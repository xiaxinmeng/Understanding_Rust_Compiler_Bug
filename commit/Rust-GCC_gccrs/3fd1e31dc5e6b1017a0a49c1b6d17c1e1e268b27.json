{"sha": "3fd1e31dc5e6b1017a0a49c1b6d17c1e1e268b27", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2ZkMWUzMWRjNWU2YjEwMTdhMGE0OWMxYjZkMTdjMWUxZTI2OGIyNw==", "commit": {"author": {"name": "Georg-Johann Lay", "email": "avr@gjlay.de", "date": "2012-09-28T08:21:06Z"}, "committer": {"name": "Georg-Johann Lay", "email": "gjl@gcc.gnu.org", "date": "2012-09-28T08:21:06Z"}, "message": "re PR rtl-optimization/52543 (lower-subreg.c: code bloat of 300%-400% for multi-word memory splits)\n\n\tPR rtl-optimization/52543\n\t* config/avr/avr.c (avr_mode_dependent_address_p): Return true for\n\tall non-generic address spaces.\n\t(TARGET_SECONDARY_RELOAD): New hook define to...\n\t(avr_secondary_reload): ...this new static function.\n\t* config/avr/avr.md (reload_in<mode>): New insns.\n\tUndo r185605 (mostly):\n\t* config/avr/avr-protos.h (avr_load_lpm): Remove.\n\t* config/avr/avr.c (avr_load_libgcc_p): Don't restrict to __flash loads.\n\t(avr_out_lpm): Also handle loads > 1 byte.\n\t(avr_load_lpm): Remove.\n\t(avr_find_unused_d_reg): New static function.\n\t(avr_out_lpm_no_lpmx): New static function.\n\t(adjust_insn_length): Remove ADJUST_LEN_LOAD_LPM.\n\t* config/avr/avr.md (unspec): Remove UNSPEC_LPM.\n\t(load_<mode>_libgcc): Use MEM instead of UNSPEC_LPM.\n\t(load_<mode>, load_<mode>_clobber): Remove.\n\t(mov<mode>): For multi-byte move from non-generic\n\t16-bit address spaces: Expand to *mov<mode> again.\n\t(load<mode>_libgcc): New expander.\n\t(split-lpmx): Remove split.\n\nFrom-SVN: r191820", "tree": {"sha": "cb5b381dedfa92278ef86432edd69d0a6e334ac4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cb5b381dedfa92278ef86432edd69d0a6e334ac4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3fd1e31dc5e6b1017a0a49c1b6d17c1e1e268b27", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3fd1e31dc5e6b1017a0a49c1b6d17c1e1e268b27", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3fd1e31dc5e6b1017a0a49c1b6d17c1e1e268b27", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3fd1e31dc5e6b1017a0a49c1b6d17c1e1e268b27/comments", "author": null, "committer": {"login": "sprintersb", "id": 8905355, "node_id": "MDQ6VXNlcjg5MDUzNTU=", "avatar_url": "https://avatars.githubusercontent.com/u/8905355?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sprintersb", "html_url": "https://github.com/sprintersb", "followers_url": "https://api.github.com/users/sprintersb/followers", "following_url": "https://api.github.com/users/sprintersb/following{/other_user}", "gists_url": "https://api.github.com/users/sprintersb/gists{/gist_id}", "starred_url": "https://api.github.com/users/sprintersb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sprintersb/subscriptions", "organizations_url": "https://api.github.com/users/sprintersb/orgs", "repos_url": "https://api.github.com/users/sprintersb/repos", "events_url": "https://api.github.com/users/sprintersb/events{/privacy}", "received_events_url": "https://api.github.com/users/sprintersb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "af710874e9402567635008a88279e9ab02227b2d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af710874e9402567635008a88279e9ab02227b2d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/af710874e9402567635008a88279e9ab02227b2d"}], "stats": {"total": 699, "additions": 463, "deletions": 236}, "files": [{"sha": "fdabc44347c6395e7ed20060fd66d166e1270880", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fd1e31dc5e6b1017a0a49c1b6d17c1e1e268b27/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fd1e31dc5e6b1017a0a49c1b6d17c1e1e268b27/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3fd1e31dc5e6b1017a0a49c1b6d17c1e1e268b27", "patch": "@@ -1,3 +1,28 @@\n+2012-09-28  Georg-Johann Lay  <avr@gjlay.de>\n+\n+\tPR rtl-optimization/52543\n+\t* config/avr/avr.c (avr_mode_dependent_address_p): Return true for\n+\tall non-generic address spaces.\n+\t(TARGET_SECONDARY_RELOAD): New hook define to...\n+\t(avr_secondary_reload): ...this new static function.\n+\t* config/avr/avr.md (reload_in<mode>): New insns.\n+\n+\tUndo r185605 (mostly):\n+\t* config/avr/avr-protos.h (avr_load_lpm): Remove.\n+\t* config/avr/avr.c (avr_load_libgcc_p): Don't restrict to __flash loads.\n+\t(avr_out_lpm): Also handle loads > 1 byte.\n+\t(avr_load_lpm): Remove.\n+\t(avr_find_unused_d_reg): New static function.\n+\t(avr_out_lpm_no_lpmx): New static function.\n+\t(adjust_insn_length): Remove ADJUST_LEN_LOAD_LPM.\n+\t* config/avr/avr.md (unspec): Remove UNSPEC_LPM.\n+\t(load_<mode>_libgcc): Use MEM instead of UNSPEC_LPM.\n+\t(load_<mode>, load_<mode>_clobber): Remove.\n+\t(mov<mode>): For multi-byte move from non-generic\n+\t16-bit address spaces: Expand to *mov<mode> again.\n+\t(load<mode>_libgcc): New expander.\n+\t(split-lpmx): Remove split.\n+\n 2012-09-27  Dehao Chen  <dehao@google.com>\n \n \t* tree.h (tree_constructor): Remove IS_UNKNOWN_LOCATION."}, {"sha": "91cac4c210967cc305bf690bc8afbf18b9c7f0cd", "filename": "gcc/config/avr/avr-protos.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fd1e31dc5e6b1017a0a49c1b6d17c1e1e268b27/gcc%2Fconfig%2Favr%2Favr-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fd1e31dc5e6b1017a0a49c1b6d17c1e1e268b27/gcc%2Fconfig%2Favr%2Favr-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr-protos.h?ref=3fd1e31dc5e6b1017a0a49c1b6d17c1e1e268b27", "patch": "@@ -75,8 +75,6 @@ extern const char *avr_out_ashlpsi3 (rtx, rtx*, int*);\n extern const char *avr_out_ashrpsi3 (rtx, rtx*, int*);\n extern const char *avr_out_lshrpsi3 (rtx, rtx*, int*);\n \n-extern const char* avr_load_lpm (rtx, rtx*, int*);\n-\n extern bool avr_rotate_bytes (rtx operands[]);\n \n extern const char* avr_out_fract (rtx, rtx[], bool, int*);"}, {"sha": "c9740bae9bc31c808dedcf4e378b16a8ccf3d96e", "filename": "gcc/config/avr/avr.c", "status": "modified", "additions": 342, "deletions": 129, "changes": 471, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fd1e31dc5e6b1017a0a49c1b6d17c1e1e268b27/gcc%2Fconfig%2Favr%2Favr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fd1e31dc5e6b1017a0a49c1b6d17c1e1e268b27/gcc%2Fconfig%2Favr%2Favr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.c?ref=3fd1e31dc5e6b1017a0a49c1b6d17c1e1e268b27", "patch": "@@ -1625,17 +1625,17 @@ avr_cannot_modify_jumps_p (void)\n \n /* Implement `TARGET_MODE_DEPENDENT_ADDRESS_P'.  */\n \n-/* FIXME:  PSImode addresses are not mode-dependent in themselves.\n-      This hook just serves to hack around PR rtl-optimization/52543 by\n-      claiming that PSImode addresses (which are used for the 24-bit\n-      address space __memx) were mode-dependent so that lower-subreg.s\n-      will skip these addresses.  See also the similar FIXME comment along\n-      with mov<mode> expanders in avr.md.  */\n-\n static bool\n-avr_mode_dependent_address_p (const_rtx addr, addr_space_t as ATTRIBUTE_UNUSED)\n+avr_mode_dependent_address_p (const_rtx addr ATTRIBUTE_UNUSED, addr_space_t as)\n {\n-  return GET_MODE (addr) != Pmode;\n+  /* FIXME:  Non-generic addresses are not mode-dependent in themselves.\n+       This hook just serves to hack around PR rtl-optimization/52543 by\n+       claiming that non-generic addresses were mode-dependent so that\n+       lower-subreg.c will skip these addresses.  lower-subreg.c sets up fake\n+       RTXes to probe SET and MEM costs and assumes that MEM is always in the\n+       generic address space which is not true.  */\n+\n+  return !ADDR_SPACE_GENERIC_P (as);\n }\n \n \n@@ -1865,6 +1865,50 @@ avr_legitimize_reload_address (rtx *px, enum machine_mode mode,\n }\n \n \n+/* Implement `TARGET_SECONDARY_RELOAD' */\n+\n+static reg_class_t\n+avr_secondary_reload (bool in_p, rtx x,\n+                      reg_class_t reload_class ATTRIBUTE_UNUSED,\n+                      enum machine_mode mode, secondary_reload_info *sri)\n+{\n+  if (in_p\n+      && MEM_P (x)\n+      && !ADDR_SPACE_GENERIC_P (MEM_ADDR_SPACE (x))\n+      && ADDR_SPACE_MEMX != MEM_ADDR_SPACE (x))\n+    {\n+      /* For the non-generic 16-bit spaces we need a d-class scratch.  */\n+\n+      switch (mode)\n+        {\n+        default:\n+          gcc_unreachable();\n+\n+        case QImode:  sri->icode = CODE_FOR_reload_inqi; break;\n+        case QQmode:  sri->icode = CODE_FOR_reload_inqq; break;\n+        case UQQmode: sri->icode = CODE_FOR_reload_inuqq; break;\n+\n+        case HImode:  sri->icode = CODE_FOR_reload_inhi; break;\n+        case HQmode:  sri->icode = CODE_FOR_reload_inhq; break;\n+        case HAmode:  sri->icode = CODE_FOR_reload_inha; break;\n+        case UHQmode: sri->icode = CODE_FOR_reload_inuhq; break;\n+        case UHAmode: sri->icode = CODE_FOR_reload_inuha; break;\n+\n+        case PSImode: sri->icode = CODE_FOR_reload_inpsi; break;\n+\n+        case SImode:  sri->icode = CODE_FOR_reload_insi; break;\n+        case SFmode:  sri->icode = CODE_FOR_reload_insf; break;\n+        case SQmode:  sri->icode = CODE_FOR_reload_insq; break;\n+        case SAmode:  sri->icode = CODE_FOR_reload_insa; break;\n+        case USQmode: sri->icode = CODE_FOR_reload_inusq; break;\n+        case USAmode: sri->icode = CODE_FOR_reload_inusa; break;\n+        }\n+    }\n+\n+  return NO_REGS;\n+}\n+\n+\n /* Helper function to print assembler resp. track instruction\n    sequence lengths.  Always return \"\".\n    \n@@ -2655,8 +2699,7 @@ avr_load_libgcc_p (rtx op)\n         \n   return (n_bytes > 2\n           && !AVR_HAVE_LPMX\n-          && MEM_P (op)\n-          && MEM_ADDR_SPACE (op) == ADDR_SPACE_FLASH);\n+          && avr_mem_flash_p (op));\n }\n \n /* Return true if a value of mode MODE is read by __xload_* function.  */\n@@ -2671,6 +2714,157 @@ avr_xload_libgcc_p (enum machine_mode mode)\n }\n \n \n+/* Fixme: This is a hack because secondary reloads don't works as expected.\n+\n+   Find an unused d-register to be used as scratch in INSN.\n+   EXCLUDE is either NULL_RTX or some register. In the case where EXCLUDE\n+   is a register, skip all possible return values that overlap EXCLUDE.\n+   The policy for the returned register is similar to that of\n+   `reg_unused_after', i.e. the returned register may overlap the SET_DEST\n+   of INSN.\n+\n+   Return a QImode d-register or NULL_RTX if nothing found.  */\n+\n+static rtx\n+avr_find_unused_d_reg (rtx insn, rtx exclude)\n+{\n+  int regno;\n+  bool isr_p = (avr_interrupt_function_p (current_function_decl)\n+                || avr_signal_function_p (current_function_decl));\n+\n+  for (regno = 16; regno < 32; regno++)\n+    {\n+      rtx reg = all_regs_rtx[regno];\n+      \n+      if ((exclude\n+           && reg_overlap_mentioned_p (exclude, reg))\n+          || fixed_regs[regno])\n+        {\n+          continue;\n+        }\n+\n+      /* Try non-live register */\n+\n+      if (!df_regs_ever_live_p (regno)\n+          && (TREE_THIS_VOLATILE (current_function_decl)\n+              || cfun->machine->is_OS_task\n+              || cfun->machine->is_OS_main\n+              || (!isr_p && call_used_regs[regno])))\n+        {\n+          return reg;\n+        }\n+\n+      /* Any live register can be used if it is unused after.\n+         Prologue/epilogue will care for it as needed.  */\n+      \n+      if (df_regs_ever_live_p (regno)\n+          && reg_unused_after (insn, reg))\n+        {\n+          return reg;\n+        }\n+    }\n+\n+  return NULL_RTX;\n+}\n+\n+\n+/* Helper function for the next function in the case where only restricted\n+   version of LPM instruction is available.  */\n+\n+static const char*\n+avr_out_lpm_no_lpmx (rtx insn, rtx *xop, int *plen)\n+{\n+  rtx dest = xop[0];\n+  rtx addr = xop[1];\n+  int n_bytes = GET_MODE_SIZE (GET_MODE (dest));\n+  int regno_dest;\n+\n+  regno_dest = REGNO (dest);\n+\n+  /* The implicit target register of LPM.  */\n+  xop[3] = lpm_reg_rtx;\n+\n+  switch (GET_CODE (addr))\n+    {\n+    default:\n+      gcc_unreachable();\n+\n+    case REG:\n+\n+      gcc_assert (REG_Z == REGNO (addr));\n+\n+      switch (n_bytes)\n+        {\n+        default:\n+          gcc_unreachable();\n+\n+        case 1:\n+          avr_asm_len (\"%4lpm\", xop, plen, 1);\n+\n+          if (regno_dest != LPM_REGNO)\n+            avr_asm_len (\"mov %0,%3\", xop, plen, 1);\n+\n+          return \"\";\n+\n+        case 2:\n+          if (REGNO (dest) == REG_Z)\n+            return avr_asm_len (\"%4lpm\"      CR_TAB\n+                                \"push %3\"    CR_TAB\n+                                \"adiw %2,1\"  CR_TAB\n+                                \"%4lpm\"      CR_TAB\n+                                \"mov %B0,%3\" CR_TAB\n+                                \"pop %A0\", xop, plen, 6);\n+          \n+          avr_asm_len (\"%4lpm\"      CR_TAB\n+                       \"mov %A0,%3\" CR_TAB\n+                       \"adiw %2,1\"  CR_TAB\n+                       \"%4lpm\"      CR_TAB\n+                       \"mov %B0,%3\", xop, plen, 5);\n+                \n+          if (!reg_unused_after (insn, addr))\n+            avr_asm_len (\"sbiw %2,1\", xop, plen, 1);\n+          \n+          break; /* 2 */\n+        }\n+      \n+      break; /* REG */\n+\n+    case POST_INC:\n+\n+      gcc_assert (REG_Z == REGNO (XEXP (addr, 0))\n+                  && n_bytes <= 4);\n+\n+      if (regno_dest == LPM_REGNO)\n+        avr_asm_len (\"%4lpm\"      CR_TAB\n+                     \"adiw %2,1\", xop, plen, 2);\n+      else\n+        avr_asm_len (\"%4lpm\"      CR_TAB\n+                     \"mov %A0,%3\" CR_TAB\n+                     \"adiw %2,1\", xop, plen, 3);\n+\n+      if (n_bytes >= 2)\n+        avr_asm_len (\"%4lpm\"      CR_TAB\n+                     \"mov %B0,%3\" CR_TAB\n+                     \"adiw %2,1\", xop, plen, 3);\n+\n+      if (n_bytes >= 3)\n+        avr_asm_len (\"%4lpm\"      CR_TAB\n+                     \"mov %C0,%3\" CR_TAB\n+                     \"adiw %2,1\", xop, plen, 3);\n+\n+      if (n_bytes >= 4)\n+        avr_asm_len (\"%4lpm\"      CR_TAB\n+                     \"mov %D0,%3\" CR_TAB\n+                     \"adiw %2,1\", xop, plen, 3);\n+\n+      break; /* POST_INC */\n+      \n+    } /* switch CODE (addr) */\n+      \n+  return \"\";\n+}\n+\n+\n /* If PLEN == NULL: Ouput instructions to load a value from a memory location\n    OP[1] in AS1 to register OP[0].\n    If PLEN != 0 set *PLEN to the length in words of the instruction sequence.\n@@ -2679,11 +2873,13 @@ avr_xload_libgcc_p (enum machine_mode mode)\n static const char*\n avr_out_lpm (rtx insn, rtx *op, int *plen)\n {\n-  rtx xop[3];\n+  rtx xop[7];\n   rtx dest = op[0];\n   rtx src = SET_SRC (single_set (insn));\n   rtx addr;\n   int n_bytes = GET_MODE_SIZE (GET_MODE (dest));\n+  int regno_dest;\n+  int segment;\n   RTX_CODE code;\n   addr_space_t as = MEM_ADDR_SPACE (src);\n \n@@ -2704,124 +2900,142 @@ avr_out_lpm (rtx insn, rtx *op, int *plen)\n   gcc_assert (REG_P (dest));\n   gcc_assert (REG == code || POST_INC == code);\n \n-  /* Only 1-byte moves from __flash are representes as open coded\n-     mov insns.  All other loads from flash are not handled here but\n-     by some UNSPEC instead, see respective FIXME in machine description.  */\n-  \n-  gcc_assert (as == ADDR_SPACE_FLASH);\n-  gcc_assert (n_bytes == 1);\n-\n   xop[0] = dest;\n-  xop[1] = lpm_addr_reg_rtx;\n-  xop[2] = lpm_reg_rtx;\n+  xop[1] = addr;\n+  xop[2] = lpm_addr_reg_rtx;\n+  xop[4] = xstring_empty;\n+  xop[5] = tmp_reg_rtx;\n+  xop[6] = XEXP (rampz_rtx, 0);\n \n-  switch (code)\n+  regno_dest = REGNO (dest);\n+\n+  segment = avr_addrspace[as].segment;\n+\n+  /* Set RAMPZ as needed.  */\n+\n+  if (segment)\n+    {\n+      xop[4] = GEN_INT (segment);\n+      xop[3] = avr_find_unused_d_reg (insn, lpm_addr_reg_rtx);\n+\n+      if (xop[3] != NULL_RTX)\n+        {\n+          avr_asm_len (\"ldi %3,%4\" CR_TAB\n+                       \"out %i6,%3\", xop, plen, 2);\n+        }\n+      else if (segment == 1)\n+        {\n+          avr_asm_len (\"clr %5\" CR_TAB\n+                       \"inc %5\" CR_TAB\n+                       \"out %i6,%5\", xop, plen, 3);\n+        }\n+      else\n+        {\n+          avr_asm_len (\"mov %5,%2\"         CR_TAB\n+                       \"ldi %2,%4\"         CR_TAB\n+                       \"out %i6,%2\"  CR_TAB\n+                       \"mov %2,%5\", xop, plen, 4);\n+        }\n+      \n+      xop[4] = xstring_e;\n+\n+      if (!AVR_HAVE_ELPMX)\n+        return avr_out_lpm_no_lpmx (insn, xop, plen);\n+    }\n+  else if (!AVR_HAVE_LPMX)\n+    {\n+      return avr_out_lpm_no_lpmx (insn, xop, plen);\n+    }\n+\n+  /* We have [E]LPMX: Output reading from Flash the comfortable way.  */\n+\n+  switch (GET_CODE (addr))\n     {\n     default:\n       gcc_unreachable();\n \n     case REG:\n \n       gcc_assert (REG_Z == REGNO (addr));\n-      \n-      return AVR_HAVE_LPMX\n-        ? avr_asm_len (\"lpm %0,%a1\", xop, plen, 1)\n-        : avr_asm_len (\"lpm\" CR_TAB\n-                       \"mov %0,%2\", xop, plen, 2);\n-      \n-    case POST_INC:\n-      \n-      gcc_assert (REG_Z == REGNO (XEXP (addr, 0)));\n \n-      return AVR_HAVE_LPMX\n-        ? avr_asm_len (\"lpm %0,%a1+\", xop, plen, 1)\n-        : avr_asm_len (\"lpm\"        CR_TAB\n-                       \"adiw %1, 1\" CR_TAB\n-                       \"mov %0,%2\", xop, plen, 3);\n-    }\n+      switch (n_bytes)\n+        {\n+        default:\n+          gcc_unreachable();\n \n-  return \"\";\n-}\n+        case 1:\n+          return avr_asm_len (\"%4lpm %0,%a2\", xop, plen, 1);\n \n+        case 2:\n+          if (REGNO (dest) == REG_Z)\n+            return avr_asm_len (\"%4lpm %5,%a2+\" CR_TAB\n+                                \"%4lpm %B0,%a2\" CR_TAB\n+                                \"mov %A0,%5\", xop, plen, 3);\n+          else\n+            {\n+              avr_asm_len (\"%4lpm %A0,%a2+\" CR_TAB\n+                           \"%4lpm %B0,%a2\", xop, plen, 2);\n+                \n+              if (!reg_unused_after (insn, addr))\n+                avr_asm_len (\"sbiw %2,1\", xop, plen, 1);\n+            }\n+          \n+          break; /* 2 */\n \n-/* If PLEN == NULL: Ouput instructions to load $0 with a value from\n-   flash address $1:Z.  If $1 = 0 we can use LPM to read, otherwise\n-   use ELPM.\n-   If PLEN != 0 set *PLEN to the length in words of the instruction sequence.\n-   Return \"\".  */\n+        case 3:\n \n-const char*\n-avr_load_lpm (rtx insn, rtx *op, int *plen)\n-{\n-  rtx xop[4];\n-  int n, n_bytes = GET_MODE_SIZE (GET_MODE (op[0]));\n-  rtx xsegment = op[1];\n-  bool clobber_z = PARALLEL == GET_CODE (PATTERN (insn));\n-  bool r30_in_tmp = false;\n-  \n-  if (plen)\n-    *plen = 0;\n-  \n-  xop[1] = lpm_addr_reg_rtx;\n-  xop[2] = lpm_reg_rtx;\n-  xop[3] = xstring_empty;\n-  \n-  /* Set RAMPZ as needed.  */\n-  \n-  if (REG_P (xsegment))\n-    {\n-      avr_asm_len (\"out __RAMPZ__,%0\", &xsegment, plen, 1);\n-      xop[3] = xstring_e;\n-    }\n-  \n-  /* Load the individual bytes from LSB to MSB.  */\n-  \n-  for (n = 0; n < n_bytes; n++)\n-    {\n-      xop[0] = all_regs_rtx[REGNO (op[0]) + n];\n+          avr_asm_len (\"%4lpm %A0,%a2+\" CR_TAB\n+                       \"%4lpm %B0,%a2+\" CR_TAB\n+                       \"%4lpm %C0,%a2\", xop, plen, 3);\n+                \n+          if (!reg_unused_after (insn, addr))\n+            avr_asm_len (\"sbiw %2,2\", xop, plen, 1);\n+\n+          break; /* 3 */\n       \n-      if ((CONST_INT_P (xsegment) && AVR_HAVE_LPMX)\n-          || (REG_P (xsegment) && AVR_HAVE_ELPMX))\n-        {\n-          if (n == n_bytes-1)\n-            avr_asm_len (\"%3lpm %0,%a1\", xop, plen, 1);\n-          else if (REGNO (xop[0]) == REG_Z)\n+        case 4:\n+\n+          avr_asm_len (\"%4lpm %A0,%a2+\" CR_TAB\n+                       \"%4lpm %B0,%a2+\", xop, plen, 2);\n+          \n+          if (REGNO (dest) == REG_Z - 2)\n+            return avr_asm_len (\"%4lpm %5,%a2+\" CR_TAB\n+                                \"%4lpm %C0,%a2\"          CR_TAB\n+                                \"mov %D0,%5\", xop, plen, 3);\n+          else\n             {\n-              avr_asm_len (\"%3lpm %2,%a1+\", xop, plen, 1);\n-              r30_in_tmp = true;\n+              avr_asm_len (\"%4lpm %C0,%a2+\" CR_TAB\n+                           \"%4lpm %D0,%a2\", xop, plen, 2);\n+                \n+              if (!reg_unused_after (insn, addr))\n+                avr_asm_len (\"sbiw %2,3\", xop, plen, 1);\n             }\n-          else\n-            avr_asm_len (\"%3lpm %0,%a1+\", xop, plen, 1);\n-        }\n-      else\n-        {\n-          gcc_assert (clobber_z);\n-          \n-          avr_asm_len (\"%3lpm\" CR_TAB\n-                       \"mov %0,%2\", xop, plen, 2);\n \n-          if (n != n_bytes-1)\n-            avr_asm_len (\"adiw %1,1\", xop, plen, 1);\n-        }\n-    }\n-  \n-  if (r30_in_tmp)\n-    avr_asm_len (\"mov %1,%2\", xop, plen, 1);\n-  \n-  if (!clobber_z\n-      && n_bytes > 1\n-      && !reg_unused_after (insn, lpm_addr_reg_rtx)\n-      && !reg_overlap_mentioned_p (op[0], lpm_addr_reg_rtx))\n-    {\n-      xop[2] = GEN_INT (n_bytes-1);\n-      avr_asm_len (\"sbiw %1,%2\", xop, plen, 1);\n-    }\n-  \n-  if (REG_P (xsegment) && AVR_HAVE_RAMPD)\n+          break; /* 4 */\n+        } /* n_bytes */\n+      \n+      break; /* REG */\n+\n+    case POST_INC:\n+\n+      gcc_assert (REG_Z == REGNO (XEXP (addr, 0))\n+                  && n_bytes <= 4);\n+\n+      avr_asm_len                    (\"%4lpm %A0,%a2+\", xop, plen, 1);\n+      if (n_bytes >= 2)  avr_asm_len (\"%4lpm %B0,%a2+\", xop, plen, 1);\n+      if (n_bytes >= 3)  avr_asm_len (\"%4lpm %C0,%a2+\", xop, plen, 1);\n+      if (n_bytes >= 4)  avr_asm_len (\"%4lpm %D0,%a2+\", xop, plen, 1);\n+\n+      break; /* POST_INC */\n+\n+    } /* switch CODE (addr) */\n+\n+  if (xop[4] == xstring_e && AVR_HAVE_RAMPD)\n     {\n       /* Reset RAMPZ to 0 so that EBI devices don't read garbage from RAM */\n-      \n-      avr_asm_len (\"out __RAMPZ__,__zero_reg__\", xop, plen, 1);\n+\n+      xop[0] = zero_reg_rtx;\n+      avr_asm_len (\"out %i6,%0\", xop, plen, 1);\n     }\n \n   return \"\";\n@@ -2857,40 +3071,37 @@ avr_out_xload (rtx insn ATTRIBUTE_UNUSED, rtx *op, int *plen)\n \n \n const char*\n-output_movqi (rtx insn, rtx operands[], int *real_l)\n+output_movqi (rtx insn, rtx operands[], int *plen)\n {\n   rtx dest = operands[0];\n   rtx src = operands[1];\n   \n   if (avr_mem_flash_p (src)\n       || avr_mem_flash_p (dest))\n     {\n-      return avr_out_lpm (insn, operands, real_l);\n+      return avr_out_lpm (insn, operands, plen);\n     }\n \n-  if (real_l)\n-    *real_l = 1;\n-  \n   gcc_assert (1 == GET_MODE_SIZE (GET_MODE (dest)));\n \n   if (REG_P (dest))\n     {\n       if (REG_P (src)) /* mov r,r */\n-\t{\n-\t  if (test_hard_reg_class (STACK_REG, dest))\n-\t    return \"out %0,%1\";\n-\t  else if (test_hard_reg_class (STACK_REG, src))\n-\t    return \"in %0,%1\";\n-\t  \n-\t  return \"mov %0,%1\";\n-\t}\n+        {\n+          if (test_hard_reg_class (STACK_REG, dest))\n+            return avr_asm_len (\"out %0,%1\", operands, plen, -1);\n+          else if (test_hard_reg_class (STACK_REG, src))\n+            return avr_asm_len (\"in %0,%1\", operands, plen, -1);\n+          \n+          return avr_asm_len (\"mov %0,%1\", operands, plen, -1);\n+        }\n       else if (CONSTANT_P (src))\n         {\n-          output_reload_in_const (operands, NULL_RTX, real_l, false);\n+          output_reload_in_const (operands, NULL_RTX, plen, false);\n           return \"\";\n         }\n       else if (MEM_P (src))\n-\treturn out_movqi_r_mr (insn, operands, real_l); /* mov r,m */\n+        return out_movqi_r_mr (insn, operands, plen); /* mov r,m */\n     }\n   else if (MEM_P (dest))\n     {\n@@ -2899,8 +3110,9 @@ output_movqi (rtx insn, rtx operands[], int *real_l)\n       xop[0] = dest;\n       xop[1] = src == CONST0_RTX (GET_MODE (dest)) ? zero_reg_rtx : src;\n \n-      return out_movqi_mr_r (insn, xop, real_l);\n+      return out_movqi_mr_r (insn, xop, plen);\n     }\n+\n   return \"\";\n }\n \n@@ -7314,7 +7526,6 @@ adjust_insn_length (rtx insn, int len)\n     case ADJUST_LEN_MOV32: output_movsisf (insn, op, &len); break;\n     case ADJUST_LEN_MOVMEM: avr_out_movmem (insn, op, &len); break;\n     case ADJUST_LEN_XLOAD: avr_out_xload (insn, op, &len); break;\n-    case ADJUST_LEN_LOAD_LPM: avr_load_lpm (insn, op, &len); break;\n \n     case ADJUST_LEN_SFRACT: avr_out_fract (insn, op, true, &len); break;\n     case ADJUST_LEN_UFRACT: avr_out_fract (insn, op, false, &len); break;\n@@ -10337,8 +10548,7 @@ avr_addr_space_pointer_mode (addr_space_t as)\n static bool\n avr_reg_ok_for_pgm_addr (rtx reg, bool strict)\n {\n-  if (!REG_P (reg))\n-    return false;\n+  gcc_assert (REG_P (reg));\n \n   if (strict)\n     {\n@@ -11710,6 +11920,9 @@ avr_fold_builtin (tree fndecl, int n_args ATTRIBUTE_UNUSED, tree *arg,\n #undef  TARGET_MODE_DEPENDENT_ADDRESS_P\n #define TARGET_MODE_DEPENDENT_ADDRESS_P avr_mode_dependent_address_p\n \n+#undef  TARGET_SECONDARY_RELOAD\n+#define TARGET_SECONDARY_RELOAD avr_secondary_reload\n+\n #undef  TARGET_PRINT_OPERAND\n #define TARGET_PRINT_OPERAND avr_print_operand\n #undef  TARGET_PRINT_OPERAND_ADDRESS"}, {"sha": "334064337cdd05d9389b8874708f503ab6f334f6", "filename": "gcc/config/avr/avr.md", "status": "modified", "additions": 96, "deletions": 105, "changes": 201, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fd1e31dc5e6b1017a0a49c1b6d17c1e1e268b27/gcc%2Fconfig%2Favr%2Favr.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fd1e31dc5e6b1017a0a49c1b6d17c1e1e268b27/gcc%2Fconfig%2Favr%2Favr.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.md?ref=3fd1e31dc5e6b1017a0a49c1b6d17c1e1e268b27", "patch": "@@ -63,7 +63,6 @@\n   [UNSPEC_STRLEN\n    UNSPEC_MOVMEM\n    UNSPEC_INDEX_JMP\n-   UNSPEC_LPM\n    UNSPEC_FMUL\n    UNSPEC_FMULS\n    UNSPEC_FMULSU\n@@ -142,7 +141,7 @@\n    tsthi, tstpsi, tstsi, compare, compare64, call,\n    mov8, mov16, mov24, mov32, reload_in16, reload_in24, reload_in32,\n    ufract, sfract,\n-   xload, movmem, load_lpm,\n+   xload, movmem,\n    ashlqi, ashrqi, lshrqi,\n    ashlhi, ashrhi, lshrhi,\n    ashlsi, ashrsi, lshrsi,\n@@ -393,60 +392,57 @@\n ;;========================================================================\n ;; Move stuff around\n \n-;; Represent a load from __flash that needs libgcc support as UNSPEC.\n-;; This is legal because we read from non-changing memory.\n-;; For rationale see the FIXME below.\n-\n-;; \"load_psi_libgcc\"    \n-;; \"load_si_libgcc\"    \n-;; \"load_sf_libgcc\"    \n-(define_insn \"load_<mode>_libgcc\"\n-  [(set (reg:MOVMODE 22)\n-        (unspec:MOVMODE [(reg:HI REG_Z)]\n-                        UNSPEC_LPM))]\n-  \"\"\n-  {\n-    rtx n_bytes = GEN_INT (GET_MODE_SIZE (<MODE>mode));\n-    output_asm_insn (\"%~call __load_%0\", &n_bytes);\n-    return \"\";\n-  }\n-  [(set_attr \"type\" \"xcall\")\n-   (set_attr \"cc\" \"clobber\")])\n-\n-\n-;; Similar for inline reads from flash.  We use UNSPEC instead\n-;; of MEM for the same reason as above: PR52543.\n-;; $1 contains the memory segment.\n-\n-(define_insn \"load_<mode>\"\n-  [(set (match_operand:MOVMODE 0 \"register_operand\" \"=r\")\n-        (unspec:MOVMODE [(reg:HI REG_Z)\n-                         (match_operand:QI 1 \"reg_or_0_operand\" \"rL\")]\n-                        UNSPEC_LPM))]\n-  \"(CONST_INT_P (operands[1]) && AVR_HAVE_LPMX)\n-   || (REG_P (operands[1]) && AVR_HAVE_ELPMX)\"\n+;; Secondary input reload from non-generic 16-bit address spaces\n+(define_insn \"reload_in<mode>\"\n+  [(set (match_operand:MOVMODE 0 \"register_operand\"   \"=r\")\n+        (match_operand:MOVMODE 1 \"memory_operand\"      \"m\"))\n+   (clobber (match_operand:QI 2 \"d_register_operand\"  \"=d\"))]\n+  \"MEM_P (operands[1])\n+   && !ADDR_SPACE_GENERIC_P (MEM_ADDR_SPACE (operands[1]))\"\n   {\n-    return avr_load_lpm (insn, operands, NULL);\n+    return output_movqi (insn, operands, NULL);\n   }\n-  [(set_attr \"adjust_len\" \"load_lpm\")\n+  [(set_attr \"adjust_len\" \"mov8\")\n    (set_attr \"cc\" \"clobber\")])\n \n \n-;; Similar to above for the complementary situation when there is no [E]LPMx.\n-;; Clobber Z in that case.\n+;; \"loadqi_libgcc\"\n+;; \"loadhi_libgcc\"\n+;; \"loadpsi_libgcc\"    \n+;; \"loadsi_libgcc\"    \n+;; \"loadsf_libgcc\"    \n+(define_expand \"load<mode>_libgcc\"\n+  [(set (match_dup 3)\n+        (match_dup 2))\n+   (set (reg:MOVMODE 22)\n+        (match_operand:MOVMODE 1 \"memory_operand\" \"\"))\n+   (set (match_operand:MOVMODE 0 \"register_operand\" \"\")\n+        (reg:MOVMODE 22))]\n+  \"avr_load_libgcc_p (operands[1])\"\n+  {\n+    operands[3] = gen_rtx_REG (HImode, REG_Z);\n+    operands[2] = force_operand (XEXP (operands[1], 0), NULL_RTX);\n+    operands[1] = replace_equiv_address (operands[1], operands[3]);\n+    set_mem_addr_space (operands[1], ADDR_SPACE_FLASH);\n+  })\n \n-(define_insn \"load_<mode>_clobber\"\n-  [(set (match_operand:MOVMODE 0 \"register_operand\" \"=r\")\n-        (unspec:MOVMODE [(reg:HI REG_Z)\n-                         (match_operand:QI 1 \"reg_or_0_operand\" \"rL\")]\n-                        UNSPEC_LPM))\n-   (clobber (reg:HI REG_Z))]\n-  \"!((CONST_INT_P (operands[1]) && AVR_HAVE_LPMX)\n-     || (REG_P (operands[1]) && AVR_HAVE_ELPMX))\"\n+;; \"load_qi_libgcc\"\n+;; \"load_hi_libgcc\"\n+;; \"load_psi_libgcc\"    \n+;; \"load_si_libgcc\"    \n+;; \"load_sf_libgcc\"    \n+(define_insn \"load_<mode>_libgcc\"\n+  [(set (reg:MOVMODE 22)\n+        (match_operand:MOVMODE 0 \"memory_operand\" \"m,m\"))]\n+  \"avr_load_libgcc_p (operands[0])\n+   && REG_P (XEXP (operands[0], 0))\n+   && REG_Z == REGNO (XEXP (operands[0], 0))\"\n   {\n-    return avr_load_lpm (insn, operands, NULL);\n+    operands[0] = GEN_INT (GET_MODE_SIZE (<MODE>mode));\n+    return \"%~call __load_%0\";\n   }\n-  [(set_attr \"adjust_len\" \"load_lpm\")\n+  [(set_attr \"length\" \"1,2\")\n+   (set_attr \"isa\" \"rjmp,jmp\")\n    (set_attr \"cc\" \"clobber\")])\n \n \n@@ -464,6 +460,10 @@\n   \"&& 1\"\n   [(clobber (const_int 0))]\n   {\n+    /* ; Split away the high part of the address.  GCC's register allocator\n+       ; in not able to allocate segment registers and reload the resulting\n+       ; expressions.  Notice that no address register can hold a PSImode.  */\n+\n     rtx insn, addr = XEXP (operands[1], 0);\n     rtx hi8 = gen_reg_rtx (QImode);\n     rtx reg_z = gen_rtx_REG (HImode, REG_Z);\n@@ -583,72 +583,29 @@\n         operands[1] = src = copy_to_mode_reg (<MODE>mode, src);\n       }\n \n-  if (avr_mem_memx_p (src))\n-    {\n-      rtx addr = XEXP (src, 0);\n-\n-      if (!REG_P (addr))\n-        src = replace_equiv_address (src, copy_to_mode_reg (PSImode, addr));\n-\n-      if (!avr_xload_libgcc_p (<MODE>mode))\n-        /* ; No <mode> here because gen_xload8<mode>_A only iterates over ALL1.\n-           ; insn-emit does not depend on the mode, it' all about operands.  */\n-        emit_insn (gen_xload8qi_A (dest, src));\n-      else\n-        emit_insn (gen_xload<mode>_A (dest, src));\n-\n-      DONE;\n-    }\n+    if (avr_mem_memx_p (src))\n+      {\n+        rtx addr = XEXP (src, 0);\n \n-    /* For old devices without LPMx, prefer __flash loads per libcall.  */\n+        if (!REG_P (addr))\n+          src = replace_equiv_address (src, copy_to_mode_reg (PSImode, addr));\n \n-    if (avr_load_libgcc_p (src))\n-      {\n-        emit_move_insn (gen_rtx_REG (Pmode, REG_Z),\n-                        force_reg (Pmode, XEXP (src, 0)));\n+        if (!avr_xload_libgcc_p (<MODE>mode))\n+          /* ; No <mode> here because gen_xload8<mode>_A only iterates over ALL1.\n+             ; insn-emit does not depend on the mode, it's all about operands.  */\n+          emit_insn (gen_xload8qi_A (dest, src));\n+        else\n+          emit_insn (gen_xload<mode>_A (dest, src));\n \n-        emit_insn (gen_load_<mode>_libgcc ());\n-        emit_move_insn (dest, gen_rtx_REG (<MODE>mode, 22));\n         DONE;\n       }\n \n-    /* ; FIXME:  Hack around PR rtl-optimization/52543.\n-       ; lower-subreg.c splits loads from the 16-bit address spaces which\n-       ; causes code bloat because each load need his setting of RAMPZ.\n-       ; Moreover, the split will happen in such a way that the loads don't\n-       ; take advantage of POST_INC addressing.  Thus, we use UNSPEC to\n-       ; represent these loads instead.  Notice that this is legitimate\n-       ; because the memory content does not change:  Loads from the same\n-       ; address will yield the same value.\n-       ; POST_INC addressing would make the addresses mode_dependent and could\n-       ; work around that PR, too.  However, notice that it is *not* legitimate\n-       ; to expand to POST_INC at expand time:  The following passes assert\n-       ; that pre-/post-modify addressing is introduced by .auto_inc_dec and\n-       ; does not exist before that pass.  */\n-\n-    if (avr_mem_flash_p (src)\n-        && (GET_MODE_SIZE (<MODE>mode) > 1\n-            || MEM_ADDR_SPACE (src) != ADDR_SPACE_FLASH))\n+    if (avr_load_libgcc_p (src))\n       {\n-        rtx xsegment = GEN_INT (avr_addrspace[MEM_ADDR_SPACE (src)].segment);\n-        if (!AVR_HAVE_ELPM)\n-          xsegment = const0_rtx;\n-        if (xsegment != const0_rtx)\n-          xsegment = force_reg (QImode, xsegment);\n-\n-        emit_move_insn (gen_rtx_REG (Pmode, REG_Z),\n-                        force_reg (Pmode, XEXP (src, 0)));\n-\n-        if ((CONST_INT_P (xsegment) && AVR_HAVE_LPMX)\n-            || (REG_P (xsegment) && AVR_HAVE_ELPMX))\n-          emit_insn (gen_load_<mode> (dest, xsegment));\n-        else\n-          emit_insn (gen_load_<mode>_clobber (dest, xsegment));\n+        /* For the small devices, do loads per libgcc call.  */\n+        emit_insn (gen_load<mode>_libgcc (dest, src));\n         DONE;\n       }\n-\n-    /* ; The only address-space for which we use plain MEM and reload\n-       ; machinery are 1-byte loads from __flash.  */\n   })\n \n ;;========================================================================\n@@ -798,6 +755,40 @@\n     operands[5] = gen_rtx_REG (HImode, REGNO (operands[3]));\n   })\n \n+;; For LPM loads from AS1 we split \n+;;    R = *Z\n+;; to\n+;;    R = *Z++\n+;;    Z = Z - sizeof (R)\n+;;\n+;; so that the second instruction can be optimized out.\n+\n+(define_split ; \"split-lpmx\"\n+  [(set (match_operand:HISI 0 \"register_operand\" \"\")\n+        (match_operand:HISI 1 \"memory_operand\" \"\"))]\n+  \"reload_completed\n+   && AVR_HAVE_LPMX\"\n+  [(set (match_dup 0)\n+        (match_dup 2))\n+   (set (match_dup 3)\n+        (plus:HI (match_dup 3)\n+                 (match_dup 4)))]\n+  {\n+     rtx addr = XEXP (operands[1], 0);\n+\n+     if (!avr_mem_flash_p (operands[1])\n+         || !REG_P (addr)\n+         || reg_overlap_mentioned_p (addr, operands[0]))\n+       {\n+         FAIL;\n+       }\n+\n+    operands[2] = replace_equiv_address (operands[1],\n+                                         gen_rtx_POST_INC (Pmode, addr));\n+    operands[3] = addr;\n+    operands[4] = gen_int_mode (-GET_MODE_SIZE (<MODE>mode), HImode);\n+  })\n+\n ;;==========================================================================\n ;; xpointer move (24 bit)\n   "}]}