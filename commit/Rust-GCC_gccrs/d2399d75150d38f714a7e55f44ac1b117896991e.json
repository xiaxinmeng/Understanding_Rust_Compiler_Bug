{"sha": "d2399d75150d38f714a7e55f44ac1b117896991e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDIzOTlkNzUxNTBkMzhmNzE0YTdlNTVmNDRhYzFiMTE3ODk2OTkxZQ==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2003-09-12T15:07:50Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2003-09-12T15:07:50Z"}, "message": "re PR rtl-optimization/8967 (Making class data members `const' pessimizes code)\n\n\n\tPR optimization/8967\n\t* alias.c (write_dependence_p): Modify to take an additional constp\n\targument that controls whether the UNCHANGING_RTX_P flags are used.\n\t(anti_dependence, output_dependence): Adjust write_dependence_p\n\tcallers to pass this additional argument, to return the same result.\n\t(unchanging_anti_dependence): New variant of anti_dependence that\n\tignores the UNCHANGING_RTX_P property on memory references.\n\t* rtl.h (unchaning_anti_dependence): Prototype here.\n\t* flow.c (init_propagate_block): Place fake constant mem writes on\n\tthe mem_set_list so that dead writes to const variables are deleted.\n\t(insn_dead_p): Change anti_dependence to unchanging_anti_dependence.\n\t(mark_used_regs): Likewise.\n\nFrom-SVN: r71332", "tree": {"sha": "b74dbfb654b2ba729bd9d180dd9845f8532b8c0e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b74dbfb654b2ba729bd9d180dd9845f8532b8c0e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d2399d75150d38f714a7e55f44ac1b117896991e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d2399d75150d38f714a7e55f44ac1b117896991e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d2399d75150d38f714a7e55f44ac1b117896991e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d2399d75150d38f714a7e55f44ac1b117896991e/comments", "author": null, "committer": null, "parents": [{"sha": "f0f4da3220c5b0c14d0e88ec57ff1bc5c5e0f367", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f0f4da3220c5b0c14d0e88ec57ff1bc5c5e0f367", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f0f4da3220c5b0c14d0e88ec57ff1bc5c5e0f367"}], "stats": {"total": 66, "additions": 44, "deletions": 22}, "files": [{"sha": "eb5e258df6e5cba6b7fc75359e8d7972d0f3e72b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2399d75150d38f714a7e55f44ac1b117896991e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2399d75150d38f714a7e55f44ac1b117896991e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d2399d75150d38f714a7e55f44ac1b117896991e", "patch": "@@ -1,3 +1,18 @@\n+2003-09-12  Roger Sayle  <roger@eyesopen.com>\n+\n+\tPR optimization/8967\n+\t* alias.c (write_dependence_p): Modify to take an additional constp\n+\targument that controls whether the UNCHANGING_RTX_P flags are used.\n+\t(anti_dependence, output_dependence): Adjust write_dependence_p\n+\tcallers to pass this additional argument, to return the same result.\n+\t(unchanging_anti_dependence): New variant of anti_dependence that\n+\tignores the UNCHANGING_RTX_P property on memory references.\n+\t* rtl.h (unchaning_anti_dependence): Prototype here.\n+\t* flow.c (init_propagate_block): Place fake constant mem writes on\n+\tthe mem_set_list so that dead writes to const variables are deleted.\n+\t(insn_dead_p): Change anti_dependence to unchanging_anti_dependence.\n+\t(mark_used_regs): Likewise.\n+\n 2003-09-12  Richard Sandiford  <rsandifo@redhat.com>\n \n \t* config/mcore/mcore-protos.h (mcore_r15_operand_p): Declare."}, {"sha": "f56820ea1e28c1e5c83cfe2077f7ad5a71c2644a", "filename": "gcc/alias.c", "status": "modified", "additions": 26, "deletions": 13, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2399d75150d38f714a7e55f44ac1b117896991e/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2399d75150d38f714a7e55f44ac1b117896991e/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=d2399d75150d38f714a7e55f44ac1b117896991e", "patch": "@@ -110,7 +110,7 @@ static bool nonoverlapping_component_refs_p (tree, tree);\n static tree decl_for_component_ref (tree);\n static rtx adjust_offset_for_component_ref (tree, rtx);\n static int nonoverlapping_memrefs_p (rtx, rtx);\n-static int write_dependence_p (rtx, rtx, int);\n+static int write_dependence_p (rtx, rtx, int, int);\n \n static int nonlocal_mentioned_p_1 (rtx *, void *);\n static int nonlocal_mentioned_p (rtx);\n@@ -2202,10 +2202,11 @@ canon_true_dependence (rtx mem, enum machine_mode mem_mode, rtx mem_addr,\n }\n \n /* Returns nonzero if a write to X might alias a previous read from\n-   (or, if WRITEP is nonzero, a write to) MEM.  */\n+   (or, if WRITEP is nonzero, a write to) MEM.  If CONSTP is non-zero,\n+   honor the RTX_UNCHANGING_P flags on X and MEM.  */\n \n static int\n-write_dependence_p (rtx mem, rtx x, int writep)\n+write_dependence_p (rtx mem, rtx x, int writep, int constp)\n {\n   rtx x_addr, mem_addr;\n   rtx fixed_scalar;\n@@ -2224,15 +2225,18 @@ write_dependence_p (rtx mem, rtx x, int writep)\n   if (DIFFERENT_ALIAS_SETS_P (x, mem))\n     return 0;\n \n-  /* Unchanging memory can't conflict with non-unchanging memory.  */\n-  if (RTX_UNCHANGING_P (x) != RTX_UNCHANGING_P (mem))\n-    return 0;\n+  if (constp)\n+    {\n+      /* Unchanging memory can't conflict with non-unchanging memory.  */\n+      if (RTX_UNCHANGING_P (x) != RTX_UNCHANGING_P (mem))\n+\treturn 0;\n \n-  /* If MEM is an unchanging read, then it can't possibly conflict with\n-     the store to X, because there is at most one store to MEM, and it must\n-     have occurred somewhere before MEM.  */\n-  if (! writep && RTX_UNCHANGING_P (mem))\n-    return 0;\n+      /* If MEM is an unchanging read, then it can't possibly conflict with\n+\t the store to X, because there is at most one store to MEM, and it\n+\t must have occurred somewhere before MEM.  */\n+      if (! writep && RTX_UNCHANGING_P (mem))\n+\treturn 0;\n+    }\n \n   if (nonoverlapping_memrefs_p (x, mem))\n     return 0;\n@@ -2273,15 +2277,24 @@ write_dependence_p (rtx mem, rtx x, int writep)\n int\n anti_dependence (rtx mem, rtx x)\n {\n-  return write_dependence_p (mem, x, /*writep=*/0);\n+  return write_dependence_p (mem, x, /*writep=*/0, /*constp*/1);\n }\n \n /* Output dependence: X is written after store in MEM takes place.  */\n \n int\n output_dependence (rtx mem, rtx x)\n {\n-  return write_dependence_p (mem, x, /*writep=*/1);\n+  return write_dependence_p (mem, x, /*writep=*/1, /*constp*/1);\n+}\n+\n+/* Unchanging anti dependence: Like anti_dependence but ignores\n+   the UNCHANGING_RTX_P property on const variable references.  */\n+\n+int\n+unchanging_anti_dependence (rtx mem, rtx x)\n+{\n+  return write_dependence_p (mem, x, /*writep=*/0, /*constp*/0);\n }\n \f\n /* A subroutine of nonlocal_mentioned_p, returns 1 if *LOC mentions"}, {"sha": "66c04eecfa6f8e2b4e80c7aa83c9b87b124bae5f", "filename": "gcc/flow.c", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2399d75150d38f714a7e55f44ac1b117896991e/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2399d75150d38f714a7e55f44ac1b117896991e/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=d2399d75150d38f714a7e55f44ac1b117896991e", "patch": "@@ -1974,13 +1974,6 @@ init_propagate_block_info (basic_block bb, regset live, regset local_set,\n \t    rtx mem = SET_DEST (set);\n \t    rtx canon_mem = canon_rtx (mem);\n \n-\t    /* This optimization is performed by faking a store to the\n-\t       memory at the end of the block.  This doesn't work for\n-\t       unchanging memories because multiple stores to unchanging\n-\t       memory is illegal and alias analysis doesn't consider it.  */\n-\t    if (RTX_UNCHANGING_P (canon_mem))\n-\t      continue;\n-\n \t    if (XEXP (canon_mem, 0) == frame_pointer_rtx\n \t\t|| (GET_CODE (XEXP (canon_mem, 0)) == PLUS\n \t\t    && XEXP (XEXP (canon_mem, 0), 0) == frame_pointer_rtx\n@@ -2152,7 +2145,7 @@ insn_dead_p (struct propagate_block_info *pbi, rtx x, int call_ok,\n \t     rtx_equal_p does not check the alias set or flags, we also\n \t     must have the potential for them to conflict (anti_dependence).  */\n \t  for (temp = pbi->mem_set_list; temp != 0; temp = XEXP (temp, 1))\n-\t    if (anti_dependence (r, XEXP (temp, 0)))\n+\t    if (unchanging_anti_dependence (r, XEXP (temp, 0)))\n \t      {\n \t\trtx mem = XEXP (temp, 0);\n \n@@ -3730,7 +3723,7 @@ mark_used_regs (struct propagate_block_info *pbi, rtx x, rtx cond, rtx insn)\n \t      while (temp)\n \t\t{\n \t\t  next = XEXP (temp, 1);\n-\t\t  if (anti_dependence (XEXP (temp, 0), x))\n+\t\t  if (unchanging_anti_dependence (XEXP (temp, 0), x))\n \t\t    {\n \t\t      /* Splice temp out of the list.  */\n \t\t      if (prev)"}, {"sha": "fb1922a3b9d0490117b39a407b707e1b503a8bb7", "filename": "gcc/rtl.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2399d75150d38f714a7e55f44ac1b117896991e/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2399d75150d38f714a7e55f44ac1b117896991e/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=d2399d75150d38f714a7e55f44ac1b117896991e", "patch": "@@ -2253,6 +2253,7 @@ extern int canon_true_dependence (rtx, enum machine_mode, rtx, rtx,\n extern int read_dependence (rtx, rtx);\n extern int anti_dependence (rtx, rtx);\n extern int output_dependence (rtx, rtx);\n+extern int unchanging_anti_dependence (rtx, rtx);\n extern void mark_constant_function (void);\n extern void init_alias_once (void);\n extern void init_alias_analysis (void);"}]}