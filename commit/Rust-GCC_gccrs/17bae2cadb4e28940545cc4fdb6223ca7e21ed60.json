{"sha": "17bae2cadb4e28940545cc4fdb6223ca7e21ed60", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTdiYWUyY2FkYjRlMjg5NDA1NDVjYzRmZGI2MjIzY2E3ZTIxZWQ2MA==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2017-11-15T12:53:21Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2017-11-15T12:53:21Z"}, "message": "re PR tree-optimization/82985 (ICC: in vn_nary_build_or_lookup_1, at tree-ssa-sccvn.c:1722)\n\n2017-11-15  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/82985\n\t* g++.dg/torture/pr82985.C: Likewise.\n\nFrom-SVN: r254767", "tree": {"sha": "bebb42919534864ac792e4d046219675f3edc974", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bebb42919534864ac792e4d046219675f3edc974"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/17bae2cadb4e28940545cc4fdb6223ca7e21ed60", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/17bae2cadb4e28940545cc4fdb6223ca7e21ed60", "html_url": "https://github.com/Rust-GCC/gccrs/commit/17bae2cadb4e28940545cc4fdb6223ca7e21ed60", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/17bae2cadb4e28940545cc4fdb6223ca7e21ed60/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "86a9e738370e25b9ddb1d444fd99f9173309ce19", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86a9e738370e25b9ddb1d444fd99f9173309ce19", "html_url": "https://github.com/Rust-GCC/gccrs/commit/86a9e738370e25b9ddb1d444fd99f9173309ce19"}], "stats": {"total": 463, "additions": 463, "deletions": 0}, "files": [{"sha": "1dada439fafe2b9c46a1bffb6345cb43c387f290", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17bae2cadb4e28940545cc4fdb6223ca7e21ed60/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17bae2cadb4e28940545cc4fdb6223ca7e21ed60/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=17bae2cadb4e28940545cc4fdb6223ca7e21ed60", "patch": "@@ -1,3 +1,8 @@\n+2017-11-15  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/82985\n+\t* g++.dg/torture/pr82985.C: Likewise.\n+\n 2017-11-15  Sebastian Peryt  <sebastian.peryt@intel.com>\n \t\n \tPR target/82941"}, {"sha": "5c371835cf68115534dc9faa8c443980a58d39fe", "filename": "gcc/testsuite/g++.dg/torture/pr82985.C", "status": "added", "additions": 458, "deletions": 0, "changes": 458, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17bae2cadb4e28940545cc4fdb6223ca7e21ed60/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr82985.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17bae2cadb4e28940545cc4fdb6223ca7e21ed60/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr82985.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr82985.C?ref=17bae2cadb4e28940545cc4fdb6223ca7e21ed60", "patch": "@@ -0,0 +1,458 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-w\" } */\n+/* { dg-additional-options \"-mavx2\" { target { x86_64-*-* i?86-*-* } } } */\n+\n+namespace std {\n+template < typename _Default > struct __detector { using type = _Default; };\n+template < typename _Default, template < typename > class >\n+using __detected_or = __detector< _Default >;\n+template < typename _Default, template < typename > class _Op >\n+using __detected_or_t = typename __detected_or< _Default, _Op >::type;\n+template < typename > struct iterator_traits;\n+template < typename _Tp > struct iterator_traits< _Tp * > {\n+  typedef _Tp reference;\n+};\n+} // std\n+using std::iterator_traits;\n+template < typename _Iterator, typename > struct __normal_iterator {\n+  typename iterator_traits< _Iterator >::reference operator*();\n+  void operator++();\n+};\n+template < typename _IteratorL, typename _IteratorR, typename _Container >\n+int operator!=(__normal_iterator< _IteratorL, _Container >,\n+               __normal_iterator< _IteratorR, _Container >);\n+namespace std {\n+template < typename _Tp > struct allocator { typedef _Tp value_type; };\n+struct __allocator_traits_base {\n+  template < typename _Tp > using __pointer = typename _Tp::pointer;\n+};\n+template < typename _Alloc > struct allocator_traits : __allocator_traits_base {\n+  using pointer = __detected_or_t< typename _Alloc::value_type *, __pointer >;\n+};\n+} // std\n+typedef double __m128d __attribute__((__vector_size__(16)));\n+typedef double __m256d __attribute__((__vector_size__(32)));\n+enum { InnerVectorizedTraversal, LinearVectorizedTraversal };\n+enum { ReadOnlyAccessors };\n+template < int, typename Then, typename > struct conditional {\n+  typedef Then type;\n+};\n+template < typename Then, typename Else > struct conditional< 0, Then, Else > {\n+  typedef Else type;\n+};\n+template < typename, typename > struct is_same {\n+  enum { value };\n+};\n+template < typename T > struct is_same< T, T > {\n+  enum { value = 1 };\n+};\n+template < typename > struct traits;\n+struct accessors_level {\n+  enum { has_direct_access, has_write_access, value };\n+};\n+template < typename > struct EigenBase;\n+template < typename > struct PlainObjectBase;\n+template < typename, int = accessors_level::value > struct DenseCoeffsBase;\n+template < typename, int, int, int = 0, int = 0, int = 0 > struct Matrix;\n+template < typename > struct MatrixBase;\n+template < typename, int, int, bool = 0 > struct Block;\n+struct VectorBlock;\n+template < typename, typename > struct CwiseNullaryOp;\n+template < typename, typename, typename > struct CwiseBinaryOp;\n+template < typename, int = accessors_level::has_write_access > struct MapBase;\n+template < typename > struct packet_traits;\n+template < typename > struct unpacket_traits;\n+template < int Size, typename PacketType,\n+           int = Size == is_same< PacketType, typename unpacket_traits<\n+                                                  PacketType >::half >::value >\n+struct find_best_packet_helper;\n+template < int Size, typename PacketType >\n+struct find_best_packet_helper< Size, PacketType, 1 > {\n+  typedef PacketType type;\n+};\n+template < int Size, typename PacketType >\n+struct find_best_packet_helper< Size, PacketType, 0 > {\n+  typedef typename find_best_packet_helper<\n+      1, typename unpacket_traits< PacketType >::half >::type type;\n+};\n+template < typename T, int Size > struct find_best_packet {\n+  typedef typename find_best_packet_helper<\n+      Size, typename packet_traits< T >::type >::type type;\n+};\n+struct compute_matrix_flags {\n+  enum { ret = 1 };\n+};\n+struct ref_selector {\n+  typedef Matrix< double, 10, 1 > &type;\n+};\n+template < typename Derived > struct dense_xpr_base {\n+  typedef MatrixBase< Derived > type;\n+};\n+template < typename ExpressionType > struct is_lvalue {\n+  enum { value = traits< ExpressionType >::Flags };\n+};\n+template < typename Packet > void pmul(Packet);\n+template < typename Packet >\n+Packet pload(const typename unpacket_traits< Packet >::type *);\n+template < typename Packet >\n+Packet pset1(const typename unpacket_traits< Packet >::type &);\n+template < typename Scalar, typename Packet > void pstoreu(Scalar, Packet &);\n+template < typename Packet, int >\n+Packet ploadt(const typename unpacket_traits< Packet >::type *from) {\n+  return pload< Packet >(from);\n+}\n+template < typename Scalar, typename Packet, int >\n+void pstoret(Scalar *to, const Packet from) {\n+  pstoreu(to, from);\n+}\n+typedef __m128d Packet2d;\n+template <> struct unpacket_traits< Packet2d > {\n+  typedef double type;\n+  typedef Packet2d half;\n+};\n+template <> Packet2d pload(const double *from) { return *(__m128d *)from; }\n+typedef __m256d Packet4d;\n+template <> struct packet_traits< double > { typedef Packet4d type; };\n+template <> struct unpacket_traits< Packet4d > {\n+  typedef double type;\n+  typedef Packet2d half;\n+};\n+__m256d pset1___trans_tmp_1;\n+template <> Packet4d pset1(const double &) {\n+  int __A;\n+  pset1___trans_tmp_1 = __m256d{__A};\n+  return pset1___trans_tmp_1;\n+}\n+template <> void pstoreu(double *to, const Packet4d &from) {\n+  *(__attribute__((__vector_size__(4 * sizeof(double)))) double *)to = from;\n+}\n+struct scalar_product_op {\n+  template < typename Packet > void packetOp(Packet a, Packet) { pmul(a); }\n+};\n+struct scalar_constant_op {\n+  template < typename PacketType > PacketType packetOp() {\n+    return pset1< PacketType >(0);\n+  }\n+};\n+struct assign_op {\n+  template < int, typename Packet > void assignPacket(double *a, Packet b) {\n+    pstoret< double, Packet, 0 >(a, b);\n+  }\n+};\n+template < typename Derived >\n+struct DenseCoeffsBase< Derived, 0 > : EigenBase< Derived > {};\n+template < typename Derived >\n+struct DenseCoeffsBase< Derived > : DenseCoeffsBase< Derived, 0 > {};\n+template < typename Derived > struct DenseBase : DenseCoeffsBase< Derived > {\n+  using DenseCoeffsBase< Derived >::derived;\n+  enum { SizeAtCompileTime, MaxSizeAtCompileTime };\n+  static CwiseNullaryOp< scalar_constant_op, Derived > Constant();\n+  Derived &setConstant();\n+  struct FixedSegmentReturnType {\n+    typedef VectorBlock Type;\n+  };\n+  template < int > typename FixedSegmentReturnType::Type segment() {\n+    return typename FixedSegmentReturnType::Type(derived(), 0, 0);\n+  }\n+};\n+template < typename Derived > struct MatrixBase : DenseBase< Derived > {\n+  using DenseBase< Derived >::derived;\n+  template < typename OtherDerived >\n+  CwiseBinaryOp< scalar_product_op, const Derived, const OtherDerived >\n+  cwiseProduct(OtherDerived) {\n+    return CwiseBinaryOp< scalar_product_op, const Derived,\n+                          const OtherDerived >(derived(), derived());\n+  }\n+  template < typename OtherDerived >\n+  Derived &operator=(const DenseBase< OtherDerived > &);\n+};\n+template < typename Derived > struct EigenBase {\n+  Derived &derived() { return *static_cast< Derived * >(this); }\n+  Derived derived() const;\n+};\n+template < typename > struct binary_evaluator;\n+template < typename Derived > struct evaluator {\n+  typedef Derived PlainObjectType;\n+  typedef typename PlainObjectType::Scalar Scalar;\n+  enum { IsVectorAtCompileTime, Flags };\n+  evaluator(PlainObjectType m) : m_data(m.data()) {}\n+  Scalar &coeffRef(int, int);\n+  template < int, typename PacketType > PacketType packet(int, int) {\n+    return ploadt< PacketType, 0 >(m_data);\n+  }\n+  const Scalar *m_data;\n+};\n+template < typename Scalar, int Rows, int Cols, int Options, int MaxRows,\n+           int MaxCols >\n+struct evaluator< Matrix< Scalar, Rows, Cols, Options, MaxRows, MaxCols > >\n+    : evaluator< PlainObjectBase< Matrix< Scalar, Rows, Cols > > > {\n+  typedef Matrix< Scalar, Rows, Cols > XprType;\n+  evaluator(XprType m) : evaluator< PlainObjectBase< XprType > >(m) {}\n+};\n+struct nullary_wrapper {\n+  template < typename T, typename IndexType >\n+  T packetOp(scalar_constant_op op, IndexType, IndexType) {\n+    return op.packetOp< T >();\n+  }\n+};\n+template < typename NullaryOp, typename PlainObjectType >\n+struct evaluator< CwiseNullaryOp< NullaryOp, PlainObjectType > > {\n+  evaluator(CwiseNullaryOp< NullaryOp, PlainObjectType >);\n+  template < int, typename PacketType, typename IndexType >\n+  PacketType packet(IndexType row, IndexType col) {\n+    return m_wrapper.packetOp< PacketType >(m_functor, row, col);\n+  }\n+  NullaryOp m_functor;\n+  nullary_wrapper m_wrapper;\n+};\n+template < typename BinaryOp, typename Lhs, typename Rhs >\n+struct evaluator< CwiseBinaryOp< BinaryOp, Lhs, Rhs > >\n+    : binary_evaluator< CwiseBinaryOp< BinaryOp, Lhs, Rhs > > {\n+  evaluator(CwiseBinaryOp< BinaryOp, Lhs, Rhs > xpr)\n+      : binary_evaluator< CwiseBinaryOp< BinaryOp, Lhs, Rhs > >(xpr) {}\n+};\n+template < typename BinaryOp, typename Lhs, typename Rhs >\n+struct binary_evaluator< CwiseBinaryOp< BinaryOp, Lhs, Rhs > > {\n+  binary_evaluator(CwiseBinaryOp< BinaryOp, Lhs, Rhs > xpr)\n+      : m_lhsImpl(xpr.lhs()), m_rhsImpl(xpr.rhs()) {}\n+  template < int, typename PacketType > PacketType packet(int, int) {\n+    PacketType __trans_tmp_1 = m_lhsImpl.template packet< 0, PacketType >(0, 0);\n+    PacketType __trans_tmp_2;\n+    m_functor.packetOp(__trans_tmp_1, __trans_tmp_2);\n+  }\n+  BinaryOp m_functor;\n+  evaluator< Lhs > m_lhsImpl;\n+  evaluator< Rhs > m_rhsImpl;\n+};\n+template < typename Derived > struct mapbase_evaluator {\n+  typedef Derived XprType;\n+  mapbase_evaluator(XprType map) : m_data(map.data()) {}\n+  typename XprType::Scalar &coeffRef(int, int) { return m_data[0]; }\n+  typename XprType::PointerType m_data;\n+};\n+template < int > struct block_evaluator;\n+template < typename ArgType, int BlockRows, int BlockCols, bool InnerPanel >\n+struct evaluator< Block< ArgType, BlockRows, BlockCols, InnerPanel > >\n+    : block_evaluator< BlockCols > {\n+  enum { Flags };\n+  evaluator(Block< ArgType, 1, 1 > block) : block_evaluator< 1 >(block) {}\n+};\n+template < int BlockCols >\n+struct block_evaluator\n+    : mapbase_evaluator< Block< Matrix< double, 10, 1 >, 1, BlockCols > > {\n+  typedef Block< Matrix< double, 10, 1 >, 1, BlockCols > XprType;\n+  block_evaluator(XprType block) : mapbase_evaluator< XprType >(block) {}\n+};\n+template < typename DstEvaluator > struct copy_using_evaluator_traits {\n+  typedef typename DstEvaluator::XprType Dst;\n+  typedef typename Dst::Scalar DstScalar;\n+  enum { DstFlags = DstEvaluator::Flags };\n+  enum { InnerSize = DstFlags };\n+  typedef typename conditional<\n+      int() == LinearVectorizedTraversal,\n+      typename find_best_packet< DstScalar, Dst::SizeAtCompileTime >::type,\n+      typename find_best_packet< DstScalar, InnerSize >::type >::type\n+      PacketType;\n+};\n+template < typename Kernel >\n+struct copy_using_evaluator_innervec_CompleteUnrolling {\n+  enum { outer, inner, SrcAlignment, DstAlignment };\n+  static void run(Kernel kernel) {\n+    kernel.template assignPacketByOuterInner< DstAlignment, SrcAlignment,\n+                                              typename Kernel::PacketType >(\n+        outer, inner);\n+  }\n+};\n+template < typename Kernel > struct dense_assignment_loop {\n+  static void run(Kernel kernel) {\n+    copy_using_evaluator_innervec_CompleteUnrolling< Kernel >::run(kernel);\n+  }\n+};\n+template < typename DstEvaluatorTypeT, typename SrcEvaluatorTypeT,\n+           typename Functor >\n+struct generic_dense_assignment_kernel {\n+  typedef DstEvaluatorTypeT DstXprType;\n+  typedef DstEvaluatorTypeT DstEvaluatorType;\n+  typedef SrcEvaluatorTypeT SrcEvaluatorType;\n+  typedef typename copy_using_evaluator_traits< DstEvaluatorTypeT >::PacketType\n+      PacketType;\n+  generic_dense_assignment_kernel(DstEvaluatorType dst, SrcEvaluatorType src,\n+                                  Functor, DstXprType dstExpr)\n+      : m_dst(dst), m_src(src), m_dstExpr(dstExpr) {}\n+  template < int StoreMode, int LoadMode, typename >\n+  void assignPacketByOuterInner(long, long) {\n+    long row;\n+    long col;\n+    m_functor.template assignPacket< StoreMode >(\n+        &m_dst.coeffRef(row, col),\n+        m_src.template packet< LoadMode, PacketType >(row, col));\n+  }\n+  DstEvaluatorType &m_dst;\n+  SrcEvaluatorType m_src;\n+  Functor m_functor;\n+  DstXprType m_dstExpr;\n+};\n+template < typename DstXprType, typename SrcXprType, typename Functor >\n+void call_dense_assignment_loop(DstXprType dst, SrcXprType src, Functor func) {\n+  typedef evaluator< DstXprType > DstEvaluatorType;\n+  typedef evaluator< SrcXprType > SrcEvaluatorType;\n+  SrcEvaluatorType srcEvaluator(src);\n+  DstEvaluatorType dstEvaluator(dst);\n+  typedef generic_dense_assignment_kernel< DstEvaluatorType, SrcEvaluatorType,\n+                                           Functor >\n+      Kernel;\n+  Kernel kernel(dstEvaluator, srcEvaluator, func, dst);\n+  dense_assignment_loop< Kernel >::run(kernel);\n+}\n+template < typename, typename, typename > struct Assignment;\n+template < typename Dst, typename Src > void call_assignment(Dst dst, Src src) {\n+  call_assignment(dst, src, assign_op());\n+}\n+template < typename Dst, typename Src, typename Func >\n+void call_assignment(Dst dst, Src src, Func func) {\n+  call_assignment_no_alias(dst, src, func);\n+}\n+template < typename Dst, typename Src, typename Func >\n+void call_assignment_no_alias(Dst dst, Src src, Func func) {\n+  enum { NeedToTranspose };\n+  Assignment< typename conditional< NeedToTranspose, int, Dst >::type, Src,\n+              Func >::run(dst, src, func);\n+}\n+template < typename DstXprType, typename SrcXprType, typename Functor >\n+struct Assignment {\n+  static void run(DstXprType dst, SrcXprType src, Functor func) {\n+    call_dense_assignment_loop(dst, src, func);\n+  }\n+};\n+template < typename Derived >\n+template < typename OtherDerived >\n+Derived &MatrixBase< Derived >::\n+operator=(const DenseBase< OtherDerived > &other) {\n+  call_assignment(derived(), other.derived());\n+}\n+template < int Size > struct plain_array { double array[Size]; };\n+template < int Size > class DenseStorage {\n+  plain_array< Size > m_data;\n+\n+public:\n+  const double *data() const { return m_data.array; }\n+  double *data() { return m_data.array; }\n+};\n+template < typename Derived >\n+struct PlainObjectBase : dense_xpr_base< Derived >::type {\n+  typedef typename dense_xpr_base< Derived >::type Base;\n+  typedef typename traits< Derived >::Scalar Scalar;\n+  DenseStorage< Base::MaxSizeAtCompileTime > m_storage;\n+  const Scalar *data() const { return m_storage.data(); }\n+  Scalar *data() { return m_storage.data(); }\n+  PlainObjectBase() {}\n+  template < typename OtherDerived > PlainObjectBase(OtherDerived other) {\n+    call_assignment_no_alias(this->derived(), other, assign_op());\n+  }\n+};\n+template < typename _Scalar, int _Rows, int _Cols, int _Options, int _MaxRows,\n+           int _MaxCols >\n+struct traits< Matrix< _Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols > > {\n+  typedef _Scalar Scalar;\n+  enum { Flags = compute_matrix_flags::ret };\n+};\n+template < typename, int _Rows, int _Cols, int, int, int >\n+struct Matrix : PlainObjectBase< Matrix< double, _Rows, _Cols > > {\n+  PlainObjectBase< Matrix > Base;\n+  Matrix() {}\n+  template < typename OtherDerived > Matrix(OtherDerived other) : Base(other) {}\n+};\n+template < typename, typename, typename > struct CwiseBinaryOp {\n+  typedef ref_selector::type LhsNested;\n+  CwiseBinaryOp(Matrix< double, 10, 1 > &aLhs, Matrix< double, 0, 0 >)\n+      : m_lhs(aLhs) {}\n+  LhsNested lhs() { return m_lhs; }\n+  Matrix< double, 8, 1 > rhs() {}\n+  LhsNested m_lhs;\n+};\n+template < typename NullaryOp, typename >\n+struct CwiseNullaryOp\n+    : dense_xpr_base< CwiseNullaryOp< NullaryOp, int > >::type {};\n+template < typename Derived > Derived &DenseBase< Derived >::setConstant() {\n+  derived() = Constant();\n+}\n+template < typename Derived >\n+struct MapBase< Derived, ReadOnlyAccessors > : dense_xpr_base< Derived >::type {\n+  typedef typename dense_xpr_base< Derived >::type Base;\n+  typedef typename traits< Derived >::Scalar Scalar;\n+  typedef typename conditional< is_lvalue< Derived >::value, Scalar *,\n+                                Scalar >::type PointerType;\n+  Scalar *data() { return m_data; }\n+  MapBase(PointerType dataPtr, long, long) : m_data(dataPtr) {}\n+  PointerType m_data;\n+};\n+template < typename Derived >\n+struct MapBase< Derived > : MapBase< Derived, ReadOnlyAccessors > {\n+  typedef MapBase< Derived, ReadOnlyAccessors > Base;\n+  MapBase(typename Base::PointerType dataPtr, long rows, long cols)\n+      : Base(dataPtr, rows, cols) {}\n+  using MapBase< Derived, ReadOnlyAccessors >::Base::operator=;\n+};\n+template < typename XprType, int BlockRows, int BlockCols, bool InnerPanel >\n+struct traits< Block< XprType, BlockRows, BlockCols, InnerPanel > >\n+    : traits< XprType > {};\n+template < int, int > struct BlockImpl_dense;\n+template < typename, int, int, typename > class BlockImpl;\n+template < typename, int BlockRows, int BlockCols, bool >\n+struct Block : BlockImpl< Matrix< double, 10, 1 >, BlockRows, BlockCols, int > {\n+  typedef BlockImpl< Matrix< double, 10, 1 >, BlockRows, BlockCols, int > Impl;\n+  using Impl::operator=;\n+  Block(Matrix< double, 10, 1 > &xpr, long startRow, long startCol,\n+        long blockRows, long blockCols)\n+      : Impl(xpr, startRow, startCol, blockRows, blockCols) {}\n+};\n+template < typename XprType, int BlockRows, int BlockCols >\n+struct BlockImpl< XprType, BlockRows, BlockCols, int >\n+    : BlockImpl_dense< BlockRows, BlockCols > {\n+  typedef BlockImpl_dense< BlockRows, BlockCols > Impl;\n+  typedef Impl Base;\n+  using Base::operator=;\n+  BlockImpl(XprType &xpr, long startRow, long startCol, long blockRows,\n+            long blockCols)\n+      : Impl(xpr, startRow, startCol, blockRows, blockCols) {}\n+};\n+template < int BlockRows, int BlockCols >\n+struct BlockImpl_dense\n+    : MapBase< Block< Matrix< double, 10, 1 >, BlockRows, BlockCols > > {\n+  typedef MapBase< Block< Matrix< double, 10, 1 >, BlockRows, BlockCols > >\n+      Base;\n+  using Base::operator=;\n+  BlockImpl_dense(Matrix< double, 10, 1 > &xpr, long, long, long blockRows,\n+                  long blockCols)\n+      : Base(xpr.data(), blockRows, blockCols) {}\n+};\n+struct VectorBlock : Block< int, traits< Matrix< double, 0, 1 > >::Flags, 1 > {\n+  VectorBlock(Matrix< double, 10, 1 > &vector, long start, long size)\n+      : Block(vector, 0, start, 1, size) {}\n+};\n+namespace std {\n+template < typename _Alloc > struct _Vector_base {\n+  typedef typename allocator_traits< _Alloc >::pointer pointer;\n+};\n+template < typename _Tp, typename _Alloc = allocator< _Tp > > class vector {\n+public:\n+  typedef __normal_iterator< typename _Vector_base< _Alloc >::pointer, int >\n+      iterator;\n+  iterator begin();\n+  iterator end();\n+};\n+struct FrameHessian {\n+  Matrix< double, 0, 1 > step;\n+  void setState(Matrix< double, 0, 1 >);\n+};\n+struct FullSystem {\n+  bool doStepFromBackup();\n+  vector< FrameHessian * > frameHessians;\n+};\n+bool FullSystem::doStepFromBackup() {\n+  Matrix< double, 10, 1 > pstepfac;\n+  pstepfac.segment< 4 >().setConstant();\n+  for (FrameHessian *fh : frameHessians)\n+    fh->setState(pstepfac.cwiseProduct(fh->step));\n+}\n+} // namespace std"}]}