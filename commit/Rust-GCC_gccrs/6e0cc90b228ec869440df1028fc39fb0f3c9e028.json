{"sha": "6e0cc90b228ec869440df1028fc39fb0f3c9e028", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmUwY2M5MGIyMjhlYzg2OTQ0MGRmMTAyOGZjMzlmYjBmM2M5ZTAyOA==", "commit": {"author": {"name": "Kelvin Nilsen", "email": "kelvin@gcc.gnu.org", "date": "2017-09-27T23:43:26Z"}, "committer": {"name": "Kelvin Nilsen", "email": "kelvin@gcc.gnu.org", "date": "2017-09-27T23:43:26Z"}, "message": "rs6000-p8swap.c (const_load_sequence_p): Revise this function to return false if the definition used by the swap...\n\ngcc/ChangeLog:\n\n2017-09-27  Kelvin Nilsen  <kelvin@gcc.gnu.org>\n\n\t* config/rs6000/rs6000-p8swap.c (const_load_sequence_p): Revise\n\tthis function to return false if the definition used by the swap\n\tinstruction is artificial, or if the memory address from which the\n\tconstant value is loaded is not represented by a base address held\n\tin a register or if the base address register is a frame or stack\n\tpointer.  Additionally, return false if the base address of the\n\tloaded constant is a SYMBOL_REF but is not considered to be a\n\tconstant.\n\t(replace_swapped_load_constant): New function.\n\t(rs6000_analyze_swaps): Add a new pass to replace a swap of a\n\tloaded constant vector with a load of a swapped constant vector.\n\ngcc/testsuite/ChangeLog:\n\n2017-09-27  Kelvin Nilsen  <kelvin@gcc.gnu.org>\n\n\t* gcc.target/powerpc/swaps-p8-28.c: New test.\n\t* gcc.target/powerpc/swaps-p8-29.c: New test.\n\t* gcc.target/powerpc/swaps-p8-30.c: New test.\n\t* gcc.target/powerpc/swaps-p8-31.c: New test.\n\t* gcc.target/powerpc/swaps-p8-32.c: New test.\n\t* gcc.target/powerpc/swaps-p8-33.c: New test.\n\t* gcc.target/powerpc/swaps-p8-34.c: New test.\n\t* gcc.target/powerpc/swaps-p8-35.c: New test.\n\t* gcc.target/powerpc/swaps-p8-36.c: New test.\n\t* gcc.target/powerpc/swaps-p8-37.c: New test.\n\t* gcc.target/powerpc/swaps-p8-38.c: New test.\n\t* gcc.target/powerpc/swaps-p8-39.c: New test.\n\t* gcc.target/powerpc/swaps-p8-40.c: New test.\n\t* gcc.target/powerpc/swaps-p8-41.c: New test.\n\t* gcc.target/powerpc/swaps-p8-42.c: New test.\n\t* gcc.target/powerpc/swaps-p8-43.c: New test.\n\t* gcc.target/powerpc/swaps-p8-44.c: New test.\n\t* gcc.target/powerpc/swaps-p8-45.c: New test.\n\nFrom-SVN: r253240", "tree": {"sha": "02c3cb0dde03b7281f4e5e47f04596971fe6db71", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/02c3cb0dde03b7281f4e5e47f04596971fe6db71"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6e0cc90b228ec869440df1028fc39fb0f3c9e028", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e0cc90b228ec869440df1028fc39fb0f3c9e028", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e0cc90b228ec869440df1028fc39fb0f3c9e028", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e0cc90b228ec869440df1028fc39fb0f3c9e028/comments", "author": null, "committer": null, "parents": [{"sha": "4ca4cf4e420cc817fc66949d4c8069f951d857b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ca4cf4e420cc817fc66949d4c8069f951d857b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4ca4cf4e420cc817fc66949d4c8069f951d857b4"}], "stats": {"total": 797, "additions": 794, "deletions": 3}, "files": [{"sha": "8a482744574dbc1de77e968e515bf77057a5a817", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e0cc90b228ec869440df1028fc39fb0f3c9e028/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e0cc90b228ec869440df1028fc39fb0f3c9e028/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6e0cc90b228ec869440df1028fc39fb0f3c9e028", "patch": "@@ -1,3 +1,17 @@\n+2017-09-27  Kelvin Nilsen  <kelvin@gcc.gnu.org>\n+\n+\t* config/rs6000/rs6000-p8swap.c (const_load_sequence_p): Revise\n+\tthis function to return false if the definition used by the swap\n+\tinstruction is artificial, or if the memory address from which the\n+\tconstant value is loaded is not represented by a base address held\n+\tin a register or if the base address register is a frame or stack\n+\tpointer.  Additionally, return false if the base address of the\n+\tloaded constant is a SYMBOL_REF but is not considered to be a\n+\tconstant.\n+\t(replace_swapped_load_constant): New function.\n+\t(rs6000_analyze_swaps): Add a new pass to replace a swap of a\n+\tloaded constant vector with a load of a swapped constant vector.\n+\n 2017-09-27  Carl Love  <cel@us.ibm.com>\n \n \t* config/rs6000/rs6000-builtin.def (BU_FP_1MISC_1): Add define macro."}, {"sha": "83df9c871cf5fe535fa937509c8cda950548dff2", "filename": "gcc/config/rs6000/rs6000-p8swap.c", "status": "modified", "additions": 267, "deletions": 3, "changes": 270, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e0cc90b228ec869440df1028fc39fb0f3c9e028/gcc%2Fconfig%2Frs6000%2Frs6000-p8swap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e0cc90b228ec869440df1028fc39fb0f3c9e028/gcc%2Fconfig%2Frs6000%2Frs6000-p8swap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-p8swap.c?ref=6e0cc90b228ec869440df1028fc39fb0f3c9e028", "patch": "@@ -335,21 +335,26 @@ const_load_sequence_p (swap_web_entry *insn_entry, rtx insn)\n \n   const_rtx tocrel_base;\n \n-  /* Find the unique use in the swap and locate its def.  If the def\n-     isn't unique, punt.  */\n   struct df_insn_info *insn_info = DF_INSN_INFO_GET (insn);\n   df_ref use;\n   FOR_EACH_INSN_INFO_USE (use, insn_info)\n     {\n       struct df_link *def_link = DF_REF_CHAIN (use);\n-      if (!def_link || def_link->next)\n+\n+      /* If there is no def or the def is artificial or there are\n+\t multiple defs, punt.  */\n+      if (!def_link || !def_link->ref || DF_REF_IS_ARTIFICIAL (def_link->ref)\n+\t  || def_link->next)\n \treturn false;\n \n       rtx def_insn = DF_REF_INSN (def_link->ref);\n       unsigned uid2 = INSN_UID (def_insn);\n+      /* If this is not a load or is not a swap, return false.  */\n       if (!insn_entry[uid2].is_load || !insn_entry[uid2].is_swap)\n \treturn false;\n \n+      /* If the source of the rtl def is not a set from memory, return\n+\t false.  */\n       rtx body = PATTERN (def_insn);\n       if (GET_CODE (body) != SET\n \t  || GET_CODE (SET_SRC (body)) != VEC_SELECT\n@@ -358,18 +363,32 @@ const_load_sequence_p (swap_web_entry *insn_entry, rtx insn)\n \n       rtx mem = XEXP (SET_SRC (body), 0);\n       rtx base_reg = XEXP (mem, 0);\n+      /* If the base address for the memory expression is not\n+\t represented by a register, punt.  */\n+      if (!REG_P (base_reg))\n+\treturn false;\n \n       df_ref base_use;\n       insn_info = DF_INSN_INFO_GET (def_insn);\n       FOR_EACH_INSN_INFO_USE (base_use, insn_info)\n \t{\n+\t  /* If base_use does not represent base_reg, look for another\n+\t     use.  */\n \t  if (!rtx_equal_p (DF_REF_REG (base_use), base_reg))\n \t    continue;\n \n \t  struct df_link *base_def_link = DF_REF_CHAIN (base_use);\n \t  if (!base_def_link || base_def_link->next)\n \t    return false;\n \n+\t  /* Constants held on the stack are not \"true\" constants\n+\t     because their values are not part of the static load\n+\t     image.  If this constant's base reference is a stack\n+\t     or frame pointer, it is seen as an artificial\n+\t     reference.  */\n+\t  if (DF_REF_IS_ARTIFICIAL (base_def_link->ref))\n+\t    return false;\n+\n \t  rtx tocrel_insn = DF_REF_INSN (base_def_link->ref);\n \t  rtx tocrel_body = PATTERN (tocrel_insn);\n \t  rtx base, offset;\n@@ -383,8 +402,26 @@ const_load_sequence_p (swap_web_entry *insn_entry, rtx insn)\n \t  if (!toc_relative_expr_p (tocrel_expr, false, &tocrel_base, NULL))\n \t    return false;\n \t  split_const (XVECEXP (tocrel_base, 0, 0), &base, &offset);\n+\n \t  if (GET_CODE (base) != SYMBOL_REF || !CONSTANT_POOL_ADDRESS_P (base))\n \t    return false;\n+\t  else\n+\t    {\n+\t      /* FIXME: The conditions under which\n+\t          ((GET_CODE (const_vector) == SYMBOL_REF) &&\n+\t           !CONSTANT_POOL_ADDRESS_P (const_vector))\n+\t         are not well understood.  This code prevents\n+\t         an internal compiler error which will occur in\n+\t         replace_swapped_load_constant () if we were to return\n+\t         true.  Some day, we should figure out how to properly\n+\t         handle this condition in\n+\t         replace_swapped_load_constant () and then we can\n+\t         remove this special test.  */\n+\t      rtx const_vector = get_pool_constant (base);\n+\t      if (GET_CODE (const_vector) == SYMBOL_REF\n+\t\t  && !CONSTANT_POOL_ADDRESS_P (const_vector))\n+\t\t    return false;\n+\t    }\n \t}\n     }\n   return true;\n@@ -1281,6 +1318,195 @@ replace_swap_with_copy (swap_web_entry *insn_entry, unsigned i)\n   insn->set_deleted ();\n }\n \n+/* Given that swap_insn represents a swap of a load of a constant\n+   vector value, replace with a single instruction that loads a\n+   swapped variant of the original constant.\n+\n+   The \"natural\" representation of a byte array in memory is the same\n+   for big endian and little endian.\n+\n+   unsigned char byte_array[] =\n+     { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, a, b, c, d, e, f };\n+\n+   However, when loaded into a vector register, the representation\n+   depends on endian conventions.\n+\n+   In big-endian mode, the register holds:\n+\n+     MSB                                            LSB\n+     [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, a, b, c, d, e, f ]\n+\n+   In little-endian mode, the register holds:\n+\n+     MSB                                            LSB\n+     [ f, e, d, c, b, a, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0 ]\n+\n+   Word arrays require different handling.  Consider the word array:\n+\n+   unsigned int word_array[] =\n+     { 0x00010203, 0x04050607, 0x08090a0b, 0x0c0d0e0f };\n+\n+   The in-memory representation depends on endian configuration.  The\n+   equivalent array, declared as a byte array, in memory would be:\n+\n+   unsigned char big_endian_word_array_data[] =\n+     { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, a, b, c, d, e, f }\n+\n+   unsigned char little_endian_word_array_data[] =\n+     { 3, 2, 1, 0, 7, 6, 5, 4, b, a, 9, 8, f, e, d, c }\n+\n+   In big-endian mode, the register holds:\n+\n+     MSB                                            LSB\n+     [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, a, b, c, d, e, f ]\n+\n+   In little-endian mode, the register holds:\n+\n+     MSB                                            LSB\n+     [ c, d, e, f, 8, 9, a, b, 4, 5, 6, 7, 0, 1, 2, 3 ]\n+\n+\n+  Similar transformations apply to the vector of half-word and vector\n+  of double-word representations.\n+\n+  For now, don't handle vectors of quad-precision values.  Just return.\n+  A better solution is to fix the code generator to emit lvx/stvx for\n+  those.  */\n+static void\n+replace_swapped_load_constant (swap_web_entry *insn_entry, rtx swap_insn)\n+{\n+  /* Find the load.  */\n+  struct df_insn_info *insn_info = DF_INSN_INFO_GET (swap_insn);\n+  rtx_insn *load_insn;\n+  df_ref use  = DF_INSN_INFO_USES (insn_info);\n+  struct df_link *def_link = DF_REF_CHAIN (use);\n+  gcc_assert (def_link && !def_link->next);\n+\n+  load_insn = DF_REF_INSN (def_link->ref);\n+  gcc_assert (load_insn);\n+\n+  /* Find the TOC-relative symbol access.  */\n+  insn_info = DF_INSN_INFO_GET (load_insn);\n+  use = DF_INSN_INFO_USES (insn_info);\n+\n+  def_link = DF_REF_CHAIN (use);\n+  gcc_assert (def_link && !def_link->next);\n+\n+  rtx_insn *tocrel_insn = DF_REF_INSN (def_link->ref);\n+  gcc_assert (tocrel_insn);\n+\n+  /* Find the embedded CONST_VECTOR.  We have to call toc_relative_expr_p\n+     to set tocrel_base; otherwise it would be unnecessary as we've\n+     already established it will return true.  */\n+  rtx base, offset;\n+  rtx tocrel_expr = SET_SRC (PATTERN (tocrel_insn));\n+  const_rtx tocrel_base;\n+\n+  /* There is an extra level of indirection for small/large code models.  */\n+  if (GET_CODE (tocrel_expr) == MEM)\n+    tocrel_expr = XEXP (tocrel_expr, 0);\n+\n+  if (!toc_relative_expr_p (tocrel_expr, false, &tocrel_base, NULL))\n+    gcc_unreachable ();\n+\n+  split_const (XVECEXP (tocrel_base, 0, 0), &base, &offset);\n+  rtx const_vector = get_pool_constant (base);\n+\n+  /* With the extra indirection, get_pool_constant will produce the\n+     real constant from the reg_equal expression, so get the real\n+     constant.  */\n+  if (GET_CODE (const_vector) == SYMBOL_REF)\n+    const_vector = get_pool_constant (const_vector);\n+  gcc_assert (GET_CODE (const_vector) == CONST_VECTOR);\n+\n+  rtx new_mem;\n+  enum machine_mode mode = GET_MODE (const_vector);\n+\n+  /* Create an adjusted constant from the original constant.  */\n+  if (mode == V1TImode)\n+    /* Leave this code as is.  */\n+    return;\n+  else if (mode == V16QImode)\n+    {\n+      rtx vals = gen_rtx_PARALLEL (mode, rtvec_alloc (16));\n+      int i;\n+\n+      for (i = 0; i < 16; i++)\n+\tXVECEXP (vals, 0, ((i+8) % 16)) = XVECEXP (const_vector, 0, i);\n+      rtx new_const_vector = gen_rtx_CONST_VECTOR (mode, XVEC (vals, 0));\n+      new_mem = force_const_mem (mode, new_const_vector);\n+    }\n+  else if ((mode == V8HImode)\n+#ifdef HAVE_V8HFmode\n+\t   || (mode == V8HFmode)\n+#endif\n+\t   )\n+    {\n+      rtx vals = gen_rtx_PARALLEL (mode, rtvec_alloc (8));\n+      int i;\n+\n+      for (i = 0; i < 8; i++)\n+\tXVECEXP (vals, 0, ((i+4) % 8)) = XVECEXP (const_vector, 0, i);\n+      rtx new_const_vector = gen_rtx_CONST_VECTOR (mode, XVEC (vals, 0));\n+      new_mem = force_const_mem (mode, new_const_vector);\n+    }\n+  else if ((mode == V4SImode) || (mode == V4SFmode))\n+    {\n+      rtx vals = gen_rtx_PARALLEL (mode, rtvec_alloc (4));\n+      int i;\n+\n+      for (i = 0; i < 4; i++)\n+\tXVECEXP (vals, 0, ((i+2) % 4)) = XVECEXP (const_vector, 0, i);\n+      rtx new_const_vector = gen_rtx_CONST_VECTOR (mode, XVEC (vals, 0));\n+      new_mem = force_const_mem (mode, new_const_vector);\n+    }\n+  else if ((mode == V2DImode) || (mode == V2DFmode))\n+    {\n+      rtx vals = gen_rtx_PARALLEL (mode, rtvec_alloc (2));\n+      int i;\n+\n+      for (i = 0; i < 2; i++)\n+\tXVECEXP (vals, 0, ((i+1) % 2)) = XVECEXP (const_vector, 0, i);\n+      rtx new_const_vector = gen_rtx_CONST_VECTOR (mode, XVEC (vals, 0));\n+      new_mem = force_const_mem (mode, new_const_vector);\n+    }\n+  else\n+    {\n+      /* We do not expect other modes to be constant-load-swapped.  */\n+      gcc_unreachable ();\n+    }\n+\n+  /* This gives us a MEM whose base operand is a SYMBOL_REF, which we\n+     can't recognize.  Force the SYMBOL_REF into a register.  */\n+  if (!REG_P (XEXP (new_mem, 0))) {\n+    rtx base_reg = force_reg (Pmode, XEXP (new_mem, 0));\n+    XEXP (new_mem, 0) = base_reg;\n+\n+    /* Move the newly created insn ahead of the load insn.  */\n+    /* The last insn is the the insn that forced new_mem into a register.  */\n+    rtx_insn *force_insn = get_last_insn ();\n+    /* Remove this insn from the end of the instruction sequence.  */\n+    remove_insn (force_insn);\n+    rtx_insn *before_load_insn = PREV_INSN (load_insn);\n+\n+    /* And insert this insn back into the sequence before the previous\n+       load insn so this new expression will be available when the\n+       existing load is modified to load the swapped constant.  */\n+    add_insn_after (force_insn, before_load_insn, BLOCK_FOR_INSN (load_insn));\n+    df_insn_rescan (before_load_insn);\n+    df_insn_rescan (force_insn);\n+  }\n+\n+  /* Replace the MEM in the load instruction and rescan it.  */\n+  XEXP (SET_SRC (PATTERN (load_insn)), 0) = new_mem;\n+  INSN_CODE (load_insn) = -1; /* Force re-recognition.  */\n+  df_insn_rescan (load_insn);\n+\n+  unsigned int uid = INSN_UID (swap_insn);\n+  mark_swaps_for_removal (insn_entry, uid);\n+  replace_swap_with_copy (insn_entry, uid);\n+}\n+\n /* Dump the swap table to DUMP_FILE.  */\n static void\n dump_swap_insn_table (swap_web_entry *insn_entry)\n@@ -1873,6 +2099,44 @@ rs6000_analyze_swaps (function *fun)\n \n   /* Clean up.  */\n   free (insn_entry);\n+\n+  /* Use additional pass over rtl to replace swap(load(vector constant))\n+     with load(swapped vector constant). */\n+  swap_web_entry *pass2_insn_entry;\n+  pass2_insn_entry = XCNEWVEC (swap_web_entry, get_max_uid ());\n+\n+  /* Walk the insns to gather basic data.  */\n+  FOR_ALL_BB_FN (bb, fun)\n+    FOR_BB_INSNS_SAFE (bb, insn, curr_insn)\n+    {\n+      unsigned int uid = INSN_UID (insn);\n+      if (NONDEBUG_INSN_P (insn))\n+\t{\n+\t  pass2_insn_entry[uid].insn = insn;\n+\n+\t  pass2_insn_entry[uid].is_relevant = 1;\n+\t  pass2_insn_entry[uid].is_load = insn_is_load_p (insn);\n+\t  pass2_insn_entry[uid].is_store = insn_is_store_p (insn);\n+\n+\t  /* Determine if this is a doubleword swap.  If not,\n+\t     determine whether it can legally be swapped.  */\n+\t  if (insn_is_swap_p (insn))\n+\t    pass2_insn_entry[uid].is_swap = 1;\n+\t}\n+    }\n+\n+  e = get_max_uid ();\n+  for (unsigned i = 0; i < e; ++i)\n+    if (pass2_insn_entry[i].is_swap && !pass2_insn_entry[i].is_load\n+\t&& !pass2_insn_entry[i].is_store)\n+      {\n+\tinsn = pass2_insn_entry[i].insn;\n+\tif (const_load_sequence_p (pass2_insn_entry, insn))\n+\t  replace_swapped_load_constant (pass2_insn_entry, insn);\n+      }\n+\n+  /* Clean up.  */\n+  free (pass2_insn_entry);\n   return 0;\n }\n "}, {"sha": "0b5f5ee6858266687c61a0dfe5014fa2cb5edfa0", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e0cc90b228ec869440df1028fc39fb0f3c9e028/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e0cc90b228ec869440df1028fc39fb0f3c9e028/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=6e0cc90b228ec869440df1028fc39fb0f3c9e028", "patch": "@@ -1,3 +1,24 @@\n+2017-09-27  Kelvin Nilsen  <kelvin@gcc.gnu.org>\n+\n+\t* gcc.target/powerpc/swaps-p8-28.c: New test.\n+\t* gcc.target/powerpc/swaps-p8-29.c: New test.\n+\t* gcc.target/powerpc/swaps-p8-30.c: New test.\n+\t* gcc.target/powerpc/swaps-p8-31.c: New test.\n+\t* gcc.target/powerpc/swaps-p8-32.c: New test.\n+\t* gcc.target/powerpc/swaps-p8-33.c: New test.\n+\t* gcc.target/powerpc/swaps-p8-34.c: New test.\n+\t* gcc.target/powerpc/swaps-p8-35.c: New test.\n+\t* gcc.target/powerpc/swaps-p8-36.c: New test.\n+\t* gcc.target/powerpc/swaps-p8-37.c: New test.\n+\t* gcc.target/powerpc/swaps-p8-38.c: New test.\n+\t* gcc.target/powerpc/swaps-p8-39.c: New test.\n+\t* gcc.target/powerpc/swaps-p8-40.c: New test.\n+\t* gcc.target/powerpc/swaps-p8-41.c: New test.\n+\t* gcc.target/powerpc/swaps-p8-42.c: New test.\n+\t* gcc.target/powerpc/swaps-p8-43.c: New test.\n+\t* gcc.target/powerpc/swaps-p8-44.c: New test.\n+\t* gcc.target/powerpc/swaps-p8-45.c: New test.\n+\n 2017-09-27 Carl Love  <cel@us.ibm.com>\n \t* gcc.target/powerpc/builtin-fctid-fctiw-runnable.c: New test file\n \tfor the __builtin_fctid and __builtin_fctiw."}, {"sha": "4e96d9232930244af6a9ec519bf79865852ccefb", "filename": "gcc/testsuite/gcc.target/powerpc/swaps-p8-28.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e0cc90b228ec869440df1028fc39fb0f3c9e028/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-28.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e0cc90b228ec869440df1028fc39fb0f3c9e028/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-28.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-28.c?ref=6e0cc90b228ec869440df1028fc39fb0f3c9e028", "patch": "@@ -0,0 +1,29 @@\n+/* { dg-require-effective-target p8vector_hw } */\n+/* { dg-do run { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power8\" } } */\n+/* { dg-options \"-mcpu=power8 -O3 \" } */\n+\n+#include <altivec.h>\n+\n+extern void abort (void);\n+\n+vector char y = { 0, 1, 2, 3,\n+\t\t  4, 5, 6, 7,\n+\t\t  8, 9, 10, 11,\n+\t\t  12, 13, 14, 15 };\n+\n+vector char\n+foo (void)\n+{\n+  return y;\n+}\n+\n+int\n+main (int argc, char *argv[])\n+{\n+  vector char fetched_value = foo ();\n+  if (fetched_value[0] != 0 || fetched_value[15] != 15)\n+    abort ();\n+  else\n+    return 0;\n+}"}, {"sha": "c1ed7d3ceef8f6c85084199e8ad12445731c5bbe", "filename": "gcc/testsuite/gcc.target/powerpc/swaps-p8-29.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e0cc90b228ec869440df1028fc39fb0f3c9e028/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-29.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e0cc90b228ec869440df1028fc39fb0f3c9e028/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-29.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-29.c?ref=6e0cc90b228ec869440df1028fc39fb0f3c9e028", "patch": "@@ -0,0 +1,29 @@\n+/* { dg-require-effective-target p8vector_hw } */\n+/* { dg-do run { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power8\" } } */\n+/* { dg-options \"-mcpu=power8 -O3 \" } */\n+\n+#include <altivec.h>\n+\n+extern void abort (void);\n+\n+const vector char y = { 0, 1, 2, 3,\n+\t\t\t4, 5, 6, 7,\n+\t\t\t8, 9, 10, 11,\n+\t\t\t12, 13, 14, 15 };\n+\n+vector char\n+foo (void)\n+{\n+  return y;\n+}\n+\n+int\n+main (int argc, char *argv[])\n+{\n+  vector char fetched_value = foo ();\n+  if (fetched_value[0] != 0 || fetched_value[15] != 15)\n+    abort ();\n+  else\n+    return 0;\n+}"}, {"sha": "4e265d5d7cea335112610de4020591691bd82aa7", "filename": "gcc/testsuite/gcc.target/powerpc/swaps-p8-30.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e0cc90b228ec869440df1028fc39fb0f3c9e028/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-30.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e0cc90b228ec869440df1028fc39fb0f3c9e028/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-30.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-30.c?ref=6e0cc90b228ec869440df1028fc39fb0f3c9e028", "patch": "@@ -0,0 +1,31 @@\n+/* { dg-require-effective-target powerpc_p8vector_ok } */\n+/* { dg-do compile { target { powerpc64le-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power8\" } } */\n+/* { dg-options \"-mcpu=power8 -O3 \" } */\n+/* { dg-final { scan-assembler-not \"xxpermdi\" } } */\n+/* { dg-final { scan-assembler-not \"xxswapd\" } } */\n+\n+#include <altivec.h>\n+\n+extern void abort (void);\n+\n+const vector char y = { 0, 1, 2, 3,\n+\t\t\t4, 5, 6, 7,\n+\t\t\t8, 9, 10, 11,\n+\t\t\t12, 13, 14, 15 };\n+\n+vector char\n+foo (void)\n+{\n+  return y;\n+}\n+\n+int\n+main (int argc, char *argv[])\n+{\n+  vector char fetched_value = foo ();\n+  if (fetched_value[0] != 0 || fetched_value[15] != 15)\n+    abort ();\n+  else\n+    return 0;\n+}"}, {"sha": "1711dd13ae370c8c5109ae35daf0c9f9cbde3b31", "filename": "gcc/testsuite/gcc.target/powerpc/swaps-p8-31.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e0cc90b228ec869440df1028fc39fb0f3c9e028/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-31.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e0cc90b228ec869440df1028fc39fb0f3c9e028/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-31.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-31.c?ref=6e0cc90b228ec869440df1028fc39fb0f3c9e028", "patch": "@@ -0,0 +1,27 @@\n+/* { dg-require-effective-target p8vector_hw } */\n+/* { dg-do run { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power8\" } } */\n+/* { dg-options \"-mcpu=power8 -O3 \" } */\n+\n+#include <altivec.h>\n+\n+extern void abort (void);\n+\n+vector short y = { 0, 1, 2, 3,\n+\t\t   4, 5, 6, 7 };\n+\n+vector short\n+foo (void)\n+{\n+  return y;\n+}\n+\n+int\n+main (int argc, char *argv[])\n+{\n+  vector short fetched_value = foo ();\n+  if (fetched_value[0] != 0 || fetched_value[7] != 7)\n+    abort ();\n+  else\n+    return 0;\n+}"}, {"sha": "8f137196df38d66c7a72b2381e9ba4d04399f175", "filename": "gcc/testsuite/gcc.target/powerpc/swaps-p8-32.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e0cc90b228ec869440df1028fc39fb0f3c9e028/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e0cc90b228ec869440df1028fc39fb0f3c9e028/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-32.c?ref=6e0cc90b228ec869440df1028fc39fb0f3c9e028", "patch": "@@ -0,0 +1,27 @@\n+/* { dg-require-effective-target p8vector_hw } */\n+/* { dg-do run { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power8\" } } */\n+/* { dg-options \"-mcpu=power8 -O3 \" } */\n+\n+#include <altivec.h>\n+\n+extern void abort (void);\n+\n+const vector short y = { 0, 1, 2, 3,\n+\t\t\t 4, 5, 6, 7 };\n+\n+vector short\n+foo (void)\n+{\n+  return y;\n+}\n+\n+int\n+main (int argc, char *argv[])\n+{\n+  vector short fetched_value = foo ();\n+  if (fetched_value[0] != 0 || fetched_value[7] != 7)\n+    abort ();\n+  else\n+    return 0;\n+}"}, {"sha": "8e76ba94c5b90c903a6da4ca12d9801521fb8b01", "filename": "gcc/testsuite/gcc.target/powerpc/swaps-p8-33.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e0cc90b228ec869440df1028fc39fb0f3c9e028/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-33.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e0cc90b228ec869440df1028fc39fb0f3c9e028/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-33.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-33.c?ref=6e0cc90b228ec869440df1028fc39fb0f3c9e028", "patch": "@@ -0,0 +1,29 @@\n+/* { dg-require-effective-target powerpc_p8vector_ok } */\n+/* { dg-do compile { target { powerpc64le-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power8\" } } */\n+/* { dg-options \"-mcpu=power8 -O3 \" } */\n+/* { dg-final { scan-assembler-not \"xxpermdi\" } } */\n+/* { dg-final { scan-assembler-not \"xxswapd\" } } */\n+\n+#include <altivec.h>\n+\n+extern void abort (void);\n+\n+const vector short y = { 0, 1, 2, 3,\n+\t\t\t 4, 5, 6, 7 };\n+\n+vector short\n+foo (void)\n+{\n+  return y;\n+}\n+\n+int\n+main (int argc, char *argv[])\n+{\n+  vector short fetched_value = foo ();\n+  if (fetched_value[0] != 0 || fetched_value[15] != 15)\n+    abort ();\n+  else\n+    return 0;\n+}"}, {"sha": "7eb39e3c045466a2da68022bcc6d7c5be4e61955", "filename": "gcc/testsuite/gcc.target/powerpc/swaps-p8-34.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e0cc90b228ec869440df1028fc39fb0f3c9e028/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-34.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e0cc90b228ec869440df1028fc39fb0f3c9e028/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-34.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-34.c?ref=6e0cc90b228ec869440df1028fc39fb0f3c9e028", "patch": "@@ -0,0 +1,26 @@\n+/* { dg-require-effective-target p8vector_hw } */\n+/* { dg-do run { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power8\" } } */\n+/* { dg-options \"-mcpu=power8 -O3 \" } */\n+\n+#include <altivec.h>\n+\n+extern void abort (void);\n+\n+vector int y = { 0, 1, 2, 3 };\n+\n+vector int\n+foo (void)\n+{\n+  return y;\n+}\n+\n+int\n+main (int argc, char *argv[])\n+{\n+  vector int fetched_value = foo ();\n+  if (fetched_value[0] != 0 || fetched_value[3] != 3)\n+    abort ();\n+  else\n+    return 0;\n+}"}, {"sha": "99ca9918a62181420f6ab82d7f0506888c7a6fef", "filename": "gcc/testsuite/gcc.target/powerpc/swaps-p8-35.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e0cc90b228ec869440df1028fc39fb0f3c9e028/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-35.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e0cc90b228ec869440df1028fc39fb0f3c9e028/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-35.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-35.c?ref=6e0cc90b228ec869440df1028fc39fb0f3c9e028", "patch": "@@ -0,0 +1,26 @@\n+/* { dg-require-effective-target p8vector_hw } */\n+/* { dg-do run { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power8\" } } */\n+/* { dg-options \"-mcpu=power8 -O3 \" } */\n+\n+#include <altivec.h>\n+\n+extern void abort (void);\n+\n+const vector int y = { 0, 1, 2, 3 };\n+\n+vector int\n+foo (void)\n+{\n+  return y;\n+}\n+\n+int\n+main (int argc, char *argv[])\n+{\n+  vector int fetched_value = foo ();\n+  if (fetched_value[0] != 0 || fetched_value[3] != 3)\n+    abort ();\n+  else\n+    return 0;\n+}"}, {"sha": "6c067b3dc60bceb2d770a254a772410fb4521c85", "filename": "gcc/testsuite/gcc.target/powerpc/swaps-p8-36.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e0cc90b228ec869440df1028fc39fb0f3c9e028/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-36.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e0cc90b228ec869440df1028fc39fb0f3c9e028/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-36.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-36.c?ref=6e0cc90b228ec869440df1028fc39fb0f3c9e028", "patch": "@@ -0,0 +1,28 @@\n+/* { dg-require-effective-target powerpc_p8vector_ok } */\n+/* { dg-do compile { target { powerpc64le-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power8\" } } */\n+/* { dg-options \"-mcpu=power8 -O3 \" } */\n+/* { dg-final { scan-assembler-not \"xxpermdi\" } } */\n+/* { dg-final { scan-assembler-not \"xxswapd\" } } */\n+\n+#include <altivec.h>\n+\n+extern void abort (void);\n+\n+const vector int y = { 0, 1, 2, 3 };\n+\n+vector int\n+foo (void)\n+{\n+  return y;\n+}\n+\n+int\n+main (int argc, char *argv[])\n+{\n+  vector int fetched_value = foo ();\n+  if (fetched_value[0] != 0 || fetched_value[3] != 3)\n+    abort ();\n+  else\n+    return 0;\n+}"}, {"sha": "ac5f7cc21a6f03d1e69d388c09c34aef291ee758", "filename": "gcc/testsuite/gcc.target/powerpc/swaps-p8-37.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e0cc90b228ec869440df1028fc39fb0f3c9e028/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-37.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e0cc90b228ec869440df1028fc39fb0f3c9e028/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-37.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-37.c?ref=6e0cc90b228ec869440df1028fc39fb0f3c9e028", "patch": "@@ -0,0 +1,26 @@\n+/* { dg-require-effective-target p8vector_hw } */\n+/* { dg-do run { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power8\" } } */\n+/* { dg-options \"-mcpu=power8 -O3 \" } */\n+\n+#include <altivec.h>\n+\n+extern void abort (void);\n+\n+vector float y = { 0.0f, 0.1f, 0.2f, 0.3f };\n+\n+vector float\n+foo (void)\n+{\n+  return y;\n+}\n+\n+int\n+main (int argc, char *argv[])\n+{\n+  vector float fetched_value = foo ();\n+  if (fetched_value[0] != 0.0f || fetched_value[3] != 0.3f)\n+    abort ();\n+  else\n+    return 0;\n+}"}, {"sha": "b05536bfcb7ff1bf1ea9376667692400f8e2e26b", "filename": "gcc/testsuite/gcc.target/powerpc/swaps-p8-38.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e0cc90b228ec869440df1028fc39fb0f3c9e028/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-38.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e0cc90b228ec869440df1028fc39fb0f3c9e028/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-38.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-38.c?ref=6e0cc90b228ec869440df1028fc39fb0f3c9e028", "patch": "@@ -0,0 +1,26 @@\n+/* { dg-require-effective-target p8vector_hw } */\n+/* { dg-do run { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power8\" } } */\n+/* { dg-options \"-mcpu=power8 -O3 \" } */\n+\n+#include <altivec.h>\n+\n+extern void abort (void);\n+\n+const vector float y = { 0.0f, 0.1f, 0.2f, 0.3f };\n+\n+vector float\n+foo (void)\n+{\n+  return y;\n+}\n+\n+int\n+main (int argc, char *argv[])\n+{\n+  vector float fetched_value = foo ();\n+  if (fetched_value[0] != 0.0f || fetched_value[3] != 0.3f)\n+    abort ();\n+  else\n+    return 0;\n+}"}, {"sha": "b76f5c44b2dbe1908380e2ab500a1258cda48217", "filename": "gcc/testsuite/gcc.target/powerpc/swaps-p8-39.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e0cc90b228ec869440df1028fc39fb0f3c9e028/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-39.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e0cc90b228ec869440df1028fc39fb0f3c9e028/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-39.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-39.c?ref=6e0cc90b228ec869440df1028fc39fb0f3c9e028", "patch": "@@ -0,0 +1,28 @@\n+/* { dg-require-effective-target powerpc_p8vector_ok } */\n+/* { dg-do compile { target { powerpc64le-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power8\" } } */\n+/* { dg-options \"-mcpu=power8 -O3 \" } */\n+/* { dg-final { scan-assembler-not \"xxpermdi\" } } */\n+/* { dg-final { scan-assembler-not \"xxswapd\" } } */\n+\n+#include <altivec.h>\n+\n+extern void abort (void);\n+\n+const vector float y = { 0.0f, 0.1f, 0.2f, 0.3f };\n+\n+vector float\n+foo (void)\n+{\n+  return y;\n+}\n+\n+int\n+main (int argc, char *argv[])\n+{\n+  vector float fetched_value = foo ();\n+  if (fetched_value[0] != 0.0f || fetched_value[3] != 0.3)\n+    abort ();\n+  else\n+    return 0;\n+}"}, {"sha": "2f48d0d22834a04d002024d770c63b9d5489b3f8", "filename": "gcc/testsuite/gcc.target/powerpc/swaps-p8-40.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e0cc90b228ec869440df1028fc39fb0f3c9e028/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-40.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e0cc90b228ec869440df1028fc39fb0f3c9e028/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-40.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-40.c?ref=6e0cc90b228ec869440df1028fc39fb0f3c9e028", "patch": "@@ -0,0 +1,26 @@\n+/* { dg-require-effective-target p8vector_hw } */\n+/* { dg-do run { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power8\" } } */\n+/* { dg-options \"-mcpu=power8 -O3 \" } */\n+\n+#include <altivec.h>\n+\n+extern void abort (void);\n+\n+vector long long int y = { 0, 1 };\n+\n+vector long long int\n+foo (void)\n+{\n+  return y;\n+}\n+\n+int\n+main (int argc, int *argv[])\n+{\n+  vector long long int fetched_value = foo ();\n+  if (fetched_value[0] != 0 || fetched_value[1] != 1)\n+    abort ();\n+  else\n+    return 0;\n+}"}, {"sha": "a6fda1261d6c8aa357844564d4271b9b1f59383b", "filename": "gcc/testsuite/gcc.target/powerpc/swaps-p8-41.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e0cc90b228ec869440df1028fc39fb0f3c9e028/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-41.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e0cc90b228ec869440df1028fc39fb0f3c9e028/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-41.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-41.c?ref=6e0cc90b228ec869440df1028fc39fb0f3c9e028", "patch": "@@ -0,0 +1,26 @@\n+/* { dg-require-effective-target p8vector_hw } */\n+/* { dg-do run { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power8\" } } */\n+/* { dg-options \"-mcpu=power8 -O3 \" } */\n+\n+#include <altivec.h>\n+\n+extern void abort (void);\n+\n+const vector long long int y = { 0, 1 };\n+\n+vector long long int\n+foo (void)\n+{\n+  return y;\n+}\n+\n+int\n+main (int argc, char *argv[])\n+{\n+  vector long long int fetched_value = foo ();\n+  if (fetched_value[0] != 0 || fetched_value[1] != 1)\n+    abort ();\n+  else\n+    return 0;\n+}"}, {"sha": "5e4073f086741bf01450606104280a5078269c81", "filename": "gcc/testsuite/gcc.target/powerpc/swaps-p8-42.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e0cc90b228ec869440df1028fc39fb0f3c9e028/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-42.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e0cc90b228ec869440df1028fc39fb0f3c9e028/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-42.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-42.c?ref=6e0cc90b228ec869440df1028fc39fb0f3c9e028", "patch": "@@ -0,0 +1,28 @@\n+/* { dg-require-effective-target powerpc_p8vector_ok } */\n+/* { dg-do compile { target { powerpc64le-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power8\" } } */\n+/* { dg-options \"-mcpu=power8 -O3 \" } */\n+/* { dg-final { scan-assembler-not \"xxpermdi\" } } */\n+/* { dg-final { scan-assembler-not \"xxswapd\" } } */\n+\n+#include <altivec.h>\n+\n+extern void abort (void);\n+\n+const vector long long int y = { 0, 1 };\n+\n+vector long long int\n+foo (void)\n+{\n+  return y;\n+}\n+\n+int\n+main (int argc, char *argv[])\n+{\n+  vector long long int fetched_value = foo ();\n+  if (fetched_value[0] != 0 || fetched_value[1] != 1)\n+    abort ();\n+  else\n+    return 0;\n+}"}, {"sha": "383394ca365e339aa9f3014c57e84063b4fb53cd", "filename": "gcc/testsuite/gcc.target/powerpc/swaps-p8-43.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e0cc90b228ec869440df1028fc39fb0f3c9e028/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-43.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e0cc90b228ec869440df1028fc39fb0f3c9e028/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-43.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-43.c?ref=6e0cc90b228ec869440df1028fc39fb0f3c9e028", "patch": "@@ -0,0 +1,26 @@\n+/* { dg-require-effective-target p8vector_hw } */\n+/* { dg-do run { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power8\" } } */\n+/* { dg-options \"-mcpu=power8 -O3 \" } */\n+\n+#include <altivec.h>\n+\n+extern void abort (void);\n+\n+vector double y = { 0.0, 0.1 };\n+\n+vector double\n+foo (void)\n+{\n+  return y;\n+}\n+\n+int\n+main (int argc, char *argv[])\n+{\n+  vector double fetched_value = foo ();\n+  if (fetched_value[0] != 0 || fetched_value[1] != 0.1)\n+    abort ();\n+  else\n+    return 0;\n+}"}, {"sha": "06323a9ed827a3d83b808dc9b65547dab98aef52", "filename": "gcc/testsuite/gcc.target/powerpc/swaps-p8-44.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e0cc90b228ec869440df1028fc39fb0f3c9e028/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-44.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e0cc90b228ec869440df1028fc39fb0f3c9e028/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-44.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-44.c?ref=6e0cc90b228ec869440df1028fc39fb0f3c9e028", "patch": "@@ -0,0 +1,26 @@\n+/* { dg-require-effective-target p8vector_hw } */\n+/* { dg-do run { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power8\" } } */\n+/* { dg-options \"-mcpu=power8 -O3 \" } */\n+\n+#include <altivec.h>\n+\n+extern void abort (void);\n+\n+const vector double y = { 0.0, 0.1 };\n+\n+vector double\n+foo (void)\n+{\n+  return y;\n+}\n+\n+int\n+main (int argc, char *argv[])\n+{\n+  vector double fetched_value = foo ();\n+  if (fetched_value[0] != 0.0 || fetched_value[1] != 0.1)\n+    abort ();\n+  else\n+    return 0;\n+}"}, {"sha": "2129bea430f4bb38bb74b8def839704ecf1d4fb7", "filename": "gcc/testsuite/gcc.target/powerpc/swaps-p8-45.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e0cc90b228ec869440df1028fc39fb0f3c9e028/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-45.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e0cc90b228ec869440df1028fc39fb0f3c9e028/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-45.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fswaps-p8-45.c?ref=6e0cc90b228ec869440df1028fc39fb0f3c9e028", "patch": "@@ -0,0 +1,28 @@\n+/* { dg-require-effective-target powerpc_p8vector_ok } */\n+/* { dg-do compile { target { powerpc64le-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power8\" } } */\n+/* { dg-options \"-mcpu=power8 -O3 \" } */\n+/* { dg-final { scan-assembler-not \"xxpermdi\" } } */\n+/* { dg-final { scan-assembler-not \"xxswapd\" } } */\n+\n+#include <altivec.h>\n+\n+extern void abort (void);\n+\n+const vector double y = { 0.0, 0.1 };\n+\n+vector double\n+foo (void)\n+{\n+  return y;\n+}\n+\n+int\n+main (int argc, char *argv[])\n+{\n+  vector double fetched_value = foo ();\n+  if (fetched_value[0] != 0.0 || fetched_value[15] != 0.1)\n+    abort ();\n+  else\n+    return 0;\n+}"}]}