{"sha": "6dab8d4cdf065d4045132d01e9c2556bdcab4195", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmRhYjhkNGNkZjA2NWQ0MDQ1MTMyZDAxZTljMjU1NmJkY2FiNDE5NQ==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2003-06-19T19:30:34Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2003-06-19T19:30:34Z"}, "message": "builtins.c (expand_errno_check): Assume that flag_errno_math and HONOR_NANS have been tested before calling here.\n\n\n\t* builtins.c (expand_errno_check): Assume that flag_errno_math\n\tand HONOR_NANS have been tested before calling here.  Only try\n\tto set errno ourselves if the decl can't throw an exception.\n\t(expand_builtin_mathfn): Move the code to stabilize the arg\n\tafter the main switch, so that that its only done when needed.\n\tBUILT_IN_SQRT{,F,L} doesn't set errno if its arg is nonnegative.\n\tDon't modify the original expr when stabilizing the argument.\n\t(expand_builtin_mathfn_2): Likewise, move the code to stabilize\n\tthe args after the main switch, and don't modify the orginal exp.\n\nFrom-SVN: r68217", "tree": {"sha": "7af02d8fec3c643ce7d7d78668269c6d7cfb822d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7af02d8fec3c643ce7d7d78668269c6d7cfb822d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6dab8d4cdf065d4045132d01e9c2556bdcab4195", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6dab8d4cdf065d4045132d01e9c2556bdcab4195", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6dab8d4cdf065d4045132d01e9c2556bdcab4195", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6dab8d4cdf065d4045132d01e9c2556bdcab4195/comments", "author": null, "committer": null, "parents": [{"sha": "cf8e4b78762b282387140a4cf54c880bbc87acd4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf8e4b78762b282387140a4cf54c880bbc87acd4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cf8e4b78762b282387140a4cf54c880bbc87acd4"}], "stats": {"total": 212, "additions": 127, "deletions": 85}, "files": [{"sha": "a470fcb6a5234da91fe7f0fce26553b03ba748dc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dab8d4cdf065d4045132d01e9c2556bdcab4195/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dab8d4cdf065d4045132d01e9c2556bdcab4195/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6dab8d4cdf065d4045132d01e9c2556bdcab4195", "patch": "@@ -1,3 +1,15 @@\n+2003-06-19  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* builtins.c (expand_errno_check): Assume that flag_errno_math\n+\tand HONOR_NANS have been tested before calling here.  Only try\n+\tto set errno ourselves if the decl can't throw an exception.\n+\t(expand_builtin_mathfn): Move the code to stabilize the arg\n+\tafter the main switch, so that that its only done when needed.\n+\tBUILT_IN_SQRT{,F,L} doesn't set errno if its arg is nonnegative.\n+\tDon't modify the original expr when stabilizing the argument.\n+\t(expand_builtin_mathfn_2): Likewise, move the code to stabilize\n+\tthe args after the main switch, and don't modify the orginal exp.\n+\n 2003-06-19  Aldy Hernandez  <aldyh@redhat.com>\n  \n         * expr.c (const_vector_from_tree): Initialize remaining elements"}, {"sha": "8f278aa06455b0d2b4e9c7e67438778381320de4", "filename": "gcc/builtins.c", "status": "modified", "additions": 115, "deletions": 85, "changes": 200, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dab8d4cdf065d4045132d01e9c2556bdcab4195/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dab8d4cdf065d4045132d01e9c2556bdcab4195/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=6dab8d4cdf065d4045132d01e9c2556bdcab4195", "patch": "@@ -1653,38 +1653,35 @@ mathfn_built_in (tree type, enum built_in_function fn)\n static void\n expand_errno_check (tree exp, rtx target)\n {\n-  rtx lab;\n+  rtx lab = gen_label_rtx ();\n \n-  if (flag_errno_math && HONOR_NANS (GET_MODE (target)))\n-    {\n-      lab = gen_label_rtx ();\n-\n-      /* Test the result; if it is NaN, set errno=EDOM because\n-\t the argument was not in the domain.  */\n-      emit_cmp_and_jump_insns (target, target, EQ, 0, GET_MODE (target),\n-\t\t\t       0, lab);\n+  /* Test the result; if it is NaN, set errno=EDOM because\n+     the argument was not in the domain.  */\n+  emit_cmp_and_jump_insns (target, target, EQ, 0, GET_MODE (target),\n+\t\t\t   0, lab);\n \n #ifdef TARGET_EDOM\n-      {\n+  /* If this built-in doesn't throw an exception, set errno directly.  */\n+  if (TREE_NOTHROW (TREE_OPERAND (TREE_OPERAND (exp, 0), 0)))\n+    {\n #ifdef GEN_ERRNO_RTX\n-\trtx errno_rtx = GEN_ERRNO_RTX;\n+      rtx errno_rtx = GEN_ERRNO_RTX;\n #else\n-\trtx errno_rtx\n+      rtx errno_rtx\n \t  = gen_rtx_MEM (word_mode, gen_rtx_SYMBOL_REF (Pmode, \"errno\"));\n #endif\n-\n-\temit_move_insn (errno_rtx, GEN_INT (TARGET_EDOM));\n-      }\n-#else\n-      /* We can't set errno=EDOM directly; let the library call do it.\n-\t Pop the arguments right away in case the call gets deleted.  */\n-      NO_DEFER_POP;\n-      expand_call (exp, target, 0);\n-      OK_DEFER_POP;\n-#endif\n-\n+      emit_move_insn (errno_rtx, GEN_INT (TARGET_EDOM));\n       emit_label (lab);\n+      return;\n     }\n+#endif\n+\n+  /* We can't set errno=EDOM directly; let the library call do it.\n+     Pop the arguments right away in case the call gets deleted.  */\n+  NO_DEFER_POP;\n+  expand_call (exp, target, 0);\n+  OK_DEFER_POP;\n+  emit_label (lab);\n }\n \n \n@@ -1701,35 +1698,14 @@ expand_builtin_mathfn (tree exp, rtx target, rtx subtarget)\n   rtx op0, insns;\n   tree fndecl = TREE_OPERAND (TREE_OPERAND (exp, 0), 0);\n   tree arglist = TREE_OPERAND (exp, 1);\n-  enum machine_mode argmode;\n+  enum machine_mode mode;\n   bool errno_set = false;\n+  tree arg;\n \n   if (!validate_arglist (arglist, REAL_TYPE, VOID_TYPE))\n     return 0;\n \n-  /* Stabilize and compute the argument.  */\n-  if (TREE_CODE (TREE_VALUE (arglist)) != VAR_DECL\n-      && TREE_CODE (TREE_VALUE (arglist)) != PARM_DECL)\n-    {\n-      exp = copy_node (exp);\n-      TREE_OPERAND (exp, 1) = arglist;\n-      /* Wrap the computation of the argument in a SAVE_EXPR.  That\n-\t way, if we need to expand the argument again (as in the\n-\t flag_errno_math case below where we cannot directly set\n-\t errno), we will not perform side-effects more than once.\n-\t Note that here we're mutating the original EXP as well as the\n-\t copy; that's the right thing to do in case the original EXP\n-\t is expanded later.  */\n-      TREE_VALUE (arglist) = save_expr (TREE_VALUE (arglist));\n-      arglist = copy_node (arglist);\n-    }\n-  op0 = expand_expr (TREE_VALUE (arglist), subtarget, VOIDmode, 0);\n-\n-  /* Make a suitable register to place result in.  */\n-  target = gen_reg_rtx (TYPE_MODE (TREE_TYPE (exp)));\n-\n-  emit_queue ();\n-  start_sequence ();\n+  arg = TREE_VALUE (arglist);\n \n   switch (DECL_FUNCTION_CODE (fndecl))\n     {\n@@ -1744,7 +1720,9 @@ expand_builtin_mathfn (tree exp, rtx target, rtx subtarget)\n     case BUILT_IN_SQRT:\n     case BUILT_IN_SQRTF:\n     case BUILT_IN_SQRTL:\n-      errno_set = true; builtin_optab = sqrt_optab; break;\n+      errno_set = ! tree_expr_nonnegative_p (arg);\n+      builtin_optab = sqrt_optab;\n+      break;\n     case BUILT_IN_EXP:\n     case BUILT_IN_EXPF:\n     case BUILT_IN_EXPL:\n@@ -1785,10 +1763,41 @@ expand_builtin_mathfn (tree exp, rtx target, rtx subtarget)\n       abort ();\n     }\n \n+  /* Make a suitable register to place result in.  */\n+  mode = TYPE_MODE (TREE_TYPE (exp));\n+  target = gen_reg_rtx (mode);\n+\n+  if (! flag_errno_math || ! HONOR_NANS (mode))\n+    errno_set = false;\n+\n+  /* Stabilize and compute the argument.  */\n+  if (errno_set)\n+    switch (TREE_CODE (arg))\n+      {\n+      case VAR_DECL:\n+      case PARM_DECL:\n+      case SAVE_EXPR:\n+      case REAL_CST:\n+\tbreak;\n+\n+      default:\n+\t/* Wrap the computation of the argument in a SAVE_EXPR, as we\n+\t   need to expand the argument again in expand_errno_check.  This\n+\t   way, we will not perform side-effects more the once.  */\n+\targ = save_expr (arg);\n+\targlist = build_tree_list (NULL_TREE, arg);\n+\texp = build_function_call_expr (fndecl, arglist);\n+\tbreak;\n+      }\n+\n+  op0 = expand_expr (arg, subtarget, VOIDmode, 0);\n+\n+  emit_queue ();\n+  start_sequence ();\n+\n   /* Compute into TARGET.\n      Set TARGET to wherever the result comes back.  */\n-  argmode = TYPE_MODE (TREE_TYPE (TREE_VALUE (arglist)));\n-  target = expand_unop (argmode, builtin_optab, op0, target, 0);\n+  target = expand_unop (mode, builtin_optab, op0, target, 0);\n \n   /* If we were unable to expand via the builtin, stop the\n      sequence (without outputting the insns) and return 0, causing\n@@ -1824,8 +1833,8 @@ expand_builtin_mathfn_2 (tree exp, rtx target, rtx subtarget)\n   rtx op0, op1, insns;\n   tree fndecl = TREE_OPERAND (TREE_OPERAND (exp, 0), 0);\n   tree arglist = TREE_OPERAND (exp, 1);\n-  tree arg0, arg1;\n-  enum machine_mode argmode;\n+  tree arg0, arg1, temp;\n+  enum machine_mode mode;\n   bool errno_set = true;\n   bool stable = true;\n \n@@ -1835,37 +1844,6 @@ expand_builtin_mathfn_2 (tree exp, rtx target, rtx subtarget)\n   arg0 = TREE_VALUE (arglist);\n   arg1 = TREE_VALUE (TREE_CHAIN (arglist));\n \n-  /* Stabilize the arguments.  */\n-  if (TREE_CODE (arg0) != VAR_DECL && TREE_CODE (arg0) != PARM_DECL)\n-    {\n-      arg0 = save_expr (arg0);\n-      TREE_VALUE (arglist) = arg0;\n-      stable = false;\n-    }\n-  if (TREE_CODE (arg1) != VAR_DECL && TREE_CODE (arg1) != PARM_DECL)\n-    {\n-      arg1 = save_expr (arg1);\n-      TREE_VALUE (TREE_CHAIN (arglist)) = arg1;\n-      stable = false;\n-    }\n-\n-  if (! stable)\n-    {\n-      exp = copy_node (exp);\n-      arglist = tree_cons (NULL_TREE, arg0,\n-\t\t\t   build_tree_list (NULL_TREE, arg1));\n-      TREE_OPERAND (exp, 1) = arglist;\n-    }\n-\n-  op0 = expand_expr (arg0, subtarget, VOIDmode, 0);\n-  op1 = expand_expr (arg1, 0, VOIDmode, 0);\n-\n-  /* Make a suitable register to place result in.  */\n-  target = gen_reg_rtx (TYPE_MODE (TREE_TYPE (exp)));\n-\n-  emit_queue ();\n-  start_sequence ();\n-\n   switch (DECL_FUNCTION_CODE (fndecl))\n     {\n     case BUILT_IN_POW:\n@@ -1880,10 +1858,62 @@ expand_builtin_mathfn_2 (tree exp, rtx target, rtx subtarget)\n       abort ();\n     }\n \n+  /* Make a suitable register to place result in.  */\n+  mode = TYPE_MODE (TREE_TYPE (exp));\n+  target = gen_reg_rtx (mode);\n+\n+  if (! flag_errno_math || ! HONOR_NANS (mode))\n+    errno_set = false;\n+\n+  /* Stabilize the arguments.  */\n+  if (errno_set)\n+    {\n+      switch (TREE_CODE (arg1))\n+\t{\n+\tcase VAR_DECL:\n+\tcase PARM_DECL:\n+\tcase SAVE_EXPR:\n+\tcase REAL_CST:\n+\t  temp = TREE_CHAIN (arglist);\n+\t  break;\n+\n+\tdefault:\n+\t  stable = false;\n+\t  arg1 = save_expr (arg1);\n+\t  temp = build_tree_list (NULL_TREE, arg1);\n+\t  break;\n+        }\n+\n+      switch (TREE_CODE (arg0))\n+\t{\n+\tcase VAR_DECL:\n+\tcase PARM_DECL:\n+\tcase SAVE_EXPR:\n+\tcase REAL_CST:\n+\t  if (! stable)\n+\t    arglist = build_tree_list (temp, arg0);\n+\t  break;\n+\n+\tdefault:\n+\t  stable = false;\n+\t  arg0 = save_expr (arg0);\n+\t  arglist = build_tree_list (temp, arg0);\n+\t  break;\n+\t}\n+\n+      if (! stable)\n+\texp = build_function_call_expr (fndecl, arglist);\n+    }\n+\n+  op0 = expand_expr (arg0, subtarget, VOIDmode, 0);\n+  op1 = expand_expr (arg1, 0, VOIDmode, 0);\n+\n+  emit_queue ();\n+  start_sequence ();\n+\n   /* Compute into TARGET.\n      Set TARGET to wherever the result comes back.  */\n-  argmode = TYPE_MODE (TREE_TYPE (arg0));\n-  target = expand_binop (argmode, builtin_optab, op0, op1,\n+  target = expand_binop (mode, builtin_optab, op0, op1,\n \t\t\t target, 0, OPTAB_DIRECT);\n \n   /* If we were unable to expand via the builtin, stop the"}]}