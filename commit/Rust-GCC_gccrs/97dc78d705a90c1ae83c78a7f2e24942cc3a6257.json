{"sha": "97dc78d705a90c1ae83c78a7f2e24942cc3a6257", "node_id": "C_kwDOANBUbNoAKDk3ZGM3OGQ3MDVhOTBjMWFlODNjNzhhN2YyZTI0OTQyY2MzYTYyNTc", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2022-05-26T13:43:14Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2022-05-26T13:43:14Z"}, "message": "c++: constrained partial spec forward decl [PR96363]\n\nHere during cp_parser_single_declaration for #2, we were calling\nassociate_classtype_constraints for TPL<T> (the primary template type)\nbefore maybe_process_partial_specialization could get a chance to\nnotice that we're in fact declaring a distinct constrained partial\nspec and not redeclaring the primary template.  This caused us to\nemit a bogus error about differing constraints b/t the primary template\nand #2's constraints.  This patch fixes this by moving the call to\nassociate_classtype_constraints after the call to shadow_tag (which\ncalls maybe_process_partial_specialization) and adjusting shadow_tag to\nuse the return value of m_p_p_s.\n\nMoreover, if we later try to define a constrained partial specialization\nthat's been declared earlier (as in the third testcase), then\nmaybe_new_partial_specialization correctly notices it's a redeclaration\nand returns NULL_TREE.  But in this case we also need to update TYPE to\npoint to the redeclared partial spec (it'll otherwise continue pointing\nto the primary template type, eventually leading to a bogus error).\n\n\tPR c++/96363\n\ngcc/cp/ChangeLog:\n\n\t* decl.cc (shadow_tag): Use the return value of\n\tmaybe_process_partial_specialization.\n\t* parser.cc (cp_parser_single_declaration): Call shadow_tag\n\tbefore associate_classtype_constraints.\n\t* pt.cc (maybe_new_partial_specialization): Change return type\n\tto bool.  Take 'type' argument by mutable reference.  Set 'type'\n\tto point to the correct constrained specialization when\n\tappropriate.\n\t(maybe_process_partial_specialization): Adjust accordingly.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/cpp2a/concepts-partial-spec12.C: New test.\n\t* g++.dg/cpp2a/concepts-partial-spec12a.C: New test.\n\t* g++.dg/cpp2a/concepts-partial-spec13.C: New test.", "tree": {"sha": "411af4c56d65173191b9a3c09b7098031fc8d7b3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/411af4c56d65173191b9a3c09b7098031fc8d7b3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/97dc78d705a90c1ae83c78a7f2e24942cc3a6257", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/97dc78d705a90c1ae83c78a7f2e24942cc3a6257", "html_url": "https://github.com/Rust-GCC/gccrs/commit/97dc78d705a90c1ae83c78a7f2e24942cc3a6257", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/97dc78d705a90c1ae83c78a7f2e24942cc3a6257/comments", "author": null, "committer": null, "parents": [{"sha": "692643c3ed3b7b82dde6b890c76b611c3ea371f0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/692643c3ed3b7b82dde6b890c76b611c3ea371f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/692643c3ed3b7b82dde6b890c76b611c3ea371f0"}], "stats": {"total": 93, "additions": 69, "deletions": 24}, "files": [{"sha": "892e4a4b19b73ce0410f11a39d76e967503c0777", "filename": "gcc/cp/decl.cc", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97dc78d705a90c1ae83c78a7f2e24942cc3a6257/gcc%2Fcp%2Fdecl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97dc78d705a90c1ae83c78a7f2e24942cc3a6257/gcc%2Fcp%2Fdecl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.cc?ref=97dc78d705a90c1ae83c78a7f2e24942cc3a6257", "patch": "@@ -5464,7 +5464,8 @@ shadow_tag (cp_decl_specifier_seq *declspecs)\n   if (!t)\n     return NULL_TREE;\n \n-  if (maybe_process_partial_specialization (t) == error_mark_node)\n+  t = maybe_process_partial_specialization (t);\n+  if (t == error_mark_node)\n     return NULL_TREE;\n \n   /* This is where the variables in an anonymous union are"}, {"sha": "a6af9939c33e2fc680d308b0fc9dc8f160346457", "filename": "gcc/cp/parser.cc", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97dc78d705a90c1ae83c78a7f2e24942cc3a6257/gcc%2Fcp%2Fparser.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97dc78d705a90c1ae83c78a7f2e24942cc3a6257/gcc%2Fcp%2Fparser.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.cc?ref=97dc78d705a90c1ae83c78a7f2e24942cc3a6257", "patch": "@@ -31811,12 +31811,6 @@ cp_parser_single_declaration (cp_parser* parser,\n       if (cp_parser_declares_only_class_p (parser)\n \t  || (declares_class_or_enum & 2))\n \t{\n-\t  /* If this is a declaration, but not a definition, associate\n-\t     any constraints with the type declaration. Constraints\n-\t     are associated with definitions in cp_parser_class_specifier.  */\n-\t  if (declares_class_or_enum == 1)\n-\t    associate_classtype_constraints (decl_specifiers.type);\n-\n \t  decl = shadow_tag (&decl_specifiers);\n \n \t  /* In this case:\n@@ -31838,6 +31832,12 @@ cp_parser_single_declaration (cp_parser* parser,\n \t  else\n \t    decl = error_mark_node;\n \n+\t  /* If this is a declaration, but not a definition, associate\n+\t     any constraints with the type declaration. Constraints\n+\t     are associated with definitions in cp_parser_class_specifier.  */\n+\t  if (declares_class_or_enum == 1)\n+\t    associate_classtype_constraints (TREE_TYPE (decl));\n+\n \t  /* Perform access checks for template parameters.  */\n \t  cp_parser_perform_template_parameter_access_checks (checks);\n "}, {"sha": "24bbe2f406081e41cc17e8bdf75a64c5a5b30c11", "filename": "gcc/cp/pt.cc", "status": "modified", "additions": 21, "deletions": 17, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97dc78d705a90c1ae83c78a7f2e24942cc3a6257/gcc%2Fcp%2Fpt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97dc78d705a90c1ae83c78a7f2e24942cc3a6257/gcc%2Fcp%2Fpt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.cc?ref=97dc78d705a90c1ae83c78a7f2e24942cc3a6257", "patch": "@@ -874,12 +874,12 @@ check_explicit_instantiation_namespace (tree spec)\n \t       spec, current_namespace, ns);\n }\n \n-/* Returns the type of a template specialization only if that\n-   specialization needs to be defined. Otherwise (e.g., if the type has\n-   already been defined), the function returns NULL_TREE.  */\n+/* Returns true if TYPE is a new partial specialization that needs to be\n+   set up.  This may also modify TYPE to point to the correct (new or\n+   existing) constrained partial specialization.  */\n \n-static tree\n-maybe_new_partial_specialization (tree type)\n+static bool\n+maybe_new_partial_specialization (tree& type)\n {\n   /* An implicit instantiation of an incomplete type implies\n      the definition of a new class template.\n@@ -893,7 +893,7 @@ maybe_new_partial_specialization (tree type)\n      Here, S<T*> is an implicit instantiation of S whose type\n      is incomplete.  */\n   if (CLASSTYPE_IMPLICIT_INSTANTIATION (type) && !COMPLETE_TYPE_P (type))\n-    return type;\n+    return true;\n \n   /* It can also be the case that TYPE is a completed specialization.\n      Continuing the previous example, suppose we also declare:\n@@ -919,11 +919,11 @@ maybe_new_partial_specialization (tree type)\n       /* If there are no template parameters, this cannot be a new\n \t partial template specialization?  */\n       if (!current_template_parms)\n-        return NULL_TREE;\n+\treturn false;\n \n       /* The injected-class-name is not a new partial specialization.  */\n       if (DECL_SELF_REFERENCE_P (TYPE_NAME (type)))\n-\treturn NULL_TREE;\n+\treturn false;\n \n       /* If the constraints are not the same as those of the primary\n \t then, we can probably create a new specialization.  */\n@@ -933,7 +933,7 @@ maybe_new_partial_specialization (tree type)\n \t{\n \t  tree main_constr = get_constraints (tmpl);\n \t  if (equivalent_constraints (type_constr, main_constr))\n-\t    return NULL_TREE;\n+\t    return false;\n \t}\n \n       /* Also, if there's a pre-existing specialization with matching\n@@ -946,7 +946,10 @@ maybe_new_partial_specialization (tree type)\n           tree spec_constr = get_constraints (spec_tmpl);\n           if (comp_template_args (args, spec_args)\n \t      && equivalent_constraints (type_constr, spec_constr))\n-            return NULL_TREE;\n+\t    {\n+\t      type = TREE_TYPE (spec_tmpl);\n+\t      return false;\n+\t    }\n           specs = TREE_CHAIN (specs);\n         }\n \n@@ -971,10 +974,11 @@ maybe_new_partial_specialization (tree type)\n       set_instantiating_module (d);\n       DECL_MODULE_EXPORT_P (d) = DECL_MODULE_EXPORT_P (tmpl);\n \n-      return t;\n+      type = t;\n+      return true;\n     }\n \n-  return NULL_TREE;\n+  return false;\n }\n \n /* The TYPE is being declared.  If it is a template type, that means it\n@@ -1030,16 +1034,16 @@ maybe_process_partial_specialization (tree type)\n \n \t Make sure that `C<int>' and `C<T*>' are implicit instantiations.  */\n \n-      if (tree t = maybe_new_partial_specialization (type))\n+      if (maybe_new_partial_specialization (type))\n \t{\n-\t  if (!check_specialization_namespace (CLASSTYPE_TI_TEMPLATE (t))\n+\t  if (!check_specialization_namespace (CLASSTYPE_TI_TEMPLATE (type))\n \t      && !at_namespace_scope_p ())\n \t    return error_mark_node;\n-\t  SET_CLASSTYPE_TEMPLATE_SPECIALIZATION (t);\n-\t  DECL_SOURCE_LOCATION (TYPE_MAIN_DECL (t)) = input_location;\n+\t  SET_CLASSTYPE_TEMPLATE_SPECIALIZATION (type);\n+\t  DECL_SOURCE_LOCATION (TYPE_MAIN_DECL (type)) = input_location;\n \t  if (processing_template_decl)\n \t    {\n-\t      tree decl = push_template_decl (TYPE_MAIN_DECL (t));\n+\t      tree decl = push_template_decl (TYPE_MAIN_DECL (type));\n \t      if (decl == error_mark_node)\n \t\treturn error_mark_node;\n \t      return TREE_TYPE (decl);"}, {"sha": "9bb6e2d9ea6857f41074af4a576bdc0c1067b588", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-partial-spec12.C", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97dc78d705a90c1ae83c78a7f2e24942cc3a6257/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-partial-spec12.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97dc78d705a90c1ae83c78a7f2e24942cc3a6257/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-partial-spec12.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-partial-spec12.C?ref=97dc78d705a90c1ae83c78a7f2e24942cc3a6257", "patch": "@@ -0,0 +1,10 @@\n+// PR c++/96363\n+// { dg-do compile { target c++20 } }\n+\n+template<class T> class TPL;\n+\n+template<class T> requires true  class TPL<T>;   // #1\n+template<class T> requires false class TPL<T>;   // #2 error here\n+\n+template<class T> requires true  class TPL<T*>;  // #1\n+template<class T> requires false class TPL<T*>;  // #2 error here"}, {"sha": "6d23a28892dda1587e72b2c13b502f0b3a007b65", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-partial-spec12a.C", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97dc78d705a90c1ae83c78a7f2e24942cc3a6257/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-partial-spec12a.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97dc78d705a90c1ae83c78a7f2e24942cc3a6257/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-partial-spec12a.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-partial-spec12a.C?ref=97dc78d705a90c1ae83c78a7f2e24942cc3a6257", "patch": "@@ -0,0 +1,14 @@\n+// PR c++/96363\n+// { dg-do compile { target c++20 } }\n+// A version of concepts-partial-spec12.C where the primary template is\n+// constrained.\n+\n+template<class T> concept C = true;\n+\n+template<C T> class TPL;\n+\n+template<C T> requires true  class TPL<T>;   // #1\n+template<C T> requires false class TPL<T>;   // #2 error here\n+\n+template<C T> requires true  class TPL<T*>;  // #1\n+template<C T> requires false class TPL<T*>;  // #2 error here"}, {"sha": "b5ec2c92585b2595dbec39a7c86bbc07a82b4219", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-partial-spec13.C", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97dc78d705a90c1ae83c78a7f2e24942cc3a6257/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-partial-spec13.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97dc78d705a90c1ae83c78a7f2e24942cc3a6257/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-partial-spec13.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-partial-spec13.C?ref=97dc78d705a90c1ae83c78a7f2e24942cc3a6257", "patch": "@@ -0,0 +1,16 @@\n+// PR c++/99501\n+// { dg-do compile { target c++20 } }\n+\n+template<auto> struct X;\n+\n+template<auto V> requires requires{V.a;} struct X<V>;\n+template<auto V> requires requires{V.b;} struct X<V>;\n+\n+template<auto V> requires requires{V.a;} struct X<V> { static const bool v = false; };\n+template<auto V> requires requires{V.b;} struct X<V> { static const bool v = true; };\n+\n+struct A { int a; };\n+static_assert(!X<A{}>::v);\n+\n+struct B { int b; };\n+static_assert(X<B{}>::v);"}]}