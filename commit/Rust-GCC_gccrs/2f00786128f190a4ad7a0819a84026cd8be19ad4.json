{"sha": "2f00786128f190a4ad7a0819a84026cd8be19ad4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmYwMDc4NjEyOGYxOTBhNGFkN2EwODE5YTg0MDI2Y2Q4YmUxOWFkNA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2019-09-30T18:36:11Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2019-09-30T18:36:11Z"}, "message": "[x86] Cache result of expensive_function_p between frame layouts\n\nix86_compute_frame_layout sets use_fast_prologue_epilogue if\nthe function isn't more expensive than a certain threshold,\nwhere the threshold depends on the number of saved registers.\nHowever, the RA is allowed to insert and delete instructions\nas it goes along, which can change whether this threshold is\ncrossed or not.\n\nI hit this with an RA change I'm working on.  Rematerialisation\nwas able to remove an instruction and avoid a spill, which happened\nto bring the size of the function below the threshold.  But since\nnothing legitimately frame-related had changed, there was no need for\nthe RA to lay out the frame again.  We then failed the final sanity\ncheck in lra_eliminate.\n\n2019-09-30  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* config/i386/i386.h (ix86_frame::expensive_p): New field.\n\t(ix86_frame::expensive_count): Likewise.\n\t* config/i386/i386.c (ix86_compute_frame_layout): Make the choice\n\tof use_fast_prologue_epilogue robust against incidental changes\n\tin function size.\n\nFrom-SVN: r276361", "tree": {"sha": "77d073fc875526d85db3c49a3a2cfcd3033cdb04", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/77d073fc875526d85db3c49a3a2cfcd3033cdb04"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2f00786128f190a4ad7a0819a84026cd8be19ad4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f00786128f190a4ad7a0819a84026cd8be19ad4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2f00786128f190a4ad7a0819a84026cd8be19ad4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f00786128f190a4ad7a0819a84026cd8be19ad4/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "021f65807164b2770e8f113b0f85b1bb193020ef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/021f65807164b2770e8f113b0f85b1bb193020ef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/021f65807164b2770e8f113b0f85b1bb193020ef"}], "stats": {"total": 32, "additions": 29, "deletions": 3}, "files": [{"sha": "f665a5c684c6a73a0d651a225b916706c2b54f09", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f00786128f190a4ad7a0819a84026cd8be19ad4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f00786128f190a4ad7a0819a84026cd8be19ad4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2f00786128f190a4ad7a0819a84026cd8be19ad4", "patch": "@@ -1,3 +1,11 @@\n+2019-09-30  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* config/i386/i386.h (ix86_frame::expensive_p): New field.\n+\t(ix86_frame::expensive_count): Likewise.\n+\t* config/i386/i386.c (ix86_compute_frame_layout): Make the choice\n+\tof use_fast_prologue_epilogue robust against incidental changes\n+\tin function size.\n+\n 2019-09-30  Ilya Leoshkevich  <iii@linux.ibm.com>\n \n \tPR target/77918"}, {"sha": "083e2280d00be5caa9e0dcdc87d5d208d104410e", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f00786128f190a4ad7a0819a84026cd8be19ad4/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f00786128f190a4ad7a0819a84026cd8be19ad4/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=2f00786128f190a4ad7a0819a84026cd8be19ad4", "patch": "@@ -5877,16 +5877,29 @@ ix86_compute_frame_layout (void)\n \t case function is known to be outside hot spot (this is known with\n \t feedback only).  Weight the size of function by number of registers\n \t to save as it is cheap to use one or two push instructions but very\n-\t slow to use many of them.  */\n+\t slow to use many of them.\n+\n+\t Calling this hook multiple times with the same frame requirements\n+\t must produce the same layout, since the RA might otherwise be\n+\t unable to reach a fixed point or might fail its final sanity checks.\n+\t This means that once we've assumed that a function does or doesn't\n+\t have a particular size, we have to stick to that assumption\n+\t regardless of how the function has changed since.  */\n       if (count)\n \tcount = (count - 1) * FAST_PROLOGUE_INSN_COUNT;\n       if (node->frequency < NODE_FREQUENCY_NORMAL\n \t  || (flag_branch_probabilities\n \t      && node->frequency < NODE_FREQUENCY_HOT))\n \tm->use_fast_prologue_epilogue = false;\n       else\n-\tm->use_fast_prologue_epilogue\n-\t   = !expensive_function_p (count);\n+\t{\n+\t  if (count != frame->expensive_count)\n+\t    {\n+\t      frame->expensive_count = count;\n+\t      frame->expensive_p = expensive_function_p (count);\n+\t    }\n+\t  m->use_fast_prologue_epilogue = !frame->expensive_p;\n+\t}\n     }\n \n   frame->save_regs_using_mov"}, {"sha": "4e37336c7140d294e4254c8b7de07b330a2cae64", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2f00786128f190a4ad7a0819a84026cd8be19ad4/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2f00786128f190a4ad7a0819a84026cd8be19ad4/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=2f00786128f190a4ad7a0819a84026cd8be19ad4", "patch": "@@ -2643,6 +2643,11 @@ struct GTY(()) ix86_frame\n   /* When save_regs_using_mov is set, emit prologue using\n      move instead of push instructions.  */\n   bool save_regs_using_mov;\n+\n+  /* Assume without checking that:\n+       EXPENSIVE_P = expensive_function_p (EXPENSIVE_COUNT).  */\n+  bool expensive_p;\n+  int expensive_count;\n };\n \n /* Machine specific frame tracking during prologue/epilogue generation.  All"}]}