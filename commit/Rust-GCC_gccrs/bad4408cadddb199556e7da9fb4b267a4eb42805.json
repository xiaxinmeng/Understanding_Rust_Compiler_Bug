{"sha": "bad4408cadddb199556e7da9fb4b267a4eb42805", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmFkNDQwOGNhZGRkYjE5OTU1NmU3ZGE5ZmI0YjI2N2E0ZWI0MjgwNQ==", "commit": {"author": {"name": "John David Anglin", "email": "danglin@gcc.gnu.org", "date": "2018-09-20T01:04:34Z"}, "committer": {"name": "John David Anglin", "email": "danglin@gcc.gnu.org", "date": "2018-09-20T01:04:34Z"}, "message": "pa.md (atomic_storeqi): Restore deleted expander.\n\n\t* config/pa/pa.md (atomic_storeqi): Restore deleted expander.\n\t(atomic_storehi): Likewise.\n\t(atomic_storesi): Likewise.\n\t(atomic_loaddi): Restore compare and swap exchange loop code.\n\nFrom-SVN: r264433", "tree": {"sha": "7536be4425b98e43853dc88d25d2136a262e0e65", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7536be4425b98e43853dc88d25d2136a262e0e65"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bad4408cadddb199556e7da9fb4b267a4eb42805", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bad4408cadddb199556e7da9fb4b267a4eb42805", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bad4408cadddb199556e7da9fb4b267a4eb42805", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bad4408cadddb199556e7da9fb4b267a4eb42805/comments", "author": null, "committer": null, "parents": [{"sha": "fa8332f13f2e0c97ecaa7e6f86a7e866ae2e73fc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa8332f13f2e0c97ecaa7e6f86a7e866ae2e73fc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fa8332f13f2e0c97ecaa7e6f86a7e866ae2e73fc"}], "stats": {"total": 69, "additions": 68, "deletions": 1}, "files": [{"sha": "30e784e61dbdbc0993886cbccf64bdae9039c534", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bad4408cadddb199556e7da9fb4b267a4eb42805/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bad4408cadddb199556e7da9fb4b267a4eb42805/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bad4408cadddb199556e7da9fb4b267a4eb42805", "patch": "@@ -1,3 +1,10 @@\n+2018-09-19  John David Anglin  <danglin@gcc.gnu.org>\n+\n+\t* config/pa/pa.md (atomic_storeqi): Restore deleted expander.\n+\t(atomic_storehi): Likewise.\n+\t(atomic_storesi): Likewise.\n+\t(atomic_loaddi): Restore compare and swap exchange loop code.\n+\n 2018-09-19  Segher Boessenkool  <segher@kernel.crashing.org>\n \n \tPR rtl-optimization/86902"}, {"sha": "77611503c67732fb71114e7f1d8e7c1a8883ef41", "filename": "gcc/config/pa/pa.md", "status": "modified", "additions": 61, "deletions": 1, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bad4408cadddb199556e7da9fb4b267a4eb42805/gcc%2Fconfig%2Fpa%2Fpa.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bad4408cadddb199556e7da9fb4b267a4eb42805/gcc%2Fconfig%2Fpa%2Fpa.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.md?ref=bad4408cadddb199556e7da9fb4b267a4eb42805", "patch": "@@ -9958,7 +9958,59 @@ add,l %2,%3,%3\\;bv,n %%r0(%3)\"\n \n ;; These patterns are at the bottom so the non atomic versions are preferred.\n \n-;; Implement atomic DImode load using 64-bit floating point load.\n+(define_expand \"atomic_storeqi\"\n+  [(match_operand:QI 0 \"memory_operand\")                ;; memory\n+   (match_operand:QI 1 \"register_operand\")              ;; val out\n+   (match_operand:SI 2 \"const_int_operand\")]            ;; model\n+  \"\"\n+{\n+  if (TARGET_SYNC_LIBCALL)\n+    {\n+      rtx mem = operands[0];\n+      rtx val = operands[1];\n+      if (pa_maybe_emit_compare_and_swap_exchange_loop (NULL_RTX, mem, val))\n+\tDONE;\n+    }\n+  FAIL;\n+})\n+\n+;; Implement atomic HImode stores using exchange.\n+\n+(define_expand \"atomic_storehi\"\n+  [(match_operand:HI 0 \"memory_operand\")                ;; memory\n+   (match_operand:HI 1 \"register_operand\")              ;; val out\n+   (match_operand:SI 2 \"const_int_operand\")]            ;; model\n+  \"\"\n+{\n+  if (TARGET_SYNC_LIBCALL)\n+    {\n+      rtx mem = operands[0];\n+      rtx val = operands[1];\n+      if (pa_maybe_emit_compare_and_swap_exchange_loop (NULL_RTX, mem, val))\n+\tDONE;\n+    }\n+  FAIL;\n+})\n+\n+;; Implement atomic SImode store using exchange.\n+\n+(define_expand \"atomic_storesi\"\n+  [(match_operand:SI 0 \"memory_operand\")                ;; memory\n+   (match_operand:SI 1 \"register_operand\")              ;; val out\n+   (match_operand:SI 2 \"const_int_operand\")]            ;; model\n+  \"\"\n+{\n+  if (TARGET_SYNC_LIBCALL)\n+    {\n+      rtx mem = operands[0];\n+      rtx val = operands[1];\n+      if (pa_maybe_emit_compare_and_swap_exchange_loop (NULL_RTX, mem, val))\n+\tDONE;\n+    }\n+  FAIL;\n+})\n+\n+;; Implement atomic DImode load.\n \n (define_expand \"atomic_loaddi\"\n   [(match_operand:DI 0 \"register_operand\")              ;; val out\n@@ -9999,6 +10051,14 @@ add,l %2,%3,%3\\;bv,n %%r0(%3)\"\n {\n   enum memmodel model;\n \n+  if (TARGET_SYNC_LIBCALL)\n+    {\n+      rtx mem = operands[0];\n+      rtx val = operands[1];\n+      if (pa_maybe_emit_compare_and_swap_exchange_loop (NULL_RTX, mem, val))\n+\tDONE;\n+    }\n+\n   if (TARGET_64BIT || TARGET_DISABLE_FPREGS || TARGET_SOFT_FLOAT)\n     FAIL;\n "}]}