{"sha": "9805965e3551b66b5bd751d6076791d00cdeb137", "node_id": "C_kwDOANBUbNoAKDk4MDU5NjVlMzU1MWI2NmI1YmQ3NTFkNjA3Njc5MWQwMGNkZWIxMzc", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2022-03-03T12:34:27Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2022-03-03T22:24:45Z"}, "message": "libstdc++: Implement std::strong_order for floating-point types [PR96526]\n\nThis removes a FIXME in <compare>, defining the total order for\nfloating-point types. I originally opened PR96526 to request a new\ncompiler built-in to implement this, but now that we have std::bit_cast\nit can be done entirely in the library.\n\nThe implementation is based on the glibc definitions of totalorder,\ntotalorderf, totalorderl etc.\n\nI think this works for all the types that satisfy std::floating_point\ntoday, and should also work for the types expected to be added by P1467\nexcept for std::bfloat16_t. It also supports some additional types that\ndon't currently satisfy std::floating_point, such as __float80, but we\nprobably do want that to satisfy the concept for non-strict modes.\n\nlibstdc++-v3/ChangeLog:\n\n\tPR libstdc++/96526\n\t* libsupc++/compare (strong_order): Add missing support for\n\tfloating-point types.\n\t* testsuite/18_support/comparisons/algorithms/strong_order_floats.cc:\n\tNew test.", "tree": {"sha": "288db4761d23164160d952f925428e5fea5b5281", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/288db4761d23164160d952f925428e5fea5b5281"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9805965e3551b66b5bd751d6076791d00cdeb137", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9805965e3551b66b5bd751d6076791d00cdeb137", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9805965e3551b66b5bd751d6076791d00cdeb137", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9805965e3551b66b5bd751d6076791d00cdeb137/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "51149a05b8cc8e4fc5a77a65857894daa371de89", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51149a05b8cc8e4fc5a77a65857894daa371de89", "html_url": "https://github.com/Rust-GCC/gccrs/commit/51149a05b8cc8e4fc5a77a65857894daa371de89"}], "stats": {"total": 355, "additions": 351, "deletions": 4}, "files": [{"sha": "a8747207b23557684ec25bdc02a5903ae1cdfb70", "filename": "libstdc++-v3/libsupc++/compare", "status": "modified", "additions": 249, "deletions": 4, "changes": 253, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9805965e3551b66b5bd751d6076791d00cdeb137/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fcompare", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9805965e3551b66b5bd751d6076791d00cdeb137/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fcompare", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Fcompare?ref=9805965e3551b66b5bd751d6076791d00cdeb137", "patch": "@@ -642,7 +642,7 @@ namespace std\n     template<typename _Tp, typename _Up>\n       concept __strongly_ordered\n \t= __adl_strong<_Tp, _Up>\n-\t  // FIXME: || floating_point<remove_reference_t<_Tp>>\n+\t  || floating_point<remove_reference_t<_Tp>>\n \t  || __cmp3way<strong_ordering, _Tp, _Up>;\n \n     template<typename _Tp, typename _Up>\n@@ -667,17 +667,262 @@ namespace std\n       friend class _Weak_order;\n       friend class _Strong_fallback;\n \n+      // Names for the supported floating-point representations.\n+      enum class _Fp_fmt\n+      {\n+\t_Binary16, _Binary32, _Binary64, _Binary128, // IEEE\n+\t_X86_80bit,  // x86 80-bit extended precision\n+\t_M68k_80bit, // m68k 80-bit extended precision\n+\t_Dbldbl, // IBM 128-bit double-double\n+\t// TODO: _Bfloat16,\n+      };\n+\n+      // Identify the format used by a floating-point type.\n+      template<typename _Tp>\n+\tstatic consteval _Fp_fmt\n+\t_S_fp_fmt() noexcept\n+\t{\n+\t  using enum _Fp_fmt;\n+\n+\t  // Identify these formats first, then assume anything else is IEEE.\n+\t  // N.B. ARM __fp16 alternative format can be handled as binary16.\n+\n+#ifdef __LONG_DOUBLE_IBM128__\n+\t  if constexpr (__is_same(_Tp, long double))\n+\t    return _Dbldbl;\n+#elif defined __LONG_DOUBLE_IEEE128__ && defined __SIZEOF_IBM128__\n+\t  if constexpr (__is_same(_Tp, __ibm128))\n+\t    return _Dbldbl;\n+#endif\n+\n+#if __LDBL_MANT_DIG__ == 64\n+\t  if constexpr (__is_same(_Tp, long double))\n+\t    return __LDBL_MIN_EXP__ == -16381 ? _X86_80bit : _M68k_80bit;\n+#endif\n+#ifdef __SIZEOF_FLOAT80__\n+\t  if constexpr (__is_same(_Tp, __float80))\n+\t    return _X86_80bit;\n+#endif\n+\n+\t  constexpr int __width = sizeof(_Tp) * __CHAR_BIT__;\n+\n+\t  if constexpr (__width == 16)       // IEEE binary16 (or ARM fp16).\n+\t    return _Binary16;\n+\t  else if constexpr (__width == 32)  // IEEE binary32\n+\t    return _Binary32;\n+\t  else if constexpr (__width == 64)  // IEEE binary64\n+\t    return _Binary64;\n+\t  else if constexpr (__width == 128) // IEEE binary128\n+\t    return _Binary128;\n+\t}\n+\n+      // So we don't need to include <stdint.h> and pollute the namespace.\n+      using int64_t = __INT64_TYPE__;\n+      using int32_t = __INT32_TYPE__;\n+      using int16_t = __INT16_TYPE__;\n+      using uint64_t = __UINT64_TYPE__;\n+      using uint16_t = __UINT16_TYPE__;\n+\n+      // Used to unpack floating-point types that do not fit into an integer.\n+      template<typename _Tp>\n+\tstruct _Int\n+\t{\n+#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__\n+\t  uint64_t _M_lo;\n+\t  _Tp _M_hi;\n+#else\n+\t  _Tp _M_hi;\n+\t  uint64_t _M_lo;\n+#endif\n+\n+\t  constexpr explicit\n+\t  _Int(_Tp __hi, uint64_t __lo) noexcept : _M_hi(__hi)\n+\t  { _M_lo = __lo; }\n+\n+\t  constexpr explicit\n+\t  _Int(uint64_t __lo) noexcept : _M_hi(0)\n+\t  { _M_lo = __lo; }\n+\n+\t  constexpr bool operator==(const _Int&) const = default;\n+\n+#if defined __hppa__ || (defined __mips__ && !defined __mips_nan2008)\n+\t  consteval _Int\n+\t  operator<<(int __n) const noexcept\n+\t  {\n+\t    // XXX this assumes n >= 64, which is true for the use below.\n+\t    return _Int(static_cast<_Tp>(_M_lo << (__n - 64)), 0);\n+\t  }\n+#endif\n+\n+\t  constexpr _Int&\n+\t  operator^=(const _Int& __rhs) noexcept\n+\t  {\n+\t    _M_hi ^= __rhs._M_hi;\n+\t    _M_lo ^= __rhs._M_lo;\n+\t    return *this;\n+\t  }\n+\n+\t  constexpr strong_ordering\n+\t  operator<=>(const _Int& __rhs) const noexcept\n+\t  {\n+\t    strong_ordering __cmp = _M_hi <=> __rhs._M_hi;\n+\t    if (__cmp != strong_ordering::equal)\n+\t      return __cmp;\n+\t    return _M_lo <=> __rhs._M_lo;\n+\t  }\n+\t};\n+\n+      template<typename _Tp>\n+\tstatic constexpr _Tp\n+\t_S_compl(_Tp __t) noexcept\n+\t{\n+\t  constexpr int __width = sizeof(_Tp) * __CHAR_BIT__;\n+\t  // Sign extend to get all ones or all zeros.\n+\t  make_unsigned_t<_Tp> __sign = __t >> (__width - 1);\n+\t  // If the sign bit was set, this flips all bits below it.\n+\t  // This converts ones' complement to two's complement.\n+\t  return __t ^ (__sign >> 1);\n+\t}\n+\n+      // As above but works on both parts of _Int<T>.\n+      template<typename _Tp>\n+\tstatic constexpr _Int<_Tp>\n+\t_S_compl(_Int<_Tp> __t) noexcept\n+\t{\n+\t  constexpr int __width = sizeof(_Tp) * __CHAR_BIT__;\n+\t  make_unsigned_t<_Tp> __sign = __t._M_hi >> (__width - 1);\n+\t  __t._M_hi ^= (__sign >> 1 );\n+\t  uint64_t __sign64 = (_Tp)__sign;\n+\t  __t._M_lo ^= __sign64;\n+\t  return __t;\n+\t}\n+\n+      // Bit-cast a floating-point value to an unsigned integer.\n+      template<typename _Tp>\n+\tconstexpr static auto\n+\t_S_fp_bits(_Tp __val) noexcept\n+\t{\n+\t  if constexpr (sizeof(_Tp) == sizeof(int64_t))\n+\t    return __builtin_bit_cast(int64_t, __val);\n+\t  else if constexpr (sizeof(_Tp) == sizeof(int32_t))\n+\t    return __builtin_bit_cast(int32_t, __val);\n+\t  else if constexpr (sizeof(_Tp) == sizeof(int16_t))\n+\t    return __builtin_bit_cast(int16_t, __val);\n+\t  else\n+\t    {\n+\t      using enum _Fp_fmt;\n+\t      constexpr auto __fmt = _S_fp_fmt<_Tp>();\n+\t      if constexpr (__fmt == _X86_80bit || __fmt == _M68k_80bit)\n+\t\t{\n+\t\t  if constexpr (sizeof(_Tp) == 3 * sizeof(int32_t))\n+\t\t    {\n+\t\t      auto __ival = __builtin_bit_cast(_Int<int32_t>, __val);\n+\t\t      return _Int<int16_t>(__ival._M_hi, __ival._M_lo);\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      auto __ival = __builtin_bit_cast(_Int<int64_t>, __val);\n+\t\t      return _Int<int16_t>(__ival._M_hi, __ival._M_lo);\n+\t\t    }\n+\t\t}\n+\t      else if constexpr (sizeof(_Tp) == 2 * sizeof(int64_t))\n+\t\t{\n+#if __SIZEOF_INT128__\n+\t\t  return __builtin_bit_cast(__int128, __val);\n+#else\n+\t\t  return __builtin_bit_cast(_Int<int64_t>, __val);\n+#endif\n+\t\t}\n+\t      else\n+\t\tstatic_assert(sizeof(_Tp) == sizeof(int64_t),\n+\t\t\t      \"unsupported floating-point type\");\n+\t    }\n+\t}\n+\n+      template<typename _Tp>\n+\tstatic constexpr strong_ordering\n+\t_S_fp_cmp(_Tp __x, _Tp __y) noexcept\n+\t{\n+\t  auto __ix = _S_fp_bits(__x);\n+\t  auto __iy = _S_fp_bits(__y);\n+\n+\t  if (__ix == __iy)\n+\t    return strong_ordering::equal; // All bits are equal, we're done.\n+\n+\t  using enum _Fp_fmt;\n+\t  using _Int = decltype(__ix);\n+\n+\t  constexpr auto __fmt = _S_fp_fmt<_Tp>();\n+\n+\t  if constexpr (__fmt == _Dbldbl) // double-double\n+\t    {\n+\t      // Unpack the double-double into two parts.\n+\t      // We never inspect the low double as a double, cast to integer.\n+\t      struct _Unpacked { double _M_hi; int64_t _M_lo; };\n+\t      auto __x2 = __builtin_bit_cast(_Unpacked, __x);\n+\t      auto __y2 = __builtin_bit_cast(_Unpacked, __y);\n+\n+\t      // Compare the high doubles first and use result if unequal.\n+\t      auto __cmp = _S_fp_cmp(__x2._M_hi, __y2._M_hi);\n+\t      if (__cmp != strong_ordering::equal)\n+\t\treturn __cmp;\n+\n+\t      // For NaN the low double is unused, so if the high doubles\n+\t      // are the same NaN, we don't need to compare the low doubles.\n+\t      if (__builtin_isnan(__x2._M_hi))\n+\t\treturn strong_ordering::equal;\n+\t      // Similarly, if the low doubles are +zero or -zero (which is\n+\t      // true for all infinities and some other values), we're done.\n+\t      if (((__x2._M_lo | __y2._M_lo) & 0x7fffffffffffffffULL) == 0)\n+\t\treturn strong_ordering::equal;\n+\n+\t      // Otherwise, compare the low parts.\n+\t      return _S_compl(__x2._M_lo) <=> _S_compl(__y2._M_lo);\n+\t    }\n+\t  else\n+\t    {\n+\t      if constexpr (__fmt == _M68k_80bit)\n+\t\t{\n+\t\t  // For m68k the MSB of the significand is ignored for the\n+\t\t  // greatest exponent, so either 0 or 1 is valid there.\n+\t\t  // Set it before comparing, so that we never have 0 there.\n+\t\t  constexpr uint16_t __maxexp = 0x7fff;\n+\t\t  if ((__ix._M_hi & __maxexp) == __maxexp)\n+\t\t    __ix._M_lo |= 1ull << 63;\n+\t\t  if ((__iy._M_hi & __maxexp) == __maxexp)\n+\t\t    __iy._M_lo |= 1ull << 63;\n+\t\t}\n+\t      else\n+\t\t{\n+#if defined __hppa__ || (defined __mips__ && !defined __mips_nan2008)\n+\t\t  // IEEE 754-1985 allowed the meaning of the quiet/signaling\n+\t\t  // bit to be reversed. Flip that to give desired ordering.\n+\t\t  if (__builtin_isnan(__x) && __builtin_isnan(__y))\n+\t\t    {\n+\t\t      constexpr int __nantype = __fmt == _Binary32  ?  22\n+\t\t\t\t\t      : __fmt == _Binary64  ?  51\n+\t\t\t\t\t      : __fmt == _Binary128 ? 111\n+\t\t\t\t\t      : -1;\n+\t\t      constexpr _Int __bit = _Int(1) << __nantype;\n+\t\t      __ix ^= __bit;\n+\t\t      __iy ^= __bit;\n+\t\t    }\n+#endif\n+\t\t}\n+\t      return _S_compl(__ix) <=> _S_compl(__iy);\n+\t    }\n+\t}\n+\n     public:\n       template<typename _Tp, __decayed_same_as<_Tp> _Up>\n \trequires __strongly_ordered<_Tp, _Up>\n \tconstexpr strong_ordering\n \toperator() [[nodiscard]] (_Tp&& __e, _Up&& __f) const\n \tnoexcept(_S_noexcept<_Tp, _Up>())\n \t{\n-\t  /* FIXME:\n \t  if constexpr (floating_point<decay_t<_Tp>>)\n-\t    return __cmp_cust::__fp_strong_order(__e, __f);\n-\t  else */ if constexpr (__adl_strong<_Tp, _Up>)\n+\t    return _S_fp_cmp(__e, __f);\n+\t  else if constexpr (__adl_strong<_Tp, _Up>)\n \t    return strong_ordering(strong_order(static_cast<_Tp&&>(__e),\n \t\t\t\t\t\tstatic_cast<_Up&&>(__f)));\n \t  else if constexpr (__cmp3way<strong_ordering, _Tp, _Up>)"}, {"sha": "e28fcac6e1132edf31457feaee813b8e3c8fcc43", "filename": "libstdc++-v3/testsuite/18_support/comparisons/algorithms/strong_order_floats.cc", "status": "added", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9805965e3551b66b5bd751d6076791d00cdeb137/libstdc%2B%2B-v3%2Ftestsuite%2F18_support%2Fcomparisons%2Falgorithms%2Fstrong_order_floats.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9805965e3551b66b5bd751d6076791d00cdeb137/libstdc%2B%2B-v3%2Ftestsuite%2F18_support%2Fcomparisons%2Falgorithms%2Fstrong_order_floats.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F18_support%2Fcomparisons%2Falgorithms%2Fstrong_order_floats.cc?ref=9805965e3551b66b5bd751d6076791d00cdeb137", "patch": "@@ -0,0 +1,102 @@\n+// { dg-options \"-std=gnu++20\" }\n+// { dg-do compile { target c++20 } }\n+\n+#include <compare>\n+#include <limits>\n+#include <testsuite_hooks.h>\n+\n+// Test floating-point ordering.\n+\n+template<typename T> constexpr T epsilon = std::numeric_limits<T>::epsilon();\n+\n+// PR middle-end/19779 IBM 128bit long double format is not constant folded.\n+// 1.0L + numeric_limits<long double>::epsilon() is not a constant expression\n+// so just use numeric_limits<double>::epsilon() instead.\n+#if defined __LONG_DOUBLE_IBM128__\n+using D = long double;\n+#elif defined __LONG_DOUBLE_IEEE128__ && defined __SIZEOF_IBM128__\n+using D = __ibm128;\n+#else\n+using D = double;\n+#endif\n+\n+template<> constexpr D epsilon<D> = std::numeric_limits<double>::epsilon();\n+\n+template<typename Float>\n+constexpr bool\n+test_fp()\n+{\n+  const auto& less = std::strong_ordering::less;\n+  const auto& greater = std::strong_ordering::greater;\n+\n+  static_assert( std::numeric_limits<Float>::is_specialized);\n+  Float min = std::numeric_limits<Float>::lowest();\n+  Float max = std::numeric_limits<Float>::max();\n+  Float qnan = std::numeric_limits<Float>::quiet_NaN();\n+  Float snan = std::numeric_limits<Float>::signaling_NaN();\n+  Float inf = std::numeric_limits<Float>::infinity();\n+  Float denorm = std::numeric_limits<Float>::denorm_min();\n+  Float smallest = std::numeric_limits<Float>::min();\n+\n+  // -qnan < -snan < -inf < -num < -zero < +zero < +num < +inf < +snan < +qnan\n+\n+  struct Test\n+  {\n+    Float lhs;\n+    Float rhs;\n+    std::strong_ordering expected;\n+\n+    constexpr explicit operator bool() const noexcept\n+    { return std::strong_order(lhs, rhs) == expected; }\n+\n+    constexpr Test rev() const noexcept\n+    { return { rhs, lhs, 0 <=> expected }; }\n+\n+    constexpr Test neg() const noexcept\n+    { return { -lhs, -rhs, 0 <=> expected }; }\n+  };\n+\n+  auto test = [&](Test t, bool selftest = true) {\n+    if (selftest)\n+    {\n+      // Check that each operand compares equal to itself.\n+      if (std::strong_order(t.lhs, t.lhs) != std::strong_ordering::equal)\n+\treturn false;\n+      if (std::strong_order(t.rhs, t.rhs) != std::strong_ordering::equal)\n+\treturn false;\n+    }\n+    return t && t.rev() && t.neg() && t.rev().neg();\n+  };\n+\n+  VERIFY(test({   1.0,  2.0, less    }));\n+  VERIFY(test({   1.0, -2.0, greater }));\n+  VERIFY(test({   3e6,  2e9, less    }));\n+  VERIFY(test({   8e8, -9e9, greater }));\n+  VERIFY(test({   0.0, -0.0, greater }));\n+  VERIFY(test({  -inf,  min, less    }));\n+  VERIFY(test({ -snan,  min, less    }));\n+  VERIFY(test({ -qnan,  min, less    }));\n+\n+  const Float vals[] = {\n+    Float(0.0), denorm, smallest, Float(0.004), Float(0.2), Float(1.0),\n+    Float(1) + epsilon<Float>, Float(1.1), Float(1e3), Float(123e4), Float(1e9),\n+    max, inf, snan, qnan\n+  };\n+\n+  for (auto& f : vals)\n+  {\n+    VERIFY(test({ f, -f, greater }));\n+    VERIFY(test({ f, min, greater }, false));\n+    for (auto& g : vals)\n+    {\n+      VERIFY(test({ f, g, &f <=> &g }, false));\n+      VERIFY(test({ f, -g, greater }, false));\n+    }\n+  }\n+\n+  return true;\n+}\n+\n+static_assert( test_fp<float>() );\n+static_assert( test_fp<double>() );\n+static_assert( test_fp<long double>() );"}]}