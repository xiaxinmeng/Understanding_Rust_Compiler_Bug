{"sha": "917948d364025c5cc418cd6486dc75b43fa12015", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTE3OTQ4ZDM2NDAyNWM1Y2M0MThjZDY0ODZkYzc1YjQzZmExMjAxNQ==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "ook@ucw.cz", "date": "2007-09-07T02:40:14Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2007-09-07T02:40:14Z"}, "message": "cgraphbuild.c (rebuild_cgraph_edges): Export.\n\n\t* cgraphbuild.c (rebuild_cgraph_edges): Export.\n\t* cgraph.h (rebuild_cgraph_edges): Declare.\n\t* tree-pass.h (pass_expand_omp_ssa): New.\n\t* omp-low.c (find_omp_clause): Export.\n\t(copy_var_decl): Split from omp_copy_decl_2.\n\t(build_omp_barrier): Return the call to emit instead of emitting\n\tit directly.\n\t(lower_rec_input_clauses, expand_omp_single): Gimplify the result of\n\tbuild_omp_barrier.\n\t(extract_omp_for_data, expand_parallel_call, expand_omp_parallel,\n\texpand_omp_for_generic, expand_omp_for_static_nochunk,\n\texpand_omp_for_static_chunk, expand_omp_for, expand_omp_sections):\n\tAdapted to work on SSA form.\n\t(execute_expand_omp): Do not invalidate dominance information.\n\t(gate_expand_omp): Do not run with -fopenmp-ssa flag.\n\t(gate_expand_omp_ssa, pass_expand_omp_ssa): New.\n\t* gimplify.c (gimplify_omp_for): Ensure that the control variable is\n\ta gimple_reg.\n\t(force_gimple_operand): Allow gimplifying code expressions without\n\tvalue.\n\t* tree-predcom.c (mark_virtual_ops_for_renaming): Handle phi nodes.\n\t* common.opt (fopenmp-ssa): New.\n\t* tree-flow.h (find_omp_clause, copy_var_decl): Declare.\n\t* Makefile.in (tree-cfg.o): Add TREE_INLINE_H dependency.\n\t* tree-cfg.c: Include tree-inline.h.\n\t(struct move_stmt_d): Replace vars_to_remove by vars_map field.\n\t(replace_by_duplicate_decl, replace_ssa_name,\n\tmark_virtual_ops_in_region): New functions.\n\t(move_stmt_r, move_block_to_fn, move_sese_region_to_fn): Adapted\n\tto work on SSA form.\n\t* passes.c (init_optimization_passes): Add pass_expand_omp_ssa pass.\n\t* tree-ssa-operands.c (get_expr_operands): Handle operands of OMP\n\tconstructs.\n\nFrom-SVN: r128223", "tree": {"sha": "7c5c590c4bfd0b7c4f0dda268de7e85ce217d91f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7c5c590c4bfd0b7c4f0dda268de7e85ce217d91f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/917948d364025c5cc418cd6486dc75b43fa12015", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/917948d364025c5cc418cd6486dc75b43fa12015", "html_url": "https://github.com/Rust-GCC/gccrs/commit/917948d364025c5cc418cd6486dc75b43fa12015", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/917948d364025c5cc418cd6486dc75b43fa12015/comments", "author": {"login": "rakdver", "id": 20416833, "node_id": "MDQ6VXNlcjIwNDE2ODMz", "avatar_url": "https://avatars.githubusercontent.com/u/20416833?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rakdver", "html_url": "https://github.com/rakdver", "followers_url": "https://api.github.com/users/rakdver/followers", "following_url": "https://api.github.com/users/rakdver/following{/other_user}", "gists_url": "https://api.github.com/users/rakdver/gists{/gist_id}", "starred_url": "https://api.github.com/users/rakdver/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rakdver/subscriptions", "organizations_url": "https://api.github.com/users/rakdver/orgs", "repos_url": "https://api.github.com/users/rakdver/repos", "events_url": "https://api.github.com/users/rakdver/events{/privacy}", "received_events_url": "https://api.github.com/users/rakdver/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e054e6fb646e1fe418545b93b2673c8fa5cb8c95", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e054e6fb646e1fe418545b93b2673c8fa5cb8c95", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e054e6fb646e1fe418545b93b2673c8fa5cb8c95"}], "stats": {"total": 1222, "additions": 854, "deletions": 368}, "files": [{"sha": "76a81d88ab3f41226e190fec695dabf09c9f3f21", "filename": "gcc/ChangeLog", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/917948d364025c5cc418cd6486dc75b43fa12015/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/917948d364025c5cc418cd6486dc75b43fa12015/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=917948d364025c5cc418cd6486dc75b43fa12015", "patch": "@@ -1,3 +1,39 @@\n+2007-09-06  Zdenek Dvorak  <ook@ucw.cz>\n+\n+\t* cgraphbuild.c (rebuild_cgraph_edges): Export.\n+\t* cgraph.h (rebuild_cgraph_edges): Declare.\n+\t* tree-pass.h (pass_expand_omp_ssa): New.\n+\t* omp-low.c (find_omp_clause): Export.\n+\t(copy_var_decl): Split from omp_copy_decl_2.\n+\t(build_omp_barrier): Return the call to emit instead of emitting\n+\tit directly.\n+\t(lower_rec_input_clauses, expand_omp_single): Gimplify the result of\n+\tbuild_omp_barrier.\n+\t(extract_omp_for_data, expand_parallel_call, expand_omp_parallel,\n+\texpand_omp_for_generic, expand_omp_for_static_nochunk,\n+\texpand_omp_for_static_chunk, expand_omp_for, expand_omp_sections):\n+\tAdapted to work on SSA form.\n+\t(execute_expand_omp): Do not invalidate dominance information.\n+\t(gate_expand_omp): Do not run with -fopenmp-ssa flag.\n+\t(gate_expand_omp_ssa, pass_expand_omp_ssa): New.\n+\t* gimplify.c (gimplify_omp_for): Ensure that the control variable is\n+\ta gimple_reg.\n+\t(force_gimple_operand): Allow gimplifying code expressions without\n+\tvalue.\n+\t* tree-predcom.c (mark_virtual_ops_for_renaming): Handle phi nodes.\n+\t* common.opt (fopenmp-ssa): New.\n+\t* tree-flow.h (find_omp_clause, copy_var_decl): Declare.\n+\t* Makefile.in (tree-cfg.o): Add TREE_INLINE_H dependency.\n+\t* tree-cfg.c: Include tree-inline.h.\n+\t(struct move_stmt_d): Replace vars_to_remove by vars_map field.\n+\t(replace_by_duplicate_decl, replace_ssa_name,\n+\tmark_virtual_ops_in_region): New functions.\n+\t(move_stmt_r, move_block_to_fn, move_sese_region_to_fn): Adapted\n+\tto work on SSA form.\n+\t* passes.c (init_optimization_passes): Add pass_expand_omp_ssa pass.\n+\t* tree-ssa-operands.c (get_expr_operands): Handle operands of OMP\n+\tconstructs.\n+\n 2007-09-06  Laurynas Biveinis  <laurynas.biveinis@gmail.com>\n \n \t* tree-loop-linear.c: Include obstack.h."}, {"sha": "fee5d25cab796854f5cd0d6a2df751735e100ac4", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/917948d364025c5cc418cd6486dc75b43fa12015/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/917948d364025c5cc418cd6486dc75b43fa12015/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=917948d364025c5cc418cd6486dc75b43fa12015", "patch": "@@ -2079,7 +2079,7 @@ tree-cfg.o : tree-cfg.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n    $(DIAGNOSTIC_H) $(FUNCTION_H) $(TIMEVAR_H) $(TM_H) coretypes.h \\\n    $(TREE_DUMP_H) except.h langhooks.h $(CFGLOOP_H) tree-pass.h \\\n    $(CFGLAYOUT_H) $(BASIC_BLOCK_H) hard-reg-set.h toplev.h \\\n-   tree-ssa-propagate.h\n+   tree-ssa-propagate.h $(TREE_INLINE_H)\n tree-cfgcleanup.o : tree-cfgcleanup.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n    $(RTL_H) $(TREE_H) $(TM_P_H) $(EXPR_H) $(GGC_H) $(FLAGS_H) output.h \\\n    $(DIAGNOSTIC_H) toplev.h $(FUNCTION_H) $(TIMEVAR_H) $(TM_H) coretypes.h \\"}, {"sha": "2d6d7c94c9a926d24b5644150b2cafc9980863cd", "filename": "gcc/cgraph.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/917948d364025c5cc418cd6486dc75b43fa12015/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/917948d364025c5cc418cd6486dc75b43fa12015/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=917948d364025c5cc418cd6486dc75b43fa12015", "patch": "@@ -344,6 +344,9 @@ struct cgraph_node *save_inline_function_body (struct cgraph_node *);\n void record_references_in_initializer (tree);\n bool cgraph_process_new_functions (void);\n \n+/* In cgraphbuild.c  */\n+unsigned int rebuild_cgraph_edges (void);\n+\n /* In ipa.c  */\n bool cgraph_remove_unreachable_nodes (bool, FILE *);\n int cgraph_postorder (struct cgraph_node **);"}, {"sha": "1e3e5da1910813689f80c10393f6de82064e906d", "filename": "gcc/cgraphbuild.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/917948d364025c5cc418cd6486dc75b43fa12015/gcc%2Fcgraphbuild.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/917948d364025c5cc418cd6486dc75b43fa12015/gcc%2Fcgraphbuild.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphbuild.c?ref=917948d364025c5cc418cd6486dc75b43fa12015", "patch": "@@ -202,7 +202,7 @@ record_references_in_initializer (tree decl)\n /* Rebuild cgraph edges for current function node.  This needs to be run after\n    passes that don't update the cgraph.  */\n \n-static unsigned int\n+unsigned int\n rebuild_cgraph_edges (void)\n {\n   basic_block bb;"}, {"sha": "c53a93e0483b778d34ff1eee3f72aa801ab0ba5f", "filename": "gcc/common.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/917948d364025c5cc418cd6486dc75b43fa12015/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/917948d364025c5cc418cd6486dc75b43fa12015/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=917948d364025c5cc418cd6486dc75b43fa12015", "patch": "@@ -709,6 +709,10 @@ fomit-frame-pointer\n Common Report Var(flag_omit_frame_pointer) Optimization\n When possible do not generate stack frames\n \n+fopenmp-ssa\n+Common Report Var(flag_openmp_ssa)\n+Expand OpenMP operations on SSA form\n+\n foptimize-register-move\n Common Report Var(flag_regmove) Optimization\n Do the full register move optimization pass"}, {"sha": "d10c8486df87099e0d8e77af835ce87d32fafff6", "filename": "gcc/gimplify.c", "status": "modified", "additions": 46, "deletions": 10, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/917948d364025c5cc418cd6486dc75b43fa12015/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/917948d364025c5cc418cd6486dc75b43fa12015/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=917948d364025c5cc418cd6486dc75b43fa12015", "patch": "@@ -5114,8 +5114,9 @@ gimplify_omp_parallel (tree *expr_p, tree *pre_p)\n static enum gimplify_status\n gimplify_omp_for (tree *expr_p, tree *pre_p)\n {\n-  tree for_stmt, decl, t;\n+  tree for_stmt, decl, var, t;\n   enum gimplify_status ret = GS_OK;\n+  tree body, init_decl = NULL_TREE;\n \n   for_stmt = *expr_p;\n \n@@ -5134,6 +5135,20 @@ gimplify_omp_for (tree *expr_p, tree *pre_p)\n   else\n     omp_add_variable (gimplify_omp_ctxp, decl, GOVD_PRIVATE | GOVD_SEEN);\n \n+  /* If DECL is not a gimple register, create a temporary variable to act as an\n+     iteration counter.  This is valid, since DECL cannot be modified in the\n+     body of the loop.  */\n+  if (!is_gimple_reg (decl))\n+    {\n+      var = create_tmp_var (TREE_TYPE (decl), get_name (decl));\n+      GENERIC_TREE_OPERAND (t, 0) = var;\n+\n+      init_decl = build_gimple_modify_stmt (decl, var);\n+      omp_add_variable (gimplify_omp_ctxp, var, GOVD_PRIVATE | GOVD_SEEN);\n+    }\n+  else\n+    var = decl;\n+\n   ret |= gimplify_expr (&GENERIC_TREE_OPERAND (t, 1),\n \t\t\t&OMP_FOR_PRE_BODY (for_stmt),\n \t\t\tNULL, is_gimple_val, fb_rvalue);\n@@ -5143,6 +5158,7 @@ gimplify_omp_for (tree *expr_p, tree *pre_p)\n   t = OMP_FOR_COND (for_stmt);\n   gcc_assert (COMPARISON_CLASS_P (t));\n   gcc_assert (GENERIC_TREE_OPERAND (t, 0) == decl);\n+  TREE_OPERAND (t, 0) = var;\n \n   ret |= gimplify_expr (&GENERIC_TREE_OPERAND (t, 1),\n \t\t\t&OMP_FOR_PRE_BODY (for_stmt),\n@@ -5155,33 +5171,38 @@ gimplify_omp_for (tree *expr_p, tree *pre_p)\n     case PREINCREMENT_EXPR:\n     case POSTINCREMENT_EXPR:\n       t = build_int_cst (TREE_TYPE (decl), 1);\n-      t = build2 (PLUS_EXPR, TREE_TYPE (decl), decl, t);\n-      t = build_gimple_modify_stmt (decl, t);\n+      t = build2 (PLUS_EXPR, TREE_TYPE (decl), var, t);\n+      t = build_gimple_modify_stmt (var, t);\n       OMP_FOR_INCR (for_stmt) = t;\n       break;\n \n     case PREDECREMENT_EXPR:\n     case POSTDECREMENT_EXPR:\n       t = build_int_cst (TREE_TYPE (decl), -1);\n-      t = build2 (PLUS_EXPR, TREE_TYPE (decl), decl, t);\n-      t = build_gimple_modify_stmt (decl, t);\n+      t = build2 (PLUS_EXPR, TREE_TYPE (decl), var, t);\n+      t = build_gimple_modify_stmt (var, t);\n       OMP_FOR_INCR (for_stmt) = t;\n       break;\n       \n     case GIMPLE_MODIFY_STMT:\n       gcc_assert (GIMPLE_STMT_OPERAND (t, 0) == decl);\n+      GIMPLE_STMT_OPERAND (t, 0) = var;\n+\n       t = GIMPLE_STMT_OPERAND (t, 1);\n       switch (TREE_CODE (t))\n \t{\n \tcase PLUS_EXPR:\n \t  if (TREE_OPERAND (t, 1) == decl)\n \t    {\n \t      TREE_OPERAND (t, 1) = TREE_OPERAND (t, 0);\n-\t      TREE_OPERAND (t, 0) = decl;\n+\t      TREE_OPERAND (t, 0) = var;\n \t      break;\n \t    }\n+\n+\t  /* Fallthru.  */\n \tcase MINUS_EXPR:\n \t  gcc_assert (TREE_OPERAND (t, 0) == decl);\n+\t  TREE_OPERAND (t, 0) = var;\n \t  break;\n \tdefault:\n \t  gcc_unreachable ();\n@@ -5195,7 +5216,13 @@ gimplify_omp_for (tree *expr_p, tree *pre_p)\n       gcc_unreachable ();\n     }\n \n-  gimplify_to_stmt_list (&OMP_FOR_BODY (for_stmt));\n+  body = OMP_FOR_BODY (for_stmt);\n+  gimplify_to_stmt_list (&body);\n+  t = alloc_stmt_list ();\n+  if (init_decl)\n+    append_to_statement_list (init_decl, &t);\n+  append_to_statement_list (body, &t);\n+  OMP_FOR_BODY (for_stmt) = t;\n   gimplify_adjust_omp_clauses (&OMP_FOR_CLAUSES (for_stmt));\n \n   return ret == GS_ALL_DONE ? GS_ALL_DONE : GS_ERROR;\n@@ -6591,9 +6618,18 @@ force_gimple_operand (tree expr, tree *stmts, bool simple, tree var)\n   if (var)\n     expr = build_gimple_modify_stmt (var, expr);\n \n-  ret = gimplify_expr (&expr, stmts, NULL,\n-\t\t       gimple_test_f, fb_rvalue);\n-  gcc_assert (ret != GS_ERROR);\n+  if (TREE_CODE (expr) != GIMPLE_MODIFY_STMT\n+      && TREE_TYPE (expr) == void_type_node)\n+    {\n+      gimplify_and_add (expr, stmts);\n+      expr = NULL_TREE;\n+    }\n+  else\n+    {\n+      ret = gimplify_expr (&expr, stmts, NULL,\n+\t\t\t   gimple_test_f, fb_rvalue);\n+      gcc_assert (ret != GS_ERROR);\n+    }\n \n   if (gimple_referenced_vars (cfun))\n     {"}, {"sha": "57f36509c67db749ec475043851a9fd19e330e5e", "filename": "gcc/omp-low.c", "status": "modified", "additions": 499, "deletions": 288, "changes": 787, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/917948d364025c5cc418cd6486dc75b43fa12015/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/917948d364025c5cc418cd6486dc75b43fa12015/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=917948d364025c5cc418cd6486dc75b43fa12015", "patch": "@@ -117,7 +117,7 @@ static tree maybe_lookup_decl_in_outer_ctx (tree, omp_context *);\n \n /* Find an OpenMP clause of type KIND within CLAUSES.  */\n \n-static tree\n+tree\n find_omp_clause (tree clauses, enum tree_code kind)\n {\n   for (; clauses ; clauses = OMP_CLAUSE_CHAIN (clauses))\n@@ -151,21 +151,22 @@ is_combined_parallel (struct omp_region *region)\n static void\n extract_omp_for_data (tree for_stmt, struct omp_for_data *fd)\n {\n-  tree t;\n+  tree t, var;\n \n   fd->for_stmt = for_stmt;\n   fd->pre = NULL;\n \n   t = OMP_FOR_INIT (for_stmt);\n   gcc_assert (TREE_CODE (t) == GIMPLE_MODIFY_STMT);\n   fd->v = GIMPLE_STMT_OPERAND (t, 0);\n-  gcc_assert (DECL_P (fd->v));\n+  gcc_assert (SSA_VAR_P (fd->v));\n   gcc_assert (TREE_CODE (TREE_TYPE (fd->v)) == INTEGER_TYPE);\n+  var = TREE_CODE (fd->v) == SSA_NAME ? SSA_NAME_VAR (fd->v) : fd->v;\n   fd->n1 = GIMPLE_STMT_OPERAND (t, 1);\n \n   t = OMP_FOR_COND (for_stmt);\n   fd->cond_code = TREE_CODE (t);\n-  gcc_assert (TREE_OPERAND (t, 0) == fd->v);\n+  gcc_assert (TREE_OPERAND (t, 0) == var);\n   fd->n2 = TREE_OPERAND (t, 1);\n   switch (fd->cond_code)\n     {\n@@ -188,9 +189,9 @@ extract_omp_for_data (tree for_stmt, struct omp_for_data *fd)\n \n   t = OMP_FOR_INCR (fd->for_stmt);\n   gcc_assert (TREE_CODE (t) == GIMPLE_MODIFY_STMT);\n-  gcc_assert (GIMPLE_STMT_OPERAND (t, 0) == fd->v);\n+  gcc_assert (GIMPLE_STMT_OPERAND (t, 0) == var);\n   t = GIMPLE_STMT_OPERAND (t, 1);\n-  gcc_assert (TREE_OPERAND (t, 0) == fd->v);\n+  gcc_assert (TREE_OPERAND (t, 0) == var);\n   switch (TREE_CODE (t))\n     {\n     case PLUS_EXPR:\n@@ -513,22 +514,34 @@ use_pointer_for_field (const_tree decl, bool shared_p)\n   return false;\n }\n \n-/* Construct a new automatic decl similar to VAR.  */\n+/* Create a new VAR_DECL and copy information from VAR to it.  */\n \n-static tree\n-omp_copy_decl_2 (tree var, tree name, tree type, omp_context *ctx)\n+tree\n+copy_var_decl (tree var, tree name, tree type)\n {\n   tree copy = build_decl (VAR_DECL, name, type);\n \n   TREE_ADDRESSABLE (copy) = TREE_ADDRESSABLE (var);\n+  TREE_THIS_VOLATILE (copy) = TREE_THIS_VOLATILE (var);\n   DECL_GIMPLE_REG_P (copy) = DECL_GIMPLE_REG_P (var);\n   DECL_NO_TBAA_P (copy) = DECL_NO_TBAA_P (var);\n   DECL_ARTIFICIAL (copy) = DECL_ARTIFICIAL (var);\n   DECL_IGNORED_P (copy) = DECL_IGNORED_P (var);\n+  DECL_CONTEXT (copy) = DECL_CONTEXT (var);\n   TREE_USED (copy) = 1;\n-  DECL_CONTEXT (copy) = current_function_decl;\n   DECL_SEEN_IN_BIND_EXPR_P (copy) = 1;\n \n+  return copy;\n+}\n+\n+/* Construct a new automatic decl similar to VAR.  */\n+\n+static tree\n+omp_copy_decl_2 (tree var, tree name, tree type, omp_context *ctx)\n+{\n+  tree copy = copy_var_decl (var, name, type);\n+\n+  DECL_CONTEXT (copy) = current_function_decl;\n   TREE_CHAIN (copy) = ctx->block_vars;\n   ctx->block_vars = copy;\n \n@@ -1432,11 +1445,10 @@ scan_omp (tree *stmt_p, omp_context *ctx)\n \n /* Build a call to GOMP_barrier.  */\n \n-static void\n-build_omp_barrier (tree *stmt_list)\n+static tree\n+build_omp_barrier (void)\n {\n-  tree t = build_call_expr (built_in_decls[BUILT_IN_GOMP_BARRIER], 0);\n-  gimplify_and_add (t, stmt_list);\n+  return build_call_expr (built_in_decls[BUILT_IN_GOMP_BARRIER], 0);\n }\n \n /* If a context was created for STMT when it was scanned, return it.  */\n@@ -1829,7 +1841,7 @@ lower_rec_input_clauses (tree clauses, tree *ilist, tree *dlist,\n      lastprivate clauses we need to ensure the lastprivate copying\n      happens after firstprivate copying in all threads.  */\n   if (copyin_by_ref || lastprivate_firstprivate)\n-    build_omp_barrier (ilist);\n+    gimplify_and_add (build_omp_barrier (), ilist);\n }\n \n \n@@ -2153,12 +2165,11 @@ static void\n expand_parallel_call (struct omp_region *region, basic_block bb,\n \t\t      tree entry_stmt, tree ws_args)\n {\n-  tree t, t1, t2, val, cond, c, list, clauses;\n+  tree t, t1, t2, val, cond, c, clauses;\n   block_stmt_iterator si;\n   int start_ix;\n \n   clauses = OMP_PARALLEL_CLAUSES (entry_stmt);\n-  push_gimplify_context ();\n \n   /* Determine what flavor of GOMP_parallel_start we will be\n      emitting.  */\n@@ -2204,22 +2215,37 @@ expand_parallel_call (struct omp_region *region, basic_block bb,\n       cond = gimple_boolify (cond);\n \n       if (integer_zerop (val))\n-\tval = build2 (EQ_EXPR, unsigned_type_node, cond,\n-\t\t      build_int_cst (TREE_TYPE (cond), 0));\n+\tval = fold_build2 (EQ_EXPR, unsigned_type_node, cond,\n+\t\t\t   build_int_cst (TREE_TYPE (cond), 0));\n       else\n \t{\n \t  basic_block cond_bb, then_bb, else_bb;\n-\t  edge e;\n-\t  tree t, tmp;\n+\t  edge e, e_then, e_else;\n+\t  tree t, tmp_then, tmp_else, tmp_join, tmp_var;\n+\n+\t  tmp_var = create_tmp_var (TREE_TYPE (val), NULL);\n+\t  if (gimple_in_ssa_p (cfun))\n+\t    {\n+\t      tmp_then = make_ssa_name (tmp_var, NULL_TREE);\n+\t      tmp_else = make_ssa_name (tmp_var, NULL_TREE);\n+\t      tmp_join = make_ssa_name (tmp_var, NULL_TREE);\n+\t    }\n+\t  else\n+\t    {\n+\t      tmp_then = tmp_var;\n+\t      tmp_else = tmp_var;\n+\t      tmp_join = tmp_var;\n+\t    }\n \n-\t  tmp = create_tmp_var (TREE_TYPE (val), NULL);\n \t  e = split_block (bb, NULL);\n \t  cond_bb = e->src;\n \t  bb = e->dest;\n \t  remove_edge (e);\n \n \t  then_bb = create_empty_bb (cond_bb);\n \t  else_bb = create_empty_bb (then_bb);\n+\t  set_immediate_dominator (CDI_DOMINATORS, then_bb, cond_bb);\n+\t  set_immediate_dominator (CDI_DOMINATORS, else_bb, cond_bb);\n \n \t  t = build3 (COND_EXPR, void_type_node,\n \t\t      cond, NULL_TREE, NULL_TREE);\n@@ -2228,29 +2254,40 @@ expand_parallel_call (struct omp_region *region, basic_block bb,\n \t  bsi_insert_after (&si, t, BSI_CONTINUE_LINKING);\n \n \t  si = bsi_start (then_bb);\n-\t  t = build_gimple_modify_stmt (tmp, val);\n+\t  t = build_gimple_modify_stmt (tmp_then, val);\n+\t  if (gimple_in_ssa_p (cfun))\n+\t    SSA_NAME_DEF_STMT (tmp_then) = t;\n \t  bsi_insert_after (&si, t, BSI_CONTINUE_LINKING);\n \n \t  si = bsi_start (else_bb);\n-\t  t = build_gimple_modify_stmt (tmp, \n+\t  t = build_gimple_modify_stmt (tmp_else, \n \t\t\t\t\tbuild_int_cst (unsigned_type_node, 1));\n+\t  if (gimple_in_ssa_p (cfun))\n+\t    SSA_NAME_DEF_STMT (tmp_else) = t;\n \t  bsi_insert_after (&si, t, BSI_CONTINUE_LINKING);\n \n \t  make_edge (cond_bb, then_bb, EDGE_TRUE_VALUE);\n \t  make_edge (cond_bb, else_bb, EDGE_FALSE_VALUE);\n-\t  make_edge (then_bb, bb, EDGE_FALLTHRU);\n-\t  make_edge (else_bb, bb, EDGE_FALLTHRU);\n+\t  e_then = make_edge (then_bb, bb, EDGE_FALLTHRU);\n+\t  e_else = make_edge (else_bb, bb, EDGE_FALLTHRU);\n \n-\t  val = tmp;\n+\t  if (gimple_in_ssa_p (cfun))\n+\t    {\n+\t      tree phi = create_phi_node (tmp_join, bb);\n+\t      SSA_NAME_DEF_STMT (tmp_join) = phi;\n+\t      add_phi_arg (phi, tmp_then, e_then);\n+\t      add_phi_arg (phi, tmp_else, e_else);\n+\t    }\n+\n+\t  val = tmp_join;\n \t}\n \n-      list = NULL_TREE;\n-      val = get_formal_tmp_var (val, &list);\n       si = bsi_start (bb);\n-      bsi_insert_after (&si, list, BSI_CONTINUE_LINKING);\n+      val = force_gimple_operand_bsi (&si, val, true, NULL_TREE,\n+\t\t\t\t      false, BSI_CONTINUE_LINKING);\n     }\n \n-  list = NULL_TREE;\n+  si = bsi_last (bb);\n   t = OMP_PARALLEL_DATA_ARG (entry_stmt);\n   if (t == NULL)\n     t1 = null_pointer_node;\n@@ -2268,23 +2305,21 @@ expand_parallel_call (struct omp_region *region, basic_block bb,\n   else\n     t = build_call_expr (built_in_decls[start_ix], 3, t2, t1, val);\n \n-  gimplify_and_add (t, &list);\n+  force_gimple_operand_bsi (&si, t, true, NULL_TREE,\n+\t\t\t    false, BSI_CONTINUE_LINKING);\n \n   t = OMP_PARALLEL_DATA_ARG (entry_stmt);\n   if (t == NULL)\n     t = null_pointer_node;\n   else\n     t = build_fold_addr_expr (t);\n   t = build_call_expr (OMP_PARALLEL_FN (entry_stmt), 1, t);\n-  gimplify_and_add (t, &list);\n+  force_gimple_operand_bsi (&si, t, true, NULL_TREE,\n+\t\t\t    false, BSI_CONTINUE_LINKING);\n \n   t = build_call_expr (built_in_decls[BUILT_IN_GOMP_PARALLEL_END], 0);\n-  gimplify_and_add (t, &list);\n-\n-  si = bsi_last (bb);\n-  bsi_insert_after (&si, list, BSI_CONTINUE_LINKING);\n-\n-  pop_gimplify_context (NULL_TREE);\n+  force_gimple_operand_bsi (&si, t, true, NULL_TREE,\n+\t\t\t    false, BSI_CONTINUE_LINKING);\n }\n \n \n@@ -2408,7 +2443,6 @@ expand_omp_parallel (struct omp_region *region)\n   block_stmt_iterator si;\n   tree entry_stmt;\n   edge e;\n-  bool do_cleanup_cfg = false;\n \n   entry_stmt = last_stmt (region->entry);\n   child_fn = OMP_PARALLEL_FN (entry_stmt);\n@@ -2437,13 +2471,12 @@ expand_omp_parallel (struct omp_region *region)\n       bsi_remove (&si, true);\n \n       new_bb = entry_bb;\n-      remove_edge (entry_succ_e);\n       if (exit_bb)\n \t{\n \t  exit_succ_e = single_succ_edge (exit_bb);\n \t  make_edge (new_bb, exit_succ_e->dest, EDGE_FALLTHRU);\n \t}\n-      do_cleanup_cfg = true;\n+      remove_edge_and_dominated_blocks (entry_succ_e);\n     }\n   else\n     {\n@@ -2464,6 +2497,7 @@ expand_omp_parallel (struct omp_region *region)\n \t{\n \t  basic_block entry_succ_bb = single_succ (entry_bb);\n \t  block_stmt_iterator si;\n+\t  tree parcopy_stmt = NULL_TREE, arg, narg;\n \n \t  for (si = bsi_start (entry_succ_bb); ; bsi_next (&si))\n \t    {\n@@ -2480,25 +2514,40 @@ expand_omp_parallel (struct omp_region *region)\n \t\t  && TREE_OPERAND (arg, 0)\n \t\t     == OMP_PARALLEL_DATA_ARG (entry_stmt))\n \t\t{\n-\t\t  if (GIMPLE_STMT_OPERAND (stmt, 0)\n-\t\t      == DECL_ARGUMENTS (child_fn))\n-\t\t    bsi_remove (&si, true);\n-\t\t  else\n-\t\t    GIMPLE_STMT_OPERAND (stmt, 1) = DECL_ARGUMENTS (child_fn);\n+\t\t  parcopy_stmt = stmt;\n \t\t  break;\n \t\t}\n \t    }\n+\n+\t  gcc_assert (parcopy_stmt != NULL_TREE);\n+\t  arg = DECL_ARGUMENTS (child_fn);\n+\n+\t  if (!gimple_in_ssa_p (cfun))\n+\t    {\n+\t      if (GIMPLE_STMT_OPERAND (parcopy_stmt, 0) == arg)\n+\t\tbsi_remove (&si, true);\n+\t      else\n+\t\tGIMPLE_STMT_OPERAND (parcopy_stmt, 1) = arg;\n+\t    }\n+\t  else\n+\t    {\n+\t      /* If we are in ssa form, we must load the value from the default\n+\t\t definition of the argument.  That should not be defined now,\n+\t\t since the argument is not used uninitialized.  */\n+\t      gcc_assert (gimple_default_def (cfun, arg) == NULL);\n+\t      narg = make_ssa_name (arg, build_empty_stmt ());\n+\t      set_default_def (arg, narg);\n+\t      GIMPLE_STMT_OPERAND (parcopy_stmt, 1) = narg;\n+\t      update_stmt (parcopy_stmt);\n+\t    }\n \t}\n \n       /* Declare local variables needed in CHILD_CFUN.  */\n       block = DECL_INITIAL (child_fn);\n       BLOCK_VARS (block) = list2chain (child_cfun->unexpanded_var_list);\n       DECL_SAVED_TREE (child_fn) = bb_stmt_list (single_succ (entry_bb));\n \n-      /* Reset DECL_CONTEXT on locals and function arguments.  */\n-      for (t = BLOCK_VARS (block); t; t = TREE_CHAIN (t))\n-\tDECL_CONTEXT (t) = child_fn;\n-\n+      /* Reset DECL_CONTEXT on function arguments.  */\n       for (t = DECL_ARGUMENTS (child_fn); t; t = TREE_CHAIN (t))\n \tDECL_CONTEXT (t) = child_fn;\n \n@@ -2512,17 +2561,6 @@ expand_omp_parallel (struct omp_region *region)\n       entry_bb = e->dest;\n       single_succ_edge (entry_bb)->flags = EDGE_FALLTHRU;\n \n-      /* Move the parallel region into CHILD_CFUN.  We need to reset\n-\t dominance information because the expansion of the inner\n-\t regions has invalidated it.  */\n-      free_dominance_info (CDI_DOMINATORS);\n-      new_bb = move_sese_region_to_fn (child_cfun, entry_bb, exit_bb);\n-      if (exit_bb)\n-\tsingle_succ_edge (new_bb)->flags = EDGE_FALLTHRU;\n-      DECL_STRUCT_FUNCTION (child_fn)->curr_properties\n-\t= cfun->curr_properties;\n-      cgraph_add_new_function (child_fn, true);\n-\n       /* Convert OMP_RETURN into a RETURN_EXPR.  */\n       if (exit_bb)\n \t{\n@@ -2533,18 +2571,35 @@ expand_omp_parallel (struct omp_region *region)\n \t  bsi_insert_after (&si, t, BSI_SAME_STMT);\n \t  bsi_remove (&si, true);\n \t}\n+\n+      /* Move the parallel region into CHILD_CFUN.  */\n+ \n+      if (gimple_in_ssa_p (cfun))\n+\t{\n+\t  push_cfun (child_cfun);\n+\t  init_tree_ssa ();\n+\t  init_ssa_operands ();\n+\t  cfun->gimple_df->in_ssa_p = true;\n+\t  pop_cfun ();\n+\t}\n+      new_bb = move_sese_region_to_fn (child_cfun, entry_bb, exit_bb);\n+      if (exit_bb)\n+\tsingle_succ_edge (new_bb)->flags = EDGE_FALLTHRU;\n+\n+      /* Inform the callgraph about the new function.  */\n+      DECL_STRUCT_FUNCTION (child_fn)->curr_properties\n+\t= cfun->curr_properties;\n+      cgraph_add_new_function (child_fn, true);\n+\n+      /* Fix the callgraph edges for child_cfun.  Those for cfun will be\n+\t fixed in a following pass.  */\n+      push_cfun (child_cfun);\n+      rebuild_cgraph_edges ();\n+      pop_cfun ();\n     }\n \n   /* Emit a library call to launch the children threads.  */\n   expand_parallel_call (region, new_bb, entry_stmt, ws_args);\n-\n-  if (do_cleanup_cfg)\n-    {\n-      /* Clean up the unreachable sub-graph we created above.  */\n-      free_dominance_info (CDI_DOMINATORS);\n-      free_dominance_info (CDI_POST_DOMINATORS);\n-      cleanup_tree_cfg ();\n-    }\n }\n \n \n@@ -2569,31 +2624,36 @@ expand_omp_parallel (struct omp_region *region)\n     L3:\n \n     If this is a combined omp parallel loop, instead of the call to\n-    GOMP_loop_foo_start, we emit 'goto L2'.  */\n+    GOMP_loop_foo_start, we call GOMP_loop_foo_next.  */\n \n static void\n expand_omp_for_generic (struct omp_region *region,\n \t\t\tstruct omp_for_data *fd,\n \t\t\tenum built_in_function start_fn,\n \t\t\tenum built_in_function next_fn)\n {\n-  tree type, istart0, iend0, iend;\n-  tree t, list;\n+  tree type, istart0, iend0, iend, phi;\n+  tree t, vmain, vback;\n   basic_block entry_bb, cont_bb, exit_bb, l0_bb, l1_bb;\n   basic_block l2_bb = NULL, l3_bb = NULL;\n   block_stmt_iterator si;\n   bool in_combined_parallel = is_combined_parallel (region);\n   bool broken_loop = region->cont == NULL;\n+  edge e, ne;\n \n   gcc_assert (!broken_loop || !in_combined_parallel);\n \n   type = TREE_TYPE (fd->v);\n \n   istart0 = create_tmp_var (long_integer_type_node, \".istart0\");\n   iend0 = create_tmp_var (long_integer_type_node, \".iend0\");\n-  iend = create_tmp_var (type, NULL);\n   TREE_ADDRESSABLE (istart0) = 1;\n   TREE_ADDRESSABLE (iend0) = 1;\n+  if (gimple_in_ssa_p (cfun))\n+    {\n+      add_referenced_var (istart0);\n+      add_referenced_var (iend0);\n+    }\n \n   entry_bb = region->entry;\n   cont_bb = region->cont;\n@@ -2615,12 +2675,19 @@ expand_omp_for_generic (struct omp_region *region,\n \n   si = bsi_last (entry_bb);\n   gcc_assert (TREE_CODE (bsi_stmt (si)) == OMP_FOR);\n-  if (!in_combined_parallel)\n+  if (in_combined_parallel)\n+    {\n+      /* In a combined parallel loop, emit a call to\n+\t GOMP_loop_foo_next.  */\n+      t = build_call_expr (built_in_decls[next_fn], 2,\n+\t\t\t   build_fold_addr_expr (istart0),\n+\t\t\t   build_fold_addr_expr (iend0));\n+    }\n+  else\n     {\n       tree t0, t1, t2, t3, t4;\n       /* If this is not a combined parallel loop, emit a call to\n \t GOMP_loop_foo_start in ENTRY_BB.  */\n-      list = alloc_stmt_list ();\n       t4 = build_fold_addr_expr (iend0);\n       t3 = build_fold_addr_expr (istart0);\n       t2 = fold_convert (long_integer_type_node, fd->step);\n@@ -2635,58 +2702,80 @@ expand_omp_for_generic (struct omp_region *region,\n       else\n \tt = build_call_expr (built_in_decls[start_fn], 5,\n \t\t\t     t0, t1, t2, t3, t4);\n-      t = get_formal_tmp_var (t, &list);\n-      t = build3 (COND_EXPR, void_type_node, t, NULL_TREE, NULL_TREE);\n-      append_to_statement_list (t, &list);\n-      bsi_insert_after (&si, list, BSI_SAME_STMT);\n     }\n+  t = force_gimple_operand_bsi (&si, t, true, NULL_TREE,\n+\t\t\t       \ttrue, BSI_SAME_STMT);\n+  t = build3 (COND_EXPR, void_type_node, t, NULL_TREE, NULL_TREE);\n+  bsi_insert_after (&si, t, BSI_SAME_STMT);\n+\n+  /* V may be used outside of the loop (e.g., to handle lastprivate clause).\n+     If this is the case, its value is undefined if the loop is not entered\n+     at all.  To handle this case, set its initial value to N1.  */\n+  if (gimple_in_ssa_p (cfun))\n+    {\n+      e = find_edge (entry_bb, l3_bb);\n+      for (phi = phi_nodes (l3_bb); phi; phi = PHI_CHAIN (phi))\n+\tif (PHI_ARG_DEF_FROM_EDGE (phi, e) == fd->v)\n+\t  SET_USE (PHI_ARG_DEF_PTR_FROM_EDGE (phi, e), fd->n1);\n+    }\n+  else\n+    {\n+      t = build_gimple_modify_stmt (fd->v, fd->n1);\n+      bsi_insert_before (&si, t, BSI_SAME_STMT);\n+    }\n+\n+  /* Remove the OMP_FOR statement.  */\n   bsi_remove (&si, true);\n \n   /* Iteration setup for sequential loop goes in L0_BB.  */\n-  list = alloc_stmt_list ();\n+  si = bsi_start (l0_bb);\n   t = fold_convert (type, istart0);\n+  t = force_gimple_operand_bsi (&si, t, false, NULL_TREE,\n+\t\t\t\tfalse, BSI_CONTINUE_LINKING);\n   t = build_gimple_modify_stmt (fd->v, t);\n-  gimplify_and_add (t, &list);\n+  bsi_insert_after (&si, t, BSI_CONTINUE_LINKING);\n+  if (gimple_in_ssa_p (cfun))\n+    SSA_NAME_DEF_STMT (fd->v) = t;\n \n   t = fold_convert (type, iend0);\n-  t = build_gimple_modify_stmt (iend, t);\n-  gimplify_and_add (t, &list);\n-\n-  si = bsi_start (l0_bb);\n-  bsi_insert_after (&si, list, BSI_CONTINUE_LINKING);\n+  iend = force_gimple_operand_bsi (&si, t, true, NULL_TREE,\n+\t\t\t\t   false, BSI_CONTINUE_LINKING);\n \n   if (!broken_loop)\n     {\n       /* Code to control the increment and predicate for the sequential\n \t loop goes in the CONT_BB.  */\n-      list = alloc_stmt_list ();\n-\n-      t = build2 (PLUS_EXPR, type, fd->v, fd->step);\n-      t = build_gimple_modify_stmt (fd->v, t);\n-      gimplify_and_add (t, &list);\n+      si = bsi_last (cont_bb);\n+      t = bsi_stmt (si);\n+      gcc_assert (TREE_CODE (t) == OMP_CONTINUE);\n+      vmain = TREE_OPERAND (t, 1);\n+      vback = TREE_OPERAND (t, 0);\n+\n+      t = fold_build2 (PLUS_EXPR, type, vmain, fd->step);\n+      t = force_gimple_operand_bsi (&si, t, false, NULL_TREE,\n+\t\t\t\t    true, BSI_SAME_STMT);\n+      t = build_gimple_modify_stmt (vback, t);\n+      bsi_insert_before (&si, t, BSI_SAME_STMT);\n+      if (gimple_in_ssa_p (cfun))\n+\tSSA_NAME_DEF_STMT (vback) = t;\n   \n-      t = build2 (fd->cond_code, boolean_type_node, fd->v, iend);\n-      t = get_formal_tmp_var (t, &list);\n+      t = build2 (fd->cond_code, boolean_type_node, vback, iend);\n       t = build3 (COND_EXPR, void_type_node, t, NULL_TREE, NULL_TREE);\n-      append_to_statement_list (t, &list);\n+      bsi_insert_before (&si, t, BSI_SAME_STMT);\n \n-      si = bsi_last (cont_bb);\n-      bsi_insert_after (&si, list, BSI_SAME_STMT);\n-      gcc_assert (TREE_CODE (bsi_stmt (si)) == OMP_CONTINUE);\n+      /* Remove OMP_CONTINUE.  */\n       bsi_remove (&si, true);\n \n       /* Emit code to get the next parallel iteration in L2_BB.  */\n-      list = alloc_stmt_list ();\n+      si = bsi_start (l2_bb);\n \n       t = build_call_expr (built_in_decls[next_fn], 2,\n \t\t\t   build_fold_addr_expr (istart0),\n \t\t\t   build_fold_addr_expr (iend0));\n-      t = get_formal_tmp_var (t, &list);\n+      t = force_gimple_operand_bsi (&si, t, true, NULL_TREE,\n+\t\t\t\t    false, BSI_CONTINUE_LINKING);\n       t = build3 (COND_EXPR, void_type_node, t, NULL_TREE, NULL_TREE);\n-      append_to_statement_list (t, &list);\n-  \n-      si = bsi_start (l2_bb);\n-      bsi_insert_after (&si, list, BSI_CONTINUE_LINKING);\n+      bsi_insert_after (&si, t, BSI_CONTINUE_LINKING);\n     }\n \n   /* Add the loop cleanup function.  */\n@@ -2700,25 +2789,31 @@ expand_omp_for_generic (struct omp_region *region,\n   bsi_remove (&si, true);\n \n   /* Connect the new blocks.  */\n-  if (in_combined_parallel)\n-    {\n-      remove_edge (BRANCH_EDGE (entry_bb));\n-      redirect_edge_and_branch (single_succ_edge (entry_bb), l2_bb);\n-    }\n-  else\n-    {\n-      find_edge (entry_bb, l0_bb)->flags = EDGE_TRUE_VALUE;\n-      find_edge (entry_bb, l3_bb)->flags = EDGE_FALSE_VALUE;\n-    }\n+  find_edge (entry_bb, l0_bb)->flags = EDGE_TRUE_VALUE;\n+  find_edge (entry_bb, l3_bb)->flags = EDGE_FALSE_VALUE;\n \n   if (!broken_loop)\n     {\n+      e = find_edge (cont_bb, l3_bb);\n+      ne = make_edge (l2_bb, l3_bb, EDGE_FALSE_VALUE);\n+\n+      for (phi = phi_nodes (l3_bb); phi; phi = PHI_CHAIN (phi))\n+\tSET_USE (PHI_ARG_DEF_PTR_FROM_EDGE (phi, ne),\n+\t\t PHI_ARG_DEF_FROM_EDGE (phi, e));\n+      remove_edge (e);\n+\n       find_edge (cont_bb, l1_bb)->flags = EDGE_TRUE_VALUE;\n-      remove_edge (find_edge (cont_bb, l3_bb));\n       make_edge (cont_bb, l2_bb, EDGE_FALSE_VALUE);\n-\n       make_edge (l2_bb, l0_bb, EDGE_TRUE_VALUE);\n-      make_edge (l2_bb, l3_bb, EDGE_FALSE_VALUE);\n+\n+      set_immediate_dominator (CDI_DOMINATORS, l2_bb,\n+\t\t\t       recompute_dominator (CDI_DOMINATORS, l2_bb));\n+      set_immediate_dominator (CDI_DOMINATORS, l3_bb,\n+\t\t\t       recompute_dominator (CDI_DOMINATORS, l3_bb));\n+      set_immediate_dominator (CDI_DOMINATORS, l0_bb,\n+\t\t\t       recompute_dominator (CDI_DOMINATORS, l0_bb));\n+      set_immediate_dominator (CDI_DOMINATORS, l1_bb,\n+\t\t\t       recompute_dominator (CDI_DOMINATORS, l1_bb));\n     }\n }\n \n@@ -2740,9 +2835,9 @@ expand_omp_for_generic (struct omp_region *region,\n \tq += (q * nthreads != n);\n \ts0 = q * threadid;\n \te0 = min(s0 + q, n);\n+\tV = s0 * STEP + N1;\n \tif (s0 >= e0) goto L2; else goto L0;\n     L0:\n-\tV = s0 * STEP + N1;\n \te = e0 * STEP + N1;\n     L1:\n \tBODY;\n@@ -2756,7 +2851,7 @@ expand_omp_for_static_nochunk (struct omp_region *region,\n \t\t\t       struct omp_for_data *fd)\n {\n   tree n, q, s0, e0, e, t, nthreads, threadid;\n-  tree type, list;\n+  tree type, vmain, vback;\n   basic_block entry_bb, exit_bb, seq_start_bb, body_bb, cont_bb;\n   basic_block fin_bb;\n   block_stmt_iterator si;\n@@ -2775,113 +2870,124 @@ expand_omp_for_static_nochunk (struct omp_region *region,\n   exit_bb = region->exit;\n \n   /* Iteration space partitioning goes in ENTRY_BB.  */\n-  list = alloc_stmt_list ();\n+  si = bsi_last (entry_bb);\n+  gcc_assert (TREE_CODE (bsi_stmt (si)) == OMP_FOR);\n \n   t = build_call_expr (built_in_decls[BUILT_IN_OMP_GET_NUM_THREADS], 0);\n   t = fold_convert (type, t);\n-  nthreads = get_formal_tmp_var (t, &list);\n+  nthreads = force_gimple_operand_bsi (&si, t, true, NULL_TREE,\n+\t\t\t\t       true, BSI_SAME_STMT);\n   \n   t = build_call_expr (built_in_decls[BUILT_IN_OMP_GET_THREAD_NUM], 0);\n   t = fold_convert (type, t);\n-  threadid = get_formal_tmp_var (t, &list);\n+  threadid = force_gimple_operand_bsi (&si, t, true, NULL_TREE,\n+\t\t\t\t       true, BSI_SAME_STMT);\n \n-  fd->n1 = fold_convert (type, fd->n1);\n-  if (!is_gimple_val (fd->n1))\n-    fd->n1 = get_formal_tmp_var (fd->n1, &list);\n+  fd->n1 = force_gimple_operand_bsi (&si,\n+\t\t\t\t     fold_convert (type, fd->n1),\n+\t\t\t\t     true, NULL_TREE,\n+\t\t\t\t     true, BSI_SAME_STMT);\n \n-  fd->n2 = fold_convert (type, fd->n2);\n-  if (!is_gimple_val (fd->n2))\n-    fd->n2 = get_formal_tmp_var (fd->n2, &list);\n+  fd->n2 = force_gimple_operand_bsi (&si,\n+\t\t\t\t    fold_convert (type, fd->n2),\n+\t\t\t\t    true, NULL_TREE,\n+\t\t\t\t    true, BSI_SAME_STMT);\n \n-  fd->step = fold_convert (type, fd->step);\n-  if (!is_gimple_val (fd->step))\n-    fd->step = get_formal_tmp_var (fd->step, &list);\n+  fd->step = force_gimple_operand_bsi (&si,\n+\t\t\t\t       fold_convert (type, fd->step),\n+\t\t\t\t       true, NULL_TREE,\n+\t\t\t\t       true, BSI_SAME_STMT);\n \n   t = build_int_cst (type, (fd->cond_code == LT_EXPR ? -1 : 1));\n   t = fold_build2 (PLUS_EXPR, type, fd->step, t);\n   t = fold_build2 (PLUS_EXPR, type, t, fd->n2);\n   t = fold_build2 (MINUS_EXPR, type, t, fd->n1);\n   t = fold_build2 (TRUNC_DIV_EXPR, type, t, fd->step);\n   t = fold_convert (type, t);\n-  if (is_gimple_val (t))\n-    n = t;\n-  else\n-    n = get_formal_tmp_var (t, &list);\n+  n = force_gimple_operand_bsi (&si, t, true, NULL_TREE, true, BSI_SAME_STMT);\n \n-  t = build2 (TRUNC_DIV_EXPR, type, n, nthreads);\n-  q = get_formal_tmp_var (t, &list);\n+  t = fold_build2 (TRUNC_DIV_EXPR, type, n, nthreads);\n+  q = force_gimple_operand_bsi (&si, t, true, NULL_TREE, true, BSI_SAME_STMT);\n \n-  t = build2 (MULT_EXPR, type, q, nthreads);\n-  t = build2 (NE_EXPR, type, t, n);\n-  t = build2 (PLUS_EXPR, type, q, t);\n-  q = get_formal_tmp_var (t, &list);\n+  t = fold_build2 (MULT_EXPR, type, q, nthreads);\n+  t = fold_build2 (NE_EXPR, type, t, n);\n+  t = fold_build2 (PLUS_EXPR, type, q, t);\n+  q = force_gimple_operand_bsi (&si, t, true, NULL_TREE, true, BSI_SAME_STMT);\n \n   t = build2 (MULT_EXPR, type, q, threadid);\n-  s0 = get_formal_tmp_var (t, &list);\n+  s0 = force_gimple_operand_bsi (&si, t, true, NULL_TREE, true, BSI_SAME_STMT);\n+\n+  t = fold_build2 (PLUS_EXPR, type, s0, q);\n+  t = fold_build2 (MIN_EXPR, type, t, n);\n+  e0 = force_gimple_operand_bsi (&si, t, true, NULL_TREE, true, BSI_SAME_STMT);\n \n-  t = build2 (PLUS_EXPR, type, s0, q);\n-  t = build2 (MIN_EXPR, type, t, n);\n-  e0 = get_formal_tmp_var (t, &list);\n+  t = fold_convert (type, s0);\n+  t = fold_build2 (MULT_EXPR, type, t, fd->step);\n+  t = fold_build2 (PLUS_EXPR, type, t, fd->n1);\n+  t = force_gimple_operand_bsi (&si, t, false, NULL_TREE,\n+\t\t\t\ttrue, BSI_SAME_STMT);\n+  t = build_gimple_modify_stmt (fd->v, t);\n+  bsi_insert_before (&si, t, BSI_SAME_STMT);\n+  if (gimple_in_ssa_p (cfun))\n+    SSA_NAME_DEF_STMT (fd->v) = t;\n \n   t = build2 (GE_EXPR, boolean_type_node, s0, e0);\n   t = build3 (COND_EXPR, void_type_node, t, NULL_TREE, NULL_TREE);\n-  append_to_statement_list (t, &list);\n+  bsi_insert_before (&si, t, BSI_SAME_STMT);\n \n-  si = bsi_last (entry_bb);\n-  gcc_assert (TREE_CODE (bsi_stmt (si)) == OMP_FOR);\n-  bsi_insert_after (&si, list, BSI_SAME_STMT);\n+  /* Remove the OMP_FOR statement.  */\n   bsi_remove (&si, true);\n \n   /* Setup code for sequential iteration goes in SEQ_START_BB.  */\n-  list = alloc_stmt_list ();\n-\n-  t = fold_convert (type, s0);\n-  t = build2 (MULT_EXPR, type, t, fd->step);\n-  t = build2 (PLUS_EXPR, type, t, fd->n1);\n-  t = build_gimple_modify_stmt (fd->v, t);\n-  gimplify_and_add (t, &list);\n+  si = bsi_start (seq_start_bb);\n \n   t = fold_convert (type, e0);\n-  t = build2 (MULT_EXPR, type, t, fd->step);\n-  t = build2 (PLUS_EXPR, type, t, fd->n1);\n-  e = get_formal_tmp_var (t, &list);\n-\n-  si = bsi_start (seq_start_bb);\n-  bsi_insert_after (&si, list, BSI_CONTINUE_LINKING);\n+  t = fold_build2 (MULT_EXPR, type, t, fd->step);\n+  t = fold_build2 (PLUS_EXPR, type, t, fd->n1);\n+  e = force_gimple_operand_bsi (&si, t, true, NULL_TREE,\n+\t\t\t\tfalse, BSI_CONTINUE_LINKING);\n \n   /* The code controlling the sequential loop replaces the OMP_CONTINUE.  */\n-  list = alloc_stmt_list ();\n-\n-  t = build2 (PLUS_EXPR, type, fd->v, fd->step);\n-  t = build_gimple_modify_stmt (fd->v, t);\n-  gimplify_and_add (t, &list);\n-\n-  t = build2 (fd->cond_code, boolean_type_node, fd->v, e);\n-  t = get_formal_tmp_var (t, &list);\n+  si = bsi_last (cont_bb);\n+  t = bsi_stmt (si);\n+  gcc_assert (TREE_CODE (t) == OMP_CONTINUE);\n+  vmain = TREE_OPERAND (t, 1);\n+  vback = TREE_OPERAND (t, 0);\n+\n+  t = fold_build2 (PLUS_EXPR, type, vmain, fd->step);\n+  t = force_gimple_operand_bsi (&si, t, false, NULL_TREE,\n+\t\t\t\ttrue, BSI_SAME_STMT);\n+  t = build_gimple_modify_stmt (vback, t);\n+  bsi_insert_before (&si, t, BSI_SAME_STMT);\n+  if (gimple_in_ssa_p (cfun))\n+    SSA_NAME_DEF_STMT (vback) = t;\n+\n+  t = build2 (fd->cond_code, boolean_type_node, vback, e);\n   t = build3 (COND_EXPR, void_type_node, t, NULL_TREE, NULL_TREE);\n-  append_to_statement_list (t, &list);\n+  bsi_insert_before (&si, t, BSI_SAME_STMT);\n \n-  si = bsi_last (cont_bb);\n-  gcc_assert (TREE_CODE (bsi_stmt (si)) == OMP_CONTINUE);\n-  bsi_insert_after (&si, list, BSI_SAME_STMT);\n+  /* Remove the OMP_CONTINUE statement.  */\n   bsi_remove (&si, true);\n \n   /* Replace the OMP_RETURN with a barrier, or nothing.  */\n   si = bsi_last (exit_bb);\n   if (!OMP_RETURN_NOWAIT (bsi_stmt (si)))\n-    {\n-      list = alloc_stmt_list ();\n-      build_omp_barrier (&list);\n-      bsi_insert_after (&si, list, BSI_SAME_STMT);\n-    }\n+    force_gimple_operand_bsi (&si, build_omp_barrier (), false, NULL_TREE,\n+\t\t\t      false, BSI_SAME_STMT);\n   bsi_remove (&si, true);\n \n   /* Connect all the blocks.  */\n   find_edge (entry_bb, seq_start_bb)->flags = EDGE_FALSE_VALUE;\n   find_edge (entry_bb, fin_bb)->flags = EDGE_TRUE_VALUE;\n-  \n+\n   find_edge (cont_bb, body_bb)->flags = EDGE_TRUE_VALUE;\n   find_edge (cont_bb, fin_bb)->flags = EDGE_FALSE_VALUE;\n+ \n+  set_immediate_dominator (CDI_DOMINATORS, seq_start_bb, entry_bb);\n+  set_immediate_dominator (CDI_DOMINATORS, body_bb,\n+\t\t\t   recompute_dominator (CDI_DOMINATORS, body_bb));\n+  set_immediate_dominator (CDI_DOMINATORS, fin_bb,\n+\t\t\t   recompute_dominator (CDI_DOMINATORS, fin_bb));\n }\n \n \n@@ -2899,6 +3005,9 @@ expand_omp_for_static_nochunk (struct omp_region *region,\n \t  adj = STEP + 1;\n \tn = (adj + N2 - N1) / STEP;\n \ttrip = 0;\n+\tV = threadid * CHUNK * STEP + N1;  -- this extra definition of V is\n+\t\t\t\t\t      here so that V is defined\n+\t\t\t\t\t      if the loop is not entered\n     L0:\n \ts0 = (trip * nthreads + threadid) * CHUNK;\n \te0 = min(s0 + CHUNK, n);\n@@ -2919,14 +3028,13 @@ expand_omp_for_static_nochunk (struct omp_region *region,\n static void\n expand_omp_for_static_chunk (struct omp_region *region, struct omp_for_data *fd)\n {\n-  tree n, s0, e0, e, t;\n-  tree trip, nthreads, threadid;\n-  tree type;\n+  tree n, s0, e0, e, t, phi, nphi, args;\n+  tree trip_var, trip_init, trip_main, trip_back, nthreads, threadid;\n+  tree type, cont, v_main, v_back, v_extra;\n   basic_block entry_bb, exit_bb, body_bb, seq_start_bb, iter_part_bb;\n   basic_block trip_update_bb, cont_bb, fin_bb;\n-  tree list;\n   block_stmt_iterator si;\n-  edge se;\n+  edge se, re, ene;\n \n   type = TREE_TYPE (fd->v);\n \n@@ -2947,134 +3055,204 @@ expand_omp_for_static_chunk (struct omp_region *region, struct omp_for_data *fd)\n   exit_bb = region->exit;\n \n   /* Trip and adjustment setup goes in ENTRY_BB.  */\n-  list = alloc_stmt_list ();\n+  si = bsi_last (entry_bb);\n+  gcc_assert (TREE_CODE (bsi_stmt (si)) == OMP_FOR);\n \n   t = build_call_expr (built_in_decls[BUILT_IN_OMP_GET_NUM_THREADS], 0);\n   t = fold_convert (type, t);\n-  nthreads = get_formal_tmp_var (t, &list);\n+  nthreads = force_gimple_operand_bsi (&si, t, true, NULL_TREE,\n+\t\t\t\t       true, BSI_SAME_STMT);\n   \n   t = build_call_expr (built_in_decls[BUILT_IN_OMP_GET_THREAD_NUM], 0);\n   t = fold_convert (type, t);\n-  threadid = get_formal_tmp_var (t, &list);\n-\n-  fd->n1 = fold_convert (type, fd->n1);\n-  if (!is_gimple_val (fd->n1))\n-    fd->n1 = get_formal_tmp_var (fd->n1, &list);\n-\n-  fd->n2 = fold_convert (type, fd->n2);\n-  if (!is_gimple_val (fd->n2))\n-    fd->n2 = get_formal_tmp_var (fd->n2, &list);\n-\n-  fd->step = fold_convert (type, fd->step);\n-  if (!is_gimple_val (fd->step))\n-    fd->step = get_formal_tmp_var (fd->step, &list);\n-\n-  fd->chunk_size = fold_convert (type, fd->chunk_size);\n-  if (!is_gimple_val (fd->chunk_size))\n-    fd->chunk_size = get_formal_tmp_var (fd->chunk_size, &list);\n+  threadid = force_gimple_operand_bsi (&si, t, true, NULL_TREE,\n+\t\t\t\t       true, BSI_SAME_STMT);\n+\n+  fd->n1 = force_gimple_operand_bsi (&si, fold_convert (type, fd->n1),\n+\t\t\t\t     true, NULL_TREE,\n+\t\t\t\t     true, BSI_SAME_STMT);\n+  fd->n2 = force_gimple_operand_bsi (&si, fold_convert (type, fd->n2),\n+\t\t\t\t     true, NULL_TREE,\n+\t\t\t\t     true, BSI_SAME_STMT);\n+  fd->step = force_gimple_operand_bsi (&si, fold_convert (type, fd->step),\n+\t\t\t\t       true, NULL_TREE,\n+\t\t\t\t       true, BSI_SAME_STMT);\n+  fd->chunk_size\n+\t  = force_gimple_operand_bsi (&si, fold_convert (type,\n+\t\t\t\t\t\t\t fd->chunk_size),\n+\t\t\t\t      true, NULL_TREE,\n+\t\t\t\t      true, BSI_SAME_STMT);\n \n   t = build_int_cst (type, (fd->cond_code == LT_EXPR ? -1 : 1));\n   t = fold_build2 (PLUS_EXPR, type, fd->step, t);\n   t = fold_build2 (PLUS_EXPR, type, t, fd->n2);\n   t = fold_build2 (MINUS_EXPR, type, t, fd->n1);\n   t = fold_build2 (TRUNC_DIV_EXPR, type, t, fd->step);\n   t = fold_convert (type, t);\n-  if (is_gimple_val (t))\n-    n = t;\n+  n = force_gimple_operand_bsi (&si, t, true, NULL_TREE,\n+\t\t\t\ttrue, BSI_SAME_STMT);\n+\n+  trip_var = create_tmp_var (type, \".trip\");\n+  if (gimple_in_ssa_p (cfun))\n+    {\n+      add_referenced_var (trip_var);\n+      trip_init = make_ssa_name (trip_var, NULL_TREE);\n+      trip_main = make_ssa_name (trip_var, NULL_TREE);\n+      trip_back = make_ssa_name (trip_var, NULL_TREE);\n+    }\n   else\n-    n = get_formal_tmp_var (t, &list);\n+    {\n+      trip_init = trip_var;\n+      trip_main = trip_var;\n+      trip_back = trip_var;\n+    }\n \n-  t = build_int_cst (type, 0);\n-  trip = get_initialized_tmp_var (t, &list, NULL);\n+  t = build_gimple_modify_stmt (trip_init, build_int_cst (type, 0));\n+  bsi_insert_before (&si, t, BSI_SAME_STMT);\n+  if (gimple_in_ssa_p (cfun))\n+    SSA_NAME_DEF_STMT (trip_init) = t;\n \n-  si = bsi_last (entry_bb);\n-  gcc_assert (TREE_CODE (bsi_stmt (si)) == OMP_FOR);\n-  bsi_insert_after (&si, list, BSI_SAME_STMT);\n+  t = fold_build2 (MULT_EXPR, type, threadid, fd->chunk_size);\n+  t = fold_build2 (MULT_EXPR, type, t, fd->step);\n+  t = fold_build2 (PLUS_EXPR, type, t, fd->n1);\n+  v_extra = force_gimple_operand_bsi (&si, t, true, NULL_TREE,\n+\t\t\t\t      true, BSI_SAME_STMT);\n+\n+  /* Remove the OMP_FOR.  */\n   bsi_remove (&si, true);\n \n   /* Iteration space partitioning goes in ITER_PART_BB.  */\n-  list = alloc_stmt_list ();\n+  si = bsi_last (iter_part_bb);\n \n-  t = build2 (MULT_EXPR, type, trip, nthreads);\n-  t = build2 (PLUS_EXPR, type, t, threadid);\n-  t = build2 (MULT_EXPR, type, t, fd->chunk_size);\n-  s0 = get_formal_tmp_var (t, &list);\n+  t = fold_build2 (MULT_EXPR, type, trip_main, nthreads);\n+  t = fold_build2 (PLUS_EXPR, type, t, threadid);\n+  t = fold_build2 (MULT_EXPR, type, t, fd->chunk_size);\n+  s0 = force_gimple_operand_bsi (&si, t, true, NULL_TREE,\n+\t\t\t\t false, BSI_CONTINUE_LINKING);\n \n-  t = build2 (PLUS_EXPR, type, s0, fd->chunk_size);\n-  t = build2 (MIN_EXPR, type, t, n);\n-  e0 = get_formal_tmp_var (t, &list);\n+  t = fold_build2 (PLUS_EXPR, type, s0, fd->chunk_size);\n+  t = fold_build2 (MIN_EXPR, type, t, n);\n+  e0 = force_gimple_operand_bsi (&si, t, true, NULL_TREE,\n+\t\t\t\t false, BSI_CONTINUE_LINKING);\n \n   t = build2 (LT_EXPR, boolean_type_node, s0, n);\n   t = build3 (COND_EXPR, void_type_node, t, NULL_TREE, NULL_TREE);\n-  append_to_statement_list (t, &list);\n-\n-  si = bsi_start (iter_part_bb);\n-  bsi_insert_after (&si, list, BSI_CONTINUE_LINKING);\n+  bsi_insert_after (&si, t, BSI_CONTINUE_LINKING);\n \n   /* Setup code for sequential iteration goes in SEQ_START_BB.  */\n-  list = alloc_stmt_list ();\n+  si = bsi_start (seq_start_bb);\n \n   t = fold_convert (type, s0);\n-  t = build2 (MULT_EXPR, type, t, fd->step);\n-  t = build2 (PLUS_EXPR, type, t, fd->n1);\n+  t = fold_build2 (MULT_EXPR, type, t, fd->step);\n+  t = fold_build2 (PLUS_EXPR, type, t, fd->n1);\n+  t = force_gimple_operand_bsi (&si, t, false, NULL_TREE,\n+\t\t\t\tfalse, BSI_CONTINUE_LINKING);\n   t = build_gimple_modify_stmt (fd->v, t);\n-  gimplify_and_add (t, &list);\n+  bsi_insert_after (&si, t, BSI_CONTINUE_LINKING);\n+  if (gimple_in_ssa_p (cfun))\n+    SSA_NAME_DEF_STMT (fd->v) = t;\n \n   t = fold_convert (type, e0);\n-  t = build2 (MULT_EXPR, type, t, fd->step);\n-  t = build2 (PLUS_EXPR, type, t, fd->n1);\n-  e = get_formal_tmp_var (t, &list);\n-\n-  si = bsi_start (seq_start_bb);\n-  bsi_insert_after (&si, list, BSI_CONTINUE_LINKING);\n+  t = fold_build2 (MULT_EXPR, type, t, fd->step);\n+  t = fold_build2 (PLUS_EXPR, type, t, fd->n1);\n+  e = force_gimple_operand_bsi (&si, t, true, NULL_TREE,\n+\t\t\t\tfalse, BSI_CONTINUE_LINKING);\n \n   /* The code controlling the sequential loop goes in CONT_BB,\n      replacing the OMP_CONTINUE.  */\n-  list = alloc_stmt_list ();\n-\n-  t = build2 (PLUS_EXPR, type, fd->v, fd->step);\n-  t = build_gimple_modify_stmt (fd->v, t);\n-  gimplify_and_add (t, &list);\n-\n-  t = build2 (fd->cond_code, boolean_type_node, fd->v, e);\n-  t = get_formal_tmp_var (t, &list);\n+  si = bsi_last (cont_bb);\n+  cont = bsi_stmt (si);\n+  gcc_assert (TREE_CODE (cont) == OMP_CONTINUE);\n+  v_main = TREE_OPERAND (cont, 1);\n+  v_back = TREE_OPERAND (cont, 0);\n+\n+  t = build2 (PLUS_EXPR, type, v_main, fd->step);\n+  t = build_gimple_modify_stmt (v_back, t);\n+  bsi_insert_before (&si, t, BSI_SAME_STMT);\n+  if (gimple_in_ssa_p (cfun))\n+    SSA_NAME_DEF_STMT (v_back) = t;\n+\n+  t = build2 (fd->cond_code, boolean_type_node, v_back, e);\n   t = build3 (COND_EXPR, void_type_node, t, NULL_TREE, NULL_TREE);\n-  append_to_statement_list (t, &list);\n+  bsi_insert_before (&si, t, BSI_SAME_STMT);\n   \n-  si = bsi_last (cont_bb);\n-  gcc_assert (TREE_CODE (bsi_stmt (si)) == OMP_CONTINUE);\n-  bsi_insert_after (&si, list, BSI_SAME_STMT);\n+  /* Remove OMP_CONTINUE.  */\n   bsi_remove (&si, true);\n \n   /* Trip update code goes into TRIP_UPDATE_BB.  */\n-  list = alloc_stmt_list ();\n+  si = bsi_start (trip_update_bb);\n \n   t = build_int_cst (type, 1);\n-  t = build2 (PLUS_EXPR, type, trip, t);\n-  t = build_gimple_modify_stmt (trip, t);\n-  gimplify_and_add (t, &list);\n-\n-  si = bsi_start (trip_update_bb);\n-  bsi_insert_after (&si, list, BSI_CONTINUE_LINKING);\n+  t = build2 (PLUS_EXPR, type, trip_main, t);\n+  t = build_gimple_modify_stmt (trip_back, t);\n+  bsi_insert_after (&si, t, BSI_CONTINUE_LINKING);\n+  if (gimple_in_ssa_p (cfun))\n+    SSA_NAME_DEF_STMT (trip_back) = t;\n \n   /* Replace the OMP_RETURN with a barrier, or nothing.  */\n   si = bsi_last (exit_bb);\n   if (!OMP_RETURN_NOWAIT (bsi_stmt (si)))\n-    {\n-      list = alloc_stmt_list ();\n-      build_omp_barrier (&list);\n-      bsi_insert_after (&si, list, BSI_SAME_STMT);\n-    }\n+    force_gimple_operand_bsi (&si, build_omp_barrier (), false, NULL_TREE,\n+\t\t\t      false, BSI_SAME_STMT);\n   bsi_remove (&si, true);\n \n   /* Connect the new blocks.  */\n   find_edge (iter_part_bb, seq_start_bb)->flags = EDGE_TRUE_VALUE;\n   find_edge (iter_part_bb, fin_bb)->flags = EDGE_FALSE_VALUE;\n-  \n+\n   find_edge (cont_bb, body_bb)->flags = EDGE_TRUE_VALUE;\n   find_edge (cont_bb, trip_update_bb)->flags = EDGE_FALSE_VALUE;\n-  \n+\n   redirect_edge_and_branch (single_succ_edge (trip_update_bb), iter_part_bb);\n+\n+  if (gimple_in_ssa_p (cfun))\n+    {\n+      /* When we redirect the edge from trip_update_bb to iter_part_bb, we\n+\t remove arguments of the phi nodes in fin_bb.  We need to create\n+\t appropriate phi nodes in iter_part_bb instead.  */\n+      se = single_pred_edge (fin_bb);\n+      re = single_succ_edge (trip_update_bb);\n+      ene = single_succ_edge (entry_bb);\n+\n+      args = PENDING_STMT (re);\n+      PENDING_STMT (re) = NULL_TREE;\n+      for (phi = phi_nodes (fin_bb);\n+\t   phi && args;\n+\t   phi = PHI_CHAIN (phi), args = TREE_CHAIN (args))\n+\t{\n+\t  t = PHI_RESULT (phi);\n+\t  gcc_assert (t == TREE_PURPOSE (args));\n+\t  nphi = create_phi_node (t, iter_part_bb);\n+\t  SSA_NAME_DEF_STMT (t) = nphi;\n+\n+\t  t = PHI_ARG_DEF_FROM_EDGE (phi, se);\n+\t  /* A special case -- fd->v is not yet computed in iter_part_bb, we\n+\t     need to use v_extra instead.  */\n+\t  if (t == fd->v)\n+\t    t = v_extra;\n+\t  add_phi_arg (nphi, t, ene);\n+\t  add_phi_arg (nphi, TREE_VALUE (args), re);\n+\t}\n+      gcc_assert (!phi && !args);\n+      while ((phi = phi_nodes (fin_bb)) != NULL_TREE)\n+\tremove_phi_node (phi, NULL_TREE, false);\n+\n+      /* Make phi node for trip.  */\n+      phi = create_phi_node (trip_main, iter_part_bb);\n+      SSA_NAME_DEF_STMT (trip_main) = phi;\n+      add_phi_arg (phi, trip_back, single_succ_edge (trip_update_bb));\n+      add_phi_arg (phi, trip_init, single_succ_edge (entry_bb));\n+    }\n+\n+  set_immediate_dominator (CDI_DOMINATORS, trip_update_bb, cont_bb);\n+  set_immediate_dominator (CDI_DOMINATORS, iter_part_bb,\n+\t\t\t   recompute_dominator (CDI_DOMINATORS, iter_part_bb));\n+  set_immediate_dominator (CDI_DOMINATORS, fin_bb,\n+\t\t\t   recompute_dominator (CDI_DOMINATORS, fin_bb));\n+  set_immediate_dominator (CDI_DOMINATORS, seq_start_bb,\n+\t\t\t   recompute_dominator (CDI_DOMINATORS, seq_start_bb));\n+  set_immediate_dominator (CDI_DOMINATORS, body_bb,\n+\t\t\t   recompute_dominator (CDI_DOMINATORS, body_bb));\n }\n \n \n@@ -3085,8 +3263,6 @@ expand_omp_for (struct omp_region *region)\n {\n   struct omp_for_data fd;\n \n-  push_gimplify_context ();\n-\n   extract_omp_for_data (last_stmt (region->entry), &fd);\n   region->sched_kind = fd.sched_kind;\n \n@@ -3106,8 +3282,6 @@ expand_omp_for (struct omp_region *region)\n       int next_ix = BUILT_IN_GOMP_LOOP_STATIC_NEXT + fn_index;\n       expand_omp_for_generic (region, &fd, start_ix, next_ix);\n     }\n-\n-  pop_gimplify_context (NULL);\n }\n \n \n@@ -3136,12 +3310,12 @@ expand_omp_for (struct omp_region *region)\n \treduction;\n \n     If this is a combined parallel sections, replace the call to\n-    GOMP_sections_start with 'goto L1'.  */\n+    GOMP_sections_start with call to GOMP_sections_next.  */\n \n static void\n expand_omp_sections (struct omp_region *region)\n {\n-  tree label_vec, l1, l2, t, u, v, sections_stmt;\n+  tree label_vec, l1, l2, t, u, sections_stmt, vin, vmain, vnext, cont;\n   unsigned i, casei, len;\n   basic_block entry_bb, l0_bb, l1_bb, l2_bb, default_bb;\n   block_stmt_iterator si;\n@@ -3178,7 +3352,7 @@ expand_omp_sections (struct omp_region *region)\n   si = bsi_last (entry_bb);\n   sections_stmt = bsi_stmt (si);\n   gcc_assert (TREE_CODE (sections_stmt) == OMP_SECTIONS);\n-  v = OMP_SECTIONS_CONTROL (sections_stmt);\n+  vin = OMP_SECTIONS_CONTROL (sections_stmt);\n   if (!is_combined_parallel (region))\n     {\n       /* If we are not inside a combined parallel+sections region,\n@@ -3187,16 +3361,36 @@ expand_omp_sections (struct omp_region *region)\n \t\t\t exit_reachable ? len - 1 : len);\n       u = built_in_decls[BUILT_IN_GOMP_SECTIONS_START];\n       t = build_call_expr (u, 1, t);\n-      t = build_gimple_modify_stmt (v, t);\n-      bsi_insert_after (&si, t, BSI_SAME_STMT);\n     }\n+  else\n+    {\n+      /* Otherwise, call GOMP_sections_next.  */\n+      u = built_in_decls[BUILT_IN_GOMP_SECTIONS_NEXT];\n+      t = build_call_expr (u, 0);\n+    }\n+  t = build_gimple_modify_stmt (vin, t);\n+  bsi_insert_after (&si, t, BSI_SAME_STMT);\n+  if (gimple_in_ssa_p (cfun))\n+    SSA_NAME_DEF_STMT (vin) = t;\n   bsi_remove (&si, true);\n \n   /* The switch() statement replacing OMP_SECTIONS_SWITCH goes in L0_BB.  */\n   si = bsi_last (l0_bb);\n   gcc_assert (TREE_CODE (bsi_stmt (si)) == OMP_SECTIONS_SWITCH);\n+  if (exit_reachable)\n+    {\n+      cont = last_stmt (l1_bb);\n+      gcc_assert (TREE_CODE (cont) == OMP_CONTINUE);\n+      vmain = TREE_OPERAND (cont, 1);\n+      vnext = TREE_OPERAND (cont, 0);\n+    }\n+  else\n+    {\n+      vmain = vin;\n+      vnext = NULL_TREE;\n+    }\n \n-  t = build3 (SWITCH_EXPR, void_type_node, v, NULL, label_vec);\n+  t = build3 (SWITCH_EXPR, void_type_node, vmain, NULL, label_vec);\n   bsi_insert_after (&si, t, BSI_SAME_STMT);\n   bsi_remove (&si, true);\n \n@@ -3257,8 +3451,10 @@ expand_omp_sections (struct omp_region *region)\n       gcc_assert (TREE_CODE (bsi_stmt (si)) == OMP_CONTINUE);\n \n       t = build_call_expr (built_in_decls[BUILT_IN_GOMP_SECTIONS_NEXT], 0);\n-      t = build_gimple_modify_stmt (v, t);\n+      t = build_gimple_modify_stmt (vnext, t);\n       bsi_insert_after (&si, t, BSI_SAME_STMT);\n+      if (gimple_in_ssa_p (cfun))\n+\tSSA_NAME_DEF_STMT (vnext) = t;\n       bsi_remove (&si, true);\n \n       single_succ_edge (l1_bb)->flags = EDGE_FALLTHRU;\n@@ -3274,15 +3470,7 @@ expand_omp_sections (struct omp_region *region)\n       bsi_remove (&si, true);\n     }\n \n-  /* Connect the new blocks.  */\n-  if (is_combined_parallel (region))\n-    {\n-      /* If this was a combined parallel+sections region, we did not\n-\t emit a GOMP_sections_start in the entry block, so we just\n-\t need to jump to L1_BB to get the next section.  */\n-      gcc_assert (exit_reachable);\n-      redirect_edge_and_branch (single_succ_edge (entry_bb), l1_bb);\n-    }\n+  set_immediate_dominator (CDI_DOMINATORS, default_bb, l0_bb);\n }\n \n \n@@ -3312,11 +3500,8 @@ expand_omp_single (struct omp_region *region)\n \n   si = bsi_last (exit_bb);\n   if (!OMP_RETURN_NOWAIT (bsi_stmt (si)) || need_barrier)\n-    {\n-      tree t = alloc_stmt_list ();\n-      build_omp_barrier (&t);\n-      bsi_insert_after (&si, t, BSI_SAME_STMT);\n-    }\n+    force_gimple_operand_bsi (&si, build_omp_barrier (), false, NULL_TREE,\n+\t\t\t      false, BSI_SAME_STMT);\n   bsi_remove (&si, true);\n   single_succ_edge (exit_bb)->flags = EDGE_FALLTHRU;\n }\n@@ -3498,19 +3683,45 @@ execute_expand_omp (void)\n \n   expand_omp (root_omp_region);\n \n-  free_dominance_info (CDI_DOMINATORS);\n-  free_dominance_info (CDI_POST_DOMINATORS);\n   cleanup_tree_cfg ();\n \n   free_omp_regions ();\n \n   return 0;\n }\n \n+/* OMP expansion in SSA form.  For testing purposes only.  */\n+\n+static bool\n+gate_expand_omp_ssa (void)\n+{\n+  return flag_openmp_ssa && flag_openmp != 0 && errorcount == 0;\n+}\n+\n+struct tree_opt_pass pass_expand_omp_ssa = \n+{\n+  \"ompexpssa\",\t\t\t\t/* name */\n+  gate_expand_omp_ssa,\t\t\t/* gate */\n+  execute_expand_omp,\t\t\t/* execute */\n+  NULL,\t\t\t\t\t/* sub */\n+  NULL,\t\t\t\t\t/* next */\n+  0,\t\t\t\t\t/* static_pass_number */\n+  0,\t\t\t\t\t/* tv_id */\n+  PROP_gimple_any,\t\t\t/* properties_required */\n+  PROP_gimple_lomp,\t\t\t/* properties_provided */\n+  0,\t\t\t\t\t/* properties_destroyed */\n+  0,\t\t\t\t\t/* todo_flags_start */\n+  TODO_dump_func,\t\t\t/* todo_flags_finish */\n+  0\t\t\t\t\t/* letter */\n+};\n+\n+/* OMP expansion -- the default pass, run before creation of SSA form.  */\n+\n static bool\n gate_expand_omp (void)\n {\n-  return flag_openmp != 0 && errorcount == 0;\n+  return ((!flag_openmp_ssa || !optimize)\n+\t  && flag_openmp != 0 && errorcount == 0);\n }\n \n struct tree_opt_pass pass_expand_omp = "}, {"sha": "29ec8e282ebc0b40a3cf4c94e7b4fee6b5cd78cf", "filename": "gcc/passes.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/917948d364025c5cc418cd6486dc75b43fa12015/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/917948d364025c5cc418cd6486dc75b43fa12015/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=917948d364025c5cc418cd6486dc75b43fa12015", "patch": "@@ -515,6 +515,7 @@ init_optimization_passes (void)\n \t  NEXT_PASS (pass_referenced_vars);\n \t  NEXT_PASS (pass_reset_cc_flags);\n \t  NEXT_PASS (pass_build_ssa);\n+\t  NEXT_PASS (pass_expand_omp_ssa);\n \t  NEXT_PASS (pass_early_warn_uninitialized);\n \t  NEXT_PASS (pass_rebuild_cgraph_edges);\n \t  NEXT_PASS (pass_early_inline);"}, {"sha": "84000537b2f8a87cc98ac854693715ba2ada989d", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 195, "deletions": 63, "changes": 258, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/917948d364025c5cc418cd6486dc75b43fa12015/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/917948d364025c5cc418cd6486dc75b43fa12015/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=917948d364025c5cc418cd6486dc75b43fa12015", "patch": "@@ -46,6 +46,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-ssa-propagate.h\"\n #include \"value-prof.h\"\n #include \"pointer-set.h\"\n+#include \"tree-inline.h\"\n \n /* This file contains functions for building the Control Flow Graph (CFG)\n    for a function tree.  */\n@@ -5248,13 +5249,89 @@ gather_blocks_in_sese_region (basic_block entry, basic_block exit,\n     }\n }\n \n+/* Replaces *TP with a duplicate (belonging to function TO_CONTEXT).\n+   The duplicates are recorded in VARS_MAP.  */\n+\n+static void\n+replace_by_duplicate_decl (tree *tp, struct pointer_map_t *vars_map,\n+\t\t\t   tree to_context)\n+{\n+  tree t = *tp, new_t;\n+  struct function *f = DECL_STRUCT_FUNCTION (to_context);\n+  void **loc;\n+\n+  if (DECL_CONTEXT (t) == to_context)\n+    return;\n+\n+  loc = pointer_map_contains (vars_map, t);\n+\n+  if (!loc)\n+    {\n+      loc = pointer_map_insert (vars_map, t);\n+\n+      if (SSA_VAR_P (t))\n+\t{\n+\t  new_t = copy_var_decl (t, DECL_NAME (t), TREE_TYPE (t));\n+\t  f->unexpanded_var_list\n+\t\t  = tree_cons (NULL_TREE, new_t, f->unexpanded_var_list);\n+\t}\n+      else\n+\t{\n+\t  gcc_assert (TREE_CODE (t) == CONST_DECL);\n+\t  new_t = copy_node (t);\n+\t}\n+      DECL_CONTEXT (new_t) = to_context;\n+\n+      *loc = new_t;\n+    }\n+  else\n+    new_t = *loc;\n+\n+  *tp = new_t;\n+}\n+\n+/* Creates an ssa name in TO_CONTEXT equivalent to NAME.\n+   VARS_MAP maps old ssa names and var_decls to the new ones.  */\n+\n+static tree\n+replace_ssa_name (tree name, struct pointer_map_t *vars_map,\n+\t\t  tree to_context)\n+{\n+  void **loc;\n+  tree new_name, decl = SSA_NAME_VAR (name);\n+\n+  gcc_assert (is_gimple_reg (name));\n+\n+  loc = pointer_map_contains (vars_map, name);\n+\n+  if (!loc)\n+    {\n+      replace_by_duplicate_decl (&decl, vars_map, to_context);\n+\n+      push_cfun (DECL_STRUCT_FUNCTION (to_context));\n+      if (gimple_in_ssa_p (cfun))\n+\tadd_referenced_var (decl);\n+\n+      new_name = make_ssa_name (decl, SSA_NAME_DEF_STMT (name));\n+      if (SSA_NAME_IS_DEFAULT_DEF (name))\n+\tset_default_def (decl, new_name);\n+      pop_cfun ();\n+\n+      loc = pointer_map_insert (vars_map, name);\n+      *loc = new_name;\n+    }\n+  else\n+    new_name = *loc;\n+\n+  return new_name;\n+}\n \n struct move_stmt_d\n {\n   tree block;\n   tree from_context;\n   tree to_context;\n-  bitmap vars_to_remove;\n+  struct pointer_map_t *vars_map;\n   htab_t new_label_map;\n   bool remap_decls_p;\n };\n@@ -5289,9 +5366,11 @@ move_stmt_r (tree *tp, int *walk_subtrees, void *data)\n \n       p->remap_decls_p = save_remap_decls_p;\n     }\n-  else if (DECL_P (t) && DECL_CONTEXT (t) == p->from_context)\n+  else if (DECL_P (t) || TREE_CODE (t) == SSA_NAME)\n     {\n-      if (TREE_CODE (t) == LABEL_DECL)\n+      if (TREE_CODE (t) == SSA_NAME)\n+\t*tp = replace_ssa_name (t, p->vars_map, p->to_context);\n+      else if (TREE_CODE (t) == LABEL_DECL)\n \t{\n \t  if (p->new_label_map)\n \t    {\n@@ -5306,27 +5385,53 @@ move_stmt_r (tree *tp, int *walk_subtrees, void *data)\n \t}\n       else if (p->remap_decls_p)\n \t{\n-\t  DECL_CONTEXT (t) = p->to_context;\n-\n-\t  if (TREE_CODE (t) == VAR_DECL)\n+\t  /* Replace T with its duplicate.  T should no longer appear in the\n+\t     parent function, so this looks wasteful; however, it may appear\n+\t     in referenced_vars, and more importantly, as virtual operands of\n+\t     statements, and in alias lists of other variables.  It would be\n+\t     quite difficult to expunge it from all those places.  ??? It might\n+\t     suffice to do this for addressable variables.  */\n+\t  if ((TREE_CODE (t) == VAR_DECL\n+\t       && !is_global_var (t))\n+\t      || TREE_CODE (t) == CONST_DECL)\n+\t    replace_by_duplicate_decl (tp, p->vars_map, p->to_context);\n+\t  \n+\t  if (SSA_VAR_P (t)\n+\t      && gimple_in_ssa_p (cfun))\n \t    {\n-\t      struct function *f = DECL_STRUCT_FUNCTION (p->to_context);\n-\t      f->unexpanded_var_list\n-\t\t= tree_cons (0, t, f->unexpanded_var_list);\n-\n-\t      /* Mark T to be removed from the original function,\n-\t         otherwise it will be given a DECL_RTL when the\n-\t\t original function is expanded.  */\n-\t      bitmap_set_bit (p->vars_to_remove, DECL_UID (t));\n+\t      push_cfun (DECL_STRUCT_FUNCTION (p->to_context));\n+\t      add_referenced_var (*tp);\n+\t      pop_cfun ();\n \t    }\n \t}\n+      *walk_subtrees = 0;\n     }\n   else if (TYPE_P (t))\n     *walk_subtrees = 0;\n \n   return NULL_TREE;\n }\n \n+/* Marks virtual operands of all statements in basic blocks BBS for\n+   renaming.  */\n+\n+static void\n+mark_virtual_ops_in_region (VEC (basic_block,heap) *bbs)\n+{\n+  tree phi;\n+  block_stmt_iterator bsi;\n+  basic_block bb;\n+  unsigned i;\n+\n+  for (i = 0; VEC_iterate (basic_block, bbs, i, bb); i++)\n+    {\n+      for (phi = phi_nodes (bb); phi; phi = PHI_CHAIN (phi))\n+\tmark_virtual_ops_for_renaming (phi);\n+\n+      for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n+\tmark_virtual_ops_for_renaming (bsi_stmt (bsi));\n+    }\n+}\n \n /* Move basic block BB from function CFUN to function DEST_FN.  The\n    block is moved out of the original linked list and placed after\n@@ -5335,20 +5440,22 @@ move_stmt_r (tree *tp, int *walk_subtrees, void *data)\n    If UPDATE_EDGE_COUNT_P is true, the edge counts on both CFGs is\n    updated to reflect the moved edges.\n \n-   On exit, local variables that need to be removed from\n-   CFUN->UNEXPANDED_VAR_LIST will have been added to VARS_TO_REMOVE.  */\n+   The local variables are remapped to new instances, VARS_MAP is used\n+   to record the mapping.  */\n \n static void\n move_block_to_fn (struct function *dest_cfun, basic_block bb,\n \t\t  basic_block after, bool update_edge_count_p,\n-\t\t  bitmap vars_to_remove, htab_t new_label_map, int eh_offset)\n+\t\t  struct pointer_map_t *vars_map, htab_t new_label_map,\n+\t\t  int eh_offset)\n {\n   struct control_flow_graph *cfg;\n   edge_iterator ei;\n   edge e;\n   block_stmt_iterator si;\n   struct move_stmt_d d;\n   unsigned old_len, new_len;\n+  tree phi;\n \n   /* Remove BB from dominance structures.  */\n   delete_from_dominance_info (CDI_DOMINATORS, bb);\n@@ -5385,20 +5492,39 @@ move_block_to_fn (struct function *dest_cfun, basic_block bb,\n   VEC_replace (basic_block, cfg->x_basic_block_info,\n                bb->index, bb);\n \n+  /* Remap the variables in phi nodes.  */\n+  for (phi = phi_nodes (bb); phi; phi = PHI_CHAIN (phi))\n+    {\n+      use_operand_p use;\n+      tree op = PHI_RESULT (phi);\n+      ssa_op_iter oi;\n+\n+      if (!is_gimple_reg (op))\n+\tcontinue;\n+\n+      SET_PHI_RESULT (phi, replace_ssa_name (op, vars_map, dest_cfun->decl));\n+      FOR_EACH_PHI_ARG (use, phi, oi, SSA_OP_USE)\n+\t{\n+\t  op = USE_FROM_PTR (use);\n+\t  if (TREE_CODE (op) == SSA_NAME)\n+\t    SET_USE (use, replace_ssa_name (op, vars_map, dest_cfun->decl));\n+\t}\n+    }\n+\n   /* The statements in BB need to be associated with a new TREE_BLOCK.\n      Labels need to be associated with a new label-to-block map.  */\n   memset (&d, 0, sizeof (d));\n-  d.vars_to_remove = vars_to_remove;\n+  d.vars_map = vars_map;\n+  d.from_context = cfun->decl;\n+  d.to_context = dest_cfun->decl;\n+  d.new_label_map = new_label_map;\n \n   for (si = bsi_start (bb); !bsi_end_p (si); bsi_next (&si))\n     {\n       tree stmt = bsi_stmt (si);\n       int region;\n \n-      d.from_context = cfun->decl;\n-      d.to_context = dest_cfun->decl;\n       d.remap_decls_p = true;\n-      d.new_label_map = new_label_map;\n       if (TREE_BLOCK (stmt))\n \td.block = DECL_INITIAL (dest_cfun->decl);\n \n@@ -5441,6 +5567,8 @@ move_block_to_fn (struct function *dest_cfun, basic_block bb,\n \t  gimple_duplicate_stmt_histograms (dest_cfun, stmt, cfun, stmt);\n           gimple_remove_stmt_histograms (cfun, stmt);\n \t}\n+\n+      update_stmt (stmt);\n     }\n }\n \n@@ -5518,42 +5646,48 @@ basic_block\n move_sese_region_to_fn (struct function *dest_cfun, basic_block entry_bb,\n \t\t        basic_block exit_bb)\n {\n-  VEC(basic_block,heap) *bbs;\n-  basic_block after, bb, *entry_pred, *exit_succ;\n-  struct function *saved_cfun;\n+  VEC(basic_block,heap) *bbs, *dom_bbs;\n+  basic_block dom_entry = get_immediate_dominator (CDI_DOMINATORS, entry_bb);\n+  basic_block after, bb, *entry_pred, *exit_succ, abb;\n+  struct function *saved_cfun = cfun;\n   int *entry_flag, *exit_flag, eh_offset;\n+  unsigned *entry_prob, *exit_prob;\n   unsigned i, num_entry_edges, num_exit_edges;\n   edge e;\n   edge_iterator ei;\n-  bitmap vars_to_remove;\n   htab_t new_label_map;\n-\n-  saved_cfun = cfun;\n-\n-  /* Collect all the blocks in the region.  Manually add ENTRY_BB\n-     because it won't be added by dfs_enumerate_from.  */\n-  calculate_dominance_info (CDI_DOMINATORS);\n+  struct pointer_map_t *vars_map;\n \n   /* If ENTRY does not strictly dominate EXIT, this cannot be an SESE\n      region.  */\n   gcc_assert (entry_bb != exit_bb\n               && (!exit_bb\n \t\t  || dominated_by_p (CDI_DOMINATORS, exit_bb, entry_bb)));\n \n+  /* Collect all the blocks in the region.  Manually add ENTRY_BB\n+     because it won't be added by dfs_enumerate_from.  */\n   bbs = NULL;\n   VEC_safe_push (basic_block, heap, bbs, entry_bb);\n   gather_blocks_in_sese_region (entry_bb, exit_bb, &bbs);\n \n+  /* The blocks that used to be dominated by something in BBS will now be\n+     dominated by the new block.  */\n+  dom_bbs = get_dominated_by_region (CDI_DOMINATORS,\n+\t\t\t\t     VEC_address (basic_block, bbs),\n+\t\t\t\t     VEC_length (basic_block, bbs));\n+\n   /* Detach ENTRY_BB and EXIT_BB from CFUN->CFG.  We need to remember\n      the predecessor edges to ENTRY_BB and the successor edges to\n      EXIT_BB so that we can re-attach them to the new basic block that\n      will replace the region.  */\n   num_entry_edges = EDGE_COUNT (entry_bb->preds);\n   entry_pred = (basic_block *) xcalloc (num_entry_edges, sizeof (basic_block));\n   entry_flag = (int *) xcalloc (num_entry_edges, sizeof (int));\n+  entry_prob = XNEWVEC (unsigned, num_entry_edges);\n   i = 0;\n   for (ei = ei_start (entry_bb->preds); (e = ei_safe_edge (ei)) != NULL;)\n     {\n+      entry_prob[i] = e->probability;\n       entry_flag[i] = e->flags;\n       entry_pred[i++] = e->src;\n       remove_edge (e);\n@@ -5565,9 +5699,11 @@ move_sese_region_to_fn (struct function *dest_cfun, basic_block entry_bb,\n       exit_succ = (basic_block *) xcalloc (num_exit_edges,\n \t\t\t\t\t   sizeof (basic_block));\n       exit_flag = (int *) xcalloc (num_exit_edges, sizeof (int));\n+      exit_prob = XNEWVEC (unsigned, num_exit_edges);\n       i = 0;\n       for (ei = ei_start (exit_bb->succs); (e = ei_safe_edge (ei)) != NULL;)\n \t{\n+\t  exit_prob[i] = e->probability;\n \t  exit_flag[i] = e->flags;\n \t  exit_succ[i++] = e->dest;\n \t  remove_edge (e);\n@@ -5578,11 +5714,12 @@ move_sese_region_to_fn (struct function *dest_cfun, basic_block entry_bb,\n       num_exit_edges = 0;\n       exit_succ = NULL;\n       exit_flag = NULL;\n+      exit_prob = NULL;\n     }\n \n   /* Switch context to the child function to initialize DEST_FN's CFG.  */\n   gcc_assert (dest_cfun->cfg == NULL);\n-  set_cfun (dest_cfun);\n+  push_cfun (dest_cfun);\n \n   init_empty_tree_cfg ();\n \n@@ -5605,46 +5742,30 @@ move_sese_region_to_fn (struct function *dest_cfun, basic_block entry_bb,\n \t}\n     }\n \n-  set_cfun (saved_cfun);\n+  pop_cfun ();\n+\n+  /* The ssa form for virtual operands in the source function will have to\n+     be repaired.  We do not care for the real operands -- the sese region\n+     must be closed with respect to those.  */\n+  mark_virtual_ops_in_region (bbs);\n \n   /* Move blocks from BBS into DEST_CFUN.  */\n   gcc_assert (VEC_length (basic_block, bbs) >= 2);\n   after = dest_cfun->cfg->x_entry_block_ptr;\n-  vars_to_remove = BITMAP_ALLOC (NULL);\n+  vars_map = pointer_map_create ();\n   for (i = 0; VEC_iterate (basic_block, bbs, i, bb); i++)\n     {\n       /* No need to update edge counts on the last block.  It has\n \t already been updated earlier when we detached the region from\n \t the original CFG.  */\n-      move_block_to_fn (dest_cfun, bb, after, bb != exit_bb, vars_to_remove,\n+      move_block_to_fn (dest_cfun, bb, after, bb != exit_bb, vars_map,\n \t                new_label_map, eh_offset);\n       after = bb;\n     }\n \n   if (new_label_map)\n     htab_delete (new_label_map);\n-\n-  /* Remove the variables marked in VARS_TO_REMOVE from\n-     CFUN->UNEXPANDED_VAR_LIST.  Otherwise, they will be given a\n-     DECL_RTL in the context of CFUN.  */\n-  if (!bitmap_empty_p (vars_to_remove))\n-    {\n-      tree *p;\n-\n-      for (p = &cfun->unexpanded_var_list; *p; )\n-\t{\n-\t  tree var = TREE_VALUE (*p);\n-\t  if (bitmap_bit_p (vars_to_remove, DECL_UID (var)))\n-\t    {\n-\t      *p = TREE_CHAIN (*p);\n-\t      continue;\n-\t    }\n-\n-\t  p = &TREE_CHAIN (*p);\n-\t}\n-    }\n-\n-  BITMAP_FREE (vars_to_remove);\n+  pointer_map_destroy (vars_map);\n \n   /* Rewire the entry and exit blocks.  The successor to the entry\n      block turns into the successor of DEST_FN's ENTRY_BLOCK_PTR in\n@@ -5655,30 +5776,41 @@ move_sese_region_to_fn (struct function *dest_cfun, basic_block entry_bb,\n \n      FIXME, this is silly.  The CFG ought to become a parameter to\n      these helpers.  */\n-  set_cfun (dest_cfun);\n+  push_cfun (dest_cfun);\n   make_edge (ENTRY_BLOCK_PTR, entry_bb, EDGE_FALLTHRU);\n   if (exit_bb)\n     make_edge (exit_bb,  EXIT_BLOCK_PTR, 0);\n-  set_cfun (saved_cfun);\n+  pop_cfun ();\n \n   /* Back in the original function, the SESE region has disappeared,\n      create a new basic block in its place.  */\n   bb = create_empty_bb (entry_pred[0]);\n   for (i = 0; i < num_entry_edges; i++)\n-    make_edge (entry_pred[i], bb, entry_flag[i]);\n+    {\n+      e = make_edge (entry_pred[i], bb, entry_flag[i]);\n+      e->probability = entry_prob[i];\n+    }\n \n   for (i = 0; i < num_exit_edges; i++)\n-    make_edge (bb, exit_succ[i], exit_flag[i]);\n+    {\n+      e = make_edge (bb, exit_succ[i], exit_flag[i]);\n+      e->probability = exit_prob[i];\n+    }\n+\n+  set_immediate_dominator (CDI_DOMINATORS, bb, dom_entry);\n+  for (i = 0; VEC_iterate (basic_block, dom_bbs, i, abb); i++)\n+    set_immediate_dominator (CDI_DOMINATORS, abb, bb);\n+  VEC_free (basic_block, heap, dom_bbs);\n \n   if (exit_bb)\n     {\n+      free (exit_prob);\n       free (exit_flag);\n       free (exit_succ);\n     }\n+  free (entry_prob);\n   free (entry_flag);\n   free (entry_pred);\n-  free_dominance_info (CDI_DOMINATORS);\n-  free_dominance_info (CDI_POST_DOMINATORS);\n   VEC_free (basic_block, heap, bbs);\n \n   return bb;"}, {"sha": "83956a1a355c2f111fa35655c8132699ed863820", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/917948d364025c5cc418cd6486dc75b43fa12015/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/917948d364025c5cc418cd6486dc75b43fa12015/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=917948d364025c5cc418cd6486dc75b43fa12015", "patch": "@@ -711,6 +711,8 @@ extern struct omp_region *root_omp_region;\n extern struct omp_region *new_omp_region (basic_block, enum tree_code,\n \t\t\t\t\t  struct omp_region *);\n extern void free_omp_regions (void);\n+extern tree find_omp_clause (tree, enum tree_code);\n+tree copy_var_decl (tree, tree, tree);\n \n /*---------------------------------------------------------------------------\n \t\t\t      Function prototypes"}, {"sha": "a7de71700b274458e41aa52e1cafb6fa5822ed14", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/917948d364025c5cc418cd6486dc75b43fa12015/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/917948d364025c5cc418cd6486dc75b43fa12015/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=917948d364025c5cc418cd6486dc75b43fa12015", "patch": "@@ -290,6 +290,7 @@ extern struct tree_opt_pass pass_lower_vector;\n extern struct tree_opt_pass pass_lower_vector_ssa;\n extern struct tree_opt_pass pass_lower_omp;\n extern struct tree_opt_pass pass_expand_omp;\n+extern struct tree_opt_pass pass_expand_omp_ssa;\n extern struct tree_opt_pass pass_object_sizes;\n extern struct tree_opt_pass pass_fold_builtins;\n extern struct tree_opt_pass pass_stdarg;"}, {"sha": "6fa80ee61337e913eaae4c4fe8ad5ba1db2e1429", "filename": "gcc/tree-predcom.c", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/917948d364025c5cc418cd6486dc75b43fa12015/gcc%2Ftree-predcom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/917948d364025c5cc418cd6486dc75b43fa12015/gcc%2Ftree-predcom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-predcom.c?ref=917948d364025c5cc418cd6486dc75b43fa12015", "patch": "@@ -1393,7 +1393,16 @@ mark_virtual_ops_for_renaming (tree stmt)\n   tree var;\n \n   if (TREE_CODE (stmt) == PHI_NODE)\n-    return;\n+    {\n+      var = PHI_RESULT (stmt);\n+      if (is_gimple_reg (var))\n+\treturn;\n+\n+      if (TREE_CODE (var) == SSA_NAME)\n+\tvar = SSA_NAME_VAR (var);\n+      mark_sym_for_renaming (var);\n+      return;\n+    }\n \n   update_stmt (stmt);\n "}, {"sha": "c18f97d4960dc02a5724d94a8d7cfbf556579e1d", "filename": "gcc/tree-ssa-operands.c", "status": "modified", "additions": 55, "deletions": 4, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/917948d364025c5cc418cd6486dc75b43fa12015/gcc%2Ftree-ssa-operands.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/917948d364025c5cc418cd6486dc75b43fa12015/gcc%2Ftree-ssa-operands.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-operands.c?ref=917948d364025c5cc418cd6486dc75b43fa12015", "patch": "@@ -2247,21 +2247,72 @@ get_expr_operands (tree stmt, tree *expr_p, int flags)\n       get_expr_operands (stmt, &CHANGE_DYNAMIC_TYPE_LOCATION (expr), opf_use);\n       return;\n \n+    case OMP_FOR:\n+      {\n+\ttree init = OMP_FOR_INIT (expr);\n+\ttree cond = OMP_FOR_COND (expr);\n+\ttree incr = OMP_FOR_INCR (expr);\n+\ttree c, clauses = OMP_FOR_CLAUSES (stmt);\n+\n+\tget_expr_operands (stmt, &GIMPLE_STMT_OPERAND (init, 0), opf_def);\n+\tget_expr_operands (stmt, &GIMPLE_STMT_OPERAND (init, 1), opf_use);\n+\tget_expr_operands (stmt, &TREE_OPERAND (cond, 1), opf_use);\n+\tget_expr_operands (stmt, &TREE_OPERAND (GIMPLE_STMT_OPERAND (incr, 1), 1),\n+\t\t\t   opf_use);\n+\n+\tc = find_omp_clause (clauses, OMP_CLAUSE_SCHEDULE);\n+\tif (c)\n+\t  get_expr_operands (stmt, &OMP_CLAUSE_SCHEDULE_CHUNK_EXPR (c),\n+\t\t\t     opf_use);\n+\treturn;\n+      }\n+\n+    case OMP_CONTINUE:\n+      {\n+\tget_expr_operands (stmt, &TREE_OPERAND (expr, 0), opf_def);\n+\tget_expr_operands (stmt, &TREE_OPERAND (expr, 1), opf_use);\n+\treturn;\n+      }\n+\n+    case OMP_PARALLEL:\n+      {\n+\ttree c, clauses = OMP_PARALLEL_CLAUSES (stmt);\n+\n+\tif (OMP_PARALLEL_DATA_ARG (stmt))\n+\t  {\n+\t    get_expr_operands (stmt, &OMP_PARALLEL_DATA_ARG (stmt), opf_use);\n+\t    add_to_addressable_set (OMP_PARALLEL_DATA_ARG (stmt),\n+\t\t\t\t    &s_ann->addresses_taken);\n+\t  }\n+\n+\tc = find_omp_clause (clauses, OMP_CLAUSE_IF);\n+\tif (c)\n+\t  get_expr_operands (stmt, &OMP_CLAUSE_IF_EXPR (c), opf_use);\n+\tc = find_omp_clause (clauses, OMP_CLAUSE_NUM_THREADS);\n+\tif (c)\n+\t  get_expr_operands (stmt, &OMP_CLAUSE_NUM_THREADS_EXPR (c), opf_use);\n+\treturn;\n+      }\n+\n+    case OMP_SECTIONS:\n+      {\n+\tget_expr_operands (stmt, &OMP_SECTIONS_CONTROL (expr), opf_def);\n+\treturn;\n+      }\n+\n     case BLOCK:\n     case FUNCTION_DECL:\n     case EXC_PTR_EXPR:\n     case FILTER_EXPR:\n     case LABEL_DECL:\n     case CONST_DECL:\n-    case OMP_PARALLEL:\n-    case OMP_SECTIONS:\n-    case OMP_FOR:\n     case OMP_SINGLE:\n     case OMP_MASTER:\n     case OMP_ORDERED:\n     case OMP_CRITICAL:\n     case OMP_RETURN:\n-    case OMP_CONTINUE:\n+    case OMP_SECTION:\n+    case OMP_SECTIONS_SWITCH:\n       /* Expressions that make no memory references.  */\n       return;\n "}]}