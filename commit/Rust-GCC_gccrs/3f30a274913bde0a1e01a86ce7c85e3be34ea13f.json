{"sha": "3f30a274913bde0a1e01a86ce7c85e3be34ea13f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2YzMGEyNzQ5MTNiZGUwYTFlMDFhODZjZTdjODVlM2JlMzRlYTEzZg==", "commit": {"author": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2020-05-14T21:43:17Z"}, "committer": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2020-05-14T21:43:17Z"}, "message": "libiberty: Update D symbol demangling for latest ABI spec.\n\nSome small improvements and clarifications have been done in the D ABI\nspecification to remove all ambiguities found in the current grammar,\nthis implementation now more closely resembles the spec, whilst\nmaintaining compatibility with the old ABI.\n\nThree new rules have been added to the ABI.\n\n1. Back references using 'Q', analogous to C++ substitutions, compresses\n   repeated identifiers, types, and template symbol and value parameters.\n\n2. Template aliases to externally mangled symbols are prefixed with 'X'.\n   This includes any symbol that isn't extern(D), or has its name\n   overriden with pragma(mangle).  This fixes an ambiguity where it was\n   not clear whether 'V' was an encoded calling convention, or the next\n   template value parameter.\n\n3. Alias parameters, templates, and tuple symbols no longer encode the\n   symbol length of its subpart.  Tuples are now terminated with 'Z'.\n   This fixes another ambiguity where the first character of the mangled\n   name can be a digit as well, so the demangler had to figure out where\n   to split the two adjacent numbers by trying out each combination.\n\nlibiberty/ChangeLog:\n\n\t* d-demangle.c (enum dlang_symbol_kinds): Remove enum.\n\t(struct dlang_info): New struct\n\t(dlang_decode_backref): New function.\n\t(dlang_backref): New function.\n\t(dlang_symbol_backref): New function.\n\t(dlang_type_backref): New function.\n\t(dlang_symbol_name_p): New function.\n\t(dlang_function_type_noreturn): New function.\n\t(dlang_function_type): Add 'info' parameter.  Decode function type\n\twith dlang_function_type_noreturn.\n\t(dlang_function_args): Add 'info' parameter.\n\t(dlang_type): Add 'info' parameter.  Handle back referenced types.\n\t(dlang_identifier): Replace 'kind' parameter with 'info'.  Handle back\n\treferenced symbols.  Split off decoding of plain identifiers to...\n\t(dlang_lname): ...here.\n\t(dlang_parse_mangle): Replace 'kind' parameter with 'info'.  Decode\n\tfunction type and return with dlang_type.\n\t(dlang_parse_qualified): Replace 'kind' parameter with 'info', add\n\t'suffix_modifier' parameter.  Decode function type with\n\tdlang_function_type_noreturn.\n\t(dlang_parse_tuple): Add 'info' parameter.\n\t(dlang_template_symbol_param): New function.\n\t(dlang_template_args): Add 'info' parameter.  Decode symbol parameter\n\twith dlang_template_symbol_param.  Handle back referenced values, and\n\texternally mangled parameters.\n\t(dlang_parse_template): Add 'info' parameter.\n\t(dlang_demangle_init_info): New function.\n\t(dlang_demangle): Initialize and pass 'info' parameter.\n\t* testsuite/d-demangle-expected: Add new tests.\n\nCo-Authored-By: Rainer Schuetze <r.sagitario@gmx.de>", "tree": {"sha": "2ddcc91e573775d13f0ab3096aaa2eaa46288205", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2ddcc91e573775d13f0ab3096aaa2eaa46288205"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3f30a274913bde0a1e01a86ce7c85e3be34ea13f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f30a274913bde0a1e01a86ce7c85e3be34ea13f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3f30a274913bde0a1e01a86ce7c85e3be34ea13f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f30a274913bde0a1e01a86ce7c85e3be34ea13f/comments", "author": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4e1592f8e1d6366699e05c0824fc3dc39ca7314b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e1592f8e1d6366699e05c0824fc3dc39ca7314b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4e1592f8e1d6366699e05c0824fc3dc39ca7314b"}], "stats": {"total": 874, "additions": 613, "deletions": 261}, "files": [{"sha": "74c515b4b90f6626a33b74cb83e70a988d54f21b", "filename": "libiberty/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f30a274913bde0a1e01a86ce7c85e3be34ea13f/libiberty%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f30a274913bde0a1e01a86ce7c85e3be34ea13f/libiberty%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FChangeLog?ref=3f30a274913bde0a1e01a86ce7c85e3be34ea13f", "patch": "@@ -1,3 +1,36 @@\n+2020-05-14  Rainer Schuetze  <r.sagitario@gmx.de>\n+\t    Iain Buclaw  <ibuclaw@gdcproject.org>\n+\n+\t* d-demangle.c (enum dlang_symbol_kinds): Remove enum.\n+\t(struct dlang_info): New struct\n+\t(dlang_decode_backref): New function.\n+\t(dlang_backref): New function.\n+\t(dlang_symbol_backref): New function.\n+\t(dlang_type_backref): New function.\n+\t(dlang_symbol_name_p): New function.\n+\t(dlang_function_type_noreturn): New function.\n+\t(dlang_function_type): Add 'info' parameter.  Decode function type\n+\twith dlang_function_type_noreturn.\n+\t(dlang_function_args): Add 'info' parameter.\n+\t(dlang_type): Add 'info' parameter.  Handle back referenced types.\n+\t(dlang_identifier): Replace 'kind' parameter with 'info'.  Handle back\n+\treferenced symbols.  Split off decoding of plain identifiers to...\n+\t(dlang_lname): ...here.\n+\t(dlang_parse_mangle): Replace 'kind' parameter with 'info'.  Decode\n+\tfunction type and return with dlang_type.\n+\t(dlang_parse_qualified): Replace 'kind' parameter with 'info', add\n+\t'suffix_modifier' parameter.  Decode function type with\n+\tdlang_function_type_noreturn.\n+\t(dlang_parse_tuple): Add 'info' parameter.\n+\t(dlang_template_symbol_param): New function.\n+\t(dlang_template_args): Add 'info' parameter.  Decode symbol parameter\n+\twith dlang_template_symbol_param.  Handle back referenced values, and\n+\texternally mangled parameters.\n+\t(dlang_parse_template): Add 'info' parameter.\n+\t(dlang_demangle_init_info): New function.\n+\t(dlang_demangle): Initialize and pass 'info' parameter.\n+\t* testsuite/d-demangle-expected: Add new tests.\n+\n 2020-05-12  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR bootstrap/94998"}, {"sha": "5856bc2930f2dc583144833b8ca43c82d6f650d2", "filename": "libiberty/d-demangle.c", "status": "modified", "additions": 508, "deletions": 261, "changes": 769, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f30a274913bde0a1e01a86ce7c85e3be34ea13f/libiberty%2Fd-demangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f30a274913bde0a1e01a86ce7c85e3be34ea13f/libiberty%2Fd-demangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fd-demangle.c?ref=3f30a274913bde0a1e01a86ce7c85e3be34ea13f", "patch": "@@ -160,37 +160,42 @@ string_prepend (string *p, const char *s)\n     }\n }\n \n-/* What kinds of symbol we could be parsing.  */\n-enum dlang_symbol_kinds\n+/* Demangle information structure we pass around.  */\n+struct dlang_info\n {\n-  /* Top-level symbol, needs it's type checked.  */\n-  dlang_top_level,\n-  /* Function symbol, needs it's type checked.   */\n-  dlang_function,\n-  /* Strongly typed name, such as for classes, structs and enums.  */\n-  dlang_type_name,\n-  /* Template identifier.  */\n-  dlang_template_ident,\n-  /* Template symbol parameter.  */\n-  dlang_template_param\n+  /* The string we are demangling.  */\n+  const char *s;\n+  /* The index of the last back reference.  */\n+  int last_backref;\n };\n \n+/* Pass as the LEN to dlang_parse_template if symbol length is not known.  */\n+enum { TEMPLATE_LENGTH_UNKNOWN = -1 };\n+\n /* Prototypes for forward referenced functions */\n-static const char *dlang_function_args (string *, const char *);\n+static const char *dlang_function_type (string *, const char *,\n+\t\t\t\t\tstruct dlang_info *);\n \n-static const char *dlang_type (string *, const char *);\n+static const char *dlang_function_args (string *, const char *,\n+\t\t\t\t\tstruct dlang_info *);\n+\n+static const char *dlang_type (string *, const char *, struct dlang_info *);\n \n static const char *dlang_value (string *, const char *, const char *, char);\n \n static const char *dlang_parse_qualified (string *, const char *,\n-\t\t\t\t\t  enum dlang_symbol_kinds);\n+\t\t\t\t\t  struct dlang_info *, int);\n \n static const char *dlang_parse_mangle (string *, const char *,\n-\t\t\t\t       enum dlang_symbol_kinds);\n+\t\t\t\t       struct dlang_info *);\n+\n+static const char *dlang_parse_tuple (string *, const char *,\n+\t\t\t\t      struct dlang_info *);\n \n-static const char *dlang_parse_tuple (string *, const char *);\n+static const char *dlang_parse_template (string *, const char *,\n+\t\t\t\t\t struct dlang_info *, long);\n \n-static const char *dlang_parse_template (string *, const char *, long);\n+static const char *dlang_lname (string *, const char *, long);\n \n \n /* Extract the number from MANGLED, and assign the result to RET.\n@@ -267,6 +272,175 @@ dlang_call_convention_p (const char *mangled)\n     }\n }\n \n+/* Extract the back reference position from MANGLED, and assign the result\n+   to RET.  Return the remaining string on success or NULL on failure.  */\n+static const char *\n+dlang_decode_backref (const char *mangled, long *ret)\n+{\n+  /* Return NULL if trying to extract something that isn't a digit.  */\n+  if (mangled == NULL || !ISALPHA (*mangled))\n+    return NULL;\n+\n+  /* Any identifier or non-basic type that has been emitted to the mangled\n+     symbol before will not be emitted again, but is referenced by a special\n+     sequence encoding the relative position of the original occurrence in the\n+     mangled symbol name.\n+\n+     Numbers in back references are encoded with base 26 by upper case letters\n+     A-Z for higher digits but lower case letters a-z for the last digit.\n+\n+\tNumberBackRef:\n+\t    [a-z]\n+\t    [A-Z] NumberBackRef\n+\t    ^\n+   */\n+  (*ret) = 0;\n+\n+  while (ISALPHA (*mangled))\n+    {\n+      (*ret) *= 26;\n+\n+      /* If an overflow occured when multiplying by 26, the result\n+\t will not be a multiple of 26.  */\n+      if ((*ret % 26) != 0)\n+\treturn NULL;\n+\n+      if (mangled[0] >= 'a' && mangled[0] <= 'z')\n+\t{\n+\t  (*ret) += mangled[0] - 'a';\n+\t  return mangled + 1;\n+\t}\n+\n+      (*ret) += mangled[0] - 'A';\n+      mangled++;\n+    }\n+\n+  return NULL;\n+}\n+\n+/* Extract the symbol pointed at by the back reference and assign the result\n+   to RET.  Return the remaining string on success or NULL on failure.  */\n+static const char *\n+dlang_backref (const char *mangled, const char **ret, struct dlang_info *info)\n+{\n+  (*ret) = NULL;\n+\n+  if (mangled == NULL || *mangled != 'Q')\n+    return NULL;\n+\n+  /* Position of 'Q'.  */\n+  const char *qpos = mangled;\n+  long refpos;\n+  mangled++;\n+\n+  mangled = dlang_decode_backref (mangled, &refpos);\n+  if (mangled == NULL)\n+    return NULL;\n+\n+  if (refpos <= 0 || refpos > qpos - info->s)\n+    return NULL;\n+\n+  /* Set the position of the back reference.  */\n+  (*ret) = qpos - refpos;\n+\n+  return mangled;\n+}\n+\n+/* Demangle a back referenced symbol from MANGLED and append it to DECL.\n+   Return the remaining string on success or NULL on failure.  */\n+static const char *\n+dlang_symbol_backref (string *decl, const char *mangled,\n+\t\t      struct dlang_info *info)\n+{\n+  /* An identifier back reference always points to a digit 0 to 9.\n+\n+\tIdentifierBackRef:\n+\t    Q NumberBackRef\n+\t    ^\n+   */\n+  const char *backref;\n+  long len;\n+\n+  /* Get position of the back reference.  */\n+  mangled = dlang_backref (mangled, &backref, info);\n+\n+  /* Must point to a simple identifier.  */\n+  backref = dlang_number (backref, &len);\n+  if (backref == NULL)\n+    return NULL;\n+\n+  backref = dlang_lname (decl, backref, len);\n+  if (backref == NULL)\n+    return NULL;\n+\n+  return mangled;\n+}\n+\n+/* Demangle a back referenced type from MANGLED and append it to DECL.\n+   IS_FUNCTION is 1 if the back referenced type is expected to be a function.\n+   Return the remaining string on success or NULL on failure.  */\n+static const char *\n+dlang_type_backref (string *decl, const char *mangled, struct dlang_info *info,\n+\t\t    int is_function)\n+{\n+  /* A type back reference always points to a letter.\n+\n+\tTypeBackRef:\n+\t    Q NumberBackRef\n+\t    ^\n+   */\n+  const char *backref;\n+\n+  /* If we appear to be moving backwards through the mangle string, then\n+     bail as this may be a recursive back reference.  */\n+  if (mangled - info->s >= info->last_backref)\n+    return NULL;\n+\n+  int save_refpos = info->last_backref;\n+  info->last_backref = mangled - info->s;\n+\n+  /* Get position of the back reference.  */\n+  mangled = dlang_backref (mangled, &backref, info);\n+\n+  /* Must point to a type.  */\n+  if (is_function)\n+    backref = dlang_function_type (decl, backref, info);\n+  else\n+    backref = dlang_type (decl, backref, info);\n+\n+  info->last_backref = save_refpos;\n+\n+  if (backref == NULL)\n+    return NULL;\n+\n+  return mangled;\n+}\n+\n+/* Extract the beginning of a symbol name from MANGLED and\n+   return 1 on success or 0 on failure.  */\n+static int\n+dlang_symbol_name_p (const char *mangled, struct dlang_info *info)\n+{\n+  long ret;\n+  const char *qref = mangled;\n+\n+  if (ISDIGIT (*mangled))\n+    return 1;\n+\n+  if (mangled[0] == '_' && mangled[1] == '_'\n+      && (mangled[2] == 'T' || mangled[2] == 'U'))\n+    return 1;\n+\n+  if (*mangled != 'Q')\n+    return 0;\n+\n+  mangled = dlang_decode_backref (mangled + 1, &ret);\n+  if (mangled == NULL || ret <= 0 || ret > qref - info->s)\n+    return 0;\n+\n+  return ISDIGIT (qref[-ret]);\n+}\n+\n /* Demangle the calling convention from MANGLED and append it to DECL.\n    Return the remaining string on success or NULL on failure.  */\n static const char *\n@@ -414,13 +588,39 @@ dlang_attributes (string *decl, const char *mangled)\n   return mangled;\n }\n \n+/* Demangle the function type from MANGLED without the return type.\n+   The arguments are appended to ARGS, the calling convention is appended\n+   to CALL and attributes are appended to ATTR.  Any of these can be NULL\n+   to throw the information away.  Return the remaining string on success\n+   or NULL on failure.  */\n+static const char *\n+dlang_function_type_noreturn (string *args, string *call, string *attr,\n+\t\t\t      const char *mangled, struct dlang_info *info)\n+{\n+  string dump;\n+  string_init (&dump);\n+\n+  /* Skip over calling convention and attributes.  */\n+  mangled = dlang_call_convention (call ? call : &dump, mangled);\n+  mangled = dlang_attributes (attr ? attr : &dump, mangled);\n+\n+  if (args)\n+    string_append (args, \"(\");\n+\n+  mangled = dlang_function_args (args ? args : &dump, mangled, info);\n+  if (args)\n+    string_append (args, \")\");\n+\n+  string_delete (&dump);\n+  return mangled;\n+}\n+\n /* Demangle the function type from MANGLED and append it to DECL.\n    Return the remaining string on success or NULL on failure.  */\n static const char *\n-dlang_function_type (string *decl, const char *mangled)\n+dlang_function_type (string *decl, const char *mangled, struct dlang_info *info)\n {\n   string attr, args, type;\n-  size_t szattr, szargs, sztype;\n \n   if (mangled == NULL || *mangled == '\\0')\n     return NULL;\n@@ -435,27 +635,16 @@ dlang_function_type (string *decl, const char *mangled)\n   string_init (&args);\n   string_init (&type);\n \n-  /* Function call convention.  */\n-  mangled = dlang_call_convention (decl, mangled);\n-\n-  /* Function attributes.  */\n-  mangled = dlang_attributes (&attr, mangled);\n-  szattr = string_length (&attr);\n-\n-  /* Function arguments.  */\n-  mangled = dlang_function_args (&args, mangled);\n-  szargs = string_length (&args);\n+  mangled = dlang_function_type_noreturn (&args, decl, &attr, mangled, info);\n \n   /* Function return type.  */\n-  mangled = dlang_type (&type, mangled);\n-  sztype = string_length (&type);\n+  mangled = dlang_type (&type, mangled, info);\n \n   /* Append to decl in order. */\n-  string_appendn (decl, type.b, sztype);\n-  string_append (decl, \"(\");\n-  string_appendn (decl, args.b, szargs);\n-  string_append (decl, \") \");\n-  string_appendn (decl, attr.b, szattr);\n+  string_appendn (decl, type.b, string_length (&type));\n+  string_appendn (decl, args.b, string_length (&args));\n+  string_append (decl, \" \");\n+  string_appendn (decl, attr.b, string_length (&attr));\n \n   string_delete (&attr);\n   string_delete (&args);\n@@ -466,7 +655,7 @@ dlang_function_type (string *decl, const char *mangled)\n /* Demangle the argument list from MANGLED and append it to DECL.\n    Return the remaining string on success or NULL on failure.  */\n static const char *\n-dlang_function_args (string *decl, const char *mangled)\n+dlang_function_args (string *decl, const char *mangled, struct dlang_info *info)\n {\n   size_t n = 0;\n \n@@ -519,7 +708,7 @@ dlang_function_args (string *decl, const char *mangled)\n \t  string_append (decl, \"lazy \");\n \t  break;\n \t}\n-      mangled = dlang_type (decl, mangled);\n+      mangled = dlang_type (decl, mangled, info);\n     }\n \n   return mangled;\n@@ -528,7 +717,7 @@ dlang_function_args (string *decl, const char *mangled)\n /* Demangle the type from MANGLED and append it to DECL.\n    Return the remaining string on success or NULL on failure.  */\n static const char *\n-dlang_type (string *decl, const char *mangled)\n+dlang_type (string *decl, const char *mangled, struct dlang_info *info)\n {\n   if (mangled == NULL || *mangled == '\\0')\n     return NULL;\n@@ -538,19 +727,19 @@ dlang_type (string *decl, const char *mangled)\n     case 'O': /* shared(T) */\n       mangled++;\n       string_append (decl, \"shared(\");\n-      mangled = dlang_type (decl, mangled);\n+      mangled = dlang_type (decl, mangled, info);\n       string_append (decl, \")\");\n       return mangled;\n     case 'x': /* const(T) */\n       mangled++;\n       string_append (decl, \"const(\");\n-      mangled = dlang_type (decl, mangled);\n+      mangled = dlang_type (decl, mangled, info);\n       string_append (decl, \")\");\n       return mangled;\n     case 'y': /* immutable(T) */\n       mangled++;\n       string_append (decl, \"immutable(\");\n-      mangled = dlang_type (decl, mangled);\n+      mangled = dlang_type (decl, mangled, info);\n       string_append (decl, \")\");\n       return mangled;\n     case 'N':\n@@ -559,23 +748,23 @@ dlang_type (string *decl, const char *mangled)\n \t{\n \t  mangled++;\n \t  string_append (decl, \"inout(\");\n-\t  mangled = dlang_type (decl, mangled);\n+\t  mangled = dlang_type (decl, mangled, info);\n \t  string_append (decl, \")\");\n \t  return mangled;\n \t}\n       else if (*mangled == 'h') /* vector(T) */\n \t{\n \t  mangled++;\n \t  string_append (decl, \"__vector(\");\n-\t  mangled = dlang_type (decl, mangled);\n+\t  mangled = dlang_type (decl, mangled, info);\n \t  string_append (decl, \")\");\n \t  return mangled;\n \t}\n       else\n \treturn NULL;\n     case 'A': /* dynamic array (T[]) */\n       mangled++;\n-      mangled = dlang_type (decl, mangled);\n+      mangled = dlang_type (decl, mangled, info);\n       string_append (decl, \"[]\");\n       return mangled;\n     case 'G': /* static array (T[N]) */\n@@ -590,7 +779,7 @@ dlang_type (string *decl, const char *mangled)\n \t  num++;\n \t  mangled++;\n \t}\n-      mangled = dlang_type (decl, mangled);\n+      mangled = dlang_type (decl, mangled, info);\n       string_append (decl, \"[\");\n       string_appendn (decl, numptr, num);\n       string_append (decl, \"]\");\n@@ -603,10 +792,10 @@ dlang_type (string *decl, const char *mangled)\n       mangled++;\n \n       string_init (&type);\n-      mangled = dlang_type (&type, mangled);\n+      mangled = dlang_type (&type, mangled, info);\n       sztype = string_length (&type);\n \n-      mangled = dlang_type (decl, mangled);\n+      mangled = dlang_type (decl, mangled, info);\n       string_append (decl, \"[\");\n       string_appendn (decl, type.b, sztype);\n       string_append (decl, \"]\");\n@@ -618,7 +807,7 @@ dlang_type (string *decl, const char *mangled)\n       mangled++;\n       if (!dlang_call_convention_p (mangled))\n \t{\n-\t  mangled = dlang_type (decl, mangled);\n+\t  mangled = dlang_type (decl, mangled, info);\n \t  string_append (decl, \"*\");\n \t  return mangled;\n \t}\n@@ -630,7 +819,7 @@ dlang_type (string *decl, const char *mangled)\n     case 'R': /* function T (C++) */\n     case 'Y': /* function T (Objective-C) */\n       /* Function pointer types don't include the trailing asterisk.  */\n-      mangled = dlang_function_type (decl, mangled);\n+      mangled = dlang_function_type (decl, mangled, info);\n       string_append (decl, \"function\");\n       return mangled;\n     case 'I': /* ident T */\n@@ -639,7 +828,7 @@ dlang_type (string *decl, const char *mangled)\n     case 'E': /* enum T */\n     case 'T': /* typedef T */\n       mangled++;\n-      return dlang_parse_qualified (decl, mangled, dlang_type_name);\n+      return dlang_parse_qualified (decl, mangled, info, 0);\n     case 'D': /* delegate T */\n     {\n       string mods;\n@@ -650,7 +839,12 @@ dlang_type (string *decl, const char *mangled)\n       mangled = dlang_type_modifiers (&mods, mangled);\n       szmods = string_length (&mods);\n \n-      mangled = dlang_function_type (decl, mangled);\n+      /* Back referenced function type.  */\n+      if (*mangled == 'Q')\n+\tmangled = dlang_type_backref (decl, mangled, info, 1);\n+      else\n+\tmangled = dlang_function_type (decl, mangled, info);\n+\n       string_append (decl, \"delegate\");\n       string_appendn (decl, mods.b, szmods);\n \n@@ -659,7 +853,7 @@ dlang_type (string *decl, const char *mangled)\n     }\n     case 'B': /* tuple T */\n       mangled++;\n-      return dlang_parse_tuple (decl, mangled);\n+      return dlang_parse_tuple (decl, mangled, info);\n \n     /* Basic types */\n     case 'n':\n@@ -773,6 +967,10 @@ dlang_type (string *decl, const char *mangled)\n \t}\n       return NULL;\n \n+    /* Back referenced type.  */\n+    case 'Q':\n+      return dlang_type_backref (decl, mangled, info, 0);\n+\n     default: /* unhandled */\n       return NULL;\n     }\n@@ -781,152 +979,127 @@ dlang_type (string *decl, const char *mangled)\n /* Extract the identifier from MANGLED and append it to DECL.\n    Return the remaining string on success or NULL on failure.  */\n static const char *\n-dlang_identifier (string *decl, const char *mangled,\n-\t\t  enum dlang_symbol_kinds kind)\n+dlang_identifier (string *decl, const char *mangled, struct dlang_info *info)\n {\n   long len;\n-  const char *endptr = dlang_number (mangled, &len);\n \n-  if (endptr == NULL || len == 0)\n+  if (mangled == NULL || *mangled == '\\0')\n     return NULL;\n \n-  /* In template parameter symbols, the first character of the mangled\n-     name can be a digit.  This causes ambiguity issues because the\n-     digits of the two numbers are adjacent.  */\n-  if (kind == dlang_template_param)\n-    {\n-      long psize = len;\n-      const char *pend;\n-      int saved = string_length (decl);\n-\n-      /* Work backwards until a match is found.  */\n-      for (pend = endptr; endptr != NULL; pend--)\n-\t{\n-\t  mangled = pend;\n+  if (*mangled == 'Q')\n+    return dlang_symbol_backref (decl, mangled, info);\n \n-\t  /* Reached the beginning of the pointer to the name length,\n-\t     try parsing the entire symbol.  */\n-\t  if (psize == 0)\n-\t    {\n-\t      psize = len;\n-\t      pend = endptr;\n-\t      endptr = NULL;\n-\t    }\n+  /* May be a template instance without a length prefix.  */\n+  if (mangled[0] == '_' && mangled[1] == '_'\n+      && (mangled[2] == 'T' || mangled[2] == 'U'))\n+    return dlang_parse_template (decl, mangled, info, TEMPLATE_LENGTH_UNKNOWN);\n \n-\t  /* Check whether template parameter is a function with a valid\n-\t     return type or an untyped identifier.  */\n-\t  if (ISDIGIT (*mangled))\n-\t    mangled = dlang_parse_qualified (decl, mangled,\n-\t\t\t\t\t     dlang_template_ident);\n-\t  else if (strncmp (mangled, \"_D\", 2) == 0)\n-\t    mangled = dlang_parse_mangle (decl, mangled, dlang_function);\n+  const char *endptr = dlang_number (mangled, &len);\n \n-\t  /* Check for name length mismatch.  */\n-\t  if (mangled && (mangled - pend) == psize)\n-\t    return mangled;\n+  if (endptr == NULL || len == 0)\n+    return NULL;\n \n-\t  psize /= 10;\n-\t  string_setlength (decl, saved);\n-\t}\n+  if (strlen (endptr) < (size_t) len)\n+    return NULL;\n \n-      /* No match on any combinations.  */\n-      return NULL;\n-    }\n-  else\n-    {\n-      if (strlen (endptr) < (size_t) len)\n-\treturn NULL;\n+  mangled = endptr;\n \n-      mangled = endptr;\n+  /* May be a template instance with a length prefix.  */\n+  if (len >= 5 && mangled[0] == '_' && mangled[1] == '_'\n+      && (mangled[2] == 'T' || mangled[2] == 'U'))\n+    return dlang_parse_template (decl, mangled, info, len);\n \n-      /* May be a template instance.  */\n-      if (len >= 5 && mangled[0] == '_' && mangled[1] == '_'\n-\t  && (mangled[2] == 'T' || mangled[2] == 'U'))\n-\treturn dlang_parse_template (decl, mangled, len);\n+  return dlang_lname (decl, mangled, len);\n+}\n \n-      switch (len)\n+/* Extract the plain identifier from MANGLED and prepend/append it to DECL\n+   with special treatment for some magic compiler generted symbols.\n+   Return the remaining string on success or NULL on failure.  */\n+static const char *\n+dlang_lname (string *decl, const char *mangled, long len)\n+{\n+  switch (len)\n+    {\n+    case 6:\n+      if (strncmp (mangled, \"__ctor\", len) == 0)\n \t{\n-\tcase 6:\n-\t  if (strncmp (mangled, \"__ctor\", len) == 0)\n-\t    {\n-\t      /* Constructor symbol for a class/struct.  */\n-\t      string_append (decl, \"this\");\n-\t      mangled += len;\n-\t      return mangled;\n-\t    }\n-\t  else if (strncmp (mangled, \"__dtor\", len) == 0)\n-\t    {\n-\t      /* Destructor symbol for a class/struct.  */\n-\t      string_append (decl, \"~this\");\n-\t      mangled += len;\n-\t      return mangled;\n-\t    }\n-\t  else if (strncmp (mangled, \"__initZ\", len+1) == 0)\n-\t    {\n-\t      /* The static initialiser for a given symbol.  */\n-\t      string_prepend (decl, \"initializer for \");\n-\t      string_setlength (decl, string_length (decl) - 1);\n-\t      mangled += len;\n-\t      return mangled;\n-\t    }\n-\t  else if (strncmp (mangled, \"__vtblZ\", len+1) == 0)\n-\t    {\n-\t      /* The vtable symbol for a given class.  */\n-\t      string_prepend (decl, \"vtable for \");\n-\t      string_setlength (decl, string_length (decl) - 1);\n-\t      mangled += len;\n-\t      return mangled;\n-\t    }\n-\t  break;\n-\n-\tcase 7:\n-\t  if (strncmp (mangled, \"__ClassZ\", len+1) == 0)\n-\t    {\n-\t      /* The classinfo symbol for a given class.  */\n-\t      string_prepend (decl, \"ClassInfo for \");\n-\t      string_setlength (decl, string_length (decl) - 1);\n-\t      mangled += len;\n-\t      return mangled;\n-\t    }\n-\t  break;\n+\t  /* Constructor symbol for a class/struct.  */\n+\t  string_append (decl, \"this\");\n+\t  mangled += len;\n+\t  return mangled;\n+\t}\n+      else if (strncmp (mangled, \"__dtor\", len) == 0)\n+\t{\n+\t  /* Destructor symbol for a class/struct.  */\n+\t  string_append (decl, \"~this\");\n+\t  mangled += len;\n+\t  return mangled;\n+\t}\n+      else if (strncmp (mangled, \"__initZ\", len + 1) == 0)\n+\t{\n+\t  /* The static initialiser for a given symbol.  */\n+\t  string_prepend (decl, \"initializer for \");\n+\t  string_setlength (decl, string_length (decl) - 1);\n+\t  mangled += len;\n+\t  return mangled;\n+\t}\n+      else if (strncmp (mangled, \"__vtblZ\", len + 1) == 0)\n+\t{\n+\t  /* The vtable symbol for a given class.  */\n+\t  string_prepend (decl, \"vtable for \");\n+\t  string_setlength (decl, string_length (decl) - 1);\n+\t  mangled += len;\n+\t  return mangled;\n+\t}\n+      break;\n \n-\tcase 10:\n-\t  if (strncmp (mangled, \"__postblitMFZ\", len+3) == 0)\n-\t    {\n-\t      /* Postblit symbol for a struct.  */\n-\t      string_append (decl, \"this(this)\");\n-\t      mangled += len + 3;\n-\t      return mangled;\n-\t    }\n-\t  break;\n+    case 7:\n+      if (strncmp (mangled, \"__ClassZ\", len + 1) == 0)\n+\t{\n+\t  /* The classinfo symbol for a given class.  */\n+\t  string_prepend (decl, \"ClassInfo for \");\n+\t  string_setlength (decl, string_length (decl) - 1);\n+\t  mangled += len;\n+\t  return mangled;\n+\t}\n+      break;\n \n-\tcase 11:\n-\t  if (strncmp (mangled, \"__InterfaceZ\", len+1) == 0)\n-\t    {\n-\t      /* The interface symbol for a given class.  */\n-\t      string_prepend (decl, \"Interface for \");\n-\t      string_setlength (decl, string_length (decl) - 1);\n-\t      mangled += len;\n-\t      return mangled;\n-\t    }\n-\t  break;\n+    case 10:\n+      if (strncmp (mangled, \"__postblitMFZ\", len + 3) == 0)\n+\t{\n+\t  /* Postblit symbol for a struct.  */\n+\t  string_append (decl, \"this(this)\");\n+\t  mangled += len + 3;\n+\t  return mangled;\n+\t}\n+      break;\n \n-\tcase 12:\n-\t  if (strncmp (mangled, \"__ModuleInfoZ\", len+1) == 0)\n-\t    {\n-\t      /* The ModuleInfo symbol for a given module.  */\n-\t      string_prepend (decl, \"ModuleInfo for \");\n-\t      string_setlength (decl, string_length (decl) - 1);\n-\t      mangled += len;\n-\t      return mangled;\n-\t    }\n-\t  break;\n+    case 11:\n+      if (strncmp (mangled, \"__InterfaceZ\", len + 1) == 0)\n+\t{\n+\t  /* The interface symbol for a given class.  */\n+\t  string_prepend (decl, \"Interface for \");\n+\t  string_setlength (decl, string_length (decl) - 1);\n+\t  mangled += len;\n+\t  return mangled;\n \t}\n+      break;\n \n-      string_appendn (decl, mangled, len);\n-      mangled += len;\n+    case 12:\n+      if (strncmp (mangled, \"__ModuleInfoZ\", len + 1) == 0)\n+\t{\n+\t  /* The ModuleInfo symbol for a given module.  */\n+\t  string_prepend (decl, \"ModuleInfo for \");\n+\t  string_setlength (decl, string_length (decl) - 1);\n+\t  mangled += len;\n+\t  return mangled;\n+\t}\n+      break;\n     }\n \n+  string_appendn (decl, mangled, len);\n+  mangled += len;\n+\n   return mangled;\n }\n \n@@ -1347,22 +1520,22 @@ dlang_value (string *decl, const char *mangled, const char *name, char type)\n /* Extract and demangle the symbol in MANGLED and append it to DECL.\n    Returns the remaining signature on success or NULL on failure.  */\n static const char *\n-dlang_parse_mangle (string *decl, const char *mangled,\n-\t\t    enum dlang_symbol_kinds kind)\n+dlang_parse_mangle (string *decl, const char *mangled, struct dlang_info *info)\n {\n   /* A D mangled symbol is comprised of both scope and type information.\n \n \tMangleName:\n \t    _D QualifiedName Type\n-\t    _D QualifiedName M Type\n \t    _D QualifiedName Z\n \t    ^\n      The caller should have guaranteed that the start pointer is at the\n      above location.\n+     Note that type is never a function type, but only the return type of\n+     a function or the type of a variable.\n    */\n   mangled += 2;\n \n-  mangled = dlang_parse_qualified (decl, mangled, dlang_top_level);\n+  mangled = dlang_parse_qualified (decl, mangled, info, 1);\n \n   if (mangled != NULL)\n     {\n@@ -1371,68 +1544,40 @@ dlang_parse_mangle (string *decl, const char *mangled,\n \tmangled++;\n       else\n \t{\n-\t  string mods;\n-\t  int saved;\n-\n-\t  /* Skip over 'this' parameter.  */\n-\t  if (*mangled == 'M')\n-\t    mangled++;\n-\n-\t  /* Save the type modifiers for appending at the end if needed.  */\n-\t  string_init (&mods);\n-\t  mangled = dlang_type_modifiers (&mods, mangled);\n-\n-\t  if (mangled && dlang_call_convention_p (mangled))\n-\t    {\n-\t      /* Skip over calling convention and attributes.  */\n-\t      saved = string_length (decl);\n-\t      mangled = dlang_call_convention (decl, mangled);\n-\t      mangled = dlang_attributes (decl, mangled);\n-\t      string_setlength (decl, saved);\n-\n-\t      string_append (decl, \"(\");\n-\t      mangled = dlang_function_args (decl, mangled);\n-\t      string_append (decl, \")\");\n-\n-\t      /* Add any const/immutable/shared modifier. */\n-\t      string_appendn (decl, mods.b, string_length (&mods));\n-\t    }\n-\n-\t  /* Consume the decl type of symbol.  */\n-\t  saved = string_length (decl);\n-\t  mangled = dlang_type (decl, mangled);\n-\t  string_setlength (decl, saved);\n+\t  /* Discard the declaration or return type.  */\n+\t  string type;\n \n-\t  string_delete (&mods);\n+\t  string_init (&type);\n+\t  mangled = dlang_type (&type, mangled, info);\n+\t  string_delete (&type);\n \t}\n     }\n \n-  /* Check that the entire symbol was successfully demangled.  */\n-  if (kind == dlang_top_level)\n-    {\n-      if (mangled == NULL || *mangled != '\\0')\n-\treturn NULL;\n-    }\n-\n   return mangled;\n }\n \n /* Extract and demangle the qualified symbol in MANGLED and append it to DECL.\n+   SUFFIX_MODIFIERS is 1 if we are printing modifiers on this after the symbol.\n    Returns the remaining signature on success or NULL on failure.  */\n static const char *\n dlang_parse_qualified (string *decl, const char *mangled,\n-\t\t       enum dlang_symbol_kinds kind)\n+\t\t       struct dlang_info *info, int suffix_modifiers)\n {\n   /* Qualified names are identifiers separated by their encoded length.\n      Nested functions also encode their argument types without specifying\n      what they return.\n \n \tQualifiedName:\n-\t    SymbolName\n-\t    SymbolName QualifiedName\n-\t    SymbolName TypeFunctionNoReturn QualifiedName\n-\t    SymbolName M TypeModifiers TypeFunctionNoReturn QualifiedName\n+\t    SymbolFunctionName\n+\t    SymbolFunctionName QualifiedName\n \t    ^\n+\n+\tSymbolFunctionName:\n+\t    SymbolName\n+\t    SymbolName TypeFunctionNoReturn\n+\t    SymbolName M TypeFunctionNoReturn\n+\t    SymbolName M TypeModifiers TypeFunctionNoReturn\n+\n      The start pointer should be at the above location.\n    */\n   size_t n = 0;\n@@ -1445,57 +1590,53 @@ dlang_parse_qualified (string *decl, const char *mangled,\n       while (*mangled == '0')\n \tmangled++;\n \n-      mangled = dlang_identifier (decl, mangled, kind);\n+      mangled = dlang_identifier (decl, mangled, info);\n \n       /* Consume the encoded arguments.  However if this is not followed by the\n-\t next encoded length, then this is not a continuation of a qualified\n-\t name, in which case we backtrack and return the current unconsumed\n-\t position of the mangled decl.  */\n+\t next encoded length or mangle type, then this is not a continuation of\n+\t a qualified name, in which case we backtrack and return the current\n+\t unconsumed position of the mangled decl.  */\n       if (mangled && (*mangled == 'M' || dlang_call_convention_p (mangled)))\n \t{\n+\t  string mods;\n \t  const char *start = mangled;\n \t  int saved = string_length (decl);\n \n+\t  /* Save the type modifiers for appending at the end if needed.  */\n+\t  string_init (&mods);\n+\n \t  /* Skip over 'this' parameter and type modifiers.  */\n \t  if (*mangled == 'M')\n \t    {\n \t      mangled++;\n-\t      mangled = dlang_type_modifiers (decl, mangled);\n+\t      mangled = dlang_type_modifiers (&mods, mangled);\n \t      string_setlength (decl, saved);\n \t    }\n \n-\t  /* The rule we expect to match in the mangled string is:\n-\n-\t\tTypeFunctionNoReturn:\n-\t\t    CallConvention FuncAttrs Arguments ArgClose\n-\n-\t     The calling convention and function attributes are not included\n-\t     in the demangled string.  */\n-\t  mangled = dlang_call_convention (decl, mangled);\n-\t  mangled = dlang_attributes (decl, mangled);\n-\t  string_setlength (decl, saved);\n+\t  mangled = dlang_function_type_noreturn (decl, NULL, NULL,\n+\t\t\t\t\t\t  mangled, info);\n+\t  if (suffix_modifiers)\n+\t    string_appendn (decl, mods.b, string_length (&mods));\n \n-\t  string_append (decl, \"(\");\n-\t  mangled = dlang_function_args (decl, mangled);\n-\t  string_append (decl, \")\");\n-\n-\t  if (mangled == NULL || !ISDIGIT (*mangled))\n+\t  if (mangled == NULL || *mangled == '\\0')\n \t    {\n \t      /* Did not match the rule we were looking for.  */\n \t      mangled = start;\n \t      string_setlength (decl, saved);\n \t    }\n+\n+\t  string_delete (&mods);\n \t}\n     }\n-  while (mangled && ISDIGIT (*mangled));\n+  while (mangled && dlang_symbol_name_p (mangled, info));\n \n   return mangled;\n }\n \n /* Demangle the tuple from MANGLED and append it to DECL.\n    Return the remaining string on success or NULL on failure.  */\n static const char *\n-dlang_parse_tuple (string *decl, const char *mangled)\n+dlang_parse_tuple (string *decl, const char *mangled, struct dlang_info *info)\n {\n   long elements;\n \n@@ -1507,7 +1648,7 @@ dlang_parse_tuple (string *decl, const char *mangled)\n \n   while (elements--)\n     {\n-      mangled = dlang_type (decl, mangled);\n+      mangled = dlang_type (decl, mangled, info);\n       if (mangled == NULL)\n \treturn NULL;\n \n@@ -1519,10 +1660,71 @@ dlang_parse_tuple (string *decl, const char *mangled)\n   return mangled;\n }\n \n+/* Demangle the template symbol parameter from MANGLED and append it to DECL.\n+   Return the remaining string on success or NULL on failure.  */\n+static const char *\n+dlang_template_symbol_param (string *decl, const char *mangled,\n+\t\t\t     struct dlang_info *info)\n+{\n+  if (strncmp (mangled, \"_D\", 2) == 0\n+      && dlang_symbol_name_p (mangled + 2, info))\n+    return dlang_parse_mangle (decl, mangled, info);\n+\n+  if (*mangled == 'Q')\n+    return dlang_parse_qualified (decl, mangled, info, 0);\n+\n+  long len;\n+  const char *endptr = dlang_number (mangled, &len);\n+\n+  if (endptr == NULL || len == 0)\n+    return NULL;\n+\n+  /* In template parameter symbols generated by the frontend up to 2.076,\n+     the symbol length is encoded and the first character of the mangled\n+     name can be a digit.  This causes ambiguity issues because the digits\n+     of the two numbers are adjacent.  */\n+  long psize = len;\n+  const char *pend;\n+  int saved = string_length (decl);\n+\n+  /* Work backwards until a match is found.  */\n+  for (pend = endptr; endptr != NULL; pend--)\n+    {\n+      mangled = pend;\n+\n+      /* Reached the beginning of the pointer to the name length,\n+\t try parsing the entire symbol.  */\n+      if (psize == 0)\n+\t{\n+\t  psize = len;\n+\t  pend = endptr;\n+\t  endptr = NULL;\n+\t}\n+\n+      /* Check whether template parameter is a function with a valid\n+\t return type or an untyped identifier.  */\n+      if (dlang_symbol_name_p (mangled, info))\n+\tmangled = dlang_parse_qualified (decl, mangled, info, 0);\n+      else if (strncmp (mangled, \"_D\", 2) == 0\n+\t       && dlang_symbol_name_p (mangled + 2, info))\n+\tmangled = dlang_parse_mangle (decl, mangled, info);\n+\n+      /* Check for name length mismatch.  */\n+      if (mangled && (endptr == NULL || (mangled - pend) == psize))\n+\treturn mangled;\n+\n+      psize /= 10;\n+      string_setlength (decl, saved);\n+    }\n+\n+  /* No match on any combinations.  */\n+  return NULL;\n+}\n+\n /* Demangle the argument list from MANGLED and append it to DECL.\n    Return the remaining string on success or NULL on failure.  */\n static const char *\n-dlang_template_args (string *decl, const char *mangled)\n+dlang_template_args (string *decl, const char *mangled, struct dlang_info *info)\n {\n   size_t n = 0;\n \n@@ -1546,11 +1748,11 @@ dlang_template_args (string *decl, const char *mangled)\n \t{\n \tcase 'S': /* Symbol parameter.  */\n \t  mangled++;\n-\t  mangled = dlang_identifier (decl, mangled, dlang_template_param);\n+\t  mangled = dlang_template_symbol_param (decl, mangled, info);\n \t  break;\n \tcase 'T': /* Type parameter.  */\n \t  mangled++;\n-\t  mangled = dlang_type (decl, mangled);\n+\t  mangled = dlang_type (decl, mangled, info);\n \t  break;\n \tcase 'V': /* Value parameter.  */\n \t{\n@@ -1561,18 +1763,41 @@ dlang_template_args (string *decl, const char *mangled)\n \t  mangled++;\n \t  type = *mangled;\n \n+\t  if (type == 'Q')\n+\t    {\n+\t      /* Value type is a back reference, peek at the real type.  */\n+\t      const char *backref;\n+\t      if (dlang_backref (mangled, &backref, info) == NULL)\n+\t\treturn NULL;\n+\n+\t      type = *backref;\n+\t    }\n+\n \t  /* In the few instances where the type is actually desired in\n \t     the output, it should precede the value from dlang_value.  */\n \t  string_init (&name);\n-\t  mangled = dlang_type (&name, mangled);\n+\t  mangled = dlang_type (&name, mangled, info);\n \t  string_need (&name, 1);\n \t  *(name.p) = '\\0';\n \n \t  mangled = dlang_value (decl, mangled, name.b, type);\n \t  string_delete (&name);\n \t  break;\n \t}\n+\tcase 'X': /* Externally mangled parameter.  */\n+\t{\n+\t  long len;\n+\t  const char *endptr;\n \n+\t  mangled++;\n+\t  endptr = dlang_number (mangled, &len);\n+\t  if (endptr == NULL || strlen (endptr) < (size_t) len)\n+\t    return NULL;\n+\n+\t  string_appendn (decl, endptr, len);\n+\t  mangled = endptr + len;\n+\t  break;\n+\t}\n \tdefault:\n \t  return NULL;\n \t}\n@@ -1582,12 +1807,14 @@ dlang_template_args (string *decl, const char *mangled)\n }\n \n /* Extract and demangle the template symbol in MANGLED, expected to\n-   be made up of LEN characters, and append it to DECL.\n+   be made up of LEN characters (-1 if unknown), and append it to DECL.\n    Returns the remaining signature on success or NULL on failure.  */\n static const char *\n-dlang_parse_template (string *decl, const char *mangled, long len)\n+dlang_parse_template (string *decl, const char *mangled,\n+\t\t      struct dlang_info *info, long len)\n {\n   const char *start = mangled;\n+  string args;\n \n   /* Template instance names have the types and values of its parameters\n      encoded into it.\n@@ -1601,26 +1828,40 @@ dlang_parse_template (string *decl, const char *mangled, long len)\n    */\n \n   /* Template symbol.  */\n-  if (!ISDIGIT (mangled[3]) || mangled[3] == '0')\n+  if (!dlang_symbol_name_p (mangled + 3, info) || mangled[3] == '0')\n     return NULL;\n \n   mangled += 3;\n \n   /* Template identifier.  */\n-  mangled = dlang_identifier (decl, mangled, dlang_template_ident);\n+  mangled = dlang_identifier (decl, mangled, info);\n \n   /* Template arguments.  */\n+  string_init (&args);\n+  mangled = dlang_template_args (&args, mangled, info);\n+\n   string_append (decl, \"!(\");\n-  mangled = dlang_template_args (decl, mangled);\n+  string_appendn (decl, args.b, string_length (&args));\n   string_append (decl, \")\");\n \n+  string_delete (&args);\n+\n   /* Check for template name length mismatch.  */\n-  if (mangled && (mangled - start) != len)\n+  if (len != TEMPLATE_LENGTH_UNKNOWN && mangled && (mangled - start) != len)\n     return NULL;\n \n   return mangled;\n }\n \n+/* Initialize the information structure we use to pass around information.  */\n+static void\n+dlang_demangle_init_info (const char *mangled, int last_backref,\n+\t\t\t  struct dlang_info *info)\n+{\n+  info->s = mangled;\n+  info->last_backref = last_backref;\n+}\n+\n /* Extract and demangle the symbol in MANGLED.  Returns the demangled\n    signature on success or NULL on failure.  */\n \n@@ -1644,7 +1885,13 @@ dlang_demangle (const char *mangled, int option ATTRIBUTE_UNUSED)\n     }\n   else\n     {\n-      if (dlang_parse_mangle (&decl, mangled, dlang_top_level) == NULL)\n+      struct dlang_info info;\n+\n+      dlang_demangle_init_info (mangled, strlen (mangled), &info);\n+      mangled = dlang_parse_mangle (&decl, mangled, &info);\n+\n+      /* Check that the entire symbol was successfully demangled.  */\n+      if (mangled == NULL || *mangled != '\\0')\n \tstring_delete (&decl);\n     }\n "}, {"sha": "47b24ea48ae72b5f49bb583f2e6dfbe30eff63b8", "filename": "libiberty/testsuite/d-demangle-expected", "status": "modified", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f30a274913bde0a1e01a86ce7c85e3be34ea13f/libiberty%2Ftestsuite%2Fd-demangle-expected", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f30a274913bde0a1e01a86ce7c85e3be34ea13f/libiberty%2Ftestsuite%2Fd-demangle-expected", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Ftestsuite%2Fd-demangle-expected?ref=3f30a274913bde0a1e01a86ce7c85e3be34ea13f", "patch": "@@ -1326,3 +1326,75 @@ _D1_B699999999961*\n --format=dlang\n _D5__T1fVHacA6666666666_\n _D5__T1fVHacA6666666666_\n+#\n+--format=dlang\n+_D3std5range15__T4iotaTtTtTtZ4iotaFtttZ6Result7opIndexMNgFNaNbNiNfmZNgt\n+std.range.iota!(ushort, ushort, ushort).iota(ushort, ushort, ushort).Result.opIndex(ulong) inout\n+#\n+--format=dlang\n+_D3std6format77__T6getNthVAyaa13_696e7465676572207769647468S233std6traits10isIntegralTiTkTkZ6getNthFNaNfkkkZi\n+std.format.getNth!(\"integer width\", std.traits.isIntegral, int, uint, uint).getNth(uint, uint, uint)\n+#\n+--format=dlang\n+_D3std11parallelism42__T16RoundRobinBufferTDFKAaZvTDxFNaNdNeZbZ16RoundRobinBuffer5primeMFZv\n+std.parallelism.RoundRobinBuffer!(void(ref char[]) delegate, bool() pure @property @trusted delegate const).RoundRobinBuffer.prime()\n+#\n+--format=dlang\n+_D4core4stdc5errnoQgFZi\n+core.stdc.errno.errno()\n+#\n+--format=dlang\n+_D4testFS10structnameQnZb\n+test(structname, structname)\n+#\n+--format=dlang\n+_D3std11parallelism__T4TaskS8unittest3cmpTAyaTQeZQBb6__dtorMFNfZv\n+std.parallelism.Task!(unittest.cmp, immutable(char)[], immutable(char)[]).Task.~this()\n+#\n+--format=dlang\n+_D13testexpansion44__T1sTS13testexpansion8__T1sTiZ1sFiZ6ResultZ1sFS13testexpansion8__T1sTiZ1sFiZ6ResultZ6Result3fooMFNaNfZv\n+testexpansion.s!(testexpansion.s!(int).s(int).Result).s(testexpansion.s!(int).s(int).Result).Result.foo()\n+#\n+--format=dlang\n+_D13testexpansion__T1sTSQw__TQjTiZQoFiZ6ResultZQBbFQBcZQq3fooMFNaNfZv\n+testexpansion.s!(testexpansion.s!(int).s(int).Result).s(testexpansion.s!(int).s(int).Result).Result.foo()\n+#\n+--format=dlang\n+_D3std4conv__T7enumRepTyAaTEQBa12experimental9allocator15building_blocks15stats_collector7OptionsVQCti64ZQDnyQDh\n+std.conv.enumRep!(immutable(char[]), std.experimental.allocator.building_blocks.stats_collector.Options, 64).enumRep\n+#\n+--format=dlang\n+_D3std12experimental9allocator6common__T10reallocateTSQCaQBzQBo15building_blocks17kernighan_ritchie__T8KRRegionTSQEhQEgQDvQCh14null_allocator13NullAllocatorZQCdZQErFNaNbNiKQEpKAvmZb\n+std.experimental.allocator.common.reallocate!(std.experimental.allocator.building_blocks.kernighan_ritchie.KRRegion!(std.experimental.allocator.building_blocks.null_allocator.NullAllocator).KRRegion).reallocate(ref std.experimental.allocator.building_blocks.kernighan_ritchie.KRRegion!(std.experimental.allocator.building_blocks.null_allocator.NullAllocator).KRRegion, ref void[], ulong)\n+#\n+--format=dlang\n+_D3std9exception__T11doesPointToTASQBh5regex8internal2ir10NamedGroupTQBkTvZQCeFNaNbNiNeKxASQDlQCeQCbQBvQBvKxQtZb\n+std.exception.doesPointTo!(std.regex.internal.ir.NamedGroup[], std.regex.internal.ir.NamedGroup[], void).doesPointTo(ref const(std.regex.internal.ir.NamedGroup[]), ref const(std.regex.internal.ir.NamedGroup[]))\n+#\n+--format=dlang\n+_D3std9algorithm9iteration__T14SplitterResultS_DQBu3uni7isWhiteFNaNbNiNfwZbTAyaZQBz9__xtoHashFNbNeKxSQDvQDuQDn__TQDgS_DQEnQCtQCsQCnTQCeZQEdZm\n+std.algorithm.iteration.SplitterResult!(std.uni.isWhite(dchar), immutable(char)[]).SplitterResult.__xtoHash(ref const(std.algorithm.iteration.SplitterResult!(std.uni.isWhite, immutable(char)[]).SplitterResult))\n+#\n+--format=dlang\n+_D3std8typecons__T7TypedefTCQBaQz19__unittestL6513_208FNfZ7MyClassVQBonVAyanZQCh6__ctorMFNaNbNcNiNfQCuZSQDyQDx__TQDrTQDmVQDqnVQCcnZQEj\n+std.typecons.Typedef!(std.typecons.__unittestL6513_208().MyClass, null, null).Typedef.this(std.typecons.__unittestL6513_208().MyClass)\n+#\n+--format=dlang\n+_D3std6getopt__TQkTAyaTDFNaNbNiNfQoZvTQtTDQsZQBnFNfKAQBiQBlQBkQBrQyZSQCpQCo12GetoptResult\n+std.getopt.getopt!(immutable(char)[], void(immutable(char)[]) pure nothrow @nogc @safe delegate, immutable(char)[], void(immutable(char)[]) pure nothrow @nogc @safe delegate).getopt(ref immutable(char)[][], immutable(char)[], void(immutable(char)[]) pure nothrow @nogc @safe delegate, immutable(char)[], void(immutable(char)[]) pure nothrow @nogc @safe delegate)\n+#\n+--format=dlang\n+_D3std5regex8internal9kickstart__T7ShiftOrTaZQl11ShiftThread__T3setS_DQCqQCpQCmQCg__TQBzTaZQCfQBv10setInvMaskMFNaNbNiNfkkZvZQCjMFNaNfwZv\n+std.regex.internal.kickstart.ShiftOr!(char).ShiftOr.ShiftThread.set!(std.regex.internal.kickstart.ShiftOr!(char).ShiftOr.ShiftThread.setInvMask(uint, uint)).set(dchar)\n+#\n+--format=dlang\n+_D3std5stdio4File__T8lockImplX10LockFileExTykZQBaMFmmykZi\n+std.stdio.File.lockImpl!(LockFileEx, immutable(uint)).lockImpl(ulong, ulong, immutable(uint))\n+#\n+--format=dlang\n+_D3std9algorithm9iteration__T12FilterResultSQBq8typecons__T5TupleTiVAyaa1_61TiVQla1_62TiVQva1_63ZQBm__T6renameVHiQBtA2i0a1_63i2a1_61ZQBeMFNcZ9__lambda1TAiZQEw9__xtoHashFNbNeKxSQGsQGrQGk__TQGdSQHiQFs__TQFmTiVQFja1_61TiVQFua1_62TiVQGfa1_63ZQGx__TQFlVQFhA2i0a1_63i2a1_61ZQGjMFNcZQFfTQEyZQJvZm\n+std.algorithm.iteration.FilterResult!(std.typecons.Tuple!(int, \"a\", int, \"b\", int, \"c\").Tuple.rename!([0:\"c\", 2:\"a\"]).rename().__lambda1, int[]).FilterResult.__xtoHash(ref const(std.algorithm.iteration.FilterResult!(std.typecons.Tuple!(int, \"a\", int, \"b\", int, \"c\").Tuple.rename!([0:\"c\", 2:\"a\"]).rename().__lambda1, int[]).FilterResult))\n+#\n+--format=dlang\n+_D3std3uni__T6toCaseS_DQvQt12toLowerIndexFNaNbNiNewZtVii1043S_DQCjQCi10toLowerTabFNaNbNiNemZwSQDo5ascii7toLowerTAyaZQDzFNaNeQmZ14__foreachbody2MFNaNeKmKwZ14__foreachbody3MFNaNeKwZi\n+std.uni.toCase!(std.uni.toLowerIndex(dchar), 1043, std.uni.toLowerTab(ulong), std.ascii.toLower, immutable(char)[]).toCase(immutable(char)[]).__foreachbody2(ref ulong, ref dchar).__foreachbody3(ref dchar)"}]}