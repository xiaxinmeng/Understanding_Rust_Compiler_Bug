{"sha": "43e654afeba484d75fbee080262a038c1da00ad5", "node_id": "C_kwDOANBUbNoAKDQzZTY1NGFmZWJhNDg0ZDc1ZmJlZTA4MDI2MmEwMzhjMWRhMDBhZDU", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2022-10-25T13:39:00Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2022-10-25T19:16:22Z"}, "message": "c++: Adjust synthetic template parm creation\n\nWe intend to mark synthetic template parameters (coming from use of auto\nparms), as DECL_VIRTUAL_P.  The API of process_template_parm is\nawkwardly confusing, and we were marking the previous template parm\n(unless this was the first parm).  process_template_parm returns the list\nof parms, when most (all?) users really want the newly-added final node.\nThat's a bigger change, so let's not do it right now.  With this, we\ncorrectly mark such synthetic parms DECL_VIRTUAL_P.\n\n\tgcc/cp/\n\t* parser.cc (synthesize_implicit_template_parm): Fix thinko about\n\tmark the new parm DECL_VIRTUAL_P.  Avoid unneccessary tree_last call.", "tree": {"sha": "ba3b9cc0bc14981159ac43691e5dd0fdd293e103", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ba3b9cc0bc14981159ac43691e5dd0fdd293e103"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/43e654afeba484d75fbee080262a038c1da00ad5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43e654afeba484d75fbee080262a038c1da00ad5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/43e654afeba484d75fbee080262a038c1da00ad5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43e654afeba484d75fbee080262a038c1da00ad5/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fe1e1ae0c84d3f52f62509d164bbb117c29d9675", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe1e1ae0c84d3f52f62509d164bbb117c29d9675", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fe1e1ae0c84d3f52f62509d164bbb117c29d9675"}], "stats": {"total": 26, "additions": 15, "deletions": 11}, "files": [{"sha": "e685f190b3d4d1677601040435236aabdacbcdec", "filename": "gcc/cp/parser.cc", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43e654afeba484d75fbee080262a038c1da00ad5/gcc%2Fcp%2Fparser.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43e654afeba484d75fbee080262a038c1da00ad5/gcc%2Fcp%2Fparser.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.cc?ref=43e654afeba484d75fbee080262a038c1da00ad5", "patch": "@@ -48996,12 +48996,11 @@ synthesize_implicit_template_parm  (cp_parser *parser, tree constr)\n \n   tree proto = constr ? DECL_INITIAL (constr) : NULL_TREE;\n   tree synth_id = make_generic_type_name ();\n-  tree synth_tmpl_parm;\n   bool non_type = false;\n \n   /* Synthesize the type template parameter.  */\n   gcc_assert(!proto || TREE_CODE (proto) == TYPE_DECL);\n-  synth_tmpl_parm = finish_template_type_parm (class_type_node, synth_id);\n+  tree synth_tmpl_parm = finish_template_type_parm (class_type_node, synth_id);\n \n   if (become_template)\n     current_template_parms = tree_cons (size_int (current_template_depth + 1),\n@@ -49016,22 +49015,27 @@ synthesize_implicit_template_parm  (cp_parser *parser, tree constr)\n \t\t\t     node,\n \t\t\t     /*non_type=*/non_type,\n \t\t\t     /*param_pack=*/false);\n+  // Process_template_parm returns the list of parms, and\n+  // parser->implicit_template_parms holds the final node of the parm\n+  // list.  We really want to manipulate the newly appended element.\n+  gcc_checking_assert (!parser->implicit_template_parms\n+\t\t       || parser->implicit_template_parms == new_parm);\n+  if (parser->implicit_template_parms)\n+    new_parm = TREE_CHAIN (new_parm);\n+  gcc_checking_assert (!TREE_CHAIN (new_parm));\n+\n+  // Record the last implicit parm node\n+  parser->implicit_template_parms = new_parm;\n \n   /* Mark the synthetic declaration \"virtual\". This is used when\n      comparing template-heads to determine if whether an abbreviated\n      function template is equivalent to an explicit template.\n \n-     Note that DECL_ARTIFICIAL is used elsewhere for template parameters.  */\n+     Note that DECL_ARTIFICIAL is used elsewhere for template\n+     parameters.  */\n   if (TREE_VALUE (new_parm) != error_mark_node)\n     DECL_VIRTUAL_P (TREE_VALUE (new_parm)) = true;\n \n-  // Chain the new parameter to the list of implicit parameters.\n-  if (parser->implicit_template_parms)\n-    parser->implicit_template_parms\n-      = TREE_CHAIN (parser->implicit_template_parms);\n-  else\n-    parser->implicit_template_parms = new_parm;\n-\n   tree new_decl = get_local_decls ();\n   if (non_type)\n     /* Return the TEMPLATE_PARM_INDEX, not the PARM_DECL.  */\n@@ -49059,7 +49063,7 @@ synthesize_implicit_template_parm  (cp_parser *parser, tree constr)\n \n   /* If the new parameter was constrained, we need to add that to the\n      constraints in the template parameter list.  */\n-  if (tree req = TEMPLATE_PARM_CONSTRAINTS (tree_last (new_parm)))\n+  if (tree req = TEMPLATE_PARM_CONSTRAINTS (new_parm))\n     {\n       tree reqs = TEMPLATE_PARMS_CONSTRAINTS (current_template_parms);\n       reqs = combine_constraint_expressions (reqs, req);"}]}