{"sha": "776749c5f2d9a2e3e1fc34d2ae1738012c773ba0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Nzc2NzQ5YzVmMmQ5YTJlM2UxZmMzNGQyYWUxNzM4MDEyYzc3M2JhMA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2000-10-02T06:50:52Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2000-10-02T06:50:52Z"}, "message": "genix.h: Remove.\n\n\t* config/ns32k/genix.h: Remove.\n\t* config/ns32k/x-genix: Likewise.\n\t* config/ns32k/xm-genix.h: Likewise.\n\t* config/fx80: Remove all filee in directory.\n\t* config/pyr: Likewise.\n\t* config/tahoe: Likewise.\n\t* config/gmicro: Likewise.\n\t* config/spur: Likewise.\n\t* configure.in: Remove configury bits for above targets.\n\t* configure: Regenerated.\n\nFrom-SVN: r36691", "tree": {"sha": "6ce21fc2cf38a871af1e086f945bda1a8db93bd0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6ce21fc2cf38a871af1e086f945bda1a8db93bd0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/776749c5f2d9a2e3e1fc34d2ae1738012c773ba0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/776749c5f2d9a2e3e1fc34d2ae1738012c773ba0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/776749c5f2d9a2e3e1fc34d2ae1738012c773ba0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/776749c5f2d9a2e3e1fc34d2ae1738012c773ba0/comments", "author": null, "committer": null, "parents": [{"sha": "a7b4171a5b8a655097812307bbe261032dfbe366", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7b4171a5b8a655097812307bbe261032dfbe366", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a7b4171a5b8a655097812307bbe261032dfbe366"}], "stats": {"total": 20299, "additions": 103, "deletions": 20196}, "files": [{"sha": "3f9f5914edb9800b925a96a182aed61df5ec98c6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/776749c5f2d9a2e3e1fc34d2ae1738012c773ba0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/776749c5f2d9a2e3e1fc34d2ae1738012c773ba0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=776749c5f2d9a2e3e1fc34d2ae1738012c773ba0", "patch": "@@ -1,5 +1,16 @@\n 2000-10-01  Mark Mitchell  <mark@codesourcery.com>\n \n+\t* config/ns32k/genix.h: Remove.\n+\t* config/ns32k/x-genix: Likewise.\n+\t* config/ns32k/xm-genix.h: Likewise.\n+\t* config/fx80: Remove all filee in directory.\n+\t* config/pyr: Likewise.\n+\t* config/tahoe: Likewise.\n+\t* config/gmicro: Likewise.\n+\t* config/spur: Likewise.\n+\t* configure.in: Remove configury bits for above targets.\n+\t* configure: Regenerated.\n+\t\n \t* configure.in: Don't configure chill by default.\n \t* configure: Regenerated.\n \t"}, {"sha": "81d637e18f69eafa16c18f29fb73c37e61d2cecb", "filename": "gcc/config/fx80/fx80.c", "status": "removed", "additions": 0, "deletions": 301, "changes": 301, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7b4171a5b8a655097812307bbe261032dfbe366/gcc%2Fconfig%2Ffx80%2Ffx80.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7b4171a5b8a655097812307bbe261032dfbe366/gcc%2Fconfig%2Ffx80%2Ffx80.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffx80%2Ffx80.c?ref=a7b4171a5b8a655097812307bbe261032dfbe366", "patch": "@@ -1,301 +0,0 @@\n-/* Subroutines for insn-output.c for Alliant FX computers.\n-   Copyright (C) 1989, 1991, 1997, 1998, 1999 Free Software Foundation, Inc.\n-\n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-\n-/* Some output-actions in alliant.md need these.  */\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"rtl.h\"\n-#include \"regs.h\"\n-#include \"hard-reg-set.h\"\n-#include \"real.h\"\n-#include \"insn-config.h\"\n-#include \"conditions.h\"\n-#include \"insn-flags.h\"\n-#include \"function.h\"\n-#include \"output.h\"\n-#include \"insn-attr.h\"\n-\n-/* Index into this array by (register number >> 3) to find the\n-   smallest class which contains that register.  */\n-enum reg_class regno_reg_class[]\n-  = { DATA_REGS, ADDR_REGS, FP_REGS };\n-\n-static rtx find_addr_reg ();\n-\n-char *\n-output_btst (operands, countop, dataop, insn, signpos)\n-     rtx *operands;\n-     rtx countop, dataop;\n-     rtx insn;\n-     int signpos;\n-{\n-  operands[0] = countop;\n-  operands[1] = dataop;\n-\n-  if (GET_CODE (countop) == CONST_INT)\n-    {\n-      register int count = INTVAL (countop);\n-      /* If COUNT is bigger than size of storage unit in use,\n-\t advance to the containing unit of same size.  */\n-      if (count > signpos)\n-\t{\n-\t  int offset = (count & ~signpos) / 8;\n-\t  count = count & signpos;\n-\t  operands[1] = dataop = adj_offsettable_operand (dataop, offset);\n-\t}\n-      if (count == signpos)\n-\tcc_status.flags = CC_NOT_POSITIVE | CC_Z_IN_NOT_N;\n-      else\n-\tcc_status.flags = CC_NOT_NEGATIVE | CC_Z_IN_NOT_N;\n-\n-      /* These three statements used to use next_insns_test_no...\n-\t but it appears that this should do the same job.  */\n-      if (count == 31\n-\t  && next_insn_tests_no_inequality (insn))\n-\treturn \"tst%.l %1\";\n-      if (count == 15\n-\t  && next_insn_tests_no_inequality (insn))\n-\treturn \"tst%.w %1\";\n-      if (count == 7\n-\t  && next_insn_tests_no_inequality (insn))\n-\treturn \"tst%.b %1\";\n-\n-      cc_status.flags = CC_NOT_NEGATIVE;\n-    }\n-  return \"btst %0,%1\";\n-}\n-\f\n-/* Return the best assembler insn template\n-   for moving operands[1] into operands[0] as a fullword.  */\n-\n-static char *\n-singlemove_string (operands)\n-     rtx *operands;\n-{\n-  if (operands[1] != const0_rtx)\n-    return \"mov%.l %1,%0\";\n-  if (! ADDRESS_REG_P (operands[0]))\n-    return \"clr%.l %0\";\n-  return \"sub%.l %0,%0\";\n-}\n-\n-/* Output assembler code to perform a doubleword move insn\n-   with operands OPERANDS.  */\n-\n-char *\n-output_move_double (operands)\n-     rtx *operands;\n-{\n-  enum { REGOP, OFFSOP, MEMOP, PUSHOP, POPOP, CNSTOP, RNDOP } optype0, optype1;\n-  rtx latehalf[2];\n-  rtx addreg0 = 0, addreg1 = 0;\n-\n-  /* First classify both operands.  */\n-\n-  if (REG_P (operands[0]))\n-    optype0 = REGOP;\n-  else if (offsettable_memref_p (operands[0]))\n-    optype0 = OFFSOP;\n-  else if (GET_CODE (XEXP (operands[0], 0)) == POST_INC)\n-    optype0 = POPOP;\n-  else if (GET_CODE (XEXP (operands[0], 0)) == PRE_DEC)\n-    optype0 = PUSHOP;\n-  else if (GET_CODE (operands[0]) == MEM)\n-    optype0 = MEMOP;\n-  else\n-    optype0 = RNDOP;\n-\n-  if (REG_P (operands[1]))\n-    optype1 = REGOP;\n-  else if (CONSTANT_P (operands[1]))\n-    optype1 = CNSTOP;\n-  else if (offsettable_memref_p (operands[1]))\n-    optype1 = OFFSOP;\n-  else if (GET_CODE (XEXP (operands[1], 0)) == POST_INC)\n-    optype1 = POPOP;\n-  else if (GET_CODE (XEXP (operands[1], 0)) == PRE_DEC)\n-    optype1 = PUSHOP;\n-  else if (GET_CODE (operands[1]) == MEM)\n-    optype1 = MEMOP;\n-  else\n-    optype1 = RNDOP;\n-\n-  /* Check for the cases that the operand constraints are not\n-     supposed to allow to happen.  Abort if we get one,\n-     because generating code for these cases is painful.  */\n-\n-  if (optype0 == RNDOP || optype1 == RNDOP)\n-    abort ();\n-\n-  /* If one operand is decrementing and one is incrementing\n-     decrement the former register explicitly\n-     and change that operand into ordinary indexing.  */\n-\n-  if (optype0 == PUSHOP && optype1 == POPOP)\n-    {\n-      operands[0] = XEXP (XEXP (operands[0], 0), 0);\n-      output_asm_insn (\"subq%.l %#8,%0\", operands);\n-      operands[0] = gen_rtx_MEM (DImode, operands[0]);\n-      optype0 = OFFSOP;\n-    }\n-  if (optype0 == POPOP && optype1 == PUSHOP)\n-    {\n-      operands[1] = XEXP (XEXP (operands[1], 0), 0);\n-      output_asm_insn (\"subq%.l %#8,%1\", operands);\n-      operands[1] = gen_rtx_MEM (DImode, operands[1]);\n-      optype1 = OFFSOP;\n-    }\n-\n-  /* If an operand is an unoffsettable memory ref, find a register\n-     we can increment temporarily to make it refer to the second word.  */\n-\n-  if (optype0 == MEMOP)\n-    addreg0 = find_addr_reg (XEXP (operands[0], 0));\n-\n-  if (optype1 == MEMOP)\n-    addreg1 = find_addr_reg (XEXP (operands[1], 0));\n-\n-  /* Ok, we can do one word at a time.\n-     Normally we do the low-numbered word first,\n-     but if either operand is autodecrementing then we\n-     do the high-numbered word first.\n-\n-     In either case, set up in LATEHALF the operands to use\n-     for the high-numbered word and in some cases alter the\n-     operands in OPERANDS to be suitable for the low-numbered word.  */\n-\n-  if (optype0 == REGOP)\n-    latehalf[0] = gen_rtx_REG (SImode, REGNO (operands[0]) + 1);\n-  else if (optype0 == OFFSOP)\n-    latehalf[0] = adj_offsettable_operand (operands[0], 4);\n-  else\n-    latehalf[0] = operands[0];\n-\n-  if (optype1 == REGOP)\n-    latehalf[1] = gen_rtx_REG (SImode, REGNO (operands[1]) + 1);\n-  else if (optype1 == OFFSOP)\n-    latehalf[1] = adj_offsettable_operand (operands[1], 4);\n-  else if (optype1 == CNSTOP)\n-    {\n-      if (GET_CODE (operands[1]) == CONST_DOUBLE)\n-\tsplit_double (operands[1], &operands[1], &latehalf[1]);\n-      else if (CONSTANT_P (operands[1]))\n-\t{\n-\t  latehalf[1] = operands[1];\n-\t  operands[1] = const0_rtx;\n-\t}\n-    }\n-  else\n-    latehalf[1] = operands[1];\n-\n-  /* If insn is effectively movd N(sp),-(sp) then we will do the\n-     high word first.  We should use the adjusted operand 1 (which is N+4(sp))\n-     for the low word as well, to compensate for the first decrement of sp.  */\n-  if (optype0 == PUSHOP\n-      && REGNO (XEXP (XEXP (operands[0], 0), 0)) == STACK_POINTER_REGNUM\n-      && reg_overlap_mentioned_p (stack_pointer_rtx, operands[1]))\n-    operands[1] = latehalf[1];\n-\n-  /* If one or both operands autodecrementing,\n-     do the two words, high-numbered first.  */\n-\n-  /* Likewise,  the first move would clobber the source of the second one,\n-     do them in the other order.  This happens only for registers;\n-     such overlap can't happen in memory unless the user explicitly\n-     sets it up, and that is an undefined circumstance.  */\n-\n-  if (optype0 == PUSHOP || optype1 == PUSHOP\n-      || (optype0 == REGOP && optype1 == REGOP\n-\t  && REGNO (operands[0]) == REGNO (latehalf[1])))\n-    {\n-      /* Make any unoffsettable addresses point at high-numbered word.  */\n-      if (addreg0)\n-\toutput_asm_insn (\"addql %#4,%0\", &addreg0);\n-      if (addreg1)\n-\toutput_asm_insn (\"addql %#4,%0\", &addreg1);\n-\n-      /* Do that word.  */\n-      output_asm_insn (singlemove_string (latehalf), latehalf);\n-\n-      /* Undo the adds we just did.  */\n-      if (addreg0)\n-\toutput_asm_insn (\"subql %#4,%0\", &addreg0);\n-      if (addreg1)\n-\toutput_asm_insn (\"subql %#4,%0\", &addreg1);\n-\n-      /* Do low-numbered word.  */\n-      return singlemove_string (operands);\n-    }\n-\n-  /* Normal case: do the two words, low-numbered first.  */\n-\n-  output_asm_insn (singlemove_string (operands), operands);\n-\n-  /* Make any unoffsettable addresses point at high-numbered word.  */\n-  if (addreg0)\n-    output_asm_insn (\"addql %#4,%0\", &addreg0);\n-  if (addreg1)\n-    output_asm_insn (\"addql %#4,%0\", &addreg1);\n-\n-  /* Do that word.  */\n-  output_asm_insn (singlemove_string (latehalf), latehalf);\n-\n-  /* Undo the adds we just did.  */\n-  if (addreg0)\n-    output_asm_insn (\"subql %#4,%0\", &addreg0);\n-  if (addreg1)\n-    output_asm_insn (\"subql %#4,%0\", &addreg1);\n-\n-  return \"\";\n-}\n-\n-/* Return a REG that occurs in ADDR with coefficient 1.\n-   ADDR can be effectively incremented by incrementing REG.  */\n-\n-static rtx\n-find_addr_reg (addr)\n-     rtx addr;\n-{\n-  while (GET_CODE (addr) == PLUS)\n-    {\n-      if (GET_CODE (XEXP (addr, 0)) == REG)\n-\taddr = XEXP (addr, 0);\n-      else if (GET_CODE (XEXP (addr, 1)) == REG)\n-\taddr = XEXP (addr, 1);\n-      else if (CONSTANT_P (XEXP (addr, 0)))\n-\taddr = XEXP (addr, 1);\n-      else if (CONSTANT_P (XEXP (addr, 1)))\n-\taddr = XEXP (addr, 0);\n-      else\n-\tabort ();\n-    }\n-  if (GET_CODE (addr) == REG)\n-    return addr;\n-  abort ();\n-}\n-\n-int\n-standard_SunFPA_constant_p (x)\n-     rtx x;\n-{\n-  return( 0 );\n-}\n-"}, {"sha": "003d6d4dba904233f397915c9d0c7412b7669f27", "filename": "gcc/config/fx80/fx80.h", "status": "removed", "additions": 0, "deletions": 1445, "changes": 1445, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7b4171a5b8a655097812307bbe261032dfbe366/gcc%2Fconfig%2Ffx80%2Ffx80.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7b4171a5b8a655097812307bbe261032dfbe366/gcc%2Fconfig%2Ffx80%2Ffx80.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffx80%2Ffx80.h?ref=a7b4171a5b8a655097812307bbe261032dfbe366", "patch": "@@ -1,1445 +0,0 @@\n-/* Definitions of target machine for GNU compiler.  Alliant FX version.\n-   Copyright (C) 1989, 1993, 1994, 1995, 1996, 1998, 1999, 2000\n-   Free Software Foundation, Inc.\n-   Adapted from m68k.h by Paul Petersen (petersen@uicsrd.csrd.uiuc.edu)\n-   and Joe Weening (weening@gang-of-four.stanford.edu).\n-\n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-\n-/* This file is based on m68k.h, simplified by removing support for\n-   the Sun FPA and other things not applicable to the Alliant.  Some\n-   remnants of these features remain.  */\n-\n-/* Names to predefine in the preprocessor for this target machine.  */\n-\n-#define CPP_PREDEFINES \"-Dmc68000 -Dalliant -Dunix -Asystem(unix) -Acpu(m68k) -Amachine(m68k)\"\n-\n-/* Print subsidiary information on the compiler version in use.  */\n-\n-#define TARGET_VERSION fprintf (stderr, \" (Alliant)\");\n-\n-/* Run-time compilation parameters selecting different hardware\n-   subsets.  The Alliant IP is an mc68020.  (Older mc68010-based IPs\n-   are no longer supported.)  The Alliant CE is 68020-compatible, and\n-   also has floating point, vector and concurrency instructions.\n-\n-   Although the IP doesn't have floating point, it emulates it in the\n-   operating system.  Using this generally is faster than running code\n-   compiled with -msoft-float, because the soft-float code still uses\n-   (simulated) FP registers and ends up emulating several fmove{s,d}\n-   instructions per call.  So I don't recommend using soft-float for\n-   any Alliant code.  -- JSW\n-*/\n-\n-extern int target_flags;\n-\n-/* Macros used in the machine description to test the flags.  */\n-\n-/* Compile for a 68020 (not a 68000 or 68010).  */\n-#define TARGET_68020 (target_flags & 1)\n-/* Compile CE insns for floating point (not library calls).  */\n-#define TARGET_CE (target_flags & 2)\n-/* Compile using 68020 bitfield insns.  */\n-#define TARGET_BITFIELD (target_flags & 4)\n-/* Compile with 16-bit `int'.  */\n-#define TARGET_SHORT (target_flags & 040)\n-\n-/* Default 3 means compile 68020 and CE instructions.  We don't use\n-   bitfield instructions because there appears to be a bug in the\n-   implementation of bfins on the CE.  */\n-\n-#define TARGET_DEFAULT 3\n-\n-/* Define __HAVE_CE__ in preprocessor according to the -m flags.\n-   This will control the use of inline FP insns in certain macros.\n-   Also inform the program which CPU this is for.  */\n-\n-#if TARGET_DEFAULT & 02\n-\n-/* -mce is the default */\n-#define CPP_SPEC \\\n-\"%{!msoft-float:-D__HAVE_CE__ }\\\n-%{m68000:-Dmc68010}%{mc68000:-Dmc68010}%{!mc68000:%{!m68000:-Dmc68020}}\"\n-\n-#else\n-\n-/* -msoft-float is the default */\n-#define CPP_SPEC \\\n-\"%{mce:-D__HAVE_CE__ }\\\n-%{m68000:-Dmc68010}%{mc68000:-Dmc68010}%{!mc68000:%{!m68000:-Dmc68020}}\"\n-\n-#endif\n-\n-/* Link with libg.a when debugging, for dbx's sake.  */\n-\n-#define LIB_SPEC \"%{g:-lg} %{!p:%{!pg:-lc}}%{p:-lc_p}%{pg:-lc_p} \"\n-\n-/* Make the linker remove temporary labels, since the Alliant assembler\n-   doesn't.  */\n-\n-#define LINK_SPEC \"-X\"\n-\n-/* Every structure or union's size must be a multiple of 2 bytes.  */\n-\n-#define STRUCTURE_SIZE_BOUNDARY 16\n-\n-/* This is BSD, so it wants DBX format.  */\n-\n-#define DBX_DEBUGGING_INFO\n-\n-/* Macro to define tables used to set the flags.\n-   This is a list in braces of pairs in braces,\n-   each pair being { \"NAME\", VALUE }\n-   where VALUE is the bits to set or minus the bits to clear.\n-   An empty string NAME is used to identify the default VALUE.  */\n-\n-#define TARGET_SWITCHES  \\\n-  { { \"68020\", 5, N_(\"Generate code for a mc68020\")},\t\t\\\n-    { \"c68020\", 5, N_(\"Generate code for a mc68020\")},\t\t\\\n-    { \"bitfield\", 4, N_(\"Use bitfield instructions\")},\t\t\\\n-    { \"68000\", -7, N_(\"Generate code for a mc68000\")},\t\t\\\n-    { \"c68000\", -7, N_(\"Generate code for a mc68000\")},\t\t\\\n-    { \"soft-float\", -2, N_(\"Generate software FP code\")},\t\\\n-    { \"nobitfield\", -4, N_(\"Do not generate bitfield insns\")},\t\\\n-    { \"short\", 040, N_(\"Use 16bit integers\")},\t\t\t\\\n-    { \"noshort\", -040, N_(\"Use 32bit integers\")},\t\t\\\n-    { \"\", TARGET_DEFAULT, NULL}}\n-\f\n-/* target machine storage layout */\n-\n-/* Define this if most significant bit is lowest numbered\n-   in instructions that operate on numbered bit-fields.\n-   This is true for 68020 insns such as bfins and bfexts.\n-   We make it true always by avoiding using the single-bit insns\n-   except in special cases with constant bit numbers.  */\n-#define BITS_BIG_ENDIAN 1\n-\n-/* Define this if most significant byte of a word is the lowest numbered.  */\n-/* That is true on the 68000.  */\n-#define BYTES_BIG_ENDIAN 1\n-\n-/* Define this if most significant word of a multiword number is the lowest\n-   numbered.  */\n-/* For 68000 we can decide arbitrarily\n-   since there are no machine instructions for them.  */\n-#define WORDS_BIG_ENDIAN 0\n-\n-/* number of bits in an addressable storage unit */\n-#define BITS_PER_UNIT 8\n-\n-/* Width in bits of a \"word\", which is the contents of a machine register.\n-   Note that this is not necessarily the width of data type `int';\n-   if using 16-bit ints on a 68000, this would still be 32.\n-   But on a machine with 16-bit registers, this would be 16.  */\n-#define BITS_PER_WORD 32\n-\n-/* Width of a word, in units (bytes).  */\n-#define UNITS_PER_WORD 4\n-\n-/* Width in bits of a pointer.\n-   See also the macro `Pmode' defined below.  */\n-#define POINTER_SIZE 32\n-\n-/* Allocation boundary (in *bits*) for storing arguments in argument list.  */\n-#define PARM_BOUNDARY (TARGET_SHORT ? 16 : 32)\n-\n-/* Boundary (in *bits*) on which stack pointer should be aligned.  */\n-#define STACK_BOUNDARY 16\n-\n-/* Allocation boundary (in *bits*) for the code of a function.  */\n-#define FUNCTION_BOUNDARY 16\n-\n-/* Alignment of field after `int : 0' in a structure.  */\n-#define EMPTY_FIELD_BOUNDARY 16\n-\n-/* No data type wants to be aligned rounder than this.  */\n-#define BIGGEST_ALIGNMENT 16\n-\n-/* Set this non-zero if move instructions will actually fail to work\n-   when given unaligned data.  */\n-#define STRICT_ALIGNMENT 1\n-\n-/* Define number of bits in most basic integer type.\n-   (If undefined, default is BITS_PER_WORD).  */\n-\n-#define INT_TYPE_SIZE (TARGET_SHORT ? 16 : 32)\n-\n-/* Define these to avoid dependence on meaning of `int'.  */\n-\n-#define WCHAR_TYPE \"long int\"\n-#define WCHAR_TYPE_SIZE 32\n-\f\n-/* Standard register usage.  */\n-\n-/* Number of actual hardware registers.\n-   The hardware registers are assigned numbers for the compiler\n-   from 0 to just below FIRST_PSEUDO_REGISTER.\n-   All registers that the compiler knows about must be given numbers,\n-   even those that are not normally considered general registers.\n-   For the Alliant, we give the data registers numbers 0-7,\n-   the address registers numbers 010-017,\n-   and the floating point registers numbers 020-027.  */\n-#define FIRST_PSEUDO_REGISTER 24\n-\n-/* 1 for registers that have pervasive standard uses\n-   and are not available for the register allocator.\n-   On the Alliant, these are a0 (argument pointer),\n-   a6 (frame pointer) and a7 (stack pointer).  */\n-#define FIXED_REGISTERS  \\\n- {0, 0, 0, 0, 0, 0, 0, 0, \\\n-  1, 0, 0, 0, 0, 0, 1, 1, \\\n-  0, 0, 0, 0, 0, 0, 0, 0  }\n-\n-/* 1 for registers not available across function calls.\n-   These must include the FIXED_REGISTERS and also any\n-   registers that can be used without being saved.\n-   The latter must include the registers where values are returned\n-   and the register where structure-value addresses are passed.\n-   Aside from that, you can include as many other registers as you like.\n-   The Alliant calling sequence allows a function to use any register,\n-   so we include them all here.  */\n-\n-#define CALL_USED_REGISTERS \\\n- {1, 1, 1, 1, 1, 1, 1, 1, \\\n-  1, 1, 1, 1, 1, 1, 1, 1, \\\n-  1, 1, 1, 1, 1, 1, 1, 1  }\n-\n-/* Return number of consecutive hard regs needed starting at reg REGNO\n-   to hold something of mode MODE.\n-   This is ordinarily the length in words of a value of mode MODE\n-   but can be less for certain modes in special long registers.\n-\n-   On the Alliant, ordinary registers hold 32 bits worth;\n-   for the FP registers, a single register is always enough for\n-   any floating-point value.  */\n-#define HARD_REGNO_NREGS(REGNO, MODE)   \\\n-  ((REGNO) >= 16 ? GET_MODE_NUNITS (MODE)\t\\\n-   : ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD))\n-\n-/* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.\n-   On the Alliant, the cpu registers can hold any mode but the FP registers\n-   can hold only floating point.  */\n-#define HARD_REGNO_MODE_OK(REGNO, MODE)\t\t\\\n-  ((REGNO) < 16 || GET_MODE_CLASS (MODE) == MODE_FLOAT\t\\\n-   || GET_MODE_CLASS (MODE) == MODE_COMPLEX_FLOAT)\n-\n-/* Value is 1 if it is a good idea to tie two pseudo registers\n-   when one has mode MODE1 and one has mode MODE2.\n-   If HARD_REGNO_MODE_OK could produce different values for MODE1 and MODE2,\n-   for any hard reg, then this must be 0 for correct output.  */\n-#define MODES_TIEABLE_P(MODE1, MODE2)\t\t\t\\\n-   (((MODE1) == SFmode || (MODE1) == DFmode\t\t\\\n-     || (MODE1) == SCmode || (MODE1) == DCmode)\t\t\\\n-       == ((MODE2) == SFmode || (MODE2) == DFmode\t\\\n-\t   || (MODE2) == SCmode || (MODE2) == DCmode))\n-\n-/* Specify the registers used for certain standard purposes.\n-   The values of these macros are register numbers.  */\n-\n-/* m68000 pc isn't overloaded on a register.  */\n-/* #define PC_REGNUM  */\n-\n-/* Register to use for pushing function arguments.  */\n-#define STACK_POINTER_REGNUM 15\n-\n-/* Base register for access to local variables of the function.  */\n-#define FRAME_POINTER_REGNUM 14\n-\n-/* Value should be nonzero if functions must have frame pointers.\n-   Zero means the frame pointer need not be set up (and parms\n-   may be accessed via the stack pointer) in functions that seem suitable.\n-   This is computed in `reload', in reload1.c.  */\n-/* Set for now on Alliant until we find a way to make this work with\n-   their calling sequence.  */\n-#define FRAME_POINTER_REQUIRED 1\n-\n-/* Base register for access to arguments of the function.  */\n-#define ARG_POINTER_REGNUM  8 \n-\n-/* Register in which static-chain is passed to a function.  */\n-#define STATIC_CHAIN_REGNUM 10\n-\n-/* Register in which address to store a structure value\n-   is passed to a function.  */\n-#define STRUCT_VALUE_REGNUM 9\n-\f\n-/* Define the classes of registers for register constraints in the\n-   machine description.  Also define ranges of constants.\n-\n-   One of the classes must always be named ALL_REGS and include all hard regs.\n-   If there is more than one class, another class must be named NO_REGS\n-   and contain no registers.\n-\n-   The name GENERAL_REGS must be the name of a class (or an alias for\n-   another name such as ALL_REGS).  This is the class of registers\n-   that is allowed by \"g\" or \"r\" in a register constraint.\n-   Also, registers outside this class are allocated only when\n-   instructions express preferences for them.\n-\n-   The classes must be numbered in nondecreasing order; that is,\n-   a larger-numbered class must never be contained completely\n-   in a smaller-numbered class.\n-\n-   For any two classes, it is very desirable that there be another\n-   class that represents their union.  */\n-\n-/* The Alliant has three kinds of registers, so eight classes would be\n-   a complete set.  One of them is not needed.  */\n-\n-enum reg_class { NO_REGS, FP_REGS, DATA_REGS, DATA_OR_FP_REGS,\n-  ADDR_REGS, GENERAL_REGS, ALL_REGS, LIM_REG_CLASSES };\n-\n-#define N_REG_CLASSES (int) LIM_REG_CLASSES\n-\n-/* Give names of register classes as strings for dump file.   */\n-\n-#define REG_CLASS_NAMES \\\n- { \"NO_REGS\", \"FP_REGS\", \"DATA_REGS\", \"DATA_OR_FP_REGS\",  \\\n-   \"ADDR_REGS\", \"GENERAL_REGS\", \"ALL_REGS\" }\n-\n-/* Define which registers fit in which classes.\n-   This is an initializer for a vector of HARD_REG_SET\n-   of length N_REG_CLASSES.  */\n-\n-#define REG_CLASS_CONTENTS \\\n-{\t\t\t\t\t\\\n- 0,\t\t/* NO_REGS */\t\t\\\n- 0x00ff0000,\t/* FP_REGS */\t\t\\\n- 0x000000ff,\t/* DATA_REGS */\t\t\\\n- 0x00ff00ff,\t/* DATA_OR_FP_REGS */\t\\\n- 0x0000ff00,\t/* ADDR_REGS */\t\t\\\n- 0x0000ffff,\t/* GENERAL_REGS */\t\\\n- 0x00ffffff\t/* ALL_REGS */\t\t\\\n-}\n-\n-/* The same information, inverted:\n-   Return the class number of the smallest class containing\n-   reg number REGNO.  This could be a conditional expression\n-   or could index an array.  */\n-\n-extern enum reg_class regno_reg_class[];\n-#define REGNO_REG_CLASS(REGNO) (regno_reg_class[(REGNO)>>3])\n-\n-/* The class value for index registers, and the one for base regs.  */\n-\n-#define INDEX_REG_CLASS GENERAL_REGS\n-#define BASE_REG_CLASS ADDR_REGS\n-\n-/* Get reg_class from a letter such as appears in the machine description.  */\n-\n-#define REG_CLASS_FROM_LETTER(C) \\\n-  ((C) == 'a' ? ADDR_REGS :\t\t\t\\\n-   ((C) == 'd' ? DATA_REGS :\t\t\t\\\n-    ((C) == 'f' ? FP_REGS :\t\t\t\\\n-     NO_REGS)))\n-\n-/* The letters I, J, K, L and M in a register constraint string\n-   can be used to stand for particular ranges of immediate operands.\n-   This macro defines what the ranges are.\n-   C is the letter, and VALUE is a constant value.\n-   Return 1 if VALUE is in the range specified by C.\n-\n-   For the 68000, `I' is used for the range 1 to 8\n-   allowed as immediate shift counts and in addq.\n-   `J' is used for the range of signed numbers that fit in 16 bits.\n-   `K' is for numbers that moveq can't handle.\n-   `L' is for range -8 to -1, range of values that can be added with subq.  */\n-\n-#define CONST_OK_FOR_LETTER_P(VALUE, C)  \\\n-  ((C) == 'I' ? (VALUE) > 0 && (VALUE) <= 8 :    \\\n-   (C) == 'J' ? (VALUE) >= -0x8000 && (VALUE) <= 0x7FFF :\t\\\n-   (C) == 'K' ? (VALUE) < -0x80 || (VALUE) >= 0x80 :\t\\\n-   (C) == 'L' ? (VALUE) < 0 && (VALUE) >= -8 : 0)\n-\n-#define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C)  0\n-\n-/* Given an rtx X being reloaded into a reg required to be\n-   in class CLASS, return the class of reg to actually use.\n-   In general this is just CLASS; but on some machines\n-   in some cases it is preferable to use a more restrictive class.\n-   On the 68000 series, use a data reg if possible when the\n-   value is a constant in the range where moveq could be used\n-   and we ensure that QImodes are reloaded into data regs.  */\n-\n-#define PREFERRED_RELOAD_CLASS(X,CLASS)  \\\n-  ((GET_CODE (X) == CONST_INT\t\t\t\\\n-    && (unsigned) (INTVAL (X) + 0x80) < 0x100\t\\\n-    && (CLASS) != ADDR_REGS)\t\t\t\\\n-   ? DATA_REGS\t\t\t\t\t\\\n-   : GET_MODE (X) == QImode\t\t\t\\\n-   ? DATA_REGS\t\t\t\t\t\\\n-   : (CLASS))\n-\n-/* Return the maximum number of consecutive registers\n-   needed to represent mode MODE in a register of class CLASS.  */\n-/* On the 68000, this is the size of MODE in words,\n-   except in the FP regs, where a single reg is always enough.  */\n-#define CLASS_MAX_NREGS(CLASS, MODE)\t\\\n- ((CLASS) == FP_REGS ? 1 \\\n-  : ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD))\n-\n-/* Moves between fp regs and other regs are two insns.  */\n-#define REGISTER_MOVE_COST(CLASS1, CLASS2)\t\t\\\n-  ((((CLASS1) == FP_REGS && (CLASS2) != FP_REGS)\t\\\n-    || ((CLASS2) == FP_REGS && (CLASS1) != FP_REGS))\t\\\n-   ? 4 : 2)\n-\f\n-/* Stack layout; function entry, exit and calling.  */\n-\n-/* Define this if pushing a word on the stack\n-   makes the stack pointer a smaller address.  */\n-#define STACK_GROWS_DOWNWARD\n-\n-/* Define this if the nominal address of the stack frame\n-   is at the high-address end of the local variables;\n-   that is, each additional local variable allocated\n-   goes at a more negative offset in the frame.  */\n-#define FRAME_GROWS_DOWNWARD\n-\n-/* The Alliant uses -fcaller-saves by default.  */\n-#define DEFAULT_CALLER_SAVES\n-\n-/* Offset within stack frame to start allocating local variables at.\n-   If FRAME_GROWS_DOWNWARD, this is the offset to the END of the\n-   first local allocated.  Otherwise, it is the offset to the BEGINNING\n-   of the first local allocated.  */\n-#define STARTING_FRAME_OFFSET -4\n-\n-/* If we generate an insn to push BYTES bytes,\n-   this says how many the stack pointer really advances by.\n-   On the 68000, sp@- in a byte insn really pushes a word.  */\n-#define PUSH_ROUNDING(BYTES) (((BYTES) + 1) & ~1)\n-\n-/* Offset of first parameter from the argument pointer register value.  */\n-#define FIRST_PARM_OFFSET(FNDECL) 0\n-\n-/* Value is the number of bytes of arguments automatically\n-   popped when returning from a subroutine call.\n-   FUNDECL is the declaration node of the function (as a tree),\n-   FUNTYPE is the data type of the function (as a tree),\n-   or for a library call it is an identifier node for the subroutine name.\n-   SIZE is the number of bytes of arguments passed on the stack. \n-\n-   On the Alliant we define this as SIZE and make the calling sequence\n-   (in alliant.md) pop the args.  This wouldn't be necessary if we\n-   could add to the pending stack adjustment the size of the argument\n-   descriptors that are pushed after the arguments.  */\n-\n-#define RETURN_POPS_ARGS(FUNDECL,FUNTYPE,SIZE) (SIZE)\n-\n-/* Define how to find the value returned by a function.\n-   VALTYPE is the data type of the value (as a tree).\n-   If the precise function being called is known, FUNC is its FUNCTION_DECL;\n-   otherwise, FUNC is 0.  */\n-\n-/* On the Alliant the return value is in FP0 if real, else D0.  */\n-\n-#define FUNCTION_VALUE(VALTYPE, FUNC)  \\\n-  (TREE_CODE (VALTYPE) == REAL_TYPE \\\n-   ? gen_rtx_REG (TYPE_MODE (VALTYPE), 16) \\\n-   : gen_rtx_REG (TYPE_MODE (VALTYPE), 0))\n-\n-/* Define how to find the value returned by a library function\n-   assuming the value has mode MODE.  */\n-\n-/* On the Alliant the return value is in FP0 if real, else D0.  The\n-   Alliant library functions for floating-point emulation return their\n-   values both in FP0 and in D0/D1.  But since not all libgcc functions\n-   return the results of these directly, we cannot assume that D0/D1\n-   contain the values we expect on return from a libgcc function.  */\n-\n-#define LIBCALL_VALUE(MODE)  \\\n-  (((MODE) == DFmode || (MODE) == SFmode) \\\n-   ? gen_rtx_REG (MODE, 16) \\\n-   : gen_rtx_REG (MODE, 0))\n-\n-/* 1 if N is a possible register number for a function value.\n-   On the Alliant, D0 and FP0 are the only registers thus used.\n-   (No need to mention D1 when used as a pair with D0.)  */\n-\n-#define FUNCTION_VALUE_REGNO_P(N) (((N) & ~16) == 0)\n-\n-/* Define this if PCC uses the nonreentrant convention for returning\n-   structure and union values.  */\n-\n-#define PCC_STATIC_STRUCT_RETURN\n-\n-/* 1 if N is a possible register number for function argument passing.\n-   On the Alliant, no registers are used in this way.  */\n-\n-#define FUNCTION_ARG_REGNO_P(N) 0\n-\f\n-/* Define a data type for recording info about an argument list\n-   during the scan of that argument list.  This data type should\n-   hold all necessary information about the function itself\n-   and about the args processed so far, enough to enable macros\n-   such as FUNCTION_ARG to determine where the next arg should go.\n-\n-   On the Alliant, this is a single integer, which is a number of bytes\n-   of arguments scanned so far.  */\n-\n-#define CUMULATIVE_ARGS int\n-\n-/* Initialize a variable CUM of type CUMULATIVE_ARGS\n-   for a call to a function whose data type is FNTYPE.\n-   For a library call, FNTYPE is 0.\n-\n-   On the Alliant, the offset starts at 0.  */\n-\n-#define INIT_CUMULATIVE_ARGS(CUM,FNTYPE,LIBNAME,INDIRECT)\t\\\n- ((CUM) = 0)\n-\n-/* Update the data in CUM to advance over an argument\n-   of mode MODE and data type TYPE.\n-   (TYPE is null for libcalls where that information may not be available.)  */\n-\n-#define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED)\t\\\n- ((CUM) += ((MODE) != BLKmode\t\t\t\\\n-\t    ? (GET_MODE_SIZE (MODE) + 3) & ~3\t\\\n-\t    : (int_size_in_bytes (TYPE) + 3) & ~3))\n-\n-/* Define where to put the arguments to a function.\n-   Value is zero to push the argument on the stack,\n-   or a hard register in which to store the argument.\n-\n-   MODE is the argument's machine mode.\n-   TYPE is the data type of the argument (as a tree).\n-    This is null for libcalls where that information may\n-    not be available.\n-   CUM is a variable of type CUMULATIVE_ARGS which gives info about\n-    the preceding args and about the function being called.\n-   NAMED is nonzero if this argument is a named parameter\n-    (otherwise it is an extra parameter matching an ellipsis).  */\n-\n-/* On the Alliant all args are pushed.  */\n-\n-#define FUNCTION_ARG(CUM, MODE, TYPE, NAMED) 0\n-\n-/* For an arg passed partly in registers and partly in memory,\n-   this is the number of registers used.\n-   For args passed entirely in registers or entirely in memory, zero.  */\n-\n-#define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED) 0\n-\n-/* This macro generates the assembly code for function entry.\n-   FILE is a stdio stream to output the code to.\n-   SIZE is an int: how many units of temporary storage to allocate.\n-   Refer to the array `regs_ever_live' to determine which registers\n-   to save; `regs_ever_live[I]' is nonzero if register number I\n-   is ever used in the function.  This macro is responsible for\n-   knowing which registers should not be saved even if used.\n-   The Alliant uses caller-saves, so this macro is very simple.  */\n-\n-#define FUNCTION_PROLOGUE(FILE, SIZE)     \\\n-{ int fsize = ((SIZE) - STARTING_FRAME_OFFSET + 3) & -4;\t\\\n-  if (frame_pointer_needed)\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      if (fsize < 0x8000)\t\t\t\t\t\\\n-\tfprintf(FILE,\"\\tlinkw a6,#%d\\n\", -fsize);\t\t\\\n-      else if (TARGET_68020)\t\t\t\t\t\\\n-\tfprintf(FILE,\"\\tlinkl a6,#%d\\n\", -fsize);\t\t\\\n-      else\t\t\t\t\t\t\t\\\n-\tfprintf(FILE,\"\\tlinkw a6,#0\\n\\tsubl #%d,sp\\n\", fsize);  \\\n-      fprintf(FILE, \"\\tmovl a0,a6@(-4)\\n\" ); }}\n-\n-/* Output assembler code to FILE to increment profiler label # LABELNO\n-   for profiling a function entry.  */\n-\n-#define FUNCTION_PROFILER(FILE, LABELNO)  \\\n-  fprintf (FILE, \"\\tjbsr __mcount_\\n\")\n-\n-/* EXIT_IGNORE_STACK should be nonzero if, when returning from a function,\n-   the stack pointer does not matter.  The value is tested only in\n-   functions that have frame pointers.\n-   No definition is equivalent to always zero.  */\n-\n-#define EXIT_IGNORE_STACK 1\n-\n-/* This macro generates the assembly code for function exit,\n-   on machines that need it.  If FUNCTION_EPILOGUE is not defined\n-   then individual return instructions are generated for each\n-   return statement.  Args are same as for FUNCTION_PROLOGUE.\n-\n-   The function epilogue should not depend on the current stack pointer!\n-   It should use the frame pointer only.  This is mandatory because\n-   of alloca; we also take advantage of it to omit stack adjustments\n-   before returning.  */\n-\n-#define FUNCTION_EPILOGUE(FILE, SIZE) \\\n-{ if (frame_pointer_needed)\t\t\t\t\t\\\n-    fprintf (FILE, \"\\tunlk a6\\n\");\t\t\t\t\\\n-  fprintf (FILE, \"\\trts\\n\"); }\n-\n-/* Store in the variable DEPTH the initial difference between the\n-   frame pointer reg contents and the stack pointer reg contents,\n-   as of the start of the function body.  This depends on the layout\n-   of the fixed parts of the stack frame and on how registers are saved.  */\n-\n-#define INITIAL_FRAME_POINTER_OFFSET(DEPTH)\t\t\t\\\n-{\t\t\t\t\t\t\t\t\\\n-  int regno;\t\t\t\t\t\t\t\\\n-  int offset = -4;\t\t\t\t\t\t\\\n-  for (regno = 16; regno < FIRST_PSEUDO_REGISTER; regno++)\t\\\n-    if (regs_ever_live[regno] && ! call_used_regs[regno])\t\\\n-      offset += 12;\t\t\t\t\t\t\\\n-  for (regno = 0; regno < 16; regno++)\t\t\t\t\\\n-    if (regs_ever_live[regno] && ! call_used_regs[regno])\t\\\n-      offset += 4;\t\t\t\t\t\t\\\n-  (DEPTH) = offset - ((get_frame_size () + 3) & -4);\t\t\\\n-}\n-\f\n-/* Addressing modes, and classification of registers for them.  */\n-\n-#define HAVE_POST_INCREMENT 1\n-/* #define HAVE_POST_DECREMENT 0 */\n-\n-#define HAVE_PRE_DECREMENT 1\n-/* #define HAVE_PRE_INCREMENT 0 */\n-\n-/* Macros to check register numbers against specific register classes.  */\n-\n-/* These assume that REGNO is a hard or pseudo reg number.\n-   They give nonzero only if REGNO is a hard reg of the suitable class\n-   or a pseudo reg currently allocated to a suitable hard reg.\n-   Since they use reg_renumber, they are safe only once reg_renumber\n-   has been allocated, which happens in local-alloc.c.  */\n-\n-#define REGNO_OK_FOR_INDEX_P(REGNO) \\\n-((REGNO) < 16 || (unsigned) reg_renumber[REGNO] < 16)\n-#define REGNO_OK_FOR_BASE_P(REGNO) \\\n-(((REGNO) ^ 010) < 8 || (unsigned) (reg_renumber[REGNO] ^ 010) < 8)\n-#define REGNO_OK_FOR_DATA_P(REGNO) \\\n-((REGNO) < 8 || (unsigned) reg_renumber[REGNO] < 8)\n-#define REGNO_OK_FOR_FP_P(REGNO) \\\n-(((REGNO) ^ 020) < 8 || (unsigned) (reg_renumber[REGNO] ^ 020) < 8)\n-\n-/* Now macros that check whether X is a register and also,\n-   strictly, whether it is in a specified class.\n-\n-   These macros are specific to the 68000, and may be used only\n-   in code for printing assembler insns and in conditions for\n-   define_optimization.  */\n-\n-/* 1 if X is a data register.  */\n-\n-#define DATA_REG_P(X) (REG_P (X) && REGNO_OK_FOR_DATA_P (REGNO (X)))\n-\n-/* 1 if X is an fp register.  */\n-\n-#define FP_REG_P(X) (REG_P (X) && REGNO_OK_FOR_FP_P (REGNO (X)))\n-\n-/* 1 if X is an address register  */\n-\n-#define ADDRESS_REG_P(X) (REG_P (X) && REGNO_OK_FOR_BASE_P (REGNO (X)))\n-\f\n-/* Maximum number of registers that can appear in a valid memory address.  */\n-\n-#define MAX_REGS_PER_ADDRESS 2\n-\n-/* Recognize any constant value that is a valid address.  */\n-\n-#define CONSTANT_ADDRESS_P(X)   \\\n-  (GET_CODE (X) == LABEL_REF || GET_CODE (X) == SYMBOL_REF\t\t\\\n-   || GET_CODE (X) == CONST_INT || GET_CODE (X) == CONST\t\t\\\n-   || GET_CODE (X) == HIGH)\n-\n-/* Nonzero if the constant value X is a legitimate general operand.\n-   It is given that X satisfies CONSTANT_P or is a CONST_DOUBLE.  */\n-\n-/* Alliant FP instructions don't take immediate operands, so this\n-   forces them into memory.  */\n-#define LEGITIMATE_CONSTANT_P(X) (GET_CODE (X) != CONST_DOUBLE)\n-\n-/* The macros REG_OK_FOR..._P assume that the arg is a REG rtx\n-   and check its validity for a certain class.\n-   We have two alternate definitions for each of them.\n-   The usual definition accepts all pseudo regs; the other rejects\n-   them unless they have been allocated suitable hard regs.\n-   The symbol REG_OK_STRICT causes the latter definition to be used.\n-\n-   Most source files want to accept pseudo regs in the hope that\n-   they will get allocated to the class that the insn wants them to be in.\n-   Source files for reload pass need to be strict.\n-   After reload, it makes no difference, since pseudo regs have\n-   been eliminated by then.  */\n-\n-#ifndef REG_OK_STRICT\n-\n-/* Nonzero if X is a hard reg that can be used as an index\n-   or if it is a pseudo reg.  */\n-#define REG_OK_FOR_INDEX_P(X) ((REGNO (X) ^ 020) >= 8)\n-/* Nonzero if X is a hard reg that can be used as a base reg\n-   or if it is a pseudo reg.  */\n-#define REG_OK_FOR_BASE_P(X) ((REGNO (X) & ~027) != 0)\n-\n-#else\n-\n-/* Nonzero if X is a hard reg that can be used as an index.  */\n-#define REG_OK_FOR_INDEX_P(X) REGNO_OK_FOR_INDEX_P (REGNO (X))\n-/* Nonzero if X is a hard reg that can be used as a base reg.  */\n-#define REG_OK_FOR_BASE_P(X) REGNO_OK_FOR_BASE_P (REGNO (X))\n-\n-#endif\n-\f\n-/* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression\n-   that is a valid memory address for an instruction.\n-   The MODE argument is the machine mode for the MEM expression\n-   that wants to use this address.\n-\n-   The other macros defined here are used only in GO_IF_LEGITIMATE_ADDRESS.  */\n-\n-#define INDIRECTABLE_1_ADDRESS_P(X)  \\\n-  (CONSTANT_ADDRESS_P (X)\t\t\t\t\t\t\\\n-   || (GET_CODE (X) == REG && REG_OK_FOR_BASE_P (X))\t\t\t\\\n-   || ((GET_CODE (X) == PRE_DEC || GET_CODE (X) == POST_INC)\t\t\\\n-       && REG_P (XEXP (X, 0))\t\t\t\t\t\t\\\n-       && REG_OK_FOR_BASE_P (XEXP (X, 0)))\t\t\t\t\\\n-   || (GET_CODE (X) == PLUS\t\t\t\t\t\t\\\n-       && REG_P (XEXP (X, 0)) && REG_OK_FOR_BASE_P (XEXP (X, 0))\t\\\n-       && GET_CODE (XEXP (X, 1)) == CONST_INT\t\t\t\t\\\n-       && ((unsigned) INTVAL (XEXP (X, 1)) + 0x8000) < 0x10000))\n-\n-#define GO_IF_NONINDEXED_ADDRESS(X, ADDR)  \\\n-{ if (INDIRECTABLE_1_ADDRESS_P (X)) goto ADDR; }\n-\n-#define GO_IF_INDEXABLE_BASE(X, ADDR)\t\\\n-{ if (GET_CODE (X) == LABEL_REF) goto ADDR;\t\t\t\t\\\n-  if (GET_CODE (X) == REG && REG_OK_FOR_BASE_P (X)) goto ADDR; }\n-\n-#define GO_IF_INDEXING(X, ADDR)\t\\\n-{ if (GET_CODE (X) == PLUS && LEGITIMATE_INDEX_P (XEXP (X, 0)))\t\t\\\n-    { GO_IF_INDEXABLE_BASE (XEXP (X, 1), ADDR); }\t\t\t\\\n-  if (GET_CODE (X) == PLUS && LEGITIMATE_INDEX_P (XEXP (X, 1)))\t\t\\\n-    { GO_IF_INDEXABLE_BASE (XEXP (X, 0), ADDR); } }\n-\n-#define GO_IF_INDEXED_ADDRESS(X, ADDR)\t \\\n-{ GO_IF_INDEXING (X, ADDR);\t\t\t\t\t\t\\\n-  if (GET_CODE (X) == PLUS)\t\t\t\t\t\t\\\n-    { if (GET_CODE (XEXP (X, 1)) == CONST_INT\t\t\t\t\\\n-\t  && (unsigned) INTVAL (XEXP (X, 1)) + 0x80 < 0x100)\t\t\\\n-\t{ rtx go_temp = XEXP (X, 0); GO_IF_INDEXING (go_temp, ADDR); }\t\\\n-      if (GET_CODE (XEXP (X, 0)) == CONST_INT\t\t\t\t\\\n-\t  && (unsigned) INTVAL (XEXP (X, 0)) + 0x80 < 0x100)\t\t\\\n-\t{ rtx go_temp = XEXP (X, 1); GO_IF_INDEXING (go_temp, ADDR); } } }\n-\n-#define LEGITIMATE_INDEX_REG_P(X)   \\\n-  ((GET_CODE (X) == REG && REG_OK_FOR_INDEX_P (X))\t\\\n-   || (GET_CODE (X) == SIGN_EXTEND\t\t\t\\\n-       && GET_CODE (XEXP (X, 0)) == REG\t\t\t\\\n-       && GET_MODE (XEXP (X, 0)) == HImode\t\t\\\n-       && REG_OK_FOR_INDEX_P (XEXP (X, 0))))\n-\n-#define LEGITIMATE_INDEX_P(X)   \\\n-   (LEGITIMATE_INDEX_REG_P (X)\t\t\t\t\\\n-    || (TARGET_68020 && GET_CODE (X) == MULT\t\t\\\n-\t&& LEGITIMATE_INDEX_REG_P (XEXP (X, 0))\t\t\\\n-\t&& GET_CODE (XEXP (X, 1)) == CONST_INT\t\t\\\n-\t&& (INTVAL (XEXP (X, 1)) == 2\t\t\t\\\n-\t    || INTVAL (XEXP (X, 1)) == 4\t\t\\\n-\t    || INTVAL (XEXP (X, 1)) == 8)))\n-\n-#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)  \\\n-{ GO_IF_NONINDEXED_ADDRESS (X, ADDR);\t\t\t\\\n-  GO_IF_INDEXED_ADDRESS (X, ADDR); }\n-\f\n-/* Try machine-dependent ways of modifying an illegitimate address\n-   to be legitimate.  If we find one, return the new, valid address.\n-   This macro is used in only one place: `memory_address' in explow.c.\n-\n-   OLDX is the address as it was before break_out_memory_refs was called.\n-   In some cases it is useful to look at this to decide what needs to be done.\n-\n-   MODE and WIN are passed so that this macro can use\n-   GO_IF_LEGITIMATE_ADDRESS.\n-\n-   It is always safe for this macro to do nothing.  It exists to recognize\n-   opportunities to optimize the output.\n-\n-   For the 68000, we handle X+REG by loading X into a register R and\n-   using R+REG.  R will go in an address reg and indexing will be used.\n-   However, if REG is a broken-out memory address or multiplication,\n-   nothing needs to be done because REG can certainly go in an address reg.  */\n-\n-#define LEGITIMIZE_ADDRESS(X,OLDX,MODE,WIN)   \\\n-{ register int ch = (X) != (OLDX);\t\t\t\t\t\\\n-  if (GET_CODE (X) == PLUS)\t\t\t\t\t\t\\\n-    { if (GET_CODE (XEXP (X, 0)) == MULT)\t\t\t\t\\\n-\tch = 1, XEXP (X, 0) = force_operand (XEXP (X, 0), 0);\t\t\\\n-      if (GET_CODE (XEXP (X, 1)) == MULT)\t\t\t\t\\\n-\tch = 1, XEXP (X, 1) = force_operand (XEXP (X, 1), 0);\t\t\\\n-      if (ch && GET_CODE (XEXP (X, 1)) == REG\t\t\t\t\\\n-\t  && GET_CODE (XEXP (X, 0)) == REG)\t\t\t\t\\\n-\tgoto WIN;\t\t\t\t\t\t\t\\\n-      if (ch) { GO_IF_LEGITIMATE_ADDRESS (MODE, X, WIN); }\t\t\\\n-      if (GET_CODE (XEXP (X, 0)) == REG\t\t\t\t\t\\\n-\t       || (GET_CODE (XEXP (X, 0)) == SIGN_EXTEND\t\t\\\n-\t\t   && GET_CODE (XEXP (XEXP (X, 0), 0)) == REG\t\t\\\n-\t\t   && GET_MODE (XEXP (XEXP (X, 0), 0)) == HImode))\t\\\n-\t{ register rtx temp = gen_reg_rtx (Pmode);\t\t\t\\\n-\t  register rtx val = force_operand (XEXP (X, 1), 0);\t\t\\\n-\t  emit_move_insn (temp, val);\t\t\t\t\t\\\n-\t  XEXP (X, 1) = temp;\t\t\t\t\t\t\\\n-\t  goto WIN; }\t\t\t\t\t\t\t\\\n-      else if (GET_CODE (XEXP (X, 1)) == REG\t\t\t\t\\\n-\t       || (GET_CODE (XEXP (X, 1)) == SIGN_EXTEND\t\t\\\n-\t\t   && GET_CODE (XEXP (XEXP (X, 1), 0)) == REG\t\t\\\n-\t\t   && GET_MODE (XEXP (XEXP (X, 1), 0)) == HImode))\t\\\n-\t{ register rtx temp = gen_reg_rtx (Pmode);\t\t\t\\\n-\t  register rtx val = force_operand (XEXP (X, 0), 0);\t\t\\\n-\t  emit_move_insn (temp, val);\t\t\t\t\t\\\n-\t  XEXP (X, 0) = temp;\t\t\t\t\t\t\\\n-\t  goto WIN; }}}\n-\n-/* Go to LABEL if ADDR (a legitimate address expression)\n-   has an effect that depends on the machine mode it is used for.\n-   On the 68000, only predecrement and postincrement address depend thus\n-   (the amount of decrement or increment being the length of the operand).  */\n-\n-#define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR,LABEL)\t\\\n- if (GET_CODE (ADDR) == POST_INC || GET_CODE (ADDR) == PRE_DEC) goto LABEL\n-\f\n-/* Specify the machine mode that this machine uses\n-   for the index in the tablejump instruction.  */\n-#define CASE_VECTOR_MODE HImode\n-\n-/* Define as C expression which evaluates to nonzero if the tablejump\n-   instruction expects the table to contain offsets from the address of the\n-   table.\n-   Do not define this if the table should contain absolute addresses. */\n-#define CASE_VECTOR_PC_RELATIVE 1\n-\n-/* Specify the tree operation to be used to convert reals to integers.  */\n-#define IMPLICIT_FIX_EXPR FIX_ROUND_EXPR\n-\n-/* This is the kind of divide that is easiest to do in the general case.  */\n-#define EASY_DIV_EXPR TRUNC_DIV_EXPR\n-\n-/* Define this as 1 if `char' should by default be signed; else as 0.  */\n-#define DEFAULT_SIGNED_CHAR 1\n-\n-/* Max number of bytes we can move from memory to memory\n-   in one reasonably fast instruction.  */\n-#define MOVE_MAX 4\n-\n-/* Define this if zero-extension is slow (more than one real instruction).  */\n-#define SLOW_ZERO_EXTEND\n-\n-/* Nonzero if access to memory by bytes is slow and undesirable.  */\n-#define SLOW_BYTE_ACCESS 0\n-\n-/* Define this to be nonzero if shift instructions ignore all but the low-order\n-   few bits. */\n-#define SHIFT_COUNT_TRUNCATED 1\n-\n-/* Value is 1 if truncating an integer of INPREC bits to OUTPREC bits\n-   is done just by pretending it is already truncated.  */\n-#define TRULY_NOOP_TRUNCATION(OUTPREC, INPREC) 1\n-\n-/* We assume that the store-condition-codes instructions store 0 for false\n-   and some other value for true.  This is the value stored for true.  */\n-\n-#define STORE_FLAG_VALUE (-1)\n-\n-/* When a prototype says `char' or `short', really pass an `int'.  */\n-#define PROMOTE_PROTOTYPES 1\n-\n-/* Specify the machine mode that pointers have.\n-   After generation of rtl, the compiler makes no further distinction\n-   between pointers and any other objects of this machine mode.  */\n-#define Pmode SImode\n-\n-/* A function address in a call instruction\n-   is a byte address (for indexing purposes)\n-   so give the MEM rtx a byte's mode.  */\n-#define FUNCTION_MODE QImode\n-\n-/* Compute the cost of computing a constant rtl expression RTX\n-   whose rtx-code is CODE.  The body of this macro is a portion\n-   of a switch statement.  If the code is computed here,\n-   return it with a return statement.  Otherwise, break from the switch.  */\n-\n-#define CONST_COSTS(RTX,CODE,OUTER_CODE) \\\n-  case CONST_INT:\t\t\t\t\t\t\\\n-    /* Constant zero is super cheap due to clr instruction.  */\t\\\n-    if (RTX == const0_rtx) return 0;\t\t\t\t\\\n-    if ((unsigned) INTVAL (RTX) < 077) return 1;\t\t\\\n-  case CONST:\t\t\t\t\t\t\t\\\n-  case LABEL_REF:\t\t\t\t\t\t\\\n-  case SYMBOL_REF:\t\t\t\t\t\t\\\n-    return 3;\t\t\t\t\t\t\t\\\n-  case CONST_DOUBLE:\t\t\t\t\t\t\\\n-    return 5;\n-\n-/* Check a `double' value for validity for a particular machine mode.\n-   This is defined to avoid crashes outputting certain constants.  */\n-\n-#define CHECK_FLOAT_VALUE(MODE, D, OVERFLOW)\t\t\t\t\\\n-  if (OVERFLOW)\t\t\t\t\t\t\t\t\\\n-    (D) = 3.4028234663852890e+38;\t\t\t\t\t\\\n-  else if ((MODE) == SFmode)\t\t\t\t\t\t\\\n-    { \t\t\t\t\t\t\t\t\t\\\n-      if ((d) > 3.4028234663852890e+38)\t\t\t\t\t\\\n-\t(OVERFLOW) = 1, (D) = 3.4028234663852890e+38;\t\t\t\\\n-      else if ((D) < -3.4028234663852890e+38)\t\t\t\t\\\n-\t(OVERFLOW) = 1, (D) = -3.4028234663852890e+38;\t\t\t\\\n-      else if (((D) > 0) && ((D) < 1.1754943508222873e-38))\t\t\\\n-\t(OVERFLOW) = 1, (D) = 0.0;\t\t\t\t\t\\\n-      else if (((d) < 0) && ((d) > -1.1754943508222873e-38))\t\t\\\n-\t(OVERFLOW) = 1, (D) = 0.0;\t\t\t\t\t\\\n-    }\n-\f\n-/* Tell final.c how to eliminate redundant test instructions.  */\n-\n-/* Here we define machine-dependent flags and fields in cc_status\n-   (see `conditions.h').  */\n-\n-/* On the Alliant, floating-point instructions do not modify the\n-   ordinary CC register.  Only fcmp and ftest instructions modify the\n-   floating-point CC register.  We should actually keep track of what\n-   both kinds of CC registers contain, but for now we only consider\n-   the most recent instruction that has set either register.  */\n-\n-/* Set if the cc value came from a floating point test, so a floating\n-   point conditional branch must be output.  */\n-#define CC_IN_FP 04000\n-\n-/* Store in cc_status the expressions\n-   that the condition codes will describe\n-   after execution of an instruction whose pattern is EXP.\n-   Do not alter them if the instruction would not alter the cc's.  */\n-\n-/* On the 68000, all the insns to store in an address register\n-   fail to set the cc's.  However, in some cases these instructions\n-   can make it possibly invalid to use the saved cc's.  In those\n-   cases we clear out some or all of the saved cc's so they won't be used.  */\n-\n-#define NOTICE_UPDATE_CC(EXP, INSN) \\\n-{\t\t\t\t\t\t\t\t\\\n-  if (GET_CODE (EXP) == SET)\t\t\t\t\t\\\n-    { if (ADDRESS_REG_P (SET_DEST (EXP)) || FP_REG_P (SET_DEST (EXP)))\t    \\\n-\t{ if (cc_status.value1\t\t\t\t\t\\\n-\t      && reg_overlap_mentioned_p (SET_DEST (EXP), cc_status.value1)) \\\n-\t    cc_status.value1 = 0;\t\t\t\t\\\n-\t  if (cc_status.value2\t\t\t\t\t\\\n-\t      && reg_overlap_mentioned_p (SET_DEST (EXP), cc_status.value2)) \\\n-\t    cc_status.value2 = 0; }\t\t\t\t\\\n-      else if (GET_CODE (SET_SRC (EXP)) == MOD\t\t\t\\\n-\t       || GET_CODE (SET_SRC (EXP)) == UMOD\t\t\\\n-\t       || (GET_CODE (SET_SRC (EXP)) == TRUNCATE\t\t\\\n-\t\t   && (GET_CODE (XEXP (SET_SRC (EXP))) == MOD\t\\\n-\t\t       || GET_CODE (XEXP (SET_SRC (EXP))) == UMOD)))\t\\\n-\t/* The swap insn produces cc's that don't correspond to the \t\\\n-\t   result.  */\t\t\t\t\t\t\\\n-        CC_STATUS_INIT;\t\t\t\t\t\t\\\n-      else if (SET_DEST (EXP) != cc0_rtx\t\t\t\t\\\n-\t       && (FP_REG_P (SET_SRC (EXP))\t\t\t\\\n-\t\t   || GET_CODE (SET_SRC (EXP)) == FIX\t\t\\\n-\t\t   || GET_CODE (SET_SRC (EXP)) == FLOAT_TRUNCATE \\\n-\t\t   || GET_CODE (SET_SRC (EXP)) == FLOAT_EXTEND)) \\\n-\t{ CC_STATUS_INIT; }\t\t\t\t\t\\\n-      /* A pair of move insns doesn't produce a useful overall cc.  */ \\\n-      else if (!FP_REG_P (SET_DEST (EXP))\t\t\t\\\n-\t       && !FP_REG_P (SET_SRC (EXP))\t\t\t\\\n-\t       && GET_MODE_SIZE (GET_MODE (SET_SRC (EXP))) > 4\t\\\n-\t       && (GET_CODE (SET_SRC (EXP)) == REG\t\t\\\n-\t\t   || GET_CODE (SET_SRC (EXP)) == MEM\t\t\\\n-\t\t   || GET_CODE (SET_SRC (EXP)) == CONST_DOUBLE))\\\n-\t{ CC_STATUS_INIT; }\t\t\t\t\t\\\n-      else if (GET_CODE (SET_SRC (EXP)) == CALL)\t\t\\\n-\t{ CC_STATUS_INIT; }\t\t\t\t\t\\\n-      else if (XEXP (EXP, 0) != pc_rtx)\t\t\t\t\\\n-\t{ cc_status.flags = 0;\t\t\t\t\t\\\n-\t  cc_status.value1 = XEXP (EXP, 0);\t\t\t\\\n-\t  cc_status.value2 = XEXP (EXP, 1); } }\t\t\t\\\n-  else if (GET_CODE (EXP) == PARALLEL\t\t\t\t\\\n-\t   && GET_CODE (XVECEXP (EXP, 0, 0)) == SET)\t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      if (ADDRESS_REG_P (XEXP (XVECEXP (EXP, 0, 0), 0)))\t\\\n-\tCC_STATUS_INIT;\t\t\t\t\t\t\\\n-      else if (XEXP (XVECEXP (EXP, 0, 0), 0) != pc_rtx)\t\t\\\n-\t{ cc_status.flags = 0;\t\t\t\t\t\\\n-\t  cc_status.value1 = XEXP (XVECEXP (EXP, 0, 0), 0);\t\\\n-\t  cc_status.value2 = XEXP (XVECEXP (EXP, 0, 0), 1); } }\t\\\n-  else CC_STATUS_INIT;\t\t\t\t\t\t\\\n-  if (cc_status.value2 != 0\t\t\t\t\t\\\n-      && ADDRESS_REG_P (cc_status.value2)\t\t\t\\\n-      && GET_MODE (cc_status.value2) == QImode)\t\t\t\\\n-    CC_STATUS_INIT;\t\t\t\t\t\t\\\n-  if (cc_status.value2 != 0)\t\t\t\t\t\\\n-    switch (GET_CODE (cc_status.value2))\t\t\t\\\n-      { case PLUS: case MINUS: case MULT:\t\t\t\\\n-\tcase DIV: case UDIV: case MOD: case UMOD: case NEG:\t\\\n-\tcase ASHIFT:  case ASHIFTRT: case LSHIFTRT:\t\t\\\n-\tcase ROTATE: case ROTATERT:\t\t\t\t\\\n-\t  if (GET_MODE (cc_status.value2) != VOIDmode)\t\t\\\n-\t    cc_status.flags |= CC_NO_OVERFLOW;\t\t\t\\\n-\t  break;\t\t\t\t\t\t\\\n-\tcase ZERO_EXTEND:\t\t\t\t\t\\\n-\t  /* (SET r1 (ZERO_EXTEND r2)) on this machine\n-\t     ends with a move insn moving r2 in r2's mode.\n-\t     Thus, the cc's are set for r2.\n-\t     This can set N bit spuriously. */\t\t\t\\\n-\t  cc_status.flags |= CC_NOT_NEGATIVE; }\t\t\t\\\n-  if (cc_status.value1 && GET_CODE (cc_status.value1) == REG\t\\\n-      && cc_status.value2\t\t\t\t\t\\\n-      && reg_overlap_mentioned_p (cc_status.value1, cc_status.value2))\t\\\n-    cc_status.value2 = 0;\t\t\t\t\t\\\n-  if ((cc_status.value1 && FP_REG_P (cc_status.value1))\t\t\\\n-       || (cc_status.value2 && FP_REG_P (cc_status.value2)))\t\\\n-    cc_status.flags = CC_IN_FP; }\n-\n-#define OUTPUT_JUMP(NORMAL, FLOAT, NO_OV)  \\\n-{ if (cc_prev_status.flags & CC_IN_FP)\t\t\t\\\n-    return FLOAT;\t\t\t\t\t\t\\\n-  if (cc_prev_status.flags & CC_NO_OVERFLOW)\t\t\t\\\n-    return NO_OV;\t\t\t\t\t\t\\\n-  return NORMAL; }\n-\f\n-/* Control the assembler format that we output.  */\n-\n-/* Output at beginning of assembler file.  */\n-\n-#define ASM_FILE_START(FILE)\t\\\n-  fprintf (FILE, \"#NO_APP\\n\");\n-\n-/* Output to assembler file text saying following lines\n-   may contain character constants, extra white space, comments, etc.  */\n-\n-#define ASM_APP_ON \"#APP\\n\"\n-\n-/* Output to assembler file text saying following lines\n-   no longer contain unusual constructs.  */\n-\n-#define ASM_APP_OFF \"#NO_APP\\n\"\n-\n-/* Output before read-only data.  */\n-\n-#define TEXT_SECTION_ASM_OP \"\\t.text\"\n-\n-/* Output before writable data.  */\n-\n-#define DATA_SECTION_ASM_OP \"\\t.data\"\n-\n-/* How to refer to registers in assembler output.\n-   This sequence is indexed by compiler's hard-register-number (see above).  */\n-\n-#define REGISTER_NAMES \\\n-{\"d0\", \"d1\", \"d2\", \"d3\", \"d4\", \"d5\", \"d6\", \"d7\",\t\\\n- \"a0\", \"a1\", \"a2\", \"a3\", \"a4\", \"a5\", \"a6\", \"sp\",\t\\\n- \"fp0\", \"fp1\", \"fp2\", \"fp3\", \"fp4\", \"fp5\", \"fp6\", \"fp7\" }\n-\n-/* How to renumber registers for dbx and gdb.\n-   On the Sun-3, the floating point registers have numbers\n-   18 to 25, not 16 to 23 as they do in the compiler.  */\n-/* (On the Alliant, dbx isn't working yet at all.  */\n-\n-#define DBX_REGISTER_NUMBER(REGNO) ((REGNO) < 16 ? (REGNO) : (REGNO) + 2)\n-\n-/* This is how to output the definition of a user-level label named NAME,\n-   such as the label on a static function or variable NAME.  */\n-\n-#define ASM_OUTPUT_LABEL(FILE,NAME)\t\\\n-  do { assemble_name (FILE, NAME); fputs (\":\\n\", FILE); } while (0)\n-\n-/* This is how to output a command to make the user-level label named NAME\n-   defined for reference from other files.  */\n-\n-#define ASM_GLOBALIZE_LABEL(FILE,NAME)\t\\\n-  do { fputs (\"\\t.globl \", FILE); assemble_name (FILE, NAME); fputs (\"\\n\", FILE);} while (0)\n-\n-/* The prefix to add to user-visible assembler symbols. */\n-\n-#define USER_LABEL_PREFIX \"_\"\n-\n-/* This is how to output an internal numbered label where\n-   PREFIX is the class of label and NUM is the number within the class.  */\n-\n-#define ASM_OUTPUT_INTERNAL_LABEL(FILE,PREFIX,NUM)\t\\\n-  fprintf (FILE, \"%s%d:\\n\", PREFIX, NUM)\n-\n-/* This is how to store into the string LABEL\n-   the symbol_ref name of an internal numbered label where\n-   PREFIX is the class of label and NUM is the number within the class.\n-   This is suitable for output with `assemble_name'.  */\n-\n-#define ASM_GENERATE_INTERNAL_LABEL(LABEL,PREFIX,NUM)\t\\\n-  sprintf (LABEL, \"*%s%d\", PREFIX, NUM)\n-\n-/* This is how to output an assembler line defining a `double' constant.  */\n-\n-#define ASM_OUTPUT_DOUBLE(FILE,VALUE)  \\\n-do { union { double d; long v[2];} tem;\t\t\t\\\n-     tem.d = (VALUE);\t\t\t\t\t\\\n-     fprintf (FILE, \"\\t.long 0x%x,0x%x\\n\", tem.v[0], tem.v[1]);\t\\\n-   } while (0)\n-\n-/* This is how to output an assembler line defining a `float' constant.  */\n-\n-#define ASM_OUTPUT_FLOAT(FILE,VALUE)  \\\n-do { union { float f; long l;} tem;\t\t\t\\\n-     tem.f = (VALUE);\t\t\t\t\t\\\n-     fprintf (FILE, \"\\t.long 0x%x\\n\", tem.l);\t\\\n-   } while (0)\n-\n-/* This is how to output an assembler line defining an `int' constant.  */\n-\n-#define ASM_OUTPUT_INT(FILE,VALUE)  \\\n-( fprintf (FILE, \"\\t.long \"),\t\t\t\\\n-  output_addr_const (FILE, (VALUE)),\t\t\\\n-  fprintf (FILE, \"\\n\"))\n-\n-/* Likewise for `char' and `short' constants.  */\n-\n-#define ASM_OUTPUT_SHORT(FILE,VALUE)  \\\n-( fprintf (FILE, \"\\t.word \"),\t\t\t\\\n-  output_addr_const (FILE, (VALUE)),\t\t\\\n-  fprintf (FILE, \"\\n\"))\n-\n-#define ASM_OUTPUT_CHAR(FILE,VALUE)  \\\n-( fprintf (FILE, \"\\t.byte \"),\t\t\t\\\n-  output_addr_const (FILE, (VALUE)),\t\t\\\n-  fprintf (FILE, \"\\n\"))\n-\n-#define ASM_OUTPUT_ASCII(FILE,PTR,SIZE)               \\\n-do { int i; const unsigned char *pp = (const unsigned char *) (PTR); \\\n-  fprintf((FILE), \"\\t.byte %d\", (unsigned int)*pp++);\t\t\\\n-  for (i = 1; i < (SIZE); ++i, ++pp) {\t\t\t\t\\\n-    if ((i % 8) == 0)\t\t\t\t\t\t\\\n-      fprintf((FILE), \"\\n\\t.byte %d\", (unsigned int) *pp);\t\\\n-    else\t\t\t\t\t\t\t\\\n-      fprintf((FILE), \",%d\", (unsigned int) *pp); }\t\t\\\n-  fprintf ((FILE), \"\\n\");       } while (0)\n-\n-/* This is how to output an assembler line for a numeric constant byte.  */\n-\n-#define ASM_OUTPUT_BYTE(FILE,VALUE)  \\\n-  fprintf (FILE, \"\\t.byte 0x%x\\n\", (VALUE))\n-\n-/* This is how to output an insn to push a register on the stack.\n-   It need not be very fast code.  */\n-\n-#define ASM_OUTPUT_REG_PUSH(FILE,REGNO)  \\\n-  fprintf (FILE, \"\\tmovl %s,sp@-\\n\", reg_names[REGNO])\n-\n-/* This is how to output an insn to pop a register from the stack.\n-   It need not be very fast code.  */\n-\n-#define ASM_OUTPUT_REG_POP(FILE,REGNO)  \\\n-  fprintf (FILE, \"\\tmovl sp@+,%s\\n\", reg_names[REGNO])\n-\n-/* This is how to output an element of a case-vector that is absolute.\n-   (The 68000 does not use such vectors,\n-   but we must define this macro anyway.)  */\n-\n-#define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)  \\\n-  fprintf (FILE, \"\\t.long L%d\\n\", VALUE)\n-\n-/* This is how to output an element of a case-vector that is relative.  */\n-\n-#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL)  \\\n-  fprintf (FILE, \"\\t.word L%d-L%d\\n\", VALUE, REL)\n-\n-/* This is how to output an assembler line\n-   that says to advance the location counter\n-   to a multiple of 2**LOG bytes.  */\n-\n-#define ASM_OUTPUT_ALIGN(FILE,LOG)\t\\\n-  if ((LOG) == 1)\t\t\t\\\n-    fprintf (FILE, \"\\t.even\\n\");\t\\\n-  else if ((LOG) != 0)\t\t\t\\\n-    fprintf (FILE, \"\\t.align %dn\", (LOG));\t\n-\n-#define ASM_OUTPUT_SKIP(FILE,SIZE)  \\\n-  fprintf (FILE, \"\\t. = . + %u\\n\", (SIZE))\n-\n-/* This says how to output an assembler line\n-   to define a global common symbol.  */\n-\n-#define ASM_OUTPUT_COMMON(FILE, NAME, SIZE, ROUNDED)  \\\n-( fputs (\"\\t.comm \", (FILE)),\t\t\t\\\n-  assemble_name ((FILE), (NAME)),\t\t\\\n-  fprintf ((FILE), \",%u\\n\", (ROUNDED)))\n-\n-/* This says how to output an assembler line\n-   to define a local common symbol.  */\n-\n-#define ASM_OUTPUT_LOCAL(FILE, NAME, SIZE, ROUNDED)  \\\n-( fputs (\"\\t.lcomm \", (FILE)),\t\t\t\\\n-  assemble_name ((FILE), (NAME)),\t\t\\\n-  fprintf ((FILE), \",%u\\n\", (ROUNDED)))\n-\n-/* Store in OUTPUT a string (made with alloca) containing\n-   an assembler-name for a local static variable named NAME.\n-   LABELNO is an integer which is different for each call.  */\n-\n-#define ASM_FORMAT_PRIVATE_NAME(OUTPUT, NAME, LABELNO)\t\\\n-( (OUTPUT) = (char *) alloca (strlen ((NAME)) + 10),\t\\\n-  sprintf ((OUTPUT), \"%s.%d\", (NAME), (LABELNO)))\n-\n-/* Define the parentheses used to group arithmetic operations\n-   in assembler code.  */\n-\n-#define ASM_OPEN_PAREN \"(\"\n-#define ASM_CLOSE_PAREN \")\"\n-\n-/* Define results of standard character escape sequences.  */\n-#define TARGET_BELL 007\n-#define TARGET_BS 010\n-#define TARGET_TAB 011\n-#define TARGET_NEWLINE 012\n-#define TARGET_VT 013\n-#define TARGET_FF 014\n-#define TARGET_CR 015\n-\n-/* Print operand X (an rtx) in assembler syntax to file FILE.\n-   CODE is a letter or dot (`z' in `%z0') or 0 if no letter was specified.\n-   For `%' followed by punctuation, CODE is the punctuation and X is null.\n-\n-   On the Alliant, we use several CODE characters:\n-   '.' for dot needed in Motorola-style opcode names.\n-   '-' for an operand pushing on the stack:\n-       sp@-, -(sp) or -(%sp) depending on the style of syntax.\n-   '+' for an operand pushing on the stack:\n-       sp@+, (sp)+ or (%sp)+ depending on the style of syntax.\n-   '@' for a reference to the top word on the stack:\n-       sp@, (sp) or (%sp) depending on the style of syntax.\n-   '#' for an immediate operand prefix (# in MIT and Motorola syntax\n-       but & in SGS syntax).\n-   '!' for the cc register (used in an `and to cc' insn).\n-\n-   'b' for byte insn (no effect, on the Sun; this is for the ISI).\n-   'd' to force memory addressing to be absolute, not relative.\n-   'f' for float insn (print a CONST_DOUBLE as a float rather than in hex)\n-   'x' for float insn (print a CONST_DOUBLE as a float rather than in hex),\n-       or print pair of registers as rx:ry.  */\n-\n-#define PRINT_OPERAND_PUNCT_VALID_P(CODE)\t\t\t\t\\\n-  ((CODE) == '.' || (CODE) == '#' || (CODE) == '-'\t\t\t\\\n-   || (CODE) == '+' || (CODE) == '@' || (CODE) == '!')\n-\n-#define PRINT_OPERAND(FILE, X, CODE)  \\\n-{ int i;\t\t\t\t\t\t\t\t\\\n-  if (CODE == '.') ;\t\t\t\t\t\t\t\\\n-  else if (CODE == '#') fprintf (FILE, \"#\");\t\t\t\t\\\n-  else if (CODE == '-') fprintf (FILE, \"sp@-\");\t\t\t\t\\\n-  else if (CODE == '+') fprintf (FILE, \"sp@+\");\t\t\t\t\\\n-  else if (CODE == '@') fprintf (FILE, \"sp@\");\t\t\t\t\\\n-  else if (CODE == '!') fprintf (FILE, \"cc\");\t\t\t\t\\\n-  else if ((X)  == 0  ) ;\t\t\t\t\t\t\\\n-  else if (GET_CODE (X) == REG)\t\t\t\t\t\t\\\n-    { if (REGNO (X) < 16 && (CODE == 'y' || CODE == 'x') && GET_MODE (X) == DFmode)\t\\\n-        fprintf (FILE, \"%s,%s\", reg_names[REGNO (X)], reg_names[REGNO (X)+1]); \\\n-      else\t\t\t\t\t\t\t\t\\\n-        fprintf (FILE, \"%s\", reg_names[REGNO (X)]);\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-  else if (GET_CODE (X) == MEM)\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      output_address (XEXP (X, 0));\t\t\t\t\t\\\n-      if (CODE == 'd' && ! TARGET_68020\t\t\t\t\t\\\n-\t  && CONSTANT_ADDRESS_P (XEXP (X, 0))\t\t\t\t\\\n-\t  && !(GET_CODE (XEXP (X, 0)) == CONST_INT\t\t\t\\\n-\t       && INTVAL (XEXP (X, 0)) < 0x8000\t\t\t\t\\\n-\t       && INTVAL (XEXP (X, 0)) >= -0x8000))\t\t\t\\\n-\tfprintf (FILE, \":l\");\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-  else if (GET_CODE (X) == CONST_DOUBLE && GET_MODE (X) == SFmode)\t\\\n-    { union { double d; int i[2]; } u;\t\t\t\t\t\\\n-      union { float f; int i; } u1;\t\t\t\t\t\\\n-      u.i[0] = CONST_DOUBLE_LOW (X); u.i[1] = CONST_DOUBLE_HIGH (X);\t\\\n-      u1.f = u.d;\t\t\t\t\t\t\t\\\n-      if (CODE == 'f')\t\t\t\t\t\t\t\\\n-        fprintf (FILE, \"#0r%.9g\", u1.f);\t\t\t\t\\\n-      else\t\t\t\t\t\t\t\t\\\n-        fprintf (FILE, \"#0x%x\", u1.i); }\t\t\t\t\\\n-  else if (GET_CODE (X) == CONST_DOUBLE && GET_MODE (X) != VOIDmode)\t\\\n-    { union { double d; int i[2]; } u;\t\t\t\t\t\\\n-      u.i[0] = CONST_DOUBLE_LOW (X); u.i[1] = CONST_DOUBLE_HIGH (X);\t\\\n-      fprintf (FILE, \"#0r%.20g\", u.d); }\t\t\t\t\\\n-  else { putc ('#', FILE); output_addr_const (FILE, X); }}\n-\f\n-/* Note that this contains a kludge that knows that the only reason\n-   we have an address (plus (label_ref...) (reg...))\n-   is in the insn before a tablejump, and we know that m68k.md\n-   generates a label LInnn: on such an insn.  */\n-#define PRINT_OPERAND_ADDRESS(FILE, ADDR)  \\\n-{ register rtx reg1, reg2, breg, ireg;\t\t\t\t\t\\\n-  register rtx addr = ADDR;\t\t\t\t\t\t\\\n-  static char *sz = \".BW.L...D\";\t\t\t\t\t\\\n-  rtx offset;\t\t\t\t\t\t\t\t\\\n-  switch (GET_CODE (addr))\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-    case REG:\t\t\t\t\t\t\t\t\\\n-      fprintf (FILE, \"%s@\", reg_names[REGNO (addr)]);\t\t\t\\\n-      break;\t\t\t\t\t\t\t\t\\\n-    case PRE_DEC:\t\t\t\t\t\t\t\\\n-      fprintf (FILE, \"%s@-\", reg_names[REGNO (XEXP (addr, 0))]);\t\\\n-      break;\t\t\t\t\t\t\t\t\\\n-    case POST_INC:\t\t\t\t\t\t\t\\\n-      fprintf (FILE, \"%s@+\", reg_names[REGNO (XEXP (addr, 0))]);\t\\\n-      break;\t\t\t\t\t\t\t\t\\\n-    case PLUS:\t\t\t\t\t\t\t\t\\\n-      reg1 = 0;\treg2 = 0;\t\t\t\t\t\t\\\n-      ireg = 0;\tbreg = 0;\t\t\t\t\t\t\\\n-      offset = 0;\t\t\t\t\t\t\t\\\n-      if (CONSTANT_ADDRESS_P (XEXP (addr, 0)))\t\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  offset = XEXP (addr, 0);\t\t\t\t\t\\\n-\t  addr = XEXP (addr, 1);\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-      else if (CONSTANT_ADDRESS_P (XEXP (addr, 1)))\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  offset = XEXP (addr, 1);\t\t\t\t\t\\\n-\t  addr = XEXP (addr, 0);\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-      if (GET_CODE (addr) != PLUS) ;\t\t\t\t\t\\\n-      else if (GET_CODE (XEXP (addr, 0)) == SIGN_EXTEND)\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  reg1 = XEXP (addr, 0);\t\t\t\t\t\\\n-\t  addr = XEXP (addr, 1);\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-      else if (GET_CODE (XEXP (addr, 1)) == SIGN_EXTEND)\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  reg1 = XEXP (addr, 1);\t\t\t\t\t\\\n-\t  addr = XEXP (addr, 0);\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-      else if (GET_CODE (XEXP (addr, 0)) == MULT)\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  reg1 = XEXP (addr, 0);\t\t\t\t\t\\\n-\t  addr = XEXP (addr, 1);\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-      else if (GET_CODE (XEXP (addr, 1)) == MULT)\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  reg1 = XEXP (addr, 1);\t\t\t\t\t\\\n-\t  addr = XEXP (addr, 0);\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-      else if (GET_CODE (XEXP (addr, 0)) == REG)\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  reg1 = XEXP (addr, 0);\t\t\t\t\t\\\n-\t  addr = XEXP (addr, 1);\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-      else if (GET_CODE (XEXP (addr, 1)) == REG)\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  reg1 = XEXP (addr, 1);\t\t\t\t\t\\\n-\t  addr = XEXP (addr, 0);\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-      if (GET_CODE (addr) == REG || GET_CODE (addr) == MULT\t\t\\\n-\t  || GET_CODE (addr) == SIGN_EXTEND)\t\t\t\t\\\n-\t{ if (reg1 == 0) reg1 = addr; else reg2 = addr; addr = 0; }\t\\\n-/*  for OLD_INDEXING\t\t\t\t\t\t\t\\\n-      else if (GET_CODE (addr) == PLUS)\t\t\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  if (GET_CODE (XEXP (addr, 0)) == REG)\t\t\t\t\\\n-\t    {\t\t\t\t\t\t\t\t\\\n-\t      reg2 = XEXP (addr, 0);\t\t\t\t\t\\\n-\t      addr = XEXP (addr, 1);\t\t\t\t\t\\\n-\t    }\t\t\t\t\t\t\t\t\\\n-\t  else if (GET_CODE (XEXP (addr, 1)) == REG)\t\t\t\\\n-\t    {\t\t\t\t\t\t\t\t\\\n-\t      reg2 = XEXP (addr, 1);\t\t\t\t\t\\\n-\t      addr = XEXP (addr, 0);\t\t\t\t\t\\\n-\t    }\t\t\t\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-  */\t\t\t\t\t\t\t\t\t\\\n-      if (offset != 0) { if (addr != 0) abort (); addr = offset; }\t\\\n-      if ((reg1 && (GET_CODE (reg1) == SIGN_EXTEND\t\t\t\\\n-\t\t    || GET_CODE (reg1) == MULT))\t\t\t\\\n-\t  || (reg2 != 0 && REGNO_OK_FOR_BASE_P (REGNO (reg2))))\t\t\\\n-\t{ breg = reg2; ireg = reg1; }\t\t\t\t\t\\\n-      else if (reg1 != 0 && REGNO_OK_FOR_BASE_P (REGNO (reg1)))\t\t\\\n-\t{ breg = reg1; ireg = reg2; }\t\t\t\t\t\\\n-      if (ireg != 0 && breg == 0 && GET_CODE (addr) == LABEL_REF)\t\\\n-        { int scale = 1;\t\t\t\t\t\t\\\n-\t  if (GET_CODE (ireg) == MULT)\t\t\t\t\t\\\n-\t    { scale = INTVAL (XEXP (ireg, 1));\t\t\t\t\\\n-\t      ireg = XEXP (ireg, 0); }\t\t\t\t\t\\\n-\t  if (GET_CODE (ireg) == SIGN_EXTEND)\t\t\t\t\\\n-\t    fprintf (FILE, \"pc@(L%d-LI%d-2:B)[%s:W\",\t\t\t\\\n-\t\t     CODE_LABEL_NUMBER (XEXP (addr, 0)),\t\t\\\n-\t\t     CODE_LABEL_NUMBER (XEXP (addr, 0)),\t\t\\\n-\t\t     reg_names[REGNO (XEXP (ireg, 0))]); \t\t\\\n-\t  else\t\t\t\t\t\t\t\t\\\n-\t    fprintf (FILE, \"pc@(L%d-LI%d-2:B)[%s:L\",\t\t\t\\\n-\t\t     CODE_LABEL_NUMBER (XEXP (addr, 0)),\t\t\\\n-\t\t     CODE_LABEL_NUMBER (XEXP (addr, 0)),\t\t\\\n-\t\t     reg_names[REGNO (ireg)]);\t\t\t\t\\\n-\t  fprintf (FILE, \":%c\", sz[scale]);\t\t\t\t\\\n-\t  putc (']', FILE);\t\t\t\t\t\t\\\n-\t  break; }\t\t\t\t\t\t\t\\\n-      if (breg != 0 && ireg == 0 && GET_CODE (addr) == LABEL_REF)\t\\\n-        { fprintf (FILE, \"pc@(L%d-LI%d-2:B)[%s:L:B]\",\t\t\t\\\n-\t\t   CODE_LABEL_NUMBER (XEXP (addr, 0)),\t\t\t\\\n-\t\t   CODE_LABEL_NUMBER (XEXP (addr, 0)),\t\t\t\\\n-\t\t   reg_names[REGNO (breg)]);\t\t\t\t\\\n-\t  break; }\t\t\t\t\t\t\t\\\n-      if (ireg != 0 || breg != 0)\t\t\t\t\t\\\n-\t{ int scale = 1;\t\t\t\t\t\t\\\n-\t  if (breg == 0)\t\t\t\t\t\t\\\n-\t    abort ();\t\t\t\t\t\t\t\\\n-\t  if (addr && GET_CODE (addr) == LABEL_REF) abort ();\t\t\\\n-\t  fprintf (FILE, \"%s@\", reg_names[REGNO (breg)]);\t\t\\\n-\t  if (addr != 0) {\t\t\t\t\t\t\\\n-            putc( '(', FILE );\t\t\t\t\t\t\\\n-\t    output_addr_const (FILE, addr);\t\t\t\t\\\n-            if (ireg != 0) {\t\t\t\t\t\t\\\n-              if (GET_CODE(addr) == CONST_INT) {\t\t\t\\\n-                int size_of = 1, val = INTVAL(addr);\t\t\t\\\n-                if (val < -0x8000 || val >= 0x8000)\t\t\t\\\n-                   size_of = 4;   \t\t\t\t\t\\\n-                else if (val < -0x80 || val >= 0x80)\t\t\t\\\n-                   size_of = 2;\t\t\t\t\t\t\\\n-                fprintf(FILE, \":%c\", sz[size_of]);\t\t\t\\\n-              }        \t\t\t\t\t\t\t\\\n-              else\t\t\t\t\t\t\t\\\n-                fprintf(FILE, \":L\"); } \t\t\t\t\t\\\n-            putc( ')', FILE ); }\t\t\t\t\t\\\n-\t  if (ireg != 0) {\t\t\t\t\t\t\\\n-\t    putc ('[', FILE);\t\t\t\t\t\t\\\n-\t    if (ireg != 0 && GET_CODE (ireg) == MULT)\t\t\t\\\n-\t      { scale = INTVAL (XEXP (ireg, 1));\t\t\t\\\n-\t        ireg = XEXP (ireg, 0); }\t\t\t\t\\\n-\t    if (ireg != 0 && GET_CODE (ireg) == SIGN_EXTEND)\t\t\\\n-\t      fprintf (FILE, \"%s:W\", reg_names[REGNO (XEXP (ireg, 0))]);\t\\\n-\t    else if (ireg != 0)\t\t\t\t\t\t\\\n-\t      fprintf (FILE, \"%s:L\", reg_names[REGNO (ireg)]);\t\t\\\n-\t    fprintf (FILE, \":%c\", sz[scale]);\t\t\t\t\\\n-\t    putc (']', FILE);\t\t\t\t\t\t\\\n-          }\t\t\t\t\t\t\t\t\\\n-\t  break;\t\t\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-      else if (reg1 != 0 && GET_CODE (addr) == LABEL_REF)\t\t\\\n-\t{ fprintf (FILE, \"pc@(L%d-LI%d-2:B)[%s:L:B]\",\t\t\t\\\n-\t\t   CODE_LABEL_NUMBER (XEXP (addr, 0)),\t\t\t\\\n-\t\t   CODE_LABEL_NUMBER (XEXP (addr, 0)),\t\t\t\\\n-\t\t   reg_names[REGNO (reg1)]);\t\t\t\t\\\n-\t  break; }\t\t\t\t\t\t\t\\\n-    default:\t\t\t\t\t\t\t\t\\\n-      if (GET_CODE (addr) == CONST_INT\t\t\t\t\t\\\n-\t  && INTVAL (addr) < 0x8000\t\t\t\t\t\\\n-\t  && INTVAL (addr) >= -0x8000)\t\t\t\t\t\\\n-\tfprintf (FILE, \"%d:W\", INTVAL (addr));\t\t\t\t\\\n-      else\t\t\t\t\t\t\t\t\\\n-        output_addr_const (FILE, addr);\t\t\t\t\t\\\n-    }}\n-\f\n-/*\n-Local variables:\n-version-control: t\n-End:\n-*/\n-"}, {"sha": "5cb320bcfabba4ae210ac6190eb8544b92239c44", "filename": "gcc/config/fx80/fx80.md", "status": "removed", "additions": 0, "deletions": 2510, "changes": 2510, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7b4171a5b8a655097812307bbe261032dfbe366/gcc%2Fconfig%2Ffx80%2Ffx80.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7b4171a5b8a655097812307bbe261032dfbe366/gcc%2Fconfig%2Ffx80%2Ffx80.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffx80%2Ffx80.md?ref=a7b4171a5b8a655097812307bbe261032dfbe366", "patch": "@@ -1,2510 +0,0 @@\n-;;- Machine description for GNU C compiler for Alliant FX systems\n-;;  Copyright (C) 1989, 1994, 1996, 1998, 1999 Free Software Foundation, Inc.\n-;;  Adapted from m68k.md by Paul Petersen (petersen@uicsrd.csrd.uiuc.edu)\n-;;  and Joe Weening (weening@gang-of-four.stanford.edu).\n-\n-;; This file is part of GNU CC.\n-\n-;; GNU CC is free software; you can redistribute it and/or modify\n-;; it under the terms of the GNU General Public License as published by\n-;; the Free Software Foundation; either version 2, or (at your option)\n-;; any later version.\n-\n-;; GNU CC is distributed in the hope that it will be useful,\n-;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n-;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-;; GNU General Public License for more details.\n-\n-;; You should have received a copy of the GNU General Public License\n-;; along with GNU CC; see the file COPYING.  If not, write to\n-;; the Free Software Foundation, 59 Temple Place - Suite 330,\n-;; Boston, MA 02111-1307, USA.\n-\n-\n-;;- instruction definitions\n-\n-;;- @@The original PO technology requires these to be ordered by speed,\n-;;- @@    so that assigner will pick the fastest.\n-\n-;;- See file \"rtl.def\" for documentation on define_insn, match_*, et. al.\n-\n-;;- When naming insn's (operand 0 of define_insn) be careful about using\n-;;- names from other targets machine descriptions.\n-\n-;;- cpp macro #define NOTICE_UPDATE_CC in file tm.h handles condition code\n-;;- updates for most instructions.\n-\n-;;- Operand classes for the register allocator:\n-;;- 'a' one of the address registers can be used.\n-;;- 'd' one of the data registers can be used.\n-;;- 'f' one of the CE floating point registers can be used\n-;;- 'r' either a data or an address register can be used.\n-\n-;;- Immediate integer operand constraints:\n-;;- 'I'  1 .. 8\n-;;- 'J'  -32768 .. 32767\n-;;- 'K'  -128 .. 127\n-;;- 'L'  -8 .. -1\n-\n-;;- Some remnants of constraint codes for the m68k ('x','y','G','H')\n-;;- may remain in the insn definitions.\n-\n-;;- Some of these insn's are composites of several Alliant op codes.\n-;;- The assembler (or final @@??) insures that the appropriate one is\n-;;- selected.\n-\f\n-;; We don't want to allow a constant operand for test insns because\n-;; (set (cc0) (const_int foo)) has no mode information.  Such insns will\n-;; be folded while optimizing anyway.\n-\n-(define_insn \"tstsi\"\n-  [(set (cc0)\n-\t(match_operand:SI 0 \"nonimmediate_operand\" \"rm\"))]\n-  \"\"\n-  \"*\n-{\n-  if (TARGET_68020 || ! ADDRESS_REG_P (operands[0]))\n-    return \\\"tst%.l %0\\\";\n-  /* If you think that the 68020 does not support tstl a0,\n-     reread page B-167 of the 68020 manual more carefully.  */\n-  /* On an address reg, cmpw may replace cmpl.  */\n-  return \\\"cmp%.w %#0,%0\\\";\n-}\")\n-\n-(define_insn \"tsthi\"\n-  [(set (cc0)\n-\t(match_operand:HI 0 \"nonimmediate_operand\" \"rm\"))]\n-  \"\"\n-  \"*\n-{\n-  if (TARGET_68020 || ! ADDRESS_REG_P (operands[0]))\n-    return \\\"tst%.w %0\\\";\n-  return \\\"cmp%.w %#0,%0\\\";\n-}\")\n-\n-(define_insn \"tstqi\"\n-  [(set (cc0)\n-\t(match_operand:QI 0 \"nonimmediate_operand\" \"dm\"))]\n-  \"\"\n-  \"tst%.b %0\")\n-\n-(define_insn \"tstsf\"\n-  [(set (cc0)\n-\t(match_operand:SF 0 \"nonimmediate_operand\" \"fm\"))]\n-  \"TARGET_CE\"\n-  \"*\n-{\n-  cc_status.flags = CC_IN_FP;\n-  return \\\"ftest%.s %0\\\";\n-}\")\n-\n-(define_insn \"tstdf\"\n-  [(set (cc0)\n-\t(match_operand:DF 0 \"nonimmediate_operand\" \"fm\"))]\n-  \"TARGET_CE\"\n-  \"*\n-{\n-  cc_status.flags = CC_IN_FP;\n-  return \\\"ftest%.d %0\\\";\n-}\")\n-\f\n-;; compare instructions.\n-\n-;; A composite of the cmp, cmpa, & cmpi m68000 op codes.\n-(define_insn \"cmpsi\"\n-  [(set (cc0)\n-\t(compare (match_operand:SI 0 \"nonimmediate_operand\" \"rKs,mr,>\")\n-\t\t (match_operand:SI 1 \"general_operand\" \"mr,Ksr,>\")))]\n-  \"\"\n-  \"*\n-{\n-  if (GET_CODE (operands[0]) == MEM && GET_CODE (operands[1]) == MEM)\n-    return \\\"cmpm%.l %1,%0\\\";\n-  if (REG_P (operands[1])\n-      || (!REG_P (operands[0]) && GET_CODE (operands[0]) != MEM))\n-    {\n-      cc_status.flags |= CC_REVERSED;\n-      return \\\"cmp%.l %d0,%d1\\\"; \n-    }\n-  return \\\"cmp%.l %d1,%d0\\\";\n-}\")\n-\n-(define_insn \"cmphi\"\n-  [(set (cc0)\n-\t(compare (match_operand:HI 0 \"nonimmediate_operand\" \"rnm,d,n,m\")\n-\t\t (match_operand:HI 1 \"general_operand\" \"d,rnm,m,n\")))]\n-  \"\"\n-  \"*\n-{\n-  if (GET_CODE (operands[0]) == MEM && GET_CODE (operands[1]) == MEM)\n-    return \\\"cmpm%.w %1,%0\\\";\n-  if ((REG_P (operands[1]) && !ADDRESS_REG_P (operands[1]))\n-      || (!REG_P (operands[0]) && GET_CODE (operands[0]) != MEM))\n-    { cc_status.flags |= CC_REVERSED;\n-      return \\\"cmp%.w %d0,%d1\\\"; \n-    }\n-  return \\\"cmp%.w %d1,%d0\\\";\n-}\")\n-\n-(define_insn \"cmpqi\"\n-  [(set (cc0)\n-\t(compare (match_operand:QI 0 \"nonimmediate_operand\" \"dn,md,>\")\n-\t\t (match_operand:QI 1 \"general_operand\" \"dm,nd,>\")))]\n-  \"\"\n-  \"*\n-{\n-  if (GET_CODE (operands[0]) == MEM && GET_CODE (operands[1]) == MEM)\n-    return \\\"cmpm%.b %1,%0\\\";\n-  if (REG_P (operands[1])\n-      || (!REG_P (operands[0]) && GET_CODE (operands[0]) != MEM))\n-    {\n-      cc_status.flags |= CC_REVERSED;\n-      return \\\"cmp%.b %d0,%d1\\\";\n-    }\n-  return \\\"cmp%.b %d1,%d0\\\";\n-}\")\n-\n-(define_insn \"cmpdf\"\n-  [(set (cc0)\n-\t(compare (match_operand:DF 0 \"nonimmediate_operand\" \"f,m\")\n-\t\t (match_operand:DF 1 \"nonimmediate_operand\" \"fm,f\")))]\n-  \"TARGET_CE\"\n-  \"*\n-{\n-  cc_status.flags = CC_IN_FP;\n-  if (FP_REG_P (operands[0]))\n-    return \\\"fcmp%.d %1,%0\\\";\n-  cc_status.flags |= CC_REVERSED;\n-  return \\\"fcmp%.d %0,%1\\\";\n-}\")\n-\n-(define_insn \"cmpsf\"\n-  [(set (cc0)\n-\t(compare (match_operand:SF 0 \"nonimmediate_operand\" \"f,m\")\n-\t\t (match_operand:SF 1 \"nonimmediate_operand\" \"fm,f\")))]\n-  \"TARGET_CE\"\n-  \"*\n-{\n-  cc_status.flags = CC_IN_FP;\n-  if (FP_REG_P (operands[0]))\n-    return \\\"fcmp%.s %1,%0\\\";\n-  cc_status.flags |= CC_REVERSED;\n-  return \\\"fcmp%.s %0,%1\\\";\n-}\")\n-\f\n-;; Recognizers for btst instructions.\n-\n-(define_insn \"\"\n-  [(set (cc0) (zero_extract (match_operand:QI 0 \"memory_operand\" \"o\")\n-\t\t\t    (const_int 1)\n-\t\t\t    (minus:SI (const_int 7)\n-\t\t\t\t      (match_operand:SI 1 \"general_operand\" \"di\"))))]\n-  \"\"\n-  \"* { return output_btst (operands, operands[1], operands[0], insn, 7); }\")\n-\n-(define_insn \"\"\n-  [(set (cc0) (zero_extract (match_operand:SI 0 \"register_operand\" \"d\")\n-\t\t\t    (const_int 1)\n-\t\t\t    (minus:SI (const_int 31)\n-\t\t\t\t      (match_operand:SI 1 \"general_operand\" \"di\"))))]\n-  \"\"\n-  \"* { return output_btst (operands, operands[1], operands[0], insn, 31); }\")\n-\n-;; The following two patterns are like the previous two\n-;; except that they use the fact that bit-number operands\n-;; are automatically masked to 3 or 5 bits.\n-\n-(define_insn \"\"\n-  [(set (cc0) (zero_extract (match_operand:QI 0 \"memory_operand\" \"o\")\n-\t\t\t    (const_int 1)\n-\t\t\t    (minus:SI (const_int 7)\n-\t\t\t\t      (and:SI\n-\t\t\t\t       (match_operand:SI 1 \"general_operand\" \"d\")\n-\t\t\t\t       (const_int 7)))))]\n-  \"\"\n-  \"* { return output_btst (operands, operands[1], operands[0], insn, 7); }\")\n-\n-(define_insn \"\"\n-  [(set (cc0) (zero_extract (match_operand:SI 0 \"register_operand\" \"d\")\n-\t\t\t    (const_int 1)\n-\t\t\t    (minus:SI (const_int 31)\n-\t\t\t\t      (and:SI\n-\t\t\t\t       (match_operand:SI 1 \"general_operand\" \"d\")\n-\t\t\t\t       (const_int 31)))))]\n-  \"\"\n-  \"* { return output_btst (operands, operands[1], operands[0], insn, 31); }\")\n-\n-;; Nonoffsettable mem refs are ok in this one pattern\n-;; since we don't try to adjust them.\n-(define_insn \"\"\n-  [(set (cc0) (zero_extract (match_operand:QI 0 \"memory_operand\" \"m\")\n-\t\t\t    (const_int 1)\n-\t\t\t    (match_operand:SI 1 \"general_operand\" \"i\")))]\n-  \"GET_CODE (operands[1]) == CONST_INT\n-   && (unsigned) INTVAL (operands[1]) < 8\"\n-  \"*\n-{\n-  operands[1] = GEN_INT (7 - INTVAL (operands[1]));\n-  return output_btst (operands, operands[1], operands[0], insn, 7);\n-}\")\n-\n-\n-(define_insn \"\"\n-  [(set (cc0) (zero_extract (match_operand:SI 0 \"register_operand\" \"do\")\n-\t\t\t    (const_int 1)\n-\t\t\t    (match_operand:SI 1 \"general_operand\" \"i\")))]\n-  \"GET_CODE (operands[1]) == CONST_INT\"\n-  \"*\n-{\n-  if (GET_CODE (operands[0]) == MEM)\n-    {\n-      operands[0] = adj_offsettable_operand (operands[0],\n-\t\t\t\t\t     INTVAL (operands[1]) / 8);\n-      operands[1] = GEN_INT (7 - INTVAL (operands[1]) % 8);\n-      return output_btst (operands, operands[1], operands[0], insn, 7);\n-    }\n-  operands[1] = GEN_INT (31 - INTVAL (operands[1]));\n-  return output_btst (operands, operands[1], operands[0], insn, 31);\n-}\")\n-\n-\f\n-;; move instructions\n-\n-;; A special case in which it is not desirable\n-;; to reload the constant into a data register.\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"push_operand\" \"=m\")\n-\t(match_operand:SI 1 \"general_operand\" \"J\"))]\n-  \"GET_CODE (operands[1]) == CONST_INT\n-   && INTVAL (operands[1]) >= -0x8000\n-   && INTVAL (operands[1]) < 0x8000\"\n-  \"*\n-{\n-  if (operands[1] == const0_rtx)\n-    return \\\"clr%.l %0\\\";\n-  return \\\"pea %a1\\\";\n-}\")\n-\n-;This is never used.\n-;(define_insn \"swapsi\"\n-;  [(set (match_operand:SI 0 \"general_operand\" \"r\")\n-;\t(match_operand:SI 1 \"general_operand\" \"r\"))\n-;   (set (match_dup 1) (match_dup 0))]\n-;  \"\"\n-;  \"exg %1,%0\")\n-\n-;; Special case of fullword move when source is zero.\n-;; The reason this is special is to avoid loading a zero\n-;; into a data reg with moveq in order to store it elsewhere.\n-   \n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=a,g\")\n-\t(const_int 0))]\n-  \"\"\n-  \"@\n-   sub%.l %0,%0\n-   clr%.l %0\")\n-\n-;; General case of fullword move.  The register constraints\n-;; force integer constants in range for a moveq to be reloaded\n-;; if they are headed for memory.\n-(define_insn \"movsi\"\n-  ;; Notes: make sure no alternative allows g vs g.\n-  ;; We don't allow f-regs since fixed point cannot go in them.\n-  ;; We do allow y and x regs since fixed point is allowed in them.\n-  [(set (match_operand:SI 0 \"general_operand\" \"=g,da,y,!*x*r*m\")\n-\t(match_operand:SI 1 \"general_operand\" \"daymKs,i,g,*x*r*m\"))]\n-  \"\"\n-  \"*\n-{\n-  if (GET_CODE (operands[1]) == CONST_INT)\n-    {\n-      if (operands[1] == const0_rtx\n-\t  && (DATA_REG_P (operands[0])\n-\t      || GET_CODE (operands[0]) == MEM))\n-\treturn \\\"clr%.l %0\\\";\n-      else if (DATA_REG_P (operands[0])\n-\t       && INTVAL (operands[1]) < 128\n-\t       && INTVAL (operands[1]) >= -128)\n-\treturn \\\"moveq %1,%0\\\";\n-      else if (ADDRESS_REG_P (operands[0])\n-\t       && INTVAL (operands[1]) < 0x8000\n-\t       && INTVAL (operands[1]) >= -0x8000)\n-\treturn \\\"mov%.w %1,%0\\\";\n-      else if (push_operand (operands[0], SImode)\n-\t       && INTVAL (operands[1]) < 0x8000\n-\t       && INTVAL (operands[1]) >= -0x8000)\n-        return \\\"pea %a1\\\";\n-    }\n-  else if ((GET_CODE (operands[1]) == SYMBOL_REF\n-\t    || GET_CODE (operands[1]) == CONST)\n-\t   && push_operand (operands[0], SImode))\n-    return \\\"pea %a1\\\";\n-  else if ((GET_CODE (operands[1]) == SYMBOL_REF\n-\t    || GET_CODE (operands[1]) == CONST)\n-\t   && ADDRESS_REG_P (operands[0]))\n-    return \\\"lea %a1,%0\\\";\n-  return \\\"mov%.l %1,%0\\\";\n-}\")\n-\n-(define_insn \"movhi\"\n-  [(set (match_operand:HI 0 \"general_operand\" \"=g\")\n-\t(match_operand:HI 1 \"general_operand\" \"g\"))]\n-  \"\"\n-  \"*\n-{\n-  if (GET_CODE (operands[1]) == CONST_INT)\n-    {\n-      if (operands[1] == const0_rtx\n-\t  && (DATA_REG_P (operands[0])\n-\t      || GET_CODE (operands[0]) == MEM))\n-\treturn \\\"clr%.w %0\\\";\n-      else if (DATA_REG_P (operands[0])\n-\t       && INTVAL (operands[1]) < 128\n-\t       && INTVAL (operands[1]) >= -128)\n-        {\n-\t  return \\\"moveq %1,%0\\\";\n-\t}\n-      else if (INTVAL (operands[1]) < 0x8000\n-\t       && INTVAL (operands[1]) >= -0x8000)\n-\treturn \\\"mov%.w %1,%0\\\";\n-    }\n-  else if (CONSTANT_P (operands[1]))\n-    return \\\"mov%.l %1,%0\\\";\n-  /* Recognize the insn before a tablejump, one that refers\n-     to a table of offsets.  Such an insn will need to refer\n-     to a label on the insn.  So output one.  Use the label-number\n-     of the table of offsets to generate this label.  */\n-  if (GET_CODE (operands[1]) == MEM\n-      && GET_CODE (XEXP (operands[1], 0)) == PLUS\n-      && (GET_CODE (XEXP (XEXP (operands[1], 0), 0)) == LABEL_REF\n-\t  || GET_CODE (XEXP (XEXP (operands[1], 0), 1)) == LABEL_REF)\n-      && GET_CODE (XEXP (XEXP (operands[1], 0), 0)) != PLUS\n-      && GET_CODE (XEXP (XEXP (operands[1], 0), 1)) != PLUS)\n-    {\n-      rtx labelref;\n-      if (GET_CODE (XEXP (XEXP (operands[1], 0), 0)) == LABEL_REF)\n-\tlabelref = XEXP (XEXP (operands[1], 0), 0);\n-      else\n-\tlabelref = XEXP (XEXP (operands[1], 0), 1);\n-      ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \\\"LI\\\",\n-\t\t\t\t CODE_LABEL_NUMBER (XEXP (labelref, 0)));\n-    }\n-  return \\\"mov%.w %1,%0\\\";\n-}\")\n-\n-(define_insn \"movstricthi\"\n-  [(set (strict_low_part (match_operand:HI 0 \"general_operand\" \"+dm\"))\n-\t(match_operand:HI 1 \"general_operand\" \"rmn\"))]\n-  \"\"\n-  \"*\n-{\n-  if (operands[1] == const0_rtx)\n-    return \\\"clr%.w %0\\\";\n-  return \\\"mov%.w %1,%0\\\";\n-}\")\n-\n-(define_insn \"movqi\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"=d,*a,m,m,?*a\")\n-\t(match_operand:QI 1 \"general_operand\" \"dmi*a,d*a,dmi,?*a,m\"))]\n-  \"\"\n-  \"*\n-{\n-  rtx xoperands[4];\n-  if (ADDRESS_REG_P (operands[0]) && GET_CODE (operands[1]) == MEM)\n-    {\n-      xoperands[1] = operands[1];\n-      xoperands[2]\n-        = gen_rtx_MEM (QImode, plus_constant (stack_pointer_rtx, 1));\n-      xoperands[3] = stack_pointer_rtx;\n-      /* Just pushing a byte puts it in the high byte of the halfword.  */\n-      /* We must put it in the low half, the second byte.  */\n-      output_asm_insn (\\\"subq%.w %#2,%3\\;mov%.b %1,%2\\\", xoperands);\n-      return \\\"mov%.w %+,%0\\\";\n-    }\n-  if (ADDRESS_REG_P (operands[1]) && GET_CODE (operands[0]) == MEM)\n-    {\n-      xoperands[0] = operands[0];\n-      xoperands[1] = operands[1];\n-      xoperands[2]\n-        = gen_rtx_MEM (QImode, plus_constant (stack_pointer_rtx, 1));\n-      xoperands[3] = stack_pointer_rtx;\n-      output_asm_insn (\\\"mov%.w %1,%-\\;mov%.b %2,%0\\;addq%.w %#2,%3\\\", xoperands);\n-      return \\\"\\\";\n-    }\n-  if (operands[1] == const0_rtx)\n-    return \\\"clr%.b %0\\\";\n-  if (GET_CODE (operands[1]) == CONST_INT\n-      && INTVAL (operands[1]) == -1)\n-    return \\\"st %0\\\";\n-  if (GET_CODE (operands[1]) != CONST_INT && CONSTANT_P (operands[1]))\n-    return \\\"mov%.l %1,%0\\\";\n-  if (ADDRESS_REG_P (operands[0]) || ADDRESS_REG_P (operands[1]))\n-    return \\\"mov%.w %1,%0\\\";\n-  return \\\"mov%.b %1,%0\\\";\n-}\")\n-\n-(define_insn \"movstrictqi\"\n-  [(set (strict_low_part (match_operand:QI 0 \"general_operand\" \"+dm\"))\n-\t(match_operand:QI 1 \"general_operand\" \"dmn\"))]\n-  \"\"\n-  \"*\n-{\n-  if (operands[1] == const0_rtx)\n-    return \\\"clr%.b %0\\\";\n-  return \\\"mov%.b %1,%0\\\";\n-}\")\n-\n-;; Floating-point moves on a CE are faster using an FP register than\n-;; with movl instructions.  (Especially for double floats, but also\n-;; for single floats, even though it takes an extra instruction.)  But\n-;; on an IP, the FP registers are simulated and so should be avoided.\n-;; We do this by using define_expand for movsf and movdf, and using\n-;; different constraints for each target type.  The constraints for\n-;; TARGET_CE allow general registers because they sometimes need to\n-;; hold floats, but they are not preferable.\n-\n-(define_expand \"movsf\"\n-  [(set (match_operand:SF 0 \"general_operand\" \"\")\n-\t(match_operand:SF 1 \"nonimmediate_operand\" \"\"))]\n-  \"\"\n-  \"\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:SF 0 \"general_operand\" \"=f,m,!*r,!f*m\")\n-\t(match_operand:SF 1 \"nonimmediate_operand\" \"fm,f,f*r*m,*r\"))]\n-  \"TARGET_CE\"\n-  \"*\n-{\n-  if (FP_REG_P (operands[0]))\n-    {\n-      if (FP_REG_P (operands[1]))\n-\treturn \\\"fmove%.s %1,%0\\\";\n-      if (REG_P (operands[1]))\n-\treturn \\\"mov%.l %1,%-\\;fmove%.s %+,%0\\\";\n-      return \\\"fmove%.s %1,%0\\\";\n-    }\n-  if (FP_REG_P (operands[1]))\n-    {\n-      if (REG_P (operands[0]))\n-\treturn \\\"fmove%.s %1,%-\\;mov%.l %+,%0\\\";\n-      return \\\"fmove%.s %1,%0\\\";\n-    }\n-  return \\\"mov%.l %1,%0\\\";\n-}\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:SF 0 \"general_operand\" \"=frm\")\n-\t(match_operand:SF 1 \"nonimmediate_operand\" \"frm\"))]\n-  \"!TARGET_CE\"\n-  \"*\n-{\n-  if (FP_REG_P (operands[0]))\n-    {\n-      if (FP_REG_P (operands[1]))\n-\treturn \\\"fmove%.s %1,%0\\\";\n-      if (REG_P (operands[1]))\n-\treturn \\\"mov%.l %1,%-\\;fmove%.s %+,%0\\\";\n-      return \\\"fmove%.s %1,%0\\\";\n-    }\n-  if (FP_REG_P (operands[1]))\n-    {\n-      if (REG_P (operands[0]))\n-\treturn \\\"fmove%.s %1,%-\\;mov%.l %+,%0\\\";\n-      return \\\"fmove%.s %1,%0\\\";\n-    }\n-  return \\\"mov%.l %1,%0\\\";\n-}\")\n-\n-(define_expand \"movdf\"\n-  [(set (match_operand:DF 0 \"general_operand\" \"\")\n-\t(match_operand:DF 1 \"nonimmediate_operand\" \"\"))]\n-  \"\"\n-  \"\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:DF 0 \"general_operand\" \"=f,m,!*r,!f*m\")\n-\t(match_operand:DF 1 \"nonimmediate_operand\" \"fm,f,f*r*m,*r\"))]\n-  \"TARGET_CE\"\n-  \"*\n-{\n-  if (FP_REG_P (operands[0]))\n-    {\n-      if (FP_REG_P (operands[1]))\n-\treturn \\\"fmove%.d %1,%0\\\";\n-      if (REG_P (operands[1]))\n-\t{\n-\t  rtx xoperands[2];\n-\t  xoperands[1] = gen_rtx_REG (SImode, REGNO (operands[1]) + 1);\n-\t  output_asm_insn (\\\"mov%.l %1,%-\\\", xoperands);\n-\t  output_asm_insn (\\\"mov%.l %1,%-\\\", operands);\n-\t  return \\\"fmove%.d %+,%0\\\";\n-\t}\n-      return \\\"fmove%.d %1,%0\\\";\n-    }\n-  else if (FP_REG_P (operands[1]))\n-    {\n-      if (REG_P (operands[0]))\n-\t{\n-\t  output_asm_insn (\\\"fmove%.d %1,%-\\;mov%.l %+,%0\\\", operands);\n-\t  operands[0] = gen_rtx_REG (SImode, REGNO (operands[0]) + 1);\n-\t  return \\\"mov%.l %+,%0\\\";\n-\t}\n-      return \\\"fmove%.d %1,%0\\\";\n-    }\n-  return output_move_double (operands);\n-}\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:DF 0 \"general_operand\" \"=frm\")\n-\t(match_operand:DF 1 \"nonimmediate_operand\" \"frm\"))]\n-  \"!TARGET_CE\"\n-  \"*\n-{\n-  if (FP_REG_P (operands[0]))\n-    {\n-      if (FP_REG_P (operands[1]))\n-\treturn \\\"fmove%.d %1,%0\\\";\n-      if (REG_P (operands[1]))\n-\t{\n-\t  rtx xoperands[2];\n-\t  xoperands[1] = gen_rtx_REG (SImode, REGNO (operands[1]) + 1);\n-\t  output_asm_insn (\\\"mov%.l %1,%-\\\", xoperands);\n-\t  output_asm_insn (\\\"mov%.l %1,%-\\\", operands);\n-\t  return \\\"fmove%.d %+,%0\\\";\n-\t}\n-      return \\\"fmove%.d %1,%0\\\";\n-    }\n-  else if (FP_REG_P (operands[1]))\n-    {\n-      if (REG_P (operands[0]))\n-\t{\n-\t  output_asm_insn (\\\"fmove%.d %1,%-\\;mov%.l %+,%0\\\", operands);\n-\t  operands[0] = gen_rtx_REG (SImode, REGNO (operands[0]) + 1);\n-\t  return \\\"mov%.l %+,%0\\\";\n-\t}\n-      return \\\"fmove%.d %1,%0\\\";\n-    }\n-  return output_move_double (operands);\n-}\")\n-\n-(define_insn \"movdi\"\n-  [(set (match_operand:DI 0 \"general_operand\" \"=rm,&r,&ro<>\")\n-\t(match_operand:DI 1 \"general_operand\" \"r,m,roi<>\"))]\n-  \"\"\n-  \"*\n-{\n-  return output_move_double (operands);\n-}\n-\")\n-\n-;; This goes after the move instructions\n-;; because the move instructions are better (require no spilling)\n-;; when they can apply.  It goes before the add/sub insns\n-;; so we will prefer it to them.\n-\n-(define_insn \"pushasi\"\n-  [(set (match_operand:SI 0 \"push_operand\" \"=m\")\n-\t(match_operand:SI 1 \"address_operand\" \"p\"))]\n-  \"\"\n-  \"pea %a1\")\n-\f\n-;; truncation instructions\n-(define_insn \"truncsiqi2\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"=dm,d\")\n-\t(truncate:QI\n-\t (match_operand:SI 1 \"general_operand\" \"doJ,i\")))]\n-  \"\"\n-  \"*\n-{\n-  if (GET_CODE (operands[0]) == REG)\n-    return \\\"mov%.l %1,%0\\\";\n-  if (GET_CODE (operands[1]) == MEM)\n-    operands[1] = adj_offsettable_operand (operands[1], 3);\n-  return \\\"mov%.b %1,%0\\\";\n-}\")\n-\n-(define_insn \"trunchiqi2\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"=dm,d\")\n-\t(truncate:QI\n-\t (match_operand:HI 1 \"general_operand\" \"doJ,i\")))]\n-  \"\"\n-  \"*\n-{\n-  if (GET_CODE (operands[0]) == REG\n-      && (GET_CODE (operands[1]) == MEM\n-\t  || GET_CODE (operands[1]) == CONST_INT))\n-    return \\\"mov%.w %1,%0\\\";\n-  if (GET_CODE (operands[0]) == REG)\n-    return \\\"mov%.l %1,%0\\\";\n-  if (GET_CODE (operands[1]) == MEM)\n-    operands[1] = adj_offsettable_operand (operands[1], 1);\n-  return \\\"mov%.b %1,%0\\\";\n-}\")\n-\n-(define_insn \"truncsihi2\"\n-  [(set (match_operand:HI 0 \"general_operand\" \"=dm,d\")\n-\t(truncate:HI\n-\t (match_operand:SI 1 \"general_operand\" \"roJ,i\")))]\n-  \"\"\n-  \"*\n-{\n-  if (GET_CODE (operands[0]) == REG)\n-    return \\\"mov%.l %1,%0\\\";\n-  if (GET_CODE (operands[1]) == MEM)\n-    operands[1] = adj_offsettable_operand (operands[1], 2);\n-  return \\\"mov%.w %1,%0\\\";\n-}\")\n-\f\n-;; zero extension instructions\n-\n-(define_expand \"zero_extendhisi2\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(const_int 0))\n-   (set (strict_low_part (subreg:HI (match_dup 0) 0))\n-\t(match_operand:HI 1 \"general_operand\" \"\"))]\n-  \"\"\n-  \"operands[1] = make_safe_from (operands[1], operands[0]);\")\n-\n-(define_expand \"zero_extendqihi2\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"\")\n-\t(const_int 0))\n-   (set (strict_low_part (subreg:QI (match_dup 0) 0))\n-\t(match_operand:QI 1 \"general_operand\" \"\"))]\n-  \"\"\n-  \"operands[1] = make_safe_from (operands[1], operands[0]);\")\n-\n-(define_expand \"zero_extendqisi2\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(const_int 0))\n-   (set (strict_low_part (subreg:QI (match_dup 0) 0))\n-\t(match_operand:QI 1 \"general_operand\" \"\"))]\n-  \"\"\n-  \" operands[1] = make_safe_from (operands[1], operands[0]); \")\n-\f\n-;; Patterns to recognize zero-extend insns produced by the combiner.\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=do<>\")\n-\t(zero_extend:SI\n-\t (match_operand:HI 1 \"nonimmediate_operand\" \"rm\")))]\n-  \"\"\n-  \"*\n-{\n-  if (DATA_REG_P (operands[0]))\n-    {\n-      if (GET_CODE (operands[1]) == REG\n-\t  && REGNO (operands[0]) == REGNO (operands[1]))\n-\treturn \\\"and%.l %#0xFFFF,%0\\\";\n-      if (reg_mentioned_p (operands[0], operands[1]))\n-        return \\\"mov%.w %1,%0\\;and%.l %#0xFFFF,%0\\\";\n-      return \\\"clr%.l %0\\;mov%.w %1,%0\\\";\n-    }\n-  else if (GET_CODE (operands[0]) == MEM\n-\t   && GET_CODE (XEXP (operands[0], 0)) == PRE_DEC)\n-    return \\\"mov%.w %1,%0\\;clr%.w %0\\\";\n-  else if (GET_CODE (operands[0]) == MEM\n-\t   && GET_CODE (XEXP (operands[0], 0)) == POST_INC)\n-    return \\\"clr%.w %0\\;mov%.w %1,%0\\\";\n-  else\n-    {\n-      output_asm_insn (\\\"clr%.w %0\\\", operands);\n-      operands[0] = adj_offsettable_operand (operands[0], 2);\n-      return \\\"mov%.w %1,%0\\\";\n-    }\n-}\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:HI 0 \"general_operand\" \"=do<>\")\n-\t(zero_extend:HI\n-\t (match_operand:QI 1 \"nonimmediate_operand\" \"dm\")))]\n-  \"\"\n-  \"*\n-{\n-  if (DATA_REG_P (operands[0]))\n-    {\n-      if (GET_CODE (operands[1]) == REG\n-\t  && REGNO (operands[0]) == REGNO (operands[1]))\n-\treturn \\\"and%.w %#0xFF,%0\\\";\n-      if (reg_mentioned_p (operands[0], operands[1]))\n-        return \\\"mov%.b %1,%0\\;and%.w %#0xFF,%0\\\";\n-      return \\\"clr%.w %0\\;mov%.b %1,%0\\\";\n-    }\n-  else if (GET_CODE (operands[0]) == MEM\n-\t   && GET_CODE (XEXP (operands[0], 0)) == PRE_DEC)\n-    {\n-      if (REGNO (XEXP (XEXP (operands[0], 0), 0))\n-\t  == STACK_POINTER_REGNUM)\n-\treturn \\\"clr%.w %-\\;mov%.b %1,%0\\\";\n-      else\n-\treturn \\\"mov%.b %1,%0\\;clr%.b %0\\\";\n-    }\n-  else if (GET_CODE (operands[0]) == MEM\n-\t   && GET_CODE (XEXP (operands[0], 0)) == POST_INC)\n-    return \\\"clr%.b %0\\;mov%.b %1,%0\\\";\n-  else\n-    {\n-      output_asm_insn (\\\"clr%.b %0\\\", operands);\n-      operands[0] = adj_offsettable_operand (operands[0], 1);\n-      return \\\"mov%.b %1,%0\\\";\n-    }\n-}\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=do<>\")\n-\t(zero_extend:SI\n-\t (match_operand:QI 1 \"nonimmediate_operand\" \"dm\")))]\n-  \"\"\n-  \"*\n-{\n-  if (DATA_REG_P (operands[0]))\n-    {\n-      if (GET_CODE (operands[1]) == REG\n-\t  && REGNO (operands[0]) == REGNO (operands[1]))\n-\treturn \\\"and%.l %#0xFF,%0\\\";\n-      if (reg_mentioned_p (operands[0], operands[1]))\n-        return \\\"mov%.b %1,%0\\;and%.l %#0xFF,%0\\\";\n-      return \\\"clr%.l %0\\;mov%.b %1,%0\\\";\n-    }\n-  else if (GET_CODE (operands[0]) == MEM\n-\t   && GET_CODE (XEXP (operands[0], 0)) == PRE_DEC)\n-    {\n-      operands[0] = XEXP (XEXP (operands[0], 0), 0);\n-      return \\\"clr%.l %0@-\\;mov%.b %1,%0@(3)\\\";\n-    }\n-  else if (GET_CODE (operands[0]) == MEM\n-\t   && GET_CODE (XEXP (operands[0], 0)) == POST_INC)\n-    {\n-      operands[0] = XEXP (XEXP (operands[0], 0), 0);\n-      return \\\"clr%.l %0@+\\;mov%.b %1,%0@(-1)\\\";\n-    }\n-  else\n-    {\n-      output_asm_insn (\\\"clr%.l %0\\\", operands);\n-      operands[0] = adj_offsettable_operand (operands[0], 3);\n-      return \\\"mov%.b %1,%0\\\";\n-    }\n-}\")\n-\f\n-;; sign extension instructions\n-\n-(define_insn \"extendhisi2\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=*d,a\")\n-\t(sign_extend:SI\n-\t (match_operand:HI 1 \"nonimmediate_operand\" \"0,rmn\")))]\n-  \"\"\n-  \"@\n-   ext%.l %0\n-   mov%.w %1,%0\")\n-\n-(define_insn \"extendqihi2\"\n-  [(set (match_operand:HI 0 \"general_operand\" \"=d\")\n-\t(sign_extend:HI\n-\t (match_operand:QI 1 \"nonimmediate_operand\" \"0\")))]\n-  \"\"\n-  \"ext%.w %0\")\n-\n-(define_insn \"extendqisi2\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=d\")\n-\t(sign_extend:SI\n-\t (match_operand:QI 1 \"nonimmediate_operand\" \"0\")))]\n-  \"TARGET_68020\"\n-  \"extb%.l %0\")\n-\f\n-;; Conversions between float and double.\n-\n-(define_insn \"extendsfdf2\"\n-  [(set (match_operand:DF 0 \"general_operand\" \"=f,m\")\n-\t(float_extend:DF\n-\t  (match_operand:SF 1 \"nonimmediate_operand\" \"fm,f\")))]\n-  \"TARGET_CE\"\n-  \"fmovesd %1,%0\")\n-\n-(define_insn \"truncdfsf2\"\n-  [(set (match_operand:SF 0 \"general_operand\" \"=f,m\")\n-\t(float_truncate:SF\n-\t  (match_operand:DF 1 \"nonimmediate_operand\" \"fm,f\")))]\n-  \"TARGET_CE\"\n-  \"fmoveds %1,%0\")\n-\f\n-;; Conversion between fixed point and floating point.\n-;; Note that among the fix-to-float insns\n-;; the ones that start with SImode come first.\n-;; That is so that an operand that is a CONST_INT\n-;; (and therefore lacks a specific machine mode).\n-;; will be recognized as SImode (which is always valid)\n-;; rather than as QImode or HImode.\n-\n-(define_insn \"floatsisf2\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n-\t(float:SF (match_operand:SI 1 \"nonimmediate_operand\" \"dm\")))]\n-  \"TARGET_CE\"\n-  \"fmovels %1,%0\")\n-\n-(define_insn \"floatsidf2\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n-\t(float:DF (match_operand:SI 1 \"nonimmediate_operand\" \"dm\")))]\n-  \"TARGET_CE\"\n-  \"fmoveld %1,%0\")\n-\n-(define_insn \"floathisf2\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n-\t(float:SF (match_operand:HI 1 \"nonimmediate_operand\" \"dm\")))]\n-  \"TARGET_CE\"\n-  \"fmovews %1,%0\")\n-\n-(define_insn \"floathidf2\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n-\t(float:DF (match_operand:HI 1 \"nonimmediate_operand\" \"dm\")))]\n-  \"TARGET_CE\"\n-  \"fmovewd %1,%0\")\n-\n-(define_insn \"floatqisf2\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n-\t(float:SF (match_operand:QI 1 \"nonimmediate_operand\" \"dm\")))]\n-  \"TARGET_CE\"\n-  \"fmovebs %1,%0\")\n-\n-(define_insn \"floatqidf2\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n-\t(float:DF (match_operand:QI 1 \"nonimmediate_operand\" \"dm\")))]\n-  \"TARGET_CE\"\n-  \"fmovebd %1,%0\")\n-\f\n-;; Float-to-fix conversion insns.\n-\n-(define_insn \"fix_truncsfqi2\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"=dm\")\n-\t(fix:QI (fix:SF (match_operand:SF 1 \"register_operand\" \"f\"))))]\n-  \"TARGET_CE\"\n-  \"fmovesb %1,%0\")\n-\n-(define_insn \"fix_truncsfhi2\"\n-  [(set (match_operand:HI 0 \"general_operand\" \"=dm\")\n-\t(fix:HI (fix:SF (match_operand:SF 1 \"register_operand\" \"f\"))))]\n-  \"TARGET_CE\"\n-  \"fmovesw %1,%0\")\n-\n-(define_insn \"fix_truncsfsi2\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=dm\")\n-\t(fix:SI (fix:SF (match_operand:SF 1 \"register_operand\" \"f\"))))]\n-  \"TARGET_CE\"\n-  \"fmovesl %1,%0\")\n-\n-(define_insn \"fix_truncdfqi2\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"=dm\")\n-\t(fix:QI (fix:DF (match_operand:DF 1 \"register_operand\" \"f\"))))]\n-  \"TARGET_CE\"\n-  \"fmovedb %1,%0\")\n-\n-(define_insn \"fix_truncdfhi2\"\n-  [(set (match_operand:HI 0 \"general_operand\" \"=dm\")\n-\t(fix:HI (fix:DF (match_operand:DF 1 \"register_operand\" \"f\"))))]\n-  \"TARGET_CE\"\n-  \"fmovedw %1,%0\")\n-\n-(define_insn \"fix_truncdfsi2\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=dm\")\n-\t(fix:SI (fix:DF (match_operand:DF 1 \"register_operand\" \"f\"))))]\n-  \"TARGET_CE\"\n-  \"fmovedl %1,%0\")\n-\f\n-;; add instructions\n-\n-(define_insn \"addsi3\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=m,r,!a,!a\")\n-\t(plus:SI (match_operand:SI 1 \"general_operand\" \"%0,0,a,rJK\")\n-\t\t (match_operand:SI 2 \"general_operand\" \"dIKLs,mrIKLs,rJK,a\")))]\n-  \"\"\n-  \"*\n-{\n-  if (! operands_match_p (operands[0], operands[1]))\n-    {\n-      if (!ADDRESS_REG_P (operands[1]))\n-\t{\n-\t  rtx tmp = operands[1];\n-\n-\t  operands[1] = operands[2];\n-\t  operands[2] = tmp;\n-\t}\n-\n-      /* These insns can result from reloads to access\n-\t stack slots over 64k from the frame pointer.  */\n-      if (GET_CODE (operands[2]) == CONST_INT\n-\t  && INTVAL (operands[2]) + 0x8000 >= (unsigned) 0x10000)\n-        return \\\"mov%.l %2,%0\\;add%.l %1,%0\\\";\n-      if (GET_CODE (operands[2]) == REG)\n-\treturn \\\"lea %1@[%2:L:B],%0\\\";\n-      else\n-\treturn \\\"lea %1@(%c2),%0\\\";\n-    }\n-  if (GET_CODE (operands[2]) == CONST_INT)\n-    {\n-      if (INTVAL (operands[2]) > 0\n-\t  && INTVAL (operands[2]) <= 8)\n-\treturn (ADDRESS_REG_P (operands[0])\n-\t\t? \\\"addq%.w %2,%0\\\"\n-\t\t: \\\"addq%.l %2,%0\\\");\n-      if (INTVAL (operands[2]) < 0\n-\t  && INTVAL (operands[2]) >= -8)\n-        {\n-\t  operands[2] = GEN_INT (- INTVAL (operands[2]));\n-\t  return (ADDRESS_REG_P (operands[0])\n-\t\t  ? \\\"subq%.w %2,%0\\\"\n-\t\t  : \\\"subq%.l %2,%0\\\");\n-\t}\n-      if (ADDRESS_REG_P (operands[0])\n-\t  && INTVAL (operands[2]) >= -0x8000\n-\t  && INTVAL (operands[2]) < 0x8000)\n-\treturn \\\"add%.w %2,%0\\\";\n-    }\n-  return \\\"add%.l %2,%0\\\";\n-}\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=a\")\n-\t(plus:SI (match_operand:SI 1 \"general_operand\" \"0\")\n-\t\t (sign_extend:SI (match_operand:HI 2 \"nonimmediate_operand\" \"rmn\"))))]\n-  \"\"\n-  \"add%.w %2,%0\")\n-\n-(define_insn \"addhi3\"\n-  [(set (match_operand:HI 0 \"general_operand\" \"=mr,mr,m,r\")\n-\t(plus:HI (match_operand:HI 1 \"general_operand\" \"%0,0,0,0\")\n-\t\t (match_operand:HI 2 \"general_operand\" \"I,L,dn,rmn\")))]\n-  \"\"\n-  \"@\n-   addq%.w %2,%0\n-   subq%.w #%n2,%0\n-   add%.w %2,%0\n-   add%.w %2,%0\")\n-\n-(define_insn \"\"\n-  [(set (strict_low_part (match_operand:HI 0 \"general_operand\" \"+m,d\"))\n-\t(plus:HI (match_dup 0)\n-\t\t (match_operand:HI 1 \"general_operand\" \"dn,rmn\")))]\n-  \"\"\n-  \"add%.w %1,%0\")\n-\n-(define_insn \"addqi3\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"=md,mr,m,d\")\n-\t(plus:QI (match_operand:QI 1 \"general_operand\" \"%0,0,0,0\")\n-\t\t (match_operand:QI 2 \"general_operand\" \"I,L,dn,dmn\")))]\n-  \"\"\n-  \"@\n-   addq%.b %2,%0\n-   subq%.b #%n2,%0\n-   add%.b %2,%0\n-   add%.b %2,%0\")\n-\n-(define_insn \"\"\n-  [(set (strict_low_part (match_operand:QI 0 \"general_operand\" \"+m,d\"))\n-\t(plus:QI (match_dup 0)\n-\t\t (match_operand:QI 1 \"general_operand\" \"dn,dmn\")))]\n-  \"\"\n-  \"add%.b %1,%0\")\n-\n-(define_insn \"adddf3\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n-\t(plus:DF (match_operand:DF 1 \"nonimmediate_operand\" \"%f\")\n-\t\t (match_operand:DF 2 \"nonimmediate_operand\" \"fm\")))]\n-  \"TARGET_CE\"\n-  \"fadd%.d %2,%1,%0\")\n-\n-(define_insn \"addsf3\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n-\t(plus:SF (match_operand:SF 1 \"nonimmediate_operand\" \"%f\")\n-\t\t (match_operand:SF 2 \"nonimmediate_operand\" \"fm\")))]\n-  \"TARGET_CE\"\n-  \"fadd%.s %2,%1,%0\")\n-\f\n-;; subtract instructions\n-\n-(define_insn \"subsi3\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=m,r,!a,?d\")\n-\t(minus:SI (match_operand:SI 1 \"general_operand\" \"0,0,a,mrIKs\")\n-\t\t  (match_operand:SI 2 \"general_operand\" \"dIKs,mrIKs,J,0\")))]\n-  \"\"\n-  \"*\n-{\n-  if (! operands_match_p (operands[0], operands[1]))\n-    {\n-      if (operands_match_p (operands[0], operands[2]))\n-\t{\n-\t  if (GET_CODE (operands[1]) == CONST_INT)\n-\t    {\n-\t      if (INTVAL (operands[1]) > 0\n-\t\t  && INTVAL (operands[1]) <= 8)\n-\t\treturn \\\"subq%.l %1,%0\\;neg%.l %0\\\";\n-\t    }\n-\t  return \\\"sub%.l %1,%0\\;neg%.l %0\\\";\n-\t}\n-      /* This case is matched by J, but negating -0x8000\n-         in an lea would give an invalid displacement.\n-\t So do this specially.  */\n-      if (INTVAL (operands[2]) == -0x8000)\n-\treturn \\\"mov%.l %1,%0\\;sub%.l %2,%0\\\";\n-      return \\\"lea %1@(%n2),%0\\\";\n-    }\n-  if (GET_CODE (operands[2]) == CONST_INT)\n-    {\n-      if (INTVAL (operands[2]) > 0\n-\t  && INTVAL (operands[2]) <= 8)\n-\treturn \\\"subq%.l %2,%0\\\";\n-      if (ADDRESS_REG_P (operands[0])\n-\t  && INTVAL (operands[2]) >= -0x8000\n-\t  && INTVAL (operands[2]) < 0x8000)\n-\treturn \\\"sub%.w %2,%0\\\";\n-    }\n-  return \\\"sub%.l %2,%0\\\";\n-}\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=a\")\n-\t(minus:SI (match_operand:SI 1 \"general_operand\" \"0\")\n-\t\t  (sign_extend:SI (match_operand:HI 2 \"nonimmediate_operand\" \"rmn\"))))]\n-  \"\"\n-  \"sub%.w %2,%0\")\n-\n-(define_insn \"subhi3\"\n-  [(set (match_operand:HI 0 \"general_operand\" \"=m,r\")\n-\t(minus:HI (match_operand:HI 1 \"general_operand\" \"0,0\")\n-\t\t  (match_operand:HI 2 \"general_operand\" \"dn,rmn\")))]\n-  \"\"\n-  \"sub%.w %2,%0\")\n-\n-(define_insn \"\"\n-  [(set (strict_low_part (match_operand:HI 0 \"general_operand\" \"+m,d\"))\n-\t(minus:HI (match_dup 0)\n-\t\t  (match_operand:HI 1 \"general_operand\" \"dn,rmn\")))]\n-  \"\"\n-  \"sub%.w %1,%0\")\n-\n-(define_insn \"subqi3\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"=m,d\")\n-\t(minus:QI (match_operand:QI 1 \"general_operand\" \"0,0\")\n-\t\t  (match_operand:QI 2 \"general_operand\" \"dn,dmn\")))]\n-  \"\"\n-  \"sub%.b %2,%0\")\n-\n-(define_insn \"\"\n-  [(set (strict_low_part (match_operand:QI 0 \"general_operand\" \"+m,d\"))\n-\t(minus:QI (match_dup 0)\n-\t\t  (match_operand:QI 1 \"general_operand\" \"dn,dmn\")))]\n-  \"\"\n-  \"sub%.b %1,%0\")\n-\n-(define_insn \"subdf3\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=f,f,f\")\n-\t(minus:DF (match_operand:DF 1 \"nonimmediate_operand\" \"f,f,m\")\n-\t\t  (match_operand:DF 2 \"nonimmediate_operand\" \"f,m,f\")))]\n-  \"TARGET_CE\"\n-  \"@\n-   fsub%.d %2,%1,%0\n-   fsub%.d %2,%1,%0\n-   frsub%.d %1,%2,%0\")\n-\n-(define_insn \"subsf3\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=f,f,f\")\n-\t(minus:SF (match_operand:SF 1 \"nonimmediate_operand\" \"f,f,m\")\n-\t\t  (match_operand:SF 2 \"nonimmediate_operand\" \"f,m,f\")))]\n-  \"TARGET_CE\"\n-  \"@\n-   fsub%.s %2,%1,%0\n-   fsub%.s %2,%1,%0\n-   frsub%.s %1,%2,%0\")\n-\f\n-;; multiply instructions\n-\n-(define_insn \"mulhi3\"\n-  [(set (match_operand:HI 0 \"general_operand\" \"=d\")\n-\t(mult:HI (match_operand:HI 1 \"general_operand\" \"%0\")\n-\t\t (match_operand:HI 2 \"general_operand\" \"dmn\")))]\n-  \"\"\n-  \"muls %2,%0\")\n-\n-(define_insn \"mulhisi3\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=d\")\n-\t(mult:SI (sign_extend:SI (match_operand:HI 1 \"nonimmediate_operand\" \"%0\"))\n-\t\t (sign_extend:SI (match_operand:HI 2 \"nonimmediate_operand\" \"dm\"))))]\n-  \"\"\n-  \"muls %2,%0\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=d\")\n-\t(mult:SI (sign_extend:SI (match_operand:HI 1 \"nonimmediate_operand\" \"%0\"))\n-\t\t (match_operand:SI 2 \"const_int_operand\" \"n\")))]\n-  \"\"\n-  \"muls %2,%0\")\n-\n-(define_insn \"mulsi3\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=d\")\n-\t(mult:SI (match_operand:SI 1 \"general_operand\" \"%0\")\n-\t\t (match_operand:SI 2 \"general_operand\" \"dmsK\")))]\n-  \"TARGET_68020\"\n-  \"muls%.l %2,%0\")\n-\n-(define_insn \"umulhisi3\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=d\")\n-\t(mult:SI (zero_extend:SI\n-\t\t  (match_operand:HI 1 \"nonimmediate_operand\" \"%0\"))\n-\t\t (zero_extend:SI\n-\t\t  (match_operand:HI 2 \"nonimmediate_operand\" \"dm\"))))]\n-  \"\"\n-  \"mulu %2,%0\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=d\")\n-\t(mult:SI (zero_extend:SI\n-\t\t  (match_operand:HI 1 \"nonimmediate_operand\" \"%0\"))\n-\t\t (match_operand:SI 2 \"const_int_operand\" \"n\")))]\n-  \"\"\n-  \"mulu %2,%0\")\n-\n-(define_insn \"muldf3\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n-\t(mult:DF (match_operand:DF 1 \"nonimmediate_operand\" \"%f\")\n-\t\t (match_operand:DF 2 \"nonimmediate_operand\" \"fm\")))]\n-  \"TARGET_CE\"\n-  \"fmul%.d %2,%1,%0\")\n-\n-(define_insn \"mulsf3\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n-\t(mult:SF (match_operand:SF 1 \"nonimmediate_operand\" \"%f\")\n-\t\t (match_operand:SF 2 \"nonimmediate_operand\" \"fm\")))]\n-  \"TARGET_CE\"\n-  \"fmul%.s %2,%1,%0\")\n-\f\n-;; divide instructions\n-\n-(define_insn \"divhi3\"\n-  [(set (match_operand:HI 0 \"general_operand\" \"=d\")\n-\t(div:HI (match_operand:HI 1 \"general_operand\" \"0\")\n-\t\t(match_operand:HI 2 \"general_operand\" \"dmn\")))]\n-  \"\"\n-  \"extl %0\\;divs %2,%0\")\n-\n-(define_insn \"divhisi3\"\n-  [(set (match_operand:HI 0 \"general_operand\" \"=d\")\n-\t(truncate:HI\n-\t (div:SI\n-\t  (match_operand:SI 1 \"general_operand\" \"0\")\n-\t  (sign_extend:SI (match_operand:HI 2 \"nonimmediate_operand\" \"dm\")))))]\n-  \"\"\n-  \"divs %2,%0\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:HI 0 \"general_operand\" \"=d\")\n-\t(truncate:HI (div:SI (match_operand:SI 1 \"general_operand\" \"0\")\n-\t\t\t     (match_operand:SI 2 \"const_int_operand\" \"n\"))))]\n-  \"\"\n-  \"divs %2,%0\")\n-\n-(define_insn \"divsi3\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=d\")\n-\t(div:SI (match_operand:SI 1 \"general_operand\" \"0\")\n-\t\t(match_operand:SI 2 \"general_operand\" \"dmsK\")))]\n-  \"TARGET_68020\"\n-  \"divs%.l %2,%0,%0\")\n-\n-(define_insn \"udivhi3\"\n-  [(set (match_operand:HI 0 \"general_operand\" \"=d\")\n-\t(udiv:HI (match_operand:HI 1 \"general_operand\" \"0\")\n-\t\t (match_operand:HI 2 \"general_operand\" \"dmn\")))]\n-  \"\"\n-  \"and%.l %#0xFFFF,%0\\;divu %2,%0\")\n-\n-(define_insn \"udivhisi3\"\n-  [(set (match_operand:HI 0 \"general_operand\" \"=d\")\n-\t(truncate:HI\n-\t (udiv:SI\n-\t  (match_operand:SI 1 \"general_operand\" \"0\")\n-\t  (zero_extend:SI (match_operand:HI 2 \"nonimmediate_operand\" \"dm\")))))]\n-  \"\"\n-  \"divu %2,%0\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:HI 0 \"general_operand\" \"=d\")\n-\t(truncate:HI (udiv:SI (match_operand:SI 1 \"nonimmediate_operand\" \"0\")\n-\t\t\t      (match_operand:HI 2 \"const_int_operand\" \"n\"))))]\n-  \"\"\n-  \"divu %2,%0\")\n-\n-(define_insn \"udivsi3\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=d\")\n-\t(udiv:SI (match_operand:SI 1 \"general_operand\" \"0\")\n-\t\t (match_operand:SI 2 \"general_operand\" \"dmsK\")))]\n-  \"TARGET_68020\"\n-  \"divu%.l %2,%0,%0\")\n-\n-(define_insn \"divdf3\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=f,f,f\")\n-\t(div:DF (match_operand:DF 1 \"nonimmediate_operand\" \"f,f,m\")\n-\t\t(match_operand:DF 2 \"nonimmediate_operand\" \"f,m,f\")))]\n-  \"TARGET_CE\"\n-  \"@\n-   fdiv%.d %2,%1,%0\n-   fdiv%.d %2,%1,%0\n-   frdiv%.d %1,%2,%0\")\n-\n-(define_insn \"divsf3\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=f,f,f\")\n-\t(div:SF (match_operand:SF 1 \"nonimmediate_operand\" \"f,f,m\")\n-\t\t(match_operand:SF 2 \"nonimmediate_operand\" \"f,m,f\")))]\n-  \"TARGET_CE\"\n-  \"@\n-   fdiv%.s %2,%1,%0\n-   fdiv%.s %2,%1,%0\n-   frdiv%.s %1,%2,%0\")\n-\f\n-;; Remainder instructions.\n-\n-(define_insn \"modhi3\"\n-  [(set (match_operand:HI 0 \"general_operand\" \"=d\")\n-\t(mod:HI (match_operand:HI 1 \"general_operand\" \"0\")\n-\t\t(match_operand:HI 2 \"general_operand\" \"dmn\")))]\n-  \"\"\n-  \"extl %0\\;divs %2,%0\\;swap %0\")\n-\n-(define_insn \"modhisi3\"\n-  [(set (match_operand:HI 0 \"general_operand\" \"=d\")\n-\t(truncate:HI\n-\t (mod:SI\n-\t  (match_operand:SI 1 \"general_operand\" \"0\")\n-\t  (sign_extend:SI (match_operand:HI 2 \"nonimmediate_operand\" \"dm\")))))]\n-  \"\"\n-  \"divs %2,%0\\;swap %0\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:HI 0 \"general_operand\" \"=d\")\n-\t(truncate:HI (mod:SI (match_operand:SI 1 \"general_operand\" \"0\")\n-\t\t\t     (match_operand:SI 2 \"const_int_operand\" \"n\"))))]\n-  \"\"\n-  \"divs %2,%0\\;swap %0\")\n-\n-(define_insn \"umodhi3\"\n-  [(set (match_operand:HI 0 \"general_operand\" \"=d\")\n-\t(umod:HI (match_operand:HI 1 \"general_operand\" \"0\")\n-\t\t (match_operand:HI 2 \"general_operand\" \"dmn\")))]\n-  \"\"\n-  \"and%.l %#0xFFFF,%0\\;divu %2,%0\\;swap %0\")\n-\n-(define_insn \"umodhisi3\"\n-  [(set (match_operand:HI 0 \"general_operand\" \"=d\")\n-\t(truncate:HI\n-\t (umod:SI\n-\t  (match_operand:SI 1 \"general_operand\" \"0\")\n-\t  (zero_extend:SI (match_operand:HI 2 \"nonimmediate_operand\" \"dm\")))))]\n-  \"\"\n-  \"divu %2,%0\\;swap %0\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:HI 0 \"general_operand\" \"=d\")\n-\t(truncate:HI (umod:SI (match_operand:SI 1 \"general_operand\" \"0\")\n-\t\t\t      (match_operand:SI 2 \"const_int_operand\" \"n\"))))]\n-  \"\"\n-  \"divu %2,%0\\;swap %0\")\n-\n-(define_insn \"divmodsi4\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=d\")\n-\t(div:SI (match_operand:SI 1 \"general_operand\" \"0\")\n-\t\t(match_operand:SI 2 \"general_operand\" \"dmsK\")))\n-   (set (match_operand:SI 3 \"general_operand\" \"=d\")\n-\t(mod:SI (match_dup 1) (match_dup 2)))]\n-  \"TARGET_68020\"\n-  \"divs%.l %2,%0,%3\")\n-\n-(define_insn \"udivmodsi4\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=d\")\n-\t(udiv:SI (match_operand:SI 1 \"general_operand\" \"0\")\n-\t\t (match_operand:SI 2 \"general_operand\" \"dmsK\")))\n-   (set (match_operand:SI 3 \"general_operand\" \"=d\")\n-\t(umod:SI (match_dup 1) (match_dup 2)))]\n-  \"TARGET_68020\"\n-  \"divu%.l %2,%0,%3\")\n-\f\n-;; logical-and instructions\n-\n-(define_insn \"andsi3\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=m,d\")\n-\t(and:SI (match_operand:SI 1 \"general_operand\" \"%0,0\")\n-\t\t(match_operand:SI 2 \"general_operand\" \"dKs,dmKs\")))]\n-  \"\"\n-  \"*\n-{\n-  if (GET_CODE (operands[2]) == CONST_INT\n-      && (INTVAL (operands[2]) | 0xffff) == 0xffffffff\n-      && (DATA_REG_P (operands[0])\n-\t  || offsettable_memref_p (operands[0])))\n-    { \n-      if (GET_CODE (operands[0]) != REG)\n-        operands[0] = adj_offsettable_operand (operands[0], 2);\n-      operands[2] = GEN_INT (INTVAL (operands[2]) & 0xffff);\n-      /* Do not delete a following tstl %0 insn; that would be incorrect.  */\n-      CC_STATUS_INIT;\n-      if (operands[2] == const0_rtx)\n-        return \\\"clr%.w %0\\\";\n-      return \\\"and%.w %2,%0\\\";\n-    }\n-  return \\\"and%.l %2,%0\\\";\n-}\")\n-\n-(define_insn \"andhi3\"\n-  [(set (match_operand:HI 0 \"general_operand\" \"=m,d\")\n-\t(and:HI (match_operand:HI 1 \"general_operand\" \"%0,0\")\n-\t\t(match_operand:HI 2 \"general_operand\" \"dn,dmn\")))]\n-  \"\"\n-  \"and%.w %2,%0\")\n-\n-(define_insn \"andqi3\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"=m,d\")\n-\t(and:QI (match_operand:QI 1 \"general_operand\" \"%0,0\")\n-\t\t(match_operand:QI 2 \"general_operand\" \"dn,dmn\")))]\n-  \"\"\n-  \"and%.b %2,%0\")\n-\n-\f\n-;; inclusive-or instructions\n-\n-(define_insn \"iorsi3\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=m,d\")\n-\t(ior:SI (match_operand:SI 1 \"general_operand\" \"%0,0\")\n-\t\t(match_operand:SI 2 \"general_operand\" \"dKs,dmKs\")))]\n-  \"\"\n-  \"*\n-{\n-  register int logval;\n-  if (GET_CODE (operands[2]) == CONST_INT\n-      && INTVAL (operands[2]) >> 16 == 0\n-      && (DATA_REG_P (operands[0])\n-\t  || offsettable_memref_p (operands[0])))\n-    { \n-      if (GET_CODE (operands[0]) != REG)\n-        operands[0] = adj_offsettable_operand (operands[0], 2);\n-      /* Do not delete a following tstl %0 insn; that would be incorrect.  */\n-      CC_STATUS_INIT;\n-      return \\\"or%.w %2,%0\\\";\n-    }\n-  if (GET_CODE (operands[2]) == CONST_INT\n-      && (logval = exact_log2 (INTVAL (operands[2]))) >= 0\n-      && (DATA_REG_P (operands[0])\n-\t  || offsettable_memref_p (operands[0])))\n-    { \n-      if (DATA_REG_P (operands[0]))\n-\toperands[1] = GEN_INT (logval);\n-      else\n-        {\n-\t  operands[0]\n-\t    = adj_offsettable_operand (operands[0], 3 - (logval / 8));\n-\t  operands[1] = GEN_INT (logval % 8);\n-\t}\n-      return \\\"bset %1,%0\\\";\n-    }\n-  return \\\"or%.l %2,%0\\\";\n-}\")\n-\n-(define_insn \"iorhi3\"\n-  [(set (match_operand:HI 0 \"general_operand\" \"=m,d\")\n-\t(ior:HI (match_operand:HI 1 \"general_operand\" \"%0,0\")\n-\t\t(match_operand:HI 2 \"general_operand\" \"dn,dmn\")))]\n-  \"\"\n-  \"or%.w %2,%0\")\n-\n-(define_insn \"iorqi3\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"=m,d\")\n-\t(ior:QI (match_operand:QI 1 \"general_operand\" \"%0,0\")\n-\t\t(match_operand:QI 2 \"general_operand\" \"dn,dmn\")))]\n-  \"\"\n-  \"or%.b %2,%0\")\n-\f\n-;; xor instructions\n-\n-(define_insn \"xorsi3\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=do,m\")\n-\t(xor:SI (match_operand:SI 1 \"general_operand\" \"%0,0\")\n-\t\t(match_operand:SI 2 \"general_operand\" \"di,dKs\")))]\n-  \"\"\n-  \"*\n-{\n-  if (GET_CODE (operands[2]) == CONST_INT\n-      && INTVAL (operands[2]) >> 16 == 0\n-      && (offsettable_memref_p (operands[0]) || DATA_REG_P (operands[0])))\n-    { \n-      if (! DATA_REG_P (operands[0]))\n-\toperands[0] = adj_offsettable_operand (operands[0], 2);\n-      /* Do not delete a following tstl %0 insn; that would be incorrect.  */\n-      CC_STATUS_INIT;\n-      return \\\"eor%.w %2,%0\\\";\n-    }\n-  return \\\"eor%.l %2,%0\\\";\n-}\")\n-\n-(define_insn \"xorhi3\"\n-  [(set (match_operand:HI 0 \"general_operand\" \"=dm\")\n-\t(xor:HI (match_operand:HI 1 \"general_operand\" \"%0\")\n-\t\t(match_operand:HI 2 \"general_operand\" \"dn\")))]\n-  \"\"\n-  \"eor%.w %2,%0\")\n-\n-(define_insn \"xorqi3\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"=dm\")\n-\t(xor:QI (match_operand:QI 1 \"general_operand\" \"%0\")\n-\t\t(match_operand:QI 2 \"general_operand\" \"dn\")))]\n-  \"\"\n-  \"eor%.b %2,%0\")\n-\f\n-;; negation instructions\n-\n-(define_insn \"negsi2\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=dm\")\n-\t(neg:SI (match_operand:SI 1 \"general_operand\" \"0\")))]\n-  \"\"\n-  \"neg%.l %0\")\n-\n-(define_insn \"neghi2\"\n-  [(set (match_operand:HI 0 \"general_operand\" \"=dm\")\n-\t(neg:HI (match_operand:HI 1 \"general_operand\" \"0\")))]\n-  \"\"\n-  \"neg%.w %0\")\n-\n-(define_insn \"negqi2\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"=dm\")\n-\t(neg:QI (match_operand:QI 1 \"general_operand\" \"0\")))]\n-  \"\"\n-  \"neg%.b %0\")\n-\n-(define_insn \"negsf2\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n-\t(neg:SF (match_operand:SF 1 \"nonimmediate_operand\" \"fm\")))]\n-  \"TARGET_CE\"\n-  \"fneg%.s %1,%0\")\n-\n-(define_insn \"negdf2\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n-\t(neg:DF (match_operand:DF 1 \"nonimmediate_operand\" \"fm\")))]\n-  \"TARGET_CE\"\n-  \"fneg%.d %1,%0\")\n-\f\n-;; Absolute value instructions\n-\n-(define_insn \"abssf2\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n-\t(abs:SF (match_operand:SF 1 \"nonimmediate_operand\" \"fm\")))]\n-  \"TARGET_CE\"\n-  \"fabs%.s %1,%0\")\n-\n-(define_insn \"absdf2\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n-\t(abs:DF (match_operand:DF 1 \"nonimmediate_operand\" \"fm\")))]\n-  \"TARGET_CE\"\n-  \"fabs%.d %1,%0\")\n-\f\n-;; Square root instructions\n-\n-(define_insn \"sqrtsf2\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n-\t(sqrt:SF (match_operand:SF 1 \"nonimmediate_operand\" \"fm\")))]\n-  \"TARGET_CE\"\n-  \"fsqrt%.s %1,%0\")\n-\n-(define_insn \"sqrtdf2\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n-\t(sqrt:DF (match_operand:DF 1 \"nonimmediate_operand\" \"fm\")))]\n-  \"TARGET_CE\"\n-  \"fsqrt%.d %1,%0\")\n-\f\n-;; one complement instructions\n-\n-(define_insn \"one_cmplsi2\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=dm\")\n-\t(not:SI (match_operand:SI 1 \"general_operand\" \"0\")))]\n-  \"\"\n-  \"not%.l %0\")\n-\n-(define_insn \"one_cmplhi2\"\n-  [(set (match_operand:HI 0 \"general_operand\" \"=dm\")\n-\t(not:HI (match_operand:HI 1 \"general_operand\" \"0\")))]\n-  \"\"\n-  \"not%.w %0\")\n-\n-(define_insn \"one_cmplqi2\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"=dm\")\n-\t(not:QI (match_operand:QI 1 \"general_operand\" \"0\")))]\n-  \"\"\n-  \"not%.b %0\")\n-\f\n-\f\n-;; arithmetic shift instructions\n-;; We don't need the shift memory by 1 bit instruction\n-\n-(define_insn \"ashlsi3\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=d\")\n-\t(ashift:SI (match_operand:SI 1 \"general_operand\" \"0\")\n-\t\t   (match_operand:SI 2 \"general_operand\" \"dI\")))]\n-  \"\"\n-  \"asl%.l %2,%0\")\n-\n-(define_insn \"ashlhi3\"\n-  [(set (match_operand:HI 0 \"general_operand\" \"=d\")\n-\t(ashift:HI (match_operand:HI 1 \"general_operand\" \"0\")\n-\t\t   (match_operand:HI 2 \"general_operand\" \"dI\")))]\n-  \"\"\n-  \"asl%.w %2,%0\")\n-\n-(define_insn \"ashlqi3\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"=d\")\n-\t(ashift:QI (match_operand:QI 1 \"general_operand\" \"0\")\n-\t\t   (match_operand:QI 2 \"general_operand\" \"dI\")))]\n-  \"\"\n-  \"asl%.b %2,%0\")\n-\n-(define_insn \"ashrsi3\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=d\")\n-\t(ashiftrt:SI (match_operand:SI 1 \"general_operand\" \"0\")\n-\t\t     (match_operand:SI 2 \"general_operand\" \"dI\")))]\n-  \"\"\n-  \"asr%.l %2,%0\")\n-\n-(define_insn \"ashrhi3\"\n-  [(set (match_operand:HI 0 \"general_operand\" \"=d\")\n-\t(ashiftrt:HI (match_operand:HI 1 \"general_operand\" \"0\")\n-\t\t     (match_operand:HI 2 \"general_operand\" \"dI\")))]\n-  \"\"\n-  \"asr%.w %2,%0\")\n-\n-(define_insn \"ashrqi3\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"=d\")\n-\t(ashiftrt:QI (match_operand:QI 1 \"general_operand\" \"0\")\n-\t\t     (match_operand:QI 2 \"general_operand\" \"dI\")))]\n-  \"\"\n-  \"asr%.b %2,%0\")\n-\f\n-;; logical shift instructions\n-\n-(define_insn \"lshrsi3\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=d\")\n-\t(lshiftrt:SI (match_operand:SI 1 \"general_operand\" \"0\")\n-\t\t     (match_operand:SI 2 \"general_operand\" \"dI\")))]\n-  \"\"\n-  \"lsr%.l %2,%0\")\n-\n-(define_insn \"lshrhi3\"\n-  [(set (match_operand:HI 0 \"general_operand\" \"=d\")\n-\t(lshiftrt:HI (match_operand:HI 1 \"general_operand\" \"0\")\n-\t\t     (match_operand:HI 2 \"general_operand\" \"dI\")))]\n-  \"\"\n-  \"lsr%.w %2,%0\")\n-\n-(define_insn \"lshrqi3\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"=d\")\n-\t(lshiftrt:QI (match_operand:QI 1 \"general_operand\" \"0\")\n-\t\t     (match_operand:QI 2 \"general_operand\" \"dI\")))]\n-  \"\"\n-  \"lsr%.b %2,%0\")\n-\f\n-;; rotate instructions\n-\n-(define_insn \"rotlsi3\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=d\")\n-\t(rotate:SI (match_operand:SI 1 \"general_operand\" \"0\")\n-\t\t   (match_operand:SI 2 \"general_operand\" \"dI\")))]\n-  \"\"\n-  \"rol%.l %2,%0\")\n-\n-(define_insn \"rotlhi3\"\n-  [(set (match_operand:HI 0 \"general_operand\" \"=d\")\n-\t(rotate:HI (match_operand:HI 1 \"general_operand\" \"0\")\n-\t\t   (match_operand:HI 2 \"general_operand\" \"dI\")))]\n-  \"\"\n-  \"rol%.w %2,%0\")\n-\n-(define_insn \"rotlqi3\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"=d\")\n-\t(rotate:QI (match_operand:QI 1 \"general_operand\" \"0\")\n-\t\t   (match_operand:QI 2 \"general_operand\" \"dI\")))]\n-  \"\"\n-  \"rol%.b %2,%0\")\n-\n-(define_insn \"rotrsi3\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=d\")\n-\t(rotatert:SI (match_operand:SI 1 \"general_operand\" \"0\")\n-\t\t     (match_operand:SI 2 \"general_operand\" \"dI\")))]\n-  \"\"\n-  \"ror%.l %2,%0\")\n-\n-(define_insn \"rotrhi3\"\n-  [(set (match_operand:HI 0 \"general_operand\" \"=d\")\n-\t(rotatert:HI (match_operand:HI 1 \"general_operand\" \"0\")\n-\t\t     (match_operand:HI 2 \"general_operand\" \"dI\")))]\n-  \"\"\n-  \"ror%.w %2,%0\")\n-\n-(define_insn \"rotrqi3\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"=d\")\n-\t(rotatert:QI (match_operand:QI 1 \"general_operand\" \"0\")\n-\t\t     (match_operand:QI 2 \"general_operand\" \"dI\")))]\n-  \"\"\n-  \"ror%.b %2,%0\")\n-\f\n-;; Special cases of bit-field insns which we should\n-;; recognize in preference to the general case.\n-;; These handle aligned 8-bit and 16-bit fields,\n-;; which can usually be done with move instructions.\n-\n-(define_insn \"\"\n-  [(set (zero_extract:SI (match_operand:SI 0 \"register_operand\" \"+do\")\n-\t\t\t (match_operand:SI 1 \"const_int_operand\" \"i\")\n-\t\t\t (match_operand:SI 2 \"const_int_operand\" \"i\"))\n-\t(match_operand:SI 3 \"general_operand\" \"d\"))]\n-  \"TARGET_68020 && TARGET_BITFIELD\n-   && (INTVAL (operands[1]) == 8 || INTVAL (operands[1]) == 16)\n-   && INTVAL (operands[2]) % INTVAL (operands[1]) == 0\n-   && (GET_CODE (operands[0]) == REG\n-       || ! mode_dependent_address_p (XEXP (operands[0], 0)))\"\n-  \"*\n-{\n-  if (REG_P (operands[0]))\n-    {\n-      if (INTVAL (operands[1]) + INTVAL (operands[2]) != 32)\n-        return \\\"bfins %3,[%c2,%c1]%0\\\";\n-    }\n-  else\n-    operands[0]\n-      = adj_offsettable_operand (operands[0], INTVAL (operands[2]) / 8);\n-\n-  if (GET_CODE (operands[3]) == MEM)\n-    operands[3] = adj_offsettable_operand (operands[3],\n-\t\t\t\t\t   (32 - INTVAL (operands[1])) / 8);\n-  if (INTVAL (operands[1]) == 8)\n-    return \\\"mov%.b %3,%0\\\";\n-  return \\\"mov%.w %3,%0\\\";\n-}\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=&d\")\n-\t(zero_extract:SI (match_operand:SI 1 \"register_operand\" \"do\")\n-\t\t\t (match_operand:SI 2 \"const_int_operand\" \"i\")\n-\t\t\t (match_operand:SI 3 \"const_int_operand\" \"i\")))]\n-  \"TARGET_68020 && TARGET_BITFIELD\n-   && (INTVAL (operands[2]) == 8 || INTVAL (operands[2]) == 16)\n-   && INTVAL (operands[3]) % INTVAL (operands[2]) == 0\n-   && (GET_CODE (operands[1]) == REG\n-       || ! mode_dependent_address_p (XEXP (operands[1], 0)))\"\n-  \"*\n-{\n-  if (REG_P (operands[1]))\n-    {\n-      if (INTVAL (operands[2]) + INTVAL (operands[3]) != 32)\n-\treturn \\\"bfextu [%c3,%c2]%1,%0\\\";\n-    }\n-  else\n-    operands[1]\n-      = adj_offsettable_operand (operands[1], INTVAL (operands[3]) / 8);\n-\n-  output_asm_insn (\\\"clrl %0\\\", operands);\n-  if (GET_CODE (operands[0]) == MEM)\n-    operands[0] = adj_offsettable_operand (operands[0],\n-\t\t\t\t\t   (32 - INTVAL (operands[1])) / 8);\n-  if (INTVAL (operands[2]) == 8)\n-    return \\\"mov%.b %1,%0\\\";\n-  return \\\"mov%.w %1,%0\\\";\n-}\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=d\")\n-\t(sign_extract:SI (match_operand:SI 1 \"register_operand\" \"do\")\n-\t\t\t (match_operand:SI 2 \"const_int_operand\" \"i\")\n-\t\t\t (match_operand:SI 3 \"const_int_operand\" \"i\")))]\n-  \"TARGET_68020 && TARGET_BITFIELD\n-   && (INTVAL (operands[2]) == 8 || INTVAL (operands[2]) == 16)\n-   && INTVAL (operands[3]) % INTVAL (operands[2]) == 0\n-   && (GET_CODE (operands[1]) == REG\n-       || ! mode_dependent_address_p (XEXP (operands[1], 0)))\"\n-  \"*\n-{\n-  if (REG_P (operands[1]))\n-    {\n-      if (INTVAL (operands[2]) + INTVAL (operands[3]) != 32)\n-\treturn \\\"bfexts [%c3,%c2]%1,%0\\\";\n-    }\n-  else\n-    operands[1]\n-      = adj_offsettable_operand (operands[1], INTVAL (operands[3]) / 8);\n-\n-  if (INTVAL (operands[2]) == 8)\n-    return \\\"mov%.b %1,%0\\;extb%.l %0\\\";\n-  return \\\"mov%.w %1,%0\\;ext%.l %0\\\";\n-}\")\n-\f\n-;; Bit field instructions, general cases.\n-;; \"o,d\" constraint causes a nonoffsettable memref to match the \"o\"\n-;; so that its address is reloaded.\n-\n-(define_expand \"extv\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"\")\n-\t(sign_extract:SI (match_operand:SI 1 \"general_operand\" \"\")\n-\t\t\t (match_operand:SI 2 \"general_operand\" \"\")\n-\t\t\t (match_operand:SI 3 \"general_operand\" \"\")))]\n-  \"TARGET_68020 && TARGET_BITFIELD\"\n-  \"\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=d\")\n-\t(sign_extract:SI (match_operand:QI 1 \"memory_operand\" \"o\")\n-\t\t\t (match_operand:SI 2 \"general_operand\" \"di\")\n-\t\t\t (match_operand:SI 3 \"general_operand\" \"di\")))]\n-  \"TARGET_68020 && TARGET_BITFIELD\"\n-  \"bfexts [%c3,%c2]%1,%0\")\n-\n-(define_expand \"extzv\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"\")\n-\t(zero_extract:SI (match_operand:SI 1 \"general_operand\" \"\")\n-\t\t\t (match_operand:SI 2 \"general_operand\" \"\")\n-\t\t\t (match_operand:SI 3 \"general_operand\" \"\")))]\n-  \"TARGET_68020 && TARGET_BITFIELD\"\n-  \"\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=d\")\n-\t(zero_extract:SI (match_operand:QI 1 \"memory_operand\" \"o\")\n-\t\t\t (match_operand:SI 2 \"general_operand\" \"di\")\n-\t\t\t (match_operand:SI 3 \"general_operand\" \"di\")))]\n-  \"TARGET_68020 && TARGET_BITFIELD\"\n-  \"bfextu [%c3,%c2]%1,%0\")\n-\n-(define_insn \"\"\n-  [(set (zero_extract:SI (match_operand:QI 0 \"memory_operand\" \"+o\")\n-\t\t\t (match_operand:SI 1 \"general_operand\" \"di\")\n-\t\t\t (match_operand:SI 2 \"general_operand\" \"di\"))\n-        (xor:SI (zero_extract:SI (match_dup 0) (match_dup 1) (match_dup 2))\n-\t\t(match_operand:SI 3 \"const_int_operand\" \"i,i\")))]\n-  \"TARGET_68020 && TARGET_BITFIELD\n-   && (INTVAL (operands[3]) == -1\n-       || (GET_CODE (operands[1]) == CONST_INT\n-           && (~ INTVAL (operands[3]) & ((1 << INTVAL (operands[1]))- 1)) == 0))\"\n-  \"*\n-{\n-  CC_STATUS_INIT;\n-  return \\\"bfchg [%c2,%c1]%0\\\";\n-}\")\n-\n-(define_insn \"\"\n-  [(set (zero_extract:SI (match_operand:QI 0 \"memory_operand\" \"+o\")\n-\t\t\t (match_operand:SI 1 \"general_operand\" \"di\")\n-\t\t\t (match_operand:SI 2 \"general_operand\" \"di\"))\n-\t(const_int 0))]\n-  \"TARGET_68020 && TARGET_BITFIELD\"\n-  \"*\n-{\n-  CC_STATUS_INIT;\n-  return \\\"bfclr [%c2,%c1]%0\\\";\n-}\")\n-\n-(define_insn \"\"\n-  [(set (zero_extract:SI (match_operand:QI 0 \"memory_operand\" \"+o\")\n-\t\t\t (match_operand:SI 1 \"general_operand\" \"di\")\n-\t\t\t (match_operand:SI 2 \"general_operand\" \"di\"))\n-\t(const_int -1))]\n-  \"TARGET_68020 && TARGET_BITFIELD\"\n-  \"*\n-{\n-  CC_STATUS_INIT;\n-  return \\\"bfset [%c2,%c1]%0\\\";\n-}\")\n-\n-(define_expand \"insv\"\n-  [(set (zero_extract:SI (match_operand:SI 0 \"general_operand\" \"\")\n-\t\t\t (match_operand:SI 1 \"general_operand\" \"\")\n-\t\t\t (match_operand:SI 2 \"general_operand\" \"\"))\n-\t(match_operand:SI 3 \"general_operand\" \"\"))]\n-  \"TARGET_68020 && TARGET_BITFIELD\"\n-  \"\")\n-\n-(define_insn \"\"\n-  [(set (zero_extract:SI (match_operand:QI 0 \"memory_operand\" \"+o\")\n-\t\t\t (match_operand:SI 1 \"general_operand\" \"di\")\n-\t\t\t (match_operand:SI 2 \"general_operand\" \"di\"))\n-\t(match_operand:SI 3 \"general_operand\" \"d\"))]\n-  \"TARGET_68020 && TARGET_BITFIELD\"\n-  \"bfins %3,[%c2,%c1]%0\")\n-\n-;; Now recognize bit field insns that operate on registers\n-;; (or at least were intended to do so).\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=d\")\n-\t(sign_extract:SI (match_operand:SI 1 \"register_operand\" \"d\")\n-\t\t\t (match_operand:SI 2 \"general_operand\" \"di\")\n-\t\t\t (match_operand:SI 3 \"general_operand\" \"di\")))]\n-  \"TARGET_68020 && TARGET_BITFIELD\"\n-  \"bfexts [%c3,%c2]%1,%0\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=d\")\n-\t(zero_extract:SI (match_operand:SI 1 \"register_operand\" \"d\")\n-\t\t\t (match_operand:SI 2 \"general_operand\" \"di\")\n-\t\t\t (match_operand:SI 3 \"general_operand\" \"di\")))]\n-  \"TARGET_68020 && TARGET_BITFIELD\"\n-  \"bfextu [%c3,%c2]%1,%0\")\n-\n-(define_insn \"\"\n-  [(set (zero_extract:SI (match_operand:SI 0 \"register_operand\" \"+d\")\n-\t\t\t (match_operand:SI 1 \"general_operand\" \"di\")\n-\t\t\t (match_operand:SI 2 \"general_operand\" \"di\"))\n-\t(const_int 0))]\n-  \"TARGET_68020 && TARGET_BITFIELD\"\n-  \"*\n-{\n-  CC_STATUS_INIT;\n-  return \\\"bfclr [%c2,%c1]%0\\\";\n-}\")\n-\n-(define_insn \"\"\n-  [(set (zero_extract:SI (match_operand:SI 0 \"register_operand\" \"+d\")\n-\t\t\t (match_operand:SI 1 \"general_operand\" \"di\")\n-\t\t\t (match_operand:SI 2 \"general_operand\" \"di\"))\n-\t(const_int -1))]\n-  \"TARGET_68020 && TARGET_BITFIELD\"\n-  \"*\n-{\n-  CC_STATUS_INIT;\n-  return \\\"bfset [%c2,%c1]%0\\\";\n-}\")\n-\n-(define_insn \"\"\n-  [(set (zero_extract:SI (match_operand:SI 0 \"register_operand\" \"+d\")\n-\t\t\t (match_operand:SI 1 \"general_operand\" \"di\")\n-\t\t\t (match_operand:SI 2 \"general_operand\" \"di\"))\n-\t(match_operand:SI 3 \"general_operand\" \"d\"))]\n-  \"TARGET_68020 && TARGET_BITFIELD\"\n-  \"*\n-{\n-  return \\\"bfins %3,[%c2,%c1]%0\\\";\n-}\")\n-\f\n-;; Special patterns for optimizing bit-field instructions.\n-\n-(define_insn \"\"\n-  [(set (cc0)\n-\t(zero_extract:SI (match_operand:QI 0 \"memory_operand\" \"o\")\n-\t\t\t (match_operand:SI 1 \"const_int_operand\" \"i\")\n-\t\t\t (match_operand:SI 2 \"general_operand\" \"di\")))]\n-  \"TARGET_68020 && TARGET_BITFIELD\"\n-  \"*\n-{\n-  if (operands[1] == const1_rtx\n-      && GET_CODE (operands[2]) == CONST_INT)\n-    {    \n-      int width = GET_CODE (operands[0]) == REG ? 31 : 7;\n-      return output_btst (operands, GEN_INT (width - INTVAL (operands[2])),\n-\t\t\t  operands[0], insn, 1000);\n-      /* Pass 1000 as SIGNPOS argument so that btst will\n-         not think we are testing the sign bit for an `and'\n-\t and assume that nonzero implies a negative result.  */\n-    }\n-  if (INTVAL (operands[1]) != 32)\n-    cc_status.flags = CC_NOT_NEGATIVE;\n-  return \\\"bftst [%c2,%c1]%0\\\";\n-}\")\n-\n-;;; now handle the register cases\n-(define_insn \"\"\n-  [(set (cc0)\n-\t(zero_extract:SI (match_operand:SI 0 \"register_operand\" \"d\")\n-\t\t\t (match_operand:SI 1 \"const_int_operand\" \"i\")\n-\t\t\t (match_operand:SI 2 \"general_operand\" \"di\")))]\n-  \"TARGET_68020 && TARGET_BITFIELD\"\n-  \"*\n-{\n-  if (operands[1] == const1_rtx\n-      && GET_CODE (operands[2]) == CONST_INT)\n-    {    \n-      int width = GET_CODE (operands[0]) == REG ? 31 : 7;\n-      return output_btst (operands, GEN_INT (width - INTVAL (operands[2])),\n-\t\t\t  operands[0], insn, 1000);\n-      /* Pass 1000 as SIGNPOS argument so that btst will\n-         not think we are testing the sign bit for an `and'\n-\t and assume that nonzero implies a negative result.  */\n-    }\n-  if (INTVAL (operands[1]) != 32)\n-    cc_status.flags = CC_NOT_NEGATIVE;\n-  return \\\"bftst [%c2,%c1]%0\\\";\n-}\")\n-\n-\f\n-(define_insn \"seq\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"=d\")\n-\t(eq:QI (cc0) (const_int 0)))]\n-  \"\"\n-  \"*\n-  cc_status = cc_prev_status;\n-  OUTPUT_JUMP (\\\"seq %0\\\", \\\"fseq %0\\\", \\\"seq %0\\\");\n-\")\n-\n-(define_insn \"sne\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"=d\")\n-\t(ne:QI (cc0) (const_int 0)))]\n-  \"\"\n-  \"*\n-  cc_status = cc_prev_status;\n-  OUTPUT_JUMP (\\\"sne %0\\\", \\\"fsneq %0\\\", \\\"sne %0\\\");\n-\")\n-\n-(define_insn \"sgt\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"=d\")\n-\t(gt:QI (cc0) (const_int 0)))]\n-  \"\"\n-  \"*\n-  cc_status = cc_prev_status;\n-  OUTPUT_JUMP (\\\"sgt %0\\\", \\\"fsgt %0\\\", \\\"and%.b %#0xc,%!\\;sgt %0\\\");\n-\")\n-\n-(define_insn \"sgtu\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"=d\")\n-\t(gtu:QI (cc0) (const_int 0)))]\n-  \"\"\n-  \"* cc_status = cc_prev_status;\n-     return \\\"shi %0\\\"; \")\n-\n-(define_insn \"slt\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"=d\")\n-\t(lt:QI (cc0) (const_int 0)))]\n-  \"\"\n-  \"* cc_status = cc_prev_status;\n-     OUTPUT_JUMP (\\\"slt %0\\\", \\\"fslt %0\\\", \\\"smi %0\\\"); \")\n-\n-(define_insn \"sltu\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"=d\")\n-\t(ltu:QI (cc0) (const_int 0)))]\n-  \"\"\n-  \"* cc_status = cc_prev_status;\n-     return \\\"scs %0\\\"; \")\n-\n-(define_insn \"sge\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"=d\")\n-\t(ge:QI (cc0) (const_int 0)))]\n-  \"\"\n-  \"* cc_status = cc_prev_status;\n-     OUTPUT_JUMP (\\\"sge %0\\\", \\\"fsge %0\\\", \\\"spl %0\\\"); \")\n-\n-(define_insn \"sgeu\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"=d\")\n-\t(geu:QI (cc0) (const_int 0)))]\n-  \"\"\n-  \"* cc_status = cc_prev_status;\n-     return \\\"scc %0\\\"; \")\n-\n-(define_insn \"sle\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"=d\")\n-\t(le:QI (cc0) (const_int 0)))]\n-  \"\"\n-  \"*\n-  cc_status = cc_prev_status;\n-  OUTPUT_JUMP (\\\"sle %0\\\", \\\"fsle %0\\\", \\\"and%.b %#0xc,%!\\;sle %0\\\");\n-\")\n-\n-(define_insn \"sleu\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"=d\")\n-\t(leu:QI (cc0) (const_int 0)))]\n-  \"\"\n-  \"* cc_status = cc_prev_status;\n-     return \\\"sls %0\\\"; \")\n-\f\n-;; Basic conditional jump instructions.\n-\n-(define_insn \"beq\"\n-  [(set (pc)\n-\t(if_then_else (eq (cc0)\n-\t\t\t  (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"*\n-{\n-  OUTPUT_JUMP (\\\"jeq %l0\\\", \\\"fbeq %l0\\\", \\\"jeq %l0\\\");\n-}\")\n-\n-(define_insn \"bne\"\n-  [(set (pc)\n-\t(if_then_else (ne (cc0)\n-\t\t\t  (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"*\n-{\n-  OUTPUT_JUMP (\\\"jne %l0\\\", \\\"fbneq %l0\\\", \\\"jne %l0\\\");\n-}\")\n-\n-(define_insn \"bgt\"\n-  [(set (pc)\n-\t(if_then_else (gt (cc0)\n-\t\t\t  (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"*\n-  OUTPUT_JUMP (\\\"jgt %l0\\\", \\\"fbgt %l0\\\", \\\"and%.b %#0xc,%!\\;jgt %l0\\\");\n-\")\n-\n-(define_insn \"bgtu\"\n-  [(set (pc)\n-\t(if_then_else (gtu (cc0)\n-\t\t\t   (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"*\n-  return \\\"jhi %l0\\\";\n-\")\n-\n-(define_insn \"blt\"\n-  [(set (pc)\n-\t(if_then_else (lt (cc0)\n-\t\t\t  (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"*\n-  OUTPUT_JUMP (\\\"jlt %l0\\\", \\\"fblt %l0\\\", \\\"jmi %l0\\\");\n-\")\n-\n-(define_insn \"bltu\"\n-  [(set (pc)\n-\t(if_then_else (ltu (cc0)\n-\t\t\t   (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"*\n-  return \\\"jcs %l0\\\";\n-\")\n-\n-(define_insn \"bge\"\n-  [(set (pc)\n-\t(if_then_else (ge (cc0)\n-\t\t\t  (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"*\n-  OUTPUT_JUMP (\\\"jge %l0\\\", \\\"fbge %l0\\\", \\\"jpl %l0\\\");\n-\")\n-\n-(define_insn \"bgeu\"\n-  [(set (pc)\n-\t(if_then_else (geu (cc0)\n-\t\t\t   (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"*\n-  return \\\"jcc %l0\\\";\n-\")\n-\n-(define_insn \"ble\"\n-  [(set (pc)\n-\t(if_then_else (le (cc0)\n-\t\t\t  (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"*\n-  OUTPUT_JUMP (\\\"jle %l0\\\", \\\"fble %l0\\\", \\\"and%.b %#0xc,%!\\;jle %l0\\\");\n-\")\n-\n-(define_insn \"bleu\"\n-  [(set (pc)\n-\t(if_then_else (leu (cc0)\n-\t\t\t   (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"*\n-  return \\\"jls %l0\\\";\n-\")\n-\f\n-;; Negated conditional jump instructions.\n-\n-(define_insn \"\"\n-  [(set (pc)\n-\t(if_then_else (eq (cc0)\n-\t\t\t  (const_int 0))\n-\t\t      (pc)\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n-  \"\"\n-  \"*\n-{\n-  OUTPUT_JUMP (\\\"jne %l0\\\", \\\"fbneq %l0\\\", \\\"jne %l0\\\");\n-}\")\n-\n-(define_insn \"\"\n-  [(set (pc)\n-\t(if_then_else (ne (cc0)\n-\t\t\t  (const_int 0))\n-\t\t      (pc)\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n-  \"\"\n-  \"*\n-{\n-  OUTPUT_JUMP (\\\"jeq %l0\\\", \\\"fbeq %l0\\\", \\\"jeq %l0\\\");\n-}\")\n-\n-(define_insn \"\"\n-  [(set (pc)\n-\t(if_then_else (gt (cc0)\n-\t\t\t  (const_int 0))\n-\t\t      (pc)\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n-  \"\"\n-  \"*\n-  OUTPUT_JUMP (\\\"jle %l0\\\", \\\"fbngt %l0\\\", \\\"and%.b %#0xc,%!\\;jle %l0\\\");\n-\")\n-\n-(define_insn \"\"\n-  [(set (pc)\n-\t(if_then_else (gtu (cc0)\n-\t\t\t   (const_int 0))\n-\t\t      (pc)\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n-  \"\"\n-  \"*\n-  return \\\"jls %l0\\\";\n-\")\n-\n-(define_insn \"\"\n-  [(set (pc)\n-\t(if_then_else (lt (cc0)\n-\t\t\t  (const_int 0))\n-\t\t      (pc)\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n-  \"\"\n-  \"*\n-  OUTPUT_JUMP (\\\"jge %l0\\\", \\\"fbnlt %l0\\\", \\\"jpl %l0\\\");\n-\")\n-\n-(define_insn \"\"\n-  [(set (pc)\n-\t(if_then_else (ltu (cc0)\n-\t\t\t   (const_int 0))\n-\t\t      (pc)\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n-  \"\"\n-  \"*\n-  return \\\"jcc %l0\\\";\n-\")\n-\n-(define_insn \"\"\n-  [(set (pc)\n-\t(if_then_else (ge (cc0)\n-\t\t\t  (const_int 0))\n-\t\t      (pc)\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n-  \"\"\n-  \"*\n-  OUTPUT_JUMP (\\\"jlt %l0\\\", \\\"fbnge %l0\\\", \\\"jmi %l0\\\");\n-\")\n-\n-(define_insn \"\"\n-  [(set (pc)\n-\t(if_then_else (geu (cc0)\n-\t\t\t   (const_int 0))\n-\t\t      (pc)\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n-  \"\"\n-  \"*\n-  return \\\"jcs %l0\\\";\n-\")\n-\n-(define_insn \"\"\n-  [(set (pc)\n-\t(if_then_else (le (cc0)\n-\t\t\t  (const_int 0))\n-\t\t      (pc)\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n-  \"\"\n-  \"*\n-  OUTPUT_JUMP (\\\"jgt %l0\\\", \\\"fbnle %l0\\\", \\\"and%.b %#0xc,%!\\;jgt %l0\\\");\n-\")\n-\n-(define_insn \"\"\n-  [(set (pc)\n-\t(if_then_else (leu (cc0)\n-\t\t\t   (const_int 0))\n-\t\t      (pc)\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n-  \"\"\n-  \"*\n-  return \\\"jhi %l0\\\";\n-\")\n-\f\n-;; Subroutines of \"casesi\".\n-\n-(define_expand \"casesi_1\"\n-  [(set (match_operand:SI 3 \"general_operand\" \"\")\n-\t(plus:SI (match_operand:SI 0 \"general_operand\" \"\")\n-\t\t ;; Note operand 1 has been negated!\n-\t\t (match_operand:SI 1 \"immediate_operand\" \"\")))\n-   (set (cc0) (compare (match_operand:SI 2 \"nonimmediate_operand\" \"\")\n-\t\t       (match_dup 3)))\n-   (set (pc) (if_then_else (ltu (cc0) (const_int 0))\n-\t\t\t   (label_ref (match_operand 4 \"\" \"\")) (pc)))]\n-  \"\"\n-  \"\")\n-\n-(define_expand \"casesi_2\"\n-  [(set (match_operand:HI 0 \"\" \"\") (mem:HI (match_operand:SI 1 \"\" \"\")))\n-   ;; The USE here is so that at least one jump-insn will refer to the label,\n-   ;; to keep it alive in jump_optimize.\n-   (parallel [(set (pc)\n-\t\t   (plus:SI (pc) (sign_extend:SI (match_dup 0))))\n-\t      (use (label_ref (match_operand 2 \"\" \"\")))])]\n-  \"\"\n-  \"\")\n-\n-;; Operand 0 is index (in bytes); operand 1 is minimum, operand 2 the maximum;\n-;; operand 3 is CODE_LABEL for the table;\n-;; operand 4 is the CODE_LABEL to go to if index out of range.\n-(define_expand \"casesi\"\n-  ;; We don't use these for generating the RTL, but we must describe\n-  ;; the operands here.\n-  [(match_operand:HI 0 \"general_operand\" \"\")\n-   (match_operand:SI 1 \"immediate_operand\" \"\")\n-   (match_operand:SI 2 \"general_operand\" \"\")\n-   (match_operand 3 \"\" \"\")\n-   (match_operand 4 \"\" \"\")]\n-  \"\"\n-  \"\n-{\n-  rtx table_elt_addr;\n-  rtx index_diff;\n-\n-  operands[1] = negate_rtx (SImode, operands[1]);\n-  index_diff = gen_reg_rtx (SImode);\n-  /* Emit the first few insns.  */\n-  emit_insn (gen_casesi_1 (operands[0], operands[1], operands[2],\n-\t\t\t   index_diff, operands[4]));\n-  /* Construct a memory address.  This may emit some insns.  */\n-  table_elt_addr\n-    = memory_address_noforce\n-        (HImode,\n-\t gen_rtx_PLUS (Pmode,\n-\t\t       gen_rtx_MULT (Pmode, index_diff, GEN_INT (2)),\n-\t\t       gen_rtx_LABEL_REF (Pmode, operands[3])));\n-  /* Emit the last few insns.  */\n-  emit_insn (gen_casesi_2 (gen_reg_rtx (HImode), table_elt_addr, operands[3]));\n-  DONE;\n-}\")\n-\n-;; Recognize one of the insns resulting from casesi_2.\n-(define_insn \"\"\n-  [(set (pc)\n-\t(plus:SI (pc)\n-\t\t (sign_extend:SI (match_operand:HI 0 \"general_operand\" \"r\"))))\n-   (use (label_ref (match_operand 1 \"\" \"\")))]\n-  \"\"\n-  \"*\n-  return \\\"jmp pc@(2:B)[%0:W:B]\\\";\n-\")\n-\f\n-;; Unconditional and other jump instructions\n-(define_insn \"jump\"\n-  [(set (pc)\n-\t(label_ref (match_operand 0 \"\" \"\")))]\n-  \"\"\n-  \"*\n-  return \\\"jra %l0\\\";\n-\")\n-\n-(define_insn \"\"\n-  [(set (pc)\n-\t(if_then_else\n-\t (ne (match_operand:HI 0 \"general_operand\" \"d,m,g\")\n-\t     (const_int 0))\n-\t (label_ref (match_operand 1 \"\" \"\"))\n-\t (pc)))\n-   (set (match_dup 0)\n-\t(plus:HI (match_dup 0)\n-\t\t (const_int -1)))]\n-  \"\"\n-  \"@\n-   dbra %0,%l1\n-   subq%.w %#1,%0\\;jcc %l1\n-   subq%.w %#1,%0\\;cmp%.w %#-1,%0\\;jne %l1\")\n-\n-(define_insn \"\"\n-  [(set (pc)\n-\t(if_then_else\n-\t (ne (match_operand:SI 0 \"general_operand\" \"d,m,g\")\n-\t     (const_int 0))\n-\t (label_ref (match_operand 1 \"\" \"\"))\n-\t (pc)))\n-   (set (match_dup 0)\n-\t(plus:SI (match_dup 0)\n-\t\t (const_int -1)))]\n-  \"\"\n-  \"@\n-   dbra %0,%l1\\;clr%.w %0\\;subq%.l %#1,%0\\;jcc %l1\n-   subq%.l %#1,%0\\;jcc %l1\n-   subq%.l %#1,%0\\;cmp%.l %#-1,%0\\;jne %l1\")\n-\n-;; dbra patterns that use REG_NOTES info generated by strength_reduce.\n-\n-(define_expand \"decrement_and_branch_until_zero\"\n-  [(parallel [(set (pc)\n-\t\t   (if_then_else\n-\t\t    (ge (match_operand:SI 0 \"general_operand\" \"\")\n-\t\t\t(const_int 1))\n-\t\t    (label_ref (match_operand 1 \"\" \"\"))\n-\t\t    (pc)))\n-\t      (set (match_dup 0)\n-\t\t   (plus:SI (match_dup 0)\n-\t\t\t    (const_int -1)))])]\n-  \"\"\n-  \"\")\n-\n-(define_insn \"\"\n-  [(set (pc)\n-\t(if_then_else\n-\t  (ge (match_operand:SI 0 \"general_operand\" \"d,m,g\")\n-\t      (const_int 1))\n-\t  (label_ref (match_operand 1 \"\" \"\"))\n-\t  (pc)))\n-   (set (match_dup 0)\n-\t(plus:SI (match_dup 0)\n-\t\t (const_int -1)))]\n-  \"find_reg_note (insn, REG_NONNEG, 0)\"\n-  \"@\n-   dbra %0,%l1\\;clrw %0\\;subql %#1,%0\\;jcc %l1\n-   subq%.l %#1,%0\\;jcc %l1\n-   subq%.l %#1,%0\\;cmp%.l %#-1,%0\\;jne %l1\")\n-\n-;; Call subroutine with no return value.\n-(define_insn \"call\"\n-  [(call (match_operand:QI 0 \"memory_operand\" \"o\")\n-\t (match_operand:SI 1 \"general_operand\" \"g\"))]\n-  \"\"\n-  \"*\n-{\n-  rtx xoperands[2];\n-  int size = XINT(operands[1],0);\n-\n-  if (size == 0) \n-    output_asm_insn (\\\"sub%.l a0,a0\\;jbsr %0\\\", operands);\n-  else\n-  {\n-    xoperands[1] = GEN_INT (size/4);\n-    output_asm_insn (\\\"mov%.l sp,a0\\;pea %a1\\\", xoperands);\n-    output_asm_insn (\\\"jbsr %0\\\", operands);\n-    size = size + 4;\n-    xoperands[1] = GEN_INT (size);\n-    if (size <= 8)\n-      output_asm_insn (\\\"addq%.l %1,sp\\\", xoperands);\n-    else if (size < 0x8000)\n-      output_asm_insn (\\\"add%.w %1,sp\\\", xoperands);\n-    else\n-      output_asm_insn (\\\"add%.l %1,sp\\\", xoperands);\n-  }\n-  return \\\"mov%.l a6@(-4),a0\\\";\n-}\")\n-\n-;; Call subroutine, returning value in operand 0\n-;; (which must be a hard register).\n-(define_insn \"call_value\"\n-  [(set (match_operand 0 \"\" \"=rf\")\n-\t(call (match_operand:QI 1 \"memory_operand\" \"o\")\n-\t      (match_operand:SI 2 \"general_operand\" \"g\")))]\n-  \"\"\n-  \"*\n-{\n-  rtx xoperands[3];\n-  int size = XINT(operands[2],0);\n-\n-  if (size == 0)\n-    output_asm_insn(\\\"sub%.l a0,a0\\;jbsr %1\\\", operands);\n-  else\n-  {\n-    xoperands[2] = GEN_INT (size/4);\n-    output_asm_insn (\\\"mov%.l sp,a0\\;pea %a2\\\", xoperands);\n-    output_asm_insn (\\\"jbsr %1\\\", operands);\n-    size = size + 4;\n-    xoperands[2] = GEN_INT (size);\n-    if (size <= 8)\n-      output_asm_insn (\\\"addq%.l %2,sp\\\", xoperands);\n-    else if (size < 0x8000)\n-      output_asm_insn (\\\"add%.w %2,sp\\\", xoperands);\n-    else\n-      output_asm_insn (\\\"add%.l %2,sp\\\", xoperands);\n-  }\n-  return \\\"mov%.l a6@(-4),a0\\\";\n-}\")\n-\n-;; Call subroutine returning any type.\n-\n-(define_expand \"untyped_call\"\n-  [(parallel [(call (match_operand 0 \"\" \"\")\n-\t\t    (const_int 0))\n-\t      (match_operand 1 \"\" \"\")\n-\t      (match_operand 2 \"\" \"\")])]\n-  \"\"\n-  \"\n-{\n-  int i;\n-\n-  emit_call_insn (GEN_CALL (operands[0], const0_rtx, NULL, const0_rtx));\n-\n-  for (i = 0; i < XVECLEN (operands[2], 0); i++)\n-    {\n-      rtx set = XVECEXP (operands[2], 0, i);\n-      emit_move_insn (SET_DEST (set), SET_SRC (set));\n-    }\n-\n-  /* The optimizer does not know that the call sets the function value\n-     registers we stored in the result block.  We avoid problems by\n-     claiming that all hard registers are used and clobbered at this\n-     point.  */\n-  emit_insn (gen_blockage ());\n-\n-  DONE;\n-}\")\n-\n-;; UNSPEC_VOLATILE is considered to use and clobber all hard registers and\n-;; all of memory.  This blocks insns from being moved across this point.\n-\n-(define_insn \"blockage\"\n-  [(unspec_volatile [(const_int 0)] 0)]\n-  \"\"\n-  \"\")\n-\n-(define_insn \"nop\"\n-  [(const_int 0)]\n-  \"\"\n-  \"nop\")\n-\f\n-;; This should not be used unless the add/sub insns can't be.\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=a\")\n-\t(match_operand:QI 1 \"address_operand\" \"p\"))]\n-  \"\"\n-  \"lea %a1,%0\")\n-\f\n-;; This is the first machine-dependent peephole optimization.\n-;; It is useful when a floating value is returned from a function call\n-;; and then is moved into an FP register.\n-;; But it is mainly intended to test the support for these optimizations.\n-\n-;Not applicable to Alliant -- floating results are returned in fp0\n-;(define_peephole\n-;  [(set (reg:SI 15) (plus:SI (reg:SI 15) (const_int 4)))\n-;   (set (match_operand:DF 0 \"register_operand\" \"f\")\n-;\t(match_operand:DF 1 \"register_operand\" \"ad\"))]\n-;  \"FP_REG_P (operands[0]) && ! FP_REG_P (operands[1])\"\n-;  \"*\n-;{\n-;  rtx xoperands[2];\n-;  xoperands[1] = gen_rtx_REG (SImode, REGNO (operands[1]) + 1);\n-;  output_asm_insn (\\\"mov%.l %1,%@\\\", xoperands);\n-;  output_asm_insn (\\\"mov%.l %1,%-\\\", operands);\n-;  return \\\"fmove%.d %+,%0\\\";\n-;}\n-;\")"}, {"sha": "178d76253f5392c84861da361c9494976281365a", "filename": "gcc/config/fx80/xm-fx80.h", "status": "removed", "additions": 0, "deletions": 39, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7b4171a5b8a655097812307bbe261032dfbe366/gcc%2Fconfig%2Ffx80%2Fxm-fx80.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7b4171a5b8a655097812307bbe261032dfbe366/gcc%2Fconfig%2Ffx80%2Fxm-fx80.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffx80%2Fxm-fx80.h?ref=a7b4171a5b8a655097812307bbe261032dfbe366", "patch": "@@ -1,39 +0,0 @@\n-/* Configuration for GNU C-compiler for Alliant FX computers.\n-   Copyright (C) 1989, 1993 Free Software Foundation, Inc.\n-\n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-\n-/* #defines that need visibility everywhere.  */\n-#define FALSE 0\n-#define TRUE 1\n-\n-/* This describes the machine the compiler is hosted on.  */\n-#define HOST_BITS_PER_CHAR 8\n-#define HOST_BITS_PER_SHORT 16\n-#define HOST_BITS_PER_INT 32\n-#define HOST_BITS_PER_LONG 32\n-#define HOST_BITS_PER_LONGLONG 64\n-\n-/* target machine dependencies.\n-   tm.h is a symbolic link to the actual target specific file.   */\n-#include \"tm.h\"\n-\n-/* Arguments to use with `exit'.  */\n-#define SUCCESS_EXIT_CODE 0\n-#define FATAL_EXIT_CODE 33"}, {"sha": "306431cd118f4e95b7e77500826888186b27a17b", "filename": "gcc/config/gmicro/gmicro.c", "status": "removed", "additions": 0, "deletions": 977, "changes": 977, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7b4171a5b8a655097812307bbe261032dfbe366/gcc%2Fconfig%2Fgmicro%2Fgmicro.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7b4171a5b8a655097812307bbe261032dfbe366/gcc%2Fconfig%2Fgmicro%2Fgmicro.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fgmicro%2Fgmicro.c?ref=a7b4171a5b8a655097812307bbe261032dfbe366", "patch": "@@ -1,977 +0,0 @@\n-/* Subroutines for insn-output.c for the Gmicro.\n-   Copyright (C) 1990, 1991, 1997, 1998, 1999 Free Software Foundation, Inc.\n-   Contributed by Masanobu Yuhara, Fujitsu Laboratories LTD.\n-   (yuhara@flab.fujitsu.co.jp)\n-\n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-Among other things, the copyright\n-notice and this notice must be preserved on all copies.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"rtl.h\"\n-#include \"regs.h\"\n-#include \"hard-reg-set.h\"\n-#include \"real.h\"\n-#include \"insn-config.h\"\n-#include \"conditions.h\"\n-#include \"insn-flags.h\"\n-#include \"output.h\"\n-#include \"function.h\"\n-#include \"insn-attr.h\"\n-\n-mypr (s, a1, a2, a3, a4, a5)\n-     char *s;\n-     int a1, a2, a3, a4, a5;\n-{\n-  fprintf (stderr, s, a1, a2, a3, a4, a5);\n-}\n-\n-myprcode (i)\n-     int i;\n-{\n-  if (i < 0 || i > 90)\n-    fprintf (stderr, \"code = %d\\n\", i);\n-  else\n-    fprintf (stderr, \"code = %s\\n\", GET_RTX_NAME(i));\n-}\n-\n-myabort (i)\n-     int i;\n-{\n-  fprintf (stderr, \"myabort\");\n-  myprcode (i);\n-}\n-\n-\n-/* This is how to output an ascii string.  */\n-/* See ASM_OUTPUT_ASCII in gmicro.h.  */\n-output_ascii (file, p, size)\n-     FILE *file;\n-     char *p;\n-     int size;\n-{\n-  int i;\n-  int in_quote = 0;\n-  register int c;\n-\n-  fprintf (file, \"\\t.sdata \");\n-\n-  for (i = 0; i < size; i++) \n-    {\n-      c = p[i];\n-      if (c >= ' ' && c < 0x7f) \n-\t{\n-\t  if (!in_quote) \n-\t    {\n-\t      putc ('\"', file);\n-\t      in_quote = 1;\n-\t    }\n-\t  putc (c, file);\n-\t}\n-      else \n-\t{\n-\t  if (in_quote) \n-\t    {\n-\t      putc ('\"', file);\n-\t      in_quote = 0;\n-\t    }\n-\t  fprintf (file, \"<%d>\", c);\n-\t}\n-    }\n-  if (in_quote)\n-    putc ('\"', file);\n-  putc ('\\n', file);\n-}\n-\n-\n-/* call this when GET_CODE (index) is MULT. */\n-print_scaled_index (file, index)\n-     FILE *file;\n-     register rtx index;\n-{\n-  register rtx ireg;\n-  int scale;\n-\n-  if (GET_CODE (XEXP (index, 0)) == REG) \n-    {\n-      ireg = XEXP (index, 0);\n-      scale = INTVAL (XEXP (index, 1));\n-    }\n-  else \n-    {\n-      ireg = XEXP (index, 1);\n-      scale = INTVAL (XEXP (index, 0));\n-    }\n-  if (scale == 1)\n-    fprintf (file, \"%s\", reg_names[REGNO (ireg)]);\n-  else\n-    fprintf (file, \"%s*%d\", reg_names[REGNO (ireg)], scale);\n-}\n-    \n-\n-print_operand_address (file, addr)\n-     FILE *file;\n-     register rtx addr;\n-{\n-  register rtx xtmp0, xtmp1, breg, ixreg;\n-  int scale;\n-  int needcomma = 0;\n-  rtx offset;\n-\n-  fprintf (file, \"@\");\n- retry:\n-  switch (GET_CODE (addr)) \n-    {\n-    case MEM:\n-      fprintf (file, \"@\");\n-      addr = XEXP (addr, 0);\n-      goto retry;\n-\n-    case REG:\n-      fprintf (file, \"%s\", reg_names[REGNO (addr)]);\n-      break;\n-\n-    case MULT:\n-      print_scaled_index (file, addr);\n-      break;\n-\n-    case PRE_DEC:\n-      fprintf (file, \"-%s\", reg_names[REGNO (XEXP (addr, 0))]);\n-      break;\n-\n-    case POST_INC:\n-      fprintf (file, \"%s+\", reg_names[REGNO (XEXP (addr, 0))]);\n-      break;\n-\n-    case PLUS:\n-      xtmp0 = XEXP (addr, 0);\n-      xtmp1 = XEXP (addr, 1);\n-      ixreg = 0;\tbreg = 0;\n-      offset = 0;\n-      if (CONSTANT_ADDRESS_P (xtmp0)) \n-\t{\n-\t  offset = xtmp0;\n-\t  breg = xtmp1;\n-\t}\n-      else if (CONSTANT_ADDRESS_P (xtmp1)) \n-\t{\n-\t  offset = xtmp1;\n-\t  breg = xtmp0;\n-\t}\n-      else \n-\t{\n-\t  goto NOT_DISP;\n-\t}\n-\n-      if (REG_CODE_BASE_P (breg))\n-\tgoto PRINT_MEM;\n-\n-      if (GET_CODE (breg) == MULT) \n-\t{\n-\t  if (REG_CODE_INDEX_P (XEXP (breg, 0))) \n-\t    {\n-\t      ixreg = XEXP (breg, 0);\n-\t      scale = INTVAL (XEXP (breg, 1));\n-\t      breg = 0;\n-\t    }\n-\t  else \n-\t    {\n-\t      ixreg = XEXP (breg, 1);\n-\t      scale = INTVAL (XEXP (breg, 0));\n-\t      breg = 0;\n-\t    }\n-\t  goto PRINT_MEM;\n-\t}\n-\n-      /* GET_CODE (breg) must be PLUS here. */\n-      xtmp0 = XEXP (breg, 0);\n-      xtmp1 = XEXP (breg, 1);\n-      if (REG_CODE_BASE_P (xtmp0)) \n-\t{\n-\t  breg = xtmp0;\n-\t  xtmp0 = xtmp1;\n-\t}\n-      else \n-\t{\n-\t  breg = xtmp1;\n-\t  /* xtmp0 = xtmp0; */\n-\t}\n-\n-      if (GET_CODE (xtmp0) == MULT) \n-\t{\n-\t  if (REG_CODE_INDEX_P (XEXP (xtmp0, 0))) \n-\t    {\n-\t      ixreg = XEXP (xtmp0, 0);\n-\t      scale = INTVAL (XEXP (xtmp0, 1));\n-\t    }\n-\t  else \n-\t    {\n-\t      ixreg = XEXP (xtmp0, 1);\n-\t      scale = INTVAL (XEXP (xtmp0, 0));\n-\t    }\n-\t}\n-      else \n-\t{\n-\t  ixreg = xtmp0;\n-\t  scale = 1;\n-\t}\n-      goto PRINT_MEM;\n-\n-    NOT_DISP:\n-      if (REG_CODE_BASE_P (xtmp0)) \n-\t{\n-\t  breg = xtmp0;\n-\t  xtmp0 = xtmp1;\n-\t}\n-      else if (REG_CODE_BASE_P (xtmp1)) \n-\t{\n-\t  breg = xtmp1;\n-\t  /* xtmp0 = xtmp0; */\n-\t}\n-      else\n-\tgoto NOT_BASE;\n-    \n-      if (REG_CODE_INDEX_P (xtmp0)) \n-\t{\n-\t  ixreg = xtmp0;\n-\t  scale = 1;\n-\t  goto PRINT_MEM;\n-\t}\n-      else if (CONSTANT_ADDRESS_P (xtmp0)) \n-\t{\n-\t  offset = xtmp0;\n-\t  goto PRINT_MEM;\n-\t}\n-      else if (GET_CODE (xtmp0) == MULT) \n-\t{\n-\t  if (REG_CODE_INDEX_P (XEXP (xtmp0, 0))) \n-\t    {\n-\t      ixreg = XEXP (xtmp0, 0);\n-\t      scale = INTVAL (XEXP (xtmp0, 1));\n-\t    }\n-\t  else \n-\t    {\n-\t      ixreg = XEXP (xtmp0, 1);\n-\t      scale = INTVAL (XEXP (xtmp0, 0));\n-\t    }\n-\t  goto PRINT_MEM;\n-\t}\n-\n-      /* GET_CODE (xtmp0) must be PLUS. */\n-      xtmp1 = XEXP (xtmp0, 1);\n-      xtmp0 = XEXP (xtmp0, 0);\n-\n-      if (CONSTANT_ADDRESS_P (xtmp0)) \n-\t{\n-\t  offset = xtmp0;\n-\t  xtmp0 = xtmp1;\n-\t}\n-      else \n-\t{\n-\t  offset = xtmp1;\n-\t  /* xtmp0 = xtmp0; */\n-\t}\n-\n-      if (REG_CODE_INDEX_P (xtmp0)) \n-\t{\n-\t  ixreg = xtmp0;\n-\t}\n-      else \n-\t{\t\t\t/* GET_CODE (xtmp0) must be MULT. */\n-\t  if (REG_CODE_INDEX_P (XEXP (xtmp0, 0))) \n-\t    {\n-\t      ixreg = XEXP (xtmp0, 0);\n-\t      scale = INTVAL (XEXP (xtmp0, 1));\n-\t    }\n-\t  else \n-\t    {\n-\t      ixreg = XEXP (xtmp0, 1);\n-\t      scale = INTVAL (XEXP (xtmp0, 0));\n-\t    }\n-\t}\n-      goto PRINT_MEM;\n-\n-    NOT_BASE:\n-      if (GET_CODE (xtmp0) == PLUS) \n-\t{\n-\t  ixreg = xtmp1;\n-\t  /* xtmp0 = xtmp0; */\n-\t}\n-      else \n-\t{\n-\t  ixreg = xtmp0;\n-\t  xtmp0 = xtmp1;\n-\t}\n-\n-      if (REG_CODE_INDEX_P (ixreg)) \n-\t{\n-\t  scale = 1;\n-\t}\n-      else if (REG_CODE_INDEX_P (XEXP (ixreg, 0))) \n-\t{\n-\t  scale = INTVAL (XEXP (ixreg, 1));\n-\t  ixreg = XEXP (ixreg, 0);\n-\t}\n-      else \n-\t{\t\t\t/* was else if with no condition. OK ??? */\n-\t  scale = INTVAL (XEXP (ixreg, 0));\n-\t  ixreg = XEXP (ixreg, 1);\n-\t}\n-\n-      if (REG_CODE_BASE_P (XEXP (xtmp0, 0))) \n-\t{\n-\t  breg = XEXP (xtmp0, 0);\n-\t  offset = XEXP (xtmp0, 1);\n-\t}\n-      else \n-\t{\n-\t  breg = XEXP (xtmp0, 1);\n-\t  offset = XEXP (xtmp0, 0);\n-\t}\n-\n-    PRINT_MEM:\n-      if (breg == 0 && ixreg == 0) \n-\t{\n-\t  output_address (offset);\n-\t  break;\n-\t}\n-      else if (ixreg == 0 && offset == 0) \n-\t{\n-\t  fprintf (file, \"%s\", reg_names[REGNO (breg)]);\n-\t  break;\n-\t}\n-      else \n-\t{\n-\t  fprintf (file, \"(\");\n-\t  if (offset != 0) \n-\t    {\n-\t      output_addr_const (file, offset);\n-\t      needcomma = 1;\n-\t    }\n-\t  if (breg != 0) \n-\t    {\n-\t      if (needcomma)\n-\t\tfprintf (file, \",\");\n-\t      fprintf (file, \"%s\", reg_names[REGNO (breg)]);\n-\t      needcomma = 1;\n-\t    }\n-\t  if (ixreg != 0) \n-\t    {\n-\t      if (needcomma)\n-\t\tfprintf (file, \",\");\n-\t      fprintf (file, \"%s\", reg_names[REGNO (ixreg)]);\n-\t      if (scale != 1)\n-\t\tfprintf (file,\"*%d\", scale);\n-\t    }\n-\t  fprintf (file, \")\");\n-\n-\t  break;\n-\t}\n-\n-    default:\n-      output_addr_const (file, addr);\n-    }\n-}\n-\n-\n-\n-/* Return a REG that occurs in ADDR with coefficient 1.\n-   ADDR can be effectively incremented by incrementing REG.  */\n-\n-static rtx\n-find_addr_reg (addr)\n-     rtx addr;\n-{\n-  while (GET_CODE (addr) == PLUS)\n-    {\n-      if (GET_CODE (XEXP (addr, 0)) == REG)\n-\taddr = XEXP (addr, 0);\n-      else if (GET_CODE (XEXP (addr, 1)) == REG)\n-\taddr = XEXP (addr, 1);\n-      else if (GET_CODE (XEXP (addr, 0)) == PLUS)\n-\taddr = XEXP (addr, 0);\n-      else if (GET_CODE (XEXP (addr, 1)) == PLUS)\n-\taddr = XEXP (addr, 1);\n-    }\n-  if (GET_CODE (addr) == REG)\n-    return addr;\n-  return 0;\n-}\n-\n-\n-    /* Return the best assembler insn template\n-    for moving operands[1] into operands[0] as a fullword.  */\n-\n-static char *\n-singlemove_string (operands)\n-     rtx *operands;\n-{\n-  if (FPU_REG_P (operands[0]) || FPU_REG_P (operands[1])) \n-    {\n-      if (GREG_P (operands[0]) || GREG_P (operands[1])) \n-\t{\n-\t  myabort (101);\t/* Not Supported yet !! */\n-\t}\n-      else \n-\t{\n-\t  return \"fmov.s %1,%0\";\n-\t}\n-    }\n-  return \"mov.w %1,%0\";\n-}\n-\n-\n-/* Output assembler code to perform a doubleword move insn\n-   with operands OPERANDS.  */\n-\n-char *\n-output_move_double (operands)\n-     rtx *operands;\n-{\n-  enum \n-    { REGOP, OFFSOP, MEMOP, PUSHOP, POPOP, CNSTOP, RNDOP }\n-  optype0, optype1;\n-  rtx latehalf[2];\n-  rtx addreg0 = 0, addreg1 = 0;\n-\n-  /* First classify both operands.  */\n-\n-  if (REG_P (operands[0]))\n-    optype0 = REGOP;\n-  else if (offsettable_memref_p (operands[0]))\n-    optype0 = OFFSOP;\n-  else if (GET_CODE (XEXP (operands[0], 0)) == POST_INC)\n-    optype0 = POPOP;\n-  else if (GET_CODE (XEXP (operands[0], 0)) == PRE_DEC)\n-    optype0 = PUSHOP;\n-  else if (GET_CODE (operands[0]) == MEM)\n-    optype0 = MEMOP;\n-  else\n-    optype0 = RNDOP;\n-\n-  if (REG_P (operands[1]))\n-    optype1 = REGOP;\n-  else if (CONSTANT_P (operands[1]))\n-    optype1 = CNSTOP;\n-  else if (offsettable_memref_p (operands[1]))\n-    optype1 = OFFSOP;\n-  else if (GET_CODE (XEXP (operands[1], 0)) == POST_INC)\n-    optype1 = POPOP;\n-  else if (GET_CODE (XEXP (operands[1], 0)) == PRE_DEC)\n-    optype1 = PUSHOP;\n-  else if (GET_CODE (operands[1]) == MEM)\n-    optype1 = MEMOP;\n-  else\n-    optype1 = RNDOP;\n-\n-  /* Check for the cases that the operand constraints are not\n-     supposed to allow to happen.  Abort if we get one,\n-     because generating code for these cases is painful.  */\n-\n-  if (optype0 == RNDOP || optype1 == RNDOP)\n-    myabort (102);\n-\n-  /* If one operand is decrementing and one is incrementing\n-     decrement the former register explicitly\n-     and change that operand into ordinary indexing.  */\n-\n-  if (optype0 == PUSHOP && optype1 == POPOP)\n-    {\n-      operands[0] = XEXP (XEXP (operands[0], 0), 0);\n-      output_asm_insn (\"sub.w %#8,%0\", operands);\n-      operands[0] = gen_rtx_MEM (DImode, operands[0]);\n-      optype0 = OFFSOP;\n-    }\n-  if (optype0 == POPOP && optype1 == PUSHOP)\n-    {\n-      operands[1] = XEXP (XEXP (operands[1], 0), 0);\n-      output_asm_insn (\"sub.w %#8,%1\", operands);\n-      operands[1] = gen_rtx_MEM (DImode, operands[1]);\n-      optype1 = OFFSOP;\n-    }\n-\n-  /* If an operand is an unoffsettable memory ref, find a register\n-     we can increment temporarily to make it refer to the second word.  */\n-\n-  if (optype0 == MEMOP)\n-    addreg0 = find_addr_reg (operands[0]);\n-\n-  if (optype1 == MEMOP)\n-    addreg1 = find_addr_reg (operands[1]);\n-\n-  /* Ok, we can do one word at a time.\n-     Normally we do the low-numbered word first,\n-     but if either operand is autodecrementing then we\n-     do the high-numbered word first.\n-     \n-     In either case, set up in LATEHALF the operands to use\n-     for the high-numbered word and in some cases alter the\n-     operands in OPERANDS to be suitable for the low-numbered word.  */\n-\n-  if (optype0 == REGOP)\n-    latehalf[0] = gen_rtx_REG (SImode, REGNO (operands[0]) + 1);\n-  else if (optype0 == OFFSOP)\n-    latehalf[0] = adj_offsettable_operand (operands[0], 4);\n-  else\n-    latehalf[0] = operands[0];\n-\n-  if (optype1 == REGOP)\n-    latehalf[1] = gen_rtx_REG (SImode, REGNO (operands[1]) + 1);\n-  else if (optype1 == OFFSOP)\n-    latehalf[1] = adj_offsettable_operand (operands[1], 4);\n-  else if (optype1 == CNSTOP)\n-    {\n-      if (GET_CODE (operands[1]) == CONST_DOUBLE)\n-\tsplit_double (operands[1], &operands[1], &latehalf[1]);\n-      else if (CONSTANT_P (operands[1]))\n-\tlatehalf[1] = const0_rtx;\n-    }\n-  else\n-    latehalf[1] = operands[1];\n-\n-  /* If insn is effectively movd N(sp),-(sp) then we will do the\n-     high word first.  We should use the adjusted operand 1 (which is N+4(sp))\n-     for the low word as well, to compensate for the first decrement of sp.  */\n-  if (optype0 == PUSHOP\n-      && REGNO (XEXP (XEXP (operands[0], 0), 0)) == STACK_POINTER_REGNUM\n-      && reg_overlap_mentioned_p (stack_pointer_rtx, operands[1]))\n-    operands[1] = latehalf[1];\n-\n-  /* If one or both operands autodecrementing,\n-     do the two words, high-numbered first.  */\n-\n-  /* Likewise,  the first move would clobber the source of the second one,\n-     do them in the other order.  This happens only for registers;\n-     such overlap can't happen in memory unless the user explicitly\n-     sets it up, and that is an undefined circumstance.  */\n-\n-  if (optype0 == PUSHOP || optype1 == PUSHOP\n-      || (optype0 == REGOP && optype1 == REGOP\n-\t  && REGNO (operands[0]) == REGNO (latehalf[1])))\n-    {\n-      /* Make any unoffsettable addresses point at high-numbered word.  */\n-      if (addreg0)\n-\toutput_asm_insn (\"add.w %#4,%0\", &addreg0);\n-      if (addreg1)\n-\toutput_asm_insn (\"add.w %#4,%0\", &addreg1);\n-\n-      /* Do that word.  */\n-      output_asm_insn (singlemove_string (latehalf), latehalf);\n-\n-      /* Undo the adds we just did.  */\n-      if (addreg0)\n-\toutput_asm_insn (\"sub.w %#4,%0\", &addreg0);\n-      if (addreg1)\n-\toutput_asm_insn (\"sub.w %#4,%0\", &addreg1);\n-\n-      /* Do low-numbered word.  */\n-      return singlemove_string (operands);\n-    }\n-\n-  /* Normal case: do the two words, low-numbered first.  */\n-\n-  output_asm_insn (singlemove_string (operands), operands);\n-\n-  /* Make any unoffsettable addresses point at high-numbered word.  */\n-  if (addreg0)\n-    output_asm_insn (\"add.w %#4,%0\", &addreg0);\n-  if (addreg1)\n-    output_asm_insn (\"add.w %#4,%0\", &addreg1);\n-\n-  /* Do that word.  */\n-  output_asm_insn (singlemove_string (latehalf), latehalf);\n-\n-  /* Undo the adds we just did.  */\n-  if (addreg0)\n-    output_asm_insn (\"sub.w %#4,%0\", &addreg0);\n-  if (addreg1)\n-    output_asm_insn (\"sub.w %#4,%0\", &addreg1);\n-\n-  return \"\";\n-}\n-\n-/* Move const_double to floating point register (DF) */\n-char *\n-output_move_const_double (operands)\n-     rtx *operands;\n-{\n-  int code = standard_fpu_constant_p (operands[1]);\n-\n-  if (FPU_REG_P (operands[0])) \n-    {\n-      if (code != 0)\n-\t{\n-\t  static char buf[40];\n-\n-\t  sprintf (buf, \"fmvr from%d,%%0.d\", code);\n-\t  return buf;\n-\t}\n-      else \n-\t{\n-\t  return \"fmov %1,%0.d\";\n-\t}\n-    }\n-  else if (GREG_P (operands[0])) \n-    {\n-      rtx xoperands[2];\n-      xoperands[0] = gen_rtx_REG (SImode, REGNO (operands[0]) + 1);\n-      xoperands[1] = GEN_INT (CONST_DOUBLE_HIGH (operands[1]));\n-      output_asm_insn (\"mov.w %1,%0\", xoperands);\n-      operands[1] = GEN_INT (CONST_DOUBLE_LOW (operands[1]));\n-      return \"mov.w %1,%0\";\n-    }\n-  else \n-    return output_move_double (operands); /* ?????? */\n-}\n-\n-char *\n-output_move_const_single (operands)\n-     rtx *operands;\n-{\n-  int code = standard_fpu_constant_p (operands[1]);\n-  static char buf[40];\n-\n-  if (FPU_REG_P (operands[0])) \n-    {\n-      if (code != 0)\n-\t{\n-\t  sprintf (buf, \"fmvr from%d,%%0.s\", code);\n-\t  return buf;\n-\t}\n-      return \"fmov.s %f1,%0\";\n-    }\n-  else \n-    return \"mov.w %f1,%0\";\n-}\n-\n-\n-/* Return nonzero if X, a CONST_DOUBLE, has a value that we can get\n-   from the \"fmvr\" instruction of the Gmicro FPU.\n-   The value, anded with 0xff, gives the code to use in fmovecr\n-   to get the desired constant.  */\n-\n-  u.i[0] = CONST_DOUBLE_LOW (x);\n-  u.i[1] = CONST_DOUBLE_HIGH (x);\n-  d = u.d;\n-\n-  if (d == 0.0)\t\t\t/* +0.0 */\n-    return 0x0;\n-  /* Note: there are various other constants available\n-     but it is a nuisance to put in their values here.  */\n-  if (d == 1.0)\t\t\t/* +1.0 */\n-    return 0x1;\n-\n-  /*\n-   * Stuff that looks different if it's single or double\n-   */\n-  if (GET_MODE (x) == SFmode)\n-    {\n-      if (d == S_PI)\n-\treturn 0x2;\n-      if (d == (S_PI / 2.0))\n-\treturn 0x3;\n-      if (d == S_E)\n-\treturn 0x4;\n-      if (d == S_LOGEof2)\n-\treturn 0x5;\n-      if (d == S_LOGEof10)\n-\treturn 0x6;\n-      if (d == S_LOG10of2)\n-\treturn 0x7;\n-      if (d == S_LOG10ofE)\n-\treturn 0x8;\n-      if (d == S_LOG2ofE)\n-\treturn 0x9;\n-    }\n-  else\n-    {\n-      if (d == D_PI)\n-\treturn 0x2;\n-      if (d == (D_PI / 2.0))\n-\treturn 0x3;\n-      if (d == D_E)\n-\treturn 0x4;\n-      if (d == D_LOGEof2)\n-\treturn 0x5;\n-      if (d == D_LOGEof10)\n-\treturn 0x6;\n-      if (d == D_LOG10of2)\n-\treturn 0x7;\n-      if (d == D_LOG10ofE)\n-\treturn 0x8;\n-      if (d == D_LOG2ofE)\n-\treturn 0x9;\n-    }\n-\n-  return 0;\n-}\n-\n-#undef S_PI\n-#undef D_PI\n-#undef S_E\n-#undef D_E\n-#undef S_LOGEof2\n-#undef D_LOGEof2\n-#undef S_LOGEof10\n-#undef D_LOGEof10\n-#undef S_LOG10of2\n-#undef D_LOG10of2\n-#undef S_LOG10ofE\n-#undef D_LOG10ofE\n-#undef S_LOG2ofE\n-#undef D_LOG2ofE\n-\n-/* dest should be operand 0 */\n-/* imm should be operand 1 */\n-\n-extern char *sub_imm_word ();\n-\n-char *\n-add_imm_word (imm, dest, immp)\n-     int imm;\n-     rtx dest, *immp;\n-{\n-  int is_reg, short_ok;\n-\n-\n-  if (imm < 0) \n-    {\n-      *immp = GEN_INT (-imm);\n-      return sub_imm_word (-imm, dest);\n-    }\n-    \n-  if (imm == 0)\n-    return \"mov:l.w #0,%0\";\n-    \n-  short_ok = short_format_ok (dest);\n-\n-  if (short_ok && imm <= 8)\n-    return \"add:q %1,%0.w\";\n-\n-  if (imm < 128)\n-    return \"add:e %1,%0.w\";\n-\n-  is_reg = (GET_CODE (dest) == REG);\n-\n-  if (is_reg)\n-    return \"add:l %1,%0.w\";\n-    \n-  if (short_ok)\n-    return \"add:i %1,%0.w\";\n-    \n-  return \"add %1,%0.w\";\n-}\n-\n-char *\n-sub_imm_word (imm, dest, immp)\n-     int imm;\n-     rtx dest, *immp;\n-{\n-  int is_reg, short_ok;\n-\n-  if (imm < 0 &&  imm != 0x80000000) \n-    {\n-      *immp = GEN_INT (-imm);\n-      return add_imm_word (-imm, dest);\n-    }\n-    \n-  if (imm == 0)\n-    return \"mov:z.w #0,%0\";\n-    \n-  short_ok = short_format_ok (dest);\n-\n-  if (short_ok && imm <= 8)\n-    return \"sub:q %1,%0.w\";\n-\n-  if (imm < 128)\n-    return \"sub:e %1,%0.w\";\n-\n-  is_reg = (GET_CODE (dest) == REG);\n-\n-  if (is_reg)\n-    return \"sub:l %1,%0.w\";\n-    \n-  if (short_ok)\n-    return \"sub:i %1,%0.w\";\n-    \n-  return \"sub %1,%0.w\";\n-}\n-\n-int\n-short_format_ok (x)\n-     rtx x;\n-{\n-  rtx x0, x1;\n-\n-  if (GET_CODE (x) == REG)\n-    return 1;\n-\n-  if (GET_CODE (x) == MEM \n-      && GET_CODE (XEXP (x, 0)) == PLUS) \n-    {\n-      x0 = XEXP (XEXP (x, 0), 0);\n-      x1 = XEXP (XEXP (x, 0), 1);\n-      return ((GET_CODE (x0) == REG\n-\t       && CONSTANT_P (x1)\n-\t       && ((unsigned) (INTVAL (x1) + 0x8000)  < 0x10000))\n-\t      ||\n-\t      (GET_CODE (x1) == REG\n-\t       && CONSTANT_P (x0)\n-\t       && ((unsigned) (INTVAL (x0) + 0x8000)  < 0x10000)));\n-    }\n-\n-  return 0;\n-}\n-\n-myoutput_sp_adjust (file, op, fsize)\n-     FILE *file;\n-     char *op;\n-     int fsize;\n-{\n-  if (fsize == 0)\n-    ;\n-  else if (fsize < 8)\n-    fprintf (file, \"\\t%s:q #%d,sp.w\\n\", op, fsize);\n-  else if (fsize < 128)\n-    fprintf (file, \"\\t%s:e #%d,sp.w\\n\", op, fsize);\n-  else\n-    fprintf (file, \"\\t%s:l #%d,sp.w\\n\", op, fsize);\n-}\n-\n-\n-char *\n-mov_imm_word (imm, dest)\n-     int imm;\n-     rtx dest;\n-{\n-  int is_reg, short_ok;\n-\n-  if (imm == 0)\n-    return \"mov:z.w #0,%0\";\n-    \n-  short_ok = short_format_ok (dest);\n-\n-  if (short_ok && imm > 0 && imm <= 8)\n-    return \"mov:q %1,%0.w\";\n-\n-  if (-128 <= imm && imm < 128)\n-    return \"mov:e %1,%0.w\";\n-\n-  is_reg = (GET_CODE (dest) == REG);\n-\n-  if (is_reg)\n-    return \"mov:l %1,%0.w\";\n-    \n-  if (short_ok)\n-    return \"mov:i %1,%0.w\";\n-    \n-  return \"mov %1,%0.w\";\n-}\n-\n-char *\n-cmp_imm_word (imm, dest)\n-     int imm;\n-     rtx dest;\n-{\n-  int is_reg, short_ok;\n-\n-  if (imm == 0)\n-    return \"cmp:z.w #0,%0\";\n-    \n-  short_ok = short_format_ok (dest);\n-\n-  if (short_ok && imm >0 && imm <= 8)\n-    return \"cmp:q %1,%0.w\";\n-\n-  if (-128 <= imm && imm < 128)\n-    return \"cmp:e %1,%0.w\";\n-\n-  is_reg = (GET_CODE (dest) == REG);\n-\n-  if (is_reg)\n-    return \"cmp:l %1,%0.w\";\n-    \n-  if (short_ok)\n-    return \"cmp:i %1,%0.w\";\n-    \n-  return \"cmp %1,%0.w\";\n-}\n-\n-char *\n-push_imm_word (imm)\n-     int imm;\n-{\n-  if (imm == 0)\n-    return \"mov:z.w #0,%-\";\n-    \n-  if (imm > 0 && imm <= 8)\n-    return \"mov:q %1,%-.w\";\n-\n-  if (-128 <= imm && imm < 128)\n-    return \"mov:e %1,%-.w\";\n-\n-  return \"mov:g %1,%-.w\";\n-    \n-  /* In some cases, g-format may be better than I format.??\n-     return \"mov %1,%0.w\";\n-     */\n-}\n-\n-my_signed_comp (insn)\n-     rtx insn;\n-{\n-  rtx my_insn;\n-\n-  my_insn = NEXT_INSN (insn);\n-  if (GET_CODE (my_insn) != JUMP_INSN) \n-    {\n-      fprintf (stderr, \"my_signed_comp: Not Jump_insn \");\n-      myabort (GET_CODE (my_insn));\n-    }\n-  my_insn = PATTERN (my_insn);\n-  if (GET_CODE (my_insn) != SET) \n-    {\n-      fprintf (stderr, \"my_signed_comp: Not Set \");\n-      myabort (GET_CODE (my_insn));\n-    }\n-  my_insn = SET_SRC (my_insn);\n-  if (GET_CODE (my_insn) != IF_THEN_ELSE) \n-    {\n-      fprintf (stderr, \"my_signed_comp: Not if_then_else \");\n-      myabort (GET_CODE (my_insn));\n-    }\n-  switch (GET_CODE (XEXP (my_insn, 0)))\n-    {\n-    case NE:\n-    case EQ:\n-    case GE:\n-    case GT:\n-    case LE:\n-    case LT:\n-      return 1;\n-    case GEU:\n-    case GTU:\n-    case LEU:\n-    case LTU:\n-      return 0;\n-    }\n-  fprintf (stderr, \"my_signed_comp: Not cccc \");\n-  myabort (GET_CODE (XEXP (my_insn, 0)));\n-}"}, {"sha": "59c95f8eab7ae7cfb9e4dbef7a6c7f20fa51102f", "filename": "gcc/config/gmicro/gmicro.h", "status": "removed", "additions": 0, "deletions": 1588, "changes": 1588, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7b4171a5b8a655097812307bbe261032dfbe366/gcc%2Fconfig%2Fgmicro%2Fgmicro.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7b4171a5b8a655097812307bbe261032dfbe366/gcc%2Fconfig%2Fgmicro%2Fgmicro.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fgmicro%2Fgmicro.h?ref=a7b4171a5b8a655097812307bbe261032dfbe366", "patch": "@@ -1,1588 +0,0 @@\n-/* Definitions of target machine for GNU compiler.  Gmicro (TRON) version.\n-   Copyright (C) 1987, 1988, 1989, 1995, 1996, 1997, 1998, 1999, 2000\n-   Free Software Foundation, Inc.\n-   Contributed by Masanobu Yuhara, Fujitsu Laboratories LTD.\n-   (yuhara@flab.fujitsu.co.jp)\n-\n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.   */\n-\n-\n-/* Note that some other tm.h files include this one and then override\n-   many of the definitions that relate to assembler syntax.  */\n-\n-\n-/* Names to predefine in the preprocessor for this target machine.  */\n-\n-#define CPP_PREDEFINES \"-Dgmicro -Acpu(tron) -Amachine(tron)\"\n-\n-/* #define CPP_SPEC    ** currently not defined **/\n-\n-/* #define CC1_SPEC    ** currently not defined **/\n-\n-\n-/* Print subsidiary information on the compiler version in use.  */\n-/*\n-#define TARGET_VERSION fprintf (stderr, \" (Gmicro syntax)\");\n-*/\n-\n-/* Run-time compilation parameters selecting different hardware subsets.  */\n-\n-extern int target_flags;\n-\n-/* Macros used in the machine description to test the flags.  */\n-\n-/* Compile for a Gmicro/300.  */\n-#define TARGET_G300 (target_flags & 1)\n-/* Compile for a Gmicro/200. */\n-#define TARGET_G200 (target_flags & 2)\n-/* Compile for a Gmicro/100. */\n-#define TARGET_G100 (target_flags & 4)\n-\n-/* Compile FPU insns for floating point (not library calls).  */\n-#define TARGET_FPU (target_flags & 8)\n-\n-/* Pop up arguments by called function. */\n-#define TARGET_RTD (target_flags & 0x10)\n-\n-/* Compile passing first args in regs 0 and 1.\n-   This exists only to test compiler features that will be needed for\n-   RISC chips. It is not usable and is not intended to be usable on\n-   this cpu ;-< */\n-#define TARGET_REGPARM (target_flags & 0x20)\n-\n-#define TARGET_BITFIELD (target_flags & 0x40)\n-\n-#define TARGET_NEWRETURN (target_flags & 0x80)\n-\n-/* Do not expand __builtin_smov (strcpy) to multiple movs.\n-   Use the smov instruction. */\n-#define TARGET_FORCE_SMOV (target_flags & 0x100)\n-\n-/* default options are -m300, -mFPU,\n-   with bitfield instructions added because it won't always work otherwise.\n-   If there are versions of the gmicro that don't support bitfield instructions\n-   then it will take some thinking to figure out how to make them work.  */\n-#define TARGET_DEFAULT 0x49\n-\n-/* Macro to define tables used to set the flags.\n-   This is a list in braces of pairs in braces,\n-   each pair being { \"NAME\", VALUE }\n-   where VALUE is the bits to set or minus the bits to clear.\n-   An empty string NAME is used to identify the default VALUE.  */\n-\n-#define TARGET_SWITCHES  \\\n-  { { \"g300\", 1, _(\"Compile for Gmicro/300\")},\t\t\t\\\n-    { \"g200\", 2, _(\"Compile for Gmicro/200\")},\t\t\t\\\n-    { \"g100\", 4, _(\"Compile for Gmicro/100\")},\t\t\t\\\n-    { \"fpu\", 8, _(\"Use floating point co-processor\")},\t\t\\\n-    { \"soft-float\", -8,\t\t\t\t\t\t\\\n-      _(\"Do not use floating point co-processor\")},\t\t\\\n-    { \"rtd\", 0x10, _(\"Alternate calling convention\")},\t\t\\\n-    { \"no-rtd\", -0x10, _(\"Use normal calling convention\")},\t\\\n-    { \"regparm\", 0x20, NULL},\t\t\t\t\t\\\n-    { \"no-regparm\", -0x20, NULL},\t\t\t\t\\\n-#if 0 /* Since we don't define PCC_BITFIELD_TYPE_MATTERS or use a large\n-\t STRUCTURE_SIZE_BOUNDARY, we must have bitfield instructions.  */\n-    { \"bitfield\", 0x40, _(\"Use bitfield instructions\")},\t\\\n-    { \"no-bitfield\", -0x40,\t\t\t\t\t\\\n-      _(\"Do not use bitfield instructions\")},\t\t\t\\\n-#endif\n-    { \"newreturn\", 0x80, _(\"Use alternative return sequence\")},\t\\\n-    { \"no-newreturn\", -0x80, _(\"Use normal return sequence\")},\t\\\n-    { \"force-smov\", 0x100, _(\"Always use string instruction\")},\t\\\n-    { \"no-force-smov\", -0x100,\t\t\t\t\t\\\n-      _(\"Use string instruction when appropriate\")},\t\t\\\n-    { \"\", TARGET_DEFAULT, NULL}}\n-\n-\n-/* Blow away G100 flag silently off TARGET_fpu (since we can't clear\n-   any bits in TARGET_SWITCHES above) */\n-#define OVERRIDE_OPTIONS\t\t\\\n-{\t\t\t\t\t\\\n-  if (TARGET_G100) target_flags &= ~8;\t\\\n-}\n-\f\n-/* target machine storage layout */\n-\n-/* Define this if most significant bit is lowest numbered\n-   in instructions that operate on numbered bit-fields.\n-   This is true for Gmicro insns.\n-   We make it true always by avoiding using the single-bit insns\n-   except in special cases with constant bit numbers.  */\n-#define BITS_BIG_ENDIAN 1\n-\n-/* Define this if most significant byte of a word is the lowest numbered.  */\n-/* That is true on the Gmicro.  */\n-#define BYTES_BIG_ENDIAN 1\n-\n-/* Define this if most significant word of a multiword number is the lowest\n-   numbered.  */\n-/* For Gmicro we can decide arbitrarily\n-   since there are no machine instructions for them.  ????? */\n-#define WORDS_BIG_ENDIAN 0\n-\n-/* number of bits in an addressable storage unit */\n-#define BITS_PER_UNIT 8\n-\n-/* Width in bits of a \"word\", which is the contents of a machine register. */\n-#define BITS_PER_WORD 32\n-\n-/* Width of a word, in units (bytes).  */\n-#define UNITS_PER_WORD 4\n-\n-/* Width in bits of a pointer.\n-   See also the macro `Pmode' defined below.  */\n-#define POINTER_SIZE 32\n-\n-/* Allocation boundary (in *bits*) for storing arguments in argument list.  */\n-#define PARM_BOUNDARY 32\n-\n-/* Boundary (in *bits*) on which stack pointer should be aligned.  */\n-#define STACK_BOUNDARY 32\n-\n-/* Allocation boundary (in *bits*) for the code of a function.  */\n-/* Instructions of the Gmicro should be on half-word boundary */\n-/* But word boundary gets better performance */\n-#define FUNCTION_BOUNDARY 32\n-\n-/* Alignment of field after `int : 0' in a structure.  */\n-#define EMPTY_FIELD_BOUNDARY 32\n-\n-/* No data type wants to be aligned rounder than this. */\n-/* This is not necessarily 32 on the Gmicro */\n-#define BIGGEST_ALIGNMENT 32\n-\n-/* Set this non-zero if move instructions will actually fail to work\n-   when given unaligned data.\n-   Unaligned data is allowed on Gmicro, though the access is slow. */\n-\n-#define STRICT_ALIGNMENT 1\n-#define SLOW_UNALIGNED_ACCESS(MODE, ALIGN) 1\n-\n-/* Make strings word-aligned so strcpy from constants will be faster.  */\n-#define CONSTANT_ALIGNMENT(EXP, ALIGN)  \\\n-  (TREE_CODE (EXP) == STRING_CST\t\\\n-   && (ALIGN) < BITS_PER_WORD ? BITS_PER_WORD : (ALIGN))\n-\n-/* Make arrays of chars word-aligned for the same reasons.  */\n-#define DATA_ALIGNMENT(TYPE, ALIGN)\t\t\\\n-  (TREE_CODE (TYPE) == ARRAY_TYPE\t\t\\\n-   && TYPE_MODE (TREE_TYPE (TYPE)) == QImode\t\\\n-   && (ALIGN) < BITS_PER_WORD ? BITS_PER_WORD : (ALIGN))\n-\n-/* Define number of bits in most basic integer type.\n-   (If undefined, default is BITS_PER_WORD).  */\n-#define INT_TYPE_SIZE 32\n-\n-/* #define PCC_BITFIELD_TYPE_MATTERS 1 ????? */\n-\n-/* #define CHECK_FLOAT_VALUE (MODE, VALUE) ????? */\n-\n-\f\n-/* Standard register usage.  */\n-\n-/* Number of actual hardware registers.\n-   The hardware registers are assigned numbers for the compiler\n-   from 0 to just below FIRST_PSEUDO_REGISTER.\n-   All registers that the compiler knows about must be given numbers,\n-   even those that are not normally considered general registers.\n-   For the Gmicro, we give the general registers numbers 0-15,\n-   and the FPU floating point registers numbers 16-31.  */\n-#define FIRST_PSEUDO_REGISTER 32\n-\n-/* 1 for registers that have pervasive standard uses\n-   and are not available for the register allocator.\n-   On the Gmicro, the stack pointer and the frame pointer are\n-   such registers.  */\n-/* frame pointer is not indicated as fixed, because fp may be used freely\n-   when a frame is not built. */\n-#define FIXED_REGISTERS  \\\n- {0, 0, 0, 0, 0, 0, 0, 0, \\\n-  0, 0, 0, 0, 0, 0, 0, 1, \\\n-  /* FPU registers.  */   \\\n-  0, 0, 0, 0, 0, 0, 0, 0, \\\n-  0, 0, 0, 0, 0, 0, 0, 0, }\n-\n-/* 1 for registers not available across function calls.\n-   These must include the FIXED_REGISTERS and also any\n-   registers that can be used without being saved.\n-   The latter must include the registers where values are returned\n-   and the register where structure-value addresses are passed.\n-   Aside from that, you can include as many other registers as you like.  */\n-#define CALL_USED_REGISTERS \\\n- {1, 1, 1, 1, 0, 0, 0, 0, \\\n-  0, 0, 0, 0, 0, 0, 0, 1, \\\n-  /* FPU registers.  */   \\\n-  1, 1, 1, 1, 0, 0, 0, 0, \\\n-  0, 0, 0, 0, 0, 0, 0, 0, }\n-\n-\n-/* Make sure everything's fine if we *don't* have a given processor.\n-   This assumes that putting a register in fixed_regs will keep the\n-   compilers mitt's completely off it.  We don't bother to zero it out\n-   of register classes.  If TARGET_FPU is not set,\n-   the compiler won't touch since no instructions that use these\n-   registers will be valid.  */\n-/*  This Macro is not defined now.\n-    #define CONDITIONAL_REGISTER_USAGE */\n-\n-/* Return number of consecutive hard regs needed starting at reg REGNO\n-   to hold something of mode MODE.\n-   This is ordinarily the length in words of a value of mode MODE\n-   but can be less for certain modes in special long registers.\n-\n-   On the Gmicro, ordinary registers hold 32 bits worth;\n-   for the Gmicro/FPU registers, a single register is always enough for\n-   anything that can be stored in them at all.  */\n-#define HARD_REGNO_NREGS(REGNO, MODE)   \\\n-  ((REGNO) >= 16 ? 1\t\t\t\t\\\n-   : ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD))\n-\n-/* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.\n-   On the Gmicro, the cpu registers can hold any mode but the FPU registers\n-   can hold only SFmode or DFmode.  And the FPU registers can't hold anything\n-   if FPU use is disabled. */\n-#define HARD_REGNO_MODE_OK(REGNO, MODE) \\\n-  ((REGNO) < 16\t\t\t\t\t\t\t\t\\\n-   || ((REGNO) < 32\t\t\t\t\t\t\t\\\n-       ? TARGET_FPU && (GET_MODE_CLASS (MODE) == MODE_FLOAT ||\t\t\\\n-\t\t\tGET_MODE_CLASS (MODE) == MODE_COMPLEX_FLOAT)\t\\\n-       : 0 ))\n-\n-/* Value is 1 if it is a good idea to tie two pseudo registers\n-   when one has mode MODE1 and one has mode MODE2.\n-   If HARD_REGNO_MODE_OK could produce different values for MODE1 and MODE2,\n-   for any hard reg, then this must be 0 for correct output.  */\n-#define MODES_TIEABLE_P(MODE1, MODE2)\t\t\t\\\n-  (! TARGET_FPU\t\t\t\t\t\t\\\n-   || ((GET_MODE_CLASS (MODE1) == MODE_FLOAT ||\t\t\\\n-\tGET_MODE_CLASS (MODE1) == MODE_COMPLEX_FLOAT)\t\\\n-       == ((MODE2) == SFmode || (MODE2) == DFmode)))\n-\n-/* Specify the registers used for certain standard purposes.\n-   The values of these macros are register numbers.  */\n-\n-/* Gmicro pc isn't overloaded on a register.  */\n-/* #define PC_REGNUM  */\n-\n-/* Register to use for pushing function arguments.  */\n-#define STACK_POINTER_REGNUM 15\n-\n-/* Base register for access to local variables of the function.  */\n-#define FRAME_POINTER_REGNUM 14\n-\n-/* Value should be nonzero if functions must have frame pointers.\n-   Zero means the frame pointer need not be set up (and parms\n-   may be accessed via the stack pointer) in functions that seem suitable.\n-   This is computed in `reload', in reload1.c.  */\n-#define FRAME_POINTER_REQUIRED 0\n-\n-/* Base register for access to arguments of the function.  */\n-/* The Gmicro does not have hardware ap. Fp is treated as ap */\n-#define ARG_POINTER_REGNUM 14\n-\n-/* Register in which static-chain is passed to a function.  */\n-#define STATIC_CHAIN_REGNUM 0\n-\n-/* Register in which address to store a structure value\n-   is passed to a function.  */\n-#define STRUCT_VALUE_REGNUM 1\n-\f\n-/* Define the classes of registers for register constraints in the\n-   machine description.  Also define ranges of constants.\n-\n-   One of the classes must always be named ALL_REGS and include all hard regs.\n-   If there is more than one class, another class must be named NO_REGS\n-   and contain no registers.\n-\n-   The name GENERAL_REGS must be the name of a class (or an alias for\n-   another name such as ALL_REGS).  This is the class of registers\n-   that is allowed by \"g\" or \"r\" in a register constraint.\n-   Also, registers outside this class are allocated only when\n-   instructions express preferences for them.\n-\n-   The classes must be numbered in nondecreasing order; that is,\n-   a larger-numbered class must never be contained completely\n-   in a smaller-numbered class.\n-\n-   For any two classes, it is very desirable that there be another\n-   class that represents their union.  */\n-\n-/* The Gmicro has two kinds of registers, so four classes would be\n-   a complete set.  */\n-\n-enum reg_class { NO_REGS, FPU_REGS, GENERAL_REGS, ALL_REGS, LIM_REG_CLASSES };\n-\n-#define N_REG_CLASSES (int) LIM_REG_CLASSES\n-\n-/* Give names of register classes as strings for dump file.   */\n-\n-#define REG_CLASS_NAMES \\\n-   { \"NO_REGS\", \"FPU_REGS\", \"GENERAL_REGS\", \"ALL_REGS\" }\n-\n-/* Define which registers fit in which classes.\n-   This is an initializer for a vector of HARD_REG_SET\n-   of length N_REG_CLASSES.  */\n-\n-#define REG_CLASS_CONTENTS \\\n-{\t\t\t\t\t\t\\\n-     0,\t\t\t/* NO_REGS */\t\t\\\n-     0xffff0000,\t/* FPU_REGS */\t\t\\\n-     0x0000ffff,\t/* GENERAL_REGS */\t\\\n-     0xffffffff\t\t/* ALL_REGS */\t\t\\\n-}\n-\n-/* The same information, inverted:\n-   Return the class number of the smallest class containing\n-   reg number REGNO.  This could be a conditional expression\n-   or could index an array.  */\n-\n-extern enum reg_class regno_reg_class[];\n-#define REGNO_REG_CLASS(REGNO) ( (REGNO < 16) ? GENERAL_REGS : FPU_REGS )\n-\n-/* The class value for index registers, and the one for base regs.  */\n-\n-#define INDEX_REG_CLASS GENERAL_REGS\n-#define BASE_REG_CLASS  GENERAL_REGS\n-  \n-/* Get reg_class from a letter such as appears in the machine description.\n-   We do a trick here to modify the effective constraints on the\n-   machine description; we zorch the constraint letters that aren't\n-   appropriate for a specific target.  This allows us to guarantee\n-   that a specific kind of register will not be used for a given target\n-   without fiddling with the register classes above. */\n-\n-#define REG_CLASS_FROM_LETTER(C) \\\n-  ((C) == 'r' ? GENERAL_REGS :\t\t\t\\\n-   ((C) == 'f' ? (TARGET_FPU ? FPU_REGS : NO_REGS) :\t\\\n-     NO_REGS))\n-\n-/* The letters I, J, K, L and M in a register constraint string\n-   can be used to stand for particular ranges of immediate operands.\n-   This macro defines what the ranges are.\n-   C is the letter, and VALUE is a constant value.\n-   Return 1 if VALUE is in the range specified by C.\n-\n-   For the Gmicro, all immediate value optimizations are done \n-   by assembler, so no machine dependent definition is necessary ??? */\n-\n-/* #define CONST_OK_FOR_LETTER_P(VALUE, C) ((C) == 'I') */\n-#define CONST_OK_FOR_LETTER_P(VALUE, C) 0\n-\n-/*\n- * The letters G defines all of the floating constants tha are *NOT*\n- * Gmicro-FPU constant.\n- */\n-\n-#define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C)\t\\\n-    ((C) == 'F' ||\t\t\t\t\\\n-     (C) == 'G' && !(TARGET_FPU && standard_fpu_constant_p (VALUE)))\n-\n-/* Given an rtx X being reloaded into a reg required to be\n-   in class CLASS, return the class of reg to actually use.\n-   In general this is just CLASS; but on some machines\n-   in some cases it is preferable to use a more restrictive class. */\n-/* On the Gmicro series, there is no restriction on GENERAL_REGS,\n-   so CLASS is returned. I do not know whether I should treat FPU_REGS\n-   specially or not (at least, m68k does not). */\n-\n-#define PREFERRED_RELOAD_CLASS(X,CLASS) CLASS\n-\n-/* Return the maximum number of consecutive registers\n-   needed to represent mode MODE in a register of class CLASS.  */\n-/* On the Gmicro, this is the size of MODE in words,\n-   except in the FPU regs, where a single reg is always enough.  */\n-#define CLASS_MAX_NREGS(CLASS, MODE)\t\\\n- ((CLASS) == FPU_REGS ? \\\n-   1 : ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD))\n-\f\n-/* Stack layout; function entry, exit and calling.  */\n-\n-/* Define this if pushing a word on the stack\n-   makes the stack pointer a smaller address.  */\n-#define STACK_GROWS_DOWNWARD\n-\n-/* Define this if the nominal address of the stack frame\n-   is at the high-address end of the local variables;\n-   that is, each additional local variable allocated\n-   goes at a more negative offset in the frame.  */\n-#define FRAME_GROWS_DOWNWARD\n-\n-/* Offset within stack frame to start allocating local variables at.\n-   If FRAME_GROWS_DOWNWARD, this is the offset to the END of the\n-   first local allocated.  Otherwise, it is the offset to the BEGINNING\n-   of the first local allocated.  */\n-/* On the Gmicro, FP points to the old FP and the first local variables are\n-   at (FP - 4). */\n-#define STARTING_FRAME_OFFSET 0\n-\n-/* If we generate an insn to push BYTES bytes,\n-   this says how many the stack pointer really advances by. */\n-/* On the Gmicro, sp is decremented by the exact size of the operand */\n-#define PUSH_ROUNDING(BYTES) (BYTES)\n-\n-/* Offset of first parameter from the argument pointer register value.  */\n-/* On the Gmicro, the first argument is found at (ap + 8) where ap is fp. */\n-#define FIRST_PARM_OFFSET(FNDECL) 8\n-\n-/* Value is the number of byte of arguments automatically\n-   popped when returning from a subroutine call.\n-   FUNDECL is the declaration node of the function (as a tree),\n-   FUNTYPE is the data type of the function (as a tree),\n-   or for a library call it is an identifier node for the subroutine name.\n-   SIZE is the number of bytes of arguments passed on the stack. \n-\n-   On the Gmicro, the EXITD insn may be used to pop them if the number\n-   of args is fixed, but if the number is variable then the caller must pop\n-   them all. The adjsp operand of the EXITD insn can't be used for library\n-   calls now because the library is compiled with the standard compiler.\n-   Use of adjsp operand is a selectable option, since it is incompatible with\n-   standard Unix calling sequences.  If the option is not selected,\n-   the caller must always pop the args.\n-   On the m68k this is an RTD option, so I use the same name\n-   for the Gmicro. The option name may be changed in the future. */\n-\n-#define RETURN_POPS_ARGS(FUNDECL,FUNTYPE,SIZE)   \\\n-  ((TARGET_RTD && (!(FUNDECL) || TREE_CODE (FUNDECL) != IDENTIFIER_NODE)\t\\\n-    && (TYPE_ARG_TYPES (FUNTYPE) == 0\t\t\t\t\\\n-\t|| (TREE_VALUE (tree_last (TYPE_ARG_TYPES (FUNTYPE)))\t\\\n-\t    == void_type_node)))\t\t\t\t\t\\\n-   ? (SIZE) : 0)\n-\n-/* Define how to find the value returned by a function.\n-   VALTYPE is the data type of the value (as a tree).\n-   If the precise function being called is known, FUNC is its FUNCTION_DECL;\n-   otherwise, FUNC is 0.  */\n-\n-/* On the Gmicro the floating return value is in fr0 not r0.  */\n-\n-#define FUNCTION_VALUE(VALTYPE, FUNC)  LIBCALL_VALUE (TYPE_MODE (VALTYPE))\n-\n-/* Define how to find the value returned by a library function\n-   assuming the value has mode MODE.  */\n-\n-#define LIBCALL_VALUE(MODE)\t\t\t\t\t\t\\\n-  (gen_rtx_REG ((MODE),\t\t\t\t\t\t\t\\\n-\t\t((TARGET_FPU && ((MODE) == SFmode || (MODE) == DFmode))\t\\\n-\t\t ? 16 : 0)))\n-\n-\n-/* 1 if N is a possible register number for a function value.\n-   On the Gmicro, r0 and fp0 are the possible registers.  */\n-\n-#define FUNCTION_VALUE_REGNO_P(N) ((N) == 0 || (N) == 16)\n-\n-/* Define this if PCC uses the nonreentrant convention for returning\n-   structure and union values.  */\n-\n-#define PCC_STATIC_STRUCT_RETURN\n-\n-/* 1 if N is a possible register number for function argument passing.\n-   On the Gmicro, no registers are used in this way.  */\n-/* Really? For the performance improvement, registers should be used !! */\n-\n-#define FUNCTION_ARG_REGNO_P(N) 0\n-\f\n-/* Define a data type for recording info about an argument list\n-   during the scan of that argument list.  This data type should\n-   hold all necessary information about the function itself\n-   and about the args processed so far, enough to enable macros\n-   such as FUNCTION_ARG to determine where the next arg should go.\n-\n-   On the Gmicro, this is a single integer, which is a number of bytes\n-   of arguments scanned so far.  */\n-\n-#define CUMULATIVE_ARGS int\n-\n-/* Initialize a variable CUM of type CUMULATIVE_ARGS\n-   for a call to a function whose data type is FNTYPE.\n-   For a library call, FNTYPE is 0.\n-\n-   On the Gmicro, the offset starts at 0.  */\n-\n-#define INIT_CUMULATIVE_ARGS(CUM,FNTYPE,LIBNAME,INDIRECT)\t\\\n- ((CUM) = 0)\n-\n-/* Update the data in CUM to advance over an argument\n-   of mode MODE and data type TYPE.\n-   (TYPE is null for libcalls where that information may not be available.)  */\n-\n-#define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED)\t\\\n- ((CUM) += ((MODE) != BLKmode\t\t\t\\\n-\t    ? (GET_MODE_SIZE (MODE) + 3) & ~3\t\\\n-\t    : (int_size_in_bytes (TYPE) + 3) & ~3))\n-\n-/* Define where to put the arguments to a function.\n-   Value is zero to push the argument on the stack,\n-   or a hard register in which to store the argument.\n-\n-   MODE is the argument's machine mode.\n-   TYPE is the data type of the argument (as a tree).\n-    This is null for libcalls where that information may\n-    not be available.\n-   CUM is a variable of type CUMULATIVE_ARGS which gives info about\n-    the preceding args and about the function being called.\n-   NAMED is nonzero if this argument is a named parameter\n-    (otherwise it is an extra parameter matching an ellipsis).  */\n-\n-/* On the Gmicro all args are pushed, except if -mregparm is specified\n-   then the first two words of arguments are passed in d0, d1.\n-   *NOTE* -mregparm does not work.\n-   It exists only to test register calling conventions.  */\n-\n-#define FUNCTION_ARG(CUM, MODE, TYPE, NAMED) \\\n-((TARGET_REGPARM && (CUM) < 8) ? gen_rtx_REG ((MODE), (CUM) / 4) : 0)\n-\n-/* For an arg passed partly in registers and partly in memory,\n-   this is the number of registers used.\n-   For args passed entirely in registers or entirely in memory, zero.  */\n-\n-#define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED) \\\n-((TARGET_REGPARM && (CUM) < 8\t\t\t\t\t\\\n-  && 8 < ((CUM) + ((MODE) == BLKmode\t\t\t\t\\\n-\t\t      ? int_size_in_bytes (TYPE)\t\t\\\n-\t\t      : GET_MODE_SIZE (MODE))))  \t\t\\\n- ? 2 - (CUM) / 4 : 0)\n-\n-/* The following macro is defined to output register list.\n-   The LSB of Mask is the lowest number register.\n-   Regoff is MY_GREG_OFF or MY_FREG_OFF.\n-   Do NOT use <i> in File, Mask, Regoff !!\n-   Should be changed from macros to functions.    M.Yuhara */\n-\n-#define MY_GREG_OFF 0\n-#define MY_FREG_OFF 16\n-\n-#define MY_PRINT_MASK(File, Mask, Regoff)\t\t\\\n-{\t\t\t\t\t\t\t\\\n-    int i, first = -1;\t\t\t\t\t\\\n-    if ((Mask) == 0) {\t\t\t\t\t\\\n-\tfprintf(File, \"#0\");\t\t\t\t\\\n-    } else {\t\t\t\t\t\t\\\n-\tfprintf(File, \"(\");\t\t\t\t\\\n-\tfor (i = 0; i < 16; i++) {\t\t\t\\\n-\t    if ( (Mask) & (1 << i) ) {\t\t\t\\\n-\t\tif (first < 0) {\t\t\t\\\n-\t\t    if (first == -2) {\t\t\t\\\n-\t\t\tfprintf(File, \",\");\t\t\\\n-\t\t    }\t\t\t\t\t\\\n-\t\t    first = i;\t\t\t\t\\\n-\t\t    fprintf(File, \"%s\", reg_names[Regoff + i]);\t\\\n-\t\t}\t\t\t\t\t\\\n-\t    } else if (first >= 0) {\t\t\t\\\n-\t\tif (i > first + 1) {\t\t\t\\\n-\t\t    fprintf(File, \"-%s\", reg_names[Regoff + i - 1]);\t\\\n-\t\t}\t\t\t\t\t\\\n-\t\tfirst = -2;\t\t\t\t\\\n-\t    }\t\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\\\n-\tif ( (first >= 0) && (first != 15) )\t\t\\\n-\t    fprintf(File, \"-%s\", reg_names[Regoff + 15]);\\\n-\tfprintf(File, \")\");\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\\\n-}\n-\n-\n-#define MY_PRINT_ONEREG_L(FILE,MASK)\t\t\\\n-{   register int i;\t\t\t\t\\\n-    for (i = 0; i < 16; i++)\t\t\t\\\n-\tif ( (1 << i) & (MASK)) {\t\t\\\n-\t    fprintf(FILE, \"%s\", reg_names[i]);\t\\\n-\t    (MASK) &= ~(1 << i);\t\t\\\n-\t    break;\t\t\t\t\\\n-\t}\t\t\t\t\t\\\n-}\n-\n-\n-#define MY_PRINT_ONEREG_H(FILE,MASK)\t\t\\\n-{   register int i;\t\t\t\t\\\n-    for (i = 15; i >= 0; i--)\t\t\t\\\n-\tif ( (1 << i) & (MASK)) {\t\t\\\n-\t    fprintf(FILE, \"%s\", reg_names[i]);\t\\\n-\t    (MASK) &= ~(1 << i);\t\t\\\n-\t    break;\t\t\t\t\\\n-\t}\t\t\t\t\t\\\n-}\n-\n-/* This macro generates the assembly code for function entry.\n-   FILE is a stdio stream to output the code to.\n-   SIZE is an int: how many units of temporary storage to allocate.\n-   Refer to the array `regs_ever_live' to determine which registers\n-   to save; `regs_ever_live[I]' is nonzero if register number I\n-   is ever used in the function.  This macro is responsible for\n-   knowing which registers should not be saved even if used.  */\n-\n-/* The next macro needs much optimization !!\n-   M.Yuhara */\n-\n-#define FUNCTION_PROLOGUE(FILE, SIZE)     \\\n-{ register int regno;\t\t\t\t\t\t\\\n-  register int mask = 0;\t\t\t\t\t\\\n-  register int nregs = 0;\t\t\t\t\t\\\n-  static const char * const reg_names[] = REGISTER_NAMES;\t\\\n-  extern char call_used_regs[];\t\t\t\t\t\\\n-  int fsize = ((SIZE) + 3) & -4;\t\t\t\t\\\n-  for (regno = 0; regno < 16; regno++)\t\t\t\t\\\n-    if (regs_ever_live[regno] && !call_used_regs[regno]) {\t\\\n-\tmask |= (1 << regno);\t\t\t\t\t\\\n-\tnregs++;\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-  if (frame_pointer_needed) {\t\t\t\t\t\\\n-    mask &= ~(1 << FRAME_POINTER_REGNUM);\t\t\t\\\n-    if (nregs > 4) {\t\t\t\t\t\t\\\n-\tfprintf(FILE, \"\\tenter.w #%d,\", fsize);\t\t\t\\\n-\tMY_PRINT_MASK(FILE, mask, MY_GREG_OFF);\t\t\t\\\n-\tfprintf(FILE,\"\\n\");\t\t\t\t\t\\\n-    } else {\t\t\t\t\t\t\t\\\n-\tfprintf(FILE, \"\\tmov.w fp,@-sp\\n\");\t\t\t\\\n-\tfprintf(FILE, \"\\tmov.w sp,fp\\n\");\t\t\t\\\n-\tif (fsize > 0)\t\t\t\t\t\t\\\n-\t    myoutput_sp_adjust(FILE, \"sub\", fsize);\t\t\\\n-\twhile (nregs--) {\t\t\t\t\t\\\n-\t    fprintf(FILE, \"\\tmov.w \");\t\t\t\t\\\n-\t    MY_PRINT_ONEREG_H(FILE, mask);\t\t\t\\\n-\t    fprintf(FILE, \",@-sp\\n\");\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-  } else {\t\t\t\t\t\t\t\\\n-    if (fsize > 0)\t\t\t\t\t\t\\\n-\tmyoutput_sp_adjust(FILE, \"sub\", fsize);\t\t\t\\\n-    if (mask != 0) {\t\t\t\t\t\t\\\n-\tif (nregs > 4) {\t\t\t\t\t\\\n-\t    fprintf(FILE, \"\\tstm.w \");\t\t\t\t\\\n-\t    MY_PRINT_MASK(FILE, mask, MY_GREG_OFF);\t\t\\\n-\t    fprintf(FILE, \",@-sp\\n\");\t\t\t\t\\\n-\t} else {\t\t\t\t\t\t\\\n-\t    while (nregs--) {\t\t\t\t\t\\\n-\t\tfprintf(FILE, \"\\tmov.w \");\t\t\t\\\n-\t\tMY_PRINT_ONEREG_H(FILE, mask);\t\t\t\\\n-\t\tfprintf(FILE, \",@-sp\\n\");\t\t\t\\\n-\t    }\t\t\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-  }\t\t\t\t\t\t\t\t\\\n-  mask = 0;\t\t\t\t\t\t\t\\\n-  for (regno = 16; regno < 32; regno++)\t\t\t\t\\\n-        if (regs_ever_live[regno] && !call_used_regs[regno])\t\\\n-            mask |= 1 << (regno - 16);\t\t\t\t\\\n-  if (mask != 0) {\t\t\t\t\t\t\\\n-\tfprintf(FILE, \"\\tfstm.w \");\t\t\t\t\\\n-\tMY_PRINT_MASK(FILE, mask, MY_FREG_OFF);\t\t\t\\\n-\tfprintf(FILE, \",@-sp\\n\", mask);\t\t\t\t\\\n-  }\t\t\t\t\t\t\t\t\\\n-}\n-\n-\n-/* Output assembler code to FILE to increment profiler label # LABELNO\n-   for profiling a function entry.  */\n-/* ??? M.Yuhara */\n-\n-#define FUNCTION_PROFILER(FILE, LABELNO)  \\\n-  fprintf (FILE, \"\\tmova @LP%d,r0\\n\\tjsr mcount\\n\", (LABELNO))\n-\n-/* Output assembler code to FILE to initialize this source file's\n-   basic block profiling info, if that has not already been done.  */\n-\n-#define FUNCTION_BLOCK_PROFILER(FILE, LABELNO)  \\\n-  fprintf (FILE, \"\\tcmp #0,@LPBX0\\n\\tbne LPI%d\\n\\tpusha @LPBX0\\n\\tjsr ___bb_init_func\\n\\tadd #4,sp\\nLPI%d:\\n\",  \\\n-\t   LABELNO, LABELNO);\n-\n-/* Output assembler code to FILE to increment the entry-count for\n-   the BLOCKNO'th basic block in this source file.  */\n-\n-#define BLOCK_PROFILER(FILE, BLOCKNO)\t\\\n-  fprintf (FILE, \"\\tadd #1,@(LPBX2+%d)\\n\", 4 * BLOCKNO)\n-\n-/* EXIT_IGNORE_STACK should be nonzero if, when returning from a function,\n-   the stack pointer does not matter.  The value is tested only in\n-   functions that have frame pointers.\n-   No definition is equivalent to always zero.  */\n-\n-#define EXIT_IGNORE_STACK 1\n-\n-/* This macro generates the assembly code for function exit,\n-   on machines that need it.  If FUNCTION_EPILOGUE is not defined\n-   then individual return instructions are generated for each\n-   return statement.  Args are same as for FUNCTION_PROLOGUE.\n-\n-   The function epilogue should not depend on the current stack pointer (when\n-   frame_pinter_needed)  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   It should use the frame pointer only.  This is mandatory because\n-   of alloca; we also take advantage of it to omit stack adjustments\n-   before returning.  */\n-\n-/* The Gmicro FPU seems to be unable to fldm/fstm double or single\n-   floating. It only allows extended !! */\n-/* Optimization is not enough, especially FREGs load !! M.Yuhara */\n-\n-#define FUNCTION_EPILOGUE(FILE, SIZE) \\\n-{ register int regno;\t\t\t\t\t\t\\\n-  register int mask, fmask;\t\t\t\t\t\\\n-  register int nregs, nfregs;\t\t\t\t\t\\\n-  int offset, foffset;\t\t\t\t\t\t\\\n-  extern char call_used_regs[];\t\t\t\t\t\\\n-  static const char * const reg_names[] = REGISTER_NAMES;\t\\\n-  int fsize = ((SIZE) + 3) & -4;\t\t\t\t\\\n-  FUNCTION_EXTRA_EPILOGUE (FILE, SIZE);\t\t\t\t\\\n-  nfregs = 0;  fmask = 0; \t\t\t\t\t\\\n-  for (regno = 16; regno < 31; regno++)\t\t\t\t\\\n-    if (regs_ever_live[regno] && ! call_used_regs[regno])\t\\\n-      { nfregs++; fmask |= 1 << (regno - 16); }\t\t\t\\\n-  foffset = nfregs * 12;\t\t\t\t\t\\\n-  nregs = 0;  mask = 0;\t\t\t\t\t\t\\\n-  if (frame_pointer_needed) regs_ever_live[FRAME_POINTER_REGNUM] = 0; \\\n-  for (regno = 0; regno < 16; regno++)\t\t\t\t\\\n-    if (regs_ever_live[regno] && ! call_used_regs[regno])\t\\\n-      { nregs++; mask |= 1 << regno; }\t\t\t\t\\\n-  if (frame_pointer_needed) {\t\t\t\t\t\\\n-    offset = nregs * 4 + fsize;\t\t\t\t\t\\\n-    if (nfregs > 0) {\t\t\t\t\t\t\\\n-\tfprintf(FILE, \"\\tfldm.x @(%d,fp),\", -(foffset + offset));\\\n-\tMY_PRINT_MASK(FILE, fmask, MY_FREG_OFF);\t\t\\\n-\tfprintf(FILE, \"\\n\");\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-    if (nregs > 4\t\t\t\t\t\t\\\n-\t|| current_function_pops_args) {\t\t\t\\\n-\tfprintf(FILE, \"\\tmova @(%d,fp),sp\\n\", -offset);\t\t\\\n-\tfprintf(FILE, \"\\texitd \");\t\t\t\t\\\n-\tMY_PRINT_MASK(FILE, mask, MY_GREG_OFF);\t\t\t\\\n-\tfprintf(FILE, \",#%d\\n\", current_function_pops_args);\t\\\n-    } else {\t\t\t\t\t\t\t\\\n-\twhile (nregs--) {\t\t\t\t\t\\\n-\t    fprintf(FILE, \"\\tmov:l.w @(%d,fp),\", -offset);\t\\\n-\t    MY_PRINT_ONEREG_L(FILE, mask);\t\t\t\\\n-\t    fprintf(FILE, \"\\n\");\t\t\t\t\\\n-\t    offset -= 4;\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\\\n-\tif (TARGET_NEWRETURN) {\t\t\t\t\t\\\n-\t    fprintf(FILE, \"\\tmova.w @(4,fp),sp\\n\");\t\t\\\n-\t    fprintf(FILE, \"\\tmov:l.w @fp,fp\\n\");\t\t\\\n-\t} else {\t\t\t\t\t\t\\\n-\t    fprintf(FILE, \"\\tmov.w fp,sp\\n\");\t\t\t\\\n-\t    fprintf(FILE, \"\\tmov.w @sp+,fp\\n\");\t\t\t\\\n-\t}\t\t\t\t\t\t\t\\\n-\tfprintf(FILE, \"\\trts\\n\");\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-  } else {\t\t\t\t\t\t\t\\\n-    if (nfregs > 0) {\t\t\t\t\t\t\\\n-\tfprintf(FILE, \"\\tfldm.w @sp+,\");\t\t\t\\\n-\tMY_PRINT_MASK(FILE, fmask, MY_FREG_OFF);\t\t\\\n-\tfprintf(FILE, \"\\n\");\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-    if (nregs > 4) {\t\t\t\t\t\t\\\n-\tfprintf(FILE, \"\\tldm.w @sp+,\");\t\t\t\t\\\n-\tMY_PRINT_MASK(FILE, mask, MY_GREG_OFF);\t\t\t\\\n-\tfprintf(FILE, \"\\n\");\t\t\t\t\t\\\n-    } else {\t\t\t\t\t\t\t\\\n-\twhile (nregs--) {\t\t\t\t\t\\\n-\t    fprintf(FILE, \"\\tmov.w @sp+,\");\t\t\t\\\n-\t    MY_PRINT_ONEREG_L(FILE,mask);\t\t\t\\\n-\t    fprintf(FILE, \"\\n\");\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-      if (current_function_pops_args) {\t\t\t\t\\\n-\tmyoutput_sp_adjust(FILE, \"add\", \t\t\t\\\n-\t    (fsize + 4 + current_function_pops_args));\t\t\\\n-\tfprintf(FILE, \"\\tjmp @(%d,sp)\\n\", current_function_pops_args);\\\n-    } else {\t\t\t\t\t\t\t\\\n-\tif (fsize > 0)\t\t\t\t\t\t\\\n-\t    myoutput_sp_adjust(FILE, \"add\", fsize);\t\t\\\n-\tfprintf(FILE, \"\\trts\\n\");\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-  }\t\t\t\t\t\t\t\t\\\n-}\n-\n-/* This is a hook for other tm files to change.  */\n-#define FUNCTION_EXTRA_EPILOGUE(FILE, SIZE)\n-\n-/* If the memory address ADDR is relative to the frame pointer,\n-   correct it to be relative to the stack pointer instead.\n-   This is for when we don't use a frame pointer.\n-   ADDR should be a variable name.  */\n-\n-/* You have to change the next macro if you want to use more complex\n-   addressing modes (such as double indirection and  more than one\n-   chain-addressing stages). */\n-\n-#define FIX_FRAME_POINTER_ADDRESS(ADDR,DEPTH)  \\\n-{ int offset = -1;\t\t\t\t\t\t\t\\\n-  rtx regs = stack_pointer_rtx;\t\t\t\t\t\t\\\n-  if (ADDR == frame_pointer_rtx)\t\t\t\t\t\\\n-    offset = 0;\t\t\t\t\t\t\t\t\\\n-  else if (GET_CODE (ADDR) == PLUS && XEXP (ADDR, 0) == frame_pointer_rtx \\\n-\t   && GET_CODE (XEXP (ADDR, 1)) == CONST_INT)\t\t\t\\\n-    offset = INTVAL (XEXP (ADDR, 1));\t\t\t\t\t\\\n-  else if (GET_CODE (ADDR) == PLUS && XEXP (ADDR, 0) == frame_pointer_rtx) \\\n-    { rtx other_reg = XEXP (ADDR, 1);\t\t\t\t\t\\\n-      offset = 0;\t\t\t\t\t\t\t\\\n-      regs = gen_rtx_PLUS (Pmode, stack_pointer_rtx, other_reg); }\t\\\n-  else if (GET_CODE (ADDR) == PLUS && XEXP (ADDR, 1) == frame_pointer_rtx) \\\n-    { rtx other_reg = XEXP (ADDR, 0);\t\t\t\t\t\\\n-      offset = 0;\t\t\t\t\t\t\t\\\n-      regs = gen_rtx_PLUS (Pmode, stack_pointer_rtx, other_reg); }\t\\\n-  else if (GET_CODE (ADDR) == PLUS\t\t\t\t\t\\\n-\t   && GET_CODE (XEXP (ADDR, 0)) == PLUS\t\t\t\t\\\n-\t   && XEXP (XEXP (ADDR, 0), 0) == frame_pointer_rtx\t\t\\\n-\t   && GET_CODE (XEXP (ADDR, 1)) == CONST_INT)\t\t\t\\\n-    { rtx other_reg = XEXP (XEXP (ADDR, 0), 1);\t\t\t\t\\\n-      offset = INTVAL (XEXP (ADDR, 1));\t\t\t\t\t\\\n-      regs = gen_rtx_PLUS (Pmode, stack_pointer_rtx, other_reg); }\t\\\n-  else if (GET_CODE (ADDR) == PLUS\t\t\t\t\t\\\n-\t   && GET_CODE (XEXP (ADDR, 0)) == PLUS\t\t\t\t\\\n-\t   && XEXP (XEXP (ADDR, 0), 1) == frame_pointer_rtx\t\t\\\n-\t   && GET_CODE (XEXP (ADDR, 1)) == CONST_INT)\t\t\t\\\n-    { rtx other_reg = XEXP (XEXP (ADDR, 0), 0);\t\t\t\t\\\n-      offset = INTVAL (XEXP (ADDR, 1));\t\t\t\t\t\\\n-      regs = gen_rtx_PLUS (Pmode, stack_pointer_rtx, other_reg); }\t\\\n-  if (offset >= 0)\t\t\t\t\t\t\t\\\n-    { int regno;\t\t\t\t\t\t\t\\\n-      extern char call_used_regs[];\t\t\t\t\t\\\n-      for (regno = 16; regno < 32; regno++)\t\t\t\t\\\n-        if (regs_ever_live[regno] && ! call_used_regs[regno])\t\t\\\n-          offset += 12;\t\t\t\t\t\t\t\\\n-      for (regno = 0; regno < 16; regno++)\t\t\t\t\\\n-\tif (regs_ever_live[regno] && ! call_used_regs[regno])\t\t\\\n-\t  offset += 4;\t\t\t\t\t\t\t\\\n-      offset -= 4;\t\t\t\t\t\t\t\\\n-      ADDR = plus_constant (regs, offset + (DEPTH)); } }\n-\f\n-/* Addressing modes, and classification of registers for them.  */\n-\n-/* #define HAVE_POST_INCREMENT 0 */\n-/* #define HAVE_POST_DECREMENT 0 */\n-\n-/* #define HAVE_PRE_DECREMENT 0 */\n-/* #define HAVE_PRE_INCREMENT 0 */\n-\n-/* Macros to check register numbers against specific register classes.  */\n-\n-/* These assume that REGNO is a hard or pseudo reg number.\n-   They give nonzero only if REGNO is a hard reg of the suitable class\n-   or a pseudo reg currently allocated to a suitable hard reg.\n-   Since they use reg_renumber, they are safe only once reg_renumber\n-   has been allocated, which happens in local-alloc.c.  */\n-\n-/* Gmicro */\n-#define REGNO_OK_FOR_GREG_P(REGNO) \\\n-((REGNO) < 16 || (unsigned) reg_renumber[REGNO] < 16)\n-#define REGNO_OK_FOR_FPU_P(REGNO) \\\n-(((REGNO) ^ 0x10) < 16 || (unsigned) (reg_renumber[REGNO] ^ 0x10) < 16)\n-\n-#define REGNO_OK_FOR_INDEX_P(REGNO) REGNO_OK_FOR_GREG_P(REGNO)\n-#define REGNO_OK_FOR_BASE_P(REGNO) REGNO_OK_FOR_GREG_P(REGNO)\n-\n-/* Now macros that check whether X is a register and also,\n-   strictly, whether it is in a specified class.\n-\n-   These macros are specific to the Gmicro, and may be used only\n-   in code for printing assembler insns and in conditions for\n-   define_optimization.  */\n-\n-/* 1 if X is an fpu register.  */\n-\n-#define FPU_REG_P(X) (REG_P (X) && REGNO_OK_FOR_FPU_P (REGNO (X)))\n-\n-/* I used GREG_P in the gmicro.md file. */\n-\n-#ifdef REG_OK_STRICT\n-#define GREG_P(X) (REG_P (X) && REGNO_OK_FOR_GREG_P (REGNO(X)))\n-#else\n-#define GREG_P(X) (REG_P (X) && ((REGNO (X) & ~0xf) != 0x10))\n-#endif\n-\f\n-/* Maximum number of registers that can appear in a valid memory address.  */\n-\n-/* The Gmicro allows more registers in the chained addressing mode.\n-   But I do not know gcc supports such an architecture. */\n-\n-#define MAX_REGS_PER_ADDRESS 2\n-\n-/* Recognize any constant value that is a valid address.  */\n-\n-#define CONSTANT_ADDRESS_P(X)   \\\n-  (GET_CODE (X) == LABEL_REF || GET_CODE (X) == SYMBOL_REF\t\t\\\n-   || GET_CODE (X) == CONST_INT || GET_CODE (X) == CONST\t\t\\\n-   || GET_CODE (X) == HIGH)\n-\n-/* Nonzero if the constant value X is a legitimate general operand.\n-   It is given that X satisfies CONSTANT_P or is a CONST_DOUBLE.  */\n-\n-#define LEGITIMATE_CONSTANT_P(X) 1\n-\n-/* The macros REG_OK_FOR..._P assume that the arg is a REG rtx\n-   and check its validity for a certain class.\n-   We have two alternate definitions for each of them.\n-   The usual definition accepts all pseudo regs; the other rejects\n-   them unless they have been allocated suitable hard regs.\n-   The symbol REG_OK_STRICT causes the latter definition to be used.\n-\n-   Most source files want to accept pseudo regs in the hope that\n-   they will get allocated to the class that the insn wants them to be in.\n-   Source files for reload pass need to be strict.\n-   After reload, it makes no difference, since pseudo regs have\n-   been eliminated by then.  */\n-\n-#ifndef REG_OK_STRICT\n-\n-/* Nonzero if X is a hard reg that can be used as an index\n-   or if it is a pseudo reg.  */\n-#define REG_OK_FOR_INDEX_P(X) ((REGNO (X) & ~0xf) != 0x10)\n-/* Nonzero if X is a hard reg that can be used as a base reg\n-   or if it is a pseudo reg.  */\n-#define REG_OK_FOR_BASE_P(X) ((REGNO (X) & ~0xf) != 0x10)\n-\n-#else\n-\n-/* Nonzero if X is a hard reg that can be used as an index.  */\n-#define REG_OK_FOR_INDEX_P(X) REGNO_OK_FOR_INDEX_P (REGNO (X))\n-/* Nonzero if X is a hard reg that can be used as a base reg.  */\n-#define REG_OK_FOR_BASE_P(X) REGNO_OK_FOR_BASE_P (REGNO (X))\n-\n-#endif\n-\f\n-/* The gcc uses the following effective address of the Gmicro.\n-\t\t\t\t\t       (without using PC!!).\n-   {@} ( {Rbase} + {Disp} + {Rindex * [1,2,4,8]} )\n-\twhere\n-\t\t@:     memory indirection.\n-\t\tRbase: Base Register = General Register.\n-\t\tDisp:  Displacement (up to 32bits)\n-\t\tRindex: Index Register = General Register.\n-\t\t[1,2,4,8]: Scale of Index. 1 or 2 or 4 or 8.\n-\t\tThe inside of { } can be omitted.\n-    This restricts the chained addressing up to 1 stage.  */\n-\n-\n-\n-/* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression\n-   that is a valid memory address for an instruction.\n-   The MODE argument is the machine mode for the MEM expression\n-   that wants to use this address.\n-\n-   The other macros defined here are used only in GO_IF_LEGITIMATE_ADDRESS,\n-   except for CONSTANT_ADDRESS_P which is actually machine-independent.  */\n-\n-#define REG_CODE_BASE_P(X) \\\n-  (GET_CODE (X) == REG && REG_OK_FOR_BASE_P (X))\n-\n-#define REG_CODE_INDEX_P(X) \\\n-  (GET_CODE (X) == REG && REG_OK_FOR_INDEX_P (X))\n-\n-/* GET_CODE(X) must be PLUS. This macro does not check for PLUS! */\n-#define BASE_PLUS_DISP_P(X) \\\n-   ( REG_CODE_BASE_P (XEXP (X, 0)) \t\t\\\n-     && CONSTANT_ADDRESS_P (XEXP (X, 1))\t\\\n-    ||\t\t\t\t\t\t\\\n-     REG_CODE_BASE_P (XEXP (X, 1)) \t\t\\\n-     && CONSTANT_ADDRESS_P (XEXP (X, 0)) )\n-\n-/* 1 if X is {0,Rbase} + {0,disp}.  */\n-#define BASED_ADDRESS_P(X)  \\\n-  (CONSTANT_ADDRESS_P (X)\t\\\n-   || REG_CODE_BASE_P (X)\t\\\n-   || (GET_CODE (X) == PLUS)\t\\\n-       && BASE_PLUS_DISP_P (X))\n-\n-/* 1 if X is 1 or 2 or 4 or 8. GET_CODE(X) must be CONST_INT. */\n-#define SCALE_OF_INDEX_P(X) \\\n-  ( INTVAL(X) == 4\t\\\n-    || INTVAL(X) == 2\t\\\n-    || INTVAL(X) == 8\t\\\n-    || INTVAL(X) == 1 )\n-\n-/* #define INDEX_TERM_P(X,MODE)  */\n-#define INDEX_TERM_P(X)  \\\n-  ( REG_CODE_INDEX_P(X)\t\t\t\t\t\\\n-    || (GET_CODE (X) == MULT\t\t\t\t\\\n-\t&& ( (xfoo0 = XEXP (X, 0)), (xfoo1 = XEXP(X, 1)), \\\n-\t     ( ( (GET_CODE (xfoo0) == CONST_INT)\t\\\n-\t       && SCALE_OF_INDEX_P (xfoo0)\t\t\\\n-\t       && REG_CODE_INDEX_P (xfoo1) )\t\t\\\n-\t      ||\t\t\t\t\t\\\n-\t       ( (GET_CODE (xfoo1) == CONST_INT)\t\t\\\n-\t       && SCALE_OF_INDEX_P (xfoo1)\t\t\\\n-\t       && REG_CODE_INDEX_P (xfoo0) ) ))))\n-\n-/* Assumes there are no cases such that X = (Ireg + Disp) + Disp */\n-#define BASE_DISP_INDEX_P(X)  \\\n-  ( BASED_ADDRESS_P (X)\t\t\t\t\t\t\t\\\n-   || ( (GET_CODE (X) == PLUS)\t\t\t\t\t\t\\\n-      && ( ( (xboo0 = XEXP (X, 0)), (xboo1 = XEXP (X, 1)),\t\t\\\n-\t  (REG_CODE_BASE_P (xboo0)\t\t\t\t\t\\\n-\t    && (GET_CODE (xboo1) == PLUS)\t\t\t\t\\\n-\t    && ( ( CONSTANT_ADDRESS_P (XEXP (xboo1, 0))\t\t\t\\\n-\t\t   && INDEX_TERM_P (XEXP (xboo1, 1)) )\t\t\t\\\n-\t         || ( CONSTANT_ADDRESS_P (XEXP (xboo1, 1))\t\t\\\n-\t\t     && INDEX_TERM_P (XEXP (xboo1, 0))) )))\t\t\\\n-\t ||\t\t\t\t\t\t\t\t\\\n-\t  (CONSTANT_ADDRESS_P (xboo0)\t\t\t\t\t\\\n-\t    && (GET_CODE (xboo1) == PLUS)\t\t\t\t\\\n-\t    && ( ( REG_CODE_BASE_P (XEXP (xboo1, 0))\t\t\t\\\n-\t \t   && INDEX_TERM_P (XEXP (xboo1, 1)) )\t\t\t\\\n-\t         || ( REG_CODE_BASE_P (XEXP (xboo1, 1))\t\t\t\\\n-\t\t      && INDEX_TERM_P (XEXP (xboo1, 0))) ))\t\t\\\n-\t||\t\t\t\t\t\t\t\t\\\n-\t  (INDEX_TERM_P (xboo0)\t\t\t\t\t\t\\\n-\t    && ( ( (GET_CODE (xboo1) == PLUS)\t\t\t\t\\\n-\t          && ( ( REG_CODE_BASE_P (XEXP (xboo1, 0))\t\t\\\n-\t\t      && CONSTANT_ADDRESS_P (XEXP (xboo1, 1)) )\t\t\\\n-\t               || ( REG_CODE_BASE_P (XEXP (xboo1, 1))   \t\\\n-\t\t      && CONSTANT_ADDRESS_P (XEXP (xboo1, 0))) ))\t\\\n-\t\t||\t\t\t\t\t\t\t\\\n-\t\t (CONSTANT_ADDRESS_P (xboo1))\t\t\t\t\\\n-\t\t||\t\t\t\t\t\t\t\\\n-\t\t (REG_CODE_BASE_P (xboo1)) )))))\n-\n-/*\n-\tIf you want to allow double-indirection,\n-\tyou have to change the <fp-relative> => <sp-relative> conversion\n-\troutine. M.Yuhara\n-\n-#ifdef REG_OK_STRICT\n-#define DOUBLE_INDIRECTION(X,ADDR) {\\\n-    if (BASE_DISP_INDEX_P (XEXP (XEXP (X, 0), 0) )) goto ADDR; \\\n-    }\n-#else\n-#define DOUBLE_INDIRECTION(X,ADDR) { }\n-#endif\n-*/\n-\n-\n-#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR) {\\\n-  register rtx xboo0, xboo1, xfoo0, xfoo1;\t\t\\\n-  if (GET_CODE (X) == MEM) { \t\t\t\t\\\n-    /*\t\t\t\t\t\t\t\\\n-    if (GET_CODE (XEXP (X,0)) == MEM) {\t\t\t\\\n-\tDOUBLE_INDIRECTION(X,ADDR);\t\t\t\\\n-    } else {\t\t\t\t\t\t\\\n-\tif (BASE_DISP_INDEX_P (XEXP (X, 0))) goto ADDR;\t\\\n-    }\t\t\t\t\t\t\t\\\n-    */\t\t\t\t\t\t\t\\\n-  } else {\t\t\t\t\t\t\\\n-\tif (BASE_DISP_INDEX_P (X)) goto ADDR;\t\t\\\n-\tif ((GET_CODE (X) == PRE_DEC || GET_CODE (X) == POST_INC)\t\\\n-\t    && REG_P (XEXP (X, 0))\t\t\t\t\t\\\n-\t    && (REGNO (XEXP (X, 0)) == STACK_POINTER_REGNUM))\t\t\\\n-\t\tgoto ADDR;\t\t\t\t\t\t\\\n-  }\t\t\t\t\t\t\t\\\n-}\n-\n-\f\n-/* Try machine-dependent ways of modifying an illegitimate address\n-   to be legitimate.  If we find one, return the new, valid address.\n-   This macro is used in only one place: `memory_address' in explow.c.\n-\n-   OLDX is the address as it was before break_out_memory_refs was called.\n-   In some cases it is useful to look at this to decide what needs to be done.\n-\n-   MODE and WIN are passed so that this macro can use\n-   GO_IF_LEGITIMATE_ADDRESS.\n-\n-   It is always safe for this macro to do nothing.  It exists to recognize\n-   opportunities to optimize the output.\n-\n-   For the Gmicro, nothing is done now. */\n-\n-#define LEGITIMIZE_ADDRESS(X,OLDX,MODE,WIN) {}\n-\n-/* Go to LABEL if ADDR (a legitimate address expression)\n-   has an effect that depends on the machine mode it is used for.\n-   On the VAX, the predecrement and postincrement address depend thus\n-   (the amount of decrement or increment being the length of the operand)\n-   and all indexed address depend thus (because the index scale factor\n-   is the length of the operand).\n-   The Gmicro mimics the VAX now. Since ADDE is legitimate, it cannot\n-   include auto-inc/dec. */\n-\n-/* Unnecessary ??? */\n-#define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR,LABEL)\t\\\n- { if (GET_CODE (ADDR) == POST_INC || GET_CODE (ADDR) == PRE_DEC)\t\\\n-     goto LABEL; }\n-\n-\f\n-/* Specify the machine mode that this machine uses\n-   for the index in the tablejump instruction.  */\n-/* #define CASE_VECTOR_MODE HImode */\n-#define CASE_VECTOR_MODE SImode\n-\n-/* Define as C expression which evaluates to nonzero if the tablejump\n-   instruction expects the table to contain offsets from the address of the\n-   table.\n-   Do not define this if the table should contain absolute addresses. */\n-#define CASE_VECTOR_PC_RELATIVE 1\n-\n-/* Specify the tree operation to be used to convert reals to integers.  */\n-#define IMPLICIT_FIX_EXPR FIX_ROUND_EXPR\n-\n-/* This is the kind of divide that is easiest to do in the general case.  */\n-#define EASY_DIV_EXPR TRUNC_DIV_EXPR\n-\n-/* Define this as 1 if `char' should by default be signed; else as 0.  */\n-#define DEFAULT_SIGNED_CHAR 1\n-\n-/* Max number of bytes we can move from memory to memory\n-   in one reasonably fast instruction.  */\n-#define MOVE_MAX 4\n-\n-/* Define this if zero-extension is slow (more than one real instruction).  */\n-/* #define SLOW_ZERO_EXTEND */\n-\n-/* Nonzero if access to memory by bytes is slow and undesirable.  */\n-#define SLOW_BYTE_ACCESS 0\n-\n-/* Define if shifts truncate the shift count\n-   which implies one can omit a sign-extension or zero-extension\n-   of a shift count.  */\n-/* #define SHIFT_COUNT_TRUNCATED */\n-\n-/* Value is 1 if truncating an integer of INPREC bits to OUTPREC bits\n-   is done just by pretending it is already truncated.  */\n-#define TRULY_NOOP_TRUNCATION(OUTPREC, INPREC) 1\n-\n-/* We assume that the store-condition-codes instructions store 0 for false\n-   and some other value for true.  This is the value stored for true.  */\n-\n-/* #define STORE_FLAG_VALUE (-1) */\n-\n-/* When a prototype says `char' or `short', really pass an `int'.  */\n-#define PROMOTE_PROTOTYPES 1\n-\n-/* Specify the machine mode that pointers have.\n-   After generation of rtl, the compiler makes no further distinction\n-   between pointers and any other objects of this machine mode.  */\n-#define Pmode SImode\n-\n-/* A function address in a call instruction\n-   is a byte address (for indexing purposes)\n-   so give the MEM rtx a byte's mode.  */\n-#define FUNCTION_MODE QImode\n-\n-/* Compute the cost of computing a constant rtl expression RTX\n-   whose rtx-code is CODE.  The body of this macro is a portion\n-   of a switch statement.  If the code is computed here,\n-   return it with a return statement.  Otherwise, break from the switch.  */\n-\n-#define CONST_COSTS(RTX,CODE,OUTER_CODE) \\\n-  case CONST_INT:\t\t\t\t\t\t\\\n-    if ((unsigned) INTVAL (RTX) < 8) return 0;\t\t\t\\\n-    if ((unsigned) (INTVAL (RTX) + 0x80) < 0x100) return 1;\t\\\n-    if ((unsigned) (INTVAL (RTX) + 0x8000) < 0x10000) return 2;\t\\\n-  case CONST:\t\t\t\t\t\t\t\\\n-  case LABEL_REF:\t\t\t\t\t\t\\\n-  case SYMBOL_REF:\t\t\t\t\t\t\\\n-    return 3;\t\t\t\t\t\t\t\\\n-  case CONST_DOUBLE:\t\t\t\t\t\t\\\n-    return 5;\n-\f\n-/* Define subroutines to call to handle multiply and divide.\n-   The `*' prevents an underscore from being prepended by the compiler.  */\n-/* Use libgcc on Gmicro */\n-/* #define UDIVSI3_LIBCALL \"*udiv\" */\n-/* #define UMODSI3_LIBCALL \"*urem\" */\n-\n-\n-/* Tell final.c how to eliminate redundant test instructions.  */\n-\n-/* Here we define machine-dependent flags and fields in cc_status\n-   (see `conditions.h').  */\n-\n-/* Set if the cc value is actually in the FPU, so a floating point\n-   conditional branch must be output.  */\n-#define CC_IN_FPU 04000\n-\n-/* Store in cc_status the expressions\n-   that the condition codes will describe\n-   after execution of an instruction whose pattern is EXP.\n-   Do not alter them if the instruction would not alter the cc's.  */\n-\n-/* Since Gmicro's compare instructions depend on the branch condition,\n-   all branch should be kept.\n-   More work must be done to optimize condition code !! M.Yuhara */\n-\n-#define NOTICE_UPDATE_CC(EXP, INSN) {CC_STATUS_INIT;}\n-\n-/* The skeleton of the next macro is taken from \"vax.h\".\n-   FPU-reg manipulation is added.  M.Yuhara */\n-/* Now comment out.\n-#define NOTICE_UPDATE_CC(EXP, INSN) {\t\\\n-  if (GET_CODE (EXP) == SET) {\t\t\t\t\t\\\n-      if ( !FPU_REG_P (XEXP (EXP, 0))\t\t\t\t\\\n-\t  && (XEXP (EXP, 0) != cc0_rtx)\t\t\t\t\\\n-\t  && (FPU_REG_P (XEXP (EXP, 1))\t\t\t\t\\\n-\t      || GET_CODE (XEXP (EXP, 1)) == FIX\t\t\\\n-\t      || GET_CODE (XEXP (EXP, 1)) == FLOAT_TRUNCATE\t\\\n-\t      || GET_CODE (XEXP (EXP, 1)) == FLOAT_EXTEND)) {\t\\\n-\t CC_STATUS_INIT;\t\t\t\t\t\\\n-      } else if (GET_CODE (SET_SRC (EXP)) == CALL) {\t\t\\\n-\t CC_STATUS_INIT;\t\t\t\t\t\\\n-      } else if (GET_CODE (SET_DEST (EXP)) != PC) {\t\t\\\n-\t  cc_status.flags = 0;\t\t\t\t\t\\\n-\t  cc_status.value1 = SET_DEST (EXP);\t\t\t\\\n-\t  cc_status.value2 = SET_SRC (EXP);\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\\\n-  } else if (GET_CODE (EXP) == PARALLEL\t\t\t\t\\\n-\t   && GET_CODE (XVECEXP (EXP, 0, 0)) == SET\t\t\\\n-\t   && GET_CODE (SET_DEST (XVECEXP (EXP, 0, 0))) != PC) {\\\n-      cc_status.flags = 0;\t\t\t\t\t\\\n-      cc_status.value1 = SET_DEST (XVECEXP (EXP, 0, 0));\t\\\n-      cc_status.value2 = SET_SRC (XVECEXP (EXP, 0, 0)); \t\\\n-  /* PARALLELs whose first element sets the PC are aob, sob VAX insns.\t\\\n-     They do change the cc's.  So drop through and forget the cc's. * / \\\n-  } else CC_STATUS_INIT;\t\t\t\t\t\t\\\n-  if (cc_status.value1 && GET_CODE (cc_status.value1) == REG\t\\\n-      && cc_status.value2\t\t\t\t\t\\\n-      && reg_overlap_mentioned_p (cc_status.value1, cc_status.value2))\t\\\n-    cc_status.value2 = 0;\t\t\t\t\t\\\n-  if (cc_status.value1 && GET_CODE (cc_status.value1) == MEM\t\\\n-      && cc_status.value2\t\t\t\t\t\\\n-      && GET_CODE (cc_status.value2) == MEM)\t\t\t\\\n-    cc_status.value2 = 0;\t\t\t\t\t\\\n-  if ( (cc_status.value1 && FPU_REG_P (cc_status.value1))\t\\\n-      || (cc_status.value2 && FPU_REG_P (cc_status.value2)))\t\\\n-    cc_status.flags = CC_IN_FPU;\t\t\t\t\\\n-}\n-*/\n-\n-#define OUTPUT_JUMP(NORMAL, FLOAT, NO_OV)  \\\n-{ if (cc_prev_status.flags & CC_IN_FPU)\t\t\\\n-    return FLOAT;\t\t\t\t\\\n-  if (cc_prev_status.flags & CC_NO_OVERFLOW)\t\\\n-    return NO_OV;\t\t\t\t\\\n-  return NORMAL; }\n-\f\n-/* Control the assembler format that we output.  */\n-\n-/* Output before read-only data.  */\n-\n-#define TEXT_SECTION_ASM_OP \"\\t.section text,code,align=4\"\n-\n-/* Output before writable data.  */\n-\n-#define DATA_SECTION_ASM_OP \"\\t.section data,data,align=4\"\n-\n-/* Output before uninitialized data. */\n-\n-#define BSS_SECTION_ASM_OP \"\\t.section bss,data,align=4\"\n-\n-/* Output at beginning of assembler file.\n-   It is not appropriate for this to print a list of the options used,\n-   since that's not the convention that we use.  */\n-\n-#define ASM_FILE_START(FILE)\n-\n-/* Output at the end of assembler file. */\n-\n-#define ASM_FILE_END(FILE)  fprintf (FILE, \"\\t.end\\n\");\n-\n-\n-/* Don't try to define `gcc_compiled.' since the assembler do not\n-   accept symbols with periods and GDB doesn't run on this machine anyway.  */\n-#define ASM_IDENTIFY_GCC(FILE)\n-\n-\n-/* Output to assembler file text saying following lines\n-   may contain character constants, extra white space, comments, etc.  */\n-\n-#define ASM_APP_ON \"\"\n-/* #define ASM_APP_ON \"#APP\\n\" */\n-\n-/* Output to assembler file text saying following lines\n-   no longer contain unusual constructs.  */\n-\n-#define ASM_APP_OFF \"\"\n-/* #define ASM_APP_OFF \";#NO_APP\\n\" */\n-\n-/* How to refer to registers in assembler output.\n-   This sequence is indexed by compiler's hard-register-number (see above).  */\n-\n-#define REGISTER_NAMES \\\n-{\"r0\", \"r1\", \"r2\", \"r3\", \"r4\", \"r5\", \"r6\", \"r7\",\t\\\n- \"r8\", \"r9\", \"r10\", \"r11\", \"r12\", \"r13\", \"fp\", \"sp\",\t\\\n- \"fr0\", \"fr1\", \"fr2\", \"fr3\", \"fr4\", \"fr5\", \"fr6\", \"fr7\", \\\n- \"fr8\", \"fr9\", \"fr10\", \"fr11\", \"fr12\", \"fr13\", \"fr14\", \"fr15\"}\n-\n-/* How to renumber registers for dbx and gdb. */\n-\n-#define DBX_REGISTER_NUMBER(REGNO) (REGNO)\n-\n-/* Define this if gcc should produce debugging output for dbx in response\n-   to the -g flag. This does not work for the Gmicro now */\n-\n-#define DBX_DEBUGGING_INFO\n-\n-/* This is how to output the definition of a user-level label named NAME,\n-   such as the label on a static function or variable NAME.  */\n-\n-#define ASM_OUTPUT_LABEL(FILE,NAME) {\t\\\n-    assemble_name (FILE, NAME);\t\\\n-    fputs (\":\\n\", FILE);\t\\\n-}\n-\n-/* This is how to output a command to make the user-level label named NAME\n-   defined for reference from other files.  */\n-\n-#define ASM_GLOBALIZE_LABEL(FILE,NAME) {\\\n-    fputs (\"\\t.global \", FILE);\t\\\n-    assemble_name (FILE, NAME);\t\\\n-    fputs (\"\\n\", FILE);\t\t\\\n-}\n-\n-/* This is how to output a command to make the external label named NAME\n-   which are not defined in the file to be referable */\n-/* \".import\" does not work ??? */\n-\n-#define ASM_OUTPUT_EXTERNAL(FILE,DECL,NAME) { \\\n-    fputs (\"\\t.global \", FILE);\t\\\n-    assemble_name (FILE, NAME);\t\\\n-    fputs (\"\\n\", FILE);\t\t\\\n-}\n-\n-\n-/* The prefix to add to user-visible assembler symbols. */\n-\n-#define USER_LABEL_PREFIX \"_\"\n-\n-/* This is how to output an internal numbered label where\n-   PREFIX is the class of label and NUM is the number within the class.  */\n-\n-#define ASM_OUTPUT_INTERNAL_LABEL(FILE,PREFIX,NUM)\t\\\n-  fprintf (FILE, \"%s%d:\\n\", PREFIX, NUM)\n-\n-/* This is how to store into the string LABEL\n-   the symbol_ref name of an internal numbered label where\n-   PREFIX is the class of label and NUM is the number within the class.\n-   This is suitable for output with `assemble_name'.  */\n-\n-#define ASM_GENERATE_INTERNAL_LABEL(LABEL,PREFIX,NUM)\t\\\n-  sprintf (LABEL, \"*%s%d\", PREFIX, NUM)\n-\n-/* This is how to output an assembler line defining a `double' constant.  */\n-\n-/* do {...} while(0) is necessary, because these macros are used as\n-    if (xxx) MACRO; else ....\n-\t\t  ^\n-*/\n-\n-\n-#define ASM_OUTPUT_DOUBLE(FILE,VALUE)  \\\n-do { union { double d; long l[2];} tem;\t\t\t\t\t\\\n-     tem.d = (VALUE);\t\t\t\t\t\t\t\\\n-     fprintf (FILE, \"\\t.fdata.d h'%x%08x.d\\n\", tem.l[0], tem.l[1]);\t\\\n-} while(0)\n-\n-\n-/* This is how to output an assembler line defining a `float' constant.  */\n-\n-#define ASM_OUTPUT_FLOAT(FILE,VALUE)  \\\n-do { union { float f; long l;} tem;\t\t\t\\\n-     tem.f = (VALUE);\t\t\t\t\t\\\n-     fprintf (FILE, \"\\t.fdata.s h'%x.s\\n\", tem.l);\t\\\n-} while(0)\n-\n-/* This is how to output an assembler line defining an `int' constant.  */\n-\n-#define ASM_OUTPUT_INT(FILE,VALUE)  \\\n-( fprintf (FILE, \"\\t.data.w \"),\t\t\t\\\n-  output_addr_const (FILE, (VALUE)),\t\t\\\n-  fprintf (FILE, \"\\n\"))\n-\n-/* Likewise for `char' and `short' constants.  */\n-\n-#define ASM_OUTPUT_SHORT(FILE,VALUE)  \\\n-( fprintf (FILE, \"\\t.data.h \"),\t\t\t\\\n-  output_addr_const (FILE, (VALUE)),\t\t\\\n-  fprintf (FILE, \"\\n\"))\n-\n-#define ASM_OUTPUT_CHAR(FILE,VALUE)  \\\n-( fprintf (FILE, \"\\t.data.b \"),\t\t\t\\\n-  output_addr_const (FILE, (VALUE)),\t\t\\\n-  fprintf (FILE, \"\\n\"))\n-\n-/* This is how to output an assembler line for a numeric constant byte.  */\n-\n-#define ASM_OUTPUT_BYTE(FILE,VALUE)  \\\n-  fprintf (FILE, \"\\t.data.b h'%x\\n\", (VALUE))\n-\n-#define ASM_OUTPUT_ASCII(FILE,P,SIZE)  \\\n-  output_ascii ((FILE), (P), (SIZE))\n-\n-/* This is how to output an insn to push a register on the stack.\n-   It need not be very fast code.  */\n-\n-#define ASM_OUTPUT_REG_PUSH(FILE,REGNO)  \\\n-  fprintf (FILE, \"\\tmov %s,@-sp\\n\", reg_names[REGNO])\n-\n-/* This is how to output an insn to pop a register from the stack.\n-   It need not be very fast code.  */\n-\n-#define ASM_OUTPUT_REG_POP(FILE,REGNO)  \\\n-  fprintf (FILE, \"\\tmov @sp+,%s\\n\", reg_names[REGNO])\n-\n-/* This is how to output an element of a case-vector that is absolute.\n-   (The Gmicro does not use such vectors,\n-   but we must define this macro anyway.)  */\n-\n-#define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)  \\\n-  fprintf (FILE, \"\\t.data.w L%d\\n\", VALUE)\n-\n-\n-/* This is how to output an element of a case-vector that is relative.  */\n-\n-#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL)  \\\n-  fprintf (FILE, \"\\t.data.w L%d-L%d\\n\", VALUE, REL)\n-\n-\n-/* This is how to output an assembler line\n-   that says to advance the location counter\n-   to a multiple of 2**LOG bytes.  */\n-\n-#define ASM_OUTPUT_ALIGN(FILE,LOG)  \\\n-  fprintf (FILE, \"\\t.align %d\\n\", (1 << (LOG)));\n-\n-#define ASM_OUTPUT_SKIP(FILE,SIZE)  \\\n-  fprintf (FILE, \"\\t.res.b %d\\n\", (SIZE))\n-\n-/* This says how to output an assembler line\n-   to define a global common symbol.  */\n-\n-#define ASM_OUTPUT_COMMON(FILE, NAME, SIZE, ROUNDED)  \\\n-( bss_section (),\t\t\t\t\\\n-  assemble_name ((FILE), (NAME)),\t\t\\\n-  fprintf ((FILE), \":\\t.res.b %d\\n\", (ROUNDED)),\\\n-  fprintf ((FILE), \"\\t.export \"),\t\t\\\n-  assemble_name ((FILE), (NAME)),\t\t\\\n-  fprintf ((FILE), \"\\n\") )\n-\n-/* This says how to output an assembler line\n-   to define a local common symbol.  */\n-\n-#define ASM_OUTPUT_LOCAL(FILE, NAME, SIZE, ROUNDED)  \\\n-( bss_section (),\t\t\t\t\\\n-  assemble_name ((FILE), (NAME)),\t\t\\\n-  fprintf ((FILE), \":\\t.res.b %d\\n\", (ROUNDED)))\n-\n-/* Store in OUTPUT a string (made with alloca) containing\n-   an assembler-name for a local static variable named NAME.\n-   LABELNO is an integer which is different for each call.  */\n-\n-/* $__ is unique ????? M.Yuhara */\n-#define ASM_FORMAT_PRIVATE_NAME(OUTPUT, NAME, LABELNO)\t\\\n-( (OUTPUT) = (char *) alloca (strlen ((NAME)) + 12),\t\\\n-  sprintf ((OUTPUT), \"$__%s%d\", (NAME), (LABELNO)))\n-\n-/* Define the parentheses used to group arithmetic operations\n-   in assembler code.  */\n-\n-#define ASM_OPEN_PAREN \"(\"\n-#define ASM_CLOSE_PAREN \")\"\n-\n-/* Define results of standard character escape sequences.  */\n-#define TARGET_BELL 007\n-#define TARGET_BS 010\n-#define TARGET_TAB 011\n-#define TARGET_NEWLINE 012\n-#define TARGET_VT 013\n-#define TARGET_FF 014\n-#define TARGET_CR 015\n-\n-/* Output a float value (represented as a C double) as an immediate operand.\n-   This macro is a Gmicro/68k-specific macro.  */\n-\n-#define ASM_OUTPUT_FLOAT_OPERAND(FILE,VALUE)\t\\\n-do { union { float f; long l;} tem;\t\t\\\n-  tem.f = (VALUE);\t\t\t\t\\\n-  fprintf (FILE, \"#h'%x.s\", tem.l);\t\t\\\n-} while(0)\n-\n-\n-/* Output a double value (represented as a C double) as an immediate operand.\n-   This macro is a 68k-specific macro.  */\n-#define ASM_OUTPUT_DOUBLE_OPERAND(FILE,VALUE)\t\\\n-do { union { double d; long l[2];} tem;\t\t\\\n-  tem.d = (VALUE);\t\t\t\t\\\n-  fprintf (FILE, \"#h'%x%08x.d\", tem.l[0], tem.l[1]);\t\\\n-} while(0)\n-\n-/* Print operand X (an rtx) in assembler syntax to file FILE.\n-   CODE is a letter or dot (`z' in `%z0') or 0 if no letter was specified.\n-   For `%' followed by punctuation, CODE is the punctuation and X is null.\n-\n-   On the Gmicro, we use several CODE characters:\n-   'f' for float insn (print a CONST_DOUBLE as a float rather than in hex)\n-   'b' for branch target label.\n-   '-' for an operand pushing on the stack.\n-   '+' for an operand pushing on the stack.\n-   '#' for an immediate operand prefix \n-*/\n-\n-#define PRINT_OPERAND_PUNCT_VALID_P(CODE)\t\\\n-  ( (CODE) == '#' || (CODE) == '-'\t\t\\\n-     || (CODE) == '+' || (CODE) == '@' || (CODE) == '!')\n-\n-\n-#define PRINT_OPERAND(FILE, X, CODE)  \\\n-{ int i;\t\t\t\t\t\t\t\t\\\n-  static char *reg_name[] = REGISTER_NAMES;\t\t\t\t\\\n-/* fprintf (stderr, \"PRINT_OPERAND CODE=%c(0x%x), \", CODE, CODE);\\\n-myprcode(GET_CODE(X)); */\t\\\n-  if (CODE == '#') fprintf (FILE, \"#\");\t\t\t\t\t\\\n-  else if (CODE == '-') fprintf (FILE, \"@-sp\");\t\t\t\t\\\n-  else if (CODE == '+') fprintf (FILE, \"@sp+\");\t\t\t\t\\\n-  else if (CODE == 's') fprintf (stderr, \"err: PRINT_OPERAND <s>\\n\"); \t\\\n-  else if (CODE == '!') fprintf (stderr, \"err: PRINT_OPERAND <!>\\n\"); \t\\\n-  else if (CODE == '.') fprintf (stderr, \"err: PRINT_OPERAND <.>\\n\"); \t\\\n-  else if (CODE == 'b') {\t\t\t\t\t\t\\\n-    if (GET_CODE (X) == MEM)\t\t\t\t\t\t\\\n-\toutput_addr_const (FILE, XEXP (X, 0));  /* for bsr */\t\t\\\n-    else\t\t\t\t\t\t\t\t\\\n-\toutput_addr_const (FILE, X);  /* for bcc */\t\t\t\\\n-  }\t\t\t\t\t\t\t\t\t\\\n-  else if (CODE == 'p')\t\t\t\t\t\t\t\\\n-    print_operand_address (FILE, X);\t\t\t\t\t\\\n-  else if (GET_CODE (X) == REG)\t\t\t\t\t\t\\\n-    fprintf (FILE, \"%s\", reg_name[REGNO (X)]);\t\t\t\t\\\n-  else if (GET_CODE (X) == MEM)\t\t\t\t\t\t\\\n-    output_address (XEXP (X, 0));\t\t\t\t\t\\\n-  else if (GET_CODE (X) == CONST_DOUBLE && GET_MODE (X) == SFmode)\t\\\n-    { union { double d; int i[2]; } u;\t\t\t\t\t\\\n-      union { float f; int i; } u1;\t\t\t\t\t\\\n-      u.i[0] = CONST_DOUBLE_LOW (X); u.i[1] = CONST_DOUBLE_HIGH (X);\t\\\n-      u1.f = u.d;\t\t\t\t\t\t\t\\\n-      if (CODE == 'f')\t\t\t\t\t\t\t\\\n-\tASM_OUTPUT_FLOAT_OPERAND (FILE, u1.f);\t\t\t\t\\\n-      else\t\t\t\t\t\t\t\t\\\n-\tfprintf (FILE, \"#h'%x\", u1.i); }\t\t\t\t\\\n-  else if (GET_CODE (X) == CONST_DOUBLE && GET_MODE (X) == DFmode)\t\\\n-    { union { double d; int i[2]; } u;\t\t\t\t\t\\\n-      u.i[0] = CONST_DOUBLE_LOW (X); u.i[1] = CONST_DOUBLE_HIGH (X);\t\\\n-      ASM_OUTPUT_DOUBLE_OPERAND (FILE, u.d); }\t\t\t\t\\\n-  else { putc ('#', FILE);\t\t\t\t\t\t\\\n-output_addr_const (FILE, X); }}\n-\f\n-/* Note that this contains a kludge that knows that the only reason\n-   we have an address (plus (label_ref...) (reg...))\n-   is in the insn before a tablejump, and we know that m68k.md\n-   generates a label LInnn: on such an insn.  */\n-#define PRINT_OPERAND_ADDRESS(FILE, ADDR) \\\n-    { print_operand_address (FILE, ADDR); }\n-\f\n-/*\n-Local variables:\n-version-control: t\n-End:\n-*/"}, {"sha": "ff448cf33187fbe906b2a2a3545f028edfb47aa7", "filename": "gcc/config/gmicro/gmicro.md", "status": "removed", "additions": 0, "deletions": 2742, "changes": 2742, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7b4171a5b8a655097812307bbe261032dfbe366/gcc%2Fconfig%2Fgmicro%2Fgmicro.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7b4171a5b8a655097812307bbe261032dfbe366/gcc%2Fconfig%2Fgmicro%2Fgmicro.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fgmicro%2Fgmicro.md?ref=a7b4171a5b8a655097812307bbe261032dfbe366", "patch": "@@ -1,2742 +0,0 @@\n-;;- Machine description for GNU compiler, Fujitsu Gmicro Version\n-;;  Copyright (C) 1990, 1994, 1996, 1998, 1999 Free Software Foundation, Inc.\n-;;  Contributed by M.Yuhara, Fujitsu Laboratories LTD.\n-\n-;; This file is part of GNU CC.\n-\n-;; GNU CC is free software; you can redistribute it and/or modify\n-;; it under the terms of the GNU General Public License as published by\n-;; the Free Software Foundation; either version 2, or (at your option)\n-;; any later version.\n-\n-;; GNU CC is distributed in the hope that it will be useful,\n-;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n-;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-;; GNU General Public License for more details.\n-;; Among other things, the copyright\n-;; notice and this notice must be preserved on all copies.\n-\n-\n-;; You should have received a copy of the GNU General Public License\n-;; along with GNU CC; see the file COPYING.  If not, write to\n-;; the Free Software Foundation, 59 Temple Place - Suite 330,\n-;; Boston, MA 02111-1307, USA.\n-\n-\n-;;- instruction definitions\n-\n-;;- See file \"rtl.def\" for documentation on define_insn, match_*, et. al.\n-\n-;;- When naming insn's (operand 0 of define_insn) be careful about using\n-;;- names from other targets machine descriptions.\n-\n-;;- cpp macro #define NOTICE_UPDATE_CC is essentially a no-op for the \n-;;- gmicro; no compares are eliminated.\n-\n-;;- The original structure of this file is m68k.md.\n-\n-;; ??? Work to be done:\n-;; Add patterns for ACB and SCB instructions.\n-;; Add define_insn patterns to recognize the insns that extend a byte\n-;; to a word and add it into a word, etc.\n-\n-;;- Some of these insn's are composites of several Gmicro op codes.\n-;;- The assembler (or final @@??) insures that the appropriate one is\n-;;- selected.\n-\f\n-(define_insn \"\"\n-  [(set (match_operand:DF 0 \"push_operand\" \"=m\")\n-\t(match_operand:DF 1 \"general_operand\" \"rmfF\"))]\n-  \"\"\n-  \"*\n-{\n-  if (FPU_REG_P (operands[1]))\n-    return \\\"fmov.d %f1,%0\\\";\n-  return output_move_double (operands);\n-}\")\n-\n-;; This pattern is illegal (modes of SET_DEST and SET_SRC don't match).\n-;; It is not clear what it was intended to accomplish, therefore\n-;; I have not corrected it.  -zw, 1999-09-13\n-;(define_insn \"\"\n-;  [(set (match_operand:DI 0 \"push_operand\" \"=m\")\n-;\t(match_operand:DF 1 \"general_operand\" \"rmF\"))]\n-;  \"\"\n-;  \"*\n-;{\n-;  return output_move_double (operands);\n-;}\")\n-\f\n-;; We don't want to allow a constant operand for test insns because\n-;; (set (cc0) (const_int foo)) has no mode information.  Such insns will\n-;; be folded while optimizing anyway.\n-\n-(define_insn \"tstsi\"\n-  [(set (cc0)\n-\t(match_operand:SI 0 \"nonimmediate_operand\" \"rm\"))]\n-  \"\"\n-  \"cmp:z.w #0,%0\")\n-\n-(define_insn \"tsthi\"\n-  [(set (cc0)\n-\t(match_operand:HI 0 \"nonimmediate_operand\" \"rm\"))]\n-  \"\"\n-  \"cmp:z.h #0,%0\")\n-\n-(define_insn \"tstqi\"\n-  [(set (cc0)\n-\t(match_operand:QI 0 \"nonimmediate_operand\" \"rm\"))]\n-  \"\"\n-  \"cmp:z.b #0,%0\")\n-  \n-\n-(define_insn \"tstsf\"\n-  [(set (cc0)\n-\t(match_operand:SF 0 \"general_operand\" \"fmF\"))]\n-  \"TARGET_FPU\"\n-  \"*\n-{\n-  cc_status.flags = CC_IN_FPU;\n-  return \\\"ftst.s %0\\\";\n-}\")\n-\n-\n-(define_insn \"tstdf\"\n-  [(set (cc0)\n-\t(match_operand:DF 0 \"general_operand\" \"fmF\"))]\n-  \"TARGET_FPU\"\n-  \"*\n-{\n-  cc_status.flags = CC_IN_FPU;\n-  return \\\"ftst.d %0\\\";\n-}\")\n-\f\n-;; compare instructions.\n-\n-;; (operand0 - operand1)\n-(define_insn \"cmpsi\"\n-  [(set (cc0)\n-\t(compare (match_operand:SI 0 \"nonimmediate_operand\" \"ri,rm\")\n-\t\t (match_operand:SI 1 \"general_operand\" \"rm,rmi\")))]\n-  \"\"\n-  \"*\n-{\n-  int signed_flag = my_signed_comp (insn);\n-\n-  if (which_alternative == 0)\n-    {\n-      cc_status.flags |= CC_REVERSED;\n-      if (signed_flag && GET_CODE (operands[0]) == CONST_INT)\n-\t{\n-\t  register rtx xfoo;\n-\t  xfoo = operands[1];\n-\t  operands[0] = operands[1];\n-\t  operands[1] = xfoo;\n-\t  return cmp_imm_word (INTVAL (operands[1]), operands[0]);\n-\t}\n-      if (signed_flag)\n-\treturn \\\"cmp.w %0,%1\\\"; \n-      return \\\"cmpu.w %0,%1\\\"; \n-    }\n-  if (signed_flag)\n-    {\n-      if (GET_CODE (operands[1]) == CONST_INT)\n-\treturn cmp_imm_word (INTVAL (operands[1]), operands[0]);\n-      return \\\"cmp.w %1,%0\\\"; \n-    }\n-  else\n-    return \\\"cmpu.w %1,%0\\\"; \n-}\")\n-\n-(define_insn \"cmphi\"\n-  [(set (cc0)\n-\t(compare (match_operand:HI 0 \"nonimmediate_operand\" \"ri,rm\")\n-\t\t (match_operand:HI 1 \"general_operand\" \"rm,rmi\")))]\n-  \"\"\n-  \"*\n-{\n-  int signed_flag = my_signed_comp (insn);\n-\n-  if (which_alternative == 0)\n-    {\n-      cc_status.flags |= CC_REVERSED;\n-      if (signed_flag)\n-\treturn \\\"cmp.h %0,%1\\\"; \n-      return \\\"cmpu.h %0,%1\\\"; \n-    }\n-  if (signed_flag)\n-    return \\\"cmp.h %1,%0\\\"; \n-  return \\\"cmpu.h %1,%0\\\"; \n-}\")\n-\n-(define_insn \"cmpqi\"\n-  [(set (cc0)\n-\t(compare (match_operand:QI 0 \"nonimmediate_operand\" \"ri,rm\")\n-\t\t (match_operand:QI 1 \"general_operand\" \"rm,rmi\")))]\n-  \"\"\n-  \"*\n-{\n-  int signed_flag = my_signed_comp (insn);\n-\n-  if (which_alternative == 0)\n-    {\n-      cc_status.flags |= CC_REVERSED;\n-      if (signed_flag)\n-\treturn \\\"cmp.b %0,%1\\\"; \n-      return \\\"cmpu.b %0,%1\\\"; \n-    }\n-  if (signed_flag)\n-    return \\\"cmp.b %1,%0\\\"; \n-  return \\\"cmpu.b %1,%0\\\"; \n-}\")\n-\n-\n-(define_insn \"cmpdf\"\n-  [(set (cc0)\n-\t(compare (match_operand:DF 0 \"general_operand\" \"f,mG\")\n-\t\t (match_operand:DF 1 \"general_operand\" \"fmG,f\")))]\n-  \"TARGET_FPU\"\n-  \"*\n-{\n-  cc_status.flags = CC_IN_FPU;\n-\n-  if (FPU_REG_P (operands[0]))\n-    return \\\"fcmp.d %f1,%f0\\\";\n-  cc_status.flags |= CC_REVERSED;\n-  return \\\"fcmp.d %f0,%f1\\\";\n-}\")\n-\n-\n-(define_insn \"cmpsf\"\n-  [(set (cc0)\n-\t(compare (match_operand:SF 0 \"general_operand\" \"f,mG\")\n-\t\t (match_operand:SF 1 \"general_operand\" \"fmG,f\")))]\n-  \"TARGET_FPU\"\n-  \"*\n-{\n-  cc_status.flags = CC_IN_FPU;\n-  if (FPU_REG_P (operands[0]))\n-    return \\\"fcmp.s %f1,%0\\\";\n-  cc_status.flags |= CC_REVERSED;\n-  return \\\"fcmp.s %f0,%1\\\";\n-}\")\n-\f\n-;; Recognizers for btst instructions.\n-\n-(define_insn \"\"\n-  [(set (cc0) (zero_extract (match_operand:QI 0 \"memory_operand\" \"m\")\n-\t\t\t    (const_int 1)\n-\t\t\t    (match_operand:SI 1 \"general_operand\" \"rmi\")))]\n-  \"\"\n-  \"btst %1.w,%0.b\")\n-\n-(define_insn \"\"\n-  [(set (cc0) (zero_extract (match_operand:SI 0 \"register_operand\" \"rm\")\n-\t\t\t    (const_int 1)\n-\t\t\t    (match_operand:SI 1 \"general_operand\" \"rmi\")))]\n-  \"\"\n-  \"btst %1.w,%0.w\")\n-\n-;; The following two patterns are like the previous two\n-;; except that they use the fact that bit-number operands (offset)\n-;; are automatically masked to 3 or 5 bits when the base is a register.\n-\n-(define_insn \"\"\n-  [(set (cc0) (zero_extract (match_operand:QI 0 \"memory_operand\" \"m\")\n-\t\t\t    (const_int 1)\n-\t\t\t    (and:SI\n-\t\t\t       (match_operand:SI 1 \"general_operand\" \"rmi\")\n-\t\t\t       (const_int 7))))]\n-  \"\"\n-  \"btst %1.w,%0.b\")\n-\n-(define_insn \"\"\n-  [(set (cc0) (zero_extract (match_operand:SI 0 \"register_operand\" \"r\")\n-\t\t\t    (const_int 1)\n-\t\t\t    (and:SI\n-\t\t\t       (match_operand:SI 1 \"general_operand\" \"rmi\")\n-\t\t\t       (const_int 31))))]\n-  \"\"\n-  \"btst %1.w,%0.w\")\n-\n-; More various size-patterns are allowed for btst, but not\n-; included yet.  M.Yuhara\n-\n-\n-(define_insn \"\"\n-  [(set (cc0) (and:SI (sign_extend:SI\n-\t\t       (sign_extend:HI\n-\t\t\t(match_operand:QI 0 \"nonimmediate_operand\" \"rm\")))\n-\t\t      (match_operand:SI 1 \"general_operand\" \"i\")))]\n-  \"(GET_CODE (operands[1]) == CONST_INT\n-    && (unsigned) INTVAL (operands[1]) < 0x100\n-    && exact_log2 (INTVAL (operands[1])) >= 0)\"\n-  \"*\n-{\n-  register int log = exact_log2 (INTVAL (operands[1]));\n-  operands[1] = GEN_INT (log);\n-  return \\\"btst %1,%0.b\\\";\n-}\")\n-\n-; I can add more patterns like above. But not yet.  M.Yuhara\n-\n-\n-; mtst is supported only by G/300.\n-\n-(define_insn \"\"\n-  [(set (cc0) \n-\t(and:SI (match_operand:SI 0 \"general_operand\" \"%rmi\")\n-\t\t(match_operand:SI 1 \"general_operand\" \"rm\")))]\n-  \"TARGET_G300\"\n-  \"*\n-{\n-  if (GET_CODE (operands[0]) == CONST_INT)\n-    return \\\"mtst.w %0,%1\\\";\n-  return \\\"mtst.w %1,%0\\\";\n-}\")\n-\n-(define_insn \"\"\n-  [(set (cc0) \n-\t(and:HI (match_operand:HI 0 \"general_operand\" \"%rmi\")\n-\t\t(match_operand:HI 1 \"general_operand\" \"rm\")))]\n-  \"TARGET_G300\"\n-  \"*\n-{\n-  if (GET_CODE (operands[0]) == CONST_INT)\n-    return \\\"mtst.h %0,%1\\\";\n-  return \\\"mtst.h %1,%0\\\";\n-}\")\n-\n-(define_insn \"\"\n-  [(set (cc0) \n-\t(and:QI (match_operand:QI 0 \"general_operand\" \"%rmi\")\n-\t\t(match_operand:QI 1 \"general_operand\" \"rm\")))]\n-  \"TARGET_G300\"\n-  \"*\n-{\n-  if (GET_CODE (operands[0]) == CONST_INT)\n-    return \\\"mtst.b %0,%1\\\";\n-  return \\\"mtst.b %1,%0\\\";\n-}\")\n-\n-\n-\f\n-;; move instructions\n-\n-/* added by M.Yuhara */\n-;; 1.35.04 89.08.28 modification start\n-;; register_operand -> general_operand\n-;; ashift -> mult \n-\n-(define_insn \"\"\n-  [(set (mem:SI (plus:SI\n-\t\t  (match_operand:SI 0 \"general_operand\" \"r\")\n-\t\t  (ashift:SI\n-\t\t      (match_operand:SI 1 \"general_operand\" \"r\")\n-\t\t      (const_int 2))))\n-\t(match_operand:SI 2 \"general_operand\" \"rmi\"))]\n-  \"\"\n-  \"*\n-{\n-  return \\\"mov.w %2,@(%0:b,%1*4)\\\";\n-}\")\n-\n-(define_insn \"\"\n-  [(set (mem:SI (plus:SI\n-\t\t  (ashift:SI\n-\t\t      (match_operand:SI 0 \"general_operand\" \"r\")\n-\t\t      (const_int 2))\n-\t\t  (match_operand:SI 1 \"general_operand\" \"r\")))\n-\t(match_operand:SI 2 \"general_operand\" \"rmi\"))]\n-  \"\"\n-  \"*\n-{\n-  return \\\"mov.w %2,@(%1:b,%0*4)\\\";\n-}\")\n-\n-\n-(define_insn \"\"\n-  [(set (mem:SI (plus:SI\n-\t\t  (match_operand:SI 0 \"register_operand\" \"r\")\n-\t\t  (mult:SI\n-\t\t      (match_operand:SI 1 \"register_operand\" \"r\")\n-\t\t      (const_int 4))))\n-\t(match_operand:SI 2 \"general_operand\" \"rmi\"))]\n-  \"\"\n-  \"*\n-{\n-  return \\\"mov.w %2,@(%0:b,%1*4)\\\";\n-}\")\n-\n-(define_insn \"\"\n-  [(set (mem:SI (plus:SI\n-\t\t  (mult:SI\n-\t\t      (match_operand:SI 0 \"register_operand\" \"r\")\n-\t\t      (const_int 4))\n-\t\t  (match_operand:SI 1 \"register_operand\" \"r\")))\n-\t(match_operand:SI 2 \"general_operand\" \"rmi\"))]\n-  \"\"\n-  \"*\n-{\n-  return \\\"mov.w %2,@(%1:b,%0*4)\\\";\n-}\")\n-\n-\n-(define_insn \"\"\n-  [(set (mem:SI (plus:SI\n-\t\t  (match_operand:SI 0 \"general_operand\" \"r\")\n-\t\t  (plus:SI\n-\t\t      (match_operand:SI 1 \"register_operand\" \"r\")\n-\t\t      (match_operand:SI 2 \"register_operand\" \"i\"))))\n-\t(match_operand:SI 3 \"general_operand\" \"rmi\"))]\n-  \"\"\n-  \"*\n-{\n-  return \\\"mov.w %3,@(%c2,%0,%1)\\\";\n-}\")\n-\n-(define_insn \"\"\n-  [(set (mem:SI (plus:SI\n-\t\t  (plus:SI\n-\t\t      (match_operand:SI 0 \"register_operand\" \"r\")\n-\t\t      (match_operand:SI 1 \"register_operand\" \"r\"))\n-\t\t  (match_operand:SI 2 \"general_operand\" \"i\")))\n-\t(match_operand:SI 3 \"general_operand\" \"rmi\"))]\n-  \"\"\n-  \"*\n-{\n-  return \\\"mov.w %3,@(%c2,%0,%1)\\\";\n-}\")\n-\n-\n-(define_insn \"\"\n-  [(set (mem:SI (plus:SI\n-\t\t  (match_operand:SI 0 \"general_operand\" \"i\")\n-\t\t  (plus:SI\n-\t\t      (match_operand:SI 1 \"register_operand\" \"r\")\n-\t\t      (mult:SI\n-\t\t\t  (match_operand:SI 2 \"register_operand\" \"r\")\n-\t\t\t  (const_int 4)))))\n-\t(match_operand:SI 3 \"general_operand\" \"rmi\"))]\n-  \"\"\n-  \"*\n-{\n-  return \\\"mov.w %3,@(%1:b,%0,%2*4)\\\";\n-}\")\n-\n-;; 89.08.28 1.35.04 modification end\n-\n-;; Should add \"!\" to op2 ??\n-\n-;; General move-address-to-operand should handle these.\n-;; If that does not work, please figure out why.\n-\n-;(define_insn \"\"\n-;  [(set (match_operand:SI 0 \"push_operand\" \"=m\")\n-;\t(plus:SI\n-;\t    (match_operand:SI 1 \"immediate_operand\" \"i\")\n-;\t    (match_operand:SI 2 \"general_operand\" \"r\")))]\n-;  \"\"\n-;  \"mova.w @(%c1,%2),%-\")\n-\n-;(define_insn \"\"\n-;  [(set (match_operand:SI 0 \"push_operand\" \"=m\")\n-;\t(plus:SI\n-;\t    (match_operand:SI 1 \"general_operand\" \"r\")\n-;\t    (match_operand:SI 2 \"immediate_operand\" \"i\")))]\n-;  \"\"\n-;  \"mova.w @(%c2,%1),%-\")\n-\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"push_operand\" \"=m\")\n-\t(minus:SI\n-\t    (match_operand:SI 1 \"general_operand\" \"r\")\n-\t    (match_operand:SI 2 \"immediate_operand\" \"i\")))]\n-  \"\"\n-  \"mova.w @(%n2,%1),%-\")\n-\n-\n-\n-;; General case of fullword move.\n-\n-(define_insn \"movsi\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=rm\")\n-\t(match_operand:SI 1 \"general_operand\" \"rmi\"))]\n-  \"\"\n-  \"*\n-{\n-  if (GET_CODE (operands[1]) == CONST_INT)\n-    return mov_imm_word (INTVAL (operands[1]), operands[0]);\n-  /* if (address_operand (operands[1], SImode))\n-     return \\\"mova.w %1,%0\\\"; */\n-  if (push_operand (operands[0], SImode))\n-    return \\\"mov.w %1,%-\\\";\n-  return \\\"mov.w %1,%0\\\";\n-}\")\n-\n-/* pushsi 89.08.10 for test M.Yuhara */\n-/*\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"push_operand\" \"=m\")\n-\t(match_operand:SI 1 \"general_operand\" \"rmi\"))]\n-  \"\"\n-  \"*\n-{\n-  if (GET_CODE (operands[1]) == CONST_INT)\n-    return mov_imm_word (INTVAL (operands[1]), operands[0]);\n-  if (push_operand (operands[0], SImode))\n-    return \\\"mov.w %1,%-\\\";\n-  return \\\"mov.w %1,%0\\\";\n-}\")\n-*/\n-\n-\n-(define_insn \"movhi\"\n-  [(set (match_operand:HI 0 \"general_operand\" \"=rm\")\n-\t(match_operand:HI 1 \"general_operand\" \"rmi\"))]\n-  \"\"\n-  \"*\n-{\n-  if (push_operand (operands[0], SImode))\n-    return \\\"mov.h %1,%-\\\";\n-  return \\\"mov.h %1,%0\\\";\n-}\")\n-\n-;; Is the operand constraint \"+\" necessary ????\n-;; Should I check push_operand ????\n-\n-(define_insn \"movstricthi\"\n-  [(set (strict_low_part (match_operand:HI 0 \"general_operand\" \"+rm\"))\n-\t(match_operand:HI 1 \"general_operand\" \"rmi\"))]\n-  \"\"\n-  \"mov.h %1,%0\");\n-\n-(define_insn \"movqi\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"=rm\")\n-\t(match_operand:QI 1 \"general_operand\" \"rmi\"))]\n-  \"\"\n-  \"*\n-{\n-  if (GREG_P (operands[0]))\n-    {\n-      if (CONSTANT_P (operands[1]))\n-\treturn \\\"mov:l %1,%0.w\\\";\n-      else\n-\treturn \\\"mov:l %1.b,%0.w\\\";\n-    }\n-  if (GREG_P (operands[1]))\n-    return \\\"mov:s %1.w,%0.b\\\";\n-  return \\\"mov.b %1,%0\\\";\n-}\")\n-\n-(define_insn \"movstrictqi\"\n-  [(set (strict_low_part (match_operand:QI 0 \"general_operand\" \"+rm\"))\n-\t(match_operand:QI 1 \"general_operand\" \"rmi\"))]\n-  \"\"\n-  \"mov.b %1,%0\")\n-\n-\n-(define_insn \"movsf\"\n-  [(set (match_operand:SF 0 \"general_operand\" \"=f,mf,rm,fr\")\n-\t(match_operand:SF 1 \"general_operand\" \"mfF,f,rmF,fr\"))]\n-  \"\"\n-  \"*\n-{\n-  switch (which_alternative)\n-    {\n-    case 0:\n-      if (GET_CODE (operands[1]) == CONST_DOUBLE)\n-\treturn output_move_const_single (operands);\n-      return \\\"fmov.s %1,%0\\\";\n-    case 1:\n-      return \\\"fmov.s %1,%0\\\";\n-    case 2:\n-      if (GET_CODE (operands[1]) == CONST_DOUBLE)\n-\treturn output_move_const_single (operands);\n-      return \\\"mov.w %1,%0\\\";\n-    case 3:\n-      if (FPU_REG_P (operands[0]))\n-\treturn \\\"mov.w %1,%-\\\\n\\\\tfmov.s %+,%0\\\";\n-      return \\\"fmov.s %1,%-\\\\n\\\\tmov.w %+,%0\\\";\n-    }\n-}\")\n-\n-(define_insn \"movdf\"\n-  [(set (match_operand:DF 0 \"general_operand\" \"=f,mf,rm,fr\")\n-\t(match_operand:DF 1 \"general_operand\" \"mfF,f,rmF,fr\"))]\n-  \"\"\n-  \"*\n-{\n-  switch (which_alternative)\n-    {\n-    case 0:\n-      if (GET_CODE (operands[1]) == CONST_DOUBLE)\n-\treturn output_move_const_double (operands);\n-      return \\\"fmov.d %1,%0\\\";\n-    case 1:\n-      return \\\"fmov.d %1,%0\\\";\n-    case 2:\n-      if (GET_CODE (operands[1]) == CONST_DOUBLE)\n-\treturn output_move_const_double (operands);\n-      return output_move_double (operands);\n-    case 3:\n-      if (FPU_REG_P (operands[0]))\n-\t{\n-\t  rtx xoperands[2];\n-\t  xoperands[1] = gen_rtx_REG (SImode, REGNO (operands[1]) + 1);\n-\t  output_asm_insn (\\\"mov.w %1,%-\\\", xoperands);\n-\t  output_asm_insn (\\\"mov.w %1,%-\\\", operands);\n-\t  return \\\"fmov.d %+,%0\\\";\n-\t}\n-      else\n-\t{\n-\t  output_asm_insn (\\\"fmov.d %f1,%-\\\", operands);\n-\t  output_asm_insn (\\\"mov.w %+,%0\\\", operands);\n-\t  operands[0] = gen_rtx_REG (SImode, REGNO (operands[0]) + 1);\n-\t  return \\\"mov.w %+,%0\\\";\n-\t}\n-    }\n-}\")\n-\n-\n-;; movdi can apply to fp regs in some cases\n-;; Must check again.  you can use fsti/fldi, etc.\n-;; FPU reg should be included ??\n-;; 89.12.13 for test\n-\n-(define_insn \"movdi\"\n-  ;; Let's see if it really still needs to handle fp regs, and, if so, why.\n-  [(set (match_operand:DI 0 \"general_operand\" \"=rm,&r,&ro\")\n-\t(match_operand:DI 1 \"general_operand\" \"rF,m,roiF\"))]\n-  \"\"\n-  \"*\n-{\n-  if (FPU_REG_P (operands[0]))\n-    {\n-      if (FPU_REG_P (operands[1]))\n-\treturn \\\"fmov.d %1,%0\\\";\n-      if (REG_P (operands[1]))\n-\t{\n-\t  rtx xoperands[2];\n-\t  xoperands[1] = gen_rtx_REG (SImode, REGNO (operands[1]) + 1);\n-\t  output_asm_insn (\\\"mov.w %1,%-\\\", xoperands);\n-\t  output_asm_insn (\\\"mov.w %1,%-\\\", operands);\n-\t  return \\\"fmov.d %+,%0\\\";\n-\t}\n-      if (GET_CODE (operands[1]) == CONST_DOUBLE)\n-\treturn output_move_const_double (operands);\n-      return \\\"fmov.d %f1,%0\\\";\n-    }\n-  else if (FPU_REG_P (operands[1]))\n-    {\n-      if (REG_P (operands[0]))\n-\t{\n-\t  output_asm_insn (\\\"fmov.d %f1,%-\\;mov.w %+,%0\\\", operands);\n-\t  operands[0] = gen_rtx_REG (SImode, REGNO (operands[0]) + 1);\n-\t  return \\\"mov.w %+,%0\\\";\n-\t}\n-      else\n-        return \\\"fmov.d %f1,%0\\\";\n-    }\n-  return output_move_double (operands);\n-}\n-\")\n-\n-\n-;; The definition of this insn does not really explain what it does,\n-;; but it should suffice\n-;; that anything generated as this insn will be recognized as one\n-;; and that it won't successfully combine with anything.\n-\n-;; This is dangerous when %0 and %1 overlapped !!!!!\n-;; Ugly code...\n-\n-(define_insn \"movstrhi\"\n-  [(set (match_operand:BLK 0 \"general_operand\" \"=m\")\n-\t(match_operand:BLK 1 \"general_operand\" \"m\"))\n-   (use (match_operand:HI 2 \"general_operand\" \"rmi\"))\n-   (clobber (reg:SI 0))\n-   (clobber (reg:SI 1))\n-   (clobber (reg:SI 2))]\n-  \"\"\n-  \"*\n-{\n-  int op2const;\n-  rtx tmpx;\n-\n-  if (CONSTANT_P (operands[1]))\n-    {\n-      fprintf (stderr, \\\"smov 1 const err \\\");\n-      abort ();\n-    }\n-  else if (GET_CODE (operands[1]) == REG)\n-    {\n-      fprintf (stderr, \\\"smov 1 reg err \\\");\n-      abort ();\n-    }\n-  else if (GET_CODE (operands[1]) == MEM)\n-    {\n-      tmpx = XEXP (operands[1], 0);\n-      if (CONSTANT_ADDRESS_P (tmpx) || GREG_P (tmpx))\n-\t{\n-\t  operands[1] = tmpx;\n-\t  output_asm_insn (\\\"mov.w %1,r0\\\", operands);\n-\t}\n-      else\n-\t{\n-\t  output_asm_insn (\\\"mova %1,r0\\\", operands);\n-\t}\n-    }\n-  else\n-    {\n-      fprintf (stderr, \\\"smov 1 else err \\\");\n-      abort ();\n-      output_asm_insn (\\\"mova.w %p1,r0\\\", operands);\n-    }\n-    \n-  if (CONSTANT_P (operands[0]))\n-    {\n-      fprintf (stderr, \\\"smov 0 const err \\\");\n-      abort ();\n-    }\n-  else if (GET_CODE (operands[0]) == REG)\n-    {\n-      fprintf (stderr, \\\"smov 0 reg err \\\");\n-      abort ();\n-    }\n-  else if (GET_CODE (operands[0]) == MEM)\n-    {\n-      tmpx = XEXP (operands[0], 0);\n-      if (CONSTANT_ADDRESS_P (tmpx) || GREG_P (tmpx))\n-\t{\n-\t  operands[0] = tmpx;\n-\t  output_asm_insn (\\\"mov.w %0,r1\\\", operands);\n-\t}\n-      else\n-\t{\n-\t  output_asm_insn (\\\"mova %0,r1\\\", operands);\n-\t}\n-    }\n-  else\n-    {\n-      fprintf (stderr, \\\"smov 0 else err \\\");\n-      abort ();\n-    }\n-    \n-  if (GET_CODE (operands[2]) == CONST_INT)\n-    {\n-      op2const = INTVAL (operands[2]);\n-      if (op2const % 4 != 0)\n-\t{\n-\t  output_asm_insn (\\\"mov.w %2,r2\\\", operands);\n-\t  return \\\"smov/n/f.b\\\";\n-\t}\n-      op2const = op2const / 4;\n-      if (op2const <= 4)\n-\t{\n-\t  if (op2const == 0)\n-\t    abort (0);\n-\t  if (op2const == 1)\n-\t    return \\\"mov.w @r0,@r1\\\";\n-\t  output_asm_insn (\\\"mov.w @r0,@r1\\\", operands);\n-\t  if (op2const == 2)\n-\t    return \\\"mov.w @(4,r0),@(4,r1)\\\";\n-\t  output_asm_insn (\\\"mov.w @(4,r0),@(4,r1)\\\", operands);\n-\t  if (op2const == 3)\n-\t    return \\\"mov.w @(8,r0),@(8,r1)\\\";\n-\t  output_asm_insn (\\\"mov.w @(8,r0),@(8,r1)\\\", operands);\n-\t  return \\\"mov.w @(12,r0),@(12,r1)\\\";\n-\t}\n-\t    \n-      operands[2] = GEN_INT (op2const);\n-      output_asm_insn (\\\"mov.w %2,r2\\\", operands);\n-      return \\\"smov/n/f.w\\\";\n-    }\n-  else\n-    {\n-      fprintf (stderr, \\\"smov 0 else err \\\");\n-      abort ();\n-      output_asm_insn (\\\"mov %2.h,r2.w\\\", operands);\n-      return \\\"smov/n/f.b\\\";\n-    }\n-\n-}\")\n-\f\n-;; M.Yuhara 89.08.24\n-;; experiment on the built-in strcpy (__builtin_smov)\n-;;\n-;; len = 0 means unknown string length.\n-;;\n-;; mem:SI is dummy. Necessary so as not to be deleted by optimization.\n-;; Use of BLKmode would be better...\n-;;\n-;;\n-(define_insn \"smovsi\"\n-  [(set (mem:SI (match_operand:SI 0 \"general_operand\" \"=rm\"))\n-\t(mem:SI (match_operand:SI 1 \"general_operand\" \"rm\")))\n-   (use (match_operand:SI 2 \"general_operand\" \"i\"))\n-   (clobber (reg:SI 0))\n-   (clobber (reg:SI 1))\n-   (clobber (reg:SI 2))\n-   (clobber (reg:SI 3))]\n-  \"\"\n-  \"*\n-{\n-  int len, wlen, blen, offset;\n-  char tmpstr[128];\n-  rtx xoperands[1];\n-\n-  len = INTVAL (operands[2]);\n-  output_asm_insn (\\\"mov.w %1,r0\\\\t; begin built-in strcpy\\\", operands);\n-  output_asm_insn (\\\"mov.w %0,r1\\\", operands);\n-\n-  if (len == 0)\n-    {\n-      output_asm_insn (\\\"mov:z.w #0,r2\\\", operands);\n-      output_asm_insn (\\\"mov:z.w #0,r3\\\", operands);\n-      return \\\"smov/eq/f.b\\\\t; end built-in strcpy\\\";\n-    }\n-\n-  wlen = len / 4;\n-  blen = len - wlen * 4;\n-\n-  if (wlen > 0)\n-    {\n-      if (len <= 40 && !TARGET_FORCE_SMOV)\n-\t{\n-\t  output_asm_insn (\\\"mov.w @r0,@r1\\\", operands);\n-\t  offset = 4;\n-\t  while ( (blen = len - offset) > 0)\n-\t    {\n-\t      if (blen >= 4)\n-\t\t{\n-\t\t  sprintf (tmpstr, \\\"mov.w @(%d,r0),@(%d,r1)\\\",\n-\t\t\t   offset, offset);\n-\t\t  output_asm_insn (tmpstr, operands);\n-\t\t  offset += 4;\n-\t\t}\n-\t      else if (blen >= 2)\n-\t\t{\n-\t\t  sprintf (tmpstr, \\\"mov.h @(%d,r0),@(%d,r1)\\\",\n-\t\t\t   offset, offset);\n-\t\t  output_asm_insn (tmpstr, operands);\n-\t\t  offset += 2;\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  sprintf (tmpstr, \\\"mov.b @(%d,r0),@(%d,r1)\\\",\n-\t\t\t   offset, offset);\n-\t\t  output_asm_insn (tmpstr, operands);\n-\t\t  offset++;\n-\t\t}\n-\t    }\n-\t  return \\\"\\\\t\\\\t; end built-in strcpy\\\";\n-\t}\n-      else\n-\t{\n-\t  xoperands[0] = GEN_INT (wlen);\n-\t  output_asm_insn (\\\"mov.w %0,r2\\\", xoperands);\n-\t  output_asm_insn (\\\"smov/n/f.w\\\", operands);\n-\t}\n-    }\n-\n-  if (blen >= 2)\n-    {\n-      output_asm_insn (\\\"mov.h @r0,@r1\\\", operands);\n-      if (blen == 3)\n-\toutput_asm_insn (\\\"mov.b @(2,r0),@(2,r1)\\\", operands);\n-    }\n-  else if (blen == 1)\n-    {\n-      output_asm_insn (\\\"mov.b @r0,@r1\\\", operands);\n-    }\n-\n-  return \\\"\\\\t\\\\t; end built-in strcpy\\\";\n-}\")\n-\f\n-;; truncation instructions\n-(define_insn \"truncsiqi2\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"=rm\")\n-\t(truncate:QI\n-\t (match_operand:SI 1 \"general_operand\" \"rmi\")))]\n-  \"\"\n-  \"mov %1.w,%0.b\")\n-;  \"*\n-;{\n-;  if (GET_CODE (operands[0]) == REG)\n-;    return \\\"mov.w %1,%0\\\";\n-;  if (GET_CODE (operands[1]) == MEM)\n-;    operands[1] = adj_offsettable_operand (operands[1], 3);\n-;  return \\\"mov.b %1,%0\\\";\n-;}\")\n-\n-(define_insn \"trunchiqi2\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"=rm\")\n-\t(truncate:QI\n-\t (match_operand:HI 1 \"general_operand\" \"rmi\")))]\n-  \"\"\n-  \"mov %1.h,%0.b\")\n-;  \"*\n-;{\n-;  if (GET_CODE (operands[0]) == REG)\n-;    return \\\"mov.h %1,%0\\\";\n-;  if (GET_CODE (operands[1]) == MEM)\n-;    operands[1] = adj_offsettable_operand (operands[1], 1);\n-;  return \\\"mov.b %1,%0\\\";\n-;}\")\n-\n-(define_insn \"truncsihi2\"\n-  [(set (match_operand:HI 0 \"general_operand\" \"=rm\")\n-\t(truncate:HI\n-\t (match_operand:SI 1 \"general_operand\" \"rmi\")))]\n-  \"\"\n-  \"mov %1.w,%0.h\")\n-;  \"*\n-;{\n-;  if (GET_CODE (operands[0]) == REG)\n-;    return \\\"mov.w %1,%0\\\";\n-;  if (GET_CODE (operands[1]) == MEM)\n-;    operands[1] = adj_offsettable_operand (operands[1], 2);\n-;  return \\\"mov.h %1,%0\\\";\n-;}\")\n-\f\n-;; zero extension instructions\n-;; define_expand (68k) -> define_insn (Gmicro)\n-\n-(define_insn \"zero_extendhisi2\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=rm\")\n-        (zero_extend:SI (match_operand:HI 1 \"nonimmediate_operand\" \"rm\")))]\n-  \"\"\n-  \"movu %1.h,%0.w\")\n-\n-\n-(define_insn \"zero_extendqihi2\"\n-  [(set (match_operand:HI 0 \"general_operand\" \"=rm\")\n-        (zero_extend:HI (match_operand:QI 1 \"nonimmediate_operand\" \"rm\")))]\n-  \"\"\n-  \"movu %1.b,%0.h\")\n-\n-(define_insn \"zero_extendqisi2\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=rm\")\n-        (zero_extend:SI (match_operand:QI 1 \"nonimmediate_operand\" \"rm\")))]\n-  \"\"\n-  \"movu %1.b,%0.w\")\n-\n-\f\n-;; sign extension instructions\n-\n-(define_insn \"extendhisi2\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=rm\")\n-        (sign_extend:SI (match_operand:HI 1 \"nonimmediate_operand\" \"rm\")))]\n-  \"\"\n-  \"mov %1.h,%0.w\")\n-\n-\n-(define_insn \"extendqihi2\"\n-  [(set (match_operand:HI 0 \"general_operand\" \"=rm\")\n-        (sign_extend:HI (match_operand:QI 1 \"nonimmediate_operand\" \"rm\")))]\n-  \"\"\n-  \"mov %1.b,%0.h\")\n-\n-(define_insn \"extendqisi2\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=rm\")\n-        (sign_extend:SI (match_operand:QI 1 \"nonimmediate_operand\" \"rm\")))]\n-  \"\"\n-  \"mov %1.b,%0.w\")\n-\n-\n-\f\n-;; Conversions between float and double.\n-\n-(define_insn \"extendsfdf2\"\n-  [(set (match_operand:DF 0 \"general_operand\" \"=*frm,f\")\n-\t(float_extend:DF\n-\t  (match_operand:SF 1 \"general_operand\" \"f,rmF\")))]\n-  \"TARGET_FPU\"\n-  \"*\n-{\n-  if (FPU_REG_P (operands[0]))\n-    {\n-      if (GET_CODE (operands[1]) == CONST_DOUBLE)\n-\treturn output_move_const_double (operands);\n-      if (GREG_P (operands[1]))\n-\t{\n-\t  output_asm_insn (\\\"mov.w %1,%-\\\", operands);\n-\t  return \\\"fmov %+.s,%0.d\\\";\n-\t}\n-      return \\\"fmov %1.s,%0.d\\\";\n-    }\n-  else\n-    {\n-      if (GREG_P (operands[0]))\n-\t{\n-\t  output_asm_insn (\\\"fmov %1.s,%-.d\\\", operands);\n-\t  output_asm_insn (\\\"mov.w %+,%0\\\", operands);\n-\t  operands[0] = gen_rtx (REG, SImode, REGNO (operands[0]) + 1);\n-\t  return \\\"mov.w %+,%0\\\";\n-\t}\n-      return \\\"fmov %1.s,%0.d\\\";\n-    }\n-}\")\n-\n-\n-(define_insn \"truncdfsf2\"\n-  [(set (match_operand:SF 0 \"general_operand\" \"=rfm\")\n-\t(float_truncate:SF\n-\t  (match_operand:DF 1 \"general_operand\" \"f\")))]\n-  \"TARGET_FPU\"\n-  \"*\n-{\n-  if (GREG_P (operands[0]))\n-    {\n-      output_asm_insn (\\\"fmov %1.d,%-.s\\\", operands);\n-      return \\\"mov.w %+,%0\\\";\n-    }\n-  return \\\"fmov %1.d,%0.s\\\";\n-}\")\n-\f\n-;; Conversion between fixed point and floating point.\n-;; Note that among the fix-to-float insns\n-;; the ones that start with SImode come first.\n-;; That is so that an operand that is a CONST_INT\n-;; (and therefore lacks a specific machine mode).\n-;; will be recognized as SImode (which is always valid)\n-;; rather than as QImode or HImode.\n-\n-\n-(define_insn \"floatsisf2\"\n-  [(set (match_operand:SF 0 \"general_operand\" \"=f\")\n-\t(float:SF (match_operand:SI 1 \"general_operand\" \"rmi\")))]\n-  \"TARGET_FPU\"\n-  \"fldi %1.w,%0.s\")\n-\n-(define_insn \"floatsidf2\"\n-  [(set (match_operand:DF 0 \"general_operand\" \"=f\")\n-\t(float:DF (match_operand:SI 1 \"general_operand\" \"rmi\")))]\n-  \"TARGET_FPU\"\n-  \"fldi %1.w,%0.d\")\n-\n-(define_insn \"floathisf2\"\n-  [(set (match_operand:SF 0 \"general_operand\" \"=f\")\n-\t(float:SF (match_operand:HI 1 \"general_operand\" \"rmi\")))]\n-  \"TARGET_FPU\"\n-  \"fldi %1.h,%0.s\")\n-\n-(define_insn \"floathidf2\"\n-  [(set (match_operand:DF 0 \"general_operand\" \"=f\")\n-\t(float:DF (match_operand:HI 1 \"general_operand\" \"rmi\")))]\n-  \"TARGET_FPU\"\n-  \"fldi %1.h,%0.d\")\n-\n-(define_insn \"floatqisf2\"\n-  [(set (match_operand:SF 0 \"general_operand\" \"=f\")\n-\t(float:SF (match_operand:QI 1 \"general_operand\" \"rmi\")))]\n-  \"TARGET_FPU\"\n-  \"fldi %1.b,%0.s\")\n-\n-(define_insn \"floatqidf2\"\n-  [(set (match_operand:DF 0 \"general_operand\" \"=f\")\n-\t(float:DF (match_operand:QI 1 \"general_operand\" \"rmi\")))]\n-  \"TARGET_FPU\"\n-  \"fldi %1.b,%0.d\")\n-\n-;;; Convert a float to a float whose value is an integer.\n-;;; This is the first stage of converting it to an integer type.\n-;\n-;(define_insn \"ftruncdf2\"\n-;  [(set (match_operand:DF 0 \"general_operand\" \"=f\")\n-;\t(fix:DF (match_operand:DF 1 \"general_operand\" \"fFm\")))]\n-;  \"TARGET_FPU\"\n-;  \"*\n-;{\n-;  return \\\"fintrz.d %f1,%0\\\";\n-;}\")\n-;\n-;(define_insn \"ftruncsf2\"\n-;  [(set (match_operand:SF 0 \"general_operand\" \"=f\")\n-;\t(fix:SF (match_operand:SF 1 \"general_operand\" \"fFm\")))]\n-;  \"TARGET_FPU\"\n-;  \"*\n-;{\n-;  return \\\"fintrz.s %f1,%0\\\";\n-;}\")\n-\n-;; Convert a float to an integer.\n-\n-(define_insn \"fix_truncsfqi2\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"=rm\")\n-\t(fix:QI (fix:SF (match_operand:SF 1 \"general_operand\" \"f\"))))]\n-  \"TARGET_FPU\"\n-  \"fsti %1.s,%0.b\")\n-\n-(define_insn \"fix_truncsfhi2\"\n-  [(set (match_operand:HI 0 \"general_operand\" \"=rm\")\n-\t(fix:HI (fix:SF (match_operand:SF 1 \"general_operand\" \"f\"))))]\n-  \"TARGET_FPU\"\n-  \"fsti %1.s,%0.h\")\n-\n-(define_insn \"fix_truncsfsi2\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=rm\")\n-\t(fix:SI (fix:SF (match_operand:SF 1 \"general_operand\" \"f\"))))]\n-  \"TARGET_FPU\"\n-  \"fsti %1.s,%0.w\")\n-\n-(define_insn \"fix_truncdfqi2\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"=rm\")\n-\t(fix:QI (fix:DF (match_operand:DF 1 \"general_operand\" \"f\"))))]\n-  \"TARGET_FPU\"\n-  \"fsti %1.d,%0.b\")\n-\n-(define_insn \"fix_truncdfhi2\"\n-  [(set (match_operand:HI 0 \"general_operand\" \"=rm\")\n-\t(fix:HI (fix:DF (match_operand:DF 1 \"general_operand\" \"f\"))))]\n-  \"TARGET_FPU\"\n-  \"fsti %1.d,%0.h\")\n-\n-(define_insn \"fix_truncdfsi2\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=rm\")\n-\t(fix:SI (fix:DF (match_operand:DF 1 \"general_operand\" \"f\"))))]\n-  \"TARGET_FPU\"\n-  \"fsti %1.d,%0.w\")\n-\n-\f\n-;;; Special add patterns\n-;;; 89.09.28\n-\n-;; This should be redundant; please find out why regular addsi3\n-;; fails to match this case.\n-\n-;(define_insn \"\"\n-;  [(set (mem:SI (plus:SI\n-;\t\t    (plus:SI (match_operand 0 \"general_operand\" \"r\")\n-;\t\t\t     (match_operand 1 \"general_operand\" \"r\"))\n-;\t\t    (match_operand 2 \"general_operand\" \"i\")))\n-;\t(plus:SI\n-;\t    (mem:SI (plus:SI\n-;\t\t\t(plus:SI (match_dup 0)\n-;\t\t\t\t (match_dup 1))\n-;\t\t\t(match_dup 2)))\n-;\t    (match_operand 3 \"general_operand\" \"rmi\")))]\n-;  \"\"\n-;  \"add.w %3,@(%c2,%0,%1)\")\n-\n-\f\n-;; add instructions\n-\n-;; Note that the last two alternatives are near-duplicates\n-;; in order to handle insns generated by reload.\n-;; This is needed since they are not themselves reloaded,\n-;; so commutativity won't apply to them.\n-\n-(define_insn \"addsi3\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=rm,!r,!r\")\n-\t(plus:SI (match_operand:SI 1 \"general_operand\" \"%0,r,ri\")\n-\t\t (match_operand:SI 2 \"general_operand\" \"rmi,ri,r\")))]\n-  \"\"\n-  \"*\n-{\n-  if (which_alternative == 0)\n-    {\n-      if (GET_CODE (operands[2]) == CONST_INT)\n-\t{\n-\t  operands[1] = operands[2];\n-\t  return add_imm_word (INTVAL (operands[1]), operands[0], &operands[1]);\n-\t}\n-      else\n-\treturn \\\"add.w %2,%0\\\";\n-    }\n-  else\n-    {\n-      if (GET_CODE (operands[1]) == REG\n-\t  && REGNO (operands[0]) == REGNO (operands[1]))\n-\treturn \\\"add.w %2,%0\\\";\n-      if (GET_CODE (operands[2]) == REG\n-\t  && REGNO (operands[0]) == REGNO (operands[2]))\n-\treturn \\\"add.w %1,%0\\\";\n-\n-      if (GET_CODE (operands[1]) == REG)\n-\t{\n-\t  if (GET_CODE (operands[2]) == REG)\n-\t    return \\\"mova.w @(%1,%2),%0\\\";\n-\t  else\n-\t    return \\\"mova.w @(%c2,%1),%0\\\";\n-\t}\n-      else\n-\treturn \\\"mova.w @(%c1,%2),%0\\\";\n-    }\n-}\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=rm\")\n-\t(plus:SI (match_operand:SI 1 \"general_operand\" \"0\")\n-\t\t (sign_extend:SI (match_operand:HI 2 \"nonimmediate_operand\" \"rmi\"))))]\n-  \"\"\n-  \"*\n-{\n-  if (CONSTANT_P (operands[2]))\n-    {\n-      operands[1] = operands[2];\n-      return add_imm_word (INTVAL (operands[1]), operands[0], &operands[1]);\n-    }\n-  else\n-    return \\\"add %2.h,%0.w\\\";\n-}\")\n-\n-(define_insn \"addhi3\"\n-  [(set (match_operand:HI 0 \"general_operand\" \"=rm\")\n-\t(plus:HI (match_operand:HI 1 \"general_operand\" \"%0\")\n-\t\t (match_operand:HI 2 \"general_operand\" \"rmi\")))]\n-  \"\"\n-  \"*\n-{\n-  if (GET_CODE (operands[2]) == CONST_INT\n-      && INTVAL (operands[2]) < 0)\n-    return \\\"sub.h #%n2,%0\\\";\n-  if (GREG_P (operands[0]))\n-    {\n-      if (CONSTANT_P (operands[2]))\n-\treturn \\\"add:l %2,%0.w\\\";\n-      else\n-\treturn \\\"add:l %2.h,%0.w\\\";\n-    }\n-  return \\\"add.h %2,%0\\\";\n-}\")\n-\n-(define_insn \"\"\n-  [(set (strict_low_part (match_operand:HI 0 \"general_operand\" \"+rm\"))\n-\t(plus:HI (match_dup 0)\n-\t\t (match_operand:HI 1 \"general_operand\" \"rmi\")))]\n-  \"\"\n-  \"add.h %1,%0\")\n-\n-(define_insn \"addqi3\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"=rm\")\n-\t(plus:QI (match_operand:QI 1 \"general_operand\" \"%0\")\n-\t\t (match_operand:QI 2 \"general_operand\" \"rmi\")))]\n-  \"\"\n-  \"*\n-{\n-  if (GET_CODE (operands[2]) == CONST_INT\n-      && INTVAL (operands[2]) < 0)\n-    return \\\"sub.b #%n2,%0\\\";\n-  if (GREG_P (operands[0]))\n-    {\n-      if (CONSTANT_P (operands[2]))\n-\treturn \\\"add:l %2,%0.w\\\";\n-      else\n-\treturn \\\"add:l %2.b,%0.w\\\";\n-    }\n-  return \\\"add.b %2,%0\\\";\n-}\")\n-\n-(define_insn \"\"\n-  [(set (strict_low_part (match_operand:QI 0 \"general_operand\" \"+rm\"))\n-\t(plus:QI (match_dup 0)\n-\t\t (match_operand:QI 1 \"general_operand\" \"rmi\")))]\n-  \"\"\n-  \"add.b %1,%0\")\n-\n-(define_insn \"adddf3\"\n-  [(set (match_operand:DF 0 \"general_operand\" \"=f\")\n-\t(plus:DF (match_operand:DF 1 \"general_operand\" \"%0\")\n-\t\t (match_operand:DF 2 \"general_operand\" \"fmG\")))]\n-  \"TARGET_FPU\"\n-  \"fadd.d %f2,%0\")\n-\n-(define_insn \"addsf3\"\n-  [(set (match_operand:SF 0 \"general_operand\" \"=f\")\n-\t(plus:SF (match_operand:SF 1 \"general_operand\" \"%0\")\n-\t\t (match_operand:SF 2 \"general_operand\" \"fmG\")))]\n-  \"TARGET_FPU\"\n-  \"fadd.s %f2,%0\")\n-\f\n-;; subtract instructions\n-\n-(define_insn \"subsi3\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=rm,!r\")\n-\t(minus:SI (match_operand:SI 1 \"general_operand\" \"0,r\")\n-\t\t  (match_operand:SI 2 \"general_operand\" \"rmi,i\")))]\n-  \"\"\n-  \"*\n-{\n-  if (which_alternative == 0\n-      || (GET_CODE (operands[1]) == REG\n-\t  && REGNO (operands[0]) == REGNO (operands[1])))\n-    {\n-      if (GET_CODE (operands[2]) == CONST_INT)\n-\t{\n-\t  operands[1] = operands[2];\n-\t  return sub_imm_word (INTVAL (operands[1]),\n-\t\t\t       operands[0], &operands[1]);\n-\t}\n-      else\n-\treturn \\\"sub.w %2,%0\\\";\n-    }\n-  else\n-    return \\\"mova.w @(%n2,%1),%0\\\";\n-}\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=rm\")\n-\t(minus:SI (match_operand:SI 1 \"general_operand\" \"0\")\n-\t\t  (sign_extend:SI (match_operand:HI 2 \"nonimmediate_operand\" \"rmi\"))))]\n-  \"\"\n-  \"sub %2.h,%0.w\")\n-\n-(define_insn \"subhi3\"\n-  [(set (match_operand:HI 0 \"general_operand\" \"=rm\")\n-\t(minus:HI (match_operand:HI 1 \"general_operand\" \"0\")\n-\t\t  (match_operand:HI 2 \"general_operand\" \"rmi\")))]\n-  \"\"\n-  \"*\n-{\n-  if (GET_CODE (operands[2]) == CONST_INT\n-      && INTVAL (operands[2]) < 0\n-      && INTVAL (operands[2]) != 0x8000)\n-    return \\\"add.h #%n2,%0\\\";\n-  return \\\"sub.h %2,%0\\\";\n-}\")\n-\n-(define_insn \"\"\n-  [(set (strict_low_part (match_operand:HI 0 \"general_operand\" \"+rm\"))\n-\t(minus:HI (match_dup 0)\n-\t\t  (match_operand:HI 1 \"general_operand\" \"rmi\")))]\n-  \"\"\n-  \"sub.h %1,%0\")\n-\n-(define_insn \"subqi3\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"=rm\")\n-\t(minus:QI (match_operand:QI 1 \"general_operand\" \"0\")\n-\t\t  (match_operand:QI 2 \"general_operand\" \"rmi\")))]\n-  \"\"\n-  \"*\n-{\n-  if (GET_CODE (operands[2]) == CONST_INT\n-      && INTVAL (operands[2]) < 0\n-      && INTVAL (operands[2]) != 0x80)\n-    return \\\"add.b #%n2,%0\\\";\n-  return \\\"sub.b %2,%0\\\";\n-}\")\n-\n-(define_insn \"\"\n-  [(set (strict_low_part (match_operand:QI 0 \"general_operand\" \"+rm\"))\n-\t(minus:QI (match_dup 0)\n-\t\t  (match_operand:QI 1 \"general_operand\" \"rmi\")))]\n-  \"\"\n-  \"sub.b %1,%0\")\n-\n-(define_insn \"subdf3\"\n-  [(set (match_operand:DF 0 \"general_operand\" \"=f\")\n-\t(minus:DF (match_operand:DF 1 \"general_operand\" \"0\")\n-\t\t  (match_operand:DF 2 \"general_operand\" \"fmG\")))]\n-  \"TARGET_FPU\"\n-  \"fsub.d %f2,%0\")\n-\n-(define_insn \"subsf3\"\n-  [(set (match_operand:SF 0 \"general_operand\" \"=f\")\n-\t(minus:SF (match_operand:SF 1 \"general_operand\" \"0\")\n-\t\t  (match_operand:SF 2 \"general_operand\" \"fmG\")))]\n-  \"TARGET_FPU\"\n-  \"fsub.s %f2,%0\")\n-\n-\f\n-;; multiply instructions\n-\n-(define_insn \"mulqi3\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"=rm\")\n-\t(mult:QI (match_operand:QI 1 \"general_operand\" \"%0\")\n-\t\t (match_operand:QI 2 \"general_operand\" \"rmi\")))]\n-  \"\"\n-  \"mul.b %2,%0\")\n-\n-\n-(define_insn \"mulhi3\"\n-  [(set (match_operand:HI 0 \"general_operand\" \"=rm\")\n-\t(mult:HI (match_operand:HI 1 \"general_operand\" \"%0\")\n-\t\t (match_operand:HI 2 \"general_operand\" \"rmi\")))]\n-  \"\"\n-  \"mul.h %2,%0\")\n-\n-;; define_insn \"mulhisi3\"\n-\n-(define_insn \"mulsi3\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=rm\")\n-\t(mult:SI (match_operand:SI 1 \"general_operand\" \"%0\")\n-\t\t (match_operand:SI 2 \"general_operand\" \"rmi\")))]\n-  \"\"\n-  \"mul.w %2,%0\")\n-\n-(define_insn \"muldf3\"\n-  [(set (match_operand:DF 0 \"general_operand\" \"=f\")\n-\t(mult:DF (match_operand:DF 1 \"general_operand\" \"%0\")\n-\t\t (match_operand:DF 2 \"general_operand\" \"fmG\")))]\n-  \"TARGET_FPU\"\n-  \"fmul.d %f2,%0\")\n-\n-(define_insn \"mulsf3\"\n-  [(set (match_operand:SF 0 \"general_operand\" \"=f\")\n-\t(mult:SF (match_operand:SF 1 \"general_operand\" \"%0\")\n-\t\t (match_operand:SF 2 \"general_operand\" \"fmG\")))]\n-  \"TARGET_FPU\"\n-  \"fmul.s %f2,%0\")\n-\n-\f\n-;; divide instructions\n-\n-(define_insn \"divqi3\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"=rm\")\n-\t(div:QI (match_operand:QI 1 \"general_operand\" \"0\")\n-\t\t(match_operand:QI 2 \"general_operand\" \"rmi\")))]\n-  \"\"\n-  \"div.b %2,%0\")\n-\n-(define_insn \"divhi3\"\n-  [(set (match_operand:HI 0 \"general_operand\" \"=rm\")\n-\t(div:HI (match_operand:HI 1 \"general_operand\" \"0\")\n-\t\t(match_operand:HI 2 \"general_operand\" \"rmi\")))]\n-  \"\"\n-  \"div.h %2,%0\")\n-\n-(define_insn \"divhisi3\"\n-  [(set (match_operand:HI 0 \"general_operand\" \"=r\")\n-\t(div:HI (match_operand:SI 1 \"general_operand\" \"0\")\n-\t\t(match_operand:HI 2 \"general_operand\" \"rmi\")))]\n-  \"\"\n-  \"div %2.h,%0.w\")\n-\n-(define_insn \"divsi3\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=rm\")\n-\t(div:SI (match_operand:SI 1 \"general_operand\" \"0\")\n-\t\t(match_operand:SI 2 \"general_operand\" \"rmi\")))]\n-  \"\"\n-  \"div.w %2,%0\")\n-\n-(define_insn \"udivqi3\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"=rm\")\n-\t(udiv:QI (match_operand:QI 1 \"general_operand\" \"0\")\n-\t\t (match_operand:QI 2 \"general_operand\" \"rmi\")))]\n-  \"\"\n-  \"divu.b %2,%0\")\n-\n-(define_insn \"udivhi3\"\n-  [(set (match_operand:HI 0 \"general_operand\" \"=rm\")\n-\t(udiv:HI (match_operand:HI 1 \"general_operand\" \"0\")\n-\t\t (match_operand:HI 2 \"general_operand\" \"rmi\")))]\n-  \"\"\n-  \"divu.h %2,%0\")\n-\n-(define_insn \"udivhisi3\"\n-  [(set (match_operand:HI 0 \"general_operand\" \"=r\")\n-\t(udiv:HI (match_operand:SI 1 \"general_operand\" \"0\")\n-\t\t (match_operand:HI 2 \"general_operand\" \"rmi\")))]\n-  \"\"\n-  \"divu %2.h,%0.w\")\n-\n-(define_insn \"udivsi3\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=rm\")\n-\t(udiv:SI (match_operand:SI 1 \"general_operand\" \"0\")\n-\t\t (match_operand:SI 2 \"general_operand\" \"rmi\")))]\n-  \"\"\n-  \"divu.w %2,%0\")\n-\n-(define_insn \"divdf3\"\n-  [(set (match_operand:DF 0 \"general_operand\" \"=f\")\n-\t(div:DF (match_operand:DF 1 \"general_operand\" \"0\")\n-\t\t(match_operand:DF 2 \"general_operand\" \"fmG\")))]\n-  \"TARGET_FPU\"\n-  \"fdiv.d %f2,%0\")\n-\n-(define_insn \"divsf3\"\n-  [(set (match_operand:SF 0 \"general_operand\" \"=f\")\n-\t(div:SF (match_operand:SF 1 \"general_operand\" \"0\")\n-\t\t(match_operand:SF 2 \"general_operand\" \"fmG\")))]\n-  \"TARGET_FPU\"\n-  \"fdiv.s %f2,%0\")\n-\f\n-;; Remainder instructions.\n-\n-(define_insn \"modqi3\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"=rm\")\n-\t(mod:QI (match_operand:QI 1 \"general_operand\" \"0\")\n-\t\t(match_operand:QI 2 \"general_operand\" \"rmi\")))]\n-  \"\"\n-  \"rem.b %2,%0\")\n-\n-(define_insn \"modhisi3\"\n-  [(set (match_operand:HI 0 \"general_operand\" \"=r\")\n-\t(mod:HI (match_operand:SI 1 \"general_operand\" \"0\")\n-\t\t(match_operand:HI 2 \"general_operand\" \"rmi\")))]\n-  \"\"\n-  \"rem.h %2,%0\")\n-\n-(define_insn \"umodqi3\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"=rm\")\n-\t(umod:QI (match_operand:QI 1 \"general_operand\" \"0\")\n-\t\t (match_operand:QI 2 \"general_operand\" \"rmi\")))]\n-  \"\"\n-  \"remu.b %2,%0\")\n-\n-(define_insn \"umodhi3\"\n-  [(set (match_operand:HI 0 \"general_operand\" \"=rm\")\n-\t(umod:HI (match_operand:HI 1 \"general_operand\" \"0\")\n-\t\t (match_operand:HI 2 \"general_operand\" \"rmi\")))]\n-  \"\"\n-  \"remu.h %2,%0\")\n-\n-(define_insn \"umodhisi3\"\n-  [(set (match_operand:HI 0 \"general_operand\" \"=r\")\n-\t(umod:HI (match_operand:SI 1 \"general_operand\" \"0\")\n-\t\t (match_operand:HI 2 \"general_operand\" \"rmi\")))]\n-  \"\"\n-  \"remu %2.h,%0.w\")\n-\n-;; define_insn \"divmodsi4\"\n-\n-(define_insn \"udivmodsi4\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=rm\")\n-\t(udiv:SI (match_operand:SI 1 \"general_operand\" \"0\")\n-\t\t (match_operand:SI 2 \"general_operand\" \"rmi\")))\n-   (set (match_operand:SI 3 \"general_operand\" \"=r\")\n-\t(umod:SI (match_dup 1) (match_dup 2)))]\n-  \"\"\n-  \"mov.w #0,%3;divx.w %2,%0,%3\")\n-\f\n-;; logical-and instructions\n-\n-(define_insn \"andsi3\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=rm\")\n-\t(and:SI (match_operand:SI 1 \"general_operand\" \"%0\")\n-\t\t(match_operand:SI 2 \"general_operand\" \"rmi\")))]\n-  \"\"\n-  \"*\n-{\n-  if (GET_CODE (operands[2]) == CONST_INT\n-      && (INTVAL (operands[2]) | 0xffff) == 0xffffffff\n-      && (GREG_P (operands[0])\n-\t  || offsettable_memref_p (operands[0])))\n-   \n-    { \n-      if (GET_CODE (operands[0]) != REG)\n-        operands[0] = adj_offsettable_operand (operands[0], 2);\n-      operands[2] = GEN_INT (INTVAL (operands[2]) & 0xffff);\n-      /* Do not delete a following tstl %0 insn; that would be incorrect.  */\n-      CC_STATUS_INIT;\n-      return \\\"and.h %2,%0\\\";\n-    }\n-  return \\\"and.w %2,%0\\\";\n-}\")\n-\n-(define_insn \"andhi3\"\n-  [(set (match_operand:HI 0 \"general_operand\" \"=rm\")\n-\t(and:HI (match_operand:HI 1 \"general_operand\" \"%0\")\n-\t\t(match_operand:HI 2 \"general_operand\" \"rmi\")))]\n-  \"\"\n-  \"and.h %2,%0\")\n-\n-(define_insn \"andqi3\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"=rm\")\n-\t(and:QI (match_operand:QI 1 \"general_operand\" \"%0\")\n-\t\t(match_operand:QI 2 \"general_operand\" \"rmi\")))]\n-  \"\"\n-  \"and.b %2,%0\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=r\")\n-\t(and:SI (zero_extend:SI (match_operand:HI 1 \"nonimmediate_operand\" \"rm\"))\n-\t\t(match_operand:SI 2 \"general_operand\" \"0\")))]\n-  \"\"\n-  \"*\n-{\n-  if (GET_CODE (operands[1]) == CONST_INT)\n-    return \\\"and %1,%0.w\\\";\n-  return \\\"and %1.h,%0.w\\\";\n-}\")\n-\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=r\")\n-\t(and:SI (zero_extend:SI (match_operand:QI 1 \"nonimmediate_operand\" \"rm\"))\n-\t\t(match_operand:SI 2 \"general_operand\" \"0\")))]\n-  \"\"\n-  \"*\n-{\n-  if (GET_CODE (operands[1]) == CONST_INT)\n-    return \\\"and %1,%0.w\\\";\n-  return \\\"and %1.b,%0.w\\\";\n-}\")\n-\f\n-;; inclusive-or instructions\n-\n-(define_insn \"iorsi3\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=rm\")\n-\t(ior:SI (match_operand:SI 1 \"general_operand\" \"%0\")\n-\t\t(match_operand:SI 2 \"general_operand\" \"rmi\")))]\n-  \"\"\n-  \"*\n-{\n-  register int logval;\n-  if (GET_CODE (operands[2]) == CONST_INT\n-      && INTVAL (operands[2]) >> 16 == 0\n-      && (GREG_P (operands[0])\n-\t  || offsettable_memref_p (operands[0])))\n-    { \n-      if (GET_CODE (operands[0]) != REG)\n-        operands[0] = adj_offsettable_operand (operands[0], 2);\n-      /* Do not delete a following tstl %0 insn; that would be incorrect.  */\n-      CC_STATUS_INIT;\n-      return \\\"or.h %2,%0\\\";\n-    }\n-  if (GET_CODE (operands[2]) == CONST_INT\n-      && (logval = exact_log2 (INTVAL (operands[2]))) >= 0\n-      && (GREG_P (operands[0])\n-\t  || offsettable_memref_p (operands[0])))\n-    { \n-      if (GREG_P (operands[0]))\n-\t{\n-\t  if (logval < 7)\n-\t    {\n-\t      operands[1] = GEN_INT (7 - logval);\n-\t      return \\\"bset.b %1,%0\\\";\n-\t    }\n-\t  operands[1] = GEN_INT (31 - logval);\n-\t  return \\\"bset.w %1,%0\\\";\n-\t}\n-      else\n-        {\n-\t  operands[0]\n-\t    = adj_offsettable_operand (operands[0], 3 - (logval / 8));\n-\t  operands[1] = GEN_INT (7 - (logval % 8));\n-\t}\n-      return \\\"bset.b %1,%0\\\";\n-    }\n-  return \\\"or.w %2,%0\\\";\n-}\")\n-\n-(define_insn \"iorhi3\"\n-  [(set (match_operand:HI 0 \"general_operand\" \"=rm\")\n-\t(ior:HI (match_operand:HI 1 \"general_operand\" \"%0\")\n-\t\t(match_operand:HI 2 \"general_operand\" \"rmi\")))]\n-  \"\"\n-  \"or.h %2,%0\")\n-\n-(define_insn \"iorqi3\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"=rm\")\n-\t(ior:QI (match_operand:QI 1 \"general_operand\" \"%0\")\n-\t\t(match_operand:QI 2 \"general_operand\" \"rmi\")))]\n-  \"\"\n-  \"or.b %2,%0\")\n-\f\n-;; xor instructions\n-\n-(define_insn \"xorsi3\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=rm\")\n-\t(xor:SI (match_operand:SI 1 \"general_operand\" \"%0\")\n-\t\t(match_operand:SI 2 \"general_operand\" \"rmi\")))]\n-  \"\"\n-  \"*\n-{\n-  if (GET_CODE (operands[2]) == CONST_INT\n-      && INTVAL (operands[2]) >> 16 == 0\n-      && (offsettable_memref_p (operands[0]) || GREG_P (operands[0])))\n-    { \n-      if (! GREG_P (operands[0]))\n-\toperands[0] = adj_offsettable_operand (operands[0], 2);\n-      /* Do not delete a following tstl %0 insn; that would be incorrect.  */\n-      CC_STATUS_INIT;\n-      return \\\"xor.h %2,%0\\\";\n-    }\n-  return \\\"xor.w %2,%0\\\";\n-}\")\n-\n-(define_insn \"xorhi3\"\n-  [(set (match_operand:HI 0 \"general_operand\" \"=rm\")\n-\t(xor:HI (match_operand:HI 1 \"general_operand\" \"%0\")\n-\t\t(match_operand:HI 2 \"general_operand\" \"rmi\")))]\n-  \"\"\n-  \"xor.h %2,%0\")\n-\n-(define_insn \"xorqi3\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"=rm\")\n-\t(xor:QI (match_operand:QI 1 \"general_operand\" \"%0\")\n-\t\t(match_operand:QI 2 \"general_operand\" \"rmi\")))]\n-  \"\"\n-  \"xor.b %2,%0\")\n-\f\n-;; negation instructions\n-\n-(define_insn \"negsi2\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=rm\")\n-\t(neg:SI (match_operand:SI 1 \"general_operand\" \"0\")))]\n-  \"\"\n-  \"neg.w %0\")\n-\n-(define_insn \"neghi2\"\n-  [(set (match_operand:HI 0 \"general_operand\" \"=rm\")\n-\t(neg:HI (match_operand:HI 1 \"general_operand\" \"0\")))]\n-  \"\"\n-  \"neg.h %0\")\n-\n-(define_insn \"negqi2\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"=rm\")\n-\t(neg:QI (match_operand:QI 1 \"general_operand\" \"0\")))]\n-  \"\"\n-  \"neg.b %0\")\n-\n-(define_insn \"negsf2\"\n-  [(set (match_operand:SF 0 \"general_operand\" \"=f\")\n-\t(neg:SF (match_operand:SF 1 \"general_operand\" \"fmF\")))]\n-  \"TARGET_FPU\"\n-  \"fneg.s %f1,%0\")\n-\n-\n-(define_insn \"negdf2\"\n-  [(set (match_operand:DF 0 \"general_operand\" \"=f\")\n-\t(neg:DF (match_operand:DF 1 \"general_operand\" \"fmF\")))]\n-  \"TARGET_FPU\"\n-  \"fneg.d %f1,%0\")\n-\n-\f\n-;; Absolute value instructions\n-\n-(define_insn \"abssf2\"\n-  [(set (match_operand:SF 0 \"general_operand\" \"=f\")\n-\t(abs:SF (match_operand:SF 1 \"general_operand\" \"fmF\")))]\n-  \"TARGET_FPU\"\n-  \"fabs.s %f1,%0\")\n-\n-(define_insn \"absdf2\"\n-  [(set (match_operand:DF 0 \"general_operand\" \"=f\")\n-\t(abs:DF (match_operand:DF 1 \"general_operand\" \"fmF\")))]\n-  \"TARGET_FPU\"\n-  \"fabs.d %f1,%0\")\n-\n-\f\n-;; one complement instructions\n-\n-(define_insn \"one_cmplsi2\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=rm\")\n-\t(not:SI (match_operand:SI 1 \"general_operand\" \"0\")))]\n-  \"\"\n-  \"not.w %0\")\n-\n-(define_insn \"one_cmplhi2\"\n-  [(set (match_operand:HI 0 \"general_operand\" \"=rm\")\n-\t(not:HI (match_operand:HI 1 \"general_operand\" \"0\")))]\n-  \"\"\n-  \"not.h %0\")\n-\n-(define_insn \"one_cmplqi2\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"=rm\")\n-\t(not:QI (match_operand:QI 1 \"general_operand\" \"0\")))]\n-  \"\"\n-  \"not.b %0\")\n-\f\n-;; Optimized special case of shifting.\n-;; Must precede the general case.\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=r\")\n-\t(ashiftrt:SI (match_operand:SI 1 \"memory_operand\" \"m\")\n-\t\t     (const_int 24)))]\n-  \"GET_CODE (XEXP (operands[1], 0)) != POST_INC\n-   && GET_CODE (XEXP (operands[1], 0)) != PRE_DEC\"\n-  \"mov:l %1.b,%0.w\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=r\")\n-\t(lshiftrt:SI (match_operand:SI 1 \"memory_operand\" \"m\")\n-\t\t     (const_int 24)))]\n-  \"GET_CODE (XEXP (operands[1], 0)) != POST_INC\n-   && GET_CODE (XEXP (operands[1], 0)) != PRE_DEC\"\n-  \"movu %1.b,%0.w\")\n-\n-(define_insn \"\"\n-  [(set (cc0) (compare (match_operand:QI 0 \"general_operand\" \"i\")\n-\t\t       (lshiftrt:SI (match_operand:SI 1 \"memory_operand\" \"m\")\n-\t\t\t\t    (const_int 24))))]\n-  \"(GET_CODE (operands[0]) == CONST_INT\n-    && (INTVAL (operands[0]) & ~0xff) == 0)\"\n-  \"*\n-{\n-  cc_status.flags |= CC_REVERSED;\n-  if (my_signed_comp (insn))\n-    return \\\"cmp.b %0,%1\\\";\n-  return \\\"cmpu.b %0,%1\\\";\n-}\")\n-\n-(define_insn \"\"\n-  [(set (cc0) (compare (lshiftrt:SI (match_operand:SI 0 \"memory_operand\" \"m\")\n-\t\t\t\t    (const_int 24))\n-\t\t       (match_operand:QI 1 \"general_operand\" \"i\")))]\n-  \"(GET_CODE (operands[1]) == CONST_INT\n-    && (INTVAL (operands[1]) & ~0xff) == 0)\"\n-  \"*\n-  if (my_signed_comp (insn))\n-\treturn \\\"cmp.b %1,%0\\\";\n-  return \\\"cmpu.b %1,%0\\\";\n-\")\n-\n-(define_insn \"\"\n-  [(set (cc0) (compare (match_operand:QI 0 \"general_operand\" \"i\")\n-\t\t       (ashiftrt:SI (match_operand:SI 1 \"memory_operand\" \"m\")\n-\t\t\t\t    (const_int 24))))]\n-  \"(GET_CODE (operands[0]) == CONST_INT\n-    && ((INTVAL (operands[0]) + 0x80) & ~0xff) == 0)\"\n-  \"*\n-  cc_status.flags |= CC_REVERSED;\n-  if (my_signed_comp (insn))\n-\treturn \\\"cmp.b %0,%1\\\";\n-  return \\\"cmpu.b %0,%1\\\";\n-\")\n-\n-(define_insn \"\"\n-  [(set (cc0) (compare (ashiftrt:SI (match_operand:SI 0 \"memory_operand\" \"m\")\n-\t\t\t\t    (const_int 24))\n-\t\t       (match_operand:QI 1 \"general_operand\" \"i\")))]\n-  \"(GET_CODE (operands[1]) == CONST_INT\n-    && ((INTVAL (operands[1]) + 0x80) & ~0xff) == 0)\"\n-  \"*\n-  if (my_signed_comp (insn))\n-\treturn \\\"cmp.b %1,%0\\\";\n-  return \\\"cmpu.b %1,%0\\\";\n-\")\n-\f\n-;; arithmetic shift instructions\n-;; We don't need the shift memory by 1 bit instruction\n-\n-(define_insn \"ashlsi3\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=rm\")\n-\t(ashift:SI (match_operand:SI 1 \"general_operand\" \"0\")\n-\t\t   (match_operand:SI 2 \"general_operand\" \"rmi\")))]\n-  \"\"\n-  \"sha.w %2,%0\")\n-\n-(define_insn \"ashlhi3\"\n-  [(set (match_operand:HI 0 \"general_operand\" \"=rm\")\n-\t(ashift:HI (match_operand:HI 1 \"general_operand\" \"0\")\n-\t\t   (match_operand:HI 2 \"general_operand\" \"rmi\")))]\n-  \"\"\n-  \"sha.h %2,%0\")\n-\n-(define_insn \"ashlqi3\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"=rm\")\n-\t(ashift:QI (match_operand:QI 1 \"general_operand\" \"0\")\n-\t\t   (match_operand:QI 2 \"general_operand\" \"rmi\")))]\n-  \"\"\n-  \"sha.b %2,%0\")\n-\n-;; Arithmetic right shift on the Gmicro works by negating the shift count\n-\n-;; ashiftrt -> ashift\n-(define_expand \"ashrsi3\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=rm\")\n-\t(ashift:SI (match_operand:SI 1 \"general_operand\" \"0\")\n-\t\t     (match_operand:SI 2 \"general_operand\" \"rmi\")))]\n-  \"\"\n-  \"{ operands[2] = negate_rtx (SImode, operands[2]); }\")\n-\n-;; ashiftrt -> ashift\n-(define_expand \"ashrhi3\"\n-  [(set (match_operand:HI 0 \"general_operand\" \"=rm\")\n-\t(ashift:HI (match_operand:HI 1 \"general_operand\" \"0\")\n-\t\t     (match_operand:HI 2 \"general_operand\" \"rmi\")))]\n-  \"\"\n-  \" { operands[2] = negate_rtx (HImode, operands[2]); }\")\n-\n-;; ashiftrt -> ashift\n-(define_expand \"ashrqi3\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"=rm\")\n-\t(ashift:QI (match_operand:QI 1 \"general_operand\" \"0\")\n-\t\t     (match_operand:QI 2 \"general_operand\" \"rmi\")))]\n-  \"\"\n-  \" { operands[2] = negate_rtx (QImode, operands[2]); }\")\n-\f\n-;; logical shift instructions\n-\n-;; Logical right shift on the gmicro works by negating the shift count,\n-;; then emitting a right shift with the shift count negated.  This means\n-;; that all actual shift counts in the RTL will be positive.  This \n-;; prevents converting shifts to ZERO_EXTRACTs with negative positions,\n-;; which isn't valid.\n-\n-(define_expand \"lshrsi3\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=g\")\n-\t(lshiftrt:SI (match_operand:SI 1 \"general_operand\" \"g\")\n-\t\t     (match_operand:SI 2 \"general_operand\" \"g\")))]\n-  \"\"\n-  \"\n-{\n-  if (GET_CODE (operands[2]) != CONST_INT)\n-    operands[2] = gen_rtx_NEG (SImode, negate_rtx (SImode, operands[2]));\n-}\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=rm\")\n-\t(lshiftrt:SI (match_operand:SI 1 \"general_operand\" \"0\")\n-\t\t     (match_operand:SI 2 \"const_int_operand\" \"n\")))]\n-  \"\"\n-  \"shl.w %n2,%0\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=rm\")\n-\t(lshiftrt:SI (match_operand:SI 1 \"general_operand\" \"0\")\n-\t\t     (neg:SI (match_operand:SI 2 \"general_operand\" \"rm\"))))]\n-  \"\"\n-  \"shl.w %2,%0\")\n-\n-(define_expand \"lshrhi3\"\n-  [(set (match_operand:HI 0 \"general_operand\" \"=g\")\n-\t(lshiftrt:HI (match_operand:HI 1 \"general_operand\" \"g\")\n-\t\t     (match_operand:HI 2 \"general_operand\" \"g\")))]\n-  \"\"\n-  \"\n-{\n-  if (GET_CODE (operands[2]) != CONST_INT)\n-    operands[2] = gen_rtx_NEG (HImode, negate_rtx (HImode, operands[2]));\n-}\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:HI 0 \"general_operand\" \"=rm\")\n-\t(lshiftrt:HI (match_operand:HI 1 \"general_operand\" \"0\")\n-\t\t     (match_operand:HI 2 \"const_int_operand\" \"n\")))]\n-  \"\"\n-  \"shl.h %n2,%0\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:HI 0 \"general_operand\" \"=rm\")\n-\t(lshiftrt:HI (match_operand:HI 1 \"general_operand\" \"0\")\n-\t\t     (neg:HI (match_operand:HI 2 \"general_operand\" \"rm\"))))]\n-  \"\"\n-  \"shl.h %2,%0\")\n-\n-(define_expand \"lshrqi3\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"=g\")\n-\t(lshiftrt:QI (match_operand:QI 1 \"general_operand\" \"g\")\n-\t\t     (match_operand:QI 2 \"general_operand\" \"g\")))]\n-  \"\"\n-  \"\n-{\n-  if (GET_CODE (operands[2]) != CONST_INT)\n-    operands[2] = gen_rtx_NEG (QImode, negate_rtx (QImode, operands[2]));\n-}\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"=rm\")\n-\t(lshiftrt:QI (match_operand:QI 1 \"general_operand\" \"0\")\n-\t\t     (match_operand:QI 2 \"const_int_operand\" \"n\")))]\n-  \"\"\n-  \"shl.b %n2,%0\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"=rm\")\n-\t(lshiftrt:QI (match_operand:QI 1 \"general_operand\" \"0\")\n-\t\t     (neg:QI (match_operand:QI 2 \"general_operand\" \"rm\"))))]\n-  \"\"\n-  \"shl.b %2,%0\")\n-\f\n-;; rotate instructions\n-\n-(define_insn \"rotlsi3\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=rm\")\n-\t(rotate:SI (match_operand:SI 1 \"general_operand\" \"0\")\n-\t\t   (match_operand:SI 2 \"general_operand\" \"rmi\")))]\n-  \"\"\n-  \"rol.w %2,%0\")\n-\n-(define_insn \"rotlhi3\"\n-  [(set (match_operand:HI 0 \"general_operand\" \"=rm\")\n-\t(rotate:HI (match_operand:HI 1 \"general_operand\" \"0\")\n-\t\t   (match_operand:HI 2 \"general_operand\" \"rmi\")))]\n-  \"\"\n-  \"rol.h %2,%0\")\n-\n-(define_insn \"rotlqi3\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"=rm\")\n-\t(rotate:QI (match_operand:QI 1 \"general_operand\" \"0\")\n-\t\t   (match_operand:QI 2 \"general_operand\" \"rmi\")))]\n-  \"\"\n-  \"rol.b %2,%0\")\n-\n-(define_expand \"rotrsi3\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=rm\")\n-\t(rotatert:SI (match_operand:SI 1 \"general_operand\" \"0\")\n-\t\t     (match_operand:SI 2 \"general_operand\" \"rmi\")))]\n-  \"\"\n-  \" { operands[2] = negate_rtx (SImode, operands[2]); }\")\n-\n-(define_expand \"rotrhi3\"\n-  [(set (match_operand:HI 0 \"general_operand\" \"=rm\")\n-\t(rotatert:HI (match_operand:HI 1 \"general_operand\" \"0\")\n-\t\t     (match_operand:HI 2 \"general_operand\" \"rmi\")))]\n-  \"\"\n-  \" { operands[2] = negate_rtx (HImode, operands[2]); }\")\n-\n-(define_expand \"rotrqi3\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"=rm\")\n-\t(rotatert:QI (match_operand:QI 1 \"general_operand\" \"0\")\n-\t\t     (match_operand:QI 2 \"general_operand\" \"rmi\")))]\n-  \"\"\n-  \" { operands[2] = negate_rtx (QImode, operands[2]); }\")\n-\f\n-;; Special cases of bit-field insns which we should\n-;; recognize in preference to the general case.\n-;; These handle aligned 8-bit and 16-bit fields,\n-;; which can usually be done with move instructions.\n-\n-;; Should I add  mode_dependent_address_p ????\n-\n-(define_insn \"\"\n-  [(set (zero_extract:SI (match_operand:SI 0 \"register_operand\" \"+rm\")\n-\t\t\t (match_operand:SI 1 \"immediate_operand\" \"i\")\n-\t\t\t (match_operand:SI 2 \"immediate_operand\" \"i\"))\n-\t(match_operand:SI 3 \"general_operand\" \"rm\"))]\n-  \"TARGET_BITFIELD\n-   && GET_CODE (operands[1]) == CONST_INT\n-   && (INTVAL (operands[1]) == 8 || INTVAL (operands[1]) == 16)\n-   && GET_CODE (operands[2]) == CONST_INT\n-   && INTVAL (operands[2]) % INTVAL (operands[1]) == 0\n-   && (GET_CODE (operands[0]) != REG\n-       || ( INTVAL (operands[1]) + INTVAL (operands[2]) == 32))\"\n-  \"*\n-{\n-  if (GET_CODE (operands[3]) == MEM)\n-    operands[3] = adj_offsettable_operand (operands[3],\n-\t\t\t\t\t   (32 - INTVAL (operands[1])) / 8);\n-\n-  if (GET_CODE (operands[0]) == REG)\n-    {\n-      if (INTVAL (operands[1]) == 8)\n-\treturn \\\"movu %3.b,%0.w\\\";\n-      return \\\"movu %3.h,%0.w\\\";\n-    }\n-  else\n-    {\n-      operands[0]\n-\t= adj_offsettable_operand (operands[0], INTVAL (operands[2]) / 8);\n-      if (INTVAL (operands[1]) == 8)\n-\treturn \\\"mov.b %3,%0\\\";\n-      return \\\"mov.h %3,%0\\\";\n-    }\n-}\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=&r\")\n-\t(zero_extract:SI (match_operand:SI 1 \"register_operand\" \"rm\")\n-\t\t\t (match_operand:SI 2 \"immediate_operand\" \"i\")\n-\t\t\t (match_operand:SI 3 \"immediate_operand\" \"i\")))]\n-  \"TARGET_BITFIELD\n-   && GET_CODE (operands[2]) == CONST_INT\n-   && (INTVAL (operands[2]) == 8 || INTVAL (operands[2]) == 16)\n-   && GET_CODE (operands[3]) == CONST_INT\n-   && INTVAL (operands[3]) % INTVAL (operands[2]) == 0\"\n-  \"*\n-{\n-  if (!REG_P (operands[1]))\n-    operands[1]\n-      = adj_offsettable_operand (operands[1], INTVAL (operands[3]) / 8);\n-\n-  if (REG_P (operands[0]))\n-    {\n-      if (REG_P (operands[1]))\n-\t{\n-\t  if (INTVAL (operands[2]) == 8)\n-\t    {\t\t\t/* width == 8 */\n-\t      switch (INTVAL (operands[3]))\n-\t\t{\n-\t\tcase 0:\n-\t\t  return \\\"mov.w %1,%0;shl.w #-24,%0\\\";\n-\t\t  break;\n-\t\tcase 8:\n-\t\t  return \\\"mov.w %1,%0;shl.w #8,%0;shl.w #-24,%0\\\";\n-\t\t  break;\n-\t\tcase 16:\n-\t\t  return \\\"mov.w %1,%0;shl.w #16,%0;shl.w #-24,%0\\\";\n-\t\t  break;\n-\t\tcase 24:\n-\t\t  return \\\"movu %1.b,%0.w\\\";\n-\t\t  break;\n-\t\tdefault:\n-\t\t  myabort (2);\n-\t\t}\n-\t    }\n-\t  else\n-\t    {\n-\t      switch (INTVAL (operands[3]))\n-\t\t{\n-\t\tcase 0:\n-\t\t  return \\\"mov.w %1,%0;shl.w #-16,%0\\\";\n-\t\t  break;\n-\t\tcase 16:\n-\t\t  return \\\"movu %1.h,%0.w\\\";\n-\t\t  break;\n-\t\tdefault:\n-\t\t  myabort (3);\n-\t\t}\n-\t    }\n-\t}\n-      else\n-\t{\n-\t  if (INTVAL (operands[2]) == 8)\n-\t    return \\\"movu %1.h,%0.w\\\";\n-\t  else\n-\t    return \\\"movu %1.b,%0.w\\\";\n-\t}\n-    }\n-  else\n-    {\t\t\t\t/* op[0] == MEM */\n-      if (INTVAL (operands[2]) == 8)\n-\treturn \\\"movu %1.b,%0.w\\\";\n-      return \\\"movu %1.h,%0.w\\\";\n-    }\n-}\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=r\")\n-\t(sign_extract:SI (match_operand:SI 1 \"register_operand\" \"ro\")\n-\t\t\t (match_operand:SI 2 \"immediate_operand\" \"i\")\n-\t\t\t (match_operand:SI 3 \"immediate_operand\" \"i\")))]\n-  \"TARGET_BITFIELD\n-   && GET_CODE (operands[2]) == CONST_INT\n-   && (INTVAL (operands[2]) == 8 || INTVAL (operands[2]) == 16)\n-   && GET_CODE (operands[3]) == CONST_INT\n-   && INTVAL (operands[3]) % INTVAL (operands[2]) == 0\"\n-  \"*\n-{\n-  if (!REG_P (operands[1]))\n-    operands[1]\n-      = adj_offsettable_operand (operands[1], INTVAL (operands[3]) / 8);\n-\n-  if (REG_P (operands[0]))\n-    {\n-      if (REG_P (operands[1]))\n-\t{\n-\t  if (INTVAL (operands[2]) == 8)\n-\t    {\t\t\t/* width == 8 */\n-\t      switch (INTVAL (operands[3]))\n-\t\t{\n-\t\tcase 0:\n-\t\t  return \\\"mov.w %1,%0;sha.w #-24,%0\\\";\n-\t\t  break;\n-\t\tcase 8:\n-\t\t  return \\\"mov.w %1,%0;shl.w #8,%0;sha.w #-24,%0\\\";\n-\t\t  break;\n-\t\tcase 16:\n-\t\t  return \\\"mov.w %1,%0;shl.w #16,%0;sha.w #-24,%0\\\";\n-\t\t  break;\n-\t\tcase 24:\n-\t\t  return \\\"mov %1.b,%0.w\\\";\n-\t\t  break;\n-\t\tdefault:\n-\t\t  myabort (4);\n-\t\t}\n-\t    }\n-\t  else\n-\t    {\n-\t      switch (INTVAL (operands[3]))\n-\t\t{\n-\t\tcase 0:\n-\t\t  return \\\"mov.w %1,%0;sha.w #-16,%0\\\";\n-\t\t  break;\n-\t\tcase 16:\n-\t\t  return \\\"mov %1.h,%0.w\\\";\n-\t\t  break;\n-\t\tdefault:\n-\t\t  myabort (5);\n-\t\t}\n-\t    }\n-\t}\n-      else\n-\t{\n-\t  if (INTVAL (operands[2]) == 8)\n-\t    return \\\"mov %1.h,%0.w\\\";\n-\t  else\n-\t    return \\\"mov %1.b,%0.w\\\";\n-\t}\n-    }\n-  else\n-    {\t\t\t\t/* op[0] == MEM */\n-      if (INTVAL (operands[2]) == 8)\n-\treturn \\\"mov %1.b,%0.w\\\";\n-      return \\\"mov %1.h,%0.w\\\";\n-    }\n-}\")\n-\f\n-;; Bit field instructions, general cases.\n-;; \"o,d\" constraint causes a nonoffsettable memref to match the \"o\"\n-;; so that its address is reloaded.\n-\n-;; extv dest:SI src(:QI/:SI) width:SI pos:SI\n-;;        r.w    m            r.w/#    rmi  \n-;;        %0     %1           %2       %3\n-\n-(define_expand \"extv\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"\")\n-\t(sign_extract:SI (match_operand:SI 1 \"general_operand\" \"\")\n-\t\t\t (match_operand:SI 2 \"general_operand\" \"\")\n-\t\t\t (match_operand:SI 3 \"general_operand\" \"\")))]\n-  \"TARGET_BITFIELD\"\n-  \"\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=r\")\n-\t(sign_extract:SI (match_operand:QI 1 \"memory_operand\" \"m\")\n-\t\t\t (match_operand:SI 2 \"general_operand\" \"ri\")\n-\t\t\t (match_operand:SI 3 \"general_operand\" \"rmi\")))]\n-  \"TARGET_BITFIELD\"\n-  \"bfext %3,%2,%1,%0\")\n-\n-\n-(define_expand \"extzv\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"\")\n-\t(zero_extract:SI (match_operand:SI 1 \"general_operand\" \"\")\n-\t\t\t (match_operand:SI 2 \"general_operand\" \"\")\n-\t\t\t (match_operand:SI 3 \"general_operand\" \"\")))]\n-  \"TARGET_BITFIELD\"\n-  \"\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=r\")\n-\t(zero_extract:SI (match_operand:QI 1 \"memory_operand\" \"m\")\n-\t\t\t (match_operand:SI 2 \"general_operand\" \"ri\")\n-\t\t\t (match_operand:SI 3 \"general_operand\" \"rmi\")))]\n-  \"TARGET_BITFIELD\"\n-  \"bfextu %3,%2,%1,%0\")\n-\n-;; There is no insn on the Gmicro to NOT/SET/CLR bitfield.\n-\n-\n-;; insv dest(BF):QI/SI  width:SI  pos:SI  src:SI\n-;;        m                r.w      rmi     r.w/i\n-;;        0                1        2       3\n-\n-\n-(define_expand \"insv\"\n-  [(set (zero_extract:SI (match_operand:SI 0 \"general_operand\" \"\")\n-\t\t\t (match_operand:SI 1 \"general_operand\" \"\")\n-\t\t\t (match_operand:SI 2 \"general_operand\" \"\"))\n-\t(match_operand:SI 3 \"general_operand\" \"\"))]\n-  \"TARGET_BITFIELD\"\n-  \"\")\n-\n-(define_insn \"\"\n-  [(set (zero_extract:SI (match_operand:QI 0 \"memory_operand\" \"+m,m\")\n-\t\t\t (match_operand:SI 1 \"general_operand\" \"r,i\")\n-\t\t\t (match_operand:SI 2 \"general_operand\" \"rmi,i\"))\n-\t(match_operand:SI 3 \"general_operand\" \"ri,ri\"))]\n-  \"TARGET_BITFIELD\"\n-  \"bfinsu %3,%2,%1,%0\")\n-\n-;;; bfins/bfinsu ????????\n-\n-;; == == == == == == == == == == == == == \n-\n-;; Now recognize bit field insns that operate on registers\n-;; (or at least were intended to do so).\n-\n-;; On the Gmicro/300,\n-;; bitfield instructions are not applicable to registers ;-<\n-;; But I write the register cases, because without them the gcc\n-;; seems to use \"and\" instruction with some other instructions\n-;; instead of using a shift instruction.\n-;; It is because on many processors shift instructions are slower.\n-;; On the Gmicro/300 which has a barrel shifter,\n-;; it is faster to use a shift instruction.\n-;;\n-;; Restricts width and offset to be immediates.\n-;;\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=r\")\n-\t(sign_extract:SI (match_operand:SI 1 \"register_operand\" \"r\")\n-\t\t\t (match_operand:SI 2 \"immediate_operand\" \"i\")\n-\t\t\t (match_operand:SI 3 \"immediate_operand\" \"i\")))]\n-  \"TARGET_BITFIELD\"\n-  \"*\n-{\n-  if (REGNO (operands[0]) != REGNO (operands[1]))\n-    output_asm_insn (\\\"mov.w %1,%0\\\", operands);\n-  if (INTVAL (operands[3]) != 0)\n-    output_asm_insn (\\\"shl.w %3,%0\\\", operands);\n-  operands[2] = GEN_INT (-(32 - INTVAL (operands[2])));\n-  return \\\"sha.w %3,%0\\\";\n-}\")\n-    \n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=r\")\n-\t(zero_extract:SI (match_operand:SI 1 \"register_operand\" \"r\")\n-\t\t\t (match_operand:SI 2 \"immediate_operand\" \"i\")\n-\t\t\t (match_operand:SI 3 \"immediate_operand\" \"i\")))]\n-  \"TARGET_BITFIELD\"\n-  \"*\n-{\n-  if (REGNO (operands[0]) != REGNO (operands[1]))\n-    output_asm_insn (\\\"mov.w %1,%0\\\", operands);\n-  if (INTVAL (operands[3]) != 0)\n-    output_asm_insn (\\\"shl.w %3,%0\\\", operands);\n-  operands[2] = GEN_INT (- (32 - INTVAL (operands[2])));\n-  return \\\"shl.w %3,%0\\\";\n-}\")\n-\n-\n-;; There are more descriptions for m68k, but not yet for the Gmicro.\n-;;\n-\f\n-;; Basic conditional jump instructions.\n-\n-\n-(define_insn \"beq\"\n-  [(set (pc)\n-\t(if_then_else (eq (cc0)\n-\t\t\t  (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"*\n-{\n-  OUTPUT_JUMP (\\\"beq %b0\\\", \\\"fbeq %b0\\\", \\\"beq %b0\\\");\n-}\")\n-\n-(define_insn \"bne\"\n-  [(set (pc)\n-\t(if_then_else (ne (cc0)\n-\t\t\t  (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"*\n-{\n-  OUTPUT_JUMP (\\\"bne %b0\\\", \\\"fbne %b0\\\", \\\"bne %b0\\\");\n-}\")\n-\n-(define_insn \"bgt\"\n-  [(set (pc)\n-\t(if_then_else (gt (cc0)\n-\t\t\t  (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"*\n-  OUTPUT_JUMP (\\\"bgt %b0\\\", \\\"fbgt %b0\\\", 0);\n-\")\n-\n-(define_insn \"bgtu\"\n-  [(set (pc)\n-\t(if_then_else (gtu (cc0)\n-\t\t\t   (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"bgt %b0\")\n-\n-(define_insn \"blt\"\n-  [(set (pc)\n-\t(if_then_else (lt (cc0)\n-\t\t\t  (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"*\n-  OUTPUT_JUMP (\\\"blt %b0\\\", \\\"fblt %b0\\\", \\\"bms %b0\\\");\n-\")\n-\n-;; bms ?????\n-;; \n-\n-(define_insn \"bltu\"\n-  [(set (pc)\n-\t(if_then_else (ltu (cc0)\n-\t\t\t   (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"blt %b0\")\n-\n-(define_insn \"bge\"\n-  [(set (pc)\n-\t(if_then_else (ge (cc0)\n-\t\t\t  (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"*\n-  OUTPUT_JUMP (\\\"bge %b0\\\", \\\"fbge %b0\\\", \\\"bmc %b0\\\");\n-\")\n-\n-;; bmc ??\n-\n-(define_insn \"bgeu\"\n-  [(set (pc)\n-\t(if_then_else (geu (cc0)\n-\t\t\t   (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"bge %b0\")\n-\n-(define_insn \"ble\"\n-  [(set (pc)\n-\t(if_then_else (le (cc0)\n-\t\t\t  (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"ble %b0\")\n-\n-(define_insn \"bleu\"\n-  [(set (pc)\n-\t(if_then_else (leu (cc0)\n-\t\t\t   (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"ble %b0\")\n-\f\n-;; Negated conditional jump instructions.\n-\n-(define_insn \"\"\n-  [(set (pc)\n-\t(if_then_else (eq (cc0)\n-\t\t\t  (const_int 0))\n-\t\t      (pc)\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n-  \"\"\n-  \"*\n-{\n-  OUTPUT_JUMP (\\\"bne %b0\\\", \\\"fbne %b0\\\", \\\"bne %b0\\\");\n-}\")\n-\n-(define_insn \"\"\n-  [(set (pc)\n-\t(if_then_else (ne (cc0)\n-\t\t\t  (const_int 0))\n-\t\t      (pc)\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n-  \"\"\n-  \"*\n-{\n-  OUTPUT_JUMP (\\\"beq %b0\\\", \\\"fbeq %b0\\\", \\\"beq %b0\\\");\n-}\")\n-\n-(define_insn \"\"\n-  [(set (pc)\n-\t(if_then_else (gt (cc0)\n-\t\t\t  (const_int 0))\n-\t\t      (pc)\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n-  \"\"\n-  \"*\n-  OUTPUT_JUMP (\\\"ble %b0\\\", \\\"fbngt %b0\\\", 0);\n-\")\n-;; fbngt ???\n-\n-(define_insn \"\"\n-  [(set (pc)\n-\t(if_then_else (gtu (cc0)\n-\t\t\t   (const_int 0))\n-\t\t      (pc)\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n-  \"\"\n-  \"ble %b0\")\n-\n-(define_insn \"\"\n-  [(set (pc)\n-\t(if_then_else (lt (cc0)\n-\t\t\t  (const_int 0))\n-\t\t      (pc)\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n-  \"\"\n-  \"*\n-  OUTPUT_JUMP (\\\"bge %b0\\\", \\\"fbnlt %b0\\\", \\\"jbmc %b0\\\");\n-\")\n-\n-(define_insn \"\"\n-  [(set (pc)\n-\t(if_then_else (ltu (cc0)\n-\t\t\t   (const_int 0))\n-\t\t      (pc)\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n-  \"\"\n-  \"blt %b0\")\n-\n-(define_insn \"\"\n-  [(set (pc)\n-\t(if_then_else (ge (cc0)\n-\t\t\t  (const_int 0))\n-\t\t      (pc)\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n-  \"\"\n-  \"*\n-  OUTPUT_JUMP (\\\"blt %b0\\\", \\\"fbnge %b0\\\", \\\"jbms %b0\\\");\n-\")\n-\n-(define_insn \"\"\n-  [(set (pc)\n-\t(if_then_else (geu (cc0)\n-\t\t\t   (const_int 0))\n-\t\t      (pc)\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n-  \"\"\n-  \"blt %b0\")\n-;; ????\n-\n-(define_insn \"\"\n-  [(set (pc)\n-\t(if_then_else (le (cc0)\n-\t\t\t  (const_int 0))\n-\t\t      (pc)\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n-  \"\"\n-  \"*\n-  OUTPUT_JUMP (\\\"bgt %b0\\\", \\\"fbnle %b0\\\", 0);\n-\")\n-\n-(define_insn \"\"\n-  [(set (pc)\n-\t(if_then_else (leu (cc0)\n-\t\t\t   (const_int 0))\n-\t\t      (pc)\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n-  \"\"\n-  \"bgt %b0\")\n-\f\n-;; Unconditional and other jump instructions\n-(define_insn \"jump\"\n-  [(set (pc)\n-\t(label_ref (match_operand 0 \"\" \"\")))]\n-  \"\"\n-  \"bra %b0\")\n-\n-(define_insn \"tablejump\"\n-  [(set (pc)\n-\t(plus:SI (pc) (match_operand:SI 0 \"general_operand\" \"r\")))\n-   (use (label_ref (match_operand 1 \"\" \"\")))]\n-  \"\"\n-  \"jmp @(pc:b,4:4,%0)\")\n-\n-;;\n-;; Should Add code for \"ACB\", \"SCB\". !!! ????\n-;; See m68k.h (dbra)\n-;;\n-\n-;; Call subroutine with no return value.\n-(define_insn \"call\"\n-  [(call (match_operand:QI 0 \"general_operand\" \"m\")\n-\t (match_operand:SI 1 \"general_operand\" \"rmi\"))]\n-  ;; Operand 1 not really used on the Gmicro.\n-\n-  \"\"\n-  \"*\n-{\n-  if (GET_CODE (operands[0]) == MEM\n-      && GET_CODE (XEXP (operands[0],0)) == SYMBOL_REF)\n-    return \\\"bsr %b0\\\";\n-  return \\\"jsr %0\\\";\n-}\")\n-\n-;; Call subroutine, returning value in operand 0\n-;; (which must be a hard register).\n-(define_insn \"call_value\"\n-  [(set (match_operand 0 \"\" \"=rf\")\n-\t(call (match_operand:QI 1 \"general_operand\" \"m\")\n-\t      (match_operand:SI 2 \"general_operand\" \"rmi\")))]\n-  ;; Operand 2 not really used on the Gmicro.\n-  \"\"\n-  \"*\n-{\n-  if (GET_CODE (operands[1]) == MEM\n-      && GET_CODE (XEXP (operands[1],0)) == SYMBOL_REF)\n-    return \\\"bsr %b1\\\";\n-  return \\\"jsr %1\\\";\n-}\")\n-\n-;; Call subroutine returning any type.\n-\n-(define_expand \"untyped_call\"\n-  [(parallel [(call (match_operand 0 \"\" \"\")\n-\t\t    (const_int 0))\n-\t      (match_operand 1 \"\" \"\")\n-\t      (match_operand 2 \"\" \"\")])]\n-  \"\"\n-  \"\n-{\n-  int i;\n-\n-  emit_call_insn (gen_call (operands[0], const0_rtx, NULL, const0_rtx));\n-\n-  for (i = 0; i < XVECLEN (operands[2], 0); i++)\n-    {\n-      rtx set = XVECEXP (operands[2], 0, i);\n-      emit_move_insn (SET_DEST (set), SET_SRC (set));\n-    }\n-\n-  /* The optimizer does not know that the call sets the function value\n-     registers we stored in the result block.  We avoid problems by\n-     claiming that all hard registers are used and clobbered at this\n-     point.  */\n-  emit_insn (gen_blockage ());\n-\n-  DONE;\n-}\")\n-\n-;; UNSPEC_VOLATILE is considered to use and clobber all hard registers and\n-;; all of memory.  This blocks insns from being moved across this point.\n-\n-(define_insn \"blockage\"\n-  [(unspec_volatile [(const_int 0)] 0)]\n-  \"\"\n-  \"\")\n-\n-(define_insn \"nop\"\n-  [(const_int 0)]\n-    \"\"\n-    \"nop\")\n-\f\n-;; Turned off because the general move-an-address pattern handles it.\n-;; \n-;; Thus goes after the move instructions\n-;; because the move instructions are better (require no spilling)\n-;; when they can apply. \n-;; After add/sub now !!\n-\n-;(define_insn \"pushasi\"\n-;  [(set (match_operand:SI 0 \"push_operand\" \"=m\")\n-;\t(match_operand:SI 1 \"address_operand\" \"p\"))]\n-;  \"\"\n-;  \"*\n-;{\n-;  if (GET_CODE (operands[1]) == CONST_INT)\n-;    return push_imm_word (INTVAL (operands[1]), operands[0]);\n-;  if (CONSTANT_P (operands[1]))\n-;    return \\\"mov.w %1,%-\\\";\n-;  if (GET_CODE (operands[1]) == REG)\n-;    return \\\"mov.w %1,%-\\\";\n-;  else if (GET_CODE (operands[1]) == MEM)\n-;    {\n-;      return \\\"mov.w %1,%-\\\";\n-;    }\n-;  else\n-;    return \\\"mova.w %p1,%-\\\";\n-;}\")\n-\f\n-;; This should not be used unless the add/sub insns can't be.\n-\n-/* mova.[whq] 89.08.11 for test M.Yuhara */\n-;(define_insn \"\"\n-;  [(set (match_operand:SI 0 \"general_operand\" \"=rm\")\n-;\t(match_operand:SI 1 \"address_operand\" \"p\"))]\n-;  \"\"\n-;  \"*\n-;{\n-;    if (GET_CODE (operands[1]) == CONST_INT)\n-;        return mov_imm_word (INTVAL (operands[1]), operands[0]);\n-;    if (CONSTANT_P (operands[1]))\n-;        return \\\"mov.w %1,%0\\\";\n-;    if (GET_CODE (operands[1]) == REG)\n-;        return \\\"mov.w %1,%0\\\";\n-;    else  if (GET_CODE (operands[1]) == MEM) {\n-;\toperands[1] = XEXP (operands[1],0);\n-;        return \\\"mov.w %1,%0\\\";\n-;    }\n-;    else\n-;        return \\\"mova.w %p1,%0\\\";\n-;}\")\n-\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=rm\")\n-\t(match_operand:HI 1 \"address_operand\" \"p\"))]\n-  \"\"\n-  \"*\n-{\n-  if (GET_CODE (operands[1]) == CONST_INT)\n-    return mov_imm_word (INTVAL (operands[1]), operands[0]);\n-  if (CONSTANT_P (operands[1]))\n-    return \\\"mov.w %1,%0\\\";\n-  if (GET_CODE (operands[1]) == REG)\n-    return \\\"mov.w %1,%0\\\";\n-  else  if (GET_CODE (operands[1]) == MEM)\n-    {\n-      operands[1] = XEXP (operands[1],0);\n-      return \\\"mov.w %1,%0\\\";\t/* OK ? */\n-    }\n-  else\n-    return \\\"mova.w %p1,%0\\\";\n-}\")\n-\n-;(define_insn \"\"\n-;  [(set (match_operand:SI 0 \"general_operand\" \"=rm\")\n-;\t(match_operand:QI 1 \"address_operand\" \"p\"))]\n-;  \"\"\n-;  \"*\n-;{\n-;  if (push_operand (operands[0], SImode))\n-;    return \\\"mova %1,%-\\\";\n-;  return \\\"mova %1,%0\\\";\n-;}\")\n-\n-;(define_insn \"\"\n-;  [(set (match_operand:SI 0 \"general_operand\" \"=rm\")\n-;\t(match_operand:QI 1 \"address_operand\" \"p\"))]\n-;  \"\"\n-;  \"*\n-;{\n-;  if (CONSTANT_P (operands[1]))\n-;    return \\\"mov.w %1,%0\\\";\n-;  else if (GET_CODE (operands[1]) == REG)\n-;    return \\\"mov.w %1,%0\\\";\n-;  else if (GET_CODE (operands[1]) == MEM)\n-;    {\n-;      operands[1] = XEXP (operands[1],0);\n-;      return \\\"mov.w %1,%0 ; OK?\\\";\n-;    }\n-;  else if (GET_CODE (operands[0]) == REG\n-;\t   && GET_CODE (operands[1]) == PLUS)\n-;    {\n-;      rtx xreg, xdisp;\n-;\n-;      if (GET_CODE (XEXP (operands[1], 0)) == REG \n-;\t  && REGNO (XEXP (operands[1], 0)) == REGNO (operands[0]))\n-;\t{\n-;\t  xreg = XEXP (operands[1], 0);\n-;\t  xdisp = XEXP (operands[1],1);\n-;\t}\n-;      else\n-;\t{\n-;\t  xreg = XEXP (operands[1], 1);\n-;\t  xdisp = XEXP (operands[1],0);\n-;\t}\n-;\n-;      if (GET_CODE (xreg) == REG\n-;\t  && REGNO (xreg) == REGNO (operands[0])\n-;\t  && (CONSTANT_P (xdisp) || GET_CODE (xdisp) == REG))\n-;\t{\n-;\t  operands[1] = xdisp;\n-;\t  if (CONSTANT_P (xdisp))\n-;\t    return add_imm_word (INTVAL (xdisp), xreg, &operands[1]);\n-;\t  else\n-;\t    return \\\"add.w %1,%0\\\";\n-;\t}\n-;    }\n-;  return \\\"mova.w %p1,%0\\\";\n-;}\")\n-\f\n-;; This is the first machine-dependent peephole optimization.\n-;; It is useful when a floating value is returned from a function call\n-;; and then is moved into an FP register.\n-;; But it is mainly intended to test the support for these optimizations.\n-\n-(define_peephole\n-  [(set (reg:SI 15) (plus:SI (reg:SI 15) (const_int 4)))\n-   (set (match_operand:DF 0 \"register_operand\" \"=f\")\n-\t(match_operand:DF 1 \"register_operand\" \"r\"))]\n-  \"FPU_REG_P (operands[0]) && ! FPU_REG_P (operands[1])\"\n-  \"*\n-{\n-  rtx xoperands[2];\n-  xoperands[1] = gen_rtx_REG (SImode, REGNO (operands[1]) + 1);\n-  output_asm_insn (\\\"mov.w %1,@sp\\\", xoperands);\n-  output_asm_insn (\\\"mov.w %1,%-\\\", operands);\n-  return \\\"fmov.d %+,%0\\\";\n-}\n-\")"}, {"sha": "ac84cfcb90c15be2f7c45b1957249573bf36e4a8", "filename": "gcc/config/ns32k/genix.h", "status": "removed", "additions": 0, "deletions": 167, "changes": 167, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7b4171a5b8a655097812307bbe261032dfbe366/gcc%2Fconfig%2Fns32k%2Fgenix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7b4171a5b8a655097812307bbe261032dfbe366/gcc%2Fconfig%2Fns32k%2Fgenix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fns32k%2Fgenix.h?ref=a7b4171a5b8a655097812307bbe261032dfbe366", "patch": "@@ -1,167 +0,0 @@\n-/* Definitions of target machine for GNU compiler.  Genix ns32000 version.\n-   Copyright (C) 1987, 1988, 1994 Free Software Foundation, Inc.\n-\n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-#include \"ns32k/encore.h\"\n-\n-/* We don't want the one Encore needs.  */\n-#undef ASM_SPEC\n-\n-/* The following defines override ones in ns32k.h and prevent any attempts\n-   to explicitly or implicitly make references to the SB register in the GCC\n-   generated code.  It is necessary to avoid such references under Genix V.3.1\n-   because this OS doesn't even save/restore the SB on context switches!  */\n-\n-#define IS_OK_REG_FOR_BASE_P(X)\t\t\t\t\t\t\\\n-  ( (GET_CODE (X) == REG) && REG_OK_FOR_BASE_P (X) )\n-\n-#undef INDIRECTABLE_1_ADDRESS_P\n-#define INDIRECTABLE_1_ADDRESS_P(X)\t\t\t\t\t\\\n-  (CONSTANT_ADDRESS_NO_LABEL_P (X)\t\t\t\t\t\\\n-   || IS_OK_REG_FOR_BASE_P (X)\t\t\t\t\t\t\\\n-   || (GET_CODE (X) == PLUS\t\t\t\t\t\t\\\n-       && IS_OK_REG_FOR_BASE_P (XEXP (X, 0))\t\t\t\t\\\n-       && CONSTANT_ADDRESS_P (XEXP (X, 1))  )  )\n-\n-/* Note that for double indirects, only FP, SP, and SB are allowed\n-   as the inner-most base register.  But we are avoiding use of SB.  */\n-\n-#undef MEM_REG\n-#define MEM_REG(X)\t\t\t\t\t\t\t\\\n-  ( (GET_CODE (X) == REG)\t\t\t\t\t\t\\\n-  && ( (REGNO (X) == FRAME_POINTER_REGNUM)\t\t\t\t\\\n-    || (REGNO (X) == STACK_POINTER_REGNUM) ) )\n-\n-#undef INDIRECTABLE_2_ADDRESS_P\n-#define INDIRECTABLE_2_ADDRESS_P(X)\t\t\t\t\t\\\n-  (GET_CODE (X) == MEM\t\t\t\t\t\t\t\\\n-   && (((xfoo0 = XEXP (X, 0), MEM_REG (xfoo0))\t\t\t\t\\\n-       || (GET_CODE (xfoo0) == PLUS\t\t\t\t\t\\\n-\t   && MEM_REG (XEXP (xfoo0, 0))\t\t\t\t\t\\\n-\t   && CONSTANT_ADDRESS_NO_LABEL_P (XEXP (xfoo0, 1))))\t\t\\\n-       || CONSTANT_ADDRESS_NO_LABEL_P (xfoo0)))\n-\n-/* Go to ADDR if X is a valid address not using indexing.\n-   (This much is the easy part.)  */\n-#undef GO_IF_NONINDEXED_ADDRESS\n-#define GO_IF_NONINDEXED_ADDRESS(X, ADDR)\t\t\t\t\\\n-{ register rtx xfoob = (X);\t\t\t\t\t\t\\\n-  if (GET_CODE (xfoob) == REG) goto ADDR;\t\t\t\t\\\n-  if (INDIRECTABLE_1_ADDRESS_P(X)) goto ADDR;\t\t\t\t\\\n-  if (CONSTANT_P(X)) goto ADDR;\t\t\t\t\t\t\\\n-  if (INDIRECTABLE_2_ADDRESS_P (X)) goto ADDR;\t\t\t\t\\\n-  if (GET_CODE (X) == PLUS)\t\t\t\t\t\t\\\n-    if (CONSTANT_ADDRESS_NO_LABEL_P (XEXP (X, 1)))\t\t\t\\\n-      if (INDIRECTABLE_2_ADDRESS_P (XEXP (X, 0)))\t\t\t\\\n-\tgoto ADDR;\t\t\t\t\t\t\t\\\n-}\n-\n-/* A bug in the GNX 3.X assembler causes references to external symbols to\n-   be mishandled if the symbol is also used as the name of a function-local\n-   variable or as the name of a struct or union field.  The problem only\n-   appears when you are also using the -g option so that SDB debugging\n-   directives are also being produced by GCC.  In such cases, the assembler\n-   gets the external entity confused with the local entity and addressing\n-   havoc ensues.  The solution is to get GCC to produce .global directives\n-   for all external entities which are actually referenced within the current\n-   source file.  The following macro does this.  */\n-\n-#define ASM_OUTPUT_EXTERNAL(FILE, DECL, NAME)\t\t\t\t\\\n-    ASM_GLOBALIZE_LABEL(FILE,NAME);\n-\n-/* Genix wants 0l instead of 0f.  */\n-\n-#undef ASM_OUTPUT_DOUBLE\n-#define ASM_OUTPUT_DOUBLE(FILE,VALUE)\t\t\t\t\\\n- fprintf (FILE, \"\\t.long 0l%.20e\\n\", (VALUE))\n-\n-/*  A bug in the GNX 3.X linker prevents symbol-table entries with a storage-\n-    class field of C_EFCN (-1) from being accepted. */\n-\n-#ifdef PUT_SDB_EPILOGUE_END\n-#undef PUT_SDB_EPILOGUE_END\n-#endif\n-#define PUT_SDB_EPILOGUE_END(NAME)\n-\n-#undef TARGET_VERSION\n-#define TARGET_VERSION fprintf (stderr, \" (32000, National syntax)\");\n-\n-/* Same as the encore definition except\n-   * Different syntax for double constants.\n-   * Don't output `?' before external regs.\n-   * Output `(sb)' in certain indirect refs.  */\n-\n-#error this has not been updated since version 1.\n-#error it is certainly wrong.\n-\n-#undef PRINT_OPERAND\n-#define PRINT_OPERAND(FILE, X, CODE)\t\t\t\t\t\\\n-{ if (CODE == '$') putc ('$', FILE);\t\t\t\t\t\\\n-  else if (CODE == '?');\t\t\t\t\t\t\\\n-  else if (GET_CODE (X) == REG)\t\t\t\t\t\t\\\n-    fprintf (FILE, \"%s\", reg_names[REGNO (X)]);\t\t\t\t\\\n-  else if (GET_CODE (X) == MEM)\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      rtx xfoo;\t\t\t\t\t\t\t\t\\\n-      xfoo = XEXP (X, 0);\t\t\t\t\t\t\\\n-      switch (GET_CODE (xfoo))\t\t\t\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\tcase MEM:\t\t\t\t\t\t\t\\\n-\t  if (GET_CODE (XEXP (xfoo, 0)) == REG)\t\t\t\t\\\n-\t    if (REGNO (XEXP (xfoo, 0)) == STACK_POINTER_REGNUM)\t\t\\\n-\t      fprintf (FILE, \"0(0(sp))\");\t\t\t\t\\\n-\t    else fprintf (FILE, \"0(0(%s))\",\t\t\t\t\\\n-\t\t\t  reg_names[REGNO (XEXP (xfoo, 0))]);\t\t\\\n-\t  else\t\t\t\t\t\t\t\t\\\n-\t    {\t\t\t\t\t\t\t\t\\\n-\t      extern int paren_base_reg_printed;\t\t\t\\\n-\t      fprintf (FILE, \"0(\");\t\t\t\t\t\\\n-\t      paren_base_reg_printed = 0;\t\t\t\t\\\n-\t      output_address (xfoo);\t\t\t\t\t\\\n-\t      if (!paren_base_reg_printed)\t\t\t\t\\\n-\t\tfprintf (FILE, \"(sb)\");\t\t\t\t\t\\\n-\t      putc (')', FILE);\t\t\t\t\t\t\\\n-\t    }\t\t\t\t\t\t\t\t\\\n-\t  break;\t\t\t\t\t\t\t\\\n-\tcase REG:\t\t\t\t\t\t\t\\\n-\t  fprintf (FILE, \"0(%s)\", reg_names[REGNO (xfoo)]);\t\t\\\n-\t  break;\t\t\t\t\t\t\t\\\n-\tcase PRE_DEC:\t\t\t\t\t\t\t\\\n-\tcase POST_INC:\t\t\t\t\t\t\t\\\n-\t  fprintf (FILE, \"tos\");\t\t\t\t\t\\\n-\t  break;\t\t\t\t\t\t\t\\\n-\tcase CONST_INT:\t\t\t\t\t\t\t\\\n-\t  fprintf (FILE, \"@%d\", INTVAL (xfoo));\t\t\t\t\\\n-\t  break;\t\t\t\t\t\t\t\\\n-\tdefault:\t\t\t\t\t\t\t\\\n-\t  output_address (xfoo);\t\t\t\t\t\\\n-\t  break;\t\t\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-  else if (GET_CODE (X) == CONST_DOUBLE && GET_MODE (X) != VOIDmode)\t\\\n-    if (GET_MODE (X) == DFmode)\t\t\t\t\t\t\\\n-      { union { double d; int i[2]; } u;\t\t\t\t\\\n-        u.i[0] = CONST_DOUBLE_LOW (X); u.i[1] = CONST_DOUBLE_HIGH (X);\t\\\n-\tfprintf (FILE, \"$0l%.20e\", u.d); }\t\t\t\t\\\n-    else { union { double d; int i[2]; } u;\t\t\t\t\\\n-\t   u.i[0] = CONST_DOUBLE_LOW (X); u.i[1] = CONST_DOUBLE_HIGH (X); \\\n-\t   fprintf (FILE, \"$0f%.20e\", u.d); }\t\t\t\t\\\n-  else if (GET_CODE (X) == CONST)\t\t\t\t\t\\\n-    output_addr_const (FILE, X);\t\t\t\t\t\\\n-  else { putc ('$', FILE); output_addr_const (FILE, X); }}"}, {"sha": "0598df8a193be75e977d598580dc65c13294a813", "filename": "gcc/config/ns32k/x-genix", "status": "removed", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7b4171a5b8a655097812307bbe261032dfbe366/gcc%2Fconfig%2Fns32k%2Fx-genix", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7b4171a5b8a655097812307bbe261032dfbe366/gcc%2Fconfig%2Fns32k%2Fx-genix", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fns32k%2Fx-genix?ref=a7b4171a5b8a655097812307bbe261032dfbe366", "patch": "@@ -1,6 +0,0 @@\n-# Makefile modifications for compilation on Genix.\n-ALLOCA=alloca.o\n-MALLOC = malloc.o\n-\n-# You must get malloc.c and getpagesize.h from GNU Emacs.\n-"}, {"sha": "6749fee2e5d5d4aa44c27a0d7d8427ecc18ac519", "filename": "gcc/config/ns32k/xm-genix.h", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7b4171a5b8a655097812307bbe261032dfbe366/gcc%2Fconfig%2Fns32k%2Fxm-genix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7b4171a5b8a655097812307bbe261032dfbe366/gcc%2Fconfig%2Fns32k%2Fxm-genix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fns32k%2Fxm-genix.h?ref=a7b4171a5b8a655097812307bbe261032dfbe366", "patch": "@@ -1,7 +0,0 @@\n-/* Config file for ns32k running system V.  */\n-\n-#define memcpy(src,dst,len) bcopy ((dst),(src),(len))\n-#define memset gcc_memset\n-#define memcmp(left,right,len) bcmp ((left),(right),(len))\n-\n-#define USG"}, {"sha": "9c39e3f77e9381838872efdfa28853fc4c260438", "filename": "gcc/config/pyr/pyr.c", "status": "removed", "additions": 0, "deletions": 956, "changes": 956, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7b4171a5b8a655097812307bbe261032dfbe366/gcc%2Fconfig%2Fpyr%2Fpyr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7b4171a5b8a655097812307bbe261032dfbe366/gcc%2Fconfig%2Fpyr%2Fpyr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpyr%2Fpyr.c?ref=a7b4171a5b8a655097812307bbe261032dfbe366", "patch": "@@ -1,956 +0,0 @@\n-/* Subroutines for insn-output.c for Pyramid 90x, 9000, and MIServer Series.\n-   Copyright (C) 1989, 1991, 1997, 1998, 1999 Free Software Foundation, Inc.\n-\n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-/* Some output-actions in pyr.md need these.  */\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"rtl.h\"\n-#include \"regs.h\"\n-#include \"hard-reg-set.h\"\n-#include \"real.h\"\n-#include \"insn-config.h\"\n-#include \"conditions.h\"\n-#include \"insn-flags.h\"\n-#include \"output.h\"\n-#include \"insn-attr.h\"\n-#include \"tree.h\"\n-#include \"function.h\"\n-\n-/*\n- * Do FUNCTION_ARG.\n- * This cannot be defined as a macro on pyramids, because Pyramid Technology's\n- * C compiler dies on (several equivalent definitions of) this macro.\n- * The only way around this cc bug was to make this a function.\n- * While it would be possible to use a macro version for gcc, it seems\n- * more reliable to have a single version of the code.\n- */\n-void *\n-pyr_function_arg(cum, mode, type, named)\n-  CUMULATIVE_ARGS cum;\n-  enum machine_mode mode;\n-  tree type;\n-{\n-  return (void *)(FUNCTION_ARG_HELPER (cum, mode,type,named));\n-}\n-\f\n-/* Do the hard part of PARAM_SAFE_FOR_REG_P.\n- * This cannot be defined as a macro on pyramids, because Pyramid Technology's\n- * C compiler dies on (several equivalent definitions of) this macro.\n- * The only way around this cc bug was to make this a function.\n- */\n-int\n-inner_param_safe_helper (type)\n-    tree type;\n-{\n-  return (INNER_PARAM_SAFE_HELPER(type));\n-}\n-\f\n-\n-/* Return 1 if OP is a non-indexed operand of mode MODE.\n-   This is either a register reference, a memory reference,\n-   or a constant.  In the case of a memory reference, the address\n-   is checked to make sure it isn't indexed.\n-\n-   Register and memory references must have mode MODE in order to be valid,\n-   but some constants have no machine mode and are valid for any mode.\n-\n-   If MODE is VOIDmode, OP is checked for validity for whatever mode\n-   it has.\n-\n-   The main use of this function is as a predicate in match_operand\n-   expressions in the machine description.\n-\n-   It is  useful to compare this with general_operand().  They should\n-   be identical except for one line.\n-\n-   This function seems necessary because of the non-orthogonality of\n-   Pyramid insns.\n-   For any 2-operand insn, and any combination of operand modes,\n-   if indexing is valid for the isn's second operand, it is invalid\n-   for the first operand to be indexed. */\n-\n-extern int volatile_ok;\n-\n-int\n-nonindexed_operand (op, mode)\n-    register rtx op;\n-    enum machine_mode mode;\n-{\n-  register RTX_CODE code = GET_CODE (op);\n-  int mode_altering_drug = 0;\n-\n-  if (mode == VOIDmode)\n-    mode = GET_MODE (op);\n-\n-  /* Don't accept CONST_INT or anything similar\n-     if the caller wants something floating.  */\n-  if (GET_MODE (op) == VOIDmode && mode != VOIDmode\n-      && GET_MODE_CLASS (mode) != MODE_INT)\n-    return 0;\n-\n-  if (CONSTANT_P (op))\n-    return ((GET_MODE (op) == VOIDmode || GET_MODE (op) == mode)\n-\t    && LEGITIMATE_CONSTANT_P (op));\n-\n-  /* Except for certain constants with VOIDmode, already checked for,\n-     OP's mode must match MODE if MODE specifies a mode.  */\n-\n-  if (GET_MODE (op) != mode)\n-    return 0;\n-\n-  while (code == SUBREG)\n-    {\n-      op = SUBREG_REG (op);\n-      code = GET_CODE (op);\n-#if 0\n-      /* No longer needed, since (SUBREG (MEM...))\n-\t will load the MEM into a reload reg in the MEM's own mode.  */\n-      mode_altering_drug = 1;\n-#endif\n-    }\n-  if (code == REG)\n-    return 1;\n-  if (code == CONST_DOUBLE)\n-    return LEGITIMATE_CONSTANT_P (op);\n-  if (code == MEM)\n-    {\n-      register rtx y = XEXP (op, 0);\n-      if (! volatile_ok && MEM_VOLATILE_P (op))\n-\treturn 0;\n-    GO_IF_NONINDEXED_ADDRESS (y, win);\n-    }\n-  return 0;\n-\n- win:\n-  if (mode_altering_drug)\n-    return ! mode_dependent_address_p (XEXP (op, 0));\n-  return 1;\n-}\n-\n-/* Return non-zero if the rtx OP has an immediate component.  An\n-   immediate component or additive term equal to zero is rejected\n-   due to assembler problems.  */\n-\n-int\n-has_direct_base (op)\n-     rtx op;\n-{\n-  if ((CONSTANT_ADDRESS_P (op)\n-       && op != const0_rtx)\n-      || (GET_CODE (op) == PLUS\n-\t  && ((CONSTANT_ADDRESS_P (XEXP (op, 1))\n-\t       && XEXP (op, 1) != const0_rtx)\n-\t      || (CONSTANT_ADDRESS_P (XEXP (op, 0))\n-\t\t  && XEXP (op, 0) != const0_rtx))))\n-    return 1;\n-\n-  return 0;\n-}\n-\n-/* Return zero if the rtx OP has a (scaled) index.  */\n-\n-int\n-has_index (op)\n-     rtx op;\n-{\n-  if (GET_CODE (op) == PLUS\n-      && (GET_CODE (XEXP (op, 0)) == MULT\n-\t  || (GET_CODE (XEXP (op, 1)) == MULT)))\n-    return 1;\n-  else\n-    return 0;\n-}\n-\n-int swap_operands;\n-\n-/* weird_memory_memory -- return 1 if OP1 and OP2 can be compared (or\n-   exchanged with xchw) with one instruction.  If the operands need to\n-   be swapped, set the global variable SWAP_OPERANDS.  This function\n-   silently assumes that both OP0 and OP1 are valid memory references.\n-   */\n-\n-int\n-weird_memory_memory (op0, op1)\n-     rtx op0, op1;\n-{\n-  RTX_CODE code0, code1;\n-\n-  op0 = XEXP (op0, 0);\n-  op1 = XEXP (op1, 0);\n-  code0 = GET_CODE (op0);\n-  code1 = GET_CODE (op1);\n-\n-  swap_operands = 0;\n-\n-  if (code1 == REG || code1 == SUBREG)\n-    {\n-      return 1;\n-    }\n-  if (code0 == REG || code0 == SUBREG)\n-    {\n-      swap_operands = 1;\n-      return 1;\n-    }\n-  if (has_direct_base (op0) && has_direct_base (op1))\n-    {\n-      if (has_index (op1))\n-\t{\n-\t  if (has_index (op0))\n-\t    return 0;\n-\t  swap_operands = 1;\n-\t}\n-\n-      return 1;\n-    }\n-  return 0;\n-}\n-\n-int\n-signed_comparison (x, mode)\n-     rtx x;\n-     enum machine_mode mode;\n-{\n-  return ! TRULY_UNSIGNED_COMPARE_P (GET_CODE (x));\n-}\n-\n-extern rtx force_reg ();\n-rtx test_op0, test_op1;\n-enum machine_mode test_mode;\n-\n-/* Sign-extend or zero-extend constant X from FROM_MODE to TO_MODE.  */\n-\n-rtx\n-extend_const (x, extop, from_mode, to_mode)\n-    rtx x;\n-    RTX_CODE extop;\n-    enum machine_mode from_mode, to_mode;\n-{\n-  int val;\n-  int negative;\n-  if (from_mode == to_mode)\n-    return x;\n-  if (GET_CODE (x) != CONST_INT)\n-    abort ();\n-  val = INTVAL (x);\n-  negative = val & (1 << (GET_MODE_BITSIZE (from_mode) - 1));\n-  if (GET_MODE_BITSIZE (from_mode) == HOST_BITS_PER_INT)\n-    abort ();\n-  if (negative && extop == SIGN_EXTEND)\n-    val = val | ((-1) << (GET_MODE_BITSIZE (from_mode)));\n-  else\n-    val = val & ~((-1) << (GET_MODE_BITSIZE (from_mode)));\n-  if (GET_MODE_BITSIZE (to_mode) == HOST_BITS_PER_INT)\n-    return GEN_INT (val);\n-\n-  return GEN_INT (val & ~((-1) << (GET_MODE_BITSIZE (to_mode))));\n-}\n-\n-rtx\n-ensure_extended (op, extop, from_mode)\n-     rtx op;\n-     RTX_CODE extop;\n-     enum machine_mode from_mode;\n-{\n-  if (GET_CODE (op) == CONST_INT)\n-    return extend_const (op, extop, from_mode, SImode);\n-  else\n-    return force_reg (SImode, gen_rtx (extop, SImode, op));\n-}\n-\n-/* Emit rtl for a branch, as well as any delayed (integer) compare insns.\n-   The compare insn to perform is determined by the global variables\n-   test_op0 and test_op1.  */\n-\n-void\n-extend_and_branch (extop)\n-     RTX_CODE extop;\n-{\n-  rtx op0, op1;\n-  RTX_CODE code0, code1;\n-\n-  op0 = test_op0, op1 = test_op1;\n-  if (op0 == 0)\n-    return;\n-\n-  code0 = GET_CODE (op0);\n-  if (op1 != 0)\n-    code1 = GET_CODE (op1);\n-  test_op0 = test_op1 = 0;\n-\n-  if (op1 == 0)\n-    {\n-      op0 = ensure_extended (op0, extop, test_mode);\n-      emit_insn (gen_rtx_SET (VOIDmode, cc0_rtx, op0));\n-    }\n-  else\n-    {\n-      if (CONSTANT_P (op0) && CONSTANT_P (op1))\n-\t{\n-\t  op0 = ensure_extended (op0, extop, test_mode);\n-\t  op1 = ensure_extended (op1, extop, test_mode);\n-\t}\n-      else if (extop == ZERO_EXTEND && test_mode == HImode)\n-\t{\n-\t  /* Pyramids have no unsigned \"cmphi\" instructions.  We need to\n-\t     zero extend unsigned halfwords into temporary registers. */\n-\t  op0 = ensure_extended (op0, extop, test_mode);\n-\t  op1 = ensure_extended (op1, extop, test_mode);\n-\t}\n-      else if (CONSTANT_P (op0))\n-\t{\n-\t  op0 = ensure_extended (op0, extop, test_mode);\n-\t  op1 = ensure_extended (op1, extop, test_mode);\n-\t}\n-      else if (CONSTANT_P (op1))\n-\t{\n-\t  op1 = ensure_extended (op1, extop, test_mode);\n-\t  op0 = ensure_extended (op0, extop, test_mode);\n-\t}\n-      else if ((code0 == REG || code0 == SUBREG)\n-\t       && (code1 == REG || code1 == SUBREG))\n-\t{\n-\t  /* I could do this case without extension, by using the virtual\n-\t     register address (but that would lose for global regs).  */\n-\t  op0 = ensure_extended (op0, extop, test_mode);\n-\t  op1 = ensure_extended (op1, extop, test_mode);\n-\t}\n-      else if (code0 == MEM && code1 == MEM)\n-\t{\n-\t  /* Load into a reg if the address combination can't be handled\n-\t     directly.  */\n-\t  if (! weird_memory_memory (op0, op1))\n-\t    op0 = force_reg (test_mode, op0);\n-\t}\n-\n-      emit_insn (gen_rtx_SET (VOIDmode, cc0_rtx,\n-\t\t\t      gen_rtx_COMPARE (VOIDmode, op0, op1)));\n-    }\n-}\n-\n-/* Return non-zero if the two single-word moves with operands[0]\n-   and operands[1] for the first single-word move, and operands[2]\n-   and operands[3] for the second single-word move, is possible to\n-   combine to a double word move.\n-\n-   The criterion is whether the operands are in consecutive memory cells,\n-   registers, etc.  */\n-\n-int\n-movdi_possible (operands)\n-     rtx operands[];\n-{\n-  int cnst_diff0, cnst_diff1;\n-  RTX_CODE code0 = GET_CODE (operands[0]);\n-  RTX_CODE code1 = GET_CODE (operands[1]);\n-\n-  /* Don't dare to combine (possibly overlapping) memory -> memory moves.  */\n-  /* It would be possible to detect the cases where we dare, by using\n-     constant_diff (operands[0], operands[1])!!!  */\n-  if (code0 == MEM && code1 == MEM)\n-    return 0;\n-\n-  cnst_diff0 = consecutive_operands (operands[0], operands[2]);\n-  if (cnst_diff0 == 0)\n-    return 0;\n-\n-  cnst_diff1 = consecutive_operands (operands[1], operands[3]);\n-  if (cnst_diff1 == 0)\n-    return 0;\n-\n-  if (cnst_diff0 & cnst_diff1)\n-    {\n-      /* The source and destination operands are consecutive.  */\n-\n-      /* If the first move writes into the source of the second move,\n-\t we cannot combine.  */\n-      if ((code0 == REG\n-\t   && reg_overlap_mentioned_p (operands[0], operands[3]))\n-\t  || (code0 == SUBREG\n-\t      && subreg_overlap_mentioned_p (operands[0], operands[3])))\n-\t  return 0;\n-\n-      if (cnst_diff0 & 1)\n-\t/* operands[0],[1] has higher addresses than operands[2],[3].  */\n-\tswap_operands = 0;\n-      else\n-\t/* operands[0],[1] has lower addresses than operands[2],[3].  */\n-\tswap_operands = 1;\n-      return 1;\n-    }\n-  return 0;\n-}\n-\n-/* Like reg_overlap_mentioned_p, but accepts a subreg rtx instead\n-   of a reg.  */\n-\n-int\n-subreg_overlap_mentioned_p (subreg, x)\n-     rtx subreg, x;\n-{\n-  rtx reg = SUBREG_REG (subreg);\n-  int regno = REGNO (reg) + SUBREG_WORD (subreg);\n-  int endregno = regno + HARD_REGNO_NREGS (regno, GET_MODE (subreg));\n-  return refers_to_regno_p (regno, endregno, x, 0);\n-}\n-\n-/* Return 1 if OP0 is a consecutive operand to OP1, 2 if OP1 is a\n-   consecutive operand to OP0.\n-\n-   This function is used to determine if addresses are consecutive,\n-   and therefore possible to combine to fewer instructions.  */\n-\n-int\n-consecutive_operands (op0, op1)\n-     rtx op0, op1;\n-{\n-  RTX_CODE code0, code1;\n-  int cnst_diff;\n-  int regno_off0, regno_off1;\n-\n-  code0 = GET_CODE (op0);\n-  code1 = GET_CODE (op1);\n-\n-  regno_off0 = 0;\n-  if (code0 == SUBREG)\n-    {\n-      if (GET_MODE_SIZE (GET_MODE (SUBREG_REG (op0))) <= UNITS_PER_WORD)\n-\treturn 0;\n-      regno_off0 = SUBREG_WORD (op0);\n-      op0 = SUBREG_REG (op0);\n-      code0 = REG;\n-    }\n-\n-  regno_off1 = 0;\n-  if (code1 == SUBREG)\n-    {\n-      if (GET_MODE_SIZE (GET_MODE (SUBREG_REG (op1))) <= UNITS_PER_WORD)\n-\treturn 0;\n-      regno_off1 = SUBREG_WORD (op1);\n-      op1 = SUBREG_REG (op1);\n-      code1 = REG;\n-    }\n-\n-  if (code0 != code1)\n-    return 0;\n-\n-  switch (code0)\n-    {\n-    case CONST_INT:\n-      /* Cannot permit any symbolic constants, even if the consecutive\n-\t operand is 0, since a movl really performs sign extension.  */\n-      if (code1 != CONST_INT)\n-\treturn 0;\n-      if ((INTVAL (op0) == 0 && INTVAL (op1) == 0)\n-\t  || (INTVAL (op0) == -1 && INTVAL (op1) == -1))\n-\treturn 3;\n-      if ((INTVAL (op0) == 0 && INTVAL (op1) > 0)\n-\t  || (INTVAL (op0) == -1 && INTVAL (op1) < 0))\n-\treturn 2;\n-      if ((INTVAL (op1) == 0 && INTVAL (op0) > 0)\n-\t  || (INTVAL (op1) == -1 && INTVAL (op0) < 0))\n-\treturn 1;\n-      break;\n-\n-    case REG:\n-      regno_off0 = REGNO (op0) + regno_off0;\n-      regno_off1 = REGNO (op1) + regno_off1;\n-\n-      cnst_diff = regno_off0 - regno_off1;\n-      if (cnst_diff == 1)\n-\t{\n-\t  /* movl with the highest numbered parameter (local) register as\n-\t     source or destination, doesn't wrap to the lowest numbered local\n-\t     (temporary) register.  */\n-\n-\t  if (regno_off0 % 16 != 0)\n-\t    return 1;\n-\t  else\n-\t    return 0;\n-\t}\n-      else if (cnst_diff == -1)\n-\t{\n-\t  if (regno_off1 % 16 != 0)\n-\t    return 2;\n-\t  else\n-\t    return 0;\n-\t}\n-      break;\n-\n-    case MEM:\n-      op0 = XEXP (op0, 0);\n-      op1 = XEXP (op1, 0);\n-      if (GET_CODE (op0) == CONST)\n-\top0 = XEXP (op0, 0);\n-      if (GET_CODE (op1) == CONST)\n-\top1 = XEXP (op1, 0);\n-\n-      cnst_diff = constant_diff (op0, op1);\n-      if (cnst_diff)\n-\t{\n-\t  if (cnst_diff == 4)\n-\t    return 1;\n-\t  else if (cnst_diff == -4)\n-\t    return 2;\n-\t}\n-      break;\n-    }\n-  return 0;\n-}\n-\n-/* Return the constant difference of the rtx expressions OP0 and OP1,\n-   or 0 if they don't have a constant difference.\n-\n-   This function is used to determine if addresses are consecutive,\n-   and therefore possible to combine to fewer instructions.  */\n-\n-int\n-constant_diff (op0, op1)\n-     rtx op0, op1;\n-{\n-  RTX_CODE code0, code1;\n-  int cnst_diff;\n-\n-  code0 = GET_CODE (op0);\n-  code1 = GET_CODE (op1);\n-\n-  if (code0 != code1)\n-    {\n-      if (code0 == PLUS)\n-\t{\n-\t  if (GET_CODE (XEXP (op0, 1)) == CONST_INT\n-\t      && rtx_equal_p (op1, XEXP (op0, 0)))\n-\t    return INTVAL (XEXP (op0, 1));\n-\t}\n-      else if (code1 == PLUS)\n-\t{\n-\t  if (GET_CODE (XEXP (op1, 1)) == CONST_INT\n-\t      && rtx_equal_p (op0, XEXP (op1, 0)))\n-\t    return -INTVAL (XEXP (op1, 1));\n-\t}\n-      return 0;\n-    }\n-\n-  if (code0 == CONST_INT)\n-    return INTVAL (op0) - INTVAL (op1);\n-\n-  if (code0 == PLUS)\n-    {\n-      cnst_diff = constant_diff (XEXP (op0, 0), XEXP (op1, 0));\n-      if (cnst_diff)\n-\treturn (rtx_equal_p (XEXP (op0, 1), XEXP (op1, 1)))\n-\t  ? cnst_diff : 0;\n-      cnst_diff = constant_diff (XEXP (op0, 1), XEXP (op1, 1));\n-      if (cnst_diff)\n-\treturn (rtx_equal_p (XEXP (op0, 0), XEXP (op1, 0)))\n-\t  ? cnst_diff : 0;\n-    }\n-\n-  return 0;\n-}\n-\n-int\n-already_sign_extended (insn, from_mode, op)\n-     rtx insn;\n-     enum machine_mode from_mode;\n-     rtx op;\n-{\n-  rtx xinsn, xdest, xsrc;\n-\n-  for (;;)\n-    {\n-      insn = PREV_INSN (insn);\n-      if (insn == 0)\n-\treturn 0;\n-      if (GET_CODE (insn) == NOTE || GET_CODE (insn) == JUMP_INSN)\n-\tcontinue;\n-      if (GET_CODE (insn) == CALL_INSN && ! call_used_regs[REGNO (op)])\n-\tcontinue;\n-      if (GET_CODE (insn) != INSN)\n-\treturn 0;\n-      xinsn = PATTERN (insn);\n-\n-      if (GET_CODE (xinsn) != SET)\n-\treturn 0;\n-\n-      xdest = SET_DEST (xinsn);\n-      xsrc = SET_SRC (xinsn);\n-\n-      if (GET_CODE (xdest) == SUBREG)\n-\tabort ();\n-\n-      if ( ! REG_P (xdest))\n-\tcontinue;\n-\n-      if (REGNO (op) == REGNO (xdest)\n-\t  && ((GET_CODE (xsrc) == SIGN_EXTEND\n-\t   && GET_MODE (XEXP (xsrc, 0)) == from_mode)\n-\t  || (GET_CODE (xsrc) == MEM\n-\t      && GET_MODE (xsrc) == from_mode)))\n-\treturn 1;\n-\n-      /* The register is modified by another operation.  */\n-      if (reg_overlap_mentioned_p (xdest, op))\n-\treturn 0;\n-    }\n-}\n-\n-char *\n-output_move_double (operands)\n-     rtx *operands;\n-{\n-  if (GET_CODE (operands[1]) == CONST_DOUBLE)\n-    {\n-      if (GET_MODE_CLASS (GET_MODE (operands[1])) == MODE_INT)\n-\t{\n-\t  /* In an integer, the low-order word is in CONST_DOUBLE_LOW.  */\n-\t  rtx const_op = operands[1];\n-\t  if ((CONST_DOUBLE_HIGH (const_op) == 0\n-\t       && CONST_DOUBLE_LOW (const_op) >= 0)\n-\t      || (CONST_DOUBLE_HIGH (const_op) == -1\n-\t\t  && CONST_DOUBLE_LOW (const_op) < 0))\n-\t    {\n-\t      operands[1] = GEN_INT (CONST_DOUBLE_LOW (const_op));\n-\t      return \"movl %1,%0\";\n-\t    }\n-\t  operands[1] = GEN_INT (CONST_DOUBLE_HIGH (const_op));\n-\t  output_asm_insn (\"movw %1,%0\", operands);\n-\t  operands[0] = gen_rtx_REG (SImode, REGNO (operands[0]) + 1);\n-\t  operands[1] = GEN_INT (CONST_DOUBLE_LOW (const_op));\n-\t  return \"movw %1,%0\";\n-\t}\n-      else\n-\t{\n-\t  /* In a real, the low-address word is in CONST_DOUBLE_LOW.  */\n-\t  rtx const_op = operands[1];\n-\t  if ((CONST_DOUBLE_LOW (const_op) == 0\n-\t       && CONST_DOUBLE_HIGH (const_op) >= 0)\n-\t      || (CONST_DOUBLE_LOW (const_op) == -1\n-\t\t  && CONST_DOUBLE_HIGH (const_op) < 0))\n-\t    {\n-\t      operands[1] = GEN_INT (CONST_DOUBLE_HIGH (const_op));\n-\t      return \"movl %1,%0\";\n-\t    }\n-\t  operands[1] = GEN_INT (CONST_DOUBLE_LOW (const_op));\n-\t  output_asm_insn (\"movw %1,%0\", operands);\n-\t  operands[0] = gen_rtx_REG (SImode, REGNO (operands[0]) + 1);\n-\t  operands[1] = GEN_INT (CONST_DOUBLE_HIGH (const_op));\n-\t  return \"movw %1,%0\";\n-\t}\n-    }\n-\n-  return \"movl %1,%0\";\n-}\n-\n-/* Output a shift insns, after having reduced integer arguments to\n-   avoid as warnings.  */\n-\n-char *\n-output_shift (pattern, op2, mod)\n-     char *pattern;\n-     rtx op2;\n-     int mod;\n-{\n-  if (GET_CODE (op2) == CONST_INT)\n-    {\n-      int cnt = INTVAL (op2) % mod;\n-      if (cnt == 0)\n-\t{\n-\t  cc_status = cc_prev_status;\n-\t  return \"\";\n-\t}\n-      op2 = GEN_INT (cnt);\n-    }\n-  return pattern;\n-}\n-\n-/* Return non-zero if the code of this rtx pattern is a relop.  */\n-\n-int\n-relop (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n-{\n-  switch (GET_CODE (op))\n-    {\n-    case EQ:\n-    case NE:\n-    case LT:\n-    case LE:\n-    case GE:\n-    case GT:\n-    case LTU:\n-    case LEU:\n-    case GEU:\n-    case GTU:\n-      return 1;\n-    }\n-  return 0;\n-}\n-\n-void\n-notice_update_cc (EXP, INSN)\n-     rtx EXP, INSN;\n-{\n-  switch (GET_CODE (EXP))\n-    {\n-    case SET:\n-      switch (GET_CODE (SET_DEST (EXP)))\n-\t{\n-\tcase CC0:\n-\t  cc_status.mdep = 0;\n-\t  cc_status.flags = 0;\n-\t  cc_status.value1 = 0;\n-\t  cc_status.value2 = SET_SRC (EXP);\n-\t  break;\n-\n-\tcase PC:\n-\t  break;\n-\n-\tcase REG:\n-\t  switch (GET_CODE (SET_SRC (EXP)))\n-\t    {\n-\t    case CALL:\n-\t      goto call;\n-\t    case MEM:\n-\t      if (GET_MODE (SET_SRC (EXP)) == QImode\n-\t\t  || GET_MODE (SET_SRC (EXP)) == HImode)\n-\t\t{\n-\t\t  cc_status.mdep = 0;\n-\t\t  cc_status.flags = CC_NO_OVERFLOW;\n-\t\t  cc_status.value1 = SET_DEST (EXP);\n-\t\t  cc_status.value2 = SET_SRC (EXP);\n-\t\t  break;\n-\t\t}\n-\t      /* else: Fall through.  */\n-\t    case CONST_INT:\n-\t    case SYMBOL_REF:\n-\t    case LABEL_REF:\n-\t    case CONST:\n-\t    case CONST_DOUBLE:\n-\t    case REG:\n-\t      if (cc_status.value1\n-\t\t  && reg_overlap_mentioned_p (SET_DEST (EXP),\n-\t\t\t\t\t      cc_status.value1))\n-\t\tcc_status.value1 = 0;\n-\t      if (cc_status.value2\n-\t\t  && reg_overlap_mentioned_p (SET_DEST (EXP),\n-\t\t\t\t\t      cc_status.value2))\n-\t\tcc_status.value2 = 0;\n-\t      break;\n-\n-\t    case UDIV:\n-\t    case UMOD:\n-\t      cc_status.mdep = CC_VALID_FOR_UNSIGNED;\n-\t      cc_status.flags = CC_NO_OVERFLOW;\n-\t      cc_status.value1 = SET_DEST (EXP);\n-\t      cc_status.value2 = SET_SRC (EXP);\n-\t      break;\n-\t    default:\n-\t      cc_status.mdep = 0;\n-\t      cc_status.flags = CC_NO_OVERFLOW;\n-\t      cc_status.value1 = SET_DEST (EXP);\n-\t      cc_status.value2 = SET_SRC (EXP);\n-\t      break;\n-\t    }\n-\t  break;\n-\n-\tcase MEM:\n-\t  switch (GET_CODE (SET_SRC (EXP)))\n-\t    {\n-\t    case REG:\n-\t      if (GET_MODE (SET_SRC (EXP)) == QImode\n-\t\t  || GET_MODE (SET_SRC (EXP)) == HImode)\n-\t\t{\n-\t\t  cc_status.flags = CC_NO_OVERFLOW;\n-\t\t  cc_status.value1 = SET_DEST (EXP);\n-\t\t  cc_status.value2 = SET_SRC (EXP);\n-\t\t  cc_status.mdep = 0;\n-\t\t  break;\n-\t\t}\n-\t      /* else: Fall through.  */\n-\t    case CONST_INT:\n-\t    case SYMBOL_REF:\n-\t    case LABEL_REF:\n-\t    case CONST:\n-\t    case CONST_DOUBLE:\n-\t    case MEM:\n-\t      /* Need to forget cc_status about memory positions each\n-\t\t time a memory store is made, even if the memory store\n-\t\t insns in question doesn't modify the condition codes.  */\n-\t      if (cc_status.value1 &&\n-\t\t  GET_CODE (cc_status.value1) == MEM)\n-\t\tcc_status.value1 = 0;\n-\t      if (cc_status.value2 &&\n-\t\t  GET_CODE (cc_status.value2) == MEM)\n-\t\tcc_status.value2 = 0;\n-\t      break;\n-\t    case SIGN_EXTEND:\n-\t    case FLOAT_EXTEND:\n-\t    case FLOAT_TRUNCATE:\n-\t    case FLOAT:\n-\t    case FIX:\n-\t      cc_status.flags = CC_NO_OVERFLOW;\n-\t      cc_status.value1 = SET_DEST (EXP);\n-\t      cc_status.value2 = SET_SRC (EXP);\n-\t      cc_status.mdep = 0;\n-\t      break;\n-\n-\t    default:\n-\t      abort ();\n-\t    }\n-\t  break;\n-\n-\tdefault:\n-\t  abort ();\n-\t}\n-      break;\n-\n-    case CALL:\n-    call:\n-      CC_STATUS_INIT;\n-      break;\n-      /* Do calls preserve the condition codes?  (At least forget\n-\t cc_status expressions if they refer to registers\n-\t not preserved across calls.  Also forget expressions\n-\t about memory contents.)  */\n-      if (cc_status.value1\n-\t  && (refers_to_regno_p (PYR_TREG (0), PYR_TREG (15),\n-\t\t\t\t cc_status.value1, 0)\n-\t      || GET_CODE (cc_status.value1) == MEM))\n-\tcc_status.value1 = 0;\n-      if (cc_status.value2\n-\t  && (refers_to_regno_p (PYR_TREG (0), PYR_TREG (15),\n-\t\t\t\t cc_status.value2, 0)\n-\t      || GET_CODE (cc_status.value2) == MEM))\n-\tcc_status.value2 = 0;\n-      break;\n-\n-    default:\n-      CC_STATUS_INIT;\n-    }\n-}\n-\n-void\n-forget_cc_if_dependent (op)\n-     rtx op;\n-{\n-  cc_status = cc_prev_status;\n-  if (cc_status.value1 && reg_overlap_mentioned_p (op, cc_status.value1))\n-    cc_status.value1 = 0;\n-  if (cc_status.value2 && reg_overlap_mentioned_p (op, cc_status.value2))\n-    cc_status.value2 = 0;\n-}\n-\f\n-/* ??? None of the original definitions ever worked for stdarg.h, or\n-   even for structs or float arguments.   Quoting bits of the old \n-   va-pyr.h for historical interest.  */\n-\n-/**\n- *\n- * \tVarargs for PYR/GNU CC\n- *\n- * WARNING -- WARNING -- DANGER\n- *\n- * The code in this file implements varargs for gcc on a pyr in\n- * a way that is compatible with code compiled by the Pyramid Technology\n- * C compiler.\n- * As such, it depends strongly on the Pyramid conventions for\n- * parameter passing.ct and independent implementation. \n- * These (somewhat bizarre) parameter-passing conventions are described\n- * in the ``OSx Operating System Porting Guide''.\n- * \n- * A quick summary is useful:\n- * 12 of the 48 register-windowed regs available for\n- * parameter passing.  Parameters of a function call that are eligible\n- * to be passed in registers are assigned registers from TR0/PR0 onwards;\n- * all other arguments are passed on the stack.\n- * Structure and union parameters are *never* passed in registers,\n- * even if they are small enough to fit.  They are always passed on\n- * the stack.\n- *\n- * Double-sized parameters cannot be passed in TR11, because\n- * TR12 is not used for passing parameters.  If, in the absence of this\n- * rule, a double-sized param would have been passed in TR11,\n- * that parameter is passed on the stack and no parameters are\n- * passed in TR11.\n- * \n- * It is only known to work for passing 32-bit integer quantities\n- * (ie chars, shorts, ints/enums, longs), doubles, or pointers. \n- * Passing structures on a Pyramid via varargs is a loser.\n- * Passing an object larger than 8 bytes on a pyramid via varargs may\n- * also be a loser.\n- * \n- */\n-\n-tree\n-pyr_build_va_list ()\n-{\n-typedef struct __va_regs {\n-      __voidptr __stackp,__regp,__count;\n-      __voidptr __pr0,__pr1,__pr2,__pr3,__pr4,__pr5,__pr6,__pr7,__pr8,__pr9,__pr10,__pr11;\n-  } __va_regs;\n-\n-typedef __va_regs __va_buf;\n-typedef __va_buf __gnuc_va_list;\n-}\n-\n-void\n-pyr_va_start (stdarg_p, valist, nextarg)\n-     int stdarg_p;\n-     tree valist;\n-     rtx nextarg ATTRIBUTE_UNUSED;\n-{\n-#define va_alist \\\n-  __va0,__va1,__va2,__va3,__va4,__va5,__va6,__va7,__va8,__va9,__va10,__va11, \\\n- __builtin_va_alist\n-\n-/* The ... causes current_function_varargs to be set in cc1.  */\n-#define va_dcl __voidptr va_alist; __va_ellipsis\n-\n-\n-/* __asm (\"rcsp %0\" : \"=r\" ( _AP [0]));*/\n-\n-#define va_start(_AP)  \\\n-  _AP =  ((struct __va_regs) {\t\t\t\t\t\t\\\n-   &(_AP.__pr0), (void*)&__builtin_va_alist, (void*)0,\t\t\t\\\n-        __va0,__va1,__va2,__va3,__va4,__va5,\t\t\t\t\\\n-\t__va6,__va7,__va8,__va9,__va10,__va11})\n-\n-}\n-\n-rtx\n-pyr_va_arg (valist, type)\n-     tree valist, type;\n-{\n-#define va_arg(_AP, _MODE)\t\\\n-__extension__\t\t\t\t\t\t\t\t\\\n-(*({__voidptr *__ap = (__voidptr*)&_AP;\t\t\t\t\t\\\n-  register int __size = sizeof (_MODE);\t\t\t\t\t\\\n-  register int __onstack =\t\t\t\t\t\t\\\n-\t  (__size > 8 || ( (int)(__ap[2]) > 11) ||\t\t\t\\\n-\t    (__size==8 && (int)(__ap[2])==11));\t\t\t\t\\\n-  register int* __param_addr =  ((int*)((__ap) [__onstack]));\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  ((void *)__ap[__onstack])+=__size;\t\t\t\t\t\\\n-    if (__onstack==0 || (int)(__ap[2])==11)\t\t\t\t\\\n-      __ap[2]+= (__size >> 2);\t\t\t\t\t\t\\\n-  (( _MODE *) (void *) __param_addr);\t\t\t\t\t\\\n-}))\n-}"}, {"sha": "009a0d5738adf56abc91564ead992e7852db917f", "filename": "gcc/config/pyr/pyr.h", "status": "removed", "additions": 0, "deletions": 1505, "changes": 1505, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7b4171a5b8a655097812307bbe261032dfbe366/gcc%2Fconfig%2Fpyr%2Fpyr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7b4171a5b8a655097812307bbe261032dfbe366/gcc%2Fconfig%2Fpyr%2Fpyr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpyr%2Fpyr.h?ref=a7b4171a5b8a655097812307bbe261032dfbe366", "patch": "@@ -1,1505 +0,0 @@\n-/* Definitions of target machine parameters for GNU compiler,\n-   for Pyramid 90x, 9000, and MIServer Series.\n-   Copyright (C) 1989, 1995, 1996, 1997, 1998, 1999\n-   Free Software Foundation, Inc.\n-\n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-/*\n- * If you're going to change this, and you haven't already,\n- * you should get and read\n- * \t``OSx Operating System Porting Guide'',\n- *\t  publication number 4100-0066-A\n- *\t  Revision A\n- *\t  Pyramid Technology Corporation.\n- *\n- * or whatever the most recent version is.  In any case, page and\n- * section number references given herein refer to this document.\n- *\n- *  The instruction table for gdb lists the available insns and\n- *  the valid addressing modes.\n- *\n- *  Any other information on the Pyramid architecture is proprietary\n- *  and hard to get. (Pyramid cc -S and adb are also useful.)\n- *\n- */\n-\n-/*** Run-time compilation parameters selecting different hardware subsets. ***/\n-\n-/* Names to predefine in the preprocessor for this target machine.  */\n-\n-#define CPP_PREDEFINES \"-Dpyr -Dunix -Asystem(unix) -Acpu(pyr) -Amachine(pyr)\"\n-\n-/* Print subsidiary information on the compiler version in use.  */\n-\n-#define TARGET_VERSION fprintf (stderr, \" (pyr)\");\n-\n-extern int target_flags;\n-\n-/* Nonzero if compiling code that Unix assembler can assemble.  */\n-#define TARGET_UNIX_ASM (target_flags & 1)\n-\n-/* Implement stdarg in the same fashion used on all other machines.  */\n-#define TARGET_GNU_STDARG   (target_flags & 2)\n-\n-/* Compile using RETD to pop off the args.\n-   This will not work unless you use prototypes at least\n-   for all functions that can take varying numbers of args.\n-   This contravenes the Pyramid calling convention, so we don't\n-   do it yet.  */\n-\n-#define TARGET_RETD (target_flags & 4)\n-\n-/* Macros used in the machine description to test the flags.  */\n-\n-/* Macro to define tables used to set the flags.\n-   This is a list in braces of pairs in braces,\n-   each pair being { \"NAME\", VALUE }\n-   where VALUE is the bits to set or minus the bits to clear.\n-   An empty string NAME is used to identify the default VALUE.\n-\n-   -mgnu will be useful if we ever have GAS on a pyramid.  */\n-\n-#define TARGET_SWITCHES  \\\n-  { {\"unix\", 1},  \t\t\\\n-    {\"gnu\", -1},  \t\t\\\n-    {\"gnu-stdarg\", 2},\t\t\\\n-    {\"nognu-stdarg\", -2},\t\\\n-    {\"retd\", 4},\t\t\\\n-    {\"no-retd\", -4},\t\t\\\n-    { \"\", TARGET_DEFAULT}}\n-\n-/* Default target_flags if no switches specified.\n-\n-   (equivalent to \"-munix -mindex -mgnu-stdarg\")  */\n-\n-#ifndef TARGET_DEFAULT\n-#define TARGET_DEFAULT (1 + 2)\n-#endif\n-\n-/* Make GCC agree with types.h.  */\n-#ifdef\tSIZE_TYPE\n-#undef\tSIZE_TYPE\n-#endif\n-#define\tSIZE_TYPE\t\"unsigned int\"\n-\n-/* Assembler does not permit $ in labels */\n-\n-#define\tNO_DOLLAR_IN_LABEL\n-\n-/* Maybe it doesn't permit dot either.  */\n-#define NO_DOT_IN_LABEL\n-\n-/* Never allow $ in identifiers */\n-\n-#define DOLLARS_IN_IDENTIFIERS 0\n-\f\n-/*** Target machine storage layout ***/\n-\n-/* Define this to non-zero if most significant bit is lowest\n-   numbered in instructions that operate on numbered bit-fields.\n-   This is not true on the pyramid.  */\n-#define BITS_BIG_ENDIAN 0\n-\n-/* Define this to non-zero if most significant byte of a word is\n-   the lowest numbered.  */\n-#define BYTES_BIG_ENDIAN 1\n-\n-/* Define this to non-zero if most significant word of a multiword\n-   number is the lowest numbered.  */\n-#define WORDS_BIG_ENDIAN 1\n-\n-/* Number of bits in an addressable storage unit */\n-#define BITS_PER_UNIT 8\n-\n-/* Width in bits of a \"word\", which is the contents of a machine register.\n-   Note that this is not necessarily the width of data type `int';\n-   if using 16-bit ints on a 68000, this would still be 32.\n-   But on a machine with 16-bit registers, this would be 16.  */\n-#define BITS_PER_WORD 32\n-\n-/* Width of a word, in units (bytes).  */\n-#define UNITS_PER_WORD 4\n-\n-/* Width in bits of a pointer.\n-   See also the macro `Pmode' defined below.  */\n-#define POINTER_SIZE 32\n-\n-/* Allocation boundary (in *bits*) for storing arguments in argument list.  */\n-#define PARM_BOUNDARY 32\n-\n-/* Boundary (in *bits*) on which stack pointer should be aligned.  */\n-#define STACK_BOUNDARY 32\n-\n-/* Allocation boundary (in *bits*) for the code of a function.  */\n-#define FUNCTION_BOUNDARY 32\n-\n-/* Alignment of field after `int : 0' in a structure.  */\n-#define EMPTY_FIELD_BOUNDARY 32\n-\n-/* Every structure's size must be a multiple of this.  */\n-#define STRUCTURE_SIZE_BOUNDARY 32\n-\n-/* No data type wants to be aligned rounder than this.  */\n-#define BIGGEST_ALIGNMENT 32\n-\n-/* Specified types of bitfields affect alignment of those fields\n-   and of the structure as a whole.  */\n-#define PCC_BITFIELD_TYPE_MATTERS 1\n-\n-/* Make strings word-aligned so strcpy from constants will be faster. \n-   Pyramid documentation says the best alignment is to align\n-   on the size of a cache line, which is 32 bytes.\n-   Newer pyrs have single insns that do strcmp() and strcpy(), so this\n-   may not actually win anything.   */\n-#define CONSTANT_ALIGNMENT(EXP, ALIGN)  \\\n-  (TREE_CODE (EXP) == STRING_CST\t\\\n-   && (ALIGN) < BITS_PER_WORD ? BITS_PER_WORD : (ALIGN))\n-\n-/* Make arrays of chars word-aligned for the same reasons.  */\n-#define DATA_ALIGNMENT(TYPE, ALIGN)\t\t\\\n-  (TREE_CODE (TYPE) == ARRAY_TYPE\t\t\\\n-   && TYPE_MODE (TREE_TYPE (TYPE)) == QImode\t\\\n-   && (ALIGN) < BITS_PER_WORD ? BITS_PER_WORD : (ALIGN))\n-\n-/* Set this nonzero if move instructions will actually fail to work\n-   when given unaligned data.  */\n-#define STRICT_ALIGNMENT 1\n-\f\n-/*** Standard register usage.  ***/\n-\n-/* Number of actual hardware registers.\n-   The hardware registers are assigned numbers for the compiler\n-   from 0 to just below FIRST_PSEUDO_REGISTER.\n-   All registers that the compiler knows about must be given numbers,\n-   even those that are not normally considered general registers.  */\n-\n-/* Nota Bene:\n-   Pyramids have 64 addressable 32-bit registers, arranged as four\n-   groups of sixteen registers each. Pyramid names the groups\n-   global, parameter, local, and temporary.\n-\n-   The sixteen global registers are fairly conventional; the last\n-   four are overloaded with a PSW, frame pointer, stack pointer, and pc.\n-   The non-dedicated global registers used to be reserved for Pyramid\n-   operating systems, and still have cryptic and undocumented uses for\n-   certain library calls.  We do not use global registers gr0 through\n-   gr11.\n-\n-   The parameter, local, and temporary registers provide register\n-   windowing.  Each procedure call has its own set of these 48\n-   registers, which constitute its call frame. (These frames are\n-   not allocated on the conventional stack, but contiguously\n-   on a separate stack called the control stack.)\n-   Register windowing is a facility whereby the temporary registers\n-   of frame n become the parameter registers of frame n+1, viz.:\n-\n-                                      0         15 0         15 0         15\n-                                     +------------+------------+------------+\n-frame n+1                            |            |            |            |\n-                                     +------------+------------+------------+\n-                                        Parameter     Local       Temporary\n-\n-                                          ^\n-                                          | These 16 regs are the same.\n-                                          v\n-\n-            0         15 0         15 0         15\n-           +------------+------------+------------+\n-frame n    |            |            |            |\n-           +------------+------------+------------+\n-             Parameter     Local       Temporary\n-\n-   New frames are automatically allocated on the control stack by the\n-   call instruction and de-allocated by the return insns \"ret\" and\n-   \"retd\".  The control-stack grows contiguously upward from a\n-   well-known address in memory; programs are free to allocate\n-   a variable sized, conventional frame on the data stack, which\n-   grows downwards in memory from just below the control stack.\n-\n-   Temporary registers are used for parameter passing, and are not\n-   preserved across calls.  TR0 through TR11 correspond to\n-   gcc's ``input'' registers; PR0 through TR11 the ``output''\n-   registers. The call insn stores the PC and PSW in PR14 and PR15 of\n-   the frame it creates; the return insns restore these into the PC\n-   and PSW. The same is true for interrupts; TR14 and TR15 of the\n-   current frame are reserved and should never be used, since an\n-   interrupt may occur at any time and clobber them.\n-\n-   An interesting quirk is the ability to take the address of a\n-   variable in a windowed register.  This done by adding the memory\n-   address of the base of the current window frame, to the offset\n-   within the frame of the desired register.  The resulting address\n-   can be treated just like any other pointer; if a quantity is stored\n-   into that address, the appropriate register also changes.\n-   GCC does not, and according to RMS will not, support this feature,\n-   even though some programs rely on this (mis)feature.\n- */\n-\n-#define PYR_GREG(n) (n)\n-#define PYR_PREG(n) (16+(n))\n-#define PYR_LREG(n) (32+(n))\n-#define PYR_TREG(n) (48+(n))\n-\n-/* Define this macro if the target machine has \"register windows\".  This\n-   C expression returns the register number as seen by the called function\n-   corresponding to register number OUT as seen by the calling function.\n-   Return OUT if register number OUT is not an outbound register.  */\n-\n-#define INCOMING_REGNO(OUT) \\\n- (((OUT) < 48 || (OUT) > 63) ? (OUT) : (OUT) - 32)\n-\n-/* Define this macro if the target machine has \"register windows\".  This\n-   C expression returns the register number as seen by the calling function\n-   corresponding to register number IN as seen by the called function.\n-   Return IN if register number IN is not an inbound register.  */\n-\n-#define OUTGOING_REGNO(IN) \\\n- (((IN) < 15 || (IN) > 31) ? (IN) : (IN) + 32)\n-\n-#define FIRST_PSEUDO_REGISTER 64\n-\n-/* 1 for registers that have pervasive standard uses\n-   and are not available for the register allocator.\n-\n-   On the pyramid, these are LOGPSW, SP, and PC.  */\n-\n-#define FIXED_REGISTERS \\\n-  {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\t\\\n-   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1,\t\\\n-   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\t\\\n-   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1}\n-\n-/* 1 for registers not available across function calls.\n-   These must include the FIXED_REGISTERS and also any\n-   registers that can be used without being saved.\n-   The latter must include the registers where values are returned\n-   and the register where structure-value addresses are passed.\n-   Aside from that, you can include as many other registers as you like.  */\n-#define CALL_USED_REGISTERS \\\n-  {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\t\\\n-   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1,\t\\\n-   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \t\\\n-   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1}\n-\n-/* #define DEFAULT_CALLER_SAVES */\n-\n-/* Return number of consecutive hard regs needed starting at reg REGNO\n-   to hold something of mode MODE.\n-   This is ordinarily the length in words of a value of mode MODE\n-   but can be less for certain modes in special long registers.\n-   On the pyramid, all registers are one word long.  */\n-#define HARD_REGNO_NREGS(REGNO, MODE)   \\\n- ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n-\n-/* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.\n-   On the pyramid, all registers can hold all modes.  */\n-\n-/* -->FIXME: this is not the case for 64-bit quantities in tr11/12 through\n-   --> TR14/15.  This should be fixed,  but to do it correctly, we also\n-   --> need to fix MODES_TIEABLE_P. Yuk.  We ignore this, since GCC should\n-   --> do the \"right\" thing due to FIXED_REGISTERS. */\n-#define HARD_REGNO_MODE_OK(REGNO, MODE) 1\n-\n-/* Value is 1 if it is a good idea to tie two pseudo registers\n-   when one has mode MODE1 and one has mode MODE2.\n-   If HARD_REGNO_MODE_OK could produce different values for MODE1 and MODE2,\n-   for any hard reg, then this must be 0 for correct output.  */\n-#define MODES_TIEABLE_P(MODE1, MODE2) 1\n-\n-/* Specify the registers used for certain standard purposes.\n-   The values of these macros are register numbers.  */\n-\n-/* Pyramid pc is overloaded on global register 15.  */\n-#define PC_REGNUM PYR_GREG(15)\n-\n-/* Register to use for pushing function arguments.\n-   --> on Pyramids, the data stack pointer. */\n-#define STACK_POINTER_REGNUM PYR_GREG(14)\n-\n-/* Base register for access to local variables of the function.\n-   Pyramid uses CFP (GR13) as both frame pointer and argument pointer. */\n-#define FRAME_POINTER_REGNUM 13 /* pyr cpp fails on PYR_GREG(13) */\n-\n-/* Value should be nonzero if functions must have frame pointers.\n-   Zero means the frame pointer need not be set up (and parms\n-   may be accessed via the stack pointer) in functions that seem suitable.\n-   This is computed in `reload', in reload1.c.\n-\n-   Setting this to 1 can't break anything.  Since the Pyramid has\n-   register windows, I don't know if defining this to be zero can\n-   win anything.  It could changed later, if it wins. */\n-#define FRAME_POINTER_REQUIRED 1\n-\n-/* Base register for access to arguments of the function.  */\n-#define ARG_POINTER_REGNUM 13 /* PYR_GREG(13) */\n-\n-/* Register in which static-chain is passed to a function.  */\n-/* If needed, Pyramid says to use temporary register 12. */\n-#define STATIC_CHAIN_REGNUM PYR_TREG(12)\n-\n-/* If register windows are used, STATIC_CHAIN_INCOMING_REGNUM\n-   is the register number as seen by the called function, while\n-   STATIC_CHAIN_REGNUM is the register number as seen by the calling\n-   function. */\n-#define STATIC_CHAIN_INCOMING_REGNUM PYR_PREG(12)\n-\n-/* Register in which address to store a structure value\n-   is passed to a function.\n-   On a Pyramid, this is temporary register 0 (TR0).   */\n-\n-#define STRUCT_VALUE_REGNUM PYR_TREG(0)\n-#define STRUCT_VALUE_INCOMING_REGNUM PYR_PREG(0)\n-\f\n-/* Define the classes of registers for register constraints in the\n-   machine description.  Also define ranges of constants.\n-\n-   One of the classes must always be named ALL_REGS and include all hard regs.\n-   If there is more than one class, another class must be named NO_REGS\n-   and contain no registers.\n-\n-   The name GENERAL_REGS must be the name of a class (or an alias for\n-   another name such as ALL_REGS).  This is the class of registers\n-   that is allowed by \"g\" or \"r\" in a register constraint.\n-   Also, registers outside this class are allocated only when\n-   instructions express preferences for them.\n-\n-   The classes must be numbered in nondecreasing order; that is,\n-   a larger-numbered class must never be contained completely\n-   in a smaller-numbered class.\n-\n-   For any two classes, it is very desirable that there be another\n-   class that represents their union.  */\n-\n-/* The pyramid has only one kind of registers, so NO_REGS and ALL_REGS\n-   are the only classes.  */\n-\n-enum reg_class { NO_REGS, ALL_REGS, LIM_REG_CLASSES };\n-\n-#define N_REG_CLASSES (int) LIM_REG_CLASSES\n-\n-/* Since GENERAL_REGS is the same class as ALL_REGS,\n-   don't give it a different class number; just make it an alias.  */\n-\n-#define GENERAL_REGS ALL_REGS\n-\n-/* Give names of register classes as strings for dump file.   */\n-\n-#define REG_CLASS_NAMES \\\n- {\"NO_REGS\", \"ALL_REGS\" }\n-\n-/* Define which registers fit in which classes.\n-   This is an initializer for a vector of HARD_REG_SET\n-   of length N_REG_CLASSES.  */\n-\n-#define REG_CLASS_CONTENTS {{0,0}, {0xffffffff,0xffffffff}}\n-\n-/* The same information, inverted:\n-   Return the class number of the smallest class containing\n-   reg number REGNO.  This could be a conditional expression\n-   or could index an array.  */\n-\n-#define REGNO_REG_CLASS(REGNO) ALL_REGS\n-\n-/* The class value for index registers, and the one for base regs.  */\n-\n-#define BASE_REG_CLASS ALL_REGS\n-#define INDEX_REG_CLASS ALL_REGS\n-\n-/* Get reg_class from a letter such as appears in the machine description.  */\n-\n-#define REG_CLASS_FROM_LETTER(C) NO_REGS\n-\n-/* Given an rtx X being reloaded into a reg required to be\n-   in class CLASS, return the class of reg to actually use.\n-   In general this is just CLASS; but on some machines\n-   in some cases it is preferable to use a more restrictive class.  */\n-\n-#define PREFERRED_RELOAD_CLASS(X,CLASS)  (CLASS)\n-\n-/* Return the maximum number of consecutive registers\n-   needed to represent mode MODE in a register of class CLASS.  */\n-/* On the pyramid, this is always the size of MODE in words,\n-   since all registers are the same size.  */\n-#define CLASS_MAX_NREGS(CLASS, MODE)\t\\\n- ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n-\n-/* The letters I, J, K, L and M in a register constraint string\n-   can be used to stand for particular ranges of immediate operands.\n-   This macro defines what the ranges are.\n-   C is the letter, and VALUE is a constant value.\n-   Return 1 if VALUE is in the range specified by C.\n-\n-   --> For the Pyramid, 'I' can be used for the 6-bit signed integers\n-   --> (-32 to 31) allowed as immediate short operands in many\n-   --> instructions. 'J' cane be used for any value that doesn't fit\n-   --> in 6 bits.  */\n-\n-#define CONST_OK_FOR_LETTER_P(VALUE, C)  \\\n-  ((C) == 'I' ? (VALUE) >= -32 && (VALUE) < 32 : \\\n-   (C) == 'J' ? (VALUE) < -32 || (VALUE) >= 32 : \\\n-   (C) == 'K' ? (VALUE) == 0xff || (VALUE) == 0xffff : 0)\n-\n-/* Similar, but for floating constants, and defining letters G and H.\n-   Here VALUE is the CONST_DOUBLE rtx itself.  */\n-\n-#define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C) 0\n-\n-\f\n-/*** Stack layout; function entry, exit and calling.  ***/\n-\n-/* Define this if pushing a word on the stack\n-   makes the stack pointer a smaller address.  */\n-#define STACK_GROWS_DOWNWARD\n-\n-/* Define this if the nominal address of the stack frame\n-   is at the high-address end of the local variables;\n-   that is, each additional local variable allocated\n-   goes at a more negative offset in the frame.  */\n-#define FRAME_GROWS_DOWNWARD\n-\n-/* Offset within stack frame to start allocating local variables at.\n-   If FRAME_GROWS_DOWNWARD, this is the offset to the END of the\n-   first local allocated.  Otherwise, it is the offset to the BEGINNING\n-   of the first local allocated.  */\n-/* FIXME: this used to work when defined as 0.  But that makes gnu\n-   stdargs clobber the first arg.  What gives?? */\n-#define STARTING_FRAME_OFFSET 0\n-\n-/* Offset of first parameter from the argument pointer register value.  */\n-#define FIRST_PARM_OFFSET(FNDECL) 0\n-\n-/* Value is the number of bytes of arguments automatically\n-   popped when returning from a subroutine call.\n-   FUNDECL is the declaration node of the function (as a tree),\n-   FUNTYPE is the data type of the function (as a tree),\n-   or for a library call it is an identifier node for the subroutine name.\n-   SIZE is the number of bytes of arguments passed on the stack.\n-\n-   The Pyramid OSx Porting Guide says we are never to do this;\n-   using RETD in this way violates the Pyramid calling convention.\n-   We may nevertheless provide this as an option.   */\n-\n-#define RETURN_POPS_ARGS(FUNDECL,FUNTYPE,SIZE)   \\\n-  ((TARGET_RETD && (!(FUNDECL) || TREE_CODE (FUNDECL) != IDENTIFIER_NODE)\t\\\n-    && (TYPE_ARG_TYPES (FUNTYPE) == 0\t\t\t\t\\\n-\t|| (TREE_VALUE (tree_last (TYPE_ARG_TYPES (FUNTYPE)))\t\\\n-\t    == void_type_node)))\t\t\t\t\\\n-   ? (SIZE) : 0)\n-\n-/* Define how to find the value returned by a function.\n-   VALTYPE is the data type of the value (as a tree).\n-   If the precise function being called is known, FUNC is its FUNCTION_DECL;\n-   otherwise, FUNC is 0.  */\n-\n-/* --> Pyramid has register windows.\n-   --> The caller sees the return value is in TR0(/TR1) regardless of\n-   --> its type.   */\n-\n-#define FUNCTION_VALUE(VALTYPE, FUNC)  \\\n-  gen_rtx_REG (TYPE_MODE (VALTYPE), PYR_TREG(0))\n-\n-/* --> but the callee has to leave it in PR0(/PR1) */\n-\n-#define FUNCTION_OUTGOING_VALUE(VALTYPE, FUNC)\t\\\n-  gen_rtx_REG (TYPE_MODE (VALTYPE), PYR_PREG(0))\n-\n-/* Define how to find the value returned by a library function\n-   assuming the value has mode MODE.  */\n-\n-/* --> On Pyramid the return value is in TR0/TR1 regardless.  */\n-\n-#define LIBCALL_VALUE(MODE)  gen_rtx_REG (MODE, PYR_TREG(0))\n-\n-/* Define this if PCC uses the nonreentrant convention for returning\n-   structure and union values.  */\n-\n-#define PCC_STATIC_STRUCT_RETURN\n-\n-/* 1 if N is a possible register number for a function value\n-   as seen by the caller.\n-\n-  On the Pyramid, TR0 is the only register thus used.   */\n-\n-#define FUNCTION_VALUE_REGNO_P(N) ((N) == PYR_TREG(0))\n-\n-/* 1 if N is a possible register number for function argument passing.\n-   On the Pyramid, the first twelve temporary registers are available.  */\n-\n-/* FIXME FIXME FIXME\n-   it's not clear whether this macro should be defined from the point\n-   of view of the caller or the callee.  Since it's never actually used\n-   in GNU CC, the point is somewhat moot :-).\n-\n-   This definition is consistent with register usage in the md's for\n-   other register-window architectures (sparc and spur).\n- */\n-#define FUNCTION_ARG_REGNO_P(N) ((PYR_TREG(0) <= (N)) && ((N) <= PYR_TREG(11)))\n-\f\n-/*** Parameter passing: FUNCTION_ARG and FUNCTION_INCOMING_ARG ***/\n-\n-/* Define a data type for recording info about an argument list\n-   during the scan of that argument list.  This data type should\n-   hold all necessary information about the function itself\n-   and about the args processed so far, enough to enable macros\n-   such as FUNCTION_ARG to determine where the next arg should go.\n-\n-   On Pyramids, each parameter is passed either completely on the stack\n-   or completely in registers.  No parameter larger than a double may\n-   be passed in a register.  Also, no struct or union may be passed in\n-   a register, even if it would fit.\n-\n-    So parameters are not necessarily passed \"consecutively\".\n-    Thus we need a vector data type: one element to record how many\n-    parameters have been passed in registers and on the stack,\n-    respectively.\n-\n-    ((These constraints seem like a gross waste of registers. But if we\n-    ignore the constraint about structs & unions, we won`t be able to\n-    freely mix gcc-compiled code and pyr cc-compiled code.  It looks\n-    like better argument passing conventions, and a machine-dependent\n-    flag to enable them, might be a win.))   */\n-\n-\n-#define CUMULATIVE_ARGS int\n-\n-/* Define the number of registers that can hold parameters.\n-   This macro is used only in other macro definitions below.   */\n-#define NPARM_REGS 12\n-\n-/* Decide whether or not a parameter can be put in a register.\n-   (We may still have problems with libcalls. GCC doesn't seem\n-   to know about anything more than the machine mode.  I trust\n-   structures are never passed to a libcall...\n-\n-   If compiling with -mgnu-stdarg, this definition should make\n-   functions using the gcc-supplied stdarg, and calls to such\n-   functions (declared with an arglist ending in\"...\"),  work.\n-   But such fns won't be able to call pyr cc-compiled\n-   varargs fns (eg, printf(), _doprnt.)\n-\n-   If compiling with -mnognu-stdarg, this definition should make\n-   calls to pyr cc-compiled functions work.  Functions using\n-   the gcc-supplied stdarg will be utterly broken.\n-   There will be no better solution until RMS can be persuaded that\n-   one is needed.\n-\n-   This macro is used only in other macro definitions below.\n-   (well, it may be used in pyr.c, because the damn pyramid cc\n-   can't handle the macro definition of PARAM_SAFE_FOR_REG_P !   */\n-\n-\n-#define INNER_PARAM_SAFE_HELPER(TYPE) \\\n- ((TARGET_GNU_STDARG ? (! TREE_ADDRESSABLE ((tree)TYPE)): 1)\t\\\n-   && (TREE_CODE ((tree)TYPE) != RECORD_TYPE)\t\t\t\\\n-   && (TREE_CODE ((tree)TYPE) != UNION_TYPE))\n-\n-#ifdef __GNUC__\n-#define PARAM_SAFE_HELPER(TYPE) \\\n-  INNER_PARAM_SAFE_HELPER((TYPE))\n-#else\n-extern int inner_param_safe_helper();\n-#define PARAM_SAFE_HELPER(TYPE) \\\n-  inner_param_safe_helper((tree)(TYPE))\n-#endif\n-\n-/* Be careful with the expression (long) (TYPE) == 0.\n-   Writing it in more obvious/correct forms makes the Pyr cc\n-   dump core!   */\n-#define PARAM_SAFE_FOR_REG_P(MODE, TYPE, NAMED) \\\n-  (((MODE) != BLKmode)\t\t\t\t\\\n-   && ((TARGET_GNU_STDARG) ? (NAMED) : 1)\t\\\n-   && ((((long)(TYPE))==0) || PARAM_SAFE_HELPER((TYPE))))\n-\n-/* Initialize a variable CUM of type CUMULATIVE_ARGS\n-   for a call to a function whose data type is FNTYPE.\n-   For a library call, FNTYPE is 0.   */\n-\n-#define INIT_CUMULATIVE_ARGS(CUM,FNTYPE,LIBNAME,INDIRECT)\t\\\n-  ((CUM) = (FNTYPE && !flag_pcc_struct_return\t\t\\\n-\t    && aggregate_value_p (TREE_TYPE (FNTYPE))))\n-\n-/* Determine where to put an argument to a function.\n-   Value is zero to push the argument on the stack,\n-   or a hard register in which to store the argument.\n-\n-   MODE is the argument's machine mode.\n-   TYPE is the data type of the argument (as a tree).\n-    This is null for libcalls where that information may\n-    not be available.\n-   CUM is a variable of type CUMULATIVE_ARGS which gives info about\n-    the preceding args and about the function being called.\n-   NAMED is nonzero if this argument is a named parameter\n-    (otherwise it is an extra parameter matching an ellipsis). */\n-\n-#define FUNCTION_ARG_HELPER(CUM, MODE, TYPE, NAMED) \\\n-(PARAM_SAFE_FOR_REG_P(MODE,TYPE,NAMED)\t\t\t\t\\\n- ? (NPARM_REGS >= ((CUM)\t\t\t\t\t\\\n-\t\t   + ((MODE) == BLKmode\t\t\t\t\\\n-\t\t      ? (int_size_in_bytes (TYPE) + 3) / 4\t\\\n-\t\t      : (GET_MODE_SIZE (MODE) + 3) / 4))\t\\\n-    ? gen_rtx_REG ((MODE), PYR_TREG(CUM))\t\t\t\\\n-    : 0)\t\t\t\t\t\t\t\\\n- : 0)\n-#ifdef __GNUC__\n-#define FUNCTION_ARG(CUM, MODE, TYPE, NAMED) \\\n-\tFUNCTION_ARG_HELPER(CUM, MODE, TYPE, NAMED)\n-#else\n-/*****************  Avoid bug in Pyramid OSx compiler... ******************/\n-#define FUNCTION_ARG  (rtx) pyr_function_arg\n-extern void* pyr_function_arg ();\n-#endif\n-\n-/* Define where a function finds its arguments.\n-   This is different from FUNCTION_ARG because of register windows.  */\n-\n-#define FUNCTION_INCOMING_ARG(CUM, MODE, TYPE, NAMED) \\\n-(PARAM_SAFE_FOR_REG_P(MODE,TYPE,NAMED)\t\t\t\\\n- ? (NPARM_REGS >= ((CUM)\t\t\t\t\\\n-\t   + ((MODE) == BLKmode\t\t\t\t\\\n-\t      ? (int_size_in_bytes (TYPE) + 3) / 4\t\\\n-\t      : (GET_MODE_SIZE (MODE) + 3) / 4))\t\\\n-    ? gen_rtx_REG ((MODE), PYR_PREG(CUM))\t\t\\\n-    : 0)\t\t\t\t\t\t\\\n- : 0)\n-\n-/* Update the data in CUM to advance over an argument\n-   of mode MODE and data type TYPE.\n-   (TYPE is null for libcalls where that information may not be available.)  */\n-\n-#define FUNCTION_ARG_ADVANCE(CUM,MODE,TYPE,NAMED)  \\\n-((CUM)\t+=  (PARAM_SAFE_FOR_REG_P(MODE,TYPE,NAMED)\t\\\n-\t     ? ((MODE) != BLKmode\t\t\t\\\n-\t\t? (GET_MODE_SIZE (MODE) + 3) / 4\t\\\n-\t\t: (int_size_in_bytes (TYPE) + 3) / 4)\t\\\n-\t     : 0))\n-\n-/* This macro generates the assembly code for function entry.\n-   FILE is a stdio stream to output the code to.\n-   SIZE is an int: how many units of temporary storage to allocate.\n-   Refer to the array `regs_ever_live' to determine which registers\n-   to save; `regs_ever_live[I]' is nonzero if register number I\n-   is ever used in the function.  This macro is responsible for\n-   knowing which registers should not be saved even if used.  */\n-\n-#if FRAME_POINTER_REQUIRED\n-\n-/* We always have frame pointers */\n-\n-/* Don't set up a frame pointer if it's not referenced.  */\n-\n-#define FUNCTION_PROLOGUE(FILE, SIZE) \\\n-{\t\t\t\t\t\t\t\t\t\\\n-  int _size = (SIZE) + current_function_pretend_args_size;\t\t\\\n-  if (_size + current_function_args_size != 0\t\t\t\t\\\n-      || current_function_calls_alloca)\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      fprintf (FILE, \"\\tadsf $%d\\n\", _size);\t\t\t\t\\\n-      if (current_function_pretend_args_size > 0)\t\t\t\\\n-      fprintf (FILE, \"\\tsubw $%d,cfp\\n\",\t\t\t\t\\\n-\t  current_function_pretend_args_size);\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-}\n-\n-#else /* !FRAME_POINTER_REQUIRED */\n-\n-/* Don't set up a frame pointer if `frame_pointer_needed' tells us\n-   there is no need.  Also, don't set up a frame pointer if it's not\n-   referenced.  */\n-\n-/* The definition used to be broken.  Write a new one.  */\n-\n-#endif /* !FRAME_POINTER_REQUIRED */\n-\n-/* the trampoline stuff was taken from convex.h - S.P. */\n-\n-/* A C statement to output, on the stream FILE, assembler code for a\n-   block of data that contains the constant parts of a trampoline.  This\n-   code should not include a label - the label is taken care of\n-   automatically.\n-\tWe use TR12/PR12 for the static chain.\n-\tmovew $<STATIC>,pr12\t# I2R\n-\tjump $<func>\t\t# S2R\n- */\n-#define TRAMPOLINE_TEMPLATE(FILE) \\\n-{ ASM_OUTPUT_INT (FILE, GEN_INT (0x2100001C));\t\\\n-  ASM_OUTPUT_INT (FILE, GEN_INT (0x00000000));\t\\\n-  ASM_OUTPUT_INT (FILE, GEN_INT (0x40000000));\t\\\n-  ASM_OUTPUT_INT (FILE, GEN_INT (0x00000000)); }\n-\n-#define TRAMPOLINE_SIZE\t\t16\n-#define TRAMPOLINE_ALIGNMENT\t32\n-\n-/* Emit RTL insns to initialize the variable parts of a trampoline.\n-   FNADDR is an RTX for the address of the function's pure code.\n-   CXT is an RTX for the static chain value for the function.  */\n-\n-#define INITIALIZE_TRAMPOLINE(TRAMP, FNADDR, CXT) \\\n-{ emit_move_insn (gen_rtx_MEM (Pmode, plus_constant (TRAMP, 4)), CXT);\t\\\n-  emit_move_insn (gen_rtx (MEM, Pmode, plus_constant (TRAMP, 12)), FNADDR); \\\n-  emit_call_insn (gen_call\t\t\t\t\t\t\\\n-\t\t  (gen_rtx_MEM\t\t\t\t\t\t\\\n-\t\t   (QImode,\t\t\t\t\t\t\\\n-\t\t    gen_rtx_SYMBOL_REF (Pmode, \"__enable_execute_stack\")), \\\n-\t\t   const0_rtx));\t\t\t\t\\\n-}\n-\n-/* Output assembler code to FILE to increment profiler label # LABELNO\n-   for profiling a function entry.  */\n-#define FUNCTION_PROFILER(FILE, LABELNO)  \\\n-   fprintf (FILE, \"\\tmova LP%d,tr0\\n\\tcall mcount\\n\", (LABELNO));\n-\n-/* Output assembler code to FILE to initialize this source file's\n-   basic block profiling info, if that has not already been done.\n-   Don't know if this works on Pyrs. */\n-\n-#if 0 /* don't do basic_block profiling yet */\n-#define FUNCTION_BLOCK_PROFILER(FILE, LABELNO)  \\\n-  fprintf (FILE, \\\n-           \"\\tmtstw LPBX0,tr0\\n\\tbne LPI%d\\n\\tmova LP%d,TR0\\n\\tcall __bb_init_func\\nLPI%d:\\n\", \\\n-           LABELNO, LABELNO);\n-\n-/* Output assembler code to increment the count associated with\n-   the basic block number BLOCKNO.  Not sure how to do this on pyrs. */\n-#define BLOCK_PROFILER(FILE, BLOCKNO)  \\\n-    fprintf (FILE, \"\\taddw\", 4 * BLOCKNO)\n-#endif /* don't do basic_block profiling yet */\n-\n-/* When returning from a function, the stack pointer does not matter\n-   (as long as there is a frame pointer).  */\n-\n-/* This should return non-zero when we really set up a frame pointer.\n-   Otherwise, GCC is directed to preserve sp by returning zero.  */\n-#define EXIT_IGNORE_STACK \\\n-  (get_frame_size () + current_function_pretend_args_size\t\t\\\n-   + current_function_args_size != 0\t\t\t\t\t\\\n-   || current_function_calls_alloca)\t\t\t\t\t\\\n-\n-/* Store in the variable DEPTH the initial difference between the\n-   frame pointer reg contents and the stack pointer reg contents,\n-   as of the start of the function body.  This depends on the layout\n-   of the fixed parts of the stack frame and on how registers are saved.\n-\n-   On the Pyramid, FRAME_POINTER_REQUIRED is always 1, so the definition\n-   of this macro doesn't matter.  But it must be defined.  */\n-\n-#define INITIAL_FRAME_POINTER_OFFSET(DEPTH) (DEPTH) = 0;\n-\f\n-/*** Addressing modes, and classification of registers for them.  ***/\n-\n-/* #define HAVE_POST_INCREMENT 0 */\t/* pyramid has none of these */\n-/* #define HAVE_POST_DECREMENT 0 */\n-\n-/* #define HAVE_PRE_DECREMENT 0 */\n-/* #define HAVE_PRE_INCREMENT 0 */\n-\n-/* Macros to check register numbers against specific register classes.  */\n-\n-/* These assume that REGNO is a hard or pseudo reg number.\n-   They give nonzero only if REGNO is a hard reg of the suitable class\n-   or a pseudo reg currently allocated to a suitable hard reg.\n-   Since they use reg_renumber, they are safe only once reg_renumber\n-   has been allocated, which happens in local-alloc.c.  */\n-\n-/* All registers except gr0 OK as index or base registers.  */\n-\n-#define REGNO_OK_FOR_BASE_P(regno) \\\n-((regno) < FIRST_PSEUDO_REGISTER || reg_renumber[regno] >= 0)\n-\n-#define REGNO_OK_FOR_INDEX_P(regno)  \\\n-((unsigned) (regno) - 1 < FIRST_PSEUDO_REGISTER - 1 \\\n- || reg_renumber[regno] > 0)\n-\n-/* Maximum number of registers that can appear in a valid memory address.  */\n-\n-#define MAX_REGS_PER_ADDRESS 2     /* check MAX_REGS_PER_ADDRESS */\n-\n-/* 1 if X is an rtx for a constant that is a valid address.  */\n-\n-#define CONSTANT_ADDRESS_P(X)   \\\n-  (GET_CODE (X) == LABEL_REF || GET_CODE (X) == SYMBOL_REF\t\t\\\n-   || GET_CODE (X) == CONST_INT || GET_CODE (X) == CONST\t\t\\\n-   || GET_CODE (X) == HIGH)\n-\n-/* Nonzero if the constant value X is a legitimate general operand.\n-   It is given that X satisfies CONSTANT_P or is a CONST_DOUBLE.  */\n-\n-#define LEGITIMATE_CONSTANT_P(X) 1\n-\n-/* The macros REG_OK_FOR..._P assume that the arg is a REG rtx\n-   and check its validity for a certain class.\n-   We have two alternate definitions for each of them.\n-   The usual definition accepts all pseudo regs; the other rejects\n-   them unless they have been allocated suitable hard regs.\n-   The symbol REG_OK_STRICT causes the latter definition to be used.\n-\n-   Most source files want to accept pseudo regs in the hope that\n-   they will get allocated to the class that the insn wants them to be in.\n-   Source files for reload pass need to be strict.\n-   After reload, it makes no difference, since pseudo regs have\n-   been eliminated by then.  */\n-\n-#ifndef REG_OK_STRICT\n-\n-/* Nonzero if X is a hard reg that can be used as an index\n-   or if it is a pseudo reg.  */\n-#define REG_OK_FOR_INDEX_P(X) (REGNO (X) > 0)\n-/* Nonzero if X is a hard reg that can be used as a base reg\n-   or if it is a pseudo reg.  */\n-#define REG_OK_FOR_BASE_P(X) 1\n-\n-#else\n-\n-/* Nonzero if X is a hard reg that can be used as an index.  */\n-#define REG_OK_FOR_INDEX_P(X) REGNO_OK_FOR_INDEX_P (REGNO (X))\n-/* Nonzero if X is a hard reg that can be used as a base reg.  */\n-#define REG_OK_FOR_BASE_P(X) REGNO_OK_FOR_BASE_P (REGNO (X))\n-\n-#endif\n-\f\n-/* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression\n-   that is a valid memory address for an instruction.\n-   The MODE argument is the machine mode for the MEM expression\n-   that wants to use this address.\n-\n-   The other macros defined here are used only in GO_IF_LEGITIMATE_ADDRESS,\n-   except for CONSTANT_ADDRESS_P which is actually machine-independent.  */\n-\n-\n-/* Go to ADDR if X is indexable -- i.e., neither indexed nor offset.  */\n-#define GO_IF_INDEXABLE_ADDRESS(X, ADDR)  \\\n-{ register rtx xfoob = (X);\t\t\t\t\t\t\\\n-  if ((CONSTANT_ADDRESS_P (xfoob))\t\t\t\t\t\\\n-      || (GET_CODE (xfoob) == REG && (REG_OK_FOR_BASE_P (xfoob))))\t\\\n-\t  goto ADDR;\t\t\t\t\t\t\t\\\n- }\n-\n-\n-/* Go to label ADDR if X is a valid address that doesn't use indexing.\n-   This is so if X is either a simple address, or the contents of a register\n-   plus an offset.\n-   This macro also gets used in output-pyramid.h in the function that\n-   recognizes non-indexed operands.  */\n-\n-#define GO_IF_NONINDEXED_ADDRESS(X, ADDR)  \\\n-{\t\t\t\t\t\t\t\t\t\\\n-  if (GET_CODE (X) == REG)\t\t\t\t\t\t\\\n-      goto ADDR;\t\t\t\t\t\t\t\\\n-  GO_IF_INDEXABLE_ADDRESS (X, ADDR);\t\t\t\t\t\\\n-  if (GET_CODE (X) == PLUS)\t\t\t\t\t\t\\\n-    { /* Handle offset(reg) represented with offset on left */\t\t\\\n-      if (CONSTANT_ADDRESS_P (XEXP (X, 0)))\t\t\t\t\\\n-\t{ if (GET_CODE (XEXP (X, 1)) == REG\t\t\t\t\\\n-\t      && REG_OK_FOR_BASE_P (XEXP (X, 1)))\t\t\t\\\n-\t    goto ADDR;\t\t\t\t\t\t\t\\\n-\t }\t\t\t\t\t\t\t\t\\\n-      /* Handle offset(reg) represented with offset on right */\t\t\\\n-      if (CONSTANT_ADDRESS_P (XEXP (X, 1)))\t\t\t\t\\\n-\t{ if (GET_CODE (XEXP (X, 0)) == REG\t\t\t\t\\\n-\t      && REG_OK_FOR_BASE_P (XEXP (X, 0)))\t\t\t\\\n-\t    goto ADDR;\t\t\t\t\t\t\t\\\n-\t }\t\t\t\t\t\t\t\t\\\n-     }\t\t\t\t\t\t\t\t\t\\\n-}\n-\n-/* 1 if PROD is either a reg or a reg times a valid offset multiplier\n-   (ie, 2, 4, or 8).\n-   This macro's expansion uses the temporary variables xfoo0 and xfoo1\n-   that must be declared in the surrounding context.  */\n-#define INDEX_TERM_P(PROD, MODE)   \\\n-((GET_CODE (PROD) == REG && REG_OK_FOR_BASE_P (PROD))\t\t\t\\\n-  || (GET_CODE (PROD) == MULT\t\t\t\t\t\t\\\n-      &&\t\t\t\t\t\t\t\t\\\n-      (xfoo0 = XEXP (PROD, 0), xfoo1 = XEXP (PROD, 1),\t\t\t\\\n-       ((GET_CODE (xfoo0) == CONST_INT\t\t\t\t\t\\\n-         && (INTVAL (xfoo0) == 1\t\t\t\t\t\\\n-\t     || INTVAL (xfoo0) == 2\t\t\t\t\t\\\n-\t     || INTVAL (xfoo0) == 4\t\t\t\t\t\\\n-\t     || INTVAL (xfoo0) == 8)\t\t\t\t\t\\\n-         && GET_CODE (xfoo1) == REG\t\t\t\t\t\\\n-         && REG_OK_FOR_INDEX_P (xfoo1))\t\t\t\t\t\\\n-        ||\t\t\t\t\t\t\t\t\\\n-        (GET_CODE (xfoo1) == CONST_INT\t\t\t\t\t\\\n-\t && (INTVAL (xfoo1) == 1\t\t\t\t\t\\\n-\t     || INTVAL (xfoo1) == 2\t\t\t\t\t\\\n-\t     || INTVAL (xfoo1) == 4\t\t\t\t\t\\\n-\t     || INTVAL (xfoo1) == 8)\t\t\t\t\t\\\n-        && GET_CODE (xfoo0) == REG\t\t\t\t\t\\\n-        && REG_OK_FOR_INDEX_P (xfoo0))))))\n-\n-\n-#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)  \\\n-{ register rtx xone, xtwo, xfoo0, xfoo1;\t\t\t\t\\\n-  GO_IF_NONINDEXED_ADDRESS (X, ADDR);\t\t\t\t\t\\\n-  if (GET_CODE (X) == PLUS)\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      /* Handle <address>[index] represented with index-sum outermost */\\\n-      xone = XEXP (X, 0);\t\t\t\t\t\t\\\n-      xtwo = XEXP (X, 1);\t\t\t\t\t\t\\\n-      if (INDEX_TERM_P (xone, MODE))\t\t\t\t\t\\\n-\t{ GO_IF_INDEXABLE_ADDRESS (xtwo, ADDR); }\t\t\t\\\n-      /* Handle <address>[index] represented with index-sum innermost */\\\n-      if (INDEX_TERM_P (xtwo, MODE))\t\t\t\t\t\\\n-\t{ GO_IF_INDEXABLE_ADDRESS (xone, ADDR); }\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-}\n-\n-/* Try machine-dependent ways of modifying an illegitimate address\n-   to be legitimate.  If we find one, return the new, valid address.\n-   This macro is used in only one place: `memory_address' in explow.c.\n-\n-   OLDX is the address as it was before break_out_memory_refs was called.\n-   In some cases it is useful to look at this to decide what needs to be done.\n-\n-   MODE and WIN are passed so that this macro can use\n-   GO_IF_LEGITIMATE_ADDRESS.\n-\n-   It is always safe for this macro to do nothing.  It exists to recognize\n-   opportunities to optimize the output.\n-\n-   --> FIXME: We haven't yet figured out what optimizations are useful\n-   --> on Pyramids.   */\n-\n-#define LEGITIMIZE_ADDRESS(X,OLDX,MODE,WIN)  {}\n-\n-/* Go to LABEL if ADDR (a legitimate address expression)\n-   has an effect that depends on the machine mode it is used for.\n-   There don't seem to be any such modes on pyramids. */\n-#define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR,LABEL)\n-\f\n-/*** Miscellaneous Parameters ***/\n-\n-/* Specify the machine mode that this machine uses\n-   for the index in the tablejump instruction.  */\n-#define CASE_VECTOR_MODE SImode\n-\n-/* Define as C expression which evaluates to nonzero if the tablejump\n-   instruction expects the table to contain offsets from the address of the\n-   table.\n-   Do not define this if the table should contain absolute addresses. */\n-/*#define CASE_VECTOR_PC_RELATIVE 1 */\n-\n-/* Specify the tree operation to be used to convert reals to integers.  */\n-#define IMPLICIT_FIX_EXPR FIX_ROUND_EXPR\n-\n-/* This is the kind of divide that is easiest to do in the general case.\n-   It's just a guess. I have no idea of insn cost on pyrs. */\n-#define EASY_DIV_EXPR TRUNC_DIV_EXPR\n-\n-/* Define this as 1 if `char' should by default be signed; else as 0.  */\n-#define DEFAULT_SIGNED_CHAR 1\n-\n-/* This flag, if defined, says the same insns that convert to a signed fixnum\n-   also convert validly to an unsigned one.  */\n-/* This is untrue for pyramid.  The cvtdw instruction generates a trap\n-   for input operands that are out-of-range for a signed int.  */\n-/* #define FIXUNS_TRUNC_LIKE_FIX_TRUNC */\n-\n-/* Define this macro if the preprocessor should silently ignore\n-  '#sccs' directives. */\n-/* #define SCCS_DIRECTIVE */\n-\n-/* Define this macro if the preprocessor should silently ignore\n-  '#ident' directives. */\n-/* #define IDENT_DIRECTIVE */\n-\n-/* Max number of bytes we can move from memory to memory\n-   in one reasonably fast instruction.  */\n-#define MOVE_MAX 8\n-\n-/* Define this if zero-extension is slow (more than one real instruction).  */\n-/* #define SLOW_ZERO_EXTEND */\n-\n-/* number of bits in an 'int' on target machine */\n-#define INT_TYPE_SIZE 32\n-\n-/* 1 if byte access requires more than one instruction */\n-#define SLOW_BYTE_ACCESS 0\n-\n-/* Define this to be nonzero if shift instructions ignore all but the low-order\n-   few bits. */\n-#define SHIFT_COUNT_TRUNCATED 1\n-\n-/* Value is 1 if truncating an integer of INPREC bits to OUTPREC bits\n-   is done just by pretending it is already truncated.  */\n-#define TRULY_NOOP_TRUNCATION(OUTPREC, INPREC) 1\n-\n-/* Define this macro if it is as good or better to call a constant\n-   function address than to call an address kept in a register.  */\n-/* #define NO_FUNCTION_CSE */\n-\n-/* When a prototype says `char' or `short', really pass an `int'.  */\n-#define PROMOTE_PROTOTYPES 1\n-\n-/* There are no flag store insns on a pyr. */\n-/* #define STORE_FLAG_VALUE */\n-\n-/* Specify the machine mode that pointers have.\n-   After generation of rtl, the compiler makes no further distinction\n-   between pointers and any other objects of this machine mode.  */\n-#define Pmode SImode\n-\n-/* A function address in a call instruction\n-   is a byte address (for indexing purposes)\n-   so give the MEM rtx a byte's mode.  */\n-#define FUNCTION_MODE QImode\n-\n-/* Compute the cost of computing a constant rtl expression RTX\n-   whose rtx-code is CODE.  The body of this macro is a portion\n-   of a switch statement.  If the code is computed here,\n-   return it with a return statement.  Otherwise, break from the switch.  */\n-\n-#define CONST_COSTS(RTX,CODE,OUTER_CODE) \\\n-  case CONST_INT:\t\t\t\t\t\t\\\n-    if (CONST_OK_FOR_LETTER_P (INTVAL (RTX),'I')) return 0;\t\\\n-  case CONST:\t\t\t\t\t\t\t\\\n-  case LABEL_REF:\t\t\t\t\t\t\\\n-  case SYMBOL_REF:\t\t\t\t\t\t\\\n-    return 4;\t\t\t\t\t\t\t\\\n-  case CONST_DOUBLE:\t\t\t\t\t\t\\\n-    return 6;\n-\n-/* A flag which says to swap the operands of certain insns\n-   when they are output.  */\n-extern int swap_operands;\n-\f\n-/*** Condition Code Information ***/\n-\n-/* Tell final.c how to eliminate redundant test instructions.  */\n-\n-/* Here we define machine-dependent flags and fields in cc_status\n-   (see `conditions.h').  No extra ones are needed for the pyr.  */\n-\n-/* Store in cc_status the expressions\n-   that the condition codes will describe\n-   after execution of an instruction whose pattern is EXP.\n-   Do not alter them if the instruction would not alter the cc's.  */\n-\n-/* This is a very simple definition of NOTICE_UPDATE_CC.\n-   Many cases can be optimized, to improve condition code usage.\n-   Maybe we should handle this entirely in the md, since it complicated\n-   to describe the way pyr sets cc.  */\n-\n-#define TRULY_UNSIGNED_COMPARE_P(X) \\\n-  (X == GEU || X == GTU || X == LEU || X == LTU)\n-#define CC_VALID_FOR_UNSIGNED 2\n-\n-#define CC_STATUS_MDEP_INIT cc_status.mdep = 0\n-\n-#define NOTICE_UPDATE_CC(EXP, INSN) \\\n-  notice_update_cc(EXP, INSN)\n-\f\n-/*** Output of Assembler Code ***/\n-\n-/* Output at beginning of assembler file.  */\n-\n-#define ASM_FILE_START(FILE) \\\n-  fprintf (FILE, ((TARGET_UNIX_ASM)? \"\" : \"#NO_APP\\n\"));\n-\n-/* Output to assembler file text saying following lines\n-   may contain character constants, extra white space, comments, etc.  */\n-\n-#define ASM_APP_ON ((TARGET_UNIX_ASM) ? \"\" : \"#APP\\n\")\n-\n-/* Output to assembler file text saying following lines\n-   no longer contain unusual constructs.  */\n-\n-#define ASM_APP_OFF ((TARGET_UNIX_ASM) ? \"\" : \"#NO_APP\\n\")\n-\n-/* Output before read-only data.  */\n-\n-#define TEXT_SECTION_ASM_OP \"\\t.text\"\n-\n-/* Output before writable data.  */\n-\n-#define DATA_SECTION_ASM_OP \"\\t.data\"\n-\n-/* How to refer to registers in assembler output.\n-   This sequence is indexed by compiler's hard-register-number (see above).  */\n-\n-#define REGISTER_NAMES \\\n-{\"gr0\", \"gr1\", \"gr2\", \"gr3\", \"gr4\", \"gr5\", \"gr6\", \"gr7\", \"gr8\", \\\n- \"gr9\", \"gr10\", \"gr11\", \"logpsw\", \"cfp\", \"sp\", \"pc\", \\\n- \"pr0\", \"pr1\", \"pr2\", \"pr3\", \"pr4\", \"pr5\", \"pr6\", \"pr7\", \\\n- \"pr8\", \"pr9\", \"pr10\", \"pr11\", \"pr12\", \"pr13\", \"pr14\", \"pr15\", \\\n- \"lr0\", \"lr1\", \"lr2\", \"lr3\", \"lr4\", \"lr5\", \"lr6\", \"lr7\", \\\n- \"lr8\", \"lr9\", \"lr10\", \"lr11\", \"lr12\", \"lr13\", \"lr14\", \"lr15\", \\\n- \"tr0\", \"tr1\", \"tr2\", \"tr3\", \"tr4\", \"tr5\", \"tr6\", \"tr7\", \\\n- \"tr8\", \"tr9\", \"tr10\", \"tr11\", \"tr12\", \"tr13\", \"tr14\", \"tr15\"}\n-\n-/* How to renumber registers for dbx and gdb.  */\n-\n-#define DBX_REGISTER_NUMBER(REGNO) (REGNO)\n-\n-/* Our preference is for dbx rather than sdb.\n-   Yours may be different. */\n-#define DBX_DEBUGGING_INFO\n-/* #define SDB_DEBUGGING_INFO */\n-\n-/* Don't use the `xsfoo;' construct in DBX output; this system\n-   doesn't support it.  */\n-\n-#define DBX_NO_XREFS 1\n-\n-/* Do not break .stabs pseudos into continuations.  */\n-\n-#define DBX_CONTIN_LENGTH 0\n-\n-/* This is the char to use for continuation (in case we need to turn\n-   continuation back on).  */\n-\n-#define DBX_CONTIN_CHAR '?'\n-\n-/* This is how to output the definition of a user-level label named NAME,\n-   such as the label on a static function or variable NAME.  */\n-\n-#define ASM_OUTPUT_LABEL(FILE,NAME)\t\\\n-  do { assemble_name (FILE, NAME); fputs (\":\\n\", FILE); } while (0)\n-\n-/* This is how to output a command to make the user-level label named NAME\n-   defined for reference from other files.  */\n-\n-#define ASM_GLOBALIZE_LABEL(FILE,NAME)\t\\\n-  do { fputs (\".globl \", FILE); assemble_name (FILE, NAME); fputs (\"\\n\", FILE);} while (0)\n-\n-/* The prefix to add to user-visible assembler symbols. */\n-\n-#define USER_LABEL_PREFIX \"_\"\n-\n-/* This is how to output an internal numbered label where\n-   PREFIX is the class of label and NUM is the number within the class.  */\n-\n-#define ASM_OUTPUT_INTERNAL_LABEL(FILE,PREFIX,NUM)\t\\\n-  fprintf (FILE, \"%s%d:\\n\", PREFIX, NUM)\n-\n-/* This is how to store into the string LABEL\n-   the symbol_ref name of an internal numbered label where\n-   PREFIX is the class of label and NUM is the number within the class.\n-   This is suitable for output with `assemble_name'.  */\n-\n-#define ASM_GENERATE_INTERNAL_LABEL(LABEL,PREFIX,NUM)\t\\\n-  sprintf (LABEL, \"*%s%d\", PREFIX, NUM)\n-\n-/* This is how to output an assembler line defining a `double' constant.  */\n-\n-#define ASM_OUTPUT_DOUBLE(FILE,VALUE)  \\\n-  fprintf (FILE, \"\\t.double 0d%.20e\\n\", (VALUE))\n-\n-/* This is how to output an assembler line defining a `float' constant.  */\n-\n-#define ASM_OUTPUT_FLOAT(FILE,VALUE)  \\\n-  fprintf (FILE, \"\\t.float 0f%.20e\\n\", (VALUE))\n-\n-/* This is how to output an assembler line defining an `int' constant.  */\n-\n-#define ASM_OUTPUT_INT(FILE,VALUE)  \\\n-( fprintf (FILE, \"\\t.word \"),\t\t\t\\\n-  output_addr_const (FILE, (VALUE)),\t\t\\\n-  fprintf (FILE, \"\\n\"))\n-\n-/* Likewise for `char' and `short' constants.  */\n-\n-#define ASM_OUTPUT_SHORT(FILE,VALUE)  \\\n-( fprintf (FILE, \"\\t.half \"),\t\t\t\\\n-  output_addr_const (FILE, (VALUE)),\t\t\\\n-  fprintf (FILE, \"\\n\"))\n-\n-#define ASM_OUTPUT_CHAR(FILE,VALUE)  \\\n-( fprintf (FILE, \"\\t.byte \"),\t\t\t\\\n-  output_addr_const (FILE, (VALUE)),\t\t\\\n-  fprintf (FILE, \"\\n\"))\n-\n-/* This is how to output an assembler line for a numeric constant byte.  */\n-\n-#define ASM_OUTPUT_BYTE(FILE,VALUE)  \\\n-  fprintf (FILE, \"\\t.byte 0x%x\\n\", (VALUE))\n-\n-/* This is how to output an insn to push a register on the stack.\n-   It need not be very fast code.  */\n-\n-#define ASM_OUTPUT_REG_PUSH(FILE,REGNO)  \\\n-  fprintf (FILE, \"\\tsubw $4,sp\\n\\tmovw %s,(sp)\\n\", reg_names[REGNO])\n-\n-/* This is how to output an insn to pop a register from the stack.\n-   It need not be very fast code.  */\n-\n-#define ASM_OUTPUT_REG_POP(FILE,REGNO)  \\\n-  fprintf (FILE, \"\\tmovw (sp),%s\\n\\taddw $4,sp\\n\", reg_names[REGNO])\n-\n-/* Store in OUTPUT a string (made with alloca) containing\n-   an assembler-name for a local static variable named NAME.\n-   LABELNO is an integer which is different for each call.  */\n-\n-#define ASM_FORMAT_PRIVATE_NAME(OUTPUT, NAME, LABELNO)\t\\\n-( (OUTPUT) = (char *) alloca (strlen ((NAME)) + 10),\t\\\n-  sprintf ((OUTPUT), \"%s.%d\", (NAME), (LABELNO)))\n-\n-/* This is how to output an element of a case-vector that is absolute.  */\n-\n-#define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)  \\\n-  fprintf (FILE, \"\\t.word L%d\\n\", VALUE)\n-\n-/* This is how to output an element of a case-vector that is relative.  */\n-\n-\n-#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL)  \\\n-  fprintf (FILE, \"\\t.word L%d-L%d\\n\", VALUE, REL)\n-\n-/* This is how to output an assembler line\n-   that says to advance the location counter\n-   to a multiple of 2**LOG bytes.\n-\n-   On Pyramids, the text segment must always be word aligned.\n-   On Pyramids, .align takes only args between 2 and 5.\n-  */\n-\n-#define ASM_OUTPUT_ALIGN(FILE,LOG)  \\\n-  fprintf (FILE, \"\\t.align %d\\n\", (LOG) < 2 ? 2 : (LOG))\n-\n-#define ASM_OUTPUT_SKIP(FILE,SIZE)  \\\n-  fprintf (FILE, \"\\t.space %u\\n\", (SIZE))\n-\n-/* This says how to output an assembler line\n-   to define a global common symbol.  */\n-\n-#define ASM_OUTPUT_COMMON(FILE, NAME, SIZE, ROUNDED)  \\\n-( fputs (\".comm \", (FILE)),\t\t\t\\\n-  assemble_name ((FILE), (NAME)),\t\t\\\n-  fprintf ((FILE), \",%u\\n\", (ROUNDED)))\n-\n-/* This says how to output an assembler line\n-   to define a local common symbol.  */\n-\n-#define ASM_OUTPUT_LOCAL(FILE, NAME, SIZE, ROUNDED)  \\\n-( fputs (\".lcomm \", (FILE)),\t\t\t\\\n-  assemble_name ((FILE), (NAME)),\t\t\\\n-  fprintf ((FILE), \",%u\\n\", (ROUNDED)))\n-\n-/* Define the parentheses used to group arithmetic operations\n-   in assembler code.  */\n-\n-#define ASM_OPEN_PAREN \"(\"\n-#define ASM_CLOSE_PAREN \")\"\n-\n-/* Define results of standard character escape sequences.  */\n-#define TARGET_BELL 007\n-#define TARGET_BS 010\n-#define TARGET_TAB 011\n-#define TARGET_NEWLINE 012\n-#define TARGET_VT 013\n-#define TARGET_FF 014\n-#define TARGET_CR 015\n-\n-/* Print operand X (an rtx) in assembler syntax to file FILE.\n-   CODE is a letter or dot (`z' in `%z0') or 0 if no letter was specified.\n-   For `%' followed by punctuation, CODE is the punctuation and X is null.\n-   On the Pyr, we support the conventional CODE characters:\n-\n-   'f' for float insn (print a CONST_DOUBLE as a float rather than in hex)\n-   which are never used. */\n-\n-/* FIXME : should be more robust with CONST_DOUBLE. */\n-\n-#define PRINT_OPERAND(FILE, X, CODE)  \\\n-{ if (GET_CODE (X) == REG)\t\t\t\t\t\t\\\n-    fprintf (FILE, \"%s\", reg_names [REGNO (X) + ((CODE) == 'R')]);\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  else if (GET_CODE (X) == MEM)\t\t\t\t\t\t\\\n-    output_address (XEXP (X, 0));\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  else if (GET_CODE (X) == CONST_DOUBLE && GET_MODE (X) == SFmode)\t\\\n-    { union { double d; int i[2]; } u;\t\t\t\t\t\\\n-      union { float f; int i; } u1;\t\t\t\t\t\\\n-      u.i[0] = CONST_DOUBLE_LOW (X); u.i[1] = CONST_DOUBLE_HIGH (X);\t\\\n-      u1.f = u.d;\t\t\t\t\t\t\t\\\n-      if (CODE == 'f')\t\t\t\t\t\t\t\\\n-        fprintf (FILE, \"$0f%.0e\", u1.f);\t\t\t\t\\\n-      else\t\t\t\t\t\t\t\t\\\n-        fprintf (FILE, \"$0x%x\", u1.i); }\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  else if (GET_CODE (X) == CONST_DOUBLE && GET_MODE (X) != VOIDmode)\t\\\n-    { union { double d; int i[2]; } u;\t\t\t\t\t\\\n-      u.i[0] = CONST_DOUBLE_LOW (X); u.i[1] = CONST_DOUBLE_HIGH (X);\t\\\n-      fprintf (FILE, \"$0d%.20e\", u.d); }\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  else if (CODE == 'N')\t\t\t\t\t\t\t\\\n-    switch (GET_CODE (X))\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-      case EQ:\tfputs (\"eq\", FILE);\tbreak;\t\t\t\t\\\n-      case NE:\tfputs (\"ne\", FILE);\tbreak;\t\t\t\t\\\n-      case GT:\t\t\t\t\t\t\t\t\\\n-      case GTU:\tfputs (\"gt\", FILE);\tbreak;\t\t\t\t\\\n-      case LT:\t\t\t\t\t\t\t\t\\\n-      case LTU:\tfputs (\"lt\", FILE);\tbreak;\t\t\t\t\\\n-      case GE:\t\t\t\t\t\t\t\t\\\n-      case GEU:\tfputs (\"ge\", FILE);\tbreak;\t\t\t\t\\\n-      case LE:\t\t\t\t\t\t\t\t\\\n-      case LEU:\tfputs (\"le\", FILE);\tbreak;\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  else if (CODE == 'C')\t\t\t\t\t\t\t\\\n-    switch (GET_CODE (X))\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-      case EQ:\tfputs (\"ne\", FILE);\tbreak;\t\t\t\t\\\n-      case NE:\tfputs (\"eq\", FILE);\tbreak;\t\t\t\t\\\n-      case GT:\t\t\t\t\t\t\t\t\\\n-      case GTU:\tfputs (\"le\", FILE);\tbreak;\t\t\t\t\\\n-      case LT:\t\t\t\t\t\t\t\t\\\n-      case LTU:\tfputs (\"ge\", FILE);\tbreak;\t\t\t\t\\\n-      case GE:\t\t\t\t\t\t\t\t\\\n-      case GEU:\tfputs (\"lt\", FILE);\tbreak;\t\t\t\t\\\n-      case LE:\t\t\t\t\t\t\t\t\\\n-      case LEU:\tfputs (\"gt\", FILE);\tbreak;\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  else if (CODE == 'R')\t\t\t\t\t\t\t\\\n-    switch (GET_CODE (X))\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-      case EQ:\tfputs (\"eq\", FILE);\tbreak;\t\t\t\t\\\n-      case NE:\tfputs (\"ne\", FILE);\tbreak;\t\t\t\t\\\n-      case GT:\t\t\t\t\t\t\t\t\\\n-      case GTU:\tfputs (\"lt\", FILE);\tbreak;\t\t\t\t\\\n-      case LT:\t\t\t\t\t\t\t\t\\\n-      case LTU:\tfputs (\"gt\", FILE);\tbreak;\t\t\t\t\\\n-      case GE:\t\t\t\t\t\t\t\t\\\n-      case GEU:\tfputs (\"le\", FILE);\tbreak;\t\t\t\t\\\n-      case LE:\t\t\t\t\t\t\t\t\\\n-      case LEU:\tfputs (\"ge\", FILE);\tbreak;\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\t\\\n-  else { putc ('$', FILE); output_addr_const (FILE, X); }\t\t\\\n-}\n-\n-/* Print a memory operand whose address is ADDR, on file FILE.  */\n-/* This is horrendously complicated.  */\n-#define PRINT_OPERAND_ADDRESS(FILE, ADDR)  \\\n-{\t\t\t\t\t\t\t\t\t\\\n-  register rtx reg1, reg2, breg, ireg;\t\t\t\t\t\\\n-  register rtx addr = ADDR;\t\t\t\t\t\t\\\n-  rtx offset, scale;\t\t\t\t\t\t\t\\\n- retry:\t\t\t\t\t\t\t\t\t\\\n-  switch (GET_CODE (addr))\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-    case MEM:\t\t\t\t\t\t\t\t\\\n-      fprintf (stderr, \"bad Mem \"); debug_rtx (addr);\t\t\t\\\n-      addr = XEXP (addr, 0);\t\t\t\t\t\t\\\n-      abort ();\t\t\t\t\t\t\t\t\\\n-    case REG:\t\t\t\t\t\t\t\t\\\n-      fprintf (FILE, \"(%s)\", reg_names [REGNO (addr)]);\t\t\t\\\n-      break;\t\t\t\t\t\t\t\t\\\n-    case PLUS:\t\t\t\t\t\t\t\t\\\n-      reg1 = 0;\treg2 = 0;\t\t\t\t\t\t\\\n-      ireg = 0;\tbreg = 0;\t\t\t\t\t\t\\\n-      offset = 0;\t\t\t\t\t\t\t\\\n-      if (CONSTANT_ADDRESS_P (XEXP (addr, 0))\t\t\t\t\\\n-\t  || GET_CODE (XEXP (addr, 0)) == MEM)\t\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  offset = XEXP (addr, 0);\t\t\t\t\t\\\n-\t  addr = XEXP (addr, 1);\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-      else if (CONSTANT_ADDRESS_P (XEXP (addr, 1))\t\t\t\\\n-\t       || GET_CODE (XEXP (addr, 1)) == MEM)\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  offset = XEXP (addr, 1);\t\t\t\t\t\\\n-\t  addr = XEXP (addr, 0);\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-      if (GET_CODE (addr) != PLUS) ;\t\t\t\t\t\\\n-      else if (GET_CODE (XEXP (addr, 0)) == MULT)\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  reg1 = XEXP (addr, 0);\t\t\t\t\t\\\n-\t  addr = XEXP (addr, 1);\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-      else if (GET_CODE (XEXP (addr, 1)) == MULT)\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  reg1 = XEXP (addr, 1);\t\t\t\t\t\\\n-\t  addr = XEXP (addr, 0);\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-      else if (GET_CODE (XEXP (addr, 0)) == REG)\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  reg1 = XEXP (addr, 0);\t\t\t\t\t\\\n-\t  addr = XEXP (addr, 1);\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-      else if (GET_CODE (XEXP (addr, 1)) == REG)\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  reg1 = XEXP (addr, 1);\t\t\t\t\t\\\n-\t  addr = XEXP (addr, 0);\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-      if (GET_CODE (addr) == REG || GET_CODE (addr) == MULT)\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  if (reg1 == 0)\t\t\t\t\t\t\\\n-\t    reg1 = addr;\t\t\t\t\t\t\\\n-          else\t\t\t\t\t\t\t\t\\\n-\t    reg2 = addr;\t\t\t\t\t\t\\\n-\t  addr = 0;\t\t\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-      if (offset != 0) \t\t\t\t\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  if (addr != 0) {\t\t\t\t\t\t\\\n-\t    fprintf (stderr, \"\\nBad addr \"); debug_rtx (addr);\t\t\\\n-\t    abort ();}\t\t\t\t\t\t\t\\\n-\t  addr = offset;\t\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-      if (reg1 != 0 && GET_CODE (reg1) == MULT)\t\t\t\t\\\n-\t{ breg = reg2; ireg = reg1; }\t\t\t\t\t\\\n-      else if (reg2 != 0 && GET_CODE (reg2) == MULT)\t\t\t\\\n-\t{ breg = reg1; ireg = reg2; }\t\t\t\t\t\\\n-      else if (reg2 != 0 || GET_CODE (addr) == MEM)\t\t\t\\\n-\t{ breg = reg2; ireg = reg1; }\t\t\t\t\t\\\n-      else\t\t\t\t\t\t\t\t\\\n-\t{ breg = reg1; ireg = reg2; }\t\t\t\t\t\\\n-      if (addr != 0)\t\t\t\t\t\t\t\\\n-\toutput_address (offset);\t\t\t\t\t\\\n-      if (breg != 0)\t\t\t\t\t\t\t\\\n-\t{ if (GET_CODE (breg) != REG)\t\t\t\t\t\\\n-\t    {\t\t\t\t\t\t\t\t\\\n-\t      fprintf (stderr, \"bad Breg\"); debug_rtx (addr);\t\t\\\n-\t      abort ();\t\t\t\t\t\t\t\\\n-\t    }\t\t\t\t\t\t\t\t\\\n-\t  fprintf (FILE, \"(%s)\", reg_names[REGNO (breg)]); }\t\t\\\n-      if (ireg != 0)\t\t\t\t\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  if (GET_CODE (ireg) == MULT)\t\t\t\t\t\\\n-\t    {\t\t\t\t\t\t\t\t\\\n-\t      scale = XEXP (ireg, 1);\t\t\t\t\t\\\n-\t      ireg = XEXP (ireg, 0);\t\t\t\t\t\\\n-\t      if (GET_CODE (ireg) != REG)\t\t\t\t\\\n-\t        { register rtx tem;\t\t\t\t\t\\\n-\t\t  tem = ireg; ireg = scale; scale = tem;\t\t\\\n-\t        }\t\t\t\t\t\t\t\\\n- \t      if (GET_CODE (ireg) != REG) {\t\t\t\t\\\n-\t\t      fprintf (stderr, \"bad idx \"); debug_rtx (addr);\t\\\n-\t\tabort (); }\t\t\t\t\t\t\\\n-\t      if ((GET_CODE (scale) == CONST_INT) && (INTVAL(scale) >= 1))\\\n-\t\tfprintf (FILE, \"[%s*0x%x]\", reg_names[REGNO (ireg)],\t\\\n-\t\t\t INTVAL(scale));\t\t\t\t\\\n-\t      else\t\t\t\t\t\t\t\\\n-\t\tfprintf (FILE, \"[%s*1]\", reg_names[REGNO (ireg)]);\t\\\n- \t    } \t\t\t\t\t\t\t\t\\\n-\t  else if (GET_CODE (ireg) == REG)\t\t\t\t\\\n-\t      fprintf (FILE, \"[%s*1]\", reg_names[REGNO (ireg)]);\t\\\n-\t  else\t\t\t\t\t\t\t\t\\\n-\t    {\t\t\t\t\t\t\t\t\\\n-\t      fprintf (stderr, \"Not indexed at all!\"); debug_rtx (addr);\\\n-\t      abort ();\t\t\t\t\t\t\t\\\n-\t    }\t\t\t\t\t\t\t\t\\\n-\t }\t\t\t\t\t\t\t\t\\\n-       break;\t\t\t\t\t\t\t\t\\\n-    default:\t\t\t\t\t\t\t\t\\\n-      output_addr_const (FILE, addr);\t\t\t\t\t\\\n-   }\t\t\t\t\t\t\t\t\t\\\n-}"}, {"sha": "efd7bce5a1a75d7351de29299f5c6de99b4c0f94", "filename": "gcc/config/pyr/pyr.md", "status": "removed", "additions": 0, "deletions": 1360, "changes": 1360, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7b4171a5b8a655097812307bbe261032dfbe366/gcc%2Fconfig%2Fpyr%2Fpyr.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7b4171a5b8a655097812307bbe261032dfbe366/gcc%2Fconfig%2Fpyr%2Fpyr.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpyr%2Fpyr.md?ref=a7b4171a5b8a655097812307bbe261032dfbe366", "patch": "@@ -1,1360 +0,0 @@\n-;; GNU C machine description for Pyramid 90x, 9000, MIServer Series\n-;; Copyright (C) 1989, 90, 95, 97, 98, 1999 Free Software Foundation, Inc.\n-\n-;; This file is part of GNU CC.\n-\n-;; GNU CC is free software; you can redistribute it and/or modify\n-;; it under the terms of the GNU General Public License as published by\n-;; the Free Software Foundation; either version 2, or (at your option)\n-;; any later version.\n-\n-;; GNU CC is distributed in the hope that it will be useful,\n-;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n-;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-;; GNU General Public License for more details.\n-\n-;; You should have received a copy of the GNU General Public License\n-;; along with GNU CC; see the file COPYING.  If not, write to\n-;; the Free Software Foundation, 59 Temple Place - Suite 330,\n-;; Boston, MA 02111-1307, USA.\n-\n-;; Instruction patterns.  When multiple patterns apply,\n-;; the first one in the file is chosen.\n-;;\n-;; See file \"rtl.def\" for documentation on define_insn, match_*, et. al.\n-;;\n-;; cpp macro #define NOTICE_UPDATE_CC in file tm.h handles condition code\n-;; updates for most instructions.\n-\f\n-;; These comments are mostly obsolete.  Written for gcc version 1.XX.\n-;; * Try using define_insn instead of some peepholes in more places.\n-;; * Set REG_NOTES:REG_EQUIV for cvt[bh]w loads.  This would make the\n-;;   backward scan in sign_extend needless.\n-;; * Match (pc) (label_ref) case in peephole patterns.\n-;; * Should optimize\n-;;   \"cmpX op1,op2;  b{eq,ne} LY;  ucmpX op1.op2;  b{lt,le,gt,ge} LZ\"\n-;;   to\n-;;   \"ucmpX op1,op2;  b{eq,ne} LY;  b{lt,le,gt,ge} LZ\"\n-;;   by pre-scanning insn and running notice_update_cc for them.\n-;; * Is it necessary to do copy_rtx in the test and compare patterns?\n-;; * Fix true frame pointer omission.\n-;; * Make the jump tables contain branches, not addresses!  This would\n-;;   save us one instruction.\n-;; * Could the complicated scheme for compares be simplified, if we had\n-;;   no named cmpqi or cmphi patterns, and instead anonymous patterns for\n-;;   the less-than-word compare cases pyr can handle???\n-;; * The jump insn seems to accept more than just IR addressing.  Would\n-;;   we win by telling GCC?  Or can we use movw into the global reg which\n-;;   is a synonym for pc?\n-;; * More DImode patterns.\n-;; * Scan backwards in \"zero_extendhisi2\", \"zero_extendqisi2\" to find out\n-;;   if the extension can be omitted.\n-;; * \"divmodsi\" with Pyramid \"ediv\" insn.  Is it possible in rtl??\n-;; * Would \"rcsp tmpreg; u?cmp[bh] op1_regdispl(tmpreg),op2\" win in\n-;;   comparison with the two extensions and single test generated now?\n-;;   The rcsp insn could be expanded, and moved out of loops by the\n-;;   optimizer, making 1 (64 bit) insn of 3 (32 bit) insns in loops.\n-;;   The rcsp insn could be followed by an add insn, making non-displacement\n-;;   IR addressing sufficient.\n-\n-;______________________________________________________________________\n-;\n-;\tTest and Compare Patterns.\n-;______________________________________________________________________\n-\n-; The argument for the rather complicated test and compare expansion\n-; scheme, is the irregular pyramid instructions for these operations.\n-; 1) Pyramid has different signed and unsigned compares.  2) HImode\n-; and QImode integers are memory-memory and immediate-memory only.  3)\n-; Unsigned HImode compares doesn't exist.  4) Only certain\n-; combinations of addresses are allowed for memory-memory compares.\n-; Whenever necessary, in order to fulfill these addressing\n-; constraints, the compare operands are swapped.\n-\n-(define_expand \"tstsi\"\n-  [(set (cc0)\n-\t(match_operand:SI 0 \"general_operand\" \"\"))]\n-  \"\" \"operands[0] = force_reg (SImode, operands[0]);\")\n-\n-(define_insn \"\"\n-  [(set (cc0)\n-\t(compare (match_operand:SI 0 \"memory_operand\" \"m\")\n-\t\t (match_operand:SI 1 \"memory_operand\" \"m\")))]\n-  \"weird_memory_memory (operands[0], operands[1])\"\n-  \"*\n-{\n-  rtx br_insn = NEXT_INSN (insn);\n-  RTX_CODE br_code;\n-\n-  if (GET_CODE (br_insn) != JUMP_INSN)\n-    abort();\n-  br_code =  GET_CODE (XEXP (XEXP (PATTERN (br_insn), 1), 0));\n-\n-  weird_memory_memory (operands[0], operands[1]);\n-\n-  if (swap_operands)\n-    {\n-      cc_status.flags = CC_REVERSED;\n-      if (TRULY_UNSIGNED_COMPARE_P (br_code))\n-\t{\n-\t  cc_status.mdep = CC_VALID_FOR_UNSIGNED;\n-\t  return \\\"ucmpw %0,%1\\\";\n-\t}\n-      return \\\"cmpw %0,%1\\\";\n-    }\n-\n-  if (TRULY_UNSIGNED_COMPARE_P (br_code))\n-    {\n-      cc_status.mdep = CC_VALID_FOR_UNSIGNED;\n-      return \\\"ucmpw %1,%0\\\";\n-    }\n-  return \\\"cmpw %1,%0\\\";\n-}\")\n-\n-(define_insn \"cmpsi\"\n-  [(set (cc0)\n-\t(compare (match_operand:SI 0 \"nonimmediate_operand\" \"r,g\")\n-\t\t (match_operand:SI 1 \"general_operand\" \"g,r\")))]\n-  \"\"\n-  \"*\n-{\n-  rtx br_insn = NEXT_INSN (insn);\n-  RTX_CODE br_code;\n-\n-  if (GET_CODE (br_insn) != JUMP_INSN)\n-    abort();\n-  br_code =  GET_CODE (XEXP (XEXP (PATTERN (br_insn), 1), 0));\n-\n-  if (which_alternative != 0)\n-    {\n-      cc_status.flags = CC_REVERSED;\n-      if (TRULY_UNSIGNED_COMPARE_P (br_code))\n-\t{\n-\t  cc_status.mdep = CC_VALID_FOR_UNSIGNED;\n-\t  return \\\"ucmpw %0,%1\\\";\n-\t}\n-      return \\\"cmpw %0,%1\\\";\n-    }\n-\n-  if (TRULY_UNSIGNED_COMPARE_P (br_code))\n-    {\n-      cc_status.mdep = CC_VALID_FOR_UNSIGNED;\n-      return \\\"ucmpw %1,%0\\\";\n-    }\n-  return \\\"cmpw %1,%0\\\";\n-}\")\n-\n-(define_insn \"\"\n-  [(set (cc0)\n-\t(match_operand:SI 0 \"nonimmediate_operand\" \"r\"))]\n-  \"\"\n-  \"*\n-{\n-#if 0\n-  cc_status.flags |= CC_NO_OVERFLOW;\n-  return \\\"cmpw $0,%0\\\";\n-#endif\n-  rtx br_insn = NEXT_INSN (insn);\n-  RTX_CODE br_code;\n-\n-  if (GET_CODE (br_insn) != JUMP_INSN)\n-    abort();\n-  br_code =  GET_CODE (XEXP (XEXP (PATTERN (br_insn), 1), 0));\n-\n-  if (TRULY_UNSIGNED_COMPARE_P (br_code))\n-    {\n-      cc_status.mdep = CC_VALID_FOR_UNSIGNED;\n-      return \\\"ucmpw $0,%0\\\";\n-    }\n-  return \\\"mtstw %0,%0\\\";\n-}\")\n-\n-(define_expand \"cmphi\"\n-  [(set (cc0)\n-\t(compare (match_operand:HI 0 \"nonimmediate_operand\" \"\")\n-\t\t (match_operand:HI 1 \"general_operand\" \"\")))]\n-  \"\"\n-  \"\n-{\n-  extern rtx test_op0, test_op1;  extern enum machine_mode test_mode;\n-  test_op0 = copy_rtx (operands[0]);\n-  test_op1 = copy_rtx (operands[1]);\n-  test_mode = HImode;\n-  DONE;\n-}\")\n-\n-(define_expand \"tsthi\"\n-  [(set (cc0)\n-\t(match_operand:HI 0 \"nonimmediate_operand\" \"\"))]\n-  \"\"\n-  \"\n-{\n-  extern rtx test_op0;  extern enum machine_mode test_mode;\n-  test_op0 = copy_rtx (operands[0]);\n-  test_mode = HImode;\n-  DONE;\n-}\")\n-\n-(define_insn \"\"\n-  [(set (cc0)\n-\t(compare (match_operand:HI 0 \"memory_operand\" \"m\")\n-\t\t (match_operand:HI 1 \"memory_operand\" \"m\")))]\n-  \"(!TRULY_UNSIGNED_COMPARE_P (GET_CODE (XEXP (SET_SRC (PATTERN (NEXT_INSN (insn))), 0))))\n-   && weird_memory_memory (operands[0], operands[1])\"\n-  \"*\n-{\n-  rtx br_insn = NEXT_INSN (insn);\n-\n-  if (GET_CODE (br_insn) != JUMP_INSN)\n-    abort();\n-\n-  weird_memory_memory (operands[0], operands[1]);\n-\n-  if (swap_operands)\n-    {\n-      cc_status.flags = CC_REVERSED;\n-      return \\\"cmph %0,%1\\\";\n-    }\n-\n-  return \\\"cmph %1,%0\\\";\n-}\")\n-\n-(define_insn \"\"\n-  [(set (cc0)\n-\t(compare (match_operand:HI 0 \"nonimmediate_operand\" \"r,m\")\n-\t\t (match_operand:HI 1 \"nonimmediate_operand\" \"m,r\")))]\n-  \"(!TRULY_UNSIGNED_COMPARE_P (GET_CODE (XEXP (SET_SRC (PATTERN (NEXT_INSN (insn))), 0))))\n-   && ((GET_CODE (operands[0]) == MEM) != (GET_CODE (operands[1]) == MEM))\"\n-  \"*\n-{\n-  rtx br_insn = NEXT_INSN (insn);\n-\n-  if (GET_CODE (br_insn) != JUMP_INSN)\n-    abort();\n-\n-  if (which_alternative != 0)\n-    {\n-      cc_status.flags = CC_REVERSED;\n-      return \\\"cmph %0,%1\\\";\n-    }\n-\n-  return \\\"cmph %1,%0\\\";\n-}\")\n-\n-(define_expand \"cmpqi\"\n-  [(set (cc0)\n-\t(compare (match_operand:QI 0 \"nonimmediate_operand\" \"\")\n-\t\t (match_operand:QI 1 \"general_operand\" \"\")))]\n-  \"\"\n-  \"\n-{\n-  extern rtx test_op0, test_op1;  extern enum machine_mode test_mode;\n-  test_op0 = copy_rtx (operands[0]);\n-  test_op1 = copy_rtx (operands[1]);\n-  test_mode = QImode;\n-  DONE;\n-}\")\n-\n-(define_expand \"tstqi\"\n-  [(set (cc0)\n-\t(match_operand:QI 0 \"nonimmediate_operand\" \"\"))]\n-  \"\"\n-  \"\n-{\n-  extern rtx test_op0;  extern enum machine_mode test_mode;\n-  test_op0 = copy_rtx (operands[0]);\n-  test_mode = QImode;\n-  DONE;\n-}\")\n-\n-(define_insn \"\"\n-  [(set (cc0)\n-\t(compare (match_operand:QI 0 \"memory_operand\" \"m\")\n-\t\t (match_operand:QI 1 \"memory_operand\" \"m\")))]\n-  \"weird_memory_memory (operands[0], operands[1])\"\n-  \"*\n-{\n-  rtx br_insn = NEXT_INSN (insn);\n-  RTX_CODE br_code;\n-\n-  if (GET_CODE (br_insn) != JUMP_INSN)\n-    abort();\n-  br_code =  GET_CODE (XEXP (XEXP (PATTERN (br_insn), 1), 0));\n-\n-  weird_memory_memory (operands[0], operands[1]);\n-\n-  if (swap_operands)\n-    {\n-      cc_status.flags = CC_REVERSED;\n-      if (TRULY_UNSIGNED_COMPARE_P (br_code))\n-\t{\n-\t  cc_status.mdep = CC_VALID_FOR_UNSIGNED;\n-\t  return \\\"ucmpb %0,%1\\\";\n-\t}\n-      return \\\"cmpb %0,%1\\\";\n-    }\n-\n-  if (TRULY_UNSIGNED_COMPARE_P (br_code))\n-    {\n-      cc_status.mdep = CC_VALID_FOR_UNSIGNED;\n-      return \\\"ucmpb %1,%0\\\";\n-    }\n-  return \\\"cmpb %1,%0\\\";\n-}\")\n-\n-(define_insn \"\"\n-  [(set (cc0)\n-\t(compare (match_operand:QI 0 \"nonimmediate_operand\" \"r,m\")\n-\t\t (match_operand:QI 1 \"nonimmediate_operand\" \"m,r\")))]\n-  \"((GET_CODE (operands[0]) == MEM) != (GET_CODE (operands[1]) == MEM))\"\n-  \"*\n-{\n-  rtx br_insn = NEXT_INSN (insn);\n-  RTX_CODE br_code;\n-\n-  if (GET_CODE (br_insn) != JUMP_INSN)\n-    abort();\n-  br_code =  GET_CODE (XEXP (XEXP (PATTERN (br_insn), 1), 0));\n-\n-  if (which_alternative != 0)\n-    {\n-      cc_status.flags = CC_REVERSED;\n-      if (TRULY_UNSIGNED_COMPARE_P (br_code))\n-\t{\n-\t  cc_status.mdep = CC_VALID_FOR_UNSIGNED;\n-\t  return \\\"ucmpb %0,%1\\\";\n-\t}\n-      return \\\"cmpb %0,%1\\\";\n-    }\n-\n-  if (TRULY_UNSIGNED_COMPARE_P (br_code))\n-    {\n-      cc_status.mdep = CC_VALID_FOR_UNSIGNED;\n-      return \\\"ucmpb %1,%0\\\";\n-    }\n-  return \\\"cmpb %1,%0\\\";\n-}\")\n-\n-(define_expand \"bgt\"\n-  [(set (pc) (if_then_else (gt (cc0) (const_int 0))\n-\t\t\t   (label_ref (match_operand 0 \"\" \"\")) (pc)))]\n-  \"\" \"extend_and_branch (SIGN_EXTEND);\")\n-\n-(define_expand \"blt\"\n-  [(set (pc) (if_then_else (lt (cc0) (const_int 0))\n-\t\t\t   (label_ref (match_operand 0 \"\" \"\")) (pc)))]\n-  \"\" \"extend_and_branch (SIGN_EXTEND);\")\n-\n-(define_expand \"bge\"\n-  [(set (pc) (if_then_else (ge (cc0) (const_int 0))\n-\t\t\t   (label_ref (match_operand 0 \"\" \"\")) (pc)))]\n-  \"\" \"extend_and_branch (SIGN_EXTEND);\")\n-\n-(define_expand \"ble\"\n-  [(set (pc) (if_then_else (le (cc0) (const_int 0))\n-\t\t\t   (label_ref (match_operand 0 \"\" \"\")) (pc)))]\n-  \"\" \"extend_and_branch (SIGN_EXTEND);\")\n-\n-(define_expand \"beq\"\n-  [(set (pc) (if_then_else (eq (cc0) (const_int 0))\n-\t\t\t   (label_ref (match_operand 0 \"\" \"\")) (pc)))]\n-  \"\" \"extend_and_branch (SIGN_EXTEND);\")\n-\n-(define_expand \"bne\"\n-  [(set (pc) (if_then_else (ne (cc0) (const_int 0))\n-\t\t\t   (label_ref (match_operand 0 \"\" \"\")) (pc)))]\n-  \"\" \"extend_and_branch (SIGN_EXTEND);\")\n-\n-(define_expand \"bgtu\"\n-  [(set (pc) (if_then_else (gtu (cc0) (const_int 0))\n-\t\t\t   (label_ref (match_operand 0 \"\" \"\")) (pc)))]\n-  \"\" \"extend_and_branch (ZERO_EXTEND);\")\n-\n-(define_expand \"bltu\"\n-  [(set (pc) (if_then_else (ltu (cc0) (const_int 0))\n-\t\t\t   (label_ref (match_operand 0 \"\" \"\")) (pc)))]\n-  \"\" \"extend_and_branch (ZERO_EXTEND);\")\n-\n-(define_expand \"bgeu\"\n-  [(set (pc) (if_then_else (geu (cc0) (const_int 0))\n-\t\t\t   (label_ref (match_operand 0 \"\" \"\")) (pc)))]\n-  \"\" \"extend_and_branch (ZERO_EXTEND);\")\n-\n-(define_expand \"bleu\"\n-  [(set (pc) (if_then_else (leu (cc0) (const_int 0))\n-\t\t\t   (label_ref (match_operand 0 \"\" \"\")) (pc)))]\n-  \"\" \"extend_and_branch (ZERO_EXTEND);\")\n-\n-(define_insn \"cmpdf\"\n-  [(set (cc0)\n-\t(compare (match_operand:DF 0 \"register_operand\" \"r\")\n-\t\t (match_operand:DF 1 \"register_operand\" \"r\")))]\n-  \"\"\n-  \"cmpd %1,%0\")\n-\n-(define_insn \"cmpsf\"\n-  [(set (cc0)\n-\t(compare (match_operand:SF 0 \"register_operand\" \"r\")\n-\t\t (match_operand:SF 1 \"register_operand\" \"r\")))]\n-  \"\"\n-  \"cmpf %1,%0\")\n-\n-(define_insn \"tstdf\"\n-  [(set (cc0)\n-       \t(match_operand:DF 0 \"register_operand\" \"r\"))]\n-  \"\"\n-  \"mtstd %0,%0\")\n-\n-(define_insn \"tstsf\"\n-  [(set (cc0)\n-       \t(match_operand:SF 0 \"register_operand\" \"r\"))]\n-  \"\"\n-  \"mtstf %0,%0\")\n-\f\n-;______________________________________________________________________\n-;\n-;\tFixed-point Arithmetic.\n-;______________________________________________________________________\n-\n-(define_insn \"addsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r,!r\")\n-\t(plus:SI (match_operand:SI 1 \"general_operand\" \"%0,r\")\n-\t\t (match_operand:SI 2 \"general_operand\" \"g,rJ\")))]\n-  \"\"\n-  \"*\n-{\n-  if (which_alternative == 0)\n-    return (GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) == 32\n-\t    ? \\\"subw %n2,%0\\\" : \\\"addw %2,%0\\\");\n-  else\n-    {\n-      forget_cc_if_dependent (operands[0]);\n-      return \\\"mova %a2[%1*1],%0\\\";\n-    }\n-}\")\n-\n-(define_insn \"subsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n-\t(minus:SI (match_operand:SI 1 \"general_operand\" \"0,g\")\n-\t\t  (match_operand:SI 2 \"general_operand\" \"g,0\")))]\n-  \"\"\n-  \"* return (which_alternative == 0) ? \\\"subw %2,%0\\\" : \\\"rsubw %1,%0\\\";\")\n-\n-(define_insn \"mulsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(mult:SI (match_operand:SI 1 \"general_operand\" \"%0\")\n-\t\t (match_operand:SI 2 \"general_operand\" \"g\")))]\n-  \"\"\n-  \"mulw %2,%0\")\n-\n-(define_insn \"divsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n-\t(div:SI (match_operand:SI 1 \"general_operand\" \"0,g\")\n-\t\t(match_operand:SI 2 \"general_operand\" \"g,0\")))]\n-  \"\"\n-  \"* return (which_alternative == 0) ? \\\"divw %2,%0\\\" : \\\"rdivw %1,%0\\\";\")\n-\n-(define_insn \"udivsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(udiv:SI (match_operand:SI 1 \"register_operand\" \"0\")\n-\t\t (match_operand:SI 2 \"general_operand\" \"g\")))]\n-  \"\"\n-  \"udivw %2,%0\")\n-\n-(define_insn \"modsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(mod:SI (match_operand:SI 1 \"register_operand\" \"0\")\n-\t\t(match_operand:SI 2 \"general_operand\" \"g\")))]\n-  \"\"\n-  \"modw %2,%0\")\n-\n-(define_insn \"umodsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(umod:SI (match_operand:SI 1 \"register_operand\" \"0\")\n-\t\t (match_operand:SI 2 \"general_operand\" \"g\")))]\n-  \"\"\n-  \"umodw %2,%0\")\n-\n-(define_insn \"negsi2\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(neg:SI (match_operand:SI 1 \"nonimmediate_operand\" \"rm\")))]\n-  \"\"\n-  \"mnegw %1,%0\")\n-\n-(define_insn \"one_cmplsi2\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(not:SI (match_operand:SI 1 \"nonimmediate_operand\" \"rm\")))]\n-  \"\"\n-  \"mcomw %1,%0\")\n-\n-(define_insn \"abssi2\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(abs:SI (match_operand:SI 1 \"nonimmediate_operand\" \"rm\")))]\n-  \"\"\n-  \"mabsw %1,%0\")\n-\f\n-;______________________________________________________________________\n-;\n-;\tFloating-point Arithmetic.\n-;______________________________________________________________________\n-\n-(define_insn \"adddf3\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=r\")\n-\t(plus:DF (match_operand:DF 1 \"register_operand\" \"%0\")\n-\t\t (match_operand:DF 2 \"register_operand\" \"r\")))]\n-  \"\"\n-  \"addd %2,%0\")\n-\n-(define_insn \"addsf3\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=r\")\n-\t(plus:SF (match_operand:SF 1 \"register_operand\" \"%0\")\n-\t\t (match_operand:SF 2 \"register_operand\" \"r\")))]\n-  \"\"\n-  \"addf %2,%0\")\n-\n-(define_insn \"subdf3\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=r\")\n-\t(minus:DF (match_operand:DF 1 \"register_operand\" \"0\")\n-\t\t  (match_operand:DF 2 \"register_operand\" \"r\")))]\n-  \"\"\n-  \"subd %2,%0\")\n-\n-(define_insn \"subsf3\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=r\")\n-\t(minus:SF (match_operand:SF 1 \"register_operand\" \"0\")\n-\t\t  (match_operand:SF 2 \"register_operand\" \"r\")))]\n-  \"\"\n-  \"subf %2,%0\")\n-\n-(define_insn \"muldf3\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=r\")\n-\t(mult:DF (match_operand:DF 1 \"register_operand\" \"%0\")\n-\t\t (match_operand:DF 2 \"register_operand\" \"r\")))]\n-  \"\"\n-  \"muld %2,%0\")\n-\n-(define_insn \"mulsf3\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=r\")\n-\t(mult:SF (match_operand:SF 1 \"register_operand\" \"%0\")\n-\t\t (match_operand:SF 2 \"register_operand\" \"r\")))]\n-  \"\"\n-  \"mulf %2,%0\")\n-\n-(define_insn \"divdf3\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=r\")\n-\t(div:DF (match_operand:DF 1 \"register_operand\" \"0\")\n-\t\t(match_operand:DF 2 \"register_operand\" \"r\")))]\n-  \"\"\n-  \"divd %2,%0\")\n-\n-(define_insn \"divsf3\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=r\")\n-\t(div:SF (match_operand:SF 1 \"register_operand\" \"0\")\n-\t\t(match_operand:SF 2 \"register_operand\" \"r\")))]\n-  \"\"\n-  \"divf %2,%0\")\n-\n-(define_insn \"negdf2\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=r\")\n-\t(neg:DF (match_operand:DF 1 \"register_operand\" \"r\")))]\n-  \"\"\n-  \"mnegd %1,%0\")\n-\n-(define_insn \"negsf2\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=r\")\n-\t(neg:SF (match_operand:SF 1 \"register_operand\" \"r\")))]\n-  \"\"\n-  \"mnegf %1,%0\")\n-\n-(define_insn \"absdf2\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=r\")\n-\t(abs:DF (match_operand:DF 1 \"register_operand\" \"r\")))]\n-  \"\"\n-  \"mabsd %1,%0\")\n-\n-(define_insn \"abssf2\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=r\")\n-\t(abs:SF (match_operand:SF 1 \"register_operand\" \"r\")))]\n-  \"\"\n-  \"mabsf %1,%0\")\n-\f\n-;______________________________________________________________________\n-;\n-;\tLogical and Shift Instructions.\n-;______________________________________________________________________\n-\n-(define_insn \"\"\n-  [(set (cc0)\n-\t(and:SI (match_operand:SI 0 \"general_operand\" \"%r\")\n-\t\t(match_operand:SI 1 \"general_operand\" \"g\")))]\n-  \"\"\n-  \"*\n-{\n-  cc_status.flags |= CC_NO_OVERFLOW;\n-  return \\\"bitw %1,%0\\\";\n-}\")\n-\n-(define_insn \"andsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n-\t(and:SI (match_operand:SI 1 \"general_operand\" \"%0,r\")\n-\t\t(match_operand:SI 2 \"general_operand\" \"g,K\")))]\n-  \"\"\n-  \"*\n-{\n-  if (which_alternative == 0)\n-    return \\\"andw %2,%0\\\";\n-\n-  cc_status.flags = CC_NOT_NEGATIVE;\n-  return (INTVAL (operands[2]) == 255\n-\t  ? \\\"movzbw %1,%0\\\" : \\\"movzhw %1,%0\\\");\n-}\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(and:SI (not:SI (match_operand:SI 1 \"general_operand\" \"g\"))\n-\t\t(match_operand:SI 2 \"register_operand\" \"0\")))]\n-  \"\"\n-  \"bicw %1,%0\")\n-\n-(define_insn \"iorsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(ior:SI (match_operand:SI 1 \"general_operand\" \"%0\")\n-\t\t(match_operand:SI 2 \"general_operand\" \"g\")))]\n-  \"\"\n-  \"orw %2,%0\")\n-\n-(define_insn \"xorsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(xor:SI (match_operand:SI 1 \"general_operand\" \"%0\")\n-\t\t(match_operand:SI 2 \"general_operand\" \"g\")))]\n-  \"\"\n-  \"xorw %2,%0\")\n-\n-; The arithmetic left shift instructions work strangely on pyramids.\n-; They fail to modify the sign bit.  Therefore, use logic shifts.\n-\n-(define_insn \"ashlsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(ashift:SI (match_operand:SI 1 \"register_operand\" \"0\")\n-\t\t   (match_operand:SI 2 \"general_operand\" \"rnm\")))]\n-  \"\"\n-  \"*\n-{\n-  extern char *output_shift ();\n-  return output_shift (\\\"lshlw %2,%0\\\", operands[2], 32);\n-}\")\n-\n-(define_insn \"ashrsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(ashiftrt:SI (match_operand:SI 1 \"register_operand\" \"0\")\n-\t\t     (match_operand:SI 2 \"general_operand\" \"rnm\")))]\n-  \"\"\n-  \"*\n-{\n-  extern char *output_shift ();\n-  return output_shift (\\\"ashrw %2,%0\\\", operands[2], 32);\n-}\")\n-\n-(define_insn \"ashrdi3\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t(ashiftrt:DI (match_operand:DI 1 \"register_operand\" \"0\")\n-\t\t     (match_operand:SI 2 \"general_operand\" \"rnm\")))]\n-  \"\"\n-  \"*\n-{\n-  extern char *output_shift ();\n-  return output_shift (\\\"ashrl %2,%0\\\", operands[2], 64);\n-}\")\n-\n-(define_insn \"lshrsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(lshiftrt:SI (match_operand:SI 1 \"register_operand\" \"0\")\n-\t\t     (match_operand:SI 2 \"general_operand\" \"rnm\")))]\n-  \"\"\n-  \"*\n-{\n-  extern char *output_shift ();\n-  return output_shift (\\\"lshrw %2,%0\\\", operands[2], 32);\n-}\")\n-\n-(define_insn \"rotlsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(rotate:SI (match_operand:SI 1 \"register_operand\" \"0\")\n-\t\t   (match_operand:SI 2 \"general_operand\" \"rnm\")))]\n-  \"\"\n-  \"*\n-{\n-  extern char *output_shift ();\n-  return output_shift (\\\"rotlw %2,%0\\\", operands[2], 32);\n-}\")\n-\n-(define_insn \"rotrsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(rotatert:SI (match_operand:SI 1 \"register_operand\" \"0\")\n-\t\t     (match_operand:SI 2 \"general_operand\" \"rnm\")))]\n-  \"\"\n-  \"*\n-{\n-  extern char *output_shift ();\n-  return output_shift (\\\"rotrw %2,%0\\\", operands[2], 32);\n-}\")\n-\f\n-;______________________________________________________________________\n-;\n-;\tFixed and Floating Moves.\n-;______________________________________________________________________\n-\n-;; If the destination is a memory operand, indexed source operands are\n-;; disallowed.  Big DImode constants are always loaded into a reg pair,\n-;; although offsettable memory addresses really could be dealt with.\n-\n-(define_insn \"\"\n-  [(set (match_operand:DI 0 \"memory_operand\" \"=m\")\n-\t(match_operand:DI 1 \"nonindexed_operand\" \"gF\"))]\n-  \"(GET_CODE (operands[1]) == CONST_DOUBLE\n-     ? ((CONST_DOUBLE_HIGH (operands[1]) == 0\n-\t && CONST_DOUBLE_LOW (operands[1]) >= 0)\n-\t|| (CONST_DOUBLE_HIGH (operands[1]) == -1\n-\t    && CONST_DOUBLE_LOW (operands[1]) < 0))\n-     : 1)\"\n-  \"*\n-{\n-  if (GET_CODE (operands[1]) == CONST_DOUBLE)\n-    operands[1] = GEN_INT (CONST_DOUBLE_LOW (operands[1]));\n-  return \\\"movl %1,%0\\\";\n-}\")\n-\n-;; Force the destination to a register, so all source operands are allowed.\n-\n-(define_insn \"movdi\"\n-  [(set (match_operand:DI 0 \"general_operand\" \"=r\")\n-\t(match_operand:DI 1 \"general_operand\" \"gF\"))]\n-  \"\"\n-  \"*\n-{\n-  extern char *output_move_double ();\n-  return output_move_double (operands);\n-}\")\n-\n-;; If the destination is a memory address, indexed source operands are\n-;; disallowed.\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"memory_operand\" \"=m\")\n-\t(match_operand:SI 1 \"nonindexed_operand\" \"g\"))]\n-  \"\"\n-  \"movw %1,%0\")\n-\n-;; Force the destination to a register, so all source operands are allowed.\n-\n-(define_insn \"movsi\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=r\")\n-\t(match_operand:SI 1 \"general_operand\" \"g\"))]\n-  \"\"\n-  \"movw %1,%0\")\n-\n-;; If the destination is a memory address, indexed source operands are\n-;; disallowed.\n-\n-(define_insn \"\"\n-  [(set (match_operand:HI 0 \"memory_operand\" \"=m\")\n-\t(match_operand:HI 1 \"nonindexed_operand\" \"g\"))]\n-  \"\"\n-  \"*\n-{\n-  if (REG_P (operands[1]))\n-    return \\\"cvtwh %1,%0\\\";\t\t/* reg -> mem */\n-  else\n-    return \\\"movh %1,%0\\\";\t\t/* mem imm -> mem */\n-}\")\n-\n-;; Force the destination to a register, so all source operands are allowed.\n-\n-(define_insn \"movhi\"\n-  [(set (match_operand:HI 0 \"general_operand\" \"=r\")\n-\t(match_operand:HI 1 \"general_operand\" \"g\"))]\n-  \"\"\n-  \"*\n-{\n-  if (GET_CODE (operands[1]) != MEM)\n-    return \\\"movw %1,%0\\\";\t\t/* reg imm -> reg  */\n-  return \\\"cvthw %1,%0\\\";\t\t/* mem -> reg */\n-}\")\n-\n-;; If the destination is a memory address, indexed source operands are\n-;; disallowed.\n-\n-(define_insn \"\"\n-  [(set (match_operand:QI 0 \"memory_operand\" \"=m\")\n-\t(match_operand:QI 1 \"nonindexed_operand\" \"g\"))]\n-  \"\"\n-  \"*\n-{\n-  if (REG_P (operands[1]))\n-    return \\\"cvtwb %1,%0\\\";\t\t/* reg -> mem */\n-  else\n-    return \\\"movb %1,%0\\\";\t\t/* mem imm -> mem */\n-}\")\n-\n-;; Force the destination to a register, so all source operands are allowed.\n-\n-(define_insn \"movqi\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"=r\")\n-\t(match_operand:QI 1 \"general_operand\" \"g\"))]\n-  \"\"\n-  \"*\n-{\n-  if (GET_CODE (operands[1]) != MEM)\n-    return \\\"movw %1,%0\\\";\t\t/* reg imm -> reg  */\n-  return \\\"cvtbw %1,%0\\\";\t\t/* mem -> reg */\n-}\")\n-\n-;; If the destination is a memory address, indexed source operands are\n-;; disallowed.\n-\n-(define_insn \"\"\n-  [(set (match_operand:DF 0 \"memory_operand\" \"=m\")\n-\t(match_operand:DF 1 \"nonindexed_operand\" \"g\"))]\n-  \"GET_CODE (operands[1]) != CONST_DOUBLE\"\n-  \"movl %1,%0\")\n-\n-;; Force the destination to a register, so all source operands are allowed.\n-\n-(define_insn \"movdf\"\n-  [(set (match_operand:DF 0 \"general_operand\" \"=r\")\n-\t(match_operand:DF 1 \"general_operand\" \"gF\"))]\n-  \"\"\n-  \"*\n-{\n-  extern char *output_move_double ();\n-  return output_move_double (operands);\n-}\")\n-\n-;; If the destination is a memory address, indexed source operands are\n-;; disallowed.\n-\n-(define_insn \"\"\n-  [(set (match_operand:SF 0 \"memory_operand\" \"=m\")\n-\t(match_operand:SF 1 \"nonindexed_operand\" \"g\"))]\n-  \"\"\n-  \"movw %1,%0\")\n-\n-;; Force the destination to a register, so all source operands are allowed.\n-\n-(define_insn \"movsf\"\n-  [(set (match_operand:SF 0 \"general_operand\" \"=r\")\n-\t(match_operand:SF 1 \"general_operand\" \"g\"))]\n-  \"\"\n-  \"movw %1,%0\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(match_operand:QI 1 \"address_operand\" \"p\"))]\n-  \"\"\n-  \"*\n-{\n-  forget_cc_if_dependent (operands[0]);\n-  return \\\"mova %a1,%0\\\";\n-}\")\n-\f\n-;______________________________________________________________________\n-;\n-;\tConversion patterns.\n-;______________________________________________________________________\n-\n-;; The trunc patterns are used only when non compile-time constants are used.\n-\n-(define_insn \"truncsiqi2\"\n-  [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n-\t(truncate:QI (match_operand:SI 1 \"nonimmediate_operand\" \"rm\")))]\n-  \"\"\n-  \"*\n-{\n-  if (REG_P (operands[0]) && REG_P (operands[1])\n-      && REGNO (operands[0]) == REGNO (operands[1]))\n-    {\n-      cc_status = cc_prev_status;\n-      return \\\"\\\";\n-    }\n-  forget_cc_if_dependent (operands[0]);\n-  return \\\"movw %1,%0\\\";\n-}\")\n-\n-(define_insn \"truncsihi2\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n-\t(truncate:HI (match_operand:SI 1 \"nonimmediate_operand\" \"rm\")))]\n-  \"\"\n-  \"*\n-{\n-  if (REG_P (operands[0]) && REG_P (operands[1])\n-      && REGNO (operands[0]) == REGNO (operands[1]))\n-    {\n-      cc_status = cc_prev_status;\n-      return \\\"\\\";\n-    }\n-  forget_cc_if_dependent (operands[0]);\n-  return \\\"movw %1,%0\\\";\n-}\")\n-\n-(define_insn \"extendhisi2\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=r,m\")\n-\t(sign_extend:SI (match_operand:HI 1 \"nonimmediate_operand\" \"rm,r\")))]\n-  \"\"\n-  \"*\n-{\n-  if (optimize && REG_P (operands[0]) && REG_P (operands[1])\n-      && REGNO (operands[0]) == REGNO (operands[1])\n-      && already_sign_extended (insn, HImode, operands[0]))\n-    {\n-      cc_status = cc_prev_status;\n-      return \\\"\\\";\n-    }\n-  return \\\"cvthw %1,%0\\\";\n-}\")\n-\n-(define_insn \"extendqisi2\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=r,m\")\n-\t(sign_extend:SI (match_operand:QI 1 \"nonimmediate_operand\" \"rm,r\")))]\n-  \"\"\n-  \"*\n-{\n-  if (optimize && REG_P (operands[0]) && REG_P (operands[1])\n-      && REGNO (operands[0]) == REGNO (operands[1])\n-      && already_sign_extended (insn, QImode, operands[0]))\n-    {\n-      cc_status = cc_prev_status;\n-      return \\\"\\\";\n-    }\n-  return \\\"cvtbw %1,%0\\\";\n-}\")\n-\n-; Pyramid doesn't have insns *called* \"cvtbh\" or \"movzbh\".\n-; But we can cvtbw/movzbw into a register, where there is no distinction\n-; between words and halfwords.\n-\n-(define_insn \"extendqihi2\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n-\t(sign_extend:HI (match_operand:QI 1 \"nonimmediate_operand\" \"rm\")))]\n-  \"\"\n-  \"cvtbw %1,%0\")\n-\n-(define_insn \"zero_extendhisi2\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(zero_extend:SI (match_operand:HI 1 \"nonimmediate_operand\" \"rm\")))]\n-  \"\"\n-  \"*\n-{\n-  cc_status.flags = CC_NOT_NEGATIVE;\n-  return \\\"movzhw %1,%0\\\";\n-}\")\n-\n-(define_insn \"zero_extendqisi2\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(zero_extend:SI (match_operand:QI 1 \"nonimmediate_operand\" \"rm\")))]\n-  \"\"\n-  \"*\n-{\n-  cc_status.flags = CC_NOT_NEGATIVE;\n-  return \\\"movzbw %1,%0\\\";\n-}\")\n-\n-(define_insn \"zero_extendqihi2\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n-\t(zero_extend:HI (match_operand:QI 1 \"nonimmediate_operand\" \"rm\")))]\n-  \"\"\n-  \"*\n-{\n-  cc_status.flags = CC_NOT_NEGATIVE;\n-  return \\\"movzbw %1,%0\\\";\n-}\")\n-\n-(define_insn \"extendsfdf2\"\n-  [(set (match_operand:DF 0 \"general_operand\" \"=&r,m\")\n-\t(float_extend:DF (match_operand:SF 1 \"nonimmediate_operand\" \"rm,r\")))]\n-  \"\"\n-  \"cvtfd %1,%0\")\n-\n-(define_insn \"truncdfsf2\"\n-  [(set (match_operand:SF 0 \"general_operand\" \"=&r,m\")\n-\t(float_truncate:SF (match_operand:DF 1 \"nonimmediate_operand\" \"rm,r\")))]\n-  \"\"\n-  \"cvtdf %1,%0\")\n-\n-(define_insn \"floatsisf2\"\n-  [(set (match_operand:SF 0 \"general_operand\" \"=&r,m\")\n-\t(float:SF (match_operand:SI 1 \"nonimmediate_operand\" \"rm,r\")))]\n-  \"\"\n-  \"cvtwf %1,%0\")\n-\n-(define_insn \"floatsidf2\"\n-  [(set (match_operand:DF 0 \"general_operand\" \"=&r,m\")\n-\t(float:DF (match_operand:SI 1 \"nonimmediate_operand\" \"rm,r\")))]\n-  \"\"\n-  \"cvtwd %1,%0\")\n-\n-(define_insn \"fix_truncsfsi2\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=&r,m\")\n-\t(fix:SI (fix:SF (match_operand:SF 1 \"nonimmediate_operand\" \"rm,r\"))))]\n-  \"\"\n-  \"cvtfw %1,%0\")\n-\n-(define_insn \"fix_truncdfsi2\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=&r,m\")\n-\t(fix:SI (fix:DF (match_operand:DF 1 \"nonimmediate_operand\" \"rm,r\"))))]\n-  \"\"\n-  \"cvtdw %1,%0\")\n-\f\n-;______________________________________________________________________\n-;\n-;\tFlow Control Patterns.\n-;______________________________________________________________________\n-\n-;; Prefer \"br\" to \"jump\" for unconditional jumps, since it's faster.\n-;; (The assembler can manage with out-of-range branches.)\n-\n-(define_insn \"jump\"\n-  [(set (pc)\n-\t(label_ref (match_operand 0 \"\" \"\")))]\n-  \"\"\n-  \"br %l0\")\n-\n-(define_insn \"\"\n-  [(set (pc)\n-\t(if_then_else (match_operator 0 \"relop\" [(cc0) (const_int 0)])\n-\t\t      (label_ref (match_operand 1 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"*\n-{\n-  if (optimize)\n-    switch (GET_CODE (operands[0]))\n-      {\n-      case EQ: case NE:\n-\tbreak;\n-      case LT: case LE: case GE: case GT:\n-\tif (cc_prev_status.mdep == CC_VALID_FOR_UNSIGNED)\n-\t  return 0;\n-\tbreak;\n-      case LTU: case LEU: case GEU: case GTU:\n-\tif (cc_prev_status.mdep != CC_VALID_FOR_UNSIGNED)\n-\t  return 0;\n-\tbreak;\n-      }\n-\n-  return \\\"b%N0 %l1\\\";\n-}\")\n-\n-(define_insn \"\"\n-  [(set (pc)\n-\t(if_then_else (match_operator 0 \"relop\" [(cc0) (const_int 0)])\n-\t\t      (pc)\n-\t\t      (label_ref (match_operand 1 \"\" \"\"))))]\n-  \"\"\n-  \"*\n-{\n-  if (optimize)\n-    switch (GET_CODE (operands[0]))\n-      {\n-      case EQ: case NE:\n-\tbreak;\n-      case LT: case LE: case GE: case GT:\n-\tif (cc_prev_status.mdep == CC_VALID_FOR_UNSIGNED)\n-\t  return 0;\n-\tbreak;\n-      case LTU: case LEU: case GEU: case GTU:\n-\tif (cc_prev_status.mdep != CC_VALID_FOR_UNSIGNED)\n-\t  return 0;\n-\tbreak;\n-      }\n-\n-  return \\\"b%C0 %l1\\\";\n-}\")\n-\n-(define_insn \"call\"\n-  [(call (match_operand:QI 0 \"memory_operand\" \"m\")\n-\t (match_operand:SI 1 \"immediate_operand\" \"n\"))]\n-  \"\"\n-  \"call %0\")\n-\n-(define_insn \"call_value\"\n-  [(set (match_operand 0 \"\" \"=r\")\n-\t(call (match_operand:QI 1 \"memory_operand\" \"m\")\n-\t      (match_operand:SI 2 \"immediate_operand\" \"n\")))]\n-  ;; Operand 2 not really used on Pyramid architecture.\n-  \"\"\n-  \"call %1\")\n-\n-(define_insn \"return\"\n-  [(return)]\n-  \"\"\n-  \"*\n-{\n-  if (get_frame_size () + current_function_pretend_args_size\n-      + current_function_args_size != 0\n-      || current_function_calls_alloca)\n-    {\n-      int dealloc_size = current_function_pretend_args_size;\n-      if (current_function_pops_args)\n-        dealloc_size += current_function_args_size;\n-      operands[0] = GEN_INT (dealloc_size);\n-      return \\\"retd %0\\\";\n-    }\n-  else\n-    return \\\"ret\\\";\n-}\")\n-\n-(define_insn \"tablejump\"\n-  [(set (pc) (match_operand:SI 0 \"register_operand\" \"r\"))\n-   (use (label_ref (match_operand 1 \"\" \"\")))]\n-  \"\"\n-  \"jump (%0)\")\n-\n-(define_insn \"nop\"\n-  [(const_int 0)]\n-  \"\"\n-  \"movw gr0,gr0  # nop\")\n-\f\n-;______________________________________________________________________\n-;\n-;\tPeep-hole Optimization Patterns.\n-;______________________________________________________________________\n-\n-;; Optimize fullword move followed by a test of the moved value.\n-\n-(define_peephole\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(match_operand:SI 1 \"nonimmediate_operand\" \"rm\"))\n-   (set (cc0) (match_operand:SI 2 \"nonimmediate_operand\" \"rm\"))]\n-  \"rtx_equal_p (operands[2], operands[0])\n-   || rtx_equal_p (operands[2], operands[1])\"\n-  \"*\n-  cc_status.flags |= CC_NO_OVERFLOW;\n-  return \\\"mtstw %1,%0\\\";\n-\")\n-\n-;; Optimize loops with an incremented/decremented variable.\n-\n-(define_peephole\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(plus:SI (match_dup 0)\n-\t\t (const_int -1)))\n-   (set (cc0)\n-\t(compare (match_operand:SI 1 \"register_operand\" \"r\")\n-\t\t (match_operand:SI 2 \"nonmemory_operand\" \"ri\")))\n-   (set (pc)\n-\t(if_then_else (match_operator:SI 3 \"signed_comparison\"\n-\t\t\t [(cc0) (const_int 0)])\n-\t\t      (label_ref (match_operand 4 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"(GET_CODE (operands[2]) == CONST_INT\n-    ? (unsigned)INTVAL (operands[2]) + 32 >= 64\n-    : 1) && (rtx_equal_p (operands[0], operands[1])\n-\t     || rtx_equal_p (operands[0], operands[2]))\"\n-  \"*\n-  if (rtx_equal_p (operands[0], operands[1]))\n-    {\n-      output_asm_insn (\\\"dcmpw %2,%0\\\", operands);\n-      return \\\"b%N3 %l4\\\";\n-    }\n-  else\n-    {\n-      output_asm_insn (\\\"dcmpw %1,%0\\\", operands);\n-      return \\\"b%R3 %l4\\\";\n-    }\n-\")\n-\n-(define_peephole\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(plus:SI (match_dup 0)\n-\t\t (const_int 1)))\n-   (set (cc0)\n-\t(compare (match_operand:SI 1 \"register_operand\" \"r\")\n-\t\t (match_operand:SI 2 \"nonmemory_operand\" \"ri\")))\n-   (set (pc)\n-\t(if_then_else (match_operator:SI 3 \"signed_comparison\"\n-\t\t\t [(cc0) (const_int 0)])\n-\t\t      (label_ref (match_operand 4 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"(GET_CODE (operands[2]) == CONST_INT\n-    ? (unsigned)INTVAL (operands[2]) + 32 >= 64\n-    : 1) && (rtx_equal_p (operands[0], operands[1])\n-\t     || rtx_equal_p (operands[0], operands[2]))\"\n-  \"*\n-  if (rtx_equal_p (operands[0], operands[1]))\n-    {\n-      output_asm_insn (\\\"icmpw %2,%0\\\", operands);\n-      return \\\"b%N3 %l4\\\";\n-    }\n-  else\n-    {\n-      output_asm_insn (\\\"icmpw %1,%0\\\", operands);\n-      return \\\"b%R3 %l4\\\";\n-    }\n-\")\n-\n-;; Combine two word moves with consecutive operands into one long move.\n-;; Also combines immediate moves, if the high-order destination operand\n-;; is loaded with 0 or -1 and the low-order destination operand is loaded\n-;; with a constant with the same sign.\n-\n-(define_peephole\n-  [(set (match_operand:SI 0 \"general_operand\" \"=g\")\n-\t(match_operand:SI 1 \"general_operand\" \"g\"))\n-   (set (match_operand:SI 2 \"general_operand\" \"=g\")\n-\t(match_operand:SI 3 \"general_operand\" \"g\"))]\n-  \"movdi_possible (operands)\"\n-  \"*\n-{\n-  output_asm_insn (\\\"# COMBINE movw %1,%0\\\", operands);\n-  output_asm_insn (\\\"# COMBINE movw %3,%2\\\", operands);\n-  movdi_possible (operands);\n-  if (CONSTANT_P (operands[1]))\n-    return (swap_operands ? \\\"movl %3,%0\\\" : \\\"movl %1,%2\\\");\n-\n-  return (swap_operands ? \\\"movl %1,%0\\\" : \\\"movl %3,%2\\\");\n-}\")\n-\n-;; Optimize certain tests after memory stores.\n-\n-(define_peephole\n-  [(set (match_operand 0 \"memory_operand\" \"=m\")\n-\t(match_operand 1 \"register_operand\" \"r\"))\n-   (set (match_operand:SI 2 \"register_operand\" \"=r\")\n-\t(sign_extend:SI (match_dup 1)))\n-   (set (cc0)\n-\t(match_dup 2))]\n-  \"dead_or_set_p (insn, operands[2])\"\n-  \"*\n-  cc_status.flags |= CC_NO_OVERFLOW;\n-  if (GET_MODE (operands[0]) == QImode)\n-    return \\\"cvtwb %1,%0\\\";\n-  else\n-    return \\\"cvtwh %1,%0\\\";\n-\")\n-\f\n-;______________________________________________________________________\n-;\n-;\tDImode Patterns.\n-;______________________________________________________________________\n-\n-(define_expand \"extendsidi2\"\n-  [(set (subreg:SI (match_operand:DI 0 \"register_operand\" \"=r\") 1)\n-\t(match_operand:SI 1 \"general_operand\" \"g\"))\n-   (set (subreg:SI (match_dup 0) 0)\n-\t(subreg:SI (match_dup 0) 1))\n-   (set (subreg:SI (match_dup 0) 0)\n-\t(ashiftrt:SI (subreg:SI (match_dup 0) 0)\n-\t\t     (const_int 31)))]\n-  \"\"\n-  \"\")\n-\n-(define_insn \"adddi3\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t(plus:DI (match_operand:DI 1 \"nonmemory_operand\" \"%0\")\n-\t\t (match_operand:DI 2 \"nonmemory_operand\" \"rF\")))]\n-  \"\"\n-  \"*\n-{\n-  rtx xoperands[2];\n-  CC_STATUS_INIT;\n-  xoperands[0] = gen_rtx_REG (SImode, REGNO (operands[0]) + 1);\n-  if (REG_P (operands[2]))\n-    xoperands[1] = gen_rtx_REG (SImode, REGNO (operands[2]) + 1);\n-  else\n-    {\n-      xoperands[1] = GEN_INT (CONST_DOUBLE_LOW (operands[2]));\n-      operands[2] = GEN_INT (CONST_DOUBLE_HIGH (operands[2]));\n-    }\n-  output_asm_insn (\\\"addw %1,%0\\\", xoperands);\n-  return \\\"addwc %2,%0\\\";\n-}\")\n-\n-(define_insn \"subdi3\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t(minus:DI (match_operand:DI 1 \"register_operand\" \"0\")\n-\t\t  (match_operand:DI 2 \"nonmemory_operand\" \"rF\")))]\n-  \"\"\n-  \"*\n-{\n-  rtx xoperands[2];\n-  CC_STATUS_INIT;\n-  xoperands[0] = gen_rtx_REG (SImode, REGNO (operands[0]) + 1);\n-  if (REG_P (operands[2]))\n-    xoperands[1] = gen_rtx_REG (SImode, REGNO (operands[2]) + 1);\n-  else\n-    {\n-      xoperands[1] = GEN_INT (CONST_DOUBLE_LOW (operands[2]));\n-      operands[2] = GEN_INT (CONST_DOUBLE_HIGH (operands[2]));\n-    }\n-  output_asm_insn (\\\"subw %1,%0\\\", xoperands);\n-  return \\\"subwb %2,%0\\\";\n-}\")\n-\n-(define_insn \"iordi3\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t(ior:DI (match_operand:DI 1 \"nonmemory_operand\" \"%0\")\n-\t\t(match_operand:DI 2 \"nonmemory_operand\" \"rF\")))]\n-  \"\"\n-  \"*\n-{\n-  rtx xoperands[2];\n-  CC_STATUS_INIT;\n-  xoperands[0] = gen_rtx_REG (SImode, REGNO (operands[0]) + 1);\n-  if (REG_P (operands[2]))\n-    xoperands[1] = gen_rtx_REG (SImode, REGNO (operands[2]) + 1);\n-  else\n-    {\n-      xoperands[1] = GEN_INT (CONST_DOUBLE_LOW (operands[2]));\n-      operands[2] = GEN_INT (CONST_DOUBLE_HIGH (operands[2]));\n-    }\n-  output_asm_insn (\\\"orw %1,%0\\\", xoperands);\n-  return \\\"orw %2,%0\\\";\n-}\")\n-\n-(define_insn \"anddi3\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t(and:DI (match_operand:DI 1 \"nonmemory_operand\" \"%0\")\n-\t\t(match_operand:DI 2 \"nonmemory_operand\" \"rF\")))]\n-  \"\"\n-  \"*\n-{\n-  rtx xoperands[2];\n-  CC_STATUS_INIT;\n-  xoperands[0] = gen_rtx_REG (SImode, REGNO (operands[0]) + 1);\n-  if (REG_P (operands[2]))\n-    xoperands[1] = gen_rtx_REG (SImode, REGNO (operands[2]) + 1);\n-  else\n-    {\n-      xoperands[1] = GEN_INT (CONST_DOUBLE_LOW (operands[2]));\n-      operands[2] = GEN_INT (CONST_DOUBLE_HIGH (operands[2]));\n-    }\n-  output_asm_insn (\\\"andw %1,%0\\\", xoperands);\n-  return \\\"andw %2,%0\\\";\n-}\")\n-\n-(define_insn \"xordi3\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t(xor:DI (match_operand:DI 1 \"nonmemory_operand\" \"%0\")\n-\t\t(match_operand:DI 2 \"nonmemory_operand\" \"rF\")))]\n-  \"\"\n-  \"*\n-{\n-  rtx xoperands[2];\n-  CC_STATUS_INIT;\n-  xoperands[0] = gen_rtx_REG (SImode, REGNO (operands[0]) + 1);\n-  if (REG_P (operands[2]))\n-    xoperands[1] = gen_rtx_REG (SImode, REGNO (operands[2]) + 1);\n-  else\n-    {\n-      xoperands[1] = GEN_INT (CONST_DOUBLE_LOW (operands[2]));\n-      operands[2] = GEN_INT (CONST_DOUBLE_HIGH (operands[2]));\n-    }\n-  output_asm_insn (\\\"xorw %1,%0\\\", xoperands);\n-  return \\\"xorw %2,%0\\\";\n-}\")\n-\n-;; My version, modelled after Jonathan Stone's and \"tablejump\" - S.P.\n-(define_insn \"indirect_jump\"\n-  [(set (pc) (match_operand:SI 0 \"general_operand\" \"r\"))]\n-  \"\"\n-  \"jump (%0)\")"}, {"sha": "5ee249a423af6bf4aa74b970acbfa09cad648adc", "filename": "gcc/config/pyr/x-pyr", "status": "removed", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7b4171a5b8a655097812307bbe261032dfbe366/gcc%2Fconfig%2Fpyr%2Fx-pyr", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7b4171a5b8a655097812307bbe261032dfbe366/gcc%2Fconfig%2Fpyr%2Fx-pyr", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpyr%2Fx-pyr?ref=a7b4171a5b8a655097812307bbe261032dfbe366", "patch": "@@ -1,2 +0,0 @@\n-CLIB=-lc /usr/.attlib/libPW.a\n-"}, {"sha": "d3e1168af4e290405edfd42cee54a0a7e52180c9", "filename": "gcc/config/pyr/xm-pyr.h", "status": "removed", "additions": 0, "deletions": 40, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7b4171a5b8a655097812307bbe261032dfbe366/gcc%2Fconfig%2Fpyr%2Fxm-pyr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7b4171a5b8a655097812307bbe261032dfbe366/gcc%2Fconfig%2Fpyr%2Fxm-pyr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpyr%2Fxm-pyr.h?ref=a7b4171a5b8a655097812307bbe261032dfbe366", "patch": "@@ -1,40 +0,0 @@\n-/* Configuration for GNU compiler, for Pyramid 90x, 9000, and MIServer Series.\n-   Copyright (C) 1989, 1993 Free Software Foundation, Inc.\n-\n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-/* #defines that need visibility everywhere.  */\n-#define FALSE 0\n-#define TRUE 1\n-\n-/* target machine dependencies.\n-   tm.h is a symbolic link to the actual target specific file.   */\n-#include \"tm.h\"\n-\n-/* This describes the machine the compiler is hosted on.  */\n-#define HOST_BITS_PER_CHAR 8\n-#define HOST_BITS_PER_SHORT 16\n-#define HOST_BITS_PER_INT 32\n-#define HOST_BITS_PER_LONG 32\n-#define HOST_BITS_PER_LONGLONG 64\n-\n-#define HOST_WORDS_BIG_ENDIAN\n-\n-/* Arguments to use with `exit'.  */\n-#define SUCCESS_EXIT_CODE 0\n-#define FATAL_EXIT_CODE 33"}, {"sha": "5c4024379e863799faa45c68a43e37a6096dcf25", "filename": "gcc/config/spur/spur.c", "status": "removed", "additions": 0, "deletions": 386, "changes": 386, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7b4171a5b8a655097812307bbe261032dfbe366/gcc%2Fconfig%2Fspur%2Fspur.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7b4171a5b8a655097812307bbe261032dfbe366/gcc%2Fconfig%2Fspur%2Fspur.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspur%2Fspur.c?ref=a7b4171a5b8a655097812307bbe261032dfbe366", "patch": "@@ -1,386 +0,0 @@\n-/* Subroutines for insn-output.c for SPUR.  Adapted from routines for\n-   the Motorola 68000 family.\n-   Copyright (C) 1988, 1991, 1997, 1998, 1999 Free Software Foundation, Inc.\n-\n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"rtl.h\"\n-#include \"regs.h\"\n-#include \"hard-reg-set.h\"\n-#include \"real.h\"\n-#include \"insn-config.h\"\n-#include \"conditions.h\"\n-#include \"insn-flags.h\"\n-#include \"output.h\"\n-#include \"function.h\"\n-#include \"insn-attr.h\"\n-\n-static rtx find_addr_reg ();\n-\n-char *\n-output_compare (operands, opcode, exchange_opcode, \n-\t\tneg_opcode, neg_exchange_opcode)\n-     rtx *operands;\n-     char *opcode;\n-     char *exchange_opcode;\n-     char *neg_opcode;\n-     char *neg_exchange_opcode;\n-{\n-  static char buf[100];\n-  operands[2] = operands[0];\n-  if (GET_CODE (cc_prev_status.value1) == CONST_INT)\n-    {\n-      operands[1] = cc_prev_status.value1;\n-      operands[0] = cc_prev_status.value2;\n-      opcode = exchange_opcode, neg_opcode = neg_exchange_opcode;\n-    }\n-  else\n-    {\n-      operands[0] = cc_prev_status.value1;\n-      operands[1] = cc_prev_status.value2;\n-    }\n-  if (TARGET_LONG_JUMPS)\n-    sprintf (buf,\n-\t     \"cmp_br_delayed %s,%%0,%%1,1f\\n\\tnop\\n\\tjump %%l2\\n\\tnop\\n1:\",\n-\t     neg_opcode);\n-  else \n-    sprintf (buf, \"cmp_br_delayed %s,%%0,%%1,%%l2\\n\\tnop\", opcode);\n-  return buf;\n-}\n-\n-/* Return the best assembler insn template\n-   for moving operands[1] into operands[0] as a fullword.  */\n-\n-static char *\n-singlemove_string (operands)\n-     rtx *operands;\n-{\n-  if (GET_CODE (operands[0]) == MEM)\n-    return \"st_32 %r1,%0\";\n-  if (GET_CODE (operands[1]) == MEM)\n-    return \"ld_32 %0,%1\\n\\tnop\";\n-  if (GET_CODE (operands[1]) == REG)\n-    return \"add_nt %0,%1,$0\";\n-  return \"add_nt %0,r0,%1\";\n-}\n-\f\n-/* Output assembler code to perform a doubleword move insn\n-   with operands OPERANDS.  */\n-\n-char *\n-output_move_double (operands)\n-     rtx *operands;\n-{\n-  enum { REGOP, OFFSOP, MEMOP, PUSHOP, POPOP, CNSTOP, RNDOP } optype0, optype1;\n-  rtx latehalf[2];\n-  rtx addreg0 = 0, addreg1 = 0;\n-\n-  /* First classify both operands.  */\n-\n-  if (REG_P (operands[0]))\n-    optype0 = REGOP;\n-  else if (offsettable_memref_p (operands[0]))\n-    optype0 = OFFSOP;\n-  else if (GET_CODE (operands[0]) == MEM)\n-    optype0 = MEMOP;\n-  else\n-    optype0 = RNDOP;\n-\n-  if (REG_P (operands[1]))\n-    optype1 = REGOP;\n-  else if (CONSTANT_P (operands[1]))\n-    optype1 = CNSTOP;\n-  else if (offsettable_memref_p (operands[1]))\n-    optype1 = OFFSOP;\n-  else if (GET_CODE (operands[1]) == MEM)\n-    optype1 = MEMOP;\n-  else\n-    optype1 = RNDOP;\n-\n-  /* Check for the cases that the operand constraints are not\n-     supposed to allow to happen.  Abort if we get one,\n-     because generating code for these cases is painful.  */\n-\n-  if (optype0 == RNDOP || optype1 == RNDOP)\n-    abort ();\n-\n-  /* If an operand is an unoffsettable memory ref, find a register\n-     we can increment temporarily to make it refer to the second word.  */\n-\n-  if (optype0 == MEMOP)\n-    addreg0 = find_addr_reg (XEXP (operands[0], 0));\n-\n-  if (optype1 == MEMOP)\n-    addreg1 = find_addr_reg (XEXP (operands[1], 0));\n-\n-  /* Ok, we can do one word at a time.\n-     Normally we do the low-numbered word first,\n-     but if either operand is autodecrementing then we\n-     do the high-numbered word first.\n-\n-     In either case, set up in LATEHALF the operands to use\n-     for the high-numbered word and in some cases alter the\n-     operands in OPERANDS to be suitable for the low-numbered word.  */\n-\n-  if (optype0 == REGOP)\n-    latehalf[0] = gen_rtx_REG (SImode, REGNO (operands[0]) + 1);\n-  else if (optype0 == OFFSOP)\n-    latehalf[0] = adj_offsettable_operand (operands[0], 4);\n-  else\n-    latehalf[0] = operands[0];\n-\n-  if (optype1 == REGOP)\n-    latehalf[1] = gen_rtx_REG (SImode, REGNO (operands[1]) + 1);\n-  else if (optype1 == OFFSOP)\n-    latehalf[1] = adj_offsettable_operand (operands[1], 4);\n-  else if (optype1 == CNSTOP)\n-    {\n-      if (GET_CODE (operands[1]) == CONST_DOUBLE)\n-\t{\n-\t  latehalf[1] = GEN_INT (CONST_DOUBLE_HIGH (operands[1]));\n-\t  operands[1] = GEN_INT (CONST_DOUBLE_LOW (operands[1]));\n-\t}\n-      else if (CONSTANT_P (operands[1]))\n-\tlatehalf[1] = const0_rtx;\n-    }\n-  else\n-    latehalf[1] = operands[1];\n-\n-  /* If the first move would clobber the source of the second one,\n-     do them in the other order.  This happens only for registers;\n-     such overlap can't happen in memory unless the user explicitly\n-     sets it up, and that is an undefined circumstance.  */\n-\n-  if (optype0 == REGOP && optype1 == REGOP\n-      && REGNO (operands[0]) == REGNO (latehalf[1]))\n-    {\n-      /* Make any unoffsettable addresses point at high-numbered word.  */\n-      if (addreg0)\n-\toutput_asm_insn (\"add_nt %0,%0,$4\", &addreg0);\n-      if (addreg1)\n-\toutput_asm_insn (\"add_nt %0,%0,$4\", &addreg1);\n-\n-      /* Do that word.  */\n-      output_asm_insn (singlemove_string (latehalf), latehalf);\n-\n-      /* Undo the adds we just did.  */\n-      if (addreg0)\n-\toutput_asm_insn (\"add_nt %0,%0,$-4\", &addreg0);\n-      if (addreg1)\n-\toutput_asm_insn (\"add_nt %0,%0,$-4\", &addreg0);\n-\n-      /* Do low-numbered word.  */\n-      return singlemove_string (operands);\n-    }\n-\n-  /* Normal case: do the two words, low-numbered first.  */\n-\n-  output_asm_insn (singlemove_string (operands), operands);\n-\n-  /* Make any unoffsettable addresses point at high-numbered word.  */\n-  if (addreg0)\n-    output_asm_insn (\"add_nt %0,%0,$4\", &addreg0);\n-  if (addreg1)\n-    output_asm_insn (\"add_nt %0,%0,$4\", &addreg1);\n-\n-  /* Do that word.  */\n-  output_asm_insn (singlemove_string (latehalf), latehalf);\n-\n-  /* Undo the adds we just did.  */\n-  if (addreg0)\n-    output_asm_insn (\"add_nt %0,%0,$-4\", &addreg0);\n-  if (addreg1)\n-    output_asm_insn (\"add_nt %0,%0,$-4\", &addreg1);\n-\n-  return \"\";\n-}\n-\f\n-static char *\n-output_fp_move_double (operands)\n-     rtx *operands;\n-{\n-  if (FP_REG_P (operands[0]))\n-    {\n-      if (FP_REG_P (operands[1]))\n-\treturn \"fmov %0,%1\";\n-      if (GET_CODE (operands[1]) == REG)\n-\t{\n-\t  rtx xoperands[2];\n-\t  int offset = - get_frame_size () - 8;\n-\t  xoperands[1] = gen_rtx_REG (SImode, REGNO (operands[1]) + 1);\n-\t  xoperands[0] = GEN_INT (offset + 4);\n-\t  output_asm_insn (\"st_32 %1,r25,%0\", xoperands);\n-\t  xoperands[1] = operands[1];\n-\t  xoperands[0] = GEN_INT (offset);\n-\t  output_asm_insn (\"st_32 %1,r25,%0\", xoperands);\n-\t  xoperands[1] = operands[0];\n-\t  output_asm_insn (\"ld_dbl %1,r25,%0\\n\\tnop\", xoperands);\n-\t  return \"\";\n-\t}\n-      return \"ld_dbl %0,%1\\n\\tnop\";\n-    }\n-  else if (FP_REG_P (operands[1]))\n-    {\n-      if (GET_CODE (operands[0]) == REG)\n-\t{\n-\t  rtx xoperands[2];\n-\t  int offset = - get_frame_size () - 8;\n-\t  xoperands[0] = GEN_INT (offset);\n-\t  xoperands[1] = operands[1];\n-\t  output_asm_insn (\"st_dbl %1,r25,%0\", xoperands);\n-\t  xoperands[1] = operands[0];\n-\t  output_asm_insn (\"ld_32 %1,r25,%0\\n\\tnop\", xoperands);\n-\t  xoperands[1] = gen_rtx_REG (SImode, REGNO (operands[0]) + 1);\n-\t  xoperands[0] = GEN_INT (offset + 4);\n-\t  output_asm_insn (\"ld_32 %1,r25,%0\\n\\tnop\", xoperands);\n-\t  return \"\";\n-\t}\n-      return \"st_dbl %1,%0\";\n-    }\n-}\n-\f\n-/* Return a REG that occurs in ADDR with coefficient 1.\n-   ADDR can be effectively incremented by incrementing REG.  */\n-\n-static rtx\n-find_addr_reg (addr)\n-     rtx addr;\n-{\n-  while (GET_CODE (addr) == PLUS)\n-    {\n-      if (GET_CODE (XEXP (addr, 0)) == REG)\n-\taddr = XEXP (addr, 0);\n-      else if (GET_CODE (XEXP (addr, 1)) == REG)\n-\taddr = XEXP (addr, 1);\n-      else if (CONSTANT_P (XEXP (addr, 0)))\n-\taddr = XEXP (addr, 1);\n-      else if (CONSTANT_P (XEXP (addr, 1)))\n-\taddr = XEXP (addr, 0);\n-      else\n-\tabort ();\n-    }\n-  if (GET_CODE (addr) == REG)\n-    return addr;\n-  abort ();\n-}\n-\f\n-/* Generate code to add a large integer constant to register, reg, storing\n- * the result in a register, target.  Offset must be 27-bit signed quantity */\n-\n-static char *\n-output_add_large_offset (target, reg, offset)\n-     rtx target, reg;\n-     int offset;\n-{\n-  rtx operands[3];\n-  int high, n, i;\n-  operands[0] = target, operands[1] = reg;\n-    \n-  for (high = offset, n = 0; \n-       (unsigned) (high + 0x2000) >= 0x4000; \n-       high >>= 1, n += 1)\n-    ;\n-  operands[2] = GEN_INT (high);\n-  output_asm_insn (\"add_nt r2,r0,%2\", operands);\n-  i = n;\n-  while (i >= 3)\n-    output_asm_insn (\"sll r2,r2,$3\", operands), i -= 3;\n-  if (i == 2) \n-    output_asm_insn (\"sll r2,r2,$2\", operands);\n-  else if (i == 1)\n-    output_asm_insn (\"sll r2,r2,$1\", operands);\n-  output_asm_insn (\"add_nt %0,r2,%1\", operands);\n-  if (offset - (high << n) != 0)\n-    {\n-      operands[2] = GEN_INT (offset - (high << n));\n-      output_asm_insn (\"add_nt %0,%0,%2\", operands);\n-    }\n-  return \"\";\n-}\n-\f\n-/* Additional TESTFN for matching. Like immediate_operand, but matches big\n- * constants */\n-\n-int\n-big_immediate_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n-{\n-  return (GET_CODE (op) == CONST_INT);\n-}\n-\f\n-/* ??? None of the original definitions ever worked for stdarg.h, and\n-   the port never updated for gcc2.  Quoting bits of the old va-spur.h\n-   for historical interest.  */\n-\n-tree\n-spur_build_va_list ()\n-{\n-  typedef struct {\n-    int __pnt;\n-    char *__regs;\n-    char *__stack;\n-  } va_list;\n-}\n-\n-void\n-spur_va_start (stdarg_p, valist, nextarg)\n-     int stdarg_p;\n-     tree valist;\n-     rtx nextarg ATTRIBUTE_UNUSED;\n-{\n-struct __va_struct { char __regs[20]; };\n-\n-#define va_alist __va_regs, __va_stack\n-#define va_dcl struct __va_struct __va_regs; int __va_stack; \n-\n-#define va_start(pvar) \\\n-     ((pvar).__pnt = 0, (pvar).__regs = __va_regs.__regs, \\\n-      (pvar).__stack = (char *) &__va_stack)\n-}\n-\n-rtx\n-spur_va_arg (valist, type)\n-     tree valist, type;\n-{\n-#define va_arg(pvar,type)\t\t\t\t\t\t   \\\n-__extension__\t\t\t\t\t\t\t\t   \\\n-    (*({  type *__va_result;\t\t\t\t\t\t   \\\n-        if ((pvar).__pnt >= 20) {\t\t\t\t\t   \\\n-           __va_result = ( (type *) ((pvar).__stack + (pvar).__pnt - 20)); \\\n-\t   (pvar).__pnt += (sizeof(type) + 7) & ~7;\t\t\t   \\\n-\t}\t\t\t\t\t\t\t\t   \\\n-\telse if ((pvar).__pnt + sizeof(type) > 20) {\t\t\t   \\\n-\t   __va_result = (type *) (pvar).__stack;\t\t\t   \\\n-\t   (pvar).__pnt = 20 + ( (sizeof(type) + 7) & ~7);\t\t   \\\n-\t}\t\t\t\t\t\t\t\t   \\\n-\telse if (sizeof(type) == 8) {\t\t\t\t\t   \\\n-\t   union {double d; int i[2];} __u;\t\t\t\t   \\\n-\t   __u.i[0] = *(int *) ((pvar).__regs + (pvar).__pnt);\t\t   \\\n-\t   __u.i[1] = *(int *) ((pvar).__regs + (pvar).__pnt + 4);\t   \\\n-\t   __va_result = (type *) &__u;\t\t\t\t\t   \\\n-\t   (pvar).__pnt += 8;\t\t\t\t\t\t   \\\n-\t}\t\t\t\t\t\t\t\t   \\\n-\telse {\t\t\t\t\t\t\t\t   \\\n-\t   __va_result = (type *) ((pvar).__regs + (pvar).__pnt);\t   \\\n-\t   (pvar).__pnt += (sizeof(type) + 3) & ~3;\t\t\t   \\\n-\t}\t\t\t\t\t\t\t\t   \\\n-\t__va_result; }))\n-}"}, {"sha": "2627583bfc8e6eb1f53d049094dc248e69194e28", "filename": "gcc/config/spur/spur.h", "status": "removed", "additions": 0, "deletions": 1045, "changes": 1045, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7b4171a5b8a655097812307bbe261032dfbe366/gcc%2Fconfig%2Fspur%2Fspur.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7b4171a5b8a655097812307bbe261032dfbe366/gcc%2Fconfig%2Fspur%2Fspur.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspur%2Fspur.h?ref=a7b4171a5b8a655097812307bbe261032dfbe366", "patch": "@@ -1,1045 +0,0 @@\n-/* Definitions of target machine for GNU compiler, for SPUR chip.\n-   Copyright (C) 1988, 1995, 1996, 1998, 1999, 2000 Free Software Foundation, Inc.\n-\n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-\n-/* Note that some other tm.h files include this one and then override\n-   many of the definitions that relate to assembler syntax.  */\n-\n-\n-/* Names to predefine in the preprocessor for this target machine.  */\n-\n-#define CPP_PREDEFINES \"-Dspur -Acpu(spur) -Amachine(spur)\"\n-\n-/* Link with libg.a when debugging, for dbx's sake.  */\n-\n-#define LIB_SPEC \"%{g:-lg} %{!p:%{!pg:-lc}}%{p:-lc_p}%{pg:-lc_p} \"\n-\n-/* Print subsidiary information on the compiler version in use.  */\n-#define TARGET_VERSION fprintf (stderr, \" (spur)\");\n-\n-/* Run-time compilation parameters selecting different hardware subsets.\n-\n-   On the SPUR, we don't yet need any.  */\n-\n-extern int target_flags;\n-\n-/* Nonzero if we should generate code to use the fpu.  */\n-#define TARGET_FPU (target_flags & 1)\n-\n-/* Nonzero if we should expand constant shifts into series of shift\n-   instructions.  */\n-#define TARGET_EXPAND_SHIFTS (target_flags & 2)\n-\n-/* Nonzero if we should generate long jumps for compares. */\n-#define TARGET_LONG_JUMPS (target_flags & 4)\n-\n-/* Macro to define tables used to set the flags.\n-   This is a list in braces of pairs in braces,\n-   each pair being { \"NAME\", VALUE }\n-   where VALUE is the bits to set or minus the bits to clear.\n-   An empty string NAME is used to identify the default VALUE.  */\n-\n-#define TARGET_SWITCHES  \\\n-  { {\"fpu\", 1},\t\t\t\\\n-    {\"soft-float\", -1},\t\t\\\n-    {\"expand-shifts\", 2},       \\\n-    {\"lib-shifts\", -2},\t\t\\\n-    {\"long-jumps\", 4},\t\t\\\n-    {\"short-jumps\", -4},\t\\\n-    { \"\", TARGET_DEFAULT}}\n-\n-#define TARGET_DEFAULT 0\n-\f\n-/* target machine storage layout */\n-\n-/* Define this if most significant bit is lowest numbered\n-   in instructions that operate on numbered bit-fields.\n-   This is a moot question on the SPUR due to the lack of bit-field insns.  */\n-#define BITS_BIG_ENDIAN 0\n-\n-/* Define this if most significant byte of a word is the lowest numbered.  */\n-/* That is not true on SPUR.  */\n-#define BYTES_BIG_ENDIAN 0\n-\n-/* Define this if most significant word of a multiword number is the lowest\n-   numbered.  */\n-/* For SPUR we can decide arbitrarily\n-   since there are no machine instructions for them.  */\n-#define WORDS_BIG_ENDIAN 0\n-\n-/* number of bits in an addressable storage unit */\n-#define BITS_PER_UNIT 8\n-\n-/* Width in bits of a \"word\", which is the contents of a machine register.\n-   Note that this is not necessarily the width of data type `int';\n-   if using 16-bit ints on a 68000, this would still be 32.\n-   But on a machine with 16-bit registers, this would be 16.  */\n-#define BITS_PER_WORD 32\n-\n-/* Width of a word, in units (bytes).  */\n-#define UNITS_PER_WORD 4\n-\n-/* Width in bits of a pointer.\n-   See also the macro `Pmode' defined below.  */\n-#define POINTER_SIZE 32\n-\n-/* Allocation boundary (in *bits*) for storing arguments in argument list.  */\n-#define PARM_BOUNDARY 64\n-\n-/* Boundary (in *bits*) on which stack pointer should be aligned.  */\n-#define STACK_BOUNDARY 64\n-\n-/* Allocation boundary (in *bits*) for the code of a function.  */\n-#define FUNCTION_BOUNDARY 32\n-\n-/* Alignment of field after `int : 0' in a structure.  */\n-#define EMPTY_FIELD_BOUNDARY 32\n-\n-/* Every structure's size must be a multiple of this.  */\n-#define STRUCTURE_SIZE_BOUNDARY 32\n-\n-/* No data type wants to be aligned rounder than this.  */\n-#define BIGGEST_ALIGNMENT 64\n-\n-/* Set this nonzero if move instructions will actually fail to work\n-   when given unaligned data.  */\n-#define STRICT_ALIGNMENT 1\n-\f\n-/* Standard register usage.  */\n-\n-/* Number of actual hardware registers.\n-   The hardware registers are assigned numbers for the compiler\n-   from 0 to just below FIRST_PSEUDO_REGISTER.\n-   All registers that the compiler knows about must be given numbers,\n-   even those that are not normally considered general registers.\n-\n-   SPUR has 32 fullword registers and 15 floating point registers.  */\n-\n-#define FIRST_PSEUDO_REGISTER 47\n-\n-/* 1 for registers that have pervasive standard uses\n-   and are not available for the register allocator.\n-   On SPUR, this includes all the global registers\n-   and the callee return address register.  */\n-#define FIXED_REGISTERS  \\\n- {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, \\\n-  1, 0, 0, 0, 0, 0,\t\t\\\n-  0, 0, 0, 0, 0, 0, 0, 0, 1, 1,\t\\\n-  1, 0, 0, 0, 0, 0,\t\t\\\n-  1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}\n-\n-/* 1 for registers not available across function calls.\n-   These must include the FIXED_REGISTERS and also any\n-   registers that can be used without being saved.\n-   The latter must include the registers where values are returned\n-   and the register where structure-value addresses are passed.\n-   Aside from that, you can include as many other registers as you like.  */\n-#define CALL_USED_REGISTERS  \\\n- {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, \\\n-  1, 0, 0, 0, 0, 0,\t\t\\\n-  0, 0, 0, 0, 0, 0, 0, 0, 1, 1,\t\\\n-  1, 1, 1, 1, 1, 1,\t\t\\\n-  1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0}\n-\n-/* Return number of consecutive hard regs needed starting at reg REGNO\n-   to hold something of mode MODE.\n-   This is ordinarily the length in words of a value of mode MODE\n-   but can be less for certain modes in special long registers.\n-\n-   On SPUR, ordinary registers hold 32 bits worth;\n-   a single floating point register is always enough for\n-   anything that can be stored in them at all.  */\n-#define HARD_REGNO_NREGS(REGNO, MODE)   \\\n-  ((REGNO) >= 32 ? GET_MODE_NUNITS ((MODE))\t\\\n-   : ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD))\n-\n-/* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.\n-   On SPUR, the cpu registers can hold any mode but the float registers\n-   can hold only floating point.  And they can't hold anything if use\n-   of hardware floating point is disabled.  */\n-#define HARD_REGNO_MODE_OK(REGNO, MODE) \\\n-  (((REGNO) < 32\t\t\t\t\t\t\t\\\n-    && (REGNO) + ((GET_MODE_UNIT_SIZE ((MODE)) + 3) / 4) <= 32)\t\t\\\n-   || (TARGET_FPU && ((MODE) == SFmode || (MODE) == DFmode\t\t\\\n-\t\t      || (MODE) == SCmode || (MODE) == DCmode)))\n-\n-/* Value is 1 if it is a good idea to tie two pseudo registers\n-   when one has mode MODE1 and one has mode MODE2.\n-   If HARD_REGNO_MODE_OK could produce different values for MODE1 and MODE2,\n-   for any hard reg, then this must be 0 for correct output.  */\n-#define MODES_TIEABLE_P(MODE1, MODE2) \\\n-  (((MODE1) == SFmode || (MODE1) == DFmode\t\t\\\n-    || (MODE1) == SCmode || (MODE1) == DCmode)\t\t\\\n-   == ((MODE2) == SFmode || (MODE2) == DFmode\t\t\\\n-       || (MODE2) == SCmode || (MODE2) == DCmode))\n-\n-/* Specify the registers used for certain standard purposes.\n-   The values of these macros are register numbers.  */\n-\n-/* SPUR pc isn't overloaded on a register that the compiler knows about.  */\n-/* #define PC_REGNUM  */\n-\n-/* Register to use for pushing function arguments.  */\n-#define STACK_POINTER_REGNUM 4\n-\n-/* Base register for access to local variables of the function.  */\n-#define FRAME_POINTER_REGNUM 25\n-\n-/* Value should be nonzero if functions must have frame pointers.\n-   Zero means the frame pointer need not be set up (and parms\n-   may be accessed via the stack pointer) in functions that seem suitable.\n-   This is computed in `reload', in reload1.c.  */\n-#define FRAME_POINTER_REQUIRED 1\n-\n-/* Base register for access to arguments of the function.  */\n-#define ARG_POINTER_REGNUM 25\n-\n-/* Register in which static-chain is passed to a function.  */\n-/* ??? */\n-#define STATIC_CHAIN_REGNUM 8\n-\n-/* Register in which address to store a structure value\n-   is passed to a function.  */\n-#define STRUCT_VALUE_REGNUM 27\n-#define STRUCT_VALUE_INCOMING_REGNUM 11\n-\f\n-/* Define the classes of registers for register constraints in the\n-   machine description.  Also define ranges of constants.\n-\n-   One of the classes must always be named ALL_REGS and include all hard regs.\n-   If there is more than one class, another class must be named NO_REGS\n-   and contain no registers.\n-\n-   The name GENERAL_REGS must be the name of a class (or an alias for\n-   another name such as ALL_REGS).  This is the class of registers\n-   that is allowed by \"g\" or \"r\" in a register constraint.\n-   Also, registers outside this class are allocated only when\n-   instructions express preferences for them.\n-\n-   The classes must be numbered in nondecreasing order; that is,\n-   a larger-numbered class must never be contained completely\n-   in a smaller-numbered class.\n-\n-   For any two classes, it is very desirable that there be another\n-   class that represents their union.  */\n-   \n-/* The 68000 has two kinds of registers, hence four classes.  */\n-\n-enum reg_class { NO_REGS, GENERAL_REGS, FP_REGS, ALL_REGS, LIM_REG_CLASSES };\n-\n-#define N_REG_CLASSES (int) LIM_REG_CLASSES\n-\n-/* Give names of register classes as strings for dump file.   */\n-\n-#define REG_CLASS_NAMES \\\n- {\"NO_REGS\", \"GENERAL_REGS\", \"FP_REGS\", \"ALL_REGS\" }\n-\n-/* Define which registers fit in which classes.\n-   This is an initializer for a vector of HARD_REG_SET\n-   of length N_REG_CLASSES.  */\n-\n-#define REG_CLASS_CONTENTS {{0, 0}, {-1, 0}, {0, 0x7fff}, {-1, 0x7fff}}\n-\n-/* The same information, inverted:\n-   Return the class number of the smallest class containing\n-   reg number REGNO.  This could be a conditional expression\n-   or could index an array.  */\n-\n-#define REGNO_REG_CLASS(REGNO) \\\n- ((REGNO) >= 32 ? FP_REGS : GENERAL_REGS)\n-\n-/* The class value for index registers, and the one for base regs.  */\n-#define INDEX_REG_CLASS GENERAL_REGS\n-#define BASE_REG_CLASS GENERAL_REGS\n-\n-/* Get reg_class from a letter such as appears in the machine description.  */\n-\n-#define REG_CLASS_FROM_LETTER(C) \\\n-  ((C) == 'f' ? FP_REGS : NO_REGS)\n-\n-/* The letters I, J, K, L and M in a register constraint string\n-   can be used to stand for particular ranges of immediate operands.\n-   This macro defines what the ranges are.\n-   C is the letter, and VALUE is a constant value.\n-   Return 1 if VALUE is in the range specified by C.\n-\n-   For SPUR, `I' is used for the range of constants an insn\n-   can actually contain.\n-   `J' is used for the range which is just zero (since that is R0).\n-   `K' is used for the 5-bit operand of a compare insns.  */\n-\n-#define CONST_OK_FOR_LETTER_P(VALUE, C)  \\\n-  ((C) == 'I' ? (unsigned) ((VALUE) + 0x2000) < 0x4000\t\\\n-   : (C) == 'J' ? (VALUE) == 0\t\t\t\t\\\n-   : (C) == 'K' ? (unsigned) (VALUE) < 0x20\t\t\\\n-   : 0)\n-\n-/* Similar, but for floating constants, and defining letters G and H.\n-   Here VALUE is the CONST_DOUBLE rtx itself.  */\n-\n-#define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C)  \t\\\n-  ((C) == 'G' && CONST_DOUBLE_HIGH (VALUE) == 0\t\t\\\n-   && CONST_DOUBLE_LOW (VALUE) == 0)\n-\n-/* Given an rtx X being reloaded into a reg required to be\n-   in class CLASS, return the class of reg to actually use.\n-   In general this is just CLASS; but on some machines\n-   in some cases it is preferable to use a more restrictive class.  */\n-#define PREFERRED_RELOAD_CLASS(X,CLASS) (CLASS)\n-\n-/* Return the maximum number of consecutive registers\n-   needed to represent mode MODE in a register of class CLASS.  */\n-/* On SPUR, this is the size of MODE in words,\n-   except in the FP regs, where a single reg is always enough.  */\n-#define CLASS_MAX_NREGS(CLASS, MODE)\t\\\n- ((CLASS) == FP_REGS ? 1\t\t\t\\\n-  : ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD))\n-\f\n-/* Stack layout; function entry, exit and calling.  */\n-\n-/* Define this if pushing a word on the stack\n-   makes the stack pointer a smaller address.  */\n-#define STACK_GROWS_DOWNWARD\n-\n-/* Define this if the nominal address of the stack frame\n-   is at the high-address end of the local variables;\n-   that is, each additional local variable allocated\n-   goes at a more negative offset in the frame.  */\n-#define FRAME_GROWS_DOWNWARD\n-\n-/* Offset within stack frame to start allocating local variables at.\n-   If FRAME_GROWS_DOWNWARD, this is the offset to the END of the\n-   first local allocated.  Otherwise, it is the offset to the BEGINNING\n-   of the first local allocated.  */\n-#define STARTING_FRAME_OFFSET 0\n-\n-/* If we generate an insn to push BYTES bytes,\n-   this says how many the stack pointer really advances by.\n-   On SPUR, don't define this because there are no push insns.  */\n-/*  #define PUSH_ROUNDING(BYTES) */\n-\n-/* Offset of first parameter from the argument pointer register value.  */\n-#define FIRST_PARM_OFFSET(FNDECL) 0\n-\n-/* Value is the number of bytes of arguments automatically\n-   popped when returning from a subroutine call.\n-   FUNDECL is the declaration node of the function (as a tree),\n-   FUNTYPE is the data type of the function (as a tree),\n-   or for a library call it is an identifier node for the subroutine name.\n-   SIZE is the number of bytes of arguments passed on the stack.  */\n-\n-#define RETURN_POPS_ARGS(FUNDECL,FUNTYPE,SIZE) 0\n-\n-/* Define how to find the value returned by a function.\n-   VALTYPE is the data type of the value (as a tree).\n-   If the precise function being called is known, FUNC is its FUNCTION_DECL;\n-   otherwise, FUNC is 0.  */\n-\n-/* On SPUR the value is found in the second \"output\" register.  */\n-\n-#define FUNCTION_VALUE(VALTYPE, FUNC)  \\\n-  gen_rtx_REG (TYPE_MODE (VALTYPE), 27)\n-\n-/* But the called function leaves it in the second \"input\" register.  */\n-\n-#define FUNCTION_OUTGOING_VALUE(VALTYPE, FUNC)  \\\n-  gen_rtx_REG (TYPE_MODE (VALTYPE), 11)\n-\n-/* Define how to find the value returned by a library function\n-   assuming the value has mode MODE.  */\n-\n-#define LIBCALL_VALUE(MODE)  gen_rtx_REG (MODE, 27)\n-\n-/* 1 if N is a possible register number for a function value\n-   as seen by the caller.\n-   On SPUR, the first \"output\" reg is the only register thus used.  */\n-\n-#define FUNCTION_VALUE_REGNO_P(N) ((N) == 27)\n-\n-/* 1 if N is a possible register number for function argument passing.\n-   On SPUR, these are the \"output\" registers.  */\n-\n-#define FUNCTION_ARG_REGNO_P(N) ((N) < 32 && (N) > 26)\n-\n-/* Define this macro if the target machine has \"register windows\".  This\n-   C expression returns the register number as seen by the called function\n-   corresponding to register number OUT as seen by the calling function.\n-   Return OUT if register number OUT is not an outbound register.  */\n-\n-#define INCOMING_REGNO(OUT) \\\n- (((OUT) < 27 || (OUT) > 31) ? (OUT) : (OUT) - 16)\n-\n-/* Define this macro if the target machine has \"register windows\".  This\n-   C expression returns the register number as seen by the calling function\n-   corresponding to register number IN as seen by the called function.\n-   Return IN if register number IN is not an inbound register.  */\n-\n-#define OUTGOING_REGNO(IN) \\\n- (((IN) < 11 || (IN) > 15) ? (IN) : (IN) + 16)\n-\f\n-/* Define a data type for recording info about an argument list\n-   during the scan of that argument list.  This data type should\n-   hold all necessary information about the function itself\n-   and about the args processed so far, enough to enable macros\n-   such as FUNCTION_ARG to determine where the next arg should go.\n-\n-   On SPUR, this is a single integer, which is a number of words\n-   of arguments scanned so far (including the invisible argument,\n-   if any, which holds the structure-value-address).\n-   Thus 5 or more means all following args should go on the stack.  */\n-\n-#define CUMULATIVE_ARGS int\n-\n-/* Initialize a variable CUM of type CUMULATIVE_ARGS\n-   for a call to a function whose data type is FNTYPE.\n-   For a library call, FNTYPE is 0.\n-\n-   On SPUR, the offset normally starts at 0, but starts at 4 bytes\n-   when the function gets a structure-value-address as an\n-   invisible first argument.  */\n-\n-#define INIT_CUMULATIVE_ARGS(CUM,FNTYPE,LIBNAME,INDIRECT)\t\\\n- ((CUM) = ((FNTYPE) != 0 && aggregate_value_p (TREE_TYPE ((FNTYPE)))))\n-\n-/* Update the data in CUM to advance over an argument\n-   of mode MODE and data type TYPE.\n-   (TYPE is null for libcalls where that information may not be available.)  */\n-\n-#define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED)\t\\\n- ((CUM) += ((MODE) != BLKmode\t\t\t\\\n-\t    ? (GET_MODE_SIZE (MODE) + 3) / 4\t\\\n-\t    : (int_size_in_bytes (TYPE) + 3) / 4))\n-\n-/* Determine where to put an argument to a function.\n-   Value is zero to push the argument on the stack,\n-   or a hard register in which to store the argument.\n-\n-   MODE is the argument's machine mode.\n-   TYPE is the data type of the argument (as a tree).\n-    This is null for libcalls where that information may\n-    not be available.\n-   CUM is a variable of type CUMULATIVE_ARGS which gives info about\n-    the preceding args and about the function being called.\n-   NAMED is nonzero if this argument is a named parameter\n-    (otherwise it is an extra parameter matching an ellipsis).  */\n-\n-/* On SPUR the first five words of args are normally in registers\n-   and the rest are pushed.  But any arg that won't entirely fit in regs\n-   is pushed.  */\n-\n-#define FUNCTION_ARG(CUM, MODE, TYPE, NAMED)\t\t\\\n-(5 >= ((CUM)\t\t\t\t\t\t\\\n-       + ((MODE) == BLKmode\t\t\t\t\\\n-\t  ? (int_size_in_bytes (TYPE) + 3) / 4\t\t\\\n-\t  : (GET_MODE_SIZE (MODE) + 3) / 4))\t\t\\\n- ? gen_rtx_REG ((MODE), 27 + (CUM))\t\t\t\\\n- : 0)\n-\n-/* Define where a function finds its arguments.\n-   This is different from FUNCTION_ARG because of register windows.  */\n-\n-#define FUNCTION_INCOMING_ARG(CUM, MODE, TYPE, NAMED)\t\\\n-(5 >= ((CUM)\t\t\t\t\t\t\\\n-       + ((MODE) == BLKmode\t\t\t\t\\\n-\t  ? (int_size_in_bytes (TYPE) + 3) / 4\t\t\\\n-\t  : (GET_MODE_SIZE (MODE) + 3) / 4))\t\t\\\n- ? gen_rtx_REG ((MODE), 11 + (CUM))\t\t\t\\\n- : 0)\n-\n-/* For an arg passed partly in registers and partly in memory,\n-   this is the number of registers used.\n-   For args passed entirely in registers or entirely in memory, zero.  */\n-\n-#define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED) 0\n-\n-/* This macro generates the assembly code for function entry.\n-   FILE is a stdio stream to output the code to.\n-   SIZE is an int: how many units of temporary storage to allocate.\n-   Refer to the array `regs_ever_live' to determine which registers\n-   to save; `regs_ever_live[I]' is nonzero if register number I\n-   is ever used in the function.  This macro is responsible for\n-   knowing which registers should not be saved even if used.  */\n-\n-/* On spur, move-double insns between fpu and cpu need an 8-byte block\n-   of memory.  If any fpu reg is used in the function, we allocate\n-   such a block here, at the bottom of the frame, just in case it's needed.  */\n-\n-#define FUNCTION_PROLOGUE(FILE, SIZE)\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\\\n-  extern char call_used_regs[];\t\t\t\t\t\\\n-  int fsize = ((SIZE) + 7) & ~7;\t\t\t\t\\\n-  int nregs, i, fp_used = 0;\t\t\t\t\t\\\n-  for (i = 32, nregs = 0; i < FIRST_PSEUDO_REGISTER; i++)\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      if (regs_ever_live[i] && ! call_used_regs[i])\t\t\\\n-        nregs++;\t\t\t\t\t\t\\\n-      if (regs_ever_live[i]) fp_used = 1;\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-  if (fp_used) fsize += 8;\t\t\t\t\t\\\n-  fprintf (FILE, \"0:\\trd_special r24,pc\\n\");\t\t\t\\\n-  fprintf (FILE, \"\\tand r24,r24,$~0x3\\n\");\t\t\t\\\n-  fprintf (FILE, \"\\tadd_nt r25,r4,$%d\\n\",\t\t\t\\\n-\t   - current_function_pretend_args_size);\t\t\\\n-  if (fsize + nregs != 0 || current_function_pretend_args_size > 0)\\\n-    {\t\t\t\t\t\t\t\t\\\n-      int n = - fsize - nregs * 16;\t\t\t\t\\\n-      if (n >= -8192)\t\t\t\t\t\t\\\n-        fprintf (FILE, \"\\tadd_nt r4,r25,$%d\\n\", n);\t\t\\\n-      else\t\t\t\t\t\t\t\\\n-        {\t\t\t\t\t\t\t\\\n-\t  fprintf (FILE, \"\\tadd_nt r4,r25,$-8192\\n\");\t\t\\\n-\t  n += 8192;\t\t\t\t\t\t\\\n-          while (n < -8192)\t\t\t\t\t\\\n-            fprintf (FILE, \"\\tadd_nt r4,r4,$-8192\\n\"), n += 8192; \\\n-\t  if (n != 0)\t\t\t\t\t\t\\\n-            fprintf (FILE, \"\\tadd_nt r4,r4,$%d\\n\", n);\t\t\\\n-        }\t\t\t\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\\\n-  for (i = 32, nregs = 0; i < FIRST_PSEUDO_REGISTER; i++)\t\\\n-    if (regs_ever_live[i] && ! call_used_regs[i])\t\t\\\n-      {\t\t\t\t\t\t\t\t\\\n-        fprintf (FILE, \"\\tst_ext1 %s,r4,$%d\\n\",\t\t\t\\\n-\t         reg_names[i], 8 * nregs++);\t\t\t\\\n-        fprintf (FILE, \"\\tst_ext2 %s,r4,$%d\\n\",\t\t\t\\\n-\t         reg_names[i], 8 * nregs++);\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\\\n-}\n-\n-/* Output assembler code to FILE to increment profiler label # LABELNO\n-   for profiling a function entry.  */\n-\n-#define FUNCTION_PROFILER(FILE, LABELNO)  \\\n-   abort ();\n-\n-/* EXIT_IGNORE_STACK should be nonzero if, when returning from a function,\n-   the stack pointer does not matter.  The value is tested only in\n-   functions that have frame pointers.\n-   No definition is equivalent to always zero.  */\n-\n-#define EXIT_IGNORE_STACK\t\\\n- (get_frame_size () != 0\t\\\n-  || current_function_calls_alloca || current_function_pretend_args_size)\n-\n-/* This macro generates the assembly code for function exit,\n-   on machines that need it.  If FUNCTION_EPILOGUE is not defined\n-   then individual return instructions are generated for each\n-   return statement.  Args are same as for FUNCTION_PROLOGUE.\n-\n-   The function epilogue should not depend on the current stack pointer!\n-   It should use the frame pointer only.  This is mandatory because\n-   of alloca; we also take advantage of it to omit stack adjustments\n-   before returning.  */\n-\n-#define FUNCTION_EPILOGUE(FILE, SIZE)\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\\\n-  extern char call_used_regs[];\t\t\t\t\t\\\n-  int fsize = ((SIZE) + 7) & ~7;\t\t\t\t\\\n-  int nregs, i, fp_used = 0;\t\t\t\t\t\\\n-  for (i = 32, nregs = 0; i < FIRST_PSEUDO_REGISTER; i++)\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      if (regs_ever_live[i] && ! call_used_regs[i])\t\t\\\n-\tnregs++;\t\t\t\t\t\t\\\n-      if (regs_ever_live[i]) fp_used = 1;\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-  if (fp_used) fsize += 8;\t\t\t\t\t\\\n-  if (nregs != 0)\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      fprintf (FILE, \"\\tadd_nt r4,r25,$%d\\n\", - fsize - nregs * 16); \\\n-      for (i = 32, nregs = 0; i < FIRST_PSEUDO_REGISTER; i++)\t\\\n-        if (regs_ever_live[i] && ! call_used_regs[i])\t\t\\\n-\t  {\t\t\t\t\t\t\t\\\n-            fprintf (FILE, \"\\tld_ext1 %s,r4,$%d\\n\\tnop\\n\",\t\\\n-\t\t     reg_names[i], 8 * nregs++);\t\t\\\n-            fprintf (FILE, \"\\tld_ext2 %s,r4,$%d\\n\\tnop\\n\",\t\\\n-\t\t     reg_names[i], 8 * nregs++);\t\t\\\n-\t  }\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-  if (fsize != 0 || nregs != 0 || current_function_calls_alloca\t\\\n-      || current_function_pretend_args_size > 0)\t\t\\\n-    fprintf (FILE, \"\\tadd_nt r4,r25,$%d\\n\",\t\t\t\\\n-\t     current_function_pretend_args_size);\t\t\\\n-  fprintf (FILE, \"\\treturn r10,$8\\n\\tnop\\n\");\t\t\t\\\n-}\n-\f\n-/* Addressing modes, and classification of registers for them.  */\n-\n-/* #define HAVE_POST_INCREMENT 0 */\n-/* #define HAVE_POST_DECREMENT 0 */\n-\n-/* #define HAVE_PRE_DECREMENT 0 */\n-/* #define HAVE_PRE_INCREMENT 0 */\n-\n-/* Macros to check register numbers against specific register classes.  */\n-\n-/* These assume that REGNO is a hard or pseudo reg number.\n-   They give nonzero only if REGNO is a hard reg of the suitable class\n-   or a pseudo reg currently allocated to a suitable hard reg.\n-   Since they use reg_renumber, they are safe only once reg_renumber\n-   has been allocated, which happens in local-alloc.c.  */\n-\n-#define REGNO_OK_FOR_INDEX_P(REGNO) \\\n-((REGNO) < 32 || (unsigned) reg_renumber[REGNO] < 32)\n-#define REGNO_OK_FOR_BASE_P(REGNO) \\\n-((REGNO) < 32 || (unsigned) reg_renumber[REGNO] < 32)\n-#define REGNO_OK_FOR_FP_P(REGNO) \\\n-(((REGNO) ^ 0x20) < 14 || (unsigned) (reg_renumber[REGNO] ^ 0x20) < 14)\n-\n-/* Now macros that check whether X is a register and also,\n-   strictly, whether it is in a specified class.\n-\n-   These macros are specific to the SPUR, and may be used only\n-   in code for printing assembler insns and in conditions for\n-   define_optimization.  */\n-\n-/* 1 if X is an fp register.  */\n-\n-#define FP_REG_P(X) (REG_P (X) && REGNO_OK_FOR_FP_P (REGNO (X)))\n-\f\n-/* Maximum number of registers that can appear in a valid memory address.  */\n-\n-#define MAX_REGS_PER_ADDRESS 2\n-\n-/* Recognize any constant value that is a valid address.  */\n-\n-#define CONSTANT_ADDRESS_P(X)   \\\n-  (GET_CODE (X) == LABEL_REF || GET_CODE (X) == SYMBOL_REF\t\t\\\n-   || GET_CODE (X) == CONST_INT || GET_CODE (X) == CONST\t\t\\\n-   || GET_CODE (X) == HIGH)\n-\n-/* Nonzero if the constant value X is a legitimate general operand.\n-   It is given that X satisfies CONSTANT_P or is a CONST_DOUBLE.  */\n-\n-#define LEGITIMATE_CONSTANT_P(X)\t\t\\\n- ((GET_CODE (X) == CONST_INT\t\t\t\\\n-   && (unsigned) (INTVAL (X) + 0x2000) < 0x4000)\\\n-  || (GET_CODE (X) == SYMBOL_REF && (X)->unchanging))\n-\n-/* The macros REG_OK_FOR..._P assume that the arg is a REG rtx\n-   and check its validity for a certain class.\n-   We have two alternate definitions for each of them.\n-   The usual definition accepts all pseudo regs; the other rejects\n-   them unless they have been allocated suitable hard regs.\n-   The symbol REG_OK_STRICT causes the latter definition to be used.\n-\n-   Most source files want to accept pseudo regs in the hope that\n-   they will get allocated to the class that the insn wants them to be in.\n-   Source files for reload pass need to be strict.\n-   After reload, it makes no difference, since pseudo regs have\n-   been eliminated by then.  */\n-\n-#ifndef REG_OK_STRICT\n-\n-/* Nonzero if X is a hard reg that can be used as an index\n-   or if it is a pseudo reg.  */\n-#define REG_OK_FOR_INDEX_P(X) (((unsigned) REGNO (X)) - 32 >= 14)\n-/* Nonzero if X is a hard reg that can be used as a base reg\n-   or if it is a pseudo reg.  */\n-#define REG_OK_FOR_BASE_P(X) (((unsigned) REGNO (X)) - 32 >= 14)\n-\n-#else\n-\n-/* Nonzero if X is a hard reg that can be used as an index.  */\n-#define REG_OK_FOR_INDEX_P(X) REGNO_OK_FOR_INDEX_P (REGNO (X))\n-/* Nonzero if X is a hard reg that can be used as a base reg.  */\n-#define REG_OK_FOR_BASE_P(X) REGNO_OK_FOR_BASE_P (REGNO (X))\n-\n-#endif\n-\f\n-/* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression\n-   that is a valid memory address for an instruction.\n-   The MODE argument is the machine mode for the MEM expression\n-   that wants to use this address.\n-\n-   On SPUR, the actual legitimate addresses must be REG+SMALLINT or REG+REG.\n-   Actually, REG+REG is not legitimate for stores, so \n-   it is obtained only by combination on loads.\n-   We can treat a SYMBOL_REF as legitimate if it is part of this\n-   function's constant-pool, because such addresses can actually\n-   be output as REG+SMALLINT.  */\n-\n-#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)  \\\n-{ if (GET_CODE (X) == REG\t\t\t\\\n-      && REG_OK_FOR_BASE_P (X))\t\t\t\\\n-    goto ADDR;\t\t\t\t\t\\\n-  if (GET_CODE (X) == SYMBOL_REF && (X)->unchanging)\t\\\n-    goto ADDR;\t\t\t\t\t\\\n-  if (GET_CODE (X) == PLUS\t\t\t\\\n-      && GET_CODE (XEXP (X, 0)) == REG\t\t\\\n-      && REG_OK_FOR_BASE_P (XEXP (X, 0)))\t\\\n-    {\t\t\t\t\t\t\\\n-      if (GET_CODE (XEXP (X, 1)) == CONST_INT\t\\\n-\t  && INTVAL (XEXP (X, 1)) >= -0x2000\t\\\n-\t  && INTVAL (XEXP (X, 1)) < 0x2000)\t\\\n-\tgoto ADDR;\t\t\t\t\\\n-    }\t\t\t\t\t\t\\\n-}\n-\f\n-/* Try machine-dependent ways of modifying an illegitimate address\n-   to be legitimate.  If we find one, return the new, valid address.\n-   This macro is used in only one place: `memory_address' in explow.c.\n-\n-   OLDX is the address as it was before break_out_memory_refs was called.\n-   In some cases it is useful to look at this to decide what needs to be done.\n-\n-   MODE and WIN are passed so that this macro can use\n-   GO_IF_LEGITIMATE_ADDRESS.\n-\n-   It is always safe for this macro to do nothing.  It exists to recognize\n-   opportunities to optimize the output.  */\n-\n-/* On SPUR, change REG+N into REG+REG, and REG+(X*Y) into REG+REG.  */\n-\n-#define LEGITIMIZE_ADDRESS(X,OLDX,MODE,WIN)\t\\\n-{ if (GET_CODE (X) == PLUS && CONSTANT_ADDRESS_P (XEXP (X, 1)))\t\\\n-    (X) = gen_rtx_PLUS (SImode, XEXP (X, 0),\t\t\t\\\n-\t\t\tcopy_to_mode_reg (SImode, XEXP (X, 1))); \\\n-  if (GET_CODE (X) == PLUS && CONSTANT_ADDRESS_P (XEXP (X, 0)))\t\\\n-    (X) = gen_rtx_PLUS (SImode, XEXP (X, 1),\t\t\t\\\n-\t\t\tcopy_to_mode_reg (SImode, XEXP (X, 0))); \\\n-  if (GET_CODE (X) == PLUS && GET_CODE (XEXP (X, 0)) == MULT)\t\\\n-    (X) = gen_rtx_PLUS (SImode, XEXP (X, 1),\t\t\t\\\n-\t\t\tforce_operand (XEXP (X, 0), 0));\t\\\n-  if (GET_CODE (X) == PLUS && GET_CODE (XEXP (X, 1)) == MULT)\t\\\n-    (X) = gen_rtx_PLUS (SImode, XEXP (X, 0),\t\t\t\\\n-\t\t\tforce_operand (XEXP (X, 1), 0));\t\\\n-  if (memory_address_p (MODE, X))\t\t\t\t\\\n-    goto WIN; }\n-\n-/* Go to LABEL if ADDR (a legitimate address expression)\n-   has an effect that depends on the machine mode it is used for.\n-   On the SPUR this is never true.  */\n-\n-#define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR,LABEL)\n-\f\n-/* Specify the machine mode that this machine uses\n-   for the index in the tablejump instruction.  */\n-#define CASE_VECTOR_MODE SImode\n-\n-/* Define as C expression which evaluates to nonzero if the tablejump\n-   instruction expects the table to contain offsets from the address of the\n-   table.\n-   Do not define this if the table should contain absolute addresses. */\n-/* #define CASE_VECTOR_PC_RELATIVE 1 */\n-\n-/* Specify the tree operation to be used to convert reals to integers.  */\n-#define IMPLICIT_FIX_EXPR FIX_ROUND_EXPR\n-\n-/* This is the kind of divide that is easiest to do in the general case.  */\n-#define EASY_DIV_EXPR TRUNC_DIV_EXPR\n-\n-/* Define this as 1 if `char' should by default be signed; else as 0.  */\n-#define DEFAULT_SIGNED_CHAR 0\n-\n-/* Max number of bytes we can move from memory to memory\n-   in one reasonably fast instruction.  */\n-#define MOVE_MAX 4\n-\n-/* Nonzero if access to memory by bytes is slow and undesirable.  */\n-#define SLOW_BYTE_ACCESS 1\n-\n-/* This is BSD, so it wants DBX format.  */\n-#define DBX_DEBUGGING_INFO\n-\n-/* Do not break .stabs pseudos into continuations.  */\n-#define DBX_CONTIN_LENGTH 0\n-\n-/* Don't try to use the `x' type-cross-reference character in DBX data.\n-   Also has the consequence of putting each struct, union or enum\n-   into a separate .stabs, containing only cross-refs to the others.  */\n-#define DBX_NO_XREFS\n-\n-/* Value is 1 if truncating an integer of INPREC bits to OUTPREC bits\n-   is done just by pretending it is already truncated.  */\n-#define TRULY_NOOP_TRUNCATION(OUTPREC, INPREC) 1\n-\n-/* Specify the machine mode that pointers have.\n-   After generation of rtl, the compiler makes no further distinction\n-   between pointers and any other objects of this machine mode.  */\n-#define Pmode SImode\n-\n-/* A function address in a call instruction\n-   is a byte address (for indexing purposes)\n-   so give the MEM rtx a byte's mode.  */\n-#define FUNCTION_MODE SImode\n-\n-/* Define this if addresses of constant functions\n-   shouldn't be put through pseudo regs where they can be cse'd.\n-   Desirable on machines where ordinary constants are expensive\n-   but a CALL with constant address is cheap.  */\n-#define NO_FUNCTION_CSE\n-\n-/* Compute the cost of computing a constant rtl expression RTX\n-   whose rtx-code is CODE.  The body of this macro is a portion\n-   of a switch statement.  If the code is computed here,\n-   return it with a return statement.  Otherwise, break from the switch.  */\n-\n-#define CONST_COSTS(RTX,CODE,OUTER_CODE) \\\n-  case CONST_INT:\t\t\t\t\t\t\\\n-    if (INTVAL (RTX) < 0x2000 && INTVAL (RTX) >= -0x2000) return 1; \\\n-  case CONST:\t\t\t\t\t\t\t\\\n-  case LABEL_REF:\t\t\t\t\t\t\\\n-  case SYMBOL_REF:\t\t\t\t\t\t\\\n-    return 2;\t\t\t\t\t\t\t\\\n-  case CONST_DOUBLE:\t\t\t\t\t\t\\\n-    return 4;\n-\f\n-/* Tell final.c how to eliminate redundant test instructions.  */\n-\n-/* Here we define machine-dependent flags and fields in cc_status\n-   (see `conditions.h').  */\n-\n-/* (None are needed on SPUR.)  */\n-\n-/* Store in cc_status the expressions\n-   that the condition codes will describe\n-   after execution of an instruction whose pattern is EXP.\n-   Do not alter them if the instruction would not alter the cc's.  */\n-\n-/* The SPUR does not really have a condition code.  */\n-\n-#define NOTICE_UPDATE_CC(EXP, INSN) \\\n-{ CC_STATUS_INIT; }\n-\f\n-/* Control the assembler format that we output.  */\n-\n-/* Output at beginning of assembler file.  */\n-\n-#define ASM_FILE_START(FILE)\n-\n-/* Output to assembler file text saying following lines\n-   may contain character constants, extra white space, comments, etc.  */\n-\n-#define ASM_APP_ON \"\"\n-\n-/* Output to assembler file text saying following lines\n-   no longer contain unusual constructs.  */\n-\n-#define ASM_APP_OFF \"\"\n-\n-/* Output before read-only data.  */\n-\n-#define TEXT_SECTION_ASM_OP \"\\t.text\"\n-\n-/* Output before writable data.  */\n-\n-#define DATA_SECTION_ASM_OP \"\\t.data\"\n-\n-/* How to refer to registers in assembler output.\n-   This sequence is indexed by compiler's hard-register-number (see above).  */\n-\n-#define REGISTER_NAMES \\\n-{\"r0\", \"r1\", \"r2\", \"r3\", \"r4\", \"r5\", \"r6\", \"r7\", \"r8\", \"r9\",\t\t\\\n- \"r10\", \"r11\", \"r12\", \"r13\", \"r14\", \"r15\", \"r16\", \"r17\", \"r18\", \"r19\",\t\\\n- \"r20\", \"r21\", \"r22\", \"r23\", \"r24\", \"r25\", \"r26\", \"r27\", \"r28\", \"r29\",\t\\\n- \"r30\", \"r31\",\t\t\t\t\t\t\t\t\\\n- \"f0\", \"f1\", \"f2\", \"f3\", \"f4\", \"f5\", \"f6\", \"f7\", \"f8\", \"f9\",\t\\\n- \"f10\", \"f11\", \"f12\", \"f13\", \"f14\" }\n-\n-/* How to renumber registers for dbx and gdb.  */\n-\n-#define DBX_REGISTER_NUMBER(REGNO) (REGNO)\n-\n-/* This is how to output the definition of a user-level label named NAME,\n-   such as the label on a static function or variable NAME.  */\n-\n-#define ASM_OUTPUT_LABEL(FILE,NAME)\t\\\n-  do { assemble_name (FILE, NAME); fputs (\":\\n\", FILE); } while (0)\n-\n-/* This is how to output a command to make the user-level label named NAME\n-   defined for reference from other files.  */\n-\n-#define ASM_GLOBALIZE_LABEL(FILE,NAME)\t\\\n-  do { fputs (\".globl \", FILE); assemble_name (FILE, NAME); fputs (\"\\n\", FILE);} while (0)\n-\n-/* The prefix to add to user-visible assembler symbols. */\n-\n-#define USER_LABEL_PREFIX \"_\"\n-\n-/* This is how to output an internal numbered label where\n-   PREFIX is the class of label and NUM is the number within the class.  */\n-\n-#define ASM_OUTPUT_INTERNAL_LABEL(FILE,PREFIX,NUM)\t\\\n-  fprintf (FILE, \"%s%d:\\n\", PREFIX, NUM)\n-\n-/* This is how to store into the string LABEL\n-   the symbol_ref name of an internal numbered label where\n-   PREFIX is the class of label and NUM is the number within the class.\n-   This is suitable for output with `assemble_name'.  */\n-\n-#define ASM_GENERATE_INTERNAL_LABEL(LABEL,PREFIX,NUM)\t\\\n-  sprintf (LABEL, \"*%s%d\", PREFIX, NUM)\n-\n-/* This is how to output an assembler line defining a `double' constant.  */\n-\n-#define ASM_OUTPUT_DOUBLE(FILE,VALUE)  \\\n-  fprintf (FILE, \"\\t.double %.20e\\n\", (VALUE))\n-\n-/* This is how to output an assembler line defining a `float' constant.  */\n-\n-#define ASM_OUTPUT_FLOAT(FILE,VALUE)  \\\n-  fprintf (FILE, \"\\t.single %.12e\\n\", (VALUE))\n-\n-/* This is how to output an assembler line defining an `int' constant.  */\n-\n-#define ASM_OUTPUT_INT(FILE,VALUE)  \\\n-( fprintf (FILE, \"\\t.long \"),\t\t\t\\\n-  output_addr_const (FILE, (VALUE)),\t\t\\\n-  fprintf (FILE, \"\\n\"))\n-\n-/* Likewise for `char' and `short' constants.  */\n-\n-#define ASM_OUTPUT_SHORT(FILE,VALUE)  \\\n-( fprintf (FILE, \"\\t.word \"),\t\t\t\\\n-  output_addr_const (FILE, (VALUE)),\t\t\\\n-  fprintf (FILE, \"\\n\"))\n-\n-#define ASM_OUTPUT_CHAR(FILE,VALUE)  \\\n-( fprintf (FILE, \"\\t.byte \"),\t\t\t\\\n-  output_addr_const (FILE, (VALUE)),\t\t\\\n-  fprintf (FILE, \"\\n\"))\n-\n-/* This is how to output an assembler line for a numeric constant byte.  */\n-\n-#define ASM_OUTPUT_BYTE(FILE,VALUE)  \\\n-  fprintf (FILE, \"\\t.byte 0x%x\\n\", (VALUE))\n-\n-/* This is how to output code to push a register on the stack.\n-   It need not be very fast code.  */\n-\n-#define ASM_OUTPUT_REG_PUSH(FILE,REGNO)  \\\n-  fprintf (FILE, \"\\tadd_nt r4,r4,$-4\\n\\tst_32 %s,r4,$0\\n\", reg_names[REGNO])\n-\n-/* This is how to output an insn to pop a register from the stack.\n-   It need not be very fast code.  */\n-\n-#define ASM_OUTPUT_REG_POP(FILE,REGNO)  \\\n-  fprintf (FILE, \"\\tld_32 %s,r4,$0\\n\\tadd_nt r4,r4,$4\\n\", reg_names[REGNO])\n-\n-/* This is how to output an element of a case-vector that is absolute.  */\n-\n-#define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)  \\\n-  fprintf (FILE, \"\\t.long L%d\\n\", VALUE)\n-\n-/* This is how to output an element of a case-vector that is relative.\n-   (SPUR does not use such vectors,\n-   but we must define this macro anyway.)  */\n-\n-#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL)  \\\n-  fprintf (FILE, \"\\t.word L%d-L%d\\n\", VALUE, REL)\n-\n-/* This is how to output an assembler line\n-   that says to advance the location counter\n-   to a multiple of 2**LOG bytes.  */\n-\n-#define ASM_OUTPUT_ALIGN(FILE,LOG)\t\\\n-  if ((LOG) != 0)\t\t\t\\\n-    fprintf (FILE, \"\\t.align %d\\n\", (LOG))\n-\n-#define ASM_OUTPUT_SKIP(FILE,SIZE)  \\\n-  fprintf (FILE, \"\\t.space %u\\n\", (SIZE))\n-\n-/* This says how to output an assembler line\n-   to define a global common symbol.  */\n-\n-#define ASM_OUTPUT_COMMON(FILE, NAME, SIZE, ROUNDED)  \\\n-( fputs (\".comm \", (FILE)),\t\t\t\\\n-  assemble_name ((FILE), (NAME)),\t\t\\\n-  fprintf ((FILE), \",%u\\n\", (ROUNDED)))\n-\n-/* This says how to output an assembler line\n-   to define a local common symbol.  */\n-\n-#define ASM_OUTPUT_LOCAL(FILE, NAME, SIZE, ROUNDED)  \\\n-( fputs (\".lcomm \", (FILE)),\t\t\t\\\n-  assemble_name ((FILE), (NAME)),\t\t\\\n-  fprintf ((FILE), \",%u\\n\", (ROUNDED)))\n-\n-/* Store in OUTPUT a string (made with alloca) containing\n-   an assembler-name for a local static variable named NAME.\n-   LABELNO is an integer which is different for each call.  */\n-\n-#define ASM_FORMAT_PRIVATE_NAME(OUTPUT, NAME, LABELNO)\t\\\n-( (OUTPUT) = (char *) alloca (strlen ((NAME)) + 10),\t\\\n-  sprintf ((OUTPUT), \"%s.%d\", (NAME), (LABELNO)))\n-\n-/* Define the parentheses used to group arithmetic operations\n-   in assembler code.  */\n-\n-#define ASM_OPEN_PAREN \"(\"\n-#define ASM_CLOSE_PAREN \")\"\n-\n-/* Define results of standard character escape sequences.  */\n-#define TARGET_BELL 007\n-#define TARGET_BS 010\n-#define TARGET_TAB 011\n-#define TARGET_NEWLINE 012\n-#define TARGET_VT 013\n-#define TARGET_FF 014\n-#define TARGET_CR 015\n-\n-/* Print operand X (an rtx) in assembler syntax to file FILE.\n-   CODE is a letter or dot (`z' in `%z0') or 0 if no letter was specified.\n-   For `%' followed by punctuation, CODE is the punctuation and X is null.\n-\n-   On SPUR, the CODE can be `r', meaning this is a register-only operand\n-   and an immediate zero should be represented as `r0'.  */\n-\n-#define PRINT_OPERAND(FILE, X, CODE)  \\\n-{ if (GET_CODE (X) == REG)\t\t\t\t\t\t\\\n-    fprintf (FILE, \"%s\", reg_names[REGNO (X)]);\t\t\t\t\\\n-  else if (GET_CODE (X) == MEM)\t\t\t\t\t\t\\\n-    output_address (XEXP (X, 0));\t\t\t\t\t\\\n-  else if (GET_CODE (X) == CONST_DOUBLE)\t\t\t\t\\\n-    abort ();\t\t\t\t\t\t\t\t\\\n-  else if ((CODE) == 'r' && (X) == const0_rtx)\t\t\t\t\\\n-    fprintf (FILE, \"r0\");\t\t\t\t\t\t\\\n-  else { putc ('$', FILE); output_addr_const (FILE, X); }}\n-\f\n-/* Print a memory address as an operand to reference that memory location.  */\n-\n-#define PRINT_OPERAND_ADDRESS(FILE, ADDR)  \\\n-{ register rtx base, index = 0;\t\t\t\t\t\\\n-  int offset = 0;\t\t\t\t\t\t\\\n-  register rtx addr = ADDR;\t\t\t\t\t\\\n-  if (GET_CODE (addr) == REG)\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      fprintf (FILE, \"%s,$0\", reg_names[REGNO (addr)]);\t\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-  else if (GET_CODE (addr) == PLUS)\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      if (GET_CODE (XEXP (addr, 0)) == CONST_INT)\t\t\\\n-\toffset = INTVAL (XEXP (addr, 0)), base = XEXP (addr, 1);\\\n-      else if (GET_CODE (XEXP (addr, 1)) == CONST_INT)\t\t\\\n-\toffset = INTVAL (XEXP (addr, 1)), base = XEXP (addr, 0);\\\n-      else\t\t\t\t\t\t\t\\\n-\tbase = XEXP (addr, 0), index = XEXP (addr, 1);\t\t\\\n-      fprintf (FILE, \"%s,\", reg_names[REGNO (base)]);\t\t\\\n-      if (index == 0)\t\t\t\t\t\t\\\n-\tfprintf (FILE, \"$%d\", offset);\t\t\t\t\\\n-      else\t\t\t\t\t\t\t\\\n-\tfprintf (FILE, \"%s,\", reg_names[REGNO (index)]);\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-  else\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      fprintf (FILE, \"r24,$(\");\t\t\t\t\t\\\n-      output_addr_const (FILE, addr);\t\t\t\t\\\n-      fprintf (FILE, \"-0b)\");\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-}"}, {"sha": "100cc0b5a924292a0a2d72963da4ff10e386fcbb", "filename": "gcc/config/spur/spur.md", "status": "removed", "additions": 0, "deletions": 1092, "changes": 1092, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7b4171a5b8a655097812307bbe261032dfbe366/gcc%2Fconfig%2Fspur%2Fspur.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7b4171a5b8a655097812307bbe261032dfbe366/gcc%2Fconfig%2Fspur%2Fspur.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspur%2Fspur.md?ref=a7b4171a5b8a655097812307bbe261032dfbe366", "patch": "@@ -1,1092 +0,0 @@\n-;;- Machine description for SPUR chip for GNU C compiler\n-;;  Copyright (C) 1988, 1998, 1999 Free Software Foundation, Inc.\n-\n-;; This file is part of GNU CC.\n-\n-;; GNU CC is free software; you can redistribute it and/or modify\n-;; it under the terms of the GNU General Public License as published by\n-;; the Free Software Foundation; either version 2, or (at your option)\n-;; any later version.\n-\n-;; GNU CC is distributed in the hope that it will be useful,\n-;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n-;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-;; GNU General Public License for more details.\n-\n-;; You should have received a copy of the GNU General Public License\n-;; along with GNU CC; see the file COPYING.  If not, write to\n-;; the Free Software Foundation, 59 Temple Place - Suite 330,\n-;; Boston, MA 02111-1307, USA.\n-\n-\n-;;- See file \"rtl.def\" for documentation on define_insn, match_*, et. al.\n-\n-;;- cpp macro #define NOTICE_UPDATE_CC in file tm.h handles condition code\n-;;- updates for most instructions.\n-\n-;;- Operand classes for the register allocator:\n-\f\n-;; Compare instructions.\n-;; This pattern is used for generating an \"insn\"\n-;; which does just a compare and sets a (fictitious) condition code.\n-\n-;; The actual SPUR insns are compare-and-conditional-jump.\n-;; The define_peephole's below recognize the combinations of\n-;; compares and jumps, and output each pair as a single assembler insn.\n-\n-;; This controls RTL generation and register allocation.\n-(define_insn \"cmpsi\"\n-  [(set (cc0)\n-\t(compare (match_operand:SI 0 \"register_operand\" \"rK\")\n-\t\t (match_operand:SI 1 \"nonmemory_operand\" \"rK\")))]\n-  \"\"\n-  \"*\n-{\n-  cc_status.value1 = operands[0], cc_status.value2 = operands[1];\n-  return \\\"\\\";\n-}\")\n-\n-;; We have to have this because cse can optimize the previous pattern\n-;; into this one.\n-\n-(define_insn \"tstsi\"\n-  [(set (cc0)\n-\t(match_operand:SI 0 \"register_operand\" \"r\"))]\n-  \"\"\n-  \"*\n-{\n-  cc_status.value1 = operands[0], cc_status.value2 = const0_rtx;\n-  return \\\"\\\";\n-}\")\n-\n-\n-;; These control RTL generation for conditional jump insns\n-;; and match them for register allocation.\n-\n-(define_insn \"beq\"\n-  [(set (pc)\n-\t(if_then_else (eq (cc0)\n-\t\t\t  (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"* return output_compare (operands, \\\"eq\\\", \\\"eq\\\", \\\"ne\\\", \\\"ne\\\"); \")\n-\n-(define_insn \"bne\"\n-  [(set (pc)\n-\t(if_then_else (ne (cc0)\n-\t\t\t  (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"* return output_compare (operands, \\\"ne\\\", \\\"ne\\\", \\\"eq\\\", \\\"eq\\\"); \")\n-\n-(define_insn \"bgt\"\n-  [(set (pc)\n-\t(if_then_else (gt (cc0)\n-\t\t\t  (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"* return output_compare (operands, \\\"gt\\\", \\\"lt\\\", \\\"le\\\", \\\"ge\\\"); \")\n-\n-(define_insn \"bgtu\"\n-  [(set (pc)\n-\t(if_then_else (gtu (cc0)\n-\t\t\t   (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"* return output_compare (operands, \\\"ugt\\\", \\\"ult\\\", \\\"ule\\\", \\\"uge\\\"); \")\n-\n-(define_insn \"blt\"\n-  [(set (pc)\n-\t(if_then_else (lt (cc0)\n-\t\t\t  (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"* return output_compare (operands, \\\"lt\\\", \\\"gt\\\", \\\"ge\\\", \\\"le\\\"); \")\n-\n-(define_insn \"bltu\"\n-  [(set (pc)\n-\t(if_then_else (ltu (cc0)\n-\t\t\t   (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"* return output_compare (operands, \\\"ult\\\", \\\"ugt\\\", \\\"uge\\\", \\\"ule\\\"); \")\n-\n-(define_insn \"bge\"\n-  [(set (pc)\n-\t(if_then_else (ge (cc0)\n-\t\t\t  (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"* return output_compare (operands, \\\"ge\\\", \\\"le\\\", \\\"lt\\\", \\\"gt\\\"); \")\n-\n-(define_insn \"bgeu\"\n-  [(set (pc)\n-\t(if_then_else (geu (cc0)\n-\t\t\t   (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"* return output_compare (operands, \\\"uge\\\", \\\"ule\\\", \\\"ult\\\", \\\"ugt\\\"); \")\n-\n-(define_insn \"ble\"\n-  [(set (pc)\n-\t(if_then_else (le (cc0)\n-\t\t\t  (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"* return output_compare (operands, \\\"le\\\", \\\"ge\\\", \\\"gt\\\", \\\"lt\\\"); \")\n-\n-(define_insn \"bleu\"\n-  [(set (pc)\n-\t(if_then_else (leu (cc0)\n-\t\t\t   (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n-  \"\"\n-  \"* return output_compare (operands, \\\"ule\\\", \\\"uge\\\", \\\"ugt\\\", \\\"ult\\\"); \")\n-\f\n-;; These match inverted jump insns for register allocation.\n-\n-(define_insn \"\"\n-  [(set (pc)\n-\t(if_then_else (eq (cc0)\n-\t\t\t  (const_int 0))\n-\t\t      (pc)\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n-  \"\"\n-  \"* return output_compare (operands, \\\"ne\\\", \\\"ne\\\", \\\"eq\\\", \\\"eq\\\"); \")\n-\n-(define_insn \"\"\n-  [(set (pc)\n-\t(if_then_else (ne (cc0)\n-\t\t\t  (const_int 0))\n-\t\t      (pc)\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n-  \"\"\n-  \"* return output_compare (operands, \\\"eq\\\", \\\"eq\\\", \\\"ne\\\", \\\"ne\\\"); \")\n-\n-(define_insn \"\"\n-  [(set (pc)\n-\t(if_then_else (gt (cc0)\n-\t\t\t  (const_int 0))\n-\t\t      (pc)\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n-  \"\"\n-  \"* return output_compare (operands, \\\"le\\\", \\\"ge\\\", \\\"gt\\\", \\\"lt\\\"); \")\n-\n-(define_insn \"\"\n-  [(set (pc)\n-\t(if_then_else (gtu (cc0)\n-\t\t\t   (const_int 0))\n-\t\t      (pc)\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n-  \"\"\n-  \"* return output_compare (operands, \\\"ule\\\", \\\"uge\\\", \\\"ugt\\\", \\\"ult\\\"); \")\n-\n-(define_insn \"\"\n-  [(set (pc)\n-\t(if_then_else (lt (cc0)\n-\t\t\t  (const_int 0))\n-\t\t      (pc)\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n-  \"\"\n-  \"* return output_compare (operands, \\\"ge\\\", \\\"le\\\", \\\"lt\\\", \\\"gt\\\"); \")\n-\n-(define_insn \"\"\n-  [(set (pc)\n-\t(if_then_else (ltu (cc0)\n-\t\t\t   (const_int 0))\n-\t\t      (pc)\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n-  \"\"\n-  \"* return output_compare (operands, \\\"uge\\\", \\\"ule\\\", \\\"ult\\\", \\\"ugt\\\"); \")\n-\n-(define_insn \"\"\n-  [(set (pc)\n-\t(if_then_else (ge (cc0)\n-\t\t\t  (const_int 0))\n-\t\t      (pc)\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n-  \"\"\n-  \"* return output_compare (operands, \\\"lt\\\", \\\"gt\\\", \\\"ge\\\", \\\"le\\\"); \")\n-\n-(define_insn \"\"\n-  [(set (pc)\n-\t(if_then_else (geu (cc0)\n-\t\t\t   (const_int 0))\n-\t\t      (pc)\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n-  \"\"\n-  \"* return output_compare (operands, \\\"ult\\\", \\\"ugt\\\", \\\"uge\\\", \\\"ule\\\"); \")\n-\n-(define_insn \"\"\n-  [(set (pc)\n-\t(if_then_else (le (cc0)\n-\t\t\t  (const_int 0))\n-\t\t      (pc)\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n-  \"\"\n-  \"* return output_compare (operands, \\\"gt\\\", \\\"lt\\\", \\\"le\\\", \\\"ge\\\"); \")\n-\n-(define_insn \"\"\n-  [(set (pc)\n-\t(if_then_else (leu (cc0)\n-\t\t\t   (const_int 0))\n-\t\t      (pc)\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n-  \"\"\n-  \"* return output_compare (operands, \\\"ugt\\\", \\\"ult\\\", \\\"ule\\\", \\\"uge\\\"); \")\n-\f\n-;; Move instructions\n-\n-(define_insn \"movsi\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=r,m\")\n-\t(match_operand:SI 1 \"general_operand\" \"rmi,rJ\"))]\n-  \"\"\n-  \"*\n-{\n-  if (GET_CODE (operands[0]) == MEM)\n-    return \\\"st_32 %r1,%0\\\";\n-  if (GET_CODE (operands[1]) == MEM)\n-    return \\\"ld_32 %0,%1\\;nop\\\";\n-  if (GET_CODE (operands[1]) == REG)\n-    return \\\"add_nt %0,%1,$0\\\";\n-  if (GET_CODE (operands[1]) == SYMBOL_REF && operands[1]->unchanging)\n-    return \\\"add_nt %0,r24,$(%1-0b)\\\";\n-  return \\\"add_nt %0,r0,%1\\\";\n-}\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(mem:SI (plus:SI (match_operand:SI 1 \"register_operand\" \"r\")\n-\t\t\t (match_operand:SI 2 \"register_operand\" \"r\"))))]\n-  \"\"\n-  \"ld_32 %0,%1,%2\\;nop\")\n-\f\n-;; Generate insns for moving single bytes.\n-\n-(define_expand \"movqi\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"\")\n-\t(match_operand:QI 1 \"general_operand\" \"\"))]\n-  \"\"\n-  \"\n-{\n-  if (GET_CODE (operands[0]) == MEM && GET_CODE (operands[1]) == MEM)\n-    operands[1] = copy_to_reg (operands[1]);\n-\n-  if (GET_CODE (operands[1]) == MEM)\n-    {\n-      rtx tem = gen_reg_rtx (SImode);\n-      rtx addr = force_reg (SImode, XEXP (operands[1], 0));\n-      rtx subreg;\n-\n-      emit_move_insn (tem, gen_rtx_MEM (SImode, addr));\n-      if (GET_CODE (operands[0]) == SUBREG)\n-\tsubreg = gen_rtx_SUBREG (SImode, SUBREG_REG (operands[0]),\n-\t\t\t\t SUBREG_WORD (operands[0]));\n-      else\n-\tsubreg = gen_rtx_SUBREG (SImode, operands[0], 0);\n-\n-      emit_insn (gen_rtx_SET (VOIDmode, subreg,\n-\t\t\t      gen_rtx_ZERO_EXTRACT (SImode, tem,\n-\t\t\t\t\t\t    GEN_INT (8),\n-\t\t\t\t\t\t    addr)));\n-    }\n-  else if (GET_CODE (operands[0]) == MEM)\n-    {\n-      rtx tem = gen_reg_rtx (SImode);\n-      rtx addr = force_reg (SImode, XEXP (operands[0], 0));\n-      rtx subreg;\n-\n-      emit_move_insn (tem, gen_rtx_MEM (SImode, addr));\n-      if (! CONSTANT_ADDRESS_P (operands[1]))\n-\t{\n-\t  if (GET_CODE (operands[1]) == SUBREG)\n-\t    subreg = gen_rtx_SUBREG (SImode, SUBREG_REG (operands[1]),\n-\t\t\t\t     SUBREG_WORD (operands[1]));\n-\t  else\n-\t    subreg = gen_rtx_SUBREG (SImode, operands[1], 0);\n-\t}\n-\n-      emit_insn (gen_rtx_SET (VOIDmode,\n-\t\t\t      gen_rtx_ZERO_EXTRACT (SImode, tem,\n-\t\t\t\t\t\t    GEN_INT (8),\n-\t\t\t\t\t\t    addr),\n-\t\t\t      subreg));\n-      emit_move_insn (gen_rtx_MEM (SImode, addr), tem);\n-    }\n-  else\n-    {\n-      emit_insn (gen_rtx_SET (VOIDmode, operands[0], operands[1]));\n-    }\n-  DONE;\n-}\")\n-\f\n-;; Recognize insns generated for moving single bytes.\n-\n-(define_insn \"\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"=r,m\")\n-\t(match_operand:QI 1 \"general_operand\" \"rmi,r\"))]\n-  \"\"\n-  \"*\n-{\n-  if (GET_CODE (operands[0]) == MEM)\n-    return \\\"st_32 %1,%0\\\";\n-  if (GET_CODE (operands[1]) == MEM)\n-    return \\\"ld_32 %0,%1\\;nop\\\";\n-  if (GET_CODE (operands[1]) == REG)\n-    return \\\"add_nt %0,%1,$0\\\";\n-  return \\\"add_nt %0,r0,%1\\\";\n-}\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(zero_extract:SI (match_operand:SI 1 \"register_operand\" \"r\")\n-\t\t\t (const_int 8)\n-\t\t\t (match_operand:SI 2 \"nonmemory_operand\" \"rI\")))]\n-  \"\"\n-  \"extract %0,%1,%2\")\n-\n-(define_insn \"\"\n-  [(set (zero_extract:SI (match_operand:SI 0 \"register_operand\" \"+r\")\n-\t\t\t (const_int 8)\n-\t\t\t (match_operand:SI 1 \"nonmemory_operand\" \"rI\"))\n-\t(match_operand:SI 2 \"nonmemory_operand\" \"ri\"))]\n-  \"\"\n-  \"wr_insert %1\\;insert %0,%0,%2\")\n-\n-;; Constant propagation can optimize the previous pattern into this pattern.\n-;[Not any more.  It could when the position-operand contains a MULT.]\n-\n-;(define_insn \"\"\n-;  [(set (zero_extract:QI (match_operand:SI 0 \"register_operand\" \"+r\")\n-;\t\t\t (const_int 8)\n-;\t\t\t (match_operand:SI 1 \"immediate_operand\" \"I\"))\n-;\t(match_operand:QI 2 \"register_operand\" \"r\"))]\n-;  \"GET_CODE (operands[1]) == CONST_INT\n-;   && INTVAL (operands[1]) % 8 == 0\n-;   && (unsigned) INTVAL (operands[1]) < 32\"\n-;  \"*\n-;{\n-;  operands[1] = GEN_INT (INTVAL (operands[1]) / 8);\n-;  return \\\"wr_insert 0,0,%1\\;insert %0,%0,%2\\\";\n-;}\")\n-\f\n-;; The three define_expand patterns on this page\n-;; serve as subroutines of \"movhi\".\n-\n-;; Generate code to fetch an aligned halfword from memory.\n-;; Operand 0 is the destination register (HImode).\n-;; Operand 1 is the memory address (SImode).\n-;; Operand 2 is a temporary (SImode).\n-;; Operand 3 is a temporary (SImode).\n-;; Operand 4 is a temporary (QImode).\n-\n-;; Operand 5 is an internal temporary (HImode).\n-\n-(define_expand \"loadhi\"\n-  [(set (match_operand:SI 2 \"register_operand\" \"\")\n-\t(mem:SI (match_operand:SI 1 \"register_operand\" \"\")))\n-   ;; Extract the low byte.\n-   (set (subreg:SI (match_dup 5) 0)\n-\t(zero_extract:SI (match_dup 2) (const_int 8) (match_dup 1)))\n-   ;; Form address of high byte.\n-   (set (match_operand:SI 3 \"register_operand\" \"\")\n-\t(plus:SI (match_dup 1) (const_int 1)))\n-   ;; Extract the high byte.\n-   (set (subreg:SI (match_operand:QI 4 \"register_operand\" \"\") 0)\n-\t(zero_extract:SI (match_dup 2) (const_int 8) (match_dup 3)))\n-   ;; Put the high byte in with the low one.\n-   (set (zero_extract:SI (match_dup 5) (const_int 8) (const_int 1))\n-\t(subreg:SI (match_dup 4) 0))\n-   (set (match_operand:HI 0 \"register_operand\" \"\") (match_dup 5))]\n-  \"\"\n-  \"operands[5] = gen_reg_rtx (HImode);\")\n-\n-;; Generate code to store an aligned halfword into memory.\n-;; Operand 0 is the destination address (SImode).\n-;; Operand 1 is the source register (HImode, not constant).\n-;; Operand 2 is a temporary (SImode).\n-;; Operand 3 is a temporary (SImode).\n-;; Operand 4 is a temporary (QImode).\n-\n-;; Operand 5 is an internal variable made from operand 1.\n-\n-(define_expand \"storehi\"\n-  [(set (match_operand:SI 2 \"register_operand\" \"\")\n-\t(mem:SI (match_operand:SI 0 \"register_operand\" \"\")))\n-   ;; Insert the low byte.\n-   (set (zero_extract:SI (match_dup 2) (const_int 8) (match_dup 0))\n-\t(match_dup 5))\n-   ;; Form address of high byte.\n-   (set (match_operand:SI 3 \"register_operand\" \"\")\n-\t(plus:SI (match_dup 0) (const_int 1)))\n-   ;; Extract the high byte from the source.\n-   (set (subreg:SI (match_operand:QI 4 \"register_operand\" \"\") 0)\n-\t(zero_extract:SI (match_operand:HI 1 \"register_operand\" \"\")\n-\t\t\t (const_int 8) (const_int 1)))\n-   ;; Store high byte into the memory word\n-   (set (zero_extract:SI (match_dup 2) (const_int 8) (match_dup 3))\n-\t(subreg:SI (match_dup 4) 0))\n-   ;; Put memory word back into memory.\n-   (set (mem:SI (match_dup 0))\n-\t(match_dup 2))]\n-  \"\"\n-  \"\n-{\n-  if (GET_CODE (operands[1]) == SUBREG)\n-    operands[5] = gen_rtx_SUBREG (SImode, SUBREG_REG (operands[1]),\n-\t\t\t\t  SUBREG_WORD (operands[1]));\n-  else\n-    operands[5] = gen_rtx_SUBREG (SImode, operands[1], 0);\n-}\")\n-\n-;; Like storehi but operands[1] is a CONST_INT.\n-\n-(define_expand \"storeinthi\"\n-  [(set (match_operand:SI 2 \"register_operand\" \"\")\n-\t(mem:SI (match_operand:SI 0 \"register_operand\" \"\")))\n-   ;; Insert the low byte.\n-   (set (zero_extract:SI (match_dup 2) (const_int 8) (match_dup 0))\n-\t(match_dup 5))\n-   ;; Form address of high byte.\n-   (set (match_operand:SI 3 \"register_operand\" \"\")\n-\t(plus:SI (match_dup 0) (const_int 1)))\n-   ;; Store high byte into the memory word\n-   (set (zero_extract:SI (match_dup 2) (const_int 8) (match_dup 3))\n-\t(match_dup 6))\n-   ;; Put memory word back into memory.\n-   (set (mem:SI (match_dup 0))\n-\t(match_dup 2))]\n-  \"\"\n-  \" operands[5] = GEN_INT (INTVAL (operands[1]) & 255);\n-    operands[6] = GEN_INT (INTVAL (operands[1]) >> 8) & 255);\n-\")\n-\f\n-;; Main entry for generating insns to move halfwords.\n-\n-(define_expand \"movhi\"\n-  [(set (match_operand:HI 0 \"general_operand\" \"\")\n-\t(match_operand:HI 1 \"general_operand\" \"\"))]\n-  \"\"\n-  \"\n-{\n-  if (GET_CODE (operands[0]) == MEM && GET_CODE (operands[1]) == MEM)\n-    operands[1] = copy_to_reg (operands[1]);\n-  \n-  if (GET_CODE (operands[1]) == MEM)\n-    {\n-      rtx insn =\n-\temit_insn (gen_loadhi (operands[0],\n-\t\t\t       force_reg (SImode, XEXP (operands[1], 0)),\n-\t\t\t       gen_reg_rtx (SImode), gen_reg_rtx (SImode),\n-\t\t\t       gen_reg_rtx (QImode)));\n-      /* Tell cse what value the loadhi produces, so it detect duplicates.  */\n-      REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_EQUAL, operands[1],\n-\t\t\t\t\t    REG_NOTES (insn));\n-    }\n-  else if (GET_CODE (operands[0]) == MEM)\n-    {\n-      if (GET_CODE (operands[1]) == CONST_INT)\n-\temit_insn (gen_storeinthi (force_reg (SImode, XEXP (operands[0], 0)),\n-\t\t\t           operands[1],\n-\t\t\t\t   gen_reg_rtx (SImode), gen_reg_rtx (SImode),\n-\t\t\t\t   gen_reg_rtx (QImode)));\n-      else\n-\t{\n-\t  if (CONSTANT_P (operands[1]))\n-            operands[1] = force_reg (HImode, operands[1]);\n-\t  emit_insn (gen_storehi (force_reg (SImode, XEXP (operands[0], 0)),\n-\t\t\t\t  operands[1],\n-\t\t\t\t  gen_reg_rtx (SImode), gen_reg_rtx (SImode),\n-\t\t\t\t  gen_reg_rtx (QImode)));\n-\t}\n-    }\n-  else\n-    emit_insn (gen_rtx_SET (VOIDmode, operands[0], operands[1]));\n-  DONE;\n-}\")\n-\f\n-;; Recognize insns generated for moving halfwords.\n-;; (Note that the extract and insert patterns for single-byte moves\n-;;  are also involved in recognizing some of the insns used for this purpose.)\n-\n-(define_insn \"\"\n-  [(set (match_operand:HI 0 \"general_operand\" \"=r,m\")\n-\t(match_operand:HI 1 \"general_operand\" \"rmi,r\"))]\n-  \"\"\n-  \"*\n-{\n-  if (GET_CODE (operands[0]) == MEM)\n-    return \\\"st_32 %1,%0\\\";\n-  if (GET_CODE (operands[1]) == MEM)\n-    return \\\"ld_32 %0,%1\\;nop\\\";\n-  if (GET_CODE (operands[1]) == REG)\n-    return \\\"add_nt %0,%1,$0\\\";\n-  return \\\"add_nt %0,r0,%1\\\";\n-}\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(zero_extract:SI (match_operand:HI 1 \"register_operand\" \"r\")\n-\t\t\t (const_int 8)\n-\t\t\t (match_operand:SI 2 \"nonmemory_operand\" \"rI\")))]\n-  \"\"\n-  \"extract %0,%1,%2\")\n-\n-(define_insn \"\"\n-  [(set (zero_extract:SI (match_operand:HI 0 \"register_operand\" \"+r\")\n-\t\t\t (const_int 8)\n-\t\t\t (match_operand:SI 1 \"nonmemory_operand\" \"rI\"))\n-\t(match_operand:SI 2 \"nonmemory_operand\" \"ri\"))]\n-  \"\"\n-  \"wr_insert %1\\;insert %0,%0,%2\")\n-\n-;; Constant propagation can optimize the previous pattern into this pattern.\n-\n-;(define_insn \"\"\n-;  [(set (zero_extract:QI (match_operand:HI 0 \"register_operand\" \"+r\")\n-;\t\t\t (const_int 8)\n-;\t\t\t (match_operand:SI 1 \"immediate_operand\" \"I\"))\n-;\t(match_operand:QI 2 \"register_operand\" \"r\"))]\n-;  \"GET_CODE (operands[1]) == CONST_INT\n-;   && INTVAL (operands[1]) % 8 == 0\n-;   && (unsigned) INTVAL (operands[1]) < 32\"\n-;  \"*\n-;{\n-;  operands[1] = GEN_INT (INTVAL (operands[1]) / 8);\n-;  return \\\"wr_insert 0,0,%1\\;insert %0,%0,%2\\\";\n-;}\")\n-\f\n-;; This pattern forces (set (reg:DF ...) (const_double ...))\n-;; to be reloaded by putting the constant into memory.\n-;; It must come before the more general movdf pattern.\n-(define_insn \"\"\n-  [(set (match_operand:DF 0 \"general_operand\" \"=&r,f,&o\")\n-\t(match_operand:DF 1 \"\" \"mG,m,G\"))]\n-  \"GET_CODE (operands[1]) == CONST_DOUBLE\"\n-  \"*\n-{\n-  if (FP_REG_P (operands[0]))\n-    return output_fp_move_double (operands);\n-  if (operands[1] == CONST0_RTX (DFmode) && GET_CODE (operands[0]) == REG)\n-    {\n-      operands[1] = gen_rtx_REG (SImode, REGNO (operands[0]) + 1);\n-      return \\\"add_nt %0,r0,$0\\;add_nt %1,r0,$0\\\";\n-    }\n-  if (operands[1] == CONST0_RTX (DFmode) && GET_CODE (operands[0]) == MEM)\n-    {\n-      operands[1] = adj_offsettable_operand (operands[0], 4);\n-      return \\\"st_32 r0,%0\\;st_32 r0,%1\\\";\n-    }\n-  return output_move_double (operands);\n-}\n-\")\n-  \n-(define_insn \"movdf\"\n-  [(set (match_operand:DF 0 \"general_operand\" \"=r,&r,m,?f,?rm\")\n-\t(match_operand:DF 1 \"general_operand\" \"r,m,r,rfm,f\"))]\n-  \"\"\n-  \"*\n-{\n-  if (FP_REG_P (operands[0]) || FP_REG_P (operands[1]))\n-    return output_fp_move_double (operands);\n-  return output_move_double (operands);\n-}\n-\")\n-\n-(define_insn \"movdi\"\n-  [(set (match_operand:DI 0 \"general_operand\" \"=r,&r,m,?f,?rm\")\n-\t(match_operand:DI 1 \"general_operand\" \"r,m,r,rfm,f\"))]\n-  \"\"\n-  \"*\n-{\n-  if (FP_REG_P (operands[0]) || FP_REG_P (operands[1]))\n-    return output_fp_move_double (operands);\n-  return output_move_double (operands);\n-}\n-\")\n-\n-(define_insn \"movsf\"\n-  [(set (match_operand:SF 0 \"general_operand\" \"=rf,m\")\n-\t(match_operand:SF 1 \"general_operand\" \"rfm,rf\"))]\n-  \"\"\n-  \"*\n-{\n-  if (FP_REG_P (operands[0]))\n-    {\n-      if (FP_REG_P (operands[1]))\n-\treturn \\\"fmov %0,%1\\\";\n-      if (GET_CODE (operands[1]) == REG)\n-\t{\n-\t  rtx xoperands[2];\n-\t  int offset = - get_frame_size () - 8;\n-\t  xoperands[1] = operands[1];\n-\t  xoperands[0] = GEN_INT (offset);\n-\t  output_asm_insn (\\\"st_32 %1,r25,%0\\\", xoperands);\n-\t  xoperands[1] = operands[0];\n-\t  output_asm_insn (\\\"ld_sgl %1,r25,%0\\;nop\\\", xoperands);\n-\t  return \\\"\\\";\n-\t}\n-      return \\\"ld_sgl %0,%1\\;nop\\\";\n-    }\n-  if (FP_REG_P (operands[1]))\n-    {\n-      if (GET_CODE (operands[0]) == REG)\n-\t{\n-\t  rtx xoperands[2];\n-\t  int offset = - get_frame_size () - 8;\n-\t  xoperands[0] = GEN_INT (offset);\n-\t  xoperands[1] = operands[1];\n-\t  output_asm_insn (\\\"st_sgl %1,r25,%0\\\", xoperands);\n-\t  xoperands[1] = operands[0];\n-\t  output_asm_insn (\\\"ld_32 %1,r25,%0\\;nop\\\", xoperands);\n-\t  return \\\"\\\";\n-\t}\n-      return \\\"st_sgl %1,%0\\\";\n-    }\n-  if (GET_CODE (operands[0]) == MEM)\n-    return \\\"st_32 %r1,%0\\\";\n-  if (GET_CODE (operands[1]) == MEM)\n-    return \\\"ld_32 %0,%1\\;nop\\\";\n-  if (GET_CODE (operands[1]) == REG)\n-    return \\\"add_nt %0,%1,$0\\\";\n-  return \\\"add_nt %0,r0,%1\\\";\n-}\")\n-\f\n-;;- truncation instructions\n-(define_insn \"truncsiqi2\"\n-  [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n-\t(truncate:QI\n-\t (match_operand:SI 1 \"register_operand\" \"r\")))]\n-  \"\"\n-  \"add_nt %0,%1,$0\")\n-\n-(define_insn \"trunchiqi2\"\n-  [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n-\t(truncate:QI\n-\t (match_operand:HI 1 \"register_operand\" \"r\")))]\n-  \"\"\n-  \"add_nt %0,%1,$0\")\n-\n-(define_insn \"truncsihi2\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n-\t(truncate:HI\n-\t (match_operand:SI 1 \"register_operand\" \"r\")))]\n-  \"\"\n-  \"add_nt %0,%1,$0\")\n-\f\n-;;- zero extension instructions\n-\n-;; Note that the one starting from HImode comes before those for QImode\n-;; so that a constant operand will match HImode, not QImode.\n-(define_expand \"zero_extendhisi2\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(and:SI (match_operand:HI 1 \"register_operand\" \"\") ;Changed to SI below\n-\t\t;; This constant is invalid, but reloading will handle it.\n-\t\t;; It's useless to generate here the insns to construct it\n-\t\t;; because constant propagation would simplify them anyway.\n-\t\t(match_dup 2)))]\n-  \"\"\n-  \"\n-{\n-  if (GET_CODE (operands[1]) == SUBREG)\n-    operands[1] = gen_rtx_SUBREG (SImode, SUBREG_REG (operands[1]),\n-\t\t\t\t  SUBREG_WORD (operands[1]));\n-  else\n-    operands[1] = gen_rtx_SUBREG (SImode, operands[1], 0);\n-\n-  operands[2] = force_reg (SImode, GEN_INT (65535));\n-}\")\n-\n-(define_insn \"zero_extendqihi2\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n-\t(zero_extend:HI\n-\t (match_operand:QI 1 \"register_operand\" \"r\")))]\n-  \"\"\n-  \"extract %0,%1,$0\")\n-\n-(define_insn \"zero_extendqisi2\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(zero_extend:SI\n-\t (match_operand:QI 1 \"register_operand\" \"r\")))]\n-  \"\"\n-  \"extract %0,%1,$0\")\n-\f\n-;;- sign extension instructions\n-;; Note that the one starting from HImode comes before those for QImode\n-;; so that a constant operand will match HImode, not QImode.\n-\n-(define_expand \"extendhisi2\"\n-  [(set (match_dup 2)\n-\t(and:SI (match_operand:HI 1 \"register_operand\" \"\") ;Changed to SI below\n-\t\t(match_dup 4)))\n-   (set (match_dup 3) (plus:SI (match_dup 2) (match_dup 5)))\n-   (set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(xor:SI (match_dup 3) (match_dup 5)))]\n-  \"\"\n-  \"\n-{\n-  if (GET_CODE (operands[1]) == SUBREG)\n-    operands[1] = gen_rtx_SUBREG (SImode, SUBREG_REG (operands[1]),\n-\t\t\t\t  SUBREG_WORD (operands[1]));\n-  else\n-    operands[1] = gen_rtx_SUBREG (SImode, operands[1], 0);\n-\n-  operands[2] = gen_reg_rtx (SImode);\n-  operands[3] = gen_reg_rtx (SImode);\n-  operands[4] = force_reg (SImode, GEN_INT (65535));\n-  operands[5] = force_reg (SImode, GEN_INT (-32768));\n-}\")\n-\n-(define_expand \"extendqihi2\"\n-  [(set (match_dup 2)\n-\t(and:HI (match_operand:QI 1 \"register_operand\" \"\") ;Changed to SI below\n-\t\t(const_int 255)))\n-   (set (match_dup 3)\n-\t(plus:SI (match_dup 2) (const_int -128)))\n-   (set (match_operand:HI 0 \"register_operand\" \"\")\n-\t(xor:SI (match_dup 3) (const_int -128)))]\n-  \"\"\n-  \"\n-{\n-  if (GET_CODE (operands[1]) == SUBREG)\n-    operands[1] = gen_rtx_SUBREG (HImode, SUBREG_REG (operands[1]),\n-\t\t\t\t  SUBREG_WORD (operands[1]));\n-  else\n-    operands[1] = gen_rtx_SUBREG (HImode, operands[1], 0);\n-\n-  operands[2] = gen_reg_rtx (HImode);\n-  operands[3] = gen_reg_rtx (HImode);\n-}\")\n-\n-(define_expand \"extendqisi2\"\n-  [(set (match_dup 2)\n-\t(and:SI (match_operand:QI 1 \"register_operand\" \"\") ;Changed to SI below\n-\t\t(const_int 255)))\n-   (set (match_dup 3) (plus:SI (match_dup 2) (const_int -128)))\n-   (set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(xor:SI (match_dup 3) (const_int -128)))]\n-  \"\"\n-  \"\n-{\n-  if (GET_CODE (operands[1]) == SUBREG)\n-    operands[1] = gen_rtx_SUBREG (SImode, SUBREG_REG (operands[1]),\n-\t\t\t\t  SUBREG_WORD (operands[1]));\n-  else\n-    operands[1] = gen_rtx_SUBREG (SImode, operands[1], 0);\n-\n-  operands[2] = gen_reg_rtx (SImode);\n-  operands[3] = gen_reg_rtx (SImode);\n-}\")\n-\f\n-;;- arithmetic instructions\n-\n-(define_insn \"addsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(plus:SI (match_operand:SI 1 \"nonmemory_operand\" \"%r\")\n-\t\t (match_operand:SI 2 \"nonmemory_operand\" \"rI\")))]\n-  \"\"\n-  \"add %0,%1,%2\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(plus:SI (match_operand:SI 1 \"nonmemory_operand\" \"%r\")\n-\t\t (match_operand:SI 2 \"big_immediate_operand\" \"g\")))]\n-  \"GET_CODE (operands[2]) == CONST_INT \n-   && (unsigned) (INTVAL (operands[2]) + 0x8000000) < 0x10000000\"\n-  \"*\n-{\n-  return \n-    output_add_large_offset (operands[0], operands[1], INTVAL (operands[2]));\n-}\")\n-\n-(define_insn \"subsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(minus:SI (match_operand:SI 1 \"register_operand\" \"r\")\n-\t\t  (match_operand:SI 2 \"nonmemory_operand\" \"rI\")))]\n-  \"\"\n-  \"sub %0,%1,%2\")\n-\n-(define_insn \"andsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(and:SI (match_operand:SI 1 \"nonmemory_operand\" \"%r\")\n-\t\t(match_operand:SI 2 \"nonmemory_operand\" \"rI\")))]\n-  \"\"\n-  \"and %0,%1,%2\")\n-\n-(define_insn \"iorsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(ior:SI (match_operand:SI 1 \"nonmemory_operand\" \"%r\")\n-\t\t(match_operand:SI 2 \"nonmemory_operand\" \"rI\")))]\n-  \"\"\n-  \"or %0,%1,%2\")\n-\n-(define_insn \"xorsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(xor:SI (match_operand:SI 1 \"nonmemory_operand\" \"%r\")\n-\t\t(match_operand:SI 2 \"nonmemory_operand\" \"rI\")))]\n-  \"\"\n-  \"xor %0,%1,%2\")\n-\n-(define_insn \"negsi2\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(neg:SI (match_operand:SI 1 \"nonmemory_operand\" \"rI\")))]\n-  \"\"\n-  \"sub %0,r0,%1\")\n-\n-(define_insn \"one_cmplsi2\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(not:SI (match_operand:SI 1 \"register_operand\" \"r\")))]\n-  \"\"\n-  \"xor %0,%1,$-1\")\n-\f\n-;; Floating point arithmetic instructions.\n-\n-(define_insn \"adddf3\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n-\t(plus:DF (match_operand:DF 1 \"register_operand\" \"f\")\n-\t\t (match_operand:DF 2 \"register_operand\" \"f\")))]\n-  \"TARGET_FPU\"\n-  \"fadd %0,%1,%2\")\n-\n-(define_insn \"addsf3\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n-\t(plus:SF (match_operand:SF 1 \"register_operand\" \"f\")\n-\t\t (match_operand:SF 2 \"register_operand\" \"f\")))]\n-  \"TARGET_FPU\"\n-  \"fadd %0,%1,%2\")\n-\n-(define_insn \"subdf3\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n-\t(minus:DF (match_operand:DF 1 \"register_operand\" \"f\")\n-\t\t  (match_operand:DF 2 \"register_operand\" \"f\")))]\n-  \"TARGET_FPU\"\n-  \"fsub %0,%1,%2\")\n-\n-(define_insn \"subsf3\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n-\t(minus:SF (match_operand:SF 1 \"register_operand\" \"f\")\n-\t\t  (match_operand:SF 2 \"register_operand\" \"f\")))]\n-  \"TARGET_FPU\"\n-  \"fsub %0,%1,%2\")\n-\n-(define_insn \"muldf3\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n-\t(mult:DF (match_operand:DF 1 \"register_operand\" \"f\")\n-\t\t (match_operand:DF 2 \"register_operand\" \"f\")))]\n-  \"TARGET_FPU\"\n-  \"fmul %0,%1,%2\")\n-\n-(define_insn \"mulsf3\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n-\t(mult:SF (match_operand:SF 1 \"register_operand\" \"f\")\n-\t\t (match_operand:SF 2 \"register_operand\" \"f\")))]\n-  \"TARGET_FPU\"\n-  \"fmul %0,%1,%2\")\n-\n-(define_insn \"divdf3\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n-\t(div:DF (match_operand:DF 1 \"register_operand\" \"f\")\n-\t\t(match_operand:DF 2 \"register_operand\" \"f\")))]\n-  \"TARGET_FPU\"\n-  \"fdiv %0,%1,%2\")\n-\n-(define_insn \"divsf3\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n-\t(div:SF (match_operand:SF 1 \"register_operand\" \"f\")\n-\t\t(match_operand:SF 2 \"register_operand\" \"f\")))]\n-  \"TARGET_FPU\"\n-  \"fdiv %0,%1,%2\")\n-\n-(define_insn \"negdf2\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n-\t(neg:DF (match_operand:DF 1 \"nonmemory_operand\" \"f\")))]\n-  \"TARGET_FPU\"\n-  \"fneg %0,%1\")\n-\n-(define_insn \"negsf2\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n-\t(neg:SF (match_operand:SF 1 \"nonmemory_operand\" \"f\")))]\n-  \"TARGET_FPU\"\n-  \"fneg %0,%1\")\n-\n-(define_insn \"absdf2\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n-\t(abs:DF (match_operand:DF 1 \"nonmemory_operand\" \"f\")))]\n-  \"TARGET_FPU\"\n-  \"fabs %0,%1\")\n-\n-(define_insn \"abssf2\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n-\t(abs:SF (match_operand:SF 1 \"nonmemory_operand\" \"f\")))]\n-  \"TARGET_FPU\"\n-  \"fabs %0,%1\")\n-\f\n-;; Shift instructions\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(ashift:SI (match_operand:SI 1 \"register_operand\" \"r\")\n-\t\t   (match_operand:SI 2 \"immediate_operand\" \"I\")))]\n-  \"GET_CODE (operands[2]) == CONST_INT\"\n-  \"*\n-{\n-  unsigned int amount = INTVAL (operands[2]);\n-\n-  switch (amount)\n-    {\n-    case 0:\n-      return \\\"add_nt %0,%1,$0\\\";\n-    case 1:\n-      return \\\"sll %0,%1,$1\\\";\n-    case 2:\n-      return \\\"sll %0,%1,$2\\\";\n-    default:\n-      output_asm_insn (\\\"sll %0,%1,$3\\\", operands);\n-\n-      for (amount -= 3; amount >= 3; amount -= 3)\n-\toutput_asm_insn (\\\"sll %0,%0,$3\\\", operands);\n-\n-      if (amount > 0)\n-\toutput_asm_insn (amount == 1 ? \\\"sll %0,%0,$1\\\" : \\\"sll %0,%0,$2\\\",\n-\t\t\t operands);\n-      return \\\"\\\";\n-    }\n-}\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(ashiftrt:SI (match_operand:SI 1 \"register_operand\" \"r\")\n-\t             (match_operand:SI 2 \"immediate_operand\" \"I\")))]\n-  \"GET_CODE (operands[2]) == CONST_INT\"\n-  \"*\n-{\n-  unsigned int amount = INTVAL (operands[2]);\n-\n-  if (amount == 0) \n-    return \\\"add_nt %0,%1,$0\\\";\n-  else\n-    output_asm_insn (\\\"sra %0,%1,$1\\\", operands);\n-  \n-  for (amount -= 1; amount > 0; amount -= 1)\n-    output_asm_insn (\\\"sra %0,%0,$1\\\", operands);\n-\n-  return \\\"\\\";\n-}\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(lshiftrt:SI (match_operand:SI 1 \"register_operand\" \"r\")\n-\t             (match_operand:SI 2 \"immediate_operand\" \"I\")))]\n-  \"GET_CODE (operands[2]) == CONST_INT\"\n-  \"*\n-{\n-  unsigned int amount = INTVAL (operands[2]);\n-\n-  if (amount == 0) \n-    return \\\"add_nt %0,%1,$0\\\";\n-  else\n-    output_asm_insn (\\\"srl %0,%1,$1\\\", operands);\n-  \n-  for (amount -= 1; amount > 0; amount -= 1)\n-    output_asm_insn (\\\"srl %0,%0,$1\\\", operands);\n-\n-  return \\\"\\\";\n-}\")\n-\n-(define_expand \"ashlsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(ashift:SI (match_operand:SI 1 \"register_operand\" \"\")\n-\t\t   (match_operand:SI 2 \"nonmemory_operand\" \"\")))]\n-  \"\"\n-  \"\n-{\n-  if (GET_CODE (operands[2]) != CONST_INT\n-      || (! TARGET_EXPAND_SHIFTS && (unsigned) INTVAL (operands[2]) > 3))\n-    FAIL;\n-}\")\n-\n-(define_expand \"ashrsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(ashiftrt:SI (match_operand:SI 1 \"register_operand\" \"\")\n-\t\t     (match_operand:SI 2 \"nonmemory_operand\" \"\")))]\n-  \"\"\n-  \"\n-{\n-  if (GET_CODE (operands[2]) != CONST_INT\n-      || (! TARGET_EXPAND_SHIFTS && (unsigned) INTVAL (operands[2]) > 1))\n-    FAIL;\n-}\")\n-\n-(define_expand \"lshrsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(lshiftrt:SI (match_operand:SI 1 \"register_operand\" \"\")\n-\t\t     (match_operand:SI 2 \"nonmemory_operand\" \"\")))]\n-  \"\"\n-  \"\n-{\n-  if (GET_CODE (operands[2]) != CONST_INT\n-      || (! TARGET_EXPAND_SHIFTS && (unsigned) INTVAL (operands[2]) > 1))\n-    FAIL;\n-}\")\n-\f\n-;; Unconditional and other jump instructions\n-(define_insn \"jump\"\n-  [(set (pc)\n-\t(label_ref (match_operand 0 \"\" \"\")))]\n-  \"\"\n-  \"jump %l0\\;nop\")\n-\n-(define_insn \"tablejump\"\n-  [(set (pc) (match_operand:SI 0 \"register_operand\" \"r\"))\n-   (use (label_ref (match_operand 1 \"\" \"\")))]\n-  \"\"\n-  \"jump_reg r0,%0\\;nop\")\n-\n-;;- jump to subroutine\n-(define_insn \"call\"\n-  [(call (match_operand:SI 0 \"memory_operand\" \"m\")\n-\t (match_operand:SI 1 \"general_operand\" \"g\"))]\n-  ;;- Don't use operand 1 for most machines.\n-  \"\"\n-  \"add_nt r2,%0\\;call .+8\\;jump_reg r0,r2\\;nop\")\n-\n-(define_insn \"call_value\"\n-  [(set (match_operand 0 \"\" \"=g\")\n-\t(call (match_operand:SI 1 \"memory_operand\" \"m\")\n-\t      (match_operand:SI 2 \"general_operand\" \"g\")))]\n-  ;;- Don't use operand 1 for most machines.\n-  \"\"\n-  \"add_nt r2,%1\\;call .+8\\;jump_reg r0,r2\\;nop\")\n-\n-;; A memory ref with constant address is not normally valid.\n-;; But it is valid in a call insns.  This pattern allows the\n-;; loading of the address to combine with the call.\n-(define_insn \"\"\n-  [(call (mem:SI (match_operand:SI 0 \"\" \"i\"))\n-\t (match_operand:SI 1 \"general_operand\" \"g\"))]\n-  ;;- Don't use operand 1 for most machines.\n-  \"GET_CODE (operands[0]) == SYMBOL_REF\"\n-  \"call %0\\;nop\")\n-\n-(define_insn \"\"\n-  [(set (match_operand 0 \"\" \"=g\")\n-\t(call (mem:SI (match_operand:SI 1 \"\" \"i\"))\n-\t      (match_operand:SI 2 \"general_operand\" \"g\")))]\n-  ;;- Don't use operand 1 for most machines.\n-  \"GET_CODE (operands[1]) == SYMBOL_REF\"\n-  \"call %1\\;nop\")\n-\n-(define_insn \"nop\"\n-  [(const_int 0)]\n-  \"\"\n-  \"nop\")"}, {"sha": "1d30053bc53902e32d7191c94b068c683dcee1fa", "filename": "gcc/config/spur/xm-spur.h", "status": "removed", "additions": 0, "deletions": 39, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7b4171a5b8a655097812307bbe261032dfbe366/gcc%2Fconfig%2Fspur%2Fxm-spur.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7b4171a5b8a655097812307bbe261032dfbe366/gcc%2Fconfig%2Fspur%2Fxm-spur.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspur%2Fxm-spur.h?ref=a7b4171a5b8a655097812307bbe261032dfbe366", "patch": "@@ -1,39 +0,0 @@\n-/* Configuration for GNU C-compiler for Berkeley SPUR processor.\n-   Copyright (C) 1988, 1993 Free Software Foundation, Inc.\n-\n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-\n-/* #defines that need visibility everywhere.  */\n-#define FALSE 0\n-#define TRUE 1\n-\n-/* This describes the machine the compiler is hosted on.  */\n-#define HOST_BITS_PER_CHAR 8\n-#define HOST_BITS_PER_SHORT 16\n-#define HOST_BITS_PER_INT 32\n-#define HOST_BITS_PER_LONG 32\n-#define HOST_BITS_PER_LONGLONG 64\n-\n-/* target machine dependencies.\n-   tm.h is a symbolic link to the actual target specific file.   */\n-#include \"tm.h\"\n-\n-/* Arguments to use with `exit'.  */\n-#define SUCCESS_EXIT_CODE 0\n-#define FATAL_EXIT_CODE 33"}, {"sha": "80d05e6e67f88fd72e7ea029e044c462310816c3", "filename": "gcc/config/tahoe/harris.h", "status": "removed", "additions": 0, "deletions": 87, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7b4171a5b8a655097812307bbe261032dfbe366/gcc%2Fconfig%2Ftahoe%2Fharris.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7b4171a5b8a655097812307bbe261032dfbe366/gcc%2Fconfig%2Ftahoe%2Fharris.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftahoe%2Fharris.h?ref=a7b4171a5b8a655097812307bbe261032dfbe366", "patch": "@@ -1,87 +0,0 @@\n-/* Definitions of target machine for GNU compiler.  Harris tahoe version.\n-   Copyright (C) 1989, 1993 Free Software Foundation, Inc.\n-\n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-\n-#include \"tahoe/tahoe.h\"\n-\n-#undef CPP_PREDEFINES\n-#define CPP_PREDEFINES \"-Dtahoe -Dunix -Dhcx -Asystem(unix) -Acpu(tahoe) -Amachine(tahoe)\"\n-\n-#undef DBX_DEBUGGING_INFO\n-#define SDB_DEBUGGING_INFO\n-\n-#undef LIB_SPEC\n-\n-#undef TARGET_DEFAULT\n-#define TARGET_DEFAULT 1\n-\n-/* urem and udiv don't exist on this system.  */\n-#undef UDIVSI3_LIBCALL\n-#undef UMODSI3_LIBCALL\n-\n-/* Operand of .align is not logarithmic.  */\n-#undef ASM_OUTPUT_ALIGN\n-#define ASM_OUTPUT_ALIGN(FILE,LOG)  \\\n-  LOG ? fprintf (FILE, \"\\t.align %d\\n\", 1 << (LOG)) : 0\n-\n-/* For the same reason, we need .align 2 after casesi.  */\n-#undef PRINT_OPERAND\n-#define PRINT_OPERAND(FILE, X, CODE)  \\\n-{ if (CODE == '@')\t\t\t\t\t\t\t\\\n-    putc ('2', FILE);\t\t\t\t\t\t\t\\\n-  else if (GET_CODE (X) == REG)\t\t\t\t\t\t\\\n-    fprintf (FILE, \"%s\", reg_names[REGNO (X)]);\t\t\t\t\\\n-  else if (GET_CODE (X) == MEM)\t\t\t\t\t\t\\\n-    output_address (XEXP (X, 0));\t\t\t\t\t\\\n-  else { putc ('$', FILE); output_addr_const (FILE, X); }}\n-\n-#undef ASM_OUTPUT_LOCAL\n-#define ASM_OUTPUT_LOCAL(FILE, NAME, SIZE, ROUNDED)  \\\n-( fputs (\".bss \", (FILE)),\t\t\t\\\n-  assemble_name ((FILE), (NAME)),\t\t\\\n-  fprintf ((FILE), \",%u,4\\n\", (ROUNDED)))\n-\n-/* Output at beginning of assembler file.  */\n-/* The .file command should always begin the output.  */\n-\n-#undef ASM_FILE_START\n-#define ASM_FILE_START(FILE)\t\t\t\\\n-  output_file_directive ((FILE), main_input_filename);\n-\n-#define ASM_OUTPUT_ASCII(FILE, PTR, SIZE)\t\t\\\n-do {\t\t\t\t\t\t\t\\\n-  const unsigned char *_p = (PTR);\t\t\t\\\n-  int _thissize = (SIZE);\t\t\t\t\\\n-  fprintf ((FILE), \"\\t.ascii \\\"\");\t\t\t\\\n-  for (i = 0; i < _thissize; i++)\t\t\t\\\n-    {\t\t\t\t\t\t\t\\\n-      register int c = _p[i];\t\t\t\t\\\n-      if (c >= ' ' && c < 0177 && c != '\\\"' && c != '\\\\') \\\n-\tputc (c, (FILE));\t\t\t\t\\\n-      else\t\t\t\t\t\t\\\n-\t{\t\t\t\t\t\t\\\n-\t  fprintf ((FILE), \"\\\\%o\", c);\t\t\t\\\n-\t  if (i < _thissize - 1\t\t\t\t\\\n-\t      && _p[i + 1] >= '0' && _p[i + 1] <= '9')\t\\\n-\t    fprintf ((FILE), \"\\\"\\n\\t.ascii \\\"\");\t\\\n-\t}\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\\\n-  fprintf ((FILE), \"\\\"\\n\");\t\t\t\t\\\n-} while (0)"}, {"sha": "cbd68716011c3ac5b581b6d76641599d9a14c0b9", "filename": "gcc/config/tahoe/tahoe.c", "status": "removed", "additions": 0, "deletions": 565, "changes": 565, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7b4171a5b8a655097812307bbe261032dfbe366/gcc%2Fconfig%2Ftahoe%2Ftahoe.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7b4171a5b8a655097812307bbe261032dfbe366/gcc%2Fconfig%2Ftahoe%2Ftahoe.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftahoe%2Ftahoe.c?ref=a7b4171a5b8a655097812307bbe261032dfbe366", "patch": "@@ -1,565 +0,0 @@\n-/* Subroutines for insn-output.c for Tahoe.\n-   Copyright (C) 1989, 1991, 1997, 1998, 1999 Free Software Foundation, Inc.\n-   Contributed by the University of Buffalo (Devon Bowen, Dale Wiles\n-   and Kevin Zachmann.\n-   Changes for HCX by Piet van Oostrum, University of Utrecht,\n-   The Netherlands (piet@cs.ruu.nl)\n-   Speed tweaks by Michael Tiemann (tiemann@lurch.stanford.edu).\n-\n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"rtl.h\"\n-#include \"regs.h\"\n-#include \"hard-reg-set.h\"\n-#include \"real.h\"\n-#include \"insn-config.h\"\n-#include \"conditions.h\"\n-#include \"insn-flags.h\"\n-#include \"function.h\"\n-#include \"output.h\"\n-#include \"insn-attr.h\"\n-#include \"ggc.h\"\n-\n-/* On tahoe, you have to go to memory to convert a register\n-   from sub-word to word.  */\n-\n-rtx tahoe_reg_conversion_loc;\n-\n-int\n-extensible_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n-{\n-  if ((GET_CODE (op) == REG\n-       || (GET_CODE (op) == SUBREG\n-\t   && GET_CODE (SUBREG_REG (op)) == REG))\n-      && tahoe_reg_conversion_loc == 0)\n-    {\n-      tahoe_reg_conversion_loc\n-\t= assign_stack_local (SImode, GET_MODE_SIZE (SImode));\n-      ggc_add_rtx_root (&tahoe_reg_conversion_loc, 1);\n-    }\n-\n-  return general_operand (op, mode);\n-}\n-\n-/* Most of the print_operand_address function was taken from the VAX since\n-   the modes are basically the same. I had to add a special case, though, for\n-   symbol references with offsets.  */\n-\n-print_operand_address (file, addr)\n-     FILE *file;\n-     register rtx addr;\n-{\n-  register rtx reg1, reg2, breg, ireg;\n-  rtx offset;\n-  static char *reg_name[] = REGISTER_NAMES;\n-\n- retry:\n-  switch (GET_CODE (addr))\n-    {\n-    case MEM:\n-      fprintf (file, \"*\");\n-      addr = XEXP (addr, 0);\n-      goto retry;\n-\n-    case REG:\n-      fprintf (file, \"(%s)\", reg_name [REGNO (addr)]);\n-      break;\n-\n-    case PRE_DEC:\n-      fprintf (file, \"-(%s)\", reg_name [REGNO (XEXP (addr, 0))]);\n-      break;\n-\n-    case POST_INC:\n-      fprintf (file, \"(%s)+\", reg_name [REGNO (XEXP (addr, 0))]);\n-      break;\n-\n-    case PLUS:\n-      reg1 = 0,\treg2 = 0;\n-      ireg = 0,\tbreg = 0;\n-      offset = 0;\n-\n-      if (CONSTANT_ADDRESS_P (XEXP (addr, 0))\n-\t  && GET_CODE (XEXP (addr, 1)) == CONST_INT)\n-\toutput_addr_const (file, addr);\n-\n-      if (CONSTANT_ADDRESS_P (XEXP (addr, 1))\n-\t  && GET_CODE (XEXP (addr, 0)) == CONST_INT)\n-\toutput_addr_const (file, addr);\n-\n-      if (CONSTANT_ADDRESS_P (XEXP (addr, 0))\n-\t  || GET_CODE (XEXP (addr, 0)) == MEM)\n-\toffset = XEXP (addr, 0), addr = XEXP (addr, 1);\n-      else if (CONSTANT_ADDRESS_P (XEXP (addr, 1))\n-\t       || GET_CODE (XEXP (addr, 1)) == MEM)\n-\toffset = XEXP (addr, 1), addr = XEXP (addr, 0);\n-\n-      if (GET_CODE (addr) != PLUS)\n-\t;\n-      else if (GET_CODE (XEXP (addr, 0)) == MULT)\n-\treg1 = XEXP (addr, 0), addr = XEXP (addr, 1);\n-      else if (GET_CODE (XEXP (addr, 1)) == MULT)\n-\treg1 = XEXP (addr, 1), addr = XEXP (addr, 0);\n-      else if (GET_CODE (XEXP (addr, 0)) == REG)\n-\treg1 = XEXP (addr, 0), addr = XEXP (addr, 1);\n-      else if (GET_CODE (XEXP (addr, 1)) == REG)\n-\treg1 = XEXP (addr, 1), addr = XEXP (addr, 0);\n-\n-      if (GET_CODE (addr) == REG || GET_CODE (addr) == MULT)\n-\t{\n-\t  if (reg1 == 0)\n-\t    reg1 = addr;\n-\t  else\n-\t    reg2 = addr;\n-\t  addr = 0;\n-\t}\n-\n-      if (offset != 0)\n-\t{\n-\t  if (addr != 0)\n-\t    abort ();\n-\n-\t  addr = offset;\n-\t}\n-\n-      if (reg1 != 0 && GET_CODE (reg1) == MULT)\n-\tbreg = reg2, ireg = reg1;\n-      else if (reg2 != 0 && GET_CODE (reg2) == MULT)\n-\tbreg = reg1, ireg = reg2;\n-      else if (reg2 != 0 || GET_CODE (addr) == MEM)\n-\tbreg = reg2, ireg = reg1;\n-      else\n-\tbreg = reg1, ireg = reg2;\n-\n-      if (addr != 0)\n-\toutput_address (offset);\n-\n-      if (breg != 0)\n-\t{\n-\t  if (GET_CODE (breg) != REG)\n-\t    abort ();\n-\t  fprintf (file, \"(%s)\", reg_name[REGNO (breg)]);\n-\t}\n-\n-      if (ireg != 0)\n-\t{\n-\t  if (GET_CODE (ireg) == MULT)\n-\t    ireg = XEXP (ireg, 0);\n-\t  if (GET_CODE (ireg) != REG)\n-\t    abort ();\n-\t  fprintf (file, \"[%s]\", reg_name[REGNO (ireg)]);\n-\t}\n-      break;\n-\n-    default:\n-      output_addr_const (file, addr);\n-    }\n-}\n-\n-/* Do a quick check and find out what the best way to do the mini-move is.\n-   Could be a push or a move.....  */\n-\n-static char *\n-singlemove_string (operands)\n-     rtx *operands;\n-{\n-  if (operands[1] == const0_rtx)\n-      return \"clrl %0\";\n-\n-  if (push_operand (operands[0], SImode))\n-    return \"pushl %1\";\n-\n-  return \"movl %1,%0\";\n-}\n-\n-/* Given the rtx for an address, return true if the given register number is\n-   used in the address somewhere.  */\n-\n-int\n-regisused (addr, regnum)\n-     rtx addr;\n-     int regnum;\n-{\n-  if (GET_CODE (addr) == REG)\n-    return REGNO (addr) == regnum;\n-\n-  else if (GET_CODE (addr) == MEM)\n-    return regisused (XEXP (addr, 0), regnum);\n-\n-  else if (GET_CODE (addr) == MULT || GET_CODE (addr) == PLUS)\n-    return (regisused (XEXP (addr, 0), regnum)\n-\t    || regisused (XEXP (addr, 1), regnum));\n-\n-  return 0;\n-}\n-\n-\n-/* Given some rtx, traverse it and return the register used in a index. If no\n-   index is found, return 0.  */\n-\n-rtx\n-index_reg (addr)\n-     rtx addr;\n-{\n-  rtx temp;\n-\n-  if (GET_CODE (addr) == MEM)\n-    return index_reg (XEXP (addr, 0));\n-\n-  else if (GET_CODE (addr) == MULT)\n-    {\n-      if (GET_CODE (XEXP (addr, 0)) == REG)\n-\treturn XEXP (addr, 0);\n-      else\n-\treturn XEXP (addr, 1);\n-    }\n-\n-  else if (GET_CODE (addr) == PLUS)\n-    {\n-      if ((temp = index_reg (XEXP (addr, 0))) != 0)\n-\treturn temp;\n-      else\n-\treturn index_reg (XEXP (addr, 1));\n-    }\n-\n-  return 0;\n-}\n-\n-\n-/* Simulate the move double by generating two movl's. We need to be careful\n-   about mixing modes here.  */\n-\n-char *\n-output_move_double (operands)\n-     rtx *operands;\n-{\n-  enum { REGOP, OFFSOP, MEMOP, PUSHOP, POPOP, INDOP, CNSTOP, RNDOP }\n-    optype0, optype1;\n-  rtx latehalf[2];\n-  rtx shftreg0 = 0, shftreg1 = 0;\n-  rtx temp0 = 0, temp1 = 0;\n-  rtx addreg0 = 0, addreg1 = 0;\n-  int dohighfirst = 0;\n-\n-  /* First classify both operands. */\n-\n-  if (REG_P (operands[0]))\n-    optype0 = REGOP;\n-  else if (GET_CODE (operands[0]) == MEM\n-\t   && (shftreg0 = index_reg (operands[0])) != 0)\n-    optype0 = INDOP;\n-  else if (offsettable_memref_p (operands[0]))\n-    optype0 = OFFSOP;\n-  else if (GET_CODE (XEXP (operands[0], 0)) == PRE_DEC)\n-    {\n-      optype0 = PUSHOP;\n-      dohighfirst++;\n-    }\n-  else if (GET_CODE (operands[0]) == MEM)\n-    optype0 = MEMOP;\n-  else\n-    optype0 = RNDOP;\n-\n-  if (REG_P (operands[1]))\n-    optype1 = REGOP;\n-  else if (GET_CODE (operands[1]) == MEM\n-\t   && (shftreg1 = index_reg (operands[1])) !+ 0)\n-    optype1 = INDOP;\n-  else if (offsettable_memref_p (operands[1]))\n-    optype1 = OFFSOP;\n-  else if (GET_CODE (XEXP (operands[1], 0)) == POST_INC)\n-    optype1 = POPOP; \n-  else if (GET_CODE (operands[1]) == MEM)\n-    optype1 = MEMOP;\n-  else if (CONSTANT_P (operands[1]))\n-    optype1 = CNSTOP;\n-  else\n-    optype1 = RNDOP;\n-\n-  /* Set up for the high byte move for operand zero */\n-\n-  switch (optype0)\n-    {\n-      /* If it's a register, just use the next highest in the high address\n-\t move. */\n-    case REGOP:\n-      latehalf[0] = gen_rtx_REG (SImode, REGNO (operands[0]) + 1);\n-      break;\n-\n-      /* For an offsettable address, use the GCC function to modify the\n-\t operand to get an offset of 4 higher for the second move.  */\n-    case OFFSOP:\n-      latehalf[0] = adj_offsettable_operand (operands[0], 4);\n-      break;\n-\n-      /* If the operand is MEMOP type, it must be a pointer to a pointer.\n-\t So just remember to increase the mem location and use the same\n-\t operand.  */\n-    case MEMOP:\n-      latehalf[0] = operands[0];\n-      addreg0 = XEXP(operands[0],0);\n-      break;\n-\n-      /* If we're dealing with a push instruction, just leave the operand\n-\t alone since it auto-increments. */\n-    case PUSHOP:\n-      latehalf[0] = operands[0];\n-      break;\n-\n-      /* Indexed addressing. If the address is considered offsettable, use\n-\t the offset in the high part. Otherwise find what exactly is being\n-\t added to the multiplication. If it's a mem reference, increment that\n-\t with the high part being unchanged to cause the shift. If it's a\n-\t reg, do the same. If we can't identify it, abort. Remember that the\n-\t shift register was already set during identification.  */\n-\n-    case INDOP:\n-      if (offsettable_memref_p (operands[0]))\n-\t{\n-\t  latehalf[0] = adj_offsettable_operand (operands[0], 4);\n-\t  break;\n-\t}\n-\n-      latehalf[0] = operands[0];\n-\n-      temp0 = XEXP (XEXP (operands[0], 0), 0);\n-      if (GET_CODE(temp0) == MULT)\n-\t{\n-\t  temp1 = temp0;\n-\t  temp0 = XEXP (XEXP (operands[0], 0), 1);\n-\t}\n-      else\n-\t{\n-\t  temp1 = XEXP (XEXP (operands[0], 0), 1);\n-\t  if (GET_CODE (temp1) != MULT)\n-\t    abort();\n-\t}\n-\n-      if (GET_CODE (temp0) == MEM)\n-\taddreg0 = temp0;\n-      else if (GET_CODE (temp0) == REG)\n-\taddreg0 = temp0;\n-      else\n-\tabort();\n-\n-      break;\n-\n-    case RNDOP:\n-    default:\n-      abort();\n-  }\n-\n-  /* Do the same setup for operand one.  */\n-\n-  switch (optype1)\n-    {\n-    case REGOP:\n-      latehalf[1] = gen_rtx_REG (SImode, REGNO (operands[1]) + 1);\n-      break;\n-\n-    case OFFSOP:\n-      latehalf[1] = adj_offsettable_operand (operands[1], 4);\n-      break;\n-\n-    case MEMOP:\n-      latehalf[1] = operands[1];\n-      addreg1 = XEXP (operands[1], 0);\n-      break;\n-\n-    case POPOP:\n-      latehalf[1] = operands[1];\n-      break;\n-\n-    case INDOP:\n-      if (offsettable_memref_p (operands[1]))\n-\t{\n-\t  latehalf[1] = adj_offsettable_operand (operands[1], 4);\n-\t  break;\n-\t}\n-\n-      latehalf[1] = operands[1];\n-\n-      temp0 = XEXP (XEXP (operands[1], 0), 0);\n-      if (GET_CODE (temp0) == MULT)\n-\t{\n-\t  temp1 = temp0;\n-\t  temp0 = XEXP (XEXP (operands[1], 0), 1);\n-\t}\n-      else\n-\t{\n-\t  temp1 = XEXP (XEXP (operands[1], 0), 1);\n-\t  if (GET_CODE (temp1) != MULT)\n-\t    abort();\n-\t}\n-\n-      if (GET_CODE (temp0) == MEM)\n-\taddreg1 = temp0;\n-      else if (GET_CODE (temp0) == REG)\n-\taddreg1 = temp0;\n-      else\n-\tabort();\n-      break;\n-\n-    case CNSTOP:\n-      if (GET_CODE (operands[1]) == CONST_DOUBLE)\n-\tsplit_double (operands[1], &operands[1], &latehalf[1]);\n-      else if (CONSTANT_P (operands[1]))\n-\tlatehalf[1] = const0_rtx;\n-      else\n-\tabort ();\n-      break;\n-\n-    case RNDOP:\n-    default:\n-      abort ();\n-  }\n-\n-\n-  /* Double the register used for shifting in both of the operands but make\n-     sure the same register isn't doubled twice!  */\n-\n-  if (shftreg0 != 0 && shftreg1 != 0 && rtx_equal_p (shftreg0, shftreg1))\n-    output_asm_insn (\"addl2 %0,%0\", &shftreg0);\n-  else\n-    {\n-      if (shftreg0 != 0)\n-\toutput_asm_insn (\"addl2 %0,%0\", &shftreg0);\n-      if (shftreg1!= 0)\n-\toutput_asm_insn (\"addl2 %0,%0\", &shftreg1);\n-    }\n-\n-  /* If the destination is a register and that register is needed in the\n-     source addressing mode, swap the order of the moves since we don't want\n-     this destroyed til last. If both regs are used, not much we can do, so\n-     abort. If these becomes a problem, maybe we can do it on the stack?  */\n-\n-  if (GET_CODE (operands[0]) == REG\n-      && regisused (operands[1], REGNO (operands[0])))\n-    {\n-      if (regisused (latehalf[1], REGNO(latehalf[0])))\n-\t;\n-      else\n-\tdohighfirst++;\n-    }\n-\n-  /* If we're pushing, do the high address part first. */\n-\n-  if (dohighfirst)\n-    {\n-      if (addreg0 != 0 && addreg1 != 0 && rtx_equal_p (addreg0, addreg1))\n-\toutput_asm_insn (\"addl2 $4,%0\", &addreg0);\n-      else\n-\t{\n-\t  if (addreg0 != 0)\n-\t    output_asm_insn (\"addl2 $4,%0\", &addreg0);\n-\t  if (addreg1 != 0)\n-\t    output_asm_insn (\"addl2 $4,%0\", &addreg1);\n-\t}\n-\n-      output_asm_insn (singlemove_string (latehalf), latehalf);\n-\n-      if (addreg0 != 0 && addreg1 != 0 && rtx_equal_p (addreg0, addreg1))\n-\toutput_asm_insn (\"subl2 $4,%0\", &addreg0);\n-      else\n-\t{\n-\t  if (addreg0 != 0)\n-\t    output_asm_insn (\"subl2 $4,%0\", &addreg0);\n-\t  if (addreg1 != 0)\n-\t    output_asm_insn (\"subl2 $4,%0\", &addreg1);\n-\t}\n-\n-      return singlemove_string (operands);\n-    }\n-\n-  output_asm_insn (singlemove_string(operands), operands);\n-\n-  if (addreg0 != 0 && addreg1 != 0 && rtx_equal_p (addreg0, addreg1))\n-    output_asm_insn (\"addl2 $4,%0\", &addreg0);\n-  else\n-    {\n-      if (addreg0 != 0)\n-\toutput_asm_insn (\"addl2 $4,%0\", &addreg0);\n-      if (addreg1 != 0)\n-\toutput_asm_insn (\"addl2 $4,%0\", &addreg1);\n-    }\n-\n-  output_asm_insn (singlemove_string (latehalf), latehalf);\n-\n-  if (addreg0 != 0 && addreg1 != 0 && rtx_equal_p(addreg0, addreg1))\n-    output_asm_insn (\"subl2 $4,%0\", &addreg0);\n-  else\n-    {\n-      if (addreg0 != 0)\n-\toutput_asm_insn (\"subl2 $4,%0\", &addreg0);\n-      if (addreg1 != 0)\n-\toutput_asm_insn (\"subl2 $4,%0\", &addreg1);\n-    }\n-\n-  if (shftreg0 != 0 && shftreg1 != 0 && rtx_equal_p (shftreg0, shftreg1))\n-    output_asm_insn (\"shar $1,%0,%0\", &shftreg0);\n-  else\n-    {\n-      if (shftreg0 != 0)\n-\toutput_asm_insn (\"shar $1,%0,%0\", &shftreg0);\n-      if (shftreg1 != 0)\n-\toutput_asm_insn (\"shar $1,%0,%0\", &shftreg1);\n-  }\n-\n-  return \"\";\n-}\n-\n-\n-/* This checks if a zero_extended cmp[bw] can be replaced by a sign_extended\n-   cmp[bw]. This can be done if the operand is a constant that fits in a\n-   byte/word or a memory operand. Besides that the next instruction must be an\n-   unsigned compare. Some of these tests are done by the machine description */\n-\n-int\n-tahoe_cmp_check (insn, op, max)\n-     rtx insn, op;\n-     int max;\n-{\n-  register rtx next = NEXT_INSN (insn);\n-\n-    if (GET_CODE (op) == CONST_INT\n-\t&& (INTVAL (op) < 0 || INTVAL (op) > max))\n-      return 0;\n-\n-  if (INSN_P (next))\n-    {\n-      next = PATTERN (next);\n-      if (GET_CODE (next) == SET\n-\t  && SET_DEST (next) == pc_rtx\n-\t  && GET_CODE (SET_SRC (next)) == IF_THEN_ELSE)\n-\tswitch (GET_CODE (XEXP (SET_SRC (next), 0)))\n-\t  {\n-\t  case EQ:\n-\t  case NE:\n-\t  case LTU:\n-\t  case GTU:\n-\t  case LEU:\n-\t  case GEU:\n-\t    return 1;\n-\t  }\n-    }\n-  \n-  return 0;\n-}"}, {"sha": "240f39942973605294255ca1cdfa9cb7e3884732", "filename": "gcc/config/tahoe/tahoe.h", "status": "removed", "additions": 0, "deletions": 1017, "changes": 1017, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7b4171a5b8a655097812307bbe261032dfbe366/gcc%2Fconfig%2Ftahoe%2Ftahoe.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7b4171a5b8a655097812307bbe261032dfbe366/gcc%2Fconfig%2Ftahoe%2Ftahoe.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftahoe%2Ftahoe.h?ref=a7b4171a5b8a655097812307bbe261032dfbe366", "patch": "@@ -1,1017 +0,0 @@\n-/* Definitions of target machine for GNU compiler.  Tahoe version.\n-   Copyright (C) 1989, 93, 94, 95, 96, 1998, 1999, 2000 Free Software Foundation, Inc.\n-\n-This file is part of GNU CC.\n-\n-GNU CC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU CC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU CC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 59 Temple Place - Suite 330,\n-Boston, MA 02111-1307, USA.  */\n-\n-/*\n- * Original port made at the University of Buffalo by Devon Bowen,\n- * Dale Wiles and Kevin Zachmann.\n- *\n- * HCX/UX version by Piet van Oostrum (piet@cs.ruu.nl)\n- *\n- * Performance hacking by Michael Tiemann (tiemann@cygnus.com)\n- */\n-\n-/* define this for the HCX/UX version */\n-\n-/* #define HCX_UX */\n-\n-/*\n- * Run-time Target Specification\n- */\n-\n-#ifdef HCX_UX\n-/* no predefines, see Makefile and hcx-universe.c */\n-/* have cc1 print that this is the hcx version */\n-#define TARGET_VERSION printf (\" (hcx)\");\n-#else\n-/* we want \"tahoe\" and \"unix\" defined for all future compilations */\n-#define CPP_PREDEFINES \"-Dtahoe -Dunix -Asystem(unix) -Acpu(tahoe) -Amachine(tahoe)\"\n-/* have cc1 print that this is the tahoe version */\n-#define TARGET_VERSION printf (\" (tahoe)\");\n-#endif\n-\n-/* this is required in all tm files to hold flags */\n-\n-extern int target_flags;\n-\n-/* Zero if it is safe to output .dfloat and .float pseudos.  */\n-#define TARGET_HEX_FLOAT (target_flags & 1)\n-\n-#define TARGET_DEFAULT 1\n-\n-#define TARGET_SWITCHES\t\t\\\n-  { {\"hex-float\", 1},\t\t\\\n-    {\"no-hex-float\", -1},\t\\\n-    { \"\", TARGET_DEFAULT} }\n-\f\n-\n-/*\n- * Storage Layout\n- */\n-\n-/* This symbol was previously not mentioned, so apparently the tahoe\n-   is little-endian for bits, or else doesn't care.  */\n-#define BITS_BIG_ENDIAN 0\n-\n-/* tahoe uses a big endian byte order */\n-\n-#define BYTES_BIG_ENDIAN 1\n-\n-/* tahoe uses a big endian word order */\n-\n-#define WORDS_BIG_ENDIAN 1\n-\n-/* standard byte size is usable on tahoe */\n-\n-#define BITS_PER_UNIT 8\n-\n-/* longs on the tahoe are 4 byte groups */\n-\n-#define BITS_PER_WORD 32\n-\n-/* from the last two params we get 4 bytes per word */\n-\n-#define UNITS_PER_WORD 4\n-\n-/* addresses are 32 bits (one word) */\n-\n-#define POINTER_SIZE 32\n-\n-/* all parameters line up on 32 boundaries */\n-\n-#define PARM_BOUNDARY 32\n-\n-/* stack should line up on 32 boundaries */\n-\n-#define STACK_BOUNDARY 32\n-\n-/* line functions up on 32 bits */\n-\n-#define FUNCTION_BOUNDARY 32\n-\n-/* the biggest alignment the tahoe needs in 32 bits */\n-\n-#define BIGGEST_ALIGNMENT 32\n-\n-/* we have to align after an 'int : 0' in a structure */\n-\n-#define EMPTY_FIELD_BOUNDARY 32\n-\n-#ifdef HCX_UX\n-/* structures must be made of full words */\n-\n-#define STRUCTURE_SIZE_BOUNDARY 32\n-#else\n-/* structures must be made of full bytes */\n-\n-#define STRUCTURE_SIZE_BOUNDARY 8\n-#endif\n-\n-/* tahoe is picky about data alignment */\n-\n-#define STRICT_ALIGNMENT 1\n-\n-/* keep things standard with pcc */\n-\n-#define PCC_BITFIELD_TYPE_MATTERS 1\n-\n-/* this section is borrowed from the vax version since the */\n-/* formats are the same in both of the architectures\t   */\n-\n-#define CHECK_FLOAT_VALUE(MODE, D, OVERFLOW) \\\n-  if (OVERFLOW)\t\t\t\t\t\t\t\t\\\n-    (D) = 1.7014117331926443e+38;\t\t\t\t\t\\\n-  else if ((MODE) == SFmode)\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      if ((D) > 1.7014117331926443e+38)\t\t\t\t\t\\\n-\t(OVERFLOW) = 1, (D) = 1.7014117331926443e+38;\t\t\t\\\n-      else if ((D) < -1.7014117331926443e+38)\t\t\t\t\\\n-\t(OVERFLOW) = 1, (D) = -1.7014117331926443e+38;\t\t\t\\\n-      else if (((D) > 0) && ((D) < 2.9387358770557188e-39))\t\t\\\n-\t(OVERFLOW) = 1, (D) = 0.0;\t\t\t\t\t\\\n-      else if (((D) < 0) && ((D) > -2.9387358770557188e-39))\t\t\\\n-\t(OVERFLOW) = 1, (D) = 0.0;\t\t\t\t\t\\\n-    }\n-\n-\n-/*\n- * Register Usage\n- */\n-\n-/* define 15 general regs plus one for the floating point reg (FPP) */\n-\n-#define FIRST_PSEUDO_REGISTER 17\n-\n-/* let the compiler know what the fp, sp and pc are */\n-\n-#define FIXED_REGISTERS {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0}\n-\n-/* lots of regs aren't guaranteed to return from a call. The FPP reg */\n-/* must be included in these since it can't be saved by the reg mask */\n-\n-#define CALL_USED_REGISTERS {1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1}\n-\n-/* A single fp reg can handle any type of float.\n-   CPU regs hold just 32 bits.  */\n-\n-#define HARD_REGNO_NREGS(REGNO, MODE) \\\n- (REGNO != 16 ? ((GET_MODE_SIZE(MODE)+UNITS_PER_WORD-1) / UNITS_PER_WORD)  \\\n-  : GET_MODE_NUNITS ((MODE)))\n-\n-/* any mode greater than 4 bytes (doubles) can only go in an even regs */\n-/* and the FPP can only hold SFmode and DFmode \t\t\t       */\n-\n-#define HARD_REGNO_MODE_OK(REGNO, MODE) \\\n- (REGNO != 16\t\t\t\t\t\t\t\\\n-  ? (GET_MODE_UNIT_SIZE (MODE) <= 4 ? 1 : (REGNO % 2 - 1))\t\\\n-  : ((MODE) == SFmode || (MODE) == DFmode\t\t\t\\\n-     || (MODE) == SCmode || (MODE) == DCmode))\n-\n-/* if mode1 or mode2, but not both, are doubles then modes cannot be tied */\n-\n-#define MODES_TIEABLE_P(MODE1, MODE2) \\\n- (((MODE1) == DFmode || (MODE1) == DCmode)\t\\\n-  == ((MODE2) == DFmode || (MODE2) == DCmode))\n-\n-/* return nonzero if register variable of mode MODE is not\n-   a priori a bad idea.  Used only if defined.  */\n-#define MODE_OK_FOR_USERVAR(MODE)\t\\\n-  ((MODE) == SImode)\n-\n-/* the program counter is reg 15 */\n-\n-#define PC_REGNUM 15\n-\n-/* the stack pointer is reg 14 */\n-\n-#define STACK_POINTER_REGNUM 14\n-\n-/* the frame pointer is reg 13 */\n-\n-#define FRAME_POINTER_REGNUM 13\n-\n-/* tahoe does require an fp */\n-\n-#define FRAME_POINTER_REQUIRED 1\n-\n-/* since tahoe doesn't have a argument pointer, make it the fp */\n-\n-#define ARG_POINTER_REGNUM 13\n-\n-/* this isn't currently used since C doesn't support this feature */\n-\n-#define STATIC_CHAIN_REGNUM 0\n-\n-/* we'll use reg 1 for structure passing cause the destination */\n-/* of the eventual movblk requires it to be there anyway.      */\n-\n-#define STRUCT_VALUE_REGNUM 1\n-\n-\n-/*\n- * Register Classes\n- */\n-\n-/* tahoe has two types of regs. GENERAL_REGS are all the regs up */\n-/* to number 15. FPP_REG is the special floating point processor  */\n-/* register class (only one reg).\t\t\t\t  */\n-\n-enum reg_class {NO_REGS,GENERAL_REGS,FPP_REG,ALL_REGS,LIM_REG_CLASSES};\n-\n-/* defines the number of reg classes.\t\t\t\t    */\n-\n-#define N_REG_CLASSES (int) LIM_REG_CLASSES\n-\n-/* this defines what the classes are officially named for debugging */\n-\n-#define REG_CLASS_NAMES \\\n- {\"NO_REGS\",\"GENERAL_REGS\",\"FPP_REG\",\"ALL_REGS\"}\n-\n-/* set general regs to be the first 16 regs and the fpp reg to be 17th */\n-\n-#define REG_CLASS_CONTENTS {0,0xffff,0x10000,0x1ffff}\n-\n-/* register class for the fpp reg is FPP_REG, all others are GENERAL_REGS */\n-\n-#define REGNO_REG_CLASS(REGNO) (REGNO == 16 ? FPP_REG : GENERAL_REGS)\n-\n-/* only general registers can be used as a base reg */\n-\n-#define BASE_REG_CLASS GENERAL_REGS\n-\n-/* only general registers can be used to index */\n-\n-#define INDEX_REG_CLASS GENERAL_REGS\n-\n-/* 'a' as a constraint in the md file means the FFP_REG class */\n-\n-#define REG_CLASS_FROM_LETTER(C) (C == 'a' ? FPP_REG : NO_REGS)\n-\n-/* any general reg but the fpp can be a base reg */\n-\n-#define REGNO_OK_FOR_BASE_P(regno) \\\n-((regno) < FIRST_PSEUDO_REGISTER - 1 || reg_renumber[regno] >= 0)\n-\n-/* any general reg except the pc and fpp can be an index reg */\n-\n-#define REGNO_OK_FOR_INDEX_P(regno)  \\\n-((regno) < FIRST_PSEUDO_REGISTER - 2 || reg_renumber[regno] >= 0)\n-\n-/* if your loading a floating point constant, it can't be done */\n-/* through a register. Force it to be a memory constant.       */\n-\n-#define PREFERRED_RELOAD_CLASS(X,CLASS) \\\n-\t((GET_CODE (X) == CONST_DOUBLE) ? NO_REGS : CLASS)\n-\n-/* for the fpp reg, all modes fit; for any others, you need two for doubles */\n-\n-#define CLASS_MAX_NREGS(CLASS, MODE)\t\\\n- (CLASS != FPP_REG ? ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD) : 1)\n-\n-/* we don't define any special constant sizes so all should fail */\n-\n-#define CONST_OK_FOR_LETTER_P(VALUE, C)  0\n-\n-/* we don't define any special double sizes so all should fail */\n-\n-#define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C) 0\n-\n-\n-/*\n- * Describing Stack Layout\n- */\n-\n-/* tahoe stack grows from high to low memory */\n-\n-#define STACK_GROWS_DOWNWARD\n-\n-/* Define this if longjmp restores from saved registers\n-   rather than from what setjmp saved.  */\n-#define LONGJMP_RESTORE_FROM_STACK\n-\n-/* tahoe call frames grow from high to low memory on the stack */\n-\n-#define FRAME_GROWS_DOWNWARD\n-\n-/* the tahoe fp points to the *top* of the frame instead of the   */\n-/* bottom, so we have to make this offset a constant large enough */\n-/* to jump over the biggest frame possible.\t\t\t  */\n-\n-#define STARTING_FRAME_OFFSET -52\n-\n-/* tahoe always pushes 4 bytes unless it's a double in which case */\n-/* it pushes a full 8 bytes.\t\t\t\t\t  */\n-\n-#define PUSH_ROUNDING(BYTES) (BYTES <= 4 ? 4 : 8)\n-\n-/* the first parameter in a function is at the fp + 4 */\n-\n-#define FIRST_PARM_OFFSET(FNDECL) 4\n-\n-/* the tahoe return function takes care of everything on the stack */\n-\n-#define RETURN_POPS_ARGS(FUNDECL,FUNTYPE,SIZE) (SIZE)\n-\n-/* function values for all types are returned in register 0 */\n-\n-#define FUNCTION_VALUE(VALTYPE, FUNC)  \\\n-  gen_rtx_REG (TYPE_MODE (VALTYPE), 0)\n-\n-/* library routines also return things in reg 0 */\n-\n-#define LIBCALL_VALUE(MODE)  gen_rtx_REG (MODE, 0)\n-\n-/* Tahoe doesn't return structures in a reentrant way */\n-\n-#define PCC_STATIC_STRUCT_RETURN\n-\n-/* we only return values from a function in reg 0 */\n-\n-#define FUNCTION_VALUE_REGNO_P(N) ((N) == 0)\n-\n-/* we never pass args through a register */\n-\n-#define FUNCTION_ARG(CUM, MODE, TYPE, NAMED) 0\n-\n-/* int is fine to hold the argument summary in FUNCTION_ARG */\n-\n-#define CUMULATIVE_ARGS int\n-\n-/* we just set CUM to 0 before the FUNCTION_ARG call. No matter what */\n-/* we make it, FUNCTION_ARG will return 0 anyway\t\t     */\n-\n-#define INIT_CUMULATIVE_ARGS(CUM,FNTYPE,LIBNAME,INDIRECT)\t\\\n- ((CUM) = 0)\n-\n-/* all modes push their size rounded to the nearest word boundary */\n-/* except block which is the size of the block rounded up\t  */\n-\n-#define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED)\t\\\n- ((CUM) += ((MODE) != BLKmode\t\t\t\\\n-\t    ? (GET_MODE_SIZE (MODE) + 3) & ~3\t\\\n-\t    : (int_size_in_bytes (TYPE) + 3) & ~3))\n-\n-/* this is always false since we never pass params in regs */\n-\n-#define FUNCTION_ARG_REGNO_P(N) 0\n-\n-/* this code calculates the register entry mask and sets up    */\n-/* the stack pointer for the function. The stack is set down   */\n-/* far enough from the fp to jump over any push regs and local */\n-/* vars. This is a problem since the tahoe has the fp pointing */\n-/* to the top of the frame and the compiler must know the off- */\n-/* set off the fp to the local vars.\t\t\t       */\n-\n-#define FUNCTION_PROLOGUE(FILE, SIZE)     \\\n-{ register int regno;\t\t\t\t\t\t\\\n-  register int mask = 0;\t\t\t\t\t\\\n-  extern char call_used_regs[];\t\t\t\t\t\\\n-  for (regno = 0; regno < FIRST_PSEUDO_REGISTER-1; regno++)\t\\\n-    if (regs_ever_live[regno] && !call_used_regs[regno])\t\\\n-       mask |= 1 << regno;\t\t\t\t\t\\\n-  fprintf (FILE, \"\\t.word 0x%x\\n\", mask);\t\t\t\\\n-  if (SIZE != 0) fprintf (FILE, \"\\tsubl3 $%d,fp,sp\\n\", (SIZE) - STARTING_FRAME_OFFSET); }\n-\n-/* Zero out global variable in case it was used in this function.  */\n-#define FUNCTION_EPILOGUE(FILE, SIZE)\t\\\n-{ extern rtx tahoe_reg_conversion_loc;\t\t\t\t\\\n-  tahoe_reg_conversion_loc = 0;\t\t\t\t\t\\\n-}\n-\n-#ifdef HCX_UX\n-\n-/* to call the profiler, the address of the counter var is placed */\n-/* on the stack and then passed into mcount this way\t\t\t  */\n-\n-#define FUNCTION_PROFILER(FILE, LABELNO)  \\\n-   fprintf (FILE, \"\\tpushal LP%d\\n\\tcallf $8,mcount\\n\", (LABELNO));\n-\n-#else\n-\n-/* to call the profiler, push the variable value onto the stack */\n-/* and call mcount like a regular function.\t\t\t*/\n-\n-#define FUNCTION_PROFILER(FILE, LABELNO)  \\\n-   fprintf (FILE, \"\\tpushl $LP%d\\n\\tcallf $8,mcount\\n\", (LABELNO));\n-\n-#endif\n-\n-/* all stack handling at the end of a function is handled by the */\n-/* return command.\t\t\t\t\t\t */\n-\n-#define EXIT_IGNORE_STACK 1\n-\n-/*\n- * Library Subroutine Names\n- */\n-\n-/* udiv is a valid C library routine in libc.a, so we call that */\n-\n-#define UDIVSI3_LIBCALL \"*udiv\"\n-\n-/* urem is a valid C library routine in libc.a, so we call that */\n-/* but not so on hcx/ux */\n-\n-#ifdef HCX_UX\n-#undef UMODSI3_LIBCALL\n-#else\n-#define UMODSI3_LIBCALL \"*urem\"\n-#endif\n-\n-\n-/*\n- * Addressing Modes\n- */\n-\n-/* constant addresses can be treated exactly the same as normal constants */\n-\n-#define CONSTANT_ADDRESS_P(X)   \\\n-  (GET_CODE (X) == LABEL_REF || GET_CODE (X) == SYMBOL_REF\t\t\\\n-   || GET_CODE (X) == CONST_INT || GET_CODE (X) == CONST\t\t\\\n-   || GET_CODE (X) == HIGH)\n-\n-/* we can have as many as two regs in any given address */\n-\n-#define MAX_REGS_PER_ADDRESS 2\n-\n-/* The following is all the code for GO_IF_LEGITIMATE_ADDRESS */\n-/* most of this taken directly from the vax tm file since the */\n-/* tahoe and vax addressing modes are nearly identical.\t      */\n-\n-/* Is x an indirectable address? */\n-\n-#define INDIRECTABLE_ADDRESS_P(X)  \\\n-  (CONSTANT_ADDRESS_P (X)\t\t\t\t\t\t\\\n-   || (GET_CODE (X) == REG && REG_OK_FOR_BASE_P (X))\t\t\t\\\n-   || (GET_CODE (X) == PLUS\t\t\t\t\t\t\\\n-       && GET_CODE (XEXP (X, 0)) == REG\t\t\t\t\t\\\n-       && REG_OK_FOR_BASE_P (XEXP (X, 0))\t\t\t\t\\\n-       && CONSTANT_ADDRESS_P (XEXP (X, 1))))\n-\n-/* If x is a non-indexed-address, go to ADDR. */\n-\n-#define GO_IF_NONINDEXED_ADDRESS(X, ADDR)  \\\n-{ register rtx xfoob = (X);\t\t\t\t\t\t\\\n-  if (GET_CODE (xfoob) == REG) goto ADDR;\t\t\t\t\\\n-  if (INDIRECTABLE_ADDRESS_P (xfoob)) goto ADDR;\t\t\t\\\n-  xfoob = XEXP (X, 0);\t\t\t\t\t\t\t\\\n-  if (GET_CODE (X) == MEM && INDIRECTABLE_ADDRESS_P (xfoob))\t\t\\\n-    goto ADDR;\t\t\t\t\t\t\t\t\\\n-  if ((GET_CODE (X) == PRE_DEC || GET_CODE (X) == POST_INC)\t\t\\\n-      && GET_CODE (xfoob) == REG && REGNO (xfoob) == 14)\t\t\\\n-    goto ADDR; }\n-\n-/* Is PROD an index term in mode MODE. */\n-\n-#define INDEX_TERM_P(PROD, MODE)   \\\n-(GET_MODE_SIZE (MODE) == 1\t\t\t\t\t\t\\\n- ? (GET_CODE (PROD) == REG && REG_OK_FOR_BASE_P (PROD))\t\t\t\\\n- : (GET_CODE (PROD) == MULT\t\t\t\t\t\t\\\n-    &&\t\t\t\t\t\t\t\t\t\\\n-    (xfoo0 = XEXP (PROD, 0), xfoo1 = XEXP (PROD, 1),\t\t\t\\\n-     ((GET_CODE (xfoo0) == CONST_INT\t\t\t\t\t\\\n-       && INTVAL (xfoo0) == GET_MODE_SIZE (MODE)\t\t\t\\\n-       && GET_CODE (xfoo1) == REG\t\t\t\t\t\\\n-       && REG_OK_FOR_INDEX_P (xfoo1))\t\t\t\t\t\\\n-      ||\t\t\t\t\t\t\t\t\\\n-      (GET_CODE (xfoo1) == CONST_INT\t\t\t\t\t\\\n-       && INTVAL (xfoo1) == GET_MODE_SIZE (MODE)\t\t\t\\\n-       && GET_CODE (xfoo0) == REG\t\t\t\t\t\\\n-       && REG_OK_FOR_INDEX_P (xfoo0))))))\n-\n-/* Is the addition to the index a reg? */\n-\n-#define GO_IF_REG_PLUS_INDEX(X, MODE, ADDR)\t\\\n-{ register rtx xfooa;\t\t\t\t\t\t\t\\\n-  if (GET_CODE (X) == PLUS)\t\t\t\t\t\t\\\n-    { if (GET_CODE (XEXP (X, 0)) == REG\t\t\t\t\t\\\n-\t  && REG_OK_FOR_BASE_P (XEXP (X, 0))\t\t\t\t\\\n-\t  && (xfooa = XEXP (X, 1),\t\t\t\t\t\\\n-\t      INDEX_TERM_P (xfooa, MODE)))\t\t\t\t\\\n-\tgoto ADDR;\t\t\t\t\t\t\t\\\n-      if (GET_CODE (XEXP (X, 1)) == REG\t\t\t\t\t\\\n-\t  && REG_OK_FOR_BASE_P (XEXP (X, 1))\t\t\t\t\\\n-\t  && (xfooa = XEXP (X, 0),\t\t\t\t\t\\\n-\t      INDEX_TERM_P (xfooa, MODE)))\t\t\t\t\\\n-\tgoto ADDR; } }\n-\n-/* Is the rtx X a valid memory address for operand of mode MODE? */\n-/* If it is, go to ADDR */\n-\n-#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)  \\\n-{ register rtx xfoo, xfoo0, xfoo1;\t\t\t\t\t\\\n-  GO_IF_NONINDEXED_ADDRESS (X, ADDR);\t\t\t\t\t\\\n-  if (GET_CODE (X) == PLUS)\t\t\t\t\t\t\\\n-    { xfoo = XEXP (X, 0);\t\t\t\t\t\t\\\n-      if (INDEX_TERM_P (xfoo, MODE))\t\t\t\t\t\\\n-\t{ GO_IF_NONINDEXED_ADDRESS (XEXP (X, 1), ADDR); }\t\t\\\n-      xfoo = XEXP (X, 1);\t\t\t\t\t\t\\\n-      if (INDEX_TERM_P (xfoo, MODE))\t\t\t\t\t\\\n-\t{ GO_IF_NONINDEXED_ADDRESS (XEXP (X, 0), ADDR); }\t\t\\\n-      if (CONSTANT_ADDRESS_P (XEXP (X, 0)))\t\t\t\t\\\n-\t{ if (GET_CODE (XEXP (X, 1)) == REG\t\t\t\t\\\n-\t      && REG_OK_FOR_BASE_P (XEXP (X, 1)))\t\t\t\\\n-\t    goto ADDR;\t\t\t\t\t\t\t\\\n-\t  GO_IF_REG_PLUS_INDEX (XEXP (X, 1), MODE, ADDR); }\t\t\\\n-      if (CONSTANT_ADDRESS_P (XEXP (X, 1)))\t\t\t\t\\\n-\t{ if (GET_CODE (XEXP (X, 0)) == REG\t\t\t\t\\\n-\t      && REG_OK_FOR_BASE_P (XEXP (X, 0)))\t\t\t\\\n-\t    goto ADDR;\t\t\t\t\t\t\t\\\n-\t  GO_IF_REG_PLUS_INDEX (XEXP (X, 0), MODE, ADDR); } } }\n-\n-/* Register 16 can never be used for index or base */\n-\n-#ifndef REG_OK_STRICT\n-#define REG_OK_FOR_INDEX_P(X) (REGNO(X) != 16)\n-#define REG_OK_FOR_BASE_P(X) (REGNO(X) != 16)\n-#else\n-#define REG_OK_FOR_INDEX_P(X) REGNO_OK_FOR_INDEX_P (REGNO (X))\n-#define REG_OK_FOR_BASE_P(X) REGNO_OK_FOR_BASE_P (REGNO (X))\n-#endif\n-\n-/* Addressing is too simple to allow optimizing here */\n-\n-#define LEGITIMIZE_ADDRESS(X,OLDX,MODE,WIN)  {}\n-\n-/* Post_inc and pre_dec always adds 4 */\n-\n-#define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR,LABEL)\t\\\n- { if (GET_CODE(ADDR) == POST_INC || GET_CODE(ADDR) == PRE_DEC)\t\t\\\n-       goto LABEL;\t\t\t\t\t\t\t\\\n-   if (GET_CODE (ADDR) == PLUS)\t\t\t\t\t\t\\\n-     { if (CONSTANT_ADDRESS_P (XEXP (ADDR, 0))\t\t\t\t\\\n-\t   && GET_CODE (XEXP (ADDR, 1)) == REG);\t\t\t\\\n-       else if (CONSTANT_ADDRESS_P (XEXP (ADDR, 1))\t\t\t\\\n-\t\t&& GET_CODE (XEXP (ADDR, 0)) == REG);\t\t\t\\\n-       else goto LABEL; }}\n-\n-/* Double's are not legitimate as immediate operands */\n-\n-#define LEGITIMATE_CONSTANT_P(X) \\\n-  (GET_CODE (X) != CONST_DOUBLE)\n-\n-\n-/*\n- * Miscellaneous Parameters\n- */\n-\n-/* the elements in the case jump table are all words */\n-\n-#define CASE_VECTOR_MODE HImode\n-\n-/* Define as C expression which evaluates to nonzero if the tablejump\n-   instruction expects the table to contain offsets from the address of the\n-   table.\n-   Do not define this if the table should contain absolute addresses. */\n-#define CASE_VECTOR_PC_RELATIVE 1\n-\n-/* tahoe case instructions just fall through to the next instruction */\n-/* if not satisfied. It doesn't support a default action\t     */\n-\n-#define CASE_DROPS_THROUGH\n-\n-/* the standard answer is given here and work ok */\n-\n-#define IMPLICIT_FIX_EXPR FIX_ROUND_EXPR\n-\n-/* in a general div case, it's easiest to use TRUNC_DIV_EXPR */\n-\n-#define EASY_DIV_EXPR TRUNC_DIV_EXPR\n-\n-/* the standard seems to be leaving char's as signed so we left it */\n-/* this way even though we think they should be unsigned!\t   */\n-\n-#define DEFAULT_SIGNED_CHAR 1\n-\n-/* the most we can move without cutting down speed is 4 bytes */\n-\n-#define MOVE_MAX 4\n-\n-/* our int is 32 bits */\n-\n-#define INT_TYPE_SIZE 32\n-\n-/* byte access isn't really slower than anything else */\n-\n-#define SLOW_BYTE_ACCESS 0\n-\n-/* zero extension is more than one instruction so try to avoid it */\n-\n-#define SLOW_ZERO_EXTEND\n-\n-/* any bits higher than the low 4 are ignored in the shift count */\n-/* so don't bother zero extending or sign extending them         */\n-\n-#define SHIFT_COUNT_TRUNCATED 1\n-\n-/* we don't need to officially convert from one fixed type to another */\n-/* in order to use it as that type. We can just assume it's the same  */\n-\n-#define TRULY_NOOP_TRUNCATION(OUTPREC, INPREC) 1\n-\n-/* pass chars as ints */\n-\n-#define PROMOTE_PROTOTYPES 1\n-\n-/* pointers can be represented by an si mode expression */\n-\n-#define Pmode SImode\n-\n-/* function addresses are made by specifying a byte address */\n-\n-#define FUNCTION_MODE QImode\n-\n-/* Define this if addresses of constant functions\n-   shouldn't be put through pseudo regs where they can be cse'd.\n-   On the tahoe a call with a constant address is much faster than one with a\n-   register. */\n-\n-#define NO_FUNCTION_CSE\n-\n-/* specify the costs of various sorts of constants,\n-   and also indicate that multiplication is cheap on this machine.  */\n-\n-#define CONST_COSTS(RTX,CODE,OUTER_CODE) \\\n-  case CONST_INT:\t\t\t\t\t\t\\\n-    /* Constant zero is super cheap due to clr instruction.  */\t\\\n-    if (RTX == const0_rtx) return 0;\t\t\t\t\\\n-    if ((unsigned) INTVAL (RTX) < 077) return 1;\t\t\\\n-    if (INTVAL (RTX) <= 127 && INTVAL (RTX) >= -128) return 2;\t\\\n-  case CONST:\t\t\t\t\t\t\t\\\n-  case LABEL_REF:\t\t\t\t\t\t\\\n-  case SYMBOL_REF:\t\t\t\t\t\t\\\n-    return 3;\t\t\t\t\t\t\t\\\n-  case CONST_DOUBLE:\t\t\t\t\t\t\\\n-    return 5;\t\t\t\t\t\t\t\\\n-  case MULT:\t\t\t\t\t\t\t\\\n-    total = 2;\n-\n-\n-/*\n- * Condition Code Information\n- */\n-\n-/* Nonzero if the results of the previous comparison are\n-   in the floating point condition code register.  */\n-\n-#define CC_UNCHANGED 04000\n-\n-\n-#define NOTICE_UPDATE_CC(EXP, INSN) \\\n-{ if (cc_status.flags & CC_UNCHANGED)\t\t\t\t\\\n-    /* Happens for cvtld and a few other insns.  */\t\t\\\n-    cc_status.flags &= ~CC_UNCHANGED;\t\t\t\t\\\n-  else if (GET_CODE (EXP) == SET)\t\t\t\t\\\n-    { if (GET_CODE (SET_SRC (EXP)) == CALL)\t\t\t\\\n-\tCC_STATUS_INIT;\t\t\t\t\t\t\\\n-      else if (GET_CODE (SET_DEST (EXP)) != PC)\t\t\t\\\n-\t{ cc_status.flags = 0;\t\t\t\t\t\\\n-\t  cc_status.value1 = SET_DEST (EXP);\t\t\t\\\n-\t  cc_status.value2 = SET_SRC (EXP); } }\t\t\t\\\n-  else if (GET_CODE (EXP) == PARALLEL\t\t\t\t\\\n-\t   && GET_CODE (XVECEXP (EXP, 0, 0)) == SET\t\t\\\n-\t   && GET_CODE (SET_DEST (XVECEXP (EXP, 0, 0))) != PC)\t\\\n-    { cc_status.flags = 0;\t\t\t\t\t\\\n-      cc_status.value1 = SET_DEST (XVECEXP (EXP, 0, 0));\t\\\n-      cc_status.value2 = SET_SRC (XVECEXP (EXP, 0, 0)); }\t\\\n-  /* PARALLELs whose first element sets the PC are aob, sob insns.\t\\\n-     They do change the cc's.  So drop through and forget the cc's.  */ \\\n-  else CC_STATUS_INIT;\t\t\t\t\t\t\\\n-  if (cc_status.value1 && GET_CODE (cc_status.value1) == REG\t\\\n-      && cc_status.value2\t\t\t\t\t\\\n-      && reg_overlap_mentioned_p (cc_status.value1, cc_status.value2))\t\\\n-    cc_status.value2 = 0;\t\t\t\t\t\\\n-  if (cc_status.value1 && GET_CODE (cc_status.value1) == MEM\t\\\n-      && cc_status.value2\t\t\t\t\t\\\n-      && GET_CODE (cc_status.value2) == MEM)\t\t\t\\\n-    cc_status.value2 = 0; }\n-/* Actual condition, one line up, should be that value2's address\n-   depends on value1, but that is too much of a pain.  */\n-\n-\n-/*\n- * Output of Assembler Code\n- */\n-\n-/* print which tahoe version compiled this code and print a directive */\n-/* to the gnu assembler to say that the following is normal assembly  */\n-\n-#ifdef HCX_UX\n-#define ASM_FILE_START(FILE)\t\t\\\n-{ fprintf (FILE, \"#gcc hcx 1.0\\n\\n\");\t\\\n-  output_file_directive ((FILE), main_input_filename);} while (0)\n-#else\n-#define ASM_FILE_START(FILE) fprintf (FILE, \"#gcc tahoe 1.0\\n#NO_APP\\n\");\n-#endif\n-\n-/* the instruction that turns on the APP for the gnu assembler */\n-\n-#define ASM_APP_ON \"#APP\\n\"\n-\n-/* the instruction that turns off the APP for the gnu assembler */\n-\n-#define ASM_APP_OFF \"#NO_APP\\n\"\n-\n-/* what to output before read-only data.  */\n-\n-#define TEXT_SECTION_ASM_OP \"\\t.text\"\n-\n-/* what to output before writable data.  */\n-\n-#define DATA_SECTION_ASM_OP \"\\t.data\"\n-\n-/* this is what we call each of the regs. notice that the FPP reg is   */\n-/* called \"ac\". This should never get used due to the way we've set    */\n-/* up FPP instructions in the md file. But we call it \"ac\" here to     */\n-/* fill the list.\t\t\t\t\t\t       */\n-\n-#define REGISTER_NAMES \\\n-{\"r0\", \"r1\", \"r2\", \"r3\", \"r4\", \"r5\", \"r6\", \"r7\", \"r8\", \\\n- \"r9\", \"r10\", \"r11\", \"r12\", \"fp\", \"sp\", \"pc\", \"ac\"}\n-\n-#ifdef HCX_UX\n-/* allow generation of sdb info in the assembly */\n-#define SDB_DEBUGGING_INFO\n-#else\n-/* allow generation of dbx info in the assembly */\n-\n-#define DBX_DEBUGGING_INFO\n-\n-/* our dbx doesn't support this */\n-\n-#define DBX_NO_XREFS\n-\n-/* we don't want symbols broken up */\n-\n-#define DBX_CONTIN_LENGTH 0\n-\n-/* this'll really never be used, but we'll leave it at this */\n-\n-#define DBX_CONTIN_CHAR '?'\n-\n-#endif /* HCX_UX */\n-\n-/* registers are called the same thing in dbx anything else */\n-/* This is necessary even if we generate SDB output */\n-\n-#define DBX_REGISTER_NUMBER(REGNO) (REGNO)\n-\n-/* labels are the label followed by a colon and a newline */\n-/* must be a statement, so surround it in a null loop     */\n-\n-#define ASM_OUTPUT_LABEL(FILE,NAME)\t\\\n-  do { assemble_name (FILE, NAME); fputs (\":\\n\", FILE); } while (0)\n-\n-/* use the .globl directive to make labels global for the linker */\n-\n-#define ASM_GLOBALIZE_LABEL(FILE,NAME)\t\\\n-  do { fputs (\".globl \", FILE); assemble_name (FILE, NAME); fputs (\"\\n\", FILE);} while (0)\n-\n-/* The prefix to add to user-visible assembler symbols. */\n-\n-#define USER_LABEL_PREFIX \"_\"\n-\n-/* use the standard format for printing internal labels */\n-\n-#define ASM_OUTPUT_INTERNAL_LABEL(FILE,PREFIX,NUM)\t\\\n-  fprintf (FILE, \"%s%d:\\n\", PREFIX, NUM)\n-\n-/* a * is used for label indirection in unix assembly */\n-\n-#define ASM_GENERATE_INTERNAL_LABEL(LABEL,PREFIX,NUM)\t\\\n-  sprintf (LABEL, \"*%s%d\", PREFIX, NUM)\n-\n-/* outputting a double is easy cause we only have one kind */\n-\n-#ifdef HCX_UX\n-#define ASM_OUTPUT_DOUBLE(FILE,VALUE)  \\\n-  fprintf (FILE, \"\\t.double 0d%.20e\\n\", (VALUE))\n-#else\n-#define ASM_OUTPUT_DOUBLE(FILE,VALUE)  \\\n-{\t\t\t\t\t\t\t\\\n-  union { int i[2]; double d;} temp;\t\t\t\\\n-  temp.d = (VALUE);\t\t\t\t\t\\\n-  if (TARGET_HEX_FLOAT)\t\t\t\t\t\\\n-    fprintf ((FILE), \"\\t.long 0x%x,0x%x  # %.20e\\n\",\t\\\n-\t     temp.i[0], temp.i[1], temp.d);\t\t\\\n-  else\t\t\t\t\t\t\t\\\n-    fprintf (FILE, \"\\t.dfloat 0d%.20e\\n\", temp.d);\t\\\n-}\n-#endif\n-\n-/* This is how to output an assembler line defining a `float' constant.  */\n-\n-#ifdef HCX_UX\n-#define ASM_OUTPUT_FLOAT(FILE,VALUE)  \\\n-  fprintf (FILE, \"\\t.float 0f%.20e\\n\", (VALUE))\n-#else\n-#define ASM_OUTPUT_FLOAT(FILE,VALUE)  \\\n-{\t\t\t\t\t\t\t\\\n-  union { int i; float f;} temp;\t\t\t\\\n-  temp.f = (float) (VALUE);\t\t\t\t\\\n-  if (TARGET_HEX_FLOAT)\t\t\t\t\t\\\n-    fprintf ((FILE), \"\\t.long 0x%x  # %.20e\\n\",\t\t\\\n-\t     temp.i, temp.f);\t\t\t\t\\\n-  else\t\t\t\t\t\t\t\\\n-    fprintf (FILE, \"\\t.float 0f%.20e\\n\", temp.f);\t\\\n-}\n-#endif\n-\n-/* This is how to output an assembler line defining an `int' constant.  */\n-\n-#define ASM_OUTPUT_INT(FILE,VALUE)  \\\n-( fprintf (FILE, \"\\t.long \"),\t\t\t\\\n-  output_addr_const (FILE, (VALUE)),\t\t\\\n-  fprintf (FILE, \"\\n\"))\n-\n-/* Likewise for `char' and `short' constants.  */\n-\n-#define ASM_OUTPUT_SHORT(FILE,VALUE)  \\\n-( fprintf (FILE, \"\\t.word \"),\t\t\t\\\n-  output_addr_const (FILE, (VALUE)),\t\t\\\n-  fprintf (FILE, \"\\n\"))\n-\n-#define ASM_OUTPUT_CHAR(FILE,VALUE)  \\\n-( fprintf (FILE, \"\\t.byte \"),\t\t\t\\\n-  output_addr_const (FILE, (VALUE)),\t\t\\\n-  fprintf (FILE, \"\\n\"))\n-\n-#ifdef HCX_UX\n-/* This is how to output an assembler line for an ASCII string.  */\n-\n-#define ASM_OUTPUT_ASCII(FILE, p, size)  \t\t\\\n-do {\tregister int i;\t\t\t\t\t\\\n-\t  fprintf ((FILE), \"\\t.ascii \\\"\"); \t\t\\\n-\t  for (i = 0; i < (size); i++) \t\t\t\\\n-\t    {\t\t\t\t\t\t\\\n-\t      register int c = (p)[i];\t\t\t\\\n-\t      if (c == '\\'' || c == '\\\\')\t\t\\\n-\t\tputc ('\\\\', (FILE));\t\t\t\\\n-\t      if (c >= ' ' && c < 0177 && c != '\\\"')\t\\\n-\t\tputc (c, (FILE));\t\t\t\\\n-\t      else\t\t\t\t\t\\\n-\t\t{\t\t\t\t\t\\\n-\t\t  fprintf ((FILE), \"\\\\%03o\", c);\t\\\n-\t\t}\t\t\t\t\t\\\n-\t    }\t\t\t\t\t\t\\\n-\t  fprintf ((FILE), \"\\\"\\n\"); } while (0)\n-#endif\n-\n-/* This is how to output an assembler line for a numeric constant byte.  */\n-\n-#define ASM_OUTPUT_BYTE(FILE,VALUE)  \\\n-  fprintf (FILE, \"\\t.byte 0x%x\\n\", (VALUE))\n-\n-/* this is the insn to push a register onto the stack */\n-\n-#define ASM_OUTPUT_REG_PUSH(FILE,REGNO)\t\\\n-  fprintf (FILE, \"\\tpushl %s\\n\", reg_names[REGNO])\n-\n-/* this is the insn to pop a register from the stack */\n-\n-#define ASM_OUTPUT_REG_POP(FILE,REGNO)\t\\\n-  fprintf (FILE, \"\\tmovl (sp)+,%s\\n\", reg_names[REGNO])\n-\n-/* this is required even thought tahoe doesn't support it */\n-/* cause the C code expects it to be defined\t\t  */\n-\n-#define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)  \\\n-  fprintf (FILE, \"\\t.long L%d\\n\", VALUE)\n-\n-/* This is how to output an element of a case-vector that is relative.  */\n-\n-#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL)  \\\n-  fprintf (FILE, \"\\t.word L%d-L%d\\n\", VALUE, REL)\n-\n-/* This is how to output an assembler line\n-   that says to advance the location counter\n-   to a multiple of 2**LOG bytes.  */\n-\n-#ifdef HCX_UX\n-#define CASE_ALIGNMENT 2\n-#define ASM_OUTPUT_ALIGN(FILE,LOG)  \\\n-    if ((LOG)!=0) fprintf ((FILE), \"\\t.align %d\\n\", 1<<(LOG))\n-#else\n-#define CASE_ALIGNMENT 1\n-#define ASM_OUTPUT_ALIGN(FILE,LOG)  \\\n-  LOG ? fprintf (FILE, \"\\t.align %d\\n\", (LOG)) : 0\n-#endif\n-\n-/* This is how to skip over some space */\n-\n-#define ASM_OUTPUT_SKIP(FILE,SIZE)  \\\n-  fprintf (FILE, \"\\t.space %u\\n\", (SIZE))\n-\n-/* This defines common variables across files */\n-\n-#ifdef HCX_UX\n-#define ASM_OUTPUT_COMMON(FILE, NAME, SIZE, ROUNDED)  \\\n-( fputs (\".comm \", (FILE)),\t\t\t\\\n-  assemble_name ((FILE), (NAME)),\t\t\\\n-  fprintf ((FILE), \",%u\\n\", (SIZE)))\n-#else\n-#define ASM_OUTPUT_COMMON(FILE, NAME, SIZE, ROUNDED)  \\\n-( fputs (\".comm \", (FILE)),\t\t\t\\\n-  assemble_name ((FILE), (NAME)),\t\t\\\n-  fprintf ((FILE), \",%u\\n\", (ROUNDED)))\n-#endif\n-\n-/* This says how to output an assembler line\n-   to define a local common symbol.  */\n-\n-#ifdef HCX_UX\n-#define ASM_OUTPUT_LOCAL(FILE, NAME, SIZE, ROUNDED)  \\\n-( fputs (\"\\t.bss \", (FILE)),\t\t\t\\\n-  assemble_name ((FILE), (NAME)),\t\t\\\n-  fprintf ((FILE), \",%u,4\\n\", (SIZE),(ROUNDED)))\n-#else\n-#define ASM_OUTPUT_LOCAL(FILE, NAME, SIZE, ROUNDED)  \\\n-( fputs (\".lcomm \", (FILE)),\t\t\t\\\n-  assemble_name ((FILE), (NAME)),\t\t\\\n-  fprintf ((FILE), \",%u\\n\", (ROUNDED)))\n-#endif\n-\n-/* code to generate a label */\n-\n-#define ASM_FORMAT_PRIVATE_NAME(OUTPUT, NAME, LABELNO)\t\\\n-( (OUTPUT) = (char *) alloca (strlen ((NAME)) + 10),\t\\\n-  sprintf ((OUTPUT), \"%s.%d\", (NAME), (LABELNO)))\n-\n-/* Define the parentheses used to group arithmetic operations\n-   in assembler code.  */\n-\n-#define ASM_OPEN_PAREN \"(\"\n-#define ASM_CLOSE_PAREN \")\"\n-\n-/* Define results of standard character escape sequences.  */\n-\n-#define TARGET_BELL 007\n-#define TARGET_BS 010\n-#define TARGET_TAB 011\n-#define TARGET_NEWLINE 012\n-#define TARGET_VT 013\n-#define TARGET_FF 014\n-#define TARGET_CR 015\n-\n-/* Print an instruction operand X on file FILE.\n-   CODE is the code from the %-spec that requested printing this operand;\n-   if `%z3' was used to print operand 3, then CODE is 'z'.\n-   On the Vax, the only code used is `#', indicating that either\n-   `d' or `g' should be printed, depending on whether we're using dfloat\n-   or gfloat.  */\n-/* Print an operand.  Some difference from the vax code,\n-   since the tahoe can't support immediate floats and doubles.\n-\n-   %@ means print the proper alignment operand for aligning after a casesi.\n-   This depends on the assembler syntax.\n-   This is 1 for our assembler, since .align is logarithmic.\n-\n-   %s means the number given is supposed to be a shift value, but on\n-   the tahoe it should be converted to a number that can be used as a\n-   multiplicative constant (cause multiplication is a whole lot faster\n-   than shifting). So make the number 2^n instead. */\n-\n-#define PRINT_OPERAND_PUNCT_VALID_P(CODE)\t\t\t\t\\\n-  ((CODE) == '@')\n-\n-#define PRINT_OPERAND(FILE, X, CODE)  \\\n-{ if (CODE == '@')\t\t\t\t\t\t\t\\\n-    putc ('0' + CASE_ALIGNMENT, FILE);\t\t\t\t\t\\\n-  else if (CODE == 's')\t\t\t\t\t\t\t\\\n-    fprintf (FILE, \"$%d\", 1 << INTVAL(X));\t\t\t\t\\\n-  else if (GET_CODE (X) == REG)\t\t\t\t\t\t\\\n-    fprintf (FILE, \"%s\", reg_names[REGNO (X)]);\t\t\t\t\\\n-  else if (GET_CODE (X) == MEM)\t\t\t\t\t\t\\\n-    output_address (XEXP (X, 0));\t\t\t\t\t\\\n-  else { putc ('$', FILE); output_addr_const (FILE, X); }}\n-\n-/* When the operand is an address, call print_operand_address to */\n-/* do the work from output-tahoe.c.\t\t\t\t */\n-\n-#define PRINT_OPERAND_ADDRESS(FILE, ADDR)  \\\n- print_operand_address (FILE, ADDR)\n-\n-/* This is for G++ */\n-\n-#define CRT0_DUMMIES\n-#define DOT_GLOBAL_START\n-#ifdef HCX_UX\n-#define NO_GNU_LD /* because of COFF format */\n-#define LINK_SPEC \"-L/usr/staff/lib\"\n-#endif"}, {"sha": "34b487f85c06c85d240f80c8b705ccc6a6e7060f", "filename": "gcc/config/tahoe/tahoe.md", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7b4171a5b8a655097812307bbe261032dfbe366/gcc%2Fconfig%2Ftahoe%2Ftahoe.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7b4171a5b8a655097812307bbe261032dfbe366/gcc%2Fconfig%2Ftahoe%2Ftahoe.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftahoe%2Ftahoe.md?ref=a7b4171a5b8a655097812307bbe261032dfbe366"}, {"sha": "1af7bdda31ebc042deb72225929cb721e33adfad", "filename": "gcc/config/tahoe/xm-tahoe.h", "status": "removed", "additions": 0, "deletions": 59, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7b4171a5b8a655097812307bbe261032dfbe366/gcc%2Fconfig%2Ftahoe%2Fxm-tahoe.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7b4171a5b8a655097812307bbe261032dfbe366/gcc%2Fconfig%2Ftahoe%2Fxm-tahoe.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ftahoe%2Fxm-tahoe.h?ref=a7b4171a5b8a655097812307bbe261032dfbe366"}, {"sha": "a4d00374be466e818dd6c928f6e0c3e3c0ab5bd1", "filename": "gcc/configure", "status": "modified", "additions": 92, "deletions": 121, "changes": 213, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/776749c5f2d9a2e3e1fc34d2ae1738012c773ba0/gcc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/776749c5f2d9a2e3e1fc34d2ae1738012c773ba0/gcc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure?ref=776749c5f2d9a2e3e1fc34d2ae1738012c773ba0"}, {"sha": "557f2357ed6d3e4072f2d6b80836dda2b966eba7", "filename": "gcc/configure.in", "status": "modified", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/776749c5f2d9a2e3e1fc34d2ae1738012c773ba0/gcc%2Fconfigure.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/776749c5f2d9a2e3e1fc34d2ae1738012c773ba0/gcc%2Fconfigure.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure.in?ref=776749c5f2d9a2e3e1fc34d2ae1738012c773ba0"}]}