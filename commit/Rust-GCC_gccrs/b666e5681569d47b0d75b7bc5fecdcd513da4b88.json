{"sha": "b666e5681569d47b0d75b7bc5fecdcd513da4b88", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjY2NmU1NjgxNTY5ZDQ3YjBkNzViN2JjNWZlY2RjZDUxM2RhNGI4OA==", "commit": {"author": {"name": "Geert Bosch", "email": "bosch@adacore.com", "date": "2008-07-31T10:27:20Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2008-07-31T10:27:20Z"}, "message": "arit64.c: New file implementing __gnat_mulv64 signed integer multiplication with overflow...\n\n2008-07-31  Geert Bosch  <bosch@adacore.com>\n\n\t* arit64.c:\n\tNew file implementing __gnat_mulv64 signed integer multiplication with\n\toverflow checking\n\n\t* fe.h (Backend_Overflow_Checks_On_Target): Define for use by Gigi\n\n\t* gcc-interface/gigi.h:\n\t(standard_types): Add ADT_mulv64_decl\n\t(mulv64_decl): Define subprogram declaration for __gnat_mulv64\n\n\t* gcc-interface/utils.c:\n\t(init_gigi_decls): Add initialization of mulv64_decl\n\n\t* gcc-interface/trans.c:\n\t(build_unary_op_trapv): New function\n\t(build_binary_op_trapv): New function\n\t(gnat_to_gnu): Use the above functions instead of\n\tbuild_{unary,binary}_op\n\n\t* gcc-interface/Makefile.in\n\t(LIBGNAT_SRCS): Add arit64.c\n\t(LIBGNAT_OBJS): Add arit64.o\n\nFrom-SVN: r138384", "tree": {"sha": "1a6f7b4149003b503d7b9e36f8cf1dc1cd606d93", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1a6f7b4149003b503d7b9e36f8cf1dc1cd606d93"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b666e5681569d47b0d75b7bc5fecdcd513da4b88", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b666e5681569d47b0d75b7bc5fecdcd513da4b88", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b666e5681569d47b0d75b7bc5fecdcd513da4b88", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b666e5681569d47b0d75b7bc5fecdcd513da4b88/comments", "author": null, "committer": null, "parents": [{"sha": "b2c6b35f24ba203e027caa8e5206810d3d6ae265", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b2c6b35f24ba203e027caa8e5206810d3d6ae265", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b2c6b35f24ba203e027caa8e5206810d3d6ae265"}], "stats": {"total": 258, "additions": 253, "deletions": 5}, "files": [{"sha": "c21f67c94184c18c69e03e6f98235f2fb15eb08f", "filename": "gcc/ada/arit64.c", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b666e5681569d47b0d75b7bc5fecdcd513da4b88/gcc%2Fada%2Farit64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b666e5681569d47b0d75b7bc5fecdcd513da4b88/gcc%2Fada%2Farit64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Farit64.c?ref=b666e5681569d47b0d75b7bc5fecdcd513da4b88", "patch": "@@ -0,0 +1,58 @@\n+/****************************************************************************\n+ *                                                                          *\n+ *                         GNAT COMPILER COMPONENTS                         *\n+ *                                                                          *\n+ *                             A R I T 6 4 . C                              *\n+ *                                                                          *\n+ *                          C Implementation File                           *\n+ *                                                                          *\n+ *         Copyright (C) 2008, Free Software Foundation, Inc.               *\n+ *                                                                          *\n+ * GNAT is free software;  you can  redistribute it  and/or modify it under *\n+ * terms of the  GNU General Public License as published  by the Free Soft- *\n+ * ware  Foundation;  either version 2,  or (at your option) any later ver- *\n+ * sion.  GNAT is distributed in the hope that it will be useful, but WITH- *\n+ * OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY *\n+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License *\n+ * for  more details.  You should have  received  a copy of the GNU General *\n+ * Public License  distributed with GNAT;  see file COPYING.  If not, write *\n+ * to  the  Free Software Foundation,  51  Franklin  Street,  Fifth  Floor, *\n+ * Boston, MA 02110-1301, USA.                                              *\n+ *                                                                          *\n+ * As a  special  exception,  if you  link  this file  with other  files to *\n+ * produce an executable,  this file does not by itself cause the resulting *\n+ * executable to be covered by the GNU General Public License. This except- *\n+ * ion does not  however invalidate  any other reasons  why the  executable *\n+ * file might be covered by the  GNU Public License.                        *\n+ *                                                                          *\n+ * GNAT was originally developed  by the GNAT team at  New York University. *\n+ * Extensive contributions were provided by Ada Core Technologies Inc.      *\n+ *                                                                          *\n+ ****************************************************************************/\n+\n+extern void __gnat_rcheck_10(char *file, int line)\n+  __attribute__ ((__noreturn__));\n+\n+long long int __gnat_mulv64 (long long int x, long long int y)\n+{\n+  unsigned neg = (x >= 0) ^ (y >= 0);\n+  long long unsigned xa = x >= 0 ? (long long unsigned) x\n+                                 : -(long long unsigned) x;\n+  long long unsigned ya = y >= 0 ? (long long unsigned) y\n+                                 : -(long long unsigned) y;\n+  unsigned xhi = (unsigned) (xa >> 32);\n+  unsigned yhi = (unsigned) (ya >> 32);\n+  unsigned xlo = (unsigned) xa;\n+  unsigned ylo = (unsigned) ya;\n+  long long unsigned mid\n+    = xhi ? (long long unsigned) xhi * (long long unsigned) ylo\n+\t : (long long unsigned) yhi * (long long unsigned) xlo;\n+  long long unsigned low = (long long unsigned) xlo * (long long unsigned) ylo;\n+\n+  if ((xhi && yhi) ||  mid + (low  >> 32) > 0x7fffffff + neg)\n+    __gnat_rcheck_10 (__FILE__, __LINE__);\n+\n+  low += ((long long unsigned) (unsigned) mid) << 32;\n+\n+  return (long long int) (neg ? -low : low);\n+}"}, {"sha": "e69f798db5d34fb06090740f1d20f076230d1543", "filename": "gcc/ada/fe.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b666e5681569d47b0d75b7bc5fecdcd513da4b88/gcc%2Fada%2Ffe.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b666e5681569d47b0d75b7bc5fecdcd513da4b88/gcc%2Fada%2Ffe.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffe.h?ref=b666e5681569d47b0d75b7bc5fecdcd513da4b88", "patch": "@@ -219,8 +219,10 @@ extern void Set_Has_No_Elaboration_Code\t(Node_Id, Boolean);\n \n /* targparm: */\n \n+#define Backend_Overflow_Checks_On_Target targparm__backend_overflow_checks_on_target\n #define Stack_Check_Probes_On_Target targparm__stack_check_probes_on_target\n #define Stack_Check_Limits_On_Target targparm__stack_check_limits_on_target\n \n+extern Boolean Backend_Overflow_Checks_On_Target;\n extern Boolean Stack_Check_Probes_On_Target;\n extern Boolean Stack_Check_Limits_On_Target;"}, {"sha": "c939a0f9ff43ec6ff705f1687b399d6cd899d6b6", "filename": "gcc/ada/gcc-interface/Makefile.in", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b666e5681569d47b0d75b7bc5fecdcd513da4b88/gcc%2Fada%2Fgcc-interface%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b666e5681569d47b0d75b7bc5fecdcd513da4b88/gcc%2Fada%2Fgcc-interface%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2FMakefile.in?ref=b666e5681569d47b0d75b7bc5fecdcd513da4b88", "patch": "@@ -1715,13 +1715,13 @@ endif\n # go into the directory.  The pthreads emulation is built in the threads\n # subdirectory and copied.\n LIBGNAT_SRCS = adaint.c adaint.h argv.c cio.c cstreams.c \\\n-  errno.c exit.c cal.c ctrl_c.c env.c env.h \\\n+  errno.c exit.c cal.c ctrl_c.c env.c env.h arit64.c \\\n   raise.h raise.c sysdep.c aux-io.c init.c initialize.c seh_init.c \\\n   final.c tracebak.c tb-alvms.c tb-alvxw.c tb-gcc.c expect.c mkdir.c \\\n   socket.c gsocket.h targext.c $(EXTRA_LIBGNAT_SRCS)\n \n LIBGNAT_OBJS = adaint.o argv.o cio.o cstreams.o ctrl_c.o errno.o exit.o env.o \\\n-  raise.o sysdep.o aux-io.o init.o initialize.o seh_init.o cal.o \\\n+  raise.o sysdep.o aux-io.o init.o initialize.o seh_init.o cal.o arit64.o \\\n   final.o tracebak.o expect.o mkdir.o socket.o targext.o $(EXTRA_LIBGNAT_OBJS)\n \n # NOTE ??? - when the -I option for compiling Ada code is made to work,"}, {"sha": "f44fec89abdb1e93a2a961dceff48f3c34f6c822", "filename": "gcc/ada/gcc-interface/gigi.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b666e5681569d47b0d75b7bc5fecdcd513da4b88/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b666e5681569d47b0d75b7bc5fecdcd513da4b88/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fgigi.h?ref=b666e5681569d47b0d75b7bc5fecdcd513da4b88", "patch": "@@ -394,6 +394,9 @@ enum standard_datatypes\n   /* Likewise for freeing memory.  */\n   ADT_free_decl,\n \n+  /* Function decl node for 64-bit multiplication with overflow checking */\n+  ADT_mulv64_decl,\n+\n   /* Types and decls used by our temporary exception mechanism.  See\n      init_gigi_decls for details.  */\n   ADT_jmpbuf_type,\n@@ -425,6 +428,7 @@ extern GTY(()) tree gnat_raise_decls[(int) LAST_REASON_CODE + 1];\n #define malloc_decl gnat_std_decls[(int) ADT_malloc_decl]\n #define malloc32_decl gnat_std_decls[(int) ADT_malloc32_decl]\n #define free_decl gnat_std_decls[(int) ADT_free_decl]\n+#define mulv64_decl gnat_std_decls[(int) ADT_mulv64_decl]\n #define jmpbuf_type gnat_std_decls[(int) ADT_jmpbuf_type]\n #define jmpbuf_ptr_type gnat_std_decls[(int) ADT_jmpbuf_ptr_type]\n #define get_jmpbuf_decl gnat_std_decls[(int) ADT_get_jmpbuf_decl]"}, {"sha": "f8e1d49eaa27db21318aa4800343a7400ce106fd", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 179, "deletions": 3, "changes": 182, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b666e5681569d47b0d75b7bc5fecdcd513da4b88/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b666e5681569d47b0d75b7bc5fecdcd513da4b88/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=b666e5681569d47b0d75b7bc5fecdcd513da4b88", "patch": "@@ -205,6 +205,8 @@ static void process_decls (List_Id, List_Id, Node_Id, bool, bool);\n static tree emit_range_check (tree, Node_Id);\n static tree emit_index_check (tree, tree, tree, tree);\n static tree emit_check (tree, tree, int);\n+static tree build_unary_op_trapv (enum tree_code, tree, tree);\n+static tree build_binary_op_trapv (enum tree_code, tree, tree, tree);\n static tree convert_with_check (Entity_Id, tree, bool, bool, bool);\n static bool smaller_packable_type_p (tree, tree);\n static bool addressable_p (tree, tree);\n@@ -3939,7 +3941,22 @@ gnat_to_gnu (Node_Id gnat_node)\n \t    gnu_rhs = convert (gnu_type, gnu_rhs);\n \t  }\n \n-\tgnu_result = build_binary_op (code, gnu_type, gnu_lhs, gnu_rhs);\n+\t/* Instead of expanding overflow checks for addition, subtraction\n+\t   and multiplication itself, the front end will leave this to\n+\t   the back end when Backend_Overflow_Checks_On_Target is set.\n+\t   As the GCC back end itself does not know yet how to properly\n+\t   do overflow checking, do it here.  The goal is to push\n+\t   the expansions further into the back end over time.  */\n+\tif (Do_Overflow_Check (gnat_node) && Backend_Overflow_Checks_On_Target\n+            && (Nkind (gnat_node) == N_Op_Add\n+\t\t|| Nkind (gnat_node) == N_Op_Subtract\n+\t\t|| Nkind (gnat_node) == N_Op_Multiply)\n+\t    && !TYPE_UNSIGNED (gnu_type)\n+\t    && !FLOAT_TYPE_P (gnu_type))\n+          gnu_result\n+\t    = build_binary_op_trapv (code, gnu_type, gnu_lhs, gnu_rhs);\n+\telse\n+\t  gnu_result = build_binary_op (code, gnu_type, gnu_lhs, gnu_rhs);\n \n \t/* If this is a logical shift with the shift count not verified,\n \t   we must return zero if it is too large.  We cannot compensate\n@@ -4004,8 +4021,14 @@ gnat_to_gnu (Node_Id gnat_node)\n          gnu_result_type = get_unpadded_type (Base_Type\n \t\t\t\t\t      (Full_View (Etype (gnat_node))));\n \n-      gnu_result = build_unary_op (gnu_codes[Nkind (gnat_node)],\n-\t\t\t\t   gnu_result_type, gnu_expr);\n+      if (Do_Overflow_Check (gnat_node)\n+\t  && !TYPE_UNSIGNED (gnu_result_type)\n+\t  && !FLOAT_TYPE_P (gnu_result_type))\n+\tgnu_result = build_unary_op_trapv (gnu_codes[Nkind (gnat_node)],\n+\t\t\t\t\t   gnu_result_type, gnu_expr);\n+      else\n+\tgnu_result = build_unary_op (gnu_codes[Nkind (gnat_node)],\n+\t\t\t\t     gnu_result_type, gnu_expr);\n       break;\n \n     case N_Allocator:\n@@ -5875,6 +5898,159 @@ process_decls (List_Id gnat_decls, List_Id gnat_decls2,\n \t  }\n }\n \f\n+/* Make a unary operation of kind CODE using build_unary_op, but guard\n+   the operation by an overflow check. CODE can be one of NEGATE_EXPR\n+   or ABS_EXPR.  GNU_TYPE is the type desired for the result.\n+   Usually the operation is to be performed in that type.  */\n+\n+static tree\n+build_unary_op_trapv (enum tree_code code,\n+\t\t      tree gnu_type,\n+\t\t      tree operand)\n+{\n+  gcc_assert ((code == NEGATE_EXPR) || (code == ABS_EXPR));\n+\n+  operand = save_expr (operand);\n+\n+  return emit_check (build_binary_op (EQ_EXPR, integer_type_node,\n+\t\t\t\t      operand, TYPE_MIN_VALUE (gnu_type)),\n+\t\t     build_unary_op (code, gnu_type, operand),\n+\t\t     CE_Overflow_Check_Failed);\n+}\n+\n+/* Make a binary operation of kind CODE using build_binary_op, but\n+   guard the operation by an overflow check. CODE can be one of\n+   PLUS_EXPR, MINUS_EXPR or MULT_EXPR.  GNU_TYPE is the type desired\n+   for the result.  Usually the operation is to be performed in that type.  */\n+\n+static tree\n+build_binary_op_trapv (enum tree_code code,\n+\t\t       tree gnu_type,\n+\t\t       tree left,\n+\t\t       tree right)\n+{\n+  tree lhs = save_expr (left);\n+  tree rhs = save_expr (right);\n+  tree type_max = TYPE_MAX_VALUE (gnu_type);\n+  tree type_min = TYPE_MIN_VALUE (gnu_type);\n+  tree gnu_expr;\n+  tree tmp1, tmp2;\n+  tree zero = convert (gnu_type, integer_zero_node);\n+  tree rhs_ge_zero;\n+  tree check_pos;\n+  tree check_neg;\n+\n+  int precision = TYPE_PRECISION (gnu_type);\n+\n+  /* Prefer a constant rhs to simplify checks */\n+\n+  if (TREE_CONSTANT (lhs) && !TREE_CONSTANT (rhs)\n+      && commutative_tree_code (code))\n+    {\n+      tree tmp = lhs;\n+      lhs = rhs;\n+      rhs = tmp;\n+   }\n+\n+  /* In the case the right-hand size is still not constant, try to\n+     use an exact operation in a wider type. */\n+\n+  if (!TREE_CONSTANT (rhs))\n+    {\n+      int needed_precision = code == MULT_EXPR ? 2 * precision : precision + 1;\n+\n+      if (code == MULT_EXPR && precision == 64)\n+\t{\n+\t  return build_call_2_expr (mulv64_decl, lhs, rhs);\n+\t}\n+      else if (needed_precision <= LONG_LONG_TYPE_SIZE)\n+\t{\n+\t  tree calc_type = gnat_type_for_size (needed_precision, 0);\n+\t  tree result;\n+\t  tree check;\n+\n+\t  result = build_binary_op (code, calc_type,\n+\t\t\t\t    convert (calc_type, lhs),\n+\t\t\t\t    convert (calc_type, rhs));\n+\n+\t  check = build_binary_op\n+\t    (TRUTH_ORIF_EXPR, integer_type_node,\n+\t     build_binary_op (LT_EXPR, integer_type_node, result,\n+\t\t\t      convert (calc_type, type_min)),\n+\t     build_binary_op (GT_EXPR, integer_type_node, result,\n+\t\t\t      convert (calc_type, type_max)));\n+\n+\t  result = convert (gnu_type, result);\n+\n+\t  return emit_check (check, result, CE_Overflow_Check_Failed);\n+\t}\n+    }\n+\n+  gnu_expr = build_binary_op (code, gnu_type, lhs, rhs);\n+  rhs_ge_zero = build_binary_op (GE_EXPR, integer_type_node, rhs, zero);\n+\n+  switch (code)\n+    {\n+    case PLUS_EXPR:\n+      /* When rhs >= 0, overflow when lhs > type_max - rhs */\n+      check_pos = build_binary_op (GT_EXPR, integer_type_node, lhs,\n+\t\t\t\t   build_binary_op (MINUS_EXPR, gnu_type,\n+\t\t\t\t\t\t    type_max, rhs)),\n+\n+      /* When rhs < 0, overflow when lhs < type_min - rhs */\n+      check_neg = build_binary_op (LT_EXPR, integer_type_node, lhs,\n+\t\t\t\t   build_binary_op (MINUS_EXPR, gnu_type,\n+\t\t\t\t\t\t    type_min, rhs));\n+      break;\n+\n+    case MINUS_EXPR:\n+      /* When rhs >= 0, overflow when lhs < type_min + rhs */\n+      check_pos = build_binary_op (LT_EXPR, integer_type_node, lhs,\n+\t\t\t\t   build_binary_op (PLUS_EXPR, gnu_type,\n+\t\t\t\t\t\t    type_min, rhs)),\n+\n+      /* When rhs < 0, overflow when lhs > type_max + rhs */\n+      check_neg = build_binary_op (GT_EXPR, integer_type_node, lhs,\n+\t\t\t\t   build_binary_op (PLUS_EXPR, gnu_type,\n+\t\t\t\t\t\t    type_max, rhs));\n+      break;\n+\n+    case MULT_EXPR:\n+      /* The check here is designed to be efficient if the rhs is constant,\n+         Four different check expressions determine wether X * C overflows,\n+\t depending on C.\n+\t   C ==  0  =>  false\n+\t   C  >  0  =>  X > type_max / C || X < type_min / C\n+\t   C == -1  =>  X == type_min\n+\t   C  < -1  =>  X > type_min / C || X < type_max / C */\n+\n+      tmp1 = build_binary_op (TRUNC_DIV_EXPR, gnu_type, type_max, rhs);\n+      tmp2 = build_binary_op (TRUNC_DIV_EXPR, gnu_type, type_min, rhs);\n+\n+      check_pos = build_binary_op (TRUTH_ANDIF_EXPR, integer_type_node,\n+\t\t    build_binary_op (NE_EXPR, integer_type_node, zero, rhs),\n+\t\t    build_binary_op (TRUTH_ORIF_EXPR, integer_type_node,\n+\t\t      build_binary_op (GT_EXPR, integer_type_node, lhs, tmp1),\n+\t\t      build_binary_op (LT_EXPR, integer_type_node, lhs, tmp2)));\n+\n+      check_neg = fold_build3 (COND_EXPR, integer_type_node,\n+\t\t    build_binary_op (EQ_EXPR, integer_type_node, rhs,\n+\t\t\t\t     build_int_cst (gnu_type, -1)),\n+\t\t    build_binary_op (EQ_EXPR, integer_type_node, lhs, type_min),\n+\t\t    build_binary_op (TRUTH_ORIF_EXPR, integer_type_node,\n+\t\t      build_binary_op (GT_EXPR, integer_type_node, lhs, tmp2),\n+\t\t      build_binary_op (LT_EXPR, integer_type_node, lhs, tmp1)));\n+      break;\n+\n+    default:\n+      gcc_unreachable();\n+    }\n+\n+  return emit_check (fold_build3 (COND_EXPR, integer_type_node, rhs_ge_zero,\n+\t\t\t\t  check_pos, check_neg),\n+\t\t     gnu_expr, CE_Overflow_Check_Failed);\n+}\n+\n /* Emit code for a range check. GNU_EXPR is the expression to be checked,\n    GNAT_RANGE_TYPE the gnat type or subtype containing the bounds against\n    which we have to check. */"}, {"sha": "61e36fe208cfc664a3181e42f81ffa631300d8ac", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b666e5681569d47b0d75b7bc5fecdcd513da4b88/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b666e5681569d47b0d75b7bc5fecdcd513da4b88/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=b666e5681569d47b0d75b7bc5fecdcd513da4b88", "patch": "@@ -542,6 +542,7 @@ void\n init_gigi_decls (tree long_long_float_type, tree exception_type)\n {\n   tree endlink, decl;\n+  tree int64_type = gnat_type_for_size (64, 0);\n   unsigned int i;\n \n   /* Set the types that GCC and Gigi use from the front end.  We would like\n@@ -630,6 +631,13 @@ init_gigi_decls (tree long_long_float_type, tree exception_type)\n \t\t\t\t\t\t\t   endlink)),\n \t\t\t   NULL_TREE, false, true, true, NULL, Empty);\n \n+  /* This is used for 64-bit multiplication with overflow checking.  */\n+  mulv64_decl\n+    = create_subprog_decl (get_identifier (\"__gnat_mulv64\"), NULL_TREE,\n+\t\t\t   build_function_type_list (int64_type, int64_type,\n+\t\t\t\t\t\t     int64_type, NULL_TREE),\n+\t\t\t   NULL_TREE, false, true, true, NULL, Empty);\n+\n   /* Make the types and functions used for exception processing.    */\n   jmpbuf_type\n     = build_array_type (gnat_type_for_mode (Pmode, 0),"}]}