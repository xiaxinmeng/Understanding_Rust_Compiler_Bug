{"sha": "f012c8ef4b35dcee9b5a3807868d050812d5b3b9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjAxMmM4ZWY0YjM1ZGNlZTliNWEzODA3ODY4ZDA1MDgxMmQ1YjNiOQ==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2017-05-30T20:38:14Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2017-05-30T20:38:14Z"}, "message": "C++ template type diff printing\n\ngcc/ChangeLog:\n\t* diagnostic-color.c (color_dict): Add \"type-diff\".\n\t(parse_gcc_colors): Update comment.\n\t* doc/invoke.texi (Diagnostic Message Formatting Options): Add\n\t-fdiagnostics-show-template-tree and -fno-elide-type.\n\t(GCC_COLORS): Add type-diff to example.\n\t(type-diff=): New.\n\t(-fdiagnostics-show-template-tree): New.\n\t(-fno-elide-type): New.\n\t* pretty-print.c (pp_format): Pass quote and formatters[argno] to\n\tthe pp_format_decoder callback.  Call any m_format_postprocessor's\n\t\"handle\" method.\n\t(pretty_printer::pretty_printer): Initialize\n\tm_format_postprocessor.\n\t(pretty_printer::~pretty_printer): Delete any\n\tm_format_postprocessor.\n\t* pretty-print.h (printer_fn): Add bool and const char **\n\tparameters.\n\t(class format_postprocessor): New class.\n\t(struct pretty_printer::format_decoder): Document the new\n\tparameters.\n\t(struct pretty_printer::m_format_postprocessor): New field.\n\t* tree-diagnostic.c (default_tree_printer): Update for new\n\tbool and const char ** params.\n\t* tree-diagnostic.h (default_tree_printer): Likewise.\n\ngcc/c/ChangeLog:\n\t* c-objc-common.c (c_tree_printer): Gain bool and const char **\n\tparameters.\n\ngcc/c-family/ChangeLog:\n\t* c-format.c (gcc_cxxdiag_char_table): Add 'H' and 'I' to\n\tformat_chars.\n\t* c.opt (fdiagnostics-show-template-tree): New option.\n\t(felide-type): New option.\n\ngcc/cp/ChangeLog:\n\t* call.c (perform_implicit_conversion_flags): Convert\n\t\"from %qT to %qT\" to \"from %qH to %qI\" in diagnostic.\n\t(print_conversion_rejection): Replace pairs of %qT with\n\t%qH and %qI in various places.\n\t(build_user_type_conversion_1): Likewise.\n\t(build_integral_nontype_arg_conv): Likewise.\n\t(build_conditional_expr_1): Likewise.\n\t(convert_like_real): Likewise.\n\t(convert_arg_to_ellipsis): Likewise.\n\t(joust): Likewise.\n\t(initialize_reference): Likewise.\n\t* cvt.c (cp_convert_to_pointer): Likewise.\n\t(cp_convert_to_pointer): Likewise.\n\t(convert_to_reference): Likewise.\n\t(ocp_convert): Likewise.\n\t* error.c (cp_printer): Gain bool and const char ** parameters.\n\t(struct deferred_printed_type): New struct.\n\t(class cxx_format_postprocessor): New class.\n\t(cxx_initialize_diagnostics): Wire up a cxx_format_postprocessor\n\tto pp->m_format_postprocessor.\n\t(comparable_template_types_p): New function.\n\t(newline_and_indent): New function.\n\t(arg_to_string): New function.\n\t(print_nonequal_arg): New function.\n\t(print_template_differences): New function.\n\t(type_to_string_with_compare): New function.\n\t(print_template_tree_comparison): New function.\n\t(append_formatted_chunk): New function.\n\t(add_quotes): New function.\n\t(cxx_format_postprocessor::handle): New function.\n\t(defer_phase_2_of_type_diff): New function.\n\t(cp_printer): Add \"quoted\" and \"buffer_ptr\" params.  Implement\n\t%H and %I.\n\t* typeck.c (cp_build_binary_op): Replace pairs of %qT with\n\t%qH and %qI in various places.\n\t(convert_member_func_to_ptr): Likewise.\n\t(build_reinterpret_cast_1): Likewise.\n\t(convert_for_assignment): Likewise.\n\t* typeck2.c (check_narrowing): Likewise.\n\ngcc/fortran/ChangeLog:\n\t* error.c (gfc_format_decoder): Update for new bool and\n\tconst char ** params.\n\ngcc/testsuite/ChangeLog:\n\t* g++.dg/plugin/plugin.exp (plugin_test_list): Add...\n\t* g++.dg/plugin/show-template-tree-color-no-elide-type.C: New\n\ttest case.\n\t* g++.dg/plugin/show-template-tree-color.C: New test case.\n\t* g++.dg/plugin/show_template_tree_color_plugin.c: New plugin.\n\t* g++.dg/template/show-template-tree-2.C: New test case.\n\t* g++.dg/template/show-template-tree-3.C: New test case.\n\t* g++.dg/template/show-template-tree-4.C: New test case.\n\t* g++.dg/template/show-template-tree-no-elide-type.C: New test case.\n\t* g++.dg/template/show-template-tree.C: New test case.\n\nFrom-SVN: r248698", "tree": {"sha": "02e8550289f6ec4b17f911b6571757f54cfb3e19", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/02e8550289f6ec4b17f911b6571757f54cfb3e19"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f012c8ef4b35dcee9b5a3807868d050812d5b3b9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f012c8ef4b35dcee9b5a3807868d050812d5b3b9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f012c8ef4b35dcee9b5a3807868d050812d5b3b9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f012c8ef4b35dcee9b5a3807868d050812d5b3b9/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3f8efe25d65ce84369573301df1520ba589a5faa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f8efe25d65ce84369573301df1520ba589a5faa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3f8efe25d65ce84369573301df1520ba589a5faa"}], "stats": {"total": 1176, "additions": 1117, "deletions": 59}, "files": [{"sha": "da2b93ff90021c436f2a58ca3931ceb8a7c1feca", "filename": "gcc/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f012c8ef4b35dcee9b5a3807868d050812d5b3b9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f012c8ef4b35dcee9b5a3807868d050812d5b3b9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f012c8ef4b35dcee9b5a3807868d050812d5b3b9", "patch": "@@ -1,3 +1,30 @@\n+2017-05-30  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* diagnostic-color.c (color_dict): Add \"type-diff\".\n+\t(parse_gcc_colors): Update comment.\n+\t* doc/invoke.texi (Diagnostic Message Formatting Options): Add\n+\t-fdiagnostics-show-template-tree and -fno-elide-type.\n+\t(GCC_COLORS): Add type-diff to example.\n+\t(type-diff=): New.\n+\t(-fdiagnostics-show-template-tree): New.\n+\t(-fno-elide-type): New.\n+\t* pretty-print.c (pp_format): Pass quote and formatters[argno] to\n+\tthe pp_format_decoder callback.  Call any m_format_postprocessor's\n+\t\"handle\" method.\n+\t(pretty_printer::pretty_printer): Initialize\n+\tm_format_postprocessor.\n+\t(pretty_printer::~pretty_printer): Delete any\n+\tm_format_postprocessor.\n+\t* pretty-print.h (printer_fn): Add bool and const char **\n+\tparameters.\n+\t(class format_postprocessor): New class.\n+\t(struct pretty_printer::format_decoder): Document the new\n+\tparameters.\n+\t(struct pretty_printer::m_format_postprocessor): New field.\n+\t* tree-diagnostic.c (default_tree_printer): Update for new\n+\tbool and const char ** params.\n+\t* tree-diagnostic.h (default_tree_printer): Likewise.\n+\n 2017-05-30  Segher Boessenkool  <segher@kernel.crashing.org>\n \n \t* config/rs6000/predicates.md (cc_reg_not_micro_cr0_operand): Delete."}, {"sha": "a077867c8da0fbb7866d727f87ccfaf807f0c430", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f012c8ef4b35dcee9b5a3807868d050812d5b3b9/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f012c8ef4b35dcee9b5a3807868d050812d5b3b9/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=f012c8ef4b35dcee9b5a3807868d050812d5b3b9", "patch": "@@ -1,3 +1,10 @@\n+2017-05-30  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* c-format.c (gcc_cxxdiag_char_table): Add 'H' and 'I' to\n+\tformat_chars.\n+\t* c.opt (fdiagnostics-show-template-tree): New option.\n+\t(felide-type): New option.\n+\n 2017-05-25  Volker Reichelt  <v.reichelt@netcologne.de>\n \n \t* c.opt (Wcatch-value=): New C++ warning flag."}, {"sha": "faef267220d50ef38375459e7da3c7e6f886f41a", "filename": "gcc/c-family/c-format.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f012c8ef4b35dcee9b5a3807868d050812d5b3b9/gcc%2Fc-family%2Fc-format.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f012c8ef4b35dcee9b5a3807868d050812d5b3b9/gcc%2Fc-family%2Fc-format.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-format.c?ref=f012c8ef4b35dcee9b5a3807868d050812d5b3b9", "patch": "@@ -771,7 +771,7 @@ static const format_char_info gcc_cxxdiag_char_table[] =\n   /* Custom conversion specifiers.  */\n \n   /* These will require a \"tree\" at runtime.  */\n-  { \"ADFSTVX\",1,STD_C89,{ T89_T,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q+#\",   \"'\",   NULL },\n+  { \"ADFHISTVX\",1,STD_C89,{ T89_T,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q+#\",   \"'\",   NULL },\n   { \"E\", 1,STD_C89,{ T89_T,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q+#\",   \"\",   NULL },\n   { \"K\", 1, STD_C89,{ T89_T,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"\",   \"\\\"\",   NULL },\n   { \"v\", 0,STD_C89, { T89_I,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q#\",  \"\",   NULL },"}, {"sha": "c3eca4acdeb199b6ad34008b717bfb7703a2ed9f", "filename": "gcc/c-family/c.opt", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f012c8ef4b35dcee9b5a3807868d050812d5b3b9/gcc%2Fc-family%2Fc.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f012c8ef4b35dcee9b5a3807868d050812d5b3b9/gcc%2Fc-family%2Fc.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc.opt?ref=f012c8ef4b35dcee9b5a3807868d050812d5b3b9", "patch": "@@ -1346,6 +1346,10 @@ fdefault-inline\n C++ ObjC++ Ignore\n Does nothing.  Preserved for backward compatibility.\n \n+fdiagnostics-show-template-tree\n+C++ ObjC++ Var(flag_diagnostics_show_template_tree) Init(0)\n+Print hierarchical comparisons when template types are mismatched.\n+\n fdirectives-only\n C ObjC C++ ObjC++\n Preprocess directives only.\n@@ -1365,6 +1369,10 @@ Write all declarations as Ada code for the given file only.\n felide-constructors\n C++ ObjC++ Var(flag_elide_constructors) Init(1)\n \n+felide-type\n+C++ ObjC++ Var(flag_elide_type) Init(1)\n+-fno-elide-type Do not elide common elements in template comparisons.\n+\n fenforce-eh-specs\n C++ ObjC++ Var(flag_enforce_eh_specs) Init(1)\n Generate code to check exception specifications."}, {"sha": "2fa398466b1b99b5a14cdccf96c2fa6a5785cfb6", "filename": "gcc/c/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f012c8ef4b35dcee9b5a3807868d050812d5b3b9/gcc%2Fc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f012c8ef4b35dcee9b5a3807868d050812d5b3b9/gcc%2Fc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FChangeLog?ref=f012c8ef4b35dcee9b5a3807868d050812d5b3b9", "patch": "@@ -1,3 +1,8 @@\n+2017-05-30  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* c-objc-common.c (c_tree_printer): Gain bool and const char **\n+\tparameters.\n+\n 2017-05-24  Martin Sebor  <msebor@redhat.com>\n \n \tPR c/80731"}, {"sha": "05212b2cb8e4c9477daf2cd2f86e3205a66249e4", "filename": "gcc/c/c-objc-common.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f012c8ef4b35dcee9b5a3807868d050812d5b3b9/gcc%2Fc%2Fc-objc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f012c8ef4b35dcee9b5a3807868d050812d5b3b9/gcc%2Fc%2Fc-objc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-objc-common.c?ref=f012c8ef4b35dcee9b5a3807868d050812d5b3b9", "patch": "@@ -28,7 +28,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"c-objc-common.h\"\n \n static bool c_tree_printer (pretty_printer *, text_info *, const char *,\n-\t\t\t    int, bool, bool, bool);\n+\t\t\t    int, bool, bool, bool, bool, const char **);\n \n bool\n c_missing_noreturn_ok_p (tree decl)\n@@ -75,7 +75,8 @@ c_objc_common_init (void)\n    diagnostic machinery.  */\n static bool\n c_tree_printer (pretty_printer *pp, text_info *text, const char *spec,\n-\t\tint precision, bool wide, bool set_locus, bool hash)\n+\t\tint precision, bool wide, bool set_locus, bool hash,\n+\t\tbool, const char **)\n {\n   tree t = NULL_TREE;\n   tree name;"}, {"sha": "2dac6109392d6c849ed9f8bf29af9081cf97ec90", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f012c8ef4b35dcee9b5a3807868d050812d5b3b9/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f012c8ef4b35dcee9b5a3807868d050812d5b3b9/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=f012c8ef4b35dcee9b5a3807868d050812d5b3b9", "patch": "@@ -1,3 +1,45 @@\n+2017-05-30  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* call.c (perform_implicit_conversion_flags): Convert\n+\t\"from %qT to %qT\" to \"from %qH to %qI\" in diagnostic.\n+\t(print_conversion_rejection): Replace pairs of %qT with\n+\t%qH and %qI in various places.\n+\t(build_user_type_conversion_1): Likewise.\n+\t(build_integral_nontype_arg_conv): Likewise.\n+\t(build_conditional_expr_1): Likewise.\n+\t(convert_like_real): Likewise.\n+\t(convert_arg_to_ellipsis): Likewise.\n+\t(joust): Likewise.\n+\t(initialize_reference): Likewise.\n+\t* cvt.c (cp_convert_to_pointer): Likewise.\n+\t(cp_convert_to_pointer): Likewise.\n+\t(convert_to_reference): Likewise.\n+\t(ocp_convert): Likewise.\n+\t* error.c (cp_printer): Gain bool and const char ** parameters.\n+\t(struct deferred_printed_type): New struct.\n+\t(class cxx_format_postprocessor): New class.\n+\t(cxx_initialize_diagnostics): Wire up a cxx_format_postprocessor\n+\tto pp->m_format_postprocessor.\n+\t(comparable_template_types_p): New function.\n+\t(newline_and_indent): New function.\n+\t(arg_to_string): New function.\n+\t(print_nonequal_arg): New function.\n+\t(print_template_differences): New function.\n+\t(type_to_string_with_compare): New function.\n+\t(print_template_tree_comparison): New function.\n+\t(append_formatted_chunk): New function.\n+\t(add_quotes): New function.\n+\t(cxx_format_postprocessor::handle): New function.\n+\t(defer_phase_2_of_type_diff): New function.\n+\t(cp_printer): Add \"quoted\" and \"buffer_ptr\" params.  Implement\n+\t%H and %I.\n+\t* typeck.c (cp_build_binary_op): Replace pairs of %qT with\n+\t%qH and %qI in various places.\n+\t(convert_member_func_to_ptr): Likewise.\n+\t(build_reinterpret_cast_1): Likewise.\n+\t(convert_for_assignment): Likewise.\n+\t* typeck2.c (check_narrowing): Likewise.\n+\n 2017-05-30  Nathan Sidwell  <nathan@acm.org>\n \n \tKill IDENTIFIER_NAMESPACE_BINDINGS"}, {"sha": "51260f07dfd142dcbc5b7a69330c0142335969dc", "filename": "gcc/cp/call.c", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f012c8ef4b35dcee9b5a3807868d050812d5b3b9/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f012c8ef4b35dcee9b5a3807868d050812d5b3b9/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=f012c8ef4b35dcee9b5a3807868d050812d5b3b9", "patch": "@@ -3402,7 +3402,7 @@ print_conversion_rejection (location_t loc, struct conversion_info *info)\n \t\tfrom);\n       else\n \tinform (loc, \"  no known conversion for implicit \"\n-\t\t\"%<this%> parameter from %qT to %qT\",\n+\t\t\"%<this%> parameter from %qH to %qI\",\n \t\tfrom, info->to_type);\n     }\n   else if (!TYPE_P (info->from))\n@@ -3415,10 +3415,10 @@ print_conversion_rejection (location_t loc, struct conversion_info *info)\n     }\n   else if (info->n_arg == -2)\n     /* Conversion of conversion function return value failed.  */\n-    inform (loc, \"  no known conversion from %qT to %qT\",\n+    inform (loc, \"  no known conversion from %qH to %qI\",\n \t    from, info->to_type);\n   else\n-    inform (loc, \"  no known conversion for argument %d from %qT to %qT\",\n+    inform (loc, \"  no known conversion for argument %d from %qH to %qI\",\n \t    info->n_arg + 1, from, info->to_type);\n }\n \n@@ -3925,7 +3925,7 @@ build_user_type_conversion_1 (tree totype, tree expr, int flags,\n     {\n       if (complain & tf_error)\n \t{\n-\t  error (\"conversion from %qT to %qT is ambiguous\",\n+\t  error (\"conversion from %qH to %qI is ambiguous\",\n \t\t fromtype, totype);\n \t  print_z_candidates (location_of (expr), candidates);\n \t}\n@@ -4052,7 +4052,7 @@ build_integral_nontype_arg_conv (tree type, tree expr, tsubst_flags_t complain)\n \t  break;\n \n \tif (complain & tf_error)\n-\t  error_at (loc, \"conversion from %qT to %qT not considered for \"\n+\t  error_at (loc, \"conversion from %qH to %qI not considered for \"\n \t\t    \"non-type template argument\", t, type);\n \t/* fall through.  */\n \n@@ -4818,14 +4818,14 @@ build_conditional_expr_1 (location_t loc, tree arg1, tree arg2, tree arg3,\n \t  if (unsafe_conversion_p (loc, stype, arg2, NULL_TREE, false))\n \t    {\n \t      if (complain & tf_error)\n-\t\terror_at (loc, \"conversion of scalar %qT to vector %qT \"\n+\t\terror_at (loc, \"conversion of scalar %qH to vector %qI \"\n \t\t\t       \"involves truncation\", arg2_type, vtype);\n \t      return error_mark_node;\n \t    }\n \t  if (unsafe_conversion_p (loc, stype, arg3, NULL_TREE, false))\n \t    {\n \t      if (complain & tf_error)\n-\t\terror_at (loc, \"conversion of scalar %qT to vector %qT \"\n+\t\terror_at (loc, \"conversion of scalar %qH to vector %qI \"\n \t\t\t       \"involves truncation\", arg3_type, vtype);\n \t      return error_mark_node;\n \t    }\n@@ -5214,7 +5214,7 @@ build_conditional_expr_1 (location_t loc, tree arg1, tree arg2, tree arg3,\n \t\t\t\t\t\t\t     arg3_type);\n       if (complain & tf_warning)\n \tdo_warn_double_promotion (result_type, arg2_type, arg3_type,\n-\t\t\t\t  \"implicit conversion from %qT to %qT to \"\n+\t\t\t\t  \"implicit conversion from %qH to %qI to \"\n \t\t\t\t  \"match other result of conditional\",\n \t\t\t\t  loc);\n \n@@ -6593,7 +6593,7 @@ convert_like_real (conversion *convs, tree expr, tree fn, int argnum,\n \t from std::nullptr_t requires direct-initialization.  */\n       if (NULLPTR_TYPE_P (TREE_TYPE (expr))\n \t  && TREE_CODE (totype) == BOOLEAN_TYPE)\n-\tcomplained = permerror (loc, \"converting to %qT from %qT requires \"\n+\tcomplained = permerror (loc, \"converting to %qH from %qI requires \"\n \t\t\t\t\"direct-initialization\",\n \t\t\t\ttotype, TREE_TYPE (expr));\n \n@@ -6602,7 +6602,7 @@ convert_like_real (conversion *convs, tree expr, tree fn, int argnum,\n \t  if (t->kind == ck_user && t->cand->reason)\n \t    {\n \t      complained = permerror (loc, \"invalid user-defined conversion \"\n-\t\t\t\t      \"from %qT to %qT\", TREE_TYPE (expr),\n+\t\t\t\t      \"from %qH to %qI\", TREE_TYPE (expr),\n \t\t\t\t      totype);\n \t      if (complained)\n \t\tprint_z_candidate (loc, \"candidate is:\", t->cand);\n@@ -6638,7 +6638,7 @@ convert_like_real (conversion *convs, tree expr, tree fn, int argnum,\n \t    break;\n \t}\n       if (!complained)\n-\tcomplained = permerror (loc, \"invalid conversion from %qT to %qT\",\n+\tcomplained = permerror (loc, \"invalid conversion from %qH to %qI\",\n \t\t\t\tTREE_TYPE (expr), totype);\n       if (complained && fn)\n \tinform (DECL_SOURCE_LOCATION (fn),\n@@ -6914,14 +6914,14 @@ convert_like_real (conversion *convs, tree expr, tree fn, int argnum,\n \t    tree extype = TREE_TYPE (expr);\n \t    if (TYPE_REF_IS_RVALUE (ref_type)\n \t\t&& lvalue_p (expr))\n-\t      error_at (loc, \"cannot bind rvalue reference of type %qT to \"\n-                        \"lvalue of type %qT\", totype, extype);\n+\t      error_at (loc, \"cannot bind rvalue reference of type %qH to \"\n+                        \"lvalue of type %qI\", totype, extype);\n \t    else if (!TYPE_REF_IS_RVALUE (ref_type) && !lvalue_p (expr)\n \t\t     && !CP_TYPE_CONST_NON_VOLATILE_P (TREE_TYPE (ref_type)))\n \t      error_at (loc, \"cannot bind non-const lvalue reference of \"\n-\t\t\t\"type %qT to an rvalue of type %qT\", totype, extype);\n+\t\t\t\"type %qH to an rvalue of type %qI\", totype, extype);\n \t    else if (!reference_compatible_p (TREE_TYPE (totype), extype))\n-\t      error_at (loc, \"binding reference of type %qT to %qT \"\n+\t      error_at (loc, \"binding reference of type %qH to %qI \"\n \t\t\t\"discards qualifiers\", totype, extype);\n \t    else\n \t      gcc_unreachable ();\n@@ -7073,7 +7073,7 @@ convert_arg_to_ellipsis (tree arg, tsubst_flags_t complain)\n       if ((complain & tf_warning)\n \t  && warn_double_promotion && !c_inhibit_evaluation_warnings)\n \twarning_at (loc, OPT_Wdouble_promotion,\n-\t\t    \"implicit conversion from %qT to %qT when passing \"\n+\t\t    \"implicit conversion from %qH to %qI when passing \"\n \t\t    \"argument to function\",\n \t\t    arg_type, double_type_node);\n       arg = convert_to_real_nofold (double_type_node, arg);\n@@ -9640,7 +9640,7 @@ joust (struct z_candidate *cand1, struct z_candidate *cand2, bool warn,\n \t  if (! DECL_CONSTRUCTOR_P (w->fn))\n \t    source = TREE_TYPE (source);\n \t  if (warning (OPT_Wconversion, \"choosing %qD over %qD\", w->fn, l->fn)\n-\t      && warning (OPT_Wconversion, \"  for conversion from %qT to %qT\",\n+\t      && warning (OPT_Wconversion, \"  for conversion from %qH to %qI\",\n \t\t\t  source, w->second_conv->type)) \n \t    {\n \t      inform (input_location, \"  because conversion sequence for the argument is better\");\n@@ -10096,7 +10096,7 @@ perform_implicit_conversion_flags (tree type, tree expr,\n \t  else if (invalid_nonstatic_memfn_p (loc, expr, complain))\n \t    /* We gave an error.  */;\n \t  else\n-\t    error_at (loc, \"could not convert %qE from %qT to %qT\", expr,\n+\t    error_at (loc, \"could not convert %qE from %qH to %qI\", expr,\n \t\t      TREE_TYPE (expr), type);\n \t}\n       expr = error_mark_node;\n@@ -10412,11 +10412,11 @@ initialize_reference (tree type, tree expr,\n \t\t   && !TYPE_REF_IS_RVALUE (type)\n \t\t   && !lvalue_p (expr))\n \t    error_at (loc, \"invalid initialization of non-const reference of \"\n-\t\t      \"type %qT from an rvalue of type %qT\",\n+\t\t      \"type %qH from an rvalue of type %qI\",\n \t\t      type, TREE_TYPE (expr));\n \t  else\n \t    error_at (loc, \"invalid initialization of reference of type \"\n-\t\t      \"%qT from expression of type %qT\", type,\n+\t\t      \"%qH from expression of type %qI\", type,\n \t\t      TREE_TYPE (expr));\n \t}\n       return error_mark_node;"}, {"sha": "e8a7ee29465d089dbd0dc979259c37e1a8691ba2", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f012c8ef4b35dcee9b5a3807868d050812d5b3b9/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f012c8ef4b35dcee9b5a3807868d050812d5b3b9/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=f012c8ef4b35dcee9b5a3807868d050812d5b3b9", "patch": "@@ -86,7 +86,7 @@ cp_convert_to_pointer (tree type, tree expr, bool dofold,\n       if (!COMPLETE_TYPE_P (intype))\n \t{\n \t  if (complain & tf_error)\n-\t    error_at (loc, \"can%'t convert from incomplete type %qT to %qT\",\n+\t    error_at (loc, \"can%'t convert from incomplete type %qH to %qI\",\n \t\t      intype, type);\n \t  return error_mark_node;\n \t}\n@@ -96,7 +96,7 @@ cp_convert_to_pointer (tree type, tree expr, bool dofold,\n \t{\n \t  if ((complain & tf_error)\n \t      && rval == error_mark_node)\n-\t    error_at (loc, \"conversion of %qE from %qT to %qT is ambiguous\",\n+\t    error_at (loc, \"conversion of %qE from %qH to %qI is ambiguous\",\n \t\t      expr, intype, type);\n \t  return rval;\n \t}\n@@ -168,7 +168,7 @@ cp_convert_to_pointer (tree type, tree expr, bool dofold,\n       if (TYPE_PTRMEMFUNC_P (type))\n \t{\n \t  if (complain & tf_error)\n-\t    error_at (loc, \"cannot convert %qE from type %qT to type %qT\",\n+\t    error_at (loc, \"cannot convert %qE from type %qH to type %qI\",\n \t\t      expr, intype, type);\n \t  return error_mark_node;\n \t}\n@@ -195,7 +195,7 @@ cp_convert_to_pointer (tree type, tree expr, bool dofold,\n \t    }\n \t}\n       if (complain & tf_error)\n-\terror_at (loc, \"cannot convert %qE from type %qT to type %qT\",\n+\terror_at (loc, \"cannot convert %qE from type %qH to type %qI\",\n \t\t  expr, intype, type);\n       return error_mark_node;\n     }\n@@ -221,7 +221,7 @@ cp_convert_to_pointer (tree type, tree expr, bool dofold,\n   else if (TYPE_PTRMEM_P (type) && INTEGRAL_CODE_P (form))\n     {\n       if (complain & tf_error)\n-\terror_at (loc, \"invalid conversion from %qT to %qT\", intype, type);\n+\terror_at (loc, \"invalid conversion from %qH to %qI\", intype, type);\n       return error_mark_node;\n     }\n \n@@ -244,7 +244,7 @@ cp_convert_to_pointer (tree type, tree expr, bool dofold,\n     return instantiate_type (type, expr, complain);\n \n   if (complain & tf_error)\n-    error_at (loc, \"cannot convert %qE from type %qT to type %qT\",\n+    error_at (loc, \"cannot convert %qE from type %qH to type %qI\",\n \t      expr, intype, type);\n   return error_mark_node;\n }\n@@ -464,7 +464,7 @@ convert_to_reference (tree reftype, tree expr, int convtype,\n \t    && !at_least_as_qualified_p (ttl, ttr))\n \t  {\n \t    if (complain & tf_error)\n-\t      permerror (loc, \"conversion from %qT to %qT discards qualifiers\",\n+\t      permerror (loc, \"conversion from %qH to %qI discards qualifiers\",\n \t\t\t ttr, reftype);\n \t    else\n \t      return error_mark_node;\n@@ -514,7 +514,7 @@ convert_to_reference (tree reftype, tree expr, int convtype,\n     }\n \n   if (complain & tf_error)\n-    error_at (loc, \"cannot convert type %qT to type %qT\", intype, reftype);\n+    error_at (loc, \"cannot convert type %qH to type %qI\", intype, reftype);\n \n   return error_mark_node;\n }\n@@ -907,7 +907,7 @@ ocp_convert (tree type, tree expr, int convtype, int flags,\n       if (invalid_nonstatic_memfn_p (loc, expr, complain))\n \t/* We displayed the error message.  */;\n       else\n-\terror_at (loc, \"conversion from %qT to non-scalar type %qT requested\",\n+\terror_at (loc, \"conversion from %qH to non-scalar type %qI requested\",\n \t\t  TREE_TYPE (expr), type);\n     }\n   return error_mark_node;"}, {"sha": "ed67d14567be701c5e0d308e10cebd359af7d98a", "filename": "gcc/cp/error.c", "status": "modified", "additions": 450, "deletions": 3, "changes": 453, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f012c8ef4b35dcee9b5a3807868d050812d5b3b9/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f012c8ef4b35dcee9b5a3807868d050812d5b3b9/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=f012c8ef4b35dcee9b5a3807868d050812d5b3b9", "patch": "@@ -99,7 +99,50 @@ static void cp_diagnostic_starter (diagnostic_context *, diagnostic_info *);\n static void cp_print_error_function (diagnostic_context *, diagnostic_info *);\n \n static bool cp_printer (pretty_printer *, text_info *, const char *,\n-\t\t\tint, bool, bool, bool);\n+\t\t\tint, bool, bool, bool, bool, const char **);\n+\n+/* Struct for handling %H or %I, which require delaying printing the\n+   type until a postprocessing stage.  */\n+\n+struct deferred_printed_type\n+{\n+  deferred_printed_type ()\n+  : m_tree (NULL_TREE), m_buffer_ptr (NULL), m_verbose (false), m_quote (false)\n+  {}\n+\n+  deferred_printed_type (tree type, const char **buffer_ptr, bool verbose,\n+\t\t\t bool quote)\n+  : m_tree (type), m_buffer_ptr (buffer_ptr), m_verbose (verbose),\n+    m_quote (quote)\n+  {\n+    gcc_assert (type);\n+    gcc_assert (buffer_ptr);\n+  }\n+\n+  /* The tree is not GTY-marked: they are only non-NULL within a\n+     call to pp_format.  */\n+  tree m_tree;\n+  const char **m_buffer_ptr;\n+  bool m_verbose;\n+  bool m_quote;\n+};\n+\n+/* Subclass of format_postprocessor for the C++ frontend.\n+   This handles the %H and %I formatting codes, printing them\n+   in a postprocessing phase (since they affect each other).  */\n+\n+class cxx_format_postprocessor : public format_postprocessor\n+{\n+ public:\n+  cxx_format_postprocessor ()\n+  : m_type_a (), m_type_b ()\n+  {}\n+\n+  void handle (pretty_printer *pp) FINAL OVERRIDE;\n+\n+  deferred_printed_type m_type_a;\n+  deferred_printed_type m_type_b;\n+};\n \n /* CONTEXT->printer is a basic pretty printer that was constructed\n    presumably by diagnostic_initialize(), called early in the\n@@ -123,6 +166,7 @@ cxx_initialize_diagnostics (diagnostic_context *context)\n   diagnostic_starter (context) = cp_diagnostic_starter;\n   /* diagnostic_finalizer is already c_diagnostic_finalizer.  */\n   diagnostic_format_decoder (context) = cp_printer;\n+  pp->m_format_postprocessor = new cxx_format_postprocessor ();\n }\n \n /* Dump a scope, if deemed necessary.  */\n@@ -3563,6 +3607,388 @@ maybe_print_constexpr_context (diagnostic_context *context)\n     }\n }\n \f\n+\n+/* Return true iff TYPE_A and TYPE_B are template types that are\n+   meaningful to compare.  */\n+\n+static bool\n+comparable_template_types_p (tree type_a, tree type_b)\n+{\n+  if (!CLASS_TYPE_P (type_a))\n+    return false;\n+  if (!CLASS_TYPE_P (type_b))\n+    return false;\n+\n+  tree tinfo_a = TYPE_TEMPLATE_INFO (type_a);\n+  tree tinfo_b = TYPE_TEMPLATE_INFO (type_b);\n+  if (!tinfo_a || !tinfo_b)\n+    return false;\n+\n+  return TI_TEMPLATE (tinfo_a) == TI_TEMPLATE (tinfo_b);\n+}\n+\n+/* Start a new line indented by SPC spaces on PP.  */\n+\n+static void\n+newline_and_indent (pretty_printer *pp, int spc)\n+{\n+  pp_newline (pp);\n+  for (int i = 0; i < spc; i++)\n+    pp_space (pp);\n+}\n+\n+/* Generate a GC-allocated string for ARG, an expression or type.  */\n+\n+static const char *\n+arg_to_string (tree arg, bool verbose)\n+{\n+  if (TYPE_P (arg))\n+    return type_to_string (arg, verbose);\n+  else\n+    return expr_to_string (arg);\n+}\n+\n+/* Subroutine to type_to_string_with_compare and\n+   print_template_tree_comparison.\n+\n+   Print a representation of ARG (an expression or type) to PP,\n+   colorizing it as \"type-diff\" if PP->show_color.  */\n+\n+static void\n+print_nonequal_arg (pretty_printer *pp, tree arg, bool verbose)\n+{\n+  pp_printf (pp, \"%r%s%R\",\n+\t     \"type-diff\",\n+\t     (arg\n+\t      ? arg_to_string (arg, verbose)\n+\t      : G_(\"(no argument)\")));\n+}\n+\n+/* Recursively print template TYPE_A to PP, as compared to template TYPE_B.\n+\n+   The types must satisfy comparable_template_types_p.\n+\n+   If INDENT is 0, then this is equivalent to type_to_string (TYPE_A), but\n+   potentially colorizing/eliding in comparison with TYPE_B.\n+\n+   For example given types:\n+     vector<map<int,double>>\n+   and\n+     vector<map<int,float>>\n+   then the result on PP would be:\n+     vector<map<[...],double>>\n+   with type elision, and:\n+     vector<map<int,double>>\n+   without type elision.\n+\n+   In both cases the parts of TYPE that differ from PEER will be colorized\n+   if pp_show_color (pp) is true.  In the above example, this would be\n+   \"double\".\n+\n+   If INDENT is non-zero, then the types are printed in a tree-like form\n+   which shows both types.  In the above example, the result on PP would be:\n+\n+     vector<\n+       map<\n+         [...],\n+         [double != float]>>\n+\n+   and without type-elision would be:\n+\n+     vector<\n+       map<\n+         int,\n+         [double != float]>>\n+\n+   As before, the differing parts of the types are colorized if\n+   pp_show_color (pp) is true (\"double\" and \"float\" in this example).\n+\n+   Template arguments in which both types are using the default arguments\n+   are not printed; if at least one of the two types is using a non-default\n+   argument, then that argument is printed (or both arguments for the\n+   tree-like print format).  */\n+\n+static void\n+print_template_differences (pretty_printer *pp, tree type_a, tree type_b,\n+\t\t\t    bool verbose, int indent)\n+{\n+  if (indent)\n+    newline_and_indent (pp, indent);\n+\n+  tree tinfo_a = TYPE_TEMPLATE_INFO (type_a);\n+  tree tinfo_b = TYPE_TEMPLATE_INFO (type_b);\n+\n+  pp_printf (pp, \"%s<\",\n+\t     IDENTIFIER_POINTER (DECL_NAME (TI_TEMPLATE (tinfo_a))));\n+\n+  tree args_a = TI_ARGS (tinfo_a);\n+  tree args_b = TI_ARGS (tinfo_b);\n+  gcc_assert (TREE_CODE (args_a) == TREE_VEC);\n+  gcc_assert (TREE_CODE (args_b) == TREE_VEC);\n+  int flags = 0;\n+  int len_a = get_non_default_template_args_count (args_a, flags);\n+  args_a = INNERMOST_TEMPLATE_ARGS (args_a);\n+  int len_b = get_non_default_template_args_count (args_b, flags);\n+  args_b = INNERMOST_TEMPLATE_ARGS (args_b);\n+  /* Determine the maximum range of args for which non-default template args\n+     were used; beyond this, only default args (if any) were used, and so\n+     they will be equal from this point onwards.\n+     One of the two peers might have used default arguments within this\n+     range, but the other will be using non-default arguments, and so\n+     it's more readable to print both within this range, to highlight\n+     the differences.  */\n+  int len_max = MAX (len_a, len_b);\n+  gcc_assert (TREE_CODE (args_a) == TREE_VEC);\n+  gcc_assert (TREE_CODE (args_b) == TREE_VEC);\n+  for (int idx = 0; idx < len_max; idx++)\n+    {\n+      if (idx)\n+\tpp_character (pp, ',');\n+\n+      tree arg_a = TREE_VEC_ELT (args_a, idx);\n+      tree arg_b = TREE_VEC_ELT (args_b, idx);\n+      if (arg_a == arg_b)\n+\t{\n+\t  if (indent)\n+\t    newline_and_indent (pp, indent + 2);\n+\t  /* Can do elision here, printing \"[...]\".  */\n+\t  if (flag_elide_type)\n+\t    pp_string (pp, G_(\"[...]\"));\n+\t  else\n+\t    pp_string (pp, arg_to_string (arg_a, verbose));\n+\t}\n+      else\n+\t{\n+\t  int new_indent = indent ? indent + 2 : 0;\n+\t  if (comparable_template_types_p (arg_a, arg_b))\n+\t    print_template_differences (pp, arg_a, arg_b, verbose, new_indent);\n+\t  else\n+\t    if (indent)\n+\t      {\n+\t\tnewline_and_indent (pp, indent + 2);\n+\t\tpp_character (pp, '[');\n+\t\tprint_nonequal_arg (pp, arg_a, verbose);\n+\t\tpp_string (pp, \" != \");\n+\t\tprint_nonequal_arg (pp, arg_b, verbose);\n+\t\tpp_character (pp, ']');\n+\t      }\n+\t    else\n+\t      print_nonequal_arg (pp, arg_a, verbose);\n+\t}\n+    }\n+  pp_printf (pp, \">\");\n+}\n+\n+/* As type_to_string, but for a template, potentially colorizing/eliding\n+   in comparison with PEER.\n+   For example, if TYPE is map<int,double> and PEER is map<int,int>,\n+   then the resulting string would be:\n+     map<[...],double>\n+   with type elision, and:\n+     map<int,double>\n+   without type elision.\n+\n+   In both cases the parts of TYPE that differ from PEER will be colorized\n+   if SHOW_COLOR is true.  In the above example, this would be \"double\".\n+\n+   Template arguments in which both types are using the default arguments\n+   are not printed; if at least one of the two types is using a non-default\n+   argument, then both arguments are printed.\n+\n+   The resulting string is in a GC-allocated buffer.  */\n+\n+static const char *\n+type_to_string_with_compare (tree type, tree peer, bool verbose,\n+\t\t\t     bool show_color)\n+{\n+  pretty_printer inner_pp;\n+  pretty_printer *pp = &inner_pp;\n+  pp_show_color (pp) = show_color;\n+\n+  print_template_differences (pp, type, peer, verbose, 0);\n+  return pp_ggc_formatted_text (pp);\n+}\n+\n+/* Recursively print a tree-like comparison of TYPE_A and TYPE_B to PP,\n+   indented by INDENT spaces.\n+\n+   For example given types:\n+\n+     vector<map<int,double>>\n+\n+   and\n+\n+     vector<map<double,float>>\n+\n+   the output with type elision would be:\n+\n+     vector<\n+       map<\n+         [...],\n+         [double != float]>>\n+\n+   and without type-elision would be:\n+\n+     vector<\n+       map<\n+         int,\n+         [double != float]>>\n+\n+   TYPE_A and TYPE_B must both be comparable template types\n+   (as per comparable_template_types_p).\n+\n+   Template arguments in which both types are using the default arguments\n+   are not printed; if at least one of the two types is using a non-default\n+   argument, then both arguments are printed.  */\n+\n+static void\n+print_template_tree_comparison (pretty_printer *pp, tree type_a, tree type_b,\n+\t\t\t\tbool verbose, int indent)\n+{\n+  print_template_differences (pp, type_a, type_b, verbose, indent);\n+}\n+\n+/* Subroutine for use in a format_postprocessor::handle\n+   implementation.  Adds a chunk to the end of\n+   formatted output, so that it will be printed\n+   by pp_output_formatted_text.  */\n+\n+static void\n+append_formatted_chunk (pretty_printer *pp, const char *content)\n+{\n+  output_buffer *buffer = pp_buffer (pp);\n+  struct chunk_info *chunk_array = buffer->cur_chunk_array;\n+  const char **args = chunk_array->args;\n+\n+  unsigned int chunk_idx;\n+  for (chunk_idx = 0; args[chunk_idx]; chunk_idx++)\n+    ;\n+  args[chunk_idx++] = content;\n+  args[chunk_idx] = NULL;\n+}\n+\n+/* Create a copy of CONTENT, with quotes added, and,\n+   potentially, with colorization.\n+   No escaped is performed on CONTENT.\n+   The result is in a GC-allocated buffer. */\n+\n+static const char *\n+add_quotes (const char *content, bool show_color)\n+{\n+  pretty_printer tmp_pp;\n+  pp_show_color (&tmp_pp) = show_color;\n+\n+  /* We have to use \"%<%s%>\" rather than \"%qs\" here in order to avoid\n+     quoting colorization bytes within the results.  */\n+  pp_printf (&tmp_pp, \"%<%s%>\", content);\n+\n+  return pp_ggc_formatted_text (&tmp_pp);\n+}\n+\n+/* If we had %H and %I, and hence deferred printing them,\n+   print them now, storing the result into the chunk_info\n+   for pp_format.  Quote them if 'q' was provided.\n+   Also print the difference in tree form, adding it as\n+   an additional chunk.  */\n+\n+void\n+cxx_format_postprocessor::handle (pretty_printer *pp)\n+{\n+  /* If we have one of %H and %I, the other should have\n+     been present.  */\n+  if (m_type_a.m_tree || m_type_b.m_tree)\n+    {\n+      /* Avoid reentrancy issues by working with a copy of\n+\t m_type_a and m_type_b, resetting them now.  */\n+      deferred_printed_type type_a = m_type_a;\n+      deferred_printed_type type_b = m_type_b;\n+      m_type_a = deferred_printed_type ();\n+      m_type_b = deferred_printed_type ();\n+\n+      gcc_assert (type_a.m_buffer_ptr);\n+      gcc_assert (type_b.m_buffer_ptr);\n+\n+      bool show_color = pp_show_color (pp);\n+\n+      const char *type_a_text;\n+      const char *type_b_text;\n+\n+      if (comparable_template_types_p (type_a.m_tree, type_b.m_tree))\n+\t{\n+\t  type_a_text\n+\t    = type_to_string_with_compare (type_a.m_tree, type_b.m_tree,\n+\t\t\t\t\t   type_a.m_verbose, show_color);\n+\t  type_b_text\n+\t    = type_to_string_with_compare (type_b.m_tree, type_a.m_tree,\n+\t\t\t\t\t   type_b.m_verbose, show_color);\n+\n+\t  if (flag_diagnostics_show_template_tree)\n+\t    {\n+\t      pretty_printer inner_pp;\n+\t      pp_show_color (&inner_pp) = pp_show_color (pp);\n+\t      print_template_tree_comparison\n+\t\t(&inner_pp, type_a.m_tree, type_b.m_tree, type_a.m_verbose, 2);\n+\t      append_formatted_chunk (pp, pp_ggc_formatted_text (&inner_pp));\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  /* If the types were not comparable, they are printed normally,\n+\t     and no difference tree is printed.  */\n+\t  type_a_text = type_to_string (type_a.m_tree, type_a.m_verbose);\n+\t  type_b_text = type_to_string (type_b.m_tree, type_b.m_verbose);\n+\t}\n+\n+      if (type_a.m_quote)\n+\ttype_a_text = add_quotes (type_a_text, show_color);\n+      *type_a.m_buffer_ptr = type_a_text;\n+\n+       if (type_b.m_quote)\n+\ttype_b_text = add_quotes (type_b_text, show_color);\n+      *type_b.m_buffer_ptr = type_b_text;\n+   }\n+}\n+\n+/* Subroutine for handling %H and %I, to support i18n of messages like:\n+\n+    error_at (loc, \"could not convert %qE from %qH to %qI\",\n+\t       expr, type_a, type_b);\n+\n+   so that we can print things like:\n+\n+     could not convert 'foo' from 'map<int,double>' to 'map<int,int>'\n+\n+   and, with type-elision:\n+\n+     could not convert 'foo' from 'map<[...],double>' to 'map<[...],int>'\n+\n+   (with color-coding of the differences between the types).\n+\n+   The %H and %I format codes are peers: both must be present,\n+   and they affect each other.  Hence to handle them, we must\n+   delay printing until we have both, deferring the printing to\n+   pretty_printer's m_format_postprocessor hook.\n+\n+   This is called in phase 2 of pp_format, when it is accumulating\n+   a series of formatted chunks.  We stash the location of the chunk\n+   we're meant to have written to, so that we can write to it in the\n+   m_format_postprocessor hook.\n+\n+   We also need to stash whether a 'q' prefix was provided (the QUOTE\n+   param)  so that we can add the quotes when writing out the delayed\n+   chunk.  */\n+\n+static void\n+defer_phase_2_of_type_diff (deferred_printed_type *deferred,\n+\t\t\t    tree type, const char **buffer_ptr,\n+\t\t\t    bool verbose, bool quote)\n+{\n+  gcc_assert (deferred->m_tree == NULL_TREE);\n+  gcc_assert (deferred->m_buffer_ptr == NULL);\n+  *deferred = deferred_printed_type (type, buffer_ptr, verbose, quote);\n+}\n+\n+\n /* Called from output_format -- during diagnostic message processing --\n    to handle C++ specific format specifier with the following meanings:\n    %A   function argument-list.\n@@ -3577,11 +4003,18 @@ maybe_print_constexpr_context (diagnostic_context *context)\n    %S   substitution (template + args)\n    %T   type.\n    %V   cv-qualifier.\n-   %X   exception-specification.  */\n+   %X   exception-specification.\n+   %H   type difference (from)\n+   %I   type difference (to).  */\n static bool\n cp_printer (pretty_printer *pp, text_info *text, const char *spec,\n-\t    int precision, bool wide, bool set_locus, bool verbose)\n+\t    int precision, bool wide, bool set_locus, bool verbose,\n+\t    bool quoted, const char **buffer_ptr)\n {\n+  gcc_assert (pp->m_format_postprocessor);\n+  cxx_format_postprocessor *postprocessor\n+    = static_cast <cxx_format_postprocessor *> (pp->m_format_postprocessor);\n+\n   const char *result;\n   tree t = NULL;\n #define next_tree    (t = va_arg (*text->args_ptr, tree))\n@@ -3627,6 +4060,20 @@ cp_printer (pretty_printer *pp, text_info *text, const char *spec,\n       percent_K_format (text);\n       return true;\n \n+    case 'H':\n+      {\n+\tdefer_phase_2_of_type_diff (&postprocessor->m_type_a, next_tree,\n+\t\t\t\t    buffer_ptr, verbose, quoted);\n+\treturn true;\n+      }\n+\n+    case 'I':\n+      {\n+\tdefer_phase_2_of_type_diff (&postprocessor->m_type_b, next_tree,\n+\t\t\t\t    buffer_ptr, verbose, quoted);\n+\treturn true;\n+      }\n+\n     default:\n       return false;\n     }"}, {"sha": "c657b3b9812ec34fd6989fed51a770bb15474e3a", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f012c8ef4b35dcee9b5a3807868d050812d5b3b9/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f012c8ef4b35dcee9b5a3807868d050812d5b3b9/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=f012c8ef4b35dcee9b5a3807868d050812d5b3b9", "patch": "@@ -5040,7 +5040,7 @@ cp_build_binary_op (location_t location,\n       result_type = cp_common_type (type0, type1);\n       if (complain & tf_warning)\n \tdo_warn_double_promotion (result_type, type0, type1,\n-\t\t\t\t  \"implicit conversion from %qT to %qT \"\n+\t\t\t\t  \"implicit conversion from %qH to %qI \"\n \t\t\t\t  \"to match other operand of binary \"\n \t\t\t\t  \"expression\",\n \t\t\t\t  location);\n@@ -7076,7 +7076,7 @@ convert_member_func_to_ptr (tree type, tree expr, tsubst_flags_t complain)\n \n   if (pedantic || warn_pmf2ptr)\n     pedwarn (input_location, pedantic ? OPT_Wpedantic : OPT_Wpmf_conversions,\n-\t     \"converting from %qT to %qT\", intype, type);\n+\t     \"converting from %qH to %qI\", intype, type);\n \n   if (TREE_CODE (intype) == METHOD_TYPE)\n     expr = build_addr_func (expr, complain);\n@@ -7202,7 +7202,7 @@ build_reinterpret_cast_1 (tree type, tree expr, bool c_cast_p,\n       if (TYPE_PRECISION (type) < TYPE_PRECISION (intype))\n         {\n           if (complain & tf_error)\n-            permerror (input_location, \"cast from %qT to %qT loses precision\",\n+            permerror (input_location, \"cast from %qH to %qI loses precision\",\n                        intype, type);\n           else\n             return error_mark_node;\n@@ -7242,7 +7242,7 @@ build_reinterpret_cast_1 (tree type, tree expr, bool c_cast_p,\n \t  && COMPLETE_TYPE_P (TREE_TYPE (type))\n \t  && COMPLETE_TYPE_P (TREE_TYPE (intype))\n \t  && TYPE_ALIGN (TREE_TYPE (type)) > TYPE_ALIGN (TREE_TYPE (intype)))\n-\twarning (OPT_Wcast_align, \"cast from %qT to %qT \"\n+\twarning (OPT_Wcast_align, \"cast from %qH to %qI \"\n                  \"increases required alignment of target type\", intype, type);\n \n       /* We need to strip nops here, because the front end likes to\n@@ -8569,33 +8569,33 @@ convert_for_assignment (tree type, tree rhs,\n \t\t    return r;\n \t\t}\n \t      else if (fndecl)\n-\t\terror (\"cannot convert %qT to %qT for argument %qP to %qD\",\n+\t\terror (\"cannot convert %qH to %qI for argument %qP to %qD\",\n \t\t       rhstype, type, parmnum, fndecl);\n \t      else\n \t\tswitch (errtype)\n \t\t  {\n \t\t    case ICR_DEFAULT_ARGUMENT:\n-\t\t      error (\"cannot convert %qT to %qT in default argument\",\n+\t\t      error (\"cannot convert %qH to %qI in default argument\",\n \t\t\t     rhstype, type);\n \t\t      break;\n \t\t    case ICR_ARGPASS:\n-\t\t      error (\"cannot convert %qT to %qT in argument passing\",\n+\t\t      error (\"cannot convert %qH to %qI in argument passing\",\n \t\t\t     rhstype, type);\n \t\t      break;\n \t\t    case ICR_CONVERTING:\n-\t\t      error (\"cannot convert %qT to %qT\",\n+\t\t      error (\"cannot convert %qH to %qI\",\n \t\t\t     rhstype, type);\n \t\t      break;\n \t\t    case ICR_INIT:\n-\t\t      error (\"cannot convert %qT to %qT in initialization\",\n+\t\t      error (\"cannot convert %qH to %qI in initialization\",\n \t\t\t     rhstype, type);\n \t\t      break;\n \t\t    case ICR_RETURN:\n-\t\t      error (\"cannot convert %qT to %qT in return\",\n+\t\t      error (\"cannot convert %qH to %qI in return\",\n \t\t\t     rhstype, type);\n \t\t      break;\n \t\t    case ICR_ASSIGN:\n-\t\t      error (\"cannot convert %qT to %qT in assignment\",\n+\t\t      error (\"cannot convert %qH to %qI in assignment\",\n \t\t\t     rhstype, type);\n \t\t      break;\n \t\t    default:"}, {"sha": "4623d6d9197e478129765cf28a964fa4235c430c", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f012c8ef4b35dcee9b5a3807868d050812d5b3b9/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f012c8ef4b35dcee9b5a3807868d050812d5b3b9/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=f012c8ef4b35dcee9b5a3807868d050812d5b3b9", "patch": "@@ -955,7 +955,7 @@ check_narrowing (tree type, tree init, tsubst_flags_t complain)\n \t{\n \t  if (complain & tf_warning)\n \t    warning_at (loc, OPT_Wnarrowing, \"narrowing conversion of %qE \"\n-\t\t\t\"from %qT to %qT inside { } is ill-formed in C++11\",\n+\t\t\t\"from %qH to %qI inside { } is ill-formed in C++11\",\n \t\t\tinit, ftype, type);\n \t  ok = true;\n \t}\n@@ -966,7 +966,7 @@ check_narrowing (tree type, tree init, tsubst_flags_t complain)\n \t      if ((!almost_ok || pedantic)\n \t\t  && pedwarn (loc, OPT_Wnarrowing,\n \t\t\t      \"narrowing conversion of %qE \"\n-\t\t\t      \"from %qT to %qT inside { }\",\n+\t\t\t      \"from %qH to %qI inside { }\",\n \t\t\t      init, ftype, type)\n \t\t  && almost_ok)\n \t\tinform (loc, \" the expression has a constant value but is not \"\n@@ -979,7 +979,7 @@ check_narrowing (tree type, tree init, tsubst_flags_t complain)\n \t  int savederrorcount = errorcount;\n \t  global_dc->pedantic_errors = 1;\n \t  pedwarn (loc, OPT_Wnarrowing,\n-\t\t   \"narrowing conversion of %qE from %qT to %qT \"\n+\t\t   \"narrowing conversion of %qE from %qH to %qI \"\n \t\t   \"inside { }\", init, ftype, type);\n \t  if (errorcount == savederrorcount)\n \t    ok = true;"}, {"sha": "6adb872146b698177f8d266f4fd7ad0b68eb413b", "filename": "gcc/diagnostic-color.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f012c8ef4b35dcee9b5a3807868d050812d5b3b9/gcc%2Fdiagnostic-color.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f012c8ef4b35dcee9b5a3807868d050812d5b3b9/gcc%2Fdiagnostic-color.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic-color.c?ref=f012c8ef4b35dcee9b5a3807868d050812d5b3b9", "patch": "@@ -174,6 +174,7 @@ static struct color_cap color_dict[] =\n   { \"diff-hunk\", SGR_SEQ (COLOR_FG_CYAN), 9, false },\n   { \"diff-delete\", SGR_SEQ (COLOR_FG_RED), 11, false },\n   { \"diff-insert\", SGR_SEQ (COLOR_FG_GREEN), 11, false },\n+  { \"type-diff\", SGR_SEQ (COLOR_BOLD COLOR_SEPARATOR COLOR_FG_GREEN), 9, false },\n   { NULL, NULL, 0, false }\n };\n \n@@ -204,8 +205,9 @@ colorize_stop (bool show_color)\n /* Parse GCC_COLORS.  The default would look like:\n    GCC_COLORS='error=01;31:warning=01;35:note=01;36:\\\n    range1=32:range2=34:locus=01:quote=01:\\\n-   fixit-insert=32:fixit-delete=31'\\\n-   diff-filename=01:diff-hunk=32:diff-delete=31:diff-insert=32'\n+   fixit-insert=32:fixit-delete=31:'\\\n+   diff-filename=01:diff-hunk=32:diff-delete=31:diff-insert=32:\\\n+   type-diff=01;32'\n    No character escaping is needed or supported.  */\n static bool\n parse_gcc_colors (void)"}, {"sha": "20805df884d11a65da35a2922f2a24ca25c33335", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 49, "deletions": 1, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f012c8ef4b35dcee9b5a3807868d050812d5b3b9/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f012c8ef4b35dcee9b5a3807868d050812d5b3b9/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=f012c8ef4b35dcee9b5a3807868d050812d5b3b9", "patch": "@@ -251,6 +251,7 @@ Objective-C and Objective-C++ Dialects}.\n -fdiagnostics-color=@r{[}auto@r{|}never@r{|}always@r{]}  @gol\n -fno-diagnostics-show-option  -fno-diagnostics-show-caret @gol\n -fdiagnostics-parseable-fixits  -fdiagnostics-generate-patch @gol\n+-fdiagnostics-show-template-tree -fno-elide-type @gol\n -fno-show-column}\n \n @item Warning Options\n@@ -3448,7 +3449,8 @@ The default @env{GCC_COLORS} is\n @smallexample\n error=01;31:warning=01;35:note=01;36:range1=32:range2=34:locus=01:\\\n quote=01:fixit-insert=32:fixit-delete=31:\\\n-diff-filename=01:diff-hunk=32:diff-delete=31:diff-insert=32\n+diff-filename=01:diff-hunk=32:diff-delete=31:diff-insert=32:\\\n+type-diff=01;32\n @end smallexample\n @noindent\n where @samp{01;31} is bold red, @samp{01;35} is bold magenta,\n@@ -3512,6 +3514,11 @@ SGR substring for deleted lines within generated patches.\n @item diff-insert=\n @vindex diff-insert GCC_COLORS @r{capability}\n SGR substring for inserted lines within generated patches.\n+\n+@item type-diff=\n+@vindex type-diff GCC_COLORS @r{capability}\n+SGR substring for highlighting mismatching types within template\n+arguments in the C++ frontend.\n @end table\n \n @item -fno-diagnostics-show-option\n@@ -3584,6 +3591,47 @@ are printed.  For example:\n The diff may or may not be colorized, following the same rules\n as for diagnostics (see @option{-fdiagnostics-color}).\n \n+@item -fdiagnostics-show-template-tree\n+@opindex fdiagnostics-show-template-tree\n+\n+In the C++ frontend, when printing diagnostics showing mismatching\n+template types, such as:\n+\n+@smallexample\n+  could not convert 'std::map<int, std::vector<double> >()'\n+    from 'map<[...],vector<double>>' to 'map<[...],vector<float>>\n+@end smallexample\n+\n+the @option{-fdiagnostics-show-template-tree} flag enables printing a\n+tree-like structure showing the common and differing parts of the types,\n+such as:\n+\n+@smallexample\n+  map<\n+    [...],\n+    vector<\n+      [double != float]>>\n+@end smallexample\n+\n+The parts that differ are highlighted with color (``double'' and\n+``float'' in this case).\n+\n+@item -fno-elide-type\n+@opindex fno-elide-type\n+@opindex felide-type\n+By default when the C++ frontend prints diagnostics showing mismatching\n+template types, common parts of the types are printed as ``[...]'' to\n+simplify the error message.  For example:\n+\n+@smallexample\n+  could not convert 'std::map<int, std::vector<double> >()'\n+    from 'map<[...],vector<double>>' to 'map<[...],vector<float>>\n+@end smallexample\n+\n+Specifying the @option{-fno-elide-type} flag suppresses that behavior.\n+This flag also affects the output of the\n+@option{-fdiagnostics-show-template-tree} flag.\n+\n @item -fno-show-column\n @opindex fno-show-column\n Do not print column numbers in diagnostics.  This may be necessary if"}, {"sha": "08c3ea7b17298e4fc705299406f34abd5259d554", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f012c8ef4b35dcee9b5a3807868d050812d5b3b9/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f012c8ef4b35dcee9b5a3807868d050812d5b3b9/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=f012c8ef4b35dcee9b5a3807868d050812d5b3b9", "patch": "@@ -1,3 +1,8 @@\n+2017-05-30  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* error.c (gfc_format_decoder): Update for new bool and\n+\tconst char ** params.\n+\n 2017-05-29  Thomas Koenig  <tkoenig@gcc.gnu.org>\n \n \tPR fortran/37131"}, {"sha": "3ad1cf9ff25c08960f528c609198cab5e9e13e8d", "filename": "gcc/fortran/error.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f012c8ef4b35dcee9b5a3807868d050812d5b3b9/gcc%2Ffortran%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f012c8ef4b35dcee9b5a3807868d050812d5b3b9/gcc%2Ffortran%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ferror.c?ref=f012c8ef4b35dcee9b5a3807868d050812d5b3b9", "patch": "@@ -917,7 +917,8 @@ gfc_notify_std (int std, const char *gmsgid, ...)\n */\n static bool\n gfc_format_decoder (pretty_printer *pp, text_info *text, const char *spec,\n-\t\t    int precision, bool wide, bool set_locus, bool hash)\n+\t\t    int precision, bool wide, bool set_locus, bool hash,\n+\t\t    bool quoted, const char **buffer_ptr)\n {\n   switch (*spec)\n     {\n@@ -948,7 +949,7 @@ gfc_format_decoder (pretty_printer *pp, text_info *text, const char *spec,\n \t etc. diagnostics can use the FE printer while the FE is still\n \t active.  */\n       return default_tree_printer (pp, text, spec, precision, wide,\n-\t\t\t\t   set_locus, hash);\n+\t\t\t\t   set_locus, hash, quoted, buffer_ptr);\n     }\n }\n "}, {"sha": "570dec77dc1b9df56bddb320c543ab2201c9798c", "filename": "gcc/pretty-print.c", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f012c8ef4b35dcee9b5a3807868d050812d5b3b9/gcc%2Fpretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f012c8ef4b35dcee9b5a3807868d050812d5b3b9/gcc%2Fpretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpretty-print.c?ref=f012c8ef4b35dcee9b5a3807868d050812d5b3b9", "patch": "@@ -677,7 +677,8 @@ pp_format (pretty_printer *pp, text_info *text)\n \n \t    gcc_assert (pp_format_decoder (pp));\n \t    ok = pp_format_decoder (pp) (pp, text, p,\n-\t\t\t\t\t precision, wide, plus, hash);\n+\t\t\t\t\t precision, wide, plus, hash, quote,\n+\t\t\t\t\t formatters[argno]);\n \t    gcc_assert (ok);\n \t  }\n \t}\n@@ -696,6 +697,11 @@ pp_format (pretty_printer *pp, text_info *text)\n     for (; argno < PP_NL_ARGMAX; argno++)\n       gcc_assert (!formatters[argno]);\n \n+  /* If the client supplied a postprocessing object, call its \"handle\"\n+     hook here.  */\n+  if (pp->m_format_postprocessor)\n+    pp->m_format_postprocessor->handle (pp);\n+\n   /* Revert to normal obstack and wrapping mode.  */\n   buffer->obstack = &buffer->formatted_obstack;\n   buffer->line_length = 0;\n@@ -847,6 +853,7 @@ pretty_printer::pretty_printer (const char *p, int l)\n     indent_skip (),\n     wrapping (),\n     format_decoder (),\n+    m_format_postprocessor (NULL),\n     emitted_prefix (),\n     need_newline (),\n     translate_identifiers (true),\n@@ -860,6 +867,8 @@ pretty_printer::pretty_printer (const char *p, int l)\n \n pretty_printer::~pretty_printer ()\n {\n+  if (m_format_postprocessor)\n+    delete m_format_postprocessor;\n   buffer->~output_buffer ();\n   XDELETE (buffer);\n }"}, {"sha": "40e56a35d93e7c7db0332dba203d28c432290d88", "filename": "gcc/pretty-print.h", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f012c8ef4b35dcee9b5a3807868d050812d5b3b9/gcc%2Fpretty-print.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f012c8ef4b35dcee9b5a3807868d050812d5b3b9/gcc%2Fpretty-print.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpretty-print.h?ref=f012c8ef4b35dcee9b5a3807868d050812d5b3b9", "patch": "@@ -180,11 +180,20 @@ struct pp_wrapping_mode_t\n    A client-supplied formatter returns true if everything goes well,\n    otherwise it returns false.  */\n typedef bool (*printer_fn) (pretty_printer *, text_info *, const char *,\n-\t\t\t    int, bool, bool, bool);\n+\t\t\t    int, bool, bool, bool, bool, const char **);\n \n /* Client supplied function used to decode formats.  */\n #define pp_format_decoder(PP) (PP)->format_decoder\n \n+/* Base class for an optional client-supplied object for doing additional\n+   processing between stages 2 and 3 of formatted printing.  */\n+class format_postprocessor\n+{\n+ public:\n+  virtual ~format_postprocessor () {}\n+  virtual void handle (pretty_printer *) = 0;\n+};\n+\n /* TRUE if a newline character needs to be added before further\n    formatting.  */\n #define pp_needs_newline(PP)  (PP)->need_newline\n@@ -239,9 +248,16 @@ struct pretty_printer\n      If the BUFFER needs additional characters from the format string, it\n      should advance the TEXT->format_spec as it goes.  When FORMAT_DECODER\n      returns, TEXT->format_spec should point to the last character processed.\n-  */\n+     The QUOTE and BUFFER_PTR are passed in, to allow for deferring-handling\n+     of format codes (e.g. %H and %I in the C++ frontend).  */\n   printer_fn format_decoder;\n \n+  /* If non-NULL, this is called by pp_format once after all format codes\n+     have been processed, to allow for client-specific postprocessing.\n+     This is used by the C++ frontend for handling the %H and %I\n+     format codes (which interract with each other).  */\n+  format_postprocessor *m_format_postprocessor;\n+\n   /* Nonzero if current PREFIX was emitted at least once.  */\n   bool emitted_prefix;\n "}, {"sha": "8fbbfcece6bfaa92a9eb3ea0c32b0bca6c180159", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f012c8ef4b35dcee9b5a3807868d050812d5b3b9/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f012c8ef4b35dcee9b5a3807868d050812d5b3b9/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f012c8ef4b35dcee9b5a3807868d050812d5b3b9", "patch": "@@ -1,3 +1,16 @@\n+2017-05-30  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* g++.dg/plugin/plugin.exp (plugin_test_list): Add...\n+\t* g++.dg/plugin/show-template-tree-color-no-elide-type.C: New\n+\ttest case.\n+\t* g++.dg/plugin/show-template-tree-color.C: New test case.\n+\t* g++.dg/plugin/show_template_tree_color_plugin.c: New plugin.\n+\t* g++.dg/template/show-template-tree-2.C: New test case.\n+\t* g++.dg/template/show-template-tree-3.C: New test case.\n+\t* g++.dg/template/show-template-tree-4.C: New test case.\n+\t* g++.dg/template/show-template-tree-no-elide-type.C: New test case.\n+\t* g++.dg/template/show-template-tree.C: New test case.\n+\n 2017-05-30  Segher Boessenkool  <segher@kernel.crashing.org>\n \n \t* gcc.target/powerpc/shift-dot.c: Delete -mgen-cell-microcode from"}, {"sha": "94ebe933798b9c0debcc371c41df23b628e72ff3", "filename": "gcc/testsuite/g++.dg/plugin/plugin.exp", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f012c8ef4b35dcee9b5a3807868d050812d5b3b9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fplugin%2Fplugin.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f012c8ef4b35dcee9b5a3807868d050812d5b3b9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fplugin%2Fplugin.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fplugin%2Fplugin.exp?ref=f012c8ef4b35dcee9b5a3807868d050812d5b3b9", "patch": "@@ -65,6 +65,9 @@ set plugin_test_list [list \\\n     { def_plugin.c def-plugin-test.C } \\\n     { ../../gcc.dg/plugin/diagnostic_plugin_test_tree_expression_range.c \\\n \t  diagnostic-test-expressions-1.C } \\\n+    { show_template_tree_color_plugin.c \\\n+    \t  show-template-tree-color.C \\\n+    \t  show-template-tree-color-no-elide-type.C } \\\n ]\n \n foreach plugin_test $plugin_test_list {"}, {"sha": "cab0359f240d93f39a398cbfcdbdd4b01e740736", "filename": "gcc/testsuite/g++.dg/plugin/show-template-tree-color-no-elide-type.C", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f012c8ef4b35dcee9b5a3807868d050812d5b3b9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fplugin%2Fshow-template-tree-color-no-elide-type.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f012c8ef4b35dcee9b5a3807868d050812d5b3b9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fplugin%2Fshow-template-tree-color-no-elide-type.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fplugin%2Fshow-template-tree-color-no-elide-type.C?ref=f012c8ef4b35dcee9b5a3807868d050812d5b3b9", "patch": "@@ -0,0 +1,30 @@\n+/* Verify colorization of the output of -fdiagnostics-show-template-tree,\n+   and within the %H and %I format codes.\n+   Doing so requires a plugin; see the comments in the plugin for the\n+   rationale.  */\n+\n+// { dg-options \"-fdiagnostics-show-template-tree -fdiagnostics-color=always -fno-elide-type\" }\n+\n+template<typename> struct vector {};\n+template<typename, typename> struct map {};\n+\n+void fn_1(vector<int>);\n+void fn_2(map<int, int>);\n+\n+void test ()\n+{\n+  fn_1 (vector<double> ());\n+  /* { dg-begin-multiline-output \"\" }\n+could not convert '\u001b[01m\u001b[Kvector<double>()\u001b[m\u001b[K' from '\u001b[01m\u001b[Kvector<\u001b[01;32m\u001b[Kdouble\u001b[m\u001b[K>\u001b[m\u001b[K' to '\u001b[01m\u001b[Kvector<\u001b[01;32m\u001b[Kint\u001b[m\u001b[K>\u001b[m\u001b[K'\n+  vector<\n+    [\u001b[01;32m\u001b[Kdouble\u001b[m\u001b[K != \u001b[01;32m\u001b[Kint\u001b[m\u001b[K]>\n+     { dg-end-multiline-output \"\" } */\n+\n+  fn_2 (map<int, double>());\n+  /* { dg-begin-multiline-output \"\" }\n+could not convert '\u001b[01m\u001b[Kmap<int, double>()\u001b[m\u001b[K' from '\u001b[01m\u001b[Kmap<int,\u001b[01;32m\u001b[Kdouble\u001b[m\u001b[K>\u001b[m\u001b[K' to '\u001b[01m\u001b[Kmap<int,\u001b[01;32m\u001b[Kint\u001b[m\u001b[K>\u001b[m\u001b[K'\n+  map<\n+    int,\n+    [\u001b[01;32m\u001b[Kdouble\u001b[m\u001b[K != \u001b[01;32m\u001b[Kint\u001b[m\u001b[K]>\n+     { dg-end-multiline-output \"\" } */\n+}"}, {"sha": "eb99a3ed8dac2c1735270f9a3ad7c1f14a7dba67", "filename": "gcc/testsuite/g++.dg/plugin/show-template-tree-color.C", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f012c8ef4b35dcee9b5a3807868d050812d5b3b9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fplugin%2Fshow-template-tree-color.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f012c8ef4b35dcee9b5a3807868d050812d5b3b9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fplugin%2Fshow-template-tree-color.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fplugin%2Fshow-template-tree-color.C?ref=f012c8ef4b35dcee9b5a3807868d050812d5b3b9", "patch": "@@ -0,0 +1,30 @@\n+/* Verify colorization of the output of -fdiagnostics-show-template-tree,\n+   and within the %H and %I format codes.\n+   Doing so requires a plugin; see the comments in the plugin for the\n+   rationale.  */\n+\n+// { dg-options \"-fdiagnostics-show-template-tree -fdiagnostics-color=always\" }\n+\n+template<typename> struct vector {};\n+template<typename, typename> struct map {};\n+\n+void fn_1(vector<int>);\n+void fn_2(map<int, int>);\n+\n+void test ()\n+{\n+  fn_1 (vector<double> ());\n+  /* { dg-begin-multiline-output \"\" }\n+could not convert '\u001b[01m\u001b[Kvector<double>()\u001b[m\u001b[K' from '\u001b[01m\u001b[Kvector<\u001b[01;32m\u001b[Kdouble\u001b[m\u001b[K>\u001b[m\u001b[K' to '\u001b[01m\u001b[Kvector<\u001b[01;32m\u001b[Kint\u001b[m\u001b[K>\u001b[m\u001b[K'\n+  vector<\n+    [\u001b[01;32m\u001b[Kdouble\u001b[m\u001b[K != \u001b[01;32m\u001b[Kint\u001b[m\u001b[K]>\n+     { dg-end-multiline-output \"\" } */\n+\n+  fn_2 (map<int, double>());\n+  /* { dg-begin-multiline-output \"\" }\n+could not convert '\u001b[01m\u001b[Kmap<int, double>()\u001b[m\u001b[K' from '\u001b[01m\u001b[Kmap<[...],\u001b[01;32m\u001b[Kdouble\u001b[m\u001b[K>\u001b[m\u001b[K' to '\u001b[01m\u001b[Kmap<[...],\u001b[01;32m\u001b[Kint\u001b[m\u001b[K>\u001b[m\u001b[K'\n+  map<\n+    [...],\n+    [\u001b[01;32m\u001b[Kdouble\u001b[m\u001b[K != \u001b[01;32m\u001b[Kint\u001b[m\u001b[K]>\n+     { dg-end-multiline-output \"\" } */\n+}"}, {"sha": "af568bf622a73cd12ee226c9f8294670c70cd960", "filename": "gcc/testsuite/g++.dg/plugin/show_template_tree_color_plugin.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f012c8ef4b35dcee9b5a3807868d050812d5b3b9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fplugin%2Fshow_template_tree_color_plugin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f012c8ef4b35dcee9b5a3807868d050812d5b3b9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fplugin%2Fshow_template_tree_color_plugin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fplugin%2Fshow_template_tree_color_plugin.c?ref=f012c8ef4b35dcee9b5a3807868d050812d5b3b9", "patch": "@@ -0,0 +1,38 @@\n+/* We want to verify the colorized output of cxx_format_postprocessor,\n+   but turning on colorization for everything confuses \"dg-error\" etc.\n+   The color codes in the generated messages would also need escaping\n+   for use within dg-error.\n+\n+   Hence the simplest approach is to provide a custom diagnostic_starter_fn,\n+   which does nothing.\n+\n+   The resulting messages lack the \"FILENAME:LINE:COL: error: \" prefix\n+   and can thus be tested using dg-begin/end-multiline-output.  */\n+\n+/* { dg-options \"-O\" } */\n+\n+#include \"gcc-plugin.h\"\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"plugin-version.h\"\n+#include \"diagnostic.h\"\n+\n+int plugin_is_GPL_compatible;\n+\n+void\n+noop_starter_fn (diagnostic_context *, diagnostic_info *)\n+{\n+}\n+\n+int\n+plugin_init (struct plugin_name_args *plugin_info,\n+\t     struct plugin_gcc_version *version)\n+{\n+  if (!plugin_default_version_check (version, &gcc_version))\n+    return 1;\n+\n+  diagnostic_starter (global_dc) = noop_starter_fn;\n+\n+  return 0;\n+}"}, {"sha": "1cd3a06bbbfaf65bb2773a334df2d344dcce7d0f", "filename": "gcc/testsuite/g++.dg/template/show-template-tree-2.C", "status": "added", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f012c8ef4b35dcee9b5a3807868d050812d5b3b9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fshow-template-tree-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f012c8ef4b35dcee9b5a3807868d050812d5b3b9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fshow-template-tree-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fshow-template-tree-2.C?ref=f012c8ef4b35dcee9b5a3807868d050812d5b3b9", "patch": "@@ -0,0 +1,118 @@\n+// Tests of -fdiagnostics-show-template-tree with variadic templates\n+// { dg-options \"-fdiagnostics-show-template-tree -std=c++11\" }\n+\n+template<typename> struct vector {};\n+template<typename, typename> struct map {};\n+template<typename ... Types> struct var {};\n+\n+void fn_0(var<>);\n+void fn_1(var<int>);\n+void fn_2(var<int, int>);\n+void fn_3(vector<var<> >);\n+void fn_4(vector<var<int> >);\n+void fn_5(vector<var<int, int> >);\n+\n+void test_fn_0 ()\n+{\n+  fn_0 (var<> ());\n+  fn_0 (var<int> ()); // { dg-error \"could not convert .* from 'var<int>' to 'var<>'\" }\n+  /* { dg-begin-multiline-output \"\" }\n+  var<\n+    [int != ]>\n+     { dg-end-multiline-output \"\" } */\n+  fn_0 (var<int, int> ()); // { dg-error \"could not convert .* from 'var<int, int>' to 'var<>'\" }\n+  /* { dg-begin-multiline-output \"\" }\n+  var<\n+    [int, int != ]>\n+     { dg-end-multiline-output \"\" } */\n+  fn_0 (vector<var<int> >()); // { dg-error \"could not convert .* from 'vector<var<int> >' to 'var<>'\" }\n+  fn_0 (vector<var<int, int> >());  // { dg-error \"could not convert .* from 'vector<var<int, int> >' to 'var<>'\" }\n+}\n+\n+void test_fn_1 ()\n+{\n+  fn_1 (var<> ()); // { dg-error \"could not convert .* from 'var<>' to 'var<int>'\" }\n+  /* { dg-begin-multiline-output \"\" }\n+  var<\n+    [ != int]>\n+     { dg-end-multiline-output \"\" } */\n+  fn_1 (var<int> ());\n+  fn_1 (var<int, int> ()); // { dg-error \"could not convert .* from 'var<int, int>' to 'var<int>'\" }\n+  /* { dg-begin-multiline-output \"\" }\n+  var<\n+    [int, int != int]>\n+     { dg-end-multiline-output \"\" } */\n+  fn_1 (vector<var<int> >()); // { dg-error \"could not convert .* from 'vector<var<int> >' to 'var<int>'\" }\n+  fn_1 (vector<var<int, int> >()); // { dg-error \"could not convert .* from 'vector<var<int, int> >' to 'var<int>'\" }\n+}\n+\n+void test_fn_2 ()\n+{\n+  fn_2 (var<> ()); // { dg-error \"could not convert .* from 'var<>' to 'var<int, int>'\" }\n+  /* { dg-begin-multiline-output \"\" }\n+  var<\n+    [ != int, int]>\n+     { dg-end-multiline-output \"\" } */\n+  fn_2 (var<int> ()); // { dg-error \"could not convert .* from 'var<int>' to 'var<int, int>'\" }\n+  /* { dg-begin-multiline-output \"\" }\n+  var<\n+    [int != int, int]>\n+     { dg-end-multiline-output \"\" } */\n+  fn_2 (var<int, int> ());\n+  fn_2 (vector<var<int> >()); // { dg-error \"could not convert .* from 'vector<var<int> >' to 'var<int, int>'\" }\n+  fn_2 (vector<var<int, int> >()); // { dg-error \"could not convert .* from 'vector<var<int, int> >' to 'var<int, int>'\" }\n+}\n+\n+void test_fn_3 ()\n+{\n+  fn_3 (var<> ()); // { dg-error \"could not convert .* from 'var<>' to 'vector<var<> >'\" }\n+  fn_3 (var<int> ()); // { dg-error \"could not convert .* from 'var<int>' to 'vector<var<> >'\" }\n+  fn_3 (var<int, int> ()); // { dg-error \"could not convert .* from 'var<int, int>' to 'vector<var<> >'\" }\n+  fn_3 (vector<var<> >());\n+  fn_3 (vector<var<int> >());  // { dg-error \"could not convert .* from 'vector<var<int>>' to 'vector<var<>>'\" }\n+  /* { dg-begin-multiline-output \"\" }\n+  vector<\n+    var<\n+      [int != ]>>\n+     { dg-end-multiline-output \"\" } */\n+  fn_3 (vector<var<int, int> >()); // { dg-error \"could not convert .* from 'vector<var<int, int>>' to 'vector<var<>>'\" }\n+  /* { dg-begin-multiline-output \"\" }\n+  vector<\n+    var<\n+      [int, int != ]>>\n+     { dg-end-multiline-output \"\" } */\n+}\n+\n+void test_fn_4 ()\n+{\n+  fn_4 (var<> ()); // { dg-error \"could not convert .* from 'var<>' to 'vector<var<int> >'\" }\n+  fn_4 (var<int> ()); // { dg-error \"could not convert .* from 'var<int>' to 'vector<var<int> >'\" }\n+  fn_4 (var<int, int> ()); // { dg-error \"could not convert .* from 'var<int, int>' to 'vector<var<int> >'\" }\n+  fn_4 (vector<var<> >()); // { dg-error \"could not convert .* from 'vector<var<>>' to 'vector<var<int>>'\" }\n+  /* { dg-begin-multiline-output \"\" }\n+  vector<\n+    var<\n+      [ != int]>>\n+     { dg-end-multiline-output \"\" } */\n+  fn_4 (vector<var<int> >()); \n+  fn_4 (vector<var<int, int> >()); // { dg-error \"could not convert .* from 'vector<var<int, int>>' to 'vector<var<int>>'\" }\n+  /* { dg-begin-multiline-output \"\" }\n+  vector<\n+    var<\n+      [int, int != int]>>\n+     { dg-end-multiline-output \"\" } */\n+}\n+\n+void test_fn_5 ()\n+{\n+  fn_5 (var<> ()); // { dg-error \"could not convert .* from 'var<>' to 'vector<var<int, int> >'\" }\n+  fn_5 (var<int> ());  // { dg-error \"could not convert .* from 'var<int>' to 'vector<var<int, int> >'\" }\n+  fn_5 (var<int, int> ());  // { dg-error \"could not convert .* from 'var<int, int>' to 'vector<var<int, int> >'\" }\n+  fn_5 (vector<var<int> >());  // { dg-error \"could not convert .* from 'vector<var<int>>' to 'vector<var<int, int>>'\" }\n+  /* { dg-begin-multiline-output \"\" }\n+  vector<\n+    var<\n+      [int != int, int]>>\n+     { dg-end-multiline-output \"\" } */\n+  fn_5 (vector<var<int, int> >());\n+}"}, {"sha": "0eda40bcf773b193217ea653b66e74c5c41b2104", "filename": "gcc/testsuite/g++.dg/template/show-template-tree-3.C", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f012c8ef4b35dcee9b5a3807868d050812d5b3b9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fshow-template-tree-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f012c8ef4b35dcee9b5a3807868d050812d5b3b9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fshow-template-tree-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fshow-template-tree-3.C?ref=f012c8ef4b35dcee9b5a3807868d050812d5b3b9", "patch": "@@ -0,0 +1,37 @@\n+/* End-to-end test of -fdiagnostics-show-template-tree and -felide-type\n+   using the STL.\n+   In particular, ensure that we don't print the default arguments e.g.\n+   rather than printing\n+     from 'vector<double,allocator<double>>' to 'vector<float,allocator<float>>'\n+   (albeit with differences nicely color-coded), we want to print:\n+     from 'vector<double>' to 'vector<float>'\n+   (again, with the \"double\" and \"float\" highlighted, though we can't test\n+   for that in this case).  */\n+\n+// { dg-options \"-fdiagnostics-show-template-tree\" }\n+\n+#include <map>\n+#include <vector>\n+\n+using std::vector;\n+using std::map;\n+\n+void takes_vf (vector<float> v);\n+void takes_mivf (map<int, vector<float> > v);\n+\n+int test ()\n+{\n+  takes_vf (vector<double> ()); // { dg-error \"could not convert '.*' from 'vector<double>' to 'vector<float>'\" }\n+  /* { dg-begin-multiline-output \"\" }\n+  vector<\n+    [double != float]>\n+     { dg-end-multiline-output \"\" } */\n+\n+  takes_mivf (map<int, vector<double> > ()); // { dg-error \"could not convert '.*' from 'map<.\\\\.\\\\.\\\\..,vector<double>>' to 'map<.\\\\.\\\\.\\\\..,vector<float>>'\" }\n+  /* { dg-begin-multiline-output \"\" }\n+  map<\n+    [...],\n+    vector<\n+      [double != float]>>\n+     { dg-end-multiline-output \"\" } */\n+}"}, {"sha": "953733b03b450b3f32d7e635c5b1e757e1ea5136", "filename": "gcc/testsuite/g++.dg/template/show-template-tree-4.C", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f012c8ef4b35dcee9b5a3807868d050812d5b3b9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fshow-template-tree-4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f012c8ef4b35dcee9b5a3807868d050812d5b3b9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fshow-template-tree-4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fshow-template-tree-4.C?ref=f012c8ef4b35dcee9b5a3807868d050812d5b3b9", "patch": "@@ -0,0 +1,95 @@\n+// { dg-options \"-fdiagnostics-show-template-tree\" }\n+\n+/* Example of default template args, and various kinds of mismatch.  */\n+\n+template <int = 0, int = 1, int = 2>\n+struct s {};\n+\n+void takes_s (s<> );\n+void takes_s013 (s<0, 1, 3> );\n+void takes_s321 (s<3, 2, 1> );\n+\n+void test ()\n+{\n+  takes_s (s<>());\n+  takes_s (s<0, 1>());\n+  takes_s (s<0, 1, 2>());\n+  takes_s (s<0, 2>()); // { dg-error \"could not convert '.*' from 's<.\\\\.\\\\.\\\\..,2>' to 's<.\\\\.\\\\.\\\\..,1>'\" }\n+  /* { dg-begin-multiline-output \"\" }\n+  s<\n+    [...],\n+    [2 != 1]>\n+     { dg-end-multiline-output \"\" } */\n+\n+  takes_s (s<1>()); // { dg-error \"could not convert '.*' from 's<1>' to 's<0>'\" }\n+  /* { dg-begin-multiline-output \"\" }\n+  s<\n+    [1 != 0]>\n+     { dg-end-multiline-output \"\" } */\n+\n+  takes_s (s<0, 1, 3>()); // { dg-error \"could not convert '.*' from 's<.\\\\.\\\\.\\\\..,.\\\\.\\\\.\\\\..,3>' to 's<.\\\\.\\\\.\\\\..,.\\\\.\\\\.\\\\..,2>'\" }\n+  /* { dg-begin-multiline-output \"\" }\n+  s<\n+    [...],\n+    [...],\n+    [3 != 2]>\n+     { dg-end-multiline-output \"\" } */\n+\n+  takes_s (s<3, 2, 0>()); // { dg-error \"could not convert '.*' from 's<3,2,0>' to 's<0,1,2>'\" }\n+  /* { dg-begin-multiline-output \"\" }\n+  s<\n+    [3 != 0],\n+    [2 != 1],\n+    [0 != 2]>\n+     { dg-end-multiline-output \"\" } */\n+\n+  takes_s (s<3, 2, 1>()); // { dg-error \"could not convert '.*' from 's<3,2,1>' to 's<0,1,2>'\" }\n+  /* { dg-begin-multiline-output \"\" }\n+  s<\n+    [3 != 0],\n+    [2 != 1],\n+    [1 != 2]>\n+     { dg-end-multiline-output \"\" } */\n+\n+  takes_s013 (s<0, 1, 2>()); // { dg-error \"could not convert '.*' from 's<.\\\\.\\\\.\\\\..,.\\\\.\\\\.\\\\..,2>' to 's<.\\\\.\\\\.\\\\..,.\\\\.\\\\.\\\\..,3>'\" }\n+  /* { dg-begin-multiline-output \"\" }\n+  s<\n+    [...],\n+    [...],\n+    [2 != 3]>\n+     { dg-end-multiline-output \"\" } */\n+\n+  takes_s321 (s<>());        // { dg-error \"could not convert '.*' from 's<0,1,2>' to 's<3,2,1>'\" }\n+  /* { dg-begin-multiline-output \"\" }\n+  s<\n+    [0 != 3],\n+    [1 != 2],\n+    [2 != 1]>\n+     { dg-end-multiline-output \"\" } */\n+\n+  takes_s321 (s<0, 1, 3>()); // { dg-error \"could not convert '.*' from 's<0,1,3>' to 's<3,2,1>'\" }\n+  /* { dg-begin-multiline-output \"\" }\n+  s<\n+    [0 != 3],\n+    [1 != 2],\n+    [3 != 1]>\n+     { dg-end-multiline-output \"\" } */\n+\n+  takes_s321 (s<3, 2, 0>()); // { dg-error \"could not convert '.*' from 's<.\\\\.\\\\.\\\\..,.\\\\.\\\\.\\\\..,0>' to 's<.\\\\.\\\\.\\\\..,.\\\\.\\\\.\\\\..,1>'\" }\n+  /* { dg-begin-multiline-output \"\" }\n+  s<\n+    [...],\n+    [...],\n+    [0 != 1]>\n+     { dg-end-multiline-output \"\" } */\n+\n+  takes_s321 (s<3, 2, 1>());\n+\n+  takes_s321 (s<1, 2, 3>()); // { dg-error \"could not convert '.*' from 's<1,.\\\\.\\\\.\\\\..,3>' to 's<3,.\\\\.\\\\.\\\\..,1>'\" }\n+  /* { dg-begin-multiline-output \"\" }\n+  s<\n+    [1 != 3],\n+    [...],\n+    [3 != 1]>\n+     { dg-end-multiline-output \"\" } */\n+}"}, {"sha": "d4bfa81c2e0d4906e444912744d1621a190c999c", "filename": "gcc/testsuite/g++.dg/template/show-template-tree-no-elide-type.C", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f012c8ef4b35dcee9b5a3807868d050812d5b3b9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fshow-template-tree-no-elide-type.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f012c8ef4b35dcee9b5a3807868d050812d5b3b9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fshow-template-tree-no-elide-type.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fshow-template-tree-no-elide-type.C?ref=f012c8ef4b35dcee9b5a3807868d050812d5b3b9", "patch": "@@ -0,0 +1,24 @@\n+// { dg-options \"-fdiagnostics-show-template-tree -fno-elide-type\" }\n+\n+template<typename> struct vector {};\n+template<typename, typename> struct map {};\n+\n+void fn_1(vector<int>);\n+void fn_2(map<int, int>);\n+void fn_3(vector<map<int, float> >);\n+\n+void test ()\n+{\n+  fn_1 (vector<double> ()); // { dg-error \"could not convert .* from 'vector<double>' to 'vector<int>'\" }\n+  /* { dg-begin-multiline-output \"\" }\n+  vector<\n+    [double != int]>\n+     { dg-end-multiline-output \"\" } */\n+\n+  fn_2 (map<int, double>());  // { dg-error \"could not convert .* from 'map<int,double>' to 'map<int,int>'\" }\n+  /* { dg-begin-multiline-output \"\" }\n+  map<\n+    int,\n+    [double != int]>\n+     { dg-end-multiline-output \"\" } */\n+}"}, {"sha": "0b75098675acb0ae0398c379d2dc6fd98c3e2c0c", "filename": "gcc/testsuite/g++.dg/template/show-template-tree.C", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f012c8ef4b35dcee9b5a3807868d050812d5b3b9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fshow-template-tree.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f012c8ef4b35dcee9b5a3807868d050812d5b3b9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fshow-template-tree.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fshow-template-tree.C?ref=f012c8ef4b35dcee9b5a3807868d050812d5b3b9", "patch": "@@ -0,0 +1,51 @@\n+// { dg-options \"-fdiagnostics-show-template-tree\" }\n+\n+template<typename> struct vector {};\n+template<typename, typename> struct map {};\n+template<int> struct arr {};\n+\n+void fn_1(vector<int>);\n+void fn_2(map<int, int>);\n+void fn_3(vector<map<int, float> >);\n+void takes_arr_10 (arr<10>);\n+\n+void test ()\n+{\n+  fn_1 (vector<int> ());\n+  fn_1 (42); // { dg-error \"could not convert '42' from 'int' to 'vector<int>'\" }\n+  fn_1 (vector<double> ()); // { dg-error \"could not convert .* from 'vector<double>' to 'vector<int>'\" }\n+  /* { dg-begin-multiline-output \"\" }\n+  vector<\n+    [double != int]>\n+     { dg-end-multiline-output \"\" } */\n+  fn_1 (map<int, int> ()); // { dg-error \"could not convert .* from 'map<int, int>' to 'vector<int>'\" }\n+\n+  fn_2 (map<int, int>());\n+  fn_2 (map<int, double>());  // { dg-error \"could not convert .* from 'map<.\\\\.\\\\.\\\\..,double>. to .map<.\\\\.\\\\.\\\\..,int>'\" }\n+  /* { dg-begin-multiline-output \"\" }\n+  map<\n+    [...],\n+    [double != int]>\n+     { dg-end-multiline-output \"\" } */\n+  fn_2 (map<double, double>());  // { dg-error \"could not convert .* from .map<double,double>. to .map<int,int>.\" }\n+  /* { dg-begin-multiline-output \"\" }\n+  map<\n+    [double != int],\n+    [double != int]>\n+     { dg-end-multiline-output \"\" } */\n+\n+  fn_3 (vector<map<int, float> >());\n+  fn_3 (vector<map<int, double> >());  // { dg-error \"could not convert .* from 'vector<map<.\\\\.\\\\.\\\\..,double>>' to 'vector<map<.\\\\.\\\\.\\\\..,float>>'\" }\n+  /* { dg-begin-multiline-output \"\" }\n+  vector<\n+    map<\n+      [...],\n+      [double != float]>>\n+     { dg-end-multiline-output \"\" } */\n+\n+  takes_arr_10 (arr<5>()); // { dg-error \"could not convert '.*' from 'arr<5>' to 'arr<10>'\" }\n+  /* { dg-begin-multiline-output \"\" }\n+  arr<\n+    [5 != 10]>\n+     { dg-end-multiline-output \"\" } */\n+}"}, {"sha": "52b7e7f0bb4420b24a317b613596fa7f3407aef6", "filename": "gcc/tree-diagnostic.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f012c8ef4b35dcee9b5a3807868d050812d5b3b9/gcc%2Ftree-diagnostic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f012c8ef4b35dcee9b5a3807868d050812d5b3b9/gcc%2Ftree-diagnostic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-diagnostic.c?ref=f012c8ef4b35dcee9b5a3807868d050812d5b3b9", "patch": "@@ -244,7 +244,8 @@ virt_loc_aware_diagnostic_finalizer (diagnostic_context *context,\n /* Default tree printer.   Handles declarations only.  */\n bool\n default_tree_printer (pretty_printer *pp, text_info *text, const char *spec,\n-\t\t      int precision, bool wide, bool set_locus, bool hash)\n+\t\t      int precision, bool wide, bool set_locus, bool hash,\n+\t\t      bool, const char **)\n {\n   tree t;\n "}, {"sha": "85aa980aeb97d9702e7e873f5a2b426138f55149", "filename": "gcc/tree-diagnostic.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f012c8ef4b35dcee9b5a3807868d050812d5b3b9/gcc%2Ftree-diagnostic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f012c8ef4b35dcee9b5a3807868d050812d5b3b9/gcc%2Ftree-diagnostic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-diagnostic.h?ref=f012c8ef4b35dcee9b5a3807868d050812d5b3b9", "patch": "@@ -55,6 +55,6 @@ void virt_loc_aware_diagnostic_finalizer (diagnostic_context *,\n \n void tree_diagnostics_defaults (diagnostic_context *context);\n bool default_tree_printer (pretty_printer *, text_info *, const char *,\n-\t\t\t   int, bool, bool, bool);\n+\t\t\t   int, bool, bool, bool, bool, const char **);\n \n #endif /* ! GCC_TREE_DIAGNOSTIC_H */"}]}