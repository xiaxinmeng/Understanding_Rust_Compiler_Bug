{"sha": "969d70ca573bbd887b1ccfa21130c70b463ad1f9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTY5ZDcwY2E1NzNiYmQ4ODdiMWNjZmEyMTEzMGM3MGI0NjNhZDFmOQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2002-05-08T09:17:27Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2002-05-08T09:17:27Z"}, "message": "cfglayout.c (function_tail_eff_head): Rename to ...\n\n\n\t* cfglayout.c (function_tail_eff_head): Rename to ...\n\t(function_footer): ... this one.\n\t(unlink_insn_chain): New functions.\n\t(label_for_bb): Only call block_label and emit debug message.\n\t(record_effective_endpoints): Actually unlink the headers and footers.\n\t(fixup_reorder_cahin): Re-insert the unlinked sequences.\n\t(cfg_layout_duplicate_bb): Use duplicate_insn_chain.\n\t* cfglayout.h (struct reorder_block_def): New fields footer/header;\n\tremove eff_head/eff_end.\n\t* rtl.h (set_first_insn): Declare.\n\t* emit-rtl.c (set_first_insn): New function.\n\n\t* cfglayout.c (fixup_reorder_chain): Dump duplicated\n\t(cfg_layout_can_duplicate_bb_p, cfg_layout_rerirect_edge,\n\tcfg_layout_duplicate_bb): New global function.\n\t(duplicate_insn_chain): New static function.\n\t* cfglayout.h (cfg_layout_can_duplicate_bb_p, cfg_layout_rerirect_edge,\n\tcfg_layout_duplicate_bb): Declare.\n\t(struct reorder_block_def): Add \"original\" field.\n\t* emit-rtl.c (emit_copy_of_insn_after): New function.\n\t* rtl.h (emit_copy_of_insn_after): Declare.\n\n\t* cfglayout.c (fixup_fallthru_exit_predecessor): Kill.\n\t(fixup_reorder_chain): properly handle edges to exit block.\n\nWed May  8 11:10:31 CEST 2002  Zdenek Dvorak  <rakdver@atrey.karlin.mff.cuni.cz>\n\t\t\t       Jan Hubicka  <jh@suse.cz>\n\n\t* basic-block.h (note_prediction_to_br_prob): declare.\n\t* c-semantics.c: Inlucde predit.h\n\t(expand_stmt): predict GOTO_STMT as not taken.\n\t* cfgcleanup.c: (delete_unreachable_blocks): Make global.\n\t(cleanup_cfg): Do not free tail_recursion_list.\n\t* cfgrtl.c (can_delete_note_p): Delete NOTE_INSN_PREDICTION.\n\t(flow_delete_block): Kill predictions past end of basic block.\n\t* output.h (delete_unreachable_blocks): Declare.\n\t* predict.c (predicted_by_p, process_note_predictions,\n\tprocess_note_prediction, last_block_p): New function.\n\t(estimate_probability): Bypass loop on PRED_CONTINUE;\n\tdo not handle noreturn heuristics; kill PRED_RETURN; add\n\tPRED_EARLY_RETURN.\n\t* predict.def (PRED_CONTINUE, PRED_EARLY_RETURN, PRED_GOTO,\n\tPRED_CONST_RETURN, PRED_NEGATIVE_RETURN, PRED_NULL_RETURN): New.\n\t* predict.h (IS_TAKEN): New constant.\n\t* print-rtl.c (print_rtx): Pretty print NOTE_INSN_PREDICTION.\n\t* rtl.c (NOTE_INSN_PREDICTION): New.\n\t* rtl.h (NOTE_PREDICTION, NOTE_PREDICTION_ALG, NOTE_PREDICTION_FLAGS):\n\tNew macro.\n\t(insn_note): add NOTE_INSN_PREDICTION.\n\t* sibcall.c (optimize_sibling_and_tail_recursive_call): Do not build\n\tCFG; free tail_recursion_label_list.\n\t* stmt.c: Include predict.h;\n\t(return_prediction): New.\n\t(expand_value_return): Use it.\n\t* toplev.c: Lower NOTE_INSN_PREDICTION before sibcall.\n\nFrom-SVN: r53285", "tree": {"sha": "e792f9087c41693050ce30fb1cf4b7791611a354", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e792f9087c41693050ce30fb1cf4b7791611a354"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/969d70ca573bbd887b1ccfa21130c70b463ad1f9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/969d70ca573bbd887b1ccfa21130c70b463ad1f9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/969d70ca573bbd887b1ccfa21130c70b463ad1f9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/969d70ca573bbd887b1ccfa21130c70b463ad1f9/comments", "author": null, "committer": null, "parents": [{"sha": "41f8d041be068873c8c27b3e9c86bed3b2c90385", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/41f8d041be068873c8c27b3e9c86bed3b2c90385", "html_url": "https://github.com/Rust-GCC/gccrs/commit/41f8d041be068873c8c27b3e9c86bed3b2c90385"}], "stats": {"total": 958, "additions": 861, "deletions": 97}, "files": [{"sha": "bfeecda612b69de5a0da42840663dbee1bfe3bfc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/969d70ca573bbd887b1ccfa21130c70b463ad1f9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/969d70ca573bbd887b1ccfa21130c70b463ad1f9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=969d70ca573bbd887b1ccfa21130c70b463ad1f9", "patch": "@@ -1,3 +1,61 @@\n+Wed May  8 11:08:50 CEST 2002  Jan Hubicka  <jh@suse.cz>\n+\n+\t* cfglayout.c (function_tail_eff_head): Rename to ...\n+\t(function_footer): ... this one.\n+\t(unlink_insn_chain): New functions.\n+\t(label_for_bb): Only call block_label and emit debug message.\n+\t(record_effective_endpoints): Actually unlink the headers and footers.\n+\t(fixup_reorder_cahin): Re-insert the unlinked sequences.\n+\t(cfg_layout_duplicate_bb): Use duplicate_insn_chain.\n+\t* cfglayout.h (struct reorder_block_def): New fields footer/header;\n+\tremove eff_head/eff_end.\n+\t* rtl.h (set_first_insn): Declare.\n+\t* emit-rtl.c (set_first_insn): New function.\n+\n+\t* cfglayout.c (fixup_reorder_chain): Dump duplicated\n+\t(cfg_layout_can_duplicate_bb_p, cfg_layout_rerirect_edge,\n+\tcfg_layout_duplicate_bb): New global function.\n+\t(duplicate_insn_chain): New static function.\n+\t* cfglayout.h (cfg_layout_can_duplicate_bb_p, cfg_layout_rerirect_edge,\n+\tcfg_layout_duplicate_bb): Declare.\n+\t(struct reorder_block_def): Add \"original\" field.\n+\t* emit-rtl.c (emit_copy_of_insn_after): New function.\n+\t* rtl.h (emit_copy_of_insn_after): Declare.\n+\n+\t* cfglayout.c (fixup_fallthru_exit_predecessor): Kill.\n+\t(fixup_reorder_chain): properly handle edges to exit block.\n+\n+Wed May  8 11:10:31 CEST 2002  Zdenek Dvorak  <rakdver@atrey.karlin.mff.cuni.cz>\n+\t\t\t       Jan Hubicka  <jh@suse.cz>\n+\n+\t* basic-block.h (note_prediction_to_br_prob): declare.\n+\t* c-semantics.c: Inlucde predit.h\n+\t(expand_stmt): predict GOTO_STMT as not taken.\n+\t* cfgcleanup.c: (delete_unreachable_blocks): Make global.\n+\t(cleanup_cfg): Do not free tail_recursion_list.\n+\t* cfgrtl.c (can_delete_note_p): Delete NOTE_INSN_PREDICTION.\n+\t(flow_delete_block): Kill predictions past end of basic block.\n+\t* output.h (delete_unreachable_blocks): Declare.\n+\t* predict.c (predicted_by_p, process_note_predictions,\n+\tprocess_note_prediction, last_block_p): New function.\n+\t(estimate_probability): Bypass loop on PRED_CONTINUE;\n+\tdo not handle noreturn heuristics; kill PRED_RETURN; add\n+\tPRED_EARLY_RETURN.\n+\t* predict.def (PRED_CONTINUE, PRED_EARLY_RETURN, PRED_GOTO,\n+\tPRED_CONST_RETURN, PRED_NEGATIVE_RETURN, PRED_NULL_RETURN): New.\n+\t* predict.h (IS_TAKEN): New constant.\n+\t* print-rtl.c (print_rtx): Pretty print NOTE_INSN_PREDICTION.\n+\t* rtl.c (NOTE_INSN_PREDICTION): New.\n+\t* rtl.h (NOTE_PREDICTION, NOTE_PREDICTION_ALG, NOTE_PREDICTION_FLAGS):\n+\tNew macro.\n+\t(insn_note): add NOTE_INSN_PREDICTION.\n+\t* sibcall.c (optimize_sibling_and_tail_recursive_call): Do not build\n+\tCFG; free tail_recursion_label_list.\n+\t* stmt.c: Include predict.h;\n+\t(return_prediction): New.\n+\t(expand_value_return): Use it.\n+\t* toplev.c: Lower NOTE_INSN_PREDICTION before sibcall.\n+\n 2002-05-08  Richard Sandiford  <rsandifo@redhat.com>\n \n \t* config/mips/mips.md: Name the unspecs with define_constant."}, {"sha": "7a55da713b4ca961cdc6dfca3ece4c172b8fcd46", "filename": "gcc/Makefile.in", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/969d70ca573bbd887b1ccfa21130c70b463ad1f9/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/969d70ca573bbd887b1ccfa21130c70b463ad1f9/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=969d70ca573bbd887b1ccfa21130c70b463ad1f9", "patch": "@@ -1227,7 +1227,7 @@ c-format.o : c-format.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) langhooks.h \\\n \n c-semantics.o : c-semantics.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) $(C_TREE_H) \\\n \tc-lex.h flags.h toplev.h output.h c-pragma.h $(RTL_H) $(GGC_H) \\\n-\t$(EXPR_H)\n+\t$(EXPR_H) predict.h\n \n # Language-independent files.\n \n@@ -1389,7 +1389,7 @@ function.o : function.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(TREE_H) flags.h \\\n stmt.o : stmt.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(TREE_H) flags.h function.h  \\\n    insn-config.h hard-reg-set.h $(EXPR_H) libfuncs.h except.h \\\n    $(LOOP_H) $(RECOG_H) toplev.h output.h varray.h $(GGC_H) $(TM_P_H) \\\n-   langhooks.h\n+   langhooks.h predict.h\n except.o : except.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(TREE_H) flags.h \\\n    except.h function.h $(EXPR_H) libfuncs.h integrate.h langhooks.h \\\n    insn-config.h hard-reg-set.h $(BASIC_BLOCK_H) output.h \\"}, {"sha": "e1c1905827c134d02be084f4ecfb689fcb33ee10", "filename": "gcc/basic-block.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/969d70ca573bbd887b1ccfa21130c70b463ad1f9/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/969d70ca573bbd887b1ccfa21130c70b463ad1f9/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=969d70ca573bbd887b1ccfa21130c70b463ad1f9", "patch": "@@ -625,6 +625,7 @@ extern rtx emit_block_insn_before\tPARAMS ((rtx, rtx, basic_block));\n \n /* In predict.c */\n extern void estimate_probability        PARAMS ((struct loops *));\n+extern void note_prediction_to_br_prob\tPARAMS ((void));\n extern void expected_value_to_br_prob\tPARAMS ((void));\n \n /* In flow.c */"}, {"sha": "32fae4482101de95c3d6dd21745db336b27cde68", "filename": "gcc/c-semantics.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/969d70ca573bbd887b1ccfa21130c70b463ad1f9/gcc%2Fc-semantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/969d70ca573bbd887b1ccfa21130c70b463ad1f9/gcc%2Fc-semantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-semantics.c?ref=969d70ca573bbd887b1ccfa21130c70b463ad1f9", "patch": "@@ -36,6 +36,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"expr.h\"\n #include \"output.h\"\n #include \"timevar.h\"\n+#include \"predict.h\"\n \n /* If non-NULL, the address of a language-specific function for\n    expanding statements.  */\n@@ -834,6 +835,14 @@ expand_stmt (t)\n \t  break;\n \n \tcase GOTO_STMT:\n+\t  /* Emit information for branch prediction.  */\n+\t  if (!GOTO_FAKE_P (t)\n+\t      && TREE_CODE (GOTO_DESTINATION (t)) == LABEL_DECL)\n+\t    {\n+\t      rtx note = emit_note (NULL, NOTE_INSN_PREDICTION);\n+\n+\t      NOTE_PREDICTION (note) = NOTE_PREDICT (PRED_GOTO, NOT_TAKEN);\n+\t    }\n \t  genrtl_goto_stmt (GOTO_DESTINATION (t));\n \t  break;\n "}, {"sha": "1bb3d9bc19d5280eb82c3f17d95e426e9f0c5631", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/969d70ca573bbd887b1ccfa21130c70b463ad1f9/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/969d70ca573bbd887b1ccfa21130c70b463ad1f9/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=969d70ca573bbd887b1ccfa21130c70b463ad1f9", "patch": "@@ -74,7 +74,7 @@ static int flow_find_cross_jump\t\tPARAMS ((int, basic_block, basic_block,\n \t\t\t\t\t\t rtx *, rtx *));\n static bool insns_match_p\t\tPARAMS ((int, rtx, rtx));\n \n-static bool delete_unreachable_blocks\tPARAMS ((void));\n+bool delete_unreachable_blocks\t\tPARAMS ((void));\n static bool label_is_jump_target_p\tPARAMS ((rtx, rtx));\n static bool tail_recursion_label_p\tPARAMS ((rtx));\n static void merge_blocks_move_predecessor_nojumps PARAMS ((basic_block,\n@@ -1748,7 +1748,7 @@ try_optimize_cfg (mode)\n \f\n /* Delete all unreachable basic blocks.  */\n \n-static bool\n+bool\n delete_unreachable_blocks ()\n {\n   int i, j;\n@@ -1829,7 +1829,6 @@ cleanup_cfg (mode)\n \n   /* Kill the data we won't maintain.  */\n   free_EXPR_LIST_list (&label_value_list);\n-  free_EXPR_LIST_list (&tail_recursion_label_list);\n   timevar_pop (TV_CLEANUP_CFG);\n \n   return changed;"}, {"sha": "632280caa900a40971907559abec5e5dc434c922", "filename": "gcc/cfglayout.c", "status": "modified", "additions": 340, "deletions": 40, "changes": 380, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/969d70ca573bbd887b1ccfa21130c70b463ad1f9/gcc%2Fcfglayout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/969d70ca573bbd887b1ccfa21130c70b463ad1f9/gcc%2Fcfglayout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfglayout.c?ref=969d70ca573bbd887b1ccfa21130c70b463ad1f9", "patch": "@@ -35,7 +35,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n extern struct obstack flow_obstack;\n \n /* Holds the interesting trailing notes for the function.  */\n-static rtx function_tail_eff_head;\n+static rtx function_footer;\n \n static rtx skip_insns_after_block\tPARAMS ((basic_block));\n static void record_effective_endpoints\tPARAMS ((void));\n@@ -47,10 +47,33 @@ static void change_scope\t\tPARAMS ((rtx, tree, tree));\n \n void verify_insn_chain\t\t\tPARAMS ((void));\n static void fixup_fallthru_exit_predecessor PARAMS ((void));\n+static rtx unlink_insn_chain PARAMS ((rtx, rtx));\n+static rtx duplicate_insn_chain PARAMS ((rtx, rtx));\n \n /* Map insn uid to lexical block.  */\n static varray_type insn_scopes;\n \f\n+static rtx\n+unlink_insn_chain (first, last)\n+     rtx first;\n+     rtx last;\n+{\n+  rtx prevfirst = PREV_INSN (first);\n+  rtx nextlast = NEXT_INSN (last);\n+\n+  PREV_INSN (first) = NULL;\n+  NEXT_INSN (last) = NULL;\n+  if (prevfirst)\n+    NEXT_INSN (prevfirst) = nextlast;\n+  if (nextlast)\n+    PREV_INSN (nextlast) = prevfirst;\n+  else\n+    set_last_insn (prevfirst);\n+  if (!prevfirst)\n+    set_first_insn (nextlast);\n+  return first;\n+}\n+\f\n /* Skip over inter-block insns occurring after BB which are typically\n    associated with BB (e.g., barriers). If there are any such insns,\n    we return the last one. Otherwise, we return the end of BB.  */\n@@ -155,8 +178,6 @@ label_for_bb (bb)\n \tfprintf (rtl_dump_file, \"Emitting label for block %d\\n\", bb->index);\n \n       label = block_label (bb);\n-      if (bb->head == PREV_INSN (RBI (bb)->eff_head))\n-\tRBI (bb)->eff_head = label;\n     }\n \n   return label;\n@@ -176,13 +197,18 @@ record_effective_endpoints ()\n       basic_block bb = BASIC_BLOCK (i);\n       rtx end;\n \n-      RBI (bb)->eff_head = next_insn;\n+      if (PREV_INSN (bb->head) && next_insn != bb->head)\n+\tRBI (bb)->header = unlink_insn_chain (next_insn,\n+\t\t\t\t\t      PREV_INSN (bb->head));\n       end = skip_insns_after_block (bb);\n-      RBI (bb)->eff_end = end;\n-      next_insn = NEXT_INSN (end);\n+      if (NEXT_INSN (bb->end) && bb->end != end)\n+        RBI (bb)->footer = unlink_insn_chain (NEXT_INSN (bb->end), end);\n+      next_insn = NEXT_INSN (bb->end);\n     }\n \n-  function_tail_eff_head = next_insn;\n+  function_footer = next_insn;\n+  if (function_footer)\n+    function_footer = unlink_insn_chain (function_footer, get_last_insn ());\n }\n \f\n /* Build a varray mapping INSN_UID to lexical block.  Return it.  */\n@@ -237,7 +263,7 @@ set_block_levels (block, level)\n       block = BLOCK_CHAIN (block);\n     }\n }\n-\n+\f\n /* Emit lexical block notes needed to change scope from S1 to S2.  */\n \n static void\n@@ -330,32 +356,49 @@ scope_to_insns_finalize ()\n static void\n fixup_reorder_chain ()\n {\n-  basic_block bb, last_bb;\n+  basic_block bb;\n   int index;\n-  rtx insn;\n-  int old_n_basic_blocks = n_basic_blocks;\n+  rtx insn = NULL;\n \n   /* First do the bulk reordering -- rechain the blocks without regard to\n      the needed changes to jumps and labels.  */\n \n-  for (last_bb = BASIC_BLOCK (0), bb = RBI (last_bb)->next, index = 1;\n+  for (bb = BASIC_BLOCK (0), index = 0;\n        bb != 0;\n-       last_bb = bb, bb = RBI (bb)->next, index++)\n+       bb = RBI (bb)->next, index++)\n     {\n-      rtx last_e = RBI (last_bb)->eff_end;\n-      rtx curr_h = RBI (bb)->eff_head;\n-\n-      NEXT_INSN (last_e) = curr_h;\n-      PREV_INSN (curr_h) = last_e;\n+      if (RBI (bb)->header)\n+\t{\n+\t  if (insn)\n+\t    NEXT_INSN (insn) = RBI (bb)->header;\n+\t  else\n+\t    set_first_insn (RBI (bb)->header);\n+\t  PREV_INSN (RBI (bb)->header) = insn;\n+\t  insn = RBI (bb)->header;\n+\t  while (NEXT_INSN (insn))\n+\t    insn = NEXT_INSN (insn);\n+\t}\n+      if (insn)\n+\tNEXT_INSN (insn) = bb->head;\n+      else\n+\tset_first_insn (bb->head);\n+      PREV_INSN (bb->head) = insn;\n+      insn = bb->end;\n+      if (RBI (bb)->footer)\n+\t{\n+\t  NEXT_INSN (insn) = RBI (bb)->footer;\n+\t  PREV_INSN (RBI (bb)->footer) = insn;\n+\t  while (NEXT_INSN (insn))\n+\t    insn = NEXT_INSN (insn);\n+\t}\n     }\n \n   if (index != n_basic_blocks)\n     abort ();\n \n-  insn = RBI (last_bb)->eff_end;\n-  NEXT_INSN (insn) = function_tail_eff_head;\n-  if (function_tail_eff_head)\n-    PREV_INSN (function_tail_eff_head) = insn;\n+  NEXT_INSN (insn) = function_footer;\n+  if (function_footer)\n+    PREV_INSN (function_footer) = insn;\n \n   while (NEXT_INSN (insn))\n     insn = NEXT_INSN (insn);\n@@ -470,8 +513,6 @@ fixup_reorder_chain ()\n       if (nb)\n \t{\n \t  alloc_aux_for_block (nb, sizeof (struct reorder_block_def));\n-\t  RBI (nb)->eff_head = nb->head;\n-\t  RBI (nb)->eff_end = NEXT_INSN (nb->end);\n \t  RBI (nb)->visited = 1;\n \t  RBI (nb)->next = RBI (bb)->next;\n \t  RBI (bb)->next = nb;\n@@ -481,20 +522,26 @@ fixup_reorder_chain ()\n     }\n \n   /* Put basic_block_info in the new order.  */\n-  bb = BASIC_BLOCK (0);\n-  index = 0;\n \n   if (rtl_dump_file)\n-    fprintf (rtl_dump_file, \"Reordered sequence:\\n\");\n-\n-  for (; bb; bb = RBI (bb)->next, index++)\n     {\n-      if (rtl_dump_file)\n-\tfprintf (rtl_dump_file, \" %i %sbb %i freq %i\\n\", index,\n-\t\t bb->index >= old_n_basic_blocks ? \"compensation \" : \"\",\n-\t\t bb->index,\n-\t   \t bb->frequency);\n+      fprintf (rtl_dump_file, \"Reordered sequence:\\n\");\n+      for (bb = BASIC_BLOCK (0), index = 0; bb; bb = RBI (bb)->next, index ++)\n+\t{\n+\t  fprintf (rtl_dump_file, \" %i \", index);\n+\t  if (RBI (bb)->original)\n+\t    fprintf (rtl_dump_file, \"duplicate of %i \",\n+\t\t     RBI (bb)->original->index);\n+\t  else if (forwarder_block_p (bb) && GET_CODE (bb->head) != CODE_LABEL)\n+\t    fprintf (rtl_dump_file, \"compensation \");\n+\t  else\n+\t    fprintf (rtl_dump_file, \"bb %i \", bb->index);\n+\t  fprintf (rtl_dump_file, \" [%i]\\n\", bb->frequency);\n+\t}\n+    }\n \n+  for (bb = BASIC_BLOCK (0), index = 0; bb; bb = RBI (bb)->next, index ++)\n+    {\n       bb->index = index;\n       BASIC_BLOCK (index) = bb;\n     }\n@@ -530,10 +577,9 @@ verify_insn_chain ()\n   if (insn_cnt1 != insn_cnt2)\n     abort ();\n }\n-\n-/* The block falling through to exit must be the last one in the reordered\n-   chain.  Ensure it is.  */\n-\n+\f\n+/* The block falling through to exit must be the last one in the\n+   reordered chain.  Ensure that this condition is met.  */\n static void\n fixup_fallthru_exit_predecessor ()\n {\n@@ -560,12 +606,266 @@ fixup_fallthru_exit_predecessor ()\n     }\n }\n \f\n-/* Main entry point to this module: initialize the datastructures for CFG\n-   layout changes.  */\n+/* Return true in case it is possible to duplicate the basic block BB.  */\n+\n+bool\n+cfg_layout_can_duplicate_bb_p (bb)\n+     basic_block bb;\n+{\n+  rtx next;\n+  edge s;\n+\n+  if (bb == EXIT_BLOCK_PTR || bb == ENTRY_BLOCK_PTR)\n+    return false;\n+\n+  /* Duplicating fallthru block to exit would require adding an jump\n+     and splitting the real last BB.  */\n+  for (s = bb->succ; s; s = s->succ_next)\n+    if (s->dest == EXIT_BLOCK_PTR && s->flags & EDGE_FALLTHRU)\n+       return false;\n+\n+  /* Do not attempt to duplicate tablejumps, as we need to unshare\n+     the dispatch table.  This is dificult to do, as the instructions\n+     computing jump destination may be hoisted outside the basic block.  */\n+  if (GET_CODE (bb->end) == JUMP_INSN && JUMP_LABEL (bb->end)\n+      && (next = next_nonnote_insn (JUMP_LABEL (bb->end)))\n+      && GET_CODE (next) == JUMP_INSN\n+      && (GET_CODE (PATTERN (next)) == ADDR_VEC\n+\t  || GET_CODE (PATTERN (next)) == ADDR_DIFF_VEC))\n+    return false;\n+  return true;\n+}\n+\n+static rtx\n+duplicate_insn_chain (from, to)\n+     rtx from, to;\n+{\n+  rtx insn, last;\n+\n+  /* Avoid updating of boundaries of previous basic block.  The\n+     note will get removed from insn stream in fixup.  */\n+  last = emit_note (NULL, NOTE_INSN_DELETED);\n+\n+  /* Create copy at the end of INSN chain.  The chain will\n+     be reordered later.  */\n+  for (insn = from; insn != NEXT_INSN (to); insn = NEXT_INSN (insn))\n+    {\n+      rtx new;\n+      switch (GET_CODE (insn))\n+\t{\n+\tcase INSN:\n+\tcase CALL_INSN:\n+\tcase JUMP_INSN:\n+\t  /* Avoid copying of dispatch tables.  We never duplicate\n+\t     tablejumps, so this can hit only in case the table got\n+\t     moved far from original jump.  */\n+\t  if (GET_CODE (PATTERN (insn)) == ADDR_VEC\n+\t      || GET_CODE (PATTERN (insn)) == ADDR_DIFF_VEC)\n+\t    break;\n+\t  new = emit_copy_of_insn_after (insn, get_last_insn ());\n+\t  /* Record the INSN_SCOPE.  */\n+\t  VARRAY_GROW (insn_scopes, INSN_UID (new) + 1);\n+\t  VARRAY_TREE (insn_scopes, INSN_UID (new))\n+\t    = VARRAY_TREE (insn_scopes, INSN_UID (insn));\n+\t  break;\n+\n+\tcase CODE_LABEL:\n+\t  break;\n+\n+\tcase BARRIER:\n+\t  emit_barrier ();\n+\t  break;\n+\n+\tcase NOTE:\n+\t  switch (NOTE_LINE_NUMBER (insn))\n+\t    {\n+\t      /* In case prologue is empty and function contain label\n+\t         in first BB, we may want to copy the block.  */\n+\t    case NOTE_INSN_PROLOGUE_END:\n+\n+\t    case NOTE_INSN_LOOP_VTOP:\n+\t    case NOTE_INSN_LOOP_CONT:\n+\t    case NOTE_INSN_LOOP_BEG:\n+\t    case NOTE_INSN_LOOP_END:\n+\t      /* Strip down the loop notes - we don't really want to keep\n+\t         them consistent in loop copies.  */\n+\t    case NOTE_INSN_DELETED:\n+\t    case NOTE_INSN_DELETED_LABEL:\n+\t      /* No problem to strip these.  */\n+\t    case NOTE_INSN_EPILOGUE_BEG:\n+\t    case NOTE_INSN_FUNCTION_END:\n+\t      /* Debug code expect these notes to exist just once.\n+\t         Keep them in the master copy.\n+\t         ??? It probably makes more sense to duplicate them for each\n+\t         epilogue copy.  */\n+\t    case NOTE_INSN_FUNCTION_BEG:\n+\t      /* There is always just single entry to function.  */\n+\t    case NOTE_INSN_BASIC_BLOCK:\n+\t      break;\n+\n+\t      /* There is no purpose to duplicate prologue.  */\n+\t    case NOTE_INSN_BLOCK_BEG:\n+\t    case NOTE_INSN_BLOCK_END:\n+\t      /* The BLOCK_BEG/BLOCK_END notes should be eliminated when BB\n+\t         reordering is in the progress.  */\n+\t    case NOTE_INSN_EH_REGION_BEG:\n+\t    case NOTE_INSN_EH_REGION_END:\n+\t    case NOTE_INSN_RANGE_BEG:\n+\t    case NOTE_INSN_RANGE_END:\n+\t      /* Should never exist at BB duplication time.  */\n+\t      abort ();\n+\t      break;\n+\t    case NOTE_INSN_REPEATED_LINE_NUMBER:\n+\t      emit_note (NOTE_SOURCE_FILE (insn), NOTE_LINE_NUMBER (insn));\n+\t      break;\n+\n+\t    default:\n+\t      if (NOTE_LINE_NUMBER (insn) < 0)\n+\t\tabort ();\n+\t      /* It is possible that no_line_number is set and the note\n+\t         won't be emitted.  */\n+\t      emit_note (NOTE_SOURCE_FILE (insn), NOTE_LINE_NUMBER (insn));\n+\t    }\n+\t  break;\n+\tdefault:\n+\t  abort ();\n+\t}\n+    }\n+  insn = NEXT_INSN (last);\n+  delete_insn (last);\n+  return insn;\n+}\n+\n+/* Redirect Edge to DEST.  */\n+void\n+cfg_layout_redirect_edge (e, dest)\n+     edge e;\n+     basic_block dest;\n+{\n+  int old_index = dest->index;\n+  basic_block src = e->src;\n+\n+  /* Redirect_edge_and_branch may decide to turn branch into fallthru edge\n+     in the case the basic block appears to be in sequence.  Avoid this\n+     transformation.  */\n+\n+  dest->index = n_basic_blocks + 1;\n+  if (e->flags & EDGE_FALLTHRU)\n+    {\n+      /* In case we are redirecting fallthru edge to the branch edge\n+         of conditional jump, remove it.  */\n+      if (src->succ->succ_next\n+\t  && !src->succ->succ_next->succ_next)\n+\t{\n+\t  edge s = e->succ_next ? e->succ_next : src->succ;\n+\t  if (s->dest == dest\n+\t      && any_condjump_p (src->end)\n+\t      && onlyjump_p (src->end))\n+\t    delete_insn (src->end);\n+\t}\n+      redirect_edge_succ_nodup (e, dest);\n+    }\n+  else\n+    redirect_edge_and_branch (e, dest);\n+  dest->index = old_index;\n+}\n+\n+/* Create an duplicate of the basic block BB and redirect edge E into it.  */\n+\n+basic_block\n+cfg_layout_duplicate_bb (bb, e)\n+     basic_block bb;\n+     edge e;\n+{\n+  rtx insn;\n+  edge s, n;\n+  basic_block new_bb;\n+  gcov_type new_count = e ? e->count : 0;\n+\n+  if (bb->count < new_count)\n+    new_count = bb->count;\n+  if (!bb->pred)\n+    abort ();\n+#ifdef ENABLE_CHECKING\n+  if (!cfg_layout_can_duplicate_bb_p (bb))\n+    abort ();\n+#endif\n+\n+  insn = duplicate_insn_chain (bb->head, bb->end);\n+  new_bb = create_basic_block (n_basic_blocks, insn,\n+\t\t \t       insn ? get_last_insn () : NULL);\n+  alloc_aux_for_block (new_bb, sizeof (struct reorder_block_def));\n+\n+  if (RBI (bb)->header)\n+    {\n+      insn = RBI (bb)->header;\n+      while (NEXT_INSN (insn))\n+\tinsn = NEXT_INSN (insn);\n+      insn = duplicate_insn_chain (RBI (bb)->header, insn);\n+      if (insn)\n+\tRBI (new_bb)->header = unlink_insn_chain (insn, get_last_insn ());\n+    }\n+\n+  if (RBI (bb)->footer)\n+    {\n+      insn = RBI (bb)->footer;\n+      while (NEXT_INSN (insn))\n+\tinsn = NEXT_INSN (insn);\n+      insn = duplicate_insn_chain (RBI (bb)->footer, insn);\n+      if (insn)\n+\tRBI (new_bb)->footer = unlink_insn_chain (insn, get_last_insn ());\n+    }\n+\n+  if (bb->global_live_at_start)\n+    {\n+      new_bb->global_live_at_start = OBSTACK_ALLOC_REG_SET (&flow_obstack);\n+      new_bb->global_live_at_end = OBSTACK_ALLOC_REG_SET (&flow_obstack);\n+      COPY_REG_SET (new_bb->global_live_at_start, bb->global_live_at_start);\n+      COPY_REG_SET (new_bb->global_live_at_end, bb->global_live_at_end);\n+    }\n+\n+  new_bb->loop_depth = bb->loop_depth;\n+  new_bb->flags = bb->flags;\n+  for (s = bb->succ; s; s = s->succ_next)\n+    {\n+      n = make_edge (new_bb, s->dest, s->flags);\n+      n->probability = s->probability;\n+      if (new_count)\n+\t/* Take care for overflows!  */\n+\tn->count = s->count * (new_count * 10000 / bb->count) / 10000;\n+      else\n+\tn->count = 0;\n+      s->count -= n->count;\n+    }\n+\n+  new_bb->count = new_count;\n+  bb->count -= new_count;\n+\n+  if (e)\n+   {\n+     new_bb->frequency = EDGE_FREQUENCY (e);\n+     bb->frequency -= EDGE_FREQUENCY (e);\n+\n+     cfg_layout_redirect_edge (e, new_bb);\n+   }\n+\n+  if (bb->count < 0)\n+    bb->count = 0;\n+  if (bb->frequency < 0)\n+    bb->frequency = 0;\n+\n+  RBI (new_bb)->original = bb;\n+  return new_bb;\n+}\n+\f\n+/* Main entry point to this module - initialize the datastructures for\n+   CFG layout changes.  It keeps LOOPS up-to-date if not null.  */\n \n void\n cfg_layout_initialize ()\n {\n+  /* Our algorithm depends on fact that there are now dead jumptables\n+     around the code.  */\n   alloc_aux_for_blocks (sizeof (struct reorder_block_def));\n \n   scope_to_insns_initialize ();"}, {"sha": "e4e27d00ed44afc2e3db093b5515a6f12dcb03af", "filename": "gcc/cfglayout.h", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/969d70ca573bbd887b1ccfa21130c70b463ad1f9/gcc%2Fcfglayout.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/969d70ca573bbd887b1ccfa21130c70b463ad1f9/gcc%2Fcfglayout.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfglayout.h?ref=969d70ca573bbd887b1ccfa21130c70b463ad1f9", "patch": "@@ -21,16 +21,21 @@\n /* Structure to hold information about the blocks during reordering.  */\n typedef struct reorder_block_def\n {\n-  rtx eff_head;\n-  rtx eff_end;\n+  rtx header;\n+  rtx footer;\n   basic_block next;\n+  basic_block original;\n+\n+  /* These fields are used by bb-reorder pass.  */\n   int visited;\n } *reorder_block_def;\n \n #define RBI(BB)\t((reorder_block_def) (BB)->aux)\n \n extern void cfg_layout_initialize\tPARAMS ((void));\n extern void cfg_layout_finalize\t\tPARAMS ((void));\n-\n+extern bool cfg_layout_can_duplicate_bb_p PARAMS ((basic_block));\n+extern basic_block cfg_layout_duplicate_bb PARAMS ((basic_block, edge));\n extern void scope_to_insns_initialize\tPARAMS ((void));\n extern void scope_to_insns_finalize\tPARAMS ((void));\n+extern void cfg_layout_redirect_edge\tPARAMS ((edge, basic_block));"}, {"sha": "d96f677c9896319da02175947c6e3fea6b22d1c6", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/969d70ca573bbd887b1ccfa21130c70b463ad1f9/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/969d70ca573bbd887b1ccfa21130c70b463ad1f9/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=969d70ca573bbd887b1ccfa21130c70b463ad1f9", "patch": "@@ -89,7 +89,8 @@ can_delete_note_p (note)\n      rtx note;\n {\n   return (NOTE_LINE_NUMBER (note) == NOTE_INSN_DELETED\n-\t  || NOTE_LINE_NUMBER (note) == NOTE_INSN_BASIC_BLOCK);\n+\t  || NOTE_LINE_NUMBER (note) == NOTE_INSN_BASIC_BLOCK\n+          || NOTE_LINE_NUMBER (note) == NOTE_INSN_PREDICTION);\n }\n \n /* True if a given label can be deleted.  */\n@@ -375,6 +376,16 @@ flow_delete_block_noexpunge (b)\n      and remove the associated NOTE_INSN_EH_REGION_BEG and\n      NOTE_INSN_EH_REGION_END notes.  */\n \n+  /* Get rid of all NOTE_INSN_PREDICTIONs hanging before the block.  */\n+  \n+  for (insn = PREV_INSN (b->head); insn; insn = PREV_INSN (insn))\n+    {\n+      if (GET_CODE (insn) != NOTE)\n+        break;\n+      if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_PREDICTION)\n+        NOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n+    }\n+\n   insn = b->head;\n \n   never_reached_warning (insn, b->end);"}, {"sha": "adeabe9db0b78ddd7128b89435cc6f121a3b79aa", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/969d70ca573bbd887b1ccfa21130c70b463ad1f9/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/969d70ca573bbd887b1ccfa21130c70b463ad1f9/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=969d70ca573bbd887b1ccfa21130c70b463ad1f9", "patch": "@@ -3731,6 +3731,27 @@ emit_call_insn_before (pattern, before)\n   return insn;\n }\n \n+/* Make an instruction with body PATTERN and code CALL_INSN\n+   and output it before the instruction BEFORE.  */\n+\n+rtx\n+emit_call_insn_after (pattern, before)\n+     rtx pattern, before;\n+{\n+  rtx insn;\n+\n+  if (GET_CODE (pattern) == SEQUENCE)\n+    insn = emit_insn_after (pattern, before);\n+  else\n+    {\n+      insn = make_call_insn_raw (pattern);\n+      add_insn_after (insn, before);\n+      PUT_CODE (insn, CALL_INSN);\n+    }\n+\n+  return insn;\n+}\n+\n /* Make an insn of code BARRIER\n    and output it before the insn BEFORE.  */\n \n@@ -5052,3 +5073,68 @@ restore_line_number_status (old_value)\n {\n   no_line_numbers = old_value;\n }\n+\n+/* Produce exact duplicate of insn INSN after AFTER.\n+   Care updating of libcall regions if present.  */\n+\n+rtx\n+emit_copy_of_insn_after (insn, after)\n+     rtx insn, after;\n+{\n+  rtx new;\n+  rtx note1, note2, link;\n+\n+  switch (GET_CODE (insn))\n+    {\n+    case INSN:\n+      new = emit_insn_after (copy_insn (PATTERN (insn)), after);\n+      break;\n+\n+    case JUMP_INSN:\n+      new = emit_jump_insn_after (copy_insn (PATTERN (insn)), after);\n+      break;\n+\n+    case CALL_INSN:\n+      new = emit_call_insn_after (copy_insn (PATTERN (insn)), after);\n+      if (CALL_INSN_FUNCTION_USAGE (insn))\n+\tCALL_INSN_FUNCTION_USAGE (new)\n+\t  = copy_insn (CALL_INSN_FUNCTION_USAGE (insn));\n+      SIBLING_CALL_P (new) = SIBLING_CALL_P (insn);\n+      CONST_OR_PURE_CALL_P (new) = CONST_OR_PURE_CALL_P (insn);\n+      break;\n+\n+    default:\n+      abort ();\n+    }\n+\n+  /* Update LABEL_NUSES.  */\n+  mark_jump_label (PATTERN (new), new, 0);\n+\n+  /* Copy all REG_NOTES except REG_LABEL since mark_jump_label will\n+     make them.  */\n+  for (link = REG_NOTES (insn); link; link = XEXP (link, 1))\n+    if (REG_NOTE_KIND (link) != REG_LABEL)\n+      {\n+\tif (GET_CODE (link) == EXPR_LIST)\n+\t  REG_NOTES (new)\n+\t    = copy_insn_1 (gen_rtx_EXPR_LIST (REG_NOTE_KIND (link),\n+\t\t\t\t\t      XEXP (link, 0),\n+\t\t\t\t\t      REG_NOTES (new)));\n+\telse\n+\t  REG_NOTES (new)\n+\t    = copy_insn_1 (gen_rtx_INSN_LIST (REG_NOTE_KIND (link),\n+\t\t\t\t\t      XEXP (link, 0),\n+\t\t\t\t\t      REG_NOTES (new)));\n+      }\n+\n+  /* Fix the libcall sequences.  */\n+  if ((note1 = find_reg_note (new, REG_RETVAL, NULL_RTX)) != NULL)\n+    {\n+      rtx p = new;\n+      while ((note2 = find_reg_note (p, REG_LIBCALL, NULL_RTX)) == NULL)\n+\tp = PREV_INSN (p);\n+      XEXP (note1, 0) = p;\n+      XEXP (note2, 0) = new;\n+    }\n+  return new;\n+}"}, {"sha": "289bdc0a1ba18aa3db3eb4a4543aadfa8ae34d2f", "filename": "gcc/output.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/969d70ca573bbd887b1ccfa21130c70b463ad1f9/gcc%2Foutput.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/969d70ca573bbd887b1ccfa21130c70b463ad1f9/gcc%2Foutput.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foutput.h?ref=969d70ca573bbd887b1ccfa21130c70b463ad1f9", "patch": "@@ -145,6 +145,7 @@ extern int regno_uninitialized\t\tPARAMS ((unsigned int));\n extern int regno_clobbered_at_setjmp\tPARAMS ((int));\n extern void find_basic_blocks\t\tPARAMS ((rtx, int, FILE *));\n extern bool cleanup_cfg\t\t\tPARAMS ((int));\n+extern bool delete_unreachable_blocks\tPARAMS ((void));\n extern void check_function_return_warnings PARAMS ((void));\n #endif\n "}, {"sha": "5896c10a1919961a2d09abdd3192596b19343ea2", "filename": "gcc/predict.c", "status": "modified", "additions": 219, "deletions": 28, "changes": 247, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/969d70ca573bbd887b1ccfa21130c70b463ad1f9/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/969d70ca573bbd887b1ccfa21130c70b463ad1f9/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=969d70ca573bbd887b1ccfa21130c70b463ad1f9", "patch": "@@ -61,13 +61,20 @@ static REAL_VALUE_TYPE real_zero, real_one, real_almost_one, real_br_prob_base,\n #define PROB_VERY_LIKELY\t(REG_BR_PROB_BASE - PROB_VERY_UNLIKELY)\n #define PROB_ALWAYS\t\t(REG_BR_PROB_BASE)\n \n+static bool predicted_by_p\t\t PARAMS ((basic_block,\n+\t\t\t\t\t\t  enum br_predictor));\n static void combine_predictions_for_insn PARAMS ((rtx, basic_block));\n static void dump_prediction\t\t PARAMS ((enum br_predictor, int,\n \t\t\t\t\t\t  basic_block, int));\n static void estimate_loops_at_level\t PARAMS ((struct loop *loop));\n static void propagate_freq\t\t PARAMS ((basic_block));\n static void estimate_bb_frequencies\t PARAMS ((struct loops *));\n static void counts_to_freqs\t\t PARAMS ((void));\n+static void process_note_predictions\t PARAMS ((basic_block, int *, int *,\n+                                                  sbitmap *));\n+static void process_note_prediction\t PARAMS ((basic_block, int *, int *,\n+                                                  sbitmap *, int, int));\n+static bool last_basic_block_p           PARAMS ((basic_block));\n \n /* Information we hold about each branch predictor.\n    Filled using information from predict.def.  */\n@@ -96,6 +103,23 @@ static const struct predictor_info predictor_info[]= {\n   {NULL, 0, 0}\n };\n #undef DEF_PREDICTOR\n+/* Return true if the one of outgoing edges is already predicted by\n+   PREDICTOR.  */\n+\n+static bool\n+predicted_by_p (bb, predictor)\n+     basic_block bb;\n+     enum br_predictor predictor;\n+{\n+  rtx note;\n+  if (!INSN_P (bb->end))\n+    return false;\n+  for (note = REG_NOTES (bb->end); note; note = XEXP (note, 1))\n+    if (REG_NOTE_KIND (note) == REG_BR_PRED\n+\t&& INTVAL (XEXP (XEXP (note, 0), 0)) == (int)predictor)\n+      return true;\n+  return false;\n+}\n \n void\n predict_insn (insn, predictor, probability)\n@@ -333,7 +357,6 @@ estimate_probability (loops_info)\n {\n   sbitmap *dominators, *post_dominators;\n   int i;\n-  int found_noreturn = 0;\n \n   dominators = sbitmap_vector_alloc (n_basic_blocks, n_basic_blocks);\n   post_dominators = sbitmap_vector_alloc (n_basic_blocks, n_basic_blocks);\n@@ -357,6 +380,13 @@ estimate_probability (loops_info)\n \t    int header_found = 0;\n \t    edge e;\n \n+\t  /* Bypass loop heuristics on continue statement.  These\n+\t     statements construct loops via \"non-loop\" constructs\n+\t     in the source language and are better to be handled\n+\t     separately.  */\n+\t  if (predicted_by_p (BASIC_BLOCK (j), PRED_CONTINUE))\n+\t    continue;\n+\n \t    /* Loop branch heuristics - predict an edge back to a\n \t       loop's head as taken.  */\n \t    for (e = BASIC_BLOCK(j)->succ; e; e = e->succ_next)\n@@ -389,37 +419,22 @@ estimate_probability (loops_info)\n       rtx cond, earliest;\n       edge e;\n \n-      /* If block has no successor, predict all possible paths to it as\n-         improbable, as the block contains a call to a noreturn function and\n-         thus can be executed only once.  */\n-      if (bb->succ == NULL && !found_noreturn)\n-\t{\n-\t  int y;\n-\n-\t  /* ??? Postdominator claims each noreturn block to be postdominated\n-\t     by each, so we need to run only once.  This needs to be changed\n-\t     once postdominace algorithm is updated to say something more\n-\t     sane.  */\n-\t  found_noreturn = 1;\n-\t  for (y = 0; y < n_basic_blocks; y++)\n-\t    if (!TEST_BIT (post_dominators[y], i))\n-\t      for (e = BASIC_BLOCK (y)->succ; e; e = e->succ_next)\n-\t\tif (e->dest->index >= 0\n-\t\t    && TEST_BIT (post_dominators[e->dest->index], i))\n-\t\t  predict_edge_def (e, PRED_NORETURN, NOT_TAKEN);\n-\t}\n-\n       if (GET_CODE (last_insn) != JUMP_INSN || ! any_condjump_p (last_insn))\n \tcontinue;\n \n       for (e = bb->succ; e; e = e->succ_next)\n \t{\n-\t  /* Predict edges to blocks that return immediately to be\n-\t     improbable.  These are usually used to signal error states.  */\n-\t  if (e->dest == EXIT_BLOCK_PTR\n-\t      || (e->dest->succ && !e->dest->succ->succ_next\n-\t\t  && e->dest->succ->dest == EXIT_BLOCK_PTR))\n-\t    predict_edge_def (e, PRED_ERROR_RETURN, NOT_TAKEN);\n+\t  /* Predict early returns to be probable, as we've already taken\n+\t     care for error returns and other are often used for fast paths\n+\t     trought function.  */\n+\t  if ((e->dest == EXIT_BLOCK_PTR\n+\t       || (e->dest->succ && !e->dest->succ->succ_next\n+\t\t   && e->dest->succ->dest == EXIT_BLOCK_PTR))\n+\t       && !predicted_by_p (bb, PRED_NULL_RETURN)\n+\t       && !predicted_by_p (bb, PRED_CONST_RETURN)\n+\t       && !predicted_by_p (bb, PRED_NEGATIVE_RETURN)\n+\t       && !last_basic_block_p (e->dest))\n+\t    predict_edge_def (e, PRED_EARLY_RETURN, TAKEN);\n \n \t  /* Look for block we are guarding (ie we dominate it,\n \t     but it doesn't postdominate us).  */\n@@ -538,7 +553,8 @@ estimate_probability (loops_info)\n   /* Attach the combined probability to each conditional jump.  */\n   for (i = 0; i < n_basic_blocks; i++)\n     if (GET_CODE (BLOCK_END (i)) == JUMP_INSN\n-\t&& any_condjump_p (BLOCK_END (i)))\n+\t&& any_condjump_p (BLOCK_END (i))\n+\t&& BASIC_BLOCK (i)->succ->succ_next != NULL)\n       combine_predictions_for_insn (BLOCK_END (i), BASIC_BLOCK (i));\n \n   sbitmap_vector_free (post_dominators);\n@@ -620,6 +636,181 @@ expected_value_to_br_prob ()\n     }\n }\n \f\n+/* Check whether this is the last basic block of function.  Commonly tehre\n+   is one extra common cleanup block.  */\n+static bool\n+last_basic_block_p (bb)\n+     basic_block bb;\n+{\n+  return (bb->index == n_basic_blocks - 1\n+\t  || (bb->index == n_basic_blocks - 2\n+\t      && bb->succ && !bb->succ->succ_next\n+\t      && bb->succ->dest->index == n_basic_blocks - 1));\n+}\n+\n+/* Sets branch probabilities according to PREDiction and FLAGS. HEADS[bb->index]\n+   should be index of basic block in that we need to alter branch predictions\n+   (i.e. the first of our dominators such that we do not post-dominate it)\n+   (but we fill this information on demand, so -1 may be there in case this\n+   was not needed yet). */\n+\n+static void\n+process_note_prediction (bb, heads, dominators, post_dominators, pred, flags)\n+     basic_block bb;\n+     int *heads;\n+     int *dominators;\n+     sbitmap *post_dominators;\n+     int pred;\n+     int flags;\n+{\n+  edge e;\n+  int y;\n+  bool taken;\n+\n+  taken = flags & IS_TAKEN;\n+\n+  if (heads[bb->index] < 0)\n+    {\n+      /* This is first time we need this field in heads array; so\n+         find first dominator that we do not post-dominate (we are\n+         using already known members of heads array).  */\n+      int ai = bb->index;\n+      int next_ai = dominators[bb->index];\n+      int head;\n+\n+      while (heads[next_ai] < 0)\n+\t{\n+\t  if (!TEST_BIT (post_dominators[next_ai], bb->index))\n+\t    break;\n+\t  heads[next_ai] = ai;\n+\t  ai = next_ai;\n+\t  next_ai = dominators[next_ai];\n+\t}\n+      if (!TEST_BIT (post_dominators[next_ai], bb->index))\n+\thead = next_ai;\n+      else\n+\thead = heads[next_ai];\n+      while (next_ai != bb->index)\n+\t{\n+\t  next_ai = ai;\n+\t  ai = heads[ai];\n+\t  heads[next_ai] = head;\n+\t}\n+    }\n+  y = heads[bb->index];\n+\n+  /* Now find the edge that leads to our branch and aply the prediction.  */\n+\n+  if (y == n_basic_blocks)\n+    return;\n+  for (e = BASIC_BLOCK (y)->succ; e; e = e->succ_next)\n+    if (e->dest->index >= 0\n+\t&& TEST_BIT (post_dominators[e->dest->index], bb->index))\n+      predict_edge_def (e, pred, taken);\n+}\n+\n+/* Gathers NOTE_INSN_PREDICTIONs in given basic block and turns them\n+   into branch probabilities.  For description of heads array, see\n+   process_note_prediction.  */\n+\n+static void\n+process_note_predictions (bb, heads, dominators, post_dominators)\n+     basic_block bb;\n+     int *heads;\n+     int *dominators;\n+     sbitmap *post_dominators;\n+{\n+  rtx insn;\n+  edge e;\n+\n+  /* Additionaly, we check here for blocks with no successors.  */\n+  int contained_noreturn_call = 0;\n+  int was_bb_head = 0;\n+  int noreturn_block = 1;\n+\n+  for (insn = bb->end; insn;\n+       was_bb_head |= (insn == bb->head), insn = PREV_INSN (insn))\n+    {\n+      if (GET_CODE (insn) != NOTE)\n+\t{\n+\t  if (was_bb_head)\n+\t    break;\n+\t  else\n+\t    {\n+\t      /* Noreturn calls cause program to exit, therefore they are\n+\t         always predicted as not taken.  */\n+\t      if (GET_CODE (insn) == CALL_INSN\n+\t\t  && find_reg_note (insn, REG_NORETURN, NULL))\n+\t\tcontained_noreturn_call = 1;\n+\t      continue;\n+\t    }\n+\t}\n+      if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_PREDICTION)\n+\t{\n+\t  int alg = (int) NOTE_PREDICTION_ALG (insn);\n+\t  /* Process single prediction note.  */\n+\t  process_note_prediction (bb,\n+\t\t\t\t   heads,\n+\t\t\t\t   dominators,\n+\t\t\t\t   post_dominators,\n+\t\t\t\t   alg, (int) NOTE_PREDICTION_FLAGS (insn));\n+\t  delete_insn (insn);\n+\t}\n+    }\n+  for (e = bb->succ; e; e = e->succ_next)\n+    if (!(e->flags & EDGE_FAKE))\n+      noreturn_block = 0;\n+  if (contained_noreturn_call)\n+    {\n+      /* This block ended from other reasons than because of return.\n+         If it is because of noreturn call, this should certainly not\n+         be taken.  Otherwise it is probably some error recovery.  */\n+      process_note_prediction (bb,\n+\t\t\t       heads,\n+\t\t\t       dominators,\n+\t\t\t       post_dominators, PRED_NORETURN, NOT_TAKEN);\n+    }\n+}\n+\n+/* Gathers NOTE_INSN_PREDICTIONs and turns them into\n+   branch probabilities.  */\n+\n+void\n+note_prediction_to_br_prob ()\n+{\n+  int i;\n+  sbitmap *post_dominators;\n+  int *dominators, *heads;\n+\n+  /* To enable handling of noreturn blocks.  */\n+  add_noreturn_fake_exit_edges ();\n+  connect_infinite_loops_to_exit ();\n+\n+  dominators = xmalloc (sizeof (int) * n_basic_blocks);\n+  memset (dominators, -1, sizeof (int) * n_basic_blocks);\n+  post_dominators = sbitmap_vector_alloc (n_basic_blocks, n_basic_blocks);\n+  calculate_dominance_info (NULL, post_dominators, CDI_POST_DOMINATORS);\n+  calculate_dominance_info (dominators, NULL, CDI_DOMINATORS);\n+\n+  heads = xmalloc (sizeof (int) * n_basic_blocks);\n+  memset (heads, -1, sizeof (int) * n_basic_blocks);\n+  heads[0] = n_basic_blocks;\n+\n+  /* Process all prediction notes.  */\n+\n+  for (i = 0; i < n_basic_blocks; ++i)\n+    {\n+      basic_block bb = BASIC_BLOCK (i);\n+      process_note_predictions (bb, heads, dominators, post_dominators);\n+    }\n+\n+  sbitmap_vector_free (post_dominators);\n+  free (dominators);\n+  free (heads);\n+\n+  remove_fake_edges ();\n+}\n+\f\n /* This is used to carry information about basic blocks.  It is\n    attached to the AUX field of the standard CFG block.  */\n "}, {"sha": "0e441314cc0ed0ef7d35cf76664120cfeb89e2cb", "filename": "gcc/predict.def", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/969d70ca573bbd887b1ccfa21130c70b463ad1f9/gcc%2Fpredict.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/969d70ca573bbd887b1ccfa21130c70b463ad1f9/gcc%2Fpredict.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.def?ref=969d70ca573bbd887b1ccfa21130c70b463ad1f9", "patch": "@@ -63,6 +63,9 @@ DEF_PREDICTOR (PRED_LOOP_ITERATIONS, \"loop iterations\", PROB_ALWAYS,\n DEF_PREDICTOR (PRED_BUILTIN_EXPECT, \"__builtin_expect\", PROB_VERY_LIKELY,\n \t       PRED_FLAG_FIRST_MATCH)\n \n+/* Branch containing goto is probably not taken.  */\n+DEF_PREDICTOR (PRED_CONTINUE, \"continue\", HITRATE (56), 0)\n+\n /* Branch to basic block containing call marked by noreturn attribute.  */\n DEF_PREDICTOR (PRED_NORETURN, \"noreturn call\", HITRATE (99),\n \t       PRED_FLAG_FIRST_MATCH)\n@@ -97,4 +100,16 @@ DEF_PREDICTOR (PRED_FPOPCODE, \"fp_opcode\", HITRATE (90), 0)\n DEF_PREDICTOR (PRED_CALL, \"call\", HITRATE (70), 0)\n \n /* Branch causing function to terminate is probably not taken.  */\n-DEF_PREDICTOR (PRED_ERROR_RETURN, \"error return\", HITRATE (52), 0)\n+DEF_PREDICTOR (PRED_EARLY_RETURN, \"early return\", HITRATE (67), 0)\n+\n+/* Branch containing goto is probably not taken.  */\n+DEF_PREDICTOR (PRED_GOTO, \"goto\", HITRATE (70), 0)\n+\n+/* Branch ending with return constant is probably not taken.  */\n+DEF_PREDICTOR (PRED_CONST_RETURN, \"const return\", HITRATE (95), 0)\n+\n+/* Branch ending with return negative constant is probably not taken.  */\n+DEF_PREDICTOR (PRED_NEGATIVE_RETURN, \"negative return\", HITRATE (96), 0)\n+\n+/* Branch ending with return; is probably not taken */\n+DEF_PREDICTOR (PRED_NULL_RETURN, \"null return\", HITRATE (90), 0)"}, {"sha": "a936b56894618e10c1b949046f1c84f1286e2113", "filename": "gcc/predict.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/969d70ca573bbd887b1ccfa21130c70b463ad1f9/gcc%2Fpredict.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/969d70ca573bbd887b1ccfa21130c70b463ad1f9/gcc%2Fpredict.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.h?ref=969d70ca573bbd887b1ccfa21130c70b463ad1f9", "patch": "@@ -34,6 +34,9 @@ enum prediction\n    TAKEN\n };\n \n+/* Flags for NOTE_PREDICTION */\n+#define IS_TAKEN 1\t\t/* Predict edges to the block as taken.  */\n+\n extern void predict_insn_def\tPARAMS ((rtx, enum br_predictor,\n \t\t\t\t\t enum prediction));\n extern void predict_insn\tPARAMS ((rtx, enum br_predictor, int));"}, {"sha": "8cd339ab9891ba6d4a8e46568271917c4782c051", "filename": "gcc/print-rtl.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/969d70ca573bbd887b1ccfa21130c70b463ad1f9/gcc%2Fprint-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/969d70ca573bbd887b1ccfa21130c70b463ad1f9/gcc%2Fprint-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-rtl.c?ref=969d70ca573bbd887b1ccfa21130c70b463ad1f9", "patch": "@@ -284,6 +284,15 @@ print_rtx (in_rtx)\n \t\t  fprintf (outfile, \" \\\"\\\"\");\n \t\tbreak;\n \n+              case NOTE_INSN_PREDICTION:\n+                if (NOTE_PREDICTION (in_rtx))\n+                  fprintf (outfile, \" [ %d %d ] \",\n+                    (int)NOTE_PREDICTION_ALG (in_rtx),\n+                    (int) NOTE_PREDICTION_FLAGS (in_rtx));\n+                else\n+                  fprintf (outfile, \" [ ERROR ]\");\n+                break;\n+                            \n \t      default:\n \t\t{\n \t\t  const char * const str = X0STR (in_rtx, i);"}, {"sha": "2b816d7808b11c294a267a40a7dcac0858e09148", "filename": "gcc/rtl.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/969d70ca573bbd887b1ccfa21130c70b463ad1f9/gcc%2Frtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/969d70ca573bbd887b1ccfa21130c70b463ad1f9/gcc%2Frtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.c?ref=969d70ca573bbd887b1ccfa21130c70b463ad1f9", "patch": "@@ -216,7 +216,8 @@ const char * const note_insn_name[NOTE_INSN_MAX - NOTE_INSN_BIAS] =\n   \"NOTE_INSN_EH_REGION_BEG\", \"NOTE_INSN_EH_REGION_END\",\n   \"NOTE_INSN_REPEATED_LINE_NUMBER\", \"NOTE_INSN_RANGE_BEG\",\n   \"NOTE_INSN_RANGE_END\", \"NOTE_INSN_LIVE\",\n-  \"NOTE_INSN_BASIC_BLOCK\", \"NOTE_INSN_EXPECTED_VALUE\"\n+  \"NOTE_INSN_BASIC_BLOCK\", \"NOTE_INSN_EXPECTED_VALUE\",\n+  \"NOTE_INSN_PREDICTION\"\n };\n \n const char * const reg_note_name[] ="}, {"sha": "f201903159419a370890190870467b5ce53c1a9e", "filename": "gcc/rtl.h", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/969d70ca573bbd887b1ccfa21130c70b463ad1f9/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/969d70ca573bbd887b1ccfa21130c70b463ad1f9/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=969d70ca573bbd887b1ccfa21130c70b463ad1f9", "patch": "@@ -740,6 +740,7 @@ extern const char * const reg_note_name[];\n #define NOTE_LIVE_INFO(INSN)   \tXCEXP (INSN, 3, NOTE)\n #define NOTE_BASIC_BLOCK(INSN)\tXCBBDEF (INSN, 3, NOTE)\n #define NOTE_EXPECTED_VALUE(INSN) XCEXP (INSN, 3, NOTE)\n+#define NOTE_PREDICTION(INSN)   XCINT (INSN, 3, NOTE)\n \n /* In a NOTE that is a line number, this is the line number.\n    Other kinds of NOTEs are identified by negative numbers here.  */\n@@ -750,6 +751,11 @@ extern const char * const reg_note_name[];\n   (GET_CODE (INSN) == NOTE\t\t\t\t\\\n    && NOTE_LINE_NUMBER (INSN) == NOTE_INSN_BASIC_BLOCK)\n \n+/* Algorithm and flags for prediction.  */\n+#define NOTE_PREDICTION_ALG(INSN)   (XCINT(INSN, 3, NOTE)>>8)\n+#define NOTE_PREDICTION_FLAGS(INSN) (XCINT(INSN, 3, NOTE)&0xff)\n+#define NOTE_PREDICT(ALG,FLAGS)     ((ALG<<8)+(FLAGS))\n+\n /* Codes that appear in the NOTE_LINE_NUMBER field\n    for kinds of notes that are not line numbers.\n \n@@ -838,6 +844,9 @@ enum insn_note\n      NOTE_EXPECTED_VALUE; stored as (eq (reg) (const_int)).  */\n   NOTE_INSN_EXPECTED_VALUE,\n \n+  /* Record a prediction.  Uses NOTE_PREDICTION. */\n+  NOTE_INSN_PREDICTION,\n+\n   NOTE_INSN_MAX\n };\n \n@@ -1349,6 +1358,7 @@ extern rtx copy_insn_1\t\t\tPARAMS ((rtx));\n extern rtx copy_insn\t\t\tPARAMS ((rtx));\n extern rtx gen_int_mode\t\t\tPARAMS ((HOST_WIDE_INT,\n \t\t\t\t\t\t enum machine_mode));\n+extern rtx emit_copy_of_insn_after\tPARAMS ((rtx, rtx));\n \n /* In rtl.c */\n extern rtx rtx_alloc\t\t\tPARAMS ((RTX_CODE));\n@@ -1437,6 +1447,7 @@ extern rtx emit_label_before\t\tPARAMS ((rtx, rtx));\n extern rtx emit_note_before\t\tPARAMS ((int, rtx));\n extern rtx emit_insn_after\t\tPARAMS ((rtx, rtx));\n extern rtx emit_jump_insn_after\t\tPARAMS ((rtx, rtx));\n+extern rtx emit_call_insn_after\t\tPARAMS ((rtx, rtx));\n extern rtx emit_barrier_after\t\tPARAMS ((rtx));\n extern rtx emit_label_after\t\tPARAMS ((rtx, rtx));\n extern rtx emit_note_after\t\tPARAMS ((int, rtx));"}, {"sha": "535c827fa1868abe91628f0dc749ba5f89f3c4bf", "filename": "gcc/sibcall.c", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/969d70ca573bbd887b1ccfa21130c70b463ad1f9/gcc%2Fsibcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/969d70ca573bbd887b1ccfa21130c70b463ad1f9/gcc%2Fsibcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsibcall.c?ref=969d70ca573bbd887b1ccfa21130c70b463ad1f9", "patch": "@@ -580,16 +580,6 @@ optimize_sibling_and_tail_recursive_calls ()\n \n   insns = get_insns ();\n \n-  /* We do not perform these calls when flag_exceptions is true, so this\n-     is probably a NOP at the current time.  However, we may want to support\n-     sibling and tail recursion optimizations in the future, so let's plan\n-     ahead and find all the EH labels.  */\n-  find_exception_handler_labels ();\n-\n-  rebuild_jump_labels (insns);\n-  /* We need cfg information to determine which blocks are succeeded\n-     only by the epilogue.  */\n-  find_basic_blocks (insns, max_reg_num (), 0);\n   cleanup_cfg (CLEANUP_PRE_SIBCALL | CLEANUP_PRE_LOOP);\n \n   /* If there are no basic blocks, then there is nothing to do.  */\n@@ -776,4 +766,5 @@ optimize_sibling_and_tail_recursive_calls ()\n \n   /* This information will be invalid after inline expansion.  Kill it now.  */\n   free_basic_block_vars (0);\n+  free_EXPR_LIST_list (&tail_recursion_label_list);\n }"}, {"sha": "639587aa45ef830bb4c3ce58437b0dd4bdbcb262", "filename": "gcc/stmt.c", "status": "modified", "additions": 56, "deletions": 3, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/969d70ca573bbd887b1ccfa21130c70b463ad1f9/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/969d70ca573bbd887b1ccfa21130c70b463ad1f9/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=969d70ca573bbd887b1ccfa21130c70b463ad1f9", "patch": "@@ -54,6 +54,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"output.h\"\n #include \"ggc.h\"\n #include \"langhooks.h\"\n+#include \"predict.h\"\n \n #define obstack_chunk_alloc xmalloc\n #define obstack_chunk_free free\n@@ -414,6 +415,7 @@ static tree resolve_operand_names\tPARAMS ((tree, tree, tree,\n \t\t\t\t\t\t const char **));\n static char *resolve_operand_name_1\tPARAMS ((char *, tree, tree));\n static void expand_null_return_1\tPARAMS ((rtx));\n+static enum br_predictor return_prediction PARAMS ((rtx));\n static void expand_value_return\t\tPARAMS ((rtx));\n static int tail_recursion_args\t\tPARAMS ((tree, tree));\n static void expand_cleanups\t\tPARAMS ((tree, tree, int, int));\n@@ -2824,6 +2826,11 @@ int\n expand_continue_loop (whichloop)\n      struct nesting *whichloop;\n {\n+  /* Emit information for branch prediction.  */\n+  rtx note;\n+\n+  note = emit_note (NULL, NOTE_INSN_PREDICTION);\n+  NOTE_PREDICTION (note) = NOTE_PREDICT (PRED_CONTINUE, IS_TAKEN);\n   last_expr_type = 0;\n   if (whichloop == 0)\n     whichloop = loop_stack;\n@@ -2965,7 +2972,9 @@ expand_exit_something ()\n void\n expand_null_return ()\n {\n-  rtx last_insn = get_last_insn ();\n+  rtx last_insn;\n+\n+  last_insn = get_last_insn ();\n \n   /* If this function was declared to return a value, but we\n      didn't, clobber the return registers so that they are not\n@@ -2975,14 +2984,58 @@ expand_null_return ()\n   expand_null_return_1 (last_insn);\n }\n \n+/* Try to guess whether the value of return means error code.  */\n+static enum br_predictor\n+return_prediction (val)\n+     rtx val;\n+{\n+  /* Different heuristics for pointers and scalars.  */\n+  if (POINTER_TYPE_P (TREE_TYPE (DECL_RESULT (current_function_decl))))\n+    {\n+      /* NULL is usually not returned.  */\n+      if (val == const0_rtx)\n+\treturn PRED_NULL_RETURN;\n+    }\n+  else\n+    {\n+      /* Negative return values are often used to indicate\n+         errors.  */\n+      if (GET_CODE (val) == CONST_INT\n+\t  && INTVAL (val) < 0)\n+\treturn PRED_NEGATIVE_RETURN;\n+      /* Constant return values are also usually erors,\n+         zero/one often mean booleans so exclude them from the\n+\t heuristics.  */\n+      if (CONSTANT_P (val)\n+\t  && (val != const0_rtx && val != const1_rtx))\n+\treturn PRED_CONST_RETURN;\n+    }\n+  return PRED_NO_PREDICTION;\n+}\n+\n /* Generate RTL to return from the current function, with value VAL.  */\n \n static void\n expand_value_return (val)\n      rtx val;\n {\n-  rtx last_insn = get_last_insn ();\n-  rtx return_reg = DECL_RTL (DECL_RESULT (current_function_decl));\n+  rtx last_insn;\n+  rtx return_reg;\n+  enum br_predictor pred;\n+\n+  if ((pred = return_prediction (val)) != PRED_NO_PREDICTION)\n+    {\n+      /* Emit information for branch prediction.  */\n+      rtx note;\n+\n+      note = emit_note (NULL, NOTE_INSN_PREDICTION);\n+\n+      NOTE_PREDICTION (note) = NOTE_PREDICT (pred, NOT_TAKEN);\n+\n+    }\n+\n+  last_insn = get_last_insn ();\n+  return_reg = DECL_RTL (DECL_RESULT (current_function_decl));\n \n   /* Copy the value to the return location\n      unless it's already there.  */"}, {"sha": "572d4c094c17bdf71554d0e2ea8ce251624f08b1", "filename": "gcc/toplev.c", "status": "modified", "additions": 25, "deletions": 5, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/969d70ca573bbd887b1ccfa21130c70b463ad1f9/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/969d70ca573bbd887b1ccfa21130c70b463ad1f9/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=969d70ca573bbd887b1ccfa21130c70b463ad1f9", "patch": "@@ -2492,18 +2492,38 @@ rest_of_compilation (decl)\n       || errorcount || sorrycount)\n     goto exit_rest_of_compilation;\n \n+  timevar_push (TV_JUMP);\n+  open_dump_file (DFI_sibling, decl);\n+  insns = get_insns ();\n+  rebuild_jump_labels (insns);\n+  find_exception_handler_labels ();\n+  find_basic_blocks (insns, max_reg_num (), rtl_dump_file);\n+  \n+  delete_unreachable_blocks ();\n+\n+  /* Turn NOTE_INSN_PREDICTIONs into branch predictions.  */\n+  note_prediction_to_br_prob ();\n+\n   /* We may have potential sibling or tail recursion sites.  Select one\n      (of possibly multiple) methods of performing the call.  */\n   if (flag_optimize_sibling_calls)\n     {\n-      timevar_push (TV_JUMP);\n-      open_dump_file (DFI_sibling, decl);\n-\n+      rtx insn;\n       optimize_sibling_and_tail_recursive_calls ();\n \n-      close_dump_file (DFI_sibling, print_rtl, get_insns ());\n-      timevar_pop (TV_JUMP);\n+      /* There is pass ordering problem - we must lower NOTE_INSN_PREDICTION\n+         notes before simplifying cfg and we must do lowering after sibcall\n+         that unhides parts of RTL chain and cleans up the CFG.\n+        \n+         Until sibcall is replaced by tree-level optimizer, lets just\n+         sweep away the NOTE_INSN_PREDICTION notes that leaked out.  */\n+      for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n+\tif (GET_CODE (insn) == NOTE\n+\t    && NOTE_LINE_NUMBER (insn) == NOTE_INSN_PREDICTION)\n+\t  delete_insn (insn);\n     }\n+   close_dump_file (DFI_sibling, print_rtl, get_insns ());\n+   timevar_pop (TV_JUMP);\n \n   /* Complete generation of exception handling code.  */\n   find_exception_handler_labels ();"}]}