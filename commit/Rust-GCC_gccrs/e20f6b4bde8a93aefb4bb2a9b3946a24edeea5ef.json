{"sha": "e20f6b4bde8a93aefb4bb2a9b3946a24edeea5ef", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTIwZjZiNGJkZThhOTNhZWZiNGJiMmE5YjM5NDZhMjRlZGVlYTVlZg==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2012-02-16T10:20:26Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2012-02-16T10:20:26Z"}, "message": "re PR tree-optimization/52255 (ICE: verify_ssa failed, block does not dominate use)\n\n\tPR tree-optimization/52255\n\t* tree-vect-loop-manip.c (slpeel_tree_peel_loop_to_edge): If\n\tloop->header has virtual PHI, but exit_e->dest doesn't, add\n\tvirtual PHI to exit_e->dest and adjust all uses after the loop.\n\n\t* gcc.c-torture/compile/pr52255.c: New test.\n\nFrom-SVN: r184306", "tree": {"sha": "bcc4d6f1cbee98dbf9bb01d20e7a4e350b084a42", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bcc4d6f1cbee98dbf9bb01d20e7a4e350b084a42"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e20f6b4bde8a93aefb4bb2a9b3946a24edeea5ef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e20f6b4bde8a93aefb4bb2a9b3946a24edeea5ef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e20f6b4bde8a93aefb4bb2a9b3946a24edeea5ef", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e20f6b4bde8a93aefb4bb2a9b3946a24edeea5ef/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "672ed3139a0c2aced7c702f3ce4b26dd34672dd2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/672ed3139a0c2aced7c702f3ce4b26dd34672dd2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/672ed3139a0c2aced7c702f3ce4b26dd34672dd2"}], "stats": {"total": 57, "additions": 56, "deletions": 1}, "files": [{"sha": "e8b5efab3495004e9048e03034b49afc9882b645", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e20f6b4bde8a93aefb4bb2a9b3946a24edeea5ef/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e20f6b4bde8a93aefb4bb2a9b3946a24edeea5ef/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e20f6b4bde8a93aefb4bb2a9b3946a24edeea5ef", "patch": "@@ -1,5 +1,10 @@\n 2012-02-16  Jakub Jelinek  <jakub@redhat.com>\n \n+\tPR tree-optimization/52255\n+\t* tree-vect-loop-manip.c (slpeel_tree_peel_loop_to_edge): If\n+\tloop->header has virtual PHI, but exit_e->dest doesn't, add\n+\tvirtual PHI to exit_e->dest and adjust all uses after the loop.\n+\n \tPR debug/52260\n \t* dwarf2out.c (copy_decls_walk): Fill in *slot before traversing\n \tchildren with clone_tree_hash, not after it."}, {"sha": "76f2bb619fe1ac70d42f70a621eca249cdc4da91", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e20f6b4bde8a93aefb4bb2a9b3946a24edeea5ef/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e20f6b4bde8a93aefb4bb2a9b3946a24edeea5ef/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e20f6b4bde8a93aefb4bb2a9b3946a24edeea5ef", "patch": "@@ -1,5 +1,8 @@\n 2012-02-16  Jakub Jelinek  <jakub@redhat.com>\n \n+\tPR tree-optimization/52255\n+\t* gcc.c-torture/compile/pr52255.c: New test.\n+\n \tPR debug/52260\n \t* g++.dg/debug/dwarf2/pr52260.C: New test.\n "}, {"sha": "e68ae37dcb6160234be1330efd3422e1da5f8bc3", "filename": "gcc/testsuite/gcc.c-torture/compile/pr52255.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e20f6b4bde8a93aefb4bb2a9b3946a24edeea5ef/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr52255.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e20f6b4bde8a93aefb4bb2a9b3946a24edeea5ef/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr52255.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr52255.c?ref=e20f6b4bde8a93aefb4bb2a9b3946a24edeea5ef", "patch": "@@ -0,0 +1,12 @@\n+/* PR tree-optimization/52255 */\n+\n+int a, b, c[10], d[10] = { 0, 0 };\n+\n+void\n+foo (void)\n+{\n+  for (a = 1; a <= 4; a += 1)\n+    d[a] = d[1];\n+  for (; b; ++b)\n+    c[0] |= 1;\n+}"}, {"sha": "70c4f89f6ed3c9be162067270b90e97932dd3d31", "filename": "gcc/tree-vect-loop-manip.c", "status": "modified", "additions": 36, "deletions": 1, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e20f6b4bde8a93aefb4bb2a9b3946a24edeea5ef/gcc%2Ftree-vect-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e20f6b4bde8a93aefb4bb2a9b3946a24edeea5ef/gcc%2Ftree-vect-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop-manip.c?ref=e20f6b4bde8a93aefb4bb2a9b3946a24edeea5ef", "patch": "@@ -513,7 +513,7 @@ slpeel_update_phi_nodes_for_guard1 (edge guard_edge, struct loop *loop,\n        !gsi_end_p (gsi_orig) && !gsi_end_p (gsi_update);\n        gsi_next (&gsi_orig), gsi_next (&gsi_update))\n     {\n-      source_location loop_locus, guard_locus;;\n+      source_location loop_locus, guard_locus;\n       orig_phi = gsi_stmt (gsi_orig);\n       update_phi = gsi_stmt (gsi_update);\n \n@@ -1171,6 +1171,7 @@ slpeel_tree_peel_loop_to_edge (struct loop *loop,\n   basic_block bb_before_first_loop;\n   basic_block bb_between_loops;\n   basic_block new_exit_bb;\n+  gimple_stmt_iterator gsi;\n   edge exit_e = single_exit (loop);\n   LOC loop_loc;\n   tree cost_pre_condition = NULL_TREE;\n@@ -1184,6 +1185,40 @@ slpeel_tree_peel_loop_to_edge (struct loop *loop,\n    the function tree_duplicate_bb is called.  */\n   gimple_register_cfg_hooks ();\n \n+  /* If the loop has a virtual PHI, but exit bb doesn't, create a virtual PHI\n+     in the exit bb and rename all the uses after the loop.  This simplifies\n+     the *guard[12] routines, which assume loop closed SSA form for all PHIs\n+     (but normally loop closed SSA form doesn't require virtual PHIs to be\n+     in the same form).  Doing this early simplifies the checking what\n+     uses should be renamed.  */\n+  for (gsi = gsi_start_phis (loop->header); !gsi_end_p (gsi); gsi_next (&gsi))\n+    if (!is_gimple_reg (gimple_phi_result (gsi_stmt (gsi))))\n+      {\n+\tgimple phi = gsi_stmt (gsi);\n+\tfor (gsi = gsi_start_phis (exit_e->dest);\n+\t     !gsi_end_p (gsi); gsi_next (&gsi))\n+\t  if (!is_gimple_reg (gimple_phi_result (gsi_stmt (gsi))))\n+\t    break;\n+\tif (gsi_end_p (gsi))\n+\t  {\n+\t    gimple new_phi = create_phi_node (SSA_NAME_VAR (PHI_RESULT (phi)),\n+\t\t\t\t\t      exit_e->dest);\n+\t    tree vop = PHI_ARG_DEF_FROM_EDGE (phi, EDGE_SUCC (loop->latch, 0));\n+\t    imm_use_iterator imm_iter;\n+\t    gimple stmt;\n+\t    tree new_vop = make_ssa_name (SSA_NAME_VAR (PHI_RESULT (phi)),\n+\t\t\t\t\t  new_phi);\n+\t    use_operand_p use_p;\n+\n+\t    add_phi_arg (new_phi, vop, exit_e, UNKNOWN_LOCATION);\n+\t    gimple_phi_set_result (new_phi, new_vop);\n+\t    FOR_EACH_IMM_USE_STMT (stmt, imm_iter, vop)\n+\t      if (stmt != new_phi && gimple_bb (stmt) != loop->header)\n+\t\tFOR_EACH_IMM_USE_ON_STMT (use_p, imm_iter)\n+\t\t  SET_USE (use_p, new_vop);\n+\t  }\n+\tbreak;\n+      }\n \n   /* 1. Generate a copy of LOOP and put it on E (E is the entry/exit of LOOP).\n         Resulting CFG would be:"}]}