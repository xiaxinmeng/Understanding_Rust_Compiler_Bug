{"sha": "4ad5b1915d50cc39691487f58794d699c7900ace", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGFkNWIxOTE1ZDUwY2MzOTY5MTQ4N2Y1ODc5NGQ2OTljNzkwMGFjZQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2021-03-03T08:51:54Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2021-03-03T08:51:54Z"}, "message": "cfgrtl: Fix up fixup_partitions caused ICE [PR99085]\n\nfixup_partitions sometimes changes some basic blocks from hot partition to\ncold partition, in particular if after unreachable block removal or other\noptimizations a hot partition block is dominated by cold partition block(s).\nIt fixes up the edges and jumps on those edges, but when after reorder\nblocks and in rtl (non-cfglayout) mode that is clearly not enough, because\nit keeps the block order the same and so we can end up with more than\n1 hot/cold section transition in the same function.\n\nSo, this patch fixes that up too.\n\n2021-03-03  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR target/99085\n\t* cfgrtl.c (fixup_partitions): When changing some bbs from hot to cold\n\tpartitions, if in non-layout mode after reorder_blocks also move\n\taffected blocks to ensure a single partition transition.\n\n\t* gcc.dg/graphite/pr99085.c: New test.", "tree": {"sha": "070eb24c4c456a40d89f7d3583567ffe78c7a733", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/070eb24c4c456a40d89f7d3583567ffe78c7a733"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4ad5b1915d50cc39691487f58794d699c7900ace", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ad5b1915d50cc39691487f58794d699c7900ace", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4ad5b1915d50cc39691487f58794d699c7900ace", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ad5b1915d50cc39691487f58794d699c7900ace/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "006693a59f7cd1310aed53a2816020bedf1fb742", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/006693a59f7cd1310aed53a2816020bedf1fb742", "html_url": "https://github.com/Rust-GCC/gccrs/commit/006693a59f7cd1310aed53a2816020bedf1fb742"}], "stats": {"total": 79, "additions": 74, "deletions": 5}, "files": [{"sha": "efd7a81ecc20c2c0443b0a4d2b98ff31002c14ce", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 54, "deletions": 5, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ad5b1915d50cc39691487f58794d699c7900ace/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ad5b1915d50cc39691487f58794d699c7900ace/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=4ad5b1915d50cc39691487f58794d699c7900ace", "patch": "@@ -2414,8 +2414,6 @@ find_partition_fixes (bool flag_only)\n void\n fixup_partitions (void)\n {\n-  basic_block bb;\n-\n   if (!crtl->has_bb_partition)\n     return;\n \n@@ -2436,10 +2434,61 @@ fixup_partitions (void)\n   /* Do the partition fixup after all necessary blocks have been converted to\n      cold, so that we only update the region crossings the minimum number of\n      places, which can require forcing edges to be non fallthru.  */\n-  while (! bbs_to_fix.is_empty ())\n+  if (! bbs_to_fix.is_empty ())\n     {\n-      bb = bbs_to_fix.pop ();\n-      fixup_new_cold_bb (bb);\n+      do\n+\t{\n+\t  basic_block bb = bbs_to_fix.pop ();\n+\t  fixup_new_cold_bb (bb);\n+\t}\n+      while (! bbs_to_fix.is_empty ());\n+\n+      /* Fix up hot cold block grouping if needed.  */\n+      if (crtl->bb_reorder_complete && current_ir_type () == IR_RTL_CFGRTL)\n+\t{\n+\t  basic_block bb, first = NULL, second = NULL;\n+\t  int current_partition = BB_UNPARTITIONED;\n+\n+\t  FOR_EACH_BB_FN (bb, cfun)\n+\t    {\n+\t      if (current_partition != BB_UNPARTITIONED\n+\t\t  && BB_PARTITION (bb) != current_partition)\n+\t\t{\n+\t\t  if (first == NULL)\n+\t\t    first = bb;\n+\t\t  else if (second == NULL)\n+\t\t    second = bb;\n+\t\t  else\n+\t\t    {\n+\t\t      /* If we switch partitions for the 3rd, 5th etc. time,\n+\t\t\t move bbs first (inclusive) .. second (exclusive) right\n+\t\t\t before bb.  */\n+\t\t      basic_block prev_first = first->prev_bb;\n+\t\t      basic_block prev_second = second->prev_bb;\n+\t\t      basic_block prev_bb = bb->prev_bb;\n+\t\t      prev_first->next_bb = second;\n+\t\t      second->prev_bb = prev_first;\n+\t\t      prev_second->next_bb = bb;\n+\t\t      bb->prev_bb = prev_second;\n+\t\t      prev_bb->next_bb = first;\n+\t\t      first->prev_bb = prev_bb;\n+\t\t      rtx_insn *prev_first_insn = PREV_INSN (BB_HEAD (first));\n+\t\t      rtx_insn *prev_second_insn\n+\t\t\t= PREV_INSN (BB_HEAD (second));\n+\t\t      rtx_insn *prev_bb_insn = PREV_INSN (BB_HEAD (bb));\n+\t\t      SET_NEXT_INSN (prev_first_insn) = BB_HEAD (second);\n+\t\t      SET_PREV_INSN (BB_HEAD (second)) = prev_first_insn;\n+\t\t      SET_NEXT_INSN (prev_second_insn) = BB_HEAD (bb);\n+\t\t      SET_PREV_INSN (BB_HEAD (bb)) = prev_second_insn;\n+\t\t      SET_NEXT_INSN (prev_bb_insn) = BB_HEAD (first);\n+\t\t      SET_PREV_INSN (BB_HEAD (first)) = prev_bb_insn;\n+\t\t      second = NULL;\n+\t\t    }\n+\t\t}\n+\t      current_partition = BB_PARTITION (bb);\n+\t    }\n+\t  gcc_assert (!second);\n+\t}\n     }\n }\n "}, {"sha": "dc1c9359ef0c11cc81f1d371627f230298f1de1c", "filename": "gcc/testsuite/gcc.dg/graphite/pr99085.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ad5b1915d50cc39691487f58794d699c7900ace/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr99085.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ad5b1915d50cc39691487f58794d699c7900ace/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr99085.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr99085.c?ref=4ad5b1915d50cc39691487f58794d699c7900ace", "patch": "@@ -0,0 +1,20 @@\n+/* PR target/99085 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fgraphite-identity -fsel-sched-pipelining -fselective-scheduling2\" } */\n+\n+void\n+foo (int m, int n, int o, int i)\n+{\n+  long double a2[m];\n+  int c2[n][o];\n+  int j, k;\n+\n+  while (i < m)\n+    a2[i++] = 13.132L;\n+\n+  for (j = 0; j < n; j++)\n+    for (k = 0; k < o; k++)\n+      c2[j][k] = 1;\n+\n+  __builtin_abort ();\n+}"}]}