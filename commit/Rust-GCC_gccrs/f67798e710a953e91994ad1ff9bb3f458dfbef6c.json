{"sha": "f67798e710a953e91994ad1ff9bb3f458dfbef6c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjY3Nzk4ZTcxMGE5NTNlOTE5OTRhZDFmZjliYjNmNDU4ZGZiZWY2Yw==", "commit": {"author": {"name": "Neil Booth", "email": "neilb@earthling.net", "date": "2000-07-16T13:35:23Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2000-07-16T13:35:23Z"}, "message": "cpplex.c: Update comments.\n\n\t* cpplex.c: Update comments.\n\t* README.Portability: Small update.\n\nFrom-SVN: r35058", "tree": {"sha": "b0c9d9345b06aeca451f4412634176000d523856", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b0c9d9345b06aeca451f4412634176000d523856"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f67798e710a953e91994ad1ff9bb3f458dfbef6c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f67798e710a953e91994ad1ff9bb3f458dfbef6c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f67798e710a953e91994ad1ff9bb3f458dfbef6c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f67798e710a953e91994ad1ff9bb3f458dfbef6c/comments", "author": null, "committer": null, "parents": [{"sha": "bf4467813b6b51c4eabaf8b4865c1e4ac09b0ad9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf4467813b6b51c4eabaf8b4865c1e4ac09b0ad9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bf4467813b6b51c4eabaf8b4865c1e4ac09b0ad9"}], "stats": {"total": 180, "additions": 175, "deletions": 5}, "files": [{"sha": "900d10e39dca3c554bf85fd249bc7f9f220fc4eb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f67798e710a953e91994ad1ff9bb3f458dfbef6c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f67798e710a953e91994ad1ff9bb3f458dfbef6c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f67798e710a953e91994ad1ff9bb3f458dfbef6c", "patch": "@@ -1,3 +1,8 @@\n+2000-07-16  Neil Booth  <NeilB@earthling.net>\n+\n+\t* cpplex.c: Update comments.\n+\t* README.Portability: Small update.\n+\n 2000-07-16  Neil Booth  <NeilB@earthling.net>\n \n \t* README.Portability:  Small update."}, {"sha": "d69c3869b3fe88facf80c5a521ba496be6515efe", "filename": "gcc/README.Portability", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f67798e710a953e91994ad1ff9bb3f458dfbef6c/gcc%2FREADME.Portability", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f67798e710a953e91994ad1ff9bb3f458dfbef6c/gcc%2FREADME.Portability", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FREADME.Portability?ref=f67798e710a953e91994ad1ff9bb3f458dfbef6c", "patch": "@@ -46,6 +46,10 @@ should be written\n \n   free ((PTR) h->value.expansion);\n \n+Further, an initial investigation indicates that pointers to functions\n+returning void are okay.  Thus the example given by \"Calling functions\n+through pointers to functions\" below appears not to cause a problem.\n+\n \n String literals\n ---------------\n@@ -87,7 +91,7 @@ needs to be coded in some other way.\n signed keyword\n --------------\n \n-The signed keyword did not exist in K+R compilers, it was introduced\n+The signed keyword did not exist in K+R compilers; it was introduced\n in ISO C89, so you cannot use it.  In both K+R and standard C,\n unqualified char and bitfields may be signed or unsigned.  There is no\n way to portably declare signed chars or signed bitfields."}, {"sha": "fe337c0a852bf72b4e44a45fbb2c56e4e665c62e", "filename": "gcc/cpplex.c", "status": "modified", "additions": 165, "deletions": 4, "changes": 169, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f67798e710a953e91994ad1ff9bb3f458dfbef6c/gcc%2Fcpplex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f67798e710a953e91994ad1ff9bb3f458dfbef6c/gcc%2Fcpplex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplex.c?ref=f67798e710a953e91994ad1ff9bb3f458dfbef6c", "patch": "@@ -71,7 +71,8 @@ struct cpp_context\n   /* Pushed token to be returned by next call to get_raw_token.  */\n   const cpp_token *pushed_token;\n \n-  struct macro_args *args;\t/* 0 for arguments and object-like macros.  */\n+  struct macro_args *args;\t/* The arguments for a function-like\n+\t\t\t\t   macro.  NULL otherwise.  */\n   unsigned short posn;\t\t/* Current posn, index into u.  */\n   unsigned short count;\t\t/* No. of tokens in u.  */\n   unsigned short level;\n@@ -762,8 +763,7 @@ cpp_ideq (token, string)\n  have been pushed on the top of the stack as a CPP_BACKSLASH.  The\n  newline ('\\n' or '\\r') handler looks at the token at the top of the\n  stack to see if it is a CPP_BACKSLASH, and if so discards both.\n- Otherwise it pushes the newline (CPP_VSPACE) token as normal.  Hence\n- the '=' handler would never see any intervening escaped newlines.\n+ Hence the '=' handler would never see any intervening tokens.\n \n  To make trigraphs work in this context, as in precedence trigraphs\n  are highest and converted before anything else, the '?' handler does\n@@ -2023,7 +2023,168 @@ _cpp_spell_operator (type)\n }\n \n \n-/* Macro expansion algorithm.  TODO.  */\n+/* Macro expansion algorithm.\n+\n+Macro expansion is implemented by a single-pass algorithm; there are\n+no rescan passes involved.  cpp_get_token expands just enough to be\n+able to return a token to the caller, a consequence is that when it\n+returns the preprocessor can be in a state of mid-expansion.  The\n+algorithm does not work by fully expanding a macro invocation into\n+some kind of token list, and then returning them one by one.\n+\n+Our expansion state is recorded in a context stack.  We start out with\n+a single context on the stack, let's call it base context.  This\n+consists of the token list returned by lex_line that forms the next\n+logical line in the source file.\n+\n+The current level in the context stack is stored in the cur_context\n+member of the cpp_reader structure.  The context it references keeps,\n+amongst other things, a count of how many tokens form that context and\n+our position within those tokens.\n+\n+Fundamentally, calling cpp_get_token will return the next token from\n+the current context.  If we're at the end of the current context, that\n+context is popped from the stack first, unless it is the base context,\n+in which case the next logical line is lexed from the source file.\n+\n+However, before returning the token, if it is a CPP_NAME token\n+_cpp_get_token checks to see if it is a macro and if it is enabled.\n+Each time it encounters a macro name, it calls push_macro_context.\n+This function checks that the macro should be expanded (with\n+is_macro_enabled), and if so pushes a new macro context on the stack\n+which becomes the current context.  It then loops back to read the\n+first token of the macro context.\n+\n+A macro context basically consists of the token list representing the\n+macro's replacement list, which was saved in the hash table by\n+save_macro_expansion when its #define statement was parsed.  If the\n+macro is function-like, it also contains the tokens that form the\n+arguments to the macro.  I say more about macro arguments below, but\n+for now just saying that each argument is a set of pointers to tokens\n+is enough.\n+\n+When taking tokens from a macro context, we may get a CPP_MACRO_ARG\n+token.  This represents an argument passed to the macro, with the\n+argument number stored in the token's AUX field.  The argument should\n+be substituted, this is achieved by pushing an \"argument context\".  An\n+argument context is just refers to the tokens forming the argument,\n+which are obtained directly from the macro context.  The STRINGIFY\n+flag on a CPP_MACRO_ARG token indicates that the argument should be\n+stringified.\n+\n+Here's a few simple rules the context stack obeys:-\n+\n+  1) The lex_line token list is always context zero.\n+\n+  2) Context 1, if it exists, must be a macro context.\n+\n+  3) An argument context can only appear above a macro context.\n+\n+  4) A macro context can appear above the base context, another macro\n+  context, or an argument context.\n+\n+  5) These imply that the minimal level of an argument context is 2.\n+\n+The only tricky thing left is ensuring that macros are enabled and\n+disabled correctly.  The algorithm controls macro expansion by the\n+level of the context a token is taken from in the context stack.  If a\n+token is taken from a level equal to no_expand_level (a member of\n+struct cpp_reader), no expansion is performed.\n+\n+When popping a context off the stack, if no_expand_level equals the\n+level of the popped context, it is reduced by one to match the new\n+context level, so that expansion is still disabled.  It does not\n+increase if a context is pushed, though.  It starts out life as\n+UINT_MAX, which has the effect that initially macro expansion is\n+enabled.  I explain how this mechanism works below.\n+\n+The standard requires:-\n+\n+  1) Arguments to be fully expanded before substitution.\n+\n+  2) Stringified arguments to not be expanded, nor the tokens\n+  immediately surrounding a ## operator.\n+\n+  3) Continual rescanning until there are no more macros left to\n+  replace.\n+\n+  4) Once a macro has been expanded in stage 1) or 3), it cannot be\n+  expanded again during later rescans.  This prevents infinite\n+  recursion.\n+\n+The first thing to observe is that stage 3) is mostly redundant.\n+Since a macro is disabled once it has been expanded, how can a rescan\n+find an unexpanded macro name?  There are only two cases where this is\n+possible:-\n+\n+  a) If the macro name results from a token paste operation.\n+\n+  b) If the macro in question is a function-like macro that hasn't\n+  already been expanded because previously there was not the required\n+  '(' token immediately following it.  This is only possible when an\n+  argument is substituted, and after substitution the last token of\n+  the argument can bind with a parenthesis appearing in the tokens\n+  following the substitution.  Note that if the '(' appears within the\n+  argument, the ')' must too, as expanding macro arguments cannot\n+  \"suck in\" tokens outside the argument.\n+\n+So we tackle this as follows.  When parsing the macro invocation for\n+arguments, we record the tokens forming each argument as a list of\n+pointers to those tokens.  We do not expand any tokens that are \"raw\",\n+i.e. directly from the macro invocation, but other tokens that come\n+from (nested) argument substitution are fully expanded.\n+\n+This is achieved by setting the no_expand_level to that of the macro\n+invocation.  A CPP_MACRO_ARG token never appears in the list of tokens\n+forming an argument, because parse_args (indirectly) calls\n+get_raw_token which automatically pushes argument contexts and traces\n+into them.  Since these contexts are at a higher level than the\n+no_expand_level, they get fully macro expanded.\n+\n+\"Raw\" and non-raw tokens are separated in arguments by null pointers,\n+with the policy that the initial state of an argument is raw.  If the\n+first token is not raw, it should be preceded by a null pointer.  When\n+tracing through the tokens of an argument context, each time\n+get_raw_token encounters a null pointer, it toggles the flag\n+CONTEXT_RAW.\n+\n+This flag, when set, indicates to is_macro_disabled that we are\n+reading raw tokens which should be macro-expanded.  Similarly, if\n+clear, is_macro_disabled suppresses re-expansion.\n+\n+It's probably time for an example.\n+\n+#define hash #\n+#define str(x) #x\n+#define xstr(y) str(y hash)\n+str(hash)\t\t\t// \"hash\"\n+xstr(hash)\t\t\t// \"# hash\"\n+\n+In the invocation of str, parse_args turns off macro expansion and so\n+parses the argument as <hash>.  This is the only token (pointer)\n+passed as the argument to str.  Since <hash> is raw there is no need\n+for an initial null pointer.  stringify_arg is called from\n+get_raw_token when tracing through the expansion of str, since the\n+argument has the STRINGIFY flag set.  stringify_arg turns off\n+macro_expansion by setting the no_expand_level to that of the argument\n+context.  Thus it gets the token <hash> and stringifies it to \"hash\"\n+correctly.\n+\n+Similary xstr is passed <hash>.  However, when parse_args is parsing\n+the invocation of str() in xstr's expansion, get_raw_token encounters\n+a CPP_MACRO_ARG token for y.  Transparently to parse_args, it pushes\n+an argument context, and enters the tokens of the argument,\n+i.e. <hash>.  This is at a higher context level than parse_args\n+disabled, and so is_macro_disabled permits expansion of it and a macro\n+context is pushed on top of the argument context.  This contains the\n+<#> token, and the end result is that <hash> is macro expanded.\n+However, after popping off the argument context, the <hash> of xstr's\n+expansion does not get macro expanded because we're back at the\n+no_expand_level.  The end result is that the argument passed to str is\n+<NULL> <#> <NULL> <hash>.  Note the nulls - policy is we start off\n+raw, <#> is not raw, but then <hash> is.\n+\n+*/\n \n \n /* Free the storage allocated for macro arguments.  */"}]}