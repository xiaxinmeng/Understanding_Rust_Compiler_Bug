{"sha": "294ccb21c4d993c4fd9f4220e0ee8513a1666894", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mjk0Y2NiMjFjNGQ5OTNjNGZkOWY0MjIwZTBlZTg1MTNhMTY2Njg5NA==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2007-12-13T10:30:55Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-12-13T10:30:55Z"}, "message": "sem_ch8.adb (Analyze_Subprogram_Renaming): Special error message for renaming entry as subprogram using rename-as-body if...\n\n2007-12-06  Robert Dewar  <dewar@adacore.com>\n\t    Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch8.adb (Analyze_Subprogram_Renaming): Special error message for\n\trenaming entry as subprogram using rename-as-body if subprogram spec\n\tfrozen.\n\t(Use_One_Type): The clause is legal on an access type whose designated\n\ttype has a limited view.\n\t(Find_Direct_Name): Use Namet.Sp.Is_Bad_Spelling_Of function\n\t(Find_Expanded_Name): Use Namet.Sp.Is_Bad_Spelling_Of function\n\t(Analyze_Renamed_Primitive_Operation): new procedure to determine the\n\toperation denoted by a selected component.\n\t(Analyze_Renamed_Entry): Resolve the prefix of the entry name, because\n\tit can be an expression, possibly overloaded, that returns a task or\n\tan access to one.\n\nFrom-SVN: r130854", "tree": {"sha": "7bdf5ce371466b8c858b1015ea3156681c6a3ba4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7bdf5ce371466b8c858b1015ea3156681c6a3ba4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/294ccb21c4d993c4fd9f4220e0ee8513a1666894", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/294ccb21c4d993c4fd9f4220e0ee8513a1666894", "html_url": "https://github.com/Rust-GCC/gccrs/commit/294ccb21c4d993c4fd9f4220e0ee8513a1666894", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/294ccb21c4d993c4fd9f4220e0ee8513a1666894/comments", "author": null, "committer": null, "parents": [{"sha": "d469eabed98420f0bdd2895d47e11829e3bb76d9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d469eabed98420f0bdd2895d47e11829e3bb76d9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d469eabed98420f0bdd2895d47e11829e3bb76d9"}], "stats": {"total": 348, "additions": 276, "deletions": 72}, "files": [{"sha": "ec2047b749efedff136411c912a781ec931be40d", "filename": "gcc/ada/sem_ch8.adb", "status": "modified", "additions": 276, "deletions": 72, "changes": 348, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/294ccb21c4d993c4fd9f4220e0ee8513a1666894/gcc%2Fada%2Fsem_ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/294ccb21c4d993c4fd9f4220e0ee8513a1666894/gcc%2Fada%2Fsem_ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch8.adb?ref=294ccb21c4d993c4fd9f4220e0ee8513a1666894", "patch": "@@ -37,6 +37,7 @@ with Lib;      use Lib;\n with Lib.Load; use Lib.Load;\n with Lib.Xref; use Lib.Xref;\n with Namet;    use Namet;\n+with Namet.Sp; use Namet.Sp;\n with Nlists;   use Nlists;\n with Nmake;    use Nmake;\n with Opt;      use Opt;\n@@ -64,8 +65,6 @@ with Table;\n with Tbuild;   use Tbuild;\n with Uintp;    use Uintp;\n \n-with GNAT.Spelling_Checker; use GNAT.Spelling_Checker;\n-\n package body Sem_Ch8 is\n \n    ------------------------------------\n@@ -388,6 +387,14 @@ package body Sem_Ch8 is\n    --  Used when the renamed entity is an indexed component. The prefix must\n    --  denote an entry family.\n \n+   procedure Analyze_Renamed_Primitive_Operation\n+     (N       : Node_Id;\n+      New_S   : Entity_Id;\n+      Is_Body : Boolean);\n+   --  If the renamed entity in a subprogram renaming is a primitive operation\n+   --  or a class-wide operation in prefix form, save the target object, which\n+   --  must be added to the list of actuals in any subsequent call.\n+\n    function Applicable_Use (Pack_Name : Node_Id) return Boolean;\n    --  Common code to Use_One_Package and Set_Use, to determine whether\n    --  use clause must be processed. Pack_Name is an entity name that\n@@ -916,7 +923,7 @@ package body Sem_Ch8 is\n \n         or else (Nkind (Original_Node (Nam)) = N_Attribute_Reference\n                   and then Is_Function_Attribute_Name\n-                    (Attribute_Name (Original_Node (Nam))))\n+                             (Attribute_Name (Original_Node (Nam))))\n \n             --  Weird but legal, equivalent to renaming a function call.\n             --  Illegal if the literal is the result of constant-folding an\n@@ -974,7 +981,7 @@ package body Sem_Ch8 is\n       end if;\n \n       --  Apply Text_IO kludge here, since we may be renaming one of the\n-      --  children of Text_IO\n+      --  children of Text_IO.\n \n       Text_IO_Kludge (Name (N));\n \n@@ -1014,6 +1021,8 @@ package body Sem_Ch8 is\n          Set_Ekind (New_P, E_Package);\n          Set_Etype (New_P, Standard_Void_Type);\n \n+      --  Here for OK package renaming\n+\n       else\n          --  Entities in the old package are accessible through the renaming\n          --  entity. The simplest implementation is to have both packages share\n@@ -1036,6 +1045,24 @@ package body Sem_Ch8 is\n          Check_Library_Unit_Renaming (N, Old_P);\n          Generate_Reference (Old_P, Name (N));\n \n+         --  If the renaming is in the visible part of a package, then we set\n+         --  In_Package_Spec for the renamed package, to prevent giving\n+         --  warnings about no entities referenced. Such a warning would be\n+         --  overenthusiastic, since clients can see entities in the renamed\n+         --  package via the visible package renaming.\n+\n+         declare\n+            Ent : constant Entity_Id := Cunit_Entity (Current_Sem_Unit);\n+         begin\n+            if Ekind (Ent) = E_Package\n+              and then not In_Private_Part (Ent)\n+              and then In_Extended_Main_Source_Unit (N)\n+              and then Ekind (Old_P) = E_Package\n+            then\n+               Set_Renamed_In_Spec (Old_P);\n+            end if;\n+         end;\n+\n          --  If this is the renaming declaration of a package instantiation\n          --  within itself, it is the declaration that ends the list of actuals\n          --  for the instantiation. At this point, the subtypes that rename\n@@ -1084,7 +1111,6 @@ package body Sem_Ch8 is\n             end;\n          end if;\n       end if;\n-\n    end Analyze_Package_Renaming;\n \n    -------------------------------\n@@ -1210,6 +1236,11 @@ package body Sem_Ch8 is\n          end if;\n \n          Inherit_Renamed_Profile (New_S, Old_S);\n+\n+         --  The prefix can be an arbitrary expression that yields a task\n+         --  type, so it must be resolved.\n+\n+         Resolve (Prefix (Nam), Scope (Old_S));\n       end if;\n \n       Set_Convention (New_S, Convention (Old_S));\n@@ -1265,6 +1296,114 @@ package body Sem_Ch8 is\n       end if;\n    end Analyze_Renamed_Family_Member;\n \n+   -----------------------------------------\n+   -- Analyze_Renamed_Primitive_Operation --\n+   -----------------------------------------\n+\n+   procedure Analyze_Renamed_Primitive_Operation\n+     (N       : Node_Id;\n+      New_S   : Entity_Id;\n+      Is_Body : Boolean)\n+   is\n+      Old_S : Entity_Id;\n+\n+      function Conforms\n+        (Subp : Entity_Id;\n+         Ctyp : Conformance_Type) return Boolean;\n+      --  Verify that the signatures of the renamed entity and the new entity\n+      --  match. The first formal of the renamed entity is skipped because it\n+      --  is the target object in any subsequent call.\n+\n+      function Conforms\n+        (Subp : Entity_Id;\n+         Ctyp : Conformance_Type) return Boolean\n+      is\n+         Old_F : Entity_Id;\n+         New_F : Entity_Id;\n+\n+      begin\n+         if Ekind (Subp) /= Ekind (New_S) then\n+            return False;\n+         end if;\n+\n+         Old_F := Next_Formal (First_Formal (Subp));\n+         New_F := First_Formal (New_S);\n+         while Present (Old_F) and then Present (New_F) loop\n+            if not Conforming_Types (Etype (Old_F), Etype (New_F), Ctyp) then\n+               return False;\n+            end if;\n+\n+            if Ctyp >= Mode_Conformant\n+              and then Ekind (Old_F) /= Ekind (New_F)\n+            then\n+               return False;\n+            end if;\n+\n+            Next_Formal (New_F);\n+            Next_Formal (Old_F);\n+         end loop;\n+\n+         return True;\n+      end Conforms;\n+\n+   begin\n+      if not Is_Overloaded (Selector_Name (Name (N))) then\n+         Old_S := Entity (Selector_Name (Name (N)));\n+\n+         if not Conforms (Old_S, Type_Conformant) then\n+            Old_S := Any_Id;\n+         end if;\n+\n+      else\n+         --  Find the operation that matches the given signature\n+\n+         declare\n+            It  : Interp;\n+            Ind : Interp_Index;\n+\n+         begin\n+            Old_S := Any_Id;\n+            Get_First_Interp (Selector_Name (Name (N)), Ind, It);\n+\n+            while Present (It.Nam) loop\n+               if Conforms (It.Nam, Type_Conformant) then\n+                  Old_S := It.Nam;\n+               end if;\n+\n+               Get_Next_Interp (Ind, It);\n+            end loop;\n+         end;\n+      end if;\n+\n+      if Old_S = Any_Id then\n+         Error_Msg_N (\" no subprogram or entry matches specification\",  N);\n+\n+      else\n+         if Is_Body then\n+            if not Conforms (Old_S, Subtype_Conformant) then\n+               Error_Msg_N (\"subtype conformance error in renaming\", N);\n+            end if;\n+\n+            Generate_Reference (New_S, Defining_Entity (N), 'b');\n+            Style.Check_Identifier (Defining_Entity (N), New_S);\n+\n+         else\n+            --  Only mode conformance required for a renaming_as_declaration\n+\n+            if not Conforms (Old_S, Mode_Conformant) then\n+               Error_Msg_N (\"mode conformance error in renaming\", N);\n+            end if;\n+         end if;\n+\n+         --  Inherit_Renamed_Profile (New_S, Old_S);\n+\n+         --  The prefix can be an arbitrary expression that yields an\n+         --  object, so it must be resolved.\n+\n+         Resolve (Prefix (Name (N)));\n+      end if;\n+   end Analyze_Renamed_Primitive_Operation;\n+\n    ---------------------------------\n    -- Analyze_Subprogram_Renaming --\n    ---------------------------------\n@@ -1573,14 +1712,17 @@ package body Sem_Ch8 is\n \n       Rename_Spec := Find_Corresponding_Spec (N);\n \n+      --  Case of Renaming_As_Body\n+\n       if Present (Rename_Spec) then\n \n-         --  Renaming_As_Body. Renaming declaration is the completion of\n-         --  the declaration of Rename_Spec. We will build an actual body\n-         --  for it at the freezing point.\n+         --  Renaming declaration is the completion of the declaration of\n+         --  Rename_Spec. We build an actual body for it at the freezing point.\n \n          Set_Corresponding_Spec (N, Rename_Spec);\n \n+         --  Deal with special case of Input and Output stream functions\n+\n          if Nkind (Unit_Declaration_Node (Rename_Spec)) =\n                                      N_Abstract_Subprogram_Declaration\n          then\n@@ -1622,6 +1764,13 @@ package body Sem_Ch8 is\n          Check_Fully_Conformant (New_S, Rename_Spec);\n          Set_Public_Status (New_S);\n \n+         --  The specification does not introduce new formals, but only\n+         --  repeats the formals of the original subprogram declaration.\n+         --  For cross-reference purposes, and for refactoring tools, we\n+         --  treat the formals of the renaming declaration as body formals.\n+\n+         Reference_Body_Formals (Rename_Spec, New_S);\n+\n          --  Indicate that the entity in the declaration functions like the\n          --  corresponding body, and is not a new entity. The body will be\n          --  constructed later at the freeze point, so indicate that the\n@@ -1645,6 +1794,8 @@ package body Sem_Ch8 is\n               (\"subprogram& overrides inherited operation\", N, Rename_Spec);\n          end if;\n \n+      --  Normal subprogram renaming (not renaming as body)\n+\n       else\n          Generate_Definition (New_S);\n          New_Overloaded_Entity (New_S);\n@@ -1671,12 +1822,57 @@ package body Sem_Ch8 is\n \n       elsif Nkind (Nam) = N_Selected_Component then\n \n-         --  Renamed entity is an entry or protected subprogram. For those\n-         --  cases an explicit body is built (at the point of freezing of this\n-         --  entity) that contains a call to the renamed entity.\n+         --  A prefix of the form  A.B can designate an entry of task A, a\n+         --  protected operation of protected object A, or finally a primitive\n+         --  operation of object A. In the later case, A is an object of some\n+         --  tagged type, or an access type that denotes one such. To further\n+         --  distinguish these cases, note that the scope of a task entry or\n+         --  protected operation is type of the prefix.\n \n-         Analyze_Renamed_Entry (N, New_S, Present (Rename_Spec));\n-         return;\n+         --  The prefix could be an overloaded function call that returns both\n+         --  kinds of operations. This overloading pathology is left to the\n+         --  dedicated reader ???\n+\n+         declare\n+            T : constant Entity_Id := Etype (Prefix (Nam));\n+\n+         begin\n+            if Present (T)\n+              and then\n+                (Is_Tagged_Type (T)\n+                  or else\n+                    (Is_Access_Type (T)\n+                      and then\n+                        Is_Tagged_Type (Designated_Type (T))))\n+              and then Scope (Entity (Selector_Name (Nam))) /= T\n+            then\n+               Analyze_Renamed_Primitive_Operation\n+                 (N, New_S, Present (Rename_Spec));\n+               return;\n+\n+            else\n+               --  Renamed entity is an entry or protected operation. For those\n+               --  cases an explicit body is built (at the point of freezing of\n+               --  this entity) that contains a call to the renamed entity.\n+\n+               --  This is not allowed for renaming as body if the renamed\n+               --  spec is already frozen (see RM 8.5.4(5) for details).\n+\n+               if Present (Rename_Spec)\n+                 and then Is_Frozen (Rename_Spec)\n+               then\n+                  Error_Msg_N\n+                    (\"renaming-as-body cannot rename entry as subprogram\", N);\n+                  Error_Msg_NE\n+                    (\"\\since & is already frozen (RM 8.5.4(5))\",\n+                     N, Rename_Spec);\n+               else\n+                  Analyze_Renamed_Entry (N, New_S, Present (Rename_Spec));\n+               end if;\n+\n+               return;\n+            end if;\n+         end;\n \n       elsif Nkind (Nam) = N_Explicit_Dereference then\n \n@@ -2760,8 +2956,8 @@ package body Sem_Ch8 is\n             Pop_Scope;\n \n             while not (Is_List_Member (Decl))\n-              or else Nkind (Parent (Decl)) = N_Protected_Definition\n-              or else Nkind (Parent (Decl)) = N_Task_Definition\n+              or else Nkind_In (Parent (Decl), N_Protected_Definition,\n+                                               N_Task_Definition)\n             loop\n                Decl := Parent (Decl);\n             end loop;\n@@ -3339,10 +3535,7 @@ package body Sem_Ch8 is\n          if Nkind (N) = N_Identifier\n            and then Nkind (Parent (N)) = N_Case_Statement_Alternative\n          then\n-            Get_Name_String (Chars (N));\n-\n             declare\n-               Case_Str : constant String    := Name_Buffer (1 .. Name_Len);\n                Case_Stm : constant Node_Id   := Parent (Parent (N));\n                Case_Typ : constant Entity_Id := Etype (Expression (Case_Stm));\n                Case_Rtp : constant Entity_Id := Root_Type (Case_Typ);\n@@ -3359,9 +3552,7 @@ package body Sem_Ch8 is\n                   Get_Name_String (Chars (Lit));\n \n                   if Chars (Lit) /= Chars (N)\n-                    and then Is_Bad_Spelling_Of\n-                      (Case_Str, Name_Buffer (1 .. Name_Len))\n-                  then\n+                    and then Is_Bad_Spelling_Of (Chars (N), Chars (Lit)) then\n                      Error_Msg_Node_2 := Lit;\n                      Error_Msg_N\n                        (\"& is undefined, assume misspelling of &\", N);\n@@ -3445,8 +3636,6 @@ package body Sem_Ch8 is\n \n             --  Now check for possible misspellings\n \n-            Get_Name_String (Chars (N));\n-\n             declare\n                E      : Entity_Id;\n                Ematch : Entity_Id := Empty;\n@@ -3455,23 +3644,16 @@ package body Sem_Ch8 is\n                                 Name_Id (Nat (First_Name_Id) +\n                                            Name_Entries_Count - 1);\n \n-               S  : constant String (1 .. Name_Len) :=\n-                      Name_Buffer (1 .. Name_Len);\n-\n             begin\n-               for N in First_Name_Id .. Last_Name_Id loop\n-                  E := Get_Name_Entity_Id (N);\n+               for Nam in First_Name_Id .. Last_Name_Id loop\n+                  E := Get_Name_Entity_Id (Nam);\n \n                   if Present (E)\n                      and then (Is_Immediately_Visible (E)\n                                  or else\n                                Is_Potentially_Use_Visible (E))\n                   then\n-                     Get_Name_String (N);\n-\n-                     if Is_Bad_Spelling_Of\n-                          (S, Name_Buffer (1 .. Name_Len))\n-                     then\n+                     if Is_Bad_Spelling_Of (Chars (N), Nam) then\n                         Ematch := E;\n                         exit;\n                      end if;\n@@ -3812,6 +3994,18 @@ package body Sem_Ch8 is\n \n       <<Found>> begin\n \n+         --  When distribution features are available (Get_PCS_Name /=\n+         --  Name_No_DSA), a remote access-to-subprogram type is converted\n+         --  into a record type holding whatever information is needed to\n+         --  perform a remote call on an RCI suprogram. In that case we\n+         --  rewrite any occurrence of the RAS type into the equivalent record\n+         --  type here. 'Access attribute references and RAS dereferences are\n+         --  then implemented using specific TSSs. However when distribution is\n+         --  not available (case of Get_PCS_Name = Name_No_DSA), we bypass the\n+         --  generation of these TSSs, and we must keep the RAS type in its\n+         --  original access-to-subprogram form (since all calls through a\n+         --  value of such type will be local anyway in the absence of a PCS).\n+\n          if Comes_From_Source (N)\n            and then Is_Remote_Access_To_Subprogram_Type (E)\n            and then Expander_Active\n@@ -3875,17 +4069,28 @@ package body Sem_Ch8 is\n          --  to the discriminant in the initialization procedure.\n \n          else\n-            --  Entity is unambiguous, indicate that it is referenced here. One\n-            --  slightly odd case is that we do not want to set the Referenced\n-            --  flag if the entity is a label, and the identifier is the label\n-            --  in the source, since this is not a reference from the point of\n-            --  view of the user\n+            --  Entity is unambiguous, indicate that it is referenced here\n+\n+            --  For a renaming of an object, always generate simple reference,\n+            --  we don't try to keep track of assignments in this case.\n+\n+            if Is_Object (E) and then Present (Renamed_Object (E)) then\n+               Generate_Reference (E, N);\n \n-            if Nkind (Parent (N)) = N_Label then\n+            --  One odd case is that we do not want to set the Referenced flag\n+            --  if the entity is a label, and the identifier is the label in\n+            --  the source, since this is not a reference from the point of\n+            --  view of the user.\n+\n+            elsif Nkind (Parent (N)) = N_Label then\n                declare\n                   R : constant Boolean := Referenced (E);\n+\n                begin\n-                  if not Is_Actual_Parameter then\n+                  --  Generate reference unless this is an actual parameter\n+                  --  (see comment below)\n+\n+                  if Is_Actual_Parameter then\n                      Generate_Reference (E, N);\n                      Set_Referenced (E, R);\n                   end if;\n@@ -3938,8 +4143,8 @@ package body Sem_Ch8 is\n                begin\n                   P := Parent (N);\n                   while Present (P)\n-                    and then Nkind (P) /= N_Parameter_Specification\n-                    and then Nkind (P) /= N_Component_Declaration\n+                    and then not Nkind_In (P, N_Parameter_Specification,\n+                                              N_Component_Declaration)\n                   loop\n                      P := Parent (P);\n                   end loop;\n@@ -4225,34 +4430,25 @@ package body Sem_Ch8 is\n                   --  Check for misspelling of some entity in prefix\n \n                   Id := First_Entity (P_Name);\n-                  Get_Name_String (Chars (Selector));\n-\n-                  declare\n-                     S  : constant String (1 .. Name_Len) :=\n-                            Name_Buffer (1 .. Name_Len);\n-                  begin\n-                     while Present (Id) loop\n-                        Get_Name_String (Chars (Id));\n-                        if Is_Bad_Spelling_Of\n-                          (Name_Buffer (1 .. Name_Len), S)\n-                          and then not Is_Internal_Name (Chars (Id))\n-                        then\n-                           Error_Msg_NE\n-                             (\"possible misspelling of&\", Selector, Id);\n-                           exit;\n-                        end if;\n+                  while Present (Id) loop\n+                     if Is_Bad_Spelling_Of (Chars (Id), Chars (Selector))\n+                       and then not Is_Internal_Name (Chars (Id))\n+                     then\n+                        Error_Msg_NE\n+                          (\"possible misspelling of&\", Selector, Id);\n+                        exit;\n+                     end if;\n \n-                        Next_Entity (Id);\n-                     end loop;\n-                  end;\n+                     Next_Entity (Id);\n+                  end loop;\n \n                   --  Specialize the message if this may be an instantiation\n                   --  of a child unit that was not mentioned in the context.\n \n                   if Nkind (Parent (N)) = N_Package_Instantiation\n                     and then Is_Generic_Instance (Entity (Prefix (N)))\n                     and then Is_Compilation_Unit\n-                     (Generic_Parent (Parent (Entity (Prefix (N)))))\n+                               (Generic_Parent (Parent (Entity (Prefix (N)))))\n                   then\n                      Error_Msg_Node_2 := Selector;\n                      Error_Msg_N (\"\\missing `WITH &.&;`\", Prefix (N));\n@@ -4298,11 +4494,11 @@ package body Sem_Ch8 is\n \n       if Is_Task_Type (P_Name)\n         and then ((Ekind (Id) = E_Entry\n-                    and then Nkind (Parent (N)) /= N_Attribute_Reference)\n-                    or else\n-                  (Ekind (Id) = E_Entry_Family\n-                    and then\n-                      Nkind (Parent (Parent (N))) /= N_Attribute_Reference))\n+                     and then Nkind (Parent (N)) /= N_Attribute_Reference)\n+                   or else\n+                    (Ekind (Id) = E_Entry_Family\n+                      and then\n+                        Nkind (Parent (Parent (N))) /= N_Attribute_Reference))\n       then\n          --  It is an entry call after all, either to the current task (which\n          --  will deadlock) or to an enclosing task.\n@@ -6179,9 +6375,11 @@ package body Sem_Ch8 is\n          The_Unit := Unit (Cunit (Current_Sem_Unit));\n \n          if No (With_Sys)\n-           and then (Nkind (The_Unit) = N_Package_Body\n-                      or else (Nkind (The_Unit) = N_Subprogram_Body\n-                        and then not Acts_As_Spec (Cunit (Current_Sem_Unit))))\n+           and then\n+             (Nkind (The_Unit) = N_Package_Body\n+                or else (Nkind (The_Unit) = N_Subprogram_Body\n+                           and then\n+                             not Acts_As_Spec (Cunit (Current_Sem_Unit))))\n          then\n             With_Sys := Find_System (Library_Unit (Cunit (Current_Sem_Unit)));\n          end if;\n@@ -6193,7 +6391,6 @@ package body Sem_Ch8 is\n             --  context as well (Current_Sem_Unit is the parent unit);\n \n             The_Unit := Parent (N);\n-\n             while Nkind (The_Unit) /= N_Compilation_Unit loop\n                The_Unit := Parent (The_Unit);\n             end loop;\n@@ -6694,7 +6891,14 @@ package body Sem_Ch8 is\n       if In_Open_Scopes (Scope (T)) then\n          null;\n \n-      elsif From_With_Type (T) then\n+      --  A limited view cannot appear in a use_type clause. However, an\n+      --  access type whose designated type is limited has the flag but\n+      --  is not itself a limited view unless we only have a limited view\n+      --  of its enclosing package.\n+\n+      elsif From_With_Type (T)\n+        and then From_With_Type (Scope (T))\n+      then\n          Error_Msg_N\n            (\"incomplete type from limited view \"\n              & \"cannot appear in use clause\", Id);"}]}