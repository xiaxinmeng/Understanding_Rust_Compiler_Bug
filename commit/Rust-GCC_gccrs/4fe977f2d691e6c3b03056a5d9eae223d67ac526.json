{"sha": "4fe977f2d691e6c3b03056a5d9eae223d67ac526", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGZlOTc3ZjJkNjkxZTZjM2IwMzA1NmE1ZDllYWUyMjNkNjdhYzUyNg==", "commit": {"author": {"name": "Paolo Carlini", "email": "paolo.carlini@oracle.com", "date": "2012-05-06T15:06:31Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2012-05-06T15:06:31Z"}, "message": "re PR c++/53152 (In \"no match for operatorXX\" error message gives the wrong column info)\n\n2012-05-06  Paolo Carlini  <paolo.carlini@oracle.com>\n\n\tPR c++/53152\n\t* call.c (op_error, build_new_op_1, build_new_op): Add location_t\n\tparameter.\n\t(build_conditional_expr_1): Adjust.\n\t* typeck.c (build_x_indirect_ref, build_x_binary_op,\n\tbuild_x_unary_op): Add location_t parameter.\n\t(rationalize_conditional_expr, build_x_array_ref,\n\tbuild_x_compound_expr, cp_build_modify_expr, build_x_modify_expr):\n\tAdjust.\n\t* typeck2.c (build_x_arrow): Add location_t parameter.\n\t* semantics.c (finish_unary_op_expr): Likewise.\n\t(finish_increment_expr, handle_omp_for_class_iterator): Adjust.\n\t* decl2.c (grok_array_decl): Add location_t parameter.\n\t* parser.c (cp_parser_postfix_open_square_expression,\n\tcp_parser_postfix_dot_deref_expression, cp_parser_unary_expression,\n\tcp_parser_binary_expression, cp_parser_builtin_offsetof,\n\tdo_range_for_auto_deduction, cp_convert_range_for,\n\tcp_parser_template_argument, cp_parser_omp_for_cond): Pass the\n\tlocation, adjust.\n\t* pt.c (tsubst_copy_and_build): Adjust.\n\t* tree.c (maybe_dummy_object): Likewise.\n\t* cp-tree.h: Update declarations.\n\nFrom-SVN: r187211", "tree": {"sha": "091bdd2e12e8553129d9574e18d678519a3acedf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/091bdd2e12e8553129d9574e18d678519a3acedf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4fe977f2d691e6c3b03056a5d9eae223d67ac526", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4fe977f2d691e6c3b03056a5d9eae223d67ac526", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4fe977f2d691e6c3b03056a5d9eae223d67ac526", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4fe977f2d691e6c3b03056a5d9eae223d67ac526/comments", "author": null, "committer": null, "parents": [{"sha": "630dfc9c518aadc930be98f64a4cdc9a10bd45ca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/630dfc9c518aadc930be98f64a4cdc9a10bd45ca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/630dfc9c518aadc930be98f64a4cdc9a10bd45ca"}], "stats": {"total": 298, "additions": 174, "deletions": 124}, "files": [{"sha": "ebafba5d3aee66b75343d6d8d2945f3ba872b8cc", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fe977f2d691e6c3b03056a5d9eae223d67ac526/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fe977f2d691e6c3b03056a5d9eae223d67ac526/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=4fe977f2d691e6c3b03056a5d9eae223d67ac526", "patch": "@@ -1,3 +1,28 @@\n+2012-05-06  Paolo Carlini  <paolo.carlini@oracle.com>\n+\n+\tPR c++/53152\n+\t* call.c (op_error, build_new_op_1, build_new_op): Add location_t\n+\tparameter.\n+\t(build_conditional_expr_1): Adjust.\n+\t* typeck.c (build_x_indirect_ref, build_x_binary_op,\n+\tbuild_x_unary_op): Add location_t parameter.\n+\t(rationalize_conditional_expr, build_x_array_ref,\n+\tbuild_x_compound_expr, cp_build_modify_expr, build_x_modify_expr):\n+\tAdjust.\n+\t* typeck2.c (build_x_arrow): Add location_t parameter.\n+\t* semantics.c (finish_unary_op_expr): Likewise.\n+\t(finish_increment_expr, handle_omp_for_class_iterator): Adjust.\n+\t* decl2.c (grok_array_decl): Add location_t parameter.\n+\t* parser.c (cp_parser_postfix_open_square_expression,\n+\tcp_parser_postfix_dot_deref_expression, cp_parser_unary_expression,\n+\tcp_parser_binary_expression, cp_parser_builtin_offsetof,\n+\tdo_range_for_auto_deduction, cp_convert_range_for,\n+\tcp_parser_template_argument, cp_parser_omp_for_cond): Pass the\n+\tlocation, adjust.\n+\t* pt.c (tsubst_copy_and_build): Adjust.\n+\t* tree.c (maybe_dummy_object): Likewise.\n+\t* cp-tree.h: Update declarations.\n+\n 2012-05-04  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \t* semantics.c (cxx_eval_constant_expression, case CONVERT_EXPR): Tidy."}, {"sha": "bf2766fa4604868a477242ea59653e9b55c39edb", "filename": "gcc/cp/call.c", "status": "modified", "additions": 54, "deletions": 48, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fe977f2d691e6c3b03056a5d9eae223d67ac526/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fe977f2d691e6c3b03056a5d9eae223d67ac526/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=4fe977f2d691e6c3b03056a5d9eae223d67ac526", "patch": "@@ -159,8 +159,8 @@ static tree build_java_interface_fn_ref (tree, tree);\n \t\t     /*c_cast_p=*/false, (COMPLAIN))\n static tree convert_like_real (conversion *, tree, tree, int, int, bool,\n \t\t\t       bool, tsubst_flags_t);\n-static void op_error (enum tree_code, enum tree_code, tree, tree,\n-\t\t      tree, bool);\n+static void op_error (location_t, enum tree_code, enum tree_code, tree,\n+\t\t      tree, tree, bool);\n static struct z_candidate *build_user_type_conversion_1 (tree, tree, int,\n \t\t\t\t\t\t\t tsubst_flags_t);\n static void print_z_candidate (const char *, struct z_candidate *);\n@@ -4200,7 +4200,7 @@ op_error_string (const char *errmsg, int ntypes, bool match)\n }\n \n static void\n-op_error (enum tree_code code, enum tree_code code2,\n+op_error (location_t loc, enum tree_code code, enum tree_code code2,\n \t  tree arg1, tree arg2, tree arg3, bool match)\n {\n   const char *opname;\n@@ -4214,62 +4214,65 @@ op_error (enum tree_code code, enum tree_code code2,\n     {\n     case COND_EXPR:\n       if (flag_diagnostics_show_caret)\n-\terror (op_error_string (G_(\"ternary %<operator?:%>\"), 3, match),\n-\t       TREE_TYPE (arg1), TREE_TYPE (arg2), TREE_TYPE (arg3));\n+\terror_at (loc, op_error_string (G_(\"ternary %<operator?:%>\"),\n+\t\t\t\t\t3, match),\n+\t\t  TREE_TYPE (arg1), TREE_TYPE (arg2), TREE_TYPE (arg3));\n       else\n-\terror (op_error_string (G_(\"ternary %<operator?:%> \"\n-\t\t\t\t   \"in %<%E ? %E : %E%>\"), 3, match),\n-\t       arg1, arg2, arg3,\n-\t       TREE_TYPE (arg1), TREE_TYPE (arg2), TREE_TYPE (arg3));\n+\terror_at (loc, op_error_string (G_(\"ternary %<operator?:%> \"\n+\t\t\t\t\t   \"in %<%E ? %E : %E%>\"), 3, match),\n+\t\t  arg1, arg2, arg3,\n+\t\t  TREE_TYPE (arg1), TREE_TYPE (arg2), TREE_TYPE (arg3));\n       break;\n \n     case POSTINCREMENT_EXPR:\n     case POSTDECREMENT_EXPR:\n       if (flag_diagnostics_show_caret)\n-\terror (op_error_string (G_(\"%<operator%s%>\"), 1, match),\n-\t       opname, TREE_TYPE (arg1));\n+\terror_at (loc, op_error_string (G_(\"%<operator%s%>\"), 1, match),\n+\t\t  opname, TREE_TYPE (arg1));\n       else\n-\terror (op_error_string (G_(\"%<operator%s%> in %<%E%s%>\"), 1, match),\n-\t       opname, arg1, opname, TREE_TYPE (arg1));\n+\terror_at (loc, op_error_string (G_(\"%<operator%s%> in %<%E%s%>\"),\n+\t\t\t\t\t1, match),\n+\t\t  opname, arg1, opname, TREE_TYPE (arg1));\n       break;\n \n     case ARRAY_REF:\n       if (flag_diagnostics_show_caret)\n-\terror (op_error_string (G_(\"%<operator[]%>\"), 2, match),\n-\t       TREE_TYPE (arg1), TREE_TYPE (arg2));\n+\terror_at (loc, op_error_string (G_(\"%<operator[]%>\"), 2, match),\n+\t\t  TREE_TYPE (arg1), TREE_TYPE (arg2));\n       else\n-\terror (op_error_string (G_(\"%<operator[]%> in %<%E[%E]%>\"), 2, match),\n-\t       arg1, arg2, TREE_TYPE (arg1), TREE_TYPE (arg2));\n+\terror_at (loc, op_error_string (G_(\"%<operator[]%> in %<%E[%E]%>\"),\n+\t\t\t\t\t2, match),\n+\t\t  arg1, arg2, TREE_TYPE (arg1), TREE_TYPE (arg2));\n       break;\n \n     case REALPART_EXPR:\n     case IMAGPART_EXPR:\n       if (flag_diagnostics_show_caret)\n-\terror (op_error_string (G_(\"%qs\"), 1, match),\n-\t       opname, TREE_TYPE (arg1));\n+\terror_at (loc, op_error_string (G_(\"%qs\"), 1, match),\n+\t\t  opname, TREE_TYPE (arg1));\n       else\n-\terror (op_error_string (G_(\"%qs in %<%s %E%>\"), 1, match),\n-\t       opname, opname, arg1, TREE_TYPE (arg1));\n+\terror_at (loc, op_error_string (G_(\"%qs in %<%s %E%>\"), 1, match),\n+\t\t  opname, opname, arg1, TREE_TYPE (arg1));\n       break;\n \n     default:\n       if (arg2)\n \tif (flag_diagnostics_show_caret)\n-\t  error (op_error_string (G_(\"%<operator%s%>\"), 2, match),\n-\t\t opname, TREE_TYPE (arg1), TREE_TYPE (arg2));\n+\t  error_at (loc, op_error_string (G_(\"%<operator%s%>\"), 2, match),\n+\t\t    opname, TREE_TYPE (arg1), TREE_TYPE (arg2));\n \telse\n-\t  error (op_error_string (G_(\"%<operator%s%> in %<%E %s %E%>\"),\n-\t\t\t\t  2, match),\n-\t\t opname, arg1, opname, arg2,\n-\t\t TREE_TYPE (arg1), TREE_TYPE (arg2));\n+\t  error_at (loc, op_error_string (G_(\"%<operator%s%> in %<%E %s %E%>\"),\n+\t\t\t\t\t  2, match),\n+\t\t    opname, arg1, opname, arg2,\n+\t\t    TREE_TYPE (arg1), TREE_TYPE (arg2));\n       else\n \tif (flag_diagnostics_show_caret)\n-\t  error (op_error_string (G_(\"%<operator%s%>\"), 1, match),\n-\t\t opname, TREE_TYPE (arg1));\n+\t  error_at (loc, op_error_string (G_(\"%<operator%s%>\"), 1, match),\n+\t\t    opname, TREE_TYPE (arg1));\n \telse\n-\t  error (op_error_string (G_(\"%<operator%s%> in %<%s%E%>\"),\n-\t\t\t\t  1, match),\n-\t\t opname, opname, arg1, TREE_TYPE (arg1));\n+\t  error_at (loc, op_error_string (G_(\"%<operator%s%> in %<%s%E%>\"),\n+\t\t\t\t\t  1, match),\n+\t\t    opname, opname, arg1, TREE_TYPE (arg1));\n       break;\n     }\n }\n@@ -4607,7 +4610,8 @@ build_conditional_expr_1 (tree arg1, tree arg2, tree arg3,\n \t{\n           if (complain & tf_error)\n             {\n-              op_error (COND_EXPR, NOP_EXPR, arg1, arg2, arg3, FALSE);\n+              op_error (input_location, COND_EXPR, NOP_EXPR,\n+\t\t\targ1, arg2, arg3, FALSE);\n               print_z_candidates (location_of (arg1), candidates);\n             }\n \t  return error_mark_node;\n@@ -4617,7 +4621,8 @@ build_conditional_expr_1 (tree arg1, tree arg2, tree arg3,\n \t{\n           if (complain & tf_error)\n             {\n-              op_error (COND_EXPR, NOP_EXPR, arg1, arg2, arg3, FALSE);\n+              op_error (input_location, COND_EXPR, NOP_EXPR,\n+\t\t\targ1, arg2, arg3, FALSE);\n               print_z_candidates (location_of (arg1), candidates);\n             }\n \t  return error_mark_node;\n@@ -4944,8 +4949,8 @@ add_candidates (tree fns, tree first_arg, const VEC(tree,gc) *args,\n }\n \n static tree\n-build_new_op_1 (enum tree_code code, int flags, tree arg1, tree arg2, tree arg3,\n-\t\ttree *overload, tsubst_flags_t complain)\n+build_new_op_1 (location_t loc, enum tree_code code, int flags, tree arg1,\n+\t\ttree arg2, tree arg3, tree *overload, tsubst_flags_t complain)\n {\n   struct z_candidate *candidates = 0, *cand;\n   VEC(tree,gc) *arglist;\n@@ -5098,8 +5103,7 @@ build_new_op_1 (enum tree_code code, int flags, tree arg1, tree arg2, tree arg3,\n \t\t? G_(\"no %<%D(int)%> declared for postfix %qs,\"\n \t\t     \" trying prefix operator instead\")\n \t\t: G_(\"no %<%D(int)%> declared for postfix %qs\");\n-\t      permerror (input_location, msg, fnname,\n-\t\t\t operator_name_info[code].name);\n+\t      permerror (loc, msg, fnname, operator_name_info[code].name);\n \t    }\n \n \t  if (!flag_permissive)\n@@ -5109,8 +5113,8 @@ build_new_op_1 (enum tree_code code, int flags, tree arg1, tree arg2, tree arg3,\n \t    code = PREINCREMENT_EXPR;\n \t  else\n \t    code = PREDECREMENT_EXPR;\n-\t  result = build_new_op_1 (code, flags, arg1, NULL_TREE, NULL_TREE,\n-\t\t\t\t   overload, complain);\n+\t  result = build_new_op_1 (loc, code, flags, arg1, NULL_TREE,\n+\t\t\t\t   NULL_TREE, overload, complain);\n \t  break;\n \n \t  /* The caller will deal with these.  */\n@@ -5135,8 +5139,8 @@ build_new_op_1 (enum tree_code code, int flags, tree arg1, tree arg2, tree arg3,\n \t\t  {\n \t\t    /* ... Otherwise, report the more generic\n \t\t       \"no matching operator found\" error */\n-\t\t    op_error (code, code2, arg1, arg2, arg3, FALSE);\n-\t\t    print_z_candidates (input_location, candidates);\n+\t\t    op_error (loc, code, code2, arg1, arg2, arg3, FALSE);\n+\t\t    print_z_candidates (loc, candidates);\n \t\t  }\n \t    }\n \t  result = error_mark_node;\n@@ -5150,8 +5154,8 @@ build_new_op_1 (enum tree_code code, int flags, tree arg1, tree arg2, tree arg3,\n \t{\n \t  if ((flags & LOOKUP_COMPLAIN) && (complain & tf_error))\n \t    {\n-\t      op_error (code, code2, arg1, arg2, arg3, TRUE);\n-\t      print_z_candidates (input_location, candidates);\n+\t      op_error (loc, code, code2, arg1, arg2, arg3, TRUE);\n+\t      print_z_candidates (loc, candidates);\n \t    }\n \t  result = error_mark_node;\n \t}\n@@ -5213,7 +5217,7 @@ build_new_op_1 (enum tree_code code, int flags, tree arg1, tree arg2, tree arg3,\n \t      /* We need to call warn_logical_operator before\n \t\t converting arg2 to a boolean_type.  */\n \t      if (complain & tf_warning)\n-\t\twarn_logical_operator (input_location, code, boolean_type_node,\n+\t\twarn_logical_operator (loc, code, boolean_type_node,\n \t\t\t\t       code_orig_arg1, arg1,\n \t\t\t\t       code_orig_arg2, arg2);\n \n@@ -5254,7 +5258,7 @@ build_new_op_1 (enum tree_code code, int flags, tree arg1, tree arg2, tree arg3,\n     case TRUTH_ORIF_EXPR:\n     case TRUTH_AND_EXPR:\n     case TRUTH_OR_EXPR:\n-      warn_logical_operator (input_location, code, boolean_type_node,\n+      warn_logical_operator (loc, code, boolean_type_node,\n \t\t\t     code_orig_arg1, arg1, code_orig_arg2, arg2);\n       /* Fall through.  */\n     case PLUS_EXPR:\n@@ -5313,12 +5317,14 @@ build_new_op_1 (enum tree_code code, int flags, tree arg1, tree arg2, tree arg3,\n /* Wrapper for above.  */\n \n tree\n-build_new_op (enum tree_code code, int flags, tree arg1, tree arg2, tree arg3,\n+build_new_op (location_t loc, enum tree_code code, int flags,\n+\t      tree arg1, tree arg2, tree arg3,\n \t      tree *overload, tsubst_flags_t complain)\n {\n   tree ret;\n   bool subtime = timevar_cond_start (TV_OVERLOAD);\n-  ret = build_new_op_1 (code, flags, arg1, arg2, arg3, overload, complain);\n+  ret = build_new_op_1 (loc, code, flags, arg1, arg2, arg3,\n+\t\t\toverload, complain);\n   timevar_cond_stop (TV_OVERLOAD, subtime);\n   return ret;\n }"}, {"sha": "141b559eb74a29b768e3d1d06a499489a3bef30c", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fe977f2d691e6c3b03056a5d9eae223d67ac526/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fe977f2d691e6c3b03056a5d9eae223d67ac526/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=4fe977f2d691e6c3b03056a5d9eae223d67ac526", "patch": "@@ -4874,8 +4874,8 @@ extern tree build_new_method_call\t\t(tree, tree, VEC(tree,gc) **,\n \t\t\t\t\t\t tsubst_flags_t);\n extern tree build_special_member_call\t\t(tree, tree, VEC(tree,gc) **,\n \t\t\t\t\t\t tree, int, tsubst_flags_t);\n-extern tree build_new_op\t\t\t(enum tree_code, int, tree, \n-\t\t\t\t\t\t tree, tree, tree *,\n+extern tree build_new_op\t\t\t(location_t, enum tree_code,\n+\t\t\t\t\t\t int, tree, tree, tree, tree *,\n \t\t\t\t\t\t tsubst_flags_t);\n extern tree build_op_call\t\t\t(tree, VEC(tree,gc) **,\n \t\t\t\t\t\t tsubst_flags_t);\n@@ -5112,7 +5112,7 @@ extern void maybe_make_one_only\t\t\t(tree);\n extern bool vague_linkage_p\t\t\t(tree);\n extern void grokclassfn\t\t\t\t(tree, tree,\n \t\t\t\t\t\t enum overload_flags);\n-extern tree grok_array_decl\t\t\t(tree, tree);\n+extern tree grok_array_decl\t\t\t(location_t, tree, tree);\n extern tree delete_sanity\t\t\t(tree, tree, bool, int, tsubst_flags_t);\n extern tree check_classfn\t\t\t(tree, tree, tree);\n extern void check_member_template\t\t(tree);\n@@ -5564,7 +5564,7 @@ extern tree finish_call_expr\t\t\t(tree, VEC(tree,gc) **, bool,\n extern tree finish_increment_expr\t\t(tree, enum tree_code);\n extern tree finish_this_expr\t\t\t(void);\n extern tree finish_pseudo_destructor_expr       (tree, tree, tree);\n-extern tree finish_unary_op_expr\t\t(enum tree_code, tree);\n+extern tree finish_unary_op_expr\t\t(location_t, enum tree_code, tree);\n extern tree finish_compound_literal\t\t(tree, tree, tsubst_flags_t);\n extern tree finish_fname\t\t\t(tree);\n extern void finish_translation_unit\t\t(void);\n@@ -5791,8 +5791,8 @@ extern tree build_class_member_access_expr      (tree, tree, tree, bool,\n \t\t\t\t\t\t tsubst_flags_t);\n extern tree finish_class_member_access_expr     (tree, tree, bool, \n \t\t\t\t\t\t tsubst_flags_t);\n-extern tree build_x_indirect_ref\t\t(tree, ref_operator, \n-                                                 tsubst_flags_t);\n+extern tree build_x_indirect_ref\t\t(location_t, tree,\n+\t\t\t\t\t\t ref_operator, tsubst_flags_t);\n extern tree cp_build_indirect_ref\t\t(tree, ref_operator,\n                                                  tsubst_flags_t);\n extern tree build_array_ref\t\t\t(location_t, tree, tree);\n@@ -5804,12 +5804,14 @@ extern tree cp_build_function_call_nary         (tree, tsubst_flags_t, ...)\n \t\t\t\t\t\tATTRIBUTE_SENTINEL;\n extern tree cp_build_function_call_vec\t\t(tree, VEC(tree,gc) **,\n \t\t\t\t\t\t tsubst_flags_t);\n-extern tree build_x_binary_op\t\t\t(enum tree_code, tree,\n+extern tree build_x_binary_op\t\t\t(location_t,\n+\t\t\t\t\t\t enum tree_code, tree,\n \t\t\t\t\t\t enum tree_code, tree,\n \t\t\t\t\t\t enum tree_code, tree *,\n \t\t\t\t\t\t tsubst_flags_t);\n extern tree build_x_array_ref\t\t\t(tree, tree, tsubst_flags_t);\n-extern tree build_x_unary_op\t\t\t(enum tree_code, tree,\n+extern tree build_x_unary_op\t\t\t(location_t,\n+\t\t\t\t\t\t enum tree_code, tree,\n                                                  tsubst_flags_t);\n extern tree cp_build_addr_expr\t\t\t(tree, tsubst_flags_t);\n extern tree cp_build_addr_expr_strict\t\t(tree, tsubst_flags_t);\n@@ -5898,7 +5900,8 @@ extern void check_narrowing\t\t\t(tree, tree);\n extern tree digest_init\t\t\t\t(tree, tree, tsubst_flags_t);\n extern tree digest_init_flags\t\t\t(tree, tree, int);\n extern tree build_scoped_ref\t\t\t(tree, tree, tree *);\n-extern tree build_x_arrow\t\t\t(tree, tsubst_flags_t);\n+extern tree build_x_arrow\t\t\t(location_t, tree,\n+\t\t\t\t\t\t tsubst_flags_t);\n extern tree build_m_component_ref\t\t(tree, tree, tsubst_flags_t);\n extern tree build_functional_cast\t\t(tree, tree, tsubst_flags_t);\n extern tree add_exception_specifier\t\t(tree, tree, int);"}, {"sha": "b0544bbb91d6c1963cefc543e09c39fce5bc57f3", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fe977f2d691e6c3b03056a5d9eae223d67ac526/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fe977f2d691e6c3b03056a5d9eae223d67ac526/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=4fe977f2d691e6c3b03056a5d9eae223d67ac526", "patch": "@@ -336,7 +336,7 @@ grokclassfn (tree ctype, tree function, enum overload_flags flags)\n    along the way.  */\n \n tree\n-grok_array_decl (tree array_expr, tree index_exp)\n+grok_array_decl (location_t loc, tree array_expr, tree index_exp)\n {\n   tree type;\n   tree expr;\n@@ -362,7 +362,7 @@ grok_array_decl (tree array_expr, tree index_exp)\n \n   /* If they have an `operator[]', use that.  */\n   if (MAYBE_CLASS_TYPE_P (type) || MAYBE_CLASS_TYPE_P (TREE_TYPE (index_exp)))\n-    expr = build_new_op (ARRAY_REF, LOOKUP_NORMAL,\n+    expr = build_new_op (loc, ARRAY_REF, LOOKUP_NORMAL,\n \t\t\t array_expr, index_exp, NULL_TREE,\n \t\t\t /*overload=*/NULL, tf_warning_or_error);\n   else"}, {"sha": "20597fddc8c7555d43b3ecbf03c5c67180a1de51", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 38, "deletions": 25, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fe977f2d691e6c3b03056a5d9eae223d67ac526/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fe977f2d691e6c3b03056a5d9eae223d67ac526/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=4fe977f2d691e6c3b03056a5d9eae223d67ac526", "patch": "@@ -5850,6 +5850,7 @@ cp_parser_postfix_open_square_expression (cp_parser *parser,\n \t\t\t\t\t  bool for_offsetof)\n {\n   tree index;\n+  location_t loc = cp_lexer_peek_token (parser->lexer)->location;\n \n   /* Consume the `[' token.  */\n   cp_lexer_consume_token (parser->lexer);\n@@ -5880,7 +5881,7 @@ cp_parser_postfix_open_square_expression (cp_parser *parser,\n   cp_parser_require (parser, CPP_CLOSE_SQUARE, RT_CLOSE_SQUARE);\n \n   /* Build the ARRAY_REF.  */\n-  postfix_expression = grok_array_decl (postfix_expression, index);\n+  postfix_expression = grok_array_decl (loc, postfix_expression, index);\n \n   /* When not doing offsetof, array references are not permitted in\n      constant-expressions.  */\n@@ -5918,7 +5919,7 @@ cp_parser_postfix_dot_deref_expression (cp_parser *parser,\n \n   /* If this is a `->' operator, dereference the pointer.  */\n   if (token_type == CPP_DEREF)\n-    postfix_expression = build_x_arrow (postfix_expression,\n+    postfix_expression = build_x_arrow (location, postfix_expression,\n \t\t\t\t\ttf_warning_or_error);\n   /* Check to see whether or not the expression is type-dependent.  */\n   dependent_p = type_dependent_expression_p (postfix_expression);\n@@ -6435,7 +6436,8 @@ cp_parser_unary_expression (cp_parser *parser, bool address_p, bool cast_p,\n \t    /* Parse the cast-expression.  */\n \t    expression = cp_parser_simple_cast_expression (parser);\n \t    /* Create the complete representation.  */\n-\t    return build_x_unary_op ((keyword == RID_REALPART\n+\t    return build_x_unary_op (token->location,\n+\t\t\t\t     (keyword == RID_REALPART\n \t\t\t\t      ? REALPART_EXPR : IMAGPART_EXPR),\n \t\t\t\t     expression,\n                                      tf_warning_or_error);\n@@ -6531,7 +6533,7 @@ cp_parser_unary_expression (cp_parser *parser, bool address_p, bool cast_p,\n \t{\n \t  tree identifier;\n \t  tree expression;\n-\t  location_t loc = cp_lexer_peek_token (parser->lexer)->location;\n+\t  location_t loc = token->location;\n \n \t  /* Consume the '&&' token.  */\n \t  cp_lexer_consume_token (parser->lexer);\n@@ -6550,6 +6552,7 @@ cp_parser_unary_expression (cp_parser *parser, bool address_p, bool cast_p,\n       tree cast_expression;\n       tree expression = error_mark_node;\n       non_integral_constant non_constant_p = NIC_NONE;\n+      location_t loc = token->location;\n \n       /* Consume the operator token.  */\n       token = cp_lexer_consume_token (parser->lexer);\n@@ -6563,15 +6566,17 @@ cp_parser_unary_expression (cp_parser *parser, bool address_p, bool cast_p,\n \t{\n \tcase INDIRECT_REF:\n \t  non_constant_p = NIC_STAR;\n-\t  expression = build_x_indirect_ref (cast_expression, RO_UNARY_STAR,\n+\t  expression = build_x_indirect_ref (loc, cast_expression,\n+\t\t\t\t\t     RO_UNARY_STAR,\n                                              tf_warning_or_error);\n \t  break;\n \n \tcase ADDR_EXPR:\n \t   non_constant_p = NIC_ADDR;\n \t  /* Fall through.  */\n \tcase BIT_NOT_EXPR:\n-\t  expression = build_x_unary_op (unary_operator, cast_expression,\n+\t  expression = build_x_unary_op (loc, unary_operator,\n+\t\t\t\t\t cast_expression,\n                                          tf_warning_or_error);\n \t  break;\n \n@@ -6583,7 +6588,8 @@ cp_parser_unary_expression (cp_parser *parser, bool address_p, bool cast_p,\n \tcase UNARY_PLUS_EXPR:\n \tcase NEGATE_EXPR:\n \tcase TRUTH_NOT_EXPR:\n-\t  expression = finish_unary_op_expr (unary_operator, cast_expression);\n+\t  expression = finish_unary_op_expr (loc, unary_operator,\n+\t\t\t\t\t     cast_expression);\n \t  break;\n \n \tdefault:\n@@ -7271,6 +7277,7 @@ cp_parser_binary_expression (cp_parser* parser, bool cast_p,\n   cp_parser_expression_stack_entry *sp = &stack[0];\n   tree lhs, rhs;\n   cp_token *token;\n+  location_t loc;\n   enum tree_code tree_type, lhs_type, rhs_type;\n   enum cp_parser_prec new_prec, lookahead_prec;\n   tree overload;\n@@ -7283,16 +7290,15 @@ cp_parser_binary_expression (cp_parser* parser, bool cast_p,\n     {\n       /* Get an operator token.  */\n       token = cp_lexer_peek_token (parser->lexer);\n+      loc = token->location;\n \n       if (warn_cxx0x_compat\n           && token->type == CPP_RSHIFT\n           && !parser->greater_than_is_operator_p)\n         {\n-          if (warning_at (token->location, OPT_Wc__0x_compat, \n-\t\t\t  \"%<>>%> operator is treated as\"\n-\t\t\t  \" two right angle brackets in C++11\"))\n-\t    inform (token->location,\n-\t\t    \"suggest parentheses around %<>>%> expression\");\n+          if (warning_at (loc, OPT_Wc__0x_compat, \"%<>>%> operator is treated\"\n+\t\t\t  \" as two right angle brackets in C++11\"))\n+\t    inform (loc, \"suggest parentheses around %<>>%> expression\");\n         }\n \n       new_prec = TOKEN_PRECEDENCE (token);\n@@ -7390,7 +7396,7 @@ cp_parser_binary_expression (cp_parser* parser, bool cast_p,\n \t  && TREE_CODE_CLASS (tree_type) == tcc_comparison)\n \tlhs = build2 (tree_type, boolean_type_node, lhs, rhs);\n       else\n-\tlhs = build_x_binary_op (tree_type, lhs, lhs_type, rhs, rhs_type,\n+\tlhs = build_x_binary_op (loc, tree_type, lhs, lhs_type, rhs, rhs_type,\n \t\t\t\t &overload, tf_warning_or_error);\n       lhs_type = tree_type;\n \n@@ -7798,7 +7804,7 @@ cp_parser_builtin_offsetof (cp_parser *parser)\n \n \tcase CPP_DEREF:\n \t  /* offsetof-member-designator \"->\" identifier */\n-\t  expr = grok_array_decl (expr, integer_zero_node);\n+\t  expr = grok_array_decl (token->location, expr, integer_zero_node);\n \t  /* FALLTHRU */\n \n \tcase CPP_DOT:\n@@ -9407,7 +9413,7 @@ do_range_for_auto_deduction (tree decl, tree range_expr)\n       iter_type = (cp_parser_perform_range_for_lookup\n \t\t   (range_temp, &begin_dummy, &end_dummy));\n       iter_decl = build_decl (input_location, VAR_DECL, NULL_TREE, iter_type);\n-      iter_decl = build_x_indirect_ref (iter_decl, RO_NULL,\n+      iter_decl = build_x_indirect_ref (input_location, iter_decl, RO_NULL,\n \t\t\t\t\ttf_warning_or_error);\n       TREE_TYPE (decl) = do_auto_deduction (TREE_TYPE (decl),\n \t\t\t\t\t    iter_decl, auto_node);\n@@ -9495,19 +9501,21 @@ cp_convert_range_for (tree statement, tree range_decl, tree range_expr)\n   finish_for_init_stmt (statement);\n \n   /* The new for condition.  */\n-  condition = build_x_binary_op (NE_EXPR,\n+  condition = build_x_binary_op (input_location, NE_EXPR,\n \t\t\t\t begin, ERROR_MARK,\n \t\t\t\t end, ERROR_MARK,\n \t\t\t\t NULL, tf_warning_or_error);\n   finish_for_cond (condition, statement);\n \n   /* The new increment expression.  */\n-  expression = finish_unary_op_expr (PREINCREMENT_EXPR, begin);\n+  expression = finish_unary_op_expr (input_location,\n+\t\t\t\t     PREINCREMENT_EXPR, begin);\n   finish_for_expr (expression, statement);\n \n   /* The declaration is initialized with *__begin inside the loop body.  */\n   cp_finish_decl (range_decl,\n-\t\t  build_x_indirect_ref (begin, RO_NULL, tf_warning_or_error),\n+\t\t  build_x_indirect_ref (input_location, begin, RO_NULL,\n+\t\t\t\t\ttf_warning_or_error),\n \t\t  /*is_constant_init*/false, NULL_TREE,\n \t\t  LOOKUP_ONLYCONVERTING);\n \n@@ -12858,6 +12866,7 @@ cp_parser_template_argument (cp_parser* parser)\n   bool address_p;\n   bool maybe_type_id = false;\n   cp_token *token = NULL, *argument_start_token = NULL;\n+  location_t loc = 0;\n   cp_id_kind idk;\n \n   /* There's really no way to know what we're looking at, so we just\n@@ -12973,7 +12982,10 @@ cp_parser_template_argument (cp_parser* parser)\n      object or function with external linkage.  */\n   address_p = cp_lexer_next_token_is (parser->lexer, CPP_AND);\n   if (address_p)\n-    cp_lexer_consume_token (parser->lexer);\n+    {\n+      loc = cp_lexer_peek_token (parser->lexer)->location;\n+      cp_lexer_consume_token (parser->lexer);\n+    }\n   /* See if we might have an id-expression.  */\n   token = cp_lexer_peek_token (parser->lexer);\n   if (token->type == CPP_NAME\n@@ -13033,8 +13045,8 @@ cp_parser_template_argument (cp_parser* parser)\n \t  if (cp_parser_parse_definitely (parser))\n \t    {\n \t      if (address_p)\n-\t\targument = build_x_unary_op (ADDR_EXPR, argument,\n-                                             tf_warning_or_error);\n+\t\targument = build_x_unary_op (loc, ADDR_EXPR, argument,\n+\t\t\t\t\t     tf_warning_or_error);\n \t      return argument;\n \t    }\n \t}\n@@ -26062,7 +26074,7 @@ cp_parser_omp_for_cond (cp_parser *parser, tree decl)\n \t  || CLASS_TYPE_P (TREE_TYPE (decl))))\n     return cond;\n \n-  return build_x_binary_op (TREE_CODE (cond),\n+  return build_x_binary_op (input_location, TREE_CODE (cond),\n \t\t\t    TREE_OPERAND (cond, 0), ERROR_MARK,\n \t\t\t    TREE_OPERAND (cond, 1), ERROR_MARK,\n \t\t\t    /*overload=*/NULL, tf_warning_or_error);\n@@ -26138,11 +26150,12 @@ cp_parser_omp_for_incr (cp_parser *parser, tree decl)\n \t      if (op == PLUS_EXPR)\n \t\tlhs = rhs;\n \t      else\n-\t\tlhs = build_x_unary_op (NEGATE_EXPR, rhs, tf_warning_or_error);\n+\t\tlhs = build_x_unary_op (input_location, NEGATE_EXPR, rhs,\n+\t\t\t\t\ttf_warning_or_error);\n \t    }\n \t  else\n-\t    lhs = build_x_binary_op (op, lhs, ERROR_MARK, rhs, ERROR_MARK,\n-\t\t\t\t     NULL, tf_warning_or_error);\n+\t    lhs = build_x_binary_op (input_location, op, lhs, ERROR_MARK, rhs,\n+\t\t\t\t     ERROR_MARK, NULL, tf_warning_or_error);\n \t}\n     }\n   while (token->type == CPP_PLUS || token->type == CPP_MINUS);"}, {"sha": "08b0ad684eda9760f9e0833fb1256e4724c63329", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fe977f2d691e6c3b03056a5d9eae223d67ac526/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fe977f2d691e6c3b03056a5d9eae223d67ac526/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=4fe977f2d691e6c3b03056a5d9eae223d67ac526", "patch": "@@ -13466,7 +13466,7 @@ tsubst_copy_and_build (tree t,\n \t      r = convert_from_reference (r);\n \t  }\n \telse\n-\t  r = build_x_indirect_ref (r, RO_UNARY_STAR, complain);\n+\t  r = build_x_indirect_ref (input_location, r, RO_UNARY_STAR, complain);\n \treturn r;\n       }\n \n@@ -13543,7 +13543,7 @@ tsubst_copy_and_build (tree t,\n     case POSTINCREMENT_EXPR:\n       op1 = tsubst_non_call_postfix_expression (TREE_OPERAND (t, 0),\n \t\t\t\t\t\targs, complain, in_decl);\n-      return build_x_unary_op (TREE_CODE (t), op1, complain);\n+      return build_x_unary_op (input_location, TREE_CODE (t), op1, complain);\n \n     case PREDECREMENT_EXPR:\n     case PREINCREMENT_EXPR:\n@@ -13554,8 +13554,8 @@ tsubst_copy_and_build (tree t,\n     case UNARY_PLUS_EXPR:  /* Unary + */\n     case REALPART_EXPR:\n     case IMAGPART_EXPR:\n-      return build_x_unary_op (TREE_CODE (t), RECUR (TREE_OPERAND (t, 0)),\n-                               complain);\n+      return build_x_unary_op (input_location, TREE_CODE (t),\n+\t\t\t       RECUR (TREE_OPERAND (t, 0)), complain);\n \n     case FIX_TRUNC_EXPR:\n       return cp_build_unary_op (FIX_TRUNC_EXPR, RECUR (TREE_OPERAND (t, 0)),\n@@ -13572,7 +13572,7 @@ tsubst_copy_and_build (tree t,\n       else\n \top1 = tsubst_non_call_postfix_expression (op1, args, complain,\n \t\t\t\t\t\t  in_decl);\n-      return build_x_unary_op (ADDR_EXPR, op1, complain);\n+      return build_x_unary_op (input_location, ADDR_EXPR, op1, complain);\n \n     case PLUS_EXPR:\n     case MINUS_EXPR:\n@@ -13607,7 +13607,7 @@ tsubst_copy_and_build (tree t,\n     case DOTSTAR_EXPR:\n       {\n \ttree r = build_x_binary_op\n-\t  (TREE_CODE (t),\n+\t  (input_location, TREE_CODE (t),\n \t   RECUR (TREE_OPERAND (t, 0)),\n \t   (TREE_NO_WARNING (TREE_OPERAND (t, 0))\n \t    ? ERROR_MARK\n@@ -13711,7 +13711,7 @@ tsubst_copy_and_build (tree t,\n       /* Remember that there was a reference to this entity.  */\n       if (DECL_P (op1))\n \tmark_used (op1);\n-      return build_x_arrow (op1, complain);\n+      return build_x_arrow (input_location, op1, complain);\n \n     case NEW_EXPR:\n       {"}, {"sha": "9447787f002389ed15d150818f56d4a080d75095", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fe977f2d691e6c3b03056a5d9eae223d67ac526/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fe977f2d691e6c3b03056a5d9eae223d67ac526/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=4fe977f2d691e6c3b03056a5d9eae223d67ac526", "patch": "@@ -2224,7 +2224,7 @@ finish_call_expr (tree fn, VEC(tree,gc) **args, bool disallow_virtual,\n tree\n finish_increment_expr (tree expr, enum tree_code code)\n {\n-  return build_x_unary_op (code, expr, tf_warning_or_error);\n+  return build_x_unary_op (input_location, code, expr, tf_warning_or_error);\n }\n \n /* Finish a use of `this'.  Returns an expression for `this'.  */\n@@ -2318,9 +2318,9 @@ finish_pseudo_destructor_expr (tree object, tree scope, tree destructor)\n /* Finish an expression of the form CODE EXPR.  */\n \n tree\n-finish_unary_op_expr (enum tree_code code, tree expr)\n+finish_unary_op_expr (location_t loc, enum tree_code code, tree expr)\n {\n-  tree result = build_x_unary_op (code, expr, tf_warning_or_error);\n+  tree result = build_x_unary_op (loc, code, expr, tf_warning_or_error);\n   if (TREE_OVERFLOW_P (result) && !TREE_OVERFLOW_P (expr))\n     overflow_warning (input_location, result);\n \n@@ -4456,7 +4456,8 @@ handle_omp_for_class_iterator (int i, location_t locus, tree declv, tree initv,\n \tcond = error_mark_node;\n       else\n \t{\n-\t  tree tem = build_x_binary_op (TREE_CODE (cond), iter, ERROR_MARK,\n+\t  tree tem = build_x_binary_op (input_location, TREE_CODE (cond),\n+\t\t\t\t\titer, ERROR_MARK,\n \t\t\t\t\tTREE_OPERAND (cond, 1), ERROR_MARK,\n \t\t\t\t\tNULL, tf_warning_or_error);\n \t  if (error_operand_p (tem))\n@@ -4472,7 +4473,7 @@ handle_omp_for_class_iterator (int i, location_t locus, tree declv, tree initv,\n       error_at (elocus, \"invalid controlling predicate\");\n       return true;\n     }\n-  diff = build_x_binary_op (MINUS_EXPR, TREE_OPERAND (cond, 1),\n+  diff = build_x_binary_op (input_location, MINUS_EXPR, TREE_OPERAND (cond, 1),\n \t\t\t    ERROR_MARK, iter, ERROR_MARK, NULL,\n \t\t\t    tf_warning_or_error);\n   if (error_operand_p (diff))\n@@ -4495,7 +4496,7 @@ handle_omp_for_class_iterator (int i, location_t locus, tree declv, tree initv,\n \t  incr = error_mark_node;\n \t  break;\n \t}\n-      iter_incr = build_x_unary_op (TREE_CODE (incr), iter,\n+      iter_incr = build_x_unary_op (input_location, TREE_CODE (incr), iter,\n \t\t\t\t    tf_warning_or_error);\n       if (error_operand_p (iter_incr))\n \treturn true;\n@@ -4545,7 +4546,7 @@ handle_omp_for_class_iterator (int i, location_t locus, tree declv, tree initv,\n \t\tincr = error_mark_node;\n \t      else\n \t\t{\n-\t\t  iter_incr = build_x_binary_op (PLUS_EXPR,\n+\t\t  iter_incr = build_x_binary_op (input_location, PLUS_EXPR,\n \t\t\t\t\t\t TREE_OPERAND (rhs, 0),\n \t\t\t\t\t\t ERROR_MARK, iter,\n \t\t\t\t\t\t ERROR_MARK, NULL,"}, {"sha": "918b9ccd55a8613d71e6e4b139caa717ce6934f8", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fe977f2d691e6c3b03056a5d9eae223d67ac526/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fe977f2d691e6c3b03056a5d9eae223d67ac526/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=4fe977f2d691e6c3b03056a5d9eae223d67ac526", "patch": "@@ -2598,8 +2598,8 @@ maybe_dummy_object (tree type, tree* binfop)\n \t   && context == nonlambda_method_basetype ())\n     /* In a lambda, need to go through 'this' capture.  */\n     decl = (build_x_indirect_ref\n-\t    ((lambda_expr_this_capture\n-\t      (CLASSTYPE_LAMBDA_EXPR (current_class_type))),\n+\t    (input_location, (lambda_expr_this_capture\n+\t\t\t      (CLASSTYPE_LAMBDA_EXPR (current_class_type))),\n \t     RO_NULL, tf_warning_or_error));\n   else\n     decl = build_dummy_object (context);"}, {"sha": "2b3fcca4188eccd6b6001bb226a1a75b31d4d44e", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 23, "deletions": 21, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fe977f2d691e6c3b03056a5d9eae223d67ac526/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fe977f2d691e6c3b03056a5d9eae223d67ac526/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=4fe977f2d691e6c3b03056a5d9eae223d67ac526", "patch": "@@ -2060,7 +2060,8 @@ rationalize_conditional_expr (enum tree_code code, tree t,\n       gcc_assert (!TREE_SIDE_EFFECTS (op0)\n \t\t  && !TREE_SIDE_EFFECTS (op1));\n       return\n-\tbuild_conditional_expr (build_x_binary_op ((TREE_CODE (t) == MIN_EXPR\n+\tbuild_conditional_expr (build_x_binary_op (input_location,\n+\t\t\t\t\t\t   (TREE_CODE (t) == MIN_EXPR\n \t\t\t\t\t\t    ? LE_EXPR : GE_EXPR),\n \t\t\t\t\t\t   op0, TREE_CODE (op0),\n \t\t\t\t\t\t   op1, TREE_CODE (op1),\n@@ -2730,7 +2731,7 @@ build_ptrmemfunc_access_expr (tree ptrmem, tree member_name)\n    Must also handle REFERENCE_TYPEs for C++.  */\n \n tree\n-build_x_indirect_ref (tree expr, ref_operator errorstring, \n+build_x_indirect_ref (location_t loc, tree expr, ref_operator errorstring, \n                       tsubst_flags_t complain)\n {\n   tree orig_expr = expr;\n@@ -2746,8 +2747,8 @@ build_x_indirect_ref (tree expr, ref_operator errorstring,\n       expr = build_non_dependent_expr (expr);\n     }\n \n-  rval = build_new_op (INDIRECT_REF, LOOKUP_NORMAL, expr, NULL_TREE,\n-\t\t       NULL_TREE, /*overload=*/NULL, complain);\n+  rval = build_new_op (loc, INDIRECT_REF, LOOKUP_NORMAL, expr,\n+\t\t       NULL_TREE, NULL_TREE, /*overload=*/NULL, complain);\n   if (!rval)\n     rval = cp_build_indirect_ref (expr, errorstring, complain);\n \n@@ -3580,8 +3581,9 @@ convert_arguments (tree typelist, VEC(tree,gc) **values, tree fndecl,\n    ARG2_CODE as ERROR_MARK.  */\n \n tree\n-build_x_binary_op (enum tree_code code, tree arg1, enum tree_code arg1_code,\n-\t\t   tree arg2, enum tree_code arg2_code, tree *overload,\n+build_x_binary_op (location_t loc, enum tree_code code, tree arg1,\n+\t\t   enum tree_code arg1_code, tree arg2,\n+\t\t   enum tree_code arg2_code, tree *overload,\n \t\t   tsubst_flags_t complain)\n {\n   tree orig_arg1;\n@@ -3603,7 +3605,7 @@ build_x_binary_op (enum tree_code code, tree arg1, enum tree_code arg1_code,\n   if (code == DOTSTAR_EXPR)\n     expr = build_m_component_ref (arg1, arg2, complain);\n   else\n-    expr = build_new_op (code, LOOKUP_NORMAL, arg1, arg2, NULL_TREE,\n+    expr = build_new_op (loc, code, LOOKUP_NORMAL, arg1, arg2, NULL_TREE,\n \t\t\t overload, complain);\n \n   /* Check for cases such as x+y<<z which users are likely to\n@@ -3643,8 +3645,8 @@ build_x_array_ref (tree arg1, tree arg2, tsubst_flags_t complain)\n       arg2 = build_non_dependent_expr (arg2);\n     }\n \n-  expr = build_new_op (ARRAY_REF, LOOKUP_NORMAL, arg1, arg2, NULL_TREE,\n-\t\t       /*overload=*/NULL, complain);\n+  expr = build_new_op (input_location, ARRAY_REF, LOOKUP_NORMAL, arg1,\n+\t\t       arg2, NULL_TREE, /*overload=*/NULL, complain);\n \n   if (processing_template_decl && expr != error_mark_node)\n     return build_min_non_dep (ARRAY_REF, expr, orig_arg1, orig_arg2,\n@@ -4659,7 +4661,8 @@ pointer_diff (tree op0, tree op1, tree ptrtype)\n    and XARG is the operand.  */\n \n tree\n-build_x_unary_op (enum tree_code code, tree xarg, tsubst_flags_t complain)\n+build_x_unary_op (location_t loc, enum tree_code code, tree xarg,\n+\t\t  tsubst_flags_t complain)\n {\n   tree orig_expr = xarg;\n   tree exp;\n@@ -4690,8 +4693,8 @@ build_x_unary_op (enum tree_code code, tree xarg, tsubst_flags_t complain)\n \t  || (TREE_CODE (xarg) == OFFSET_REF)))\n     /* Don't look for a function.  */;\n   else\n-    exp = build_new_op (code, LOOKUP_NORMAL, xarg, NULL_TREE, NULL_TREE,\n-\t\t\t/*overload=*/NULL, complain);\n+    exp = build_new_op (loc, code, LOOKUP_NORMAL, xarg, NULL_TREE,\n+\t\t\tNULL_TREE, /*overload=*/NULL, complain);\n   if (!exp && code == ADDR_EXPR)\n     {\n       if (is_overloaded_fn (xarg))\n@@ -5720,8 +5723,8 @@ build_x_compound_expr (tree op1, tree op2, tsubst_flags_t complain)\n       op2 = build_non_dependent_expr (op2);\n     }\n \n-  result = build_new_op (COMPOUND_EXPR, LOOKUP_NORMAL, op1, op2, NULL_TREE,\n-\t\t\t /*overload=*/NULL, complain);\n+  result = build_new_op (input_location, COMPOUND_EXPR, LOOKUP_NORMAL,\n+\t\t\t op1, op2, NULL_TREE, /*overload=*/NULL, complain);\n   if (!result)\n     result = cp_build_compound_expr (op1, op2, complain);\n \n@@ -6909,9 +6912,9 @@ cp_build_modify_expr (tree lhs, enum tree_code modifycode, tree rhs,\n \t    /* Do the default thing.  */;\n \t  else\n \t    {\n-\t      result = build_new_op (MODIFY_EXPR, LOOKUP_NORMAL,\n-\t\t\t\t     lhs, rhs, make_node (NOP_EXPR),\n-\t\t\t\t     /*overload=*/NULL,\n+\t      result = build_new_op (input_location, MODIFY_EXPR,\n+\t\t\t\t     LOOKUP_NORMAL, lhs, rhs,\n+\t\t\t\t     make_node (NOP_EXPR), /*overload=*/NULL,\n \t\t\t\t     complain);\n \t      if (result == NULL_TREE)\n \t\treturn error_mark_node;\n@@ -7111,10 +7114,9 @@ build_x_modify_expr (tree lhs, enum tree_code modifycode, tree rhs,\n \n   if (modifycode != NOP_EXPR)\n     {\n-      tree rval = build_new_op (MODIFY_EXPR, LOOKUP_NORMAL, lhs, rhs,\n-\t\t\t\tmake_node (modifycode),\n-\t\t\t\t/*overload=*/NULL,\n-\t\t\t\tcomplain);\n+      tree rval = build_new_op (input_location, MODIFY_EXPR, LOOKUP_NORMAL,\n+\t\t\t\tlhs, rhs, make_node (modifycode),\n+\t\t\t\t/*overload=*/NULL, complain);\n       if (rval)\n \t{\n \t  TREE_NO_WARNING (rval) = 1;"}, {"sha": "b26723f5ea3351039dea760b9cb108a148c488fd", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fe977f2d691e6c3b03056a5d9eae223d67ac526/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fe977f2d691e6c3b03056a5d9eae223d67ac526/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=4fe977f2d691e6c3b03056a5d9eae223d67ac526", "patch": "@@ -1471,7 +1471,7 @@ build_scoped_ref (tree datum, tree basetype, tree* binfo_p)\n    delegation is detected.  */\n \n tree\n-build_x_arrow (tree expr, tsubst_flags_t complain)\n+build_x_arrow (location_t loc, tree expr, tsubst_flags_t complain)\n {\n   tree orig_expr = expr;\n   tree type = TREE_TYPE (expr);\n@@ -1493,8 +1493,8 @@ build_x_arrow (tree expr, tsubst_flags_t complain)\n       struct tinst_level *actual_inst = current_instantiation ();\n       tree fn = NULL;\n \n-      while ((expr = build_new_op (COMPONENT_REF, LOOKUP_NORMAL, expr,\n-\t\t\t\t   NULL_TREE, NULL_TREE,\n+      while ((expr = build_new_op (loc, COMPONENT_REF,\n+\t\t\t\t   LOOKUP_NORMAL, expr, NULL_TREE, NULL_TREE,\n \t\t\t\t   &fn, complain)))\n \t{\n \t  if (expr == error_mark_node)"}]}