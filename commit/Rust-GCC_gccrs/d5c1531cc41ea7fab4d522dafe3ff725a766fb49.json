{"sha": "d5c1531cc41ea7fab4d522dafe3ff725a766fb49", "node_id": "C_kwDOANBUbNoAKGQ1YzE1MzFjYzQxZWE3ZmFiNGQ1MjJkYWZlM2ZmNzI1YTc2NmZiNDk", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2022-05-25T12:49:07Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-05-25T12:49:07Z"}, "message": "Merge #1278\n\n1278: Remove inside_loop parameter r=philberty a=philberty\n\nThe parameter was a hack used to support error handling cases\r\nin Break and Continue expression's but this is no longer required.\n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>", "tree": {"sha": "44c687fbf3217a020f71c88250c2e8680ee30755", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/44c687fbf3217a020f71c88250c2e8680ee30755"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d5c1531cc41ea7fab4d522dafe3ff725a766fb49", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJijiXDCRBK7hj4Ov3rIwAAQhMIAJNPuGiGJBdUugwKv0PBXWvP\ncYXLV6timS8kAeT/uHVsJhiHW5xE6YNF/TTbVTfVabBcAkVOPlOccgoPPs0P04dD\nNXrxaGZVsInYXvaOCPujKJoD1+CtchHBPW4KqQowKvtRv24dEbEKeNRKxWwI0JsN\nrw1+x72qahxtvAcxGg1EE7P7QezsC+6xqVzWQEHp/Kj39a0PPLprD+h3e7CoSafI\nce/3NW2CPBcJ4PnTBK9PjG6X5mUnZluvBJFeSPs5LvT1yxH+o6y1NKk3MvK5ttt+\nDne7sSDNTU6x93iRWTyHKkW4eT4bimsbFyrG4HpBvycpTdfGoA7E7+RH+nyVVwE=\n=v8pm\n-----END PGP SIGNATURE-----\n", "payload": "tree 44c687fbf3217a020f71c88250c2e8680ee30755\nparent 36c91efc86d962b8614b87c2ed22314e06cb3462\nparent 7f7efa4463d95e23f375583b02db6408b6610a2f\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1653482947 +0000\ncommitter GitHub <noreply@github.com> 1653482947 +0000\n\nMerge #1278\n\n1278: Remove inside_loop parameter r=philberty a=philberty\n\nThe parameter was a hack used to support error handling cases\r\nin Break and Continue expression's but this is no longer required.\n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d5c1531cc41ea7fab4d522dafe3ff725a766fb49", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d5c1531cc41ea7fab4d522dafe3ff725a766fb49", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d5c1531cc41ea7fab4d522dafe3ff725a766fb49/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "36c91efc86d962b8614b87c2ed22314e06cb3462", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/36c91efc86d962b8614b87c2ed22314e06cb3462", "html_url": "https://github.com/Rust-GCC/gccrs/commit/36c91efc86d962b8614b87c2ed22314e06cb3462"}, {"sha": "7f7efa4463d95e23f375583b02db6408b6610a2f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f7efa4463d95e23f375583b02db6408b6610a2f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7f7efa4463d95e23f375583b02db6408b6610a2f"}], "stats": {"total": 217, "additions": 95, "deletions": 122}, "files": [{"sha": "7e87e1d0a4403d1445ca92ce84c5830c9a68bafb", "filename": "gcc/rust/typecheck/rust-hir-trait-resolve.cc", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5c1531cc41ea7fab4d522dafe3ff725a766fb49/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5c1531cc41ea7fab4d522dafe3ff725a766fb49/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.cc?ref=d5c1531cc41ea7fab4d522dafe3ff725a766fb49", "patch": "@@ -324,8 +324,7 @@ TraitItemReference::resolve_item (HIR::TraitItemFunc &func)\n   auto expected_ret_tyty = resolved_fn_type->get_return_type ();\n   context->push_return_type (TypeCheckContextItem (&func), expected_ret_tyty);\n \n-  auto block_expr_ty\n-    = TypeCheckExpr::Resolve (func.get_block_expr ().get (), false);\n+  auto block_expr_ty = TypeCheckExpr::Resolve (func.get_block_expr ().get ());\n \n   context->pop_return_type ();\n "}, {"sha": "16cae9c38b282788c6526e23ca08659d05e6c090", "filename": "gcc/rust/typecheck/rust-hir-type-check-enumitem.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5c1531cc41ea7fab4d522dafe3ff725a766fb49/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-enumitem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5c1531cc41ea7fab4d522dafe3ff725a766fb49/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-enumitem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-enumitem.h?ref=d5c1531cc41ea7fab4d522dafe3ff725a766fb49", "patch": "@@ -81,7 +81,7 @@ class TypeCheckEnumItem : public TypeCheckBase\n       rust_error_at (item.get_locus (), \"discriminant too big\");\n \n     auto &discriminant = item.get_discriminant_expression ();\n-    auto capacity_type = TypeCheckExpr::Resolve (discriminant.get (), false);\n+    auto capacity_type = TypeCheckExpr::Resolve (discriminant.get ());\n     if (capacity_type->get_kind () == TyTy::TypeKind::ERROR)\n       return;\n "}, {"sha": "d96a85cc342579f3b59b2755a68ee8c64a0bf1b7", "filename": "gcc/rust/typecheck/rust-hir-type-check-expr.cc", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5c1531cc41ea7fab4d522dafe3ff725a766fb49/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5c1531cc41ea7fab4d522dafe3ff725a766fb49/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.cc?ref=d5c1531cc41ea7fab4d522dafe3ff725a766fb49", "patch": "@@ -56,9 +56,8 @@ TypeCheckExpr::visit (HIR::RangeFromToExpr &expr)\n   // resolve the range expressions and these types must unify then we use that\n   // type to substitute into the ADT\n   TyTy::BaseType *from_ty\n-    = TypeCheckExpr::Resolve (expr.get_from_expr ().get (), false);\n-  TyTy::BaseType *to_ty\n-    = TypeCheckExpr::Resolve (expr.get_to_expr ().get (), false);\n+    = TypeCheckExpr::Resolve (expr.get_from_expr ().get ());\n+  TyTy::BaseType *to_ty = TypeCheckExpr::Resolve (expr.get_to_expr ().get ());\n   TyTy::BaseType *unified = from_ty->unify (to_ty);\n \n   // substitute it in\n@@ -105,7 +104,7 @@ TypeCheckExpr::visit (HIR::RangeFromExpr &expr)\n   // resolve the range expressions and these types must unify then we use that\n   // type to substitute into the ADT\n   TyTy::BaseType *from_ty\n-    = TypeCheckExpr::Resolve (expr.get_from_expr ().get (), false);\n+    = TypeCheckExpr::Resolve (expr.get_from_expr ().get ());\n \n   // substitute it in\n   std::vector<TyTy::SubstitutionArg> subst_mappings;\n@@ -150,8 +149,7 @@ TypeCheckExpr::visit (HIR::RangeToExpr &expr)\n \n   // resolve the range expressions and these types must unify then we use that\n   // type to substitute into the ADT\n-  TyTy::BaseType *from_ty\n-    = TypeCheckExpr::Resolve (expr.get_to_expr ().get (), false);\n+  TyTy::BaseType *from_ty = TypeCheckExpr::Resolve (expr.get_to_expr ().get ());\n \n   // substitute it in\n   std::vector<TyTy::SubstitutionArg> subst_mappings;\n@@ -228,9 +226,8 @@ TypeCheckExpr::visit (HIR::RangeFromToInclExpr &expr)\n   // resolve the range expressions and these types must unify then we use that\n   // type to substitute into the ADT\n   TyTy::BaseType *from_ty\n-    = TypeCheckExpr::Resolve (expr.get_from_expr ().get (), false);\n-  TyTy::BaseType *to_ty\n-    = TypeCheckExpr::Resolve (expr.get_to_expr ().get (), false);\n+    = TypeCheckExpr::Resolve (expr.get_from_expr ().get ());\n+  TyTy::BaseType *to_ty = TypeCheckExpr::Resolve (expr.get_to_expr ().get ());\n   TyTy::BaseType *unified = from_ty->unify (to_ty);\n \n   // substitute it in\n@@ -245,12 +242,11 @@ TypeCheckExpr::visit (HIR::RangeFromToInclExpr &expr)\n void\n TypeCheckExpr::visit (HIR::ArrayIndexExpr &expr)\n {\n-  auto array_expr_ty\n-    = TypeCheckExpr::Resolve (expr.get_array_expr (), inside_loop);\n+  auto array_expr_ty = TypeCheckExpr::Resolve (expr.get_array_expr ());\n   if (array_expr_ty->get_kind () == TyTy::TypeKind::ERROR)\n     return;\n \n-  auto index_expr_ty = TypeCheckExpr::Resolve (expr.get_index_expr (), false);\n+  auto index_expr_ty = TypeCheckExpr::Resolve (expr.get_index_expr ());\n   if (index_expr_ty->get_kind () == TyTy::TypeKind::ERROR)\n     return;\n "}, {"sha": "9dcae0871cac73e7f1d3316261739e8c6bcf3028", "filename": "gcc/rust/typecheck/rust-hir-type-check-expr.h", "status": "modified", "additions": 49, "deletions": 63, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5c1531cc41ea7fab4d522dafe3ff725a766fb49/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5c1531cc41ea7fab4d522dafe3ff725a766fb49/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h?ref=d5c1531cc41ea7fab4d522dafe3ff725a766fb49", "patch": "@@ -40,12 +40,11 @@ class TypeCheckExpr : public TypeCheckBase\n   using Rust::Resolver::TypeCheckBase::visit;\n \n public:\n-  /* Perform type checking on expr. Also runs type unification algorithm.\n-     Returns the unified type of expr.\n-     `inside_loop` acts as a context for BreakExpr, etc. May change later. */\n-  static TyTy::BaseType *Resolve (HIR::Expr *expr, bool inside_loop)\n+  // Perform type checking on expr. Also runs type unification algorithm.\n+  // Returns the unified type of expr\n+  static TyTy::BaseType *Resolve (HIR::Expr *expr)\n   {\n-    TypeCheckExpr resolver (inside_loop);\n+    TypeCheckExpr resolver;\n     expr->accept_vis (resolver);\n \n     if (resolver.infered == nullptr)\n@@ -66,8 +65,7 @@ class TypeCheckExpr : public TypeCheckBase\n \n   void visit (HIR::TupleIndexExpr &expr) override\n   {\n-    auto resolved\n-      = TypeCheckExpr::Resolve (expr.get_tuple_expr ().get (), inside_loop);\n+    auto resolved = TypeCheckExpr::Resolve (expr.get_tuple_expr ().get ());\n     if (resolved->get_kind () == TyTy::TypeKind::ERROR)\n       {\n \trust_error_at (expr.get_tuple_expr ()->get_locus (),\n@@ -154,7 +152,7 @@ class TypeCheckExpr : public TypeCheckBase\n     std::vector<TyTy::TyVar> fields;\n     for (auto &elem : expr.get_tuple_elems ())\n       {\n-\tauto field_ty = TypeCheckExpr::Resolve (elem.get (), false);\n+\tauto field_ty = TypeCheckExpr::Resolve (elem.get ());\n \tfields.push_back (TyTy::TyVar (field_ty->get_ref ()));\n       }\n     infered = new TyTy::TupleType (expr.get_mappings ().get_hirid (),\n@@ -168,7 +166,7 @@ class TypeCheckExpr : public TypeCheckBase\n \n     TyTy::BaseType *expr_ty\n       = expr.has_return_expr ()\n-\t  ? TypeCheckExpr::Resolve (expr.get_expr (), false)\n+\t  ? TypeCheckExpr::Resolve (expr.get_expr ())\n \t  : TyTy::TupleType::get_unit_type (expr.get_mappings ().get_hirid ());\n \n     infered = fn_return_tyty->unify (expr_ty);\n@@ -181,8 +179,7 @@ class TypeCheckExpr : public TypeCheckBase\n \n   void visit (HIR::CallExpr &expr) override\n   {\n-    TyTy::BaseType *function_tyty\n-      = TypeCheckExpr::Resolve (expr.get_fnexpr (), false);\n+    TyTy::BaseType *function_tyty = TypeCheckExpr::Resolve (expr.get_fnexpr ());\n \n     bool valid_tyty = function_tyty->get_kind () == TyTy::TypeKind::ADT\n \t\t      || function_tyty->get_kind () == TyTy::TypeKind::FNDEF\n@@ -225,8 +222,7 @@ class TypeCheckExpr : public TypeCheckBase\n \n   void visit (HIR::MethodCallExpr &expr) override\n   {\n-    auto receiver_tyty\n-      = TypeCheckExpr::Resolve (expr.get_receiver ().get (), false);\n+    auto receiver_tyty = TypeCheckExpr::Resolve (expr.get_receiver ().get ());\n     if (receiver_tyty->get_kind () == TyTy::TypeKind::ERROR)\n       {\n \trust_error_at (expr.get_receiver ()->get_locus (),\n@@ -381,8 +377,8 @@ class TypeCheckExpr : public TypeCheckBase\n     infered\n       = TyTy::TupleType::get_unit_type (expr.get_mappings ().get_hirid ());\n \n-    auto lhs = TypeCheckExpr::Resolve (expr.get_lhs (), false);\n-    auto rhs = TypeCheckExpr::Resolve (expr.get_rhs (), false);\n+    auto lhs = TypeCheckExpr::Resolve (expr.get_lhs ());\n+    auto rhs = TypeCheckExpr::Resolve (expr.get_rhs ());\n \n     lhs->coerce (rhs);\n   }\n@@ -392,8 +388,8 @@ class TypeCheckExpr : public TypeCheckBase\n     infered\n       = TyTy::TupleType::get_unit_type (expr.get_mappings ().get_hirid ());\n \n-    auto lhs = TypeCheckExpr::Resolve (expr.get_left_expr ().get (), false);\n-    auto rhs = TypeCheckExpr::Resolve (expr.get_right_expr ().get (), false);\n+    auto lhs = TypeCheckExpr::Resolve (expr.get_left_expr ().get ());\n+    auto rhs = TypeCheckExpr::Resolve (expr.get_right_expr ().get ());\n \n     // we dont care about the result of the unify from a compound assignment\n     // since this is a unit-type expr\n@@ -495,8 +491,8 @@ class TypeCheckExpr : public TypeCheckBase\n \n   void visit (HIR::ArithmeticOrLogicalExpr &expr) override\n   {\n-    auto lhs = TypeCheckExpr::Resolve (expr.get_lhs (), false);\n-    auto rhs = TypeCheckExpr::Resolve (expr.get_rhs (), false);\n+    auto lhs = TypeCheckExpr::Resolve (expr.get_lhs ());\n+    auto rhs = TypeCheckExpr::Resolve (expr.get_rhs ());\n \n     auto lang_item_type\n       = Analysis::RustLangItem::OperatorToLangItem (expr.get_expr_type ());\n@@ -531,8 +527,8 @@ class TypeCheckExpr : public TypeCheckBase\n \n   void visit (HIR::ComparisonExpr &expr) override\n   {\n-    auto lhs = TypeCheckExpr::Resolve (expr.get_lhs (), false);\n-    auto rhs = TypeCheckExpr::Resolve (expr.get_rhs (), false);\n+    auto lhs = TypeCheckExpr::Resolve (expr.get_lhs ());\n+    auto rhs = TypeCheckExpr::Resolve (expr.get_rhs ());\n \n     auto result = lhs->unify (rhs);\n     if (result == nullptr || result->get_kind () == TyTy::TypeKind::ERROR)\n@@ -544,8 +540,8 @@ class TypeCheckExpr : public TypeCheckBase\n \n   void visit (HIR::LazyBooleanExpr &expr) override\n   {\n-    auto lhs = TypeCheckExpr::Resolve (expr.get_lhs (), false);\n-    auto rhs = TypeCheckExpr::Resolve (expr.get_rhs (), false);\n+    auto lhs = TypeCheckExpr::Resolve (expr.get_lhs ());\n+    auto rhs = TypeCheckExpr::Resolve (expr.get_rhs ());\n \n     // we expect the lhs and rhs must be bools at this point\n     TyTy::BoolType elhs (expr.get_mappings ().get_hirid ());\n@@ -563,8 +559,7 @@ class TypeCheckExpr : public TypeCheckBase\n \n   void visit (HIR::NegationExpr &expr) override\n   {\n-    auto negated_expr_ty\n-      = TypeCheckExpr::Resolve (expr.get_expr ().get (), false);\n+    auto negated_expr_ty = TypeCheckExpr::Resolve (expr.get_expr ().get ());\n \n     // check for operator overload\n     auto lang_item_type = Analysis::RustLangItem::NegationOperatorToLangItem (\n@@ -625,20 +620,18 @@ class TypeCheckExpr : public TypeCheckBase\n \n   void visit (HIR::IfExpr &expr) override\n   {\n-    TypeCheckExpr::Resolve (expr.get_if_condition (), false);\n-    TypeCheckExpr::Resolve (expr.get_if_block (), inside_loop);\n+    TypeCheckExpr::Resolve (expr.get_if_condition ());\n+    TypeCheckExpr::Resolve (expr.get_if_block ());\n \n     infered\n       = TyTy::TupleType::get_unit_type (expr.get_mappings ().get_hirid ());\n   }\n \n   void visit (HIR::IfExprConseqElse &expr) override\n   {\n-    TypeCheckExpr::Resolve (expr.get_if_condition (), false);\n-    auto if_blk_resolved\n-      = TypeCheckExpr::Resolve (expr.get_if_block (), inside_loop);\n-    auto else_blk_resolved\n-      = TypeCheckExpr::Resolve (expr.get_else_block (), inside_loop);\n+    TypeCheckExpr::Resolve (expr.get_if_condition ());\n+    auto if_blk_resolved = TypeCheckExpr::Resolve (expr.get_if_block ());\n+    auto else_blk_resolved = TypeCheckExpr::Resolve (expr.get_else_block ());\n \n     if (if_blk_resolved->get_kind () == TyTy::NEVER)\n       infered = else_blk_resolved;\n@@ -650,11 +643,10 @@ class TypeCheckExpr : public TypeCheckBase\n \n   void visit (HIR::IfExprConseqIf &expr) override\n   {\n-    TypeCheckExpr::Resolve (expr.get_if_condition (), false);\n-    auto if_blk_resolved\n-      = TypeCheckExpr::Resolve (expr.get_if_block (), inside_loop);\n+    TypeCheckExpr::Resolve (expr.get_if_condition ());\n+    auto if_blk_resolved = TypeCheckExpr::Resolve (expr.get_if_block ());\n     auto else_blk_resolved\n-      = TypeCheckExpr::Resolve (expr.get_conseq_if_expr (), inside_loop);\n+      = TypeCheckExpr::Resolve (expr.get_conseq_if_expr ());\n \n     if (if_blk_resolved->get_kind () == TyTy::NEVER)\n       infered = else_blk_resolved;\n@@ -669,7 +661,7 @@ class TypeCheckExpr : public TypeCheckBase\n     // this needs to perform a least upper bound coercion on the blocks and then\n     // unify the scruintee and arms\n     TyTy::BaseType *scrutinee_tyty\n-      = TypeCheckExpr::Resolve (expr.get_scrutinee_expr ().get (), false);\n+      = TypeCheckExpr::Resolve (expr.get_scrutinee_expr ().get ());\n \n     for (auto &pattern : expr.get_patterns ())\n       {\n@@ -681,7 +673,7 @@ class TypeCheckExpr : public TypeCheckBase\n \t  return;\n       }\n \n-    TypeCheckExpr::Resolve (expr.get_if_block (), inside_loop);\n+    TypeCheckExpr::Resolve (expr.get_if_block ());\n \n     infered\n       = TyTy::TupleType::get_unit_type (expr.get_mappings ().get_hirid ());\n@@ -691,8 +683,7 @@ class TypeCheckExpr : public TypeCheckBase\n \n   void visit (HIR::UnsafeBlockExpr &expr) override\n   {\n-    infered\n-      = TypeCheckExpr::Resolve (expr.get_block_expr ().get (), inside_loop);\n+    infered = TypeCheckExpr::Resolve (expr.get_block_expr ().get ());\n   }\n \n   void visit (HIR::ArrayIndexExpr &expr) override;\n@@ -708,11 +699,10 @@ class TypeCheckExpr : public TypeCheckBase\n \tcase HIR::ArrayElems::ArrayExprType::COPIED: {\n \t  HIR::ArrayElemsCopied &elems\n \t    = static_cast<HIR::ArrayElemsCopied &> (elements);\n-\t  element_type\n-\t    = TypeCheckExpr::Resolve (elems.get_elem_to_copy (), false);\n+\t  element_type = TypeCheckExpr::Resolve (elems.get_elem_to_copy ());\n \n \t  auto capacity_type\n-\t    = TypeCheckExpr::Resolve (elems.get_num_copies_expr (), false);\n+\t    = TypeCheckExpr::Resolve (elems.get_num_copies_expr ());\n \n \t  TyTy::BaseType *expected_ty = nullptr;\n \t  bool ok = context->lookup_builtin (\"usize\", &expected_ty);\n@@ -735,7 +725,7 @@ class TypeCheckExpr : public TypeCheckBase\n \t  std::vector<TyTy::BaseType *> types;\n \t  for (auto &elem : elems.get_values ())\n \t    {\n-\t      types.push_back (TypeCheckExpr::Resolve (elem.get (), false));\n+\t      types.push_back (TypeCheckExpr::Resolve (elem.get ()));\n \t    }\n \n \t  element_type = TyTy::TyVar::get_implicit_infer_var (expr.get_locus ())\n@@ -774,7 +764,7 @@ class TypeCheckExpr : public TypeCheckBase\n   void visit (HIR::StructExprStruct &struct_expr) override\n   {\n     TyTy::BaseType *struct_path_ty\n-      = TypeCheckExpr::Resolve (&struct_expr.get_struct_name (), false);\n+      = TypeCheckExpr::Resolve (&struct_expr.get_struct_name ());\n     if (struct_path_ty->get_kind () != TyTy::TypeKind::ADT)\n       {\n \trust_error_at (struct_expr.get_struct_name ().get_locus (),\n@@ -792,13 +782,13 @@ class TypeCheckExpr : public TypeCheckBase\n \n   void visit (HIR::GroupedExpr &expr) override\n   {\n-    infered = TypeCheckExpr::Resolve (expr.get_expr_in_parens ().get (), false);\n+    infered = TypeCheckExpr::Resolve (expr.get_expr_in_parens ().get ());\n   }\n \n   void visit (HIR::FieldAccessExpr &expr) override\n   {\n     auto struct_base\n-      = TypeCheckExpr::Resolve (expr.get_receiver_expr ().get (), false);\n+      = TypeCheckExpr::Resolve (expr.get_receiver_expr ().get ());\n \n     // FIXME does this require autoderef here?\n     if (struct_base->get_kind () == TyTy::TypeKind::REF)\n@@ -846,7 +836,7 @@ class TypeCheckExpr : public TypeCheckBase\n     context->push_new_loop_context (expr.get_mappings ().get_hirid (),\n \t\t\t\t    expr.get_locus ());\n     TyTy::BaseType *block_expr\n-      = TypeCheckExpr::Resolve (expr.get_loop_block ().get (), true);\n+      = TypeCheckExpr::Resolve (expr.get_loop_block ().get ());\n     if (!block_expr->is_unit ())\n       {\n \trust_error_at (expr.get_loop_block ()->get_locus (),\n@@ -873,9 +863,9 @@ class TypeCheckExpr : public TypeCheckBase\n   {\n     context->push_new_while_loop_context (expr.get_mappings ().get_hirid ());\n \n-    TypeCheckExpr::Resolve (expr.get_predicate_expr ().get (), false);\n+    TypeCheckExpr::Resolve (expr.get_predicate_expr ().get ());\n     TyTy::BaseType *block_expr\n-      = TypeCheckExpr::Resolve (expr.get_loop_block ().get (), true);\n+      = TypeCheckExpr::Resolve (expr.get_loop_block ().get ());\n \n     if (!block_expr->is_unit ())\n       {\n@@ -892,7 +882,7 @@ class TypeCheckExpr : public TypeCheckBase\n \n   void visit (HIR::BreakExpr &expr) override\n   {\n-    if (!inside_loop)\n+    if (!context->have_loop_context ())\n       {\n \trust_error_at (expr.get_locus (), \"cannot %<break%> outside of a loop\");\n \treturn;\n@@ -901,7 +891,7 @@ class TypeCheckExpr : public TypeCheckBase\n     if (expr.has_break_expr ())\n       {\n \tTyTy::BaseType *break_expr_tyty\n-\t  = TypeCheckExpr::Resolve (expr.get_expr ().get (), false);\n+\t  = TypeCheckExpr::Resolve (expr.get_expr ().get ());\n \n \tTyTy::BaseType *loop_context = context->peek_loop_context ();\n \tif (loop_context->get_kind () == TyTy::TypeKind::ERROR)\n@@ -920,7 +910,7 @@ class TypeCheckExpr : public TypeCheckBase\n \n   void visit (HIR::ContinueExpr &expr) override\n   {\n-    if (!inside_loop)\n+    if (!context->have_loop_context ())\n       {\n \trust_error_at (expr.get_locus (),\n \t\t       \"cannot %<continue%> outside of a loop\");\n@@ -933,7 +923,7 @@ class TypeCheckExpr : public TypeCheckBase\n   void visit (HIR::BorrowExpr &expr) override\n   {\n     TyTy::BaseType *resolved_base\n-      = TypeCheckExpr::Resolve (expr.get_expr ().get (), false);\n+      = TypeCheckExpr::Resolve (expr.get_expr ().get ());\n \n     if (expr.get_is_double_borrow ())\n       {\n@@ -949,7 +939,7 @@ class TypeCheckExpr : public TypeCheckBase\n   void visit (HIR::DereferenceExpr &expr) override\n   {\n     TyTy::BaseType *resolved_base\n-      = TypeCheckExpr::Resolve (expr.get_expr ().get (), false);\n+      = TypeCheckExpr::Resolve (expr.get_expr ().get ());\n \n     auto lang_item_type = Analysis::RustLangItem::ItemType::DEREF;\n     bool operator_overloaded\n@@ -990,7 +980,7 @@ class TypeCheckExpr : public TypeCheckBase\n   void visit (HIR::TypeCastExpr &expr) override\n   {\n     TyTy::BaseType *expr_to_convert\n-      = TypeCheckExpr::Resolve (expr.get_casted_expr ().get (), false);\n+      = TypeCheckExpr::Resolve (expr.get_casted_expr ().get ());\n     TyTy::BaseType *tyty_to_convert_to\n       = TypeCheckType::Resolve (expr.get_type_to_convert_to ().get ());\n \n@@ -1002,7 +992,7 @@ class TypeCheckExpr : public TypeCheckBase\n     // this needs to perform a least upper bound coercion on the blocks and then\n     // unify the scruintee and arms\n     TyTy::BaseType *scrutinee_tyty\n-      = TypeCheckExpr::Resolve (expr.get_scrutinee_expr ().get (), false);\n+      = TypeCheckExpr::Resolve (expr.get_scrutinee_expr ().get ());\n \n     std::vector<TyTy::BaseType *> kase_block_tys;\n     for (auto &kase : expr.get_match_cases ())\n@@ -1021,7 +1011,7 @@ class TypeCheckExpr : public TypeCheckBase\n \n \t// check the kase type\n \tTyTy::BaseType *kase_block_ty\n-\t  = TypeCheckExpr::Resolve (kase.get_expr ().get (), inside_loop);\n+\t  = TypeCheckExpr::Resolve (kase.get_expr ().get ());\n \tkase_block_tys.push_back (kase_block_ty);\n       }\n \n@@ -1059,9 +1049,7 @@ class TypeCheckExpr : public TypeCheckBase\n \t\t\t     TyTy::BaseType *rhs);\n \n private:\n-  TypeCheckExpr (bool inside_loop)\n-    : TypeCheckBase (), infered (nullptr), inside_loop (inside_loop)\n-  {}\n+  TypeCheckExpr () : TypeCheckBase (), infered (nullptr) {}\n \n   TyTy::BaseType *resolve_root_path (HIR::PathInExpression &expr,\n \t\t\t\t     size_t *offset,\n@@ -1127,8 +1115,6 @@ class TypeCheckExpr : public TypeCheckBase\n \n   /* The return value of TypeCheckExpr::Resolve */\n   TyTy::BaseType *infered;\n-\n-  bool inside_loop;\n };\n \n } // namespace Resolver"}, {"sha": "c7af9b23ef9f0b66a821404e50a034caa9adae46", "filename": "gcc/rust/typecheck/rust-hir-type-check-implitem.h", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5c1531cc41ea7fab4d522dafe3ff725a766fb49/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5c1531cc41ea7fab4d522dafe3ff725a766fb49/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.h?ref=d5c1531cc41ea7fab4d522dafe3ff725a766fb49", "patch": "@@ -176,8 +176,7 @@ class TypeCheckTopLevelImplItem : public TypeCheckBase\n   void visit (HIR::ConstantItem &constant) override\n   {\n     TyTy::BaseType *type = TypeCheckType::Resolve (constant.get_type ());\n-    TyTy::BaseType *expr_type\n-      = TypeCheckExpr::Resolve (constant.get_expr (), false);\n+    TyTy::BaseType *expr_type = TypeCheckExpr::Resolve (constant.get_expr ());\n \n     context->insert_type (constant.get_mappings (), type->unify (expr_type));\n   }\n@@ -369,7 +368,7 @@ class TypeCheckImplItem : public TypeCheckBase\n \t\t\t       expected_ret_tyty);\n \n     auto block_expr_ty\n-      = TypeCheckExpr::Resolve (function.get_definition ().get (), false);\n+      = TypeCheckExpr::Resolve (function.get_definition ().get ());\n \n     context->pop_return_type ();\n     expected_ret_tyty->unify (block_expr_ty);"}, {"sha": "85733357fbd13f2ad9bb49919daf7490946af8ec", "filename": "gcc/rust/typecheck/rust-hir-type-check-item.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5c1531cc41ea7fab4d522dafe3ff725a766fb49/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5c1531cc41ea7fab4d522dafe3ff725a766fb49/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-item.h?ref=d5c1531cc41ea7fab4d522dafe3ff725a766fb49", "patch": "@@ -210,7 +210,7 @@ class TypeCheckItem : public TypeCheckBase\n \t\t\t       expected_ret_tyty);\n \n     auto block_expr_ty\n-      = TypeCheckExpr::Resolve (function.get_definition ().get (), false);\n+      = TypeCheckExpr::Resolve (function.get_definition ().get ());\n \n     context->pop_return_type ();\n "}, {"sha": "be3b8e4c0110080a495f2a1419c00977b7b8b726", "filename": "gcc/rust/typecheck/rust-hir-type-check-pattern.cc", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5c1531cc41ea7fab4d522dafe3ff725a766fb49/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-pattern.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5c1531cc41ea7fab4d522dafe3ff725a766fb49/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-pattern.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-pattern.cc?ref=d5c1531cc41ea7fab4d522dafe3ff725a766fb49", "patch": "@@ -25,13 +25,13 @@ namespace Resolver {\n void\n TypeCheckPattern::visit (HIR::PathInExpression &pattern)\n {\n-  infered = TypeCheckExpr::Resolve (&pattern, false);\n+  infered = TypeCheckExpr::Resolve (&pattern);\n }\n \n void\n TypeCheckPattern::visit (HIR::TupleStructPattern &pattern)\n {\n-  infered = TypeCheckExpr::Resolve (&pattern.get_path (), false);\n+  infered = TypeCheckExpr::Resolve (&pattern.get_path ());\n   if (infered->get_kind () == TyTy::TypeKind::ERROR)\n     return;\n \n@@ -117,7 +117,7 @@ TypeCheckPattern::visit (HIR::TupleStructPattern &pattern)\n void\n TypeCheckPattern::visit (HIR::StructPattern &pattern)\n {\n-  infered = TypeCheckExpr::Resolve (&pattern.get_path (), false);\n+  infered = TypeCheckExpr::Resolve (&pattern.get_path ());\n   if (infered->get_kind () == TyTy::TypeKind::ERROR)\n     return;\n \n@@ -300,7 +300,7 @@ TypeCheckPattern::visit (HIR::RangePattern &pattern)\n \t  = *static_cast<HIR::RangePatternBoundPath *> (\n \t    pattern.get_upper_bound ().get ());\n \n-\tupper = TypeCheckExpr::Resolve (&ref.get_path (), false);\n+\tupper = TypeCheckExpr::Resolve (&ref.get_path ());\n       }\n       break;\n \n@@ -309,7 +309,7 @@ TypeCheckPattern::visit (HIR::RangePattern &pattern)\n \t  = *static_cast<HIR::RangePatternBoundQualPath *> (\n \t    pattern.get_upper_bound ().get ());\n \n-\tupper = TypeCheckExpr::Resolve (&ref.get_qualified_path (), false);\n+\tupper = TypeCheckExpr::Resolve (&ref.get_qualified_path ());\n       }\n       break;\n     }\n@@ -333,7 +333,7 @@ TypeCheckPattern::visit (HIR::RangePattern &pattern)\n \t  = *static_cast<HIR::RangePatternBoundPath *> (\n \t    pattern.get_lower_bound ().get ());\n \n-\tlower = TypeCheckExpr::Resolve (&ref.get_path (), false);\n+\tlower = TypeCheckExpr::Resolve (&ref.get_path ());\n       }\n       break;\n \n@@ -342,7 +342,7 @@ TypeCheckPattern::visit (HIR::RangePattern &pattern)\n \t  = *static_cast<HIR::RangePatternBoundQualPath *> (\n \t    pattern.get_lower_bound ().get ());\n \n-\tlower = TypeCheckExpr::Resolve (&ref.get_qualified_path (), false);\n+\tlower = TypeCheckExpr::Resolve (&ref.get_qualified_path ());\n       }\n       break;\n     }"}, {"sha": "327bffa6971587062c84f47a5c2b538145dff75a", "filename": "gcc/rust/typecheck/rust-hir-type-check-stmt.h", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5c1531cc41ea7fab4d522dafe3ff725a766fb49/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5c1531cc41ea7fab4d522dafe3ff725a766fb49/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-stmt.h?ref=d5c1531cc41ea7fab4d522dafe3ff725a766fb49", "patch": "@@ -34,21 +34,21 @@ class TypeCheckStmt : public TypeCheckBase\n   using Rust::Resolver::TypeCheckBase::visit;\n \n public:\n-  static TyTy::BaseType *Resolve (HIR::Stmt *stmt, bool inside_loop)\n+  static TyTy::BaseType *Resolve (HIR::Stmt *stmt)\n   {\n-    TypeCheckStmt resolver (inside_loop);\n+    TypeCheckStmt resolver;\n     stmt->accept_vis (resolver);\n     return resolver.infered;\n   }\n \n   void visit (HIR::ExprStmtWithBlock &stmt) override\n   {\n-    infered = TypeCheckExpr::Resolve (stmt.get_expr (), inside_loop);\n+    infered = TypeCheckExpr::Resolve (stmt.get_expr ());\n   }\n \n   void visit (HIR::ExprStmtWithoutBlock &stmt) override\n   {\n-    infered = TypeCheckExpr::Resolve (stmt.get_expr (), inside_loop);\n+    infered = TypeCheckExpr::Resolve (stmt.get_expr ());\n   }\n \n   void visit (HIR::EmptyStmt &stmt) override\n@@ -68,8 +68,7 @@ class TypeCheckStmt : public TypeCheckBase\n   void visit (HIR::ConstantItem &constant) override\n   {\n     TyTy::BaseType *type = TypeCheckType::Resolve (constant.get_type ());\n-    TyTy::BaseType *expr_type\n-      = TypeCheckExpr::Resolve (constant.get_expr (), false);\n+    TyTy::BaseType *expr_type = TypeCheckExpr::Resolve (constant.get_expr ());\n \n     infered = type->unify (expr_type);\n     context->insert_type (constant.get_mappings (), infered);\n@@ -83,8 +82,7 @@ class TypeCheckStmt : public TypeCheckBase\n     TyTy::BaseType *init_expr_ty = nullptr;\n     if (stmt.has_init_expr ())\n       {\n-\tinit_expr_ty\n-\t  = TypeCheckExpr::Resolve (stmt.get_init_expr (), inside_loop);\n+\tinit_expr_ty = TypeCheckExpr::Resolve (stmt.get_init_expr ());\n \tif (init_expr_ty->get_kind () == TyTy::TypeKind::ERROR)\n \t  return;\n \n@@ -494,7 +492,7 @@ class TypeCheckStmt : public TypeCheckBase\n \t\t\t       expected_ret_tyty);\n \n     auto block_expr_ty\n-      = TypeCheckExpr::Resolve (function.get_definition ().get (), false);\n+      = TypeCheckExpr::Resolve (function.get_definition ().get ());\n \n     context->pop_return_type ();\n \n@@ -505,12 +503,9 @@ class TypeCheckStmt : public TypeCheckBase\n   }\n \n private:\n-  TypeCheckStmt (bool inside_loop)\n-    : TypeCheckBase (), infered (nullptr), inside_loop (inside_loop)\n-  {}\n+  TypeCheckStmt () : TypeCheckBase (), infered (nullptr) {}\n \n   TyTy::BaseType *infered;\n-  bool inside_loop;\n };\n \n } // namespace Resolver"}, {"sha": "6634ad4ad7d9e756c9ff06748c0abc62b91e0db7", "filename": "gcc/rust/typecheck/rust-hir-type-check-struct.cc", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5c1531cc41ea7fab4d522dafe3ff725a766fb49/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-struct.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5c1531cc41ea7fab4d522dafe3ff725a766fb49/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-struct.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-struct.cc?ref=d5c1531cc41ea7fab4d522dafe3ff725a766fb49", "patch": "@@ -28,7 +28,7 @@ void\n TypeCheckStructExpr::visit (HIR::StructExprStructFields &struct_expr)\n {\n   TyTy::BaseType *struct_path_ty\n-    = TypeCheckExpr::Resolve (&struct_expr.get_struct_name (), false);\n+    = TypeCheckExpr::Resolve (&struct_expr.get_struct_name ());\n   if (struct_path_ty->get_kind () != TyTy::TypeKind::ADT)\n     {\n       rust_error_at (struct_expr.get_struct_name ().get_locus (),\n@@ -41,8 +41,7 @@ TypeCheckStructExpr::visit (HIR::StructExprStructFields &struct_expr)\n   if (struct_expr.has_struct_base ())\n     {\n       TyTy::BaseType *base_resolved\n-\t= TypeCheckExpr::Resolve (struct_expr.struct_base->base_struct.get (),\n-\t\t\t\t  false);\n+\t= TypeCheckExpr::Resolve (struct_expr.struct_base->base_struct.get ());\n       struct_def\n \t= (TyTy::ADTType *) struct_path_resolved->coerce (base_resolved);\n       if (struct_def == nullptr)\n@@ -221,7 +220,7 @@ TypeCheckStructExpr::visit (HIR::StructExprFieldIdentifierValue &field)\n       return;\n     }\n \n-  TyTy::BaseType *value = TypeCheckExpr::Resolve (field.get_value (), false);\n+  TyTy::BaseType *value = TypeCheckExpr::Resolve (field.get_value ());\n   resolved_field_value_expr = field_type->get_field_type ()->coerce (value);\n   if (resolved_field_value_expr != nullptr)\n     {\n@@ -250,7 +249,7 @@ TypeCheckStructExpr::visit (HIR::StructExprFieldIndexValue &field)\n       return;\n     }\n \n-  TyTy::BaseType *value = TypeCheckExpr::Resolve (field.get_value (), false);\n+  TyTy::BaseType *value = TypeCheckExpr::Resolve (field.get_value ());\n   resolved_field_value_expr = field_type->get_field_type ()->coerce (value);\n   if (resolved_field_value_expr != nullptr)\n     {\n@@ -283,7 +282,7 @@ TypeCheckStructExpr::visit (HIR::StructExprFieldIdentifier &field)\n   // existing code to figure out the type\n   HIR::IdentifierExpr expr (field.get_mappings (), field.get_field_name (),\n \t\t\t    field.get_locus ());\n-  TyTy::BaseType *value = TypeCheckExpr::Resolve (&expr, false);\n+  TyTy::BaseType *value = TypeCheckExpr::Resolve (&expr);\n \n   resolved_field_value_expr = field_type->get_field_type ()->coerce (value);\n   if (resolved_field_value_expr != nullptr)"}, {"sha": "fe961d14fa9e4c2ea214d7d80a169484a79594d1", "filename": "gcc/rust/typecheck/rust-hir-type-check-toplevel.h", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5c1531cc41ea7fab4d522dafe3ff725a766fb49/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-toplevel.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5c1531cc41ea7fab4d522dafe3ff725a766fb49/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-toplevel.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-toplevel.h?ref=d5c1531cc41ea7fab4d522dafe3ff725a766fb49", "patch": "@@ -351,16 +351,15 @@ class TypeCheckTopLevel : public TypeCheckBase\n   void visit (HIR::StaticItem &var) override\n   {\n     TyTy::BaseType *type = TypeCheckType::Resolve (var.get_type ());\n-    TyTy::BaseType *expr_type = TypeCheckExpr::Resolve (var.get_expr (), false);\n+    TyTy::BaseType *expr_type = TypeCheckExpr::Resolve (var.get_expr ());\n \n     context->insert_type (var.get_mappings (), type->unify (expr_type));\n   }\n \n   void visit (HIR::ConstantItem &constant) override\n   {\n     TyTy::BaseType *type = TypeCheckType::Resolve (constant.get_type ());\n-    TyTy::BaseType *expr_type\n-      = TypeCheckExpr::Resolve (constant.get_expr (), false);\n+    TyTy::BaseType *expr_type = TypeCheckExpr::Resolve (constant.get_expr ());\n \n     context->insert_type (constant.get_mappings (), type->unify (expr_type));\n   }"}, {"sha": "85de3a1d07db365cca1bf45eb6b148278854905f", "filename": "gcc/rust/typecheck/rust-hir-type-check-type.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5c1531cc41ea7fab4d522dafe3ff725a766fb49/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5c1531cc41ea7fab4d522dafe3ff725a766fb49/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.cc?ref=d5c1531cc41ea7fab4d522dafe3ff725a766fb49", "patch": "@@ -535,7 +535,7 @@ TypeCheckType::visit (HIR::TraitObjectType &type)\n void\n TypeCheckType::visit (HIR::ArrayType &type)\n {\n-  auto capacity_type = TypeCheckExpr::Resolve (type.get_size_expr (), false);\n+  auto capacity_type = TypeCheckExpr::Resolve (type.get_size_expr ());\n   if (capacity_type->get_kind () == TyTy::TypeKind::ERROR)\n     return;\n "}, {"sha": "1d26d60ccba8dd90bdff9101e5c732220619c1dd", "filename": "gcc/rust/typecheck/rust-hir-type-check.cc", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5c1531cc41ea7fab4d522dafe3ff725a766fb49/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5c1531cc41ea7fab4d522dafe3ff725a766fb49/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc?ref=d5c1531cc41ea7fab4d522dafe3ff725a766fb49", "patch": "@@ -90,15 +90,15 @@ TypeCheckExpr::visit (HIR::BlockExpr &expr)\n       if (!s->is_item ())\n \tcontinue;\n \n-      TypeCheckStmt::Resolve (s.get (), inside_loop);\n+      TypeCheckStmt::Resolve (s.get ());\n     }\n \n   for (auto &s : expr.get_statements ())\n     {\n       if (s->is_item ())\n \tcontinue;\n \n-      auto resolved = TypeCheckStmt::Resolve (s.get (), inside_loop);\n+      auto resolved = TypeCheckStmt::Resolve (s.get ());\n       if (resolved == nullptr)\n \t{\n \t  rust_error_at (s->get_locus (), \"failure to resolve type\");\n@@ -114,9 +114,7 @@ TypeCheckExpr::visit (HIR::BlockExpr &expr)\n     }\n \n   if (expr.has_expr ())\n-    infered\n-      = TypeCheckExpr::Resolve (expr.get_final_expr ().get (), inside_loop)\n-\t  ->clone ();\n+    infered = TypeCheckExpr::Resolve (expr.get_final_expr ().get ())->clone ();\n   else if (expr.is_tail_reachable ())\n     infered\n       = TyTy::TupleType::get_unit_type (expr.get_mappings ().get_hirid ());\n@@ -184,7 +182,7 @@ TraitItemReference::get_type_from_constant (\n   if (constant.has_expr ())\n     {\n       TyTy::BaseType *expr\n-\t= TypeCheckExpr::Resolve (constant.get_expr ().get (), false);\n+\t= TypeCheckExpr::Resolve (constant.get_expr ().get ());\n \n       return type->unify (expr);\n     }"}, {"sha": "07c7a5cf60bda416638d8c5710113974be42f97f", "filename": "gcc/rust/typecheck/rust-hir-type-check.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5c1531cc41ea7fab4d522dafe3ff725a766fb49/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5c1531cc41ea7fab4d522dafe3ff725a766fb49/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.h?ref=d5c1531cc41ea7fab4d522dafe3ff725a766fb49", "patch": "@@ -126,6 +126,8 @@ class TypeCheckContext\n       }\n   }\n \n+  bool have_loop_context () const { return !loop_type_stack.empty (); }\n+\n   void push_new_loop_context (HirId id, Location locus)\n   {\n     TyTy::BaseType *infer_var"}, {"sha": "84aa83545364e3429c50f9f98e41abccb412b460", "filename": "gcc/rust/typecheck/rust-tyty.cc", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5c1531cc41ea7fab4d522dafe3ff725a766fb49/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5c1531cc41ea7fab4d522dafe3ff725a766fb49/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc?ref=d5c1531cc41ea7fab4d522dafe3ff725a766fb49", "patch": "@@ -3227,7 +3227,7 @@ TypeCheckCallExpr::visit (ADTType &type)\n       StructFieldType *field = variant.get_field_at_index (i);\n       BaseType *field_tyty = field->get_field_type ();\n \n-      BaseType *arg = Resolver::TypeCheckExpr::Resolve (argument.get (), false);\n+      BaseType *arg = Resolver::TypeCheckExpr::Resolve (argument.get ());\n       if (arg->get_kind () == TyTy::TypeKind::ERROR)\n \t{\n \t  rust_error_at (argument->get_locus (),\n@@ -3285,7 +3285,7 @@ TypeCheckCallExpr::visit (FnType &type)\n   for (auto &argument : call.get_arguments ())\n     {\n       auto argument_expr_tyty\n-\t= Resolver::TypeCheckExpr::Resolve (argument.get (), false);\n+\t= Resolver::TypeCheckExpr::Resolve (argument.get ());\n       if (argument_expr_tyty->get_kind () == TyTy::TypeKind::ERROR)\n \t{\n \t  rust_error_at (\n@@ -3341,7 +3341,7 @@ TypeCheckCallExpr::visit (FnPtr &type)\n     {\n       auto fnparam = type.param_at (i);\n       auto argument_expr_tyty\n-\t= Resolver::TypeCheckExpr::Resolve (argument.get (), false);\n+\t= Resolver::TypeCheckExpr::Resolve (argument.get ());\n       if (argument_expr_tyty->get_kind () == TyTy::TypeKind::ERROR)\n \t{\n \t  rust_error_at (\n@@ -3396,7 +3396,7 @@ TypeCheckMethodCallExpr::visit (FnType &type)\n     {\n       auto fnparam = type.param_at (i);\n       auto argument_expr_tyty\n-\t= Resolver::TypeCheckExpr::Resolve (argument.get (), false);\n+\t= Resolver::TypeCheckExpr::Resolve (argument.get ());\n       if (argument_expr_tyty->get_kind () == TyTy::TypeKind::ERROR)\n \t{\n \t  rust_error_at ("}]}