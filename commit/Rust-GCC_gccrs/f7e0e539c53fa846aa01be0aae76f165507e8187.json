{"sha": "f7e0e539c53fa846aa01be0aae76f165507e8187", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjdlMGU1MzljNTNmYTg0NmFhMDFiZTBhYWU3NmYxNjU1MDdlODE4Nw==", "commit": {"author": {"name": "David S. Miller", "email": "davem@pierdol.cobaltmicro.com", "date": "1998-07-03T03:19:41Z"}, "committer": {"name": "David S. Miller", "email": "davem@gcc.gnu.org", "date": "1998-07-03T03:19:41Z"}, "message": "sparc.c (sparc_operand, [...]): Recognize CONSTANT_P_RTX.\n\n\t* sparc.c (sparc_operand, move_operand,\tarith_operand,\n\tarith11_operand, arith10_operand, arith_double_operand,\n\tarith11_double_operand, arith10_double_operand, small_int,\n\tuns_small_int): Recognize CONSTANT_P_RTX.\n\t(output_sized_memop, output_move_with_extension,\n\toutput_load_address, output_size_for_block_move,\n\toutput_block_move, delay_operand): Remove, has not been\n\tenabled or referenced for years.\n\t* sparc.md (movstrsi, block_move_insn): Likewise.\n\t* sparc.h (PREDICATE_CODES): Define.\n\t* linux-aout.h (MACHINE_STATE_{SAVE,RESTORE}): Override with\n\tversion which uses getcc/setcc traps to save/restore condition\n\tcodes.\n\t* linux64.h: Likewise.\n\t* sunos4.h: Likewise.\n\t* linux.h: Likewise.\n\t* sol2.h: Likewise.\n\t* sun4o3.h: Likewise.\n\nFrom-SVN: r20917", "tree": {"sha": "3e187973b234063596a26c4c08018efa835ac893", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3e187973b234063596a26c4c08018efa835ac893"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f7e0e539c53fa846aa01be0aae76f165507e8187", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f7e0e539c53fa846aa01be0aae76f165507e8187", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f7e0e539c53fa846aa01be0aae76f165507e8187", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f7e0e539c53fa846aa01be0aae76f165507e8187/comments", "author": null, "committer": null, "parents": [{"sha": "d420e567dc52d4c7c384ffdcefe4bd4ae8f4e30b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d420e567dc52d4c7c384ffdcefe4bd4ae8f4e30b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d420e567dc52d4c7c384ffdcefe4bd4ae8f4e30b"}], "stats": {"total": 634, "additions": 202, "deletions": 432}, "files": [{"sha": "17f45c1251bb53d5900b5788bee7f694d60a900b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7e0e539c53fa846aa01be0aae76f165507e8187/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7e0e539c53fa846aa01be0aae76f165507e8187/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f7e0e539c53fa846aa01be0aae76f165507e8187", "patch": "@@ -1,3 +1,24 @@\n+Fri Jul  3 02:33:35 1998  David S. Miller  <davem@pierdol.cobaltmicro.com>\n+\n+\t* sparc.c (sparc_operand, move_operand,\tarith_operand,\n+\tarith11_operand, arith10_operand, arith_double_operand,\n+\tarith11_double_operand, arith10_double_operand, small_int,\n+\tuns_small_int): Recognize CONSTANT_P_RTX.\n+\t(output_sized_memop, output_move_with_extension,\n+\toutput_load_address, output_size_for_block_move,\n+\toutput_block_move, delay_operand): Remove, has not been\n+\tenabled or referenced for years.\n+\t* sparc.md (movstrsi, block_move_insn): Likewise.\n+\t* sparc.h (PREDICATE_CODES): Define.\n+\t* linux-aout.h (MACHINE_STATE_{SAVE,RESTORE}): Override with\n+\tversion which uses getcc/setcc traps to save/restore condition\n+\tcodes.\n+\t* linux64.h: Likewise.\n+\t* sunos4.h: Likewise.\n+\t* linux.h: Likewise.\n+\t* sol2.h: Likewise.\n+\t* sun4o3.h: Likewise.\n+\n Fri Jul  3 02:28:05 1998  Richard Henderson  <rth@cygnus.com>\n \n \t* alpha.c (alpha_initialize_trampoline): Hack around Pmode/ptr_mode"}, {"sha": "76d7653eaae6ed281c57f382499c8cf782cfa857", "filename": "gcc/config/sparc/linux-aout.h", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7e0e539c53fa846aa01be0aae76f165507e8187/gcc%2Fconfig%2Fsparc%2Flinux-aout.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7e0e539c53fa846aa01be0aae76f165507e8187/gcc%2Fconfig%2Fsparc%2Flinux-aout.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Flinux-aout.h?ref=f7e0e539c53fa846aa01be0aae76f165507e8187", "patch": "@@ -109,3 +109,22 @@ Boston, MA 02111-1307, USA.  */\n    long double yet.  */\n #define LONG_DOUBLE_TYPE_SIZE 128\n #endif\n+\f\n+/* Override MACHINE_STATE_{SAVE,RESTORE} because we have special\n+   traps available which can get and set the condition codes\n+   reliably.  */\n+#undef MACHINE_STATE_SAVE\n+#define MACHINE_STATE_SAVE(ID)\t\t\t\t\\\n+  unsigned long int ms_flags, ms_saveret;\t\t\\\n+  asm volatile(\"ta\t0x20\\n\\t\"\t\t\t\\\n+\t       \"mov\t%%g1, %0\\n\\t\"\t\t\t\\\n+\t       \"mov\t%%g2, %1\\n\\t\"\t\t\t\\\n+\t       : \"=r\" (ms_flags), \"=r\" (ms_saveret));\n+\n+#undef MACHINE_STATE_RESTORE\n+#define MACHINE_STATE_RESTORE(ID)\t\t\t\\\n+  asm volatile(\"mov\t%0, %%g1\\n\\t\"\t\t\t\\\n+\t       \"mov\t%1, %%g2\\n\\t\"\t\t\t\\\n+\t       \"ta\t0x21\\n\\t\"\t\t\t\\\n+\t       : /* no outputs */\t\t\t\\\n+\t       : \"r\" (ms_flags), \"r\" (ms_saveret));"}, {"sha": "fe6bf6a993477fb1c601c8cb0b23f0e7f3b4540c", "filename": "gcc/config/sparc/linux.h", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7e0e539c53fa846aa01be0aae76f165507e8187/gcc%2Fconfig%2Fsparc%2Flinux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7e0e539c53fa846aa01be0aae76f165507e8187/gcc%2Fconfig%2Fsparc%2Flinux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Flinux.h?ref=f7e0e539c53fa846aa01be0aae76f165507e8187", "patch": "@@ -238,3 +238,22 @@ do {\t\t\t\t\t\t\t\t\t\\\n    long double yet.  */\n #define LONG_DOUBLE_TYPE_SIZE 128\n #endif\n+\f\n+/* Override MACHINE_STATE_{SAVE,RESTORE} because we have special\n+   traps available which can get and set the condition codes\n+   reliably.  */\n+#undef MACHINE_STATE_SAVE\n+#define MACHINE_STATE_SAVE(ID)\t\t\t\t\\\n+  unsigned long int ms_flags, ms_saveret;\t\t\\\n+  asm volatile(\"ta\t0x20\\n\\t\"\t\t\t\\\n+\t       \"mov\t%%g1, %0\\n\\t\"\t\t\t\\\n+\t       \"mov\t%%g2, %1\\n\\t\"\t\t\t\\\n+\t       : \"=r\" (ms_flags), \"=r\" (ms_saveret));\n+\n+#undef MACHINE_STATE_RESTORE\n+#define MACHINE_STATE_RESTORE(ID)\t\t\t\\\n+  asm volatile(\"mov\t%0, %%g1\\n\\t\"\t\t\t\\\n+\t       \"mov\t%1, %%g2\\n\\t\"\t\t\t\\\n+\t       \"ta\t0x21\\n\\t\"\t\t\t\\\n+\t       : /* no outputs */\t\t\t\\\n+\t       : \"r\" (ms_flags), \"r\" (ms_saveret));"}, {"sha": "866d357c8cfd626dabd8a157d6c60686fc30c818", "filename": "gcc/config/sparc/linux64.h", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7e0e539c53fa846aa01be0aae76f165507e8187/gcc%2Fconfig%2Fsparc%2Flinux64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7e0e539c53fa846aa01be0aae76f165507e8187/gcc%2Fconfig%2Fsparc%2Flinux64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Flinux64.h?ref=f7e0e539c53fa846aa01be0aae76f165507e8187", "patch": "@@ -224,3 +224,22 @@ do {\t\t\t\t\t\t\t\t\t\\\n    RELATIVE relocations.  */\n \n /* #define DWARF_OFFSET_SIZE PTR_SIZE */\n+\f\n+/* Override MACHINE_STATE_{SAVE,RESTORE} because we have special\n+   traps available which can get and set the condition codes\n+   reliably.  */\n+#undef MACHINE_STATE_SAVE\n+#define MACHINE_STATE_SAVE(ID)\t\t\t\t\\\n+  unsigned long int ms_flags, ms_saveret;\t\t\\\n+  asm volatile(\"ta\t0x20\\n\\t\"\t\t\t\\\n+\t       \"mov\t%%g1, %0\\n\\t\"\t\t\t\\\n+\t       \"mov\t%%g2, %1\\n\\t\"\t\t\t\\\n+\t       : \"=r\" (ms_flags), \"=r\" (ms_saveret));\n+\n+#undef MACHINE_STATE_RESTORE\n+#define MACHINE_STATE_RESTORE(ID)\t\t\t\\\n+  asm volatile(\"mov\t%0, %%g1\\n\\t\"\t\t\t\\\n+\t       \"mov\t%1, %%g2\\n\\t\"\t\t\t\\\n+\t       \"ta\t0x21\\n\\t\"\t\t\t\\\n+\t       : /* no outputs */\t\t\t\\\n+\t       : \"r\" (ms_flags), \"r\" (ms_saveret));"}, {"sha": "a0fa4a864e1d3d313605095fecd95d4cd0f773b2", "filename": "gcc/config/sparc/sol2.h", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7e0e539c53fa846aa01be0aae76f165507e8187/gcc%2Fconfig%2Fsparc%2Fsol2.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7e0e539c53fa846aa01be0aae76f165507e8187/gcc%2Fconfig%2Fsparc%2Fsol2.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsol2.h?ref=f7e0e539c53fa846aa01be0aae76f165507e8187", "patch": "@@ -210,4 +210,23 @@ Boston, MA 02111-1307, USA.  */\n    sparc_override_options will disable V8+ if not generating V9 code.  */\n #undef TARGET_DEFAULT\n #define TARGET_DEFAULT (MASK_APP_REGS + MASK_EPILOGUE + MASK_FPU + MASK_V8PLUS)\n+\f\n+/* Override MACHINE_STATE_{SAVE,RESTORE} because we have special\n+   traps available which can get and set the condition codes\n+   reliably.  */\n+#undef MACHINE_STATE_SAVE\n+#define MACHINE_STATE_SAVE(ID)\t\t\t\t\\\n+  unsigned long int ms_flags, ms_saveret;\t\t\\\n+  asm volatile(\"ta\t0x20\\n\\t\"\t\t\t\\\n+\t       \"mov\t%%g1, %0\\n\\t\"\t\t\t\\\n+\t       \"mov\t%%g2, %1\\n\\t\"\t\t\t\\\n+\t       : \"=r\" (ms_flags), \"=r\" (ms_saveret));\n+\n+#undef MACHINE_STATE_RESTORE\n+#define MACHINE_STATE_RESTORE(ID)\t\t\t\\\n+  asm volatile(\"mov\t%0, %%g1\\n\\t\"\t\t\t\\\n+\t       \"mov\t%1, %%g2\\n\\t\"\t\t\t\\\n+\t       \"ta\t0x21\\n\\t\"\t\t\t\\\n+\t       : /* no outputs */\t\t\t\\\n+\t       : \"r\" (ms_flags), \"r\" (ms_saveret));\n "}, {"sha": "62be726e7a0c865d001df13876372c5c15d4cc8c", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 23, "deletions": 382, "changes": 405, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7e0e539c53fa846aa01be0aae76f165507e8187/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7e0e539c53fa846aa01be0aae76f165507e8187/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=f7e0e539c53fa846aa01be0aae76f165507e8187", "patch": "@@ -641,7 +641,8 @@ sparc_operand (op, mode)\n      rtx op;\n      enum machine_mode mode;\n {\n-  if (register_operand (op, mode))\n+  if (register_operand (op, mode)\n+      || GET_CODE (op) == CONSTANT_P_RTX)\n     return 1;\n   if (GET_CODE (op) == CONST_INT)\n     return SMALL_INT (op);\n@@ -666,7 +667,8 @@ move_operand (op, mode)\n {\n   if (mode == DImode && arith_double_operand (op, mode))\n     return 1;\n-  if (register_operand (op, mode))\n+  if (register_operand (op, mode)\n+      || GET_CODE (op) == CONSTANT_P_RTX)\n     return 1;\n   if (GET_CODE (op) == CONST_INT)\n     return SMALL_INT (op) || SPARC_SETHI_P (INTVAL (op));\n@@ -773,6 +775,7 @@ v9_regcmp_op (op, mode)\n   return v9_regcmp_p (code);\n }\n \n+/* ??? Same as eq_or_neq.  */\n int\n v8plus_regcmp_op (op, mode)\n      register rtx op;\n@@ -834,7 +837,8 @@ arith_operand (op, mode)\n      enum machine_mode mode;\n {\n   int val;\n-  if (register_operand (op, mode))\n+  if (register_operand (op, mode)\n+      || GET_CODE (op) == CONSTANT_P_RTX)\n     return 1;\n   if (GET_CODE (op) != CONST_INT)\n     return 0;\n@@ -852,6 +856,7 @@ arith11_operand (op, mode)\n      enum machine_mode mode;\n {\n   return (register_operand (op, mode)\n+\t  || GET_CODE (op) == CONSTANT_P_RTX\n \t  || (GET_CODE (op) == CONST_INT && SPARC_SIMM11_P (INTVAL (op))));\n }\n \n@@ -865,6 +870,7 @@ arith10_operand (op, mode)\n      enum machine_mode mode;\n {\n   return (register_operand (op, mode)\n+\t  || GET_CODE (op) == CONSTANT_P_RTX\n \t  || (GET_CODE (op) == CONST_INT && SPARC_SIMM10_P (INTVAL (op))));\n }\n \n@@ -881,6 +887,7 @@ arith_double_operand (op, mode)\n      enum machine_mode mode;\n {\n   return (register_operand (op, mode)\n+\t  || GET_CODE (op) == CONSTANT_P_RTX\n \t  || (GET_CODE (op) == CONST_INT && SMALL_INT (op))\n \t  || (! TARGET_ARCH64\n \t      && GET_CODE (op) == CONST_DOUBLE\n@@ -906,6 +913,7 @@ arith11_double_operand (op, mode)\n      enum machine_mode mode;\n {\n   return (register_operand (op, mode)\n+\t  || GET_CODE (op) == CONSTANT_P_RTX\n \t  || (GET_CODE (op) == CONST_DOUBLE\n \t      && (GET_MODE (op) == mode || GET_MODE (op) == VOIDmode)\n \t      && (unsigned HOST_WIDE_INT) (CONST_DOUBLE_LOW (op) + 0x400) < 0x800\n@@ -929,6 +937,7 @@ arith10_double_operand (op, mode)\n      enum machine_mode mode;\n {\n   return (register_operand (op, mode)\n+\t  || GET_CODE (op) == CONSTANT_P_RTX\n \t  || (GET_CODE (op) == CONST_DOUBLE\n \t      && (GET_MODE (op) == mode || GET_MODE (op) == VOIDmode)\n \t      && (unsigned) (CONST_DOUBLE_LOW (op) + 0x200) < 0x400\n@@ -950,7 +959,8 @@ small_int (op, mode)\n      rtx op;\n      enum machine_mode mode ATTRIBUTE_UNUSED;\n {\n-  return (GET_CODE (op) == CONST_INT && SMALL_INT (op));\n+  return ((GET_CODE (op) == CONST_INT && SMALL_INT (op))\n+\t  || GET_CODE (op) == CONSTANT_P_RTX);\n }\n \n /* Recognize operand values for the umul instruction.  That instruction sign\n@@ -964,14 +974,16 @@ uns_small_int (op, mode)\n {\n #if HOST_BITS_PER_WIDE_INT > 32\n   /* All allowed constants will fit a CONST_INT.  */\n-  return (GET_CODE (op) == CONST_INT\n-\t  && ((INTVAL (op) >= 0 && INTVAL (op) < 0x1000)\n-\t      || (INTVAL (op) >= 0xFFFFF000 && INTVAL (op) < 0x100000000L)));\n+  return ((GET_CODE (op) == CONST_INT\n+\t   && ((INTVAL (op) >= 0 && INTVAL (op) < 0x1000)\n+\t       || (INTVAL (op) >= 0xFFFFF000 && INTVAL (op) < 0x100000000L)))\n+\t  || GET_CODE (op) == CONSTANT_P_RTX);\n #else\n-  return ((GET_CODE (op) == CONST_INT && (unsigned) INTVAL (op) < 0x1000)\n-\t  || (GET_CODE (op) == CONST_DOUBLE\n-\t      && CONST_DOUBLE_HIGH (op) == 0\n-\t      && (unsigned) CONST_DOUBLE_LOW (op) - 0xFFFFF000 < 0x1000));\n+  return (((GET_CODE (op) == CONST_INT && (unsigned) INTVAL (op) < 0x1000)\n+\t   || (GET_CODE (op) == CONST_DOUBLE\n+\t       && CONST_DOUBLE_HIGH (op) == 0\n+\t       && (unsigned) CONST_DOUBLE_LOW (op) - 0xFFFFF000 < 0x1000))\n+\t  || GET_CODE (op) == CONSTANT_P_RTX);\n #endif\n }\n \n@@ -2685,350 +2697,6 @@ find_addr_reg (addr)\n     return addr;\n   abort ();\n }\n-\n-#if 0 /* not currently used */\n-\n-void\n-output_sized_memop (opname, mode, signedp)\n-     char *opname;\n-     enum machine_mode mode;\n-     int signedp;\n-{\n-  static char *ld_size_suffix_u[] = { \"ub\", \"uh\", \"\", \"?\", \"d\" };\n-  static char *ld_size_suffix_s[] = { \"sb\", \"sh\", \"\", \"?\", \"d\" };\n-  static char *st_size_suffix[] = { \"b\", \"h\", \"\", \"?\", \"d\" };\n-  char **opnametab, *modename;\n-\n-  if (opname[0] == 'l')\n-    if (signedp)\n-      opnametab = ld_size_suffix_s;\n-    else\n-      opnametab = ld_size_suffix_u;\n-  else\n-    opnametab = st_size_suffix;\n-  modename = opnametab[GET_MODE_SIZE (mode) >> 1];\n-\n-  fprintf (asm_out_file, \"\\t%s%s\", opname, modename);\n-}\n-\n-void\n-output_move_with_extension (operands)\n-     rtx *operands;\n-{\n-  if (GET_MODE (operands[2]) == HImode)\n-    output_asm_insn (\"sll %2,0x10,%0\", operands);\n-  else if (GET_MODE (operands[2]) == QImode)\n-    output_asm_insn (\"sll %2,0x18,%0\", operands);\n-  else\n-    abort ();\n-}\n-#endif /* not currently used */\n-\f\n-#if 0\n-/* ??? These are only used by the movstrsi pattern, but we get better code\n-   in general without that, because emit_block_move can do just as good a\n-   job as this function does when alignment and size are known.  When they\n-   aren't known, a call to strcpy may be faster anyways, because it is\n-   likely to be carefully crafted assembly language code, and below we just\n-   do a byte-wise copy.\n-\n-   Also, emit_block_move expands into multiple read/write RTL insns, which\n-   can then be optimized, whereas our movstrsi pattern can not be optimized\n-   at all.  */\n-\n-/* Load the address specified by OPERANDS[3] into the register\n-   specified by OPERANDS[0].\n-\n-   OPERANDS[3] may be the result of a sum, hence it could either be:\n-\n-   (1) CONST\n-   (2) REG\n-   (2) REG + CONST_INT\n-   (3) REG + REG + CONST_INT\n-   (4) REG + REG  (special case of 3).\n-\n-   Note that (3) is not a legitimate address.\n-   All cases are handled here.  */\n-\n-void\n-output_load_address (operands)\n-     rtx *operands;\n-{\n-  rtx base, offset;\n-\n-  if (CONSTANT_P (operands[3]))\n-    {\n-      output_asm_insn (\"set %3,%0\", operands);\n-      return;\n-    }\n-\n-  if (REG_P (operands[3]))\n-    {\n-      if (REGNO (operands[0]) != REGNO (operands[3]))\n-\toutput_asm_insn (\"mov %3,%0\", operands);\n-      return;\n-    }\n-\n-  if (GET_CODE (operands[3]) != PLUS)\n-    abort ();\n-\n-  base = XEXP (operands[3], 0);\n-  offset = XEXP (operands[3], 1);\n-\n-  if (GET_CODE (base) == CONST_INT)\n-    {\n-      rtx tmp = base;\n-      base = offset;\n-      offset = tmp;\n-    }\n-\n-  if (GET_CODE (offset) != CONST_INT)\n-    {\n-      /* Operand is (PLUS (REG) (REG)).  */\n-      base = operands[3];\n-      offset = const0_rtx;\n-    }\n-\n-  if (REG_P (base))\n-    {\n-      operands[6] = base;\n-      operands[7] = offset;\n-      if (SMALL_INT (offset))\n-\toutput_asm_insn (\"add %6,%7,%0\", operands);\n-      else\n-\toutput_asm_insn (\"set %7,%0\\n\\tadd %0,%6,%0\", operands);\n-    }\n-  else if (GET_CODE (base) == PLUS)\n-    {\n-      operands[6] = XEXP (base, 0);\n-      operands[7] = XEXP (base, 1);\n-      operands[8] = offset;\n-\n-      if (SMALL_INT (offset))\n-\toutput_asm_insn (\"add %6,%7,%0\\n\\tadd %0,%8,%0\", operands);\n-      else\n-\toutput_asm_insn (\"set %8,%0\\n\\tadd %0,%6,%0\\n\\tadd %0,%7,%0\", operands);\n-    }\n-  else\n-    abort ();\n-}\n-\n-/* Output code to place a size count SIZE in register REG.\n-   ALIGN is the size of the unit of transfer.\n-\n-   Because block moves are pipelined, we don't include the\n-   first element in the transfer of SIZE to REG.  */\n-\n-static void\n-output_size_for_block_move (size, reg, align)\n-     rtx size, reg;\n-     rtx align;\n-{\n-  rtx xoperands[3];\n-\n-  xoperands[0] = reg;\n-  xoperands[1] = size;\n-  xoperands[2] = align;\n-  if (GET_CODE (size) == REG)\n-    output_asm_insn (\"sub %1,%2,%0\", xoperands);\n-  else\n-    {\n-      xoperands[1]\n-\t= GEN_INT (INTVAL (size) - INTVAL (align));\n-      output_asm_insn (\"set %1,%0\", xoperands);\n-    }\n-}\n-\n-/* Emit code to perform a block move.\n-\n-   OPERANDS[0] is the destination.\n-   OPERANDS[1] is the source.\n-   OPERANDS[2] is the size.\n-   OPERANDS[3] is the alignment safe to use.\n-   OPERANDS[4] is a register we can safely clobber as a temp.  */\n-\n-char *\n-output_block_move (operands)\n-     rtx *operands;\n-{\n-  /* A vector for our computed operands.  Note that load_output_address\n-     makes use of (and can clobber) up to the 8th element of this vector.  */\n-  rtx xoperands[10];\n-  rtx zoperands[10];\n-  static int movstrsi_label = 0;\n-  int i;\n-  rtx temp1 = operands[4];\n-  rtx sizertx = operands[2];\n-  rtx alignrtx = operands[3];\n-  int align = INTVAL (alignrtx);\n-  char label3[30], label5[30];\n-\n-  xoperands[0] = operands[0];\n-  xoperands[1] = operands[1];\n-  xoperands[2] = temp1;\n-\n-  /* We can't move more than this many bytes at a time because we have only\n-     one register, %g1, to move them through.  */\n-  if (align > UNITS_PER_WORD)\n-    {\n-      align = UNITS_PER_WORD;\n-      alignrtx = GEN_INT (UNITS_PER_WORD);\n-    }\n-\n-  /* We consider 8 ld/st pairs, for a total of 16 inline insns to be\n-     reasonable here.  (Actually will emit a maximum of 18 inline insns for\n-     the case of size == 31 and align == 4).  */\n-\n-  if (GET_CODE (sizertx) == CONST_INT && (INTVAL (sizertx) / align) <= 8\n-      && memory_address_p (QImode, plus_constant_for_output (xoperands[0],\n-\t\t\t\t\t\t\t     INTVAL (sizertx)))\n-      && memory_address_p (QImode, plus_constant_for_output (xoperands[1],\n-\t\t\t\t\t\t\t     INTVAL (sizertx))))\n-    {\n-      int size = INTVAL (sizertx);\n-      int offset = 0;\n-\n-      /* We will store different integers into this particular RTX.  */\n-      xoperands[2] = rtx_alloc (CONST_INT);\n-      PUT_MODE (xoperands[2], VOIDmode);\n-\n-      /* This case is currently not handled.  Abort instead of generating\n-\t bad code.  */\n-      if (align > UNITS_PER_WORD)\n-\tabort ();\n-\n-      if (TARGET_ARCH64 && align >= 8)\n-\t{\n-\t  for (i = (size >> 3) - 1; i >= 0; i--)\n-\t    {\n-\t      INTVAL (xoperands[2]) = (i << 3) + offset;\n-\t      output_asm_insn (\"ldx [%a1+%2],%%g1\\n\\tstx %%g1,[%a0+%2]\",\n-\t\t\t       xoperands);\n-\t    }\n-\t  offset += (size & ~0x7);\n-\t  size = size & 0x7;\n-\t  if (size == 0)\n-\t    return \"\";\n-\t}\n-\n-      if (align >= 4)\n-\t{\n-\t  for (i = (size >> 2) - 1; i >= 0; i--)\n-\t    {\n-\t      INTVAL (xoperands[2]) = (i << 2) + offset;\n-\t      output_asm_insn (\"ld [%a1+%2],%%g1\\n\\tst %%g1,[%a0+%2]\",\n-\t\t\t       xoperands);\n-\t    }\n-\t  offset += (size & ~0x3);\n-\t  size = size & 0x3;\n-\t  if (size == 0)\n-\t    return \"\";\n-\t}\n-\n-      if (align >= 2)\n-\t{\n-\t  for (i = (size >> 1) - 1; i >= 0; i--)\n-\t    {\n-\t      INTVAL (xoperands[2]) = (i << 1) + offset;\n-\t      output_asm_insn (\"lduh [%a1+%2],%%g1\\n\\tsth %%g1,[%a0+%2]\",\n-\t\t\t       xoperands);\n-\t    }\n-\t  offset += (size & ~0x1);\n-\t  size = size & 0x1;\n-\t  if (size == 0)\n-\t    return \"\";\n-\t}\n-\n-      if (align >= 1)\n-\t{\n-\t  for (i = size - 1; i >= 0; i--)\n-\t    {\n-\t      INTVAL (xoperands[2]) = i + offset;\n-\t      output_asm_insn (\"ldub [%a1+%2],%%g1\\n\\tstb %%g1,[%a0+%2]\",\n-\t\t\t       xoperands);\n-\t    }\n-\t  return \"\";\n-\t}\n-\n-      /* We should never reach here.  */\n-      abort ();\n-    }\n-\n-  /* If the size isn't known to be a multiple of the alignment,\n-     we have to do it in smaller pieces.  If we could determine that\n-     the size was a multiple of 2 (or whatever), we could be smarter\n-     about this.  */\n-  if (GET_CODE (sizertx) != CONST_INT)\n-    align = 1;\n-  else\n-    {\n-      int size = INTVAL (sizertx);\n-      while (size % align)\n-\talign >>= 1;\n-    }\n-\n-  if (align != INTVAL (alignrtx))\n-    alignrtx = GEN_INT (align);\n-\n-  xoperands[3] = GEN_INT (movstrsi_label++);\n-  xoperands[4] = GEN_INT (align);\n-  xoperands[5] = GEN_INT (movstrsi_label++);\n-\n-  ASM_GENERATE_INTERNAL_LABEL (label3, \"Lm\", INTVAL (xoperands[3]));\n-  ASM_GENERATE_INTERNAL_LABEL (label5, \"Lm\", INTVAL (xoperands[5]));\n-\n-  /* This is the size of the transfer.  Emit code to decrement the size\n-     value by ALIGN, and store the result in the temp1 register.  */\n-  output_size_for_block_move (sizertx, temp1, alignrtx);\n-\n-  /* Must handle the case when the size is zero or negative, so the first thing\n-     we do is compare the size against zero, and only copy bytes if it is\n-     zero or greater.  Note that we have already subtracted off the alignment\n-     once, so we must copy 1 alignment worth of bytes if the size is zero\n-     here.\n-\n-     The SUN assembler complains about labels in branch delay slots, so we\n-     do this before outputting the load address, so that there will always\n-     be a harmless insn between the branch here and the next label emitted\n-     below.  */\n-\n-  {\n-    char pattern[100];\n-\n-    sprintf (pattern, \"cmp %%2,0\\n\\tbl %s\", &label5[1]);\n-    output_asm_insn (pattern, xoperands);\n-  }\n-\n-  zoperands[0] = operands[0];\n-  zoperands[3] = plus_constant_for_output (operands[0], align);\n-  output_load_address (zoperands);\n-\n-  /* ??? This might be much faster if the loops below were preconditioned\n-     and unrolled.\n-\n-     That is, at run time, copy enough bytes one at a time to ensure that the\n-     target and source addresses are aligned to the largest possible\n-     alignment.  Then use a preconditioned unrolled loop to copy say 16\n-     bytes at a time.  Then copy bytes one at a time until finish the rest.  */\n-\n-  /* Output the first label separately, so that it is spaced properly.  */\n-\n-  ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"Lm\", INTVAL (xoperands[3]));\n-\n-  {\n-    char pattern[200];\n-    register char *ld_suffix = ((align == 1) ? \"ub\" : (align == 2) ? \"uh\"\n-\t\t\t\t: (align == 8 && TARGET_ARCH64) ? \"x\" : \"\");\n-    register char *st_suffix = ((align == 1) ? \"b\" : (align == 2) ? \"h\"\n-\t\t\t\t: (align == 8 && TARGET_ARCH64) ? \"x\" : \"\");\n-\n-    sprintf (pattern, \"ld%s [%%1+%%2],%%%%g1\\n\\tsubcc %%2,%%4,%%2\\n\\tbge %s\\n\\tst%s %%%%g1,[%%0+%%2]\\n%s:\", ld_suffix, &label3[1], st_suffix, &label5[1]);\n-    output_asm_insn (pattern, xoperands);\n-  }\n-\n-  return \"\";\n-}\n-#endif\n \f\n /* Output reasonable peephole for set-on-condition-code insns.\n    Note that these insns assume a particular way of defining\n@@ -6798,30 +6466,3 @@ sparc_return_peephole_ok (dest, src)\n     return 0;\n   return IN_OR_GLOBAL_P (dest);\n }\n-\n-int\n-delay_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n-{\n-  switch (GET_CODE (op))\n-    {\n-    case CONST:\n-    case CONST_INT:\n-    case SYMBOL_REF:\n-    case LABEL_REF:\n-      return 1;\n-\n-    case MEM:\n-      return delay_operand (XEXP (op, 0), Pmode);\n-\n-    case REG:\n-      return IN_OR_GLOBAL_P (op);\n-\n-    case PLUS:\n-      return delay_operand (XEXP (op, 0), Pmode) && delay_operand (XEXP (op, 1), Pmode);\n-\n-    default:\n-      return 0;\n-    }\n-}"}, {"sha": "1e0c64475b28282f8c5ad449af5b3f0b6d6f14ae", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7e0e539c53fa846aa01be0aae76f165507e8187/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7e0e539c53fa846aa01be0aae76f165507e8187/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=f7e0e539c53fa846aa01be0aae76f165507e8187", "patch": "@@ -3186,6 +3186,49 @@ do {\t\t\t\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\\\n }\n \n+/* Define the codes that are matched by predicates in sparc.c.  */\n+\n+#define PREDICATE_CODES\t\t\t\t\t\t\t\t    \\\n+{\"reg_or_0_operand\", {SUBREG, REG, CONST_INT, CONST_DOUBLE}},\t\t\t    \\\n+{\"fp_zero_operand\", {CONST_DOUBLE}},\t\t\t\t\t\t    \\\n+{\"intreg_operand\", {SUBREG, REG}},\t\t\t\t\t\t    \\\n+{\"fcc_reg_operand\", {REG}},\t\t\t\t\t\t\t    \\\n+{\"icc_or_fcc_reg_operand\", {REG}},\t\t\t\t\t\t    \\\n+{\"restore_operand\", {REG}},\t\t\t\t\t\t\t    \\\n+{\"call_operand\", {MEM}},\t\t\t\t\t\t\t    \\\n+{\"call_operand_address\", {SYMBOL_REF, LABEL_REF, CONST, CONST_DOUBLE, ADDRESSOF,    \\\n+                          SUBREG, REG, PLUS, LO_SUM, CONST_INT}},\t\t    \\\n+{\"symbolic_operand\", {SYMBOL_REF, LABEL_REF, CONST, CONST_DOUBLE}},\t\t    \\\n+{\"symbolic_memory_operand\", {SUBREG, MEM}},\t\t\t\t\t    \\\n+{\"label_ref_operand\", {LABEL_REF}},\t\t\t\t\t\t    \\\n+{\"sp64_medium_pic_operand\", {CONST}},\t\t\t\t\t\t    \\\n+{\"data_segment_operand\", {SYMBOL_REF, PLUS, CONST}},\t\t\t\t    \\\n+{\"text_segment_operand\", {LABEL_REF, SYMBOL_REF, PLUS, CONST}},\t\t\t    \\\n+{\"reg_or_nonsymb_mem_operand\", {SUBREG, REG, MEM}},\t\t\t\t    \\\n+{\"sparc_operand\", {SUBREG, REG, CONSTANT_P_RTX, CONST_INT, MEM}},\t\t    \\\n+{\"move_operand\", {SUBREG, REG, CONSTANT_P_RTX, CONST_INT, CONST_DOUBLE, MEM}},\t    \\\n+{\"splittable_symbolic_memory_operand\", {MEM}},\t\t\t\t\t    \\\n+{\"splittable_immediate_memory_operand\", {MEM}},\t\t\t\t\t    \\\n+{\"eq_or_neq\", {EQ, NE}},\t\t\t\t\t\t\t    \\\n+{\"normal_comp_operator\", {GE, GT, LE, LT, GTU, LEU}},\t\t\t\t    \\\n+{\"noov_compare_op\", {NE, EQ, GE, GT, LE, LT, GEU, GTU, LEU, LTU}},\t\t    \\\n+{\"v9_regcmp_op\", {EQ, NE, GE, LT, LE, GT}},\t\t\t\t\t    \\\n+{\"v8plus_regcmp_op\", {EQ, NE}},\t\t\t\t\t\t\t    \\\n+{\"extend_op\", {SIGN_EXTEND, ZERO_EXTEND}},\t\t\t\t\t    \\\n+{\"cc_arithop\", {AND, IOR, XOR}},\t\t\t\t\t\t    \\\n+{\"cc_arithopn\", {AND, IOR}},\t\t\t\t\t\t\t    \\\n+{\"arith_operand\", {SUBREG, REG, CONSTANT_P_RTX, CONST_INT}},\t\t\t    \\\n+{\"arith11_operand\", {SUBREG, REG, CONSTANT_P_RTX, CONST_INT}},\t\t\t    \\\n+{\"arith10_operand\", {SUBREG, REG, CONSTANT_P_RTX, CONST_INT}},\t\t\t    \\\n+{\"arith_double_operand\", {SUBREG, REG, CONSTANT_P_RTX, CONST_INT, CONST_DOUBLE}},   \\\n+{\"arith11_double_operand\", {SUBREG, REG, CONSTANT_P_RTX, CONST_INT, CONST_DOUBLE}}, \\\n+{\"arith10_double_operand\", {SUBREG, REG, CONSTANT_P_RTX, CONST_INT, CONST_DOUBLE}}, \\\n+{\"small_int\", {CONST_INT, CONSTANT_P_RTX}},\t\t\t\t\t    \\\n+{\"uns_small_int\", {CONST_INT, CONSTANT_P_RTX}},\t\t\t\t\t    \\\n+{\"uns_arith_operand\", {SUBREG, REG, CONST_INT, CONSTANT_P_RTX}},\t\t    \\\n+{\"clobbered_register\", {REG}},\n+\n+\n /* The number of Pmode words for the setjmp buffer.  */\n #define JMP_BUF_SIZE 12\n "}, {"sha": "ca8de61c04d61e40c9f2655b658ab6c61f97a1f3", "filename": "gcc/config/sparc/sparc.md", "status": "modified", "additions": 0, "deletions": 49, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7e0e539c53fa846aa01be0aae76f165507e8187/gcc%2Fconfig%2Fsparc%2Fsparc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7e0e539c53fa846aa01be0aae76f165507e8187/gcc%2Fconfig%2Fsparc%2Fsparc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.md?ref=f7e0e539c53fa846aa01be0aae76f165507e8187", "patch": "@@ -2314,55 +2314,6 @@\n ;; ??? There's no symbolic (set (mem:DI ...) ...).\n ;; Experimentation with v9 suggested one isn't needed.\n \f\n-;; Block move insns.\n-\n-;; ??? We get better code without it.  See output_block_move in sparc.c.\n-\n-;; The definition of this insn does not really explain what it does,\n-;; but it should suffice\n-;; that anything generated as this insn will be recognized as one\n-;; and that it will not successfully combine with anything.\n-;(define_expand \"movstrsi\"\n-;  [(parallel [(set (mem:BLK (match_operand:BLK 0 \"general_operand\" \"\"))\n-;\t\t   (mem:BLK (match_operand:BLK 1 \"general_operand\" \"\")))\n-;\t      (use (match_operand:SI 2 \"nonmemory_operand\" \"\"))\n-;\t      (use (match_operand:SI 3 \"immediate_operand\" \"\"))\n-;\t      (clobber (match_dup 0))\n-;\t      (clobber (match_dup 1))\n-;\t      (clobber (match_scratch:SI 4 \"\"))\n-;\t      (clobber (reg:SI 100))\n-;\t      (clobber (reg:SI 1))])]\n-;  \"\"\n-;  \"\n-;{\n-;  /* If the size isn't known, don't emit inline code.  output_block_move\n-;     would output code that's much slower than the library function.\n-;     Also don't output code for large blocks.  */\n-;  if (GET_CODE (operands[2]) != CONST_INT\n-;      || GET_CODE (operands[3]) != CONST_INT\n-;      || INTVAL (operands[2]) / INTVAL (operands[3]) > 16)\n-;    FAIL;\n-;\n-;  operands[0] = copy_to_mode_reg (Pmode, XEXP (operands[0], 0));\n-;  operands[1] = copy_to_mode_reg (Pmode, XEXP (operands[1], 0));\n-;  operands[2] = force_not_mem (operands[2]);\n-;}\")\n-\n-;(define_insn \"*block_move_insn\"\n-;  [(set (mem:BLK (match_operand:SI 0 \"register_operand\" \"+r\"))\n-;\t(mem:BLK (match_operand:SI 1 \"register_operand\" \"+r\")))\n-;   (use (match_operand:SI 2 \"nonmemory_operand\" \"rn\"))\n-;   (use (match_operand:SI 3 \"immediate_operand\" \"i\"))\n-;   (clobber (match_dup 0))\n-;   (clobber (match_dup 1))\n-;   (clobber (match_scratch:SI 4 \"=&r\"))\n-;   (clobber (reg:SI 100))\n-;   (clobber (reg:SI 1))]\n-;  \"\"\n-;  \"* return output_block_move (operands);\"\n-;  [(set_attr \"type\" \"multi\")\n-;   (set_attr \"length\" \"6\")])\n-\f\n ;; Floating point move insns\n \n ;; This pattern forces (set (reg:SF ...) (const_double ...))"}, {"sha": "10c73916b603756aca651fcab174b76cd0d3eb05", "filename": "gcc/config/sparc/sun4o3.h", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7e0e539c53fa846aa01be0aae76f165507e8187/gcc%2Fconfig%2Fsparc%2Fsun4o3.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7e0e539c53fa846aa01be0aae76f165507e8187/gcc%2Fconfig%2Fsparc%2Fsun4o3.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsun4o3.h?ref=f7e0e539c53fa846aa01be0aae76f165507e8187", "patch": "@@ -5,6 +5,25 @@\n   fprintf (FILE, \"\\tsethi %%hi(LP%d),%%o0\\n\\tcall .mcount\\n\\tor %%lo(LP%d),%%o0,%%o0\\n\", \\\n \t   (LABELNO), (LABELNO))\n \n-/* LINK_SPEC is needed only for Sunos 4.  */\n+/* LINK_SPEC is needed only for SunOS 4.  */\n \n #undef LINK_SPEC\n+\n+/* Override MACHINE_STATE_{SAVE,RESTORE} because we have special\n+   traps available which can get and set the condition codes\n+   reliably.  */\n+#undef MACHINE_STATE_SAVE\n+#define MACHINE_STATE_SAVE(ID)\t\t\t\t\\\n+  unsigned long int ms_flags, ms_saveret;\t\t\\\n+  asm volatile(\"ta\t0x20\\n\\t\"\t\t\t\\\n+\t       \"mov\t%%g1, %0\\n\\t\"\t\t\t\\\n+\t       \"mov\t%%g2, %1\\n\\t\"\t\t\t\\\n+\t       : \"=r\" (ms_flags), \"=r\" (ms_saveret));\n+\n+#undef MACHINE_STATE_RESTORE\n+#define MACHINE_STATE_RESTORE(ID)\t\t\t\\\n+  asm volatile(\"mov\t%0, %%g1\\n\\t\"\t\t\t\\\n+\t       \"mov\t%1, %%g2\\n\\t\"\t\t\t\\\n+\t       \"ta\t0x21\\n\\t\"\t\t\t\\\n+\t       : /* no outputs */\t\t\t\\\n+\t       : \"r\" (ms_flags), \"r\" (ms_saveret));"}, {"sha": "14c7a437d67c174a090b19e3d01e4b3a2324b468", "filename": "gcc/config/sparc/sunos4.h", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7e0e539c53fa846aa01be0aae76f165507e8187/gcc%2Fconfig%2Fsparc%2Fsunos4.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7e0e539c53fa846aa01be0aae76f165507e8187/gcc%2Fconfig%2Fsparc%2Fsunos4.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsunos4.h?ref=f7e0e539c53fa846aa01be0aae76f165507e8187", "patch": "@@ -28,3 +28,22 @@ Boston, MA 02111-1307, USA.  */\n \n /* The Sun as doesn't like unaligned data.  */\n #define DWARF2_UNWIND_INFO 0\n+\n+/* Override MACHINE_STATE_{SAVE,RESTORE} because we have special\n+   traps available which can get and set the condition codes\n+   reliably.  */\n+#undef MACHINE_STATE_SAVE\n+#define MACHINE_STATE_SAVE(ID)\t\t\t\t\\\n+  unsigned long int ms_flags, ms_saveret;\t\t\\\n+  asm volatile(\"ta\t0x20\\n\\t\"\t\t\t\\\n+\t       \"mov\t%%g1, %0\\n\\t\"\t\t\t\\\n+\t       \"mov\t%%g2, %1\\n\\t\"\t\t\t\\\n+\t       : \"=r\" (ms_flags), \"=r\" (ms_saveret));\n+\n+#undef MACHINE_STATE_RESTORE\n+#define MACHINE_STATE_RESTORE(ID)\t\t\t\\\n+  asm volatile(\"mov\t%0, %%g1\\n\\t\"\t\t\t\\\n+\t       \"mov\t%1, %%g2\\n\\t\"\t\t\t\\\n+\t       \"ta\t0x21\\n\\t\"\t\t\t\\\n+\t       : /* no outputs */\t\t\t\\\n+\t       : \"r\" (ms_flags), \"r\" (ms_saveret));"}]}