{"sha": "8f0ce8da14c75a8b60721cc5e813505599c46715", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGYwY2U4ZGExNGM3NWE4YjYwNzIxY2M1ZTgxMzUwNTU5OWM0NjcxNQ==", "commit": {"author": {"name": "Ito Kazumitsu", "email": "kaz@maczuka.gcd.org", "date": "2004-07-10T08:55:22Z"}, "committer": {"name": "Michael Koch", "email": "mkoch@gcc.gnu.org", "date": "2004-07-10T08:55:22Z"}, "message": "2004-07-10  Ito Kazumitsu  <kaz@maczuka.gcd.org>\n\n\t* java/text/MessageFormat.java\n\t(formatInternal): Append \"{n}\" if argument n is unavailable.\n\t(format(Object, StringBuffer, FieldPosition)): This\n\tshould be equivalent to format(Object[],\n\tStringBuffer, FieldPosition).\n\nFrom-SVN: r84448", "tree": {"sha": "905361c6d0df010ab5ebeddd8423a624910958a6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/905361c6d0df010ab5ebeddd8423a624910958a6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8f0ce8da14c75a8b60721cc5e813505599c46715", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f0ce8da14c75a8b60721cc5e813505599c46715", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8f0ce8da14c75a8b60721cc5e813505599c46715", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f0ce8da14c75a8b60721cc5e813505599c46715/comments", "author": null, "committer": null, "parents": [{"sha": "b352098021d0d7be6f551de3c3ea80979f2e88e9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b352098021d0d7be6f551de3c3ea80979f2e88e9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b352098021d0d7be6f551de3c3ea80979f2e88e9"}], "stats": {"total": 77, "additions": 41, "deletions": 36}, "files": [{"sha": "eb4e210f0da4dd5baf0e81981c4e2e7cf6d0d965", "filename": "libjava/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f0ce8da14c75a8b60721cc5e813505599c46715/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f0ce8da14c75a8b60721cc5e813505599c46715/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=8f0ce8da14c75a8b60721cc5e813505599c46715", "patch": "@@ -1,3 +1,11 @@\n+2004-07-10  Ito Kazumitsu  <kaz@maczuka.gcd.org>\n+\n+\t* java/text/MessageFormat.java\n+\t(formatInternal): Append \"{n}\" if argument n is unavailable.\n+\t(format(Object, StringBuffer, FieldPosition)): This\n+\tshould be equivalent to format(Object[],\n+\tStringBuffer, FieldPosition).\n+\n 2004-07-09  Bryce McKinlay  <mckinlay@redhat.com>\n \n \t* java.util.Calendar.java (cache): New private static field. Cached"}, {"sha": "b123412554d6aa37d6c61473ada7342c985349e6", "filename": "libjava/java/text/MessageFormat.java", "status": "modified", "additions": 33, "deletions": 36, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f0ce8da14c75a8b60721cc5e813505599c46715/libjava%2Fjava%2Ftext%2FMessageFormat.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f0ce8da14c75a8b60721cc5e813505599c46715/libjava%2Fjava%2Ftext%2FMessageFormat.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Ftext%2FMessageFormat.java?ref=8f0ce8da14c75a8b60721cc5e813505599c46715", "patch": "@@ -1,5 +1,5 @@\n /* MessageFormat.java - Localized message formatting.\n-   Copyright (C) 1999, 2001, 2002 Free Software Foundation, Inc.\n+   Copyright (C) 1999, 2001, 2002, 2004 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -157,7 +157,7 @@ public static class Field extends Format.Field\n      * This is the attribute set for all characters produced\n      * by MessageFormat during a formatting.\n      */\n-    public static final MessageFormat.Field ARGUMENT = new Field(\"argument\");\n+    public static final MessageFormat.Field ARGUMENT = new MessageFormat.Field(\"argument\");\n \n     // For deserialization\n     private Field()\n@@ -414,33 +414,41 @@ protected final StringBuffer formatInternal (Object arguments[], StringBuffer ap\n \n     for (int i = 0; i < elements.length; ++i)\n       {\n-\tif (elements[i].argNumber >= arguments.length)\n-\t  throw new IllegalArgumentException(\"Not enough arguments given\");\n+\tObject thisArg = null;\n+\tboolean unavailable = false;\n+\tif (arguments == null || elements[i].argNumber >= arguments.length)\n+\t  unavailable = true;\n+\telse\n+\t  thisArg = arguments[elements[i].argNumber];\n \n-\tObject thisArg = arguments[elements[i].argNumber];\n \tAttributedCharacterIterator iterator = null;\n \n \tFormat formatter = null;\n \n \tif (fp != null && i == fp.getField() && fp.getFieldAttribute() == Field.ARGUMENT)\n \t  fp.setBeginIndex(appendBuf.length());\n \n-\tif (elements[i].setFormat != null)\n-\t  formatter = elements[i].setFormat;\n-\telse if (elements[i].format != null)\n+\tif (unavailable)\n+\t  appendBuf.append(\"{\" + elements[i].argNumber + \"}\");\n+\telse\n \t  {\n-\t    if (elements[i].formatClass != null\n-\t\t&& ! elements[i].formatClass.isInstance(thisArg))\n-\t      throw new IllegalArgumentException(\"Wrong format class\");\n+\t    if (elements[i].setFormat != null)\n+\t      formatter = elements[i].setFormat;\n+\t    else if (elements[i].format != null)\n+\t      {\n+\t        if (elements[i].formatClass != null\n+\t\t    && ! elements[i].formatClass.isInstance(thisArg))\n+\t          throw new IllegalArgumentException(\"Wrong format class\");\n \t    \n-\t    formatter = elements[i].format;\n+\t        formatter = elements[i].format;\n+\t      }\n+\t    else if (thisArg instanceof Number)\n+\t      formatter = NumberFormat.getInstance(locale);\n+\t    else if (thisArg instanceof Date)\n+\t      formatter = DateFormat.getTimeInstance(DateFormat.DEFAULT, locale);\n+\t    else\n+\t      appendBuf.append(thisArg);\n \t  }\n-\telse if (thisArg instanceof Number)\n-\t  formatter = NumberFormat.getInstance(locale);\n-\telse if (thisArg instanceof Date)\n-\t  formatter = DateFormat.getTimeInstance(DateFormat.DEFAULT, locale);\n-\telse\n-\t  appendBuf.append(thisArg);\n \n \tif (fp != null && fp.getField() == i && fp.getFieldAttribute() == Field.ARGUMENT)\n \t  fp.setEndIndex(appendBuf.length());\n@@ -496,29 +504,18 @@ else if (thisArg instanceof Date)\n   }\n \n   /**\n-   * Returns the pattern with the formatted objects.\n+   * Returns the pattern with the formatted objects.  The first argument\n+   * must be a array of Objects.\n+   * This is equivalent to format((Object[]) objectArray, appendBuf, fpos)\n    *\n-   * @param source The object to be formatted.\n-   * @param result The StringBuffer where the text is appened.\n+   * @param objectArray The object array to be formatted.\n+   * @param appendBuf The StringBuffer where the text is appened.\n    * @param fpos A FieldPosition object (it is ignored).\n    */\n-  public final StringBuffer format (Object singleArg, StringBuffer appendBuf,\n+  public final StringBuffer format (Object objectArray, StringBuffer appendBuf,\n \t\t\t\t    FieldPosition fpos)\n   {\n-    Object[] args;\n-\n-    if (singleArg instanceof Object[])\n-      {\n-\t// This isn't specified in any manual, but it follows the\n-\t// JDK implementation.\n-\targs = (Object[]) singleArg;\n-      }\n-    else\n-      {\n-\targs = new Object[1];\n-\targs[0] = singleArg;\n-      }\n-    return format (args, appendBuf, fpos);\n+    return format ((Object[])objectArray, appendBuf, fpos);\n   }\n \n   /**"}]}