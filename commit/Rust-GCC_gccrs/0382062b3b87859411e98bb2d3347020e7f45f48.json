{"sha": "0382062b3b87859411e98bb2d3347020e7f45f48", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDM4MjA2MmIzYjg3ODU5NDExZTk4YmIyZDMzNDcwMjBlN2Y0NWY0OA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-07-29T12:40:42Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-07-29T12:40:42Z"}, "message": "[multiple changes]\n\n2014-07-29  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* exp_ch7.adb (Build_BIP_Cleanup_Stmts): Remove\n\tformal parameter Obj_Id and update the comment on usage. Renamed\n\tObj_Typ to Func_Typ and update all occurrences.\n\t(Find_Last_Init): Remove formal parameter Decl and update the comment\n\ton usage.\n\tRemove local constants Obj_Id and Obj_Typ. Remove local variables\n\tInit_Typ and Is_Conc. Remove the extraction of the initialization type.\n\t(Find_Last_Init_In_Block): Remove formal parameter\n\tInit_Typ and update the comment on usage.\n\t(Is_Init_Call): Remove formal parameter Init_Typ and update the comment\n\ton usage. Check whether the procedure call is an initialization\n\tprocedure of either the object type or the initialization type.\n\t(Is_Init_Proc_Of): New routine.\n\t(Process_Object_Declaration): Obj_Id and Obj_Typ are now global to this\n\troutine. Add new variable Init_Typ. Add circuitry to extract the object\n\ttype as well as the initialization type.\n\n2014-07-29  Robert Dewar  <dewar@adacore.com>\n\n\t* sem_case.adb: Minor reformatting.\n\t* sem_aux.ads: Minor reformatting.\n\n2014-07-29  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sinfo.adb (Set_Else_Actions, Set_Then_Actions): Set parent\n\tpointer on these fields, even though they are semantic, because\n\tsubsequent analysis and expansion of action nades may require\n\texploring the tree, for example to locate a node to be wrapped\n\twhen a function with controlled result is called.\n\n2014-07-29  Claire Dross  <dross@adacore.com>\n\n\t* sem_aux.adb (Get_Binary_Nkind): Use case on\n\tName_Id instead of an intermediate string.\n\t(Get_Unary_Nkind): Use case on Name_Id instead of an intermediate\n\tstring.\n\n2014-07-29  Sergey Rybin  <rybin@adacore.com frybin>\n\n\t* gnat_ugn.texi (gnatelim, gnatstub, gnatmetric): Add note\n\tabout processing sources with preprocessor directives.\n\nFrom-SVN: r213155", "tree": {"sha": "a270d538296317d1c5acb6eda3c5aa21b378c4d1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a270d538296317d1c5acb6eda3c5aa21b378c4d1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0382062b3b87859411e98bb2d3347020e7f45f48", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0382062b3b87859411e98bb2d3347020e7f45f48", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0382062b3b87859411e98bb2d3347020e7f45f48", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0382062b3b87859411e98bb2d3347020e7f45f48/comments", "author": null, "committer": null, "parents": [{"sha": "56386ab9004a24f057aff7aeaed15da1f025f7ff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/56386ab9004a24f057aff7aeaed15da1f025f7ff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/56386ab9004a24f057aff7aeaed15da1f025f7ff"}], "stats": {"total": 451, "additions": 271, "deletions": 180}, "files": [{"sha": "7933eb71bb4b466173e5801ce8f3b017da90aa3c", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0382062b3b87859411e98bb2d3347020e7f45f48/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0382062b3b87859411e98bb2d3347020e7f45f48/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=0382062b3b87859411e98bb2d3347020e7f45f48", "patch": "@@ -1,3 +1,47 @@\n+2014-07-29  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* exp_ch7.adb (Build_BIP_Cleanup_Stmts): Remove\n+\tformal parameter Obj_Id and update the comment on usage. Renamed\n+\tObj_Typ to Func_Typ and update all occurrences.\n+\t(Find_Last_Init): Remove formal parameter Decl and update the comment\n+\ton usage.\n+\tRemove local constants Obj_Id and Obj_Typ. Remove local variables\n+\tInit_Typ and Is_Conc. Remove the extraction of the initialization type.\n+\t(Find_Last_Init_In_Block): Remove formal parameter\n+\tInit_Typ and update the comment on usage.\n+\t(Is_Init_Call): Remove formal parameter Init_Typ and update the comment\n+\ton usage. Check whether the procedure call is an initialization\n+\tprocedure of either the object type or the initialization type.\n+\t(Is_Init_Proc_Of): New routine.\n+\t(Process_Object_Declaration): Obj_Id and Obj_Typ are now global to this\n+\troutine. Add new variable Init_Typ. Add circuitry to extract the object\n+\ttype as well as the initialization type.\n+\n+2014-07-29  Robert Dewar  <dewar@adacore.com>\n+\n+\t* sem_case.adb: Minor reformatting.\n+\t* sem_aux.ads: Minor reformatting.\n+\n+2014-07-29  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sinfo.adb (Set_Else_Actions, Set_Then_Actions): Set parent\n+\tpointer on these fields, even though they are semantic, because\n+\tsubsequent analysis and expansion of action nades may require\n+\texploring the tree, for example to locate a node to be wrapped\n+\twhen a function with controlled result is called.\n+\n+2014-07-29  Claire Dross  <dross@adacore.com>\n+\n+\t* sem_aux.adb (Get_Binary_Nkind): Use case on\n+\tName_Id instead of an intermediate string.\n+\t(Get_Unary_Nkind): Use case on Name_Id instead of an intermediate\n+\tstring.\n+\n+2014-07-29  Sergey Rybin  <rybin@adacore.com frybin>\n+\n+\t* gnat_ugn.texi (gnatelim, gnatstub, gnatmetric): Add note\n+\tabout processing sources with preprocessor directives.\n+\n 2014-07-24  Martin Liska  <mliska@suse.cz>\n \n \t* gcc-interface/trans.c (finalize_nrv): Adjust function call."}, {"sha": "ad7a1d20bf4278afff30e01ca0d58e48d7226263", "filename": "gcc/ada/exp_ch7.adb", "status": "modified", "additions": 134, "deletions": 108, "changes": 242, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0382062b3b87859411e98bb2d3347020e7f45f48/gcc%2Fada%2Fexp_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0382062b3b87859411e98bb2d3347020e7f45f48/gcc%2Fada%2Fexp_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch7.adb?ref=0382062b3b87859411e98bb2d3347020e7f45f48", "patch": "@@ -2066,13 +2066,20 @@ package body Exp_Ch7 is\n          Has_No_Init  : Boolean := False;\n          Is_Protected : Boolean := False)\n       is\n-         Loc : constant Source_Ptr := Sloc (Decl);\n+         Loc    : constant Source_Ptr := Sloc (Decl);\n+         Obj_Id : constant Entity_Id := Defining_Identifier (Decl);\n \n-         function Build_BIP_Cleanup_Stmts\n-           (Func_Id : Entity_Id;\n-            Obj_Id  : Entity_Id) return Node_Id;\n-         --  Func_Id denotes a build-in-place function. Obj_Id is the return\n-         --  object of Func_Id. Generate the following cleanup code:\n+         Init_Typ : Entity_Id;\n+         --  The initialization type of the related object declaration. Note\n+         --  that this is not necessarely the same type as Obj_Typ because of\n+         --  possible type derivations.\n+\n+         Obj_Typ : Entity_Id;\n+         --  The type of the related object declaration\n+\n+         function Build_BIP_Cleanup_Stmts (Func_Id : Entity_Id) return Node_Id;\n+         --  Func_Id denotes a build-in-place function. Generate the following\n+         --  cleanup code:\n          --\n          --    if BIPallocfrom > Secondary_Stack'Pos\n          --      and then BIPfinalizationmaster /= null\n@@ -2090,27 +2097,25 @@ package body Exp_Ch7 is\n          --  allocation which Obj_Id renames.\n \n          procedure Find_Last_Init\n-           (Decl        : Node_Id;\n-            Last_Init   : out Node_Id;\n+           (Last_Init   : out Node_Id;\n             Body_Insert : out Node_Id);\n          --  Find the last initialization call related to object declaration\n          --  Decl. Last_Init denotes the last initialization call which follows\n-         --  Decl. Body_Insert denotes the finalizer body could be potentially\n-         --  inserted.\n+         --  Decl. Body_Insert denotes a node where the finalizer body could be\n+         --  potentially inserted after (if blocks are involved).\n \n          -----------------------------\n          -- Build_BIP_Cleanup_Stmts --\n          -----------------------------\n \n          function Build_BIP_Cleanup_Stmts\n-           (Func_Id : Entity_Id;\n-            Obj_Id  : Entity_Id) return Node_Id\n+           (Func_Id : Entity_Id) return Node_Id\n          is\n             Decls      : constant List_Id := New_List;\n             Fin_Mas_Id : constant Entity_Id :=\n                            Build_In_Place_Formal\n                              (Func_Id, BIP_Finalization_Master);\n-            Obj_Typ    : constant Entity_Id := Etype (Func_Id);\n+            Func_Typ   : constant Entity_Id := Etype (Func_Id);\n             Temp_Id    : constant Entity_Id :=\n                            Entity (Prefix (Name (Parent (Obj_Id))));\n \n@@ -2146,7 +2151,7 @@ package body Exp_Ch7 is\n             --  caller's finalization master.\n \n             --  Generate:\n-            --    type Ptr_Typ is access Obj_Typ;\n+            --    type Ptr_Typ is access Func_Typ;\n \n             Ptr_Typ := Make_Temporary (Loc, 'P');\n \n@@ -2155,7 +2160,7 @@ package body Exp_Ch7 is\n                 Defining_Identifier => Ptr_Typ,\n                 Type_Definition     =>\n                   Make_Access_To_Object_Definition (Loc,\n-                    Subtype_Indication => New_Occurrence_Of (Obj_Typ, Loc))));\n+                    Subtype_Indication => New_Occurrence_Of (Func_Typ, Loc))));\n \n             --  Perform minor decoration in order to set the master and the\n             --  storage pool attributes.\n@@ -2207,8 +2212,8 @@ package body Exp_Ch7 is\n             --      and then BIPfinalizationmaster /= null\n             --    then\n \n-            if not Is_Constrained (Obj_Typ)\n-              or else Is_Tagged_Type (Obj_Typ)\n+            if not Is_Constrained (Func_Typ)\n+              or else Is_Tagged_Type (Func_Typ)\n             then\n                declare\n                   Alloc : constant Entity_Id :=\n@@ -2244,21 +2249,16 @@ package body Exp_Ch7 is\n          --------------------\n \n          procedure Find_Last_Init\n-           (Decl        : Node_Id;\n-            Last_Init   : out Node_Id;\n+           (Last_Init   : out Node_Id;\n             Body_Insert : out Node_Id)\n          is\n-            function Find_Last_Init_In_Block\n-              (Blk      : Node_Id;\n-               Init_Typ : Entity_Id) return Node_Id;\n+            function Find_Last_Init_In_Block (Blk : Node_Id) return Node_Id;\n             --  Find the last initialization call within the statements of\n-            --  block Blk. Init_Typ is type of the object being initialized.\n+            --  block Blk.\n \n-            function Is_Init_Call\n-              (N        : Node_Id;\n-               Init_Typ : Entity_Id) return Boolean;\n+            function Is_Init_Call (N : Node_Id) return Boolean;\n             --  Determine whether node N denotes one of the initialization\n-            --  procedures of type Init_Typ.\n+            --  procedures of types Init_Typ or Obj_Typ.\n \n             function Next_Suitable_Statement (Stmt : Node_Id) return Node_Id;\n             --  Given a statement which is part of a list, return the next\n@@ -2268,10 +2268,7 @@ package body Exp_Ch7 is\n             -- Find_Last_Init_In_Block --\n             -----------------------------\n \n-            function Find_Last_Init_In_Block\n-              (Blk      : Node_Id;\n-               Init_Typ : Entity_Id) return Node_Id\n-            is\n+            function Find_Last_Init_In_Block (Blk : Node_Id) return Node_Id is\n                HSS  : constant Node_Id := Handled_Statement_Sequence (Blk);\n                Stmt : Node_Id;\n \n@@ -2286,9 +2283,9 @@ package body Exp_Ch7 is\n                      --  Peek inside nested blocks in case aborts are allowed\n \n                      if Nkind (Stmt) = N_Block_Statement then\n-                        return Find_Last_Init_In_Block (Stmt, Init_Typ);\n+                        return Find_Last_Init_In_Block (Stmt);\n \n-                     elsif Is_Init_Call (Stmt, Init_Typ) then\n+                     elsif Is_Init_Call (Stmt) then\n                         return Stmt;\n                      end if;\n \n@@ -2303,33 +2300,38 @@ package body Exp_Ch7 is\n             -- Is_Init_Call --\n             ------------------\n \n-            function Is_Init_Call\n-              (N        : Node_Id;\n-               Init_Typ : Entity_Id) return Boolean\n-            is\n-               Call_Id   : Entity_Id;\n-               Deep_Init : Entity_Id := Empty;\n-               Prim_Init : Entity_Id := Empty;\n-               Type_Init : Entity_Id := Empty;\n-\n-            begin\n-               if Nkind (N) = N_Procedure_Call_Statement\n-                 and then Nkind (Name (N)) = N_Identifier\n-               then\n-                  Call_Id := Entity (Name (N));\n+            function Is_Init_Call (N : Node_Id) return Boolean is\n+               function Is_Init_Proc_Of\n+                 (Subp_Id : Entity_Id;\n+                  Typ     : Entity_Id) return Boolean;\n+               --  Determine whether subprogram Subp_Id is a valid init proc of\n+               --  type Typ.\n+\n+               ---------------------\n+               -- Is_Init_Proc_Of --\n+               ---------------------\n+\n+               function Is_Init_Proc_Of\n+                 (Subp_Id : Entity_Id;\n+                  Typ     : Entity_Id) return Boolean\n+               is\n+                  Deep_Init : Entity_Id := Empty;\n+                  Prim_Init : Entity_Id := Empty;\n+                  Type_Init : Entity_Id := Empty;\n \n-                  --  Obtain all possible initialization routines of the object\n-                  --  type and try to match the procedure call against one of\n-                  --  them.\n+               begin\n+                  --  Obtain all possible initialization routines of the\n+                  --  related type and try to match the subprogram entity\n+                  --  against one of them.\n \n                   --  Deep_Initialize\n \n-                  Deep_Init := TSS (Init_Typ, TSS_Deep_Initialize);\n+                  Deep_Init := TSS (Typ, TSS_Deep_Initialize);\n \n                   --  Primitive Initialize\n \n-                  if Is_Controlled (Init_Typ) then\n-                     Prim_Init := Find_Prim_Op (Init_Typ, Name_Initialize);\n+                  if Is_Controlled (Typ) then\n+                     Prim_Init := Find_Prim_Op (Typ, Name_Initialize);\n \n                      if Present (Prim_Init) then\n                         Prim_Init := Ultimate_Alias (Prim_Init);\n@@ -2338,16 +2340,37 @@ package body Exp_Ch7 is\n \n                   --  Type initialization routine\n \n-                  if Has_Non_Null_Base_Init_Proc (Init_Typ) then\n-                     Type_Init := Base_Init_Proc (Init_Typ);\n+                  if Has_Non_Null_Base_Init_Proc (Typ) then\n+                     Type_Init := Base_Init_Proc (Typ);\n                   end if;\n \n                   return\n-                    (Present (Deep_Init) and then Call_Id = Deep_Init)\n+                    (Present (Deep_Init) and then Subp_Id = Deep_Init)\n                       or else\n-                    (Present (Prim_Init) and then Call_Id = Prim_Init)\n+                    (Present (Prim_Init) and then Subp_Id = Prim_Init)\n                       or else\n-                    (Present (Type_Init) and then Call_Id = Type_Init);\n+                    (Present (Type_Init) and then Subp_Id = Type_Init);\n+               end Is_Init_Proc_Of;\n+\n+               --  Local variables\n+\n+               Call_Id : Entity_Id;\n+\n+            --  Start of processing for Is_Init_Call\n+\n+            begin\n+               if Nkind (N) = N_Procedure_Call_Statement\n+                 and then Nkind (Name (N)) = N_Identifier\n+               then\n+                  Call_Id := Entity (Name (N));\n+\n+                  --  Consider both the type of the object declaration and its\n+                  --  related initialization type.\n+\n+                  return\n+                    Is_Init_Proc_Of (Call_Id, Init_Typ)\n+                      or else\n+                    Is_Init_Proc_Of (Call_Id, Obj_Typ);\n                end if;\n \n                return False;\n@@ -2374,13 +2397,9 @@ package body Exp_Ch7 is\n \n             --  Local variables\n \n-            Obj_Id   : constant Entity_Id := Defining_Entity (Decl);\n-            Obj_Typ  : constant Entity_Id := Base_Type (Etype (Obj_Id));\n-            Call     : Node_Id;\n-            Init_Typ : Entity_Id := Obj_Typ;\n-            Is_Conc  : Boolean   := False;\n-            Stmt     : Node_Id;\n-            Stmt_2   : Node_Id;\n+            Call   : Node_Id;\n+            Stmt   : Node_Id;\n+            Stmt_2 : Node_Id;\n \n          --  Start of processing for Find_Last_Init\n \n@@ -2395,34 +2414,6 @@ package body Exp_Ch7 is\n                return;\n             end if;\n \n-            --  Obtain the proper type of the object being initialized\n-\n-            loop\n-               if Is_Concurrent_Type (Init_Typ)\n-                 and then Present (Corresponding_Record_Type (Init_Typ))\n-               then\n-                  Is_Conc  := True;\n-                  Init_Typ := Corresponding_Record_Type (Init_Typ);\n-\n-               elsif Is_Private_Type (Init_Typ)\n-                  and then Present (Full_View (Init_Typ))\n-               then\n-                  Init_Typ := Full_View (Init_Typ);\n-\n-               elsif Is_Untagged_Derivation (Init_Typ)\n-                 and then not Is_Conc\n-               then\n-                  Init_Typ := Root_Type (Init_Typ);\n-\n-               else\n-                  exit;\n-               end if;\n-            end loop;\n-\n-            if Init_Typ /= Base_Type (Init_Typ) then\n-               Init_Typ := Base_Type (Init_Typ);\n-            end if;\n-\n             Stmt := Next_Suitable_Statement (Decl);\n \n             --  A limited controlled object initialized by a function call uses\n@@ -2442,7 +2433,7 @@ package body Exp_Ch7 is\n             --  In this scenario the declaration of the temporary acts as the\n             --  last initialization statement.\n \n-            if Is_Limited_Type (Init_Typ)\n+            if Is_Limited_Type (Obj_Typ)\n               and then Has_Init_Expression (Decl)\n               and then No (Expression (Decl))\n             then\n@@ -2482,7 +2473,7 @@ package body Exp_Ch7 is\n             --  within a block.\n \n             elsif Nkind (Stmt) = N_Block_Statement then\n-               Last_Init   := Find_Last_Init_In_Block (Stmt, Init_Typ);\n+               Last_Init   := Find_Last_Init_In_Block (Stmt);\n                Body_Insert := Stmt;\n \n             --  Otherwise the initialization calls follow the related object\n@@ -2496,22 +2487,22 @@ package body Exp_Ch7 is\n \n                if Present (Stmt_2) then\n                   if Nkind (Stmt_2) = N_Block_Statement then\n-                     Call := Find_Last_Init_In_Block (Stmt_2, Init_Typ);\n+                     Call := Find_Last_Init_In_Block (Stmt_2);\n \n                      if Present (Call) then\n                         Last_Init   := Call;\n                         Body_Insert := Stmt_2;\n                      end if;\n \n-                  elsif Is_Init_Call (Stmt_2, Init_Typ) then\n+                  elsif Is_Init_Call (Stmt_2) then\n                      Last_Init   := Stmt_2;\n                      Body_Insert := Last_Init;\n                   end if;\n \n                --  If the object lacks a call to Deep_Initialize, then it must\n                --  have a call to its related type init proc.\n \n-               elsif Is_Init_Call (Stmt, Init_Typ) then\n+               elsif Is_Init_Call (Stmt) then\n                   Last_Init   := Stmt;\n                   Body_Insert := Last_Init;\n                end if;\n@@ -2520,7 +2511,6 @@ package body Exp_Ch7 is\n \n          --  Local variables\n \n-         Obj_Id    : constant Entity_Id := Defining_Identifier (Decl);\n          Body_Ins  : Node_Id;\n          Count_Ins : Node_Id;\n          Fin_Call  : Node_Id;\n@@ -2529,23 +2519,60 @@ package body Exp_Ch7 is\n          Label     : Node_Id;\n          Label_Id  : Entity_Id;\n          Obj_Ref   : Node_Id;\n-         Obj_Typ   : Entity_Id;\n \n       --  Start of processing for Process_Object_Declaration\n \n       begin\n+         --  Handle the object type and the reference to the object\n+\n          Obj_Ref := New_Occurrence_Of (Obj_Id, Loc);\n          Obj_Typ := Base_Type (Etype (Obj_Id));\n \n-         --  Handle access types\n+         loop\n+            if Is_Access_Type (Obj_Typ) then\n+               Obj_Typ := Directly_Designated_Type (Obj_Typ);\n+               Obj_Ref := Make_Explicit_Dereference (Loc, Obj_Ref);\n \n-         if Is_Access_Type (Obj_Typ) then\n-            Obj_Ref := Make_Explicit_Dereference (Loc, Obj_Ref);\n-            Obj_Typ := Directly_Designated_Type (Obj_Typ);\n-         end if;\n+            elsif Is_Concurrent_Type (Obj_Typ)\n+              and then Present (Corresponding_Record_Type (Obj_Typ))\n+            then\n+               Obj_Typ := Corresponding_Record_Type (Obj_Typ);\n+               Obj_Ref := Unchecked_Convert_To (Obj_Typ, Obj_Ref);\n+\n+            elsif Is_Private_Type (Obj_Typ)\n+              and then Present (Full_View (Obj_Typ))\n+            then\n+               Obj_Typ := Full_View (Obj_Typ);\n+               Obj_Ref := Unchecked_Convert_To (Obj_Typ, Obj_Ref);\n+\n+            elsif Obj_Typ /= Base_Type (Obj_Typ) then\n+               Obj_Typ := Base_Type (Obj_Typ);\n+               Obj_Ref := Unchecked_Convert_To (Obj_Typ, Obj_Ref);\n+\n+            else\n+               exit;\n+            end if;\n+         end loop;\n \n          Set_Etype (Obj_Ref, Obj_Typ);\n \n+         --  Handle the initialization type of the object declaration\n+\n+         Init_Typ := Obj_Typ;\n+         loop\n+            if Is_Private_Type (Init_Typ)\n+              and then Present (Full_View (Init_Typ))\n+            then\n+               Init_Typ := Full_View (Init_Typ);\n+\n+            elsif Is_Untagged_Derivation (Init_Typ) then\n+               Init_Typ := Root_Type (Init_Typ);\n+\n+            else\n+               exit;\n+            end if;\n+         end loop;\n+\n          --  Set a new value for the state counter and insert the statement\n          --  after the object declaration. Generate:\n \n@@ -2571,7 +2598,7 @@ package body Exp_Ch7 is\n          --  either [Deep_]Initialize or the type specific init proc.\n \n          else\n-            Find_Last_Init (Decl, Count_Ins, Body_Ins);\n+            Find_Last_Init (Count_Ins, Body_Ins);\n          end if;\n \n          Insert_After (Count_Ins, Inc_Decl);\n@@ -2754,8 +2781,7 @@ package body Exp_Ch7 is\n                   if Is_Build_In_Place_Function (Func_Id)\n                     and then Needs_BIP_Finalization_Master (Func_Id)\n                   then\n-                     Append_To\n-                       (Fin_Stmts, Build_BIP_Cleanup_Stmts (Func_Id, Obj_Id));\n+                     Append_To (Fin_Stmts, Build_BIP_Cleanup_Stmts (Func_Id));\n                   end if;\n                end;\n             end if;"}, {"sha": "062659eb9fa37aa205b36e66849508e004ba761a", "filename": "gcc/ada/gnat_ugn.texi", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0382062b3b87859411e98bb2d3347020e7f45f48/gcc%2Fada%2Fgnat_ugn.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0382062b3b87859411e98bb2d3347020e7f45f48/gcc%2Fada%2Fgnat_ugn.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_ugn.texi?ref=0382062b3b87859411e98bb2d3347020e7f45f48", "patch": "@@ -11418,6 +11418,12 @@ After a full successful build of the main subprogram @code{gnatelim} can be\n called without  specifying sources to analyse, in this case it computes\n the source closure of the main unit from the @file{ALI} files.\n \n+If the set of sources to be processed by @code{gnatelim} contains sources with\n+preprocessing directives\n+then the needed options should be provided to run preprocessor as a part of\n+the @command{gnatelim} call, and the generated set of pragmas @code{Eliminate}\n+will correspond to preprocessed sources.\n+\n The following command will create the set of @file{ALI} files needed for\n @code{gnatelim}:\n \n@@ -15637,6 +15643,13 @@ Project Files}). Another possibility is to specify the source search\n path and needed configuration files in @option{-cargs} section of @command{gnatmetric}\n call, see the description of the @command{gnatmetric} switches below.\n \n+If the set of sources to be processed by @code{gnatmetric} contains sources with\n+preprocessing directives\n+then the needed options should be provided to run preprocessor as a part of\n+the @command{gnatmetric} call, and the computed metrics\n+will correspond to preprocessed sources.\n+\n+\n The @command{gnatmetric} command has the form\n \n @smallexample\n@@ -19373,6 +19386,11 @@ Project Files}). Another possibility is to specify the source search\n path and needed configuration files in @option{-cargs} section of @command{gnatstub}\n call, see the description of the @command{gnatstub} switches below.\n \n+If the @command{gnatstub} argument source contains preprocessing directives\n+then the needed options should be provided to run preprocessor as a part of\n+the @command{gnatstub} call, and the generated body stub will correspond to\n+the preprocessed source.\n+\n By default, all the program unit body stubs generated by @code{gnatstub}\n raise the predefined @code{Program_Error} exception, which will catch\n accidental calls of generated stubs. This behavior can be changed with"}, {"sha": "4b251e31c5161b031fac10ad4d4f55ddee302f73", "filename": "gcc/ada/sem_aux.adb", "status": "modified", "additions": 50, "deletions": 50, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0382062b3b87859411e98bb2d3347020e7f45f48/gcc%2Fada%2Fsem_aux.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0382062b3b87859411e98bb2d3347020e7f45f48/gcc%2Fada%2Fsem_aux.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aux.adb?ref=0382062b3b87859411e98bb2d3347020e7f45f48", "patch": "@@ -439,45 +439,45 @@ package body Sem_Aux is\n    ---------------------\n \n    function Get_Binary_Nkind (Op : Entity_Id) return Node_Kind is\n-      Name : constant String := Get_Name_String (Chars (Op));\n    begin\n-      if Name = \"Oadd\" then\n-         return N_Op_Add;\n-      elsif Name = \"Oconcat\" then\n-         return N_Op_Concat;\n-      elsif Name = \"Oexpon\" then\n-         return N_Op_Expon;\n-      elsif Name = \"Osubtract\" then\n-         return N_Op_Subtract;\n-      elsif Name = \"Omod\" then\n-         return N_Op_Mod;\n-      elsif Name = \"Omultiply\" then\n-         return N_Op_Multiply;\n-      elsif Name = \"Odivide\" then\n-         return N_Op_Divide;\n-      elsif Name = \"Orem\" then\n-         return N_Op_Rem;\n-      elsif Name = \"Oand\" then\n-         return N_Op_And;\n-      elsif Name = \"Oeq\" then\n-         return N_Op_Eq;\n-      elsif Name = \"Oge\" then\n-         return N_Op_Ge;\n-      elsif Name = \"Ogt\" then\n-         return N_Op_Gt;\n-      elsif Name = \"Ole\" then\n-         return N_Op_Le;\n-      elsif Name = \"Olt\" then\n-         return N_Op_Lt;\n-      elsif Name = \"One\" then\n-         return N_Op_Ne;\n-      elsif Name = \"Oxor\" then\n-         return N_Op_Or;\n-      elsif Name = \"Oor\" then\n-         return N_Op_Xor;\n-      else\n-         raise Program_Error;\n-      end if;\n+      case Chars (Op) is\n+         when Name_Op_Add =>\n+            return N_Op_Add;\n+         when Name_Op_Concat =>\n+            return N_Op_Concat;\n+         when Name_Op_Expon =>\n+            return N_Op_Expon;\n+         when Name_Op_Subtract =>\n+            return N_Op_Subtract;\n+         when Name_Op_Mod =>\n+            return N_Op_Mod;\n+         when Name_Op_Multiply =>\n+            return N_Op_Multiply;\n+         when Name_Op_Divide =>\n+            return N_Op_Divide;\n+         when Name_Op_Rem =>\n+            return N_Op_Rem;\n+         when Name_Op_And =>\n+            return N_Op_And;\n+         when Name_Op_Eq =>\n+            return N_Op_Eq;\n+         when Name_Op_Ge =>\n+            return N_Op_Ge;\n+         when Name_Op_Gt =>\n+            return N_Op_Gt;\n+         when Name_Op_Le =>\n+            return N_Op_Le;\n+         when Name_Op_Lt =>\n+            return N_Op_Lt;\n+         when Name_Op_Ne =>\n+            return N_Op_Ne;\n+         when Name_Op_Or =>\n+            return N_Op_Or;\n+         when Name_Op_Xor =>\n+            return N_Op_Xor;\n+         when others =>\n+            raise Program_Error;\n+      end case;\n    end Get_Binary_Nkind;\n \n    ------------------\n@@ -652,19 +652,19 @@ package body Sem_Aux is\n    ---------------------\n \n    function Get_Unary_Nkind (Op : Entity_Id) return Node_Kind is\n-      Name : constant String := Get_Name_String (Chars (Op));\n    begin\n-      if Name = \"Oabs\" then\n-         return N_Op_Abs;\n-      elsif Name = \"Osubtract\" then\n-         return N_Op_Minus;\n-      elsif Name = \"Onot\" then\n-         return N_Op_Not;\n-      elsif Name = \"Oadd\" then\n-         return N_Op_Plus;\n-      else\n-         raise Program_Error;\n-      end if;\n+      case Chars (Op) is\n+         when Name_Op_Abs =>\n+            return N_Op_Abs;\n+         when Name_Op_Subtract =>\n+            return N_Op_Minus;\n+         when Name_Op_Not =>\n+            return N_Op_Not;\n+         when Name_Op_Add =>\n+            return N_Op_Plus;\n+         when others =>\n+            raise Program_Error;\n+      end case;\n    end Get_Unary_Nkind;\n \n    ---------------------------------"}, {"sha": "c40ddaba829276c91078641bd936f439f8d13825", "filename": "gcc/ada/sem_aux.ads", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0382062b3b87859411e98bb2d3347020e7f45f48/gcc%2Fada%2Fsem_aux.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0382062b3b87859411e98bb2d3347020e7f45f48/gcc%2Fada%2Fsem_aux.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aux.ads?ref=0382062b3b87859411e98bb2d3347020e7f45f48", "patch": "@@ -152,6 +152,18 @@ package Sem_Aux is\n    --  Typ must be a tagged record type. This function returns the Entity for\n    --  the first _Tag field in the record type.\n \n+   function Get_Binary_Nkind (Op : Entity_Id) return Node_Kind;\n+   --  Op must be an entity with an Ekind of E_Operator. This function returns\n+   --  the Nkind value that would be used to construct a binary operator node\n+   --  referencing this entity. It is an error to call this function if Ekind\n+   --  (Op) /= E_Operator.\n+\n+   function Get_Unary_Nkind (Op : Entity_Id) return Node_Kind;\n+   --  Op must be an entity with an Ekind of E_Operator. This function returns\n+   --  the Nkind value that would be used to construct a unary operator node\n+   --  referencing this entity. It is an error to call this function if Ekind\n+   --  (Op) /= E_Operator.\n+\n    function Get_Rep_Item\n      (E             : Entity_Id;\n       Nam           : Name_Id;\n@@ -386,17 +398,4 @@ package Sem_Aux is\n    --  package specification. Simplifies handling of child units, and better\n    --  than the old idiom: Specification (Unit_Declaration_Node (Pack_Id)).\n \n-   function Get_Binary_Nkind (Op : Entity_Id) return Node_Kind;\n-   --  Op must be an entity with an Ekind of E_Operator.\n-   --  This function returns the Nkind value that would\n-   --  be used to construct a binary operator node referencing\n-   --  this entity. It is an error to call this function\n-   --  if Ekind (Op) /= E_Operator.\n-\n-   function Get_Unary_Nkind (Op : Entity_Id) return Node_Kind;\n-   --  Op must be an entity with an Ekind of E_Operator.\n-   --  This function returns the Nkind value that would\n-   --  be used to construct a unary operator node referencing\n-   --  this entity. It is an error to call this function\n-   --  if Ekind (Op) /= E_Operator.\n end Sem_Aux;"}, {"sha": "7a8a60a999eecba619eb6df8c4f25574129f909e", "filename": "gcc/ada/sem_case.adb", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0382062b3b87859411e98bb2d3347020e7f45f48/gcc%2Fada%2Fsem_case.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0382062b3b87859411e98bb2d3347020e7f45f48/gcc%2Fada%2Fsem_case.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_case.adb?ref=0382062b3b87859411e98bb2d3347020e7f45f48", "patch": "@@ -647,7 +647,7 @@ package body Sem_Case is\n       Bounds_Lo     : constant Node_Id := Type_Low_Bound  (Bounds_Type);\n       Num_Choices   : constant Nat     := Choice_Table'Last;\n       Has_Predicate : constant Boolean :=\n-                        Is_Static_Subtype (Bounds_Type)\n+                        Is_OK_Static_Subtype (Bounds_Type)\n                           and then Present (Static_Predicate (Bounds_Type));\n \n       Choice      : Node_Id;\n@@ -977,7 +977,7 @@ package body Sem_Case is\n          --  Special case: only an others case is present. The others case\n          --  covers the full range of the type.\n \n-         if Is_Static_Subtype (Choice_Type) then\n+         if Is_OK_Static_Subtype (Choice_Type) then\n             Choice := New_Occurrence_Of (Choice_Type, Loc);\n          else\n             Choice := New_Occurrence_Of (Base_Type (Choice_Type), Loc);\n@@ -1268,9 +1268,9 @@ package body Sem_Case is\n \n             --  Do not insert non static choices in the table to be sorted\n \n-            elsif not Is_Static_Expression (Lo)\n+            elsif not Is_OK_Static_Expression (Lo)\n                     or else\n-                  not Is_Static_Expression (Hi)\n+                  not Is_OK_Static_Expression (Hi)\n             then\n                Process_Non_Static_Choice (Choice);\n                return;\n@@ -1498,7 +1498,7 @@ package body Sem_Case is\n \n                         --  Not predicated subtype case\n \n-                        elsif not Is_Static_Subtype (E) then\n+                        elsif not Is_OK_Static_Subtype (E) then\n                            Process_Non_Static_Choice (Choice);\n                         else\n                            Check\n@@ -1522,7 +1522,7 @@ package body Sem_Case is\n                         begin\n                            E := Entity (Subtype_Mark (Choice));\n \n-                           if not Is_Static_Subtype (E) then\n+                           if not Is_OK_Static_Subtype (E) then\n                               Process_Non_Static_Choice (Choice);\n \n                            else"}, {"sha": "2d21669be922ee08b509f5bce5f71ff317f637b4", "filename": "gcc/ada/sinfo.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0382062b3b87859411e98bb2d3347020e7f45f48/gcc%2Fada%2Fsinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0382062b3b87859411e98bb2d3347020e7f45f48/gcc%2Fada%2Fsinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.adb?ref=0382062b3b87859411e98bb2d3347020e7f45f48", "patch": "@@ -4238,7 +4238,7 @@ package body Sinfo is\n    begin\n       pragma Assert (False\n         or else NT (N).Nkind = N_If_Expression);\n-      Set_List3 (N, Val); -- semantic field, no parent set\n+      Set_List3_With_Parent (N, Val); -- semantic field, but needs parents\n    end Set_Else_Actions;\n \n    procedure Set_Else_Statements\n@@ -6266,7 +6266,7 @@ package body Sinfo is\n    begin\n       pragma Assert (False\n         or else NT (N).Nkind = N_If_Expression);\n-      Set_List2 (N, Val); -- semantic field, no parent set\n+      Set_List2_With_Parent (N, Val); -- semantic field, but needs parents\n    end Set_Then_Actions;\n \n    procedure Set_Then_Statements"}, {"sha": "36bd33fa5db0cd16d8bc96785cbcda241e5c2e27", "filename": "gcc/ada/sinfo.ads", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0382062b3b87859411e98bb2d3347020e7f45f48/gcc%2Fada%2Fsinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0382062b3b87859411e98bb2d3347020e7f45f48/gcc%2Fada%2Fsinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.ads?ref=0382062b3b87859411e98bb2d3347020e7f45f48", "patch": "@@ -4262,7 +4262,11 @@ package Sinfo is\n \n       --  Note: the Then_Actions and Else_Actions fields are always set to\n       --  No_List in the tree passed to Gigi. These fields are used only\n-      --  for temporary processing purposes in the expander.\n+      --  for temporary processing purposes in the expander. Even though they\n+      --  are semantic fields, their parent pointers are set because analysis\n+      --  of actions nodes in those lists may generate additional actions that\n+      --  need to know their insertion point (for example for the creation of\n+      --  transient scopes).\n \n       ----------------------------\n       -- 4.5.7  Case Expression --"}]}