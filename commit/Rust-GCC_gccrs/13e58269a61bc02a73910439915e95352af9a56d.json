{"sha": "13e58269a61bc02a73910439915e95352af9a56d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTNlNTgyNjlhNjFiYzAyYTczOTEwNDM5OTE1ZTk1MzUyYWY5YTU2ZA==", "commit": {"author": {"name": "Ulrich Weigand", "email": "uweigand@de.ibm.com", "date": "2002-02-15T23:30:03Z"}, "committer": {"name": "Ulrich Weigand", "email": "uweigand@gcc.gnu.org", "date": "2002-02-15T23:30:03Z"}, "message": "s390.c (pool_stop_uid, [...]): Delete.\n\n\t* config/s390/s390.c (pool_stop_uid, other_chunk, far_away,\n\tcheck_and_change_labels, s390_final_chunkify): Delete.\n\t(s390_split_branches, s390_chunkify_pool): New functions.\n\t(s390_function_prologue): Call them.\n\n\t* config/s390/s390.h (S390_REL_MAX): Delete.\n\t(S390_CHUNK_MAX, S390_CHUNK_OV): Adjust values.\n\n\t* config/s390/s390.md (cjump, icjump, jump): Fix length\n\tattribute calculation.\n\nFrom-SVN: r49797", "tree": {"sha": "822061ed2d96786aa1d1632e690639d5cd374533", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/822061ed2d96786aa1d1632e690639d5cd374533"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/13e58269a61bc02a73910439915e95352af9a56d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/13e58269a61bc02a73910439915e95352af9a56d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/13e58269a61bc02a73910439915e95352af9a56d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/13e58269a61bc02a73910439915e95352af9a56d/comments", "author": null, "committer": null, "parents": [{"sha": "34d1b01d2e3a634317fa53965a4341f97e2cd4bc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/34d1b01d2e3a634317fa53965a4341f97e2cd4bc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/34d1b01d2e3a634317fa53965a4341f97e2cd4bc"}], "stats": {"total": 514, "additions": 215, "deletions": 299}, "files": [{"sha": "73f2033975ac6c675fcc355270f83016aa1b737b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13e58269a61bc02a73910439915e95352af9a56d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13e58269a61bc02a73910439915e95352af9a56d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=13e58269a61bc02a73910439915e95352af9a56d", "patch": "@@ -1,3 +1,17 @@\n+2002-02-16  Ulrich Weigand  <uweigand@de.ibm.com>\n+\n+\t* config/s390/s390.c (pool_stop_uid, other_chunk, far_away, \n+\tcheck_and_change_labels, s390_final_chunkify): Delete.\n+\t(s390_split_branches, s390_chunkify_pool): New functions.\n+\t(s390_function_prologue): Call them.\n+\t\n+\t* config/s390/s390.h (S390_REL_MAX): Delete.\n+\t(S390_CHUNK_MAX, S390_CHUNK_OV): Adjust values.\n+\n+\t* config/s390/s390.md (cjump, icjump, jump): Fix length \n+\tattribute calculation.\n+\n+\n 2002-02-15  David Edelsohn  <edelsohn@gnu.org>\n \n \t* config/rs6000/linux64.h (STRIP_NAME_ENCODING): Delete."}, {"sha": "0f6a9db10c7304b34a8f25250faec8982297d12c", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 163, "deletions": 278, "changes": 441, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13e58269a61bc02a73910439915e95352af9a56d/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13e58269a61bc02a73910439915e95352af9a56d/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=13e58269a61bc02a73910439915e95352af9a56d", "patch": "@@ -129,10 +129,8 @@ static int general_s_operand PARAMS ((rtx, enum machine_mode, int));\n static int s390_decompose_address PARAMS ((rtx, struct s390_address *, int));\n static int reg_used_in_mem_p PARAMS ((int, rtx));\n static int addr_generation_dependency_p PARAMS ((rtx, rtx));\n-static int other_chunk PARAMS ((int *, int, int));\n-static int far_away PARAMS ((int, int));\n-static rtx check_and_change_labels PARAMS ((rtx, int *));\n-static void s390_final_chunkify PARAMS ((int));\n+static void s390_split_branches PARAMS ((void));\n+static void s390_chunkify_pool PARAMS ((void));\n static int save_fprs_p PARAMS ((void));\n static int find_unused_clobbered_reg PARAMS ((void));\n static void s390_frame_info PARAMS ((struct s390_frame *));\n@@ -2341,10 +2339,6 @@ int s390_pool_count = -1;\n    processed.  */\n rtx s390_pool_start_insn = NULL_RTX;\n \n-/* UID of last insn using the constant pool chunk that is currently \n-   being processed.  */\n-static int pool_stop_uid;\n-\n /* Called from the ASM_OUTPUT_POOL_PROLOGUE macro to \n    prepare for printing a literal pool chunk to stdio stream FILE.  \n \n@@ -2382,312 +2376,206 @@ s390_asm_output_pool_prologue (file, fname, fndecl, size)\n     function_section (fndecl);\n }\n \n-/* Return true if OTHER_ADDR is in different chunk than MY_ADDR.\n-   LTORG points to a list of all literal pools inserted\n-   into the current function.  */\n+/* Split all branches that exceed the maximum distance.  */\n \n-static int\n-other_chunk (ltorg, my_addr, other_addr)\n-     int *ltorg;\n-     int my_addr;\n-     int other_addr;\n+static void \n+s390_split_branches (void)\n {\n-  int ad, i=0, j=0;\n-\n-  while ((ad = ltorg[i++])) {\n-    if (INSN_ADDRESSES (ad) >= my_addr)\n-      break;\n-  }\n-\n-  while ((ad = ltorg[j++])) {\n-    if (INSN_ADDRESSES (ad) > other_addr)\n-      break;\n-  }\n-  \n-  if (i==j)\n-    return 0;\n-\n-  return 1;\n-}\n+  rtx temp_reg = gen_rtx_REG (Pmode, RETURN_REGNUM);\n+  rtx insn, pat, label, target, jump, tmp;\n \n-/* Return true if OTHER_ADDR is too far away from MY_ADDR\n-   to use a relative branch instruction.  */\n+  /* In 64-bit mode we can jump +- 4GB.  */\n \n-static int \n-far_away (my_addr, other_addr)\n-     int my_addr;\n-     int other_addr;\n-{\n-  /* In 64 bit mode we can jump +- 4GB.  */\n   if (TARGET_64BIT)\n-    return 0;\n-  if (abs (my_addr - other_addr) > S390_REL_MAX)\n-    return 1;\n-  return 0;\n-}\n+    return;\n \n-/* Go through all insns in the current function (starting\n-   at INSN), replacing branch insn if necessary.  A branch\n-   needs to be modified if either the distance to the \n-   target is too far to use a relative branch, or if the\n-   target uses a different literal pool than the origin.\n-   LTORG_UIDS points to a list of all literal pool insns\n-   that have been inserted.  */\n+  /* Find all branches that exceed 64KB, and split them.  */\n \n-static rtx \n-check_and_change_labels (insn, ltorg_uids)\n-     rtx insn;\n-     int *ltorg_uids;\n-{\n-  rtx temp_reg = gen_rtx_REG (Pmode, RETURN_REGNUM);\n-  rtx target, jump, cjump;\n-  rtx pattern, tmp, body, label1;\n-  int addr0, addr1;\n+  for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n+    {\n+      if (GET_CODE (insn) != JUMP_INSN)\n+\tcontinue;\n \n-  if (GET_CODE (insn) != JUMP_INSN) \n-    return insn;\n+      pat = PATTERN (insn);\n+      if (GET_CODE (pat) != SET)\n+\tcontinue;\n \n-  pattern = PATTERN (insn);\n-  \n-  addr0 = INSN_ADDRESSES (INSN_UID (insn));\n-  if (GET_CODE (pattern) == SET) \n-    {\n-      body = XEXP (pattern, 1);\n-      if (GET_CODE (body) == LABEL_REF) \n+      if (GET_CODE (SET_SRC (pat)) == LABEL_REF) \n \t{\n-\t  addr1 = INSN_ADDRESSES (INSN_UID (XEXP (body, 0)));\n-\t  \n-\t  if (other_chunk (ltorg_uids, addr0, addr1)) \n-\t    {\n-\t      SYMBOL_REF_USED (XEXP (body, 0)) = 1;\n-\t    } \n-\t  if (far_away (addr0, addr1)) \n-\t    {\n-\t      if (flag_pic) \n-\t\t{\n-\t\t  target = gen_rtx_UNSPEC (SImode, gen_rtvec (1, body), 100);\n-\t\t  target = gen_rtx_CONST (SImode, target);\n-\t\t  target = force_const_mem (SImode, target);\n-\t\t  jump = gen_rtx_REG (Pmode, BASE_REGISTER);\n-\t\t  jump = gen_rtx_PLUS (Pmode, jump, temp_reg);\n-\t\t} \n-\t      else \n-\t\t{\n-\t\t  target = force_const_mem (Pmode, body);\n-\t\t  jump = temp_reg;\n-\t\t}\n-\t      \n-\t      emit_insn_before (gen_movsi (temp_reg, target), insn);\n-\t      tmp = emit_jump_insn_before (gen_indirect_jump (jump), insn);\n-\t      remove_insn (insn);\n-\t      INSN_ADDRESSES_NEW (tmp, -1);\n-\t      return tmp;\n-\t    }\n+\t  label = SET_SRC (pat);\n \t} \n-      else if (GET_CODE (body) == IF_THEN_ELSE) \n+      else if (GET_CODE (SET_SRC (pat)) == IF_THEN_ELSE) \n \t{\n-\t  if (GET_CODE (XEXP (body, 1)) == LABEL_REF) \n-\t    {\n-\t      addr1 = INSN_ADDRESSES (INSN_UID (XEXP (XEXP (body, 1), 0)));\n-\t      \n-\t      if (other_chunk (ltorg_uids, addr0, addr1)) \n-\t\t{\n-\t\t  SYMBOL_REF_USED (XEXP (XEXP (body, 1), 0)) = 1;\n-\t\t} \n-\t      \n-\t      if (far_away (addr0, addr1)) \n-\t\t{\n-\t\t  if (flag_pic) \n-\t\t    {\n-\t\t      target = gen_rtx_UNSPEC (SImode, gen_rtvec (1, XEXP (body, 1)), 100);\n-\t\t      target = gen_rtx_CONST (SImode, target);\n-\t\t      target = force_const_mem (SImode, target);\n-\t\t      jump = gen_rtx_REG (Pmode, BASE_REGISTER);\n-\t\t      jump = gen_rtx_PLUS (Pmode, jump, temp_reg);\n-\t\t    } \n-\t\t  else \n-\t\t    {\n-\t\t      target = force_const_mem (Pmode, XEXP (body, 1));\n-\t\t      jump = temp_reg;\n-\t\t    }\n-\t\t  \n-\t\t  label1 = gen_label_rtx ();\n-\t\t  cjump = gen_rtx_LABEL_REF (VOIDmode, label1);\n-\t\t  cjump = gen_rtx_IF_THEN_ELSE (VOIDmode, XEXP (body, 0), pc_rtx, cjump);\n-\t\t  cjump = gen_rtx_SET (VOIDmode, pc_rtx, cjump);\n-\t\t  emit_jump_insn_before (cjump, insn);\n-\t\t  emit_insn_before (gen_movsi (temp_reg, target), insn);\n-\t\t  tmp = emit_jump_insn_before (gen_indirect_jump (jump), insn);\n-\t\t  INSN_ADDRESSES_NEW (emit_label_before (label1, insn), -1);\n-\t\t  remove_insn (insn);\n-\t\t  return tmp;\n-\t\t}\n-\t    }\n-\t  else if (GET_CODE (XEXP (body, 2)) == LABEL_REF) \n-\t    {\n-\t      addr1 = INSN_ADDRESSES (INSN_UID (XEXP (XEXP (body, 2), 0)));\n-\t      \n-\t      if (other_chunk (ltorg_uids, addr0, addr1)) \n-\t\t{\n-\t\t  SYMBOL_REF_USED (XEXP (XEXP (body, 2), 0)) = 1;\n-\t\t} \n-\t      \n-\t      if (far_away (addr0, addr1)) \n-\t\t{\n-\t\t  if (flag_pic) \n-\t\t    {\n-\t\t      target = gen_rtx_UNSPEC (SImode, gen_rtvec (1, XEXP (body, 2)), 100);\n-\t\t      target = gen_rtx_CONST (SImode, target);\n-\t\t      target = force_const_mem (SImode, target);\n-\t\t      jump = gen_rtx_REG (Pmode, BASE_REGISTER);\n-\t\t      jump = gen_rtx_PLUS (Pmode, jump, temp_reg);\n-\t\t    } \n-\t\t  else \n-\t\t    {\n-\t\t      target = force_const_mem (Pmode, XEXP (body, 2));\n-\t\t      jump = temp_reg;\n-\t\t    }\n-\t\t  \n-\t\t  label1 = gen_label_rtx ();\n-\t\t  cjump = gen_rtx_LABEL_REF (VOIDmode, label1);\n-\t\t  cjump = gen_rtx_IF_THEN_ELSE (VOIDmode, XEXP (body, 0), cjump, pc_rtx);\n-\t\t  cjump = gen_rtx_SET (VOIDmode, pc_rtx, cjump);\n-\t\t  emit_jump_insn_before (cjump, insn);\n-\t\t  emit_insn_before (gen_movsi (temp_reg, target), insn);\n-\t\t  tmp = emit_jump_insn_before (gen_indirect_jump (jump), insn);\n-\t\t  INSN_ADDRESSES_NEW (emit_label_before (label1, insn), -1);\n-\t\t  remove_insn (insn);\n-\t\t  return tmp;\n-\t\t}\n-\t    }\n+\t  if (GET_CODE (XEXP (SET_SRC (pat), 1)) == LABEL_REF) \n+\t    label = XEXP (SET_SRC (pat), 1);\n+          else if (GET_CODE (XEXP (SET_SRC (pat), 2)) == LABEL_REF) \n+            label = XEXP (SET_SRC (pat), 2);\n+\t  else\n+\t    continue;\n+        }\n+      else\n+\tcontinue;\n+\n+      if (get_attr_length (insn) == 4)\n+\tcontinue;\n+\n+      if (flag_pic)\n+\t{\n+\t  target = gen_rtx_UNSPEC (SImode, gen_rtvec (1, label), 100);\n+\t  target = gen_rtx_CONST (SImode, target);\n+\t  target = force_const_mem (SImode, target);\n+\t  jump = gen_rtx_REG (Pmode, BASE_REGISTER);\n+\t  jump = gen_rtx_PLUS (Pmode, jump, temp_reg);\n \t}\n-    } \n-  else if (GET_CODE (pattern) == ADDR_VEC || \n-\t   GET_CODE (pattern) == ADDR_DIFF_VEC) \n-    {\n-      int i, diff_vec_p = GET_CODE (pattern) == ADDR_DIFF_VEC;\n-      int len = XVECLEN (pattern, diff_vec_p);\n-      \n-      for (i = 0; i < len; i++) \n+      else\n \t{\n-\t  addr1 = INSN_ADDRESSES (INSN_UID (XEXP (XVECEXP (pattern, diff_vec_p, i), 0)));\n-\t  if (other_chunk (ltorg_uids, addr0, addr1)) \n-\t    {\n-\t      SYMBOL_REF_USED (XEXP (XVECEXP (pattern, diff_vec_p, i), 0)) = 1;\n-\t    } \n+\t  target = force_const_mem (Pmode, label);\n+\t  jump = temp_reg;\n+\t}\n+\n+      if (GET_CODE (SET_SRC (pat)) == IF_THEN_ELSE)\n+\t{\n+\t  if (GET_CODE (XEXP (SET_SRC (pat), 1)) == LABEL_REF)\n+\t    jump = gen_rtx_IF_THEN_ELSE (VOIDmode, XEXP (SET_SRC (pat), 0),\n+\t\t\t\t\t jump, pc_rtx);\n+\t  else\n+\t    jump = gen_rtx_IF_THEN_ELSE (VOIDmode, XEXP (SET_SRC (pat), 0),\n+\t\t\t\t\t pc_rtx, jump);\n \t}\n+\n+      tmp = emit_insn_before (gen_rtx_SET (Pmode, temp_reg, target), insn);\n+      INSN_ADDRESSES_NEW (tmp, -1);\n+\n+      tmp = emit_jump_insn_before (gen_rtx_SET (VOIDmode, pc_rtx, jump), insn);\n+      INSN_ADDRESSES_NEW (tmp, -1);\n+\n+      remove_insn (insn);\n+      insn = tmp;\n     }\n-  return insn;\n }\n \n-/* Called from s390_function_prologue to make final adjustments\n-   before outputting code.  CHUNKIFY specifies whether we need\n-   to use multiple literal pools (because the total size of the\n-   literals exceeds 4K).  */\n+/* Chunkify the literal pool if required.  */\n \n-static void\n-s390_final_chunkify (chunkify)\n-     int chunkify;\n+static void \n+s390_chunkify_pool (void)\n {\n-  rtx insn, ninsn, tmp;\n-  int addr, naddr = 0, uids;\n-  int chunk_max = 0;\n+  int *ltorg_uids, max_ltorg, chunk, last_addr;\n+  rtx insn;\n \n-  int size = insn_current_address;\n+  /* Do we need to chunkify the literal pool?  */\n \n-  int *ltorg_uids;\n-  int max_ltorg=0;\n+  if (get_pool_size () <= S390_POOL_MAX)\n+    return;\n \n-  ltorg_uids = alloca (size / 1024 + 1024);\n-  memset (ltorg_uids, 0, size / 1024 + 1024);\n+  /* Find all insns where a literal pool chunk must be inserted.  */\n \n-  if (chunkify == 1) \n-    {\n-      chunk_max = size * 2048 / get_pool_size ();\n-      chunk_max = chunk_max > S390_CHUNK_MAX \n-\t? S390_CHUNK_MAX : chunk_max;\n-    } \n-  \n-  for (insn=get_insns (); insn;insn = next_real_insn (insn)) \n+  ltorg_uids = alloca (insn_current_address / 1024 + 1024);\n+  max_ltorg = 0;\n+\n+  last_addr = 0;\n+  for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n     {\n-      if (GET_RTX_CLASS (GET_CODE (insn)) != 'i')\n+      if (INSN_ADDRESSES (INSN_UID (insn)) - last_addr < S390_CHUNK_MAX)\n \tcontinue;\n-      \n-      addr = INSN_ADDRESSES (INSN_UID (insn));\n-      if ((ninsn = next_real_insn (insn))) \n+      if (INSN_ADDRESSES (INSN_UID (insn)) - last_addr > S390_CHUNK_OV)\n+\tabort ();\n+\n+      if (GET_CODE (insn) == CODE_LABEL\n+\t  && !(GET_CODE (NEXT_INSN (insn)) == JUMP_INSN\n+\t       && (GET_CODE (PATTERN (NEXT_INSN (insn))) == ADDR_VEC\n+\t\t   || GET_CODE (PATTERN (NEXT_INSN (insn))) == ADDR_DIFF_VEC)))\n \t{\n-\t  naddr = INSN_ADDRESSES (INSN_UID (ninsn));\n+\t  ltorg_uids[max_ltorg++] = INSN_UID (prev_real_insn (insn));\n+\t  last_addr = INSN_ADDRESSES (ltorg_uids[max_ltorg-1]);\n+\t  continue;\n \t}\n-      \n-      if (chunkify && (addr / chunk_max != naddr / chunk_max)) \n+\n+      if (GET_CODE (insn) == CALL_INSN)\n \t{\n-\t  for (tmp = insn; tmp; tmp = NEXT_INSN (tmp)) \n-\t    {\n-\t      if (GET_CODE (tmp) == CODE_LABEL && \n-\t\t  GET_CODE (NEXT_INSN (tmp)) != JUMP_INSN) \n-\t\t{\n-\t\t  ltorg_uids[max_ltorg++] = INSN_UID (prev_real_insn (tmp));\n-\t\t  break;\n-\t\t} \n-\t      if (GET_CODE (tmp) == CALL_INSN) \n-\t\t{\n-\t\t  ltorg_uids[max_ltorg++] = INSN_UID (tmp);\n-\t\t  break;\n-\t\t} \n-\t      if (INSN_ADDRESSES (INSN_UID (tmp)) - naddr > S390_CHUNK_OV) \n-\t\t{\n-\t\t  debug_rtx (insn);\n-\t\t  debug_rtx (tmp);\n-\t\t  fprintf (stderr, \"s390 multiple literalpool support:\\n No code label between this insn %X %X\",\n-\t\t\t   naddr, INSN_ADDRESSES (INSN_UID (tmp)));\n-\t\t  abort ();\n-\t\t}\n-\t    }\n-\t  if (tmp == NULL) \n-\t    {\n-\t      warning (\"no code label found\");\n-\t    }\n-\t} \n+\t  ltorg_uids[max_ltorg++] = INSN_UID (insn);\n+\t  last_addr = INSN_ADDRESSES (ltorg_uids[max_ltorg-1]);\n+\t  continue;\n+\t}\n     }\n-  ltorg_uids[max_ltorg] = 0;\n \n-  if (max_ltorg > 0)\n-    {\n-      for (insn = get_insns (), uids = 0; insn; insn = next_real_insn (insn)) \n-        if (INSN_UID (insn) == ltorg_uids[uids]) \n-\t  {\n-\t    INSN_ADDRESSES_NEW (emit_insn_after (gen_ltorg (\n-\t\t\t        gen_rtx_CONST_INT (Pmode, ltorg_uids[++uids])),\n-\t\t\t\t\t       insn), -1);\n-\t  } \n+  ltorg_uids[max_ltorg] = insn_current_address + 1;\n \n-      init_insn_lengths ();\n-      shorten_branches (get_insns ());\n-    }\n+  /* Find and mark all labels that are branched into \n+     from an insn belonging to a different chunk.  */\n \n-  for (insn = get_insns (); insn; insn = next_real_insn (insn)) \n+  chunk = last_addr = 0;\n+  for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n     {\n-      if (GET_RTX_CLASS (GET_CODE (insn)) != 'i')\n-\tcontinue;\n       if (GET_CODE (insn) == JUMP_INSN) \n-\tinsn = check_and_change_labels (insn, ltorg_uids);\n+\t{\n+          rtx pat = PATTERN (insn);\n+          if (GET_CODE (pat) == SET) \n+            {\n+\t      rtx label = 0;\n+\n+              if (GET_CODE (SET_SRC (pat)) == LABEL_REF) \n+\t        {\n+\t          label = XEXP (SET_SRC (pat), 0);\n+\t        } \n+              else if (GET_CODE (SET_SRC (pat)) == IF_THEN_ELSE) \n+\t        {\n+\t          if (GET_CODE (XEXP (SET_SRC (pat), 1)) == LABEL_REF) \n+\t            label = XEXP (XEXP (SET_SRC (pat), 1), 0);\n+\t          else if (GET_CODE (XEXP (SET_SRC (pat), 2)) == LABEL_REF) \n+\t            label = XEXP (XEXP (SET_SRC (pat), 2), 0);\n+\t        }\n+\n+\t      if (label)\n+\t\t{\n+\t          if (INSN_ADDRESSES (INSN_UID (label)) <= last_addr\n+\t              || INSN_ADDRESSES (INSN_UID (label)) > ltorg_uids[chunk])\n+\t            SYMBOL_REF_USED (label) = 1;\n+\t\t}\n+            } \n+          else if (GET_CODE (pat) == ADDR_VEC\n+\t           || GET_CODE (pat) == ADDR_DIFF_VEC)\n+            {\n+\t      int i, diff_p = GET_CODE (pat) == ADDR_DIFF_VEC;\n+\n+              for (i = 0; i < XVECLEN (pat, diff_p); i++) \n+\t        {\n+\t          rtx label = XEXP (XVECEXP (pat, diff_p, i), 0);\n+\n+\t          if (INSN_ADDRESSES (INSN_UID (label)) <= last_addr\n+\t              || INSN_ADDRESSES (INSN_UID (label)) > ltorg_uids[chunk])\n+\t\t    SYMBOL_REF_USED (label) = 1;\n+\t        }\n+            }\n+        }\n+\n+      if (INSN_UID (insn) == ltorg_uids[chunk]) \n+        {\n+\t  last_addr = ltorg_uids[chunk++];\n+        }\n     }\n \n-  if (chunkify) \n+  /* Insert literal pools and base register reload insns.  */\n+\n+  chunk = 0;\n+  for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n     {\n-    for (insn=get_insns (); insn;insn = next_insn (insn)) \n-      {\n-      if (GET_CODE (insn) == CODE_LABEL) \n+      if (INSN_UID (insn) == ltorg_uids[chunk]) \n+        {\n+\t  rtx new_insn = gen_ltorg (GEN_INT (chunk++));\n+\t  INSN_ADDRESSES_NEW (emit_insn_after (new_insn, insn), -1);\n+        }\n+\n+      if (GET_CODE (insn) == CODE_LABEL && SYMBOL_REF_USED (insn))\n \t{\n-\tif (SYMBOL_REF_USED (insn)) \n-\t  {\n-\t    INSN_ADDRESSES_NEW (emit_insn_after (gen_reload_base (\n-\t\t\t\t\t\t\t\t  gen_rtx_LABEL_REF (Pmode, XEXP (insn, 0))), insn), -1);\n-\t  }\n+\t  rtx new_insn = gen_reload_base (insn);\n+\t  INSN_ADDRESSES_NEW (emit_insn_after (new_insn, insn), -1);\n \t}\n-      }\n     }\n-  pool_stop_uid = ltorg_uids[0];\n+\n+  /* Recompute insn addresses.  */\n+\n+  init_insn_lengths ();\n+  shorten_branches (get_insns ());\n }\n \n /* Return true if INSN is a 'ltorg' insn.  */\n@@ -2719,7 +2607,6 @@ s390_dump_literal_pool (act_insn, stop)\n      rtx stop;\n {\n   s390_pool_start_insn = act_insn;\n-  pool_stop_uid = INTVAL (stop);\n   s390_pool_count++;\n   output_constant_pool (current_function_name, current_function_decl);\n   function_section (current_function_decl);\n@@ -2927,10 +2814,8 @@ s390_function_prologue (file, lsize)\n      FILE *file ATTRIBUTE_UNUSED;\n      HOST_WIDE_INT lsize ATTRIBUTE_UNUSED;\n {\n-  if (get_pool_size () > S390_POOL_MAX)\n-    s390_final_chunkify (1);\n-  else\n-    s390_final_chunkify (0);\n+  s390_chunkify_pool ();\n+  s390_split_branches ();\n }\n \n /* Output the function epilogue assembly code to the "}, {"sha": "6756e6099ef4ba935df6bcd2ea1f1dc137f00efe", "filename": "gcc/config/s390/s390.h", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13e58269a61bc02a73910439915e95352af9a56d/gcc%2Fconfig%2Fs390%2Fs390.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13e58269a61bc02a73910439915e95352af9a56d/gcc%2Fconfig%2Fs390%2Fs390.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.h?ref=13e58269a61bc02a73910439915e95352af9a56d", "patch": "@@ -1330,9 +1330,8 @@ extern int s390_nr_constants;\n /* Function is splitted in chunk, if literal pool could overflow\n    Value need to be lowered, if problems with displacement overflow.  */\n \n-#define S390_REL_MAX 55000\n-#define S390_CHUNK_MAX 0x2000\n-#define S390_CHUNK_OV 0x8000\n+#define S390_CHUNK_MAX 0xe00\n+#define S390_CHUNK_OV 0x1000\n #define S390_POOL_MAX 0xe00\n \n #define ASM_OUTPUT_POOL_PROLOGUE(FILE, FUNNAME, fndecl, size)  \t        \\"}, {"sha": "1ec96849b36c639dd8bc8457a72432384b1d68bb", "filename": "gcc/config/s390/s390.md", "status": "modified", "additions": 36, "deletions": 18, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13e58269a61bc02a73910439915e95352af9a56d/gcc%2Fconfig%2Fs390%2Fs390.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13e58269a61bc02a73910439915e95352af9a56d/gcc%2Fconfig%2Fs390%2Fs390.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.md?ref=13e58269a61bc02a73910439915e95352af9a56d", "patch": "@@ -5660,15 +5660,21 @@\n   \"\"\n   \"*\n {\n-  if (get_attr_length (insn) == 4 || !TARGET_64BIT)\n-     return \\\"j%C1\\\\t%l0\\\";\n+  if (get_attr_length (insn) == 4)\n+    return \\\"j%C1\\\\t%l0\\\";\n+  else if (TARGET_64BIT)\n+    return \\\"jg%C1\\\\t%l0\\\";\n   else\n-     return \\\"jg%C1\\\\t%l0\\\";\n+    abort ();\n }\"\n   [(set_attr \"op_type\" \"RI\")\n-   (set (attr \"length\") (if_then_else\n-      (lt (abs (minus (pc) (match_dup 0))) (const_int 60000))\n-      (const_int 4) (const_int 6)))])\n+   (set (attr \"length\")\n+        (cond [(lt (abs (minus (pc) (match_dup 0))) (const_int 60000))\n+                (const_int 4)\n+               (ne (symbol_ref \"TARGET_64BIT\") (const_int 0))\n+                 (const_int 6)\n+               (eq (symbol_ref \"flag_pic\") (const_int 0))\n+                 (const_int 6)] (const_int 8)))])\n \n (define_insn \"*cjump_long\"\n  [(set (pc)\n@@ -5703,15 +5709,21 @@\n   \"\"\n   \"*\n {  \n-  if (get_attr_length (insn) == 4 || !TARGET_64BIT)\n-     return \\\"j%D1\\\\t%l0\\\";\n+  if (get_attr_length (insn) == 4)\n+    return \\\"j%D1\\\\t%l0\\\";\n+  else if (TARGET_64BIT)\n+    return \\\"jg%D1\\\\t%l0\\\";\n   else\n-     return \\\"jg%D1\\\\t%l0\\\";\n+    abort ();\n }\"\n   [(set_attr \"op_type\" \"RI\")\n-   (set (attr \"length\") (if_then_else\n-     (lt (abs (minus (pc) (match_dup 0))) (const_int 60000))\n-     (const_int 4) (const_int 6)))])\n+   (set (attr \"length\")\n+        (cond [(lt (abs (minus (pc) (match_dup 0))) (const_int 60000))\n+                (const_int 4)\n+               (ne (symbol_ref \"TARGET_64BIT\") (const_int 0))\n+                 (const_int 6)\n+               (eq (symbol_ref \"flag_pic\") (const_int 0))\n+                 (const_int 6)] (const_int 8)))])\n \n (define_insn \"*icjump_long\"\n  [(set (pc)\n@@ -5794,15 +5806,21 @@\n   \"\"\n   \"*\n {\n-  if (get_attr_length (insn) == 4 || !TARGET_64BIT)\n-     return \\\"j\\\\t%l0\\\";\n+  if (get_attr_length (insn) == 4)\n+    return \\\"j\\\\t%l0\\\";\n+  else if (TARGET_64BIT)\n+    return \\\"jg\\\\t%l0\\\";\n   else\n-     return \\\"jg\\\\t%l0\\\";\n+    abort ();\n }\"\n   [(set_attr \"op_type\" \"RI\")\n-   (set (attr \"length\") (if_then_else\n-     (lt (abs (minus (pc) (match_dup 0))) (const_int 60000))\n-     (const_int 4) (const_int 6)))])\n+   (set (attr \"length\")\n+        (cond [(lt (abs (minus (pc) (match_dup 0))) (const_int 60000))\n+                (const_int 4)\n+               (ne (symbol_ref \"TARGET_64BIT\") (const_int 0))\n+                 (const_int 6)\n+               (eq (symbol_ref \"flag_pic\") (const_int 0))\n+                 (const_int 6)] (const_int 8)))])\n \n ;\n ; indirect-jump instruction pattern(s)."}]}