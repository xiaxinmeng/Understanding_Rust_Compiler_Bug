{"sha": "c800f862877b728756eb0a41c6ed12cf1fdc3c45", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzgwMGY4NjI4NzdiNzI4NzU2ZWIwYTQxYzZlZDEyY2YxZmRjM2M0NQ==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2009-04-07T13:55:31Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-04-07T13:55:31Z"}, "message": "checks.adb (Determine_Range): Add Assume_Valid parameter\n\n2009-04-07  Robert Dewar  <dewar@adacore.com>\n\n\t* checks.adb (Determine_Range): Add Assume_Valid parameter\n\t\n\t* checks.ads (Determine_Range): Add Assume_Valid parameter\n\t\n\t* errout.adb (Error_Msg_NEL): Use Suppress_Loop_Warnings rather than\n\t Is_Null_Loop to suppress warnings in a loop body.\n\t\n\t* exp_ch4.adb:\n\t(Rewrite_Comparison): Major rewrite to accomodate invalid values\n\t\n\t* exp_ch5.adb:\n\t(Expand_N_Loop_Statement): Delete loop known not to execute\n\t\n\t* opt.ads:\n\t(Assume_No_Invalid_Values): Now set to False, and as documented, this\n\t fully enables the proper handling of invalid values.\n\t\n\t* sem_attr.adb:\n\tNew calling sequence for Is_In_Range\n\t\n\t* sem_ch5.adb:\n\t(Analyze_Iteration_Scheme): Accomodate possible invalid values\n\t in determining if a loop range is null.\n\t\n\t* sem_eval.adb:\n\t(Is_In_Range): Add Assume_Valid parameter\n\t(Is_Out_Of_Range): Add Assume_Valid_Parameter\n\t(Compile_Time_Compare): Major rewrite to accomodate invalid values and\n\t also to do more accurate and complete range analysis, catching more\n\t cases.\n\t\n\t* sem_eval.ads:\n\t(Is_In_Range): Add Assume_Valid parameter\n\t(Is_Out_Of_Range): Add Assume_Valid_Parameter\n\t\n\t* sem_util.adb:\n\tNew calling sequence for Is_In_Range\n\t\n\t* sinfo.adb:\n\t(Suppress_Loop_Warnings): New flag\n\t\n\t* sinfo.ads:\n\t(Is_Null_Loop): Update documentation\n\t(Suppress_Loop_Warnings): New flag\n\t\n\t* gnat_ugn.texi: Document -gnatB switch\n\nFrom-SVN: r145672", "tree": {"sha": "f813cf5f3512ec45d3d80589002e3c400c361b66", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f813cf5f3512ec45d3d80589002e3c400c361b66"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c800f862877b728756eb0a41c6ed12cf1fdc3c45", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c800f862877b728756eb0a41c6ed12cf1fdc3c45", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c800f862877b728756eb0a41c6ed12cf1fdc3c45", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c800f862877b728756eb0a41c6ed12cf1fdc3c45/comments", "author": null, "committer": null, "parents": [{"sha": "9d00840d08b39852023715be90d3499ad677aa38", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d00840d08b39852023715be90d3499ad677aa38", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9d00840d08b39852023715be90d3499ad677aa38"}], "stats": {"total": 645, "additions": 483, "deletions": 162}, "files": [{"sha": "c03102775ba086cb9a6b0b21ac476f033c8f01ea", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c800f862877b728756eb0a41c6ed12cf1fdc3c45/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c800f862877b728756eb0a41c6ed12cf1fdc3c45/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=c800f862877b728756eb0a41c6ed12cf1fdc3c45", "patch": "@@ -1,3 +1,52 @@\n+2009-04-07  Robert Dewar  <dewar@adacore.com>\n+\n+\t* checks.adb (Determine_Range): Add Assume_Valid parameter\n+\t\n+\t* checks.ads (Determine_Range): Add Assume_Valid parameter\n+\t\n+\t* errout.adb (Error_Msg_NEL): Use Suppress_Loop_Warnings rather than\n+\t Is_Null_Loop to suppress warnings in a loop body.\n+\t\n+\t* exp_ch4.adb:\n+\t(Rewrite_Comparison): Major rewrite to accomodate invalid values\n+\t\n+\t* exp_ch5.adb:\n+\t(Expand_N_Loop_Statement): Delete loop known not to execute\n+\t\n+\t* opt.ads:\n+\t(Assume_No_Invalid_Values): Now set to False, and as documented, this\n+\t fully enables the proper handling of invalid values.\n+\t\n+\t* sem_attr.adb:\n+\tNew calling sequence for Is_In_Range\n+\t\n+\t* sem_ch5.adb:\n+\t(Analyze_Iteration_Scheme): Accomodate possible invalid values\n+\t in determining if a loop range is null.\n+\t\n+\t* sem_eval.adb:\n+\t(Is_In_Range): Add Assume_Valid parameter\n+\t(Is_Out_Of_Range): Add Assume_Valid_Parameter\n+\t(Compile_Time_Compare): Major rewrite to accomodate invalid values and\n+\t also to do more accurate and complete range analysis, catching more\n+\t cases.\n+\t\n+\t* sem_eval.ads:\n+\t(Is_In_Range): Add Assume_Valid parameter\n+\t(Is_Out_Of_Range): Add Assume_Valid_Parameter\n+\t\n+\t* sem_util.adb:\n+\tNew calling sequence for Is_In_Range\n+\t\n+\t* sinfo.adb:\n+\t(Suppress_Loop_Warnings): New flag\n+\t\n+\t* sinfo.ads:\n+\t(Is_Null_Loop): Update documentation\n+\t(Suppress_Loop_Warnings): New flag\n+\t\n+\t* gnat_ugn.texi: Document -gnatB switch\n+\n 2009-04-07  Arnaud Charlet  <charlet@adacore.com>\n \n \t* gnatvsn.ads: Bump version number."}, {"sha": "ab5c86856c82d829b0c9b3f0b1e6cbb0b9c80e80", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 64, "deletions": 37, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c800f862877b728756eb0a41c6ed12cf1fdc3c45/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c800f862877b728756eb0a41c6ed12cf1fdc3c45/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=c800f862877b728756eb0a41c6ed12cf1fdc3c45", "patch": "@@ -842,14 +842,16 @@ package body Checks is\n                Tlo := Expr_Value (Type_Low_Bound  (Target_Type));\n                Thi := Expr_Value (Type_High_Bound (Target_Type));\n \n-               Determine_Range (Left_Opnd  (N), LOK, Llo, Lhi);\n-               Determine_Range (Right_Opnd (N), ROK, Rlo, Rhi);\n+               Determine_Range\n+                 (Left_Opnd  (N), LOK, Llo, Lhi, Assume_Valid => True);\n+               Determine_Range\n+                 (Right_Opnd (N), ROK, Rlo, Rhi, Assume_Valid => True);\n \n                if (LOK and ROK)\n                  and then Tlo <= Llo and then Lhi <= Thi\n                  and then Tlo <= Rlo and then Rhi <= Thi\n                then\n-                  Determine_Range (N, VOK, Vlo, Vhi);\n+                  Determine_Range (N, VOK, Vlo, Vhi, Assume_Valid => True);\n \n                   if VOK and then Tlo <= Vlo and then Vhi <= Thi then\n                      Rewrite (Left_Opnd (N),\n@@ -1459,7 +1461,7 @@ package body Checks is\n         and then not Backend_Divide_Checks_On_Target\n         and then Check_Needed (Right, Division_Check)\n       then\n-         Determine_Range (Right, ROK, Rlo, Rhi);\n+         Determine_Range (Right, ROK, Rlo, Rhi, Assume_Valid => True);\n \n          --  See if division by zero possible, and if so generate test. This\n          --  part of the test is not controlled by the -gnato switch.\n@@ -1482,7 +1484,7 @@ package body Checks is\n             if Nkind (N) = N_Op_Divide\n               and then Is_Signed_Integer_Type (Typ)\n             then\n-               Determine_Range (Left, LOK, Llo, Lhi);\n+               Determine_Range (Left, LOK, Llo, Lhi, Assume_Valid => True);\n                LLB := Expr_Value (Type_Low_Bound (Base_Type (Typ)));\n \n                if ((not ROK) or else (Rlo <= (-1) and then (-1) <= Rhi))\n@@ -2003,7 +2005,7 @@ package body Checks is\n \n                   --  Otherwise determine range of value\n \n-                  Determine_Range (Expr, OK, Lo, Hi);\n+                  Determine_Range (Expr, OK, Lo, Hi, Assume_Valid => True);\n \n                   if OK then\n \n@@ -2046,11 +2048,18 @@ package body Checks is\n                            Assume_Valid => True,\n                            Fixed_Int    => Fixed_Int)\n              or else\n-           Is_In_Range (Expr, Target_Typ, Fixed_Int, Int_Real))\n+               Is_In_Range (Expr, Target_Typ,\n+                            Assume_Valid => True,\n+                            Fixed_Int => Fixed_Int,\n+                            Int_Real  => Int_Real))\n       then\n          return;\n \n-      elsif Is_Out_Of_Range (Expr, Target_Typ, Fixed_Int, Int_Real) then\n+      elsif Is_Out_Of_Range (Expr, Target_Typ,\n+                             Assume_Valid => True,\n+                             Fixed_Int    => Fixed_Int,\n+                             Int_Real     => Int_Real)\n+      then\n          Bad_Value;\n          return;\n \n@@ -3010,6 +3019,7 @@ package body Checks is\n    --  Determine size of below cache (power of 2 is more efficient!)\n \n    Determine_Range_Cache_N  : array (Cache_Index) of Node_Id;\n+   Determine_Range_Cache_V  : array (Cache_Index) of Boolean;\n    Determine_Range_Cache_Lo : array (Cache_Index) of Uint;\n    Determine_Range_Cache_Hi : array (Cache_Index) of Uint;\n    --  The above arrays are used to implement a small direct cache for\n@@ -3018,13 +3028,15 @@ package body Checks is\n    --  on the way up the tree, a quadratic behavior can otherwise be\n    --  encountered in large expressions. The cache entry for node N is stored\n    --  in the (N mod Cache_Size) entry, and can be validated by checking the\n-   --  actual node value stored there.\n+   --  actual node value stored there. The Range_Cache_V array records the\n+   --  setting of Assume_Valid for the cache entry.\n \n    procedure Determine_Range\n-     (N  : Node_Id;\n-      OK : out Boolean;\n-      Lo : out Uint;\n-      Hi : out Uint)\n+     (N            : Node_Id;\n+      OK           : out Boolean;\n+      Lo           : out Uint;\n+      Hi           : out Uint;\n+      Assume_Valid : Boolean := False)\n    is\n       Typ : Entity_Id := Etype (N);\n       --  Type to use, may get reset to base type for possibly invalid entity\n@@ -3064,13 +3076,15 @@ package body Checks is\n \n       function OK_Operands return Boolean is\n       begin\n-         Determine_Range (Left_Opnd  (N), OK1, Lo_Left,  Hi_Left);\n+         Determine_Range\n+           (Left_Opnd  (N), OK1, Lo_Left,  Hi_Left, Assume_Valid);\n \n          if not OK1 then\n             return False;\n          end if;\n \n-         Determine_Range (Right_Opnd (N), OK1, Lo_Right, Hi_Right);\n+         Determine_Range\n+           (Right_Opnd (N), OK1, Lo_Right, Hi_Right, Assume_Valid);\n          return OK1;\n       end OK_Operands;\n \n@@ -3111,7 +3125,10 @@ package body Checks is\n \n       Cindex := Cache_Index (N mod Cache_Size);\n \n-      if Determine_Range_Cache_N (Cindex) = N then\n+      if Determine_Range_Cache_N (Cindex) = N\n+           and then\n+         Determine_Range_Cache_V (Cindex) = Assume_Valid\n+      then\n          Lo := Determine_Range_Cache_Lo (Cindex);\n          Hi := Determine_Range_Cache_Hi (Cindex);\n          return;\n@@ -3122,14 +3139,15 @@ package body Checks is\n       --  overflow situation, which is a separate check, we are talking here\n       --  only about the expression value).\n \n-      --  First step, change to use base type if the expression is an entity\n-      --  which we do not know is valid.\n+      --  First step, change to use base type unless we know the value is valid\n \n-      if Is_Entity_Name (N)\n-        and then not Is_Known_Valid (Entity (N))\n-        and then not Assume_No_Invalid_Values\n+      if (Is_Entity_Name (N) and then Is_Known_Valid (Entity (N)))\n+        or else Assume_No_Invalid_Values\n+        or else Assume_Valid\n       then\n-         Typ := Base_Type (Typ);\n+         null;\n+      else\n+         Typ := Underlying_Type (Base_Type (Typ));\n       end if;\n \n       --  We use the actual bound unless it is dynamic, in which case use the\n@@ -3186,12 +3204,14 @@ package body Checks is\n          --  For unary plus, result is limited by range of operand\n \n          when N_Op_Plus =>\n-            Determine_Range (Right_Opnd (N), OK1, Lor, Hir);\n+            Determine_Range\n+              (Right_Opnd (N), OK1, Lor, Hir, Assume_Valid);\n \n          --  For unary minus, determine range of operand, and negate it\n \n          when N_Op_Minus =>\n-            Determine_Range (Right_Opnd (N), OK1, Lo_Right, Hi_Right);\n+            Determine_Range\n+              (Right_Opnd (N), OK1, Lo_Right, Hi_Right, Assume_Valid);\n \n             if OK1 then\n                Lor := -Hi_Right;\n@@ -3298,7 +3318,8 @@ package body Checks is\n                --  possible range of values of the attribute expression\n \n                when Name_Pos | Name_Val =>\n-                  Determine_Range (First (Expressions (N)), OK1, Lor, Hir);\n+                  Determine_Range\n+                    (First (Expressions (N)), OK1, Lor, Hir, Assume_Valid);\n \n                --  For Length attribute, use the bounds of the corresponding\n                --  index type to refine the range.\n@@ -3341,27 +3362,29 @@ package body Checks is\n                      end loop;\n \n                      Determine_Range\n-                       (Type_Low_Bound (Etype (Indx)), OK1, LL, LU);\n+                       (Type_Low_Bound (Etype (Indx)), OK1, LL, LU,\n+                        Assume_Valid);\n \n                      if OK1 then\n                         Determine_Range\n-                          (Type_High_Bound (Etype (Indx)), OK1, UL, UU);\n+                          (Type_High_Bound (Etype (Indx)), OK1, UL, UU,\n+                           Assume_Valid);\n \n                         if OK1 then\n \n                            --  The maximum value for Length is the biggest\n                            --  possible gap between the values of the bounds.\n                            --  But of course, this value cannot be negative.\n \n-                           Hir := UI_Max (Uint_0, UU - LL);\n+                           Hir := UI_Max (Uint_0, UU - LL + 1);\n \n                            --  For constrained arrays, the minimum value for\n                            --  Length is taken from the actual value of the\n                            --  bounds, since the index will be exactly of\n                            --  this subtype.\n \n                            if Is_Constrained (Atyp) then\n-                              Lor := UI_Max (Uint_0, UL - LU);\n+                              Lor := UI_Max (Uint_0, UL - LU + 1);\n \n                            --  For an unconstrained array, the minimum value\n                            --  for length is always zero.\n@@ -3385,7 +3408,7 @@ package body Checks is\n          --  refine the range using the converted value.\n \n          when N_Type_Conversion =>\n-            Determine_Range (Expression (N), OK1, Lor, Hir);\n+            Determine_Range (Expression (N), OK1, Lor, Hir, Assume_Valid);\n \n          --  Nothing special to do for all other expression kinds\n \n@@ -3430,6 +3453,7 @@ package body Checks is\n       --  Set cache entry for future call and we are all done\n \n       Determine_Range_Cache_N  (Cindex) := N;\n+      Determine_Range_Cache_V  (Cindex) := Assume_Valid;\n       Determine_Range_Cache_Lo (Cindex) := Lo;\n       Determine_Range_Cache_Hi (Cindex) := Hi;\n       return;\n@@ -3546,7 +3570,7 @@ package body Checks is\n       --  different.\n \n       if Nkind (N) /= N_Type_Conversion then\n-         Determine_Range (N, OK, Lo, Hi);\n+         Determine_Range (N, OK, Lo, Hi, Assume_Valid => True);\n \n          --  Note in the test below that we assume that the range is not OK\n          --  if a bound of the range is equal to that of the type. That's not\n@@ -6954,7 +6978,6 @@ package body Checks is\n                begin\n                   Opnd_Index := First_Index (Get_Actual_Subtype (Ck_Node));\n                   Targ_Index := First_Index (T_Typ);\n-\n                   while Present (Opnd_Index) loop\n \n                      --  If the index is a range, use its bounds. If it is an\n@@ -6970,11 +6993,13 @@ package body Checks is\n                      end if;\n \n                      if Nkind (Opnd_Range) = N_Range then\n-                        if Is_In_Range\n-                             (Low_Bound (Opnd_Range), Etype (Targ_Index))\n+                        if  Is_In_Range\n+                             (Low_Bound (Opnd_Range), Etype (Targ_Index),\n+                              Assume_Valid => True)\n                           and then\n                             Is_In_Range\n-                             (High_Bound (Opnd_Range), Etype (Targ_Index))\n+                             (High_Bound (Opnd_Range), Etype (Targ_Index),\n+                              Assume_Valid => True)\n                         then\n                            null;\n \n@@ -6991,10 +7016,12 @@ package body Checks is\n                            null;\n \n                         elsif Is_Out_Of_Range\n-                                (Low_Bound (Opnd_Range), Etype (Targ_Index))\n+                                (Low_Bound (Opnd_Range), Etype (Targ_Index),\n+                                 Assume_Valid => True)\n                           or else\n                               Is_Out_Of_Range\n-                                (High_Bound (Opnd_Range), Etype (Targ_Index))\n+                                (High_Bound (Opnd_Range), Etype (Targ_Index),\n+                                 Assume_Valid => True)\n                         then\n                            Add_Check\n                              (Compile_Time_Constraint_Error"}, {"sha": "1b88dc10201022e9921cb09d01a199dd08fc2768", "filename": "gcc/ada/checks.ads", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c800f862877b728756eb0a41c6ed12cf1fdc3c45/gcc%2Fada%2Fchecks.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c800f862877b728756eb0a41c6ed12cf1fdc3c45/gcc%2Fada%2Fchecks.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.ads?ref=c800f862877b728756eb0a41c6ed12cf1fdc3c45", "patch": "@@ -184,10 +184,11 @@ package Checks is\n    --  to make sure that the universal result is in range.\n \n    procedure Determine_Range\n-     (N  : Node_Id;\n-      OK : out Boolean;\n-      Lo : out Uint;\n-      Hi : out Uint);\n+     (N            : Node_Id;\n+      OK           : out Boolean;\n+      Lo           : out Uint;\n+      Hi           : out Uint;\n+      Assume_Valid : Boolean := False);\n    --  N is a node for a subexpression. If N is of a discrete type with no\n    --  error indications, and no other peculiarities (e.g. missing type\n    --  fields), then OK is True on return, and Lo and Hi are set to a\n@@ -197,7 +198,10 @@ package Checks is\n    --  type, or some kind of error condition is detected, then OK is False on\n    --  exit, and Lo/Hi are set to No_Uint. Thus the significance of OK being\n    --  False on return is that no useful information is available on the range\n-   --  of the expression.\n+   --  of the expression. Assume_Valid determines whether the processing is\n+   --  allowed to assume that values are in range of their subtypes. If it is\n+   --  set to True, then this assumption is valid, if False, then processing\n+   --  is done using base types to allow invalid values.\n \n    procedure Install_Null_Excluding_Check (N : Node_Id);\n    --  Determines whether an access node requires a runtime access check and"}, {"sha": "6f122f6c27f4e1c0596166c135c4033aef4e4619", "filename": "gcc/ada/errout.adb", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c800f862877b728756eb0a41c6ed12cf1fdc3c45/gcc%2Fada%2Ferrout.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c800f862877b728756eb0a41c6ed12cf1fdc3c45/gcc%2Fada%2Ferrout.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ferrout.adb?ref=c800f862877b728756eb0a41c6ed12cf1fdc3c45", "patch": "@@ -1090,15 +1090,19 @@ package body Errout is\n             return;\n          end if;\n \n-         --  Suppress if inside loop that is known to be null\n+         --  Suppress if inside loop that is known to be null or is probably\n+         --  null (case where loop executes only if invalid values present).\n+         --  In either case warnings in the loop are likely to be junk.\n \n          declare\n             P : Node_Id;\n \n          begin\n             P := Parent (N);\n             while Present (P) loop\n-               if Nkind (P) = N_Loop_Statement and then Is_Null_Loop (P) then\n+               if Nkind (P) = N_Loop_Statement\n+                 and then Suppress_Loop_Warnings (P)\n+               then\n                   return;\n                end if;\n "}, {"sha": "f924214bfab98adb7157a2f0d12bde39e337ba46", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 125, "deletions": 34, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c800f862877b728756eb0a41c6ed12cf1fdc3c45/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c800f862877b728756eb0a41c6ed12cf1fdc3c45/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=c800f862877b728756eb0a41c6ed12cf1fdc3c45", "patch": "@@ -3826,16 +3826,17 @@ package body Exp_Ch4 is\n             Lo_Orig : constant Node_Id := Original_Node (Lo);\n             Hi_Orig : constant Node_Id := Original_Node (Hi);\n \n-            Lcheck : constant Compare_Result :=\n-                       Compile_Time_Compare (Lop, Lo, Assume_Valid => True);\n-            Ucheck : constant Compare_Result :=\n-                       Compile_Time_Compare (Lop, Hi, Assume_Valid => True);\n+            Lcheck : Compare_Result;\n+            Ucheck : Compare_Result;\n \n             Warn1 : constant Boolean :=\n                       Constant_Condition_Warnings\n-                        and then Comes_From_Source (N);\n+                        and then Comes_From_Source (N)\n+                        and then not In_Instance;\n             --  This must be true for any of the optimization warnings, we\n             --  clearly want to give them only for source with the flag on.\n+            --  We also skip these warnings in an instance since it may be\n+            --  the case that different instantiations have different ranges.\n \n             Warn2 : constant Boolean :=\n                       Warn1\n@@ -3893,12 +3894,15 @@ package body Exp_Ch4 is\n             --  If we have an explicit range, do a bit of optimization based\n             --  on range analysis (we may be able to kill one or both checks).\n \n+            Lcheck := Compile_Time_Compare (Lop, Lo, Assume_Valid => False);\n+            Ucheck := Compile_Time_Compare (Lop, Hi, Assume_Valid => False);\n+\n             --  If either check is known to fail, replace result by False since\n             --  the other check does not matter. Preserve the static flag for\n             --  legality checks, because we are constant-folding beyond RM 4.9.\n \n             if Lcheck = LT or else Ucheck = GT then\n-               if Warn1 and then not In_Instance then\n+               if Warn1 then\n                   Error_Msg_N (\"?range test optimized away\", N);\n                   Error_Msg_N (\"\\?value is known to be out of range\", N);\n                end if;\n@@ -3914,7 +3918,7 @@ package body Exp_Ch4 is\n             --  since we know we are in range.\n \n             elsif Lcheck in Compare_GE and then Ucheck in Compare_LE then\n-               if Warn1 and then not In_Instance then\n+               if Warn1 then\n                   Error_Msg_N (\"?range test optimized away\", N);\n                   Error_Msg_N (\"\\?value is known to be in range\", N);\n                end if;\n@@ -3962,6 +3966,41 @@ package body Exp_Ch4 is\n \n                return;\n             end if;\n+\n+            --  We couldn't optimize away the range check, but there is one\n+            --  more issue. If we are checking constant conditionals, then we\n+            --  see if we can determine the outcome assuming everything is\n+            --  valid, and if so give an appropriate warning.\n+\n+            if Warn1 and then not Assume_No_Invalid_Values then\n+               Lcheck := Compile_Time_Compare (Lop, Lo, Assume_Valid => True);\n+               Ucheck := Compile_Time_Compare (Lop, Hi, Assume_Valid => True);\n+\n+               --  Result is out of range for valid value\n+\n+               if Lcheck = LT or else Ucheck = GT then\n+                  Error_Msg_N\n+                    (\"?value can only be in range if it is invalid\", N);\n+\n+               --  Result is in range for valid value\n+\n+               elsif Lcheck in Compare_GE and then Ucheck in Compare_LE then\n+                  Error_Msg_N\n+                    (\"?value can only be out of range if it is invalid\", N);\n+\n+               --  Lower bound check succeeds if value is valid\n+\n+               elsif Warn2 and then Lcheck in Compare_GE then\n+                  Error_Msg_N\n+                    (\"?lower bound check only fails if it is invalid\", Lo);\n+\n+               --  Upper bound  check succeeds if value is valid\n+\n+               elsif Warn2 and then Ucheck in Compare_LE then\n+                  Error_Msg_N\n+                    (\"?upper bound check only fails for invalid values\", Hi);\n+               end if;\n+            end if;\n          end;\n \n          --  For all other cases of an explicit range, nothing to be done\n@@ -3998,7 +4037,8 @@ package body Exp_Ch4 is\n \n             --  If type is scalar type, rewrite as x in t'first .. t'last.\n             --  This reason we do this is that the bounds may have the wrong\n-            --  type if they come from the original type definition.\n+            --  type if they come from the original type definition. Also this\n+            --  way we get all the processing above for an explicit range.\n \n             elsif Is_Scalar_Type (Typ) then\n                Rewrite (Rop,\n@@ -9013,6 +9053,13 @@ package body Exp_Ch4 is\n    ------------------------\n \n    procedure Rewrite_Comparison (N : Node_Id) is\n+      Warning_Generated : Boolean := False;\n+      --  Set to True if first pass with Assume_Valid generates a warning in\n+      --  which case we skip the second pass to avoid warning overloaded.\n+\n+      Result : Node_Id;\n+      --  Set to Standard_True or Standard_False\n+\n    begin\n       if Nkind (N) = N_Type_Conversion then\n          Rewrite_Comparison (Expression (N));\n@@ -9022,20 +9069,29 @@ package body Exp_Ch4 is\n          return;\n       end if;\n \n-      declare\n-         Typ : constant Entity_Id := Etype (N);\n-         Op1 : constant Node_Id   := Left_Opnd (N);\n-         Op2 : constant Node_Id   := Right_Opnd (N);\n+      --  Now start looking at the comparison in detail. We potentially go\n+      --  through this loop twice. The first time, Assume_Valid is set False\n+      --  in the call to Compile_Time_Compare. If this call results in a\n+      --  clear result of always True or Always False, that's decisive and\n+      --  we are done. Otherwise we repeat the processing with Assume_Valid\n+      --  set to True to generate additional warnings. We can stil that step\n+      --  if Constant_Condition_Warnings is False.\n+\n+      for AV in False .. True loop\n+         declare\n+            Typ : constant Entity_Id := Etype (N);\n+            Op1 : constant Node_Id   := Left_Opnd (N);\n+            Op2 : constant Node_Id   := Right_Opnd (N);\n \n-         Res : constant Compare_Result :=\n-                 Compile_Time_Compare (Op1, Op2, Assume_Valid => True);\n-         --  Res indicates if compare outcome can be compile time determined\n+            Res : constant Compare_Result :=\n+                    Compile_Time_Compare (Op1, Op2, Assume_Valid => AV);\n+            --  Res indicates if compare outcome can be compile time determined\n \n-         True_Result  : Boolean;\n-         False_Result : Boolean;\n+            True_Result  : Boolean;\n+            False_Result : Boolean;\n \n-      begin\n-         case N_Op_Compare (Nkind (N)) is\n+         begin\n+            case N_Op_Compare (Nkind (N)) is\n             when N_Op_Eq =>\n                True_Result  := Res = EQ;\n                False_Result := Res = LT or else Res = GT or else Res = NE;\n@@ -9054,6 +9110,7 @@ package body Exp_Ch4 is\n                then\n                   Error_Msg_N\n                     (\"can never be greater than, could replace by \"\"'=\"\"?\", N);\n+                  Warning_Generated := True;\n                end if;\n \n             when N_Op_Gt =>\n@@ -9078,28 +9135,62 @@ package body Exp_Ch4 is\n                then\n                   Error_Msg_N\n                     (\"can never be less than, could replace by \"\"'=\"\"?\", N);\n+                  Warning_Generated := True;\n                end if;\n \n             when N_Op_Ne =>\n                True_Result  := Res = NE or else Res = GT or else Res = LT;\n                False_Result := Res = EQ;\n-         end case;\n+            end case;\n \n-         if True_Result then\n-            Rewrite (N,\n-              Convert_To (Typ,\n-                New_Occurrence_Of (Standard_True, Sloc (N))));\n-            Analyze_And_Resolve (N, Typ);\n-            Warn_On_Known_Condition (N);\n+            --  If this is the first iteration, then we actually convert the\n+            --  comparison into True or False, if the result is certain.\n \n-         elsif False_Result then\n-            Rewrite (N,\n-              Convert_To (Typ,\n-                New_Occurrence_Of (Standard_False, Sloc (N))));\n-            Analyze_And_Resolve (N, Typ);\n-            Warn_On_Known_Condition (N);\n-         end if;\n-      end;\n+            if AV = False then\n+               if True_Result or False_Result then\n+                  if True_Result then\n+                     Result := Standard_True;\n+                  else\n+                     Result := Standard_False;\n+                  end if;\n+\n+                  Rewrite (N,\n+                    Convert_To (Typ,\n+                      New_Occurrence_Of (Result, Sloc (N))));\n+                  Analyze_And_Resolve (N, Typ);\n+                  Warn_On_Known_Condition (N);\n+                  return;\n+               end if;\n+\n+            --  If this is the second iteration (AV = True), and the original\n+            --  node comes from source and we are not in an instance, then\n+            --  give a warning if we know result would be True or False. Note\n+            --  we know Constant_Condition_Warnings is set if we get here.\n+\n+            elsif Comes_From_Source (Original_Node (N))\n+              and then not In_Instance\n+            then\n+               if True_Result then\n+                  Error_Msg_N\n+                    (\"condition can only be False if invalid values present?\",\n+                     N);\n+               elsif False_Result then\n+                  Error_Msg_N\n+                    (\"condition can only be True if invalid values present?\",\n+                     N);\n+               end if;\n+            end if;\n+         end;\n+\n+         --  Skip second iteration if not warning on constant conditions or\n+         --  if the first iteration already generated a warning of some kind\n+         --  or if we are in any case assuming all values are valid (so that\n+         --  the first iteration took care of the valid case).\n+\n+         exit when not Constant_Condition_Warnings;\n+         exit when Warning_Generated;\n+         exit when Assume_No_Invalid_Values;\n+      end loop;\n    end Rewrite_Comparison;\n \n    ----------------------------"}, {"sha": "4305887cff6f41553e1298df3a38a17d03709d99", "filename": "gcc/ada/exp_ch5.adb", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c800f862877b728756eb0a41c6ed12cf1fdc3c45/gcc%2Fada%2Fexp_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c800f862877b728756eb0a41c6ed12cf1fdc3c45/gcc%2Fada%2Fexp_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch5.adb?ref=c800f862877b728756eb0a41c6ed12cf1fdc3c45", "patch": "@@ -3306,20 +3306,32 @@ package body Exp_Ch5 is\n    -- Expand_N_Loop_Statement --\n    -----------------------------\n \n-   --  1. Deal with while condition for C/Fortran boolean\n-   --  2. Deal with loops with a non-standard enumeration type range\n-   --  3. Deal with while loops where Condition_Actions is set\n-   --  4. Insert polling call if required\n+   --  1. Remove null loop entirely\n+   --  2. Deal with while condition for C/Fortran boolean\n+   --  3. Deal with loops with a non-standard enumeration type range\n+   --  4. Deal with while loops where Condition_Actions is set\n+   --  5. Insert polling call if required\n \n    procedure Expand_N_Loop_Statement (N : Node_Id) is\n       Loc  : constant Source_Ptr := Sloc (N);\n       Isc  : constant Node_Id    := Iteration_Scheme (N);\n \n    begin\n+      --  Delete null loop\n+\n+      if Is_Null_Loop (N) then\n+         Rewrite (N, Make_Null_Statement (Loc));\n+         return;\n+      end if;\n+\n+      --  Deal with condition for C/Fortran Boolean\n+\n       if Present (Isc) then\n          Adjust_Condition (Condition (Isc));\n       end if;\n \n+      --  Generate polling call\n+\n       if Is_Non_Empty_List (Statements (N)) then\n          Generate_Poll_Call (First (Statements (N)));\n       end if;"}, {"sha": "78cca2843e4acc98bce702ba20b23cedb56a474c", "filename": "gcc/ada/gnat_ugn.texi", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c800f862877b728756eb0a41c6ed12cf1fdc3c45/gcc%2Fada%2Fgnat_ugn.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c800f862877b728756eb0a41c6ed12cf1fdc3c45/gcc%2Fada%2Fgnat_ugn.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_ugn.texi?ref=c800f862877b728756eb0a41c6ed12cf1fdc3c45", "patch": "@@ -3867,6 +3867,10 @@ it will be ignored.\n @cindex @option{-gnatb} (@command{gcc})\n Generate brief messages to @file{stderr} even if verbose mode set.\n \n+@item -gnatB\n+@cindex @option{-gnatB} (@command{gcc})\n+Assume no invalid (bad) values except for 'Valid attribute use.\n+\n @item -gnatc\n @cindex @option{-gnatc} (@command{gcc})\n Check syntax and semantics only (no code generation attempted).\n@@ -5586,6 +5590,12 @@ statements (where a wild jump might result from an invalid value),\n and subscripts on the left hand side (where memory corruption could\n occur as a result of an invalid value).\n \n+The @option{-gnatB} switch tells the compiler to assume that all\n+values are valid (that is, within their declared subtype range)\n+except in the context of a use of the Valid attribute. This means\n+the compiler can generate more efficient code, since the range\n+of values is better known at compile time.\n+\n The @option{-gnatV^@var{x}^^} switch allows more control over the validity\n checking mode.\n @ifclear vms"}, {"sha": "810f4d5c8138c9cc27a6b878719bea1f411503bf", "filename": "gcc/ada/opt.ads", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c800f862877b728756eb0a41c6ed12cf1fdc3c45/gcc%2Fada%2Fopt.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c800f862877b728756eb0a41c6ed12cf1fdc3c45/gcc%2Fada%2Fopt.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fopt.ads?ref=c800f862877b728756eb0a41c6ed12cf1fdc3c45", "patch": "@@ -158,14 +158,14 @@ package Opt is\n    --  GNAT\n    --  Enable assertions made using pragma Assert\n \n-   Assume_No_Invalid_Values : Boolean := True;\n-   --  ??? true for now, enable by setting to false later\n+   Assume_No_Invalid_Values : Boolean := False;\n    --  GNAT\n    --  Normally, in accordance with (RM 13.9.1 (9-11)) the front end assumes\n    --  that values could have invalid representations, unless it can clearly\n    --  prove that the values are valid. If this switch is set (by -gnatB or by\n    --  pragma Assume_No_Invalid_Values (Off)), then the compiler assumes values\n-   --  are valid and in range of their representations.\n+   --  are valid and in range of their representations. This feature is now\n+   --  fully enabled in the compiler.\n \n    Back_Annotate_Rep_Info : Boolean := False;\n    --  GNAT"}, {"sha": "fd72ba080d59b993196878669574d4c2c68d5958", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c800f862877b728756eb0a41c6ed12cf1fdc3c45/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c800f862877b728756eb0a41c6ed12cf1fdc3c45/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=c800f862877b728756eb0a41c6ed12cf1fdc3c45", "patch": "@@ -4840,7 +4840,7 @@ package body Sem_Attr is\n \n          --  Check that result is in bounds of the type if it is static\n \n-         if Is_In_Range (N, T) then\n+         if Is_In_Range (N, T, Assume_Valid => False) then\n             null;\n \n          elsif Is_Out_Of_Range (N, T) then"}, {"sha": "888ac0222adacd112071b4e4c3783ae927122b10", "filename": "gcc/ada/sem_ch5.adb", "status": "modified", "additions": 42, "deletions": 29, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c800f862877b728756eb0a41c6ed12cf1fdc3c45/gcc%2Fada%2Fsem_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c800f862877b728756eb0a41c6ed12cf1fdc3c45/gcc%2Fada%2Fsem_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch5.adb?ref=c800f862877b728756eb0a41c6ed12cf1fdc3c45", "patch": "@@ -1843,23 +1843,12 @@ package body Sem_Ch5 is\n                         L : constant Node_Id := Low_Bound  (DS);\n                         H : constant Node_Id := High_Bound (DS);\n \n-                        Llo : Uint;\n-                        Lhi : Uint;\n-                        LOK : Boolean;\n-                        Hlo : Uint;\n-                        Hhi : Uint;\n-                        HOK : Boolean;\n-\n-                        pragma Warnings (Off, Hlo);\n-\n                      begin\n-                        Determine_Range (L, LOK, Llo, Lhi);\n-                        Determine_Range (H, HOK, Hlo, Hhi);\n-\n                         --  If range of loop is null, issue warning\n \n-                        if (LOK and HOK) and then Llo > Hhi then\n-\n+                        if Compile_Time_Compare\n+                            (L, H, Assume_Valid => True) = GT\n+                        then\n                            --  Suppress the warning if inside a generic\n                            --  template or instance, since in practice\n                            --  they tend to be dubious in these cases since\n@@ -1868,21 +1857,46 @@ package body Sem_Ch5 is\n                            if not Inside_A_Generic\n                               and then not In_Instance\n                            then\n-                              Error_Msg_N\n-                                (\"?loop range is null, loop will not execute\",\n-                                 DS);\n+                              --  Specialize msg if invalid values could make\n+                              --  the loop non-null after all.\n+\n+                              if Compile_Time_Compare\n+                                   (L, H, Assume_Valid => False) = GT\n+                              then\n+                                 Error_Msg_N\n+                                   (\"?loop range is null, \"\n+                                    & \"loop will not execute\",\n+                                    DS);\n+\n+                                 --  Since we know the range of the loop is\n+                                 --  null, set the appropriate flag to remove\n+                                 --  the loop entirely during expansion.\n+\n+                                 Set_Is_Null_Loop (Parent (N));\n+\n+                              --  Here is where the loop could execute because\n+                              --  of invalid values, so issue appropriate\n+                              --  message and in this case we do not set the\n+                              --  Is_Null_Loop flag since the loop may execute.\n+\n+                              else\n+                                 Error_Msg_N\n+                                   (\"?loop range may be null, \"\n+                                    & \"loop may not execute\",\n+                                    DS);\n+                                 Error_Msg_N\n+                                   (\"?can only execute if invalid values \"\n+                                    & \"are present\",\n+                                    DS);\n+                              end if;\n                            end if;\n \n-                           --  Since we know the range of the loop is null,\n-                           --  set the appropriate flag to suppress any\n-                           --  warnings that would otherwise be issued in\n-                           --  the body of the loop that will not execute.\n-                           --  We do this even in the generic case, since\n-                           --  if it is dubious to warn on the null loop\n-                           --  itself, it is certainly dubious to warn for\n-                           --  conditions that occur inside it!\n+                           --  In either case, suppress warnings in the body of\n+                           --  the loop, since it is likely that these warnings\n+                           --  will be inappropriate if the loop never actually\n+                           --  executes, which is unlikely.\n \n-                           Set_Is_Null_Loop (Parent (N));\n+                           Set_Suppress_Loop_Warnings (Parent (N));\n \n                         --  The other case for a warning is a reverse loop\n                         --  where the upper bound is the integer literal\n@@ -1898,10 +1912,9 @@ package body Sem_Ch5 is\n                         elsif Reverse_Present (LP)\n                           and then Nkind (Original_Node (H)) =\n                                                           N_Integer_Literal\n-                          and then (Intval (H) = Uint_0\n+                          and then (Intval (Original_Node (H)) = Uint_0\n                                       or else\n-                                    Intval (H) = Uint_1)\n-                          and then Lhi > Hhi\n+                                    Intval (Original_Node (H)) = Uint_1)\n                         then\n                            Error_Msg_N (\"?loop range may be null\", DS);\n                            Error_Msg_N (\"\\?bounds may be wrong way round\", DS);"}, {"sha": "2d3e2cb6e7281e212640b9032d8382bd49278acd", "filename": "gcc/ada/sem_eval.adb", "status": "modified", "additions": 107, "deletions": 33, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c800f862877b728756eb0a41c6ed12cf1fdc3c45/gcc%2Fada%2Fsem_eval.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c800f862877b728756eb0a41c6ed12cf1fdc3c45/gcc%2Fada%2Fsem_eval.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_eval.adb?ref=c800f862877b728756eb0a41c6ed12cf1fdc3c45", "patch": "@@ -241,7 +241,7 @@ package body Sem_Eval is\n \n       if not Is_Static_Expression (N) then\n          if Is_Floating_Point_Type (T)\n-           and then Is_Out_Of_Range (N, Base_Type (T))\n+           and then Is_Out_Of_Range (N, Base_Type (T), Assume_Valid => True)\n          then\n             Error_Msg_N\n               (\"?float value out of range, infinity will be generated\", N);\n@@ -271,7 +271,7 @@ package body Sem_Eval is\n          --  number, so as not to lose case where value overflows in the\n          --  least significant bit or less. See B490001.\n \n-         if Is_Out_Of_Range (N, Base_Type (T)) then\n+         if Is_Out_Of_Range (N, Base_Type (T), Assume_Valid => True) then\n             Out_Of_Range (N);\n             return;\n          end if;\n@@ -325,21 +325,21 @@ package body Sem_Eval is\n \n       --  Check out of range of base type\n \n-      elsif Is_Out_Of_Range (N, Base_Type (T)) then\n+      elsif Is_Out_Of_Range (N, Base_Type (T), Assume_Valid => True) then\n          Out_Of_Range (N);\n \n-      --  Give warning if outside subtype (where one or both of the\n-      --  bounds of the subtype is static). This warning is omitted\n-      --  if the expression appears in a range that could be null\n-      --  (warnings are handled elsewhere for this case).\n+      --  Give warning if outside subtype (where one or both of the bounds of\n+      --  the subtype is static). This warning is omitted if the expression\n+      --  appears in a range that could be null (warnings are handled elsewhere\n+      --  for this case).\n \n       elsif T /= Base_Type (T)\n         and then Nkind (Parent (N)) /= N_Range\n       then\n-         if Is_In_Range (N, T) then\n+         if Is_In_Range (N, T, Assume_Valid => True) then\n             null;\n \n-         elsif Is_Out_Of_Range (N, T) then\n+         elsif Is_Out_Of_Range (N, T, Assume_Valid => True) then\n             Apply_Compile_Time_Constraint_Error\n               (N, \"value not in range of}?\", CE_Range_Check_Failed);\n \n@@ -574,16 +574,17 @@ package body Sem_Eval is\n \n       begin\n          --  Values are the same if they refer to the same entity and the\n-         --  entity is a constant object (E_Constant). This does not however\n-         --  apply to Float types, since we may have two NaN values and they\n-         --  should never compare equal.\n+         --  entity is non-volatile. This does not however apply to Float\n+         --  types, since we may have two NaN values and they should never\n+         --  compare equal.\n \n          if Nkind_In (Lf, N_Identifier, N_Expanded_Name)\n            and then Nkind_In (Rf, N_Identifier, N_Expanded_Name)\n            and then Entity (Lf) = Entity (Rf)\n            and then Present (Entity (Lf))\n            and then not Is_Floating_Point_Type (Etype (L))\n-           and then Is_Constant_Object (Entity (Lf))\n+           and then not Is_Volatile_Reference (L)\n+           and then not Is_Volatile_Reference (R)\n          then\n             return True;\n \n@@ -748,7 +749,7 @@ package body Sem_Eval is\n          --  not known to have valid representations. This takes care of\n          --  properly dealing with invalid representations.\n \n-         if not Assume_Valid then\n+         if not Assume_Valid and then not Assume_No_Invalid_Values then\n             if Is_Entity_Name (L) and then not Is_Known_Valid (Entity (L)) then\n                Ltyp := Base_Type (Ltyp);\n             end if;\n@@ -758,6 +759,39 @@ package body Sem_Eval is\n             end if;\n          end if;\n \n+         --  Try range analysis on variables and see if ranges are disjoint\n+\n+         declare\n+            LOK, ROK : Boolean;\n+            LLo, LHi : Uint;\n+            RLo, RHi : Uint;\n+\n+         begin\n+            Determine_Range (L, LOK, LLo, LHi, Assume_Valid);\n+            Determine_Range (R, ROK, RLo, RHi, Assume_Valid);\n+\n+            if LOK and ROK then\n+               if LHi < RLo then\n+                  return LT;\n+\n+               elsif RHi < LLo then\n+                  return GT;\n+\n+               elsif LLo = LHi\n+                 and then RLo = RHi\n+                 and then LLo = RLo\n+               then\n+                  return EQ;\n+\n+               elsif LHi = RLo then\n+                  return LE;\n+\n+               elsif RHi = LLo then\n+                  return GE;\n+               end if;\n+            end if;\n+         end;\n+\n          --  Here is where we check for comparisons against maximum bounds of\n          --  types, where we know that no value can be outside the bounds of\n          --  the subtype. Note that this routine is allowed to assume that all\n@@ -1812,7 +1846,7 @@ package body Sem_Eval is\n       --  Modular integer literals must be in their base range\n \n       if Is_Modular_Integer_Type (T)\n-        and then Is_Out_Of_Range (N, Base_Type (T))\n+        and then Is_Out_Of_Range (N, Base_Type (T), Assume_Valid => True)\n       then\n          Out_Of_Range (N);\n       end if;\n@@ -2276,7 +2310,7 @@ package body Sem_Eval is\n \n       Set_Is_Static_Expression (N, Stat);\n \n-      if Is_Out_Of_Range (N, Etype (N)) then\n+      if Is_Out_Of_Range (N, Etype (N), Assume_Valid => True) then\n          Out_Of_Range (N);\n       end if;\n    end Eval_Qualified_Expression;\n@@ -2998,7 +3032,7 @@ package body Sem_Eval is\n          Fold_Uint (N, Expr_Value (Operand), Stat);\n       end if;\n \n-      if Is_Out_Of_Range (N, Etype (N)) then\n+      if Is_Out_Of_Range (N, Etype (N), Assume_Valid => True) then\n          Out_Of_Range (N);\n       end if;\n \n@@ -3610,10 +3644,11 @@ package body Sem_Eval is\n    -----------------\n \n    function Is_In_Range\n-     (N         : Node_Id;\n-      Typ       : Entity_Id;\n-      Fixed_Int : Boolean := False;\n-      Int_Real  : Boolean := False) return Boolean\n+     (N            : Node_Id;\n+      Typ          : Entity_Id;\n+      Assume_Valid : Boolean := False;\n+      Fixed_Int    : Boolean := False;\n+      Int_Real     : Boolean := False) return Boolean\n    is\n       Val  : Uint;\n       Valr : Ureal;\n@@ -3635,19 +3670,38 @@ package body Sem_Eval is\n       elsif not Compile_Time_Known_Value (N) then\n          return False;\n \n+      --  General processing with a known compile time value\n+\n       else\n          declare\n-            Lo       : constant Node_Id := Type_Low_Bound  (Typ);\n-            Hi       : constant Node_Id := Type_High_Bound (Typ);\n-            LB_Known : constant Boolean := Compile_Time_Known_Value (Lo);\n-            UB_Known : constant Boolean := Compile_Time_Known_Value (Hi);\n+            Lo       : Node_Id;\n+            Hi       : Node_Id;\n+            LB_Known : Boolean;\n+            UB_Known : Boolean;\n+            Typt     : Entity_Id;\n \n          begin\n+            if Assume_Valid\n+              or else Assume_No_Invalid_Values\n+              or else (Is_Entity_Name (N)\n+                        and then Is_Known_Valid (Entity (N)))\n+            then\n+               Typt := Typ;\n+            else\n+               Typt := Underlying_Type (Base_Type (Typ));\n+            end if;\n+\n+            Lo := Type_Low_Bound  (Typt);\n+            Hi := Type_High_Bound (Typt);\n+\n+            LB_Known := Compile_Time_Known_Value (Lo);\n+            UB_Known := Compile_Time_Known_Value (Hi);\n+\n             --  Fixed point types should be considered as such only in\n             --  flag Fixed_Int is set to False.\n \n-            if Is_Floating_Point_Type (Typ)\n-              or else (Is_Fixed_Point_Type (Typ) and then not Fixed_Int)\n+            if Is_Floating_Point_Type (Typt)\n+              or else (Is_Fixed_Point_Type (Typt) and then not Fixed_Int)\n               or else Int_Real\n             then\n                Valr := Expr_Value_R (N);\n@@ -3792,6 +3846,7 @@ package body Sem_Eval is\n    function Is_Out_Of_Range\n      (N            : Node_Id;\n       Typ          : Entity_Id;\n+      Assume_Valid : Boolean := False;\n       Fixed_Int    : Boolean := False;\n       Int_Real     : Boolean := False) return Boolean\n    is\n@@ -3826,18 +3881,37 @@ package body Sem_Eval is\n \n       else\n          declare\n-            Lo       : constant Node_Id := Type_Low_Bound  (Typ);\n-            Hi       : constant Node_Id := Type_High_Bound (Typ);\n-            LB_Known : constant Boolean := Compile_Time_Known_Value (Lo);\n-            UB_Known : constant Boolean := Compile_Time_Known_Value (Hi);\n+            Lo       : Node_Id;\n+            Hi       : Node_Id;\n+            LB_Known : Boolean;\n+            UB_Known : Boolean;\n+            Typt     : Entity_Id;\n \n          begin\n+            --  Go to base type if we could have invalid values\n+\n+            if Assume_Valid\n+              or else Assume_No_Invalid_Values\n+              or else (Is_Entity_Name (N)\n+                        and then Is_Known_Valid (Entity (N)))\n+            then\n+               Typt := Typ;\n+            else\n+               Typt := Underlying_Type (Base_Type (Typ));\n+            end if;\n+\n+            Lo := Type_Low_Bound (Typt);\n+            Hi := Type_High_Bound (Typt);\n+\n+            LB_Known := Compile_Time_Known_Value (Lo);\n+            UB_Known := Compile_Time_Known_Value (Hi);\n+\n             --  Real types (note that fixed-point types are not treated\n             --  as being of a real type if the flag Fixed_Int is set,\n             --  since in that case they are regarded as integer types).\n \n-            if Is_Floating_Point_Type (Typ)\n-              or else (Is_Fixed_Point_Type (Typ) and then not Fixed_Int)\n+            if Is_Floating_Point_Type (Typt)\n+              or else (Is_Fixed_Point_Type (Typt) and then not Fixed_Int)\n               or else Int_Real\n             then\n                Valr := Expr_Value_R (N);"}, {"sha": "97b0967d67e5791b5811a1b6f3e29919c369957b", "filename": "gcc/ada/sem_eval.ads", "status": "modified", "additions": 16, "deletions": 10, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c800f862877b728756eb0a41c6ed12cf1fdc3c45/gcc%2Fada%2Fsem_eval.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c800f862877b728756eb0a41c6ed12cf1fdc3c45/gcc%2Fada%2Fsem_eval.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_eval.ads?ref=c800f862877b728756eb0a41c6ed12cf1fdc3c45", "patch": "@@ -327,10 +327,11 @@ package Sem_Eval is\n    --  known at compile time but not static, then the result is not static.\n \n    function Is_In_Range\n-     (N         : Node_Id;\n-      Typ       : Entity_Id;\n-      Fixed_Int : Boolean := False;\n-      Int_Real  : Boolean := False) return Boolean;\n+     (N            : Node_Id;\n+      Typ          : Entity_Id;\n+      Assume_Valid : Boolean := False;\n+      Fixed_Int    : Boolean := False;\n+      Int_Real     : Boolean := False) return Boolean;\n    --  Returns True if it can be guaranteed at compile time that expression is\n    --  known to be in range of the subtype Typ. If the values of N or of either\n    --  bounds of Type are unknown at compile time, False will always be\n@@ -345,21 +346,26 @@ package Sem_Eval is\n    --  value (i.e. the underlying integer value is used). In this case we use\n    --  the corresponding integer value, both for the bounds of Typ, and for the\n    --  value of the expression N. If Typ is a discrete type and Fixed_Int as\n-   --  well as Int_Real are false, integer values are used throughout.\n+   --  well as Int_Real are false, integer values are used throughout. The\n+   --  Assume_Valid parameter determines whether values are to be assumed to\n+   --  be valid (True), or invalid values can occur (False).\n \n    function Is_Out_Of_Range\n-     (N         : Node_Id;\n-      Typ       : Entity_Id;\n-      Fixed_Int : Boolean := False;\n-      Int_Real  : Boolean := False) return Boolean;\n+     (N            : Node_Id;\n+      Typ          : Entity_Id;\n+      Assume_Valid : Boolean := False;\n+      Fixed_Int    : Boolean := False;\n+      Int_Real     : Boolean := False) return Boolean;\n    --  Returns True if it can be guaranteed at compile time that expression is\n    --  known to be out of range of the subtype Typ. True is returned if Typ is\n    --  a scalar type, at least one of whose bounds is known at compile time,\n    --  and N is a compile time known expression which can be determined to be\n    --  outside a compile_time known bound of Typ. A result of False does not\n    --  mean that the expression is in range, but rather merely that it cannot\n    --  be determined at compile time that it is out of range. Flags Int_Real\n-   --  and Fixed_Int are used as in routine Is_In_Range above.\n+   --  and Fixed_Int are used as in routine Is_In_Range above. The Assume_Valid\n+   --  parameter determines whether values are to be assumed to be valid\n+   --  (True), or invalid values can occur (False).\n \n    function In_Subrange_Of\n      (T1           : Entity_Id;"}, {"sha": "4adaa568338e9e97f82021df630e45d4e0cc2726", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c800f862877b728756eb0a41c6ed12cf1fdc3c45/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c800f862877b728756eb0a41c6ed12cf1fdc3c45/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=c800f862877b728756eb0a41c6ed12cf1fdc3c45", "patch": "@@ -2963,7 +2963,8 @@ package body Sem_Util is\n                elsif Is_Entity_Name (Choice)\n                  and then Is_Type (Entity (Choice))\n                then\n-                  exit Search when Is_In_Range (Expr, Etype (Choice));\n+                  exit Search when Is_In_Range (Expr, Etype (Choice),\n+                                                Assume_Valid => False);\n \n                --  Choice is a subtype indication\n "}, {"sha": "6fd7da9af1285b259e718b30d9443034ba041756", "filename": "gcc/ada/sinfo.adb", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c800f862877b728756eb0a41c6ed12cf1fdc3c45/gcc%2Fada%2Fsinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c800f862877b728756eb0a41c6ed12cf1fdc3c45/gcc%2Fada%2Fsinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.adb?ref=c800f862877b728756eb0a41c6ed12cf1fdc3c45", "patch": "@@ -2623,6 +2623,14 @@ package body Sinfo is\n       return Node5 (N);\n    end Subtype_Indication;\n \n+   function Suppress_Loop_Warnings\n+      (N : Node_Id) return Boolean is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Loop_Statement);\n+      return Flag17 (N);\n+   end Suppress_Loop_Warnings;\n+\n    function Subtype_Mark\n       (N : Node_Id) return Node_Id is\n    begin\n@@ -5411,6 +5419,14 @@ package body Sinfo is\n       Set_List2_With_Parent (N, Val);\n    end Set_Subtype_Marks;\n \n+   procedure Set_Suppress_Loop_Warnings\n+      (N : Node_Id; Val : Boolean := True) is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Loop_Statement);\n+      Set_Flag17 (N, Val);\n+   end Set_Suppress_Loop_Warnings;\n+\n    procedure Set_Synchronized_Present\n      (N : Node_Id; Val : Boolean := True) is\n    begin"}, {"sha": "bf428e8541cd863f281113910b8facb2591d0d95", "filename": "gcc/ada/sinfo.ads", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c800f862877b728756eb0a41c6ed12cf1fdc3c45/gcc%2Fada%2Fsinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c800f862877b728756eb0a41c6ed12cf1fdc3c45/gcc%2Fada%2Fsinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.ads?ref=c800f862877b728756eb0a41c6ed12cf1fdc3c45", "patch": "@@ -1200,9 +1200,8 @@ package Sinfo is\n \n    --  Is_Null_Loop (Flag16-Sem)\n    --    This flag is set in an N_Loop_Statement node if the corresponding loop\n-   --    can be determined to be null at compile time. This is used to suppress\n-   --    any warnings that would otherwise be issued inside the loop since they\n-   --    are probably not useful.\n+   --    can be determined to be null at compile time. This is used to remove\n+   --    the loop entirely at expansion time.\n \n    --  Is_Overloaded (Flag5-Sem)\n    --    A flag present in all expression nodes. Used temporarily during\n@@ -1597,6 +1596,12 @@ package Sinfo is\n    --    value of a type whose size is not known at compile time on the\n    --    secondary stack.\n \n+   --  Suppress_Loop_Warnings (Flag17-Sem)\n+   --    Used in N_Loop_Statement node to indicate that warnings within the\n+   --    body of the loop should be suppressed. This is set when the range\n+   --    of a FOR loop is known to be null, or is probably null (loop would\n+   --    only execute if invalid values are present).\n+\n    --  Target_Type (Node2-Sem)\n    --    Used in an N_Validate_Unchecked_Conversion node to point to the target\n    --    type entity for the unchecked conversion instantiation which gigi must\n@@ -3940,6 +3945,7 @@ package Sinfo is\n       --  End_Label (Node4)\n       --  Has_Created_Identifier (Flag15)\n       --  Is_Null_Loop (Flag16)\n+      --  Suppress_Loop_Warnings (Flag17)\n \n       --------------------------\n       -- 5.5 Iteration Scheme --\n@@ -8252,6 +8258,9 @@ package Sinfo is\n    function Subtype_Marks\n      (N : Node_Id) return List_Id;    -- List2\n \n+   function Suppress_Loop_Warnings\n+     (N : Node_Id) return Boolean;    -- Flag17\n+\n    function Synchronized_Present\n      (N : Node_Id) return Boolean;    -- Flag7\n \n@@ -9131,6 +9140,9 @@ package Sinfo is\n    procedure Set_Subtype_Marks\n      (N : Node_Id; Val : List_Id);            -- List2\n \n+   procedure Set_Suppress_Loop_Warnings\n+     (N : Node_Id; Val : Boolean := True);    -- Flag17\n+\n    procedure Set_Synchronized_Present\n      (N : Node_Id; Val : Boolean := True);    -- Flag7\n \n@@ -11108,6 +11120,7 @@ package Sinfo is\n    pragma Inline (Subtype_Indication);\n    pragma Inline (Subtype_Mark);\n    pragma Inline (Subtype_Marks);\n+   pragma Inline (Suppress_Loop_Warnings);\n    pragma Inline (Synchronized_Present);\n    pragma Inline (Tagged_Present);\n    pragma Inline (Target_Type);\n@@ -11397,6 +11410,7 @@ package Sinfo is\n    pragma Inline (Set_Subtype_Indication);\n    pragma Inline (Set_Subtype_Mark);\n    pragma Inline (Set_Subtype_Marks);\n+   pragma Inline (Set_Suppress_Loop_Warnings);\n    pragma Inline (Set_Synchronized_Present);\n    pragma Inline (Set_Tagged_Present);\n    pragma Inline (Set_Target_Type);"}]}