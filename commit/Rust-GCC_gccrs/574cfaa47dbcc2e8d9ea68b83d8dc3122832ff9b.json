{"sha": "574cfaa47dbcc2e8d9ea68b83d8dc3122832ff9b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTc0Y2ZhYTQ3ZGJjYzJlOGQ5ZWE2OGI4M2Q4ZGMzMTIyODMyZmY5Yg==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2011-04-26T19:28:25Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2011-04-26T19:28:25Z"}, "message": "re PR c++/48530 ([C++0x][SFINAE] Hard errors with deleted d'tors)\n\n\tPR c++/48530\n\t* decl.c (cxx_maybe_build_cleanup): Add complain parm.\n\t* tree.c (force_target_expr): Add complain parm.\n\t(build_target_expr_with_type): Likewise.\n\t(get_target_expr_sfinae): Split out.\n\t(build_vec_init_expr, bot_manip): Adjust.\n\t* init.c (build_vec_delete, build_vec_delete_1): Add complain parm.\n\t(build_delete, build_dtor_call): Likewise.\n\t(perform_direct_initialization_if_possible): Adjust.\n\t(build_vec_init): Handle error return.\n\t* cvt.c (force_rvalue): Add complain parm.\n\tCall build_special_member_call directly.\n\t* decl2.c (delete_sanity): Add complain parm.\n\t(build_cleanup): Adjust.\n\t* pt.c (tsubst_copy_and_build, tsubst_expr): Adjust.\n\t* semantics.c (finish_stmt_expr_expr): Adjust.\n\t(finish_compound_literal): Adjust.\n\t* parser.c (cp_parser_delete_expression): Adjust.\n\t* typeck2.c (build_functional_cast): Adjust.\n\t* cp-tree.h: Adjust.\n\nFrom-SVN: r172985", "tree": {"sha": "e83e77854b5490319145c8e64a21bec89b47616f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e83e77854b5490319145c8e64a21bec89b47616f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/574cfaa47dbcc2e8d9ea68b83d8dc3122832ff9b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/574cfaa47dbcc2e8d9ea68b83d8dc3122832ff9b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/574cfaa47dbcc2e8d9ea68b83d8dc3122832ff9b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/574cfaa47dbcc2e8d9ea68b83d8dc3122832ff9b/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5a87ca71c875b5bc34b9b8bc0ef405cec9b51b51", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a87ca71c875b5bc34b9b8bc0ef405cec9b51b51", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5a87ca71c875b5bc34b9b8bc0ef405cec9b51b51"}], "stats": {"total": 351, "additions": 240, "deletions": 111}, "files": [{"sha": "fba4a032d51ea4b6973e193a9027dbaa7f4e82a0", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/574cfaa47dbcc2e8d9ea68b83d8dc3122832ff9b/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/574cfaa47dbcc2e8d9ea68b83d8dc3122832ff9b/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=574cfaa47dbcc2e8d9ea68b83d8dc3122832ff9b", "patch": "@@ -1,3 +1,26 @@\n+2011-04-26  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/48530\n+\t* decl.c (cxx_maybe_build_cleanup): Add complain parm.\n+\t* tree.c (force_target_expr): Add complain parm.\n+\t(build_target_expr_with_type): Likewise.\n+\t(get_target_expr_sfinae): Split out.\n+\t(build_vec_init_expr, bot_manip): Adjust.\n+\t* init.c (build_vec_delete, build_vec_delete_1): Add complain parm.\n+\t(build_delete, build_dtor_call): Likewise.\n+\t(perform_direct_initialization_if_possible): Adjust.\n+\t(build_vec_init): Handle error return.\n+\t* cvt.c (force_rvalue): Add complain parm.\n+\tCall build_special_member_call directly.\n+\t* decl2.c (delete_sanity): Add complain parm.\n+\t(build_cleanup): Adjust.\n+\t* pt.c (tsubst_copy_and_build, tsubst_expr): Adjust.\n+\t* semantics.c (finish_stmt_expr_expr): Adjust.\n+\t(finish_compound_literal): Adjust.\n+\t* parser.c (cp_parser_delete_expression): Adjust.\n+\t* typeck2.c (build_functional_cast): Adjust.\n+\t* cp-tree.h: Adjust.\n+\n 2011-04-26  Martin Jambor  <mjambor@suse.cz>\n \n \t* class.c (cp_fold_obj_type_ref): Remove."}, {"sha": "10efd1cdfdcda245cfdd2af81744817db67a4cf5", "filename": "gcc/cp/call.c", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/574cfaa47dbcc2e8d9ea68b83d8dc3122832ff9b/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/574cfaa47dbcc2e8d9ea68b83d8dc3122832ff9b/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=574cfaa47dbcc2e8d9ea68b83d8dc3122832ff9b", "patch": "@@ -4144,15 +4144,23 @@ build_conditional_expr (tree arg1, tree arg2, tree arg3,\n \t  && TREE_CODE (arg3) != THROW_EXPR)\n \t{\n \t  if (!VOID_TYPE_P (arg3_type))\n-\t    arg3 = force_rvalue (arg3);\n+\t    {\n+\t      arg3 = force_rvalue (arg3, complain);\n+\t      if (arg3 == error_mark_node)\n+\t\treturn error_mark_node;\n+\t    }\n \t  arg3_type = TREE_TYPE (arg3);\n \t  result_type = arg3_type;\n \t}\n       else if (TREE_CODE (arg2) != THROW_EXPR\n \t       && TREE_CODE (arg3) == THROW_EXPR)\n \t{\n \t  if (!VOID_TYPE_P (arg2_type))\n-\t    arg2 = force_rvalue (arg2);\n+\t    {\n+\t      arg2 = force_rvalue (arg2, complain);\n+\t      if (arg2 == error_mark_node)\n+\t\treturn error_mark_node;\n+\t    }\n \t  arg2_type = TREE_TYPE (arg2);\n \t  result_type = arg2_type;\n \t}\n@@ -4359,11 +4367,11 @@ build_conditional_expr (tree arg1, tree arg2, tree arg3,\n      that isn't wrapped with a TARGET_EXPR plays havoc with exception\n      regions.  */\n \n-  arg2 = force_rvalue (arg2);\n+  arg2 = force_rvalue (arg2, complain);\n   if (!CLASS_TYPE_P (arg2_type))\n     arg2_type = TREE_TYPE (arg2);\n \n-  arg3 = force_rvalue (arg3);\n+  arg3 = force_rvalue (arg3, complain);\n   if (!CLASS_TYPE_P (arg3_type))\n     arg3_type = TREE_TYPE (arg3);\n \n@@ -5642,7 +5650,7 @@ convert_like_real (conversion *convs, tree expr, tree fn, int argnum,\n \t\texpr = convert_bitfield_to_declared_type (expr);\n \t\texpr = fold_convert (type, expr);\n \t      }\n-\t    expr = build_target_expr_with_type (expr, type);\n+\t    expr = build_target_expr_with_type (expr, type, complain);\n \t  }\n \n \t/* Take the address of the thing to which we will bind the\n@@ -6341,7 +6349,7 @@ build_over_call (struct z_candidate *cand, int flags, tsubst_flags_t complain)\n \t  if (TREE_CODE (arg) == TARGET_EXPR)\n \t    return arg;\n \t  else if (trivial)\n-\t    return force_target_expr (DECL_CONTEXT (fn), arg);\n+\t    return force_target_expr (DECL_CONTEXT (fn), arg, complain);\n \t}\n       else if (TREE_CODE (arg) == TARGET_EXPR || trivial)\n \t{\n@@ -8246,7 +8254,7 @@ set_up_extended_ref_temp (tree decl, tree expr, tree *cleanup, tree *initp)\n       if (TREE_STATIC (var))\n \tinit = add_stmt_to_compound (init, register_dtor_fn (var));\n       else\n-\t*cleanup = cxx_maybe_build_cleanup (var);\n+\t*cleanup = cxx_maybe_build_cleanup (var, tf_warning_or_error);\n \n       /* We must be careful to destroy the temporary only\n \t after its initialization has taken place.  If the"}, {"sha": "26da4b3746c10dccb7630fd8e5a5a9a8d51d2874", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/574cfaa47dbcc2e8d9ea68b83d8dc3122832ff9b/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/574cfaa47dbcc2e8d9ea68b83d8dc3122832ff9b/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=574cfaa47dbcc2e8d9ea68b83d8dc3122832ff9b", "patch": "@@ -4744,7 +4744,7 @@ extern void adjust_clone_args\t\t\t(tree);\n /* in cvt.c */\n extern tree convert_to_reference\t\t(tree, tree, int, int, tree);\n extern tree convert_from_reference\t\t(tree);\n-extern tree force_rvalue\t\t\t(tree);\n+extern tree force_rvalue\t\t\t(tree, tsubst_flags_t);\n extern tree ocp_convert\t\t\t\t(tree, tree, int, int);\n extern tree cp_convert\t\t\t\t(tree, tree);\n extern tree cp_convert_and_check                (tree, tree);\n@@ -4858,7 +4858,7 @@ extern tree next_initializable_field (tree);\n extern bool defer_mark_used_calls;\n extern GTY(()) VEC(tree, gc) *deferred_mark_used_calls;\n extern tree finish_case_label\t\t\t(location_t, tree, tree);\n-extern tree cxx_maybe_build_cleanup\t\t(tree);\n+extern tree cxx_maybe_build_cleanup\t\t(tree, tsubst_flags_t);\n \n /* in decl2.c */\n extern bool check_java_method\t\t\t(tree);\n@@ -4870,7 +4870,7 @@ extern bool vague_linkage_p\t\t\t(tree);\n extern void grokclassfn\t\t\t\t(tree, tree,\n \t\t\t\t\t\t enum overload_flags);\n extern tree grok_array_decl\t\t\t(tree, tree);\n-extern tree delete_sanity\t\t\t(tree, tree, bool, int);\n+extern tree delete_sanity\t\t\t(tree, tree, bool, int, tsubst_flags_t);\n extern tree check_classfn\t\t\t(tree, tree, tree);\n extern void check_member_template\t\t(tree);\n extern tree grokfield (const cp_declarator *, cp_decl_specifier_seq *,\n@@ -4977,10 +4977,11 @@ extern tree build_vec_init\t\t\t(tree, tree, tree, bool, int,\n                                                  tsubst_flags_t);\n extern tree build_delete\t\t\t(tree, tree,\n \t\t\t\t\t\t special_function_kind,\n-\t\t\t\t\t\t int, int);\n+\t\t\t\t\t\t int, int, tsubst_flags_t);\n extern void push_base_cleanups\t\t\t(void);\n extern tree build_vec_delete\t\t\t(tree, tree,\n-\t\t\t\t\t\t special_function_kind, int);\n+\t\t\t\t\t\t special_function_kind, int,\n+\t\t\t\t\t\t tsubst_flags_t);\n extern tree create_temporary_var\t\t(tree);\n extern void initialize_vtbl_ptrs\t\t(tree);\n extern tree build_java_class_ref\t\t(tree);\n@@ -5379,8 +5380,8 @@ extern void maybe_add_lambda_conv_op            (tree);\n \n /* in tree.c */\n void cp_free_lang_data \t\t\t\t(tree t);\n-extern tree force_target_expr\t\t\t(tree, tree);\n-extern tree build_target_expr_with_type\t\t(tree, tree);\n+extern tree force_target_expr\t\t\t(tree, tree, tsubst_flags_t);\n+extern tree build_target_expr_with_type\t\t(tree, tree, tsubst_flags_t);\n extern void lang_check_failed\t\t\t(const char *, int,\n \t\t\t\t\t\t const char *) ATTRIBUTE_NORETURN;\n extern tree stabilize_expr\t\t\t(tree, tree *);\n@@ -5413,6 +5414,7 @@ extern tree build_min_non_dep_call_vec\t\t(tree, tree, VEC(tree,gc) *);\n extern tree build_cplus_new\t\t\t(tree, tree, tsubst_flags_t);\n extern tree build_aggr_init_expr\t\t(tree, tree, tsubst_flags_t);\n extern tree get_target_expr\t\t\t(tree);\n+extern tree get_target_expr_sfinae\t\t(tree, tsubst_flags_t);\n extern tree build_cplus_array_type\t\t(tree, tree);\n extern tree build_array_of_n_type\t\t(tree, int);\n extern tree build_array_copy\t\t\t(tree);"}, {"sha": "64fe87187ab230d88fee0c3b52877723fe6c0190", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/574cfaa47dbcc2e8d9ea68b83d8dc3122832ff9b/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/574cfaa47dbcc2e8d9ea68b83d8dc3122832ff9b/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=574cfaa47dbcc2e8d9ea68b83d8dc3122832ff9b", "patch": "@@ -531,11 +531,17 @@ convert_from_reference (tree val)\n    argument of class type into a temporary.  */\n \n tree\n-force_rvalue (tree expr)\n+force_rvalue (tree expr, tsubst_flags_t complain)\n {\n-  if (MAYBE_CLASS_TYPE_P (TREE_TYPE (expr)) && TREE_CODE (expr) != TARGET_EXPR)\n-    expr = ocp_convert (TREE_TYPE (expr), expr,\n-\t\t\tCONV_IMPLICIT|CONV_FORCE_TEMP, LOOKUP_NORMAL);\n+  tree type = TREE_TYPE (expr);\n+  if (MAYBE_CLASS_TYPE_P (type) && TREE_CODE (expr) != TARGET_EXPR)\n+    {\n+      VEC(tree,gc) *args = make_tree_vector_single (expr);\n+      expr = build_special_member_call (NULL_TREE, complete_ctor_identifier,\n+\t\t\t\t\t&args, type, LOOKUP_NORMAL, complain);\n+      release_tree_vector (args);\n+      expr = build_cplus_new (type, expr, complain);\n+    }\n   else\n     expr = decay_conversion (expr);\n "}, {"sha": "ccc5fd018c9d704b75dcf3bd5dd248fdcfd208f5", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/574cfaa47dbcc2e8d9ea68b83d8dc3122832ff9b/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/574cfaa47dbcc2e8d9ea68b83d8dc3122832ff9b/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=574cfaa47dbcc2e8d9ea68b83d8dc3122832ff9b", "patch": "@@ -5640,7 +5640,7 @@ initialize_local_var (tree decl, tree init)\n     DECL_READ_P (decl) = 1;\n \n   /* Generate a cleanup, if necessary.  */\n-  cleanup = cxx_maybe_build_cleanup (decl);\n+  cleanup = cxx_maybe_build_cleanup (decl, tf_warning_or_error);\n \n   /* Perform the initialization.  */\n   if (init)\n@@ -13309,7 +13309,7 @@ complete_vars (tree type)\n    cleanup need be done.  */\n \n tree\n-cxx_maybe_build_cleanup (tree decl)\n+cxx_maybe_build_cleanup (tree decl, tsubst_flags_t complain)\n {\n   tree type;\n   tree attr;\n@@ -13344,8 +13344,9 @@ cxx_maybe_build_cleanup (tree decl)\n       fn = lookup_name (id);\n       arg = build_address (decl);\n       mark_used (decl);\n-      cleanup = cp_build_function_call_nary (fn, tf_warning_or_error,\n-\t\t\t\t\t     arg, NULL_TREE);\n+      cleanup = cp_build_function_call_nary (fn, complain, arg, NULL_TREE);\n+      if (cleanup == error_mark_node)\n+\treturn error_mark_node;\n     }\n   /* Handle ordinary C++ destructors.  */\n   type = TREE_TYPE (decl);\n@@ -13367,9 +13368,11 @@ cxx_maybe_build_cleanup (tree decl)\n \tflags |= LOOKUP_NONVIRTUAL;\n \n       call = build_delete (TREE_TYPE (addr), addr,\n-\t\t\t   sfk_complete_destructor, flags, 0);\n-      if (cleanup)\n-\tcleanup = build_compound_expr (input_location, cleanup, call);\n+\t\t\t   sfk_complete_destructor, flags, 0, complain);\n+      if (call == error_mark_node)\n+\tcleanup = error_mark_node;\n+      else if (cleanup)\n+\tcleanup = cp_build_compound_expr (cleanup, call, complain);\n       else\n \tcleanup = call;\n     }"}, {"sha": "d1b252d58a84c1e6d1883559f31457e6c23c00ef", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/574cfaa47dbcc2e8d9ea68b83d8dc3122832ff9b/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/574cfaa47dbcc2e8d9ea68b83d8dc3122832ff9b/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=574cfaa47dbcc2e8d9ea68b83d8dc3122832ff9b", "patch": "@@ -419,7 +419,8 @@ grok_array_decl (tree array_expr, tree index_exp)\n    Implements ARM $5.3.4.  This is called from the parser.  */\n \n tree\n-delete_sanity (tree exp, tree size, bool doing_vec, int use_global_delete)\n+delete_sanity (tree exp, tree size, bool doing_vec, int use_global_delete,\n+\t       tsubst_flags_t complain)\n {\n   tree t, type;\n \n@@ -475,10 +476,11 @@ delete_sanity (tree exp, tree size, bool doing_vec, int use_global_delete)\n   if (doing_vec)\n     return build_vec_delete (t, /*maxindex=*/NULL_TREE,\n \t\t\t     sfk_deleting_destructor,\n-\t\t\t     use_global_delete);\n+\t\t\t     use_global_delete, complain);\n   else\n     return build_delete (type, t, sfk_deleting_destructor,\n-\t\t\t LOOKUP_NORMAL, use_global_delete);\n+\t\t\t LOOKUP_NORMAL, use_global_delete,\n+\t\t\t complain);\n }\n \n /* Report an error if the indicated template declaration is not the\n@@ -2594,7 +2596,8 @@ build_cleanup (tree decl)\n     temp = build_address (decl);\n   temp = build_delete (TREE_TYPE (temp), temp,\n \t\t       sfk_complete_destructor,\n-\t\t       LOOKUP_NORMAL|LOOKUP_NONVIRTUAL|LOOKUP_DESTRUCTOR, 0);\n+\t\t       LOOKUP_NORMAL|LOOKUP_NONVIRTUAL|LOOKUP_DESTRUCTOR, 0,\n+\t\t       tf_warning_or_error);\n   return temp;\n }\n "}, {"sha": "25beba8bd5ea4e5e2085a5ddee26f15d89274214", "filename": "gcc/cp/init.c", "status": "modified", "additions": 96, "deletions": 58, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/574cfaa47dbcc2e8d9ea68b83d8dc3122832ff9b/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/574cfaa47dbcc2e8d9ea68b83d8dc3122832ff9b/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=574cfaa47dbcc2e8d9ea68b83d8dc3122832ff9b", "patch": "@@ -37,7 +37,6 @@ static tree finish_init_stmts (bool, tree, tree);\n static void construct_virtual_base (tree, tree);\n static void expand_aggr_init_1 (tree, tree, tree, tree, int, tsubst_flags_t);\n static void expand_default_init (tree, tree, tree, tree, int, tsubst_flags_t);\n-static tree build_vec_delete_1 (tree, tree, tree, special_function_kind, int);\n static void perform_member_init (tree, tree);\n static tree build_builtin_delete_call (tree);\n static int member_init_ok_or_else (tree, tree, tree);\n@@ -46,7 +45,6 @@ static tree sort_mem_initializers (tree, tree);\n static tree initializing_context (tree);\n static void expand_cleanup_for_base (tree, tree);\n static tree dfs_initialize_vtbl_ptrs (tree, void *);\n-static tree build_dtor_call (tree, special_function_kind, int);\n static tree build_field_list (tree, tree, int *);\n static tree build_vtbl_address (tree);\n static int diagnose_uninitialized_cst_or_ref_member_1 (tree, tree, bool, bool);\n@@ -620,7 +618,8 @@ perform_member_init (tree member, tree init)\n \t\t\t\t\t     /*preserve_reference=*/false,\n \t\t\t\t\t     tf_warning_or_error);\n       expr = build_delete (type, expr, sfk_complete_destructor,\n-\t\t\t   LOOKUP_NONVIRTUAL|LOOKUP_DESTRUCTOR, 0);\n+\t\t\t   LOOKUP_NONVIRTUAL|LOOKUP_DESTRUCTOR, 0,\n+\t\t\t   tf_warning_or_error);\n \n       if (expr != error_mark_node)\n \tfinish_eh_cleanup (expr);\n@@ -2720,7 +2719,8 @@ build_java_class_ref (tree type)\n \f\n static tree\n build_vec_delete_1 (tree base, tree maxindex, tree type,\n-    special_function_kind auto_delete_vec, int use_global_delete)\n+\t\t    special_function_kind auto_delete_vec,\n+\t\t    int use_global_delete, tsubst_flags_t complain)\n {\n   tree virtual_size;\n   tree ptype = build_pointer_type (type = complete_type (type));\n@@ -2749,6 +2749,9 @@ build_vec_delete_1 (tree base, tree maxindex, tree type,\n   /* We should only have 1-D arrays here.  */\n   gcc_assert (TREE_CODE (type) != ARRAY_TYPE);\n \n+  if (base == error_mark_node || maxindex == error_mark_node)\n+    return error_mark_node;\n+\n   if (! MAYBE_CLASS_TYPE_P (type) || TYPE_HAS_TRIVIAL_DESTRUCTOR (type))\n     goto no_destructor;\n \n@@ -2762,7 +2765,9 @@ build_vec_delete_1 (tree base, tree maxindex, tree type,\n \t\t\t\t\t\t  POINTER_PLUS_EXPR, ptype,\n \t\t\t\t\t\t  fold_convert (ptype, base),\n \t\t\t\t\t\t  virtual_size),\n-\t\t\t\t     tf_warning_or_error);\n+\t\t\t\t     complain);\n+  if (tbase_init == error_mark_node)\n+    return error_mark_node;\n   controller = build3 (BIND_EXPR, void_type_node, tbase,\n \t\t       NULL_TREE, NULL_TREE);\n   TREE_SIDE_EFFECTS (controller) = 1;\n@@ -2771,15 +2776,17 @@ build_vec_delete_1 (tree base, tree maxindex, tree type,\n \t\t build2 (EQ_EXPR, boolean_type_node, tbase,\n \t\t\t fold_convert (ptype, base)));\n   tmp = fold_build1_loc (input_location, NEGATE_EXPR, sizetype, size_exp);\n-  body = build_compound_expr\n-    (input_location, \n-     body, cp_build_modify_expr (tbase, NOP_EXPR,\n-\t\t\t\t build2 (POINTER_PLUS_EXPR, ptype, tbase, tmp),\n-\t\t\t\t tf_warning_or_error));\n-  body = build_compound_expr\n-    (input_location,\n-     body, build_delete (ptype, tbase, sfk_complete_destructor,\n-\t\t\t LOOKUP_NORMAL|LOOKUP_DESTRUCTOR, 1));\n+  tmp = build2 (POINTER_PLUS_EXPR, ptype, tbase, tmp);\n+  tmp = cp_build_modify_expr (tbase, NOP_EXPR, tmp, complain);\n+  if (tmp == error_mark_node)\n+    return error_mark_node;\n+  body = build_compound_expr (input_location, body, tmp);\n+  tmp = build_delete (ptype, tbase, sfk_complete_destructor,\n+\t\t      LOOKUP_NORMAL|LOOKUP_DESTRUCTOR, 1,\n+\t\t      complain);\n+  if (tmp == error_mark_node)\n+    return error_mark_node;\n+  body = build_compound_expr (input_location, body, tmp);\n \n   loop = build1 (LOOP_EXPR, void_type_node, body);\n   loop = build_compound_expr (input_location, tbase_init, loop);\n@@ -2803,14 +2810,15 @@ build_vec_delete_1 (tree base, tree maxindex, tree type,\n \t  tree cookie_size;\n \n \t  cookie_size = targetm.cxx.get_cookie_size (type);\n-\t  base_tbd\n-\t    = cp_convert (ptype,\n-\t\t\t  cp_build_binary_op (input_location,\n-\t\t\t\t\t      MINUS_EXPR,\n-\t\t\t\t\t      cp_convert (string_type_node,\n-\t\t\t\t\t\t\t  base),\n-\t\t\t\t\t      cookie_size,\n-\t\t\t\t\t      tf_warning_or_error));\n+\t  base_tbd = cp_build_binary_op (input_location,\n+\t\t\t\t\t MINUS_EXPR,\n+\t\t\t\t\t cp_convert (string_type_node,\n+\t\t\t\t\t\t     base),\n+\t\t\t\t\t cookie_size,\n+\t\t\t\t\t complain);\n+\t  if (base_tbd == error_mark_node)\n+\t    return error_mark_node;\n+\t  base_tbd = cp_convert (ptype, base_tbd);\n \t  /* True size with header.  */\n \t  virtual_size = size_binop (PLUS_EXPR, virtual_size, cookie_size);\n \t}\n@@ -2853,7 +2861,7 @@ build_vec_delete_1 (tree base, tree maxindex, tree type,\n     /* Pre-evaluate the SAVE_EXPR outside of the BIND_EXPR.  */\n     body = build2 (COMPOUND_EXPR, void_type_node, base, body);\n \n-  return convert_to_void (body, ICV_CAST, tf_warning_or_error);\n+  return convert_to_void (body, ICV_CAST, complain);\n }\n \n /* Create an unnamed variable of the indicated TYPE.  */\n@@ -2942,6 +2950,7 @@ build_vec_init (tree base, tree maxindex, tree init,\n   tree const_init = NULL_TREE;\n   tree obase = base;\n   bool xvalue = false;\n+  bool errors = false;\n \n   if (TREE_CODE (atype) == ARRAY_TYPE && TYPE_DOMAIN (atype))\n     maxindex = array_type_nelts (atype);\n@@ -3087,7 +3096,8 @@ build_vec_init (tree base, tree maxindex, tree init,\n \t  else\n \t    one_init = cp_build_modify_expr (baseref, NOP_EXPR,\n \t\t\t\t\t     elt, complain);\n-\n+\t  if (one_init == error_mark_node)\n+\t    errors = true;\n \t  if (try_const)\n \t    {\n \t      tree e = one_init;\n@@ -3120,10 +3130,18 @@ build_vec_init (tree base, tree maxindex, tree init,\n \t    finish_expr_stmt (one_init);\n \t  current_stmt_tree ()->stmts_are_full_exprs_p = 0;\n \n-\t  finish_expr_stmt (cp_build_unary_op (PREINCREMENT_EXPR, base, 0,\n-                                               complain));\n-\t  finish_expr_stmt (cp_build_unary_op (PREDECREMENT_EXPR, iterator, 0,\n-                                               complain));\n+\t  one_init = cp_build_unary_op (PREINCREMENT_EXPR, base, 0, complain);\n+\t  if (one_init == error_mark_node)\n+\t    errors = true;\n+\t  else\n+\t    finish_expr_stmt (one_init);\n+\n+\t  one_init = cp_build_unary_op (PREDECREMENT_EXPR, iterator, 0,\n+\t\t\t\t\tcomplain);\n+\t  if (one_init == error_mark_node)\n+\t    errors = true;\n+\t  else\n+\t    finish_expr_stmt (one_init);\n \t}\n \n       if (try_const)\n@@ -3149,7 +3167,7 @@ build_vec_init (tree base, tree maxindex, tree init,\n \t{\n           if (complain & tf_error)\n             error (\"initializer ends prematurely\");\n-\t  return error_mark_node;\n+\t  errors = true;\n \t}\n     }\n \n@@ -3176,9 +3194,11 @@ build_vec_init (tree base, tree maxindex, tree init,\n       finish_for_cond (build2 (NE_EXPR, boolean_type_node, iterator,\n \t\t\t       build_int_cst (TREE_TYPE (iterator), -1)),\n \t\t       for_stmt);\n-      finish_for_expr (cp_build_unary_op (PREDECREMENT_EXPR, iterator, 0,\n-                                          complain),\n-\t\t       for_stmt);\n+      elt_init = cp_build_unary_op (PREDECREMENT_EXPR, iterator, 0,\n+\t\t\t\t    complain);\n+      if (elt_init == error_mark_node)\n+\terrors = true;\n+      finish_for_expr (elt_init, for_stmt);\n \n       to = build1 (INDIRECT_REF, type, base);\n \n@@ -3219,9 +3239,7 @@ build_vec_init (tree base, tree maxindex, tree init,\n       else if (explicit_value_init_p)\n \t{\n \t  elt_init = build_value_init (type, complain);\n-\t  if (elt_init == error_mark_node)\n-\t    return error_mark_node;\n-\t  else\n+\t  if (elt_init != error_mark_node)\n \t    elt_init = build2 (INIT_EXPR, type, to, elt_init);\n \t}\n       else\n@@ -3230,6 +3248,9 @@ build_vec_init (tree base, tree maxindex, tree init,\n \t  elt_init = build_aggr_init (to, init, 0, complain);\n \t}\n \n+      if (elt_init == error_mark_node)\n+\terrors = true;\n+\n       current_stmt_tree ()->stmts_are_full_exprs_p = 1;\n       finish_expr_stmt (elt_init);\n       current_stmt_tree ()->stmts_are_full_exprs_p = 0;\n@@ -3263,7 +3284,9 @@ build_vec_init (tree base, tree maxindex, tree init,\n       finish_cleanup_try_block (try_block);\n       e = build_vec_delete_1 (rval, m,\n \t\t\t      inner_elt_type, sfk_base_destructor,\n-\t\t\t      /*use_global_delete=*/0);\n+\t\t\t      /*use_global_delete=*/0, complain);\n+      if (e == error_mark_node)\n+\terrors = true;\n       finish_cleanup (e, try_block);\n     }\n \n@@ -3286,14 +3309,17 @@ build_vec_init (tree base, tree maxindex, tree init,\n \n   if (const_init)\n     return build2 (INIT_EXPR, atype, obase, const_init);\n+  if (errors)\n+    return error_mark_node;\n   return stmt_expr;\n }\n \n /* Call the DTOR_KIND destructor for EXP.  FLAGS are as for\n    build_delete.  */\n \n static tree\n-build_dtor_call (tree exp, special_function_kind dtor_kind, int flags)\n+build_dtor_call (tree exp, special_function_kind dtor_kind, int flags,\n+\t\t tsubst_flags_t complain)\n {\n   tree name;\n   tree fn;\n@@ -3320,7 +3346,7 @@ build_dtor_call (tree exp, special_function_kind dtor_kind, int flags)\n \t\t\t\t/*conversion_path=*/NULL_TREE,\n \t\t\t\tflags,\n \t\t\t\t/*fn_p=*/NULL,\n-\t\t\t\ttf_warning_or_error);\n+\t\t\t\tcomplain);\n }\n \n /* Generate a call to a destructor. TYPE is the type to cast ADDR to.\n@@ -3334,7 +3360,7 @@ build_dtor_call (tree exp, special_function_kind dtor_kind, int flags)\n \n tree\n build_delete (tree type, tree addr, special_function_kind auto_delete,\n-    int flags, int use_global_delete)\n+\t      int flags, int use_global_delete, tsubst_flags_t complain)\n {\n   tree expr;\n \n@@ -3369,8 +3395,9 @@ build_delete (tree type, tree addr, special_function_kind auto_delete,\n \t  complete_type (type);\n \t  if (!COMPLETE_TYPE_P (type))\n \t    {\n-\t      if (warning (0, \"possible problem detected in invocation of \"\n-\t\t\t   \"delete operator:\"))\n+\t      if ((complain & tf_warning)\n+\t\t  && warning (0, \"possible problem detected in invocation of \"\n+\t\t\t      \"delete operator:\"))\n \t\t{\n \t\t  cxx_incomplete_type_diagnostic (addr, type, DK_WARNING);\n \t\t  inform (input_location, \"neither the destructor nor the class-specific \"\n@@ -3395,18 +3422,21 @@ build_delete (tree type, tree addr, special_function_kind auto_delete,\n \n       if (TYPE_DOMAIN (type) == NULL_TREE)\n \t{\n-\t  error (\"unknown array size in delete\");\n+\t  if (complain & tf_error)\n+\t    error (\"unknown array size in delete\");\n \t  return error_mark_node;\n \t}\n       return build_vec_delete (addr, array_type_nelts (type),\n-\t\t\t       auto_delete, use_global_delete);\n+\t\t\t       auto_delete, use_global_delete, complain);\n     }\n   else\n     {\n       /* Don't check PROTECT here; leave that decision to the\n \t destructor.  If the destructor is accessible, call it,\n \t else report error.  */\n-      addr = cp_build_addr_expr (addr, tf_warning_or_error);\n+      addr = cp_build_addr_expr (addr, complain);\n+      if (addr == error_mark_node)\n+\treturn error_mark_node;\n       if (TREE_SIDE_EFFECTS (addr))\n \taddr = save_expr (addr);\n \n@@ -3478,9 +3508,10 @@ build_delete (tree type, tree addr, special_function_kind auto_delete,\n \t\t\t\t/*alloc_fn=*/NULL_TREE);\n \t}\n \n-      expr = build_dtor_call (cp_build_indirect_ref (addr, RO_NULL, \n-                                                     tf_warning_or_error),\n-\t\t\t      auto_delete, flags);\n+      expr = build_dtor_call (cp_build_indirect_ref (addr, RO_NULL, complain),\n+\t\t\t      auto_delete, flags, complain);\n+      if (expr == error_mark_node)\n+\treturn error_mark_node;\n       if (do_delete)\n \texpr = build2 (COMPOUND_EXPR, void_type_node, expr, do_delete);\n \n@@ -3492,10 +3523,14 @@ build_delete (tree type, tree addr, special_function_kind auto_delete,\n \t/* Explicit destructor call; don't check for null pointer.  */\n \tifexp = integer_one_node;\n       else\n-\t/* Handle deleting a null pointer.  */\n-\tifexp = fold (cp_build_binary_op (input_location,\n-\t\t\t\t\t  NE_EXPR, addr, integer_zero_node,\n-\t\t\t\t\t  tf_warning_or_error));\n+\t{\n+\t  /* Handle deleting a null pointer.  */\n+\t  ifexp = fold (cp_build_binary_op (input_location,\n+\t\t\t\t\t    NE_EXPR, addr, integer_zero_node,\n+\t\t\t\t\t    complain));\n+\t  if (ifexp == error_mark_node)\n+\t    return error_mark_node;\n+\t}\n \n       if (ifexp != integer_one_node)\n \texpr = build3 (COND_EXPR, void_type_node,\n@@ -3588,7 +3623,7 @@ push_base_cleanups (void)\n \t  expr = build_delete (this_type, this_member,\n \t\t\t       sfk_complete_destructor,\n \t\t\t       LOOKUP_NONVIRTUAL|LOOKUP_DESTRUCTOR|LOOKUP_NORMAL,\n-\t\t\t       0);\n+\t\t\t       0, tf_warning_or_error);\n \t  finish_decl_cleanup (NULL_TREE, expr);\n \t}\n     }\n@@ -3612,7 +3647,8 @@ push_base_cleanups (void)\n \n tree\n build_vec_delete (tree base, tree maxindex,\n-    special_function_kind auto_delete_vec, int use_global_delete)\n+\t\t  special_function_kind auto_delete_vec,\n+\t\t  int use_global_delete, tsubst_flags_t complain)\n {\n   tree type;\n   tree rval;\n@@ -3638,15 +3674,17 @@ build_vec_delete (tree base, tree maxindex,\n \t\t\t    size_ptr_type,\n \t\t\t    fold_convert (size_ptr_type, base),\n \t\t\t    cookie_addr);\n-      maxindex = cp_build_indirect_ref (cookie_addr, RO_NULL, tf_warning_or_error);\n+      maxindex = cp_build_indirect_ref (cookie_addr, RO_NULL, complain);\n     }\n   else if (TREE_CODE (type) == ARRAY_TYPE)\n     {\n       /* Get the total number of things in the array, maxindex is a\n \t bad name.  */\n       maxindex = array_type_nelts_total (type);\n       type = strip_array_types (type);\n-      base = cp_build_addr_expr (base, tf_warning_or_error);\n+      base = cp_build_addr_expr (base, complain);\n+      if (base == error_mark_node)\n+\treturn error_mark_node;\n       if (TREE_SIDE_EFFECTS (base))\n \t{\n \t  base_init = get_target_expr (base);\n@@ -3655,14 +3693,14 @@ build_vec_delete (tree base, tree maxindex,\n     }\n   else\n     {\n-      if (base != error_mark_node)\n+      if (base != error_mark_node && !(complain & tf_error))\n \terror (\"type to vector delete is neither pointer or array type\");\n       return error_mark_node;\n     }\n \n   rval = build_vec_delete_1 (base, maxindex, type, auto_delete_vec,\n-\t\t\t     use_global_delete);\n-  if (base_init)\n+\t\t\t     use_global_delete, complain);\n+  if (base_init && rval != error_mark_node)\n     rval = build2 (COMPOUND_EXPR, TREE_TYPE (rval), base_init, rval);\n \n   return rval;"}, {"sha": "6da285e83dd30dfc3e4774dcf3728eee54f597e0", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/574cfaa47dbcc2e8d9ea68b83d8dc3122832ff9b/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/574cfaa47dbcc2e8d9ea68b83d8dc3122832ff9b/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=574cfaa47dbcc2e8d9ea68b83d8dc3122832ff9b", "patch": "@@ -6295,7 +6295,8 @@ cp_parser_delete_expression (cp_parser* parser)\n   if (cp_parser_non_integral_constant_expression (parser, NIC_DEL))\n     return error_mark_node;\n \n-  return delete_sanity (expression, NULL_TREE, array_p, global_scope_p);\n+  return delete_sanity (expression, NULL_TREE, array_p, global_scope_p,\n+\t\t\ttf_warning_or_error);\n }\n \n /* Returns true if TOKEN may start a cast-expression and false"}, {"sha": "de574a497e80fa77fd56f1af4d67337add314257", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/574cfaa47dbcc2e8d9ea68b83d8dc3122832ff9b/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/574cfaa47dbcc2e8d9ea68b83d8dc3122832ff9b/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=574cfaa47dbcc2e8d9ea68b83d8dc3122832ff9b", "patch": "@@ -12102,7 +12102,7 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl,\n \t\t\t    init = build_value_init (TREE_TYPE (decl),\n \t\t\t\t\t\t     complain);\n \t\t\t    if (TREE_CODE (init) == AGGR_INIT_EXPR)\n-\t\t\t      init = get_target_expr (init);\n+\t\t\t      init = get_target_expr_sfinae (init, complain);\n \t\t\t  }\n \t\t\telse\n \t\t\t  init = t;\n@@ -12846,7 +12846,8 @@ tsubst_copy_and_build (tree t,\n        (RECUR (TREE_OPERAND (t, 0)),\n \tRECUR (TREE_OPERAND (t, 1)),\n \tDELETE_EXPR_USE_VEC (t),\n-\tDELETE_EXPR_USE_GLOBAL (t));\n+\tDELETE_EXPR_USE_GLOBAL (t),\n+\tcomplain);\n \n     case COMPOUND_EXPR:\n       return build_x_compound_expr (RECUR (TREE_OPERAND (t, 0)),"}, {"sha": "16fabb80556f2b2d6b51bcab20bdf0b9348639d5", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/574cfaa47dbcc2e8d9ea68b83d8dc3122832ff9b/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/574cfaa47dbcc2e8d9ea68b83d8dc3122832ff9b/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=574cfaa47dbcc2e8d9ea68b83d8dc3122832ff9b", "patch": "@@ -1835,7 +1835,7 @@ finish_stmt_expr_expr (tree expr, tree stmt_expr)\n \t  /* It actually has a value we need to deal with.  First, force it\n \t     to be an rvalue so that we won't need to build up a copy\n \t     constructor call later when we try to assign it to something.  */\n-\t  expr = force_rvalue (expr);\n+\t  expr = force_rvalue (expr, tf_warning_or_error);\n \t  if (error_operand_p (expr))\n \t    return error_mark_node;\n \n@@ -1892,7 +1892,7 @@ finish_stmt_expr (tree stmt_expr, bool has_no_scope)\n \t temporary object created by the final expression is destroyed at\n \t the end of the full-expression containing the\n \t statement-expression.  */\n-      result = force_target_expr (type, result);\n+      result = force_target_expr (type, result, tf_warning_or_error);\n     }\n \n   return result;\n@@ -2407,7 +2407,7 @@ finish_compound_literal (tree type, tree compound_literal,\n       return decl;\n     }\n   else\n-    return get_target_expr (compound_literal);\n+    return get_target_expr_sfinae (compound_literal, complain);\n }\n \n /* Return the declaration for the function-name variable indicated by\n@@ -7995,7 +7995,7 @@ build_lambda_object (tree lambda_expr)\n \t     There's normally no way to express direct-initialization\n \t     from an element of a CONSTRUCTOR, so we build up a special\n \t     TARGET_EXPR to bypass the usual copy-initialization.  */\n-\t  val = force_rvalue (val);\n+\t  val = force_rvalue (val, tf_warning_or_error);\n \t  if (TREE_CODE (val) == TARGET_EXPR)\n \t    TARGET_EXPR_DIRECT_INIT_P (val) = true;\n \t}"}, {"sha": "8fe8832f7bb3095e6e43aec8999b91e8fabe6b48", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 25, "deletions": 16, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/574cfaa47dbcc2e8d9ea68b83d8dc3122832ff9b/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/574cfaa47dbcc2e8d9ea68b83d8dc3122832ff9b/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=574cfaa47dbcc2e8d9ea68b83d8dc3122832ff9b", "patch": "@@ -39,7 +39,7 @@ static tree bot_replace (tree *, int *, void *);\n static int list_hash_eq (const void *, const void *);\n static hashval_t list_hash_pieces (tree, tree, tree);\n static hashval_t list_hash (const void *);\n-static tree build_target_expr (tree, tree);\n+static tree build_target_expr (tree, tree, tsubst_flags_t);\n static tree count_trees_r (tree *, int *, void *);\n static tree verify_stmt_tree_r (tree *, int *, void *);\n static tree build_local_temp (tree);\n@@ -281,7 +281,7 @@ builtin_valid_in_constant_expr_p (const_tree decl)\n /* Build a TARGET_EXPR, initializing the DECL with the VALUE.  */\n \n static tree\n-build_target_expr (tree decl, tree value)\n+build_target_expr (tree decl, tree value, tsubst_flags_t complain)\n {\n   tree t;\n \n@@ -292,8 +292,10 @@ build_target_expr (tree decl, tree value)\n \t\t\t\t\t    TREE_TYPE (value)));\n #endif\n \n-  t = build4 (TARGET_EXPR, TREE_TYPE (decl), decl, value,\n-\t      cxx_maybe_build_cleanup (decl), NULL_TREE);\n+  t = cxx_maybe_build_cleanup (decl, complain);\n+  if (t == error_mark_node)\n+    return error_mark_node;\n+  t = build4 (TARGET_EXPR, TREE_TYPE (decl), decl, value, t, NULL_TREE);\n   /* We always set TREE_SIDE_EFFECTS so that expand_expr does not\n      ignore the TARGET_EXPR.  If there really turn out to be no\n      side-effects, then the optimizer should be able to get rid of\n@@ -453,7 +455,7 @@ build_cplus_new (tree type, tree init, tsubst_flags_t complain)\n   else\n     return rval;\n \n-  rval = build_target_expr (slot, rval);\n+  rval = build_target_expr (slot, rval, complain);\n   TARGET_EXPR_IMPLICIT_P (rval) = 1;\n \n   return rval;\n@@ -526,7 +528,7 @@ build_vec_init_expr (tree type, tree init)\n     VEC_INIT_EXPR_IS_CONSTEXPR (init) = true;\n   VEC_INIT_EXPR_VALUE_INIT (init) = value_init;\n \n-  init = build_target_expr (slot, init);\n+  init = build_target_expr (slot, init, tf_warning_or_error);\n   TARGET_EXPR_IMPLICIT_P (init) = 1;\n \n   return init;\n@@ -559,7 +561,7 @@ build_array_copy (tree init)\n    indicated TYPE.  */\n \n tree\n-build_target_expr_with_type (tree init, tree type)\n+build_target_expr_with_type (tree init, tree type, tsubst_flags_t complain)\n {\n   gcc_assert (!VOID_TYPE_P (type));\n \n@@ -577,9 +579,9 @@ build_target_expr_with_type (tree init, tree type)\n        another one here.  A CONSTRUCTOR is aggregate initialization, which\n        is handled separately.  A VA_ARG_EXPR is magic creation of an\n        aggregate; there's no additional work to be done.  */\n-    return force_rvalue (init);\n+    return force_rvalue (init, complain);\n \n-  return force_target_expr (type, init);\n+  return force_target_expr (type, init, complain);\n }\n \n /* Like the above function, but without the checking.  This function should\n@@ -588,27 +590,33 @@ build_target_expr_with_type (tree init, tree type)\n    infinite recursion.  */\n \n tree\n-force_target_expr (tree type, tree init)\n+force_target_expr (tree type, tree init, tsubst_flags_t complain)\n {\n   tree slot;\n \n   gcc_assert (!VOID_TYPE_P (type));\n \n   slot = build_local_temp (type);\n-  return build_target_expr (slot, init);\n+  return build_target_expr (slot, init, complain);\n }\n \n /* Like build_target_expr_with_type, but use the type of INIT.  */\n \n tree\n-get_target_expr (tree init)\n+get_target_expr_sfinae (tree init, tsubst_flags_t complain)\n {\n   if (TREE_CODE (init) == AGGR_INIT_EXPR)\n-    return build_target_expr (AGGR_INIT_EXPR_SLOT (init), init);\n+    return build_target_expr (AGGR_INIT_EXPR_SLOT (init), init, complain);\n   else if (TREE_CODE (init) == VEC_INIT_EXPR)\n-    return build_target_expr (VEC_INIT_EXPR_SLOT (init), init);\n+    return build_target_expr (VEC_INIT_EXPR_SLOT (init), init, complain);\n   else\n-    return build_target_expr_with_type (init, TREE_TYPE (init));\n+    return build_target_expr_with_type (init, TREE_TYPE (init), complain);\n+}\n+\n+tree\n+get_target_expr (tree init)\n+{\n+  return get_target_expr_sfinae (init, tf_warning_or_error);\n }\n \n /* If EXPR is a bitfield reference, convert it to the declared type of\n@@ -1810,7 +1818,8 @@ bot_manip (tree* tp, int* walk_subtrees, void* data)\n \tu = build_cplus_new (TREE_TYPE (t), TREE_OPERAND (t, 1),\n \t\t\t     tf_warning_or_error);\n       else\n-\tu = build_target_expr_with_type (TREE_OPERAND (t, 1), TREE_TYPE (t));\n+\tu = build_target_expr_with_type (TREE_OPERAND (t, 1), TREE_TYPE (t),\n+\t\t\t\t\t tf_warning_or_error);\n \n       /* Map the old variable to the new one.  */\n       splay_tree_insert (target_remap,"}, {"sha": "5522868df9cf4d81d959ec881a51a52d4e87ff86", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/574cfaa47dbcc2e8d9ea68b83d8dc3122832ff9b/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/574cfaa47dbcc2e8d9ea68b83d8dc3122832ff9b/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=574cfaa47dbcc2e8d9ea68b83d8dc3122832ff9b", "patch": "@@ -1610,7 +1610,7 @@ build_functional_cast (tree exp, tree parms, tsubst_flags_t complain)\n       && !TYPE_HAS_USER_CONSTRUCTOR (type))\n     {\n       exp = build_value_init (type, complain);\n-      exp = get_target_expr (exp);\n+      exp = get_target_expr_sfinae (exp, complain);\n       /* FIXME this is wrong */\n       if (literal_type_p (type))\n \tTREE_CONSTANT (exp) = true;"}, {"sha": "0a59e372af71d0faeb63d56852a623f2f3d2c232", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/574cfaa47dbcc2e8d9ea68b83d8dc3122832ff9b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/574cfaa47dbcc2e8d9ea68b83d8dc3122832ff9b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=574cfaa47dbcc2e8d9ea68b83d8dc3122832ff9b", "patch": "@@ -1,3 +1,7 @@\n+2011-04-25  Jason Merrill  <jason@redhat.com>\n+\n+\t* g++.dg/cpp0x/sfinae17.C: New.\n+\n 2011-03-23  Michael Meissner  <meissner@linux.vnet.ibm.com>\n \n \tPR target/48258"}, {"sha": "dbbd9efe41073deef10fa4b484f7dad498c32bcd", "filename": "gcc/testsuite/g++.dg/cpp0x/sfinae17.C", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/574cfaa47dbcc2e8d9ea68b83d8dc3122832ff9b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fsfinae17.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/574cfaa47dbcc2e8d9ea68b83d8dc3122832ff9b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fsfinae17.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fsfinae17.C?ref=574cfaa47dbcc2e8d9ea68b83d8dc3122832ff9b", "patch": "@@ -0,0 +1,31 @@\n+// PR c++/48530\n+// { dg-options -std=c++0x }\n+\n+template<class T,\n+\t class = decltype(T{})\n+>\n+char f(int);\n+\n+template<class>\n+char (&f(...))[2];\n+\n+struct DelDtor {\n+  ~DelDtor() = delete;\n+};\n+\n+static_assert(sizeof(f<DelDtor[2]>(0)) != 1, \"Error\");\n+\n+struct A\n+{\n+  static DelDtor *p;\n+};\n+\n+template<class T,\n+\t class = decltype(delete T::p, (T*)0)\n+>\n+char g(int);\n+\n+template<class>\n+char (&g(...))[2];\n+\n+static_assert(sizeof(g<DelDtor>(0)) != 1, \"Error\");"}]}