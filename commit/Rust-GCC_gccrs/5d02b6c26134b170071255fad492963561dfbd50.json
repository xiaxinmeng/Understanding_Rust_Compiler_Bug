{"sha": "5d02b6c26134b170071255fad492963561dfbd50", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWQwMmI2YzI2MTM0YjE3MDA3MTI1NWZhZDQ5Mjk2MzU2MWRmYmQ1MA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "1999-04-17T23:31:34Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1999-04-17T23:31:34Z"}, "message": "alpha.h (REG_OK_FP_BASE_P): New macro.\n\n        * alpha.h (REG_OK_FP_BASE_P): New macro.\n        (GO_IF_LEGITIMATE_SIMPLE_ADDRESS): Use it.\n        * alpha.md (adddi3+1): New insn to handle large constants off\n        the soft frame pointer.\n        (adddi3+2): Don't split soft frame pointer or arg pointer additions.\n\nFrom-SVN: r26530", "tree": {"sha": "0ae169b0fd890824a422f22950f870a0f346e88d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0ae169b0fd890824a422f22950f870a0f346e88d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5d02b6c26134b170071255fad492963561dfbd50", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d02b6c26134b170071255fad492963561dfbd50", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5d02b6c26134b170071255fad492963561dfbd50", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d02b6c26134b170071255fad492963561dfbd50/comments", "author": null, "committer": null, "parents": [{"sha": "87ba694401df1d06dda4b8c14b50528a740eef6d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/87ba694401df1d06dda4b8c14b50528a740eef6d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/87ba694401df1d06dda4b8c14b50528a740eef6d"}], "stats": {"total": 54, "additions": 47, "deletions": 7}, "files": [{"sha": "6c2b370af8a75bbbe4327fac318fe2706710df92", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d02b6c26134b170071255fad492963561dfbd50/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d02b6c26134b170071255fad492963561dfbd50/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5d02b6c26134b170071255fad492963561dfbd50", "patch": "@@ -1,3 +1,11 @@\n+Sat Apr 17 22:54:17 1999  Richard Henderson  <rth@cygnus.com>\n+\n+\t* alpha.h (REG_OK_FP_BASE_P): New macro.\n+\t(GO_IF_LEGITIMATE_SIMPLE_ADDRESS): Use it.\n+\t* alpha.md (adddi3+1): New insn to handle large constants off \n+\tthe soft frame pointer.\n+\t(adddi3+2): Don't split soft frame pointer or arg pointer additions.\n+\n Sun Apr 18 17:24:10 1999  Michael Hayes  <m.hayes@elec.canterbury.ac.nz>\n \n \t* config/c4x/c4x.c (legitimize_operands): Use rtx_cost"}, {"sha": "2026ca9760bb98b69e773f09480fb51fd4b70d07", "filename": "gcc/config/alpha/alpha.h", "status": "modified", "additions": 22, "deletions": 4, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d02b6c26134b170071255fad492963561dfbd50/gcc%2Fconfig%2Falpha%2Falpha.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d02b6c26134b170071255fad492963561dfbd50/gcc%2Fconfig%2Falpha%2Falpha.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.h?ref=5d02b6c26134b170071255fad492963561dfbd50", "patch": "@@ -1386,18 +1386,32 @@ extern void alpha_init_expanders ();\n /* Nonzero if X is a hard reg that can be used as an index\n    or if it is a pseudo reg.  */\n #define REG_OK_FOR_INDEX_P(X) 0\n+\n /* Nonzero if X is a hard reg that can be used as a base reg\n    or if it is a pseudo reg.  */\n #define REG_OK_FOR_BASE_P(X)  \\\n   (REGNO (X) < 32 || REGNO (X) == 63 || REGNO (X) >= FIRST_PSEUDO_REGISTER)\n \n+/* ??? Nonzero if X is the frame pointer, or some virtual register\n+   that may eliminate to the frame pointer.  These will be allowed to\n+   have offsets greater than 32K.  This is done because register\n+   elimination offsets will change the hi/lo split, and if we split\n+   before reload, we will require additional instructions.   */\n+#define REG_OK_FP_BASE_P(X)\t\t\t\\\n+  (REGNO (X) == 31 || REGNO (X) == 63\t\t\\\n+   || (REGNO (X) >= FIRST_PSEUDO_REGISTER\t\\\n+       && REGNO (X) < LAST_VIRTUAL_REGISTER))\n+\n #else\n \n /* Nonzero if X is a hard reg that can be used as an index.  */\n #define REG_OK_FOR_INDEX_P(X) REGNO_OK_FOR_INDEX_P (REGNO (X))\n+\n /* Nonzero if X is a hard reg that can be used as a base reg.  */\n #define REG_OK_FOR_BASE_P(X) REGNO_OK_FOR_BASE_P (REGNO (X))\n \n+#define REG_OK_FP_BASE_P(X) 0\n+\n #endif\n \f\n /* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression\n@@ -1418,10 +1432,14 @@ extern void alpha_init_expanders ();\n   if (CONSTANT_ADDRESS_P (X))\t\t\t\\\n     goto ADDR;\t\t\t\t\t\\\n   if (GET_CODE (X) == PLUS\t\t\t\\\n-      && REG_P (XEXP (X, 0))\t\t\t\\\n-      && REG_OK_FOR_BASE_P (XEXP (X, 0))\t\\\n-      && CONSTANT_ADDRESS_P (XEXP (X, 1)))\t\\\n-    goto ADDR;\t\t\t\t\t\\\n+      && REG_P (XEXP (X, 0)))\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      if (REG_OK_FP_BASE_P (XEXP (X, 0)))\t\\\n+\tgoto ADDR;\t\t\t\t\\\n+      if (REG_OK_FOR_BASE_P (XEXP (X, 0))\t\\\n+\t  && CONSTANT_ADDRESS_P (XEXP (X, 1)))\t\\\n+\tgoto ADDR;\t\t\t\t\\\n+    }\t\t\t\t\t\t\\\n }\n \n /* Now accept the simple address, or, for DImode only, an AND of a simple"}, {"sha": "501443799afdac87a30469e976ece32364f55adf", "filename": "gcc/config/alpha/alpha.md", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d02b6c26134b170071255fad492963561dfbd50/gcc%2Fconfig%2Falpha%2Falpha.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d02b6c26134b170071255fad492963561dfbd50/gcc%2Fconfig%2Falpha%2Falpha.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.md?ref=5d02b6c26134b170071255fad492963561dfbd50", "patch": "@@ -563,14 +563,28 @@\n   return pattern[which];\n }\")\n \n-;; Don't do this if we are adjusting SP since we don't want to do\n-;; it in two steps. \n+;; ??? Allow large constants when basing off the frame pointer or some\n+;; virtual register that may eliminate to the frame pointer.  This is\n+;; done because register elimination offsets will change the hi/lo split,\n+;; and if we split before reload, we will require additional instructions.\n+\n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+        (plus:DI (match_operand:DI 1 \"reg_no_subreg_operand\" \"r\")\n+\t\t (match_operand:DI 2 \"const_int_operand\" \"n\")))]\n+  \"REG_OK_FP_BASE_P (operands[1])\"\n+  \"#\")\n+\n+;; Don't do this if we are adjusting SP since we don't want to do it\n+;; in two steps.  Don't split FP sources for the reason listed above.\n (define_split\n   [(set (match_operand:DI 0 \"register_operand\" \"\")\n \t(plus:DI (match_operand:DI 1 \"register_operand\" \"\")\n \t\t (match_operand:DI 2 \"const_int_operand\" \"\")))]\n   \"! add_operand (operands[2], DImode)\n-   && operands[0] != stack_pointer_rtx\"\n+   && operands[0] != stack_pointer_rtx\n+   && operands[1] != frame_pointer_rtx\n+   && operands[1] != arg_pointer_rtx\"\n   [(set (match_dup 0) (plus:DI (match_dup 1) (match_dup 3)))\n    (set (match_dup 0) (plus:DI (match_dup 0) (match_dup 4)))]\n   \""}]}