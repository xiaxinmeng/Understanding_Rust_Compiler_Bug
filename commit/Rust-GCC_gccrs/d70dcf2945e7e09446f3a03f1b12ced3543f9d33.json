{"sha": "d70dcf2945e7e09446f3a03f1b12ced3543f9d33", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDcwZGNmMjk0NWU3ZTA5NDQ2ZjNhMDNmMWIxMmNlZDM1NDNmOWQzMw==", "commit": {"author": {"name": "Kenneth Zadeck", "email": "zadeck@naturalbridge.com", "date": "2008-05-14T12:24:43Z"}, "committer": {"name": "Kenneth Zadeck", "email": "zadeck@gcc.gnu.org", "date": "2008-05-14T12:24:43Z"}, "message": "rtl.texi: Removed reference to REG_NO_CONFLICT notes.\n\n2008-05-14  Kenneth Zadeck <zadeck@naturalbridge.com>\n\n\t* doc/rtl.texi: Removed reference to REG_NO_CONFLICT notes.\n\t* optabs.c (expand_binop, expand_absneg_bit, expand_unop,\n\texpand_copysign_bit, ): Change call to emit_no_conflict_block to\n\temit_insn and remove unneeded code to construct extra args.\n\t(emit_no_conflict_block): Removed.\n\t* optabls.h: (emit_no_conflict_block): Removed.\n\t* cse.c (cse_extended_basic_block): Remove search for\n\tREG_NO_CONFLICT note.  \n\t* global.c: Removed incorrect comment added in revision 117.\n\t* expr.c (convert_move): Change call to emit_no_conflict_block to\n\temit_insn.\n\t* recog.c: Change comments so that they do not mention\n\tREG_NO_CONFLICT.\n\t* local_alloc.c (combine_regs): Removed last parameter.\n\t(no_conflict_p): Removed.\n\t(block_alloc): Removed note, no_conflict_combined_regno and set\n\tlocal vars. Removed all code to process REG_NO_CONFLICT blocks.\n\t(combine_regs): Removed already_dead and code to look for\n\tREG_NO_CONFLICT notes.\n\t* lower_subreg (remove_retval_note): Removed code to look for\n\tREG_NO_CONFLICT block.\n\t(resolve_reg_notes): Removed REG_NO_CONFLICT case.\n\t(resolve_clobber): Remove code to process libcalls that have\n\tREG_NO_CONFLICT notes.\n\t* loop_invariant.c (find_invariant_insn): Removed REG_NO_CONFLICT\n\tcase.\n\t* combine.c (can_combine_p, distribute_notes):  Removed REG_NO_CONFLICT\n\tcase.\n\t* config/cris/cris.md (movdi pattern): Changed\n\temit_no_conflict_block to emit_insns.\n\t* config/mn10300/mn10300.md (absdf2, negdf2 patterns): Ditto.\n\t* config/m68k/m68k.md (negdf2, negxf2, absdf2, absxf2 patterns):\n\tDitto. \n\t* reg-notes.def (NO_CONFLICT): Removed.\n\nFrom-SVN: r135289", "tree": {"sha": "1b9cd90a2e69bb7ed2a67500e6e2e2262544cf81", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1b9cd90a2e69bb7ed2a67500e6e2e2262544cf81"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d70dcf2945e7e09446f3a03f1b12ced3543f9d33", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d70dcf2945e7e09446f3a03f1b12ced3543f9d33", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d70dcf2945e7e09446f3a03f1b12ced3543f9d33", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d70dcf2945e7e09446f3a03f1b12ced3543f9d33/comments", "author": {"login": "zadeck", "id": 42682403, "node_id": "MDQ6VXNlcjQyNjgyNDAz", "avatar_url": "https://avatars.githubusercontent.com/u/42682403?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zadeck", "html_url": "https://github.com/zadeck", "followers_url": "https://api.github.com/users/zadeck/followers", "following_url": "https://api.github.com/users/zadeck/following{/other_user}", "gists_url": "https://api.github.com/users/zadeck/gists{/gist_id}", "starred_url": "https://api.github.com/users/zadeck/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zadeck/subscriptions", "organizations_url": "https://api.github.com/users/zadeck/orgs", "repos_url": "https://api.github.com/users/zadeck/repos", "events_url": "https://api.github.com/users/zadeck/events{/privacy}", "received_events_url": "https://api.github.com/users/zadeck/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "cc44abe6a5bedb27256cfb8b2c9d42c3873ceacd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc44abe6a5bedb27256cfb8b2c9d42c3873ceacd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cc44abe6a5bedb27256cfb8b2c9d42c3873ceacd"}], "stats": {"total": 443, "additions": 70, "deletions": 373}, "files": [{"sha": "223fe39ad034d9d731d8a7c7d4c929c7965d0394", "filename": "gcc/ChangeLog", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d70dcf2945e7e09446f3a03f1b12ced3543f9d33/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d70dcf2945e7e09446f3a03f1b12ced3543f9d33/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d70dcf2945e7e09446f3a03f1b12ced3543f9d33", "patch": "@@ -1,3 +1,40 @@\n+2008-05-14  Kenneth Zadeck <zadeck@naturalbridge.com>\n+\n+\t* doc/rtl.texi: Removed reference to REG_NO_CONFLICT notes.\n+\t* optabs.c (expand_binop, expand_absneg_bit, expand_unop,\n+\texpand_copysign_bit, ): Change call to emit_no_conflict_block to\n+\temit_insn and remove unneeded code to construct extra args.\n+\t(emit_no_conflict_block): Removed.\n+\t* optabls.h: (emit_no_conflict_block): Removed.\n+\t* cse.c (cse_extended_basic_block): Remove search for\n+\tREG_NO_CONFLICT note.  \n+\t* global.c: Removed incorrect comment added in revision 117.\n+\t* expr.c (convert_move): Change call to emit_no_conflict_block to\n+\temit_insn.\n+\t* recog.c: Change comments so that they do not mention\n+\tREG_NO_CONFLICT.\n+\t* local_alloc.c (combine_regs): Removed last parameter.\n+\t(no_conflict_p): Removed.\n+\t(block_alloc): Removed note, no_conflict_combined_regno and set\n+\tlocal vars. Removed all code to process REG_NO_CONFLICT blocks.\n+\t(combine_regs): Removed already_dead and code to look for\n+\tREG_NO_CONFLICT notes.\n+\t* lower_subreg (remove_retval_note): Removed code to look for\n+\tREG_NO_CONFLICT block.\n+\t(resolve_reg_notes): Removed REG_NO_CONFLICT case.\n+\t(resolve_clobber): Remove code to process libcalls that have\n+\tREG_NO_CONFLICT notes.\n+\t* loop_invariant.c (find_invariant_insn): Removed REG_NO_CONFLICT\n+\tcase.\n+\t* combine.c (can_combine_p, distribute_notes):  Removed REG_NO_CONFLICT\n+\tcase.\n+\t* config/cris/cris.md (movdi pattern): Changed\n+\temit_no_conflict_block to emit_insns.\n+\t* config/mn10300/mn10300.md (absdf2, negdf2 patterns): Ditto.\n+\t* config/m68k/m68k.md (negdf2, negxf2, absdf2, absxf2 patterns):\n+\tDitto. \n+\t* reg-notes.def (NO_CONFLICT): Removed.\n+\t\n 2008-05-14  David S. Miller  <davem@davemloft.net>\n \n \t* config/sparc/sparc.c (sparc_profile_hook): If"}, {"sha": "42940a3c0463cb74ba9ada0eb97afce6c900f556", "filename": "gcc/combine.c", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d70dcf2945e7e09446f3a03f1b12ced3543f9d33/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d70dcf2945e7e09446f3a03f1b12ced3543f9d33/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=d70dcf2945e7e09446f3a03f1b12ced3543f9d33", "patch": "@@ -1653,7 +1653,7 @@ can_combine_p (rtx insn, rtx i3, rtx pred ATTRIBUTE_UNUSED, rtx succ,\n   /* Don't eliminate a store in the stack pointer.  */\n   if (dest == stack_pointer_rtx\n       /* Don't combine with an insn that sets a register to itself if it has\n-\t a REG_EQUAL note.  This may be part of a REG_NO_CONFLICT sequence.  */\n+\t a REG_EQUAL note.  This may be part of a LIBCALL sequence.  */\n       || (rtx_equal_p (src, dest) && find_reg_note (insn, REG_EQUAL, NULL_RTX))\n       /* Can't merge an ASM_OPERANDS.  */\n       || GET_CODE (src) == ASM_OPERANDS\n@@ -1696,10 +1696,6 @@ can_combine_p (rtx insn, rtx i3, rtx pred ATTRIBUTE_UNUSED, rtx succ,\n \t       && use_crosses_set_p (src, DF_INSN_LUID (insn)))\n \t      || (GET_CODE (src) == ASM_OPERANDS && MEM_VOLATILE_P (src))\n \t      || GET_CODE (src) == UNSPEC_VOLATILE))\n-      /* If there is a REG_NO_CONFLICT note for DEST in I3 or SUCC, we get\n-\t better register allocation by not doing the combine.  */\n-      || find_reg_note (i3, REG_NO_CONFLICT, dest)\n-      || (succ && find_reg_note (succ, REG_NO_CONFLICT, dest))\n       /* Don't combine across a CALL_INSN, because that would possibly\n \t change whether the life span of some REGs crosses calls or not,\n \t and it is a pain to update that information.\n@@ -12460,7 +12456,6 @@ distribute_notes (rtx notes, rtx from_insn, rtx i3, rtx i2, rtx elim_i2,\n \t  break;\n \n \tcase REG_INC:\n-\tcase REG_NO_CONFLICT:\n \t  /* These notes say something about how a register is used.  They must\n \t     be present on any use of the register in I2 or I3.  */\n \t  if (reg_mentioned_p (XEXP (note, 0), PATTERN (i3)))"}, {"sha": "9e3ec027d3811d70437ceb182b1ab803fa6ad158", "filename": "gcc/config/cris/cris.md", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d70dcf2945e7e09446f3a03f1b12ced3543f9d33/gcc%2Fconfig%2Fcris%2Fcris.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d70dcf2945e7e09446f3a03f1b12ced3543f9d33/gcc%2Fconfig%2Fcris%2Fcris.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris.md?ref=d70dcf2945e7e09446f3a03f1b12ced3543f9d33", "patch": "@@ -547,9 +547,7 @@\n      gcc.c-torture/execute/961213-1.c shows that CSE2 gets confused by the\n      resulting subreg sets when using the construct from mcore (as of FSF\n      CVS, version -r 1.5), and it believes that the high part (the last one\n-     emitted) is the final value.  This construct from romp seems more\n-     robust, especially considering the head comments from\n-     emit_no_conflict_block.  */\n+     emitted) is the final value.  */\n   if ((CONST_INT_P (operands[1]) || GET_CODE (operands[1]) == CONST_DOUBLE)\n       && ! reload_completed\n       && ! reload_in_progress)\n@@ -566,7 +564,7 @@\n       insns = get_insns ();\n       end_sequence ();\n \n-      emit_no_conflict_block (insns, op0, op1, 0, op1);\n+      emit_insn (insns);\n       DONE;\n     }\n })"}, {"sha": "56c459e68b0c5dd359ff2f2b428a26fb74bc4dc0", "filename": "gcc/config/m68k/m68k.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d70dcf2945e7e09446f3a03f1b12ced3543f9d33/gcc%2Fconfig%2Fm68k%2Fm68k.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d70dcf2945e7e09446f3a03f1b12ced3543f9d33/gcc%2Fconfig%2Fm68k%2Fm68k.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.md?ref=d70dcf2945e7e09446f3a03f1b12ced3543f9d33", "patch": "@@ -4092,7 +4092,7 @@\n       insns = get_insns ();\n       end_sequence ();\n \n-      emit_no_conflict_block (insns, operands[0], operands[1], 0, 0);\n+      emit_insn (insns);\n       DONE;\n     }\n })\n@@ -4126,7 +4126,7 @@\n       insns = get_insns ();\n       end_sequence ();\n \n-      emit_no_conflict_block (insns, operands[0], operands[1], 0, 0);\n+      emit_insn (insns);\n       DONE;\n     }\n })\n@@ -4245,7 +4245,7 @@\n       insns = get_insns ();\n       end_sequence ();\n \n-      emit_no_conflict_block (insns, operands[0], operands[1], 0, 0);\n+      emit_insn (insns);\n       DONE;\n     }\n })\n@@ -4279,7 +4279,7 @@\n       insns = get_insns ();\n       end_sequence ();\n \n-      emit_no_conflict_block (insns, operands[0], operands[1], 0, 0);\n+      emit_insn (insns);\n       DONE;\n     }\n })"}, {"sha": "57c51625b227eb77a13b0e76f3372d6065f0b5aa", "filename": "gcc/config/mn10300/mn10300.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d70dcf2945e7e09446f3a03f1b12ced3543f9d33/gcc%2Fconfig%2Fmn10300%2Fmn10300.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d70dcf2945e7e09446f3a03f1b12ced3543f9d33/gcc%2Fconfig%2Fmn10300%2Fmn10300.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.md?ref=d70dcf2945e7e09446f3a03f1b12ced3543f9d33", "patch": "@@ -2203,7 +2203,7 @@\n   insns = get_insns ();\n   end_sequence ();\n \n-  emit_no_conflict_block (insns, operands[0], operands[1], 0, 0);\n+  emit_insn (insns);\n   DONE;\n }\")\n \n@@ -2272,7 +2272,7 @@\n   insns = get_insns ();\n   end_sequence ();\n \n-  emit_no_conflict_block (insns, operands[0], operands[1], 0, 0);\n+  emit_insn (insns);\n   DONE;\n }\")\n "}, {"sha": "ffe7efb600663f7a3473319f0b5c768afa6fb64d", "filename": "gcc/cse.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d70dcf2945e7e09446f3a03f1b12ced3543f9d33/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d70dcf2945e7e09446f3a03f1b12ced3543f9d33/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=d70dcf2945e7e09446f3a03f1b12ced3543f9d33", "patch": "@@ -6059,8 +6059,6 @@ cse_extended_basic_block (struct cse_basic_block_data *ebb_data)\n \t\t      else\n \t\t\tno_conflict = -1;\n \t\t    }\n-\t\t  else if (find_reg_note (insn, REG_NO_CONFLICT, NULL_RTX))\n-\t\t    no_conflict = 1;\n \t\t}\n \n \t      cse_insn (insn, libcall_insn);"}, {"sha": "96de36503faf132fa8cdedc585e71aa2485b8b3c", "filename": "gcc/doc/rtl.texi", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d70dcf2945e7e09446f3a03f1b12ced3543f9d33/gcc%2Fdoc%2Frtl.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d70dcf2945e7e09446f3a03f1b12ced3543f9d33/gcc%2Fdoc%2Frtl.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Frtl.texi?ref=d70dcf2945e7e09446f3a03f1b12ced3543f9d33", "patch": "@@ -3641,23 +3641,6 @@ instructions, such as the m68k dbra, can be matched.\n The @code{REG_NONNEG} note is added to insns only if the machine\n description has a @samp{decrement_and_branch_until_zero} pattern.\n \n-@findex REG_NO_CONFLICT\n-@item REG_NO_CONFLICT\n-This insn does not cause a conflict between @var{op} and the item\n-being set by this insn even though it might appear that it does.\n-In other words, if the destination register and @var{op} could\n-otherwise be assigned the same register, this insn does not\n-prevent that assignment.\n-\n-Insns with this note are usually part of a block that begins with a\n-@code{clobber} insn specifying a multi-word pseudo register (which will\n-be the output of the block), a group of insns that each set one word of\n-the value and have the @code{REG_NO_CONFLICT} note attached, and a final\n-insn that copies the output to itself with an attached @code{REG_EQUAL}\n-note giving the expression being computed.  This block is encapsulated\n-with @code{REG_LIBCALL} and @code{REG_RETVAL} notes on the first and\n-last insns, respectively.\n-\n @findex REG_LABEL_OPERAND\n @item REG_LABEL_OPERAND\n This insn uses @var{op}, a @code{code_label} or a @code{note} of type"}, {"sha": "d2fc6d0cc5f848597b1313af8c6844829745459e", "filename": "gcc/expr.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d70dcf2945e7e09446f3a03f1b12ced3543f9d33/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d70dcf2945e7e09446f3a03f1b12ced3543f9d33/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=d70dcf2945e7e09446f3a03f1b12ced3543f9d33", "patch": "@@ -625,8 +625,7 @@ convert_move (rtx to, rtx from, int unsignedp)\n       insns = get_insns ();\n       end_sequence ();\n \n-      emit_no_conflict_block (insns, to, from, NULL_RTX,\n-\t\t\t      gen_rtx_fmt_e (equiv_code, to_mode, copy_rtx (from)));\n+      emit_insn (insns);\n       return;\n     }\n "}, {"sha": "cddcac3d0acc8c5f62a316fe603e1394c4f05e92", "filename": "gcc/global.c", "status": "modified", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d70dcf2945e7e09446f3a03f1b12ced3543f9d33/gcc%2Fglobal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d70dcf2945e7e09446f3a03f1b12ced3543f9d33/gcc%2Fglobal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fglobal.c?ref=d70dcf2945e7e09446f3a03f1b12ced3543f9d33", "patch": "@@ -131,31 +131,6 @@ static int local_reg_live_length[FIRST_PSEUDO_REGISTER];\n \n #define SET_REGBIT(TABLE, I, J)  SET_HARD_REG_BIT (allocno[I].TABLE, J)\n \n-/* This is turned off because it doesn't work right for DImode.\n-   (And it is only used for DImode, so the other cases are worthless.)\n-   The problem is that it isn't true that there is NO possibility of conflict;\n-   only that there is no conflict if the two pseudos get the exact same regs.\n-   If they were allocated with a partial overlap, there would be a conflict.\n-   We can't safely turn off the conflict unless we have another way to\n-   prevent the partial overlap.\n-\n-   Idea: change hard_reg_conflicts so that instead of recording which\n-   hard regs the allocno may not overlap, it records where the allocno\n-   may not start.  Change both where it is used and where it is updated.\n-   Then there is a way to record that (reg:DI 108) may start at 10\n-   but not at 9 or 11.  There is still the question of how to record\n-   this semi-conflict between two pseudos.  */\n-#if 0\n-/* Reg pairs for which conflict after the current insn\n-   is inhibited by a REG_NO_CONFLICT note.\n-   If the table gets full, we ignore any other notes--that is conservative.  */\n-#define NUM_NO_CONFLICT_PAIRS 4\n-/* Number of pairs in use in this insn.  */\n-int n_no_conflict_pairs;\n-static struct { int allocno1, allocno2;}\n-  no_conflict_pairs[NUM_NO_CONFLICT_PAIRS];\n-#endif /* 0 */\n-\n /* Return true if *LOC contains an asm.  */\n \n static int"}, {"sha": "0ee20b2c3ab0cf12306f06feb355cc4844029646", "filename": "gcc/local-alloc.c", "status": "modified", "additions": 8, "deletions": 126, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d70dcf2945e7e09446f3a03f1b12ced3543f9d33/gcc%2Flocal-alloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d70dcf2945e7e09446f3a03f1b12ced3543f9d33/gcc%2Flocal-alloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flocal-alloc.c?ref=d70dcf2945e7e09446f3a03f1b12ced3543f9d33", "patch": "@@ -305,7 +305,7 @@ static int qty_sugg_compare (int, int);\n static int qty_sugg_compare_1 (const void *, const void *);\n static int qty_compare (int, int);\n static int qty_compare_1 (const void *, const void *);\n-static int combine_regs (rtx, rtx, int, int, rtx, int);\n+static int combine_regs (rtx, rtx, int, int, rtx);\n static int reg_meets_class_p (int, enum reg_class);\n static void update_qty_class (int, int);\n static void reg_is_set (rtx, const_rtx, void *);\n@@ -315,7 +315,6 @@ static int find_free_reg (enum reg_class, enum machine_mode, int, int, int,\n \t\t\t  int, int);\n static void mark_life (int, enum machine_mode, int);\n static void post_mark_life (int, enum machine_mode, int, int, int);\n-static int no_conflict_p (rtx, rtx, rtx);\n static int requires_inout (const char *);\n \f\n /* Allocate a new quantity (new within current basic block)\n@@ -1271,12 +1270,11 @@ block_alloc (int b)\n {\n   int i, q;\n   rtx insn;\n-  rtx note, hard_reg;\n+  rtx hard_reg;\n   int insn_number = 0;\n   int insn_count = 0;\n   int max_uid = get_max_uid ();\n   int *qty_order;\n-  int no_conflict_combined_regno = -1;\n   struct df_ref ** def_rec;\n \n   /* Count the instructions in the basic block.  */\n@@ -1326,7 +1324,7 @@ block_alloc (int b)\n \n       if (INSN_P (insn))\n \t{\n-\t  rtx link, set;\n+\t  rtx link;\n \t  int win = 0;\n \t  rtx r0, r1 = NULL_RTX;\n \t  int combined_regno = -1;\n@@ -1433,63 +1431,13 @@ block_alloc (int b)\n \n \t\t      if (REG_P (r1) || GET_CODE (r1) == SUBREG)\n \t\t\twin = combine_regs (r1, r0, may_save_copy,\n-\t\t\t\t\t    insn_number, insn, 0);\n+\t\t\t\t\t    insn_number, insn);\n \t\t    }\n \t\t  if (win)\n \t\t    break;\n \t\t}\n \t    }\n \n-\t  /* Recognize an insn sequence with an ultimate result\n-\t     which can safely overlap one of the inputs.\n-\t     The sequence begins with a CLOBBER of its result,\n-\t     and ends with an insn that copies the result to itself\n-\t     and has a REG_EQUAL note for an equivalent formula.\n-\t     That note indicates what the inputs are.\n-\t     The result and the input can overlap if each insn in\n-\t     the sequence either doesn't mention the input\n-\t     or has a REG_NO_CONFLICT note to inhibit the conflict.\n-\n-\t     We do the combining test at the CLOBBER so that the\n-\t     destination register won't have had a quantity number\n-\t     assigned, since that would prevent combining.  */\n-\n-\t  if (optimize\n-\t      && GET_CODE (PATTERN (insn)) == CLOBBER\n-\t      && (r0 = XEXP (PATTERN (insn), 0),\n-\t\t  REG_P (r0))\n-\t      && (link = find_reg_note (insn, REG_LIBCALL, NULL_RTX)) != 0\n-\t      && XEXP (link, 0) != 0\n-\t      && NONJUMP_INSN_P (XEXP (link, 0))\n-\t      && (set = single_set (XEXP (link, 0))) != 0\n-\t      && SET_DEST (set) == r0 && SET_SRC (set) == r0\n-\t      && (note = find_reg_note (XEXP (link, 0), REG_EQUAL,\n-\t\t\t\t\tNULL_RTX)) != 0)\n-\t    {\n-\t      if (r1 = XEXP (note, 0), REG_P (r1)\n-\t\t  /* Check that we have such a sequence.  */\n-\t\t  && no_conflict_p (insn, r0, r1))\n-\t\twin = combine_regs (r1, r0, 1, insn_number, insn, 1);\n-\t      else if (GET_RTX_FORMAT (GET_CODE (XEXP (note, 0)))[0] == 'e'\n-\t\t       && (r1 = XEXP (XEXP (note, 0), 0),\n-\t\t\t   REG_P (r1) || GET_CODE (r1) == SUBREG)\n-\t\t       && no_conflict_p (insn, r0, r1))\n-\t\twin = combine_regs (r1, r0, 0, insn_number, insn, 1);\n-\n-\t      /* Here we care if the operation to be computed is\n-\t\t commutative.  */\n-\t      else if (COMMUTATIVE_P (XEXP (note, 0))\n-\t\t       && (r1 = XEXP (XEXP (note, 0), 1),\n-\t\t\t   (REG_P (r1) || GET_CODE (r1) == SUBREG))\n-\t\t       && no_conflict_p (insn, r0, r1))\n-\t\twin = combine_regs (r1, r0, 0, insn_number, insn, 1);\n-\n-\t      /* If we did combine something, show the register number\n-\t\t in question so that we know to ignore its death.  */\n-\t      if (win)\n-\t\tno_conflict_combined_regno = REGNO (r1);\n-\t    }\n-\n \t  /* If registers were just tied, set COMBINED_REGNO\n \t     to the number of the register used in this insn\n \t     that was tied to the register set in this insn.\n@@ -1502,16 +1450,12 @@ block_alloc (int b)\n \t      combined_regno = REGNO (r1);\n \t    }\n \n-\t  /* Mark the death of everything that dies in this instruction,\n-\t     except for anything that was just combined.  */\n+\t  /* Mark the death of everything that dies in this instruction.  */\n \n \t  for (link = REG_NOTES (insn); link; link = XEXP (link, 1))\n \t    if (REG_NOTE_KIND (link) == REG_DEAD\n \t\t&& REG_P (XEXP (link, 0))\n-\t\t&& combined_regno != (int) REGNO (XEXP (link, 0))\n-\t\t&& (no_conflict_combined_regno != (int) REGNO (XEXP (link, 0))\n-\t\t    || ! find_reg_note (insn, REG_NO_CONFLICT,\n-\t\t\t\t\tXEXP (link, 0))))\n+\t\t&& combined_regno != (int) REGNO (XEXP (link, 0)))\n \t      wipe_dead_reg (XEXP (link, 0), 0);\n \n \t  /* Allocate qty numbers for all registers local to this block\n@@ -1530,14 +1474,6 @@ block_alloc (int b)\n \t    if (REG_NOTE_KIND (link) == REG_UNUSED\n \t\t&& REG_P (XEXP (link, 0)))\n \t      wipe_dead_reg (XEXP (link, 0), 1);\n-\n-\t  /* If this is an insn that has a REG_RETVAL note pointing at a\n-\t     CLOBBER insn, we have reached the end of a REG_NO_CONFLICT\n-\t     block, so clear any register number that combined within it.  */\n-\t  if ((note = find_reg_note (insn, REG_RETVAL, NULL_RTX)) != 0\n-\t      && NONJUMP_INSN_P (XEXP (note, 0))\n-\t      && GET_CODE (PATTERN (XEXP (note, 0))) == CLOBBER)\n-\t    no_conflict_combined_regno = -1;\n \t}\n \n       /* Set the registers live after INSN_NUMBER.  Note that we never\n@@ -1833,10 +1769,6 @@ qty_sugg_compare_1 (const void *q1p, const void *q2p)\n    If we really combined them, we could lose if the pseudo lives\n    across an insn that clobbers the hard reg (eg, movmem).\n \n-   ALREADY_DEAD is nonzero if USEDREG is known to be dead even though\n-   there is no REG_DEAD note on INSN.  This occurs during the processing\n-   of REG_NO_CONFLICT blocks.\n-\n    MAY_SAVE_COPY is nonzero if this insn is simply copying USEDREG to\n    SETREG or if the input and output must share a register.\n    In that case, we record a hard reg suggestion in QTY_PHYS_COPY_SUGG.\n@@ -1845,7 +1777,7 @@ qty_sugg_compare_1 (const void *q1p, const void *q2p)\n \n static int\n combine_regs (rtx usedreg, rtx setreg, int may_save_copy, int insn_number,\n-\t      rtx insn, int already_dead)\n+\t      rtx insn)\n {\n   int ureg, sreg;\n   int offset = 0;\n@@ -1935,11 +1867,6 @@ combine_regs (rtx usedreg, rtx setreg, int may_save_copy, int insn_number,\n \t  && usize < qty[reg_qty[ureg]].size)\n       /* Can't combine if SREG is not a register we can allocate.  */\n       || (sreg >= FIRST_PSEUDO_REGISTER && reg_qty[sreg] == -1)\n-      /* Don't combine with a pseudo mentioned in a REG_NO_CONFLICT note.\n-\t These have already been taken care of.  This probably wouldn't\n-\t combine anyway, but don't take any chances.  */\n-      || (ureg >= FIRST_PSEUDO_REGISTER\n-\t  && find_reg_note (insn, REG_NO_CONFLICT, usedreg))\n       /* Don't tie something to itself.  In most cases it would make no\n \t difference, but it would screw up if the reg being tied to itself\n \t also dies in this insn.  */\n@@ -2015,7 +1942,7 @@ combine_regs (rtx usedreg, rtx setreg, int may_save_copy, int insn_number,\n      if this is the last use of UREG, provided the classes they want\n      are compatible.  */\n \n-  if ((already_dead || find_regno_note (insn, REG_DEAD, ureg))\n+  if (find_regno_note (insn, REG_DEAD, ureg)\n       && reg_meets_class_p (sreg, qty[reg_qty[ureg]].min_class))\n     {\n       /* Add SREG to UREG's quantity.  */\n@@ -2395,51 +2322,6 @@ post_mark_life (int regno, enum machine_mode mode, int life, int birth,\n       }\n }\n \f\n-/* INSN is the CLOBBER insn that starts a REG_NO_NOCONFLICT block, R0\n-   is the register being clobbered, and R1 is a register being used in\n-   the equivalent expression.\n-\n-   If R1 dies in the block and has a REG_NO_CONFLICT note on every insn\n-   in which it is used, return 1.\n-\n-   Otherwise, return 0.  */\n-\n-static int\n-no_conflict_p (rtx insn, rtx r0 ATTRIBUTE_UNUSED, rtx r1)\n-{\n-  int ok = 0;\n-  rtx note = find_reg_note (insn, REG_LIBCALL, NULL_RTX);\n-  rtx p, last;\n-\n-  /* If R1 is a hard register, return 0 since we handle this case\n-     when we scan the insns that actually use it.  */\n-\n-  if (note == 0\n-      || (REG_P (r1) && REGNO (r1) < FIRST_PSEUDO_REGISTER)\n-      || (GET_CODE (r1) == SUBREG && REG_P (SUBREG_REG (r1))\n-\t  && REGNO (SUBREG_REG (r1)) < FIRST_PSEUDO_REGISTER))\n-    return 0;\n-\n-  last = XEXP (note, 0);\n-\n-  for (p = NEXT_INSN (insn); p && p != last; p = NEXT_INSN (p))\n-    if (INSN_P (p))\n-      {\n-\tif (find_reg_note (p, REG_DEAD, r1))\n-\t  ok = 1;\n-\n-\t/* There must be a REG_NO_CONFLICT note on every insn, otherwise\n-\t   some earlier optimization pass has inserted instructions into\n-\t   the sequence, and it is not safe to perform this optimization.\n-\t   Note that emit_no_conflict_block always ensures that this is\n-\t   true when these sequences are created.  */\n-\tif (! find_reg_note (p, REG_NO_CONFLICT, r1))\n-\t  return 0;\n-      }\n-\n-  return ok;\n-}\n-\f\n /* Return the number of alternatives for which the constraint string P\n    indicates that the operand must be equal to operand 0 and that no register\n    is acceptable.  */"}, {"sha": "384649d8515aa5c4da50849a0aa7fc5dd3be35c8", "filename": "gcc/loop-invariant.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d70dcf2945e7e09446f3a03f1b12ced3543f9d33/gcc%2Floop-invariant.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d70dcf2945e7e09446f3a03f1b12ced3543f9d33/gcc%2Floop-invariant.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-invariant.c?ref=d70dcf2945e7e09446f3a03f1b12ced3543f9d33", "patch": "@@ -797,8 +797,7 @@ find_invariant_insn (rtx insn, bool always_reached, bool always_executed)\n \n   /* Until we get rid of LIBCALLS.  */\n   if (find_reg_note (insn, REG_RETVAL, NULL_RTX)\n-      || find_reg_note (insn, REG_LIBCALL, NULL_RTX)\n-      || find_reg_note (insn, REG_NO_CONFLICT, NULL_RTX))\n+      || find_reg_note (insn, REG_LIBCALL, NULL_RTX))\n     return;\n \n #ifdef HAVE_cc0"}, {"sha": "219226048ff17d9c573f141e7bd7eb2540147914", "filename": "gcc/lower-subreg.c", "status": "modified", "additions": 2, "deletions": 27, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d70dcf2945e7e09446f3a03f1b12ced3543f9d33/gcc%2Flower-subreg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d70dcf2945e7e09446f3a03f1b12ced3543f9d33/gcc%2Flower-subreg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flower-subreg.c?ref=d70dcf2945e7e09446f3a03f1b12ced3543f9d33", "patch": "@@ -586,7 +586,7 @@ move_libcall_note (rtx old_start, rtx new_start)\n static void\n remove_retval_note (rtx insn1)\n {\n-  rtx note0, insn0, note1, insn;\n+  rtx note0, insn0, note1;\n \n   note1 = find_reg_note (insn1, REG_RETVAL, NULL);\n   if (note1 == NULL_RTX)\n@@ -597,19 +597,6 @@ remove_retval_note (rtx insn1)\n \n   remove_note (insn0, note0);\n   remove_note (insn1, note1);\n-\n-  for (insn = insn0; insn != insn1; insn = NEXT_INSN (insn))\n-    {\n-      while (1)\n-\t{\n-\t  rtx note;\n-\n-\t  note = find_reg_note (insn, REG_NO_CONFLICT, NULL);\n-\t  if (note == NULL_RTX)\n-\t    break;\n-\t  remove_note (insn, note);\n-\t}\n-    }\n }\n \n /* Resolve any decomposed registers which appear in register notes on\n@@ -642,7 +629,6 @@ resolve_reg_notes (rtx insn)\n       note = *pnote;\n       switch (REG_NOTE_KIND (note))\n \t{\n-\tcase REG_NO_CONFLICT:\n \tcase REG_DEAD:\n \tcase REG_UNUSED:\n \t  if (resolve_reg_p (XEXP (note, 0)))\n@@ -897,7 +883,7 @@ resolve_simple_move (rtx set, rtx insn)\n static bool\n resolve_clobber (rtx pat, rtx insn)\n {\n-  rtx reg, note;\n+  rtx reg;\n   enum machine_mode orig_mode;\n   unsigned int words, i;\n   int ret;\n@@ -906,17 +892,6 @@ resolve_clobber (rtx pat, rtx insn)\n   if (!resolve_reg_p (reg) && !resolve_subreg_p (reg))\n     return false;\n \n-  /* If this clobber has a REG_LIBCALL note, then it is the initial\n-     clobber added by emit_no_conflict_block.  We were able to\n-     decompose the register, so we no longer need the clobber.  */\n-  note = find_reg_note (insn, REG_LIBCALL, NULL_RTX);\n-  if (note != NULL_RTX)\n-    {\n-      remove_retval_note (XEXP (note, 0));\n-      delete_insn (insn);\n-      return true;\n-    }\n-\n   orig_mode = GET_MODE (reg);\n   words = GET_MODE_SIZE (orig_mode);\n   words = (words + UNITS_PER_WORD - 1) / UNITS_PER_WORD;"}, {"sha": "0303c203823422837616fe86b3b1ab8018898080", "filename": "gcc/optabs.c", "status": "modified", "additions": 10, "deletions": 146, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d70dcf2945e7e09446f3a03f1b12ced3543f9d33/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d70dcf2945e7e09446f3a03f1b12ced3543f9d33/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=d70dcf2945e7e09446f3a03f1b12ced3543f9d33", "patch": "@@ -1151,8 +1151,7 @@ expand_doubleword_shift (enum machine_mode op1_mode, optab binoptab,\n \n    If we want to multiply two two-word values and have normal and widening\n    multiplies of single-word values, we can do this with three smaller\n-   multiplications.  Note that we do not make a REG_NO_CONFLICT block here\n-   because we are not operating on one word at a time.\n+   multiplications.\n \n    The multiplication proceeds as follows:\n \t\t\t         _______________________\n@@ -1750,7 +1749,7 @@ expand_binop (enum machine_mode mode, optab binoptab, rtx op0, rtx op1,\n \t  else\n \t    equiv_value = 0;\n \n-\t  emit_no_conflict_block (insns, target, op0, op1, equiv_value);\n+\t  emit_insn (insns);\n \t  return target;\n \t}\n     }\n@@ -1785,7 +1784,7 @@ expand_binop (enum machine_mode mode, optab binoptab, rtx op0, rtx op1,\n \t  || (shift_mask == BITS_PER_WORD - 1\n \t      && double_shift_mask == BITS_PER_WORD * 2 - 1))\n \t{\n-\t  rtx insns, equiv_value;\n+\t  rtx insns;\n \t  rtx into_target, outof_target;\n \t  rtx into_input, outof_input;\n \t  int left_shift, outof_word;\n@@ -1819,8 +1818,7 @@ expand_binop (enum machine_mode mode, optab binoptab, rtx op0, rtx op1,\n \t      insns = get_insns ();\n \t      end_sequence ();\n \n-\t      equiv_value = gen_rtx_fmt_ee (binoptab->code, mode, op0, op1);\n-\t      emit_no_conflict_block (insns, target, op0, op1, equiv_value);\n+\t      emit_insn (insns);\n \t      return target;\n \t    }\n \t  end_sequence ();\n@@ -1935,11 +1933,6 @@ expand_binop (enum machine_mode mode, optab binoptab, rtx op0, rtx op1,\n \n       if (inter != 0)\n \t{\n-\t  /* One may be tempted to wrap the insns in a REG_NO_CONFLICT\n-\t     block to help the register allocator a bit.  But a multi-word\n-\t     rotate will need all the input bits when setting the output\n-\t     bits, so there clearly is a conflict between the input and\n-\t     output registers.  So we can't use a no-conflict block here.  */\n \t  emit_insn (insns);\n \t  return target;\n \t}\n@@ -3012,8 +3005,7 @@ expand_absneg_bit (enum rtx_code code, enum machine_mode mode,\n       insns = get_insns ();\n       end_sequence ();\n \n-      temp = gen_rtx_fmt_e (code, mode, copy_rtx (op0));\n-      emit_no_conflict_block (insns, target, op0, NULL_RTX, temp);\n+      emit_insn (insns);\n     }\n   else\n     {\n@@ -3213,9 +3205,7 @@ expand_unop (enum machine_mode mode, optab unoptab, rtx op0, rtx target,\n       insns = get_insns ();\n       end_sequence ();\n \n-      emit_no_conflict_block (insns, target, op0, NULL_RTX,\n-\t\t\t      gen_rtx_fmt_e (unoptab->code, mode,\n-\t\t\t\t\t     copy_rtx (op0)));\n+      emit_insn (insns);\n       return target;\n     }\n \n@@ -3665,7 +3655,7 @@ expand_copysign_bit (enum machine_mode mode, rtx op0, rtx op1, rtx target,\n       insns = get_insns ();\n       end_sequence ();\n \n-      emit_no_conflict_block (insns, target, op0, op1, NULL_RTX);\n+      emit_insn (insns);\n     }\n   else\n     {\n@@ -3777,10 +3767,9 @@ struct no_conflict_data\n   bool must_stay;\n };\n \n-/* Called via note_stores by emit_no_conflict_block and emit_libcall_block.\n-   Set P->must_stay if the currently examined clobber / store has to stay\n-   in the list of insns that constitute the actual no_conflict block /\n-   libcall block.  */\n+/* Called via note_stores by emit_libcall_block.  Set P->must_stay if\n+   the currently examined clobber / store has to stay in the list of\n+   insns that constitute the actual libcall block.  */\n static void\n no_conflict_move_test (rtx dest, const_rtx set, void *p0)\n {\n@@ -3844,131 +3833,6 @@ maybe_encapsulate_block (rtx first, rtx last, rtx equiv)\n     }\n }\n \n-/* Emit code to perform a series of operations on a multi-word quantity, one\n-   word at a time.\n-\n-   Such a block is preceded by a CLOBBER of the output, consists of multiple\n-   insns, each setting one word of the output, and followed by a SET copying\n-   the output to itself.\n-\n-   Each of the insns setting words of the output receives a REG_NO_CONFLICT\n-   note indicating that it doesn't conflict with the (also multi-word)\n-   inputs.  The entire block is surrounded by REG_LIBCALL and REG_RETVAL\n-   notes.\n-\n-   INSNS is a block of code generated to perform the operation, not including\n-   the CLOBBER and final copy.  All insns that compute intermediate values\n-   are first emitted, followed by the block as described above.\n-\n-   TARGET, OP0, and OP1 are the output and inputs of the operations,\n-   respectively.  OP1 may be zero for a unary operation.\n-\n-   EQUIV, if nonzero, is an expression to be placed into a REG_EQUAL note\n-   on the last insn.\n-\n-   If TARGET is not a register, INSNS is simply emitted with no special\n-   processing.  Likewise if anything in INSNS is not an INSN or if\n-   there is a libcall block inside INSNS.\n-\n-   The final insn emitted is returned.  */\n-\n-rtx\n-emit_no_conflict_block (rtx insns, rtx target, rtx op0, rtx op1, rtx equiv)\n-{\n-  rtx prev, next, first, last, insn;\n-\n-  if (!REG_P (target) || reload_in_progress)\n-    return emit_insn (insns);\n-  else\n-    for (insn = insns; insn; insn = NEXT_INSN (insn))\n-      if (!NONJUMP_INSN_P (insn)\n-\t  || find_reg_note (insn, REG_LIBCALL, NULL_RTX))\n-\treturn emit_insn (insns);\n-\n-  /* First emit all insns that do not store into words of the output and remove\n-     these from the list.  */\n-  for (insn = insns; insn; insn = next)\n-    {\n-      rtx note;\n-      struct no_conflict_data data;\n-\n-      next = NEXT_INSN (insn);\n-\n-      /* Some ports (cris) create a libcall regions at their own.  We must\n-\t avoid any potential nesting of LIBCALLs.  */\n-      if ((note = find_reg_note (insn, REG_LIBCALL, NULL)) != NULL)\n-\tremove_note (insn, note);\n-      if ((note = find_reg_note (insn, REG_RETVAL, NULL)) != NULL)\n-\tremove_note (insn, note);\n-\n-      data.target = target;\n-      data.first = insns;\n-      data.insn = insn;\n-      data.must_stay = 0;\n-      note_stores (PATTERN (insn), no_conflict_move_test, &data);\n-      if (! data.must_stay)\n-\t{\n-\t  if (PREV_INSN (insn))\n-\t    NEXT_INSN (PREV_INSN (insn)) = next;\n-\t  else\n-\t    insns = next;\n-\n-\t  if (next)\n-\t    PREV_INSN (next) = PREV_INSN (insn);\n-\n-\t  add_insn (insn);\n-\t}\n-    }\n-\n-  prev = get_last_insn ();\n-\n-  /* Now write the CLOBBER of the output, followed by the setting of each\n-     of the words, followed by the final copy.  */\n-  if (target != op0 && target != op1)\n-    emit_insn (gen_rtx_CLOBBER (VOIDmode, target));\n-\n-  for (insn = insns; insn; insn = next)\n-    {\n-      next = NEXT_INSN (insn);\n-      add_insn (insn);\n-\n-      if (op1 && REG_P (op1))\n-\tREG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_NO_CONFLICT, op1,\n-\t\t\t\t\t      REG_NOTES (insn));\n-\n-      if (op0 && REG_P (op0))\n-\tREG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_NO_CONFLICT, op0,\n-\t\t\t\t\t      REG_NOTES (insn));\n-    }\n-\n-  if (optab_handler (mov_optab, GET_MODE (target))->insn_code\n-      != CODE_FOR_nothing)\n-    {\n-      last = emit_move_insn (target, target);\n-      if (equiv)\n-\tset_unique_reg_note (last, REG_EQUAL, equiv);\n-    }\n-  else\n-    {\n-      last = get_last_insn ();\n-\n-      /* Remove any existing REG_EQUAL note from \"last\", or else it will\n-\t be mistaken for a note referring to the full contents of the\n-\t alleged libcall value when found together with the REG_RETVAL\n-\t note added below.  An existing note can come from an insn\n-\t expansion at \"last\".  */\n-      remove_note (last, find_reg_note (last, REG_EQUAL, NULL_RTX));\n-    }\n-\n-  if (prev == 0)\n-    first = get_insns ();\n-  else\n-    first = NEXT_INSN (prev);\n-\n-  maybe_encapsulate_block (first, last, equiv);\n-\n-  return last;\n-}\n \f\n /* Emit code to make a call to a constant function or a library call.\n "}, {"sha": "8e4f6e769c37ca50516d92ee4be8af0f9de99a5a", "filename": "gcc/optabs.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d70dcf2945e7e09446f3a03f1b12ced3543f9d33/gcc%2Foptabs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d70dcf2945e7e09446f3a03f1b12ced3543f9d33/gcc%2Foptabs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.h?ref=d70dcf2945e7e09446f3a03f1b12ced3543f9d33", "patch": "@@ -710,10 +710,6 @@ extern void emit_unop_insn (int, rtx, rtx, enum rtx_code);\n    REG_LIBCALL_ID notes to all insns in block.  */\n extern void maybe_encapsulate_block (rtx, rtx, rtx);\n \n-/* Emit code to perform a series of operations on a multi-word quantity, one\n-   word at a time.  */\n-extern rtx emit_no_conflict_block (rtx, rtx, rtx, rtx, rtx);\n-\n /* Emit one rtl insn to compare two rtx's.  */\n extern void emit_cmp_insn (rtx, rtx, enum rtx_code, rtx, enum machine_mode,\n \t\t\t   int);"}, {"sha": "ec627a3e08bdab526d408f3f1cf874e3af785ac0", "filename": "gcc/recog.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d70dcf2945e7e09446f3a03f1b12ced3543f9d33/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d70dcf2945e7e09446f3a03f1b12ced3543f9d33/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=d70dcf2945e7e09446f3a03f1b12ced3543f9d33", "patch": "@@ -2646,7 +2646,7 @@ split_all_insns (void)\n \n \t      /* Don't split no-op move insns.  These should silently\n \t\t disappear later in final.  Splitting such insns would\n-\t\t break the code that handles REG_NO_CONFLICT blocks.  */\n+\t\t break the code that handles LIBCALL blocks.  */\n \t      if (set && set_noop_p (set))\n \t\t{\n \t\t  /* Nops get in the way while scheduling, so delete them\n@@ -2701,7 +2701,7 @@ split_all_insns_noflow (void)\n \t{\n \t  /* Don't split no-op move insns.  These should silently\n \t     disappear later in final.  Splitting such insns would\n-\t     break the code that handles REG_NO_CONFLICT blocks.  */\n+\t     break the code that handles LIBCALL blocks.  */\n \t  rtx set = single_set (insn);\n \t  if (set && set_noop_p (set))\n \t    {"}, {"sha": "c9cc1c7819b111f6a9dabb7b333553c1f7d51ef4", "filename": "gcc/reg-notes.def", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d70dcf2945e7e09446f3a03f1b12ced3543f9d33/gcc%2Freg-notes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d70dcf2945e7e09446f3a03f1b12ced3543f9d33/gcc%2Freg-notes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-notes.def?ref=d70dcf2945e7e09446f3a03f1b12ced3543f9d33", "patch": "@@ -76,10 +76,6 @@ REG_NOTE (LIBCALL)\n    will never be added to any instructions.  */\n REG_NOTE (NONNEG)\n \n-/* There is no conflict *after this insn* between the register in the\n-   note and the destination of this insn.  */\n-REG_NOTE (NO_CONFLICT)\n-\n /* Identifies a register set in this insn and never used.  */\n REG_NOTE (UNUSED)\n "}]}