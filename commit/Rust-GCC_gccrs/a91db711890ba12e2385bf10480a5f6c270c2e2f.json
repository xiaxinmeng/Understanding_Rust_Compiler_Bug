{"sha": "a91db711890ba12e2385bf10480a5f6c270c2e2f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTkxZGI3MTE4OTBiYTEyZTIzODViZjEwNDgwYTVmNmMyNzBjMmUyZg==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2003-07-25T10:16:13Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2003-07-25T10:16:13Z"}, "message": "re PR c++/11596 (ICE with int templates)\n\ncp:\n\tPR c++/11596\n\t* pt.c (maybe_fold_nontype_arg, maybe_fold_nontype_args): Remove.\n\t(tsubst_template_arg): New.\n\t(tsubst_template_arg_vector): Rename to ...\n\t(tsubst_template_args): ... this. Accept a TREE_LIST form. Use\n\ttsubst_template_arg.\n\t(coerce_template_parms): Use tsubst_template_arg for default\n\tvalue.\n\t(tsubst_template_parms): Likewise.\n\t(tsubst_aggr_type): Adjust.\n\t(tsubst_decl): Likewise.\n\t(tsubst): Use tsubst_template_arg for a DOMAIN. Adjust.\n\t(tsubst_copy) <TEMPLATE_ID_EXPR case>: Use tsubst_template_args.\ntestsuite:\n\tPR 11596\n\t* g++.dg/template/defarg3.C: New test.\n\n\t* g++.dg/ext/packed2.C: Pack member struct too. Explain why.\n\nFrom-SVN: r69776", "tree": {"sha": "93b81ba56c622ef6f046ebedd0ad9b4aced3cb5d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/93b81ba56c622ef6f046ebedd0ad9b4aced3cb5d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a91db711890ba12e2385bf10480a5f6c270c2e2f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a91db711890ba12e2385bf10480a5f6c270c2e2f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a91db711890ba12e2385bf10480a5f6c270c2e2f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a91db711890ba12e2385bf10480a5f6c270c2e2f/comments", "author": null, "committer": null, "parents": [{"sha": "b6fe0bb8c5a68ed64a124734c3fdc39777f8f7e6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6fe0bb8c5a68ed64a124734c3fdc39777f8f7e6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b6fe0bb8c5a68ed64a124734c3fdc39777f8f7e6"}], "stats": {"total": 287, "additions": 163, "deletions": 124}, "files": [{"sha": "4ad8ce99bd2914e895fb17398f6237e8d5b5f099", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a91db711890ba12e2385bf10480a5f6c270c2e2f/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a91db711890ba12e2385bf10480a5f6c270c2e2f/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=a91db711890ba12e2385bf10480a5f6c270c2e2f", "patch": "@@ -1,11 +1,27 @@\n+2003-07-25  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\tPR c++/11596\n+\t* pt.c (maybe_fold_nontype_arg, maybe_fold_nontype_args): Remove.\n+\t(tsubst_template_arg): New.\n+\t(tsubst_template_arg_vector): Rename to ...\n+\t(tsubst_template_args): ... this. Accept a TREE_LIST form. Use\n+\ttsubst_template_arg.\n+\t(coerce_template_parms): Use tsubst_template_arg for default\n+\tvalue.\n+\t(tsubst_template_parms): Likewise.\n+\t(tsubst_aggr_type): Adjust.\n+\t(tsubst_decl): Likewise.\n+\t(tsubst): Use tsubst_template_arg for a DOMAIN. Adjust.\n+\t(tsubst_copy) <TEMPLATE_ID_EXPR case>: Use tsubst_template_args.\n+\n 2003-07-25 Gabriel Dos Reis  <gdr@integrable-solutions.net>\n \n \t* Make-lang.in (cp/error.o): Depend on DIAGNOSTIC_H.\n-\t* error.c: Use the new pretty-printer fraamework.\n+\t* error.c: Use the new pretty-printer framework.\n \n 2003-07-24  Per Bothner  <pbothner@apple.com>\n \n-\t* decl.c (pushdecl_class_level):   Don't use push_srcloc/pop_srcloc\n+\t* decl.c (pushdecl_class_level): Don't use push_srcloc/pop_srcloc\n \twhich causes errors messages to incorrectly mention included files.\n \n 2003-07-24  Mark Mitchell  <mark@codesourcery.com>"}, {"sha": "013e805bc26b2746f0fd0ac660bdc6a96cd4c994", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 114, "deletions": 119, "changes": 233, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a91db711890ba12e2385bf10480a5f6c270c2e2f/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a91db711890ba12e2385bf10480a5f6c270c2e2f/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=a91db711890ba12e2385bf10480a5f6c270c2e2f", "patch": "@@ -111,8 +111,6 @@ static int maybe_adjust_types_for_deduction (unification_kind_t, tree*, tree*);\n static int  type_unification_real (tree, tree, tree, tree,\n \t\t\t\t   int, unification_kind_t, int, int);\n static void note_template_header (int);\n-static tree maybe_fold_nontype_arg (tree);\n-static void maybe_fold_nontype_args (tree);\n static tree convert_nontype_argument (tree, tree);\n static tree convert_template_argument (tree, tree, tree,\n \t\t\t\t       tsubst_flags_t, int, tree);\n@@ -136,7 +134,8 @@ static tree get_bindings (tree, tree, tree);\n static tree get_bindings_real (tree, tree, tree, int, int, int);\n static int template_decl_level (tree);\n static int check_cv_quals_for_unify (int, tree, tree);\n-static tree tsubst_template_arg_vector (tree, tree, tsubst_flags_t);\n+static tree tsubst_template_arg (tree, tree, tsubst_flags_t, tree);\n+static tree tsubst_template_args (tree, tree, tsubst_flags_t, tree);\n static tree tsubst_template_parms (tree, tree, tsubst_flags_t);\n static void regenerate_decl_from_template (tree, tree);\n static tree most_specialized (tree, tree, tree);\n@@ -3641,19 +3640,11 @@ coerce_template_parms (tree parms,\n \t}\n       else if (i < nargs)\n \targ = TREE_VEC_ELT (inner_args, i);\n-      /* If no template argument was supplied, look for a default\n-\t value.  */\n-      else if (TREE_PURPOSE (parm) == NULL_TREE)\n-\t{\n-\t  /* There was no default value.  */\n-\t  my_friendly_assert (!require_all_arguments, 0);\n-\t  break;\n-\t}\n-      else if (TREE_CODE (TREE_VALUE (parm)) == TYPE_DECL)\n-\targ = tsubst (TREE_PURPOSE (parm), new_args, complain, in_decl);\n       else\n-\targ = tsubst_expr (TREE_PURPOSE (parm), new_args, complain,\n-\t\t\t   in_decl);\n+        /* If no template argument was supplied, look for a default\n+\t   value.  */\n+\targ = tsubst_template_arg (TREE_PURPOSE (parm), new_args,\n+\t\t\t\t   complain, in_decl);\n \n       /* Now, convert the Ith argument, as necessary.  */\n       if (arg == NULL_TREE)\n@@ -5473,97 +5464,103 @@ list_eq (tree t1, tree t2)\n   return list_eq (TREE_CHAIN (t1), TREE_CHAIN (t2));\n }\n \n-/* If arg is a non-type template parameter that does not depend on template\n-   arguments, fold it like we weren't in the body of a template.  */\n-\n static tree\n-maybe_fold_nontype_arg (tree arg)\n+tsubst_template_arg (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n {\n-  if (arg && !TYPE_P (arg) && !uses_template_parms (arg))\n+  tree r;\n+  \n+  if (!t)\n+    r = t;\n+  else if (TYPE_P (t))\n+    r = tsubst (t, args, complain, in_decl);\n+  else\n     {\n-      /* Sometimes, one of the args was an expression involving a\n-\t template constant parameter, like N - 1.  Now that we've\n-\t tsubst'd, we might have something like 2 - 1.  This will\n-\t confuse lookup_template_class, so we do constant folding\n-\t here.  We have to unset processing_template_decl, to fool\n-\t tsubst_copy_and_build() into building an actual tree.  */\n+      r = tsubst_expr (t, args, complain, in_decl);\n \n-      /* If the TREE_TYPE of ARG is not NULL_TREE, ARG is already\n-\t as simple as it's going to get, and trying to reprocess\n-\t the trees will break.  */\n-      if (!TREE_TYPE (arg))\n+      if (!uses_template_parms (r))\n \t{\n-\t  int saved_processing_template_decl = processing_template_decl; \n-\t  processing_template_decl = 0;\n-\t  arg = tsubst_copy_and_build (arg,\n-\t\t\t\t       /*args=*/NULL_TREE,\n-\t\t\t\t       tf_error,\n-\t\t\t\t       /*in_decl=*/NULL_TREE,\n-\t\t\t\t       /*function_p=*/false);\n-\t  processing_template_decl = saved_processing_template_decl; \n+\t  /* Sometimes, one of the args was an expression involving a\n+\t     template constant parameter, like N - 1.  Now that we've\n+\t     tsubst'd, we might have something like 2 - 1.  This will\n+\t     confuse lookup_template_class, so we do constant folding\n+\t     here.  We have to unset processing_template_decl, to fool\n+\t     tsubst_copy_and_build() into building an actual tree.  */\n+\n+\t /* If the TREE_TYPE of ARG is not NULL_TREE, ARG is already\n+\t    as simple as it's going to get, and trying to reprocess\n+\t    the trees will break.  Once tsubst_expr et al DTRT for\n+\t    non-dependent exprs, this code can go away, as the type\n+\t    will always be set.  */\n+\t  if (!TREE_TYPE (r))\n+\t    {\n+\t      int saved_processing_template_decl = processing_template_decl; \n+\t      processing_template_decl = 0;\n+\t      r = tsubst_copy_and_build (r, /*args=*/NULL_TREE,\n+\t\t\t\t\t tf_error, /*in_decl=*/NULL_TREE,\n+\t\t\t\t\t /*function_p=*/false);\n+\t      processing_template_decl = saved_processing_template_decl; \n+\t    }\n+\t  r = fold (r);\n \t}\n-\n-      arg = fold (arg);\n-    }\n-  return arg;\n-}\n-\n-/* Apply maybe_fold_nontype_arg on a list or vector of args.  */\n-\n-static void\n-maybe_fold_nontype_args (tree targs)\n-{\n-  if (!targs)\n-    /*OK*/;\n-  else if (TREE_CODE (targs) == TREE_LIST)\n-    {\n-      tree chain;\n-      for (chain = targs; chain; chain = TREE_CHAIN (chain))\n-\tTREE_VALUE (chain) = maybe_fold_nontype_arg (TREE_VALUE (chain));\n-    }\n-  else\n-    {\n-      int i;\n-      for (i = 0; i < TREE_VEC_LENGTH (targs); ++i)\n-\tTREE_VEC_ELT (targs, i)\n-\t  = maybe_fold_nontype_arg (TREE_VEC_ELT (targs, i));\n     }\n+  return r;\n }\n \n-/* Substitute ARGS into the vector of template arguments T.  */\n+/* Substitute ARGS into the vector or list of template arguments T.  */\n \n static tree\n-tsubst_template_arg_vector (tree t, tree args, tsubst_flags_t complain)\n+tsubst_template_args (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n {\n-  int len = TREE_VEC_LENGTH (t), need_new = 0, i;\n+  int is_list = !(t && TREE_CODE (t) == TREE_VEC);\n+  int len = is_list ? list_length (t) : TREE_VEC_LENGTH (t);\n+  int need_new = 0, i;\n+  tree position = t;\n   tree *elts = alloca (len * sizeof (tree));\n   \n-  memset (elts, 0, len * sizeof (tree));\n-  \n   for (i = 0; i < len; i++)\n     {\n-      if (TREE_VEC_ELT (t, i) != NULL_TREE\n-\t  && TREE_CODE (TREE_VEC_ELT (t, i)) == TREE_VEC)\n-\telts[i] = tsubst_template_arg_vector (TREE_VEC_ELT (t, i),\n-\t\t\t\t\t      args, complain);\n+      tree orig_arg;\n+      tree new_arg = NULL_TREE;\n+\n+      if (is_list)\n+\t{\n+\t  orig_arg = TREE_VALUE (position);\n+\t  position = TREE_CHAIN (position);\n+\t}\n       else\n-\telts[i] = maybe_fold_nontype_arg\n-\t  (tsubst_expr (TREE_VEC_ELT (t, i), args, complain,\n-\t\t\tNULL_TREE));\n+\t{\n+\t  orig_arg = TREE_VEC_ELT (t, i);\n+\t  if (TREE_CODE (orig_arg) == TREE_VEC)\n+\t    new_arg = tsubst_template_args (orig_arg, args, complain, in_decl);\n+\t}\n+\n+      if (!new_arg)\n+\tnew_arg = tsubst_template_arg (orig_arg, args, complain, in_decl);\n       \n-      if (elts[i] == error_mark_node)\n+      if (new_arg == error_mark_node)\n \treturn error_mark_node;\n \n-      if (elts[i] != TREE_VEC_ELT (t, i))\n+      elts[i] = new_arg;\n+      if (new_arg != orig_arg)\n \tneed_new = 1;\n     }\n   \n   if (!need_new)\n     return t;\n-  \n-  t = make_tree_vec (len);\n-  for (i = 0; i < len; i++)\n-    TREE_VEC_ELT (t, i) = elts[i];\n+\n+  if (is_list)\n+    {\n+      t = NULL_TREE;\n+\n+      for (i = len; i--;)\n+\tt = tree_cons (NULL_TREE, elts[i], t);\n+    }\n+  else\n+    {\n+      t = make_tree_vec (len);\n+      for (i = 0; i < len; i++)\n+\tTREE_VEC_ELT (t, i) = elts[i];\n+    }\n   \n   return t;\n }\n@@ -5597,10 +5594,10 @@ tsubst_template_parms (tree parms, tree args, tsubst_flags_t complain)\n \t  tree parm_decl = TREE_VALUE (tuple);\n \n \t  parm_decl = tsubst (parm_decl, args, complain, NULL_TREE);\n-\t  default_value = tsubst_expr (default_value, args,\n-\t\t\t\t       complain, NULL_TREE);\n-\t  tuple = build_tree_list (maybe_fold_nontype_arg (default_value), \n-\t\t\t\t   parm_decl);\n+\t  default_value = tsubst_template_arg (default_value, args,\n+\t\t\t\t\t       complain, NULL_TREE);\n+\t  \n+\t  tuple = build_tree_list (default_value, parm_decl);\n \t  TREE_VEC_ELT (new_vec, i) = tuple;\n \t}\n       \n@@ -5662,8 +5659,8 @@ tsubst_aggr_type (tree t,\n \t     and supposing that we are instantiating f<int, double>,\n \t     then our ARGS will be {int, double}, but, when looking up\n \t     S we only want {double}.  */\n-\t  argvec = tsubst_template_arg_vector (TYPE_TI_ARGS (t), args,\n-\t\t\t\t\t       complain);\n+\t  argvec = tsubst_template_args (TYPE_TI_ARGS (t), args,\n+\t\t\t\t\t complain, in_decl);\n \t  if (argvec == error_mark_node)\n \t    return error_mark_node;\n \n@@ -5779,10 +5776,10 @@ tsubst_decl (tree t, tree args, tree type, tsubst_flags_t complain)\n \t      : DECL_TI_ARGS (DECL_TEMPLATE_RESULT (t));\n \t    tree full_args;\n \t    \n-\t    full_args = tsubst_template_arg_vector (tmpl_args, args,\n-\t\t\t\t\t\t    complain);\n+\t    full_args = tsubst_template_args (tmpl_args, args,\n+\t\t\t\t\t      complain, in_decl);\n \n-\t    /* tsubst_template_arg_vector doesn't copy the vector if\n+\t    /* tsubst_template_args doesn't copy the vector if\n \t       nothing changed.  But, *something* should have\n \t       changed.  */\n \t    my_friendly_assert (full_args != tmpl_args, 0);\n@@ -5895,10 +5892,9 @@ tsubst_decl (tree t, tree args, tree type, tsubst_flags_t complain)\n \t       specialization, and the complete set of arguments used to\n \t       specialize R.  */\n \t    gen_tmpl = most_general_template (DECL_TI_TEMPLATE (t));\n-\t    argvec \n-\t      = tsubst_template_arg_vector (DECL_TI_ARGS \n-\t\t\t\t\t    (DECL_TEMPLATE_RESULT (gen_tmpl)),\n-\t\t\t\t\t    args, complain); \n+\t    argvec = tsubst_template_args (DECL_TI_ARGS \n+\t\t\t\t\t   (DECL_TEMPLATE_RESULT (gen_tmpl)),\n+\t\t\t\t\t   args, complain, in_decl); \n \n \t    /* Check to see if we already have this specialization.  */\n \t    spec = retrieve_specialization (gen_tmpl, argvec);\n@@ -6477,12 +6473,9 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n       {\n \ttree max, omax = TREE_OPERAND (TYPE_MAX_VALUE (t), 0);\n \n-\tmax = tsubst_expr (omax, args, complain, in_decl);\n-\tif (max == error_mark_node)\n-\t  return error_mark_node;\n-\n-\t/* See if we can reduce this expression to something simpler.  */\n-\tmax = maybe_fold_nontype_arg (max);\n+\t/* The array dimension behaves like a non-type template arg,\n+\t   in that we want to fold it as much as possible.  */\n+\tmax = tsubst_template_arg (omax, args, complain, in_decl);\n \tif (!processing_template_decl)\n \t  max = decl_constant_value (max);\n \n@@ -6726,7 +6719,7 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \t}\n \n       /* Otherwise, a vector of template arguments.  */\n-      return tsubst_template_arg_vector (t, args, complain);\n+      return tsubst_template_args (t, args, complain, in_decl);\n \n     case POINTER_TYPE:\n     case REFERENCE_TYPE:\n@@ -7157,8 +7150,7 @@ tsubst_qualified_id (tree qualified_id, tree args,\n     }\n \n   if (!BASELINK_P (name) && !DECL_P (expr))\n-    expr = lookup_qualified_name (scope, expr, /*is_type_p=*/0,\n-\t\t\t\t  (complain & tf_error) != 0);\n+    expr = lookup_qualified_name (scope, expr, /*is_type_p=*/0, false);\n   if (DECL_P (expr))\n     check_accessibility_of_qualified_id (expr, \n \t\t\t\t\t /*object_type=*/NULL_TREE,\n@@ -7175,7 +7167,9 @@ tsubst_qualified_id (tree qualified_id, tree args,\n   if (is_template)\n     expr = lookup_template_function (expr, template_args);\n \n-  if (TYPE_P (scope))\n+  if (expr == error_mark_node && complain & tf_error)\n+    nested_name_lookup_error (scope, TREE_OPERAND (qualified_id, 1));\n+  else if (TYPE_P (scope))\n     {\n       expr = (adjust_result_of_qualified_name_lookup \n \t      (expr, scope, current_class_type));\n@@ -7459,12 +7453,13 @@ tsubst_copy (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n     case TEMPLATE_ID_EXPR:\n       {\n         /* Substituted template arguments */\n-\ttree targs = tsubst_copy (TREE_OPERAND (t, 1), args, complain,\n-\t\t\t\t  in_decl);\n+\ttree fn = TREE_OPERAND (t, 0);\n+\ttree targs = TREE_OPERAND (t, 1);\n \n-\tmaybe_fold_nontype_args (targs);\n-\treturn lookup_template_function\n-\t  (tsubst_copy (TREE_OPERAND (t, 0), args, complain, in_decl), targs);\n+\tfn = tsubst_copy (fn, args, complain, in_decl);\n+\ttargs = tsubst_template_args (targs, args, complain, in_decl);\n+\t\n+\treturn lookup_template_function (fn, targs);\n       }\n \n     case TREE_LIST:\n@@ -7595,12 +7590,15 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \t  {\n \t    tree scope = DECL_INITIAL (decl);\n \t    tree name = DECL_NAME (decl);\n+\t    tree decl;\n \t    \n \t    scope = tsubst_expr (scope, args, complain, in_decl);\n-\t    do_local_using_decl (lookup_qualified_name (scope,\n-\t\t\t\t\t\t\tname, \n-\t\t\t\t\t\t\t/*is_type_p=*/0,\n-\t\t\t\t\t\t\t/*complain=*/true));\n+\t    decl = lookup_qualified_name (scope, name,\n+\t\t\t\t\t  /*is_type_p=*/0, /*complain=*/false);\n+\t    if (decl == error_mark_node)\n+\t      nested_name_lookup_error (scope, name);\n+\t    else\n+\t      do_local_using_decl (decl);\n \t  }\n \telse\n \t  {\n@@ -8258,18 +8256,15 @@ tsubst_copy_and_build (tree t,\n \t       scope is.  */\n \t    tmpl = TREE_OPERAND (TREE_OPERAND (member, 1), 0);\n \t    args = TREE_OPERAND (TREE_OPERAND (member, 1), 1);\n-\t    member = lookup_qualified_name (TREE_OPERAND (member, 0),\n-\t\t\t\t\t    tmpl, \n-\t\t\t\t\t    /*is_type=*/0,\n-\t\t\t\t\t    /*complain=*/true);\n+\t    member = lookup_qualified_name (TREE_OPERAND (member, 0), tmpl, \n+\t\t\t\t\t    /*is_type=*/0, /*complain=*/false);\n \t    if (BASELINK_P (member))\n \t      BASELINK_FUNCTIONS (member) \n \t\t= build_nt (TEMPLATE_ID_EXPR, BASELINK_FUNCTIONS (member),\n \t\t\t    args);\n \t    else\n \t      {\n-\t\terror (\"`%D' is not a member of `%T'\",\n-\t\t       tmpl, TREE_TYPE (object));\n+\t\tnested_name_lookup_error (TREE_TYPE (object), tmpl);\n \t\treturn error_mark_node;\n \t      }\n \t  }"}, {"sha": "2e78e1b95bce69931bec0f95a502be18ed2494eb", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a91db711890ba12e2385bf10480a5f6c270c2e2f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a91db711890ba12e2385bf10480a5f6c270c2e2f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a91db711890ba12e2385bf10480a5f6c270c2e2f", "patch": "@@ -1,3 +1,10 @@\n+2003-07-25  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\tPR 11596\n+\t* g++.dg/template/defarg3.C: New test.\n+\n+\t* g++.dg/ext/packed2.C: Pack member struct too. Explain why.\n+\n 2003-07-24  Mark Mitchell  <mark@codesourcery.com>\n \n \t* g++.dg/inherit/access5.C: New test."}, {"sha": "66f156bac7ce46513476e330cd85e9eba2c5af7f", "filename": "gcc/testsuite/g++.dg/ext/packed2.C", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a91db711890ba12e2385bf10480a5f6c270c2e2f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fpacked2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a91db711890ba12e2385bf10480a5f6c270c2e2f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fpacked2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fpacked2.C?ref=a91db711890ba12e2385bf10480a5f6c270c2e2f", "patch": "@@ -1,18 +1,23 @@\n // PR c++/10091\n \n+// Original synopsis\n // Bug: We were dying because in general, B::a doesn't have enough\n // alignment for us to take its address.  But if the B is C::b, it does\n // have enough alignment, and we should be able to determine that.\n \n // This only failed on STRICT_ALIGNMENT targets (i.e. not i686)\n \n+// July 2003\n+// packing of non-pods is now only allowed if the non-pod is itself\n+// packed. Also only such pods can be reference bound to non-consts\n+\n struct A {\n   int i;\n \n   A();\n   A(const A&);\n   A& operator=(const A&);\n-};\n+} __attribute__ ((packed));\n \n struct B {\n   A a;\n@@ -23,8 +28,8 @@ struct C {\n   int j;\n };\n \n-void f (const A&);\n-void g (const C& c)\n+void f (A&);\n+void g (C& c)\n {\n   f (c.b.a);\n }"}, {"sha": "da91cb7b1740e04df84e520e104cbcdd4b6e2506", "filename": "gcc/testsuite/g++.dg/template/defarg3.C", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a91db711890ba12e2385bf10480a5f6c270c2e2f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fdefarg3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a91db711890ba12e2385bf10480a5f6c270c2e2f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fdefarg3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fdefarg3.C?ref=a91db711890ba12e2385bf10480a5f6c270c2e2f", "patch": "@@ -0,0 +1,16 @@\n+// { dg-do compile }\n+\n+// Copyright (C) 2003 Free Software Foundation, Inc.\n+// Contributed by Nathan Sidwell 22 Jul 2003 <nathan@codesourcery.com>\n+\n+// PR c++ 11596\n+\n+template <int V, bool F = V < 1> struct A { enum { value }; };\n+template <int V> struct B { enum { value = A<1>::value }; };\n+int ary[!B<1>::value ? 1 : -1];\n+\n+template <int V, bool F = V < 1> struct A1 { enum { value = 1}; };\n+template <int V> struct A1<V,false> { enum { value}; };\n+template <int V> struct B1 { enum { value = A1<1>::value }; };\n+\n+int ary1[!B1<1>::value ? 1 : -1];"}]}