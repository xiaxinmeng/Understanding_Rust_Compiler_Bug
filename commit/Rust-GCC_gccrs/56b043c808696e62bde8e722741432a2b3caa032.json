{"sha": "56b043c808696e62bde8e722741432a2b3caa032", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTZiMDQzYzgwODY5NmU2MmJkZThlNzIyNzQxNDMyYTJiM2NhYTAzMg==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2004-08-09T19:13:07Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2004-08-09T19:13:07Z"}, "message": "Makefile.in (OBJC-common): Add tree-ssa-threadupdate.c\n\n        * Makefile.in (OBJC-common): Add tree-ssa-threadupdate.c\n        (tree-ssa-threadupdate.o): Add dependencies.\n        * tree-ssa-threadupdate.c: New file.\n        * tree-flow.h (incoming_edge_threaded): New flag in block annotation.\n        (rewrite_vars_out_of_ssa): Remove prototype.\n        (cleanup_tree_cfg): Returns a bool.\n        * tree.h (thread_through_all_blocks): Prototype.\n        * tree-outof-ssa.c  (SSANORM_*): Move into here.\n        (remove_ssa_form): Now static.\n        (rewrite_vars_out_of_ssa): Kill.\n        * tree-ssa-live.c (register_ssa_partitions_for_vars): Kill.\n        * tree-ssa-live.h (SSANORM_*): Moved into tree-outof-ssa.c.\n        (remove_ssa_form, register_partitions_for_vars): Kill declarations.\n        * tree-cfg.c (cleanup_tree_cfg): Return a value indicating if\n        anything was changed.\n        * tree-phinodes.c (add_phi_arg): Get the block for the PHI\n        from the PHI's annotation rather than the edge associated with\n        the new argument.\n        * tree-ssa-dom.c (redirection_edges): Kill.\n        (redirect_edges_and_update_ssa_graph): Kill.\n        (tree_ssa_dominator_optimize): Do not reset forwardable flag\n        for blocks anymore.  Do not initialize redirection_edges.\n        Call thread_through_all_blocks.  Simplify code for cleanup\n        of the CFG and iterating.  No longer call cleanup_tree_cfg\n        outside the iteration loop.\n        (thread_across_edge): No longer mess with forwardable blocks.\n\nFrom-SVN: r85721", "tree": {"sha": "43d76704cc977318946377c4bb267eca1f611d0e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/43d76704cc977318946377c4bb267eca1f611d0e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/56b043c808696e62bde8e722741432a2b3caa032", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/56b043c808696e62bde8e722741432a2b3caa032", "html_url": "https://github.com/Rust-GCC/gccrs/commit/56b043c808696e62bde8e722741432a2b3caa032", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/56b043c808696e62bde8e722741432a2b3caa032/comments", "author": null, "committer": null, "parents": [{"sha": "9b305d55bf262d8896f15f6766bbf77c7f4aeb12", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b305d55bf262d8896f15f6766bbf77c7f4aeb12", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9b305d55bf262d8896f15f6766bbf77c7f4aeb12"}], "stats": {"total": 1035, "additions": 510, "deletions": 525}, "files": [{"sha": "359f0cfb79e8b401534a22b6cada1bc4702f30cc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56b043c808696e62bde8e722741432a2b3caa032/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56b043c808696e62bde8e722741432a2b3caa032/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=56b043c808696e62bde8e722741432a2b3caa032", "patch": "@@ -1,3 +1,32 @@\n+2004-08-09  Jeff Law  <law@redhat.com>\n+\n+\t* Makefile.in (OBJC-common): Add tree-ssa-threadupdate.c\n+\t(tree-ssa-threadupdate.o): Add dependencies.\n+\t* tree-ssa-threadupdate.c: New file.\n+\t* tree-flow.h (incoming_edge_threaded): New flag in block annotation.\n+\t(rewrite_vars_out_of_ssa): Remove prototype.\n+\t(cleanup_tree_cfg): Returns a bool.\n+\t* tree.h (thread_through_all_blocks): Prototype.\n+\t* tree-outof-ssa.c  (SSANORM_*): Move into here.\n+\t(remove_ssa_form): Now static.\n+\t(rewrite_vars_out_of_ssa): Kill.\n+\t* tree-ssa-live.c (register_ssa_partitions_for_vars): Kill.\n+\t* tree-ssa-live.h (SSANORM_*): Moved into tree-outof-ssa.c.\n+\t(remove_ssa_form, register_partitions_for_vars): Kill declarations.\n+\t* tree-cfg.c (cleanup_tree_cfg): Return a value indicating if\n+\tanything was changed.\n+\t* tree-phinodes.c (add_phi_arg): Get the block for the PHI\n+\tfrom the PHI's annotation rather than the edge associated with\n+\tthe new argument.\n+\t* tree-ssa-dom.c (redirection_edges): Kill.\n+\t(redirect_edges_and_update_ssa_graph): Kill.\n+\t(tree_ssa_dominator_optimize): Do not reset forwardable flag\n+\tfor blocks anymore.  Do not initialize redirection_edges.\n+\tCall thread_through_all_blocks.  Simplify code for cleanup\n+\tof the CFG and iterating.  No longer call cleanup_tree_cfg\n+\toutside the iteration loop.\n+\t(thread_across_edge): No longer mess with forwardable blocks.\n+\n 2004-08-09  Zack Weinberg  <zack@codesourcery.com>\n \n \t* explow.c (memory_address): Use memory_address_p."}, {"sha": "984bb9e0bdd391638565b3ebd850962dbb80b3b5", "filename": "gcc/Makefile.in", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56b043c808696e62bde8e722741432a2b3caa032/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56b043c808696e62bde8e722741432a2b3caa032/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=56b043c808696e62bde8e722741432a2b3caa032", "patch": "@@ -898,7 +898,7 @@ OBJS-common = \\\n  tree-ssa-phiopt.o tree-ssa-forwprop.o tree-nested.o tree-ssa-dse.o\t   \\\n  tree-ssa-dom.o domwalk.o tree-tailcall.o gimple-low.o tree-iterator.o\t   \\\n  tree-phinodes.o tree-ssanames.o tree-sra.o tree-complex.o tree-ssa-loop.o \\\n- tree-ssa-loop-niter.o tree-ssa-loop-manip.o\t\t\t\t   \\\n+ tree-ssa-loop-niter.o tree-ssa-loop-manip.o tree-ssa-threadupdate.o\t   \\\n  alias.o bb-reorder.o bitmap.o builtins.o caller-save.o calls.o\t  \t   \\\n  cfg.o cfganal.o cfgbuild.o cfgcleanup.o cfglayout.o cfgloop.o\t\t   \\\n  cfgloopanal.o cfgloopmanip.o loop-init.o loop-unswitch.o loop-unroll.o\t   \\\n@@ -1632,6 +1632,10 @@ tree-ssa-dom.o : tree-ssa-dom.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n    $(RTL_H) $(TREE_H) $(TM_P_H) $(EXPR_H) $(GGC_H) output.h diagnostic.h \\\n    errors.h function.h $(TIMEVAR_H) $(TM_H) coretypes.h $(TREE_DUMP_H) \\\n    $(BASIC_BLOCK_H) domwalk.h real.h tree-pass.h $(FLAGS_H) langhooks.h\n+tree-ssa-threadupdate.o : tree-ssa-threadupdate.c $(TREE_FLOW_H) $(CONFIG_H) \\\n+   $(SYSTEM_H) $(RTL_H) $(TREE_H) $(TM_P_H) $(EXPR_H) $(GGC_H) output.h \\\n+   diagnostic.h errors.h function.h $(TM_H) coretypes.h $(TREE_DUMP_H) \\\n+   $(BASIC_BLOCK_H) $(FLAGS_H)  tree-pass.h\n tree-ssanames.o : tree-ssanames.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    $(TM_H) $(TREE_H) varray.h $(GGC_H) gt-tree-ssanames.h  $(TREE_FLOW_H)\n tree-phinodes.o : tree-phinodes.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\"}, {"sha": "c9bc37ce6b9f87800142578cb8c694c9174c6092", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56b043c808696e62bde8e722741432a2b3caa032/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56b043c808696e62bde8e722741432a2b3caa032/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=56b043c808696e62bde8e722741432a2b3caa032", "patch": "@@ -717,10 +717,11 @@ make_goto_expr_edges (basic_block bb)\n \n /* Remove unreachable blocks and other miscellaneous clean up work.  */\n \n-void\n+bool\n cleanup_tree_cfg (void)\n {\n   bool something_changed = true;\n+  bool retval = false;\n \n   timevar_push (TV_TREE_CLEANUP_CFG);\n \n@@ -731,6 +732,7 @@ cleanup_tree_cfg (void)\n       something_changed = cleanup_control_flow ();\n       something_changed |= delete_unreachable_blocks ();\n       something_changed |= thread_jumps ();\n+      retval |= something_changed;\n     }\n \n   /* Merging the blocks creates no new opportunities for the other\n@@ -743,6 +745,7 @@ cleanup_tree_cfg (void)\n   verify_flow_info ();\n #endif\n   timevar_pop (TV_TREE_CLEANUP_CFG);\n+  return retval;\n }\n \n "}, {"sha": "d470035470eec4b93762407318efa595e9df65bf", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56b043c808696e62bde8e722741432a2b3caa032/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56b043c808696e62bde8e722741432a2b3caa032/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=56b043c808696e62bde8e722741432a2b3caa032", "patch": "@@ -356,6 +356,10 @@ struct bb_ann_d GTY(())\n   /* Nonzero if this block contains an escape point (see is_escape_site).  */\n   unsigned has_escape_site : 1;\n \n+  /* Nonzero if one or more incoming edges to this block should be threaded\n+     to an outgoing edge of this block.  */\n+  unsigned incoming_edge_threaded : 1;\n+\n   struct edge_prediction *predictions;\n };\n \n@@ -474,7 +478,7 @@ extern void debug_loop_ir (void);\n extern void print_loop_ir (FILE *);\n extern void cleanup_dead_labels (void);\n extern void group_case_labels (void);\n-extern void cleanup_tree_cfg (void);\n+extern bool cleanup_tree_cfg (void);\n extern tree first_stmt (basic_block);\n extern tree last_stmt (basic_block);\n extern tree *last_stmt_ptr (basic_block);\n@@ -561,7 +565,6 @@ typedef bool (*walk_use_def_chains_fn) (tree, tree, void *);\n \n /* In tree-ssa.c  */\n extern void init_tree_ssa (void);\n-extern void rewrite_vars_out_of_ssa (bitmap);\n extern void dump_reaching_defs (FILE *);\n extern void debug_reaching_defs (void);\n extern void dump_tree_ssa (FILE *);"}, {"sha": "33a927e14aeaae7fe279b5400756c9cfb4005a3d", "filename": "gcc/tree-outof-ssa.c", "status": "modified", "additions": 9, "deletions": 117, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56b043c808696e62bde8e722741432a2b3caa032/gcc%2Ftree-outof-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56b043c808696e62bde8e722741432a2b3caa032/gcc%2Ftree-outof-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-outof-ssa.c?ref=56b043c808696e62bde8e722741432a2b3caa032", "patch": "@@ -48,6 +48,14 @@ Boston, MA 02111-1307, USA.  */\n #include \"tree-ssa-live.h\"\n #include \"tree-pass.h\"\n \n+/* Flags to pass to remove_ssa_form.  */\n+\n+#define SSANORM_PERFORM_TER\t\t0x1\n+#define SSANORM_COMBINE_TEMPS\t\t0x2\n+#define SSANORM_REMOVE_ALL_PHIS\t\t0x4\n+#define SSANORM_COALESCE_PARTITIONS\t0x8\n+#define SSANORM_USE_COALESCE_LIST\t0x10\n+\n /* Used to hold all the components required to do SSA PHI elimination.\n    The node and pred/succ list is a simple linear list of nodes and\n    edges represented as pairs of nodes.\n@@ -1956,7 +1964,7 @@ rewrite_trees (var_map map, tree *values)\n /* Remove the variables specified in MAP from SSA form.  Any debug information\n    is sent to DUMP.  FLAGS indicate what options should be used.  */\n \n-void\n+static void\n remove_ssa_form (FILE *dump, var_map map, int flags)\n {\n   tree_live_info_p liveinfo;\n@@ -2039,122 +2047,6 @@ remove_ssa_form (FILE *dump, var_map map, int flags)\n   dump_file = save;\n }\n \n-\n-/* Take a subset of the variables VARS in the current function out of SSA\n-   form.  */\n-\n-void\n-rewrite_vars_out_of_ssa (bitmap vars)\n-{\n-  if (bitmap_first_set_bit (vars) >= 0)\n-    {\n-      var_map map;\n-      basic_block bb;\n-      tree phi;\n-      int i;\n-      int ssa_flags;\n-\n-      /* Search for PHIs in which one of the PHI arguments is marked for\n-\t translation out of SSA form, but for which the PHI result is not\n-\t marked for translation out of SSA form.\n-\n-\t Our per-variable out of SSA translation can not handle that case;\n-\t however we can easily handle it here by creating a new instance\n-\t of the PHI result's underlying variable and initializing it to\n-\t the offending PHI argument on the edge associated with the\n-\t PHI argument.  We then change the PHI argument to use our new\n-\t instead of the PHI's underlying variable.\n-\n-\t You might think we could register partitions for the out-of-ssa\n-\t translation here and avoid a second walk of the PHI nodes.  No\n-\t such luck since the size of the var map will change if we have\n-\t to manually take variables out of SSA form here.  */\n-      FOR_EACH_BB (bb)\n-\t{\n-\t  for (phi = phi_nodes (bb); phi; phi = PHI_CHAIN (phi))\n-\t    {\n-\t      tree result = SSA_NAME_VAR (PHI_RESULT (phi));\n-\n-\t      /* If the definition is marked for renaming, then we need\n-\t\t to do nothing more for this PHI node.  */\n-\t      if (bitmap_bit_p (vars, var_ann (result)->uid))\n-\t\tcontinue;\n-\n-\t      /* Look at all the arguments and see if any of them are\n-\t\t marked for renaming.  If so, we need to handle them\n-\t\t specially.  */\n-\t      for (i = 0; i < PHI_NUM_ARGS (phi); i++)\n-\t\t{\n-\t\t  tree arg = PHI_ARG_DEF (phi, i);\n-\n-\t\t  /* If the argument is not an SSA_NAME, then we can ignore\n-\t\t     this argument.  */\n-\t\t  if (TREE_CODE (arg) != SSA_NAME)\n-\t\t    continue;\n-\n-\t\t  /* If this argument is marked for renaming, then we need\n-\t\t     to undo the copy propagation so that we can take\n-\t\t     the argument out of SSA form without taking the\n-\t\t     result out of SSA form.  */\n-\t\t  arg = SSA_NAME_VAR (arg);\n-\t\t  if (bitmap_bit_p (vars, var_ann (arg)->uid))\n-\t\t    {\n-\t\t      tree new_name, copy;\n-\n-\t\t      /* Get a new SSA_NAME for the copy, it is based on\n-\t\t\t the result, not the argument!   We use the PHI\n-\t\t\t as the definition since we haven't created the\n-\t\t\t definition statement yet.  */\n-\t\t      new_name = make_ssa_name (result, phi);\n-\n-\t\t      /* Now create the copy statement.  */\n-\t\t      copy = build (MODIFY_EXPR, TREE_TYPE (arg),\n-\t\t\t\t    new_name, PHI_ARG_DEF (phi, i));\n-\n-\t\t      /* Now update SSA_NAME_DEF_STMT to point to the\n-\t\t\t newly created statement.  */\n-\t\t      SSA_NAME_DEF_STMT (new_name) = copy;\n-\n-\t\t      /* Now make the argument reference our new SSA_NAME.  */\n-\t\t      SET_PHI_ARG_DEF (phi, i, new_name);\n-\n-\t\t      /* Queue the statement for insertion.  */\n-\t\t      bsi_insert_on_edge (PHI_ARG_EDGE (phi, i), copy);\n-\t\t      modify_stmt (copy);\n-\t\t    }\n-\t\t}\n-\t    }\n-\t}\n-\n-      /* If any copies were inserted on edges, actually insert them now.  */\n-      bsi_commit_edge_inserts (NULL);\n-                                                                                \n-      /* Now register partitions for all instances of the variables we\n-\t are taking out of SSA form.  */\n-      map = init_var_map (num_ssa_names + 1);\n-      register_ssa_partitions_for_vars (vars, map);\n-\n-      /* Now that we have all the partitions registered, translate the\n-\t appropriate variables out of SSA form.  */\n-      ssa_flags = SSANORM_COALESCE_PARTITIONS;\n-      if (flag_tree_combine_temps)\n-\tssa_flags |= SSANORM_COMBINE_TEMPS;\n-      remove_ssa_form (dump_file, map, ssa_flags);\n-\n-      /* And finally, reset the out_of_ssa flag for each of the vars\n-\t we just took out of SSA form.  */\n-      EXECUTE_IF_SET_IN_BITMAP (vars, 0, i,\n-\t{\n-\t  var_ann (referenced_var (i))->out_of_ssa_tag = 0;\n-\t});\n-\n-     /* Free the map as we are done with it.  */\n-     delete_var_map (map);\n-\n-    }\n-}\n-\n-\n /* Take the current function out of SSA form, as described in\n    R. Morgan, ``Building an Optimizing Compiler'',\n    Butterworth-Heinemann, Boston, MA, 1998. pp 176-186.  */"}, {"sha": "5bf77360601a9633617ad70f090ea577e0793317", "filename": "gcc/tree-phinodes.c", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56b043c808696e62bde8e722741432a2b3caa032/gcc%2Ftree-phinodes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56b043c808696e62bde8e722741432a2b3caa032/gcc%2Ftree-phinodes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-phinodes.c?ref=56b043c808696e62bde8e722741432a2b3caa032", "patch": "@@ -335,17 +335,24 @@ add_phi_arg (tree *phi, tree def, edge e)\n \t release the old PHI node.  */\n       if (*phi != old_phi)\n \t{\n+\t  /* Extract the basic block for the PHI from the PHI's annotation\n+\t     rather than the edge.  This works better as the edge's\n+\t     destination may not currently be the block with the PHI\n+\t     node if we are in the process of threading the edge to\n+\t     a new destination.  */\n+\t  basic_block bb = bb_for_stmt (*phi);\n+\n \t  release_phi_node (old_phi);\n \n \t  /* Update the list head if replacing the first listed phi.  */\n-\t  if (phi_nodes (e->dest) == old_phi)\n-\t    bb_ann (e->dest)->phi_nodes = *phi;\n+\t  if (phi_nodes (bb) == old_phi)\n+\t    bb_ann (bb)->phi_nodes = *phi;\n \t  else\n \t    {\n \t      /* Traverse the list looking for the phi node to chain to.  */\n \t      tree p;\n \n-\t      for (p = phi_nodes (e->dest);\n+\t      for (p = phi_nodes (bb);\n \t\t   p && PHI_CHAIN (p) != old_phi;\n \t\t   p = PHI_CHAIN (p))\n \t\t;"}, {"sha": "26df9ed75913dc1737e41f3ab1fe21d7ff4a9903", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 24, "deletions": 299, "changes": 323, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56b043c808696e62bde8e722741432a2b3caa032/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56b043c808696e62bde8e722741432a2b3caa032/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=56b043c808696e62bde8e722741432a2b3caa032", "patch": "@@ -63,6 +63,7 @@ static htab_t avail_exprs;\n    have to perform in lookup_avail_expr and finally it allows us to\n    significantly reduce the number of calls into the hashing routine\n    itself.  */\n+\n struct expr_hash_elt\n {\n   /* The value (lhs) of this expression.  */\n@@ -160,18 +161,6 @@ struct vrp_element\n \n static struct opt_stats_d opt_stats;\n \n-/* This virtual array holds pairs of edges which describe a scheduled\n-   edge redirection from jump threading.\n-\n-   The first entry in each pair is the edge we are going to redirect.\n-\n-   The second entry in each pair is the edge leading to our final\n-   destination block.  By providing this as an edge rather than the\n-   final target block itself we can correctly handle redirections\n-   when the target block had PHIs which required edge insertions/splitting\n-   to remove the PHIs.  */\n-static GTY(()) varray_type redirection_edges;\n-\n /* A virtual array holding value range records for the variable identified\n    by the index, SSA_VERSION.  */\n static varray_type vrp_data;\n@@ -267,7 +256,6 @@ static void restore_vars_to_original_value (varray_type locals,\n static void restore_currdefs_to_original_value (varray_type locals,\n \t\t\t\t\t\tunsigned limit);\n static void register_definitions_for_stmt (stmt_ann_t, varray_type *);\n-static void redirect_edges_and_update_ssa_graph (varray_type);\n static edge single_incoming_edge_ignoring_loop_edges (basic_block);\n \n /* Local version of fold that doesn't introduce cruft.  */\n@@ -301,240 +289,6 @@ set_value_for (tree var, tree value, varray_type table)\n   VARRAY_TREE (table, SSA_NAME_VERSION (var)) = value;\n }\n \n-/* REDIRECTION_EDGES contains edge pairs where we want to revector the\n-   destination of the first edge to the destination of the second edge.\n-\n-   These redirections may significantly change the SSA graph since we\n-   allow redirection through blocks with PHI nodes and blocks with\n-   real instructions in some cases.\n-\n-   This routine will perform the requested redirections and incrementally\n-   update the SSA graph. \n-\n-   Note in some cases requested redirections may be ignored as they can\n-   not be safely implemented.  */\n-\n-static void\n-redirect_edges_and_update_ssa_graph (varray_type redirection_edges)\n-{\n-  basic_block tgt, bb;\n-  tree phi;\n-  unsigned int i;\n-  size_t old_num_referenced_vars = num_referenced_vars;\n-  bitmap virtuals_to_rename = BITMAP_XMALLOC ();\n-\n-  /* First note any variables which we are going to have to take\n-     out of SSA form as well as any virtuals which need updating.  */\n-  for (i = 0; i < VARRAY_ACTIVE_SIZE (redirection_edges); i += 2)\n-    {\n-      block_stmt_iterator bsi;\n-      edge e;\n-      basic_block tgt;\n-      tree phi;\n-\n-      e = VARRAY_EDGE (redirection_edges, i);\n-      tgt = VARRAY_EDGE (redirection_edges, i + 1)->dest;\n-\n-      /* All variables referenced in PHI nodes we bypass must be\n-\t renamed.  */\n-      for (phi = phi_nodes (e->dest); phi; phi = PHI_CHAIN (phi))\n-\t{\n-\t  tree result = SSA_NAME_VAR (PHI_RESULT (phi));\n-\n-\t  if (is_gimple_reg (PHI_RESULT (phi)))\n-\t    bitmap_set_bit (vars_to_rename, var_ann (result)->uid);\n-\t  else\n-\t    bitmap_set_bit (virtuals_to_rename, var_ann (result)->uid);\n-        }\n-\n-      /* Any variables set by statements at the start of the block we\n-\t are bypassing must also be taken our of SSA form.  */\n-      for (bsi = bsi_start (e->dest); ! bsi_end_p (bsi); bsi_next (&bsi))\n-\t{\n-\t  unsigned int j;\n-\t  def_optype defs;\n-\t  v_may_def_optype v_may_defs;\n-\t  v_must_def_optype v_must_defs;\n-\t  tree stmt = bsi_stmt (bsi);\n-\t  stmt_ann_t ann = stmt_ann (stmt);\n-\n-\t  if (TREE_CODE (stmt) == COND_EXPR)\n-\t    break;\n-\n-\t  get_stmt_operands (stmt);\n-\n-\t  defs = DEF_OPS (ann);\n-\t  for (j = 0; j < NUM_DEFS (defs); j++)\n-\t    {\n-\t      tree op = DEF_OP (defs, j);\n-\t      tree var = SSA_NAME_VAR (op);\n-\t      bitmap_set_bit (vars_to_rename, var_ann (var)->uid);\n-\t    }\n-\n-\t  v_may_defs = STMT_V_MAY_DEF_OPS (stmt);\n-\t  for (j = 0; j < NUM_V_MAY_DEFS (v_may_defs); j++)\n-\t    {\n-\t      tree op = V_MAY_DEF_RESULT (v_may_defs, j);\n-\t      tree var = SSA_NAME_VAR (op);\n-\t      bitmap_set_bit (vars_to_rename, var_ann (var)->uid);\n-\t    }\n-\t    \n-\t  v_must_defs = STMT_V_MUST_DEF_OPS (stmt);\n-\t  for (j = 0; j < NUM_V_MUST_DEFS (v_must_defs); j++)\n-\t    {\n-\t      tree op = V_MUST_DEF_OP (v_must_defs, j);\n-\t      tree var = SSA_NAME_VAR (op);\n-\t      bitmap_set_bit (vars_to_rename, var_ann (var)->uid);\n-\t    }\n-\t}\n-\n-      /* Finally, any variables in PHI nodes at our final destination\n-         must also be taken out of SSA form.  */\n-      for (phi = phi_nodes (tgt); phi; phi = PHI_CHAIN (phi))\n-\t{\n-\t  tree result = SSA_NAME_VAR (PHI_RESULT (phi));\n-\n-\t  if (is_gimple_reg (PHI_RESULT (phi)))\n-\t    bitmap_set_bit (vars_to_rename, var_ann (result)->uid);\n-\t  else\n-\t    bitmap_set_bit (virtuals_to_rename, var_ann (result)->uid);\n-        }\n-    }\n-\n-  /* Take those selected variables out of SSA form.  This must be\n-     done before we start redirecting edges.  */\n-  if (bitmap_first_set_bit (vars_to_rename) >= 0)\n-    rewrite_vars_out_of_ssa (vars_to_rename);\n-\n-  /* The out of SSA translation above may split the edge from\n-     E->src to E->dest.  This could potentially cause us to lose\n-     an assignment leading to invalid warnings about uninitialized\n-     variables or incorrect code.\n-\n-     Luckily, we can detect this by looking at the last statement\n-     in E->dest.  If it is not a COND_EXPR or SWITCH_EXPR, then\n-     the edge was split and instead of E, we want E->dest->succ.  */\n-  for (i = 0; i < VARRAY_ACTIVE_SIZE (redirection_edges); i += 2)\n-    {\n-      edge e = VARRAY_EDGE (redirection_edges, i);\n-      tree last = last_stmt (e->dest);\n-\n-      if (last\n-\t  && TREE_CODE (last) != COND_EXPR\n-\t  && TREE_CODE (last) != SWITCH_EXPR)\n-\t{\n-\t  e = e->dest->succ;\n-\n-#ifdef ENABLE_CHECKING\n-\t  /* There should only be a single successor if the\n-\t     original edge was split.  */\n-\t  if (e->succ_next)\n-\t    abort ();\n-#endif\n-\t  /* Replace the edge in REDIRECTION_EDGES for the\n-\t     loop below.  */\n-\t  VARRAY_EDGE (redirection_edges, i) = e;\n-\t}\n-    }\n-\n-  /* If we created any new variables as part of the out-of-ssa\n-     translation, then any jump threads must be invalidated if they\n-     bypass a block in which we skipped instructions.\n-\n-     This is necessary as instructions which appeared to be NOPS\n-     may be necessary after the out-of-ssa translation.  */\n-  if (num_referenced_vars != old_num_referenced_vars)\n-    {\n-      for (i = 0; i < VARRAY_ACTIVE_SIZE (redirection_edges); i += 2)\n-\t{\n-\t  block_stmt_iterator bsi;\n-\t  edge e;\n-\n-\t  e = VARRAY_EDGE (redirection_edges, i);\n-\t  for (bsi = bsi_start (e->dest); ! bsi_end_p (bsi); bsi_next (&bsi))\n-\t    {\n-\t      tree stmt = bsi_stmt (bsi);\n-\n-\t      if (IS_EMPTY_STMT (stmt)\n-\t\t  || TREE_CODE (stmt) == LABEL_EXPR)\n-\t\tcontinue;\n-\n-\t      if (TREE_CODE (stmt) == COND_EXPR)\n-\t\tbreak;\n-\n-\t      /* Invalidate the jump thread.  */\n-\t      VARRAY_EDGE (redirection_edges, i) = NULL;\n-\t      VARRAY_EDGE (redirection_edges, i + 1) = NULL;\n-\t      break;\n-\t    }\n-\t}\n-    }\n-\n-  /* Now redirect the edges.  */\n-  for (i = 0; i < VARRAY_ACTIVE_SIZE (redirection_edges); i += 2)\n-    {\n-      basic_block src;\n-      edge e;\n-\n-      e = VARRAY_EDGE (redirection_edges, i);\n-      if (!e)\n-\tcontinue;\n-\n-      tgt = VARRAY_EDGE (redirection_edges, i + 1)->dest;\n-\n-\n-      if (dump_file && (dump_flags & TDF_DETAILS))\n-\tfprintf (dump_file, \"  Threaded jump %d --> %d to %d\\n\",\n-\t\t e->src->index, e->dest->index, tgt->index);\n-\n-      src = e->src;\n-\n-      e = redirect_edge_and_branch (e, tgt);\n-      PENDING_STMT (e) = NULL_TREE;\n-\n-      /* Updating the dominance information would be nontrivial.  */\n-      free_dominance_info (CDI_DOMINATORS);\n-      \n-      if ((dump_file && (dump_flags & TDF_DETAILS))\n-\t  && e->src != src)\n-\tfprintf (dump_file, \"    basic block %d created\\n\",\n-\t\t e->src->index);\n-\n-      cfg_altered = true;\n-    }\n-\n-  VARRAY_CLEAR (redirection_edges);\n-\n-  for (i = old_num_referenced_vars; i < num_referenced_vars; i++)\n-    {\n-      bitmap_set_bit (vars_to_rename, i);\n-      var_ann (referenced_var (i))->out_of_ssa_tag = 0;\n-    }\n-\n-  bitmap_a_or_b (vars_to_rename, vars_to_rename, virtuals_to_rename);\n-\n-  /* We must remove any PHIs for virtual variables that we are going to\n-     re-rename.  Hopefully we'll be able to simply update these incrementally\n-     soon.  */\n-  FOR_EACH_BB (bb)\n-    {\n-      tree next;\n-\n-      for (phi = phi_nodes (bb); phi; phi = next)\n-\t{\n-\t  tree result = PHI_RESULT (phi);\n-\n-\t  next = PHI_CHAIN (phi);\n-\n-\t  if (bitmap_bit_p (virtuals_to_rename,\n-\t\t\t    var_ann (SSA_NAME_VAR (result))->uid))\n-\t    remove_phi_node (phi, NULL, bb);\n-\t}\n-    }\n-\n-  BITMAP_XFREE (virtuals_to_rename);\n-}\n-\n /* Jump threading, redundancy elimination and const/copy propagation. \n \n    This pass may expose new symbols that need to be renamed into SSA.  For\n@@ -544,7 +298,6 @@ redirect_edges_and_update_ssa_graph (varray_type redirection_edges)\n static void\n tree_ssa_dominator_optimize (void)\n {\n-  basic_block bb;\n   struct dom_walk_data walk_data;\n   unsigned int i;\n \n@@ -560,7 +313,6 @@ tree_ssa_dominator_optimize (void)\n   avail_exprs = htab_create (1024, real_avail_expr_hash, avail_expr_eq, free);\n   VARRAY_TREE_INIT (const_and_copies, num_ssa_names, \"const_and_copies\");\n   nonzero_vars = BITMAP_XMALLOC ();\n-  VARRAY_EDGE_INIT (redirection_edges, 20, \"redirection_edges\");\n   VARRAY_GENERIC_PTR_INIT (vrp_data, num_ssa_names, \"vrp_data\");\n   need_eh_cleanup = BITMAP_XMALLOC ();\n \n@@ -583,11 +335,6 @@ tree_ssa_dominator_optimize (void)\n   /* Now initialize the dominator walker.  */\n   init_walk_dominator_tree (&walk_data);\n \n-  /* Reset block_forwardable in each block's annotation.  We use that\n-     attribute when threading through COND_EXPRs.  */\n-  FOR_EACH_BB (bb)\n-    bb_ann (bb)->forwardable = 1;\n-\n   calculate_dominance_info (CDI_DOMINATORS);\n \n   /* If we prove certain blocks are unreachable, then we want to\n@@ -603,43 +350,36 @@ tree_ssa_dominator_optimize (void)\n       /* Recursively walk the dominator tree optimizing statements.  */\n       walk_dominator_tree (&walk_data, ENTRY_BLOCK_PTR);\n \n-      /* Wipe the hash tables.  */\n+      /* If we exposed any new variables, go ahead and put them into\n+\t SSA form now, before we handle jump threading.  This simplifies\n+\t interactions between rewriting of _DECL nodes into SSA form\n+\t and rewriting SSA_NAME nodes into SSA form after block\n+\t duplication and CFG manipulation.  */\n+      if (bitmap_first_set_bit (vars_to_rename) >= 0)\n+\t{\n+\t  rewrite_into_ssa (false);\n+\t  bitmap_clear (vars_to_rename);\n+\t}\n \n-      if (VARRAY_ACTIVE_SIZE (redirection_edges) > 0)\n-\tredirect_edges_and_update_ssa_graph (redirection_edges);\n+      /* Thread jumps, creating duplicate blocks as needed.  */\n+      cfg_altered = thread_through_all_blocks ();\n \n+      /* Removal of statements may make some EH edges dead.  Purge\n+\t such edges from the CFG as needed.  */\n       if (bitmap_first_set_bit (need_eh_cleanup) >= 0)\n \t{\n-\t  cfg_altered = tree_purge_all_dead_eh_edges (need_eh_cleanup);\n+\t  cfg_altered |= tree_purge_all_dead_eh_edges (need_eh_cleanup);\n \t  bitmap_zero (need_eh_cleanup);\n \t}\n \n-      /* We may have made some basic blocks unreachable, remove them.  */\n-      cfg_altered |= delete_unreachable_blocks ();\n+      free_dominance_info (CDI_DOMINATORS);\n+      cfg_altered = cleanup_tree_cfg ();\n+      calculate_dominance_info (CDI_DOMINATORS);\n \n-      /* If the CFG was altered, then recompute the dominator tree.  This\n-\t is not strictly needed if we only removed unreachable blocks, but\n-\t may produce better results.  If we threaded jumps, then rebuilding\n-\t the dominator tree is strictly necessary.  Likewise with EH cleanup.\n-\t Free the dominance info first so that cleanup_tree_cfg doesn't try\n-\t to verify it.  */\n-      if (cfg_altered)\n-\t{\n-          free_dominance_info (CDI_DOMINATORS);\n-\t  cleanup_tree_cfg ();\n-\t  calculate_dominance_info (CDI_DOMINATORS);\n-\t}\n+      rewrite_ssa_into_ssa ();\n \n-      /* If we are going to iterate (CFG_ALTERED is true), then we must\n-\t perform any queued renaming before the next iteration.  */\n-      if (cfg_altered\n-\t  && bitmap_first_set_bit (vars_to_rename) >= 0)\n+      if (VARRAY_ACTIVE_SIZE (const_and_copies) <= num_ssa_names)\n \t{\n-\t  rewrite_into_ssa (false);\n-\t  bitmap_clear (vars_to_rename);\n-\n-\t  /* The into SSA translation may have created new SSA_NAMES whic\n-\t     affect the size of CONST_AND_COPIES and VRP_DATA.  */\n \t  VARRAY_GROW (const_and_copies, num_ssa_names);\n \t  VARRAY_GROW (vrp_data, num_ssa_names);\n \t}\n@@ -655,9 +395,6 @@ tree_ssa_dominator_optimize (void)\n     }\n   while (cfg_altered);\n \n-  /* Remove any unreachable blocks left behind and linearize the CFG.  */\n-  cleanup_tree_cfg ();\n-\n   /* Debugging dumps.  */\n   if (dump_file && (dump_flags & TDF_STATS))\n     dump_dominator_optimization_stats (dump_file);\n@@ -946,23 +683,11 @@ thread_across_edge (struct dom_walk_data *walk_data, edge e)\n \t  /* If we have a known destination for the conditional, then\n \t     we can perform this optimization, which saves at least one\n \t     conditional jump each time it applies since we get to\n-\t     bypass the conditional at our original destination. \n-\n-\t     Note that we can either thread through a block with PHIs\n-\t     or to a block with PHIs, but not both.  At this time the\n-\t     bookkeeping to keep the CFG & SSA up-to-date has proven\n-\t     difficult.  */\n+\t     bypass the conditional at our original destination.   */\n \t  if (dest)\n \t    {\n-\t      int saved_forwardable = bb_ann (e->src)->forwardable;\n-\t      edge tmp_edge;\n-\n-\t      bb_ann (e->src)->forwardable = 0;\n-\t      tmp_edge = tree_block_forwards_to (dest);\n-\t      taken_edge = (tmp_edge ? tmp_edge : taken_edge);\n-\t      bb_ann (e->src)->forwardable = saved_forwardable;\n-\t      VARRAY_PUSH_EDGE (redirection_edges, e);\n-\t      VARRAY_PUSH_EDGE (redirection_edges, taken_edge);\n+\t      e->aux = taken_edge;\n+\t      bb_ann (e->dest)->incoming_edge_threaded = true;\n \t    }\n \t}\n     }"}, {"sha": "bd5e8fb22ae23f5f220225e38fcffdf322130c29", "filename": "gcc/tree-ssa-live.c", "status": "modified", "additions": 0, "deletions": 92, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56b043c808696e62bde8e722741432a2b3caa032/gcc%2Ftree-ssa-live.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56b043c808696e62bde8e722741432a2b3caa032/gcc%2Ftree-ssa-live.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-live.c?ref=56b043c808696e62bde8e722741432a2b3caa032", "patch": "@@ -1827,95 +1827,3 @@ dump_live_info (FILE *f, tree_live_info_p live, int flag)\n \t}\n     }\n }\n-\n-/* Register partitions in MAP so that we can take VARS out of SSA form. \n-   This requires a walk over all the PHI nodes and all the statements.  */\n-\n-void\n-register_ssa_partitions_for_vars (bitmap vars, var_map map)\n-{\n-  basic_block bb;\n-\n-  if (bitmap_first_set_bit (vars) >= 0)\n-    {\n-\n-      /* Find every instance (SSA_NAME) of variables in VARs and\n-\t register a new partition for them.  This requires examining\n-\t every statement and every PHI node once.  */\n-      FOR_EACH_BB (bb)\n-\t{\n-\t  block_stmt_iterator bsi;\n-\t  tree next;\n-\t  tree phi;\n-\n-\t  /* Register partitions for SSA_NAMEs appearing in the PHI\n-\t     nodes in this basic block.\n-\n-\t     Note we delete PHI nodes in this loop if they are \n-\t     associated with virtual vars which are going to be\n-\t     renamed.  */\n-\t  for (phi = phi_nodes (bb); phi; phi = next)\n-\t    {\n-\t      tree result = SSA_NAME_VAR (PHI_RESULT (phi));\n-\n-\t      next = PHI_CHAIN (phi);\n-\t      if (bitmap_bit_p (vars, var_ann (result)->uid))\n-\t\t{\n-\t\t  if (! is_gimple_reg (result))\n-\t\t    remove_phi_node (phi, NULL_TREE, bb);\n-\t\t  else\n-\t\t    {\n-\t\t      int i;\n-\n-\t\t      /* Register a partition for the result.  */\n-\t\t      register_ssa_partition (map, PHI_RESULT (phi), 0);\n-\n-\t\t      /* Register a partition for each argument as needed.  */\n-\t\t      for (i = 0; i < PHI_NUM_ARGS (phi); i++)\n-\t\t\t{\n-\t\t\t  tree arg = PHI_ARG_DEF (phi, i);\n-\n-\t\t\t  if (TREE_CODE (arg) != SSA_NAME)\n-\t\t\t    continue;\n-\t\t\t  if (!bitmap_bit_p (vars, \n-\t\t\t\t\t     var_ann (SSA_NAME_VAR (arg))->uid))\n-\t\t\t    continue;\n-\n-\t\t\t  register_ssa_partition (map, arg, 1);\n-\t\t        }\n-\t\t    }\n-\t\t}\n-\t    }\n-\n-\t  /* Now register partitions for SSA_NAMEs appearing in each\n-\t     statement in this block.  */\n-\t  for (bsi = bsi_start (bb); ! bsi_end_p (bsi); bsi_next (&bsi))\n-\t    {\n-\t      stmt_ann_t ann = stmt_ann (bsi_stmt (bsi));\n-\t      use_optype uses = USE_OPS (ann);\n-\t      def_optype defs = DEF_OPS (ann);\n-\t      unsigned int i;\n-\n-\t      for (i = 0; i < NUM_USES (uses); i++)\n-\t\t{\n-\t\t  tree op = USE_OP (uses, i);\n-\n-\t\t  if (TREE_CODE (op) == SSA_NAME\n-\t\t      && bitmap_bit_p (vars, var_ann (SSA_NAME_VAR (op))->uid))\n-\t\t    register_ssa_partition (map, op, 1);\n-\t\t}\n-\t\t    \n-\t      for (i = 0; i < NUM_DEFS (defs); i++)\n-\t\t{\n-\t\t  tree op = DEF_OP (defs, i);\n-\n-\t\t  if (TREE_CODE (op) == SSA_NAME\n-\t\t\t  && bitmap_bit_p (vars,\n-\t\t\t     var_ann (SSA_NAME_VAR (op))->uid))\n-\t\t    register_ssa_partition (map, op, 0);\n-\t\t}\n-\t    }\n-\t}\n-    }\n-}\n-"}, {"sha": "b863795049675cb4e6a1efb817ea350b534a07b3", "filename": "gcc/tree-ssa-live.h", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56b043c808696e62bde8e722741432a2b3caa032/gcc%2Ftree-ssa-live.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56b043c808696e62bde8e722741432a2b3caa032/gcc%2Ftree-ssa-live.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-live.h?ref=56b043c808696e62bde8e722741432a2b3caa032", "patch": "@@ -58,22 +58,12 @@ typedef struct _var_map\n #define VARMAP_NORMAL\t\t0\n #define VARMAP_NO_SINGLE_DEFS\t1\n \n-/* Flags to pass to remove_ssa_form.  */\n-\n-#define SSANORM_PERFORM_TER\t\t0x1\n-#define SSANORM_COMBINE_TEMPS\t\t0x2\n-#define SSANORM_REMOVE_ALL_PHIS\t\t0x4\n-#define SSANORM_COALESCE_PARTITIONS\t0x8\n-#define SSANORM_USE_COALESCE_LIST\t0x10\n-\n extern var_map init_var_map (int);\n extern void delete_var_map (var_map);\n extern void dump_var_map (FILE *, var_map);\n extern int var_union (var_map, tree, tree);\n extern void change_partition_var (var_map, tree, int);\n extern void compact_var_map (var_map, int);\n-extern void remove_ssa_form (FILE *, var_map, int);\n-extern void register_ssa_partitions_for_vars (bitmap vars, var_map map);\n extern tree make_ssa_temp (tree);\n \n static inline int num_var_partitions (var_map);"}, {"sha": "37c893073de01dd9bfc9c1933d96d6c20e0cfab4", "filename": "gcc/tree-ssa-threadupdate.c", "status": "added", "additions": 421, "deletions": 0, "changes": 421, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56b043c808696e62bde8e722741432a2b3caa032/gcc%2Ftree-ssa-threadupdate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56b043c808696e62bde8e722741432a2b3caa032/gcc%2Ftree-ssa-threadupdate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadupdate.c?ref=56b043c808696e62bde8e722741432a2b3caa032", "patch": "@@ -0,0 +1,421 @@\n+/* Thread edges through blocks and update the control flow and SSA graphs.\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"tree.h\"\n+#include \"flags.h\"\n+#include \"rtl.h\"\n+#include \"tm_p.h\"\n+#include \"ggc.h\"\n+#include \"basic-block.h\"\n+#include \"output.h\"\n+#include \"errors.h\"\n+#include \"expr.h\"\n+#include \"function.h\"\n+#include \"diagnostic.h\"\n+#include \"tree-flow.h\"\n+#include \"tree-dump.h\"\n+#include \"tree-pass.h\"\n+\n+/* Given a block B, update the CFG and SSA graph to reflect redirecting\n+   one or more in-edges to B to instead reach the destination of an\n+   out-edge from B while preserving any side effects in B.\n+\n+   ie, given A->B and B->C, change A->B to be A->C yet still preserve the\n+   side effects of executing B.\n+\n+     1. Make a copy of B (including its outgoing edges and statements).  Call\n+\tthe copy B'.  Note B' has no incoming edges or PHIs at this time.\n+\n+     2. Remove the control statement at the end of B' and all outgoing edges\n+\texcept B'->C.\n+\n+     3. Add a new argument to each PHI in C with the same value as the existing\n+\targument associated with edge B->C.  Associate the new PHI arguments\n+\twith the edge B'->C.\n+\n+     4. For each PHI in B, find or create a PHI in B' with an identical\n+\tPHI_RESULT.  Add an argument to the PHI in B' which as the same\n+\tvalue as the PHI in B associated with the edge A->B.  Associate\n+\tthe new argument in the PHI in B' with the edge A->B.\n+\n+     5. Change the edge A->B to A->B'.\n+\n+\t5a. This automatically deletes any PHI arguments associated with the\n+\t    edge A->B in B.\n+\n+\t5b. This automatically associates each new argument added in step 4\n+\t    with the edge A->B'.\n+\n+     6. Repeat for other incoming edges into B.\n+\n+     7. Put the duplicated resources in B and all the B' blocks into SSA form.\n+\n+   Note that block duplication can be minimized by first collecting the\n+   the set of unique destination blocks that the incoming edges should\n+   be threaded to.  Block duplication can be further minimized by using \n+   B instead of creating B' for one destination if all edges into B are\n+   going to be threaded to a successor of B.  */\n+\n+\n+/* Main data structure recording information regarding B's duplicate\n+   blocks.  */\n+\n+struct redirection_data\n+{\n+  /* A duplicate of B with the trailing control statement removed and which\n+     targets a single successor of B.  */\n+  basic_block dup_block;\n+\n+  /* An outgoing edge from B.  DUP_BLOCK will have OUTGOING_EDGE->dest as\n+     its single successor.  */\n+  edge outgoing_edge;\n+};\n+\n+/* For each PHI node in BB, find or create a PHI node in NEW_BB for the\n+   same PHI_RESULT.  Add an argument to the PHI node in NEW_BB which\n+   corresponds to the same PHI argument associated with edge E in BB.  */\n+\n+static void\n+copy_phis_to_block (basic_block new_bb, basic_block bb, edge e)\n+{\n+  tree phi, arg;\n+\n+  /* Walk over every PHI in BB.  */\n+  for (phi = phi_nodes (bb); phi; phi = PHI_CHAIN (phi))\n+    {\n+      tree new_phi;\n+\n+      /* First try to find a PHI node in NEW_BB which has the same\n+         PHI_RESULT as the PHI from BB we are currently processing.  */\n+      for (new_phi = phi_nodes (new_bb); new_phi;\n+\t   new_phi = PHI_CHAIN (new_phi))\n+\tif (PHI_RESULT (new_phi) == PHI_RESULT (phi))\n+\t  break;\n+\n+      /* If we did not find a suitable PHI in NEW_BB, create one.  */\n+      if (!new_phi)\n+\tnew_phi = create_phi_node (PHI_RESULT (phi), new_bb);\n+\n+      /* Extract the argument corresponding to E from the current PHI\n+         node in BB.  */\n+      arg = PHI_ARG_DEF_TREE (phi, phi_arg_from_edge (phi, e));\n+\n+      /* Now add that same argument to the new PHI node in block NEW_BB.  */\n+      add_phi_arg (&new_phi, arg, e);\n+    }\n+}\n+\n+/* Remove the last statement in block BB which must be a COND_EXPR or\n+   SWITCH_EXPR.  Also remove all outgoing edges except the edge which\n+   reaches DEST_BB.\n+\n+   This is only used by jump threading which knows the last statement in\n+   BB should be a COND_EXPR or SWITCH_EXPR.  If the block ends with any other\n+   statement, then we abort.  */\n+\n+static void\n+remove_last_stmt_and_useless_edges (basic_block bb, basic_block dest_bb)\n+{\n+  block_stmt_iterator bsi;\n+  edge e, next;\n+\n+  bsi = bsi_last (bb);\n+\n+#ifdef ENABLE_CHECKING\n+  if (TREE_CODE (bsi_stmt (bsi)) != COND_EXPR\n+      && TREE_CODE (bsi_stmt (bsi)) != SWITCH_EXPR)\n+    abort ();\n+#endif\n+\n+  bsi_remove (&bsi);\n+\n+  next = NULL;\n+  for (e = bb->succ; e; e = next)\n+    {\n+      next = e->succ_next;\n+\n+      if (e->dest != dest_bb)\n+\tssa_remove_edge (e);\n+    }\n+\n+  /* BB now has a single outgoing edge. We need to update the flags for\n+     that single outgoing edge.  */\n+  bb->succ->flags &= ~(EDGE_TRUE_VALUE | EDGE_FALSE_VALUE);\n+  bb->succ->flags |= EDGE_FALLTHRU;\n+}\n+\n+/* Create a duplicate of BB which only reaches the destination of the edge\n+   stored in RD.  Record the duplicate block in RD.  */\n+\n+static void\n+create_block_for_threading (basic_block bb, struct redirection_data *rd)\n+{\n+  tree phi;\n+\n+  /* We can use the generic block duplication code and simply remove\n+     the stuff we do not need.  */\n+  rd->dup_block = duplicate_block (bb, NULL);\n+\n+  /* The call to duplicate_block will copy everything, including the\n+     useless COND_EXPR or SWITCH_EXPR at the end of the block.  We just remove\n+     the useless COND_EXPR or SWITCH_EXPR here rather than having a\n+     specialized block copier.  */\n+  remove_last_stmt_and_useless_edges (rd->dup_block, rd->outgoing_edge->dest);\n+\n+  /* If there are any PHI nodes at the destination of the outgoing edge\n+     from the duplicate block, then we will need to add a new argument\n+     to them.  The argument should have the same value as the argument\n+     associated with the outgoing edge stored in RD.  */\n+  for (phi = phi_nodes (rd->dup_block->succ->dest); phi;\n+       phi = PHI_CHAIN (phi))\n+    {\n+      int indx = phi_arg_from_edge (phi, rd->outgoing_edge);\n+      add_phi_arg (&phi, PHI_ARG_DEF_TREE (phi, indx), rd->dup_block->succ);\n+    }\n+}\n+\n+/* BB is a block which ends with a COND_EXPR or SWITCH_EXPR and when BB\n+   is reached via one or more specific incoming edges, we know which\n+   outgoing edge from BB will be traversed.\n+\n+   We want to redirect those incoming edges to the target of the \n+   appropriate outgoing edge.  Doing so avoids a conditional branch\n+   and may expose new optimization opportunities.  Note that we have\n+   to update dominator tree and SSA graph after such changes.\n+\n+   The key to keeping the SSA graph update managable is to duplicate\n+   the side effects occuring in BB so that those side effects still\n+   occur on the paths which bypass BB after redirecting edges.\n+\n+   We accomplish this by creating duplicates of BB and arranging for\n+   the duplicates to unconditionally pass control to one specific\n+   successor of BB.  We then revector the incoming edges into BB to\n+   the appropriate duplicate of BB.\n+\n+   BB and its duplicates will have assignments to the same set of\n+   SSA_NAMEs.  Right now, we just call into rewrite_ssa_into_ssa\n+   to update the SSA graph for those names.\n+\n+   We are also going to experiment with a true incremental update\n+   scheme for the duplicated resources.  Of of the interesting\n+   properties we can exploit here is that all the resources set\n+   in BB will have the same IDFS, so we have one IDFS computation\n+   per block with incoming threaded edges, which can lower the\n+   cost of the true incremental update algorithm.  */\n+\n+static void\n+thread_block (basic_block bb)\n+{\n+  /* E is an incoming edge into BB that we may or may not want to\n+     redirect to a duplicate of BB.  */\n+  edge e;\n+\n+  /* The next edge in a predecessor list.  Used in loops where E->pred_next\n+     may change within the loop.  */\n+  edge next;\n+\n+  /* ALL indicates whether or not all incoming edges into BB should\n+     be threaded to a duplicate of BB.  */\n+  bool all = true;\n+\n+  /* Main data structure to hold information for duplicates of BB.  */\n+  varray_type redirection_data;\n+  unsigned int i;\n+\n+  VARRAY_GENERIC_PTR_INIT (redirection_data, 2, \"redirection data\");\n+\n+  /* Look at each incoming edge into BB.  Record each unique outgoing\n+     edge that we want to thread an incoming edge to.  Also note if\n+     all incoming edges are threaded or not.  */\n+  for (e = bb->pred; e; e = e->pred_next)\n+    {\n+      if (!e->aux)\n+\t{\n+\t  all = false;\n+\t}\n+      else\n+\t{\n+\t  unsigned int i;\n+\n+\t  /* See if we can find an entry for the destination of this\n+\t     threaded edge that has already been recorded.  */\n+\t  for (i = 0; i < VARRAY_ACTIVE_SIZE (redirection_data); i++)\n+\t    {\n+\t      struct redirection_data *rd;\n+\t      edge e2;\n+\n+\t      rd = VARRAY_GENERIC_PTR (redirection_data, i);\n+\t      e2 = e->aux;\n+\n+\t      if (e2->dest == rd->outgoing_edge->dest)\n+\t\tbreak;\n+\t    }\n+\n+\t  /* If the loop did not terminate early, then we have a new\n+\t     destination for the incoming threaded edges.  Record it.  */\n+\t  if (i == VARRAY_ACTIVE_SIZE (redirection_data))\n+\t    {\n+\t      struct redirection_data *rd;\n+\n+\t      rd = xcalloc (1, sizeof (redirection_data));\n+\t      rd->outgoing_edge = e->aux;\n+\t      VARRAY_PUSH_GENERIC_PTR (redirection_data, rd);\n+\t    }\n+\t}\n+    }\n+\n+  /* Now create duplicates of BB.  Note that if all incoming edges are\n+     threaded, then BB is going to become unreachable.  In that case\n+     we use BB for one of the duplicates rather than wasting memory\n+     duplicating BB.  Thus the odd starting condition for the loop.  */\n+  for (i = (all ? 1 : 0); i < VARRAY_ACTIVE_SIZE (redirection_data); i++)\n+    {\n+      struct redirection_data *rd = VARRAY_GENERIC_PTR (redirection_data, i);\n+      create_block_for_threading (bb, rd);\n+    }\n+\n+  /* The loop above created the duplicate blocks (and the statements\n+     within the duplicate blocks).  This loop creates PHI nodes for the\n+     duplicated blocks and redirects the incoming edges into BB to reach\n+     the duplicates of BB.\n+\n+     Note that redirecting the edge will change e->pred_next, so we have\n+     to hold e->pred_next in a temporary. \n+\n+     If this turns out to be a performance problem, then we could create\n+     a list of incoming edges associated with each entry in \n+     REDIRECTION_DATA and walk over that list of edges instead.  */\n+  next = NULL;\n+  for (e = bb->pred; e; e = next)\n+    {\n+      edge new_dest = e->aux;\n+\n+      next = e->pred_next;\n+\n+      /* E was not threaded, then there is nothing to do.  */\n+      if (!new_dest)\n+\tcontinue;\n+\n+      /* Go ahead and clear E->aux.  It's not needed anymore and failure\n+         to clear it will cause all kinds of unpleasant problems later.  */\n+      e->aux = NULL;\n+\n+      /* We know E is an edge we want to thread.  Find the entry associated\n+         with E's new destination in the REDIRECTION_DATA array.  */\n+      for (i = 0; i < VARRAY_ACTIVE_SIZE (redirection_data); i++)\n+\t{\n+\t  struct redirection_data *rd;\n+\n+\t  rd = VARRAY_GENERIC_PTR (redirection_data, i);\n+\n+\t  /* We have found the right entry if the outgoing edge in this\n+\t     entry matches E's new destination.  Note that if we have not\n+\t     created a duplicate block (rd->dup_block is NULL), then we\n+\t     are going to re-use BB as a duplicate and we do not need\n+\t     to create PHI nodes or redirect the edge.  */\n+\t  if (rd->outgoing_edge == new_dest && rd->dup_block)\n+\t    {\n+\t      edge e2;\n+\t      copy_phis_to_block (rd->dup_block, bb, e);\n+\n+\t      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\tfprintf (dump_file, \"  Threaded jump %d --> %d to %d\\n\",\n+\t\t\t e->src->index, e->dest->index, rd->dup_block->index);\n+\n+\t      e2 = redirect_edge_and_branch (e, rd->dup_block);\n+\t      PENDING_STMT (e2) = NULL;\n+\n+\t      if ((dump_file && (dump_flags & TDF_DETAILS))\n+\t\t  && e->src != e2->src)\n+\t      fprintf (dump_file, \"    basic block %d created\\n\",\n+\t\t       e2->src->index);\n+\t      break;\n+\t    }\n+\t}\n+    }\n+\n+  /* If all the incoming edges where threaded, then we used BB as one\n+     of the duplicate blocks.  We need to fixup BB in that case so that\n+     it no longer has a COND_EXPR or SWITCH_EXPR and reaches one destination\n+     unconditionally.  */\n+  if (all)\n+    {\n+      struct redirection_data *rd;\n+\n+      rd = VARRAY_GENERIC_PTR (redirection_data, 0);\n+\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file, \"  Threaded jump %d --> %d to %d\\n\",\n+\t\t bb->pred->src->index, bb->index, bb->succ->dest->index);\n+\n+      remove_last_stmt_and_useless_edges (bb, rd->outgoing_edge->dest);\n+    }\n+\n+  /* Done with this block.  Free any memory we have allocated, clear\n+     REDIRECTION_DATA and unmark this block as needing incoming\n+     edge redirections.  */\n+  for (i = 0; i < VARRAY_ACTIVE_SIZE (redirection_data); i++)\n+    {\n+      struct redirection_data *rd = VARRAY_GENERIC_PTR (redirection_data, i);\n+      free (rd);\n+    }\n+  VARRAY_CLEAR (redirection_data);\n+}\n+\n+/* Walk through all blocks and thread incoming edges to the block's \n+   destinations as requested.  This is the only entry point into this\n+   file.\n+\n+   Blocks which have one or more incoming edges have INCOMING_EDGE_THREADED\n+   set in the block's annotation.\n+   this routine.\n+\n+   Each edge that should be threaded has the new destination edge stored in\n+   the original edge's AUX field.\n+\n+   This routine (or one of its callees) will clear INCOMING_EDGE_THREADED\n+   in the block annotations and the AUX field in the edges.\n+\n+   It is the caller's responsibility to fix the dominance information\n+   and rewrite duplicated SSA_NAMEs back into SSA form.\n+\n+   Returns true if one or more edges were threaded, false otherwise.   */\n+\n+bool\n+thread_through_all_blocks (void)\n+{\n+  basic_block bb;\n+  bool retval = false;\n+\n+  FOR_EACH_BB (bb)\n+    {\n+      if (bb_ann (bb)->incoming_edge_threaded)\n+\t{\n+\t  thread_block (bb);\n+\t  retval = true;\n+\t  bb_ann (bb)->incoming_edge_threaded = false;\n+\t}\n+    }\n+  return retval;\n+}"}, {"sha": "a75a0ea23db953b17cb0d0f156d75df4fba43717", "filename": "gcc/tree.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56b043c808696e62bde8e722741432a2b3caa032/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56b043c808696e62bde8e722741432a2b3caa032/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=56b043c808696e62bde8e722741432a2b3caa032", "patch": "@@ -3770,4 +3770,7 @@ extern bool in_gimple_form;\n tree lower_bound_in_type (tree, tree);\n tree upper_bound_in_type (tree, tree);\n \n+/* In tree-ssa-threadupdate.c.  */\n+extern bool thread_through_all_blocks (void);\n+\n #endif  /* GCC_TREE_H  */"}]}