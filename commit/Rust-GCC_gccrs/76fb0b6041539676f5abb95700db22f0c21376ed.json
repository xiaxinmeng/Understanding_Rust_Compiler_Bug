{"sha": "76fb0b6041539676f5abb95700db22f0c21376ed", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzZmYjBiNjA0MTUzOTY3NmY1YWJiOTU3MDBkYjIyZjBjMjEzNzZlZA==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-10-21T02:43:58Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-10-21T02:43:58Z"}, "message": "(fold_rtx): Alter previous change: don't fold the shift\nif the count exceeds the width of the value inside the subreg.\n\n(note_mem_written): (mem (scratch)) means clobber everything.\n\n(fold_rtx): Special case handling for folding\na subreg of the result of a left shift.\n\nFrom-SVN: r5854", "tree": {"sha": "bb48288a4b6fdbe77ceb8d312da5b847b9711692", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bb48288a4b6fdbe77ceb8d312da5b847b9711692"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/76fb0b6041539676f5abb95700db22f0c21376ed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76fb0b6041539676f5abb95700db22f0c21376ed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/76fb0b6041539676f5abb95700db22f0c21376ed", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76fb0b6041539676f5abb95700db22f0c21376ed/comments", "author": null, "committer": null, "parents": [{"sha": "cc8187fc1da50b99899be52de1ce2aa83483d238", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc8187fc1da50b99899be52de1ce2aa83483d238", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cc8187fc1da50b99899be52de1ce2aa83483d238"}], "stats": {"total": 27, "additions": 26, "deletions": 1}, "files": [{"sha": "ade0532ce4521fb05dedb79be00053f3048062ac", "filename": "gcc/cse.c", "status": "modified", "additions": 26, "deletions": 1, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76fb0b6041539676f5abb95700db22f0c21376ed/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76fb0b6041539676f5abb95700db22f0c21376ed/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=76fb0b6041539676f5abb95700db22f0c21376ed", "patch": "@@ -4729,7 +4729,29 @@ fold_rtx (x, insn)\n \t\t  if (op1)\n \t\t    op1 = equiv_constant (op1);\n \n-\t\t  if (op0 && op1)\n+\t\t  /* If we are looking for the low SImode part of \n+\t\t     (ashift:DI c (const_int 32)), it doesn't work\n+\t\t     to compute that in SImode, because a 32-bit shift\n+\t\t     in SImode is unpredictable.  We know the value is 0.  */\n+\t\t  if (op0 && op1\n+\t\t      && (GET_CODE (elt->exp) == ASHIFT\n+\t\t\t  || GET_CODE (elt->exp) == LSHIFT)\n+\t\t      && GET_CODE (op1) == CONST_INT\n+\t\t      && INTVAL (op1) >= GET_MODE_BITSIZE (mode))\n+\t\t    {\n+\t\t      if (INTVAL (op1) < GET_MODE_BITSIZE (GET_MODE (elt->exp)))\n+\t\t\t\n+\t\t\t/* If the count fits in the inner mode's width,\n+\t\t\t   but exceeds the outer mode's width,\n+\t\t\t   the value will get truncated to 0\n+\t\t\t   by the subreg.  */\n+\t\t\tnew = const0_rtx;\n+\t\t      else\n+\t\t\t/* If the count exceeds even the inner mode's width,\n+\t\t\t   don't fold this expression.  */\n+\t\t\tnew = 0;\n+\t\t    }\n+\t\t  else if (op0 && op1)\n \t\t    new = simplify_binary_operation (GET_CODE (elt->exp), mode,\n \t\t\t\t\t\t     op0, op1);\n \t\t}\n@@ -7101,6 +7123,9 @@ note_mem_written (written, writes_ptr)\n \t}\n       else if (GET_MODE (written) == BLKmode)\n \t*writes_ptr = everything;\n+      /* (mem (scratch)) means clobber everything.  */\n+      else if (GET_CODE (addr) == SCRATCH)\n+\t*writes_ptr = everything;\n       else if (cse_rtx_addr_varies_p (written))\n \t{\n \t  /* A varying address that is a sum indicates an array element,"}]}