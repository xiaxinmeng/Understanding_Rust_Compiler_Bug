{"sha": "75505450f647279fc6fecc603cedf6702c871dc2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzU1MDU0NTBmNjQ3Mjc5ZmM2ZmVjYzYwM2NlZGY2NzAyYzg3MWRjMg==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2005-03-06T00:42:56Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2005-03-06T00:42:56Z"}, "message": "* fold-const.c (fold): Remove handling of binary expressions.\n\nFrom-SVN: r95961", "tree": {"sha": "5f344e5535af0e66a0d00c8427062bf3e9c63dbe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5f344e5535af0e66a0d00c8427062bf3e9c63dbe"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/75505450f647279fc6fecc603cedf6702c871dc2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75505450f647279fc6fecc603cedf6702c871dc2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/75505450f647279fc6fecc603cedf6702c871dc2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75505450f647279fc6fecc603cedf6702c871dc2/comments", "author": null, "committer": null, "parents": [{"sha": "5c2ff394f325de79c7b73a4502a8239077c64e0e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c2ff394f325de79c7b73a4502a8239077c64e0e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5c2ff394f325de79c7b73a4502a8239077c64e0e"}], "stats": {"total": 2600, "additions": 2, "deletions": 2598}, "files": [{"sha": "e6c7fa8321cc627419b2873e57d2a241abd61cc7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75505450f647279fc6fecc603cedf6702c871dc2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75505450f647279fc6fecc603cedf6702c871dc2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=75505450f647279fc6fecc603cedf6702c871dc2", "patch": "@@ -6,6 +6,8 @@\n \t(NON_TYPE_CHECK): Use TYPE_P instead of\n \tIS_NON_TYPE_CODE_CLASS.\n \n+\t* fold-const.c (fold): Remove handling of binary expressions.\n+\n 2005-03-05  James A. Morrison  <phython@gcc.gnu.org>\n \n \t* doc/c-tree.texi: Wrap comments in @r{}."}, {"sha": "04f56eb11483bd049908c5ef79dc95d19aee6405", "filename": "gcc/fold-const.c", "status": "modified", "additions": 0, "deletions": 2598, "changes": 2598, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75505450f647279fc6fecc603cedf6702c871dc2/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75505450f647279fc6fecc603cedf6702c871dc2/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=75505450f647279fc6fecc603cedf6702c871dc2", "patch": "@@ -9873,17 +9873,9 @@ tree\n fold (tree expr)\n {\n   const tree t = expr;\n-  const tree type = TREE_TYPE (expr);\n-  tree t1 = NULL_TREE;\n-  tree tem;\n-  tree arg0 = NULL_TREE, arg1 = NULL_TREE;\n   enum tree_code code = TREE_CODE (t);\n   enum tree_code_class kind = TREE_CODE_CLASS (code);\n \n-  /* WINS will be nonzero when the switch is done\n-     if all operands are constant.  */\n-  int wins = 1;\n-\n   /* Return right away if a constant.  */\n   if (kind == tcc_constant)\n     return t;\n@@ -9903,2601 +9895,11 @@ fold (tree expr)\n \t}\n     }\n \n-  if (IS_EXPR_CODE_CLASS (kind))\n-    {\n-      int len = TREE_CODE_LENGTH (code);\n-      int i;\n-      for (i = 0; i < len; i++)\n-\t{\n-\t  tree op = TREE_OPERAND (t, i);\n-\t  tree subop;\n-\n-\t  if (op == 0)\n-\t    continue;\t\t/* Valid for CALL_EXPR, at least.  */\n-\n-\t  /* Strip any conversions that don't change the mode.  This is\n-\t     safe for every expression, except for a comparison expression\n-\t     because its signedness is derived from its operands.  So, in\n-\t     the latter case, only strip conversions that don't change the\n-\t     signedness.\n-\n-\t     Note that this is done as an internal manipulation within the\n-\t     constant folder, in order to find the simplest representation\n-\t     of the arguments so that their form can be studied.  In any\n-\t     cases, the appropriate type conversions should be put back in\n-\t     the tree that will get out of the constant folder.  */\n-\t  if (kind == tcc_comparison)\n-\t    STRIP_SIGN_NOPS (op);\n-\t  else\n-\t    STRIP_NOPS (op);\n-\n-\t  if (TREE_CODE (op) == COMPLEX_CST)\n-\t    subop = TREE_REALPART (op);\n-\t  else\n-\t    subop = op;\n-\n-\t  if (TREE_CODE (subop) != INTEGER_CST\n-\t      && TREE_CODE (subop) != REAL_CST)\n-\t    /* Note that TREE_CONSTANT isn't enough:\n-\t       static var addresses are constant but we can't\n-\t       do arithmetic on them.  */\n-\t    wins = 0;\n-\n-\t  if (i == 0)\n-\t    arg0 = op;\n-\t  else if (i == 1)\n-\t    arg1 = op;\n-\t}\n-    }\n-\n-  /* If this is a commutative operation, and ARG0 is a constant, move it\n-     to ARG1 to reduce the number of tests below.  */\n-  if (commutative_tree_code (code)\n-      && tree_swap_operands_p (arg0, arg1, true))\n-    return fold (build2 (code, type, TREE_OPERAND (t, 1),\n-\t\t\t TREE_OPERAND (t, 0)));\n-\n-  /* Now WINS is set as described above,\n-     ARG0 is the first operand of EXPR,\n-     and ARG1 is the second operand (if it has more than one operand).\n-\n-     First check for cases where an arithmetic operation is applied to a\n-     compound, conditional, or comparison operation.  Push the arithmetic\n-     operation inside the compound or conditional to see if any folding\n-     can then be done.  Convert comparison to conditional for this purpose.\n-     The also optimizes non-constant cases that used to be done in\n-     expand_expr.\n-\n-     Before we do that, see if this is a BIT_AND_EXPR or a BIT_IOR_EXPR,\n-     one of the operands is a comparison and the other is a comparison, a\n-     BIT_AND_EXPR with the constant 1, or a truth value.  In that case, the\n-     code below would make the expression more complex.  Change it to a\n-     TRUTH_{AND,OR}_EXPR.  Likewise, convert a similar NE_EXPR to\n-     TRUTH_XOR_EXPR and an EQ_EXPR to the inversion of a TRUTH_XOR_EXPR.  */\n-\n-  if ((code == BIT_AND_EXPR || code == BIT_IOR_EXPR\n-       || code == EQ_EXPR || code == NE_EXPR)\n-      && ((truth_value_p (TREE_CODE (arg0))\n-\t   && (truth_value_p (TREE_CODE (arg1))\n-\t       || (TREE_CODE (arg1) == BIT_AND_EXPR\n-\t\t   && integer_onep (TREE_OPERAND (arg1, 1)))))\n-\t  || (truth_value_p (TREE_CODE (arg1))\n-\t      && (truth_value_p (TREE_CODE (arg0))\n-\t\t  || (TREE_CODE (arg0) == BIT_AND_EXPR\n-\t\t      && integer_onep (TREE_OPERAND (arg0, 1)))))))\n-    {\n-      tem = fold (build2 (code == BIT_AND_EXPR ? TRUTH_AND_EXPR\n-\t\t\t  : code == BIT_IOR_EXPR ? TRUTH_OR_EXPR\n-\t\t\t  : TRUTH_XOR_EXPR,\n-\t\t\t  type, fold_convert (boolean_type_node, arg0),\n-\t\t\t  fold_convert (boolean_type_node, arg1)));\n-\n-      if (code == EQ_EXPR)\n-\ttem = invert_truthvalue (tem);\n-\n-      return tem;\n-    }\n-\n-  if (TREE_CODE_CLASS (code) == tcc_comparison\n-\t   && TREE_CODE (arg0) == COMPOUND_EXPR)\n-    return build2 (COMPOUND_EXPR, type, TREE_OPERAND (arg0, 0),\n-\t\t   fold (build2 (code, type, TREE_OPERAND (arg0, 1), arg1)));\n-  else if (TREE_CODE_CLASS (code) == tcc_comparison\n-\t   && TREE_CODE (arg1) == COMPOUND_EXPR)\n-    return build2 (COMPOUND_EXPR, type, TREE_OPERAND (arg1, 0),\n-\t\t   fold (build2 (code, type, arg0, TREE_OPERAND (arg1, 1))));\n-  else if (TREE_CODE_CLASS (code) == tcc_binary\n-\t   || TREE_CODE_CLASS (code) == tcc_comparison)\n-    {\n-      if (TREE_CODE (arg0) == COMPOUND_EXPR)\n-\treturn build2 (COMPOUND_EXPR, type, TREE_OPERAND (arg0, 0),\n-\t\t       fold (build2 (code, type, TREE_OPERAND (arg0, 1),\n-\t\t\t\t     arg1)));\n-      if (TREE_CODE (arg1) == COMPOUND_EXPR\n-\t  && reorder_operands_p (arg0, TREE_OPERAND (arg1, 0)))\n-\treturn build2 (COMPOUND_EXPR, type, TREE_OPERAND (arg1, 0),\n-\t\t       fold (build2 (code, type,\n-\t\t\t\t     arg0, TREE_OPERAND (arg1, 1))));\n-\n-      if (TREE_CODE (arg0) == COND_EXPR || COMPARISON_CLASS_P (arg0))\n-\t{\n-\t  tem = fold_binary_op_with_conditional_arg (t, code, arg0, arg1, \n-\t\t\t\t\t\t     /*cond_first_p=*/1);\n-\t  if (tem != NULL_TREE)\n-\t    return tem;\n-\t}\n-\n-      if (TREE_CODE (arg1) == COND_EXPR || COMPARISON_CLASS_P (arg1))\n-\t{\n-\t  tem = fold_binary_op_with_conditional_arg (t, code, arg1, arg0, \n-\t\t\t\t\t             /*cond_first_p=*/0);\n-\t  if (tem != NULL_TREE)\n-\t    return tem;\n-\t}\n-    }\n-\n   switch (code)\n     {\n     case CONST_DECL:\n       return fold (DECL_INITIAL (t));\n \n-    case RANGE_EXPR:\n-      if (TREE_CONSTANT (t) != wins)\n-\t{\n-\t  tem = copy_node (t);\n-\t  TREE_CONSTANT (tem) = wins;\n-\t  TREE_INVARIANT (tem) = wins;\n-\t  return tem;\n-\t}\n-      return t;\n-\n-    case PLUS_EXPR:\n-      /* A + (-B) -> A - B */\n-      if (TREE_CODE (arg1) == NEGATE_EXPR)\n-\treturn fold (build2 (MINUS_EXPR, type, arg0, TREE_OPERAND (arg1, 0)));\n-      /* (-A) + B -> B - A */\n-      if (TREE_CODE (arg0) == NEGATE_EXPR\n-\t  && reorder_operands_p (TREE_OPERAND (arg0, 0), arg1))\n-\treturn fold (build2 (MINUS_EXPR, type, arg1, TREE_OPERAND (arg0, 0)));\n-\n-      if (TREE_CODE (type) == COMPLEX_TYPE)\n-\t{\n-\t  tem = fold_complex_add (type, arg0, arg1, PLUS_EXPR);\n-\t  if (tem)\n-\t    return tem;\n-\t}\n-\n-      if (! FLOAT_TYPE_P (type))\n-\t{\n-\t  if (integer_zerop (arg1))\n-\t    return non_lvalue (fold_convert (type, arg0));\n-\n-\t  /* If we are adding two BIT_AND_EXPR's, both of which are and'ing\n-\t     with a constant, and the two constants have no bits in common,\n-\t     we should treat this as a BIT_IOR_EXPR since this may produce more\n-\t     simplifications.  */\n-\t  if (TREE_CODE (arg0) == BIT_AND_EXPR\n-\t      && TREE_CODE (arg1) == BIT_AND_EXPR\n-\t      && TREE_CODE (TREE_OPERAND (arg0, 1)) == INTEGER_CST\n-\t      && TREE_CODE (TREE_OPERAND (arg1, 1)) == INTEGER_CST\n-\t      && integer_zerop (const_binop (BIT_AND_EXPR,\n-\t\t\t\t\t     TREE_OPERAND (arg0, 1),\n-\t\t\t\t\t     TREE_OPERAND (arg1, 1), 0)))\n-\t    {\n-\t      code = BIT_IOR_EXPR;\n-\t      goto bit_ior;\n-\t    }\n-\n-\t  /* Reassociate (plus (plus (mult) (foo)) (mult)) as\n-\t     (plus (plus (mult) (mult)) (foo)) so that we can\n-\t     take advantage of the factoring cases below.  */\n-\t  if (((TREE_CODE (arg0) == PLUS_EXPR\n-\t\t|| TREE_CODE (arg0) == MINUS_EXPR)\n-\t       && TREE_CODE (arg1) == MULT_EXPR)\n-\t      || ((TREE_CODE (arg1) == PLUS_EXPR\n-\t\t   || TREE_CODE (arg1) == MINUS_EXPR)\n-\t\t  && TREE_CODE (arg0) == MULT_EXPR))\n-\t    {\n-\t      tree parg0, parg1, parg, marg;\n-\t      enum tree_code pcode;\n-\n-\t      if (TREE_CODE (arg1) == MULT_EXPR)\n-\t\tparg = arg0, marg = arg1;\n-\t      else\n-\t\tparg = arg1, marg = arg0;\n-\t      pcode = TREE_CODE (parg);\n-\t      parg0 = TREE_OPERAND (parg, 0);\n-\t      parg1 = TREE_OPERAND (parg, 1);\n-\t      STRIP_NOPS (parg0);\n-\t      STRIP_NOPS (parg1);\n-\n-\t      if (TREE_CODE (parg0) == MULT_EXPR\n-\t\t  && TREE_CODE (parg1) != MULT_EXPR)\n-\t\treturn fold (build2 (pcode, type,\n-\t\t\t\t     fold (build2 (PLUS_EXPR, type,\n-\t\t\t\t\t\t   fold_convert (type, parg0),\n-\t\t\t\t\t\t   fold_convert (type, marg))),\n-\t\t\t\t     fold_convert (type, parg1)));\n-\t      if (TREE_CODE (parg0) != MULT_EXPR\n-\t\t  && TREE_CODE (parg1) == MULT_EXPR)\n-\t\treturn fold (build2 (PLUS_EXPR, type,\n-\t\t\t\t     fold_convert (type, parg0),\n-\t\t\t\t     fold (build2 (pcode, type,\n-\t\t\t\t\t\t   fold_convert (type, marg),\n-\t\t\t\t\t\t   fold_convert (type,\n-\t\t\t\t\t\t\t\t parg1)))));\n-\t    }\n-\n-\t  if (TREE_CODE (arg0) == MULT_EXPR && TREE_CODE (arg1) == MULT_EXPR)\n-\t    {\n-\t      tree arg00, arg01, arg10, arg11;\n-\t      tree alt0 = NULL_TREE, alt1 = NULL_TREE, same;\n-\n-\t      /* (A * C) + (B * C) -> (A+B) * C.\n-\t\t We are most concerned about the case where C is a constant,\n-\t\t but other combinations show up during loop reduction.  Since\n-\t\t it is not difficult, try all four possibilities.  */\n-\n-\t      arg00 = TREE_OPERAND (arg0, 0);\n-\t      arg01 = TREE_OPERAND (arg0, 1);\n-\t      arg10 = TREE_OPERAND (arg1, 0);\n-\t      arg11 = TREE_OPERAND (arg1, 1);\n-\t      same = NULL_TREE;\n-\n-\t      if (operand_equal_p (arg01, arg11, 0))\n-\t\tsame = arg01, alt0 = arg00, alt1 = arg10;\n-\t      else if (operand_equal_p (arg00, arg10, 0))\n-\t\tsame = arg00, alt0 = arg01, alt1 = arg11;\n-\t      else if (operand_equal_p (arg00, arg11, 0))\n-\t\tsame = arg00, alt0 = arg01, alt1 = arg10;\n-\t      else if (operand_equal_p (arg01, arg10, 0))\n-\t\tsame = arg01, alt0 = arg00, alt1 = arg11;\n-\n-\t      /* No identical multiplicands; see if we can find a common\n-\t\t power-of-two factor in non-power-of-two multiplies.  This\n-\t\t can help in multi-dimensional array access.  */\n-\t      else if (TREE_CODE (arg01) == INTEGER_CST\n-\t\t       && TREE_CODE (arg11) == INTEGER_CST\n-\t\t       && TREE_INT_CST_HIGH (arg01) == 0\n-\t\t       && TREE_INT_CST_HIGH (arg11) == 0)\n-\t\t{\n-\t\t  HOST_WIDE_INT int01, int11, tmp;\n-\t\t  int01 = TREE_INT_CST_LOW (arg01);\n-\t\t  int11 = TREE_INT_CST_LOW (arg11);\n-\n-\t\t  /* Move min of absolute values to int11.  */\n-\t\t  if ((int01 >= 0 ? int01 : -int01)\n-\t\t      < (int11 >= 0 ? int11 : -int11))\n-\t\t    {\n-\t\t      tmp = int01, int01 = int11, int11 = tmp;\n-\t\t      alt0 = arg00, arg00 = arg10, arg10 = alt0;\n-\t\t      alt0 = arg01, arg01 = arg11, arg11 = alt0;\n-\t\t    }\n-\n-\t\t  if (exact_log2 (int11) > 0 && int01 % int11 == 0)\n-\t\t    {\n-\t\t      alt0 = fold (build2 (MULT_EXPR, type, arg00,\n-\t\t\t\t\t   build_int_cst (NULL_TREE,\n-\t\t\t\t\t\t\t  int01 / int11)));\n-\t\t      alt1 = arg10;\n-\t\t      same = arg11;\n-\t\t    }\n-\t\t}\n-\n-\t      if (same)\n-\t\treturn fold (build2 (MULT_EXPR, type,\n-\t\t\t\t     fold (build2 (PLUS_EXPR, type,\n-\t\t\t\t\t\t   fold_convert (type, alt0),\n-\t\t\t\t\t\t   fold_convert (type, alt1))),\n-\t\t\t\t     same));\n-\t    }\n-\n-\t  /* Try replacing &a[i1] + c * i2 with &a[i1 + i2], if c is step\n-\t     of the array.  Loop optimizer sometimes produce this type of\n-\t     expressions.  */\n-\t  if (TREE_CODE (arg0) == ADDR_EXPR\n-\t      && TREE_CODE (arg1) == MULT_EXPR)\n-\t    {\n-\t      tem = try_move_mult_to_index (PLUS_EXPR, arg0, arg1);\n-\t      if (tem)\n-\t\treturn fold_convert (type, fold (tem));\n-\t    }\n-\t  else if (TREE_CODE (arg1) == ADDR_EXPR\n-\t\t   && TREE_CODE (arg0) == MULT_EXPR)\n-\t    {\n-\t      tem = try_move_mult_to_index (PLUS_EXPR, arg1, arg0);\n-\t      if (tem)\n-\t\treturn fold_convert (type, fold (tem));\n-\t    }\n-\t}\n-      else\n-\t{\n-\t  /* See if ARG1 is zero and X + ARG1 reduces to X.  */\n-\t  if (fold_real_zero_addition_p (TREE_TYPE (arg0), arg1, 0))\n-\t    return non_lvalue (fold_convert (type, arg0));\n-\n-\t  /* Likewise if the operands are reversed.  */\n-\t  if (fold_real_zero_addition_p (TREE_TYPE (arg1), arg0, 0))\n-\t    return non_lvalue (fold_convert (type, arg1));\n-\n-\t  /* Convert X + -C into X - C.  */\n-\t  if (TREE_CODE (arg1) == REAL_CST\n-\t      && REAL_VALUE_NEGATIVE (TREE_REAL_CST (arg1)))\n-\t    {\n-\t      tem = fold_negate_const (arg1, type);\n-\t      if (!TREE_OVERFLOW (arg1) || !flag_trapping_math)\n-\t\treturn fold (build2 (MINUS_EXPR, type,\n-\t\t\t\t     fold_convert (type, arg0),\n-\t\t\t\t     fold_convert (type, tem)));\n-\t    }\n-\n-\t  /* Convert x+x into x*2.0.  */\n-\t  if (operand_equal_p (arg0, arg1, 0)\n-\t      && SCALAR_FLOAT_TYPE_P (type))\n-\t    return fold (build2 (MULT_EXPR, type, arg0,\n-\t\t\t\t build_real (type, dconst2)));\n-\n-\t  /* Convert x*c+x into x*(c+1).  */\n-\t  if (flag_unsafe_math_optimizations\n-\t      && TREE_CODE (arg0) == MULT_EXPR\n-\t      && TREE_CODE (TREE_OPERAND (arg0, 1)) == REAL_CST\n-\t      && ! TREE_CONSTANT_OVERFLOW (TREE_OPERAND (arg0, 1))\n-\t      && operand_equal_p (TREE_OPERAND (arg0, 0), arg1, 0))\n-\t    {\n-\t      REAL_VALUE_TYPE c;\n-\n-\t      c = TREE_REAL_CST (TREE_OPERAND (arg0, 1));\n-\t      real_arithmetic (&c, PLUS_EXPR, &c, &dconst1);\n-\t      return fold (build2 (MULT_EXPR, type, arg1,\n-\t\t\t\t   build_real (type, c)));\n-\t    }\n-\n-\t  /* Convert x+x*c into x*(c+1).  */\n-\t  if (flag_unsafe_math_optimizations\n-\t      && TREE_CODE (arg1) == MULT_EXPR\n-\t      && TREE_CODE (TREE_OPERAND (arg1, 1)) == REAL_CST\n-\t      && ! TREE_CONSTANT_OVERFLOW (TREE_OPERAND (arg1, 1))\n-\t      && operand_equal_p (TREE_OPERAND (arg1, 0), arg0, 0))\n-\t    {\n-\t      REAL_VALUE_TYPE c;\n-\n-\t      c = TREE_REAL_CST (TREE_OPERAND (arg1, 1));\n-\t      real_arithmetic (&c, PLUS_EXPR, &c, &dconst1);\n-\t      return fold (build2 (MULT_EXPR, type, arg0,\n-\t\t\t\t   build_real (type, c)));\n-\t    }\n-\n-\t  /* Convert x*c1+x*c2 into x*(c1+c2).  */\n-\t  if (flag_unsafe_math_optimizations\n-\t      && TREE_CODE (arg0) == MULT_EXPR\n-\t      && TREE_CODE (arg1) == MULT_EXPR\n-\t      && TREE_CODE (TREE_OPERAND (arg0, 1)) == REAL_CST\n-\t      && ! TREE_CONSTANT_OVERFLOW (TREE_OPERAND (arg0, 1))\n-\t      && TREE_CODE (TREE_OPERAND (arg1, 1)) == REAL_CST\n-\t      && ! TREE_CONSTANT_OVERFLOW (TREE_OPERAND (arg1, 1))\n-\t      && operand_equal_p (TREE_OPERAND (arg0, 0),\n-\t\t\t\t  TREE_OPERAND (arg1, 0), 0))\n-\t    {\n-\t      REAL_VALUE_TYPE c1, c2;\n-\n-\t      c1 = TREE_REAL_CST (TREE_OPERAND (arg0, 1));\n-\t      c2 = TREE_REAL_CST (TREE_OPERAND (arg1, 1));\n-\t      real_arithmetic (&c1, PLUS_EXPR, &c1, &c2);\n-\t      return fold (build2 (MULT_EXPR, type,\n-\t\t\t\t   TREE_OPERAND (arg0, 0),\n-\t\t\t\t   build_real (type, c1)));\n-\t    }\n-          /* Convert a + (b*c + d*e) into (a + b*c) + d*e.  */\n-          if (flag_unsafe_math_optimizations\n-              && TREE_CODE (arg1) == PLUS_EXPR\n-              && TREE_CODE (arg0) != MULT_EXPR)\n-            {\n-              tree tree10 = TREE_OPERAND (arg1, 0);\n-              tree tree11 = TREE_OPERAND (arg1, 1);\n-              if (TREE_CODE (tree11) == MULT_EXPR\n-\t\t  && TREE_CODE (tree10) == MULT_EXPR)\n-                {\n-                  tree tree0;\n-                  tree0 = fold (build2 (PLUS_EXPR, type, arg0, tree10));\n-                  return fold (build2 (PLUS_EXPR, type, tree0, tree11));\n-                }\n-            }\n-          /* Convert (b*c + d*e) + a into b*c + (d*e +a).  */\n-          if (flag_unsafe_math_optimizations\n-              && TREE_CODE (arg0) == PLUS_EXPR\n-              && TREE_CODE (arg1) != MULT_EXPR)\n-            {\n-              tree tree00 = TREE_OPERAND (arg0, 0);\n-              tree tree01 = TREE_OPERAND (arg0, 1);\n-              if (TREE_CODE (tree01) == MULT_EXPR\n-\t\t  && TREE_CODE (tree00) == MULT_EXPR)\n-                {\n-                  tree tree0;\n-                  tree0 = fold (build2 (PLUS_EXPR, type, tree01, arg1));\n-                  return fold (build2 (PLUS_EXPR, type, tree00, tree0));\n-                }\n-            }\n-\t}\n-\n-     bit_rotate:\n-      /* (A << C1) + (A >> C2) if A is unsigned and C1+C2 is the size of A\n-\t is a rotate of A by C1 bits.  */\n-      /* (A << B) + (A >> (Z - B)) if A is unsigned and Z is the size of A\n-\t is a rotate of A by B bits.  */\n-      {\n-\tenum tree_code code0, code1;\n-\tcode0 = TREE_CODE (arg0);\n-\tcode1 = TREE_CODE (arg1);\n-\tif (((code0 == RSHIFT_EXPR && code1 == LSHIFT_EXPR)\n-\t     || (code1 == RSHIFT_EXPR && code0 == LSHIFT_EXPR))\n-\t    && operand_equal_p (TREE_OPERAND (arg0, 0),\n-\t\t\t        TREE_OPERAND (arg1, 0), 0)\n-\t    && TYPE_UNSIGNED (TREE_TYPE (TREE_OPERAND (arg0, 0))))\n-\t  {\n-\t    tree tree01, tree11;\n-\t    enum tree_code code01, code11;\n-\n-\t    tree01 = TREE_OPERAND (arg0, 1);\n-\t    tree11 = TREE_OPERAND (arg1, 1);\n-\t    STRIP_NOPS (tree01);\n-\t    STRIP_NOPS (tree11);\n-\t    code01 = TREE_CODE (tree01);\n-\t    code11 = TREE_CODE (tree11);\n-\t    if (code01 == INTEGER_CST\n-\t\t&& code11 == INTEGER_CST\n-\t\t&& TREE_INT_CST_HIGH (tree01) == 0\n-\t\t&& TREE_INT_CST_HIGH (tree11) == 0\n-\t\t&& ((TREE_INT_CST_LOW (tree01) + TREE_INT_CST_LOW (tree11))\n-\t\t    == TYPE_PRECISION (TREE_TYPE (TREE_OPERAND (arg0, 0)))))\n-\t      return build2 (LROTATE_EXPR, type, TREE_OPERAND (arg0, 0),\n-\t\t\t     code0 == LSHIFT_EXPR ? tree01 : tree11);\n-\t    else if (code11 == MINUS_EXPR)\n-\t      {\n-\t\ttree tree110, tree111;\n-\t\ttree110 = TREE_OPERAND (tree11, 0);\n-\t\ttree111 = TREE_OPERAND (tree11, 1);\n-\t\tSTRIP_NOPS (tree110);\n-\t\tSTRIP_NOPS (tree111);\n-\t\tif (TREE_CODE (tree110) == INTEGER_CST\n-\t\t    && 0 == compare_tree_int (tree110,\n-\t\t\t\t\t      TYPE_PRECISION\n-\t\t\t\t\t      (TREE_TYPE (TREE_OPERAND\n-\t\t\t\t\t\t\t  (arg0, 0))))\n-\t\t    && operand_equal_p (tree01, tree111, 0))\n-\t\t  return build2 ((code0 == LSHIFT_EXPR\n-\t\t\t\t  ? LROTATE_EXPR\n-\t\t\t\t  : RROTATE_EXPR),\n-\t\t\t\t type, TREE_OPERAND (arg0, 0), tree01);\n-\t      }\n-\t    else if (code01 == MINUS_EXPR)\n-\t      {\n-\t\ttree tree010, tree011;\n-\t\ttree010 = TREE_OPERAND (tree01, 0);\n-\t\ttree011 = TREE_OPERAND (tree01, 1);\n-\t\tSTRIP_NOPS (tree010);\n-\t\tSTRIP_NOPS (tree011);\n-\t\tif (TREE_CODE (tree010) == INTEGER_CST\n-\t\t    && 0 == compare_tree_int (tree010,\n-\t\t\t\t\t      TYPE_PRECISION\n-\t\t\t\t\t      (TREE_TYPE (TREE_OPERAND\n-\t\t\t\t\t\t\t  (arg0, 0))))\n-\t\t    && operand_equal_p (tree11, tree011, 0))\n-\t\t  return build2 ((code0 != LSHIFT_EXPR\n-\t\t\t\t  ? LROTATE_EXPR\n-\t\t\t\t  : RROTATE_EXPR),\n-\t\t\t\t type, TREE_OPERAND (arg0, 0), tree11);\n-\t      }\n-\t  }\n-      }\n-\n-    associate:\n-      /* In most languages, can't associate operations on floats through\n-\t parentheses.  Rather than remember where the parentheses were, we\n-\t don't associate floats at all, unless the user has specified\n-\t -funsafe-math-optimizations.  */\n-\n-      if (! wins\n-\t  && (! FLOAT_TYPE_P (type) || flag_unsafe_math_optimizations))\n-\t{\n-\t  tree var0, con0, lit0, minus_lit0;\n-\t  tree var1, con1, lit1, minus_lit1;\n-\n-\t  /* Split both trees into variables, constants, and literals.  Then\n-\t     associate each group together, the constants with literals,\n-\t     then the result with variables.  This increases the chances of\n-\t     literals being recombined later and of generating relocatable\n-\t     expressions for the sum of a constant and literal.  */\n-\t  var0 = split_tree (arg0, code, &con0, &lit0, &minus_lit0, 0);\n-\t  var1 = split_tree (arg1, code, &con1, &lit1, &minus_lit1,\n-\t\t\t     code == MINUS_EXPR);\n-\n-\t  /* Only do something if we found more than two objects.  Otherwise,\n-\t     nothing has changed and we risk infinite recursion.  */\n-\t  if (2 < ((var0 != 0) + (var1 != 0)\n-\t\t   + (con0 != 0) + (con1 != 0)\n-\t\t   + (lit0 != 0) + (lit1 != 0)\n-\t\t   + (minus_lit0 != 0) + (minus_lit1 != 0)))\n-\t    {\n-\t      /* Recombine MINUS_EXPR operands by using PLUS_EXPR.  */\n-\t      if (code == MINUS_EXPR)\n-\t\tcode = PLUS_EXPR;\n-\n-\t      var0 = associate_trees (var0, var1, code, type);\n-\t      con0 = associate_trees (con0, con1, code, type);\n-\t      lit0 = associate_trees (lit0, lit1, code, type);\n-\t      minus_lit0 = associate_trees (minus_lit0, minus_lit1, code, type);\n-\n-\t      /* Preserve the MINUS_EXPR if the negative part of the literal is\n-\t\t greater than the positive part.  Otherwise, the multiplicative\n-\t\t folding code (i.e extract_muldiv) may be fooled in case\n-\t\t unsigned constants are subtracted, like in the following\n-\t\t example: ((X*2 + 4) - 8U)/2.  */\n-\t      if (minus_lit0 && lit0)\n-\t\t{\n-\t\t  if (TREE_CODE (lit0) == INTEGER_CST\n-\t\t      && TREE_CODE (minus_lit0) == INTEGER_CST\n-\t\t      && tree_int_cst_lt (lit0, minus_lit0))\n-\t\t    {\n-\t\t      minus_lit0 = associate_trees (minus_lit0, lit0,\n-\t\t\t\t\t\t    MINUS_EXPR, type);\n-\t\t      lit0 = 0;\n-\t\t    }\n-\t\t  else\n-\t\t    {\n-\t\t      lit0 = associate_trees (lit0, minus_lit0,\n-\t\t\t\t\t      MINUS_EXPR, type);\n-\t\t      minus_lit0 = 0;\n-\t\t    }\n-\t\t}\n-\t      if (minus_lit0)\n-\t\t{\n-\t\t  if (con0 == 0)\n-\t\t    return fold_convert (type,\n-\t\t\t\t\t associate_trees (var0, minus_lit0,\n-\t\t\t\t\t\t\t  MINUS_EXPR, type));\n-\t\t  else\n-\t\t    {\n-\t\t      con0 = associate_trees (con0, minus_lit0,\n-\t\t\t\t\t      MINUS_EXPR, type);\n-\t\t      return fold_convert (type,\n-\t\t\t\t\t   associate_trees (var0, con0,\n-\t\t\t\t\t\t\t    PLUS_EXPR, type));\n-\t\t    }\n-\t\t}\n-\n-\t      con0 = associate_trees (con0, lit0, code, type);\n-\t      return fold_convert (type, associate_trees (var0, con0,\n-\t\t\t\t\t\t\t  code, type));\n-\t    }\n-\t}\n-\n-    binary:\n-      if (wins)\n-\tt1 = const_binop (code, arg0, arg1, 0);\n-      if (t1 != NULL_TREE)\n-\t{\n-\t  /* The return value should always have\n-\t     the same type as the original expression.  */\n-\t  if (TREE_TYPE (t1) != type)\n-\t    t1 = fold_convert (type, t1);\n-\n-\t  return t1;\n-\t}\n-      return t;\n-\n-    case MINUS_EXPR:\n-      /* A - (-B) -> A + B */\n-      if (TREE_CODE (arg1) == NEGATE_EXPR)\n-\treturn fold (build2 (PLUS_EXPR, type, arg0, TREE_OPERAND (arg1, 0)));\n-      /* (-A) - B -> (-B) - A  where B is easily negated and we can swap.  */\n-      if (TREE_CODE (arg0) == NEGATE_EXPR\n-\t  && (FLOAT_TYPE_P (type)\n-\t      || (INTEGRAL_TYPE_P (type) && flag_wrapv && !flag_trapv))\n-\t  && negate_expr_p (arg1)\n-\t  && reorder_operands_p (arg0, arg1))\n-\treturn fold (build2 (MINUS_EXPR, type, negate_expr (arg1),\n-\t\t\t     TREE_OPERAND (arg0, 0)));\n-\n-      if (TREE_CODE (type) == COMPLEX_TYPE)\n-\t{\n-\t  tem = fold_complex_add (type, arg0, arg1, MINUS_EXPR);\n-\t  if (tem)\n-\t    return tem;\n-\t}\n-\n-      if (! FLOAT_TYPE_P (type))\n-\t{\n-\t  if (! wins && integer_zerop (arg0))\n-\t    return negate_expr (fold_convert (type, arg1));\n-\t  if (integer_zerop (arg1))\n-\t    return non_lvalue (fold_convert (type, arg0));\n-\n-\t  /* Fold A - (A & B) into ~B & A.  */\n-\t  if (!TREE_SIDE_EFFECTS (arg0)\n-\t      && TREE_CODE (arg1) == BIT_AND_EXPR)\n-\t    {\n-\t      if (operand_equal_p (arg0, TREE_OPERAND (arg1, 1), 0))\n-\t\treturn fold (build2 (BIT_AND_EXPR, type,\n-\t\t\t\t     fold (build1 (BIT_NOT_EXPR, type,\n-\t\t\t\t\t\t   TREE_OPERAND (arg1, 0))),\n-\t\t\t\t     arg0));\n-\t      if (operand_equal_p (arg0, TREE_OPERAND (arg1, 0), 0))\n-\t\treturn fold (build2 (BIT_AND_EXPR, type,\n-\t\t\t\t     fold (build1 (BIT_NOT_EXPR, type,\n-\t\t\t\t\t\t   TREE_OPERAND (arg1, 1))),\n-\t\t\t\t     arg0));\n-\t    }\n-\n-\t  /* Fold (A & ~B) - (A & B) into (A ^ B) - B, where B is\n-\t     any power of 2 minus 1.  */\n-\t  if (TREE_CODE (arg0) == BIT_AND_EXPR\n-\t      && TREE_CODE (arg1) == BIT_AND_EXPR\n-\t      && operand_equal_p (TREE_OPERAND (arg0, 0),\n-\t\t\t\t  TREE_OPERAND (arg1, 0), 0))\n-\t    {\n-\t      tree mask0 = TREE_OPERAND (arg0, 1);\n-\t      tree mask1 = TREE_OPERAND (arg1, 1);\n-\t      tree tem = fold (build1 (BIT_NOT_EXPR, type, mask0));\n-\n-\t      if (operand_equal_p (tem, mask1, 0))\n-\t\t{\n-\t\t  tem = fold (build2 (BIT_XOR_EXPR, type,\n-\t\t\t\t      TREE_OPERAND (arg0, 0), mask1));\n-\t\t  return fold (build2 (MINUS_EXPR, type, tem, mask1));\n-\t\t}\n-\t    }\n-\t}\n-\n-      /* See if ARG1 is zero and X - ARG1 reduces to X.  */\n-      else if (fold_real_zero_addition_p (TREE_TYPE (arg0), arg1, 1))\n-\treturn non_lvalue (fold_convert (type, arg0));\n-\n-      /* (ARG0 - ARG1) is the same as (-ARG1 + ARG0).  So check whether\n-\t ARG0 is zero and X + ARG0 reduces to X, since that would mean\n-\t (-ARG1 + ARG0) reduces to -ARG1.  */\n-      else if (!wins && fold_real_zero_addition_p (TREE_TYPE (arg1), arg0, 0))\n-\treturn negate_expr (fold_convert (type, arg1));\n-\n-      /* Fold &x - &x.  This can happen from &x.foo - &x.\n-\t This is unsafe for certain floats even in non-IEEE formats.\n-\t In IEEE, it is unsafe because it does wrong for NaNs.\n-\t Also note that operand_equal_p is always false if an operand\n-\t is volatile.  */\n-\n-      if ((! FLOAT_TYPE_P (type) || flag_unsafe_math_optimizations)\n-\t  && operand_equal_p (arg0, arg1, 0))\n-\treturn fold_convert (type, integer_zero_node);\n-\n-      /* A - B -> A + (-B) if B is easily negatable.  */\n-      if (!wins && negate_expr_p (arg1)\n-\t  && ((FLOAT_TYPE_P (type)\n-               /* Avoid this transformation if B is a positive REAL_CST.  */\n-\t       && (TREE_CODE (arg1) != REAL_CST\n-\t\t   ||  REAL_VALUE_NEGATIVE (TREE_REAL_CST (arg1))))\n-\t      || (INTEGRAL_TYPE_P (type) && flag_wrapv && !flag_trapv)))\n-\treturn fold (build2 (PLUS_EXPR, type, arg0, negate_expr (arg1)));\n-\n-      /* Try folding difference of addresses.  */\n-      {\n-\tHOST_WIDE_INT diff;\n-\n-\tif ((TREE_CODE (arg0) == ADDR_EXPR\n-\t     || TREE_CODE (arg1) == ADDR_EXPR)\n-\t    && ptr_difference_const (arg0, arg1, &diff))\n-\t  return build_int_cst_type (type, diff);\n-      }\n-\t  \n-      /* Try replacing &a[i1] - c * i2 with &a[i1 - i2], if c is step\n-\t of the array.  Loop optimizer sometimes produce this type of\n-\t expressions.  */\n-      if (TREE_CODE (arg0) == ADDR_EXPR\n-\t  && TREE_CODE (arg1) == MULT_EXPR)\n-\t{\n-\t  tem = try_move_mult_to_index (MINUS_EXPR, arg0, arg1);\n-\t  if (tem)\n-\t    return fold_convert (type, fold (tem));\n-\t}\n-\n-      if (TREE_CODE (arg0) == MULT_EXPR\n-\t  && TREE_CODE (arg1) == MULT_EXPR\n-\t  && (!FLOAT_TYPE_P (type) || flag_unsafe_math_optimizations))\n-\t{\n-          /* (A * C) - (B * C) -> (A-B) * C.  */\n-\t  if (operand_equal_p (TREE_OPERAND (arg0, 1),\n-\t\t\t       TREE_OPERAND (arg1, 1), 0))\n-\t    return fold (build2 (MULT_EXPR, type,\n-\t\t\t\t fold (build2 (MINUS_EXPR, type,\n-\t\t\t\t\t       TREE_OPERAND (arg0, 0),\n-\t\t\t\t\t       TREE_OPERAND (arg1, 0))),\n-\t\t\t\t TREE_OPERAND (arg0, 1)));\n-          /* (A * C1) - (A * C2) -> A * (C1-C2).  */\n-\t  if (operand_equal_p (TREE_OPERAND (arg0, 0),\n-\t\t\t       TREE_OPERAND (arg1, 0), 0))\n-\t    return fold (build2 (MULT_EXPR, type,\n-\t\t\t\t TREE_OPERAND (arg0, 0),\n-\t\t\t\t fold (build2 (MINUS_EXPR, type,\n-\t\t\t\t\t       TREE_OPERAND (arg0, 1),\n-\t\t\t\t\t       TREE_OPERAND (arg1, 1)))));\n-\t}\n-\n-      goto associate;\n-\n-    case MULT_EXPR:\n-      /* (-A) * (-B) -> A * B  */\n-      if (TREE_CODE (arg0) == NEGATE_EXPR && negate_expr_p (arg1))\n-\treturn fold (build2 (MULT_EXPR, type,\n-\t\t\t     TREE_OPERAND (arg0, 0),\n-\t\t\t     negate_expr (arg1)));\n-      if (TREE_CODE (arg1) == NEGATE_EXPR && negate_expr_p (arg0))\n-\treturn fold (build2 (MULT_EXPR, type,\n-\t\t\t     negate_expr (arg0),\n-\t\t\t     TREE_OPERAND (arg1, 0)));\n-\n-      if (TREE_CODE (type) == COMPLEX_TYPE)\n-\t{\n-\t  tem = fold_complex_mult (type, arg0, arg1);\n-\t  if (tem)\n-\t    return tem;\n-\t}\n-\n-      if (! FLOAT_TYPE_P (type))\n-\t{\n-\t  if (integer_zerop (arg1))\n-\t    return omit_one_operand (type, arg1, arg0);\n-\t  if (integer_onep (arg1))\n-\t    return non_lvalue (fold_convert (type, arg0));\n-\n-\t  /* (a * (1 << b)) is (a << b)  */\n-\t  if (TREE_CODE (arg1) == LSHIFT_EXPR\n-\t      && integer_onep (TREE_OPERAND (arg1, 0)))\n-\t    return fold (build2 (LSHIFT_EXPR, type, arg0,\n-\t\t\t\t TREE_OPERAND (arg1, 1)));\n-\t  if (TREE_CODE (arg0) == LSHIFT_EXPR\n-\t      && integer_onep (TREE_OPERAND (arg0, 0)))\n-\t    return fold (build2 (LSHIFT_EXPR, type, arg1,\n-\t\t\t\t TREE_OPERAND (arg0, 1)));\n-\n-\t  if (TREE_CODE (arg1) == INTEGER_CST\n-\t      && 0 != (tem = extract_muldiv (TREE_OPERAND (t, 0),\n-\t\t\t\t\t     fold_convert (type, arg1),\n-\t\t\t\t\t     code, NULL_TREE)))\n-\t    return fold_convert (type, tem);\n-\n-\t}\n-      else\n-\t{\n-\t  /* Maybe fold x * 0 to 0.  The expressions aren't the same\n-\t     when x is NaN, since x * 0 is also NaN.  Nor are they the\n-\t     same in modes with signed zeros, since multiplying a\n-\t     negative value by 0 gives -0, not +0.  */\n-\t  if (!HONOR_NANS (TYPE_MODE (TREE_TYPE (arg0)))\n-\t      && !HONOR_SIGNED_ZEROS (TYPE_MODE (TREE_TYPE (arg0)))\n-\t      && real_zerop (arg1))\n-\t    return omit_one_operand (type, arg1, arg0);\n-\t  /* In IEEE floating point, x*1 is not equivalent to x for snans.  */\n-\t  if (!HONOR_SNANS (TYPE_MODE (TREE_TYPE (arg0)))\n-\t      && real_onep (arg1))\n-\t    return non_lvalue (fold_convert (type, arg0));\n-\n-\t  /* Transform x * -1.0 into -x.  */\n-\t  if (!HONOR_SNANS (TYPE_MODE (TREE_TYPE (arg0)))\n-\t      && real_minus_onep (arg1))\n-\t    return fold_convert (type, negate_expr (arg0));\n-\n-\t  /* Convert (C1/X)*C2 into (C1*C2)/X.  */\n-\t  if (flag_unsafe_math_optimizations\n-\t      && TREE_CODE (arg0) == RDIV_EXPR\n-\t      && TREE_CODE (arg1) == REAL_CST\n-\t      && TREE_CODE (TREE_OPERAND (arg0, 0)) == REAL_CST)\n-\t    {\n-\t      tree tem = const_binop (MULT_EXPR, TREE_OPERAND (arg0, 0),\n-\t\t\t\t      arg1, 0);\n-\t      if (tem)\n-\t\treturn fold (build2 (RDIV_EXPR, type, tem,\n-\t\t\t\t     TREE_OPERAND (arg0, 1)));\n-\t    }\n-\n-          /* Strip sign operations from X in X*X, i.e. -Y*-Y -> Y*Y.  */\n-\t  if (operand_equal_p (arg0, arg1, 0))\n-\t    {\n-\t      tree tem = fold_strip_sign_ops (arg0);\n-\t      if (tem != NULL_TREE)\n-\t\t{\n-\t\t  tem = fold_convert (type, tem);\n-\t\t  return fold (build2 (MULT_EXPR, type, tem, tem));\n-\t\t}\n-\t    }\n-\n-\t  if (flag_unsafe_math_optimizations)\n-\t    {\n-\t      enum built_in_function fcode0 = builtin_mathfn_code (arg0);\n-\t      enum built_in_function fcode1 = builtin_mathfn_code (arg1);\n-\n-\t      /* Optimizations of root(...)*root(...).  */\n-\t      if (fcode0 == fcode1 && BUILTIN_ROOT_P (fcode0))\n-\t\t{\n-\t\t  tree rootfn, arg, arglist;\n-\t\t  tree arg00 = TREE_VALUE (TREE_OPERAND (arg0, 1));\n-\t\t  tree arg10 = TREE_VALUE (TREE_OPERAND (arg1, 1));\n-\n-\t\t  /* Optimize sqrt(x)*sqrt(x) as x.  */\n-\t\t  if (BUILTIN_SQRT_P (fcode0)\n-\t\t      && operand_equal_p (arg00, arg10, 0)\n-\t\t      && ! HONOR_SNANS (TYPE_MODE (type)))\n-\t\t    return arg00;\n-\n-\t          /* Optimize root(x)*root(y) as root(x*y).  */\n-\t\t  rootfn = TREE_OPERAND (TREE_OPERAND (arg0, 0), 0);\n-\t\t  arg = fold (build2 (MULT_EXPR, type, arg00, arg10));\n-\t\t  arglist = build_tree_list (NULL_TREE, arg);\n-\t\t  return build_function_call_expr (rootfn, arglist);\n-\t\t}\n-\n-\t      /* Optimize expN(x)*expN(y) as expN(x+y).  */\n-\t      if (fcode0 == fcode1 && BUILTIN_EXPONENT_P (fcode0))\n-\t\t{\n-\t\t  tree expfn = TREE_OPERAND (TREE_OPERAND (arg0, 0), 0);\n-\t\t  tree arg = build2 (PLUS_EXPR, type,\n-\t\t\t\t     TREE_VALUE (TREE_OPERAND (arg0, 1)),\n-\t\t\t\t     TREE_VALUE (TREE_OPERAND (arg1, 1)));\n-\t\t  tree arglist = build_tree_list (NULL_TREE, fold (arg));\n-\t\t  return build_function_call_expr (expfn, arglist);\n-\t\t}\n-\n-\t      /* Optimizations of pow(...)*pow(...).  */\n-\t      if ((fcode0 == BUILT_IN_POW && fcode1 == BUILT_IN_POW)\n-\t\t  || (fcode0 == BUILT_IN_POWF && fcode1 == BUILT_IN_POWF)\n-\t\t  || (fcode0 == BUILT_IN_POWL && fcode1 == BUILT_IN_POWL))\n-\t\t{\n-\t\t  tree arg00 = TREE_VALUE (TREE_OPERAND (arg0, 1));\n-\t\t  tree arg01 = TREE_VALUE (TREE_CHAIN (TREE_OPERAND (arg0,\n-\t\t\t\t\t\t\t\t     1)));\n-\t\t  tree arg10 = TREE_VALUE (TREE_OPERAND (arg1, 1));\n-\t\t  tree arg11 = TREE_VALUE (TREE_CHAIN (TREE_OPERAND (arg1,\n-\t\t\t\t\t\t\t\t     1)));\n-\n-\t\t  /* Optimize pow(x,y)*pow(z,y) as pow(x*z,y).  */\n-\t\t  if (operand_equal_p (arg01, arg11, 0))\n-\t\t    {\n-\t\t      tree powfn = TREE_OPERAND (TREE_OPERAND (arg0, 0), 0);\n-\t\t      tree arg = build2 (MULT_EXPR, type, arg00, arg10);\n-\t\t      tree arglist = tree_cons (NULL_TREE, fold (arg),\n-\t\t\t\t\t\tbuild_tree_list (NULL_TREE,\n-\t\t\t\t\t\t\t\t arg01));\n-\t\t      return build_function_call_expr (powfn, arglist);\n-\t\t    }\n-\n-\t\t  /* Optimize pow(x,y)*pow(x,z) as pow(x,y+z).  */\n-\t\t  if (operand_equal_p (arg00, arg10, 0))\n-\t\t    {\n-\t\t      tree powfn = TREE_OPERAND (TREE_OPERAND (arg0, 0), 0);\n-\t\t      tree arg = fold (build2 (PLUS_EXPR, type, arg01, arg11));\n-\t\t      tree arglist = tree_cons (NULL_TREE, arg00,\n-\t\t\t\t\t\tbuild_tree_list (NULL_TREE,\n-\t\t\t\t\t\t\t\t arg));\n-\t\t      return build_function_call_expr (powfn, arglist);\n-\t\t    }\n-\t\t}\n-\n-\t      /* Optimize tan(x)*cos(x) as sin(x).  */\n-\t      if (((fcode0 == BUILT_IN_TAN && fcode1 == BUILT_IN_COS)\n-\t\t   || (fcode0 == BUILT_IN_TANF && fcode1 == BUILT_IN_COSF)\n-\t\t   || (fcode0 == BUILT_IN_TANL && fcode1 == BUILT_IN_COSL)\n-\t\t   || (fcode0 == BUILT_IN_COS && fcode1 == BUILT_IN_TAN)\n-\t\t   || (fcode0 == BUILT_IN_COSF && fcode1 == BUILT_IN_TANF)\n-\t\t   || (fcode0 == BUILT_IN_COSL && fcode1 == BUILT_IN_TANL))\n-\t\t  && operand_equal_p (TREE_VALUE (TREE_OPERAND (arg0, 1)),\n-\t\t\t\t      TREE_VALUE (TREE_OPERAND (arg1, 1)), 0))\n-\t\t{\n-\t\t  tree sinfn = mathfn_built_in (type, BUILT_IN_SIN);\n-\n-\t\t  if (sinfn != NULL_TREE)\n-\t\t    return build_function_call_expr (sinfn,\n-\t\t\t\t\t\t     TREE_OPERAND (arg0, 1));\n-\t\t}\n-\n-\t      /* Optimize x*pow(x,c) as pow(x,c+1).  */\n-\t      if (fcode1 == BUILT_IN_POW\n-\t\t  || fcode1 == BUILT_IN_POWF\n-\t\t  || fcode1 == BUILT_IN_POWL)\n-\t\t{\n-\t\t  tree arg10 = TREE_VALUE (TREE_OPERAND (arg1, 1));\n-\t\t  tree arg11 = TREE_VALUE (TREE_CHAIN (TREE_OPERAND (arg1,\n-\t\t\t\t\t\t\t\t     1)));\n-\t\t  if (TREE_CODE (arg11) == REAL_CST\n-\t\t      && ! TREE_CONSTANT_OVERFLOW (arg11)\n-\t\t      && operand_equal_p (arg0, arg10, 0))\n-\t\t    {\n-\t\t      tree powfn = TREE_OPERAND (TREE_OPERAND (arg1, 0), 0);\n-\t\t      REAL_VALUE_TYPE c;\n-\t\t      tree arg, arglist;\n-\n-\t\t      c = TREE_REAL_CST (arg11);\n-\t\t      real_arithmetic (&c, PLUS_EXPR, &c, &dconst1);\n-\t\t      arg = build_real (type, c);\n-\t\t      arglist = build_tree_list (NULL_TREE, arg);\n-\t\t      arglist = tree_cons (NULL_TREE, arg0, arglist);\n-\t\t      return build_function_call_expr (powfn, arglist);\n-\t\t    }\n-\t\t}\n-\n-\t      /* Optimize pow(x,c)*x as pow(x,c+1).  */\n-\t      if (fcode0 == BUILT_IN_POW\n-\t\t  || fcode0 == BUILT_IN_POWF\n-\t\t  || fcode0 == BUILT_IN_POWL)\n-\t\t{\n-\t\t  tree arg00 = TREE_VALUE (TREE_OPERAND (arg0, 1));\n-\t\t  tree arg01 = TREE_VALUE (TREE_CHAIN (TREE_OPERAND (arg0,\n-\t\t\t\t\t\t\t\t     1)));\n-\t\t  if (TREE_CODE (arg01) == REAL_CST\n-\t\t      && ! TREE_CONSTANT_OVERFLOW (arg01)\n-\t\t      && operand_equal_p (arg1, arg00, 0))\n-\t\t    {\n-\t\t      tree powfn = TREE_OPERAND (TREE_OPERAND (arg0, 0), 0);\n-\t\t      REAL_VALUE_TYPE c;\n-\t\t      tree arg, arglist;\n-\n-\t\t      c = TREE_REAL_CST (arg01);\n-\t\t      real_arithmetic (&c, PLUS_EXPR, &c, &dconst1);\n-\t\t      arg = build_real (type, c);\n-\t\t      arglist = build_tree_list (NULL_TREE, arg);\n-\t\t      arglist = tree_cons (NULL_TREE, arg1, arglist);\n-\t\t      return build_function_call_expr (powfn, arglist);\n-\t\t    }\n-\t\t}\n-\n-\t      /* Optimize x*x as pow(x,2.0), which is expanded as x*x.  */\n-\t      if (! optimize_size\n-\t\t  && operand_equal_p (arg0, arg1, 0))\n-\t\t{\n-\t\t  tree powfn = mathfn_built_in (type, BUILT_IN_POW);\n-\n-\t\t  if (powfn)\n-\t\t    {\n-\t\t      tree arg = build_real (type, dconst2);\n-\t\t      tree arglist = build_tree_list (NULL_TREE, arg);\n-\t\t      arglist = tree_cons (NULL_TREE, arg0, arglist);\n-\t\t      return build_function_call_expr (powfn, arglist);\n-\t\t    }\n-\t\t}\n-\t    }\n-\t}\n-      goto associate;\n-\n-    case BIT_IOR_EXPR:\n-    bit_ior:\n-      if (integer_all_onesp (arg1))\n-\treturn omit_one_operand (type, arg1, arg0);\n-      if (integer_zerop (arg1))\n-\treturn non_lvalue (fold_convert (type, arg0));\n-      if (operand_equal_p (arg0, arg1, 0))\n-\treturn non_lvalue (fold_convert (type, arg0));\n-\n-      /* ~X | X is -1.  */\n-      if (TREE_CODE (arg0) == BIT_NOT_EXPR\n-\t  && operand_equal_p (TREE_OPERAND (arg0, 0), arg1, 0))\n-\t{\n-\t  t1 = build_int_cst (type, -1);\n-\t  t1 = force_fit_type (t1, 0, false, false);\n-\t  return omit_one_operand (type, t1, arg1);\n-\t}\n-\n-      /* X | ~X is -1.  */\n-      if (TREE_CODE (arg1) == BIT_NOT_EXPR\n-\t  && operand_equal_p (arg0, TREE_OPERAND (arg1, 0), 0))\n-\t{\n-\t  t1 = build_int_cst (type, -1);\n-\t  t1 = force_fit_type (t1, 0, false, false);\n-\t  return omit_one_operand (type, t1, arg0);\n-\t}\n-\n-      t1 = distribute_bit_expr (code, type, arg0, arg1);\n-      if (t1 != NULL_TREE)\n-\treturn t1;\n-\n-      /* Convert (or (not arg0) (not arg1)) to (not (and (arg0) (arg1))).\n-\n-\t This results in more efficient code for machines without a NAND\n-\t instruction.  Combine will canonicalize to the first form\n-\t which will allow use of NAND instructions provided by the\n-\t backend if they exist.  */\n-      if (TREE_CODE (arg0) == BIT_NOT_EXPR\n-\t  && TREE_CODE (arg1) == BIT_NOT_EXPR)\n-\t{\n-\t  return fold (build1 (BIT_NOT_EXPR, type,\n-\t\t\t       build2 (BIT_AND_EXPR, type,\n-\t\t\t\t       TREE_OPERAND (arg0, 0),\n-\t\t\t\t       TREE_OPERAND (arg1, 0))));\n-\t}\n-\n-      /* See if this can be simplified into a rotate first.  If that\n-\t is unsuccessful continue in the association code.  */\n-      goto bit_rotate;\n-\n-    case BIT_XOR_EXPR:\n-      if (integer_zerop (arg1))\n-\treturn non_lvalue (fold_convert (type, arg0));\n-      if (integer_all_onesp (arg1))\n-\treturn fold (build1 (BIT_NOT_EXPR, type, arg0));\n-      if (operand_equal_p (arg0, arg1, 0))\n-\treturn omit_one_operand (type, integer_zero_node, arg0);\n-\n-      /* ~X ^ X is -1.  */\n-      if (TREE_CODE (arg0) == BIT_NOT_EXPR\n-\t  && operand_equal_p (TREE_OPERAND (arg0, 0), arg1, 0))\n-\t{\n-\t  t1 = build_int_cst (type, -1);\n-\t  t1 = force_fit_type (t1, 0, false, false);\n-\t  return omit_one_operand (type, t1, arg1);\n-\t}\n-\n-      /* X ^ ~X is -1.  */\n-      if (TREE_CODE (arg1) == BIT_NOT_EXPR\n-\t  && operand_equal_p (arg0, TREE_OPERAND (arg1, 0), 0))\n-\t{\n-\t  t1 = build_int_cst (type, -1);\n-\t  t1 = force_fit_type (t1, 0, false, false);\n-\t  return omit_one_operand (type, t1, arg0);\n-\t}\n-\n-      /* If we are XORing two BIT_AND_EXPR's, both of which are and'ing\n-         with a constant, and the two constants have no bits in common,\n-\t we should treat this as a BIT_IOR_EXPR since this may produce more\n-\t simplifications.  */\n-      if (TREE_CODE (arg0) == BIT_AND_EXPR\n-\t  && TREE_CODE (arg1) == BIT_AND_EXPR\n-\t  && TREE_CODE (TREE_OPERAND (arg0, 1)) == INTEGER_CST\n-\t  && TREE_CODE (TREE_OPERAND (arg1, 1)) == INTEGER_CST\n-\t  && integer_zerop (const_binop (BIT_AND_EXPR,\n-\t\t\t\t\t TREE_OPERAND (arg0, 1),\n-\t\t\t\t\t TREE_OPERAND (arg1, 1), 0)))\n-\t{\n-\t  code = BIT_IOR_EXPR;\n-\t  goto bit_ior;\n-\t}\n-\n-      /* See if this can be simplified into a rotate first.  If that\n-\t is unsuccessful continue in the association code.  */\n-      goto bit_rotate;\n-\n-    case BIT_AND_EXPR:\n-      if (integer_all_onesp (arg1))\n-\treturn non_lvalue (fold_convert (type, arg0));\n-      if (integer_zerop (arg1))\n-\treturn omit_one_operand (type, arg1, arg0);\n-      if (operand_equal_p (arg0, arg1, 0))\n-\treturn non_lvalue (fold_convert (type, arg0));\n-\n-      /* ~X & X is always zero.  */\n-      if (TREE_CODE (arg0) == BIT_NOT_EXPR\n-\t  && operand_equal_p (TREE_OPERAND (arg0, 0), arg1, 0))\n-\treturn omit_one_operand (type, integer_zero_node, arg1);\n-\n-      /* X & ~X is always zero.  */\n-      if (TREE_CODE (arg1) == BIT_NOT_EXPR\n-\t  && operand_equal_p (arg0, TREE_OPERAND (arg1, 0), 0))\n-\treturn omit_one_operand (type, integer_zero_node, arg0);\n-\n-      t1 = distribute_bit_expr (code, type, arg0, arg1);\n-      if (t1 != NULL_TREE)\n-\treturn t1;\n-      /* Simplify ((int)c & 0377) into (int)c, if c is unsigned char.  */\n-      if (TREE_CODE (arg1) == INTEGER_CST && TREE_CODE (arg0) == NOP_EXPR\n-\t  && TYPE_UNSIGNED (TREE_TYPE (TREE_OPERAND (arg0, 0))))\n-\t{\n-\t  unsigned int prec\n-\t    = TYPE_PRECISION (TREE_TYPE (TREE_OPERAND (arg0, 0)));\n-\n-\t  if (prec < BITS_PER_WORD && prec < HOST_BITS_PER_WIDE_INT\n-\t      && (~TREE_INT_CST_LOW (arg1)\n-\t\t  & (((HOST_WIDE_INT) 1 << prec) - 1)) == 0)\n-\t    return fold_convert (type, TREE_OPERAND (arg0, 0));\n-\t}\n-\n-      /* Convert (and (not arg0) (not arg1)) to (not (or (arg0) (arg1))).\n-\n-\t This results in more efficient code for machines without a NOR\n-\t instruction.  Combine will canonicalize to the first form\n-\t which will allow use of NOR instructions provided by the\n-\t backend if they exist.  */\n-      if (TREE_CODE (arg0) == BIT_NOT_EXPR\n-\t  && TREE_CODE (arg1) == BIT_NOT_EXPR)\n-\t{\n-\t  return fold (build1 (BIT_NOT_EXPR, type,\n-\t\t\t       build2 (BIT_IOR_EXPR, type,\n-\t\t\t\t       TREE_OPERAND (arg0, 0),\n-\t\t\t\t       TREE_OPERAND (arg1, 0))));\n-\t}\n-\n-      goto associate;\n-\n-    case RDIV_EXPR:\n-      /* Don't touch a floating-point divide by zero unless the mode\n-\t of the constant can represent infinity.  */\n-      if (TREE_CODE (arg1) == REAL_CST\n-\t  && !MODE_HAS_INFINITIES (TYPE_MODE (TREE_TYPE (arg1)))\n-\t  && real_zerop (arg1))\n-\treturn t;\n-\n-      /* (-A) / (-B) -> A / B  */\n-      if (TREE_CODE (arg0) == NEGATE_EXPR && negate_expr_p (arg1))\n-\treturn fold (build2 (RDIV_EXPR, type,\n-\t\t\t     TREE_OPERAND (arg0, 0),\n-\t\t\t     negate_expr (arg1)));\n-      if (TREE_CODE (arg1) == NEGATE_EXPR && negate_expr_p (arg0))\n-\treturn fold (build2 (RDIV_EXPR, type,\n-\t\t\t     negate_expr (arg0),\n-\t\t\t     TREE_OPERAND (arg1, 0)));\n-\n-      /* In IEEE floating point, x/1 is not equivalent to x for snans.  */\n-      if (!HONOR_SNANS (TYPE_MODE (TREE_TYPE (arg0)))\n-\t  && real_onep (arg1))\n-\treturn non_lvalue (fold_convert (type, arg0));\n-\n-      /* In IEEE floating point, x/-1 is not equivalent to -x for snans.  */\n-      if (!HONOR_SNANS (TYPE_MODE (TREE_TYPE (arg0)))\n-\t  && real_minus_onep (arg1))\n-\treturn non_lvalue (fold_convert (type, negate_expr (arg0)));\n-\n-      /* If ARG1 is a constant, we can convert this to a multiply by the\n-\t reciprocal.  This does not have the same rounding properties,\n-\t so only do this if -funsafe-math-optimizations.  We can actually\n-\t always safely do it if ARG1 is a power of two, but it's hard to\n-\t tell if it is or not in a portable manner.  */\n-      if (TREE_CODE (arg1) == REAL_CST)\n-\t{\n-\t  if (flag_unsafe_math_optimizations\n-\t      && 0 != (tem = const_binop (code, build_real (type, dconst1),\n-\t\t\t\t\t  arg1, 0)))\n-\t    return fold (build2 (MULT_EXPR, type, arg0, tem));\n-\t  /* Find the reciprocal if optimizing and the result is exact.  */\n-\t  if (optimize)\n-\t    {\n-\t      REAL_VALUE_TYPE r;\n-\t      r = TREE_REAL_CST (arg1);\n-\t      if (exact_real_inverse (TYPE_MODE(TREE_TYPE(arg0)), &r))\n-\t\t{\n-\t\t  tem = build_real (type, r);\n-\t\t  return fold (build2 (MULT_EXPR, type, arg0, tem));\n-\t\t}\n-\t    }\n-\t}\n-      /* Convert A/B/C to A/(B*C).  */\n-      if (flag_unsafe_math_optimizations\n-\t  && TREE_CODE (arg0) == RDIV_EXPR)\n-\treturn fold (build2 (RDIV_EXPR, type, TREE_OPERAND (arg0, 0),\n-\t\t\t     fold (build2 (MULT_EXPR, type,\n-\t\t\t\t\t   TREE_OPERAND (arg0, 1), arg1))));\n-\n-      /* Convert A/(B/C) to (A/B)*C.  */\n-      if (flag_unsafe_math_optimizations\n-\t  && TREE_CODE (arg1) == RDIV_EXPR)\n-\treturn fold (build2 (MULT_EXPR, type,\n-\t\t\t     fold (build2 (RDIV_EXPR, type, arg0,\n-\t\t\t\t\t   TREE_OPERAND (arg1, 0))),\n-\t\t\t     TREE_OPERAND (arg1, 1)));\n-\n-      /* Convert C1/(X*C2) into (C1/C2)/X.  */\n-      if (flag_unsafe_math_optimizations\n-\t  && TREE_CODE (arg1) == MULT_EXPR\n-\t  && TREE_CODE (arg0) == REAL_CST\n-\t  && TREE_CODE (TREE_OPERAND (arg1, 1)) == REAL_CST)\n-\t{\n-\t  tree tem = const_binop (RDIV_EXPR, arg0,\n-\t\t\t\t  TREE_OPERAND (arg1, 1), 0);\n-\t  if (tem)\n-\t    return fold (build2 (RDIV_EXPR, type, tem,\n-\t\t\t\t TREE_OPERAND (arg1, 0)));\n-\t}\n-\n-      if (TREE_CODE (type) == COMPLEX_TYPE)\n-\t{\n-\t  tem = fold_complex_div (type, arg0, arg1, code);\n-\t  if (tem)\n-\t    return tem;\n-\t}\n-\n-      if (flag_unsafe_math_optimizations)\n-\t{\n-\t  enum built_in_function fcode = builtin_mathfn_code (arg1);\n-\t  /* Optimize x/expN(y) into x*expN(-y).  */\n-\t  if (BUILTIN_EXPONENT_P (fcode))\n-\t    {\n-\t      tree expfn = TREE_OPERAND (TREE_OPERAND (arg1, 0), 0);\n-\t      tree arg = negate_expr (TREE_VALUE (TREE_OPERAND (arg1, 1)));\n-\t      tree arglist = build_tree_list (NULL_TREE,\n-\t\t\t\t\t      fold_convert (type, arg));\n-\t      arg1 = build_function_call_expr (expfn, arglist);\n-\t      return fold (build2 (MULT_EXPR, type, arg0, arg1));\n-\t    }\n-\n-\t  /* Optimize x/pow(y,z) into x*pow(y,-z).  */\n-\t  if (fcode == BUILT_IN_POW\n-\t      || fcode == BUILT_IN_POWF\n-\t      || fcode == BUILT_IN_POWL)\n-\t    {\n-\t      tree powfn = TREE_OPERAND (TREE_OPERAND (arg1, 0), 0);\n-\t      tree arg10 = TREE_VALUE (TREE_OPERAND (arg1, 1));\n-\t      tree arg11 = TREE_VALUE (TREE_CHAIN (TREE_OPERAND (arg1, 1)));\n-\t      tree neg11 = fold_convert (type, negate_expr (arg11));\n-\t      tree arglist = tree_cons(NULL_TREE, arg10,\n-\t\t\t\t       build_tree_list (NULL_TREE, neg11));\n-\t      arg1 = build_function_call_expr (powfn, arglist);\n-\t      return fold (build2 (MULT_EXPR, type, arg0, arg1));\n-\t    }\n-\t}\n-\n-      if (flag_unsafe_math_optimizations)\n-\t{\n-\t  enum built_in_function fcode0 = builtin_mathfn_code (arg0);\n-\t  enum built_in_function fcode1 = builtin_mathfn_code (arg1);\n-\n-\t  /* Optimize sin(x)/cos(x) as tan(x).  */\n-\t  if (((fcode0 == BUILT_IN_SIN && fcode1 == BUILT_IN_COS)\n-\t       || (fcode0 == BUILT_IN_SINF && fcode1 == BUILT_IN_COSF)\n-\t       || (fcode0 == BUILT_IN_SINL && fcode1 == BUILT_IN_COSL))\n-\t      && operand_equal_p (TREE_VALUE (TREE_OPERAND (arg0, 1)),\n-\t\t\t\t  TREE_VALUE (TREE_OPERAND (arg1, 1)), 0))\n-\t    {\n-\t      tree tanfn = mathfn_built_in (type, BUILT_IN_TAN);\n-\n-\t      if (tanfn != NULL_TREE)\n-\t\treturn build_function_call_expr (tanfn,\n-\t\t\t\t\t\t TREE_OPERAND (arg0, 1));\n-\t    }\n-\n-\t  /* Optimize cos(x)/sin(x) as 1.0/tan(x).  */\n-\t  if (((fcode0 == BUILT_IN_COS && fcode1 == BUILT_IN_SIN)\n-\t       || (fcode0 == BUILT_IN_COSF && fcode1 == BUILT_IN_SINF)\n-\t       || (fcode0 == BUILT_IN_COSL && fcode1 == BUILT_IN_SINL))\n-\t      && operand_equal_p (TREE_VALUE (TREE_OPERAND (arg0, 1)),\n-\t\t\t\t  TREE_VALUE (TREE_OPERAND (arg1, 1)), 0))\n-\t    {\n-\t      tree tanfn = mathfn_built_in (type, BUILT_IN_TAN);\n-\n-\t      if (tanfn != NULL_TREE)\n-\t\t{\n-\t\t  tree tmp = TREE_OPERAND (arg0, 1);\n-\t\t  tmp = build_function_call_expr (tanfn, tmp);\n-\t\t  return fold (build2 (RDIV_EXPR, type,\n-\t\t\t\t       build_real (type, dconst1), tmp));\n-\t\t}\n-\t    }\n-\n-\t  /* Optimize pow(x,c)/x as pow(x,c-1).  */\n-\t  if (fcode0 == BUILT_IN_POW\n-\t      || fcode0 == BUILT_IN_POWF\n-\t      || fcode0 == BUILT_IN_POWL)\n-\t    {\n-\t      tree arg00 = TREE_VALUE (TREE_OPERAND (arg0, 1));\n-\t      tree arg01 = TREE_VALUE (TREE_CHAIN (TREE_OPERAND (arg0, 1)));\n-\t      if (TREE_CODE (arg01) == REAL_CST\n-\t\t  && ! TREE_CONSTANT_OVERFLOW (arg01)\n-\t\t  && operand_equal_p (arg1, arg00, 0))\n-\t\t{\n-\t\t  tree powfn = TREE_OPERAND (TREE_OPERAND (arg0, 0), 0);\n-\t\t  REAL_VALUE_TYPE c;\n-\t\t  tree arg, arglist;\n-\n-\t\t  c = TREE_REAL_CST (arg01);\n-\t\t  real_arithmetic (&c, MINUS_EXPR, &c, &dconst1);\n-\t\t  arg = build_real (type, c);\n-\t\t  arglist = build_tree_list (NULL_TREE, arg);\n-\t\t  arglist = tree_cons (NULL_TREE, arg1, arglist);\n-\t\t  return build_function_call_expr (powfn, arglist);\n-\t\t}\n-\t    }\n-\t}\n-      goto binary;\n-\n-    case TRUNC_DIV_EXPR:\n-    case ROUND_DIV_EXPR:\n-    case FLOOR_DIV_EXPR:\n-    case CEIL_DIV_EXPR:\n-    case EXACT_DIV_EXPR:\n-      if (integer_onep (arg1))\n-\treturn non_lvalue (fold_convert (type, arg0));\n-      if (integer_zerop (arg1))\n-\treturn t;\n-      /* X / -1 is -X.  */\n-      if (!TYPE_UNSIGNED (type)\n-\t  && TREE_CODE (arg1) == INTEGER_CST\n-\t  && TREE_INT_CST_LOW (arg1) == (unsigned HOST_WIDE_INT) -1\n-\t  && TREE_INT_CST_HIGH (arg1) == -1)\n-\treturn fold_convert (type, negate_expr (arg0));\n-\n-      /* If arg0 is a multiple of arg1, then rewrite to the fastest div\n-\t operation, EXACT_DIV_EXPR.\n-\n-\t Note that only CEIL_DIV_EXPR and FLOOR_DIV_EXPR are rewritten now.\n-\t At one time others generated faster code, it's not clear if they do\n-\t after the last round to changes to the DIV code in expmed.c.  */\n-      if ((code == CEIL_DIV_EXPR || code == FLOOR_DIV_EXPR)\n-\t  && multiple_of_p (type, arg0, arg1))\n-\treturn fold (build2 (EXACT_DIV_EXPR, type, arg0, arg1));\n-\n-      if (TREE_CODE (arg1) == INTEGER_CST\n-\t  && 0 != (tem = extract_muldiv (TREE_OPERAND (t, 0), arg1,\n-\t\t\t\t\t code, NULL_TREE)))\n-\treturn fold_convert (type, tem);\n-\n-      if (TREE_CODE (type) == COMPLEX_TYPE)\n-\t{\n-\t  tem = fold_complex_div (type, arg0, arg1, code);\n-\t  if (tem)\n-\t    return tem;\n-\t}\n-      goto binary;\n-\n-    case CEIL_MOD_EXPR:\n-    case FLOOR_MOD_EXPR:\n-    case ROUND_MOD_EXPR:\n-    case TRUNC_MOD_EXPR:\n-      /* X % 1 is always zero, but be sure to preserve any side\n-\t effects in X.  */\n-      if (integer_onep (arg1))\n-\treturn omit_one_operand (type, integer_zero_node, arg0);\n-\n-      /* X % 0, return X % 0 unchanged so that we can get the\n-\t proper warnings and errors.  */\n-      if (integer_zerop (arg1))\n-\treturn t;\n-\n-      /* 0 % X is always zero, but be sure to preserve any side\n-\t effects in X.  Place this after checking for X == 0.  */\n-      if (integer_zerop (arg0))\n-\treturn omit_one_operand (type, integer_zero_node, arg1);\n-\n-      /* X % -1 is zero.  */\n-      if (!TYPE_UNSIGNED (type)\n-\t  && TREE_CODE (arg1) == INTEGER_CST\n-\t  && TREE_INT_CST_LOW (arg1) == (unsigned HOST_WIDE_INT) -1\n-\t  && TREE_INT_CST_HIGH (arg1) == -1)\n-\treturn omit_one_operand (type, integer_zero_node, arg0);\n-\n-      /* Optimize unsigned TRUNC_MOD_EXPR by a power of two into a\n-\t BIT_AND_EXPR, i.e. \"X % C\" into \"X & C2\".  */\n-      if (code == TRUNC_MOD_EXPR\n-\t  && TYPE_UNSIGNED (type)\n-\t  && integer_pow2p (arg1))\n-\t{\n-\t  unsigned HOST_WIDE_INT high, low;\n-\t  tree mask;\n-\t  int l;\n-\n-\t  l = tree_log2 (arg1);\n-\t  if (l >= HOST_BITS_PER_WIDE_INT)\n-\t    {\n-\t      high = ((unsigned HOST_WIDE_INT) 1\n-\t\t      << (l - HOST_BITS_PER_WIDE_INT)) - 1;\n-\t      low = -1;\n-\t    }\n-\t  else\n-\t    {\n-\t      high = 0;\n-\t      low = ((unsigned HOST_WIDE_INT) 1 << l) - 1;\n-\t    }\n-\n-\t  mask = build_int_cst_wide (type, low, high);\n-\t  return fold (build2 (BIT_AND_EXPR, type,\n-\t\t\t       fold_convert (type, arg0), mask));\n-\t}\n-\n-      /* X % -C is the same as X % C.  */\n-      if (code == TRUNC_MOD_EXPR\n-\t  && !TYPE_UNSIGNED (type)\n-\t  && TREE_CODE (arg1) == INTEGER_CST\n-\t  && TREE_INT_CST_HIGH (arg1) < 0\n-\t  && !flag_trapv\n-\t  /* Avoid this transformation if C is INT_MIN, i.e. C == -C.  */\n-\t  && !sign_bit_p (arg1, arg1))\n-\treturn fold (build2 (code, type, fold_convert (type, arg0),\n-\t\t\t     fold_convert (type, negate_expr (arg1))));\n-\n-      /* X % -Y is the same as X % Y.  */\n-      if (code == TRUNC_MOD_EXPR\n-\t  && !TYPE_UNSIGNED (type)\n-\t  && TREE_CODE (arg1) == NEGATE_EXPR\n-\t  && !flag_trapv)\n-\treturn fold (build2 (code, type, fold_convert (type, arg0),\n-\t\t\t     fold_convert (type, TREE_OPERAND (arg1, 0))));\n-\n-      if (TREE_CODE (arg1) == INTEGER_CST\n-\t  && 0 != (tem = extract_muldiv (TREE_OPERAND (t, 0), arg1,\n-\t\t\t\t\t code, NULL_TREE)))\n-\treturn fold_convert (type, tem);\n-\n-      goto binary;\n-\n-    case LROTATE_EXPR:\n-    case RROTATE_EXPR:\n-      if (integer_all_onesp (arg0))\n-\treturn omit_one_operand (type, arg0, arg1);\n-      goto shift;\n-\n-    case RSHIFT_EXPR:\n-      /* Optimize -1 >> x for arithmetic right shifts.  */\n-      if (integer_all_onesp (arg0) && !TYPE_UNSIGNED (type))\n-\treturn omit_one_operand (type, arg0, arg1);\n-      /* ... fall through ...  */\n-\n-    case LSHIFT_EXPR:\n-    shift:\n-      if (integer_zerop (arg1))\n-\treturn non_lvalue (fold_convert (type, arg0));\n-      if (integer_zerop (arg0))\n-\treturn omit_one_operand (type, arg0, arg1);\n-\n-      /* Since negative shift count is not well-defined,\n-\t don't try to compute it in the compiler.  */\n-      if (TREE_CODE (arg1) == INTEGER_CST && tree_int_cst_sgn (arg1) < 0)\n-\treturn t;\n-      /* Rewrite an LROTATE_EXPR by a constant into an\n-\t RROTATE_EXPR by a new constant.  */\n-      if (code == LROTATE_EXPR && TREE_CODE (arg1) == INTEGER_CST)\n-\t{\n-\t  tree tem = build_int_cst (NULL_TREE,\n-\t\t\t\t    GET_MODE_BITSIZE (TYPE_MODE (type)));\n-\t  tem = fold_convert (TREE_TYPE (arg1), tem);\n-\t  tem = const_binop (MINUS_EXPR, tem, arg1, 0);\n-\t  return fold (build2 (RROTATE_EXPR, type, arg0, tem));\n-\t}\n-\n-      /* If we have a rotate of a bit operation with the rotate count and\n-\t the second operand of the bit operation both constant,\n-\t permute the two operations.  */\n-      if (code == RROTATE_EXPR && TREE_CODE (arg1) == INTEGER_CST\n-\t  && (TREE_CODE (arg0) == BIT_AND_EXPR\n-\t      || TREE_CODE (arg0) == BIT_IOR_EXPR\n-\t      || TREE_CODE (arg0) == BIT_XOR_EXPR)\n-\t  && TREE_CODE (TREE_OPERAND (arg0, 1)) == INTEGER_CST)\n-\treturn fold (build2 (TREE_CODE (arg0), type,\n-\t\t\t     fold (build2 (code, type,\n-\t\t\t\t\t   TREE_OPERAND (arg0, 0), arg1)),\n-\t\t\t     fold (build2 (code, type,\n-\t\t\t\t\t   TREE_OPERAND (arg0, 1), arg1))));\n-\n-      /* Two consecutive rotates adding up to the width of the mode can\n-\t be ignored.  */\n-      if (code == RROTATE_EXPR && TREE_CODE (arg1) == INTEGER_CST\n-\t  && TREE_CODE (arg0) == RROTATE_EXPR\n-\t  && TREE_CODE (TREE_OPERAND (arg0, 1)) == INTEGER_CST\n-\t  && TREE_INT_CST_HIGH (arg1) == 0\n-\t  && TREE_INT_CST_HIGH (TREE_OPERAND (arg0, 1)) == 0\n-\t  && ((TREE_INT_CST_LOW (arg1)\n-\t       + TREE_INT_CST_LOW (TREE_OPERAND (arg0, 1)))\n-\t      == (unsigned int) GET_MODE_BITSIZE (TYPE_MODE (type))))\n-\treturn TREE_OPERAND (arg0, 0);\n-\n-      goto binary;\n-\n-    case MIN_EXPR:\n-      if (operand_equal_p (arg0, arg1, 0))\n-\treturn omit_one_operand (type, arg0, arg1);\n-      if (INTEGRAL_TYPE_P (type)\n-\t  && operand_equal_p (arg1, TYPE_MIN_VALUE (type), OEP_ONLY_CONST))\n-\treturn omit_one_operand (type, arg1, arg0);\n-      goto associate;\n-\n-    case MAX_EXPR:\n-      if (operand_equal_p (arg0, arg1, 0))\n-\treturn omit_one_operand (type, arg0, arg1);\n-      if (INTEGRAL_TYPE_P (type)\n-\t  && TYPE_MAX_VALUE (type)\n-\t  && operand_equal_p (arg1, TYPE_MAX_VALUE (type), OEP_ONLY_CONST))\n-\treturn omit_one_operand (type, arg1, arg0);\n-      goto associate;\n-\n-    case TRUTH_ANDIF_EXPR:\n-      /* Note that the operands of this must be ints\n-\t and their values must be 0 or 1.\n-\t (\"true\" is a fixed value perhaps depending on the language.)  */\n-      /* If first arg is constant zero, return it.  */\n-      if (integer_zerop (arg0))\n-\treturn fold_convert (type, arg0);\n-    case TRUTH_AND_EXPR:\n-      /* If either arg is constant true, drop it.  */\n-      if (TREE_CODE (arg0) == INTEGER_CST && ! integer_zerop (arg0))\n-\treturn non_lvalue (fold_convert (type, arg1));\n-      if (TREE_CODE (arg1) == INTEGER_CST && ! integer_zerop (arg1)\n-\t  /* Preserve sequence points.  */\n-\t  && (code != TRUTH_ANDIF_EXPR || ! TREE_SIDE_EFFECTS (arg0)))\n-\treturn non_lvalue (fold_convert (type, arg0));\n-      /* If second arg is constant zero, result is zero, but first arg\n-\t must be evaluated.  */\n-      if (integer_zerop (arg1))\n-\treturn omit_one_operand (type, arg1, arg0);\n-      /* Likewise for first arg, but note that only the TRUTH_AND_EXPR\n-\t case will be handled here.  */\n-      if (integer_zerop (arg0))\n-\treturn omit_one_operand (type, arg0, arg1);\n-\n-      /* !X && X is always false.  */\n-      if (TREE_CODE (arg0) == TRUTH_NOT_EXPR\n-\t  && operand_equal_p (TREE_OPERAND (arg0, 0), arg1, 0))\n-\treturn omit_one_operand (type, integer_zero_node, arg1);\n-      /* X && !X is always false.  */\n-      if (TREE_CODE (arg1) == TRUTH_NOT_EXPR\n-\t  && operand_equal_p (arg0, TREE_OPERAND (arg1, 0), 0))\n-\treturn omit_one_operand (type, integer_zero_node, arg0);\n-\n-      /* A < X && A + 1 > Y ==> A < X && A >= Y.  Normally A + 1 > Y\n-\t means A >= Y && A != MAX, but in this case we know that\n-\t A < X <= MAX.  */\n-\n-      if (!TREE_SIDE_EFFECTS (arg0)\n-\t  && !TREE_SIDE_EFFECTS (arg1))\n-\t{\n-\t  tem = fold_to_nonsharp_ineq_using_bound (arg0, arg1);\n-\t  if (tem)\n-\t    return fold (build2 (code, type, tem, arg1));\n-\n-\t  tem = fold_to_nonsharp_ineq_using_bound (arg1, arg0);\n-\t  if (tem)\n-\t    return fold (build2 (code, type, arg0, tem));\n-\t}\n-\n-    truth_andor:\n-      /* We only do these simplifications if we are optimizing.  */\n-      if (!optimize)\n-\treturn t;\n-\n-      /* Check for things like (A || B) && (A || C).  We can convert this\n-\t to A || (B && C).  Note that either operator can be any of the four\n-\t truth and/or operations and the transformation will still be\n-\t valid.   Also note that we only care about order for the\n-\t ANDIF and ORIF operators.  If B contains side effects, this\n-\t might change the truth-value of A.  */\n-      if (TREE_CODE (arg0) == TREE_CODE (arg1)\n-\t  && (TREE_CODE (arg0) == TRUTH_ANDIF_EXPR\n-\t      || TREE_CODE (arg0) == TRUTH_ORIF_EXPR\n-\t      || TREE_CODE (arg0) == TRUTH_AND_EXPR\n-\t      || TREE_CODE (arg0) == TRUTH_OR_EXPR)\n-\t  && ! TREE_SIDE_EFFECTS (TREE_OPERAND (arg0, 1)))\n-\t{\n-\t  tree a00 = TREE_OPERAND (arg0, 0);\n-\t  tree a01 = TREE_OPERAND (arg0, 1);\n-\t  tree a10 = TREE_OPERAND (arg1, 0);\n-\t  tree a11 = TREE_OPERAND (arg1, 1);\n-\t  int commutative = ((TREE_CODE (arg0) == TRUTH_OR_EXPR\n-\t\t\t      || TREE_CODE (arg0) == TRUTH_AND_EXPR)\n-\t\t\t     && (code == TRUTH_AND_EXPR\n-\t\t\t\t || code == TRUTH_OR_EXPR));\n-\n-\t  if (operand_equal_p (a00, a10, 0))\n-\t    return fold (build2 (TREE_CODE (arg0), type, a00,\n-\t\t\t\t fold (build2 (code, type, a01, a11))));\n-\t  else if (commutative && operand_equal_p (a00, a11, 0))\n-\t    return fold (build2 (TREE_CODE (arg0), type, a00,\n-\t\t\t\t fold (build2 (code, type, a01, a10))));\n-\t  else if (commutative && operand_equal_p (a01, a10, 0))\n-\t    return fold (build2 (TREE_CODE (arg0), type, a01,\n-\t\t\t\t fold (build2 (code, type, a00, a11))));\n-\n-\t  /* This case if tricky because we must either have commutative\n-\t     operators or else A10 must not have side-effects.  */\n-\n-\t  else if ((commutative || ! TREE_SIDE_EFFECTS (a10))\n-\t\t   && operand_equal_p (a01, a11, 0))\n-\t    return fold (build2 (TREE_CODE (arg0), type,\n-\t\t\t\t fold (build2 (code, type, a00, a10)),\n-\t\t\t\t a01));\n-\t}\n-\n-      /* See if we can build a range comparison.  */\n-      if (0 != (tem = fold_range_test (t)))\n-\treturn tem;\n-\n-      /* Check for the possibility of merging component references.  If our\n-\t lhs is another similar operation, try to merge its rhs with our\n-\t rhs.  Then try to merge our lhs and rhs.  */\n-      if (TREE_CODE (arg0) == code\n-\t  && 0 != (tem = fold_truthop (code, type,\n-\t\t\t\t       TREE_OPERAND (arg0, 1), arg1)))\n-\treturn fold (build2 (code, type, TREE_OPERAND (arg0, 0), tem));\n-\n-      if ((tem = fold_truthop (code, type, arg0, arg1)) != 0)\n-\treturn tem;\n-\n-      return t;\n-\n-    case TRUTH_ORIF_EXPR:\n-      /* Note that the operands of this must be ints\n-\t and their values must be 0 or true.\n-\t (\"true\" is a fixed value perhaps depending on the language.)  */\n-      /* If first arg is constant true, return it.  */\n-      if (TREE_CODE (arg0) == INTEGER_CST && ! integer_zerop (arg0))\n-\treturn fold_convert (type, arg0);\n-    case TRUTH_OR_EXPR:\n-      /* If either arg is constant zero, drop it.  */\n-      if (TREE_CODE (arg0) == INTEGER_CST && integer_zerop (arg0))\n-\treturn non_lvalue (fold_convert (type, arg1));\n-      if (TREE_CODE (arg1) == INTEGER_CST && integer_zerop (arg1)\n-\t  /* Preserve sequence points.  */\n-\t  && (code != TRUTH_ORIF_EXPR || ! TREE_SIDE_EFFECTS (arg0)))\n-\treturn non_lvalue (fold_convert (type, arg0));\n-      /* If second arg is constant true, result is true, but we must\n-\t evaluate first arg.  */\n-      if (TREE_CODE (arg1) == INTEGER_CST && ! integer_zerop (arg1))\n-\treturn omit_one_operand (type, arg1, arg0);\n-      /* Likewise for first arg, but note this only occurs here for\n-\t TRUTH_OR_EXPR.  */\n-      if (TREE_CODE (arg0) == INTEGER_CST && ! integer_zerop (arg0))\n-\treturn omit_one_operand (type, arg0, arg1);\n-\n-      /* !X || X is always true.  */\n-      if (TREE_CODE (arg0) == TRUTH_NOT_EXPR\n-\t  && operand_equal_p (TREE_OPERAND (arg0, 0), arg1, 0))\n-\treturn omit_one_operand (type, integer_one_node, arg1);\n-      /* X || !X is always true.  */\n-      if (TREE_CODE (arg1) == TRUTH_NOT_EXPR\n-\t  && operand_equal_p (arg0, TREE_OPERAND (arg1, 0), 0))\n-\treturn omit_one_operand (type, integer_one_node, arg0);\n-\n-      goto truth_andor;\n-\n-    case TRUTH_XOR_EXPR:\n-      /* If the second arg is constant zero, drop it.  */\n-      if (integer_zerop (arg1))\n-\treturn non_lvalue (fold_convert (type, arg0));\n-      /* If the second arg is constant true, this is a logical inversion.  */\n-      if (integer_onep (arg1))\n-\treturn non_lvalue (fold_convert (type, invert_truthvalue (arg0)));\n-      /* Identical arguments cancel to zero.  */\n-      if (operand_equal_p (arg0, arg1, 0))\n-\treturn omit_one_operand (type, integer_zero_node, arg0);\n-\n-      /* !X ^ X is always true.  */\n-      if (TREE_CODE (arg0) == TRUTH_NOT_EXPR\n-\t  && operand_equal_p (TREE_OPERAND (arg0, 0), arg1, 0))\n-\treturn omit_one_operand (type, integer_one_node, arg1);\n-\n-      /* X ^ !X is always true.  */\n-      if (TREE_CODE (arg1) == TRUTH_NOT_EXPR\n-\t  && operand_equal_p (arg0, TREE_OPERAND (arg1, 0), 0))\n-\treturn omit_one_operand (type, integer_one_node, arg0);\n-\n-      return t;\n-\n-    case EQ_EXPR:\n-    case NE_EXPR:\n-    case LT_EXPR:\n-    case GT_EXPR:\n-    case LE_EXPR:\n-    case GE_EXPR:\n-      /* If one arg is a real or integer constant, put it last.  */\n-      if (tree_swap_operands_p (arg0, arg1, true))\n-\treturn fold (build2 (swap_tree_comparison (code), type, arg1, arg0));\n-\n-      /* If this is an equality comparison of the address of a non-weak\n-\t object against zero, then we know the result.  */\n-      if ((code == EQ_EXPR || code == NE_EXPR)\n-\t  && TREE_CODE (arg0) == ADDR_EXPR\n-\t  && DECL_P (TREE_OPERAND (arg0, 0))\n-\t  && ! DECL_WEAK (TREE_OPERAND (arg0, 0))\n-\t  && integer_zerop (arg1))\n-\treturn constant_boolean_node (code != EQ_EXPR, type);\n-\n-      /* If this is an equality comparison of the address of two non-weak,\n-\t unaliased symbols neither of which are extern (since we do not\n-\t have access to attributes for externs), then we know the result.  */\n-      if ((code == EQ_EXPR || code == NE_EXPR)\n-\t  && TREE_CODE (arg0) == ADDR_EXPR\n-\t  && DECL_P (TREE_OPERAND (arg0, 0))\n-\t  && ! DECL_WEAK (TREE_OPERAND (arg0, 0))\n-\t  && ! lookup_attribute (\"alias\",\n-\t\t\t\t DECL_ATTRIBUTES (TREE_OPERAND (arg0, 0)))\n-\t  && ! DECL_EXTERNAL (TREE_OPERAND (arg0, 0))\n-\t  && TREE_CODE (arg1) == ADDR_EXPR\n-\t  && DECL_P (TREE_OPERAND (arg1, 0))\n-\t  && ! DECL_WEAK (TREE_OPERAND (arg1, 0))\n-\t  && ! lookup_attribute (\"alias\",\n-\t\t\t\t DECL_ATTRIBUTES (TREE_OPERAND (arg1, 0)))\n-\t  && ! DECL_EXTERNAL (TREE_OPERAND (arg1, 0)))\n-\treturn constant_boolean_node (operand_equal_p (arg0, arg1, 0)\n-\t\t\t\t      ? code == EQ_EXPR : code != EQ_EXPR,\n-\t\t\t\t      type);\n-\n-      /* If this is a comparison of two exprs that look like an\n-\t ARRAY_REF of the same object, then we can fold this to a\n-\t comparison of the two offsets.  */\n-      if (COMPARISON_CLASS_P (t))\n-\t{\n-\t  tree base0, offset0, base1, offset1;\n-\n-\t  if (extract_array_ref (arg0, &base0, &offset0)\n-\t      && extract_array_ref (arg1, &base1, &offset1)\n-\t      && operand_equal_p (base0, base1, 0))\n-\t    {\n-\t      if (offset0 == NULL_TREE\n-\t\t  && offset1 == NULL_TREE)\n-\t\t{\n-\t\t  offset0 = integer_zero_node;\n-\t\t  offset1 = integer_zero_node;\n-\t\t}\n-\t      else if (offset0 == NULL_TREE)\n-\t\toffset0 = build_int_cst (TREE_TYPE (offset1), 0);\n-\t      else if (offset1 == NULL_TREE)\n-\t\toffset1 = build_int_cst (TREE_TYPE (offset0), 0);\n-\n-\t      if (TREE_TYPE (offset0) == TREE_TYPE (offset1))\n-\t\treturn fold (build2 (code, type, offset0, offset1));\n-\t    }\n-\t}\n-\n-      if (FLOAT_TYPE_P (TREE_TYPE (arg0)))\n-\t{\n-\t  tree targ0 = strip_float_extensions (arg0);\n-\t  tree targ1 = strip_float_extensions (arg1);\n-\t  tree newtype = TREE_TYPE (targ0);\n-\n-\t  if (TYPE_PRECISION (TREE_TYPE (targ1)) > TYPE_PRECISION (newtype))\n-\t    newtype = TREE_TYPE (targ1);\n-\n-\t  /* Fold (double)float1 CMP (double)float2 into float1 CMP float2.  */\n-\t  if (TYPE_PRECISION (newtype) < TYPE_PRECISION (TREE_TYPE (arg0)))\n-\t    return fold (build2 (code, type, fold_convert (newtype, targ0),\n-\t\t\t\t fold_convert (newtype, targ1)));\n-\n-\t  /* (-a) CMP (-b) -> b CMP a  */\n-\t  if (TREE_CODE (arg0) == NEGATE_EXPR\n-\t      && TREE_CODE (arg1) == NEGATE_EXPR)\n-\t    return fold (build2 (code, type, TREE_OPERAND (arg1, 0),\n-\t\t\t\t TREE_OPERAND (arg0, 0)));\n-\n-\t  if (TREE_CODE (arg1) == REAL_CST)\n-\t  {\n-\t    REAL_VALUE_TYPE cst;\n-\t    cst = TREE_REAL_CST (arg1);\n-\n-\t    /* (-a) CMP CST -> a swap(CMP) (-CST)  */\n-\t    if (TREE_CODE (arg0) == NEGATE_EXPR)\n-\t      return\n-\t\tfold (build2 (swap_tree_comparison (code), type,\n-\t\t\t      TREE_OPERAND (arg0, 0),\n-\t\t\t      build_real (TREE_TYPE (arg1),\n-\t\t\t\t\t  REAL_VALUE_NEGATE (cst))));\n-\n-\t    /* IEEE doesn't distinguish +0 and -0 in comparisons.  */\n-\t    /* a CMP (-0) -> a CMP 0  */\n-\t    if (REAL_VALUE_MINUS_ZERO (cst))\n-\t      return fold (build2 (code, type, arg0,\n-\t\t\t\t   build_real (TREE_TYPE (arg1), dconst0)));\n-\n-\t    /* x != NaN is always true, other ops are always false.  */\n-\t    if (REAL_VALUE_ISNAN (cst)\n-\t\t&& ! HONOR_SNANS (TYPE_MODE (TREE_TYPE (arg1))))\n-\t      {\n-\t\ttem = (code == NE_EXPR) ? integer_one_node : integer_zero_node;\n-\t\treturn omit_one_operand (type, tem, arg0);\n-\t      }\n-\n-\t    /* Fold comparisons against infinity.  */\n-\t    if (REAL_VALUE_ISINF (cst))\n-\t      {\n-\t\ttem = fold_inf_compare (code, type, arg0, arg1);\n-\t\tif (tem != NULL_TREE)\n-\t\t  return tem;\n-\t      }\n-\t  }\n-\n-\t  /* If this is a comparison of a real constant with a PLUS_EXPR\n-\t     or a MINUS_EXPR of a real constant, we can convert it into a\n-\t     comparison with a revised real constant as long as no overflow\n-\t     occurs when unsafe_math_optimizations are enabled.  */\n-\t  if (flag_unsafe_math_optimizations\n-\t      && TREE_CODE (arg1) == REAL_CST\n-\t      && (TREE_CODE (arg0) == PLUS_EXPR\n-\t\t  || TREE_CODE (arg0) == MINUS_EXPR)\n-\t      && TREE_CODE (TREE_OPERAND (arg0, 1)) == REAL_CST\n-\t      && 0 != (tem = const_binop (TREE_CODE (arg0) == PLUS_EXPR\n-\t\t\t\t\t  ? MINUS_EXPR : PLUS_EXPR,\n-\t\t\t\t\t  arg1, TREE_OPERAND (arg0, 1), 0))\n-\t      && ! TREE_CONSTANT_OVERFLOW (tem))\n-\t    return fold (build2 (code, type, TREE_OPERAND (arg0, 0), tem));\n-\n-\t  /* Likewise, we can simplify a comparison of a real constant with\n-\t     a MINUS_EXPR whose first operand is also a real constant, i.e.\n-\t     (c1 - x) < c2 becomes x > c1-c2.  */\n-\t  if (flag_unsafe_math_optimizations\n-\t      && TREE_CODE (arg1) == REAL_CST\n-\t      && TREE_CODE (arg0) == MINUS_EXPR\n-\t      && TREE_CODE (TREE_OPERAND (arg0, 0)) == REAL_CST\n-\t      && 0 != (tem = const_binop (MINUS_EXPR, TREE_OPERAND (arg0, 0),\n-\t\t\t\t\t  arg1, 0))\n-\t      && ! TREE_CONSTANT_OVERFLOW (tem))\n-\t    return fold (build2 (swap_tree_comparison (code), type,\n-\t\t\t\t TREE_OPERAND (arg0, 1), tem));\n-\n-\t  /* Fold comparisons against built-in math functions.  */\n-\t  if (TREE_CODE (arg1) == REAL_CST\n-\t      && flag_unsafe_math_optimizations\n-\t      && ! flag_errno_math)\n-\t    {\n-\t      enum built_in_function fcode = builtin_mathfn_code (arg0);\n-\n-\t      if (fcode != END_BUILTINS)\n-\t\t{\n-\t\t  tem = fold_mathfn_compare (fcode, code, type, arg0, arg1);\n-\t\t  if (tem != NULL_TREE)\n-\t\t    return tem;\n-\t\t}\n-\t    }\n-\t}\n-\n-      /* Convert foo++ == CONST into ++foo == CONST + INCR.  */\n-      if (TREE_CONSTANT (arg1)\n-\t  && (TREE_CODE (arg0) == POSTINCREMENT_EXPR\n-\t      || TREE_CODE (arg0) == POSTDECREMENT_EXPR)\n-\t  /* This optimization is invalid for ordered comparisons\n-\t     if CONST+INCR overflows or if foo+incr might overflow.\n-\t     This optimization is invalid for floating point due to rounding.\n-\t     For pointer types we assume overflow doesn't happen.  */\n-\t  && (POINTER_TYPE_P (TREE_TYPE (arg0))\n-\t      || (INTEGRAL_TYPE_P (TREE_TYPE (arg0))\n-\t\t  && (code == EQ_EXPR || code == NE_EXPR))))\n-\t{\n-\t  tree varop, newconst;\n-\n-\t  if (TREE_CODE (arg0) == POSTINCREMENT_EXPR)\n-\t    {\n-\t      newconst = fold (build2 (PLUS_EXPR, TREE_TYPE (arg0),\n-\t\t\t\t       arg1, TREE_OPERAND (arg0, 1)));\n-\t      varop = build2 (PREINCREMENT_EXPR, TREE_TYPE (arg0),\n-\t\t\t      TREE_OPERAND (arg0, 0),\n-\t\t\t      TREE_OPERAND (arg0, 1));\n-\t    }\n-\t  else\n-\t    {\n-\t      newconst = fold (build2 (MINUS_EXPR, TREE_TYPE (arg0),\n-\t\t\t\t       arg1, TREE_OPERAND (arg0, 1)));\n-\t      varop = build2 (PREDECREMENT_EXPR, TREE_TYPE (arg0),\n-\t\t\t      TREE_OPERAND (arg0, 0),\n-\t\t\t      TREE_OPERAND (arg0, 1));\n-\t    }\n-\n-\n-\t  /* If VAROP is a reference to a bitfield, we must mask\n-\t     the constant by the width of the field.  */\n-\t  if (TREE_CODE (TREE_OPERAND (varop, 0)) == COMPONENT_REF\n-\t      && DECL_BIT_FIELD (TREE_OPERAND (TREE_OPERAND (varop, 0), 1))\n-\t      && host_integerp (DECL_SIZE (TREE_OPERAND\n-\t\t\t\t\t   (TREE_OPERAND (varop, 0), 1)), 1))\n-\t    {\n-\t      tree fielddecl = TREE_OPERAND (TREE_OPERAND (varop, 0), 1);\n-\t      HOST_WIDE_INT size = tree_low_cst (DECL_SIZE (fielddecl), 1);\n-\t      tree folded_compare, shift;\n-\n-\t      /* First check whether the comparison would come out\n-\t\t always the same.  If we don't do that we would\n-\t\t change the meaning with the masking.  */\n-\t      folded_compare = fold (build2 (code, type,\n-\t\t\t\t\t     TREE_OPERAND (varop, 0), arg1));\n-\t      if (integer_zerop (folded_compare)\n-\t\t  || integer_onep (folded_compare))\n-\t\treturn omit_one_operand (type, folded_compare, varop);\n-\n-\t      shift = build_int_cst (NULL_TREE,\n-\t\t\t\t     TYPE_PRECISION (TREE_TYPE (varop)) - size);\n-\t      shift = fold_convert (TREE_TYPE (varop), shift);\n-\t      newconst = fold (build2 (LSHIFT_EXPR, TREE_TYPE (varop),\n-\t\t\t\t       newconst, shift));\n-\t      newconst = fold (build2 (RSHIFT_EXPR, TREE_TYPE (varop),\n-\t\t\t\t       newconst, shift));\n-\t    }\n-\n-\t  return fold (build2 (code, type, varop, newconst));\n-\t}\n-\n-      /* Change X >= C to X > (C - 1) and X < C to X <= (C - 1) if C > 0.\n-\t This transformation affects the cases which are handled in later\n-\t optimizations involving comparisons with non-negative constants.  */\n-      if (TREE_CODE (arg1) == INTEGER_CST\n-\t  && TREE_CODE (arg0) != INTEGER_CST\n-\t  && tree_int_cst_sgn (arg1) > 0)\n-\t{\n-\t  switch (code)\n-\t    {\n-\t    case GE_EXPR:\n-\t      arg1 = const_binop (MINUS_EXPR, arg1, integer_one_node, 0);\n-\t      return fold (build2 (GT_EXPR, type, arg0, arg1));\n-\n-\t    case LT_EXPR:\n-\t      arg1 = const_binop (MINUS_EXPR, arg1, integer_one_node, 0);\n-\t      return fold (build2 (LE_EXPR, type, arg0, arg1));\n-\n-\t    default:\n-\t      break;\n-\t    }\n-\t}\n-\n-      /* Comparisons with the highest or lowest possible integer of\n-\t the specified size will have known values.\n-\n-\t This is quite similar to fold_relational_hi_lo, however,\n-\t attempts to share the code have been nothing but trouble.  */\n-      {\n-\tint width = GET_MODE_BITSIZE (TYPE_MODE (TREE_TYPE (arg1)));\n-\n-\tif (TREE_CODE (arg1) == INTEGER_CST\n-\t    && ! TREE_CONSTANT_OVERFLOW (arg1)\n-\t    && width <= 2 * HOST_BITS_PER_WIDE_INT\n-\t    && (INTEGRAL_TYPE_P (TREE_TYPE (arg1))\n-\t\t|| POINTER_TYPE_P (TREE_TYPE (arg1))))\n-\t  {\n-\t    HOST_WIDE_INT signed_max_hi;\n-\t    unsigned HOST_WIDE_INT signed_max_lo;\n-\t    unsigned HOST_WIDE_INT max_hi, max_lo, min_hi, min_lo;\n-\n-\t    if (width <= HOST_BITS_PER_WIDE_INT)\n-\t      {\n-\t\tsigned_max_lo = ((unsigned HOST_WIDE_INT) 1 << (width - 1))\n-\t\t\t\t- 1;\n-\t\tsigned_max_hi = 0;\n-\t\tmax_hi = 0;\n-\n-\t\tif (TYPE_UNSIGNED (TREE_TYPE (arg1)))\n-\t\t  {\n-\t\t    max_lo = ((unsigned HOST_WIDE_INT) 2 << (width - 1)) - 1;\n-\t\t    min_lo = 0;\n-\t\t    min_hi = 0;\n-\t\t  }\n-\t\telse\n-\t\t  {\n-\t\t    max_lo = signed_max_lo;\n-\t\t    min_lo = ((unsigned HOST_WIDE_INT) -1 << (width - 1));\n-\t\t    min_hi = -1;\n-\t\t  }\n-\t      }\n-\t    else\n-\t      {\n-\t\twidth -= HOST_BITS_PER_WIDE_INT;\n-\t\tsigned_max_lo = -1;\n-\t\tsigned_max_hi = ((unsigned HOST_WIDE_INT) 1 << (width - 1))\n-\t\t\t\t- 1;\n-\t\tmax_lo = -1;\n-\t\tmin_lo = 0;\n-\n-\t\tif (TYPE_UNSIGNED (TREE_TYPE (arg1)))\n-\t\t  {\n-\t\t    max_hi = ((unsigned HOST_WIDE_INT) 2 << (width - 1)) - 1;\n-\t\t    min_hi = 0;\n-\t\t  }\n-\t\telse\n-\t\t  {\n-\t\t    max_hi = signed_max_hi;\n-\t\t    min_hi = ((unsigned HOST_WIDE_INT) -1 << (width - 1));\n-\t\t  }\n-\t      }\n-\n-\t    if ((unsigned HOST_WIDE_INT) TREE_INT_CST_HIGH (arg1) == max_hi\n-\t\t&& TREE_INT_CST_LOW (arg1) == max_lo)\n-\t      switch (code)\n-\t\t{\n-\t\tcase GT_EXPR:\n-\t\t  return omit_one_operand (type, integer_zero_node, arg0);\n-\n-\t\tcase GE_EXPR:\n-\t\t  return fold (build2 (EQ_EXPR, type, arg0, arg1));\n-\n-\t\tcase LE_EXPR:\n-\t\t  return omit_one_operand (type, integer_one_node, arg0);\n-\n-\t\tcase LT_EXPR:\n-\t\t  return fold (build2 (NE_EXPR, type, arg0, arg1));\n-\n-\t\t/* The GE_EXPR and LT_EXPR cases above are not normally\n-\t\t   reached because of previous transformations.  */\n-\n-\t\tdefault:\n-\t\t  break;\n-\t\t}\n-\t    else if ((unsigned HOST_WIDE_INT) TREE_INT_CST_HIGH (arg1)\n-\t\t     == max_hi\n-\t\t     && TREE_INT_CST_LOW (arg1) == max_lo - 1)\n-\t      switch (code)\n-\t\t{\n-\t\tcase GT_EXPR:\n-\t\t  arg1 = const_binop (PLUS_EXPR, arg1, integer_one_node, 0);\n-\t\t  return fold (build2 (EQ_EXPR, type, arg0, arg1));\n-\t\tcase LE_EXPR:\n-\t\t  arg1 = const_binop (PLUS_EXPR, arg1, integer_one_node, 0);\n-\t\t  return fold (build2 (NE_EXPR, type, arg0, arg1));\n-\t\tdefault:\n-\t\t  break;\n-\t\t}\n-\t    else if ((unsigned HOST_WIDE_INT) TREE_INT_CST_HIGH (arg1)\n-\t\t     == min_hi\n-\t\t     && TREE_INT_CST_LOW (arg1) == min_lo)\n-\t      switch (code)\n-\t\t{\n-\t\tcase LT_EXPR:\n-\t\t  return omit_one_operand (type, integer_zero_node, arg0);\n-\n-\t\tcase LE_EXPR:\n-\t\t  return fold (build2 (EQ_EXPR, type, arg0, arg1));\n-\n-\t\tcase GE_EXPR:\n-\t\t  return omit_one_operand (type, integer_one_node, arg0);\n-\n-\t\tcase GT_EXPR:\n-\t\t  return fold (build2 (NE_EXPR, type, arg0, arg1));\n-\n-\t\tdefault:\n-\t\t  break;\n-\t\t}\n-\t    else if ((unsigned HOST_WIDE_INT) TREE_INT_CST_HIGH (arg1)\n-\t\t     == min_hi\n-\t\t     && TREE_INT_CST_LOW (arg1) == min_lo + 1)\n-\t      switch (code)\n-\t\t{\n-\t\tcase GE_EXPR:\n-\t\t  arg1 = const_binop (MINUS_EXPR, arg1, integer_one_node, 0);\n-\t\t  return fold (build2 (NE_EXPR, type, arg0, arg1));\n-\t\tcase LT_EXPR:\n-\t\t  arg1 = const_binop (MINUS_EXPR, arg1, integer_one_node, 0);\n-\t\t  return fold (build2 (EQ_EXPR, type, arg0, arg1));\n-\t\tdefault:\n-\t\t  break;\n-\t\t}\n-\n-\t    else if (!in_gimple_form\n-\t\t     && TREE_INT_CST_HIGH (arg1) == signed_max_hi\n-\t\t     && TREE_INT_CST_LOW (arg1) == signed_max_lo\n-\t\t     && TYPE_UNSIGNED (TREE_TYPE (arg1))\n-\t\t     /* signed_type does not work on pointer types.  */\n-\t\t     && INTEGRAL_TYPE_P (TREE_TYPE (arg1)))\n-\t      {\n-\t\t/* The following case also applies to X < signed_max+1\n-\t\t   and X >= signed_max+1 because previous transformations.  */\n-\t\tif (code == LE_EXPR || code == GT_EXPR)\n-\t\t  {\n-\t\t    tree st0, st1;\n-\t\t    st0 = lang_hooks.types.signed_type (TREE_TYPE (arg0));\n-\t\t    st1 = lang_hooks.types.signed_type (TREE_TYPE (arg1));\n-\t\t    return fold\n-\t\t      (build2 (code == LE_EXPR ? GE_EXPR: LT_EXPR,\n-\t\t\t       type, fold_convert (st0, arg0),\n-\t\t\t       fold_convert (st1, integer_zero_node)));\n-\t\t  }\n-\t      }\n-\t  }\n-      }\n-\n-      /* If this is an EQ or NE comparison of a constant with a PLUS_EXPR or\n-\t a MINUS_EXPR of a constant, we can convert it into a comparison with\n-\t a revised constant as long as no overflow occurs.  */\n-      if ((code == EQ_EXPR || code == NE_EXPR)\n-\t  && TREE_CODE (arg1) == INTEGER_CST\n-\t  && (TREE_CODE (arg0) == PLUS_EXPR\n-\t      || TREE_CODE (arg0) == MINUS_EXPR)\n-\t  && TREE_CODE (TREE_OPERAND (arg0, 1)) == INTEGER_CST\n-\t  && 0 != (tem = const_binop (TREE_CODE (arg0) == PLUS_EXPR\n-\t\t\t\t      ? MINUS_EXPR : PLUS_EXPR,\n-\t\t\t\t      arg1, TREE_OPERAND (arg0, 1), 0))\n-\t  && ! TREE_CONSTANT_OVERFLOW (tem))\n-\treturn fold (build2 (code, type, TREE_OPERAND (arg0, 0), tem));\n-\n-      /* Similarly for a NEGATE_EXPR.  */\n-      else if ((code == EQ_EXPR || code == NE_EXPR)\n-\t       && TREE_CODE (arg0) == NEGATE_EXPR\n-\t       && TREE_CODE (arg1) == INTEGER_CST\n-\t       && 0 != (tem = negate_expr (arg1))\n-\t       && TREE_CODE (tem) == INTEGER_CST\n-\t       && ! TREE_CONSTANT_OVERFLOW (tem))\n-\treturn fold (build2 (code, type, TREE_OPERAND (arg0, 0), tem));\n-\n-      /* If we have X - Y == 0, we can convert that to X == Y and similarly\n-\t for !=.  Don't do this for ordered comparisons due to overflow.  */\n-      else if ((code == NE_EXPR || code == EQ_EXPR)\n-\t       && integer_zerop (arg1) && TREE_CODE (arg0) == MINUS_EXPR)\n-\treturn fold (build2 (code, type,\n-\t\t\t     TREE_OPERAND (arg0, 0), TREE_OPERAND (arg0, 1)));\n-\n-      else if (TREE_CODE (TREE_TYPE (arg0)) == INTEGER_TYPE\n-\t       && TREE_CODE (arg0) == NOP_EXPR)\n-\t{\n-\t  /* If we are widening one operand of an integer comparison,\n-\t     see if the other operand is similarly being widened.  Perhaps we\n-\t     can do the comparison in the narrower type.  */\n-\t  tem = fold_widened_comparison (code, type, arg0, arg1);\n-\t  if (tem)\n-\t    return tem;\n-\n-\t  /* Or if we are changing signedness.  */\n-\t  tem = fold_sign_changed_comparison (code, type, arg0, arg1);\n-\t  if (tem)\n-\t    return tem;\n-\t}\n-\n-      /* If this is comparing a constant with a MIN_EXPR or a MAX_EXPR of a\n-\t constant, we can simplify it.  */\n-      else if (TREE_CODE (arg1) == INTEGER_CST\n-\t       && (TREE_CODE (arg0) == MIN_EXPR\n-\t\t   || TREE_CODE (arg0) == MAX_EXPR)\n-\t       && TREE_CODE (TREE_OPERAND (arg0, 1)) == INTEGER_CST)\n-\treturn optimize_minmax_comparison (t);\n-\n-      /* If we are comparing an ABS_EXPR with a constant, we can\n-\t convert all the cases into explicit comparisons, but they may\n-\t well not be faster than doing the ABS and one comparison.\n-\t But ABS (X) <= C is a range comparison, which becomes a subtraction\n-\t and a comparison, and is probably faster.  */\n-      else if (code == LE_EXPR && TREE_CODE (arg1) == INTEGER_CST\n-\t       && TREE_CODE (arg0) == ABS_EXPR\n-\t       && ! TREE_SIDE_EFFECTS (arg0)\n-\t       && (0 != (tem = negate_expr (arg1)))\n-\t       && TREE_CODE (tem) == INTEGER_CST\n-\t       && ! TREE_CONSTANT_OVERFLOW (tem))\n-\treturn fold (build2 (TRUTH_ANDIF_EXPR, type,\n-\t\t\t     build2 (GE_EXPR, type,\n-\t\t\t\t     TREE_OPERAND (arg0, 0), tem),\n-\t\t\t     build2 (LE_EXPR, type,\n-\t\t\t\t     TREE_OPERAND (arg0, 0), arg1)));\n-\n-      /* Convert ABS_EXPR<x> >= 0 to true.  */\n-      else if (code == GE_EXPR\n-\t       && tree_expr_nonnegative_p (arg0)\n-\t       && (integer_zerop (arg1)\n-\t\t   || (! HONOR_NANS (TYPE_MODE (TREE_TYPE (arg0)))\n-                       && real_zerop (arg1))))\n-\treturn omit_one_operand (type, integer_one_node, arg0);\n-\n-      /* Convert ABS_EXPR<x> < 0 to false.  */\n-      else if (code == LT_EXPR\n-\t       && tree_expr_nonnegative_p (arg0)\n-\t       && (integer_zerop (arg1) || real_zerop (arg1)))\n-\treturn omit_one_operand (type, integer_zero_node, arg0);\n-\n-      /* Convert ABS_EXPR<x> == 0 or ABS_EXPR<x> != 0 to x == 0 or x != 0.  */\n-      else if ((code == EQ_EXPR || code == NE_EXPR)\n-\t       && TREE_CODE (arg0) == ABS_EXPR\n-\t       && (integer_zerop (arg1) || real_zerop (arg1)))\n-\treturn fold (build2 (code, type, TREE_OPERAND (arg0, 0), arg1));\n-\n-      /* If this is an EQ or NE comparison with zero and ARG0 is\n-\t (1 << foo) & bar, convert it to (bar >> foo) & 1.  Both require\n-\t two operations, but the latter can be done in one less insn\n-\t on machines that have only two-operand insns or on which a\n-\t constant cannot be the first operand.  */\n-      if (integer_zerop (arg1) && (code == EQ_EXPR || code == NE_EXPR)\n-\t  && TREE_CODE (arg0) == BIT_AND_EXPR)\n-\t{\n-\t  tree arg00 = TREE_OPERAND (arg0, 0);\n-\t  tree arg01 = TREE_OPERAND (arg0, 1);\n-\t  if (TREE_CODE (arg00) == LSHIFT_EXPR\n-\t      && integer_onep (TREE_OPERAND (arg00, 0)))\n-\t    return\n-\t      fold (build2 (code, type,\n-\t\t\t    build2 (BIT_AND_EXPR, TREE_TYPE (arg0),\n-\t\t\t\t    build2 (RSHIFT_EXPR, TREE_TYPE (arg00),\n-\t\t\t\t\t    arg01, TREE_OPERAND (arg00, 1)),\n-\t\t\t\t    fold_convert (TREE_TYPE (arg0),\n-\t\t\t\t\t\t  integer_one_node)),\n-\t\t\t    arg1));\n-\t  else if (TREE_CODE (TREE_OPERAND (arg0, 1)) == LSHIFT_EXPR\n-\t\t   && integer_onep (TREE_OPERAND (TREE_OPERAND (arg0, 1), 0)))\n-\t    return\n-\t      fold (build2 (code, type,\n-\t\t\t    build2 (BIT_AND_EXPR, TREE_TYPE (arg0),\n-\t\t\t\t    build2 (RSHIFT_EXPR, TREE_TYPE (arg01),\n-\t\t\t\t\t    arg00, TREE_OPERAND (arg01, 1)),\n-\t\t\t\t    fold_convert (TREE_TYPE (arg0),\n-\t\t\t\t\t\t  integer_one_node)),\n-\t\t\t    arg1));\n-\t}\n-\n-      /* If this is an NE or EQ comparison of zero against the result of a\n-\t signed MOD operation whose second operand is a power of 2, make\n-\t the MOD operation unsigned since it is simpler and equivalent.  */\n-      if ((code == NE_EXPR || code == EQ_EXPR)\n-\t  && integer_zerop (arg1)\n-\t  && !TYPE_UNSIGNED (TREE_TYPE (arg0))\n-\t  && (TREE_CODE (arg0) == TRUNC_MOD_EXPR\n-\t      || TREE_CODE (arg0) == CEIL_MOD_EXPR\n-\t      || TREE_CODE (arg0) == FLOOR_MOD_EXPR\n-\t      || TREE_CODE (arg0) == ROUND_MOD_EXPR)\n-\t  && integer_pow2p (TREE_OPERAND (arg0, 1)))\n-\t{\n-\t  tree newtype = lang_hooks.types.unsigned_type (TREE_TYPE (arg0));\n-\t  tree newmod = fold (build2 (TREE_CODE (arg0), newtype,\n-\t\t\t\t      fold_convert (newtype,\n-\t\t\t\t\t\t    TREE_OPERAND (arg0, 0)),\n-\t\t\t\t      fold_convert (newtype,\n-\t\t\t\t\t\t    TREE_OPERAND (arg0, 1))));\n-\n-\t  return fold (build2 (code, type, newmod,\n-\t\t\t       fold_convert (newtype, arg1)));\n-\t}\n-\n-      /* If this is an NE comparison of zero with an AND of one, remove the\n-\t comparison since the AND will give the correct value.  */\n-      if (code == NE_EXPR && integer_zerop (arg1)\n-\t  && TREE_CODE (arg0) == BIT_AND_EXPR\n-\t  && integer_onep (TREE_OPERAND (arg0, 1)))\n-\treturn fold_convert (type, arg0);\n-\n-      /* If we have (A & C) == C where C is a power of 2, convert this into\n-\t (A & C) != 0.  Similarly for NE_EXPR.  */\n-      if ((code == EQ_EXPR || code == NE_EXPR)\n-\t  && TREE_CODE (arg0) == BIT_AND_EXPR\n-\t  && integer_pow2p (TREE_OPERAND (arg0, 1))\n-\t  && operand_equal_p (TREE_OPERAND (arg0, 1), arg1, 0))\n-\treturn fold (build2 (code == EQ_EXPR ? NE_EXPR : EQ_EXPR, type,\n-\t\t\t     arg0, fold_convert (TREE_TYPE (arg0),\n-\t\t\t\t\t\t integer_zero_node)));\n-\n-      /* If we have (A & C) != 0 or (A & C) == 0 and C is a power of\n-\t 2, then fold the expression into shifts and logical operations.  */\n-      tem = fold_single_bit_test (code, arg0, arg1, type);\n-      if (tem)\n-\treturn tem;\n-\n-      /* If we have (A & C) == D where D & ~C != 0, convert this into 0.\n-\t Similarly for NE_EXPR.  */\n-      if ((code == EQ_EXPR || code == NE_EXPR)\n-\t  && TREE_CODE (arg0) == BIT_AND_EXPR\n-\t  && TREE_CODE (arg1) == INTEGER_CST\n-\t  && TREE_CODE (TREE_OPERAND (arg0, 1)) == INTEGER_CST)\n-\t{\n-\t  tree notc = fold (build1 (BIT_NOT_EXPR,\n-\t\t\t\t    TREE_TYPE (TREE_OPERAND (arg0, 1)),\n-\t\t\t\t    TREE_OPERAND (arg0, 1)));\n-\t  tree dandnotc = fold (build2 (BIT_AND_EXPR, TREE_TYPE (arg0),\n-\t\t\t\t\targ1, notc));\n-\t  tree rslt = code == EQ_EXPR ? integer_zero_node : integer_one_node;\n-\t  if (integer_nonzerop (dandnotc))\n-\t    return omit_one_operand (type, rslt, arg0);\n-\t}\n-\n-      /* If we have (A | C) == D where C & ~D != 0, convert this into 0.\n-\t Similarly for NE_EXPR.  */\n-      if ((code == EQ_EXPR || code == NE_EXPR)\n-\t  && TREE_CODE (arg0) == BIT_IOR_EXPR\n-\t  && TREE_CODE (arg1) == INTEGER_CST\n-\t  && TREE_CODE (TREE_OPERAND (arg0, 1)) == INTEGER_CST)\n-\t{\n-\t  tree notd = fold (build1 (BIT_NOT_EXPR, TREE_TYPE (arg1), arg1));\n-\t  tree candnotd = fold (build2 (BIT_AND_EXPR, TREE_TYPE (arg0),\n-\t\t\t\t\tTREE_OPERAND (arg0, 1), notd));\n-\t  tree rslt = code == EQ_EXPR ? integer_zero_node : integer_one_node;\n-\t  if (integer_nonzerop (candnotd))\n-\t    return omit_one_operand (type, rslt, arg0);\n-\t}\n-\n-      /* If X is unsigned, convert X < (1 << Y) into X >> Y == 0\n-\t and similarly for >= into !=.  */\n-      if ((code == LT_EXPR || code == GE_EXPR)\n-\t  && TYPE_UNSIGNED (TREE_TYPE (arg0))\n-\t  && TREE_CODE (arg1) == LSHIFT_EXPR\n-\t  && integer_onep (TREE_OPERAND (arg1, 0)))\n-\treturn build2 (code == LT_EXPR ? EQ_EXPR : NE_EXPR, type,\n-\t\t       build2 (RSHIFT_EXPR, TREE_TYPE (arg0), arg0,\n-\t\t\t       TREE_OPERAND (arg1, 1)),\n-\t\t       fold_convert (TREE_TYPE (arg0), integer_zero_node));\n-\n-      else if ((code == LT_EXPR || code == GE_EXPR)\n-\t       && TYPE_UNSIGNED (TREE_TYPE (arg0))\n-\t       && (TREE_CODE (arg1) == NOP_EXPR\n-\t\t   || TREE_CODE (arg1) == CONVERT_EXPR)\n-\t       && TREE_CODE (TREE_OPERAND (arg1, 0)) == LSHIFT_EXPR\n-\t       && integer_onep (TREE_OPERAND (TREE_OPERAND (arg1, 0), 0)))\n-\treturn\n-\t  build2 (code == LT_EXPR ? EQ_EXPR : NE_EXPR, type,\n-\t\t  fold_convert (TREE_TYPE (arg0),\n-\t\t\t\tbuild2 (RSHIFT_EXPR, TREE_TYPE (arg0), arg0,\n-\t\t\t\t\tTREE_OPERAND (TREE_OPERAND (arg1, 0),\n-\t\t\t\t\t\t      1))),\n-\t\t  fold_convert (TREE_TYPE (arg0), integer_zero_node));\n-\n-      /* Simplify comparison of something with itself.  (For IEEE\n-\t floating-point, we can only do some of these simplifications.)  */\n-      if (operand_equal_p (arg0, arg1, 0))\n-\t{\n-\t  switch (code)\n-\t    {\n-\t    case EQ_EXPR:\n-\t      if (! FLOAT_TYPE_P (TREE_TYPE (arg0))\n-\t\t  || ! HONOR_NANS (TYPE_MODE (TREE_TYPE (arg0))))\n-\t\treturn constant_boolean_node (1, type);\n-\t      break;\n-\n-\t    case GE_EXPR:\n-\t    case LE_EXPR:\n-\t      if (! FLOAT_TYPE_P (TREE_TYPE (arg0))\n-\t\t  || ! HONOR_NANS (TYPE_MODE (TREE_TYPE (arg0))))\n-\t\treturn constant_boolean_node (1, type);\n-\t      return fold (build2 (EQ_EXPR, type, arg0, arg1));\n-\n-\t    case NE_EXPR:\n-\t      /* For NE, we can only do this simplification if integer\n-\t\t or we don't honor IEEE floating point NaNs.  */\n-\t      if (FLOAT_TYPE_P (TREE_TYPE (arg0))\n-\t\t  && HONOR_NANS (TYPE_MODE (TREE_TYPE (arg0))))\n-\t\tbreak;\n-\t      /* ... fall through ...  */\n-\t    case GT_EXPR:\n-\t    case LT_EXPR:\n-\t      return constant_boolean_node (0, type);\n-\t    default:\n-\t      gcc_unreachable ();\n-\t    }\n-\t}\n-\n-      /* If we are comparing an expression that just has comparisons\n-\t of two integer values, arithmetic expressions of those comparisons,\n-\t and constants, we can simplify it.  There are only three cases\n-\t to check: the two values can either be equal, the first can be\n-\t greater, or the second can be greater.  Fold the expression for\n-\t those three values.  Since each value must be 0 or 1, we have\n-\t eight possibilities, each of which corresponds to the constant 0\n-\t or 1 or one of the six possible comparisons.\n-\n-\t This handles common cases like (a > b) == 0 but also handles\n-\t expressions like  ((x > y) - (y > x)) > 0, which supposedly\n-\t occur in macroized code.  */\n-\n-      if (TREE_CODE (arg1) == INTEGER_CST && TREE_CODE (arg0) != INTEGER_CST)\n-\t{\n-\t  tree cval1 = 0, cval2 = 0;\n-\t  int save_p = 0;\n-\n-\t  if (twoval_comparison_p (arg0, &cval1, &cval2, &save_p)\n-\t      /* Don't handle degenerate cases here; they should already\n-\t\t have been handled anyway.  */\n-\t      && cval1 != 0 && cval2 != 0\n-\t      && ! (TREE_CONSTANT (cval1) && TREE_CONSTANT (cval2))\n-\t      && TREE_TYPE (cval1) == TREE_TYPE (cval2)\n-\t      && INTEGRAL_TYPE_P (TREE_TYPE (cval1))\n-\t      && TYPE_MAX_VALUE (TREE_TYPE (cval1))\n-\t      && TYPE_MAX_VALUE (TREE_TYPE (cval2))\n-\t      && ! operand_equal_p (TYPE_MIN_VALUE (TREE_TYPE (cval1)),\n-\t\t\t\t    TYPE_MAX_VALUE (TREE_TYPE (cval2)), 0))\n-\t    {\n-\t      tree maxval = TYPE_MAX_VALUE (TREE_TYPE (cval1));\n-\t      tree minval = TYPE_MIN_VALUE (TREE_TYPE (cval1));\n-\n-\t      /* We can't just pass T to eval_subst in case cval1 or cval2\n-\t\t was the same as ARG1.  */\n-\n-\t      tree high_result\n-\t\t= fold (build2 (code, type,\n-\t\t\t\teval_subst (arg0, cval1, maxval,\n-\t\t\t\t\t    cval2, minval),\n-\t\t\t\targ1));\n-\t      tree equal_result\n-\t\t= fold (build2 (code, type,\n-\t\t\t\teval_subst (arg0, cval1, maxval,\n-\t\t\t\t\t    cval2, maxval),\n-\t\t\t\targ1));\n-\t      tree low_result\n-\t\t= fold (build2 (code, type,\n-\t\t\t\teval_subst (arg0, cval1, minval,\n-\t\t\t\t\t    cval2, maxval),\n-\t\t\t\targ1));\n-\n-\t      /* All three of these results should be 0 or 1.  Confirm they\n-\t\t are.  Then use those values to select the proper code\n-\t\t to use.  */\n-\n-\t      if ((integer_zerop (high_result)\n-\t\t   || integer_onep (high_result))\n-\t\t  && (integer_zerop (equal_result)\n-\t\t      || integer_onep (equal_result))\n-\t\t  && (integer_zerop (low_result)\n-\t\t      || integer_onep (low_result)))\n-\t\t{\n-\t\t  /* Make a 3-bit mask with the high-order bit being the\n-\t\t     value for `>', the next for '=', and the low for '<'.  */\n-\t\t  switch ((integer_onep (high_result) * 4)\n-\t\t\t  + (integer_onep (equal_result) * 2)\n-\t\t\t  + integer_onep (low_result))\n-\t\t    {\n-\t\t    case 0:\n-\t\t      /* Always false.  */\n-\t\t      return omit_one_operand (type, integer_zero_node, arg0);\n-\t\t    case 1:\n-\t\t      code = LT_EXPR;\n-\t\t      break;\n-\t\t    case 2:\n-\t\t      code = EQ_EXPR;\n-\t\t      break;\n-\t\t    case 3:\n-\t\t      code = LE_EXPR;\n-\t\t      break;\n-\t\t    case 4:\n-\t\t      code = GT_EXPR;\n-\t\t      break;\n-\t\t    case 5:\n-\t\t      code = NE_EXPR;\n-\t\t      break;\n-\t\t    case 6:\n-\t\t      code = GE_EXPR;\n-\t\t      break;\n-\t\t    case 7:\n-\t\t      /* Always true.  */\n-\t\t      return omit_one_operand (type, integer_one_node, arg0);\n-\t\t    }\n-\n-\t\t  tem = build2 (code, type, cval1, cval2);\n-\t\t  if (save_p)\n-\t\t    return save_expr (tem);\n-\t\t  else\n-\t\t    return fold (tem);\n-\t\t}\n-\t    }\n-\t}\n-\n-      /* If this is a comparison of a field, we may be able to simplify it.  */\n-      if (((TREE_CODE (arg0) == COMPONENT_REF\n-\t    && lang_hooks.can_use_bit_fields_p ())\n-\t   || TREE_CODE (arg0) == BIT_FIELD_REF)\n-\t  && (code == EQ_EXPR || code == NE_EXPR)\n-\t  /* Handle the constant case even without -O\n-\t     to make sure the warnings are given.  */\n-\t  && (optimize || TREE_CODE (arg1) == INTEGER_CST))\n-\t{\n-\t  t1 = optimize_bit_field_compare (code, type, arg0, arg1);\n-\t  if (t1)\n-\t    return t1;\n-\t}\n-\n-      /* If this is a comparison of complex values and either or both sides\n-\t are a COMPLEX_EXPR or COMPLEX_CST, it is best to split up the\n-\t comparisons and join them with a TRUTH_ANDIF_EXPR or TRUTH_ORIF_EXPR.\n-\t This may prevent needless evaluations.  */\n-      if ((code == EQ_EXPR || code == NE_EXPR)\n-\t  && TREE_CODE (TREE_TYPE (arg0)) == COMPLEX_TYPE\n-\t  && (TREE_CODE (arg0) == COMPLEX_EXPR\n-\t      || TREE_CODE (arg1) == COMPLEX_EXPR\n-\t      || TREE_CODE (arg0) == COMPLEX_CST\n-\t      || TREE_CODE (arg1) == COMPLEX_CST))\n-\t{\n-\t  tree subtype = TREE_TYPE (TREE_TYPE (arg0));\n-\t  tree real0, imag0, real1, imag1;\n-\n-\t  arg0 = save_expr (arg0);\n-\t  arg1 = save_expr (arg1);\n-\t  real0 = fold (build1 (REALPART_EXPR, subtype, arg0));\n-\t  imag0 = fold (build1 (IMAGPART_EXPR, subtype, arg0));\n-\t  real1 = fold (build1 (REALPART_EXPR, subtype, arg1));\n-\t  imag1 = fold (build1 (IMAGPART_EXPR, subtype, arg1));\n-\n-\t  return fold (build2 ((code == EQ_EXPR ? TRUTH_ANDIF_EXPR\n-\t\t\t\t: TRUTH_ORIF_EXPR),\n-\t\t\t       type,\n-\t\t\t       fold (build2 (code, type, real0, real1)),\n-\t\t\t       fold (build2 (code, type, imag0, imag1))));\n-\t}\n-\n-      /* Optimize comparisons of strlen vs zero to a compare of the\n-\t first character of the string vs zero.  To wit,\n-\t\tstrlen(ptr) == 0   =>  *ptr == 0\n-\t\tstrlen(ptr) != 0   =>  *ptr != 0\n-\t Other cases should reduce to one of these two (or a constant)\n-\t due to the return value of strlen being unsigned.  */\n-      if ((code == EQ_EXPR || code == NE_EXPR)\n-\t  && integer_zerop (arg1)\n-\t  && TREE_CODE (arg0) == CALL_EXPR)\n-\t{\n-\t  tree fndecl = get_callee_fndecl (arg0);\n-\t  tree arglist;\n-\n-\t  if (fndecl\n-\t      && DECL_BUILT_IN_CLASS (fndecl) == BUILT_IN_NORMAL\n-\t      && DECL_FUNCTION_CODE (fndecl) == BUILT_IN_STRLEN\n-\t      && (arglist = TREE_OPERAND (arg0, 1))\n-\t      && TREE_CODE (TREE_TYPE (TREE_VALUE (arglist))) == POINTER_TYPE\n-\t      && ! TREE_CHAIN (arglist))\n-\t    return fold (build2 (code, type,\n-\t\t\t\t build1 (INDIRECT_REF, char_type_node,\n-\t\t\t\t\t TREE_VALUE (arglist)),\n-\t\t\t\t fold_convert (char_type_node,\n-\t\t\t\t\t       integer_zero_node)));\n-\t}\n-\n-      /* We can fold X/C1 op C2 where C1 and C2 are integer constants\n-\t into a single range test.  */\n-      if ((TREE_CODE (arg0) == TRUNC_DIV_EXPR\n-\t   || TREE_CODE (arg0) == EXACT_DIV_EXPR)\n-\t  && TREE_CODE (arg1) == INTEGER_CST\n-\t  && TREE_CODE (TREE_OPERAND (arg0, 1)) == INTEGER_CST\n-\t  && !integer_zerop (TREE_OPERAND (arg0, 1))\n-\t  && !TREE_OVERFLOW (TREE_OPERAND (arg0, 1))\n-\t  && !TREE_OVERFLOW (arg1))\n-\t{\n-\t  t1 = fold_div_compare (code, type, arg0, arg1);\n-\t  if (t1 != NULL_TREE)\n-\t    return t1;\n-\t}\n-\n-      if ((code == EQ_EXPR || code == NE_EXPR)\n-\t  && !TREE_SIDE_EFFECTS (arg0)\n-\t  && integer_zerop (arg1)\n-\t  && tree_expr_nonzero_p (arg0))\n-\treturn constant_boolean_node (code==NE_EXPR, type);\n-\n-      t1 = fold_relational_const (code, type, arg0, arg1);\n-      return t1 == NULL_TREE ? t : t1;\n-\n-    case UNORDERED_EXPR:\n-    case ORDERED_EXPR:\n-    case UNLT_EXPR:\n-    case UNLE_EXPR:\n-    case UNGT_EXPR:\n-    case UNGE_EXPR:\n-    case UNEQ_EXPR:\n-    case LTGT_EXPR:\n-      if (TREE_CODE (arg0) == REAL_CST && TREE_CODE (arg1) == REAL_CST)\n-\t{\n-\t  t1 = fold_relational_const (code, type, arg0, arg1);\n-\t  if (t1 != NULL_TREE)\n-\t    return t1;\n-\t}\n-\n-      /* If the first operand is NaN, the result is constant.  */\n-      if (TREE_CODE (arg0) == REAL_CST\n-\t  && REAL_VALUE_ISNAN (TREE_REAL_CST (arg0))\n-\t  && (code != LTGT_EXPR || ! flag_trapping_math))\n-\t{\n-\t  t1 = (code == ORDERED_EXPR || code == LTGT_EXPR)\n-\t       ? integer_zero_node\n-\t       : integer_one_node;\n-\t  return omit_one_operand (type, t1, arg1);\n-\t}\n-\n-      /* If the second operand is NaN, the result is constant.  */\n-      if (TREE_CODE (arg1) == REAL_CST\n-\t  && REAL_VALUE_ISNAN (TREE_REAL_CST (arg1))\n-\t  && (code != LTGT_EXPR || ! flag_trapping_math))\n-\t{\n-\t  t1 = (code == ORDERED_EXPR || code == LTGT_EXPR)\n-\t       ? integer_zero_node\n-\t       : integer_one_node;\n-\t  return omit_one_operand (type, t1, arg0);\n-\t}\n-\n-      /* Simplify unordered comparison of something with itself.  */\n-      if ((code == UNLE_EXPR || code == UNGE_EXPR || code == UNEQ_EXPR)\n-\t  && operand_equal_p (arg0, arg1, 0))\n-\treturn constant_boolean_node (1, type);\n-\n-      if (code == LTGT_EXPR\n-\t  && !flag_trapping_math\n-\t  && operand_equal_p (arg0, arg1, 0))\n-\treturn constant_boolean_node (0, type);\n-\n-      /* Fold (double)float1 CMP (double)float2 into float1 CMP float2.  */\n-      {\n-\ttree targ0 = strip_float_extensions (arg0);\n-\ttree targ1 = strip_float_extensions (arg1);\n-\ttree newtype = TREE_TYPE (targ0);\n-\n-\tif (TYPE_PRECISION (TREE_TYPE (targ1)) > TYPE_PRECISION (newtype))\n-\t  newtype = TREE_TYPE (targ1);\n-\n-\tif (TYPE_PRECISION (newtype) < TYPE_PRECISION (TREE_TYPE (arg0)))\n-\t  return fold (build2 (code, type, fold_convert (newtype, targ0),\n-\t\t\t       fold_convert (newtype, targ1)));\n-      }\n-\n-      return t;\n-\n-    case COMPOUND_EXPR:\n-      /* When pedantic, a compound expression can be neither an lvalue\n-\t nor an integer constant expression.  */\n-      if (TREE_SIDE_EFFECTS (arg0) || TREE_CONSTANT (arg1))\n-\treturn t;\n-      /* Don't let (0, 0) be null pointer constant.  */\n-      tem = integer_zerop (arg1) ? build1 (NOP_EXPR, type, arg1)\n-\t\t\t\t : fold_convert (type, arg1);\n-      return pedantic_non_lvalue (tem);\n-\n-    case COMPLEX_EXPR:\n-      if (wins)\n-\treturn build_complex (type, arg0, arg1);\n-      return t;\n-\n     default:\n       return t;\n     } /* switch (code) */"}]}