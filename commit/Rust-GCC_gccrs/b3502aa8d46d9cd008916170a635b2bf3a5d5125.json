{"sha": "b3502aa8d46d9cd008916170a635b2bf3a5d5125", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjM1MDJhYThkNDZkOWNkMDA4OTE2MTcwYTYzNWIyYmYzYTVkNTEyNQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2007-02-22T16:04:55Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2007-02-22T16:04:55Z"}, "message": "re PR libgcj/17002 (java.util.TimeZone.getDefault() is broken)\n\nlibjava/\n\tPR libgcj/17002\n\tPR classpath/28550\n\t* java/util/VMTimeZone.java (getDefaultTimeZoneId): To read\n\t/etc/localtime, use ZoneInfo.readTZFile instead of\n\tVMTimeZone.readtzFile.  Get better timezone name for /etc/localtime,\n\teither if it is a symlink or through /etc/sysconfig/clock.\n\t(readSysconfigClockFile): New static method.\n\t(readtzFile): Removed.\n\t* java/lang/System.java: Add gnu.java.util.zoneinfo.dir to comments.\n\t* posix.cc (_Jv_platform_initProperties): Set\n\tgnu.java.util.zoneinfo.dir.\n\t* sources.am (gnu_java_util_source_files): Add\n\tclasspath/gnu/java/util/ZoneInfo.java.\n\t* Makefile.in: Regenerated.\n\t* java/util/VMTimeZone.h: Regenerated.\n\t* java/util/TimeZone.h: Regenerated.\n\t* gnu/java/util/ZoneInfo.h: Generated.\nlibjava/classpath/\n\t* java/util/Date.java (parse): Properly parse 09:01:02 as\n\thours/minutes/seconds, not as hours/minutes/year.\n\t* java/util/SimpleTimeZone.java (SimpleTimeZone): Simplify\n\t{start,end}TimeMode constructor by calling shorter constructor,\n\tset {start,end}TimeMode fields after it returns.\n\t(setStartRule): Don't adjust startTime into WALL_TIME.  Set\n\tstartTimeMode to WALL_TIME.\n\t(endStartRule): Similarly.\n\t(getOffset): Handle properly millis + dstOffset overflowing into the\n\tnext day.  Adjust startTime resp. endTime based on startTimeMode\n\tresp. endTimeMode.\n\t* java/util/TimeZone.java (zoneinfo_dir, availableIDs, aliases0): New\n\tstatic fields.\n\t(timezones): Remove synchronized keyword.  Set zoneinfo_dir.\n\tIf non-null, set up aliases0 and don't put anything into\n\ttimezones0.\n\t(defaultZone): Call getTimeZone instead of timezones().get.\n\t(getDefaultTimeZone): Fix parsing of EST5 or EST5EDT6.  Use\n\tgetTimeZoneInternal instead of timezones().get.\n\t(parseTime): Parse correctly hour:minute.\n\t(getTimeZoneInternal): New private method.\n\t(getTimeZone): Do the custom ID checking first, canonicalize\n\tID for custom IDs as required by documentation.  Call\n\tgetTimeZoneInternal to handle the rest.\n\t(getAvailableIDs(int)): Add locking.  Handle zoneinfo_dir != null.\n\t(getAvailableIDs(File,String,ArrayList)): New private method.\n\t(getAvailableIDs()): Add locking.  Handle zoneinfo_dir != null.\n\t* gnu/java/util/ZoneInfo.java: New file.\n\nFrom-SVN: r122229", "tree": {"sha": "b6cca022867a508330c4917198eb1491fc030faa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b6cca022867a508330c4917198eb1491fc030faa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b3502aa8d46d9cd008916170a635b2bf3a5d5125", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3502aa8d46d9cd008916170a635b2bf3a5d5125", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b3502aa8d46d9cd008916170a635b2bf3a5d5125", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3502aa8d46d9cd008916170a635b2bf3a5d5125/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0c5c188f0759e74255b4792d141d97926e6dc4a1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c5c188f0759e74255b4792d141d97926e6dc4a1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0c5c188f0759e74255b4792d141d97926e6dc4a1"}], "stats": {"total": 2309, "additions": 1702, "deletions": 607}, "files": [{"sha": "eaea0ecaef3bac0b163ebd4c8b38ca317351ea10", "filename": "libjava/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3502aa8d46d9cd008916170a635b2bf3a5d5125/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3502aa8d46d9cd008916170a635b2bf3a5d5125/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=b3502aa8d46d9cd008916170a635b2bf3a5d5125", "patch": "@@ -1,3 +1,23 @@\n+2007-02-22  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR libgcj/17002\n+\tPR classpath/28550\n+\t* java/util/VMTimeZone.java (getDefaultTimeZoneId): To read\n+\t/etc/localtime, use ZoneInfo.readTZFile instead of\n+\tVMTimeZone.readtzFile.  Get better timezone name for /etc/localtime,\n+\teither if it is a symlink or through /etc/sysconfig/clock.\n+\t(readSysconfigClockFile): New static method.\n+\t(readtzFile): Removed.\n+\t* java/lang/System.java: Add gnu.java.util.zoneinfo.dir to comments.\n+\t* posix.cc (_Jv_platform_initProperties): Set\n+\tgnu.java.util.zoneinfo.dir.\n+\t* sources.am (gnu_java_util_source_files): Add\n+\tclasspath/gnu/java/util/ZoneInfo.java.\n+\t* Makefile.in: Regenerated.\n+\t* java/util/VMTimeZone.h: Regenerated.\n+\t* java/util/TimeZone.h: Regenerated.\n+\t* gnu/java/util/ZoneInfo.h: Generated.\n+\n 2007-02-22  Mohan Embar  <gnustuff@thisiscool.com>\n \n \t* include/win32-threads.h: Added #undef OUT."}, {"sha": "27aa9ae9e696d2ab6de77b4db3ce9bd8e0916c63", "filename": "libjava/Makefile.in", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3502aa8d46d9cd008916170a635b2bf3a5d5125/libjava%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3502aa8d46d9cd008916170a635b2bf3a5d5125/libjava%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.in?ref=b3502aa8d46d9cd008916170a635b2bf3a5d5125", "patch": "@@ -2402,7 +2402,8 @@ gnu_java_text_header_files = $(patsubst classpath/%,%,$(patsubst %.java,%.h,$(gn\n gnu_java_util_source_files = \\\n classpath/gnu/java/util/DoubleEnumeration.java \\\n classpath/gnu/java/util/EmptyEnumeration.java \\\n-classpath/gnu/java/util/WeakIdentityHashMap.java\n+classpath/gnu/java/util/WeakIdentityHashMap.java \\\n+classpath/gnu/java/util/ZoneInfo.java\n \n gnu_java_util_header_files = $(patsubst classpath/%,%,$(patsubst %.java,%.h,$(gnu_java_util_source_files)))\n gnu_java_util_jar_source_files = \\"}, {"sha": "fa92bda1bb076e8ece3337b29140c4ad9badd34b", "filename": "libjava/classpath/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3502aa8d46d9cd008916170a635b2bf3a5d5125/libjava%2Fclasspath%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3502aa8d46d9cd008916170a635b2bf3a5d5125/libjava%2Fclasspath%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2FChangeLog?ref=b3502aa8d46d9cd008916170a635b2bf3a5d5125", "patch": "@@ -1,3 +1,34 @@\n+2007-02-20  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* java/util/Date.java (parse): Properly parse 09:01:02 as\n+\thours/minutes/seconds, not as hours/minutes/year.\n+\t* java/util/SimpleTimeZone.java (SimpleTimeZone): Simplify\n+\t{start,end}TimeMode constructor by calling shorter constructor,\n+\tset {start,end}TimeMode fields after it returns.\n+\t(setStartRule): Don't adjust startTime into WALL_TIME.  Set\n+\tstartTimeMode to WALL_TIME.\n+\t(endStartRule): Similarly.\n+\t(getOffset): Handle properly millis + dstOffset overflowing into the\n+\tnext day.  Adjust startTime resp. endTime based on startTimeMode\n+\tresp. endTimeMode.\n+\t* java/util/TimeZone.java (zoneinfo_dir, availableIDs, aliases0): New\n+\tstatic fields.\n+\t(timezones): Remove synchronized keyword.  Set zoneinfo_dir.\n+\tIf non-null, set up aliases0 and don't put anything into\n+\ttimezones0.\n+\t(defaultZone): Call getTimeZone instead of timezones().get.\n+\t(getDefaultTimeZone): Fix parsing of EST5 or EST5EDT6.  Use\n+\tgetTimeZoneInternal instead of timezones().get.\n+\t(parseTime): Parse correctly hour:minute.\n+\t(getTimeZoneInternal): New private method.\n+\t(getTimeZone): Do the custom ID checking first, canonicalize\n+\tID for custom IDs as required by documentation.  Call\n+\tgetTimeZoneInternal to handle the rest.\n+\t(getAvailableIDs(int)): Add locking.  Handle zoneinfo_dir != null.\n+\t(getAvailableIDs(File,String,ArrayList)): New private method.\n+\t(getAvailableIDs()): Add locking.  Handle zoneinfo_dir != null.\n+\t* gnu/java/util/ZoneInfo.java: New file.\n+\n 2007-02-20  Matthias Klose  <doko@ubuntu.com>\n \n \t* doc/Makefile.am: Add rules to build and install man pages"}, {"sha": "2146a321f404acd61196c70aaec66f5f780173b6", "filename": "libjava/classpath/gnu/java/util/ZoneInfo.java", "status": "added", "additions": 1160, "deletions": 0, "changes": 1160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3502aa8d46d9cd008916170a635b2bf3a5d5125/libjava%2Fclasspath%2Fgnu%2Fjava%2Futil%2FZoneInfo.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3502aa8d46d9cd008916170a635b2bf3a5d5125/libjava%2Fclasspath%2Fgnu%2Fjava%2Futil%2FZoneInfo.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fgnu%2Fjava%2Futil%2FZoneInfo.java?ref=b3502aa8d46d9cd008916170a635b2bf3a5d5125", "patch": "@@ -0,0 +1,1160 @@\n+/* gnu.java.util.ZoneInfo\n+   Copyright (C) 2007 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n+02110-1301 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.java.util;\n+\n+import java.io.BufferedInputStream;\n+import java.io.DataInputStream;\n+import java.io.EOFException;\n+import java.io.FileInputStream;\n+import java.io.InputStream;\n+import java.io.IOException;\n+import java.util.Calendar;\n+import java.util.Date;\n+import java.util.GregorianCalendar;\n+import java.util.SimpleTimeZone;\n+import java.util.TimeZone;\n+\n+/**\n+ * This class represents more advanced variant of java.util.SimpleTimeZone.\n+ * It can handle zic(8) compiled transition dates plus uses a SimpleTimeZone\n+ * for years beyond last precomputed transition.  Before first precomputed\n+ * transition it assumes no daylight saving was in effect.\n+ * Timezones that never used daylight saving time should use just\n+ * SimpleTimeZone instead of this class.\n+ *\n+ * This object is tightly bound to the Gregorian calendar.  It assumes\n+ * a regular seven days week, and the month lengths are that of the\n+ * Gregorian Calendar.\n+ *\n+ * @see Calendar\n+ * @see GregorianCalendar\n+ * @see SimpleTimeZone\n+ * @author Jakub Jelinek\n+ */\n+public class ZoneInfo extends TimeZone\n+{\n+  private static final int SECS_SHIFT = 22;\n+  private static final long OFFSET_MASK = (1 << 21) - 1;\n+  private static final int OFFSET_SHIFT = 64 - 21;\n+  private static final long IS_DST = 1 << 21;\n+\n+  /**\n+   * The raw time zone offset in milliseconds to GMT, ignoring\n+   * daylight savings.\n+   * @serial\n+   */\n+  private int rawOffset;\n+\n+  /**\n+   * Cached DST savings for the last transition rule.\n+   */\n+  private int dstSavings;\n+\n+  /**\n+   * Cached flag whether last transition rule uses DST saving.\n+   */\n+  private boolean useDaylight;\n+\n+  /**\n+   * Array of encoded transitions.\n+   * Transition time in UTC seconds since epoch is in the most\n+   * significant 64 - SECS_SHIFT bits, then one bit flag\n+   * whether DST is active and the least significant bits\n+   * containing offset relative to rawOffset.  Both the DST\n+   * flag and relative offset apply to time before the transition\n+   * and after or equal to previous transition if any.\n+   * The array must be sorted.\n+   */\n+  private long[] transitions;\n+\n+  /**\n+   * SimpleTimeZone rule which applies on or after the latest\n+   * transition.  If the DST changes are not expresible as a\n+   * SimpleTimeZone rule, then the rule should just contain\n+   * the standard time and no DST time.\n+   */\n+  private SimpleTimeZone lastRule;\n+\n+  /**\n+   * Cached GMT SimpleTimeZone object for internal use in\n+   * getOffset method.\n+   */\n+  private static SimpleTimeZone gmtZone = null;\n+\n+  static final long serialVersionUID = -3740626706860383657L;\n+\n+  /**\n+   * Create a <code>ZoneInfo</code> with the given time offset\n+   * from GMT and with daylight savings.\n+   *\n+   * @param rawOffset The time offset from GMT in milliseconds.\n+   * @param id  The identifier of this time zone.\n+   * @param transitions  Array of transition times in UTC seconds since\n+   * Epoch in topmost 42 bits, below that 1 boolean bit whether the time\n+   * before that transition used daylight saving and in bottommost 21\n+   * bits relative daylight saving offset against rawOffset in seconds\n+   * that applies before this transition.\n+   * @param endRule SimpleTimeZone class describing the daylight saving\n+   * rules after the last transition.\n+   */\n+  public ZoneInfo(int rawOffset, String id, long[] transitions,\n+\t\t  SimpleTimeZone lastRule)\n+  {\n+    if (transitions == null || transitions.length < 1)\n+      throw new IllegalArgumentException(\"transitions must not be null\");\n+    if (lastRule == null)\n+      throw new IllegalArgumentException(\"lastRule must not be null\");\n+    this.rawOffset = rawOffset;\n+    this.transitions = transitions;\n+    this.lastRule = lastRule;\n+    setID(id);\n+    computeDSTSavings();\n+  }\n+\n+  /**\n+   * Gets the time zone offset, for current date, modified in case of\n+   * daylight savings.  This is the offset to add to UTC to get the local\n+   * time.\n+   *\n+   * The day must be a positive number and dayOfWeek must be a positive value\n+   * from Calendar.  dayOfWeek is redundant, but must match the other values\n+   * or an inaccurate result may be returned.\n+   *\n+   * @param era the era of the given date\n+   * @param year the year of the given date\n+   * @param month the month of the given date, 0 for January.\n+   * @param day the day of month\n+   * @param dayOfWeek the day of week; this must match the other fields.\n+   * @param millis the millis in the day (in local standard time)\n+   * @return the time zone offset in milliseconds.\n+   * @throws IllegalArgumentException if arguments are incorrect.\n+   */\n+  public int getOffset(int era, int year, int month, int day, int dayOfWeek,\n+\t\t       int millis)\n+  {\n+    if (gmtZone == null)\n+      gmtZone = new SimpleTimeZone(0, \"GMT\");\n+\n+    if (dayOfWeek < Calendar.SUNDAY || dayOfWeek > Calendar.SATURDAY)\n+      throw new IllegalArgumentException(\"dayOfWeek out of range\");\n+    if (month < Calendar.JANUARY || month > Calendar.DECEMBER)\n+      throw new IllegalArgumentException(\"month out of range:\" + month);\n+\n+    if (era != GregorianCalendar.AD)\n+      return (int) (((transitions[0] << OFFSET_SHIFT) >> OFFSET_SHIFT) * 1000);\n+\n+    GregorianCalendar cal = new GregorianCalendar((TimeZone) gmtZone);\n+    cal.set(year, month, day, 0, 0, 0);\n+    if (cal.get(Calendar.DAY_OF_MONTH) != day)\n+      throw new IllegalArgumentException(\"day out of range\");\n+\n+    return getOffset(cal.getTimeInMillis() - rawOffset + millis);\n+  }\n+\n+  private long findTransition(long secs)\n+  {\n+    if (secs < (transitions[0] >> SECS_SHIFT))\n+      return transitions[0];\n+\n+    if (secs >= (transitions[transitions.length-1] >> SECS_SHIFT))\n+      return Long.MAX_VALUE;\n+\n+    long val = (secs + 1) << SECS_SHIFT;\n+    int lo = 1;\n+    int hi = transitions.length;\n+    int mid = 1;\n+    while (lo < hi)\n+      {\n+\tmid = (lo + hi) / 2;\n+\t// secs < (transitions[mid-1] >> SECS_SHIFT)\n+\tif (val <= transitions[mid-1])\n+\t  hi = mid;\n+\t// secs >= (transitions[mid] >> SECS_SHIFT)\n+\telse if (val > transitions[mid])\n+\t  lo = mid + 1;\n+\telse\n+\t  break;\n+      }\n+    return transitions[mid];\n+  }\n+\n+  /**\n+   * Get the time zone offset for the specified date, modified in case of\n+   * daylight savings.  This is the offset to add to UTC to get the local\n+   * time.\n+   * @param date the date represented in millisecends\n+   * since January 1, 1970 00:00:00 GMT.\n+   */\n+  public int getOffset(long date)\n+  {\n+    long d = (date >= 0 ? date / 1000 : (date + 1) / 1000 - 1);\n+    long transition = findTransition(d);\n+\n+    // For times on or after last transition use lastRule.\n+    if (transition == Long.MAX_VALUE)\n+      return lastRule.getOffset(date);\n+\n+    return (int) (((transition << OFFSET_SHIFT) >> OFFSET_SHIFT) * 1000);\n+  }\n+\n+  /**\n+   * Returns the time zone offset to GMT in milliseconds, ignoring\n+   * day light savings.\n+   * @return the time zone offset.\n+   */\n+  public int getRawOffset()\n+  {\n+    return rawOffset;\n+  }\n+\n+  /**\n+   * Sets the standard time zone offset to GMT.\n+   * @param rawOffset The time offset from GMT in milliseconds.\n+   */\n+  public void setRawOffset(int rawOffset)\n+  {\n+    this.rawOffset = rawOffset;\n+    lastRule.setRawOffset(rawOffset);\n+  }\n+\n+  private void computeDSTSavings()\n+  {\n+    if (lastRule.useDaylightTime())\n+      {\n+\tdstSavings = lastRule.getDSTSavings();\n+\tuseDaylight = true;\n+      }\n+    else\n+      {\n+\tdstSavings = 0;\n+\tuseDaylight = false;\n+\t// lastRule might say no DST is in effect simply because\n+\t// the DST rules are too complex for SimpleTimeZone, say\n+\t// for Asia/Jerusalem.\n+\t// Look at the last DST offset if it is newer than current time.\n+\tlong currentSecs = System.currentTimeMillis() / 1000;\n+\tint i;\n+\tfor (i = transitions.length - 1;\n+\t     i >= 0 && currentSecs < (transitions[i] >> SECS_SHIFT);\n+\t     i--)\n+\t  if ((transitions[i] & IS_DST) != 0)\n+\t    {\n+\t      dstSavings = (int) (((transitions[i] << OFFSET_SHIFT)\n+\t\t\t\t   >> OFFSET_SHIFT) * 1000)\n+\t\t\t   - rawOffset;\n+\t      useDaylight = true;\n+\t      break;\n+\t    }\n+      }\n+  }\n+\n+  /**\n+   * Gets the daylight savings offset.  This is a positive offset in\n+   * milliseconds with respect to standard time.  Typically this\n+   * is one hour, but for some time zones this may be half an our.\n+   * @return the daylight savings offset in milliseconds.\n+   */\n+  public int getDSTSavings()\n+  {\n+    return dstSavings;\n+  }\n+\n+  /**\n+   * Returns if this time zone uses daylight savings time.\n+   * @return true, if we use daylight savings time, false otherwise.\n+   */\n+  public boolean useDaylightTime()\n+  {\n+    return useDaylight;\n+  }\n+\n+  /**\n+   * Determines if the given date is in daylight savings time.\n+   * @return true, if it is in daylight savings time, false otherwise.\n+   */\n+  public boolean inDaylightTime(Date date)\n+  {\n+    long d = date.getTime();\n+    d = (d >= 0 ? d / 1000 : (d + 1) / 1000 - 1);\n+    long transition = findTransition(d);\n+\n+    // For times on or after last transition use lastRule.\n+    if (transition == Long.MAX_VALUE)\n+      return lastRule.inDaylightTime(date);\n+\n+    return (transition & IS_DST) != 0;\n+  }\n+\n+  /**\n+   * Generates the hashCode for the SimpleDateFormat object.  It is\n+   * the rawOffset, possibly, if useDaylightSavings is true, xored\n+   * with startYear, startMonth, startDayOfWeekInMonth, ..., endTime.\n+   */\n+  public synchronized int hashCode()\n+  {\n+    int hash = lastRule.hashCode();\n+    // FIXME - hash transitions?\n+    return hash;\n+  }\n+\n+  public synchronized boolean equals(Object o)\n+  {\n+    if (! hasSameRules((TimeZone) o))\n+      return false;\n+\n+    ZoneInfo zone = (ZoneInfo) o;\n+    return getID().equals(zone.getID());\n+  }\n+\n+  /**\n+   * Test if the other time zone uses the same rule and only\n+   * possibly differs in ID.  This implementation for this particular\n+   * class will return true if the other object is a ZoneInfo,\n+   * the raw offsets and useDaylight are identical and if useDaylight\n+   * is true, also the start and end datas are identical.\n+   * @return true if this zone uses the same rule.\n+   */\n+  public boolean hasSameRules(TimeZone o)\n+  {\n+    if (this == o)\n+      return true;\n+    if (! (o instanceof ZoneInfo))\n+      return false;\n+    ZoneInfo zone = (ZoneInfo) o;\n+    if (zone.hashCode() != hashCode() || rawOffset != zone.rawOffset)\n+      return false;\n+    if (! lastRule.equals(zone.lastRule))\n+      return false;\n+    // FIXME - compare transitions?\n+    return true;\n+  }\n+\n+  /**\n+   * Returns a string representation of this ZoneInfo object.\n+   * @return a string representation of this ZoneInfo object.\n+   */\n+  public String toString()\n+  {\n+    return getClass().getName() + \"[\" + \"id=\" + getID() + \",offset=\"\n+\t   + rawOffset + \",transitions=\" + transitions.length\n+\t   + \",useDaylight=\" + useDaylight\n+\t   + (useDaylight ? (\",dstSavings=\" + dstSavings) : \"\")\n+\t   + \",lastRule=\" + lastRule.toString() + \"]\";\n+  }\n+\n+  /**\n+   * Reads zic(8) compiled timezone data file from file\n+   * and returns a TimeZone class describing it, either\n+   * SimpleTimeZone or ZoneInfo depending on whether\n+   * it can be described by SimpleTimeZone rule or not.\n+   */\n+  public static TimeZone readTZFile(String id, String file)\n+  {\n+    DataInputStream dis = null;\n+    try\n+      {\n+\tFileInputStream fis = new FileInputStream(file);\n+\tBufferedInputStream bis = new BufferedInputStream(fis);\n+\tdis = new DataInputStream(bis);\n+\n+\t// Make sure we are reading a tzfile.\n+\tbyte[] tzif = new byte[5];\n+\tdis.readFully(tzif);\n+\tint tzif2 = 4;\n+\tif (tzif[0] == 'T' && tzif[1] == 'Z'\n+\t    && tzif[2] == 'i' && tzif[3] == 'f')\n+\t  {\n+\t    if (tzif[4] >= '2')\n+\t      tzif2 = 8;\n+\t    // Reserved bytes\n+\t    skipFully(dis, 16 - 1);\n+\t  }\n+\telse\n+\t  // Darwin has tzdata files that don't start with the TZif marker\n+\t  skipFully(dis, 16 - 5);\n+\n+\tint ttisgmtcnt = dis.readInt();\n+\tint ttisstdcnt = dis.readInt();\n+\tint leapcnt = dis.readInt();\n+\tint timecnt = dis.readInt();\n+\tint typecnt = dis.readInt();\n+\tint charcnt = dis.readInt();\n+\tif (tzif2 == 8)\n+\t  {\n+\t    skipFully(dis, timecnt * (4 + 1) + typecnt * (4 + 1 + 1) + charcnt\n+\t\t\t   + leapcnt * (4 + 4) + ttisgmtcnt + ttisstdcnt);\n+\n+\t    dis.readFully(tzif);\n+\t    if (tzif[0] != 'T' || tzif[1] != 'Z' || tzif[2] != 'i'\n+\t\t|| tzif[3] != 'f' || tzif[4] < '2')\n+\t      return null;\n+\n+\t    // Reserved bytes\n+\t    skipFully(dis, 16 - 1);\n+\t    ttisgmtcnt = dis.readInt();\n+\t    ttisstdcnt = dis.readInt();\n+\t    leapcnt = dis.readInt();\n+\t    timecnt = dis.readInt();\n+\t    typecnt = dis.readInt();\n+\t    charcnt = dis.readInt();\n+\t  }\n+\n+\t// Sanity checks\n+\tif (typecnt <= 0 || timecnt < 0 || charcnt < 0\n+\t    || leapcnt < 0 || ttisgmtcnt < 0 || ttisstdcnt < 0\n+\t    || ttisgmtcnt > typecnt || ttisstdcnt > typecnt)\n+\t  return null;\n+\n+\t// Transition times\n+\tlong[] times = new long[timecnt];\n+\tfor (int i = 0; i < timecnt; i++)\n+\t  if (tzif2 == 8)\n+\t    times[i] = dis.readLong();\n+\t  else\n+\t    times[i] = (long) dis.readInt();\n+\n+\t// Transition types\n+\tint[] types = new int[timecnt];\n+\tfor (int i = 0; i < timecnt; i++)\n+\t  {\n+\t    types[i] = dis.readByte();\n+\t    if (types[i] < 0)\n+\t      types[i] += 256;\n+\t    if (types[i] >= typecnt)\n+\t      return null;\n+\t  }\n+\n+\t// Types\n+\tint[] offsets = new int[typecnt];\n+\tint[] typeflags = new int[typecnt];\n+\tfor (int i = 0; i < typecnt; i++)\n+\t  {\n+\t    offsets[i] = dis.readInt();\n+\t    if (offsets[i] >= IS_DST / 2 || offsets[i] <= -IS_DST / 2)\n+\t      return null;\n+\t    int dst = dis.readByte();\n+\t    int abbrind = dis.readByte();\n+\t    if (abbrind < 0)\n+\t      abbrind += 256;\n+\t    if (abbrind >= charcnt)\n+\t      return null;\n+\t    typeflags[i] = (dst != 0 ? (1 << 8) : 0) + abbrind;\n+\t  }\n+\n+\t// Abbrev names\n+\tbyte[] names = new byte[charcnt];\n+\tdis.readFully(names);\n+\n+\t// Leap transitions, for now ignore\n+\tskipFully(dis, leapcnt * (tzif2 + 4) + ttisstdcnt + ttisgmtcnt);\n+\n+\t// tzIf2 format has optional POSIX TZ env string\n+\tString tzstr = null;\n+\tif (tzif2 == 8 && dis.readByte() == '\\n')\n+\t  {\n+\t    tzstr = dis.readLine();\n+\t    if (tzstr.length() <= 0)\n+\t      tzstr = null;\n+\t  }\n+\n+\t// Get std/dst_offset and dst/non-dst time zone names.\n+\tint std_ind = -1;\n+\tint dst_ind = -1;\n+\tif (timecnt == 0)\n+\t  std_ind = 0;\n+\telse\n+\t  for (int i = timecnt - 1; i >= 0; i--)\n+\t    {\n+\t      if (std_ind == -1 && (typeflags[types[i]] & (1 << 8)) == 0)\n+\t\tstd_ind = types[i];\n+\t      else if (dst_ind == -1 && (typeflags[types[i]] & (1 << 8)) != 0)\n+\t\tdst_ind = types[i];\n+\t      if (dst_ind != -1 && std_ind != -1)\n+\t\tbreak;\n+\t    }\n+\n+\tif (std_ind == -1)\n+\t  return null;\n+\n+\tint j = typeflags[std_ind] & 255;\n+\twhile (j < charcnt && names[j] != 0)\n+\t  j++;\n+\tString std_zonename = new String(names, typeflags[std_ind] & 255,\n+\t\t\t\t\t j - (typeflags[std_ind] & 255),\n+\t\t\t\t\t \"ASCII\");\n+\n+\tString dst_zonename = \"\";\n+\tif (dst_ind != -1)\n+\t  {\n+\t    j = typeflags[dst_ind] & 255;\n+\t    while (j < charcnt && names[j] != 0)\n+\t      j++;\n+\t    dst_zonename = new String(names, typeflags[dst_ind] & 255,\n+\t\t\t\t      j - (typeflags[dst_ind] & 255), \"ASCII\");\n+\t  }\n+\n+\t// Only use gmt offset when necessary.\n+\t// Also special case GMT+/- timezones.\n+\tString std_offset_string = \"\";\n+\tString dst_offset_string = \"\";\n+\tif (tzstr == null\n+\t    && (dst_ind != -1\n+\t\t|| (offsets[std_ind] != 0\n+\t\t    && !std_zonename.startsWith(\"GMT+\")\n+\t\t    && !std_zonename.startsWith(\"GMT-\"))))\n+\t  {\n+\t    std_offset_string = Integer.toString(-offsets[std_ind] / 3600);\n+\t    int seconds = -offsets[std_ind] % 3600;\n+\t    if (seconds != 0)\n+\t      {\n+\t\tif (seconds < 0)\n+\t\t  seconds *= -1;\n+\t\tif (seconds < 600)\n+\t\t  std_offset_string += \":0\" + Integer.toString(seconds / 60);\n+\t\telse\n+\t\t  std_offset_string += \":\" + Integer.toString(seconds / 60);\n+\t\tseconds = seconds % 60;\n+\t\tif (seconds >= 10)\n+\t\t  std_offset_string += \":\" + Integer.toString(seconds);\n+\t\telse if (seconds > 0)\n+\t\t  std_offset_string += \":0\" + Integer.toString(seconds);\n+\t      }\n+\n+\t    if (dst_ind != -1 && offsets[dst_ind] != offsets[std_ind] + 3600)\n+\t      {\n+\t\tdst_offset_string = Integer.toString(-offsets[dst_ind] / 3600);\n+\t\tseconds = -offsets[dst_ind] % 3600;\n+\t\tif (seconds != 0)\n+\t\t  {\n+\t\t    if (seconds < 0)\n+\t\t      seconds *= -1;\n+\t\t    if (seconds < 600)\n+\t\t      dst_offset_string\n+\t\t\t+= \":0\" + Integer.toString(seconds / 60);\n+\t\t    else\n+\t\t      dst_offset_string\n+\t\t\t+= \":\" + Integer.toString(seconds / 60);\n+\t\t    seconds = seconds % 60;\n+\t\t    if (seconds >= 10)\n+\t\t      dst_offset_string += \":\" + Integer.toString(seconds);\n+\t\t    else if (seconds > 0)\n+\t\t      dst_offset_string += \":0\" + Integer.toString(seconds);\n+\t\t  }\n+\t      }\n+\t  }\n+\n+\t/*\n+\t * If no tzIf2 POSIX TZ string is available and the timezone\n+\t * uses DST, try to guess the last rule by trying to make\n+\t * sense from transitions at 5 years in the future and onwards.\n+\t * tzdata actually uses only 3 forms of rules:\n+\t * fixed date within a month, e.g. change on April, 5th\n+\t * 1st weekday on or after Nth: change on Sun>=15 in April\n+\t * last weekday in a month: change on lastSun in April\n+\t */\n+\tString[] change_spec = { null, null };\n+\tif (tzstr == null && dst_ind != -1 && timecnt > 10)\n+\t  {\n+\t    long nowPlus5y = System.currentTimeMillis() / 1000\n+\t\t\t     + 5 * 365 * 86400;\n+\t    int first;\n+\n+\t    for (first = timecnt - 1; first >= 0; first--)\n+\t      if (times[first] < nowPlus5y\n+\t\t  || (types[first] != std_ind && types[first] != dst_ind)\n+\t\t  || types[first] != types[timecnt - 2 + ((first ^ timecnt) & 1)])\n+\t\tbreak;\n+\t    first++;\n+\n+\t    if (timecnt - first >= 10 && types[timecnt - 1] != types[timecnt - 2])\n+\t      {\n+\t\tGregorianCalendar cal\n+\t\t  = new GregorianCalendar(new SimpleTimeZone(0, \"GMT\"));\n+\n+\t\tint[] values = new int[2 * 11];\n+\t\tint i;\n+\t\tfor (i = timecnt - 1; i >= first; i--)\n+\t\t  {\n+\t\t    int base = (i % 2) * 11;\n+\t\t    int offset = offsets[types[i > first ? i - 1 : i + 1]];\n+\t\t    cal.setTimeInMillis((times[i] + offset) * 1000);\n+\t\t    if (i >= timecnt - 2)\n+\t\t      {\n+\t\t\tvalues[base + 0] = cal.get(Calendar.YEAR);\n+\t\t\tvalues[base + 1] = cal.get(Calendar.MONTH);\n+\t\t\tvalues[base + 2] = cal.get(Calendar.DAY_OF_MONTH);\n+\t\t\tvalues[base + 3]\n+\t\t\t  = cal.getActualMaximum(Calendar.DAY_OF_MONTH);\n+\t\t\tvalues[base + 4] = cal.get(Calendar.DAY_OF_WEEK);\n+\t\t\tvalues[base + 5] = cal.get(Calendar.HOUR_OF_DAY);\n+\t\t\tvalues[base + 6] = cal.get(Calendar.MINUTE);\n+\t\t\tvalues[base + 7] = cal.get(Calendar.SECOND);\n+\t\t\tvalues[base + 8] = values[base + 2]; // Range start\n+\t\t\tvalues[base + 9] = values[base + 2]; // Range end\n+\t\t\tvalues[base + 10] = 0; // Determined type\n+\t\t      }\n+\t\t    else\n+\t\t      {\n+\t\t\tint year = cal.get(Calendar.YEAR);\n+\t\t\tint month = cal.get(Calendar.MONTH);\n+\t\t\tint day_of_month = cal.get(Calendar.DAY_OF_MONTH);\n+\t\t\tint month_days\n+\t\t\t  = cal.getActualMaximum(Calendar.DAY_OF_MONTH);\n+\t\t\tint day_of_week = cal.get(Calendar.DAY_OF_WEEK);\n+\t\t\tint hour = cal.get(Calendar.HOUR_OF_DAY);\n+\t\t\tint minute = cal.get(Calendar.MINUTE);\n+\t\t\tint second = cal.get(Calendar.SECOND);\n+\t\t\tif (year != values[base + 0] - 1\n+\t\t\t    || month != values[base + 1]\n+\t\t\t    || hour != values[base + 5]\n+\t\t\t    || minute != values[base + 6]\n+\t\t\t    || second != values[base + 7])\n+\t\t\t  break;\n+\t\t\tif (day_of_week == values[base + 4])\n+\t\t\t  {\n+\t\t\t    // Either a Sun>=8 or lastSun rule.\n+\t\t\t    if (day_of_month < values[base + 8])\n+\t\t\t      values[base + 8] = day_of_month;\n+\t\t\t    if (day_of_month > values[base + 9])\n+\t\t\t      values[base + 9] = day_of_month;\n+\t\t\t    if (values[base + 10] < 0)\n+\t\t\t      break;\n+\t\t\t    if (values[base + 10] == 0)\n+\t\t\t      {\n+\t\t\t\tvalues[base + 10] = 1;\n+\t\t\t\t// If day of month > 28, this is\n+\t\t\t\t// certainly lastSun rule.\n+\t\t\t\tif (values[base + 2] > 28)\n+\t\t\t\t  values[base + 2] = 3;\n+\t\t\t\t// If day of month isn't in the last\n+\t\t\t\t// week, it can't be lastSun rule.\n+\t\t\t\telse if (values[base + 2]\n+\t\t\t\t\t <= values[base + 3] - 7)\n+\t\t\t\t  values[base + 3] = 2;\n+\t\t\t      }\n+\t\t\t    if (values[base + 10] == 1)\n+\t\t\t      {\n+\t\t\t\t// If day of month is > 28, this is\n+\t\t\t\t// certainly lastSun rule.\n+\t\t\t\tif (day_of_month > 28)\n+\t\t\t\t  values[base + 10] = 3;\n+\t\t\t\t// If day of month isn't in the last\n+\t\t\t\t// week, it can't be lastSun rule.\n+\t\t\t\telse if (day_of_month <= month_days - 7)\n+\t\t\t\t  values[base + 10] = 2;\n+\t\t\t      }\n+\t\t\t    else if ((values[base + 10] == 2\n+\t\t\t\t      && day_of_month > 28)\n+\t\t\t\t     || (values[base + 10] == 3\n+\t\t\t\t\t && day_of_month <= month_days - 7))\n+\t\t\t      break;\n+\t\t\t  }\n+\t\t\telse\n+\t\t\t  {\n+\t\t\t    // Must be fixed day in month rule.\n+\t\t\t    if (day_of_month != values[base + 2]\n+\t\t\t\t|| values[base + 10] > 0)\n+\t\t\t      break;\n+\t\t\t    values[base + 4] = day_of_week;\n+\t\t\t    values[base + 10] = -1;\n+\t\t\t  }\n+\t\t\tvalues[base + 0] -= 1;\n+\t\t      }\n+\t\t  }\n+\n+\t\tif (i < first)\n+\t\t  {\n+\t\t    for (i = 0; i < 2; i++)\n+\t\t      {\n+\t\t\tint base = 11 * i;\n+\t\t\tif (values[base + 10] == 0)\n+\t\t\t  continue;\n+\t\t\tif (values[base + 10] == -1)\n+\t\t\t  {\n+\t\t\t    int[] dayCount\n+\t\t\t      = { 0, 31, 59, 90, 120, 151,\n+\t\t\t\t  181, 212, 243, 273, 304, 334 };\n+\t\t\t    int d = dayCount[values[base + 1]\n+\t\t\t\t\t     - Calendar.JANUARY];\n+\t\t\t    d += values[base + 2];\n+\t\t\t    change_spec[i] = \",J\" + Integer.toString(d);\n+\t\t\t  }\n+\t\t\telse if (values[base + 10] == 2)\n+\t\t\t  {\n+\t\t\t    // If we haven't seen all days of the week,\n+\t\t\t    // we can't be sure what the rule really is.\n+\t\t\t    if (values[base + 8] + 6 != values[base + 9])\n+\t\t\t      continue;\n+\n+\t\t\t    int d;\n+\t\t\t    d = values[base + 1] - Calendar.JANUARY + 1;\n+\t\t\t    // E.g. Sun >= 5 is not representable in POSIX\n+\t\t\t    // TZ env string, use \",Am.n.d\" extension\n+\t\t\t    // where m is month 1 .. 12, n is the date on\n+\t\t\t    // or after which it happens and d is day\n+\t\t\t    // of the week, 0 .. 6.  So Sun >= 5 in April\n+\t\t\t    // is \",A4.5.0\".\n+\t\t\t    if ((values[base + 8] % 7) == 1)\n+\t\t\t      {\n+\t\t\t\tchange_spec[i] = \",M\" + Integer.toString(d);\n+\t\t\t\td = (values[base + 8] + 6) / 7;\n+\t\t\t      }\n+\t\t\t    else\n+\t\t\t      {\n+\t\t\t\tchange_spec[i] = \",A\" + Integer.toString(d);\n+\t\t\t\td = values[base + 8];\n+\t\t\t      }\n+\t\t\t    change_spec[i] += \".\" + Integer.toString(d);\n+\t\t\t    d = values[base + 4] - Calendar.SUNDAY;\n+\t\t\t    change_spec[i] += \".\" + Integer.toString(d);\n+\t\t\t  }\n+\t\t\telse\n+\t\t\t  {\n+\t\t\t    // If we don't know whether this is lastSun or\n+\t\t\t    // Sun >= 22 rule.  That can be either because\n+\t\t\t    // there was insufficient number of\n+\t\t\t    // transitions, or February, where it is quite\n+\t\t\t    // probable we haven't seen any 29th dates.\n+\t\t\t    // For February, assume lastSun rule, otherwise\n+\t\t\t    // punt.\n+\t\t\t    if (values[base + 10] == 1\n+\t\t\t\t&& values[base + 1] != Calendar.FEBRUARY)\n+\t\t\t      continue;\n+\n+\t\t\t    int d;\n+\t\t\t    d = values[base + 1] - Calendar.JANUARY + 1;\n+\t\t\t    change_spec[i] = \",M\" + Integer.toString(d);\n+\t\t\t    d = values[base + 4] - Calendar.SUNDAY;\n+\t\t\t    change_spec[i] += \".5.\" + Integer.toString(d);\n+\t\t\t  }\n+\n+\t\t\t// Don't add time specification if time is\n+\t\t\t// 02:00:00.\n+\t\t\tif (values[base + 5] != 2\n+\t\t\t    || values[base + 6] != 0\n+\t\t\t    || values[base + 7] != 0)\n+\t\t\t  {\n+\t\t\t    int d = values[base + 5];\n+\t\t\t    change_spec[i] += \"/\" + Integer.toString(d);\n+\t\t\t    if (values[base + 6] != 0 || values[base + 7] != 0)\n+\t\t\t      {\n+\t\t\t\td = values[base + 6];\n+\t\t\t\tif (d < 10)\n+\t\t\t\t  change_spec[i]\n+\t\t\t\t    += \":0\" + Integer.toString(d);\n+\t\t\t\telse\n+\t\t\t\t  change_spec[i] += \":\" + Integer.toString(d);\n+\t\t\t\td = values[base + 7];\n+\t\t\t\tif (d >= 10)\n+\t\t\t\t   change_spec[i]\n+\t\t\t\t     += \":\" + Integer.toString(d);\n+\t\t\t\telse if (d > 0)\n+\t\t\t\t  change_spec[i]\n+\t\t\t\t    += \":0\" + Integer.toString(d);\n+\t\t\t      }\n+\t\t\t  }\n+\t\t      }\n+\t\t    if (types[(timecnt - 1) & -2] == std_ind)\n+\t\t      {\n+\t\t\tString tmp = change_spec[0];\n+\t\t\tchange_spec[0] = change_spec[1];\n+\t\t\tchange_spec[1] = tmp;\n+\t\t      }\n+\t\t  }\n+\t      }\n+\t  }\n+\n+\tif (tzstr == null)\n+\t  {\n+\t    tzstr = std_zonename + std_offset_string;\n+\t    if (change_spec[0] != null && change_spec[1] != null)\n+\t      tzstr += dst_zonename + dst_offset_string\n+\t\t       + change_spec[0] + change_spec[1];\n+\t  }\n+\n+\tif (timecnt == 0)\n+\t  return new SimpleTimeZone(offsets[std_ind] * 1000,\n+\t\t\t\t    id != null ? id : tzstr);\n+\n+\tSimpleTimeZone endRule = createLastRule(tzstr);\n+\tif (endRule == null)\n+\t  return null;\n+\n+\t/* Finally adjust the times array into the form the constructor\n+\t * expects.  times[0] is special, the offset and DST flag there\n+\t * are for all times before that transition.  Use the first non-DST\n+\t * type.  For all other transitions, the data file has the type\n+\t * (<offset, isdst, zonename>) for the time interval starting\n+\t */\n+\tfor (int i = 0; i < typecnt; i++)\n+\t  if ((typeflags[i] & (1 << 8)) == 0)\n+\t    {\n+\t      times[0] = (times[0] << SECS_SHIFT) | (offsets[i] & OFFSET_MASK);\n+\t      break;\n+\t    }\n+\n+\tfor (int i = 1; i < timecnt; i++)\n+\t  times[i] = (times[i] << SECS_SHIFT)\n+\t\t     | (offsets[types[i - 1]] & OFFSET_MASK)\n+\t\t     | ((typeflags[types[i - 1]] & (1 << 8)) != 0 ? IS_DST : 0);\n+\n+\treturn new ZoneInfo(offsets[std_ind] * 1000, id != null ? id : tzstr,\n+\t\t\t    times, endRule);\n+      }\n+    catch (IOException ioe)\n+      {\n+\t// Parse error, not a proper tzfile.\n+\treturn null;\n+      }\n+    finally\n+      {\n+\ttry\n+\t  {\n+\t    if (dis != null)\n+\t      dis.close();\n+\t  }\n+\tcatch(IOException ioe)\n+\t  {\n+\t    // Error while close, nothing we can do.\n+\t  }\n+      }\n+  }\n+\n+  /**\n+   * Skips the requested number of bytes in the given InputStream.\n+   * Throws EOFException if not enough bytes could be skipped.\n+   * Negative numbers of bytes to skip are ignored.\n+   */\n+  private static void skipFully(InputStream is, long l) throws IOException\n+  {\n+    while (l > 0)\n+      {\n+\tlong k = is.skip(l);\n+\tif (k <= 0)\n+\t  throw new EOFException();\n+\tl -= k;\n+      }\n+  }\n+\n+  /**\n+   * Create a SimpleTimeZone from a POSIX TZ environment string,\n+   * see http://www.opengroup.org/onlinepubs/009695399/basedefs/xbd_chap08.html\n+   * for details.\n+   * It supports also an extension, where Am.n.d rule (m 1 .. 12, n 1 .. 25, d\n+   * 0 .. 6) describes day of week d on or after nth day of month m.\n+   * Say A4.5.0 is Sun>=5 in April.\n+   */\n+  private static SimpleTimeZone createLastRule(String tzstr)\n+  {\n+    String stdName = null;\n+    int stdOffs;\n+    int dstOffs;\n+    try\n+      {\n+\tint idLength = tzstr.length();\n+\n+\tint index = 0;\n+\tint prevIndex;\n+\tchar c;\n+\n+\t// get std\n+\tdo\n+\t  c = tzstr.charAt(index);\n+\twhile (c != '+' && c != '-' && c != ',' && c != ':'\n+\t       && ! Character.isDigit(c) && c != '\\0' && ++index < idLength);\n+\n+\tif (index >= idLength)\n+\t  return new SimpleTimeZone(0, tzstr);\n+\n+\tstdName = tzstr.substring(0, index);\n+\tprevIndex = index;\n+\n+\t// get the std offset\n+\tdo\n+\t  c = tzstr.charAt(index++);\n+\twhile ((c == '-' || c == '+' || c == ':' || Character.isDigit(c))\n+\t       && index < idLength);\n+\tif (index < idLength)\n+\t  index--;\n+\n+\t{ // convert the dst string to a millis number\n+\t    String offset = tzstr.substring(prevIndex, index);\n+\t    prevIndex = index;\n+\n+\t    if (offset.charAt(0) == '+' || offset.charAt(0) == '-')\n+\t      stdOffs = parseTime(offset.substring(1));\n+\t    else\n+\t      stdOffs = parseTime(offset);\n+\n+\t    if (offset.charAt(0) == '-')\n+\t      stdOffs = -stdOffs;\n+\n+\t    // TZ timezone offsets are positive when WEST of the meridian.\n+\t    stdOffs = -stdOffs;\n+\t}\n+\n+\t// Done yet? (Format: std offset)\n+\tif (index >= idLength)\n+\t  return new SimpleTimeZone(stdOffs, stdName);\n+\n+\t// get dst\n+\tdo\n+\t  c = tzstr.charAt(index);\n+\twhile (c != '+' && c != '-' && c != ',' && c != ':'\n+\t       && ! Character.isDigit(c) && c != '\\0' && ++index < idLength);\n+\n+\t// Done yet? (Format: std offset dst)\n+\tif (index >= idLength)\n+\t  return new SimpleTimeZone(stdOffs, stdName);\n+\n+\t// get the dst offset\n+\tprevIndex = index;\n+\tdo\n+\t  c = tzstr.charAt(index++);\n+\twhile ((c == '-' || c == '+' || c == ':' || Character.isDigit(c))\n+\t       && index < idLength);\n+\tif (index < idLength)\n+\t  index--;\n+\n+\tif (index == prevIndex && (c == ',' || c == ';'))\n+\t  {\n+\t    // Missing dst offset defaults to one hour ahead of standard\n+\t    // time.\n+\t    dstOffs = stdOffs + 60 * 60 * 1000;\n+\t  }\n+\telse\n+\t  { // convert the dst string to a millis number\n+\t    String offset = tzstr.substring(prevIndex, index);\n+\t    prevIndex = index;\n+\n+\t    if (offset.charAt(0) == '+' || offset.charAt(0) == '-')\n+\t      dstOffs = parseTime(offset.substring(1));\n+\t    else\n+\t      dstOffs = parseTime(offset);\n+\n+\t    if (offset.charAt(0) == '-')\n+\t      dstOffs = -dstOffs;\n+\n+\t    // TZ timezone offsets are positive when WEST of the meridian.\n+\t    dstOffs = -dstOffs;\n+\t  }\n+\n+\t// Done yet? (Format: std offset dst offset)\n+\tif (index >= idLength)\n+\t  return new SimpleTimeZone(stdOffs, stdName);\n+\n+\t// get the DST rule\n+\tif (tzstr.charAt(index) == ','\n+\t    || tzstr.charAt(index) == ';')\n+\t  {\n+\t    index++;\n+\t    int offs = index;\n+\t    while (tzstr.charAt(index) != ','\n+\t\t   && tzstr.charAt(index) != ';')\n+\t      index++;\n+\t    String startTime = tzstr.substring(offs, index);\n+\t    index++;\n+\t    String endTime = tzstr.substring(index);\n+\n+\t    index = startTime.indexOf('/');\n+\t    int startMillis;\n+\t    int endMillis;\n+\t    String startDate;\n+\t    String endDate;\n+\t    if (index != -1)\n+\t      {\n+\t\tstartDate = startTime.substring(0, index);\n+\t\tstartMillis = parseTime(startTime.substring(index + 1));\n+\t      }\n+\t    else\n+\t      {\n+\t\tstartDate = startTime;\n+\t\t// if time isn't given, default to 2:00:00 AM.\n+\t\tstartMillis = 2 * 60 * 60 * 1000;\n+\t      }\n+\t    index = endTime.indexOf('/');\n+\t    if (index != -1)\n+\t      {\n+\t\tendDate = endTime.substring(0, index);\n+\t\tendMillis = parseTime(endTime.substring(index + 1));\n+\t      }\n+\t    else\n+\t      {\n+\t\tendDate = endTime;\n+\t\t// if time isn't given, default to 2:00:00 AM.\n+\t\tendMillis = 2 * 60 * 60 * 1000;\n+\t      }\n+\n+\t    int[] start = getDateParams(startDate);\n+\t    int[] end = getDateParams(endDate);\n+\t    return new SimpleTimeZone(stdOffs, tzstr, start[0], start[1],\n+\t\t\t\t      start[2], startMillis, end[0], end[1],\n+\t\t\t\t      end[2], endMillis, (dstOffs - stdOffs));\n+\t  }\n+      }\n+\n+    catch (IndexOutOfBoundsException _)\n+      {\n+      }\n+    catch (NumberFormatException _)\n+      {\n+      }\n+\n+    return null;\n+  }\n+\n+  /**\n+   * Parses and returns the params for a POSIX TZ date field,\n+   * in the format int[]{ month, day, dayOfWeek }, following the\n+   * SimpleTimeZone constructor rules.\n+   */\n+  private static int[] getDateParams(String date)\n+  {\n+    int[] dayCount = { 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334 };\n+    int month;\n+    int type = 0;\n+\n+    if (date.charAt(0) == 'M' || date.charAt(0) == 'm')\n+      type = 1;\n+    else if (date.charAt(0) == 'A' || date.charAt(0) == 'a')\n+      type = 2;\n+\n+    if (type > 0)\n+      {\n+\tint day;\n+\n+\t// Month, week of month, day of week\n+\t// \"Mm.w.d\".  d is between 0 (Sunday) and 6.  Week w is\n+\t// between 1 and 5; Week 1 is the first week in which day d\n+\t// occurs and Week 5 specifies the last d day in the month.\n+\t// Month m is between 1 and 12.\n+\n+\t// Month, day of month, day of week\n+\t// ZoneInfo extension, not in POSIX\n+\t// \"Am.n.d\".  d is between 0 (Sunday) and 6.  Day of month n is\n+\t// between 1 and 25.  Month m is between 1 and 12.\n+\n+\tmonth = Integer.parseInt(date.substring(1, date.indexOf('.')));\n+\tint week = Integer.parseInt(date.substring(date.indexOf('.') + 1,\n+\t\t\t\t\t\t   date.lastIndexOf('.')));\n+\tint dayOfWeek = Integer.parseInt(date.substring(date.lastIndexOf('.')\n+\t\t\t\t\t\t\t+ 1));\n+\tdayOfWeek++; // Java day of week is one-based, Sunday is first day.\n+\n+\tif (type == 2)\n+\t  {\n+\t    day = week;\n+\t    dayOfWeek = -dayOfWeek;\n+\t  }\n+ \telse if (week == 5)\n+ \t  day = -1; // last day of month is -1 in java, 5 in TZ\n+ \telse\n+\t  {\n+\t    // First day of week starting on or after.  For example,\n+\t    // to specify the second Sunday of April, set month to\n+\t    // APRIL, day-of-month to 8, and day-of-week to -SUNDAY.\n+\t    day = (week - 1) * 7 + 1;\n+\t    dayOfWeek = -dayOfWeek;\n+\t  }\n+\n+\tmonth--; // Java month is zero-based.\n+\treturn new int[] { month, day, dayOfWeek };\n+      }\n+\n+    // julian day, either zero-based 0<=n<=365 (incl feb 29)\n+    // or one-based 1<=n<=365 (no feb 29)\n+    int julianDay; // Julian day\n+\n+    if (date.charAt(0) != 'J' || date.charAt(0) != 'j')\n+      {\n+\tjulianDay = Integer.parseInt(date.substring(1));\n+\tjulianDay++; // make 1-based\n+\t// Adjust day count to include feb 29.\n+\tdayCount = new int[]\n+\t\t   {\n+\t\t     0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335\n+\t\t   };\n+      }\n+    else\n+      // 1-based julian day\n+      julianDay = Integer.parseInt(date);\n+\n+    int i = 11;\n+    while (i > 0)\n+      if (dayCount[i] < julianDay)\n+\tbreak;\n+      else\n+\ti--;\n+    julianDay -= dayCount[i];\n+    month = i;\n+    return new int[] { month, julianDay, 0 };\n+  }\n+\n+  /**\n+   * Parses a time field hh[:mm[:ss]], returning the result\n+   * in milliseconds. No leading sign.\n+   */\n+  private static int parseTime(String time)\n+  {\n+    int millis = 0;\n+    int i = 0;\n+\n+    while (i < time.length())\n+      if (time.charAt(i) == ':')\n+\tbreak;\n+      else\n+\ti++;\n+    millis = 60 * 60 * 1000 * Integer.parseInt(time.substring(0, i));\n+    if (i >= time.length())\n+      return millis;\n+\n+    int iprev = ++i;\n+    while (i < time.length())\n+      if (time.charAt(i) == ':')\n+\tbreak;\n+      else\n+\ti++;\n+    millis += 60 * 1000 * Integer.parseInt(time.substring(iprev, i));\n+    if (i >= time.length())\n+      return millis;\n+\n+    millis += 1000 * Integer.parseInt(time.substring(++i));\n+    return millis;\n+  }\n+}"}, {"sha": "f481753db8dd1efd2506a36225565e41d4aa0fb9", "filename": "libjava/classpath/java/util/Date.java", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3502aa8d46d9cd008916170a635b2bf3a5d5125/libjava%2Fclasspath%2Fjava%2Futil%2FDate.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3502aa8d46d9cd008916170a635b2bf3a5d5125/libjava%2Fclasspath%2Fjava%2Futil%2FDate.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjava%2Futil%2FDate.java?ref=b3502aa8d46d9cd008916170a635b2bf3a5d5125", "patch": "@@ -754,6 +754,7 @@ else if (ch == ')')\n \t  }\n \telse if (firstch >= '0' && firstch <= '9')\n \t  {\n+\t    int lastPunct = -1;\n \t    while (tok != null && tok.length() > 0)\n \t      {\n \t\tint punctOffset = tok.length();\n@@ -791,6 +792,13 @@ else if (firstch >= '0' && firstch <= '9')\n \t\t    else\n \t\t      minute = num;\n \t\t  }\n+\t\telse if (lastPunct == ':' && hour >= 0 && (minute < 0 || second < 0))\n+\t\t  {\n+\t\t    if (minute < 0)\n+\t\t      minute = num;\n+\t\t    else\n+\t\t      second = num;\n+\t\t  }\n \t        else if ((num >= 70\n \t\t\t  && (punct == ' ' || punct == ','\n \t\t\t      || punct == '/' || punct < 0))\n@@ -828,6 +836,7 @@ else if (day < 0)\n \t\t  tok = null;\n \t\telse\n \t\t  tok = tok.substring(punctOffset + 1);\n+\t\tlastPunct = punct;\n \t      }\n \t  }\n \telse if (firstch >= 'A' && firstch <= 'Z')"}, {"sha": "14821ba0274ad5fdc61732828ffe7ef2412fdd2f", "filename": "libjava/classpath/java/util/SimpleTimeZone.java", "status": "modified", "additions": 47, "deletions": 73, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3502aa8d46d9cd008916170a635b2bf3a5d5125/libjava%2Fclasspath%2Fjava%2Futil%2FSimpleTimeZone.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3502aa8d46d9cd008916170a635b2bf3a5d5125/libjava%2Fclasspath%2Fjava%2Futil%2FSimpleTimeZone.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjava%2Futil%2FSimpleTimeZone.java?ref=b3502aa8d46d9cd008916170a635b2bf3a5d5125", "patch": "@@ -1,5 +1,6 @@\n /* java.util.SimpleTimeZone\n-   Copyright (C) 1998, 1999, 2000, 2003, 2004, 2005  Free Software Foundation, Inc.\n+   Copyright (C) 1998, 1999, 2000, 2003, 2004, 2005, 2007\n+   Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -141,8 +142,8 @@ public class SimpleTimeZone extends TimeZone\n \n   /**\n    * This variable specifies the time of change to daylight savings.\n-   * This time is given in milliseconds after midnight local\n-   * standard time.\n+   * This time is given in milliseconds after midnight in startTimeMode\n+   * chosen time mode.\n    * @serial\n    */\n   private int startTime;\n@@ -187,8 +188,8 @@ public class SimpleTimeZone extends TimeZone\n \n   /**\n    * This variable specifies the time of change back to standard time.\n-   * This time is given in milliseconds after midnight local\n-   * standard time.\n+   * This time is given in milliseconds after midnight in endTimeMode\n+   * chosen time mode.\n    * @serial\n    */\n   private int endTime;\n@@ -380,24 +381,17 @@ public SimpleTimeZone(int rawOffset, String id, int startMonth,\n                         int endDayOfWeekInMonth, int endDayOfWeek,\n                         int endTime, int endTimeMode, int dstSavings)\n   {\n-    this.rawOffset = rawOffset;\n-    setID(id);\n-    useDaylight = true;\n+    this(rawOffset, id, startMonth, startDayOfWeekInMonth, startDayOfWeek,\n+\t startTime, endMonth, endDayOfWeekInMonth, endDayOfWeek, endTime);\n \n     if (startTimeMode < WALL_TIME || startTimeMode > UTC_TIME)\n       throw new IllegalArgumentException(\"startTimeMode must be one of WALL_TIME, STANDARD_TIME, or UTC_TIME\");\n     if (endTimeMode < WALL_TIME || endTimeMode > UTC_TIME)\n       throw new IllegalArgumentException(\"endTimeMode must be one of WALL_TIME, STANDARD_TIME, or UTC_TIME\");\n-    this.startTimeMode = startTimeMode;\n-    this.endTimeMode = endTimeMode;\n-\n-    setStartRule(startMonth, startDayOfWeekInMonth, startDayOfWeek, startTime);\n-    setEndRule(endMonth, endDayOfWeekInMonth, endDayOfWeek, endTime);\n-    if (startMonth == endMonth)\n-      throw new IllegalArgumentException(\"startMonth and endMonth must be different\");\n-    this.startYear = 0;\n \n     this.dstSavings = dstSavings;\n+    this.startTimeMode = startTimeMode;\n+    this.endTimeMode = endTimeMode;\n   }\n \n   /**\n@@ -477,12 +471,8 @@ public void setStartRule(int month, int day, int dayOfWeek, int time)\n     this.startMonth = month;\n     this.startDay = day;\n     this.startDayOfWeek = Math.abs(dayOfWeek);\n-    if (this.startTimeMode == WALL_TIME || this.startTimeMode == STANDARD_TIME)\n-      this.startTime = time;\n-    else\n-      // Convert from UTC to STANDARD\n-      this.startTime = time + this.rawOffset;\n-    useDaylight = true;\n+    this.startTime = time;\n+    this.startTimeMode = WALL_TIME;\n   }\n \n   /**\n@@ -513,24 +503,10 @@ public void setStartRule(int month, int day, int dayOfWeek, int time)\n   public void setStartRule(int month, int day, int dayOfWeek, int time,\n                            boolean after)\n   {\n-    // FIXME: XXX: Validate that checkRule and offset processing work with on\n-    // or before mode.\n-    this.startDay = after ? Math.abs(day) : -Math.abs(day);\n-    this.startDayOfWeek = after ? Math.abs(dayOfWeek) : -Math.abs(dayOfWeek);\n-    this.startMode = (dayOfWeek != 0)\n-                     ? (after ? DOW_GE_DOM_MODE : DOW_LE_DOM_MODE)\n-                     : checkRule(month, day, dayOfWeek);\n-    this.startDay = Math.abs(this.startDay);\n-    this.startDayOfWeek = Math.abs(this.startDayOfWeek);\n-\n-    this.startMonth = month;\n-\n-    if (this.startTimeMode == WALL_TIME || this.startTimeMode == STANDARD_TIME)\n-      this.startTime = time;\n+    if (after)\n+      setStartRule(month, day, -dayOfWeek, time);\n     else\n-      // Convert from UTC to STANDARD\n-      this.startTime = time + this.rawOffset;\n-    useDaylight = true;\n+      setStartRule(month, -day, -dayOfWeek, time);\n   }\n \n   /**\n@@ -570,14 +546,8 @@ public void setEndRule(int month, int day, int dayOfWeek, int time)\n     this.endMonth = month;\n     this.endDay = day;\n     this.endDayOfWeek = Math.abs(dayOfWeek);\n-    if (this.endTimeMode == WALL_TIME)\n-      this.endTime = time;\n-    else if (this.endTimeMode == STANDARD_TIME)\n-      // Convert from STANDARD to DST\n-      this.endTime = time + this.dstSavings;\n-    else\n-      // Convert from UTC to DST\n-      this.endTime = time + this.rawOffset + this.dstSavings;\n+    this.endTime = time;\n+    this.endTimeMode = WALL_TIME;\n     useDaylight = true;\n   }\n \n@@ -607,27 +577,10 @@ else if (this.endTimeMode == STANDARD_TIME)\n   public void setEndRule(int month, int day, int dayOfWeek, int time,\n                          boolean after)\n   {\n-    // FIXME: XXX: Validate that checkRule and offset processing work with on\n-    // or before mode.\n-    this.endDay = after ? Math.abs(day) : -Math.abs(day);\n-    this.endDayOfWeek = after ? Math.abs(dayOfWeek) : -Math.abs(dayOfWeek);\n-    this.endMode = (dayOfWeek != 0)\n-                   ? (after ? DOW_GE_DOM_MODE : DOW_LE_DOM_MODE)\n-                   : checkRule(month, day, dayOfWeek);\n-    this.endDay = Math.abs(this.endDay);\n-    this.endDayOfWeek = Math.abs(endDayOfWeek);\n-\n-    this.endMonth = month;\n-\n-    if (this.endTimeMode == WALL_TIME)\n-      this.endTime = time;\n-    else if (this.endTimeMode == STANDARD_TIME)\n-      // Convert from STANDARD to DST\n-      this.endTime = time + this.dstSavings;\n+    if (after)\n+      setEndRule(month, day, -dayOfWeek, time);\n     else\n-      // Convert from UTC to DST\n-      this.endTime = time + this.rawOffset + this.dstSavings;\n-    useDaylight = true;\n+      setEndRule(month, -day, -dayOfWeek, time);\n   }\n \n   /**\n@@ -688,16 +641,37 @@ public int getOffset(int era, int year, int month, int day, int dayOfWeek,\n     int daylightSavings = 0;\n     if (useDaylight && era == GregorianCalendar.AD && year >= startYear)\n       {\n+\tint orig_year = year;\n+\tint time = startTime + (startTimeMode == UTC_TIME ? rawOffset : 0);\n \t// This does only work for Gregorian calendars :-(\n \t// This is mainly because setStartYear doesn't take an era.\n \tboolean afterStart = ! isBefore(year, month, day, dayOfWeek, millis,\n \t                                startMode, startMonth, startDay,\n-\t                                startDayOfWeek, startTime);\n-\tboolean beforeEnd = isBefore(year, month, day, dayOfWeek,\n-\t\t\t\t     millis + dstSavings,\n-\t                             endMode, endMonth, endDay, endDayOfWeek,\n-\t                             endTime);\n-\n+\t\t\t\t\tstartDayOfWeek, time);\n+\tmillis += dstSavings;\n+\tif (millis >= 24 * 60 * 60 * 1000)\n+\t  {\n+\t    millis -= 24 * 60 * 60 * 1000;\n+\t    dayOfWeek = (dayOfWeek % 7) + 1;\n+\t    if (++day > daysInMonth)\n+\t      {\n+\t\tday = 1;\n+\t\tif (month++ == Calendar.DECEMBER)\n+\t\t  {\n+\t\t    month = Calendar.JANUARY;\n+\t\t    year++;\n+\t\t  }\n+\t      }\n+\t  }\n+\ttime = endTime + (endTimeMode == UTC_TIME ? rawOffset : 0);\n+\tif (endTimeMode != WALL_TIME)\n+\t  time += dstSavings;\n+\tboolean beforeEnd = isBefore(year, month, day, dayOfWeek, millis,\n+\t\t\t\t     endMode, endMonth, endDay, endDayOfWeek,\n+\t\t\t\t     time);\n+\n+\tif (year != orig_year)\n+\t  afterStart = false;\n \tif (startMonth < endMonth)\n \t  // use daylight savings, if the date is after the start of\n \t  // savings, and before the end of savings."}, {"sha": "cede9fc789ff0ec65556823ed6eec400b982072b", "filename": "libjava/classpath/java/util/TimeZone.java", "status": "modified", "additions": 261, "deletions": 53, "changes": 314, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3502aa8d46d9cd008916170a635b2bf3a5d5125/libjava%2Fclasspath%2Fjava%2Futil%2FTimeZone.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3502aa8d46d9cd008916170a635b2bf3a5d5125/libjava%2Fclasspath%2Fjava%2Futil%2FTimeZone.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Fjava%2Futil%2FTimeZone.java?ref=b3502aa8d46d9cd008916170a635b2bf3a5d5125", "patch": "@@ -39,6 +39,9 @@\n \n package java.util;\n \n+import gnu.classpath.SystemProperties;\n+import gnu.java.util.ZoneInfo;\n+import java.io.File;\n import java.security.AccessController;\n import java.security.PrivilegedAction;\n import java.text.DateFormatSymbols;\n@@ -115,7 +118,7 @@ public Object run()\n \t\t\n \t\t// Fall back on GMT.\n \t\tif (zone == null)\n-\t\t  zone = (TimeZone) timezones().get(\"GMT\");\n+\t\t  zone = getTimeZone (\"GMT\");\n \t\t\n \t\treturn zone;\n \t      }\n@@ -127,6 +130,22 @@ public Object run()\n   \n   private static final long serialVersionUID = 3581463369166924961L;\n \n+  /**\n+   * Flag whether zoneinfo data should be used,\n+   * otherwise builtin timezone data will be provided.\n+   */\n+  private static String zoneinfo_dir;\n+\n+  /**\n+   * Cached copy of getAvailableIDs().\n+   */\n+  private static String[] availableIDs = null;\n+\n+  /**\n+   * JDK 1.1.x compatibility aliases.\n+   */\n+  private static HashMap aliases0;\n+\n   /**\n    * HashMap for timezones by ID.  \n    */\n@@ -135,13 +154,55 @@ public Object run()\n    * it is not needed: \n    */\n   // Package-private to avoid a trampoline.\n-  static synchronized HashMap timezones()\n+  static HashMap timezones()\n   {\n     if (timezones0 == null) \n       {\n \tHashMap timezones = new HashMap();\n \ttimezones0 = timezones;\n \n+\tzoneinfo_dir = SystemProperties.getProperty(\"gnu.java.util.zoneinfo.dir\");\n+\tif (zoneinfo_dir != null && !new File(zoneinfo_dir).isDirectory())\n+\t  zoneinfo_dir = null;\n+\n+\tif (zoneinfo_dir != null)\n+\t  {\n+\t    aliases0 = new HashMap();\n+\n+\t    // These deprecated aliases for JDK 1.1.x compatibility\n+\t    // should take precedence over data files read from\n+\t    // /usr/share/zoneinfo.\n+\t    aliases0.put(\"ACT\", \"Australia/Darwin\");\n+\t    aliases0.put(\"AET\", \"Australia/Sydney\");\n+\t    aliases0.put(\"AGT\", \"America/Argentina/Buenos_Aires\");\n+\t    aliases0.put(\"ART\", \"Africa/Cairo\");\n+\t    aliases0.put(\"AST\", \"America/Juneau\");\n+\t    aliases0.put(\"BST\", \"Asia/Colombo\");\n+\t    aliases0.put(\"CAT\", \"Africa/Gaborone\");\n+\t    aliases0.put(\"CNT\", \"America/St_Johns\");\n+\t    aliases0.put(\"CST\", \"CST6CDT\");\n+\t    aliases0.put(\"CTT\", \"Asia/Brunei\");\n+\t    aliases0.put(\"EAT\", \"Indian/Comoro\");\n+\t    aliases0.put(\"ECT\", \"CET\");\n+\t    aliases0.put(\"EST\", \"EST5EDT\");\n+\t    aliases0.put(\"EST5\", \"EST5EDT\");\n+\t    aliases0.put(\"IET\", \"EST5EDT\");\n+\t    aliases0.put(\"IST\", \"Asia/Calcutta\");\n+\t    aliases0.put(\"JST\", \"Asia/Seoul\");\n+\t    aliases0.put(\"MIT\", \"Pacific/Niue\");\n+\t    aliases0.put(\"MST\", \"MST7MDT\");\n+\t    aliases0.put(\"MST7\", \"MST7MDT\");\n+\t    aliases0.put(\"NET\", \"Indian/Mauritius\");\n+\t    aliases0.put(\"NST\", \"Pacific/Auckland\");\n+\t    aliases0.put(\"PLT\", \"Indian/Kerguelen\");\n+\t    aliases0.put(\"PNT\", \"MST7MDT\");\n+\t    aliases0.put(\"PRT\", \"America/Anguilla\");\n+\t    aliases0.put(\"PST\", \"PST8PDT\");\n+\t    aliases0.put(\"SST\", \"Pacific/Ponape\");\n+\t    aliases0.put(\"VST\", \"Asia/Bangkok\");\n+\t    return timezones;\n+\t  }\n+\n \tTimeZone tz;\n \t// Automatically generated by scripts/timezones.pl\n \t// XXX - Should we read this data from a file?\n@@ -887,7 +948,6 @@ static synchronized HashMap timezones()\n   static TimeZone getDefaultTimeZone(String sysTimeZoneId)\n   {\n     String stdName = null;\n-    String dstName;\n     int stdOffs;\n     int dstOffs;\n     try\n@@ -900,14 +960,14 @@ static TimeZone getDefaultTimeZone(String sysTimeZoneId)\n \n \t// get std\n \tdo\n-\t  c = sysTimeZoneId.charAt(index++);\n+\t  c = sysTimeZoneId.charAt(index);\n \twhile (c != '+' && c != '-' && c != ',' && c != ':'\n-\t       && ! Character.isDigit(c) && c != '\\0' && index < idLength);\n+\t       && ! Character.isDigit(c) && c != '\\0' && ++index < idLength);\n \n \tif (index >= idLength)\n-\t  return (TimeZone)timezones().get(sysTimeZoneId);\n+\t  return getTimeZoneInternal(sysTimeZoneId);\n \n-\tstdName = sysTimeZoneId.substring(0, --index);\n+\tstdName = sysTimeZoneId.substring(0, index);\n \tprevIndex = index;\n \n \t// get the std offset\n@@ -938,7 +998,7 @@ static TimeZone getDefaultTimeZone(String sysTimeZoneId)\n \tif (index >= idLength)\n \t  {\n \t    // Do we have an existing timezone with that name and offset?\n-\t    TimeZone tz = (TimeZone) timezones().get(stdName);\n+\t    TimeZone tz = getTimeZoneInternal(stdName);\n \t    if (tz != null)\n \t      if (tz.getRawOffset() == stdOffs)\n \t\treturn tz;\n@@ -949,16 +1009,16 @@ static TimeZone getDefaultTimeZone(String sysTimeZoneId)\n \n \t// get dst\n \tdo\n-\t  c = sysTimeZoneId.charAt(index++);\n+\t  c = sysTimeZoneId.charAt(index);\n \twhile (c != '+' && c != '-' && c != ',' && c != ':'\n-\t       && ! Character.isDigit(c) && c != '\\0' && index < idLength);\n+\t       && ! Character.isDigit(c) && c != '\\0' && ++index < idLength);\n \n \t// Done yet? (Format: std offset dst)\n \tif (index >= idLength)\n \t  {\n \t    // Do we have an existing timezone with that name and offset \n \t    // which has DST?\n-\t    TimeZone tz = (TimeZone) timezones().get(stdName);\n+\t    TimeZone tz = getTimeZoneInternal(stdName);\n \t    if (tz != null)\n \t      if (tz.getRawOffset() == stdOffs && tz.useDaylightTime())\n \t\treturn tz;\n@@ -968,7 +1028,6 @@ static TimeZone getDefaultTimeZone(String sysTimeZoneId)\n \t  }\n \n \t// get the dst offset\n-\tdstName = sysTimeZoneId.substring(prevIndex, --index);\n \tprevIndex = index;\n \tdo\n \t  c = sysTimeZoneId.charAt(index++);\n@@ -1005,7 +1064,7 @@ static TimeZone getDefaultTimeZone(String sysTimeZoneId)\n \tif (index >= idLength)\n \t  {\n \t    // Time Zone existing with same name, dst and offsets?\n-\t    TimeZone tz = (TimeZone) timezones().get(stdName);\n+\t    TimeZone tz = getTimeZoneInternal(stdName);\n \t    if (tz != null)\n \t      if (tz.getRawOffset() == stdOffs && tz.useDaylightTime()\n \t          && tz.getDSTSavings() == (dstOffs - stdOffs))\n@@ -1171,10 +1230,10 @@ private static int parseTime(String time)\n \tbreak;\n       else\n \ti++;\n+    millis += 60 * 1000 * Integer.parseInt(time.substring(iprev, i));\n     if (i >= time.length())\n       return millis;\n \n-    millis += 60 * 1000 * Integer.parseInt(time.substring(iprev, i));\n     millis += 1000 * Integer.parseInt(time.substring(++i));\n     return millis;\n   }\n@@ -1406,30 +1465,67 @@ public int getDSTSavings ()\n    * @return The time zone for the identifier or GMT, if no such time\n    * zone exists.\n    */\n-  // FIXME: XXX: JCL indicates this and other methods are synchronized.\n-  public static TimeZone getTimeZone(String ID)\n+  private static TimeZone getTimeZoneInternal(String ID)\n   {\n     // First check timezones hash\n-    TimeZone tz = (TimeZone) timezones().get(ID);\n-    if (tz != null)\n+    TimeZone tz = null;\n+    TimeZone tznew = null;\n+    for (int pass = 0; pass < 2; pass++)\n       {\n-\tif (tz.getID().equals(ID))\n-\t  return tz;\n-\n-\t// We always return a timezone with the requested ID.\n-\t// This is the same behaviour as with JDK1.2.\n-\ttz = (TimeZone) tz.clone();\n-\ttz.setID(ID);\n-\t// We also save the alias, so that we return the same\n-\t// object again if getTimeZone is called with the same\n-\t// alias.\n-\ttimezones().put(ID, tz);\n-\treturn tz;\n+\tsynchronized (TimeZone.class)\n+\t  {\n+\t    tz = (TimeZone) timezones().get(ID);\n+\t    if (tz != null)\n+\t      {\n+\t\tif (!tz.getID().equals(ID))\n+\t\t  {\n+\t\t    // We always return a timezone with the requested ID.\n+\t\t    // This is the same behaviour as with JDK1.2.\n+\t\t    tz = (TimeZone) tz.clone();\n+\t\t    tz.setID(ID);\n+\t\t    // We also save the alias, so that we return the same\n+\t\t    // object again if getTimeZone is called with the same\n+\t\t    // alias.\n+\t\t    timezones().put(ID, tz);\n+\t\t  }\n+\t\treturn tz;\n+\t      }\n+\t    else if (tznew != null)\n+\t      {\n+\t\ttimezones().put(ID, tznew);\n+\t\treturn tznew;\n+\t      }\n+\t  }\n+\n+\tif (pass == 1 || zoneinfo_dir == null)\n+\t  return null;\n+\n+\t// aliases0 is never changing after first timezones(), so should\n+\t// be safe without synchronization.\n+\tString zonename = (String) aliases0.get(ID);\n+\tif (zonename == null)\n+\t  zonename = ID;\n+\n+\t// Read the file outside of the critical section, it is expensive.\n+\ttznew = ZoneInfo.readTZFile (ID, zoneinfo_dir\n+\t\t\t\t     + File.separatorChar + zonename);\n+\tif (tznew == null)\n+\t  return null;\n       }\n \n-    // See if the ID is really a GMT offset form.\n-    // Note that GMT is in the table so we know it is different.\n-    if (ID.startsWith(\"GMT\"))\n+    return null;\n+  }\n+\n+  /**\n+   * Gets the TimeZone for the given ID.\n+   * @param ID the time zone identifier.\n+   * @return The time zone for the identifier or GMT, if no such time\n+   * zone exists.\n+   */\n+  public static TimeZone getTimeZone(String ID)\n+  {\n+    // Check for custom IDs first\n+    if (ID.startsWith(\"GMT\") && ID.length() > 3)\n       {\n \tint pos = 3;\n \tint offset_direction = 1;\n@@ -1474,17 +1570,32 @@ else if (ID.charAt(pos) == '+')\n \t\t  }\n \t      }\n \n-\t    return new SimpleTimeZone((hour * (60 * 60 * 1000) +\n-\t\t\t\t       minute * (60 * 1000))\n+\t    // Custom IDs have to be normalized\n+\t    StringBuffer sb = new StringBuffer(9);\n+\t    sb.append(\"GMT\");\n+\n+\t    sb.append(offset_direction >= 0 ? '+' : '-');\n+\t    sb.append((char) ('0' + hour / 10));\n+\t    sb.append((char) ('0' + hour % 10));\n+\t    sb.append(':');\n+\t    sb.append((char) ('0' + minute / 10));\n+\t    sb.append((char) ('0' + minute % 10));\n+\t    ID = sb.toString();\n+\n+\t    return new SimpleTimeZone((hour * (60 * 60 * 1000)\n+\t\t\t\t       + minute * (60 * 1000))\n \t\t\t\t      * offset_direction, ID);\n \t  }\n \tcatch (NumberFormatException e)\n \t  {\n \t  }\n       }\n \n-    // Finally, return GMT per spec\n-    return getTimeZone(\"GMT\");\n+    TimeZone tz = getTimeZoneInternal(ID);\n+    if (tz != null)\n+      return tz;\n+\n+    return new SimpleTimeZone(0, \"GMT\");\n   }\n \n   /**\n@@ -1497,37 +1608,134 @@ else if (ID.charAt(pos) == '+')\n    */\n   public static String[] getAvailableIDs(int rawOffset)\n   {\n+    synchronized (TimeZone.class)\n+      {\n+\tHashMap h = timezones();\n+\tint count = 0;\n+\tif (zoneinfo_dir == null)\n+\t  {\n+\t    Iterator iter = h.entrySet().iterator();\n+\t    while (iter.hasNext())\n+\t      {\n+\t\t// Don't iterate the values, since we want to count\n+\t\t// doubled values (aliases)\n+\t\tMap.Entry entry = (Map.Entry) iter.next();\n+\t\tif (((TimeZone) entry.getValue()).getRawOffset() == rawOffset)\n+\t\t  count++;\n+\t      }\n+\n+\t    String[] ids = new String[count];\n+\t    count = 0;\n+\t    iter = h.entrySet().iterator();\n+\t    while (iter.hasNext())\n+\t      {\n+\t\tMap.Entry entry = (Map.Entry) iter.next();\n+\t\tif (((TimeZone) entry.getValue()).getRawOffset() == rawOffset)\n+\t\t  ids[count++] = (String) entry.getKey();\n+\t      }\n+\t    return ids;\n+\t  }\n+      }\n+\n+    String[] s = getAvailableIDs();\n     int count = 0;\n-    Iterator iter = timezones().entrySet().iterator();\n-    while (iter.hasNext())\n+    for (int i = 0; i < s.length; i++)\n       {\n-\t// Don't iterate the values, since we want to count \n-\t// doubled values (aliases)\n-\tMap.Entry entry = (Map.Entry) iter.next();\n-\tif (((TimeZone) entry.getValue()).getRawOffset() == rawOffset)\n+\tTimeZone t = getTimeZoneInternal(s[i]);\n+\tif (t == null || t.getRawOffset() != rawOffset)\n+\t  s[i] = null;\n+\telse\n \t  count++;\n       }\n-\n     String[] ids = new String[count];\n     count = 0;\n-    iter = timezones().entrySet().iterator();\n-    while (iter.hasNext())\n-      {\n-\tMap.Entry entry = (Map.Entry) iter.next();\n-\tif (((TimeZone) entry.getValue()).getRawOffset() == rawOffset)\n-\t  ids[count++] = (String) entry.getKey();\n-      }\n+    for (int i = 0; i < s.length; i++)\n+    if (s[i] != null)\n+      ids[count++] = s[i];\n+\n     return ids;\n   }\n \n+  private static int getAvailableIDs(File d, String prefix, ArrayList list)\n+    {\n+      String[] files = d.list();\n+      int count = files.length;\n+      boolean top = prefix.length() == 0;\n+      list.add (files);\n+      for (int i = 0; i < files.length; i++)\n+\t{\n+\t  if (top\n+\t      && (files[i].equals(\"posix\")\n+\t\t  || files[i].equals(\"right\")\n+\t\t  || files[i].endsWith(\".tab\")\n+\t\t  || aliases0.get(files[i]) != null))\n+\t    {\n+\t      files[i] = null;\n+\t      count--;\n+\t      continue;\n+\t    }\n+\n+\t  File f = new File(d, files[i]);\n+\t  if (f.isDirectory())\n+\t    {\n+\t      count += getAvailableIDs(f, prefix + files[i]\n+\t\t\t\t       + File.separatorChar, list) - 1;\n+\t      files[i] = null;\n+\t    }\n+\t  else\n+\t    files[i] = prefix + files[i];\n+\t}\n+      return count;\n+    }\n+\n   /**\n    * Gets all available IDs.\n    * @return An array of all supported IDs.\n    */\n   public static String[] getAvailableIDs()\n   {\n-    return (String[])\n-      timezones().keySet().toArray(new String[timezones().size()]);\n+    synchronized (TimeZone.class)\n+      {\n+\tHashMap h = timezones();\n+\tif (zoneinfo_dir == null)\n+\t  return (String[]) h.keySet().toArray(new String[h.size()]);\n+\n+\tif (availableIDs != null)\n+\t  {\n+\t    String[] ids = new String[availableIDs.length];\n+\t    for (int i = 0; i < availableIDs.length; i++)\n+\t      ids[i] = availableIDs[i];\n+\t    return ids;\n+\t  }\n+\n+\tFile d = new File(zoneinfo_dir);\n+\tArrayList list = new ArrayList(30);\n+\tint count = getAvailableIDs(d, \"\", list) + aliases0.size();\n+\tavailableIDs = new String[count];\n+\tString[] ids = new String[count];\n+\n+\tcount = 0;\n+\tfor (int i = 0; i < list.size(); i++)\n+\t  {\n+\t    String[] s = (String[]) list.get(i);\n+\t    for (int j = 0; j < s.length; j++)\n+\t      if (s[j] != null)\n+\t\t{\n+\t\t  availableIDs[count] = s[j];\n+\t\t  ids[count++] = s[j];\n+\t\t}\n+\t  }\n+\n+\tIterator iter = aliases0.entrySet().iterator();\n+\twhile (iter.hasNext())\n+\t  {\n+\t    Map.Entry entry = (Map.Entry) iter.next();\n+\t    availableIDs[count] = (String) entry.getKey();\n+\t    ids[count++] = (String) entry.getKey();\n+\t  }\n+\n+\treturn ids;\n+      }\n   }\n \n   /**"}, {"sha": "3ff3706ba849a9da3bd4dc1f9f2dc08a6a02d9bb", "filename": "libjava/classpath/lib/gnu/java/util/ZoneInfo.class", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3502aa8d46d9cd008916170a635b2bf3a5d5125/libjava%2Fclasspath%2Flib%2Fgnu%2Fjava%2Futil%2FZoneInfo.class", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3502aa8d46d9cd008916170a635b2bf3a5d5125/libjava%2Fclasspath%2Flib%2Fgnu%2Fjava%2Futil%2FZoneInfo.class", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Flib%2Fgnu%2Fjava%2Futil%2FZoneInfo.class?ref=b3502aa8d46d9cd008916170a635b2bf3a5d5125"}, {"sha": "c6aebaa4742ea7ad2618238db6922eca2bb57605", "filename": "libjava/classpath/lib/java/util/Date.class", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3502aa8d46d9cd008916170a635b2bf3a5d5125/libjava%2Fclasspath%2Flib%2Fjava%2Futil%2FDate.class", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3502aa8d46d9cd008916170a635b2bf3a5d5125/libjava%2Fclasspath%2Flib%2Fjava%2Futil%2FDate.class", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Flib%2Fjava%2Futil%2FDate.class?ref=b3502aa8d46d9cd008916170a635b2bf3a5d5125"}, {"sha": "1506330b6cf23565fde5ee5749ee4c4009c2eefd", "filename": "libjava/classpath/lib/java/util/SimpleTimeZone.class", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3502aa8d46d9cd008916170a635b2bf3a5d5125/libjava%2Fclasspath%2Flib%2Fjava%2Futil%2FSimpleTimeZone.class", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3502aa8d46d9cd008916170a635b2bf3a5d5125/libjava%2Fclasspath%2Flib%2Fjava%2Futil%2FSimpleTimeZone.class", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Flib%2Fjava%2Futil%2FSimpleTimeZone.class?ref=b3502aa8d46d9cd008916170a635b2bf3a5d5125"}, {"sha": "08d8bd2f52a4b4f5344988056b7de9c821432a73", "filename": "libjava/classpath/lib/java/util/TimeZone$1.class", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3502aa8d46d9cd008916170a635b2bf3a5d5125/libjava%2Fclasspath%2Flib%2Fjava%2Futil%2FTimeZone%241.class", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3502aa8d46d9cd008916170a635b2bf3a5d5125/libjava%2Fclasspath%2Flib%2Fjava%2Futil%2FTimeZone%241.class", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Flib%2Fjava%2Futil%2FTimeZone%241.class?ref=b3502aa8d46d9cd008916170a635b2bf3a5d5125"}, {"sha": "556c26d6ed97a2c3fda2f4ba0971f2cf80f5c5ef", "filename": "libjava/classpath/lib/java/util/TimeZone.class", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3502aa8d46d9cd008916170a635b2bf3a5d5125/libjava%2Fclasspath%2Flib%2Fjava%2Futil%2FTimeZone.class", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3502aa8d46d9cd008916170a635b2bf3a5d5125/libjava%2Fclasspath%2Flib%2Fjava%2Futil%2FTimeZone.class", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Flib%2Fjava%2Futil%2FTimeZone.class?ref=b3502aa8d46d9cd008916170a635b2bf3a5d5125"}, {"sha": "f2f9fa959310fd8a00c1b1eae3d4b95fb026f35d", "filename": "libjava/classpath/lib/java/util/VMTimeZone.class", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3502aa8d46d9cd008916170a635b2bf3a5d5125/libjava%2Fclasspath%2Flib%2Fjava%2Futil%2FVMTimeZone.class", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3502aa8d46d9cd008916170a635b2bf3a5d5125/libjava%2Fclasspath%2Flib%2Fjava%2Futil%2FVMTimeZone.class", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Flib%2Fjava%2Futil%2FVMTimeZone.class?ref=b3502aa8d46d9cd008916170a635b2bf3a5d5125"}, {"sha": "83a0bf896a35c62d7167e5d2fc90572c83998e46", "filename": "libjava/gnu/java/util/ZoneInfo.h", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3502aa8d46d9cd008916170a635b2bf3a5d5125/libjava%2Fgnu%2Fjava%2Futil%2FZoneInfo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3502aa8d46d9cd008916170a635b2bf3a5d5125/libjava%2Fgnu%2Fjava%2Futil%2FZoneInfo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Futil%2FZoneInfo.h?ref=b3502aa8d46d9cd008916170a635b2bf3a5d5125", "patch": "@@ -0,0 +1,70 @@\n+\n+// DO NOT EDIT THIS FILE - it is machine generated -*- c++ -*-\n+\n+#ifndef __gnu_java_util_ZoneInfo__\n+#define __gnu_java_util_ZoneInfo__\n+\n+#pragma interface\n+\n+#include <java/util/TimeZone.h>\n+#include <gcj/array.h>\n+\n+extern \"Java\"\n+{\n+  namespace gnu\n+  {\n+    namespace java\n+    {\n+      namespace util\n+      {\n+          class ZoneInfo;\n+      }\n+    }\n+  }\n+}\n+\n+class gnu::java::util::ZoneInfo : public ::java::util::TimeZone\n+{\n+\n+public:\n+  ZoneInfo(jint, ::java::lang::String *, JArray< jlong > *, ::java::util::SimpleTimeZone *);\n+  virtual jint getOffset(jint, jint, jint, jint, jint, jint);\n+private:\n+  jlong findTransition(jlong);\n+public:\n+  virtual jint getOffset(jlong);\n+  virtual jint getRawOffset();\n+  virtual void setRawOffset(jint);\n+private:\n+  void computeDSTSavings();\n+public:\n+  virtual jint getDSTSavings();\n+  virtual jboolean useDaylightTime();\n+  virtual jboolean inDaylightTime(::java::util::Date *);\n+  virtual jint hashCode();\n+  virtual jboolean equals(::java::lang::Object *);\n+  virtual jboolean hasSameRules(::java::util::TimeZone *);\n+  virtual ::java::lang::String * toString();\n+  static ::java::util::TimeZone * readTZFile(::java::lang::String *, ::java::lang::String *);\n+private:\n+  static void skipFully(::java::io::InputStream *, jlong);\n+  static ::java::util::SimpleTimeZone * createLastRule(::java::lang::String *);\n+  static JArray< jint > * getDateParams(::java::lang::String *);\n+  static jint parseTime(::java::lang::String *);\n+  static const jint SECS_SHIFT = 22;\n+  static const jlong OFFSET_MASK = 2097151LL;\n+  static const jint OFFSET_SHIFT = 43;\n+  static const jlong IS_DST = 2097152LL;\n+  jint __attribute__((aligned(__alignof__( ::java::util::TimeZone)))) rawOffset;\n+  jint dstSavings;\n+  jboolean useDaylight;\n+  JArray< jlong > * transitions;\n+  ::java::util::SimpleTimeZone * lastRule;\n+  static ::java::util::SimpleTimeZone * gmtZone;\n+public: // actually package-private\n+  static const jlong serialVersionUID = -3740626706860383657LL;\n+public:\n+  static ::java::lang::Class class$;\n+};\n+\n+#endif // __gnu_java_util_ZoneInfo__"}, {"sha": "76a39f0d3f288a1cc28b3fd3defd2cd946ca5ec1", "filename": "libjava/java/lang/System.java", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3502aa8d46d9cd008916170a635b2bf3a5d5125/libjava%2Fjava%2Flang%2FSystem.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3502aa8d46d9cd008916170a635b2bf3a5d5125/libjava%2Fjava%2Flang%2FSystem.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FSystem.java?ref=b3502aa8d46d9cd008916170a635b2bf3a5d5125", "patch": "@@ -1,5 +1,5 @@\n /* System.java -- useful methods to interface with the system\n-   Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006\n+   Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007\n    Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n@@ -318,6 +318,7 @@ public static native void arraycopy(Object src, int srcStart,\n    * <dt>gnu.java.io.encoding_scheme_alias.latin?</dt>       <dd>8859_?</dd>\n    * <dt>gnu.java.io.encoding_scheme_alias.UTF-8</dt>        <dd>UTF8</dd>\n    * <dt>gnu.java.io.encoding_scheme_alias.utf-8</dt>        <dd>UTF8</dd>\n+   * <dt>gnu.java.util.zoneinfo.dir</dt>\t<dd>Root of zoneinfo tree</dd>\n    * </dl>\n    *\n    * @return the system properties, will never be null"}, {"sha": "9ae0ebc3f16a12fe04f7ccb5016ffad6caddd0e0", "filename": "libjava/java/util/TimeZone.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3502aa8d46d9cd008916170a635b2bf3a5d5125/libjava%2Fjava%2Futil%2FTimeZone.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3502aa8d46d9cd008916170a635b2bf3a5d5125/libjava%2Fjava%2Futil%2FTimeZone.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FTimeZone.h?ref=b3502aa8d46d9cd008916170a635b2bf3a5d5125", "patch": "@@ -40,8 +40,14 @@ class java::util::TimeZone : public ::java::lang::Object\n   virtual jboolean useDaylightTime() = 0;\n   virtual jboolean inDaylightTime(::java::util::Date *) = 0;\n   virtual jint getDSTSavings();\n+private:\n+  static ::java::util::TimeZone * getTimeZoneInternal(::java::lang::String *);\n+public:\n   static ::java::util::TimeZone * getTimeZone(::java::lang::String *);\n   static JArray< ::java::lang::String * > * getAvailableIDs(jint);\n+private:\n+  static jint getAvailableIDs(::java::io::File *, ::java::lang::String *, ::java::util::ArrayList *);\n+public:\n   static JArray< ::java::lang::String * > * getAvailableIDs();\n   static ::java::util::TimeZone * getDefault();\n   static void setDefault(::java::util::TimeZone *);\n@@ -53,6 +59,9 @@ class java::util::TimeZone : public ::java::lang::Object\n   ::java::lang::String * __attribute__((aligned(__alignof__( ::java::lang::Object)))) ID;\n   static ::java::util::TimeZone * defaultZone0;\n   static const jlong serialVersionUID = 3581463369166924961LL;\n+  static ::java::lang::String * zoneinfo_dir;\n+  static JArray< ::java::lang::String * > * availableIDs;\n+  static ::java::util::HashMap * aliases0;\n   static ::java::util::HashMap * timezones0;\n public:\n   static ::java::lang::Class class$;"}, {"sha": "26ca5e224cb980a052a013cd11c131f74df7ef3e", "filename": "libjava/java/util/VMTimeZone.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3502aa8d46d9cd008916170a635b2bf3a5d5125/libjava%2Fjava%2Futil%2FVMTimeZone.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3502aa8d46d9cd008916170a635b2bf3a5d5125/libjava%2Fjava%2Futil%2FVMTimeZone.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FVMTimeZone.h?ref=b3502aa8d46d9cd008916170a635b2bf3a5d5125", "patch": "@@ -16,8 +16,7 @@ class java::util::VMTimeZone : public ::java::lang::Object\n   static ::java::util::TimeZone * getDefaultTimeZoneId();\n private:\n   static ::java::lang::String * readTimeZoneFile(::java::lang::String *);\n-  static ::java::lang::String * readtzFile(::java::lang::String *);\n-  static void skipFully(::java::io::InputStream *, jlong);\n+  static ::java::lang::String * readSysconfigClockFile(::java::lang::String *);\n   static ::java::lang::String * getSystemTimeZoneId();\n public:\n   static ::java::lang::Class class$;"}, {"sha": "992ecaf28a8ccf944bb69d97f8108ce3f12b5c8b", "filename": "libjava/java/util/VMTimeZone.java", "status": "modified", "additions": 84, "deletions": 476, "changes": 560, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3502aa8d46d9cd008916170a635b2bf3a5d5125/libjava%2Fjava%2Futil%2FVMTimeZone.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3502aa8d46d9cd008916170a635b2bf3a5d5125/libjava%2Fjava%2Futil%2FVMTimeZone.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FVMTimeZone.java?ref=b3502aa8d46d9cd008916170a635b2bf3a5d5125", "patch": "@@ -40,9 +40,9 @@\n package java.util;\n \n import gnu.classpath.Configuration;\n+import gnu.classpath.SystemProperties;\n+import gnu.java.util.ZoneInfo;\n import java.util.TimeZone;\n-import java.util.Calendar;\n-import java.util.GregorianCalendar;\n \n import java.io.*;\n \n@@ -78,9 +78,10 @@\n    * The reference implementation which is made for GNU/Posix like\n    * systems calls <code>System.getenv(\"TZ\")</code>,\n    * <code>readTimeZoneFile(\"/etc/timezone\")</code>,\n-   * <code>readtzFile(\"/etc/localtime\")</code> and finally\n-   * <code>getSystemTimeZoneId()</code> till a supported TimeZone is\n-   * found through <code>TimeZone.getDefaultTimeZone(String)</code>.\n+   * <code>ZoneInfo.readTZFile((String)null, \"/etc/localtime\")</code>\n+   * and finally <code>getSystemTimeZoneId()</code> till a supported\n+   * TimeZone is found through\n+   * <code>TimeZone.getDefaultTimeZone(String)</code>.\n    * If every method fails <code>null</code> is returned (which means\n    * the TimeZone code will fall back on GMT as default time zone).\n    * <p>\n@@ -111,9 +112,51 @@ static TimeZone getDefaultTimeZoneId()\n     // Try to parse /etc/localtime\n     if (zone == null)\n       {\n-\ttzid = readtzFile(\"/etc/localtime\");\n-\tif (tzid != null && !tzid.equals(\"\"))\n-\t  zone = TimeZone.getDefaultTimeZone(tzid);\n+\tzone = ZoneInfo.readTZFile((String) null, \"/etc/localtime\");\n+\tif (zone != null)\n+\t  {\n+\t    // Try to find a more suitable ID for the /etc/localtime\n+\t    // timezone.\n+\t    // Sometimes /etc/localtime is a symlink to some\n+\t    // /usr/share/zoneinfo/ file.\n+\t    String id = null;\n+\t    try\n+\t      {\n+\t\tid = new File(\"/etc/localtime\").getCanonicalPath();\n+\t\tif (id != null)\n+\t\t  {\n+\t\t    String zoneinfo_dir\n+\t\t      = SystemProperties.getProperty(\"gnu.java.util.zoneinfo.dir\");\n+\t\t    if (zoneinfo_dir != null)\n+\t\t      zoneinfo_dir\n+\t\t\t= new File(zoneinfo_dir\n+\t\t\t\t   + File.separatorChar).getCanonicalPath();\n+\t\t    if (zoneinfo_dir != null && id.startsWith(zoneinfo_dir))\n+\t\t      {\n+\t\t\tint pos = zoneinfo_dir.length();\n+\t\t\twhile (pos < id.length()\n+\t\t\t       && id.charAt(pos) == File.separatorChar)\n+\t\t\t  pos++;\n+\t\t\tif (pos < id.length())\n+\t\t\t  id = id.substring(pos);\n+\t\t\telse\n+\t\t\t  id = null;\n+\t\t      }\n+\t\t    else\n+\t\t      id = null;\n+\t\t  }\n+\t      }\n+\t    catch (IOException ioe)\n+\t      {\n+\t\tid = null;\n+\t      }\n+\n+\t    if (id == null)\n+\t      id = readSysconfigClockFile(\"/etc/sysconfig/clock\");\n+\n+\t    if (id != null)\n+\t      zone.setID(id);\n+\t  }\n       }\n \n     // Try some system specific way\n@@ -189,466 +232,47 @@ private static String readTimeZoneFile(String file)\n   }\n \n   /**\n-   * Tries to read a file as a \"standard\" tzfile and return a time\n-   * zone id string as expected by <code>getDefaultTimeZone(String)</code>.\n-   * If the file doesn't exist, an IOException occurs or it isn't a tzfile\n-   * that can be parsed null is returned.\n+   * Tries to read the time zone name from a file.\n+   * If the file cannot be read or an IOException occurs null is returned.\n    * <p>\n-   * The tzfile structure (as also used by glibc) is described in the Olson\n-   * tz database archive as can be found at\n-   * <code>ftp://elsie.nci.nih.gov/pub/</code>.\n-   * <p>\n-   * At least the following platforms support the tzdata file format\n-   * and /etc/localtime (GNU/Linux, Darwin, Solaris and FreeBSD at\n-   * least). Some systems (like Darwin) don't start the file with the\n-   * required magic bytes 'TZif', this implementation can handle\n-   * that).\n+   * The /etc/sysconfig/clock file is not standard, but a lot of systems\n+   * have it. The file is included by shell scripts and the timezone\n+   * name is defined in ZONE variable.\n+   * This routine should grok it with or without quotes:\n+   * ZONE=America/New_York\n+   * or\n+   * ZONE=\"Europe/London\"\n    */\n-  private static String readtzFile(String file)\n+  private static String readSysconfigClockFile(String file)\n   {\n-    File f = new File(file);\n-    if (!f.exists())\n-      return null;\n-\n-    DataInputStream dis = null;\n+    BufferedReader br = null;\n     try\n       {\n-\tFileInputStream fis = new FileInputStream(f);\n+\tFileInputStream fis = new FileInputStream(file);\n \tBufferedInputStream bis = new BufferedInputStream(fis);\n-\tdis = new DataInputStream(bis);\n-\n-\t// Make sure we are reading a tzfile.\n-\tbyte[] tzif = new byte[5];\n-\tdis.readFully(tzif);\n-\tint tzif2 = 4;\n-\tif (tzif[0] == 'T' && tzif[1] == 'Z'\n-\t    && tzif[2] == 'i' && tzif[3] == 'f')\n-\t  {\n-\t    if (tzif[4] >= '2')\n-\t      tzif2 = 8;\n-\t    // Reserved bytes\n-\t    skipFully(dis, 16 - 1);\n-\t  }\n-\telse\n-\t  // Darwin has tzdata files that don't start with the TZif marker\n-\t  skipFully(dis, 16 - 5);\n-\n-\tString id = null;\n-\tint ttisgmtcnt = dis.readInt();\n-\tint ttisstdcnt = dis.readInt();\n-\tint leapcnt = dis.readInt();\n-\tint timecnt = dis.readInt();\n-\tint typecnt = dis.readInt();\n-\tint charcnt = dis.readInt();\n-\tif (tzif2 == 8)\n-\t  {\n-\t    skipFully(dis, timecnt * (4 + 1) + typecnt * (4 + 1 + 1) + charcnt\n-\t\t\t   + leapcnt * (4 + 4) + ttisgmtcnt + ttisstdcnt);\n-\n-\t    dis.readFully(tzif);\n-\t    if (tzif[0] != 'T' || tzif[1] != 'Z' || tzif[2] != 'i'\n-\t\t|| tzif[3] != 'f' || tzif[4] < '2')\n-\t      return null;\n-\n-\t    // Reserved bytes\n-\t    skipFully(dis, 16 - 1);\n-\t    ttisgmtcnt = dis.readInt();\n-\t    ttisstdcnt = dis.readInt();\n-\t    leapcnt = dis.readInt();\n-\t    timecnt = dis.readInt();\n-\t    typecnt = dis.readInt();\n-\t    charcnt = dis.readInt();\n-\t  }\n-\tif (typecnt > 0)\n-\t  {\n-\t    int seltimecnt = timecnt;\n-\t    if (seltimecnt > 16)\n-\t      seltimecnt = 16;\n-\n-\t    long[] times = new long[seltimecnt];\n-\t    int[] types = new int[seltimecnt];\n-\n-\t    // Transition times\n-\t    skipFully(dis, (timecnt - seltimecnt) * tzif2);\n-\n-\t    for (int i = 0; i < seltimecnt; i++)\n-\t      if (tzif2 == 8)\n-\t\ttimes[i] = dis.readLong();\n-\t      else\n-\t\ttimes[i] = (long) dis.readInt();\n-\n-\t    // Transition types\n-\t    skipFully(dis, timecnt - seltimecnt);\n-\t    for (int i = 0; i < seltimecnt; i++)\n-\t      {\n-\t\ttypes[i] = dis.readByte();\n-\t\tif (types[i] < 0)\n-\t\t  types[i] += 256;\n-\t      }\n-\n-\t    // Get std/dst_offset and dst/non-dst time zone names.\n-\t    int std_abbrind = -1;\n-\t    int dst_abbrind = -1;\n-\t    int std_offset = 0;\n-\t    int dst_offset = 0;\n-\t    int std_ind = -1;\n-\t    int dst_ind = -1;\n-\n-\t    int alternation = 0;\n-\t    if (seltimecnt >= 4 && types[0] != types[1]\n-\t\t&& types[0] < typecnt && types[1] < typecnt)\n-\t      {\n-\t\t// Verify only two types are involved\n-\t\t// in the transitions and they alternate.\n-\t\talternation = 1;\n-\t\tfor (int i = 2; i < seltimecnt; i++)\n-\t\t  if (types[i] != types[i % 2])\n-\t\t    alternation = 0;\n-\t      }\n-\n-\t    // If a timezone previously used DST, but no longer does\n-\t    // (or no longer will in the near future, say 5 years),\n-\t    // then always pick only the std zone type corresponding\n-\t    // to latest applicable transition.\n-\t    if (seltimecnt > 0\n-\t\t&& times[seltimecnt - 1]\n-\t\t   < System.currentTimeMillis() / 1000 + 5 * 365 * 86400)\n-\t      alternation = -1;\n-\n-\t    for (int i = 0; i < typecnt; i++)\n-\t      {\n-\t\t// gmtoff\n-\t\tint offset = dis.readInt();\n-\t\tint dst = dis.readByte();\n-\t\tint abbrind = dis.readByte();\n-\t\tif (dst == 0)\n-\t\t  {\n-\t\t    if (alternation == 0\n-\t\t\t|| (alternation == 1\n-\t\t\t    && (i == types[0] || i == types[1]))\n-\t\t\t|| (alternation == -1 && i == types[seltimecnt - 1]))\n-\t\t      {\n-\t\t\tstd_abbrind = abbrind;\n-\t\t\tstd_offset = offset * -1;\n-\t\t\tstd_ind = i;\n-\t\t      }\n-\t\t  }\n-\t\telse if (alternation >= 0)\n-\t\t  {\n-\t\t    if (alternation == 0 || i == types[0] || i == types[1])\n-\t\t      {\n-\t\t\tdst_abbrind = abbrind;\n-\t\t\tdst_offset = offset * -1;\n-\t\t\tdst_ind = i;\n-\t\t      }\n-\t\t  }\n-\t      }\n-\n-\t    if (std_abbrind >= 0)\n-\t      {\n-\t\tbyte[] names = new byte[charcnt];\n-\t\tdis.readFully(names);\n-\t\tint j = std_abbrind;\n-\t\twhile (j < charcnt && names[j] != 0)\n-\t\t  j++;\n-\n-\t\tString zonename = new String(names, std_abbrind,\n-\t\t\t\t\t     j - std_abbrind, \"ASCII\");\n-\n-\t\tString dst_zonename;\n-\t\tif (dst_abbrind >= 0)\n-\t\t  {\n-\t\t    j = dst_abbrind;\n-\t\t    while (j < charcnt && names[j] != 0)\n-\t\t      j++;\n-\t\t    dst_zonename = new String(names, dst_abbrind,\n-\t\t\t\t\t      j - dst_abbrind, \"ASCII\");\n-\t\t  }\n-\t\telse\n-\t\t  dst_zonename = \"\";\n+\tbr = new BufferedReader(new InputStreamReader(bis));\n \n-\t\tString[] change_spec = { null, null };\n-\t\tif (dst_abbrind >= 0 && alternation > 0)\n-\t\t  {\n-\t\t    // Guess rules for the std->dst and dst->std transitions\n-\t\t    // from the transition times since Epoch.\n-\t\t    // tzdata actually uses only 3 forms of rules:\n-\t\t    // fixed date within a month, e.g. change on April, 5th\n-\t\t    // 1st weekday on or after Nth: change on Sun>=15 in April\n-\t\t    // last weekday in a month: change on lastSun in April\n-\t\t    GregorianCalendar cal\n-\t\t      = new GregorianCalendar (TimeZone.getTimeZone(\"GMT\"));\n-\n-\t\t    int[] values = new int[2 * 11];\n-\t\t    int i;\n-\t\t    for (i = seltimecnt - 1; i >= 0; i--)\n-\t\t      {\n-\t\t\tint base = (i % 2) * 11;\n-\t\t\tint offset = types[i] == dst_ind ? std_offset : dst_offset;\n-\t\t\tcal.setTimeInMillis((times[i] - offset) * 1000);\n-\t\t\tif (i >= seltimecnt - 2)\n-\t\t\t  {\n-\t\t\t    values[base + 0] = cal.get(Calendar.YEAR);\n-\t\t\t    values[base + 1] = cal.get(Calendar.MONTH);\n-\t\t\t    values[base + 2] = cal.get(Calendar.DAY_OF_MONTH);\n-\t\t\t    values[base + 3]\n-\t\t\t      = cal.getActualMaximum(Calendar.DAY_OF_MONTH);\n-\t\t\t    values[base + 4] = cal.get(Calendar.DAY_OF_WEEK);\n-\t\t\t    values[base + 5] = cal.get(Calendar.HOUR_OF_DAY);\n-\t\t\t    values[base + 6] = cal.get(Calendar.MINUTE);\n-\t\t\t    values[base + 7] = cal.get(Calendar.SECOND);\n-\t\t\t    values[base + 8] = values[base + 2]; // Range start\n-\t\t\t    values[base + 9] = values[base + 2]; // Range end\n-\t\t\t    values[base + 10] = 0; // Determined type\n-\t\t\t  }\n-\t\t\telse\n-\t\t\t  {\n-\t\t\t    int year = cal.get(Calendar.YEAR);\n-\t\t\t    int month = cal.get(Calendar.MONTH);\n-\t\t\t    int day_of_month = cal.get(Calendar.DAY_OF_MONTH);\n-\t\t\t    int month_days\n-\t\t\t      = cal.getActualMaximum(Calendar.DAY_OF_MONTH);\n-\t\t\t    int day_of_week = cal.get(Calendar.DAY_OF_WEEK);\n-\t\t\t    int hour = cal.get(Calendar.HOUR_OF_DAY);\n-\t\t\t    int minute = cal.get(Calendar.MINUTE);\n-\t\t\t    int second = cal.get(Calendar.SECOND);\n-\t\t\t    if (year != values[base + 0] - 1\n-\t\t\t\t|| month != values[base + 1]\n-\t\t\t\t|| hour != values[base + 5]\n-\t\t\t\t|| minute != values[base + 6]\n-\t\t\t\t|| second != values[base + 7])\n-\t\t\t      break;\n-\t\t\t    if (day_of_week == values[base + 4])\n-\t\t\t      {\n-\t\t\t\t// Either a Sun>=8 or lastSun rule.\n-\t\t\t\tif (day_of_month < values[base + 8])\n-\t\t\t\t  values[base + 8] = day_of_month;\n-\t\t\t\tif (day_of_month > values[base + 9])\n-\t\t\t\t  values[base + 9] = day_of_month;\n-\t\t\t\tif (values[base + 10] < 0)\n-\t\t\t\t  break;\n-\t\t\t\tif (values[base + 10] == 0)\n-\t\t\t\t  {\n-\t\t\t\t    values[base + 10] = 1;\n-\t\t\t\t    // If day of month > 28, this is\n-\t\t\t\t    // certainly lastSun rule.\n-\t\t\t\t    if (values[base + 2] > 28)\n-\t\t\t\t      values[base + 2] = 3;\n-\t\t\t\t    // If day of month isn't in the last\n-\t\t\t\t    // week, it can't be lastSun rule.\n-\t\t\t\t    else if (values[base + 2]\n-\t\t\t\t\t     <= values[base + 3] - 7)\n-\t\t\t\t      values[base + 3] = 2;\n-\t\t\t\t  }\n-\t\t\t\tif (values[base + 10] == 1)\n-\t\t\t\t  {\n-\t\t\t\t    // If day of month is > 28, this is\n-\t\t\t\t    // certainly lastSun rule.\n-\t\t\t\t    if (day_of_month > 28)\n-\t\t\t\t      values[base + 10] = 3;\n-\t\t\t\t    // If day of month isn't in the last\n-\t\t\t\t    // week, it can't be lastSun rule.\n-\t\t\t\t    else if (day_of_month <= month_days - 7)\n-\t\t\t\t      values[base + 10] = 2;\n-\t\t\t\t  }\n-\t\t\t\telse if ((values[base + 10] == 2\n-\t\t\t\t\t  && day_of_month > 28)\n-\t\t\t\t\t || (values[base + 10] == 3\n-\t\t\t\t\t     && day_of_month\n-\t\t\t\t\t\t<= month_days - 7))\n-\t\t\t\t  break;\n-\t\t\t      }\n-\t\t\t    else\n-\t\t\t      {\n-\t\t\t\t// Must be fixed day in month rule.\n-\t\t\t\tif (day_of_month != values[base + 2]\n-\t\t\t\t    || values[base + 10] > 0)\n-\t\t\t\t  break;\n-\t\t\t\tvalues[base + 4] = day_of_week;\n-\t\t\t\tvalues[base + 10] = -1;\n-\t\t\t      }\n-\t\t\t    values[base + 0] -= 1;\n-\t\t\t  }\n-\t\t      }\n-\t\t    if (i < 0)\n-\t\t      {\n-\t\t\tfor (i = 0; i < 2; i++)\n-\t\t\t  {\n-\t\t\t    int base = 11 * i;\n-\t\t\t    if (values[base + 10] == 0)\n-\t\t\t      continue;\n-\t\t\t    if (values[base + 10] == -1)\n-\t\t\t      {\n-\t\t\t\tint[] dayCount\n-\t\t\t\t  = { 0, 31, 59, 90, 120, 151,\n-\t\t\t\t      181, 212, 243, 273, 304, 334 };\n-\t\t\t\tint d = dayCount[values[base + 1]\n-\t\t\t\t\t\t - Calendar.JANUARY];\n-\t\t\t\td += values[base + 2];\n-\t\t\t\tchange_spec[i] = \",J\" + Integer.toString(d);\n-\t\t\t      }\n-\t\t\t    else if (values[base + 10] == 2)\n-\t\t\t      {\n-\t\t\t\t// If we haven't seen all days of the week,\n-\t\t\t\t// we can't be sure what the rule really is.\n-\t\t\t\tif (values[base + 8] + 6 != values[base + 9])\n-\t\t\t\t  continue;\n-\n-\t\t\t\t// FIXME: Sun >= 5 is representable in\n-\t\t\t\t// SimpleTimeZone, but not in POSIX TZ env\n-\t\t\t\t// strings.  Should we change readtzFile\n-\t\t\t\t// to actually return a SimpleTimeZone\n-\t\t\t\t// rather than POSIX TZ string?\n-\t\t\t\tif ((values[base + 8] % 7) != 1)\n-\t\t\t\t  continue;\n-\n-\t\t\t\tint d;\n-\t\t\t\td = values[base + 1] - Calendar.JANUARY + 1;\n-\t\t\t\tchange_spec[i] = \",M\" + Integer.toString(d);\n-\t\t\t\td = (values[base + 8] + 6) / 7;\n-\t\t\t\tchange_spec[i] += \".\" + Integer.toString(d);\n-\t\t\t\td = values[base + 4] - Calendar.SUNDAY;\n-\t\t\t\tchange_spec[i] += \".\" + Integer.toString(d);\n-\t\t\t      }\n-\t\t\t    else\n-\t\t\t      {\n-\t\t\t\t// If we don't know whether this is lastSun or\n-\t\t\t\t// Sun >= 22 rule.  That can be either because\n-\t\t\t\t// there was insufficient number of\n-\t\t\t\t// transitions, or February, where it is quite\n-\t\t\t\t// probable we haven't seen any 29th dates.\n-\t\t\t\t// For February, assume lastSun rule, otherwise\n-\t\t\t\t// punt.\n-\t\t\t\tif (values[base + 10] == 1\n-\t\t\t\t    && values[base + 1] != Calendar.FEBRUARY)\n-\t\t\t\t  continue;\n-\n-\t\t\t\tint d;\n-\t\t\t\td = values[base + 1] - Calendar.JANUARY + 1;\n-\t\t\t\tchange_spec[i] = \",M\" + Integer.toString(d);\n-\t\t\t\td = values[base + 4] - Calendar.SUNDAY;\n-\t\t\t\tchange_spec[i] += \".5.\" + Integer.toString(d);\n-\t\t\t      }\n-\n-\t\t\t    // Don't add time specification if time is\n-\t\t\t    // 02:00:00.\n-\t\t\t    if (values[base + 5] != 2\n-\t\t\t\t|| values[base + 6] != 0\n-\t\t\t\t|| values[base + 7] != 0)\n-\t\t\t      {\n-\t\t\t\tint d = values[base + 5];\n-\t\t\t\tchange_spec[i] += \"/\" + Integer.toString(d);\n-\t\t\t\tif (values[base + 6] != 0\n-\t\t\t\t    || values[base + 7] != 0)\n-\t\t\t\t  {\n-\t\t\t\t    d = values[base + 6];\n-\t\t\t\t    if (d < 10)\n-\t\t\t\t      change_spec[i]\n-\t\t\t\t\t+= \":0\" + Integer.toString(d);\n-\t\t\t\t    else\n-\t\t\t\t      change_spec[i]\n-\t\t\t\t\t+= \":\" + Integer.toString(d);\n-\t\t\t\t    d = values[base + 7];\n-\t\t\t\t    if (d >= 10)\n-\t\t\t\t      change_spec[i]\n-\t\t\t\t\t+= \":\" + Integer.toString(d);\n-\t\t\t\t    else if (d > 0)\n-\t\t\t\t      change_spec[i]\n-\t\t\t\t\t+= \":0\" + Integer.toString(d);\n-\t\t\t\t  }\n-\t\t\t      }\n-\t\t\t  }\n-\t\t\tif (types[0] == std_ind)\n-\t\t\t  {\n-\t\t\t    String tmp = change_spec[0];\n-\t\t\t    change_spec[0] = change_spec[1];\n-\t\t\t    change_spec[1] = tmp;\n-\t\t\t  }\n-\t\t      }\n-\t\t  }\n-\n-\t\t// Only use gmt offset when necessary.\n-\t\t// Also special case GMT+/- timezones.\n-\t\tString offset_string, dst_offset_string = \"\";\n-\t\tif (dst_abbrind < 0\n-\t\t    && (std_offset == 0\n-\t\t\t|| zonename.startsWith(\"GMT+\")\n-\t\t\t|| zonename.startsWith(\"GMT-\")))\n-\t\t  offset_string = \"\";\n-\t\telse\n-\t\t  {\n-\t\t    offset_string = Integer.toString(std_offset / 3600);\n-\t\t    int seconds = std_offset % 3600;\n-\t\t    if (seconds != 0)\n-\t\t      {\n-\t\t\tif (seconds < 0)\n-\t\t\t  seconds *= -1;\n-\t\t\tif (seconds < 600)\n-\t\t\t  offset_string\n-\t\t\t    += \":0\" + Integer.toString(seconds / 60);\n-\t\t\telse\n-\t\t\t  offset_string\n-\t\t\t    += \":\" + Integer.toString(seconds / 60);\n-\t\t\tseconds = seconds % 60;\n-\t\t\tif (seconds >= 10)\n-\t\t\t  offset_string\n-\t\t\t    += \":\" + Integer.toString(seconds);\n-\t\t\telse if (seconds > 0)\n-\t\t\t  offset_string\n-\t\t\t    += \":0\" + Integer.toString(seconds);\n-\t\t      }\n-\t\t    if (dst_abbrind >= 0\n-\t\t\t&& dst_offset != std_offset - 3600)\n-\t\t      {\n-\t\t\tdst_offset_string\n-\t\t\t  = Integer.toString(dst_offset / 3600);\n-\t\t\tseconds = dst_offset % 3600;\n-\t\t\tif (seconds != 0)\n-\t\t\t  {\n-\t\t\t    if (seconds < 0)\n-\t\t\t      seconds *= -1;\n-\t\t\t    if (seconds < 600)\n-\t\t\t      dst_offset_string\n-\t\t\t\t+= \":0\" + Integer.toString(seconds / 60);\n-\t\t\t    else\n-\t\t\t      dst_offset_string\n-\t\t\t\t+= \":\" + Integer.toString(seconds / 60);\n-\t\t\t    seconds = seconds % 60;\n-\t\t\t    if (seconds >= 10)\n-\t\t\t      dst_offset_string\n-\t\t\t\t+= \":\" + Integer.toString(seconds);\n-\t\t\t    else if (seconds > 0)\n-\t\t\t      dst_offset_string\n-\t\t\t\t+= \":0\" + Integer.toString(seconds);\n-\t\t\t  }\n-\t\t      }\n-\t\t  }\n-\n-\t\tif (dst_abbrind < 0)\n-\t\t  id = zonename + offset_string;\n-\t\telse if (change_spec[0] != null && change_spec[1] != null)\n-\t\t  id = zonename + offset_string + dst_zonename\n-\t\t       + dst_offset_string + change_spec[0] + change_spec[1];\n-\t      }\n-\t    else if (tzif2 == 8)\n-\t      skipFully(dis, charcnt);\n-\t  }\n-\telse if (tzif2 == 8)\n-\t  skipFully(dis, timecnt * (8 + 1) + typecnt * (4 + 1 + 1) + charcnt);\n-\n-\tif (tzif2 == 8)\n+\tfor (String line = br.readLine(); line != null; line = br.readLine())\n \t  {\n-\t    // Skip over the rest of 64-bit data\n-\t    skipFully(dis, leapcnt * (8 + 4) + ttisgmtcnt + ttisstdcnt);\n-\t    if (dis.readByte() == '\\n')\n+\t    line = line.trim();\n+\t    if (line.length() < 8 || !line.startsWith(\"ZONE=\"))\n+\t      continue;\n+\t    int posstart = 6;\n+\t    int posend;\n+\t    if (line.charAt(5) == '\"')\n+\t      posend = line.indexOf('\"', 6);\n+\t    else if (line.charAt(5) == '\\'')\n+\t      posend = line.indexOf('\\'', 6);\n+\t    else\n \t      {\n-\t\tString posixtz = dis.readLine();\n-\t\tif (posixtz.length() > 0)\n-\t\t  id = posixtz;\n+\t\tposstart = 5;\n+\t\tposend = line.length();\n \t      }\n+\t    if (posend < 0)\n+\t      return null;\n+\t    return line.substring(posstart, posend);\n \t  }\n-\n-\treturn id;\n+\treturn null;\n       }\n     catch (IOException ioe)\n       {\n@@ -659,31 +283,15 @@ else if (tzif2 == 8)\n       {\n \ttry\n \t  {\n-\t    if (dis != null)\n-\t      dis.close();\n+\t    if (br != null)\n+\t      br.close();\n \t  }\n-\tcatch(IOException ioe)\n+\tcatch (IOException ioe)\n \t  {\n \t    // Error while close, nothing we can do.\n \t  }\n       }\n   }\n-  \n-  /**\n-   * Skips the requested number of bytes in the given InputStream.\n-   * Throws EOFException if not enough bytes could be skipped.\n-   * Negative numbers of bytes to skip are ignored.\n-   */\n-  private static void skipFully(InputStream is, long l) throws IOException\n-  {\n-    while (l > 0)\n-      {\n-        long k = is.skip(l);\n-        if (k <= 0)\n-          throw new EOFException();\n-        l -= k;\n-      }\n-  }\n \n   /**\n    * Tries to get the system time zone id through native code."}, {"sha": "5d64094c815a19610e25a28f33bf406901dbc534", "filename": "libjava/posix.cc", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3502aa8d46d9cd008916170a635b2bf3a5d5125/libjava%2Fposix.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3502aa8d46d9cd008916170a635b2bf3a5d5125/libjava%2Fposix.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fposix.cc?ref=b3502aa8d46d9cd008916170a635b2bf3a5d5125", "patch": "@@ -139,6 +139,10 @@ _Jv_platform_initProperties (java::util::Properties* newprops)\n   if (! tmpdir)\n     tmpdir = \"/tmp\";\n   SET (\"java.io.tmpdir\", tmpdir);\n+  const char *zoneinfodir = ::getenv(\"TZDATA\");\n+  if (! zoneinfodir)\n+    zoneinfodir = \"/usr/share/zoneinfo\";\n+  SET (\"gnu.java.util.zoneinfo.dir\", zoneinfodir);\n }\n \n static inline void"}, {"sha": "77e7796ff339693f3799a31ac3cdd9b302ebf9d3", "filename": "libjava/sources.am", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3502aa8d46d9cd008916170a635b2bf3a5d5125/libjava%2Fsources.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3502aa8d46d9cd008916170a635b2bf3a5d5125/libjava%2Fsources.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fsources.am?ref=b3502aa8d46d9cd008916170a635b2bf3a5d5125", "patch": "@@ -2110,7 +2110,8 @@ gnu/java/text.list: $(gnu_java_text_source_files)\n gnu_java_util_source_files = \\\n classpath/gnu/java/util/DoubleEnumeration.java \\\n classpath/gnu/java/util/EmptyEnumeration.java \\\n-classpath/gnu/java/util/WeakIdentityHashMap.java\n+classpath/gnu/java/util/WeakIdentityHashMap.java \\\n+classpath/gnu/java/util/ZoneInfo.java\n \n gnu_java_util_header_files = $(patsubst classpath/%,%,$(patsubst %.java,%.h,$(gnu_java_util_source_files)))\n "}]}