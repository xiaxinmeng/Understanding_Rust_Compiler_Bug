{"sha": "8c154b65579602aad087eff7229a460412b9ed8c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGMxNTRiNjU1Nzk2MDJhYWQwODdlZmY3MjI5YTQ2MDQxMmI5ZWQ4Yw==", "commit": {"author": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2008-04-20T19:56:07Z"}, "committer": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2008-04-20T19:56:07Z"}, "message": "re PR fortran/35960 (run time abort with assignment of RESHAPEd zero sized array)\n\n2008-04-20  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR libfortran/35960\n\t* intrinsics/reshape_generic.c (reshape_internal): If the size\n\tof the resized array is zero, as determined by the SHAPE\n\targument, return early.\n\t* m4/reshape.m4:  Likewise.\n\t* generated/reshape_i4.c:  Regererated.\n\t* generated/reshape_i8.c:  Regenerated.\n\t* generated/reshape_i16.c:  Regenerated.\n\t* generated/reshape_r4.c:  Regenerated.\n\t* generated/reshape_r8.c:  Regenerated.\n\t* generated/reshape_r10.c:  Regenerated.\n\t* generated/reshape_r16.c:  Regenerated.\n\t* generated/reshape_c4.c:  Regenerated.\n\t* generated/reshape_c8.c:  Regenerated.\n\t* generated/reshape_c10.c:  Regenerated.\n\t* generated/reshape_c16.c:  Regenerated.\n\n2008-04-20  Thomas Koenig  <tkoenig@gcc.gnu.org>\n\n\tPR libfortran/35960\n\t* gfortran.dg/reshape_zerosize_1.f90:  New file.\n\nFrom-SVN: r134490", "tree": {"sha": "a0f091b6d4e9ffd907ca682662f415fcb11b9fd8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a0f091b6d4e9ffd907ca682662f415fcb11b9fd8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8c154b65579602aad087eff7229a460412b9ed8c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c154b65579602aad087eff7229a460412b9ed8c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8c154b65579602aad087eff7229a460412b9ed8c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c154b65579602aad087eff7229a460412b9ed8c/comments", "author": null, "committer": null, "parents": [{"sha": "eea05d39c799880df753e9b74d2d96e86215c46e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eea05d39c799880df753e9b74d2d96e86215c46e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eea05d39c799880df753e9b74d2d96e86215c46e"}], "stats": {"total": 489, "additions": 386, "deletions": 103}, "files": [{"sha": "d2435caaa72cb25d947845b7d5e293a4f9f16eac", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c154b65579602aad087eff7229a460412b9ed8c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c154b65579602aad087eff7229a460412b9ed8c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8c154b65579602aad087eff7229a460412b9ed8c", "patch": "@@ -1,3 +1,8 @@\n+2008-04-20  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR libfortran/35960\n+\t* gfortran.dg/reshape_zerosize_1.f90:  New file.\n+\n 2008-04-20  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gnat.dg/alignment6.adb: New test."}, {"sha": "61896ab97b4714487330734b9c5e2c6bd1d66d1d", "filename": "gcc/testsuite/gfortran.dg/reshape_zerosize_1.f90", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c154b65579602aad087eff7229a460412b9ed8c/gcc%2Ftestsuite%2Fgfortran.dg%2Freshape_zerosize_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c154b65579602aad087eff7229a460412b9ed8c/gcc%2Ftestsuite%2Fgfortran.dg%2Freshape_zerosize_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Freshape_zerosize_1.f90?ref=8c154b65579602aad087eff7229a460412b9ed8c", "patch": "@@ -0,0 +1,39 @@\n+!  { dg-do run }\n+!  PR 35960 - there was a run-time abort when the SHAPE argument to\n+!  RESHAPE was zero-sized.\n+!  Test case contributed by Dick Henderson.\n+      program try_gf1065\n+\n+\n+! fails on Windows XP\n+! gcc version 4.4.0 20080312 (experimental) [trunk revision 133139]\n+\n+\n+      call       gf1065(1,  2,  3,  4,  7,  8,  9)\n+      end\n+\n+      SUBROUTINE GF1065(nf1,nf2,nf3,nf4,nf7,nf8,nf9)\n+\n+      REAL RDA(10,9)\n+      REAL RCA1(90)\n+      integer ila(2)\n+      RDA(NF9:NF8, NF7:NF3) = RESHAPE(RCA1,(/0,0/), (/1.0/),(/2,1/))\n+\n+      rDA(NF9:NF8, NF7:NF3) = RESHAPE(rCA1,(/0,0/),ORDER=(/2,1/))\n+\n+      ILA(1) = 5\n+      ILA(2) = 0\n+      rDA(NF4:NF8, NF7:NF3) = RESHAPE(rcA1,ILA)\n+\n+      RdA(NF4:NF8, NF7:NF3) = RESHAPE(RcA1,ILA,PAD=(/-1.0/))\n+\n+      ILA(1) = 0\n+      ILA(2) = 5\n+      RdA(NF9:NF8,NF4:NF8)=RESHAPE(RcA1,ILA,(/-1.0/),(/NF2,NF1/))\n+\n+      ILA(1) = 5\n+      ILA(2) = 0\n+      RdA(NF4:NF8, NF7:NF3) = RESHAPE(RcA1,ILA,ORDER=(/NF1,NF2/))\n+\n+\n+      END SUBROUTINE"}, {"sha": "922eef795d25a8b3bc2efab291dfba6f78f4e01c", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c154b65579602aad087eff7229a460412b9ed8c/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c154b65579602aad087eff7229a460412b9ed8c/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=8c154b65579602aad087eff7229a460412b9ed8c", "patch": "@@ -1,3 +1,22 @@\n+2008-04-20  Thomas Koenig  <tkoenig@gcc.gnu.org>\n+\n+\tPR libfortran/35960\n+\t* intrinsics/reshape_generic.c (reshape_internal): If the size\n+\tof the resized array is zero, as determined by the SHAPE\n+\targument, return early.\n+\t* m4/reshape.m4:  Likewise.\n+\t* generated/reshape_i4.c:  Regererated.\n+\t* generated/reshape_i8.c:  Regenerated.\n+\t* generated/reshape_i16.c:  Regenerated.\n+\t* generated/reshape_r4.c:  Regenerated.\n+\t* generated/reshape_r8.c:  Regenerated.\n+\t* generated/reshape_r10.c:  Regenerated.\n+\t* generated/reshape_r16.c:  Regenerated.\n+\t* generated/reshape_c4.c:  Regenerated.\n+\t* generated/reshape_c8.c:  Regenerated.\n+\t* generated/reshape_c10.c:  Regenerated.\n+\t* generated/reshape_c16.c:  Regenerated.\n+\n 2008-04-18  Paolo Bonzini  <bonzini@gnu.org>\n \n \tPR bootstrap/35457"}, {"sha": "28cad4a0b6ed368eea8cc3ef20a9201aa39f5fa7", "filename": "libgfortran/generated/reshape_c10.c", "status": "modified", "additions": 25, "deletions": 8, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c154b65579602aad087eff7229a460412b9ed8c/libgfortran%2Fgenerated%2Freshape_c10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c154b65579602aad087eff7229a460412b9ed8c/libgfortran%2Fgenerated%2Freshape_c10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Freshape_c10.c?ref=8c154b65579602aad087eff7229a460412b9ed8c", "patch": "@@ -81,16 +81,32 @@ reshape_c10 (gfc_array_c10 * const restrict ret,\n   const GFC_COMPLEX_10 *src;\n   int n;\n   int dim;\n-  int sempty, pempty;\n+  int sempty, pempty, shape_empty;\n+  index_type shape_data[GFC_MAX_DIMENSIONS];\n+\n+  rdim = shape->dim[0].ubound - shape->dim[0].lbound + 1;\n+  if (rdim != GFC_DESCRIPTOR_RANK(ret))\n+    runtime_error(\"rank of return array incorrect in RESHAPE intrinsic\");\n+\n+  shape_empty = 0;\n+\n+  for (n = 0; n < rdim; n++)\n+    {\n+      shape_data[n] = shape->data[n * shape->dim[0].stride];\n+      if (shape_data[n] <= 0)\n+      {\n+        shape_data[n] = 0;\n+\tshape_empty = 1;\n+      }\n+    }\n \n   if (ret->data == NULL)\n     {\n-      rdim = shape->dim[0].ubound - shape->dim[0].lbound + 1;\n       rs = 1;\n       for (n = 0; n < rdim; n++)\n \t{\n \t  ret->dim[n].lbound = 0;\n-\t  rex = shape->data[n * shape->dim[0].stride];\n+\t  rex = shape_data[n];\n \t  ret->dim[n].ubound =  rex - 1;\n \t  ret->dim[n].stride = rs;\n \t  rs *= rex;\n@@ -99,10 +115,9 @@ reshape_c10 (gfc_array_c10 * const restrict ret,\n       ret->data = internal_malloc_size ( rs * sizeof (GFC_COMPLEX_10));\n       ret->dtype = (source->dtype & ~GFC_DTYPE_RANK_MASK) | rdim;\n     }\n-  else\n-    {\n-      rdim = GFC_DESCRIPTOR_RANK (ret);\n-    }\n+\n+  if (shape_empty)\n+    return;\n \n   rsize = 1;\n   for (n = 0; n < rdim; n++)\n@@ -115,8 +130,10 @@ reshape_c10 (gfc_array_c10 * const restrict ret,\n       rcount[n] = 0;\n       rstride[n] = ret->dim[dim].stride;\n       rextent[n] = ret->dim[dim].ubound + 1 - ret->dim[dim].lbound;\n+      if (rextent[n] < 0)\n+        rextent[n] == 0;\n \n-      if (rextent[n] != shape->data[dim * shape->dim[0].stride])\n+      if (rextent[n] != shape_data[dim])\n         runtime_error (\"shape and target do not conform\");\n \n       if (rsize == rstride[n])"}, {"sha": "ce658dae66870d83004a4815f4d38adaf0460441", "filename": "libgfortran/generated/reshape_c16.c", "status": "modified", "additions": 25, "deletions": 8, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c154b65579602aad087eff7229a460412b9ed8c/libgfortran%2Fgenerated%2Freshape_c16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c154b65579602aad087eff7229a460412b9ed8c/libgfortran%2Fgenerated%2Freshape_c16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Freshape_c16.c?ref=8c154b65579602aad087eff7229a460412b9ed8c", "patch": "@@ -81,16 +81,32 @@ reshape_c16 (gfc_array_c16 * const restrict ret,\n   const GFC_COMPLEX_16 *src;\n   int n;\n   int dim;\n-  int sempty, pempty;\n+  int sempty, pempty, shape_empty;\n+  index_type shape_data[GFC_MAX_DIMENSIONS];\n+\n+  rdim = shape->dim[0].ubound - shape->dim[0].lbound + 1;\n+  if (rdim != GFC_DESCRIPTOR_RANK(ret))\n+    runtime_error(\"rank of return array incorrect in RESHAPE intrinsic\");\n+\n+  shape_empty = 0;\n+\n+  for (n = 0; n < rdim; n++)\n+    {\n+      shape_data[n] = shape->data[n * shape->dim[0].stride];\n+      if (shape_data[n] <= 0)\n+      {\n+        shape_data[n] = 0;\n+\tshape_empty = 1;\n+      }\n+    }\n \n   if (ret->data == NULL)\n     {\n-      rdim = shape->dim[0].ubound - shape->dim[0].lbound + 1;\n       rs = 1;\n       for (n = 0; n < rdim; n++)\n \t{\n \t  ret->dim[n].lbound = 0;\n-\t  rex = shape->data[n * shape->dim[0].stride];\n+\t  rex = shape_data[n];\n \t  ret->dim[n].ubound =  rex - 1;\n \t  ret->dim[n].stride = rs;\n \t  rs *= rex;\n@@ -99,10 +115,9 @@ reshape_c16 (gfc_array_c16 * const restrict ret,\n       ret->data = internal_malloc_size ( rs * sizeof (GFC_COMPLEX_16));\n       ret->dtype = (source->dtype & ~GFC_DTYPE_RANK_MASK) | rdim;\n     }\n-  else\n-    {\n-      rdim = GFC_DESCRIPTOR_RANK (ret);\n-    }\n+\n+  if (shape_empty)\n+    return;\n \n   rsize = 1;\n   for (n = 0; n < rdim; n++)\n@@ -115,8 +130,10 @@ reshape_c16 (gfc_array_c16 * const restrict ret,\n       rcount[n] = 0;\n       rstride[n] = ret->dim[dim].stride;\n       rextent[n] = ret->dim[dim].ubound + 1 - ret->dim[dim].lbound;\n+      if (rextent[n] < 0)\n+        rextent[n] == 0;\n \n-      if (rextent[n] != shape->data[dim * shape->dim[0].stride])\n+      if (rextent[n] != shape_data[dim])\n         runtime_error (\"shape and target do not conform\");\n \n       if (rsize == rstride[n])"}, {"sha": "fd33a954a06b8599eed2c0dd7d0551e4870e18de", "filename": "libgfortran/generated/reshape_c4.c", "status": "modified", "additions": 25, "deletions": 8, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c154b65579602aad087eff7229a460412b9ed8c/libgfortran%2Fgenerated%2Freshape_c4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c154b65579602aad087eff7229a460412b9ed8c/libgfortran%2Fgenerated%2Freshape_c4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Freshape_c4.c?ref=8c154b65579602aad087eff7229a460412b9ed8c", "patch": "@@ -81,16 +81,32 @@ reshape_c4 (gfc_array_c4 * const restrict ret,\n   const GFC_COMPLEX_4 *src;\n   int n;\n   int dim;\n-  int sempty, pempty;\n+  int sempty, pempty, shape_empty;\n+  index_type shape_data[GFC_MAX_DIMENSIONS];\n+\n+  rdim = shape->dim[0].ubound - shape->dim[0].lbound + 1;\n+  if (rdim != GFC_DESCRIPTOR_RANK(ret))\n+    runtime_error(\"rank of return array incorrect in RESHAPE intrinsic\");\n+\n+  shape_empty = 0;\n+\n+  for (n = 0; n < rdim; n++)\n+    {\n+      shape_data[n] = shape->data[n * shape->dim[0].stride];\n+      if (shape_data[n] <= 0)\n+      {\n+        shape_data[n] = 0;\n+\tshape_empty = 1;\n+      }\n+    }\n \n   if (ret->data == NULL)\n     {\n-      rdim = shape->dim[0].ubound - shape->dim[0].lbound + 1;\n       rs = 1;\n       for (n = 0; n < rdim; n++)\n \t{\n \t  ret->dim[n].lbound = 0;\n-\t  rex = shape->data[n * shape->dim[0].stride];\n+\t  rex = shape_data[n];\n \t  ret->dim[n].ubound =  rex - 1;\n \t  ret->dim[n].stride = rs;\n \t  rs *= rex;\n@@ -99,10 +115,9 @@ reshape_c4 (gfc_array_c4 * const restrict ret,\n       ret->data = internal_malloc_size ( rs * sizeof (GFC_COMPLEX_4));\n       ret->dtype = (source->dtype & ~GFC_DTYPE_RANK_MASK) | rdim;\n     }\n-  else\n-    {\n-      rdim = GFC_DESCRIPTOR_RANK (ret);\n-    }\n+\n+  if (shape_empty)\n+    return;\n \n   rsize = 1;\n   for (n = 0; n < rdim; n++)\n@@ -115,8 +130,10 @@ reshape_c4 (gfc_array_c4 * const restrict ret,\n       rcount[n] = 0;\n       rstride[n] = ret->dim[dim].stride;\n       rextent[n] = ret->dim[dim].ubound + 1 - ret->dim[dim].lbound;\n+      if (rextent[n] < 0)\n+        rextent[n] == 0;\n \n-      if (rextent[n] != shape->data[dim * shape->dim[0].stride])\n+      if (rextent[n] != shape_data[dim])\n         runtime_error (\"shape and target do not conform\");\n \n       if (rsize == rstride[n])"}, {"sha": "d23cf88c0a34b2011f769ed81a912c9f5b2a6cf4", "filename": "libgfortran/generated/reshape_c8.c", "status": "modified", "additions": 25, "deletions": 8, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c154b65579602aad087eff7229a460412b9ed8c/libgfortran%2Fgenerated%2Freshape_c8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c154b65579602aad087eff7229a460412b9ed8c/libgfortran%2Fgenerated%2Freshape_c8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Freshape_c8.c?ref=8c154b65579602aad087eff7229a460412b9ed8c", "patch": "@@ -81,16 +81,32 @@ reshape_c8 (gfc_array_c8 * const restrict ret,\n   const GFC_COMPLEX_8 *src;\n   int n;\n   int dim;\n-  int sempty, pempty;\n+  int sempty, pempty, shape_empty;\n+  index_type shape_data[GFC_MAX_DIMENSIONS];\n+\n+  rdim = shape->dim[0].ubound - shape->dim[0].lbound + 1;\n+  if (rdim != GFC_DESCRIPTOR_RANK(ret))\n+    runtime_error(\"rank of return array incorrect in RESHAPE intrinsic\");\n+\n+  shape_empty = 0;\n+\n+  for (n = 0; n < rdim; n++)\n+    {\n+      shape_data[n] = shape->data[n * shape->dim[0].stride];\n+      if (shape_data[n] <= 0)\n+      {\n+        shape_data[n] = 0;\n+\tshape_empty = 1;\n+      }\n+    }\n \n   if (ret->data == NULL)\n     {\n-      rdim = shape->dim[0].ubound - shape->dim[0].lbound + 1;\n       rs = 1;\n       for (n = 0; n < rdim; n++)\n \t{\n \t  ret->dim[n].lbound = 0;\n-\t  rex = shape->data[n * shape->dim[0].stride];\n+\t  rex = shape_data[n];\n \t  ret->dim[n].ubound =  rex - 1;\n \t  ret->dim[n].stride = rs;\n \t  rs *= rex;\n@@ -99,10 +115,9 @@ reshape_c8 (gfc_array_c8 * const restrict ret,\n       ret->data = internal_malloc_size ( rs * sizeof (GFC_COMPLEX_8));\n       ret->dtype = (source->dtype & ~GFC_DTYPE_RANK_MASK) | rdim;\n     }\n-  else\n-    {\n-      rdim = GFC_DESCRIPTOR_RANK (ret);\n-    }\n+\n+  if (shape_empty)\n+    return;\n \n   rsize = 1;\n   for (n = 0; n < rdim; n++)\n@@ -115,8 +130,10 @@ reshape_c8 (gfc_array_c8 * const restrict ret,\n       rcount[n] = 0;\n       rstride[n] = ret->dim[dim].stride;\n       rextent[n] = ret->dim[dim].ubound + 1 - ret->dim[dim].lbound;\n+      if (rextent[n] < 0)\n+        rextent[n] == 0;\n \n-      if (rextent[n] != shape->data[dim * shape->dim[0].stride])\n+      if (rextent[n] != shape_data[dim])\n         runtime_error (\"shape and target do not conform\");\n \n       if (rsize == rstride[n])"}, {"sha": "c9b3694c5deb83ac4d05b44e48d3df6c1c38cc2d", "filename": "libgfortran/generated/reshape_i16.c", "status": "modified", "additions": 25, "deletions": 8, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c154b65579602aad087eff7229a460412b9ed8c/libgfortran%2Fgenerated%2Freshape_i16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c154b65579602aad087eff7229a460412b9ed8c/libgfortran%2Fgenerated%2Freshape_i16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Freshape_i16.c?ref=8c154b65579602aad087eff7229a460412b9ed8c", "patch": "@@ -81,16 +81,32 @@ reshape_16 (gfc_array_i16 * const restrict ret,\n   const GFC_INTEGER_16 *src;\n   int n;\n   int dim;\n-  int sempty, pempty;\n+  int sempty, pempty, shape_empty;\n+  index_type shape_data[GFC_MAX_DIMENSIONS];\n+\n+  rdim = shape->dim[0].ubound - shape->dim[0].lbound + 1;\n+  if (rdim != GFC_DESCRIPTOR_RANK(ret))\n+    runtime_error(\"rank of return array incorrect in RESHAPE intrinsic\");\n+\n+  shape_empty = 0;\n+\n+  for (n = 0; n < rdim; n++)\n+    {\n+      shape_data[n] = shape->data[n * shape->dim[0].stride];\n+      if (shape_data[n] <= 0)\n+      {\n+        shape_data[n] = 0;\n+\tshape_empty = 1;\n+      }\n+    }\n \n   if (ret->data == NULL)\n     {\n-      rdim = shape->dim[0].ubound - shape->dim[0].lbound + 1;\n       rs = 1;\n       for (n = 0; n < rdim; n++)\n \t{\n \t  ret->dim[n].lbound = 0;\n-\t  rex = shape->data[n * shape->dim[0].stride];\n+\t  rex = shape_data[n];\n \t  ret->dim[n].ubound =  rex - 1;\n \t  ret->dim[n].stride = rs;\n \t  rs *= rex;\n@@ -99,10 +115,9 @@ reshape_16 (gfc_array_i16 * const restrict ret,\n       ret->data = internal_malloc_size ( rs * sizeof (GFC_INTEGER_16));\n       ret->dtype = (source->dtype & ~GFC_DTYPE_RANK_MASK) | rdim;\n     }\n-  else\n-    {\n-      rdim = GFC_DESCRIPTOR_RANK (ret);\n-    }\n+\n+  if (shape_empty)\n+    return;\n \n   rsize = 1;\n   for (n = 0; n < rdim; n++)\n@@ -115,8 +130,10 @@ reshape_16 (gfc_array_i16 * const restrict ret,\n       rcount[n] = 0;\n       rstride[n] = ret->dim[dim].stride;\n       rextent[n] = ret->dim[dim].ubound + 1 - ret->dim[dim].lbound;\n+      if (rextent[n] < 0)\n+        rextent[n] == 0;\n \n-      if (rextent[n] != shape->data[dim * shape->dim[0].stride])\n+      if (rextent[n] != shape_data[dim])\n         runtime_error (\"shape and target do not conform\");\n \n       if (rsize == rstride[n])"}, {"sha": "4a55b68fed6957fe3013921b0b5518a48c2bb29d", "filename": "libgfortran/generated/reshape_i4.c", "status": "modified", "additions": 25, "deletions": 8, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c154b65579602aad087eff7229a460412b9ed8c/libgfortran%2Fgenerated%2Freshape_i4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c154b65579602aad087eff7229a460412b9ed8c/libgfortran%2Fgenerated%2Freshape_i4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Freshape_i4.c?ref=8c154b65579602aad087eff7229a460412b9ed8c", "patch": "@@ -81,16 +81,32 @@ reshape_4 (gfc_array_i4 * const restrict ret,\n   const GFC_INTEGER_4 *src;\n   int n;\n   int dim;\n-  int sempty, pempty;\n+  int sempty, pempty, shape_empty;\n+  index_type shape_data[GFC_MAX_DIMENSIONS];\n+\n+  rdim = shape->dim[0].ubound - shape->dim[0].lbound + 1;\n+  if (rdim != GFC_DESCRIPTOR_RANK(ret))\n+    runtime_error(\"rank of return array incorrect in RESHAPE intrinsic\");\n+\n+  shape_empty = 0;\n+\n+  for (n = 0; n < rdim; n++)\n+    {\n+      shape_data[n] = shape->data[n * shape->dim[0].stride];\n+      if (shape_data[n] <= 0)\n+\t{\n+          shape_data[n] = 0;\n+\t  shape_empty = 1;\n+        }\n+    }\n \n   if (ret->data == NULL)\n     {\n-      rdim = shape->dim[0].ubound - shape->dim[0].lbound + 1;\n       rs = 1;\n       for (n = 0; n < rdim; n++)\n \t{\n \t  ret->dim[n].lbound = 0;\n-\t  rex = shape->data[n * shape->dim[0].stride];\n+\t  rex = shape_data[n];\n \t  ret->dim[n].ubound =  rex - 1;\n \t  ret->dim[n].stride = rs;\n \t  rs *= rex;\n@@ -99,10 +115,9 @@ reshape_4 (gfc_array_i4 * const restrict ret,\n       ret->data = internal_malloc_size ( rs * sizeof (GFC_INTEGER_4));\n       ret->dtype = (source->dtype & ~GFC_DTYPE_RANK_MASK) | rdim;\n     }\n-  else\n-    {\n-      rdim = GFC_DESCRIPTOR_RANK (ret);\n-    }\n+\n+  if (shape_empty)\n+    return;\n \n   rsize = 1;\n   for (n = 0; n < rdim; n++)\n@@ -115,8 +130,10 @@ reshape_4 (gfc_array_i4 * const restrict ret,\n       rcount[n] = 0;\n       rstride[n] = ret->dim[dim].stride;\n       rextent[n] = ret->dim[dim].ubound + 1 - ret->dim[dim].lbound;\n+      if (rextent[n] < 0)\n+        rextent[n] == 0;\n \n-      if (rextent[n] != shape->data[dim * shape->dim[0].stride])\n+      if (rextent[n] != shape_data[dim])\n         runtime_error (\"shape and target do not conform\");\n \n       if (rsize == rstride[n])"}, {"sha": "d496ca9d7efc23afd806e70977140162e6ad4cc1", "filename": "libgfortran/generated/reshape_i8.c", "status": "modified", "additions": 25, "deletions": 8, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c154b65579602aad087eff7229a460412b9ed8c/libgfortran%2Fgenerated%2Freshape_i8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c154b65579602aad087eff7229a460412b9ed8c/libgfortran%2Fgenerated%2Freshape_i8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Freshape_i8.c?ref=8c154b65579602aad087eff7229a460412b9ed8c", "patch": "@@ -81,16 +81,32 @@ reshape_8 (gfc_array_i8 * const restrict ret,\n   const GFC_INTEGER_8 *src;\n   int n;\n   int dim;\n-  int sempty, pempty;\n+  int sempty, pempty, shape_empty;\n+  index_type shape_data[GFC_MAX_DIMENSIONS];\n+\n+  rdim = shape->dim[0].ubound - shape->dim[0].lbound + 1;\n+  if (rdim != GFC_DESCRIPTOR_RANK(ret))\n+    runtime_error(\"rank of return array incorrect in RESHAPE intrinsic\");\n+\n+  shape_empty = 0;\n+\n+  for (n = 0; n < rdim; n++)\n+    {\n+      shape_data[n] = shape->data[n * shape->dim[0].stride];\n+      if (shape_data[n] <= 0)\n+      {\n+        shape_data[n] = 0;\n+\tshape_empty = 1;\n+      }\n+    }\n \n   if (ret->data == NULL)\n     {\n-      rdim = shape->dim[0].ubound - shape->dim[0].lbound + 1;\n       rs = 1;\n       for (n = 0; n < rdim; n++)\n \t{\n \t  ret->dim[n].lbound = 0;\n-\t  rex = shape->data[n * shape->dim[0].stride];\n+\t  rex = shape_data[n];\n \t  ret->dim[n].ubound =  rex - 1;\n \t  ret->dim[n].stride = rs;\n \t  rs *= rex;\n@@ -99,10 +115,9 @@ reshape_8 (gfc_array_i8 * const restrict ret,\n       ret->data = internal_malloc_size ( rs * sizeof (GFC_INTEGER_8));\n       ret->dtype = (source->dtype & ~GFC_DTYPE_RANK_MASK) | rdim;\n     }\n-  else\n-    {\n-      rdim = GFC_DESCRIPTOR_RANK (ret);\n-    }\n+\n+  if (shape_empty)\n+    return;\n \n   rsize = 1;\n   for (n = 0; n < rdim; n++)\n@@ -115,8 +130,10 @@ reshape_8 (gfc_array_i8 * const restrict ret,\n       rcount[n] = 0;\n       rstride[n] = ret->dim[dim].stride;\n       rextent[n] = ret->dim[dim].ubound + 1 - ret->dim[dim].lbound;\n+      if (rextent[n] < 0)\n+        rextent[n] == 0;\n \n-      if (rextent[n] != shape->data[dim * shape->dim[0].stride])\n+      if (rextent[n] != shape_data[dim])\n         runtime_error (\"shape and target do not conform\");\n \n       if (rsize == rstride[n])"}, {"sha": "61e367c96ce78769bf0c809c6d381297f65cdbfd", "filename": "libgfortran/generated/reshape_r10.c", "status": "modified", "additions": 25, "deletions": 8, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c154b65579602aad087eff7229a460412b9ed8c/libgfortran%2Fgenerated%2Freshape_r10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c154b65579602aad087eff7229a460412b9ed8c/libgfortran%2Fgenerated%2Freshape_r10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Freshape_r10.c?ref=8c154b65579602aad087eff7229a460412b9ed8c", "patch": "@@ -81,16 +81,32 @@ reshape_r10 (gfc_array_r10 * const restrict ret,\n   const GFC_REAL_10 *src;\n   int n;\n   int dim;\n-  int sempty, pempty;\n+  int sempty, pempty, shape_empty;\n+  index_type shape_data[GFC_MAX_DIMENSIONS];\n+\n+  rdim = shape->dim[0].ubound - shape->dim[0].lbound + 1;\n+  if (rdim != GFC_DESCRIPTOR_RANK(ret))\n+    runtime_error(\"rank of return array incorrect in RESHAPE intrinsic\");\n+\n+  shape_empty = 0;\n+\n+  for (n = 0; n < rdim; n++)\n+    {\n+      shape_data[n] = shape->data[n * shape->dim[0].stride];\n+      if (shape_data[n] <= 0)\n+      {\n+        shape_data[n] = 0;\n+\tshape_empty = 1;\n+      }\n+    }\n \n   if (ret->data == NULL)\n     {\n-      rdim = shape->dim[0].ubound - shape->dim[0].lbound + 1;\n       rs = 1;\n       for (n = 0; n < rdim; n++)\n \t{\n \t  ret->dim[n].lbound = 0;\n-\t  rex = shape->data[n * shape->dim[0].stride];\n+\t  rex = shape_data[n];\n \t  ret->dim[n].ubound =  rex - 1;\n \t  ret->dim[n].stride = rs;\n \t  rs *= rex;\n@@ -99,10 +115,9 @@ reshape_r10 (gfc_array_r10 * const restrict ret,\n       ret->data = internal_malloc_size ( rs * sizeof (GFC_REAL_10));\n       ret->dtype = (source->dtype & ~GFC_DTYPE_RANK_MASK) | rdim;\n     }\n-  else\n-    {\n-      rdim = GFC_DESCRIPTOR_RANK (ret);\n-    }\n+\n+  if (shape_empty)\n+    return;\n \n   rsize = 1;\n   for (n = 0; n < rdim; n++)\n@@ -115,8 +130,10 @@ reshape_r10 (gfc_array_r10 * const restrict ret,\n       rcount[n] = 0;\n       rstride[n] = ret->dim[dim].stride;\n       rextent[n] = ret->dim[dim].ubound + 1 - ret->dim[dim].lbound;\n+      if (rextent[n] < 0)\n+        rextent[n] == 0;\n \n-      if (rextent[n] != shape->data[dim * shape->dim[0].stride])\n+      if (rextent[n] != shape_data[dim])\n         runtime_error (\"shape and target do not conform\");\n \n       if (rsize == rstride[n])"}, {"sha": "f04fe32c6a82a391b111734fed94c674d47b801c", "filename": "libgfortran/generated/reshape_r16.c", "status": "modified", "additions": 25, "deletions": 8, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c154b65579602aad087eff7229a460412b9ed8c/libgfortran%2Fgenerated%2Freshape_r16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c154b65579602aad087eff7229a460412b9ed8c/libgfortran%2Fgenerated%2Freshape_r16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Freshape_r16.c?ref=8c154b65579602aad087eff7229a460412b9ed8c", "patch": "@@ -81,16 +81,32 @@ reshape_r16 (gfc_array_r16 * const restrict ret,\n   const GFC_REAL_16 *src;\n   int n;\n   int dim;\n-  int sempty, pempty;\n+  int sempty, pempty, shape_empty;\n+  index_type shape_data[GFC_MAX_DIMENSIONS];\n+\n+  rdim = shape->dim[0].ubound - shape->dim[0].lbound + 1;\n+  if (rdim != GFC_DESCRIPTOR_RANK(ret))\n+    runtime_error(\"rank of return array incorrect in RESHAPE intrinsic\");\n+\n+  shape_empty = 0;\n+\n+  for (n = 0; n < rdim; n++)\n+    {\n+      shape_data[n] = shape->data[n * shape->dim[0].stride];\n+      if (shape_data[n] <= 0)\n+      {\n+        shape_data[n] = 0;\n+\tshape_empty = 1;\n+      }\n+    }\n \n   if (ret->data == NULL)\n     {\n-      rdim = shape->dim[0].ubound - shape->dim[0].lbound + 1;\n       rs = 1;\n       for (n = 0; n < rdim; n++)\n \t{\n \t  ret->dim[n].lbound = 0;\n-\t  rex = shape->data[n * shape->dim[0].stride];\n+\t  rex = shape_data[n];\n \t  ret->dim[n].ubound =  rex - 1;\n \t  ret->dim[n].stride = rs;\n \t  rs *= rex;\n@@ -99,10 +115,9 @@ reshape_r16 (gfc_array_r16 * const restrict ret,\n       ret->data = internal_malloc_size ( rs * sizeof (GFC_REAL_16));\n       ret->dtype = (source->dtype & ~GFC_DTYPE_RANK_MASK) | rdim;\n     }\n-  else\n-    {\n-      rdim = GFC_DESCRIPTOR_RANK (ret);\n-    }\n+\n+  if (shape_empty)\n+    return;\n \n   rsize = 1;\n   for (n = 0; n < rdim; n++)\n@@ -115,8 +130,10 @@ reshape_r16 (gfc_array_r16 * const restrict ret,\n       rcount[n] = 0;\n       rstride[n] = ret->dim[dim].stride;\n       rextent[n] = ret->dim[dim].ubound + 1 - ret->dim[dim].lbound;\n+      if (rextent[n] < 0)\n+        rextent[n] == 0;\n \n-      if (rextent[n] != shape->data[dim * shape->dim[0].stride])\n+      if (rextent[n] != shape_data[dim])\n         runtime_error (\"shape and target do not conform\");\n \n       if (rsize == rstride[n])"}, {"sha": "0323a7246242d884a227b5b15fa83a7072bfdcc0", "filename": "libgfortran/generated/reshape_r4.c", "status": "modified", "additions": 25, "deletions": 8, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c154b65579602aad087eff7229a460412b9ed8c/libgfortran%2Fgenerated%2Freshape_r4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c154b65579602aad087eff7229a460412b9ed8c/libgfortran%2Fgenerated%2Freshape_r4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Freshape_r4.c?ref=8c154b65579602aad087eff7229a460412b9ed8c", "patch": "@@ -81,16 +81,32 @@ reshape_r4 (gfc_array_r4 * const restrict ret,\n   const GFC_REAL_4 *src;\n   int n;\n   int dim;\n-  int sempty, pempty;\n+  int sempty, pempty, shape_empty;\n+  index_type shape_data[GFC_MAX_DIMENSIONS];\n+\n+  rdim = shape->dim[0].ubound - shape->dim[0].lbound + 1;\n+  if (rdim != GFC_DESCRIPTOR_RANK(ret))\n+    runtime_error(\"rank of return array incorrect in RESHAPE intrinsic\");\n+\n+  shape_empty = 0;\n+\n+  for (n = 0; n < rdim; n++)\n+    {\n+      shape_data[n] = shape->data[n * shape->dim[0].stride];\n+      if (shape_data[n] <= 0)\n+      {\n+        shape_data[n] = 0;\n+\tshape_empty = 1;\n+      }\n+    }\n \n   if (ret->data == NULL)\n     {\n-      rdim = shape->dim[0].ubound - shape->dim[0].lbound + 1;\n       rs = 1;\n       for (n = 0; n < rdim; n++)\n \t{\n \t  ret->dim[n].lbound = 0;\n-\t  rex = shape->data[n * shape->dim[0].stride];\n+\t  rex = shape_data[n];\n \t  ret->dim[n].ubound =  rex - 1;\n \t  ret->dim[n].stride = rs;\n \t  rs *= rex;\n@@ -99,10 +115,9 @@ reshape_r4 (gfc_array_r4 * const restrict ret,\n       ret->data = internal_malloc_size ( rs * sizeof (GFC_REAL_4));\n       ret->dtype = (source->dtype & ~GFC_DTYPE_RANK_MASK) | rdim;\n     }\n-  else\n-    {\n-      rdim = GFC_DESCRIPTOR_RANK (ret);\n-    }\n+\n+  if (shape_empty)\n+    return;\n \n   rsize = 1;\n   for (n = 0; n < rdim; n++)\n@@ -115,8 +130,10 @@ reshape_r4 (gfc_array_r4 * const restrict ret,\n       rcount[n] = 0;\n       rstride[n] = ret->dim[dim].stride;\n       rextent[n] = ret->dim[dim].ubound + 1 - ret->dim[dim].lbound;\n+      if (rextent[n] < 0)\n+        rextent[n] == 0;\n \n-      if (rextent[n] != shape->data[dim * shape->dim[0].stride])\n+      if (rextent[n] != shape_data[dim])\n         runtime_error (\"shape and target do not conform\");\n \n       if (rsize == rstride[n])"}, {"sha": "e6be1ef03be4b0b0258ba91f0f6b1f9bd534c766", "filename": "libgfortran/generated/reshape_r8.c", "status": "modified", "additions": 25, "deletions": 8, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c154b65579602aad087eff7229a460412b9ed8c/libgfortran%2Fgenerated%2Freshape_r8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c154b65579602aad087eff7229a460412b9ed8c/libgfortran%2Fgenerated%2Freshape_r8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fgenerated%2Freshape_r8.c?ref=8c154b65579602aad087eff7229a460412b9ed8c", "patch": "@@ -81,16 +81,32 @@ reshape_r8 (gfc_array_r8 * const restrict ret,\n   const GFC_REAL_8 *src;\n   int n;\n   int dim;\n-  int sempty, pempty;\n+  int sempty, pempty, shape_empty;\n+  index_type shape_data[GFC_MAX_DIMENSIONS];\n+\n+  rdim = shape->dim[0].ubound - shape->dim[0].lbound + 1;\n+  if (rdim != GFC_DESCRIPTOR_RANK(ret))\n+    runtime_error(\"rank of return array incorrect in RESHAPE intrinsic\");\n+\n+  shape_empty = 0;\n+\n+  for (n = 0; n < rdim; n++)\n+    {\n+      shape_data[n] = shape->data[n * shape->dim[0].stride];\n+      if (shape_data[n] <= 0)\n+      {\n+        shape_data[n] = 0;\n+\tshape_empty = 1;\n+      }\n+    }\n \n   if (ret->data == NULL)\n     {\n-      rdim = shape->dim[0].ubound - shape->dim[0].lbound + 1;\n       rs = 1;\n       for (n = 0; n < rdim; n++)\n \t{\n \t  ret->dim[n].lbound = 0;\n-\t  rex = shape->data[n * shape->dim[0].stride];\n+\t  rex = shape_data[n];\n \t  ret->dim[n].ubound =  rex - 1;\n \t  ret->dim[n].stride = rs;\n \t  rs *= rex;\n@@ -99,10 +115,9 @@ reshape_r8 (gfc_array_r8 * const restrict ret,\n       ret->data = internal_malloc_size ( rs * sizeof (GFC_REAL_8));\n       ret->dtype = (source->dtype & ~GFC_DTYPE_RANK_MASK) | rdim;\n     }\n-  else\n-    {\n-      rdim = GFC_DESCRIPTOR_RANK (ret);\n-    }\n+\n+  if (shape_empty)\n+    return;\n \n   rsize = 1;\n   for (n = 0; n < rdim; n++)\n@@ -115,8 +130,10 @@ reshape_r8 (gfc_array_r8 * const restrict ret,\n       rcount[n] = 0;\n       rstride[n] = ret->dim[dim].stride;\n       rextent[n] = ret->dim[dim].ubound + 1 - ret->dim[dim].lbound;\n+      if (rextent[n] < 0)\n+        rextent[n] == 0;\n \n-      if (rextent[n] != shape->data[dim * shape->dim[0].stride])\n+      if (rextent[n] != shape_data[dim])\n         runtime_error (\"shape and target do not conform\");\n \n       if (rsize == rstride[n])"}, {"sha": "e28ed69feba9a4ef521977b90cd5aa9a5151f14a", "filename": "libgfortran/intrinsics/reshape_generic.c", "status": "modified", "additions": 23, "deletions": 7, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c154b65579602aad087eff7229a460412b9ed8c/libgfortran%2Fintrinsics%2Freshape_generic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c154b65579602aad087eff7229a460412b9ed8c/libgfortran%2Fintrinsics%2Freshape_generic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Freshape_generic.c?ref=8c154b65579602aad087eff7229a460412b9ed8c", "patch": "@@ -69,7 +69,24 @@ reshape_internal (parray *ret, parray *source, shape_type *shape,\n   const char *src;\n   int n;\n   int dim;\n-  int sempty, pempty;\n+  int sempty, pempty, shape_empty;\n+  index_type shape_data[GFC_MAX_DIMENSIONS];\n+\n+  rdim = shape->dim[0].ubound - shape->dim[0].lbound + 1;\n+  if (rdim != GFC_DESCRIPTOR_RANK(ret))\n+    runtime_error(\"rank of return array incorrect in RESHAPE intrinsic\");\n+\n+  shape_empty = 0;\n+\n+  for (n = 0; n < rdim; n++)\n+    {\n+      shape_data[n] = shape->data[n * shape->dim[0].stride];\n+      if (shape_data[n] <= 0)\n+\t{\n+\t  shape_data[n] = 0;\n+\t  shape_empty = 1;\n+\t}\n+    }\n \n   if (ret->data == NULL)\n     {\n@@ -78,7 +95,7 @@ reshape_internal (parray *ret, parray *source, shape_type *shape,\n       for (n = 0; n < rdim; n++)\n \t{\n \t  ret->dim[n].lbound = 0;\n-\t  rex = shape->data[n * shape->dim[0].stride];\n+\t  rex = shape_data[n];\n \t  ret->dim[n].ubound =  rex - 1;\n \t  ret->dim[n].stride = rs;\n \t  rs *= rex;\n@@ -87,10 +104,9 @@ reshape_internal (parray *ret, parray *source, shape_type *shape,\n       ret->data = internal_malloc_size ( rs * size );\n       ret->dtype = (source->dtype & ~GFC_DTYPE_RANK_MASK) | rdim;\n     }\n-  else\n-    {\n-      rdim = GFC_DESCRIPTOR_RANK (ret);\n-    }\n+\n+  if (shape_empty)\n+    return;\n \n   rsize = 1;\n   for (n = 0; n < rdim; n++)\n@@ -104,7 +120,7 @@ reshape_internal (parray *ret, parray *source, shape_type *shape,\n       rstride[n] = ret->dim[dim].stride;\n       rextent[n] = ret->dim[dim].ubound + 1 - ret->dim[dim].lbound;\n \n-      if (rextent[n] != shape->data[dim * shape->dim[0].stride])\n+      if (rextent[n] != shape_data[dim])\n         runtime_error (\"shape and target do not conform\");\n \n       if (rsize == rstride[n])"}, {"sha": "ed060ecb9ff155787379a13d19d38bdeea2058bd", "filename": "libgfortran/m4/reshape.m4", "status": "modified", "additions": 25, "deletions": 8, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c154b65579602aad087eff7229a460412b9ed8c/libgfortran%2Fm4%2Freshape.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c154b65579602aad087eff7229a460412b9ed8c/libgfortran%2Fm4%2Freshape.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fm4%2Freshape.m4?ref=8c154b65579602aad087eff7229a460412b9ed8c", "patch": "@@ -85,16 +85,32 @@ reshape_'rtype_ccode` ('rtype` * const restrict ret,\n   const 'rtype_name` *src;\n   int n;\n   int dim;\n-  int sempty, pempty;\n+  int sempty, pempty, shape_empty;\n+  index_type shape_data[GFC_MAX_DIMENSIONS];\n+\n+  rdim = shape->dim[0].ubound - shape->dim[0].lbound + 1;\n+  if (rdim != GFC_DESCRIPTOR_RANK(ret))\n+    runtime_error(\"rank of return array incorrect in RESHAPE intrinsic\");\n+\n+  shape_empty = 0;\n+\n+  for (n = 0; n < rdim; n++)\n+    {\n+      shape_data[n] = shape->data[n * shape->dim[0].stride];\n+      if (shape_data[n] <= 0)\n+      {\n+        shape_data[n] = 0;\n+\tshape_empty = 1;\n+      }\n+    }\n \n   if (ret->data == NULL)\n     {\n-      rdim = shape->dim[0].ubound - shape->dim[0].lbound + 1;\n       rs = 1;\n       for (n = 0; n < rdim; n++)\n \t{\n \t  ret->dim[n].lbound = 0;\n-\t  rex = shape->data[n * shape->dim[0].stride];\n+\t  rex = shape_data[n];\n \t  ret->dim[n].ubound =  rex - 1;\n \t  ret->dim[n].stride = rs;\n \t  rs *= rex;\n@@ -103,10 +119,9 @@ reshape_'rtype_ccode` ('rtype` * const restrict ret,\n       ret->data = internal_malloc_size ( rs * sizeof ('rtype_name`));\n       ret->dtype = (source->dtype & ~GFC_DTYPE_RANK_MASK) | rdim;\n     }\n-  else\n-    {\n-      rdim = GFC_DESCRIPTOR_RANK (ret);\n-    }\n+\n+  if (shape_empty)\n+    return;\n \n   rsize = 1;\n   for (n = 0; n < rdim; n++)\n@@ -119,8 +134,10 @@ reshape_'rtype_ccode` ('rtype` * const restrict ret,\n       rcount[n] = 0;\n       rstride[n] = ret->dim[dim].stride;\n       rextent[n] = ret->dim[dim].ubound + 1 - ret->dim[dim].lbound;\n+      if (rextent[n] < 0)\n+        rextent[n] == 0;\n \n-      if (rextent[n] != shape->data[dim * shape->dim[0].stride])\n+      if (rextent[n] != shape_data[dim])\n         runtime_error (\"shape and target do not conform\");\n \n       if (rsize == rstride[n])"}]}