{"sha": "8b978a57fad8f2a6bbf590521b06f606a6f953c0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGI5NzhhNTdmYWQ4ZjJhNmJiZjU5MDUyMWIwNmY2MDZhNmY5NTNjMA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2003-02-11T21:58:09Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2003-02-11T21:58:09Z"}, "message": "i386.c (contains_128bit_aligned_vector_p): New function.\n\n\t* i386.c (contains_128bit_aligned_vector_p): New function.\n\t(ix86_function_arg_boundary): Properly align vector modes.\n\nFrom-SVN: r62732", "tree": {"sha": "14fed9983febcab1ba4bc99d3b37feac8d1370bd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/14fed9983febcab1ba4bc99d3b37feac8d1370bd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8b978a57fad8f2a6bbf590521b06f606a6f953c0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b978a57fad8f2a6bbf590521b06f606a6f953c0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8b978a57fad8f2a6bbf590521b06f606a6f953c0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b978a57fad8f2a6bbf590521b06f606a6f953c0/comments", "author": null, "committer": null, "parents": [{"sha": "ce3039af7dc478d4ac6d0fdeda3d1c3e0f97c943", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce3039af7dc478d4ac6d0fdeda3d1c3e0f97c943", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ce3039af7dc478d4ac6d0fdeda3d1c3e0f97c943"}], "stats": {"total": 88, "additions": 86, "deletions": 2}, "files": [{"sha": "f1341b2b57613af8aadc5d1fa8a84bce1834804f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b978a57fad8f2a6bbf590521b06f606a6f953c0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b978a57fad8f2a6bbf590521b06f606a6f953c0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8b978a57fad8f2a6bbf590521b06f606a6f953c0", "patch": "@@ -1,3 +1,8 @@\n+Mon Oct 21 17:07:47 CEST 2002  Jan Hubicka  <jh@suse.cz>\n+\n+\t* i386.c (contains_128bit_aligned_vector_p): New function.\n+\t(ix86_function_arg_boundary): Properly align vector modes.\n+\n 2003-02-11  Bob Wilson  <bob.wilson@acm.org>\n \n \t* config/xtensa/xtensa.md (set_frame_ptr): Change rtl to set reg a7."}, {"sha": "cad5c60cd659b5b001d7e6308cb8a2129a923e75", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 81, "deletions": 2, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b978a57fad8f2a6bbf590521b06f606a6f953c0/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b978a57fad8f2a6bbf590521b06f606a6f953c0/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=8b978a57fad8f2a6bbf590521b06f606a6f953c0", "patch": "@@ -880,6 +880,7 @@ static bool ix86_function_ok_for_sibcall PARAMS ((tree, tree));\n static tree ix86_handle_cdecl_attribute PARAMS ((tree *, tree, tree, int, bool *));\n static tree ix86_handle_regparm_attribute PARAMS ((tree *, tree, tree, int, bool *));\n static int ix86_value_regno PARAMS ((enum machine_mode));\n+static bool contains_128bit_aligned_vector_p PARAMS ((tree));\n static bool ix86_ms_bitfield_layout_p PARAMS ((tree));\n static tree ix86_handle_struct_attribute PARAMS ((tree *, tree, tree, int, bool *));\n static int extended_reg_mentioned_1 PARAMS ((rtx *, void *));\n@@ -2534,6 +2535,64 @@ function_arg_pass_by_reference (cum, mode, type, named)\n   return 0;\n }\n \n+/* Return true when TYPE should be 128bit aligned for 32bit argument passing\n+   ABI  */\n+static bool\n+contains_128bit_aligned_vector_p (type)\n+     tree type;\n+{\n+  enum machine_mode mode = TYPE_MODE (type);\n+  if (SSE_REG_MODE_P (mode)\n+      && (!TYPE_USER_ALIGN (type) || TYPE_ALIGN (type) > 128))\n+    return true;\n+  if (TYPE_ALIGN (type) < 128)\n+    return false;\n+\n+  if (AGGREGATE_TYPE_P (type))\n+    {\n+      /* Walk the agregates recursivly.  */\n+      if (TREE_CODE (type) == RECORD_TYPE\n+\t  || TREE_CODE (type) == UNION_TYPE\n+\t  || TREE_CODE (type) == QUAL_UNION_TYPE)\n+\t{\n+\t  tree field;\n+\n+\t  if (TYPE_BINFO (type) != NULL\n+\t      && TYPE_BINFO_BASETYPES (type) != NULL)\n+\t    {\n+\t      tree bases = TYPE_BINFO_BASETYPES (type);\n+\t      int n_bases = TREE_VEC_LENGTH (bases);\n+\t      int i;\n+\n+\t      for (i = 0; i < n_bases; ++i)\n+\t\t{\n+\t\t  tree binfo = TREE_VEC_ELT (bases, i);\n+\t\t  tree type = BINFO_TYPE (binfo);\n+\n+\t\t  if (contains_128bit_aligned_vector_p (type))\n+\t\t    return true;\n+\t\t}\n+\t    }\n+\t  /* And now merge the fields of structure.   */\n+\t  for (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n+\t    {\n+\t      if (TREE_CODE (field) == FIELD_DECL\n+\t\t  && contains_128bit_aligned_vector_p (TREE_TYPE (field)))\n+\t\treturn true;\n+\t    }\n+\t}\n+      /* Just for use if some languages passes arrays by value.  */\n+      else if (TREE_CODE (type) == ARRAY_TYPE)\n+\t{\n+\t  if (contains_128bit_aligned_vector_p (TREE_TYPE (type)))\n+\t    return true;\n+\t}\n+      else\n+\tabort ();\n+    }\n+  return false;\n+}\n+\n /* Gives the alignment boundary, in bits, of an argument with the specified mode\n    and type.   */\n \n@@ -2543,14 +2602,34 @@ ix86_function_arg_boundary (mode, type)\n      tree type;\n {\n   int align;\n-  if (!TARGET_64BIT)\n-    return PARM_BOUNDARY;\n   if (type)\n     align = TYPE_ALIGN (type);\n   else\n     align = GET_MODE_ALIGNMENT (mode);\n   if (align < PARM_BOUNDARY)\n     align = PARM_BOUNDARY;\n+  if (!TARGET_64BIT)\n+    {\n+      /* i386 ABI defines all arguments to be 4 byte aligned.  We have to\n+\t make an exception for SSE modes since these require 128bit\n+\t alignment.  \n+\n+\t The handling here differs from field_alignment.  ICC aligns MMX\n+\t arguments to 4 byte boundaries, while structure fields are aligned\n+\t to 8 byte boundaries.  */\n+      if (!type)\n+\t{\n+\t  if (!SSE_REG_MODE_P (mode))\n+\t    align = PARM_BOUNDARY;\n+\t}\n+      else\n+\t{\n+\t  if (!contains_128bit_aligned_vector_p (type))\n+\t    align = PARM_BOUNDARY;\n+\t}\n+      if (align != PARM_BOUNDARY && !TARGET_SSE)\n+\tabort();\n+    }\n   if (align > 128)\n     align = 128;\n   return align;"}]}