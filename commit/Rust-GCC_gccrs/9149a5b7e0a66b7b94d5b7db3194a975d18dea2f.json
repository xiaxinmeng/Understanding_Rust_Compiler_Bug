{"sha": "9149a5b7e0a66b7b94d5b7db3194a975d18dea2f", "node_id": "C_kwDOANBUbNoAKDkxNDlhNWI3ZTBhNjZiN2I5NGQ1YjdkYjMxOTRhOTc1ZDE4ZGVhMmY", "commit": {"author": {"name": "Eric Botcazou", "email": "botcazou@adacore.com", "date": "2022-12-23T23:45:15Z"}, "committer": {"name": "Jonathan Yong", "email": "10walls@gmail.com", "date": "2022-12-23T23:58:06Z"}, "message": "Reimplement GNU threads library on native Windows\n\nThis reimplements the GNU threads library on native Windows (except for the\nObjective-C specific subset) using direct Win32 API calls, in lieu of the\nimplementation based on semaphores.  This base implementations requires\nWindows XP/Server 2003, which was the default minimal setting of MinGW-W64\nuntil end of 2020.  This also adds the support required for the C++11 threads,\nusing again direct Win32 API calls; this additional layer requires Windows\nVista/Server 2008 and is enabled only if _WIN32_WINNT >= 0x0600.\n\nThis also changes libstdc++ to pass -D_WIN32_WINNT=0x0600 but only when the\nswitch --enable-libstdcxx-threads is passed, which means that C++11 threads\nare still disabled by default *unless* MinGW-W64 itself is configured for\nWindows Vista/Server 2008 or later by default (this has been the case in\nthe development version since end of 2020, for earlier versions you can\nconfigure it --with-default-win32-winnt=0x0600 to get the same effect).\n\nI only manually tested it on i686-w64-mingw32 and x86_64-w64-mingw32 but\nAdaCore has used it in their C/C++/Ada compilers for 3 years now and the\n30_threads chapter of the libstdc++ testsuite was clean at the time.\n\n2022-10-31  Eric Botcazou  <ebotcazou@adacore.com>\n\nlibgcc/\n\t* config.host (i[34567]86-*-mingw*): Add thread fragment after EH one\n\tas well as new i386/t-slibgcc-mingw fragment.\n\t(x86_64-*-mingw*): Likewise.\n\t* config/i386/gthr-win32.h: If _WIN32_WINNT is at least 0x0600, define\n\tboth __GTHREAD_HAS_COND and __GTHREADS_CXX0X to 1.\n\tError out if _GTHREAD_USE_MUTEX_TIMEDLOCK is 1.\n\tInclude stdlib.h instead of errno.h and do not include _mingw.h.\n\t(CONST_CAST2): Add specific definition for C++.\n\t(ATTRIBUTE_UNUSED): New macro.\n\t(__UNUSED_PARAM): Delete.\n\tDefine WIN32_LEAN_AND_MEAN before including windows.h.\n\t(__gthread_objc_data_tls): Use TLS_OUT_OF_INDEXES instead of (DWORD)-1.\n\t(__gthread_objc_init_thread_system): Likewise.\n\t(__gthread_objc_thread_get_data): Minor tweak.\n\t(__gthread_objc_condition_allocate): Use ATTRIBUTE_UNUSED.\n\t(__gthread_objc_condition_deallocate): Likewise.\n\t(__gthread_objc_condition_wait): Likewise.\n\t(__gthread_objc_condition_broadcast): Likewise.\n\t(__gthread_objc_condition_signal): Likewise.\n\tInclude sys/time.h.\n\t(__gthr_win32_DWORD): New typedef.\n\t(__gthr_win32_HANDLE): Likewise.\n\t(__gthr_win32_CRITICAL_SECTION): Likewise.\n\t(__gthr_win32_CONDITION_VARIABLE): Likewise.\n\t(__gthread_t): Adjust.\n\t(__gthread_key_t): Likewise.\n\t(__gthread_mutex_t): Likewise.\n\t(__gthread_recursive_mutex_t): Likewise.\n\t(__gthread_cond_t): New typedef.\n\t(__gthread_time_t): Likewise.\n\t(__GTHREAD_MUTEX_INIT_DEFAULT): Delete.\n\t(__GTHREAD_RECURSIVE_MUTEX_INIT_DEFAULT): Likewise.\n\t(__GTHREAD_COND_INIT_FUNCTION): Define.\n\t(__GTHREAD_TIME_INIT): Likewise.\n\t(__gthr_i486_lock_cmp_xchg): Delete.\n\t(__gthr_win32_create): Declare.\n\t(__gthr_win32_join): Likewise.\n\t(__gthr_win32_self): Likewise.\n\t(__gthr_win32_detach): Likewise.\n\t(__gthr_win32_equal): Likewise.\n\t(__gthr_win32_yield): Likewise.\n\t(__gthr_win32_mutex_destroy): Likewise.\n\t(__gthr_win32_cond_init_function): Likewise if __GTHREADS_HAS_COND is 1.\n\t(__gthr_win32_cond_broadcast): Likewise.\n\t(__gthr_win32_cond_signal): Likewise.\n\t(__gthr_win32_cond_wait): Likewise.\n\t(__gthr_win32_cond_timedwait): Likewise.\n\t(__gthr_win32_recursive_mutex_init_function): Delete.\n\t(__gthr_win32_recursive_mutex_lock): Likewise.\n\t(__gthr_win32_recursive_mutex_unlock): Likewise.\n\t(__gthr_win32_recursive_mutex_destroy): Likewise.\n\t(__gthread_create): New inline function.\n\t(__gthread_join): Likewise.\n\t(__gthread_self): Likewise.\n\t(__gthread_detach): Likewise.\n\t(__gthread_equal): Likewise.\n\t(__gthread_yield): Likewise.\n\t(__gthread_cond_init_function): Likewise if __GTHREADS_HAS_COND is 1.\n\t(__gthread_cond_broadcast): Likewise.\n\t(__gthread_cond_signal): Likewise.\n\t(__gthread_cond_wait): Likewise.\n\t(__gthread_cond_timedwait): Likewise.\n\t(__GTHREAD_WIN32_INLINE): New macro.\n\t(__GTHREAD_WIN32_COND_INLINE): Likewise.\n\t(__GTHREAD_WIN32_ACTIVE_P): Likewise.\n\tDefine WIN32_LEAN_AND_MEAN before including windows.h.\n\t(__gthread_once): Minor tweaks.\n\t(__gthread_key_create): Use ATTRIBUTE_UNUSED and TLS_OUT_OF_INDEXES.\n\t(__gthread_key_delete): Minor tweak.\n\t(__gthread_getspecific): Likewise.\n\t(__gthread_setspecific): Likewise.\n\t(__gthread_mutex_init_function): Reimplement.\n\t(__gthread_mutex_destroy): Likewise.\n\t(__gthread_mutex_lock): Likewise.\n\t(__gthread_mutex_trylock): Likewise.\n\t(__gthread_mutex_unlock): Likewise.\n\t(__gthr_win32_abs_to_rel_time): Declare.\n\t(__gthread_recursive_mutex_init_function): Reimplement.\n\t(__gthread_recursive_mutex_destroy): Likewise.\n\t(__gthread_recursive_mutex_lock): Likewise.\n\t(__gthread_recursive_mutex_trylock): Likewise.\n\t(__gthread_recursive_mutex_unlock): Likewise.\n\t(__gthread_cond_destroy): New inline function.\n\t(__gthread_cond_wait_recursive): Likewise.\n\t* config/i386/gthr-win32.c: Delete everything.\n\tInclude gthr-win32.h to get the out-of-line version of inline routines.\n\tAdd compile-time checks for the local version of the Win32 types.\n\t* config/i386/gthr-win32-cond.c: New file.\n\t* config/i386/gthr-win32-thread.c: Likewise.\n\t* config/i386/t-gthr-win32: Add config/i386/gthr-win32-thread.c to the\n\tEH part, config/i386/gthr-win32-cond.c and config/i386/gthr-win32.c to\n\tthe static version of libgcc.\n\t* config/i386/t-slibgcc-mingw: New file.\n\t* config/i386/libgcc-mingw.ver: Likewise.\nlibstdc++-v3/\n\t* acinclude.m4 (GLIBCXX_EXPORT_FLAGS): Substitute CPPFLAGS.\n\t(GLIBCXX_ENABLE_LIBSTDCXX_TIME): Set ac_has_sched_yield and\n\tac_has_win32_sleep to yes for MinGW.  Change HAVE_WIN32_SLEEP\n\tinto _GLIBCXX_USE_WIN32_SLEEP.\n\t(GLIBCXX_CHECK_GTHREADS): Add _WIN32_THREADS to compilation flags for\n\tWin32 threads and force _GTHREAD_USE_MUTEX_TIMEDLOCK to 0 for them.\n\tAdd -D_WIN32_WINNT=0x0600 to compilation flags if yes was configured\n\tand add it to CPPFLAGS on success.\n\t* config.h.in: Regenerate.\n\t* configure: Likewise.\n\t* config/os/mingw32-w64/os_defines.h (_GLIBCXX_USE_GET_NPROCS_WIN32):\n\tDefine to 1.\n\t* config/os/mingw32/os_defines.h (_GLIBCXX_USE_GET_NPROCS_WIN32): Ditto\n\t* src/c++11/thread.cc (get_nprocs): Provide Win32 implementation if\n\t_GLIBCXX_USE_GET_NPROCS_WIN32 is defined.  Replace HAVE_WIN32_SLEEP\n\twith USE_WIN32_SLEEP.\n\t* testsuite/19_diagnostics/headers/system_error/errc_std_c++0x.cc: Add\n\tmissing conditional compilation.\n\t* testsuite/lib/libstdc++.exp (check_v3_target_sleep): Add support for\n\t_GLIBCXX_USE_WIN32_SLEEP.\n\t(check_v3_target_nprocs): Likewise for _GLIBCXX_USE_GET_NPROCS_WIN32.\n\nSigned-off-by: Eric Botcazou <ebotcazou@adacore.com>\nSigned-off-by: Jonathan Yong <10walls@gmail.com>", "tree": {"sha": "8a4021ace74a510a9d19b8f1aaf47952d7622a9f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8a4021ace74a510a9d19b8f1aaf47952d7622a9f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9149a5b7e0a66b7b94d5b7db3194a975d18dea2f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9149a5b7e0a66b7b94d5b7db3194a975d18dea2f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9149a5b7e0a66b7b94d5b7db3194a975d18dea2f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9149a5b7e0a66b7b94d5b7db3194a975d18dea2f/comments", "author": null, "committer": {"login": "jon-y", "id": 4688224, "node_id": "MDQ6VXNlcjQ2ODgyMjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4688224?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jon-y", "html_url": "https://github.com/jon-y", "followers_url": "https://api.github.com/users/jon-y/followers", "following_url": "https://api.github.com/users/jon-y/following{/other_user}", "gists_url": "https://api.github.com/users/jon-y/gists{/gist_id}", "starred_url": "https://api.github.com/users/jon-y/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jon-y/subscriptions", "organizations_url": "https://api.github.com/users/jon-y/orgs", "repos_url": "https://api.github.com/users/jon-y/repos", "events_url": "https://api.github.com/users/jon-y/events{/privacy}", "received_events_url": "https://api.github.com/users/jon-y/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6a95f0e0a06d78d94138d4c3dd64d41591197281", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a95f0e0a06d78d94138d4c3dd64d41591197281", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6a95f0e0a06d78d94138d4c3dd64d41591197281"}], "stats": {"total": 1260, "additions": 743, "deletions": 517}, "files": [{"sha": "d2087654c409e1d48e2c7165428228e03026cff1", "filename": "libgcc/config.host", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9149a5b7e0a66b7b94d5b7db3194a975d18dea2f/libgcc%2Fconfig.host", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9149a5b7e0a66b7b94d5b7db3194a975d18dea2f/libgcc%2Fconfig.host", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig.host?ref=9149a5b7e0a66b7b94d5b7db3194a975d18dea2f", "patch": "@@ -820,13 +820,13 @@ i[34567]86-*-mingw*)\n \tfi\n \tcase ${target_thread_file} in\n \t  win32)\n-\t    tmake_file=\"$tmake_file i386/t-gthr-win32\"\n+\t    tmake_thr_file=\"i386/t-gthr-win32\"\n \t    ;;\n \t  posix)\n-\t    tmake_file=\"i386/t-mingw-pthread $tmake_file\"\n+\t    tmake_thr_file=\"i386/t-mingw-pthread\"\n \t    ;;\n \t  mcf)\n-\t    tmake_file=\"i386/t-mingw-mcfgthread $tmake_file\"\n+\t    tmake_thr_file=\"i386/t-mingw-mcfgthread\"\n \t    ;;\n \tesac\n \t# This has to match the logic for DWARF2_UNWIND_INFO in gcc/config/i386/cygming.h\n@@ -842,18 +842,18 @@ i[34567]86-*-mingw*)\n \telse\n \t\ttmake_dlldir_file=\"i386/t-dlldir-x\"\n \tfi\n-\ttmake_file=\"${tmake_file} ${tmake_eh_file} ${tmake_dlldir_file} i386/t-slibgcc-cygming i386/t-cygming i386/t-mingw32 t-crtfm i386/t-chkstk t-dfprules\"\n+\ttmake_file=\"${tmake_file} ${tmake_eh_file} ${tmake_thr_file} ${tmake_dlldir_file} i386/t-slibgcc-cygming i386/t-slibgcc-mingw i386/t-cygming i386/t-mingw32 t-crtfm i386/t-chkstk t-dfprules\"\n \t;;\n x86_64-*-mingw*)\n \tcase ${target_thread_file} in\n \t  win32)\n-\t    tmake_file=\"$tmake_file i386/t-gthr-win32\"\n+\t    tmake_thr_file=\"i386/t-gthr-win32\"\n \t    ;;\n \t  posix)\n-\t    tmake_file=\"i386/t-mingw-pthread $tmake_file\"\n+\t    tmake_thr_file=\"i386/t-mingw-pthread\"\n \t    ;;\n \t  mcf)\n-\t    tmake_file=\"i386/t-mingw-mcfgthread $tmake_file\"\n+\t    tmake_thr_file=\"i386/t-mingw-mcfgthread\"\n \t    ;;\n \tesac\n \t# This has to match the logic for DWARF2_UNWIND_INFO in gcc/config/i386/cygming.h\n@@ -872,7 +872,7 @@ x86_64-*-mingw*)\n \telse\n \t\ttmake_dlldir_file=\"i386/t-dlldir-x\"\n \tfi\n-\ttmake_file=\"${tmake_file} ${tmake_eh_file} ${tmake_dlldir_file} i386/t-slibgcc-cygming i386/t-cygming i386/t-mingw32 t-dfprules t-crtfm i386/t-chkstk\"\n+\ttmake_file=\"${tmake_file} ${tmake_eh_file} ${tmake_thr_file} ${tmake_dlldir_file} i386/t-slibgcc-cygming i386/t-slibgcc-mingw i386/t-cygming i386/t-mingw32 t-dfprules t-crtfm i386/t-chkstk\"\n \textra_parts=\"$extra_parts crtbegin.o crtend.o crtfastmath.o\"\n \tif test x$enable_vtable_verify = xyes; then\n \t\textra_parts=\"$extra_parts vtv_start.o vtv_end.o vtv_start_preinit.o vtv_end_preinit.o\""}, {"sha": "6b6fb45d5d35abe0a1ac9081aa65370d96c16ac9", "filename": "libgcc/config/i386/gthr-win32-cond.c", "status": "added", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9149a5b7e0a66b7b94d5b7db3194a975d18dea2f/libgcc%2Fconfig%2Fi386%2Fgthr-win32-cond.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9149a5b7e0a66b7b94d5b7db3194a975d18dea2f/libgcc%2Fconfig%2Fi386%2Fgthr-win32-cond.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fi386%2Fgthr-win32-cond.c?ref=9149a5b7e0a66b7b94d5b7db3194a975d18dea2f", "patch": "@@ -0,0 +1,89 @@\n+/* Implementation of threads compatibility routines for libgcc2.  */\n+\n+/* Copyright (C) 1999-2022 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+/* This module is separate from the rest of the implementation because it\n+   references symbols in system libraries that are only available on Vista\n+   and Server 2008 or later versions.  */\n+\n+/* Get the out-of-line version of the inline routines.  */\n+\n+#if _WIN32_WINNT < 0x0600\n+#undef _WIN32_WINNT\n+#define _WIN32_WINNT 0x0600\n+#endif\n+\n+#define __GTHREAD_WIN32_COND_INLINE\n+\n+#define __gthread_cond_init_function __gthr_win32_cond_init_function\n+#define __gthread_cond_broadcast __gthr_win32_cond_broadcast\n+#define __gthread_cond_signal __gthr_win32_cond_signal\n+#define __gthread_cond_wait __gthr_win32_cond_wait\n+#define __gthread_cond_timedwait __gthr_win32_cond_timedwait\n+\n+#include \"gthr-win32.h\"\n+\n+/* The number of 100-nanoseconds between 1/1/1601 and 1/1/1970. */\n+#define FILETIME_1970 116444736000000000ULL\n+\n+/* The number of 100-nanoseconds per second.  */\n+#define NSEC100_PER_SEC (1000000000ULL / 100)\n+\n+/* The number of 100-nanoseconds per millisecond.  */\n+#define NSEC100_PER_MSEC (NSEC100_PER_SEC / 1000)\n+\n+/* The ceiling division of X by Y.  */\n+#define CEIL_DIV(X, Y) (((X) + (Y) - 1) / (Y))\n+\n+/* Convert absolute thread time to relative time in millisecond.  */\n+\n+DWORD\n+__gthr_win32_abs_to_rel_time (const __gthread_time_t *abs_time)\n+{\n+  union {\n+    ULONGLONG nsec100;\n+    FILETIME ft;\n+  } now;\n+  ULONGLONG abs_time_nsec100;\n+\n+  /* The Windows epoch is 1/1/1601 while the Unix epoch is 1/1/1970.  */\n+  GetSystemTimeAsFileTime (&now.ft);\n+  now.nsec100 -= FILETIME_1970;\n+\n+  abs_time_nsec100\n+    = (ULONGLONG) abs_time->tv_sec * NSEC100_PER_SEC\n+\t+ CEIL_DIV (abs_time->tv_nsec, 100);\n+\n+  if (abs_time_nsec100 < now.nsec100)\n+    return 0;\n+\n+  return (DWORD) CEIL_DIV (abs_time_nsec100 - now.nsec100, NSEC100_PER_SEC);\n+}\n+\n+/* Check the sizes of the local version of the Win32 types.  */\n+\n+#define CHECK_SIZE_OF(TYPE) \\\n+  typedef int assertion[sizeof(__gthr_win32_##TYPE) == sizeof(TYPE) ? 1 : -1];\n+\n+CHECK_SIZE_OF (CONDITION_VARIABLE)"}, {"sha": "81e6fd094c7a4a09c7ff22a612e3d90ad1f283d3", "filename": "libgcc/config/i386/gthr-win32-thread.c", "status": "added", "additions": 162, "deletions": 0, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9149a5b7e0a66b7b94d5b7db3194a975d18dea2f/libgcc%2Fconfig%2Fi386%2Fgthr-win32-thread.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9149a5b7e0a66b7b94d5b7db3194a975d18dea2f/libgcc%2Fconfig%2Fi386%2Fgthr-win32-thread.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fi386%2Fgthr-win32-thread.c?ref=9149a5b7e0a66b7b94d5b7db3194a975d18dea2f", "patch": "@@ -0,0 +1,162 @@\n+/* Implementation of threads compatibility routines for libgcc2.  */\n+\n+/* Copyright (C) 1999-2022 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+/* This module is separate from the rest of the implementation because only\n+   one copy of it ought to be linked.  */\n+\n+/* The implementation strategy for the c++0x thread support is as follows.\n+\n+   A GNU thread is represented by a Win32 HANDLE that is obtained when the\n+   Win32 thread is created, except of course for the initial thread.  This\n+   Win32 HANDLE is stored in a descriptor keyed from TLS memory for every\n+   thread, so the self routine can return it instead of having to duplicate\n+   the pseudo-handle returned by GetCurrentThread each time it is invoked.\n+   For the initial thread, this Win32 HANDLE is created during the first\n+   call to the self routine using the aforementioned technique.\n+\n+   Note that the equal routine compares the identifier of threads instead\n+   of their Win32 HANDLE, which will give the correct positive answer even\n+   in the case where distinct Win32 HANDLEs have been created for the same\n+   thread by multiple instances of libgcc included in the link.  */\n+\n+#include \"gthr-win32.h\"\n+\n+/* The thread descriptor keyed from TLS memory.  */\n+struct __gthr_win32_thr_desc\n+{\n+  void *(*func) (void*);\n+  void *args;\n+  HANDLE h;\n+};\n+\n+/* The TLS key used by one instance of the library.  */\n+static __gthread_key_t __gthr_win32_tls = TLS_OUT_OF_INDEXES;\n+\n+/* The initialization device for the TLS key.  */\n+static __gthread_once_t __gthr_win32_tls_once = __GTHREAD_ONCE_INIT;\n+\n+/* Initialize the TLS key.  */\n+\n+static void\n+__gthr_win32_tls_init (void)\n+{\n+  if (__gthread_key_create (&__gthr_win32_tls, free))\n+    abort ();\n+}\n+\n+/* Wrapper routine around thread functions.  */\n+\n+static DWORD\n+__gthr_win32_thread_wrapper (void *args)\n+{\n+  struct __gthr_win32_thr_desc *td = (struct __gthr_win32_thr_desc *) args;\n+\n+  __gthread_setspecific (__gthr_win32_tls, td);\n+\n+  DWORD exit_code = (DWORD) (ULONG_PTR) (*td->func) (td->args);\n+\n+  ExitThread (exit_code);\n+  return exit_code;\n+}\n+\n+/* Implement the __gthread_create routine.  */\n+\n+int\n+__gthr_win32_create (__gthread_t *thr, void *(*func) (void*), void *args)\n+{\n+  struct __gthr_win32_thr_desc *td;\n+\n+  __gthread_once (&__gthr_win32_tls_once, __gthr_win32_tls_init);\n+\n+  td = malloc (sizeof (struct __gthr_win32_thr_desc));\n+  td->func = func;\n+  td->args = args;\n+  td->h = CreateThread (NULL, 0,\n+\t\t\t(LPTHREAD_START_ROUTINE) __gthr_win32_thread_wrapper,\n+\t\t\t(LPVOID) td, CREATE_SUSPENDED, NULL);\n+  if (td->h)\n+    {\n+      ResumeThread (td->h);\n+      *thr = (__gthread_t) td->h;\n+      return 0;\n+    }\n+  else\n+    {\n+      free (td);\n+      return (int) GetLastError ();\n+    }\n+}\n+\n+/* Implement the __gthread_join routine.  */\n+\n+int\n+__gthr_win32_join (__gthread_t thr, void **value_ptr)\n+{\n+  int status = 0;\n+\n+  if (GetThreadId ((HANDLE) thr) == GetCurrentThreadId ())\n+    return 1;\n+\n+  if (WaitForSingleObject ((HANDLE) thr, INFINITE) == WAIT_OBJECT_0)\n+    {\n+      if (value_ptr)\n+\t{\n+\t  DWORD exit_code;\n+\t  if (GetExitCodeThread ((HANDLE) thr, &exit_code))\n+\t    *value_ptr = (void *) (ULONG_PTR) exit_code;\n+\t  else\n+\t    status = (int) GetLastError ();\n+\t}\n+    }\n+  else\n+    status = (int) GetLastError ();\n+\n+  CloseHandle ((HANDLE) thr);\n+  return status;\n+}\n+\n+/* Implement the __gthread_self routine.  */\n+\n+__gthread_t\n+__gthr_win32_self (void)\n+{\n+  struct __gthr_win32_thr_desc *td;\n+\n+  __gthread_once (&__gthr_win32_tls_once, __gthr_win32_tls_init);\n+\n+  if (!(td = __gthread_getspecific (__gthr_win32_tls)))\n+    {\n+      HANDLE proc = GetCurrentProcess ();\n+      td = malloc (sizeof (struct __gthr_win32_thr_desc));\n+      td->func = NULL;\n+      td->args = NULL;\n+      if (!DuplicateHandle (proc, GetCurrentThread(), proc, &td->h, 0, FALSE,\n+\t\t\t    DUPLICATE_SAME_ACCESS))\n+\tabort ();\n+      __gthread_setspecific (__gthr_win32_tls, td);\n+    }\n+\n+  return td->h;\n+}"}, {"sha": "df06e20d18a2f5068b631ee4b730e0f6387ac87e", "filename": "libgcc/config/i386/gthr-win32.c", "status": "modified", "additions": 27, "deletions": 237, "changes": 264, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9149a5b7e0a66b7b94d5b7db3194a975d18dea2f/libgcc%2Fconfig%2Fi386%2Fgthr-win32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9149a5b7e0a66b7b94d5b7db3194a975d18dea2f/libgcc%2Fconfig%2Fi386%2Fgthr-win32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fi386%2Fgthr-win32.c?ref=9149a5b7e0a66b7b94d5b7db3194a975d18dea2f", "patch": "@@ -1,10 +1,6 @@\n-/* Implementation of W32-specific threads compatibility routines for\n-   libgcc2.  */\n+/* Implementation of threads compatibility routines for libgcc2.  */\n \n /* Copyright (C) 1999-2022 Free Software Foundation, Inc.\n-   Contributed by Mumit Khan <khan@xraylith.wisc.edu>.\n-   Modified and moved to separate file by Danny Smith\n-   <dannysmith@users.sourceforge.net>.\n \n This file is part of GCC.\n \n@@ -27,239 +23,33 @@ a copy of the GCC Runtime Library Exception along with this program;\n see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n <http://www.gnu.org/licenses/>.  */\n \n-#include <windows.h>\n-#ifndef __GTHREAD_HIDE_WIN32API\n-# define __GTHREAD_HIDE_WIN32API 1\n-#endif\n-#include \"gthr-win32.h\"\n-\n-/* Windows32 threads specific definitions. The windows32 threading model\n-   does not map well into pthread-inspired gcc's threading model, and so \n-   there are caveats one needs to be aware of.\n-\n-   1. The destructor supplied to __gthread_key_create is ignored for\n-      generic x86-win32 ports. This will certainly cause memory leaks \n-      due to unreclaimed eh contexts (sizeof (eh_context) is at least \n-      24 bytes for x86 currently).\n-\n-      This memory leak may be significant for long-running applications\n-      that make heavy use of C++ EH.\n-\n-      However, Mingw runtime (version 0.3 or newer) provides a mechanism\n-      to emulate pthreads key dtors; the runtime provides a special DLL,\n-      linked in if -mthreads option is specified, that runs the dtors in\n-      the reverse order of registration when each thread exits. If\n-      -mthreads option is not given, a stub is linked in instead of the\n-      DLL, which results in memory leak. Other x86-win32 ports can use \n-      the same technique of course to avoid the leak.\n-\n-   2. The error codes returned are non-POSIX like, and cast into ints.\n-      This may cause incorrect error return due to truncation values on \n-      hw where sizeof (DWORD) > sizeof (int).\n-   \n-   3. We are currently using a special mutex instead of the Critical\n-      Sections, since Win9x does not support TryEnterCriticalSection\n-      (while NT does).\n-  \n-   The basic framework should work well enough. In the long term, GCC\n-   needs to use Structured Exception Handling on Windows32.  */\n-\n-int\n-__gthr_win32_once (__gthread_once_t *once, void (*func) (void))\n-{\n-  if (once == NULL || func == NULL)\n-    return EINVAL;\n-\n-  if (! once->done)\n-    {\n-      if (InterlockedIncrement (&(once->started)) == 0)\n-        {\n-\t  (*func) ();\n-\t  once->done = TRUE;\n-\t}\n-      else\n-\t{\n-\t  /* Another thread is currently executing the code, so wait for it \n-\t     to finish; yield the CPU in the meantime.  If performance \n-\t     does become an issue, the solution is to use an Event that \n-\t     we wait on here (and set above), but that implies a place to \n-\t     create the event before this routine is called.  */ \n-\t  while (! once->done)\n-\t    Sleep (0);\n-\t}\n-    }\n-  return 0;\n-}\n-\n-/* Windows32 thread local keys don't support destructors; this leads to\n-   leaks, especially in threaded applications making extensive use of \n-   C++ EH. Mingw uses a thread-support DLL to work-around this problem.  */\n-\n-int\n-__gthr_win32_key_create (__gthread_key_t *key,\n-\t\t\t void (*dtor) (void *) __attribute__((unused)))\n-{\n-  int status = 0;\n-  DWORD tls_index = TlsAlloc ();\n-  if (tls_index != 0xFFFFFFFF)\n-    {\n-      *key = tls_index;\n-#ifdef MINGW32_SUPPORTS_MT_EH\n-      /* Mingw runtime will run the dtors in reverse order for each thread\n-         when the thread exits.  */\n-      status = __mingwthr_key_dtor (*key, dtor);\n-#endif\n-    }\n-  else\n-    status = (int) GetLastError ();\n-  return status;\n-}\n-\n-int\n-__gthr_win32_key_delete (__gthread_key_t key)\n-{\n-  return (TlsFree (key) != 0) ? 0 : (int) GetLastError ();\n-}\n-\n-void *\n-__gthr_win32_getspecific (__gthread_key_t key)\n-{\n-  DWORD lasterror;\n-  void *ptr;\n-  lasterror = GetLastError();\n-  ptr = TlsGetValue(key);\n-  SetLastError( lasterror );\n-  return ptr;\n-}\n+/* Get the out-of-line version of the inline routines.  */\n+\n+#define __GTHREAD_WIN32_ACTIVE_P() 1\n+#define __GTHREAD_WIN32_INLINE\n+\n+#define __gthread_detach __gthr_win32_detach\n+#define __gthread_equal __gthr_win32_equal\n+#define __gthread_yield __gthr_win32_yield\n+#define __gthread_once __gthr_win32_once\n+#define __gthread_key_create __gthr_win32_key_create\n+#define __gthread_key_delete __gthr_win32_key_delete\n+#define __gthread_getspecific __gthr_win32_getspecific\n+#define __gthread_setspecific __gthr_win32_setspecific\n+#define __gthread_mutex_init_function __gthr_win32_mutex_init_function\n+#define __gthread_mutex_destroy __gthr_win32_mutex_destroy\n+#define __gthread_mutex_lock __gthr_win32_mutex_lock\n+#define __gthread_mutex_trylock __gthr_win32_mutex_trylock\n+#define __gthread_mutex_unlock __gthr_win32_mutex_unlock\n+#define __gthread_recursive_mutex_trylock __gthr_win32_recursive_mutex_trylock\n \n-int\n-__gthr_win32_setspecific (__gthread_key_t key, const void *ptr)\n-{\n-  if (TlsSetValue (key, CONST_CAST2(void *, const void *, ptr)) != 0)\n-    return 0;\n-  else\n-    return GetLastError ();\n-}\n-\n-void\n-__gthr_win32_mutex_init_function (__gthread_mutex_t *mutex)\n-{\n-  mutex->counter = -1;\n-  mutex->sema = CreateSemaphoreW (NULL, 0, 65535, NULL);\n-}\n-\n-void\n-__gthr_win32_mutex_destroy (__gthread_mutex_t *mutex)\n-{\n-  CloseHandle ((HANDLE) mutex->sema);\n-}\n-\n-int\n-__gthr_win32_mutex_lock (__gthread_mutex_t *mutex)\n-{\n-  if (InterlockedIncrement (&mutex->counter) == 0 ||\n-      WaitForSingleObject (mutex->sema, INFINITE) == WAIT_OBJECT_0)\n-    return 0;\n-  else\n-    {\n-      /* WaitForSingleObject returns WAIT_FAILED, and we can only do\n-         some best-effort cleanup here.  */\n-      InterlockedDecrement (&mutex->counter);\n-      return 1;\n-    }\n-}\n-\n-int\n-__gthr_win32_mutex_trylock (__gthread_mutex_t *mutex)\n-{\n-  if (__GTHR_W32_InterlockedCompareExchange (&mutex->counter, 0, -1) < 0)\n-    return 0;\n-  else\n-    return 1;\n-}\n-\n-int\n-__gthr_win32_mutex_unlock (__gthread_mutex_t *mutex)\n-{\n-  if (InterlockedDecrement (&mutex->counter) >= 0)\n-    return ReleaseSemaphore (mutex->sema, 1, NULL) ? 0 : 1;\n-  else\n-    return 0;\n-}\n-\n-void\n-__gthr_win32_recursive_mutex_init_function (__gthread_recursive_mutex_t *mutex)\n-{\n-  mutex->counter = -1;\n-  mutex->depth = 0;\n-  mutex->owner = 0;\n-  mutex->sema = CreateSemaphoreW (NULL, 0, 65535, NULL);\n-}\n-\n-int\n-__gthr_win32_recursive_mutex_lock (__gthread_recursive_mutex_t *mutex)\n-{\n-  DWORD me = GetCurrentThreadId();\n-  if (InterlockedIncrement (&mutex->counter) == 0)\n-    {\n-      mutex->depth = 1;\n-      mutex->owner = me;\n-    }\n-  else if (mutex->owner == me)\n-    {\n-      InterlockedDecrement (&mutex->counter);\n-      ++(mutex->depth);\n-    }\n-  else if (WaitForSingleObject (mutex->sema, INFINITE) == WAIT_OBJECT_0)\n-    {\n-      mutex->depth = 1;\n-      mutex->owner = me;\n-    }\n-  else\n-    {\n-      /* WaitForSingleObject returns WAIT_FAILED, and we can only do\n-         some best-effort cleanup here.  */\n-      InterlockedDecrement (&mutex->counter);\n-      return 1;\n-    }\n-  return 0;\n-}\n-\n-int\n-__gthr_win32_recursive_mutex_trylock (__gthread_recursive_mutex_t *mutex)\n-{\n-  DWORD me = GetCurrentThreadId();\n-  if (__GTHR_W32_InterlockedCompareExchange (&mutex->counter, 0, -1) < 0)\n-    {\n-      mutex->depth = 1;\n-      mutex->owner = me;\n-    }\n-  else if (mutex->owner == me)\n-    ++(mutex->depth);\n-  else\n-    return 1;\n-\n-  return 0;\n-}\n-\n-int\n-__gthr_win32_recursive_mutex_unlock (__gthread_recursive_mutex_t *mutex)\n-{\n-  --(mutex->depth);\n-  if (mutex->depth == 0)\n-    {\n-      mutex->owner = 0;\n+#include \"gthr-win32.h\"\n \n-      if (InterlockedDecrement (&mutex->counter) >= 0)\n-\treturn ReleaseSemaphore (mutex->sema, 1, NULL) ? 0 : 1;\n-    }\n+/* Check the sizes of the local version of the Win32 types.  */\n \n-  return 0;\n-}\n+#define CHECK_SIZE_OF(TYPE) \\\n+  typedef int assertion[sizeof(__gthr_win32_##TYPE) == sizeof(TYPE) ? 1 : -1];\n \n-int\n-__gthr_win32_recursive_mutex_destroy (__gthread_recursive_mutex_t *mutex)\n-{\n-  CloseHandle ((HANDLE) mutex->sema);\n-  return 0;\n-}\n+CHECK_SIZE_OF (DWORD)\n+CHECK_SIZE_OF (HANDLE)\n+CHECK_SIZE_OF (CRITICAL_SECTION)"}, {"sha": "9485dd50bf90c6ed3756a2ec74c0ad3aa6bb967f", "filename": "libgcc/config/i386/gthr-win32.h", "status": "modified", "additions": 318, "deletions": 218, "changes": 536, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9149a5b7e0a66b7b94d5b7db3194a975d18dea2f/libgcc%2Fconfig%2Fi386%2Fgthr-win32.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9149a5b7e0a66b7b94d5b7db3194a975d18dea2f/libgcc%2Fconfig%2Fi386%2Fgthr-win32.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fi386%2Fgthr-win32.h?ref=9149a5b7e0a66b7b94d5b7db3194a975d18dea2f", "patch": "@@ -28,18 +28,15 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #ifndef GCC_GTHR_WIN32_H\n #define GCC_GTHR_WIN32_H\n \n-/* Make sure CONST_CAST2 (origin in system.h) is declared.  */\n-#ifndef CONST_CAST2\n-#define CONST_CAST2(TOTYPE,FROMTYPE,X) ((__extension__(union {FROMTYPE _q; TOTYPE _nq;})(X))._nq)\n-#endif\n+/* So we can test Windows version numbers.  */\n+#include <stdlib.h>\n \n-/* Windows32 threads specific definitions. The windows32 threading model\n-   does not map well into pthread-inspired gcc's threading model, and so\n-   there are caveats one needs to be aware of.\n+/* The Windows threading model does not map well into the POSIX inspired\n+   GCC threading model, so there are caveats one needs to be aware of.\n \n    1. The destructor supplied to __gthread_key_create is ignored for\n-      generic x86-win32 ports. This will certainly cause memory leaks\n-      due to unreclaimed eh contexts (sizeof (eh_context) is at least\n+      generic Windows ports.  This will certainly cause memory leaks\n+      due to unreclaimed EH contexts (sizeof (eh_context) is at least\n       24 bytes for x86 currently).\n \n       This memory leak may be significant for long-running applications\n@@ -50,29 +47,41 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n       linked in if -mthreads option is specified, that runs the dtors in\n       the reverse order of registration when each thread exits. If\n       -mthreads option is not given, a stub is linked in instead of the\n-      DLL, which results in memory leak. Other x86-win32 ports can use\n+      DLL, which results in memory leak.  Other Windows ports can use\n       the same technique of course to avoid the leak.\n \n    2. The error codes returned are non-POSIX like, and cast into ints.\n       This may cause incorrect error return due to truncation values on\n       hw where sizeof (DWORD) > sizeof (int).\n \n-   3. We are currently using a special mutex instead of the Critical\n-      Sections, since Win9x does not support TryEnterCriticalSection\n-      (while NT does).\n+   3. POSIX-like condition variables are supported, but only on Vista and\n+      Server 2008 or later versions.\n \n-   The basic framework should work well enough. In the long term, GCC\n-   needs to use Structured Exception Handling on Windows32.  */\n+   4. Timed lock primitives are not supported.  */\n \n #define __GTHREADS 1\n \n-#include <errno.h>\n-#ifdef __MINGW32__\n-#include <_mingw.h>\n+/* Condition variables are supported on Vista and Server 2008 or later.  */\n+#if _WIN32_WINNT >= 0x0600\n+#define __GTHREAD_HAS_COND 1\n+#define __GTHREADS_CXX0X 1\n+#endif\n+\n+#if _GTHREAD_USE_MUTEX_TIMEDLOCK\n+#error Timed lock primitives are not supported on Windows targets\n+#endif\n+\n+/* Make sure CONST_CAST2 (origin in system.h) is declared.  */\n+#ifndef CONST_CAST2\n+#ifdef __cplusplus\n+#define CONST_CAST2(TOTYPE,FROMTYPE,X) (const_cast<TOTYPE> (X))\n+#else\n+#define CONST_CAST2(TOTYPE,FROMTYPE,X) ((__extension__(union {FROMTYPE _q; TOTYPE _nq;})(X))._nq)\n+#endif\n #endif\n \n-#ifndef __UNUSED_PARAM\n-#define __UNUSED_PARAM(x) x\n+#ifndef ATTRIBUTE_UNUSED\n+#define ATTRIBUTE_UNUSED __attribute__ ((__unused__))\n #endif\n \n #ifdef _LIBOBJC\n@@ -82,12 +91,13 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #ifndef __OBJC__\n #define __OBJC__\n #endif\n+#define WIN32_LEAN_AND_MEAN\n #include <windows.h>\n /* Now undef the windows BOOL.  */\n #undef BOOL\n \n /* Key structure for maintaining thread specific storage */\n-static DWORD\t__gthread_objc_data_tls = (DWORD) -1;\n+static DWORD __gthread_objc_data_tls = TLS_OUT_OF_INDEXES;\n \n /* Backend initialization functions */\n \n@@ -96,7 +106,7 @@ int\n __gthread_objc_init_thread_system (void)\n {\n   /* Initialize the thread storage key.  */\n-  if ((__gthread_objc_data_tls = TlsAlloc ()) != (DWORD) -1)\n+  if ((__gthread_objc_data_tls = TlsAlloc ()) != TLS_OUT_OF_INDEXES)\n     return 0;\n   else\n     return -1;\n@@ -106,7 +116,7 @@ __gthread_objc_init_thread_system (void)\n int\n __gthread_objc_close_thread_system (void)\n {\n-  if (__gthread_objc_data_tls != (DWORD) -1)\n+  if (__gthread_objc_data_tls != TLS_OUT_OF_INDEXES)\n     TlsFree (__gthread_objc_data_tls);\n   return 0;\n }\n@@ -222,15 +232,9 @@ __gthread_objc_thread_set_data (void *value)\n void *\n __gthread_objc_thread_get_data (void)\n {\n-  DWORD lasterror;\n-  void *ptr;\n-\n-  lasterror = GetLastError ();\n-\n-  ptr = TlsGetValue (__gthread_objc_data_tls);          /* Return thread data.  */\n-\n+  DWORD lasterror = GetLastError ();\n+  void * ptr = TlsGetValue (__gthread_objc_data_tls);\n   SetLastError (lasterror);\n-\n   return ptr;\n }\n \n@@ -294,76 +298,87 @@ __gthread_objc_mutex_unlock (objc_mutex_t mutex)\n \n /* Allocate a condition.  */\n int\n-__gthread_objc_condition_allocate (objc_condition_t __UNUSED_PARAM(condition))\n+__gthread_objc_condition_allocate (objc_condition_t condition ATTRIBUTE_UNUSED)\n {\n   /* Unimplemented.  */\n   return -1;\n }\n \n /* Deallocate a condition.  */\n int\n-__gthread_objc_condition_deallocate (objc_condition_t __UNUSED_PARAM(condition))\n+__gthread_objc_condition_deallocate (objc_condition_t condition ATTRIBUTE_UNUSED)\n {\n   /* Unimplemented.  */\n   return -1;\n }\n \n /* Wait on the condition */\n int\n-__gthread_objc_condition_wait (objc_condition_t __UNUSED_PARAM(condition),\n-\t\t\t       objc_mutex_t __UNUSED_PARAM(mutex))\n+__gthread_objc_condition_wait (objc_condition_t condition ATTRIBUTE_UNUSED,\n+\t\t\t       objc_mutex_t mutex ATTRIBUTE_UNUSED)\n {\n   /* Unimplemented.  */\n   return -1;\n }\n \n /* Wake up all threads waiting on this condition.  */\n int\n-__gthread_objc_condition_broadcast (objc_condition_t __UNUSED_PARAM(condition))\n+__gthread_objc_condition_broadcast (objc_condition_t condition ATTRIBUTE_UNUSED)\n {\n   /* Unimplemented.  */\n   return -1;\n }\n \n /* Wake up one thread waiting on this condition.  */\n int\n-__gthread_objc_condition_signal (objc_condition_t __UNUSED_PARAM(condition))\n+__gthread_objc_condition_signal (objc_condition_t condition ATTRIBUTE_UNUSED)\n {\n   /* Unimplemented.  */\n   return -1;\n }\n \n #else /* _LIBOBJC */\n \n+/* For struct timespec.  Do not include <sys/time.h> here since Gnulib provides\n+   its own version which drags the Win32 API definitions.  */\n+#include <sys/timeb.h>\n+\n #ifdef __cplusplus\n extern \"C\" {\n #endif\n \n-typedef unsigned long __gthread_key_t;\n+typedef unsigned int __gthr_win32_DWORD;\n+typedef void *__gthr_win32_HANDLE;\n \n typedef struct {\n-  int done;\n-  long started;\n-} __gthread_once_t;\n+  void *DebugInfo;\n+  int LockCount;\n+  int RecursionCount;\n+  __gthr_win32_HANDLE OwningThread;\n+  __gthr_win32_HANDLE LockSemaphore;\n+  void *SpinCount;\n+} __gthr_win32_CRITICAL_SECTION;\n \n typedef struct {\n-  long counter;\n-  void *sema;\n-} __gthread_mutex_t;\n-\n-typedef struct {\n-  long counter;\n-  long depth;\n-  unsigned long owner;\n-  void *sema;\n-} __gthread_recursive_mutex_t;\n+  void *Ptr;\n+} __gthr_win32_CONDITION_VARIABLE;\n+\n+typedef __gthr_win32_HANDLE __gthread_t;\n+typedef __gthr_win32_DWORD __gthread_key_t;\n+typedef struct { int done; long started; } __gthread_once_t;\n+typedef __gthr_win32_CRITICAL_SECTION __gthread_mutex_t;\n+typedef __gthr_win32_CRITICAL_SECTION __gthread_recursive_mutex_t;\n+#if __GTHREAD_HAS_COND\n+typedef __gthr_win32_CONDITION_VARIABLE __gthread_cond_t;\n+#endif\n+typedef struct timespec __gthread_time_t;\n \n #define __GTHREAD_ONCE_INIT {0, -1}\n #define __GTHREAD_MUTEX_INIT_FUNCTION __gthread_mutex_init_function\n-#define __GTHREAD_MUTEX_INIT_DEFAULT {-1, 0}\n #define __GTHREAD_RECURSIVE_MUTEX_INIT_FUNCTION \\\n   __gthread_recursive_mutex_init_function\n-#define __GTHREAD_RECURSIVE_MUTEX_INIT_DEFAULT {-1, 0, 0, 0}\n+#define __GTHREAD_COND_INIT_FUNCTION __gthread_cond_init_function\n+#define __GTHREAD_TIME_INIT {0, 0}\n \n #if defined (_WIN32) && !defined(__CYGWIN__)\n #define MINGW32_SUPPORTS_MT_EH 1\n@@ -388,30 +403,74 @@ __gthread_active_p (void)\n #endif\n }\n \n-#if __GTHREAD_HIDE_WIN32API\n-\n-/* The implementations are in config/i386/gthr-win32.c in libgcc.a.\n-   Only stubs are exposed to avoid polluting the C++ namespace with\n-   windows api definitions.  */\n-\n+extern int __gthr_win32_create (__gthread_t *, void *(*) (void*), void *);\n+extern int __gthr_win32_join (__gthread_t, void **);\n+extern __gthread_t __gthr_win32_self (void);\n extern int __gthr_win32_once (__gthread_once_t *, void (*) (void));\n+extern int __gthr_win32_detach (__gthread_t);\n+extern int __gthr_win32_equal (__gthread_t, __gthread_t);\n+extern int __gthr_win32_yield (void);\n extern int __gthr_win32_key_create (__gthread_key_t *, void (*) (void*));\n extern int __gthr_win32_key_delete (__gthread_key_t);\n extern void * __gthr_win32_getspecific (__gthread_key_t);\n extern int __gthr_win32_setspecific (__gthread_key_t, const void *);\n extern void __gthr_win32_mutex_init_function (__gthread_mutex_t *);\n+extern void __gthr_win32_mutex_destroy (__gthread_mutex_t *);\n extern int __gthr_win32_mutex_lock (__gthread_mutex_t *);\n extern int __gthr_win32_mutex_trylock (__gthread_mutex_t *);\n extern int __gthr_win32_mutex_unlock (__gthread_mutex_t *);\n-extern void\n-  __gthr_win32_recursive_mutex_init_function (__gthread_recursive_mutex_t *);\n-extern int __gthr_win32_recursive_mutex_lock (__gthread_recursive_mutex_t *);\n-extern int\n-  __gthr_win32_recursive_mutex_trylock (__gthread_recursive_mutex_t *);\n-extern int __gthr_win32_recursive_mutex_unlock (__gthread_recursive_mutex_t *);\n-extern void __gthr_win32_mutex_destroy (__gthread_mutex_t *);\n-extern int\n-  __gthr_win32_recursive_mutex_destroy (__gthread_recursive_mutex_t *);\n+extern int __gthr_win32_recursive_mutex_trylock (__gthread_recursive_mutex_t *);\n+#if __GTHREAD_HAS_COND\n+extern void __gthr_win32_cond_init_function (__gthread_cond_t *);\n+extern int __gthr_win32_cond_broadcast (__gthread_cond_t *);\n+extern int __gthr_win32_cond_signal (__gthread_cond_t *);\n+extern int __gthr_win32_cond_wait (__gthread_cond_t *, __gthread_mutex_t *);\n+extern int __gthr_win32_cond_timedwait (__gthread_cond_t *, __gthread_mutex_t *,\n+\t\t\t\t\tconst __gthread_time_t *);\n+#endif\n+\n+static inline int\n+__gthread_create (__gthread_t *__thr, void *(*__func) (void*),\n+\t\t  void *__args)\n+{\n+  return __gthr_win32_create (__thr, __func, __args);\n+}\n+\n+static inline int\n+__gthread_join (__gthread_t __thr, void **__value_ptr)\n+{\n+  return __gthr_win32_join (__thr, __value_ptr);\n+}\n+\n+static inline __gthread_t\n+__gthread_self (void)\n+{\n+  return __gthr_win32_self ();\n+}\n+\n+#if __GTHREAD_HIDE_WIN32API\n+\n+/* The implementations are in config/i386/gthr-win32.c in libgcc.a.\n+   Only stubs are exposed to avoid polluting the C++ namespace with\n+   Win32 API definitions.  */\n+\n+static inline int\n+__gthread_detach (__gthread_t __thr)\n+{\n+  return __gthr_win32_detach (__thr);\n+}\n+\n+static inline int\n+__gthread_equal (__gthread_t __thr1, __gthread_t __thr2)\n+{\n+  return __gthr_win32_equal (__thr1, __thr2);\n+}\n+\n+static inline int\n+__gthread_yield (void)\n+{\n+  return __gthr_win32_yield ();\n+}\n \n static inline int\n __gthread_once (__gthread_once_t *__once, void (*__func) (void))\n@@ -485,279 +544,320 @@ __gthread_mutex_unlock (__gthread_mutex_t *__mutex)\n     return 0;\n }\n \n+static inline int\n+__gthread_recursive_mutex_trylock (__gthread_recursive_mutex_t *__mutex)\n+{\n+  if (__gthread_active_p ())\n+    return __gthr_win32_recursive_mutex_trylock (__mutex);\n+  else\n+    return 0;\n+}\n+\n+#if __GTHREAD_HAS_COND\n+\n static inline void\n-__gthread_recursive_mutex_init_function (__gthread_recursive_mutex_t *__mutex)\n+__gthread_cond_init_function (__gthread_cond_t *__cond)\n {\n-   __gthr_win32_recursive_mutex_init_function (__mutex);\n+  __gthr_win32_cond_init_function (__cond);\n }\n \n static inline int\n-__gthread_recursive_mutex_lock (__gthread_recursive_mutex_t *__mutex)\n+__gthread_cond_broadcast (__gthread_cond_t *__cond)\n {\n-  if (__gthread_active_p ())\n-    return __gthr_win32_recursive_mutex_lock (__mutex);\n-  else\n-    return 0;\n+  return __gthr_win32_cond_broadcast (__cond);\n }\n \n static inline int\n-__gthread_recursive_mutex_trylock (__gthread_recursive_mutex_t *__mutex)\n+__gthread_cond_signal (__gthread_cond_t *__cond)\n {\n-  if (__gthread_active_p ())\n-    return __gthr_win32_recursive_mutex_trylock (__mutex);\n-  else\n-    return 0;\n+  return __gthr_win32_cond_signal (__cond);\n }\n \n static inline int\n-__gthread_recursive_mutex_unlock (__gthread_recursive_mutex_t *__mutex)\n+__gthread_cond_wait (__gthread_cond_t *__cond, __gthread_mutex_t *__mutex)\n {\n-  if (__gthread_active_p ())\n-    return __gthr_win32_recursive_mutex_unlock (__mutex);\n-  else\n-    return 0;\n+  return __gthr_win32_cond_wait (__cond, __mutex);\n }\n \n static inline int\n-__gthread_recursive_mutex_destroy (__gthread_recursive_mutex_t *__mutex)\n+__gthread_cond_timedwait (__gthread_cond_t *__cond, __gthread_mutex_t *__mutex,\n+\t\t\t  const __gthread_time_t *__abs_time)\n {\n-  return __gthr_win32_recursive_mutex_destroy (__mutex);\n+  return __gthr_win32_cond_timedwait (__cond, __mutex, __abs_time);\n }\n \n+#endif /* __GTHREAD_HAS_COND */\n+\n #else /* ! __GTHREAD_HIDE_WIN32API */\n \n-#define NOGDI\n+#ifndef __GTHREAD_WIN32_INLINE\n+#define __GTHREAD_WIN32_INLINE static inline\n+#endif\n+\n+#ifndef __GTHREAD_WIN32_COND_INLINE\n+#define __GTHREAD_WIN32_COND_INLINE static inline\n+#endif\n+\n+#ifndef __GTHREAD_WIN32_ACTIVE_P\n+#define __GTHREAD_WIN32_ACTIVE_P __gthread_active_p\n+#endif\n+\n+#define WIN32_LEAN_AND_MEAN\n #include <windows.h>\n-#include <errno.h>\n \n-static inline int\n+__GTHREAD_WIN32_INLINE int\n+__gthread_detach (__gthread_t __thr)\n+{\n+  CloseHandle ((HANDLE) __thr);\n+  return 0;\n+}\n+\n+__GTHREAD_WIN32_INLINE int\n+__gthread_equal (__gthread_t __t1, __gthread_t __t2)\n+{\n+  return GetThreadId ((HANDLE) __t1) == GetThreadId ((HANDLE) __t2);\n+}\n+\n+__GTHREAD_WIN32_INLINE int\n+__gthread_yield (void)\n+{\n+  Sleep (0);\n+  return 0;\n+}\n+\n+__GTHREAD_WIN32_INLINE int\n __gthread_once (__gthread_once_t *__once, void (*__func) (void))\n {\n-  if (! __gthread_active_p ())\n+  if (!__GTHREAD_WIN32_ACTIVE_P ())\n     return -1;\n-  else if (__once == NULL || __func == NULL)\n-    return EINVAL;\n \n-  if (! __once->done)\n+  if (__builtin_expect (!__once->done, 0))\n     {\n-      if (InterlockedIncrement (&(__once->started)) == 0)\n+      /* We rely on the memory model of the x86 architecture where every load\n+\t has acquire semantics and every store has release semantics.  */\n+      if (__atomic_add_fetch (&__once->started, 1, __ATOMIC_ACQ_REL) == 0)\n \t{\n \t  (*__func) ();\n-\t  __once->done = TRUE;\n+\t  __once->done = 1;\n \t}\n       else\n \t{\n \t  /* Another thread is currently executing the code, so wait for it\n-\t     to finish; yield the CPU in the meantime.  If performance\n+\t     to finish and yield the CPU in the meantime.  If performance\n \t     does become an issue, the solution is to use an Event that\n \t     we wait on here (and set above), but that implies a place to\n \t     create the event before this routine is called.  */\n-\t  while (! __once->done)\n-\t    Sleep (0);\n+\t  while (!__once->done)\n+\t    __gthread_yield ();\n \t}\n     }\n \n   return 0;\n }\n \n-/* Windows32 thread local keys don't support destructors; this leads to\n+/* Windows thread local keys don't support destructors; this leads to\n    leaks, especially in threaded applications making extensive use of\n    C++ EH. Mingw uses a thread-support DLL to work-around this problem.  */\n-static inline int\n+__GTHREAD_WIN32_INLINE int\n __gthread_key_create (__gthread_key_t *__key,\n-\t\t      void (*__dtor) (void *) __attribute__((__unused__)))\n+\t\t      void (*__dtor) (void *) ATTRIBUTE_UNUSED)\n {\n-  int __status = 0;\n   DWORD __tls_index = TlsAlloc ();\n-  if (__tls_index != 0xFFFFFFFF)\n+  if (__tls_index != TLS_OUT_OF_INDEXES)\n     {\n       *__key = __tls_index;\n #ifdef MINGW32_SUPPORTS_MT_EH\n       /* Mingw runtime will run the dtors in reverse order for each thread\n          when the thread exits.  */\n-      __status = __mingwthr_key_dtor (*__key, __dtor);\n+      return __mingwthr_key_dtor (*__key, __dtor);\n+#else\n+      return 0;\n #endif\n     }\n   else\n-    __status = (int) GetLastError ();\n-  return __status;\n+    return (int) GetLastError ();\n }\n \n-static inline int\n+__GTHREAD_WIN32_INLINE int\n __gthread_key_delete (__gthread_key_t __key)\n {\n-  return (TlsFree (__key) != 0) ? 0 : (int) GetLastError ();\n+  if (TlsFree (__key))\n+    return 0;\n+  else\n+    return (int) GetLastError ();\n }\n \n-static inline void *\n+__GTHREAD_WIN32_INLINE void *\n __gthread_getspecific (__gthread_key_t __key)\n {\n-  DWORD __lasterror;\n-  void *__ptr;\n-\n-  __lasterror = GetLastError ();\n-\n-  __ptr = TlsGetValue (__key);\n-\n+  DWORD __lasterror = GetLastError ();\n+  void *__ptr = TlsGetValue (__key);\n   SetLastError (__lasterror);\n-\n   return __ptr;\n }\n \n-static inline int\n+__GTHREAD_WIN32_INLINE int\n __gthread_setspecific (__gthread_key_t __key, const void *__ptr)\n {\n-  if (TlsSetValue (__key, CONST_CAST2(void *, const void *, __ptr)) != 0)\n+  if (TlsSetValue (__key, CONST_CAST2(void *, const void *, __ptr)))\n     return 0;\n   else\n-    return GetLastError ();\n+    return (int) GetLastError ();\n }\n \n-static inline void\n+__GTHREAD_WIN32_INLINE void\n __gthread_mutex_init_function (__gthread_mutex_t *__mutex)\n {\n-  __mutex->counter = -1;\n-  __mutex->sema = CreateSemaphoreW (NULL, 0, 65535, NULL);\n+  InitializeCriticalSection ((LPCRITICAL_SECTION) __mutex);\n }\n \n-static inline void\n+__GTHREAD_WIN32_INLINE void\n __gthread_mutex_destroy (__gthread_mutex_t *__mutex)\n {\n-  CloseHandle ((HANDLE) __mutex->sema);\n+  DeleteCriticalSection ((LPCRITICAL_SECTION) __mutex);\n }\n \n-static inline int\n+__GTHREAD_WIN32_INLINE int\n __gthread_mutex_lock (__gthread_mutex_t *__mutex)\n {\n-  int __status = 0;\n+  if (__GTHREAD_WIN32_ACTIVE_P ())\n+    EnterCriticalSection ((LPCRITICAL_SECTION) __mutex);\n+  return 0;\n+}\n \n-  if (__gthread_active_p ())\n+__GTHREAD_WIN32_INLINE int\n+__gthread_mutex_trylock (__gthread_mutex_t *__mutex)\n+{\n+  if (__GTHREAD_WIN32_ACTIVE_P ())\n     {\n-      if (InterlockedIncrement (&__mutex->counter) == 0 ||\n-\t  WaitForSingleObject (__mutex->sema, INFINITE) == WAIT_OBJECT_0)\n-\t__status = 0;\n-      else\n+      BOOL __ret = TryEnterCriticalSection ((LPCRITICAL_SECTION) __mutex);\n+      if (__ret)\n \t{\n-\t  /* WaitForSingleObject returns WAIT_FAILED, and we can only do\n-\t     some best-effort cleanup here.  */\n-\t  InterlockedDecrement (&__mutex->counter);\n-\t  __status = 1;\n+\t  if (__mutex->RecursionCount > 1)\n+\t    {\n+\t      LeaveCriticalSection ((LPCRITICAL_SECTION) __mutex);\n+\t      return 1;\n+\t    }\n+\t  else\n+\t    return 0;\n \t}\n+      else\n+\treturn 1;\n     }\n-  return __status;\n+  else\n+    return 0;\n }\n \n-static inline int\n-__gthread_mutex_trylock (__gthread_mutex_t *__mutex)\n+__GTHREAD_WIN32_INLINE int\n+__gthread_mutex_unlock (__gthread_mutex_t *__mutex)\n {\n-  int __status = 0;\n+  if (__GTHREAD_WIN32_ACTIVE_P ())\n+    LeaveCriticalSection ((LPCRITICAL_SECTION) __mutex);\n+  return 0;\n+}\n \n-  if (__gthread_active_p ())\n-    {\n-      if (__GTHR_W32_InterlockedCompareExchange (&__mutex->counter, 0, -1) < 0)\n-\t__status = 0;\n-      else\n-\t__status = 1;\n-    }\n-  return __status;\n+__GTHREAD_WIN32_INLINE int\n+__gthread_recursive_mutex_trylock (__gthread_recursive_mutex_t *__mutex)\n+{\n+  if (__GTHREAD_WIN32_ACTIVE_P ())\n+    return TryEnterCriticalSection ((LPCRITICAL_SECTION) __mutex) ? 0 : 1;\n+  else\n+    return 0;\n }\n \n-static inline int\n-__gthread_mutex_unlock (__gthread_mutex_t *__mutex)\n+#if __GTHREAD_HAS_COND\n+\n+__GTHREAD_WIN32_COND_INLINE void\n+__gthread_cond_init_function (__gthread_cond_t *__cond)\n {\n-  if (__gthread_active_p ())\n-    {\n-      if (InterlockedDecrement (&__mutex->counter) >= 0)\n-\treturn ReleaseSemaphore (__mutex->sema, 1, NULL) ? 0 : 1;\n-    }\n+  InitializeConditionVariable ((PCONDITION_VARIABLE) __cond);\n+}\n+\n+__GTHREAD_WIN32_COND_INLINE int\n+__gthread_cond_broadcast (__gthread_cond_t *__cond)\n+{\n+  WakeAllConditionVariable ((PCONDITION_VARIABLE) __cond);\n   return 0;\n }\n \n+__GTHREAD_WIN32_COND_INLINE int\n+__gthread_cond_signal (__gthread_cond_t *__cond)\n+{\n+  WakeConditionVariable ((PCONDITION_VARIABLE) __cond);\n+  return 0;\n+}\n+\n+__GTHREAD_WIN32_COND_INLINE int\n+__gthread_cond_wait (__gthread_cond_t *__cond, __gthread_mutex_t *__mutex)\n+{\n+  if (SleepConditionVariableCS ((PCONDITION_VARIABLE) __cond,\n+\t\t\t\t(PCRITICAL_SECTION) __mutex,\n+\t\t\t\tINFINITE))\n+    return 0;\n+  else\n+    return (int) GetLastError ();\n+}\n+\n+extern DWORD __gthr_win32_abs_to_rel_time (const __gthread_time_t *);\n+\n+__GTHREAD_WIN32_COND_INLINE int\n+__gthread_cond_timedwait (__gthread_cond_t *__cond,\n+\t\t\t  __gthread_mutex_t *__mutex,\n+\t\t\t  const __gthread_time_t *__abs_time)\n+{\n+  DWORD __rel_time = __gthr_win32_abs_to_rel_time (__abs_time);\n+  if (SleepConditionVariableCS ((PCONDITION_VARIABLE) __cond,\n+\t\t\t\t(PCRITICAL_SECTION) __mutex,\n+\t\t\t\t__rel_time))\n+    return 0;\n+  else\n+    return (int) GetLastError ();\n+}\n+\n+#endif /* __GTHREAD_HAS_COND */\n+\n+#endif /*  __GTHREAD_HIDE_WIN32API */\n+\n static inline void\n __gthread_recursive_mutex_init_function (__gthread_recursive_mutex_t *__mutex)\n {\n-  __mutex->counter = -1;\n-  __mutex->depth = 0;\n-  __mutex->owner = 0;\n-  __mutex->sema = CreateSemaphoreW (NULL, 0, 65535, NULL);\n+  __gthread_mutex_init_function (__mutex);\n }\n \n-static inline int\n-__gthread_recursive_mutex_lock (__gthread_recursive_mutex_t *__mutex)\n+static inline void\n+__gthread_recursive_mutex_destroy (__gthread_recursive_mutex_t *__mutex)\n {\n-  if (__gthread_active_p ())\n-    {\n-      DWORD __me = GetCurrentThreadId();\n-      if (InterlockedIncrement (&__mutex->counter) == 0)\n-\t{\n-\t  __mutex->depth = 1;\n-\t  __mutex->owner = __me;\n-\t}\n-      else if (__mutex->owner == __me)\n-\t{\n-\t  InterlockedDecrement (&__mutex->counter);\n-\t  ++(__mutex->depth);\n-\t}\n-      else if (WaitForSingleObject (__mutex->sema, INFINITE) == WAIT_OBJECT_0)\n-\t{\n-\t  __mutex->depth = 1;\n-\t  __mutex->owner = __me;\n-\t}\n-      else\n-\t{\n-\t  /* WaitForSingleObject returns WAIT_FAILED, and we can only do\n-\t     some best-effort cleanup here.  */\n-\t  InterlockedDecrement (&__mutex->counter);\n-\t  return 1;\n-\t}\n-    }\n-  return 0;\n+  __gthread_mutex_destroy (__mutex);\n }\n \n static inline int\n-__gthread_recursive_mutex_trylock (__gthread_recursive_mutex_t *__mutex)\n+__gthread_recursive_mutex_lock (__gthread_recursive_mutex_t *__mutex)\n {\n-  if (__gthread_active_p ())\n-    {\n-      DWORD __me = GetCurrentThreadId();\n-      if (__GTHR_W32_InterlockedCompareExchange (&__mutex->counter, 0, -1) < 0)\n-\t{\n-\t  __mutex->depth = 1;\n-\t  __mutex->owner = __me;\n-\t}\n-      else if (__mutex->owner == __me)\n-\t++(__mutex->depth);\n-      else\n-\treturn 1;\n-    }\n-  return 0;\n+  return __gthread_mutex_lock (__mutex);\n }\n \n static inline int\n __gthread_recursive_mutex_unlock (__gthread_recursive_mutex_t *__mutex)\n {\n-  if (__gthread_active_p ())\n-    {\n-      --(__mutex->depth);\n-      if (__mutex->depth == 0)\n-\t{\n-\t  __mutex->owner = 0;\n+  return __gthread_mutex_unlock (__mutex);\n+}\n \n-\t  if (InterlockedDecrement (&__mutex->counter) >= 0)\n-\t    return ReleaseSemaphore (__mutex->sema, 1, NULL) ? 0 : 1;\n-\t}\n-    }\n+#if __GTHREAD_HAS_COND\n+\n+static inline int\n+__gthread_cond_destroy (__gthread_cond_t *__cond ATTRIBUTE_UNUSED)\n+{\n   return 0;\n }\n \n static inline int\n-__gthread_recursive_mutex_destroy (__gthread_recursive_mutex_t *__mutex)\n+__gthread_cond_wait_recursive (__gthread_cond_t *__cond,\n+\t\t\t       __gthread_recursive_mutex_t *__mutex)\n {\n-  CloseHandle ((HANDLE) __mutex->sema);\n-  return 0;\n+  return __gthread_cond_wait (__cond, __mutex);\n }\n \n-#endif /*  __GTHREAD_HIDE_WIN32API */\n+#endif\n \n #ifdef __cplusplus\n }"}, {"sha": "89f8741f9deab7580980ef5b00e215ec22b83efa", "filename": "libgcc/config/i386/libgcc-mingw.ver", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9149a5b7e0a66b7b94d5b7db3194a975d18dea2f/libgcc%2Fconfig%2Fi386%2Flibgcc-mingw.ver", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9149a5b7e0a66b7b94d5b7db3194a975d18dea2f/libgcc%2Fconfig%2Fi386%2Flibgcc-mingw.ver", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fi386%2Flibgcc-mingw.ver?ref=9149a5b7e0a66b7b94d5b7db3194a975d18dea2f", "patch": "@@ -0,0 +1,23 @@\n+# Copyright (C) 2022 Free Software Foundation, Inc.\n+#\n+# This file is part of GCC.\n+#\n+# GCC is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3, or (at your option)\n+# any later version.\n+#\n+# GCC is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with GCC; see the file COPYING3.  If not see\n+# <http://www.gnu.org/licenses/>.\n+\n+GCC_13 {\n+  __gthr_win32_create\n+  __gthr_win32_join\n+  __gthr_win32_self\n+}"}, {"sha": "c2726e23794bb9bb621c1ad3822416bb8e58ed98", "filename": "libgcc/config/i386/t-gthr-win32", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9149a5b7e0a66b7b94d5b7db3194a975d18dea2f/libgcc%2Fconfig%2Fi386%2Ft-gthr-win32", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9149a5b7e0a66b7b94d5b7db3194a975d18dea2f/libgcc%2Fconfig%2Fi386%2Ft-gthr-win32", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fi386%2Ft-gthr-win32?ref=9149a5b7e0a66b7b94d5b7db3194a975d18dea2f", "patch": "@@ -1,2 +1,6 @@\n-# We hide calls to w32api needed for w32 thread support here:\n-LIB2ADD = $(srcdir)/config/i386/gthr-win32.c\n+# We need a unique module interfacing with the Win32 API for thread support.\n+LIB2ADDEH += $(srcdir)/config/i386/gthr-win32-thread.c\n+# We hide calls to the Win32 API needed for condition variable support here.\n+LIB2ADD_ST += $(srcdir)/config/i386/gthr-win32-cond.c\n+# We hide calls to the Win32 API needed for the rest here.\n+LIB2ADD_ST += $(srcdir)/config/i386/gthr-win32.c"}, {"sha": "f4ad0a8ede3905af24c126087aef767db3a67f2c", "filename": "libgcc/config/i386/t-slibgcc-mingw", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9149a5b7e0a66b7b94d5b7db3194a975d18dea2f/libgcc%2Fconfig%2Fi386%2Ft-slibgcc-mingw", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9149a5b7e0a66b7b94d5b7db3194a975d18dea2f/libgcc%2Fconfig%2Fi386%2Ft-slibgcc-mingw", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fi386%2Ft-slibgcc-mingw?ref=9149a5b7e0a66b7b94d5b7db3194a975d18dea2f", "patch": "@@ -0,0 +1 @@\n+SHLIB_MAPFILES += $(srcdir)/config/i386/libgcc-mingw.ver"}, {"sha": "51c3c5103640c6eef80edb9db6d69904bc770683", "filename": "libstdc++-v3/acinclude.m4", "status": "modified", "additions": 28, "deletions": 14, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9149a5b7e0a66b7b94d5b7db3194a975d18dea2f/libstdc%2B%2B-v3%2Facinclude.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9149a5b7e0a66b7b94d5b7db3194a975d18dea2f/libstdc%2B%2B-v3%2Facinclude.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Facinclude.m4?ref=9149a5b7e0a66b7b94d5b7db3194a975d18dea2f", "patch": "@@ -678,10 +678,13 @@ dnl Set up *_FLAGS and *FLAGS variables for all sundry Makefile.am's.\n dnl (SECTION_FLAGS is done under CHECK_COMPILER_FEATURES.)\n dnl\n dnl Substs:\n+dnl  CPPFLAGS\n dnl  OPTIMIZE_CXXFLAGS\n dnl  WARN_FLAGS\n dnl\n AC_DEFUN([GLIBCXX_EXPORT_FLAGS], [\n+  AC_SUBST(CPPFLAGS)\n+\n   # Optimization flags that are probably a good idea for thrill-seekers. Just\n   # uncomment the lines below and make, everything else is ready to go...\n   # Alternatively OPTIMIZE_CXXFLAGS can be set in configure.host.\n@@ -1352,6 +1355,10 @@ AC_DEFUN([GLIBCXX_ENABLE_LIBSTDCXX_TIME], [\n       cygwin*)\n         ac_has_nanosleep=yes\n         ;;\n+      mingw*)\n+        ac_has_win32_sleep=yes\n+        ac_has_sched_yield=yes\n+        ;;\n       darwin*)\n         ac_has_nanosleep=yes\n         ac_has_sched_yield=yes\n@@ -1537,6 +1544,9 @@ AC_DEFUN([GLIBCXX_ENABLE_LIBSTDCXX_TIME], [\n   if test x\"$ac_has_nanosleep\" = x\"yes\"; then\n     AC_DEFINE(_GLIBCXX_USE_NANOSLEEP, 1,\n       [ Defined if nanosleep is available. ])\n+  elif test x\"$ac_has_win32_sleep\" = x\"yes\"; then\n+    AC_DEFINE(_GLIBCXX_USE_WIN32_SLEEP, 1,\n+      [Defined if Sleep exists.])\n   else\n       AC_MSG_CHECKING([for sleep])\n       AC_TRY_COMPILE([#include <unistd.h>],\n@@ -1557,20 +1567,7 @@ AC_DEFUN([GLIBCXX_ENABLE_LIBSTDCXX_TIME], [\n       AC_MSG_RESULT($ac_has_usleep)\n   fi\n \n-  if test x\"$ac_has_nanosleep$ac_has_sleep\" = x\"nono\"; then\n-      ac_no_sleep=yes\n-      AC_MSG_CHECKING([for Sleep])\n-      AC_TRY_COMPILE([#include <windows.h>],\n-                     [Sleep(1)],\n-                     [ac_has_win32_sleep=yes],[ac_has_win32_sleep=no])\n-      if test x\"$ac_has_win32_sleep\" = x\"yes\"; then\n-        AC_DEFINE(HAVE_WIN32_SLEEP,1, [Defined if Sleep exists.])\n-\tac_no_sleep=no\n-      fi\n-      AC_MSG_RESULT($ac_has_win32_sleep)\n-  fi\n-\n-  if test x\"$ac_no_sleep\" = x\"yes\"; then\n+  if test x\"$ac_has_nanosleep$ac_has_win32_sleep$ac_has_sleep\" = x\"nonono\"; then\n     AC_DEFINE(_GLIBCXX_NO_SLEEP,1, [Defined if no way to sleep is available.])\n   fi\n \n@@ -3987,6 +3984,15 @@ AC_DEFUN([GLIBCXX_CHECK_GTHREADS], [\n   case $target_thread_file in\n     posix)\n       CXXFLAGS=\"$CXXFLAGS -DSUPPORTS_WEAK -DGTHREAD_USE_WEAK -D_PTHREADS\"\n+      ;;\n+    win32)\n+      CXXFLAGS=\"$CXXFLAGS -D_WIN32_THREADS\"\n+      # The support of condition variables is disabled by default in\n+      # the Win32 gthreads library, so enable it on explicit request.\n+      if test x$enable_libstdcxx_threads = xyes; then\n+        CXXFLAGS=\"$CXXFLAGS -D_WIN32_WINNT=0x0600\"\n+      fi\n+      ;;\n   esac\n \n   AC_MSG_CHECKING([whether it can be safely assumed that mutex_timedlock is available])\n@@ -3997,6 +4003,9 @@ AC_DEFUN([GLIBCXX_CHECK_GTHREADS], [\n       #if (defined(_PTHREADS) \\\n \t  && (!defined(_POSIX_TIMEOUTS) || _POSIX_TIMEOUTS <= 0))\n       #error\n+      // In case of Win32 threads there is no support.\n+      #elif defined(_WIN32_THREADS)\n+      #error\n       #endif\n     ], [ac_gthread_use_mutex_timedlock=1], [ac_gthread_use_mutex_timedlock=0])\n \n@@ -4043,6 +4052,11 @@ AC_DEFUN([GLIBCXX_CHECK_GTHREADS], [\n              [],\n              [#include \"gthr.h\"])\n     fi\n+\n+    # See above for the rationale.\n+    if test $target_thread_file = win32; then\n+      CPPFLAGS=\"$CPPFLAGS -D_WIN32_WINNT=0x0600\"\n+    fi\n   fi\n \n   AC_CHECK_HEADER(semaphore.h, ["}, {"sha": "02119b9459e3dfead52b88f479e10e7cec57b108", "filename": "libstdc++-v3/config.h.in", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9149a5b7e0a66b7b94d5b7db3194a975d18dea2f/libstdc%2B%2B-v3%2Fconfig.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9149a5b7e0a66b7b94d5b7db3194a975d18dea2f/libstdc%2B%2B-v3%2Fconfig.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig.h.in?ref=9149a5b7e0a66b7b94d5b7db3194a975d18dea2f", "patch": "@@ -525,9 +525,6 @@\n /* Define to 1 if you have the <wctype.h> header file. */\n #undef HAVE_WCTYPE_H\n \n-/* Defined if Sleep exists. */\n-#undef HAVE_WIN32_SLEEP\n-\n /* Define if writev is available in <sys/uio.h>. */\n #undef HAVE_WRITEV\n \n@@ -1028,6 +1025,9 @@\n /* Define if code specialized for wchar_t should be used. */\n #undef _GLIBCXX_USE_WCHAR_T\n \n+/* Defined if Sleep exists. */\n+#undef _GLIBCXX_USE_WIN32_SLEEP\n+\n /* Define to 1 if a verbose library is built, or 0 otherwise. */\n #undef _GLIBCXX_VERBOSE\n "}, {"sha": "ee02ff82e8605fa5ff4767b3b593c7e4fb2edd07", "filename": "libstdc++-v3/config/os/mingw32-w64/os_defines.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9149a5b7e0a66b7b94d5b7db3194a975d18dea2f/libstdc%2B%2B-v3%2Fconfig%2Fos%2Fmingw32-w64%2Fos_defines.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9149a5b7e0a66b7b94d5b7db3194a975d18dea2f/libstdc%2B%2B-v3%2Fconfig%2Fos%2Fmingw32-w64%2Fos_defines.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Fos%2Fmingw32-w64%2Fos_defines.h?ref=9149a5b7e0a66b7b94d5b7db3194a975d18dea2f", "patch": "@@ -85,6 +85,9 @@\n // their dtors are called\n #define _GLIBCXX_THREAD_ATEXIT_WIN32 1\n \n+// Enable use of GetSystemInfo to implement get_nprocs\n+#define _GLIBCXX_USE_GET_NPROCS_WIN32 1\n+\n // See libstdc++/59807\n #define _GTHREAD_USE_MUTEX_INIT_FUNC 1\n "}, {"sha": "69f4bc0abea413462b06ce332af6f7b297da54b5", "filename": "libstdc++-v3/config/os/mingw32/os_defines.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9149a5b7e0a66b7b94d5b7db3194a975d18dea2f/libstdc%2B%2B-v3%2Fconfig%2Fos%2Fmingw32%2Fos_defines.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9149a5b7e0a66b7b94d5b7db3194a975d18dea2f/libstdc%2B%2B-v3%2Fconfig%2Fos%2Fmingw32%2Fos_defines.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Fos%2Fmingw32%2Fos_defines.h?ref=9149a5b7e0a66b7b94d5b7db3194a975d18dea2f", "patch": "@@ -75,6 +75,9 @@\n #define _GLIBCXX_LLP64 1\n #endif\n \n+// Enable use of GetSystemInfo to implement get_nprocs\n+#define _GLIBCXX_USE_GET_NPROCS_WIN32 1\n+\n // See libstdc++/59807\n #define _GTHREAD_USE_MUTEX_INIT_FUNC 1\n "}, {"sha": "bdcd80607975fbdbd9aacf562f86b4c4571992a0", "filename": "libstdc++-v3/configure", "status": "modified", "additions": 28, "deletions": 32, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9149a5b7e0a66b7b94d5b7db3194a975d18dea2f/libstdc%2B%2B-v3%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9149a5b7e0a66b7b94d5b7db3194a975d18dea2f/libstdc%2B%2B-v3%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfigure?ref=9149a5b7e0a66b7b94d5b7db3194a975d18dea2f", "patch": "@@ -20523,6 +20523,10 @@ ac_compiler_gnu=$ac_cv_cxx_compiler_gnu\n       cygwin*)\n         ac_has_nanosleep=yes\n         ;;\n+      mingw*)\n+        ac_has_win32_sleep=yes\n+        ac_has_sched_yield=yes\n+        ;;\n       darwin*)\n         ac_has_nanosleep=yes\n         ac_has_sched_yield=yes\n@@ -21056,6 +21060,10 @@ $as_echo \"#define _GLIBCXX_USE_SCHED_YIELD 1\" >>confdefs.h\n \n $as_echo \"#define _GLIBCXX_USE_NANOSLEEP 1\" >>confdefs.h\n \n+  elif test x\"$ac_has_win32_sleep\" = x\"yes\"; then\n+\n+$as_echo \"#define _GLIBCXX_USE_WIN32_SLEEP 1\" >>confdefs.h\n+\n   else\n       { $as_echo \"$as_me:${as_lineno-$LINENO}: checking for sleep\" >&5\n $as_echo_n \"checking for sleep... \" >&6; }\n@@ -21112,38 +21120,7 @@ $as_echo \"#define HAVE_USLEEP 1\" >>confdefs.h\n $as_echo \"$ac_has_usleep\" >&6; }\n   fi\n \n-  if test x\"$ac_has_nanosleep$ac_has_sleep\" = x\"nono\"; then\n-      ac_no_sleep=yes\n-      { $as_echo \"$as_me:${as_lineno-$LINENO}: checking for Sleep\" >&5\n-$as_echo_n \"checking for Sleep... \" >&6; }\n-      cat confdefs.h - <<_ACEOF >conftest.$ac_ext\n-/* end confdefs.h.  */\n-#include <windows.h>\n-int\n-main ()\n-{\n-Sleep(1)\n-  ;\n-  return 0;\n-}\n-_ACEOF\n-if ac_fn_cxx_try_compile \"$LINENO\"; then :\n-  ac_has_win32_sleep=yes\n-else\n-  ac_has_win32_sleep=no\n-fi\n-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext\n-      if test x\"$ac_has_win32_sleep\" = x\"yes\"; then\n-\n-$as_echo \"#define HAVE_WIN32_SLEEP 1\" >>confdefs.h\n-\n-\tac_no_sleep=no\n-      fi\n-      { $as_echo \"$as_me:${as_lineno-$LINENO}: result: $ac_has_win32_sleep\" >&5\n-$as_echo \"$ac_has_win32_sleep\" >&6; }\n-  fi\n-\n-  if test x\"$ac_no_sleep\" = x\"yes\"; then\n+  if test x\"$ac_has_nanosleep$ac_has_win32_sleep$ac_has_sleep\" = x\"nonono\"; then\n \n $as_echo \"#define _GLIBCXX_NO_SLEEP 1\" >>confdefs.h\n \n@@ -69715,6 +69692,15 @@ ac_compiler_gnu=$ac_cv_cxx_compiler_gnu\n   case $target_thread_file in\n     posix)\n       CXXFLAGS=\"$CXXFLAGS -DSUPPORTS_WEAK -DGTHREAD_USE_WEAK -D_PTHREADS\"\n+      ;;\n+    win32)\n+      CXXFLAGS=\"$CXXFLAGS -D_WIN32_THREADS\"\n+      # The support of condition variables is disabled by default in\n+      # the Win32 gthreads library, so enable it on explicit request.\n+      if test x$enable_libstdcxx_threads = xyes; then\n+        CXXFLAGS=\"$CXXFLAGS -D_WIN32_WINNT=0x0600\"\n+      fi\n+      ;;\n   esac\n \n   { $as_echo \"$as_me:${as_lineno-$LINENO}: checking whether it can be safely assumed that mutex_timedlock is available\" >&5\n@@ -69731,6 +69717,9 @@ main ()\n       #if (defined(_PTHREADS) \\\n \t  && (!defined(_POSIX_TIMEOUTS) || _POSIX_TIMEOUTS <= 0))\n       #error\n+      // In case of Win32 threads there is no support.\n+      #elif defined(_WIN32_THREADS)\n+      #error\n       #endif\n \n   ;\n@@ -69827,6 +69816,11 @@ $as_echo \"#define _GLIBCXX_USE_PTHREAD_RWLOCK_T 1\" >>confdefs.h\n fi\n \n     fi\n+\n+    # See above for the rationale.\n+    if test $target_thread_file = win32; then\n+      CPPFLAGS=\"$CPPFLAGS -D_WIN32_WINNT=0x0600\"\n+    fi\n   fi\n \n   ac_fn_cxx_check_header_mongrel \"$LINENO\" \"semaphore.h\" \"ac_cv_header_semaphore_h\" \"$ac_includes_default\"\n@@ -72603,6 +72597,8 @@ $as_echo \"$gxx_include_dir\" >&6; }\n \n \n \n+\n+\n   # Optimization flags that are probably a good idea for thrill-seekers. Just\n   # uncomment the lines below and make, everything else is ready to go...\n   # Alternatively OPTIMIZE_CXXFLAGS can be set in configure.host."}, {"sha": "a803897909078966e891073a67143bf76c684cf6", "filename": "libstdc++-v3/src/c++11/thread.cc", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9149a5b7e0a66b7b94d5b7db3194a975d18dea2f/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B11%2Fthread.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9149a5b7e0a66b7b94d5b7db3194a975d18dea2f/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B11%2Fthread.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B11%2Fthread.cc?ref=9149a5b7e0a66b7b94d5b7db3194a975d18dea2f", "patch": "@@ -34,7 +34,7 @@\n #ifndef _GLIBCXX_USE_NANOSLEEP\n # ifdef _GLIBCXX_HAVE_SLEEP\n #  include <unistd.h>\n-# elif defined(_GLIBCXX_HAVE_WIN32_SLEEP)\n+# elif defined(_GLIBCXX_USE_WIN32_SLEEP)\n #  include <windows.h>\n # elif defined _GLIBCXX_NO_SLEEP && defined _GLIBCXX_HAS_GTHREADS\n // We expect to be able to sleep for targets that support multiple threads:\n@@ -62,6 +62,16 @@ static inline int get_nprocs()\n  return 0;\n }\n # define _GLIBCXX_NPROCS get_nprocs()\n+#elif defined(_GLIBCXX_USE_GET_NPROCS_WIN32)\n+#define WIN32_LEAN_AND_MEAN\n+# include <windows.h>\n+static inline int get_nprocs()\n+{\n+  SYSTEM_INFO sysinfo;\n+  GetSystemInfo (&sysinfo);\n+  return (int)sysinfo.dwNumberOfProcessors;\n+}\n+# define _GLIBCXX_NPROCS get_nprocs()\n #elif defined(_GLIBCXX_USE_SC_NPROCESSORS_ONLN)\n # include <unistd.h>\n # define _GLIBCXX_NPROCS sysconf(_SC_NPROCESSORS_ONLN)\n@@ -254,7 +264,7 @@ namespace this_thread\n \t__s = chrono::duration_cast<chrono::seconds>(target - now);\n \t__ns = chrono::duration_cast<chrono::nanoseconds>(target - (now + __s));\n     }\n-#elif defined(_GLIBCXX_HAVE_WIN32_SLEEP)\n+#elif defined(_GLIBCXX_USE_WIN32_SLEEP)\n     unsigned long ms = __ns.count() / 1000000;\n     if (__ns.count() > 0 && ms == 0)\n       ms = 1;"}, {"sha": "ebf7147cdc03cf71bf2f6d98697b534ef96ebf79", "filename": "libstdc++-v3/testsuite/19_diagnostics/headers/system_error/errc_std_c++0x.cc", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9149a5b7e0a66b7b94d5b7db3194a975d18dea2f/libstdc%2B%2B-v3%2Ftestsuite%2F19_diagnostics%2Fheaders%2Fsystem_error%2Ferrc_std_c%2B%2B0x.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9149a5b7e0a66b7b94d5b7db3194a975d18dea2f/libstdc%2B%2B-v3%2Ftestsuite%2F19_diagnostics%2Fheaders%2Fsystem_error%2Ferrc_std_c%2B%2B0x.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F19_diagnostics%2Fheaders%2Fsystem_error%2Ferrc_std_c%2B%2B0x.cc?ref=9149a5b7e0a66b7b94d5b7db3194a975d18dea2f", "patch": "@@ -70,7 +70,10 @@ void test01()\n   TEST_ERRC(network_reset);\n   TEST_ERRC(network_unreachable);\n   TEST_ERRC(no_buffer_space);\n+\n+#ifdef ECHILD\n   TEST_ERRC(no_child_process);\n+#endif\n \n #ifdef ENOLINK\n   TEST_ERRC(no_link);\n@@ -86,7 +89,10 @@ void test01()\n   TEST_ERRC(no_message);\n #endif\n   TEST_ERRC(no_protocol_option);\n+\n+#ifdef ENOSPC\n   TEST_ERRC(no_space_on_device);\n+#endif\n \n #ifdef ENOSR\n   TEST_ERRC(no_stream_resources);\n@@ -105,16 +111,26 @@ void test01()\n \n   TEST_ERRC(not_connected);\n   TEST_ERRC(not_enough_memory);\n+\n+#ifdef ENOTSUP\n   TEST_ERRC(not_supported);\n+#endif\n \n #ifdef ECANCELED\n   TEST_ERRC(operation_canceled);\n #endif\n \n   TEST_ERRC(operation_in_progress);\n+\n+#ifdef EPERM\n   TEST_ERRC(operation_not_permitted);\n+#endif\n+\n   TEST_ERRC(operation_not_supported);\n+\n+#ifdef EWOULDBLOCK\n   TEST_ERRC(operation_would_block);\n+#endif\n \n #ifdef EOWNERDEAD\n   TEST_ERRC(owner_dead);\n@@ -144,7 +160,10 @@ void test01()\n   TEST_ERRC(text_file_busy);\n #endif\n \n+#ifdef ETIMEDOUT\n   TEST_ERRC(timed_out);\n+#endif\n+\n   TEST_ERRC(too_many_files_open_in_system);\n   TEST_ERRC(too_many_files_open);\n   TEST_ERRC(too_many_links);"}, {"sha": "0a484e6637998ab436091e3af0a55c0cecaac1fb", "filename": "libstdc++-v3/testsuite/lib/libstdc++.exp", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9149a5b7e0a66b7b94d5b7db3194a975d18dea2f/libstdc%2B%2B-v3%2Ftestsuite%2Flib%2Flibstdc%2B%2B.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9149a5b7e0a66b7b94d5b7db3194a975d18dea2f/libstdc%2B%2B-v3%2Ftestsuite%2Flib%2Flibstdc%2B%2B.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Flib%2Flibstdc%2B%2B.exp?ref=9149a5b7e0a66b7b94d5b7db3194a975d18dea2f", "patch": "@@ -510,6 +510,15 @@ proc v3_target_compile { source dest type options } {\n \t}\n     }\n \n+    # Small adjustment for MinGW hosts.\n+    if { $dest == \"/dev/null\" && [ishost \"*-*-mingw*\"] } {\n+\tif { $type == \"executable\" } {\n+\t    set dest \"x.exe\"\n+\t} else {\n+\t    set dest \"nul\"\n+\t}\n+    }\n+\n     lappend options \"compiler=$cxx_final\"\n     lappend options \"timeout=[timeout_value]\"\n \n@@ -1147,7 +1156,9 @@ proc check_effective_target_gthreads_timed { } {\n # Return 1 if either nanosleep or sleep is available, 0 otherwise.\n proc check_v3_target_sleep { } {\n     return [check_v3_target_prop_cached et_sleep {\n-\tset cond \"defined _GLIBCXX_USE_NANOSLEEP || defined _GLIBCXX_HAVE_SLEEP\"\n+\tset cond \"defined _GLIBCXX_USE_NANOSLEEP\"\n+\tset cond \"$cond || defined _GLIBCXX_USE_WIN32_SLEEP\"\n+\tset cond \"$cond || defined _GLIBCXX_HAVE_SLEEP\"\n \treturn [v3_check_preprocessor_condition sleep $cond]\n     }]\n }\n@@ -1191,6 +1202,7 @@ proc check_v3_target_binary_io { } {\n proc check_v3_target_nprocs { } {\n     return [check_v3_target_prop_cached et_nprocs {\n \tset cond \"defined _GLIBCXX_USE_GET_NPROCS\"\n+\tset cond \"$cond || defined _GLIBCXX_USE_GET_NPROCS_WIN32\"\n \tset cond \"$cond || defined _GLIBCXX_USE_PTHREADS_NUM_PROCESSORS_NP\"\n \tset cond \"$cond || defined _GLIBCXX_USE_SYSCTL_HW_NCPU\"\n \tset cond \"$cond || defined _GLIBCXX_USE_SC_NPROCESSORS_ONLN\""}]}