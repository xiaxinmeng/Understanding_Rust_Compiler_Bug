{"sha": "b54819879e0518b3f1acc5242f9c1d86dd1b9e3c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjU0ODE5ODc5ZTA1MThiM2YxYWNjNTI0MmY5YzFkODZkZDFiOWUzYw==", "commit": {"author": {"name": "Bin Cheng", "email": "bin.cheng@arm.com", "date": "2016-11-23T12:44:08Z"}, "committer": {"name": "Bin Cheng", "email": "amker@gcc.gnu.org", "date": "2016-11-23T12:44:08Z"}, "message": "fold-const.c (fold_cond_expr_with_comparison): Move simplification for A cmp C1 ? A : C2 to below, also simplify remaining code.\n\n\t* fold-const.c (fold_cond_expr_with_comparison): Move simplification\n\tfor A cmp C1 ? A : C2 to below, also simplify remaining code.\n\t* match.pd: Move and extend simplification from above to here:\n\t(cond (cmp (convert1? x) c1) (convert2? x) c2) -> (minmax (x c)).\n\t* tree-if-conv.c (ifcvt_follow_ssa_use_edges): New func.\n\t(predicate_scalar_phi): Call fold_stmt using the new valueize func.\n\n\tgcc/testsuite\n\t* gcc.dg/fold-cond_expr-1.c: New test.\n\t* gcc.dg/fold-condcmpconv-1.c: New test.\n\t* gcc.dg/fold-condcmpconv-2.c: New test.\n\nFrom-SVN: r242750", "tree": {"sha": "db5d291195258e1f26c23a15aa79a6d86dbc1de4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/db5d291195258e1f26c23a15aa79a6d86dbc1de4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b54819879e0518b3f1acc5242f9c1d86dd1b9e3c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b54819879e0518b3f1acc5242f9c1d86dd1b9e3c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b54819879e0518b3f1acc5242f9c1d86dd1b9e3c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b54819879e0518b3f1acc5242f9c1d86dd1b9e3c/comments", "author": null, "committer": null, "parents": [{"sha": "b8d89b03db5f212919e4571671ebb4f5f8b1e19d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b8d89b03db5f212919e4571671ebb4f5f8b1e19d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b8d89b03db5f212919e4571671ebb4f5f8b1e19d"}], "stats": {"total": 266, "additions": 176, "deletions": 90}, "files": [{"sha": "a330d7a51a4d4761a5eeae87a98d506be5387e03", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b54819879e0518b3f1acc5242f9c1d86dd1b9e3c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b54819879e0518b3f1acc5242f9c1d86dd1b9e3c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b54819879e0518b3f1acc5242f9c1d86dd1b9e3c", "patch": "@@ -1,3 +1,12 @@\n+2016-11-23  Bin Cheng  <bin.cheng@arm.com>\n+\n+\t* fold-const.c (fold_cond_expr_with_comparison): Move simplification\n+\tfor A cmp C1 ? A : C2 to below, also simplify remaining code.\n+\t* match.pd: Move and extend simplification from above to here:\n+\t(cond (cmp (convert1? x) c1) (convert2? x) c2) -> (minmax (x c)).\n+\t* tree-if-conv.c (ifcvt_follow_ssa_use_edges): New func.\n+\t(predicate_scalar_phi): Call fold_stmt using the new valueize func.\n+\n 2016-11-23  Martin Liska  <mliska@suse.cz>\n             Martin Jambor  <mjambor@suse.cz>\n "}, {"sha": "cbfbc24222cf5ae844557d45becb2e98357a7753", "filename": "gcc/fold-const.c", "status": "modified", "additions": 9, "deletions": 86, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b54819879e0518b3f1acc5242f9c1d86dd1b9e3c/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b54819879e0518b3f1acc5242f9c1d86dd1b9e3c/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=b54819879e0518b3f1acc5242f9c1d86dd1b9e3c", "patch": "@@ -5210,95 +5210,18 @@ fold_cond_expr_with_comparison (location_t loc, tree type,\n \t}\n     }\n \n-  /* If this is A op C1 ? A : C2 with C1 and C2 constant integers,\n-     we might still be able to simplify this.  For example,\n-     if C1 is one less or one more than C2, this might have started\n-     out as a MIN or MAX and been transformed by this function.\n-     Only good for INTEGER_TYPEs, because we need TYPE_MAX_VALUE.  */\n+  /* If this is A == C1 ? A : C2 with C1 and C2 constant integers,\n+     we simplify it into A == C1 ? C1 : C2.  */\n \n-  if (INTEGRAL_TYPE_P (type)\n+  if (comp_code == EQ_EXPR\n+      && INTEGRAL_TYPE_P (type)\n       && TREE_CODE (arg01) == INTEGER_CST\n+      && TREE_CODE (arg1) != INTEGER_CST\n       && TREE_CODE (arg2) == INTEGER_CST)\n-    switch (comp_code)\n-      {\n-      case EQ_EXPR:\n-\tif (TREE_CODE (arg1) == INTEGER_CST)\n-\t  break;\n-\t/* We can replace A with C1 in this case.  */\n-\targ1 = fold_convert_loc (loc, type, arg01);\n-\treturn fold_build3_loc (loc, COND_EXPR, type, arg0, arg1, arg2);\n-\n-      case LT_EXPR:\n-\t/* If C1 is C2 + 1, this is min(A, C2), but use ARG00's type for\n-\t   MIN_EXPR, to preserve the signedness of the comparison.  */\n-\tif (! operand_equal_p (arg2, TYPE_MAX_VALUE (type),\n-\t\t\t       OEP_ONLY_CONST)\n-\t    && operand_equal_p (arg01,\n-\t\t\t\tconst_binop (PLUS_EXPR, arg2,\n-\t\t\t\t\t     build_int_cst (type, 1)),\n-\t\t\t\tOEP_ONLY_CONST))\n-\t  {\n-\t    tem = fold_build2_loc (loc, MIN_EXPR, TREE_TYPE (arg00), arg00,\n-\t\t\t\t   fold_convert_loc (loc, TREE_TYPE (arg00),\n-\t\t\t\t\t\t     arg2));\n-\t    return fold_convert_loc (loc, type, tem);\n-\t  }\n-\tbreak;\n-\n-      case LE_EXPR:\n-\t/* If C1 is C2 - 1, this is min(A, C2), with the same care\n-\t   as above.  */\n-\tif (! operand_equal_p (arg2, TYPE_MIN_VALUE (type),\n-\t\t\t       OEP_ONLY_CONST)\n-\t    && operand_equal_p (arg01,\n-\t\t\t\tconst_binop (MINUS_EXPR, arg2,\n-\t\t\t\t\t     build_int_cst (type, 1)),\n-\t\t\t\tOEP_ONLY_CONST))\n-\t  {\n-\t    tem = fold_build2_loc (loc, MIN_EXPR, TREE_TYPE (arg00), arg00,\n-\t\t\t\t   fold_convert_loc (loc, TREE_TYPE (arg00),\n-\t\t\t\t\t\t     arg2));\n-\t    return fold_convert_loc (loc, type, tem);\n-\t  }\n-\tbreak;\n-\n-      case GT_EXPR:\n-\t/* If C1 is C2 - 1, this is max(A, C2), but use ARG00's type for\n-\t   MAX_EXPR, to preserve the signedness of the comparison.  */\n-\tif (! operand_equal_p (arg2, TYPE_MIN_VALUE (type),\n-\t\t\t       OEP_ONLY_CONST)\n-\t    && operand_equal_p (arg01,\n-\t\t\t\tconst_binop (MINUS_EXPR, arg2,\n-\t\t\t\t\t     build_int_cst (type, 1)),\n-\t\t\t\tOEP_ONLY_CONST))\n-\t  {\n-\t    tem = fold_build2_loc (loc, MAX_EXPR, TREE_TYPE (arg00), arg00,\n-\t\t\t\t   fold_convert_loc (loc, TREE_TYPE (arg00),\n-\t\t\t\t\t\t     arg2));\n-\t    return fold_convert_loc (loc, type, tem);\n-\t  }\n-\tbreak;\n-\n-      case GE_EXPR:\n-\t/* If C1 is C2 + 1, this is max(A, C2), with the same care as above.  */\n-\tif (! operand_equal_p (arg2, TYPE_MAX_VALUE (type),\n-\t\t\t       OEP_ONLY_CONST)\n-\t    && operand_equal_p (arg01,\n-\t\t\t\tconst_binop (PLUS_EXPR, arg2,\n-\t\t\t\t\t     build_int_cst (type, 1)),\n-\t\t\t\tOEP_ONLY_CONST))\n-\t  {\n-\t    tem = fold_build2_loc (loc, MAX_EXPR, TREE_TYPE (arg00), arg00,\n-\t\t\t\t   fold_convert_loc (loc, TREE_TYPE (arg00),\n-\t\t\t\t\t\t     arg2));\n-\t    return fold_convert_loc (loc, type, tem);\n-\t  }\n-\tbreak;\n-      case NE_EXPR:\n-\tbreak;\n-      default:\n-\tgcc_unreachable ();\n-      }\n+    {\n+      arg1 = fold_convert_loc (loc, type, arg01);\n+      return fold_build3_loc (loc, COND_EXPR, type, arg0, arg1, arg2);\n+    }\n \n   return NULL_TREE;\n }"}, {"sha": "2599d27c5281522546689334890e1963a449eae6", "filename": "gcc/match.pd", "status": "modified", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b54819879e0518b3f1acc5242f9c1d86dd1b9e3c/gcc%2Fmatch.pd", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b54819879e0518b3f1acc5242f9c1d86dd1b9e3c/gcc%2Fmatch.pd", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmatch.pd?ref=b54819879e0518b3f1acc5242f9c1d86dd1b9e3c", "patch": "@@ -1953,6 +1953,67 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n   (if (integer_zerop (@0))\n    @2)))\n \n+/* Simplification moved from fold_cond_expr_with_comparison.  It may also\n+   be extended.  */\n+/* (cond (cmp (convert1? x) c1) (convert2? x) c2) -> (minmax (x c)) if:\n+     1) Conversions are type widening from smaller type.\n+     2) Const c1 equals to c2 after canonicalizing comparison.\n+     3) Comparison has tree code LT, LE, GT or GE.\n+   This specific pattern is needed when (cmp (convert x) c) may not\n+   be simplified by comparison patterns because of multiple uses of\n+   x.  It also makes sense here because simplifying across multiple\n+   referred var is always benefitial for complicated cases.  */\n+(for cmp (lt le gt ge)\n+ (simplify\n+  (cond (cmp@0 (convert1? @1) INTEGER_CST@3) (convert2? @1) INTEGER_CST@2)\n+  (with\n+   {\n+     tree from_type = TREE_TYPE (@1);\n+     tree c1_type = TREE_TYPE (@3), c2_type = TREE_TYPE (@2);\n+     enum tree_code code = TREE_CODE (@0), cmp_code = TREE_CODE (@0);\n+\n+     if (int_fits_type_p (@2, from_type)\n+\t && (types_match (c1_type, from_type)\n+\t     || (TYPE_PRECISION (c1_type) > TYPE_PRECISION (from_type)\n+\t\t && (TYPE_UNSIGNED (from_type)\n+\t\t     || TYPE_SIGN (c1_type) == TYPE_SIGN (from_type))))\n+\t && (types_match (c2_type, from_type)\n+\t     || (TYPE_PRECISION (c2_type) > TYPE_PRECISION (from_type)\n+\t\t && (TYPE_UNSIGNED (from_type)\n+\t\t     || TYPE_SIGN (c2_type) == TYPE_SIGN (from_type)))))\n+       {\n+\t if (wi::to_widest (@3) == (wi::to_widest (@2) - 1))\n+\t   {\n+\t     /* X <= Y - 1 equals to X < Y.  */\n+\t     if (cmp_code == LE_EXPR)\n+\t       code = LT_EXPR;\n+\t     /* X > Y - 1 equals to X >= Y.  */\n+\t     if (cmp_code == GT_EXPR)\n+\t       code = GE_EXPR;\n+\t   }\n+\t if (wi::to_widest (@3) == (wi::to_widest (@2) + 1))\n+\t   {\n+\t     /* X < Y + 1 equals to X <= Y.  */\n+\t     if (cmp_code == LT_EXPR)\n+\t       code = LE_EXPR;\n+\t     /* X >= Y + 1 equals to X > Y.  */\n+\t     if (cmp_code == GE_EXPR)\n+\t       code = GT_EXPR;\n+\t   }\n+\t if (code != cmp_code || wi::to_widest (@2) == wi::to_widest (@3))\n+\t   {\n+\t     if (cmp_code == LT_EXPR || cmp_code == LE_EXPR)\n+\t       code = MIN_EXPR;\n+\t     if (cmp_code == GT_EXPR || cmp_code == GE_EXPR)\n+\t       code = MAX_EXPR;\n+\t   }\n+       }\n+   }\n+   (if (code == MAX_EXPR)\n+    (convert (max @1 (convert:from_type @2)))\n+    (if (code == MIN_EXPR)\n+     (convert (min @1 (convert:from_type @2))))))))\n+\n (for cnd (cond vec_cond)\n  /* A ? B : (A ? X : C) -> A ? B : C.  */\n  (simplify"}, {"sha": "604c5918c3bf753003ec9574165adcdfbf9020fe", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b54819879e0518b3f1acc5242f9c1d86dd1b9e3c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b54819879e0518b3f1acc5242f9c1d86dd1b9e3c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b54819879e0518b3f1acc5242f9c1d86dd1b9e3c", "patch": "@@ -1,3 +1,9 @@\n+2016-11-23  Bin Cheng  <bin.cheng@arm.com>\n+\n+\t* gcc.dg/fold-cond_expr-1.c: New test.\n+\t* gcc.dg/fold-condcmpconv-1.c: New test.\n+\t* gcc.dg/fold-condcmpconv-2.c: New test.\n+\n 2016-11-23  Richard Biener  <rguenther@suse.de>\n \n \tPR middle-end/71762"}, {"sha": "68ec75480ada80e2314db4e2239a67c3e6798634", "filename": "gcc/testsuite/gcc.dg/fold-cond_expr-1.c", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b54819879e0518b3f1acc5242f9c1d86dd1b9e3c/gcc%2Ftestsuite%2Fgcc.dg%2Ffold-cond_expr-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b54819879e0518b3f1acc5242f9c1d86dd1b9e3c/gcc%2Ftestsuite%2Fgcc.dg%2Ffold-cond_expr-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ffold-cond_expr-1.c?ref=b54819879e0518b3f1acc5242f9c1d86dd1b9e3c", "patch": "@@ -0,0 +1,47 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-optimized\" } */\n+\n+int\n+min1 (signed char op1, signed char op2)\n+{\n+  return (op1 < 25) ? (int)op1 : 24;\n+}\n+int\n+min2 (signed char op1, signed char op2)\n+{\n+  return (op1 <= 24) ? (int)op1 : 25;\n+}\n+int\n+min3 (unsigned char op1, unsigned char op2)\n+{\n+  return (op1 < 25) ? (unsigned int)op1 : 24;\n+}\n+int\n+min4 (unsigned char op1, unsigned char op2)\n+{\n+  return (op1 <= 24) ? (unsigned int)op1 : 25;\n+}\n+int\n+max1 (signed char op1, signed char op2)\n+{\n+  return (op1 > 24) ? (int)op1 : 25;\n+}\n+int\n+max2 (signed char op1, signed char op2)\n+{\n+  return (op1 >= 25) ? (int)op1 : 24;\n+}\n+int\n+max3 (unsigned char op1, unsigned char op2)\n+{\n+  return (op1 > 24) ? (unsigned int)op1 : 25;\n+}\n+int\n+max4 (unsigned char op1, unsigned char op2)\n+{\n+  return (op1 >= 25) ? (unsigned int)op1 : 24;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"MIN_EXPR\" 4 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"MAX_EXPR\" 4 \"optimized\" } } */\n+"}, {"sha": "321294f4b9636f992fb0593c13c8bcadb69e1c61", "filename": "gcc/testsuite/gcc.dg/fold-condcmpconv-1.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b54819879e0518b3f1acc5242f9c1d86dd1b9e3c/gcc%2Ftestsuite%2Fgcc.dg%2Ffold-condcmpconv-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b54819879e0518b3f1acc5242f9c1d86dd1b9e3c/gcc%2Ftestsuite%2Fgcc.dg%2Ffold-condcmpconv-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ffold-condcmpconv-1.c?ref=b54819879e0518b3f1acc5242f9c1d86dd1b9e3c", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -fdump-tree-ifcvt\" } */\n+\n+int foo (unsigned short a[], unsigned int x)\n+{\n+  unsigned int i;\n+  for (i = 0; i < 1000; i++)\n+    {\n+      x = a[i];\n+      a[i] = (unsigned short)(x >= 255 ? 255 : x);\n+    }  return x;\n+}\n+\n+/* { dg-final { scan-tree-dump \" = MIN_EXPR <\" \"ifcvt\" } } */"}, {"sha": "5d3ef4a1e604df6790ff1d39a37cf9eb70c2df4e", "filename": "gcc/testsuite/gcc.dg/fold-condcmpconv-2.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b54819879e0518b3f1acc5242f9c1d86dd1b9e3c/gcc%2Ftestsuite%2Fgcc.dg%2Ffold-condcmpconv-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b54819879e0518b3f1acc5242f9c1d86dd1b9e3c/gcc%2Ftestsuite%2Fgcc.dg%2Ffold-condcmpconv-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ffold-condcmpconv-2.c?ref=b54819879e0518b3f1acc5242f9c1d86dd1b9e3c", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -fdump-tree-ifcvt\" } */\n+\n+int foo (short a[], int x)\n+{\n+  unsigned int i;\n+  for (i = 0; i < 1000; i++)\n+    {\n+      x = a[i];\n+      a[i] = (short)(x <= 0 ? 0 : x);\n+    }  return x;\n+}\n+\n+\n+/* { dg-final { scan-tree-dump \" = MAX_EXPR <\" \"ifcvt\" } } */"}, {"sha": "e66d383c55b4694c635f67da21630aa9d2f64cf4", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr66726.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b54819879e0518b3f1acc5242f9c1d86dd1b9e3c/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr66726.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b54819879e0518b3f1acc5242f9c1d86dd1b9e3c/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr66726.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr66726.c?ref=b54819879e0518b3f1acc5242f9c1d86dd1b9e3c", "patch": "@@ -1,6 +1,5 @@\n-\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fdump-tree-phiopt1-details\" } */\n+/* { dg-options \"-O2 -fdump-tree-gimple\" } */\n \n extern unsigned short mode_size[];\n \n@@ -10,6 +9,8 @@ oof (int mode)\n   return (64 < mode_size[mode] ? 64 : mode_size[mode]);\n }\n \n-/* { dg-final { scan-tree-dump-times \"factor conversion out\" 1 \"phiopt1\" } } */\n-/* { dg-final { scan-tree-dump-times \"MIN_EXPR\" 1 \"phiopt1\" } } */\n+/* With simplifications transforming cond_expr int min/max_expr\n+   supported by match.pd patterns, we can optimize this at early\n+   stage of compilation, rather than relying on phiopt for that.  */\n+/* { dg-final { scan-tree-dump-times \"MIN_EXPR\" 1 \"gimple\" } } */\n "}, {"sha": "5716deb7974c738761ec13fa0b12e603aacb2e51", "filename": "gcc/tree-if-conv.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b54819879e0518b3f1acc5242f9c1d86dd1b9e3c/gcc%2Ftree-if-conv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b54819879e0518b3f1acc5242f9c1d86dd1b9e3c/gcc%2Ftree-if-conv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-if-conv.c?ref=b54819879e0518b3f1acc5242f9c1d86dd1b9e3c", "patch": "@@ -1749,6 +1749,14 @@ gen_phi_arg_condition (gphi *phi, vec<int> *occur,\n   return cond;\n }\n \n+/* Local valueization callback that follows all-use SSA edges.  */\n+\n+static tree\n+ifcvt_follow_ssa_use_edges (tree val)\n+{\n+  return val;\n+}\n+\n /* Replace a scalar PHI node with a COND_EXPR using COND as condition.\n    This routine can handle PHI nodes with more than two arguments.\n \n@@ -1844,6 +1852,8 @@ predicate_scalar_phi (gphi *phi, gimple_stmt_iterator *gsi)\n \t\t\t\t    arg0, arg1);\n       new_stmt = gimple_build_assign (res, rhs);\n       gsi_insert_before (gsi, new_stmt, GSI_SAME_STMT);\n+      gimple_stmt_iterator new_gsi = gsi_for_stmt (new_stmt);\n+      fold_stmt (&new_gsi, ifcvt_follow_ssa_use_edges);\n       update_stmt (new_stmt);\n \n       if (dump_file && (dump_flags & TDF_DETAILS))"}]}