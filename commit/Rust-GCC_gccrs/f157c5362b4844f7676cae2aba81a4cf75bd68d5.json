{"sha": "f157c5362b4844f7676cae2aba81a4cf75bd68d5", "node_id": "C_kwDOANBUbNoAKGYxNTdjNTM2MmI0ODQ0Zjc2NzZjYWUyYWJhODFhNGNmNzViZDY4ZDU", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2021-12-09T20:02:17Z"}, "committer": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2021-12-09T20:02:17Z"}, "message": "Limit inlining functions called once\n\nas dicussed in PR ipa/103454 there are several benchmarks that regresses\nfor -finline-functions-called once. Runtmes:\n - tramp3d with -Ofast. 31%\n - exchange2 with -Ofast 11-21%\n - roms O2 9%-10%\n - tonto 2.5-3.5% with LTO\nBuild times:\n - specfp2006 41% (mostly wrf that builds 71% faster)\n - specint2006 1.5-3%\n - specfp2017 64% (again mostly wrf)\n - specint2017 2.5-3.5%\n\nThis patch adds two params to tweak the behaviour:\n 1) max-inline-functions-called-once-loop-depth limiting the loop depth\n    (this is useful primarily for exchange where the inlined function is in\n     loop depth 9)\n 2) max-inline-functions-called-once-insns\n    We already have large-function-insns/growth parameters, but these are\n    limiting also inlining small functions, so reducing them will regress\n    very large functions that are hot.\n\n    Because inlining functions called once is meant just as a cleanup pass\n    I think it makes sense to have separate limit for it.\ngcc/ChangeLog:\n\n2021-12-09  Jan Hubicka  <hubicka@ucw.cz>\n\n\t* doc/invoke.texi (max-inline-functions-called-once-loop-depth,\n\tmax-inline-functions-called-once-insns): New parameters.\n\t* ipa-inline.c (check_callers): Handle\n\tparam_inline_functions_called_once_loop_depth and\n\tparam_inline_functions_called_once_insns.\n\t(edge_badness): Fix linebreaks.\n\t* params.opt (param=max-inline-functions-called-once-loop-depth,\n\tparam=max-inline-functions-called-once-insn): New params.", "tree": {"sha": "81b783c0485d83f14494ca6afb36da088ef5951e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/81b783c0485d83f14494ca6afb36da088ef5951e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f157c5362b4844f7676cae2aba81a4cf75bd68d5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f157c5362b4844f7676cae2aba81a4cf75bd68d5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f157c5362b4844f7676cae2aba81a4cf75bd68d5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f157c5362b4844f7676cae2aba81a4cf75bd68d5/comments", "author": null, "committer": null, "parents": [{"sha": "243a980437b5e7fca56587bf86667005bdf343a7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/243a980437b5e7fca56587bf86667005bdf343a7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/243a980437b5e7fca56587bf86667005bdf343a7"}], "stats": {"total": 63, "additions": 46, "deletions": 17}, "files": [{"sha": "9b4371b9213ac900c2230e2d0ef0c55ec811a539", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f157c5362b4844f7676cae2aba81a4cf75bd68d5/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f157c5362b4844f7676cae2aba81a4cf75bd68d5/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=f157c5362b4844f7676cae2aba81a4cf75bd68d5", "patch": "@@ -13605,6 +13605,14 @@ The maximum number of backtrack attempts the scheduler should make\n when modulo scheduling a loop.  Larger values can exponentially increase\n compilation time.\n \n+@item max-inline-functions-called-once-loop-depth\n+Maximal loop depth of a call considered by inline heuristics that tries to\n+inline all functions called once.\n+\n+@item max-inline-functions-called-once-insns\n+Maximal estimated size of functions produced while inlining functions called\n+once.\n+\n @item max-inline-insns-single\n Several parameters control the tree inliner used in GCC@.  This number sets the\n maximum number of instructions (counted in GCC's internal representation) in a"}, {"sha": "54cd085a84d36518e3799a34baa50498b4e0d63c", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 30, "deletions": 17, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f157c5362b4844f7676cae2aba81a4cf75bd68d5/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f157c5362b4844f7676cae2aba81a4cf75bd68d5/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=f157c5362b4844f7676cae2aba81a4cf75bd68d5", "patch": "@@ -1091,20 +1091,30 @@ static bool\n check_callers (struct cgraph_node *node, void *has_hot_call)\n {\n   struct cgraph_edge *e;\n-   for (e = node->callers; e; e = e->next_caller)\n-     {\n-       if (!opt_for_fn (e->caller->decl, flag_inline_functions_called_once)\n-\t   || !opt_for_fn (e->caller->decl, optimize))\n-\t return true;\n-       if (!can_inline_edge_p (e, true))\n-         return true;\n-       if (e->recursive_p ())\n-\t return true;\n-       if (!can_inline_edge_by_limits_p (e, true))\n-         return true;\n-       if (!(*(bool *)has_hot_call) && e->maybe_hot_p ())\n-\t *(bool *)has_hot_call = true;\n-     }\n+  for (e = node->callers; e; e = e->next_caller)\n+    {\n+      if (!opt_for_fn (e->caller->decl, flag_inline_functions_called_once)\n+\t  || !opt_for_fn (e->caller->decl, optimize))\n+\treturn true;\n+      if (!can_inline_edge_p (e, true))\n+\treturn true;\n+      if (e->recursive_p ())\n+\treturn true;\n+      if (!can_inline_edge_by_limits_p (e, true))\n+\treturn true;\n+      /* Inlining large functions to large loop depth is often harmful because\n+\t of register pressure it implies.  */\n+      if ((int)ipa_call_summaries->get (e)->loop_depth\n+\t  > param_inline_functions_called_once_loop_depth)\n+\treturn true;\n+      /* Do not produce gigantic functions.  */\n+      if (estimate_size_after_inlining (e->caller->inlined_to ?\n+\t\t\t\t\te->caller->inlined_to : e->caller, e)\n+\t  > param_inline_functions_called_once_insns)\n+\treturn true;\n+      if (!(*(bool *)has_hot_call) && e->maybe_hot_p ())\n+\t*(bool *)has_hot_call = true;\n+    }\n   return false;\n }\n \n@@ -1327,9 +1337,12 @@ edge_badness (struct cgraph_edge *edge, bool dump)\n \t\t   \" %i (compensated)\\n\",\n \t\t   badness.to_double (),\n \t\t   freq.to_double (),\n-\t\t   edge->count.ipa ().initialized_p () ? edge->count.ipa ().to_gcov_type () : -1,\n-\t\t   caller->count.ipa ().initialized_p () ? caller->count.ipa ().to_gcov_type () : -1,\n-\t\t   inlining_speedup (edge, freq, unspec_edge_time, edge_time).to_double (),\n+\t\t   edge->count.ipa ().initialized_p ()\n+\t\t   ? edge->count.ipa ().to_gcov_type () : -1,\n+\t\t   caller->count.ipa ().initialized_p ()\n+\t\t   ? caller->count.ipa ().to_gcov_type () : -1,\n+\t\t   inlining_speedup (edge, freq, unspec_edge_time,\n+\t\t\t\t     edge_time).to_double (),\n \t\t   estimate_growth (callee),\n \t\t   callee_info->growth, overall_growth);\n \t}"}, {"sha": "f1b5757461c3cc33a744e41c90dd174a1cb28089", "filename": "gcc/params.opt", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f157c5362b4844f7676cae2aba81a4cf75bd68d5/gcc%2Fparams.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f157c5362b4844f7676cae2aba81a4cf75bd68d5/gcc%2Fparams.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.opt?ref=f157c5362b4844f7676cae2aba81a4cf75bd68d5", "patch": "@@ -545,6 +545,14 @@ The maximum expansion factor when copying basic blocks.\n Common Joined UInteger Var(param_max_hoist_depth) Init(30) Param Optimization\n Maximum depth of search in the dominator tree for expressions to hoist.\n \n+-param=max-inline-functions-called-once-loop-depth=\n+Common Joined UInteger Var(param_inline_functions_called_once_loop_depth) Init(6) Optimization Param\n+Maximum loop depth of a call which is considered for inlining functions called once\n+\n+-param=max-inline-functions-called-once-insns=\n+Common Joined UInteger Var(param_inline_functions_called_once_insns) Init(4000) Optimization Param\n+Maximum combinaed size of caller and callee wich is inlined if callee is called once.\n+\n -param=max-inline-insns-auto=\n Common Joined UInteger Var(param_max_inline_insns_auto) Init(15) Optimization Param\n The maximum number of instructions when automatically inlining."}]}