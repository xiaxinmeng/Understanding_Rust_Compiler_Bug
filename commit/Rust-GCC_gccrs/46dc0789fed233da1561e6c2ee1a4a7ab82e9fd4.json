{"sha": "46dc0789fed233da1561e6c2ee1a4a7ab82e9fd4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDZkYzA3ODlmZWQyMzNkYTE1NjFlNmMyZWUxYTRhN2FiODJlOWZkNA==", "commit": {"author": {"name": "Mircea Namolaru", "email": "namolaru@il.ibm.com", "date": "2007-08-28T06:52:16Z"}, "committer": {"name": "Revital Eres", "email": "revitale@gcc.gnu.org", "date": "2007-08-28T06:52:16Z"}, "message": "Modulo-scheduling improvements. Patch 2 of 2\n\nCo-Authored-By: Andrey Belevantsev <abel@ispras.ru>\nCo-Authored-By: Revital Eres <eres@il.ibm.com>\nCo-Authored-By: Vladimir Yanovsky <yanov@il.ibm.com>\n\nFrom-SVN: r127848", "tree": {"sha": "bc3b2739b170fd0d12aa9aeb627ced2e462e8b9d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bc3b2739b170fd0d12aa9aeb627ced2e462e8b9d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/46dc0789fed233da1561e6c2ee1a4a7ab82e9fd4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46dc0789fed233da1561e6c2ee1a4a7ab82e9fd4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/46dc0789fed233da1561e6c2ee1a4a7ab82e9fd4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46dc0789fed233da1561e6c2ee1a4a7ab82e9fd4/comments", "author": null, "committer": null, "parents": [{"sha": "7368348cb7d8665e6eb213264d6ca056f2f05219", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7368348cb7d8665e6eb213264d6ca056f2f05219", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7368348cb7d8665e6eb213264d6ca056f2f05219"}], "stats": {"total": 355, "additions": 293, "deletions": 62}, "files": [{"sha": "b440e93660527b1e39dc2d262ac446812e3441f4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46dc0789fed233da1561e6c2ee1a4a7ab82e9fd4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46dc0789fed233da1561e6c2ee1a4a7ab82e9fd4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=46dc0789fed233da1561e6c2ee1a4a7ab82e9fd4", "patch": "@@ -1,3 +1,31 @@\n+2007-08-28  Mircea Namolaru  <namolaru@il.ibm.com>\n+            Vladimir Yanovsky  <yanov@il.ibm.com>\n+            Revital Eres  <eres@il.ibm.com>\n+            Andrey Belevantsev  <abel@ispras.ru>\n+\n+\t* config/spu/spu.md: Recognize doloop pattern when -fmodulo-sched\n+\tis set.\n+\t* modulo-sched.c: Add documentation regarding do-loop.\n+\t(doloop_register_get): Change number of arguments to support\n+\tthe new do-loop pattern and check whether COUNT_REG has no other\n+\toccurences in the loop besides in the control part.\n+\t(duplicate_insns_of_cycles): Do not duplicate the insn which\n+\tchanges count_reg as it is already adjusted.\n+\t(generate_prolog_epilog): New argument to support the new\n+\tdo-loop pattern.  Change the subtract instruction to use\n+\texpand_simple_binop.  Call duplicate_insns_of_cycles with new\n+\targument.\n+\t(sms_schedule): Call doloop_register_get and\n+\tgenerate_prolog_epilog with new argument.  Do not handle loops\n+\twith single sets insns with subreg in their lhs.\n+\t* loop-doloop.c (doloop_optimize): Support for another do-loop\n+\tpattern.\n+\t(doloop_condition_get): Gets an instruction instead of a pattern\n+\tand change the return condition when the do-loop pattern is\n+\tnot parallel.\n+\t* ddg.c (create_ddg_dep_from_intra_loop_link): Handle only reg\n+\tdeps when considering to not create edges.\n+\n 2007-08-27  Alexandre Oliva  <aoliva@redhat.com>\n \n \t* doc/extend.texi (gnu_inline funtion attribute): Document C++"}, {"sha": "1afdd11f1308819b62e345beaffee739823a3231", "filename": "gcc/config/spu/spu.md", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46dc0789fed233da1561e6c2ee1a4a7ab82e9fd4/gcc%2Fconfig%2Fspu%2Fspu.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46dc0789fed233da1561e6c2ee1a4a7ab82e9fd4/gcc%2Fconfig%2Fspu%2Fspu.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu.md?ref=46dc0789fed233da1561e6c2ee1a4a7ab82e9fd4", "patch": "@@ -3887,6 +3887,48 @@ selb\\t%0,%4,%0,%3\"\n   [(set_attr \"type\" \"br\")])\n \n \f\n+\n+ ;; Define the subtract-one-and-jump insns so loop.c\n+ ;; knows what to generate.\n+ (define_expand \"doloop_end\"\n+   [(use (match_operand 0 \"\" \"\"))      ; loop pseudo\n+    (use (match_operand 1 \"\" \"\"))      ; iterations; zero if unknown\n+    (use (match_operand 2 \"\" \"\"))      ; max iterations\n+    (use (match_operand 3 \"\" \"\"))      ; loop level\n+    (use (match_operand 4 \"\" \"\"))]     ; label\n+   \"\"\n+   \"\n+ {\n+   /* Currently SMS relies on the do-loop pattern to recognize loops\n+      where (1) the control part comprises of all insns defining and/or\n+      using a certain 'count' register and (2) the loop count can be\n+      adjusted by modifying this register prior to the loop.\n+.     ??? The possible introduction of a new block to initialize the\n+      new IV can potentially effects branch optimizations.  */\n+   if (optimize > 0 && flag_modulo_sched)\n+   {\n+     rtx s0;\n+     rtx bcomp;\n+     rtx loc_ref;\n+\n+     /* Only use this on innermost loops.  */\n+     if (INTVAL (operands[3]) > 1)\n+       FAIL;\n+     if (GET_MODE (operands[0]) != SImode)\n+       FAIL;\n+\n+     s0 = operands [0];\n+     emit_move_insn (s0, gen_rtx_PLUS (SImode, s0, GEN_INT (-1)));\n+     bcomp = gen_rtx_NE(SImode, s0, const0_rtx);\n+     loc_ref = gen_rtx_LABEL_REF (VOIDmode, operands [4]);\n+     emit_jump_insn (gen_rtx_SET (VOIDmode, pc_rtx,\n+                                  gen_rtx_IF_THEN_ELSE (VOIDmode, bcomp,\n+                                                        loc_ref, pc_rtx)));\n+\n+     DONE;\n+   }\n+ }\")\n+\n ;; convert between any two modes, avoiding any GCC assumptions\n (define_expand \"spu_convert\"\n   [(set (match_operand 0 \"spu_reg_operand\" \"\")"}, {"sha": "f1ec8fdb121e0c89bd7df541a31adceab8b20c07", "filename": "gcc/ddg.c", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46dc0789fed233da1561e6c2ee1a4a7ab82e9fd4/gcc%2Fddg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46dc0789fed233da1561e6c2ee1a4a7ab82e9fd4/gcc%2Fddg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fddg.c?ref=46dc0789fed233da1561e6c2ee1a4a7ab82e9fd4", "patch": "@@ -176,13 +176,17 @@ create_ddg_dep_from_intra_loop_link (ddg_ptr g, ddg_node_ptr src_node,\n       rtx set;\n \n       set = single_set (dest_node->insn);\n-      if (set)\n+      /* TODO: Handle registers that REG_P is not true for them, i.e.\n+         subregs and special registers.  */\n+      if (set && REG_P (SET_DEST (set)))\n         {\n           int regno = REGNO (SET_DEST (set));\n-          struct df_ref *first_def =\n-            df_bb_regno_first_def_find (g->bb, regno);\n+          struct df_ref *first_def;\n           struct df_rd_bb_info *bb_info = DF_RD_BB_INFO (g->bb);\n \n+          first_def = df_bb_regno_first_def_find (g->bb, regno);\n+          gcc_assert (first_def);\n+\n           if (bitmap_bit_p (bb_info->gen, first_def->id))\n             return;\n         }"}, {"sha": "6e33a4f9ba014273b7f8199efc18e4418541840f", "filename": "gcc/loop-doloop.c", "status": "modified", "additions": 63, "deletions": 19, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46dc0789fed233da1561e6c2ee1a4a7ab82e9fd4/gcc%2Floop-doloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46dc0789fed233da1561e6c2ee1a4a7ab82e9fd4/gcc%2Floop-doloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-doloop.c?ref=46dc0789fed233da1561e6c2ee1a4a7ab82e9fd4", "patch": "@@ -69,35 +69,59 @@ along with GCC; see the file COPYING3.  If not see\n    if it is not a decrement and branch jump insn.  */\n \n rtx\n-doloop_condition_get (rtx pattern)\n+doloop_condition_get (rtx doloop_pat)\n {\n   rtx cmp;\n   rtx inc;\n   rtx reg;\n   rtx inc_src;\n   rtx condition;\n+  rtx pattern;\n \n-  /* The canonical doloop pattern we expect is:\n+  /* The canonical doloop pattern we expect has one of the following\n+     forms:\n \n-     (parallel [(set (pc) (if_then_else (condition)\n-                                        (label_ref (label))\n-                                        (pc)))\n-                (set (reg) (plus (reg) (const_int -1)))\n-                (additional clobbers and uses)])\n+     1)  (parallel [(set (pc) (if_then_else (condition)\n+\t  \t\t\t            (label_ref (label))\n+\t\t\t\t            (pc)))\n+\t             (set (reg) (plus (reg) (const_int -1)))\n+\t             (additional clobbers and uses)])\n \n-     Some targets (IA-64) wrap the set of the loop counter in\n-     an if_then_else too.\n+     The branch must be the first entry of the parallel (also required\n+     by jump.c), and the second entry of the parallel must be a set of\n+     the loop counter register.  Some targets (IA-64) wrap the set of\n+     the loop counter in an if_then_else too.\n \n-     In summary, the branch must be the first entry of the\n-     parallel (also required by jump.c), and the second\n-     entry of the parallel must be a set of the loop counter\n-     register.  */\n+     2)  (set (reg) (plus (reg) (const_int -1))\n+         (set (pc) (if_then_else (reg != 0)\n+\t                         (label_ref (label))\n+\t\t\t         (pc))).  */\n+\n+  pattern = PATTERN (doloop_pat);\n \n   if (GET_CODE (pattern) != PARALLEL)\n-    return 0;\n+    {\n+      rtx cond;\n+\n+      /* We expect the decrement to immediately precede the branch.  */\n \n-  cmp = XVECEXP (pattern, 0, 0);\n-  inc = XVECEXP (pattern, 0, 1);\n+      if ((PREV_INSN (doloop_pat) == NULL_RTX)\n+          || !INSN_P (PREV_INSN (doloop_pat)))\n+        return 0;\n+\n+      cmp = pattern;\n+      inc = PATTERN (PREV_INSN (doloop_pat));\n+      /* We expect the condition to be of the form (reg != 0)  */\n+      cond = XEXP (SET_SRC (cmp), 0);\n+      if (GET_CODE (cond) != NE || XEXP (cond, 1) != const0_rtx)\n+        return 0;\n+\n+    }\n+  else\n+    {\n+      cmp = XVECEXP (pattern, 0, 0);\n+      inc = XVECEXP (pattern, 0, 1);\n+    }\n \n   /* Check for (set (reg) (something)).  */\n   if (GET_CODE (inc) != SET)\n@@ -139,7 +163,29 @@ doloop_condition_get (rtx pattern)\n   if ((XEXP (condition, 0) == reg)\n       || (GET_CODE (XEXP (condition, 0)) == PLUS\n \t\t   && XEXP (XEXP (condition, 0), 0) == reg))\n+   {\n+     if (GET_CODE (pattern) != PARALLEL)\n+     /*  The second form we expect:\n+\n+         (set (reg) (plus (reg) (const_int -1))\n+         (set (pc) (if_then_else (reg != 0)\n+                                 (label_ref (label))\n+                                 (pc))).\n+\n+         is equivalent to the following:\n+\n+         (parallel [(set (pc) (if_then_else (reg != 1)\n+                                            (label_ref (label))\n+                                            (pc)))\n+                     (set (reg) (plus (reg) (const_int -1)))\n+                     (additional clobbers and uses)])\n+\n+         So we return that form instead.\n+     */\n+        condition = gen_rtx_fmt_ee (NE, VOIDmode, inc_src, const1_rtx);\n+\n     return condition;\n+   }\n \n   /* ??? If a machine uses a funny comparison, we could return a\n      canonicalized form here.  */\n@@ -597,9 +643,7 @@ doloop_optimize (struct loop *loop)\n     {\n       while (NEXT_INSN (doloop_pat) != NULL_RTX)\n \tdoloop_pat = NEXT_INSN (doloop_pat);\n-      if (JUMP_P (doloop_pat))\n-\tdoloop_pat = PATTERN (doloop_pat);\n-      else\n+      if (!JUMP_P (doloop_pat))\n \tdoloop_pat = NULL_RTX;\n     }\n "}, {"sha": "7e9f6aa1a693cb60bd695ecdb66d74d335e64dc0", "filename": "gcc/modulo-sched.c", "status": "modified", "additions": 108, "deletions": 40, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46dc0789fed233da1561e6c2ee1a4a7ab82e9fd4/gcc%2Fmodulo-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46dc0789fed233da1561e6c2ee1a4a7ab82e9fd4/gcc%2Fmodulo-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmodulo-sched.c?ref=46dc0789fed233da1561e6c2ee1a4a7ab82e9fd4", "patch": "@@ -82,8 +82,21 @@ along with GCC; see the file COPYING3.  If not see\n       perform modulo variable expansion for live ranges that span more than\n       II cycles (i.e. use register copies to prevent a def from overwriting\n       itself before reaching the use).\n-*/\n \n+    SMS works with countable loops (1) whose control part can be easily\n+    decoupled from the rest of the loop and (2) whose loop count can\n+    be easily adjusted.  This is because we peel a constant number of\n+    iterations into a prologue and epilogue for which we want to avoid\n+    emitting the control part, and a kernel which is to iterate that\n+    constant number of iterations less than the original loop.  So the\n+    control part should be a set of insns clearly identified and having\n+    its own iv, not otherwise used in the loop (at-least for now), which\n+    initializes a register before the loop to the number of iterations.\n+    Currently SMS relies on the do-loop pattern to recognize such loops,\n+    where (1) the control part comprises of all insns defining and/or\n+    using a certain 'count' register and (2) the loop count can be\n+    adjusted by modifying this register prior to the loop.  \n+    TODO: Rely on cfgloop analysis instead.  */\n \f\n /* This page defines partial-schedule structures and functions for\n    modulo scheduling.  */\n@@ -182,10 +195,11 @@ static int sms_order_nodes (ddg_ptr, int, int * result);\n static void set_node_sched_params (ddg_ptr);\n static partial_schedule_ptr sms_schedule_by_order (ddg_ptr, int, int, int *);\n static void permute_partial_schedule (partial_schedule_ptr ps, rtx last);\n-static void generate_prolog_epilog (partial_schedule_ptr ,struct loop * loop, rtx);\n+static void generate_prolog_epilog (partial_schedule_ptr, struct loop *loop,\n+                                    rtx, rtx);\n static void duplicate_insns_of_cycles (partial_schedule_ptr ps,\n \t\t\t\t       int from_stage, int to_stage,\n-\t\t\t\t       int is_prolog);\n+\t\t\t\t       int is_prolog, rtx count_reg);\n \n #define SCHED_ASAP(x) (((node_sched_params_ptr)(x)->aux.info)->asap)\n #define SCHED_TIME(x) (((node_sched_params_ptr)(x)->aux.info)->time)\n@@ -261,20 +275,22 @@ static struct sched_info sms_sched_info =\n };\n \n \n-/* Return the register decremented and tested in INSN,\n-   or zero if it is not a decrement-and-branch insn.  */\n-\n+/* Given HEAD and TAIL which are the first and last insns in a loop;\n+   return the register which controls the loop.  Return zero if it has\n+   more than one occurrence in the loop besides the control part or the\n+   do-loop pattern is not of the form we expect.  */\n static rtx\n-doloop_register_get (rtx insn ATTRIBUTE_UNUSED)\n+doloop_register_get (rtx head ATTRIBUTE_UNUSED, rtx tail ATTRIBUTE_UNUSED)\n {\n #ifdef HAVE_doloop_end\n-  rtx pattern, reg, condition;\n+  rtx reg, condition, insn;\n+  bool found = false;\n \n-  if (! JUMP_P (insn))\n+  if (!JUMP_P (tail))\n     return NULL_RTX;\n \n-  pattern = PATTERN (insn);\n-  condition = doloop_condition_get (pattern);\n+  /* TODO: Free SMS's dependence on doloop_condition_get.  */\n+  condition = doloop_condition_get (tail);\n   if (! condition)\n     return NULL_RTX;\n \n@@ -286,6 +302,29 @@ doloop_register_get (rtx insn ATTRIBUTE_UNUSED)\n   else\n     gcc_unreachable ();\n \n+  /* Check that the COUNT_REG has no other occurrences in the loop\n+     until the decrement.  We assume the control part consists of\n+     either a single (parallel) branch-on-count or a (non-parallel)\n+     branch immediately preceded by a single (decrement) insn.  */\n+  for (insn = head; insn != PREV_INSN (tail); insn = NEXT_INSN (insn))\n+    if ((found = reg_mentioned_p (reg, insn)) == true)\n+      break;\n+  if (found)\n+    {\n+      if (dump_file)\n+        fprintf (dump_file, \"SMS count_reg found outside control\\n\");\n+\n+      return NULL_RTX;\n+    }\n+  /* One last check in case the do-loop pattern is parallel.  */\n+  if (GET_CODE (PATTERN (tail)) == PARALLEL)\n+    if (reg_mentioned_p (reg, PREV_INSN (tail)))\n+      {\n+        if (dump_file)\n+          fprintf (dump_file, \"SMS count_reg found outside control\\n\");\n+\n+        return NULL_RTX;\n+      }\n   return reg;\n #else\n   return NULL_RTX;\n@@ -583,7 +622,7 @@ permute_partial_schedule (partial_schedule_ptr ps, rtx last)\n \n static void\n duplicate_insns_of_cycles (partial_schedule_ptr ps, int from_stage,\n-\t\t\t   int to_stage, int for_prolog)\n+\t\t\t   int to_stage, int for_prolog, rtx count_reg)\n {\n   int row;\n   ps_insn_ptr ps_ij;\n@@ -595,6 +634,13 @@ duplicate_insns_of_cycles (partial_schedule_ptr ps, int from_stage,\n \tint j, i_reg_moves;\n \trtx reg_move = NULL_RTX;\n \n+        /* Do not duplicate any insn which refers to count_reg as it\n+           belongs to the control part.\n+           TODO: This should be done by analyzing the control part of\n+           the loop.  */\n+        if (reg_mentioned_p (count_reg, u_node->insn))\n+          continue;\n+\n \tif (for_prolog)\n \t  {\n \t    /* SCHED_STAGE (u_node) >= from_stage == 0.  Generate increasing\n@@ -643,23 +689,35 @@ duplicate_insns_of_cycles (partial_schedule_ptr ps, int from_stage,\n \n /* Generate the instructions (including reg_moves) for prolog & epilog.  */\n static void\n-generate_prolog_epilog (partial_schedule_ptr ps, struct loop * loop, rtx count_reg)\n+generate_prolog_epilog (partial_schedule_ptr ps, struct loop *loop,\n+                        rtx count_reg, rtx count_init)\n {\n   int i;\n   int last_stage = PS_STAGE_COUNT (ps) - 1;\n   edge e;\n-\n+  \n   /* Generate the prolog, inserting its insns on the loop-entry edge.  */\n   start_sequence ();\n \n-  if (count_reg)\n-   /* Generate a subtract instruction at the beginning of the prolog to\n-      adjust the loop count by STAGE_COUNT.  */\n-   emit_insn (gen_sub2_insn (count_reg, GEN_INT (last_stage)));\n+  if (!count_init)\n+    {\n+      /* Generate instructions at the beginning of the prolog to\n+         adjust the loop count by STAGE_COUNT.  If loop count is constant\n+         (count_init), this constant is adjusted by STAGE_COUNT in\n+         generate_prolog_epilog function.  */\n+      rtx sub_reg = NULL_RTX;\n+\n+      sub_reg = expand_simple_binop (GET_MODE (count_reg), MINUS,\n+                                     count_reg, GEN_INT (last_stage),\n+                                     count_reg, 1, OPTAB_DIRECT);\n+      gcc_assert (REG_P (sub_reg));\n+      if (REGNO (sub_reg) != REGNO (count_reg))\n+        emit_move_insn (count_reg, sub_reg);\n+    }\n \n   for (i = 0; i < last_stage; i++)\n-    duplicate_insns_of_cycles (ps, 0, i, 1);\n-\n+    duplicate_insns_of_cycles (ps, 0, i, 1, count_reg);\n+  \n   /* Put the prolog on the entry edge.  */\n   e = loop_preheader_edge (loop);\n   split_edge_and_insert (e, get_insns ());\n@@ -670,8 +728,8 @@ generate_prolog_epilog (partial_schedule_ptr ps, struct loop * loop, rtx count_r\n   start_sequence ();\n \n   for (i = 0; i < last_stage; i++)\n-    duplicate_insns_of_cycles (ps, i + 1, last_stage, 0);\n-\n+    duplicate_insns_of_cycles (ps, i + 1, last_stage, 0, count_reg);\n+  \n   /* Put the epilogue on the exit edge.  */\n   gcc_assert (single_exit (loop));\n   e = single_exit (loop);\n@@ -907,20 +965,27 @@ sms_schedule (void)\n         }\n \n       /* Make sure this is a doloop.  */\n-      if ( !(count_reg = doloop_register_get (tail)))\n+      if ( !(count_reg = doloop_register_get (head, tail)))\n \tcontinue;\n \n       /* Don't handle BBs with calls or barriers, or !single_set insns,\n          or auto-increment insns (to avoid creating invalid reg-moves\n          for the auto-increment insns).  \n-         ??? Should handle auto-increment insns.  */\n-      for (insn = head; insn != NEXT_INSN (tail); insn = NEXT_INSN (insn))\n-\tif (CALL_P (insn)\n-\t    || BARRIER_P (insn)\n-\t    || (INSN_P (insn) && !JUMP_P (insn)\n-\t\t&& !single_set (insn) && GET_CODE (PATTERN (insn)) != USE)\n-            || (FIND_REG_INC_NOTE (insn, NULL_RTX) != 0))\n-\t  break;\n+         ??? Should handle auto-increment insns.\n+         ??? Should handle insns defining subregs.  */\n+     for (insn = head; insn != NEXT_INSN (tail); insn = NEXT_INSN (insn))\n+      {\n+         rtx set;\n+\n+        if (CALL_P (insn)\n+            || BARRIER_P (insn)\n+            || (INSN_P (insn) && !JUMP_P (insn)\n+                && !single_set (insn) && GET_CODE (PATTERN (insn)) != USE)\n+            || (FIND_REG_INC_NOTE (insn, NULL_RTX) != 0)\n+            || (INSN_P (insn) && (set = single_set (insn))\n+                && GET_CODE (SET_DEST (set)) == SUBREG))\n+        break;\n+      }\n \n       if (insn != NEXT_INSN (tail))\n \t{\n@@ -932,8 +997,11 @@ sms_schedule (void)\n \t\tfprintf (dump_file, \"SMS loop-with-barrier\\n\");\n               else if (FIND_REG_INC_NOTE (insn, NULL_RTX) != 0)\n                 fprintf (dump_file, \"SMS reg inc\\n\");\n-\t      else\n-\t\tfprintf (dump_file, \"SMS loop-with-not-single-set\\n\");\n+              else if ((INSN_P (insn) && !JUMP_P (insn)\n+                && !single_set (insn) && GET_CODE (PATTERN (insn)) != USE))\n+                fprintf (dump_file, \"SMS loop-with-not-single-set\\n\");\n+              else\n+               fprintf (dump_file, \"SMS loop with subreg in lhs\\n\");\n \t      print_rtl_single (dump_file, insn);\n \t    }\n \n@@ -998,7 +1066,7 @@ sms_schedule (void)\n       /* In case of th loop have doloop register it gets special\n \t handling.  */\n       count_init = NULL_RTX;\n-      if ((count_reg = doloop_register_get (tail)))\n+      if ((count_reg = doloop_register_get (head, tail)))\n \t{\n \t  basic_block pre_header;\n \n@@ -1072,7 +1140,10 @@ sms_schedule (void)\n \t     the closing_branch was scheduled and should appear in the last (ii-1)\n \t     row.  Otherwise, we are free to schedule the branch, and we let nodes\n \t     that were scheduled at the first PS_MIN_CYCLE cycle appear in the first\n-\t     row; this should reduce stage_count to minimum.  */\n+\t     row; this should reduce stage_count to minimum.  \n+             TODO: Revisit the issue of scheduling the insns of the\n+             control part relative to the branch when the control part\n+             has more than one insn.  */\n \t  normalize_sched_times (ps);\n \t  rotate_partial_schedule (ps, PS_MIN_CYCLE (ps));\n \t  set_columns_for_ps (ps);\n@@ -1111,11 +1182,8 @@ sms_schedule (void)\n \t  if (dump_file)\n \t    print_node_sched_params (dump_file, g->num_nodes, g);\n \t  /* Generate prolog and epilog.  */\n-\t  if (count_reg && !count_init)\n-\t    generate_prolog_epilog (ps, loop, count_reg);\n-\t  else\n-\t    generate_prolog_epilog (ps, loop, NULL_RTX);\n-\t    \n+          generate_prolog_epilog (ps, loop, count_reg, count_init);\n+ \n \t  free_undo_replace_buff (reg_move_replaces);\n \t}\n "}, {"sha": "690128fcca8d72e40fd7fb8a8527eed4322a449e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46dc0789fed233da1561e6c2ee1a4a7ab82e9fd4/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46dc0789fed233da1561e6c2ee1a4a7ab82e9fd4/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=46dc0789fed233da1561e6c2ee1a4a7ab82e9fd4", "patch": "@@ -1,3 +1,10 @@\n+2007-08-28  Mircea Namolaru  <namolaru@il.ibm.com>\n+            Vladimir Yanovsky  <yanov@il.ibm.com>\n+            Revital Eres  <eres@il.ibm.com>\n+            Andrey Belevantsev  <abel@ispras.ru>\n+\n+\t* gcc.dg/sms-1.c: New test.\n+\n 2007-08-27  Alexandre Oliva  <aoliva@redhat.com>\n \n \t* g++.dg/ext/gnu-inline-common.h: New."}, {"sha": "d915ef54f2b8d10949dd48174238fc046106c7cc", "filename": "gcc/testsuite/gcc.dg/sms-1.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46dc0789fed233da1561e6c2ee1a4a7ab82e9fd4/gcc%2Ftestsuite%2Fgcc.dg%2Fsms-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46dc0789fed233da1561e6c2ee1a4a7ab82e9fd4/gcc%2Ftestsuite%2Fgcc.dg%2Fsms-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsms-1.c?ref=46dc0789fed233da1561e6c2ee1a4a7ab82e9fd4", "patch": "@@ -0,0 +1,38 @@\n+/* The same test as loop-3c.c.  It failed on ia64\n+   due to not handling of subreg in the lhs that is fixed.  */\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -fmodulo-sched -fmodulo-sched-allow-regmoves -w\" } */\n+\n+\n+#include <limits.h>\n+\n+void * a[255];\n+\n+f (m)\n+{\n+  int i;\n+  int sh = 0x100;\n+  i = m;\n+  do\n+    {\n+      a[sh >>= 1] = ((unsigned)i << 3)  + (char*)a;\n+      i += 4;\n+    }\n+  while (i < INT_MAX/2 + 1 + 4 * 4);\n+}\n+\n+main ()\n+{\n+  a[0x10] = 0;\n+  a[0x08] = 0;\n+  f (INT_MAX/2 + INT_MAX/4 + 2);\n+  if (a[0x10] || a[0x08])\n+    abort ();\n+  a[0x10] = 0;\n+  a[0x08] = 0;\n+  f (INT_MAX/2 + 1);\n+  if (! a[0x10] || a[0x08])\n+    abort ();\n+  exit (0);\n+}\n+"}]}