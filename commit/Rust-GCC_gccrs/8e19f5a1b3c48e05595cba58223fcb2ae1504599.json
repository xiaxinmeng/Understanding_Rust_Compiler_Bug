{"sha": "8e19f5a1b3c48e05595cba58223fcb2ae1504599", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGUxOWY1YTFiM2M0OGUwNTU5NWNiYTU4MjIzZmNiMmFlMTUwNDU5OQ==", "commit": {"author": {"name": "Ira Rosen", "email": "ira.rosen@linaro.org", "date": "2011-09-25T12:33:03Z"}, "committer": {"name": "Ira Rosen", "email": "irar@gcc.gnu.org", "date": "2011-09-25T12:33:03Z"}, "message": "tree-vect-slp.c (vect_slp_analyze_bb_1): Split out core part of vect_analyze_bb here.\n\n\n        * tree-vect-slp.c (vect_slp_analyze_bb_1): Split out core part\n        of vect_analyze_bb here.\n        (vect_analyze_bb): Loop over vector sizes calling\n        vect_analyze_bb_1.\n\nFrom-SVN: r179164", "tree": {"sha": "5e6b24cfe0fb459242ac91d070e83079a6dc651c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5e6b24cfe0fb459242ac91d070e83079a6dc651c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8e19f5a1b3c48e05595cba58223fcb2ae1504599", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e19f5a1b3c48e05595cba58223fcb2ae1504599", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8e19f5a1b3c48e05595cba58223fcb2ae1504599", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e19f5a1b3c48e05595cba58223fcb2ae1504599/comments", "author": null, "committer": null, "parents": [{"sha": "13ec1ccaaa69f1b12be42b3bb91f4223eea7e4df", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/13ec1ccaaa69f1b12be42b3bb91f4223eea7e4df", "html_url": "https://github.com/Rust-GCC/gccrs/commit/13ec1ccaaa69f1b12be42b3bb91f4223eea7e4df"}], "stats": {"total": 179, "additions": 151, "deletions": 28}, "files": [{"sha": "6978fab421f79e6151cb3521a6d8120d0909c30d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e19f5a1b3c48e05595cba58223fcb2ae1504599/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e19f5a1b3c48e05595cba58223fcb2ae1504599/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8e19f5a1b3c48e05595cba58223fcb2ae1504599", "patch": "@@ -1,3 +1,9 @@\n+2011-09-25  Ira Rosen  <ira.rosen@linaro.org>\n+\n+\t* tree-vect-slp.c (vect_slp_analyze_bb_1): Split out core part\n+\tof vect_analyze_bb here.\n+\t(vect_analyze_bb): Loop over vector sizes calling vect_analyze_bb_1.\n+\n 2011-09-25  Ira Rosen  <ira.rosen@linaro.org>\n \n \t* tree-data-ref.c (dr_analyze_innermost): Add new argument."}, {"sha": "00eed090b5bfee5e4d275cbd2b8b14ecc3334df3", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e19f5a1b3c48e05595cba58223fcb2ae1504599/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e19f5a1b3c48e05595cba58223fcb2ae1504599/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8e19f5a1b3c48e05595cba58223fcb2ae1504599", "patch": "@@ -1,3 +1,10 @@\n+2011-09-25  Ira Rosen  <ira.rosen@linaro.org>\n+\n+\t* lib/target-supports.exp (check_effective_target_vect64): New.\n+\t* gcc.dg/vect/bb-slp-11.c: Expect the error message twice in case\n+\tof multiple vector sizes.\n+\t* gcc.dg/vect/bb-slp-26.c: New.\n+\n 2011-09-25  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/50280"}, {"sha": "677eb38259a06adc465a24a35ac06f76917c886b", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-11.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e19f5a1b3c48e05595cba58223fcb2ae1504599/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e19f5a1b3c48e05595cba58223fcb2ae1504599/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-11.c?ref=8e19f5a1b3c48e05595cba58223fcb2ae1504599", "patch": "@@ -49,6 +49,7 @@ int main (void)\n }\n \n /* { dg-final { scan-tree-dump-times \"basic block vectorized using SLP\" 0 \"slp\" } } */\n-/* { dg-final { scan-tree-dump-times \"SLP with multiple types\" 1 \"slp\" } } */\n+/* { dg-final { scan-tree-dump-times \"SLP with multiple types\" 1 \"slp\" { xfail vect_multiple_sizes } } } */\n+/* { dg-final { scan-tree-dump-times \"SLP with multiple types\" 2 \"slp\" { target vect_multiple_sizes } } } */\n /* { dg-final { cleanup-tree-dump \"slp\" } } */\n   "}, {"sha": "cf8f9587d03d9b6a9cf2c3329c2f499aa34b7da9", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-26.c", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e19f5a1b3c48e05595cba58223fcb2ae1504599/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-26.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e19f5a1b3c48e05595cba58223fcb2ae1504599/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-26.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-26.c?ref=8e19f5a1b3c48e05595cba58223fcb2ae1504599", "patch": "@@ -0,0 +1,60 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define A 3\n+#define B 4\n+#define N 256\n+\n+char src[N], dst[N];\n+\n+void foo (char * __restrict__ dst, char * __restrict__ src, int h,\n+          int stride, int dummy)\n+{\n+  int i;\n+  h /= 16;\n+  for (i = 0; i < h; i++)\n+    {\n+      dst[0] += A*src[0] + src[stride];\n+      dst[1] += A*src[1] + src[1+stride];\n+      dst[2] += A*src[2] + src[2+stride];\n+      dst[3] += A*src[3] + src[3+stride];\n+      dst[4] += A*src[4] + src[4+stride];\n+      dst[5] += A*src[5] + src[5+stride];\n+      dst[6] += A*src[6] + src[6+stride];\n+      dst[7] += A*src[7] + src[7+stride];\n+      dst += 8;\n+      src += 8;\n+      if (dummy == 32)\n+        abort ();\n+   }\n+}\n+\n+\n+int main (void)\n+{\n+  int i;\n+\n+  check_vect ();\n+\n+  for (i = 0; i < N; i++)\n+    {\n+       dst[i] = 0;\n+       src[i] = i/8;\n+    }\n+\n+  foo (dst, src, N, 8, 0);\n+\n+  for (i = 0; i < N/2; i++)\n+    {\n+      if (dst[i] != A * src[i] + src[i+8])\n+        abort ();\n+    }\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"basic block vectorized using SLP\" 1 \"slp\" { target vect64 } } } */\n+/* { dg-final { cleanup-tree-dump \"slp\" } } */\n+"}, {"sha": "59ceecaad1c8a79f4ab2a0c051b3f9fe4e32fea5", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e19f5a1b3c48e05595cba58223fcb2ae1504599/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e19f5a1b3c48e05595cba58223fcb2ae1504599/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=8e19f5a1b3c48e05595cba58223fcb2ae1504599", "patch": "@@ -3393,6 +3393,24 @@ proc check_effective_target_vect_multiple_sizes { } {\n     return $et_vect_multiple_sizes_saved\n }\n \n+# Return 1 if the target supports vectors of 64 bits.\n+\n+proc check_effective_target_vect64 { } {\n+    global et_vect64\n+\n+    if [info exists et_vect64_saved] {\n+        verbose \"check_effective_target_vect64: using cached result\" 2\n+    } else {\n+        set et_vect64_saved 0\n+        if { ([istarget arm*-*-*] && [check_effective_target_arm_neon_ok]) } {\n+           set et_vect64_saved 1\n+        }\n+    }\n+\n+    verbose \"check_effective_target_vect64: returning $et_vect64_saved\" 2\n+    return $et_vect64_saved\n+}\n+\n # Return 1 if the target supports section-anchors\n \n proc check_effective_target_section_anchors { } {"}, {"sha": "5dc5cf694b248e761d8c7a59709809950a9d3b2b", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 58, "deletions": 27, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e19f5a1b3c48e05595cba58223fcb2ae1504599/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e19f5a1b3c48e05595cba58223fcb2ae1504599/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=8e19f5a1b3c48e05595cba58223fcb2ae1504599", "patch": "@@ -1694,42 +1694,18 @@ vect_bb_vectorization_profitable_p (bb_vec_info bb_vinfo)\n \n /* Check if the basic block can be vectorized.  */\n \n-bb_vec_info\n-vect_slp_analyze_bb (basic_block bb)\n+static bb_vec_info\n+vect_slp_analyze_bb_1 (basic_block bb)\n {\n   bb_vec_info bb_vinfo;\n   VEC (ddr_p, heap) *ddrs;\n   VEC (slp_instance, heap) *slp_instances;\n   slp_instance instance;\n-  int i, insns = 0;\n-  gimple_stmt_iterator gsi;\n+  int i;\n   int min_vf = 2;\n   int max_vf = MAX_VECTORIZATION_FACTOR;\n   bool data_dependence_in_bb = false;\n \n-  current_vector_size = 0;\n-\n-  if (vect_print_dump_info (REPORT_DETAILS))\n-    fprintf (vect_dump, \"===vect_slp_analyze_bb===\\n\");\n-\n-  for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n-    {\n-      gimple stmt = gsi_stmt (gsi);\n-      if (!is_gimple_debug (stmt)\n-\t  && !gimple_nop_p (stmt)\n-\t  && gimple_code (stmt) != GIMPLE_LABEL)\n-\tinsns++;\n-    }\n-\n-  if (insns > PARAM_VALUE (PARAM_SLP_MAX_INSNS_IN_BB))\n-    {\n-      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOCATIONS))\n-        fprintf (vect_dump, \"not vectorized: too many instructions in basic \"\n-                            \"block.\\n\");\n-\n-      return NULL;\n-    }\n-\n   bb_vinfo = new_bb_vec_info (bb);\n   if (!bb_vinfo)\n     return NULL;\n@@ -1849,6 +1825,61 @@ vect_slp_analyze_bb (basic_block bb)\n }\n \n \n+bb_vec_info\n+vect_slp_analyze_bb (basic_block bb)\n+{\n+  bb_vec_info bb_vinfo;\n+  int insns = 0;\n+  gimple_stmt_iterator gsi;\n+  unsigned int vector_sizes;\n+\n+  if (vect_print_dump_info (REPORT_DETAILS))\n+    fprintf (vect_dump, \"===vect_slp_analyze_bb===\\n\");\n+\n+  for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+    {\n+      gimple stmt = gsi_stmt (gsi);\n+      if (!is_gimple_debug (stmt)\n+          && !gimple_nop_p (stmt)\n+          && gimple_code (stmt) != GIMPLE_LABEL)\n+        insns++;\n+    }\n+\n+  if (insns > PARAM_VALUE (PARAM_SLP_MAX_INSNS_IN_BB))\n+    {\n+      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOCATIONS))\n+        fprintf (vect_dump, \"not vectorized: too many instructions in basic \"\n+                            \"block.\\n\");\n+\n+      return NULL;\n+    }\n+\n+  /* Autodetect first vector size we try.  */\n+  current_vector_size = 0;\n+  vector_sizes = targetm.vectorize.autovectorize_vector_sizes ();\n+\n+  while (1)\n+    {\n+      bb_vinfo = vect_slp_analyze_bb_1 (bb);\n+      if (bb_vinfo)\n+        return bb_vinfo;\n+\n+      destroy_bb_vec_info (bb_vinfo);\n+\n+      vector_sizes &= ~current_vector_size;\n+      if (vector_sizes == 0\n+          || current_vector_size == 0)\n+        return NULL;\n+\n+      /* Try the next biggest vector size.  */\n+      current_vector_size = 1 << floor_log2 (vector_sizes);\n+      if (vect_print_dump_info (REPORT_DETAILS))\n+        fprintf (vect_dump, \"***** Re-trying analysis with \"\n+                 \"vector size %d\\n\", current_vector_size);\n+    }\n+}\n+\n+\n /* SLP costs are calculated according to SLP instance unrolling factor (i.e.,\n    the number of created vector stmts depends on the unrolling factor).\n    However, the actual number of vector stmts for every SLP node depends on"}]}