{"sha": "1910440ea6f09731f4c475f8556c101e8944340c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTkxMDQ0MGVhNmYwOTczMWY0YzQ3NWY4NTU2YzEwMWU4OTQ0MzQwYw==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard@codesourcery.com", "date": "2007-05-10T11:15:07Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2007-05-10T11:15:07Z"}, "message": "config.gcc (sparc-wrs-vxworks): New target.\n\ngcc/\n\t* config.gcc (sparc-wrs-vxworks): New target.\n\t* config/sparc/vxworks.h, config/sparc/t-vxworks: New files.\n\t* config/sparc/sparc-protos.h (sparc_emit_call_insn): Declare.\n\t* config/sparc/sparc.h: Include vxworks-dummy.h.\n\t(PRINT_OPERAND_ADDRESS): Extend SYMBOL_REF handling to\n\tinclude LABEL_REFs too.\n\t* config/sparc/sparc.c (sparc_expand_move): Don't assume that\n\t_GLOBAL_OFFSET_TABLE_ - label_ref is a link-time constant on\n\tVxWorks.\n\t(legitimize_pic_address): Handle LABEL_REFs like SYMBOL_REFs\n\ton VxWorks.\n\t(load_pic_register): Use gen_vxworks_load_got for VxWorks.\n\t(sparc_emit_call_insn): New function.\n\t(sparc_function_ok_for_sibcall): Restrict sibcalls to locally-binding\n\tfunctions when generating VxWorks PIC.\n\t* config/sparc/sparc.md (vxworks_load_got): New pattern.\n\t(call, call_value): Use sparc_emit_call_insn instead of\n\temit_call_insn.\n\nlibgcc/\n\t* config.host (sparc-wrs-vxworks): New target.\n\nFrom-SVN: r124595", "tree": {"sha": "6dd6c8dc5926e50ceabcd4e33f3edafd37e19c3c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6dd6c8dc5926e50ceabcd4e33f3edafd37e19c3c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1910440ea6f09731f4c475f8556c101e8944340c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1910440ea6f09731f4c475f8556c101e8944340c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1910440ea6f09731f4c475f8556c101e8944340c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1910440ea6f09731f4c475f8556c101e8944340c/comments", "author": null, "committer": null, "parents": [{"sha": "31b40480a461ba486b17ad808fd0266546fabddf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31b40480a461ba486b17ad808fd0266546fabddf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/31b40480a461ba486b17ad808fd0266546fabddf"}], "stats": {"total": 210, "additions": 190, "deletions": 20}, "files": [{"sha": "60c3c9cafbf6d3f098f0a309f75ed2d66297b533", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1910440ea6f09731f4c475f8556c101e8944340c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1910440ea6f09731f4c475f8556c101e8944340c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1910440ea6f09731f4c475f8556c101e8944340c", "patch": "@@ -1,3 +1,24 @@\n+2007-05-10  Richard Sandiford  <richard@codesourcery.com>\n+\n+\t* config.gcc (sparc-wrs-vxworks): New target.\n+\t* config/sparc/vxworks.h, config/sparc/t-vxworks: New files.\n+\t* config/sparc/sparc-protos.h (sparc_emit_call_insn): Declare.\n+\t* config/sparc/sparc.h: Include vxworks-dummy.h.\n+\t(PRINT_OPERAND_ADDRESS): Extend SYMBOL_REF handling to\n+\tinclude LABEL_REFs too.\n+\t* config/sparc/sparc.c (sparc_expand_move): Don't assume that\n+\t_GLOBAL_OFFSET_TABLE_ - label_ref is a link-time constant on\n+\tVxWorks.\n+\t(legitimize_pic_address): Handle LABEL_REFs like SYMBOL_REFs\n+\ton VxWorks.\n+\t(load_pic_register): Use gen_vxworks_load_got for VxWorks.\n+\t(sparc_emit_call_insn): New function.\n+\t(sparc_function_ok_for_sibcall): Restrict sibcalls to locally-binding\n+\tfunctions when generating VxWorks PIC.\n+\t* config/sparc/sparc.md (vxworks_load_got): New pattern.\n+\t(call, call_value): Use sparc_emit_call_insn instead of\n+\temit_call_insn.\n+\n 2007-05-09  Bob Wilson  <bob.wilson@acm.org>\n \t\n \t* config/xtensa/xtensa.c (xtensa_output_literal): Don't use #if."}, {"sha": "a26f3ddd933af0536e128a7559fd2bcf9eec86c9", "filename": "gcc/config.gcc", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1910440ea6f09731f4c475f8556c101e8944340c/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1910440ea6f09731f4c475f8556c101e8944340c/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=1910440ea6f09731f4c475f8556c101e8944340c", "patch": "@@ -2370,6 +2370,10 @@ sparc-*-sysv4*)\n \textra_parts=\"crtbegin.o crtend.o\"\n \tuse_fixproto=yes\n \t;;\n+sparc-wrs-vxworks)\n+\ttm_file=\"${tm_file} elfos.h svr4.h sparc/sysv4.h vx-common.h vxworks.h sparc/vxworks.h\"\n+\ttmake_file=\"${tmake_file} sparc/t-vxworks\"\n+\t;;\n sparc64-*-elf*)\n \ttm_file=\"${tm_file} dbxelf.h elfos.h svr4.h sparc/sysv4.h sparc/sp64-elf.h\"\n \textra_options=\"${extra_options} sparc/little-endian.opt\""}, {"sha": "c1b2813a3b383f22c70475aa9c2769ad6ce8fea4", "filename": "gcc/config/sparc/sparc-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1910440ea6f09731f4c475f8556c101e8944340c/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1910440ea6f09731f4c475f8556c101e8944340c/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h?ref=1910440ea6f09731f4c475f8556c101e8944340c", "patch": "@@ -73,6 +73,7 @@ extern int legitimate_address_p (enum machine_mode, rtx, int);\n extern rtx legitimize_pic_address (rtx, enum machine_mode, rtx);\n extern rtx legitimize_tls_address (rtx);\n extern rtx legitimize_address (rtx, rtx, enum machine_mode);\n+extern void sparc_emit_call_insn (rtx, rtx);\n extern void sparc_defer_case_vector (rtx, rtx, int);\n extern bool sparc_expand_move (enum machine_mode, rtx *);\n extern void sparc_emit_set_const32 (rtx, rtx);"}, {"sha": "f94af2ac5d17423fb930e5e6ac9860fe53cdfaab", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 61, "deletions": 13, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1910440ea6f09731f4c475f8556c101e8944340c/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1910440ea6f09731f4c475f8556c101e8944340c/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=1910440ea6f09731f4c475f8556c101e8944340c", "patch": "@@ -980,17 +980,27 @@ sparc_expand_move (enum machine_mode mode, rtx *operands)\n       if (pic_address_needs_scratch (operands[1]))\n \toperands[1] = legitimize_pic_address (operands[1], mode, 0);\n \n-      if (GET_CODE (operands[1]) == LABEL_REF && mode == SImode)\n-\t{\n-\t  emit_insn (gen_movsi_pic_label_ref (operands[0], operands[1]));\n-\t  return true;\n-\t}\n+      /* VxWorks does not impose a fixed gap between segments; the run-time\n+\t gap can be different from the object-file gap.  We therefore can't\n+\t assume X - _GLOBAL_OFFSET_TABLE_ is a link-time constant unless we\n+\t are absolutely sure that X is in the same segment as the GOT.\n+\t Unfortunately, the flexibility of linker scripts means that we\n+\t can't be sure of that in general, so assume that _G_O_T_-relative\n+\t accesses are never valid on VxWorks.  */\n+      if (GET_CODE (operands[1]) == LABEL_REF && !TARGET_VXWORKS_RTP)\n+\t{\n+\t  if (mode == SImode)\n+\t    {\n+\t      emit_insn (gen_movsi_pic_label_ref (operands[0], operands[1]));\n+\t      return true;\n+\t    }\n \n-      if (GET_CODE (operands[1]) == LABEL_REF && mode == DImode)\n-\t{\n-\t  gcc_assert (TARGET_ARCH64);\n-\t  emit_insn (gen_movdi_pic_label_ref (operands[0], operands[1]));\n-\t  return true;\n+\t  if (mode == DImode)\n+\t    {\n+\t      gcc_assert (TARGET_ARCH64);\n+\t      emit_insn (gen_movdi_pic_label_ref (operands[0], operands[1]));\n+\t      return true;\n+\t    }\n \t}\n \n       if (symbolic_operand (operands[1], mode))\n@@ -3212,7 +3222,9 @@ rtx\n legitimize_pic_address (rtx orig, enum machine_mode mode ATTRIBUTE_UNUSED,\n \t\t\trtx reg)\n {\n-  if (GET_CODE (orig) == SYMBOL_REF)\n+  if (GET_CODE (orig) == SYMBOL_REF\n+      /* See the comment in sparc_expand_move.  */\n+      || (TARGET_VXWORKS_RTP && GET_CODE (orig) == LABEL_REF))\n     {\n       rtx pic_ref, address;\n       rtx insn;\n@@ -3377,6 +3389,13 @@ load_pic_register (bool delay_pic_helper)\n {\n   int orig_flag_pic = flag_pic;\n \n+  if (TARGET_VXWORKS_RTP)\n+    {\n+      emit_insn (gen_vxworks_load_got ());\n+      emit_insn (gen_rtx_USE (VOIDmode, pic_offset_table_rtx));\n+      return;\n+    }\n+\n   /* If we haven't initialized the special PIC symbols, do so now.  */\n   if (!pic_helper_symbol_name[0])\n     {\n@@ -3405,6 +3424,29 @@ load_pic_register (bool delay_pic_helper)\n      since we may not fall out the bottom.  */\n   emit_insn (gen_rtx_USE (VOIDmode, pic_offset_table_rtx));\n }\n+\n+/* Emit a call instruction with the pattern given by PAT.  ADDR is the\n+   address of the call target.  */\n+\n+void\n+sparc_emit_call_insn (rtx pat, rtx addr)\n+{\n+  rtx insn;\n+\n+  insn = emit_call_insn (pat);\n+\n+  /* The PIC register is live on entry to VxWorks PIC PLT entries.  */\n+  if (TARGET_VXWORKS_RTP\n+      && flag_pic\n+      && GET_CODE (addr) == SYMBOL_REF\n+      && (SYMBOL_REF_DECL (addr)\n+\t  ? !targetm.binds_local_p (SYMBOL_REF_DECL (addr))\n+\t  : !SYMBOL_REF_LOCAL_P (addr)))\n+    {\n+      use_reg (&CALL_INSN_FUNCTION_USAGE (insn), pic_offset_table_rtx);\n+      current_function_uses_pic_offset_table = 1;\n+    }\n+}\n \f\n /* Return 1 if RTX is a MEM which is known to be aligned to at\n    least a DESIRED byte boundary.  */\n@@ -7771,13 +7813,19 @@ sparc_elf_asm_named_section (const char *name, unsigned int flags,\n    the sibling call right?  Well, in the C++ case we can end up passing\n    the pointer to the struct return area to a constructor (which returns\n    void) and then nothing else happens.  Such a sibling call would look\n-   valid without the added check here.  */\n+   valid without the added check here.\n+\n+   VxWorks PIC PLT entries require the global pointer to be initialized\n+   on entry.  We therefore can't emit sibling calls to them.  */\n static bool\n sparc_function_ok_for_sibcall (tree decl, tree exp ATTRIBUTE_UNUSED)\n {\n   return (decl\n \t  && flag_delayed_branch\n-\t  && (TARGET_ARCH64 || ! current_function_returns_struct));\n+\t  && (TARGET_ARCH64 || ! current_function_returns_struct)\n+\t  && !(TARGET_VXWORKS_RTP\n+\t       && flag_pic\n+\t       && !targetm.binds_local_p (decl)));\n }\n \f\n /* libfunc renaming.  */"}, {"sha": "1a4805bb7d3e3336cdf9a1c34b31e8594a2c6863", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1910440ea6f09731f4c475f8556c101e8944340c/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1910440ea6f09731f4c475f8556c101e8944340c/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=1910440ea6f09731f4c475f8556c101e8944340c", "patch": "@@ -22,6 +22,8 @@ along with GCC; see the file COPYING.  If not, write to\n the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n Boston, MA 02110-1301, USA.  */\n \n+#include \"config/vxworks-dummy.h\"\n+\n /* Note that some other tm.h files include this one and then override\n    whatever definitions are necessary.  */\n \n@@ -2409,6 +2411,7 @@ extern int sparc_indent_opcode;\n \t  else if (GET_CODE (index) == REG)\t\t\t\\\n \t    fprintf (FILE, \"+%s\", reg_names[REGNO (index)]);\t\\\n \t  else if (GET_CODE (index) == SYMBOL_REF\t\t\\\n+\t\t   || GET_CODE (index) == LABEL_REF\t\t\\\n \t\t   || GET_CODE (index) == CONST)\t\t\\\n \t    fputc ('+', FILE), output_addr_const (FILE, index);\t\\\n \t  else gcc_unreachable ();\t\t\t\t\\"}, {"sha": "6d5797dbe2b91106cc074acc25c4ab86b7c1ce80", "filename": "gcc/config/sparc/sparc.md", "status": "modified", "additions": 25, "deletions": 7, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1910440ea6f09731f4c475f8556c101e8944340c/gcc%2Fconfig%2Fsparc%2Fsparc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1910440ea6f09731f4c475f8556c101e8944340c/gcc%2Fconfig%2Fsparc%2Fsparc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.md?ref=1910440ea6f09731f4c475f8556c101e8944340c", "patch": "@@ -1874,6 +1874,22 @@\n   \"flag_pic\"\n   \"or\\t%1, %%lo(%a3-(%a2-.)), %0\")\n \n+;; Set up the PIC register for VxWorks.\n+\n+(define_expand \"vxworks_load_got\"\n+  [(set (match_dup 0)\n+\t(high:SI (match_dup 1)))\n+   (set (match_dup 0)\n+\t(mem:SI (lo_sum:SI (match_dup 0) (match_dup 1))))\n+   (set (match_dup 0)\n+\t(mem:SI (lo_sum:SI (match_dup 0) (match_dup 2))))]\n+  \"TARGET_VXWORKS_RTP\"\n+{\n+  operands[0] = pic_offset_table_rtx;\n+  operands[1] = gen_rtx_SYMBOL_REF (SImode, VXWORKS_GOTT_BASE);\n+  operands[2] = gen_rtx_SYMBOL_REF (SImode, VXWORKS_GOTT_INDEX);\n+})\n+\n (define_expand \"movdi\"\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"\")\n \t(match_operand:DI 1 \"general_operand\" \"\"))]\n@@ -6676,7 +6692,7 @@\n {\n   rtx fn_rtx;\n \n-  gcc_assert (GET_MODE (operands[0]) == FUNCTION_MODE);\n+  gcc_assert (MEM_P (operands[0]) && GET_MODE (operands[0]) == FUNCTION_MODE);\n \n   gcc_assert (GET_CODE (operands[3]) == CONST_INT);\n \n@@ -6712,18 +6728,20 @@\n \n   /* We accept negative sizes for untyped calls.  */\n   if (! TARGET_ARCH64 && INTVAL (operands[3]) != 0)\n-    emit_call_insn\n+    sparc_emit_call_insn\n       (gen_rtx_PARALLEL\n        (VOIDmode,\n \tgen_rtvec (3, gen_rtx_CALL (VOIDmode, fn_rtx, const0_rtx),\n \t\t   operands[3],\n-\t\t   gen_rtx_CLOBBER (VOIDmode, gen_rtx_REG (Pmode, 15)))));\n+\t\t   gen_rtx_CLOBBER (VOIDmode, gen_rtx_REG (Pmode, 15)))),\n+       XEXP (fn_rtx, 0));\n   else\n-    emit_call_insn\n+    sparc_emit_call_insn\n       (gen_rtx_PARALLEL\n        (VOIDmode,\n \tgen_rtvec (2, gen_rtx_CALL (VOIDmode, fn_rtx, const0_rtx),\n-\t\t   gen_rtx_CLOBBER (VOIDmode, gen_rtx_REG (Pmode, 15)))));\n+\t\t   gen_rtx_CLOBBER (VOIDmode, gen_rtx_REG (Pmode, 15)))),\n+       XEXP (fn_rtx, 0));\n \n  finish_call:\n \n@@ -6840,7 +6858,7 @@\n   rtx fn_rtx;\n   rtvec vec;\n \n-  gcc_assert (GET_MODE (operands[1]) == FUNCTION_MODE);\n+  gcc_assert (MEM_P (operands[1]) && GET_MODE (operands[1]) == FUNCTION_MODE);\n \n   fn_rtx = operands[1];\n \n@@ -6849,7 +6867,7 @@\n \t\t\t\tgen_rtx_CALL (VOIDmode, fn_rtx, const0_rtx)),\n \t\t   gen_rtx_CLOBBER (VOIDmode, gen_rtx_REG (Pmode, 15)));\n \n-  emit_call_insn (gen_rtx_PARALLEL (VOIDmode, vec));\n+  sparc_emit_call_insn (gen_rtx_PARALLEL (VOIDmode, vec), XEXP (fn_rtx, 0));\n \n   DONE;\n })"}, {"sha": "2aabf1a43cdd4ba92fcfc70a8fdb402e0dbe2c10", "filename": "gcc/config/sparc/t-vxworks", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1910440ea6f09731f4c475f8556c101e8944340c/gcc%2Fconfig%2Fsparc%2Ft-vxworks", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1910440ea6f09731f4c475f8556c101e8944340c/gcc%2Fconfig%2Fsparc%2Ft-vxworks", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Ft-vxworks?ref=1910440ea6f09731f4c475f8556c101e8944340c", "patch": "@@ -0,0 +1,5 @@\n+# Multilibs for VxWorks.\n+\n+MULTILIB_OPTIONS = mrtp fPIC\n+MULTILIB_MATCHES = fPIC=fpic\n+MULTILIB_EXCEPTIONS = fPIC"}, {"sha": "7faacea53abdb8a2eb8364c188d8268244b668c4", "filename": "gcc/config/sparc/vxworks.h", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1910440ea6f09731f4c475f8556c101e8944340c/gcc%2Fconfig%2Fsparc%2Fvxworks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1910440ea6f09731f4c475f8556c101e8944340c/gcc%2Fconfig%2Fsparc%2Fvxworks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fvxworks.h?ref=1910440ea6f09731f4c475f8556c101e8944340c", "patch": "@@ -0,0 +1,64 @@\n+/* Definitions of target machine for GNU compiler,\n+   for SPARC targeting the VxWorks run time environment.\n+   Copyright (C) 2007 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+#define TARGET_OS_CPP_BUILTINS()\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      builtin_define (\"__sparc\");\t\t\\\n+      builtin_define (\"CPU=SIMSPARCSOLARIS\");\t\\\n+      VXWORKS_OS_CPP_BUILTINS ();\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+\n+#undef OVERRIDE_OPTIONS\n+#define OVERRIDE_OPTIONS\t\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      VXWORKS_OVERRIDE_OPTIONS;\t\t\t\\\n+      sparc_override_options ();\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+\n+#undef CPP_SUBTARGET_SPEC\n+#define CPP_SUBTARGET_SPEC VXWORKS_ADDITIONAL_CPP_SPEC\n+\n+#undef LIB_SPEC\n+#define LIB_SPEC VXWORKS_LIB_SPEC\n+#undef LINK_SPEC\n+#define LINK_SPEC VXWORKS_LINK_SPEC\n+#undef STARTFILE_SPEC\n+#define STARTFILE_SPEC VXWORKS_STARTFILE_SPEC\n+#undef ENDFILE_SPEC\n+#define ENDFILE_SPEC VXWORKS_ENDFILE_SPEC\n+\n+#undef TARGET_VERSION\n+#define TARGET_VERSION fputs (\" (SPARC/VxWorks)\", stderr);\n+\n+#undef FUNCTION_PROFILER\n+#define FUNCTION_PROFILER VXWORKS_FUNCTION_PROFILER\n+\n+/* Use standard numbered ctors/dtors sections.  */\n+#undef CTORS_SECTION_ASM_OP\n+#undef DTORS_SECTION_ASM_OP\n+\n+/* We cannot use PC-relative accesses for VxWorks PIC because there is no\n+   fixed gap between segments.  */\n+#undef ASM_PREFERRED_EH_DATA_FORMAT"}, {"sha": "8baa49f82e220ff4ce7b3c15c4b0cf40000333da", "filename": "libgcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1910440ea6f09731f4c475f8556c101e8944340c/libgcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1910440ea6f09731f4c475f8556c101e8944340c/libgcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FChangeLog?ref=1910440ea6f09731f4c475f8556c101e8944340c", "patch": "@@ -1,3 +1,7 @@\n+2007-05-10  Richard Sandiford  <richard@codesourcery.com>\n+\n+\t* config.host (sparc-wrs-vxworks): New target.\n+\n 2007-04-14  Kazu Hirata  <kazu@codesourcery.com>\n \n \t* config.host: Recognize fido."}, {"sha": "4de74cf203ed468cb5247a1a16559fd9dd75c775", "filename": "libgcc/config.host", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1910440ea6f09731f4c475f8556c101e8944340c/libgcc%2Fconfig.host", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1910440ea6f09731f4c475f8556c101e8944340c/libgcc%2Fconfig.host", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig.host?ref=1910440ea6f09731f4c475f8556c101e8944340c", "patch": "@@ -594,6 +594,8 @@ sparc-*-sysv4*)\n \t;;\n sparc64-*-elf*)\n \t;;\n+sparc-wrs-vxworks)\n+\t;;\n sparc64-*-freebsd*|ultrasparc-*-freebsd*)\n \t;;\n sparc64-*-linux*)\t\t# 64-bit SPARC's running GNU/Linux"}]}