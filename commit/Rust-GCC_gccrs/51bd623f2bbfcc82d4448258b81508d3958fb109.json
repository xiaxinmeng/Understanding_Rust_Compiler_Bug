{"sha": "51bd623f2bbfcc82d4448258b81508d3958fb109", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTFiZDYyM2YyYmJmY2M4MmQ0NDQ4MjU4YjgxNTA4ZDM5NThmYjEwOQ==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1995-02-07T20:18:09Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1995-02-07T20:18:09Z"}, "message": "Correct errors in comments.  Delete all assembler comments.\n\nDelete commented out patterns.  Delete all peepholes but two.\nDelete all define_splits but one.  Delete all `combiner' patterns.\n(mpy): Correct multiply latencies.\n(needs_delay_slot, hit_stack, interrupt_function, in_delay_slot,\ndefine_delay): Correct and/or simplify all reorg related definitions.\n(addsi3_real): Delete.\n(addsi3): Use arith_operand for argument 1.\n(mulhisi3): Use arith_reg_operand not mac_operand.\n(and_ffff, and_ff): Delete.\n(andsi3): Handle constant 255 specially.\n(rot*): Correct and/or simplify all rotate patterns.\n(ashlsi3_k): Delete clobber of T bit.  Output add for 1 bit shift.\n(ashlsi3_n, lshrsi3_n): Delete use of fake_shift.\n(negc): Correct pattern by adding set of T bit.\n(extend*): Delete 'u' and 'U' constraint cases.\n(pop): Separate 'l' and 'x' constraint cases.\n(movsi-1): Better code for move to T bit case.\n(bsr, bsr_value, mac): Delete.\n\nFrom-SVN: r8888", "tree": {"sha": "583d81dd99dfc9572757e9893a1632705821d5f7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/583d81dd99dfc9572757e9893a1632705821d5f7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/51bd623f2bbfcc82d4448258b81508d3958fb109", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51bd623f2bbfcc82d4448258b81508d3958fb109", "html_url": "https://github.com/Rust-GCC/gccrs/commit/51bd623f2bbfcc82d4448258b81508d3958fb109", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51bd623f2bbfcc82d4448258b81508d3958fb109/comments", "author": null, "committer": null, "parents": [{"sha": "c8b3b7d66538467c6a55a8bdbc5efd1311db8721", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c8b3b7d66538467c6a55a8bdbc5efd1311db8721", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c8b3b7d66538467c6a55a8bdbc5efd1311db8721"}], "stats": {"total": 573, "additions": 209, "deletions": 364}, "files": [{"sha": "4b39dad58137ff007bdd96aa3d5bcd4ac0a96e3f", "filename": "gcc/config/sh/sh.md", "status": "modified", "additions": 209, "deletions": 364, "changes": 573, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51bd623f2bbfcc82d4448258b81508d3958fb109/gcc%2Fconfig%2Fsh%2Fsh.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51bd623f2bbfcc82d4448258b81508d3958fb109/gcc%2Fconfig%2Fsh%2Fsh.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.md?ref=51bd623f2bbfcc82d4448258b81508d3958fb109", "patch": "@@ -19,6 +19,14 @@\n ;; the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n \n \n+;; ??? The MAC.W and MAC.L instructions are not supported.  There is no\n+;; way to generate them.\n+\n+;; ??? The BSR instruction is not supported.  It might be possible to\n+;; generate it by keeping track of function sizes (and hence relative\n+;; addresses), and then using it only if the target is earlier in the same\n+;; file, and is within range.  Better would be assembler/linker relaxing,\n+;; but that is much harder.\n \n ;; Special constraints for SH machine description:\n ;;\n@@ -30,8 +38,6 @@\n ;; Special formats used for outputting SH instructions:\n ;;\n ;;   %.  --  print a .s if insn needs delay slot\n-;;   %*  --  print a local label\n-;;   %^  --  increment the local label number\n ;;   %#  --  output a nop if there is nothing to put in the delay slot\n ;;   %R  --  print the lsw arg of a double, \n ;;   %S  --  print the msw arg of a double\n@@ -58,17 +64,15 @@\n (define_attr \"cpu\" \"sh0,sh1,sh2,sh3\"\n   (const (symbol_ref \"sh_cpu\")))\n \n-(define_attr \"interrupt_function\" \"no,yes\"\n-  (const (symbol_ref \"pragma_interrupt\")))\n ;;\n ;; cbranch\tconditional branch instructions\n ;; jump\t\tunconditional jumps\n ;; arith\tordinary arithmetic\n ;; load\t\tfrom memory\n ;; store\tto memory\n ;; move\t\tregister to register\n-;; smpy\t\tsingle precision integer multiply\n-;; dmpy\t\tdouble precision integer multiply\n+;; smpy\t\tword precision integer multiply\n+;; dmpy\t\tlongword or doublelongword precision integer multiply\n ;; return\trts\n ;; pload\tload of pr reg (can't be put into delay slot of rts)\n ;; pcload\tpc relative load of constant value\n@@ -120,40 +124,42 @@\n ;; (define_function_unit {name} {num-units} {n-users} {test}\n ;;                       {ready-delay} {issue-delay} [{conflict-list}])\n \t\t\t\t      \n-(define_function_unit \"memory\" 1 0 (eq_attr \"type\" \"load,pcload\") 2 2)\n-(define_function_unit \"mpy\"    1 0 (eq_attr \"type\" \"smpy\") 7 7)\n-(define_function_unit \"mpy\"    1 0 (eq_attr \"type\" \"dmpy\") 9 9)\n+(define_function_unit \"memory\" 1 0 (eq_attr \"type\" \"load,pcload,pload\") 2 2)\n+(define_function_unit \"mpy\"    1 0 (eq_attr \"type\" \"smpy\") 2 2)\n+(define_function_unit \"mpy\"    1 0 (eq_attr \"type\" \"dmpy\") 3 3)\n \n-(define_attr \"needs_delay_slot\" \"yes,no\"\n-  (cond [(eq_attr \"type\" \"jump\")   (const_string \"yes\")\n-\t (eq_attr \"type\" \"return\") (const_string \"yes\")]\n-\t(const_string \"no\")))\n+; Definitions for filling branch delay slots.\n \n-(define_delay \n+(define_attr \"needs_delay_slot\" \"yes,no\" (const_string \"no\"))\n+\n+(define_attr \"hit_stack\" \"yes,no\" (const_string \"no\"))\n+\n+(define_attr \"interrupt_function\" \"no,yes\"\n+  (const (symbol_ref \"pragma_interrupt\")))\n+\n+(define_attr \"in_delay_slot\" \"yes,no\" \n+  (cond [(eq_attr \"type\" \"cbranch\") (const_string \"no\")\n+\t (eq_attr \"type\" \"pcload\") (const_string \"no\")\n+\t (eq_attr \"needs_delay_slot\" \"yes\") (const_string \"no\")\n+\t (eq_attr \"length\" \"2\") (const_string \"yes\")\n+\t ] (const_string \"no\")))\n+\n+(define_delay\n   (eq_attr \"needs_delay_slot\" \"yes\")\n   [(eq_attr \"in_delay_slot\" \"yes\") (nil) (nil)])\n \n (define_delay \n   (eq_attr \"type\" \"return\")\n   [(and (eq_attr \"in_delay_slot\" \"yes\") \n-\t(ior (eq_attr \"interrupt_function\" \"no\")\n-\t    (eq_attr \"hit_stack\" \"no\"))) (nil) (nil)])\n-\n-(define_attr \"hit_stack\" \"yes,no\" (const_string \"no\"))\n+\t(and (ior (eq_attr \"interrupt_function\" \"no\")\n+\t\t  (eq_attr \"hit_stack\" \"no\"))\n+\t     (ior (eq_attr \"interrupt_function\" \"yes\")\n+\t\t  (eq_attr \"type\" \"!pload\")))) (nil) (nil)])\n \n (define_delay \n   (and (eq_attr \"type\" \"cbranch\") \n        (eq_attr \"cpu\" \"sh2,sh3\"))\n   [(eq_attr \"in_delay_slot\" \"yes\") (nil) (nil)])\n-\n-(define_attr \"in_delay_slot\" \"yes,no\" \n-  (cond [(eq_attr \"type\" \"cbranch\") (const_string \"no\")\n-\t (eq_attr \"type\" \"jump\") (const_string \"no\")\n-\t (eq_attr \"type\" \"pload\") (const_string \"no\")\n-\t (eq_attr \"type\" \"pcload\") (const_string \"no\")\n-\t (eq_attr \"type\" \"return\") (const_string \"no\")\n-\t (eq_attr \"length\" \"2\") (const_string \"yes\")\n-\t ] (const_string \"no\")))\n \f\n ;; -------------------------------------------------------------------------\n ;; SImode signed integer comparisons\n@@ -164,14 +170,26 @@\n \t(eq:SI (reg:SI 18)\n \t       (const_int 1)))]\n   \"\"\n-  \"movt\t%0 !movt1\")\n+  \"movt\t%0\")\n+\n+;; ??? This combiner pattern does not work, because combine does not combine\n+;; instructions that set a hard register when SMALL_REGISTER_CLASSES is\n+;; defined.  Perhaps use a pseudo-reg for the T bit?\n+\n+(define_insn \"\"\n+  [(set (reg:SI 18)\n+\t(eq:SI (and:SI (match_operand:SI 0 \"arith_reg_operand\" \"z,r\")\n+\t\t       (match_operand:SI 1 \"arith_operand\" \"L,r\"))\n+\t       (const_int 0)))]\n+  \"\"\n+  \"tst\t%1,%0\")\n \n (define_insn \"cmpeqsi_t\"\n   [(set (reg:SI 18) (eq:SI (match_operand:SI 0 \"arith_reg_operand\" \"r,z,r\")\n \t\t\t   (match_operand:SI 1 \"arith_operand\" \"N,rI,r\")))]\n   \"\"\n   \"@\n-\ttst\t%0,%0 ! t0\n+\ttst\t%0,%0\n \tcmp/eq\t%1,%0\n \tcmp/eq\t%1,%0\")\n \n@@ -238,21 +256,13 @@\n   [(set_attr \"length\" \"6\")])\n \n \n-(define_insn \"addsi3_real\"\n+(define_insn \"addsi3\"\n   [(set (match_operand:SI 0 \"arith_reg_operand\" \"=r\")\n-\t(plus:SI (match_operand:SI 1 \"arith_reg_operand\" \"%0\")\n+\t(plus:SI (match_operand:SI 1 \"arith_operand\" \"%0\")\n \t\t (match_operand:SI 2 \"arith_operand\" \"rI\")))]\n   \"\"\n   \"add\t%2,%0\"\n   [(set_attr \"type\" \"arith\")])\n-\n-(define_expand \"addsi3\"\n-  [(set (match_operand:SI 0 \"arith_reg_operand\" \"=r\")\n-\t(plus:SI (match_operand:SI 1 \"arith_operand\" \"%0\")\n-\t\t (match_operand:SI 2 \"arith_operand\" \"rI\")))]\n-  \"\"\n-  \"\")\n-\n \f\n ;; -------------------------------------------------------------------------\n ;; Subtraction instructions\n@@ -375,9 +385,9 @@\n (define_expand \"mulhisi3\"\n   [(set (reg:SI 21)\n \t(mult:SI (sign_extend:SI\n-\t\t  (match_operand:HI 1 \"mac_operand\" \"r\"))\n+\t\t  (match_operand:HI 1 \"arith_reg_operand\" \"r\"))\n \t\t (sign_extend:SI\n-\t\t  (match_operand:HI 2 \"mac_operand\" \"r\"))))\n+\t\t  (match_operand:HI 2 \"arith_reg_operand\" \"r\"))))\n    (set (match_operand:SI 0 \"arith_reg_operand\" \"=r\")\n \t(reg:SI 21))]\n   \"\"\n@@ -437,17 +447,25 @@\n \t\t (match_operand:SI 1 \"arith_reg_operand\" \"r\")))]\n   \"TARGET_SH2\"\n   \"mul.l\t%1,%0\"\n-  [(set_attr \"type\" \"smpy\")])\n+  [(set_attr \"type\" \"dmpy\")])\n \n (define_expand \"mulsi3\"\n   [(set (reg:SI 21)\n \t(mult:SI  (match_operand:SI 1 \"arith_reg_operand\" \"r\")\n \t\t  (match_operand:SI 2 \"arith_reg_operand\" \"r\")))\n    (set (match_operand:SI 0 \"arith_reg_operand\" \"=r\")\n \t(reg:SI 21))]\n-  \"TARGET_SH2\"\n-  \"\")\n-\n+  \"\"\n+  \"\n+{\n+  if (!TARGET_SH2)\n+    {\n+      FAIL;\n+      /* ??? Does this give worse or better code?  */\n+      emit_insn (gen_mulsi3_call (operands[0], operands[1], operands[2]));\n+      DONE;\n+    }\n+}\")\n \n (define_insn \"\"\n   [(set (reg:DI 20)\n@@ -488,22 +506,6 @@\n ;; Logical operations\n ;; -------------------------------------------------------------------------\n \n-(define_insn \"and_ffff\"\n- [(set (match_operand:SI 0 \"arith_reg_operand\" \"=r\")\n-       (and:SI (match_operand:SI 1 \"arith_reg_operand\" \"r\")\n-\t       (const_int 65535)))]\n- \"\"\n- \"extu.w\t%1,%0\"\n- [(set_attr \"type\" \"arith\")])\n-\n-(define_insn \"and_ff\"\n- [(set (match_operand:SI 0 \"arith_reg_operand\" \"=r\")\n-       (and:SI (match_operand:SI 1 \"arith_reg_operand\" \"r\")\n-\t       (const_int 255)))]\n- \"\"\n- \"extu.b\t%1,%0\"\n- [(set_attr \"type\" \"arith\")])\n-   \n (define_insn \"\"\n   [(set (match_operand:SI 0 \"arith_reg_operand\" \"=r,z\")\n \t(and:SI (match_operand:SI 1 \"arith_reg_operand\" \"%0,0\")\n@@ -512,12 +514,23 @@\n   \"and\t%2,%0\"\n   [(set_attr \"type\" \"arith\")])\n \n+;; If the constant is 255, then emit a extu.b instruction instead of an\n+;; and, since that will give better code.\n+\n (define_expand \"andsi3\"\n   [(set (match_operand:SI 0 \"arith_reg_operand\" \"\")\n \t(and:SI (match_operand:SI 1 \"arith_reg_operand\" \"\")\n \t\t(match_operand:SI 2 \"logical_operand\" \"\")))]\n   \"\"\n-  \"\")\n+  \"\n+{\n+  if (GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) == 255)\n+    {\n+      emit_insn (gen_zero_extendqisi2 (operands[0],\n+\t\t\t\t       gen_lowpart (QImode, operands[1])));\n+      DONE;\n+    }\n+}\")\n \n (define_insn \"iorsi3\"\n   [(set (match_operand:SI 0 \"arith_reg_operand\" \"=r,z\")\n@@ -539,38 +552,70 @@\n ;; Shifts and rotates\n ;; -------------------------------------------------------------------------\n \n-(define_insn \"rotlsi3_k\"\n+(define_insn \"rotlsi3_1\"\n   [(set (match_operand:SI 0 \"arith_reg_operand\" \"=r\")\n \t(rotate:SI (match_operand:SI 1 \"arith_reg_operand\" \"0\")\n \t\t   (const_int 1)))\n    (clobber (reg:SI 18))]\n   \"\"\n   \"rotl\t%0\")\n \n-(define_expand \"rotlsi3\"\n-  [(parallel[(set (match_operand:SI 0 \"arith_reg_operand\" \"\")\n-\t\t  (rotate:SI (match_operand:SI 1 \"arith_reg_operand\" \"\")\n-\t\t\t     (match_operand:SI 2 \"immediate_operand\" \"\")))\n-\t     (clobber (reg:SI 18))])]\n-  \"\"\n-  \"{ if (GET_CODE(operands[2]) != CONST_INT || INTVAL(operands[2]) != 1) FAIL;}\")\n-\n-(define_insn \"rotrsi3_k\"\n+(define_insn \"rotlsi3_31\"\n   [(set (match_operand:SI 0 \"arith_reg_operand\" \"=r\")\n-\t(rotatert:SI (match_operand:SI 1 \"arith_reg_operand\" \"0\")\n-\t\t     (const_int 1)))\n+\t(rotate:SI (match_operand:SI 1 \"arith_reg_operand\" \"0\")\n+\t\t   (const_int 31)))\n    (clobber (reg:SI 18))]\n   \"\"\n   \"rotr\t%0\")\n \n-(define_expand \"rotrsi3\"\n-  [(parallel[(set (match_operand:SI 0 \"arith_reg_operand\" \"\")\n-\t\t   (rotatert:SI (match_operand:SI 1 \"arith_reg_operand\" \"\")\n-\t\t\t\t(match_operand:SI 2 \"immediate_operand\" \"\")))\n-\t      (clobber (reg:SI 18))])]\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"arith_reg_operand\" \"=r\")\n+\t(rotate:SI (match_operand:SI 1 \"arith_reg_operand\" \"r\")\n+\t\t   (const_int 16)))]\n   \"\"\n-  \"{ if (GET_CODE(operands[2]) != CONST_INT || INTVAL(operands[2]) != 1) FAIL;}\")\n+  \"swap.w\t%1,%0\")\n \n+(define_expand \"rotlsi3\"\n+  [(set (match_operand:SI 0 \"arith_reg_operand\" \"\")\n+\t(rotate:SI (match_operand:SI 1 \"arith_reg_operand\" \"\")\n+\t\t   (match_operand:SI 2 \"immediate_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  if (GET_CODE (operands[2]) != CONST_INT)\n+    FAIL;\n+\n+  if (INTVAL (operands[2]) == 1)\n+    {\n+      emit_insn (gen_rotlsi3_1 (operands[0], operands[1]));\n+      DONE;\n+    }\n+  else if (INTVAL (operands[2]) == 31)\n+    {\n+      emit_insn (gen_rotlsi3_31 (operands[0], operands[1]));\n+      DONE;\n+    }\n+  else if (INTVAL (operands[2]) != 16)\n+    FAIL;\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"arith_reg_operand\" \"=r\")\n+\t(rotate:HI (match_operand:HI 1 \"arith_reg_operand\" \"r\")\n+\t\t   (const_int 8)))]\n+  \"\"\n+  \"swap.b\t%1,%0\")\n+\n+(define_expand \"rotlhi3\"\n+  [(set (match_operand:HI 0 \"arith_reg_operand\" \"\")\n+\t(rotate:HI (match_operand:HI 1 \"arith_reg_operand\" \"\")\n+\t\t   (match_operand:HI 2 \"immediate_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  if (GET_CODE (operands[2]) != CONST_INT || INTVAL (operands[2]) != 8)\n+    FAIL;\n+}\")\n \n ;;\n ;; shift left\n@@ -579,27 +624,26 @@\n (define_insn \"ashlsi3_k\"\n   [(set (match_operand:SI 0 \"arith_reg_operand\" \"=r,r\")\n \t(ashift:SI (match_operand:SI 1 \"arith_reg_operand\" \"0,0\")\n-\t\t   (match_operand:SI 2 \"immediate_operand\" \"M,K\")))\n-   (clobber (reg:SI 18))]\n+\t\t   (match_operand:SI 2 \"immediate_operand\" \"M,K\")))]\n   \"CONST_OK_FOR_K (INTVAL (operands[2]))\"\n   \"@\n-\tshll\t%0\n+\tadd\t%0,%0\n \tshll%O2\t%0\")\n \n-; seperate pattern for shifts by any N.  Look at pnum_clobbers\n-; to see if this is being recognised inside combine.  If so, dont\n-; match, since combine will try and merge shifts, which will break\n-; scheduling\n+; ??? seperate pattern for shifts by any N.  Turn this on to recognize shift\n+; insns which aren't supported in the hardware.  This will allow the combiner\n+; to notice more patterns, but the down side is that the asm outputter will\n+; have to emit several instructions for each shift which isn't possible in\n+; the hardware, this makes scheduling perform badly.\n \n (define_insn \"ashlsi3_n\"\n   [(set (match_operand:SI 0 \"arith_reg_operand\" \"=r\")\n \t(ashift:SI (match_operand:SI 1 \"arith_reg_operand\" \"0\")\n \t\t   (match_operand:SI 2 \"immediate_operand\" \"n\")))\n    (clobber (reg:SI 18))]\n-  \"fake_shift()\"\n+  \"0\"\n   \"*return output_shift(\\\"shll\\\", operands[0], operands[2], ASHIFT);\"\n   [(set_attr \"length\" \"12\")\n-   (set_attr \"in_delay_slot\" \"no\")\n    (set_attr \"type\" \"arith\")])\n \n (define_expand \"ashlsi3\"\n@@ -623,21 +667,6 @@\n   \"shar\t%0\"\n   [(set_attr \"type\" \"arith\")])\n \n-\n-; an arithmetic shift right by 16 is better as a logical shift and a \n-; sign extend\n-\n-;(define_split \n-;  [(set (match_operand:SI 0 \"arith_reg_operand\" \"=r\")\n-;\t(ashiftrt:SI (match_operand:SI 1 \"arith_reg_operand\" \"0\")\n-;\t\t     (const_int 16)))\n-;   (clobber (reg:SI 18))]\n-;  \"\"\n-;  [(set (match_dup 3) (match_dup 0))\n-;    (set (match_dup 3) (lshiftrt:SI (match_dup 3) (const_int 16)))\n-;    (set (match_dup 0) (sign_extend:SI (subreg:HI (match_dup 3) 0)))]\n-;  \"operands[3] = gen_reg_rtx (SImode);\")\n-\n (define_insn \"ashrsi2_16\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n         (ashiftrt:SI (match_operand:SI 1 \"register_operand\" \"r\")\n@@ -679,7 +708,6 @@\n   \"\"\n   \"jsr\t@%1%#\"\n   [(set_attr \"type\" \"sfunc\")\n-   (set_attr \"in_delay_slot\" \"no\")\n    (set_attr \"needs_delay_slot\" \"yes\")])\n \n (define_expand \"ashrsi3\"\n@@ -704,17 +732,16 @@\n \tshlr\t%0\n \tshlr%O2\t%0\")\n \n-; seperate pattern for shifts by any N. \n+; ??? seperate pattern for shifts by any N.  See ashlsi3_n.\n \n (define_insn \"lshrsi3_n\"\n   [(set (match_operand:SI 0 \"arith_reg_operand\" \"=r\")\n \t(lshiftrt:SI (match_operand:SI 1 \"arith_reg_operand\" \"0\")\n \t\t     (match_operand:SI 2 \"immediate_operand\" \"n\")))\n    (clobber (reg:SI 18))]\n-  \"fake_shift()\"\n+  \"0\"\n   \"* return output_shift (\\\"shlr\\\", operands[0], operands[2], LSHIFTRT);\"\n   [(set_attr \"length\" \"12\")\n-   (set_attr \"in_delay_slot\" \"no\")\n    (set_attr \"type\" \"arith\")])\n \n (define_expand \"lshrsi3\"\n@@ -788,7 +815,11 @@\n \n (define_insn \"negc\"\n   [(set (match_operand:SI 0 \"arith_reg_operand\" \"=r\")\n-\t(neg:SI (plus:SI (reg:SI 18) (match_operand:SI 1 \"arith_reg_operand\" \"r\"))))]\n+\t(neg:SI (plus:SI (reg:SI 18)\n+\t\t\t (match_operand:SI 1 \"arith_reg_operand\" \"r\"))))\n+   (set (reg:SI 18)\n+\t(ne:SI (plus:SI (reg:SI 18) (match_dup 1))\n+\t       (const_int 0)))]\n   \"\"\n   \"negc\t%1,%0\"\n   [(set_attr \"type\" \"arith\")])\n@@ -863,38 +894,35 @@\n \t(sign_extend:DI (match_operand:SI 1 \"arith_reg_operand\" \"r\")))\n    (clobber (reg:SI 18))]\n   \"\"\n-  \"mov\t%1,%S0\\;mov\t%1,%R0\\;shll\t%S0\\;subc\t%S0,%S0 ! a sidi2\"\n+  \"mov\t%1,%S0\\;mov\t%1,%R0\\;shll\t%S0\\;subc\t%S0,%S0\"\n   [(set_attr \"length\" \"8\")]) \n \n (define_insn \"extendhisi2\"\n-  [(set (match_operand:SI 0 \"arith_reg_operand\" \"=r,z,r\")\n-\t(sign_extend:SI (match_operand:HI 1 \"general_movsrc_operand\" \"r,u,m\")))]\n+  [(set (match_operand:SI 0 \"arith_reg_operand\" \"=r,r\")\n+\t(sign_extend:SI (match_operand:HI 1 \"general_movsrc_operand\" \"r,m\")))]\n   \"\"\n   \"@\n \texts.w\t%1,%0\n-   \tmov.w\t%1,%0\n    \tmov.w\t%1,%0\"\n-  [(set_attr \"type\" \"arith,load,load\")])\n+  [(set_attr \"type\" \"arith,load\")])\n \n (define_insn \"extendqisi2\"\n-  [(set (match_operand:SI 0 \"arith_reg_operand\" \"=r,z,r\")\n-\t(sign_extend:SI (match_operand:QI 1 \"general_movsrc_operand\" \"r,U,m\")))]\n+  [(set (match_operand:SI 0 \"arith_reg_operand\" \"=r,r\")\n+\t(sign_extend:SI (match_operand:QI 1 \"general_movsrc_operand\" \"r,m\")))]\n   \"\"\n   \"@\n \texts.b\t%1,%0\n-\tmov.b\t%1,%0 !p9\n-\tmov.b\t%1,%0 !p8\"\n-  [(set_attr \"type\" \"arith,load,load\")])\n+\tmov.b\t%1,%0\"\n+  [(set_attr \"type\" \"arith,load\")])\n \n (define_insn \"extendqihi2\"\n-  [(set (match_operand:HI 0 \"arith_reg_operand\" \"=r,z,r\")\n-\t(sign_extend:HI (match_operand:QI 1 \"general_movsrc_operand\" \"r,U,m\")))]\n+  [(set (match_operand:HI 0 \"arith_reg_operand\" \"=r,r\")\n+\t(sign_extend:HI (match_operand:QI 1 \"general_movsrc_operand\" \"r,m\")))]\n   \"\"\n   \"@\n \texts.b\t%1,%0\n-\tmov.b\t%1,%0  !p7\n-\tmov.b\t%1,%0 ! p6\"\n-  [(set_attr \"type\" \"arith,load,load\")])\n+\tmov.b\t%1,%0\"\n+  [(set_attr \"type\" \"arith,load\")])\n \n \f\n ;; -------------------------------------------------------------------------\n@@ -909,18 +937,19 @@\n   \"\"\n   \"@\n \tmov.l\t%0,@-r15\n-\tsts.l\t%0,@-r15 ! push\"\n+\tsts.l\t%0,@-r15\"\n   [(set_attr \"type\" \"store\")\n    (set_attr \"hit_stack\" \"yes\")])\n \n (define_insn \"pop\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r,lx\")\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,l,x\")\n \t(mem:SI (post_inc:SI (reg:SI 15))))]\n   \"\"\n   \"@\n \tmov.l\t@r15+,%0\n+\tlds.l\t@r15+,%0\n \tlds.l\t@r15+,%0\"\n-  [(set_attr \"type\" \"load,pload\")\n+  [(set_attr \"type\" \"load,pload,load\")\n    (set_attr \"hit_stack\" \"yes\")])\n \n (define_insn \"\"\n@@ -968,9 +997,10 @@\n \tsts.l\t%1,%0\n \tlds\t%1,%0\n \tlds.l\t%1,%0\n-\ttst\t%1,%1\\;bt\tT%*\\;bra\tF%*\\;sett\\;T%*:clrt\\;F%*:%^\n-\tfake %1,%0\"\n-  [(set_attr \"type\" \"pcload,move,load,move,store,store,move,load,move,move,move\")])\n+\ttst\t%1,%1\\;rotcl\t%1\\;xor\t#1,%1\\;rotcr\t%1\n+\tfake\t%1,%0\"\n+  [(set_attr \"type\" \"pcload,move,load,move,store,store,move,load,move,move,move\")\n+   (set_attr \"length\" \"*,*,*,*,*,*,*,*,*,8,*\")])\n \t\t\t  \n (define_expand \"movsi\"\n   [(set (match_operand:SI 0 \"general_movdst_operand\" \"\")\n@@ -1001,18 +1031,18 @@\n   \"if (prepare_move_operands(operands, QImode)) DONE; \")\n \n (define_insn \"movhi_i\"\n-  [(set (match_operand:HI 0 \"general_movdst_operand\" \"=r,r,r,r,<m,r,r,l\")\n-\t(match_operand:HI 1 \"general_movsrc_operand\" \"Q,rI,>m,t,r,i,l,r\"))]\n+  [(set (match_operand:HI 0 \"general_movdst_operand\" \"=r,r,r,r,<m,r,l,r\")\n+\t(match_operand:HI 1 \"general_movsrc_operand\" \"Q,rI,>m,t,r,l,r,i\"))]\n   \"\"\n   \"@\n \tmov.w\t%1,%0\n \tmov\t%1,%0\n \tmov.w\t%1,%0\n \tmovt\t%0\n \tmov.w\t%1,%0\n-\tfake %1,%0\n \tsts\t%1,%0\n-\tlds\t%1,%0\"\n+\tlds\t%1,%0\n+\tfake\t%1,%0\"\n   [(set_attr \"type\" \"pcload,move,load,move,store,move,move,move\")])\n \n (define_expand \"movhi\"\n@@ -1153,13 +1183,16 @@\n    \"mov.l\t%1,%0\"\n   [(set_attr \"type\" \"store\")])\n \t\t\n+;; ??? Why do we have unsupported auto-inc in the dest, and auto-dec in the\n+;; source? And why is the supported auto-dec dest and auto-inc source missing?\n+\n (define_insn \"movsf_i\"\n   [(set (match_operand:SF 0 \"general_movdst_operand\" \"=>,r,r,r,r,m,l,r\")\n \t(match_operand:SF 1 \"general_movsrc_operand\"  \"r,<,r,I,m,r,r,l\"))]\n   \"\"\n   \"@\n-        mov.l\t%1,@%N0\\;add\t#4,%N0 !bad\n-        add\t#-4,%1\\;mov.l\t@%N1,%0 !bad\n+        mov.l\t%1,@%N0\\;add\t#4,%N0\n+        add\t#-4,%1\\;mov.l\t@%N1,%0\n \tmov\t%1,%0\n \tmov\t%1,%0\n \tmov.l\t%1,%0\n@@ -1343,33 +1376,13 @@\n    (set_attr \"needs_delay_slot\" \"yes\")])\n \n \n-(define_insn \"bsr\"\n-  [(call (mem:SI (match_operand 0 \"bsr_operand\" \"i\"))\n-\t (match_operand 1 \"\" \"\"))\n-   (clobber (reg:SI 17))]\n-  \"TARGET_BSR\"\n-  \"bsr\t%O0%#\"\n-  [(set_attr \"needs_delay_slot\" \"yes\")\n-   (set_attr \"in_delay_slot\" \"no\")])\n-\n (define_insn \"calli\"\n   [(call (mem:SI (match_operand:SI 0 \"arith_reg_operand\" \"r\"))\n \t (match_operand 1 \"\" \"\"))\n    (clobber (reg:SI 17))]\n   \"\"\n   \"jsr\t@%0%#\"\n-  [(set_attr \"needs_delay_slot\" \"yes\")\n-   (set_attr \"in_delay_slot\" \"no\")])\n-\n-(define_insn \"bsr_value\"\n-  [(set (match_operand 0 \"\" \"=rf\")\n-\t(call (mem:SI (match_operand 1 \"bsr_operand\" \"i\"))\n-\t      (match_operand 2 \"\" \"\")))\n-   (clobber (reg:SI 17))]\n-  \"TARGET_BSR\"\n-  \"bsr\t%O1%#\"\n-  [(set_attr \"needs_delay_slot\" \"yes\")\n-   (set_attr \"in_delay_slot\" \"no\")])\n+  [(set_attr \"needs_delay_slot\" \"yes\")])\n \n (define_insn \"call_valuei\"\n   [(set (match_operand 0 \"\" \"=rf\")\n@@ -1378,8 +1391,7 @@\n    (clobber (reg:SI 17))]\n   \"\"\n   \"jsr\t@%1%#\"\n-  [(set_attr \"needs_delay_slot\" \"yes\")\n-   (set_attr \"in_delay_slot\" \"no\")])\n+  [(set_attr \"needs_delay_slot\" \"yes\")])\n \n (define_expand \"call\"\n   [(parallel[(call (match_operand 0 \"arith_reg_operand\" \"o\")\n@@ -1401,46 +1413,38 @@\n \t(match_operand:SI 0 \"arith_reg_operand\" \"r\"))]\n   \"\"\n   \"jmp\t@%0%#\"\n-  [(set_attr \"needs_delay_slot\" \"yes\")\n-   (set_attr \"in_delay_slot\" \"no\")])\n-\n+  [(set_attr \"needs_delay_slot\" \"yes\")])\n \f\n ;; ------------------------------------------------------------------------\n ;; Misc insns\n ;; ------------------------------------------------------------------------\n \n-;(define_insn \"dect\"\n-;  [(parallel[\n-;\t     (set (match_dup 0)\n-;\t\t  (plus:SI (match_dup 0)\n-;\t\t\t   (const_int -1)))\n-;\n-;\t     (set (reg:SI 18)\n-;\t\t  (eq:SI (match_operand:SI 0 \"register_operand\" \"=r\")\n-;\t\t\t (const_int 0)))])]\n-;  \"TARGET_SH2\"\n-;  \"dt\t%0\")\n+;; ??? This combiner pattern does not work, because combine does not combine\n+;; instructions that set a hard register when SMALL_REGISTER_CLASSES is\n+;; defined.  Perhaps use a pseudo-reg for the T bit?\n+\n+(define_insn \"dect\"\n+  [(parallel[\n+\t     (set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t\t  (plus:SI (match_dup 0)\n+\t\t\t   (const_int -1)))\n+\t     (set (reg:SI 18)\n+\t\t  (eq:SI (plus:SI (match_dup 0) (const_int -1))\n+\t\t\t (const_int 0)))])]\n+  \"TARGET_SH2\"\n+  \"dt\t%0\")\n \n (define_insn \"nop\"\n   [(const_int 0)]\n   \"\"\n-  \"or\tr0,r0\")\n-\n-; experimental use of auto inc and dec made these...\n-; can be deleted\n-\n-(define_insn \"fake\"\n-  [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n-\t(mem:QI (pre_dec:SI (match_operand:SI 1 \"register_operand\" \"r\"))))]\n-  \"\"\n-  \"add\t#-1,%1\\;mov.b\t@%1,%0 !bad\"\n-  [(set_attr \"length\" \"4\")])\n+  \"nop\")\n \n ;; Load address of a label. This is only generated by the casesi expand.\n+;; This must use unspec, because this only works immediately before a casesi.\n \n (define_insn \"mova\"\n   [(set (reg:SI 0) \n-\t(label_ref (match_operand 0 \"\" \"\")))]\n+\t(unspec [(label_ref (match_operand 0 \"\" \"\"))] 1))]\n   \"\"\n   \"mova\t%O0,r0\"\n   [(set_attr \"in_delay_slot\" \"no\")])\n@@ -1453,6 +1457,8 @@\n ;; operand 3 is CODE_LABEL for the table;\n ;; operand 4 is the CODE_LABEL to go to if index out of range.\n \n+;; ??? There should be a barrier after the jump at the end.\n+\n (define_expand \"casesi\"\n   [(set (match_dup 5) (match_operand:SI 0 \"arith_reg_operand\" \"\"))\n    (set (match_dup 5) (minus:SI (match_dup 5)\n@@ -1466,9 +1472,8 @@\n \t\t      (label_ref (match_operand 4 \"\" \"\"))\n \t\t      (pc)))\n    (set (match_dup 6) (match_dup 5))\n-   (parallel[(set (match_dup 6) (ashift:SI (match_dup 6) (match_dup 7)))\n-\t\t(clobber (reg:SI 18))])\n-   (set (reg:SI 0) (label_ref (match_operand 3 \"\" \"\")))\n+   (set (match_dup 6) (ashift:SI (match_dup 6) (match_dup 7)))\n+   (set (reg:SI 0) (unspec [(label_ref (match_operand 3 \"\" \"\"))] 1))\n    (parallel[(set (reg:SI 0) (plus:SI (reg:SI 0)\n \t\t\t\t      (mem:HI (plus:SI (reg:SI 0)\n \t\t\t\t\t\t       (match_dup 6)))))\n@@ -1497,16 +1502,14 @@\n \t\treturn \\\"mov.l\t@(r0,%0),%0\\;add\t%0,r0\\\";\n \telse\n \t   \treturn \\\"mov.w\t@(r0,%0),%0\\;add\t%0,r0\\\";\"\n-  [(set_attr \"needs_delay_slot\" \"no\")\n-   (set_attr \"in_delay_slot\" \"no\")\n-   (set_attr \"length\" \"4\")])\n-\n+  [(set_attr \"length\" \"4\")])\n \n (define_insn \"return\"\n   [(return)]\n   \"reload_completed\"\n   \"%@\t%#\"\n-  [(set_attr \"type\" \"return\")])\n+  [(set_attr \"type\" \"return\")\n+   (set_attr \"needs_delay_slot\" \"yes\")])\n \n (define_expand \"prologue\"\n   [(const_int 0)]\n@@ -1533,7 +1536,7 @@\n   [(set (match_operand:SI 0 \"arith_reg_operand\" \"=r\")\n \t(eq:SI (reg:SI 18) (const_int 1)))]\n   \"\"\n-  \"movt\t%0 ! \")\n+  \"movt\t%0\")\n \n (define_expand \"seq\"\n   [(set (match_operand:SI 0 \"arith_reg_operand\" \"\")\n@@ -1596,116 +1599,6 @@\n   \"\"\n   \"operands[1] = prepare_scc_operands (EQ);\")\n \n-;; -------------------------------------------------------------------------\n-;; Peepholes\n-;; -------------------------------------------------------------------------\n-\n-\n-(define_peephole \n-  [(set (match_operand:QI 0 \"arith_reg_operand\" \"\")\n-\t(mem:QI (match_operand:SI 1 \"arith_reg_operand\" \"\")))\n-   (set (match_dup 1) (plus:SI (match_dup 1) (const_int 1)))]\n-  \"REGNO (operands[1]) != REGNO (operands[0])\"\n-  \"mov.b\t@%1+,%0\")\n-\n-(define_peephole \n-  [(set (match_operand:HI 0 \"arith_reg_operand\" \"\")\n-\t(mem:HI (match_operand:SI 1 \"arith_reg_operand\" \"\")))\n-   (set (match_dup 1) (plus:SI (match_dup 1) (const_int 2)))]\n-  \"REGNO (operands[1]) != REGNO (operands[0])\"\n-  \"mov.w\t@%1+,%0\")\n-\n-(define_peephole \n-  [(set (match_operand:SI 0 \"arith_reg_operand\" \"\")\n-\t(mem:SI (match_operand:SI 1 \"arith_reg_operand\" \"\")))\n-   (set (match_dup 1) (plus:SI (match_dup 1) (const_int 4)))]\n-  \"REGNO (operands[1]) != REGNO (operands[0])\"\n-  \"mov.l\t@%1+,%0\")\n-\n-(define_peephole\n-  [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n-\t(match_operand:QI 1 \"memory_operand\" \"g\"))\n-   (set (match_operand:SI 2 \"register_operand\" \"=r\")\n-\t(sign_extend:SI (match_dup 0)))]\n-  \"REGNO (operands[0]) == REGNO (operands[2])\"\n-  \"mov.b\t%1,%0 !p 5\")\n-\n-(define_peephole \n-  [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n-\t(match_operand:QI 1 \"general_movsrc_operand\" \"g\"))\n-   (set (match_operand:SI 2 \"register_operand\" \"=r\")\n-\t(sign_extend:SI (match_dup 0)))]\n-  \"REGNO (operands[0]) != REGNO (operands[2]) \n-   && 0 && dead_or_set_p (insn, operands[0])\"\n-  \"mov.b\t%1,%2 ! p4\")\n-\n-  \n-;; -------------------------------------------------------------------------\n-;; Peepholes\n-;; -------------------------------------------------------------------------\n-\n-(define_peephole \n-  [(set (reg:SI 0) (label_ref (match_operand 0 \"\" \"\")))\n-   (set (match_operand:SI 1 \"register_operand\" \"=r\")\n-\t(reg:SI 0))\n-   (set (reg:SI 0) (label_ref (match_dup 0)))\n-   (set (match_operand:SI 2 \"register_operand\" \"=r\")\n-\t(reg:SI 0))]\n-   \"\"\n-   \"mova\t%O0,r0\\;mov\tr0,%1\\;mov\tr0,%2\")\n-\n-;; -------------------------------------------------------------------------\n-;; Combine patterns\n-;; -------------------------------------------------------------------------\n-\n-(define_insn \"\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(plus:SI (match_operand:HI 1 \"register_operand\" \"%0\")\n-\t\t (match_operand:SI 2 \"register_operand\" \"r\")))]\n-  \"\"\n-  \"add\t%2,%0 ! why\")\n-\n-(define_insn \"addc_2\"\n-  [(set (match_operand:SI 0 \"arith_reg_operand\" \"=&r\")\n-\t(plus:SI (reg:SI 18)\n-\t\t (match_operand:SI 1 \"arith_reg_operand\" \"r\")))\n-   (clobber (reg:SI 18))]\n-  \"\"\n-  \"mov\t#0,%0\\;addc\t%1,%0 ! addc1\"\n-  [(set_attr \"length\" \"4\")])\n-\n-(define_insn \"combine_1\"\n-  [(set (match_operand:SI 0 \"arith_reg_operand\" \"=r\")\n-\t(sign_extend:SI (mem:QI (match_operand:SI 1 \"arith_reg_operand\" \"r\"))))]\n-  \"\"\n-  \"mov.b\t@%1,%0 ! why\"\n-  [(set_attr \"type\" \"load\")])\n-  \n-(define_insn \"combine_2\"\n-  [(set (reg:SI 18)\n-\t(eq:SI (and:SI (match_operand:SI 0 \"arith_reg_operand\" \"z,r\")\n-\t\t    (match_operand:SI 1 \"arith_operand\" \"L,r\"))\n-\t    (const_int 0)))]\n-  \"\"\n-  \"tst\t%1,%0 !t2c\")\n-\n-(define_split\n-  [(set (pc) \n-\t(if_then_else\n-\t (match_operator 2 \"equality_operator\" [(match_operand:SI 0 \"arith_reg_operand\" \"r\")\n-\t\t\t\t\t\t(const_int 0)])\n-\t (label_ref (match_operand 1 \"\" \"\"))\n-\t (pc)))\n-   (clobber (reg:SI 18))]\n-  \"\"\n-  [(set (reg:SI 18) (eq:SI (and:SI (match_dup 0) (match_dup 0))\n-\t\t\t(const_int 0)))\n-   (set (pc)\n-\t(if_then_else (match_op_dup 2 [(reg:SI 18) (const_int 1)])\n-\t\t      (label_ref (match_dup 1))\n-\t\t      (pc)))]\n-  \"\")\n-\n ;; -------------------------------------------------------------------------\n ;; Instructions to cope with inline literal tables\n ;; -------------------------------------------------------------------------\n@@ -1775,61 +1668,10 @@\n   \"* return output_jump_label_table ();\"\n   [(set_attr \"in_delay_slot\" \"no\")])\n \n-\n-;(define_split \n-;  [(set (subreg:SI (match_operand:QI 0 \"register_operand\" \"=r\") 0)\n-;\t(plus:SI (subreg:SI (match_operand:QI 1 \"general_operand\" \"g\") 0)\n-;\t\t (subreg:SI (match_operand:QI 2 \"general_operand\" \"g\") 0)))]\n-;  \"\"\n-;  [(set (match_dup 3) (plus:SI (match_dup 1) (match_dup 2)))\n-;   (set (match_dup 1) (subreg:SI (match_dup 3) 0))]\n-;  \"operands[3] = gen_reg_rtx(SImode);\")\n-\n-\n-; byte arithmetic involving constants which need to be sign extended can be \n-; fixed up...\n-\n-\n-(define_split \n-  [(set (subreg:SI (match_operand:QI 0 \"register_operand\" \"=r\") 0)\n-\t(plus:SI (subreg:SI (match_operand:QI 1 \"register_operand\" \"0\") 0)\n-\t\t (subreg:SI (match_operand 2 \"immediate_operand\" \"n\") 0)))]\n-  \"\"\n-  [(set (match_dup 4) (plus:SI (match_dup 2) (match_dup 3)))\n-   (set (match_dup 0) (and:SI (match_dup 0) (const_int 255)))]\n-  \"{ int i = INTVAL(operands[2]) & 0xff;\n-   if (i > 127) i = i - 256;\n-   operands[3] = GEN_INT(i); \n-   operands[4] = gen_reg_rtx(SImode);} \")\n-\n-\n-;; these instructions don't really exist - they are needed\n-;; before machine_dependent_reorg\n-\n-(define_insn \"movsi_k\"\n- [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-       (match_operand:SI 1 \"immediate_operand\" \"\"))]\n-  \"\"\n-  \"! this is a fake\")\n-\n-\n-(define_insn \"movhi_k\"\n- [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n-       (match_operand:HI 1 \"immediate_operand\" \"\"))]\n-  \"\"\n-  \"! this is a fake\")\n-\n-(define_insn \"movdi_k\"\n- [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-       (match_operand:DI 1 \"immediate_operand\" \"\"))]\n-  \"\"\n-  \"! this is a fake\")\n-\n ;; -------------------------------------------------------------------------\n ;; Misc\n ;; -------------------------------------------------------------------------\n \n-\n ;; String/block move insn.  \n \n (define_expand \"movstrsi\"\n@@ -1877,18 +1719,21 @@\n   [(set_attr \"type\" \"sfunc\")\n    (set_attr \"needs_delay_slot\" \"yes\")])\n \n-(define_insn \"mac\"\n-  [(set (reg:SI 21)\n-\t(mult:SI (sign_extend:SI (mem:HI (post_inc:SI \n-\t\t\t\t\t  (match_operand:SI 0 \"arith_reg_operand\" \"r\"))))\n-\t\t (sign_extend:SI (mem:HI (post_inc:SI\n-\t\t\t\t\t  (match_operand:SI 1 \"arith_reg_operand\" \"r\"))))))]\n-  \"\"\n-  \"mac.w\t@%0+,@%1+\")\n+;; -------------------------------------------------------------------------\n+;; Peepholes\n+;; -------------------------------------------------------------------------\n \n+;; This matches cases where a stack pointer increment at the start of the\n+;; epilogue combines with a stack slot read loading the return value.\n \n-\t\t\t\n+(define_peephole \n+  [(set (match_operand:SI 0 \"arith_reg_operand\" \"\")\n+\t(mem:SI (match_operand:SI 1 \"arith_reg_operand\" \"\")))\n+   (set (match_dup 1) (plus:SI (match_dup 1) (const_int 4)))]\n+  \"REGNO (operands[1]) != REGNO (operands[0])\"\n+  \"mov.l\t@%1+,%0\")\n \n+;; See the comment on the dt combiner pattern above.\n \n (define_peephole \n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")"}]}