{"sha": "4381f7c29941a637a6fdce1b2f8a1cb9df586b71", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDM4MWY3YzI5OTQxYTYzN2E2ZmRjZTFiMmY4YTFjYjlkZjU4NmI3MQ==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@hxi.com", "date": "2000-08-29T21:14:57Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2000-08-29T21:14:57Z"}, "message": "reload.c: Fix formatting.\n\n\n        * reload.c: Fix formatting.\n\n        * stmt.c: Fix formatting.\n\nFrom-SVN: r36051", "tree": {"sha": "edb89f8fae76e053d32b72e77396593aa0965523", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/edb89f8fae76e053d32b72e77396593aa0965523"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4381f7c29941a637a6fdce1b2f8a1cb9df586b71", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4381f7c29941a637a6fdce1b2f8a1cb9df586b71", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4381f7c29941a637a6fdce1b2f8a1cb9df586b71", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4381f7c29941a637a6fdce1b2f8a1cb9df586b71/comments", "author": null, "committer": null, "parents": [{"sha": "9218435e8509897c139a18c5e3b974cc8ec0cbee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9218435e8509897c139a18c5e3b974cc8ec0cbee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9218435e8509897c139a18c5e3b974cc8ec0cbee"}], "stats": {"total": 289, "additions": 143, "deletions": 146}, "files": [{"sha": "f0d1b058f57cd93cccffabe9bcabf4af1ee0240c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4381f7c29941a637a6fdce1b2f8a1cb9df586b71/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4381f7c29941a637a6fdce1b2f8a1cb9df586b71/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4381f7c29941a637a6fdce1b2f8a1cb9df586b71", "patch": "@@ -1,5 +1,9 @@\n 2000-08-29  Kazu Hirata  <kazu@hxi.com>\n \n+\t* reload.c: Fix formatting.\n+\n+\t* stmt.c: Fix formatting.\n+\n \t* gcc.c: Fix formatting.\n \n 2000-08-29  Zack Weinberg  <zack@wolery.cumb.org>"}, {"sha": "c82b66a597aad3e607c6faf418113db43d10b1cb", "filename": "gcc/reload.c", "status": "modified", "additions": 34, "deletions": 40, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4381f7c29941a637a6fdce1b2f8a1cb9df586b71/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4381f7c29941a637a6fdce1b2f8a1cb9df586b71/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=4381f7c29941a637a6fdce1b2f8a1cb9df586b71", "patch": "@@ -19,7 +19,6 @@ along with GNU CC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n-\n /* This file contains subroutines used only from the file reload1.c.\n    It knows how to scan one insn for operands and values\n    that need to be copied into registers to make valid code.\n@@ -71,7 +70,6 @@ NOTE SIDE EFFECTS:\n 2 happens only when REPLACE is 1, which is only when\n actually doing the reloads, not when just counting them.\n \n-\n Using a reload register for several reloads in one insn:\n \n When an insn has reloads, it is considered as having three parts:\n@@ -2173,26 +2171,26 @@ decompose (x)\n \t  || GET_CODE (addr) == POST_DEC || GET_CODE (addr) == POST_INC)\n \t{\n \t  val.base = XEXP (addr, 0);\n-\t  val.start = - GET_MODE_SIZE (GET_MODE (x));\n+\t  val.start = -GET_MODE_SIZE (GET_MODE (x));\n \t  val.end = GET_MODE_SIZE (GET_MODE (x));\n \t  val.safe = REGNO (val.base) == STACK_POINTER_REGNUM;\n \t  return val;\n \t}\n \n       if (GET_CODE (addr) == PRE_MODIFY || GET_CODE (addr) == POST_MODIFY)\n- \t{\n- \t  if (GET_CODE (XEXP (addr, 1)) == PLUS\n+\t{\n+\t  if (GET_CODE (XEXP (addr, 1)) == PLUS\n \t      && XEXP (addr, 0) == XEXP (XEXP (addr, 1), 0)\n \t      && CONSTANT_P (XEXP (XEXP (addr, 1), 1)))\n- \t    {\n- \t      val.base  = XEXP (addr, 0);\n- \t      val.start = -INTVAL (XEXP (XEXP (addr, 1), 1));\n- \t      val.end   = INTVAL (XEXP (XEXP (addr, 1), 1));\n- \t      val.safe  = REGNO (val.base) == STACK_POINTER_REGNUM;\n- \t      return val;\n- \t    }\n- \t}\n-      \n+\t    {\n+\t      val.base  = XEXP (addr, 0);\n+\t      val.start = -INTVAL (XEXP (XEXP (addr, 1), 1));\n+\t      val.end   = INTVAL (XEXP (XEXP (addr, 1), 1));\n+\t      val.safe  = REGNO (val.base) == STACK_POINTER_REGNUM;\n+\t      return val;\n+\t    }\n+\t}\n+\n       if (GET_CODE (addr) == CONST)\n \t{\n \t  addr = XEXP (addr, 0);\n@@ -2311,7 +2309,7 @@ immune_p (x, y, ydata)\n   if (GET_CODE (x) != MEM)\n     return 1;\n \n-  xdata =  decompose (x);\n+  xdata = decompose (x);\n \n   if (! rtx_equal_p (xdata.base, ydata.base))\n     {\n@@ -2333,7 +2331,6 @@ immune_p (x, y, ydata)\n       return 0;\n     }\n \n-\n   return (xdata.start >= ydata.end || ydata.start >= xdata.end);\n }\n \n@@ -2878,7 +2875,8 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t      case '#':\n \t\t/* Ignore rest of this alternative as far as\n \t\t   reloading is concerned.  */\n-\t\twhile (*p && *p != ',') p++;\n+\t\twhile (*p && *p != ',')\n+\t\t  p++;\n \t\tbreak;\n \n \t      case '0':  case '1':  case '2':  case '3':  case '4':\n@@ -2902,9 +2900,9 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t\t       only on one side of its diagonal.  */\n \t\t    ? (operands_match\n \t\t       [(c == commutative || c == commutative + 1)\n-\t\t       ? 2*commutative + 1 - c : c]\n+\t\t       ? 2 * commutative + 1 - c : c]\n \t\t       [(i == commutative || i == commutative + 1)\n-\t\t       ? 2*commutative + 1 - i : i])\n+\t\t       ? 2 * commutative + 1 - i : i])\n \t\t    : operands_match[c][i])\n \t\t  {\n \t\t    /* If we are matching a non-offsettable address where an\n@@ -3233,7 +3231,6 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t\t       && ! const_to_mem)\n \t\tbad = 1;\n \n-\n \t      /* We prefer to reload pseudos over reloading other things,\n \t\t since such reloads may be able to be eliminated later.\n \t\t If we are reloading a SCRATCH, we won't be generating any\n@@ -3276,7 +3273,6 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t     Don't do this if the preferred class has only one register\n \t     because we might otherwise exhaust the class.  */\n \n-\n \t  if (! win && this_alternative[i] != (int) NO_REGS\n \t      && GET_MODE_SIZE (operand_mode[i]) <= UNITS_PER_WORD\n \t      && reg_class_size[(int) preferred_class[i]] > 1)\n@@ -3511,7 +3507,7 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n       tem = *recog_data.operand_loc[commutative];\n       *recog_data.operand_loc[commutative]\n \t= *recog_data.operand_loc[commutative + 1];\n-      *recog_data.operand_loc[commutative+1] = tem;\n+      *recog_data.operand_loc[commutative + 1] = tem;\n \n       for (i = 0; i < n_reloads; i++)\n \t{\n@@ -3947,8 +3943,7 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t    {\n \t      int secondary_in_reload = rld[i].secondary_in_reload;\n \n-\t      rld[secondary_in_reload].when_needed\n-\t\t= RELOAD_FOR_OPADDR_ADDR;\n+\t      rld[secondary_in_reload].when_needed = RELOAD_FOR_OPADDR_ADDR;\n \n \t      /* If there's a tertiary reload we have to change it also.  */\n \t      if (secondary_in_reload > 0\n@@ -3963,8 +3958,7 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t    {\n \t      int secondary_out_reload = rld[i].secondary_out_reload;\n \n-\t      rld[secondary_out_reload].when_needed\n-\t\t= RELOAD_FOR_OPADDR_ADDR;\n+\t      rld[secondary_out_reload].when_needed = RELOAD_FOR_OPADDR_ADDR;\n \n \t      /* If there's a tertiary reload we have to change it also.  */\n \t      if (secondary_out_reload\n@@ -4018,7 +4012,7 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n     int first_op_addr_num = -2;\n     int first_inpaddr_num[MAX_RECOG_OPERANDS];\n     int first_outpaddr_num[MAX_RECOG_OPERANDS];\n-    int need_change= 0;\n+    int need_change = 0;\n     /* We use last_op_addr_reload and the contents of the above arrays\n        first as flags - -2 means no instance encountered, -1 means exactly\n        one instance encountered.\n@@ -5131,12 +5125,12 @@ find_reloads_address_1 (mode, x, context, loc, opnum, type, ind_levels, insn)\n \t   of another register or by a constant value.  Thus, these\n \t   operands must match.  */\n \tif (op0 != XEXP (op1, 0))\n-\t  abort();\n+\t  abort ();\n \n \t/* Require index register (or constant).  Let's just handle the\n \t   register case in the meantime... If the target allows\n \t   auto-modify by a constant then we could try replacing a pseudo\n-\t   register with its equivalent constant where applicable. */\n+\t   register with its equivalent constant where applicable.  */\n \tif (REG_P (XEXP (op1, 1)))\n \t  if (!REGNO_OK_FOR_INDEX_P (REGNO (XEXP (op1, 1))))\n \t    find_reloads_address_1 (mode, XEXP (op1, 1), 1, &XEXP (op1, 1),\n@@ -5186,14 +5180,14 @@ find_reloads_address_1 (mode, x, context, loc, opnum, type, ind_levels, insn)\n \t    if (!REGNO_MODE_OK_FOR_BASE_P (regno, GET_MODE (x)))\n \t      {\n \t\tpush_reload (XEXP (op1, 0), XEXP (x, 0),\n-\t\t\t     &XEXP (op1, 0), &XEXP (x, 0), \n+\t\t\t     &XEXP (op1, 0), &XEXP (x, 0),\n \t\t\t     BASE_REG_CLASS,\n \t\t\t     GET_MODE (x), GET_MODE (x), 0, 0,\n \t\t\t     opnum, RELOAD_OTHER);\n \t      }\n \t  }\n \telse\n-\t  abort();\n+\t  abort ();\n       }\n       return 0;\n \n@@ -5928,7 +5922,7 @@ refers_to_regno_for_reload_p (regno, endregno, x, loc)\n       else if (fmt[i] == 'E')\n \t{\n \t  register int j;\n-\t  for (j = XVECLEN (x, i) - 1; j >=0; j--)\n+\t  for (j = XVECLEN (x, i) - 1; j >= 0; j--)\n \t    if (loc != &XVECEXP (x, i, j)\n \t\t&& refers_to_regno_for_reload_p (regno, endregno,\n \t\t\t\t\t\t XVECEXP (x, i, j), loc))\n@@ -6300,10 +6294,10 @@ find_equiv_reg (goal, insn, class, other, reload_reg_p, goalreg, mode)\n       if (GET_CODE (p) == CALL_INSN)\n \t{\n \t  int i;\n-\t  \n+\n \t  if (goal_mem || need_stable_sp)\n \t    return 0;\n-\t  \n+\n \t  if (regno >= 0 && regno < FIRST_PSEUDO_REGISTER)\n \t    for (i = 0; i < nregs; ++i)\n \t      if (call_used_regs[regno + i])\n@@ -6444,7 +6438,7 @@ find_equiv_reg (goal, insn, class, other, reload_reg_p, goalreg, mode)\n \t\t\t      && xregno + xnregs > regno)\n \t\t\t    return 0;\n \t\t\t  else if (xregno < valueno + valuenregs\n-\t\t\t      && xregno + xnregs > valueno)\n+\t\t\t\t   && xregno + xnregs > valueno)\n \t\t\t    return 0;\n \t\t\t  else if (goal_mem_addr_varies\n \t\t\t\t   && reg_overlap_mentioned_for_reload_p (dest,\n@@ -6517,11 +6511,11 @@ find_inc_amount (x, inced)\n \t       && XEXP (addr, 0) == XEXP (XEXP (addr, 1), 0)\n \t       && XEXP (addr, 0) == inced\n \t       && GET_CODE (XEXP (XEXP (addr, 1), 1)) == CONST_INT)\n- \t{ \n- \t  i = INTVAL (XEXP (XEXP (addr, 1), 1));\n- \t  return i < 0 ? -i : i;\n- \t}\n-   }\n+\t{\n+\t  i = INTVAL (XEXP (XEXP (addr, 1), 1));\n+\t  return i < 0 ? -i : i;\n+\t}\n+    }\n \n   fmt = GET_RTX_FORMAT (code);\n   for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)"}, {"sha": "af4c08f293f62d741897b6191c1655b126025d30", "filename": "gcc/stmt.c", "status": "modified", "additions": 105, "deletions": 106, "changes": 211, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4381f7c29941a637a6fdce1b2f8a1cb9df586b71/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4381f7c29941a637a6fdce1b2f8a1cb9df586b71/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=4381f7c29941a637a6fdce1b2f8a1cb9df586b71", "patch": "@@ -19,7 +19,6 @@ along with GNU CC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n-\n /* This file handles the generation of rtl code from tree structure\n    above the level of expressions, using subroutines in exp*.c and emit-rtl.c.\n    It also creates the rtl expressions for parameters and auto variables\n@@ -64,7 +63,6 @@ struct obstack stmt_obstack;\n #ifndef CASE_VECTOR_PC_RELATIVE\n #define CASE_VECTOR_PC_RELATIVE 0\n #endif\n-\n \f\n /* Functions and data structures for expanding case statements.  */\n \n@@ -400,7 +398,6 @@ static int using_eh_for_cleanups_p = 0;\n /* Character strings, each containing a single decimal digit.  */\n static char *digit_strings[10];\n \n-\n static int n_occurrences\t\tPARAMS ((int, const char *));\n static void expand_goto_internal\tPARAMS ((tree, rtx, rtx));\n static int expand_fixup\t\t\tPARAMS ((tree, rtx, rtx));\n@@ -851,7 +848,7 @@ expand_goto (label)\n \t  emit_insn (gen_rtx_USE (VOIDmode, stack_pointer_rtx));\n \t  emit_indirect_jump (handler_slot);\n \t}\n-     }\n+    }\n   else\n     expand_goto_internal (label, label_rtx (label), NULL_RTX);\n }\n@@ -1050,7 +1047,7 @@ expand_fixup (tree_label, rtl_label, last_insn)\n \t  insert_block (block);\n \telse\n \t  {\n-\t    BLOCK_CHAIN (block) \n+\t    BLOCK_CHAIN (block)\n \t      = BLOCK_CHAIN (DECL_INITIAL (current_function_decl));\n \t    BLOCK_CHAIN (DECL_INITIAL (current_function_decl))\n \t      = block;\n@@ -1083,8 +1080,6 @@ expand_fixup (tree_label, rtl_label, last_insn)\n \n   return block != 0;\n }\n-\n-\n \f\n /* Expand any needed fixups in the outputmost binding level of the\n    function.  FIRST_INSN is the first insn in the function.  */\n@@ -1196,7 +1191,7 @@ fixup_gotos (thisblock, stack_level, cleanup_list, first_insn, dont_jump_in)\n \t      && ! (f->target_rtl == return_label\n \t\t    && ((TREE_CODE (TREE_TYPE (current_function_decl))\n \t\t\t == FUNCTION_TYPE)\n-\t\t\t&& (TYPE_RETURNS_STACK_DEPRESSED \n+\t\t\t&& (TYPE_RETURNS_STACK_DEPRESSED\n \t\t\t    (TREE_TYPE (current_function_decl))))))\n \t    emit_stack_restore (SAVE_BLOCK, f->stack_level, f->before_jump);\n \n@@ -1215,7 +1210,6 @@ fixup_gotos (thisblock, stack_level, cleanup_list, first_insn, dont_jump_in)\n \t  end_sequence ();\n \t  emit_insns_after (cleanup_insns, f->before_jump);\n \n-\n \t  f->before_jump = 0;\n \t}\n     }\n@@ -1390,7 +1384,7 @@ expand_asm_operands (string, outputs, inputs, clobbers, vol, filename, line)\n \t  error (\"too many alternatives in `asm'\");\n \t  return;\n \t}\n-      \n+\n       tmp = outputs;\n       while (tmp)\n \t{\n@@ -1595,8 +1589,8 @@ expand_asm_operands (string, outputs, inputs, clobbers, vol, filename, line)\n   argvec = rtvec_alloc (ninputs);\n   constraints = rtvec_alloc (ninputs);\n \n-  body = gen_rtx_ASM_OPERANDS (VOIDmode, TREE_STRING_POINTER (string), \n-\t\t\t       empty_string, 0, argvec, constraints, \n+  body = gen_rtx_ASM_OPERANDS (VOIDmode, TREE_STRING_POINTER (string),\n+\t\t\t       empty_string, 0, argvec, constraints,\n \t\t\t       filename, line);\n \n   MEM_VOLATILE_P (body) = vol;\n@@ -1688,14 +1682,14 @@ expand_asm_operands (string, outputs, inputs, clobbers, vol, filename, line)\n \n \t\tfor (j = constraint[j] - '0'; j > 0; --j)\n \t\t  o = TREE_CHAIN (o);\n-\t\n+\n \t\tc_len = strlen (TREE_STRING_POINTER (TREE_PURPOSE (o)));\n \t\tconstraint = TREE_STRING_POINTER (TREE_PURPOSE (o));\n \t\tj = 0;\n \t\tbreak;\n \t      }\n \n-\t    /* ... fall through ... */\n+\t    /* Fall through.  */\n \n \t  case 'p':  case 'r':\n \t    allows_reg = 1;\n@@ -1782,7 +1776,7 @@ expand_asm_operands (string, outputs, inputs, clobbers, vol, filename, line)\n   for (i = 0; i < noutputs; i++)\n     output_rtx[i] = protect_from_queue (output_rtx[i], 1);\n \n-  /* For in-out operands, copy output rtx to input rtx. */\n+  /* For in-out operands, copy output rtx to input rtx.  */\n   for (i = 0; i < ninout; i++)\n     {\n       int j = inout_opnum[i];\n@@ -1930,7 +1924,7 @@ expand_expr_stmt (exp)\n       else\n \t{\n \t  rtx lab = gen_label_rtx ();\n-\t  \n+\n \t  /* Compare the value with itself to reference it.  */\n \t  emit_cmp_and_jump_insns (last_expr_value, last_expr_value, EQ,\n \t\t\t\t   expand_expr (TYPE_SIZE (last_expr_type),\n@@ -2036,8 +2030,8 @@ warn_if_unused_value (exp)\n \t the user cannot control it.  */\n       if (TREE_CODE (TREE_TYPE (TREE_OPERAND (exp, 0))) == REFERENCE_TYPE)\n \treturn warn_if_unused_value (TREE_OPERAND (exp, 0));\n-      /* ... fall through ...  */\n-      \n+      /* Fall through.  */\n+\n     default:\n       /* Referencing a volatile value is a side effect, so don't warn.  */\n       if ((DECL_P (exp)\n@@ -2228,8 +2222,6 @@ expand_end_cond ()\n   POPSTACK (cond_stack);\n   last_expr_type = 0;\n }\n-\n-\n \f\n /* Generate RTL for the start of a loop.  EXIT_FLAG is nonzero if this\n    loop should be exited by `exit_something'.  This is a loop for which\n@@ -2342,8 +2334,8 @@ expand_end_loop ()\n \t  insn = PREV_INSN (label);\n \t  reorder_insns (label, label, start_label);\n \n-\t  for (prev = PREV_INSN (jump); ; prev = PREV_INSN (prev))\n-\t   {\n+\t  for (prev = PREV_INSN (jump);; prev = PREV_INSN (prev))\n+\t    {\n \t      /* We ignore line number notes, but if we see any other note,\n \t\t in particular NOTE_INSN_BLOCK_*, NOTE_INSN_EH_REGION_*,\n \t\t NOTE_INSN_LOOP_*, we disable this optimization.  */\n@@ -2388,7 +2380,7 @@ expand_end_loop ()\n \t body;\n \t goto start_label;\n \t end_label:\n-\t \n+\n      transform it to look like:\n \n          goto start_label;\n@@ -2419,7 +2411,7 @@ expand_end_loop ()\n       for (insn = NEXT_INSN (loop_stack->data.loop.start_label); insn;\n \t   insn = NEXT_INSN (insn))\n \t{\n-\t  if (GET_CODE (insn) == NOTE) \n+\t  if (GET_CODE (insn) == NOTE)\n \t    {\n \t      if (optimize < 2\n \t\t  && (NOTE_LINE_NUMBER (insn) == NOTE_INSN_BLOCK_BEG\n@@ -2436,7 +2428,7 @@ expand_end_loop ()\n \t      else if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_EH_REGION_END)\n \t\t{\n \t\t  --eh_regions;\n-\t\t  if (eh_regions < 0) \n+\t\t  if (eh_regions < 0)\n \t\t    /* We've come to the end of an EH region, but\n \t\t       never saw the beginning of that region.  That\n \t\t       means that an EH region begins before the top\n@@ -2463,37 +2455,37 @@ expand_end_loop ()\n \t  if (last_test_insn && num_insns > 30)\n \t    break;\n \n-\t  if (eh_regions > 0) \n+\t  if (eh_regions > 0)\n \t    /* We don't want to move a partial EH region.  Consider:\n \n \t\t  while ( ( { try {\n-\t\t\t\tif (cond ()) 0;\t\n+\t\t\t\tif (cond ()) 0;\n \t\t\t\telse {\n \t\t\t\t  bar();\n \t\t\t\t  1;\n \t\t\t\t}\n-\t\t\t      } catch (...) { \n+\t\t\t      } catch (...) {\n \t\t\t\t1;\n \t\t\t      } )) {\n \t\t     body;\n-\t\t  } \n+\t\t  }\n \n \t        This isn't legal C++, but here's what it's supposed to\n \t        mean: if cond() is true, stop looping.  Otherwise,\n \t        call bar, and keep looping.  In addition, if cond\n \t        throws an exception, catch it and keep looping. Such\n-\t        constructs are certainy legal in LISP.  \n+\t        constructs are certainy legal in LISP.\n \n \t\tWe should not move the `if (cond()) 0' test since then\n \t\tthe EH-region for the try-block would be broken up.\n \t\t(In this case we would the EH_BEG note for the `try'\n \t\tand `if cond()' but not the call to bar() or the\n-\t\tEH_END note.)  \n+\t\tEH_END note.)\n \n \t        So we don't look for tests within an EH region.  */\n \t    continue;\n \n-\t  if (GET_CODE (insn) == JUMP_INSN \n+\t  if (GET_CODE (insn) == JUMP_INSN\n \t      && GET_CODE (PATTERN (insn)) == SET\n \t      && SET_DEST (PATTERN (insn)) == pc_rtx)\n \t    {\n@@ -2518,9 +2510,9 @@ expand_end_loop ()\n \n \t      do {\n \t\tif (dest1 && GET_CODE (dest1) == LABEL_REF\n-\t\t    && ((XEXP (dest1, 0) \n+\t\t    && ((XEXP (dest1, 0)\n \t\t\t == loop_stack->data.loop.alt_end_label)\n-\t\t\t|| (XEXP (dest1, 0) \n+\t\t\t|| (XEXP (dest1, 0)\n \t\t\t    == loop_stack->data.loop.end_label)))\n \t\t  {\n \t\t    last_test_insn = potential_last_test;\n@@ -2659,7 +2651,6 @@ expand_exit_loop_if_false (whichloop, cond)\n      around a unconditional branch to exit the loop.  If fixups are\n      necessary, they go before the unconditional branch.  */\n \n-\n   do_jump (cond, NULL_RTX, label);\n   last_insn = get_last_insn ();\n   if (GET_CODE (last_insn) == CODE_LABEL)\n@@ -2741,7 +2732,7 @@ expand_null_return ()\n   struct nesting *block = block_stack;\n   rtx last_insn = get_last_insn ();\n \n-  /* If this function was declared to return a value, but we \n+  /* If this function was declared to return a value, but we\n      didn't, clobber the return registers so that they are not\n      propogated live to the rest of the function.  */\n   clobber_return_register ();\n@@ -2964,7 +2955,7 @@ expand_return (retval)\n \tbig_endian_correction = (BITS_PER_WORD - ((bytes % UNITS_PER_WORD)\n \t\t\t\t\t\t  * BITS_PER_UNIT));\n \n-      /* Copy the structure BITSIZE bits at a time.  */ \n+      /* Copy the structure BITSIZE bits at a time.  */\n       for (bitpos = 0, xbitpos = big_endian_correction;\n \t   bitpos < bytes * BITS_PER_UNIT;\n \t   bitpos += bitsize, xbitpos += bitsize)\n@@ -3075,8 +3066,8 @@ drop_through_at_end_p ()\n \f\n /* Attempt to optimize a potential tail recursion call into a goto.\n    ARGUMENTS are the arguments to a CALL_EXPR; LAST_INSN indicates\n-   where to place the jump to the tail recursion label. \n-   \n+   where to place the jump to the tail recursion label.\n+\n    Return TRUE if the call was optimized into a goto.  */\n \n int\n@@ -3150,7 +3141,10 @@ tail_recursion_args (actuals, formals)\n       register int j;\n       for (f = formals, j = 0; j < i; f = TREE_CHAIN (f), j++)\n \tif (reg_mentioned_p (DECL_RTL (f), argvec[i]))\n-\t  { copy = 1; break; }\n+\t  {\n+\t    copy = 1;\n+\t    break;\n+\t  }\n       if (copy)\n \targvec[i] = copy_to_reg (argvec[i]);\n     }\n@@ -3185,7 +3179,7 @@ tail_recursion_args (actuals, formals)\n \t will not create corresponding BLOCK nodes.  (There should be\n \t a one-to-one correspondence between NOTE_INSN_BLOCK_BEG notes\n \t and BLOCKs.)  If this flag is set, MARK_ENDS should be zero\n-\t when expand_end_bindings is called.  \n+\t when expand_end_bindings is called.\n \n     If we are creating a NOTE_INSN_BLOCK_BEG note, a BLOCK may\n     optionally be supplied.  If so, it becomes the NOTE_BLOCK for the\n@@ -3200,7 +3194,7 @@ expand_start_bindings_and_block (flags, block)\n   rtx note;\n   int exit_flag = ((flags & 1) != 0);\n   int block_flag = ((flags & 2) == 0);\n-  \n+\n   /* If a BLOCK is supplied, then the caller should be requesting a\n      NOTE_INSN_BLOCK_BEG note.  */\n   if (!block_flag && block)\n@@ -3214,7 +3208,7 @@ expand_start_bindings_and_block (flags, block)\n     }\n   else\n     note = emit_note (NULL_PTR, NOTE_INSN_DELETED);\n-    \n+\n   /* Make an entry on block_stack for the block we are entering.  */\n \n   thisblock->next = block_stack;\n@@ -3281,7 +3275,7 @@ void\n expand_end_target_temps ()\n {\n   expand_end_bindings (NULL_TREE, 0, 0);\n-  \n+\n   /* This is so that even if the result is preserved, the space\n      allocated will be freed, as we know that it is no longer in use.  */\n   pop_temp_slots ();\n@@ -3295,7 +3289,7 @@ expand_end_target_temps ()\n    BLOCK_SUPERCONTEXT of the node will point to another BLOCK node which\n    represents the outermost (function) scope for the function or method (i.e.\n    the one which includes the formal parameters).  The BLOCK_SUPERCONTEXT of\n-   *that* node in turn will point to the relevant FUNCTION_DECL node. */\n+   *that* node in turn will point to the relevant FUNCTION_DECL node.  */\n \n int\n is_body_block (stmt)\n@@ -3549,10 +3543,10 @@ warn_about_unused_variables (vars)\n \n   if (warn_unused_variable)\n     for (decl = vars; decl; decl = TREE_CHAIN (decl))\n-      if (TREE_CODE (decl) == VAR_DECL \n+      if (TREE_CODE (decl) == VAR_DECL\n \t  && ! TREE_USED (decl)\n \t  && ! DECL_IN_SYSTEM_HEADER (decl)\n-\t  && DECL_NAME (decl) && ! DECL_ARTIFICIAL (decl)) \n+\t  && DECL_NAME (decl) && ! DECL_ARTIFICIAL (decl))\n \twarning_with_decl (decl, \"unused variable `%s'\");\n }\n \n@@ -3592,7 +3586,7 @@ expand_end_bindings (vars, mark_ends, dont_jump_in)\n   /* Since expand_eh_region_start does an expand_start_bindings, we\n      have to first end all the bindings that were created by\n      expand_eh_region_start.  */\n-     \n+\n   thisblock = block_stack;\n \n   /* If any of the variables in this scope were not used, warn the\n@@ -3660,7 +3654,7 @@ expand_end_bindings (vars, mark_ends, dont_jump_in)\n       if (GET_CODE (insn) == NOTE)\n \tinsn = prev_nonnote_insn (insn);\n       reachable = (! insn || GET_CODE (insn) != BARRIER);\n-      \n+\n       /* Do the cleanups.  */\n       expand_cleanups (thisblock->data.block.cleanups, NULL_TREE, 0, reachable);\n       if (reachable)\n@@ -3857,7 +3851,7 @@ expand_decl (decl)\n       free_temp_slots ();\n \n       /* Allocate space on the stack for the variable.  Note that\n-\t DECL_ALIGN says how the variable is to be aligned and we \n+\t DECL_ALIGN says how the variable is to be aligned and we\n \t cannot use it to conclude anything about the alignment of\n \t the size.  */\n       address = allocate_dynamic_stack_space (size, NULL_RTX,\n@@ -4171,7 +4165,7 @@ expand_anon_union_decl (decl, cleanup, decl_elts)\n \tTREE_ADDRESSABLE (decl) = 1;\n \tbreak;\n       }\n-\t  \n+\n   expand_decl (decl);\n   expand_decl_cleanup (decl, cleanup);\n   x = DECL_RTL (decl);\n@@ -4430,7 +4424,6 @@ expand_start_case (exit_flag, expr, type, printname)\n   start_cleanup_deferral ();\n }\n \n-\n /* Start a \"dummy case statement\" within which case labels are invalid\n    and are not connected to any larger real case statement.\n    This can be used if you don't want to let a case statement jump\n@@ -4504,8 +4497,8 @@ check_seenlabel ()\n \n \t      /* If insn is zero, then there must have been a syntax error.  */\n \t      if (insn)\n-\t\twarning_with_file_and_line (NOTE_SOURCE_FILE(insn),\n-\t\t\t\t\t    NOTE_LINE_NUMBER(insn),\n+\t\twarning_with_file_and_line (NOTE_SOURCE_FILE (insn),\n+\t\t\t\t\t    NOTE_LINE_NUMBER (insn),\n \t\t\t\t\t    \"unreachable code at beginning of %s\",\n \t\t\t\t\t    case_stack->data.case_stmt.printname);\n \t      break;\n@@ -4632,7 +4625,7 @@ pushcase_range (value1, value2, converter, label, duplicate)\n   if (value2 != 0 && tree_int_cst_lt (value2, value1))\n     return 4;\n \n-  /* If the max was unbounded, use the max of the nominal_type we are \n+  /* If the max was unbounded, use the max of the nominal_type we are\n      converting to.  Do this after the < check above to suppress false\n      positives.  */\n   if (value2 == 0)\n@@ -4882,7 +4875,6 @@ add_case_node (low, high, label, duplicate)\n \n   return 0;\n }\n-\n \f\n /* Returns the number of possible values of TYPE.\n    Returns -1 if the number is unknown, variable, or if the number does not\n@@ -4981,7 +4973,8 @@ mark_seen_cases (type, cases_seen, count, sparseness)\n \n   TREE_TYPE (val) = type;\n   if (! root)\n-    ; /* Do nothing */\n+    /* Do nothing.  */\n+    ;\n   else if (sparseness == 2)\n     {\n       tree t;\n@@ -4991,7 +4984,7 @@ mark_seen_cases (type, cases_seen, count, sparseness)\n \t duplicate case values (multiple enum constants\n \t with the same value).  */\n       TREE_TYPE (val) = TREE_TYPE (root->low);\n-      for (t = TYPE_VALUES (type), xlo = 0;  t != NULL_TREE;\n+      for (t = TYPE_VALUES (type), xlo = 0; t != NULL_TREE;\n \t   t = TREE_CHAIN (t), xlo++)\n \t{\n \t  TREE_INT_CST_LOW (val) = TREE_INT_CST_LOW (TREE_VALUE (t));\n@@ -5002,11 +4995,11 @@ mark_seen_cases (type, cases_seen, count, sparseness)\n \t      /* Keep going past elements distinctly greater than VAL.  */\n \t      if (tree_int_cst_lt (val, n->low))\n \t\tn = n->left;\n-\t\n+\n \t      /* or distinctly less than VAL.  */\n \t      else if (tree_int_cst_lt (n->high, val))\n \t\tn = n->right;\n-\t\n+\n \t      else\n \t\t{\n \t\t  /* We have found a matching range.  */\n@@ -5026,7 +5019,7 @@ mark_seen_cases (type, cases_seen, count, sparseness)\n \t{\n \t  TREE_INT_CST_LOW (val) = TREE_INT_CST_LOW (n->low);\n \t  TREE_INT_CST_HIGH (val) = TREE_INT_CST_HIGH (n->low);\n-\t  while ( ! tree_int_cst_lt (n->high, val))\n+\t  while (! tree_int_cst_lt (n->high, val))\n \t    {\n \t      /* Calculate (into xlo) the \"offset\" of the integer (val).\n \t\t The element with lowest value has offset 0, the next smallest\n@@ -5077,7 +5070,7 @@ mark_seen_cases (type, cases_seen, count, sparseness)\n \t\t\t      TREE_INT_CST_LOW (val), TREE_INT_CST_HIGH (val),\n \t\t\t      &xlo, &xhi);\n \t\t}\n-\t      \n+\n \t      if (xhi == 0 && xlo < (unsigned HOST_WIDE_INT) count)\n \t\tBITARRAY_SET (cases_seen, xlo);\n \n@@ -5106,7 +5099,7 @@ check_for_full_enumeration_handling (type)\n {\n   register struct case_node *n;\n   register tree chain;\n-#if 0  /* variable used by 'if 0'ed  code below. */\n+#if 0  /* variable used by 'if 0'ed  code below.  */\n   register struct case_node **l;\n   int all_values = 1;\n #endif\n@@ -5132,7 +5125,7 @@ check_for_full_enumeration_handling (type)\n \n   if (size > 0 && size < 600000\n       /* We deliberately use calloc here, not cmalloc, so that we can suppress\n-\t this optimization if we don't have enough memory rather than \n+\t this optimization if we don't have enough memory rather than\n \t aborting, as xmalloc would do.  */\n       && (cases_seen = (unsigned char *) calloc (bytes_needed, 1)) != NULL)\n     {\n@@ -5147,7 +5140,7 @@ check_for_full_enumeration_handling (type)\n       mark_seen_cases (type, cases_seen, size, sparseness);\n \n       for (i = 0; v != NULL_TREE && i < size; i++, v = TREE_CHAIN (v))\n-\tif (BITARRAY_TEST(cases_seen, i) == 0)\n+\tif (BITARRAY_TEST (cases_seen, i) == 0)\n \t  warning (\"enumeration value `%s' not handled in switch\",\n \t\t   IDENTIFIER_POINTER (TREE_PURPOSE (v)));\n \n@@ -5300,7 +5293,7 @@ expand_end_case (orig_index)\n       if (thiscase->data.case_stmt.case_list\n \t  && thiscase->data.case_stmt.case_list->left)\n \tthiscase->data.case_stmt.case_list\n-\t  = case_tree2list(thiscase->data.case_stmt.case_list, 0);\n+\t  = case_tree2list (thiscase->data.case_stmt.case_list, 0);\n \n       /* Simplify the case-list before we count it.  */\n       group_case_nodes (thiscase->data.case_stmt.case_list);\n@@ -5396,7 +5389,7 @@ expand_end_case (orig_index)\n \t     generate the conversion.  */\n \n \t  if (GET_MODE_CLASS (GET_MODE (index)) == MODE_INT\n-\t      && (cmp_optab->handlers[(int) GET_MODE(index)].insn_code\n+\t      && (cmp_optab->handlers[(int) GET_MODE (index)].insn_code\n \t\t  == CODE_FOR_nothing))\n \t    {\n \t      enum machine_mode wider_mode;\n@@ -5463,7 +5456,7 @@ expand_end_case (orig_index)\n \t      use_cost_table\n \t\t= (TREE_CODE (TREE_TYPE (orig_index)) != ENUMERAL_TYPE\n \t\t   && estimate_case_costs (thiscase->data.case_stmt.case_list));\n-\t      balance_case_nodes (&thiscase->data.case_stmt.case_list, \n+\t      balance_case_nodes (&thiscase->data.case_stmt.case_list,\n \t\t\t\t  NULL_PTR);\n \t      emit_case_nodes (index, thiscase->data.case_stmt.case_list,\n \t\t\t       default_label, index_type);\n@@ -5513,22 +5506,22 @@ expand_end_case (orig_index)\n \t      index = protect_from_queue (index, 0);\n \t      do_pending_stack_adjust ();\n \n-\t      op_mode = insn_data[(int)CODE_FOR_casesi].operand[0].mode;\n-\t      if (! (*insn_data[(int)CODE_FOR_casesi].operand[0].predicate)\n+\t      op_mode = insn_data[(int) CODE_FOR_casesi].operand[0].mode;\n+\t      if (! (*insn_data[(int) CODE_FOR_casesi].operand[0].predicate)\n \t\t  (index, op_mode))\n \t\tindex = copy_to_mode_reg (op_mode, index);\n \n \t      op1 = expand_expr (minval, NULL_RTX, VOIDmode, 0);\n \n-\t      op_mode = insn_data[(int)CODE_FOR_casesi].operand[1].mode;\n-\t      if (! (*insn_data[(int)CODE_FOR_casesi].operand[1].predicate)\n+\t      op_mode = insn_data[(int) CODE_FOR_casesi].operand[1].mode;\n+\t      if (! (*insn_data[(int) CODE_FOR_casesi].operand[1].predicate)\n \t\t  (op1, op_mode))\n \t\top1 = copy_to_mode_reg (op_mode, op1);\n \n \t      op2 = expand_expr (range, NULL_RTX, VOIDmode, 0);\n \n-\t      op_mode = insn_data[(int)CODE_FOR_casesi].operand[2].mode;\n-\t      if (! (*insn_data[(int)CODE_FOR_casesi].operand[2].predicate)\n+\t      op_mode = insn_data[(int) CODE_FOR_casesi].operand[2].mode;\n+\t      if (! (*insn_data[(int) CODE_FOR_casesi].operand[2].predicate)\n \t\t  (op2, op_mode))\n \t\top2 = copy_to_mode_reg (op_mode, op2);\n \n@@ -5542,8 +5535,8 @@ expand_end_case (orig_index)\n \t    {\n \t      index_type = thiscase->data.case_stmt.nominal_type;\n \t      index_expr = fold (build (MINUS_EXPR, index_type,\n-\t\t\t                convert (index_type, index_expr),\n-\t\t\t\t        convert (index_type, minval)));\n+\t\t\t\t\tconvert (index_type, index_expr),\n+\t\t\t\t\tconvert (index_type, minval)));\n \t      index = expand_expr (index_expr, NULL_RTX, VOIDmode, 0);\n \t      emit_queue ();\n \t      index = protect_from_queue (index, 0);\n@@ -5592,7 +5585,7 @@ expand_end_case (orig_index)\n \t    emit_jump_insn (gen_rtx_ADDR_DIFF_VEC (CASE_VECTOR_MODE,\n \t\t\t\t\t\t   gen_rtx_LABEL_REF (Pmode, table_label),\n \t\t\t\t\t\t   gen_rtvec_v (ncases, labelvec),\n-\t\t\t\t\t\t    const0_rtx, const0_rtx));\n+\t\t\t\t\t\t   const0_rtx, const0_rtx));\n \t  else\n \t    emit_jump_insn (gen_rtx_ADDR_VEC (CASE_VECTOR_MODE,\n \t\t\t\t\t      gen_rtvec_v (ncases, labelvec)));\n@@ -6097,17 +6090,19 @@ emit_case_nodes (index, node, default_label, index_type)\n \n \t  if (node_is_bounded (node->right, index_type))\n \t    {\n-\t      emit_cmp_and_jump_insns (index, expand_expr (node->high, NULL_RTX,\n-\t\t\t\t\t\t\t   VOIDmode, 0),\n-\t\t\t\t        GT, NULL_RTX, mode, unsignedp, 0,\n-\t\t\t\t\tlabel_rtx (node->right->code_label));\n+\t      emit_cmp_and_jump_insns (index,\n+\t\t\t\t       expand_expr (node->high, NULL_RTX,\n+\t\t\t\t\t\t    VOIDmode, 0),\n+\t\t\t\t       GT, NULL_RTX, mode, unsignedp, 0,\n+\t\t\t\t       label_rtx (node->right->code_label));\n \t      emit_case_nodes (index, node->left, default_label, index_type);\n \t    }\n \n \t  else if (node_is_bounded (node->left, index_type))\n \t    {\n-\t      emit_cmp_and_jump_insns (index, expand_expr (node->high, NULL_RTX,\n-\t\t\t\t\t\t\t   VOIDmode, 0),\n+\t      emit_cmp_and_jump_insns (index,\n+\t\t\t\t       expand_expr (node->high, NULL_RTX,\n+\t\t\t\t\t\t    VOIDmode, 0),\n \t\t\t\t       LT, NULL_RTX, mode, unsignedp, 0,\n \t\t\t\t       label_rtx (node->left->code_label));\n \t      emit_case_nodes (index, node->right, default_label, index_type);\n@@ -6118,12 +6113,12 @@ emit_case_nodes (index, node, default_label, index_type)\n \t      /* Neither node is bounded.  First distinguish the two sides;\n \t\t then emit the code for one side at a time.  */\n \n-\t      tree test_label\n-\t\t= build_decl (LABEL_DECL, NULL_TREE, NULL_TREE);\n+\t      tree test_label = build_decl (LABEL_DECL, NULL_TREE, NULL_TREE);\n \n \t      /* See if the value is on the right.  */\n-\t      emit_cmp_and_jump_insns (index, expand_expr (node->high, NULL_RTX,\n-\t\t\t\t\t\t\t   VOIDmode, 0),\n+\t      emit_cmp_and_jump_insns (index,\n+\t\t\t\t       expand_expr (node->high, NULL_RTX,\n+\t\t\t\t\t\t    VOIDmode, 0),\n \t\t\t\t       GT, NULL_RTX, mode, unsignedp, 0,\n \t\t\t\t       label_rtx (test_label));\n \n@@ -6153,9 +6148,9 @@ emit_case_nodes (index, node, default_label, index_type)\n \t    {\n \t      if (!node_has_low_bound (node, index_type))\n \t\t{\n-\t\t  emit_cmp_and_jump_insns (index, expand_expr (node->high,\n-\t\t\t\t\t\t\t       NULL_RTX,\n-\t\t\t\t\t\t\t       VOIDmode, 0),\n+\t\t  emit_cmp_and_jump_insns (index,\n+\t\t\t\t\t   expand_expr (node->high, NULL_RTX,\n+\t\t\t\t\t\t\tVOIDmode, 0),\n \t\t\t\t\t   LT, NULL_RTX, mode, unsignedp, 0,\n \t\t\t\t\t   default_label);\n \t\t}\n@@ -6186,10 +6181,10 @@ emit_case_nodes (index, node, default_label, index_type)\n \t     a branch-greater-than will get us to the default\n \t     label correctly.  */\n \t  if (use_cost_table\n-\t       && cost_table[TREE_INT_CST_LOW (node->high)] < 12)\n+\t      && cost_table[TREE_INT_CST_LOW (node->high)] < 12)\n \t    ;\n #endif /* 0 */\n- \t  if (node->left->left || node->left->right\n+\t  if (node->left->left || node->left->right\n \t      || !tree_int_cst_equal (node->left->low, node->left->high))\n \t    {\n \t      if (!node_has_high_bound (node, index_type))\n@@ -6228,7 +6223,6 @@ emit_case_nodes (index, node, default_label, index_type)\n \t     then handle the two subtrees.  */\n \t  tree test_label = 0;\n \n-\n \t  if (node_is_bounded (node->right, index_type))\n \t    /* Right hand node is fully bounded so we can eliminate any\n \t       testing and branch directly to the target code.  */\n@@ -6242,8 +6236,9 @@ emit_case_nodes (index, node, default_label, index_type)\n \t\t Branch to a label where we will handle it later.  */\n \n \t      test_label = build_decl (LABEL_DECL, NULL_TREE, NULL_TREE);\n-\t      emit_cmp_and_jump_insns (index, expand_expr (node->high, NULL_RTX,\n-\t\t\t\t\t\t\t   VOIDmode, 0),\n+\t      emit_cmp_and_jump_insns (index,\n+\t\t\t\t       expand_expr (node->high, NULL_RTX,\n+\t\t\t\t\t\t    VOIDmode, 0),\n \t\t\t\t       GT, NULL_RTX, mode, unsignedp, 0,\n \t\t\t\t       label_rtx (test_label));\n \t    }\n@@ -6277,8 +6272,9 @@ emit_case_nodes (index, node, default_label, index_type)\n \t     if they are possible.  */\n \t  if (!node_has_low_bound (node, index_type))\n \t    {\n-\t      emit_cmp_and_jump_insns (index, expand_expr (node->low, NULL_RTX,\n-\t\t\t\t\t\t\t   VOIDmode, 0),\n+\t      emit_cmp_and_jump_insns (index,\n+\t\t\t\t       expand_expr (node->low, NULL_RTX,\n+\t\t\t\t\t\t    VOIDmode, 0),\n \t\t\t\t       LT, NULL_RTX, mode, unsignedp, 0,\n \t\t\t\t       default_label);\n \t    }\n@@ -6299,16 +6295,18 @@ emit_case_nodes (index, node, default_label, index_type)\n \t     if they are possible.  */\n \t  if (!node_has_high_bound (node, index_type))\n \t    {\n-\t      emit_cmp_and_jump_insns (index, expand_expr (node->high, NULL_RTX,\n-\t\t\t\t\t\t\t   VOIDmode, 0),\n+\t      emit_cmp_and_jump_insns (index,\n+\t\t\t\t       expand_expr (node->high, NULL_RTX,\n+\t\t\t\t\t\t    VOIDmode, 0),\n \t\t\t\t       GT, NULL_RTX, mode, unsignedp, 0,\n \t\t\t\t       default_label);\n \t    }\n \n \t  /* Value belongs to this node or to the left-hand subtree.  */\n \n-\t  emit_cmp_and_jump_insns (index, expand_expr (node->low, NULL_RTX,\n-\t\t\t\t\t\t       VOIDmode, 0),\n+\t  emit_cmp_and_jump_insns (index,\n+\t\t\t\t   expand_expr (node->low, NULL_RTX,\n+\t\t\t\t\t\tVOIDmode, 0),\n \t\t\t\t   GE, NULL_RTX, mode, unsignedp, 0,\n \t\t\t\t   label_rtx (node->code_label));\n \n@@ -6323,16 +6321,18 @@ emit_case_nodes (index, node, default_label, index_type)\n \n \t  if (!node_has_high_bound (node, index_type))\n \t    {\n-\t      emit_cmp_and_jump_insns (index, expand_expr (node->high, NULL_RTX,\n-\t\t\t\t\t\t\t   VOIDmode, 0),\n+\t      emit_cmp_and_jump_insns (index,\n+\t\t\t\t       expand_expr (node->high, NULL_RTX,\n+\t\t\t\t\t\t    VOIDmode, 0),\n \t\t\t\t       GT, NULL_RTX, mode, unsignedp, 0,\n \t\t\t\t       default_label);\n \t    }\n \n \t  if (!node_has_low_bound (node, index_type))\n \t    {\n-\t      emit_cmp_and_jump_insns (index, expand_expr (node->low, NULL_RTX,\n-\t\t\t\t\t\t\t   VOIDmode, 0),\n+\t      emit_cmp_and_jump_insns (index,\n+\t\t\t\t       expand_expr (node->low, NULL_RTX,\n+\t\t\t\t\t\t    VOIDmode, 0),\n \t\t\t\t       LT, NULL_RTX, mode, unsignedp, 0,\n \t\t\t\t       default_label);\n \t    }\n@@ -6341,4 +6341,3 @@ emit_case_nodes (index, node, default_label, index_type)\n \t}\n     }\n }\n-\f"}]}