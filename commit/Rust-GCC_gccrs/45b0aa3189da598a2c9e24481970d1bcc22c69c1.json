{"sha": "45b0aa3189da598a2c9e24481970d1bcc22c69c1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDViMGFhMzE4OWRhNTk4YTJjOWUyNDQ4MTk3MGQxYmNjMjJjNjljMQ==", "commit": {"author": {"name": "Andrew Haley", "email": "aph@cygnus.com", "date": "1999-06-22T23:22:13Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "1999-06-22T23:22:13Z"}, "message": "verify.c (verify_jvm_instructions): Check for pending blocks before invalid PC test and opcode switch, not after.\n\n1999-06-22  Andrew Haley  <aph@cygnus.com>\n\t* verify.c (verify_jvm_instructions): Check for pending blocks\n\tbefore invalid PC test and opcode switch, not after.\n\nFrom-SVN: r27710", "tree": {"sha": "ade4778ad996d42dbabf9b42c45bfe8013509046", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ade4778ad996d42dbabf9b42c45bfe8013509046"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/45b0aa3189da598a2c9e24481970d1bcc22c69c1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45b0aa3189da598a2c9e24481970d1bcc22c69c1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/45b0aa3189da598a2c9e24481970d1bcc22c69c1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45b0aa3189da598a2c9e24481970d1bcc22c69c1/comments", "author": null, "committer": null, "parents": [{"sha": "99d60508020fb9023b3d1e3ab54a0fb2f66cb0c4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/99d60508020fb9023b3d1e3ab54a0fb2f66cb0c4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/99d60508020fb9023b3d1e3ab54a0fb2f66cb0c4"}], "stats": {"total": 141, "additions": 74, "deletions": 67}, "files": [{"sha": "0bea56743353a660517ab553322a801ea655d10a", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45b0aa3189da598a2c9e24481970d1bcc22c69c1/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45b0aa3189da598a2c9e24481970d1bcc22c69c1/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=45b0aa3189da598a2c9e24481970d1bcc22c69c1", "patch": "@@ -1,3 +1,8 @@\n+1999-06-22  Andrew Haley  <aph@cygnus.com>\n+\n+\t* verify.c (verify_jvm_instructions): Check for pending blocks\n+\tbefore invalid PC test and opcode switch, not after.\n+\n 1999-06-21  Andrew Haley  <aph@cygnus.com>\n \n         * except.c (find_handler_in_range): The upper limit for exception"}, {"sha": "27b42862fef358f788f76a261aba80465f089d2c", "filename": "gcc/java/parse-scan.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45b0aa3189da598a2c9e24481970d1bcc22c69c1/gcc%2Fjava%2Fparse-scan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45b0aa3189da598a2c9e24481970d1bcc22c69c1/gcc%2Fjava%2Fparse-scan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse-scan.c?ref=45b0aa3189da598a2c9e24481970d1bcc22c69c1", "patch": "@@ -1375,7 +1375,7 @@ static const short yycheck[] = {     3,\n #define YYPURE 1\n \n /* -*-C-*-  Note some compilers choke on comments on `#line' lines.  */\n-#line 3 \"/x1/java/install/share/bison.simple\"\n+#line 3 \"/x1/java/posix/share/bison.simple\"\n \n /* Skeleton output parser for bison,\n    Copyright (C) 1984, 1989, 1990 Free Software Foundation, Inc.\n@@ -1568,7 +1568,7 @@ __yy_memcpy (char *to, char *from, int count)\n #endif\n #endif\n \f\n-#line 196 \"/x1/java/install/share/bison.simple\"\n+#line 196 \"/x1/java/posix/share/bison.simple\"\n \n /* The user can define YYPARSE_PARAM as the name of an argument to be passed\n    into yyparse.  The argument should have type void *.\n@@ -2156,7 +2156,7 @@ case 337:\n     break;}\n }\n    /* the action file gets copied in in place of this dollarsign */\n-#line 498 \"/x1/java/install/share/bison.simple\"\n+#line 498 \"/x1/java/posix/share/bison.simple\"\n \f\n   yyvsp -= yylen;\n   yyssp -= yylen;"}, {"sha": "7dcd87efeff273a1e651a2ad157707a57a5aecae", "filename": "gcc/java/parse.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45b0aa3189da598a2c9e24481970d1bcc22c69c1/gcc%2Fjava%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45b0aa3189da598a2c9e24481970d1bcc22c69c1/gcc%2Fjava%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.c?ref=45b0aa3189da598a2c9e24481970d1bcc22c69c1", "patch": "@@ -2211,7 +2211,7 @@ static const short yycheck[] = {     3,\n #define YYPURE 1\n \n /* -*-C-*-  Note some compilers choke on comments on `#line' lines.  */\n-#line 3 \"/usr/lib/bison.simple\"\n+#line 3 \"/x1/java/posix/share/bison.simple\"\n \n /* Skeleton output parser for bison,\n    Copyright (C) 1984, 1989, 1990 Free Software Foundation, Inc.\n@@ -2404,7 +2404,7 @@ __yy_memcpy (char *to, char *from, int count)\n #endif\n #endif\n \f\n-#line 196 \"/usr/lib/bison.simple\"\n+#line 196 \"/x1/java/posix/share/bison.simple\"\n \n /* The user can define YYPARSE_PARAM as the name of an argument to be passed\n    into yyparse.  The argument should have type void *.\n@@ -4693,7 +4693,7 @@ case 495:\n     break;}\n }\n    /* the action file gets copied in in place of this dollarsign */\n-#line 498 \"/usr/lib/bison.simple\"\n+#line 498 \"/x1/java/posix/share/bison.simple\"\n \f\n   yyvsp -= yylen;\n   yyssp -= yylen;"}, {"sha": "e367334c46206e61cb7c52f573dfe84a569bcef5", "filename": "gcc/java/verify.c", "status": "modified", "additions": 63, "deletions": 61, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45b0aa3189da598a2c9e24481970d1bcc22c69c1/gcc%2Fjava%2Fverify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45b0aa3189da598a2c9e24481970d1bcc22c69c1/gcc%2Fjava%2Fverify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fverify.c?ref=45b0aa3189da598a2c9e24481970d1bcc22c69c1", "patch": "@@ -427,6 +427,67 @@ verify_jvm_instructions (jcf, byte_ops, length)\n \t  PUSH_PENDING (lookup_label (PC));\n \t  INVALIDATE_PC;\n \t}\n+      /* Check if there are any more pending blocks in the current\n+\t subroutine.  Because we push pending blocks in a\n+\t last-in-first-out order, and because we don't push anything\n+\t from our caller until we are done with this subroutine or\n+\t anything nested in it, then we are done if the top of the\n+\t pending_blocks stack is not in a subroutine, or it is in our\n+\t caller. */\n+      if (current_subr \n+\t  && PC == INVALID_PC)\n+\t{\n+\t  tree caller = LABEL_SUBR_CONTEXT (current_subr);\n+\n+\t  if (pending_blocks == NULL_TREE\n+\t      || ! LABEL_IN_SUBR (pending_blocks)\n+\t      || LABEL_SUBR_START (pending_blocks) == caller)\n+\t    {\n+\t      int size = DECL_MAX_LOCALS(current_function_decl)+stack_pointer;\n+\t      tree ret_map = LABEL_RETURN_TYPE_STATE (current_subr);\n+\t      tmp = LABEL_RETURN_LABELS (current_subr);\n+\t      \n+\t      /* FIXME: If we exit a subroutine via a throw, we might\n+\t\t have returned to an earlier caller.  Obviously a\n+\t\t \"ret\" can only return one level, but a throw may\n+\t\t return many levels.*/\n+\t      current_subr = caller;\n+\n+\t      if (RETURN_MAP_ADJUSTED (ret_map))\n+\t\t{\n+\t\t  /* Since we are done with this subroutine , set up\n+\t\t     the (so far known) return address as pending -\n+\t\t     with the merged type state. */\n+\t\t  for ( ; tmp != NULL_TREE;  tmp = TREE_CHAIN (tmp))\n+\t\t    {\n+\t\t      tree return_label = TREE_VALUE (tmp);\n+\t\t      tree return_state = LABEL_TYPE_STATE (return_label);\n+\t\t      if (return_state == NULL_TREE)\n+\t\t\t{\n+\t\t\t  /* This means means we had not verified the\n+\t\t\t     subroutine earlier, so this is the first jsr to\n+\t\t\t     call it.  In this case, the type_map of the return\n+\t\t\t     address is just the current type_map - and that\n+\t\t\t     is handled by the following PUSH_PENDING. */\n+\t\t\t}\n+\t\t      else\n+\t\t\t{\n+\t\t\t  /* In this case we have to do a merge.  But first\n+\t\t\t     restore the type_map for unused slots to those\n+\t\t\t     that were in effect at the jsr. */\n+\t\t\t  for (index = size;  --index >= 0; )\n+\t\t\t    {\n+\t\t\t      type_map[index] = TREE_VEC_ELT (ret_map, index);\n+\t\t\t      if (type_map[index] == TYPE_UNUSED)\n+\t\t\t\ttype_map[index]\n+\t\t\t\t  = TREE_VEC_ELT (return_state, index);\n+\t\t\t    }\n+\t\t\t}\n+\t\t      PUSH_PENDING (return_label);\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n       if (PC == INVALID_PC)\n \t{\n \t  label = pending_blocks;\n@@ -449,6 +510,8 @@ verify_jvm_instructions (jcf, byte_ops, length)\n       else if (PC >= length)\n \tVERIFICATION_ERROR (\"falling through end of method\");\n \n+      /* fprintf (stderr, \"** %d\\n\", PC); */\n+\n       oldpc = PC;\n \n       if (!(instruction_bits [PC] & BCODE_INSTRUCTION_START) && ! wide)\n@@ -1208,67 +1271,6 @@ verify_jvm_instructions (jcf, byte_ops, length)\n           return 0;\n         }\n \n-\t      /* Check if there are any more pending blocks in this subroutine.\n-\t\t Because we push pending blocks in a last-in-first-out order,\n-\t\t and because we don't push anything from our caller until we\n-\t\t are done with this subroutine or anything nested in it,\n-\t\t then we are done if the top of the pending_blocks stack is\n-\t\t not in a subroutine, or it is in our caller. */\n-      if (current_subr \n-\t  && PC == INVALID_PC)\n-\t{\n-\t  tree caller = LABEL_SUBR_CONTEXT (current_subr);\n-\n-\t      if (pending_blocks == NULL_TREE\n-\t\t  || ! LABEL_IN_SUBR (pending_blocks)\n-\t\t  || LABEL_SUBR_START (pending_blocks) == caller)\n-\t\t{\n-\t      int size = DECL_MAX_LOCALS(current_function_decl)+stack_pointer;\n-\t      tree ret_map = LABEL_RETURN_TYPE_STATE (current_subr);\n-\t      tmp = LABEL_RETURN_LABELS (current_subr);\n-\t      \n-\t      /* FIXME: If we exit a subroutine via a throw, we might\n-\t\t have returned to an earlier caller.  Obviously a\n-\t\t \"ret\" can only return one level, but a throw may\n-\t\t return many levels.*/\n-\t      current_subr = caller;\n-\n-\t      if (RETURN_MAP_ADJUSTED (ret_map))\n-\t\t{\n-\t\t  /* Since we are done with this subroutine , set up\n-\t\t     the (so far known) return address as pending -\n-\t\t     with the merged type state. */\n-\t\t  for ( ; tmp != NULL_TREE;  tmp = TREE_CHAIN (tmp))\n-\t\t    {\n-\t\t      tree return_label = TREE_VALUE (tmp);\n-\t\t      tree return_state = LABEL_TYPE_STATE (return_label);\n-\t\t      if (return_state == NULL_TREE)\n-\t\t\t{\n-\t\t\t  /* This means means we had not verified the\n-\t\t\t     subroutine earlier, so this is the first jsr to\n-\t\t\t     call it.  In this case, the type_map of the return\n-\t\t\t     address is just the current type_map - and that\n-\t\t\t     is handled by the following PUSH_PENDING. */\n-\t\t\t}\n-\t\t      else\n-\t\t\t{\n-\t\t\t  /* In this case we have to do a merge.  But first\n-\t\t\t     restore the type_map for unused slots to those\n-\t\t\t     that were in effect at the jsr. */\n-\t\t\t  for (index = size;  --index >= 0; )\n-\t\t\t    {\n-\t\t\t      type_map[index] = TREE_VEC_ELT (ret_map, index);\n-\t\t\t      if (type_map[index] == TYPE_UNUSED)\n-\t\t\t\ttype_map[index]\n-\t\t\t\t  = TREE_VEC_ELT (return_state, index);\n-\t\t\t    }\n-\t\t\t}\n-\t\t      PUSH_PENDING (return_label);\n-\t\t    }\n-\t\t}\n-\t    }\n-\t}\n-\n       prevpc = oldpc;\n \n       /* The following test is true if we have entered or exited an exception"}]}