{"sha": "823e947359cceb6e29daa616be10bee3528a2296", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODIzZTk0NzM1OWNjZWI2ZTI5ZGFhNjE2YmUxMGJlZTM1MjhhMjI5Ng==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2010-05-13T10:40:51Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2010-05-13T10:40:51Z"}, "message": "re PR debug/43983 (var-tracking needlessly throws away location info for SRAed vars)\n\n\tPR debug/43983\n\t* var-tracking.c (track_expr_p): Allow tracking of variables optimized\n\tby SRA.\n\t* Makefile.in (dwarf2out.o): Depend on $(TREE_FLOW_H).\n\t* tree-sra.c (create_access_replacement): Call unshare_expr before\n\tpassing expr to SET_DECL_DEBUG_EXPR, and remove any SSA_NAMEs from\n\tit.\n\t* dwarf2out.c: Include tree-flow.h.\n\t(struct var_loc_node): Rename var_loc_note field to loc, add comment.\n\t(size_of_loc_descr, output_loc_operands, output_loc_operands_raw):\n\tHandle DW_OP_bit_piece.\n\t(decl_piece_bitsize, decl_piece_varloc_ptr, decl_piece_node,\n\tconstruct_piece_list, adjust_piece_list): New functions.\n\t(add_var_loc_to_decl): Handle SRA optimized variables.\n\tAdjust for var_loc_note to loc field renaming.\n\t(dw_loc_list_1): For WANT_ADDRESS == 2 prefer DECL_MODE of decl\n\tin VAR_LOCATION note.\n\t(new_loc_descr_op_bit_piece): New function.\n\t(dw_sra_loc_expr): New function.\n\t(dw_loc_list): Use it.  Don't handle the last range after the\n\tloop, handle it inside of the loop.  Adjust for var_loc_note\n\tto loc field renaming.\n\t(add_location_or_const_value_attribute): Only special case\n\tsingle entry loc lists if loc is NOTE_P.  Adjust for\n\tvar_loc_note to loc field renaming.\n\t(dwarf2out_var_location): Don't set newloc->var_loc_note\n\tand newloc->next here.\n\n\t* gcc.dg/guality/sra-1.c: New test.\n\nFrom-SVN: r159357", "tree": {"sha": "7efb42d94c06d876f5c682de4761b8455b9223cd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7efb42d94c06d876f5c682de4761b8455b9223cd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/823e947359cceb6e29daa616be10bee3528a2296", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/823e947359cceb6e29daa616be10bee3528a2296", "html_url": "https://github.com/Rust-GCC/gccrs/commit/823e947359cceb6e29daa616be10bee3528a2296", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/823e947359cceb6e29daa616be10bee3528a2296/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d20cfbc2af61a7ac017181d741568c2b46c5e862", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d20cfbc2af61a7ac017181d741568c2b46c5e862", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d20cfbc2af61a7ac017181d741568c2b46c5e862"}], "stats": {"total": 582, "additions": 532, "deletions": 50}, "files": [{"sha": "d031767937e06e562e603e437ce7cc14d070f9eb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/823e947359cceb6e29daa616be10bee3528a2296/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/823e947359cceb6e29daa616be10bee3528a2296/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=823e947359cceb6e29daa616be10bee3528a2296", "patch": "@@ -1,3 +1,33 @@\n+2010-05-13  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR debug/43983\n+\t* var-tracking.c (track_expr_p): Allow tracking of variables optimized\n+\tby SRA.\n+\t* Makefile.in (dwarf2out.o): Depend on $(TREE_FLOW_H).\n+\t* tree-sra.c (create_access_replacement): Call unshare_expr before\n+\tpassing expr to SET_DECL_DEBUG_EXPR, and remove any SSA_NAMEs from\n+\tit.\n+\t* dwarf2out.c: Include tree-flow.h.\n+\t(struct var_loc_node): Rename var_loc_note field to loc, add comment.\n+\t(size_of_loc_descr, output_loc_operands, output_loc_operands_raw):\n+\tHandle DW_OP_bit_piece.\n+\t(decl_piece_bitsize, decl_piece_varloc_ptr, decl_piece_node,\n+\tconstruct_piece_list, adjust_piece_list): New functions.\n+\t(add_var_loc_to_decl): Handle SRA optimized variables.\n+\tAdjust for var_loc_note to loc field renaming.\n+\t(dw_loc_list_1): For WANT_ADDRESS == 2 prefer DECL_MODE of decl\n+\tin VAR_LOCATION note.\n+\t(new_loc_descr_op_bit_piece): New function.\n+\t(dw_sra_loc_expr): New function.\n+\t(dw_loc_list): Use it.  Don't handle the last range after the\n+\tloop, handle it inside of the loop.  Adjust for var_loc_note\n+\tto loc field renaming.\n+\t(add_location_or_const_value_attribute): Only special case\n+\tsingle entry loc lists if loc is NOTE_P.  Adjust for\n+\tvar_loc_note to loc field renaming.\n+\t(dwarf2out_var_location): Don't set newloc->var_loc_note\n+\tand newloc->next here.\n+\n 2010-05-12  Jan Hubicka  <jh@suse.cz>\n \n \t* cgraph.c (cgraph_mark_address_taken_node): No longer imply needed flag."}, {"sha": "3ce9d603af98ceaa9e0b19f62621235bb870d464", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/823e947359cceb6e29daa616be10bee3528a2296/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/823e947359cceb6e29daa616be10bee3528a2296/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=823e947359cceb6e29daa616be10bee3528a2296", "patch": "@@ -2846,7 +2846,7 @@ dwarf2out.o : dwarf2out.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    output.h $(DIAGNOSTIC_H) $(REAL_H) hard-reg-set.h $(REGS_H) $(EXPR_H) \\\n    libfuncs.h $(TOPLEV_H) dwarf2out.h reload.h $(GGC_H) $(EXCEPT_H) dwarf2asm.h \\\n    $(TM_P_H) langhooks.h $(HASHTAB_H) gt-dwarf2out.h $(TARGET_H) $(CGRAPH_H) \\\n-   $(MD5_H) $(INPUT_H) $(FUNCTION_H) $(GIMPLE_H) $(TREE_PASS_H)\n+   $(MD5_H) $(INPUT_H) $(FUNCTION_H) $(GIMPLE_H) $(TREE_PASS_H) $(TREE_FLOW_H)\n dwarf2asm.o : dwarf2asm.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(FLAGS_H) $(RTL_H) $(TREE_H) output.h dwarf2asm.h $(TM_P_H) $(GGC_H) \\\n    gt-dwarf2asm.h $(DWARF2_H) $(SPLAY_TREE_H) $(TARGET_H)"}, {"sha": "fc941e2bde9436abac8c38af0c9dc717e154b205", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 392, "deletions": 45, "changes": 437, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/823e947359cceb6e29daa616be10bee3528a2296/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/823e947359cceb6e29daa616be10bee3528a2296/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=823e947359cceb6e29daa616be10bee3528a2296", "patch": "@@ -91,6 +91,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"input.h\"\n #include \"gimple.h\"\n #include \"tree-pass.h\"\n+#include \"tree-flow.h\"\n \n #ifdef DWARF2_DEBUGGING_INFO\n static void dwarf2out_source_line (unsigned int, const char *, int, bool);\n@@ -4784,6 +4785,10 @@ size_of_loc_descr (dw_loc_descr_ref loc)\n     case DW_OP_piece:\n       size += size_of_uleb128 (loc->dw_loc_oprnd1.v.val_unsigned);\n       break;\n+    case DW_OP_bit_piece:\n+      size += size_of_uleb128 (loc->dw_loc_oprnd1.v.val_unsigned);\n+      size += size_of_uleb128 (loc->dw_loc_oprnd2.v.val_unsigned);\n+      break;\n     case DW_OP_deref_size:\n     case DW_OP_xderef_size:\n       size += 1;\n@@ -5008,6 +5013,10 @@ output_loc_operands (dw_loc_descr_ref loc)\n     case DW_OP_piece:\n       dw2_asm_output_data_uleb128 (val1->v.val_unsigned, NULL);\n       break;\n+    case DW_OP_bit_piece:\n+      dw2_asm_output_data_uleb128 (val1->v.val_unsigned, NULL);\n+      dw2_asm_output_data_uleb128 (val2->v.val_unsigned, NULL);\n+      break;\n     case DW_OP_deref_size:\n     case DW_OP_xderef_size:\n       dw2_asm_output_data (1, val1->v.val_int, NULL);\n@@ -5123,6 +5132,12 @@ output_loc_operands_raw (dw_loc_descr_ref loc)\n       dw2_asm_output_data_uleb128_raw (val1->v.val_unsigned);\n       break;\n \n+    case DW_OP_bit_piece:\n+      fputc (',', asm_out_file);\n+      dw2_asm_output_data_uleb128_raw (val1->v.val_unsigned);\n+      dw2_asm_output_data_uleb128_raw (val2->v.val_unsigned);\n+      break;\n+\n     case DW_OP_consts:\n     case DW_OP_breg0:\n     case DW_OP_breg1:\n@@ -5739,7 +5754,15 @@ DEF_VEC_ALLOC_O(die_arg_entry,gc);\n \n /* Node of the variable location list.  */\n struct GTY ((chain_next (\"%h.next\"))) var_loc_node {\n-  rtx GTY (()) var_loc_note;\n+  /* Either NOTE_INSN_VAR_LOCATION, or, for SRA optimized variables,\n+     EXPR_LIST chain.  For small bitsizes, bitsize is encoded\n+     in mode of the EXPR_LIST node and first EXPR_LIST operand\n+     is either NOTE_INSN_VAR_LOCATION for a piece with a known\n+     location or NULL for padding.  For larger bitsizes,\n+     mode is 0 and first operand is a CONCAT with bitsize\n+     as first CONCAT operand and NOTE_INSN_VAR_LOCATION resp.\n+     NULL as second operand.  */\n+  rtx GTY (()) loc;\n   const char * GTY (()) label;\n   struct var_loc_node * GTY (()) next;\n };\n@@ -7757,16 +7780,175 @@ equate_decl_number_to_die (tree decl, dw_die_ref decl_die)\n   decl_die->decl_id = decl_id;\n }\n \n+/* Return how many bits covers PIECE EXPR_LIST.  */\n+\n+static int\n+decl_piece_bitsize (rtx piece)\n+{\n+  int ret = (int) GET_MODE (piece);\n+  if (ret)\n+    return ret;\n+  gcc_assert (GET_CODE (XEXP (piece, 0)) == CONCAT\n+\t      && CONST_INT_P (XEXP (XEXP (piece, 0), 0)));\n+  return INTVAL (XEXP (XEXP (piece, 0), 0));\n+}\n+\n+/* Return pointer to the location of location note in PIECE EXPR_LIST.  */\n+\n+static rtx *\n+decl_piece_varloc_ptr (rtx piece)\n+{\n+  if ((int) GET_MODE (piece))\n+    return &XEXP (piece, 0);\n+  else\n+    return &XEXP (XEXP (piece, 0), 1);\n+}\n+\n+/* Create an EXPR_LIST for location note LOC_NOTE covering BITSIZE bits.\n+   Next is the chain of following piece nodes.  */\n+\n+static rtx\n+decl_piece_node (rtx loc_note, HOST_WIDE_INT bitsize, rtx next)\n+{\n+  if (bitsize <= (int) MAX_MACHINE_MODE)\n+    return alloc_EXPR_LIST (bitsize, loc_note, next);\n+  else\n+    return alloc_EXPR_LIST (0, gen_rtx_CONCAT (VOIDmode,\n+\t\t\t\t\t       GEN_INT (bitsize),\n+\t\t\t\t\t       loc_note), next);\n+}\n+\n+/* Return rtx that should be stored into loc field for\n+   LOC_NOTE and BITPOS/BITSIZE.  */\n+\n+static rtx\n+construct_piece_list (rtx loc_note, HOST_WIDE_INT bitpos,\n+\t\t      HOST_WIDE_INT bitsize)\n+{\n+  if (bitsize != -1)\n+    {\n+      loc_note = decl_piece_node (loc_note, bitsize, NULL_RTX);\n+      if (bitpos != 0)\n+\tloc_note = decl_piece_node (NULL_RTX, bitpos, loc_note);\n+    }\n+  return loc_note;\n+}\n+\n+/* This function either modifies location piece list *DEST in\n+   place (if SRC and INNER is NULL), or copies location piece list\n+   *SRC to *DEST while modifying it.  Location BITPOS is modified\n+   to contain LOC_NOTE, any pieces overlapping it are removed resp.\n+   not copied and if needed some padding around it is added.\n+   When modifying in place, DEST should point to EXPR_LIST where\n+   earlier pieces cover PIECE_BITPOS bits, when copying SRC points\n+   to the start of the whole list and INNER points to the EXPR_LIST\n+   where earlier pieces cover PIECE_BITPOS bits.  */\n+\n+static void\n+adjust_piece_list (rtx *dest, rtx *src, rtx *inner,\n+\t\t   HOST_WIDE_INT bitpos, HOST_WIDE_INT piece_bitpos,\n+\t\t   HOST_WIDE_INT bitsize, rtx loc_note)\n+{\n+  int diff;\n+  bool copy = inner != NULL;\n+\n+  if (copy)\n+    {\n+      /* First copy all nodes preceeding the current bitpos.  */\n+      while (src != inner)\n+\t{\n+\t  *dest = decl_piece_node (*decl_piece_varloc_ptr (*src),\n+\t\t\t\t   decl_piece_bitsize (*src), NULL_RTX);\n+\t  dest = &XEXP (*dest, 1);\n+\t  src = &XEXP (*src, 1);\n+\t}\n+    }\n+  /* Add padding if needed.  */\n+  if (bitpos != piece_bitpos)\n+    {\n+      *dest = decl_piece_node (NULL_RTX, bitpos - piece_bitpos,\n+\t\t\t       copy ? NULL_RTX : *dest);\n+      dest = &XEXP (*dest, 1);\n+    }\n+  else if (*dest && decl_piece_bitsize (*dest) == bitsize)\n+    {\n+      gcc_assert (!copy);\n+      /* A piece with correct bitpos and bitsize already exist,\n+\t just update the location for it and return.  */\n+      *decl_piece_varloc_ptr (*dest) = loc_note;\n+      return;\n+    }\n+  /* Add the piece that changed.  */\n+  *dest = decl_piece_node (loc_note, bitsize, copy ? NULL_RTX : *dest);\n+  dest = &XEXP (*dest, 1);\n+  /* Skip over pieces that overlap it.  */\n+  diff = bitpos - piece_bitpos + bitsize;\n+  if (!copy)\n+    src = dest;\n+  while (diff > 0 && *src)\n+    {\n+      rtx piece = *src;\n+      diff -= decl_piece_bitsize (piece);\n+      if (copy)\n+\tsrc = &XEXP (piece, 1);\n+      else\n+\t{\n+\t  *src = XEXP (piece, 1);\n+\t  free_EXPR_LIST_node (piece);\n+\t}\n+    }\n+  /* Add padding if needed.  */\n+  if (diff < 0 && *src)\n+    {\n+      if (!copy)\n+\tdest = src;\n+      *dest = decl_piece_node (NULL_RTX, -diff, copy ? NULL_RTX : *dest);\n+      dest = &XEXP (*dest, 1);\n+    }\n+  if (!copy)\n+    return;\n+  /* Finally copy all nodes following it.  */\n+  while (*src)\n+    {\n+      *dest = decl_piece_node (*decl_piece_varloc_ptr (*src),\n+\t\t\t       decl_piece_bitsize (*src), NULL_RTX);\n+      dest = &XEXP (*dest, 1);\n+      src = &XEXP (*src, 1);\n+    }\n+}\n+\n /* Add a variable location node to the linked list for DECL.  */\n \n static struct var_loc_node *\n add_var_loc_to_decl (tree decl, rtx loc_note, const char *label)\n {\n-  unsigned int decl_id = DECL_UID (decl);\n+  unsigned int decl_id;\n   var_loc_list *temp;\n   void **slot;\n   struct var_loc_node *loc = NULL;\n+  HOST_WIDE_INT bitsize = -1, bitpos = -1;\n+\n+  if (DECL_DEBUG_EXPR_IS_FROM (decl))\n+    {\n+      tree realdecl = DECL_DEBUG_EXPR (decl);\n+      if (realdecl && handled_component_p (realdecl))\n+\t{\n+\t  HOST_WIDE_INT maxsize;\n+\t  tree innerdecl;\n+\t  innerdecl\n+\t    = get_ref_base_and_extent (realdecl, &bitpos, &bitsize, &maxsize);\n+\t  if (!DECL_P (innerdecl)\n+\t      || DECL_IGNORED_P (innerdecl)\n+\t      || TREE_STATIC (innerdecl)\n+\t      || bitsize <= 0\n+\t      || bitpos + bitsize > 256\n+\t      || bitsize != maxsize)\n+\t    return NULL;\n+\t  decl = innerdecl;\n+\t}\n+    }\n \n+  decl_id = DECL_UID (decl);\n   slot = htab_find_slot_with_hash (decl_loc_table, decl, decl_id, INSERT);\n   if (*slot == NULL)\n     {\n@@ -7780,17 +7962,40 @@ add_var_loc_to_decl (tree decl, rtx loc_note, const char *label)\n   if (temp->last)\n     {\n       struct var_loc_node *last = temp->last, *unused = NULL;\n+      rtx *piece_loc = NULL, last_loc_note;\n+      int piece_bitpos = 0;\n       if (last->next)\n \t{\n \t  last = last->next;\n \t  gcc_assert (last->next == NULL);\n \t}\n+      if (bitsize != -1 && GET_CODE (last->loc) == EXPR_LIST)\n+\t{\n+\t  piece_loc = &last->loc;\n+\t  do\n+\t    {\n+\t      int cur_bitsize = decl_piece_bitsize (*piece_loc);\n+\t      if (piece_bitpos + cur_bitsize > bitpos)\n+\t\tbreak;\n+\t      piece_bitpos += cur_bitsize;\n+\t      piece_loc = &XEXP (*piece_loc, 1);\n+\t    }\n+\t  while (*piece_loc);\n+\t}\n       /* TEMP->LAST here is either pointer to the last but one or\n \t last element in the chained list, LAST is pointer to the\n \t last element.  */\n-      /* If the last note doesn't cover any instructions, remove it.  */\n       if (label && strcmp (last->label, label) == 0)\n \t{\n+\t  /* For SRA optimized variables if there weren't any real\n+\t     insns since last note, just modify the last node.  */\n+\t  if (piece_loc != NULL)\n+\t    {\n+\t      adjust_piece_list (piece_loc, NULL, NULL,\n+\t\t\t\t bitpos, piece_bitpos, bitsize, loc_note);\n+\t      return NULL;\n+\t    }\n+\t  /* If the last note doesn't cover any instructions, remove it.  */\n \t  if (temp->last != last)\n \t    {\n \t      temp->last->next = NULL;\n@@ -7802,17 +8007,28 @@ add_var_loc_to_decl (tree decl, rtx loc_note, const char *label)\n \t    {\n \t      gcc_assert (temp->first == temp->last);\n \t      memset (temp->last, '\\0', sizeof (*temp->last));\n+\t      temp->last->loc = construct_piece_list (loc_note, bitpos, bitsize);\n \t      return temp->last;\n \t    }\n \t}\n+      if (bitsize == -1 && NOTE_P (last->loc))\n+\tlast_loc_note = last->loc;\n+      else if (piece_loc != NULL\n+\t       && *piece_loc != NULL_RTX\n+\t       && piece_bitpos == bitpos\n+\t       && decl_piece_bitsize (*piece_loc) == bitsize)\n+\tlast_loc_note = *decl_piece_varloc_ptr (*piece_loc);\n+      else\n+\tlast_loc_note = NULL_RTX;\n       /* If the current location is the same as the end of the list,\n \t and either both or neither of the locations is uninitialized,\n \t we have nothing to do.  */\n-      if ((!rtx_equal_p (NOTE_VAR_LOCATION_LOC (last->var_loc_note),\n-\t\t\t NOTE_VAR_LOCATION_LOC (loc_note)))\n-\t  || ((NOTE_VAR_LOCATION_STATUS (last->var_loc_note)\n+      if (last_loc_note == NULL_RTX\n+\t  || (!rtx_equal_p (NOTE_VAR_LOCATION_LOC (last_loc_note),\n+\t\t\t    NOTE_VAR_LOCATION_LOC (loc_note)))\n+\t  || ((NOTE_VAR_LOCATION_STATUS (last_loc_note)\n \t       != NOTE_VAR_LOCATION_STATUS (loc_note))\n-\t      && ((NOTE_VAR_LOCATION_STATUS (last->var_loc_note)\n+\t      && ((NOTE_VAR_LOCATION_STATUS (last_loc_note)\n \t\t   == VAR_INIT_STATUS_UNINITIALIZED)\n \t\t  || (NOTE_VAR_LOCATION_STATUS (loc_note)\n \t\t      == VAR_INIT_STATUS_UNINITIALIZED))))\n@@ -7827,6 +8043,11 @@ add_var_loc_to_decl (tree decl, rtx loc_note, const char *label)\n \t    }\n \t  else\n \t    loc = GGC_CNEW (struct var_loc_node);\n+\t  if (bitsize == -1 || piece_loc == NULL)\n+\t    loc->loc = construct_piece_list (loc_note, bitpos, bitsize);\n+\t  else\n+\t    adjust_piece_list (&loc->loc, &last->loc, piece_loc,\n+\t\t\t       bitpos, piece_bitpos, bitsize, loc_note);\n \t  last->next = loc;\n \t  /* Ensure TEMP->LAST will point either to the new last but one\n \t     element of the chain, or to the last element in it.  */\n@@ -7841,6 +8062,7 @@ add_var_loc_to_decl (tree decl, rtx loc_note, const char *label)\n       loc = GGC_CNEW (struct var_loc_node);\n       temp->first = loc;\n       temp->last = loc;\n+      loc->loc = construct_piece_list (loc_note, bitpos, bitsize);\n     }\n   return loc;\n }\n@@ -14084,7 +14306,11 @@ dw_loc_list_1 (tree loc, rtx varloc, int want_address,\n     }\n   else\n     {\n-      descr = loc_descriptor (varloc, DECL_MODE (loc), initialized);\n+      if (GET_CODE (varloc) == VAR_LOCATION)\n+\tmode = DECL_MODE (PAT_VAR_LOCATION_DECL (varloc));\n+      else\n+\tmode = DECL_MODE (loc);\n+      descr = loc_descriptor (varloc, mode, initialized);\n       have_address = 1;\n     }\n \n@@ -14134,6 +14360,125 @@ dw_loc_list_1 (tree loc, rtx varloc, int want_address,\n   return descr;\n }\n \n+/* Create a DW_OP_piece or DW_OP_bit_piece for bitsize, or return NULL\n+   if it is not possible.  */\n+\n+static dw_loc_descr_ref\n+new_loc_descr_op_bit_piece (HOST_WIDE_INT bitsize)\n+{\n+  if ((bitsize % BITS_PER_UNIT) == 0)\n+    return new_loc_descr (DW_OP_piece, bitsize / BITS_PER_UNIT, 0);\n+  else if (dwarf_version >= 3 || !dwarf_strict)\n+    return new_loc_descr (DW_OP_bit_piece, bitsize, 0);\n+  else\n+    return NULL;\n+}\n+\n+/* Helper function for dw_loc_list.  Compute proper Dwarf location descriptor\n+   for VAR_LOC_NOTE for variable DECL that has been optimized by SRA.  */\n+\n+static dw_loc_descr_ref\n+dw_sra_loc_expr (tree decl, rtx loc)\n+{\n+  rtx p;\n+  unsigned int padsize = 0;\n+  dw_loc_descr_ref descr, *descr_tail;\n+  unsigned HOST_WIDE_INT decl_size;\n+  rtx varloc;\n+  enum var_init_status initialized;\n+\n+  if (DECL_SIZE (decl) == NULL\n+      || !host_integerp (DECL_SIZE (decl), 1))\n+    return NULL;\n+\n+  decl_size = tree_low_cst (DECL_SIZE (decl), 1);\n+  descr = NULL;\n+  descr_tail = &descr;\n+\n+  for (p = loc; p; p = XEXP (p, 1))\n+    {\n+      unsigned int bitsize = decl_piece_bitsize (p);\n+      rtx loc_note = *decl_piece_varloc_ptr (p);\n+      dw_loc_descr_ref cur_descr;\n+      dw_loc_descr_ref *tail, last = NULL;\n+      unsigned int opsize = 0;\n+\n+      if (loc_note == NULL_RTX\n+\t  || NOTE_VAR_LOCATION_LOC (loc_note) == NULL_RTX)\n+\t{\n+\t  padsize += bitsize;\n+\t  continue;\n+\t}\n+      initialized = NOTE_VAR_LOCATION_STATUS (loc_note);\n+      varloc = NOTE_VAR_LOCATION (loc_note);\n+      cur_descr = dw_loc_list_1 (decl, varloc, 2, initialized);\n+      if (cur_descr == NULL)\n+\t{\n+\t  padsize += bitsize;\n+\t  continue;\n+\t}\n+\n+      /* Check that cur_descr either doesn't use\n+\t DW_OP_*piece operations, or their sum is equal\n+\t to bitsize.  Otherwise we can't embed it.  */\n+      for (tail = &cur_descr; *tail != NULL;\n+\t   tail = &(*tail)->dw_loc_next)\n+\tif ((*tail)->dw_loc_opc == DW_OP_piece)\n+\t  {\n+\t    opsize += (*tail)->dw_loc_oprnd1.v.val_unsigned\n+\t\t      * BITS_PER_UNIT;\n+\t    last = *tail;\n+\t  }\n+\telse if ((*tail)->dw_loc_opc == DW_OP_bit_piece)\n+\t  {\n+\t    opsize += (*tail)->dw_loc_oprnd1.v.val_unsigned;\n+\t    last = *tail;\n+\t  }\n+\n+      if (last != NULL && opsize != bitsize)\n+\t{\n+\t  padsize += bitsize;\n+\t  continue;\n+\t}\n+\n+      /* If there is a hole, add DW_OP_*piece after empty DWARF\n+\t expression, which means that those bits are optimized out.  */\n+      if (padsize)\n+\t{\n+\t  if (padsize > decl_size)\n+\t    return NULL;\n+\t  decl_size -= padsize;\n+\t  *descr_tail = new_loc_descr_op_bit_piece (padsize);\n+\t  if (*descr_tail == NULL)\n+\t    return NULL;\n+\t  descr_tail = &(*descr_tail)->dw_loc_next;\n+\t  padsize = 0;\n+\t}\n+      *descr_tail = cur_descr;\n+      descr_tail = tail;\n+      if (bitsize > decl_size)\n+\treturn NULL;\n+      decl_size -= bitsize;\n+      if (last == NULL)\n+\t{\n+\t  *descr_tail = new_loc_descr_op_bit_piece (bitsize);\n+\t  if (*descr_tail == NULL)\n+\t    return NULL;\n+\t  descr_tail = &(*descr_tail)->dw_loc_next;\n+\t}\n+    }\n+\n+  /* If there were any non-empty expressions, add padding till the end of\n+     the decl.  */\n+  if (descr != NULL && decl_size != 0)\n+    {\n+      *descr_tail = new_loc_descr_op_bit_piece (decl_size);\n+      if (*descr_tail == NULL)\n+\treturn NULL;\n+    }\n+  return descr;\n+}\n+\n /* Return the dwarf representation of the location list LOC_LIST of\n    DECL.  WANT_ADDRESS has the same meaning as in loc_list_from_tree\n    function.  */\n@@ -14163,45 +14508,48 @@ dw_loc_list (var_loc_list *loc_list, tree decl, int want_address)\n \n   secname = secname_for_decl (decl);\n \n-  for (node = loc_list->first; node->next; node = node->next)\n-    if (NOTE_VAR_LOCATION_LOC (node->var_loc_note) != NULL_RTX)\n+  for (node = loc_list->first; node; node = node->next)\n+    if (GET_CODE (node->loc) == EXPR_LIST\n+\t|| NOTE_VAR_LOCATION_LOC (node->loc) != NULL_RTX)\n       {\n-\t/* The variable has a location between NODE->LABEL and\n-\t   NODE->NEXT->LABEL.  */\n-\tinitialized = NOTE_VAR_LOCATION_STATUS (node->var_loc_note);\n-\tvarloc = NOTE_VAR_LOCATION (node->var_loc_note);\n-\tdescr = dw_loc_list_1 (decl, varloc, want_address, initialized);\n+\tif (GET_CODE (node->loc) == EXPR_LIST)\n+\t  {\n+\t    /* This requires DW_OP_{,bit_}piece, which is not usable\n+\t       inside DWARF expressions.  */\n+\t    if (want_address != 2)\n+\t      continue;\n+\t    descr = dw_sra_loc_expr (decl, node->loc);\n+\t    if (descr == NULL)\n+\t      continue;\n+\t  }\n+\telse\n+\t  {\n+\t    initialized = NOTE_VAR_LOCATION_STATUS (node->loc);\n+\t    varloc = NOTE_VAR_LOCATION (node->loc);\n+\t    descr = dw_loc_list_1 (decl, varloc, want_address, initialized);\n+\t  }\n \tif (descr)\n \t  {\n-\t    *listp = new_loc_list (descr, node->label, node->next->label,\n-\t\t\t\t   secname);\n+\t    /* The variable has a location between NODE->LABEL and\n+\t       NODE->NEXT->LABEL.  */\n+\t    if (node->next)\n+\t      endname = node->next->label;\n+\t    /* If the variable has a location at the last label\n+\t       it keeps its location until the end of function.  */\n+\t    else if (!current_function_decl)\n+\t      endname = text_end_label;\n+\t    else\n+\t      {\n+\t\tASM_GENERATE_INTERNAL_LABEL (label_id, FUNC_END_LABEL,\n+\t\t\t\t\t     current_function_funcdef_no);\n+\t\tendname = ggc_strdup (label_id);\n+\t      }\n+\n+\t    *listp = new_loc_list (descr, node->label, endname, secname);\n \t    listp = &(*listp)->dw_loc_next;\n \t  }\n       }\n \n-  /* If the variable has a location at the last label\n-     it keeps its location until the end of function.  */\n-  if (NOTE_VAR_LOCATION_LOC (node->var_loc_note) != NULL_RTX)\n-    {\n-      initialized = NOTE_VAR_LOCATION_STATUS (node->var_loc_note);\n-      varloc = NOTE_VAR_LOCATION (node->var_loc_note);\n-      descr = dw_loc_list_1 (decl, varloc, want_address, initialized);\n-      if (descr)\n-\t{\n-\t  if (!current_function_decl)\n-\t    endname = text_end_label;\n-\t  else\n-\t    {\n-\t      ASM_GENERATE_INTERNAL_LABEL (label_id, FUNC_END_LABEL,\n-\t\t\t\t\t   current_function_funcdef_no);\n-\t      endname = ggc_strdup (label_id);\n-\t    }\n-\n-\t  *listp = new_loc_list (descr, node->label, endname, secname);\n-\t  listp = &(*listp)->dw_loc_next;\n-\t}\n-    }\n-\n   /* Try to avoid the overhead of a location list emitting a location\n      expression instead, but only if we didn't have more than one\n      location entry in the first place.  If some entries were not\n@@ -15950,13 +16298,14 @@ add_location_or_const_value_attribute (dw_die_ref die, tree decl,\n   if (loc_list\n       && loc_list->first\n       && loc_list->first->next == NULL\n-      && NOTE_VAR_LOCATION (loc_list->first->var_loc_note)\n-      && NOTE_VAR_LOCATION_LOC (loc_list->first->var_loc_note))\n+      && NOTE_P (loc_list->first->loc)\n+      && NOTE_VAR_LOCATION (loc_list->first->loc)\n+      && NOTE_VAR_LOCATION_LOC (loc_list->first->loc))\n     {\n       struct var_loc_node *node;\n \n       node = loc_list->first;\n-      rtl = NOTE_VAR_LOCATION_LOC (node->var_loc_note);\n+      rtl = NOTE_VAR_LOCATION_LOC (node->loc);\n       if (GET_CODE (rtl) == EXPR_LIST)\n \trtl = XEXP (rtl, 0);\n       if ((CONSTANT_P (rtl) || GET_CODE (rtl) == CONST_STRING)\n@@ -20458,8 +20807,6 @@ dwarf2out_var_location (rtx loc_note)\n       loclabel_num++;\n       last_label = ggc_strdup (loclabel);\n     }\n-  newloc->var_loc_note = loc_note;\n-  newloc->next = NULL;\n \n   if (!NOTE_DURING_CALL_P (loc_note))\n     newloc->label = last_label;"}, {"sha": "8b0418c4b39b0f979ea0d17f1fdf8842c6030816", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/823e947359cceb6e29daa616be10bee3528a2296/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/823e947359cceb6e29daa616be10bee3528a2296/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=823e947359cceb6e29daa616be10bee3528a2296", "patch": "@@ -1,3 +1,8 @@\n+2010-05-13  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR debug/43983\n+\t* gcc.dg/guality/sra-1.c: New test.\n+\n 2010-05-12  Jan Hubicka  <jh@suse.cz>\n \n \t* tree-ssa/unreachable.c: New test."}, {"sha": "feb115821aa90e2666973dcd530142914e22e1c0", "filename": "gcc/testsuite/gcc.dg/guality/sra-1.c", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/823e947359cceb6e29daa616be10bee3528a2296/gcc%2Ftestsuite%2Fgcc.dg%2Fguality%2Fsra-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/823e947359cceb6e29daa616be10bee3528a2296/gcc%2Ftestsuite%2Fgcc.dg%2Fguality%2Fsra-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fguality%2Fsra-1.c?ref=823e947359cceb6e29daa616be10bee3528a2296", "patch": "@@ -0,0 +1,56 @@\n+/* PR debug/43983 */\n+/* { dg-do run } */\n+/* { dg-options \"-g\" } */\n+\n+struct A { int i; int j; };\n+struct B { int : 4; int i : 12; int j : 12; int : 4; };\n+\n+__attribute__((noinline)) void\n+bar (int x)\n+{\n+  asm volatile (\"\" : : \"r\" (x) : \"memory\");\n+}\n+\n+__attribute__((noinline)) int\n+f1 (int k)\n+{\n+  struct A a = { 4, k + 6 };\n+  asm (\"\" : \"+r\" (a.i));\n+  a.j++;\n+  bar (a.i);\t\t/* { dg-final { gdb-test 20 \"a.i\" \"4\" } } */\n+  bar (a.j);\t\t/* { dg-final { gdb-test 20 \"a.j\" \"14\" } } */\n+  return a.i + a.j;\n+}\n+\n+__attribute__((noinline)) int\n+f2 (int k)\n+{\n+  int a[2] = { 4, k + 6 };\n+  asm (\"\" : \"+r\" (a[0]));\n+  a[1]++;\n+  bar (a[0]);\t\t/* { dg-final { gdb-test 31 \"a\\[0\\]\" \"4\" } } */\n+  bar (a[1]);\t\t/* { dg-final { gdb-test 31 \"a\\[1\\]\" \"14\" } } */\n+  return a[0] + a[1];\n+}\n+\n+__attribute__((noinline)) int\n+f3 (int k)\n+{\n+  struct B a = { 4, k + 6 };\n+  asm (\"\" : \"+r\" (a.i));\n+  a.j++;\n+  bar (a.i);\t\t/* { dg-final { gdb-test 42 \"a.i\" \"4\" } } */\n+  bar (a.j);\t\t/* { dg-final { gdb-test 42 \"a.j\" \"14\" } } */\n+  return a.i + a.j;\n+}\n+\n+int\n+main (void)\n+{\n+  int k;\n+  asm (\"\" : \"=r\" (k) : \"0\" (7));\n+  f1 (k);\n+  f2 (k);\n+  f3 (k);\n+  return 0;\n+}"}, {"sha": "33144d7f1829850ec7714a26cd2dd51a3667b407", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 28, "deletions": 1, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/823e947359cceb6e29daa616be10bee3528a2296/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/823e947359cceb6e29daa616be10bee3528a2296/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=823e947359cceb6e29daa616be10bee3528a2296", "patch": "@@ -1609,11 +1609,38 @@ create_access_replacement (struct access *access)\n       && !DECL_ARTIFICIAL (access->base))\n     {\n       char *pretty_name = make_fancy_name (access->expr);\n+      tree debug_expr = unshare_expr (access->expr), d;\n \n       DECL_NAME (repl) = get_identifier (pretty_name);\n       obstack_free (&name_obstack, pretty_name);\n \n-      SET_DECL_DEBUG_EXPR (repl, access->expr);\n+      /* Get rid of any SSA_NAMEs embedded in debug_expr,\n+\t as DECL_DEBUG_EXPR isn't considered when looking for still\n+\t used SSA_NAMEs and thus they could be freed.  All debug info\n+\t generation cares is whether something is constant or variable\n+\t and that get_ref_base_and_extent works properly on the\n+\t expression.  */\n+      for (d = debug_expr; handled_component_p (d); d = TREE_OPERAND (d, 0))\n+\tswitch (TREE_CODE (d))\n+\t  {\n+\t  case ARRAY_REF:\n+\t  case ARRAY_RANGE_REF:\n+\t    if (TREE_OPERAND (d, 1)\n+\t\t&& TREE_CODE (TREE_OPERAND (d, 1)) == SSA_NAME)\n+\t      TREE_OPERAND (d, 1) = SSA_NAME_VAR (TREE_OPERAND (d, 1));\n+\t    if (TREE_OPERAND (d, 3)\n+\t\t&& TREE_CODE (TREE_OPERAND (d, 3)) == SSA_NAME)\n+\t      TREE_OPERAND (d, 3) = SSA_NAME_VAR (TREE_OPERAND (d, 3));\n+\t    /* FALLTHRU */\n+\t  case COMPONENT_REF:\n+\t    if (TREE_OPERAND (d, 2)\n+\t\t&& TREE_CODE (TREE_OPERAND (d, 2)) == SSA_NAME)\n+\t      TREE_OPERAND (d, 2) = SSA_NAME_VAR (TREE_OPERAND (d, 2));\n+\t    break;\n+\t  default:\n+\t    break;\n+\t  }\n+      SET_DECL_DEBUG_EXPR (repl, debug_expr);\n       DECL_DEBUG_EXPR_IS_FROM (repl) = 1;\n       TREE_NO_WARNING (repl) = TREE_NO_WARNING (access->base);\n     }"}, {"sha": "c980da6d05a952592e5e68c55928ea32e121265e", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 20, "deletions": 3, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/823e947359cceb6e29daa616be10bee3528a2296/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/823e947359cceb6e29daa616be10bee3528a2296/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=823e947359cceb6e29daa616be10bee3528a2296", "patch": "@@ -4505,10 +4505,27 @@ track_expr_p (tree expr, bool need_rtl)\n       realdecl = DECL_DEBUG_EXPR (realdecl);\n       if (realdecl == NULL_TREE)\n \trealdecl = expr;\n-      /* ??? We don't yet know how to emit DW_OP_piece for variable\n-\t that has been SRA'ed.  */\n       else if (!DECL_P (realdecl))\n-\treturn 0;\n+\t{\n+\t  if (handled_component_p (realdecl))\n+\t    {\n+\t      HOST_WIDE_INT bitsize, bitpos, maxsize;\n+\t      tree innerdecl\n+\t\t= get_ref_base_and_extent (realdecl, &bitpos, &bitsize,\n+\t\t\t\t\t   &maxsize);\n+\t      if (!DECL_P (innerdecl)\n+\t\t  || DECL_IGNORED_P (innerdecl)\n+\t\t  || TREE_STATIC (innerdecl)\n+\t\t  || bitsize <= 0\n+\t\t  || bitpos + bitsize > 256\n+\t\t  || bitsize != maxsize)\n+\t\treturn 0;\n+\t      else\n+\t\trealdecl = expr;\n+\t    }\n+\t  else\n+\t    return 0;\n+\t}\n     }\n \n   /* Do not track EXPR if REALDECL it should be ignored for debugging"}]}