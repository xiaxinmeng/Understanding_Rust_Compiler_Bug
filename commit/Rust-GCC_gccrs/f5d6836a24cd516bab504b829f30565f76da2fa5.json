{"sha": "f5d6836a24cd516bab504b829f30565f76da2fa5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjVkNjgzNmEyNGNkNTE2YmFiNTA0YjgyOWYzMDU2NWY3NmRhMmZhNQ==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2010-07-20T12:05:59Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2010-07-20T12:05:59Z"}, "message": "lto-symtab.c (lto_symtab_merge): Use gimple_types_compatible_p.\n\n2010-07-20  Richard Guenther  <rguenther@suse.de>\n\n\t* lto-symtab.c (lto_symtab_merge): Use gimple_types_compatible_p.\n\t(lto_symtab_merge_decls_2): Likewise.\n\t* gimple.h (gimple_types_compatible_p): Declare.\n\t* gimple.c (gimple_queue_type_fixup): Remove.\n\t(gimple_fixup_complete_and_incomplete_subtype_p): Likewise.\n\t(gimple_compatible_complete_and_incomplete_type_p): New\n\tfunction.\n\t(gimple_types_compatible_p): Adjust.\n\t(gimple_register_type): Remove type fixup code.\n\t(print_gimple_types_stats): Adjust.\n\t(free_gimple_type_tables): Likewise.\n\t* lto-streamer-in.c (input_gimple_stmt): Use gimple_types_compatible_p.\n\t* tree-ssa.c (useless_type_conversion_p): Likewise.\n\nFrom-SVN: r162330", "tree": {"sha": "bde8f9d8031adf6d703dcc9a8bdba382267ca985", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bde8f9d8031adf6d703dcc9a8bdba382267ca985"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f5d6836a24cd516bab504b829f30565f76da2fa5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5d6836a24cd516bab504b829f30565f76da2fa5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f5d6836a24cd516bab504b829f30565f76da2fa5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5d6836a24cd516bab504b829f30565f76da2fa5/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ad650c924ff8f880f08a3f287abb7c1ddd2ecf4d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad650c924ff8f880f08a3f287abb7c1ddd2ecf4d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ad650c924ff8f880f08a3f287abb7c1ddd2ecf4d"}], "stats": {"total": 162, "additions": 83, "deletions": 79}, "files": [{"sha": "72cd6aee2e40765a34623ed00c551a8136f56931", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5d6836a24cd516bab504b829f30565f76da2fa5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5d6836a24cd516bab504b829f30565f76da2fa5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f5d6836a24cd516bab504b829f30565f76da2fa5", "patch": "@@ -1,3 +1,19 @@\n+2010-07-20  Richard Guenther  <rguenther@suse.de>\n+\n+\t* lto-symtab.c (lto_symtab_merge): Use gimple_types_compatible_p.\n+\t(lto_symtab_merge_decls_2): Likewise.\n+\t* gimple.h (gimple_types_compatible_p): Declare.\n+\t* gimple.c (gimple_queue_type_fixup): Remove.\n+\t(gimple_fixup_complete_and_incomplete_subtype_p): Likewise.\n+\t(gimple_compatible_complete_and_incomplete_type_p): New\n+\tfunction.\n+\t(gimple_types_compatible_p): Adjust.\n+\t(gimple_register_type): Remove type fixup code.\n+\t(print_gimple_types_stats): Adjust.\n+\t(free_gimple_type_tables): Likewise.\n+\t* lto-streamer-in.c (input_gimple_stmt): Use gimple_types_compatible_p.\n+\t* tree-ssa.c (useless_type_conversion_p): Likewise.\n+\n 2010-07-20  Richard Guenther  <rguenther@suse.de>\n \n \tPR middle-end/44971"}, {"sha": "a3b1bba97c53999bf4c1733ca85fc1ab8d9913c3", "filename": "gcc/gimple.c", "status": "modified", "additions": 55, "deletions": 73, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5d6836a24cd516bab504b829f30565f76da2fa5/gcc%2Fgimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5d6836a24cd516bab504b829f30565f76da2fa5/gcc%2Fgimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.c?ref=f5d6836a24cd516bab504b829f30565f76da2fa5", "patch": "@@ -47,6 +47,8 @@ static struct pointer_map_t *type_hash_cache;\n /* Global type comparison cache.  */\n static htab_t gtc_visited;\n static struct obstack gtc_ob;\n+static htab_t gtc_visited2;\n+static struct obstack gtc_ob2;\n \n /* All the tuples have their operand vector (if present) at the very bottom\n    of the structure.  Therefore, the offset required to find the\n@@ -3323,37 +3325,12 @@ gimple_compare_field_offset (tree f1, tree f2)\n   return false;\n }\n \n-typedef struct type_fixup_s {\n-    tree context;\n-    tree *incomplete;\n-    tree complete;\n-} type_fixup;\n-DEF_VEC_O(type_fixup);\n-DEF_VEC_ALLOC_O(type_fixup,heap);\n-\n-static VEC(type_fixup, heap) *gimple_register_type_fixups = NULL;\n-\n-static void\n-gimple_queue_type_fixup (tree context, tree *incomplete, tree complete)\n-{\n-  type_fixup f;\n-  f.context = context;\n-  f.incomplete = incomplete;\n-  f.complete = complete;\n-  VEC_safe_push (type_fixup, heap, gimple_register_type_fixups, &f);\n-}\n-\n-/* If the type *T1P and the type *T2P are a complete and an incomplete\n-   variant of the same type return true and queue a fixup for the\n-   incomplete one and its CONTEXT.  Return false otherwise.  */\n+/* If the type T1 and the type T2 are a complete and an incomplete\n+   variant of the same type return true.  */\n \n static bool\n-gimple_fixup_complete_and_incomplete_subtype_p (tree context1, tree *t1p,\n-\t\t\t\t\t\ttree context2, tree *t2p)\n+gimple_compatible_complete_and_incomplete_subtype_p (tree t1, tree t2)\n {\n-  tree t1 = *t1p;\n-  tree t2 = *t2p;\n-\n   /* If one pointer points to an incomplete type variant of\n      the other pointed-to type they are the same.  */\n   if (TREE_CODE (t1) == TREE_CODE (t2)\n@@ -3363,30 +3340,15 @@ gimple_fixup_complete_and_incomplete_subtype_p (tree context1, tree *t1p,\n       && TYPE_QUALS (t1) == TYPE_QUALS (t2)\n       && compare_type_names_p (TYPE_MAIN_VARIANT (t1),\n \t\t\t       TYPE_MAIN_VARIANT (t2), true))\n-    {\n-      /* Replace the pointed-to incomplete type with the complete one.\n-\t ???  This simple name-based merging causes at least some\n-\t of the ICEs in canonicalizing FIELD_DECLs during stmt\n-\t read.  For example in GCC we have two different struct deps\n-\t and we mismatch the use in struct cpp_reader in sched-int.h\n-\t vs. mkdeps.c.  Of course the whole exercise is for TBAA\n-\t with structs which contain pointers to incomplete types\n-\t in one unit and to complete ones in another.  So we\n-\t probably should merge these types only with more context.  */\n-      if (COMPLETE_TYPE_P (t2))\n-\tgimple_queue_type_fixup (context1, t1p, t2);\n-      else\n-\tgimple_queue_type_fixup (context2, t2p, t1);\n-      return true;\n-    }\n+    return true;\n   return false;\n }\n \n /* Return 1 iff T1 and T2 are structurally identical.\n    Otherwise, return 0.  */\n \n-static int\n-gimple_types_compatible_p (tree t1, tree t2)\n+bool\n+gimple_types_compatible_p (tree t1, tree t2, bool for_merging_p)\n {\n   type_pair_t p = NULL;\n \n@@ -3439,7 +3401,8 @@ gimple_types_compatible_p (tree t1, tree t2)\n       /* Perform cheap tail-recursion for vector and complex types.  */\n       if (TREE_CODE (t1) == VECTOR_TYPE\n \t  || TREE_CODE (t1) == COMPLEX_TYPE)\n-\treturn gimple_types_compatible_p (TREE_TYPE (t1), TREE_TYPE (t2));\n+\treturn gimple_types_compatible_p (TREE_TYPE (t1), TREE_TYPE (t2),\n+\t\t\t\t\t  for_merging_p);\n \n       /* For integral types fall thru to more complex checks.  */\n     }\n@@ -3460,7 +3423,9 @@ gimple_types_compatible_p (tree t1, tree t2)\n \n   /* If we've visited this type pair before (in the case of aggregates\n      with self-referential types), and we made a decision, return it.  */\n-  p = lookup_type_pair (t1, t2, &gtc_visited, &gtc_ob);\n+  p = lookup_type_pair (t1, t2,\n+\t\t\tfor_merging_p ? &gtc_visited : &gtc_visited2,\n+\t\t\tfor_merging_p ? &gtc_ob : &gtc_ob2);\n   if (p->same_p == 0 || p->same_p == 1)\n     {\n       /* We have already decided whether T1 and T2 are the\n@@ -3489,7 +3454,8 @@ gimple_types_compatible_p (tree t1, tree t2)\n     case ARRAY_TYPE:\n       /* Array types are the same if the element types are the same and\n \t the number of elements are the same.  */\n-      if (!gimple_types_compatible_p (TREE_TYPE (t1), TREE_TYPE (t2))\n+      if (!gimple_types_compatible_p (TREE_TYPE (t1), TREE_TYPE (t2),\n+\t\t\t\t      for_merging_p)\n \t  || TYPE_STRING_FLAG (t1) != TYPE_STRING_FLAG (t2)\n \t  || TYPE_NONALIASED_COMPONENT (t1) != TYPE_NONALIASED_COMPONENT (t2))\n \tgoto different_types;\n@@ -3538,17 +3504,19 @@ gimple_types_compatible_p (tree t1, tree t2)\n     case METHOD_TYPE:\n       /* Method types should belong to the same class.  */\n       if (!gimple_types_compatible_p (TYPE_METHOD_BASETYPE (t1),\n-\t\t\t\t TYPE_METHOD_BASETYPE (t2)))\n+\t\t\t\t      TYPE_METHOD_BASETYPE (t2), for_merging_p))\n \tgoto different_types;\n \n       /* Fallthru  */\n \n     case FUNCTION_TYPE:\n       /* Function types are the same if the return type and arguments types\n \t are the same.  */\n-      if (!gimple_fixup_complete_and_incomplete_subtype_p\n-\t     (t1, &TREE_TYPE (t1), t2, &TREE_TYPE (t2))\n-\t  && !gimple_types_compatible_p (TREE_TYPE (t1), TREE_TYPE (t2)))\n+      if ((for_merging_p\n+\t   || !gimple_compatible_complete_and_incomplete_subtype_p\n+\t         (TREE_TYPE (t1), TREE_TYPE (t2)))\n+\t  && !gimple_types_compatible_p (TREE_TYPE (t1), TREE_TYPE (t2),\n+\t\t\t\t\t for_merging_p))\n \tgoto different_types;\n \n       if (!targetm.comp_type_attributes (t1, t2))\n@@ -3564,10 +3532,12 @@ gimple_types_compatible_p (tree t1, tree t2)\n \t       parms1 && parms2;\n \t       parms1 = TREE_CHAIN (parms1), parms2 = TREE_CHAIN (parms2))\n \t    {\n-\t      if (!gimple_fixup_complete_and_incomplete_subtype_p\n-\t\t    (t1, &TREE_VALUE (parms1), t2, &TREE_VALUE (parms2))\n+\t      if ((for_merging_p\n+\t\t   || !gimple_compatible_complete_and_incomplete_subtype_p\n+\t\t         (TREE_VALUE (parms1), TREE_VALUE (parms2)))\n \t\t  && !gimple_types_compatible_p (TREE_VALUE (parms1),\n-\t\t\t\t\t\t TREE_VALUE (parms2)))\n+\t\t\t\t\t\t TREE_VALUE (parms2),\n+\t\t\t\t\t\t for_merging_p))\n \t\tgoto different_types;\n \t    }\n \n@@ -3579,9 +3549,11 @@ gimple_types_compatible_p (tree t1, tree t2)\n \n     case OFFSET_TYPE:\n       {\n-\tif (!gimple_types_compatible_p (TREE_TYPE (t1), TREE_TYPE (t2))\n+\tif (!gimple_types_compatible_p (TREE_TYPE (t1), TREE_TYPE (t2),\n+\t\t\t\t\tfor_merging_p)\n \t    || !gimple_types_compatible_p (TYPE_OFFSET_BASETYPE (t1),\n-\t\t\t\t\t   TYPE_OFFSET_BASETYPE (t2)))\n+\t\t\t\t\t   TYPE_OFFSET_BASETYPE (t2),\n+\t\t\t\t\t   for_merging_p))\n \t  goto different_types;\n \n \tgoto same_types;\n@@ -3597,13 +3569,15 @@ gimple_types_compatible_p (tree t1, tree t2)\n \n \t/* If one pointer points to an incomplete type variant of\n \t   the other pointed-to type they are the same.  */\n-\tif (gimple_fixup_complete_and_incomplete_subtype_p\n-\t      (t1, &TREE_TYPE (t1), t2, &TREE_TYPE (t2)))\n+\tif (!for_merging_p\n+\t    && gimple_compatible_complete_and_incomplete_subtype_p\n+\t         (TREE_TYPE (t1), TREE_TYPE (t2)))\n \t  goto same_types;\n \n \t/* Otherwise, pointer and reference types are the same if the\n \t   pointed-to types are the same.  */\n-\tif (gimple_types_compatible_p (TREE_TYPE (t1), TREE_TYPE (t2)))\n+\tif (gimple_types_compatible_p (TREE_TYPE (t1), TREE_TYPE (t2),\n+\t\t\t\t       for_merging_p))\n \t  goto same_types;\n \n \tgoto different_types;\n@@ -3699,7 +3673,7 @@ gimple_types_compatible_p (tree t1, tree t2)\n \t\t|| DECL_NONADDRESSABLE_P (f1) != DECL_NONADDRESSABLE_P (f2)\n \t\t|| !gimple_compare_field_offset (f1, f2)\n \t\t|| !gimple_types_compatible_p (TREE_TYPE (f1),\n-\t\t\t\t\t       TREE_TYPE (f2)))\n+\t\t\t\t\t       TREE_TYPE (f2), for_merging_p))\n \t      goto different_types;\n \t  }\n \n@@ -4040,7 +4014,8 @@ gimple_type_eq (const void *p1, const void *p2)\n {\n   const_tree t1 = (const_tree) p1;\n   const_tree t2 = (const_tree) p2;\n-  return gimple_types_compatible_p (CONST_CAST_TREE (t1), CONST_CAST_TREE (t2));\n+  return gimple_types_compatible_p (CONST_CAST_TREE (t1),\n+\t\t\t\t    CONST_CAST_TREE (t2), true);\n }\n \n \n@@ -4070,14 +4045,11 @@ gimple_register_type (tree t)\n   if (gimple_types == NULL)\n     gimple_types = htab_create (16381, gimple_type_hash, gimple_type_eq, 0);\n \n-  gcc_assert (VEC_empty (type_fixup, gimple_register_type_fixups));\n   slot = htab_find_slot (gimple_types, t, INSERT);\n   if (*slot\n       && *(tree *)slot != t)\n     {\n       tree new_type = (tree) *((tree *) slot);\n-      unsigned i;\n-      type_fixup *f;\n \n       /* Do not merge types with different addressability.  */\n       gcc_assert (TREE_ADDRESSABLE (t) == TREE_ADDRESSABLE (new_type));\n@@ -4129,19 +4101,13 @@ gimple_register_type (tree t)\n \n       TYPE_CANONICAL (t) = new_type;\n       t = new_type;\n-\n-      for (i = 0;\n-\t   VEC_iterate (type_fixup, gimple_register_type_fixups, i, f); ++i)\n-\tif (f->context == t)\n-\t  *(f->incomplete) = f->complete;\n     }\n   else\n     {\n       TYPE_CANONICAL (t) = t;\n       *slot = (void *) t;\n     }\n \n-  VEC_truncate (type_fixup, gimple_register_type_fixups, 0);\n   return t;\n }\n \n@@ -4162,13 +4128,23 @@ print_gimple_types_stats (void)\n   else\n     fprintf (stderr, \"GIMPLE type table is empty\\n\");\n   if (gtc_visited)\n-    fprintf (stderr, \"GIMPLE type comparison table: size %ld, %ld \"\n+    fprintf (stderr, \"GIMPLE type merging comparison table: size %ld, %ld \"\n \t     \"elements, %ld searches, %ld collisions (ratio: %f)\\n\",\n \t     (long) htab_size (gtc_visited),\n \t     (long) htab_elements (gtc_visited),\n \t     (long) gtc_visited->searches,\n \t     (long) gtc_visited->collisions,\n \t     htab_collisions (gtc_visited));\n+  else\n+    fprintf (stderr, \"GIMPLE type merging comparison table is empty\\n\");\n+  if (gtc_visited2)\n+    fprintf (stderr, \"GIMPLE type comparison table: size %ld, %ld \"\n+\t     \"elements, %ld searches, %ld collisions (ratio: %f)\\n\",\n+\t     (long) htab_size (gtc_visited2),\n+\t     (long) htab_elements (gtc_visited2),\n+\t     (long) gtc_visited2->searches,\n+\t     (long) gtc_visited2->collisions,\n+\t     htab_collisions (gtc_visited2));\n   else\n     fprintf (stderr, \"GIMPLE type comparison table is empty\\n\");\n }\n@@ -4198,6 +4174,12 @@ free_gimple_type_tables (void)\n       obstack_free (&gtc_ob, NULL);\n       gtc_visited = NULL;\n     }\n+  if (gtc_visited2)\n+    {\n+      htab_delete (gtc_visited2);\n+      obstack_free (&gtc_ob2, NULL);\n+      gtc_visited2 = NULL;\n+    }\n }\n \n "}, {"sha": "af4799e608df05564fede4e60ab0908e63e26cda", "filename": "gcc/gimple.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5d6836a24cd516bab504b829f30565f76da2fa5/gcc%2Fgimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5d6836a24cd516bab504b829f30565f76da2fa5/gcc%2Fgimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.h?ref=f5d6836a24cd516bab504b829f30565f76da2fa5", "patch": "@@ -956,6 +956,7 @@ extern tree get_call_expr_in (tree t);\n extern void recalculate_side_effects (tree);\n extern bool gimple_compare_field_offset (tree, tree);\n extern tree gimple_register_type (tree);\n+extern bool gimple_types_compatible_p (tree, tree, bool);\n extern void print_gimple_types_stats (void);\n extern void free_gimple_type_tables (void);\n extern tree gimple_unsigned_type (tree);"}, {"sha": "9d3e7ec94a14ff60047807f252d5e0521ea47ba7", "filename": "gcc/lto-streamer-in.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5d6836a24cd516bab504b829f30565f76da2fa5/gcc%2Flto-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5d6836a24cd516bab504b829f30565f76da2fa5/gcc%2Flto-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-in.c?ref=f5d6836a24cd516bab504b829f30565f76da2fa5", "patch": "@@ -960,7 +960,9 @@ input_gimple_stmt (struct lto_input_block *ib, struct data_in *data_in,\n \t\t  for (tem = TYPE_FIELDS (type); tem; tem = TREE_CHAIN (tem))\n \t\t    {\n \t\t      if (tem == field\n-\t\t\t  || (TREE_TYPE (tem) == TREE_TYPE (field)\n+\t\t\t  || (gimple_types_compatible_p (TREE_TYPE (tem),\n+\t\t\t\t\t\t\t TREE_TYPE (field),\n+\t\t\t\t\t\t\t false)\n \t\t\t      && DECL_NONADDRESSABLE_P (tem)\n \t\t\t\t == DECL_NONADDRESSABLE_P (field)\n \t\t\t      && gimple_compare_field_offset (tem, field)))"}, {"sha": "f7bb9b6e47a0039356cc0a3979801bac8fa6a699", "filename": "gcc/lto-symtab.c", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5d6836a24cd516bab504b829f30565f76da2fa5/gcc%2Flto-symtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5d6836a24cd516bab504b829f30565f76da2fa5/gcc%2Flto-symtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-symtab.c?ref=f5d6836a24cd516bab504b829f30565f76da2fa5", "patch": "@@ -348,7 +348,8 @@ lto_symtab_merge (lto_symtab_entry_t prevailing, lto_symtab_entry_t entry)\n \n   if (TREE_CODE (decl) == FUNCTION_DECL)\n     {\n-      if (TREE_TYPE (prevailing_decl) != TREE_TYPE (decl))\n+      if (!gimple_types_compatible_p (TREE_TYPE (prevailing_decl),\n+\t\t\t\t      TREE_TYPE (decl), false))\n \t/* If we don't have a merged type yet...sigh.  The linker\n \t   wouldn't complain if the types were mismatched, so we\n \t   probably shouldn't either.  Just use the type from\n@@ -381,7 +382,7 @@ lto_symtab_merge (lto_symtab_entry_t prevailing, lto_symtab_entry_t entry)\n      fixup process didn't yet run.  */\n   prevailing_type = gimple_register_type (prevailing_type);\n   type = gimple_register_type (type);\n-  if (prevailing_type != type)\n+  if (!gimple_types_compatible_p (prevailing_type, type, false))\n     {\n       if (COMPLETE_TYPE_P (type))\n \treturn false;\n@@ -406,7 +407,8 @@ lto_symtab_merge (lto_symtab_entry_t prevailing, lto_symtab_entry_t entry)\n \t  if (TREE_CODE (tem1) != TREE_CODE (tem2))\n \t    return false;\n \n-\t  if (gimple_register_type (tem1) != gimple_register_type (tem2))\n+\t  if (!gimple_types_compatible_p (gimple_register_type (tem1),\n+\t\t\t\t\t  gimple_register_type (tem2), false))\n \t    return false;\n \t}\n \n@@ -600,7 +602,8 @@ lto_symtab_merge_decls_2 (void **slot)\n   /* Diagnose all mismatched re-declarations.  */\n   for (i = 0; VEC_iterate (tree, mismatches, i, decl); ++i)\n     {\n-      if (TREE_TYPE (prevailing->decl) != TREE_TYPE (decl))\n+      if (!gimple_types_compatible_p (TREE_TYPE (prevailing->decl),\n+\t\t\t\t      TREE_TYPE (decl), false))\n \tdiagnosed_p |= warning_at (DECL_SOURCE_LOCATION (decl), 0,\n \t\t\t\t   \"type of %qD does not match original \"\n \t\t\t\t   \"declaration\", decl);"}, {"sha": "d4c519fdfe28b908c67afb46f56e4bd56f040f0c", "filename": "gcc/tree-ssa.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5d6836a24cd516bab504b829f30565f76da2fa5/gcc%2Ftree-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5d6836a24cd516bab504b829f30565f76da2fa5/gcc%2Ftree-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa.c?ref=f5d6836a24cd516bab504b829f30565f76da2fa5", "patch": "@@ -1426,7 +1426,7 @@ useless_type_conversion_p (tree outer_type, tree inner_type)\n      compared types.  */\n   else if (AGGREGATE_TYPE_P (inner_type)\n \t   && TREE_CODE (inner_type) == TREE_CODE (outer_type))\n-    return false;\n+    return gimple_types_compatible_p (outer_type, inner_type, false);\n \n   return false;\n }"}]}