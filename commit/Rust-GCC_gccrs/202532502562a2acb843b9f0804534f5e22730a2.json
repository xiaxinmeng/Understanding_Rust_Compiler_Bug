{"sha": "202532502562a2acb843b9f0804534f5e22730a2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjAyNTMyNTAyNTYyYTJhY2I4NDNiOWYwODA0NTM0ZjVlMjI3MzBhMg==", "commit": {"author": {"name": "Steven Munroe", "email": "munroesj@gcc.gnu.org", "date": "2017-08-25T15:11:50Z"}, "committer": {"name": "Steven Munroe", "email": "munroesj@gcc.gnu.org", "date": "2017-08-25T15:11:50Z"}, "message": "Part 2/3 for contributing PPC64LE support for X86 SSE instrisics.\n\nPart 2/3 for contributing PPC64LE support for X86 SSE\ninstrisics. This patch includes the new (for PPC) xmmintrin.h,\nchanges x86intrin.h to include xmmintrin.h and associated\nconfig.gcc changes.\n\nFrom-SVN: r251356", "tree": {"sha": "16e0dd9d4a36e9b4540b4fa523bfca8bfcc23d16", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/16e0dd9d4a36e9b4540b4fa523bfca8bfcc23d16"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/202532502562a2acb843b9f0804534f5e22730a2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/202532502562a2acb843b9f0804534f5e22730a2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/202532502562a2acb843b9f0804534f5e22730a2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/202532502562a2acb843b9f0804534f5e22730a2/comments", "author": null, "committer": null, "parents": [{"sha": "55d14001d913459a089e5ba81b87672fb58d711b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/55d14001d913459a089e5ba81b87672fb58d711b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/55d14001d913459a089e5ba81b87672fb58d711b"}], "stats": {"total": 1830, "additions": 1830, "deletions": 0}, "files": [{"sha": "5a425e3ba160347edd5f0eff0bad6dbc77cfca19", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/202532502562a2acb843b9f0804534f5e22730a2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/202532502562a2acb843b9f0804534f5e22730a2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=202532502562a2acb843b9f0804534f5e22730a2", "patch": "@@ -1,3 +1,9 @@\n+2017-08-25  Steven Munroe  <munroesj@gcc.gnu.org>\n+\n+\t* config.gcc (powerpc*-*-*): Add xmmintrin.h and mm_malloc.h.\n+\t* config/rs6000/xmmintrin.h: New file.\n+\t* config/rs6000/x86intrin.h [__ALTIVEC__]: Include xmmintrin.h.\n+\n 2017-08-25  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n \n \tPR target/81504"}, {"sha": "cc56c576864649dad9d6e27b4853036e0623a102", "filename": "gcc/config.gcc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/202532502562a2acb843b9f0804534f5e22730a2/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/202532502562a2acb843b9f0804534f5e22730a2/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=202532502562a2acb843b9f0804534f5e22730a2", "patch": "@@ -457,6 +457,7 @@ powerpc*-*-*)\n \textra_objs=\"rs6000-string.o rs6000-p8swap.o\"\n \textra_headers=\"ppc-asm.h altivec.h htmintrin.h htmxlintrin.h\"\n \textra_headers=\"${extra_headers} bmi2intrin.h bmiintrin.h\"\n+\textra_headers=\"${extra_headers} xmmintrin.h mm_malloc.h\"\n \textra_headers=\"${extra_headers} mmintrin.h x86intrin.h\"\n \textra_headers=\"${extra_headers} ppu_intrinsics.h spu2vmx.h vec_types.h si2vmx.h\"\n \textra_headers=\"${extra_headers} paired.h\""}, {"sha": "624e498a29258abe70caebec8002e8f66841e9f2", "filename": "gcc/config/rs6000/x86intrin.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/202532502562a2acb843b9f0804534f5e22730a2/gcc%2Fconfig%2Frs6000%2Fx86intrin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/202532502562a2acb843b9f0804534f5e22730a2/gcc%2Fconfig%2Frs6000%2Fx86intrin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fx86intrin.h?ref=202532502562a2acb843b9f0804534f5e22730a2", "patch": "@@ -37,6 +37,8 @@\n \n #ifdef __ALTIVEC__\n #include <mmintrin.h>\n+\n+#include <xmmintrin.h>\n #endif /* __ALTIVEC__ */\n \n #include <bmiintrin.h>"}, {"sha": "d7f87b554cab62fb7db98340e68df7e1905df313", "filename": "gcc/config/rs6000/xmmintrin.h", "status": "added", "additions": 1821, "deletions": 0, "changes": 1821, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/202532502562a2acb843b9f0804534f5e22730a2/gcc%2Fconfig%2Frs6000%2Fxmmintrin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/202532502562a2acb843b9f0804534f5e22730a2/gcc%2Fconfig%2Frs6000%2Fxmmintrin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fxmmintrin.h?ref=202532502562a2acb843b9f0804534f5e22730a2", "patch": "@@ -0,0 +1,1821 @@\n+/* Copyright (C) 2002-2017 Free Software Foundation, Inc.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   GCC is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License and\n+   a copy of the GCC Runtime Library Exception along with this program;\n+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+/* Implemented from the specification included in the Intel C++ Compiler\n+   User Guide and Reference, version 9.0.  */\n+\n+#ifndef NO_WARN_X86_INTRINSICS\n+/* This header is distributed to simplify porting x86_64 code that\n+   makes explicit use of Intel intrinsics to powerpc64le.\n+   It is the user's responsibility to determine if the results are\n+   acceptable and make additional changes as necessary.\n+   Note that much code that uses Intel intrinsics can be rewritten in\n+   standard C or GNU C extensions, which are more portable and better\n+   optimized across multiple targets.\n+\n+   In the specific case of X86 SSE (__m128) intrinsics, the PowerPC\n+   VMX/VSX ISA is a good match for vector float SIMD operations.\n+   However scalar float operations in vector (XMM) registers require\n+   the POWER8 VSX ISA (2.07) level. Also there are important\n+   differences for data format and placement of float scalars in the\n+   vector register. For PowerISA Scalar floats in FPRs (left most\n+   64-bits of the low 32 VSRs) is in double format, while X86_64 SSE\n+   uses the right most 32-bits of the XMM. These differences require\n+   extra steps on POWER to match the SSE scalar float semantics.\n+\n+   Most SSE scalar float intrinsic operations can be performed more\n+   efficiently as C language float scalar operations or optimized to\n+   use vector SIMD operations.  We recommend this for new applications.\n+\n+   Another difference is the format and details of the X86_64 MXSCR vs\n+   the PowerISA FPSCR / VSCR registers. We recommend applications\n+   replace direct access to the MXSCR with the more portable <fenv.h>\n+   Posix APIs. */\n+#warning \"Please read comment above.  Use -DNO_WARN_X86_INTRINSICS to disable this warning.\"\n+#endif\n+\n+#ifndef _XMMINTRIN_H_INCLUDED\n+#define _XMMINTRIN_H_INCLUDED\n+\n+#include <altivec.h>\n+#include <assert.h>\n+\n+/* We need type definitions from the MMX header file.  */\n+#include <mmintrin.h>\n+\n+/* Get _mm_malloc () and _mm_free ().  */\n+#include <mm_malloc.h>\n+\n+/* The Intel API is flexible enough that we must allow aliasing with other\n+   vector types, and their scalar components.  */\n+typedef float __m128 __attribute__ ((__vector_size__ (16), __may_alias__));\n+\n+/* Internal data types for implementing the intrinsics.  */\n+typedef float __v4sf __attribute__ ((__vector_size__ (16)));\n+\n+/* Create an undefined vector.  */\n+extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_undefined_ps (void)\n+{\n+  __m128 __Y = __Y;\n+  return __Y;\n+}\n+\n+/* Create a vector of zeros.  */\n+extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_setzero_ps (void)\n+{\n+  return __extension__ (__m128){ 0.0f, 0.0f, 0.0f, 0.0f };\n+}\n+\n+/* Load four SPFP values from P.  The address must be 16-byte aligned.  */\n+extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_load_ps (float const *__P)\n+{\n+  assert(((unsigned long)__P & 0xfUL) == 0UL);\n+  return ((__m128)vec_ld(0, (__v4sf*)__P));\n+}\n+\n+/* Load four SPFP values from P.  The address need not be 16-byte aligned.  */\n+extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_loadu_ps (float const *__P)\n+{\n+  return (vec_vsx_ld(0, __P));\n+}\n+\n+/* Load four SPFP values in reverse order.  The address must be aligned.  */\n+extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_loadr_ps (float const *__P)\n+{\n+  __v4sf   __tmp;\n+  __m128 result;\n+  static const __vector unsigned char permute_vector =\n+    { 0x1C, 0x1D, 0x1E, 0x1F, 0x18, 0x19, 0x1A, 0x1B, 0x14, 0x15, 0x16,\n+\t0x17, 0x10, 0x11, 0x12, 0x13 };\n+\n+  __tmp = vec_ld (0, (__v4sf *) __P);\n+  result = (__m128) vec_perm (__tmp, __tmp, permute_vector);\n+  return result;\n+}\n+\n+/* Create a vector with all four elements equal to F.  */\n+extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_set1_ps (float __F)\n+{\n+  return __extension__ (__m128)(__v4sf){ __F, __F, __F, __F };\n+}\n+\n+extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_set_ps1 (float __F)\n+{\n+  return _mm_set1_ps (__F);\n+}\n+\n+/* Create the vector [Z Y X W].  */\n+extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_set_ps (const float __Z, const float __Y, const float __X, const float __W)\n+{\n+  return __extension__ (__m128)(__v4sf){ __W, __X, __Y, __Z };\n+}\n+\n+/* Create the vector [W X Y Z].  */\n+extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_setr_ps (float __Z, float __Y, float __X, float __W)\n+{\n+  return __extension__ (__m128)(__v4sf){ __Z, __Y, __X, __W };\n+}\n+\n+/* Store four SPFP values.  The address must be 16-byte aligned.  */\n+extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_store_ps (float *__P, __m128 __A)\n+{\n+  assert(((unsigned long)__P & 0xfUL) == 0UL);\n+  vec_st((__v4sf)__A, 0, (__v4sf*)__P);\n+}\n+\n+/* Store four SPFP values.  The address need not be 16-byte aligned.  */\n+extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_storeu_ps (float *__P, __m128 __A)\n+{\n+  *(__m128 *)__P = __A;\n+}\n+\n+/* Store four SPFP values in reverse order.  The address must be aligned.  */\n+extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_storer_ps (float *__P, __m128 __A)\n+{\n+  __v4sf   __tmp;\n+  static const __vector unsigned char permute_vector =\n+    { 0x1C, 0x1D, 0x1E, 0x1F, 0x18, 0x19, 0x1A, 0x1B, 0x14, 0x15, 0x16,\n+\t0x17, 0x10, 0x11, 0x12, 0x13 };\n+\n+  __tmp = (__m128) vec_perm (__A, __A, permute_vector);\n+\n+  _mm_store_ps (__P, __tmp);\n+}\n+\n+/* Store the lower SPFP value across four words.  */\n+extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_store1_ps (float *__P, __m128 __A)\n+{\n+  __v4sf __va = vec_splat((__v4sf)__A, 0);\n+  _mm_store_ps (__P, __va);\n+}\n+\n+extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_store_ps1 (float *__P, __m128 __A)\n+{\n+  _mm_store1_ps (__P, __A);\n+}\n+\n+/* Create a vector with element 0 as F and the rest zero.  */\n+extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_set_ss (float __F)\n+{\n+  return __extension__ (__m128)(__v4sf){ __F, 0.0f, 0.0f, 0.0f };\n+}\n+\n+/* Sets the low SPFP value of A from the low value of B.  */\n+extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_move_ss (__m128 __A, __m128 __B)\n+{\n+  static const __vector unsigned int mask = {0xffffffff, 0, 0, 0};\n+\n+  return (vec_sel ((__v4sf)__A, (__v4sf)__B, mask));\n+}\n+\n+/* Create a vector with element 0 as *P and the rest zero.  */\n+extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_load_ss (float const *__P)\n+{\n+  return _mm_set_ss (*__P);\n+}\n+\n+/* Stores the lower SPFP value.  */\n+extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_store_ss (float *__P, __m128 __A)\n+{\n+  *__P = ((__v4sf)__A)[0];\n+}\n+\n+/* Perform the respective operation on the lower SPFP (single-precision\n+   floating-point) values of A and B; the upper three SPFP values are\n+   passed through from A.  */\n+\n+extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_add_ss (__m128 __A, __m128 __B)\n+{\n+#ifdef _ARCH_PWR7\n+  __m128 a, b, c;\n+  static const __vector unsigned int mask = {0xffffffff, 0, 0, 0};\n+  /* PowerISA VSX does not allow partial (for just lower double)\n+     results. So to insure we don't generate spurious exceptions\n+     (from the upper double values) we splat the lower double\n+     before we to the operation.  */\n+  a = vec_splat (__A, 0);\n+  b = vec_splat (__B, 0);\n+  c = a + b;\n+  /* Then we merge the lower float result with the original upper\n+     float elements from __A.  */\n+  return (vec_sel (__A, c, mask));\n+#else\n+  __A[0] = __A[0] + __B[0];\n+  return (__A);\n+#endif\n+}\n+\n+extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_sub_ss (__m128 __A, __m128 __B)\n+{\n+#ifdef _ARCH_PWR7\n+  __m128 a, b, c;\n+  static const __vector unsigned int mask = {0xffffffff, 0, 0, 0};\n+  /* PowerISA VSX does not allow partial (for just lower double)\n+     results. So to insure we don't generate spurious exceptions\n+     (from the upper double values) we splat the lower double\n+     before we to the operation.  */\n+  a = vec_splat (__A, 0);\n+  b = vec_splat (__B, 0);\n+  c = a - b;\n+  /* Then we merge the lower float result with the original upper\n+     float elements from __A.  */\n+  return (vec_sel (__A, c, mask));\n+#else\n+  __A[0] = __A[0] - __B[0];\n+  return (__A);\n+#endif\n+}\n+\n+extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_mul_ss (__m128 __A, __m128 __B)\n+{\n+#ifdef _ARCH_PWR7\n+  __m128 a, b, c;\n+  static const __vector unsigned int mask = {0xffffffff, 0, 0, 0};\n+  /* PowerISA VSX does not allow partial (for just lower double)\n+     results. So to insure we don't generate spurious exceptions\n+     (from the upper double values) we splat the lower double\n+     before we to the operation.  */\n+  a = vec_splat (__A, 0);\n+  b = vec_splat (__B, 0);\n+  c = a * b;\n+  /* Then we merge the lower float result with the original upper\n+     float elements from __A.  */\n+  return (vec_sel (__A, c, mask));\n+#else\n+  __A[0] = __A[0] * __B[0];\n+  return (__A);\n+#endif\n+}\n+\n+extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_div_ss (__m128 __A, __m128 __B)\n+{\n+#ifdef _ARCH_PWR7\n+  __m128 a, b, c;\n+  static const __vector unsigned int mask = {0xffffffff, 0, 0, 0};\n+  /* PowerISA VSX does not allow partial (for just lower double)\n+     results. So to insure we don't generate spurious exceptions\n+     (from the upper double values) we splat the lower double\n+     before we to the operation.  */\n+  a = vec_splat (__A, 0);\n+  b = vec_splat (__B, 0);\n+  c = a / b;\n+  /* Then we merge the lower float result with the original upper\n+     float elements from __A.  */\n+  return (vec_sel (__A, c, mask));\n+#else\n+  __A[0] = __A[0] / __B[0];\n+  return (__A);\n+#endif\n+}\n+\n+extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_sqrt_ss (__m128 __A)\n+{\n+  __m128 a, c;\n+  static const __vector unsigned int mask = {0xffffffff, 0, 0, 0};\n+  /* PowerISA VSX does not allow partial (for just lower double)\n+   * results. So to insure we don't generate spurious exceptions\n+   * (from the upper double values) we splat the lower double\n+   * before we to the operation. */\n+  a = vec_splat (__A, 0);\n+  c = vec_sqrt (a);\n+  /* Then we merge the lower float result with the original upper\n+   * float elements from __A.  */\n+  return (vec_sel (__A, c, mask));\n+}\n+\n+/* Perform the respective operation on the four SPFP values in A and B.  */\n+extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_add_ps (__m128 __A, __m128 __B)\n+{\n+  return (__m128) ((__v4sf)__A + (__v4sf)__B);\n+}\n+\n+extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_sub_ps (__m128 __A, __m128 __B)\n+{\n+  return (__m128) ((__v4sf)__A - (__v4sf)__B);\n+}\n+\n+extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_mul_ps (__m128 __A, __m128 __B)\n+{\n+  return (__m128) ((__v4sf)__A * (__v4sf)__B);\n+}\n+\n+extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_div_ps (__m128 __A, __m128 __B)\n+{\n+  return (__m128) ((__v4sf)__A / (__v4sf)__B);\n+}\n+\n+extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_sqrt_ps (__m128 __A)\n+{\n+  return (vec_sqrt ((__v4sf)__A));\n+}\n+\n+extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_rcp_ps (__m128 __A)\n+{\n+  return (vec_re ((__v4sf)__A));\n+}\n+\n+extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_rsqrt_ps (__m128 __A)\n+{\n+  return (vec_rsqrte (__A));\n+}\n+\n+extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_rcp_ss (__m128 __A)\n+{\n+  __m128 a, c;\n+  static const __vector unsigned int mask = {0xffffffff, 0, 0, 0};\n+  /* PowerISA VSX does not allow partial (for just lower double)\n+   * results. So to insure we don't generate spurious exceptions\n+   * (from the upper double values) we splat the lower double\n+   * before we to the operation. */\n+  a = vec_splat (__A, 0);\n+  c = _mm_rcp_ps (a);\n+  /* Then we merge the lower float result with the original upper\n+   * float elements from __A.  */\n+  return (vec_sel (__A, c, mask));\n+}\n+\n+extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_rsqrt_ss (__m128 __A)\n+{\n+  __m128 a, c;\n+  static const __vector unsigned int mask = {0xffffffff, 0, 0, 0};\n+  /* PowerISA VSX does not allow partial (for just lower double)\n+   * results. So to insure we don't generate spurious exceptions\n+   * (from the upper double values) we splat the lower double\n+   * before we to the operation. */\n+  a = vec_splat (__A, 0);\n+  c = vec_rsqrte (a);\n+  /* Then we merge the lower float result with the original upper\n+   * float elements from __A.  */\n+  return (vec_sel (__A, c, mask));\n+}\n+\n+extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_min_ss (__m128 __A, __m128 __B)\n+{\n+  __v4sf a, b, c;\n+  static const __vector unsigned int mask = {0xffffffff, 0, 0, 0};\n+  /* PowerISA VSX does not allow partial (for just lower float)\n+   * results. So to insure we don't generate spurious exceptions\n+   * (from the upper float values) we splat the lower float\n+   * before we to the operation. */\n+  a = vec_splat ((__v4sf)__A, 0);\n+  b = vec_splat ((__v4sf)__B, 0);\n+  c = vec_min (a, b);\n+  /* Then we merge the lower float result with the original upper\n+   * float elements from __A.  */\n+  return (vec_sel ((__v4sf)__A, c, mask));\n+}\n+\n+extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_max_ss (__m128 __A, __m128 __B)\n+{\n+  __v4sf a, b, c;\n+  static const __vector unsigned int mask = {0xffffffff, 0, 0, 0};\n+  /* PowerISA VSX does not allow partial (for just lower float)\n+   * results. So to insure we don't generate spurious exceptions\n+   * (from the upper float values) we splat the lower float\n+   * before we to the operation. */\n+  a = vec_splat (__A, 0);\n+  b = vec_splat (__B, 0);\n+  c = vec_max (a, b);\n+  /* Then we merge the lower float result with the original upper\n+   * float elements from __A.  */\n+  return (vec_sel ((__v4sf)__A, c, mask));\n+}\n+\n+extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_min_ps (__m128 __A, __m128 __B)\n+{\n+  return ((__m128)vec_min ((__v4sf)__A,(__v4sf) __B));\n+}\n+\n+extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_max_ps (__m128 __A, __m128 __B)\n+{\n+  return ((__m128)vec_max ((__v4sf)__A, (__v4sf)__B));\n+}\n+\n+/* Perform logical bit-wise operations on 128-bit values.  */\n+extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_and_ps (__m128 __A, __m128 __B)\n+{\n+  return ((__m128)vec_and ((__v4sf)__A, (__v4sf)__B));\n+//  return __builtin_ia32_andps (__A, __B);\n+}\n+\n+extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_andnot_ps (__m128 __A, __m128 __B)\n+{\n+  return ((__m128)vec_andc ((__v4sf)__B, (__v4sf)__A));\n+}\n+\n+extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_or_ps (__m128 __A, __m128 __B)\n+{\n+  return ((__m128)vec_or ((__v4sf)__A, (__v4sf)__B));\n+}\n+\n+extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_xor_ps (__m128 __A, __m128 __B)\n+{\n+  return ((__m128)vec_xor ((__v4sf)__A, (__v4sf)__B));\n+}\n+\n+/* Perform a comparison on the four SPFP values of A and B.  For each\n+   element, if the comparison is true, place a mask of all ones in the\n+   result, otherwise a mask of zeros.  */\n+extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_cmpeq_ps (__m128 __A, __m128 __B)\n+{\n+  return ((__m128)vec_cmpeq ((__v4sf)__A,(__v4sf) __B));\n+}\n+\n+extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_cmplt_ps (__m128 __A, __m128 __B)\n+{\n+  return ((__m128)vec_cmplt ((__v4sf)__A, (__v4sf)__B));\n+}\n+\n+extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_cmple_ps (__m128 __A, __m128 __B)\n+{\n+  return ((__m128)vec_cmple ((__v4sf)__A, (__v4sf)__B));\n+}\n+\n+extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_cmpgt_ps (__m128 __A, __m128 __B)\n+{\n+  return ((__m128)vec_cmpgt ((__v4sf)__A, (__v4sf)__B));\n+}\n+\n+extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_cmpge_ps (__m128 __A, __m128 __B)\n+{\n+  return ((__m128)vec_cmpge ((__v4sf)__A, (__v4sf)__B));\n+}\n+\n+extern __inline  __m128  __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_cmpneq_ps (__m128  __A, __m128  __B)\n+{\n+  __v4sf temp = (__v4sf ) vec_cmpeq ((__v4sf) __A, (__v4sf)__B);\n+  return ((__m128)vec_nor (temp, temp));\n+}\n+\n+extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_cmpnlt_ps (__m128 __A, __m128 __B)\n+{\n+  return ((__m128)vec_cmpge ((__v4sf)__A, (__v4sf)__B));\n+}\n+\n+extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_cmpnle_ps (__m128 __A, __m128 __B)\n+{\n+  return ((__m128)vec_cmpgt ((__v4sf)__A, (__v4sf)__B));\n+}\n+\n+extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_cmpngt_ps (__m128 __A, __m128 __B)\n+{\n+  return ((__m128)vec_cmple ((__v4sf)__A, (__v4sf)__B));\n+}\n+\n+extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_cmpnge_ps (__m128 __A, __m128 __B)\n+{\n+  return ((__m128)vec_cmplt ((__v4sf)__A, (__v4sf)__B));\n+}\n+\n+extern __inline  __m128  __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_cmpord_ps (__m128  __A, __m128  __B)\n+{\n+  __vector unsigned int a, b;\n+  __vector unsigned int c, d;\n+  static const __vector unsigned int float_exp_mask =\n+    { 0x7f800000, 0x7f800000, 0x7f800000, 0x7f800000 };\n+\n+  a = (__vector unsigned int) vec_abs ((__v4sf)__A);\n+  b = (__vector unsigned int) vec_abs ((__v4sf)__B);\n+  c = (__vector unsigned int) vec_cmpgt (float_exp_mask, a);\n+  d = (__vector unsigned int) vec_cmpgt (float_exp_mask, b);\n+  return ((__m128 ) vec_and (c, d));\n+}\n+\n+extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_cmpunord_ps (__m128 __A, __m128 __B)\n+{\n+  __vector unsigned int a, b;\n+  __vector unsigned int c, d;\n+  static const __vector unsigned int float_exp_mask =\n+    { 0x7f800000, 0x7f800000, 0x7f800000, 0x7f800000 };\n+\n+  a = (__vector unsigned int) vec_abs ((__v4sf)__A);\n+  b = (__vector unsigned int) vec_abs ((__v4sf)__B);\n+  c = (__vector unsigned int) vec_cmpgt (a, float_exp_mask);\n+  d = (__vector unsigned int) vec_cmpgt (b, float_exp_mask);\n+  return ((__m128 ) vec_or (c, d));\n+}\n+\n+/* Perform a comparison on the lower SPFP values of A and B.  If the\n+   comparison is true, place a mask of all ones in the result, otherwise a\n+   mask of zeros.  The upper three SPFP values are passed through from A.  */\n+extern __inline  __m128  __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_cmpeq_ss (__m128  __A, __m128  __B)\n+{\n+  static const __vector unsigned int mask =\n+    { 0xffffffff, 0, 0, 0 };\n+  __v4sf a, b, c;\n+  /* PowerISA VMX does not allow partial (for just element 0)\n+   * results. So to insure we don't generate spurious exceptions\n+   * (from the upper elements) we splat the lower float\n+   * before we to the operation. */\n+  a = vec_splat ((__v4sf) __A, 0);\n+  b = vec_splat ((__v4sf) __B, 0);\n+  c = (__v4sf) vec_cmpeq(a, b);\n+  /* Then we merge the lower float result with the original upper\n+   * float elements from __A.  */\n+  return ((__m128)vec_sel ((__v4sf)__A, c, mask));\n+}\n+\n+extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_cmplt_ss (__m128 __A, __m128 __B)\n+{\n+  static const __vector unsigned int mask =\n+    { 0xffffffff, 0, 0, 0 };\n+  __v4sf a, b, c;\n+  /* PowerISA VMX does not allow partial (for just element 0)\n+   * results. So to insure we don't generate spurious exceptions\n+   * (from the upper elements) we splat the lower float\n+   * before we to the operation. */\n+  a = vec_splat ((__v4sf) __A, 0);\n+  b = vec_splat ((__v4sf) __B, 0);\n+  c = (__v4sf) vec_cmplt(a, b);\n+  /* Then we merge the lower float result with the original upper\n+   * float elements from __A.  */\n+  return ((__m128)vec_sel ((__v4sf)__A, c, mask));\n+}\n+\n+extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_cmple_ss (__m128 __A, __m128 __B)\n+{\n+  static const __vector unsigned int mask =\n+    { 0xffffffff, 0, 0, 0 };\n+  __v4sf a, b, c;\n+  /* PowerISA VMX does not allow partial (for just element 0)\n+   * results. So to insure we don't generate spurious exceptions\n+   * (from the upper elements) we splat the lower float\n+   * before we to the operation. */\n+  a = vec_splat ((__v4sf) __A, 0);\n+  b = vec_splat ((__v4sf) __B, 0);\n+  c = (__v4sf) vec_cmple(a, b);\n+  /* Then we merge the lower float result with the original upper\n+   * float elements from __A.  */\n+  return ((__m128)vec_sel ((__v4sf)__A, c, mask));\n+}\n+\n+extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_cmpgt_ss (__m128 __A, __m128 __B)\n+{\n+  static const __vector unsigned int mask =\n+    { 0xffffffff, 0, 0, 0 };\n+  __v4sf a, b, c;\n+  /* PowerISA VMX does not allow partial (for just element 0)\n+   * results. So to insure we don't generate spurious exceptions\n+   * (from the upper elements) we splat the lower float\n+   * before we to the operation. */\n+  a = vec_splat ((__v4sf) __A, 0);\n+  b = vec_splat ((__v4sf) __B, 0);\n+  c = (__v4sf) vec_cmpgt(a, b);\n+  /* Then we merge the lower float result with the original upper\n+   * float elements from __A.  */\n+  return ((__m128)vec_sel ((__v4sf)__A, c, mask));\n+}\n+\n+extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_cmpge_ss (__m128 __A, __m128 __B)\n+{\n+  static const __vector unsigned int mask =\n+    { 0xffffffff, 0, 0, 0 };\n+  __v4sf a, b, c;\n+  /* PowerISA VMX does not allow partial (for just element 0)\n+   * results. So to insure we don't generate spurious exceptions\n+   * (from the upper elements) we splat the lower float\n+   * before we to the operation. */\n+  a = vec_splat ((__v4sf) __A, 0);\n+  b = vec_splat ((__v4sf) __B, 0);\n+  c = (__v4sf) vec_cmpge(a, b);\n+  /* Then we merge the lower float result with the original upper\n+   * float elements from __A.  */\n+  return ((__m128)vec_sel ((__v4sf)__A, c, mask));\n+}\n+\n+extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_cmpneq_ss (__m128 __A, __m128 __B)\n+{\n+  static const __vector unsigned int mask =\n+    { 0xffffffff, 0, 0, 0 };\n+  __v4sf a, b, c;\n+  /* PowerISA VMX does not allow partial (for just element 0)\n+   * results. So to insure we don't generate spurious exceptions\n+   * (from the upper elements) we splat the lower float\n+   * before we to the operation. */\n+  a = vec_splat ((__v4sf) __A, 0);\n+  b = vec_splat ((__v4sf) __B, 0);\n+  c = (__v4sf) vec_cmpeq(a, b);\n+  c = vec_nor (c, c);\n+  /* Then we merge the lower float result with the original upper\n+   * float elements from __A.  */\n+  return ((__m128)vec_sel ((__v4sf)__A, c, mask));\n+}\n+\n+extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_cmpnlt_ss (__m128 __A, __m128 __B)\n+{\n+  static const __vector unsigned int mask =\n+    { 0xffffffff, 0, 0, 0 };\n+  __v4sf a, b, c;\n+  /* PowerISA VMX does not allow partial (for just element 0)\n+   * results. So to insure we don't generate spurious exceptions\n+   * (from the upper elements) we splat the lower float\n+   * before we to the operation. */\n+  a = vec_splat ((__v4sf) __A, 0);\n+  b = vec_splat ((__v4sf) __B, 0);\n+  c = (__v4sf) vec_cmpge(a, b);\n+  /* Then we merge the lower float result with the original upper\n+   * float elements from __A.  */\n+  return ((__m128)vec_sel ((__v4sf)__A, c, mask));\n+}\n+\n+extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_cmpnle_ss (__m128 __A, __m128 __B)\n+{\n+  static const __vector unsigned int mask =\n+    { 0xffffffff, 0, 0, 0 };\n+  __v4sf a, b, c;\n+  /* PowerISA VMX does not allow partial (for just element 0)\n+   * results. So to insure we don't generate spurious exceptions\n+   * (from the upper elements) we splat the lower float\n+   * before we to the operation. */\n+  a = vec_splat ((__v4sf) __A, 0);\n+  b = vec_splat ((__v4sf) __B, 0);\n+  c = (__v4sf) vec_cmpgt(a, b);\n+  /* Then we merge the lower float result with the original upper\n+   * float elements from __A.  */\n+  return ((__m128)vec_sel ((__v4sf)__A, c, mask));\n+}\n+\n+extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_cmpngt_ss (__m128 __A, __m128 __B)\n+{\n+  static const __vector unsigned int mask =\n+    { 0xffffffff, 0, 0, 0 };\n+  __v4sf a, b, c;\n+  /* PowerISA VMX does not allow partial (for just element 0)\n+   * results. So to insure we don't generate spurious exceptions\n+   * (from the upper elements) we splat the lower float\n+   * before we to the operation. */\n+  a = vec_splat ((__v4sf) __A, 0);\n+  b = vec_splat ((__v4sf) __B, 0);\n+  c = (__v4sf) vec_cmple(a, b);\n+  /* Then we merge the lower float result with the original upper\n+   * float elements from __A.  */\n+  return ((__m128)vec_sel ((__v4sf)__A, c, mask));\n+}\n+\n+extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_cmpnge_ss (__m128 __A, __m128 __B)\n+{\n+  static const __vector unsigned int mask =\n+    { 0xffffffff, 0, 0, 0 };\n+  __v4sf a, b, c;\n+  /* PowerISA VMX does not allow partial (for just element 0)\n+   * results. So to insure we don't generate spurious exceptions\n+   * (from the upper elements) we splat the lower float\n+   * before we do the operation. */\n+  a = vec_splat ((__v4sf) __A, 0);\n+  b = vec_splat ((__v4sf) __B, 0);\n+  c = (__v4sf) vec_cmplt(a, b);\n+  /* Then we merge the lower float result with the original upper\n+   * float elements from __A.  */\n+  return ((__m128)vec_sel ((__v4sf)__A, c, mask));\n+}\n+\n+extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_cmpord_ss (__m128 __A, __m128 __B)\n+{\n+  __vector unsigned int a, b;\n+  __vector unsigned int c, d;\n+  static const __vector unsigned int float_exp_mask =\n+    { 0x7f800000, 0x7f800000, 0x7f800000, 0x7f800000 };\n+  static const __vector unsigned int mask =\n+    { 0xffffffff, 0, 0, 0 };\n+\n+  a = (__vector unsigned int) vec_abs ((__v4sf)__A);\n+  b = (__vector unsigned int) vec_abs ((__v4sf)__B);\n+  c = (__vector unsigned int) vec_cmpgt (float_exp_mask, a);\n+  d = (__vector unsigned int) vec_cmpgt (float_exp_mask, b);\n+  c = vec_and (c, d);\n+  /* Then we merge the lower float result with the original upper\n+   * float elements from __A.  */\n+  return ((__m128)vec_sel ((__v4sf)__A, (__v4sf)c, mask));\n+}\n+\n+extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_cmpunord_ss (__m128 __A, __m128 __B)\n+{\n+  __vector unsigned int a, b;\n+  __vector unsigned int c, d;\n+  static const __vector unsigned int float_exp_mask =\n+    { 0x7f800000, 0x7f800000, 0x7f800000, 0x7f800000 };\n+  static const __vector unsigned int mask =\n+    { 0xffffffff, 0, 0, 0 };\n+\n+  a = (__vector unsigned int) vec_abs ((__v4sf)__A);\n+  b = (__vector unsigned int) vec_abs ((__v4sf)__B);\n+  c = (__vector unsigned int) vec_cmpgt (a, float_exp_mask);\n+  d = (__vector unsigned int) vec_cmpgt (b, float_exp_mask);\n+  c = vec_or (c, d);\n+  /* Then we merge the lower float result with the original upper\n+   * float elements from __A.  */\n+  return ((__m128)vec_sel ((__v4sf)__A, (__v4sf)c, mask));\n+}\n+\n+/* Compare the lower SPFP values of A and B and return 1 if true\n+   and 0 if false.  */\n+extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_comieq_ss (__m128 __A, __m128 __B)\n+{\n+  return (__A[0] == __B[0]);\n+}\n+\n+extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_comilt_ss (__m128 __A, __m128 __B)\n+{\n+  return (__A[0] < __B[0]);\n+}\n+\n+extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_comile_ss (__m128 __A, __m128 __B)\n+{\n+  return (__A[0] <= __B[0]);\n+}\n+\n+extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_comigt_ss (__m128 __A, __m128 __B)\n+{\n+  return (__A[0] > __B[0]);\n+}\n+\n+extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_comige_ss (__m128 __A, __m128 __B)\n+{\n+  return (__A[0] >= __B[0]);\n+}\n+\n+extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_comineq_ss (__m128 __A, __m128 __B)\n+{\n+  return (__A[0] != __B[0]);\n+}\n+\n+/* FIXME\n+ * The __mm_ucomi??_ss implementations below are exactly the same as\n+ * __mm_comi??_ss because GCC for PowerPC only generates unordered\n+ * compares (scalar and vector).\n+ * Technically __mm_comieq_ss et al should be using the ordered\n+ * compare and signal for QNaNs.\n+ * The __mm_ucomieq_sd et all should be OK, as is.\n+ */\n+extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_ucomieq_ss (__m128 __A, __m128 __B)\n+{\n+  return (__A[0] == __B[0]);\n+}\n+\n+extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_ucomilt_ss (__m128 __A, __m128 __B)\n+{\n+  return (__A[0] < __B[0]);\n+}\n+\n+extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_ucomile_ss (__m128 __A, __m128 __B)\n+{\n+  return (__A[0] <= __B[0]);\n+}\n+\n+extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_ucomigt_ss (__m128 __A, __m128 __B)\n+{\n+  return (__A[0] > __B[0]);\n+}\n+\n+extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_ucomige_ss (__m128 __A, __m128 __B)\n+{\n+  return (__A[0] >= __B[0]);\n+}\n+\n+extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_ucomineq_ss (__m128 __A, __m128 __B)\n+{\n+  return (__A[0] != __B[0]);\n+}\n+\n+extern __inline float __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_cvtss_f32 (__m128 __A)\n+{\n+  return ((__v4sf)__A)[0];\n+}\n+\n+/* Convert the lower SPFP value to a 32-bit integer according to the current\n+   rounding mode.  */\n+extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_cvtss_si32 (__m128 __A)\n+{\n+  __m64 res = 0;\n+#ifdef _ARCH_PWR8\n+  __m128 vtmp;\n+  __asm__(\n+      \"xxsldwi %x1,%x2,%x2,3;\\n\"\n+      \"xscvspdp %x1,%x1;\\n\"\n+      \"fctiw  %1,%1;\\n\"\n+      \"mfvsrd  %0,%x1;\\n\"\n+      : \"=r\" (res),\n+\t\"=&wi\" (vtmp)\n+      : \"wa\" (__A)\n+      : );\n+#else\n+  res = __builtin_rint(__A[0]);\n+#endif\n+  return (res);\n+}\n+\n+extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_cvt_ss2si (__m128 __A)\n+{\n+  return _mm_cvtss_si32 (__A);\n+}\n+\n+/* Convert the lower SPFP value to a 32-bit integer according to the\n+   current rounding mode.  */\n+\n+/* Intel intrinsic.  */\n+extern __inline long long __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_cvtss_si64 (__m128 __A)\n+{\n+  __m64 res = 0;\n+#ifdef _ARCH_PWR8\n+  __m128 vtmp;\n+  __asm__(\n+      \"xxsldwi %x1,%x2,%x2,3;\\n\"\n+      \"xscvspdp %x1,%x1;\\n\"\n+      \"fctid  %1,%1;\\n\"\n+      \"mfvsrd  %0,%x1;\\n\"\n+      : \"=r\" (res),\n+\t\"=&wi\" (vtmp)\n+      : \"wa\" (__A)\n+      : );\n+#else\n+  res = __builtin_llrint(__A[0]);\n+#endif\n+  return (res);\n+}\n+\n+/* Microsoft intrinsic.  */\n+extern __inline long long __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_cvtss_si64x (__m128 __A)\n+{\n+  return _mm_cvtss_si64 ((__v4sf) __A);\n+}\n+\n+/* Constants for use with _mm_prefetch.  */\n+enum _mm_hint\n+{\n+  /* _MM_HINT_ET is _MM_HINT_T with set 3rd bit.  */\n+  _MM_HINT_ET0 = 7,\n+  _MM_HINT_ET1 = 6,\n+  _MM_HINT_T0 = 3,\n+  _MM_HINT_T1 = 2,\n+  _MM_HINT_T2 = 1,\n+  _MM_HINT_NTA = 0\n+};\n+\n+/* Loads one cache line from address P to a location \"closer\" to the\n+   processor.  The selector I specifies the type of prefetch operation.  */\n+extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_prefetch (const void *__P, enum _mm_hint __I)\n+{\n+  /* Current PowerPC will ignores the hint parameters.  */\n+  __builtin_prefetch (__P);\n+}\n+\n+/* Convert the two lower SPFP values to 32-bit integers according to the\n+   current rounding mode.  Return the integers in packed form.  */\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_cvtps_pi32 (__m128 __A)\n+{\n+  /* Splat two lower SPFP values to both halves.  */\n+  __v4sf temp, rounded;\n+  __vector __m64 result;\n+\n+  /* Splat two lower SPFP values to both halves.  */\n+  temp = (__v4sf) vec_splat ((__vector long long)__A, 0);\n+  rounded = vec_rint(temp);\n+  result = (__vector __m64) vec_cts (rounded, 0);\n+\n+  return ((__m64) __builtin_unpack_vector_int128 ((__vector __int128)result, 0));\n+}\n+\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_cvt_ps2pi (__m128 __A)\n+{\n+  return _mm_cvtps_pi32 (__A);\n+}\n+\n+/* Truncate the lower SPFP value to a 32-bit integer.  */\n+extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_cvttss_si32 (__m128 __A)\n+{\n+  /* Extract the lower float element.  */\n+  float temp = __A[0];\n+  /* truncate to 32-bit integer and return.  */\n+  return temp;\n+}\n+\n+extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_cvtt_ss2si (__m128 __A)\n+{\n+  return _mm_cvttss_si32 (__A);\n+}\n+\n+/* Intel intrinsic.  */\n+extern __inline long long __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_cvttss_si64 (__m128 __A)\n+{\n+  /* Extract the lower float element.  */\n+  float temp = __A[0];\n+  /* truncate to 32-bit integer and return.  */\n+  return temp;\n+}\n+\n+/* Microsoft intrinsic.  */\n+extern __inline long long __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_cvttss_si64x (__m128 __A)\n+{\n+  /* Extract the lower float element.  */\n+  float temp = __A[0];\n+  /* truncate to 32-bit integer and return.  */\n+  return temp;\n+}\n+\n+/* Truncate the two lower SPFP values to 32-bit integers.  Return the\n+   integers in packed form.  */\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_cvttps_pi32 (__m128 __A)\n+{\n+  __v4sf temp;\n+  __vector __m64 result;\n+\n+  /* Splat two lower SPFP values to both halves.  */\n+  temp = (__v4sf) vec_splat ((__vector long long)__A, 0);\n+  result = (__vector __m64) vec_cts (temp, 0);\n+\n+  return ((__m64) __builtin_unpack_vector_int128 ((__vector __int128)result, 0));\n+}\n+\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_cvtt_ps2pi (__m128 __A)\n+{\n+  return _mm_cvttps_pi32 (__A);\n+}\n+\n+/* Convert B to a SPFP value and insert it as element zero in A.  */\n+extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_cvtsi32_ss (__m128 __A, int __B)\n+{\n+  float temp = __B;\n+  __A[0] = temp;\n+\n+  return __A;\n+}\n+\n+extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_cvt_si2ss (__m128 __A, int __B)\n+{\n+  return _mm_cvtsi32_ss (__A, __B);\n+}\n+\n+/* Convert B to a SPFP value and insert it as element zero in A.  */\n+/* Intel intrinsic.  */\n+extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_cvtsi64_ss (__m128 __A, long long __B)\n+{\n+  float temp = __B;\n+  __A[0] = temp;\n+\n+  return __A;\n+}\n+\n+/* Microsoft intrinsic.  */\n+extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_cvtsi64x_ss (__m128 __A, long long __B)\n+{\n+  return _mm_cvtsi64_ss (__A, __B);\n+}\n+\n+/* Convert the two 32-bit values in B to SPFP form and insert them\n+   as the two lower elements in A.  */\n+extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_cvtpi32_ps (__m128        __A, __m64        __B)\n+{\n+  __vector signed int vm1;\n+  __vector float vf1;\n+\n+  vm1 = (__vector signed int) __builtin_pack_vector_int128 (__B, __B);\n+  vf1 = (__vector float) vec_ctf (vm1, 0);\n+\n+  return ((__m128) (__vector __m64)\n+    { ((__vector __m64)vf1) [0], ((__vector __m64)__A) [1]});\n+}\n+\n+extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_cvt_pi2ps (__m128 __A, __m64 __B)\n+{\n+  return _mm_cvtpi32_ps (__A, __B);\n+}\n+\n+/* Convert the four signed 16-bit values in A to SPFP form.  */\n+extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_cvtpi16_ps (__m64 __A)\n+{\n+  __vector signed short vs8;\n+  __vector signed int vi4;\n+  __vector float vf1;\n+\n+  vs8 = (__vector signed short) __builtin_pack_vector_int128 (__A, __A);\n+  vi4 = vec_vupklsh (vs8);\n+  vf1 = (__vector float) vec_ctf (vi4, 0);\n+\n+  return (__m128) vf1;\n+}\n+\n+/* Convert the four unsigned 16-bit values in A to SPFP form.  */\n+extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_cvtpu16_ps (__m64 __A)\n+{\n+  const __vector unsigned short zero =\n+    { 0, 0, 0, 0, 0, 0, 0, 0 };\n+  __vector unsigned short vs8;\n+  __vector unsigned int vi4;\n+  __vector float vf1;\n+\n+  vs8 = (__vector unsigned short) __builtin_pack_vector_int128 (__A, __A);\n+  vi4 = (__vector unsigned int) vec_vmrglh (vs8, zero);\n+  vf1 = (__vector float) vec_ctf (vi4, 0);\n+\n+  return (__m128) vf1;\n+}\n+\n+/* Convert the low four signed 8-bit values in A to SPFP form.  */\n+extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_cvtpi8_ps (__m64 __A)\n+{\n+  __vector signed char vc16;\n+  __vector signed short vs8;\n+  __vector signed int vi4;\n+  __vector float vf1;\n+\n+  vc16 = (__vector signed char) __builtin_pack_vector_int128 (__A, __A);\n+  vs8 = vec_vupkhsb (vc16);\n+  vi4 = vec_vupkhsh (vs8);\n+  vf1 = (__vector float) vec_ctf (vi4, 0);\n+\n+  return (__m128) vf1;\n+}\n+\n+/* Convert the low four unsigned 8-bit values in A to SPFP form.  */\n+extern __inline  __m128  __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+\n+_mm_cvtpu8_ps (__m64  __A)\n+{\n+  const __vector unsigned char zero =\n+    { 0, 0, 0, 0, 0, 0, 0, 0 };\n+  __vector unsigned char vc16;\n+  __vector unsigned short vs8;\n+  __vector unsigned int vi4;\n+  __vector float vf1;\n+\n+  vc16 = (__vector unsigned char) __builtin_pack_vector_int128 (__A, __A);\n+  vs8 = (__vector unsigned short) vec_vmrglb (vc16, zero);\n+  vi4 = (__vector unsigned int) vec_vmrghh (vs8,\n+\t\t\t\t\t    (__vector unsigned short) zero);\n+  vf1 = (__vector float) vec_ctf (vi4, 0);\n+\n+  return (__m128) vf1;\n+}\n+\n+/* Convert the four signed 32-bit values in A and B to SPFP form.  */\n+extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_cvtpi32x2_ps(__m64 __A, __m64 __B)\n+{\n+  __vector signed int vi4;\n+  __vector float vf4;\n+\n+  vi4 = (__vector signed int) __builtin_pack_vector_int128 (__B, __A);\n+  vf4 = (__vector float) vec_ctf (vi4, 0);\n+  return (__m128) vf4;\n+}\n+\n+/* Convert the four SPFP values in A to four signed 16-bit integers.  */\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_cvtps_pi16(__m128 __A)\n+{\n+  __v4sf rounded;\n+  __vector signed int temp;\n+  __vector __m64 result;\n+\n+  rounded = vec_rint(__A);\n+  temp = vec_cts (rounded, 0);\n+  result = (__vector __m64) vec_pack (temp, temp);\n+\n+  return ((__m64) __builtin_unpack_vector_int128 ((__vector __int128)result, 0));\n+}\n+\n+/* Convert the four SPFP values in A to four signed 8-bit integers.  */\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_cvtps_pi8(__m128 __A)\n+{\n+  __v4sf rounded;\n+  __vector signed int tmp_i;\n+  static const __vector signed int zero = {0, 0, 0, 0};\n+  __vector signed short tmp_s;\n+  __vector signed char res_v;\n+  __m64 result;\n+\n+  rounded = vec_rint(__A);\n+  tmp_i = vec_cts (rounded, 0);\n+  tmp_s = vec_pack (tmp_i, zero);\n+  res_v = vec_pack (tmp_s, tmp_s);\n+  result = (__m64) __builtin_unpack_vector_int128 ((__vector __int128)res_v, 0);\n+\n+  return (result);\n+}\n+\n+/* Selects four specific SPFP values from A and B based on MASK.  */\n+extern __inline  __m128  __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+\n+_mm_shuffle_ps (__m128  __A, __m128  __B, int const __mask)\n+{\n+  unsigned long element_selector_10 = __mask & 0x03;\n+  unsigned long element_selector_32 = (__mask >> 2) & 0x03;\n+  unsigned long element_selector_54 = (__mask >> 4) & 0x03;\n+  unsigned long element_selector_76 = (__mask >> 6) & 0x03;\n+  static const unsigned int permute_selectors[4] =\n+    {\n+#ifdef __LITTLE_ENDIAN__\n+      0x03020100, 0x07060504, 0x0B0A0908, 0x0F0E0D0C\n+#elif __BIG_ENDIAN__\n+      0x0C0D0E0F, 0x08090A0B, 0x04050607, 0x00010203\n+#endif\n+    };\n+  __vector unsigned int t;\n+\n+#ifdef __LITTLE_ENDIAN__\n+  t[0] = permute_selectors[element_selector_10];\n+  t[1] = permute_selectors[element_selector_32];\n+  t[2] = permute_selectors[element_selector_54] + 0x10101010;\n+  t[3] = permute_selectors[element_selector_76] + 0x10101010;\n+#elif __BIG_ENDIAN__\n+  t[3] = permute_selectors[element_selector_10] + 0x10101010;\n+  t[2] = permute_selectors[element_selector_32] + 0x10101010;\n+  t[1] = permute_selectors[element_selector_54];\n+  t[0] = permute_selectors[element_selector_76];\n+#endif\n+  return vec_perm ((__v4sf) __A, (__v4sf)__B, (__vector unsigned char)t);\n+}\n+\n+/* Selects and interleaves the upper two SPFP values from A and B.  */\n+extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_unpackhi_ps (__m128 __A, __m128 __B)\n+{\n+  return (__m128) vec_vmrglw ((__v4sf) __A, (__v4sf)__B);\n+}\n+\n+/* Selects and interleaves the lower two SPFP values from A and B.  */\n+extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_unpacklo_ps (__m128 __A, __m128 __B)\n+{\n+  return (__m128) vec_vmrghw ((__v4sf) __A, (__v4sf)__B);\n+}\n+\n+/* Sets the upper two SPFP values with 64-bits of data loaded from P;\n+   the lower two values are passed through from A.  */\n+extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_loadh_pi (__m128 __A, __m64 const *__P)\n+{\n+  __vector __m64 __a = (__vector __m64)__A;\n+  __vector __m64 __p = vec_splats(*__P);\n+  __a [1] = __p [1];\n+\n+  return (__m128)__a;\n+}\n+\n+/* Stores the upper two SPFP values of A into P.  */\n+extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_storeh_pi (__m64 *__P, __m128 __A)\n+{\n+  __vector __m64 __a = (__vector __m64) __A;\n+\n+  *__P = __a[1];\n+}\n+\n+/* Moves the upper two values of B into the lower two values of A.  */\n+extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_movehl_ps (__m128 __A, __m128 __B)\n+{\n+  return (__m128) vec_mergel ((__vector __m64)__B, (__vector __m64)__A);\n+}\n+\n+/* Moves the lower two values of B into the upper two values of A.  */\n+extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_movelh_ps (__m128 __A, __m128 __B)\n+{\n+  return (__m128) vec_mergeh ((__vector __m64)__A, (__vector __m64)__B);\n+}\n+\n+/* Sets the lower two SPFP values with 64-bits of data loaded from P;\n+   the upper two values are passed through from A.  */\n+extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_loadl_pi (__m128 __A, __m64 const *__P)\n+{\n+  __vector __m64 __a = (__vector __m64)__A;\n+  __vector __m64 __p = vec_splats(*__P);\n+  __a [0] = __p [0];\n+\n+  return (__m128)__a;\n+}\n+\n+/* Stores the lower two SPFP values of A into P.  */\n+extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_storel_pi (__m64 *__P, __m128 __A)\n+{\n+  __vector __m64 __a = (__vector __m64) __A;\n+\n+  *__P = __a[0];\n+}\n+\n+#ifdef _ARCH_PWR8\n+/* Intrinsic functions that require PowerISA 2.07 minimum.  */\n+\n+/* Creates a 4-bit mask from the most significant bits of the SPFP values.  */\n+extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_movemask_ps (__m128  __A)\n+{\n+  __vector __m64 result;\n+  static const __vector unsigned int perm_mask =\n+    {\n+#ifdef __LITTLE_ENDIAN__\n+\t0x00204060, 0x80808080, 0x80808080, 0x80808080\n+#elif __BIG_ENDIAN__\n+      0x80808080, 0x80808080, 0x80808080, 0x00204060\n+#endif\n+    };\n+\n+  result = (__vector __m64) vec_vbpermq ((__vector unsigned char) __A,\n+\t\t\t\t\t (__vector unsigned char) perm_mask);\n+\n+#ifdef __LITTLE_ENDIAN__\n+  return result[1];\n+#elif __BIG_ENDIAN__\n+  return result[0];\n+#endif\n+}\n+#endif /* _ARCH_PWR8 */\n+\n+/* Create a vector with all four elements equal to *P.  */\n+extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_load1_ps (float const *__P)\n+{\n+  return _mm_set1_ps (*__P);\n+}\n+\n+extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_load_ps1 (float const *__P)\n+{\n+  return _mm_load1_ps (__P);\n+}\n+\n+/* Extracts one of the four words of A.  The selector N must be immediate.  */\n+extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_extract_pi16 (__m64 const __A, int const __N)\n+{\n+  const int shiftr = (__N & 3) * 16;\n+\n+  return ((__A >> shiftr) & 0xffff);\n+}\n+\n+extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_m_pextrw (__m64 const __A, int const __N)\n+{\n+  return _mm_extract_pi16 (__A, __N);\n+}\n+\n+/* Inserts word D into one of four words of A.  The selector N must be\n+   immediate.  */\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_insert_pi16 (__m64 const __A, int const __D, int const __N)\n+{\n+  const int shiftl = (__N & 3) * 16;\n+  const __m64 shiftD = (const __m64) __D << shiftl;\n+  const __m64 mask = 0xffffUL << shiftl;\n+  __m64 result = (__A & (~mask)) | (shiftD & mask);\n+\n+  return (result);\n+}\n+\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_m_pinsrw (__m64 const __A, int const __D, int const __N)\n+{\n+  return _mm_insert_pi16 (__A, __D, __N);\n+}\n+\n+/* Compute the element-wise maximum of signed 16-bit values.  */\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+\n+_mm_max_pi16 (__m64 __A, __m64 __B)\n+{\n+#if _ARCH_PWR8\n+  __vector signed short a, b, r;\n+  __vector bool short c;\n+\n+  a = (__vector signed short)vec_splats (__A);\n+  b = (__vector signed short)vec_splats (__B);\n+  c = (__vector bool short)vec_cmpgt (a, b);\n+  r = vec_sel (b, a, c);\n+  return (__builtin_unpack_vector_int128 ((__vector __int128_t)r, 0));\n+#else\n+  __m64_union m1, m2, res;\n+\n+  m1.as_m64 = __A;\n+  m2.as_m64 = __B;\n+\n+  res.as_short[0] =\n+      (m1.as_short[0] > m2.as_short[0]) ? m1.as_short[0] : m2.as_short[0];\n+  res.as_short[1] =\n+      (m1.as_short[1] > m2.as_short[1]) ? m1.as_short[1] : m2.as_short[1];\n+  res.as_short[2] =\n+      (m1.as_short[2] > m2.as_short[2]) ? m1.as_short[2] : m2.as_short[2];\n+  res.as_short[3] =\n+      (m1.as_short[3] > m2.as_short[3]) ? m1.as_short[3] : m2.as_short[3];\n+\n+  return (__m64) res.as_m64;\n+#endif\n+}\n+\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_m_pmaxsw (__m64 __A, __m64 __B)\n+{\n+  return _mm_max_pi16 (__A, __B);\n+}\n+\n+/* Compute the element-wise maximum of unsigned 8-bit values.  */\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_max_pu8 (__m64 __A, __m64 __B)\n+{\n+#if _ARCH_PWR8\n+  __vector unsigned char a, b, r;\n+  __vector bool char c;\n+\n+  a = (__vector unsigned char)vec_splats (__A);\n+  b = (__vector unsigned char)vec_splats (__B);\n+  c = (__vector bool char)vec_cmpgt (a, b);\n+  r = vec_sel (b, a, c);\n+  return (__builtin_unpack_vector_int128 ((__vector __int128_t)r, 0));\n+#else\n+  __m64_union m1, m2, res;\n+  long i;\n+\n+  m1.as_m64 = __A;\n+  m2.as_m64 = __B;\n+\n+\n+  for (i = 0; i < 8; i++)\n+  res.as_char[i] =\n+      ((unsigned char) m1.as_char[i] > (unsigned char) m2.as_char[i]) ?\n+\t  m1.as_char[i] : m2.as_char[i];\n+\n+  return (__m64) res.as_m64;\n+#endif\n+}\n+\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_m_pmaxub (__m64 __A, __m64 __B)\n+{\n+  return _mm_max_pu8 (__A, __B);\n+}\n+\n+/* Compute the element-wise minimum of signed 16-bit values.  */\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_min_pi16 (__m64 __A, __m64 __B)\n+{\n+#if _ARCH_PWR8\n+  __vector signed short a, b, r;\n+  __vector bool short c;\n+\n+  a = (__vector signed short)vec_splats (__A);\n+  b = (__vector signed short)vec_splats (__B);\n+  c = (__vector bool short)vec_cmplt (a, b);\n+  r = vec_sel (b, a, c);\n+  return (__builtin_unpack_vector_int128 ((__vector __int128_t)r, 0));\n+#else\n+  __m64_union m1, m2, res;\n+\n+  m1.as_m64 = __A;\n+  m2.as_m64 = __B;\n+\n+  res.as_short[0] =\n+      (m1.as_short[0] < m2.as_short[0]) ? m1.as_short[0] : m2.as_short[0];\n+  res.as_short[1] =\n+      (m1.as_short[1] < m2.as_short[1]) ? m1.as_short[1] : m2.as_short[1];\n+  res.as_short[2] =\n+      (m1.as_short[2] < m2.as_short[2]) ? m1.as_short[2] : m2.as_short[2];\n+  res.as_short[3] =\n+      (m1.as_short[3] < m2.as_short[3]) ? m1.as_short[3] : m2.as_short[3];\n+\n+  return (__m64) res.as_m64;\n+#endif\n+}\n+\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_m_pminsw (__m64 __A, __m64 __B)\n+{\n+  return _mm_min_pi16 (__A, __B);\n+}\n+\n+/* Compute the element-wise minimum of unsigned 8-bit values.  */\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_min_pu8 (__m64 __A, __m64 __B)\n+{\n+#if _ARCH_PWR8\n+  __vector unsigned char a, b, r;\n+  __vector bool char c;\n+\n+  a = (__vector unsigned char)vec_splats (__A);\n+  b = (__vector unsigned char)vec_splats (__B);\n+  c = (__vector bool char)vec_cmplt (a, b);\n+  r = vec_sel (b, a, c);\n+  return (__builtin_unpack_vector_int128 ((__vector __int128_t)r, 0));\n+#else\n+  __m64_union m1, m2, res;\n+  long i;\n+\n+  m1.as_m64 = __A;\n+  m2.as_m64 = __B;\n+\n+\n+  for (i = 0; i < 8; i++)\n+  res.as_char[i] =\n+      ((unsigned char) m1.as_char[i] < (unsigned char) m2.as_char[i]) ?\n+\t  m1.as_char[i] : m2.as_char[i];\n+\n+  return (__m64) res.as_m64;\n+#endif\n+}\n+\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_m_pminub (__m64 __A, __m64 __B)\n+{\n+  return _mm_min_pu8 (__A, __B);\n+}\n+\n+/* Create an 8-bit mask of the signs of 8-bit values.  */\n+extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_movemask_pi8 (__m64 __A)\n+{\n+  unsigned long p = 0x0008101820283038UL; // permute control for sign bits\n+\n+  return __builtin_bpermd (p, __A);\n+}\n+\n+extern __inline int __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_m_pmovmskb (__m64 __A)\n+{\n+  return _mm_movemask_pi8 (__A);\n+}\n+\n+/* Multiply four unsigned 16-bit values in A by four unsigned 16-bit values\n+   in B and produce the high 16 bits of the 32-bit results.  */\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_mulhi_pu16 (__m64 __A, __m64 __B)\n+{\n+  __vector unsigned short a, b;\n+  __vector unsigned short c;\n+  __vector unsigned int w0, w1;\n+  __vector unsigned char xform1 = {\n+      0x02, 0x03, 0x12, 0x13,  0x06, 0x07, 0x16, 0x17,\n+      0x0A, 0x0B, 0x1A, 0x1B,  0x0E, 0x0F, 0x1E, 0x1F\n+    };\n+\n+  a = (__vector unsigned short)vec_splats (__A);\n+  b = (__vector unsigned short)vec_splats (__B);\n+\n+  w0 = vec_vmuleuh (a, b);\n+  w1 = vec_vmulouh (a, b);\n+  c = (__vector unsigned short)vec_perm (w0, w1, xform1);\n+\n+  return (__builtin_unpack_vector_int128 ((__vector __int128)c, 0));\n+}\n+\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_m_pmulhuw (__m64 __A, __m64 __B)\n+{\n+  return _mm_mulhi_pu16 (__A, __B);\n+}\n+\n+/* Return a combination of the four 16-bit values in A.  The selector\n+   must be an immediate.  */\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_shuffle_pi16 (__m64 __A, int const __N)\n+{\n+  unsigned long element_selector_10 = __N & 0x03;\n+  unsigned long element_selector_32 = (__N >> 2) & 0x03;\n+  unsigned long element_selector_54 = (__N >> 4) & 0x03;\n+  unsigned long element_selector_76 = (__N >> 6) & 0x03;\n+  static const unsigned short permute_selectors[4] =\n+    {\n+#ifdef __LITTLE_ENDIAN__\n+\t      0x0908, 0x0B0A, 0x0D0C, 0x0F0E\n+#elif __BIG_ENDIAN__\n+\t      0x0607, 0x0405, 0x0203, 0x0001\n+#endif\n+    };\n+  __m64_union t;\n+  __vector __m64 a, p, r;\n+\n+#ifdef __LITTLE_ENDIAN__\n+  t.as_short[0] = permute_selectors[element_selector_10];\n+  t.as_short[1] = permute_selectors[element_selector_32];\n+  t.as_short[2] = permute_selectors[element_selector_54];\n+  t.as_short[3] = permute_selectors[element_selector_76];\n+#elif __BIG_ENDIAN__\n+  t.as_short[3] = permute_selectors[element_selector_10];\n+  t.as_short[2] = permute_selectors[element_selector_32];\n+  t.as_short[1] = permute_selectors[element_selector_54];\n+  t.as_short[0] = permute_selectors[element_selector_76];\n+#endif\n+  p = vec_splats (t.as_m64);\n+  a = vec_splats (__A);\n+  r = vec_perm (a, a, (__vector unsigned char)p);\n+  return (__builtin_unpack_vector_int128 ((__vector __int128)r, 0));\n+}\n+\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_m_pshufw (__m64 __A, int const __N)\n+{\n+  return _mm_shuffle_pi16 (__A, __N);\n+}\n+\n+/* Conditionally store byte elements of A into P.  The high bit of each\n+   byte in the selector N determines whether the corresponding byte from\n+   A is stored.  */\n+extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_maskmove_si64 (__m64 __A, __m64 __N, char *__P)\n+{\n+  __m64 hibit = 0x8080808080808080UL;\n+  __m64 mask, tmp;\n+  __m64 *p = (__m64*)__P;\n+\n+  tmp = *p;\n+  mask = _mm_cmpeq_pi8 ((__N & hibit), hibit);\n+  tmp = (tmp & (~mask)) | (__A & mask);\n+  *p = tmp;\n+}\n+\n+extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_m_maskmovq (__m64 __A, __m64 __N, char *__P)\n+{\n+  _mm_maskmove_si64 (__A, __N, __P);\n+}\n+\n+/* Compute the rounded averages of the unsigned 8-bit values in A and B.  */\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_avg_pu8 (__m64 __A, __m64 __B)\n+{\n+  __vector unsigned char a, b, c;\n+\n+  a = (__vector unsigned char)vec_splats (__A);\n+  b = (__vector unsigned char)vec_splats (__B);\n+  c = vec_avg (a, b);\n+  return (__builtin_unpack_vector_int128 ((__vector __int128)c, 0));\n+}\n+\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_m_pavgb (__m64 __A, __m64 __B)\n+{\n+  return _mm_avg_pu8 (__A, __B);\n+}\n+\n+/* Compute the rounded averages of the unsigned 16-bit values in A and B.  */\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_avg_pu16 (__m64 __A, __m64 __B)\n+{\n+  __vector unsigned short a, b, c;\n+\n+  a = (__vector unsigned short)vec_splats (__A);\n+  b = (__vector unsigned short)vec_splats (__B);\n+  c = vec_avg (a, b);\n+  return (__builtin_unpack_vector_int128 ((__vector __int128)c, 0));\n+}\n+\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_m_pavgw (__m64 __A, __m64 __B)\n+{\n+  return _mm_avg_pu16 (__A, __B);\n+}\n+\n+/* Compute the sum of the absolute differences of the unsigned 8-bit\n+   values in A and B.  Return the value in the lower 16-bit word; the\n+   upper words are cleared.  */\n+extern __inline    __m64    __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_sad_pu8 (__m64  __A, __m64  __B)\n+{\n+  __vector unsigned char a, b;\n+  __vector unsigned char vmin, vmax, vabsdiff;\n+  __vector signed int vsum;\n+  const __vector unsigned int zero =\n+    { 0, 0, 0, 0 };\n+  unsigned short result;\n+\n+  a = (__vector unsigned char) __builtin_pack_vector_int128 (0UL, __A);\n+  b = (__vector unsigned char) __builtin_pack_vector_int128 (0UL, __B);\n+  vmin = vec_min (a, b);\n+  vmax = vec_max (a, b);\n+  vabsdiff = vec_sub (vmax, vmin);\n+  /* Sum four groups of bytes into integers.  */\n+  vsum = (__vector signed int) vec_sum4s (vabsdiff, zero);\n+  /* Sum across four integers with integer result.  */\n+  vsum = vec_sums (vsum, (__vector signed int) zero);\n+  /* The sum is in the right most 32-bits of the vector result.\n+     Transfer to a GPR and truncate to 16 bits.  */\n+  result = vsum[3];\n+  return (result);\n+}\n+\n+extern __inline __m64 __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_m_psadbw (__m64 __A, __m64 __B)\n+{\n+  return _mm_sad_pu8 (__A, __B);\n+}\n+\n+/* Stores the data in A to the address P without polluting the caches.  */\n+extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_stream_pi (__m64 *__P, __m64 __A)\n+{\n+  /* Use the data cache block touch for store transient.  */\n+  __asm__ (\n+    \"\tdcbtstt\t0,%0\"\n+    :\n+    : \"b\" (__P)\n+    : \"memory\"\n+  );\n+  *__P = __A;\n+}\n+\n+/* Likewise.  The address must be 16-byte aligned.  */\n+extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_stream_ps (float *__P, __m128 __A)\n+{\n+  /* Use the data cache block touch for store transient.  */\n+  __asm__ (\n+    \"\tdcbtstt\t0,%0\"\n+    :\n+    : \"b\" (__P)\n+    : \"memory\"\n+  );\n+  _mm_store_ps (__P, __A);\n+}\n+\n+/* Guarantees that every preceding store is globally visible before\n+   any subsequent store.  */\n+extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_sfence (void)\n+{\n+  /* Generate a light weight sync.  */\n+  __atomic_thread_fence (__ATOMIC_RELEASE);\n+}\n+\n+/* The execution of the next instruction is delayed by an implementation\n+   specific amount of time.  The instruction does not modify the\n+   architectural state.  This is after the pop_options pragma because\n+   it does not require SSE support in the processor--the encoding is a\n+   nop on processors that do not support it.  */\n+extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))\n+_mm_pause (void)\n+{\n+  /* There is no exact match with this construct, but the following is\n+     close to the desired effect.  */\n+#if _ARCH_PWR8\n+  /* On power8 and later processors we can depend on Program Priority\n+     (PRI) and associated \"very low\" PPI setting.  Since we don't know\n+     what PPI this thread is running at we: 1) save the current PRI\n+     from the PPR SPR into a local GRP, 2) set the PRI to \"very low*\n+     via the special or 31,31,31 encoding. 3) issue an \"isync\" to\n+     insure the PRI change takes effect before we execute any more\n+     instructions.\n+     Now we can execute a lwsync (release barrier) while we execute\n+     this thread at \"very low\" PRI.  Finally we restore the original\n+     PRI and continue execution.  */\n+  unsigned long __PPR;\n+\n+  __asm__ volatile (\n+    \"\tmfppr\t%0;\"\n+    \"   or 31,31,31;\"\n+    \"   isync;\"\n+    \"   lwsync;\"\n+    \"   isync;\"\n+    \"   mtppr\t%0;\"\n+    : \"=r\" (__PPR)\n+    :\n+    : \"memory\"\n+  );\n+#else\n+  /* For older processor where we may not even have Program Priority\n+     controls we can only depend on Heavy Weight Sync.  */\n+  __atomic_thread_fence (__ATOMIC_SEQ_CST);\n+#endif\n+}\n+\n+/* Transpose the 4x4 matrix composed of row[0-3].  */\n+#define _MM_TRANSPOSE4_PS(row0, row1, row2, row3)\t\t\t\\\n+do {\t\t\t\t\t\t\t\t\t\\\n+  __v4sf __r0 = (row0), __r1 = (row1), __r2 = (row2), __r3 = (row3);\t\\\n+  __v4sf __t0 = vec_vmrghw (__r0, __r1);\t\t\t\\\n+  __v4sf __t1 = vec_vmrghw (__r2, __r3);\t\t\t\\\n+  __v4sf __t2 = vec_vmrglw (__r0, __r1);\t\t\t\\\n+  __v4sf __t3 = vec_vmrglw (__r2, __r3);\t\t\t\\\n+  (row0) = (__v4sf)vec_mergeh ((__vector long long)__t0, \t\\\n+\t\t\t       (__vector long long)__t1);\t\\\n+  (row1) = (__v4sf)vec_mergel ((__vector long long)__t0,\t\\\n+\t\t\t       (__vector long long)__t1);\t\\\n+  (row2) = (__v4sf)vec_mergeh ((__vector long long)__t2,\t\\\n+\t\t\t       (__vector long long)__t3);\t\\\n+  (row3) = (__v4sf)vec_mergel ((__vector long long)__t2,\t\\\n+\t\t\t       (__vector long long)__t3);\t\\\n+} while (0)\n+\n+/* For backward source compatibility.  */\n+//# include <emmintrin.h>\n+\n+#endif /* _XMMINTRIN_H_INCLUDED */"}]}