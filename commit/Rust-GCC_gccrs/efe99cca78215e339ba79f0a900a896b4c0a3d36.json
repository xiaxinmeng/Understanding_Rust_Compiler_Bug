{"sha": "efe99cca78215e339ba79f0a900a896b4c0a3d36", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWZlOTljY2E3ODIxNWUzMzliYTc5ZjBhOTAwYTg5NmI0YzBhM2QzNg==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2020-07-10T18:06:45Z"}, "committer": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2020-07-10T18:06:45Z"}, "message": "arm: Treat GNU and Advanced SIMD vectors as distinct [PR92789, PR95726]\n\nThis is an arm version of aarch64 patch r11-1741.  The approach\nis essentially identical, not much more than s/aarch64/arm/.\n\nTo recap, PR95726 is about template look-up for things like:\n\n    foo<float vecf __attribute__((vector_size(16)))>\n    foo<float32x4_t>\n\nThe immediate cause of the problem is that the hash function usually\nreturns different hashes for these types, yet the equality function\nthinks they are equal.  This then raises the question of how the types\nare supposed to be treated.\n\nThe answer we chose for AArch64 was that the GNU vector type should\nbe treated as distinct from float32x4_t, but that each type should\nimplicitly convert to the other.\n\nThis would mean that, as far as the PR is concerned, the hashing\nfunction is right to (sometimes) treat the types differently and\nthe equality function is wrong to treat them as the same.\n\nThe most obvious way to enforce the type difference is to use a\ntarget-specific type attribute.  That on its own is enough to fix\nthe PR.  The difficulty is deciding whether the knock-on effects\nare acceptable.\n\nOne obvious effect is that GCC then rejects:\n\n    typedef float vecf __attribute__((vector_size(16)));\n    vecf x;\n    float32x4_t &z = x;\n\non the basis that the types are no longer reference-compatible.\nFor AArch64 we took the approach that this was the correct behaviour.\nIt is also consistent with current Clang.\n\nA trickier question is whether:\n\n    vecf x;\n    float32x4_t y;\n    \u2026 c ? x : y \u2026\n\nshould be valid, and if so, what its type should be [PR92789].\nAs explained in the comment in the testcase, GCC and Clang both\naccepted this, but GCC chose the \u201cthen\u201d type while Clang chose\nthe \u201celse\u201d type.  This can lead to different mangling for (probably\nartificial) corner cases, as seen for \u201csel1\u201d and \u201csel2\u201d in the\ntestcase.\n\nAdding the attribute makes GCC reject the conditional expression\nas ambiguous.  For AArch64 we took the approach that this too is\nthe correct behaviour, for the reasons described in the testcase.\nHowever, it does seem to have the potential to break existing code.\n\ngcc/\n\tPR target/92789\n\tPR target/95726\n\t* config/arm/arm.c (arm_attribute_table): Add\n\t\"Advanced SIMD type\".\n\t(arm_comp_type_attributes): Check that the \"Advanced SIMD type\"\n\tattributes are equal.\n\t* config/arm/arm-builtins.c: Include stringpool.h and\n\tattribs.h.\n\t(arm_mangle_builtin_vector_type): Use the mangling recorded\n\tin the \"Advanced SIMD type\" attribute.\n\t(arm_init_simd_builtin_types): Add an \"Advanced SIMD type\"\n\tattribute to each Advanced SIMD type, using the mangled type\n\tas the attribute's single argument.\n\ngcc/testsuite/\n\tPR target/92789\n\tPR target/95726\n\t* g++.target/arm/pr95726.C: New test.", "tree": {"sha": "45e15652dacdcc61fae5337ed27fa8e5a1702fe8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/45e15652dacdcc61fae5337ed27fa8e5a1702fe8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/efe99cca78215e339ba79f0a900a896b4c0a3d36", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/efe99cca78215e339ba79f0a900a896b4c0a3d36", "html_url": "https://github.com/Rust-GCC/gccrs/commit/efe99cca78215e339ba79f0a900a896b4c0a3d36", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/efe99cca78215e339ba79f0a900a896b4c0a3d36/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "02ef74bad652522a2e424f3ffafff2452c4da105", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02ef74bad652522a2e424f3ffafff2452c4da105", "html_url": "https://github.com/Rust-GCC/gccrs/commit/02ef74bad652522a2e424f3ffafff2452c4da105"}], "stats": {"total": 94, "additions": 79, "deletions": 15}, "files": [{"sha": "33e8015b1405033180adc9334bfec8583193777f", "filename": "gcc/config/arm/arm-builtins.c", "status": "modified", "additions": 20, "deletions": 15, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efe99cca78215e339ba79f0a900a896b4c0a3d36/gcc%2Fconfig%2Farm%2Farm-builtins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efe99cca78215e339ba79f0a900a896b4c0a3d36/gcc%2Fconfig%2Farm%2Farm-builtins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-builtins.c?ref=efe99cca78215e339ba79f0a900a896b4c0a3d36", "patch": "@@ -43,6 +43,8 @@\n #include \"sbitmap.h\"\n #include \"stringpool.h\"\n #include \"arm-builtins.h\"\n+#include \"stringpool.h\"\n+#include \"attribs.h\"\n \n #define SIMD_MAX_BUILTIN_ARGS 7\n \n@@ -1457,18 +1459,12 @@ arm_mangle_builtin_scalar_type (const_tree type)\n static const char *\n arm_mangle_builtin_vector_type (const_tree type)\n {\n-  int i;\n-  int nelts = sizeof (arm_simd_types) / sizeof (arm_simd_types[0]);\n-\n-  for (i = 0; i < nelts; i++)\n-    if (arm_simd_types[i].mode ==  TYPE_MODE (type)\n-\t&& TYPE_NAME (type)\n-\t&& TREE_CODE (TYPE_NAME (type)) == TYPE_DECL\n-\t&& DECL_NAME (TYPE_NAME (type))\n-\t&& !strcmp\n-\t     (IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (type))),\n-\t      arm_simd_types[i].name))\n-      return arm_simd_types[i].mangle;\n+  tree attrs = TYPE_ATTRIBUTES (type);\n+  if (tree attr = lookup_attribute (\"Advanced SIMD type\", attrs))\n+    {\n+      tree mangled_name = TREE_VALUE (TREE_VALUE (attr));\n+      return IDENTIFIER_POINTER (mangled_name);\n+    }\n \n   return NULL;\n }\n@@ -1642,9 +1638,18 @@ arm_init_simd_builtin_types (void)\n       if (eltype == NULL)\n \tcontinue;\n       if (arm_simd_types[i].itype == NULL)\n-\tarm_simd_types[i].itype =\n-\t  build_distinct_type_copy\n-\t    (build_vector_type (eltype, GET_MODE_NUNITS (mode)));\n+\t{\n+\t  tree type = build_vector_type (eltype, GET_MODE_NUNITS (mode));\n+\t  type = build_distinct_type_copy (type);\n+\t  SET_TYPE_STRUCTURAL_EQUALITY (type);\n+\n+\t  tree mangled_name = get_identifier (arm_simd_types[i].mangle);\n+\t  tree value = tree_cons (NULL_TREE, mangled_name, NULL_TREE);\n+\t  TYPE_ATTRIBUTES (type)\n+\t    = tree_cons (get_identifier (\"Advanced SIMD type\"), value,\n+\t\t\t TYPE_ATTRIBUTES (type));\n+\t  arm_simd_types[i].itype = type;\n+\t}\n \n       tdecl = add_builtin_type (arm_simd_types[i].name,\n \t\t\t\tarm_simd_types[i].itype);"}, {"sha": "4ed717309ff7a581a7ffc3e7a07bccc47c0f129f", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efe99cca78215e339ba79f0a900a896b4c0a3d36/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efe99cca78215e339ba79f0a900a896b4c0a3d36/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=efe99cca78215e339ba79f0a900a896b4c0a3d36", "patch": "@@ -382,6 +382,7 @@ static const struct attribute_spec arm_attribute_table[] =\n     arm_handle_cmse_nonsecure_entry, NULL },\n   { \"cmse_nonsecure_call\", 0, 0, true, false, false, true,\n     arm_handle_cmse_nonsecure_call, NULL },\n+  { \"Advanced SIMD type\", 1, 1, false, true, false, true, NULL, NULL },\n   { NULL, 0, 0, false, false, false, false, NULL, NULL }\n };\n \f\n@@ -7539,6 +7540,15 @@ arm_comp_type_attributes (const_tree type1, const_tree type2)\n {\n   int l1, l2, s1, s2;\n \n+  tree attrs1 = lookup_attribute (\"Advanced SIMD type\",\n+\t\t\t\t  TYPE_ATTRIBUTES (type1));\n+  tree attrs2 = lookup_attribute (\"Advanced SIMD type\",\n+\t\t\t\t  TYPE_ATTRIBUTES (type2));\n+  if (bool (attrs1) != bool (attrs2))\n+    return 0;\n+  if (attrs1 && !attribute_value_equal (attrs1, attrs2))\n+    return 0;\n+\n   /* Check for mismatch of non-default calling convention.  */\n   if (TREE_CODE (type1) != FUNCTION_TYPE)\n     return 1;"}, {"sha": "5f7dbf11ddc23572c7f0897ab50d8171b6a1d6d0", "filename": "gcc/testsuite/g++.target/arm/pr95726.C", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/efe99cca78215e339ba79f0a900a896b4c0a3d36/gcc%2Ftestsuite%2Fg%2B%2B.target%2Farm%2Fpr95726.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/efe99cca78215e339ba79f0a900a896b4c0a3d36/gcc%2Ftestsuite%2Fg%2B%2B.target%2Farm%2Fpr95726.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.target%2Farm%2Fpr95726.C?ref=efe99cca78215e339ba79f0a900a896b4c0a3d36", "patch": "@@ -0,0 +1,49 @@\n+// { dg-require-effective-target arm_neon_ok }\n+// { dg-add-options arm_neon }\n+\n+#include <arm_neon.h>\n+\n+typedef float vecf __attribute__((vector_size(16)));\n+\n+// This assertion must hold: vecf and float32x4_t have distinct identities\n+// and mangle differently, so they are not interchangeable.\n+template<typename T> struct bar;\n+template<> struct bar<vecf> { static const int x = 1; };\n+template<> struct bar<float32x4_t> { static const int x = 2; };\n+static_assert(bar<vecf>::x + bar<float32x4_t>::x == 3, \"boo\");\n+\n+// GCC 10.1 and earlier accepted this.  However, the rule should be\n+// that GNU vectors and Advanced SIMD vectors are distinct types but\n+// that each one implicitly converts to the other.  The types are not\n+// reference-compatible.\n+//\n+// The behavior tested below is consistent with Clang.\n+vecf x;\n+float32x4_t y;\n+float32x4_t &z = x; // { dg-error {cannot bind non-const lvalue reference} }\n+\n+// These assignment must be valid even in the strictest mode: vecf must\n+// implicitly convert to float32x4_t and vice versa.\n+void foo() { x = y; y = x; }\n+\n+// Previously GCC accepted this and took the type of \"d\" from the \"then\" arm.\n+// It therefore mangled the functions as:\n+//\n+//   _Z4sel1bRDv4_f\n+//   _Z4sel2bR19__simd128_float32_t\n+//\n+// Clang currently also accepts it and takes the type of \"d\" from the\n+// \"else\" arm.  It therefore mangles the functions as follows, which is\n+// inconsistent with the old GCC behavior:\n+//\n+//   _Z4sel1b19__simd128_float32_t\n+//   _Z4sel2bDv4_f\n+//\n+// Given that the types have distinct identities and that each one\n+// implicitly converts to the other (see above), the expression ought\n+// to be rejected as invalid.  This is consistent (by analogy) with the\n+// standard C++ handling of conditional expressions involving class types,\n+// in cases where the \"then\" value implicitly converts to the \"else\" type\n+// and the \"else\" value implicitly converts to the \"then\" type.\n+auto sel1(bool c, decltype(c ? x : y) d) { return d; } // { dg-error {operands to '\\?:' have different types} }\n+auto sel2(bool c, decltype(c ? y : x) d) { return d; } // { dg-error {operands to '\\?:' have different types} }"}]}