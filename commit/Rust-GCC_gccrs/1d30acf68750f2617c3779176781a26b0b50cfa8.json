{"sha": "1d30acf68750f2617c3779176781a26b0b50cfa8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWQzMGFjZjY4NzUwZjI2MTdjMzc3OTE3Njc4MWEyNmIwYjUwY2ZhOA==", "commit": {"author": {"name": "Yuri Rumyantsev", "email": "ysrumyan@gmail.com", "date": "2016-10-17T18:05:12Z"}, "committer": {"name": "H.J. Lu", "email": "hjl@gcc.gnu.org", "date": "2016-10-17T18:05:12Z"}, "message": "Update dom_info\n\n2016-10-17  Yuri Rumyantsev  <ysrumyan@gmail.com>\n\n\t* dominance.c (dom_info::dom_info): Add new constructor for region\n\twhich is vector of basic blocks.\n\t(dom_init): New method to initialize members common for both\n\tconstructors.\n\t(dom_info::dom_info): Invoke dom_init for partial initialization.\n\t(dom_info::get_idom): Add check to corner cases on basic blocks which\n\tare not in region.\n\t(dom_info::calc_dfs_tree): Check M_FAKE_EXIT_EDGE instead of M_REVERSE\n\tto detect unreachable bbs.\n\t(dom_info::calc_idoms): Likewise.\n\t(compute_dom_fast_query_in_region): New function.\n\t(calculate_dominance_info_for_region): Likewise.\n\t(free_dominance_info_for_region): Likewise.\n\t* dominance.h: Add prototypes for introduced region-based functions\n\ttree-if-conv.c: (build_region): New function.\n\t(if_convertible_loop_p_1): Invoke local version of post-dominators\n\tcalculation before basic block predication with subsequent freeing\n\tpost-dominator info.\n\t(tree_if_conversion): Remove free of post-dominator info\n\t(pass_if_conversion::execute): Delete detection of infinite loops\n\tand fake edges to exit block since post-dominator calculation is\n\tperformed per if-converted loop only.\n\nFrom-SVN: r241275", "tree": {"sha": "b6ddb1ae919d71ade64e2f439d42ae08f57e4d6d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b6ddb1ae919d71ade64e2f439d42ae08f57e4d6d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1d30acf68750f2617c3779176781a26b0b50cfa8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d30acf68750f2617c3779176781a26b0b50cfa8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1d30acf68750f2617c3779176781a26b0b50cfa8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d30acf68750f2617c3779176781a26b0b50cfa8/comments", "author": {"login": "ysrumyan", "id": 44425612, "node_id": "MDQ6VXNlcjQ0NDI1NjEy", "avatar_url": "https://avatars.githubusercontent.com/u/44425612?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ysrumyan", "html_url": "https://github.com/ysrumyan", "followers_url": "https://api.github.com/users/ysrumyan/followers", "following_url": "https://api.github.com/users/ysrumyan/following{/other_user}", "gists_url": "https://api.github.com/users/ysrumyan/gists{/gist_id}", "starred_url": "https://api.github.com/users/ysrumyan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ysrumyan/subscriptions", "organizations_url": "https://api.github.com/users/ysrumyan/orgs", "repos_url": "https://api.github.com/users/ysrumyan/repos", "events_url": "https://api.github.com/users/ysrumyan/events{/privacy}", "received_events_url": "https://api.github.com/users/ysrumyan/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "871267e19da270df32c9ffe8be194228a14ddd87", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/871267e19da270df32c9ffe8be194228a14ddd87", "html_url": "https://github.com/Rust-GCC/gccrs/commit/871267e19da270df32c9ffe8be194228a14ddd87"}], "stats": {"total": 253, "additions": 228, "deletions": 25}, "files": [{"sha": "b512e4b9bbcf481df99a9d2761522edba398229d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d30acf68750f2617c3779176781a26b0b50cfa8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d30acf68750f2617c3779176781a26b0b50cfa8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1d30acf68750f2617c3779176781a26b0b50cfa8", "patch": "@@ -1,3 +1,28 @@\n+2016-10-17  Yuri Rumyantsev  <ysrumyan@gmail.com>\n+\n+\t* dominance.c (dom_info::dom_info): Add new constructor for region\n+\twhich is vector of basic blocks.\n+\t(dom_init): New method to initialize members common for both\n+\tconstructors.\n+\t(dom_info::dom_info): Invoke dom_init for partial initialization.\n+\t(dom_info::get_idom): Add check to corner cases on basic blocks which\n+\tare not in region.\n+\t(dom_info::calc_dfs_tree): Check M_FAKE_EXIT_EDGE instead of M_REVERSE\n+\tto detect unreachable bbs.\n+\t(dom_info::calc_idoms): Likewise.\n+\t(compute_dom_fast_query_in_region): New function.\n+\t(calculate_dominance_info_for_region): Likewise.\n+\t(free_dominance_info_for_region): Likewise.\n+\t* dominance.h: Add prototypes for introduced region-based functions\n+\ttree-if-conv.c: (build_region): New function.\n+\t(if_convertible_loop_p_1): Invoke local version of post-dominators\n+\tcalculation before basic block predication with subsequent freeing\n+\tpost-dominator info.\n+\t(tree_if_conversion): Remove free of post-dominator info\n+\t(pass_if_conversion::execute): Delete detection of infinite loops\n+\tand fake edges to exit block since post-dominator calculation is\n+\tperformed per if-converted loop only.\n+\n 2016-10-17  Bernd Edlinger  <bernd.edlinger@hotmail.de>\n \n \tPR target/77308"}, {"sha": "90bd00dab1555001f3336d78ddfb1ff934c6f5fb", "filename": "gcc/dominance.c", "status": "modified", "additions": 157, "deletions": 13, "changes": 170, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d30acf68750f2617c3779176781a26b0b50cfa8/gcc%2Fdominance.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d30acf68750f2617c3779176781a26b0b50cfa8/gcc%2Fdominance.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdominance.c?ref=1d30acf68750f2617c3779176781a26b0b50cfa8", "patch": "@@ -60,6 +60,7 @@ class dom_info\n {\n public:\n   dom_info (function *, cdi_direction);\n+  dom_info (vec <basic_block>, cdi_direction);\n   ~dom_info ();\n   void calc_dfs_tree ();\n   void calc_idoms ();\n@@ -68,6 +69,7 @@ class dom_info\n private:\n   void calc_dfs_tree_nonrec (basic_block);\n   void compress (TBB);\n+  void dom_init (void);\n   TBB eval (TBB);\n   void link_roots (TBB, TBB);\n \n@@ -153,12 +155,12 @@ inline T *new_zero_array (size_t num)\n   return result;\n }\n \n-/* Allocate all needed memory in a pessimistic fashion (so we round up).  */\n+/* Helper function for constructors to initialize a part of class members.  */\n \n-dom_info::dom_info (function *fn, cdi_direction dir)\n+void\n+dom_info::dom_init (void)\n {\n-  /* We need memory for n_basic_blocks nodes.  */\n-  size_t num = m_n_basic_blocks = n_basic_blocks_for_fn (fn);\n+  size_t num = m_n_basic_blocks;\n   m_dfs_parent = new_zero_array <TBB> (num);\n   m_dom = new_zero_array <TBB> (num);\n \n@@ -177,13 +179,23 @@ dom_info::dom_info (function *fn, cdi_direction dir)\n   m_set_chain = new_zero_array <TBB> (num);\n   m_set_child = new_zero_array <TBB> (num);\n \n-  unsigned last_bb_index = last_basic_block_for_fn (fn);\n-  m_dfs_order = new_zero_array <TBB> (last_bb_index + 1);\n-  m_dfs_last = &m_dfs_order[last_bb_index];\n   m_dfs_to_bb = new_zero_array <basic_block> (num);\n \n   m_dfsnum = 1;\n   m_nodes = 0;\n+}\n+\n+/* Allocate all needed memory in a pessimistic fashion (so we round up).  */\n+\n+dom_info::dom_info (function *fn, cdi_direction dir)\n+{\n+  m_n_basic_blocks = n_basic_blocks_for_fn (fn);\n+\n+  dom_init ();\n+\n+  unsigned last_bb_index = last_basic_block_for_fn (fn);\n+  m_dfs_order = new_zero_array <TBB> (last_bb_index + 1);\n+  m_dfs_last = &m_dfs_order[last_bb_index];\n \n   switch (dir)\n     {\n@@ -204,6 +216,44 @@ dom_info::dom_info (function *fn, cdi_direction dir)\n     }\n }\n \n+/* Constructor for reducible region REGION.  */\n+\n+dom_info::dom_info (vec<basic_block> region, cdi_direction dir)\n+{\n+  m_n_basic_blocks = region.length ();\n+  unsigned int nm1 = m_n_basic_blocks - 1;\n+\n+  dom_init ();\n+\n+  /* Determine max basic block index in region.  */\n+  int max_index = region[0]->index;\n+  for (size_t i = 1; i <= nm1; i++)\n+    if (region[i]->index > max_index)\n+      max_index = region[i]->index;\n+  max_index += 1;  /* set index on the first bb out of region.  */\n+\n+  m_dfs_order = new_zero_array <TBB> (max_index + 1);\n+  m_dfs_last = &m_dfs_order[max_index];\n+\n+  m_fake_exit_edge = NULL; /* Assume that region is reducible.  */\n+\n+  switch (dir)\n+    {\n+      case CDI_DOMINATORS:\n+\tm_reverse = false;\n+\tm_start_block = region[0];\n+\tm_end_block = region[nm1];\n+\tbreak;\n+      case CDI_POST_DOMINATORS:\n+\tm_reverse = true;\n+\tm_start_block = region[nm1];\n+\tm_end_block = region[0];\n+\tbreak;\n+      default:\n+\tgcc_unreachable ();\n+    }\n+}\n+\n inline basic_block\n dom_info::get_idom (basic_block bb)\n {\n@@ -252,6 +302,8 @@ dom_info::calc_dfs_tree_nonrec (basic_block bb)\n {\n   edge_iterator *stack = new edge_iterator[m_n_basic_blocks + 1];\n   int sp = 0;\n+  unsigned d_i = dom_convert_dir_to_idx (m_reverse ? CDI_POST_DOMINATORS\n+\t\t\t\t\t : CDI_DOMINATORS);\n \n   /* Initialize the first edge.  */\n   edge_iterator ei = m_reverse ? ei_start (bb->preds)\n@@ -276,9 +328,10 @@ dom_info::calc_dfs_tree_nonrec (basic_block bb)\n \t      bn = e->src;\n \n \t      /* If the next node BN is either already visited or a border\n-\t         block the current edge is useless, and simply overwritten\n-\t         with the next edge out of the current node.  */\n-\t      if (bn == m_end_block || m_dfs_order[bn->index])\n+\t\t block or out of region the current edge is useless, and simply\n+\t\t overwritten with the next edge out of the current node.  */\n+\t      if (bn == m_end_block || bn->dom[d_i] == NULL\n+\t\t  || m_dfs_order[bn->index])\n \t\t{\n \t\t  ei_next (&ei);\n \t\t  continue;\n@@ -289,7 +342,8 @@ dom_info::calc_dfs_tree_nonrec (basic_block bb)\n \t  else\n \t    {\n \t      bn = e->dest;\n-\t      if (bn == m_end_block || m_dfs_order[bn->index])\n+\t      if (bn == m_end_block || bn->dom[d_i] == NULL\n+\t\t  || m_dfs_order[bn->index])\n \t\t{\n \t\t  ei_next (&ei);\n \t\t  continue;\n@@ -347,7 +401,7 @@ dom_info::calc_dfs_tree ()\n \n   calc_dfs_tree_nonrec (m_start_block);\n \n-  if (m_reverse)\n+  if (m_fake_exit_edge)\n     {\n       /* In the post-dom case we may have nodes without a path to EXIT_BLOCK.\n          They are reverse-unreachable.  In the dom-case we disallow such\n@@ -511,7 +565,7 @@ dom_info::calc_idoms ()\n \t\t\t\t   : ei_start (bb->preds);\n       edge_iterator einext;\n \n-      if (m_reverse)\n+      if (m_fake_exit_edge)\n \t{\n \t  /* If this block has a fake edge to exit, process that first.  */\n \t  if (bitmap_bit_p (m_fake_exit_edge, bb->index))\n@@ -622,6 +676,33 @@ compute_dom_fast_query (enum cdi_direction dir)\n   dom_computed[dir_index] = DOM_OK;\n }\n \n+/* Analogous to the previous function but compute the data for reducible\n+   region REGION.  */\n+\n+static void\n+compute_dom_fast_query_in_region (enum cdi_direction dir,\n+\t\t\t\t  vec<basic_block> region)\n+{\n+  int num = 0;\n+  basic_block bb;\n+  unsigned int dir_index = dom_convert_dir_to_idx (dir);\n+\n+  gcc_checking_assert (dom_info_available_p (dir));\n+\n+  if (dom_computed[dir_index] == DOM_OK)\n+    return;\n+\n+  /* Assign dfs numbers for region nodes except for entry and exit nodes.  */\n+  for (unsigned int i = 1; i < region.length () - 1; i++)\n+    {\n+      bb = region[i];\n+      if (!bb->dom[dir_index]->father)\n+\tassign_dfs_numbers (bb->dom[dir_index], &num);\n+    }\n+\n+  dom_computed[dir_index] = DOM_OK;\n+}\n+\n /* The main entry point into this module.  DIR is set depending on whether\n    we want to compute dominators or postdominators.  */\n \n@@ -668,6 +749,43 @@ calculate_dominance_info (cdi_direction dir)\n   timevar_pop (TV_DOMINANCE);\n }\n \n+/* Analogous to the previous function but compute dominance info for regions\n+   which are single entry, multiple exit regions for CDI_DOMINATORs and\n+   multiple entry, single exit regions for CDI_POST_DOMINATORs.  */\n+\n+void\n+calculate_dominance_info_for_region (cdi_direction dir,\n+\t\t\t\t     vec<basic_block> region)\n+{\n+  unsigned int dir_index = dom_convert_dir_to_idx (dir);\n+  basic_block bb;\n+  unsigned int i;\n+\n+  if (dom_computed[dir_index] == DOM_OK)\n+    return;\n+\n+  timevar_push (TV_DOMINANCE);\n+  /* Assume that dom info is not partially computed.  */\n+  gcc_assert (!dom_info_available_p (dir));\n+\n+  FOR_EACH_VEC_ELT (region, i, bb)\n+    {\n+      bb->dom[dir_index] = et_new_tree (bb);\n+    }\n+  dom_info di (region, dir);\n+  di.calc_dfs_tree ();\n+  di.calc_idoms ();\n+\n+  FOR_EACH_VEC_ELT (region, i, bb)\n+    if (basic_block d = di.get_idom (bb))\n+      et_set_father (bb->dom[dir_index], d->dom[dir_index]);\n+\n+  dom_computed[dir_index] = DOM_NO_FAST_QUERY;\n+  compute_dom_fast_query_in_region (dir, region);\n+\n+  timevar_pop (TV_DOMINANCE);\n+}\n+\n /* Free dominance information for direction DIR.  */\n void\n free_dominance_info (function *fn, enum cdi_direction dir)\n@@ -696,6 +814,32 @@ free_dominance_info (enum cdi_direction dir)\n   free_dominance_info (cfun, dir);\n }\n \n+/* Free dominance information for direction DIR in region REGION.  */\n+\n+void\n+free_dominance_info_for_region (function *fn,\n+\t\t\t\tenum cdi_direction dir,\n+\t\t\t\tvec<basic_block> region)\n+{\n+  basic_block bb;\n+  unsigned int i;\n+  unsigned int dir_index = dom_convert_dir_to_idx (dir);\n+\n+  if (!dom_info_available_p (dir))\n+    return;\n+\n+  FOR_EACH_VEC_ELT (region, i, bb)\n+    {\n+      et_free_tree_force (bb->dom[dir_index]);\n+      bb->dom[dir_index] = NULL;\n+    }\n+  et_free_pools ();\n+\n+  fn->cfg->x_dom_computed[dir_index] = DOM_NONE;\n+\n+  fn->cfg->x_n_bbs_in_dom_tree[dir_index] = 0;\n+}\n+\n /* Return the immediate dominator of basic block BB.  */\n basic_block\n get_immediate_dominator (enum cdi_direction dir, basic_block bb)"}, {"sha": "ddbfa003662044ebbdb7a68f0ddf6a18ef051fda", "filename": "gcc/dominance.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d30acf68750f2617c3779176781a26b0b50cfa8/gcc%2Fdominance.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d30acf68750f2617c3779176781a26b0b50cfa8/gcc%2Fdominance.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdominance.h?ref=1d30acf68750f2617c3779176781a26b0b50cfa8", "patch": "@@ -36,8 +36,13 @@ enum dom_state\n };\n \n extern void calculate_dominance_info (enum cdi_direction);\n+extern void calculate_dominance_info_for_region (enum cdi_direction,\n+\t\t\t\t\t\t vec<basic_block>);\n extern void free_dominance_info (function *, enum cdi_direction);\n extern void free_dominance_info (enum cdi_direction);\n+extern void free_dominance_info_for_region (function *,\n+\t\t\t\t\t    enum cdi_direction,\n+\t\t\t\t\t    vec<basic_block>);\n extern basic_block get_immediate_dominator (enum cdi_direction, basic_block);\n extern void set_immediate_dominator (enum cdi_direction, basic_block,\n \t\t\t\t     basic_block);"}, {"sha": "0a201898177a812e12ed04b9498e11f340b1c8b4", "filename": "gcc/tree-if-conv.c", "status": "modified", "additions": 41, "deletions": 12, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d30acf68750f2617c3779176781a26b0b50cfa8/gcc%2Ftree-if-conv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d30acf68750f2617c3779176781a26b0b50cfa8/gcc%2Ftree-if-conv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-if-conv.c?ref=1d30acf68750f2617c3779176781a26b0b50cfa8", "patch": "@@ -1309,6 +1309,38 @@ predicate_bbs (loop_p loop)\n \t      && bb_predicate_gimplified_stmts (loop->latch) == NULL);\n }\n \n+/* Build region by adding loop pre-header and post-header blocks.  */\n+\n+static vec<basic_block>\n+build_region (struct loop *loop)\n+{\n+  vec<basic_block> region = vNULL;\n+  basic_block exit_bb = NULL;\n+\n+  gcc_assert (ifc_bbs);\n+  /* The first element is loop pre-header.  */\n+  region.safe_push (loop_preheader_edge (loop)->src);\n+\n+  for (unsigned int i = 0; i < loop->num_nodes; i++)\n+    {\n+      basic_block bb = ifc_bbs[i];\n+      region.safe_push (bb);\n+      /* Find loop postheader.  */\n+      edge e;\n+      edge_iterator ei;\n+      FOR_EACH_EDGE (e, ei, bb->succs)\n+\tif (loop_exit_edge_p (loop, e))\n+\t  {\n+\t      exit_bb = e->dest;\n+\t      break;\n+\t  }\n+    }\n+  /* The last element is loop post-header.  */\n+  gcc_assert (exit_bb);\n+  region.safe_push (exit_bb);\n+  return region;\n+}\n+\n /* Return true when LOOP is if-convertible.  This is a helper function\n    for if_convertible_loop_p.  REFS and DDRS are initialized and freed\n    in if_convertible_loop_p.  */\n@@ -1318,6 +1350,7 @@ if_convertible_loop_p_1 (struct loop *loop, vec<data_reference_p> *refs)\n {\n   unsigned int i;\n   basic_block exit_bb = NULL;\n+  vec<basic_block> region;\n \n   if (find_data_references_in_loop (loop, refs) == chrec_dont_know)\n     return false;\n@@ -1370,9 +1403,16 @@ if_convertible_loop_p_1 (struct loop *loop, vec<data_reference_p> *refs)\n \t  = new hash_map<innermost_loop_behavior_hash, data_reference_p>;\n   baseref_DR_map = new hash_map<tree_operand_hash, data_reference_p>;\n \n-  calculate_dominance_info (CDI_POST_DOMINATORS);\n+  /* Compute post-dominator tree locally.  */\n+  region = build_region (loop);\n+  calculate_dominance_info_for_region (CDI_POST_DOMINATORS, region);\n+\n   predicate_bbs (loop);\n \n+  /* Free post-dominator tree since it is not used after predication.  */\n+  free_dominance_info_for_region (cfun, CDI_POST_DOMINATORS, region);\n+  region.release ();\n+\n   for (i = 0; refs->iterate (i, &dr); i++)\n     {\n       tree ref = DR_REF (dr);\n@@ -2752,7 +2792,6 @@ tree_if_conversion (struct loop *loop)\n       free (ifc_bbs);\n       ifc_bbs = NULL;\n     }\n-  free_dominance_info (CDI_POST_DOMINATORS);\n \n   return todo;\n }\n@@ -2805,23 +2844,13 @@ pass_if_conversion::execute (function *fun)\n   if (number_of_loops (fun) <= 1)\n     return 0;\n \n-  /* If there are infinite loops, during CDI_POST_DOMINATORS computation\n-     we can pick pretty much random bb inside of the infinite loop that\n-     has the fake edge.  If we are unlucky enough, this can confuse the\n-     add_to_predicate_list post-dominator check to optimize as if that\n-     bb or some other one is a join block when it actually is not.\n-     See PR70916.  */\n-  connect_infinite_loops_to_exit ();\n-\n   FOR_EACH_LOOP (loop, 0)\n     if (flag_tree_loop_if_convert == 1\n \t|| flag_tree_loop_if_convert_stores == 1\n \t|| ((flag_tree_loop_vectorize || loop->force_vectorize)\n \t    && !loop->dont_vectorize))\n       todo |= tree_if_conversion (loop);\n \n-  remove_fake_exit_edges ();\n-\n   if (flag_checking)\n     {\n       basic_block bb;"}]}