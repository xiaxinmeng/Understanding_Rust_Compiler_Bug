{"sha": "7ca7362602d4e827ecbc39d5cfdf56df9044633b", "node_id": "C_kwDOANBUbNoAKDdjYTczNjI2MDJkNGU4MjdlY2JjMzlkNWNmZGY1NmRmOTA0NDYzM2I", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-06-03T14:12:00Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2022-06-10T16:09:34Z"}, "message": "This patch implements complex Path resolution\n\nThis patch completely reimplements our name resolution process for Paths in\ngeneral. This patch gets rid of the old Resolver::Definition structures\nwhich were used so that we can map patterns back to LetStmts and establish\nan hierarchy of nodes. This was not nessecary and complicated name/type\nresolution.\n\nTypePaths and PathInExpression are similar but have a slightl tweak in the\norder they lookup the relevant scopes for types. But overall work the same.\nThere are several cases of paths you must consider in type resolution:\n\n- i32 (simple type path)\n- Self::A (associated type reference)\n- mod::foo::impl_item() (reference to impl item)\n- super::foo (reference to impl item)\n- crate::foo\n- T::bound()\n\nIn name resolution we cannot always fully resolve a path but have to rely\non the type-resolution to fully resolve a path as it may require careful\nthought. For example a path like:\n\n  mod::foo::item()\n\nmight be for a generic foo<T>(), which might have two specialized impl\nblocks so the best the name resolution can do is resolve mod::foo then\nleave it up to the type resolution to figure out which item this is. We\nmight have i32 which is just a simple lookup.\n\nApart from that this patch introduces a module parent child hierachy so\nthat on paths such as super::foo we resolve super to be our parent module\nscope then foo can be resolved with the lookup in the items for that\nmodule.\n\nMore over this patch gets rid of some but not all of the awkward name\ncanonicalization to try and patch paths directly. More cleanup is still\nneeded here to make the name resolution step easier to read. This was\nnotable in the Qualified path handling where we can now rely on the type\nresolver to setup the associated types properly rather than the name\nresolver requiring us to resolve this directly.\n\nFixes #1251 #1230\nAddresses #1227 #1153", "tree": {"sha": "7e149ddc7c9ffb0f72bcd4be2459abc7d1ee688a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7e149ddc7c9ffb0f72bcd4be2459abc7d1ee688a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7ca7362602d4e827ecbc39d5cfdf56df9044633b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ca7362602d4e827ecbc39d5cfdf56df9044633b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7ca7362602d4e827ecbc39d5cfdf56df9044633b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ca7362602d4e827ecbc39d5cfdf56df9044633b/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fc3ef6c4b1fad0d88a65043df8102437416b1df3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc3ef6c4b1fad0d88a65043df8102437416b1df3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fc3ef6c4b1fad0d88a65043df8102437416b1df3"}], "stats": {"total": 1707, "additions": 895, "deletions": 812}, "files": [{"sha": "8f5657f0960404ebfdb6d59fb514e94de4ccbe4c", "filename": "gcc/rust/ast/rust-ast.h", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ca7362602d4e827ecbc39d5cfdf56df9044633b/gcc%2Frust%2Fast%2Frust-ast.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ca7362602d4e827ecbc39d5cfdf56df9044633b/gcc%2Frust%2Fast%2Frust-ast.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast.h?ref=7ca7362602d4e827ecbc39d5cfdf56df9044633b", "patch": "@@ -350,8 +350,16 @@ class SimplePathSegment : public PathSegment\n   Location get_locus () const { return locus; }\n   NodeId get_node_id () const { return node_id; }\n   const std::string &get_segment_name () const { return segment_name; }\n-\n-  // TODO: visitor pattern?\n+  bool is_super_path_seg () const\n+  {\n+    return as_string ().compare (\"super\") == 0;\n+  }\n+  bool is_crate_path_seg () const\n+  {\n+    return as_string ().compare (\"crate\") == 0;\n+  }\n+  bool is_lower_self () const { return as_string ().compare (\"self\") == 0; }\n+  bool is_big_self () const { return as_string ().compare (\"Self\") == 0; }\n };\n \n // A simple path without generic or type arguments"}, {"sha": "45d08bfbaa9c0bb911caabd897bed75f10b9c6d2", "filename": "gcc/rust/ast/rust-path.h", "status": "modified", "additions": 47, "deletions": 7, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ca7362602d4e827ecbc39d5cfdf56df9044633b/gcc%2Frust%2Fast%2Frust-path.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ca7362602d4e827ecbc39d5cfdf56df9044633b/gcc%2Frust%2Fast%2Frust-path.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-path.h?ref=7ca7362602d4e827ecbc39d5cfdf56df9044633b", "patch": "@@ -38,12 +38,6 @@ class PathIdentSegment\n     : segment_name (std::move (segment_name)), locus (locus)\n   {}\n \n-  /* TODO: insert check in constructor for this? Or is this a semantic error\n-   * best handled then? */\n-\n-  /* TODO: does this require visitor? pretty sure this isn't polymorphic, but\n-   * not entirely sure */\n-\n   // Creates an error PathIdentSegment.\n   static PathIdentSegment create_error ()\n   {\n@@ -54,6 +48,11 @@ class PathIdentSegment\n   bool is_error () const { return segment_name.empty (); }\n \n   std::string as_string () const { return segment_name; }\n+\n+  bool is_super_segment () const { return as_string ().compare (\"super\") == 0; }\n+  bool is_crate_segment () const { return as_string ().compare (\"crate\") == 0; }\n+  bool is_lower_self () const { return as_string ().compare (\"self\") == 0; }\n+  bool is_big_self () const { return as_string ().compare (\"Self\") == 0; }\n };\n \n // A binding of an identifier to a type used in generic arguments in paths\n@@ -264,8 +263,23 @@ class PathExprSegment\n   }\n \n   PathIdentSegment &get_ident_segment () { return segment_name; }\n+  const PathIdentSegment &get_ident_segment () const { return segment_name; }\n \n   NodeId get_node_id () const { return node_id; }\n+\n+  bool is_super_path_seg () const\n+  {\n+    return !has_generic_args () && get_ident_segment ().is_super_segment ();\n+  }\n+\n+  bool is_crate_path_seg () const\n+  {\n+    return !has_generic_args () && get_ident_segment ().is_crate_segment ();\n+  }\n+  bool is_lower_self_seg () const\n+  {\n+    return !has_generic_args () && get_ident_segment ().is_lower_self ();\n+  }\n };\n \n // AST node representing a pattern that involves a \"path\" - abstract base class\n@@ -397,6 +411,15 @@ class PathInExpression : public PathPattern, public PathExpr\n  * ident-only segment) */\n class TypePathSegment\n {\n+public:\n+  enum SegmentType\n+  {\n+    REG,\n+    GENERIC,\n+    FUNCTION\n+  };\n+\n+private:\n   PathIdentSegment ident_segment;\n   Location locus;\n \n@@ -415,6 +438,8 @@ class TypePathSegment\n public:\n   virtual ~TypePathSegment () {}\n \n+  virtual SegmentType get_type () const { return SegmentType::REG; }\n+\n   // Unique pointer custom clone function\n   std::unique_ptr<TypePathSegment> clone_type_path_segment () const\n   {\n@@ -456,9 +481,20 @@ class TypePathSegment\n     return has_separating_scope_resolution;\n   }\n \n-  PathIdentSegment get_ident_segment () { return ident_segment; };\n+  PathIdentSegment &get_ident_segment () { return ident_segment; };\n+  const PathIdentSegment &get_ident_segment () const { return ident_segment; };\n \n   NodeId get_node_id () const { return node_id; }\n+\n+  bool is_crate_path_seg () const\n+  {\n+    return get_ident_segment ().is_crate_segment ();\n+  }\n+  bool is_super_path_seg () const\n+  {\n+    return get_ident_segment ().is_super_segment ();\n+  }\n+  bool is_big_self_seg () const { return get_ident_segment ().is_big_self (); }\n };\n \n // Segment used in type path with generic args\n@@ -467,6 +503,8 @@ class TypePathSegmentGeneric : public TypePathSegment\n   GenericArgs generic_args;\n \n public:\n+  SegmentType get_type () const override { return SegmentType::GENERIC; }\n+\n   bool has_generic_args () const { return generic_args.has_generic_args (); }\n \n   bool is_ident_only () const override { return false; }\n@@ -620,6 +658,8 @@ class TypePathSegmentFunction : public TypePathSegment\n   TypePathFunction function_path;\n \n public:\n+  SegmentType get_type () const override { return SegmentType::FUNCTION; }\n+\n   // Constructor with PathIdentSegment and TypePathFn\n   TypePathSegmentFunction (PathIdentSegment ident_segment,\n \t\t\t   bool has_separating_scope_resolution,"}, {"sha": "8fa3fa1879354be1251e9cc0ad70c44bf246e987", "filename": "gcc/rust/backend/rust-compile-base.cc", "status": "modified", "additions": 26, "deletions": 30, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ca7362602d4e827ecbc39d5cfdf56df9044633b/gcc%2Frust%2Fbackend%2Frust-compile-base.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ca7362602d4e827ecbc39d5cfdf56df9044633b/gcc%2Frust%2Fbackend%2Frust-compile-base.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-base.cc?ref=7ca7362602d4e827ecbc39d5cfdf56df9044633b", "patch": "@@ -333,39 +333,33 @@ std::vector<Bvariable *>\n HIRCompileBase::compile_locals_for_block (Context *ctx, Resolver::Rib &rib,\n \t\t\t\t\t  tree fndecl)\n {\n+  CrateNum crate = ctx->get_mappings ()->get_current_crate ();\n+\n   std::vector<Bvariable *> locals;\n   for (auto it : rib.get_declarations ())\n     {\n-      auto node_id = it.first;\n-\n-      Resolver::Definition d;\n-      bool ok = ctx->get_resolver ()->lookup_definition (node_id, &d);\n-      rust_assert (ok);\n-\n-      HIR::Stmt *decl = nullptr;\n-      if (!ctx->get_mappings ()->resolve_nodeid_to_stmt (d.parent, &decl))\n-\t{\n-\t  // might be an extern block see fix for\n-\t  // https://github.com/Rust-GCC/gccrs/issues/976\n-\t  continue;\n-\t}\n-\n-      // if its a function we extract this out side of this fn context\n-      // and it is not a local to this function\n-      bool is_item = ctx->get_mappings ()->lookup_hir_item (\n-\t\t       decl->get_mappings ().get_crate_num (),\n-\t\t       decl->get_mappings ().get_hirid ())\n-\t\t     != nullptr;\n-      if (is_item)\n-\t{\n-\t  HIR::Item *item = static_cast<HIR::Item *> (decl);\n-\t  CompileItem::compile (item, ctx);\n-\t}\n-\n-      Bvariable *compiled = CompileVarDecl::compile (fndecl, decl, ctx);\n+      NodeId node_id = it.first;\n+      HirId ref = UNKNOWN_HIRID;\n+      if (!ctx->get_mappings ()->lookup_node_to_hir (crate, node_id, &ref))\n+\tcontinue;\n+\n+      // we only care about local patterns\n+      HIR::Pattern *pattern\n+\t= ctx->get_mappings ()->lookup_hir_pattern (crate, ref);\n+      if (pattern == nullptr)\n+\tcontinue;\n+\n+      // lookup the type\n+      TyTy::BaseType *tyty = nullptr;\n+      if (!ctx->get_tyctx ()->lookup_type (ref, &tyty))\n+\tcontinue;\n+\n+      // compile the local\n+      tree type = TyTyResolveCompile::compile (ctx, tyty);\n+      Bvariable *compiled\n+\t= CompileVarDecl::compile (fndecl, type, pattern, ctx);\n       locals.push_back (compiled);\n-    };\n-\n+    }\n   return locals;\n }\n \n@@ -482,7 +476,9 @@ HIRCompileBase::compile_function (\n \t\t\t\t   compiled_param_type, param_locus);\n \n       param_vars.push_back (compiled_param_var);\n-      ctx->insert_var_decl (referenced_param.get_mappings ().get_hirid (),\n+\n+      const HIR::Pattern &param_pattern = *referenced_param.get_param_name ();\n+      ctx->insert_var_decl (param_pattern.get_pattern_mappings ().get_hirid (),\n \t\t\t    compiled_param_var);\n     }\n "}, {"sha": "b153451b470f334c0c07b6a983209d0a4b508a29", "filename": "gcc/rust/backend/rust-compile-expr.cc", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ca7362602d4e827ecbc39d5cfdf56df9044633b/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ca7362602d4e827ecbc39d5cfdf56df9044633b/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc?ref=7ca7362602d4e827ecbc39d5cfdf56df9044633b", "patch": "@@ -1432,16 +1432,6 @@ CompileExpr::visit (HIR::IdentifierExpr &expr)\n   NodeId ref_node_id = UNKNOWN_NODEID;\n   if (ctx->get_resolver ()->lookup_resolved_name (ast_node_id, &ref_node_id))\n     {\n-      // these ref_node_ids will resolve to a pattern declaration but we are\n-      // interested in the definition that this refers to get the parent id\n-      Resolver::Definition def;\n-      if (!ctx->get_resolver ()->lookup_definition (ref_node_id, &def))\n-\t{\n-\t  rust_error_at (expr.get_locus (),\n-\t\t\t \"unknown reference for resolved name\");\n-\t  return;\n-\t}\n-      ref_node_id = def.parent;\n       is_value = true;\n     }\n   else if (!ctx->get_resolver ()->lookup_resolved_type (ast_node_id,"}, {"sha": "3b729c78b3797e98a31edd5085abfd2eaae7b5cb", "filename": "gcc/rust/backend/rust-compile-expr.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ca7362602d4e827ecbc39d5cfdf56df9044633b/gcc%2Frust%2Fbackend%2Frust-compile-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ca7362602d4e827ecbc39d5cfdf56df9044633b/gcc%2Frust%2Fbackend%2Frust-compile-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-expr.h?ref=7ca7362602d4e827ecbc39d5cfdf56df9044633b", "patch": "@@ -512,8 +512,8 @@ class CompileExpr : public HIRCompileBase, public HIR::HIRExpressionVisitor\n \n   void visit (HIR::FieldAccessExpr &expr) override\n   {\n-    tree receiver_ref\n-      = CompileExpr::Compile (expr.get_receiver_expr ().get (), ctx);\n+    HIR::Expr *receiver_expr = expr.get_receiver_expr ().get ();\n+    tree receiver_ref = CompileExpr::Compile (receiver_expr, ctx);\n \n     // resolve the receiver back to ADT type\n     TyTy::BaseType *receiver = nullptr;"}, {"sha": "2cf81e0f9d7a20e4051eacdc54b758547085aa3d", "filename": "gcc/rust/backend/rust-compile-resolve-path.cc", "status": "modified", "additions": 4, "deletions": 14, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ca7362602d4e827ecbc39d5cfdf56df9044633b/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ca7362602d4e827ecbc39d5cfdf56df9044633b/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc?ref=7ca7362602d4e827ecbc39d5cfdf56df9044633b", "patch": "@@ -53,22 +53,12 @@ ResolvePathRef::resolve (const HIR::PathIdentSegment &final_segment,\n \n   // need to look up the reference for this identifier\n   NodeId ref_node_id = UNKNOWN_NODEID;\n-  if (ctx->get_resolver ()->lookup_resolved_name (mappings.get_nodeid (),\n-\t\t\t\t\t\t  &ref_node_id))\n+  if (!ctx->get_resolver ()->lookup_resolved_name (mappings.get_nodeid (),\n+\t\t\t\t\t\t   &ref_node_id))\n     {\n-      Resolver::Definition def;\n-      if (!ctx->get_resolver ()->lookup_definition (ref_node_id, &def))\n-\t{\n-\t  rust_error_at (expr_locus, \"unknown reference for resolved name\");\n-\t  return error_mark_node;\n-\t}\n-      ref_node_id = def.parent;\n-    }\n+      // this can fail because it might be a Constructor for something\n+      // in that case the caller should attempt ResolvePathType::Compile\n \n-  // this can fail because it might be a Constructor for something\n-  // in that case the caller should attempt ResolvePathType::Compile\n-  if (ref_node_id == UNKNOWN_NODEID)\n-    {\n       // it might be an enum data-less enum variant\n       if (lookup->get_kind () != TyTy::TypeKind::ADT)\n \treturn error_mark_node;"}, {"sha": "aa17a4a4941006a5b34323e910b643e4d9c3826d", "filename": "gcc/rust/backend/rust-compile-stmt.h", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ca7362602d4e827ecbc39d5cfdf56df9044633b/gcc%2Frust%2Fbackend%2Frust-compile-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ca7362602d4e827ecbc39d5cfdf56df9044633b/gcc%2Frust%2Fbackend%2Frust-compile-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-stmt.h?ref=7ca7362602d4e827ecbc39d5cfdf56df9044633b", "patch": "@@ -51,9 +51,11 @@ class CompileStmt : public HIRCompileBase, public HIR::HIRStmtVisitor\n     if (!stmt.has_init_expr ())\n       return;\n \n+    const HIR::Pattern &stmt_pattern = *stmt.get_pattern ();\n+    HirId stmt_id = stmt_pattern.get_pattern_mappings ().get_hirid ();\n+\n     TyTy::BaseType *ty = nullptr;\n-    if (!ctx->get_tyctx ()->lookup_type (stmt.get_mappings ().get_hirid (),\n-\t\t\t\t\t &ty))\n+    if (!ctx->get_tyctx ()->lookup_type (stmt_id, &ty))\n       {\n \t// FIXME this should be an assertion instead\n \trust_fatal_error (stmt.get_locus (),\n@@ -62,7 +64,7 @@ class CompileStmt : public HIRCompileBase, public HIR::HIRStmtVisitor\n       }\n \n     Bvariable *var = nullptr;\n-    if (!ctx->lookup_var_decl (stmt.get_mappings ().get_hirid (), &var))\n+    if (!ctx->lookup_var_decl (stmt_id, &var))\n       {\n \t// FIXME this should be an assertion instead and use error mark node\n \trust_fatal_error (stmt.get_locus (),"}, {"sha": "e2ee05b81631844f39c83af61ba349428e6885c7", "filename": "gcc/rust/backend/rust-compile-var-decl.h", "status": "modified", "additions": 17, "deletions": 53, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ca7362602d4e827ecbc39d5cfdf56df9044633b/gcc%2Frust%2Fbackend%2Frust-compile-var-decl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ca7362602d4e827ecbc39d5cfdf56df9044633b/gcc%2Frust%2Fbackend%2Frust-compile-var-decl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-var-decl.h?ref=7ca7362602d4e827ecbc39d5cfdf56df9044633b", "patch": "@@ -25,36 +25,19 @@\n namespace Rust {\n namespace Compile {\n \n-class CompileVarDecl : public HIRCompileBase,\n-\t\t       public HIR::HIRPatternVisitor,\n-\t\t       public HIR::HIRStmtVisitor\n+class CompileVarDecl : public HIRCompileBase, public HIR::HIRPatternVisitor\n {\n   using HIR::HIRPatternVisitor::visit;\n-  using HIR::HIRStmtVisitor::visit;\n \n public:\n-  static ::Bvariable *compile (tree fndecl, HIR::Stmt *stmt, Context *ctx)\n+  static ::Bvariable *compile (tree fndecl, tree translated_type,\n+\t\t\t       HIR::Pattern *pattern, Context *ctx)\n   {\n-    CompileVarDecl compiler (ctx, fndecl);\n-    stmt->accept_vis (compiler);\n-    ctx->insert_var_decl (stmt->get_mappings ().get_hirid (),\n-\t\t\t  compiler.compiled_variable);\n+    CompileVarDecl compiler (ctx, fndecl, translated_type);\n+    pattern->accept_vis (compiler);\n     return compiler.compiled_variable;\n   }\n \n-  void visit (HIR::LetStmt &stmt) override\n-  {\n-    locus = stmt.get_locus ();\n-    TyTy::BaseType *resolved_type = nullptr;\n-    bool ok = ctx->get_tyctx ()->lookup_type (stmt.get_mappings ().get_hirid (),\n-\t\t\t\t\t      &resolved_type);\n-    rust_assert (ok);\n-\n-    translated_type = TyTyResolveCompile::compile (ctx, resolved_type);\n-    stmt.get_pattern ()->accept_vis (\n-      static_cast<HIR::HIRPatternVisitor &> (*this));\n-  }\n-\n   void visit (HIR::IdentifierPattern &pattern) override\n   {\n     if (!pattern.is_mut ())\n@@ -63,7 +46,10 @@ class CompileVarDecl : public HIRCompileBase,\n     compiled_variable\n       = ctx->get_backend ()->local_variable (fndecl, pattern.get_identifier (),\n \t\t\t\t\t     translated_type, NULL /*decl_var*/,\n-\t\t\t\t\t     locus);\n+\t\t\t\t\t     pattern.get_locus ());\n+\n+    HirId stmt_id = pattern.get_pattern_mappings ().get_hirid ();\n+    ctx->insert_var_decl (stmt_id, compiled_variable);\n   }\n \n   void visit (HIR::WildcardPattern &pattern) override\n@@ -72,7 +58,11 @@ class CompileVarDecl : public HIRCompileBase,\n \n     compiled_variable\n       = ctx->get_backend ()->local_variable (fndecl, \"_\", translated_type,\n-\t\t\t\t\t     NULL /*decl_var*/, locus);\n+\t\t\t\t\t     NULL /*decl_var*/,\n+\t\t\t\t\t     pattern.get_locus ());\n+\n+    HirId stmt_id = pattern.get_pattern_mappings ().get_hirid ();\n+    ctx->insert_var_decl (stmt_id, compiled_variable);\n   }\n \n   // Empty visit for unused Pattern HIR nodes.\n@@ -87,41 +77,15 @@ class CompileVarDecl : public HIRCompileBase,\n   void visit (HIR::TuplePattern &) override {}\n   void visit (HIR::TupleStructPattern &) override {}\n \n-  // Empty visit for unused Stmt HIR nodes.\n-  void visit (HIR::EnumItemTuple &) override {}\n-  void visit (HIR::EnumItemStruct &) override {}\n-  void visit (HIR::EnumItem &item) override {}\n-  void visit (HIR::TupleStruct &tuple_struct) override {}\n-  void visit (HIR::EnumItemDiscriminant &) override {}\n-  void visit (HIR::TypePathSegmentFunction &segment) override {}\n-  void visit (HIR::TypePath &path) override {}\n-  void visit (HIR::QualifiedPathInType &path) override {}\n-  void visit (HIR::Module &module) override {}\n-  void visit (HIR::ExternCrate &crate) override {}\n-  void visit (HIR::UseDeclaration &use_decl) override {}\n-  void visit (HIR::Function &function) override {}\n-  void visit (HIR::TypeAlias &type_alias) override {}\n-  void visit (HIR::StructStruct &struct_item) override {}\n-  void visit (HIR::Enum &enum_item) override {}\n-  void visit (HIR::Union &union_item) override {}\n-  void visit (HIR::ConstantItem &const_item) override {}\n-  void visit (HIR::StaticItem &static_item) override {}\n-  void visit (HIR::Trait &trait) override {}\n-  void visit (HIR::ImplBlock &impl) override {}\n-  void visit (HIR::ExternBlock &block) override {}\n-  void visit (HIR::EmptyStmt &stmt) override {}\n-  void visit (HIR::ExprStmtWithoutBlock &stmt) override {}\n-  void visit (HIR::ExprStmtWithBlock &stmt) override {}\n-\n private:\n-  CompileVarDecl (Context *ctx, tree fndecl)\n-    : HIRCompileBase (ctx), fndecl (fndecl), translated_type (error_mark_node),\n+  CompileVarDecl (Context *ctx, tree fndecl, tree translated_type)\n+    : HIRCompileBase (ctx), fndecl (fndecl), translated_type (translated_type),\n       compiled_variable (ctx->get_backend ()->error_variable ())\n   {}\n \n   tree fndecl;\n   tree translated_type;\n-  Location locus;\n+\n   Bvariable *compiled_variable;\n };\n "}, {"sha": "0072d30d8585725490bcffe4f5fc0db5def85ccd", "filename": "gcc/rust/hir/rust-ast-lower.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ca7362602d4e827ecbc39d5cfdf56df9044633b/gcc%2Frust%2Fhir%2Frust-ast-lower.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ca7362602d4e827ecbc39d5cfdf56df9044633b/gcc%2Frust%2Fhir%2Frust-ast-lower.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower.cc?ref=7ca7362602d4e827ecbc39d5cfdf56df9044633b", "patch": "@@ -79,7 +79,7 @@ ASTLowering::go ()\n \n   auto mappings = Analysis::Mappings::get ();\n   auto crate_num = mappings->get_current_crate ();\n-  Analysis::NodeMapping mapping (crate_num, UNKNOWN_NODEID,\n+  Analysis::NodeMapping mapping (crate_num, astCrate.get_node_id (),\n \t\t\t\t mappings->get_next_hir_id (crate_num),\n \t\t\t\t UNKNOWN_LOCAL_DEFID);\n "}, {"sha": "2b01abcc06cc1824063245766fc35c9fec912b83", "filename": "gcc/rust/lint/rust-lint-marklive.cc", "status": "modified", "additions": 4, "deletions": 19, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ca7362602d4e827ecbc39d5cfdf56df9044633b/gcc%2Frust%2Flint%2Frust-lint-marklive.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ca7362602d4e827ecbc39d5cfdf56df9044633b/gcc%2Frust%2Flint%2Frust-lint-marklive.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Flint%2Frust-lint-marklive.cc?ref=7ca7362602d4e827ecbc39d5cfdf56df9044633b", "patch": "@@ -179,16 +179,10 @@ MarkLive::visit_path_segment (HIR::PathExprSegment seg)\n   //\n   // We should mark them alive all and ignoring other kind of segments.\n   // If the segment we dont care then just return false is fine\n-  if (resolver->lookup_resolved_name (ast_node_id, &ref_node_id))\n+  if (!resolver->lookup_resolved_name (ast_node_id, &ref_node_id))\n     {\n-      Resolver::Definition def;\n-      bool ok = resolver->lookup_definition (ref_node_id, &def);\n-      rust_assert (ok);\n-      ref_node_id = def.parent;\n-    }\n-  else if (!resolver->lookup_resolved_type (ast_node_id, &ref_node_id))\n-    {\n-      return false;\n+      if (!resolver->lookup_resolved_type (ast_node_id, &ref_node_id))\n+\treturn false;\n     }\n   HirId ref;\n   bool ok = mappings->lookup_node_to_hir (seg.get_mappings ().get_crate_num (),\n@@ -300,16 +294,7 @@ MarkLive::mark_hir_id (HirId id)\n void\n MarkLive::find_ref_node_id (NodeId ast_node_id, NodeId &ref_node_id)\n {\n-  if (resolver->lookup_resolved_name (ast_node_id, &ref_node_id))\n-    {\n-      // these ref_node_ids will resolve to a pattern declaration but we are\n-      // interested in the definition that this refers to get the parent id\n-      Resolver::Definition def;\n-      bool ok = resolver->lookup_definition (ref_node_id, &def);\n-      rust_assert (ok);\n-      ref_node_id = def.parent;\n-    }\n-  else\n+  if (!resolver->lookup_resolved_name (ast_node_id, &ref_node_id))\n     {\n       bool ok = resolver->lookup_resolved_type (ast_node_id, &ref_node_id);\n       rust_assert (ok);"}, {"sha": "fdae5aa7a604112d277bd58fdcbbf6d1de1f125c", "filename": "gcc/rust/privacy/rust-visibility-resolver.cc", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ca7362602d4e827ecbc39d5cfdf56df9044633b/gcc%2Frust%2Fprivacy%2Frust-visibility-resolver.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ca7362602d4e827ecbc39d5cfdf56df9044633b/gcc%2Frust%2Fprivacy%2Frust-visibility-resolver.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fprivacy%2Frust-visibility-resolver.cc?ref=7ca7362602d4e827ecbc39d5cfdf56df9044633b", "patch": "@@ -71,12 +71,6 @@ VisibilityResolver::resolve_module_path (const HIR::SimplePath &restriction,\n   // TODO: For the hint, can we point to the original item's definition if\n   // present?\n \n-  Resolver::Definition def;\n-  rust_assert (resolver.lookup_definition (ref_node_id, &def));\n-\n-  // FIXME: Is that what we want?\n-  ref_node_id = def.parent;\n-\n   HirId ref;\n   rust_assert (\n     mappings.lookup_node_to_hir (restriction.get_mappings ().get_crate_num (),"}, {"sha": "0ae1847e3152a6cb1ac1234e9d8f08228a4075bb", "filename": "gcc/rust/resolve/rust-ast-resolve-expr.cc", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ca7362602d4e827ecbc39d5cfdf56df9044633b/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ca7362602d4e827ecbc39d5cfdf56df9044633b/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.cc?ref=7ca7362602d4e827ecbc39d5cfdf56df9044633b", "patch": "@@ -113,16 +113,12 @@ ResolveExpr::visit (AST::IdentifierExpr &expr)\n \t&resolved_node))\n     {\n       resolver->insert_resolved_name (expr.get_node_id (), resolved_node);\n-      resolver->insert_new_definition (expr.get_node_id (),\n-\t\t\t\t       Definition{expr.get_node_id (), parent});\n     }\n   else if (resolver->get_type_scope ().lookup (\n \t     CanonicalPath::new_seg (expr.get_node_id (), expr.as_string ()),\n \t     &resolved_node))\n     {\n       resolver->insert_resolved_type (expr.get_node_id (), resolved_node);\n-      resolver->insert_new_definition (expr.get_node_id (),\n-\t\t\t\t       Definition{expr.get_node_id (), parent});\n     }\n   else\n     {\n@@ -352,9 +348,6 @@ ResolveExpr::visit (AST::LoopExpr &expr)\n \t  rust_error_at (label.get_locus (), \"label redefined multiple times\");\n \t  rust_error_at (locus, \"was defined here\");\n \t});\n-      resolver->insert_new_definition (label_lifetime_node_id,\n-\t\t\t\t       Definition{label_lifetime_node_id,\n-\t\t\t\t\t\t  label.get_node_id ()});\n     }\n   resolve_expr (expr.get_loop_block ().get (), expr.get_node_id ());\n }\n@@ -412,9 +405,6 @@ ResolveExpr::visit (AST::WhileLoopExpr &expr)\n \t  rust_error_at (label.get_locus (), \"label redefined multiple times\");\n \t  rust_error_at (locus, \"was defined here\");\n \t});\n-      resolver->insert_new_definition (label_lifetime_node_id,\n-\t\t\t\t       Definition{label_lifetime_node_id,\n-\t\t\t\t\t\t  label.get_node_id ()});\n     }\n   resolve_expr (expr.get_predicate_expr ().get (), expr.get_node_id ());\n   resolve_expr (expr.get_loop_block ().get (), expr.get_node_id ());\n@@ -443,9 +433,6 @@ ResolveExpr::visit (AST::ForLoopExpr &expr)\n \t  rust_error_at (label.get_locus (), \"label redefined multiple times\");\n \t  rust_error_at (locus, \"was defined here\");\n \t});\n-      resolver->insert_new_definition (label_lifetime_node_id,\n-\t\t\t\t       Definition{label_lifetime_node_id,\n-\t\t\t\t\t\t  label.get_node_id ()});\n     }\n \n   // this needs a new rib to contain the pattern"}, {"sha": "ba184e4a53eeca46750eb3719fa5772f72e20b36", "filename": "gcc/rust/resolve/rust-ast-resolve-implitem.h", "status": "modified", "additions": 6, "deletions": 24, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ca7362602d4e827ecbc39d5cfdf56df9044633b/gcc%2Frust%2Fresolve%2Frust-ast-resolve-implitem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ca7362602d4e827ecbc39d5cfdf56df9044633b/gcc%2Frust%2Fresolve%2Frust-ast-resolve-implitem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-implitem.h?ref=7ca7362602d4e827ecbc39d5cfdf56df9044633b", "patch": "@@ -76,9 +76,6 @@ class ResolveToplevelImplItem : public ResolverBase\n \tr.add_range (locus);\n \trust_error_at (r, \"redefined multiple times\");\n       });\n-    resolver->insert_new_definition (constant.get_node_id (),\n-\t\t\t\t     Definition{constant.get_node_id (),\n-\t\t\t\t\t\tconstant.get_node_id ()});\n   }\n \n   void visit (AST::Function &function) override\n@@ -93,9 +90,6 @@ class ResolveToplevelImplItem : public ResolverBase\n \tr.add_range (locus);\n \trust_error_at (r, \"redefined multiple times\");\n       });\n-    resolver->insert_new_definition (function.get_node_id (),\n-\t\t\t\t     Definition{function.get_node_id (),\n-\t\t\t\t\t\tfunction.get_node_id ()});\n   }\n \n   void visit (AST::Method &method) override\n@@ -110,9 +104,6 @@ class ResolveToplevelImplItem : public ResolverBase\n \tr.add_range (locus);\n \trust_error_at (r, \"redefined multiple times\");\n       });\n-    resolver->insert_new_definition (method.get_node_id (),\n-\t\t\t\t     Definition{method.get_node_id (),\n-\t\t\t\t\t\tmethod.get_node_id ()});\n   }\n \n private:\n@@ -150,9 +141,6 @@ class ResolveTopLevelTraitItems : public ResolverBase\n \tr.add_range (locus);\n \trust_error_at (r, \"redefined multiple times\");\n       });\n-    resolver->insert_new_definition (function.get_node_id (),\n-\t\t\t\t     Definition{function.get_node_id (),\n-\t\t\t\t\t\tfunction.get_node_id ()});\n \n     mappings->insert_canonical_path (mappings->get_current_crate (),\n \t\t\t\t     function.get_node_id (), cpath);\n@@ -171,9 +159,6 @@ class ResolveTopLevelTraitItems : public ResolverBase\n \tr.add_range (locus);\n \trust_error_at (r, \"redefined multiple times\");\n       });\n-    resolver->insert_new_definition (method.get_node_id (),\n-\t\t\t\t     Definition{method.get_node_id (),\n-\t\t\t\t\t\tmethod.get_node_id ()});\n \n     mappings->insert_canonical_path (mappings->get_current_crate (),\n \t\t\t\t     method.get_node_id (), cpath);\n@@ -192,9 +177,6 @@ class ResolveTopLevelTraitItems : public ResolverBase\n \tr.add_range (locus);\n \trust_error_at (r, \"redefined multiple times\");\n       });\n-    resolver->insert_new_definition (constant.get_node_id (),\n-\t\t\t\t     Definition{constant.get_node_id (),\n-\t\t\t\t\t\tconstant.get_node_id ()});\n \n     mappings->insert_canonical_path (mappings->get_current_crate (),\n \t\t\t\t     constant.get_node_id (), cpath);\n@@ -253,9 +235,9 @@ class ResolveToplevelExternItem : public ResolverBase\n \tr.add_range (locus);\n \trust_error_at (r, \"redefined multiple times\");\n       });\n-    resolver->insert_new_definition (function.get_node_id (),\n-\t\t\t\t     Definition{function.get_node_id (),\n-\t\t\t\t\t\tfunction.get_node_id ()});\n+\n+    NodeId current_module = resolver->peek_current_module_scope ();\n+    mappings->insert_module_child_item (current_module, decl);\n   }\n \n   void visit (AST::ExternalStaticItem &item) override\n@@ -271,9 +253,9 @@ class ResolveToplevelExternItem : public ResolverBase\n \tr.add_range (locus);\n \trust_error_at (r, \"redefined multiple times\");\n       });\n-    resolver->insert_new_definition (item.get_node_id (),\n-\t\t\t\t     Definition{item.get_node_id (),\n-\t\t\t\t\t\titem.get_node_id ()});\n+\n+    NodeId current_module = resolver->peek_current_module_scope ();\n+    mappings->insert_module_child_item (current_module, decl);\n   }\n \n private:"}, {"sha": "9f550ad252b2b2f477c2598fb2f3d880a78e8777", "filename": "gcc/rust/resolve/rust-ast-resolve-item.cc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ca7362602d4e827ecbc39d5cfdf56df9044633b/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ca7362602d4e827ecbc39d5cfdf56df9044633b/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.cc?ref=7ca7362602d4e827ecbc39d5cfdf56df9044633b", "patch": "@@ -528,6 +528,7 @@ ResolveItem::visit (AST::Function &function)\n   auto decl = ResolveFunctionItemToCanonicalPath::resolve (function);\n   auto path = prefix.append (decl);\n   auto cpath = canonical_prefix.append (decl);\n+\n   mappings->insert_canonical_path (mappings->get_current_crate (),\n \t\t\t\t   function.get_node_id (), cpath);\n \n@@ -788,6 +789,7 @@ ResolveItem::visit (AST::TraitImpl &impl_block)\n       resolver->get_name_scope ().pop ();\n       return;\n     }\n+  rust_assert (!canonical_impl_type.is_empty ());\n \n   // setup paths\n   bool canonicalize_type_args = !impl_block.has_generics ();"}, {"sha": "dbf2df782f94cf1d3be7d99678c8cc1356db901e", "filename": "gcc/rust/resolve/rust-ast-resolve-path.cc", "status": "modified", "additions": 279, "deletions": 254, "changes": 533, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ca7362602d4e827ecbc39d5cfdf56df9044633b/gcc%2Frust%2Fresolve%2Frust-ast-resolve-path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ca7362602d4e827ecbc39d5cfdf56df9044633b/gcc%2Frust%2Fresolve%2Frust-ast-resolve-path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-path.cc?ref=7ca7362602d4e827ecbc39d5cfdf56df9044633b", "patch": "@@ -47,301 +47,326 @@ ResolvePath::go (AST::SimplePath *expr, NodeId parent)\n void\n ResolvePath::resolve_path (AST::PathInExpression *expr)\n {\n-  // resolve root segment first then apply segments in turn\n-  std::vector<AST::PathExprSegment> &segs = expr->get_segments ();\n-  AST::PathExprSegment &root_segment = segs.at (0);\n-  AST::PathIdentSegment &root_ident_seg = root_segment.get_ident_segment ();\n+  NodeId resolved_node_id = UNKNOWN_NODEID;\n+  NodeId module_scope_id = resolver->peek_current_module_scope ();\n+  NodeId previous_resolved_node_id = module_scope_id;\n+  for (size_t i = 0; i < expr->get_segments ().size (); i++)\n+    {\n+      auto &segment = expr->get_segments ().at (i);\n+      const AST::PathIdentSegment &ident_seg = segment.get_ident_segment ();\n+      bool is_first_segment = i == 0;\n+      resolved_node_id = UNKNOWN_NODEID;\n \n-  bool segment_is_type = false;\n-  CanonicalPath root_seg_path\n-    = CanonicalPath::new_seg (root_segment.get_node_id (),\n-\t\t\t      root_ident_seg.as_string ());\n+      NodeId crate_scope_id = resolver->peek_crate_module_scope ();\n+      if (segment.is_crate_path_seg ())\n+\t{\n+\t  // what is the current crate scope node id?\n+\t  module_scope_id = crate_scope_id;\n+\t  previous_resolved_node_id = module_scope_id;\n+\t  resolver->insert_resolved_name (segment.get_node_id (),\n+\t\t\t\t\t  module_scope_id);\n+\t  continue;\n+\t}\n+      else if (segment.is_super_path_seg ())\n+\t{\n+\t  if (module_scope_id == crate_scope_id)\n+\t    {\n+\t      rust_error_at (segment.get_locus (),\n+\t\t\t     \"cannot use %<super%> at the crate scope\");\n+\t      return;\n+\t    }\n+\n+\t  module_scope_id = resolver->peek_parent_module_scope ();\n+\t  previous_resolved_node_id = module_scope_id;\n+\t  resolver->insert_resolved_name (segment.get_node_id (),\n+\t\t\t\t\t  module_scope_id);\n+\t  continue;\n+\t}\n \n-  // name scope first\n-  if (resolver->get_name_scope ().lookup (root_seg_path, &resolved_node))\n-    {\n-      segment_is_type = false;\n-      resolver->insert_resolved_name (root_segment.get_node_id (),\n-\t\t\t\t      resolved_node);\n-      resolver->insert_new_definition (root_segment.get_node_id (),\n-\t\t\t\t       Definition{expr->get_node_id (),\n-\t\t\t\t\t\t  parent});\n-    }\n-  // check the type scope\n-  else if (resolver->get_type_scope ().lookup (root_seg_path, &resolved_node))\n-    {\n-      segment_is_type = true;\n-      resolver->insert_resolved_type (root_segment.get_node_id (),\n-\t\t\t\t      resolved_node);\n-      resolver->insert_new_definition (root_segment.get_node_id (),\n-\t\t\t\t       Definition{expr->get_node_id (),\n-\t\t\t\t\t\t  parent});\n-    }\n-  else\n-    {\n-      rust_error_at (expr->get_locus (),\n-\t\t     \"Cannot find path %<%s%> in this scope\",\n-\t\t     root_segment.as_string ().c_str ());\n-      return;\n-    }\n+      // resolve any generic args\n+      if (segment.has_generic_args ())\n+\t{\n+\t  bool ok = ResolveTypeToCanonicalPath::type_resolve_generic_args (\n+\t    segment.get_generic_args ());\n+\t  if (!ok)\n+\t    {\n+\t      rust_error_at (segment.get_locus (),\n+\t\t\t     \"failed to resolve generic arguments\");\n+\t      return;\n+\t    }\n+\t}\n \n-  if (root_segment.has_generic_args ())\n-    {\n-      bool ok = ResolveTypeToCanonicalPath::type_resolve_generic_args (\n-\troot_segment.get_generic_args ());\n-      if (!ok)\n+      // logic is awkward here there are a few cases\n+      //\n+      // T::Default\n+      // mod::foo::impl_item\n+      // super::super::module::item\n+      // self\n+      // self::foo\n+      // self::foo::baz\n+      //\n+      // T::Default we can only resolve the T and cant do anything about Default\n+      // its dependant on associated types\n+      //\n+      // mod::foo::impl_item\n+      // we can resolve mod::foo but nothing about impl_item but we need to\n+      // _always resolve generic arguments\n+      //\n+      // self is a simple single lookup\n+      //\n+      // we have module_scope_id for the next module_scope to lookup\n+      // resolved_node_id is the thing we have resolve this segment to\n+      //\n+      // new algo?\n+      // we can only use module resolution when the previous segment is either\n+      // unknown or equal to this module_scope_id\n+      //\n+      // can only use old resolution when previous segment is unkown\n+\n+      if (previous_resolved_node_id == module_scope_id)\n \t{\n-\t  rust_error_at (root_segment.get_locus (),\n-\t\t\t \"failed to resolve generic arguments\");\n-\t  return;\n+\t  Optional<CanonicalPath &> resolved_child\n+\t    = mappings->lookup_module_child (module_scope_id,\n+\t\t\t\t\t     ident_seg.as_string ());\n+\t  if (resolved_child.is_some ())\n+\t    {\n+\t      NodeId resolved_node = resolved_child->get_node_id ();\n+\t      if (resolver->get_name_scope ().decl_was_declared_here (\n+\t\t    resolved_node))\n+\t\t{\n+\t\t  resolved_node_id = resolved_node;\n+\t\t  resolver->insert_resolved_name (segment.get_node_id (),\n+\t\t\t\t\t\t  resolved_node);\n+\t\t}\n+\t      else if (resolver->get_type_scope ().decl_was_declared_here (\n+\t\t\t resolved_node))\n+\t\t{\n+\t\t  resolved_node_id = resolved_node;\n+\t\t  resolver->insert_resolved_type (segment.get_node_id (),\n+\t\t\t\t\t\t  resolved_node);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  rust_error_at (segment.get_locus (),\n+\t\t\t\t \"Cannot find path %<%s%> in this scope\",\n+\t\t\t\t segment.as_string ().c_str ());\n+\t\t  return;\n+\t\t}\n+\t    }\n+\t}\n+\n+      if (resolved_node_id == UNKNOWN_NODEID && is_first_segment)\n+\t{\n+\t  // name scope first\n+\t  NodeId resolved_node = UNKNOWN_NODEID;\n+\t  const CanonicalPath path\n+\t    = CanonicalPath::new_seg (segment.get_node_id (),\n+\t\t\t\t      ident_seg.as_string ());\n+\t  if (resolver->get_name_scope ().lookup (path, &resolved_node))\n+\t    {\n+\t      resolver->insert_resolved_name (segment.get_node_id (),\n+\t\t\t\t\t      resolved_node);\n+\t    }\n+\t  // check the type scope\n+\t  else if (resolver->get_type_scope ().lookup (path, &resolved_node))\n+\t    {\n+\t      resolver->insert_resolved_type (segment.get_node_id (),\n+\t\t\t\t\t      resolved_node);\n+\t    }\n+\t  else\n+\t    {\n+\t      rust_error_at (segment.get_locus (),\n+\t\t\t     \"Cannot find path %<%s%> in this scope\",\n+\t\t\t     segment.as_string ().c_str ());\n+\t      return;\n+\t    }\n+\n+\t  resolved_node_id = resolved_node;\n+\t}\n+\n+      if (resolved_node_id != UNKNOWN_NODEID)\n+\t{\n+\t  if (mappings->node_is_module (resolved_node_id))\n+\t    {\n+\t      module_scope_id = resolved_node_id;\n+\t    }\n+\t  previous_resolved_node_id = resolved_node_id;\n \t}\n     }\n \n-  bool is_single_segment = segs.size () == 1;\n-  if (is_single_segment)\n+  resolved_node = resolved_node_id;\n+  if (resolved_node_id != UNKNOWN_NODEID)\n     {\n-      if (segment_is_type)\n-\tresolver->insert_resolved_type (expr->get_node_id (), resolved_node);\n+      // name scope first\n+      if (resolver->get_name_scope ().decl_was_declared_here (resolved_node_id))\n+\t{\n+\t  resolver->insert_resolved_name (expr->get_node_id (),\n+\t\t\t\t\t  resolved_node_id);\n+\t}\n+      // check the type scope\n+      else if (resolver->get_type_scope ().decl_was_declared_here (\n+\t\t resolved_node_id))\n+\t{\n+\t  resolver->insert_resolved_type (expr->get_node_id (),\n+\t\t\t\t\t  resolved_node_id);\n+\t}\n       else\n-\tresolver->insert_resolved_name (expr->get_node_id (), resolved_node);\n-\n-      resolver->insert_new_definition (expr->get_node_id (),\n-\t\t\t\t       Definition{expr->get_node_id (),\n-\t\t\t\t\t\t  parent});\n-      return;\n+\t{\n+\t  gcc_unreachable ();\n+\t}\n     }\n-\n-  resolve_segments (root_seg_path, 1, expr->get_segments (),\n-\t\t    expr->get_node_id (), expr->get_locus ());\n }\n \n void\n ResolvePath::resolve_path (AST::QualifiedPathInExpression *expr)\n {\n   AST::QualifiedPathType &root_segment = expr->get_qualified_path_type ();\n-\n-  bool canonicalize_type_with_generics = false;\n   ResolveType::go (&root_segment.get_as_type_path (),\n-\t\t   root_segment.get_node_id (),\n-\t\t   canonicalize_type_with_generics);\n-\n-  ResolveType::go (root_segment.get_type ().get (), root_segment.get_node_id (),\n-\t\t   canonicalize_type_with_generics);\n-\n-  bool type_resolve_generic_args = true;\n-  CanonicalPath impl_type_seg\n-    = ResolveTypeToCanonicalPath::resolve (*root_segment.get_type ().get (),\n-\t\t\t\t\t   canonicalize_type_with_generics,\n-\t\t\t\t\t   type_resolve_generic_args);\n-\n-  CanonicalPath trait_type_seg\n-    = ResolveTypeToCanonicalPath::resolve (root_segment.get_as_type_path (),\n-\t\t\t\t\t   canonicalize_type_with_generics,\n-\t\t\t\t\t   type_resolve_generic_args);\n-  CanonicalPath root_seg_path\n-    = TraitImplProjection::resolve (root_segment.get_node_id (), trait_type_seg,\n-\t\t\t\t    impl_type_seg);\n-  bool segment_is_type = false;\n+\t\t   root_segment.get_node_id ());\n+  ResolveType::go (root_segment.get_type ().get (),\n+\t\t   root_segment.get_node_id ());\n \n-  // name scope first\n-  if (resolver->get_name_scope ().lookup (root_seg_path, &resolved_node))\n+  for (auto &segment : expr->get_segments ())\n     {\n-      segment_is_type = false;\n-      resolver->insert_resolved_name (root_segment.get_node_id (),\n-\t\t\t\t      resolved_node);\n-      resolver->insert_new_definition (root_segment.get_node_id (),\n-\t\t\t\t       Definition{expr->get_node_id (),\n-\t\t\t\t\t\t  parent});\n-    }\n-  // check the type scope\n-  else if (resolver->get_type_scope ().lookup (root_seg_path, &resolved_node))\n-    {\n-      segment_is_type = true;\n-      resolver->insert_resolved_type (root_segment.get_node_id (),\n-\t\t\t\t      resolved_node);\n-      resolver->insert_new_definition (root_segment.get_node_id (),\n-\t\t\t\t       Definition{expr->get_node_id (),\n-\t\t\t\t\t\t  parent});\n-    }\n-  else\n-    {\n-      rust_error_at (expr->get_locus (),\n-\t\t     \"Cannot find path %<%s%> in this scope\",\n-\t\t     root_segment.as_string ().c_str ());\n-      return;\n-    }\n-\n-  bool is_single_segment = expr->get_segments ().empty ();\n-  if (is_single_segment)\n-    {\n-      if (segment_is_type)\n-\tresolver->insert_resolved_type (expr->get_node_id (), resolved_node);\n-      else\n-\tresolver->insert_resolved_name (expr->get_node_id (), resolved_node);\n-\n-      resolver->insert_new_definition (expr->get_node_id (),\n-\t\t\t\t       Definition{expr->get_node_id (),\n-\t\t\t\t\t\t  parent});\n-      return;\n+      // we cant actually do anything with the segment itself since this is all\n+      // the job of the type system to figure it out but we can resolve any\n+      // generic arguments used\n+      if (segment.has_generic_args ())\n+\t{\n+\t  bool ok = ResolveTypeToCanonicalPath::type_resolve_generic_args (\n+\t    segment.get_generic_args ());\n+\t  if (!ok)\n+\t    {\n+\t      rust_error_at (segment.get_locus (),\n+\t\t\t     \"failed to resolve generic arguments\");\n+\t      return;\n+\t    }\n+\t}\n     }\n-\n-  resolve_segments (root_seg_path, 0, expr->get_segments (),\n-\t\t    expr->get_node_id (), expr->get_locus ());\n }\n \n void\n-ResolvePath::resolve_segments (CanonicalPath prefix, size_t offs,\n-\t\t\t       std::vector<AST::PathExprSegment> &segs,\n-\t\t\t       NodeId expr_node_id, Location expr_locus)\n+ResolvePath::resolve_path (AST::SimplePath *expr)\n {\n-  // we can attempt to resolve this path fully\n-  CanonicalPath path = prefix;\n-  bool segment_is_type = false;\n-  for (size_t i = offs; i < segs.size (); i++)\n-    {\n-      AST::PathExprSegment &seg = segs.at (i);\n-      auto s = ResolvePathSegmentToCanonicalPath::resolve (seg);\n-      path = path.append (s);\n+  NodeId crate_scope_id = resolver->peek_crate_module_scope ();\n+  NodeId module_scope_id = resolver->peek_current_module_scope ();\n \n-      // reset state\n-      segment_is_type = false;\n-      resolved_node = UNKNOWN_NODEID;\n+  NodeId resolved_node_id = UNKNOWN_NODEID;\n+  for (size_t i = 0; i < expr->get_segments ().size (); i++)\n+    {\n+      auto &segment = expr->get_segments ().at (i);\n+      bool is_first_segment = i == 0;\n+      resolved_node_id = UNKNOWN_NODEID;\n \n-      if (resolver->get_name_scope ().lookup (path, &resolved_node))\n+      if (segment.is_crate_path_seg ())\n \t{\n-\t  resolver->insert_resolved_name (seg.get_node_id (), resolved_node);\n-\t  resolver->insert_new_definition (seg.get_node_id (),\n-\t\t\t\t\t   Definition{expr_node_id, parent});\n+\t  // what is the current crate scope node id?\n+\t  module_scope_id = crate_scope_id;\n+\t  resolver->insert_resolved_name (segment.get_node_id (),\n+\t\t\t\t\t  module_scope_id);\n+\t  continue;\n \t}\n-      // check the type scope\n-      else if (resolver->get_type_scope ().lookup (path, &resolved_node))\n+      else if (segment.is_super_path_seg ())\n \t{\n-\t  segment_is_type = true;\n-\t  resolver->insert_resolved_type (seg.get_node_id (), resolved_node);\n-\t  resolver->insert_new_definition (seg.get_node_id (),\n-\t\t\t\t\t   Definition{expr_node_id, parent});\n+\t  if (module_scope_id == crate_scope_id)\n+\t    {\n+\t      rust_error_at (segment.get_locus (),\n+\t\t\t     \"cannot use %<super%> at the crate scope\");\n+\t      return;\n+\t    }\n+\n+\t  module_scope_id = resolver->peek_parent_module_scope ();\n+\t  resolver->insert_resolved_name (segment.get_node_id (),\n+\t\t\t\t\t  module_scope_id);\n+\t  continue;\n \t}\n-      else\n-\t{\n-\t  // attempt to fully resolve the path which is allowed to fail given\n-\t  // the following scenario\n-\t  //\n-\t  // https://github.com/Rust-GCC/gccrs/issues/355 Paths are\n-\t  // resolved fully here, there are limitations though imagine:\n-\t  //\n-\t  // struct Foo<A> (A);\n-\t  //\n-\t  // impl Foo<isize> {\n-\t  //    fn test() -> ...\n-\t  //\n-\t  // impl Foo<f32> {\n-\t  //    fn test() -> ...\n-\t  //\n-\t  // fn main() {\n-\t  //    let a:i32 = Foo::test();\n-\t  //\n-\t  // there are multiple paths that test can resolve to Foo::<?>::test\n-\t  // here so we cannot resolve this case\n-\t  //\n-\t  // canonical names:\n-\t  //\n-\t  // struct Foo<A>            -> Foo\n-\t  // impl Foo<isize>::fn test -> Foo::isize::test\n-\t  // impl Foo<f32>::fn test   -> Foo::f32::test\n-\t  //\n-\t  // Since there is the case we have the following paths for test:\n-\t  //\n-\t  // Foo::isize::test\n-\t  // Foo::f32::test\n-\t  // vs\n-\t  // Foo::test\n-\t  //\n-\t  // but the lookup was simply Foo::test we must rely on type resolution\n-\t  // to figure this type out in a similar fashion to method resolution\n-\t  // with a probe phase\n \n-\t  // nothing more we can do we need the type resolver to try and resolve\n-\t  // this\n-\t  return;\n+      Optional<CanonicalPath &> resolved_child\n+\t= mappings->lookup_module_child (module_scope_id,\n+\t\t\t\t\t segment.get_segment_name ());\n+      if (resolved_child.is_some ())\n+\t{\n+\t  NodeId resolved_node = resolved_child->get_node_id ();\n+\t  if (resolver->get_name_scope ().decl_was_declared_here (\n+\t\tresolved_node))\n+\t    {\n+\t      resolved_node_id = resolved_node;\n+\t      resolver->insert_resolved_name (segment.get_node_id (),\n+\t\t\t\t\t      resolved_node);\n+\t    }\n+\t  else if (resolver->get_type_scope ().decl_was_declared_here (\n+\t\t     resolved_node))\n+\t    {\n+\t      resolved_node_id = resolved_node;\n+\t      resolver->insert_resolved_type (segment.get_node_id (),\n+\t\t\t\t\t      resolved_node);\n+\t    }\n+\t  else\n+\t    {\n+\t      rust_error_at (segment.get_locus (),\n+\t\t\t     \"Cannot find path %<%s%> in this scope\",\n+\t\t\t     segment.as_string ().c_str ());\n+\t      return;\n+\t    }\n \t}\n-    }\n-\n-  // its fully resolved lets mark it as such\n-  if (resolved_node != UNKNOWN_NODEID)\n-    {\n-      if (segment_is_type)\n-\tresolver->insert_resolved_type (expr_node_id, resolved_node);\n-      else\n-\tresolver->insert_resolved_name (expr_node_id, resolved_node);\n-\n-      resolver->insert_new_definition (expr_node_id,\n-\t\t\t\t       Definition{expr_node_id, parent});\n-    }\n-}\n-\n-static bool\n-lookup_and_insert_segment (Resolver *resolver, CanonicalPath path,\n-\t\t\t   NodeId segment_id, NodeId *to_resolve, bool &is_type)\n-{\n-  if (resolver->get_name_scope ().lookup (path, to_resolve))\n-    {\n-      resolver->insert_resolved_name (segment_id, *to_resolve);\n-    }\n-  else if (resolver->get_type_scope ().lookup (path, to_resolve))\n-    {\n-      is_type = true;\n-      resolver->insert_resolved_type (segment_id, *to_resolve);\n-    }\n-  else\n-    {\n-      return false;\n-    }\n \n-  return true;\n-}\n-\n-void\n-ResolvePath::resolve_path (AST::SimplePath *simple_path)\n-{\n-  // resolve root segment first then apply segments in turn\n-  auto expr_node_id = simple_path->get_node_id ();\n-  auto is_type = false;\n-\n-  auto path = CanonicalPath::create_empty ();\n-  for (const auto &seg : simple_path->get_segments ())\n-    {\n-      auto s = ResolveSimplePathSegmentToCanonicalPath::resolve (seg);\n-      path = path.append (s);\n-\n-      // Reset state\n-      resolved_node = UNKNOWN_NODEID;\n-      is_type = false;\n+      if (resolved_node_id == UNKNOWN_NODEID && is_first_segment)\n+\t{\n+\t  // name scope first\n+\t  NodeId resolved_node = UNKNOWN_NODEID;\n+\t  const CanonicalPath path\n+\t    = CanonicalPath::new_seg (segment.get_node_id (),\n+\t\t\t\t      segment.get_segment_name ());\n+\t  if (resolver->get_name_scope ().lookup (path, &resolved_node))\n+\t    {\n+\t      resolved_node_id = resolved_node;\n+\t      resolver->insert_resolved_name (segment.get_node_id (),\n+\t\t\t\t\t      resolved_node);\n+\t    }\n+\t  // check the type scope\n+\t  else if (resolver->get_type_scope ().lookup (path, &resolved_node))\n+\t    {\n+\t      resolved_node_id = resolved_node;\n+\t      resolver->insert_resolved_type (segment.get_node_id (),\n+\t\t\t\t\t      resolved_node);\n+\t    }\n+\t}\n \n-      if (!lookup_and_insert_segment (resolver, path, seg.get_node_id (),\n-\t\t\t\t      &resolved_node, is_type))\n+      if (resolved_node_id == UNKNOWN_NODEID)\n \t{\n-\t  rust_error_at (seg.get_locus (),\n-\t\t\t \"cannot find simple path segment %qs\",\n-\t\t\t seg.as_string ().c_str ());\n+\t  rust_error_at (segment.get_locus (),\n+\t\t\t \"cannot find simple path segment %<%s%> in this scope\",\n+\t\t\t segment.as_string ().c_str ());\n \t  return;\n \t}\n+\n+      if (mappings->node_is_module (resolved_node_id))\n+\t{\n+\t  module_scope_id = resolved_node_id;\n+\t}\n     }\n \n-  if (resolved_node == UNKNOWN_NODEID)\n+  resolved_node = resolved_node_id;\n+  if (resolved_node_id != UNKNOWN_NODEID)\n     {\n-      rust_error_at (simple_path->get_locus (),\n-\t\t     \"could not resolve simple path %qs\",\n-\t\t     simple_path->as_string ().c_str ());\n-      return;\n+      // name scope first\n+      if (resolver->get_name_scope ().decl_was_declared_here (resolved_node_id))\n+\t{\n+\t  resolver->insert_resolved_name (expr->get_node_id (),\n+\t\t\t\t\t  resolved_node_id);\n+\t}\n+      // check the type scope\n+      else if (resolver->get_type_scope ().decl_was_declared_here (\n+\t\t resolved_node_id))\n+\t{\n+\t  resolver->insert_resolved_type (expr->get_node_id (),\n+\t\t\t\t\t  resolved_node_id);\n+\t}\n+      else\n+\t{\n+\t  gcc_unreachable ();\n+\t}\n     }\n-\n-  if (is_type)\n-    resolver->insert_resolved_type (expr_node_id, resolved_node);\n-  else\n-    resolver->insert_resolved_name (expr_node_id, resolved_node);\n-\n-  resolver->insert_new_definition (expr_node_id,\n-\t\t\t\t   Definition{expr_node_id, parent});\n }\n \n } // namespace Resolver"}, {"sha": "fc8785f73d58dba963344e9e05dde68ed75797e3", "filename": "gcc/rust/resolve/rust-ast-resolve-path.h", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ca7362602d4e827ecbc39d5cfdf56df9044633b/gcc%2Frust%2Fresolve%2Frust-ast-resolve-path.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ca7362602d4e827ecbc39d5cfdf56df9044633b/gcc%2Frust%2Fresolve%2Frust-ast-resolve-path.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-path.h?ref=7ca7362602d4e827ecbc39d5cfdf56df9044633b", "patch": "@@ -40,26 +40,12 @@ class ResolvePath : public ResolverBase\n   void resolve_path (AST::QualifiedPathInExpression *expr);\n   void resolve_path (AST::SimplePath *expr);\n \n-  void resolve_segments (CanonicalPath prefix, size_t offs,\n-\t\t\t std::vector<AST::PathExprSegment> &segs,\n-\t\t\t NodeId expr_node_id, Location expr_locus);\n-\n   void\n   resolve_simple_path_segments (CanonicalPath prefix, size_t offs,\n \t\t\t\tconst std::vector<AST::SimplePathSegment> &segs,\n \t\t\t\tNodeId expr_node_id, Location expr_locus);\n };\n \n-class ResolveSimplePathSegmentToCanonicalPath\n-{\n-public:\n-  static CanonicalPath resolve (const AST::SimplePathSegment &seg)\n-  {\n-    // FIXME: Since this is so simple, maybe it can simply be a tiny function?\n-    return CanonicalPath::new_seg (seg.get_node_id (), seg.get_segment_name ());\n-  }\n-};\n-\n } // namespace Resolver\n } // namespace Rust\n "}, {"sha": "1947212f4315062fc9936c99817ff34e59263acd", "filename": "gcc/rust/resolve/rust-ast-resolve-pattern.cc", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ca7362602d4e827ecbc39d5cfdf56df9044633b/gcc%2Frust%2Fresolve%2Frust-ast-resolve-pattern.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ca7362602d4e827ecbc39d5cfdf56df9044633b/gcc%2Frust%2Fresolve%2Frust-ast-resolve-pattern.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-pattern.cc?ref=7ca7362602d4e827ecbc39d5cfdf56df9044633b", "patch": "@@ -87,9 +87,7 @@ PatternDeclaration::visit (AST::StructPattern &pattern)\n \t      CanonicalPath::new_seg (ident.get_node_id (),\n \t\t\t\t      ident.get_identifier ()),\n \t      ident.get_node_id (), ident.get_locus ());\n-\t    resolver->insert_new_definition (ident.get_node_id (),\n-\t\t\t\t\t     Definition{ident.get_node_id (),\n-\t\t\t\t\t\t\tident.get_node_id ()});\n+\n \t    resolver->mark_decl_mutability (ident.get_node_id (),\n \t\t\t\t\t    ident.is_mut ());\n \t  }"}, {"sha": "b899754709e935ca91c924508fb611e147d68eab", "filename": "gcc/rust/resolve/rust-ast-resolve-pattern.h", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ca7362602d4e827ecbc39d5cfdf56df9044633b/gcc%2Frust%2Fresolve%2Frust-ast-resolve-pattern.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ca7362602d4e827ecbc39d5cfdf56df9044633b/gcc%2Frust%2Fresolve%2Frust-ast-resolve-pattern.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-pattern.h?ref=7ca7362602d4e827ecbc39d5cfdf56df9044633b", "patch": "@@ -48,9 +48,6 @@ class ResolvePattern : public ResolverBase\n \t  &resolved_node))\n       {\n \tresolver->insert_resolved_name (pattern.get_node_id (), resolved_node);\n-\tresolver->insert_new_definition (pattern.get_node_id (),\n-\t\t\t\t\t Definition{pattern.get_node_id (),\n-\t\t\t\t\t\t    parent});\n       }\n   }\n \n@@ -76,9 +73,7 @@ class PatternDeclaration : public ResolverBase\n     resolver->get_name_scope ().insert (\n       CanonicalPath::new_seg (pattern.get_node_id (), pattern.get_ident ()),\n       pattern.get_node_id (), pattern.get_locus ());\n-    resolver->insert_new_definition (pattern.get_node_id (),\n-\t\t\t\t     Definition{pattern.get_node_id (),\n-\t\t\t\t\t\tparent});\n+\n     resolver->mark_decl_mutability (pattern.get_node_id (),\n \t\t\t\t    pattern.get_is_mut ());\n   }\n@@ -88,9 +83,7 @@ class PatternDeclaration : public ResolverBase\n     resolver->get_name_scope ().insert (\n       CanonicalPath::new_seg (pattern.get_node_id (), \"_\"),\n       pattern.get_node_id (), pattern.get_locus ());\n-    resolver->insert_new_definition (pattern.get_node_id (),\n-\t\t\t\t     Definition{pattern.get_node_id (),\n-\t\t\t\t\t\tparent});\n+\n     resolver->mark_decl_mutability (pattern.get_node_id (), false);\n   }\n "}, {"sha": "3556b68fd023a6b16262bda946856d163e80f935", "filename": "gcc/rust/resolve/rust-ast-resolve-stmt.h", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ca7362602d4e827ecbc39d5cfdf56df9044633b/gcc%2Frust%2Fresolve%2Frust-ast-resolve-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ca7362602d4e827ecbc39d5cfdf56df9044633b/gcc%2Frust%2Fresolve%2Frust-ast-resolve-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-stmt.h?ref=7ca7362602d4e827ecbc39d5cfdf56df9044633b", "patch": "@@ -71,9 +71,6 @@ class ResolveStmt : public ResolverBase\n \tr.add_range (locus);\n \trust_error_at (r, \"redefined multiple times\");\n       });\n-    resolver->insert_new_definition (constant.get_node_id (),\n-\t\t\t\t     Definition{constant.get_node_id (),\n-\t\t\t\t\t\tconstant.get_node_id ()});\n \n     ResolveType::go (constant.get_type ().get (), constant.get_node_id ());\n     ResolveExpr::go (constant.get_expr ().get (), constant.get_node_id (),\n@@ -361,9 +358,6 @@ class ResolveStmt : public ResolverBase\n \tr.add_range (locus);\n \trust_error_at (r, \"redefined multiple times\");\n       });\n-    resolver->insert_new_definition (function.get_node_id (),\n-\t\t\t\t     Definition{function.get_node_id (),\n-\t\t\t\t\t\tfunction.get_node_id ()});\n \n     NodeId scope_node_id = function.get_node_id ();\n     resolver->get_name_scope ().push (scope_node_id);"}, {"sha": "78b786a3072d31f3f2438ff5398b0620fd90fc50", "filename": "gcc/rust/resolve/rust-ast-resolve-toplevel.h", "status": "modified", "additions": 1, "deletions": 26, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ca7362602d4e827ecbc39d5cfdf56df9044633b/gcc%2Frust%2Fresolve%2Frust-ast-resolve-toplevel.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ca7362602d4e827ecbc39d5cfdf56df9044633b/gcc%2Frust%2Fresolve%2Frust-ast-resolve-toplevel.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-toplevel.h?ref=7ca7362602d4e827ecbc39d5cfdf56df9044633b", "patch": "@@ -62,10 +62,6 @@ class ResolveTopLevel : public ResolverBase\n \trust_error_at (r, \"redefined multiple times\");\n       });\n \n-    resolver->insert_new_definition (module.get_node_id (),\n-\t\t\t\t     Definition{module.get_node_id (),\n-\t\t\t\t\t\tmodule.get_node_id ()});\n-\n     NodeId current_module = resolver->peek_current_module_scope ();\n     mappings->insert_module_child_item (current_module, mod);\n     mappings->insert_module_child (current_module, module.get_node_id ());\n@@ -278,9 +274,7 @@ class ResolveTopLevel : public ResolverBase\n \tr.add_range (locus);\n \trust_error_at (r, \"redefined multiple times\");\n       });\n-    resolver->insert_new_definition (var.get_node_id (),\n-\t\t\t\t     Definition{var.get_node_id (),\n-\t\t\t\t\t\tvar.get_node_id ()});\n+\n     resolver->mark_decl_mutability (var.get_node_id (), var.is_mutable ());\n \n     NodeId current_module = resolver->peek_current_module_scope ();\n@@ -302,9 +296,6 @@ class ResolveTopLevel : public ResolverBase\n \tr.add_range (locus);\n \trust_error_at (r, \"redefined multiple times\");\n       });\n-    resolver->insert_new_definition (constant.get_node_id (),\n-\t\t\t\t     Definition{constant.get_node_id (),\n-\t\t\t\t\t\tconstant.get_node_id ()});\n \n     NodeId current_module = resolver->peek_current_module_scope ();\n     mappings->insert_module_child_item (current_module, decl);\n@@ -325,17 +316,6 @@ class ResolveTopLevel : public ResolverBase\n \tr.add_range (locus);\n \trust_error_at (r, \"redefined multiple times\");\n       });\n-    resolver->insert_new_definition (function.get_node_id (),\n-\t\t\t\t     Definition{function.get_node_id (),\n-\t\t\t\t\t\tfunction.get_node_id ()});\n-\n-    // if this does not get a reference it will be determined to be unused\n-    // lets give it a fake reference to itself\n-    if (function.get_function_name ().compare (\"main\") == 0)\n-      {\n-\tresolver->insert_resolved_name (function.get_node_id (),\n-\t\t\t\t\tfunction.get_node_id ());\n-      }\n \n     NodeId current_module = resolver->peek_current_module_scope ();\n     mappings->insert_module_child_item (current_module, decl);\n@@ -386,11 +366,6 @@ class ResolveTopLevel : public ResolverBase\n \tr.add_range (locus);\n \trust_error_at (r, \"redefined multiple times\");\n       });\n-    resolver->insert_new_definition (impl_block.get_node_id (),\n-\t\t\t\t     Definition{impl_block.get_node_id (),\n-\t\t\t\t\t\timpl_block.get_node_id ()});\n-    resolver->insert_resolved_name (impl_block.get_node_id (),\n-\t\t\t\t    impl_block.get_node_id ());\n \n     for (auto &impl_item : impl_block.get_impl_items ())\n       ResolveToplevelImplItem::go (impl_item.get (), impl_prefix);"}, {"sha": "ce9c0d19e14c378dd8faf411f4d202b92cd0f2f6", "filename": "gcc/rust/resolve/rust-ast-resolve-type.cc", "status": "modified", "additions": 168, "deletions": 18, "changes": 186, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ca7362602d4e827ecbc39d5cfdf56df9044633b/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ca7362602d4e827ecbc39d5cfdf56df9044633b/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.cc?ref=7ca7362602d4e827ecbc39d5cfdf56df9044633b", "patch": "@@ -133,15 +133,12 @@ ResolveType::visit (AST::ArrayType &type)\n void\n ResolveType::visit (AST::TraitObjectTypeOneBound &type)\n {\n-  NodeId bound_resolved_id\n-    = ResolveTypeBound::go (&type.get_trait_bound (), type.get_node_id ());\n-  ok = bound_resolved_id != UNKNOWN_NODEID;\n+  ResolveTypeBound::go (&type.get_trait_bound (), type.get_node_id ());\n }\n \n void\n ResolveType::visit (AST::TraitObjectType &type)\n {\n-  ok = true;\n   for (auto &bound : type.get_type_param_bounds ())\n     {\n       /* NodeId bound_resolved_id = */\n@@ -270,30 +267,183 @@ ResolveRelativeTypePath::ResolveRelativeTypePath (CanonicalPath qualified_path)\n }\n \n bool\n-ResolveRelativeTypePath::go (AST::QualifiedPathInType &path)\n+ResolveRelativeTypePath::go (AST::TypePath &path, NodeId &resolved_node_id)\n {\n-  // resolve the type and trait path\n-  auto &qualified_path = path.get_qualified_path_type ();\n   CanonicalPath result = CanonicalPath::create_empty ();\n-  if (!resolve_qual_seg (qualified_path, result))\n-    return false;\n+  ResolveRelativeTypePath o (result);\n+  auto &resolver = o.resolver;\n+  auto &mappings = o.mappings;\n \n-  // resolve the associated impl if available but it can also be from a trait\n-  // and this is allowed to fail\n-  auto resolver = Resolver::get ();\n-  NodeId projection_resolved_id = UNKNOWN_NODEID;\n-  if (resolver->get_name_scope ().lookup (result, &projection_resolved_id))\n+  NodeId module_scope_id = resolver->peek_current_module_scope ();\n+  NodeId previous_resolved_node_id = module_scope_id;\n+  for (size_t i = 0; i < path.get_segments ().size (); i++)\n     {\n-      // mark the resolution for this\n-      resolver->insert_resolved_name (qualified_path.get_node_id (),\n-\t\t\t\t      projection_resolved_id);\n+      auto &segment = path.get_segments ().at (i);\n+      const AST::PathIdentSegment &ident_seg = segment->get_ident_segment ();\n+      bool is_first_segment = i == 0;\n+      resolved_node_id = UNKNOWN_NODEID;\n+\n+      NodeId crate_scope_id = resolver->peek_crate_module_scope ();\n+      if (segment->is_crate_path_seg ())\n+\t{\n+\t  // what is the current crate scope node id?\n+\t  module_scope_id = crate_scope_id;\n+\t  previous_resolved_node_id = module_scope_id;\n+\t  resolver->insert_resolved_name (segment->get_node_id (),\n+\t\t\t\t\t  module_scope_id);\n+\n+\t  continue;\n+\t}\n+      else if (segment->is_super_path_seg ())\n+\t{\n+\t  if (module_scope_id == crate_scope_id)\n+\t    {\n+\t      rust_error_at (segment->get_locus (),\n+\t\t\t     \"cannot use super at the crate scope\");\n+\t      return false;\n+\t    }\n+\n+\t  module_scope_id = resolver->peek_parent_module_scope ();\n+\t  previous_resolved_node_id = module_scope_id;\n+\t  resolver->insert_resolved_name (segment->get_node_id (),\n+\t\t\t\t\t  module_scope_id);\n+\t  continue;\n+\t}\n+\n+      switch (segment->get_type ())\n+\t{\n+\t  case AST::TypePathSegment::SegmentType::GENERIC: {\n+\t    AST::TypePathSegmentGeneric *s\n+\t      = static_cast<AST::TypePathSegmentGeneric *> (segment.get ());\n+\t    if (s->has_generic_args ())\n+\t      {\n+\t\tfor (auto &gt : s->get_generic_args ().get_type_args ())\n+\t\t  {\n+\t\t    ResolveType::go (gt.get (), UNKNOWN_NODEID);\n+\t\t  }\n+\t      }\n+\t  }\n+\t  break;\n+\n+\tcase AST::TypePathSegment::SegmentType::REG:\n+\t  // nothing to do\n+\t  break;\n+\n+\tcase AST::TypePathSegment::SegmentType::FUNCTION:\n+\t  gcc_unreachable ();\n+\t  break;\n+\t}\n+\n+      if (previous_resolved_node_id == module_scope_id\n+\t  && path.get_segments ().size () > 1)\n+\t{\n+\t  Optional<CanonicalPath &> resolved_child\n+\t    = mappings->lookup_module_child (module_scope_id,\n+\t\t\t\t\t     ident_seg.as_string ());\n+\t  if (resolved_child.is_some ())\n+\t    {\n+\t      NodeId resolved_node = resolved_child->get_node_id ();\n+\t      if (resolver->get_name_scope ().decl_was_declared_here (\n+\t\t    resolved_node))\n+\t\t{\n+\t\t  resolved_node_id = resolved_node;\n+\t\t  resolver->insert_resolved_name (segment->get_node_id (),\n+\t\t\t\t\t\t  resolved_node);\n+\t\t}\n+\t      else if (resolver->get_type_scope ().decl_was_declared_here (\n+\t\t\t resolved_node))\n+\t\t{\n+\t\t  resolved_node_id = resolved_node;\n+\t\t  resolver->insert_resolved_type (segment->get_node_id (),\n+\t\t\t\t\t\t  resolved_node);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  rust_error_at (segment->get_locus (),\n+\t\t\t\t \"Cannot find path %<%s%> in this scope\",\n+\t\t\t\t segment->as_string ().c_str ());\n+\t\t  return false;\n+\t\t}\n+\t    }\n+\t}\n+\n+      if (resolved_node_id == UNKNOWN_NODEID && is_first_segment)\n+\t{\n+\t  // name scope first\n+\t  NodeId resolved_node = UNKNOWN_NODEID;\n+\t  const CanonicalPath path\n+\t    = CanonicalPath::new_seg (segment->get_node_id (),\n+\t\t\t\t      ident_seg.as_string ());\n+\t  if (resolver->get_type_scope ().lookup (path, &resolved_node))\n+\t    {\n+\t      resolver->insert_resolved_type (segment->get_node_id (),\n+\t\t\t\t\t      resolved_node);\n+\t    }\n+\t  else if (resolver->get_name_scope ().lookup (path, &resolved_node))\n+\t    {\n+\t      resolver->insert_resolved_name (segment->get_node_id (),\n+\t\t\t\t\t      resolved_node);\n+\t    }\n+\t  else\n+\t    {\n+\t      rust_error_at (segment->get_locus (),\n+\t\t\t     \"failed to resolve TypePath: %s in this scope\",\n+\t\t\t     segment->as_string ().c_str ());\n+\t      return false;\n+\t    }\n+\n+\t  resolved_node_id = resolved_node;\n+\t}\n+\n+      if (resolved_node_id != UNKNOWN_NODEID)\n+\t{\n+\t  if (mappings->node_is_module (resolved_node_id))\n+\t    {\n+\t      module_scope_id = resolved_node_id;\n+\t    }\n+\t  previous_resolved_node_id = resolved_node_id;\n+\t}\n     }\n \n+  if (resolved_node_id != UNKNOWN_NODEID)\n+    {\n+      // name scope first\n+      if (resolver->get_name_scope ().decl_was_declared_here (resolved_node_id))\n+\t{\n+\t  resolver->insert_resolved_name (path.get_node_id (),\n+\t\t\t\t\t  resolved_node_id);\n+\t}\n+      // check the type scope\n+      else if (resolver->get_type_scope ().decl_was_declared_here (\n+\t\t resolved_node_id))\n+\t{\n+\t  resolver->insert_resolved_type (path.get_node_id (),\n+\t\t\t\t\t  resolved_node_id);\n+\t}\n+      else\n+\t{\n+\t  gcc_unreachable ();\n+\t}\n+    }\n+\n+  return true;\n+}\n+\n+bool\n+ResolveRelativeTypePath::go (AST::QualifiedPathInType &path)\n+{\n+  CanonicalPath result = CanonicalPath::create_empty ();\n+  ResolveRelativeTypePath o (result);\n+\n+  // resolve the type and trait path\n+  auto &qualified_path = path.get_qualified_path_type ();\n+  if (!o.resolve_qual_seg (qualified_path, result))\n+    return false;\n+\n   // qualified types are similar to other paths in that we cannot guarantee\n   // that we can resolve the path at name resolution. We must look up\n   // associated types and type information to figure this out properly\n \n-  ResolveRelativeTypePath o (result);\n   std::unique_ptr<AST::TypePathSegment> &associated\n     = path.get_associated_segment ();\n "}, {"sha": "cc117ec400346fe36a2a32a18cb0447df79916d4", "filename": "gcc/rust/resolve/rust-ast-resolve-type.h", "status": "modified", "additions": 10, "deletions": 84, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ca7362602d4e827ecbc39d5cfdf56df9044633b/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ca7362602d4e827ecbc39d5cfdf56df9044633b/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.h?ref=7ca7362602d4e827ecbc39d5cfdf56df9044633b", "patch": "@@ -190,13 +190,13 @@ class ResolveRelativeTypePath : public ResolveTypeToCanonicalPath\n   using ResolveTypeToCanonicalPath::visit;\n \n public:\n+  static bool go (AST::TypePath &path, NodeId &resolved_node_id);\n   static bool go (AST::QualifiedPathInType &path);\n \n private:\n   ResolveRelativeTypePath (CanonicalPath qualified_path);\n \n-  static bool resolve_qual_seg (AST::QualifiedPathType &seg,\n-\t\t\t\tCanonicalPath &result);\n+  bool resolve_qual_seg (AST::QualifiedPathType &seg, CanonicalPath &result);\n };\n \n class ResolveType : public ResolverBase\n@@ -211,7 +211,6 @@ class ResolveType : public ResolverBase\n     ResolveType resolver (parent, canonicalize_type_with_generics,\n \t\t\t  canonical_path);\n     type->accept_vis (resolver);\n-\n     return resolver.resolved_node;\n   };\n \n@@ -226,7 +225,6 @@ class ResolveType : public ResolverBase\n \n   void visit (AST::TupleType &tuple) override\n   {\n-    ok = true;\n     if (tuple.is_unit_type ())\n       {\n \tresolved_node = resolver->get_unit_type_node_id ();\n@@ -239,87 +237,16 @@ class ResolveType : public ResolverBase\n \n   void visit (AST::TypePath &path) override\n   {\n-    auto rel_canonical_path\n-      = ResolveTypeToCanonicalPath::resolve (path,\n-\t\t\t\t\t     canonicalize_type_with_generics,\n-\t\t\t\t\t     true);\n-    if (rel_canonical_path.is_empty ())\n-      {\n-\trust_error_at (path.get_locus (),\n-\t\t       \"Failed to resolve canonical path for TypePath\");\n-\treturn;\n-      }\n-\n-    // lets try and resolve in one go else leave it up to the type resolver to\n-    // figure outer\n-\n-    if (resolver->get_type_scope ().lookup (rel_canonical_path, &resolved_node))\n-      {\n-\tresolver->insert_resolved_type (path.get_node_id (), resolved_node);\n-\tresolver->insert_new_definition (path.get_node_id (),\n-\t\t\t\t\t Definition{path.get_node_id (),\n-\t\t\t\t\t\t    parent});\n-\n-\tif (canonical_path != nullptr)\n-\t  {\n-\t    const CanonicalPath *cpath = nullptr;\n-\t    bool ok\n-\t      = mappings->lookup_canonical_path (mappings->get_current_crate (),\n-\t\t\t\t\t\t resolved_node, &cpath);\n-\t    if (!ok)\n-\t      {\n-\t\t*canonical_path = rel_canonical_path;\n-\t      }\n-\t    else\n-\t      {\n-\t\t*canonical_path = *cpath;\n-\t      }\n-\t  }\n-\n-\treturn;\n-      }\n-\n-    // lets resolve as many segments as we can and leave it up to the type\n-    // resolver otherwise\n-    size_t nprocessed = 0;\n-    rel_canonical_path.iterate ([&] (const CanonicalPath &seg) -> bool {\n-      resolved_node = UNKNOWN_NODEID;\n-\n-      if (!resolver->get_type_scope ().lookup (seg, &resolved_node))\n-\treturn false;\n-\n-      resolver->insert_resolved_type (seg.get_node_id (), resolved_node);\n-      resolver->insert_new_definition (seg.get_node_id (),\n-\t\t\t\t       Definition{path.get_node_id (), parent});\n-      nprocessed++;\n-      return true;\n-    });\n-\n-    if (nprocessed == 0)\n+    if (ResolveRelativeTypePath::go (path, resolved_node))\n       {\n-\trust_error_at (path.get_locus (), \"failed to resolve TypePath: %s\",\n-\t\t       path.as_string ().c_str ());\n-\treturn;\n-      }\n-\n-    // its ok if this fails since the type resolver sometimes will need to\n-    // investigate the bounds of a type for the associated type for example see:\n-    // https://github.com/Rust-GCC/gccrs/issues/746\n-    if (nprocessed == rel_canonical_path.size ())\n-      {\n-\tresolver->insert_resolved_type (path.get_node_id (), resolved_node);\n-\tresolver->insert_new_definition (path.get_node_id (),\n-\t\t\t\t\t Definition{path.get_node_id (),\n-\t\t\t\t\t\t    parent});\n+\tif (canonical_path == nullptr)\n+\t  return;\n \n-\tif (canonical_path != nullptr)\n+\tconst CanonicalPath *type_path = nullptr;\n+\tif (mappings->lookup_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t\t     resolved_node, &type_path))\n \t  {\n-\t    const CanonicalPath *cpath = nullptr;\n-\t    bool ok\n-\t      = mappings->lookup_canonical_path (mappings->get_current_crate (),\n-\t\t\t\t\t\t resolved_node, &cpath);\n-\t    rust_assert (ok);\n-\t    *canonical_path = *cpath;\n+\t    *canonical_path = *type_path;\n \t  }\n       }\n   }\n@@ -350,11 +277,10 @@ class ResolveType : public ResolverBase\n \t       CanonicalPath *canonical_path)\n     : ResolverBase (parent),\n       canonicalize_type_with_generics (canonicalize_type_with_generics),\n-      ok (false), canonical_path (canonical_path)\n+      canonical_path (canonical_path)\n   {}\n \n   bool canonicalize_type_with_generics;\n-  bool ok;\n   CanonicalPath *canonical_path;\n };\n "}, {"sha": "169237a598eee0d3643109b62492fc7d752f37f1", "filename": "gcc/rust/resolve/rust-ast-resolve.cc", "status": "modified", "additions": 22, "deletions": 12, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ca7362602d4e827ecbc39d5cfdf56df9044633b/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ca7362602d4e827ecbc39d5cfdf56df9044633b/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc?ref=7ca7362602d4e827ecbc39d5cfdf56df9044633b", "patch": "@@ -81,6 +81,11 @@ NameResolution::go (AST::Crate &crate)\n     = CanonicalPath::new_seg (scope_node_id, crate_name);\n   crate_prefix.set_crate_num (cnum);\n \n+  // setup a dummy crate node\n+  resolver->get_name_scope ().insert (\n+    CanonicalPath::new_seg (crate.get_node_id (), \"__$$crate__\"),\n+    crate.get_node_id (), Location ());\n+\n   // setup the root scope\n   resolver->push_new_module_scope (scope_node_id);\n \n@@ -167,19 +172,21 @@ ResolveRelativeTypePath::resolve_qual_seg (AST::QualifiedPathType &seg,\n \t\t     seg.as_string ().c_str ());\n       return false;\n     }\n-  bool include_generic_args_in_path = false;\n \n-  NodeId type_resolved_node\n-    = ResolveType::go (seg.get_type ().get (), seg.get_node_id ());\n+  auto type = seg.get_type ().get ();\n+  NodeId type_resolved_node = ResolveType::go (type, seg.get_node_id ());\n   if (type_resolved_node == UNKNOWN_NODEID)\n     return false;\n \n-  CanonicalPath impl_type_seg\n-    = ResolveTypeToCanonicalPath::resolve (*seg.get_type ().get (),\n-\t\t\t\t\t   include_generic_args_in_path);\n+  const CanonicalPath *impl_type_seg = nullptr;\n+  bool ok\n+    = mappings->lookup_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t       type_resolved_node, &impl_type_seg);\n+  rust_assert (ok);\n+\n   if (!seg.has_as_clause ())\n     {\n-      result = result.append (impl_type_seg);\n+      result = result.append (*impl_type_seg);\n       return true;\n     }\n \n@@ -188,12 +195,15 @@ ResolveRelativeTypePath::resolve_qual_seg (AST::QualifiedPathType &seg,\n   if (trait_resolved_node == UNKNOWN_NODEID)\n     return false;\n \n-  CanonicalPath trait_type_seg\n-    = ResolveTypeToCanonicalPath::resolve (seg.get_as_type_path (),\n-\t\t\t\t\t   include_generic_args_in_path);\n+  const CanonicalPath *trait_type_seg = nullptr;\n+  ok = mappings->lookup_canonical_path (mappings->get_current_crate (),\n+\t\t\t\t\ttrait_resolved_node, &trait_type_seg);\n+  rust_assert (ok);\n+\n   CanonicalPath projection\n-    = TraitImplProjection::resolve (seg.get_node_id (), trait_type_seg,\n-\t\t\t\t    impl_type_seg);\n+    = TraitImplProjection::resolve (seg.get_node_id (), *trait_type_seg,\n+\t\t\t\t    *impl_type_seg);\n+\n   result = result.append (projection);\n   return true;\n }"}, {"sha": "fcf71907166da70286e71088d56042eacbfe8c67", "filename": "gcc/rust/resolve/rust-name-resolver.cc", "status": "modified", "additions": 31, "deletions": 23, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ca7362602d4e827ecbc39d5cfdf56df9044633b/gcc%2Frust%2Fresolve%2Frust-name-resolver.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ca7362602d4e827ecbc39d5cfdf56df9044633b/gcc%2Frust%2Fresolve%2Frust-name-resolver.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-name-resolver.cc?ref=7ca7362602d4e827ecbc39d5cfdf56df9044633b", "patch": "@@ -34,6 +34,12 @@\n       _R.push_back (builtin_type);                                             \\\n       tyctx->insert_builtin (_TY->get_ref (), builtin_type->get_node_id (),    \\\n \t\t\t     _TY);                                             \\\n+      mappings->insert_node_to_hir (mappings->get_current_crate (),            \\\n+\t\t\t\t    builtin_type->get_node_id (),              \\\n+\t\t\t\t    _TY->get_ref ());                          \\\n+      mappings->insert_canonical_path (                                        \\\n+\tmappings->get_current_crate (), builtin_type->get_node_id (),          \\\n+\tCanonicalPath::new_seg (builtin_type->get_node_id (), _X));            \\\n     }                                                                          \\\n   while (0)\n \n@@ -165,6 +171,16 @@ Scope::iterate (std::function<bool (Rib *)> cb)\n     }\n }\n \n+void\n+Scope::iterate (std::function<bool (const Rib *)> cb) const\n+{\n+  for (auto it = stack.rbegin (); it != stack.rend (); ++it)\n+    {\n+      if (!cb (*it))\n+\treturn;\n+    }\n+}\n+\n Rib *\n Scope::peek ()\n {\n@@ -200,6 +216,21 @@ Scope::append_reference_for_def (NodeId refId, NodeId defId)\n   rust_assert (ok);\n }\n \n+bool\n+Scope::decl_was_declared_here (NodeId def) const\n+{\n+  bool found = false;\n+  iterate ([&] (const Rib *r) -> bool {\n+    if (r->decl_was_declared_here (def))\n+      {\n+\tfound = true;\n+\treturn false;\n+      }\n+    return true;\n+  });\n+  return found;\n+}\n+\n Resolver::Resolver ()\n   : mappings (Analysis::Mappings::get ()), tyctx (TypeCheckContext::get ()),\n     name_scope (Scope (mappings->get_current_crate ())),\n@@ -370,29 +401,6 @@ Resolver::generate_builtins ()\n   set_unit_type_node_id (unit_type->get_node_id ());\n }\n \n-void\n-Resolver::insert_new_definition (NodeId id, Definition def)\n-{\n-  auto it = name_definitions.find (id);\n-  if (it != name_definitions.end ())\n-    {\n-      rust_assert (it->second.is_equal (def));\n-      return;\n-    }\n-  name_definitions[id] = def;\n-}\n-\n-bool\n-Resolver::lookup_definition (NodeId id, Definition *def)\n-{\n-  auto it = name_definitions.find (id);\n-  if (it == name_definitions.end ())\n-    return false;\n-\n-  *def = it->second;\n-  return true;\n-}\n-\n void\n Resolver::insert_resolved_name (NodeId refId, NodeId defId)\n {"}, {"sha": "6b611b289773200bc8f502fe972aabd8fb246857", "filename": "gcc/rust/resolve/rust-name-resolver.h", "status": "modified", "additions": 14, "deletions": 33, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ca7362602d4e827ecbc39d5cfdf56df9044633b/gcc%2Frust%2Fresolve%2Frust-name-resolver.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ca7362602d4e827ecbc39d5cfdf56df9044633b/gcc%2Frust%2Fresolve%2Frust-name-resolver.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-name-resolver.h?ref=7ca7362602d4e827ecbc39d5cfdf56df9044633b", "patch": "@@ -73,11 +73,13 @@ class Scope\n   bool lookup (const CanonicalPath &ident, NodeId *id);\n \n   void iterate (std::function<bool (Rib *)> cb);\n+  void iterate (std::function<bool (const Rib *)> cb) const;\n \n   Rib *peek ();\n   void push (NodeId id);\n   Rib *pop ();\n \n+  bool decl_was_declared_here (NodeId def) const;\n   void append_reference_for_def (NodeId refId, NodeId defId);\n \n   CrateNum get_crate_num () const { return crate_num; }\n@@ -87,32 +89,6 @@ class Scope\n   std::vector<Rib *> stack;\n };\n \n-// This can map simple NodeIds for names to their parent node\n-// for example:\n-//\n-// var x = y + 1;\n-//\n-// say y has node id=1 and the plus_expression has id=2\n-// then the Definition will have\n-// Definition { node=1, parent=2 }\n-// this will be used later to gather the ribs for the type inferences context\n-//\n-// if parent is UNKNOWN_NODEID then this is a root declaration\n-// say the var_decl hasa node_id=4;\n-// the parent could be a BLOCK_Expr node_id but lets make it UNKNOWN_NODE_ID\n-// so we know when it terminates\n-struct Definition\n-{\n-  NodeId node;\n-  NodeId parent;\n-  // add kind ?\n-\n-  bool is_equal (const Definition &other)\n-  {\n-    return node == other.node && parent == other.parent;\n-  }\n-};\n-\n class Resolver\n {\n public:\n@@ -136,9 +112,6 @@ class Resolver\n   bool find_label_rib (NodeId id, Rib **rib);\n   bool find_macro_rib (NodeId id, Rib **rib);\n \n-  void insert_new_definition (NodeId id, Definition def);\n-  bool lookup_definition (NodeId id, Definition *def);\n-\n   void insert_resolved_name (NodeId refId, NodeId defId);\n   bool lookup_resolved_name (NodeId refId, NodeId *defId);\n \n@@ -183,6 +156,18 @@ class Resolver\n     return current_module_stack.back ();\n   }\n \n+  NodeId peek_crate_module_scope () const\n+  {\n+    rust_assert (!current_module_stack.empty ());\n+    return current_module_stack.front ();\n+  }\n+\n+  NodeId peek_parent_module_scope () const\n+  {\n+    rust_assert (current_module_stack.size () > 1);\n+    return current_module_stack.at (current_module_stack.size () - 2);\n+  }\n+\n private:\n   Resolver ();\n \n@@ -207,10 +192,6 @@ class Resolver\n   std::map<NodeId, Rib *> label_ribs;\n   std::map<NodeId, Rib *> macro_ribs;\n \n-  // map any Node to its Definition\n-  // ie any name or type usage\n-  std::map<NodeId, Definition> name_definitions;\n-\n   // Rust uses DefIds to namespace these under a crate_num\n   // but then it uses the def_collector to assign local_defids\n   // to each ast node as well. not sure if this is going to fit"}, {"sha": "57063753c248bef2800272b4db9bb8189d5241a8", "filename": "gcc/rust/rust-session-manager.cc", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ca7362602d4e827ecbc39d5cfdf56df9044633b/gcc%2Frust%2Frust-session-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ca7362602d4e827ecbc39d5cfdf56df9044633b/gcc%2Frust%2Frust-session-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-session-manager.cc?ref=7ca7362602d4e827ecbc39d5cfdf56df9044633b", "patch": "@@ -737,6 +737,9 @@ Session::parse_file (const char *filename)\n   if (saw_errors ())\n     return;\n \n+  // add the mappings to it\n+  mappings->insert_hir_crate (&hir);\n+\n   // type resolve\n   Resolver::TypeResolution::Resolve (hir);\n   if (options.dump_option_enabled (CompileOptions::TYPE_RESOLUTION_DUMP))"}, {"sha": "e84f5e899e38b25e921e8d412650ebd05a314f90", "filename": "gcc/rust/typecheck/rust-hir-type-check-expr.h", "status": "modified", "additions": 3, "deletions": 24, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ca7362602d4e827ecbc39d5cfdf56df9044633b/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ca7362602d4e827ecbc39d5cfdf56df9044633b/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h?ref=7ca7362602d4e827ecbc39d5cfdf56df9044633b", "patch": "@@ -423,35 +423,14 @@ class TypeCheckExpr : public TypeCheckBase\n \n     // then lookup the reference_node_id\n     NodeId ref_node_id = UNKNOWN_NODEID;\n-    if (resolver->lookup_resolved_name (ast_node_id, &ref_node_id))\n+    if (!resolver->lookup_resolved_name (ast_node_id, &ref_node_id))\n       {\n-\t// these ref_node_ids will resolve to a pattern declaration but we are\n-\t// interested in the definition that this refers to get the parent id\n-\tDefinition def;\n-\tif (!resolver->lookup_definition (ref_node_id, &def))\n-\t  {\n-\t    // FIXME\n-\t    // this is an internal error\n-\t    rust_error_at (expr.get_locus (),\n-\t\t\t   \"unknown reference for resolved name\");\n-\t    return;\n-\t  }\n-\tref_node_id = def.parent;\n-      }\n-    else if (!resolver->lookup_resolved_type (ast_node_id, &ref_node_id))\n-      {\n-\t// FIXME\n-\t// this is an internal error\n-\trust_error_at (expr.get_locus (),\n-\t\t       \"Failed to lookup type reference for node: %s\",\n-\t\t       expr.as_string ().c_str ());\n-\treturn;\n+\tresolver->lookup_resolved_type (ast_node_id, &ref_node_id);\n       }\n \n     if (ref_node_id == UNKNOWN_NODEID)\n       {\n-\t// FIXME\n-\t// this is an internal error\n+\t// FIXME this needs to go away and just return error node\n \trust_error_at (expr.get_locus (), \"unresolved node: %s\",\n \t\t       expr.as_string ().c_str ());\n \treturn;"}, {"sha": "a05961165715c1e078906213920865f8fb24f808", "filename": "gcc/rust/typecheck/rust-hir-type-check-path.cc", "status": "modified", "additions": 88, "deletions": 59, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ca7362602d4e827ecbc39d5cfdf56df9044633b/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ca7362602d4e827ecbc39d5cfdf56df9044633b/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-path.cc?ref=7ca7362602d4e827ecbc39d5cfdf56df9044633b", "patch": "@@ -67,6 +67,36 @@ TypeCheckExpr::visit (HIR::QualifiedPathInExpression &expr)\n   // inherit the bound\n   root->inherit_bounds ({specified_bound});\n \n+  // setup the associated types\n+  const TraitReference *specified_bound_ref = specified_bound.get ();\n+  auto candidates = TypeBoundsProbe::Probe (root);\n+  AssociatedImplTrait *associated_impl_trait = nullptr;\n+  for (auto &probed_bound : candidates)\n+    {\n+      const TraitReference *bound_trait_ref = probed_bound.first;\n+      const HIR::ImplBlock *associated_impl = probed_bound.second;\n+\n+      HirId impl_block_id = associated_impl->get_mappings ().get_hirid ();\n+      AssociatedImplTrait *associated = nullptr;\n+      bool found_impl_trait\n+\t= context->lookup_associated_trait_impl (impl_block_id, &associated);\n+      if (found_impl_trait)\n+\t{\n+\t  bool found_trait = specified_bound_ref->is_equal (*bound_trait_ref);\n+\t  bool found_self = associated->get_self ()->can_eq (root, false);\n+\t  if (found_trait && found_self)\n+\t    {\n+\t      associated_impl_trait = associated;\n+\t      break;\n+\t    }\n+\t}\n+    }\n+\n+  if (associated_impl_trait != nullptr)\n+    {\n+      associated_impl_trait->setup_associated_types (root, specified_bound);\n+    }\n+\n   // lookup the associated item from the specified bound\n   HIR::PathExprSegment &item_seg = expr.get_segments ().at (0);\n   HIR::PathIdentSegment item_seg_identifier = item_seg.get_segment ();\n@@ -81,28 +111,6 @@ TypeCheckExpr::visit (HIR::QualifiedPathInExpression &expr)\n   // infer the root type\n   infered = item.get_tyty_for_receiver (root);\n \n-  // we need resolve to the impl block\n-  NodeId impl_resolved_id = UNKNOWN_NODEID;\n-  bool have_associated_impl = resolver->lookup_resolved_name (\n-    qual_path_type.get_mappings ().get_nodeid (), &impl_resolved_id);\n-  AssociatedImplTrait *lookup_associated = nullptr;\n-  if (have_associated_impl)\n-    {\n-      HirId impl_block_id;\n-      bool ok\n-\t= mappings->lookup_node_to_hir (expr.get_mappings ().get_crate_num (),\n-\t\t\t\t\timpl_resolved_id, &impl_block_id);\n-      rust_assert (ok);\n-\n-      bool found_impl_trait\n-\t= context->lookup_associated_trait_impl (impl_block_id,\n-\t\t\t\t\t\t &lookup_associated);\n-      if (found_impl_trait)\n-\t{\n-\t  lookup_associated->setup_associated_types (root, specified_bound);\n-\t}\n-    }\n-\n   // turbo-fish segment path::<ty>\n   if (item_seg.has_generic_args ())\n     {\n@@ -145,7 +153,9 @@ TypeCheckExpr::visit (HIR::PathInExpression &expr)\n     return;\n \n   if (tyseg->needs_generic_substitutions ())\n-    tyseg = SubstMapper::InferSubst (tyseg, expr.get_locus ());\n+    {\n+      tyseg = SubstMapper::InferSubst (tyseg, expr.get_locus ());\n+    }\n \n   bool fully_resolved = offset == expr.get_segments ().size ();\n   if (fully_resolved)\n@@ -162,37 +172,32 @@ TyTy::BaseType *\n TypeCheckExpr::resolve_root_path (HIR::PathInExpression &expr, size_t *offset,\n \t\t\t\t  NodeId *root_resolved_node_id)\n {\n+  TyTy::BaseType *root_tyty = nullptr;\n   *offset = 0;\n   for (size_t i = 0; i < expr.get_num_segments (); i++)\n     {\n       HIR::PathExprSegment &seg = expr.get_segments ().at (i);\n+\n       bool have_more_segments = (expr.get_num_segments () - 1 != i);\n+      bool is_root = *offset == 0;\n       NodeId ast_node_id = seg.get_mappings ().get_nodeid ();\n \n       // then lookup the reference_node_id\n       NodeId ref_node_id = UNKNOWN_NODEID;\n-      if (resolver->lookup_resolved_name (ast_node_id, &ref_node_id))\n-\t{\n-\t  // these ref_node_ids will resolve to a pattern declaration but we\n-\t  // are interested in the definition that this refers to get the\n-\t  // parent id\n-\t  Definition def;\n-\t  if (!resolver->lookup_definition (ref_node_id, &def))\n-\t    {\n-\t      rust_error_at (expr.get_locus (),\n-\t\t\t     \"unknown reference for resolved name\");\n-\t      return new TyTy::ErrorType (expr.get_mappings ().get_hirid ());\n-\t    }\n-\t  ref_node_id = def.parent;\n-\t}\n-      else\n+      if (!resolver->lookup_resolved_name (ast_node_id, &ref_node_id))\n \t{\n \t  resolver->lookup_resolved_type (ast_node_id, &ref_node_id);\n \t}\n \n       // ref_node_id is the NodeId that the segments refers to.\n       if (ref_node_id == UNKNOWN_NODEID)\n \t{\n+\t  if (root_tyty != nullptr && *offset > 0)\n+\t    {\n+\t      // then we can let the impl path probe take over now\n+\t      return root_tyty;\n+\t    }\n+\n \t  rust_error_at (seg.get_locus (),\n \t\t\t \"failed to type resolve root segment\");\n \t  return new TyTy::ErrorType (expr.get_mappings ().get_hirid ());\n@@ -217,7 +222,8 @@ TypeCheckExpr::resolve_root_path (HIR::PathInExpression &expr, size_t *offset,\n \t= (nullptr\n \t   != mappings->lookup_module (expr.get_mappings ().get_crate_num (),\n \t\t\t\t       ref));\n-      if (seg_is_module)\n+      auto seg_is_crate = mappings->is_local_hirid_crate (ref);\n+      if (seg_is_module || seg_is_crate)\n \t{\n \t  // A::B::C::this_is_a_module::D::E::F\n \t  //          ^^^^^^^^^^^^^^^^\n@@ -239,30 +245,58 @@ TypeCheckExpr::resolve_root_path (HIR::PathInExpression &expr, size_t *offset,\n       TyTy::BaseType *lookup = nullptr;\n       if (!context->lookup_type (ref, &lookup))\n \t{\n-\t  rust_error_at (seg.get_locus (), \"failed to resolve root segment\");\n-\t  return new TyTy::ErrorType (expr.get_mappings ().get_hirid ());\n+\t  if (is_root)\n+\t    {\n+\t      rust_error_at (seg.get_locus (),\n+\t\t\t     \"failed to resolve root segment\");\n+\t      return new TyTy::ErrorType (expr.get_mappings ().get_hirid ());\n+\t    }\n+\t  return root_tyty;\n+\t}\n+\n+      // if we have a previous segment type\n+      if (root_tyty != nullptr)\n+\t{\n+\t  // if this next segment needs substitution we must apply the\n+\t  // previous type arguments\n+\t  //\n+\t  // such as: GenericStruct::<_>::new(123, 456)\n+\t  if (lookup->needs_generic_substitutions ())\n+\t    {\n+\t      if (!root_tyty->needs_generic_substitutions ())\n+\t\t{\n+\t\t  auto used_args_in_prev_segment\n+\t\t    = GetUsedSubstArgs::From (root_tyty);\n+\t\t  lookup\n+\t\t    = SubstMapperInternal::Resolve (lookup,\n+\t\t\t\t\t\t    used_args_in_prev_segment);\n+\t\t}\n+\t    }\n \t}\n \n       // turbo-fish segment path::<ty>\n       if (seg.has_generic_args ())\n \t{\n \t  if (!lookup->can_substitute ())\n \t    {\n-\t      rust_error_at (seg.get_locus (),\n+\t      rust_error_at (expr.get_locus (),\n \t\t\t     \"substitutions not supported for %s\",\n-\t\t\t     lookup->as_string ().c_str ());\n-\t      return new TyTy::ErrorType (lookup->get_ref ());\n+\t\t\t     root_tyty->as_string ().c_str ());\n+\t      return new TyTy::ErrorType (expr.get_mappings ().get_hirid ());\n \t    }\n-\t  lookup = SubstMapper::Resolve (lookup, seg.get_locus (),\n+\n+\t  lookup = SubstMapper::Resolve (lookup, expr.get_locus (),\n \t\t\t\t\t &seg.get_generic_args ());\n+\t  if (lookup->get_kind () == TyTy::TypeKind::ERROR)\n+\t    return new TyTy::ErrorType (expr.get_mappings ().get_hirid ());\n \t}\n \n       *root_resolved_node_id = ref_node_id;\n       *offset = *offset + 1;\n-      return lookup;\n+      root_tyty = lookup;\n     }\n \n-  return new TyTy::ErrorType (expr.get_mappings ().get_hirid ());\n+  return root_tyty;\n }\n \n void\n@@ -423,22 +457,17 @@ TypeCheckExpr::resolve_segments (NodeId root_resolved_node_id,\n \n   context->insert_receiver (expr_mappings.get_hirid (), prev_segment);\n \n-  // lookup if the name resolver was able to canonically resolve this or not\n-  NodeId path_resolved_id = UNKNOWN_NODEID;\n-  if (resolver->lookup_resolved_name (expr_mappings.get_nodeid (),\n-\t\t\t\t      &path_resolved_id))\n+  // name scope first\n+  if (resolver->get_name_scope ().decl_was_declared_here (resolved_node_id))\n     {\n-      rust_assert (path_resolved_id == resolved_node_id);\n+      resolver->insert_resolved_name (expr_mappings.get_nodeid (),\n+\t\t\t\t      resolved_node_id);\n     }\n   // check the type scope\n-  else if (resolver->lookup_resolved_type (expr_mappings.get_nodeid (),\n-\t\t\t\t\t   &path_resolved_id))\n+  else if (resolver->get_type_scope ().decl_was_declared_here (\n+\t     resolved_node_id))\n     {\n-      rust_assert (path_resolved_id == resolved_node_id);\n-    }\n-  else\n-    {\n-      resolver->insert_resolved_name (expr_mappings.get_nodeid (),\n+      resolver->insert_resolved_type (expr_mappings.get_nodeid (),\n \t\t\t\t      resolved_node_id);\n     }\n "}, {"sha": "1018f816ecb748866dc638da7f41c7d359caab8a", "filename": "gcc/rust/typecheck/rust-hir-type-check-pattern.cc", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ca7362602d4e827ecbc39d5cfdf56df9044633b/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-pattern.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ca7362602d4e827ecbc39d5cfdf56df9044633b/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-pattern.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-pattern.cc?ref=7ca7362602d4e827ecbc39d5cfdf56df9044633b", "patch": "@@ -350,5 +350,11 @@ TypeCheckPattern::visit (HIR::RangePattern &pattern)\n   infered = upper->unify (lower);\n }\n \n+void\n+TypeCheckPattern::visit (HIR::IdentifierPattern &pattern)\n+{\n+  infered = parent;\n+}\n+\n } // namespace Resolver\n } // namespace Rust"}, {"sha": "860aca9207f68c1e0063ff697ef83c4c1892c12d", "filename": "gcc/rust/typecheck/rust-hir-type-check-pattern.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ca7362602d4e827ecbc39d5cfdf56df9044633b/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-pattern.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ca7362602d4e827ecbc39d5cfdf56df9044633b/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-pattern.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-pattern.h?ref=7ca7362602d4e827ecbc39d5cfdf56df9044633b", "patch": "@@ -58,6 +58,8 @@ class TypeCheckPattern : public TypeCheckBase\n \n   void visit (HIR::RangePattern &pattern) override;\n \n+  void visit (HIR::IdentifierPattern &pattern) override;\n+\n private:\n   TypeCheckPattern (TyTy::BaseType *parent)\n     : TypeCheckBase (), parent (parent), infered (nullptr)"}, {"sha": "96e92b4458f7b87ef88be6e74865fb2863629fd7", "filename": "gcc/rust/typecheck/rust-hir-type-check-stmt.h", "status": "modified", "additions": 15, "deletions": 19, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ca7362602d4e827ecbc39d5cfdf56df9044633b/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ca7362602d4e827ecbc39d5cfdf56df9044633b/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-stmt.h?ref=7ca7362602d4e827ecbc39d5cfdf56df9044633b", "patch": "@@ -79,17 +79,16 @@ class TypeCheckStmt : public TypeCheckBase\n     infered\n       = TyTy::TupleType::get_unit_type (stmt.get_mappings ().get_hirid ());\n \n+    const HIR::Pattern &stmt_pattern = *stmt.get_pattern ();\n     TyTy::BaseType *init_expr_ty = nullptr;\n     if (stmt.has_init_expr ())\n       {\n \tinit_expr_ty = TypeCheckExpr::Resolve (stmt.get_init_expr ());\n \tif (init_expr_ty->get_kind () == TyTy::TypeKind::ERROR)\n \t  return;\n \n-\tinit_expr_ty = init_expr_ty->clone ();\n-\tauto ref = init_expr_ty->get_ref ();\n-\tinit_expr_ty->set_ref (stmt.get_mappings ().get_hirid ());\n-\tinit_expr_ty->append_reference (ref);\n+\tinit_expr_ty->append_reference (\n+\t  stmt_pattern.get_pattern_mappings ().get_hirid ());\n       }\n \n     TyTy::BaseType *specified_ty = nullptr;\n@@ -99,38 +98,35 @@ class TypeCheckStmt : public TypeCheckBase\n     // let x:i32 = 123;\n     if (specified_ty != nullptr && init_expr_ty != nullptr)\n       {\n-\tauto unified_ty = specified_ty->coerce (init_expr_ty);\n-\tif (unified_ty->get_kind () == TyTy::TypeKind::ERROR)\n-\t  return;\n-\n-\tcontext->insert_type (stmt.get_mappings (), specified_ty);\n+\t// FIXME use this result and look at the regressions\n+\tspecified_ty->coerce (init_expr_ty);\n+\tcontext->insert_type (stmt_pattern.get_pattern_mappings (),\n+\t\t\t      specified_ty);\n       }\n     else\n       {\n \t// let x:i32;\n \tif (specified_ty != nullptr)\n \t  {\n-\t    context->insert_type (stmt.get_mappings (), specified_ty);\n+\t    context->insert_type (stmt_pattern.get_pattern_mappings (),\n+\t\t\t\t  specified_ty);\n \t  }\n \t// let x = 123;\n \telse if (init_expr_ty != nullptr)\n \t  {\n-\t    context->insert_type (stmt.get_mappings (), init_expr_ty);\n+\t    context->insert_type (stmt_pattern.get_pattern_mappings (),\n+\t\t\t\t  init_expr_ty);\n \t  }\n \t// let x;\n \telse\n \t  {\n \t    context->insert_type (\n-\t      stmt.get_mappings (),\n-\t      new TyTy::InferType (stmt.get_mappings ().get_hirid (),\n-\t\t\t\t   TyTy::InferType::InferTypeKind::GENERAL,\n-\t\t\t\t   stmt.get_locus ()));\n+\t      stmt_pattern.get_pattern_mappings (),\n+\t      new TyTy::InferType (\n+\t\tstmt_pattern.get_pattern_mappings ().get_hirid (),\n+\t\tTyTy::InferType::InferTypeKind::GENERAL, stmt.get_locus ()));\n \t  }\n       }\n-\n-    TyTy::BaseType *lookup = nullptr;\n-    bool ok = context->lookup_type (stmt.get_mappings ().get_hirid (), &lookup);\n-    rust_assert (ok);\n   }\n \n   void visit (HIR::TupleStruct &struct_decl) override"}, {"sha": "a5597beb1859902c53113e2b3f98ff65c5e00f1d", "filename": "gcc/rust/typecheck/rust-hir-type-check-type.cc", "status": "modified", "additions": 49, "deletions": 43, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ca7362602d4e827ecbc39d5cfdf56df9044633b/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ca7362602d4e827ecbc39d5cfdf56df9044633b/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.cc?ref=7ca7362602d4e827ecbc39d5cfdf56df9044633b", "patch": "@@ -151,6 +151,36 @@ TypeCheckType::visit (HIR::QualifiedPathInType &path)\n   // inherit the bound\n   root->inherit_bounds ({specified_bound});\n \n+  // setup the associated types\n+  const TraitReference *specified_bound_ref = specified_bound.get ();\n+  auto candidates = TypeBoundsProbe::Probe (root);\n+  AssociatedImplTrait *associated_impl_trait = nullptr;\n+  for (auto &probed_bound : candidates)\n+    {\n+      const TraitReference *bound_trait_ref = probed_bound.first;\n+      const HIR::ImplBlock *associated_impl = probed_bound.second;\n+\n+      HirId impl_block_id = associated_impl->get_mappings ().get_hirid ();\n+      AssociatedImplTrait *associated = nullptr;\n+      bool found_impl_trait\n+\t= context->lookup_associated_trait_impl (impl_block_id, &associated);\n+      if (found_impl_trait)\n+\t{\n+\t  bool found_trait = specified_bound_ref->is_equal (*bound_trait_ref);\n+\t  bool found_self = associated->get_self ()->can_eq (root, false);\n+\t  if (found_trait && found_self)\n+\t    {\n+\t      associated_impl_trait = associated;\n+\t      break;\n+\t    }\n+\t}\n+    }\n+\n+  if (associated_impl_trait != nullptr)\n+    {\n+      associated_impl_trait->setup_associated_types (root, specified_bound);\n+    }\n+\n   // lookup the associated item from the specified bound\n   std::unique_ptr<HIR::TypePathSegment> &item_seg\n     = path.get_associated_segment ();\n@@ -166,28 +196,6 @@ TypeCheckType::visit (HIR::QualifiedPathInType &path)\n   // infer the root type\n   translated = item.get_tyty_for_receiver (root);\n \n-  // we need resolve to the impl block\n-  NodeId impl_resolved_id = UNKNOWN_NODEID;\n-  bool have_associated_impl = resolver->lookup_resolved_name (\n-    qual_path_type.get_mappings ().get_nodeid (), &impl_resolved_id);\n-  AssociatedImplTrait *lookup_associated = nullptr;\n-  if (have_associated_impl)\n-    {\n-      HirId impl_block_id;\n-      bool ok\n-\t= mappings->lookup_node_to_hir (path.get_mappings ().get_crate_num (),\n-\t\t\t\t\timpl_resolved_id, &impl_block_id);\n-      rust_assert (ok);\n-\n-      bool found_impl_trait\n-\t= context->lookup_associated_trait_impl (impl_block_id,\n-\t\t\t\t\t\t &lookup_associated);\n-      if (found_impl_trait)\n-\t{\n-\t  lookup_associated->setup_associated_types (root, specified_bound);\n-\t}\n-    }\n-\n   // turbo-fish segment path::<ty>\n   if (item_seg->get_type () == HIR::TypePathSegment::SegmentType::GENERIC)\n     {\n@@ -245,21 +253,7 @@ TypeCheckType::resolve_root_path (HIR::TypePath &path, size_t *offset,\n \n       // then lookup the reference_node_id\n       NodeId ref_node_id = UNKNOWN_NODEID;\n-      if (resolver->lookup_resolved_name (ast_node_id, &ref_node_id))\n-\t{\n-\t  // these ref_node_ids will resolve to a pattern declaration but we\n-\t  // are interested in the definition that this refers to get the\n-\t  // parent id\n-\t  Definition def;\n-\t  if (!resolver->lookup_definition (ref_node_id, &def))\n-\t    {\n-\t      rust_error_at (path.get_locus (),\n-\t\t\t     \"unknown reference for resolved name\");\n-\t      return new TyTy::ErrorType (path.get_mappings ().get_hirid ());\n-\t    }\n-\t  ref_node_id = def.parent;\n-\t}\n-      else\n+      if (!resolver->lookup_resolved_name (ast_node_id, &ref_node_id))\n \t{\n \t  resolver->lookup_resolved_type (ast_node_id, &ref_node_id);\n \t}\n@@ -270,14 +264,15 @@ TypeCheckType::resolve_root_path (HIR::TypePath &path, size_t *offset,\n \t  if (is_root)\n \t    {\n \t      rust_error_at (seg->get_locus (),\n-\t\t\t     \"failed to type resolve root segment\");\n+\t\t\t     \"unknown reference for resolved name: %<%s%>\",\n+\t\t\t     seg->get_ident_segment ().as_string ().c_str ());\n \t      return new TyTy::ErrorType (path.get_mappings ().get_hirid ());\n \t    }\n \t  return root_tyty;\n \t}\n \n       // node back to HIR\n-      HirId ref;\n+      HirId ref = UNKNOWN_HIRID;\n       if (!mappings->lookup_node_to_hir (path.get_mappings ().get_crate_num (),\n \t\t\t\t\t ref_node_id, &ref))\n \t{\n@@ -300,8 +295,8 @@ TypeCheckType::resolve_root_path (HIR::TypePath &path, size_t *offset,\n \t= (nullptr\n \t   != mappings->lookup_module (path.get_mappings ().get_crate_num (),\n \t\t\t\t       ref));\n-\n-      if (seg_is_module)\n+      auto seg_is_crate = mappings->is_local_hirid_crate (ref);\n+      if (seg_is_module || seg_is_crate)\n \t{\n \t  // A::B::C::this_is_a_module::D::E::F\n \t  //          ^^^^^^^^^^^^^^^^\n@@ -498,8 +493,19 @@ TypeCheckType::resolve_segments (\n     }\n   else\n     {\n-      resolver->insert_resolved_type (expr_mappings.get_nodeid (),\n-\t\t\t\t      resolved_node_id);\n+      // name scope first\n+      if (resolver->get_name_scope ().decl_was_declared_here (resolved_node_id))\n+\t{\n+\t  resolver->insert_resolved_name (expr_mappings.get_nodeid (),\n+\t\t\t\t\t  resolved_node_id);\n+\t}\n+      // check the type scope\n+      else if (resolver->get_type_scope ().decl_was_declared_here (\n+\t\t resolved_node_id))\n+\t{\n+\t  resolver->insert_resolved_type (expr_mappings.get_nodeid (),\n+\t\t\t\t\t  resolved_node_id);\n+\t}\n     }\n \n   return tyseg;"}, {"sha": "36963e5efa32beaa89871200300cf439096707d3", "filename": "gcc/rust/typecheck/rust-tycheck-dump.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ca7362602d4e827ecbc39d5cfdf56df9044633b/gcc%2Frust%2Ftypecheck%2Frust-tycheck-dump.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ca7362602d4e827ecbc39d5cfdf56df9044633b/gcc%2Frust%2Ftypecheck%2Frust-tycheck-dump.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tycheck-dump.h?ref=7ca7362602d4e827ecbc39d5cfdf56df9044633b", "patch": "@@ -128,7 +128,7 @@ class TypeResolverDump : public TypeCheckBase\n   void visit (HIR::LetStmt &stmt) override\n   {\n     dump += \"let \" + stmt.get_pattern ()->as_string () + \":\"\n-\t    + type_string (stmt.get_mappings ());\n+\t    + type_string (stmt.get_pattern ()->get_pattern_mappings ());\n     if (stmt.has_init_expr ())\n       {\n \tdump += \" = \";"}, {"sha": "c21b681f2f9ada9b2f715aa5a3be4daea1aced9e", "filename": "gcc/rust/util/rust-hir-map.cc", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ca7362602d4e827ecbc39d5cfdf56df9044633b/gcc%2Frust%2Futil%2Frust-hir-map.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ca7362602d4e827ecbc39d5cfdf56df9044633b/gcc%2Frust%2Futil%2Frust-hir-map.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Futil%2Frust-hir-map.cc?ref=7ca7362602d4e827ecbc39d5cfdf56df9044633b", "patch": "@@ -201,13 +201,28 @@ Mappings::get_hir_crate (CrateNum crateNum)\n   return it->second;\n }\n \n+bool\n+Mappings::is_local_hirid_crate (HirId crateNum)\n+{\n+  for (const auto &it : hirCrateMappings)\n+    {\n+      const HIR::Crate *crate = it.second;\n+      if (crate->get_mappings ().get_hirid () == crateNum)\n+\treturn true;\n+    }\n+  return false;\n+}\n+\n void\n Mappings::insert_hir_crate (HIR::Crate *crate)\n {\n   CrateNum crateNum = crate->get_mappings ().get_crate_num ();\n   rust_assert (get_hir_crate (crateNum) == nullptr);\n \n   hirCrateMappings[crateNum] = crate;\n+  insert_node_to_hir (crate->get_mappings ().get_crate_num (),\n+\t\t      crate->get_mappings ().get_nodeid (),\n+\t\t      crate->get_mappings ().get_hirid ());\n }\n \n void\n@@ -908,6 +923,25 @@ Mappings::lookup_module_chidren_items (NodeId module)\n   return Optional<std::vector<Resolver::CanonicalPath> &>::some (it->second);\n }\n \n+Optional<Resolver::CanonicalPath &>\n+Mappings::lookup_module_child (NodeId module, const std::string &item_name)\n+{\n+  Optional<std::vector<Resolver::CanonicalPath> &> children\n+    = lookup_module_chidren_items (module);\n+  if (children.is_none ())\n+    return Optional<Resolver::CanonicalPath &>::none ();\n+\n+  // lookup the children to match the name if we can\n+  for (auto &child : children.get ())\n+    {\n+      const std::string &raw_identifier = child.get ();\n+      bool found = raw_identifier.compare (item_name) == 0;\n+      if (found)\n+\treturn Optional<Resolver::CanonicalPath &>::some (child);\n+    }\n+  return Optional<Resolver::CanonicalPath &>::none ();\n+}\n+\n void\n Mappings::insert_child_item_to_parent_module_mapping (NodeId child_item,\n \t\t\t\t\t\t      NodeId parent_module)\n@@ -925,5 +959,11 @@ Mappings::lookup_parent_module (NodeId child_item)\n   return Optional<NodeId>::some (it->second);\n }\n \n+bool\n+Mappings::node_is_module (NodeId query)\n+{\n+  return module_child_items.find (query) != module_child_items.end ();\n+}\n+\n } // namespace Analysis\n } // namespace Rust"}, {"sha": "4360ae2e2a935964de46a995c46647369c73fbc5", "filename": "gcc/rust/util/rust-hir-map.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ca7362602d4e827ecbc39d5cfdf56df9044633b/gcc%2Frust%2Futil%2Frust-hir-map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ca7362602d4e827ecbc39d5cfdf56df9044633b/gcc%2Frust%2Futil%2Frust-hir-map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Futil%2Frust-hir-map.h?ref=7ca7362602d4e827ecbc39d5cfdf56df9044633b", "patch": "@@ -122,6 +122,7 @@ class Mappings\n   void insert_ast_crate (AST::Crate *crate);\n \n   HIR::Crate *get_hir_crate (CrateNum crateNum);\n+  bool is_local_hirid_crate (HirId crateNum);\n   void insert_hir_crate (HIR::Crate *crate);\n \n   void insert_defid_mapping (DefId id, HIR::Item *item);\n@@ -329,10 +330,13 @@ class Mappings\n   void insert_module_child_item (NodeId module, Resolver::CanonicalPath item);\n   Optional<std::vector<Resolver::CanonicalPath> &>\n   lookup_module_chidren_items (NodeId module);\n+  Optional<Resolver::CanonicalPath &>\n+  lookup_module_child (NodeId module, const std::string &item_name);\n \n   void insert_child_item_to_parent_module_mapping (NodeId child_item,\n \t\t\t\t\t\t   NodeId parent_module);\n   Optional<NodeId> lookup_parent_module (NodeId child_item);\n+  bool node_is_module (NodeId query);\n \n private:\n   Mappings ();"}, {"sha": "54011bd697626769f4943eb69ff52edee2e0e5fc", "filename": "gcc/testsuite/rust/compile/complex-path1.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ca7362602d4e827ecbc39d5cfdf56df9044633b/gcc%2Ftestsuite%2Frust%2Fcompile%2Fcomplex-path1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ca7362602d4e827ecbc39d5cfdf56df9044633b/gcc%2Ftestsuite%2Frust%2Fcompile%2Fcomplex-path1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fcomplex-path1.rs?ref=7ca7362602d4e827ecbc39d5cfdf56df9044633b", "patch": "@@ -0,0 +1,18 @@\n+// { dg-additional-options \"-w\" }\n+mod a {\n+    pub fn foo() {}\n+}\n+\n+mod b {\n+    pub fn foo() {\n+        super::a::foo();\n+    }\n+}\n+\n+mod foo {\n+    pub struct bar(pub i32);\n+}\n+\n+fn test() -> crate::foo::bar {\n+    foo::bar(123)\n+}"}, {"sha": "b16e1e0b0d90eb780dbf03e7515f99c2e035e4dc", "filename": "gcc/testsuite/rust/compile/issue-1251.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7ca7362602d4e827ecbc39d5cfdf56df9044633b/gcc%2Ftestsuite%2Frust%2Fcompile%2Fissue-1251.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7ca7362602d4e827ecbc39d5cfdf56df9044633b/gcc%2Ftestsuite%2Frust%2Fcompile%2Fissue-1251.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fissue-1251.rs?ref=7ca7362602d4e827ecbc39d5cfdf56df9044633b", "patch": "@@ -0,0 +1,14 @@\n+// { dg-additional-options \"-w\" }\n+mod a {\n+    pub mod b {\n+        pub mod a {\n+            pub fn foo() {}\n+        }\n+    }\n+\n+    pub fn bidule() {\n+        crate::a::b::a::foo()\n+    }\n+}\n+\n+fn main() {}"}]}