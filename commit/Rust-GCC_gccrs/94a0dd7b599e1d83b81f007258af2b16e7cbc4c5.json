{"sha": "94a0dd7b599e1d83b81f007258af2b16e7cbc4c5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTRhMGRkN2I1OTllMWQ4M2I4MWYwMDcyNThhZjJiMTZlN2NiYzRjNQ==", "commit": {"author": {"name": "Sandra Loosemore", "email": "sandra@codesourcery.com", "date": "2007-02-28T19:21:20Z"}, "committer": {"name": "Sandra Loosemore", "email": "sandra@gcc.gnu.org", "date": "2007-02-28T19:21:20Z"}, "message": "builtins.c (fold_builtin_call_list, [...]): Delete, and replace with...\n\n2007-02-28  Sandra Loosemore  <sandra@codesourcery.com>\n\n\t* gcc/builtins.c (fold_builtin_call_list, fold_builtin_call_valist):\n\tDelete, and replace with...\n\t(fold_builtin_call_array): This.  Update callers to use it.\n\t* gcc/fold-const.c (fold_build_call_list): Delete, and replace with...\n\t(fold_build_call_array): This.\n\t(fold_build_call_list_initializer): Delete, and replace with...\n\t(fold_build_call_array_initializer): This.\n\t* gcc/tree.h: Update declarations to reflect above changes.\n\n\t* gcc/c-typeck.c (build_function_call): Store converted arguments\n\tin a stack-allocated array instead of building a list.\n\t(convert_arguments): Store arguments in the array passed in as an\n\targument, and return the actual number of arguments.\n\t* gcc/c-format.c: (check_function_format): Pass arguments in an\n\tarray instead of a list.\n\t* gcc/c-common.c (check_function_nonnull): Likewise.\n\t(check_function_sentinel): Likewise.\n\t(check_function_arguments): Likewise.\n\t* gcc/c-common.h: Update declarations to reflect above changes.\n\n\t* gcc/cp/typeck.c (build_function_call): Store converted arguments\n\tin a stack-allocated array instead of building a list.\n\t(convert_arguments): Store arguments in the array passed in as an\n\targument, and return the actual number of arguments.\n\t* gcc/cp/call.c (build_call): Delete, and replace with...\n\t(build_call_n, build_call_a): New.\n\t(build_op_delete_call): Rewrite to avoid constructing argument lists.\n\t(build_over_call): Store converted arguments in a stack-allocated\n\tarray instead of building a list.\n\t(build_cxx_call): Pass arguments in an array instead of as a list.\n\t(build_java_interface_fn_ref): Rewrite to avoid constructing\n\targument lists.\n\t* gcc/cp/tree.h: Update declarations to reflect above changes.\n\t* gcc/cp/method.c (use_thunk): Use a stack-allocated array to hold\n\tthe arguments instead of a list.\n\t* gcc/cp/rtti.c (throw_bad_cast): Update call to cxx_call.\n\t(throw_bad_typeid): Likewise.\n\t(build_dynamic_cast_1): Likewise.\n\t* gcc/cp/init.c (build_builtin_delete_call): Use build_call_n.\n\t* gcc/cp/decl.c (expand_static_init): Likewise.\n\t* gcc/cp/except.c (cp_protect_cleanup_actions): Likewise.\n\t* gcc/cp/cp-gimplify.c (genericize_eh_spec_block): Likewise.\n\t(gimplify_must_not_throw_expr): Likewise.\n\t(cxx_omp_apply_fn): Use build_call_a.\n\nFrom-SVN: r122411", "tree": {"sha": "34dad42b40269284ec633fd80ce8a06342ba7ea3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/34dad42b40269284ec633fd80ce8a06342ba7ea3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/94a0dd7b599e1d83b81f007258af2b16e7cbc4c5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/94a0dd7b599e1d83b81f007258af2b16e7cbc4c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/94a0dd7b599e1d83b81f007258af2b16e7cbc4c5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/94a0dd7b599e1d83b81f007258af2b16e7cbc4c5/comments", "author": {"login": "SandraLoosemore", "id": 104087111, "node_id": "U_kgDOBjQ-Rw", "avatar_url": "https://avatars.githubusercontent.com/u/104087111?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SandraLoosemore", "html_url": "https://github.com/SandraLoosemore", "followers_url": "https://api.github.com/users/SandraLoosemore/followers", "following_url": "https://api.github.com/users/SandraLoosemore/following{/other_user}", "gists_url": "https://api.github.com/users/SandraLoosemore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SandraLoosemore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SandraLoosemore/subscriptions", "organizations_url": "https://api.github.com/users/SandraLoosemore/orgs", "repos_url": "https://api.github.com/users/SandraLoosemore/repos", "events_url": "https://api.github.com/users/SandraLoosemore/events{/privacy}", "received_events_url": "https://api.github.com/users/SandraLoosemore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "76bf4853ce24034b8489b3b5ba56d1de50203ea5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76bf4853ce24034b8489b3b5ba56d1de50203ea5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/76bf4853ce24034b8489b3b5ba56d1de50203ea5"}], "stats": {"total": 736, "additions": 398, "deletions": 338}, "files": [{"sha": "2974266dc25bdfef5a2437287aadf78f1c86e16d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94a0dd7b599e1d83b81f007258af2b16e7cbc4c5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94a0dd7b599e1d83b81f007258af2b16e7cbc4c5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=94a0dd7b599e1d83b81f007258af2b16e7cbc4c5", "patch": "@@ -1,3 +1,25 @@\n+2007-02-28  Sandra Loosemore  <sandra@codesourcery.com>\n+\n+\t* builtins.c (fold_builtin_call_list, fold_builtin_call_valist):\n+\tDelete, and replace with...\n+\t(fold_builtin_call_array): This.  Update callers to use it.\n+\t* fold-const.c (fold_build_call_list): Delete, and replace with...\n+\t(fold_build_call_array): This.\n+\t(fold_build_call_list_initializer): Delete, and replace with...\n+\t(fold_build_call_array_initializer): This.\n+\t* tree.h: Update declarations to reflect above changes.\n+\n+\t* c-typeck.c (build_function_call): Store converted arguments\n+\tin a stack-allocated array instead of building a list.\n+\t(convert_arguments): Store arguments in the array passed in as an\n+\targument, and return the actual number of arguments.\n+\t* c-format.c: (check_function_format): Pass arguments in an\n+\tarray instead of a list.\n+\t* c-common.c (check_function_nonnull): Likewise.\n+\t(check_function_sentinel): Likewise.\n+\t(check_function_arguments): Likewise.\n+\t* c-common.h: Update declarations to reflect above changes.\n+\n 2007-02-28  Jan Hubicka  <jh@suse.cz>\n \n \t* predict.def (PRED_TREE_EARLY_RETURN, PRED_CONST_RETURN,"}, {"sha": "676b9caba663da58246480cf2c9303013b000dc8", "filename": "gcc/builtins.c", "status": "modified", "additions": 22, "deletions": 76, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94a0dd7b599e1d83b81f007258af2b16e7cbc4c5/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94a0dd7b599e1d83b81f007258af2b16e7cbc4c5/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=94a0dd7b599e1d83b81f007258af2b16e7cbc4c5", "patch": "@@ -10124,56 +10124,13 @@ build_function_call_expr (tree fndecl, tree arglist)\n {\n   tree fntype = TREE_TYPE (fndecl);\n   tree fn = build1 (ADDR_EXPR, build_pointer_type (fntype), fndecl);\n-  return fold_builtin_call_list (TREE_TYPE (fntype), fn, arglist);\n-}\n-\n-/* Construct a CALL_EXPR with type TYPE with FN as the function expression.\n-   ARGLIST is a TREE_LIST of arguments.  */\n-\n-tree\n-fold_builtin_call_list (tree type, tree fn, tree arglist)\n-{\n-  tree ret = NULL_TREE;\n-  if (TREE_CODE (fn) == ADDR_EXPR)\n-    {\n-      tree fndecl = TREE_OPERAND (fn, 0);\n-      if (TREE_CODE (fndecl) == FUNCTION_DECL\n-\t  && DECL_BUILT_IN (fndecl))\n-\t{\n-\t  /* FIXME: Don't use a list in this interface.  */\n-\t  if (DECL_BUILT_IN_CLASS (fndecl) == BUILT_IN_MD)\n-\t    {\n-\t      ret = targetm.fold_builtin (fndecl, arglist, false);\n-\t      if (ret)\n-\t\treturn ret;\n-\t    }\n-\t  else\n-\t    {\n-\t      tree tail = arglist;\n-\t      tree args[MAX_ARGS_TO_FOLD_BUILTIN];\n-\t      int nargs;\n-\t      tree exp;\n-\n-\t      for (nargs = 0; nargs < MAX_ARGS_TO_FOLD_BUILTIN; nargs++)\n-\t\t{\n-\t\t  if (!tail)\n-\t\t    break;\n-\t\t  args[nargs] = TREE_VALUE (tail);\n-\t\t  tail = TREE_CHAIN (tail);\n-\t\t}\n-\t      if (nargs <= MAX_ARGS_TO_FOLD_BUILTIN)\n-\t\t{\n-\t\t  ret = fold_builtin_n (fndecl, args, nargs, false);\n-\t\t  if (ret)\n-\t\t    return ret;\n-\t\t}\n-\t      exp = build_call_list (type, fn, arglist);\n-\t      ret = fold_builtin_varargs (fndecl, exp, false);\n-\t      return ret ? ret : exp;\n-\t    }\n-\t}\n-    }\n-  return build_call_list (type, fn, arglist);\n+  int n = list_length (arglist);\n+  tree *argarray = (tree *) alloca (n * sizeof (tree));\n+  int i;\n+  \n+  for (i = 0; i < n; i++, arglist = TREE_CHAIN (arglist))\n+    argarray[i] = TREE_VALUE (arglist);\n+  return fold_builtin_call_array (TREE_TYPE (fntype), fn, n, argarray);\n }\n \n /* Conveniently construct a function call expression.  FNDECL names the\n@@ -10184,24 +10141,26 @@ tree\n build_call_expr (tree fndecl, int n, ...)\n {\n   va_list ap;\n-  tree ret;\n   tree fntype = TREE_TYPE (fndecl);\n   tree fn = build1 (ADDR_EXPR, build_pointer_type (fntype), fndecl);\n+  tree *argarray = (tree *) alloca (n * sizeof (tree));\n+  int i;\n \n   va_start (ap, n);\n-  ret = fold_builtin_call_valist (TREE_TYPE (fntype), fn, n, ap);\n+  for (i = 0; i < n; i++)\n+    argarray[i] = va_arg (ap, tree);\n   va_end (ap);\n-  return ret;\n+  return fold_builtin_call_array (TREE_TYPE (fntype), fn, n, argarray);\n }\n \n /* Construct a CALL_EXPR with type TYPE with FN as the function expression.\n-   N arguments are passed in the va_list AP.  */\n+   N arguments are passed in the array ARGARRAY.  */\n \n tree\n-fold_builtin_call_valist (tree type,\n-\t\t\t  tree fn,\n-\t\t\t  int n,\n-\t\t\t  va_list ap)\n+fold_builtin_call_array (tree type,\n+\t\t\t tree fn,\n+\t\t\t int n,\n+\t\t\t tree *argarray)\n {\n   tree ret = NULL_TREE;\n   int i;\n@@ -10216,15 +10175,8 @@ fold_builtin_call_valist (tree type,\n         if (DECL_BUILT_IN_CLASS (fndecl) == BUILT_IN_MD)\n           {\n             tree arglist = NULL_TREE;\n-            va_list ap0;\n-            va_copy (ap0, ap);\n-            for (i = 0; i < n; i++)\n-              {\n-                tree arg = va_arg (ap0, tree);\n-                arglist = tree_cons (NULL_TREE, arg, arglist);\n-\t       }\n-            va_end (ap0);\n-            arglist = nreverse (arglist);\n+\t    for (i = n - 1; i >= 0; i--)\n+\t      arglist = tree_cons (NULL_TREE, argarray[i], arglist);\n             ret = targetm.fold_builtin (fndecl, arglist, false);\n             if (ret)\n               return ret;\n@@ -10233,25 +10185,19 @@ fold_builtin_call_valist (tree type,\n           {\n             /* First try the transformations that don't require consing up\n                an exp.  */\n-            tree args[MAX_ARGS_TO_FOLD_BUILTIN];\n-            va_list ap0;\n-            va_copy (ap0, ap);\n-            for (i = 0; i < n; i++)\n-              args[i] = va_arg (ap0, tree);\n-            va_end (ap0);\n-            ret = fold_builtin_n (fndecl, args, n, false);\n+            ret = fold_builtin_n (fndecl, argarray, n, false);\n             if (ret)\n               return ret;\n           }\n \n         /* If we got this far, we need to build an exp.  */\n-        exp = build_call_valist (type, fn, n, ap);\n+        exp = build_call_array (type, fn, n, argarray);\n         ret = fold_builtin_varargs (fndecl, exp, false);\n         return ret ? ret : exp;\n       }\n   }\n \n-  return build_call_valist (type, fn, n, ap);\n+  return build_call_array (type, fn, n, argarray);\n }\n \n /* Construct a new CALL_EXPR using the tail of the argument list of EXP"}, {"sha": "6ea3800be8db98cdc6848cf2146c873440f1516d", "filename": "gcc/c-common.c", "status": "modified", "additions": 54, "deletions": 69, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94a0dd7b599e1d83b81f007258af2b16e7cbc4c5/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94a0dd7b599e1d83b81f007258af2b16e7cbc4c5/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=94a0dd7b599e1d83b81f007258af2b16e7cbc4c5", "patch": "@@ -554,7 +554,7 @@ static tree handle_warn_unused_result_attribute (tree *, tree, tree, int,\n \t\t\t\t\t\t bool *);\n static tree handle_sentinel_attribute (tree *, tree, tree, int, bool *);\n \n-static void check_function_nonnull (tree, tree);\n+static void check_function_nonnull (tree, int, tree *);\n static void check_nonnull_arg (void *, tree, unsigned HOST_WIDE_INT);\n static bool nonnull_check_p (tree, unsigned HOST_WIDE_INT);\n static bool get_nonnull_operand (tree, unsigned HOST_WIDE_INT *);\n@@ -5710,13 +5710,15 @@ handle_nonnull_attribute (tree *node, tree ARG_UNUSED (name),\n }\n \n /* Check the argument list of a function call for null in argument slots\n-   that are marked as requiring a non-null pointer argument.  */\n+   that are marked as requiring a non-null pointer argument.  The NARGS\n+   arguments are passed in the array ARGARRAY.\n+*/\n \n static void\n-check_function_nonnull (tree attrs, tree params)\n+check_function_nonnull (tree attrs, int nargs, tree *argarray)\n {\n-  tree a, args, param;\n-  int param_num;\n+  tree a, args;\n+  int i;\n \n   for (a = attrs; a; a = TREE_CHAIN (a))\n     {\n@@ -5728,85 +5730,65 @@ check_function_nonnull (tree attrs, tree params)\n \t     should check for non-null, do it.  If the attribute has no args,\n \t     then every pointer argument is checked (in which case the check\n \t     for pointer type is done in check_nonnull_arg).  */\n-\t  for (param = params, param_num = 1; ;\n-\t       param_num++, param = TREE_CHAIN (param))\n+\t  for (i = 0; i < nargs; i++)\n \t    {\n-\t      if (!param)\n-\t\tbreak;\n-\t      if (!args || nonnull_check_p (args, param_num))\n+\t      if (!args || nonnull_check_p (args, i + 1))\n \t\tcheck_function_arguments_recurse (check_nonnull_arg, NULL,\n-\t\t\t\t\t\t  TREE_VALUE (param),\n-\t\t\t\t\t\t  param_num);\n+\t\t\t\t\t\t  argarray[i],\n+\t\t\t\t\t\t  i + 1);\n \t    }\n \t}\n     }\n }\n \n /* Check that the Nth argument of a function call (counting backwards\n-   from the end) is a (pointer)0.  */\n+   from the end) is a (pointer)0.  The NARGS arguments are passed in the\n+   array ARGARRAY.  */\n \n static void\n-check_function_sentinel (tree attrs, tree params, tree typelist)\n+check_function_sentinel (tree attrs, int nargs, tree *argarray, tree typelist)\n {\n   tree attr = lookup_attribute (\"sentinel\", attrs);\n \n   if (attr)\n     {\n-      /* Skip over the named arguments.  */\n-      while (typelist && params)\n-      {\n-\ttypelist = TREE_CHAIN (typelist);\n-\tparams = TREE_CHAIN (params);\n-      }\n+      int len = 0;\n+      int pos = 0;\n+      tree sentinel;\n \n-      if (typelist || !params)\n-\twarning (OPT_Wformat,\n-\t\t \"not enough variable arguments to fit a sentinel\");\n-      else\n+      /* Skip over the named arguments.  */\n+      while (typelist && len < nargs)\n \t{\n-\t  tree sentinel, end;\n-\t  unsigned pos = 0;\n-\n-\t  if (TREE_VALUE (attr))\n-\t    {\n-\t      tree p = TREE_VALUE (TREE_VALUE (attr));\n-\t      pos = TREE_INT_CST_LOW (p);\n-\t    }\n-\n-\t  sentinel = end = params;\n-\n-\t  /* Advance `end' ahead of `sentinel' by `pos' positions.  */\n-\t  while (pos > 0 && TREE_CHAIN (end))\n-\t    {\n-\t      pos--;\n-\t      end = TREE_CHAIN (end);\n-\t    }\n-\t  if (pos > 0)\n-\t    {\n-\t      warning (OPT_Wformat,\n-\t\t       \"not enough variable arguments to fit a sentinel\");\n-\t      return;\n-\t    }\n+\t  typelist = TREE_CHAIN (typelist);\n+\t  len++;\n+\t}\n \n-\t  /* Now advance both until we find the last parameter.  */\n-\t  while (TREE_CHAIN (end))\n-\t    {\n-\t      end = TREE_CHAIN (end);\n-\t      sentinel = TREE_CHAIN (sentinel);\n-\t    }\n+      if (TREE_VALUE (attr))\n+\t{\n+\t  tree p = TREE_VALUE (TREE_VALUE (attr));\n+\t  pos = TREE_INT_CST_LOW (p);\n+\t}\n \n-\t  /* Validate the sentinel.  */\n-\t  if ((!POINTER_TYPE_P (TREE_TYPE (TREE_VALUE (sentinel)))\n-\t       || !integer_zerop (TREE_VALUE (sentinel)))\n-\t      /* Although __null (in C++) is only an integer we allow it\n-\t\t nevertheless, as we are guaranteed that it's exactly\n-\t\t as wide as a pointer, and we don't want to force\n-\t\t users to cast the NULL they have written there.\n-\t\t We warn with -Wstrict-null-sentinel, though.  */\n-\t      && (warn_strict_null_sentinel\n-\t\t  || null_node != TREE_VALUE (sentinel)))\n-\t    warning (OPT_Wformat, \"missing sentinel in function call\");\n+      /* The sentinel must be one of the varargs, i.e.\n+\t in position >= the number of fixed arguments.  */\n+      if ((nargs - 1 - pos) < len)\n+\t{\n+\t  warning (OPT_Wformat,\n+\t\t   \"not enough variable arguments to fit a sentinel\");\n+\t  return;\n \t}\n+\n+      /* Validate the sentinel.  */\n+      sentinel = argarray[nargs - 1 - pos];\n+      if ((!POINTER_TYPE_P (TREE_TYPE (sentinel))\n+\t   || !integer_zerop (sentinel))\n+\t  /* Although __null (in C++) is only an integer we allow it\n+\t     nevertheless, as we are guaranteed that it's exactly\n+\t     as wide as a pointer, and we don't want to force\n+\t     users to cast the NULL they have written there.\n+\t     We warn with -Wstrict-null-sentinel, though.  */\n+\t  && (warn_strict_null_sentinel || null_node != sentinel))\n+\twarning (OPT_Wformat, \"missing sentinel in function call\");\n     }\n }\n \n@@ -5996,23 +5978,26 @@ handle_sentinel_attribute (tree *node, tree name, tree args,\n   return NULL_TREE;\n }\n \f\n-/* Check for valid arguments being passed to a function.  */\n+/* Check for valid arguments being passed to a function.\n+   ATTRS is a list of attributes.  There are NARGS arguments in the array\n+   ARGARRAY.  TYPELIST is the list of argument types for the function.\n+ */\n void\n-check_function_arguments (tree attrs, tree params, tree typelist)\n+check_function_arguments (tree attrs, int nargs, tree *argarray, tree typelist)\n {\n   /* Check for null being passed in a pointer argument that must be\n      non-null.  We also need to do this if format checking is enabled.  */\n \n   if (warn_nonnull)\n-    check_function_nonnull (attrs, params);\n+    check_function_nonnull (attrs, nargs, argarray);\n \n   /* Check for errors in format strings.  */\n \n   if (warn_format || warn_missing_format_attribute)\n-      check_function_format (attrs, params);\n+    check_function_format (attrs, nargs, argarray);\n \n   if (warn_format)\n-    check_function_sentinel (attrs, params, typelist);\n+    check_function_sentinel (attrs, nargs, argarray, typelist);\n }\n \n /* Generic argument checking recursion routine.  PARAM is the argument to"}, {"sha": "2eedf79d29d6e706e16301f62aae91fadbdab5c8", "filename": "gcc/c-common.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94a0dd7b599e1d83b81f007258af2b16e7cbc4c5/gcc%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94a0dd7b599e1d83b81f007258af2b16e7cbc4c5/gcc%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.h?ref=94a0dd7b599e1d83b81f007258af2b16e7cbc4c5", "patch": "@@ -640,13 +640,13 @@ extern void finish_fname_decls (void);\n extern const char *fname_as_string (int);\n extern tree fname_decl (unsigned, tree);\n \n-extern void check_function_arguments (tree, tree, tree);\n+extern void check_function_arguments (tree, int, tree *, tree);\n extern void check_function_arguments_recurse (void (*)\n \t\t\t\t\t      (void *, tree,\n \t\t\t\t\t       unsigned HOST_WIDE_INT),\n \t\t\t\t\t      void *, tree,\n \t\t\t\t\t      unsigned HOST_WIDE_INT);\n-extern void check_function_format (tree, tree);\n+extern void check_function_format (tree, int, tree *);\n extern void set_Wformat (int);\n extern tree handle_format_attribute (tree *, tree, tree, int, bool *);\n extern tree handle_format_arg_attribute (tree *, tree, tree, int, bool *);"}, {"sha": "4a0a41e3a54bd1fe39737bebca458d39a8a2c401", "filename": "gcc/c-format.c", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94a0dd7b599e1d83b81f007258af2b16e7cbc4c5/gcc%2Fc-format.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94a0dd7b599e1d83b81f007258af2b16e7cbc4c5/gcc%2Fc-format.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-format.c?ref=94a0dd7b599e1d83b81f007258af2b16e7cbc4c5", "patch": "@@ -851,13 +851,14 @@ decode_format_type (const char *s)\n \n \f\n /* Check the argument list of a call to printf, scanf, etc.\n-   ATTRS are the attributes on the function type.\n-   PARAMS is the list of argument values.  Also, if -Wmissing-format-attribute,\n+   ATTRS are the attributes on the function type.  There are NARGS argument\n+   values in the array ARGARRAY.\n+   Also, if -Wmissing-format-attribute,\n    warn for calls to vprintf or vscanf in functions with no such format\n    attribute themselves.  */\n \n void\n-check_function_format (tree attrs, tree params)\n+check_function_format (tree attrs, int nargs, tree *argarray)\n {\n   tree a;\n \n@@ -870,7 +871,16 @@ check_function_format (tree attrs, tree params)\n \t  function_format_info info;\n \t  decode_format_attr (TREE_VALUE (a), &info, 1);\n \t  if (warn_format)\n-\t    check_format_info (&info, params);\n+\t    {\n+\t      /* FIXME: Rewrite all the internal functions in this file\n+\t\t to use the ARGARRAY directly instead of constructing this\n+\t\t temporary list.  */\n+\t      tree params = NULL_TREE;\n+\t      int i;\n+\t      for (i = nargs - 1; i >= 0; i--)\n+\t\tparams = tree_cons (NULL_TREE, argarray[i], params);\n+\t      check_format_info (&info, params);\n+\t    }\n \t  if (warn_missing_format_attribute && info.first_arg_num == 0\n \t      && (format_types[info.format_type].flags\n \t\t  & (int) FMT_FLAG_ARG_CONVERT))"}, {"sha": "8afc2c757ebf30295ddcb62436750c51c4976117", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 34, "deletions": 28, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94a0dd7b599e1d83b81f007258af2b16e7cbc4c5/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94a0dd7b599e1d83b81f007258af2b16e7cbc4c5/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=94a0dd7b599e1d83b81f007258af2b16e7cbc4c5", "patch": "@@ -83,7 +83,7 @@ static int function_types_compatible_p (tree, tree);\n static int type_lists_compatible_p (tree, tree);\n static tree decl_constant_value_for_broken_optimization (tree);\n static tree lookup_field (tree, tree);\n-static tree convert_arguments (tree, tree, tree, tree);\n+static int convert_arguments (int, tree *, tree, tree, tree, tree);\n static tree pointer_diff (tree, tree);\n static tree convert_for_assignment (tree, tree, enum impl_conv, tree, tree,\n \t\t\t\t    int);\n@@ -2228,9 +2228,11 @@ tree\n build_function_call (tree function, tree params)\n {\n   tree fntype, fundecl = 0;\n-  tree coerced_params;\n   tree name = NULL_TREE, result;\n   tree tem;\n+  int nargs;\n+  tree *argarray;\n+  \n \n   /* Strip NON_LVALUE_EXPRs, etc., since we aren't using as an lvalue.  */\n   STRIP_TYPE_NOPS (function);\n@@ -2317,40 +2319,39 @@ build_function_call (tree function, tree params)\n   /* Convert the parameters to the types declared in the\n      function prototype, or apply default promotions.  */\n \n-  coerced_params\n-    = convert_arguments (TYPE_ARG_TYPES (fntype), params, function, fundecl);\n-\n-  if (coerced_params == error_mark_node)\n+  nargs = list_length (params);\n+  argarray = (tree *) alloca (nargs * sizeof (tree));\n+  nargs = convert_arguments (nargs, argarray, TYPE_ARG_TYPES (fntype), \n+\t\t\t     params, function, fundecl);\n+  if (nargs < 0)\n     return error_mark_node;\n \n   /* Check that the arguments to the function are valid.  */\n \n-  check_function_arguments (TYPE_ATTRIBUTES (fntype), coerced_params,\n+  check_function_arguments (TYPE_ATTRIBUTES (fntype), nargs, argarray,\n \t\t\t    TYPE_ARG_TYPES (fntype));\n \n   if (require_constant_value)\n     {\n-      result = fold_build_call_list_initializer (TREE_TYPE (fntype),\n-\t\t\t\t\t\t function,\n-\t\t\t\t\t\t coerced_params);\n+      result = fold_build_call_array_initializer (TREE_TYPE (fntype),\n+\t\t\t\t\t\t  function, nargs, argarray);\n       if (TREE_CONSTANT (result)\n \t  && (name == NULL_TREE\n \t      || strncmp (IDENTIFIER_POINTER (name), \"__builtin_\", 10) != 0))\n \tpedwarn_init (\"initializer element is not constant\");\n     }\n   else\n-    result = fold_build_call_list (TREE_TYPE (fntype),\n-\t\t\t\t   function, coerced_params);\n+    result = fold_build_call_array (TREE_TYPE (fntype),\n+\t\t\t\t    function, nargs, argarray);\n \n   if (VOID_TYPE_P (TREE_TYPE (result)))\n     return result;\n   return require_complete_type (result);\n }\n \f\n /* Convert the argument expressions in the list VALUES\n-   to the types in the list TYPELIST.  The result is a list of converted\n-   argument expressions, unless there are too few arguments in which\n-   case it is error_mark_node.\n+   to the types in the list TYPELIST.  The resulting arguments are\n+   stored in the array ARGARRAY which has size NARGS.\n \n    If TYPELIST is exhausted, or when an element has NULL as its type,\n    perform the default conversions.\n@@ -2364,14 +2365,17 @@ build_function_call (tree function, tree params)\n \n    This is also where warnings about wrong number of args are generated.\n \n-   Both VALUES and the returned value are chains of TREE_LIST nodes\n-   with the elements of the list in the TREE_VALUE slots of those nodes.  */\n+   VALUES is a chain of TREE_LIST nodes with the elements of the list\n+   in the TREE_VALUE slots of those nodes.\n \n-static tree\n-convert_arguments (tree typelist, tree values, tree function, tree fundecl)\n+   Returns the actual number of arguments processed (which may be less\n+   than NARGS in some error situations), or -1 on failure.  */\n+\n+static int\n+convert_arguments (int nargs, tree *argarray,\n+\t\t   tree typelist, tree values, tree function, tree fundecl)\n {\n   tree typetail, valtail;\n-  tree result = NULL;\n   int parmnum;\n   tree selector;\n \n@@ -2385,7 +2389,7 @@ convert_arguments (tree typelist, tree values, tree function, tree fundecl)\n   selector = objc_message_selector ();\n \n   /* Scan the given expressions and types, producing individual\n-     converted arguments and pushing them on RESULT in reverse order.  */\n+     converted arguments and storing them in ARGARRAY.  */\n \n   for (valtail = values, typetail = typelist, parmnum = 0;\n        valtail;\n@@ -2400,7 +2404,7 @@ convert_arguments (tree typelist, tree values, tree function, tree fundecl)\n       if (type == void_type_node)\n \t{\n \t  error (\"too many arguments to function %qE\", function);\n-\t  break;\n+\t  return parmnum;\n \t}\n \n       if (selector && argnum > 2)\n@@ -2558,35 +2562,37 @@ convert_arguments (tree typelist, tree values, tree function, tree fundecl)\n \t\t  && (TYPE_PRECISION (type) < TYPE_PRECISION (integer_type_node)))\n \t\tparmval = default_conversion (parmval);\n \t    }\n-\t  result = tree_cons (NULL_TREE, parmval, result);\n+\t  argarray[parmnum] = parmval;\n \t}\n       else if (TREE_CODE (TREE_TYPE (val)) == REAL_TYPE\n \t       && (TYPE_PRECISION (TREE_TYPE (val))\n \t\t   < TYPE_PRECISION (double_type_node))\n \t       && !DECIMAL_FLOAT_MODE_P (TYPE_MODE (TREE_TYPE (val))))\n \t/* Convert `float' to `double'.  */\n-\tresult = tree_cons (NULL_TREE, convert (double_type_node, val), result);\n+\targarray[parmnum] = convert (double_type_node, val);\n       else if ((invalid_func_diag =\n \t\ttargetm.calls.invalid_arg_for_unprototyped_fn (typelist, fundecl, val)))\n \t{\n \t  error (invalid_func_diag);\n-\t  return error_mark_node;\n+\t  return -1;\n \t}\n       else\n \t/* Convert `short' and `char' to full-size `int'.  */\n-\tresult = tree_cons (NULL_TREE, default_conversion (val), result);\n+\targarray[parmnum] = default_conversion (val);\n \n       if (typetail)\n \ttypetail = TREE_CHAIN (typetail);\n     }\n \n+  gcc_assert (parmnum == nargs);\n+\n   if (typetail != 0 && TREE_VALUE (typetail) != void_type_node)\n     {\n       error (\"too few arguments to function %qE\", function);\n-      return error_mark_node;\n+      return -1;\n     }\n \n-  return nreverse (result);\n+  return parmnum;\n }\n \f\n /* This is the entry point used by the parser to build unary operators"}, {"sha": "f6756070895dd46bb3085d2682cee85bde84e75d", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94a0dd7b599e1d83b81f007258af2b16e7cbc4c5/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94a0dd7b599e1d83b81f007258af2b16e7cbc4c5/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=94a0dd7b599e1d83b81f007258af2b16e7cbc4c5", "patch": "@@ -1,3 +1,30 @@\n+2007-02-28  Sandra Loosemore  <sandra@codesourcery.com>\n+\n+\t* typeck.c (build_function_call): Store converted arguments\n+\tin a stack-allocated array instead of building a list.\n+\t(convert_arguments): Store arguments in the array passed in as an\n+\targument, and return the actual number of arguments.\n+\t* call.c (build_call): Delete, and replace with...\n+\t(build_call_n, build_call_a): New.\n+\t(build_op_delete_call): Rewrite to avoid constructing argument lists.\n+\t(build_over_call): Store converted arguments in a stack-allocated\n+\tarray instead of building a list.\n+\t(build_cxx_call): Pass arguments in an array instead of as a list.\n+\t(build_java_interface_fn_ref): Rewrite to avoid constructing\n+\targument lists.\n+\t* tree.h: Update declarations to reflect above changes.\n+\t* method.c (use_thunk): Use a stack-allocated array to hold\n+\tthe arguments instead of a list.\n+\t* rtti.c (throw_bad_cast): Update call to cxx_call.\n+\t(throw_bad_typeid): Likewise.\n+\t(build_dynamic_cast_1): Likewise.\n+\t* init.c (build_builtin_delete_call): Use build_call_n.\n+\t* decl.c (expand_static_init): Likewise.\n+\t* except.c (cp_protect_cleanup_actions): Likewise.\n+\t* cp-gimplify.c (genericize_eh_spec_block): Likewise.\n+\t(gimplify_must_not_throw_expr): Likewise.\n+\t(cxx_omp_apply_fn): Use build_call_a.\n+\n 2007-02-26  Mark Mitchell  <mark@codesourcery.com>\n \n \t* semantics.c (expand_or_defer_fn): Call c_record_cdtor_fn."}, {"sha": "3514e62324be44fc7e2bc76ac4bc09f29fe1aec6", "filename": "gcc/cp/call.c", "status": "modified", "additions": 100, "deletions": 72, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94a0dd7b599e1d83b81f007258af2b16e7cbc4c5/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94a0dd7b599e1d83b81f007258af2b16e7cbc4c5/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=94a0dd7b599e1d83b81f007258af2b16e7cbc4c5", "patch": "@@ -269,17 +269,38 @@ build_addr_func (tree function)\n \n /* Build a CALL_EXPR, we can handle FUNCTION_TYPEs, METHOD_TYPEs, or\n    POINTER_TYPE to those.  Note, pointer to member function types\n-   (TYPE_PTRMEMFUNC_P) must be handled by our callers.  */\n+   (TYPE_PTRMEMFUNC_P) must be handled by our callers.  There are\n+   two variants.  build_call_a is the primitive taking an array of\n+   arguments, while build_call_n is a wrapper that handles varargs.  */\n \n tree\n-build_call (tree function, tree parms)\n+build_call_n (tree function, int n, ...)\n+{\n+  if (n == 0)\n+    return build_call_a (function, 0, NULL);\n+  else\n+    {\n+      tree *argarray = (tree *) alloca (n * sizeof (tree));\n+      va_list ap;\n+      int i;\n+\n+      va_start (ap, n);\n+      for (i = 0; i < n; i++)\n+\targarray[i] = va_arg (ap, tree);\n+      va_end (ap);\n+      return build_call_a (function, n, argarray);\n+    }\n+}\n+\n+tree\n+build_call_a (tree function, int n, tree *argarray)\n {\n   int is_constructor = 0;\n   int nothrow;\n-  tree tmp;\n   tree decl;\n   tree result_type;\n   tree fntype;\n+  int i;\n \n   function = build_addr_func (function);\n \n@@ -327,16 +348,16 @@ build_call (tree function, tree parms)\n      for tags in STL, which are used to control overload resolution.\n      We don't need to handle other cases of copying empty classes.  */\n   if (! decl || ! DECL_BUILT_IN (decl))\n-    for (tmp = parms; tmp; tmp = TREE_CHAIN (tmp))\n-      if (is_empty_class (TREE_TYPE (TREE_VALUE (tmp)))\n-\t  && ! TREE_ADDRESSABLE (TREE_TYPE (TREE_VALUE (tmp))))\n+    for (i = 0; i < n; i++)\n+      if (is_empty_class (TREE_TYPE (argarray[i]))\n+\t  && ! TREE_ADDRESSABLE (TREE_TYPE (argarray[i])))\n \t{\n-\t  tree t = build0 (EMPTY_CLASS_EXPR, TREE_TYPE (TREE_VALUE (tmp)));\n-\t  TREE_VALUE (tmp) = build2 (COMPOUND_EXPR, TREE_TYPE (t),\n-\t\t\t\t     TREE_VALUE (tmp), t);\n+\t  tree t = build0 (EMPTY_CLASS_EXPR, TREE_TYPE (argarray[i]));\n+\t  argarray[i] = build2 (COMPOUND_EXPR, TREE_TYPE (t),\n+\t\t\t\targarray[i], t);\n \t}\n \n-  function = build_call_list (result_type, function, parms);\n+  function = build_call_array (result_type, function, n, argarray);\n   TREE_HAS_CONSTRUCTOR (function) = is_constructor;\n   TREE_NOTHROW (function) = nothrow;\n \n@@ -4005,7 +4026,7 @@ build_op_delete_call (enum tree_code code, tree addr, tree size,\n \t\t      tree alloc_fn)\n {\n   tree fn = NULL_TREE;\n-  tree fns, fnname, argtypes, args, type;\n+  tree fns, fnname, argtypes, type;\n   int pass;\n \n   if (addr == error_mark_node)\n@@ -4036,25 +4057,22 @@ build_op_delete_call (enum tree_code code, tree addr, tree size,\n   if (fns == NULL_TREE)\n     fns = lookup_name_nonclass (fnname);\n \n+  /* Strip const and volatile from addr.  */\n+  addr = cp_convert (ptr_type_node, addr);\n+\n   if (placement)\n     {\n       /* Get the parameter types for the allocation function that is\n \t being called.  */\n       gcc_assert (alloc_fn != NULL_TREE);\n       argtypes = TREE_CHAIN (TYPE_ARG_TYPES (TREE_TYPE (alloc_fn)));\n-      /* Also the second argument.  */\n-      args = TREE_CHAIN (TREE_OPERAND (placement, 1));\n     }\n   else\n     {\n       /* First try it without the size argument.  */\n       argtypes = void_list_node;\n-      args = NULL_TREE;\n     }\n \n-  /* Strip const and volatile from addr.  */\n-  addr = cp_convert (ptr_type_node, addr);\n-\n   /* We make two tries at finding a matching `operator delete'.  On\n      the first pass, we look for a one-operator (or placement)\n      operator delete.  If we're not doing placement delete, then on\n@@ -4113,21 +4131,29 @@ build_op_delete_call (enum tree_code code, tree addr, tree size,\n       if (DECL_CLASS_SCOPE_P (fn))\n \tperform_or_defer_access_check (TYPE_BINFO (type), fn, fn);\n \n-      if (pass == 0)\n-\targs = tree_cons (NULL_TREE, addr, args);\n-      else\n-\targs = tree_cons (NULL_TREE, addr,\n-\t\t\t  build_tree_list (NULL_TREE, size));\n-\n       if (placement)\n \t{\n \t  /* The placement args might not be suitable for overload\n \t     resolution at this point, so build the call directly.  */\n+\t  int nargs = call_expr_nargs (placement);\n+\t  tree *argarray = (tree *) alloca (nargs * sizeof (tree));\n+\t  int i;\n+\t  argarray[0] = addr;\n+\t  for (i = 1; i < nargs; i++)\n+\t    argarray[i] = CALL_EXPR_ARG (placement, i);\n \t  mark_used (fn);\n-\t  return build_cxx_call (fn, args);\n+\t  return build_cxx_call (fn, nargs, argarray);\n \t}\n       else\n-\treturn build_function_call (fn, args);\n+\t{\n+\t  tree args;\n+\t  if (pass == 0)\n+\t    args = tree_cons (NULL_TREE, addr, NULL_TREE);\n+\t  else\n+\t    args = tree_cons (NULL_TREE, addr,\n+\t\t\t      build_tree_list (NULL_TREE, size));\n+\t  return build_function_call (fn, args);\n+\t}\n     }\n \n   /* If we are doing placement delete we do nothing if we don't find a\n@@ -4494,7 +4520,7 @@ call_builtin_trap (void)\n   tree fn = implicit_built_in_decls[BUILT_IN_TRAP];\n \n   gcc_assert (fn != NULL);\n-  fn = build_call (fn, NULL_TREE);\n+  fn = build_call_n (fn, 0);\n   return fn;\n }\n \n@@ -4725,11 +4751,14 @@ build_over_call (struct z_candidate *cand, int flags)\n   tree args = cand->args;\n   conversion **convs = cand->convs;\n   conversion *conv;\n-  tree converted_args = NULL_TREE;\n   tree parm = TYPE_ARG_TYPES (TREE_TYPE (fn));\n+  int parmlen;\n   tree arg, val;\n   int i = 0;\n+  int j = 0;\n   int is_method = 0;\n+  int nargs;\n+  tree *argarray;\n \n   /* In a template, there is no need to perform all of the work that\n      is normally done.  We are only interested in the type of the call\n@@ -4795,20 +4824,26 @@ build_over_call (struct z_candidate *cand, int flags)\n     args = build_tree_list (NULL_TREE, args);\n   arg = args;\n \n+  /* Find maximum size of vector to hold converted arguments.  */\n+  parmlen = list_length (parm);\n+  nargs = list_length (args);\n+  if (parmlen > nargs)\n+    nargs = parmlen;\n+  argarray = (tree *) alloca (nargs * sizeof (tree));\n+\n   /* The implicit parameters to a constructor are not considered by overload\n      resolution, and must be of the proper type.  */\n   if (DECL_CONSTRUCTOR_P (fn))\n     {\n-      converted_args = tree_cons (NULL_TREE, TREE_VALUE (arg), converted_args);\n+      argarray[j++] = TREE_VALUE (arg);\n       arg = TREE_CHAIN (arg);\n       parm = TREE_CHAIN (parm);\n       /* We should never try to call the abstract constructor.  */\n       gcc_assert (!DECL_HAS_IN_CHARGE_PARM_P (fn));\n \n       if (DECL_HAS_VTT_PARM_P (fn))\n \t{\n-\t  converted_args = tree_cons\n-\t    (NULL_TREE, TREE_VALUE (arg), converted_args);\n+\t  argarray[j++] = TREE_VALUE (arg);\n \t  arg = TREE_CHAIN (arg);\n \t  parm = TREE_CHAIN (parm);\n \t}\n@@ -4852,7 +4887,7 @@ build_over_call (struct z_candidate *cand, int flags)\n       converted_arg = build_base_path (PLUS_EXPR, converted_arg,\n \t\t\t\t       base_binfo, 1);\n \n-      converted_args = tree_cons (NULL_TREE, converted_arg, converted_args);\n+      argarray[j++] = converted_arg;\n       parm = TREE_CHAIN (parm);\n       arg = TREE_CHAIN (arg);\n       ++i;\n@@ -4875,18 +4910,14 @@ build_over_call (struct z_candidate *cand, int flags)\n \t(conv, TREE_VALUE (arg), fn, i - is_method);\n \n       val = convert_for_arg_passing (type, val);\n-      converted_args = tree_cons (NULL_TREE, val, converted_args);\n+      argarray[j++] = val;\n     }\n \n   /* Default arguments */\n   for (; parm && parm != void_list_node; parm = TREE_CHAIN (parm), i++)\n-    converted_args\n-      = tree_cons (NULL_TREE,\n-\t\t   convert_default_arg (TREE_VALUE (parm),\n-\t\t\t\t\tTREE_PURPOSE (parm),\n-\t\t\t\t\tfn, i - is_method),\n-\t\t   converted_args);\n-\n+    argarray[j++] = convert_default_arg (TREE_VALUE (parm),\n+\t\t\t\t\t TREE_PURPOSE (parm),\n+\t\t\t\t\t fn, i - is_method);\n   /* Ellipsis */\n   for (; arg; arg = TREE_CHAIN (arg))\n     {\n@@ -4895,13 +4926,14 @@ build_over_call (struct z_candidate *cand, int flags)\n \t/* Do no conversions for magic varargs.  */;\n       else\n \ta = convert_arg_to_ellipsis (a);\n-      converted_args = tree_cons (NULL_TREE, a, converted_args);\n+      argarray[j++] = a;\n     }\n \n-  converted_args = nreverse (converted_args);\n+  gcc_assert (j <= nargs);\n+  nargs = j;\n \n   check_function_arguments (TYPE_ATTRIBUTES (TREE_TYPE (fn)),\n-\t\t\t    converted_args, TYPE_ARG_TYPES (TREE_TYPE (fn)));\n+\t\t\t    nargs, argarray, TYPE_ARG_TYPES (TREE_TYPE (fn)));\n \n   /* Avoid actually calling copy constructors and copy assignment operators,\n      if possible.  */\n@@ -4911,8 +4943,7 @@ build_over_call (struct z_candidate *cand, int flags)\n   else if (cand->num_convs == 1 && DECL_COPY_CONSTRUCTOR_P (fn))\n     {\n       tree targ;\n-      arg = skip_artificial_parms_for (fn, converted_args);\n-      arg = TREE_VALUE (arg);\n+      arg = argarray[num_artificial_parms_for (fn)];\n \n       /* Pull out the real argument, disregarding const-correctness.  */\n       targ = arg;\n@@ -4967,11 +4998,11 @@ build_over_call (struct z_candidate *cand, int flags)\n \t   && TYPE_HAS_TRIVIAL_ASSIGN_REF (DECL_CONTEXT (fn)))\n     {\n       tree to = stabilize_reference\n-\t(build_indirect_ref (TREE_VALUE (converted_args), 0));\n+\t(build_indirect_ref (argarray[0], 0));\n       tree type = TREE_TYPE (to);\n       tree as_base = CLASSTYPE_AS_BASE (type);\n \n-      arg = TREE_VALUE (TREE_CHAIN (converted_args));\n+      arg = argarray[1];\n       if (tree_int_cst_equal (TYPE_SIZE (type), TYPE_SIZE (as_base)))\n \t{\n \t  arg = build_indirect_ref (arg, 0);\n@@ -4981,17 +5012,16 @@ build_over_call (struct z_candidate *cand, int flags)\n \t{\n \t  /* We must only copy the non-tail padding parts.\n \t     Use __builtin_memcpy for the bitwise copy.  */\n+\t\n+\t  tree arg0, arg1, arg2, t;\n \n-\t  tree args, t;\n-\n-\t  args = tree_cons (NULL, TYPE_SIZE_UNIT (as_base), NULL);\n-\t  args = tree_cons (NULL, arg, args);\n-\t  t = build_unary_op (ADDR_EXPR, to, 0);\n-\t  args = tree_cons (NULL, t, args);\n+\t  arg2 = TYPE_SIZE_UNIT (as_base);\n+\t  arg1 = arg;\n+\t  arg0 = build_unary_op (ADDR_EXPR, to, 0);\n \t  t = implicit_built_in_decls[BUILT_IN_MEMCPY];\n-\t  t = build_call (t, args);\n+\t  t = build_call_n (t, 3, arg0, arg1, arg2);\n \n-\t  t = convert (TREE_TYPE (TREE_VALUE (args)), t);\n+\t  t = convert (TREE_TYPE (arg0), t);\n \t  val = build_indirect_ref (t, 0);\n \t}\n \n@@ -5002,40 +5032,40 @@ build_over_call (struct z_candidate *cand, int flags)\n \n   if (DECL_VINDEX (fn) && (flags & LOOKUP_NONVIRTUAL) == 0)\n     {\n-      tree t, *p = &TREE_VALUE (converted_args);\n-      tree binfo = lookup_base (TREE_TYPE (TREE_TYPE (*p)),\n+      tree t;\n+      tree binfo = lookup_base (TREE_TYPE (TREE_TYPE (argarray[0])),\n \t\t\t\tDECL_CONTEXT (fn),\n \t\t\t\tba_any, NULL);\n       gcc_assert (binfo && binfo != error_mark_node);\n \n-      *p = build_base_path (PLUS_EXPR, *p, binfo, 1);\n-      if (TREE_SIDE_EFFECTS (*p))\n-\t*p = save_expr (*p);\n+      argarray[0] = build_base_path (PLUS_EXPR, argarray[0], binfo, 1);\n+      if (TREE_SIDE_EFFECTS (argarray[0]))\n+\targarray[0] = save_expr (argarray[0]);\n       t = build_pointer_type (TREE_TYPE (fn));\n       if (DECL_CONTEXT (fn) && TYPE_JAVA_INTERFACE (DECL_CONTEXT (fn)))\n-\tfn = build_java_interface_fn_ref (fn, *p);\n+\tfn = build_java_interface_fn_ref (fn, argarray[0]);\n       else\n-\tfn = build_vfn_ref (*p, DECL_VINDEX (fn));\n+\tfn = build_vfn_ref (argarray[0], DECL_VINDEX (fn));\n       TREE_TYPE (fn) = t;\n     }\n   else if (DECL_INLINE (fn))\n     fn = inline_conversion (fn);\n   else\n     fn = build_addr_func (fn);\n \n-  return build_cxx_call (fn, converted_args);\n+  return build_cxx_call (fn, nargs, argarray);\n }\n \n-/* Build and return a call to FN, using ARGS.  This function performs\n-   no overload resolution, conversion, or other high-level\n-   operations.  */\n+/* Build and return a call to FN, using NARGS arguments in ARGARRAY.\n+   This function performs no overload resolution, conversion, or other\n+   high-level operations.  */\n \n tree\n-build_cxx_call (tree fn, tree args)\n+build_cxx_call (tree fn, int nargs, tree *argarray)\n {\n   tree fndecl;\n \n-  fn = build_call (fn, args);\n+  fn = build_call_a (fn, nargs, argarray);\n \n   /* If this call might throw an exception, note that fact.  */\n   fndecl = get_callee_fndecl (fn);\n@@ -5069,7 +5099,7 @@ static GTY(()) tree java_iface_lookup_fn;\n static tree\n build_java_interface_fn_ref (tree fn, tree instance)\n {\n-  tree lookup_args, lookup_fn, method, idx;\n+  tree lookup_fn, method, idx;\n   tree klass_ref, iface, iface_ref;\n   int i;\n \n@@ -5116,13 +5146,11 @@ build_java_interface_fn_ref (tree fn, tree instance)\n     }\n   idx = build_int_cst (NULL_TREE, i);\n \n-  lookup_args = tree_cons (NULL_TREE, klass_ref,\n-\t\t\t   tree_cons (NULL_TREE, iface_ref,\n-\t\t\t\t      build_tree_list (NULL_TREE, idx)));\n   lookup_fn = build1 (ADDR_EXPR,\n \t\t      build_pointer_type (TREE_TYPE (java_iface_lookup_fn)),\n \t\t      java_iface_lookup_fn);\n-  return build_call_list (ptr_type_node, lookup_fn, lookup_args);\n+  return build_call_nary (ptr_type_node, lookup_fn,\n+\t\t\t  3, klass_ref, iface_ref, idx);\n }\n \n /* Returns the value to use for the in-charge parameter when making a"}, {"sha": "bd67ad1b819e11d232c25a0ba164d045e4e0eb42", "filename": "gcc/cp/cp-gimplify.c", "status": "modified", "additions": 22, "deletions": 21, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94a0dd7b599e1d83b81f007258af2b16e7cbc4c5/gcc%2Fcp%2Fcp-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94a0dd7b599e1d83b81f007258af2b16e7cbc4c5/gcc%2Fcp%2Fcp-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-gimplify.c?ref=94a0dd7b599e1d83b81f007258af2b16e7cbc4c5", "patch": "@@ -146,9 +146,7 @@ genericize_eh_spec_block (tree *stmt_p)\n {\n   tree body = EH_SPEC_STMTS (*stmt_p);\n   tree allowed = EH_SPEC_RAISES (*stmt_p);\n-  tree failure = build_call (call_unexpected_node,\n-\t\t\t     tree_cons (NULL_TREE, build_exc_ptr (),\n-\t\t\t\t\tNULL_TREE));\n+  tree failure = build_call_n (call_unexpected_node, 1, build_exc_ptr ());\n   gimplify_stmt (&body);\n \n   *stmt_p = gimple_build_eh_filter (body, allowed, failure);\n@@ -432,7 +430,7 @@ gimplify_must_not_throw_expr (tree *expr_p, tree *pre_p)\n   gimplify_stmt (&body);\n \n   stmt = gimple_build_eh_filter (body, NULL_TREE,\n-\t\t\t\t build_call (terminate_node, NULL_TREE));\n+\t\t\t\t build_call_n (terminate_node, 0));\n \n   if (temp)\n     {\n@@ -766,11 +764,16 @@ static tree\n cxx_omp_clause_apply_fn (tree fn, tree arg1, tree arg2)\n {\n   tree defparm, parm;\n-  int i;\n+  int i = 0;\n+  int nargs;\n+  tree *argarray;\n \n   if (fn == NULL)\n     return NULL;\n \n+  nargs = list_length (DECL_ARGUMENTS (fn));\n+  argarray = (tree *) alloca (nargs * sizeof (tree));\n+\n   defparm = TREE_CHAIN (TYPE_ARG_TYPES (TREE_TYPE (fn)));\n   if (arg2)\n     defparm = TREE_CHAIN (defparm);\n@@ -817,16 +820,14 @@ cxx_omp_clause_apply_fn (tree fn, tree arg1, tree arg2)\n       t = build1 (LABEL_EXPR, void_type_node, lab);\n       append_to_statement_list (t, &ret);\n \n-      t = tree_cons (NULL, p1, NULL);\n+      argarray[i++] = p1;\n       if (arg2)\n-\tt = tree_cons (NULL, p2, t);\n+\targarray[i++] = p2;\n       /* Handle default arguments.  */\n-      i = 1 + (arg2 != NULL);\n-      for (parm = defparm; parm != void_list_node; parm = TREE_CHAIN (parm))\n-\tt = tree_cons (NULL, convert_default_arg (TREE_VALUE (parm),\n-\t\t\t\t\t\t  TREE_PURPOSE (parm),\n-\t\t\t\t\t\t  fn, i++), t);\n-      t = build_call (fn, nreverse (t));\n+      for (parm = defparm; parm != void_list_node; parm = TREE_CHAIN (parm), i++)\n+\targarray[i] = convert_default_arg (TREE_VALUE (parm),\n+\t\t\t\t\t   TREE_PURPOSE (parm), fn, i);\n+      t = build_call_a (fn, i, argarray);\n       append_to_statement_list (t, &ret);\n \n       t = fold_convert (TREE_TYPE (p1), TYPE_SIZE_UNIT (inner_type));\n@@ -850,16 +851,16 @@ cxx_omp_clause_apply_fn (tree fn, tree arg1, tree arg2)\n     }\n   else\n     {\n-      tree t = tree_cons (NULL, build_fold_addr_expr (arg1), NULL);\n+      argarray[i++] = build_fold_addr_expr (arg1);\n       if (arg2)\n-\tt = tree_cons (NULL, build_fold_addr_expr (arg2), t);\n+\targarray[i++] = build_fold_addr_expr (arg2);\n       /* Handle default arguments.  */\n-      i = 1 + (arg2 != NULL);\n-      for (parm = defparm; parm != void_list_node; parm = TREE_CHAIN (parm))\n-\tt = tree_cons (NULL, convert_default_arg (TREE_VALUE (parm),\n-\t\t\t\t\t\t  TREE_PURPOSE (parm),\n-\t\t\t\t\t\t  fn, i++), t);\n-      return build_call (fn, nreverse (t));\n+      for (parm = defparm; parm != void_list_node;\n+\t   parm = TREE_CHAIN (parm), i++)\n+\targarray[i] = convert_default_arg (TREE_VALUE (parm),\n+\t\t\t\t\t   TREE_PURPOSE (parm),\n+\t\t\t\t\t   fn, i);\n+      return build_call_a (fn, i, argarray);\n     }\n }\n "}, {"sha": "6c4d7ee7fa532c8e3f496400655014e89a77a078", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94a0dd7b599e1d83b81f007258af2b16e7cbc4c5/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94a0dd7b599e1d83b81f007258af2b16e7cbc4c5/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=94a0dd7b599e1d83b81f007258af2b16e7cbc4c5", "patch": "@@ -3859,7 +3859,8 @@ extern bool check_dtor_name\t\t\t(tree, tree);\n extern tree build_vfield_ref\t\t\t(tree, tree);\n extern tree build_conditional_expr\t\t(tree, tree, tree);\n extern tree build_addr_func\t\t\t(tree);\n-extern tree build_call\t\t\t\t(tree, tree);\n+extern tree build_call_a\t\t\t(tree, int, tree*);\n+extern tree build_call_n\t\t\t(tree, int, ...);\n extern bool null_ptr_cst_p\t\t\t(tree);\n extern bool sufficient_parms_p\t\t\t(tree);\n extern tree type_decays_to\t\t\t(tree);\n@@ -3889,7 +3890,7 @@ extern tree strip_top_quals\t\t\t(tree);\n extern tree perform_implicit_conversion\t\t(tree, tree);\n extern tree perform_direct_initialization_if_possible (tree, tree, bool);\n extern tree in_charge_arg_for_name\t\t(tree);\n-extern tree build_cxx_call\t\t\t(tree, tree);\n+extern tree build_cxx_call\t\t\t(tree, int, tree *);\n #ifdef ENABLE_CHECKING\n extern void validate_conversion_obstack\t\t(void);\n #endif /* ENABLE_CHECKING */\n@@ -4174,6 +4175,7 @@ extern void synthesize_method\t\t\t(tree);\n extern tree lazily_declare_fn\t\t\t(special_function_kind,\n \t\t\t\t\t\t tree);\n extern tree skip_artificial_parms_for\t\t(tree, tree);\n+extern int num_artificial_parms_for\t\t(tree);\n extern tree make_alias_for\t\t\t(tree, tree);\n \n /* In optimize.c */"}, {"sha": "3aaa8df7dc5bad07bf62c9522cd8c9609340a966", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94a0dd7b599e1d83b81f007258af2b16e7cbc4c5/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94a0dd7b599e1d83b81f007258af2b16e7cbc4c5/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=94a0dd7b599e1d83b81f007258af2b16e7cbc4c5", "patch": "@@ -5641,7 +5641,7 @@ expand_static_init (tree decl, tree init)\n       /* Emit code to perform this initialization but once.  */\n       tree if_stmt = NULL_TREE, inner_if_stmt = NULL_TREE;\n       tree then_clause = NULL_TREE, inner_then_clause = NULL_TREE;\n-      tree guard, guard_addr, guard_addr_list;\n+      tree guard, guard_addr;\n       tree acquire_fn, release_fn, abort_fn;\n       tree flag, begin;\n \n@@ -5693,7 +5693,6 @@ expand_static_init (tree decl, tree init)\n       if (flag_threadsafe_statics)\n \t{\n \t  guard_addr = build_address (guard);\n-\t  guard_addr_list = build_tree_list (NULL_TREE, guard_addr);\n \n \t  acquire_fn = get_identifier (\"__cxa_guard_acquire\");\n \t  release_fn = get_identifier (\"__cxa_guard_release\");\n@@ -5715,7 +5714,7 @@ expand_static_init (tree decl, tree init)\n \t    }\n \n \t  inner_if_stmt = begin_if_stmt ();\n-\t  finish_if_stmt_cond (build_call (acquire_fn, guard_addr_list),\n+\t  finish_if_stmt_cond (build_call_n (acquire_fn, 1, guard_addr),\n \t\t\t       inner_if_stmt);\n \n \t  inner_then_clause = begin_compound_stmt (BCS_NO_SCOPE);\n@@ -5725,15 +5724,15 @@ expand_static_init (tree decl, tree init)\n \t  TARGET_EXPR_CLEANUP (begin)\n \t    = build3 (COND_EXPR, void_type_node, flag,\n \t\t      void_zero_node,\n-\t\t      build_call (abort_fn, guard_addr_list));\n+\t\t      build_call_n (abort_fn, 1, guard_addr));\n \t  CLEANUP_EH_ONLY (begin) = 1;\n \n \t  /* Do the initialization itself.  */\n \t  init = add_stmt_to_compound (begin, init);\n \t  init = add_stmt_to_compound\n \t    (init, build2 (MODIFY_EXPR, void_type_node, flag, boolean_true_node));\n \t  init = add_stmt_to_compound\n-\t    (init, build_call (release_fn, guard_addr_list));\n+\t    (init, build_call_n (release_fn, 1, guard_addr));\n \t}\n       else\n \tinit = add_stmt_to_compound (init, set_guard (guard));"}, {"sha": "f500437e97011aac5ce82351c994d9acd2ad6108", "filename": "gcc/cp/except.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94a0dd7b599e1d83b81f007258af2b16e7cbc4c5/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94a0dd7b599e1d83b81f007258af2b16e7cbc4c5/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=94a0dd7b599e1d83b81f007258af2b16e7cbc4c5", "patch": "@@ -99,7 +99,7 @@ cp_protect_cleanup_actions (void)\n \n      When the destruction of an object during stack unwinding exits\n      using an exception ... void terminate(); is called.  */\n-  return build_call (terminate_node, NULL_TREE);\n+  return build_call_n (terminate_node, 0);\n }\n \n static tree"}, {"sha": "679be2067e67108e60a22b49139a0e60e354c123", "filename": "gcc/cp/init.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94a0dd7b599e1d83b81f007258af2b16e7cbc4c5/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94a0dd7b599e1d83b81f007258af2b16e7cbc4c5/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=94a0dd7b599e1d83b81f007258af2b16e7cbc4c5", "patch": "@@ -1540,7 +1540,7 @@ static tree\n build_builtin_delete_call (tree addr)\n {\n   mark_used (global_delete_fndecl);\n-  return build_call (global_delete_fndecl, build_tree_list (NULL_TREE, addr));\n+  return build_call_n (global_delete_fndecl, 1, addr);\n }\n \f\n /* Build and return a NEW_EXPR.  If NELTS is non-NULL, TYPE[NELTS] is"}, {"sha": "4dff5b9026aaea04d4164eae21beaf9ba7c39266", "filename": "gcc/cp/method.c", "status": "modified", "additions": 27, "deletions": 5, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94a0dd7b599e1d83b81f007258af2b16e7cbc4c5/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94a0dd7b599e1d83b81f007258af2b16e7cbc4c5/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=94a0dd7b599e1d83b81f007258af2b16e7cbc4c5", "patch": "@@ -452,6 +452,8 @@ use_thunk (tree thunk_fndecl, bool emit_p)\n     }\n   else\n     {\n+      int i;\n+      tree *argarray = (tree *) alloca (list_length (a) * sizeof (tree));\n       /* If this is a covariant thunk, or we don't have the necessary\n \t code for efficient thunks, generate a thunk function that\n \t just makes a call to the real function.  Unfortunately, this\n@@ -475,11 +477,10 @@ use_thunk (tree thunk_fndecl, bool emit_p)\n \t\t\t  fixed_offset, virtual_offset);\n \n       /* Build up the call to the real function.  */\n-      t = tree_cons (NULL_TREE, t, NULL_TREE);\n-      for (a = TREE_CHAIN (a); a; a = TREE_CHAIN (a))\n-\tt = tree_cons (NULL_TREE, a, t);\n-      t = nreverse (t);\n-      t = build_call (alias, t);\n+      argarray[0] = t;\n+      for (i = 1, a = TREE_CHAIN (a); a; a = TREE_CHAIN (a), i++)\n+\targarray[i] = a;\n+      t = build_call_a (alias, i, argarray);\n       CALL_FROM_THUNK_P (t) = 1;\n \n       if (VOID_TYPE_P (TREE_TYPE (t)))\n@@ -1191,4 +1192,25 @@ skip_artificial_parms_for (tree fn, tree list)\n   return list;\n }\n \n+/* Given a FUNCTION_DECL FN and a chain LIST, return the number of\n+   artificial parms in FN.  */\n+\n+int\n+num_artificial_parms_for (tree fn)\n+{\n+  int count = 0;\n+\n+  if (DECL_NONSTATIC_MEMBER_FUNCTION_P (fn))\n+    count++;\n+  else\n+    return 0;\n+\n+  if (DECL_HAS_IN_CHARGE_PARM_P (fn))\n+    count++;\n+  if (DECL_HAS_VTT_PARM_P (fn))\n+    count++;\n+  return count;\n+}\n+\n+\n #include \"gt-cp-method.h\""}, {"sha": "121699f669d7afa6550ecc574afbc6054a08b834", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94a0dd7b599e1d83b81f007258af2b16e7cbc4c5/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94a0dd7b599e1d83b81f007258af2b16e7cbc4c5/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=94a0dd7b599e1d83b81f007258af2b16e7cbc4c5", "patch": "@@ -196,7 +196,7 @@ throw_bad_cast (void)\n     fn = push_throw_library_fn (fn, build_function_type (ptr_type_node,\n \t\t\t\t\t\t\t void_list_node));\n \n-  return build_cxx_call (fn, NULL_TREE);\n+  return build_cxx_call (fn, 0, NULL);\n }\n \n /* Return an expression for \"__cxa_bad_typeid()\".  The expression\n@@ -215,7 +215,7 @@ throw_bad_typeid (void)\n       fn = push_throw_library_fn (fn, t);\n     }\n \n-  return build_cxx_call (fn, NULL_TREE);\n+  return build_cxx_call (fn, 0, NULL);\n }\n \f\n /* Return an lvalue expression whose type is \"const std::type_info\"\n@@ -588,7 +588,8 @@ build_dynamic_cast_1 (tree type, tree expr)\n       else\n \t{\n \t  tree retval;\n-\t  tree result, td2, td3, elems;\n+\t  tree result, td2, td3;\n+\t  tree elems[4];\n \t  tree static_type, target_type, boff;\n \n \t  /* If we got here, we can't convert statically.  Therefore,\n@@ -646,11 +647,10 @@ build_dynamic_cast_1 (tree type, tree expr)\n \t  if (tc == REFERENCE_TYPE)\n \t    expr1 = build_unary_op (ADDR_EXPR, expr1, 0);\n \n-\t  elems = tree_cons\n-\t    (NULL_TREE, expr1, tree_cons\n-\t     (NULL_TREE, td3, tree_cons\n-\t      (NULL_TREE, td2, tree_cons\n-\t       (NULL_TREE, boff, NULL_TREE))));\n+\t  elems[0] = expr1;\n+\t  elems[1] = td3;\n+\t  elems[2] = td2;\n+\t  elems[3] = boff;\n \n \t  dcast_fn = dynamic_cast_node;\n \t  if (!dcast_fn)\n@@ -680,7 +680,7 @@ build_dynamic_cast_1 (tree type, tree expr)\n \t      pop_nested_namespace (ns);\n \t      dynamic_cast_node = dcast_fn;\n \t    }\n-\t  result = build_cxx_call (dcast_fn, elems);\n+\t  result = build_cxx_call (dcast_fn, 4, elems);\n \n \t  if (tc == REFERENCE_TYPE)\n \t    {"}, {"sha": "b8ae880440dfdfc05963ef31efea85f61f724f27", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 38, "deletions": 29, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94a0dd7b599e1d83b81f007258af2b16e7cbc4c5/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94a0dd7b599e1d83b81f007258af2b16e7cbc4c5/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=94a0dd7b599e1d83b81f007258af2b16e7cbc4c5", "patch": "@@ -60,7 +60,7 @@ static void casts_away_constness_r (tree *, tree *);\n static bool casts_away_constness (tree, tree);\n static void maybe_warn_about_returning_address_of_local (tree);\n static tree lookup_destructor (tree, tree, tree);\n-static tree convert_arguments (tree, tree, tree, int);\n+static int convert_arguments (int, tree *, tree, tree, tree, int);\n \n /* Do `exp = require_complete_type (exp);' to make sure exp\n    does not have an incomplete type.  (That includes void types.)\n@@ -2670,10 +2670,12 @@ tree\n build_function_call (tree function, tree params)\n {\n   tree fntype, fndecl;\n-  tree coerced_params;\n   tree name = NULL_TREE;\n   int is_method;\n   tree original = function;\n+  int nargs, parm_types_len;\n+  tree *argarray;\n+  tree parm_types;\n \n   /* For Objective-C, convert any calls via a cast to OBJC_TYPE_REF\n      expressions, like those used for ObjC messenger dispatches.  */\n@@ -2739,46 +2741,56 @@ build_function_call (tree function, tree params)\n \n   /* fntype now gets the type of function pointed to.  */\n   fntype = TREE_TYPE (fntype);\n+  parm_types = TYPE_ARG_TYPES (fntype);\n+\n+  /* Allocate storage for converted arguments.  */\n+  parm_types_len = list_length (parm_types);\n+  nargs = list_length (params);\n+  if (parm_types_len > nargs)\n+    nargs = parm_types_len;\n+  argarray = (tree *) alloca (nargs * sizeof (tree));\n \n   /* Convert the parameters to the types declared in the\n      function prototype, or apply default promotions.  */\n-\n-  coerced_params = convert_arguments (TYPE_ARG_TYPES (fntype),\n-\t\t\t\t      params, fndecl, LOOKUP_NORMAL);\n-  if (coerced_params == error_mark_node)\n+  nargs = convert_arguments (nargs, argarray, parm_types,\n+\t\t\t     params, fndecl, LOOKUP_NORMAL);\n+  if (nargs < 0)\n     return error_mark_node;\n \n   /* Check for errors in format strings and inappropriately\n      null parameters.  */\n \n-  check_function_arguments (TYPE_ATTRIBUTES (fntype), coerced_params,\n-\t\t\t    TYPE_ARG_TYPES (fntype));\n+  check_function_arguments (TYPE_ATTRIBUTES (fntype), nargs, argarray,\n+\t\t\t    parm_types);\n \n-  return build_cxx_call (function, coerced_params);\n+  return build_cxx_call (function, nargs, argarray);\n }\n \f\n /* Convert the actual parameter expressions in the list VALUES\n    to the types in the list TYPELIST.\n    If parmdecls is exhausted, or when an element has NULL as its type,\n    perform the default conversions.\n \n+   Store the converted arguments in ARGARRAY.  NARGS is the size of this array.\n+\n    NAME is an IDENTIFIER_NODE or 0.  It is used only for error messages.\n \n    This is also where warnings about wrong number of args are generated.\n \n-   Return a list of expressions for the parameters as converted.\n+   Returns the actual number of arguments processed (which might be less\n+   than NARGS), or -1 on error.\n \n-   Both VALUES and the returned value are chains of TREE_LIST nodes\n-   with the elements of the list in the TREE_VALUE slots of those nodes.\n+   VALUES is a chain of TREE_LIST nodes with the elements of the list\n+   in the TREE_VALUE slots of those nodes.\n \n    In C++, unspecified trailing parameters can be filled in with their\n    default arguments, if such were specified.  Do so here.  */\n \n-static tree\n-convert_arguments (tree typelist, tree values, tree fndecl, int flags)\n+static int\n+convert_arguments (int nargs, tree *argarray,\n+\t\t   tree typelist, tree values, tree fndecl, int flags)\n {\n   tree typetail, valtail;\n-  tree result = NULL_TREE;\n   const char *called_thing = 0;\n   int i = 0;\n \n@@ -2807,7 +2819,7 @@ convert_arguments (tree typelist, tree values, tree fndecl, int flags)\n       tree val = TREE_VALUE (valtail);\n \n       if (val == error_mark_node || type == error_mark_node)\n-\treturn error_mark_node;\n+\treturn -1;\n \n       if (type == void_type_node)\n \t{\n@@ -2818,11 +2830,7 @@ convert_arguments (tree typelist, tree values, tree fndecl, int flags)\n \t    }\n \t  else\n \t    error (\"too many arguments to function\");\n-\t  /* In case anybody wants to know if this argument\n-\t     list is valid.  */\n-\t  if (result)\n-\t    TREE_TYPE (tree_last (result)) = error_mark_node;\n-\t  break;\n+\t  return i;\n \t}\n \n       /* build_c_cast puts on a NOP_EXPR to make the result not an lvalue.\n@@ -2841,7 +2849,7 @@ convert_arguments (tree typelist, tree values, tree fndecl, int flags)\n \t}\n \n       if (val == error_mark_node)\n-\treturn error_mark_node;\n+\treturn -1;\n \n       if (type != 0)\n \t{\n@@ -2866,9 +2874,9 @@ convert_arguments (tree typelist, tree values, tree fndecl, int flags)\n \t    }\n \n \t  if (parmval == error_mark_node)\n-\t    return error_mark_node;\n+\t    return -1;\n \n-\t  result = tree_cons (NULL_TREE, parmval, result);\n+\t  argarray[i] = parmval;\n \t}\n       else\n \t{\n@@ -2881,7 +2889,7 @@ convert_arguments (tree typelist, tree values, tree fndecl, int flags)\n \t  else\n \t    val = convert_arg_to_ellipsis (val);\n \n-\t  result = tree_cons (NULL_TREE, val, result);\n+\t  argarray[i] = val;\n \t}\n \n       if (typetail)\n@@ -2902,9 +2910,9 @@ convert_arguments (tree typelist, tree values, tree fndecl, int flags)\n \t\t\t\t       fndecl, i);\n \n \t      if (parmval == error_mark_node)\n-\t\treturn error_mark_node;\n+\t\treturn -1;\n \n-\t      result = tree_cons (0, parmval, result);\n+\t      argarray[i] = parmval;\n \t      typetail = TREE_CHAIN (typetail);\n \t      /* ends with `...'.  */\n \t      if (typetail == NULL_TREE)\n@@ -2920,11 +2928,12 @@ convert_arguments (tree typelist, tree values, tree fndecl, int flags)\n \t    }\n \t  else\n \t    error (\"too few arguments to function\");\n-\t  return error_mark_node;\n+\t  return -1;\n \t}\n     }\n \n-  return nreverse (result);\n+  gcc_assert (i <= nargs);\n+  return i;\n }\n \f\n /* Build a binary-operation expression, after performing default"}, {"sha": "f1f4c2cb296a1a58167d81acd18e41a9274a64fe", "filename": "gcc/fold-const.c", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94a0dd7b599e1d83b81f007258af2b16e7cbc4c5/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94a0dd7b599e1d83b81f007258af2b16e7cbc4c5/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=94a0dd7b599e1d83b81f007258af2b16e7cbc4c5", "patch": "@@ -12875,13 +12875,13 @@ fold_build3_stat (enum tree_code code, tree type, tree op0, tree op1, tree op2\n   return tem;\n }\n \n-/* Fold a CALL_EXPR expression of type TYPE with operands FN and ARGLIST\n-   and a null static chain.\n+/* Fold a CALL_EXPR expression of type TYPE with operands FN and NARGS\n+   arguments in ARGARRAY, and a null static chain.\n    Return a folded expression if successful.  Otherwise, return a CALL_EXPR\n-   of type TYPE from the given operands as constructed by build_call_list.  */\n+   of type TYPE from the given operands as constructed by build_call_array.  */\n \n tree\n-fold_build_call_list (tree type, tree fn, tree arglist)\n+fold_build_call_array (tree type, tree fn, int nargs, tree *argarray)\n {\n   tree tem;\n #ifdef ENABLE_FOLD_CHECKING\n@@ -12891,6 +12891,7 @@ fold_build_call_list (tree type, tree fn, tree arglist)\n \t\tchecksum_after_arglist[16];\n   struct md5_ctx ctx;\n   htab_t ht;\n+  int i;\n \n   ht = htab_create (32, htab_hash_pointer, htab_eq_pointer, NULL);\n   md5_init_ctx (&ctx);\n@@ -12899,12 +12900,13 @@ fold_build_call_list (tree type, tree fn, tree arglist)\n   htab_empty (ht);\n \n   md5_init_ctx (&ctx);\n-  fold_checksum_tree (arglist, &ctx, ht);\n+  for (i = 0; i < nargs; i++)\n+    fold_checksum_tree (argarray[i], &ctx, ht);\n   md5_finish_ctx (&ctx, checksum_before_arglist);\n   htab_empty (ht);\n #endif\n \n-  tem = fold_builtin_call_list (type, fn, arglist);\n+  tem = fold_builtin_call_array (type, fn, nargs, argarray);\n       \n #ifdef ENABLE_FOLD_CHECKING\n   md5_init_ctx (&ctx);\n@@ -12916,12 +12918,13 @@ fold_build_call_list (tree type, tree fn, tree arglist)\n     fold_check_failed (fn, tem);\n   \n   md5_init_ctx (&ctx);\n-  fold_checksum_tree (arglist, &ctx, ht);\n+  for (i = 0; i < nargs; i++)\n+    fold_checksum_tree (argarray[i], &ctx, ht);\n   md5_finish_ctx (&ctx, checksum_after_arglist);\n   htab_delete (ht);\n \n   if (memcmp (checksum_before_arglist, checksum_after_arglist, 16))\n-    fold_check_failed (arglist, tem);\n+    fold_check_failed (NULL_TREE, tem);\n #endif\n   return tem;\n }\n@@ -12987,12 +12990,13 @@ fold_build3_initializer (enum tree_code code, tree type, tree op0, tree op1,\n }\n \n tree\n-fold_build_call_list_initializer (tree type, tree fn, tree arglist)\n+fold_build_call_array_initializer (tree type, tree fn,\n+\t\t\t\t   int nargs, tree *argarray)\n {\n   tree result;\n   START_FOLD_INIT;\n \n-  result = fold_build_call_list (type, fn, arglist);\n+  result = fold_build_call_array (type, fn, nargs, argarray);\n \n   END_FOLD_INIT;\n   return result;"}, {"sha": "69690ee3550e3bfab9645a648590a849f2423e05", "filename": "gcc/tree.h", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94a0dd7b599e1d83b81f007258af2b16e7cbc4c5/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94a0dd7b599e1d83b81f007258af2b16e7cbc4c5/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=94a0dd7b599e1d83b81f007258af2b16e7cbc4c5", "patch": "@@ -4397,8 +4397,8 @@ extern tree fold_build3_stat (enum tree_code, tree, tree, tree, tree MEM_STAT_DE\n extern tree fold_build1_initializer (enum tree_code, tree, tree);\n extern tree fold_build2_initializer (enum tree_code, tree, tree, tree);\n extern tree fold_build3_initializer (enum tree_code, tree, tree, tree, tree);\n-extern tree fold_build_call_list (tree, tree, tree);\n-extern tree fold_build_call_list_initializer (tree, tree, tree);\n+extern tree fold_build_call_array (tree, tree, int, tree *);\n+extern tree fold_build_call_array_initializer (tree, tree, int, tree *);\n extern tree fold_convert (tree, tree);\n extern tree fold_single_bit_test (enum tree_code, tree, tree, tree);\n extern tree fold_ignored_result (tree);\n@@ -4497,8 +4497,7 @@ extern bool fold_builtin_next_arg (tree, bool);\n extern enum built_in_function builtin_mathfn_code (tree);\n extern tree build_function_call_expr (tree, tree);\n extern tree fold_build_call_expr (tree, tree, tree, tree);\n-extern tree fold_builtin_call_list (tree, tree, tree);\n-extern tree fold_builtin_call_valist (tree, tree, int, va_list);\n+extern tree fold_builtin_call_array (tree, tree, int, tree *);\n extern tree build_call_expr (tree, int, ...);\n extern tree mathfn_built_in (tree, enum built_in_function fn);\n extern tree strip_float_extensions (tree);"}]}