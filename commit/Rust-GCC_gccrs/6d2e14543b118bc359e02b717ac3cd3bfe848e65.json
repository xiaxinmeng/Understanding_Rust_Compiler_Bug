{"sha": "6d2e14543b118bc359e02b717ac3cd3bfe848e65", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmQyZTE0NTQzYjExOGJjMzU5ZTAyYjcxN2FjM2NkM2JmZTg0OGU2NQ==", "commit": {"author": {"name": "Joseph Myers", "email": "jsm28@cam.ac.uk", "date": "2000-10-16T16:16:57Z"}, "committer": {"name": "Joseph Myers", "email": "jsm28@gcc.gnu.org", "date": "2000-10-16T16:16:57Z"}, "message": "c-common.c (format_check_results): New structure.\n\n\t* c-common.c (format_check_results): New structure.\n\t(finish_dollar_format_checking): Adjust to take a\n\tformat_check_results * parameter.\n\t(check_format_info, check_format_info_recurse,\n\tcheck_format_info_main): Split check_format_info into three\n\tfunctions, the main checking going in check_format_info_main.\n\tRecurse when any reduction of the format string argument towards a\n\tstring literal is done; go down both branches of a conditional\n\texpression.  Don't warn for extra format arguments or empty format\n\tstrings if they only occur in some branches of a conditional\n\texpression.\n\ntestsuite:\n\t* gcc.dg/format-branch-1.c: New test.\n\nFrom-SVN: r36883", "tree": {"sha": "c38b5f553608d53530f6f9c8511b34ab9e116067", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c38b5f553608d53530f6f9c8511b34ab9e116067"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6d2e14543b118bc359e02b717ac3cd3bfe848e65", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d2e14543b118bc359e02b717ac3cd3bfe848e65", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6d2e14543b118bc359e02b717ac3cd3bfe848e65", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d2e14543b118bc359e02b717ac3cd3bfe848e65/comments", "author": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "406df25cbe134981a6f017739a268d2b04581ac5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/406df25cbe134981a6f017739a268d2b04581ac5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/406df25cbe134981a6f017739a268d2b04581ac5"}], "stats": {"total": 349, "additions": 282, "deletions": 67}, "files": [{"sha": "f163b623a26e91b74e3c98b95359869c96439238", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d2e14543b118bc359e02b717ac3cd3bfe848e65/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d2e14543b118bc359e02b717ac3cd3bfe848e65/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6d2e14543b118bc359e02b717ac3cd3bfe848e65", "patch": "@@ -1,3 +1,17 @@\n+2000-10-16  Joseph S. Myers  <jsm28@cam.ac.uk>\n+\n+\t* c-common.c (format_check_results): New structure.\n+\t(finish_dollar_format_checking): Adjust to take a\n+\tformat_check_results * parameter.\n+\t(check_format_info, check_format_info_recurse,\n+\tcheck_format_info_main): Split check_format_info into three\n+\tfunctions, the main checking going in check_format_info_main.\n+\tRecurse when any reduction of the format string argument towards a\n+\tstring literal is done; go down both branches of a conditional\n+\texpression.  Don't warn for extra format arguments or empty format\n+\tstrings if they only occur in some branches of a conditional\n+\texpression.\n+\n 2000-10-16  Kazu Hirata  <kazu@hxi.com>\n \n \t* config/h8300/h8300.c: Remove obstack."}, {"sha": "3b88f187118946c86b3357210932a53f9394bfd9", "filename": "gcc/c-common.c", "status": "modified", "additions": 235, "deletions": 67, "changes": 302, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d2e14543b118bc359e02b717ac3cd3bfe848e65/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d2e14543b118bc359e02b717ac3cd3bfe848e65/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=6d2e14543b118bc359e02b717ac3cd3bfe848e65", "patch": "@@ -1726,14 +1726,47 @@ typedef struct international_format_info\n \n static international_format_info *international_format_list = NULL;\n \n+/* Structure detailing the results of checking a format function call\n+   where the format expression may be a conditional expression with\n+   many leaves resulting from nested conditional expressions.  */\n+typedef struct\n+{\n+  /* Number of leaves of the format argument that could not be checked\n+     as they were not string literals.  */\n+  int number_non_literal;\n+  /* Number of leaves of the format argument that were null pointers or\n+     string literals, but had extra format arguments.  */\n+  int number_extra_args;\n+  /* Number of leaves of the format argument that were null pointers or\n+     string literals, but had extra format arguments and used $ operand\n+     numbers.  */\n+  int number_dollar_extra_args;\n+  /* Number of leaves of the format argument that were wide string\n+     literals.  */\n+  int number_wide;\n+  /* Number of leaves of the format argument that were empty strings.  */\n+  int number_empty;\n+  /* Number of leaves of the format argument that were unterminated\n+     strings.  */\n+  int number_unterminated;\n+  /* Number of leaves of the format argument that were not counted above.  */\n+  int number_other;\n+} format_check_results;\n+\n static void check_format_info\tPARAMS ((int *, function_format_info *, tree));\n+static void check_format_info_recurse PARAMS ((int *, format_check_results *,\n+\t\t\t\t\t       function_format_info *, tree,\n+\t\t\t\t\t       tree, int));\n+static void check_format_info_main PARAMS ((int *, format_check_results *,\n+\t\t\t\t\t    function_format_info *,\n+\t\t\t\t\t    const char *, int, tree, int));\n static void status_warning PARAMS ((int *, const char *, ...))\n      ATTRIBUTE_PRINTF_2;\n \n static void init_dollar_format_checking\t\tPARAMS ((int, tree));\n static int maybe_read_dollar_number\t\tPARAMS ((int *, const char **, int,\n \t\t\t\t\t\t\t tree, tree *));\n-static void finish_dollar_format_checking\tPARAMS ((int *));\n+static void finish_dollar_format_checking\tPARAMS ((int *, format_check_results *));\n \n static const format_flag_spec *get_flag_spec\tPARAMS ((const format_flag_spec *,\n \t\t\t\t\t\t\t int, const char *));\n@@ -2102,8 +2135,9 @@ maybe_read_dollar_number (status, format, dollar_needed, params, param_ptr)\n    here.  */\n \n static void\n-finish_dollar_format_checking (status)\n+finish_dollar_format_checking (status, res)\n      int *status;\n+     format_check_results *res;\n {\n   int i;\n   for (i = 0; i < dollar_max_arg_used; i++)\n@@ -2113,7 +2147,10 @@ finish_dollar_format_checking (status)\n \t\t i + 1, dollar_max_arg_used);\n     }\n   if (dollar_first_arg_num && dollar_max_arg_used < dollar_arguments_count)\n-    status_warning (status, \"unused arguments in $-style format\");\n+    {\n+      res->number_other--;\n+      res->number_dollar_extra_args++;\n+    }\n }\n \n \n@@ -2162,38 +2199,9 @@ check_format_info (status, info, params)\n      function_format_info *info;\n      tree params;\n {\n-  int i;\n   int arg_num;\n-  int suppressed;\n-  const char *length_chars = NULL;\n-  enum format_lengths length_chars_val = FMT_LEN_none;\n-  enum format_std_version length_chars_std = STD_C89;\n-  int format_char;\n-  int format_length;\n   tree format_tree;\n-  tree cur_param;\n-  tree wanted_type;\n-  int main_arg_num;\n-  tree main_arg_params;\n-  enum format_std_version wanted_type_std;\n-  const char *wanted_type_name;\n-  format_wanted_type width_wanted_type;\n-  format_wanted_type precision_wanted_type;\n-  format_wanted_type main_wanted_type;\n-  format_wanted_type *first_wanted_type;\n-  format_wanted_type *last_wanted_type;\n-  tree first_fillin_param;\n-  const char *format_chars;\n-  const format_kind_info *fki = NULL;\n-  const format_flag_spec *flag_specs = NULL;\n-  const format_flag_pair *bad_flag_pairs = NULL;\n-  const format_length_info *fli = NULL;\n-  const format_char_info *fci = NULL;\n-  char flag_chars[256];\n-  /* -1 if no conversions taking an operand have been found; 0 if one has\n-     and it didn't use $; 1 if $ formats are in use.  */\n-  int has_operand_number = -1;\n-\n+  format_check_results res;\n   /* Skip to format argument.  If the argument isn't available, there's\n      no work for us to do; prototype checking will catch the problem.  */\n   for (arg_num = 1; ; ++arg_num)\n@@ -2209,9 +2217,75 @@ check_format_info (status, info, params)\n   if (format_tree == 0)\n     return;\n \n-  /* We can only check the format if it's a string constant.  */\n-  while (TREE_CODE (format_tree) == NOP_EXPR)\n-    format_tree = TREE_OPERAND (format_tree, 0); /* strip coercion */\n+  res.number_non_literal = 0;\n+  res.number_extra_args = 0;\n+  res.number_dollar_extra_args = 0;\n+  res.number_wide = 0;\n+  res.number_empty = 0;\n+  res.number_unterminated = 0;\n+  res.number_other = 0;\n+\n+  check_format_info_recurse (status, &res, info, format_tree, params, arg_num);\n+\n+  if (res.number_non_literal > 0)\n+    {\n+      /* Functions taking a va_list normally pass a non-literal format\n+\t string.  These functions typically are declared with\n+\t first_arg_num == 0, so avoid warning in those cases.  */\n+      if (info->first_arg_num != 0 && warn_format > 1)\n+\tstatus_warning (status, \"format not a string literal, argument types not checked\");\n+    }\n+\n+  /* If there were extra arguments to the format, normally warn.  However,\n+     the standard does say extra arguments are ignored, so in the specific\n+     case where we have multiple leaves (conditional expressions or\n+     ngettext) allow extra arguments if at least one leaf didn't have extra\n+     arguments, but was otherwise OK (either non-literal or checked OK).\n+     If the format is an empty string, this should be counted similarly to the\n+     case of extra format arguments.  */\n+  if (res.number_extra_args > 0 && res.number_non_literal == 0\n+      && res.number_other == 0)\n+    status_warning (status, \"too many arguments for format\");\n+  if (res.number_dollar_extra_args > 0 && res.number_non_literal == 0\n+      && res.number_other == 0)\n+    status_warning (status, \"unused arguments in $-style format\");\n+  if (res.number_empty > 0 && res.number_non_literal == 0\n+      && res.number_other == 0)\n+    status_warning (status, \"zero-length format string\");\n+\n+  if (res.number_wide > 0)\n+    status_warning (status, \"format is a wide character string\");\n+\n+  if (res.number_unterminated > 0)\n+    status_warning (status, \"unterminated format string\");\n+}\n+\n+\n+/* Recursively check a call to a format function.  FORMAT_TREE is the\n+   format parameter, which may be a conditional expression in which\n+   both halves should be checked.  ARG_NUM is the number of the\n+   format argument; PARAMS points just after it in the argument list.  */\n+\n+static void\n+check_format_info_recurse (status, res, info, format_tree, params, arg_num)\n+     int *status;\n+     format_check_results *res;\n+     function_format_info *info;\n+     tree format_tree;\n+     tree params;\n+     int arg_num;\n+{\n+  int format_length;\n+  const char *format_chars;\n+\n+  if (TREE_CODE (format_tree) == NOP_EXPR)\n+    {\n+      /* Strip coercion.  */\n+      check_format_info_recurse (status, res, info,\n+\t\t\t\t TREE_OPERAND (format_tree, 0), params,\n+\t\t\t\t arg_num);\n+      return;\n+    }\n \n   if (TREE_CODE (format_tree) == CALL_EXPR\n       && TREE_CODE (TREE_OPERAND (format_tree, 0)) == ADDR_EXPR\n@@ -2222,71 +2296,107 @@ check_format_info (status, info, params)\n \n       /* See if this is a call to a known internationalization function\n \t that modifies the format arg.  */\n-      international_format_info *info;\n+      international_format_info *iinfo;\n \n-      for (info = international_format_list; info; info = info->next)\n-\tif (info->assembler_name\n-\t    ? (info->assembler_name == DECL_ASSEMBLER_NAME (function))\n-\t    : (info->name == DECL_NAME (function)))\n+      for (iinfo = international_format_list; iinfo; iinfo = iinfo->next)\n+\tif (iinfo->assembler_name\n+\t    ? (iinfo->assembler_name == DECL_ASSEMBLER_NAME (function))\n+\t    : (iinfo->name == DECL_NAME (function)))\n \t  {\n \t    tree inner_args;\n \t    int i;\n \n \t    for (inner_args = TREE_OPERAND (format_tree, 1), i = 1;\n \t\t inner_args != 0;\n \t\t inner_args = TREE_CHAIN (inner_args), i++)\n-\t      if (i == info->format_num)\n+\t      if (i == iinfo->format_num)\n \t\t{\n-\t\t  format_tree = TREE_VALUE (inner_args);\n-\n-\t\t  while (TREE_CODE (format_tree) == NOP_EXPR)\n-\t\t    format_tree = TREE_OPERAND (format_tree, 0);\n+\t\t  /* FIXME: with Marc Espie's __attribute__((nonnull))\n+\t\t     patch in GCC, we will have chained attributes,\n+\t\t     and be able to handle functions like ngettext\n+\t\t     with multiple format_arg attributes properly.  */\n+\t\t  check_format_info_recurse (status, res, info,\n+\t\t\t\t\t     TREE_VALUE (inner_args), params,\n+\t\t\t\t\t     arg_num);\n+\t\t  return;\n \t\t}\n \t  }\n     }\n \n+  if (TREE_CODE (format_tree) == COND_EXPR)\n+    {\n+      /* Check both halves of the conditional expression.  */\n+      check_format_info_recurse (status, res, info,\n+\t\t\t\t TREE_OPERAND (format_tree, 1), params,\n+\t\t\t\t arg_num);\n+      check_format_info_recurse (status, res, info,\n+\t\t\t\t TREE_OPERAND (format_tree, 2), params,\n+\t\t\t\t arg_num);\n+      return;\n+    }\n+\n   if (integer_zerop (format_tree))\n     {\n+      /* FIXME: this warning should go away once Marc Espie's\n+\t __attribute__((nonnull)) patch is in.  Instead, checking for\n+\t nonnull attributes should probably change this function to act\n+\t specially if info == NULL and add a res->number_null entry for\n+\t that case, or maybe add a function pointer to be called at\n+\t the end instead of hardcoding check_format_info_main.  */\n       status_warning (status, \"null format string\");\n+\n+      /* Skip to first argument to check, so we can see if this format\n+\t has any arguments (it shouldn't).  */\n+      while (arg_num + 1 < info->first_arg_num)\n+\t{\n+\t  if (params == 0)\n+\t    return;\n+\t  params = TREE_CHAIN (params);\n+\t  ++arg_num;\n+\t}\n+\n+      if (params == 0)\n+\tres->number_other++;\n+      else\n+\tres->number_extra_args++;\n+\n       return;\n     }\n+\n   if (TREE_CODE (format_tree) != ADDR_EXPR)\n     {\n-      /* The user may get multiple warnings if the supplied argument\n-\t isn't even a string pointer.  */\n-      /* Functions taking a va_list normally pass a non-literal format\n-\t string.  These functions typically are declared with\n-\t first_arg_num == 0, so avoid warning in those cases.  */\n-      if (info->first_arg_num != 0 && warn_format > 1)\n-\tstatus_warning (status, \"format not a string literal, argument types not checked\");\n+      res->number_non_literal++;\n       return;\n     }\n   format_tree = TREE_OPERAND (format_tree, 0);\n   if (TREE_CODE (format_tree) != STRING_CST)\n     {\n-      /* The user may get multiple warnings if the supplied argument\n-\t isn't even a string pointer.  */\n-      /* Functions taking a va_list normally pass a non-literal format\n-\t string.  These functions typically are declared with\n-\t first_arg_num == 0, so avoid warning in those cases.  */\n-      if (info->first_arg_num != 0 && warn_format > 1)\n-\tstatus_warning (status, \"format not a string literal, argument types not checked\");\n+      res->number_non_literal++;\n       return;\n     }\n   if (TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (format_tree))) != char_type_node)\n     {\n-      status_warning (status, \"format is a wide character string\");\n+      res->number_wide++;\n       return;\n     }\n   format_chars = TREE_STRING_POINTER (format_tree);\n   format_length = TREE_STRING_LENGTH (format_tree);\n-  if (format_length <= 1)\n-    status_warning (status, \"zero-length format string\");\n+  if (format_length < 1)\n+    {\n+      res->number_unterminated++;\n+      return;\n+    }\n+  if (format_length == 1)\n+    {\n+      res->number_empty++;\n+      return;\n+    }\n   if (format_chars[--format_length] != 0)\n     {\n-      status_warning (status, \"unterminated format string\");\n+      res->number_unterminated++;\n       return;\n     }\n+\n   /* Skip to first argument to check.  */\n   while (arg_num + 1 < info->first_arg_num)\n     {\n@@ -2295,6 +2405,61 @@ check_format_info (status, info, params)\n       params = TREE_CHAIN (params);\n       ++arg_num;\n     }\n+  /* Provisionally increment res->number_other; check_format_info_main\n+     will decrement it if it finds there are extra arguments, but this way\n+     need not adjust it for every return.  */\n+  res->number_other++;\n+  check_format_info_main (status, res, info, format_chars, format_length,\n+\t\t\t  params, arg_num);\n+}\n+\n+\n+/* Do the main part of checking a call to a format function.  FORMAT_CHARS\n+   is the NUL-terminated format string (which at this point may contain\n+   internal NUL characters); FORMAT_LENGTH is its length (excluding the\n+   terminating NUL character).  ARG_NUM is one less than the number of\n+   the first format argument to check; PARAMS points to that format\n+   argument in the list of arguments.  */\n+\n+static void\n+check_format_info_main (status, res, info, format_chars, format_length,\n+\t\t\tparams, arg_num)\n+     int *status;\n+     format_check_results *res;\n+     function_format_info *info;\n+     const char *format_chars;\n+     int format_length;\n+     tree params;\n+     int arg_num;\n+{\n+  int i;\n+  int suppressed;\n+  const char *length_chars = NULL;\n+  enum format_lengths length_chars_val = FMT_LEN_none;\n+  enum format_std_version length_chars_std = STD_C89;\n+  int format_char;\n+  const char *orig_format_chars = format_chars;\n+  tree cur_param;\n+  tree wanted_type;\n+  int main_arg_num;\n+  tree main_arg_params;\n+  enum format_std_version wanted_type_std;\n+  const char *wanted_type_name;\n+  format_wanted_type width_wanted_type;\n+  format_wanted_type precision_wanted_type;\n+  format_wanted_type main_wanted_type;\n+  format_wanted_type *first_wanted_type;\n+  format_wanted_type *last_wanted_type;\n+  tree first_fillin_param;\n+  const format_kind_info *fki = NULL;\n+  const format_flag_spec *flag_specs = NULL;\n+  const format_flag_pair *bad_flag_pairs = NULL;\n+  const format_length_info *fli = NULL;\n+  const format_char_info *fci = NULL;\n+  char flag_chars[256];\n+  /* -1 if no conversions taking an operand have been found; 0 if one has\n+     and it didn't use $; 1 if $ formats are in use.  */\n+  int has_operand_number = -1;\n \n   first_fillin_param = params;\n   init_dollar_format_checking (info->first_arg_num, first_fillin_param);\n@@ -2308,13 +2473,16 @@ check_format_info (status, info, params)\n       last_wanted_type = NULL;\n       if (*format_chars == 0)\n \t{\n-\t  if (format_chars - TREE_STRING_POINTER (format_tree) != format_length)\n+\t  if (format_chars - orig_format_chars != format_length)\n \t    status_warning (status, \"embedded `\\\\0' in format\");\n \t  if (info->first_arg_num != 0 && params != 0\n \t      && has_operand_number <= 0)\n-\t    status_warning (status, \"too many arguments for format\");\n+\t    {\n+\t      res->number_other--;\n+\t      res->number_extra_args++;\n+\t    }\n \t  if (has_operand_number > 0)\n-\t    finish_dollar_format_checking (status);\n+\t    finish_dollar_format_checking (status, res);\n \t  return;\n \t}\n       if (*format_chars++ != '%')"}, {"sha": "d03fd985ab941d3473a5a23585028a12aa44291a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d2e14543b118bc359e02b717ac3cd3bfe848e65/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d2e14543b118bc359e02b717ac3cd3bfe848e65/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=6d2e14543b118bc359e02b717ac3cd3bfe848e65", "patch": "@@ -1,3 +1,7 @@\n+2000-10-16  Joseph S. Myers  <jsm28@cam.ac.uk>\n+\n+\t* gcc.dg/format-branch-1.c: New test.\n+\n 2000-10-16  Joseph S. Myers  <jsm28@cam.ac.uk>\n \n \t* README, lib/file-format.exp: Remove EGCS references."}, {"sha": "6ff41311b75d2e0b0972be19f957fb3aae90b621", "filename": "gcc/testsuite/gcc.dg/format-branch-1.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d2e14543b118bc359e02b717ac3cd3bfe848e65/gcc%2Ftestsuite%2Fgcc.dg%2Fformat-branch-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d2e14543b118bc359e02b717ac3cd3bfe848e65/gcc%2Ftestsuite%2Fgcc.dg%2Fformat-branch-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fformat-branch-1.c?ref=6d2e14543b118bc359e02b717ac3cd3bfe848e65", "patch": "@@ -0,0 +1,29 @@\n+/* Test for format checking of conditional expressions.  */\n+/* Origin: Joseph Myers <jsm28@cam.ac.uk> */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=gnu99 -Wformat\" } */\n+\n+#define NULL ((void *)0)\n+\n+extern int printf (const char *, ...);\n+\n+void\n+foo (long l, int nfoo)\n+{\n+  printf ((nfoo > 1) ? \"%d foos\" : \"%d foo\", nfoo);\n+  printf ((l > 1) ? \"%d foos\" : \"%d foo\", l); /* { dg-warning \"int format\" \"wrong type in conditional expr\" } */\n+  printf ((l > 1) ? \"%ld foos\" : \"%d foo\", l); /* { dg-warning \"int format\" \"wrong type in conditional expr\" } */\n+  printf ((l > 1) ? \"%d foos\" : \"%ld foo\", l); /* { dg-warning \"int format\" \"wrong type in conditional expr\" } */\n+  /* Should allow one case to have extra arguments.  */\n+  printf ((nfoo > 1) ? \"%d foos\" : \"1 foo\", nfoo);\n+  printf ((nfoo > 1) ? \"many foos\" : \"1 foo\", nfoo); /* { dg-warning \"too many\" \"too many args in all branches\" } */\n+  printf ((nfoo > 1) ? \"%d foos\" : \"\", nfoo);\n+  printf ((nfoo > 1) ? \"%d foos\" : ((nfoo > 0) ? \"1 foo\" : \"no foos\"), nfoo);\n+  printf ((nfoo > 1) ? \"%d foos\" : ((nfoo > 0) ? \"%d foo\" : \"%d foos\"), nfoo);\n+  printf ((nfoo > 1) ? \"%d foos\" : ((nfoo > 0) ? \"%d foo\" : \"%ld foos\"), nfoo); /* { dg-warning \"long int format\" \"wrong type\" } */\n+  printf ((nfoo > 1) ? \"%ld foos\" : ((nfoo > 0) ? \"%d foo\" : \"%d foos\"), nfoo); /* { dg-warning \"long int format\" \"wrong type\" } */\n+  printf ((nfoo > 1) ? \"%d foos\" : ((nfoo > 0) ? \"%ld foo\" : \"%d foos\"), nfoo); /* { dg-warning \"long int format\" \"wrong type\" } */\n+  /* Extra arguments to NULL should be complained about.  */\n+  printf (NULL, \"foo\"); /* { dg-warning \"too many\" \"NULL extra args\" } */\n+  /* { dg-warning \"null\" \"null format arg\" { target *-*-* } 27 } */\n+}"}]}