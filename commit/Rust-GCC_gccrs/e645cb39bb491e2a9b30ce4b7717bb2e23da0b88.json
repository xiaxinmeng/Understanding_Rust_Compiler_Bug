{"sha": "e645cb39bb491e2a9b30ce4b7717bb2e23da0b88", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTY0NWNiMzliYjQ5MWUyYTliMzBjZTRiNzcxN2JiMmUyM2RhMGI4OA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-11-18T13:53:58Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-11-18T13:53:58Z"}, "message": "[multiple changes]\n\n2015-11-18  Nicolas Roche  <roche@adacore.com>\n\n\t* sysdep.c (__gnat_localtime_tzoff): On Windows platform\n\tGetTimeZoneInformation function is thread-safe. Thus there\n\tis no need to lock the runtime in the implementation of\n\t__gnat_localtime_tzoff on that platform.\n\n2015-11-18  Eric Botcazou  <ebotcazou@adacore.com>\n\n\t* s-arit64.adb (To_Neg_Int): Add a special case for 2**63 input.\n\n2015-11-18  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* contracts.adb (Analyze_Contracts): New routine.\n\t(Analyze_Enclosing_Package_Body_Contract): Removed.\n\t(Analyze_Entry_Or_Subprogram_Contract): Add formal parameter\n\tFreeze_Id.  Propagate the entity of the freezing body to vaious\n\tanalysis routines.\n\t(Analyze_Initial_Declaration_Contract): Removed.\n\t(Analyze_Object_Contract): Add formal parameter\n\tFreeze_Id. Propagate the entity of the freezing body to vaious\n\tanalysis routines.\n\t(Analyze_Previous_Contracts): New routine.\n\t* contracts.ads (Analyze_Enclosing_Package_Body_Contract): Removed.\n\t(Analyze_Contracts): New routine.\n\t(Analyze_Entry_Or_Subprogram_Contract): Add formal\n\tparameter Freeze_Id and update the comment on usage.\n\t(Analyze_Initial_Declaration_Contract): Removed.\n\t(Analyze_Object_Contract): Add formal parameter Freeze_Id and\n\tupdate the comment on usage.\n\t(Analyze_Previous_Contracts): New routine.\n\t* sem_ch3.adb (Analyze_Declarations): Use Analyze_Contracts to\n\tanalyze all contracts of eligible constructs.\n\t* sem_ch6.adb (Analyze_Generic_Subprogram_Body):\n\tA body no longer freezes the contract of its initial\n\tdeclaration. This effect is achieved through different means.\n\t(Analyze_Subprogram_Body_Helper): A body now freezes the contracts\n\tof all eligible constructs that precede it. A body no longer\n\tfreezes the contract of its initial declaration. This effect is\n\tachieved through different means.\n\t* sem_ch7.adb (Analyze_Package_Body_Helper): A body now freezes\n\tthe contracts of all eligible constructs that precede it. A body\n\tno longer freezes the contract of its initial declaration. This\n\teffect is achieved through different means.\n\t* sem_ch9.adb (Analyze_Entry_Body): A body now freezes\n\tthe contracts of all eligible constructs that precede\n\tit. A body no longer freezes the contract of its initial\n\tdeclaration. This effect is achieved through different means.\n\t(Analyze_Protected_Body): A body now freezes the contracts\n\tof all eligible constructs that precede it. A body no longer\n\tfreezes the contract of its initial declaration. This effect\n\tis achieved through different means.\n\t(Analyze_Task_Body): A\n\tbody now freezes the contracts of all eligible constructs that\n\tprecede it. A body no longer freezes the contract of its initial\n\tdeclaration. This effect is achieved through different means.\n\t* sem_prag.adb (Add_Item_To_Name_Buffer): Single protected/task\n\tobjects now output their respective current instance of xxx\n\ttype messages.\t(Analyze_Contract_Cases_In_Decl_Part): Add\n\tformal parameter Freeze_Id. Emit a clarification message\n\twhen an undefined entity may the byproduct of contract\n\tfreezing.\n\t(Analyze_Part_Of_In_Decl_Part): Add formal\n\tparameter Freeze_Id. Emit a clarification message when an\n\tundefined entity may the byproduct of contract freezing.\n\t(Analyze_Pre_Post_Condition_In_Decl_Part): Add formal\n\tparameter Freeze_Id. Emit a clarification message when an\n\tundefined entity may the byproduct of contract freezing.\n\t(Analyze_Refined_State_In_Decl_Part): Do not report unused body\n\tstates as constituents of single protected/task types may not\n\tbave been identified yet.\n\t(Collect_Subprogram_Inputs_Outputs):\n\tReimplemented.\t(Contract_Freeze_Error): New routine.\n\t(Process_Overloadable): Use predicate Is_Single_Task_Object.\n\t* sem_prag.ads (Analyze_Contract_Cases_In_Decl_Part):\n\tAdd formal parameter Freeze_Id and update the comment\n\ton usage.\n\t(Analyze_Part_Of_In_Decl_Part): Add formal\n\tparameter Freeze_Id and update the comment on usage.\n\t(Analyze_Pre_Post_Condition_In_Decl_Part): Add formal parameter\n\tFreeze_Id and update the comment on usage.\n\t* sem_util.adb (Check_Unused_Body_States): Remove global\n\tvariable Legal_Constits. The routine now reports unused\n\tbody states regardless of whether constituents are\n\tlegal or not.\n\t(Collect_Body_States): A constituent of a\n\tsingle protected/task type is not a visible state of a\n\tpackage body.\n\t(Collect_Visible_States): A constituent\n\tof a single protected/task type is not a visible\n\tstate of a package body.\n\t(Has_Undefined_Reference): New routine.\n\t(Is_Single_Concurrent_Object): Reimplemented.\n\t(Is_Single_Protected_Object): New routine.\n\t(Is_Single_Task_Object): New routine.\n\t(Is_Visible_Object): New routine.\n\t(Report_Unused_Body_States): Moved to Check_Unused_Body_States.\n\t* sem_util.ads (Check_Unused_Body_States): Update the comment on usage.\n\t(Has_Undefined_Reference): New routine.\n\t(Is_Single_Protected_Object): New routine.\n\t(Is_Single_Task_Object): New routine.\n\t(Report_Unused_Body_States): Moved to Check_Unused_Body_States.\n\n2015-11-18  Pierre-Marie de Rodat  <derodat@adacore.com>\n\n\t* Makefile.rtl, impunit.adb: Add g-strhas.ads.\n\t* g-strhas.ads: New file.\n\t* s-strhas.ads: Add a comment to redirect users to g-strhas.ads.\n\n2015-11-18  Bob Duff  <duff@adacore.com>\n\n\t* sem_elab.adb (Check_Internal_Call_Continue): Fix the case\n\twhere the call in question is to a renaming of a subprogram that\n\tcan be safely called without ABE.\n\t* checks.adb: Minor edits.\n\nFrom-SVN: r230546", "tree": {"sha": "d04e46fb5f98bf3905e826724cc00a52afbd27b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d04e46fb5f98bf3905e826724cc00a52afbd27b4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e645cb39bb491e2a9b30ce4b7717bb2e23da0b88", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e645cb39bb491e2a9b30ce4b7717bb2e23da0b88", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e645cb39bb491e2a9b30ce4b7717bb2e23da0b88", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e645cb39bb491e2a9b30ce4b7717bb2e23da0b88/comments", "author": null, "committer": null, "parents": [{"sha": "33f47f427920586a6f21dd8f1b1adc582b9fb7af", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/33f47f427920586a6f21dd8f1b1adc582b9fb7af", "html_url": "https://github.com/Rust-GCC/gccrs/commit/33f47f427920586a6f21dd8f1b1adc582b9fb7af"}], "stats": {"total": 1168, "additions": 774, "deletions": 394}, "files": [{"sha": "bd90c5c25b48103f120eef42134e8850b21160a0", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 116, "deletions": 0, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e645cb39bb491e2a9b30ce4b7717bb2e23da0b88/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e645cb39bb491e2a9b30ce4b7717bb2e23da0b88/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=e645cb39bb491e2a9b30ce4b7717bb2e23da0b88", "patch": "@@ -1,3 +1,119 @@\n+2015-11-18  Nicolas Roche  <roche@adacore.com>\n+\n+\t* sysdep.c (__gnat_localtime_tzoff): On Windows platform\n+\tGetTimeZoneInformation function is thread-safe. Thus there\n+\tis no need to lock the runtime in the implementation of\n+\t__gnat_localtime_tzoff on that platform.\n+\n+2015-11-18  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* s-arit64.adb (To_Neg_Int): Add a special case for 2**63 input.\n+\n+2015-11-18  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* contracts.adb (Analyze_Contracts): New routine.\n+\t(Analyze_Enclosing_Package_Body_Contract): Removed.\n+\t(Analyze_Entry_Or_Subprogram_Contract): Add formal parameter\n+\tFreeze_Id.  Propagate the entity of the freezing body to vaious\n+\tanalysis routines.\n+\t(Analyze_Initial_Declaration_Contract): Removed.\n+\t(Analyze_Object_Contract): Add formal parameter\n+\tFreeze_Id. Propagate the entity of the freezing body to vaious\n+\tanalysis routines.\n+\t(Analyze_Previous_Contracts): New routine.\n+\t* contracts.ads (Analyze_Enclosing_Package_Body_Contract): Removed.\n+\t(Analyze_Contracts): New routine.\n+\t(Analyze_Entry_Or_Subprogram_Contract): Add formal\n+\tparameter Freeze_Id and update the comment on usage.\n+\t(Analyze_Initial_Declaration_Contract): Removed.\n+\t(Analyze_Object_Contract): Add formal parameter Freeze_Id and\n+\tupdate the comment on usage.\n+\t(Analyze_Previous_Contracts): New routine.\n+\t* sem_ch3.adb (Analyze_Declarations): Use Analyze_Contracts to\n+\tanalyze all contracts of eligible constructs.\n+\t* sem_ch6.adb (Analyze_Generic_Subprogram_Body):\n+\tA body no longer freezes the contract of its initial\n+\tdeclaration. This effect is achieved through different means.\n+\t(Analyze_Subprogram_Body_Helper): A body now freezes the contracts\n+\tof all eligible constructs that precede it. A body no longer\n+\tfreezes the contract of its initial declaration. This effect is\n+\tachieved through different means.\n+\t* sem_ch7.adb (Analyze_Package_Body_Helper): A body now freezes\n+\tthe contracts of all eligible constructs that precede it. A body\n+\tno longer freezes the contract of its initial declaration. This\n+\teffect is achieved through different means.\n+\t* sem_ch9.adb (Analyze_Entry_Body): A body now freezes\n+\tthe contracts of all eligible constructs that precede\n+\tit. A body no longer freezes the contract of its initial\n+\tdeclaration. This effect is achieved through different means.\n+\t(Analyze_Protected_Body): A body now freezes the contracts\n+\tof all eligible constructs that precede it. A body no longer\n+\tfreezes the contract of its initial declaration. This effect\n+\tis achieved through different means.\n+\t(Analyze_Task_Body): A\n+\tbody now freezes the contracts of all eligible constructs that\n+\tprecede it. A body no longer freezes the contract of its initial\n+\tdeclaration. This effect is achieved through different means.\n+\t* sem_prag.adb (Add_Item_To_Name_Buffer): Single protected/task\n+\tobjects now output their respective current instance of xxx\n+\ttype messages.\t(Analyze_Contract_Cases_In_Decl_Part): Add\n+\tformal parameter Freeze_Id. Emit a clarification message\n+\twhen an undefined entity may the byproduct of contract\n+\tfreezing.\n+\t(Analyze_Part_Of_In_Decl_Part): Add formal\n+\tparameter Freeze_Id. Emit a clarification message when an\n+\tundefined entity may the byproduct of contract freezing.\n+\t(Analyze_Pre_Post_Condition_In_Decl_Part): Add formal\n+\tparameter Freeze_Id. Emit a clarification message when an\n+\tundefined entity may the byproduct of contract freezing.\n+\t(Analyze_Refined_State_In_Decl_Part): Do not report unused body\n+\tstates as constituents of single protected/task types may not\n+\tbave been identified yet.\n+\t(Collect_Subprogram_Inputs_Outputs):\n+\tReimplemented.\t(Contract_Freeze_Error): New routine.\n+\t(Process_Overloadable): Use predicate Is_Single_Task_Object.\n+\t* sem_prag.ads (Analyze_Contract_Cases_In_Decl_Part):\n+\tAdd formal parameter Freeze_Id and update the comment\n+\ton usage.\n+\t(Analyze_Part_Of_In_Decl_Part): Add formal\n+\tparameter Freeze_Id and update the comment on usage.\n+\t(Analyze_Pre_Post_Condition_In_Decl_Part): Add formal parameter\n+\tFreeze_Id and update the comment on usage.\n+\t* sem_util.adb (Check_Unused_Body_States): Remove global\n+\tvariable Legal_Constits. The routine now reports unused\n+\tbody states regardless of whether constituents are\n+\tlegal or not.\n+\t(Collect_Body_States): A constituent of a\n+\tsingle protected/task type is not a visible state of a\n+\tpackage body.\n+\t(Collect_Visible_States): A constituent\n+\tof a single protected/task type is not a visible\n+\tstate of a package body.\n+\t(Has_Undefined_Reference): New routine.\n+\t(Is_Single_Concurrent_Object): Reimplemented.\n+\t(Is_Single_Protected_Object): New routine.\n+\t(Is_Single_Task_Object): New routine.\n+\t(Is_Visible_Object): New routine.\n+\t(Report_Unused_Body_States): Moved to Check_Unused_Body_States.\n+\t* sem_util.ads (Check_Unused_Body_States): Update the comment on usage.\n+\t(Has_Undefined_Reference): New routine.\n+\t(Is_Single_Protected_Object): New routine.\n+\t(Is_Single_Task_Object): New routine.\n+\t(Report_Unused_Body_States): Moved to Check_Unused_Body_States.\n+\n+2015-11-18  Pierre-Marie de Rodat  <derodat@adacore.com>\n+\n+\t* Makefile.rtl, impunit.adb: Add g-strhas.ads.\n+\t* g-strhas.ads: New file.\n+\t* s-strhas.ads: Add a comment to redirect users to g-strhas.ads.\n+\n+2015-11-18  Bob Duff  <duff@adacore.com>\n+\n+\t* sem_elab.adb (Check_Internal_Call_Continue): Fix the case\n+\twhere the call in question is to a renaming of a subprogram that\n+\tcan be safely called without ABE.\n+\t* checks.adb: Minor edits.\n+\n 2015-11-18  Hristian Kirtchev  <kirtchev@adacore.com>\n \n \t* atree.adb (Elist11): New routine."}, {"sha": "6bbf0d654871ef881a5c70d8b3d3696ccf64ba23", "filename": "gcc/ada/Makefile.rtl", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e645cb39bb491e2a9b30ce4b7717bb2e23da0b88/gcc%2Fada%2FMakefile.rtl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e645cb39bb491e2a9b30ce4b7717bb2e23da0b88/gcc%2Fada%2FMakefile.rtl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FMakefile.rtl?ref=e645cb39bb491e2a9b30ce4b7717bb2e23da0b88", "patch": "@@ -455,6 +455,7 @@ GNATRTL_NONTASKING_OBJS= \\\n   g-sptabo$(objext) \\\n   g-sptain$(objext) \\\n   g-sptavs$(objext) \\\n+  g-strhas$(objext) \\\n   g-string$(objext) \\\n   g-strspl$(objext) \\\n   g-table$(objext) \\"}, {"sha": "05a313ebbd292984e595df9847c2432ece0f3457", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e645cb39bb491e2a9b30ce4b7717bb2e23da0b88/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e645cb39bb491e2a9b30ce4b7717bb2e23da0b88/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=e645cb39bb491e2a9b30ce4b7717bb2e23da0b88", "patch": "@@ -1261,10 +1261,10 @@ package body Checks is\n          --  This block is inserted (using Insert_Actions), and then the node\n          --  is replaced with a reference to Rnn.\n \n-         --  A special case arises if our parent is a conversion node. In this\n-         --  case no point in generating a conversion to Result_Type, we will\n-         --  let the parent handle this. Note that this special case is not\n-         --  just about optimization. Consider\n+         --  If our parent is a conversion node then there is no point in\n+         --  generating a conversion to Result_Type, we will let the parent\n+         --  handle this. Note that this special case is not just about\n+         --  optimization. Consider\n \n          --      A,B,C : Integer;\n          --      ..."}, {"sha": "8eb5d8ea4f2bc113479ced08d82196fcb1f818ce", "filename": "gcc/ada/contracts.adb", "status": "modified", "additions": 131, "deletions": 54, "changes": 185, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e645cb39bb491e2a9b30ce4b7717bb2e23da0b88/gcc%2Fada%2Fcontracts.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e645cb39bb491e2a9b30ce4b7717bb2e23da0b88/gcc%2Fada%2Fcontracts.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fcontracts.adb?ref=e645cb39bb491e2a9b30ce4b7717bb2e23da0b88", "patch": "@@ -50,6 +50,16 @@ with Tbuild;   use Tbuild;\n \n package body Contracts is\n \n+   procedure Analyze_Contracts\n+     (L          : List_Id;\n+      Freeze_Nod : Node_Id;\n+      Freeze_Id  : Entity_Id);\n+   --  Subsidiary to the one parameter version of Analyze_Contracts and routine\n+   --  Analyze_Previous_Constracts. Analyze the contracts of all constructs in\n+   --  the list L. If Freeze_Nod is set, then the analysis stops when the node\n+   --  is reached. Freeze_Id is the entity of some related context which caused\n+   --  freezing upto node Freeze_Nod.\n+\n    procedure Expand_Subprogram_Contract (Body_Id : Entity_Id);\n    --  Expand the contracts of a subprogram body and its correspoding spec (if\n    --  any). This routine processes all [refined] pre- and postconditions as\n@@ -330,30 +340,79 @@ package body Contracts is\n       end if;\n    end Add_Contract_Item;\n \n-   ---------------------------------------------\n-   -- Analyze_Enclosing_Package_Body_Contract --\n-   ---------------------------------------------\n+   -----------------------\n+   -- Analyze_Contracts --\n+   -----------------------\n+\n+   procedure Analyze_Contracts (L : List_Id) is\n+   begin\n+      Analyze_Contracts (L, Freeze_Nod => Empty, Freeze_Id => Empty);\n+   end Analyze_Contracts;\n \n-   procedure Analyze_Enclosing_Package_Body_Contract (Body_Decl : Node_Id) is\n-      Par : Node_Id;\n+   procedure Analyze_Contracts\n+     (L          : List_Id;\n+      Freeze_Nod : Node_Id;\n+      Freeze_Id  : Entity_Id)\n+   is\n+      Decl : Node_Id;\n \n    begin\n-      --  Climb the parent chain looking for an enclosing body. Do not use the\n-      --  scope stack, as a body uses the entity of its corresponding spec.\n+      Decl := First (L);\n+      while Present (Decl) loop\n \n-      Par := Parent (Body_Decl);\n-      while Present (Par) loop\n-         if Nkind (Par) = N_Package_Body then\n-            Analyze_Package_Body_Contract\n-              (Body_Id   => Defining_Entity (Par),\n-               Freeze_Id => Defining_Entity (Body_Decl));\n+         --  The caller requests that the traversal stops at a particular node\n+         --  that causes contract \"freezing\".\n \n-            return;\n+         if Present (Freeze_Nod) and then Decl = Freeze_Nod then\n+            exit;\n          end if;\n \n-         Par := Parent (Par);\n+         --  Entry or subprogram declarations\n+\n+         if Nkind_In (Decl, N_Abstract_Subprogram_Declaration,\n+                            N_Entry_Declaration,\n+                            N_Generic_Subprogram_Declaration,\n+                            N_Subprogram_Declaration)\n+         then\n+            Analyze_Entry_Or_Subprogram_Contract\n+              (Subp_Id   => Defining_Entity (Decl),\n+               Freeze_Id => Freeze_Id);\n+\n+         --  Entry or subprogram bodies\n+\n+         elsif Nkind_In (Decl, N_Entry_Body, N_Subprogram_Body) then\n+            Analyze_Entry_Or_Subprogram_Body_Contract (Defining_Entity (Decl));\n+\n+         --  Objects\n+\n+         elsif Nkind (Decl) = N_Object_Declaration then\n+            Analyze_Object_Contract\n+              (Obj_Id    => Defining_Entity (Decl),\n+               Freeze_Id => Freeze_Id);\n+\n+         --  Protected untis\n+\n+         elsif Nkind_In (Decl, N_Protected_Type_Declaration,\n+                               N_Single_Protected_Declaration)\n+         then\n+            Analyze_Protected_Contract (Defining_Entity (Decl));\n+\n+         --  Subprogram body stubs\n+\n+         elsif Nkind (Decl) = N_Subprogram_Body_Stub then\n+            Analyze_Subprogram_Body_Stub_Contract (Defining_Entity (Decl));\n+\n+         --  Task units\n+\n+         elsif Nkind_In (Decl, N_Single_Task_Declaration,\n+                               N_Task_Type_Declaration)\n+         then\n+            Analyze_Task_Contract (Defining_Entity (Decl));\n+         end if;\n+\n+         Next (Decl);\n       end loop;\n-   end Analyze_Enclosing_Package_Body_Contract;\n+   end Analyze_Contracts;\n \n    -----------------------------------------------\n    -- Analyze_Entry_Or_Subprogram_Body_Contract --\n@@ -435,7 +494,10 @@ package body Contracts is\n    -- Analyze_Entry_Or_Subprogram_Contract --\n    ------------------------------------------\n \n-   procedure Analyze_Entry_Or_Subprogram_Contract (Subp_Id : Entity_Id) is\n+   procedure Analyze_Entry_Or_Subprogram_Contract\n+     (Subp_Id   : Entity_Id;\n+      Freeze_Id : Entity_Id := Empty)\n+   is\n       Items     : constant Node_Id := Contract (Subp_Id);\n       Subp_Decl : constant Node_Id := Unit_Declaration_Node (Subp_Id);\n \n@@ -489,7 +551,7 @@ package body Contracts is\n          else\n             Prag := Pre_Post_Conditions (Items);\n             while Present (Prag) loop\n-               Analyze_Pre_Post_Condition_In_Decl_Part (Prag);\n+               Analyze_Pre_Post_Condition_In_Decl_Part (Prag, Freeze_Id);\n                Prag := Next_Pragma (Prag);\n             end loop;\n          end if;\n@@ -513,7 +575,7 @@ package body Contracts is\n                --  Otherwise analyze the contract cases\n \n                else\n-                  Analyze_Contract_Cases_In_Decl_Part (Prag);\n+                  Analyze_Contract_Cases_In_Decl_Part (Prag, Freeze_Id);\n                end if;\n             else\n                pragma Assert (Prag_Nam = Name_Test_Case);\n@@ -587,44 +649,14 @@ package body Contracts is\n       end if;\n    end Analyze_Entry_Or_Subprogram_Contract;\n \n-   ------------------------------------------\n-   -- Analyze_Initial_Declaration_Contract --\n-   ------------------------------------------\n-\n-   procedure Analyze_Initial_Declaration_Contract (Body_Decl : Node_Id) is\n-      Spec_Id : constant Entity_Id := Unique_Defining_Entity (Body_Decl);\n-\n-   begin\n-      --  Note that stubs are excluded because the compiler always analyzes the\n-      --  proper body when a stub is encountered.\n-\n-      if Nkind (Body_Decl) = N_Entry_Body then\n-         Analyze_Entry_Or_Subprogram_Contract (Spec_Id);\n-\n-      elsif Nkind (Body_Decl) = N_Package_Body then\n-         Analyze_Package_Contract (Spec_Id);\n-\n-      elsif Nkind (Body_Decl) = N_Protected_Body then\n-         Analyze_Protected_Contract (Spec_Id);\n-\n-      elsif Nkind (Body_Decl) = N_Subprogram_Body then\n-         if Present (Corresponding_Spec (Body_Decl)) then\n-            Analyze_Entry_Or_Subprogram_Contract (Spec_Id);\n-         end if;\n-\n-      elsif Nkind (Body_Decl) = N_Task_Body then\n-         Analyze_Task_Contract (Spec_Id);\n-\n-      else\n-         raise Program_Error;\n-      end if;\n-   end Analyze_Initial_Declaration_Contract;\n-\n    -----------------------------\n    -- Analyze_Object_Contract --\n    -----------------------------\n \n-   procedure Analyze_Object_Contract (Obj_Id : Entity_Id) is\n+   procedure Analyze_Object_Contract\n+     (Obj_Id    : Entity_Id;\n+      Freeze_Id : Entity_Id := Empty)\n+   is\n       Obj_Typ      : constant Entity_Id := Etype (Obj_Id);\n       AR_Val       : Boolean := False;\n       AW_Val       : Boolean := False;\n@@ -769,7 +801,7 @@ package body Contracts is\n          --  Analyze indicator Part_Of\n \n          if Present (Prag) then\n-            Analyze_Part_Of_In_Decl_Part (Prag);\n+            Analyze_Part_Of_In_Decl_Part (Prag, Freeze_Id);\n \n             --  The variable is a constituent of a single protected/task type\n             --  and behaves as a component of the type. Verify that references\n@@ -1054,6 +1086,51 @@ package body Contracts is\n       end if;\n    end Analyze_Package_Contract;\n \n+   --------------------------------\n+   -- Analyze_Previous_Contracts --\n+   --------------------------------\n+\n+   procedure Analyze_Previous_Contracts (Body_Decl : Node_Id) is\n+      Body_Id : constant Entity_Id := Defining_Entity (Body_Decl);\n+      Par     : Node_Id;\n+\n+   begin\n+      --  A body that is in the process of being inlined appears from source,\n+      --  but carries name _parent. Such a body does not cause \"freezing\" of\n+      --  contracts.\n+\n+      if Chars (Body_Id) = Name_uParent then\n+         return;\n+      end if;\n+\n+      --  Climb the parent chain looking for an enclosing package body. Do not\n+      --  use the scope stack, as a body uses the entity of its corresponding\n+      --  spec.\n+\n+      Par := Parent (Body_Decl);\n+      while Present (Par) loop\n+         if Nkind (Par) = N_Package_Body then\n+            Analyze_Package_Body_Contract\n+              (Body_Id   => Defining_Entity (Par),\n+               Freeze_Id => Defining_Entity (Body_Decl));\n+\n+            exit;\n+         end if;\n+\n+         Par := Parent (Par);\n+      end loop;\n+\n+      --  Analyze the contracts of all eligible construct upto the body which\n+      --  caused the \"freezing\".\n+\n+      if Is_List_Member (Body_Decl) then\n+         Analyze_Contracts\n+           (L          => List_Containing (Body_Decl),\n+            Freeze_Nod => Body_Decl,\n+            Freeze_Id  => Body_Id);\n+      end if;\n+   end Analyze_Previous_Contracts;\n+\n    --------------------------------\n    -- Analyze_Protected_Contract --\n    --------------------------------"}, {"sha": "1059fc6315799c268e766f83ed39cca62561edc9", "filename": "gcc/ada/contracts.ads", "status": "modified", "additions": 19, "deletions": 9, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e645cb39bb491e2a9b30ce4b7717bb2e23da0b88/gcc%2Fada%2Fcontracts.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e645cb39bb491e2a9b30ce4b7717bb2e23da0b88/gcc%2Fada%2Fcontracts.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fcontracts.ads?ref=e645cb39bb491e2a9b30ce4b7717bb2e23da0b88", "patch": "@@ -59,9 +59,8 @@ package Contracts is\n    --    Test_Case\n    --    Volatile_Function\n \n-   procedure Analyze_Enclosing_Package_Body_Contract (Body_Decl : Node_Id);\n-   --  Analyze the contract of the nearest package body (if any) which encloses\n-   --  package or subprogram body Body_Decl.\n+   procedure Analyze_Contracts (L : List_Id);\n+   --  Analyze the contracts of all eligible constructs found in list L\n \n    procedure Analyze_Entry_Or_Subprogram_Body_Contract (Body_Id : Entity_Id);\n    --  Analyze all delayed pragmas chained on the contract of entry or\n@@ -77,7 +76,9 @@ package Contracts is\n    --    Refined_Post\n    --    Test_Case        (stand alone subprogram body)\n \n-   procedure Analyze_Entry_Or_Subprogram_Contract (Subp_Id : Entity_Id);\n+   procedure Analyze_Entry_Or_Subprogram_Contract\n+     (Subp_Id   : Entity_Id;\n+      Freeze_Id : Entity_Id := Empty);\n    --  Analyze all delayed pragmas chained on the contract of entry or\n    --  subprogram Subp_Id as if they appeared at the end of a declarative\n    --  region. The pragmas in question are:\n@@ -87,12 +88,13 @@ package Contracts is\n    --    Postcondition\n    --    Precondition\n    --    Test_Case\n+   --\n+   --  Freeze_Id is the entity of a [generic] package body or a [generic]\n+   --  subprogram body which \"freezes\" the contract of Subp_Id.\n \n-   procedure Analyze_Initial_Declaration_Contract (Body_Decl : Node_Id);\n-   --  Analyze the contract of the initial declaration of entry body, package\n-   --  body, protected body, subprogram body or task body Body_Decl.\n-\n-   procedure Analyze_Object_Contract (Obj_Id : Entity_Id);\n+   procedure Analyze_Object_Contract\n+     (Obj_Id    : Entity_Id;\n+      Freeze_Id : Entity_Id := Empty);\n    --  Analyze all delayed pragmas chained on the contract of object Obj_Id as\n    --  if they appeared at the end of the declarative region. The pragmas to be\n    --  considered are:\n@@ -103,6 +105,9 @@ package Contracts is\n    --    Effective_Writes\n    --    Global            (single concurrent object)\n    --    Part_Of\n+   --\n+   --  Freeze_Id is the entity of a [generic] package body or a [generic]\n+   --  subprogram body which \"freezes\" the contract of Obj_Id.\n \n    procedure Analyze_Package_Body_Contract\n      (Body_Id   : Entity_Id;\n@@ -123,6 +128,11 @@ package Contracts is\n    --    Initializes\n    --    Part_Of\n \n+   procedure Analyze_Previous_Contracts (Body_Decl : Node_Id);\n+   --  Analyze the contracts of all source constructs found in the declarative\n+   --  list which contains entry, package, protected, subprogram, or task body\n+   --  denoted by Body_Decl. The analysis stops once Body_Decl is reached.\n+\n    procedure Analyze_Protected_Contract (Prot_Id : Entity_Id);\n    --  Analyze all delayed pragmas chained on the contract of protected unit\n    --  Prot_Id if they appeared at the end of a declarative region. Currently"}, {"sha": "6a7d251e6f4bf5d77081de14955fa708955077a9", "filename": "gcc/ada/g-strhas.ads", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e645cb39bb491e2a9b30ce4b7717bb2e23da0b88/gcc%2Fada%2Fg-strhas.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e645cb39bb491e2a9b30ce4b7717bb2e23da0b88/gcc%2Fada%2Fg-strhas.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-strhas.ads?ref=e645cb39bb491e2a9b30ce4b7717bb2e23da0b88", "patch": "@@ -0,0 +1,43 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                      G N A T . S T R I N G _ H A S H                     --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--             Copyright (C) 2015, Free Software Foundation, Inc.           --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package provides a generic hashing function over strings, suitable for\n+--  use with a string keyed hash table. In particular, it is the basis for the\n+--  string hash functions in Ada.Containers.\n+--\n+--  The algorithm used here is not appropriate for applications that require\n+--  cryptographically strong hashes, or for application which wish to use very\n+--  wide hash values as pseudo unique identifiers. In such cases please refer\n+--  to GNAT.SHA1 and GNAT.MD5.\n+\n+with System.String_Hash;\n+\n+package GNAT.String_Hash renames System.String_Hash;"}, {"sha": "45b937944b30d847756b8efee3e49531fb0831a9", "filename": "gcc/ada/impunit.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e645cb39bb491e2a9b30ce4b7717bb2e23da0b88/gcc%2Fada%2Fimpunit.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e645cb39bb491e2a9b30ce4b7717bb2e23da0b88/gcc%2Fada%2Fimpunit.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fimpunit.adb?ref=e645cb39bb491e2a9b30ce4b7717bb2e23da0b88", "patch": "@@ -312,6 +312,7 @@ package body Impunit is\n     (\"g-sptabo\", F),  -- GNAT.Spitbol.Table_Boolean\n     (\"g-sptain\", F),  -- GNAT.Spitbol.Table_Integer\n     (\"g-sptavs\", F),  -- GNAT.Spitbol.Table_Vstring\n+    (\"g-strhas\", F),  -- GNAT.String_Hash\n     (\"g-string\", F),  -- GNAT.Strings\n     (\"g-strspl\", F),  -- GNAT.String_Split\n     (\"g-sse   \", F),  -- GNAT.SSE"}, {"sha": "cbefe3111fb17fa1c2d7a9f0d44597b144595abf", "filename": "gcc/ada/s-arit64.adb", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e645cb39bb491e2a9b30ce4b7717bb2e23da0b88/gcc%2Fada%2Fs-arit64.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e645cb39bb491e2a9b30ce4b7717bb2e23da0b88/gcc%2Fada%2Fs-arit64.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-arit64.adb?ref=e645cb39bb491e2a9b30ce4b7717bb2e23da0b88", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -577,7 +577,9 @@ package body System.Arith_64 is\n    ----------------\n \n    function To_Neg_Int (A : Uns64) return Int64 is\n-      R : constant Int64 := -To_Int (A);\n+      R : constant Int64 := (if A = 2**63 then Int64'First else -To_Int (A));\n+      --  Note that we can't just use the expression of the Else, because it\n+      --  overflows for A = 2**63.\n    begin\n       if R <= 0 then\n          return R;"}, {"sha": "d0dd4c8a22570eac4061e39b66cc25891653a047", "filename": "gcc/ada/s-strhas.ads", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e645cb39bb491e2a9b30ce4b7717bb2e23da0b88/gcc%2Fada%2Fs-strhas.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e645cb39bb491e2a9b30ce4b7717bb2e23da0b88/gcc%2Fada%2Fs-strhas.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-strhas.ads?ref=e645cb39bb491e2a9b30ce4b7717bb2e23da0b88", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---             Copyright (C) 2009, Free Software Foundation, Inc.           --\n+--          Copyright (C) 2009-2015, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -37,6 +37,10 @@\n --  cryptographically strong hashes, or for application which wish to use very\n --  wide hash values as pseudo unique identifiers. In such cases please refer\n --  to GNAT.SHA1 and GNAT.MD5.\n+--\n+--  Note: this package is in the System hierarchy so that it can be directly\n+--  be used by other predefined packages. User access to this package is via\n+--  a renaming of this package in GNAT.String_Hash (file g-strhas.ads).\n \n package System.String_Hash is\n    pragma Pure;"}, {"sha": "78fa19f0cbbd8b2bd59fbe0b781e17f2b8a464c1", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 3, "deletions": 47, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e645cb39bb491e2a9b30ce4b7717bb2e23da0b88/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e645cb39bb491e2a9b30ce4b7717bb2e23da0b88/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=e645cb39bb491e2a9b30ce4b7717bb2e23da0b88", "patch": "@@ -2495,54 +2495,10 @@ package body Sem_Ch3 is\n             Analyze_Package_Body_Contract (Defining_Entity (Context));\n          end if;\n \n-         --  Analyze the contracts of eligible constructs (see below) due to\n-         --  the delayed visibility needs of their aspects and pragmas.\n+         --  Analyze the contracts of various constructs now due to the delayed\n+         --  visibility needs of their aspects and pragmas.\n \n-         Decl := First (L);\n-         while Present (Decl) loop\n-\n-            --  Entry or subprogram declarations\n-\n-            if Nkind_In (Decl, N_Abstract_Subprogram_Declaration,\n-                               N_Entry_Declaration,\n-                               N_Generic_Subprogram_Declaration,\n-                               N_Subprogram_Declaration)\n-            then\n-               Analyze_Entry_Or_Subprogram_Contract (Defining_Entity (Decl));\n-\n-            --  Entry or subprogram bodies\n-\n-            elsif Nkind_In (Decl, N_Entry_Body, N_Subprogram_Body) then\n-               Analyze_Entry_Or_Subprogram_Body_Contract\n-                 (Defining_Entity (Decl));\n-\n-            --  Objects\n-\n-            elsif Nkind (Decl) = N_Object_Declaration then\n-               Analyze_Object_Contract (Defining_Entity (Decl));\n-\n-            --  Protected untis\n-\n-            elsif Nkind_In (Decl, N_Protected_Type_Declaration,\n-                                  N_Single_Protected_Declaration)\n-            then\n-               Analyze_Protected_Contract (Defining_Entity (Decl));\n-\n-            --  Subprogram body stubs\n-\n-            elsif Nkind (Decl) = N_Subprogram_Body_Stub then\n-               Analyze_Subprogram_Body_Stub_Contract (Defining_Entity (Decl));\n-\n-            --  Task units\n-\n-            elsif Nkind_In (Decl, N_Single_Task_Declaration,\n-                                  N_Task_Type_Declaration)\n-            then\n-               Analyze_Task_Contract (Defining_Entity (Decl));\n-            end if;\n-\n-            Next (Decl);\n-         end loop;\n+         Analyze_Contracts (L);\n \n          if Nkind (Context) = N_Package_Body then\n "}, {"sha": "f193f5527b1c60812e88736f7f2c25d8ae7515e1", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 3, "deletions": 19, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e645cb39bb491e2a9b30ce4b7717bb2e23da0b88/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e645cb39bb491e2a9b30ce4b7717bb2e23da0b88/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=e645cb39bb491e2a9b30ce4b7717bb2e23da0b88", "patch": "@@ -1294,15 +1294,6 @@ package body Sem_Ch6 is\n             Analyze_Aspect_Specifications_On_Body_Or_Stub (N);\n          end if;\n \n-         --  A generic subprogram body \"freezes\" the contract of its initial\n-         --  declaration. This analysis depends on attribute Corresponding_Spec\n-         --  being set. Only bodies coming from source should cause this type\n-         --  of \"freezing\".\n-\n-         if Comes_From_Source (N) then\n-            Analyze_Initial_Declaration_Contract (N);\n-         end if;\n-\n          Analyze_Declarations (Declarations (N));\n          Check_Completion;\n \n@@ -2988,7 +2979,8 @@ package body Sem_Ch6 is\n \n    begin\n       --  A [generic] subprogram body \"freezes\" the contract of the nearest\n-      --  enclosing package body:\n+      --  enclosing package body and all other contracts encountered in the\n+      --  same declarative part upto and excluding the subprogram body:\n \n       --    package body Nearest_Enclosing_Package\n       --      with Refined_State => (State => Constit)\n@@ -3009,7 +3001,7 @@ package body Sem_Ch6 is\n       --  Original_Node.\n \n       if Comes_From_Source (Original_Node (N)) then\n-         Analyze_Enclosing_Package_Body_Contract (N);\n+         Analyze_Previous_Contracts (N);\n       end if;\n \n       --  Generic subprograms are handled separately. They always have a\n@@ -3787,14 +3779,6 @@ package body Sem_Ch6 is\n          Analyze_Aspect_Specifications_On_Body_Or_Stub (N);\n       end if;\n \n-      --  A subprogram body \"freezes\" the contract of its initial declaration.\n-      --  This analysis depends on attribute Corresponding_Spec being set. Only\n-      --  bodies coming from source should cause this type of \"freezing\".\n-\n-      if Comes_From_Source (N) then\n-         Analyze_Initial_Declaration_Contract (N);\n-      end if;\n-\n       Analyze_Declarations (Declarations (N));\n \n       --  Verify that the SPARK_Mode of the body agrees with that of its spec"}, {"sha": "18cd618a547769e42d0447e4378cdafc7d8e324a", "filename": "gcc/ada/sem_ch7.adb", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e645cb39bb491e2a9b30ce4b7717bb2e23da0b88/gcc%2Fada%2Fsem_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e645cb39bb491e2a9b30ce4b7717bb2e23da0b88/gcc%2Fada%2Fsem_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch7.adb?ref=e645cb39bb491e2a9b30ce4b7717bb2e23da0b88", "patch": "@@ -543,7 +543,8 @@ package body Sem_Ch7 is\n \n    begin\n       --  A [generic] package body \"freezes\" the contract of the nearest\n-      --  enclosing package body:\n+      --  enclosing package body and all other contracts encountered in the\n+      --  same declarative part upto and excluding the package body:\n \n       --    package body Nearest_Enclosing_Package\n       --      with Refined_State => (State => Constit)\n@@ -567,7 +568,7 @@ package body Sem_Ch7 is\n       --  Only bodies coming from source should cause this type of \"freezing\"\n \n       if Comes_From_Source (N) then\n-         Analyze_Enclosing_Package_Body_Contract (N);\n+         Analyze_Previous_Contracts (N);\n       end if;\n \n       --  Find corresponding package specification, and establish the current\n@@ -767,10 +768,6 @@ package body Sem_Ch7 is\n       --  This analysis depends on attribute Corresponding_Spec being set. Only\n       --  bodies coming from source shuld cause this type of \"freezing\".\n \n-      if Comes_From_Source (N) then\n-         Analyze_Initial_Declaration_Contract (N);\n-      end if;\n-\n       if Present (Declarations (N)) then\n          Analyze_Declarations (Declarations (N));\n          Inspect_Deferred_Constant_Completion (Declarations (N));"}, {"sha": "b67b248952f198e2f70bee0e2f6d9d6df2ba92a0", "filename": "gcc/ada/sem_ch9.adb", "status": "modified", "additions": 17, "deletions": 28, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e645cb39bb491e2a9b30ce4b7717bb2e23da0b88/gcc%2Fada%2Fsem_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e645cb39bb491e2a9b30ce4b7717bb2e23da0b88/gcc%2Fada%2Fsem_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch9.adb?ref=e645cb39bb491e2a9b30ce4b7717bb2e23da0b88", "patch": "@@ -1192,12 +1192,13 @@ package body Sem_Ch9 is\n       Entry_Name : Entity_Id;\n \n    begin\n-      --  An entry body \"freezes\" the contract of the nearest enclosing\n-      --  package body. This ensures that any annotations referenced by the\n-      --  contract of an entry or subprogram body declared within the current\n-      --  protected body are available.\n+      --  An entry body \"freezes\" the contract of the nearest enclosing package\n+      --  body and all other contracts encountered in the same declarative part\n+      --  upto and excluding the entry body. This ensures that any annotations\n+      --  referenced by the contract of an entry or subprogram body declared\n+      --  within the current protected body are available.\n \n-      Analyze_Enclosing_Package_Body_Contract (N);\n+      Analyze_Previous_Contracts (N);\n \n       Tasking_Used := True;\n \n@@ -1354,11 +1355,6 @@ package body Sem_Ch9 is\n            (Sloc (N), Entry_Name, P_Type, N, Decls);\n       end if;\n \n-      --  An entry body \"freezes\" the contract of its initial declaration. This\n-      --  analysis depends on attribute Corresponding_Body being set.\n-\n-      Analyze_Initial_Declaration_Contract (N);\n-\n       if Present (Decls) then\n          Analyze_Declarations (Decls);\n          Inspect_Deferred_Constant_Completion (Decls);\n@@ -1772,11 +1768,13 @@ package body Sem_Ch9 is\n \n    begin\n       --  A protected body \"freezes\" the contract of the nearest enclosing\n-      --  package body. This ensures that any annotations referenced by the\n-      --  contract of an entry or subprogram body declared within the current\n-      --  protected body are available.\n+      --  package body and all other contracts encountered in the same\n+      --  declarative part upto and excluding the protected body. This ensures\n+      --  that any annotations referenced by the contract of an entry or\n+      --  subprogram body declared within the current protected body are\n+      --  available.\n \n-      Analyze_Enclosing_Package_Body_Contract (N);\n+      Analyze_Previous_Contracts (N);\n \n       Tasking_Used := True;\n       Set_Ekind (Body_Id, E_Protected_Body);\n@@ -1819,11 +1817,6 @@ package body Sem_Ch9 is\n       Expand_Protected_Body_Declarations (N, Spec_Id);\n       Last_E := Last_Entity (Spec_Id);\n \n-      --  A protected body \"freezes\" the contract of its initial declaration.\n-      --  This analysis depends on attribute Corresponding_Spec being set.\n-\n-      Analyze_Initial_Declaration_Contract (N);\n-\n       Analyze_Declarations (Declarations (N));\n \n       --  For visibility purposes, all entities in the body are private. Set\n@@ -2816,11 +2809,12 @@ package body Sem_Ch9 is\n \n    begin\n       --  A task body \"freezes\" the contract of the nearest enclosing package\n-      --  body. This ensures that annotations referenced by the contract of an\n-      --  entry or subprogram body declared within the current protected body\n-      --  are available.\n+      --  body and all other contracts encountered in the same declarative part\n+      --  upto and excluding the task body. This ensures that annotations\n+      --  referenced by the contract of an entry or subprogram body declared\n+      --  within the current protected body are available.\n \n-      Analyze_Enclosing_Package_Body_Contract (N);\n+      Analyze_Previous_Contracts (N);\n \n       Tasking_Used := True;\n       Set_Scope (Body_Id, Current_Scope);\n@@ -2882,11 +2876,6 @@ package body Sem_Ch9 is\n       Install_Declarations (Spec_Id);\n       Last_E := Last_Entity (Spec_Id);\n \n-      --  A task body \"freezes\" the contract of its initial declaration. This\n-      --  analysis depends on attribute Corresponding_Spec being set.\n-\n-      Analyze_Initial_Declaration_Contract (N);\n-\n       Analyze_Declarations (Decls);\n       Inspect_Deferred_Constant_Completion (Decls);\n "}, {"sha": "b229c1bd9b0c370360a7cff206357b5f34a9b5a4", "filename": "gcc/ada/sem_elab.adb", "status": "modified", "additions": 38, "deletions": 22, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e645cb39bb491e2a9b30ce4b7717bb2e23da0b88/gcc%2Fada%2Fsem_elab.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e645cb39bb491e2a9b30ce4b7717bb2e23da0b88/gcc%2Fada%2Fsem_elab.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_elab.adb?ref=e645cb39bb491e2a9b30ce4b7717bb2e23da0b88", "patch": "@@ -2122,12 +2122,6 @@ package body Sem_Elab is\n       Outer_Scope : Entity_Id;\n       Orig_Ent    : Entity_Id)\n    is\n-      Loc       : constant Source_Ptr := Sloc (N);\n-      Inst_Case : constant Boolean := Is_Generic_Unit (E);\n-\n-      Sbody : Node_Id;\n-      Ebody : Entity_Id;\n-\n       function Find_Elab_Reference (N : Node_Id) return Traverse_Result;\n       --  Function applied to each node as we traverse the body. Checks for\n       --  call or entity reference that needs checking, and if so checks it.\n@@ -2235,6 +2229,12 @@ package body Sem_Elab is\n          end if;\n       end Find_Elab_Reference;\n \n+      Inst_Case : constant Boolean    := Is_Generic_Unit (E);\n+      Loc       : constant Source_Ptr := Sloc (N);\n+\n+      Ebody : Entity_Id;\n+      Sbody : Node_Id;\n+\n    --  Start of processing for Check_Internal_Call_Continue\n \n    begin\n@@ -2379,27 +2379,43 @@ package body Sem_Elab is\n       --  Not that special case, warning and dynamic check is required\n \n       --  If we have nothing in the call stack, then this is at the outer\n-      --  level, and the ABE is bound to occur, unless it's a 'Access.\n+      --  level, and the ABE is bound to occur, unless it's a 'Access, or\n+      --  it's a renaming.\n \n       if Elab_Call.Last = 0 then\n          Error_Msg_Warn := SPARK_Mode /= On;\n \n-         if Inst_Case then\n-            Error_Msg_NE\n-              (\"cannot instantiate& before body seen<<\", N, Orig_Ent);\n-         elsif Nkind (N) /= N_Attribute_Reference then\n-            Error_Msg_NE\n-              (\"cannot call& before body seen<<\", N, Orig_Ent);\n-         else\n-            Error_Msg_NE\n-              (\"Access attribute of & before body seen<<\", N, Orig_Ent);\n-            Error_Msg_N (\"\\possible Program_Error on later references<\", N);\n-         end if;\n+         declare\n+            Insert_Check : Boolean := True;\n+            --  This flag is set to True if an elaboration check should be\n+            --  inserted.\n \n-         if Nkind (N) /= N_Attribute_Reference then\n-            Error_Msg_N (\"\\Program_Error [<<\", N);\n-            Insert_Elab_Check (N);\n-         end if;\n+         begin\n+            if Inst_Case then\n+               Error_Msg_NE\n+                 (\"cannot instantiate& before body seen<<\", N, Orig_Ent);\n+\n+            elsif Nkind (N) = N_Attribute_Reference then\n+               Error_Msg_NE\n+                 (\"Access attribute of & before body seen<<\", N, Orig_Ent);\n+               Error_Msg_N (\"\\possible Program_Error on later references<\", N);\n+               Insert_Check := False;\n+\n+            elsif Nkind (Unit_Declaration_Node (Orig_Ent)) /=\n+                    N_Subprogram_Renaming_Declaration\n+            then\n+               Error_Msg_NE\n+                 (\"cannot call& before body seen<<\", N, Orig_Ent);\n+\n+            else\n+               Insert_Check := False;\n+            end if;\n+\n+            if Insert_Check then\n+               Error_Msg_N (\"\\Program_Error [<<\", N);\n+               Insert_Elab_Check (N);\n+            end if;\n+         end;\n \n       --  Call is not at outer level\n "}, {"sha": "5ad3a555cedef11de7c5fe7adc00511af67e8540", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 172, "deletions": 63, "changes": 235, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e645cb39bb491e2a9b30ce4b7717bb2e23da0b88/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e645cb39bb491e2a9b30ce4b7717bb2e23da0b88/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=e645cb39bb491e2a9b30ce4b7717bb2e23da0b88", "patch": "@@ -208,6 +208,14 @@ package body Sem_Prag is\n    --  corresponding constituent from list Constits (if any) appear in the same\n    --  context denoted by Context. If this is the case, emit an error.\n \n+   procedure Contract_Freeze_Error\n+     (Contract_Id : Entity_Id;\n+      Freeze_Id   : Entity_Id);\n+   --  Subsidiary to the analysis of pragmas Contract_Cases, Part_Of, Post, and\n+   --  Pre. Emit a freezing-related error message where Freeze_Id is the entity\n+   --  of a body which caused contract \"freezing\" and Contract_Id denotes the\n+   --  entity of the affected contstruct.\n+\n    procedure Duplication_Error (Prag : Node_Id; Prev : Node_Id);\n    --  Subsidiary to all Find_Related_xxx routines. Emit an error on pragma\n    --  Prag that duplicates previous pragma Prev.\n@@ -341,8 +349,16 @@ package body Sem_Prag is\n    -- Analyze_Contract_Cases_In_Decl_Part --\n    -----------------------------------------\n \n-   procedure Analyze_Contract_Cases_In_Decl_Part (N : Node_Id) is\n+   procedure Analyze_Contract_Cases_In_Decl_Part\n+     (N         : Node_Id;\n+      Freeze_Id : Entity_Id := Empty)\n+   is\n+      Subp_Decl : constant Node_Id   := Find_Related_Declaration_Or_Body (N);\n+      Spec_Id   : constant Entity_Id := Unique_Defining_Entity (Subp_Decl);\n+\n       Others_Seen : Boolean := False;\n+      --  This flag is set when an \"others\" choice is encountered. It is used\n+      --  to detect multiple illegal occurences of \"others\".\n \n       procedure Analyze_Contract_Case (CCase : Node_Id);\n       --  Verify the legality of a single contract case\n@@ -354,6 +370,7 @@ package body Sem_Prag is\n       procedure Analyze_Contract_Case (CCase : Node_Id) is\n          Case_Guard  : Node_Id;\n          Conseq      : Node_Id;\n+         Errors      : Nat;\n          Extra_Guard : Node_Id;\n \n       begin\n@@ -390,11 +407,35 @@ package body Sem_Prag is\n             --  Preanalyze the case guard and consequence\n \n             if Nkind (Case_Guard) /= N_Others_Choice then\n+               Errors := Serious_Errors_Detected;\n                Preanalyze_Assert_Expression (Case_Guard, Standard_Boolean);\n+\n+               --  Emit a clarification message when the case guard contains\n+               --  at leat one undefined reference, possibly due to contract\n+               --  \"freezing\".\n+\n+               if Errors /= Serious_Errors_Detected\n+                 and then Present (Freeze_Id)\n+                 and then Has_Undefined_Reference (Case_Guard)\n+               then\n+                  Contract_Freeze_Error (Spec_Id, Freeze_Id);\n+               end if;\n             end if;\n \n+            Errors := Serious_Errors_Detected;\n             Preanalyze_Assert_Expression (Conseq, Standard_Boolean);\n \n+            --  Emit a clarification message when the consequence contains\n+            --  at leat one undefined reference, possibly due to contract\n+            --  \"freezing\".\n+\n+            if Errors /= Serious_Errors_Detected\n+              and then Present (Freeze_Id)\n+              and then Has_Undefined_Reference (Conseq)\n+            then\n+               Contract_Freeze_Error (Spec_Id, Freeze_Id);\n+            end if;\n+\n          --  The contract case is malformed\n \n          else\n@@ -404,9 +445,7 @@ package body Sem_Prag is\n \n       --  Local variables\n \n-      Subp_Decl : constant Node_Id   := Find_Related_Declaration_Or_Body (N);\n-      Spec_Id   : constant Entity_Id := Unique_Defining_Entity (Subp_Decl);\n-      CCases    : constant Node_Id   := Expression (Get_Argument (N, Spec_Id));\n+      CCases : constant Node_Id := Expression (Get_Argument (N, Spec_Id));\n \n       Save_Ghost_Mode : constant Ghost_Mode_Type := Ghost_Mode;\n \n@@ -594,10 +633,14 @@ package body Sem_Prag is\n          elsif Ekind (Item_Id) = E_Loop_Parameter then\n             Add_Str_To_Name_Buffer (\"loop parameter\");\n \n-         elsif Ekind (Item_Id) = E_Protected_Type then\n+         elsif Ekind (Item_Id) = E_Protected_Type\n+           or else Is_Single_Protected_Object (Item_Id)\n+         then\n             Add_Str_To_Name_Buffer (\"current instance of protected type\");\n \n-         elsif Ekind (Item_Id) = E_Task_Type then\n+         elsif Ekind (Item_Id) = E_Task_Type\n+           or else Is_Single_Task_Object (Item_Id)\n+         then\n             Add_Str_To_Name_Buffer (\"current instance of task type\");\n \n          elsif Ekind (Item_Id) = E_Variable then\n@@ -3162,7 +3205,13 @@ package body Sem_Prag is\n    -- Analyze_Part_Of_In_Decl_Part --\n    ----------------------------------\n \n-   procedure Analyze_Part_Of_In_Decl_Part (N : Node_Id) is\n+   procedure Analyze_Part_Of_In_Decl_Part\n+     (N         : Node_Id;\n+      Freeze_Id : Entity_Id := Empty)\n+   is\n+      Encap    : constant Node_Id   :=\n+                   Get_Pragma_Arg (First (Pragma_Argument_Associations (N)));\n+      Errors   : constant Nat       := Serious_Errors_Detected;\n       Var_Decl : constant Node_Id   := Find_Related_Context (N);\n       Var_Id   : constant Entity_Id := Defining_Entity (Var_Decl);\n       Encap_Id : Entity_Id;\n@@ -3176,7 +3225,7 @@ package body Sem_Prag is\n       Analyze_Part_Of\n         (Indic    => N,\n          Item_Id  => Var_Id,\n-         Encap    => Get_Pragma_Arg (First (Pragma_Argument_Associations (N))),\n+         Encap    => Encap,\n          Encap_Id => Encap_Id,\n          Legal    => Legal);\n \n@@ -3189,6 +3238,16 @@ package body Sem_Prag is\n          Append_Elmt (Var_Id, Part_Of_Constituents (Encap_Id));\n          Set_Encapsulating_State (Var_Id, Encap_Id);\n       end if;\n+\n+      --  Emit a clarification message when the encapsulator is undefined,\n+      --  possibly due to contract \"freezing\".\n+\n+      if Errors /= Serious_Errors_Detected\n+        and then Present (Freeze_Id)\n+        and then Has_Undefined_Reference (Encap)\n+      then\n+         Contract_Freeze_Error (Var_Id, Freeze_Id);\n+      end if;\n    end Analyze_Part_Of_In_Decl_Part;\n \n    --------------------\n@@ -20430,9 +20489,7 @@ package body Sem_Prag is\n                --    Obj : Anon_Task_Typ;\n                --    pragma SPARK_Mode ...;\n \n-               if Is_Single_Concurrent_Object (Spec_Id)\n-                 and then Ekind (Spec_Typ) = E_Task_Type\n-               then\n+               if Is_Single_Task_Object (Spec_Id) then\n                   Set_SPARK_Pragma               (Spec_Typ, N);\n                   Set_SPARK_Pragma_Inherited     (Spec_Typ, False);\n                   Set_SPARK_Aux_Pragma           (Spec_Typ, N);\n@@ -22980,7 +23037,10 @@ package body Sem_Prag is\n    -- Analyze_Pre_Post_Condition_In_Decl_Part --\n    ---------------------------------------------\n \n-   procedure Analyze_Pre_Post_Condition_In_Decl_Part (N : Node_Id) is\n+   procedure Analyze_Pre_Post_Condition_In_Decl_Part\n+     (N         : Node_Id;\n+      Freeze_Id : Entity_Id := Empty)\n+   is\n       procedure Process_Class_Wide_Condition\n         (Expr      : Node_Id;\n          Spec_Id   : Entity_Id;\n@@ -23134,6 +23194,7 @@ package body Sem_Prag is\n \n       Save_Ghost_Mode : constant Ghost_Mode_Type := Ghost_Mode;\n \n+      Errors        : Nat;\n       Restore_Scope : Boolean := False;\n \n    --  Start of processing for Analyze_Pre_Post_Condition_In_Decl_Part\n@@ -23166,8 +23227,19 @@ package body Sem_Prag is\n          end if;\n       end if;\n \n+      Errors := Serious_Errors_Detected;\n       Preanalyze_Assert_Expression (Expr, Standard_Boolean);\n \n+      --  Emit a clarification message when the expression contains at leat one\n+      --  undefined reference, possibly due to contract \"freezing\".\n+\n+      if Errors /= Serious_Errors_Detected\n+        and then Present (Freeze_Id)\n+        and then Has_Undefined_Reference (Expr)\n+      then\n+         Contract_Freeze_Error (Spec_Id, Freeze_Id);\n+      end if;\n+\n       --  For a class-wide condition, a reference to a controlling formal must\n       --  be interpreted as having the class-wide type (or an access to such)\n       --  so that the inherited condition can be properly applied to any\n@@ -25874,11 +25946,6 @@ package body Sem_Prag is\n \n       Report_Unrefined_States (Available_States);\n \n-      --  Ensure that all abstract states and objects declared in the body\n-      --  state space of the related package are utilized as constituents.\n-\n-      Report_Unused_Body_States (Body_Id, Body_States);\n-\n       Set_Is_Analyzed_Pragma (N);\n    end Analyze_Refined_State_In_Decl_Part;\n \n@@ -26631,50 +26698,74 @@ package body Sem_Prag is\n \n       --  Local variables\n \n-      Subp_Decl : constant Node_Id   := Unit_Declaration_Node (Subp_Id);\n-      Spec_Id   : constant Entity_Id := Unique_Defining_Entity (Subp_Decl);\n       Clause    : Node_Id;\n       Clauses   : Node_Id;\n       Depends   : Node_Id;\n       Formal    : Entity_Id;\n       Global    : Node_Id;\n+      Spec_Id   : Entity_Id;\n+      Subp_Decl : Node_Id;\n       Typ       : Entity_Id;\n \n    --  Start of processing for Collect_Subprogram_Inputs_Outputs\n \n    begin\n       Global_Seen := False;\n \n-      --  Process all [generic] formal parameters\n+      --  Process all formal parameters of entries, [generic] subprograms and\n+      --  their bodies.\n \n-      Formal := First_Entity (Spec_Id);\n-      while Present (Formal) loop\n-         if Ekind_In (Formal, E_Generic_In_Parameter,\n-                              E_In_Out_Parameter,\n-                              E_In_Parameter)\n-         then\n-            Append_New_Elmt (Formal, Subp_Inputs);\n-         end if;\n-\n-         if Ekind_In (Formal, E_Generic_In_Out_Parameter,\n-                              E_In_Out_Parameter,\n-                              E_Out_Parameter)\n-         then\n-            Append_New_Elmt (Formal, Subp_Outputs);\n+      if Ekind_In (Subp_Id, E_Entry,\n+                            E_Entry_Family,\n+                            E_Function,\n+                            E_Generic_Function,\n+                            E_Generic_Procedure,\n+                            E_Procedure,\n+                            E_Subprogram_Body)\n+      then\n+         Subp_Decl := Unit_Declaration_Node (Subp_Id);\n+         Spec_Id   := Unique_Defining_Entity (Subp_Decl);\n \n-            --  Out parameters can act as inputs when the related type is\n-            --  tagged, unconstrained array, unconstrained record or record\n-            --  with unconstrained components.\n+         --  Process all [generic] formal parameters\n \n-            if Ekind (Formal) = E_Out_Parameter\n-              and then Is_Unconstrained_Or_Tagged_Item (Formal)\n+         Formal := First_Entity (Spec_Id);\n+         while Present (Formal) loop\n+            if Ekind_In (Formal, E_Generic_In_Parameter,\n+                                 E_In_Out_Parameter,\n+                                 E_In_Parameter)\n             then\n                Append_New_Elmt (Formal, Subp_Inputs);\n             end if;\n-         end if;\n \n-         Next_Entity (Formal);\n-      end loop;\n+            if Ekind_In (Formal, E_Generic_In_Out_Parameter,\n+                                 E_In_Out_Parameter,\n+                                 E_Out_Parameter)\n+            then\n+               Append_New_Elmt (Formal, Subp_Outputs);\n+\n+               --  Out parameters can act as inputs when the related type is\n+               --  tagged, unconstrained array, unconstrained record or record\n+               --  with unconstrained components.\n+\n+               if Ekind (Formal) = E_Out_Parameter\n+                 and then Is_Unconstrained_Or_Tagged_Item (Formal)\n+               then\n+                  Append_New_Elmt (Formal, Subp_Inputs);\n+               end if;\n+            end if;\n+\n+            Next_Entity (Formal);\n+         end loop;\n+\n+      --  Otherwise the input denotes a task type, a task body, or the\n+      --  anonymous object created for a single task type.\n+\n+      elsif Ekind_In (Subp_Id, E_Task_Type, E_Task_Body)\n+        or else Is_Single_Task_Object (Subp_Id)\n+      then\n+         Subp_Decl := Declaration_Node (Subp_Id);\n+         Spec_Id   := Unique_Defining_Entity (Subp_Decl);\n+      end if;\n \n       --  When processing an entry, subprogram or task body, look for pragmas\n       --  Refined_Depends and Refined_Global as they specify the inputs and\n@@ -26724,46 +26815,64 @@ package body Sem_Prag is\n          end if;\n       end if;\n \n+      --  The current instance of a protected type acts as a formal parameter\n+      --  of mode IN for functions and IN OUT for entries and procedures\n+      --  (SPARK RM 6.1.4).\n+\n       if Ekind (Scope (Spec_Id)) = E_Protected_Type then\n          Typ := Scope (Spec_Id);\n \n-         --  A single protected type declaration does not have a current\n-         --  instance because the type is technically an object.\n+         --  Use the anonymous object when the type is single protected\n \n          if Is_Single_Concurrent_Type_Declaration (Declaration_Node (Typ)) then\n-            null;\n-\n-         --  Otherwise the current instance of the protected type acts as a\n-         --  formal parameter of mode IN for functions and IN OUT for entries\n-         --  and procedures (SPARK RM 6.1.4).\n+            Typ := Anonymous_Object (Typ);\n+         end if;\n \n-         else\n-            Append_New_Elmt (Typ, Subp_Inputs);\n+         Append_New_Elmt (Typ, Subp_Inputs);\n \n-            if Ekind_In (Spec_Id, E_Entry, E_Entry_Family, E_Procedure) then\n-               Append_New_Elmt (Typ, Subp_Outputs);\n-            end if;\n+         if Ekind_In (Spec_Id, E_Entry, E_Entry_Family, E_Procedure) then\n+            Append_New_Elmt (Typ, Subp_Outputs);\n          end if;\n \n+      --  The current instance of a task type acts as a formal parameter of\n+      --  mode IN OUT (SPARK RM 6.1.4).\n+\n       elsif Ekind (Spec_Id) = E_Task_Type then\n          Typ := Spec_Id;\n \n-         --  A single task type declaration does not have a current instance\n-         --  because the type is technically an object.\n+         --  Use the anonymous object when the type is single task\n \n          if Is_Single_Concurrent_Type_Declaration (Declaration_Node (Typ)) then\n-            null;\n+            Typ := Anonymous_Object (Typ);\n+         end if;\n \n-         --  Otherwise the current instance of the task type acts as a formal\n-         --  parameter of mode IN OUT (SPARK RM 6.1.4).\n+         Append_New_Elmt (Typ, Subp_Inputs);\n+         Append_New_Elmt (Typ, Subp_Outputs);\n \n-         else\n-            Append_New_Elmt (Typ, Subp_Inputs);\n-            Append_New_Elmt (Typ, Subp_Outputs);\n-         end if;\n+      elsif Is_Single_Task_Object (Spec_Id) then\n+         Append_New_Elmt (Spec_Id, Subp_Inputs);\n+         Append_New_Elmt (Spec_Id, Subp_Outputs);\n       end if;\n    end Collect_Subprogram_Inputs_Outputs;\n \n+   ---------------------------\n+   -- Contract_Freeze_Error --\n+   ---------------------------\n+\n+   procedure Contract_Freeze_Error\n+     (Contract_Id : Entity_Id;\n+      Freeze_Id   : Entity_Id)\n+   is\n+   begin\n+      Error_Msg_Name_1 := Chars (Contract_Id);\n+      Error_Msg_Sloc   := Sloc (Freeze_Id);\n+\n+      SPARK_Msg_NE\n+        (\"body & declared # freezes the contract of%\", Contract_Id, Freeze_Id);\n+      SPARK_Msg_N\n+        (\"\\all contractual items must be declared before body #\", Contract_Id);\n+   end Contract_Freeze_Error;\n+\n    ---------------------------------\n    -- Delay_Config_Pragma_Analyze --\n    ---------------------------------"}, {"sha": "ce05bfd432c714e5450ea0862edef40154618764", "filename": "gcc/ada/sem_prag.ads", "status": "modified", "additions": 19, "deletions": 6, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e645cb39bb491e2a9b30ce4b7717bb2e23da0b88/gcc%2Fada%2Fsem_prag.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e645cb39bb491e2a9b30ce4b7717bb2e23da0b88/gcc%2Fada%2Fsem_prag.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.ads?ref=e645cb39bb491e2a9b30ce4b7717bb2e23da0b88", "patch": "@@ -181,8 +181,12 @@ package Sem_Prag is\n    procedure Analyze_Pragma (N : Node_Id);\n    --  Analyze procedure for pragma reference node N\n \n-   procedure Analyze_Contract_Cases_In_Decl_Part (N : Node_Id);\n-   --  Perform full analysis of delayed pragma Contract_Cases\n+   procedure Analyze_Contract_Cases_In_Decl_Part\n+     (N         : Node_Id;\n+      Freeze_Id : Entity_Id := Empty);\n+   --  Perform full analysis of delayed pragma Contract_Cases. Freeze_Id is the\n+   --  entity of [generic] package body or [generic] subprogram body which\n+   --  caused \"freezing\" of the related contract where the pragma resides.\n \n    procedure Analyze_Depends_In_Decl_Part (N : Node_Id);\n    --  Perform full analysis of delayed pragma Depends. This routine is also\n@@ -205,11 +209,20 @@ package Sem_Prag is\n    procedure Analyze_Initializes_In_Decl_Part (N : Node_Id);\n    --  Perform full analysis of delayed pragma Initializes\n \n-   procedure Analyze_Part_Of_In_Decl_Part (N : Node_Id);\n-   --  Perform full analysis of delayed pragma Part_Of\n+   procedure Analyze_Part_Of_In_Decl_Part\n+     (N         : Node_Id;\n+      Freeze_Id : Entity_Id := Empty);\n+   --  Perform full analysis of delayed pragma Part_Of. Freeze_Id is the entity\n+   --  of [generic] package body or [generic] subprogram body which caused the\n+   --  \"freezing\" of the related contract where the pragma resides.\n \n-   procedure Analyze_Pre_Post_Condition_In_Decl_Part (N : Node_Id);\n-   --  Perform full analysis of pragmas Precondition and Postcondition\n+   procedure Analyze_Pre_Post_Condition_In_Decl_Part\n+     (N         : Node_Id;\n+      Freeze_Id : Entity_Id := Empty);\n+   --  Perform full analysis of pragmas Precondition and Postcondition.\n+   --  Freeze_Id denotes the entity of [generic] package body or [generic]\n+   --  subprogram body which caused \"freezing\" of the related contract where\n+   --  the pragma resides.\n \n    procedure Analyze_Refined_Depends_In_Decl_Part (N : Node_Id);\n    --  Preform full analysis of delayed pragma Refined_Depends. This routine"}, {"sha": "8d712ef584c3fe215f30b2c6752c1c88b2bd6b9c", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 169, "deletions": 87, "changes": 256, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e645cb39bb491e2a9b30ce4b7717bb2e23da0b88/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e645cb39bb491e2a9b30ce4b7717bb2e23da0b88/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=e645cb39bb491e2a9b30ce4b7717bb2e23da0b88", "patch": "@@ -3717,17 +3717,15 @@ package body Sem_Util is\n    ------------------------------\n \n    procedure Check_Unused_Body_States (Body_Id : Entity_Id) is\n-      Legal_Constits : Boolean := True;\n-      --  This flag designates whether all constituents of pragma Refined_State\n-      --  are legal. The flag is used to suppress the generation of potentially\n-      --  misleading error messages due to a malformed pragma.\n-\n       procedure Process_Refinement_Clause\n         (Clause : Node_Id;\n          States : Elist_Id);\n       --  Inspect all constituents of refinement clause Clause and remove any\n       --  matches from body state list States.\n \n+      procedure Report_Unused_Body_States (States : Elist_Id);\n+      --  Emit errors for each abstract state or object found in list States\n+\n       -------------------------------\n       -- Process_Refinement_Clause --\n       -------------------------------\n@@ -3747,10 +3745,6 @@ package body Sem_Util is\n             Constit_Id : Entity_Id;\n \n          begin\n-            if Error_Posted (Constit) then\n-               Legal_Constits := False;\n-            end if;\n-\n             --  Guard against illegal constituents. Only abstract states and\n             --  objects can appear on the right hand side of a refinement.\n \n@@ -3794,10 +3788,63 @@ package body Sem_Util is\n          end if;\n       end Process_Refinement_Clause;\n \n+      -------------------------------\n+      -- Report_Unused_Body_States --\n+      -------------------------------\n+\n+      procedure Report_Unused_Body_States (States : Elist_Id) is\n+         Posted     : Boolean := False;\n+         State_Elmt : Elmt_Id;\n+         State_Id   : Entity_Id;\n+\n+      begin\n+         if Present (States) then\n+            State_Elmt := First_Elmt (States);\n+            while Present (State_Elmt) loop\n+               State_Id := Node (State_Elmt);\n+\n+               --  Constants are part of the hidden state of a package, but the\n+               --  compiler cannot determine whether they have variable input\n+               --  (SPARK RM 7.1.1(2)) and cannot classify them properly as a\n+               --  hidden state. Do not emit an error when a constant does not\n+               --  participate in a state refinement, even though it acts as a\n+               --  hidden state.\n+\n+               if Ekind (State_Id) = E_Constant then\n+                  null;\n+\n+               --  Generate an error message of the form:\n+\n+               --    body of package ... has unused hidden states\n+               --      abstract state ... defined at ...\n+               --      variable ... defined at ...\n+\n+               else\n+                  if not Posted then\n+                     Posted := True;\n+                     SPARK_Msg_N\n+                       (\"body of package & has unused hidden states\", Body_Id);\n+                  end if;\n+\n+                  Error_Msg_Sloc := Sloc (State_Id);\n+\n+                  if Ekind (State_Id) = E_Abstract_State then\n+                     SPARK_Msg_NE\n+                       (\"\\abstract state & defined #\", Body_Id, State_Id);\n+\n+                  else\n+                     SPARK_Msg_NE (\"\\variable & defined #\", Body_Id, State_Id);\n+                  end if;\n+               end if;\n+\n+                  Next_Elmt (State_Elmt);\n+            end loop;\n+         end if;\n+      end Report_Unused_Body_States;\n+\n       --  Local variables\n \n-      Prag    : constant Node_Id   :=\n-                  Get_Pragma (Body_Id, Pragma_Refined_State);\n+      Prag    : constant Node_Id := Get_Pragma (Body_Id, Pragma_Refined_State);\n       Spec_Id : constant Entity_Id := Spec_Entity (Body_Id);\n       Clause  : Node_Id;\n       States  : Elist_Id;\n@@ -3806,8 +3853,8 @@ package body Sem_Util is\n \n    begin\n       --  Inspect the clauses of pragma Refined_State and determine whether all\n-      --  visible states declared within the body of the package participate in\n-      --  the refinement.\n+      --  visible states declared within the package body participate in the\n+      --  refinement.\n \n       if Present (Prag) then\n          Clause := Expression (Get_Argument (Prag, Spec_Id));\n@@ -3828,12 +3875,10 @@ package body Sem_Util is\n             Process_Refinement_Clause (Clause, States);\n          end if;\n \n-         --  Ensure that all abstract states and objects declared in the body\n-         --  state space of the related package are utilized as constituents.\n+         --  Ensure that all abstract states and objects declared in the\n+         --  package body state space are utilized as constituents.\n \n-         if Legal_Constits then\n-            Report_Unused_Body_States (Body_Id, States);\n-         end if;\n+         Report_Unused_Body_States (States);\n       end if;\n    end Check_Unused_Body_States;\n \n@@ -3842,6 +3887,10 @@ package body Sem_Util is\n    -------------------------\n \n    function Collect_Body_States (Body_Id : Entity_Id) return Elist_Id is\n+      function Is_Visible_Object (Obj_Id : Entity_Id) return Boolean;\n+      --  Determine whether object Obj_Id is a suitable visible state of a\n+      --  package body.\n+\n       procedure Collect_Visible_States\n         (Pack_Id : Entity_Id;\n          States  : in out Elist_Id);\n@@ -3874,13 +3923,8 @@ package body Sem_Util is\n             elsif Ekind (Item_Id) = E_Abstract_State then\n                Append_New_Elmt (Item_Id, States);\n \n-            --  Do not consider objects that map generic formals to their\n-            --  actuals, as the formals cannot be named from the outside and\n-            --  participate in refinement.\n-\n             elsif Ekind_In (Item_Id, E_Constant, E_Variable)\n-              and then No (Corresponding_Generic_Association\n-                             (Declaration_Node (Item_Id)))\n+              and then Is_Visible_Object (Item_Id)\n             then\n                Append_New_Elmt (Item_Id, States);\n \n@@ -3894,6 +3938,34 @@ package body Sem_Util is\n          end loop;\n       end Collect_Visible_States;\n \n+      -----------------------\n+      -- Is_Visible_Object --\n+      -----------------------\n+\n+      function Is_Visible_Object (Obj_Id : Entity_Id) return Boolean is\n+      begin\n+         --  Objects that map generic formals to their actuals are not visible\n+         --  from outside the generic instantiation.\n+\n+         if Present (Corresponding_Generic_Association\n+                       (Declaration_Node (Obj_Id)))\n+         then\n+            return False;\n+\n+         --  Constituents of a single protected/task type act as components of\n+         --  the type and are not visible from outside the type.\n+\n+         elsif Ekind (Obj_Id) = E_Variable\n+           and then Present (Encapsulating_State (Obj_Id))\n+           and then Is_Single_Concurrent_Object (Encapsulating_State (Obj_Id))\n+         then\n+            return False;\n+\n+         else\n+            return True;\n+         end if;\n+      end Is_Visible_Object;\n+\n       --  Local variables\n \n       Body_Decl : constant Node_Id := Unit_Declaration_Node (Body_Id);\n@@ -3905,7 +3977,9 @@ package body Sem_Util is\n \n    begin\n       --  Inspect the declarations of the body looking for source objects,\n-      --  packages and package instantiations.\n+      --  packages and package instantiations. Note that even though this\n+      --  processing is very similar to Collect_Visible_States, a package\n+      --  body does not have a First/Next_Entity list.\n \n       Decl := First (Declarations (Body_Decl));\n       while Present (Decl) loop\n@@ -3916,7 +3990,9 @@ package body Sem_Util is\n          if Nkind (Decl) = N_Object_Declaration then\n             Item_Id := Defining_Entity (Decl);\n \n-            if Comes_From_Source (Item_Id) then\n+            if Comes_From_Source (Item_Id)\n+              and then Is_Visible_Object (Item_Id)\n+            then\n                Append_New_Elmt (Item_Id, States);\n             end if;\n \n@@ -7254,8 +7330,7 @@ package body Sem_Util is\n    function Fix_Msg (Id : Entity_Id; Msg : String) return String is\n       Is_Task   : constant Boolean :=\n                     Ekind_In (Id, E_Task_Body, E_Task_Type)\n-                      or else (Is_Single_Concurrent_Object (Id)\n-                                and then Ekind (Etype (Id)) = E_Task_Type);\n+                      or else Is_Single_Task_Object (Id);\n       Msg_Last  : constant Natural := Msg'Last;\n       Msg_Index : Natural;\n       Res       : String (Msg'Range) := (others => ' ');\n@@ -9993,6 +10068,47 @@ package body Sem_Util is\n       end if;\n    end Has_Tagged_Component;\n \n+   -----------------------------\n+   -- Has_Undefined_Reference --\n+   -----------------------------\n+\n+   function Has_Undefined_Reference (Expr : Node_Id) return Boolean is\n+      Has_Undef_Ref : Boolean := False;\n+      --  Flag set when expression Expr contains at least one undefined\n+      --  reference.\n+\n+      function Is_Undefined_Reference (N : Node_Id) return Traverse_Result;\n+      --  Determine whether N denotes a reference and if it does, whether it is\n+      --  undefined.\n+\n+      ----------------------------\n+      -- Is_Undefined_Reference --\n+      ----------------------------\n+\n+      function Is_Undefined_Reference (N : Node_Id) return Traverse_Result is\n+      begin\n+         if Is_Entity_Name (N)\n+           and then Present (Entity (N))\n+           and then Entity (N) = Any_Id\n+         then\n+            Has_Undef_Ref := True;\n+            return Abandon;\n+         end if;\n+\n+         return OK;\n+      end Is_Undefined_Reference;\n+\n+      procedure Find_Undefined_References is\n+        new Traverse_Proc (Is_Undefined_Reference);\n+\n+   --  Start of processing for Has_Undefined_Reference\n+\n+   begin\n+      Find_Undefined_References (Expr);\n+\n+      return Has_Undef_Ref;\n+   end Has_Undefined_Reference;\n+\n    ----------------------------\n    -- Has_Volatile_Component --\n    ----------------------------\n@@ -13414,8 +13530,7 @@ package body Sem_Util is\n    function Is_Single_Concurrent_Object (Id : Entity_Id) return Boolean is\n    begin\n       return\n-        Ekind (Id) = E_Variable\n-          and then Is_Single_Concurrent_Type (Etype (Id));\n+        Is_Single_Protected_Object (Id) or else Is_Single_Task_Object (Id);\n    end Is_Single_Concurrent_Object;\n \n    -------------------------------\n@@ -13456,6 +13571,30 @@ package body Sem_Util is\n         and then Machine_Emin_Value (E) = Uint_3 - (Uint_2 ** Uint_7);\n    end Is_Single_Precision_Floating_Point_Type;\n \n+   --------------------------------\n+   -- Is_Single_Protected_Object --\n+   --------------------------------\n+\n+   function Is_Single_Protected_Object (Id : Entity_Id) return Boolean is\n+   begin\n+      return\n+        Ekind (Id) = E_Variable\n+          and then Ekind (Etype (Id)) = E_Protected_Type\n+          and then Is_Single_Concurrent_Type (Etype (Id));\n+   end Is_Single_Protected_Object;\n+\n+   ---------------------------\n+   -- Is_Single_Task_Object --\n+   ---------------------------\n+\n+   function Is_Single_Task_Object (Id : Entity_Id) return Boolean is\n+   begin\n+      return\n+        Ekind (Id) = E_Variable\n+          and then Ekind (Etype (Id)) = E_Task_Type\n+          and then Is_Single_Concurrent_Type (Etype (Id));\n+   end Is_Single_Task_Object;\n+\n    -------------------------------------\n    -- Is_SPARK_05_Initialization_Expr --\n    -------------------------------------\n@@ -17634,63 +17773,6 @@ package body Sem_Util is\n                (Boolean_Literals (not Range_Checks_Suppressed (E)), Loc);\n    end Rep_To_Pos_Flag;\n \n-   -------------------------------\n-   -- Report_Unused_Body_States --\n-   -------------------------------\n-\n-   procedure Report_Unused_Body_States\n-     (Body_Id : Entity_Id;\n-      States  : Elist_Id)\n-   is\n-      Posted     : Boolean := False;\n-      State_Elmt : Elmt_Id;\n-      State_Id   : Entity_Id;\n-\n-   begin\n-      if Present (States) then\n-         State_Elmt := First_Elmt (States);\n-         while Present (State_Elmt) loop\n-            State_Id := Node (State_Elmt);\n-\n-            --  Constants are part of the hidden state of a package, but the\n-            --  compiler cannot determine whether they have variable input\n-            --  (SPARK RM 7.1.1(2)) and cannot classify them properly as a\n-            --  hidden state. Do not emit an error when a constant does not\n-            --  participate in a state refinement, even though it acts as a\n-            --  hidden state.\n-\n-            if Ekind (State_Id) = E_Constant then\n-               null;\n-\n-            --  Generate an error message of the form:\n-\n-            --    body of package ... has unused hidden states\n-            --      abstract state ... defined at ...\n-            --      variable ... defined at ...\n-\n-            else\n-               if not Posted then\n-                  Posted := True;\n-                  SPARK_Msg_N\n-                    (\"body of package & has unused hidden states\", Body_Id);\n-               end if;\n-\n-               Error_Msg_Sloc := Sloc (State_Id);\n-\n-               if Ekind (State_Id) = E_Abstract_State then\n-                  SPARK_Msg_NE\n-                    (\"\\abstract state & defined #\", Body_Id, State_Id);\n-\n-               else\n-                  SPARK_Msg_NE (\"\\variable & defined #\", Body_Id, State_Id);\n-               end if;\n-            end if;\n-\n-            Next_Elmt (State_Elmt);\n-         end loop;\n-      end if;\n-   end Report_Unused_Body_States;\n-\n    --------------------\n    -- Require_Entity --\n    --------------------"}, {"sha": "d6f104cba2c250031a696e0188eb7e9a362bdac4", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 26, "deletions": 21, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e645cb39bb491e2a9b30ce4b7717bb2e23da0b88/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e645cb39bb491e2a9b30ce4b7717bb2e23da0b88/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=e645cb39bb491e2a9b30ce4b7717bb2e23da0b88", "patch": "@@ -57,6 +57,9 @@ package Sem_Util is\n    --  for the current unit. The declarations are added in the current scope,\n    --  so the caller should push a new scope as required before the call.\n \n+   function Add_Suffix (E : Entity_Id; Suffix : Character) return Name_Id;\n+   --  Returns the name of E adding Suffix\n+\n    function Address_Integer_Convert_OK (T1, T2 : Entity_Id) return Boolean;\n    --  Given two types, returns True if we are in Allow_Integer_Address mode\n    --  and one of the types is (a descendent of) System.Address (and this type\n@@ -327,13 +330,9 @@ package Sem_Util is\n    --  and post-state.\n \n    procedure Check_Unused_Body_States (Body_Id : Entity_Id);\n-   --  Verify that all abstract states and object declared in the state space\n-   --  of a package body denoted by entity Body_Id are used as constituents.\n-   --  Emit an error if this is not the case.\n-\n-   function Collect_Body_States (Body_Id : Entity_Id) return Elist_Id;\n-   --  Gather the entities of all abstract states and objects declared in the\n-   --  body state space of package body Body_Id.\n+   --  Verify that all abstract states and objects declared in the state space\n+   --  of package body Body_Id are used as constituents. Emit an error if this\n+   --  is not the case.\n \n    procedure Check_Unprotected_Access\n      (Context : Node_Id;\n@@ -342,6 +341,10 @@ package Sem_Util is\n    --  and the context is external to the protected operation, to warn against\n    --  a possible unlocked access to data.\n \n+   function Collect_Body_States (Body_Id : Entity_Id) return Elist_Id;\n+   --  Gather the entities of all abstract states and objects declared in the\n+   --  body state space of package body Body_Id.\n+\n    procedure Collect_Interfaces\n      (T               : Entity_Id;\n       Ifaces_List     : out Elist_Id;\n@@ -1113,21 +1116,19 @@ package Sem_Util is\n    function Has_Suffix (E : Entity_Id; Suffix : Character) return Boolean;\n    --  Returns true if the last character of E is Suffix. Used in Assertions.\n \n-   function Add_Suffix (E : Entity_Id; Suffix : Character) return Name_Id;\n-   --  Returns the name of E adding Suffix\n-\n-   function Remove_Suffix (E : Entity_Id; Suffix : Character) return Name_Id;\n-   --  Returns the name of E without Suffix\n-\n    function Has_Tagged_Component (Typ : Entity_Id) return Boolean;\n    --  Returns True if Typ is a composite type (array or record) which is\n    --  either itself a tagged type, or has a component (recursively) which is\n    --  a tagged type. Returns False for non-composite type, or if no tagged\n    --  component is present. This function is used to check if \"=\" has to be\n    --  expanded into a bunch component comparisons.\n \n+   function Has_Undefined_Reference (Expr : Node_Id) return Boolean;\n+   --  Given arbitrary expression Expr, determine whether it contains at\n+   --  least one name whose entity is Any_Id.\n+\n    function Has_Volatile_Component (Typ : Entity_Id) return Boolean;\n-   --  Given an arbitrary type, determine whether it contains at least one\n+   --  Given arbitrary type Typ, determine whether it contains at least one\n    --  volatile component.\n \n    function Implementation_Kind (Subp : Entity_Id) return Name_Id;\n@@ -1553,6 +1554,14 @@ package Sem_Util is\n    --  . machine_emax = 2**7\n    --  . machine_emin = 3 - machine_emax\n \n+   function Is_Single_Protected_Object (Id : Entity_Id) return Boolean;\n+   --  Determine whether arbitrary entity Id denotes the anonymous object\n+   --  created for a single protected type.\n+\n+   function Is_Single_Task_Object (Id : Entity_Id) return Boolean;\n+   --  Determine whether arbitrary entity Id denotes the anonymous object\n+   --  created for a single task type.\n+\n    function Is_SPARK_05_Initialization_Expr (N : Node_Id) return Boolean;\n    --  Determines if the tree referenced by N represents an initialization\n    --  expression in SPARK 2005, suitable for initializing an object in an\n@@ -1950,6 +1959,9 @@ package Sem_Util is\n    --  the removal performed by this routine does not affect the visibility of\n    --  existing homonyms.\n \n+   function Remove_Suffix (E : Entity_Id; Suffix : Character) return Name_Id;\n+   --  Returns the name of E without Suffix\n+\n    function Rep_To_Pos_Flag (E : Entity_Id; Loc : Source_Ptr) return Node_Id;\n    --  This is used to construct the second argument in a call to Rep_To_Pos\n    --  which is Standard_True if range checks are enabled (E is an entity to\n@@ -1963,13 +1975,6 @@ package Sem_Util is\n    --  more there is at least one case in the generated code (the code for\n    --  array assignment in a loop) that depends on this suppression.\n \n-   procedure Report_Unused_Body_States\n-     (Body_Id : Entity_Id;\n-      States  : Elist_Id);\n-   --  Emit errors for each abstract state or object found in list States that\n-   --  is declared in package body Body_Id, but is not used as constituent in a\n-   --  state refinement.\n-\n    procedure Require_Entity (N : Node_Id);\n    --  N is a node which should have an entity value if it is an entity name.\n    --  If not, then check if there were previous errors. If so, just fill"}, {"sha": "465007eb15df437103bef085c794ae63cb904cfa", "filename": "gcc/ada/sysdep.c", "status": "modified", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e645cb39bb491e2a9b30ce4b7717bb2e23da0b88/gcc%2Fada%2Fsysdep.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e645cb39bb491e2a9b30ce4b7717bb2e23da0b88/gcc%2Fada%2Fsysdep.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsysdep.c?ref=e645cb39bb491e2a9b30ce4b7717bb2e23da0b88", "patch": "@@ -605,27 +605,6 @@ long __gnat_invalid_tzoff = 259273;\n \n #if defined (__MINGW32__)\n \n-#ifdef CERT\n-\n-/* For the Cert run times on native Windows we use dummy functions\n-   for locking and unlocking tasks since we do not support multiple\n-   threads on this configuration (Cert run time on native Windows). */\n-\n-void dummy (void) {}\n-\n-void (*Lock_Task) ()   = &dummy;\n-void (*Unlock_Task) () = &dummy;\n-\n-#else\n-\n-#define Lock_Task system__soft_links__lock_task\n-extern void (*Lock_Task) (void);\n-\n-#define Unlock_Task system__soft_links__unlock_task\n-extern void (*Unlock_Task) (void);\n-\n-#endif\n-\n /* Reentrant localtime for Windows. */\n \n extern void\n@@ -639,8 +618,6 @@ __gnat_localtime_tzoff (const time_t *timer, const int *is_historic, long *off)\n \n   DWORD tzi_status;\n \n-  (*Lock_Task) ();\n-\n   tzi_status = GetTimeZoneInformation (&tzi);\n \n   /* Cases where we simply want to extract the offset of the current time\n@@ -712,8 +689,6 @@ __gnat_localtime_tzoff (const time_t *timer, const int *is_historic, long *off)\n       }\n     }\n   }\n-\n-  (*Unlock_Task) ();\n }\n \n #elif defined (__Lynx__)"}]}