{"sha": "d52e4867caba3a5833cc2c90ac8df8fe7ccd7b76", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDUyZTQ4NjdjYWJhM2E1ODMzY2MyYzkwYWM4ZGY4ZmU3Y2NkN2I3Ng==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2002-03-29T20:41:53Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2002-03-29T20:41:53Z"}, "message": "re PR c++/5998 (regression, all builtins disabled)\n\n\t* include/c_std/std_cmath.h:  To prevent problems overloading\n\tg++ builtins, use the double variants from the global namespace\n\tbefore defining float and long double variants in std::.\n\n\tPR c++/5998:\n\t* decl.c (cxx_init_decl_processing): Re-enable built-in functions\n\tin the g++ front-end.\n\t(duplicate_decl): Allow redefinition of anticipated built-ins.\n\tFix inlining problem by over-writing the old DECL_RTL.\n\t(lookup_namespace_name): Fail to find an identifier in the\n\tspecified namespace if its still anticipated.\n\t(builtin_function_1): New function split out from builtin_function\n\tto create a builtin in the current namespace with given context.\n\t(builtin_function): Call builtin_function_1 to define the\n\tappropriate builtins in both the std and global namespaces.\n\t(select_decl): Don't test for anticipated decls here.\n\t(unqualified_namespace_lookup): Instead ignore them whilst\n\tsearching through scopes and namespaces.\n\t* decl2.c (do_nonmember_using_decl): If a using declaration\n\tspecifies an anticipated built-in function, mark it as no longer\n\tanticipated in that scope.\n\t(ambiguous_decl):  Avoid resolving to an anticipated decl.\n\t* lex.c (do_scoped_id): Fail to find an identifier in the global\n\tnamespace if its still anticipated.\n\n\t* g++.old-deja/g++.other/builtins5.C: New test.\n\t* g++.old-deja/g++.other/builtins6.C: New test.\n\t* g++.old-deja/g++.other/builtins7.C: New test.\n\t* g++.old-deja/g++.other/builtins8.C: New test.\n\t* g++.old-deja/g++.other/builtins9.C: New test.\n\nFrom-SVN: r51568", "tree": {"sha": "187fa816b67c22e5eb8cf4e72e061f67f62adfcc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/187fa816b67c22e5eb8cf4e72e061f67f62adfcc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d52e4867caba3a5833cc2c90ac8df8fe7ccd7b76", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d52e4867caba3a5833cc2c90ac8df8fe7ccd7b76", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d52e4867caba3a5833cc2c90ac8df8fe7ccd7b76", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d52e4867caba3a5833cc2c90ac8df8fe7ccd7b76/comments", "author": null, "committer": null, "parents": [{"sha": "5843e8704e27a84b1b2b4536bed073eee6361800", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5843e8704e27a84b1b2b4536bed073eee6361800", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5843e8704e27a84b1b2b4536bed073eee6361800"}], "stats": {"total": 355, "additions": 267, "deletions": 88}, "files": [{"sha": "b7f8cb2cc78e03a199ec4159c261482e8df407ae", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d52e4867caba3a5833cc2c90ac8df8fe7ccd7b76/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d52e4867caba3a5833cc2c90ac8df8fe7ccd7b76/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=d52e4867caba3a5833cc2c90ac8df8fe7ccd7b76", "patch": "@@ -1,3 +1,26 @@\n+2002-03-28  Roger Sayle  <roger@eyesopen.com>\n+\n+\tPR c++/5998:\n+\t* decl.c (cxx_init_decl_processing): Re-enable built-in functions\n+\tin the g++ front-end.\n+\t(duplicate_decl): Allow redefinition of anticipated built-ins.\n+\tFix inlining problem by over-writing the old DECL_RTL.\n+\t(lookup_namespace_name): Fail to find an identifier in the\n+\tspecified namespace if its still anticipated.\n+\t(builtin_function_1): New function split out from builtin_function\n+\tto create a builtin in the current namespace with given context.\n+\t(builtin_function): Call builtin_function_1 to define the\n+\tappropriate builtins in both the std and global namespaces.\n+\t(select_decl): Don't test for anticipated decls here.\n+\t(unqualified_namespace_lookup): Instead ignore them whilst\n+\tsearching through scopes and namespaces.\n+\t* decl2.c (do_nonmember_using_decl): If a using declaration\n+\tspecifies an anticipated built-in function, mark it as no longer\n+\tanticipated in that scope.\n+\t(ambiguous_decl):  Avoid resolving to an anticipated decl.\n+\t* lex.c (do_scoped_id): Fail to find an identifier in the global\n+\tnamespace if its still anticipated.\n+\n 2002-03-29  Neil Booth  <neil@daikokuya.demon.co.uk>\n \n \t* cp-lang.c (LANG_HOOKS_MAKE_TYPE): Redefine."}, {"sha": "1739771debff68d6f1603b20d5d8f67a1c2e13cb", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 72, "deletions": 36, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d52e4867caba3a5833cc2c90ac8df8fe7ccd7b76/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d52e4867caba3a5833cc2c90ac8df8fe7ccd7b76/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=d52e4867caba3a5833cc2c90ac8df8fe7ccd7b76", "patch": "@@ -87,6 +87,8 @@ static tree lookup_tag PARAMS ((enum tree_code, tree,\n static void set_identifier_type_value_with_scope\n \tPARAMS ((tree, tree, struct binding_level *));\n static void record_unknown_type PARAMS ((tree, const char *));\n+static tree builtin_function_1 PARAMS ((const char *, tree, tree, int,\n+                                      enum built_in_class, const char *));\n static tree build_library_fn_1 PARAMS ((tree, enum tree_code, tree));\n static int member_function_or_else PARAMS ((tree, tree, enum overload_flags));\n static void bad_specifiers PARAMS ((tree, const char *, int, int, int, int,\n@@ -3145,6 +3147,10 @@ duplicate_decls (newdecl, olddecl)\n     {\n       if (TREE_CODE (newdecl) != FUNCTION_DECL)\n \t{\n+          /* Avoid warnings redeclaring anticipated built-ins.  */\n+          if (DECL_ANTICIPATED (olddecl))\n+            return 0;\n+\n \t  /* If you declare a built-in or predefined function name as static,\n \t     the old definition is overridden, but optionally warn this was a\n \t     bad choice of name.  */\n@@ -3172,7 +3178,10 @@ duplicate_decls (newdecl, olddecl)\n \t}\n       else if (!types_match)\n \t{\n-\t  if ((DECL_EXTERN_C_P (newdecl)\n+          /* Avoid warnings redeclaring anticipated built-ins.  */\n+          if (DECL_ANTICIPATED (olddecl))\n+            ;  /* Do nothing yet.  */\n+\t  else if ((DECL_EXTERN_C_P (newdecl)\n \t       && DECL_EXTERN_C_P (olddecl))\n \t      || compparms (TYPE_ARG_TYPES (TREE_TYPE (newdecl)),\n \t\t\t    TYPE_ARG_TYPES (TREE_TYPE (olddecl))))\n@@ -3614,6 +3623,7 @@ duplicate_decls (newdecl, olddecl)\n       TREE_READONLY (olddecl) = TREE_READONLY (newdecl);\n       TREE_THIS_VOLATILE (olddecl) = TREE_THIS_VOLATILE (newdecl);\n       TREE_SIDE_EFFECTS (olddecl) = TREE_SIDE_EFFECTS (newdecl);\n+      COPY_DECL_RTL (newdecl, olddecl);\n     }\n \n   /* Merge the storage class information.  */\n@@ -5507,7 +5517,12 @@ lookup_namespace_name (namespace, name)\n       /* If we have a single function from a using decl, pull it out.  */\n       if (TREE_CODE (val) == OVERLOAD && ! really_overloaded_fn (val))\n \tval = OVL_FUNCTION (val);\n-      return val;\n+\n+      /* Ignore built-in functions that haven't been prototyped yet.  */\n+      if (!val || !DECL_P(val)\n+          || !DECL_LANG_SPECIFIC(val)\n+          || !DECL_ANTICIPATED (val))\n+        return val;\n     }\n \n   error (\"`%D' undeclared in namespace `%D'\", name, namespace);\n@@ -5786,14 +5801,6 @@ select_decl (binding, flags)\n   tree val;\n   val = BINDING_VALUE (binding);\n \n-  /* When we implicitly declare some builtin entity, we mark it\n-     DECL_ANTICIPATED, so that we know to ignore it until it is\n-     really declared.  */\n-  if (val && DECL_P (val)\n-      && DECL_LANG_SPECIFIC (val)\n-      && DECL_ANTICIPATED (val))\n-    return NULL_TREE;\n-\n   if (LOOKUP_NAMESPACES_ONLY (flags))\n     {\n       /* We are not interested in types. */\n@@ -5843,9 +5850,21 @@ unqualified_namespace_lookup (name, flags, spacesp)\n \t*spacesp = tree_cons (scope, NULL_TREE, *spacesp);\n       val = binding_for_name (name, scope);\n \n-      /* Initialize binding for this context. */\n-      BINDING_VALUE (b) = BINDING_VALUE (val);\n-      BINDING_TYPE (b) = BINDING_TYPE (val);\n+      /* Ignore anticipated built-in functions.  */\n+      if (val && BINDING_VALUE (val)\n+          && DECL_P (BINDING_VALUE (val))\n+          && DECL_LANG_SPECIFIC (BINDING_VALUE (val))\n+          && DECL_ANTICIPATED (BINDING_VALUE (val)))\n+        {\n+          BINDING_VALUE (b) = NULL_TREE;\n+          BINDING_TYPE (b) = NULL_TREE;\n+        }\n+      else\n+        {\n+          /* Initialize binding for this context. */\n+          BINDING_VALUE (b) = BINDING_VALUE (val);\n+          BINDING_TYPE (b) = BINDING_TYPE (val);\n+        }\n \n       /* Add all _DECLs seen through local using-directives. */\n       for (level = current_binding_level;\n@@ -6435,12 +6454,6 @@ cxx_init_decl_processing ()\n       flag_inline_functions = 0;\n     }\n \n-  /* In C++, we never create builtin functions whose name does not\n-     begin with `__'.  Users should be using headers to get prototypes\n-     in C++.  It would be nice if we could warn when `-fbuiltin' is\n-     used explicitly, but we do not have that information.  */\n-  flag_no_builtin = 1;\n-\n   /* Initially, C.  */\n   current_lang_name = lang_name_c;\n \n@@ -6704,45 +6717,35 @@ cp_make_fname_decl (id, type_dep)\n   return decl;\n }\n \n-/* Entry point for the benefit of c_common_nodes_and_builtins.\n-\n-   Make a definition for a builtin function named NAME and whose data type\n-   is TYPE.  TYPE should be a function type with argument types.\n+/* Make a definition for a builtin function named NAME in the current\n+   namespace, whose data type is TYPE and whose context is CONTEXT.\n+   TYPE should be a function type with argument types.\n \n    CLASS and CODE tell later passes how to compile calls to this function.\n    See tree.h for possible values.\n \n    If LIBNAME is nonzero, use that for DECL_ASSEMBLER_NAME,\n    the name to be called if we can't opencode the function.  */\n \n-tree\n-builtin_function (name, type, code, class, libname)\n+static tree\n+builtin_function_1 (name, type, context, code, class, libname)\n      const char *name;\n      tree type;\n+     tree context;\n      int code;\n      enum built_in_class class;\n      const char *libname;\n {\n   tree decl = build_library_fn_1 (get_identifier (name), ERROR_MARK, type);\n   DECL_BUILT_IN_CLASS (decl) = class;\n   DECL_FUNCTION_CODE (decl) = code;\n+  DECL_CONTEXT (decl) = context;\n \n   /* The return builtins leave the current function.  */\n   if (code == BUILT_IN_RETURN || code == BUILT_IN_EH_RETURN)\n     TREE_THIS_VOLATILE (decl) = 1;\n \n-  my_friendly_assert (DECL_CONTEXT (decl) == NULL_TREE, 392);\n-\n-  /* All builtins that don't begin with an `_' should go in the `std'\n-     namespace.  */\n-  if (name[0] != '_')\n-    {\n-      push_namespace (std_identifier);\n-      DECL_CONTEXT (decl) = std_node;\n-    }\n   pushdecl (decl);\n-  if (name[0] != '_')\n-    pop_namespace ();\n \n   /* Since `pushdecl' relies on DECL_ASSEMBLER_NAME instead of DECL_NAME,\n      we cannot change DECL_ASSEMBLER_NAME until we have installed this\n@@ -6762,6 +6765,39 @@ builtin_function (name, type, code, class, libname)\n   return decl;\n }\n \n+/* Entry point for the benefit of c_common_nodes_and_builtins.\n+\n+   Make a defintion for a builtin function named NAME and whose data type\n+   is TYPE.  TYPE should be a function type with argument types.  This\n+   function places the anticipated declaration in the global namespace\n+   and additionally in the std namespace if appropriate.\n+\n+   CLASS and CODE tell later passes how to compile calls to this function.\n+   See tree.h for possible values.\n+\n+   If LIBNAME is nonzero, use that for DECL_ASSEMBLER_NAME,\n+   the name to be called if we can't opencode the function.  */\n+\n+tree\n+builtin_function (name, type, code, class, libname)\n+     const char *name;\n+     tree type;\n+     int code;\n+     enum built_in_class class;\n+     const char *libname;\n+{\n+  /* All builtins that don't begin with an '_' should additionally\n+     go in the 'std' namespace.  */\n+  if (name[0] != '_')\n+    {\n+      push_namespace (std_identifier);\n+      builtin_function_1 (name, type, std_node, code, class, libname);\n+      pop_namespace ();\n+    }\n+\n+  return builtin_function_1 (name, type, NULL_TREE, code, class, libname);\n+}\n+\n /* Generate a FUNCTION_DECL with the typical flags for a runtime library\n    function.  Not called directly.  */\n "}, {"sha": "95dc8e023db2d5ed2aa1871dfc7557da69415649", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d52e4867caba3a5833cc2c90ac8df8fe7ccd7b76/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d52e4867caba3a5833cc2c90ac8df8fe7ccd7b76/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=d52e4867caba3a5833cc2c90ac8df8fe7ccd7b76", "patch": "@@ -4178,6 +4178,11 @@ ambiguous_decl (name, old, new, flags)\n         if (LOOKUP_TYPES_ONLY (flags))\n           val = NULL_TREE;\n         break;\n+      case FUNCTION_DECL:\n+        /* Ignore built-in functions that are still anticipated.  */\n+        if (LOOKUP_QUALIFIERS_ONLY (flags) || DECL_ANTICIPATED (val))\n+          val = NULL_TREE;\n+        break;\n       default:\n         if (LOOKUP_QUALIFIERS_ONLY (flags))\n           val = NULL_TREE;\n@@ -4930,6 +4935,15 @@ do_nonmember_using_decl (scope, name, oldval, oldtype, newval, newtype)\n \t      else if (compparms (TYPE_ARG_TYPES (TREE_TYPE (new_fn)),\n \t\t  \t\t  TYPE_ARG_TYPES (TREE_TYPE (old_fn))))\n \t\t{\n+                  /* If this using declaration introduces a function\n+                     recognized as a built-in, no longer mark it as\n+                     anticipated in this scope.  */\n+                  if (DECL_ANTICIPATED (old_fn))\n+                    {\n+                      DECL_ANTICIPATED (old_fn) = 0;\n+                      break;\n+                    }\n+\n \t          /* There was already a non-using declaration in\n \t\t     this scope with the same parameter types. If both\n \t             are the same extern \"C\" functions, that's ok.  */"}, {"sha": "e9e660dc9722d496d1e749e0692c5b52425242e9", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d52e4867caba3a5833cc2c90ac8df8fe7ccd7b76/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d52e4867caba3a5833cc2c90ac8df8fe7ccd7b76/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=d52e4867caba3a5833cc2c90ac8df8fe7ccd7b76", "patch": "@@ -1326,7 +1326,8 @@ do_scoped_id (token, parsing)\n     id = IDENTIFIER_GLOBAL_VALUE (token);\n   if (parsing && yychar == YYEMPTY)\n     yychar = yylex ();\n-  if (! id)\n+  if (!id || (TREE_CODE (id) == FUNCTION_DECL\n+\t      && DECL_ANTICIPATED (id)))\n     {\n       if (processing_template_decl)\n \t{"}, {"sha": "606df33954187815184c60dde2bb2712fc9d8f88", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d52e4867caba3a5833cc2c90ac8df8fe7ccd7b76/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d52e4867caba3a5833cc2c90ac8df8fe7ccd7b76/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d52e4867caba3a5833cc2c90ac8df8fe7ccd7b76", "patch": "@@ -1,3 +1,11 @@\n+2002-03-28  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* g++.old-deja/g++.other/builtins5.C: New test.\n+\t* g++.old-deja/g++.other/builtins6.C: New test.\n+\t* g++.old-deja/g++.other/builtins7.C: New test.\n+\t* g++.old-deja/g++.other/builtins8.C: New test.\n+\t* g++.old-deja/g++.other/builtins9.C: New test.\n+\n 2002-03-29  Jakub Jelinek  <jakub@redhat.com>\n \n \t* g++.dg/opt/static1.C: New test."}, {"sha": "9a2cdaf289ff13bb1e72f4bbf4c057c4d7767cce", "filename": "gcc/testsuite/g++.old-deja/g++.other/builtins5.C", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d52e4867caba3a5833cc2c90ac8df8fe7ccd7b76/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fbuiltins5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d52e4867caba3a5833cc2c90ac8df8fe7ccd7b76/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fbuiltins5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fbuiltins5.C?ref=d52e4867caba3a5833cc2c90ac8df8fe7ccd7b76", "patch": "@@ -0,0 +1,16 @@\n+// Build don't link:\n+// Test that built-in functions aren't recognized without a prototype.\n+// Origin: Roger Sayle  Mar 20, 2002\n+// Copyright (C) 2002 Free Software Foundation.\n+\n+int\n+foo ()\n+{\n+  return (int) ::strlen (\"foo\"); // ERROR - undeclared\n+}\n+\n+int\n+bar ()\n+{\n+  return (int) std::strlen (\"bar\"); // ERROR - undeclared\n+}"}, {"sha": "347f4adda6d29149b826e8edb835502596e67044", "filename": "gcc/testsuite/g++.old-deja/g++.other/builtins6.C", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d52e4867caba3a5833cc2c90ac8df8fe7ccd7b76/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fbuiltins6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d52e4867caba3a5833cc2c90ac8df8fe7ccd7b76/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fbuiltins6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fbuiltins6.C?ref=d52e4867caba3a5833cc2c90ac8df8fe7ccd7b76", "patch": "@@ -0,0 +1,18 @@\n+// Test that built-in functions are recognized with a prototype.\n+// Origin: Roger Sayle  Mar 20, 2002\n+// Copyright (C) 2002 Free Software Foundation.\n+//\n+// Special g++ Options: -O2\n+\n+typedef __SIZE_TYPE__ size_t;\n+extern \"C\" size_t strlen (const char*);\n+extern \"C\" void link_error (void);\n+\n+int\n+main ()\n+{\n+  if (strlen (\"foo\") != 3)\n+    link_error ();\n+  return 0;\n+}\n+"}, {"sha": "9d4cb747487b18fd3abdbc6dde16dcdefee4a0f8", "filename": "gcc/testsuite/g++.old-deja/g++.other/builtins7.C", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d52e4867caba3a5833cc2c90ac8df8fe7ccd7b76/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fbuiltins7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d52e4867caba3a5833cc2c90ac8df8fe7ccd7b76/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fbuiltins7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fbuiltins7.C?ref=d52e4867caba3a5833cc2c90ac8df8fe7ccd7b76", "patch": "@@ -0,0 +1,20 @@\n+// Test that built-in functions are recognized with a prototype.\n+// Origin: Roger Sayle  Mar 20, 2002\n+// Copyright (C) 2002 Free Software Foundation.\n+//\n+// Special g++ Options: -O2\n+\n+extern \"C\" void link_error (void);\n+\n+namespace std {\n+typedef __SIZE_TYPE__ size_t;\n+extern \"C\" size_t strlen (const char*);\n+}\n+\n+int\n+main ()\n+{\n+  if (std::strlen (\"foo\") != 3)\n+    link_error ();\n+  return 0;\n+}"}, {"sha": "4eaa56ef26288b2083af60ad12031c3207b75f56", "filename": "gcc/testsuite/g++.old-deja/g++.other/builtins8.C", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d52e4867caba3a5833cc2c90ac8df8fe7ccd7b76/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fbuiltins8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d52e4867caba3a5833cc2c90ac8df8fe7ccd7b76/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fbuiltins8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fbuiltins8.C?ref=d52e4867caba3a5833cc2c90ac8df8fe7ccd7b76", "patch": "@@ -0,0 +1,24 @@\n+// Test that built-in functions are recognized with a prototype.\n+// Origin: Roger Sayle  Mar 20, 2002\n+// Copyright (C) 2002 Free Software Foundation.\n+//\n+// Special g++ Options: -O2\n+\n+\n+extern \"C\" void link_error (void);\n+\n+namespace std {\n+typedef __SIZE_TYPE__ size_t;\n+extern \"C\" size_t strlen (const char*);\n+}\n+\n+using namespace std;\n+\n+int\n+main ()\n+{\n+  if (strlen (\"foo\") != 3)\n+    link_error ();\n+  return 0;\n+}\n+"}, {"sha": "8f32c9fdb0757901dcdbffab9217baf4be99f236", "filename": "gcc/testsuite/g++.old-deja/g++.other/builtins9.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d52e4867caba3a5833cc2c90ac8df8fe7ccd7b76/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fbuiltins9.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d52e4867caba3a5833cc2c90ac8df8fe7ccd7b76/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fbuiltins9.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fbuiltins9.C?ref=d52e4867caba3a5833cc2c90ac8df8fe7ccd7b76", "patch": "@@ -0,0 +1,13 @@\n+// Test that inline redeclarations of builtins are emitted.\n+// Origin: Roger Sayle  Mar 28, 2002\n+// Copyright (C) 2002 Free Software Foundation.\n+\n+namespace std {\n+   inline int fabs (void) { return 0; }\n+}\n+\n+\n+int main ()\n+{\n+   return std::fabs ();\n+}"}, {"sha": "f280238833fcd57bf8cf874eb2983b8d42d3188f", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d52e4867caba3a5833cc2c90ac8df8fe7ccd7b76/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d52e4867caba3a5833cc2c90ac8df8fe7ccd7b76/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=d52e4867caba3a5833cc2c90ac8df8fe7ccd7b76", "patch": "@@ -1,3 +1,9 @@\n+2002-03-27  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* include/c_std/std_cmath.h:  To prevent problems overloading\n+\tg++ builtins, use the double variants from the global namespace\n+\tbefore defining float and long double variants in std::.\n+\n 2002-03-28  Loren J. Rittle <ljrittle@acm.org>\n \n \t* testsuite/18_support/numeric_limits.cc (test_extrema): Fix typo."}, {"sha": "9e05900b1809e6e73340d08bdf5cece4a2124030", "filename": "libstdc++-v3/include/c_std/std_cmath.h", "status": "modified", "additions": 51, "deletions": 51, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d52e4867caba3a5833cc2c90ac8df8fe7ccd7b76/libstdc%2B%2B-v3%2Finclude%2Fc_std%2Fstd_cmath.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d52e4867caba3a5833cc2c90ac8df8fe7ccd7b76/libstdc%2B%2B-v3%2Finclude%2Fc_std%2Fstd_cmath.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fc_std%2Fstd_cmath.h?ref=d52e4867caba3a5833cc2c90ac8df8fe7ccd7b76", "patch": "@@ -89,14 +89,14 @@ namespace std\n       return __x < _Tp() ? -__x : __x;\n     }\n \n-  inline float\n-  abs(float __x)\n-  { return __builtin_fabsf(__x); }\n-\n   inline double\n   abs(double __x)\n   { return __builtin_fabs(__x); }\n \n+  inline float\n+  abs(float __x)\n+  { return __builtin_fabsf(__x); }\n+\n   inline long double\n   abs(long double __x)\n   { return __builtin_fabsl(__x); }\n@@ -119,6 +119,8 @@ namespace std\n   acos(long double __x) { return ::acos(static_cast<double>(__x)); }\n #endif\n \n+  using ::asin;\n+\n #if _GLIBCPP_HAVE_ASINF\n   inline float \n   asin(float __x) { return ::asinf(__x); }\n@@ -127,8 +129,6 @@ namespace std\n   asin(float __x) { return ::asin(static_cast<double>(__x)); }\n #endif\n \n-  using ::asin;\n-\n #if _GLIBCPP_HAVE_ASINL\n   inline long double \n   asin(long double __x) { return ::asinl(__x); }\n@@ -137,6 +137,8 @@ namespace std\n   asin(long double __x) { return ::asin(static_cast<double>(__x)); }\n #endif\n \n+  using ::atan;\n+\n #if _GLIBCPP_HAVE_ATANF\n   inline float \n   atan(float __x) { return ::atanf(__x); }\n@@ -145,8 +147,6 @@ namespace std\n   atan(float __x) { return ::atan(static_cast<double>(__x)); }\n #endif\n \n-  using ::atan;\n-\n #if _GLIBCPP_HAVE_ATANL\n   inline long double \n   atan(long double __x) { return ::atanl(__x); }\n@@ -155,6 +155,8 @@ namespace std\n   atan(long double __x) { return ::atan(static_cast<double>(__x)); }\n #endif\n \n+  using ::atan2;\n+\n #if _GLIBCPP_HAVE_ATAN2F\n   inline float \n   atan2(float __y, float __x) { return ::atan2f(__y, __x); }\n@@ -164,8 +166,6 @@ namespace std\n   { return ::atan2(static_cast<double>(__y), static_cast<double>(__x)); }\n #endif\n \n-  using ::atan2;\n-\n #if _GLIBCPP_HAVE_ATAN2L\n   inline long double \n   atan2(long double __y, long double __x) { return ::atan2l(__y, __x); }\n@@ -175,6 +175,8 @@ namespace std\n   { return ::atan2(static_cast<double>(__y), static_cast<double>(__x)); }\n #endif\n \n+  using ::ceil;\n+\n #if _GLIBCPP_HAVE_CEILF\n   inline float \n   ceil(float __x) { return ::ceilf(__x); }\n@@ -183,8 +185,6 @@ namespace std\n   ceil(float __x) { return ::ceil(static_cast<double>(__x)); }\n #endif\n \n-  using ::ceil;\n-\n #if _GLIBCPP_HAVE_CEILL\n   inline long double \n   ceil(long double __x) { return ::ceill(__x); }\n@@ -193,16 +193,18 @@ namespace std\n   ceil(long double __x) { return ::ceil(static_cast<double>(__x)); }\n #endif\n \n+  using ::cos;\n+\n   inline float\n   cos(float __x)\n   { return __builtin_cosf(__x); }\n \n-  using ::cos;\n-\n   inline long double\n   cos(long double __x)\n   { return __builtin_cosl(__x); }\n \n+  using ::cosh;\n+\n #if _GLIBCPP_HAVE_COSHF\n   inline float \n   cosh(float __x) { return ::coshf(__x); }\n@@ -211,8 +213,6 @@ namespace std\n   cosh(float __x) { return ::cosh(static_cast<double>(__x)); }\n #endif\n \n-  using ::cosh;\n-\n #if _GLIBCPP_HAVE_COSHL\n   inline long double \n   cosh(long double __x) { return ::coshl(__x); }\n@@ -221,6 +221,8 @@ namespace std\n   cosh(long double __x) { return ::cosh(static_cast<double>(__x)); }\n #endif\n \n+  using ::exp;\n+\n #if _GLIBCPP_HAVE_EXPF\n   inline float \n   exp(float __x) { return ::expf(__x); }\n@@ -229,8 +231,6 @@ namespace std\n   exp(float __x) { return ::exp(static_cast<double>(__x)); }\n #endif\n \n-  using ::exp;\n-\n #if _GLIBCPP_HAVE_EXPL\n   inline long double \n   exp(long double __x) { return ::expl(__x); }\n@@ -239,16 +239,18 @@ namespace std\n   exp(long double __x) { return ::exp(static_cast<double>(__x)); }\n #endif\n \n+  using ::fabs;\n+\n   inline float\n   fabs(float __x)\n   { return __builtin_fabsf(__x); }\n \n-  using ::fabs;\n-\n   inline long double\n   fabs(long double __x)\n   { return __builtin_fabsl(__x); }\n \n+  using ::floor;\n+\n #if _GLIBCPP_HAVE_FLOORF\n   inline float \n   floor(float __x) { return ::floorf(__x); }\n@@ -257,8 +259,6 @@ namespace std\n   floor(float __x) { return ::floor(static_cast<double>(__x)); }\n #endif\n \n-  using ::floor;\n-\n #if _GLIBCPP_HAVE_FLOORL\n   inline long double \n   floor(long double __x) { return ::floorl(__x); }\n@@ -267,6 +267,8 @@ namespace std\n   floor(long double __x) { return ::floor(static_cast<double>(__x)); }\n #endif\n \n+  using ::fmod;\n+\n #if _GLIBCPP_HAVE_FMODF\n   inline float \n   fmod(float __x, float __y) { return ::fmodf(__x, __y); }\n@@ -276,8 +278,6 @@ namespace std\n   { return ::fmod(static_cast<double>(__x), static_cast<double>(__y)); }\n #endif\n \n-  using ::fmod;\n-\n #if _GLIBCPP_HAVE_FMODL\n   inline long double \n   fmod(long double __x, long double __y) { return ::fmodl(__x, __y); }\n@@ -287,6 +287,8 @@ namespace std\n   { return ::fmod(static_cast<double>(__x), static_cast<double>(__y)); }\n #endif\n \n+  using ::frexp;\n+\n #if _GLIBCPP_HAVE_FREXPF\n   inline float \n   frexp(float __x, int* __exp) { return ::frexpf(__x, __exp); }\n@@ -295,8 +297,6 @@ namespace std\n   frexp(float __x, int* __exp) { return ::frexp(__x, __exp); }\n #endif\n \n-  using ::frexp;\n-\n #if _GLIBCPP_HAVE_FREXPL\n   inline long double \n   frexp(long double __x, int* __exp) { return ::frexpl(__x, __exp); }\n@@ -306,6 +306,8 @@ namespace std\n   { return ::frexp(static_cast<double>(__x), __exp); }\n #endif\n \n+  using ::ldexp;\n+\n #if _GLIBCPP_HAVE_LDEXPF\n   inline float \n   ldexp(float __x, int __exp) { return ::ldexpf(__x, __exp); }\n@@ -315,8 +317,6 @@ namespace std\n   { return ::ldexp(static_cast<double>(__x), __exp); }\n #endif\n \n-  using ::ldexp;\n-\n #if _GLIBCPP_HAVE_LDEXPL\n   inline long double \n   ldexp(long double __x, int __exp) { return ::ldexpl(__x, __exp); }\n@@ -326,6 +326,8 @@ namespace std\n   { return ::ldexp(static_cast<double>(__x), __exp); }\n #endif\n \n+  using ::log;\n+\n #if _GLIBCPP_HAVE_LOGF\n   inline float \n   log(float __x) { return ::logf(__x); }\n@@ -334,8 +336,6 @@ namespace std\n   { return ::log(static_cast<double>(__x)); }\n #endif\n \n-  using ::log;\n-\n #if _GLIBCPP_HAVE_LOGL\n   inline long double \n   log(long double __x) { return ::logl(__x); }\n@@ -344,6 +344,8 @@ namespace std\n   log(long double __x) { return ::log(static_cast<double>(__x)); }\n #endif\n \n+  using ::log10;\n+\n #if _GLIBCPP_HAVE_LOG10F\n   inline float \n   log10(float __x) { return ::log10f(__x); }\n@@ -352,8 +354,6 @@ namespace std\n   log10(float __x) { return ::log10(static_cast<double>(__x)); }\n #endif\n \n-  using ::log10;\n-\n #if _GLIBCPP_HAVE_LOG10L\n   inline long double \n   log10(long double __x) { return ::log10l(__x); }\n@@ -362,6 +362,8 @@ namespace std\n   log10(long double __x) { return ::log10(static_cast<double>(__x)); }\n #endif\n \n+  using ::modf;\n+\n #if _GLIBCPP_HAVE_MODFF\n   inline float \n   modf(float __x, float* __iptr) { return ::modff(__x, __iptr); }\n@@ -376,8 +378,6 @@ namespace std\n   }\n #endif\n \n-  using ::modf;\n-\n #if _GLIBCPP_HAVE_MODFL\n   inline long double \n   modf(long double __x, long double* __iptr) { return ::modfl(__x, __iptr); }\n@@ -400,7 +400,9 @@ namespace std\n         ? _Tp(1)/__cmath_power(__x, -__n)\n         : __cmath_power(__x, __n);\n     }\n-  \n+\n+  using ::pow;\n+\n #if _GLIBCPP_HAVE_POWF\n   inline float \n   pow(float __x, float __y) { return ::powf(__x, __y); }\n@@ -410,8 +412,6 @@ namespace std\n   { return ::pow(static_cast<double>(__x), static_cast<double>(__y)); }\n #endif\n \n-  using ::pow;\n-\n #if _GLIBCPP_HAVE_POWL\n   inline long double \n   pow(long double __x, long double __y) { return ::powl(__x, __y); }\n@@ -421,28 +421,30 @@ namespace std\n   { return ::pow(static_cast<double>(__x), static_cast<double>(__y)); }\n #endif\n \n-  inline float \n-  pow(float __x, int __n)\n-  { return __pow_helper(__x, __n); }\n-\n   inline double \n   pow(double __x, int __i)\n   { return __pow_helper(__x, __i); }\n \n+  inline float \n+  pow(float __x, int __n)\n+  { return __pow_helper(__x, __n); }\n+\n   inline long double \n   pow(long double __x, int __n)\n   { return __pow_helper(__x, __n); }\n \n+  using ::sin;\n+\n   inline float\n   sin(float __x)\n   { return __builtin_sinf(__x); }\n \n-  using ::sin;\n-\n   inline long double\n   sin(long double __x)\n   { return __builtin_sinl(__x); }\n \n+  using ::sinh;\n+\n #if _GLIBCPP_HAVE_SINHF\n   inline float \n   sinh(float __x) { return ::sinhf(__x); }\n@@ -451,8 +453,6 @@ namespace std\n   sinh(float __x) { return ::sinh(static_cast<double>(__x)); }\n #endif\n \n-  using ::sinh;\n-\n #if _GLIBCPP_HAVE_SINHL\n   inline long double \n   sinh(long double __x) { return ::sinhl(__x); }\n@@ -461,16 +461,18 @@ namespace std\n   sinh(long double __x) { return ::sinh(static_cast<double>(__x)); }\n #endif\n \n+  using ::sqrt;\n+\n   inline float\n   sqrt(float __x)\n   { return __builtin_sqrtf(__x); }\n \n-  using ::sqrt;\n-\n   inline long double\n   sqrt(long double __x)\n   { return __builtin_sqrtl(__x); }\n \n+  using ::tan;\n+\n #if _GLIBCPP_HAVE_TANF\n   inline float \n   tan(float __x) { return ::tanf(__x); }\n@@ -479,8 +481,6 @@ namespace std\n   tan(float __x) { return ::tan(static_cast<double>(__x)); }\n #endif\n \n-  using ::tan;\n-\n #if _GLIBCPP_HAVE_TANL\n   inline long double \n   tan(long double __x) { return ::tanl(__x); }\n@@ -489,6 +489,8 @@ namespace std\n   tan(long double __x) { return ::tan(static_cast<double>(__x)); }\n #endif\n \n+  using ::tanh;\n+\n #if _GLIBCPP_HAVE_TANHF\n   inline float \n   tanh(float __x) { return ::tanhf(__x); }\n@@ -497,8 +499,6 @@ namespace std\n   tanh(float __x) { return ::tanh(static_cast<double>(__x)); }\n #endif\n \n-  using ::tanh;\n-\n #if _GLIBCPP_HAVE_TANHL\n   inline long double \n   tanh(long double __x) { return ::tanhl(__x); }"}]}