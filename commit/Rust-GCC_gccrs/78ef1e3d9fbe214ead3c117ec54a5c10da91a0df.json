{"sha": "78ef1e3d9fbe214ead3c117ec54a5c10da91a0df", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzhlZjFlM2Q5ZmJlMjE0ZWFkM2MxMTdlYzU0YTVjMTBkYTkxYTBkZg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2005-01-26T23:18:14Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2005-01-26T23:18:14Z"}, "message": "re PR middle-end/18008 (Duplicate mask on bitfield insertion)\n\n        PR middle-end/18008\n        * c-decl.c (finish_struct): Set DECL_MODE after resetting a\n        field's type.\n        * expmed.c (store_fixed_bit_field): Create a paradoxical subreg\n        if we don't need the bits above those present in the current mode.\n        * expr.c (store_field): Strip conversions to odd-bit-sized types\n        if the destination field width matches.\n\nFrom-SVN: r94290", "tree": {"sha": "c288833747703ad1533d198a783c87c3ac5711f2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c288833747703ad1533d198a783c87c3ac5711f2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/78ef1e3d9fbe214ead3c117ec54a5c10da91a0df", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/78ef1e3d9fbe214ead3c117ec54a5c10da91a0df", "html_url": "https://github.com/Rust-GCC/gccrs/commit/78ef1e3d9fbe214ead3c117ec54a5c10da91a0df", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/78ef1e3d9fbe214ead3c117ec54a5c10da91a0df/comments", "author": null, "committer": null, "parents": [{"sha": "5596990fafed164e66c78bb1f4ec82eb58ba0042", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5596990fafed164e66c78bb1f4ec82eb58ba0042", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5596990fafed164e66c78bb1f4ec82eb58ba0042"}], "stats": {"total": 36, "additions": 32, "deletions": 4}, "files": [{"sha": "7b5f4dc2ca418dfe2a653711beb45187c057c764", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78ef1e3d9fbe214ead3c117ec54a5c10da91a0df/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78ef1e3d9fbe214ead3c117ec54a5c10da91a0df/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=78ef1e3d9fbe214ead3c117ec54a5c10da91a0df", "patch": "@@ -1,3 +1,13 @@\n+2005-01-26  Richard Henderson  <rth@redhat.com>\n+\n+\tPR middle-end/18008\n+\t* c-decl.c (finish_struct): Set DECL_MODE after resetting a\n+\tfield's type.\n+\t* expmed.c (store_fixed_bit_field): Create a paradoxical subreg\n+\tif we don't need the bits above those present in the current mode.\n+\t* expr.c (store_field): Strip conversions to odd-bit-sized types\n+\tif the destination field width matches.\n+\n 2005-01-26  Richard Sandiford  <rsandifo@redhat.com>\n \n \t* config/mips/iris6.h (ENDFILE_SPEC): Don't link in irix-csr.o if\n@@ -33,6 +43,7 @@\n \t* configure.ac: Check for a TLS capable gas.\n \n \t* configure: Regenerate.\n+\n 2005-01-26  Richard Henderson  <rth@redhat.com>\n \n \tPR middle-end/18008"}, {"sha": "61521e861c7b40b0a2b5d201bb78960150b999d5", "filename": "gcc/c-decl.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78ef1e3d9fbe214ead3c117ec54a5c10da91a0df/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78ef1e3d9fbe214ead3c117ec54a5c10da91a0df/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=78ef1e3d9fbe214ead3c117ec54a5c10da91a0df", "patch": "@@ -5301,8 +5301,11 @@ finish_struct (tree t, tree fieldlist, tree attributes)\n \t    = tree_low_cst (DECL_INITIAL (*fieldlistp), 1);\n \t  tree type = TREE_TYPE (*fieldlistp);\n \t  if (width != TYPE_PRECISION (type))\n-\t    TREE_TYPE (*fieldlistp)\n-\t      = build_nonstandard_integer_type (width, TYPE_UNSIGNED (type));\n+\t    {\n+\t      TREE_TYPE (*fieldlistp)\n+\t        = build_nonstandard_integer_type (width, TYPE_UNSIGNED (type));\n+\t      DECL_MODE (*fieldlistp) = TYPE_MODE (TREE_TYPE (*fieldlistp));\n+\t    }\n \t  DECL_INITIAL (*fieldlistp) = 0;\n \t}\n       else"}, {"sha": "084a987fdc04e755d90e39d47579ac94ce0827d9", "filename": "gcc/expmed.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78ef1e3d9fbe214ead3c117ec54a5c10da91a0df/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78ef1e3d9fbe214ead3c117ec54a5c10da91a0df/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=78ef1e3d9fbe214ead3c117ec54a5c10da91a0df", "patch": "@@ -878,7 +878,7 @@ store_fixed_bit_field (rtx op0, unsigned HOST_WIDE_INT offset,\n       if (GET_MODE (value) != mode)\n \t{\n \t  if ((REG_P (value) || GET_CODE (value) == SUBREG)\n-\t      && GET_MODE_SIZE (mode) < GET_MODE_SIZE (GET_MODE (value)))\n+\t      && GET_MODE_SIZE (GET_MODE (value)) <= bitsize)\n \t    value = gen_lowpart (mode, value);\n \t  else\n \t    value = convert_to_mode (mode, value, 1);"}, {"sha": "1f82b1d98346a6745cb1c037b191297bbddc9164", "filename": "gcc/expr.c", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78ef1e3d9fbe214ead3c117ec54a5c10da91a0df/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78ef1e3d9fbe214ead3c117ec54a5c10da91a0df/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=78ef1e3d9fbe214ead3c117ec54a5c10da91a0df", "patch": "@@ -5215,7 +5215,21 @@ store_field (rtx target, HOST_WIDE_INT bitsize, HOST_WIDE_INT bitpos,\n \t  && TREE_CODE (TYPE_SIZE (TREE_TYPE (exp))) == INTEGER_CST\n \t  && compare_tree_int (TYPE_SIZE (TREE_TYPE (exp)), bitsize) != 0))\n     {\n-      rtx temp = expand_expr (exp, NULL_RTX, VOIDmode, 0);\n+      rtx temp;\n+\n+      /* If EXP is a NOP_EXPR of precision less than its mode, then that\n+\t implies a mask operation.  If the precision is the same size as\n+\t the field we're storing into, that mask is redundant.  This is\n+\t particularly common with bit field assignments generated by the\n+\t C front end.  */\n+      if (TREE_CODE (exp) == NOP_EXPR\n+\t  && INTEGRAL_TYPE_P (TREE_TYPE (exp))\n+\t  && (TYPE_PRECISION (TREE_TYPE (exp))\n+\t      < GET_MODE_BITSIZE (TYPE_MODE (TREE_TYPE (exp))))\n+\t  && bitsize == TYPE_PRECISION (TREE_TYPE (exp)))\n+\texp = TREE_OPERAND (exp, 0);\n+\n+      temp = expand_expr (exp, NULL_RTX, VOIDmode, 0);\n \n       /* If BITSIZE is narrower than the size of the type of EXP\n \t we will be narrowing TEMP.  Normally, what's wanted are the"}]}