{"sha": "073ae293d97f76c66767fdce57f6f6e3ef58b612", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDczYWUyOTNkOTdmNzZjNjY3NjdmZGNlNTdmNmY2ZTNlZjU4YjYxMg==", "commit": {"author": {"name": "Andreas Tobler", "email": "toa@pop.agri.ch", "date": "2002-03-07T18:24:42Z"}, "committer": {"name": "David Edelsohn", "email": "dje@gcc.gnu.org", "date": "2002-03-07T18:24:42Z"}, "message": "Makefile.am (EXTRA_DIST): Add Darwin and AIX closure files.\n\n2002-03-07  Andreas Tobler  <toa@pop.agri.ch>\n\t    David Edelsohn  <edelsohn@gnu.org>\n\n\t* Makefile.am (EXTRA_DIST): Add Darwin and AIX closure files.\n\t(TARGET_SRC_POWERPC_AIX): Add aix_closure.S.\n\t(TARGET_SRC_POWERPC_DARWIN): Add darwin_closure.S.\n\t* Makefile.in: Regenerate.\n\t* include/ffi.h.in: Add AIX and Darwin closure definitions.\n\t* src/powerpc/ffi_darwin.c (ffi_prep_closure): New function.\n\t(flush_icache, flush_range): New functions.\n\t(ffi_closure_helper_DARWIN): New function.\n\t* src/powerpc/aix_closure.S: New file.\n\t* src/powerpc/darwin_closure.S: New file.\n\nCo-Authored-By: David Edelsohn <edelsohn@gnu.org>\n\nFrom-SVN: r50408", "tree": {"sha": "2067fd3b0161aebe36726eaf4d9574b16aa6c1d3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2067fd3b0161aebe36726eaf4d9574b16aa6c1d3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/073ae293d97f76c66767fdce57f6f6e3ef58b612", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/073ae293d97f76c66767fdce57f6f6e3ef58b612", "html_url": "https://github.com/Rust-GCC/gccrs/commit/073ae293d97f76c66767fdce57f6f6e3ef58b612", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/073ae293d97f76c66767fdce57f6f6e3ef58b612/comments", "author": null, "committer": null, "parents": [{"sha": "fcf742eac8e28d8867e19a17fa21999c300166db", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fcf742eac8e28d8867e19a17fa21999c300166db", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fcf742eac8e28d8867e19a17fa21999c300166db"}], "stats": {"total": 825, "additions": 816, "deletions": 9}, "files": [{"sha": "382e73bfcde3516b3ef03f1bd2a22533bd279e4a", "filename": "libffi/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073ae293d97f76c66767fdce57f6f6e3ef58b612/libffi%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073ae293d97f76c66767fdce57f6f6e3ef58b612/libffi%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2FChangeLog?ref=073ae293d97f76c66767fdce57f6f6e3ef58b612", "patch": "@@ -1,3 +1,17 @@\n+2002-03-07  Andreas Tobler  <toa@pop.agri.ch>\n+\t    David Edelsohn  <edelsohn@gnu.org>\n+\n+\t* Makefile.am (EXTRA_DIST): Add Darwin and AIX closure files.\n+\t(TARGET_SRC_POWERPC_AIX): Add aix_closure.S.\n+\t(TARGET_SRC_POWERPC_DARWIN): Add darwin_closure.S.\n+\t* Makefile.in: Regenerate.\n+\t* include/ffi.h.in: Add AIX and Darwin closure definitions.\n+\t* src/powerpc/ffi_darwin.c (ffi_prep_closure): New function.\n+\t(flush_icache, flush_range): New functions.\n+\t(ffi_closure_helper_DARWIN): New function.\n+\t* src/powerpc/aix_closure.S: New file.\n+\t* src/powerpc/darwin_closure.S: New file.\n+\t\n 2002-02-24  Jeff Sturm  <jsturm@one-point.com>\n \n \t* include/ffi.h.in: Add typedef for ffi_arg."}, {"sha": "eece0813bc991f4c0c08dd5d785334435d4ddddb", "filename": "libffi/Makefile.am", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073ae293d97f76c66767fdce57f6f6e3ef58b612/libffi%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073ae293d97f76c66767fdce57f6f6e3ef58b612/libffi%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2FMakefile.am?ref=073ae293d97f76c66767fdce57f6f6e3ef58b612", "patch": "@@ -14,6 +14,7 @@ EXTRA_DIST = LICENSE ChangeLog.v1 src/mips/ffi.c src/mips/n32.S \\\n \t\tsrc/powerpc/ppc_closure.S src/powerpc/asm.h \\\n \t\tsrc/powerpc/ffi_darwin.c \\\n \t\tsrc/powerpc/darwin.S src/powerpc/aix.S \\\n+\t\tsrc/powerpc/darwin_closure.S src/powerpc/aix_closures.S \\\n \t\tsrc/arm/ffi.c src/arm/sysv.S\n \n VPATH = @srcdir@:@srcdir@/src:@srcdir@/src/@TARGETDIR@\n@@ -99,8 +100,8 @@ TARGET_SRC_ALPHA = src/alpha/ffi.c src/alpha/osf.S\n TARGET_SRC_IA64 = src/ia64/ffi.c src/ia64/unix.S\n TARGET_SRC_M68K = src/m68k/ffi.c src/m68k/sysv.S\n TARGET_SRC_POWERPC = src/powerpc/ffi.c src/powerpc/sysv.S src/powerpc/ppc_closure.S\n-TARGET_SRC_POWERPC_AIX = src/powerpc/ffi_darwin.c src/powerpc/aix.S\n-TARGET_SRC_POWERPC_DARWIN = src/powerpc/ffi_darwin.c src/powerpc/darwin.S\n+TARGET_SRC_POWERPC_AIX = src/powerpc/ffi_darwin.c src/powerpc/aix.S src/powerpc/aix_closures.S\n+TARGET_SRC_POWERPC_DARWIN = src/powerpc/ffi_darwin.c src/powerpc/darwin.S src/powerpc/darwin_closure.S\n TARGET_SRC_ARM =  src/arm/sysv.S src/arm/ffi.c\n \n ##libffi_la_SOURCES = src/debug.c src/prep_cif.c src/types.c $(TARGET_SRC_@TARGET@)"}, {"sha": "f0f0348fd7cdb8d7e147ffbf27669e9ebf164aa6", "filename": "libffi/Makefile.in", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073ae293d97f76c66767fdce57f6f6e3ef58b612/libffi%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073ae293d97f76c66767fdce57f6f6e3ef58b612/libffi%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2FMakefile.in?ref=073ae293d97f76c66767fdce57f6f6e3ef58b612", "patch": "@@ -95,6 +95,7 @@ EXTRA_DIST = LICENSE ChangeLog.v1 src/mips/ffi.c src/mips/n32.S \\\n \t\tsrc/powerpc/ppc_closure.S src/powerpc/asm.h \\\n \t\tsrc/powerpc/ffi_darwin.c \\\n \t\tsrc/powerpc/darwin.S src/powerpc/aix.S \\\n+\t\tsrc/powerpc/darwin_closure.S src/powerpc/aix_closure.S \\\n \t\tsrc/arm/ffi.c src/arm/sysv.S\n \n \n@@ -170,8 +171,8 @@ TARGET_SRC_ALPHA = src/alpha/ffi.c src/alpha/osf.S\n TARGET_SRC_IA64 = src/ia64/ffi.c src/ia64/unix.S\n TARGET_SRC_M68K = src/m68k/ffi.c src/m68k/sysv.S\n TARGET_SRC_POWERPC = src/powerpc/ffi.c src/powerpc/sysv.S src/powerpc/ppc_closure.S\n-TARGET_SRC_POWERPC_AIX = src/powerpc/ffi_darwin.c src/powerpc/aix.S\n-TARGET_SRC_POWERPC_DARWIN = src/powerpc/ffi_darwin.c src/powerpc/darwin.S\n+TARGET_SRC_POWERPC_AIX = src/powerpc/ffi_darwin.c src/powerpc/aix.S src/powerpc/aix_closure.S\n+TARGET_SRC_POWERPC_DARWIN = src/powerpc/ffi_darwin.c src/powerpc/darwin.S src/powerpc/darwin_closure.S\n TARGET_SRC_ARM = src/arm/sysv.S src/arm/ffi.c\n \n libffi_la_common_SOURCES = src/debug.c src/prep_cif.c src/types.c \\\n@@ -252,11 +253,11 @@ libfficonvenience_la_LIBADD =\n @POWERPC_AIX_TRUE@libfficonvenience_la_OBJECTS =  src/debug.lo \\\n @POWERPC_AIX_TRUE@src/prep_cif.lo src/types.lo src/raw_api.lo \\\n @POWERPC_AIX_TRUE@src/java_raw_api.lo src/powerpc/ffi_darwin.lo \\\n-@POWERPC_AIX_TRUE@src/powerpc/aix.lo\n+@POWERPC_AIX_TRUE@src/powerpc/aix.lo src/powerpc/aix_closure.lo\n @POWERPC_DARWIN_TRUE@libfficonvenience_la_OBJECTS =  src/debug.lo \\\n @POWERPC_DARWIN_TRUE@src/prep_cif.lo src/types.lo src/raw_api.lo \\\n @POWERPC_DARWIN_TRUE@src/java_raw_api.lo src/powerpc/ffi_darwin.lo \\\n-@POWERPC_DARWIN_TRUE@src/powerpc/darwin.lo\n+@POWERPC_DARWIN_TRUE@src/powerpc/darwin.lo src/powerpc/darwin_closure.lo\n @MIPS_SGI_TRUE@libfficonvenience_la_OBJECTS =  src/debug.lo \\\n @MIPS_SGI_TRUE@src/prep_cif.lo src/types.lo src/raw_api.lo \\\n @MIPS_SGI_TRUE@src/java_raw_api.lo src/mips/ffi.lo src/mips/o32.lo \\\n@@ -292,10 +293,12 @@ libffi_la_LIBADD =\n @IA64_TRUE@src/ia64/ffi.lo src/ia64/unix.lo\n @POWERPC_AIX_TRUE@libffi_la_OBJECTS =  src/debug.lo src/prep_cif.lo \\\n @POWERPC_AIX_TRUE@src/types.lo src/raw_api.lo src/java_raw_api.lo \\\n-@POWERPC_AIX_TRUE@src/powerpc/ffi_darwin.lo src/powerpc/aix.lo\n+@POWERPC_AIX_TRUE@src/powerpc/ffi_darwin.lo src/powerpc/aix.lo \\\n+@POWERPC_AIX_TRUE@src/powerpc/aix_closure.lo\n @POWERPC_DARWIN_TRUE@libffi_la_OBJECTS =  src/debug.lo src/prep_cif.lo \\\n @POWERPC_DARWIN_TRUE@src/types.lo src/raw_api.lo src/java_raw_api.lo \\\n-@POWERPC_DARWIN_TRUE@src/powerpc/ffi_darwin.lo src/powerpc/darwin.lo\n+@POWERPC_DARWIN_TRUE@src/powerpc/ffi_darwin.lo src/powerpc/darwin.lo \\\n+@POWERPC_DARWIN_TRUE@src/powerpc/darwin_closure.lo\n @MIPS_SGI_TRUE@libffi_la_OBJECTS =  src/debug.lo src/prep_cif.lo \\\n @MIPS_SGI_TRUE@src/types.lo src/raw_api.lo src/java_raw_api.lo \\\n @MIPS_SGI_TRUE@src/mips/ffi.lo src/mips/o32.lo src/mips/n32.lo"}, {"sha": "8097917fe105ce802c681b82ced462249650a767", "filename": "libffi/include/ffi.h.in", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073ae293d97f76c66767fdce57f6f6e3ef58b612/libffi%2Finclude%2Fffi.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073ae293d97f76c66767fdce57f6f6e3ef58b612/libffi%2Finclude%2Fffi.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Finclude%2Fffi.h.in?ref=073ae293d97f76c66767fdce57f6f6e3ef58b612", "patch": "@@ -412,13 +412,35 @@ struct ffi_ia64_trampoline_struct {\n #define FFI_TRAMPOLINE_SIZE 40\n #define FFI_NATIVE_RAW_API 0\n \n+#elif defined(POWERPC_DARWIN)\n+\n+#define FFI_CLOSURES 1\n+#define FFI_TRAMPOLINE_SIZE 40\n+#define FFI_NATIVE_RAW_API 0\n+\n+#elif defined(POWERPC_AIX)\n+\n+#define FFI_CLOSURES 1\n+#define FFI_TRAMPOLINE_SIZE 24 /* see struct below */ \n+#define FFI_NATIVE_RAW_API 0\n+\n #else \n \n #define FFI_CLOSURES 0\n #define FFI_NATIVE_RAW_API 0\n \n #endif\n \n+#if defined(POWERPC_DARWIN) || defined(POWERPC_AIX)\n+\n+struct ffi_aix_trampoline_struct {\n+    void * code_pointer;\t/* Pointer to ffi_closure_ASM */\n+    void * toc;\t\t\t/* TOC */\n+    void * static_chain;\t/* Pointer to closure */\n+};\n+\n+#endif\n+\n \n \n #if FFI_CLOSURES"}, {"sha": "7fa96f1fc954909449032d11576e87e421226c5a", "filename": "libffi/src/powerpc/aix_closure.S", "status": "added", "additions": 251, "deletions": 0, "changes": 251, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073ae293d97f76c66767fdce57f6f6e3ef58b612/libffi%2Fsrc%2Fpowerpc%2Faix_closure.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073ae293d97f76c66767fdce57f6f6e3ef58b612/libffi%2Fsrc%2Fpowerpc%2Faix_closure.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fpowerpc%2Faix_closure.S?ref=073ae293d97f76c66767fdce57f6f6e3ef58b612", "patch": "@@ -0,0 +1,251 @@\n+/* -----------------------------------------------------------------------\n+   aix_closures.S - Copyright (c) 2002 Free Software Foundation, Inc.\n+   based on darwin_closures.S \n+  \n+   PowerPC Assembly glue.\n+\n+   Permission is hereby granted, free of charge, to any person obtaining\n+   a copy of this software and associated documentation files (the\n+   ``Software''), to deal in the Software without restriction, including\n+   without limitation the rights to use, copy, modify, merge, publish,\n+   distribute, sublicense, and/or sell copies of the Software, and to\n+   permit persons to whom the Software is furnished to do so, subject to\n+   the following conditions:\n+\n+   The above copyright notice and this permission notice shall be included\n+   in all copies or substantial portions of the Software.\n+\n+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND, EXPRESS\n+   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n+   IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY CLAIM, DAMAGES OR\n+   OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\n+   ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n+   OTHER DEALINGS IN THE SOFTWARE.\n+   ----------------------------------------------------------------------- */\n+\n+\t.set r0,0\n+\t.set r1,1\n+\t.set r2,2\n+\t.set r3,3\n+\t.set r4,4\n+\t.set r5,5\n+\t.set r6,6\n+\t.set r7,7\n+\t.set r8,8\n+\t.set r9,9\n+\t.set r10,10\n+\t.set r11,11\n+\t.set r12,12\n+\t.set r13,13\n+\t.set r14,14\n+\t.set r15,15\n+\t.set r16,16\n+\t.set r17,17\n+\t.set r18,18\n+\t.set r19,19\n+\t.set r20,20\n+\t.set r21,21\n+\t.set r22,22\n+\t.set r23,23\n+\t.set r24,24\n+\t.set r25,25\n+\t.set r26,26\n+\t.set r27,27\n+\t.set r28,28\n+\t.set r29,29\n+\t.set r30,30\n+\t.set r31,31\n+\t.set f0,0\n+\t.set f1,1\n+\t.set f2,2\n+\t.set f3,3\n+\t.set f4,4\n+\t.set f5,5\n+\t.set f6,6\n+\t.set f7,7\n+\t.set f8,8\n+\t.set f9,9\n+\t.set f10,10\n+\t.set f11,11\n+\t.set f12,12\n+\t.set f13,13\n+\t.set f14,14\n+\t.set f15,15\n+\t.set f16,16\n+\t.set f17,17\n+\t.set f18,18\n+\t.set f19,19\n+\t.set f20,20\n+\t.set f21,21\n+\n+#define LIBFFI_ASM\n+#define JUMPTARGET(name) name\n+#define L(x) x\n+\t.file \"aix_closure.S\"\n+\t.toc\n+LC..60:\n+\t.tc L..60[TC],L..60\n+\t.csect .text[PR]\n+\t.align 2\n+\n+.csect .text[PR]\n+\t.align 2\n+\t.globl ffi_closure_ASM\n+\t.globl .ffi_closure_ASM\n+.csect ffi_closure_ASM[DS]\n+\n+ffi_closure_ASM:\n+\t.long .ffi_closure_ASM, TOC[tc0], 0\n+\t.csect .text[PR]\n+.ffi_closure_ASM:\n+\n+\tmflr r0\t\t\t/* extract return address */\n+\tstw r0, 8(r1)\t\t/* save the return address */\n+\t\n+\t/* 24 Bytes (Linkage Area) */\n+\t/* 32 Bytes (params) */\n+\t/* 104 Bytes (13*8 from FPR) */ \n+\t/* 4 Bytes (result)\n+\t/* 164 Bytes */\n+\t\n+\tstwu r1,-164(r1)\t/* skip over caller save area */\n+\n+/* we want to build up an area for the parameters passed */\n+/* in registers (both floating point and integer) */\n+\t\n+\t/* we store gpr 3 to gpr 10 (aligned to 4) */\n+\t/* in the parents outgoing area\t\t   */\n+\tstw   r3, 188(r1)\n+\tstw   r4, 192(r1)\n+\tstw   r5, 196(r1) \n+\tstw   r6, 200(r1)\n+\tstw   r7, 204(r1)\n+\tstw   r8, 208(r1) \n+\tstw   r9, 212(r1)\n+\tstw   r10, 216(r1)\n+\n+\t/* next save fpr 1 to fpr 13 (aligned to 8) */\n+\tstfd  f1, 56(r1)\n+\tstfd  f2, 64(r1)\n+\tstfd  f3, 72(r1)\n+\tstfd  f4, 80(r1)\n+\tstfd  f5, 88(r1)\n+\tstfd  f6, 96(r1)\n+\tstfd  f7, 104(r1)\n+\tstfd  f8, 112(r1)\n+\tstfd  f9, 120(r1) \n+\tstfd  f10, 128(r1) \n+\tstfd  f11, 136(r1) \n+\tstfd  f12, 144(r1) \n+\tstfd  f13, 152(r1)  \n+\n+\t/* set up registers for the routine that actually does the work */\n+\t/* get the context pointer from the trampoline */\n+\tmr r3,r11\n+\t\n+\t/* now load up the pointer to the result storage */\n+\taddi r4,r1,160\n+\t\n+\t/* now load up the pointer to the saved gpr registers */\n+\taddi r5,r1,188\n+\n+\t/* now load up the pointer to the saved fpr registers */\n+\taddi r6,r1,56\n+\n+\t/* now load up the pointer to the outgoing parameter  */\n+\t/* stack in the previous frame */\n+\taddi r7,r1,220\n+\t\n+\t/* make the call */\n+\tbl .ffi_closure_helper_DARWIN\n+\tnop\n+\n+\t/* now r3 contains the return type */\n+\t/* so use it to look up in a table */\n+\t/* so we know how to deal with each type */\n+\n+\t/* look up the proper starting point in table  */\n+\t/* by using return type as offset */\n+\taddi r5,r1,160\t\t/* get pointer to results area */\n+\tlwz r4,LC..60(2)\t/* get address of jump table */\n+\tslwi r3,r3,2\t\t/* now multiply return type by 4 */\n+\tlwzx r3,r4,r3\t\t/* get the contents of that table value */\n+\tadd r3,r3,r4\t\t/* add contents of table to table address */\n+\tmtctr r3\n+\tbctr\t\t\t/* jump to it */\n+\n+L..60:\n+\t.long L..44-L..60    /* FFI_TYPE_VOID */\n+\t.long L..50-L..60    /* FFI_TYPE_INT */\n+\t.long L..47-L..60    /* FFI_TYPE_FLOAT */\n+\t.long L..46-L..60    /* FFI_TYPE_DOUBLE */\n+\t.long L..46-L..60    /* FFI_TYPE_LONGDOUBLE */\n+\t.long L..56-L..60    /* FFI_TYPE_UINT8 */\n+\t.long L..55-L..60    /* FFI_TYPE_SINT8 */\n+\t.long L..58-L..60    /* FFI_TYPE_UINT16 */\n+\t.long L..57-L..60    /* FFI_TYPE_SINT16 */\n+\t.long L..50-L..60    /* FFI_TYPE_UINT32 */\n+\t.long L..50-L..60    /* FFI_TYPE_SINT32 */\n+\t.long L..48-L..60    /* FFI_TYPE_UINT64 */\n+\t.long L..48-L..60    /* FFI_TYPE_SINT64 */\n+\t.long L..44-L..60    /* FFI_TYPE_STRUCT */\n+\t.long L..50-L..60    /* FFI_TYPE_POINTER */\n+\n+\n+/* case double */\n+L..46:   \n+\tlfd f1,0(r5)\n+\tb L..44\n+\n+/* case float */\n+L..47:\n+\tlfs f1,0(r5)\n+\tb L..44\n+\t\n+/* case long long */\n+L..48:\n+\tlwz r3,0(r5)\n+\tlwz r4,4(r5)\n+\tb L..44\n+\t\n+/* case default / int32 / pointer */\n+L..50:\n+\tlwz r3,0(r5)\n+\tb L..44\n+\t\n+/* case signed int8\t */\n+L..55:\n+\taddi r5,r5,3\n+\tlbz r3,0(r5)\n+\tslwi r3,r3,24\n+\tsrawi r3,r3,24\n+\tb L..44\n+\n+/* case unsigned int8\t */\n+L..56:\n+\taddi r5,r5,3\n+\tlbz r3,0(r5)\n+\tb L..44\n+\n+/* case signed int16 */\n+L..57:\n+\taddi r5,r5,2\n+\tlhz r3,0(r5)\n+\textsh r3,r3\n+\tb L..44\n+\n+/* case unsigned int16 */\n+L..58:\t\n+\taddi r5,r5,2\n+\tlhz r3,0(r5)\n+\n+/* case void / done\t */\n+L..44:\n+\t\n+\taddi r1,r1,164\t\t/* restore stack pointer */\n+\tlwz r0,8(r1)\t\t/* get return address */\n+\tmtlr r0\t\t\t/* reset link register */\n+\tblr\n+\t\n+/* END(ffi_closure_ASM) */"}, {"sha": "9e54d2231b9ef82370a4c091e4df485e58f82fa5", "filename": "libffi/src/powerpc/darwin_closure.S", "status": "added", "additions": 189, "deletions": 0, "changes": 189, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073ae293d97f76c66767fdce57f6f6e3ef58b612/libffi%2Fsrc%2Fpowerpc%2Fdarwin_closure.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073ae293d97f76c66767fdce57f6f6e3ef58b612/libffi%2Fsrc%2Fpowerpc%2Fdarwin_closure.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fpowerpc%2Fdarwin_closure.S?ref=073ae293d97f76c66767fdce57f6f6e3ef58b612", "patch": "@@ -0,0 +1,189 @@\n+/* -----------------------------------------------------------------------\n+   darwin_closures.S - Copyright (c) 2002 Free Software Foundation, Inc.\n+   based on ppc_closures.S\n+ \n+   PowerPC Assembly glue.\n+\n+   Permission is hereby granted, free of charge, to any person obtaining\n+   a copy of this software and associated documentation files (the\n+   ``Software''), to deal in the Software without restriction, including\n+   without limitation the rights to use, copy, modify, merge, publish,\n+   distribute, sublicense, and/or sell copies of the Software, and to\n+   permit persons to whom the Software is furnished to do so, subject to\n+   the following conditions:\n+\n+   The above copyright notice and this permission notice shall be included\n+   in all copies or substantial portions of the Software.\n+\n+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND, EXPRESS\n+   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n+   IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY CLAIM, DAMAGES OR\n+   OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\n+   ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n+   OTHER DEALINGS IN THE SOFTWARE.\n+   ----------------------------------------------------------------------- */\n+\n+#define LIBFFI_ASM\n+#define JUMPTARGET(name) name\n+#define L(x) x\n+.text\n+.globl _ffi_closure_helper_DARWIN\n+\n+.text\n+\t.align 2\n+.globl _ffi_closure_ASM\n+\n+.text\n+\t.align 2\n+_ffi_closure_ASM:\n+\t\n+\tmflr r0\t\t\t/* extract return address */\n+\tstw r0, 8(r1)\t\t/* save the return address */\n+\t\n+\t/* 24 Bytes (Linkage Area) */\n+\t/* 32 Bytes (outgoing parameter area, always reserved) */\n+\t/* 104 Bytes (13*8 from FPR) */ \n+\t/* 4 Bytes (result)\n+\t/* 164 Bytes */\n+\t\n+\tstwu r1,-164(r1)\t/* skip over caller save area */\n+\t\n+/* we want to build up an area for the parameters passed */\n+/* in registers (both floating point and integer) */\n+\t\n+\t/* we store gpr 3 to gpr 10 (aligned to 4) */\n+\t/* in the parents outgoing area\t\t   */\n+\tstw   r3, 188(r1)\n+\tstw   r4, 192(r1)\n+\tstw   r5, 196(r1) \n+\tstw   r6, 200(r1)\n+\tstw   r7, 204(r1)\n+\tstw   r8, 208(r1) \n+\tstw   r9, 212(r1)\n+\tstw   r10, 216(r1)\n+\n+\t/* we save fpr 1 to fpr 13 (aligned to 8) */\n+\tstfd  f1, 56(r1)\n+\tstfd  f2, 64(r1)\n+\tstfd  f3, 72(r1)\n+\tstfd  f4, 80(r1)\n+\tstfd  f5, 88(r1)\n+\tstfd  f6, 96(r1)\n+\tstfd  f7, 104(r1)\n+\tstfd  f8, 112(r1)\n+\tstfd  f9, 120(r1) \n+\tstfd  f10, 128(r1) \n+\tstfd  f11, 136(r1) \n+\tstfd  f12, 144(r1) \n+\tstfd  f13, 152(r1) \n+\n+\t/* set up registers for the routine that actually does the work */\n+\t/* get the context pointer from the trampoline */\n+\tmr r3,r11\n+\t\n+\t/* now load up the pointer to the result storage */\n+\taddi r4,r1,160\n+\t\n+\t/* now load up the pointer to the saved gpr registers */\n+\taddi r5,r1,188\n+\n+\t/* now load up the pointer to the saved fpr registers */\n+\taddi r6,r1,56\n+\n+\t/* now load up the pointer to the outgoing parameter  */\n+\t/* stack in the previous frame */\n+\taddi r7,r1,220\n+\t\n+\t/* make the call */\n+\tbl L(_ffi_closure_helper_DARWIN)\n+\n+\t/* now r3 contains the return type */\n+\t/* so use it to look up in a table */\n+\t/* so we know how to deal with each type */\n+\n+\t/* look up the proper starting point in table  */\n+\t/* by using return type as offset */\n+\taddi r5,r1,160\t\t/* get pointer to results area */\n+\taddis r4,0,ha16(.L60)\t/* get address of jump table */\n+\taddi r4,r4,lo16(.L60)\n+\tslwi r3,r3,2\t\t/* now multiply return type by 4 */\n+\tlwzx r3,r4,r3\t\t/* get the contents of that table value */\n+\tadd r3,r3,r4\t\t/* add contents of table to table address */\n+\tmtctr r3\n+\tbctr\t\t\t/* jump to it */\n+\n+.L60:\n+\t.long .L44-.L60    /* FFI_TYPE_VOID */\n+\t.long .L50-.L60    /* FFI_TYPE_INT */\n+\t.long .L47-.L60    /* FFI_TYPE_FLOAT */\n+\t.long .L46-.L60    /* FFI_TYPE_DOUBLE */\n+\t.long .L46-.L60    /* FFI_TYPE_LONGDOUBLE */\n+\t.long .L56-.L60    /* FFI_TYPE_UINT8 */\n+\t.long .L55-.L60    /* FFI_TYPE_SINT8 */\n+\t.long .L58-.L60    /* FFI_TYPE_UINT16 */\n+\t.long .L57-.L60    /* FFI_TYPE_SINT16 */\n+\t.long .L50-.L60    /* FFI_TYPE_UINT32 */\n+\t.long .L50-.L60    /* FFI_TYPE_SINT32 */\n+\t.long .L48-.L60    /* FFI_TYPE_UINT64 */\n+\t.long .L48-.L60    /* FFI_TYPE_SINT64 */\n+\t.long .L44-.L60    /* FFI_TYPE_STRUCT */\n+\t.long .L50-.L60    /* FFI_TYPE_POINTER */\n+\n+\n+/* case double */\n+.L46:   \n+\tlfd f1,0(r5)\n+\tb .L44\n+\n+/* case float */\n+.L47:\n+\tlfs f1,0(r5)\n+\tb .L44\n+\t\n+/* case long long */\n+.L48:\n+\tlwz r3,0(r5)\n+\tlwz r4,4(r5)\n+\tb .L44\n+\t\n+/* case default / int32 / pointer */\n+.L50:\n+\tlwz r3,0(r5)\n+\tb .L44\n+\t\n+/* case signed int8\t */\n+.L55:\n+\taddi r5,r5,3\n+\tlbz r3,0(r5)\n+\textsb r3,r3\n+\tb .L44\n+\n+/* case unsigned int8\t */\n+.L56:\n+\taddi r5,r5,3\n+\tlbz r3,0(r5)\n+\tb .L44\n+\n+/* case signed int16 */\n+.L57:\n+\taddi r5,r5,2\n+\tlhz r3,0(r5)\n+\textsh r3,r3\n+\tb .L44\n+\n+/* case unsigned int16 */\n+.L58:\t\n+\taddi r5,r5,2\n+\tlhz r3,0(r5)\n+\n+/* case void / done\t */\n+.L44:\n+\t\n+\taddi r1,r1,164\t\t/* restore stack pointer */\n+\tlwz r0,8(r1)\t\t/* get return address */\n+\tmtlr r0\t\t\t/* reset link register */\n+\tblr\n+\t\n+/* END(ffi_closure_ASM) */\n+"}, {"sha": "d80f6bfc6f09a30a7bbbf50de68da7d2275a5588", "filename": "libffi/src/powerpc/ffi_darwin.c", "status": "modified", "additions": 328, "deletions": 1, "changes": 329, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073ae293d97f76c66767fdce57f6f6e3ef58b612/libffi%2Fsrc%2Fpowerpc%2Fffi_darwin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073ae293d97f76c66767fdce57f6f6e3ef58b612/libffi%2Fsrc%2Fpowerpc%2Fffi_darwin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fpowerpc%2Fffi_darwin.c?ref=073ae293d97f76c66767fdce57f6f6e3ef58b612", "patch": "@@ -6,7 +6,7 @@\n    Darwin ABI support (c) 2001 John Hornkvist\n    AIX ABI support (c) 2002 Free Software Foundation, Inc.\n \n-   $Id: ffi_darwin.c,v 1.2 2002/01/17 16:04:21 dje Exp $\n+   $Id: ffi_darwin.c,v 1.3 2002/02/21 19:14:28 dje Exp $\n \n    Permission is hereby granted, free of charge, to any person obtaining\n    a copy of this software and associated documentation files (the\n@@ -31,6 +31,8 @@\n #include <ffi_common.h>\n \n #include <stdlib.h>\n+   \n+extern void ffi_closure_ASM(void);\n \n enum {\n   /* The assembly depends on these exact flags.  */\n@@ -382,3 +384,328 @@ void ffi_call(/*@dependent@*/ ffi_cif *cif,\n       break;\n     }\n }\n+\n+static void flush_icache(char *);\n+static void flush_range(char *, int);\n+   \n+/* The layout of a function descriptor.  A C function pointer really    */\n+/* points to one of these.                                              */\n+\n+typedef struct aix_fd_struct {\n+    void *code_pointer;\n+    void *toc;\n+} aix_fd;\n+\n+/* here I'd like to add the stack frame layout we use in darwin_closure.S\n+ * and aix_clsoure.S\n+ *\n+/* SP previous -> +---------------------------------------+ <--- child frame\n+                  | back chain to caller 4                | \n+                  +---------------------------------------+ 4\n+                  | saved CR 4                            | \n+                  +---------------------------------------+ 8 \n+                  | saved LR 4                            | \n+                  +---------------------------------------+ 12\n+                  | reserved for compilers 4              | \n+                  +---------------------------------------+ 16\n+                  | reserved for binders 4                | \n+                  +---------------------------------------+ 20\n+                  | saved TOC pointer 4                   | \n+                  +---------------------------------------+ 24\n+                  | always reserved 8*4=32  (revious GPRs)| \n+                  | according to the linkage convention   |\n+                  | from AIX\t\t\t          |\n+                  +---------------------------------------+ 56\n+                  | our FPR area 13*8=104   \t\t  |\n+                  | f1\t\t\t\t   \t  |\n+                  | .\t       \t\t\t\t  |\n+                  | f13    \t        \t\t  | \n+                  +---------------------------------------+ 160\n+                  | result area 4                         | \n+SP current -->    +---------------------------------------+ 164 <- parent frame\n+                  | back chain to caller 4                | \n+                  +---------------------------------------+ 168\n+                  | saved CR 4                            | \n+                  +---------------------------------------+ 172\n+                  | saved LR 4                            | \n+                  +---------------------------------------+ 176\n+                  | reserved for compilers 4              | \n+                  +---------------------------------------+ 180\n+                  | reserved for binders 4                | \n+                  +---------------------------------------+ 184\n+                  | saved TOC pointer 4                   | \n+                  +---------------------------------------+ 188\n+                  | always reserved 8*4=32  we store our  |\n+                  | GPRs here\t        \t\t  |\n+                  | r3\t\t       \t\t\t  |\n+                  | .\t        \t\t\t  |\n+                  | r10      \t\t\t\t  |\n+                  +---------------------------------------+ 220\n+                  | PST area, overflow part\t          | \n+                  +---------------------------------------+ xxx\n+                  | ????\t\t\t\t  | \n+                  +---------------------------------------+ xxx\n+\n+*/\n+ffi_status\n+ffi_prep_closure (ffi_closure* closure,    \n+                  ffi_cif* cif,\n+                  void (*fun)(ffi_cif*, void*, void**, void*),\n+                  void *user_data)\n+{\n+  unsigned int *tramp;\n+  struct ffi_aix_trampoline_struct *tramp_aix;\n+ \n+  switch (cif->abi)\n+    {  \n+    case FFI_DARWIN:\n+\n+      FFI_ASSERT (cif->abi == FFI_DARWIN);\n+\n+      tramp = (unsigned int *) &closure->tramp[0];\n+      tramp[0] = 0x7c0802a6;  /*   mflr    r0 */\n+      tramp[1] = 0x4800000d;  /*   bl      10 <trampoline_initial+0x10> */\n+      tramp[4] = 0x7d6802a6;  /*   mflr    r11 */\n+      tramp[5] = 0x818b0000;  /*   lwz     r12,0(r11)  /* function address */\n+      tramp[6] = 0x7c0803a6;  /*   mtlr    r0  */\n+      tramp[7] = 0x7d8903a6;  /*   mtctr   r12 */\n+      tramp[8] = 0x816b0004;  /*   lwz     r11,4(r11)  /* static chain */\n+      tramp[9] = 0x4e800420;  /*   bctr */\n+      *(void **) &tramp[2] = (void *)ffi_closure_ASM; /* function */\n+      *(void **) &tramp[3] = (void *)closure;          /* context */\n+\n+      closure->cif = cif;\n+      closure->fun = fun;\n+      closure->user_data = user_data;\n+\n+      /* Flush the icache. Only necessary on Darwin  */\n+      flush_range(&closure->tramp[0],FFI_TRAMPOLINE_SIZE);\n+     \n+      break;\n+\n+    case FFI_AIX:\n+\n+      tramp_aix = (struct ffi_aix_trampoline_struct *) (closure->tramp);\n+      aix_fd *fd = (aix_fd *)(void *)ffi_closure_ASM;\n+\n+      FFI_ASSERT (cif->abi == FFI_AIX);\n+\n+      tramp_aix->code_pointer = fd->code_pointer;\n+      tramp_aix->toc = fd->toc;\n+      tramp_aix->static_chain = closure;\n+      closure->cif = cif;\n+      closure->fun = fun;\n+      closure->user_data = user_data;\n+\n+    default:\n+\n+      FFI_ASSERT(0);\n+      break;\n+    }\n+  return FFI_OK;\n+}\n+\n+static void\n+flush_icache(char *addr)\n+{\n+#ifndef _AIX\n+  __asm__ volatile (\n+                \"dcbf 0,%0;\"\n+                \"sync;\"\n+                \"icbi 0,%0;\"\n+                \"sync;\"\n+                \"isync;\"\n+                : : \"r\"(addr) : \"memory\");\n+#endif\n+}\n+\n+static void\n+flush_range(char * addr1, int size)\n+{\n+#define MIN_LINE_SIZE 32\n+  int i;\n+  for (i = 0; i < size; i += MIN_LINE_SIZE)\n+    flush_icache(addr1+i);\n+  flush_icache(addr1+size-1);\n+}\n+\n+int ffi_closure_helper_DARWIN (ffi_closure*, void*, unsigned long*,\n+                                     unsigned long*, unsigned long*);\n+\n+/* Basically the trampoline invokes ffi_closure_ASM, and on\n+ * entry, r11 holds the address of the closure.\n+ * After storing the registers that could possibly contain\n+ * parameters to be passed into the stack frame and setting\n+ * up space for a return value, ffi_closure_ASM invokes the\n+ * following helper function to do most of the work\n+ */\n+\n+int\n+ffi_closure_helper_DARWIN (ffi_closure* closure, void * rvalue,\n+            unsigned long * pgr, unsigned long * pfr,\n+            unsigned long * pst)\n+{\n+  /* rvalue is the pointer to space for return value in closure assembly */\n+  /* pgr is the pointer to where r3-r10 are stored in ffi_closure_ASM */\n+  /* pfr is the pointer to where f1-f13 are stored in ffi_closure_ASM */\n+  /* pst is the pointer to outgoing parameter stack in original caller */\n+\n+  void **          avalue;\n+  ffi_type **      arg_types;\n+  long             i, avn;\n+  long             nf;   /* number of floating registers already used */\n+  long             ng;   /* number of general registers already used */\n+  ffi_cif *        cif;\n+  double           temp;\n+\n+  cif = closure->cif;\n+  avalue = alloca(cif->nargs * sizeof(void *));\n+\n+  nf = 0;\n+  ng = 0;\n+\n+  /* Copy the caller's structure return value address so that the closure\n+     returns the data directly to the caller.  */\n+  if (cif->rtype->type == FFI_TYPE_STRUCT)\n+    {\n+      rvalue = (void *)pgr;\n+      ng++;      \n+      pgr++;\n+    }\n+\n+  i = 0;\n+  avn = cif->nargs;\n+  arg_types = cif->arg_types;\n+\n+  /* Grab the addresses of the arguments from the stack frame.  */\n+  while (i < avn)\n+    {\n+      switch (arg_types[i]->type)\n+        {\n+        case FFI_TYPE_SINT8:\n+        case FFI_TYPE_UINT8:\n+        /* there are 8 gpr registers used to pass values */\n+          if (ng < 8) {\n+             avalue[i] = (((char *)pgr)+3);\n+             ng++;\n+             pgr++;\n+          } else {\n+             avalue[i] = (((char *)pst)+3);\n+             pst++;\n+          }\n+          break;\n+\n+        case FFI_TYPE_SINT16:\n+        case FFI_TYPE_UINT16:\n+        /* there are 8 gpr registers used to pass values */\n+          if (ng < 8) {\n+             avalue[i] = (((char *)pgr)+2);\n+             ng++;\n+             pgr++;\n+          } else {\n+             avalue[i] = (((char *)pst)+2);\n+             pst++;\n+          }\n+          break;\n+\n+        case FFI_TYPE_SINT32:\n+        case FFI_TYPE_UINT32:\n+        case FFI_TYPE_POINTER:\n+        case FFI_TYPE_STRUCT:\n+        /* there are 8 gpr registers used to pass values */\n+          if (ng < 8) {  \n+             avalue[i] = pgr;\n+             ng++;\n+             pgr++;\n+          } else {\n+             avalue[i] = pst;\n+             pst++;\n+          }\n+          break;\n+\n+        case FFI_TYPE_SINT64:\n+        case FFI_TYPE_UINT64:\n+          /* long long ints are passed in two gpr's if available or in \n+           * the pst, one place is a bit odd, when a long long passes\n+\t   * the boundary between gpr and pst area we have to increment\n+\t   * the pst by one.\n+           */\n+           if (ng < 7) {\n+              avalue[i] = pgr;\n+              ng+=2;\n+              pgr+=2;\n+           } else if (ng == 7) {\n+              avalue[i] = pgr;\n+              ng++;\n+              pgr++;\n+              pst++;\n+           } else {\n+              avalue[i] = pst;\n+              pst+=2;\n+           }\n+           break;\n+\n+        case FFI_TYPE_FLOAT:\n+          /* a float value consumes a GPR\n+           *\n+           * there are 13 64bit floating point registers \n+\t   */\n+          \n+\t  if ((ng > 7) && (nf < 13)) {\n+\t     pst++;\n+\t  }\n+          if (nf < 13) {\n+\t     temp = *(double*)pfr;\n+             *(float*)pfr = (float)temp;\n+             avalue[i] = pfr;\n+             nf++;\n+             pfr+=2;\n+             ng++;\n+\t     pgr++;\n+\t         \n+          } else {\n+             avalue[i] = pst;\n+             nf++;\n+             pst++;\n+          }\n+          break;\n+\n+        case FFI_TYPE_DOUBLE:\n+\t  /* a double value consumes two GPRs\n+           *  \n+           * there are 13 64bit floating point registers \n+\t   */\n+\n+\t  if ((ng == 7) && (nf < 13)) {\n+             pst++;\t/* if only one gpr is left the double steals it */\n+\t  } else if ((ng > 7) && (nf < 13)) {\n+\t     pst+=2;\t/* a double consumes two GPRs in Darwin/AIX */\n+\t  }\n+          if (nf < 13) {\n+             avalue[i] = pfr;\n+             nf++;\n+             pfr+=2;\n+\t     ng+=2;\n+\t     pgr+=2;\n+\n+          } else {\n+             avalue[i] = pst;\n+             nf++;\n+             pst+=2;\n+          }\n+          break;\n+\n+        default:\n+          FFI_ASSERT(0);\n+       \n+        }\n+\n+      i++;\n+    }\n+\n+  (closure->fun) (cif, rvalue, avalue, closure->user_data);\n+\n+  /* Tell ffi_closure_ASM to perform return type promotions.  */\n+  return cif->rtype->type;\n+\n+}"}]}