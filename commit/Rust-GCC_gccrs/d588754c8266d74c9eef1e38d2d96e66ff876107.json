{"sha": "d588754c8266d74c9eef1e38d2d96e66ff876107", "node_id": "C_kwDOANBUbNoAKGQ1ODg3NTRjODI2NmQ3NGM5ZWVmMWUzOGQyZDk2ZTY2ZmY4NzYxMDc", "commit": {"author": {"name": "Joel Phillips", "email": "simplytheother@gmail.com", "date": "2022-10-21T12:35:54Z"}, "committer": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2022-12-13T13:00:04Z"}, "message": "gccrs: Add full definitions of Rust AST data structures\n\nThis adds the proper definitions of our AST nodes split across multiple\nfiles for clarity\n\n\tgcc/rust/\n\t* ast/rust-expr.h: New.\n\t* ast/rust-macro.h: New.\n\t* ast/rust-path.h: New.\n\t* ast/rust-pattern.h: New.\n\t* ast/rust-stmt.h: New.\n\t* ast/rust-type.h: New.\n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>\n\nSigned-off-by: Joel Phillips <simplytheother@gmail.com>", "tree": {"sha": "e7d900674320ed06c9211f7f7ab80c3f3189a626", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e7d900674320ed06c9211f7f7ab80c3f3189a626"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d588754c8266d74c9eef1e38d2d96e66ff876107", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d588754c8266d74c9eef1e38d2d96e66ff876107", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d588754c8266d74c9eef1e38d2d96e66ff876107", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d588754c8266d74c9eef1e38d2d96e66ff876107/comments", "author": {"login": "SimplyTheOther", "id": 19371469, "node_id": "MDQ6VXNlcjE5MzcxNDY5", "avatar_url": "https://avatars.githubusercontent.com/u/19371469?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimplyTheOther", "html_url": "https://github.com/SimplyTheOther", "followers_url": "https://api.github.com/users/SimplyTheOther/followers", "following_url": "https://api.github.com/users/SimplyTheOther/following{/other_user}", "gists_url": "https://api.github.com/users/SimplyTheOther/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimplyTheOther/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimplyTheOther/subscriptions", "organizations_url": "https://api.github.com/users/SimplyTheOther/orgs", "repos_url": "https://api.github.com/users/SimplyTheOther/repos", "events_url": "https://api.github.com/users/SimplyTheOther/events{/privacy}", "received_events_url": "https://api.github.com/users/SimplyTheOther/received_events", "type": "User", "site_admin": false}, "committer": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "438ae944fa60a3d6442822cf7b41d95c47714582", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/438ae944fa60a3d6442822cf7b41d95c47714582", "html_url": "https://github.com/Rust-GCC/gccrs/commit/438ae944fa60a3d6442822cf7b41d95c47714582"}], "stats": {"total": 9782, "additions": 9782, "deletions": 0}, "files": [{"sha": "1966a590c94a6a8790b3e0bb4446ce5fd0c8e398", "filename": "gcc/rust/ast/rust-expr.h", "status": "added", "additions": 4631, "deletions": 0, "changes": 4631, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d588754c8266d74c9eef1e38d2d96e66ff876107/gcc%2Frust%2Fast%2Frust-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d588754c8266d74c9eef1e38d2d96e66ff876107/gcc%2Frust%2Fast%2Frust-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-expr.h?ref=d588754c8266d74c9eef1e38d2d96e66ff876107"}, {"sha": "147037501ffd57942c970c62efd8bed1b4c5f626", "filename": "gcc/rust/ast/rust-macro.h", "status": "added", "additions": 958, "deletions": 0, "changes": 958, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d588754c8266d74c9eef1e38d2d96e66ff876107/gcc%2Frust%2Fast%2Frust-macro.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d588754c8266d74c9eef1e38d2d96e66ff876107/gcc%2Frust%2Fast%2Frust-macro.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-macro.h?ref=d588754c8266d74c9eef1e38d2d96e66ff876107", "patch": "@@ -0,0 +1,958 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_AST_MACRO_H\n+#define RUST_AST_MACRO_H\n+\n+#include \"rust-system.h\"\n+#include \"rust-ast.h\"\n+#include \"rust-location.h\"\n+\n+namespace Rust {\n+namespace AST {\n+\n+// Decls as definitions moved to rust-ast.h\n+class MacroItem;\n+\n+class MacroFragSpec\n+{\n+public:\n+  enum Kind\n+  {\n+    BLOCK,\n+    EXPR,\n+    IDENT,\n+    ITEM,\n+    LIFETIME,\n+    LITERAL,\n+    META,\n+    PAT,\n+    PATH,\n+    STMT,\n+    TT,\n+    TY,\n+    VIS,\n+    INVALID // not really a specifier, but used to mark invalid one passed in\n+  };\n+\n+  MacroFragSpec (Kind kind) : kind (kind) {}\n+\n+  static MacroFragSpec get_frag_spec_from_str (const std::string &str)\n+  {\n+    if (str == \"block\")\n+      return MacroFragSpec (BLOCK);\n+    else if (str == \"expr\")\n+      return MacroFragSpec (EXPR);\n+    else if (str == \"ident\")\n+      return MacroFragSpec (IDENT);\n+    else if (str == \"item\")\n+      return MacroFragSpec (ITEM);\n+    else if (str == \"lifetime\")\n+      return MacroFragSpec (LIFETIME);\n+    else if (str == \"literal\")\n+      return MacroFragSpec (LITERAL);\n+    else if (str == \"meta\")\n+      return MacroFragSpec (META);\n+    else if (str == \"pat\" || str == \"pat_param\")\n+      return MacroFragSpec (PAT);\n+    else if (str == \"path\")\n+      return MacroFragSpec (PATH);\n+    else if (str == \"stmt\")\n+      return MacroFragSpec (STMT);\n+    else if (str == \"tt\")\n+      return MacroFragSpec (TT);\n+    else if (str == \"ty\")\n+      return MacroFragSpec (TY);\n+    else if (str == \"vis\")\n+      return MacroFragSpec (VIS);\n+    else\n+      {\n+\t// error_at(\"invalid string '%s' used as fragment specifier\",\n+\t// str->c_str()));\n+\treturn MacroFragSpec (INVALID);\n+      }\n+  }\n+\n+  Kind get_kind () const { return kind; }\n+  bool is_error () const { return kind == Kind::INVALID; }\n+\n+  // Converts a frag spec enum item to a string form.\n+  std::string as_string () const\n+  {\n+    switch (kind)\n+      {\n+      case BLOCK:\n+\treturn \"block\";\n+      case EXPR:\n+\treturn \"expr\";\n+      case IDENT:\n+\treturn \"ident\";\n+      case ITEM:\n+\treturn \"item\";\n+      case LIFETIME:\n+\treturn \"lifetime\";\n+      case LITERAL:\n+\treturn \"literal\";\n+      case META:\n+\treturn \"meta\";\n+      case PAT:\n+\treturn \"pat\";\n+      case PATH:\n+\treturn \"path\";\n+      case STMT:\n+\treturn \"stmt\";\n+      case TT:\n+\treturn \"tt\";\n+      case TY:\n+\treturn \"ty\";\n+      case VIS:\n+\treturn \"vis\";\n+      case INVALID:\n+\treturn \"INVALID_FRAG_SPEC\";\n+      default:\n+\treturn \"ERROR_MARK_STRING - unknown frag spec\";\n+      }\n+  }\n+\n+  bool has_follow_set_restrictions () const\n+  {\n+    switch (kind)\n+      {\n+      case EXPR:\n+      case STMT:\n+      case PAT:\n+      case PATH:\n+      case TY:\n+      case VIS:\n+\treturn true;\n+      default:\n+\treturn false;\n+      }\n+  }\n+\n+  bool has_follow_set_fragment_restrictions () const\n+  {\n+    switch (kind)\n+      {\n+      case PAT:\n+      case TY:\n+      case VIS:\n+\treturn true;\n+      default:\n+\treturn false;\n+      }\n+  }\n+\n+private:\n+  Kind kind;\n+};\n+\n+// A macro match that has an identifier and fragment spec\n+class MacroMatchFragment : public MacroMatch\n+{\n+  Identifier ident;\n+  MacroFragSpec frag_spec;\n+  Location locus;\n+\n+public:\n+  MacroMatchFragment (Identifier ident, MacroFragSpec frag_spec, Location locus)\n+    : ident (std::move (ident)), frag_spec (frag_spec), locus (locus)\n+  {}\n+\n+  // Returns whether macro match fragment is in an error state.\n+  bool is_error () const\n+  {\n+    return frag_spec.get_kind () == MacroFragSpec::INVALID;\n+  }\n+\n+  // Creates an error state macro match fragment.\n+  static MacroMatchFragment create_error (Location locus)\n+  {\n+    return MacroMatchFragment (std::string (\"\"),\n+\t\t\t       MacroFragSpec (MacroFragSpec::Kind::INVALID),\n+\t\t\t       locus);\n+  }\n+\n+  std::string as_string () const override;\n+  Location get_match_locus () const override { return locus; };\n+\n+  void accept_vis (ASTVisitor &vis) override;\n+\n+  MacroMatchType get_macro_match_type () const override\n+  {\n+    return MacroMatchType::Fragment;\n+  }\n+\n+  Identifier get_ident () const { return ident; }\n+  const MacroFragSpec &get_frag_spec () const { return frag_spec; }\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  MacroMatchFragment *clone_macro_match_impl () const override\n+  {\n+    return new MacroMatchFragment (*this);\n+  }\n+};\n+\n+// A repetition macro match\n+class MacroMatchRepetition : public MacroMatch\n+{\n+public:\n+  enum MacroRepOp\n+  {\n+    NONE,\n+    ANY,\n+    ONE_OR_MORE,\n+    ZERO_OR_ONE,\n+  };\n+\n+private:\n+  std::vector<std::unique_ptr<MacroMatch> > matches;\n+  MacroRepOp op;\n+\n+  // bool has_sep;\n+  typedef Token MacroRepSep;\n+  // any token except delimiters and repetition operators\n+  std::unique_ptr<MacroRepSep> sep;\n+  Location locus;\n+\n+public:\n+  // Returns whether macro match repetition has separator token.\n+  bool has_sep () const { return sep != nullptr; }\n+\n+  MacroMatchRepetition (std::vector<std::unique_ptr<MacroMatch> > matches,\n+\t\t\tMacroRepOp op, std::unique_ptr<MacroRepSep> sep,\n+\t\t\tLocation locus)\n+    : matches (std::move (matches)), op (op), sep (std::move (sep)),\n+      locus (locus)\n+  {}\n+\n+  // Copy constructor with clone\n+  MacroMatchRepetition (MacroMatchRepetition const &other)\n+    : op (other.op), locus (other.locus)\n+  {\n+    // guard to protect from null pointer dereference\n+    if (other.sep != nullptr)\n+      sep = other.sep->clone_token ();\n+\n+    matches.reserve (other.matches.size ());\n+    for (const auto &e : other.matches)\n+      matches.push_back (e->clone_macro_match ());\n+  }\n+\n+  // Overloaded assignment operator to clone\n+  MacroMatchRepetition &operator= (MacroMatchRepetition const &other)\n+  {\n+    op = other.op;\n+    locus = other.locus;\n+\n+    // guard to protect from null pointer dereference\n+    if (other.sep != nullptr)\n+      sep = other.sep->clone_token ();\n+    else\n+      sep = nullptr;\n+\n+    matches.reserve (other.matches.size ());\n+    for (const auto &e : other.matches)\n+      matches.push_back (e->clone_macro_match ());\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  MacroMatchRepetition (MacroMatchRepetition &&other) = default;\n+  MacroMatchRepetition &operator= (MacroMatchRepetition &&other) = default;\n+\n+  std::string as_string () const override;\n+  Location get_match_locus () const override { return locus; };\n+\n+  void accept_vis (ASTVisitor &vis) override;\n+\n+  MacroMatchType get_macro_match_type () const override\n+  {\n+    return MacroMatchType::Repetition;\n+  }\n+\n+  MacroRepOp get_op () const { return op; }\n+  const std::unique_ptr<MacroRepSep> &get_sep () const { return sep; }\n+  std::vector<std::unique_ptr<MacroMatch> > &get_matches () { return matches; }\n+  const std::vector<std::unique_ptr<MacroMatch> > &get_matches () const\n+  {\n+    return matches;\n+  }\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  MacroMatchRepetition *clone_macro_match_impl () const override\n+  {\n+    return new MacroMatchRepetition (*this);\n+  }\n+};\n+\n+// can't inline due to polymorphism\n+class MacroMatcher : public MacroMatch\n+{\n+  DelimType delim_type;\n+  std::vector<std::unique_ptr<MacroMatch> > matches;\n+  Location locus;\n+\n+  // TODO: think of way to mark invalid that doesn't take up more space\n+  bool is_invalid;\n+\n+public:\n+  MacroMatcher (DelimType delim_type,\n+\t\tstd::vector<std::unique_ptr<MacroMatch> > matches,\n+\t\tLocation locus)\n+    : delim_type (delim_type), matches (std::move (matches)), locus (locus),\n+      is_invalid (false)\n+  {}\n+\n+  // copy constructor with vector clone\n+  MacroMatcher (MacroMatcher const &other)\n+    : delim_type (other.delim_type), locus (other.locus)\n+  {\n+    matches.reserve (other.matches.size ());\n+    for (const auto &e : other.matches)\n+      matches.push_back (e->clone_macro_match ());\n+  }\n+\n+  // overloaded assignment operator with vector clone\n+  MacroMatcher &operator= (MacroMatcher const &other)\n+  {\n+    delim_type = other.delim_type;\n+    locus = other.locus;\n+\n+    matches.reserve (other.matches.size ());\n+    for (const auto &e : other.matches)\n+      matches.push_back (e->clone_macro_match ());\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  MacroMatcher (MacroMatcher &&other) = default;\n+  MacroMatcher &operator= (MacroMatcher &&other) = default;\n+\n+  // Creates an error state macro matcher.\n+  static MacroMatcher create_error (Location locus)\n+  {\n+    return MacroMatcher (true, locus);\n+  }\n+\n+  // Returns whether MacroMatcher is in an error state.\n+  bool is_error () const { return is_invalid; }\n+  Location get_match_locus () const override { return locus; }\n+\n+  std::string as_string () const override;\n+\n+  void accept_vis (ASTVisitor &vis) override;\n+\n+  MacroMatchType get_macro_match_type () const override\n+  {\n+    return MacroMatchType::Matcher;\n+  }\n+\n+  DelimType get_delim_type () const { return delim_type; }\n+  std::vector<std::unique_ptr<MacroMatch> > &get_matches () { return matches; }\n+  const std::vector<std::unique_ptr<MacroMatch> > &get_matches () const\n+  {\n+    return matches;\n+  }\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  MacroMatcher *clone_macro_match_impl () const override\n+  {\n+    return new MacroMatcher (*this);\n+  }\n+\n+  // constructor only used to create error matcher\n+  MacroMatcher (bool is_invalid, Location locus)\n+    : delim_type (PARENS), locus (locus), is_invalid (is_invalid)\n+  {}\n+};\n+\n+// TODO: inline?\n+struct MacroTranscriber\n+{\n+private:\n+  DelimTokenTree token_tree;\n+  Location locus;\n+\n+public:\n+  MacroTranscriber (DelimTokenTree token_tree, Location locus)\n+    : token_tree (std::move (token_tree)), locus (locus)\n+  {}\n+\n+  std::string as_string () const { return token_tree.as_string (); }\n+\n+  Location get_locus () const { return locus; }\n+\n+  DelimTokenTree &get_token_tree () { return token_tree; }\n+};\n+\n+// A macro rule? Matcher and transcriber pair?\n+struct MacroRule\n+{\n+private:\n+  MacroMatcher matcher;\n+  MacroTranscriber transcriber;\n+  Location locus;\n+\n+public:\n+  MacroRule (MacroMatcher matcher, MacroTranscriber transcriber, Location locus)\n+    : matcher (std::move (matcher)), transcriber (std::move (transcriber)),\n+      locus (locus)\n+  {}\n+\n+  // Returns whether macro rule is in error state.\n+  bool is_error () const { return matcher.is_error (); }\n+\n+  // Creates an error state macro rule.\n+  static MacroRule create_error (Location locus)\n+  {\n+    return MacroRule (MacroMatcher::create_error (locus),\n+\t\t      MacroTranscriber (DelimTokenTree::create_empty (),\n+\t\t\t\t\tLocation ()),\n+\t\t      locus);\n+  }\n+\n+  Location get_locus () const { return locus; }\n+\n+  std::string as_string () const;\n+\n+  MacroMatcher &get_matcher () { return matcher; }\n+  MacroTranscriber &get_transcriber () { return transcriber; }\n+};\n+\n+// A macro rules definition item AST node\n+class MacroRulesDefinition : public MacroItem\n+{\n+  std::vector<Attribute> outer_attrs;\n+  Identifier rule_name;\n+  // MacroRulesDef rules_def;\n+  // only curly without required semicolon at end\n+  DelimType delim_type;\n+  // MacroRules rules;\n+  std::vector<MacroRule> rules; // inlined form\n+  Location locus;\n+\n+  std::function<ASTFragment (Location, MacroInvocData &)>\n+    associated_transcriber;\n+  // Since we can't compare std::functions, we need to use an extra boolean\n+  bool is_builtin_rule;\n+\n+  /**\n+   * Default function to use as an associated transcriber. This function should\n+   * never be called, hence the gcc_unreachable().\n+   * If this function is used, then the macro is not builtin and the compiler\n+   * should make use of the actual rules. If the macro is builtin, then another\n+   * associated transcriber should be used\n+   */\n+  static ASTFragment dummy_builtin (Location, MacroInvocData &)\n+  {\n+    gcc_unreachable ();\n+    return ASTFragment::create_error ();\n+  }\n+\n+  /* NOTE: in rustc, macro definitions are considered (and parsed as) a type\n+   * of macro, whereas here they are considered part of the language itself.\n+   * I am not aware of the implications of this decision. The rustc spec does\n+   * mention that using the same parser for macro definitions and invocations\n+   * is \"extremely self-referential and non-intuitive\". */\n+\n+public:\n+  std::string as_string () const override;\n+\n+  MacroRulesDefinition (Identifier rule_name, DelimType delim_type,\n+\t\t\tstd::vector<MacroRule> rules,\n+\t\t\tstd::vector<Attribute> outer_attrs, Location locus)\n+    : outer_attrs (std::move (outer_attrs)), rule_name (std::move (rule_name)),\n+      delim_type (delim_type), rules (std::move (rules)), locus (locus),\n+      associated_transcriber (dummy_builtin), is_builtin_rule (false)\n+  {}\n+\n+  MacroRulesDefinition (Identifier builtin_name, DelimType delim_type,\n+\t\t\tstd::function<ASTFragment (Location, MacroInvocData &)>\n+\t\t\t  associated_transcriber)\n+    : outer_attrs (std::vector<Attribute> ()), rule_name (builtin_name),\n+      delim_type (delim_type), rules (std::vector<MacroRule> ()),\n+      locus (Location ()), associated_transcriber (associated_transcriber),\n+      is_builtin_rule (true)\n+  {}\n+\n+  void accept_vis (ASTVisitor &vis) override;\n+\n+  // Invalid if rule name is empty, so base stripping on that.\n+  void mark_for_strip () override { rule_name = \"\"; }\n+  bool is_marked_for_strip () const override { return rule_name.empty (); }\n+\n+  // TODO: this mutable getter seems really dodgy. Think up better way.\n+  std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n+  const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n+\n+  std::vector<MacroRule> &get_macro_rules () { return rules; }\n+  const std::vector<MacroRule> &get_macro_rules () const { return rules; }\n+\n+  Location get_locus () const override final { return locus; }\n+\n+  Identifier get_rule_name () const { return rule_name; }\n+\n+  std::vector<MacroRule> &get_rules () { return rules; }\n+  const std::vector<MacroRule> &get_rules () const { return rules; }\n+\n+  bool is_builtin () const { return is_builtin_rule; }\n+  const std::function<ASTFragment (Location, MacroInvocData &)> &\n+  get_builtin_transcriber () const\n+  {\n+    rust_assert (is_builtin ());\n+    return associated_transcriber;\n+  }\n+  void set_builtin_transcriber (\n+    std::function<ASTFragment (Location, MacroInvocData &)> transcriber)\n+  {\n+    associated_transcriber = transcriber;\n+    is_builtin_rule = true;\n+  }\n+\n+  Kind get_ast_kind () const override { return Kind::MACRO_RULES_DEFINITION; }\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  MacroRulesDefinition *clone_item_impl () const override\n+  {\n+    return new MacroRulesDefinition (*this);\n+  }\n+};\n+\n+/* AST node of a macro invocation, which is replaced by the macro result at\n+ * compile time */\n+class MacroInvocation : public TypeNoBounds,\n+\t\t\tpublic Pattern,\n+\t\t\tpublic MacroItem,\n+\t\t\tpublic TraitItem,\n+\t\t\tpublic TraitImplItem,\n+\t\t\tpublic InherentImplItem,\n+\t\t\tpublic ExternalItem,\n+\t\t\tpublic ExprWithoutBlock\n+{\n+  std::vector<Attribute> outer_attrs;\n+  MacroInvocData invoc_data;\n+  Location locus;\n+\n+  // Important for when we actually expand the macro\n+  bool is_semi_coloned;\n+\n+  NodeId node_id;\n+\n+public:\n+  std::string as_string () const override;\n+\n+  MacroInvocation (MacroInvocData invoc_data,\n+\t\t   std::vector<Attribute> outer_attrs, Location locus,\n+\t\t   bool is_semi_coloned = false)\n+    : outer_attrs (std::move (outer_attrs)),\n+      invoc_data (std::move (invoc_data)), locus (locus),\n+      is_semi_coloned (is_semi_coloned),\n+      node_id (Analysis::Mappings::get ()->get_next_node_id ())\n+  {}\n+\n+  Location get_locus () const override final { return locus; }\n+\n+  void accept_vis (ASTVisitor &vis) override;\n+\n+  // Invalid if path is empty, so base stripping on that.\n+  void mark_for_strip () override { invoc_data.mark_for_strip (); }\n+  bool is_marked_for_strip () const override\n+  {\n+    return invoc_data.is_marked_for_strip ();\n+  }\n+\n+  const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n+  std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n+\n+  void set_outer_attrs (std::vector<Attribute> new_attrs) override\n+  {\n+    outer_attrs = std::move (new_attrs);\n+  }\n+\n+  NodeId get_pattern_node_id () const override final\n+  {\n+    return ExprWithoutBlock::get_node_id ();\n+  }\n+\n+  Kind get_ast_kind () const override { return Kind::MACRO_INVOCATION; }\n+\n+  NodeId get_macro_node_id () const { return node_id; }\n+\n+  MacroInvocData &get_invoc_data () { return invoc_data; }\n+\n+  bool has_semicolon () const { return is_semi_coloned; }\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  MacroInvocation *clone_pattern_impl () const final override\n+  {\n+    return clone_macro_invocation_impl ();\n+  }\n+\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  MacroInvocation *clone_expr_without_block_impl () const final override\n+  {\n+    return clone_macro_invocation_impl ();\n+  }\n+\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  MacroInvocation *clone_type_no_bounds_impl () const final override\n+  {\n+    return clone_macro_invocation_impl ();\n+  }\n+\n+  MacroInvocation *clone_external_item_impl () const final override\n+  {\n+    return clone_macro_invocation_impl ();\n+  }\n+\n+  /*virtual*/ MacroInvocation *clone_macro_invocation_impl () const\n+  {\n+    return new MacroInvocation (*this);\n+  }\n+\n+  Item *clone_item_impl () const override\n+  {\n+    return clone_macro_invocation_impl ();\n+  }\n+\n+  bool is_item () const override { return !has_semicolon (); }\n+\n+  TraitItem *clone_trait_item_impl () const override\n+  {\n+    return clone_macro_invocation_impl ();\n+  };\n+\n+  TraitImplItem *clone_trait_impl_item_impl () const override\n+  {\n+    return clone_macro_invocation_impl ();\n+  };\n+\n+  InherentImplItem *clone_inherent_impl_item_impl () const override\n+  {\n+    return clone_macro_invocation_impl ();\n+  }\n+\n+  ExprWithoutBlock *to_stmt () const override\n+\n+  {\n+    auto new_impl = clone_macro_invocation_impl ();\n+    new_impl->is_semi_coloned = true;\n+\n+    return new_impl;\n+  }\n+};\n+\n+// more generic meta item path-only form\n+class MetaItemPath : public MetaItem\n+{\n+  SimplePath path;\n+\n+public:\n+  MetaItemPath (SimplePath path) : path (std::move (path)) {}\n+\n+  std::string as_string () const override { return path.as_string (); }\n+\n+  void accept_vis (ASTVisitor &vis) override;\n+\n+  // HACK: used to simplify parsing - returns non-empty only in this case\n+  SimplePath to_path_item () const override\n+  {\n+    // this should copy construct - TODO ensure it does\n+    return path;\n+  }\n+\n+  bool check_cfg_predicate (const Session &session) const override;\n+\n+  Attribute to_attribute () const override;\n+\n+protected:\n+  // Use covariance to implement clone function as returning this type\n+  MetaItemPath *clone_meta_item_inner_impl () const override\n+  {\n+    return new MetaItemPath (*this);\n+  }\n+};\n+\n+// more generic meta item sequence form\n+class MetaItemSeq : public MetaItem\n+{\n+  SimplePath path;\n+  std::vector<std::unique_ptr<MetaItemInner> > seq;\n+\n+public:\n+  MetaItemSeq (SimplePath path,\n+\t       std::vector<std::unique_ptr<MetaItemInner> > seq)\n+    : path (std::move (path)), seq (std::move (seq))\n+  {}\n+\n+  // copy constructor with vector clone\n+  MetaItemSeq (const MetaItemSeq &other) : path (other.path)\n+  {\n+    seq.reserve (other.seq.size ());\n+    for (const auto &e : other.seq)\n+      seq.push_back (e->clone_meta_item_inner ());\n+  }\n+\n+  // overloaded assignment operator with vector clone\n+  MetaItemSeq &operator= (const MetaItemSeq &other)\n+  {\n+    MetaItem::operator= (other);\n+    path = other.path;\n+\n+    seq.reserve (other.seq.size ());\n+    for (const auto &e : other.seq)\n+      seq.push_back (e->clone_meta_item_inner ());\n+\n+    return *this;\n+  }\n+\n+  // default move constructors\n+  MetaItemSeq (MetaItemSeq &&other) = default;\n+  MetaItemSeq &operator= (MetaItemSeq &&other) = default;\n+\n+  std::string as_string () const override;\n+\n+  void accept_vis (ASTVisitor &vis) override;\n+\n+  bool check_cfg_predicate (const Session &session) const override;\n+\n+  Attribute to_attribute () const override;\n+\n+protected:\n+  // Use covariance to implement clone function as returning this type\n+  MetaItemSeq *clone_meta_item_inner_impl () const override\n+  {\n+    return new MetaItemSeq (*this);\n+  }\n+};\n+\n+// Preferred specialisation for single-identifier meta items.\n+class MetaWord : public MetaItem\n+{\n+  Identifier ident;\n+  Location ident_locus;\n+\n+public:\n+  MetaWord (Identifier ident, Location ident_locus)\n+    : ident (std::move (ident)), ident_locus (ident_locus)\n+  {}\n+\n+  std::string as_string () const override { return ident; }\n+\n+  void accept_vis (ASTVisitor &vis) override;\n+\n+  bool check_cfg_predicate (const Session &session) const override;\n+\n+  Attribute to_attribute () const override;\n+\n+protected:\n+  // Use covariance to implement clone function as returning this type\n+  MetaWord *clone_meta_item_inner_impl () const override\n+  {\n+    return new MetaWord (*this);\n+  }\n+};\n+\n+// Preferred specialisation for \"identifier '=' string literal\" meta items.\n+class MetaNameValueStr : public MetaItem\n+{\n+  Identifier ident;\n+  Location ident_locus;\n+\n+  // NOTE: str stored without quotes\n+  std::string str;\n+  Location str_locus;\n+\n+public:\n+  MetaNameValueStr (Identifier ident, Location ident_locus, std::string str,\n+\t\t    Location str_locus)\n+    : ident (std::move (ident)), ident_locus (ident_locus),\n+      str (std::move (str)), str_locus (str_locus)\n+  {}\n+\n+  std::string as_string () const override\n+  {\n+    return ident + \" = \\\"\" + str + \"\\\"\";\n+  }\n+\n+  void accept_vis (ASTVisitor &vis) override;\n+\n+  // HACK: used to simplify parsing - creates a copy of this\n+  std::unique_ptr<MetaNameValueStr> to_meta_name_value_str () const override\n+  {\n+    return std::unique_ptr<MetaNameValueStr> (clone_meta_item_inner_impl ());\n+  }\n+\n+  bool check_cfg_predicate (const Session &session) const override;\n+\n+  Attribute to_attribute () const override;\n+\n+  inline std::pair<Identifier, std::string> get_name_value_pair () const\n+  {\n+    return std::pair<Identifier, std::string> (ident, str);\n+  }\n+\n+  bool is_key_value_pair () const override { return true; }\n+\n+protected:\n+  // Use covariance to implement clone function as returning this type\n+  MetaNameValueStr *clone_meta_item_inner_impl () const override\n+  {\n+    return new MetaNameValueStr (*this);\n+  }\n+};\n+\n+// doubles up as MetaListIdents - determine via iterating through each path?\n+// Preferred specialisation for \"identifier '(' SimplePath, SimplePath, ... ')'\"\n+class MetaListPaths : public MetaItem\n+{\n+  Identifier ident;\n+  Location ident_locus;\n+  std::vector<SimplePath> paths;\n+\n+public:\n+  MetaListPaths (Identifier ident, Location ident_locus,\n+\t\t std::vector<SimplePath> paths)\n+    : ident (std::move (ident)), ident_locus (ident_locus),\n+      paths (std::move (paths))\n+  {}\n+\n+  std::string as_string () const override;\n+\n+  void accept_vis (ASTVisitor &vis) override;\n+\n+  bool check_cfg_predicate (const Session &session) const override;\n+\n+  Attribute to_attribute () const override;\n+\n+private:\n+  bool check_path_exists_in_cfg (const Session &session,\n+\t\t\t\t const SimplePath &path) const;\n+\n+protected:\n+  // Use covariance to implement clone function as returning this type\n+  MetaListPaths *clone_meta_item_inner_impl () const override\n+  {\n+    return new MetaListPaths (*this);\n+  }\n+};\n+\n+// Preferred specialisation for \"identifier '(' MetaNameValueStr, ... ')'\"\n+class MetaListNameValueStr : public MetaItem\n+{\n+  Identifier ident;\n+  Location ident_locus;\n+  std::vector<MetaNameValueStr> strs;\n+\n+public:\n+  MetaListNameValueStr (Identifier ident, Location ident_locus,\n+\t\t\tstd::vector<MetaNameValueStr> strs)\n+    : ident (std::move (ident)), ident_locus (ident_locus),\n+      strs (std::move (strs))\n+  {}\n+\n+  std::string as_string () const override;\n+\n+  void accept_vis (ASTVisitor &vis) override;\n+\n+  bool check_cfg_predicate (const Session &session) const override;\n+\n+  Attribute to_attribute () const override;\n+\n+protected:\n+  // Use covariance to implement clone function as returning this type\n+  MetaListNameValueStr *clone_meta_item_inner_impl () const override\n+  {\n+    return new MetaListNameValueStr (*this);\n+  }\n+};\n+\n+// Object that parses macros from a token stream.\n+/* TODO: would \"AttributeParser\" be a better name? MetaItems are only for\n+ * attributes, I believe */\n+struct AttributeParser\n+{\n+private:\n+  // TODO: might as well rewrite to use lexer tokens\n+  std::vector<std::unique_ptr<Token> > token_stream;\n+  int stream_pos;\n+\n+public:\n+  AttributeParser (std::vector<std::unique_ptr<Token> > token_stream,\n+\t\t   int stream_start_pos = 0)\n+    : token_stream (std::move (token_stream)), stream_pos (stream_start_pos)\n+  {}\n+\n+  ~AttributeParser () = default;\n+\n+  std::vector<std::unique_ptr<MetaItemInner> > parse_meta_item_seq ();\n+\n+private:\n+  // Parses a MetaItemInner.\n+  std::unique_ptr<MetaItemInner> parse_meta_item_inner ();\n+  // Returns whether token can end a meta item.\n+  bool is_end_meta_item_tok (TokenId id) const;\n+  // Parses a simple path.\n+  SimplePath parse_simple_path ();\n+  // Parses a segment of a simple path (but not scope resolution operator).\n+  SimplePathSegment parse_simple_path_segment ();\n+  // Parses a MetaItemLitExpr.\n+  std::unique_ptr<MetaItemLitExpr> parse_meta_item_lit ();\n+  // Parses a literal.\n+  Literal parse_literal ();\n+  // Parses a meta item that begins with a simple path.\n+  std::unique_ptr<MetaItem> parse_path_meta_item ();\n+\n+  // TODO: should this be const?\n+  std::unique_ptr<Token> &peek_token (int i = 0)\n+  {\n+    return token_stream[stream_pos + i];\n+  }\n+\n+  void skip_token (int i = 0) { stream_pos += 1 + i; }\n+};\n+} // namespace AST\n+} // namespace Rust\n+\n+/* <https://stackoverflow.com/a/35304501> */\n+namespace std {\n+template <> struct hash<Rust::AST::MacroFragSpec::Kind>\n+{\n+  size_t operator() (const Rust::AST::MacroFragSpec::Kind &t) const noexcept\n+  {\n+    return size_t (t);\n+  }\n+};\n+} // namespace std\n+\n+#endif"}, {"sha": "cc79e278f055bfe06512ac0ee362b2794295bd03", "filename": "gcc/rust/ast/rust-path.h", "status": "added", "additions": 1297, "deletions": 0, "changes": 1297, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d588754c8266d74c9eef1e38d2d96e66ff876107/gcc%2Frust%2Fast%2Frust-path.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d588754c8266d74c9eef1e38d2d96e66ff876107/gcc%2Frust%2Fast%2Frust-path.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-path.h?ref=d588754c8266d74c9eef1e38d2d96e66ff876107", "patch": "@@ -0,0 +1,1297 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_AST_PATH_H\n+#define RUST_AST_PATH_H\n+/* \"Path\" (identifier within namespaces, essentially) handling. Required include\n+ * for virtually all AST-related functionality. */\n+\n+#include \"rust-ast.h\"\n+#include \"system.h\"\n+\n+namespace Rust {\n+namespace AST {\n+\n+// The \"identifier\" (not generic args) aspect of each path expression segment\n+class PathIdentSegment\n+{\n+  std::string segment_name;\n+  Location locus;\n+\n+  // only allow identifiers, \"super\", \"self\", \"Self\", \"crate\", or \"$crate\"\n+public:\n+  PathIdentSegment (std::string segment_name, Location locus)\n+    : segment_name (std::move (segment_name)), locus (locus)\n+  {}\n+\n+  // Creates an error PathIdentSegment.\n+  static PathIdentSegment create_error ()\n+  {\n+    return PathIdentSegment (\"\", Location ());\n+  }\n+\n+  // Returns whether PathIdentSegment is in an error state.\n+  bool is_error () const { return segment_name.empty (); }\n+\n+  std::string as_string () const { return segment_name; }\n+\n+  Location get_locus () const { return locus; }\n+\n+  bool is_super_segment () const { return as_string ().compare (\"super\") == 0; }\n+  bool is_crate_segment () const { return as_string ().compare (\"crate\") == 0; }\n+  bool is_lower_self () const { return as_string ().compare (\"self\") == 0; }\n+  bool is_big_self () const { return as_string ().compare (\"Self\") == 0; }\n+};\n+\n+// A binding of an identifier to a type used in generic arguments in paths\n+struct GenericArgsBinding\n+{\n+private:\n+  Identifier identifier;\n+  std::unique_ptr<Type> type;\n+  Location locus;\n+\n+public:\n+  // Returns whether binding is in an error state.\n+  bool is_error () const\n+  {\n+    return type == nullptr;\n+    // and also identifier is empty, but cheaper computation\n+  }\n+\n+  // Creates an error state generic args binding.\n+  static GenericArgsBinding create_error ()\n+  {\n+    return GenericArgsBinding (\"\", nullptr);\n+  }\n+\n+  // Pointer type for type in constructor to enable polymorphism\n+  GenericArgsBinding (Identifier ident, std::unique_ptr<Type> type_ptr,\n+\t\t      Location locus = Location ())\n+    : identifier (std::move (ident)), type (std::move (type_ptr)), locus (locus)\n+  {}\n+\n+  // Copy constructor has to deep copy the type as it is a unique pointer\n+  GenericArgsBinding (GenericArgsBinding const &other)\n+    : identifier (other.identifier), locus (other.locus)\n+  {\n+    // guard to protect from null pointer dereference\n+    if (other.type != nullptr)\n+      type = other.type->clone_type ();\n+  }\n+\n+  // default destructor\n+  ~GenericArgsBinding () = default;\n+\n+  // Overload assignment operator to deep copy the pointed-to type\n+  GenericArgsBinding &operator= (GenericArgsBinding const &other)\n+  {\n+    identifier = other.identifier;\n+    locus = other.locus;\n+\n+    // guard to protect from null pointer dereference\n+    if (other.type != nullptr)\n+      type = other.type->clone_type ();\n+    else\n+      type = nullptr;\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  GenericArgsBinding (GenericArgsBinding &&other) = default;\n+  GenericArgsBinding &operator= (GenericArgsBinding &&other) = default;\n+\n+  std::string as_string () const;\n+\n+  // TODO: is this better? Or is a \"vis_pattern\" better?\n+  std::unique_ptr<Type> &get_type ()\n+  {\n+    rust_assert (type != nullptr);\n+    return type;\n+  }\n+\n+  Location get_locus () const { return locus; }\n+\n+  Identifier get_identifier () const { return identifier; }\n+};\n+\n+/* Class representing a const generic application */\n+class GenericArg\n+{\n+public:\n+  /**\n+   * const generic arguments cannot always be differentiated with generic type\n+   * arguments during parsing, e.g:\n+   * ```rust\n+   * let a: Foo<N>;\n+   * ```\n+   *\n+   * Is N a type? A constant defined elsewhere? The parser cannot know, and must\n+   * not draw any conclusions. We must wait until later passes of the compiler\n+   * to decide whether this refers to a constant item or a type.\n+   *\n+   * On the other hand, simple expressions like literals or block expressions\n+   * will always be constant expressions: There is no ambiguity at all.\n+   */\n+  enum class Kind\n+  {\n+    Error,\n+    Const,  // A const value\n+    Type,   // A type argument (not discernable during parsing)\n+    Either, // Either a type or a const value, cleared up during resolving\n+  };\n+\n+  static GenericArg create_error ()\n+  {\n+    return GenericArg (nullptr, nullptr, \"\", Kind::Error, Location ());\n+  }\n+\n+  static GenericArg create_const (std::unique_ptr<Expr> expression)\n+  {\n+    auto locus = expression->get_locus ();\n+    return GenericArg (std::move (expression), nullptr, \"\", Kind::Const, locus);\n+  }\n+\n+  static GenericArg create_type (std::unique_ptr<Type> type)\n+  {\n+    auto locus = type->get_locus ();\n+    return GenericArg (nullptr, std::move (type), \"\", Kind::Type, locus);\n+  }\n+\n+  static GenericArg create_ambiguous (Identifier path, Location locus)\n+  {\n+    return GenericArg (nullptr, nullptr, std::move (path), Kind::Either, locus);\n+  }\n+\n+  GenericArg (const GenericArg &other)\n+    : path (other.path), kind (other.kind), locus (other.locus)\n+  {\n+    if (other.expression)\n+      expression = other.expression->clone_expr ();\n+    if (other.type)\n+      type = other.type->clone_type ();\n+  }\n+\n+  GenericArg operator= (const GenericArg &other)\n+  {\n+    kind = other.kind;\n+    path = other.path;\n+    locus = other.locus;\n+\n+    if (other.expression)\n+      expression = other.expression->clone_expr ();\n+    if (other.type)\n+      type = other.type->clone_type ();\n+\n+    return *this;\n+  }\n+\n+  bool is_error () const { return kind == Kind::Error; }\n+\n+  Kind get_kind () const { return kind; }\n+  const Location &get_locus () const { return locus; }\n+\n+  std::unique_ptr<Expr> &get_expression ()\n+  {\n+    rust_assert (kind == Kind::Const);\n+\n+    return expression;\n+  }\n+\n+  std::unique_ptr<Type> &get_type ()\n+  {\n+    rust_assert (kind == Kind::Type);\n+\n+    return type;\n+  }\n+\n+  const std::string &get_path () const\n+  {\n+    rust_assert (kind == Kind::Either);\n+\n+    return path;\n+  }\n+\n+  std::string as_string () const\n+  {\n+    switch (get_kind ())\n+      {\n+      case Kind::Error:\n+\tgcc_unreachable ();\n+      case Kind::Either:\n+\treturn \"Ambiguous: \" + path;\n+      case Kind::Const:\n+\treturn \"Const: { \" + expression->as_string () + \" }\";\n+      case Kind::Type:\n+\treturn \"Type: \" + type->as_string ();\n+      }\n+\n+    return \"\";\n+  }\n+\n+  /**\n+   * Disambiguate an ambiguous generic argument to a const generic argument,\n+   * unequivocally\n+   */\n+  GenericArg disambiguate_to_const () const;\n+\n+  /**\n+   * Disambiguate an ambiguous generic argument to a type argument,\n+   * unequivocally\n+   */\n+  GenericArg disambiguate_to_type () const;\n+\n+private:\n+  GenericArg (std::unique_ptr<Expr> expression, std::unique_ptr<Type> type,\n+\t      Identifier path, Kind kind, Location locus)\n+    : expression (std::move (expression)), type (std::move (type)),\n+      path (std::move (path)), kind (kind), locus (locus)\n+  {}\n+\n+  /**\n+   * Expression associated with a `Clear` const generic application\n+   * A null pointer here is allowed in the case that the const argument is\n+   * ambiguous.\n+   */\n+  std::unique_ptr<Expr> expression;\n+\n+  /**\n+   * If the argument ends up being a type argument instead. A null pointer will\n+   * be present here until the resolving phase.\n+   */\n+  std::unique_ptr<Type> type;\n+\n+  /**\n+   * Optional path which cannot be differentiated between a constant item and\n+   * a type. Only used for ambiguous const generic arguments, otherwise\n+   * empty.\n+   */\n+  Identifier path;\n+\n+  /* Which kind of const generic application are we dealing with */\n+  Kind kind;\n+\n+  Location locus;\n+};\n+\n+/**\n+ * Representation of const generic parameters\n+ */\n+class ConstGenericParam : public GenericParam\n+{\n+  /* Name of the parameter */\n+  Identifier name;\n+\n+  /* Mandatory type of the const parameter - a null pointer is an error */\n+  std::unique_ptr<AST::Type> type;\n+\n+  /**\n+   * Default value for the const generic parameter\n+   */\n+  GenericArg default_value;\n+\n+  Attribute outer_attr;\n+  Location locus;\n+\n+public:\n+  ConstGenericParam (Identifier name, std::unique_ptr<AST::Type> type,\n+\t\t     GenericArg default_value, Attribute outer_attr,\n+\t\t     Location locus)\n+    : name (name), type (std::move (type)),\n+      default_value (std::move (default_value)), outer_attr (outer_attr),\n+      locus (locus)\n+  {}\n+\n+  ConstGenericParam (const ConstGenericParam &other)\n+    : GenericParam (), name (other.name), type (other.type->clone_type ()),\n+      default_value (other.default_value), outer_attr (other.outer_attr),\n+      locus (other.locus)\n+  {}\n+\n+  bool has_type () const { return type != nullptr; }\n+  bool has_default_value () const { return !default_value.is_error (); }\n+\n+  const Identifier &get_name () const { return name; }\n+\n+  std::unique_ptr<AST::Type> &get_type ()\n+  {\n+    rust_assert (has_type ());\n+\n+    return type;\n+  }\n+\n+  GenericArg &get_default_value ()\n+  {\n+    rust_assert (has_default_value ());\n+\n+    return default_value;\n+  }\n+\n+  const GenericArg &get_default_value () const\n+  {\n+    rust_assert (has_default_value ());\n+\n+    return default_value;\n+  }\n+\n+  std::string as_string () const override;\n+\n+  void accept_vis (ASTVisitor &vis) override;\n+\n+  Location get_locus () const override final { return locus; }\n+\n+  Kind get_kind () const override final { return Kind::Const; }\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  ConstGenericParam *clone_generic_param_impl () const override\n+  {\n+    return new ConstGenericParam (*this);\n+  }\n+};\n+\n+// Generic arguments allowed in each path expression segment - inline?\n+struct GenericArgs\n+{\n+  std::vector<Lifetime> lifetime_args;\n+  std::vector<GenericArg> generic_args;\n+  std::vector<GenericArgsBinding> binding_args;\n+  Location locus;\n+\n+public:\n+  // Returns true if there are any generic arguments\n+  bool has_generic_args () const\n+  {\n+    return !(lifetime_args.empty () && generic_args.empty ()\n+\t     && binding_args.empty ());\n+  }\n+\n+  GenericArgs (std::vector<Lifetime> lifetime_args,\n+\t       std::vector<GenericArg> generic_args,\n+\t       std::vector<GenericArgsBinding> binding_args,\n+\t       Location locus = Location ())\n+    : lifetime_args (std::move (lifetime_args)),\n+      generic_args (std::move (generic_args)),\n+      binding_args (std::move (binding_args)), locus (locus)\n+  {}\n+\n+  // copy constructor with vector clone\n+  GenericArgs (GenericArgs const &other)\n+    : lifetime_args (other.lifetime_args), generic_args (other.generic_args),\n+      binding_args (other.binding_args), locus (other.locus)\n+  {}\n+\n+  ~GenericArgs () = default;\n+\n+  // overloaded assignment operator to vector clone\n+  GenericArgs &operator= (GenericArgs const &other)\n+  {\n+    lifetime_args = other.lifetime_args;\n+    generic_args = other.generic_args;\n+    binding_args = other.binding_args;\n+    locus = other.locus;\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  GenericArgs (GenericArgs &&other) = default;\n+  GenericArgs &operator= (GenericArgs &&other) = default;\n+\n+  // Creates an empty GenericArgs (no arguments)\n+  static GenericArgs create_empty () { return GenericArgs ({}, {}, {}); }\n+\n+  std::string as_string () const;\n+\n+  // TODO: is this better? Or is a \"vis_pattern\" better?\n+  std::vector<GenericArg> &get_generic_args () { return generic_args; }\n+\n+  // TODO: is this better? Or is a \"vis_pattern\" better?\n+  std::vector<GenericArgsBinding> &get_binding_args () { return binding_args; }\n+\n+  std::vector<Lifetime> &get_lifetime_args () { return lifetime_args; };\n+\n+  Location get_locus () { return locus; }\n+};\n+\n+/* A segment of a path in expression, including an identifier aspect and maybe\n+ * generic args */\n+class PathExprSegment\n+{ // or should this extend PathIdentSegment?\n+private:\n+  PathIdentSegment segment_name;\n+  GenericArgs generic_args;\n+  Location locus;\n+  NodeId node_id;\n+\n+public:\n+  // Returns true if there are any generic arguments\n+  bool has_generic_args () const { return generic_args.has_generic_args (); }\n+\n+  // Constructor for segment (from IdentSegment and GenericArgs)\n+  PathExprSegment (PathIdentSegment segment_name, Location locus,\n+\t\t   GenericArgs generic_args = GenericArgs::create_empty ())\n+    : segment_name (std::move (segment_name)),\n+      generic_args (std::move (generic_args)), locus (locus),\n+      node_id (Analysis::Mappings::get ()->get_next_node_id ())\n+  {}\n+\n+  /* Constructor for segment with generic arguments (from segment name and all\n+   * args) */\n+  PathExprSegment (std::string segment_name, Location locus,\n+\t\t   std::vector<Lifetime> lifetime_args = {},\n+\t\t   std::vector<GenericArg> generic_args = {},\n+\t\t   std::vector<GenericArgsBinding> binding_args = {})\n+    : segment_name (PathIdentSegment (std::move (segment_name), locus)),\n+      generic_args (GenericArgs (std::move (lifetime_args),\n+\t\t\t\t std::move (generic_args),\n+\t\t\t\t std::move (binding_args))),\n+      locus (locus), node_id (Analysis::Mappings::get ()->get_next_node_id ())\n+  {}\n+\n+  // Returns whether path expression segment is in an error state.\n+  bool is_error () const { return segment_name.is_error (); }\n+\n+  // Creates an error-state path expression segment.\n+  static PathExprSegment create_error ()\n+  {\n+    return PathExprSegment (PathIdentSegment::create_error (), Location ());\n+  }\n+\n+  std::string as_string () const;\n+\n+  Location get_locus () const { return locus; }\n+\n+  // TODO: is this better? Or is a \"vis_pattern\" better?\n+  GenericArgs &get_generic_args ()\n+  {\n+    rust_assert (has_generic_args ());\n+    return generic_args;\n+  }\n+\n+  PathIdentSegment &get_ident_segment () { return segment_name; }\n+  const PathIdentSegment &get_ident_segment () const { return segment_name; }\n+\n+  NodeId get_node_id () const { return node_id; }\n+\n+  bool is_super_path_seg () const\n+  {\n+    return !has_generic_args () && get_ident_segment ().is_super_segment ();\n+  }\n+\n+  bool is_crate_path_seg () const\n+  {\n+    return !has_generic_args () && get_ident_segment ().is_crate_segment ();\n+  }\n+  bool is_lower_self_seg () const\n+  {\n+    return !has_generic_args () && get_ident_segment ().is_lower_self ();\n+  }\n+};\n+\n+// AST node representing a pattern that involves a \"path\" - abstract base\n+// class\n+class PathPattern : public Pattern\n+{\n+  std::vector<PathExprSegment> segments;\n+\n+protected:\n+  PathPattern (std::vector<PathExprSegment> segments)\n+    : segments (std::move (segments))\n+  {}\n+\n+  // Returns whether path has segments.\n+  bool has_segments () const { return !segments.empty (); }\n+\n+  /* Converts path segments to their equivalent SimplePath segments if\n+   * possible, and creates a SimplePath from them. */\n+  SimplePath convert_to_simple_path (bool with_opening_scope_resolution) const;\n+\n+  // Removes all segments of the path.\n+  void remove_all_segments ()\n+  {\n+    segments.clear ();\n+    segments.shrink_to_fit ();\n+  }\n+\n+public:\n+  /* Returns whether the path is a single segment (excluding qualified path\n+   * initial as segment). */\n+  bool is_single_segment () const { return segments.size () == 1; }\n+\n+  std::string as_string () const override;\n+\n+  // TODO: this seems kinda dodgy\n+  std::vector<PathExprSegment> &get_segments () { return segments; }\n+  const std::vector<PathExprSegment> &get_segments () const { return segments; }\n+};\n+\n+/* AST node representing a path-in-expression pattern (path that allows\n+ * generic arguments) */\n+class PathInExpression : public PathPattern, public PathExpr\n+{\n+  std::vector<Attribute> outer_attrs;\n+  bool has_opening_scope_resolution;\n+  Location locus;\n+  NodeId _node_id;\n+\n+public:\n+  std::string as_string () const override;\n+\n+  // Constructor\n+  PathInExpression (std::vector<PathExprSegment> path_segments,\n+\t\t    std::vector<Attribute> outer_attrs, Location locus,\n+\t\t    bool has_opening_scope_resolution = false)\n+    : PathPattern (std::move (path_segments)),\n+      outer_attrs (std::move (outer_attrs)),\n+      has_opening_scope_resolution (has_opening_scope_resolution),\n+      locus (locus), _node_id (Analysis::Mappings::get ()->get_next_node_id ())\n+  {}\n+\n+  // Creates an error state path in expression.\n+  static PathInExpression create_error ()\n+  {\n+    return PathInExpression ({}, {}, Location ());\n+  }\n+\n+  // Returns whether path in expression is in an error state.\n+  bool is_error () const { return !has_segments (); }\n+\n+  /* Converts PathInExpression to SimplePath if possible (i.e. no generic\n+   * arguments). Otherwise returns an empty SimplePath. */\n+  SimplePath as_simple_path () const\n+  {\n+    /* delegate to parent class as can't access segments. however,\n+     * QualifiedPathInExpression conversion to simple path wouldn't make\n+     * sense, so the method in the parent class should be protected, not\n+     * public. Have to pass in opening scope resolution as parent class has no\n+     * access to it.\n+     */\n+    return convert_to_simple_path (has_opening_scope_resolution);\n+  }\n+\n+  Location get_locus () const override final { return locus; }\n+\n+  void accept_vis (ASTVisitor &vis) override;\n+\n+  // Invalid if path is empty (error state), so base stripping on that.\n+  void mark_for_strip () override { remove_all_segments (); }\n+  bool is_marked_for_strip () const override { return is_error (); }\n+\n+  bool opening_scope_resolution () const\n+  {\n+    return has_opening_scope_resolution;\n+  }\n+\n+  NodeId get_node_id () const override { return _node_id; }\n+\n+  const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n+  std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n+\n+  void set_outer_attrs (std::vector<Attribute> new_attrs) override\n+  {\n+    outer_attrs = std::move (new_attrs);\n+  }\n+\n+  NodeId get_pattern_node_id () const override final { return get_node_id (); }\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object\n+   * rather than base */\n+  PathInExpression *clone_pattern_impl () const final override\n+  {\n+    return clone_path_in_expression_impl ();\n+  }\n+\n+  /* Use covariance to implement clone function as returning this object\n+   * rather than base */\n+  PathInExpression *clone_expr_without_block_impl () const final override\n+  {\n+    return clone_path_in_expression_impl ();\n+  }\n+\n+  /*virtual*/ PathInExpression *clone_path_in_expression_impl () const\n+  {\n+    return new PathInExpression (*this);\n+  }\n+};\n+\n+/* Base class for segments used in type paths - not abstract (represents an\n+ * ident-only segment) */\n+class TypePathSegment\n+{\n+public:\n+  enum SegmentType\n+  {\n+    REG,\n+    GENERIC,\n+    FUNCTION\n+  };\n+\n+private:\n+  PathIdentSegment ident_segment;\n+  Location locus;\n+\n+protected:\n+  /* This is protected because it is only really used by derived classes, not\n+   * the base. */\n+  bool has_separating_scope_resolution;\n+  NodeId node_id;\n+\n+  // Clone function implementation - not pure virtual as overrided by\n+  // subclasses\n+  virtual TypePathSegment *clone_type_path_segment_impl () const\n+  {\n+    return new TypePathSegment (*this);\n+  }\n+\n+public:\n+  virtual ~TypePathSegment () {}\n+\n+  virtual SegmentType get_type () const { return SegmentType::REG; }\n+\n+  // Unique pointer custom clone function\n+  std::unique_ptr<TypePathSegment> clone_type_path_segment () const\n+  {\n+    return std::unique_ptr<TypePathSegment> (clone_type_path_segment_impl ());\n+  }\n+\n+  TypePathSegment (PathIdentSegment ident_segment,\n+\t\t   bool has_separating_scope_resolution, Location locus)\n+    : ident_segment (std::move (ident_segment)), locus (locus),\n+      has_separating_scope_resolution (has_separating_scope_resolution),\n+      node_id (Analysis::Mappings::get ()->get_next_node_id ())\n+  {}\n+\n+  TypePathSegment (std::string segment_name,\n+\t\t   bool has_separating_scope_resolution, Location locus)\n+    : ident_segment (PathIdentSegment (std::move (segment_name), locus)),\n+      locus (locus),\n+      has_separating_scope_resolution (has_separating_scope_resolution),\n+      node_id (Analysis::Mappings::get ()->get_next_node_id ())\n+  {}\n+\n+  virtual std::string as_string () const { return ident_segment.as_string (); }\n+\n+  /* Returns whether the type path segment is in an error state. May be\n+   * virtual in future. */\n+  bool is_error () const { return ident_segment.is_error (); }\n+\n+  /* Returns whether segment is identifier only (as opposed to generic args or\n+   * function). Overridden in derived classes with other segments. */\n+  virtual bool is_ident_only () const { return true; }\n+\n+  Location get_locus () const { return locus; }\n+\n+  // not pure virtual as class not abstract\n+  virtual void accept_vis (ASTVisitor &vis);\n+\n+  bool get_separating_scope_resolution () const\n+  {\n+    return has_separating_scope_resolution;\n+  }\n+\n+  PathIdentSegment &get_ident_segment () { return ident_segment; };\n+  const PathIdentSegment &get_ident_segment () const { return ident_segment; };\n+\n+  NodeId get_node_id () const { return node_id; }\n+\n+  bool is_crate_path_seg () const\n+  {\n+    return get_ident_segment ().is_crate_segment ();\n+  }\n+  bool is_super_path_seg () const\n+  {\n+    return get_ident_segment ().is_super_segment ();\n+  }\n+  bool is_big_self_seg () const { return get_ident_segment ().is_big_self (); }\n+  bool is_lower_self_seg () const\n+  {\n+    return get_ident_segment ().is_lower_self ();\n+  }\n+};\n+\n+// Segment used in type path with generic args\n+class TypePathSegmentGeneric : public TypePathSegment\n+{\n+  GenericArgs generic_args;\n+\n+public:\n+  SegmentType get_type () const override { return SegmentType::GENERIC; }\n+\n+  bool has_generic_args () const { return generic_args.has_generic_args (); }\n+\n+  bool is_ident_only () const override { return false; }\n+\n+  // Constructor with PathIdentSegment and GenericArgs\n+  TypePathSegmentGeneric (PathIdentSegment ident_segment,\n+\t\t\t  bool has_separating_scope_resolution,\n+\t\t\t  GenericArgs generic_args, Location locus)\n+    : TypePathSegment (std::move (ident_segment),\n+\t\t       has_separating_scope_resolution, locus),\n+      generic_args (std::move (generic_args))\n+  {}\n+\n+  // Constructor from segment name and all args\n+  TypePathSegmentGeneric (std::string segment_name,\n+\t\t\t  bool has_separating_scope_resolution,\n+\t\t\t  std::vector<Lifetime> lifetime_args,\n+\t\t\t  std::vector<GenericArg> generic_args,\n+\t\t\t  std::vector<GenericArgsBinding> binding_args,\n+\t\t\t  Location locus)\n+    : TypePathSegment (std::move (segment_name),\n+\t\t       has_separating_scope_resolution, locus),\n+      generic_args (GenericArgs (std::move (lifetime_args),\n+\t\t\t\t std::move (generic_args),\n+\t\t\t\t std::move (binding_args)))\n+  {}\n+\n+  std::string as_string () const override;\n+\n+  void accept_vis (ASTVisitor &vis) override;\n+\n+  // TODO: is this better? Or is a \"vis_pattern\" better?\n+  GenericArgs &get_generic_args ()\n+  {\n+    rust_assert (has_generic_args ());\n+    return generic_args;\n+  }\n+\n+protected:\n+  // Use covariance to override base class method\n+  TypePathSegmentGeneric *clone_type_path_segment_impl () const override\n+  {\n+    return new TypePathSegmentGeneric (*this);\n+  }\n+};\n+\n+// A function as represented in a type path\n+struct TypePathFunction\n+{\n+private:\n+  // TODO: remove\n+  /*bool has_inputs;\n+  TypePathFnInputs inputs;*/\n+  // inlined from TypePathFnInputs\n+  std::vector<std::unique_ptr<Type> > inputs;\n+\n+  // bool has_type;\n+  std::unique_ptr<Type> return_type;\n+\n+  // FIXME: think of better way to mark as invalid than taking up storage\n+  bool is_invalid;\n+\n+  Location locus;\n+\n+protected:\n+  // Constructor only used to create invalid type path functions.\n+  TypePathFunction (bool is_invalid, Location locus)\n+    : is_invalid (is_invalid), locus (locus)\n+  {}\n+\n+public:\n+  // Returns whether the return type of the function has been specified.\n+  bool has_return_type () const { return return_type != nullptr; }\n+\n+  // Returns whether the function has inputs.\n+  bool has_inputs () const { return !inputs.empty (); }\n+\n+  // Returns whether function is in an error state.\n+  bool is_error () const { return is_invalid; }\n+\n+  // Creates an error state function.\n+  static TypePathFunction create_error ()\n+  {\n+    return TypePathFunction (true, Location ());\n+  }\n+\n+  // Constructor\n+  TypePathFunction (std::vector<std::unique_ptr<Type> > inputs, Location locus,\n+\t\t    std::unique_ptr<Type> type = nullptr)\n+    : inputs (std::move (inputs)), return_type (std::move (type)),\n+      is_invalid (false), locus (locus)\n+  {}\n+\n+  // Copy constructor with clone\n+  TypePathFunction (TypePathFunction const &other)\n+    : is_invalid (other.is_invalid)\n+  {\n+    // guard to protect from null pointer dereference\n+    if (other.return_type != nullptr)\n+      return_type = other.return_type->clone_type ();\n+\n+    inputs.reserve (other.inputs.size ());\n+    for (const auto &e : other.inputs)\n+      inputs.push_back (e->clone_type ());\n+  }\n+\n+  ~TypePathFunction () = default;\n+\n+  // Overloaded assignment operator to clone type\n+  TypePathFunction &operator= (TypePathFunction const &other)\n+  {\n+    is_invalid = other.is_invalid;\n+\n+    // guard to protect from null pointer dereference\n+    if (other.return_type != nullptr)\n+      return_type = other.return_type->clone_type ();\n+    else\n+      return_type = nullptr;\n+\n+    inputs.reserve (other.inputs.size ());\n+    for (const auto &e : other.inputs)\n+      inputs.push_back (e->clone_type ());\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  TypePathFunction (TypePathFunction &&other) = default;\n+  TypePathFunction &operator= (TypePathFunction &&other) = default;\n+\n+  std::string as_string () const;\n+\n+  // TODO: this mutable getter seems really dodgy. Think up better way.\n+  const std::vector<std::unique_ptr<Type> > &get_params () const\n+  {\n+    return inputs;\n+  }\n+  std::vector<std::unique_ptr<Type> > &get_params () { return inputs; }\n+\n+  // TODO: is this better? Or is a \"vis_pattern\" better?\n+  std::unique_ptr<Type> &get_return_type ()\n+  {\n+    rust_assert (has_return_type ());\n+    return return_type;\n+  }\n+};\n+\n+// Segment used in type path with a function argument\n+class TypePathSegmentFunction : public TypePathSegment\n+{\n+  TypePathFunction function_path;\n+\n+public:\n+  SegmentType get_type () const override { return SegmentType::FUNCTION; }\n+\n+  // Constructor with PathIdentSegment and TypePathFn\n+  TypePathSegmentFunction (PathIdentSegment ident_segment,\n+\t\t\t   bool has_separating_scope_resolution,\n+\t\t\t   TypePathFunction function_path, Location locus)\n+    : TypePathSegment (std::move (ident_segment),\n+\t\t       has_separating_scope_resolution, locus),\n+      function_path (std::move (function_path))\n+  {}\n+\n+  // Constructor with segment name and TypePathFn\n+  TypePathSegmentFunction (std::string segment_name,\n+\t\t\t   bool has_separating_scope_resolution,\n+\t\t\t   TypePathFunction function_path, Location locus)\n+    : TypePathSegment (std::move (segment_name),\n+\t\t       has_separating_scope_resolution, locus),\n+      function_path (std::move (function_path))\n+  {}\n+\n+  std::string as_string () const override;\n+\n+  bool is_ident_only () const override { return false; }\n+\n+  void accept_vis (ASTVisitor &vis) override;\n+\n+  // TODO: is this better? Or is a \"vis_pattern\" better?\n+  TypePathFunction &get_type_path_function ()\n+  {\n+    rust_assert (!function_path.is_error ());\n+    return function_path;\n+  }\n+\n+protected:\n+  // Use covariance to override base class method\n+  TypePathSegmentFunction *clone_type_path_segment_impl () const override\n+  {\n+    return new TypePathSegmentFunction (*this);\n+  }\n+};\n+\n+// Path used inside types\n+class TypePath : public TypeNoBounds\n+{\n+  bool has_opening_scope_resolution;\n+  std::vector<std::unique_ptr<TypePathSegment> > segments;\n+  Location locus;\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object\n+   * rather than base */\n+  TypePath *clone_type_no_bounds_impl () const override\n+  {\n+    return new TypePath (*this);\n+  }\n+\n+public:\n+  /* Returns whether the TypePath has an opening scope resolution operator\n+   * (i.e. is global path or crate-relative path, not module-relative) */\n+  bool has_opening_scope_resolution_op () const\n+  {\n+    return has_opening_scope_resolution;\n+  }\n+\n+  // Returns whether the TypePath is in an invalid state.\n+  bool is_error () const { return segments.empty (); }\n+\n+  // Creates an error state TypePath.\n+  static TypePath create_error ()\n+  {\n+    return TypePath (std::vector<std::unique_ptr<TypePathSegment> > (),\n+\t\t     Location ());\n+  }\n+\n+  // Constructor\n+  TypePath (std::vector<std::unique_ptr<TypePathSegment> > segments,\n+\t    Location locus, bool has_opening_scope_resolution = false)\n+    : TypeNoBounds (),\n+      has_opening_scope_resolution (has_opening_scope_resolution),\n+      segments (std::move (segments)), locus (locus)\n+  {}\n+\n+  // Copy constructor with vector clone\n+  TypePath (TypePath const &other)\n+    : has_opening_scope_resolution (other.has_opening_scope_resolution),\n+      locus (other.locus)\n+  {\n+    segments.reserve (other.segments.size ());\n+    for (const auto &e : other.segments)\n+      segments.push_back (e->clone_type_path_segment ());\n+  }\n+\n+  // Overloaded assignment operator with clone\n+  TypePath &operator= (TypePath const &other)\n+  {\n+    has_opening_scope_resolution = other.has_opening_scope_resolution;\n+    locus = other.locus;\n+\n+    segments.reserve (other.segments.size ());\n+    for (const auto &e : other.segments)\n+      segments.push_back (e->clone_type_path_segment ());\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  TypePath (TypePath &&other) = default;\n+  TypePath &operator= (TypePath &&other) = default;\n+\n+  std::string as_string () const override;\n+\n+  /* Converts TypePath to SimplePath if possible (i.e. no generic or function\n+   * arguments). Otherwise returns an empty SimplePath. */\n+  SimplePath as_simple_path () const;\n+\n+  // Creates a trait bound with a clone of this type path as its only element.\n+  TraitBound *to_trait_bound (bool in_parens) const override;\n+\n+  Location get_locus () const override final { return locus; }\n+\n+  void accept_vis (ASTVisitor &vis) override;\n+\n+  // TODO: this seems kinda dodgy\n+  std::vector<std::unique_ptr<TypePathSegment> > &get_segments ()\n+  {\n+    return segments;\n+  }\n+  const std::vector<std::unique_ptr<TypePathSegment> > &get_segments () const\n+  {\n+    return segments;\n+  }\n+\n+  size_t get_num_segments () const { return segments.size (); }\n+};\n+\n+struct QualifiedPathType\n+{\n+private:\n+  std::unique_ptr<Type> type_to_invoke_on;\n+  TypePath trait_path;\n+  Location locus;\n+  NodeId node_id;\n+\n+public:\n+  // Constructor\n+  QualifiedPathType (std::unique_ptr<Type> invoke_on_type,\n+\t\t     Location locus = Location (),\n+\t\t     TypePath trait_path = TypePath::create_error ())\n+    : type_to_invoke_on (std::move (invoke_on_type)),\n+      trait_path (std::move (trait_path)), locus (locus),\n+      node_id (Analysis::Mappings::get ()->get_next_node_id ())\n+  {}\n+\n+  // Copy constructor uses custom deep copy for Type to preserve polymorphism\n+  QualifiedPathType (QualifiedPathType const &other)\n+    : trait_path (other.trait_path), locus (other.locus)\n+  {\n+    node_id = other.node_id;\n+    // guard to prevent null dereference\n+    if (other.type_to_invoke_on != nullptr)\n+      type_to_invoke_on = other.type_to_invoke_on->clone_type ();\n+  }\n+\n+  // default destructor\n+  ~QualifiedPathType () = default;\n+\n+  // overload assignment operator to use custom clone method\n+  QualifiedPathType &operator= (QualifiedPathType const &other)\n+  {\n+    node_id = other.node_id;\n+    trait_path = other.trait_path;\n+    locus = other.locus;\n+\n+    // guard to prevent null dereference\n+    if (other.type_to_invoke_on != nullptr)\n+      type_to_invoke_on = other.type_to_invoke_on->clone_type ();\n+    else\n+      type_to_invoke_on = nullptr;\n+\n+    return *this;\n+  }\n+\n+  // move constructor\n+  QualifiedPathType (QualifiedPathType &&other) = default;\n+  QualifiedPathType &operator= (QualifiedPathType &&other) = default;\n+\n+  // Returns whether the qualified path type has a rebind as clause.\n+  bool has_as_clause () const { return !trait_path.is_error (); }\n+\n+  // Returns whether the qualified path type is in an error state.\n+  bool is_error () const { return type_to_invoke_on == nullptr; }\n+\n+  // Creates an error state qualified path type.\n+  static QualifiedPathType create_error ()\n+  {\n+    return QualifiedPathType (nullptr);\n+  }\n+\n+  std::string as_string () const;\n+\n+  Location get_locus () const { return locus; }\n+\n+  // TODO: is this better? Or is a \"vis_pattern\" better?\n+  std::unique_ptr<Type> &get_type ()\n+  {\n+    rust_assert (type_to_invoke_on != nullptr);\n+    return type_to_invoke_on;\n+  }\n+\n+  // TODO: is this better? Or is a \"vis_pattern\" better?\n+  TypePath &get_as_type_path ()\n+  {\n+    rust_assert (has_as_clause ());\n+    return trait_path;\n+  }\n+\n+  NodeId get_node_id () const { return node_id; }\n+};\n+\n+/* AST node representing a qualified path-in-expression pattern (path that\n+ * allows specifying trait functions) */\n+class QualifiedPathInExpression : public PathPattern, public PathExpr\n+{\n+  std::vector<Attribute> outer_attrs;\n+  QualifiedPathType path_type;\n+  Location locus;\n+  NodeId _node_id;\n+\n+public:\n+  std::string as_string () const override;\n+\n+  QualifiedPathInExpression (QualifiedPathType qual_path_type,\n+\t\t\t     std::vector<PathExprSegment> path_segments,\n+\t\t\t     std::vector<Attribute> outer_attrs, Location locus)\n+    : PathPattern (std::move (path_segments)),\n+      outer_attrs (std::move (outer_attrs)),\n+      path_type (std::move (qual_path_type)), locus (locus),\n+      _node_id (Analysis::Mappings::get ()->get_next_node_id ())\n+  {}\n+\n+  /* TODO: maybe make a shortcut constructor that has QualifiedPathType\n+   * elements as params */\n+\n+  // Returns whether qualified path in expression is in an error state.\n+  bool is_error () const { return path_type.is_error (); }\n+\n+  // Creates an error qualified path in expression.\n+  static QualifiedPathInExpression create_error ()\n+  {\n+    return QualifiedPathInExpression (QualifiedPathType::create_error (), {},\n+\t\t\t\t      {}, Location ());\n+  }\n+\n+  Location get_locus () const override final { return locus; }\n+\n+  void accept_vis (ASTVisitor &vis) override;\n+\n+  // Invalid if path_type is error, so base stripping on that.\n+  void mark_for_strip () override\n+  {\n+    path_type = QualifiedPathType::create_error ();\n+  }\n+  bool is_marked_for_strip () const override { return is_error (); }\n+\n+  // TODO: is this better? Or is a \"vis_pattern\" better?\n+  QualifiedPathType &get_qualified_path_type ()\n+  {\n+    rust_assert (!path_type.is_error ());\n+    return path_type;\n+  }\n+\n+  const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n+  std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n+\n+  void set_outer_attrs (std::vector<Attribute> new_attrs) override\n+  {\n+    outer_attrs = std::move (new_attrs);\n+  }\n+\n+  NodeId get_node_id () const override { return _node_id; }\n+\n+  NodeId get_pattern_node_id () const override final { return get_node_id (); }\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object\n+   * rather than base */\n+  QualifiedPathInExpression *clone_pattern_impl () const final override\n+  {\n+    return clone_qual_path_in_expression_impl ();\n+  }\n+\n+  /* Use covariance to implement clone function as returning this object\n+   * rather than base */\n+  QualifiedPathInExpression *\n+  clone_expr_without_block_impl () const final override\n+  {\n+    return clone_qual_path_in_expression_impl ();\n+  }\n+\n+  /*virtual*/ QualifiedPathInExpression *\n+  clone_qual_path_in_expression_impl () const\n+  {\n+    return new QualifiedPathInExpression (*this);\n+  }\n+};\n+\n+/* Represents a qualified path in a type; used for disambiguating trait\n+ * function calls */\n+class QualifiedPathInType : public TypeNoBounds\n+{\n+  QualifiedPathType path_type;\n+  std::unique_ptr<TypePathSegment> associated_segment;\n+  std::vector<std::unique_ptr<TypePathSegment> > segments;\n+  Location locus;\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object\n+   * rather than base */\n+  QualifiedPathInType *clone_type_no_bounds_impl () const override\n+  {\n+    return new QualifiedPathInType (*this);\n+  }\n+\n+public:\n+  QualifiedPathInType (\n+    QualifiedPathType qual_path_type,\n+    std::unique_ptr<TypePathSegment> associated_segment,\n+    std::vector<std::unique_ptr<TypePathSegment> > path_segments,\n+    Location locus)\n+    : path_type (std::move (qual_path_type)),\n+      associated_segment (std::move (associated_segment)),\n+      segments (std::move (path_segments)), locus (locus)\n+  {}\n+\n+  /* TODO: maybe make a shortcut constructor that has QualifiedPathType\n+   * elements as params */\n+\n+  // Copy constructor with vector clone\n+  QualifiedPathInType (QualifiedPathInType const &other)\n+    : path_type (other.path_type), locus (other.locus)\n+  {\n+    segments.reserve (other.segments.size ());\n+    for (const auto &e : other.segments)\n+      segments.push_back (e->clone_type_path_segment ());\n+  }\n+\n+  // Overloaded assignment operator with vector clone\n+  QualifiedPathInType &operator= (QualifiedPathInType const &other)\n+  {\n+    path_type = other.path_type;\n+    locus = other.locus;\n+\n+    segments.reserve (other.segments.size ());\n+    for (const auto &e : other.segments)\n+      segments.push_back (e->clone_type_path_segment ());\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  QualifiedPathInType (QualifiedPathInType &&other) = default;\n+  QualifiedPathInType &operator= (QualifiedPathInType &&other) = default;\n+\n+  // Returns whether qualified path in type is in an error state.\n+  bool is_error () const { return path_type.is_error (); }\n+\n+  // Creates an error state qualified path in type.\n+  static QualifiedPathInType create_error ()\n+  {\n+    return QualifiedPathInType (\n+      QualifiedPathType::create_error (), nullptr,\n+      std::vector<std::unique_ptr<TypePathSegment> > (), Location ());\n+  }\n+\n+  std::string as_string () const override;\n+\n+  void accept_vis (ASTVisitor &vis) override;\n+\n+  // TODO: is this better? Or is a \"vis_pattern\" better?\n+  QualifiedPathType &get_qualified_path_type ()\n+  {\n+    rust_assert (!path_type.is_error ());\n+    return path_type;\n+  }\n+\n+  std::unique_ptr<TypePathSegment> &get_associated_segment ()\n+  {\n+    return associated_segment;\n+  }\n+\n+  // TODO: this seems kinda dodgy\n+  std::vector<std::unique_ptr<TypePathSegment> > &get_segments ()\n+  {\n+    return segments;\n+  }\n+  const std::vector<std::unique_ptr<TypePathSegment> > &get_segments () const\n+  {\n+    return segments;\n+  }\n+\n+  Location get_locus () const override final { return locus; }\n+};\n+} // namespace AST\n+} // namespace Rust\n+\n+#endif"}, {"sha": "247af5dbe05f569fd76d4efa5af50823966222c7", "filename": "gcc/rust/ast/rust-pattern.h", "status": "added", "additions": 1576, "deletions": 0, "changes": 1576, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d588754c8266d74c9eef1e38d2d96e66ff876107/gcc%2Frust%2Fast%2Frust-pattern.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d588754c8266d74c9eef1e38d2d96e66ff876107/gcc%2Frust%2Fast%2Frust-pattern.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-pattern.h?ref=d588754c8266d74c9eef1e38d2d96e66ff876107", "patch": "@@ -0,0 +1,1576 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_AST_PATTERN_H\n+#define RUST_AST_PATTERN_H\n+\n+#include \"rust-ast.h\"\n+\n+namespace Rust {\n+namespace AST {\n+// Literal pattern AST node (comparing to a literal)\n+class LiteralPattern : public Pattern\n+{\n+  Literal lit;\n+  Location locus;\n+  NodeId node_id;\n+\n+public:\n+  std::string as_string () const override;\n+\n+  // Constructor for a literal pattern\n+  LiteralPattern (Literal lit, Location locus)\n+    : lit (std::move (lit)), locus (locus),\n+      node_id (Analysis::Mappings::get ()->get_next_node_id ())\n+  {}\n+\n+  LiteralPattern (std::string val, Literal::LitType type, Location locus)\n+    : lit (Literal (std::move (val), type, PrimitiveCoreType::CORETYPE_STR)),\n+      locus (locus), node_id (Analysis::Mappings::get ()->get_next_node_id ())\n+  {}\n+\n+  Location get_locus () const override final { return locus; }\n+\n+  void accept_vis (ASTVisitor &vis) override;\n+\n+  NodeId get_node_id () const { return node_id; }\n+\n+  NodeId get_pattern_node_id () const override final { return node_id; }\n+\n+  Literal &get_literal () { return lit; }\n+\n+  const Literal &get_literal () const { return lit; }\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  virtual LiteralPattern *clone_pattern_impl () const override\n+  {\n+    return new LiteralPattern (*this);\n+  }\n+};\n+\n+// Identifier pattern AST node (bind value matched to a variable)\n+class IdentifierPattern : public Pattern\n+{\n+  Identifier variable_ident;\n+  bool is_ref;\n+  bool is_mut;\n+\n+  // bool has_pattern;\n+  std::unique_ptr<Pattern> to_bind;\n+  Location locus;\n+  NodeId node_id;\n+\n+public:\n+  std::string as_string () const override;\n+\n+  // Returns whether the IdentifierPattern has a pattern to bind.\n+  bool has_pattern_to_bind () const { return to_bind != nullptr; }\n+\n+  // Constructor\n+  IdentifierPattern (Identifier ident, Location locus, bool is_ref = false,\n+\t\t     bool is_mut = false,\n+\t\t     std::unique_ptr<Pattern> to_bind = nullptr)\n+    : Pattern (), variable_ident (std::move (ident)), is_ref (is_ref),\n+      is_mut (is_mut), to_bind (std::move (to_bind)), locus (locus),\n+      node_id (Analysis::Mappings::get ()->get_next_node_id ())\n+  {}\n+\n+  IdentifierPattern (NodeId node_id, Identifier ident, Location locus,\n+\t\t     bool is_ref = false, bool is_mut = false,\n+\t\t     std::unique_ptr<Pattern> to_bind = nullptr)\n+    : Pattern (), variable_ident (std::move (ident)), is_ref (is_ref),\n+      is_mut (is_mut), to_bind (std::move (to_bind)), locus (locus),\n+      node_id (node_id)\n+  {}\n+\n+  // Copy constructor with clone\n+  IdentifierPattern (IdentifierPattern const &other)\n+    : variable_ident (other.variable_ident), is_ref (other.is_ref),\n+      is_mut (other.is_mut), locus (other.locus), node_id (other.node_id)\n+  {\n+    // fix to get prevent null pointer dereference\n+    if (other.to_bind != nullptr)\n+      to_bind = other.to_bind->clone_pattern ();\n+  }\n+\n+  // Overload assignment operator to use clone\n+  IdentifierPattern &operator= (IdentifierPattern const &other)\n+  {\n+    variable_ident = other.variable_ident;\n+    is_ref = other.is_ref;\n+    is_mut = other.is_mut;\n+    locus = other.locus;\n+    node_id = other.node_id;\n+\n+    // fix to prevent null pointer dereference\n+    if (other.to_bind != nullptr)\n+      to_bind = other.to_bind->clone_pattern ();\n+    else\n+      to_bind = nullptr;\n+\n+    return *this;\n+  }\n+\n+  // default move semantics\n+  IdentifierPattern (IdentifierPattern &&other) = default;\n+  IdentifierPattern &operator= (IdentifierPattern &&other) = default;\n+\n+  Location get_locus () const override final { return locus; }\n+\n+  void accept_vis (ASTVisitor &vis) override;\n+\n+  // TODO: is this better? Or is a \"vis_pattern\" better?\n+  std::unique_ptr<Pattern> &get_pattern_to_bind ()\n+  {\n+    rust_assert (has_pattern_to_bind ());\n+    return to_bind;\n+  }\n+\n+  Identifier get_ident () const { return variable_ident; }\n+\n+  bool get_is_mut () const { return is_mut; }\n+  bool get_is_ref () const { return is_ref; }\n+\n+  NodeId get_node_id () const { return node_id; }\n+\n+  NodeId get_pattern_node_id () const override final { return node_id; }\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  IdentifierPattern *clone_pattern_impl () const override\n+  {\n+    return new IdentifierPattern (*this);\n+  }\n+};\n+\n+// AST node for using the '_' wildcard \"match any value\" pattern\n+class WildcardPattern : public Pattern\n+{\n+  Location locus;\n+  NodeId node_id;\n+\n+public:\n+  std::string as_string () const override { return std::string (1, '_'); }\n+\n+  WildcardPattern (Location locus)\n+    : locus (locus), node_id (Analysis::Mappings::get ()->get_next_node_id ())\n+  {}\n+\n+  Location get_locus () const override final { return locus; }\n+\n+  void accept_vis (ASTVisitor &vis) override;\n+\n+  NodeId get_node_id () const { return node_id; }\n+\n+  NodeId get_pattern_node_id () const override final { return node_id; }\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  WildcardPattern *clone_pattern_impl () const override\n+  {\n+    return new WildcardPattern (*this);\n+  }\n+};\n+\n+// Base range pattern bound (lower or upper limit) - abstract\n+class RangePatternBound\n+{\n+public:\n+  enum RangePatternBoundType\n+  {\n+    LITERAL,\n+    PATH,\n+    QUALPATH\n+  };\n+\n+  virtual ~RangePatternBound () {}\n+\n+  // Unique pointer custom clone function\n+  std::unique_ptr<RangePatternBound> clone_range_pattern_bound () const\n+  {\n+    return std::unique_ptr<RangePatternBound> (\n+      clone_range_pattern_bound_impl ());\n+  }\n+\n+  virtual std::string as_string () const = 0;\n+\n+  virtual void accept_vis (ASTVisitor &vis) = 0;\n+\n+  virtual RangePatternBoundType get_bound_type () const = 0;\n+\n+protected:\n+  // pure virtual as RangePatternBound is abstract\n+  virtual RangePatternBound *clone_range_pattern_bound_impl () const = 0;\n+};\n+\n+// Literal-based pattern bound\n+class RangePatternBoundLiteral : public RangePatternBound\n+{\n+  Literal literal;\n+  /* Can only be a char, byte, int, or float literal - same impl here as\n+   * previously */\n+\n+  // Minus prefixed to literal (if integer or floating-point)\n+  bool has_minus;\n+\n+  Location locus;\n+\n+public:\n+  // Constructor\n+  RangePatternBoundLiteral (Literal literal, Location locus,\n+\t\t\t    bool has_minus = false)\n+    : literal (literal), has_minus (has_minus), locus (locus)\n+  {}\n+\n+  std::string as_string () const override;\n+\n+  Literal get_literal () const { return literal; }\n+\n+  bool get_has_minus () const { return has_minus; }\n+\n+  Location get_locus () const { return locus; }\n+\n+  void accept_vis (ASTVisitor &vis) override;\n+\n+  RangePatternBoundType get_bound_type () const override\n+  {\n+    return RangePatternBoundType::LITERAL;\n+  }\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  RangePatternBoundLiteral *clone_range_pattern_bound_impl () const override\n+  {\n+    return new RangePatternBoundLiteral (*this);\n+  }\n+};\n+\n+// Path-based pattern bound\n+class RangePatternBoundPath : public RangePatternBound\n+{\n+  PathInExpression path;\n+\n+  /* TODO: should this be refactored so that PathInExpression is a subclass of\n+   * RangePatternBound? */\n+\n+public:\n+  RangePatternBoundPath (PathInExpression path) : path (std::move (path)) {}\n+\n+  std::string as_string () const override { return path.as_string (); }\n+\n+  Location get_locus () const { return path.get_locus (); }\n+\n+  void accept_vis (ASTVisitor &vis) override;\n+\n+  // TODO: this mutable getter seems kinda dodgy\n+  PathInExpression &get_path () { return path; }\n+  const PathInExpression &get_path () const { return path; }\n+\n+  RangePatternBoundType get_bound_type () const override\n+  {\n+    return RangePatternBoundType::PATH;\n+  }\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  RangePatternBoundPath *clone_range_pattern_bound_impl () const override\n+  {\n+    return new RangePatternBoundPath (*this);\n+  }\n+};\n+\n+// Qualified path-based pattern bound\n+class RangePatternBoundQualPath : public RangePatternBound\n+{\n+  QualifiedPathInExpression path;\n+\n+  /* TODO: should this be refactored so that QualifiedPathInExpression is a\n+   * subclass of RangePatternBound? */\n+\n+public:\n+  RangePatternBoundQualPath (QualifiedPathInExpression path)\n+    : path (std::move (path))\n+  {}\n+\n+  std::string as_string () const override { return path.as_string (); }\n+\n+  Location get_locus () const { return path.get_locus (); }\n+\n+  void accept_vis (ASTVisitor &vis) override;\n+\n+  // TODO: this mutable getter seems kinda dodgy\n+  QualifiedPathInExpression &get_qualified_path () { return path; }\n+  const QualifiedPathInExpression &get_qualified_path () const { return path; }\n+\n+  RangePatternBoundType get_bound_type () const override\n+  {\n+    return RangePatternBoundType::QUALPATH;\n+  }\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  RangePatternBoundQualPath *clone_range_pattern_bound_impl () const override\n+  {\n+    return new RangePatternBoundQualPath (*this);\n+  }\n+};\n+\n+// AST node for matching within a certain range (range pattern)\n+class RangePattern : public Pattern\n+{\n+  std::unique_ptr<RangePatternBound> lower;\n+  std::unique_ptr<RangePatternBound> upper;\n+\n+  bool has_ellipsis_syntax;\n+\n+  /* location only stored to avoid a dereference - lower pattern should give\n+   * correct location so maybe change in future */\n+  Location locus;\n+  NodeId node_id;\n+\n+public:\n+  std::string as_string () const override;\n+\n+  // Constructor\n+  RangePattern (std::unique_ptr<RangePatternBound> lower,\n+\t\tstd::unique_ptr<RangePatternBound> upper, Location locus,\n+\t\tbool has_ellipsis_syntax = false)\n+    : lower (std::move (lower)), upper (std::move (upper)),\n+      has_ellipsis_syntax (has_ellipsis_syntax), locus (locus),\n+      node_id (Analysis::Mappings::get ()->get_next_node_id ())\n+  {}\n+\n+  // Copy constructor with clone\n+  RangePattern (RangePattern const &other)\n+    : lower (other.lower->clone_range_pattern_bound ()),\n+      upper (other.upper->clone_range_pattern_bound ()),\n+      has_ellipsis_syntax (other.has_ellipsis_syntax), locus (other.locus),\n+      node_id (other.node_id)\n+  {}\n+\n+  // Overloaded assignment operator to clone\n+  RangePattern &operator= (RangePattern const &other)\n+  {\n+    lower = other.lower->clone_range_pattern_bound ();\n+    upper = other.upper->clone_range_pattern_bound ();\n+    has_ellipsis_syntax = other.has_ellipsis_syntax;\n+    locus = other.locus;\n+    node_id = other.node_id;\n+\n+    return *this;\n+  }\n+\n+  // default move semantics\n+  RangePattern (RangePattern &&other) = default;\n+  RangePattern &operator= (RangePattern &&other) = default;\n+\n+  Location get_locus () const override final { return locus; }\n+\n+  void accept_vis (ASTVisitor &vis) override;\n+\n+  // TODO: is this better? or is a \"vis_bound\" better?\n+  std::unique_ptr<RangePatternBound> &get_lower_bound ()\n+  {\n+    rust_assert (lower != nullptr);\n+    return lower;\n+  }\n+\n+  std::unique_ptr<RangePatternBound> &get_upper_bound ()\n+  {\n+    rust_assert (upper != nullptr);\n+    return upper;\n+  }\n+\n+  NodeId get_node_id () const { return node_id; }\n+\n+  NodeId get_pattern_node_id () const override final { return node_id; }\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  RangePattern *clone_pattern_impl () const override\n+  {\n+    return new RangePattern (*this);\n+  }\n+};\n+\n+// AST node for pattern based on dereferencing the pointers given\n+class ReferencePattern : public Pattern\n+{\n+  bool has_two_amps;\n+  bool is_mut;\n+  std::unique_ptr<Pattern> pattern;\n+  Location locus;\n+  NodeId node_id;\n+\n+public:\n+  std::string as_string () const override;\n+\n+  ReferencePattern (std::unique_ptr<Pattern> pattern, bool is_mut_reference,\n+\t\t    bool ref_has_two_amps, Location locus)\n+    : has_two_amps (ref_has_two_amps), is_mut (is_mut_reference),\n+      pattern (std::move (pattern)), locus (locus),\n+      node_id (Analysis::Mappings::get ()->get_next_node_id ())\n+  {}\n+\n+  // Copy constructor requires clone\n+  ReferencePattern (ReferencePattern const &other)\n+    : has_two_amps (other.has_two_amps), is_mut (other.is_mut),\n+      pattern (other.pattern->clone_pattern ()), locus (other.locus),\n+      node_id (other.node_id)\n+  {}\n+\n+  // Overload assignment operator to clone\n+  ReferencePattern &operator= (ReferencePattern const &other)\n+  {\n+    pattern = other.pattern->clone_pattern ();\n+    is_mut = other.is_mut;\n+    has_two_amps = other.has_two_amps;\n+    locus = other.locus;\n+    node_id = other.node_id;\n+\n+    return *this;\n+  }\n+\n+  // default move semantics\n+  ReferencePattern (ReferencePattern &&other) = default;\n+  ReferencePattern &operator= (ReferencePattern &&other) = default;\n+\n+  Location get_locus () const override final { return locus; }\n+\n+  void accept_vis (ASTVisitor &vis) override;\n+\n+  // TODO: is this better? Or is a \"vis_pattern\" better?\n+  std::unique_ptr<Pattern> &get_referenced_pattern ()\n+  {\n+    rust_assert (pattern != nullptr);\n+    return pattern;\n+  }\n+\n+  NodeId get_node_id () const { return node_id; }\n+\n+  NodeId get_pattern_node_id () const override final { return node_id; }\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  ReferencePattern *clone_pattern_impl () const override\n+  {\n+    return new ReferencePattern (*this);\n+  }\n+};\n+\n+#if 0\n+// aka StructPatternEtCetera; potential element in struct pattern\n+struct StructPatternEtc\n+{\n+private:\n+  std::vector<Attribute> outer_attrs;\n+\n+  // should this store location data?\n+\n+public:\n+  StructPatternEtc (std::vector<Attribute> outer_attribs)\n+    : outer_attrs (std::move (outer_attribs))\n+  {}\n+\n+  // Creates an empty StructPatternEtc\n+  static StructPatternEtc create_empty ()\n+  {\n+    return StructPatternEtc (std::vector<Attribute> ());\n+  }\n+};\n+#endif\n+\n+// Base class for a single field in a struct pattern - abstract\n+class StructPatternField\n+{\n+  std::vector<Attribute> outer_attrs;\n+  Location locus;\n+\n+protected:\n+  NodeId node_id;\n+\n+public:\n+  enum ItemType\n+  {\n+    TUPLE_PAT,\n+    IDENT_PAT,\n+    IDENT\n+  };\n+\n+  virtual ~StructPatternField () {}\n+\n+  // Unique pointer custom clone function\n+  std::unique_ptr<StructPatternField> clone_struct_pattern_field () const\n+  {\n+    return std::unique_ptr<StructPatternField> (\n+      clone_struct_pattern_field_impl ());\n+  }\n+\n+  virtual std::string as_string () const;\n+\n+  Location get_locus () const { return locus; }\n+\n+  virtual void accept_vis (ASTVisitor &vis) = 0;\n+\n+  virtual void mark_for_strip () = 0;\n+  virtual bool is_marked_for_strip () const = 0;\n+  virtual ItemType get_item_type () const = 0;\n+\n+  NodeId get_node_id () const { return node_id; }\n+\n+  // TODO: seems kinda dodgy. Think of better way.\n+  std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n+  const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n+\n+protected:\n+  StructPatternField (std::vector<Attribute> outer_attribs, Location locus,\n+\t\t      NodeId node_id)\n+    : outer_attrs (std::move (outer_attribs)), locus (locus), node_id (node_id)\n+  {}\n+\n+  // Clone function implementation as pure virtual method\n+  virtual StructPatternField *clone_struct_pattern_field_impl () const = 0;\n+};\n+\n+// Tuple pattern single field in a struct pattern\n+class StructPatternFieldTuplePat : public StructPatternField\n+{\n+  TupleIndex index;\n+  std::unique_ptr<Pattern> tuple_pattern;\n+\n+public:\n+  StructPatternFieldTuplePat (TupleIndex index,\n+\t\t\t      std::unique_ptr<Pattern> tuple_pattern,\n+\t\t\t      std::vector<Attribute> outer_attribs,\n+\t\t\t      Location locus)\n+    : StructPatternField (std::move (outer_attribs), locus,\n+\t\t\t  Analysis::Mappings::get ()->get_next_node_id ()),\n+      index (index), tuple_pattern (std::move (tuple_pattern))\n+  {}\n+\n+  // Copy constructor requires clone\n+  StructPatternFieldTuplePat (StructPatternFieldTuplePat const &other)\n+    : StructPatternField (other), index (other.index)\n+  {\n+    // guard to prevent null dereference (only required if error state)\n+    node_id = other.get_node_id ();\n+    if (other.tuple_pattern != nullptr)\n+      tuple_pattern = other.tuple_pattern->clone_pattern ();\n+  }\n+\n+  // Overload assignment operator to perform clone\n+  StructPatternFieldTuplePat &\n+  operator= (StructPatternFieldTuplePat const &other)\n+  {\n+    StructPatternField::operator= (other);\n+    index = other.index;\n+    // outer_attrs = other.outer_attrs;\n+    node_id = other.get_node_id ();\n+\n+    // guard to prevent null dereference (only required if error state)\n+    if (other.tuple_pattern != nullptr)\n+      tuple_pattern = other.tuple_pattern->clone_pattern ();\n+    else\n+      tuple_pattern = nullptr;\n+\n+    return *this;\n+  }\n+\n+  // default move semantics\n+  StructPatternFieldTuplePat (StructPatternFieldTuplePat &&other) = default;\n+  StructPatternFieldTuplePat &operator= (StructPatternFieldTuplePat &&other)\n+    = default;\n+\n+  std::string as_string () const override;\n+\n+  void accept_vis (ASTVisitor &vis) override;\n+\n+  // based on idea of tuple pattern no longer existing\n+  void mark_for_strip () override { tuple_pattern = nullptr; }\n+  bool is_marked_for_strip () const override\n+  {\n+    return tuple_pattern == nullptr;\n+  }\n+\n+  // TODO: is this better? Or is a \"vis_pattern\" better?\n+  std::unique_ptr<Pattern> &get_index_pattern ()\n+  {\n+    rust_assert (tuple_pattern != nullptr);\n+    return tuple_pattern;\n+  }\n+\n+  ItemType get_item_type () const override final { return ItemType::TUPLE_PAT; }\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  StructPatternFieldTuplePat *clone_struct_pattern_field_impl () const override\n+  {\n+    return new StructPatternFieldTuplePat (*this);\n+  }\n+};\n+\n+// Identifier pattern single field in a struct pattern\n+class StructPatternFieldIdentPat : public StructPatternField\n+{\n+  Identifier ident;\n+  std::unique_ptr<Pattern> ident_pattern;\n+\n+public:\n+  StructPatternFieldIdentPat (Identifier ident,\n+\t\t\t      std::unique_ptr<Pattern> ident_pattern,\n+\t\t\t      std::vector<Attribute> outer_attrs,\n+\t\t\t      Location locus)\n+    : StructPatternField (std::move (outer_attrs), locus,\n+\t\t\t  Analysis::Mappings::get ()->get_next_node_id ()),\n+      ident (std::move (ident)), ident_pattern (std::move (ident_pattern))\n+  {}\n+\n+  // Copy constructor requires clone\n+  StructPatternFieldIdentPat (StructPatternFieldIdentPat const &other)\n+    : StructPatternField (other), ident (other.ident)\n+  {\n+    // guard to prevent null dereference (only required if error state)\n+    node_id = other.get_node_id ();\n+    if (other.ident_pattern != nullptr)\n+      ident_pattern = other.ident_pattern->clone_pattern ();\n+  }\n+\n+  // Overload assignment operator to clone\n+  StructPatternFieldIdentPat &\n+  operator= (StructPatternFieldIdentPat const &other)\n+  {\n+    StructPatternField::operator= (other);\n+    ident = other.ident;\n+    // outer_attrs = other.outer_attrs;\n+    node_id = other.get_node_id ();\n+\n+    // guard to prevent null dereference (only required if error state)\n+    if (other.ident_pattern != nullptr)\n+      ident_pattern = other.ident_pattern->clone_pattern ();\n+    else\n+      ident_pattern = nullptr;\n+\n+    return *this;\n+  }\n+\n+  // default move semantics\n+  StructPatternFieldIdentPat (StructPatternFieldIdentPat &&other) = default;\n+  StructPatternFieldIdentPat &operator= (StructPatternFieldIdentPat &&other)\n+    = default;\n+\n+  std::string as_string () const override;\n+\n+  void accept_vis (ASTVisitor &vis) override;\n+\n+  // based on idea of identifier pattern no longer existing\n+  void mark_for_strip () override { ident_pattern = nullptr; }\n+  bool is_marked_for_strip () const override\n+  {\n+    return ident_pattern == nullptr;\n+  }\n+\n+  const Identifier &get_identifier () const { return ident; }\n+\n+  // TODO: is this better? Or is a \"vis_pattern\" better?\n+  std::unique_ptr<Pattern> &get_ident_pattern ()\n+  {\n+    rust_assert (ident_pattern != nullptr);\n+    return ident_pattern;\n+  }\n+\n+  ItemType get_item_type () const override final { return ItemType::IDENT_PAT; }\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  StructPatternFieldIdentPat *clone_struct_pattern_field_impl () const override\n+  {\n+    return new StructPatternFieldIdentPat (*this);\n+  }\n+};\n+\n+// Identifier only (with no pattern) single field in a struct pattern\n+class StructPatternFieldIdent : public StructPatternField\n+{\n+  bool has_ref;\n+  bool has_mut;\n+  Identifier ident;\n+\n+public:\n+  StructPatternFieldIdent (Identifier ident, bool is_ref, bool is_mut,\n+\t\t\t   std::vector<Attribute> outer_attrs, Location locus)\n+    : StructPatternField (std::move (outer_attrs), locus,\n+\t\t\t  Analysis::Mappings::get ()->get_next_node_id ()),\n+      has_ref (is_ref), has_mut (is_mut), ident (std::move (ident))\n+  {}\n+\n+  std::string as_string () const override;\n+\n+  void accept_vis (ASTVisitor &vis) override;\n+\n+  // based on idea of identifier no longer existing\n+  void mark_for_strip () override { ident = {}; }\n+  bool is_marked_for_strip () const override { return ident.empty (); }\n+\n+  const Identifier &get_identifier () const { return ident; }\n+\n+  ItemType get_item_type () const override final { return ItemType::IDENT; }\n+\n+  bool is_ref () const { return has_ref; }\n+\n+  bool is_mut () const { return has_mut; }\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  StructPatternFieldIdent *clone_struct_pattern_field_impl () const override\n+  {\n+    return new StructPatternFieldIdent (*this);\n+  }\n+};\n+\n+// Elements of a struct pattern\n+struct StructPatternElements\n+{\n+private:\n+  // bool has_struct_pattern_fields;\n+  std::vector<std::unique_ptr<StructPatternField> > fields;\n+\n+  bool has_struct_pattern_etc;\n+  std::vector<Attribute> struct_pattern_etc_attrs;\n+  // StructPatternEtc etc;\n+\n+  // must have at least one of the two and maybe both\n+\n+  // should this store location data?\n+\n+public:\n+  // Returns whether there are any struct pattern fields\n+  bool has_struct_pattern_fields () const { return !fields.empty (); }\n+\n+  /* Returns whether the struct pattern elements is entirely empty (no fields,\n+   * no etc). */\n+  bool is_empty () const\n+  {\n+    return !has_struct_pattern_fields () && !has_struct_pattern_etc;\n+  }\n+\n+  bool has_etc () const { return has_struct_pattern_etc; }\n+\n+  // Constructor for StructPatternElements with both (potentially)\n+  StructPatternElements (\n+    std::vector<std::unique_ptr<StructPatternField> > fields,\n+    std::vector<Attribute> etc_attrs)\n+    : fields (std::move (fields)), has_struct_pattern_etc (true),\n+      struct_pattern_etc_attrs (std::move (etc_attrs))\n+  {}\n+\n+  // Constructor for StructPatternElements with no StructPatternEtc\n+  StructPatternElements (\n+    std::vector<std::unique_ptr<StructPatternField> > fields)\n+    : fields (std::move (fields)), has_struct_pattern_etc (false),\n+      struct_pattern_etc_attrs ()\n+  {}\n+\n+  // Copy constructor with vector clone\n+  StructPatternElements (StructPatternElements const &other)\n+    : has_struct_pattern_etc (other.has_struct_pattern_etc),\n+      struct_pattern_etc_attrs (other.struct_pattern_etc_attrs)\n+  {\n+    fields.reserve (other.fields.size ());\n+    for (const auto &e : other.fields)\n+      fields.push_back (e->clone_struct_pattern_field ());\n+  }\n+\n+  // Overloaded assignment operator with vector clone\n+  StructPatternElements &operator= (StructPatternElements const &other)\n+  {\n+    struct_pattern_etc_attrs = other.struct_pattern_etc_attrs;\n+    has_struct_pattern_etc = other.has_struct_pattern_etc;\n+\n+    fields.reserve (other.fields.size ());\n+    for (const auto &e : other.fields)\n+      fields.push_back (e->clone_struct_pattern_field ());\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  StructPatternElements (StructPatternElements &&other) = default;\n+  StructPatternElements &operator= (StructPatternElements &&other) = default;\n+\n+  // Creates an empty StructPatternElements\n+  static StructPatternElements create_empty ()\n+  {\n+    return StructPatternElements (\n+      std::vector<std::unique_ptr<StructPatternField> > ());\n+  }\n+\n+  std::string as_string () const;\n+\n+  // TODO: seems kinda dodgy. Think of better way.\n+  std::vector<std::unique_ptr<StructPatternField> > &\n+  get_struct_pattern_fields ()\n+  {\n+    return fields;\n+  }\n+  const std::vector<std::unique_ptr<StructPatternField> > &\n+  get_struct_pattern_fields () const\n+  {\n+    return fields;\n+  }\n+\n+  std::vector<Attribute> &get_etc_outer_attrs ()\n+  {\n+    return struct_pattern_etc_attrs;\n+  }\n+  const std::vector<Attribute> &get_etc_outer_attrs () const\n+  {\n+    return struct_pattern_etc_attrs;\n+  }\n+\n+  void strip_etc ()\n+  {\n+    has_struct_pattern_etc = false;\n+    struct_pattern_etc_attrs.clear ();\n+    struct_pattern_etc_attrs.shrink_to_fit ();\n+  }\n+};\n+\n+// Struct pattern AST node representation\n+class StructPattern : public Pattern\n+{\n+  PathInExpression path;\n+\n+  // bool has_struct_pattern_elements;\n+  StructPatternElements elems;\n+\n+  NodeId node_id;\n+  Location locus;\n+\n+public:\n+  std::string as_string () const override;\n+\n+  // Constructs a struct pattern from specified StructPatternElements\n+  StructPattern (PathInExpression struct_path, Location locus,\n+\t\t StructPatternElements elems\n+\t\t = StructPatternElements::create_empty ())\n+    : path (std::move (struct_path)), elems (std::move (elems)),\n+      node_id (Analysis::Mappings::get ()->get_next_node_id ()), locus (locus)\n+  {}\n+\n+  /* TODO: constructor to construct via elements included in\n+   * StructPatternElements */\n+\n+  /* Returns whether struct pattern has any struct pattern elements (if not, it\n+   * is empty). */\n+  bool has_struct_pattern_elems () const { return !elems.is_empty (); }\n+\n+  Location get_locus () const { return path.get_locus (); }\n+\n+  void accept_vis (ASTVisitor &vis) override;\n+\n+  // TODO: seems kinda dodgy. Think of better way.\n+  StructPatternElements &get_struct_pattern_elems () { return elems; }\n+  const StructPatternElements &get_struct_pattern_elems () const\n+  {\n+    return elems;\n+  }\n+\n+  PathInExpression &get_path () { return path; }\n+  const PathInExpression &get_path () const { return path; }\n+\n+  NodeId get_node_id () const { return node_id; }\n+\n+  NodeId get_pattern_node_id () const override final { return node_id; }\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  StructPattern *clone_pattern_impl () const override\n+  {\n+    return new StructPattern (*this);\n+  }\n+};\n+\n+// Base abstract class for patterns used in TupleStructPattern\n+class TupleStructItems\n+{\n+public:\n+  enum ItemType\n+  {\n+    RANGE,\n+    NO_RANGE\n+  };\n+\n+  virtual ~TupleStructItems () {}\n+\n+  // TODO: should this store location data?\n+\n+  // Unique pointer custom clone function\n+  std::unique_ptr<TupleStructItems> clone_tuple_struct_items () const\n+  {\n+    return std::unique_ptr<TupleStructItems> (clone_tuple_struct_items_impl ());\n+  }\n+\n+  virtual std::string as_string () const = 0;\n+\n+  virtual void accept_vis (ASTVisitor &vis) = 0;\n+\n+  virtual ItemType get_item_type () const = 0;\n+\n+protected:\n+  // pure virtual clone implementation\n+  virtual TupleStructItems *clone_tuple_struct_items_impl () const = 0;\n+};\n+\n+// Class for non-ranged tuple struct pattern patterns\n+class TupleStructItemsNoRange : public TupleStructItems\n+{\n+  std::vector<std::unique_ptr<Pattern> > patterns;\n+\n+public:\n+  TupleStructItemsNoRange (std::vector<std::unique_ptr<Pattern> > patterns)\n+    : patterns (std::move (patterns))\n+  {}\n+\n+  // Copy constructor with vector clone\n+  TupleStructItemsNoRange (TupleStructItemsNoRange const &other)\n+  {\n+    patterns.reserve (other.patterns.size ());\n+    for (const auto &e : other.patterns)\n+      patterns.push_back (e->clone_pattern ());\n+  }\n+\n+  // Overloaded assignment operator with vector clone\n+  TupleStructItemsNoRange &operator= (TupleStructItemsNoRange const &other)\n+  {\n+    patterns.reserve (other.patterns.size ());\n+    for (const auto &e : other.patterns)\n+      patterns.push_back (e->clone_pattern ());\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  TupleStructItemsNoRange (TupleStructItemsNoRange &&other) = default;\n+  TupleStructItemsNoRange &operator= (TupleStructItemsNoRange &&other)\n+    = default;\n+\n+  std::string as_string () const override;\n+\n+  void accept_vis (ASTVisitor &vis) override;\n+\n+  // TODO: seems kinda dodgy. Think of better way.\n+  std::vector<std::unique_ptr<Pattern> > &get_patterns () { return patterns; }\n+  const std::vector<std::unique_ptr<Pattern> > &get_patterns () const\n+  {\n+    return patterns;\n+  }\n+\n+  ItemType get_item_type () const override final { return ItemType::NO_RANGE; }\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  TupleStructItemsNoRange *clone_tuple_struct_items_impl () const override\n+  {\n+    return new TupleStructItemsNoRange (*this);\n+  }\n+};\n+\n+// Class for ranged tuple struct pattern patterns\n+class TupleStructItemsRange : public TupleStructItems\n+{\n+  std::vector<std::unique_ptr<Pattern> > lower_patterns;\n+  std::vector<std::unique_ptr<Pattern> > upper_patterns;\n+\n+public:\n+  TupleStructItemsRange (std::vector<std::unique_ptr<Pattern> > lower_patterns,\n+\t\t\t std::vector<std::unique_ptr<Pattern> > upper_patterns)\n+    : lower_patterns (std::move (lower_patterns)),\n+      upper_patterns (std::move (upper_patterns))\n+  {}\n+\n+  // Copy constructor with vector clone\n+  TupleStructItemsRange (TupleStructItemsRange const &other)\n+  {\n+    lower_patterns.reserve (other.lower_patterns.size ());\n+    for (const auto &e : other.lower_patterns)\n+      lower_patterns.push_back (e->clone_pattern ());\n+\n+    upper_patterns.reserve (other.upper_patterns.size ());\n+    for (const auto &e : other.upper_patterns)\n+      upper_patterns.push_back (e->clone_pattern ());\n+  }\n+\n+  // Overloaded assignment operator to clone\n+  TupleStructItemsRange &operator= (TupleStructItemsRange const &other)\n+  {\n+    lower_patterns.reserve (other.lower_patterns.size ());\n+    for (const auto &e : other.lower_patterns)\n+      lower_patterns.push_back (e->clone_pattern ());\n+\n+    upper_patterns.reserve (other.upper_patterns.size ());\n+    for (const auto &e : other.upper_patterns)\n+      upper_patterns.push_back (e->clone_pattern ());\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  TupleStructItemsRange (TupleStructItemsRange &&other) = default;\n+  TupleStructItemsRange &operator= (TupleStructItemsRange &&other) = default;\n+\n+  std::string as_string () const override;\n+\n+  void accept_vis (ASTVisitor &vis) override;\n+\n+  // TODO: seems kinda dodgy. Think of better way.\n+  std::vector<std::unique_ptr<Pattern> > &get_lower_patterns ()\n+  {\n+    return lower_patterns;\n+  }\n+  const std::vector<std::unique_ptr<Pattern> > &get_lower_patterns () const\n+  {\n+    return lower_patterns;\n+  }\n+\n+  // TODO: seems kinda dodgy. Think of better way.\n+  std::vector<std::unique_ptr<Pattern> > &get_upper_patterns ()\n+  {\n+    return upper_patterns;\n+  }\n+  const std::vector<std::unique_ptr<Pattern> > &get_upper_patterns () const\n+  {\n+    return upper_patterns;\n+  }\n+\n+  ItemType get_item_type () const override final { return ItemType::RANGE; }\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  TupleStructItemsRange *clone_tuple_struct_items_impl () const override\n+  {\n+    return new TupleStructItemsRange (*this);\n+  }\n+};\n+\n+// AST node representing a tuple struct pattern\n+class TupleStructPattern : public Pattern\n+{\n+  PathInExpression path;\n+  std::unique_ptr<TupleStructItems> items;\n+  NodeId node_id;\n+\n+  /* TOOD: should this store location data? current accessor uses path location\n+   * data */\n+\n+public:\n+  std::string as_string () const override;\n+\n+  // Returns whether the pattern has tuple struct items.\n+  bool has_items () const { return items != nullptr; }\n+\n+  TupleStructPattern (PathInExpression tuple_struct_path,\n+\t\t      std::unique_ptr<TupleStructItems> items)\n+    : path (std::move (tuple_struct_path)), items (std::move (items)),\n+      node_id (Analysis::Mappings::get ()->get_next_node_id ())\n+  {}\n+\n+  // Copy constructor required to clone\n+  TupleStructPattern (TupleStructPattern const &other) : path (other.path)\n+  {\n+    // guard to protect from null dereference\n+    node_id = other.node_id;\n+    if (other.items != nullptr)\n+      items = other.items->clone_tuple_struct_items ();\n+  }\n+\n+  // Operator overload assignment operator to clone\n+  TupleStructPattern &operator= (TupleStructPattern const &other)\n+  {\n+    path = other.path;\n+    node_id = other.node_id;\n+\n+    // guard to protect from null dereference\n+    if (other.items != nullptr)\n+      items = other.items->clone_tuple_struct_items ();\n+    else\n+      items = nullptr;\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  TupleStructPattern (TupleStructPattern &&other) = default;\n+  TupleStructPattern &operator= (TupleStructPattern &&other) = default;\n+\n+  Location get_locus () const override { return path.get_locus (); }\n+\n+  void accept_vis (ASTVisitor &vis) override;\n+\n+  // TODO: seems kinda dodgy. Think of better way.\n+  std::unique_ptr<TupleStructItems> &get_items ()\n+  {\n+    rust_assert (has_items ());\n+    return items;\n+  }\n+\n+  PathInExpression &get_path () { return path; }\n+  const PathInExpression &get_path () const { return path; }\n+\n+  NodeId get_node_id () const { return node_id; }\n+\n+  NodeId get_pattern_node_id () const override final { return node_id; }\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  TupleStructPattern *clone_pattern_impl () const override\n+  {\n+    return new TupleStructPattern (*this);\n+  }\n+};\n+\n+// Base abstract class representing TuplePattern patterns\n+class TuplePatternItems\n+{\n+public:\n+  enum TuplePatternItemType\n+  {\n+    MULTIPLE,\n+    RANGED,\n+  };\n+\n+  virtual ~TuplePatternItems () {}\n+\n+  // TODO: should this store location data?\n+\n+  // Unique pointer custom clone function\n+  std::unique_ptr<TuplePatternItems> clone_tuple_pattern_items () const\n+  {\n+    return std::unique_ptr<TuplePatternItems> (\n+      clone_tuple_pattern_items_impl ());\n+  }\n+\n+  virtual std::string as_string () const = 0;\n+\n+  virtual void accept_vis (ASTVisitor &vis) = 0;\n+\n+  virtual TuplePatternItemType get_pattern_type () const = 0;\n+\n+protected:\n+  // pure virtual clone implementation\n+  virtual TuplePatternItems *clone_tuple_pattern_items_impl () const = 0;\n+};\n+\n+// Class representing TuplePattern patterns where there is only a single pattern\n+/*class TuplePatternItemsSingle : public TuplePatternItems {\n+    // Pattern pattern;\n+    std::unique_ptr<Pattern> pattern;\n+\n+  public:\n+    TuplePatternItemsSingle(Pattern* pattern) : pattern(pattern) {}\n+\n+    // Copy constructor uses clone\n+    TuplePatternItemsSingle(TuplePatternItemsSingle const& other) :\n+      pattern(other.pattern->clone_pattern()) {}\n+\n+    // Destructor - define here if required\n+\n+    // Overload assignment operator to clone\n+    TuplePatternItemsSingle& operator=(TuplePatternItemsSingle const& other) {\n+\tpattern = other.pattern->clone_pattern();\n+\n+\treturn *this;\n+    }\n+\n+    // move constructors\n+    TuplePatternItemsSingle(TuplePatternItemsSingle&& other) = default;\n+    TuplePatternItemsSingle& operator=(TuplePatternItemsSingle&& other) =\n+default;\n+\n+  protected:\n+    // Use covariance to implement clone function as returning this object\n+rather than base virtual TuplePatternItemsSingle*\n+clone_tuple_pattern_items_impl() const override { return new\n+TuplePatternItemsSingle(*this);\n+    }\n+};*/\n+// removed in favour of single-element TuplePatternItemsMultiple\n+\n+// Class representing TuplePattern patterns where there are multiple patterns\n+class TuplePatternItemsMultiple : public TuplePatternItems\n+{\n+  std::vector<std::unique_ptr<Pattern> > patterns;\n+\n+public:\n+  TuplePatternItemsMultiple (std::vector<std::unique_ptr<Pattern> > patterns)\n+    : patterns (std::move (patterns))\n+  {}\n+\n+  // Copy constructor with vector clone\n+  TuplePatternItemsMultiple (TuplePatternItemsMultiple const &other)\n+  {\n+    patterns.reserve (other.patterns.size ());\n+    for (const auto &e : other.patterns)\n+      patterns.push_back (e->clone_pattern ());\n+  }\n+\n+  // Overloaded assignment operator to vector clone\n+  TuplePatternItemsMultiple &operator= (TuplePatternItemsMultiple const &other)\n+  {\n+    patterns.reserve (other.patterns.size ());\n+    for (const auto &e : other.patterns)\n+      patterns.push_back (e->clone_pattern ());\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  TuplePatternItemsMultiple (TuplePatternItemsMultiple &&other) = default;\n+  TuplePatternItemsMultiple &operator= (TuplePatternItemsMultiple &&other)\n+    = default;\n+\n+  std::string as_string () const override;\n+\n+  void accept_vis (ASTVisitor &vis) override;\n+\n+  // TODO: seems kinda dodgy. Think of better way.\n+  std::vector<std::unique_ptr<Pattern> > &get_patterns () { return patterns; }\n+  const std::vector<std::unique_ptr<Pattern> > &get_patterns () const\n+  {\n+    return patterns;\n+  }\n+\n+  TuplePatternItemType get_pattern_type () const override\n+  {\n+    return TuplePatternItemType::MULTIPLE;\n+  }\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  TuplePatternItemsMultiple *clone_tuple_pattern_items_impl () const override\n+  {\n+    return new TuplePatternItemsMultiple (*this);\n+  }\n+};\n+\n+// Class representing TuplePattern patterns where there are a range of patterns\n+class TuplePatternItemsRanged : public TuplePatternItems\n+{\n+  std::vector<std::unique_ptr<Pattern> > lower_patterns;\n+  std::vector<std::unique_ptr<Pattern> > upper_patterns;\n+\n+public:\n+  TuplePatternItemsRanged (\n+    std::vector<std::unique_ptr<Pattern> > lower_patterns,\n+    std::vector<std::unique_ptr<Pattern> > upper_patterns)\n+    : lower_patterns (std::move (lower_patterns)),\n+      upper_patterns (std::move (upper_patterns))\n+  {}\n+\n+  // Copy constructor with vector clone\n+  TuplePatternItemsRanged (TuplePatternItemsRanged const &other)\n+  {\n+    lower_patterns.reserve (other.lower_patterns.size ());\n+    for (const auto &e : other.lower_patterns)\n+      lower_patterns.push_back (e->clone_pattern ());\n+\n+    upper_patterns.reserve (other.upper_patterns.size ());\n+    for (const auto &e : other.upper_patterns)\n+      upper_patterns.push_back (e->clone_pattern ());\n+  }\n+\n+  // Overloaded assignment operator to clone\n+  TuplePatternItemsRanged &operator= (TuplePatternItemsRanged const &other)\n+  {\n+    lower_patterns.reserve (other.lower_patterns.size ());\n+    for (const auto &e : other.lower_patterns)\n+      lower_patterns.push_back (e->clone_pattern ());\n+\n+    upper_patterns.reserve (other.upper_patterns.size ());\n+    for (const auto &e : other.upper_patterns)\n+      upper_patterns.push_back (e->clone_pattern ());\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  TuplePatternItemsRanged (TuplePatternItemsRanged &&other) = default;\n+  TuplePatternItemsRanged &operator= (TuplePatternItemsRanged &&other)\n+    = default;\n+\n+  std::string as_string () const override;\n+\n+  void accept_vis (ASTVisitor &vis) override;\n+\n+  // TODO: seems kinda dodgy. Think of better way.\n+  std::vector<std::unique_ptr<Pattern> > &get_lower_patterns ()\n+  {\n+    return lower_patterns;\n+  }\n+  const std::vector<std::unique_ptr<Pattern> > &get_lower_patterns () const\n+  {\n+    return lower_patterns;\n+  }\n+\n+  // TODO: seems kinda dodgy. Think of better way.\n+  std::vector<std::unique_ptr<Pattern> > &get_upper_patterns ()\n+  {\n+    return upper_patterns;\n+  }\n+  const std::vector<std::unique_ptr<Pattern> > &get_upper_patterns () const\n+  {\n+    return upper_patterns;\n+  }\n+\n+  TuplePatternItemType get_pattern_type () const override\n+  {\n+    return TuplePatternItemType::RANGED;\n+  }\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  TuplePatternItemsRanged *clone_tuple_pattern_items_impl () const override\n+  {\n+    return new TuplePatternItemsRanged (*this);\n+  }\n+};\n+\n+// AST node representing a tuple pattern\n+class TuplePattern : public Pattern\n+{\n+  // bool has_tuple_pattern_items;\n+  std::unique_ptr<TuplePatternItems> items;\n+  Location locus;\n+  NodeId node_id;\n+\n+public:\n+  std::string as_string () const override;\n+\n+  // Returns true if the tuple pattern has items\n+  bool has_tuple_pattern_items () const { return items != nullptr; }\n+\n+  TuplePattern (std::unique_ptr<TuplePatternItems> items, Location locus)\n+    : items (std::move (items)), locus (locus),\n+      node_id (Analysis::Mappings::get ()->get_next_node_id ())\n+  {}\n+\n+  // Copy constructor requires clone\n+  TuplePattern (TuplePattern const &other) : locus (other.locus)\n+  {\n+    // guard to prevent null dereference\n+    node_id = other.node_id;\n+    if (other.items != nullptr)\n+      items = other.items->clone_tuple_pattern_items ();\n+  }\n+\n+  // Overload assignment operator to clone\n+  TuplePattern &operator= (TuplePattern const &other)\n+  {\n+    locus = other.locus;\n+    node_id = other.node_id;\n+\n+    // guard to prevent null dereference\n+    if (other.items != nullptr)\n+      items = other.items->clone_tuple_pattern_items ();\n+    else\n+      items = nullptr;\n+\n+    return *this;\n+  }\n+\n+  Location get_locus () const override final { return locus; }\n+\n+  void accept_vis (ASTVisitor &vis) override;\n+\n+  // TODO: seems kinda dodgy. Think of better way.\n+  std::unique_ptr<TuplePatternItems> &get_items ()\n+  {\n+    rust_assert (has_tuple_pattern_items ());\n+    return items;\n+  }\n+\n+  NodeId get_node_id () const { return node_id; }\n+\n+  NodeId get_pattern_node_id () const override final { return node_id; }\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  TuplePattern *clone_pattern_impl () const override\n+  {\n+    return new TuplePattern (*this);\n+  }\n+};\n+\n+// AST node representing a pattern in parentheses, used to control precedence\n+class GroupedPattern : public Pattern\n+{\n+  std::unique_ptr<Pattern> pattern_in_parens;\n+  Location locus;\n+  NodeId node_id;\n+\n+public:\n+  std::string as_string () const override\n+  {\n+    return \"(\" + pattern_in_parens->as_string () + \")\";\n+  }\n+\n+  GroupedPattern (std::unique_ptr<Pattern> pattern_in_parens, Location locus)\n+    : pattern_in_parens (std::move (pattern_in_parens)), locus (locus),\n+      node_id (Analysis::Mappings::get ()->get_next_node_id ())\n+  {}\n+\n+  // Copy constructor uses clone\n+  GroupedPattern (GroupedPattern const &other)\n+    : pattern_in_parens (other.pattern_in_parens->clone_pattern ()),\n+      locus (other.locus), node_id (other.node_id)\n+  {}\n+\n+  // Overload assignment operator to clone\n+  GroupedPattern &operator= (GroupedPattern const &other)\n+  {\n+    pattern_in_parens = other.pattern_in_parens->clone_pattern ();\n+    locus = other.locus;\n+    node_id = other.node_id;\n+\n+    return *this;\n+  }\n+\n+  // default move semantics\n+  GroupedPattern (GroupedPattern &&other) = default;\n+  GroupedPattern &operator= (GroupedPattern &&other) = default;\n+\n+  Location get_locus () const override final { return locus; }\n+\n+  void accept_vis (ASTVisitor &vis) override;\n+\n+  // TODO: seems kinda dodgy. Think of better way.\n+  std::unique_ptr<Pattern> &get_pattern_in_parens ()\n+  {\n+    rust_assert (pattern_in_parens != nullptr);\n+    return pattern_in_parens;\n+  }\n+\n+  NodeId get_node_id () const { return node_id; }\n+\n+  NodeId get_pattern_node_id () const override final { return node_id; }\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  GroupedPattern *clone_pattern_impl () const override\n+  {\n+    return new GroupedPattern (*this);\n+  }\n+};\n+\n+// AST node representing patterns that can match slices and arrays\n+class SlicePattern : public Pattern\n+{\n+  std::vector<std::unique_ptr<Pattern> > items;\n+  Location locus;\n+  NodeId node_id;\n+\n+public:\n+  std::string as_string () const override;\n+\n+  SlicePattern (std::vector<std::unique_ptr<Pattern> > items, Location locus)\n+    : items (std::move (items)), locus (locus),\n+      node_id (Analysis::Mappings::get ()->get_next_node_id ())\n+  {}\n+\n+  // Copy constructor with vector clone\n+  SlicePattern (SlicePattern const &other) : locus (other.locus)\n+  {\n+    node_id = other.node_id;\n+    items.reserve (other.items.size ());\n+    for (const auto &e : other.items)\n+      items.push_back (e->clone_pattern ());\n+  }\n+\n+  // Overloaded assignment operator to vector clone\n+  SlicePattern &operator= (SlicePattern const &other)\n+  {\n+    locus = other.locus;\n+    node_id = other.node_id;\n+\n+    items.reserve (other.items.size ());\n+    for (const auto &e : other.items)\n+      items.push_back (e->clone_pattern ());\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  SlicePattern (SlicePattern &&other) = default;\n+  SlicePattern &operator= (SlicePattern &&other) = default;\n+\n+  Location get_locus () const override final { return locus; }\n+\n+  void accept_vis (ASTVisitor &vis) override;\n+\n+  // TODO: seems kinda dodgy. Think of better way.\n+  std::vector<std::unique_ptr<Pattern> > &get_items () { return items; }\n+  const std::vector<std::unique_ptr<Pattern> > &get_items () const\n+  {\n+    return items;\n+  }\n+\n+  NodeId get_node_id () const { return node_id; }\n+\n+  NodeId get_pattern_node_id () const override final { return node_id; }\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  SlicePattern *clone_pattern_impl () const override\n+  {\n+    return new SlicePattern (*this);\n+  }\n+};\n+\n+// Moved definition to rust-path.h\n+class PathPattern;\n+\n+// Forward decls for paths (defined in rust-path.h)\n+class PathInExpression;\n+class QualifiedPathInExpression;\n+\n+// Replaced with forward decl - defined in rust-macro.h\n+class MacroInvocation;\n+} // namespace AST\n+} // namespace Rust\n+\n+#endif"}, {"sha": "9d95c3e27e8814fd9c973f523486ccc436c1a4ad", "filename": "gcc/rust/ast/rust-stmt.h", "status": "added", "additions": 358, "deletions": 0, "changes": 358, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d588754c8266d74c9eef1e38d2d96e66ff876107/gcc%2Frust%2Fast%2Frust-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d588754c8266d74c9eef1e38d2d96e66ff876107/gcc%2Frust%2Fast%2Frust-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-stmt.h?ref=d588754c8266d74c9eef1e38d2d96e66ff876107", "patch": "@@ -0,0 +1,358 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_AST_STATEMENT_H\n+#define RUST_AST_STATEMENT_H\n+\n+#include \"rust-ast.h\"\n+#include \"rust-path.h\"\n+#include \"rust-expr.h\"\n+\n+namespace Rust {\n+namespace AST {\n+// Just a semi-colon, which apparently is a statement.\n+class EmptyStmt : public Stmt\n+{\n+  Location locus;\n+\n+  // TODO: find another way to store this to save memory?\n+  bool marked_for_strip = false;\n+\n+public:\n+  std::string as_string () const override { return std::string (1, ';'); }\n+\n+  EmptyStmt (Location locus) : locus (locus) {}\n+\n+  Location get_locus () const override final { return locus; }\n+\n+  void accept_vis (ASTVisitor &vis) override;\n+\n+  // Can't think of any invalid invariants, so store boolean.\n+  void mark_for_strip () override { marked_for_strip = true; }\n+  bool is_marked_for_strip () const override { return marked_for_strip; }\n+\n+  bool is_item () const override final { return false; }\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  EmptyStmt *clone_stmt_impl () const override { return new EmptyStmt (*this); }\n+};\n+\n+/* Variable assignment let statement - type of \"declaration statement\" as it\n+ * introduces new name into scope */\n+class LetStmt : public Stmt\n+{\n+  // bool has_outer_attrs;\n+  std::vector<Attribute> outer_attrs;\n+\n+  std::unique_ptr<Pattern> variables_pattern;\n+\n+  // bool has_type;\n+  std::unique_ptr<Type> type;\n+\n+  // bool has_init_expr;\n+  std::unique_ptr<Expr> init_expr;\n+\n+  Location locus;\n+\n+public:\n+  Type *inferedType;\n+\n+  // Returns whether let statement has outer attributes.\n+  bool has_outer_attrs () const { return !outer_attrs.empty (); }\n+\n+  // Returns whether let statement has a given return type.\n+  bool has_type () const { return type != nullptr; }\n+\n+  // Returns whether let statement has an initialisation expression.\n+  bool has_init_expr () const { return init_expr != nullptr; }\n+\n+  std::string as_string () const override;\n+\n+  LetStmt (std::unique_ptr<Pattern> variables_pattern,\n+\t   std::unique_ptr<Expr> init_expr, std::unique_ptr<Type> type,\n+\t   std::vector<Attribute> outer_attrs, Location locus)\n+    : outer_attrs (std::move (outer_attrs)),\n+      variables_pattern (std::move (variables_pattern)),\n+      type (std::move (type)), init_expr (std::move (init_expr)), locus (locus)\n+  {}\n+\n+  // Copy constructor with clone\n+  LetStmt (LetStmt const &other)\n+    : outer_attrs (other.outer_attrs), locus (other.locus)\n+  {\n+    // guard to prevent null dereference (only required if error state)\n+    if (other.variables_pattern != nullptr)\n+      variables_pattern = other.variables_pattern->clone_pattern ();\n+\n+    // guard to prevent null dereference (always required)\n+    if (other.init_expr != nullptr)\n+      init_expr = other.init_expr->clone_expr ();\n+    if (other.type != nullptr)\n+      type = other.type->clone_type ();\n+  }\n+\n+  // Overloaded assignment operator to clone\n+  LetStmt &operator= (LetStmt const &other)\n+  {\n+    outer_attrs = other.outer_attrs;\n+    locus = other.locus;\n+\n+    // guard to prevent null dereference (only required if error state)\n+    if (other.variables_pattern != nullptr)\n+      variables_pattern = other.variables_pattern->clone_pattern ();\n+    else\n+      variables_pattern = nullptr;\n+\n+    // guard to prevent null dereference (always required)\n+    if (other.init_expr != nullptr)\n+      init_expr = other.init_expr->clone_expr ();\n+    else\n+      init_expr = nullptr;\n+    if (other.type != nullptr)\n+      type = other.type->clone_type ();\n+    else\n+      type = nullptr;\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  LetStmt (LetStmt &&other) = default;\n+  LetStmt &operator= (LetStmt &&other) = default;\n+\n+  Location get_locus () const override final { return locus; }\n+\n+  void accept_vis (ASTVisitor &vis) override;\n+\n+  // Invalid if pattern is null, so base stripping on that.\n+  void mark_for_strip () override { variables_pattern = nullptr; }\n+  bool is_marked_for_strip () const override\n+  {\n+    return variables_pattern == nullptr;\n+  }\n+\n+  // TODO: this mutable getter seems really dodgy. Think up better way.\n+  std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n+  const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n+\n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  std::unique_ptr<Expr> &get_init_expr ()\n+  {\n+    rust_assert (has_init_expr ());\n+    return init_expr;\n+  }\n+\n+  std::unique_ptr<Pattern> &get_pattern ()\n+  {\n+    rust_assert (variables_pattern != nullptr);\n+    return variables_pattern;\n+  }\n+\n+  std::unique_ptr<Type> &get_type ()\n+  {\n+    rust_assert (has_type ());\n+    return type;\n+  }\n+\n+  bool is_item () const override final { return false; }\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  LetStmt *clone_stmt_impl () const override { return new LetStmt (*this); }\n+};\n+\n+/* Abstract base class for expression statements (statements containing an\n+ * expression) */\n+class ExprStmt : public Stmt\n+{\n+public:\n+  enum ExprStmtType\n+  {\n+    WITH_BLOCK,\n+    WITHOUT_BLOCK\n+  };\n+\n+protected:\n+  Location locus;\n+\n+public:\n+  Location get_locus () const override final { return locus; }\n+\n+  bool is_item () const override final { return false; }\n+\n+  virtual ExprStmtType get_type () const = 0;\n+\n+protected:\n+  ExprStmt (Location locus) : locus (locus) {}\n+};\n+\n+/* Statement containing an expression without a block (or, due to technical\n+ * difficulties, can only be guaranteed to hold an expression). */\n+class ExprStmtWithoutBlock : public ExprStmt\n+{\n+  // TODO: ensure that this works\n+  std::unique_ptr<ExprWithoutBlock> expr;\n+  /* HACK: cannot ensure type safety of ExprWithoutBlock due to Pratt parsing,\n+   * so have to store more general type of Expr. FIXME: fix this issue somehow\n+   * or redesign AST. */\n+  // std::unique_ptr<Expr> expr;\n+\n+public:\n+  std::string as_string () const override;\n+\n+  ExprStmtWithoutBlock (std::unique_ptr<ExprWithoutBlock> expr, Location locus)\n+    : ExprStmt (locus), expr (std::move (expr->to_stmt ()))\n+  {}\n+\n+  /*ExprStmtWithoutBlock (std::unique_ptr<Expr> expr, Location locus)\n+    : ExprStmt (locus), expr (std::move (expr))\n+  {}*/\n+\n+  // Copy constructor with clone\n+  ExprStmtWithoutBlock (ExprStmtWithoutBlock const &other) : ExprStmt (other)\n+  {\n+    // guard to prevent null dereference (only required if error state)\n+    if (other.expr != nullptr)\n+      expr = other.expr->clone_expr_without_block ();\n+  }\n+  /*ExprStmtWithoutBlock (ExprStmtWithoutBlock const &other)\n+    : ExprStmt (other), expr (other.expr->clone_expr ())\n+  {}*/\n+\n+  // Overloaded assignment operator to clone\n+  ExprStmtWithoutBlock &operator= (ExprStmtWithoutBlock const &other)\n+  {\n+    ExprStmt::operator= (other);\n+    // expr = other.expr->clone_expr ();\n+\n+    // guard to prevent null dereference (only required if error state)\n+    if (other.expr != nullptr)\n+      expr = other.expr->clone_expr_without_block ();\n+    else\n+      expr = nullptr;\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  ExprStmtWithoutBlock (ExprStmtWithoutBlock &&other) = default;\n+  ExprStmtWithoutBlock &operator= (ExprStmtWithoutBlock &&other) = default;\n+\n+  void accept_vis (ASTVisitor &vis) override;\n+\n+  // Invalid if expr is null, so base stripping on that.\n+  void mark_for_strip () override { expr = nullptr; }\n+  bool is_marked_for_strip () const override { return expr == nullptr; }\n+\n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  std::unique_ptr<ExprWithoutBlock> &get_expr ()\n+  {\n+    rust_assert (expr != nullptr);\n+    return expr;\n+  }\n+\n+  ExprStmtType get_type () const override\n+  {\n+    return ExprStmtType::WITHOUT_BLOCK;\n+  };\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  ExprStmtWithoutBlock *clone_stmt_impl () const override\n+  {\n+    return new ExprStmtWithoutBlock (*this);\n+  }\n+};\n+\n+// Statement containing an expression with a block\n+class ExprStmtWithBlock : public ExprStmt\n+{\n+  std::unique_ptr<ExprWithBlock> expr;\n+  bool semicolon_followed;\n+\n+public:\n+  std::string as_string () const override;\n+\n+  std::vector<LetStmt *> locals;\n+\n+  ExprStmtWithBlock (std::unique_ptr<ExprWithBlock> expr, Location locus,\n+\t\t     bool semicolon_followed)\n+    : ExprStmt (locus), expr (std::move (expr)),\n+      semicolon_followed (semicolon_followed)\n+  {}\n+\n+  // Copy constructor with clone\n+  ExprStmtWithBlock (ExprStmtWithBlock const &other) : ExprStmt (other)\n+  {\n+    // guard to prevent null dereference (only required if error state)\n+    if (other.expr != nullptr)\n+      expr = other.expr->clone_expr_with_block ();\n+  }\n+\n+  // Overloaded assignment operator to clone\n+  ExprStmtWithBlock &operator= (ExprStmtWithBlock const &other)\n+  {\n+    ExprStmt::operator= (other);\n+\n+    // guard to prevent null dereference (only required if error state)\n+    if (other.expr != nullptr)\n+      expr = other.expr->clone_expr_with_block ();\n+    else\n+      expr = nullptr;\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  ExprStmtWithBlock (ExprStmtWithBlock &&other) = default;\n+  ExprStmtWithBlock &operator= (ExprStmtWithBlock &&other) = default;\n+\n+  void accept_vis (ASTVisitor &vis) override;\n+\n+  // Invalid if expr is null, so base stripping on that.\n+  void mark_for_strip () override { expr = nullptr; }\n+  bool is_marked_for_strip () const override { return expr == nullptr; }\n+\n+  // TODO: is this better? Or is a \"vis_block\" better?\n+  std::unique_ptr<ExprWithBlock> &get_expr ()\n+  {\n+    rust_assert (expr != nullptr);\n+    return expr;\n+  }\n+\n+  bool is_semicolon_followed () const { return semicolon_followed; }\n+\n+  ExprStmtType get_type () const override { return ExprStmtType::WITH_BLOCK; };\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  ExprStmtWithBlock *clone_stmt_impl () const override\n+  {\n+    return new ExprStmtWithBlock (*this);\n+  }\n+};\n+\n+} // namespace AST\n+} // namespace Rust\n+\n+#endif"}, {"sha": "7e9e07d0c18dc103636e617f46b9d38e2f8287ef", "filename": "gcc/rust/ast/rust-type.h", "status": "added", "additions": 962, "deletions": 0, "changes": 962, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d588754c8266d74c9eef1e38d2d96e66ff876107/gcc%2Frust%2Fast%2Frust-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d588754c8266d74c9eef1e38d2d96e66ff876107/gcc%2Frust%2Fast%2Frust-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-type.h?ref=d588754c8266d74c9eef1e38d2d96e66ff876107", "patch": "@@ -0,0 +1,962 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_AST_TYPE_H\n+#define RUST_AST_TYPE_H\n+\n+#include \"rust-ast.h\"\n+#include \"rust-path.h\"\n+\n+namespace Rust {\n+namespace AST {\n+// definitions moved to rust-ast.h\n+class TypeParamBound;\n+class Lifetime;\n+\n+// A trait bound\n+class TraitBound : public TypeParamBound\n+{\n+  bool in_parens;\n+  bool opening_question_mark;\n+\n+  // bool has_for_lifetimes;\n+  // LifetimeParams for_lifetimes;\n+  std::vector<LifetimeParam> for_lifetimes; // inlined LifetimeParams\n+\n+  TypePath type_path;\n+\n+  Location locus;\n+\n+public:\n+  // Returns whether trait bound has \"for\" lifetimes\n+  bool has_for_lifetimes () const { return !for_lifetimes.empty (); }\n+\n+  TraitBound (TypePath type_path, Location locus, bool in_parens = false,\n+\t      bool opening_question_mark = false,\n+\t      std::vector<LifetimeParam> for_lifetimes\n+\t      = std::vector<LifetimeParam> ())\n+    : TypeParamBound (Analysis::Mappings::get ()->get_next_node_id ()),\n+      in_parens (in_parens), opening_question_mark (opening_question_mark),\n+      for_lifetimes (std::move (for_lifetimes)),\n+      type_path (std::move (type_path)), locus (locus)\n+  {}\n+\n+  TraitBound (NodeId id, TypePath type_path, Location locus,\n+\t      bool in_parens = false, bool opening_question_mark = false,\n+\t      std::vector<LifetimeParam> for_lifetimes\n+\t      = std::vector<LifetimeParam> ())\n+    : TypeParamBound (id), in_parens (in_parens),\n+      opening_question_mark (opening_question_mark),\n+      for_lifetimes (std::move (for_lifetimes)),\n+      type_path (std::move (type_path)), locus (locus)\n+  {}\n+\n+  std::string as_string () const override;\n+\n+  Location get_locus () const override final { return locus; }\n+\n+  void accept_vis (ASTVisitor &vis) override;\n+\n+  // TODO: this mutable getter seems kinda dodgy\n+  TypePath &get_type_path () { return type_path; }\n+  const TypePath &get_type_path () const { return type_path; }\n+\n+  bool is_in_parens () const { return in_parens; }\n+  bool has_opening_question_mark () const { return opening_question_mark; }\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  TraitBound *clone_type_param_bound_impl () const override\n+  {\n+    return new TraitBound (node_id, type_path, locus, in_parens,\n+\t\t\t   opening_question_mark, for_lifetimes);\n+  }\n+};\n+\n+// definition moved to rust-ast.h\n+class TypeNoBounds;\n+\n+// An impl trait? Poor reference material here.\n+class ImplTraitType : public Type\n+{\n+  // TypeParamBounds type_param_bounds;\n+  // inlined form\n+  std::vector<std::unique_ptr<TypeParamBound> > type_param_bounds;\n+\n+  Location locus;\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  ImplTraitType *clone_type_impl () const override\n+  {\n+    return new ImplTraitType (*this);\n+  }\n+\n+public:\n+  ImplTraitType (\n+    std::vector<std::unique_ptr<TypeParamBound> > type_param_bounds,\n+    Location locus)\n+    : type_param_bounds (std::move (type_param_bounds)), locus (locus)\n+  {}\n+\n+  // copy constructor with vector clone\n+  ImplTraitType (ImplTraitType const &other) : locus (other.locus)\n+  {\n+    type_param_bounds.reserve (other.type_param_bounds.size ());\n+    for (const auto &e : other.type_param_bounds)\n+      type_param_bounds.push_back (e->clone_type_param_bound ());\n+  }\n+\n+  // overloaded assignment operator to clone\n+  ImplTraitType &operator= (ImplTraitType const &other)\n+  {\n+    locus = other.locus;\n+\n+    type_param_bounds.reserve (other.type_param_bounds.size ());\n+    for (const auto &e : other.type_param_bounds)\n+      type_param_bounds.push_back (e->clone_type_param_bound ());\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  ImplTraitType (ImplTraitType &&other) = default;\n+  ImplTraitType &operator= (ImplTraitType &&other) = default;\n+\n+  std::string as_string () const override;\n+\n+  Location get_locus () const override final { return locus; }\n+\n+  void accept_vis (ASTVisitor &vis) override;\n+\n+  // TODO: mutable getter seems kinda dodgy\n+  std::vector<std::unique_ptr<TypeParamBound> > &get_type_param_bounds ()\n+  {\n+    return type_param_bounds;\n+  }\n+  const std::vector<std::unique_ptr<TypeParamBound> > &\n+  get_type_param_bounds () const\n+  {\n+    return type_param_bounds;\n+  }\n+};\n+\n+// An opaque value of another type that implements a set of traits\n+class TraitObjectType : public Type\n+{\n+  bool has_dyn;\n+  std::vector<std::unique_ptr<TypeParamBound> > type_param_bounds;\n+  Location locus;\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  TraitObjectType *clone_type_impl () const override\n+  {\n+    return new TraitObjectType (*this);\n+  }\n+\n+public:\n+  TraitObjectType (\n+    std::vector<std::unique_ptr<TypeParamBound> > type_param_bounds,\n+    Location locus, bool is_dyn_dispatch)\n+    : has_dyn (is_dyn_dispatch),\n+      type_param_bounds (std::move (type_param_bounds)), locus (locus)\n+  {}\n+\n+  // copy constructor with vector clone\n+  TraitObjectType (TraitObjectType const &other)\n+    : has_dyn (other.has_dyn), locus (other.locus)\n+  {\n+    type_param_bounds.reserve (other.type_param_bounds.size ());\n+    for (const auto &e : other.type_param_bounds)\n+      type_param_bounds.push_back (e->clone_type_param_bound ());\n+  }\n+\n+  // overloaded assignment operator to clone\n+  TraitObjectType &operator= (TraitObjectType const &other)\n+  {\n+    has_dyn = other.has_dyn;\n+    locus = other.locus;\n+    type_param_bounds.reserve (other.type_param_bounds.size ());\n+    for (const auto &e : other.type_param_bounds)\n+      type_param_bounds.push_back (e->clone_type_param_bound ());\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  TraitObjectType (TraitObjectType &&other) = default;\n+  TraitObjectType &operator= (TraitObjectType &&other) = default;\n+\n+  std::string as_string () const override;\n+\n+  Location get_locus () const override final { return locus; }\n+\n+  void accept_vis (ASTVisitor &vis) override;\n+\n+  bool is_dyn () const { return has_dyn; }\n+\n+  // TODO: mutable getter seems kinda dodgy\n+  std::vector<std::unique_ptr<TypeParamBound> > &get_type_param_bounds ()\n+  {\n+    return type_param_bounds;\n+  }\n+  const std::vector<std::unique_ptr<TypeParamBound> > &\n+  get_type_param_bounds () const\n+  {\n+    return type_param_bounds;\n+  }\n+};\n+\n+// A type with parentheses around it, used to avoid ambiguity.\n+class ParenthesisedType : public TypeNoBounds\n+{\n+  std::unique_ptr<Type> type_in_parens;\n+  Location locus;\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  ParenthesisedType *clone_type_no_bounds_impl () const override\n+  {\n+    return new ParenthesisedType (*this);\n+  }\n+\n+public:\n+  // Constructor uses Type pointer for polymorphism\n+  ParenthesisedType (std::unique_ptr<Type> type_inside_parens, Location locus)\n+    : type_in_parens (std::move (type_inside_parens)), locus (locus)\n+  {}\n+\n+  /* Copy constructor uses custom deep copy method for type to preserve\n+   * polymorphism */\n+  ParenthesisedType (ParenthesisedType const &other)\n+    : type_in_parens (other.type_in_parens->clone_type ()), locus (other.locus)\n+  {}\n+\n+  // overload assignment operator to use custom clone method\n+  ParenthesisedType &operator= (ParenthesisedType const &other)\n+  {\n+    type_in_parens = other.type_in_parens->clone_type ();\n+    locus = other.locus;\n+    return *this;\n+  }\n+\n+  // default move semantics\n+  ParenthesisedType (ParenthesisedType &&other) = default;\n+  ParenthesisedType &operator= (ParenthesisedType &&other) = default;\n+\n+  std::string as_string () const override\n+  {\n+    return \"(\" + type_in_parens->as_string () + \")\";\n+  }\n+\n+  // Creates a trait bound (clone of this one's trait bound) - HACK\n+  TraitBound *to_trait_bound (bool) const override\n+  {\n+    /* NOTE: obviously it is unknown whether the internal type is a trait bound\n+     * due to polymorphism, so just let the internal type handle it. As\n+     * parenthesised type, it must be in parentheses. */\n+    return type_in_parens->to_trait_bound (true);\n+  }\n+\n+  Location get_locus () const override final { return locus; }\n+\n+  void accept_vis (ASTVisitor &vis) override;\n+\n+  // TODO: would a \"vis_type\" be better?\n+  std::unique_ptr<Type> &get_type_in_parens ()\n+  {\n+    rust_assert (type_in_parens != nullptr);\n+    return type_in_parens;\n+  }\n+};\n+\n+// Impl trait with a single bound? Poor reference material here.\n+class ImplTraitTypeOneBound : public TypeNoBounds\n+{\n+  TraitBound trait_bound;\n+  Location locus;\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  ImplTraitTypeOneBound *clone_type_no_bounds_impl () const override\n+  {\n+    return new ImplTraitTypeOneBound (*this);\n+  }\n+\n+public:\n+  ImplTraitTypeOneBound (TraitBound trait_bound, Location locus)\n+    : trait_bound (std::move (trait_bound)), locus (locus)\n+  {}\n+\n+  std::string as_string () const override;\n+\n+  Location get_locus () const override final { return locus; }\n+\n+  void accept_vis (ASTVisitor &vis) override;\n+\n+  // TODO: would a \"vis_type\" be better?\n+  TraitBound &get_trait_bound ()\n+  {\n+    // TODO: check to ensure invariants are met?\n+    return trait_bound;\n+  }\n+};\n+\n+/* A trait object with a single trait bound. The \"trait bound\" is really just\n+ * the trait. Basically like using an interface as a type in an OOP language. */\n+class TraitObjectTypeOneBound : public TypeNoBounds\n+{\n+  bool has_dyn;\n+  TraitBound trait_bound;\n+  Location locus;\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  TraitObjectTypeOneBound *clone_type_no_bounds_impl () const override\n+  {\n+    return new TraitObjectTypeOneBound (*this);\n+  }\n+\n+public:\n+  TraitObjectTypeOneBound (TraitBound trait_bound, Location locus,\n+\t\t\t   bool is_dyn_dispatch = false)\n+    : has_dyn (is_dyn_dispatch), trait_bound (std::move (trait_bound)),\n+      locus (locus)\n+  {}\n+\n+  std::string as_string () const override;\n+\n+  // Creates a trait bound (clone of this one's trait bound) - HACK\n+  TraitBound *to_trait_bound (bool) const override\n+  {\n+    /* NOTE: this assumes there is no dynamic dispatch specified- if there was,\n+     * this cloning would not be required as parsing is unambiguous. */\n+    return new TraitBound (trait_bound);\n+  }\n+\n+  Location get_locus () const override final { return locus; }\n+\n+  void accept_vis (ASTVisitor &vis) override;\n+\n+  // TODO: would a \"vis_type\" be better?\n+  TraitBound &get_trait_bound ()\n+  {\n+    // TODO: check to ensure invariants are met?\n+    return trait_bound;\n+  }\n+\n+  bool is_dyn () const { return has_dyn; }\n+};\n+\n+class TypePath; // definition moved to \"rust-path.h\"\n+\n+/* A type consisting of the \"product\" of others (the tuple's elements) in a\n+ * specific order */\n+class TupleType : public TypeNoBounds\n+{\n+  std::vector<std::unique_ptr<Type> > elems;\n+  Location locus;\n+\n+public:\n+  // Returns whether the tuple type is the unit type, i.e. has no elements.\n+  bool is_unit_type () const { return elems.empty (); }\n+\n+  TupleType (std::vector<std::unique_ptr<Type> > elems, Location locus)\n+    : elems (std::move (elems)), locus (locus)\n+  {}\n+\n+  // copy constructor with vector clone\n+  TupleType (TupleType const &other) : locus (other.locus)\n+  {\n+    elems.reserve (other.elems.size ());\n+    for (const auto &e : other.elems)\n+      elems.push_back (e->clone_type ());\n+  }\n+\n+  // overloaded assignment operator to clone\n+  TupleType &operator= (TupleType const &other)\n+  {\n+    locus = other.locus;\n+\n+    elems.reserve (other.elems.size ());\n+    for (const auto &e : other.elems)\n+      elems.push_back (e->clone_type ());\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  TupleType (TupleType &&other) = default;\n+  TupleType &operator= (TupleType &&other) = default;\n+\n+  std::string as_string () const override;\n+\n+  Location get_locus () const override final { return locus; }\n+\n+  void accept_vis (ASTVisitor &vis) override;\n+\n+  // TODO: mutable getter seems kinda dodgy\n+  std::vector<std::unique_ptr<Type> > &get_elems () { return elems; }\n+  const std::vector<std::unique_ptr<Type> > &get_elems () const\n+  {\n+    return elems;\n+  }\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  TupleType *clone_type_no_bounds_impl () const override\n+  {\n+    return new TupleType (*this);\n+  }\n+};\n+\n+/* A type with no values, representing the result of computations that never\n+ * complete. Expressions of NeverType can be coerced into any other types.\n+ * Represented as \"!\". */\n+class NeverType : public TypeNoBounds\n+{\n+  Location locus;\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  NeverType *clone_type_no_bounds_impl () const override\n+  {\n+    return new NeverType (*this);\n+  }\n+\n+public:\n+  NeverType (Location locus) : locus (locus) {}\n+\n+  std::string as_string () const override { return \"! (never type)\"; }\n+\n+  Location get_locus () const override final { return locus; }\n+\n+  void accept_vis (ASTVisitor &vis) override;\n+};\n+\n+// A type consisting of a pointer without safety or liveness guarantees\n+class RawPointerType : public TypeNoBounds\n+{\n+public:\n+  enum PointerType\n+  {\n+    MUT,\n+    CONST\n+  };\n+\n+private:\n+  PointerType pointer_type;\n+  std::unique_ptr<TypeNoBounds> type;\n+  Location locus;\n+\n+public:\n+  // Returns whether the pointer is mutable or constant.\n+  PointerType get_pointer_type () const { return pointer_type; }\n+\n+  // Constructor requires pointer for polymorphism reasons\n+  RawPointerType (PointerType pointer_type,\n+\t\t  std::unique_ptr<TypeNoBounds> type_no_bounds, Location locus)\n+    : pointer_type (pointer_type), type (std::move (type_no_bounds)),\n+      locus (locus)\n+  {}\n+\n+  // Copy constructor calls custom polymorphic clone function\n+  RawPointerType (RawPointerType const &other)\n+    : pointer_type (other.pointer_type),\n+      type (other.type->clone_type_no_bounds ()), locus (other.locus)\n+  {}\n+\n+  // overload assignment operator to use custom clone method\n+  RawPointerType &operator= (RawPointerType const &other)\n+  {\n+    pointer_type = other.pointer_type;\n+    type = other.type->clone_type_no_bounds ();\n+    locus = other.locus;\n+    return *this;\n+  }\n+\n+  // default move semantics\n+  RawPointerType (RawPointerType &&other) = default;\n+  RawPointerType &operator= (RawPointerType &&other) = default;\n+\n+  std::string as_string () const override;\n+\n+  Location get_locus () const override final { return locus; }\n+\n+  void accept_vis (ASTVisitor &vis) override;\n+\n+  // TODO: would a \"vis_type\" be better?\n+  std::unique_ptr<TypeNoBounds> &get_type_pointed_to ()\n+  {\n+    rust_assert (type != nullptr);\n+    return type;\n+  }\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  RawPointerType *clone_type_no_bounds_impl () const override\n+  {\n+    return new RawPointerType (*this);\n+  }\n+};\n+\n+// A type pointing to memory owned by another value\n+class ReferenceType : public TypeNoBounds\n+{\n+  // bool has_lifetime; // TODO: handle in lifetime or something?\n+  Lifetime lifetime;\n+\n+  bool has_mut;\n+  std::unique_ptr<TypeNoBounds> type;\n+  Location locus;\n+\n+public:\n+  // Returns whether the reference is mutable or immutable.\n+  bool is_mut () const { return has_mut; }\n+\n+  // Returns whether the reference has a lifetime.\n+  bool has_lifetime () const { return !lifetime.is_error (); }\n+\n+  // Constructor\n+  ReferenceType (bool is_mut, std::unique_ptr<TypeNoBounds> type_no_bounds,\n+\t\t Location locus, Lifetime lifetime = Lifetime::error ())\n+    : lifetime (std::move (lifetime)), has_mut (is_mut),\n+      type (std::move (type_no_bounds)), locus (locus)\n+  {}\n+\n+  // Copy constructor with custom clone method\n+  ReferenceType (ReferenceType const &other)\n+    : lifetime (other.lifetime), has_mut (other.has_mut),\n+      type (other.type->clone_type_no_bounds ()), locus (other.locus)\n+  {}\n+\n+  // Operator overload assignment operator to custom clone the unique pointer\n+  ReferenceType &operator= (ReferenceType const &other)\n+  {\n+    lifetime = other.lifetime;\n+    has_mut = other.has_mut;\n+    type = other.type->clone_type_no_bounds ();\n+    locus = other.locus;\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  ReferenceType (ReferenceType &&other) = default;\n+  ReferenceType &operator= (ReferenceType &&other) = default;\n+\n+  std::string as_string () const override;\n+\n+  Location get_locus () const override final { return locus; }\n+\n+  void accept_vis (ASTVisitor &vis) override;\n+\n+  // TODO: would a \"vis_type\" be better?\n+  std::unique_ptr<TypeNoBounds> &get_type_referenced ()\n+  {\n+    rust_assert (type != nullptr);\n+    return type;\n+  }\n+\n+  bool get_has_mut () const { return has_mut; }\n+\n+  Lifetime &get_lifetime () { return lifetime; }\n+\n+  std::unique_ptr<TypeNoBounds> &get_base_type () { return type; }\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  ReferenceType *clone_type_no_bounds_impl () const override\n+  {\n+    return new ReferenceType (*this);\n+  }\n+};\n+\n+// A fixed-size sequence of elements of a specified type\n+class ArrayType : public TypeNoBounds\n+{\n+  std::unique_ptr<Type> elem_type;\n+  std::unique_ptr<Expr> size;\n+  Location locus;\n+\n+public:\n+  // Constructor requires pointers for polymorphism\n+  ArrayType (std::unique_ptr<Type> type, std::unique_ptr<Expr> array_size,\n+\t     Location locus)\n+    : elem_type (std::move (type)), size (std::move (array_size)), locus (locus)\n+  {}\n+\n+  // Copy constructor requires deep copies of both unique pointers\n+  ArrayType (ArrayType const &other)\n+    : elem_type (other.elem_type->clone_type ()),\n+      size (other.size->clone_expr ()), locus (other.locus)\n+  {}\n+\n+  // Overload assignment operator to deep copy pointers\n+  ArrayType &operator= (ArrayType const &other)\n+  {\n+    elem_type = other.elem_type->clone_type ();\n+    size = other.size->clone_expr ();\n+    locus = other.locus;\n+    return *this;\n+  }\n+\n+  // move constructors\n+  ArrayType (ArrayType &&other) = default;\n+  ArrayType &operator= (ArrayType &&other) = default;\n+\n+  std::string as_string () const override;\n+\n+  Location get_locus () const override final { return locus; }\n+\n+  void accept_vis (ASTVisitor &vis) override;\n+\n+  // TODO: would a \"vis_type\" be better?\n+  std::unique_ptr<Type> &get_elem_type ()\n+  {\n+    rust_assert (elem_type != nullptr);\n+    return elem_type;\n+  }\n+\n+  // TODO: would a \"vis_expr\" be better?\n+  std::unique_ptr<Expr> &get_size_expr ()\n+  {\n+    rust_assert (size != nullptr);\n+    return size;\n+  }\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  ArrayType *clone_type_no_bounds_impl () const override\n+  {\n+    return new ArrayType (*this);\n+  }\n+};\n+\n+/* A dynamically-sized type representing a \"view\" into a sequence of elements of\n+ * a type */\n+class SliceType : public TypeNoBounds\n+{\n+  std::unique_ptr<Type> elem_type;\n+  Location locus;\n+\n+public:\n+  // Constructor requires pointer for polymorphism\n+  SliceType (std::unique_ptr<Type> type, Location locus)\n+    : elem_type (std::move (type)), locus (locus)\n+  {}\n+\n+  // Copy constructor requires deep copy of Type smart pointer\n+  SliceType (SliceType const &other)\n+    : elem_type (other.elem_type->clone_type ()), locus (other.locus)\n+  {}\n+\n+  // Overload assignment operator to deep copy\n+  SliceType &operator= (SliceType const &other)\n+  {\n+    elem_type = other.elem_type->clone_type ();\n+    locus = other.locus;\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  SliceType (SliceType &&other) = default;\n+  SliceType &operator= (SliceType &&other) = default;\n+\n+  std::string as_string () const override;\n+\n+  Location get_locus () const override final { return locus; }\n+\n+  void accept_vis (ASTVisitor &vis) override;\n+\n+  // TODO: would a \"vis_type\" be better?\n+  std::unique_ptr<Type> &get_elem_type ()\n+  {\n+    rust_assert (elem_type != nullptr);\n+    return elem_type;\n+  }\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  SliceType *clone_type_no_bounds_impl () const override\n+  {\n+    return new SliceType (*this);\n+  }\n+};\n+\n+/* Type used in generic arguments to explicitly request type inference (wildcard\n+ * pattern) */\n+class InferredType : public TypeNoBounds\n+{\n+  Location locus;\n+\n+  // e.g. Vec<_> = whatever\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  InferredType *clone_type_no_bounds_impl () const override\n+  {\n+    return new InferredType (*this);\n+  }\n+\n+public:\n+  InferredType (Location locus) : locus (locus) {}\n+\n+  std::string as_string () const override;\n+\n+  Location get_locus () const override final { return locus; }\n+\n+  void accept_vis (ASTVisitor &vis) override;\n+};\n+\n+class QualifiedPathInType; // definition moved to \"rust-path.h\"\n+\n+// A possibly named param used in a BaseFunctionType\n+struct MaybeNamedParam\n+{\n+public:\n+  enum ParamKind\n+  {\n+    UNNAMED,\n+    IDENTIFIER,\n+    WILDCARD\n+  };\n+\n+private:\n+  std::vector<Attribute> outer_attrs;\n+\n+  std::unique_ptr<Type> param_type;\n+\n+  ParamKind param_kind;\n+  Identifier name; // technically, can be an identifier or '_'\n+\n+  Location locus;\n+\n+public:\n+  MaybeNamedParam (Identifier name, ParamKind param_kind,\n+\t\t   std::unique_ptr<Type> param_type,\n+\t\t   std::vector<Attribute> outer_attrs, Location locus)\n+    : outer_attrs (std::move (outer_attrs)),\n+      param_type (std::move (param_type)), param_kind (param_kind),\n+      name (std::move (name)), locus (locus)\n+  {}\n+\n+  // Copy constructor with clone\n+  MaybeNamedParam (MaybeNamedParam const &other)\n+    : outer_attrs (other.outer_attrs), param_kind (other.param_kind),\n+      name (other.name), locus (other.locus)\n+  {\n+    // guard to prevent null dereference\n+    if (other.param_type != nullptr)\n+      param_type = other.param_type->clone_type ();\n+  }\n+\n+  ~MaybeNamedParam () = default;\n+\n+  // Overloaded assignment operator with clone\n+  MaybeNamedParam &operator= (MaybeNamedParam const &other)\n+  {\n+    outer_attrs = other.outer_attrs;\n+    name = other.name;\n+    param_kind = other.param_kind;\n+    locus = other.locus;\n+\n+    // guard to prevent null dereference\n+    if (other.param_type != nullptr)\n+      param_type = other.param_type->clone_type ();\n+    else\n+      param_type = nullptr;\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  MaybeNamedParam (MaybeNamedParam &&other) = default;\n+  MaybeNamedParam &operator= (MaybeNamedParam &&other) = default;\n+\n+  std::string as_string () const;\n+\n+  // Returns whether the param is in an error state.\n+  bool is_error () const { return param_type == nullptr; }\n+\n+  // Creates an error state param.\n+  static MaybeNamedParam create_error ()\n+  {\n+    return MaybeNamedParam (\"\", UNNAMED, nullptr, {}, Location ());\n+  }\n+\n+  Location get_locus () const { return locus; }\n+\n+  // TODO: this mutable getter seems really dodgy. Think up better way.\n+  std::vector<Attribute> &get_outer_attrs () { return outer_attrs; }\n+  const std::vector<Attribute> &get_outer_attrs () const { return outer_attrs; }\n+\n+  // TODO: would a \"vis_type\" be better?\n+  std::unique_ptr<Type> &get_type ()\n+  {\n+    rust_assert (param_type != nullptr);\n+    return param_type;\n+  }\n+\n+  ParamKind get_param_kind () const { return param_kind; }\n+\n+  Identifier get_name () const { return name; }\n+};\n+\n+/* A function pointer type - can be created via coercion from function items and\n+ * non- capturing closures. */\n+class BareFunctionType : public TypeNoBounds\n+{\n+  // bool has_for_lifetimes;\n+  // ForLifetimes for_lifetimes;\n+  std::vector<LifetimeParam> for_lifetimes; // inlined version\n+\n+  FunctionQualifiers function_qualifiers;\n+  std::vector<MaybeNamedParam> params;\n+  bool is_variadic;\n+  std::vector<Attribute> variadic_attrs;\n+\n+  // bool has_return_type;\n+  // BareFunctionReturnType return_type;\n+  std::unique_ptr<TypeNoBounds> return_type; // inlined version\n+\n+  Location locus;\n+\n+public:\n+  // Whether a return type is defined with the function.\n+  bool has_return_type () const { return return_type != nullptr; }\n+\n+  // Whether the function has ForLifetimes.\n+  bool has_for_lifetimes () const { return !for_lifetimes.empty (); }\n+\n+  BareFunctionType (std::vector<LifetimeParam> lifetime_params,\n+\t\t    FunctionQualifiers qualifiers,\n+\t\t    std::vector<MaybeNamedParam> named_params, bool is_variadic,\n+\t\t    std::vector<Attribute> variadic_attrs,\n+\t\t    std::unique_ptr<TypeNoBounds> type, Location locus)\n+    : for_lifetimes (std::move (lifetime_params)),\n+      function_qualifiers (std::move (qualifiers)),\n+      params (std::move (named_params)), is_variadic (is_variadic),\n+      variadic_attrs (std::move (variadic_attrs)),\n+      return_type (std::move (type)), locus (locus)\n+  {\n+    if (!variadic_attrs.empty ())\n+      is_variadic = true;\n+  }\n+\n+  // Copy constructor with clone\n+  BareFunctionType (BareFunctionType const &other)\n+    : for_lifetimes (other.for_lifetimes),\n+      function_qualifiers (other.function_qualifiers), params (other.params),\n+      is_variadic (other.is_variadic), variadic_attrs (other.variadic_attrs),\n+      locus (other.locus)\n+  {\n+    // guard to prevent null dereference\n+    if (other.return_type != nullptr)\n+      return_type = other.return_type->clone_type_no_bounds ();\n+  }\n+\n+  // Overload assignment operator to deep copy\n+  BareFunctionType &operator= (BareFunctionType const &other)\n+  {\n+    for_lifetimes = other.for_lifetimes;\n+    function_qualifiers = other.function_qualifiers;\n+    params = other.params;\n+    is_variadic = other.is_variadic;\n+    variadic_attrs = other.variadic_attrs;\n+    locus = other.locus;\n+\n+    // guard to prevent null dereference\n+    if (other.return_type != nullptr)\n+      return_type = other.return_type->clone_type_no_bounds ();\n+    else\n+      return_type = nullptr;\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  BareFunctionType (BareFunctionType &&other) = default;\n+  BareFunctionType &operator= (BareFunctionType &&other) = default;\n+\n+  std::string as_string () const override;\n+\n+  Location get_locus () const override final { return locus; }\n+\n+  void accept_vis (ASTVisitor &vis) override;\n+\n+  // TODO: this mutable getter seems kinda dodgy\n+  std::vector<MaybeNamedParam> &get_function_params () { return params; }\n+  const std::vector<MaybeNamedParam> &get_function_params () const\n+  {\n+    return params;\n+  }\n+\n+  // TODO: would a \"vis_type\" be better?\n+  std::unique_ptr<TypeNoBounds> &get_return_type ()\n+  {\n+    rust_assert (has_return_type ());\n+    return return_type;\n+  }\n+\n+  FunctionQualifiers get_function_qualifiers () { return function_qualifiers; }\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  BareFunctionType *clone_type_no_bounds_impl () const override\n+  {\n+    return new BareFunctionType (*this);\n+  }\n+};\n+\n+// Forward decl - defined in rust-macro.h\n+class MacroInvocation;\n+\n+/* TODO: possible types\n+ * struct type?\n+ * \"enum\" (tagged union) type?\n+ * C-like union type?\n+ * function item type?\n+ * closure expression types?\n+ * primitive types (bool, int, float, char, str (the slice))\n+ * Although supposedly TypePaths are used to reference these types (including\n+ * primitives) */\n+\n+/* FIXME: Incomplete spec references:\n+ *  anonymous type parameters, aka \"impl Trait in argument position\" - impl then\n+ * trait bounds abstract return types, aka \"impl Trait in return position\" -\n+ * impl then trait bounds */\n+} // namespace AST\n+} // namespace Rust\n+\n+#endif"}]}