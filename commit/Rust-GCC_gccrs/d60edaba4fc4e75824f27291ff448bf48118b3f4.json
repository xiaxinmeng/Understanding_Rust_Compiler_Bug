{"sha": "d60edaba4fc4e75824f27291ff448bf48118b3f4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDYwZWRhYmE0ZmM0ZTc1ODI0ZjI3MjkxZmY0NDhiZjQ4MTE4YjNmNA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2017-11-09T19:24:59Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2017-11-09T19:24:59Z"}, "message": "gimple-ssa-store-merging.c (struct store_immediate_info): Add bit_not_p field.\n\n\t* gimple-ssa-store-merging.c (struct store_immediate_info): Add\n\tbit_not_p field.\n\t(store_immediate_info::store_immediate_info): Add bitnotp argument,\n\tset bit_not_p to it.\n\t(imm_store_chain_info::coalesce_immediate_stores): Break group\n\tif bit_not_p is different.\n\t(count_multiple_uses, split_group,\n\timm_store_chain_info::output_merged_store): Handle info->bit_not_p.\n\t(handled_load): Avoid multiple chained BIT_NOT_EXPRs.\n\t(pass_store_merging::process_store): Handle BIT_{AND,IOR,XOR}_EXPR\n\tresult inverted using BIT_NOT_EXPR, compute bit_not_p, pass it\n\tto store_immediate_info ctor.\n\nFrom-SVN: r254606", "tree": {"sha": "a0e9608305ae2e5b1bfa1a7d5369840a34993ed1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a0e9608305ae2e5b1bfa1a7d5369840a34993ed1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d60edaba4fc4e75824f27291ff448bf48118b3f4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d60edaba4fc4e75824f27291ff448bf48118b3f4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d60edaba4fc4e75824f27291ff448bf48118b3f4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d60edaba4fc4e75824f27291ff448bf48118b3f4/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6e307219b955b80e6669acadae72c183f0eda248", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e307219b955b80e6669acadae72c183f0eda248", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e307219b955b80e6669acadae72c183f0eda248"}], "stats": {"total": 72, "additions": 66, "deletions": 6}, "files": [{"sha": "0dc2057c08d49558357a8062c7000daec6ad79ec", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d60edaba4fc4e75824f27291ff448bf48118b3f4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d60edaba4fc4e75824f27291ff448bf48118b3f4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d60edaba4fc4e75824f27291ff448bf48118b3f4", "patch": "@@ -1,3 +1,18 @@\n+2017-11-09  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* gimple-ssa-store-merging.c (struct store_immediate_info): Add\n+\tbit_not_p field.\n+\t(store_immediate_info::store_immediate_info): Add bitnotp argument,\n+\tset bit_not_p to it.\n+\t(imm_store_chain_info::coalesce_immediate_stores): Break group\n+\tif bit_not_p is different.\n+\t(count_multiple_uses, split_group,\n+\timm_store_chain_info::output_merged_store): Handle info->bit_not_p.\n+\t(handled_load): Avoid multiple chained BIT_NOT_EXPRs.\n+\t(pass_store_merging::process_store): Handle BIT_{AND,IOR,XOR}_EXPR\n+\tresult inverted using BIT_NOT_EXPR, compute bit_not_p, pass it\n+\tto store_immediate_info ctor.\n+\n 2017-11-09  Jim Wilson  <jimw@sifive.com>\n \n \t* collect2.c (OBJECT_FORMAT_COFF): Remove EXTENDED_COFF support."}, {"sha": "421498beafb7093128c5ab3b73d5c47c5ba7a4bd", "filename": "gcc/gimple-ssa-store-merging.c", "status": "modified", "additions": 51, "deletions": 6, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d60edaba4fc4e75824f27291ff448bf48118b3f4/gcc%2Fgimple-ssa-store-merging.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d60edaba4fc4e75824f27291ff448bf48118b3f4/gcc%2Fgimple-ssa-store-merging.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-store-merging.c?ref=d60edaba4fc4e75824f27291ff448bf48118b3f4", "patch": "@@ -209,12 +209,13 @@ struct store_immediate_info\n   /* INTEGER_CST for constant stores, MEM_REF for memory copy or\n      BIT_*_EXPR for logical bitwise operation.  */\n   enum tree_code rhs_code;\n+  bool bit_not_p;\n   /* Operands.  For BIT_*_EXPR rhs_code both operands are used, otherwise\n      just the first one.  */\n   store_operand_info ops[2];\n   store_immediate_info (unsigned HOST_WIDE_INT, unsigned HOST_WIDE_INT,\n \t\t\tunsigned HOST_WIDE_INT, unsigned HOST_WIDE_INT,\n-\t\t\tgimple *, unsigned int, enum tree_code,\n+\t\t\tgimple *, unsigned int, enum tree_code, bool,\n \t\t\tconst store_operand_info &,\n \t\t\tconst store_operand_info &);\n };\n@@ -226,10 +227,11 @@ store_immediate_info::store_immediate_info (unsigned HOST_WIDE_INT bs,\n \t\t\t\t\t    gimple *st,\n \t\t\t\t\t    unsigned int ord,\n \t\t\t\t\t    enum tree_code rhscode,\n+\t\t\t\t\t    bool bitnotp,\n \t\t\t\t\t    const store_operand_info &op0r,\n \t\t\t\t\t    const store_operand_info &op1r)\n   : bitsize (bs), bitpos (bp), bitregion_start (brs), bitregion_end (bre),\n-    stmt (st), order (ord), rhs_code (rhscode)\n+    stmt (st), order (ord), rhs_code (rhscode), bit_not_p (bitnotp)\n #if __cplusplus >= 201103L\n     , ops { op0r, op1r }\n {\n@@ -1169,7 +1171,8 @@ imm_store_chain_info::coalesce_immediate_stores ()\n \t Merge it into the current store group.  There can be gaps in between\n \t the stores, but there can't be gaps in between bitregions.  */\n       else if (info->bitregion_start <= merged_store->bitregion_end\n-\t       && info->rhs_code == merged_store->stores[0]->rhs_code)\n+\t       && info->rhs_code == merged_store->stores[0]->rhs_code\n+\t       && info->bit_not_p == merged_store->stores[0]->bit_not_p)\n \t{\n \t  store_immediate_info *infof = merged_store->stores[0];\n \n@@ -1386,6 +1389,17 @@ count_multiple_uses (store_immediate_info *info)\n     case BIT_AND_EXPR:\n     case BIT_IOR_EXPR:\n     case BIT_XOR_EXPR:\n+      if (info->bit_not_p)\n+\t{\n+\t  if (!has_single_use (gimple_assign_rhs1 (stmt)))\n+\t    ret = 1; /* Fall through below to return\n+\t\t\tthe BIT_NOT_EXPR stmt and then\n+\t\t\tBIT_{AND,IOR,XOR}_EXPR and anything it\n+\t\t\tuses.  */\n+\t  else\n+\t    /* stmt is after this the BIT_NOT_EXPR.  */\n+\t    stmt = SSA_NAME_DEF_STMT (gimple_assign_rhs1 (stmt));\n+\t}\n       if (!has_single_use (gimple_assign_rhs1 (stmt)))\n \t{\n \t  ret += 1 + info->ops[0].bit_not_p;\n@@ -1479,6 +1493,8 @@ split_group (merged_store_group *group, bool allow_unaligned_store,\n \tcase BIT_AND_EXPR:\n \tcase BIT_IOR_EXPR:\n \tcase BIT_XOR_EXPR:\n+\t  if (info->bit_not_p)\n+\t    total_orig[0]++; /* The orig BIT_NOT_EXPR stmt.  */\n \t  total_orig[0]++; /* The orig BIT_*_EXPR stmt.  */\n \t  break;\n \tdefault:\n@@ -1649,6 +1665,8 @@ split_group (merged_store_group *group, bool allow_unaligned_store,\n \tcase BIT_AND_EXPR:\n \tcase BIT_IOR_EXPR:\n \tcase BIT_XOR_EXPR:\n+\t  if (info->bit_not_p)\n+\t    total_new[0] += ret; /* The new BIT_NOT_EXPR stmt.  */\n \t  total_new[0] += ret; /* The new BIT_*_EXPR stmt.  */\n \t  break;\n \tdefault:\n@@ -1918,6 +1936,17 @@ imm_store_chain_info::output_merged_store (merged_store_group *group)\n \t      else\n \t\tgimple_seq_add_stmt_without_update (&seq, stmt);\n \t      src = gimple_assign_lhs (stmt);\n+\t      if (split_store->orig_stores[0]->bit_not_p)\n+\t\t{\n+\t\t  stmt = gimple_build_assign (make_ssa_name (int_type),\n+\t\t\t\t\t      BIT_NOT_EXPR, src);\n+\t\t  gimple_set_location (stmt, bit_loc);\n+\t\t  if (load_addr[1] == NULL_TREE && gsi_bb (load_gsi[0]))\n+\t\t    gimple_seq_add_stmt_without_update (&load_seq[0], stmt);\n+\t\t  else\n+\t\t    gimple_seq_add_stmt_without_update (&seq, stmt);\n+\t\t  src = gimple_assign_lhs (stmt);\n+\t\t}\n \t      break;\n \t    default:\n \t      src = ops[0];\n@@ -2232,6 +2261,11 @@ handled_load (gimple *stmt, store_operand_info *op,\n \t  && handled_load (SSA_NAME_DEF_STMT (rhs1), op, bitsize, bitpos,\n \t\t\t   bitregion_start, bitregion_end))\n \t{\n+\t  /* Don't allow _1 = load; _2 = ~1; _3 = ~_2; which should have\n+\t     been optimized earlier, but if allowed here, would confuse the\n+\t     multiple uses counting.  */\n+\t  if (op->bit_not_p)\n+\t    return false;\n \t  op->bit_not_p = !op->bit_not_p;\n \t  return true;\n \t}\n@@ -2283,6 +2317,7 @@ pass_store_merging::process_store (gimple *stmt)\n \t\t  || ((bitsize > MAX_BITSIZE_MODE_ANY_INT)\n \t\t       && (TREE_CODE (rhs) != INTEGER_CST)));\n   enum tree_code rhs_code = ERROR_MARK;\n+  bool bit_not_p = false;\n   store_operand_info ops[2];\n   if (invalid)\n     ;\n@@ -2301,7 +2336,17 @@ pass_store_merging::process_store (gimple *stmt)\n       else if (handled_load (def_stmt, &ops[0], bitsize, bitpos,\n \t\t\t     bitregion_start, bitregion_end))\n \trhs_code = MEM_REF;\n-      else\n+      else if (gimple_assign_rhs_code (def_stmt) == BIT_NOT_EXPR) \n+\t{\n+\t  tree rhs1 = gimple_assign_rhs1 (def_stmt);\n+\t  if (TREE_CODE (rhs1) == SSA_NAME\n+\t      && is_gimple_assign (SSA_NAME_DEF_STMT (rhs1)))\n+\t    {\n+\t      bit_not_p = true;\n+\t      def_stmt = SSA_NAME_DEF_STMT (rhs1);\n+\t    }\n+\t}\n+      if (rhs_code == ERROR_MARK && !invalid)\n \tswitch ((rhs_code = gimple_assign_rhs_code (def_stmt)))\n \t  {\n \t  case BIT_AND_EXPR:\n@@ -2355,7 +2400,7 @@ pass_store_merging::process_store (gimple *stmt)\n       unsigned int ord = (*chain_info)->m_store_info.length ();\n       info = new store_immediate_info (bitsize, bitpos, bitregion_start,\n \t\t\t\t       bitregion_end, stmt, ord, rhs_code,\n-\t\t\t\t       ops[0], ops[1]);\n+\t\t\t\t       bit_not_p, ops[0], ops[1]);\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \t{\n \t  fprintf (dump_file, \"Recording immediate store from stmt:\\n\");\n@@ -2383,7 +2428,7 @@ pass_store_merging::process_store (gimple *stmt)\n     = new imm_store_chain_info (m_stores_head, base_addr);\n   info = new store_immediate_info (bitsize, bitpos, bitregion_start,\n \t\t\t\t   bitregion_end, stmt, 0, rhs_code,\n-\t\t\t\t   ops[0], ops[1]);\n+\t\t\t\t   bit_not_p, ops[0], ops[1]);\n   new_chain->m_store_info.safe_push (info);\n   m_stores.put (base_addr, new_chain);\n   if (dump_file && (dump_flags & TDF_DETAILS))"}]}