{"sha": "b323be611b6f25ba36d97f229af7c983125437c9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjMyM2JlNjExYjZmMjViYTM2ZDk3ZjIyOWFmN2M5ODMxMjU0MzdjOQ==", "commit": {"author": {"name": "Mark Eggleston", "email": "markeggleston@gcc.gnu.org", "date": "2019-08-16T10:09:57Z"}, "committer": {"name": "Mark Eggleston", "email": "markeggleston@gcc.gnu.org", "date": "2019-08-16T10:09:57Z"}, "message": "Allow automatics in equivalences\n\nIf a variable with an automatic attribute appears in an\nequivalence statement the storage should be allocated on the\nstack.\n\nNote: most of this patch was provided by Jeff Law  <law@redhat.com>.\n\nFrom-SVN: r274565", "tree": {"sha": "e5bdc128d140f87153b626b487731c6ab467265b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e5bdc128d140f87153b626b487731c6ab467265b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b323be611b6f25ba36d97f229af7c983125437c9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b323be611b6f25ba36d97f229af7c983125437c9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b323be611b6f25ba36d97f229af7c983125437c9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b323be611b6f25ba36d97f229af7c983125437c9/comments", "author": null, "committer": null, "parents": [{"sha": "12f78d8bed049278229b24c9f0b7f97468fee5c5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/12f78d8bed049278229b24c9f0b7f97468fee5c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/12f78d8bed049278229b24c9f0b7f97468fee5c5"}], "stats": {"total": 340, "additions": 284, "deletions": 56}, "files": [{"sha": "bab69f3000ee35d09ba9d3e6854c2d10b0a6e0e9", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b323be611b6f25ba36d97f229af7c983125437c9/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b323be611b6f25ba36d97f229af7c983125437c9/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=b323be611b6f25ba36d97f229af7c983125437c9", "patch": "@@ -1,3 +1,24 @@\n+2019-08-16  Jeff Law <law@redhat.com>\n+\t    Mark Eggleston <mark.eggleston@codethink.com>\n+\n+\t* gfortran.h: Add gfc_check_conflict declaration.\n+\t* symbol.c (check_conflict): Rename cfg_check_conflict and remove\n+\tstatic.\n+\t* symbol.c (cfg_check_conflict): Remove automatic in equivalence\n+\tconflict check.\n+\t* symbol.c (save_symbol): Add check for in equivalence to stop the\n+\tthe save attribute being added.\n+\t* trans-common.c (build_equiv_decl): Add is_auto parameter and\n+\tadd !is_auto to condition where TREE_STATIC (decl) is set.\n+\t* trans-common.c (build_equiv_decl): Add local variable is_auto,\n+\tset it true if an atomatic attribute is encountered in the variable\n+\tlist.  Call build_equiv_decl with is_auto as an additional parameter.\n+\tflag_dec_format_defaults is enabled.\n+\t* trans-common.c (accumulate_equivalence_attributes) : New subroutine.\n+\t* trans-common.c (find_equivalence) : New local variable dummy_symbol,\n+\taccumulated equivalence attributes from each symbol then check for\n+\tconflicts.\n+  \n 2019-08-16  Richard Biener  <rguenther@suse.de>\n \n \t* trans-intrinsic.c (gfc_conv_intrinsic_findloc): Initialize"}, {"sha": "6a491ab959cf92f535990de205b2a93206cbe2e2", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b323be611b6f25ba36d97f229af7c983125437c9/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b323be611b6f25ba36d97f229af7c983125437c9/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=b323be611b6f25ba36d97f229af7c983125437c9", "patch": "@@ -3007,6 +3007,7 @@ bool gfc_merge_new_implicit (gfc_typespec *);\n void gfc_set_implicit_none (bool, bool, locus *);\n void gfc_check_function_type (gfc_namespace *);\n bool gfc_is_intrinsic_typename (const char *);\n+bool gfc_check_conflict (symbol_attribute *, const char *, locus *);\n \n gfc_typespec *gfc_get_default_type (const char *, gfc_namespace *);\n bool gfc_set_default_type (gfc_symbol *, int, gfc_namespace *);"}, {"sha": "cc5b5efa3a87383c17aa5ecf0e2aed0c31a62ab0", "filename": "gcc/fortran/symbol.c", "status": "modified", "additions": 51, "deletions": 51, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b323be611b6f25ba36d97f229af7c983125437c9/gcc%2Ffortran%2Fsymbol.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b323be611b6f25ba36d97f229af7c983125437c9/gcc%2Ffortran%2Fsymbol.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsymbol.c?ref=b323be611b6f25ba36d97f229af7c983125437c9", "patch": "@@ -407,8 +407,8 @@ gfc_check_function_type (gfc_namespace *ns)\n                                 goto conflict_std;\\\n                               }\n \n-static bool\n-check_conflict (symbol_attribute *attr, const char *name, locus *where)\n+bool\n+gfc_check_conflict (symbol_attribute *attr, const char *name, locus *where)\n {\n   static const char *dummy = \"DUMMY\", *save = \"SAVE\", *pointer = \"POINTER\",\n     *target = \"TARGET\", *external = \"EXTERNAL\", *intent = \"INTENT\",\n@@ -544,7 +544,6 @@ check_conflict (symbol_attribute *attr, const char *name, locus *where)\n   conf (allocatable, elemental);\n \n   conf (in_common, automatic);\n-  conf (in_equivalence, automatic);\n   conf (result, automatic);\n   conf (use_assoc, automatic);\n   conf (dummy, automatic);\n@@ -1004,7 +1003,7 @@ gfc_add_attribute (symbol_attribute *attr, locus *where)\n   if (check_used (attr, NULL, where))\n     return false;\n \n-  return check_conflict (attr, NULL, where);\n+  return gfc_check_conflict (attr, NULL, where);\n }\n \n \n@@ -1030,7 +1029,7 @@ gfc_add_allocatable (symbol_attribute *attr, locus *where)\n     }\n \n   attr->allocatable = 1;\n-  return check_conflict (attr, NULL, where);\n+  return gfc_check_conflict (attr, NULL, where);\n }\n \n \n@@ -1045,7 +1044,7 @@ gfc_add_automatic (symbol_attribute *attr, const char *name, locus *where)\n     return false;\n \n   attr->automatic = 1;\n-  return check_conflict (attr, name, where);\n+  return gfc_check_conflict (attr, name, where);\n }\n \n \n@@ -1071,7 +1070,7 @@ gfc_add_codimension (symbol_attribute *attr, const char *name, locus *where)\n     }\n \n   attr->codimension = 1;\n-  return check_conflict (attr, name, where);\n+  return gfc_check_conflict (attr, name, where);\n }\n \n \n@@ -1097,7 +1096,7 @@ gfc_add_dimension (symbol_attribute *attr, const char *name, locus *where)\n     }\n \n   attr->dimension = 1;\n-  return check_conflict (attr, name, where);\n+  return gfc_check_conflict (attr, name, where);\n }\n \n \n@@ -1109,7 +1108,7 @@ gfc_add_contiguous (symbol_attribute *attr, const char *name, locus *where)\n     return false;\n \n   attr->contiguous = 1;\n-  return check_conflict (attr, name, where);\n+  return gfc_check_conflict (attr, name, where);\n }\n \n \n@@ -1134,7 +1133,7 @@ gfc_add_external (symbol_attribute *attr, locus *where)\n \n   attr->external = 1;\n \n-  return check_conflict (attr, NULL, where);\n+  return gfc_check_conflict (attr, NULL, where);\n }\n \n \n@@ -1153,7 +1152,7 @@ gfc_add_intrinsic (symbol_attribute *attr, locus *where)\n \n   attr->intrinsic = 1;\n \n-  return check_conflict (attr, NULL, where);\n+  return gfc_check_conflict (attr, NULL, where);\n }\n \n \n@@ -1171,7 +1170,7 @@ gfc_add_optional (symbol_attribute *attr, locus *where)\n     }\n \n   attr->optional = 1;\n-  return check_conflict (attr, NULL, where);\n+  return gfc_check_conflict (attr, NULL, where);\n }\n \n bool\n@@ -1184,7 +1183,7 @@ gfc_add_kind (symbol_attribute *attr, locus *where)\n     }\n \n   attr->pdt_kind = 1;\n-  return check_conflict (attr, NULL, where);\n+  return gfc_check_conflict (attr, NULL, where);\n }\n \n bool\n@@ -1197,7 +1196,7 @@ gfc_add_len (symbol_attribute *attr, locus *where)\n     }\n \n   attr->pdt_len = 1;\n-  return check_conflict (attr, NULL, where);\n+  return gfc_check_conflict (attr, NULL, where);\n }\n \n \n@@ -1222,7 +1221,7 @@ gfc_add_pointer (symbol_attribute *attr, locus *where)\n   else\n     attr->pointer = 1;\n \n-  return check_conflict (attr, NULL, where);\n+  return gfc_check_conflict (attr, NULL, where);\n }\n \n \n@@ -1234,7 +1233,7 @@ gfc_add_cray_pointer (symbol_attribute *attr, locus *where)\n     return false;\n \n   attr->cray_pointer = 1;\n-  return check_conflict (attr, NULL, where);\n+  return gfc_check_conflict (attr, NULL, where);\n }\n \n \n@@ -1253,7 +1252,7 @@ gfc_add_cray_pointee (symbol_attribute *attr, locus *where)\n     }\n \n   attr->cray_pointee = 1;\n-  return check_conflict (attr, NULL, where);\n+  return gfc_check_conflict (attr, NULL, where);\n }\n \n \n@@ -1272,7 +1271,7 @@ gfc_add_protected (symbol_attribute *attr, const char *name, locus *where)\n     }\n \n   attr->is_protected = 1;\n-  return check_conflict (attr, name, where);\n+  return gfc_check_conflict (attr, name, where);\n }\n \n \n@@ -1284,7 +1283,7 @@ gfc_add_result (symbol_attribute *attr, const char *name, locus *where)\n     return false;\n \n   attr->result = 1;\n-  return check_conflict (attr, name, where);\n+  return gfc_check_conflict (attr, name, where);\n }\n \n \n@@ -1317,7 +1316,7 @@ gfc_add_save (symbol_attribute *attr, save_state s, const char *name,\n     }\n \n   attr->save = s;\n-  return check_conflict (attr, name, where);\n+  return gfc_check_conflict (attr, name, where);\n }\n \n \n@@ -1337,7 +1336,7 @@ gfc_add_value (symbol_attribute *attr, const char *name, locus *where)\n     }\n \n   attr->value = 1;\n-  return check_conflict (attr, name, where);\n+  return gfc_check_conflict (attr, name, where);\n }\n \n \n@@ -1370,7 +1369,7 @@ gfc_add_volatile (symbol_attribute *attr, const char *name, locus *where)\n \n   attr->volatile_ = 1;\n   attr->volatile_ns = gfc_current_ns;\n-  return check_conflict (attr, name, where);\n+  return gfc_check_conflict (attr, name, where);\n }\n \n \n@@ -1389,7 +1388,7 @@ gfc_add_asynchronous (symbol_attribute *attr, const char *name, locus *where)\n \n   attr->asynchronous = 1;\n   attr->asynchronous_ns = gfc_current_ns;\n-  return check_conflict (attr, name, where);\n+  return gfc_check_conflict (attr, name, where);\n }\n \n \n@@ -1407,7 +1406,7 @@ gfc_add_threadprivate (symbol_attribute *attr, const char *name, locus *where)\n     }\n \n   attr->threadprivate = 1;\n-  return check_conflict (attr, name, where);\n+  return gfc_check_conflict (attr, name, where);\n }\n \n \n@@ -1423,7 +1422,7 @@ gfc_add_omp_declare_target (symbol_attribute *attr, const char *name,\n     return true;\n \n   attr->omp_declare_target = 1;\n-  return check_conflict (attr, name, where);\n+  return gfc_check_conflict (attr, name, where);\n }\n \n \n@@ -1439,7 +1438,7 @@ gfc_add_omp_declare_target_link (symbol_attribute *attr, const char *name,\n     return true;\n \n   attr->omp_declare_target_link = 1;\n-  return check_conflict (attr, name, where);\n+  return gfc_check_conflict (attr, name, where);\n }\n \n \n@@ -1454,7 +1453,7 @@ gfc_add_oacc_declare_create (symbol_attribute *attr, const char *name,\n     return true;\n \n   attr->oacc_declare_create = 1;\n-  return check_conflict (attr, name, where);\n+  return gfc_check_conflict (attr, name, where);\n }\n \n \n@@ -1469,7 +1468,7 @@ gfc_add_oacc_declare_copyin (symbol_attribute *attr, const char *name,\n     return true;\n \n   attr->oacc_declare_copyin = 1;\n-  return check_conflict (attr, name, where);\n+  return gfc_check_conflict (attr, name, where);\n }\n \n \n@@ -1484,7 +1483,7 @@ gfc_add_oacc_declare_deviceptr (symbol_attribute *attr, const char *name,\n     return true;\n \n   attr->oacc_declare_deviceptr = 1;\n-  return check_conflict (attr, name, where);\n+  return gfc_check_conflict (attr, name, where);\n }\n \n \n@@ -1499,7 +1498,7 @@ gfc_add_oacc_declare_device_resident (symbol_attribute *attr, const char *name,\n     return true;\n \n   attr->oacc_declare_device_resident = 1;\n-  return check_conflict (attr, name, where);\n+  return gfc_check_conflict (attr, name, where);\n }\n \n \n@@ -1517,7 +1516,7 @@ gfc_add_target (symbol_attribute *attr, locus *where)\n     }\n \n   attr->target = 1;\n-  return check_conflict (attr, NULL, where);\n+  return gfc_check_conflict (attr, NULL, where);\n }\n \n \n@@ -1530,7 +1529,7 @@ gfc_add_dummy (symbol_attribute *attr, const char *name, locus *where)\n \n   /* Duplicate dummy arguments are allowed due to ENTRY statements.  */\n   attr->dummy = 1;\n-  return check_conflict (attr, name, where);\n+  return gfc_check_conflict (attr, name, where);\n }\n \n \n@@ -1543,7 +1542,7 @@ gfc_add_in_common (symbol_attribute *attr, const char *name, locus *where)\n \n   /* Duplicate attribute already checked for.  */\n   attr->in_common = 1;\n-  return check_conflict (attr, name, where);\n+  return gfc_check_conflict (attr, name, where);\n }\n \n \n@@ -1553,7 +1552,7 @@ gfc_add_in_equivalence (symbol_attribute *attr, const char *name, locus *where)\n \n   /* Duplicate attribute already checked for.  */\n   attr->in_equivalence = 1;\n-  if (!check_conflict (attr, name, where))\n+  if (!gfc_check_conflict (attr, name, where))\n     return false;\n \n   if (attr->flavor == FL_VARIABLE)\n@@ -1571,7 +1570,7 @@ gfc_add_data (symbol_attribute *attr, const char *name, locus *where)\n     return false;\n \n   attr->data = 1;\n-  return check_conflict (attr, name, where);\n+  return gfc_check_conflict (attr, name, where);\n }\n \n \n@@ -1580,7 +1579,7 @@ gfc_add_in_namelist (symbol_attribute *attr, const char *name, locus *where)\n {\n \n   attr->in_namelist = 1;\n-  return check_conflict (attr, name, where);\n+  return gfc_check_conflict (attr, name, where);\n }\n \n \n@@ -1592,7 +1591,7 @@ gfc_add_sequence (symbol_attribute *attr, const char *name, locus *where)\n     return false;\n \n   attr->sequence = 1;\n-  return check_conflict (attr, name, where);\n+  return gfc_check_conflict (attr, name, where);\n }\n \n \n@@ -1610,7 +1609,7 @@ gfc_add_elemental (symbol_attribute *attr, locus *where)\n     }\n \n   attr->elemental = 1;\n-  return check_conflict (attr, NULL, where);\n+  return gfc_check_conflict (attr, NULL, where);\n }\n \n \n@@ -1628,7 +1627,7 @@ gfc_add_pure (symbol_attribute *attr, locus *where)\n     }\n \n   attr->pure = 1;\n-  return check_conflict (attr, NULL, where);\n+  return gfc_check_conflict (attr, NULL, where);\n }\n \n \n@@ -1646,7 +1645,7 @@ gfc_add_recursive (symbol_attribute *attr, locus *where)\n     }\n \n   attr->recursive = 1;\n-  return check_conflict (attr, NULL, where);\n+  return gfc_check_conflict (attr, NULL, where);\n }\n \n \n@@ -1664,7 +1663,7 @@ gfc_add_entry (symbol_attribute *attr, const char *name, locus *where)\n     }\n \n   attr->entry = 1;\n-  return check_conflict (attr, name, where);\n+  return gfc_check_conflict (attr, name, where);\n }\n \n \n@@ -1677,7 +1676,7 @@ gfc_add_function (symbol_attribute *attr, const char *name, locus *where)\n     return false;\n \n   attr->function = 1;\n-  return check_conflict (attr, name, where);\n+  return gfc_check_conflict (attr, name, where);\n }\n \n \n@@ -1696,7 +1695,7 @@ gfc_add_subroutine (symbol_attribute *attr, const char *name, locus *where)\n      compiler-generated), do not check. See PR 84394.  */\n \n   if (name && *name != '_' && gfc_current_state () != COMP_BLOCK_DATA)\n-    return check_conflict (attr, name, where);\n+    return gfc_check_conflict (attr, name, where);\n   else\n     return true;\n }\n@@ -1711,7 +1710,7 @@ gfc_add_generic (symbol_attribute *attr, const char *name, locus *where)\n     return false;\n \n   attr->generic = 1;\n-  return check_conflict (attr, name, where);\n+  return gfc_check_conflict (attr, name, where);\n }\n \n \n@@ -1734,7 +1733,7 @@ gfc_add_proc (symbol_attribute *attr, const char *name, locus *where)\n \n   attr->procedure = 1;\n \n-  return check_conflict (attr, NULL, where);\n+  return gfc_check_conflict (attr, NULL, where);\n }\n \n \n@@ -1749,7 +1748,7 @@ gfc_add_abstract (symbol_attribute* attr, locus* where)\n \n   attr->abstract = 1;\n \n-  return check_conflict (attr, NULL, where);\n+  return gfc_check_conflict (attr, NULL, where);\n }\n \n \n@@ -1795,7 +1794,7 @@ gfc_add_flavor (symbol_attribute *attr, sym_flavor f, const char *name,\n \n   attr->flavor = f;\n \n-  return check_conflict (attr, name, where);\n+  return gfc_check_conflict (attr, name, where);\n }\n \n \n@@ -1842,7 +1841,7 @@ gfc_add_procedure (symbol_attribute *attr, procedure_type t,\n \t  || attr->dimension))\n     return false;\n \n-  return check_conflict (attr, name, where);\n+  return gfc_check_conflict (attr, name, where);\n }\n \n \n@@ -1856,7 +1855,7 @@ gfc_add_intent (symbol_attribute *attr, sym_intent intent, locus *where)\n   if (attr->intent == INTENT_UNKNOWN)\n     {\n       attr->intent = intent;\n-      return check_conflict (attr, NULL, where);\n+      return gfc_check_conflict (attr, NULL, where);\n     }\n \n   if (where == NULL)\n@@ -1881,7 +1880,7 @@ gfc_add_access (symbol_attribute *attr, gfc_access access,\n \t|| (attr->use_assoc && attr->access != ACCESS_PRIVATE))\n     {\n       attr->access = access;\n-      return check_conflict (attr, name, where);\n+      return gfc_check_conflict (attr, name, where);\n     }\n \n   if (where == NULL)\n@@ -1913,7 +1912,7 @@ gfc_add_is_bind_c (symbol_attribute *attr, const char *name, locus *where,\n   if (!gfc_notify_std (GFC_STD_F2003, \"BIND(C) at %L\", where))\n     return false;\n \n-  return check_conflict (attr, name, where);\n+  return gfc_check_conflict (attr, name, where);\n }\n \n \n@@ -4244,6 +4243,7 @@ save_symbol (gfc_symbol *sym)\n     return;\n \n   if (sym->attr.in_common\n+      || sym->attr.in_equivalence\n       || sym->attr.dummy\n       || sym->attr.result\n       || sym->attr.flavor != FL_VARIABLE)"}, {"sha": "18ad60fd6579b95b5ffb431dff84830946abe0fc", "filename": "gcc/fortran/trans-common.c", "status": "modified", "additions": 68, "deletions": 5, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b323be611b6f25ba36d97f229af7c983125437c9/gcc%2Ffortran%2Ftrans-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b323be611b6f25ba36d97f229af7c983125437c9/gcc%2Ffortran%2Ftrans-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-common.c?ref=b323be611b6f25ba36d97f229af7c983125437c9", "patch": "@@ -339,7 +339,7 @@ build_field (segment_info *h, tree union_type, record_layout_info rli)\n /* Get storage for local equivalence.  */\n \n static tree\n-build_equiv_decl (tree union_type, bool is_init, bool is_saved)\n+build_equiv_decl (tree union_type, bool is_init, bool is_saved, bool is_auto)\n {\n   tree decl;\n   char name[18];\n@@ -359,8 +359,8 @@ build_equiv_decl (tree union_type, bool is_init, bool is_saved)\n   DECL_ARTIFICIAL (decl) = 1;\n   DECL_IGNORED_P (decl) = 1;\n \n-  if (!gfc_can_put_var_on_stack (DECL_SIZE_UNIT (decl))\n-      || is_saved)\n+  if (!is_auto && (!gfc_can_put_var_on_stack (DECL_SIZE_UNIT (decl))\n+      || is_saved))\n     TREE_STATIC (decl) = 1;\n \n   TREE_ADDRESSABLE (decl) = 1;\n@@ -611,6 +611,7 @@ create_common (gfc_common_head *com, segment_info *head, bool saw_equiv)\n   tree decl;\n   bool is_init = false;\n   bool is_saved = false;\n+  bool is_auto = false;\n \n   /* Declare the variables inside the common block.\n      If the current common block contains any equivalence object, then\n@@ -654,14 +655,18 @@ create_common (gfc_common_head *com, segment_info *head, bool saw_equiv)\n       /* Has SAVE attribute.  */\n       if (s->sym->attr.save)\n         is_saved = true;\n+\n+      /* Has AUTOMATIC attribute.  */\n+      if (s->sym->attr.automatic)\n+\tis_auto = true;\n     }\n \n   finish_record_layout (rli, true);\n \n   if (com)\n     decl = build_common_decl (com, union_type, is_init);\n   else\n-    decl = build_equiv_decl (union_type, is_init, is_saved);\n+    decl = build_equiv_decl (union_type, is_init, is_saved, is_auto);\n \n   if (is_init)\n     {\n@@ -948,6 +953,59 @@ add_condition (segment_info *f, gfc_equiv *eq1, gfc_equiv *eq2)\n     confirm_condition (f, eq1, n, eq2);\n }\n \n+static void\n+accumulate_equivalence_attributes (symbol_attribute *dummy_symbol, gfc_equiv *e)\n+{\n+  symbol_attribute attr = e->expr->symtree->n.sym->attr;\n+\n+  dummy_symbol->dummy |= attr.dummy;\n+  dummy_symbol->pointer |= attr.pointer;\n+  dummy_symbol->target |= attr.target;\n+  dummy_symbol->external |= attr.external;\n+  dummy_symbol->intrinsic |= attr.intrinsic;\n+  dummy_symbol->allocatable |= attr.allocatable;\n+  dummy_symbol->elemental |= attr.elemental;\n+  dummy_symbol->recursive |= attr.recursive;\n+  dummy_symbol->in_common |= attr.in_common;\n+  dummy_symbol->result |= attr.result;\n+  dummy_symbol->in_namelist |= attr.in_namelist;\n+  dummy_symbol->optional |= attr.optional;\n+  dummy_symbol->entry |= attr.entry;\n+  dummy_symbol->function |= attr.function;\n+  dummy_symbol->subroutine |= attr.subroutine;\n+  dummy_symbol->dimension |= attr.dimension;\n+  dummy_symbol->in_equivalence |= attr.in_equivalence;\n+  dummy_symbol->use_assoc |= attr.use_assoc;\n+  dummy_symbol->cray_pointer |= attr.cray_pointer;\n+  dummy_symbol->cray_pointee |= attr.cray_pointee;\n+  dummy_symbol->data |= attr.data;\n+  dummy_symbol->value |= attr.value;\n+  dummy_symbol->volatile_ |= attr.volatile_;\n+  dummy_symbol->is_protected |= attr.is_protected;\n+  dummy_symbol->is_bind_c |= attr.is_bind_c;\n+  dummy_symbol->procedure |= attr.procedure;\n+  dummy_symbol->proc_pointer |= attr.proc_pointer;\n+  dummy_symbol->abstract |= attr.abstract;\n+  dummy_symbol->asynchronous |= attr.asynchronous;\n+  dummy_symbol->codimension |= attr.codimension;\n+  dummy_symbol->contiguous |= attr.contiguous;\n+  dummy_symbol->generic |= attr.generic;\n+  dummy_symbol->automatic |= attr.automatic;\n+  dummy_symbol->threadprivate |= attr.threadprivate;\n+  dummy_symbol->omp_declare_target |= attr.omp_declare_target;\n+  dummy_symbol->omp_declare_target_link |= attr.omp_declare_target_link;\n+  dummy_symbol->oacc_declare_copyin |= attr.oacc_declare_copyin;\n+  dummy_symbol->oacc_declare_create |= attr.oacc_declare_create;\n+  dummy_symbol->oacc_declare_deviceptr |= attr.oacc_declare_deviceptr;\n+  dummy_symbol->oacc_declare_device_resident\n+    |= attr.oacc_declare_device_resident;\n+\n+  /* Not strictly correct, but probably close enough.  */\n+  if (attr.save > dummy_symbol->save)\n+    dummy_symbol->save = attr.save;\n+  if (attr.access > dummy_symbol->access)\n+    dummy_symbol->access = attr.access;\n+}\n \n /* Given a segment element, search through the equivalence lists for unused\n    conditions that involve the symbol.  Add these rules to the segment.  */\n@@ -965,16 +1023,21 @@ find_equivalence (segment_info *n)\n       eq = NULL;\n \n       /* Search the equivalence list, including the root (first) element\n-         for the symbol that owns the segment.  */\n+\t for the symbol that owns the segment.  */\n+      symbol_attribute dummy_symbol;\n+      memset (&dummy_symbol, 0, sizeof (dummy_symbol));\n       for (e2 = e1; e2; e2 = e2->eq)\n \t{\n+\t  accumulate_equivalence_attributes (&dummy_symbol, e2);\n \t  if (!e2->used && e2->expr->symtree->n.sym == n->sym)\n \t    {\n \t      eq = e2;\n \t      break;\n \t    }\n \t}\n \n+      gfc_check_conflict (&dummy_symbol, e1->expr->symtree->name, &e1->expr->where);\n+\n       /* Go to the next root element.  */\n       if (eq == NULL)\n \tcontinue;"}, {"sha": "08af213e05cdb0c1b3b63baf91989c5647d759ab", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b323be611b6f25ba36d97f229af7c983125437c9/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b323be611b6f25ba36d97f229af7c983125437c9/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b323be611b6f25ba36d97f229af7c983125437c9", "patch": "@@ -1,3 +1,9 @@\n+2019-08-16  Mark Eggleston <mark.eggleston@codethink.com>\n+\n+\t* gfortran.dg/auto_in_equiv_1.f90: New test.\n+\t* gfortran.dg/auto_in_equiv_2.f90: New test.\n+\t* gfortran.dg/auto_in_equiv_3.f90: New test.\n+\n 2019-08-16  Richard Biener  <rguenther@suse.de>\n \n \t* gcc.dg/tree-ssa/forwprop-31.c: Adjust."}, {"sha": "61bfd0738c52eeebf2c27d8f49eca481e637c979", "filename": "gcc/testsuite/gfortran.dg/auto_in_equiv_1.f90", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b323be611b6f25ba36d97f229af7c983125437c9/gcc%2Ftestsuite%2Fgfortran.dg%2Fauto_in_equiv_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b323be611b6f25ba36d97f229af7c983125437c9/gcc%2Ftestsuite%2Fgfortran.dg%2Fauto_in_equiv_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fauto_in_equiv_1.f90?ref=b323be611b6f25ba36d97f229af7c983125437c9", "patch": "@@ -0,0 +1,36 @@\n+! { dg-compile }\n+\n+! Contributed by Mark Eggleston <mark.eggleston@codethink.com>\n+program test\n+  call suba(0)\n+  call subb(0)\n+  call suba(1)\n+\n+contains\n+  subroutine suba(option) \n+    integer, intent(in) :: option\n+    integer, automatic :: a ! { dg-error \"AUTOMATIC at \\\\(1\\\\) is a DEC extension\" }\n+    integer :: b\n+    integer :: c\n+    equivalence (a, b)\n+    if (option.eq.0) then\n+      ! initialise a and c\n+      a = 9\n+      c = 99\n+      if (a.ne.b) stop 1\n+      if (loc(a).ne.loc(b)) stop 2\n+    else\n+      ! a should've been overwritten\n+      if (a.eq.9) stop 3\n+    end if\n+  end subroutine suba\n+\n+  subroutine subb(dummy)\n+    integer, intent(in) :: dummy\n+    integer, automatic :: x ! { dg-error \"AUTOMATIC at \\\\(1\\\\) is a DEC extension\" }\n+    integer :: y\n+    x = 77\n+    y = 7\n+  end subroutine subb\n+\n+end program test"}, {"sha": "406e718604a11e8e08ae2e4d5656283a8fcb22e6", "filename": "gcc/testsuite/gfortran.dg/auto_in_equiv_2.f90", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b323be611b6f25ba36d97f229af7c983125437c9/gcc%2Ftestsuite%2Fgfortran.dg%2Fauto_in_equiv_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b323be611b6f25ba36d97f229af7c983125437c9/gcc%2Ftestsuite%2Fgfortran.dg%2Fauto_in_equiv_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fauto_in_equiv_2.f90?ref=b323be611b6f25ba36d97f229af7c983125437c9", "patch": "@@ -0,0 +1,38 @@\n+! { dg-run }\n+! { dg-options \"-fdec-static\" }\n+\n+! Contributed by Mark Eggleston <mark.eggleston@codethink.com>\n+\n+program test\n+  call suba(0)\n+  call subb(0)\n+  call suba(1)\n+\n+contains\n+  subroutine suba(option) \n+    integer, intent(in) :: option\n+    integer, automatic :: a\n+    integer :: b\n+    integer :: c\n+    equivalence (a, b)\n+    if (option.eq.0) then\n+      ! initialise a and c\n+      a = 9\n+      c = 99\n+      if (a.ne.b) stop 1\n+      if (loc(a).ne.loc(b)) stop 2\n+    else\n+      ! a should've been overwritten\n+      if (a.eq.9) stop 3\n+    end if\n+  end subroutine suba\n+\n+  subroutine subb(dummy)\n+    integer, intent(in) :: dummy\n+    integer, automatic :: x\n+    integer :: y\n+    x = 77\n+    y = 7\n+  end subroutine subb\n+\n+end program test"}, {"sha": "c67aa8c6ac132ef171fe67c1e2f09a22b0482db1", "filename": "gcc/testsuite/gfortran.dg/auto_in_equiv_3.f90", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b323be611b6f25ba36d97f229af7c983125437c9/gcc%2Ftestsuite%2Fgfortran.dg%2Fauto_in_equiv_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b323be611b6f25ba36d97f229af7c983125437c9/gcc%2Ftestsuite%2Fgfortran.dg%2Fauto_in_equiv_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fauto_in_equiv_3.f90?ref=b323be611b6f25ba36d97f229af7c983125437c9", "patch": "@@ -0,0 +1,63 @@\n+! { dg-run }\n+! { dg-options \"-fdec-static -fno-automatic\" }\n+\n+! Contributed by Mark Eggleston <mark.eggleston@codethink.com>\n+\n+! Storage is NOT on the static unless explicitly specified using the\n+! DEC extension \"automatic\". The address of the first local variable\n+! is used to determine that storage for the automatic local variable\n+! is different to that of a local variable with no attributes. The\n+! contents of the local variable in suba should be overwritten by the\n+! call to subb. \n+!\n+program test\n+  integer :: dummy\n+  integer, parameter :: address = kind(loc(dummy))\n+  integer(address) :: ad1\n+  integer(address) :: ad2\n+  integer(address) :: ad3\n+  logical :: ok\n+\n+  call suba(0, ad1)\n+  call subb(0, ad2)\n+  call suba(1, ad1)\n+  call subc(0, ad3)\n+  ok = (ad1.eq.ad3).and.(ad1.ne.ad2)\n+  if (.not.ok) stop 4\n+\n+contains\n+  subroutine suba(option, addr) \n+    integer, intent(in) :: option\n+    integer(address), intent(out) :: addr\n+    integer, automatic :: a\n+    integer :: b\n+    equivalence (a, b)\n+    addr = loc(a)\n+    if (option.eq.0) then\n+      ! initialise a and c\n+      a = 9\n+      if (a.ne.b) stop 1\n+      if (loc(a).ne.loc(b)) stop 2\n+    else\n+      ! a should've been overwritten\n+      if (a.eq.9) stop 3\n+    end if\n+  end subroutine suba\n+\n+  subroutine subb(dummy, addr)\n+    integer, intent(in) :: dummy\n+    integer(address), intent(out) :: addr\n+    integer :: x\n+    addr = loc(x)\n+    x = 77\n+  end subroutine subb\n+\n+  subroutine subc(dummy, addr)\n+    integer, intent(in) :: dummy\n+    integer(address), intent(out) :: addr\n+    integer, automatic :: y\n+    addr = loc(y)\n+    y = 77\n+  end subroutine subc\n+\n+end program test"}]}