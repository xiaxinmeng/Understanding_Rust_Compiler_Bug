{"sha": "5ade1ed2c08bf2f327ee24afc57bc263fd90e6e1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWFkZTFlZDJjMDhiZjJmMzI3ZWUyNGFmYzU3YmMyNjNmZDkwZTZlMQ==", "commit": {"author": {"name": "Douglas Gregor", "email": "doug.gregor@gmail.com", "date": "2008-03-25T13:53:58Z"}, "committer": {"name": "Doug Gregor", "email": "dgregor@gcc.gnu.org", "date": "2008-03-25T13:53:58Z"}, "message": "typeck.c (composite_pointer_type_r): Add SFINAE support.\n\n2008-03-25  Douglas Gregor  <doug.gregor@gmail.com>\n\n       * typeck.c (composite_pointer_type_r): Add SFINAE support.\n       (composite_pointer_type): Ditto.\n       (common_type): Fix call to composite_pointer_type.\n       (cxx_sizeof_nowarn): New; used to be a macro.\n       (cxx_sizeof_expr): Add SFINAE support.\n       (cxx_alignof_expr): Ditto.\n       (decay_conversion): Fix calls for SFINAE support.\n       (rationalize_conditional_expr): Add SFINAE support.\n       (build_class_member_access_expr): Ditto.\n       (finish_class_member_access_expr): Ditto.\n       (build_x_indirect_ref): Ditto.\n       (build_indirect_ref): Original version renamed to\n       cp_build_indirect_ref; new version provides a bridge from\n       c-common.\n       (cp_build_indirect_ref): Was build_indirect_ref; added SFINAE\n       support.\n       (get_member_function_from_ptrfunc): Fix calls for SFINAE support.\n       (build_function_call): Original version renamed to\n       cp_build_function_call; new version provides a bridge from\n       c-common.\n       (cp_build_function_call): Was build_function_call; added SFINAE\n       support.\n       (convert_arguments): Add SFINAE support.\n       (build_x_binary_op): Ditto.\n       (build_binary_op): Original version renamed to cp_build_binary_op;\n       new version provides a bridge from c-common.\n       (cp_build_binary_op): Was build_binary_op; added SFINAE support.\n       (pointer_diff): Fix calls for SFINAE.\n       (build_x_unary_op): Add SFINAE support.\n       (condition_conversion): Fix calls for SFINAE.\n       (build_unary_op): Original version renamed to cp_build_unary_op;\n       new version provides a bridge from c-common.\n       (cp_build_unary_op): Was build_unary_op; added SFINAE support.\n       (unary_complex_lvalue): Fix calls for SFINAE.\n       (build_x_conditional_expr): Add SFINAE support.\n       (build_x_compound_expr_from_list): Fix calls for SFINAE.\n       (build_x_compound_expr): Add SFINAE support.\n       (convert_ptrmem): Fix calls for SFINAE.\n       (build_static_cast_1): Add SFINAE support.\n       (build_static_cast): Ditto.\n       (build_reinterpret_cast_1): Ditto.\n       (build_reinterpret_cast): Ditto.\n       (build_const_cast_1): Ditto.\n       (build_const_cast): Ditto.\n       (build_c_cast): Ditto.\n       (build_modify_expr): Original version renamed to\n       cp_build_modify_expr; new version provides a bridge from c-common.\n       (cp_build_modify_expr): Was build_modify_expr; added SFINAE\n       support.\n       (build_x_modify_expr): Add SFINAE support.\n       (build_ptrmemfunc): Fix calls for SFINAE.\n       (convert_for_assignment): Add SFINAE support.\n       (convert_for_initialization): Ditto.\n       (check_return_expr): Fix calls for SFINAE.\n       (lvalue_or_else): Add SFINAE support.\n       * init.c (perform_member_init): Fix calls for SFINAE.\n       (emit_mem_initializers): Ditto.\n       (expand_virtual_init): Ditto.\n       (expand_cleanup_for_base): Ditto.\n       (build_aggr_init): Add SFINAE support.\n       (expand_default_init): Ditto.\n       (expand_aggr_init_1): Fix calls for SFINAE.\n       (build_offset_ref): Ditto.\n       (build_new_1): Add SFINAE support.\n       (build_new): Ditto.\n       (build_vec_delete_1): Fix calls for SFINAE.\n       (get_temp_regvar): Ditto.\n       (build_vec_init): Add SFINAE support.\n       (build_dtor_call): Fix calls for SFINAE.\n       (build_delete): Ditto.\n       (push_base_cleanups): Ditto.\n       (build_vec_delete_1): Ditto.\n       * class.c (build_base_path): Fix calls for SFINAE.\n       (build_simple_base_path): Ditto.\n       (convert_to_base_statically): Ditto.\n       (build_vfn_ref): Ditto.\n       (resolve_address_of_overloaded_function): Ditto.\n       * decl.c (check_initializer): Fix calls for SFINAE.\n       (register_dtor_fn): Ditto.\n       (compute_array_index_type): Ditto.\n       (finish_enum): Ditto.\n       (start_preparsed_function): Ditto.\n       (cxx_maybe_build_cleanup): Ditto.\n       * call.c (convert_like): Add COMPLAIN argument.\n       (convert_like_with_context): Ditto.\n       (build_this): Fix calls for SFINAE.\n       (build_user_type_conversion): Ditto.\n       (resolve_args): Ditto.\n       (build_new_function_call): Add SFINAE support.\n       (build_operator_new_call): Fix calls for SFINAE.\n       (build_object_call): Add SFINAE support.\n       (build_conditional_expr): Ditto.\n       (build_new_op): Ditto.\n       (build_op_delete_call): Fix calls for SFINAE.\n       (build_temp): Ditto.\n       (convert_like_real): Add SFINAE support.\n       (build_x_va_arg): Fix calls for SFINAE.\n       (convert_default_arg): Ditto.\n       (build_over_call): Add SFINAE support.\n       (build_java_interface_fn_ref): Fix calls for SFINAE.\n       (build_special_member_call): Add SFINAE support.\n       (build_new_method_call): Ditto.\n       (perform_implicit_conversion): Ditto.\n       (perform_direct_initialization_if_possible): Ditto.\n       (initialize_reference): Fix calls for SFINAE.\n       * method.c (do_build_assign_ref): Fix calls for SFINAE.\n       * rtti.c (build_headof): Fix calls for SFINAE.\n       (get_tinfo_decl_dynamic): Ditto.\n       (get_typeid): Ditto.\n       (build_dynamic_cast_1): Add SFINAE support.\n       (build_dynamic_cast): Ditto.\n       (tinfo_base_init): Fix calls for SFINAE.\n       * except.c (do_get_exception_ptr): Fix calls for SFINAE.\n       (do_end_catch): Ditto.\n       (initialize_handler_parm): Ditto.\n       (expand_start_catch_block): Ditto.\n       (do_allocate_exception): Ditto.\n       (do_free_exception): Ditto.\n       (build_throw): Ditto.\n       * cvt.c (build_up_reference): Fix calls for SFINAE.\n       (convert_to_reference): Ditto.\n       (ocp_convert): Ditto.\n       (convert_to_void): Add SFINAE support.\n       * tree.c (build_dummy_object): Fix calls for SFINAE.\n       (stabilize_expr): Ditto.\n       * cp-tree.h (build_conditional_expr): Add tsubst_flags_t\n       parameter.\n       (build_new_method_call): Ditto.\n       (build_special_member_call): Ditto.\n       (build_new_op): Ditto.\n       (perform_implicit_conversion): Ditto.\n       (perform_direct_initialization_if_possible): Ditto.\n       (convert_to_void): Ditto.\n       (build_aggr_init): Ditto.\n       (build_new): Ditto.\n       (build_vec_init): Ditto.\n       (build_dynamic_cast): Ditto.\n       (finish_call_expr): Ditto\n       (cxx_sizeof_or_alignof_expr): Add COMPLAIN parameter.\n       (cxx_sizeof_nowarn): Remove macro; add function declaration.\n       (build_class_member_access_expr): Add tsubst_flags_t parameter.\n       (finish_class_member_access_expr): Ditto.\n       (build_x_indirect_ref): Ditto.\n       (cp_build_indirect_ref): New.\n       (cp_build_function_call): Add tsubst_flags_t parameter.\n       (build_x_unary_op): Ditto.\n       (cp_build_unary_op): New.\n       (build_x_conditional_expr): Add tsubst_flags_t parameter.\n       (build_x_compound_expr): Ditto.\n       (build_compound_expr): Ditto.\n       (build_static_cast): Ditto.\n       (build_reinterpret_cast): Ditto.\n       (build_const_cast): Ditto.\n       (build_c_cast): Ditto.\n       (build_x_modify_expr): Ditto.\n       (cp_build_modify_expr): New.\n       (convert_for_initialization): Add tsubst_flags_t parameter.\n       (cp_build_binary_op): Remove macro; add function declaration.\n       (invalid_nonstatic_memfn_p): Add tsubst_flags_t parameter.\n       (lvalue_or_else): Ditto.\n       (build_functional_cast): Ditto.\n       * typeck2.c (digest_init): Fix calls for SFINAE.\n       (process_init_constructor_array): Ditto.\n       (process_init_constructor_record): Ditto.\n       (build_x_arrow): Ditto.\n       (build_m_component_ref): Ditto.\n       (build_functional_cast): Add SFINAE support.\n       * pt.c (tsubst_copy_and_build): Add (more) SFINAE support.\n       * semantics.c (simplify_loop_decl_cond): Fix calls for SFINAE.\n       (finish_expr_stmt): Ditto.\n       (finish_for_expr): Ditto.\n       (finish_asm_stmt): Ditto.\n       (finish_non_static_data_member): Ditto.\n       (finish_qualified_id_expr): Ditto.\n       (finish_call_expr): Add SFINAE support.\n       (finish_increment_expr): Fix calls for SFINAE.\n       (finish_unary_op_expr): Ditto.\n       (simplify_aggr_init_expr): Ditto.\n       (finish_omp_clauses): Ditto.\n       (finish_omp_for): Ditto.\n       (finish_omp_barrier): Ditto.\n       (finish_omo_flush): Ditto.\n       * decl2.c (grok_array_decl): Fix calls or SFINAE.\n       (build_anon_union_vars): Ditto.\n       (get_guard_cond): Ditto.\n       (set_guard): Ditto.\n       (one_static_initialization_or_destruction): Ditto.\n       (do_static_initialization_or_destruction): Ditto.\n       (generate_ctor_or_dtor_function): Ditto.\n       (build_offset_ref_call_from_tree): Ditto.\n       * parser.c (cp_parser_postfix_expression): Fix calls for SFINAE.\n       (cp_parser_postfix_dot_deref_expression): Ditto.\n       (cp_parser_unary_expression): Ditto.\n       (cp_parser_new_expression): Ditto.\n       (cp_parser_cast_expression): Ditto.\n       (cp_parser_binary_expression): Ditto.\n       (cp_parser_question_colon_clause): Ditto.\n       (cp_parser_assignment_expression): Ditto.\n       (cp_parser_expression): Ditto.\n       (cp_parser_builtin_offsetof): Ditto.\n       (cp_parser_template_argument): Ditto.\n       (cp_parser_functional_cast): Ditto.\n\n2008-03-25  Douglas Gregor  <doug.gregor@gmail.com>\n\n       * c-common.c (c_sizeof_or_alignof_type): If we're not allowed to\n       complain when we hit an error, return ERROR_MARK_NODE.\n\n2008-03-25  Douglas Gregor  <doug.gregor@gmail.com>\n\n       * g++.dg/template/sfinae4.C: New.\n       * g++.dg/template/sfinae5.C: New.\n       * g++.dg/template/sfinae6.C: New.\n       * g++.dg/template/sfinae6_neg.C: New.\n       * g++.dg/template/sfinae7.C: New.\n       * g++.dg/template/sfinae8.C: New.\n       * g++.dg/template/sfinae9.C: New.\n       * g++.dg/template/sfinae10.C: New.\n       * g++.dg/template/sfinae11.C: New.\n       * g++.dg/template/sfinae12.C: New.\n       * g++.dg/template/sfinae13.C: New.\n       * g++.dg/template/sfinae14C: New.\n\nFrom-SVN: r133519", "tree": {"sha": "3ef47d27df52cfcaa5644727ec9e934a79cad636", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3ef47d27df52cfcaa5644727ec9e934a79cad636"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5ade1ed2c08bf2f327ee24afc57bc263fd90e6e1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ade1ed2c08bf2f327ee24afc57bc263fd90e6e1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5ade1ed2c08bf2f327ee24afc57bc263fd90e6e1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ade1ed2c08bf2f327ee24afc57bc263fd90e6e1/comments", "author": {"login": "DougGregor", "id": 989428, "node_id": "MDQ6VXNlcjk4OTQyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/989428?v=4", "gravatar_id": "", "url": "https://api.github.com/users/DougGregor", "html_url": "https://github.com/DougGregor", "followers_url": "https://api.github.com/users/DougGregor/followers", "following_url": "https://api.github.com/users/DougGregor/following{/other_user}", "gists_url": "https://api.github.com/users/DougGregor/gists{/gist_id}", "starred_url": "https://api.github.com/users/DougGregor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/DougGregor/subscriptions", "organizations_url": "https://api.github.com/users/DougGregor/orgs", "repos_url": "https://api.github.com/users/DougGregor/repos", "events_url": "https://api.github.com/users/DougGregor/events{/privacy}", "received_events_url": "https://api.github.com/users/DougGregor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "de6adfa2f4dfd7afd05eecab3b6cb6b2321d6ef2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de6adfa2f4dfd7afd05eecab3b6cb6b2321d6ef2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/de6adfa2f4dfd7afd05eecab3b6cb6b2321d6ef2"}], "stats": {"total": 3686, "additions": 2877, "deletions": 809}, "files": [{"sha": "05ece07463890b3e8e450d8c8732398072ff8da5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ade1ed2c08bf2f327ee24afc57bc263fd90e6e1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ade1ed2c08bf2f327ee24afc57bc263fd90e6e1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5ade1ed2c08bf2f327ee24afc57bc263fd90e6e1", "patch": "@@ -1,3 +1,8 @@\n+2008-03-25  Douglas Gregor  <doug.gregor@gmail.com>\n+\n+       * c-common.c (c_sizeof_or_alignof_type): If we're not allowed to\n+       complain when we hit an error, return ERROR_MARK_NODE.\n+\n 2008-03-25  Naveen.H.S  <naveen.hs@kpitcummins.com>\n \n \t* config/sh/constraints.md (Pso, Psz): New constraints."}, {"sha": "1b6297452394ec2e5af47f7f00c59a033727020c", "filename": "gcc/c-common.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ade1ed2c08bf2f327ee24afc57bc263fd90e6e1/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ade1ed2c08bf2f327ee24afc57bc263fd90e6e1/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=5ade1ed2c08bf2f327ee24afc57bc263fd90e6e1", "patch": "@@ -3347,6 +3347,8 @@ c_sizeof_or_alignof_type (tree type, bool is_sizeof, int complain)\n \t{\n \t  if (complain && (pedantic || warn_pointer_arith))\n \t    pedwarn (\"invalid application of %<sizeof%> to a function type\");\n+          else if (!complain)\n+            return error_mark_node;\n \t  value = size_one_node;\n \t}\n       else\n@@ -3357,6 +3359,8 @@ c_sizeof_or_alignof_type (tree type, bool is_sizeof, int complain)\n       if (type_code == VOID_TYPE\n \t  && complain && (pedantic || warn_pointer_arith))\n \tpedwarn (\"invalid application of %qs to a void type\", op_name);\n+      else if (!complain)\n+        return error_mark_node;\n       value = size_one_node;\n     }\n   else if (!COMPLETE_TYPE_P (type))"}, {"sha": "c90f58396bd2c109b4288ebf14fa5fa619afa256", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 205, "deletions": 0, "changes": 205, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ade1ed2c08bf2f327ee24afc57bc263fd90e6e1/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ade1ed2c08bf2f327ee24afc57bc263fd90e6e1/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=5ade1ed2c08bf2f327ee24afc57bc263fd90e6e1", "patch": "@@ -1,3 +1,208 @@\n+2008-03-25  Douglas Gregor  <doug.gregor@gmail.com>\n+\n+       * typeck.c (composite_pointer_type_r): Add SFINAE support.\n+       (composite_pointer_type): Ditto.\n+       (common_type): Fix call to composite_pointer_type.\n+       (cxx_sizeof_nowarn): New; used to be a macro.\n+       (cxx_sizeof_expr): Add SFINAE support.\n+       (cxx_alignof_expr): Ditto.\n+       (decay_conversion): Fix calls for SFINAE support.\n+       (rationalize_conditional_expr): Add SFINAE support.\n+       (build_class_member_access_expr): Ditto.\n+       (finish_class_member_access_expr): Ditto.\n+       (build_x_indirect_ref): Ditto.\n+       (build_indirect_ref): Original version renamed to\n+       cp_build_indirect_ref; new version provides a bridge from\n+       c-common.\n+       (cp_build_indirect_ref): Was build_indirect_ref; added SFINAE\n+       support.\n+       (get_member_function_from_ptrfunc): Fix calls for SFINAE support.\n+       (build_function_call): Original version renamed to\n+       cp_build_function_call; new version provides a bridge from\n+       c-common.\n+       (cp_build_function_call): Was build_function_call; added SFINAE\n+       support.\n+       (convert_arguments): Add SFINAE support.\n+       (build_x_binary_op): Ditto.\n+       (build_binary_op): Original version renamed to cp_build_binary_op;\n+       new version provides a bridge from c-common.\n+       (cp_build_binary_op): Was build_binary_op; added SFINAE support.\n+       (pointer_diff): Fix calls for SFINAE.\n+       (build_x_unary_op): Add SFINAE support.\n+       (condition_conversion): Fix calls for SFINAE.\n+       (build_unary_op): Original version renamed to cp_build_unary_op;\n+       new version provides a bridge from c-common.\n+       (cp_build_unary_op): Was build_unary_op; added SFINAE support.\n+       (unary_complex_lvalue): Fix calls for SFINAE.\n+       (build_x_conditional_expr): Add SFINAE support.\n+       (build_x_compound_expr_from_list): Fix calls for SFINAE.\n+       (build_x_compound_expr): Add SFINAE support.\n+       (convert_ptrmem): Fix calls for SFINAE.\n+       (build_static_cast_1): Add SFINAE support.\n+       (build_static_cast): Ditto.\n+       (build_reinterpret_cast_1): Ditto.\n+       (build_reinterpret_cast): Ditto.\n+       (build_const_cast_1): Ditto.\n+       (build_const_cast): Ditto.\n+       (build_c_cast): Ditto.\n+       (build_modify_expr): Original version renamed to\n+       cp_build_modify_expr; new version provides a bridge from c-common.\n+       (cp_build_modify_expr): Was build_modify_expr; added SFINAE\n+       support.\n+       (build_x_modify_expr): Add SFINAE support.\n+       (build_ptrmemfunc): Fix calls for SFINAE.\n+       (convert_for_assignment): Add SFINAE support.\n+       (convert_for_initialization): Ditto.\n+       (check_return_expr): Fix calls for SFINAE.\n+       (lvalue_or_else): Add SFINAE support.\n+       * init.c (perform_member_init): Fix calls for SFINAE.\n+       (emit_mem_initializers): Ditto.\n+       (expand_virtual_init): Ditto.\n+       (expand_cleanup_for_base): Ditto.\n+       (build_aggr_init): Add SFINAE support.\n+       (expand_default_init): Ditto.\n+       (expand_aggr_init_1): Fix calls for SFINAE.\n+       (build_offset_ref): Ditto.\n+       (build_new_1): Add SFINAE support.\n+       (build_new): Ditto.\n+       (build_vec_delete_1): Fix calls for SFINAE.\n+       (get_temp_regvar): Ditto.\n+       (build_vec_init): Add SFINAE support.\n+       (build_dtor_call): Fix calls for SFINAE.\n+       (build_delete): Ditto.\n+       (push_base_cleanups): Ditto.\n+       (build_vec_delete_1): Ditto.\n+       * class.c (build_base_path): Fix calls for SFINAE.\n+       (build_simple_base_path): Ditto.\n+       (convert_to_base_statically): Ditto.\n+       (build_vfn_ref): Ditto.\n+       (resolve_address_of_overloaded_function): Ditto.\n+       * decl.c (check_initializer): Fix calls for SFINAE.\n+       (register_dtor_fn): Ditto.\n+       (compute_array_index_type): Ditto.\n+       (finish_enum): Ditto.\n+       (start_preparsed_function): Ditto.\n+       (cxx_maybe_build_cleanup): Ditto.\n+       * call.c (convert_like): Add COMPLAIN argument.\n+       (convert_like_with_context): Ditto.\n+       (build_this): Fix calls for SFINAE.\n+       (build_user_type_conversion): Ditto.\n+       (resolve_args): Ditto.\n+       (build_new_function_call): Add SFINAE support.\n+       (build_operator_new_call): Fix calls for SFINAE.\n+       (build_object_call): Add SFINAE support.\n+       (build_conditional_expr): Ditto.\n+       (build_new_op): Ditto.\n+       (build_op_delete_call): Fix calls for SFINAE.\n+       (build_temp): Ditto.\n+       (convert_like_real): Add SFINAE support.\n+       (build_x_va_arg): Fix calls for SFINAE.\n+       (convert_default_arg): Ditto.\n+       (build_over_call): Add SFINAE support.\n+       (build_java_interface_fn_ref): Fix calls for SFINAE.\n+       (build_special_member_call): Add SFINAE support.\n+       (build_new_method_call): Ditto.\n+       (perform_implicit_conversion): Ditto.\n+       (perform_direct_initialization_if_possible): Ditto.\n+       (initialize_reference): Fix calls for SFINAE.\n+       * method.c (do_build_assign_ref): Fix calls for SFINAE.\n+       * rtti.c (build_headof): Fix calls for SFINAE.\n+       (get_tinfo_decl_dynamic): Ditto.\n+       (get_typeid): Ditto.\n+       (build_dynamic_cast_1): Add SFINAE support.\n+       (build_dynamic_cast): Ditto.\n+       (tinfo_base_init): Fix calls for SFINAE.\n+       * except.c (do_get_exception_ptr): Fix calls for SFINAE.\n+       (do_end_catch): Ditto.\n+       (initialize_handler_parm): Ditto.\n+       (expand_start_catch_block): Ditto.\n+       (do_allocate_exception): Ditto.\n+       (do_free_exception): Ditto.\n+       (build_throw): Ditto.\n+       * cvt.c (build_up_reference): Fix calls for SFINAE.\n+       (convert_to_reference): Ditto.\n+       (ocp_convert): Ditto.\n+       (convert_to_void): Add SFINAE support.\n+       * tree.c (build_dummy_object): Fix calls for SFINAE.\n+       (stabilize_expr): Ditto.\n+       * cp-tree.h (build_conditional_expr): Add tsubst_flags_t\n+       parameter.\n+       (build_new_method_call): Ditto.\n+       (build_special_member_call): Ditto.\n+       (build_new_op): Ditto.\n+       (perform_implicit_conversion): Ditto.\n+       (perform_direct_initialization_if_possible): Ditto.\n+       (convert_to_void): Ditto.\n+       (build_aggr_init): Ditto.\n+       (build_new): Ditto.\n+       (build_vec_init): Ditto.\n+       (build_dynamic_cast): Ditto.\n+       (finish_call_expr): Ditto\n+       (cxx_sizeof_or_alignof_expr): Add COMPLAIN parameter.\n+       (cxx_sizeof_nowarn): Remove macro; add function declaration.\n+       (build_class_member_access_expr): Add tsubst_flags_t parameter.\n+       (finish_class_member_access_expr): Ditto.\n+       (build_x_indirect_ref): Ditto.\n+       (cp_build_indirect_ref): New.\n+       (cp_build_function_call): Add tsubst_flags_t parameter.\n+       (build_x_unary_op): Ditto.\n+       (cp_build_unary_op): New.\n+       (build_x_conditional_expr): Add tsubst_flags_t parameter.\n+       (build_x_compound_expr): Ditto.\n+       (build_compound_expr): Ditto.\n+       (build_static_cast): Ditto.\n+       (build_reinterpret_cast): Ditto.\n+       (build_const_cast): Ditto.\n+       (build_c_cast): Ditto.\n+       (build_x_modify_expr): Ditto.\n+       (cp_build_modify_expr): New.\n+       (convert_for_initialization): Add tsubst_flags_t parameter.\n+       (cp_build_binary_op): Remove macro; add function declaration.\n+       (invalid_nonstatic_memfn_p): Add tsubst_flags_t parameter.\n+       (lvalue_or_else): Ditto.\n+       (build_functional_cast): Ditto.\n+       * typeck2.c (digest_init): Fix calls for SFINAE.\n+       (process_init_constructor_array): Ditto.\n+       (process_init_constructor_record): Ditto.\n+       (build_x_arrow): Ditto.\n+       (build_m_component_ref): Ditto.\n+       (build_functional_cast): Add SFINAE support.\n+       * pt.c (tsubst_copy_and_build): Add (more) SFINAE support.\n+       * semantics.c (simplify_loop_decl_cond): Fix calls for SFINAE.\n+       (finish_expr_stmt): Ditto.\n+       (finish_for_expr): Ditto.\n+       (finish_asm_stmt): Ditto.\n+       (finish_non_static_data_member): Ditto.\n+       (finish_qualified_id_expr): Ditto.\n+       (finish_call_expr): Add SFINAE support.\n+       (finish_increment_expr): Fix calls for SFINAE.\n+       (finish_unary_op_expr): Ditto.\n+       (simplify_aggr_init_expr): Ditto.\n+       (finish_omp_clauses): Ditto.\n+       (finish_omp_for): Ditto.\n+       (finish_omp_barrier): Ditto.\n+       (finish_omo_flush): Ditto.\n+       * decl2.c (grok_array_decl): Fix calls or SFINAE.\n+       (build_anon_union_vars): Ditto.\n+       (get_guard_cond): Ditto.\n+       (set_guard): Ditto.\n+       (one_static_initialization_or_destruction): Ditto.\n+       (do_static_initialization_or_destruction): Ditto.\n+       (generate_ctor_or_dtor_function): Ditto.\n+       (build_offset_ref_call_from_tree): Ditto.\n+       * parser.c (cp_parser_postfix_expression): Fix calls for SFINAE.\n+       (cp_parser_postfix_dot_deref_expression): Ditto.\n+       (cp_parser_unary_expression): Ditto.\n+       (cp_parser_new_expression): Ditto.\n+       (cp_parser_cast_expression): Ditto.\n+       (cp_parser_binary_expression): Ditto.\n+       (cp_parser_question_colon_clause): Ditto.\n+       (cp_parser_assignment_expression): Ditto.\n+       (cp_parser_expression): Ditto.\n+       (cp_parser_builtin_offsetof): Ditto.\n+       (cp_parser_template_argument): Ditto.\n+       (cp_parser_functional_cast): Ditto.\n+\n 2008-03-24  Tom Tromey  <tromey@redhat.com>\n \n \t* lex.c (handle_pragma_interface): Don't copy the filename."}, {"sha": "29dda07426fb80f604433d6417da8885a1385ed8", "filename": "gcc/cp/call.c", "status": "modified", "additions": 259, "deletions": 172, "changes": 431, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ade1ed2c08bf2f327ee24afc57bc263fd90e6e1/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ade1ed2c08bf2f327ee24afc57bc263fd90e6e1/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=5ade1ed2c08bf2f327ee24afc57bc263fd90e6e1", "patch": "@@ -126,21 +126,21 @@ static struct z_candidate * tourney (struct z_candidate *);\n static int equal_functions (tree, tree);\n static int joust (struct z_candidate *, struct z_candidate *, bool);\n static int compare_ics (conversion *, conversion *);\n-static tree build_over_call (struct z_candidate *, int);\n+static tree build_over_call (struct z_candidate *, int, tsubst_flags_t);\n static tree build_java_interface_fn_ref (tree, tree);\n-#define convert_like(CONV, EXPR)\t\t\t\t\\\n+#define convert_like(CONV, EXPR, COMPLAIN)\t\t\t\\\n   convert_like_real ((CONV), (EXPR), NULL_TREE, 0, 0,\t\t\\\n \t\t     /*issue_conversion_warnings=*/true,\t\\\n-\t\t     /*c_cast_p=*/false)\n-#define convert_like_with_context(CONV, EXPR, FN, ARGNO)\t\\\n-  convert_like_real ((CONV), (EXPR), (FN), (ARGNO), 0,\t\t\\\n-\t\t     /*issue_conversion_warnings=*/true,\t\\\n-\t\t     /*c_cast_p=*/false)\n+\t\t     /*c_cast_p=*/false, (COMPLAIN))\n+#define convert_like_with_context(CONV, EXPR, FN, ARGNO, COMPLAIN )\t\\\n+  convert_like_real ((CONV), (EXPR), (FN), (ARGNO), 0,\t\t\t\\\n+\t\t     /*issue_conversion_warnings=*/true,\t\t\\\n+\t\t     /*c_cast_p=*/false, (COMPLAIN))\n static tree convert_like_real (conversion *, tree, tree, int, int, bool,\n-\t\t\t       bool);\n+\t\t\t       bool, tsubst_flags_t);\n static void op_error (enum tree_code, enum tree_code, tree, tree,\n \t\t      tree, const char *);\n-static tree build_object_call (tree, tree);\n+static tree build_object_call (tree, tree, tsubst_flags_t);\n static tree resolve_args (tree);\n static struct z_candidate *build_user_type_conversion_1 (tree, tree, int);\n static void print_z_candidate (const char *, struct z_candidate *);\n@@ -2418,7 +2418,7 @@ build_this (tree obj)\n   if (processing_template_decl)\n     return build_address (obj);\n \n-  return build_unary_op (ADDR_EXPR, obj, 0);\n+  return cp_build_unary_op (ADDR_EXPR, obj, 0, tf_warning_or_error);\n }\n \n /* Returns true iff functions are equivalent. Equivalent functions are\n@@ -2750,7 +2750,7 @@ build_user_type_conversion (tree totype, tree expr, int flags)\n     {\n       if (cand->second_conv->kind == ck_ambig)\n \treturn error_mark_node;\n-      expr = convert_like (cand->second_conv, expr);\n+      expr = convert_like (cand->second_conv, expr, tf_warning_or_error);\n       return convert_from_reference (expr);\n     }\n   return NULL_TREE;\n@@ -2773,7 +2773,7 @@ resolve_args (tree args)\n \t  error (\"invalid use of void expression\");\n \t  return error_mark_node;\n \t}\n-      else if (invalid_nonstatic_memfn_p (arg))\n+      else if (invalid_nonstatic_memfn_p (arg, tf_warning_or_error))\n \treturn error_mark_node;\n     }\n   return args;\n@@ -2837,7 +2837,8 @@ perform_overload_resolution (tree fn,\n    or a static member function) with the ARGS.  */\n \n tree\n-build_new_function_call (tree fn, tree args, bool koenig_p)\n+build_new_function_call (tree fn, tree args, bool koenig_p, \n+\t\t\t tsubst_flags_t complain)\n {\n   struct z_candidate *candidates, *cand;\n   bool any_viable_p;\n@@ -2858,8 +2859,9 @@ build_new_function_call (tree fn, tree args, bool koenig_p)\n       fn = remove_hidden_names (fn);\n       if (!fn)\n \t{\n-\t  error (\"no matching function for call to %<%D(%A)%>\",\n-\t\t DECL_NAME (OVL_CURRENT (orig_fn)), args);\n+\t  if (complain & tf_error)\n+\t    error (\"no matching function for call to %<%D(%A)%>\",\n+\t\t   DECL_NAME (OVL_CURRENT (orig_fn)), args);\n \t  return error_mark_node;\n \t}\n     }\n@@ -2871,22 +2873,25 @@ build_new_function_call (tree fn, tree args, bool koenig_p)\n \n   if (!cand)\n     {\n-      if (!any_viable_p && candidates && ! candidates->next)\n-\treturn build_function_call (candidates->fn, args);\n-      if (TREE_CODE (fn) == TEMPLATE_ID_EXPR)\n-\tfn = TREE_OPERAND (fn, 0);\n-      if (!any_viable_p)\n-\terror (\"no matching function for call to %<%D(%A)%>\",\n-\t       DECL_NAME (OVL_CURRENT (fn)), args);\n-      else\n-\terror (\"call of overloaded %<%D(%A)%> is ambiguous\",\n-\t       DECL_NAME (OVL_CURRENT (fn)), args);\n-      if (candidates)\n-\tprint_z_candidates (candidates);\n+      if (complain & tf_error)\n+\t{\n+\t  if (!any_viable_p && candidates && ! candidates->next)\n+\t    return cp_build_function_call (candidates->fn, args, complain);\n+\t  if (TREE_CODE (fn) == TEMPLATE_ID_EXPR)\n+\t    fn = TREE_OPERAND (fn, 0);\n+\t  if (!any_viable_p)\n+\t    error (\"no matching function for call to %<%D(%A)%>\",\n+\t\t   DECL_NAME (OVL_CURRENT (fn)), args);\n+\t  else\n+\t    error (\"call of overloaded %<%D(%A)%> is ambiguous\",\n+\t\t   DECL_NAME (OVL_CURRENT (fn)), args);\n+\t  if (candidates)\n+\t    print_z_candidates (candidates);\n+\t}\n       result = error_mark_node;\n     }\n   else\n-    result = build_over_call (cand, LOOKUP_NORMAL);\n+    result = build_over_call (cand, LOOKUP_NORMAL, complain);\n \n   /* Free all the conversions we allocated.  */\n   obstack_free (&conversion_obstack, p);\n@@ -2997,11 +3002,11 @@ build_operator_new_call (tree fnname, tree args,\n      *fn = cand->fn;\n \n    /* Build the CALL_EXPR.  */\n-   return build_over_call (cand, LOOKUP_NORMAL);\n+   return build_over_call (cand, LOOKUP_NORMAL, tf_warning_or_error);\n }\n \n static tree\n-build_object_call (tree obj, tree args)\n+build_object_call (tree obj, tree args, tsubst_flags_t complain)\n {\n   struct z_candidate *candidates = 0, *cand;\n   tree fns, convs, mem_args = NULL_TREE;\n@@ -3012,9 +3017,10 @@ build_object_call (tree obj, tree args)\n \n   if (TYPE_PTRMEMFUNC_P (type))\n     {\n-      /* It's no good looking for an overloaded operator() on a\n-\t pointer-to-member-function.  */\n-      error (\"pointer-to-member function %E cannot be called without an object; consider using .* or ->*\", obj);\n+      if (complain & tf_error)\n+        /* It's no good looking for an overloaded operator() on a\n+           pointer-to-member-function.  */\n+        error (\"pointer-to-member function %E cannot be called without an object; consider using .* or ->*\", obj);\n       return error_mark_node;\n     }\n \n@@ -3088,30 +3094,38 @@ build_object_call (tree obj, tree args)\n   candidates = splice_viable (candidates, pedantic, &any_viable_p);\n   if (!any_viable_p)\n     {\n-      error (\"no match for call to %<(%T) (%A)%>\", TREE_TYPE (obj), args);\n-      print_z_candidates (candidates);\n+      if (complain & tf_error)\n+        {\n+          error (\"no match for call to %<(%T) (%A)%>\", TREE_TYPE (obj), args);\n+          print_z_candidates (candidates);\n+        }\n       result = error_mark_node;\n     }\n   else\n     {\n       cand = tourney (candidates);\n       if (cand == 0)\n \t{\n-\t  error (\"call of %<(%T) (%A)%> is ambiguous\", TREE_TYPE (obj), args);\n-\t  print_z_candidates (candidates);\n+          if (complain & tf_error)\n+            {\n+              error (\"call of %<(%T) (%A)%> is ambiguous\", \n+                     TREE_TYPE (obj), args);\n+              print_z_candidates (candidates);\n+            }\n \t  result = error_mark_node;\n \t}\n       /* Since cand->fn will be a type, not a function, for a conversion\n \t function, we must be careful not to unconditionally look at\n \t DECL_NAME here.  */\n       else if (TREE_CODE (cand->fn) == FUNCTION_DECL\n \t       && DECL_OVERLOADED_OPERATOR_P (cand->fn) == CALL_EXPR)\n-\tresult = build_over_call (cand, LOOKUP_NORMAL);\n+\tresult = build_over_call (cand, LOOKUP_NORMAL, complain);\n       else\n \t{\n-\t  obj = convert_like_with_context (cand->convs[0], obj, cand->fn, -1);\n+\t  obj = convert_like_with_context (cand->convs[0], obj, cand->fn, -1,\n+\t\t\t\t\t   complain);\n \t  obj = convert_from_reference (obj);\n-\t  result = build_function_call (obj, args);\n+\t  result = cp_build_function_call (obj, args, complain);\n \t}\n     }\n \n@@ -3232,7 +3246,8 @@ conditional_conversion (tree e1, tree e2)\n    arguments to the conditional expression.  */\n \n tree\n-build_conditional_expr (tree arg1, tree arg2, tree arg3)\n+build_conditional_expr (tree arg1, tree arg2, tree arg3,\n+                        tsubst_flags_t complain)\n {\n   tree arg2_type;\n   tree arg3_type;\n@@ -3249,7 +3264,7 @@ build_conditional_expr (tree arg1, tree arg2, tree arg3)\n      calculated only once.  */\n   if (!arg2)\n     {\n-      if (pedantic)\n+      if (pedantic && (complain & tf_error))\n \tpedwarn (\"ISO C++ forbids omitting the middle term of a ?: expression\");\n \n       /* Make sure that lvalues remain lvalues.  See g++.oliva/ext1.C.  */\n@@ -3263,7 +3278,7 @@ build_conditional_expr (tree arg1, tree arg2, tree arg3)\n \n      The first expr ession is implicitly converted to bool (clause\n      _conv_).  */\n-  arg1 = perform_implicit_conversion (boolean_type_node, arg1);\n+  arg1 = perform_implicit_conversion (boolean_type_node, arg1, complain);\n \n   /* If something has already gone wrong, just pass that fact up the\n      tree.  */\n@@ -3327,16 +3342,19 @@ build_conditional_expr (tree arg1, tree arg2, tree arg3)\n \tresult_type = void_type_node;\n       else\n \t{\n-\t  if (VOID_TYPE_P (arg2_type))\n-            error (\"second operand to the conditional operator \"\n-                   \"is of type %<void%>, \"\n-                   \"but the third operand is neither a throw-expression \"\n-                   \"nor of type %<void%>\");\n-\t  else\n-\t    error (\"third operand to the conditional operator \"\n-                   \"is of type %<void%>, \"\n-\t\t   \"but the second operand is neither a throw-expression \"\n-                   \"nor of type %<void%>\");\n+          if (complain & tf_error)\n+            {\n+              if (VOID_TYPE_P (arg2_type))\n+                error (\"second operand to the conditional operator \"\n+                       \"is of type %<void%>, \"\n+                       \"but the third operand is neither a throw-expression \"\n+                       \"nor of type %<void%>\");\n+              else\n+                error (\"third operand to the conditional operator \"\n+                       \"is of type %<void%>, \"\n+                       \"but the second operand is neither a throw-expression \"\n+                       \"nor of type %<void%>\");\n+            }\n \t  return error_mark_node;\n \t}\n \n@@ -3380,7 +3398,7 @@ build_conditional_expr (tree arg1, tree arg2, tree arg3)\n \t}\n       else if (conv2 && (!conv2->bad_p || !conv3))\n \t{\n-\t  arg2 = convert_like (conv2, arg2);\n+\t  arg2 = convert_like (conv2, arg2, complain);\n \t  arg2 = convert_from_reference (arg2);\n \t  arg2_type = TREE_TYPE (arg2);\n \t  /* Even if CONV2 is a valid conversion, the result of the\n@@ -3393,7 +3411,7 @@ build_conditional_expr (tree arg1, tree arg2, tree arg3)\n \t}\n       else if (conv3 && (!conv3->bad_p || !conv2))\n \t{\n-\t  arg3 = convert_like (conv3, arg3);\n+\t  arg3 = convert_like (conv3, arg3, complain);\n \t  arg3 = convert_from_reference (arg3);\n \t  arg3_type = TREE_TYPE (arg3);\n \t  if (error_operand_p (arg3))\n@@ -3477,15 +3495,21 @@ build_conditional_expr (tree arg1, tree arg2, tree arg3)\n       candidates = splice_viable (candidates, pedantic, &any_viable_p);\n       if (!any_viable_p)\n \t{\n-\t  op_error (COND_EXPR, NOP_EXPR, arg1, arg2, arg3, \"no match\");\n-\t  print_z_candidates (candidates);\n+          if (complain & tf_error)\n+            {\n+              op_error (COND_EXPR, NOP_EXPR, arg1, arg2, arg3, \"no match\");\n+              print_z_candidates (candidates);\n+            }\n \t  return error_mark_node;\n \t}\n       cand = tourney (candidates);\n       if (!cand)\n \t{\n-\t  op_error (COND_EXPR, NOP_EXPR, arg1, arg2, arg3, \"no match\");\n-\t  print_z_candidates (candidates);\n+          if (complain & tf_error)\n+            {\n+              op_error (COND_EXPR, NOP_EXPR, arg1, arg2, arg3, \"no match\");\n+              print_z_candidates (candidates);\n+            }\n \t  return error_mark_node;\n \t}\n \n@@ -3495,11 +3519,11 @@ build_conditional_expr (tree arg1, tree arg2, tree arg3)\n \t the converted operands are used in place of the original\n \t operands for the remainder of this section.  */\n       conv = cand->convs[0];\n-      arg1 = convert_like (conv, arg1);\n+      arg1 = convert_like (conv, arg1, complain);\n       conv = cand->convs[1];\n-      arg2 = convert_like (conv, arg2);\n+      arg2 = convert_like (conv, arg2, complain);\n       conv = cand->convs[2];\n-      arg3 = convert_like (conv, arg3);\n+      arg3 = convert_like (conv, arg3, complain);\n     }\n \n   /* [expr.cond]\n@@ -3548,17 +3572,25 @@ build_conditional_expr (tree arg1, tree arg2, tree arg3)\n \n       if (TREE_CODE (arg2_type) == ENUMERAL_TYPE\n \t  && TREE_CODE (arg3_type) == ENUMERAL_TYPE)\n-\t warning (0, \"enumeral mismatch in conditional expression: %qT vs %qT\",\n-\t\t   arg2_type, arg3_type);\n+        {\n+          if (complain & tf_warning)\n+            warning (0, \n+                     \"enumeral mismatch in conditional expression: %qT vs %qT\",\n+                     arg2_type, arg3_type);\n+        }\n       else if (extra_warnings\n \t       && ((TREE_CODE (arg2_type) == ENUMERAL_TYPE\n \t\t    && !same_type_p (arg3_type, type_promotes_to (arg2_type)))\n \t\t   || (TREE_CODE (arg3_type) == ENUMERAL_TYPE\n \t\t       && !same_type_p (arg2_type, type_promotes_to (arg3_type)))))\n-\twarning (0, \"enumeral and non-enumeral type in conditional expression\");\n+        {\n+          if (complain & tf_warning)\n+            warning (0, \n+                     \"enumeral and non-enumeral type in conditional expression\");\n+        }\n \n-      arg2 = perform_implicit_conversion (result_type, arg2);\n-      arg3 = perform_implicit_conversion (result_type, arg3);\n+      arg2 = perform_implicit_conversion (result_type, arg2, complain);\n+      arg3 = perform_implicit_conversion (result_type, arg3, complain);\n     }\n   /* [expr.cond]\n \n@@ -3585,17 +3617,19 @@ build_conditional_expr (tree arg1, tree arg2, tree arg3)\n \t   || (TYPE_PTRMEMFUNC_P (arg2_type) && TYPE_PTRMEMFUNC_P (arg3_type)))\n     {\n       result_type = composite_pointer_type (arg2_type, arg3_type, arg2,\n-\t\t\t\t\t    arg3, \"conditional expression\");\n+\t\t\t\t\t    arg3, \"conditional expression\",\n+\t\t\t\t\t    complain);\n       if (result_type == error_mark_node)\n \treturn error_mark_node;\n-      arg2 = perform_implicit_conversion (result_type, arg2);\n-      arg3 = perform_implicit_conversion (result_type, arg3);\n+      arg2 = perform_implicit_conversion (result_type, arg2, complain);\n+      arg3 = perform_implicit_conversion (result_type, arg3, complain);\n     }\n \n   if (!result_type)\n     {\n-      error (\"operands to ?: have different types %qT and %qT\",\n-\t     arg2_type, arg3_type);\n+      if (complain & tf_error)\n+        error (\"operands to ?: have different types %qT and %qT\",\n+               arg2_type, arg3_type);\n       return error_mark_node;\n     }\n \n@@ -3707,7 +3741,7 @@ add_candidates (tree fns, tree args,\n \n tree\n build_new_op (enum tree_code code, int flags, tree arg1, tree arg2, tree arg3,\n-\t      bool *overloaded_p)\n+\t      bool *overloaded_p, tsubst_flags_t complain)\n {\n   struct z_candidate *candidates = 0, *cand;\n   tree arglist, fnname;\n@@ -3747,7 +3781,7 @@ build_new_op (enum tree_code code, int flags, tree arg1, tree arg2, tree arg3,\n       gcc_unreachable ();\n \n     case CALL_EXPR:\n-      return build_object_call (arg1, arg2);\n+      return build_object_call (arg1, arg2, complain);\n \n     case TRUTH_ORIF_EXPR:\n     case TRUTH_ANDIF_EXPR:\n@@ -3856,6 +3890,11 @@ build_new_op (enum tree_code code, int flags, tree arg1, tree arg2, tree arg3,\n \t{\n \tcase POSTINCREMENT_EXPR:\n \tcase POSTDECREMENT_EXPR:\n+\t  /* Don't try anything fancy if we're not allowed to produce\n+\t     errors.  */\n+\t  if (!(complain & tf_error))\n+\t    return error_mark_node;\n+\n \t  /* Look for an `operator++ (int)'.  If they didn't have\n \t     one, then we fall back to the old way of doing things.  */\n \t  if (flags & LOOKUP_COMPLAIN)\n@@ -3868,7 +3907,7 @@ build_new_op (enum tree_code code, int flags, tree arg1, tree arg2, tree arg3,\n \t  else\n \t    code = PREDECREMENT_EXPR;\n \t  result = build_new_op (code, flags, arg1, NULL_TREE, NULL_TREE,\n-\t\t\t\t overloaded_p);\n+\t\t\t\t overloaded_p, complain);\n \t  break;\n \n \t  /* The caller will deal with these.  */\n@@ -3880,7 +3919,7 @@ build_new_op (enum tree_code code, int flags, tree arg1, tree arg2, tree arg3,\n \t  break;\n \n \tdefault:\n-\t  if (flags & LOOKUP_COMPLAIN)\n+\t  if ((flags & LOOKUP_COMPLAIN) && (complain & tf_error))\n \t    {\n \t      op_error (code, code2, arg1, arg2, arg3, \"no match\");\n \t      print_z_candidates (candidates);\n@@ -3894,7 +3933,7 @@ build_new_op (enum tree_code code, int flags, tree arg1, tree arg2, tree arg3,\n       cand = tourney (candidates);\n       if (cand == 0)\n \t{\n-\t  if (flags & LOOKUP_COMPLAIN)\n+\t  if ((flags & LOOKUP_COMPLAIN) && (complain & tf_error))\n \t    {\n \t      op_error (code, code2, arg1, arg2, arg3, \"ambiguous overload\");\n \t      print_z_candidates (candidates);\n@@ -3909,12 +3948,12 @@ build_new_op (enum tree_code code, int flags, tree arg1, tree arg2, tree arg3,\n \t  if (resolve_args (arglist) == error_mark_node)\n \t    result = error_mark_node;\n \t  else\n-\t    result = build_over_call (cand, LOOKUP_NORMAL);\n+\t    result = build_over_call (cand, LOOKUP_NORMAL, complain);\n \t}\n       else\n \t{\n \t  /* Give any warnings we noticed during overload resolution.  */\n-\t  if (cand->warnings)\n+\t  if (cand->warnings && (complain & tf_warning))\n \t    {\n \t      struct candidate_warning *w;\n \t      for (w = cand->warnings; w; w = w->next)\n@@ -3933,7 +3972,8 @@ build_new_op (enum tree_code code, int flags, tree arg1, tree arg2, tree arg3,\n \t      if (TREE_CODE (TREE_TYPE (arg1)) == ENUMERAL_TYPE\n \t\t  && TREE_CODE (TREE_TYPE (arg2)) == ENUMERAL_TYPE\n \t\t  && (TYPE_MAIN_VARIANT (TREE_TYPE (arg1))\n-\t\t      != TYPE_MAIN_VARIANT (TREE_TYPE (arg2))))\n+\t\t      != TYPE_MAIN_VARIANT (TREE_TYPE (arg2)))\n+\t\t  && (complain & tf_warning))\n \t\t{\n \t\t  warning (0, \"comparison between %q#T and %q#T\",\n \t\t\t   TREE_TYPE (arg1), TREE_TYPE (arg2));\n@@ -3950,25 +3990,26 @@ build_new_op (enum tree_code code, int flags, tree arg1, tree arg2, tree arg3,\n \t  conv = cand->convs[0];\n \t  if (conv->kind == ck_ref_bind)\n \t    conv = conv->u.next;\n-\t  arg1 = convert_like (conv, arg1);\n+\t  arg1 = convert_like (conv, arg1, complain);\n \t  if (arg2)\n \t    {\n \t      conv = cand->convs[1];\n \t      if (conv->kind == ck_ref_bind)\n \t\tconv = conv->u.next;\n-\t      arg2 = convert_like (conv, arg2);\n+\t      arg2 = convert_like (conv, arg2, complain);\n \t    }\n \t  if (arg3)\n \t    {\n \t      conv = cand->convs[2];\n \t      if (conv->kind == ck_ref_bind)\n \t\tconv = conv->u.next;\n-\t      arg3 = convert_like (conv, arg3);\n+\t      arg3 = convert_like (conv, arg3, complain);\n \t    }\n \n \t  if (!expl_eq_arg1) \n \t    {\n-\t      warn_logical_operator (code, arg1, arg2);\n+\t      if (complain & tf_warning)\n+\t\twarn_logical_operator (code, arg1, arg2);\n \t      expl_eq_arg1 = true;\n \t    }\n \t}\n@@ -3986,10 +4027,10 @@ build_new_op (enum tree_code code, int flags, tree arg1, tree arg2, tree arg3,\n   switch (code)\n     {\n     case MODIFY_EXPR:\n-      return build_modify_expr (arg1, code2, arg2);\n+      return cp_build_modify_expr (arg1, code2, arg2, complain);\n \n     case INDIRECT_REF:\n-      return build_indirect_ref (arg1, \"unary *\");\n+      return cp_build_indirect_ref (arg1, \"unary *\", complain);\n \n     case TRUTH_ANDIF_EXPR:\n     case TRUTH_ORIF_EXPR:\n@@ -4015,7 +4056,7 @@ build_new_op (enum tree_code code, int flags, tree arg1, tree arg2, tree arg3,\n     case BIT_AND_EXPR:\n     case BIT_IOR_EXPR:\n     case BIT_XOR_EXPR:\n-      return cp_build_binary_op (code, arg1, arg2);\n+      return cp_build_binary_op (code, arg1, arg2, complain);\n \n     case UNARY_PLUS_EXPR:\n     case NEGATE_EXPR:\n@@ -4027,16 +4068,18 @@ build_new_op (enum tree_code code, int flags, tree arg1, tree arg2, tree arg3,\n     case POSTDECREMENT_EXPR:\n     case REALPART_EXPR:\n     case IMAGPART_EXPR:\n-      return build_unary_op (code, arg1, candidates != 0);\n+      return cp_build_unary_op (code, arg1, candidates != 0, complain);\n \n     case ARRAY_REF:\n       return build_array_ref (arg1, arg2);\n \n     case COND_EXPR:\n-      return build_conditional_expr (arg1, arg2, arg3);\n+      return build_conditional_expr (arg1, arg2, arg3, complain);\n \n     case MEMBER_REF:\n-      return build_m_component_ref (build_indirect_ref (arg1, NULL), arg2);\n+      return build_m_component_ref (cp_build_indirect_ref (arg1, NULL, \n+                                                           complain), \n+                                    arg2);\n \n       /* The caller will deal with these.  */\n     case ADDR_EXPR:\n@@ -4205,7 +4248,7 @@ build_op_delete_call (enum tree_code code, tree addr, tree size,\n \t  else\n \t    args = tree_cons (NULL_TREE, addr,\n \t\t\t      build_tree_list (NULL_TREE, size));\n-\t  return build_function_call (fn, args);\n+\t  return cp_build_function_call (fn, args, tf_warning_or_error);\n \t}\n     }\n \n@@ -4268,7 +4311,7 @@ build_temp (tree expr, tree type, int flags,\n   expr = build_special_member_call (NULL_TREE,\n \t\t\t\t    complete_ctor_identifier,\n \t\t\t\t    build_tree_list (NULL_TREE, expr),\n-\t\t\t\t    type, flags);\n+\t\t\t\t    type, flags, tf_warning_or_error);\n   if (warningcount > savew)\n     *diagnostic_fn = warning0;\n   else if (errorcount > savee)\n@@ -4317,7 +4360,7 @@ conversion_null_warnings (tree totype, tree expr, tree fn, int argnum)\n static tree\n convert_like_real (conversion *convs, tree expr, tree fn, int argnum,\n \t\t   int inner, bool issue_conversion_warnings,\n-\t\t   bool c_cast_p)\n+\t\t   bool c_cast_p, tsubst_flags_t complain)\n {\n   tree totype = convs->type;\n   diagnostic_fn_t diagnostic_fn;\n@@ -4335,23 +4378,31 @@ convert_like_real (conversion *convs, tree expr, tree fn, int argnum,\n \t    {\n \t      expr = convert_like_real (t, expr, fn, argnum, 1,\n \t\t\t\t\t/*issue_conversion_warnings=*/false,\n-\t\t\t\t\t/*c_cast_p=*/false);\n+\t\t\t\t\t/*c_cast_p=*/false,\n+\t\t\t\t\tcomplain);\n \t      break;\n \t    }\n \t  else if (t->kind == ck_ambig)\n \t    return convert_like_real (t, expr, fn, argnum, 1,\n \t\t\t\t      /*issue_conversion_warnings=*/false,\n-\t\t\t\t      /*c_cast_p=*/false);\n+\t\t\t\t      /*c_cast_p=*/false,\n+\t\t\t\t      complain);\n \t  else if (t->kind == ck_identity)\n \t    break;\n \t}\n-      permerror (\"invalid conversion from %qT to %qT\", TREE_TYPE (expr), totype);\n-      if (fn)\n-\tpermerror (\"  initializing argument %P of %qD\", argnum, fn);\n+      if (complain & tf_error)\n+\t{\n+\t  permerror (\"invalid conversion from %qT to %qT\", TREE_TYPE (expr), totype);\n+\t  if (fn)\n+\t    permerror (\"  initializing argument %P of %qD\", argnum, fn);\n+\t}\n+      else\n+\treturn error_mark_node;\n+\n       return cp_convert (totype, expr);\n     }\n \n-  if (issue_conversion_warnings)\n+  if (issue_conversion_warnings && (complain & tf_warning))\n     conversion_null_warnings (totype, expr, fn, argnum);\n \n   switch (convs->kind)\n@@ -4367,7 +4418,7 @@ convert_like_real (conversion *convs, tree expr, tree fn, int argnum,\n \tfor (i = 0; i < cand->num_convs; ++i)\n \t  cand->convs[i]->user_conv_p = true;\n \n-\texpr = build_over_call (cand, LOOKUP_NORMAL);\n+\texpr = build_over_call (cand, LOOKUP_NORMAL, complain);\n \n \t/* If this is a constructor or a function returning an aggr type,\n \t   we need to build up a TARGET_EXPR.  */\n@@ -4394,7 +4445,7 @@ convert_like_real (conversion *convs, tree expr, tree fn, int argnum,\n \t\t     LOOKUP_NORMAL|LOOKUP_ONLYCONVERTING|LOOKUP_NO_CONVERSION,\n \t\t     &diagnostic_fn));\n \n-\t    if (diagnostic_fn)\n+\t    if (diagnostic_fn && (complain & tf_error))\n \t      {\n \t\tif (fn)\n \t\t  diagnostic_fn\n@@ -4410,7 +4461,7 @@ convert_like_real (conversion *convs, tree expr, tree fn, int argnum,\n       }\n     case ck_identity:\n       if (type_unknown_p (expr))\n-\texpr = instantiate_type (totype, expr, tf_warning_or_error);\n+\texpr = instantiate_type (totype, expr, complain);\n       /* Convert a constant to its underlying value, unless we are\n \t about to bind it to a reference, in which case we need to\n \t leave it as an lvalue.  */\n@@ -4436,7 +4487,8 @@ convert_like_real (conversion *convs, tree expr, tree fn, int argnum,\n   expr = convert_like_real (convs->u.next, expr, fn, argnum,\n \t\t\t    convs->kind == ck_ref_bind ? -1 : 1,\n \t\t\t    convs->kind == ck_ref_bind ? issue_conversion_warnings : false, \n-\t\t\t    c_cast_p);\n+\t\t\t    c_cast_p,\n+\t\t\t    complain);\n   if (expr == error_mark_node)\n     return error_mark_node;\n \n@@ -4453,10 +4505,10 @@ convert_like_real (conversion *convs, tree expr, tree fn, int argnum,\n \t  /* We are going to bind a reference directly to a base-class\n \t     subobject of EXPR.  */\n \t  /* Build an expression for `*((base*) &expr)'.  */\n-\t  expr = build_unary_op (ADDR_EXPR, expr, 0);\n+\t  expr = cp_build_unary_op (ADDR_EXPR, expr, 0, complain);\n \t  expr = convert_to_base (expr, build_pointer_type (totype),\n \t\t\t\t  !c_cast_p, /*nonnull=*/true);\n-\t  expr = build_indirect_ref (expr, \"implicit conversion\");\n+\t  expr = cp_build_indirect_ref (expr, \"implicit conversion\", complain);\n \t  return expr;\n \t}\n \n@@ -4470,7 +4522,12 @@ convert_like_real (conversion *convs, tree expr, tree fn, int argnum,\n \tflags |= LOOKUP_NO_CONVERSION;\n       expr = build_temp (expr, totype, flags, &diagnostic_fn);\n       if (diagnostic_fn && fn)\n-\tdiagnostic_fn (\"  initializing argument %P of %qD\", argnum, fn);\n+\t{\n+\t  if ((complain & tf_error))\n+\t    diagnostic_fn (\"  initializing argument %P of %qD\", argnum, fn);\n+\t  else if (diagnostic_fn == error)\n+\t    return error_mark_node;\n+\t}\n       return build_cplus_new (totype, expr);\n \n     case ck_ref_bind:\n@@ -4482,7 +4539,7 @@ convert_like_real (conversion *convs, tree expr, tree fn, int argnum,\n            VA_ARG_EXPR and CONSTRUCTOR expressions are special cases\n            that need temporaries, even when their types are reference\n            compatible with the type of reference being bound, so the\n-           upcoming call to build_unary_op (ADDR_EXPR, expr, ...)\n+           upcoming call to cp_build_unary_op (ADDR_EXPR, expr, ...)\n            doesn't fail.  */\n \tif (convs->need_temporary_p\n \t    || TREE_CODE (expr) == CONSTRUCTOR\n@@ -4494,16 +4551,19 @@ convert_like_real (conversion *convs, tree expr, tree fn, int argnum,\n \t    if (!CP_TYPE_CONST_NON_VOLATILE_P (TREE_TYPE (ref_type))\n \t\t&& !TYPE_REF_IS_RVALUE (ref_type))\n \t      {\n-\t\t/* If the reference is volatile or non-const, we\n-\t\t   cannot create a temporary.  */\n-\t\tif (lvalue & clk_bitfield)\n-\t\t  error (\"cannot bind bitfield %qE to %qT\",\n-\t\t\t expr, ref_type);\n-\t\telse if (lvalue & clk_packed)\n-\t\t  error (\"cannot bind packed field %qE to %qT\",\n-\t\t\t expr, ref_type);\n-\t\telse\n-\t\t  error (\"cannot bind rvalue %qE to %qT\", expr, ref_type);\n+\t\tif (complain & tf_error)\n+\t\t  {\n+\t\t    /* If the reference is volatile or non-const, we\n+\t\t       cannot create a temporary.  */\n+\t\t    if (lvalue & clk_bitfield)\n+\t\t      error (\"cannot bind bitfield %qE to %qT\",\n+\t\t\t     expr, ref_type);\n+\t\t    else if (lvalue & clk_packed)\n+\t\t      error (\"cannot bind packed field %qE to %qT\",\n+\t\t\t     expr, ref_type);\n+\t\t    else\n+\t\t      error (\"cannot bind rvalue %qE to %qT\", expr, ref_type);\n+\t\t  }\n \t\treturn error_mark_node;\n \t      }\n \t    /* If the source is a packed field, and we must use a copy\n@@ -4516,8 +4576,9 @@ convert_like_real (conversion *convs, tree expr, tree fn, int argnum,\n \t\t&& CLASS_TYPE_P (type)\n \t\t&& !TYPE_HAS_TRIVIAL_INIT_REF (type))\n \t      {\n-\t\terror (\"cannot bind packed field %qE to %qT\",\n-\t\t       expr, ref_type);\n+\t\tif (complain & tf_error)\n+\t\t  error (\"cannot bind packed field %qE to %qT\",\n+\t\t\t expr, ref_type);\n \t\treturn error_mark_node;\n \t      }\n \t    if (lvalue & clk_bitfield)\n@@ -4527,7 +4588,7 @@ convert_like_real (conversion *convs, tree expr, tree fn, int argnum,\n \n \t/* Take the address of the thing to which we will bind the\n \t   reference.  */\n-\texpr = build_unary_op (ADDR_EXPR, expr, 1);\n+\texpr = cp_build_unary_op (ADDR_EXPR, expr, 1, complain);\n \tif (expr == error_mark_node)\n \t  return error_mark_node;\n \n@@ -4652,7 +4713,7 @@ build_x_va_arg (tree expr, tree type)\n       expr = convert (build_pointer_type (type1), null_node);\n       expr = build2 (COMPOUND_EXPR, TREE_TYPE (expr),\n \t\t     call_builtin_trap (), expr);\n-      expr = build_indirect_ref (expr, NULL);\n+      expr = cp_build_indirect_ref (expr, NULL, tf_warning_or_error);\n       return expr;\n     }\n \n@@ -4719,7 +4780,8 @@ convert_default_arg (tree type, tree arg, tree fn, int parmnum)\n     {\n       arg = digest_init (type, arg);\n       arg = convert_for_initialization (0, type, arg, LOOKUP_NORMAL,\n-\t\t\t\t\t\"default argument\", fn, parmnum);\n+\t\t\t\t\t\"default argument\", fn, parmnum,\n+                                        tf_warning_or_error);\n     }\n   else\n     {\n@@ -4732,7 +4794,8 @@ convert_default_arg (tree type, tree arg, tree fn, int parmnum)\n       if (!CONSTANT_CLASS_P (arg))\n \targ = unshare_expr (arg);\n       arg = convert_for_initialization (0, type, arg, LOOKUP_NORMAL,\n-\t\t\t\t\t\"default argument\", fn, parmnum);\n+\t\t\t\t\t\"default argument\", fn, parmnum,\n+                                        tf_warning_or_error);\n       arg = convert_for_arg_passing (type, arg);\n     }\n \n@@ -4845,7 +4908,7 @@ magic_varargs_p (tree fn)\n    bitmask of various LOOKUP_* flags which apply to the call itself.  */\n \n static tree\n-build_over_call (struct z_candidate *cand, int flags)\n+build_over_call (struct z_candidate *cand, int flags, tsubst_flags_t complain)\n {\n   tree fn = cand->fn;\n   tree args = cand->args;\n@@ -4957,8 +5020,13 @@ build_over_call (struct z_candidate *cand, int flags)\n       tree base_binfo;\n \n       if (convs[i]->bad_p)\n-\tpermerror (\"passing %qT as %<this%> argument of %q#D discards qualifiers\",\n-\t\t TREE_TYPE (argtype), fn);\n+\t{\n+\t  if (complain & tf_error)\n+\t    permerror (\"passing %qT as %<this%> argument of %q#D discards qualifiers\",\n+\t\t       TREE_TYPE (argtype), fn);\n+\t  else\n+\t    return error_mark_node;\n+\t}\n \n       /* [class.mfct.nonstatic]: If a nonstatic member function of a class\n \t X is called for an object that is not of type X, or of a type\n@@ -5008,10 +5076,13 @@ build_over_call (struct z_candidate *cand, int flags)\n \tconv = conv->u.next;\n \n       val = convert_like_with_context\n-\t(conv, TREE_VALUE (arg), fn, i - is_method);\n+\t(conv, TREE_VALUE (arg), fn, i - is_method, complain);\n \n       val = convert_for_arg_passing (type, val);\n-      argarray[j++] = val;\n+      if ((complain == tf_none) && val == error_mark_node)\n+        return error_mark_node;\n+      else\n+        argarray[j++] = val;\n     }\n \n   /* Default arguments */\n@@ -5067,7 +5138,7 @@ build_over_call (struct z_candidate *cand, int flags)\n       if (targ)\n \targ = targ;\n       else\n-\targ = build_indirect_ref (arg, 0);\n+\targ = cp_build_indirect_ref (arg, 0, complain);\n \n       /* [class.copy]: the copy constructor is implicitly defined even if\n \t the implementation elided its use.  */\n@@ -5091,7 +5162,7 @@ build_over_call (struct z_candidate *cand, int flags)\n \t\t   && !move_fn_p (fn)))\n \t{\n \t  tree to = stabilize_reference\n-\t    (build_indirect_ref (TREE_VALUE (args), 0));\n+\t    (cp_build_indirect_ref (TREE_VALUE (args), 0, complain));\n \n \t  val = build2 (INIT_EXPR, DECL_CONTEXT (fn), to, arg);\n \t  return val;\n@@ -5102,14 +5173,14 @@ build_over_call (struct z_candidate *cand, int flags)\n \t   && TYPE_HAS_TRIVIAL_ASSIGN_REF (DECL_CONTEXT (fn)))\n     {\n       tree to = stabilize_reference\n-\t(build_indirect_ref (argarray[0], 0));\n+\t(cp_build_indirect_ref (argarray[0], 0, complain));\n       tree type = TREE_TYPE (to);\n       tree as_base = CLASSTYPE_AS_BASE (type);\n \n       arg = argarray[1];\n       if (tree_int_cst_equal (TYPE_SIZE (type), TYPE_SIZE (as_base)))\n \t{\n-\t  arg = build_indirect_ref (arg, 0);\n+\t  arg = cp_build_indirect_ref (arg, 0, complain);\n \t  val = build2 (MODIFY_EXPR, TREE_TYPE (to), to, arg);\n \t}\n       else\n@@ -5121,12 +5192,12 @@ build_over_call (struct z_candidate *cand, int flags)\n \n \t  arg2 = TYPE_SIZE_UNIT (as_base);\n \t  arg1 = arg;\n-\t  arg0 = build_unary_op (ADDR_EXPR, to, 0);\n+\t  arg0 = cp_build_unary_op (ADDR_EXPR, to, 0, complain);\n \t  t = implicit_built_in_decls[BUILT_IN_MEMCPY];\n \t  t = build_call_n (t, 3, arg0, arg1, arg2);\n \n \t  t = convert (TREE_TYPE (arg0), t);\n-\t  val = build_indirect_ref (t, 0);\n+\t  val = cp_build_indirect_ref (t, 0, complain);\n \t}\n \n       return val;\n@@ -5227,7 +5298,8 @@ build_java_interface_fn_ref (tree fn, tree instance)\n \n   /* Look up the pointer to the runtime java.lang.Class object for `instance'.\n      This is the first entry in the vtable.  */\n-  klass_ref = build_vtbl_ref (build_indirect_ref (instance, 0),\n+  klass_ref = build_vtbl_ref (cp_build_indirect_ref (instance, 0, \n+                                                     tf_warning_or_error),\n \t\t\t      integer_zero_node);\n \n   /* Get the java.lang.Class pointer for the interface being called.  */\n@@ -5300,7 +5372,7 @@ in_charge_arg_for_name (tree name)\n \n tree\n build_special_member_call (tree instance, tree name, tree args,\n-\t\t\t   tree binfo, int flags)\n+\t\t\t   tree binfo, int flags, tsubst_flags_t complain)\n {\n   tree fns;\n   /* The type of the subobject to be constructed or destroyed.  */\n@@ -5390,7 +5462,8 @@ build_special_member_call (tree instance, tree name, tree args,\n \n   return build_new_method_call (instance, fns, args,\n \t\t\t\tTYPE_BINFO (BINFO_TYPE (binfo)),\n-\t\t\t\tflags, /*fn=*/NULL);\n+\t\t\t\tflags, /*fn=*/NULL,\n+\t\t\t\tcomplain);\n }\n \n /* Return the NAME, as a C string.  The NAME indicates a function that\n@@ -5444,7 +5517,7 @@ name_as_c_string (tree name, tree type, bool *free_p)\n tree\n build_new_method_call (tree instance, tree fns, tree args,\n \t\t       tree conversion_path, int flags,\n-\t\t       tree *fn_p)\n+\t\t       tree *fn_p, tsubst_flags_t complain)\n {\n   struct z_candidate *candidates = 0, *cand;\n   tree explicit_targs = NULL_TREE;\n@@ -5477,7 +5550,8 @@ build_new_method_call (tree instance, tree fns, tree args,\n \n   if (!BASELINK_P (fns))\n     {\n-      error (\"call to non-function %qD\", fns);\n+      if (complain & tf_error)\n+\terror (\"call to non-function %qD\", fns);\n       return error_mark_node;\n     }\n \n@@ -5594,21 +5668,24 @@ build_new_method_call (tree instance, tree fns, tree args,\n   candidates = splice_viable (candidates, pedantic, &any_viable_p);\n   if (!any_viable_p)\n     {\n-      if (!COMPLETE_TYPE_P (basetype))\n-\tcxx_incomplete_type_error (instance_ptr, basetype);\n-      else\n+      if (complain & tf_error)\n \t{\n-\t  char *pretty_name;\n-\t  bool free_p;\n-\n-\t  pretty_name = name_as_c_string (name, basetype, &free_p);\n-\t  error (\"no matching function for call to %<%T::%s(%A)%#V%>\",\n-\t\t basetype, pretty_name, user_args,\n-\t\t TREE_TYPE (TREE_TYPE (instance_ptr)));\n-\t  if (free_p)\n-\t    free (pretty_name);\n+\t  if (!COMPLETE_TYPE_P (basetype))\n+\t    cxx_incomplete_type_error (instance_ptr, basetype);\n+\t  else\n+\t    {\n+\t      char *pretty_name;\n+\t      bool free_p;\n+\n+\t      pretty_name = name_as_c_string (name, basetype, &free_p);\n+\t      error (\"no matching function for call to %<%T::%s(%A)%#V%>\",\n+\t\t     basetype, pretty_name, user_args,\n+\t\t     TREE_TYPE (TREE_TYPE (instance_ptr)));\n+\t      if (free_p)\n+\t\tfree (pretty_name);\n+\t    }\n+\t  print_z_candidates (candidates);\n \t}\n-      print_z_candidates (candidates);\n       call = error_mark_node;\n     }\n   else\n@@ -5619,12 +5696,15 @@ build_new_method_call (tree instance, tree fns, tree args,\n \t  char *pretty_name;\n \t  bool free_p;\n \n-\t  pretty_name = name_as_c_string (name, basetype, &free_p);\n-\t  error (\"call of overloaded %<%s(%A)%> is ambiguous\", pretty_name,\n-\t\t user_args);\n-\t  print_z_candidates (candidates);\n-\t  if (free_p)\n-\t    free (pretty_name);\n+\t  if (complain & tf_error)\n+\t    {\n+\t      pretty_name = name_as_c_string (name, basetype, &free_p);\n+\t      error (\"call of overloaded %<%s(%A)%> is ambiguous\", pretty_name,\n+\t\t     user_args);\n+\t      print_z_candidates (candidates);\n+\t      if (free_p)\n+\t\tfree (pretty_name);\n+\t    }\n \t  call = error_mark_node;\n \t}\n       else\n@@ -5635,7 +5715,8 @@ build_new_method_call (tree instance, tree fns, tree args,\n \t      && DECL_PURE_VIRTUAL_P (fn)\n \t      && instance == current_class_ref\n \t      && (DECL_CONSTRUCTOR_P (current_function_decl)\n-\t\t  || DECL_DESTRUCTOR_P (current_function_decl)))\n+\t\t  || DECL_DESTRUCTOR_P (current_function_decl))\n+\t      && (complain & tf_warning))\n \t    /* This is not an error, it is runtime undefined\n \t       behavior.  */\n \t    warning (0, (DECL_CONSTRUCTOR_P (current_function_decl) ?\n@@ -5646,8 +5727,9 @@ build_new_method_call (tree instance, tree fns, tree args,\n \t  if (TREE_CODE (TREE_TYPE (fn)) == METHOD_TYPE\n \t      && is_dummy_object (instance_ptr))\n \t    {\n-\t      error (\"cannot call member function %qD without object\",\n-\t\t     fn);\n+\t      if (complain & tf_error)\n+\t\terror (\"cannot call member function %qD without object\",\n+\t\t       fn);\n \t      call = error_mark_node;\n \t    }\n \t  else\n@@ -5659,7 +5741,7 @@ build_new_method_call (tree instance, tree fns, tree args,\n \t      if (fn_p)\n \t\t*fn_p = fn;\n \t      /* Build the actual CALL_EXPR.  */\n-\t      call = build_over_call (cand, flags);\n+\t      call = build_over_call (cand, flags, complain);\n \t      /* In an expression of the form `a->f()' where `f' turns\n \t\t out to be a static member function, `a' is\n \t\t none-the-less evaluated.  */\n@@ -6608,7 +6690,7 @@ can_convert_arg_bad (tree to, tree from, tree arg)\n    doing a bad conversion, convert_like will complain.  */\n \n tree\n-perform_implicit_conversion (tree type, tree expr)\n+perform_implicit_conversion (tree type, tree expr, tsubst_flags_t complain)\n {\n   conversion *conv;\n   void *p;\n@@ -6624,7 +6706,8 @@ perform_implicit_conversion (tree type, tree expr)\n \t\t\t      LOOKUP_NORMAL);\n   if (!conv)\n     {\n-      error (\"could not convert %qE to %qT\", expr, type);\n+      if (complain & tf_error)\n+\terror (\"could not convert %qE to %qT\", expr, type);\n       expr = error_mark_node;\n     }\n   else if (processing_template_decl)\n@@ -6636,7 +6719,7 @@ perform_implicit_conversion (tree type, tree expr)\n \texpr = build_nop (type, expr);\n     }\n   else\n-    expr = convert_like (conv, expr);\n+    expr = convert_like (conv, expr, complain);\n \n   /* Free all the conversions we allocated.  */\n   obstack_free (&conversion_obstack, p);\n@@ -6655,7 +6738,8 @@ perform_implicit_conversion (tree type, tree expr)\n tree\n perform_direct_initialization_if_possible (tree type,\n \t\t\t\t\t   tree expr,\n-\t\t\t\t\t   bool c_cast_p)\n+\t\t\t\t\t   bool c_cast_p,\n+                                           tsubst_flags_t complain)\n {\n   conversion *conv;\n   void *p;\n@@ -6674,7 +6758,7 @@ perform_direct_initialization_if_possible (tree type,\n     {\n       expr = build_special_member_call (NULL_TREE, complete_ctor_identifier,\n \t\t\t\t\tbuild_tree_list (NULL_TREE, expr),\n-\t\t\t\t\ttype, LOOKUP_NORMAL);\n+\t\t\t\t\ttype, LOOKUP_NORMAL, complain);\n       return build_cplus_new (type, expr);\n     }\n \n@@ -6689,7 +6773,8 @@ perform_direct_initialization_if_possible (tree type,\n   else\n     expr = convert_like_real (conv, expr, NULL_TREE, 0, 0,\n \t\t\t      /*issue_conversion_warnings=*/false,\n-\t\t\t      c_cast_p);\n+\t\t\t      c_cast_p,\n+\t\t\t      tf_warning_or_error);\n \n   /* Free all the conversions we allocated.  */\n   obstack_free (&conversion_obstack, p);\n@@ -6824,7 +6909,8 @@ initialize_reference (tree type, tree expr, tree decl, tree *cleanup)\n \t\t\t\t/*fn=*/NULL_TREE, /*argnum=*/0,\n \t\t\t\t/*inner=*/-1,\n \t\t\t\t/*issue_conversion_warnings=*/true,\n-\t\t\t\t/*c_cast_p=*/false);\n+\t\t\t\t/*c_cast_p=*/false,\n+\t\t\t\ttf_warning_or_error);\n       if (error_operand_p (expr))\n \texpr = error_mark_node;\n       else\n@@ -6897,17 +6983,18 @@ initialize_reference (tree type, tree expr, tree decl, tree *cleanup)\n \t    }\n \t  else\n \t    /* Take the address of EXPR.  */\n-\t    expr = build_unary_op (ADDR_EXPR, expr, 0);\n+\t    expr = cp_build_unary_op (ADDR_EXPR, expr, 0, tf_warning_or_error);\n \t  /* If a BASE_CONV was required, perform it now.  */\n \t  if (base_conv_type)\n \t    expr = (perform_implicit_conversion\n-\t\t    (build_pointer_type (base_conv_type), expr));\n+\t\t    (build_pointer_type (base_conv_type), expr,\n+\t\t     tf_warning_or_error));\n \t  expr = build_nop (type, expr);\n \t}\n     }\n   else\n     /* Perform the conversion.  */\n-    expr = convert_like (conv, expr);\n+    expr = convert_like (conv, expr, tf_warning_or_error);\n \n   /* Free all the conversions we allocated.  */\n   obstack_free (&conversion_obstack, p);"}, {"sha": "69acf11cdfc80630296e5f0822893c5044d00546", "filename": "gcc/cp/class.c", "status": "modified", "additions": 18, "deletions": 12, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ade1ed2c08bf2f327ee24afc57bc263fd90e6e1/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ade1ed2c08bf2f327ee24afc57bc263fd90e6e1/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=5ade1ed2c08bf2f327ee24afc57bc263fd90e6e1", "patch": "@@ -284,7 +284,7 @@ build_base_path (enum tree_code code,\n \n   if (!want_pointer)\n     /* This must happen before the call to save_expr.  */\n-    expr = build_unary_op (ADDR_EXPR, expr, 0);\n+    expr = cp_build_unary_op (ADDR_EXPR, expr, 0, tf_warning_or_error);\n \n   offset = BINFO_OFFSET (binfo);\n   fixed_type_p = resolves_to_fixed_type_p (expr, &nonnull);\n@@ -345,7 +345,7 @@ build_base_path (enum tree_code code,\n \t interesting to the optimizers anyway.  */\n       && !has_empty)\n     {\n-      expr = build_indirect_ref (expr, NULL);\n+      expr = cp_build_indirect_ref (expr, NULL, tf_warning_or_error);\n       expr = build_simple_base_path (expr, binfo);\n       if (want_pointer)\n \texpr = build_address (expr);\n@@ -370,18 +370,20 @@ build_base_path (enum tree_code code,\n \t  t = TREE_TYPE (TYPE_VFIELD (current_class_type));\n \t  t = build_pointer_type (t);\n \t  v_offset = convert (t, current_vtt_parm);\n-\t  v_offset = build_indirect_ref (v_offset, NULL);\n+\t  v_offset = cp_build_indirect_ref (v_offset, NULL, \n+                                            tf_warning_or_error);\n \t}\n       else\n-\tv_offset = build_vfield_ref (build_indirect_ref (expr, NULL),\n+\tv_offset = build_vfield_ref (cp_build_indirect_ref (expr, NULL,\n+                                                            tf_warning_or_error),\n \t\t\t\t     TREE_TYPE (TREE_TYPE (expr)));\n \n       v_offset = build2 (POINTER_PLUS_EXPR, TREE_TYPE (v_offset),\n \t\t\t v_offset, fold_convert (sizetype, BINFO_VPTR_FIELD (v_binfo)));\n       v_offset = build1 (NOP_EXPR,\n \t\t\t build_pointer_type (ptrdiff_type_node),\n \t\t\t v_offset);\n-      v_offset = build_indirect_ref (v_offset, NULL);\n+      v_offset = cp_build_indirect_ref (v_offset, NULL, tf_warning_or_error);\n       TREE_CONSTANT (v_offset) = 1;\n       TREE_INVARIANT (v_offset) = 1;\n \n@@ -425,7 +427,7 @@ build_base_path (enum tree_code code,\n     null_test = NULL;\n \n   if (!want_pointer)\n-    expr = build_indirect_ref (expr, NULL);\n+    expr = cp_build_indirect_ref (expr, NULL, tf_warning_or_error);\n \n  out:\n   if (null_test)\n@@ -459,7 +461,7 @@ build_simple_base_path (tree expr, tree binfo)\n \t in the back end.  */\n       temp = unary_complex_lvalue (ADDR_EXPR, expr);\n       if (temp)\n-\texpr = build_indirect_ref (temp, NULL);\n+\texpr = cp_build_indirect_ref (temp, NULL, tf_warning_or_error);\n \n       return expr;\n     }\n@@ -551,7 +553,8 @@ convert_to_base_statically (tree expr, tree base)\n \t when processing a template because they do not handle C++-specific\n \t trees.  */\n       gcc_assert (!processing_template_decl);\n-      expr = build_unary_op (ADDR_EXPR, expr, /*noconvert=*/1);\n+      expr = cp_build_unary_op (ADDR_EXPR, expr, /*noconvert=*/1, \n+                             tf_warning_or_error);\n       if (!integer_zerop (BINFO_OFFSET (base)))\n         expr = fold_build2 (POINTER_PLUS_EXPR, pointer_type, expr,\n \t\t\t    fold_convert (sizetype, BINFO_OFFSET (base)));\n@@ -648,13 +651,16 @@ build_vfn_ref (tree instance_ptr, tree idx)\n {\n   tree aref;\n \n-  aref = build_vtbl_ref_1 (build_indirect_ref (instance_ptr, 0), idx);\n+  aref = build_vtbl_ref_1 (cp_build_indirect_ref (instance_ptr, 0,\n+                                                  tf_warning_or_error), \n+                           idx);\n \n   /* When using function descriptors, the address of the\n      vtable entry is treated as a function pointer.  */\n   if (TARGET_VTABLE_USES_DESCRIPTORS)\n     aref = build1 (NOP_EXPR, TREE_TYPE (aref),\n-\t\t   build_unary_op (ADDR_EXPR, aref, /*noconvert=*/1));\n+\t\t   cp_build_unary_op (ADDR_EXPR, aref, /*noconvert=*/1,\n+                                   tf_warning_or_error));\n \n   /* Remember this as a method reference, for later devirtualization.  */\n   aref = build3 (OBJ_TYPE_REF, TREE_TYPE (aref), aref, instance_ptr, idx);\n@@ -6098,10 +6104,10 @@ resolve_address_of_overloaded_function (tree target_type,\n     }\n \n   if (TYPE_PTRFN_P (target_type) || TYPE_PTRMEMFUNC_P (target_type))\n-    return build_unary_op (ADDR_EXPR, fn, 0);\n+    return cp_build_unary_op (ADDR_EXPR, fn, 0, flags);\n   else\n     {\n-      /* The target must be a REFERENCE_TYPE.  Above, build_unary_op\n+      /* The target must be a REFERENCE_TYPE.  Above, cp_build_unary_op\n \t will mark the function as addressed, but here we must do it\n \t explicitly.  */\n       cxx_mark_addressable (fn);"}, {"sha": "8387fd790e08c906119f11ee046a751233afc21d", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 62, "deletions": 37, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ade1ed2c08bf2f327ee24afc57bc263fd90e6e1/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ade1ed2c08bf2f327ee24afc57bc263fd90e6e1/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=5ade1ed2c08bf2f327ee24afc57bc263fd90e6e1", "patch": "@@ -4061,21 +4061,26 @@ extern cp_parameter_declarator *no_parameters;\n extern bool check_dtor_name\t\t\t(tree, tree);\n \n extern tree build_vfield_ref\t\t\t(tree, tree);\n-extern tree build_conditional_expr\t\t(tree, tree, tree);\n+extern tree build_conditional_expr\t\t(tree, tree, tree, \n+                                                 tsubst_flags_t);\n extern tree build_addr_func\t\t\t(tree);\n extern tree build_call_a\t\t\t(tree, int, tree*);\n extern tree build_call_n\t\t\t(tree, int, ...);\n extern bool null_ptr_cst_p\t\t\t(tree);\n extern bool sufficient_parms_p\t\t\t(const_tree);\n extern tree type_decays_to\t\t\t(tree);\n extern tree build_user_type_conversion\t\t(tree, tree, int);\n-extern tree build_new_function_call\t\t(tree, tree, bool);\n+extern tree build_new_function_call\t\t(tree, tree, bool, \n+\t\t\t\t\t\t tsubst_flags_t);\n extern tree build_operator_new_call\t\t(tree, tree, tree *, tree *,\n \t\t\t\t\t\t tree *);\n extern tree build_new_method_call\t\t(tree, tree, tree, tree, int,\n-\t\t\t\t\t\t tree *);\n-extern tree build_special_member_call\t\t(tree, tree, tree, tree, int);\n-extern tree build_new_op\t\t\t(enum tree_code, int, tree, tree, tree, bool *);\n+\t\t\t\t\t\t tree *, tsubst_flags_t);\n+extern tree build_special_member_call\t\t(tree, tree, tree, tree, int,\n+                                                 tsubst_flags_t);\n+extern tree build_new_op\t\t\t(enum tree_code, int, tree, \n+\t\t\t\t\t\t tree, tree, bool *,\n+\t\t\t\t\t\t tsubst_flags_t);\n extern tree build_op_delete_call\t\t(enum tree_code, tree, tree, bool, tree, tree);\n extern bool can_convert\t\t\t\t(tree, tree);\n extern bool can_convert_arg\t\t\t(tree, tree, tree, int);\n@@ -4091,8 +4096,9 @@ extern bool is_properly_derived_from\t\t(tree, tree);\n extern tree initialize_reference\t\t(tree, tree, tree, tree *);\n extern tree make_temporary_var_for_ref_to_temp\t(tree, tree);\n extern tree strip_top_quals\t\t\t(tree);\n-extern tree perform_implicit_conversion\t\t(tree, tree);\n-extern tree perform_direct_initialization_if_possible (tree, tree, bool);\n+extern tree perform_implicit_conversion\t\t(tree, tree, tsubst_flags_t);\n+extern tree perform_direct_initialization_if_possible (tree, tree, bool,\n+                                                       tsubst_flags_t);\n extern tree in_charge_arg_for_name\t\t(tree);\n extern tree build_cxx_call\t\t\t(tree, int, tree *);\n #ifdef ENABLE_CHECKING\n@@ -4159,7 +4165,8 @@ extern tree force_rvalue\t\t\t(tree);\n extern tree ocp_convert\t\t\t\t(tree, tree, int, int);\n extern tree cp_convert\t\t\t\t(tree, tree);\n extern tree cp_convert_and_check                (tree, tree);\n-extern tree convert_to_void\t(tree, const char */*implicit context*/);\n+extern tree convert_to_void\t(tree, const char */*implicit context*/,\n+                                 tsubst_flags_t);\n extern tree convert_force\t\t\t(tree, tree, int);\n extern tree build_expr_type_conversion\t\t(int, tree, bool);\n extern tree type_promotes_to\t\t\t(tree);\n@@ -4336,14 +4343,17 @@ extern tree do_friend\t\t\t\t(tree, tree, tree, tree, enum overload_flags, bool);\n /* in init.c */\n extern tree expand_member_init\t\t\t(tree);\n extern void emit_mem_initializers\t\t(tree);\n-extern tree build_aggr_init\t\t\t(tree, tree, int);\n+extern tree build_aggr_init\t\t\t(tree, tree, int,\n+                                                 tsubst_flags_t);\n extern int is_class_type\t\t\t(tree, int);\n extern tree get_type_value\t\t\t(tree);\n extern tree build_zero_init\t\t\t(tree, tree, bool);\n extern tree build_value_init\t\t\t(tree);\n extern tree build_offset_ref\t\t\t(tree, tree, bool);\n-extern tree build_new\t\t\t\t(tree, tree, tree, tree, int);\n-extern tree build_vec_init\t\t\t(tree, tree, tree, bool, int);\n+extern tree build_new\t\t\t\t(tree, tree, tree, tree, int,\n+                                                 tsubst_flags_t);\n+extern tree build_vec_init\t\t\t(tree, tree, tree, bool, int,\n+                                                 tsubst_flags_t);\n extern tree build_default_init                  (tree, tree);\n extern tree build_delete\t\t\t(tree, tree,\n \t\t\t\t\t\t special_function_kind,\n@@ -4482,7 +4492,7 @@ extern tree build_typeid\t\t\t(tree);\n extern tree get_tinfo_decl\t\t\t(tree);\n extern tree get_typeid\t\t\t\t(tree);\n extern tree build_headof\t\t\t(tree);\n-extern tree build_dynamic_cast\t\t\t(tree, tree);\n+extern tree build_dynamic_cast\t\t\t(tree, tree, tsubst_flags_t);\n extern void emit_support_tinfos\t\t\t(void);\n extern bool emit_tinfo_decl\t\t\t(tree);\n \n@@ -4613,7 +4623,8 @@ extern tree finish_stmt_expr_expr\t\t(tree, tree);\n extern tree finish_stmt_expr\t\t\t(tree, bool);\n extern tree stmt_expr_value_expr\t\t(tree);\n extern tree perform_koenig_lookup\t\t(tree, tree);\n-extern tree finish_call_expr\t\t\t(tree, tree, bool, bool);\n+extern tree finish_call_expr\t\t\t(tree, tree, bool, bool, \n+\t\t\t\t\t\t tsubst_flags_t);\n extern tree finish_increment_expr\t\t(tree, enum tree_code);\n extern tree finish_this_expr\t\t\t(void);\n extern tree finish_pseudo_destructor_expr       (tree, tree, tree);\n@@ -4762,36 +4773,49 @@ extern bool comptypes\t\t\t\t(tree, tree, int);\n extern bool compparms\t\t\t\t(const_tree, const_tree);\n extern int comp_cv_qualification\t\t(const_tree, const_tree);\n extern int comp_cv_qual_signature\t\t(tree, tree);\n-extern tree cxx_sizeof_or_alignof_expr\t\t(tree, enum tree_code);\n+extern tree cxx_sizeof_or_alignof_expr\t\t(tree, enum tree_code, bool);\n extern tree cxx_sizeof_or_alignof_type\t\t(tree, enum tree_code, bool);\n-#define cxx_sizeof_nowarn(T) cxx_sizeof_or_alignof_type (T, SIZEOF_EXPR, false)\n+extern tree cxx_sizeof_nowarn                   (tree);\n extern tree inline_conversion\t\t\t(tree);\n extern tree is_bitfield_expr_with_lowered_type  (const_tree);\n extern tree unlowered_expr_type                 (const_tree);\n extern tree decay_conversion\t\t\t(tree);\n-extern tree build_class_member_access_expr      (tree, tree, tree, bool);\n-extern tree finish_class_member_access_expr     (tree, tree, bool);\n-extern tree build_x_indirect_ref\t\t(tree, const char *);\n-extern tree build_indirect_ref\t\t\t(tree, const char *);\n+extern tree build_class_member_access_expr      (tree, tree, tree, bool,\n+\t\t\t\t\t\t tsubst_flags_t);\n+extern tree finish_class_member_access_expr     (tree, tree, bool, \n+\t\t\t\t\t\t tsubst_flags_t);\n+extern tree build_x_indirect_ref\t\t(tree, const char *, \n+                                                 tsubst_flags_t);\n+extern tree cp_build_indirect_ref\t\t(tree, const char *,\n+                                                 tsubst_flags_t);\n extern tree build_array_ref\t\t\t(tree, tree);\n extern tree get_member_function_from_ptrfunc\t(tree *, tree);\n+extern tree cp_build_function_call              (tree, tree, tsubst_flags_t);\n extern tree build_x_binary_op\t\t\t(enum tree_code, tree,\n \t\t\t\t\t\t enum tree_code, tree,\n-\t\t\t\t\t\t enum tree_code, bool *);\n-extern tree build_x_unary_op\t\t\t(enum tree_code, tree);\n+\t\t\t\t\t\t enum tree_code, bool *,\n+\t\t\t\t\t\t tsubst_flags_t);\n+extern tree build_x_unary_op\t\t\t(enum tree_code, tree,\n+                                                 tsubst_flags_t);\n+extern tree cp_build_unary_op                   (enum tree_code, tree, int, \n+                                                 tsubst_flags_t);\n extern tree unary_complex_lvalue\t\t(enum tree_code, tree);\n-extern tree build_x_conditional_expr\t\t(tree, tree, tree);\n+extern tree build_x_conditional_expr\t\t(tree, tree, tree, \n+                                                 tsubst_flags_t);\n extern tree build_x_compound_expr_from_list\t(tree, const char *);\n-extern tree build_x_compound_expr\t\t(tree, tree);\n-extern tree build_compound_expr\t\t\t(tree, tree);\n-extern tree build_static_cast\t\t\t(tree, tree);\n-extern tree build_reinterpret_cast\t\t(tree, tree);\n-extern tree build_const_cast\t\t\t(tree, tree);\n-extern tree build_c_cast\t\t\t(tree, tree);\n-extern tree build_x_modify_expr\t\t\t(tree, enum tree_code, tree);\n-extern tree build_modify_expr\t\t\t(tree, enum tree_code, tree);\n+extern tree build_x_compound_expr\t\t(tree, tree, tsubst_flags_t);\n+extern tree build_compound_expr\t\t\t(tree, tree, tsubst_flags_t);\n+extern tree build_static_cast\t\t\t(tree, tree, tsubst_flags_t);\n+extern tree build_reinterpret_cast\t\t(tree, tree, tsubst_flags_t);\n+extern tree build_const_cast\t\t\t(tree, tree, tsubst_flags_t);\n+extern tree build_c_cast\t\t\t(tree, tree, tsubst_flags_t);\n+extern tree build_x_modify_expr\t\t\t(tree, enum tree_code, tree,\n+\t\t\t\t\t\t tsubst_flags_t);\n+extern tree cp_build_modify_expr\t\t(tree, enum tree_code, tree,\n+\t\t\t\t\t\t tsubst_flags_t);\n extern tree convert_for_initialization\t\t(tree, tree, tree, int,\n-\t\t\t\t\t\t const char *, tree, int);\n+\t\t\t\t\t\t const char *, tree, int,\n+                                                 tsubst_flags_t);\n extern int comp_ptr_ttypes\t\t\t(tree, tree);\n extern bool comp_ptr_ttypes_const\t\t(tree, tree);\n extern int ptr_reasonably_similar\t\t(const_tree, const_tree);\n@@ -4805,21 +4829,22 @@ extern tree build_ptrmemfunc1\t\t\t(tree, tree, tree);\n extern void expand_ptrmemfunc_cst\t\t(tree, tree *, tree *);\n extern tree type_after_usual_arithmetic_conversions (tree, tree);\n extern tree composite_pointer_type\t\t(tree, tree, tree, tree,\n-\t\t\t\t\t\t const char*);\n+\t\t\t\t\t\t const char*, tsubst_flags_t);\n extern tree merge_types\t\t\t\t(tree, tree);\n extern tree check_return_expr\t\t\t(tree, bool *);\n-#define cp_build_binary_op(code, arg1, arg2) \\\n-  build_binary_op(code, arg1, arg2, 1)\n+extern tree cp_build_binary_op                  (enum tree_code, tree, tree,\n+\t\t\t\t\t\t tsubst_flags_t);\n #define cxx_sizeof(T)  cxx_sizeof_or_alignof_type (T, SIZEOF_EXPR, true)\n extern tree build_ptrmemfunc_access_expr\t(tree, tree);\n extern tree build_address\t\t\t(tree);\n extern tree build_nop\t\t\t\t(tree, tree);\n extern tree non_reference\t\t\t(tree);\n extern tree lookup_anon_field\t\t\t(tree, tree);\n-extern bool invalid_nonstatic_memfn_p\t\t(const_tree);\n+extern bool invalid_nonstatic_memfn_p\t\t(const_tree, tsubst_flags_t);\n extern tree convert_member_func_to_ptr\t\t(tree, tree);\n extern tree convert_ptrmem\t\t\t(tree, tree, bool, bool);\n-extern int lvalue_or_else\t\t\t(const_tree, enum lvalue_use);\n+extern int lvalue_or_else\t\t\t(const_tree, enum lvalue_use,\n+                                                 tsubst_flags_t);\n extern int lvalue_p\t\t\t\t(const_tree);\n \n /* in typeck2.c */\n@@ -4840,7 +4865,7 @@ extern tree digest_init\t\t\t\t(tree, tree);\n extern tree build_scoped_ref\t\t\t(tree, tree, tree *);\n extern tree build_x_arrow\t\t\t(tree);\n extern tree build_m_component_ref\t\t(tree, tree);\n-extern tree build_functional_cast\t\t(tree, tree);\n+extern tree build_functional_cast\t\t(tree, tree, tsubst_flags_t);\n extern tree add_exception_specifier\t\t(tree, tree, int);\n extern tree merge_exception_specifiers\t\t(tree, tree);\n "}, {"sha": "fe1ed29ec65a2c5fb2efbac3fce6ef10dd35349c", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 40, "deletions": 24, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ade1ed2c08bf2f327ee24afc57bc263fd90e6e1/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ade1ed2c08bf2f327ee24afc57bc263fd90e6e1/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=5ade1ed2c08bf2f327ee24afc57bc263fd90e6e1", "patch": "@@ -326,7 +326,7 @@ build_up_reference (tree type, tree arg, int flags, tree decl)\n   /* If we had a way to wrap this up, and say, if we ever needed its\n      address, transform all occurrences of the register, into a memory\n      reference we could win better.  */\n-  rval = build_unary_op (ADDR_EXPR, arg, 1);\n+  rval = cp_build_unary_op (ADDR_EXPR, arg, 1, tf_warning_or_error);\n   if (rval == error_mark_node)\n     return error_mark_node;\n \n@@ -470,7 +470,7 @@ convert_to_reference (tree reftype, tree expr, int convtype,\n \twarning (0, \"casting %qT to %qT does not dereference pointer\",\n \t\t intype, reftype);\n \n-      rval = build_unary_op (ADDR_EXPR, expr, 0);\n+      rval = cp_build_unary_op (ADDR_EXPR, expr, 0, tf_warning_or_error);\n       if (rval != error_mark_node)\n \trval = convert_force (build_pointer_type (TREE_TYPE (reftype)),\n \t\t\t      rval, 0);\n@@ -480,7 +480,8 @@ convert_to_reference (tree reftype, tree expr, int convtype,\n   else\n     {\n       rval = convert_for_initialization (NULL_TREE, type, expr, flags,\n-\t\t\t\t\t \"converting\", 0, 0);\n+\t\t\t\t\t \"converting\", 0, 0,\n+                                         tf_warning_or_error);\n       if (rval == NULL_TREE || rval == error_mark_node)\n \treturn rval;\n       warn_ref_binding (reftype, intype, decl);\n@@ -630,7 +631,7 @@ ocp_convert (tree type, tree expr, int convtype, int flags)\n \n   if (code == VOID_TYPE && (convtype & CONV_STATIC))\n     {\n-      e = convert_to_void (e, /*implicit=*/NULL);\n+      e = convert_to_void (e, /*implicit=*/NULL, tf_warning_or_error);\n       return e;\n     }\n \n@@ -734,7 +735,8 @@ ocp_convert (tree type, tree expr, int convtype, int flags)\n \tctor = build_special_member_call (NULL_TREE,\n \t\t\t\t\t  complete_ctor_identifier,\n \t\t\t\t\t  build_tree_list (NULL_TREE, ctor),\n-\t\t\t\t\t  type, flags);\n+\t\t\t\t\t  type, flags,\n+                                          tf_warning_or_error);\n       if (ctor)\n \treturn build_cplus_new (type, ctor);\n     }\n@@ -763,18 +765,19 @@ ocp_convert (tree type, tree expr, int convtype, int flags)\n    IMPLICIT is tells us the context of an implicit void conversion.  */\n \n tree\n-convert_to_void (tree expr, const char *implicit)\n+convert_to_void (tree expr, const char *implicit, tsubst_flags_t complain)\n {\n   if (expr == error_mark_node\n       || TREE_TYPE (expr) == error_mark_node)\n     return error_mark_node;\n   if (!TREE_TYPE (expr))\n     return expr;\n-  if (invalid_nonstatic_memfn_p (expr))\n+  if (invalid_nonstatic_memfn_p (expr, complain))\n     return error_mark_node;\n   if (TREE_CODE (expr) == PSEUDO_DTOR_EXPR)\n     {\n-      error (\"pseudo-destructor is not called\");\n+      if (complain & tf_error)\n+        error (\"pseudo-destructor is not called\");\n       return error_mark_node;\n     }\n   if (VOID_TYPE_P (TREE_TYPE (expr)))\n@@ -788,10 +791,10 @@ convert_to_void (tree expr, const char *implicit)\n \ttree op2 = TREE_OPERAND (expr,2);\n \ttree new_op1 = convert_to_void\n \t  (op1, (implicit && !TREE_SIDE_EFFECTS (op2)\n-\t\t ? \"second operand of conditional\" : NULL));\n+\t\t ? \"second operand of conditional\" : NULL), complain);\n \ttree new_op2 = convert_to_void\n \t  (op2, (implicit && !TREE_SIDE_EFFECTS (op1)\n-\t\t ? \"third operand of conditional\" : NULL));\n+\t\t ? \"third operand of conditional\" : NULL), complain);\n \n \texpr = build3 (COND_EXPR, TREE_TYPE (new_op1),\n \t\t       TREE_OPERAND (expr, 0), new_op1, new_op2);\n@@ -804,7 +807,7 @@ convert_to_void (tree expr, const char *implicit)\n \ttree op1 = TREE_OPERAND (expr,1);\n \ttree new_op1 = convert_to_void\n \t  (op1, (implicit && !TREE_NO_WARNING (expr)\n-\t\t ? \"right-hand operand of comma\" : NULL));\n+\t\t ? \"right-hand operand of comma\" : NULL), complain);\n \n \tif (new_op1 != op1)\n \t  {\n@@ -834,14 +837,20 @@ convert_to_void (tree expr, const char *implicit)\n \n \t/* Can't load the value if we don't know the type.  */\n \tif (is_volatile && !is_complete)\n-\t  warning (0, \"object of incomplete type %qT will not be accessed in %s\",\n-\t\t   type, implicit ? implicit : \"void context\");\n+          {\n+            if (complain & tf_warning)\n+              warning (0, \"object of incomplete type %qT will not be accessed in %s\",\n+                       type, implicit ? implicit : \"void context\");\n+          }\n \t/* Don't load the value if this is an implicit dereference, or if\n \t   the type needs to be handled by ctors/dtors.  */\n \telse if (is_volatile && (is_reference || TREE_ADDRESSABLE (type)))\n-\t  warning (0, \"object of type %qT will not be accessed in %s\",\n-\t\t   TREE_TYPE (TREE_OPERAND (expr, 0)),\n-\t\t   implicit ? implicit : \"void context\");\n+          {\n+            if (complain & tf_warning)\n+              warning (0, \"object of type %qT will not be accessed in %s\",\n+                       TREE_TYPE (TREE_OPERAND (expr, 0)),\n+                       implicit ? implicit : \"void context\");\n+          }\n \tif (is_reference || !is_volatile || !is_complete || TREE_ADDRESSABLE (type))\n \t  expr = TREE_OPERAND (expr, 0);\n \n@@ -854,7 +863,7 @@ convert_to_void (tree expr, const char *implicit)\n \ttree type = TREE_TYPE (expr);\n \tint is_complete = COMPLETE_TYPE_P (complete_type (type));\n \n-\tif (TYPE_VOLATILE (type) && !is_complete)\n+\tif (TYPE_VOLATILE (type) && !is_complete && (complain & tf_warning))\n \t  warning (0, \"object %qE of incomplete type %qT will not be accessed in %s\",\n \t\t   expr, type, implicit ? implicit : \"void context\");\n \tbreak;\n@@ -892,15 +901,19 @@ convert_to_void (tree expr, const char *implicit)\n       {\n \t/* [over.over] enumerates the places where we can take the address\n \t   of an overloaded function, and this is not one of them.  */\n-\terror (\"%s cannot resolve address of overloaded function\",\n-\t       implicit ? implicit : \"void cast\");\n+\tif (complain & tf_error)\n+\t  error (\"%s cannot resolve address of overloaded function\",\n+\t\t implicit ? implicit : \"void cast\");\n+\telse\n+\t  return error_mark_node;\n \texpr = void_zero_node;\n       }\n     else if (implicit && probe == expr && is_overloaded_fn (probe))\n       {\n \t/* Only warn when there is no &.  */\n-\twarning (OPT_Waddress, \"%s is a reference, not call, to function %qE\",\n-\t\t implicit, expr);\n+\tif (complain & tf_warning)\n+\t  warning (OPT_Waddress, \"%s is a reference, not call, to function %qE\",\n+\t\t   implicit, expr);\n \tif (TREE_CODE (expr) == COMPONENT_REF)\n \t  expr = TREE_OPERAND (expr, 0);\n       }\n@@ -915,8 +928,10 @@ convert_to_void (tree expr, const char *implicit)\n \t{\n \t  /* The middle end does not warn about expressions that have\n \t     been explicitly cast to void, so we must do so here.  */\n-\t  if (!TREE_SIDE_EFFECTS (expr))\n-\t    warning (OPT_Wunused_value, \"%s has no effect\", implicit);\n+\t  if (!TREE_SIDE_EFFECTS (expr)) {\n+            if (complain & tf_warning)\n+              warning (OPT_Wunused_value, \"%s has no effect\", implicit);\n+          }\n \t  else\n \t    {\n \t      tree e;\n@@ -939,7 +954,7 @@ convert_to_void (tree expr, const char *implicit)\n \n \t      code = TREE_CODE (e);\n \t      class = TREE_CODE_CLASS (code);\n-\t      if (class == tcc_comparison\n+\t      if ((class == tcc_comparison\n \t\t   || class == tcc_unary\n \t\t   || (class == tcc_binary\n \t\t       && !(code == MODIFY_EXPR\n@@ -948,6 +963,7 @@ convert_to_void (tree expr, const char *implicit)\n \t\t\t    || code == PREINCREMENT_EXPR\n \t\t\t    || code == POSTDECREMENT_EXPR\n \t\t\t    || code == POSTINCREMENT_EXPR)))\n+                  && (complain & tf_warning))\n \t\twarning (OPT_Wunused_value, \"value computed is not used\");\n \t    }\n \t}"}, {"sha": "df0b78c19715adabd98b0450e87a41dd12c9dca9", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ade1ed2c08bf2f327ee24afc57bc263fd90e6e1/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ade1ed2c08bf2f327ee24afc57bc263fd90e6e1/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=5ade1ed2c08bf2f327ee24afc57bc263fd90e6e1", "patch": "@@ -5027,7 +5027,7 @@ check_initializer (tree decl, tree init, int flags, tree *cleanup)\n \t\t  saved_stmts_are_full_exprs_p = stmts_are_full_exprs_p ();\n \t\t  current_stmt_tree ()->stmts_are_full_exprs_p = 1;\n \t\t}\n-\t      init = build_aggr_init (decl, init, flags);\n+\t      init = build_aggr_init (decl, init, flags, tf_warning_or_error);\n \t      if (building_stmt_tree ())\n \t\tcurrent_stmt_tree ()->stmts_are_full_exprs_p =\n \t\t  saved_stmts_are_full_exprs_p;\n@@ -5978,7 +5978,7 @@ register_dtor_fn (tree decl)\n \t  addr = build_address (decl);\n \t  /* The declared type of the parameter to \"__cxa_atexit\" is\n \t     \"void *\".  For plain \"T*\", we could just let the\n-\t     machinery in build_function_call convert it -- but if the\n+\t     machinery in cp_build_function_call convert it -- but if the\n \t     type is \"cv-qualified T *\", then we need to convert it\n \t     before passing it in, to avoid spurious errors.  */\n \t  addr = build_nop (ptr_type_node, addr);\n@@ -5990,7 +5990,8 @@ register_dtor_fn (tree decl)\n \t   other value.  */\n \taddr = null_pointer_node;\n       args = tree_cons (NULL_TREE,\n-\t\t\tbuild_unary_op (ADDR_EXPR, get_dso_handle_node (), 0),\n+\t\t\tcp_build_unary_op (ADDR_EXPR, get_dso_handle_node (), 0,\n+                                        tf_warning_or_error),\n \t\t\tNULL_TREE);\n       if (targetm.cxx.use_aeabi_atexit ())\n \t{\n@@ -6005,7 +6006,8 @@ register_dtor_fn (tree decl)\n     }\n   else\n     args = tree_cons (NULL_TREE, cleanup, NULL_TREE);\n-  return build_function_call (get_atexit_node (), args);\n+  return cp_build_function_call (get_atexit_node (), args, \n+\t\t\t\t tf_warning_or_error);\n }\n \n /* DECL is a VAR_DECL with static storage duration.  INIT, if present,\n@@ -7082,7 +7084,8 @@ compute_array_index_type (tree name, tree size)\n       processing_template_decl = 0;\n       itype = cp_build_binary_op (MINUS_EXPR,\n \t\t\t\t  cp_convert (ssizetype, size),\n-\t\t\t\t  cp_convert (ssizetype, integer_one_node));\n+\t\t\t\t  cp_convert (ssizetype, integer_one_node),\n+\t\t\t\t  tf_warning_or_error);\n       itype = fold (itype);\n       processing_template_decl = saved_processing_template_decl;\n \n@@ -10820,7 +10823,8 @@ finish_enum (tree enumtype)\n       saved_location = input_location;\n       input_location = DECL_SOURCE_LOCATION (decl);\n       value = perform_implicit_conversion (underlying_type,\n-\t\t\t\t\t   DECL_INITIAL (decl));\n+\t\t\t\t\t   DECL_INITIAL (decl),\n+\t\t\t\t\t   tf_warning_or_error);\n       input_location = saved_location;\n \n       /* Do not clobber shared ints.  */\n@@ -11282,7 +11286,7 @@ start_preparsed_function (tree decl1, tree attrs, int flags)\n       gcc_assert (TREE_CODE (TREE_TYPE (t)) == POINTER_TYPE);\n \n       cp_function_chain->x_current_class_ref\n-\t= build_indirect_ref (t, NULL);\n+\t= cp_build_indirect_ref (t, NULL, tf_warning_or_error);\n       cp_function_chain->x_current_class_ptr = t;\n \n       /* Constructors and destructors need to know whether they're \"in\n@@ -12199,8 +12203,9 @@ cxx_maybe_build_cleanup (tree decl)\n       fn = lookup_name (id);\n       arg = build_address (decl);\n       mark_used (decl);\n-      cleanup = build_function_call (fn, build_tree_list (NULL_TREE,\n-\t\t\t\t\t\t\t  arg));\n+      cleanup = cp_build_function_call (fn, build_tree_list (NULL_TREE,\n+\t\t\t\t\t\t\t     arg),\n+\t\t\t\t\ttf_warning_or_error);\n     }\n   /* Handle ordinary C++ destructors.  */\n   type = TREE_TYPE (decl);\n@@ -12224,7 +12229,7 @@ cxx_maybe_build_cleanup (tree decl)\n       call = build_delete (TREE_TYPE (addr), addr,\n \t\t\t   sfk_complete_destructor, flags, 0);\n       if (cleanup)\n-\tcleanup = build_compound_expr (cleanup, call);\n+\tcleanup = build_compound_expr (cleanup, call, tf_warning_or_error);\n       else\n \tcleanup = call;\n     }"}, {"sha": "078ca99e6f89ef791d821b61590fe4dc78726819", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 29, "deletions": 18, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ade1ed2c08bf2f327ee24afc57bc263fd90e6e1/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ade1ed2c08bf2f327ee24afc57bc263fd90e6e1/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=5ade1ed2c08bf2f327ee24afc57bc263fd90e6e1", "patch": "@@ -311,7 +311,7 @@ grok_array_decl (tree array_expr, tree index_exp)\n   if (MAYBE_CLASS_TYPE_P (type) || MAYBE_CLASS_TYPE_P (TREE_TYPE (index_exp)))\n     expr = build_new_op (ARRAY_REF, LOOKUP_NORMAL,\n \t\t\t array_expr, index_exp, NULL_TREE,\n-\t\t\t /*overloaded_p=*/NULL);\n+\t\t\t /*overloaded_p=*/NULL, tf_warning_or_error);\n   else\n     {\n       tree p1, p2, i1, i2;\n@@ -1190,7 +1190,7 @@ build_anon_union_vars (tree type, tree object)\n \t\t\t    DECL_NAME (field), NULL_TREE);\n       else\n \tref = build_class_member_access_expr (object, field, NULL_TREE,\n-\t\t\t\t\t      false);\n+\t\t\t\t\t      false, tf_warning_or_error);\n \n       if (DECL_NAME (field))\n \t{\n@@ -2436,13 +2436,15 @@ get_guard_cond (tree guard)\n       guard_value = integer_one_node;\n       if (!same_type_p (TREE_TYPE (guard_value), TREE_TYPE (guard)))\n \tguard_value = convert (TREE_TYPE (guard), guard_value);\n-\tguard = cp_build_binary_op (BIT_AND_EXPR, guard, guard_value);\n+      guard = cp_build_binary_op (BIT_AND_EXPR, guard, guard_value,\n+\t\t\t\t  tf_warning_or_error);\n     }\n \n   guard_value = integer_zero_node;\n   if (!same_type_p (TREE_TYPE (guard_value), TREE_TYPE (guard)))\n     guard_value = convert (TREE_TYPE (guard), guard_value);\n-  return cp_build_binary_op (EQ_EXPR, guard, guard_value);\n+  return cp_build_binary_op (EQ_EXPR, guard, guard_value,\n+\t\t\t     tf_warning_or_error);\n }\n \n /* Return an expression which sets the GUARD variable, indicating that\n@@ -2458,7 +2460,8 @@ set_guard (tree guard)\n   guard_init = integer_one_node;\n   if (!same_type_p (TREE_TYPE (guard_init), TREE_TYPE (guard)))\n     guard_init = convert (TREE_TYPE (guard), guard_init);\n-  return build_modify_expr (guard, NOP_EXPR, guard_init);\n+  return cp_build_modify_expr (guard, NOP_EXPR, guard_init, \n+\t\t\t       tf_warning_or_error);\n }\n \n /* Start the process of running a particular set of global constructors\n@@ -2787,17 +2790,21 @@ one_static_initialization_or_destruction (tree decl, tree init, bool initp)\n       else if (initp)\n \tguard_cond\n \t  = cp_build_binary_op (EQ_EXPR,\n-\t\t\t\tbuild_unary_op (PREINCREMENT_EXPR,\n+\t\t\t\tcp_build_unary_op (PREINCREMENT_EXPR,\n \t\t\t\t\t\tguard,\n-\t\t\t\t\t\t/*noconvert=*/1),\n-\t\t\t\tinteger_one_node);\n+\t\t\t\t\t\t/*noconvert=*/1,\n+                                                tf_warning_or_error),\n+\t\t\t\tinteger_one_node,\n+\t\t\t\ttf_warning_or_error);\n       else\n \tguard_cond\n \t  = cp_build_binary_op (EQ_EXPR,\n-\t\t\t\tbuild_unary_op (PREDECREMENT_EXPR,\n+\t\t\t\tcp_build_unary_op (PREDECREMENT_EXPR,\n \t\t\t\t\t\tguard,\n-\t\t\t\t\t\t/*noconvert=*/1),\n-\t\t\t\tinteger_zero_node);\n+\t\t\t\t\t\t/*noconvert=*/1,\n+                                                tf_warning_or_error),\n+\t\t\t\tinteger_zero_node,\n+\t\t\t\ttf_warning_or_error);\n \n       guard_if_stmt = begin_if_stmt ();\n       finish_if_stmt_cond (guard_cond, guard_if_stmt);\n@@ -2849,8 +2856,9 @@ do_static_initialization_or_destruction (tree vars, bool initp)\n   init_if_stmt = begin_if_stmt ();\n   cond = initp ? integer_one_node : integer_zero_node;\n   cond = cp_build_binary_op (EQ_EXPR,\n-\t\t\t\t  initialize_p_decl,\n-\t\t\t\t  cond);\n+\t\t\t     initialize_p_decl,\n+\t\t\t     cond,\n+\t\t\t     tf_warning_or_error);\n   finish_if_stmt_cond (cond, init_if_stmt);\n \n   node = vars;\n@@ -2882,7 +2890,8 @@ do_static_initialization_or_destruction (tree vars, bool initp)\n     priority_if_stmt = begin_if_stmt ();\n     cond = cp_build_binary_op (EQ_EXPR,\n \t\t\t       priority_decl,\n-\t\t\t       build_int_cst (NULL_TREE, priority));\n+\t\t\t       build_int_cst (NULL_TREE, priority),\n+\t\t\t       tf_warning_or_error);\n     finish_if_stmt_cond (cond, priority_if_stmt);\n \n     /* Process initializers with same priority.  */\n@@ -3031,7 +3040,8 @@ generate_ctor_or_dtor_function (bool constructor_p, int priority,\n \t  arguments = tree_cons (NULL_TREE,\n \t\t\t\t build_int_cst (NULL_TREE, constructor_p),\n \t\t\t\t arguments);\n-\t  finish_expr_stmt (build_function_call (fndecl, arguments));\n+\t  finish_expr_stmt (cp_build_function_call (fndecl, arguments,\n+\t\t\t\t\t\t    tf_warning_or_error));\n \t}\n     }\n \n@@ -3534,7 +3544,7 @@ build_offset_ref_call_from_tree (tree fn, tree args)\n       args = build_non_dependent_args (args);\n       object = build_non_dependent_expr (object);\n       if (TREE_CODE (fn) == DOTSTAR_EXPR)\n-\tobject = build_unary_op (ADDR_EXPR, object, 0);\n+\tobject = cp_build_unary_op (ADDR_EXPR, object, 0, tf_warning_or_error);\n       args = tree_cons (NULL_TREE, object, args);\n       /* Now that the arguments are done, transform FN.  */\n       fn = build_non_dependent_expr (fn);\n@@ -3548,13 +3558,14 @@ build_offset_ref_call_from_tree (tree fn, tree args)\n \tvoid B::g() { (this->*p)(); }  */\n   if (TREE_CODE (fn) == OFFSET_REF)\n     {\n-      tree object_addr = build_unary_op (ADDR_EXPR, object, 0);\n+      tree object_addr = cp_build_unary_op (ADDR_EXPR, object, 0,\n+                                         tf_warning_or_error);\n       fn = TREE_OPERAND (fn, 1);\n       fn = get_member_function_from_ptrfunc (&object_addr, fn);\n       args = tree_cons (NULL_TREE, object_addr, args);\n     }\n \n-  expr = build_function_call (fn, args);\n+  expr = cp_build_function_call (fn, args, tf_warning_or_error);\n   if (processing_template_decl && expr != error_mark_node)\n     return build_min_non_dep_call_list (expr, orig_fn, orig_args);\n   return expr;"}, {"sha": "5304381a4994169664e8734b16db21582229cff8", "filename": "gcc/cp/except.c", "status": "modified", "additions": 21, "deletions": 15, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ade1ed2c08bf2f327ee24afc57bc263fd90e6e1/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ade1ed2c08bf2f327ee24afc57bc263fd90e6e1/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=5ade1ed2c08bf2f327ee24afc57bc263fd90e6e1", "patch": "@@ -176,8 +176,9 @@ do_get_exception_ptr (void)\n       fn = push_library_fn (fn, build_function_type (ptr_type_node, tmp));\n     }\n \n-  return build_function_call (fn, tree_cons (NULL_TREE, build_exc_ptr (),\n-\t\t\t\t\t     NULL_TREE));\n+  return cp_build_function_call (fn, tree_cons (NULL_TREE, build_exc_ptr (),\n+\t\t\t\t\t\tNULL_TREE),\n+\t\t\t\t tf_warning_or_error);\n }\n \n /* Build up a call to __cxa_begin_catch, to tell the runtime that the\n@@ -196,8 +197,9 @@ do_begin_catch (void)\n       fn = push_library_fn (fn, build_function_type (ptr_type_node, tmp));\n     }\n \n-  return build_function_call (fn, tree_cons (NULL_TREE, build_exc_ptr (),\n-\t\t\t\t\t     NULL_TREE));\n+  return cp_build_function_call (fn, tree_cons (NULL_TREE, build_exc_ptr (),\n+\t\t\t\t\t\tNULL_TREE),\n+\t\t\t\t tf_warning_or_error);\n }\n \n /* Returns nonzero if cleaning up an exception of type TYPE (which can be\n@@ -235,7 +237,7 @@ do_end_catch (tree type)\n       TREE_NOTHROW (fn) = 0;\n     }\n \n-  cleanup = build_function_call (fn, NULL_TREE);\n+  cleanup = cp_build_function_call (fn, NULL_TREE, tf_warning_or_error);\n   TREE_NOTHROW (cleanup) = dtor_nothrow (type);\n \n   return cleanup;\n@@ -377,7 +379,7 @@ initialize_handler_parm (tree decl, tree exp)\n      pointer catch parm with the address of the temporary.  */\n   if (TREE_CODE (init_type) == REFERENCE_TYPE\n       && TYPE_PTR_P (TREE_TYPE (init_type)))\n-    exp = build_unary_op (ADDR_EXPR, exp, 1);\n+    exp = cp_build_unary_op (ADDR_EXPR, exp, 1, tf_warning_or_error);\n \n   exp = ocp_convert (init_type, exp, CONV_IMPLICIT|CONV_FORCE_TEMP, 0);\n \n@@ -434,7 +436,7 @@ expand_start_catch_block (tree decl)\n       exp = build2 (POINTER_PLUS_EXPR, TREE_TYPE (exp), exp,\n \t\t    fold_build1 (NEGATE_EXPR, sizetype,\n \t\t\t \t TYPE_SIZE_UNIT (TREE_TYPE (exp))));\n-      exp = build_indirect_ref (exp, NULL);\n+      exp = cp_build_indirect_ref (exp, NULL, tf_warning_or_error);\n       initialize_handler_parm (decl, exp);\n       return type;\n     }\n@@ -546,8 +548,10 @@ do_allocate_exception (tree type)\n       fn = push_library_fn (fn, build_function_type (ptr_type_node, tmp));\n     }\n \n-  return build_function_call (fn, tree_cons (NULL_TREE, size_in_bytes (type),\n-\t\t\t\t\t     NULL_TREE));\n+  return cp_build_function_call (fn, \n+\t\t\t\t tree_cons (NULL_TREE, size_in_bytes (type),\n+\t\t\t\t\t    NULL_TREE),\n+\t\t\t\t tf_warning_or_error);\n }\n \n /* Call __cxa_free_exception from a cleanup.  This is never invoked\n@@ -566,7 +570,8 @@ do_free_exception (tree ptr)\n \t\t\t\t\t\tvoid_list_node));\n     }\n \n-  return build_function_call (fn, tree_cons (NULL_TREE, ptr, NULL_TREE));\n+  return cp_build_function_call (fn, tree_cons (NULL_TREE, ptr, NULL_TREE),\n+\t\t\t\t tf_warning_or_error);\n }\n \n /* Wrap all cleanups for TARGET_EXPRs in MUST_NOT_THROW_EXPR.\n@@ -644,7 +649,8 @@ build_throw (tree exp)\n \t  return error_mark_node;\n \t}\n       fn = OVL_CURRENT (fn);\n-      exp = build_function_call (fn, tree_cons (NULL_TREE, exp, NULL_TREE));\n+      exp = cp_build_function_call (fn, tree_cons (NULL_TREE, exp, NULL_TREE),\n+\t\t\t\t    tf_warning_or_error);\n     }\n   else if (exp)\n     {\n@@ -708,7 +714,7 @@ build_throw (tree exp)\n       allocate_expr = get_target_expr (allocate_expr);\n       ptr = TARGET_EXPR_SLOT (allocate_expr);\n       object = build_nop (build_pointer_type (temp_type), ptr);\n-      object = build_indirect_ref (object, NULL);\n+      object = cp_build_indirect_ref (object, NULL, tf_warning_or_error);\n \n       elided = (TREE_CODE (exp) == TARGET_EXPR);\n \n@@ -733,7 +739,7 @@ build_throw (tree exp)\n \t\t (object, complete_ctor_identifier,\n \t\t  build_tree_list (NULL_TREE, exp),\n \t\t  TREE_TYPE (object),\n-\t\t  flags));\n+\t\t  flags, tf_warning_or_error));\n \t  if (exp == error_mark_node)\n \t    {\n \t      error (\"  in thrown expression\");\n@@ -812,7 +818,7 @@ build_throw (tree exp)\n       tmp = tree_cons (NULL_TREE, throw_type, tmp);\n       tmp = tree_cons (NULL_TREE, ptr, tmp);\n       /* ??? Indicate that this function call throws throw_type.  */\n-      tmp = build_function_call (fn, tmp);\n+      tmp = cp_build_function_call (fn, tmp, tf_warning_or_error);\n \n       /* Tack on the initialization stuff.  */\n       exp = build2 (COMPOUND_EXPR, TREE_TYPE (tmp), exp, tmp);\n@@ -831,7 +837,7 @@ build_throw (tree exp)\n \n       /* ??? Indicate that this function call allows exceptions of the type\n \t of the enclosing catch block (if known).  */\n-      exp = build_function_call (fn, NULL_TREE);\n+      exp = cp_build_function_call (fn, NULL_TREE, tf_warning_or_error);\n     }\n \n   exp = build1 (THROW_EXPR, void_type_node, exp);"}, {"sha": "dc4e988a3eec4a8868fe77d1fef969a76b43c17f", "filename": "gcc/cp/init.c", "status": "modified", "additions": 165, "deletions": 95, "changes": 260, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ade1ed2c08bf2f327ee24afc57bc263fd90e6e1/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ade1ed2c08bf2f327ee24afc57bc263fd90e6e1/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=5ade1ed2c08bf2f327ee24afc57bc263fd90e6e1", "patch": "@@ -39,8 +39,8 @@ along with GCC; see the file COPYING3.  If not see\n static bool begin_init_stmts (tree *, tree *);\n static tree finish_init_stmts (bool, tree, tree);\n static void construct_virtual_base (tree, tree);\n-static void expand_aggr_init_1 (tree, tree, tree, tree, int);\n-static void expand_default_init (tree, tree, tree, tree, int);\n+static void expand_aggr_init_1 (tree, tree, tree, tree, int, tsubst_flags_t);\n+static void expand_default_init (tree, tree, tree, tree, int, tsubst_flags_t);\n static tree build_vec_delete_1 (tree, tree, tree, special_function_kind, int);\n static void perform_member_init (tree, tree);\n static tree build_builtin_delete_call (tree);\n@@ -353,7 +353,8 @@ build_value_init_1 (tree type, bool have_ctor)\n \treturn build_cplus_new\n \t  (type,\n \t   build_special_member_call (NULL_TREE, complete_ctor_identifier,\n-\t\t\t\t      NULL_TREE, type, LOOKUP_NORMAL));\n+\t\t\t\t      NULL_TREE, type, LOOKUP_NORMAL,\n+\t\t\t\t      tf_warning_or_error));\n       else if (TREE_CODE (type) != UNION_TYPE)\n \t{\n \t  tree field, init;\n@@ -401,7 +402,7 @@ build_value_init_1 (tree type, bool have_ctor)\n \t\t cp_gimplify_init_expr will know how to handle it.  */\n \t      tree ctor = build_special_member_call\n \t\t(NULL_TREE, complete_ctor_identifier,\n-\t\t NULL_TREE, type, LOOKUP_NORMAL);\n+\t\t NULL_TREE, type, LOOKUP_NORMAL, tf_warning_or_error);\n \n \t      ctor = build_cplus_new (type, ctor);\n \t      init = build2 (INIT_EXPR, void_type_node,\n@@ -487,7 +488,8 @@ perform_member_init (tree member, tree init)\n   /* Get an lvalue for the data member.  */\n   decl = build_class_member_access_expr (current_class_ref, member,\n \t\t\t\t\t /*access_path=*/NULL_TREE,\n-\t\t\t\t\t /*preserve_reference=*/true);\n+\t\t\t\t\t /*preserve_reference=*/true,\n+\t\t\t\t\t tf_warning_or_error);\n   if (decl == error_mark_node)\n     return;\n \n@@ -513,10 +515,12 @@ perform_member_init (tree member, tree init)\n \t  /* Initialization of one array from another.  */\n \t  finish_expr_stmt (build_vec_init (decl, NULL_TREE, TREE_VALUE (init),\n \t\t\t\t\t    /*explicit_default_init_p=*/false,\n-\t\t\t\t\t    /* from_array=*/1));\n+\t\t\t\t\t    /* from_array=*/1,\n+                                            tf_warning_or_error));\n \t}\n       else\n-\tfinish_expr_stmt (build_aggr_init (decl, init, 0));\n+\tfinish_expr_stmt (build_aggr_init (decl, init, 0, \n+                                           tf_warning_or_error));\n     }\n   else\n     {\n@@ -544,7 +548,8 @@ perform_member_init (tree member, tree init)\n \tinit = build_x_compound_expr_from_list (init, \"member initializer\");\n \n       if (init)\n-\tfinish_expr_stmt (build_modify_expr (decl, INIT_EXPR, init));\n+\tfinish_expr_stmt (cp_build_modify_expr (decl, INIT_EXPR, init,\n+\t\t\t\t\t\ttf_warning_or_error));\n     }\n \n   if (TYPE_HAS_NONTRIVIAL_DESTRUCTOR (type))\n@@ -553,7 +558,8 @@ perform_member_init (tree member, tree init)\n \n       expr = build_class_member_access_expr (current_class_ref, member,\n \t\t\t\t\t     /*access_path=*/NULL_TREE,\n-\t\t\t\t\t     /*preserve_reference=*/false);\n+\t\t\t\t\t     /*preserve_reference=*/false,\n+\t\t\t\t\t     tf_warning_or_error);\n       expr = build_delete (type, expr, sfk_complete_destructor,\n \t\t\t   LOOKUP_NONVIRTUAL|LOOKUP_DESTRUCTOR, 0);\n \n@@ -855,9 +861,11 @@ emit_mem_initializers (tree mem_inits)\n \t  base_addr = build_base_path (PLUS_EXPR, current_class_ptr,\n \t\t\t\t       subobject, 1);\n \t  expand_aggr_init_1 (subobject, NULL_TREE,\n-\t\t\t      build_indirect_ref (base_addr, NULL),\n+\t\t\t      cp_build_indirect_ref (base_addr, NULL,\n+                                                     tf_warning_or_error),\n \t\t\t      arguments,\n-\t\t\t      LOOKUP_NORMAL);\n+\t\t\t      LOOKUP_NORMAL,\n+                              tf_warning_or_error);\n \t  expand_cleanup_for_base (subobject, NULL_TREE);\n \t}\n \n@@ -938,7 +946,7 @@ expand_virtual_init (tree binfo, tree decl)\n \t\t      TREE_TYPE (vtt_parm),\n \t\t      vtt_parm,\n \t\t      vtt_index);\n-      vtbl2 = build_indirect_ref (vtbl2, NULL);\n+      vtbl2 = cp_build_indirect_ref (vtbl2, NULL, tf_warning_or_error);\n       vtbl2 = convert (TREE_TYPE (vtbl), vtbl2);\n \n       /* The actual initializer is the VTT value only in the subobject\n@@ -953,13 +961,15 @@ expand_virtual_init (tree binfo, tree decl)\n     }\n \n   /* Compute the location of the vtpr.  */\n-  vtbl_ptr = build_vfield_ref (build_indirect_ref (decl, NULL),\n+  vtbl_ptr = build_vfield_ref (cp_build_indirect_ref (decl, NULL, \n+                                                      tf_warning_or_error),\n \t\t\t       TREE_TYPE (binfo));\n   gcc_assert (vtbl_ptr != error_mark_node);\n \n   /* Assign the vtable to the vptr.  */\n   vtbl = convert_force (TREE_TYPE (vtbl_ptr), vtbl, 0);\n-  finish_expr_stmt (build_modify_expr (vtbl_ptr, NOP_EXPR, vtbl));\n+  finish_expr_stmt (cp_build_modify_expr (vtbl_ptr, NOP_EXPR, vtbl,\n+\t\t\t\t\t  tf_warning_or_error));\n }\n \n /* If an exception is thrown in a constructor, those base classes already\n@@ -981,7 +991,8 @@ expand_cleanup_for_base (tree binfo, tree flag)\n \t\t\t\t    base_dtor_identifier,\n \t\t\t\t    NULL_TREE,\n \t\t\t\t    binfo,\n-\t\t\t\t    LOOKUP_NORMAL | LOOKUP_NONVIRTUAL);\n+\t\t\t\t    LOOKUP_NORMAL | LOOKUP_NONVIRTUAL,\n+                                    tf_warning_or_error);\n   if (flag)\n     expr = fold_build3 (COND_EXPR, void_type_node,\n \t\t\tc_common_truthvalue_conversion (flag),\n@@ -1025,7 +1036,7 @@ construct_virtual_base (tree vbase, tree arguments)\n   exp = convert_to_base_statically (current_class_ref, vbase);\n \n   expand_aggr_init_1 (vbase, current_class_ref, exp, arguments,\n-\t\t      LOOKUP_COMPLAIN);\n+\t\t      LOOKUP_COMPLAIN, tf_warning_or_error);\n   finish_then_clause (inner_if_stmt);\n   finish_if_stmt (inner_if_stmt);\n \n@@ -1230,7 +1241,7 @@ expand_member_init (tree name)\n    perform the initialization, but not both, as it would be ambiguous.  */\n \n tree\n-build_aggr_init (tree exp, tree init, int flags)\n+build_aggr_init (tree exp, tree init, int flags, tsubst_flags_t complain)\n {\n   tree stmt_expr;\n   tree compound_stmt;\n@@ -1257,7 +1268,8 @@ build_aggr_init (tree exp, tree init, int flags)\n \t initialization form -- unless the initializer is \"()\".  */\n       if (init && TREE_CODE (init) == TREE_LIST)\n \t{\n-\t  error (\"bad array initializer\");\n+          if (complain & tf_error)\n+            error (\"bad array initializer\");\n \t  return error_mark_node;\n \t}\n       /* Must arrange to initialize each element of EXP\n@@ -1270,7 +1282,8 @@ build_aggr_init (tree exp, tree init, int flags)\n       stmt_expr = build_vec_init (exp, NULL_TREE, init,\n \t\t\t\t  /*explicit_default_init_p=*/false,\n \t\t\t\t  itype && same_type_p (itype,\n-\t\t\t\t\t\t\tTREE_TYPE (exp)));\n+\t\t\t\t\t\t\tTREE_TYPE (exp)),\n+                                  complain);\n       TREE_READONLY (exp) = was_const;\n       TREE_THIS_VOLATILE (exp) = was_volatile;\n       TREE_TYPE (exp) = type;\n@@ -1287,7 +1300,7 @@ build_aggr_init (tree exp, tree init, int flags)\n   destroy_temps = stmts_are_full_exprs_p ();\n   current_stmt_tree ()->stmts_are_full_exprs_p = 0;\n   expand_aggr_init_1 (TYPE_BINFO (type), exp, exp,\n-\t\t      init, LOOKUP_NORMAL|flags);\n+\t\t      init, LOOKUP_NORMAL|flags, complain);\n   stmt_expr = finish_init_stmts (is_global, stmt_expr, compound_stmt);\n   current_stmt_tree ()->stmts_are_full_exprs_p = destroy_temps;\n   TREE_READONLY (exp) = was_const;\n@@ -1297,7 +1310,8 @@ build_aggr_init (tree exp, tree init, int flags)\n }\n \n static void\n-expand_default_init (tree binfo, tree true_exp, tree exp, tree init, int flags)\n+expand_default_init (tree binfo, tree true_exp, tree exp, tree init, int flags,\n+                     tsubst_flags_t complain)\n {\n   tree type = TREE_TYPE (exp);\n   tree ctor_name;\n@@ -1364,9 +1378,10 @@ expand_default_init (tree binfo, tree true_exp, tree exp, tree init, int flags)\n   else\n     ctor_name = base_ctor_identifier;\n \n-  rval = build_special_member_call (exp, ctor_name, parms, binfo, flags);\n+  rval = build_special_member_call (exp, ctor_name, parms, binfo, flags,\n+                                    complain);\n   if (TREE_SIDE_EFFECTS (rval))\n-    finish_expr_stmt (convert_to_void (rval, NULL));\n+    finish_expr_stmt (convert_to_void (rval, NULL, complain));\n }\n \n /* This function is responsible for initializing EXP with INIT\n@@ -1390,7 +1405,8 @@ expand_default_init (tree binfo, tree true_exp, tree exp, tree init, int flags)\n    for its description.  */\n \n static void\n-expand_aggr_init_1 (tree binfo, tree true_exp, tree exp, tree init, int flags)\n+expand_aggr_init_1 (tree binfo, tree true_exp, tree exp, tree init, int flags,\n+                    tsubst_flags_t complain)\n {\n   tree type = TREE_TYPE (exp);\n \n@@ -1417,7 +1433,7 @@ expand_aggr_init_1 (tree binfo, tree true_exp, tree exp, tree init, int flags)\n \n   /* We know that expand_default_init can handle everything we want\n      at this point.  */\n-  expand_default_init (binfo, true_exp, exp, init, flags);\n+  expand_default_init (binfo, true_exp, exp, init, flags, complain);\n }\n \n /* Report an error if TYPE is not a user-defined, class type.  If\n@@ -1574,7 +1590,8 @@ build_offset_ref (tree type, tree member, bool address_p)\n \t  if (flag_ms_extensions)\n \t    {\n \t      PTRMEM_OK_P (member) = 1;\n-\t      return build_unary_op (ADDR_EXPR, member, 0);\n+\t      return cp_build_unary_op (ADDR_EXPR, member, 0, \n+                                        tf_warning_or_error);\n \t    }\n \t  error (\"invalid use of non-static member function %qD\",\n \t\t TREE_OPERAND (member, 1));\n@@ -1765,7 +1782,7 @@ avoid_placement_new_aliasing (tree t, tree placement)\n \n static tree\n build_new_1 (tree placement, tree type, tree nelts, tree init,\n-\t     bool globally_qualified_p)\n+\t     bool globally_qualified_p, tsubst_flags_t complain)\n {\n   tree size, rval;\n   /* True iff this is a call to \"operator new[]\" instead of just\n@@ -1855,11 +1872,13 @@ build_new_1 (tree placement, tree type, tree nelts, tree init,\n        TREE_CODE (elt_type) == ARRAY_TYPE;\n        elt_type = TREE_TYPE (elt_type))\n     nelts = cp_build_binary_op (MULT_EXPR, nelts,\n-\t\t\t\tarray_type_nelts_top (elt_type));\n+\t\t\t\tarray_type_nelts_top (elt_type),\n+\t\t\t\tcomplain);\n \n   if (TREE_CODE (elt_type) == VOID_TYPE)\n     {\n-      error (\"invalid type %<void%> for new\");\n+      if (complain & tf_error)\n+        error (\"invalid type %<void%> for new\");\n       return error_mark_node;\n     }\n \n@@ -1869,7 +1888,8 @@ build_new_1 (tree placement, tree type, tree nelts, tree init,\n   is_initialized = (TYPE_NEEDS_CONSTRUCTING (elt_type) || init);\n   if (CP_TYPE_CONST_P (elt_type) && !is_initialized)\n     {\n-      error (\"uninitialized const in %<new%> of %q#T\", elt_type);\n+      if (complain & tf_error)\n+        error (\"uninitialized const in %<new%> of %q#T\", elt_type);\n       return error_mark_node;\n     }\n \n@@ -1907,19 +1927,22 @@ build_new_1 (tree placement, tree type, tree nelts, tree init,\n       if (!get_global_value_if_present (get_identifier (alloc_name),\n \t\t\t\t\t&alloc_fn))\n \t{\n-\t  error (\"call to Java constructor with %qs undefined\", alloc_name);\n+          if (complain & tf_error)\n+            error (\"call to Java constructor with %qs undefined\", alloc_name);\n \t  return error_mark_node;\n \t}\n       else if (really_overloaded_fn (alloc_fn))\n \t{\n-\t  error (\"%qD should never be overloaded\", alloc_fn);\n+          if (complain & tf_error)\n+            error (\"%qD should never be overloaded\", alloc_fn);\n \t  return error_mark_node;\n \t}\n       alloc_fn = OVL_CURRENT (alloc_fn);\n       class_addr = build1 (ADDR_EXPR, jclass_node, class_decl);\n-      alloc_call = (build_function_call\n+      alloc_call = (cp_build_function_call\n \t\t    (alloc_fn,\n-\t\t     build_tree_list (NULL_TREE, class_addr)));\n+\t\t     build_tree_list (NULL_TREE, class_addr),\n+\t\t     complain));\n     }\n   else if (TYPE_FOR_JAVA (elt_type) && MAYBE_CLASS_TYPE_P (elt_type))\n     {\n@@ -1952,20 +1975,25 @@ build_new_1 (tree placement, tree type, tree nelts, tree init,\n \t  fns = lookup_fnfields (elt_type, fnname, /*protect=*/2);\n \t  if (fns == NULL_TREE)\n \t    {\n-\t      error (\"no suitable %qD found in class %qT\", fnname, elt_type);\n+              if (complain & tf_error)\n+                error (\"no suitable %qD found in class %qT\", fnname, elt_type);\n \t      return error_mark_node;\n \t    }\n \t  if (TREE_CODE (fns) == TREE_LIST)\n \t    {\n-\t      error (\"request for member %qD is ambiguous\", fnname);\n-\t      print_candidates (fns);\n+              if (complain & tf_error)\n+                {\n+                  error (\"request for member %qD is ambiguous\", fnname);\n+                  print_candidates (fns);\n+                }\n \t      return error_mark_node;\n \t    }\n \t  alloc_call = build_new_method_call (build_dummy_object (elt_type),\n \t\t\t\t\t      fns, args,\n \t\t\t\t\t      /*conversion_path=*/NULL_TREE,\n \t\t\t\t\t      LOOKUP_NORMAL,\n-\t\t\t\t\t      &alloc_fn);\n+\t\t\t\t\t      &alloc_fn,\n+\t\t\t\t\t      complain);\n \t}\n       else\n \t{\n@@ -2085,7 +2113,7 @@ build_new_1 (tree placement, tree type, tree nelts, tree init,\n       size_ptr_type = build_pointer_type (sizetype);\n       cookie_ptr = build2 (POINTER_PLUS_EXPR, size_ptr_type,\n \t\t\t   fold_convert (size_ptr_type, data_addr), cookie_ptr);\n-      cookie = build_indirect_ref (cookie_ptr, NULL);\n+      cookie = cp_build_indirect_ref (cookie_ptr, NULL, complain);\n \n       cookie_expr = build2 (MODIFY_EXPR, sizetype, cookie, nelts);\n \n@@ -2096,7 +2124,7 @@ build_new_1 (tree placement, tree type, tree nelts, tree init,\n \t\t\t       fold_build1 (NEGATE_EXPR, sizetype,\n \t\t\t\t\t    size_in_bytes (sizetype)));\n \n-\t  cookie = build_indirect_ref (cookie_ptr, NULL);\n+\t  cookie = cp_build_indirect_ref (cookie_ptr, NULL, complain);\n \t  cookie = build2 (MODIFY_EXPR, sizetype, cookie,\n \t\t\t   size_in_bytes(elt_type));\n \t  cookie_expr = build2 (COMPOUND_EXPR, TREE_TYPE (cookie_expr),\n@@ -2119,7 +2147,7 @@ build_new_1 (tree placement, tree type, tree nelts, tree init,\n     {\n       bool stable;\n \n-      init_expr = build_indirect_ref (data_addr, NULL);\n+      init_expr = cp_build_indirect_ref (data_addr, NULL, complain);\n \n       if (array_p)\n \t{\n@@ -2131,15 +2159,21 @@ build_new_1 (tree placement, tree type, tree nelts, tree init,\n \t      explicit_default_init_p = true;\n \t    }\n \t  else if (init)\n-\t    pedwarn (\"ISO C++ forbids initialization in array new\");\n-\n+            {\n+              if (complain & tf_error)\n+                pedwarn (\"ISO C++ forbids initialization in array new\");\n+              else\n+                return error_mark_node;\n+            }\n \t  init_expr\n \t    = build_vec_init (init_expr,\n \t\t\t      cp_build_binary_op (MINUS_EXPR, outer_nelts,\n-\t\t\t\t\t\t  integer_one_node),\n+\t\t\t\t\t\t  integer_one_node,\n+\t\t\t\t\t\t  complain),\n \t\t\t      init,\n \t\t\t      explicit_default_init_p,\n-\t\t\t      /*from_array=*/0);\n+\t\t\t      /*from_array=*/0,\n+                              complain);\n \n \t  /* An array initialization is stable because the initialization\n \t     of each element is a full-expression, so the temporaries don't\n@@ -2156,7 +2190,8 @@ build_new_1 (tree placement, tree type, tree nelts, tree init,\n \t      init_expr = build_special_member_call (init_expr,\n \t\t\t\t\t\t     complete_ctor_identifier,\n \t\t\t\t\t\t     init, elt_type,\n-\t\t\t\t\t\t     LOOKUP_NORMAL);\n+\t\t\t\t\t\t     LOOKUP_NORMAL,\n+                                                     complain);\n \t      stable = stabilize_init (init_expr, &init_preeval_expr);\n \t    }\n \t  else\n@@ -2171,7 +2206,8 @@ build_new_1 (tree placement, tree type, tree nelts, tree init,\n \t\tgcc_assert (TREE_CODE (init) != CONSTRUCTOR\n \t\t\t    || TREE_TYPE (init) != NULL_TREE);\n \n-\t      init_expr = build_modify_expr (init_expr, INIT_EXPR, init);\n+\t      init_expr = cp_build_modify_expr (init_expr, INIT_EXPR, init,\n+\t\t\t\t\t\tcomplain);\n \t      stable = stabilize_init (init_expr, &init_preeval_expr);\n \t    }\n \t}\n@@ -2263,8 +2299,10 @@ build_new_1 (tree placement, tree type, tree nelts, tree init,\n       if (check_new)\n \t{\n \t  tree ifexp = cp_build_binary_op (NE_EXPR, alloc_node,\n-\t\t\t\t\t   integer_zero_node);\n-\t  rval = build_conditional_expr (ifexp, rval, alloc_node);\n+\t\t\t\t\t   integer_zero_node,\n+\t\t\t\t\t   complain);\n+\t  rval = build_conditional_expr (ifexp, rval, alloc_node, \n+                                         complain);\n \t}\n \n       /* Perform the allocation before anything else, so that ALLOC_NODE\n@@ -2299,7 +2337,7 @@ build_new_1 (tree placement, tree type, tree nelts, tree init,\n \n tree\n build_new (tree placement, tree type, tree nelts, tree init,\n-\t   int use_global_new)\n+\t   int use_global_new, tsubst_flags_t complain)\n {\n   tree rval;\n   tree orig_placement;\n@@ -2333,7 +2371,12 @@ build_new (tree placement, tree type, tree nelts, tree init,\n   if (nelts)\n     {\n       if (!build_expr_type_conversion (WANT_INT | WANT_ENUM, nelts, false))\n-\tpedwarn (\"size in array new must have integral type\");\n+        {\n+          if (complain & tf_error)\n+            pedwarn (\"size in array new must have integral type\");\n+          else\n+            return error_mark_node;\n+        }\n       nelts = cp_save_expr (cp_convert (sizetype, nelts));\n     }\n \n@@ -2342,13 +2385,17 @@ build_new (tree placement, tree type, tree nelts, tree init,\n      returned by new.'' ARM 5.3.3 */\n   if (TREE_CODE (type) == REFERENCE_TYPE)\n     {\n-      error (\"new cannot be applied to a reference type\");\n+      if (complain & tf_error)\n+        error (\"new cannot be applied to a reference type\");\n+      else\n+        return error_mark_node;\n       type = TREE_TYPE (type);\n     }\n \n   if (TREE_CODE (type) == FUNCTION_TYPE)\n     {\n-      error (\"new cannot be applied to a function type\");\n+      if (complain & tf_error)\n+        error (\"new cannot be applied to a function type\");\n       return error_mark_node;\n     }\n \n@@ -2358,7 +2405,7 @@ build_new (tree placement, tree type, tree nelts, tree init,\n   if (!complete_type_or_else (type, NULL_TREE))\n     return error_mark_node;\n \n-  rval = build_new_1 (placement, type, nelts, init, use_global_new);\n+  rval = build_new_1 (placement, type, nelts, init, use_global_new, complain);\n   if (rval == error_mark_node)\n     return error_mark_node;\n \n@@ -2464,10 +2511,11 @@ build_vec_delete_1 (tree base, tree maxindex, tree type,\n \t\t\t     convert (sizetype, maxindex));\n \n   tbase = create_temporary_var (ptype);\n-  tbase_init = build_modify_expr (tbase, NOP_EXPR,\n-\t\t\t\t  fold_build2 (POINTER_PLUS_EXPR, ptype,\n-\t\t\t\t\t       fold_convert (ptype, base),\n-\t\t\t\t\t       virtual_size));\n+  tbase_init = cp_build_modify_expr (tbase, NOP_EXPR,\n+\t\t\t\t     fold_build2 (POINTER_PLUS_EXPR, ptype,\n+\t\t\t\t\t\t  fold_convert (ptype, base),\n+\t\t\t\t\t\t  virtual_size),\n+\t\t\t\t     tf_warning_or_error);\n   DECL_REGISTER (tbase) = 1;\n   controller = build3 (BIND_EXPR, void_type_node, tbase,\n \t\t       NULL_TREE, NULL_TREE);\n@@ -2478,14 +2526,17 @@ build_vec_delete_1 (tree base, tree maxindex, tree type,\n \t\t\t fold_convert (ptype, base)));\n   tmp = fold_build1 (NEGATE_EXPR, sizetype, size_exp);\n   body = build_compound_expr\n-    (body, build_modify_expr (tbase, NOP_EXPR,\n-\t\t\t      build2 (POINTER_PLUS_EXPR, ptype, tbase, tmp)));\n+    (body, cp_build_modify_expr (tbase, NOP_EXPR,\n+\t\t\t\t build2 (POINTER_PLUS_EXPR, ptype, tbase, tmp),\n+\t\t\t\t tf_warning_or_error),\n+     tf_warning_or_error);\n   body = build_compound_expr\n     (body, build_delete (ptype, tbase, sfk_complete_destructor,\n-\t\t\t LOOKUP_NORMAL|LOOKUP_DESTRUCTOR, 1));\n+\t\t\t LOOKUP_NORMAL|LOOKUP_DESTRUCTOR, 1),\n+     tf_warning_or_error);\n \n   loop = build1 (LOOP_EXPR, void_type_node, body);\n-  loop = build_compound_expr (tbase_init, loop);\n+  loop = build_compound_expr (tbase_init, loop, tf_warning_or_error);\n \n  no_destructor:\n   /* If the delete flag is one, or anything else with the low bit set,\n@@ -2511,7 +2562,8 @@ build_vec_delete_1 (tree base, tree maxindex, tree type,\n \t\t\t  cp_build_binary_op (MINUS_EXPR,\n \t\t\t\t\t      cp_convert (string_type_node,\n \t\t\t\t\t\t\t  base),\n-\t\t\t\t\t      cookie_size));\n+\t\t\t\t\t      cookie_size,\n+\t\t\t\t\t      tf_warning_or_error));\n \t  /* True size with header.  */\n \t  virtual_size = size_binop (PLUS_EXPR, virtual_size, cookie_size);\n \t}\n@@ -2530,7 +2582,7 @@ build_vec_delete_1 (tree base, tree maxindex, tree type,\n   else if (!body)\n     body = deallocate_expr;\n   else\n-    body = build_compound_expr (body, deallocate_expr);\n+    body = build_compound_expr (body, deallocate_expr, tf_warning_or_error);\n \n   if (!body)\n     body = integer_zero_node;\n@@ -2553,7 +2605,7 @@ build_vec_delete_1 (tree base, tree maxindex, tree type,\n     /* Pre-evaluate the SAVE_EXPR outside of the BIND_EXPR.  */\n     body = build2 (COMPOUND_EXPR, void_type_node, base, body);\n \n-  return convert_to_void (body, /*implicit=*/NULL);\n+  return convert_to_void (body, /*implicit=*/NULL, tf_warning_or_error);\n }\n \n /* Create an unnamed variable of the indicated TYPE.  */\n@@ -2588,7 +2640,8 @@ get_temp_regvar (tree type, tree init)\n   decl = create_temporary_var (type);\n   add_decl_expr (decl);\n \n-  finish_expr_stmt (build_modify_expr (decl, INIT_EXPR, init));\n+  finish_expr_stmt (cp_build_modify_expr (decl, INIT_EXPR, init, \n+\t\t\t\t\t  tf_warning_or_error));\n \n   return decl;\n }\n@@ -2616,7 +2669,7 @@ get_temp_regvar (tree type, tree init)\n tree\n build_vec_init (tree base, tree maxindex, tree init,\n \t\tbool explicit_default_init_p,\n-\t\tint from_array)\n+\t\tint from_array, tsubst_flags_t complain)\n {\n   tree rval;\n   tree base2 = NULL_TREE;\n@@ -2737,14 +2790,16 @@ build_vec_init (tree base, tree maxindex, tree init,\n \n \t  current_stmt_tree ()->stmts_are_full_exprs_p = 1;\n \t  if (MAYBE_CLASS_TYPE_P (type) || TREE_CODE (type) == ARRAY_TYPE)\n-\t    finish_expr_stmt (build_aggr_init (baseref, elt, 0));\n+\t    finish_expr_stmt (build_aggr_init (baseref, elt, 0, complain));\n \t  else\n-\t    finish_expr_stmt (build_modify_expr (baseref, NOP_EXPR,\n-\t\t\t\t\t\t elt));\n+\t    finish_expr_stmt (cp_build_modify_expr (baseref, NOP_EXPR,\n+                                                    elt, complain));\n \t  current_stmt_tree ()->stmts_are_full_exprs_p = 0;\n \n-\t  finish_expr_stmt (build_unary_op (PREINCREMENT_EXPR, base, 0));\n-\t  finish_expr_stmt (build_unary_op (PREDECREMENT_EXPR, iterator, 0));\n+\t  finish_expr_stmt (cp_build_unary_op (PREINCREMENT_EXPR, base, 0,\n+                                               complain));\n+\t  finish_expr_stmt (cp_build_unary_op (PREDECREMENT_EXPR, iterator, 0,\n+                                               complain));\n \t}\n \n       /* Clear out INIT so that we don't get confused below.  */\n@@ -2766,7 +2821,8 @@ build_vec_init (tree base, tree maxindex, tree init,\n \t       && TYPE_NEEDS_CONSTRUCTING (type)\n \t       && ! TYPE_HAS_DEFAULT_CONSTRUCTOR (type))\n \t{\n-\t  error (\"initializer ends prematurely\");\n+          if (complain & tf_error)\n+            error (\"initializer ends prematurely\");\n \t  return error_mark_node;\n \t}\n     }\n@@ -2794,7 +2850,8 @@ build_vec_init (tree base, tree maxindex, tree init,\n       finish_for_cond (build2 (NE_EXPR, boolean_type_node, iterator,\n \t\t\t       build_int_cst (TREE_TYPE (iterator), -1)),\n \t\t       for_stmt);\n-      finish_for_expr (build_unary_op (PREDECREMENT_EXPR, iterator, 0),\n+      finish_for_expr (cp_build_unary_op (PREDECREMENT_EXPR, iterator, 0,\n+                                          complain),\n \t\t       for_stmt);\n \n       to = build1 (INDIRECT_REF, type, base);\n@@ -2809,11 +2866,13 @@ build_vec_init (tree base, tree maxindex, tree init,\n \t    from = NULL_TREE;\n \n \t  if (from_array == 2)\n-\t    elt_init = build_modify_expr (to, NOP_EXPR, from);\n+\t    elt_init = cp_build_modify_expr (to, NOP_EXPR, from, \n+\t\t\t\t\t     complain);\n \t  else if (TYPE_NEEDS_CONSTRUCTING (type))\n-\t    elt_init = build_aggr_init (to, from, 0);\n+\t    elt_init = build_aggr_init (to, from, 0, complain);\n \t  else if (from)\n-\t    elt_init = build_modify_expr (to, NOP_EXPR, from);\n+\t    elt_init = cp_build_modify_expr (to, NOP_EXPR, from,\n+\t\t\t\t\t     complain);\n \t  else\n \t    gcc_unreachable ();\n \t}\n@@ -2825,23 +2884,26 @@ build_vec_init (tree base, tree maxindex, tree init,\n \t  elt_init = build_vec_init (build1 (INDIRECT_REF, type, base),\n \t\t\t\t     0, 0,\n \t\t\t\t     /*explicit_default_init_p=*/false,\n-\t\t\t\t     0);\n+\t\t\t\t     0, complain);\n \t}\n       else if (!TYPE_NEEDS_CONSTRUCTING (type))\n-\telt_init = (build_modify_expr\n+\telt_init = (cp_build_modify_expr\n \t\t    (to, INIT_EXPR,\n \t\t     build_zero_init (type, size_one_node,\n-\t\t\t\t      /*static_storage_p=*/false)));\n+\t\t\t\t      /*static_storage_p=*/false),\n+\t\t     complain));\n       else\n-\telt_init = build_aggr_init (to, init, 0);\n+\telt_init = build_aggr_init (to, init, 0, complain);\n \n       current_stmt_tree ()->stmts_are_full_exprs_p = 1;\n       finish_expr_stmt (elt_init);\n       current_stmt_tree ()->stmts_are_full_exprs_p = 0;\n \n-      finish_expr_stmt (build_unary_op (PREINCREMENT_EXPR, base, 0));\n+      finish_expr_stmt (cp_build_unary_op (PREINCREMENT_EXPR, base, 0,\n+                                           complain));\n       if (base2)\n-\tfinish_expr_stmt (build_unary_op (PREINCREMENT_EXPR, base2, 0));\n+\tfinish_expr_stmt (cp_build_unary_op (PREINCREMENT_EXPR, base2, 0,\n+                                             complain));\n \n       finish_for_stmt (for_stmt);\n     }\n@@ -2851,13 +2913,15 @@ build_vec_init (tree base, tree maxindex, tree init,\n       && from_array != 2)\n     {\n       tree e;\n-      tree m = cp_build_binary_op (MINUS_EXPR, maxindex, iterator);\n+      tree m = cp_build_binary_op (MINUS_EXPR, maxindex, iterator,\n+\t\t\t\t   complain);\n \n       /* Flatten multi-dimensional array since build_vec_delete only\n \t expects one-dimensional array.  */\n       if (TREE_CODE (type) == ARRAY_TYPE)\n \tm = cp_build_binary_op (MULT_EXPR, m,\n-\t\t\t\tarray_type_nelts_total (type));\n+\t\t\t\tarray_type_nelts_total (type),\n+\t\t\t\tcomplain);\n \n       finish_cleanup_try_block (try_block);\n       e = build_vec_delete_1 (rval, m,\n@@ -2875,7 +2939,7 @@ build_vec_init (tree base, tree maxindex, tree init,\n   /* Now convert make the result have the correct type.  */\n   atype = build_pointer_type (atype);\n   stmt_expr = build1 (NOP_EXPR, atype, stmt_expr);\n-  stmt_expr = build_indirect_ref (stmt_expr, NULL);\n+  stmt_expr = cp_build_indirect_ref (stmt_expr, NULL, complain);\n \n   current_stmt_tree ()->stmts_are_full_exprs_p = destroy_temps;\n   return stmt_expr;\n@@ -2911,7 +2975,8 @@ build_dtor_call (tree exp, special_function_kind dtor_kind, int flags)\n \t\t\t\t/*args=*/NULL_TREE,\n \t\t\t\t/*conversion_path=*/NULL_TREE,\n \t\t\t\tflags,\n-\t\t\t\t/*fn_p=*/NULL);\n+\t\t\t\t/*fn_p=*/NULL,\n+\t\t\t\ttf_warning_or_error);\n }\n \n /* Generate a call to a destructor. TYPE is the type to cast ADDR to.\n@@ -2993,7 +3058,7 @@ build_delete (tree type, tree addr, special_function_kind auto_delete,\n       /* Don't check PROTECT here; leave that decision to the\n \t destructor.  If the destructor is accessible, call it,\n \t else report error.  */\n-      addr = build_unary_op (ADDR_EXPR, addr, 0);\n+      addr = cp_build_unary_op (ADDR_EXPR, addr, 0, tf_warning_or_error);\n       if (TREE_SIDE_EFFECTS (addr))\n \taddr = save_expr (addr);\n \n@@ -3065,7 +3130,8 @@ build_delete (tree type, tree addr, special_function_kind auto_delete,\n \t\t\t\t/*alloc_fn=*/NULL_TREE);\n \t}\n \n-      expr = build_dtor_call (build_indirect_ref (addr, NULL),\n+      expr = build_dtor_call (cp_build_indirect_ref (addr, NULL, \n+                                                     tf_warning_or_error),\n \t\t\t      auto_delete, flags);\n       if (do_delete)\n \texpr = build2 (COMPOUND_EXPR, void_type_node, expr, do_delete);\n@@ -3079,7 +3145,8 @@ build_delete (tree type, tree addr, special_function_kind auto_delete,\n \tifexp = integer_one_node;\n       else\n \t/* Handle deleting a null pointer.  */\n-\tifexp = fold (cp_build_binary_op (NE_EXPR, addr, integer_zero_node));\n+\tifexp = fold (cp_build_binary_op (NE_EXPR, addr, integer_zero_node,\n+\t\t\t\t\t  tf_warning_or_error));\n \n       if (ifexp != integer_one_node)\n \texpr = build3 (COND_EXPR, void_type_node,\n@@ -3123,7 +3190,8 @@ push_base_cleanups (void)\n \t\t\t\t\t\tNULL_TREE,\n \t\t\t\t\t\tbase_binfo,\n \t\t\t\t\t\t(LOOKUP_NORMAL\n-\t\t\t\t\t\t | LOOKUP_NONVIRTUAL));\n+\t\t\t\t\t\t | LOOKUP_NONVIRTUAL),\n+                                                tf_warning_or_error);\n \t      expr = build3 (COND_EXPR, void_type_node, cond,\n \t\t\t     expr, void_zero_node);\n \t      finish_decl_cleanup (NULL_TREE, expr);\n@@ -3142,7 +3210,8 @@ push_base_cleanups (void)\n       expr = build_special_member_call (current_class_ref,\n \t\t\t\t\tbase_dtor_identifier,\n \t\t\t\t\tNULL_TREE, base_binfo,\n-\t\t\t\t\tLOOKUP_NORMAL | LOOKUP_NONVIRTUAL);\n+\t\t\t\t\tLOOKUP_NORMAL | LOOKUP_NONVIRTUAL,\n+                                        tf_warning_or_error);\n       finish_decl_cleanup (NULL_TREE, expr);\n     }\n \n@@ -3158,7 +3227,8 @@ push_base_cleanups (void)\n \t  tree this_member = (build_class_member_access_expr\n \t\t\t      (current_class_ref, member,\n \t\t\t       /*access_path=*/NULL_TREE,\n-\t\t\t       /*preserve_reference=*/false));\n+\t\t\t       /*preserve_reference=*/false,\n+\t\t\t       tf_warning_or_error));\n \t  tree this_type = TREE_TYPE (member);\n \t  expr = build_delete (this_type, this_member,\n \t\t\t       sfk_complete_destructor,\n@@ -3211,15 +3281,15 @@ build_vec_delete (tree base, tree maxindex,\n \t\t\t    build_pointer_type (sizetype),\n \t\t\t    base,\n \t\t\t    cookie_addr);\n-      maxindex = build_indirect_ref (cookie_addr, NULL);\n+      maxindex = cp_build_indirect_ref (cookie_addr, NULL, tf_warning_or_error);\n     }\n   else if (TREE_CODE (type) == ARRAY_TYPE)\n     {\n       /* Get the total number of things in the array, maxindex is a\n \t bad name.  */\n       maxindex = array_type_nelts_total (type);\n       type = strip_array_types (type);\n-      base = build_unary_op (ADDR_EXPR, base, 1);\n+      base = cp_build_unary_op (ADDR_EXPR, base, 1, tf_warning_or_error);\n       if (TREE_SIDE_EFFECTS (base))\n \t{\n \t  base_init = get_target_expr (base);"}, {"sha": "5d50f8542f92af2b206a26e55f16f87e8bca3dcc", "filename": "gcc/cp/method.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ade1ed2c08bf2f327ee24afc57bc263fd90e6e1/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ade1ed2c08bf2f327ee24afc57bc263fd90e6e1/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=5ade1ed2c08bf2f327ee24afc57bc263fd90e6e1", "patch": "@@ -674,7 +674,8 @@ do_build_assign_ref (tree fndecl)\n \t\t\t\t\tbuild_tree_list (NULL_TREE,\n \t\t\t\t\t\t\t converted_parm),\n \t\t\t\t\tbase_binfo,\n-\t\t\t\t\tLOOKUP_NORMAL | LOOKUP_NONVIRTUAL));\n+\t\t\t\t\tLOOKUP_NORMAL | LOOKUP_NONVIRTUAL,\n+                                        tf_warning_or_error));\n \t}\n \n       /* Assign to each of the non-static data members.  */\n@@ -729,7 +730,8 @@ do_build_assign_ref (tree fndecl)\n \t  init = build3 (COMPONENT_REF, expr_type, init, field, NULL_TREE);\n \n \t  if (DECL_NAME (field))\n-\t    init = build_modify_expr (comp, NOP_EXPR, init);\n+\t    init = cp_build_modify_expr (comp, NOP_EXPR, init, \n+\t\t\t\t\t tf_warning_or_error);\n \t  else\n \t    init = build2 (MODIFY_EXPR, TREE_TYPE (comp), comp, init);\n \t  finish_expr_stmt (init);"}, {"sha": "8a9c3e2956373d80d6a15ee6ad34c14594803737", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 38, "deletions": 22, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ade1ed2c08bf2f327ee24afc57bc263fd90e6e1/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ade1ed2c08bf2f327ee24afc57bc263fd90e6e1/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=5ade1ed2c08bf2f327ee24afc57bc263fd90e6e1", "patch": "@@ -4333,19 +4333,20 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p, bool cast_p,\n \t  {\n \t  case RID_DYNCAST:\n \t    postfix_expression\n-\t      = build_dynamic_cast (type, expression);\n+\t      = build_dynamic_cast (type, expression, tf_warning_or_error);\n \t    break;\n \t  case RID_STATCAST:\n \t    postfix_expression\n-\t      = build_static_cast (type, expression);\n+\t      = build_static_cast (type, expression, tf_warning_or_error);\n \t    break;\n \t  case RID_REINTCAST:\n \t    postfix_expression\n-\t      = build_reinterpret_cast (type, expression);\n+\t      = build_reinterpret_cast (type, expression, \n+                                        tf_warning_or_error);\n \t    break;\n \t  case RID_CONSTCAST:\n \t    postfix_expression\n-\t      = build_const_cast (type, expression);\n+\t      = build_const_cast (type, expression, tf_warning_or_error);\n \t    break;\n \t  default:\n \t    gcc_unreachable ();\n@@ -4644,12 +4645,14 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p, bool cast_p,\n \t\t       (instance, fn, args, NULL_TREE,\n \t\t\t(idk == CP_ID_KIND_QUALIFIED\n \t\t\t ? LOOKUP_NONVIRTUAL : LOOKUP_NORMAL),\n-\t\t\t/*fn_p=*/NULL));\n+\t\t\t/*fn_p=*/NULL,\n+\t\t\ttf_warning_or_error));\n \t\telse\n \t\t  postfix_expression\n \t\t    = finish_call_expr (postfix_expression, args,\n \t\t\t\t\t/*disallow_virtual=*/false,\n-\t\t\t\t\t/*koenig_p=*/false);\n+\t\t\t\t\t/*koenig_p=*/false,\n+\t\t\t\t\ttf_warning_or_error);\n \t      }\n \t    else if (TREE_CODE (postfix_expression) == OFFSET_REF\n \t\t     || TREE_CODE (postfix_expression) == MEMBER_REF\n@@ -4662,13 +4665,15 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p, bool cast_p,\n \t      postfix_expression\n \t\t= finish_call_expr (postfix_expression, args,\n \t\t\t\t    /*disallow_virtual=*/true,\n-\t\t\t\t    koenig_p);\n+\t\t\t\t    koenig_p,\n+\t\t\t\t    tf_warning_or_error);\n \t    else\n \t      /* All other function calls.  */\n \t      postfix_expression\n \t\t= finish_call_expr (postfix_expression, args,\n \t\t\t\t    /*disallow_virtual=*/false,\n-\t\t\t\t    koenig_p);\n+\t\t\t\t    koenig_p,\n+\t\t\t\t    tf_warning_or_error);\n \n \t    /* The POSTFIX_EXPRESSION is certainly no longer an id.  */\n \t    idk = CP_ID_KIND_NONE;\n@@ -4937,7 +4942,8 @@ cp_parser_postfix_dot_deref_expression (cp_parser *parser,\n \t      (name, BINFO_TYPE (BASELINK_ACCESS_BINFO (name)), scope);\n \t  postfix_expression\n \t    = finish_class_member_access_expr (postfix_expression, name,\n-\t\t\t\t\t       template_p);\n+\t\t\t\t\t       template_p, \n+\t\t\t\t\t       tf_warning_or_error);\n \t}\n     }\n \n@@ -5250,7 +5256,7 @@ cp_parser_unary_expression (cp_parser *parser, bool address_p, bool cast_p)\n \t    if (TYPE_P (operand))\n \t      return cxx_sizeof_or_alignof_type (operand, op, true);\n \t    else\n-\t      return cxx_sizeof_or_alignof_expr (operand, op);\n+\t      return cxx_sizeof_or_alignof_expr (operand, op, true);\n \t  }\n \n \tcase RID_NEW:\n@@ -5287,7 +5293,8 @@ cp_parser_unary_expression (cp_parser *parser, bool address_p, bool cast_p)\n \t    /* Create the complete representation.  */\n \t    return build_x_unary_op ((keyword == RID_REALPART\n \t\t\t\t      ? REALPART_EXPR : IMAGPART_EXPR),\n-\t\t\t\t     expression);\n+\t\t\t\t     expression,\n+                                     tf_warning_or_error);\n \t  }\n \t  break;\n \n@@ -5362,14 +5369,16 @@ cp_parser_unary_expression (cp_parser *parser, bool address_p, bool cast_p)\n \t{\n \tcase INDIRECT_REF:\n \t  non_constant_p = \"`*'\";\n-\t  expression = build_x_indirect_ref (cast_expression, \"unary *\");\n+\t  expression = build_x_indirect_ref (cast_expression, \"unary *\",\n+                                             tf_warning_or_error);\n \t  break;\n \n \tcase ADDR_EXPR:\n \t  non_constant_p = \"`&'\";\n \t  /* Fall through.  */\n \tcase BIT_NOT_EXPR:\n-\t  expression = build_x_unary_op (unary_operator, cast_expression);\n+\t  expression = build_x_unary_op (unary_operator, cast_expression,\n+                                         tf_warning_or_error);\n \t  break;\n \n \tcase PREINCREMENT_EXPR:\n@@ -5500,7 +5509,8 @@ cp_parser_new_expression (cp_parser* parser)\n     return error_mark_node;\n \n   /* Create a representation of the new-expression.  */\n-  return build_new (placement, type, nelts, initializer, global_scope_p);\n+  return build_new (placement, type, nelts, initializer, global_scope_p,\n+                    tf_warning_or_error);\n }\n \n /* Parse a new-placement.\n@@ -5870,7 +5880,7 @@ cp_parser_cast_expression (cp_parser *parser, bool address_p, bool cast_p)\n \t    return error_mark_node;\n \n \t  /* Perform the cast.  */\n-\t  expr = build_c_cast (type, expr);\n+\t  expr = build_c_cast (type, expr, tf_warning_or_error);\n \t  return expr;\n \t}\n     }\n@@ -6059,7 +6069,7 @@ cp_parser_binary_expression (cp_parser* parser, bool cast_p)\n \n       overloaded_p = false;\n       lhs = build_x_binary_op (tree_type, lhs, lhs_type, rhs, rhs_type,\n-\t\t\t       &overloaded_p);\n+\t\t\t       &overloaded_p, tf_warning_or_error);\n       lhs_type = tree_type;\n \n       /* If the binary operator required the use of an overloaded operator,\n@@ -6115,7 +6125,8 @@ cp_parser_question_colon_clause (cp_parser* parser, tree logical_or_expr)\n   /* Build the conditional-expression.  */\n   return build_x_conditional_expr (logical_or_expr,\n \t\t\t\t   expr,\n-\t\t\t\t   assignment_expr);\n+\t\t\t\t   assignment_expr,\n+                                   tf_warning_or_error);\n }\n \n /* Parse an assignment-expression.\n@@ -6170,7 +6181,8 @@ cp_parser_assignment_expression (cp_parser* parser, bool cast_p)\n \t      /* Build the assignment expression.  */\n \t      expr = build_x_modify_expr (expr,\n \t\t\t\t\t  assignment_operator,\n-\t\t\t\t\t  rhs);\n+\t\t\t\t\t  rhs,\n+\t\t\t\t\t  tf_warning_or_error);\n \t    }\n \t}\n     }\n@@ -6290,7 +6302,8 @@ cp_parser_expression (cp_parser* parser, bool cast_p)\n \texpression = assignment_expression;\n       else\n \texpression = build_x_compound_expr (expression,\n-\t\t\t\t\t    assignment_expression);\n+\t\t\t\t\t    assignment_expression,\n+                                            tf_warning_or_error);\n       /* If the next token is not a comma, then we are done with the\n \t expression.  */\n       if (cp_lexer_next_token_is_not (parser->lexer, CPP_COMMA))\n@@ -6410,7 +6423,8 @@ cp_parser_builtin_offsetof (cp_parser *parser)\n   cp_parser_require (parser, CPP_COMMA, \"`,'\");\n \n   /* Build the (type *)null that begins the traditional offsetof macro.  */\n-  expr = build_static_cast (build_pointer_type (type), null_pointer_node);\n+  expr = build_static_cast (build_pointer_type (type), null_pointer_node,\n+                            tf_warning_or_error);\n \n   /* Parse the offsetof-member-designator.  We begin as if we saw \"expr->\".  */\n   expr = cp_parser_postfix_dot_deref_expression (parser, CPP_DEREF, expr,\n@@ -10320,7 +10334,8 @@ cp_parser_template_argument (cp_parser* parser)\n \t  if (cp_parser_parse_definitely (parser))\n \t    {\n \t      if (address_p)\n-\t\targument = build_x_unary_op (ADDR_EXPR, argument);\n+\t\targument = build_x_unary_op (ADDR_EXPR, argument,\n+                                             tf_warning_or_error);\n \t      return argument;\n \t    }\n \t}\n@@ -17181,7 +17196,8 @@ cp_parser_functional_cast (cp_parser* parser, tree type)\n                                                /*allow_expansion_p=*/true,\n \t\t\t\t\t       /*non_constant_p=*/NULL);\n \n-  cast = build_functional_cast (type, expression_list);\n+  cast = build_functional_cast (type, expression_list,\n+                                tf_warning_or_error);\n   /* [expr.const]/1: In an integral constant expression \"only type\n      conversions to integral or enumeration type can be used\".  */\n   if (TREE_CODE (type) == TYPE_DECL)"}, {"sha": "bc33efc7fbdc30e742a5786fe976e94f0e734090", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 37, "deletions": 23, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ade1ed2c08bf2f327ee24afc57bc263fd90e6e1/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ade1ed2c08bf2f327ee24afc57bc263fd90e6e1/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=5ade1ed2c08bf2f327ee24afc57bc263fd90e6e1", "patch": "@@ -10684,7 +10684,7 @@ tsubst_copy_and_build (tree t,\n \t      r = convert_from_reference (r);\n \t  }\n \telse\n-\t  r = build_x_indirect_ref (r, \"unary *\");\n+\t  r = build_x_indirect_ref (r, \"unary *\", complain);\n \treturn r;\n       }\n \n@@ -10706,8 +10706,9 @@ tsubst_copy_and_build (tree t,\n \tif (integral_constant_expression_p\n \t    && !cast_valid_in_integral_constant_expression_p (type))\n \t  {\n-\t    error (\"a cast to a type other than an integral or \"\n-\t\t   \"enumeration type cannot appear in a constant-expression\");\n+            if (complain & tf_error)\n+              error (\"a cast to a type other than an integral or \"\n+                     \"enumeration type cannot appear in a constant-expression\");\n \t    return error_mark_node; \n \t  }\n \n@@ -10716,15 +10717,15 @@ tsubst_copy_and_build (tree t,\n \tswitch (TREE_CODE (t))\n \t  {\n \t  case CAST_EXPR:\n-\t    return build_functional_cast (type, op);\n+\t    return build_functional_cast (type, op, complain);\n \t  case REINTERPRET_CAST_EXPR:\n-\t    return build_reinterpret_cast (type, op);\n+\t    return build_reinterpret_cast (type, op, complain);\n \t  case CONST_CAST_EXPR:\n-\t    return build_const_cast (type, op);\n+\t    return build_const_cast (type, op, complain);\n \t  case DYNAMIC_CAST_EXPR:\n-\t    return build_dynamic_cast (type, op);\n+\t    return build_dynamic_cast (type, op, complain);\n \t  case STATIC_CAST_EXPR:\n-\t    return build_static_cast (type, op);\n+\t    return build_static_cast (type, op, complain);\n \t  default:\n \t    gcc_unreachable ();\n \t  }\n@@ -10734,7 +10735,7 @@ tsubst_copy_and_build (tree t,\n     case POSTINCREMENT_EXPR:\n       op1 = tsubst_non_call_postfix_expression (TREE_OPERAND (t, 0),\n \t\t\t\t\t\targs, complain, in_decl);\n-      return build_x_unary_op (TREE_CODE (t), op1);\n+      return build_x_unary_op (TREE_CODE (t), op1, complain);\n \n     case PREDECREMENT_EXPR:\n     case PREINCREMENT_EXPR:\n@@ -10745,7 +10746,8 @@ tsubst_copy_and_build (tree t,\n     case UNARY_PLUS_EXPR:  /* Unary + */\n     case REALPART_EXPR:\n     case IMAGPART_EXPR:\n-      return build_x_unary_op (TREE_CODE (t), RECUR (TREE_OPERAND (t, 0)));\n+      return build_x_unary_op (TREE_CODE (t), RECUR (TREE_OPERAND (t, 0)),\n+                               complain);\n \n     case ADDR_EXPR:\n       op1 = TREE_OPERAND (t, 0);\n@@ -10757,7 +10759,7 @@ tsubst_copy_and_build (tree t,\n \t\t\t\t\t\t  in_decl);\n       if (TREE_CODE (op1) == LABEL_DECL)\n \treturn finish_label_address_expr (DECL_NAME (op1));\n-      return build_x_unary_op (ADDR_EXPR, op1);\n+      return build_x_unary_op (ADDR_EXPR, op1, complain);\n \n     case PLUS_EXPR:\n     case MINUS_EXPR:\n@@ -10800,7 +10802,8 @@ tsubst_copy_and_build (tree t,\n \t (TREE_NO_WARNING (TREE_OPERAND (t, 1))\n \t  ? ERROR_MARK\n \t  : TREE_CODE (TREE_OPERAND (t, 1))),\n-\t /*overloaded_p=*/NULL);\n+\t /*overloaded_p=*/NULL,\n+\t complain);\n \n     case SCOPE_REF:\n       return tsubst_qualified_id (t, args, complain, in_decl, /*done=*/true,\n@@ -10816,7 +10819,8 @@ tsubst_copy_and_build (tree t,\n \t\t\t\t(TREE_NO_WARNING (TREE_OPERAND (t, 1))\n \t\t\t\t ? ERROR_MARK\n \t\t\t\t : TREE_CODE (TREE_OPERAND (t, 1))),\n-\t\t\t\t/*overloaded_p=*/NULL);\n+\t\t\t\t/*overloaded_p=*/NULL,\n+\t\t\t\tcomplain);\n \n     case SIZEOF_EXPR:\n       if (PACK_EXPANSION_P (TREE_OPERAND (t, 0)))\n@@ -10849,16 +10853,19 @@ tsubst_copy_and_build (tree t,\n \t  --skip_evaluation;\n \t}\n       if (TYPE_P (op1))\n-\treturn cxx_sizeof_or_alignof_type (op1, TREE_CODE (t), true);\n+\treturn cxx_sizeof_or_alignof_type (op1, TREE_CODE (t), \n+                                           complain & tf_error);\n       else\n-\treturn cxx_sizeof_or_alignof_expr (op1, TREE_CODE (t));\n+\treturn cxx_sizeof_or_alignof_expr (op1, TREE_CODE (t), \n+                                           complain & tf_error);\n \n     case MODOP_EXPR:\n       {\n \ttree r = build_x_modify_expr\n \t  (RECUR (TREE_OPERAND (t, 0)),\n \t   TREE_CODE (TREE_OPERAND (t, 1)),\n-\t   RECUR (TREE_OPERAND (t, 2)));\n+\t   RECUR (TREE_OPERAND (t, 2)),\n+\t   complain);\n \t/* TREE_NO_WARNING must be set if either the expression was\n \t   parenthesized or it uses an operator such as >>= rather\n \t   than plain assignment.  In the former case, it was already\n@@ -10896,7 +10903,8 @@ tsubst_copy_and_build (tree t,\n \t   RECUR (TREE_OPERAND (t, 1)),\n \t   RECUR (TREE_OPERAND (t, 2)),\n \t   init,\n-\t   NEW_EXPR_USE_GLOBAL (t));\n+\t   NEW_EXPR_USE_GLOBAL (t),\n+           complain);\n       }\n \n     case DELETE_EXPR:\n@@ -10908,7 +10916,8 @@ tsubst_copy_and_build (tree t,\n \n     case COMPOUND_EXPR:\n       return build_x_compound_expr (RECUR (TREE_OPERAND (t, 0)),\n-\t\t\t\t    RECUR (TREE_OPERAND (t, 1)));\n+\t\t\t\t    RECUR (TREE_OPERAND (t, 1)),\n+                                    complain);\n \n     case CALL_EXPR:\n       {\n@@ -10982,25 +10991,29 @@ tsubst_copy_and_build (tree t,\n \t    if (!BASELINK_P (TREE_OPERAND (function, 1)))\n \t      return finish_call_expr (function, call_args,\n \t\t\t\t       /*disallow_virtual=*/false,\n-\t\t\t\t       /*koenig_p=*/false);\n+\t\t\t\t       /*koenig_p=*/false,\n+\t\t\t\t       complain);\n \t    else\n \t      return (build_new_method_call\n \t\t      (TREE_OPERAND (function, 0),\n \t\t       TREE_OPERAND (function, 1),\n \t\t       call_args, NULL_TREE,\n \t\t       qualified_p ? LOOKUP_NONVIRTUAL : LOOKUP_NORMAL,\n-\t\t       /*fn_p=*/NULL));\n+\t\t       /*fn_p=*/NULL,\n+\t\t       complain));\n \t  }\n \treturn finish_call_expr (function, call_args,\n \t\t\t\t /*disallow_virtual=*/qualified_p,\n-\t\t\t\t koenig_p);\n+\t\t\t\t koenig_p,\n+\t\t\t\t complain);\n       }\n \n     case COND_EXPR:\n       return build_x_conditional_expr\n \t(RECUR (TREE_OPERAND (t, 0)),\n \t RECUR (TREE_OPERAND (t, 1)),\n-\t RECUR (TREE_OPERAND (t, 2)));\n+\t RECUR (TREE_OPERAND (t, 2)),\n+         complain);\n \n     case PSEUDO_DTOR_EXPR:\n       return finish_pseudo_destructor_expr\n@@ -11184,7 +11197,8 @@ tsubst_copy_and_build (tree t,\n \t  return finish_non_static_data_member (member, object, NULL_TREE);\n \n \treturn finish_class_member_access_expr (object, member,\n-\t\t\t\t\t\t/*template_p=*/false);\n+\t\t\t\t\t\t/*template_p=*/false,\n+\t\t\t\t\t\tcomplain);\n       }\n \n     case THROW_EXPR:"}, {"sha": "d17ef6433e1ae8e74c5c773e2cab9e54b0c08572", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 26, "deletions": 18, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ade1ed2c08bf2f327ee24afc57bc263fd90e6e1/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ade1ed2c08bf2f327ee24afc57bc263fd90e6e1/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=5ade1ed2c08bf2f327ee24afc57bc263fd90e6e1", "patch": "@@ -104,7 +104,7 @@ static GTY (()) VEC(tinfo_s,gc) *tinfo_descs;\n \n static tree ifnonnull (tree, tree);\n static tree tinfo_name (tree);\n-static tree build_dynamic_cast_1 (tree, tree);\n+static tree build_dynamic_cast_1 (tree, tree, tsubst_flags_t);\n static tree throw_bad_cast (void);\n static tree throw_bad_typeid (void);\n static tree get_tinfo_decl_dynamic (tree);\n@@ -188,7 +188,9 @@ build_headof (tree exp)\n   index = build_int_cst (NULL_TREE,\n \t\t\t -2 * TARGET_VTABLE_DATA_ENTRY_DISTANCE);\n \n-  offset = build_vtbl_ref (build_indirect_ref (exp, NULL), index);\n+  offset = build_vtbl_ref (cp_build_indirect_ref (exp, NULL, \n+                                                  tf_warning_or_error), \n+                           index);\n \n   type = build_qualified_type (ptr_type_node,\n \t\t\t       cp_type_quals (TREE_TYPE (exp)));\n@@ -272,7 +274,7 @@ get_tinfo_decl_dynamic (tree exp)\n     /* Otherwise return the type_info for the static type of the expr.  */\n     t = get_tinfo_ptr (TYPE_MAIN_VARIANT (type));\n \n-  return build_indirect_ref (t, NULL);\n+  return cp_build_indirect_ref (t, NULL, tf_warning_or_error);\n }\n \n static bool\n@@ -463,7 +465,8 @@ get_typeid (tree type)\n   if (!type)\n     return error_mark_node;\n \n-  return build_indirect_ref (get_tinfo_ptr (type), NULL);\n+  return cp_build_indirect_ref (get_tinfo_ptr (type), NULL, \n+                                tf_warning_or_error);\n }\n \n /* Check whether TEST is null before returning RESULT.  If TEST is used in\n@@ -483,7 +486,7 @@ ifnonnull (tree test, tree result)\n    paper.  */\n \n static tree\n-build_dynamic_cast_1 (tree type, tree expr)\n+build_dynamic_cast_1 (tree type, tree expr, tsubst_flags_t complain)\n {\n   enum tree_code tc = TREE_CODE (type);\n   tree exprtype = TREE_TYPE (expr);\n@@ -626,8 +629,9 @@ build_dynamic_cast_1 (tree type, tree expr)\n \t\t  && TREE_CODE (TREE_TYPE (old_expr)) == RECORD_TYPE)\n \t\t{\n \t\t  tree expr = throw_bad_cast ();\n-\t\t  warning (0, \"dynamic_cast of %q#D to %q#T can never succeed\",\n-\t\t\t   old_expr, type);\n+                  if (complain & tf_warning)\n+                    warning (0, \"dynamic_cast of %q#D to %q#T can never succeed\",\n+                             old_expr, type);\n \t\t  /* Bash it to the expected type.  */\n \t\t  TREE_TYPE (expr) = type;\n \t\t  return expr;\n@@ -640,8 +644,9 @@ build_dynamic_cast_1 (tree type, tree expr)\n \t      if (TREE_CODE (op) == VAR_DECL\n \t\t  && TREE_CODE (TREE_TYPE (op)) == RECORD_TYPE)\n \t\t{\n-\t\t  warning (0, \"dynamic_cast of %q#D to %q#T can never succeed\",\n-\t\t\t   op, type);\n+                  if (complain & tf_warning)\n+                    warning (0, \"dynamic_cast of %q#D to %q#T can never succeed\",\n+                             op, type);\n \t\t  retval = build_int_cst (type, 0);\n \t\t  return retval;\n \t\t}\n@@ -650,18 +655,19 @@ build_dynamic_cast_1 (tree type, tree expr)\n \t  /* Use of dynamic_cast when -fno-rtti is prohibited.  */\n \t  if (!flag_rtti)\n \t    {\n-\t      error (\"%<dynamic_cast%> not permitted with -fno-rtti\");\n+              if (complain & tf_error)\n+                error (\"%<dynamic_cast%> not permitted with -fno-rtti\");\n \t      return error_mark_node;\n \t    }\n \n \t  target_type = TYPE_MAIN_VARIANT (TREE_TYPE (type));\n \t  static_type = TYPE_MAIN_VARIANT (TREE_TYPE (exprtype));\n \t  td2 = get_tinfo_decl (target_type);\n \t  mark_used (td2);\n-\t  td2 = build_unary_op (ADDR_EXPR, td2, 0);\n+\t  td2 = cp_build_unary_op (ADDR_EXPR, td2, 0, complain);\n \t  td3 = get_tinfo_decl (static_type);\n \t  mark_used (td3);\n-\t  td3 = build_unary_op (ADDR_EXPR, td3, 0);\n+\t  td3 = cp_build_unary_op (ADDR_EXPR, td3, 0, complain);\n \n \t  /* Determine how T and V are related.  */\n \t  boff = dcast_base_hint (static_type, target_type);\n@@ -671,7 +677,7 @@ build_dynamic_cast_1 (tree type, tree expr)\n \n \t  expr1 = expr;\n \t  if (tc == REFERENCE_TYPE)\n-\t    expr1 = build_unary_op (ADDR_EXPR, expr1, 0);\n+\t    expr1 = cp_build_unary_op (ADDR_EXPR, expr1, 0, complain);\n \n \t  elems[0] = expr1;\n \t  elems[1] = td3;\n@@ -726,13 +732,14 @@ build_dynamic_cast_1 (tree type, tree expr)\n     errstr = \"source type is not polymorphic\";\n \n  fail:\n-  error (\"cannot dynamic_cast %qE (of type %q#T) to type %q#T (%s)\",\n-\t expr, exprtype, type, errstr);\n+  if (complain & tf_error)\n+    error (\"cannot dynamic_cast %qE (of type %q#T) to type %q#T (%s)\",\n+           expr, exprtype, type, errstr);\n   return error_mark_node;\n }\n \n tree\n-build_dynamic_cast (tree type, tree expr)\n+build_dynamic_cast (tree type, tree expr, tsubst_flags_t complain)\n {\n   if (type == error_mark_node || expr == error_mark_node)\n     return error_mark_node;\n@@ -744,7 +751,7 @@ build_dynamic_cast (tree type, tree expr)\n       return convert_from_reference (expr);\n     }\n \n-  return convert_from_reference (build_dynamic_cast_1 (type, expr));\n+  return convert_from_reference (build_dynamic_cast_1 (type, expr, complain));\n }\n \f\n /* Return the runtime bit mask encoding the qualifiers of TYPE.  */\n@@ -876,7 +883,8 @@ tinfo_base_init (tinfo_s *ti, tree target)\n \t}\n \n       vtable_ptr = get_vtable_decl (real_type, /*complete=*/1);\n-      vtable_ptr = build_unary_op (ADDR_EXPR, vtable_ptr, 0);\n+      vtable_ptr = cp_build_unary_op (ADDR_EXPR, vtable_ptr, 0, \n+                                   tf_warning_or_error);\n \n       /* We need to point into the middle of the vtable.  */\n       vtable_ptr = build2"}, {"sha": "8966bf5d9216288594db84a4afb61ebe44a0be82", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 35, "deletions": 23, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ade1ed2c08bf2f327ee24afc57bc263fd90e6e1/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ade1ed2c08bf2f327ee24afc57bc263fd90e6e1/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=5ade1ed2c08bf2f327ee24afc57bc263fd90e6e1", "patch": "@@ -536,7 +536,7 @@ simplify_loop_decl_cond (tree *cond_p, tree body)\n   *cond_p = boolean_true_node;\n \n   if_stmt = begin_if_stmt ();\n-  cond = build_unary_op (TRUTH_NOT_EXPR, cond, 0);\n+  cond = cp_build_unary_op (TRUTH_NOT_EXPR, cond, 0, tf_warning_or_error);\n   finish_if_stmt_cond (cond, if_stmt);\n   finish_break_stmt ();\n   finish_then_clause (if_stmt);\n@@ -614,10 +614,11 @@ finish_expr_stmt (tree expr)\n \t{\n \t  if (warn_sequence_point)\n \t    verify_sequence_points (expr);\n-\t  expr = convert_to_void (expr, \"statement\");\n+\t  expr = convert_to_void (expr, \"statement\", tf_warning_or_error);\n \t}\n       else if (!type_dependent_expression_p (expr))\n-\tconvert_to_void (build_non_dependent_expr (expr), \"statement\");\n+\tconvert_to_void (build_non_dependent_expr (expr), \"statement\", \n+                         tf_warning_or_error);\n \n       if (check_for_bare_parameter_packs (expr))\n         expr = error_mark_node;\n@@ -872,10 +873,12 @@ finish_for_expr (tree expr, tree for_stmt)\n     {\n       if (warn_sequence_point)\n \tverify_sequence_points (expr);\n-      expr = convert_to_void (expr, \"3rd expression in for\");\n+      expr = convert_to_void (expr, \"3rd expression in for\",\n+                              tf_warning_or_error);\n     }\n   else if (!type_dependent_expression_p (expr))\n-    convert_to_void (build_non_dependent_expr (expr), \"3rd expression in for\");\n+    convert_to_void (build_non_dependent_expr (expr), \"3rd expression in for\",\n+                     tf_warning_or_error);\n   expr = maybe_cleanup_point_expr_void (expr);\n   if (check_for_bare_parameter_packs (expr))\n     expr = error_mark_node;\n@@ -1247,7 +1250,7 @@ finish_asm_stmt (int volatile_p, tree string, tree output_operands,\n \t     otherwise we'll get an error.  Gross, but ...  */\n \t  STRIP_NOPS (operand);\n \n-\t  if (!lvalue_or_else (operand, lv_asm))\n+\t  if (!lvalue_or_else (operand, lv_asm, tf_warning_or_error))\n \t    operand = error_mark_node;\n \n \t  if (operand != error_mark_node\n@@ -1505,7 +1508,8 @@ finish_non_static_data_member (tree decl, tree object, tree qualifying_scope)\n \n       return build_class_member_access_expr (object, decl,\n \t\t\t\t\t     /*access_path=*/NULL_TREE,\n-\t\t\t\t\t     /*preserve_reference=*/false);\n+\t\t\t\t\t     /*preserve_reference=*/false,\n+\t\t\t\t\t     tf_warning_or_error);\n     }\n }\n \n@@ -1643,7 +1647,8 @@ finish_qualified_id_expr (tree qualifying_class,\n \t\t(maybe_dummy_object (qualifying_class, NULL),\n \t\t expr,\n \t\t BASELINK_ACCESS_BINFO (expr),\n-\t\t /*preserve_reference=*/false));\n+\t\t /*preserve_reference=*/false,\n+\t\t tf_warning_or_error));\n       else if (done)\n \t/* The expression is a qualified name whose address is not\n \t   being taken.  */\n@@ -1832,7 +1837,8 @@ perform_koenig_lookup (tree fn, tree args)\n    Returns code for the call.  */\n \n tree\n-finish_call_expr (tree fn, tree args, bool disallow_virtual, bool koenig_p)\n+finish_call_expr (tree fn, tree args, bool disallow_virtual, bool koenig_p,\n+\t\t  tsubst_flags_t complain)\n {\n   tree result;\n   tree orig_fn;\n@@ -1931,7 +1937,8 @@ finish_call_expr (tree fn, tree args, bool disallow_virtual, bool koenig_p)\n       result = build_new_method_call (object, fn, args, NULL_TREE,\n \t\t\t\t      (disallow_virtual\n \t\t\t\t       ? LOOKUP_NONVIRTUAL : 0),\n-\t\t\t\t      /*fn_p=*/NULL);\n+\t\t\t\t      /*fn_p=*/NULL,\n+\t\t\t\t      complain);\n     }\n   else if (is_overloaded_fn (fn))\n     {\n@@ -1943,7 +1950,7 @@ finish_call_expr (tree fn, tree args, bool disallow_virtual, bool koenig_p)\n \n       if (!result)\n \t/* A call to a namespace-scope function.  */\n-\tresult = build_new_function_call (fn, args, koenig_p);\n+\tresult = build_new_function_call (fn, args, koenig_p, complain);\n     }\n   else if (TREE_CODE (fn) == PSEUDO_DTOR_EXPR)\n     {\n@@ -1960,11 +1967,11 @@ finish_call_expr (tree fn, tree args, bool disallow_virtual, bool koenig_p)\n     /* If the \"function\" is really an object of class type, it might\n        have an overloaded `operator ()'.  */\n     result = build_new_op (CALL_EXPR, LOOKUP_NORMAL, fn, args, NULL_TREE,\n-\t\t\t   /*overloaded_p=*/NULL);\n+\t\t\t   /*overloaded_p=*/NULL, complain);\n \n   if (!result)\n     /* A call where the function is unknown.  */\n-    result = build_function_call (fn, args);\n+    result = cp_build_function_call (fn, args, complain);\n \n   if (processing_template_decl)\n     {\n@@ -1981,7 +1988,7 @@ finish_call_expr (tree fn, tree args, bool disallow_virtual, bool koenig_p)\n tree\n finish_increment_expr (tree expr, enum tree_code code)\n {\n-  return build_x_unary_op (code, expr);\n+  return build_x_unary_op (code, expr, tf_warning_or_error);\n }\n \n /* Finish a use of `this'.  Returns an expression for `this'.  */\n@@ -2070,7 +2077,7 @@ finish_pseudo_destructor_expr (tree object, tree scope, tree destructor)\n tree\n finish_unary_op_expr (enum tree_code code, tree expr)\n {\n-  tree result = build_x_unary_op (code, expr);\n+  tree result = build_x_unary_op (code, expr, tf_warning_or_error);\n   /* Inside a template, build_x_unary_op does not fold the\n      expression. So check whether the result is folded before\n      setting TREE_NEGATED_INT.  */\n@@ -2952,7 +2959,8 @@ finish_id_expression (tree id_expression,\n \t      /* A set of member functions.  */\n \t      decl = maybe_dummy_object (DECL_CONTEXT (first_fn), 0);\n \t      return finish_class_member_access_expr (decl, id_expression,\n-\t\t\t\t\t\t      /*template_p=*/false);\n+\t\t\t\t\t\t      /*template_p=*/false,\n+\t\t\t\t\t\t      tf_warning_or_error);\n \t    }\n \n \t  decl = baselink_for_fns (decl);\n@@ -3119,7 +3127,8 @@ simplify_aggr_init_expr (tree *tp)\n \t SLOT.  */\n       push_deferring_access_checks (dk_no_check);\n       call_expr = build_aggr_init (slot, call_expr,\n-\t\t\t\t   DIRECT_BIND | LOOKUP_ONLYCONVERTING);\n+\t\t\t\t   DIRECT_BIND | LOOKUP_ONLYCONVERTING,\n+                                   tf_warning_or_error);\n       pop_deferring_access_checks ();\n       call_expr = build2 (COMPOUND_EXPR, TREE_TYPE (slot), call_expr, slot);\n     }\n@@ -3668,7 +3677,8 @@ finish_omp_clauses (tree clauses)\n \t\t}\n \t      t = build_special_member_call (NULL_TREE,\n \t\t\t\t\t     complete_ctor_identifier,\n-\t\t\t\t\t     t, inner_type, LOOKUP_NORMAL);\n+\t\t\t\t\t     t, inner_type, LOOKUP_NORMAL,\n+                                             tf_warning_or_error);\n \n \t      if (targetm.cxx.cdtor_returns_this () || errorcount)\n \t\t/* Because constructors and destructors return this,\n@@ -3690,7 +3700,8 @@ finish_omp_clauses (tree clauses)\n \t      t = build_int_cst (build_pointer_type (inner_type), 0);\n \t      t = build1 (INDIRECT_REF, inner_type, t);\n \t      t = build_special_member_call (t, complete_dtor_identifier,\n-\t\t\t\t\t     NULL, inner_type, LOOKUP_NORMAL);\n+\t\t\t\t\t     NULL, inner_type, LOOKUP_NORMAL,\n+                                             tf_warning_or_error);\n \n \t      if (targetm.cxx.cdtor_returns_this () || errorcount)\n \t\t/* Because constructors and destructors return this,\n@@ -3713,7 +3724,8 @@ finish_omp_clauses (tree clauses)\n \t      t = build1 (INDIRECT_REF, inner_type, t);\n \t      t = build_special_member_call (t, ansi_assopname (NOP_EXPR),\n \t\t\t\t\t     build_tree_list (NULL, t),\n-\t\t\t\t\t     inner_type, LOOKUP_NORMAL);\n+\t\t\t\t\t     inner_type, LOOKUP_NORMAL,\n+                                             tf_warning_or_error);\n \n \t      /* We'll have called convert_from_reference on the call, which\n \t\t may well have added an indirect_ref.  It's unneeded here,\n@@ -3937,7 +3949,7 @@ finish_omp_for (location_t locus, tree decl, tree init, tree cond,\n \n   if (!processing_template_decl)\n     init = fold_build_cleanup_point_expr (TREE_TYPE (init), init);\n-  init = build_modify_expr (decl, NOP_EXPR, init);\n+  init = cp_build_modify_expr (decl, NOP_EXPR, init, tf_warning_or_error);\n   if (cond && TREE_SIDE_EFFECTS (cond) && COMPARISON_CLASS_P (cond))\n     {\n       int n = TREE_SIDE_EFFECTS (TREE_OPERAND (cond, 1)) != 0;\n@@ -4006,15 +4018,15 @@ void\n finish_omp_barrier (void)\n {\n   tree fn = built_in_decls[BUILT_IN_GOMP_BARRIER];\n-  tree stmt = finish_call_expr (fn, NULL, false, false);\n+  tree stmt = finish_call_expr (fn, NULL, false, false, tf_warning_or_error);\n   finish_expr_stmt (stmt);\n }\n \n void\n finish_omp_flush (void)\n {\n   tree fn = built_in_decls[BUILT_IN_SYNCHRONIZE];\n-  tree stmt = finish_call_expr (fn, NULL, false, false);\n+  tree stmt = finish_call_expr (fn, NULL, false, false, tf_warning_or_error);\n   finish_expr_stmt (stmt);\n }\n "}, {"sha": "027f1c9b1f2fdd850a7d0fff33b904ab94d4391e", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ade1ed2c08bf2f327ee24afc57bc263fd90e6e1/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ade1ed2c08bf2f327ee24afc57bc263fd90e6e1/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=5ade1ed2c08bf2f327ee24afc57bc263fd90e6e1", "patch": "@@ -1992,7 +1992,7 @@ tree\n build_dummy_object (tree type)\n {\n   tree decl = build1 (NOP_EXPR, build_pointer_type (type), void_zero_node);\n-  return build_indirect_ref (decl, NULL);\n+  return cp_build_indirect_ref (decl, NULL, tf_warning_or_error);\n }\n \n /* We've gotten a reference to a member of TYPE.  Return *this if appropriate,\n@@ -2569,10 +2569,10 @@ stabilize_expr (tree exp, tree* initp)\n     }\n   else\n     {\n-      exp = build_unary_op (ADDR_EXPR, exp, 1);\n+      exp = cp_build_unary_op (ADDR_EXPR, exp, 1, tf_warning_or_error);\n       init_expr = get_target_expr (exp);\n       exp = TARGET_EXPR_SLOT (init_expr);\n-      exp = build_indirect_ref (exp, 0);\n+      exp = cp_build_indirect_ref (exp, 0, tf_warning_or_error);\n     }\n   *initp = init_expr;\n "}, {"sha": "2e8151b1ff3298604c4bbd6fa261faa62f3be59a", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 623, "deletions": 324, "changes": 947, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ade1ed2c08bf2f327ee24afc57bc263fd90e6e1/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ade1ed2c08bf2f327ee24afc57bc263fd90e6e1/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=5ade1ed2c08bf2f327ee24afc57bc263fd90e6e1", "patch": "@@ -47,9 +47,11 @@ along with GCC; see the file COPYING3.  If not see\n \n static tree pfn_from_ptrmemfunc (tree);\n static tree delta_from_ptrmemfunc (tree);\n-static tree convert_for_assignment (tree, tree, const char *, tree, int);\n+static tree convert_for_assignment (tree, tree, const char *, tree, int,\n+\t\t\t\t    tsubst_flags_t);\n static tree cp_pointer_int_sum (enum tree_code, tree, tree);\n-static tree rationalize_conditional_expr (enum tree_code, tree);\n+static tree rationalize_conditional_expr (enum tree_code, tree, \n+\t\t\t\t\t  tsubst_flags_t);\n static int comp_ptr_ttypes_real (tree, tree, int);\n static bool comp_except_types (tree, tree, bool);\n static bool comp_array_types (const_tree, const_tree, bool);\n@@ -59,7 +61,8 @@ static void casts_away_constness_r (tree *, tree *);\n static bool casts_away_constness (tree, tree);\n static void maybe_warn_about_returning_address_of_local (tree);\n static tree lookup_destructor (tree, tree, tree);\n-static int convert_arguments (int, tree *, tree, tree, tree, int);\n+static int convert_arguments (int, tree *, tree, tree, tree, int,\n+                              tsubst_flags_t);\n \n /* Do `exp = require_complete_type (exp);' to make sure exp\n    does not have an incomplete type.  (That includes void types.)\n@@ -394,7 +397,8 @@ type_after_usual_arithmetic_conversions (tree t1, tree t2)\n    case.  See that function for documentation fo the parameters.  */\n \n static tree\n-composite_pointer_type_r (tree t1, tree t2, const char* location)\n+composite_pointer_type_r (tree t1, tree t2, const char* location,\n+\t\t\t  tsubst_flags_t complain)\n {\n   tree pointee1;\n   tree pointee2;\n@@ -426,12 +430,14 @@ composite_pointer_type_r (tree t1, tree t2, const char* location)\n \t    && TREE_CODE (pointee2) == POINTER_TYPE)\n \t   || (TYPE_PTR_TO_MEMBER_P (pointee1)\n \t       && TYPE_PTR_TO_MEMBER_P (pointee2)))\n-    result_type = composite_pointer_type_r (pointee1, pointee2, location);\n+    result_type = composite_pointer_type_r (pointee1, pointee2, location,\n+\t\t\t\t\t    complain);\n   else\n     {\n-      pedwarn (\"%s between distinct pointer types %qT and %qT \"\n-\t       \"lacks a cast\",\n-\t       location, t1, t2);\n+      if (complain & tf_error)\n+\tpedwarn (\"%s between distinct pointer types %qT and %qT \"\n+\t\t \"lacks a cast\",\n+\t\t location, t1, t2);\n       result_type = void_type_node;\n     }\n   result_type = cp_build_qualified_type (result_type,\n@@ -442,7 +448,8 @@ composite_pointer_type_r (tree t1, tree t2, const char* location)\n   if (TYPE_PTR_TO_MEMBER_P (t1))\n     {\n       if (!same_type_p (TYPE_PTRMEM_CLASS_TYPE (t1),\n-\t\t\tTYPE_PTRMEM_CLASS_TYPE (t2)))\n+\t\t\tTYPE_PTRMEM_CLASS_TYPE (t2))\n+\t  && (complain & tf_error))\n \tpedwarn (\"%s between distinct pointer types %qT and %qT \"\n \t\t \"lacks a cast\",\n \t\t location, t1, t2);\n@@ -466,7 +473,7 @@ composite_pointer_type_r (tree t1, tree t2, const char* location)\n \n tree\n composite_pointer_type (tree t1, tree t2, tree arg1, tree arg2,\n-\t\t\tconst char* location)\n+\t\t\tconst char* location, tsubst_flags_t complain)\n {\n   tree class1;\n   tree class2;\n@@ -504,7 +511,7 @@ composite_pointer_type (tree t1, tree t2, tree arg1, tree arg2,\n       tree attributes;\n       tree result_type;\n \n-      if (pedantic && TYPE_PTRFN_P (t2))\n+      if (pedantic && TYPE_PTRFN_P (t2) && (complain & tf_error))\n \tpedwarn (\"ISO C++ forbids %s between pointer of type %<void *%> \"\n \t\t \"and pointer-to-function\", location);\n       result_type\n@@ -543,8 +550,9 @@ composite_pointer_type (tree t1, tree t2, tree arg1, tree arg2,\n \t      (cp_build_qualified_type (class2, TYPE_QUALS (class1))));\n       else\n \t{\n-\t  error (\"%s between distinct pointer types %qT and %qT \"\n-\t\t \"lacks a cast\", location, t1, t2);\n+\t  if (complain & tf_error)\n+\t    error (\"%s between distinct pointer types %qT and %qT \"\n+\t\t   \"lacks a cast\", location, t1, t2);\n \t  return error_mark_node;\n \t}\n     }\n@@ -563,13 +571,14 @@ composite_pointer_type (tree t1, tree t2, tree arg1, tree arg2,\n \tt2 = build_ptrmem_type (class1, TYPE_PTRMEM_POINTED_TO_TYPE (t2));\n       else\n \t{\n-\t  error (\"%s between distinct pointer-to-member types %qT and %qT \"\n-\t\t \"lacks a cast\", location, t1, t2);\n+\t  if (complain & tf_error)\n+\t    error (\"%s between distinct pointer-to-member types %qT and %qT \"\n+\t\t   \"lacks a cast\", location, t1, t2);\n \t  return error_mark_node;\n \t}\n     }\n \n-  return composite_pointer_type_r (t1, t2, location);\n+  return composite_pointer_type_r (t1, t2, location, complain);\n }\n \n /* Return the merged type of two types.\n@@ -764,7 +773,7 @@ common_type (tree t1, tree t2)\n \t   || (TYPE_PTRMEM_P (t1) && TYPE_PTRMEM_P (t2))\n \t   || (TYPE_PTRMEMFUNC_P (t1) && TYPE_PTRMEMFUNC_P (t2)))\n     return composite_pointer_type (t1, t2, error_mark_node, error_mark_node,\n-\t\t\t\t   \"conversion\");\n+\t\t\t\t   \"conversion\", tf_warning_or_error);\n   else\n     gcc_unreachable ();\n }\n@@ -1299,10 +1308,27 @@ cxx_sizeof_or_alignof_type (tree type, enum tree_code op, bool complain)\n \t\t\t\t   complain);\n }\n \n+/* Return the size of the type, without producing any warnings for\n+   types whose size cannot be taken.  This routine should be used only\n+   in some other routine that has already produced a diagnostic about\n+   using the size of such a type.  */\n+tree \n+cxx_sizeof_nowarn (tree type)\n+{\n+  if (TREE_CODE (type) == FUNCTION_TYPE\n+      || TREE_CODE (type) == VOID_TYPE\n+      || TREE_CODE (type) == ERROR_MARK)\n+    return size_one_node;\n+  else if (!COMPLETE_TYPE_P (type))\n+    return size_zero_node;\n+  else\n+    return cxx_sizeof_or_alignof_type (type, SIZEOF_EXPR, false);\n+}\n+\n /* Process a sizeof expression where the operand is an expression.  */\n \n static tree\n-cxx_sizeof_expr (tree e)\n+cxx_sizeof_expr (tree e, tsubst_flags_t complain)\n {\n   if (e == error_mark_node)\n     return error_mark_node;\n@@ -1320,24 +1346,33 @@ cxx_sizeof_expr (tree e)\n       && TREE_CODE (TREE_OPERAND (e, 1)) == FIELD_DECL\n       && DECL_C_BIT_FIELD (TREE_OPERAND (e, 1)))\n     {\n-      error (\"invalid application of %<sizeof%> to a bit-field\");\n+      if (complain & tf_error)\n+        error (\"invalid application of %<sizeof%> to a bit-field\");\n+      else\n+        return error_mark_node;\n       e = char_type_node;\n     }\n   else if (is_overloaded_fn (e))\n     {\n-      pedwarn (\"ISO C++ forbids applying %<sizeof%> to an expression of \"\n-\t       \"function type\");\n+      if (complain & tf_error)\n+        pedwarn (\"ISO C++ forbids applying %<sizeof%> to an expression of \"\n+                 \"function type\");\n+      else\n+        return error_mark_node;\n       e = char_type_node;\n     }\n   else if (type_unknown_p (e))\n     {\n-      cxx_incomplete_type_error (e, TREE_TYPE (e));\n+      if (complain & tf_error)\n+        cxx_incomplete_type_error (e, TREE_TYPE (e));\n+      else\n+        return error_mark_node;\n       e = char_type_node;\n     }\n   else\n     e = TREE_TYPE (e);\n \n-  return cxx_sizeof_or_alignof_type (e, SIZEOF_EXPR, true);\n+  return cxx_sizeof_or_alignof_type (e, SIZEOF_EXPR, complain & tf_error);\n }\n \n /* Implement the __alignof keyword: Return the minimum required\n@@ -1346,7 +1381,7 @@ cxx_sizeof_expr (tree e)\n    \"aligned\" __attribute__ specification).  */\n \n static tree\n-cxx_alignof_expr (tree e)\n+cxx_alignof_expr (tree e, tsubst_flags_t complain)\n {\n   tree t;\n \n@@ -1368,28 +1403,38 @@ cxx_alignof_expr (tree e)\n \t   && TREE_CODE (TREE_OPERAND (e, 1)) == FIELD_DECL\n \t   && DECL_C_BIT_FIELD (TREE_OPERAND (e, 1)))\n     {\n-      error (\"invalid application of %<__alignof%> to a bit-field\");\n+      if (complain & tf_error)\n+        error (\"invalid application of %<__alignof%> to a bit-field\");\n+      else\n+        return error_mark_node;\n       t = size_one_node;\n     }\n   else if (TREE_CODE (e) == COMPONENT_REF\n \t   && TREE_CODE (TREE_OPERAND (e, 1)) == FIELD_DECL)\n     t = size_int (DECL_ALIGN_UNIT (TREE_OPERAND (e, 1)));\n   else if (is_overloaded_fn (e))\n     {\n-      pedwarn (\"ISO C++ forbids applying %<__alignof%> to an expression of \"\n-\t       \"function type\");\n+      if (complain & tf_error)\n+        pedwarn (\"ISO C++ forbids applying %<__alignof%> to an expression of \"\n+                 \"function type\");\n+      else\n+        return error_mark_node;\n       if (TREE_CODE (e) == FUNCTION_DECL)\n \tt = size_int (DECL_ALIGN_UNIT (e));\n       else\n \tt = size_one_node;\n     }\n   else if (type_unknown_p (e))\n     {\n-      cxx_incomplete_type_error (e, TREE_TYPE (e));\n+      if (complain & tf_error)\n+        cxx_incomplete_type_error (e, TREE_TYPE (e));\n+      else\n+        return error_mark_node;\n       t = size_one_node;\n     }\n   else\n-    return cxx_sizeof_or_alignof_type (TREE_TYPE (e), ALIGNOF_EXPR, true);\n+    return cxx_sizeof_or_alignof_type (TREE_TYPE (e), ALIGNOF_EXPR, \n+                                       complain & tf_error);\n \n   return fold_convert (size_type_node, t);\n }\n@@ -1398,12 +1443,12 @@ cxx_alignof_expr (tree e)\n    is an expression.  */\n \n tree\n-cxx_sizeof_or_alignof_expr (tree e, enum tree_code op)\n+cxx_sizeof_or_alignof_expr (tree e, enum tree_code op, bool complain)\n {\n   if (op == SIZEOF_EXPR)\n-    return cxx_sizeof_expr (e);\n+    return cxx_sizeof_expr (e, complain? tf_warning_or_error : tf_none);\n   else\n-    return cxx_alignof_expr (e);\n+    return cxx_alignof_expr (e, complain? tf_warning_or_error : tf_none);\n }\n \f\n /* EXPR is being used in a context that is not a function call.\n@@ -1423,11 +1468,12 @@ cxx_sizeof_or_alignof_expr (tree e, enum tree_code op)\n    violates these rules.  */\n \n bool\n-invalid_nonstatic_memfn_p (const_tree expr)\n+invalid_nonstatic_memfn_p (const_tree expr, tsubst_flags_t complain)\n {\n   if (TREE_CODE (TREE_TYPE (expr)) == METHOD_TYPE)\n     {\n-      error (\"invalid use of non-static member function\");\n+      if (complain & tf_error)\n+        error (\"invalid use of non-static member function\");\n       return true;\n     }\n   return false;\n@@ -1536,10 +1582,10 @@ decay_conversion (tree exp)\n       error (\"void value not ignored as it ought to be\");\n       return error_mark_node;\n     }\n-  if (invalid_nonstatic_memfn_p (exp))\n+  if (invalid_nonstatic_memfn_p (exp, tf_warning_or_error))\n     return error_mark_node;\n   if (code == FUNCTION_TYPE || is_overloaded_fn (exp))\n-    return build_unary_op (ADDR_EXPR, exp, 0);\n+    return cp_build_unary_op (ADDR_EXPR, exp, 0, tf_warning_or_error);\n   if (code == ARRAY_TYPE)\n     {\n       tree adr;\n@@ -1574,7 +1620,7 @@ decay_conversion (tree exp)\n \t}\n       /* This way is better for a COMPONENT_REF since it can\n \t simplify the offset for a component.  */\n-      adr = build_unary_op (ADDR_EXPR, exp, 1);\n+      adr = cp_build_unary_op (ADDR_EXPR, exp, 1, tf_warning_or_error);\n       return cp_convert (ptrtype, adr);\n     }\n \n@@ -1715,7 +1761,8 @@ string_conv_p (const_tree totype, const_tree exp, int warn)\n    get it there.  */\n \n static tree\n-rationalize_conditional_expr (enum tree_code code, tree t)\n+rationalize_conditional_expr (enum tree_code code, tree t,\n+                              tsubst_flags_t complain)\n {\n   /* For MIN_EXPR or MAX_EXPR, fold-const.c has arranged things so that\n      the first operand is always the one to be used if both operands\n@@ -1733,15 +1780,20 @@ rationalize_conditional_expr (enum tree_code code, tree t)\n \t\t\t\t\t\t    ? LE_EXPR : GE_EXPR),\n \t\t\t\t\t\t   op0, TREE_CODE (op0),\n \t\t\t\t\t\t   op1, TREE_CODE (op1),\n-\t\t\t\t\t\t   /*overloaded_p=*/NULL),\n-\t\t\t    build_unary_op (code, op0, 0),\n-\t\t\t    build_unary_op (code, op1, 0));\n+\t\t\t\t\t\t   /*overloaded_p=*/NULL,\n+\t\t\t\t\t\t   complain),\n+                                cp_build_unary_op (code, op0, 0, complain),\n+                                cp_build_unary_op (code, op1, 0, complain),\n+                                complain);\n     }\n \n   return\n     build_conditional_expr (TREE_OPERAND (t, 0),\n-\t\t\t    build_unary_op (code, TREE_OPERAND (t, 1), 0),\n-\t\t\t    build_unary_op (code, TREE_OPERAND (t, 2), 0));\n+\t\t\t    cp_build_unary_op (code, TREE_OPERAND (t, 1), 0,\n+                                               complain),\n+\t\t\t    cp_build_unary_op (code, TREE_OPERAND (t, 2), 0,\n+                                               complain),\n+                            complain);\n }\n \n /* Given the TYPE of an anonymous union field inside T, return the\n@@ -1794,7 +1846,8 @@ lookup_anon_field (tree t, tree type)\n \n tree\n build_class_member_access_expr (tree object, tree member,\n-\t\t\t\ttree access_path, bool preserve_reference)\n+\t\t\t\ttree access_path, bool preserve_reference,\n+\t\t\t\ttsubst_flags_t complain)\n {\n   tree object_type;\n   tree member_scope;\n@@ -1815,8 +1868,9 @@ build_class_member_access_expr (tree object, tree member,\n     return error_mark_node;\n   if (!CLASS_TYPE_P (object_type))\n     {\n-      error (\"request for member %qD in %qE, which is of non-class type %qT\",\n-\t     member, object, object_type);\n+      if (complain & tf_error)\n+\terror (\"request for member %qD in %qE, which is of non-class type %qT\",\n+\t       member, object, object_type);\n       return error_mark_node;\n     }\n \n@@ -1841,10 +1895,13 @@ build_class_member_access_expr (tree object, tree member,\n     member_scope = TYPE_CONTEXT (member_scope);\n   if (!member_scope || !DERIVED_FROM_P (member_scope, object_type))\n     {\n-      if (TREE_CODE (member) == FIELD_DECL)\n-\terror (\"invalid use of nonstatic data member %qE\", member);\n-      else\n-\terror (\"%qD is not a member of %qT\", member, object_type);\n+      if (complain & tf_error)\n+\t{\n+\t  if (TREE_CODE (member) == FIELD_DECL)\n+\t    error (\"invalid use of nonstatic data member %qE\", member);\n+\t  else\n+\t    error (\"%qD is not a member of %qT\", member, object_type);\n+\t}\n       return error_mark_node;\n     }\n \n@@ -1854,7 +1911,7 @@ build_class_member_access_expr (tree object, tree member,\n   {\n     tree temp = unary_complex_lvalue (ADDR_EXPR, object);\n     if (temp)\n-      object = build_indirect_ref (temp, NULL);\n+      object = cp_build_indirect_ref (temp, NULL, complain);\n   }\n \n   /* In [expr.ref], there is an explicit list of the valid choices for\n@@ -1894,10 +1951,13 @@ build_class_member_access_expr (tree object, tree member,\n \t     offsetof macro.  */\n \t  if (null_object_p && kind == bk_via_virtual)\n \t    {\n-\t      error (\"invalid access to non-static data member %qD of \"\n-\t\t     \"NULL object\",\n-\t\t     member);\n-\t      error (\"(perhaps the %<offsetof%> macro was used incorrectly)\");\n+\t      if (complain & tf_error)\n+\t\t{\n+\t\t  error (\"invalid access to non-static data member %qD of \"\n+\t\t\t \"NULL object\",\n+\t\t\t member);\n+\t\t  error (\"(perhaps the %<offsetof%> macro was used incorrectly)\");\n+\t\t}\n \t      return error_mark_node;\n \t    }\n \n@@ -1920,7 +1980,8 @@ build_class_member_access_expr (tree object, tree member,\n       if (null_object_p && warn_invalid_offsetof\n \t  && CLASSTYPE_NON_POD_P (object_type)\n \t  && !DECL_FIELD_IS_BASE (member)\n-\t  && !skip_evaluation)\n+\t  && !skip_evaluation\n+\t  && (complain & tf_warning))\n \t{\n \t  warning (OPT_Winvalid_offsetof, \n                    \"invalid access to non-static data member %qD \"\n@@ -1950,7 +2011,8 @@ build_class_member_access_expr (tree object, tree member,\n \t  object = build_class_member_access_expr (object,\n \t\t\t\t\t\t   anonymous_union,\n \t\t\t\t\t\t   /*access_path=*/NULL_TREE,\n-\t\t\t\t\t\t   preserve_reference);\n+\t\t\t\t\t\t   preserve_reference,\n+\t\t\t\t\t\t   complain);\n \t}\n \n       /* Compute the type of the field, as described in [expr.ref].  */\n@@ -2011,7 +2073,8 @@ build_class_member_access_expr (tree object, tree member,\n     }\n   else\n     {\n-      error (\"invalid use of %qD\", member);\n+      if (complain & tf_error)\n+\terror (\"invalid use of %qD\", member);\n       return error_mark_node;\n     }\n \n@@ -2117,7 +2180,8 @@ check_template_keyword (tree decl)\n    be a template via the use of the \"A::template B\" syntax.  */\n \n tree\n-finish_class_member_access_expr (tree object, tree name, bool template_p)\n+finish_class_member_access_expr (tree object, tree name, bool template_p,\n+\t\t\t\t tsubst_flags_t complain)\n {\n   tree expr;\n   tree object_type;\n@@ -2165,8 +2229,9 @@ finish_class_member_access_expr (tree object, tree name, bool template_p)\n     return error_mark_node;\n   if (!CLASS_TYPE_P (object_type))\n     {\n-      error (\"request for member %qD in %qE, which is of non-class type %qT\",\n-\t     name, object, object_type);\n+      if (complain & tf_error)\n+\terror (\"request for member %qD in %qE, which is of non-class type %qT\",\n+\t       name, object, object_type);\n       return error_mark_node;\n     }\n \n@@ -2203,8 +2268,9 @@ finish_class_member_access_expr (tree object, tree name, bool template_p)\n \t     name a member of OBJECT_TYPE.  */\n \t  if (TREE_CODE (scope) == NAMESPACE_DECL)\n \t    {\n-\t      error (\"%<%D::%D%> is not a member of %qT\",\n-\t\t     scope, name, object_type);\n+\t      if (complain & tf_error)\n+\t\terror (\"%<%D::%D%> is not a member of %qT\",\n+\t\t       scope, name, object_type);\n \t      return error_mark_node;\n \t    }\n \n@@ -2218,7 +2284,8 @@ finish_class_member_access_expr (tree object, tree name, bool template_p)\n \t    return error_mark_node;\n \t  if (!access_path)\n \t    {\n-\t      error (\"%qT is not a base of %qT\", scope, object_type);\n+\t      if (complain & tf_error)\n+\t\terror (\"%qT is not a base of %qT\", scope, object_type);\n \t      return error_mark_node;\n \t    }\n \t}\n@@ -2237,7 +2304,8 @@ finish_class_member_access_expr (tree object, tree name, bool template_p)\n \t\t\t\t  /*want_type=*/false);\n \t  if (member == NULL_TREE)\n \t    {\n-\t      error (\"%qD has no member named %qE\", object_type, name);\n+\t      if (complain & tf_error)\n+\t\terror (\"%qD has no member named %qE\", object_type, name);\n \t      return error_mark_node;\n \t    }\n \t  if (member == error_mark_node)\n@@ -2252,7 +2320,8 @@ finish_class_member_access_expr (tree object, tree name, bool template_p)\n \t    template = lookup_template_function (template, template_args);\n \t  else\n \t    {\n-\t      error (\"%qD is not a member template function\", name);\n+\t      if (complain & tf_error)\n+\t\terror (\"%qD is not a member template function\", name);\n \t      return error_mark_node;\n \t    }\n \t}\n@@ -2265,7 +2334,8 @@ finish_class_member_access_expr (tree object, tree name, bool template_p)\n     check_template_keyword (member);\n \n   expr = build_class_member_access_expr (object, member, access_path,\n-\t\t\t\t\t /*preserve_reference=*/false);\n+\t\t\t\t\t /*preserve_reference=*/false,\n+\t\t\t\t\t complain);\n   if (processing_template_decl && expr != error_mark_node)\n     {\n       if (BASELINK_P (member))\n@@ -2318,7 +2388,8 @@ build_ptrmemfunc_access_expr (tree ptrmem, tree member_name)\n    Must also handle REFERENCE_TYPEs for C++.  */\n \n tree\n-build_x_indirect_ref (tree expr, const char *errorstring)\n+build_x_indirect_ref (tree expr, const char *errorstring, \n+                      tsubst_flags_t complain)\n {\n   tree orig_expr = expr;\n   tree rval;\n@@ -2331,18 +2402,26 @@ build_x_indirect_ref (tree expr, const char *errorstring)\n     }\n \n   rval = build_new_op (INDIRECT_REF, LOOKUP_NORMAL, expr, NULL_TREE,\n-\t\t       NULL_TREE, /*overloaded_p=*/NULL);\n+\t\t       NULL_TREE, /*overloaded_p=*/NULL, complain);\n   if (!rval)\n-    rval = build_indirect_ref (expr, errorstring);\n+    rval = cp_build_indirect_ref (expr, errorstring, complain);\n \n   if (processing_template_decl && rval != error_mark_node)\n     return build_min_non_dep (INDIRECT_REF, rval, orig_expr);\n   else\n     return rval;\n }\n \n+/* Helper function called from c-common.  */\n tree\n build_indirect_ref (tree ptr, const char *errorstring)\n+{\n+  return cp_build_indirect_ref (ptr, errorstring, tf_warning_or_error);\n+}\n+\n+tree\n+cp_build_indirect_ref (tree ptr, const char *errorstring, \n+                       tsubst_flags_t complain)\n {\n   tree pointer, type;\n \n@@ -2385,7 +2464,8 @@ build_indirect_ref (tree ptr, const char *errorstring)\n \t{\n \t  /* A pointer to incomplete type (other than cv void) can be\n \t     dereferenced [expr.unary.op]/1  */\n-\t  error (\"%qT is not a pointer-to-object type\", type);\n+          if (complain & tf_error)\n+            error (\"%qT is not a pointer-to-object type\", type);\n \t  return error_mark_node;\n \t}\n       else if (TREE_CODE (pointer) == ADDR_EXPR\n@@ -2407,6 +2487,9 @@ build_indirect_ref (tree ptr, const char *errorstring)\n \t  return ref;\n \t}\n     }\n+  else if (!(complain & tf_error))\n+    /* Don't emit any errors; we'll just return ERROR_MARK_NODE later.  */\n+    ;\n   /* `pointer' won't be an error_mark_node if we were given a\n      pointer to member, so it's cool to check for this here.  */\n   else if (TYPE_PTR_TO_MEMBER_P (type))\n@@ -2462,7 +2545,8 @@ build_array_ref (tree array, tree idx)\n       return build_conditional_expr\n \t(TREE_OPERAND (array, 0),\n \t build_array_ref (TREE_OPERAND (array, 1), idx),\n-\t build_array_ref (TREE_OPERAND (array, 2), idx));\n+\t build_array_ref (TREE_OPERAND (array, 2), idx),\n+         tf_warning_or_error);\n \n     default:\n       break;\n@@ -2568,8 +2652,10 @@ build_array_ref (tree array, tree idx)\n \n     warn_array_subscript_with_type_char (idx);\n \n-    return build_indirect_ref (cp_build_binary_op (PLUS_EXPR, ar, ind),\n-\t\t\t       \"array indexing\");\n+    return cp_build_indirect_ref (cp_build_binary_op (PLUS_EXPR, ar, ind,\n+\t\t\t\t\t\t   tf_warning_or_error),\n+                                  \"array indexing\",\n+                                  tf_warning_or_error);\n   }\n }\n \f\n@@ -2627,13 +2713,17 @@ get_member_function_from_ptrfunc (tree *instance_ptrptr, tree function)\n       switch (TARGET_PTRMEMFUNC_VBIT_LOCATION)\n \t{\n \tcase ptrmemfunc_vbit_in_pfn:\n-\t  e1 = cp_build_binary_op (BIT_AND_EXPR, idx, integer_one_node);\n-\t  idx = cp_build_binary_op (MINUS_EXPR, idx, integer_one_node);\n+\t  e1 = cp_build_binary_op (BIT_AND_EXPR, idx, integer_one_node,\n+\t\t\t\t   tf_warning_or_error);\n+\t  idx = cp_build_binary_op (MINUS_EXPR, idx, integer_one_node,\n+\t\t\t\t    tf_warning_or_error);\n \t  break;\n \n \tcase ptrmemfunc_vbit_in_delta:\n-\t  e1 = cp_build_binary_op (BIT_AND_EXPR, delta, integer_one_node);\n-\t  delta = cp_build_binary_op (RSHIFT_EXPR, delta, integer_one_node);\n+\t  e1 = cp_build_binary_op (BIT_AND_EXPR, delta, integer_one_node,\n+\t\t\t\t   tf_warning_or_error);\n+\t  delta = cp_build_binary_op (RSHIFT_EXPR, delta, integer_one_node,\n+\t\t\t\t      tf_warning_or_error);\n \t  break;\n \n \tdefault:\n@@ -2667,23 +2757,24 @@ get_member_function_from_ptrfunc (tree *instance_ptrptr, tree function)\n       /* Next extract the vtable pointer from the object.  */\n       vtbl = build1 (NOP_EXPR, build_pointer_type (vtbl_ptr_type_node),\n \t\t     instance_ptr);\n-      vtbl = build_indirect_ref (vtbl, NULL);\n+      vtbl = cp_build_indirect_ref (vtbl, NULL, tf_warning_or_error);\n \n       /* Finally, extract the function pointer from the vtable.  */\n       e2 = fold_build2 (POINTER_PLUS_EXPR, TREE_TYPE (vtbl), vtbl,\n \t\t\tfold_convert (sizetype, idx));\n-      e2 = build_indirect_ref (e2, NULL);\n+      e2 = cp_build_indirect_ref (e2, NULL, tf_warning_or_error);\n       TREE_CONSTANT (e2) = 1;\n       TREE_INVARIANT (e2) = 1;\n \n       /* When using function descriptors, the address of the\n \t vtable entry is treated as a function pointer.  */\n       if (TARGET_VTABLE_USES_DESCRIPTORS)\n \te2 = build1 (NOP_EXPR, TREE_TYPE (e2),\n-\t\t     build_unary_op (ADDR_EXPR, e2, /*noconvert=*/1));\n+\t\t     cp_build_unary_op (ADDR_EXPR, e2, /*noconvert=*/1,\n+                                     tf_warning_or_error));\n \n       e2 = fold_convert (TREE_TYPE (e3), e2);\n-      e1 = build_conditional_expr (e1, e2, e3);\n+      e1 = build_conditional_expr (e1, e2, e3, tf_warning_or_error);\n \n       /* Make sure this doesn't get evaluated first inside one of the\n \t branches of the COND_EXPR.  */\n@@ -2696,8 +2787,15 @@ get_member_function_from_ptrfunc (tree *instance_ptrptr, tree function)\n   return function;\n }\n \n+/* Used by the C-common bits.  */\n tree\n build_function_call (tree function, tree params)\n+{\n+  return cp_build_function_call (function, params, tf_warning_or_error);\n+}\n+\n+tree\n+cp_build_function_call (tree function, tree params, tsubst_flags_t complain)\n {\n   tree fntype, fndecl;\n   tree name = NULL_TREE;\n@@ -2725,7 +2823,7 @@ build_function_call (tree function, tree params)\n       fndecl = function;\n \n       /* Convert anything with function type to a pointer-to-function.  */\n-      if (pedantic && DECL_MAIN_P (function))\n+      if (pedantic && DECL_MAIN_P (function) && (complain & tf_error))\n \tpedwarn (\"ISO C++ forbids calling %<::main%> from within program\");\n \n       /* Differs from default_conversion by not setting TREE_ADDRESSABLE\n@@ -2751,9 +2849,10 @@ build_function_call (tree function, tree params)\n \n   if (TYPE_PTRMEMFUNC_P (fntype))\n     {\n-      error (\"must use %<.*%> or %<->*%> to call pointer-to-member \"\n-\t     \"function in %<%E (...)%>\",\n-\t     original);\n+      if (complain & tf_error)\n+\terror (\"must use %<.*%> or %<->*%> to call pointer-to-member \"\n+\t       \"function in %<%E (...)%>\",\n+\t       original);\n       return error_mark_node;\n     }\n \n@@ -2765,7 +2864,8 @@ build_function_call (tree function, tree params)\n \t|| is_method\n \t|| TREE_CODE (function) == TEMPLATE_ID_EXPR))\n     {\n-      error (\"%qE cannot be used as a function\", original);\n+      if (complain & tf_error)\n+\terror (\"%qE cannot be used as a function\", original);\n       return error_mark_node;\n     }\n \n@@ -2783,7 +2883,8 @@ build_function_call (tree function, tree params)\n   /* Convert the parameters to the types declared in the\n      function prototype, or apply default promotions.  */\n   nargs = convert_arguments (nargs, argarray, parm_types,\n-\t\t\t     params, fndecl, LOOKUP_NORMAL);\n+\t\t\t     params, fndecl, LOOKUP_NORMAL,\n+                             complain);\n   if (nargs < 0)\n     return error_mark_node;\n \n@@ -2818,7 +2919,8 @@ build_function_call (tree function, tree params)\n \n static int\n convert_arguments (int nargs, tree *argarray,\n-\t\t   tree typelist, tree values, tree fndecl, int flags)\n+\t\t   tree typelist, tree values, tree fndecl, int flags,\n+                   tsubst_flags_t complain)\n {\n   tree typetail, valtail;\n   const char *called_thing = 0;\n@@ -2853,14 +2955,20 @@ convert_arguments (int nargs, tree *argarray,\n \n       if (type == void_type_node)\n \t{\n-\t  if (fndecl)\n-\t    {\n-\t      error (\"too many arguments to %s %q+#D\", called_thing, fndecl);\n-\t      error (\"at this point in file\");\n-\t    }\n-\t  else\n-\t    error (\"too many arguments to function\");\n-\t  return i;\n+          if (complain & tf_error)\n+            {\n+              if (fndecl)\n+                {\n+                  error (\"too many arguments to %s %q+#D\", \n+                         called_thing, fndecl);\n+                  error (\"at this point in file\");\n+                }\n+              else\n+                error (\"too many arguments to function\");\n+              return i;\n+            }\n+          else\n+            return -1;\n \t}\n \n       /* build_c_cast puts on a NOP_EXPR to make the result not an lvalue.\n@@ -2888,18 +2996,21 @@ convert_arguments (int nargs, tree *argarray,\n \n \t  if (!COMPLETE_TYPE_P (complete_type (type)))\n \t    {\n-\t      if (fndecl)\n-\t\terror (\"parameter %P of %qD has incomplete type %qT\",\n-\t\t       i, fndecl, type);\n-\t      else\n-\t\terror (\"parameter %P has incomplete type %qT\", i, type);\n+              if (complain & tf_error)\n+                {\n+                  if (fndecl)\n+                    error (\"parameter %P of %qD has incomplete type %qT\",\n+                           i, fndecl, type);\n+                  else\n+                    error (\"parameter %P has incomplete type %qT\", i, type);\n+                }\n \t      parmval = error_mark_node;\n \t    }\n \t  else\n \t    {\n \t      parmval = convert_for_initialization\n \t\t(NULL_TREE, type, val, flags,\n-\t\t \"argument passing\", fndecl, i);\n+\t\t \"argument passing\", fndecl, i, complain);\n \t      parmval = convert_for_arg_passing (type, parmval);\n \t    }\n \n@@ -2957,13 +3068,17 @@ convert_arguments (int nargs, tree *argarray,\n \t}\n       else\n \t{\n-\t  if (fndecl)\n-\t    {\n-\t      error (\"too few arguments to %s %q+#D\", called_thing, fndecl);\n-\t      error (\"at this point in file\");\n-\t    }\n-\t  else\n-\t    error (\"too few arguments to function\");\n+          if (complain & tf_error)\n+            {\n+              if (fndecl)\n+                {\n+                  error (\"too few arguments to %s %q+#D\", \n+                         called_thing, fndecl);\n+                  error (\"at this point in file\");\n+                }\n+              else\n+                error (\"too few arguments to function\");\n+            }\n \t  return -1;\n \t}\n     }\n@@ -2985,7 +3100,8 @@ convert_arguments (int nargs, tree *argarray,\n \n tree\n build_x_binary_op (enum tree_code code, tree arg1, enum tree_code arg1_code,\n-\t\t   tree arg2, enum tree_code arg2_code, bool *overloaded_p)\n+\t\t   tree arg2, enum tree_code arg2_code, bool *overloaded_p,\n+\t\t   tsubst_flags_t complain)\n {\n   tree orig_arg1;\n   tree orig_arg2;\n@@ -3007,7 +3123,7 @@ build_x_binary_op (enum tree_code code, tree arg1, enum tree_code arg1_code,\n     expr = build_m_component_ref (arg1, arg2);\n   else\n     expr = build_new_op (code, LOOKUP_NORMAL, arg1, arg2, NULL_TREE,\n-\t\t\t overloaded_p);\n+\t\t\t overloaded_p, complain);\n \n   /* Check for cases such as x+y<<z which users are likely to\n      misinterpret.  But don't warn about obj << x + y, since that is a\n@@ -3026,6 +3142,15 @@ build_x_binary_op (enum tree_code code, tree arg1, enum tree_code arg1_code,\n   return expr;\n }\n \n+/* For the c-common bits.  */\n+tree\n+build_binary_op (enum tree_code code, tree op0, tree op1,\n+\t\t int convert_p ATTRIBUTE_UNUSED)\n+{\n+  return cp_build_binary_op(code, op0, op1, tf_warning_or_error);\n+}\n+\n+\n /* Build a binary-operation expression without default conversions.\n    CODE is the kind of expression to build.\n    This function differs from `build' in several ways:\n@@ -3045,8 +3170,8 @@ build_x_binary_op (enum tree_code code, tree arg1, enum tree_code arg1_code,\n    multiple inheritance, and deal with pointer to member functions.  */\n \n tree\n-build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n-\t\t int convert_p ATTRIBUTE_UNUSED)\n+cp_build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n+\t\t    tsubst_flags_t complain)\n {\n   tree op0, op1;\n   enum tree_code code0, code1;\n@@ -3127,8 +3252,9 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n       tree t = instantiate_type (TREE_TYPE (op1), op0, tf_none);\n       if (t != error_mark_node)\n \t{\n-\t  pedwarn (\"assuming cast to type %qT from overloaded function\",\n-\t\t   TREE_TYPE (t));\n+\t  if (complain & tf_error)\n+\t    pedwarn (\"assuming cast to type %qT from overloaded function\",\n+\t\t     TREE_TYPE (t));\n \t  op0 = t;\n \t}\n     }\n@@ -3137,8 +3263,9 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n       tree t = instantiate_type (TREE_TYPE (op0), op1, tf_none);\n       if (t != error_mark_node)\n \t{\n-\t  pedwarn (\"assuming cast to type %qT from overloaded function\",\n-\t\t   TREE_TYPE (t));\n+\t  if (complain & tf_error)\n+\t    pedwarn (\"assuming cast to type %qT from overloaded function\",\n+\t\t     TREE_TYPE (t));\n \t  op1 = t;\n \t}\n     }\n@@ -3288,10 +3415,14 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n \t  if (TREE_CODE (op1) == INTEGER_CST)\n \t    {\n \t      if (tree_int_cst_lt (op1, integer_zero_node))\n-\t\twarning (0, \"right shift count is negative\");\n+\t\t{\n+\t\t  if (complain & tf_warning)\n+\t\t    warning (0, \"right shift count is negative\");\n+\t\t}\n \t      else\n \t\t{\n-\t\t  if (compare_tree_int (op1, TYPE_PRECISION (type0)) >= 0)\n+\t\t  if (compare_tree_int (op1, TYPE_PRECISION (type0)) >= 0\n+\t\t      && (complain & tf_warning))\n \t\t    warning (0, \"right shift count >= width of type\");\n \t\t}\n \t    }\n@@ -3311,9 +3442,15 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n \t  if (TREE_CODE (op1) == INTEGER_CST)\n \t    {\n \t      if (tree_int_cst_lt (op1, integer_zero_node))\n-\t\twarning (0, \"left shift count is negative\");\n+\t\t{\n+\t\t  if (complain & tf_warning)\n+\t\t    warning (0, \"left shift count is negative\");\n+\t\t}\n \t      else if (compare_tree_int (op1, TYPE_PRECISION (type0)) >= 0)\n-\t\twarning (0, \"left shift count >= width of type\");\n+\t\t{\n+\t\t  if (complain & tf_warning)\n+\t\t    warning (0, \"left shift count >= width of type\");\n+\t\t}\n \t    }\n \t  /* Convert the shift-count to an integer, regardless of\n \t     size of value being shifted.  */\n@@ -3332,13 +3469,19 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n \t  if (TREE_CODE (op1) == INTEGER_CST)\n \t    {\n \t      if (tree_int_cst_lt (op1, integer_zero_node))\n-\t\twarning (0, (code == LROTATE_EXPR)\n-                            ? G_(\"left rotate count is negative\")\n-                            : G_(\"right rotate count is negative\"));\n+\t\t{\n+\t\t  if (complain & tf_warning)\n+\t\t    warning (0, (code == LROTATE_EXPR)\n+\t\t\t          ? G_(\"left rotate count is negative\")\n+   \t\t\t          : G_(\"right rotate count is negative\"));\n+\t\t}\n \t      else if (compare_tree_int (op1, TYPE_PRECISION (type0)) >= 0)\n-\t\twarning (0, (code == LROTATE_EXPR) \n-                            ? G_(\"left rotate count >= width of type\")\n-                            : G_(\"right rotate count >= width of type\"));\n+\t\t{\n+\t\t  if (complain & tf_warning)\n+\t\t    warning (0, (code == LROTATE_EXPR) \n+                                  ? G_(\"left rotate count >= width of type\")\n+                                  : G_(\"right rotate count >= width of type\"));\n+\t\t}\n \t    }\n \t  /* Convert the shift-count to an integer, regardless of\n \t     size of value being shifted.  */\n@@ -3349,11 +3492,13 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n \n     case EQ_EXPR:\n     case NE_EXPR:\n-      if (FLOAT_TYPE_P (type0) || FLOAT_TYPE_P (type1))\n+      if ((complain & tf_warning)\n+\t  && (FLOAT_TYPE_P (type0) || FLOAT_TYPE_P (type1)))\n \twarning (OPT_Wfloat_equal,\n \t\t \"comparing floating point with == or != is unsafe\");\n-      if ((TREE_CODE (orig_op0) == STRING_CST && !integer_zerop (op1))\n-\t  || (TREE_CODE (orig_op1) == STRING_CST && !integer_zerop (op0)))\n+      if ((complain & tf_warning)\n+\t  && ((TREE_CODE (orig_op0) == STRING_CST && !integer_zerop (op1))\n+\t      || (TREE_CODE (orig_op1) == STRING_CST && !integer_zerop (op0))))\n \twarning (OPT_Waddress, \"comparison with string literal results in unspecified behaviour\");\n \n       build_type = boolean_type_node;\n@@ -3365,34 +3510,46 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n       else if ((code0 == POINTER_TYPE && code1 == POINTER_TYPE)\n \t       || (TYPE_PTRMEM_P (type0) && TYPE_PTRMEM_P (type1)))\n \tresult_type = composite_pointer_type (type0, type1, op0, op1,\n-\t\t\t\t\t      \"comparison\");\n+\t\t\t\t\t      \"comparison\", complain);\n       else if ((code0 == POINTER_TYPE || TYPE_PTRMEM_P (type0))\n \t       && null_ptr_cst_p (op1))\n \t{\n \t  if (TREE_CODE (op0) == ADDR_EXPR\n \t      && decl_with_nonnull_addr_p (TREE_OPERAND (op0, 0)))\n-\t    warning (OPT_Waddress, \"the address of %qD will never be NULL\",\n-\t\t     TREE_OPERAND (op0, 0));\n+\t    {\n+\t      if (complain & tf_warning)\n+\t\twarning (OPT_Waddress, \"the address of %qD will never be NULL\",\n+\t\t\t TREE_OPERAND (op0, 0));\n+\t    }\n \t  result_type = type0;\n \t}\n       else if ((code1 == POINTER_TYPE || TYPE_PTRMEM_P (type1))\n \t       && null_ptr_cst_p (op0))\n \t{\n \t  if (TREE_CODE (op1) == ADDR_EXPR \n \t      && decl_with_nonnull_addr_p (TREE_OPERAND (op1, 0)))\n-\t    warning (OPT_Waddress, \"the address of %qD will never be NULL\",\n-\t\t     TREE_OPERAND (op1, 0));\n+\t    {\n+\t      if (complain & tf_warning)\n+\t\twarning (OPT_Waddress, \"the address of %qD will never be NULL\",\n+\t\t\t TREE_OPERAND (op1, 0));\n+\t    }\n \t  result_type = type1;\n \t}\n       else if (code0 == POINTER_TYPE && code1 == INTEGER_TYPE)\n \t{\n \t  result_type = type0;\n-\t  pedwarn (\"ISO C++ forbids comparison between pointer and integer\");\n+\t  if (complain & tf_error) \n+            pedwarn (\"ISO C++ forbids comparison between pointer and integer\");\n+          else\n+            return error_mark_node;\n \t}\n       else if (code0 == INTEGER_TYPE && code1 == POINTER_TYPE)\n \t{\n \t  result_type = type1;\n-\t  pedwarn (\"ISO C++ forbids comparison between pointer and integer\");\n+\t  if (complain & tf_error)\n+\t    pedwarn (\"ISO C++ forbids comparison between pointer and integer\");\n+          else\n+            return error_mark_node;\n \t}\n       else if (TYPE_PTRMEMFUNC_P (type0) && null_ptr_cst_p (op1))\n \t{\n@@ -3404,12 +3561,16 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n \t      tree e1 = cp_build_binary_op (EQ_EXPR,\n \t  \t\t\t            pfn0,\t\n \t\t\t\t      \t    fold_convert (TREE_TYPE (pfn0),\n-\t\t\t\t\t\t\t  integer_zero_node));\n+\t\t\t\t\t\t\t  integer_zero_node),\n+\t\t\t\t\t    complain);\n \t      tree e2 = cp_build_binary_op (BIT_AND_EXPR, \n \t\t\t\t\t    delta0,\n-\t\t\t\t            integer_one_node);\n-\t      e2 = cp_build_binary_op (EQ_EXPR, e2, integer_zero_node);\n-\t      op0 = cp_build_binary_op (TRUTH_ANDIF_EXPR, e1, e2);\n+\t\t\t\t            integer_one_node,\n+\t\t\t\t\t    complain);\n+\t      e2 = cp_build_binary_op (EQ_EXPR, e2, integer_zero_node,\n+\t\t\t\t       complain);\n+\t      op0 = cp_build_binary_op (TRUTH_ANDIF_EXPR, e1, e2,\n+\t\t\t\t\tcomplain);\n \t      op1 = cp_convert (TREE_TYPE (op0), integer_one_node); \n \t    }\n      \t  else \n@@ -3420,7 +3581,7 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n \t  result_type = TREE_TYPE (op0);\n \t}\n       else if (TYPE_PTRMEMFUNC_P (type1) && null_ptr_cst_p (op0))\n-\treturn cp_build_binary_op (code, op1, op0);\n+\treturn cp_build_binary_op (code, op1, op0, complain);\n       else if (TYPE_PTRMEMFUNC_P (type0) && TYPE_PTRMEMFUNC_P (type1))\n \t{\n \t  tree type;\n@@ -3434,7 +3595,8 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n \t  tree delta0;\n \t  tree delta1;\n \n-\t  type = composite_pointer_type (type0, type1, op0, op1, \"comparison\");\n+\t  type = composite_pointer_type (type0, type1, op0, op1, \"comparison\",\n+\t\t\t\t\t complain);\n \n \t  if (!same_type_p (TREE_TYPE (op0), type))\n \t    op0 = cp_convert_and_check (type, op0);\n@@ -3469,20 +3631,26 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n \n \t      e1 = cp_build_binary_op (BIT_AND_EXPR,\n \t\t\t\t       delta0, \n-\t\t\t\t       integer_one_node);\n-\t      e1 = cp_build_binary_op (EQ_EXPR, e1, integer_zero_node);\n+\t\t\t\t       integer_one_node,\n+\t\t\t\t       complain);\n+\t      e1 = cp_build_binary_op (EQ_EXPR, e1, integer_zero_node,\n+\t\t\t\t       complain);\n \t      e2 = cp_build_binary_op (BIT_AND_EXPR,\n \t\t\t\t       delta1,\n-\t\t\t\t       integer_one_node);\n-\t      e2 = cp_build_binary_op (EQ_EXPR, e2, integer_zero_node);\n-\t      e1 = cp_build_binary_op (TRUTH_ANDIF_EXPR, e2, e1);\n+\t\t\t\t       integer_one_node,\n+\t\t\t\t       complain);\n+\t      e2 = cp_build_binary_op (EQ_EXPR, e2, integer_zero_node,\n+\t\t\t\t       complain);\n+\t      e1 = cp_build_binary_op (TRUTH_ANDIF_EXPR, e2, e1,\n+\t\t\t\t       complain);\n \t      e2 = cp_build_binary_op (EQ_EXPR,\n \t\t\t\t       pfn0,\n \t\t\t\t       fold_convert (TREE_TYPE (pfn0),\n-\t\t\t\t\t\t     integer_zero_node));\n-\t      e2 = cp_build_binary_op (TRUTH_ANDIF_EXPR, e2, e1);\n-\t      e1 = cp_build_binary_op (EQ_EXPR, delta0, delta1);\n-\t      e1 = cp_build_binary_op (TRUTH_ORIF_EXPR, e1, e2);\n+\t\t\t\t\t\t     integer_zero_node),\n+\t\t\t\t       complain);\n+\t      e2 = cp_build_binary_op (TRUTH_ANDIF_EXPR, e2, e1, complain);\n+\t      e1 = cp_build_binary_op (EQ_EXPR, delta0, delta1, complain);\n+\t      e1 = cp_build_binary_op (TRUTH_ORIF_EXPR, e1, e2, complain);\n \t    }\n \t  else\n \t    {\n@@ -3495,18 +3663,19 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n \t         pointer-to-member is any member with a zero PFN; the\n \t         DELTA field is unspecified.  */\n  \n-    \t      e1 = cp_build_binary_op (EQ_EXPR, delta0, delta1);\n+    \t      e1 = cp_build_binary_op (EQ_EXPR, delta0, delta1, complain);\n \t      e2 = cp_build_binary_op (EQ_EXPR,\n \t\t      \t\t       pfn0,\n \t\t\t   \t       fold_convert (TREE_TYPE (pfn0),\n-\t\t\t\t\t\t   integer_zero_node));\n-\t      e1 = cp_build_binary_op (TRUTH_ORIF_EXPR, e1, e2);\n+\t\t\t\t\t\t     integer_zero_node),\n+\t\t\t\t       complain);\n+\t      e1 = cp_build_binary_op (TRUTH_ORIF_EXPR, e1, e2, complain);\n \t    }\n \t  e2 = build2 (EQ_EXPR, boolean_type_node, pfn0, pfn1);\n-\t  e = cp_build_binary_op (TRUTH_ANDIF_EXPR, e2, e1);\n+\t  e = cp_build_binary_op (TRUTH_ANDIF_EXPR, e2, e1, complain);\n \t  if (code == EQ_EXPR)\n \t    return e;\n-\t  return cp_build_binary_op (EQ_EXPR, e, integer_zero_node);\n+\t  return cp_build_binary_op (EQ_EXPR, e, integer_zero_node, complain);\n \t}\n       else\n \t{\n@@ -3527,7 +3696,7 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n \tshorten = 1;\n       else if (code0 == POINTER_TYPE && code1 == POINTER_TYPE)\n \tresult_type = composite_pointer_type (type0, type1, op0, op1,\n-\t\t\t\t\t      \"comparison\");\n+\t\t\t\t\t      \"comparison\", complain);\n       break;\n \n     case LE_EXPR:\n@@ -3536,15 +3705,18 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n     case GT_EXPR:\n       if (TREE_CODE (orig_op0) == STRING_CST\n \t  || TREE_CODE (orig_op1) == STRING_CST)\n-\twarning (OPT_Waddress, \"comparison with string literal results in unspecified behaviour\");\n+\t{\n+\t  if (complain & tf_warning)\n+\t    warning (OPT_Waddress, \"comparison with string literal results in unspecified behaviour\");\n+\t}\n \n       build_type = boolean_type_node;\n       if ((code0 == INTEGER_TYPE || code0 == REAL_TYPE)\n \t   && (code1 == INTEGER_TYPE || code1 == REAL_TYPE))\n \tshort_compare = 1;\n       else if (code0 == POINTER_TYPE && code1 == POINTER_TYPE)\n \tresult_type = composite_pointer_type (type0, type1, op0, op1,\n-\t\t\t\t\t      \"comparison\");\n+\t\t\t\t\t      \"comparison\", complain);\n       else if (code0 == POINTER_TYPE && TREE_CODE (op1) == INTEGER_CST\n \t       && integer_zerop (op1))\n \tresult_type = type0;\n@@ -3554,12 +3726,18 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n       else if (code0 == POINTER_TYPE && code1 == INTEGER_TYPE)\n \t{\n \t  result_type = type0;\n-\t  pedwarn (\"ISO C++ forbids comparison between pointer and integer\");\n+\t  if (complain & tf_error)\n+\t    pedwarn (\"ISO C++ forbids comparison between pointer and integer\");\n+          else\n+            return error_mark_node;\n \t}\n       else if (code0 == INTEGER_TYPE && code1 == POINTER_TYPE)\n \t{\n \t  result_type = type1;\n-\t  pedwarn (\"ISO C++ forbids comparison between pointer and integer\");\n+\t  if (complain & tf_error)\n+\t    pedwarn (\"ISO C++ forbids comparison between pointer and integer\");\n+          else\n+            return error_mark_node;\n \t}\n       break;\n \n@@ -3573,7 +3751,8 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n       build_type = integer_type_node;\n       if (code0 != REAL_TYPE || code1 != REAL_TYPE)\n \t{\n-\t  error (\"unordered comparison on non-floating point argument\");\n+\t  if (complain & tf_error)\n+\t    error (\"unordered comparison on non-floating point argument\");\n \t  return error_mark_node;\n \t}\n       common = 1;\n@@ -3611,8 +3790,9 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n \n   if (!result_type)\n     {\n-      error (\"invalid operands of types %qT and %qT to binary %qO\",\n-\t     TREE_TYPE (orig_op0), TREE_TYPE (orig_op1), code);\n+      if (complain & tf_error)\n+\terror (\"invalid operands of types %qT and %qT to binary %qO\",\n+\t       TREE_TYPE (orig_op0), TREE_TYPE (orig_op1), code);\n       return error_mark_node;\n     }\n \n@@ -3742,7 +3922,8 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n \t  if (TREE_CODE (TREE_TYPE (orig_op0)) == ENUMERAL_TYPE\n \t      && TREE_CODE (TREE_TYPE (orig_op1)) == ENUMERAL_TYPE\n \t      && TYPE_MAIN_VARIANT (TREE_TYPE (orig_op0))\n-\t\t != TYPE_MAIN_VARIANT (TREE_TYPE (orig_op1)))\n+\t\t != TYPE_MAIN_VARIANT (TREE_TYPE (orig_op1))\n+\t      && (complain & tf_warning))\n \t    {\n \t      warning (OPT_Wsign_compare, \"comparison between types %q#T and %q#T\",\n \t\t       TREE_TYPE (orig_op0), TREE_TYPE (orig_op1));\n@@ -3779,7 +3960,7 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n \t\t\t    && int_fits_type_p (orig_op0, c_common_signed_type\n \t\t\t\t\t\t(result_type)))))\n \t    /* OK */;\n-\t  else\n+\t  else if (complain & tf_warning)\n \t    warning (OPT_Wsign_compare, \n \t\t     \"comparison between signed and unsigned integer expressions\");\n \n@@ -3824,15 +4005,17 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n \t\t      && bits < HOST_BITS_PER_LONG && unsignedp)\n \t\t    {\n \t\t      mask = (~ (HOST_WIDE_INT) 0) << bits;\n-\t\t      if ((mask & constant) != mask)\n+\t\t      if ((mask & constant) != mask\n+\t\t\t  && (complain & tf_warning))\n \t\t\twarning (OPT_Wsign_compare, \"comparison of promoted ~unsigned with constant\");\n \t\t    }\n \t\t}\n \t      else if (unsignedp0 && unsignedp1\n \t\t       && (TYPE_PRECISION (TREE_TYPE (primop0))\n \t\t\t   < TYPE_PRECISION (result_type))\n \t\t       && (TYPE_PRECISION (TREE_TYPE (primop1))\n-\t\t\t   < TYPE_PRECISION (result_type)))\n+\t\t\t   < TYPE_PRECISION (result_type))\n+\t\t       && (complain & tf_warning))\n \t\twarning (OPT_Wsign_compare, \"comparison of promoted ~unsigned with unsigned\");\n \t    }\n \t}\n@@ -3848,7 +4031,8 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n \t   && code != EQ_EXPR && code != NE_EXPR) \n \t  /* Or if one of OP0 or OP1 is neither a pointer nor NULL.  */\n \t  || (!null_ptr_cst_p (orig_op0) && TREE_CODE (TREE_TYPE (op0)) != POINTER_TYPE)\n-\t  || (!null_ptr_cst_p (orig_op1) && TREE_CODE (TREE_TYPE (op1)) != POINTER_TYPE)))\n+\t  || (!null_ptr_cst_p (orig_op1) && TREE_CODE (TREE_TYPE (op1)) != POINTER_TYPE))\n+      && (complain & tf_warning))\n     /* Some sort of arithmetic operation involving NULL was\n        performed.  Note that pointer-difference and pointer-addition\n        have already been handled above, and so we don't end up here in\n@@ -3934,7 +4118,8 @@ pointer_diff (tree op0, tree op1, tree ptrtype)\n \n   op0 = cp_build_binary_op (MINUS_EXPR,\n \t\t\t    cp_convert (restype, op0),\n-\t\t\t    cp_convert (restype, op1));\n+\t\t\t    cp_convert (restype, op1),\n+\t\t\t    tf_warning_or_error);\n \n   /* This generates an error if op1 is a pointer to an incomplete type.  */\n   if (!COMPLETE_TYPE_P (TREE_TYPE (TREE_TYPE (op1))))\n@@ -3955,7 +4140,7 @@ pointer_diff (tree op0, tree op1, tree ptrtype)\n    and XARG is the operand.  */\n \n tree\n-build_x_unary_op (enum tree_code code, tree xarg)\n+build_x_unary_op (enum tree_code code, tree xarg, tsubst_flags_t complain)\n {\n   tree orig_expr = xarg;\n   tree exp;\n@@ -3987,7 +4172,7 @@ build_x_unary_op (enum tree_code code, tree xarg)\n     /* Don't look for a function.  */;\n   else\n     exp = build_new_op (code, LOOKUP_NORMAL, xarg, NULL_TREE, NULL_TREE,\n-\t\t\t/*overloaded_p=*/NULL);\n+\t\t\t/*overloaded_p=*/NULL, complain);\n   if (!exp && code == ADDR_EXPR)\n     {\n       /*  A pointer to member-function can be formed only by saying\n@@ -3998,10 +4183,10 @@ build_x_unary_op (enum tree_code code, tree xarg)\n \t  if (TREE_CODE (xarg) != OFFSET_REF\n \t      || !TYPE_P (TREE_OPERAND (xarg, 0)))\n \t    {\n-\t      error (\"invalid use of %qE to form a pointer-to-member-function\",\n-\t\t     xarg);\n-\t      if (TREE_CODE (xarg) != OFFSET_REF)\n-\t\tinform (\"  a qualified-id is required\");\n+              error (\"invalid use of %qE to form a pointer-to-member-function\",\n+                     xarg);\n+              if (TREE_CODE (xarg) != OFFSET_REF)\n+                inform (\"  a qualified-id is required\");\n \t      return error_mark_node;\n \t    }\n \t  else\n@@ -4028,9 +4213,9 @@ build_x_unary_op (enum tree_code code, tree xarg)\n \t      PTRMEM_OK_P (xarg) = ptrmem;\n \t    }\n \t}\n-      else if (TREE_CODE (xarg) == TARGET_EXPR)\n+      else if (TREE_CODE (xarg) == TARGET_EXPR && (complain & tf_warning))\n \twarning (0, \"taking address of temporary\");\n-      exp = build_unary_op (ADDR_EXPR, xarg, 0);\n+      exp = cp_build_unary_op (ADDR_EXPR, xarg, 0, complain);\n     }\n \n   if (processing_template_decl && exp != error_mark_node)\n@@ -4063,7 +4248,8 @@ condition_conversion (tree expr)\n   tree t;\n   if (processing_template_decl)\n     return expr;\n-  t = perform_implicit_conversion (boolean_type_node, expr);\n+  t = perform_implicit_conversion (boolean_type_node, expr, \n+\t\t\t\t   tf_warning_or_error);\n   t = fold_build_cleanup_point_expr (boolean_type_node, t);\n   return t;\n }\n@@ -4105,7 +4291,8 @@ build_nop (tree type, tree expr)\n    (such as from short to int).  */\n \n tree\n-build_unary_op (enum tree_code code, tree xarg, int noconvert)\n+cp_build_unary_op (enum tree_code code, tree xarg, int noconvert, \n+                   tsubst_flags_t complain)\n {\n   /* No default_conversion here.  It causes trouble for ADDR_EXPR.  */\n   tree arg = xarg;\n@@ -4184,7 +4371,8 @@ build_unary_op (enum tree_code code, tree xarg, int noconvert)\n       break;\n \n     case TRUTH_NOT_EXPR:\n-      arg = perform_implicit_conversion (boolean_type_node, arg);\n+      arg = perform_implicit_conversion (boolean_type_node, arg,\n+\t\t\t\t\t complain);\n       val = invert_truthvalue (arg);\n       if (arg != error_mark_node)\n \treturn val;\n@@ -4234,9 +4422,9 @@ build_unary_op (enum tree_code code, tree xarg, int noconvert)\n \t  tree real, imag;\n \n \t  arg = stabilize_reference (arg);\n-\t  real = build_unary_op (REALPART_EXPR, arg, 1);\n-\t  imag = build_unary_op (IMAGPART_EXPR, arg, 1);\n-\t  real = build_unary_op (code, real, 1);\n+\t  real = cp_build_unary_op (REALPART_EXPR, arg, 1, complain);\n+\t  imag = cp_build_unary_op (IMAGPART_EXPR, arg, 1, complain);\n+\t  real = cp_build_unary_op (code, real, 1, complain);\n \t  if (real == error_mark_node || imag == error_mark_node)\n \t    return error_mark_node;\n \t  return build2 (COMPLEX_EXPR, TREE_TYPE (arg),\n@@ -4264,10 +4452,15 @@ build_unary_op (enum tree_code code, tree xarg, int noconvert)\n       /* Report something read-only.  */\n \n       if (CP_TYPE_CONST_P (TREE_TYPE (arg))\n-\t  || TREE_READONLY (arg))\n-\treadonly_error (arg, ((code == PREINCREMENT_EXPR\n-\t\t\t       || code == POSTINCREMENT_EXPR)\n-\t\t\t      ? \"increment\" : \"decrement\"));\n+\t  || TREE_READONLY (arg)) \n+        {\n+          if (complain & tf_error)\n+            readonly_error (arg, ((code == PREINCREMENT_EXPR\n+                                   || code == POSTINCREMENT_EXPR)\n+                                  ? \"increment\" : \"decrement\"));\n+          else\n+            return error_mark_node;\n+        }\n \n       {\n \ttree inc;\n@@ -4281,9 +4474,14 @@ build_unary_op (enum tree_code code, tree xarg, int noconvert)\n \n \t/* ARM $5.2.5 last annotation says this should be forbidden.  */\n \tif (TREE_CODE (argtype) == ENUMERAL_TYPE)\n-\t  pedwarn ((code == PREINCREMENT_EXPR || code == POSTINCREMENT_EXPR)\n-\t\t   ? G_(\"ISO C++ forbids incrementing an enum\")\n-\t\t   : G_(\"ISO C++ forbids decrementing an enum\"));\n+          {\n+            if (complain & tf_error)\n+              pedwarn ((code == PREINCREMENT_EXPR || code == POSTINCREMENT_EXPR)\n+                       ? G_(\"ISO C++ forbids incrementing an enum\")\n+                       : G_(\"ISO C++ forbids decrementing an enum\"));\n+            else\n+              return error_mark_node;\n+          }\n \n \t/* Compute the increment.  */\n \n@@ -4292,18 +4490,29 @@ build_unary_op (enum tree_code code, tree xarg, int noconvert)\n \t    tree type = complete_type (TREE_TYPE (argtype));\n \n \t    if (!COMPLETE_OR_VOID_TYPE_P (type))\n-\t      error (((code == PREINCREMENT_EXPR\n-\t\t       || code == POSTINCREMENT_EXPR))\n-\t\t     ? G_(\"cannot increment a pointer to incomplete type %qT\")\n-\t\t     : G_(\"cannot decrement a pointer to incomplete type %qT\"),\n-                      TREE_TYPE (argtype));\n+              {\n+                if (complain & tf_error)\n+                  error (((code == PREINCREMENT_EXPR\n+                           || code == POSTINCREMENT_EXPR))\n+                         ? G_(\"cannot increment a pointer to incomplete type %qT\")\n+                         : G_(\"cannot decrement a pointer to incomplete type %qT\"),\n+                         TREE_TYPE (argtype));\n+                else\n+                  return error_mark_node;\n+              }\n \t    else if ((pedantic || warn_pointer_arith)\n-\t\t     && !TYPE_PTROB_P (argtype))\n-\t      pedwarn ((code == PREINCREMENT_EXPR\n-\t\t\t || code == POSTINCREMENT_EXPR)\n-\t\t       ? G_(\"ISO C++ forbids incrementing a pointer of type %qT\")\n-\t\t       : G_(\"ISO C++ forbids decrementing a pointer of type %qT\"),\n-                        argtype);\n+\t\t     && !TYPE_PTROB_P (argtype)) \n+              {\n+                if (complain & tf_error)\n+                  pedwarn ((code == PREINCREMENT_EXPR\n+                            || code == POSTINCREMENT_EXPR)\n+                           ? G_(\"ISO C++ forbids incrementing a pointer of type %qT\")\n+                           : G_(\"ISO C++ forbids decrementing a pointer of type %qT\"),\n+                           argtype);\n+                else\n+                  return error_mark_node;\n+              }\n+\n \t    inc = cxx_sizeof_nowarn (TREE_TYPE (argtype));\n \t  }\n \telse\n@@ -4314,16 +4523,18 @@ build_unary_op (enum tree_code code, tree xarg, int noconvert)\n \t/* Complain about anything else that is not a true lvalue.  */\n \tif (!lvalue_or_else (arg, ((code == PREINCREMENT_EXPR\n \t\t\t\t    || code == POSTINCREMENT_EXPR)\n-\t\t\t\t   ? lv_increment : lv_decrement)))\n+\t\t\t\t   ? lv_increment : lv_decrement),\n+                             complain))\n \t  return error_mark_node;\n \n \t/* Forbid using -- on `bool'.  */\n \tif (same_type_p (declared_type, boolean_type_node))\n \t  {\n \t    if (code == POSTDECREMENT_EXPR || code == PREDECREMENT_EXPR)\n \t      {\n-\t\terror (\"invalid use of Boolean expression as operand \"\n-\t\t       \"to %<operator--%>\");\n+                if (complain & tf_error)\n+                  error (\"invalid use of Boolean expression as operand \"\n+                         \"to %<operator--%>\");\n \t\treturn error_mark_node;\n \t      }\n \t    val = boolean_increment (code, arg);\n@@ -4351,8 +4562,13 @@ build_unary_op (enum tree_code code, tree xarg, int noconvert)\n \t  return arg;\n \t}\n       else if (pedantic && DECL_MAIN_P (arg))\n-\t/* ARM $3.4 */\n-\tpedwarn (\"ISO C++ forbids taking address of function %<::main%>\");\n+        {\n+          /* ARM $3.4 */\n+          if (complain & tf_error)\n+            pedwarn (\"ISO C++ forbids taking address of function %<::main%>\");\n+          else\n+            return error_mark_node;\n+        }\n \n       /* Let &* cancel out to simplify resulting code.  */\n       if (TREE_CODE (arg) == INDIRECT_REF)\n@@ -4405,13 +4621,15 @@ build_unary_op (enum tree_code code, tree xarg, int noconvert)\n \t  if (! flag_ms_extensions)\n \t    {\n \t      tree name = DECL_NAME (fn);\n-\t      if (current_class_type\n-\t\t  && TREE_OPERAND (arg, 0) == current_class_ref)\n-\t\t/* An expression like &memfn.  */\n-\t\tpedwarn (\"ISO C++ forbids taking the address of an unqualified\"\n-\t\t\t \" or parenthesized non-static member function to form\"\n-\t\t\t \" a pointer to member function.  Say %<&%T::%D%>\",\n-\t\t\t base, name);\n+              if (!(complain & tf_error))\n+                return error_mark_node;\n+\t      else if (current_class_type\n+                       && TREE_OPERAND (arg, 0) == current_class_ref)\n+                  /* An expression like &memfn.  */\n+                pedwarn (\"ISO C++ forbids taking the address of an unqualified\"\n+                         \" or parenthesized non-static member function to form\"\n+                         \" a pointer to member function.  Say %<&%T::%D%>\",\n+                         base, name);\n \t      else\n \t\tpedwarn (\"ISO C++ forbids taking the address of a bound member\"\n \t\t\t \" function to form a pointer to member function.\"\n@@ -4437,8 +4655,16 @@ build_unary_op (enum tree_code code, tree xarg, int noconvert)\n \tcase CONVERT_EXPR:\n \tcase FLOAT_EXPR:\n \tcase FIX_TRUNC_EXPR:\n-\t  if (! lvalue_p (arg) && pedantic)\n-\t    pedwarn (\"ISO C++ forbids taking the address of a cast to a non-lvalue expression\");\n+          /* Even if we're not being pedantic, we cannot allow this\n+             extension when we're instantiating in a SFINAE\n+             context.  */\n+\t  if (! lvalue_p (arg) && (pedantic || complain == tf_none))\n+            {\n+              if (complain & tf_error)\n+                pedwarn (\"ISO C++ forbids taking the address of a cast to a non-lvalue expression\");\n+              else\n+                return error_mark_node;\n+            }\n \t  break;\n \n \tcase BASELINK:\n@@ -4457,12 +4683,13 @@ build_unary_op (enum tree_code code, tree xarg, int noconvert)\n \t    tree t;\n \n \t    if (!PTRMEM_OK_P (arg))\n-\t      return build_unary_op (code, arg, 0);\n+\t      return cp_build_unary_op (code, arg, 0, complain);\n \n \t    t = TREE_OPERAND (arg, 1);\n \t    if (TREE_CODE (TREE_TYPE (t)) == REFERENCE_TYPE)\n \t      {\n-\t\terror (\"cannot create pointer to reference member %qD\", t);\n+                if (complain & tf_error)\n+                  error (\"cannot create pointer to reference member %qD\", t);\n \t\treturn error_mark_node;\n \t      }\n \n@@ -4481,7 +4708,7 @@ build_unary_op (enum tree_code code, tree xarg, int noconvert)\n       if (TREE_CODE (argtype) != FUNCTION_TYPE\n \t  && TREE_CODE (argtype) != METHOD_TYPE\n \t  && TREE_CODE (arg) != OFFSET_REF\n-\t  && !lvalue_or_else (arg, lv_addressof))\n+\t  && !lvalue_or_else (arg, lv_addressof, complain))\n \treturn error_mark_node;\n \n       if (argtype != error_mark_node)\n@@ -4520,8 +4747,9 @@ build_unary_op (enum tree_code code, tree xarg, int noconvert)\n \t}\n       else if (DECL_C_BIT_FIELD (TREE_OPERAND (arg, 1)))\n \t{\n-\t  error (\"attempt to take address of bit-field structure member %qD\",\n-\t\t TREE_OPERAND (arg, 1));\n+          if (complain & tf_error)\n+            error (\"attempt to take address of bit-field structure member %qD\",\n+                   TREE_OPERAND (arg, 1));\n \t  return error_mark_node;\n \t}\n       else\n@@ -4554,10 +4782,18 @@ build_unary_op (enum tree_code code, tree xarg, int noconvert)\n       return fold_if_not_in_template (build1 (code, argtype, arg));\n     }\n \n-  error (\"%s\", errstring);\n+  if (complain & tf_error)\n+    error (\"%s\", errstring);\n   return error_mark_node;\n }\n \n+/* Hook for the c-common bits that build a unary op.  */\n+tree\n+build_unary_op (enum tree_code code, tree xarg, int noconvert)\n+{\n+  return cp_build_unary_op (code, xarg, noconvert, tf_warning_or_error);\n+}\n+\n /* Apply unary lvalue-demanding operator CODE to the expression ARG\n    for certain kinds of expressions which are not really lvalues\n    but which we can accept as lvalues.\n@@ -4577,15 +4813,16 @@ unary_complex_lvalue (enum tree_code code, tree arg)\n   /* Handle (a, b) used as an \"lvalue\".  */\n   if (TREE_CODE (arg) == COMPOUND_EXPR)\n     {\n-      tree real_result = build_unary_op (code, TREE_OPERAND (arg, 1), 0);\n+      tree real_result = cp_build_unary_op (code, TREE_OPERAND (arg, 1), 0,\n+                                            tf_warning_or_error);\n       return build2 (COMPOUND_EXPR, TREE_TYPE (real_result),\n \t\t     TREE_OPERAND (arg, 0), real_result);\n     }\n \n   /* Handle (a ? b : c) used as an \"lvalue\".  */\n   if (TREE_CODE (arg) == COND_EXPR\n       || TREE_CODE (arg) == MIN_EXPR || TREE_CODE (arg) == MAX_EXPR)\n-    return rationalize_conditional_expr (code, arg);\n+    return rationalize_conditional_expr (code, arg, tf_warning_or_error);\n \n   /* Handle (a = b), (++a), and (--a) used as an \"lvalue\".  */\n   if (TREE_CODE (arg) == MODIFY_EXPR\n@@ -4610,7 +4847,8 @@ unary_complex_lvalue (enum tree_code code, tree arg)\n   if (TREE_CODE (arg) == MODIFY_EXPR\n       || TREE_CODE (arg) == INIT_EXPR)\n     {\n-      tree real_result = build_unary_op (code, TREE_OPERAND (arg, 0), 0);\n+      tree real_result = cp_build_unary_op (code, TREE_OPERAND (arg, 0), 0,\n+                                            tf_warning_or_error);\n       arg = build2 (COMPOUND_EXPR, TREE_TYPE (real_result),\n \t\t    arg, real_result);\n       TREE_NO_WARNING (arg) = 1;\n@@ -4727,7 +4965,8 @@ cxx_mark_addressable (tree exp)\n /* Build and return a conditional expression IFEXP ? OP1 : OP2.  */\n \n tree\n-build_x_conditional_expr (tree ifexp, tree op1, tree op2)\n+build_x_conditional_expr (tree ifexp, tree op1, tree op2, \n+                          tsubst_flags_t complain)\n {\n   tree orig_ifexp = ifexp;\n   tree orig_op1 = op1;\n@@ -4750,7 +4989,7 @@ build_x_conditional_expr (tree ifexp, tree op1, tree op2)\n       op2 = build_non_dependent_expr (op2);\n     }\n \n-  expr = build_conditional_expr (ifexp, op1, op2);\n+  expr = build_conditional_expr (ifexp, op1, op2, complain);\n   if (processing_template_decl && expr != error_mark_node)\n     return build_min_non_dep (COND_EXPR, expr,\n \t\t\t      orig_ifexp, orig_op1, orig_op2);\n@@ -4770,7 +5009,8 @@ tree build_x_compound_expr_from_list (tree list, const char *msg)\n \tpedwarn (\"%s expression list treated as compound expression\", msg);\n \n       for (list = TREE_CHAIN (list); list; list = TREE_CHAIN (list))\n-\texpr = build_x_compound_expr (expr, TREE_VALUE (list));\n+\texpr = build_x_compound_expr (expr, TREE_VALUE (list), \n+                                      tf_warning_or_error);\n     }\n \n   return expr;\n@@ -4779,7 +5019,7 @@ tree build_x_compound_expr_from_list (tree list, const char *msg)\n /* Handle overloading of the ',' operator when needed.  */\n \n tree\n-build_x_compound_expr (tree op1, tree op2)\n+build_x_compound_expr (tree op1, tree op2, tsubst_flags_t complain)\n {\n   tree result;\n   tree orig_op1 = op1;\n@@ -4795,9 +5035,9 @@ build_x_compound_expr (tree op1, tree op2)\n     }\n \n   result = build_new_op (COMPOUND_EXPR, LOOKUP_NORMAL, op1, op2, NULL_TREE,\n-\t\t\t /*overloaded_p=*/NULL);\n+\t\t\t /*overloaded_p=*/NULL, complain);\n   if (!result)\n-    result = build_compound_expr (op1, op2);\n+    result = build_compound_expr (op1, op2, complain);\n \n   if (processing_template_decl && result != error_mark_node)\n     return build_min_non_dep (COMPOUND_EXPR, result, orig_op1, orig_op2);\n@@ -4808,9 +5048,9 @@ build_x_compound_expr (tree op1, tree op2)\n /* Build a compound expression.  */\n \n tree\n-build_compound_expr (tree lhs, tree rhs)\n+build_compound_expr (tree lhs, tree rhs, tsubst_flags_t complain)\n {\n-  lhs = convert_to_void (lhs, \"left-hand operand of comma\");\n+  lhs = convert_to_void (lhs, \"left-hand operand of comma\", complain);\n \n   if (lhs == error_mark_node || rhs == error_mark_node)\n     return error_mark_node;\n@@ -4893,9 +5133,11 @@ convert_ptrmem (tree type, tree expr, bool allow_inverse_p,\n \n \t  cond = cp_build_binary_op (EQ_EXPR,\n \t\t\t\t     expr,\n-\t\t\t\t     build_int_cst (TREE_TYPE (expr), -1));\n+\t\t\t\t     build_int_cst (TREE_TYPE (expr), -1),\n+\t\t\t\t     tf_warning_or_error);\n \t  op1 = build_nop (ptrdiff_type_node, expr);\n-\t  op2 = cp_build_binary_op (PLUS_EXPR, op1, delta);\n+\t  op2 = cp_build_binary_op (PLUS_EXPR, op1, delta,\n+\t\t\t\t    tf_warning_or_error);\n \n \t  expr = fold_build3 (COND_EXPR, ptrdiff_type_node, cond, op1, op2);\n \t\t\t \n@@ -4944,7 +5186,7 @@ ignore_overflows (tree expr, tree orig)\n \n static tree\n build_static_cast_1 (tree type, tree expr, bool c_cast_p,\n-\t\t     bool *valid_p)\n+\t\t     bool *valid_p, tsubst_flags_t complain)\n {\n   tree intype;\n   tree result;\n@@ -5018,7 +5260,7 @@ build_static_cast_1 (tree type, tree expr, bool c_cast_p,\n      t(e);\" is well-formed, for some invented temporary variable\n      t.  */\n   result = perform_direct_initialization_if_possible (type, expr,\n-\t\t\t\t\t\t      c_cast_p);\n+\t\t\t\t\t\t      c_cast_p, complain);\n   if (result)\n     {\n       result = convert_from_reference (result);\n@@ -5039,7 +5281,7 @@ build_static_cast_1 (tree type, tree expr, bool c_cast_p,\n \n      Any expression can be explicitly converted to type cv void.  */\n   if (TREE_CODE (type) == VOID_TYPE)\n-    return convert_to_void (expr, /*implicit=*/NULL);\n+    return convert_to_void (expr, /*implicit=*/NULL, complain);\n \n   /* [expr.static.cast]\n \n@@ -5145,7 +5387,7 @@ build_static_cast_1 (tree type, tree expr, bool c_cast_p,\n /* Return an expression representing static_cast<TYPE>(EXPR).  */\n \n tree\n-build_static_cast (tree type, tree expr)\n+build_static_cast (tree type, tree expr, tsubst_flags_t complain)\n {\n   tree result;\n   bool valid_p;\n@@ -5168,12 +5410,14 @@ build_static_cast (tree type, tree expr)\n       && TREE_TYPE (expr) == TREE_TYPE (TREE_OPERAND (expr, 0)))\n     expr = TREE_OPERAND (expr, 0);\n \n-  result = build_static_cast_1 (type, expr, /*c_cast_p=*/false, &valid_p);\n+  result = build_static_cast_1 (type, expr, /*c_cast_p=*/false, &valid_p,\n+                                complain);\n   if (valid_p)\n     return result;\n \n-  error (\"invalid static_cast from type %qT to type %qT\",\n-\t TREE_TYPE (expr), type);\n+  if (complain & tf_error)\n+    error (\"invalid static_cast from type %qT to type %qT\",\n+           TREE_TYPE (expr), type);\n   return error_mark_node;\n }\n \n@@ -5217,7 +5461,7 @@ convert_member_func_to_ptr (tree type, tree expr)\n \n static tree\n build_reinterpret_cast_1 (tree type, tree expr, bool c_cast_p,\n-\t\t\t  bool *valid_p)\n+\t\t\t  bool *valid_p, tsubst_flags_t complain)\n {\n   tree intype;\n \n@@ -5242,28 +5486,30 @@ build_reinterpret_cast_1 (tree type, tree expr, bool c_cast_p,\n     {\n       if (! real_lvalue_p (expr))\n \t{\n-\t  error (\"invalid cast of an rvalue expression of type \"\n-\t\t \"%qT to type %qT\",\n-\t\t intype, type);\n+          if (complain & tf_error)\n+            error (\"invalid cast of an rvalue expression of type \"\n+                   \"%qT to type %qT\",\n+                   intype, type);\n \t  return error_mark_node;\n \t}\n \n       /* Warn about a reinterpret_cast from \"A*\" to \"B&\" if \"A\" and\n \t \"B\" are related class types; the reinterpret_cast does not\n \t adjust the pointer.  */\n       if (TYPE_PTR_P (intype)\n+          && (complain & tf_warning)\n \t  && (comptypes (TREE_TYPE (intype), TREE_TYPE (type),\n \t\t\t COMPARE_BASE | COMPARE_DERIVED)))\n \twarning (0, \"casting %qT to %qT does not dereference pointer\",\n \t\t intype, type);\n \n-      expr = build_unary_op (ADDR_EXPR, expr, 0);\n+      expr = cp_build_unary_op (ADDR_EXPR, expr, 0, complain);\n       if (expr != error_mark_node)\n \texpr = build_reinterpret_cast_1\n \t  (build_pointer_type (TREE_TYPE (type)), expr, c_cast_p,\n-\t   valid_p);\n+\t   valid_p, complain);\n       if (expr != error_mark_node)\n-\texpr = build_indirect_ref (expr, 0);\n+\texpr = cp_build_indirect_ref (expr, 0, complain);\n       return expr;\n     }\n \n@@ -5301,8 +5547,13 @@ build_reinterpret_cast_1 (tree type, tree expr, bool c_cast_p,\n   if (CP_INTEGRAL_TYPE_P (type) && TYPE_PTR_P (intype))\n     {\n       if (TYPE_PRECISION (type) < TYPE_PRECISION (intype))\n-\tpedwarn (\"cast from %qT to %qT loses precision\",\n-\t\t intype, type);\n+        {\n+          if (complain & tf_error)\n+            pedwarn (\"cast from %qT to %qT loses precision\",\n+                     intype, type);\n+          else\n+            return error_mark_node;\n+        }\n     }\n   /* [expr.reinterpret.cast]\n      A value of integral or enumeration type can be explicitly\n@@ -5322,6 +5573,7 @@ build_reinterpret_cast_1 (tree type, tree expr, bool c_cast_p,\n \tcheck_for_casting_away_constness (intype, type, REINTERPRET_CAST_EXPR);\n       /* Warn about possible alignment problems.  */\n       if (STRICT_ALIGNMENT && warn_cast_align\n+          && (complain & tf_warning)\n \t  && !VOID_TYPE_P (type)\n \t  && TREE_CODE (TREE_TYPE (intype)) != FUNCTION_TYPE\n \t  && COMPLETE_TYPE_P (TREE_TYPE (type))\n@@ -5341,7 +5593,7 @@ build_reinterpret_cast_1 (tree type, tree expr, bool c_cast_p,\n   else if ((TYPE_PTRFN_P (type) && TYPE_PTROBV_P (intype))\n \t   || (TYPE_PTRFN_P (intype) && TYPE_PTROBV_P (type)))\n     {\n-      if (pedantic)\n+      if (pedantic && (complain & tf_warning))\n \t/* Only issue a warning, as we have always supported this\n \t   where possible, and it is necessary in some cases.  DR 195\n \t   addresses this issue, but as of 2004/10/26 is still in\n@@ -5357,15 +5609,16 @@ build_reinterpret_cast_1 (tree type, tree expr, bool c_cast_p,\n     {\n       if (valid_p)\n \t*valid_p = false;\n-      error (\"invalid cast from type %qT to type %qT\", intype, type);\n+      if (complain & tf_error)\n+        error (\"invalid cast from type %qT to type %qT\", intype, type);\n       return error_mark_node;\n     }\n \n   return cp_convert (type, expr);\n }\n \n tree\n-build_reinterpret_cast (tree type, tree expr)\n+build_reinterpret_cast (tree type, tree expr, tsubst_flags_t complain)\n {\n   if (type == error_mark_node || expr == error_mark_node)\n     return error_mark_node;\n@@ -5382,7 +5635,7 @@ build_reinterpret_cast (tree type, tree expr)\n     }\n \n   return build_reinterpret_cast_1 (type, expr, /*c_cast_p=*/false,\n-\t\t\t\t   /*valid_p=*/NULL);\n+\t\t\t\t   /*valid_p=*/NULL, complain);\n }\n \n /* Perform a const_cast from EXPR to TYPE.  If the cast is valid,\n@@ -5477,7 +5730,8 @@ build_const_cast_1 (tree dst_type, tree expr, bool complain,\n \t}\n       if (reference_type)\n \t{\n-\t  expr = build_unary_op (ADDR_EXPR, expr, 0);\n+\t  expr = cp_build_unary_op (ADDR_EXPR, expr, 0, \n+                                    complain? tf_warning_or_error : tf_none);\n \t  expr = build_nop (reference_type, expr);\n \t  return convert_from_reference (expr);\n \t}\n@@ -5501,7 +5755,7 @@ build_const_cast_1 (tree dst_type, tree expr, bool complain,\n }\n \n tree\n-build_const_cast (tree type, tree expr)\n+build_const_cast (tree type, tree expr, tsubst_flags_t complain)\n {\n   if (type == error_mark_node || error_operand_p (expr))\n     return error_mark_node;\n@@ -5517,15 +5771,15 @@ build_const_cast (tree type, tree expr)\n       return convert_from_reference (t);\n     }\n \n-  return build_const_cast_1 (type, expr, /*complain=*/true,\n+  return build_const_cast_1 (type, expr, complain & tf_error,\n \t\t\t     /*valid_p=*/NULL);\n }\n \n /* Build an expression representing an explicit C-style cast to type\n    TYPE of expression EXPR.  */\n \n tree\n-build_c_cast (tree type, tree expr)\n+build_c_cast (tree type, tree expr, tsubst_flags_t complain)\n {\n   tree value = expr;\n   tree result;\n@@ -5563,20 +5817,25 @@ build_c_cast (tree type, tree expr)\n \t NIHCL uses it. It is not valid ISO C++ however.  */\n       if (TREE_CODE (TREE_TYPE (expr)) == POINTER_TYPE)\n \t{\n-\t  pedwarn (\"ISO C++ forbids casting to an array type %qT\", type);\n+          if (complain & tf_error)\n+            pedwarn (\"ISO C++ forbids casting to an array type %qT\", type);\n+          else\n+            return error_mark_node;\n \t  type = build_pointer_type (TREE_TYPE (type));\n \t}\n       else\n \t{\n-\t  error (\"ISO C++ forbids casting to an array type %qT\", type);\n+          if (complain & tf_error)\n+            error (\"ISO C++ forbids casting to an array type %qT\", type);\n \t  return error_mark_node;\n \t}\n     }\n \n   if (TREE_CODE (type) == FUNCTION_TYPE\n       || TREE_CODE (type) == METHOD_TYPE)\n     {\n-      error (\"invalid cast to function type %qT\", type);\n+      if (complain & tf_error)\n+        error (\"invalid cast to function type %qT\", type);\n       return error_mark_node;\n     }\n \n@@ -5588,11 +5847,11 @@ build_c_cast (tree type, tree expr)\n \n   /* Or a static cast.  */\n   result = build_static_cast_1 (type, value, /*c_cast_p=*/true,\n-\t\t\t\t&valid_p);\n+\t\t\t\t&valid_p, complain);\n   /* Or a reinterpret_cast.  */\n   if (!valid_p)\n     result = build_reinterpret_cast_1 (type, value, /*c_cast_p=*/true,\n-\t\t\t\t       &valid_p);\n+\t\t\t\t       &valid_p, complain);\n   /* The static_cast or reinterpret_cast may be followed by a\n      const_cast.  */\n   if (valid_p\n@@ -5624,6 +5883,13 @@ build_c_cast (tree type, tree expr)\n   return error_mark_node;\n }\n \f\n+/* For use from the C common bits.  */\n+tree\n+build_modify_expr (tree lhs, enum tree_code modifycode, tree rhs)\n+{\n+  return cp_build_modify_expr (lhs, modifycode, rhs, tf_warning_or_error);\n+}\n+\n /* Build an assignment expression of lvalue LHS from value RHS.\n    MODIFYCODE is the code for a binary operator that we use\n    to combine the old value of LHS with RHS to get the new value.\n@@ -5632,7 +5898,8 @@ build_c_cast (tree type, tree expr)\n    C++: If MODIFYCODE is INIT_EXPR, then leave references unbashed.  */\n \n tree\n-build_modify_expr (tree lhs, enum tree_code modifycode, tree rhs)\n+cp_build_modify_expr (tree lhs, enum tree_code modifycode, tree rhs,\n+\t\t      tsubst_flags_t complain)\n {\n   tree result;\n   tree newrhs = rhs;\n@@ -5657,13 +5924,13 @@ build_modify_expr (tree lhs, enum tree_code modifycode, tree rhs)\n \t\t      TREE_OPERAND (lhs, 1));\n       return build2 (COMPOUND_EXPR, lhstype,\n \t\t     lhs,\n-\t\t     build_modify_expr (TREE_OPERAND (lhs, 0),\n-\t\t\t\t\tmodifycode, rhs));\n+\t\t     cp_build_modify_expr (TREE_OPERAND (lhs, 0),\n+\t\t\t\t\t   modifycode, rhs, complain));\n \n       /* Handle (a, b) used as an \"lvalue\".  */\n     case COMPOUND_EXPR:\n-      newrhs = build_modify_expr (TREE_OPERAND (lhs, 1),\n-\t\t\t\t  modifycode, rhs);\n+      newrhs = cp_build_modify_expr (TREE_OPERAND (lhs, 1),\n+\t\t\t\t     modifycode, rhs, complain);\n       if (newrhs == error_mark_node)\n \treturn error_mark_node;\n       return build2 (COMPOUND_EXPR, lhstype,\n@@ -5674,7 +5941,8 @@ build_modify_expr (tree lhs, enum tree_code modifycode, tree rhs)\n \tlhs = build2 (TREE_CODE (lhs), TREE_TYPE (lhs),\n \t\t      stabilize_reference (TREE_OPERAND (lhs, 0)),\n \t\t      TREE_OPERAND (lhs, 1));\n-      newrhs = build_modify_expr (TREE_OPERAND (lhs, 0), modifycode, rhs);\n+      newrhs = cp_build_modify_expr (TREE_OPERAND (lhs, 0), modifycode, rhs,\n+\t\t\t\t     complain);\n       if (newrhs == error_mark_node)\n \treturn error_mark_node;\n       return build2 (COMPOUND_EXPR, lhstype, lhs, newrhs);\n@@ -5683,7 +5951,7 @@ build_modify_expr (tree lhs, enum tree_code modifycode, tree rhs)\n     case MAX_EXPR:\n       /* MIN_EXPR and MAX_EXPR are currently only permitted as lvalues,\n \t when neither operand has side-effects.  */\n-      if (!lvalue_or_else (lhs, lv_assign))\n+      if (!lvalue_or_else (lhs, lv_assign, complain))\n \treturn error_mark_node;\n \n       gcc_assert (!TREE_SIDE_EFFECTS (TREE_OPERAND (lhs, 0))\n@@ -5709,23 +5977,25 @@ build_modify_expr (tree lhs, enum tree_code modifycode, tree rhs)\n \n \tif (VOID_TYPE_P (TREE_TYPE (rhs)))\n \t  {\n-\t    error (\"void value not ignored as it ought to be\");\n+\t    if (complain & tf_error)\n+\t      error (\"void value not ignored as it ought to be\");\n \t    return error_mark_node;\n \t  }\n \n \trhs = stabilize_expr (rhs, &preeval);\n \n \t/* Check this here to avoid odd errors when trying to convert\n \t   a throw to the type of the COND_EXPR.  */\n-\tif (!lvalue_or_else (lhs, lv_assign))\n+\tif (!lvalue_or_else (lhs, lv_assign, complain))\n \t  return error_mark_node;\n \n \tcond = build_conditional_expr\n \t  (TREE_OPERAND (lhs, 0),\n-\t   build_modify_expr (TREE_OPERAND (lhs, 1),\n-\t\t\t      modifycode, rhs),\n-\t   build_modify_expr (TREE_OPERAND (lhs, 2),\n-\t\t\t      modifycode, rhs));\n+\t   cp_build_modify_expr (TREE_OPERAND (lhs, 1),\n+\t\t\t\t modifycode, rhs, complain),\n+\t   cp_build_modify_expr (TREE_OPERAND (lhs, 2),\n+\t\t\t\t modifycode, rhs, complain),\n+           complain);\n \n \tif (cond == error_mark_node)\n \t  return cond;\n@@ -5757,7 +6027,8 @@ build_modify_expr (tree lhs, enum tree_code modifycode, tree rhs)\n \t{\n \t  result = build_special_member_call (lhs, complete_ctor_identifier,\n \t\t\t\t\t      build_tree_list (NULL_TREE, rhs),\n-\t\t\t\t\t      lhstype, LOOKUP_NORMAL);\n+\t\t\t\t\t      lhstype, LOOKUP_NORMAL,\n+                                              complain);\n \t  if (result == NULL_TREE)\n \t    return error_mark_node;\n \t  return result;\n@@ -5778,7 +6049,8 @@ build_modify_expr (tree lhs, enum tree_code modifycode, tree rhs)\n \t    {\n \t      result = build_new_op (MODIFY_EXPR, LOOKUP_NORMAL,\n \t\t\t\t     lhs, rhs, make_node (NOP_EXPR),\n-\t\t\t\t     /*overloaded_p=*/NULL);\n+\t\t\t\t     /*overloaded_p=*/NULL, \n+\t\t\t\t     complain);\n \t      if (result == NULL_TREE)\n \t\treturn error_mark_node;\n \t      return result;\n@@ -5795,11 +6067,13 @@ build_modify_expr (tree lhs, enum tree_code modifycode, tree rhs)\n \t\t\t|| MAYBE_CLASS_TYPE_P (lhstype)));\n \n \t  lhs = stabilize_reference (lhs);\n-\t  newrhs = cp_build_binary_op (modifycode, lhs, rhs);\n+\t  newrhs = cp_build_binary_op (modifycode, lhs, rhs,\n+\t\t\t\t       complain);\n \t  if (newrhs == error_mark_node)\n \t    {\n-\t      error (\"  in evaluation of %<%Q(%#T, %#T)%>\", modifycode,\n-\t\t     TREE_TYPE (lhs), TREE_TYPE (rhs));\n+\t      if (complain & tf_error)\n+\t\terror (\"  in evaluation of %<%Q(%#T, %#T)%>\", modifycode,\n+\t\t       TREE_TYPE (lhs), TREE_TYPE (rhs));\n \t      return error_mark_node;\n \t    }\n \n@@ -5811,7 +6085,7 @@ build_modify_expr (tree lhs, enum tree_code modifycode, tree rhs)\n     }\n \n   /* The left-hand side must be an lvalue.  */\n-  if (!lvalue_or_else (lhs, lv_assign))\n+  if (!lvalue_or_else (lhs, lv_assign, complain))\n     return error_mark_node;\n \n   /* Warn about modifying something that is `const'.  Don't warn if\n@@ -5826,7 +6100,12 @@ build_modify_expr (tree lhs, enum tree_code modifycode, tree rhs)\n \t     effectively const.  */\n \t  || (CLASS_TYPE_P (lhstype)\n \t      && C_TYPE_FIELDS_READONLY (lhstype))))\n-    readonly_error (lhs, \"assignment\");\n+    {\n+      if (complain & tf_error)\n+\treadonly_error (lhs, \"assignment\");\n+      else\n+\treturn error_mark_node;\n+    }\n \n   /* If storing into a structure or union member, it has probably been\n      given type `int'.  Compute the type that would go with the actual\n@@ -5867,8 +6146,9 @@ build_modify_expr (tree lhs, enum tree_code modifycode, tree rhs)\n       if (!same_or_base_type_p (TYPE_MAIN_VARIANT (lhstype),\n \t\t\t\tTYPE_MAIN_VARIANT (TREE_TYPE (rhs))))\n \t{\n-\t  error (\"incompatible types in assignment of %qT to %qT\",\n-\t\t TREE_TYPE (rhs), lhstype);\n+\t  if (complain & tf_error)\n+\t    error (\"incompatible types in assignment of %qT to %qT\",\n+\t\t   TREE_TYPE (rhs), lhstype);\n \t  return error_mark_node;\n \t}\n \n@@ -5877,36 +6157,40 @@ build_modify_expr (tree lhs, enum tree_code modifycode, tree rhs)\n \t{\n           /* This routine is used for both initialization and assignment.\n              Make sure the diagnostic message differentiates the context.  */\n-          if (modifycode == INIT_EXPR)\n-            error (\"array used as initializer\");\n-          else\n-            error (\"invalid array assignment\");\n+\t  if (complain & tf_error)\n+\t    {\n+\t      if (modifycode == INIT_EXPR)\n+\t\terror (\"array used as initializer\");\n+\t      else\n+\t\terror (\"invalid array assignment\");\n+\t    }\n \t  return error_mark_node;\n \t}\n \n       from_array = TREE_CODE (TREE_TYPE (newrhs)) == ARRAY_TYPE\n \t\t   ? 1 + (modifycode != INIT_EXPR): 0;\n       return build_vec_init (lhs, NULL_TREE, newrhs,\n \t\t\t     /*explicit_default_init_p=*/false,\n-\t\t\t     from_array);\n+\t\t\t     from_array, complain);\n     }\n \n   if (modifycode == INIT_EXPR)\n     newrhs = convert_for_initialization (lhs, lhstype, newrhs, LOOKUP_NORMAL,\n-\t\t\t\t\t \"initialization\", NULL_TREE, 0);\n+\t\t\t\t\t \"initialization\", NULL_TREE, 0,\n+                                         complain);\n   else\n     {\n       /* Avoid warnings on enum bit fields.  */\n       if (TREE_CODE (olhstype) == ENUMERAL_TYPE\n \t  && TREE_CODE (lhstype) == INTEGER_TYPE)\n \t{\n \t  newrhs = convert_for_assignment (olhstype, newrhs, \"assignment\",\n-\t\t\t\t\t   NULL_TREE, 0);\n+\t\t\t\t\t   NULL_TREE, 0, complain);\n \t  newrhs = convert_force (lhstype, newrhs, 0);\n \t}\n       else\n \tnewrhs = convert_for_assignment (lhstype, newrhs, \"assignment\",\n-\t\t\t\t\t NULL_TREE, 0);\n+\t\t\t\t\t NULL_TREE, 0, complain);\n       if (TREE_CODE (newrhs) == CALL_EXPR\n \t  && TYPE_NEEDS_CONSTRUCTING (lhstype))\n \tnewrhs = build_cplus_new (lhstype, newrhs);\n@@ -5952,11 +6236,12 @@ build_modify_expr (tree lhs, enum tree_code modifycode, tree rhs)\n       return result;\n     }\n   return convert_for_assignment (olhstype, result, \"assignment\",\n-\t\t\t\t NULL_TREE, 0);\n+\t\t\t\t NULL_TREE, 0, complain);\n }\n \n tree\n-build_x_modify_expr (tree lhs, enum tree_code modifycode, tree rhs)\n+build_x_modify_expr (tree lhs, enum tree_code modifycode, tree rhs,\n+\t\t     tsubst_flags_t complain)\n {\n   if (processing_template_decl)\n     return build_min_nt (MODOP_EXPR, lhs,\n@@ -5966,14 +6251,15 @@ build_x_modify_expr (tree lhs, enum tree_code modifycode, tree rhs)\n     {\n       tree rval = build_new_op (MODIFY_EXPR, LOOKUP_NORMAL, lhs, rhs,\n \t\t\t\tmake_node (modifycode),\n-\t\t\t\t/*overloaded_p=*/NULL);\n+\t\t\t\t/*overloaded_p=*/NULL,\n+\t\t\t\tcomplain);\n       if (rval)\n \t{\n \t  TREE_NO_WARNING (rval) = 1;\n \t  return rval;\n \t}\n     }\n-  return build_modify_expr (lhs, modifycode, rhs);\n+  return cp_build_modify_expr (lhs, modifycode, rhs, complain);\n }\n \n /* Helper function for get_delta_difference which assumes FROM is a base\n@@ -6151,7 +6437,8 @@ build_ptrmemfunc (tree type, tree pfn, int force, bool c_cast_p)\n \t  if (same_type_p (to_type, pfn_type))\n \t    return pfn;\n \t  else if (integer_zerop (n))\n-\t    return build_reinterpret_cast (to_type, pfn);\n+\t    return build_reinterpret_cast (to_type, pfn, \n+                                           tf_warning_or_error);\n \t}\n \n       if (TREE_SIDE_EFFECTS (pfn))\n@@ -6170,15 +6457,16 @@ build_ptrmemfunc (tree type, tree pfn, int force, bool c_cast_p)\n       gcc_assert  (same_type_ignoring_top_level_qualifiers_p\n \t\t   (TREE_TYPE (delta), ptrdiff_type_node));\n       if (TARGET_PTRMEMFUNC_VBIT_LOCATION == ptrmemfunc_vbit_in_delta)\n-\tn = cp_build_binary_op (LSHIFT_EXPR, n, integer_one_node);\n-      delta = cp_build_binary_op (PLUS_EXPR, delta, n);\n+\tn = cp_build_binary_op (LSHIFT_EXPR, n, integer_one_node,\n+\t\t\t\ttf_warning_or_error);\n+      delta = cp_build_binary_op (PLUS_EXPR, delta, n, tf_warning_or_error);\n       return build_ptrmemfunc1 (to_type, delta, npfn);\n     }\n \n   /* Handle null pointer to member function conversions.  */\n   if (integer_zerop (pfn))\n     {\n-      pfn = build_c_cast (type, integer_zero_node);\n+      pfn = build_c_cast (type, integer_zero_node, tf_warning_or_error);\n       return build_ptrmemfunc1 (to_type,\n \t\t\t\tinteger_zero_node,\n \t\t\t\tpfn);\n@@ -6314,7 +6602,8 @@ delta_from_ptrmemfunc (tree t)\n \n static tree\n convert_for_assignment (tree type, tree rhs,\n-\t\t\tconst char *errtype, tree fndecl, int parmnum)\n+\t\t\tconst char *errtype, tree fndecl, int parmnum,\n+\t\t\ttsubst_flags_t complain)\n {\n   tree rhstype;\n   enum tree_code coder;\n@@ -6338,7 +6627,8 @@ convert_for_assignment (tree type, tree rhs,\n   /* The RHS of an assignment cannot have void type.  */\n   if (coder == VOID_TYPE)\n     {\n-      error (\"void value not ignored as it ought to be\");\n+      if (complain & tf_error)\n+\terror (\"void value not ignored as it ought to be\");\n       return error_mark_node;\n     }\n \n@@ -6391,16 +6681,20 @@ convert_for_assignment (tree type, tree rhs,\n \trhs = cp_convert (strip_top_quals (type), rhs);\n       else\n \t{\n-\t  /* If the right-hand side has unknown type, then it is an\n-\t     overloaded function.  Call instantiate_type to get error\n-\t     messages.  */\n-\t  if (rhstype == unknown_type_node)\n-\t    instantiate_type (type, rhs, tf_warning_or_error);\n-\t  else if (fndecl)\n-\t    error (\"cannot convert %qT to %qT for argument %qP to %qD\",\n-\t\t   rhstype, type, parmnum, fndecl);\n-\t  else\n-\t    error (\"cannot convert %qT to %qT in %s\", rhstype, type, errtype);\n+\t  if (complain & tf_error)\n+\t    {\n+\t      /* If the right-hand side has unknown type, then it is an\n+\t\t overloaded function.  Call instantiate_type to get error\n+\t\t messages.  */\n+\t      if (rhstype == unknown_type_node)\n+\t\tinstantiate_type (type, rhs, tf_warning_or_error);\n+\t      else if (fndecl)\n+\t\terror (\"cannot convert %qT to %qT for argument %qP to %qD\",\n+\t\t       rhstype, type, parmnum, fndecl);\n+\t      else\n+\t\terror (\"cannot convert %qT to %qT in %s\", rhstype, type,\n+\t\t       errtype);\n+\t    }\n \t  return error_mark_node;\n \t}\n     }\n@@ -6409,7 +6703,8 @@ convert_for_assignment (tree type, tree rhs,\n       const enum tree_code codel = TREE_CODE (type);\n       if ((codel == POINTER_TYPE || codel == REFERENCE_TYPE)\n \t  && coder == codel\n-\t  && check_missing_format_attribute (type, rhstype))\n+\t  && check_missing_format_attribute (type, rhstype)\n+\t  && (complain & tf_warning))\n \twarning (OPT_Wmissing_format_attribute,\n \t\t \"%s might be a candidate for a format attribute\",\n \t\t errtype);\n@@ -6421,14 +6716,15 @@ convert_for_assignment (tree type, tree rhs,\n       && type == boolean_type_node\n       && TREE_CODE (rhs) == MODIFY_EXPR\n       && !TREE_NO_WARNING (rhs)\n-      && TREE_TYPE (rhs) != boolean_type_node)\n+      && TREE_TYPE (rhs) != boolean_type_node\n+      && (complain & tf_warning))\n     {\n       warning (OPT_Wparentheses,\n \t       \"suggest parentheses around assignment used as truth value\");\n       TREE_NO_WARNING (rhs) = 1;\n     }\n \n-  return perform_implicit_conversion (strip_top_quals (type), rhs);\n+  return perform_implicit_conversion (strip_top_quals (type), rhs, complain);\n }\n \n /* Convert RHS to be of type TYPE.\n@@ -6449,7 +6745,8 @@ convert_for_assignment (tree type, tree rhs,\n \n tree\n convert_for_initialization (tree exp, tree type, tree rhs, int flags,\n-\t\t\t    const char *errtype, tree fndecl, int parmnum)\n+\t\t\t    const char *errtype, tree fndecl, int parmnum,\n+                            tsubst_flags_t complain)\n {\n   enum tree_code codel = TREE_CODE (type);\n   tree rhstype;\n@@ -6517,7 +6814,8 @@ convert_for_initialization (tree exp, tree type, tree rhs, int flags,\n   if (MAYBE_CLASS_TYPE_P (type))\n     return ocp_convert (type, rhs, CONV_IMPLICIT|CONV_FORCE_TEMP, flags);\n \n-  return convert_for_assignment (type, rhs, errtype, fndecl, parmnum);\n+  return convert_for_assignment (type, rhs, errtype, fndecl, parmnum,\n+\t\t\t\t complain);\n }\n \f\n /* If RETVAL is the address of, or a reference to, a local variable or\n@@ -6810,7 +7108,8 @@ check_return_expr (tree retval, bool *no_warning)\n \t to the type of return value's location to handle the\n \t case that functype is smaller than the valtype.  */\n       retval = convert_for_initialization\n-\t(NULL_TREE, functype, retval, flags, \"return\", NULL_TREE, 0);\n+\t(NULL_TREE, functype, retval, flags, \"return\", NULL_TREE, 0,\n+         tf_warning_or_error);\n       retval = convert (valtype, retval);\n \n       /* If the conversion failed, treat this just like `return;'.  */\n@@ -7174,11 +7473,11 @@ non_reference (tree t)\n    how the lvalue is being used and so selects the error message.  */\n \n int\n-lvalue_or_else (const_tree ref, enum lvalue_use use)\n+lvalue_or_else (const_tree ref, enum lvalue_use use, tsubst_flags_t complain)\n {\n   int win = lvalue_p (ref);\n \n-  if (!win)\n+  if (!win && (complain & tf_error))\n     lvalue_error (use);\n \n   return win;"}, {"sha": "4fdb07ff0b9854d06bf3ecc0786699d0a8b8a183", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 16, "deletions": 11, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ade1ed2c08bf2f327ee24afc57bc263fd90e6e1/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ade1ed2c08bf2f327ee24afc57bc263fd90e6e1/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=5ade1ed2c08bf2f327ee24afc57bc263fd90e6e1", "patch": "@@ -707,7 +707,8 @@ digest_init (tree type, tree init)\n       tree *exp;\n \n       init = convert_for_initialization (0, type, init, LOOKUP_NORMAL,\n-\t\t\t\t\t \"initialization\", NULL_TREE, 0);\n+\t\t\t\t\t \"initialization\", NULL_TREE, 0,\n+                                         tf_warning_or_error);\n       exp = &init;\n \n       /* Skip any conversions since we'll be outputting the underlying\n@@ -751,7 +752,8 @@ digest_init (tree type, tree init)\n \n       return convert_for_initialization (NULL_TREE, type, init,\n \t\t\t\t\t LOOKUP_NORMAL | LOOKUP_ONLYCONVERTING,\n-\t\t\t\t\t \"initialization\", NULL_TREE, 0);\n+\t\t\t\t\t \"initialization\", NULL_TREE, 0,\n+                                         tf_warning_or_error);\n     }\n }\n \n@@ -849,7 +851,8 @@ process_init_constructor_array (tree type, tree init)\n \t      TARGET_EXPRs.  If the type in question is a class, just build\n \t      one up; if it's an array, recurse.  */\n \t    if (MAYBE_CLASS_TYPE_P (TREE_TYPE (type)))\n-\t\tnext = build_functional_cast (TREE_TYPE (type), NULL_TREE);\n+              next = build_functional_cast (TREE_TYPE (type), NULL_TREE,\n+                                            tf_warning_or_error);\n \t    else\n \t\tnext = build_constructor (NULL_TREE, NULL);\n \t    next = digest_init (TREE_TYPE (type), next);\n@@ -936,7 +939,8 @@ process_init_constructor_record (tree type, tree init)\n \t     for us, so build up TARGET_EXPRs.  If the type in question is\n \t     a class, just build one up; if it's an array, recurse.  */\n \t  if (MAYBE_CLASS_TYPE_P (TREE_TYPE (field)))\n-\t    next = build_functional_cast (TREE_TYPE (field), NULL_TREE);\n+\t    next = build_functional_cast (TREE_TYPE (field), NULL_TREE,\n+                                          tf_warning_or_error);\n \t  else\n \t    next = build_constructor (NULL_TREE, NULL);\n \n@@ -1165,7 +1169,8 @@ build_x_arrow (tree expr)\n     {\n       while ((expr = build_new_op (COMPONENT_REF, LOOKUP_NORMAL, expr,\n \t\t\t\t   NULL_TREE, NULL_TREE,\n-\t\t\t\t   /*overloaded_p=*/NULL)))\n+\t\t\t\t   /*overloaded_p=*/NULL, \n+\t\t\t\t   tf_warning_or_error)))\n \t{\n \t  if (expr == error_mark_node)\n \t    return error_mark_node;\n@@ -1205,7 +1210,7 @@ build_x_arrow (tree expr)\n \t  return expr;\n \t}\n \n-      return build_indirect_ref (last_rval, NULL);\n+      return cp_build_indirect_ref (last_rval, NULL, tf_warning_or_error);\n     }\n \n   if (types_memoized)\n@@ -1297,7 +1302,7 @@ build_m_component_ref (tree datum, tree component)\n       datum = build2 (POINTER_PLUS_EXPR, ptype,\n \t\t      fold_convert (ptype, datum),\n \t\t      build_nop (sizetype, component));\n-      return build_indirect_ref (datum, 0);\n+      return cp_build_indirect_ref (datum, 0, tf_warning_or_error);\n     }\n   else\n     return build2 (OFFSET_REF, type, datum, component);\n@@ -1306,7 +1311,7 @@ build_m_component_ref (tree datum, tree component)\n /* Return a tree node for the expression TYPENAME '(' PARMS ')'.  */\n \n tree\n-build_functional_cast (tree exp, tree parms)\n+build_functional_cast (tree exp, tree parms, tsubst_flags_t complain)\n {\n   /* This is either a call to a constructor,\n      or a C cast in C++'s `functional' notation.  */\n@@ -1337,7 +1342,7 @@ build_functional_cast (tree exp, tree parms)\n \n       /* This must build a C cast.  */\n       parms = build_x_compound_expr_from_list (parms, \"functional cast\");\n-      return build_c_cast (type, parms);\n+      return build_c_cast (type, parms, complain);\n     }\n \n   /* Prepare to evaluate as a call to a constructor.  If this expression\n@@ -1358,7 +1363,7 @@ build_functional_cast (tree exp, tree parms)\n      conversion is equivalent (in definedness, and if defined in\n      meaning) to the corresponding cast expression.  */\n   if (parms && TREE_CHAIN (parms) == NULL_TREE)\n-    return build_c_cast (type, TREE_VALUE (parms));\n+    return build_c_cast (type, TREE_VALUE (parms), complain);\n \n   /* [expr.type.conv]\n \n@@ -1378,7 +1383,7 @@ build_functional_cast (tree exp, tree parms)\n \n   /* Call the constructor.  */\n   exp = build_special_member_call (NULL_TREE, complete_ctor_identifier, parms,\n-\t\t\t\t   type, LOOKUP_NORMAL);\n+\t\t\t\t   type, LOOKUP_NORMAL, complain);\n \n   if (exp == error_mark_node)\n     return error_mark_node;"}, {"sha": "4adfe1d69473b90942d7f0dc9b3af7136a9bb235", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ade1ed2c08bf2f327ee24afc57bc263fd90e6e1/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ade1ed2c08bf2f327ee24afc57bc263fd90e6e1/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5ade1ed2c08bf2f327ee24afc57bc263fd90e6e1", "patch": "@@ -1,3 +1,18 @@\n+2008-03-25  Douglas Gregor  <doug.gregor@gmail.com>\n+\n+       * g++.dg/template/sfinae4.C: New.\n+       * g++.dg/template/sfinae5.C: New.\n+       * g++.dg/template/sfinae6.C: New.\n+       * g++.dg/template/sfinae6_neg.C: New.\n+       * g++.dg/template/sfinae7.C: New.\n+       * g++.dg/template/sfinae8.C: New.\n+       * g++.dg/template/sfinae9.C: New.\n+       * g++.dg/template/sfinae10.C: New.\n+       * g++.dg/template/sfinae11.C: New.\n+       * g++.dg/template/sfinae12.C: New.\n+       * g++.dg/template/sfinae13.C: New.\n+       * g++.dg/template/sfinae14C: New.\n+\n 2008-03-25  Naveen.H.S  <naveen.hs@kpitcummins.com>\n \n \t* gcc.target/sh/sh2a-bclr.c: New test."}, {"sha": "e0680db65a60efde763f011d432af56a0ffd4f25", "filename": "gcc/testsuite/g++.dg/template/sfinae10.C", "status": "added", "additions": 181, "deletions": 0, "changes": 181, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ade1ed2c08bf2f327ee24afc57bc263fd90e6e1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fsfinae10.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ade1ed2c08bf2f327ee24afc57bc263fd90e6e1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fsfinae10.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fsfinae10.C?ref=5ade1ed2c08bf2f327ee24afc57bc263fd90e6e1", "patch": "@@ -0,0 +1,181 @@\n+// DR 339\n+//\n+// Test of the use of various unary operators with SFINAE\n+\n+// Boilerplate helpers\n+typedef char yes_type;\n+struct no_type { char data[2]; };\n+\n+template<typename T> T create_a();\n+template<typename T> struct type { };\n+\n+template<bool, typename T = void> struct enable_if { typedef T type; };\n+template<typename T> struct enable_if<false, T> { };\n+\n+#define JOIN( X, Y ) DO_JOIN( X, Y )\n+#define DO_JOIN( X, Y ) DO_JOIN2(X,Y)\n+#define DO_JOIN2( X, Y ) X##Y\n+\n+#define DEFINE_PREFIX_UNARY_TRAIT(Name,Op)                      \\\n+template<typename T>                                            \\\n+  typename enable_if<(sizeof(Op create_a<T>(), 1) > 0),         \\\n+\t\t     yes_type>::type                            \\\n+  JOIN(check_,Name)(int);                                       \\\n+                                                                \\\n+template<typename T>                                            \\\n+  no_type JOIN(check_,Name)(...);                               \\\n+                                                                \\\n+template<typename T>                                            \\\n+struct Name                                                     \\\n+{                                                               \\\n+  static const bool value =                                     \\\n+    (sizeof(JOIN(check_,Name)<T&>(0)) == sizeof(yes_type));     \\\n+}\n+\n+#define DEFINE_POSTFIX_UNARY_TRAIT(Name,Op)                     \\\n+template<typename T>                                            \\\n+  typename enable_if<(sizeof(create_a<T>() Op, 1) > 0),         \\\n+\t\t     yes_type>::type                            \\\n+  JOIN(check_,Name)(int);                                       \\\n+                                                                \\\n+template<typename T>                                            \\\n+  no_type JOIN(check_,Name)(...);                               \\\n+                                                                \\\n+template<typename T>                                            \\\n+struct Name                                                     \\\n+{                                                               \\\n+  static const bool value =                                     \\\n+    (sizeof(JOIN(check_,Name)<T&>(0)) == sizeof(yes_type));     \\\n+}\n+\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+#  define STATIC_ASSERT(Expr) static_assert(Expr, #Expr)\n+#else\n+#  define STATIC_ASSERT(Expr) int JOIN(a,__LINE__)[Expr? 1 : -1]\n+#endif\n+\n+struct W {\n+  W operator+();\n+  W operator-();\n+  int operator*();\n+  W operator~();\n+  bool operator!();\n+  W& operator++();\n+  W& operator--();\n+  W& operator++(int);\n+  W& operator--(int);\n+};\n+\n+struct X { };\n+X operator+(X);\n+X operator-(X);\n+int operator*(X);\n+X operator~(X);\n+bool operator!(X);\n+X& operator++(X&);\n+X& operator--(X&);\n+X& operator++(X&, int);\n+X& operator--(X&, int);\n+\n+struct Y { };\n+\n+struct Z {\n+private:\n+  Z operator+(); // { dg-error \"is private\" }\n+  Z operator-(); // { dg-error \"is private\" }\n+  int operator*(); // { dg-error \"is private\" }\n+  Z operator~(); // { dg-error \"is private\" } \n+  bool operator!(); // { dg-error \"is private\" }  \n+  Z& operator++(); // { dg-error \"is private\" }  \n+  Z& operator--(); // { dg-error \"is private\" }  \n+  Z& operator++(int); // { dg-error \"is private\" }  \n+  Z& operator--(int); // { dg-error \"is private\" }  \n+};\n+\n+// has_unary_plus\n+DEFINE_PREFIX_UNARY_TRAIT(has_unary_plus, +); // { dg-error \"within this context\" }\n+STATIC_ASSERT((has_unary_plus<int>::value));\n+STATIC_ASSERT((!has_unary_plus<int X::*>::value));\n+STATIC_ASSERT((has_unary_plus<W>::value));\n+STATIC_ASSERT((has_unary_plus<X>::value));\n+STATIC_ASSERT((!has_unary_plus<Y>::value));\n+\n+// is_negatable\n+DEFINE_PREFIX_UNARY_TRAIT(is_negatable, -); // { dg-error \"within this context\" }\n+STATIC_ASSERT((is_negatable<int>::value));\n+STATIC_ASSERT((!is_negatable<int X::*>::value));\n+STATIC_ASSERT((is_negatable<W>::value));\n+STATIC_ASSERT((is_negatable<X>::value));\n+STATIC_ASSERT((!is_negatable<Y>::value));\n+\n+// is_dereferenceable\n+DEFINE_PREFIX_UNARY_TRAIT(is_dereferenceable, *); // { dg-error \"within this context\" }\n+STATIC_ASSERT((!is_dereferenceable<int>::value));\n+STATIC_ASSERT((is_dereferenceable<int*>::value));\n+STATIC_ASSERT((is_dereferenceable<W>::value));\n+STATIC_ASSERT((is_dereferenceable<X>::value));\n+STATIC_ASSERT((!is_dereferenceable<Y>::value));\n+\n+// has_bitwise_not\n+DEFINE_PREFIX_UNARY_TRAIT(has_bitwise_not, ~); // { dg-error \"within this context\" }\n+STATIC_ASSERT((has_bitwise_not<int>::value));\n+STATIC_ASSERT((!has_bitwise_not<int*>::value));\n+STATIC_ASSERT((has_bitwise_not<W>::value));\n+STATIC_ASSERT((has_bitwise_not<X>::value));\n+STATIC_ASSERT((!has_bitwise_not<Y>::value));\n+\n+// has_truth_not\n+DEFINE_PREFIX_UNARY_TRAIT(has_truth_not, !); // { dg-error \"within this context\" }\n+STATIC_ASSERT((has_truth_not<int>::value));\n+STATIC_ASSERT((has_truth_not<int*>::value));\n+STATIC_ASSERT((has_truth_not<W>::value));\n+STATIC_ASSERT((has_truth_not<X>::value));\n+STATIC_ASSERT((!has_truth_not<Y>::value));\n+\n+// has_preincrement\n+DEFINE_PREFIX_UNARY_TRAIT(has_preincrement, ++); // { dg-error \"within this context\" }\n+STATIC_ASSERT((has_preincrement<int>::value));\n+STATIC_ASSERT((has_preincrement<int*>::value));\n+STATIC_ASSERT((!has_preincrement<int X::*>::value));\n+STATIC_ASSERT((has_preincrement<W>::value));\n+STATIC_ASSERT((has_preincrement<X>::value));\n+STATIC_ASSERT((!has_preincrement<Y>::value));\n+\n+// has_predecrement\n+DEFINE_PREFIX_UNARY_TRAIT(has_predecrement, --); // { dg-error \"within this context\" }\n+STATIC_ASSERT((has_predecrement<int>::value));\n+STATIC_ASSERT((has_predecrement<int*>::value));\n+STATIC_ASSERT((!has_predecrement<int X::*>::value));\n+STATIC_ASSERT((has_predecrement<W>::value));\n+STATIC_ASSERT((has_predecrement<X>::value));\n+STATIC_ASSERT((!has_predecrement<Y>::value));\n+\n+// has_postincrement\n+DEFINE_POSTFIX_UNARY_TRAIT(has_postincrement, ++); // { dg-error \"within this context\" }\n+STATIC_ASSERT((has_postincrement<int>::value));\n+STATIC_ASSERT((has_postincrement<int*>::value));\n+STATIC_ASSERT((!has_postincrement<int X::*>::value));\n+STATIC_ASSERT((has_postincrement<W>::value));\n+STATIC_ASSERT((has_postincrement<X>::value));\n+STATIC_ASSERT((!has_postincrement<Y>::value));\n+\n+// has_postdecrement\n+DEFINE_POSTFIX_UNARY_TRAIT(has_postdecrement, --); // { dg-error \"within this context\" }\n+STATIC_ASSERT((has_postdecrement<int>::value));\n+STATIC_ASSERT((has_postdecrement<int*>::value));\n+STATIC_ASSERT((!has_postdecrement<int X::*>::value));\n+STATIC_ASSERT((has_postdecrement<W>::value));\n+STATIC_ASSERT((has_postdecrement<X>::value));\n+STATIC_ASSERT((!has_postdecrement<Y>::value));\n+\n+// Check for private members\n+STATIC_ASSERT((has_unary_plus<Z>::value)); // { dg-error \"instantiated from here\" }\n+STATIC_ASSERT((is_negatable<Z>::value)); // { dg-error \"instantiated from here\" }\n+STATIC_ASSERT((is_dereferenceable<Z>::value)); // { dg-error \"instantiated from here\" }\n+STATIC_ASSERT((has_bitwise_not<Z>::value)); // { dg-error \"instantiated from here\" }\n+STATIC_ASSERT((has_truth_not<Z>::value)); // { dg-error \"instantiated from here\" }\n+STATIC_ASSERT((has_preincrement<Z>::value)); // { dg-error \"instantiated from here\" }\n+STATIC_ASSERT((has_predecrement<Z>::value)); // { dg-error \"instantiated from here\" }\n+STATIC_ASSERT((has_postincrement<Z>::value)); // { dg-error \"instantiated from here\" }\n+STATIC_ASSERT((has_postdecrement<Z>::value)); // { dg-error \"instantiated from here\" }\n+"}, {"sha": "a813055ead20111a90e980b22fa9a7da768c47fe", "filename": "gcc/testsuite/g++.dg/template/sfinae11.C", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ade1ed2c08bf2f327ee24afc57bc263fd90e6e1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fsfinae11.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ade1ed2c08bf2f327ee24afc57bc263fd90e6e1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fsfinae11.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fsfinae11.C?ref=5ade1ed2c08bf2f327ee24afc57bc263fd90e6e1", "patch": "@@ -0,0 +1,53 @@\n+// DR 339\n+//\n+// Test of the use of the comma operator with SFINAE\n+\n+// Boilerplate helpers\n+typedef char yes_type;\n+struct no_type { char data[2]; };\n+\n+template<typename T> T create_a();\n+template<typename T> struct type { };\n+\n+template<bool, typename T = void> struct enable_if { typedef T type; };\n+template<typename T> struct enable_if<false, T> { };\n+\n+#define JOIN( X, Y ) DO_JOIN( X, Y )\n+#define DO_JOIN( X, Y ) DO_JOIN2(X,Y)\n+#define DO_JOIN2( X, Y ) X##Y\n+\n+template<typename T, typename U>\n+  typename enable_if<(sizeof(create_a<T>(), create_a<U>()) > 0),\n+\t\t     yes_type>::type\n+  check_comma(int);\n+                                                            \n+template<typename T, typename U> no_type check_comma(...);\n+                                                            \n+template<typename T, typename U>\n+struct has_comma\n+{\n+  static const bool value =\n+    (sizeof(check_comma<T, U>(0)) == sizeof(yes_type));\n+};\n+\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+#  define STATIC_ASSERT(Expr) static_assert(Expr, #Expr)\n+#else\n+#  define STATIC_ASSERT(Expr) int JOIN(a,__LINE__)[Expr? 1 : -1]\n+#endif\n+\n+struct X { };\n+struct Y { };\n+struct Z { };\n+\n+bool operator,(X&, Y);\n+bool operator,(X, Z);\n+void operator,(const Y&, const Z&);\n+\n+STATIC_ASSERT((has_comma<int, float>::value));\n+STATIC_ASSERT((has_comma<int, X>::value));\n+STATIC_ASSERT((has_comma<X, X>::value));\n+STATIC_ASSERT((has_comma<X, Y>::value));\n+STATIC_ASSERT((has_comma<X&, Y>::value));\n+STATIC_ASSERT((has_comma<X, Z>::value));\n+STATIC_ASSERT((!has_comma<Y, Z>::value));"}, {"sha": "c51211be2b9ddd0baa3c14265cb196dff4b52886", "filename": "gcc/testsuite/g++.dg/template/sfinae12.C", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ade1ed2c08bf2f327ee24afc57bc263fd90e6e1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fsfinae12.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ade1ed2c08bf2f327ee24afc57bc263fd90e6e1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fsfinae12.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fsfinae12.C?ref=5ade1ed2c08bf2f327ee24afc57bc263fd90e6e1", "patch": "@@ -0,0 +1,47 @@\n+// DR 339\n+//\n+// Test of the use of the ternary operator with SFINAE\n+\n+// Boilerplate helpers\n+typedef char yes_type;\n+struct no_type { char data[2]; };\n+\n+template<typename T> T create_a();\n+template<typename T> struct type { };\n+\n+template<bool, typename T = void> struct enable_if { typedef T type; };\n+template<typename T> struct enable_if<false, T> { };\n+\n+#define JOIN( X, Y ) DO_JOIN( X, Y )\n+#define DO_JOIN( X, Y ) DO_JOIN2(X,Y)\n+#define DO_JOIN2( X, Y ) X##Y\n+\n+template<typename T, typename U, typename V>\n+typename enable_if<\n+           (sizeof((create_a<T>()? create_a<U>() : create_a<V>()), 0) > 0),\n+           yes_type>::type\n+  check_ternary(int);\n+                                                            \n+template<typename T, typename U, typename V> no_type check_ternary(...);\n+                                                            \n+template<typename T, typename U, typename V>\n+struct has_ternary\n+{\n+  static const bool value =\n+    (sizeof(check_ternary<T, U, V>(0)) == sizeof(yes_type));\n+};\n+\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+#  define STATIC_ASSERT(Expr) static_assert(Expr, #Expr)\n+#else\n+#  define STATIC_ASSERT(Expr) int JOIN(a,__LINE__)[Expr? 1 : -1]\n+#endif\n+\n+struct X { };\n+struct Y { operator bool(); };\n+\n+STATIC_ASSERT((has_ternary<int, float, double>::value));\n+STATIC_ASSERT((has_ternary<bool, double, double>::value));\n+STATIC_ASSERT((!has_ternary<int, float*, double>::value));\n+STATIC_ASSERT((!has_ternary<X, double, double>::value));\n+STATIC_ASSERT((has_ternary<Y, double, double>::value));"}, {"sha": "b659685d88b8be814639c5c61b4908a2d68e0139", "filename": "gcc/testsuite/g++.dg/template/sfinae13.C", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ade1ed2c08bf2f327ee24afc57bc263fd90e6e1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fsfinae13.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ade1ed2c08bf2f327ee24afc57bc263fd90e6e1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fsfinae13.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fsfinae13.C?ref=5ade1ed2c08bf2f327ee24afc57bc263fd90e6e1", "patch": "@@ -0,0 +1,86 @@\n+// DR 339\n+//\n+// Test of the use of casts with SFINAE\n+\n+// Boilerplate helpers\n+typedef char yes_type;\n+struct no_type { char data[2]; };\n+\n+template<typename T> T create_a();\n+template<typename T> struct type { };\n+\n+template<bool, typename T = void> struct enable_if { typedef T type; };\n+template<typename T> struct enable_if<false, T> { };\n+\n+#define JOIN( X, Y ) DO_JOIN( X, Y )\n+#define DO_JOIN( X, Y ) DO_JOIN2(X,Y)\n+#define DO_JOIN2( X, Y ) X##Y\n+\n+#define CHECK_CAST(CastKind)                                            \\\n+template<typename T, typename U>                                        \\\n+ typename enable_if<(sizeof((JOIN(CastKind,_cast)<U>(create_a<T>())), 0) > 0), \\\n+                   yes_type>::type                                      \\\n+  JOIN(check_,JOIN(CastKind,_cast))(int);                               \\\n+                                                                        \\\n+template<typename T, typename U>                                        \\\n+  no_type JOIN(check_,JOIN(CastKind,_cast))(...);                       \\\n+                                                                        \\\n+template<typename T, typename U>                                        \\\n+struct JOIN(has_,JOIN(CastKind,_cast))                                  \\\n+{                                                                       \\\n+  static const bool value =                                             \\\n+    (sizeof(JOIN(check_,JOIN(CastKind,_cast))<T, U>(0)) == sizeof(yes_type)); \\\n+}\n+\n+template<typename T, typename U>\n+typename enable_if<(sizeof(((U)create_a<T>()), 0) > 0), yes_type>::type\n+  check_c_cast(int);\n+                                                            \n+template<typename T, typename U> no_type check_c_cast(...);\n+                                                            \n+template<typename T, typename U>\n+struct has_c_cast\n+{\n+  static const bool value =\n+    (sizeof(check_c_cast<T, U>(0)) == sizeof(yes_type));\n+};\n+\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+#  define STATIC_ASSERT(Expr) static_assert(Expr, #Expr)\n+#else\n+#  define STATIC_ASSERT(Expr) int JOIN(a,__LINE__)[Expr? 1 : -1]\n+#endif\n+\n+CHECK_CAST(static);\n+CHECK_CAST(dynamic);\n+CHECK_CAST(const);\n+CHECK_CAST(reinterpret);\n+\n+struct X { virtual void f(); };\n+struct Y { operator bool(); };\n+struct Z : public X { };\n+\n+STATIC_ASSERT((has_static_cast<int, float>::value));\n+STATIC_ASSERT((!has_static_cast<X, Y>::value));\n+STATIC_ASSERT((has_static_cast<Z, X>::value));\n+\n+STATIC_ASSERT(!(has_dynamic_cast<int, float>::value));\n+STATIC_ASSERT(!(has_dynamic_cast<X, Y>::value));\n+STATIC_ASSERT(!(has_dynamic_cast<X, Z>::value));\n+STATIC_ASSERT(!(has_dynamic_cast<Y, Z>::value));\n+STATIC_ASSERT((has_dynamic_cast<X*, Z*>::value));\n+STATIC_ASSERT((has_dynamic_cast<X*, Y*>::value));\n+STATIC_ASSERT(!(has_dynamic_cast<Y*, Z*>::value));\n+\n+STATIC_ASSERT(!(has_const_cast<int, float>::value));\n+STATIC_ASSERT((has_const_cast<const int*, int*>::value));\n+STATIC_ASSERT((has_const_cast<int*, const int*>::value));\n+STATIC_ASSERT(!(has_const_cast<const int*, float*>::value));\n+\n+STATIC_ASSERT((has_reinterpret_cast<int*, float*>::value));\n+STATIC_ASSERT(!(has_reinterpret_cast<void*, char>::value));\n+STATIC_ASSERT(!(has_reinterpret_cast<const X, X>::value));\n+\n+STATIC_ASSERT((has_c_cast<int, float>::value));\n+STATIC_ASSERT(!(has_c_cast<X, Y>::value));\n+STATIC_ASSERT(!(has_c_cast<void*, char>::value));"}, {"sha": "93eba43a08f33b83dc1f6f2f48734f52d5c365b1", "filename": "gcc/testsuite/g++.dg/template/sfinae14.C", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ade1ed2c08bf2f327ee24afc57bc263fd90e6e1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fsfinae14.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ade1ed2c08bf2f327ee24afc57bc263fd90e6e1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fsfinae14.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fsfinae14.C?ref=5ade1ed2c08bf2f327ee24afc57bc263fd90e6e1", "patch": "@@ -0,0 +1,79 @@\n+// DR 339\n+//\n+// Test of the use of the new and new[] operators with SFINAE\n+\n+// Boilerplate helpers\n+typedef char yes_type;\n+struct no_type { char data[2]; };\n+\n+template<typename T> T create_a();\n+template<typename T> struct type { };\n+\n+template<bool, typename T = void> struct enable_if { typedef T type; };\n+template<typename T> struct enable_if<false, T> { };\n+\n+#define JOIN( X, Y ) DO_JOIN( X, Y )\n+#define DO_JOIN( X, Y ) DO_JOIN2(X,Y)\n+#define DO_JOIN2( X, Y ) X##Y\n+\n+template<typename T>\n+typename enable_if<(sizeof(new T, 0) > 0), yes_type>::type\n+  check_new(int);\n+                                                            \n+template<typename T> no_type check_new(...);\n+                                                            \n+template<typename T>\n+struct has_new\n+{\n+  static const bool value =\n+    (sizeof(check_new<T>(0)) == sizeof(yes_type));\n+};\n+\n+template<typename T, typename U>\n+typename enable_if<(sizeof((new T(create_a<U>())), 0) > 0),\n+                   yes_type>::type\n+  check_new_one_arg(int);\n+                                                            \n+template<typename T, typename U> no_type check_new_one_arg(...);\n+                                                            \n+template<typename T, typename U>\n+struct has_new_one_arg\n+{\n+  static const bool value =\n+    (sizeof(check_new_one_arg<T, U>(0)) == sizeof(yes_type));\n+};\n+\n+template<typename T, typename U, U N>\n+typename enable_if<(sizeof(new T[N], 0) > 0), yes_type>::type\n+  check_array_new(int);\n+                                                            \n+template<typename T, typename U, U N> no_type check_array_new(...);\n+                                                            \n+template<typename T, typename U, U N>\n+struct has_array_new\n+{\n+  static const bool value =\n+    (sizeof(check_array_new<T, U, N>(0)) == sizeof(yes_type));\n+};\n+\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+#  define STATIC_ASSERT(Expr) static_assert(Expr, #Expr)\n+#else\n+#  define STATIC_ASSERT(Expr) int JOIN(a,__LINE__)[Expr? 1 : -1]\n+#endif\n+\n+struct X { \n+  X(int);\n+};\n+\n+struct Y { int foo; };\n+\n+STATIC_ASSERT((has_new<Y>::value));\n+STATIC_ASSERT(!(has_new<X>::value));\n+STATIC_ASSERT((has_new_one_arg<Y, Y>::value));\n+STATIC_ASSERT((has_new_one_arg<X, float>::value));\n+STATIC_ASSERT(!(has_new_one_arg<X, int X::*>::value));\n+\n+STATIC_ASSERT((has_array_new<Y, int, 5>::value));\n+STATIC_ASSERT(!(has_array_new<X, int Y::*, &Y::foo>::value));\n+STATIC_ASSERT((has_array_new<X, int, 5>::value));"}, {"sha": "a9650511e9dd698c40c3787aba5b3c3901a38de2", "filename": "gcc/testsuite/g++.dg/template/sfinae4.C", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ade1ed2c08bf2f327ee24afc57bc263fd90e6e1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fsfinae4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ade1ed2c08bf2f327ee24afc57bc263fd90e6e1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fsfinae4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fsfinae4.C?ref=5ade1ed2c08bf2f327ee24afc57bc263fd90e6e1", "patch": "@@ -0,0 +1,35 @@\n+// DR 339\n+//\n+// Test of the use of free functions with SFINAE\n+void foo(int) { }\n+template<typename T> void foo(T*) { }\n+\n+typedef char yes_type;\n+struct no_type { char data[2]; };\n+\n+template<typename T> T create_a();\n+\n+template<bool, typename T = void> struct enable_if { typedef T type; };\n+template<typename T> struct enable_if<false, T> { };\n+\n+template<typename T> \n+  typename enable_if<(sizeof(foo(create_a<T const&>()), 1) > 0),\n+\t\t     yes_type>::type\n+  check_has_foo(const volatile T&);\n+\n+no_type check_has_foo(...);\n+\n+template<typename T>\n+struct has_foo\n+{\n+  static const bool value = \n+    (sizeof(check_has_foo(create_a<T const&>())) == sizeof(yes_type));\n+};\n+\n+struct X { };\n+\n+int a1[has_foo<int>::value? 1 : -1];\n+int a2[has_foo<long>::value? 1 : -1];\n+int a3[has_foo<int*>::value? 1 : -1];\n+int a4[has_foo<X>::value? -1 : 1];\n+int a5[has_foo<int X::*>::value? -1 : 1];"}, {"sha": "516e5cc85fcc6f59754e558ab305011e0f0846cb", "filename": "gcc/testsuite/g++.dg/template/sfinae5.C", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ade1ed2c08bf2f327ee24afc57bc263fd90e6e1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fsfinae5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ade1ed2c08bf2f327ee24afc57bc263fd90e6e1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fsfinae5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fsfinae5.C?ref=5ade1ed2c08bf2f327ee24afc57bc263fd90e6e1", "patch": "@@ -0,0 +1,47 @@\n+// DR 339\n+//\n+// Test of the use of member functions with SFINAE\n+typedef char yes_type;\n+struct no_type { char data[2]; };\n+\n+template<typename T> T create_a();\n+\n+template<bool, typename T = void> struct enable_if { typedef T type; };\n+template<typename T> struct enable_if<false, T> { };\n+\n+template<typename T> \n+  typename enable_if<(sizeof(create_a<T>().foo(), 1) > 0),\n+\t\t     yes_type>::type\n+  check_has_member_foo(const volatile T&);\n+\n+no_type check_has_member_foo(...);\n+\n+template<typename T>\n+struct has_foo\n+{\n+  static const bool value = \n+    (sizeof(check_has_member_foo(create_a<T const&>())) == sizeof(yes_type));\n+};\n+\n+struct X { };\n+struct Y {\n+  void foo();\n+};\n+struct Z {\n+  void foo(int);\n+};\n+\n+struct A {\n+  int foo;\n+};\n+\n+struct B {\n+  static int foo();\n+};\n+\n+int a1[has_foo<X>::value? -1 : 1];\n+int a2[has_foo<Y>::value? 1 : -1];\n+int a3[has_foo<Z>::value? -1 : 1];\n+int a4[has_foo<int>::value? -1 : 1];\n+int a5[has_foo<A>::value? -1 : 1];\n+int a6[has_foo<B>::value? 1 : -1];"}, {"sha": "64567aae28eb236e639e494493933f0865f50a32", "filename": "gcc/testsuite/g++.dg/template/sfinae6.C", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ade1ed2c08bf2f327ee24afc57bc263fd90e6e1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fsfinae6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ade1ed2c08bf2f327ee24afc57bc263fd90e6e1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fsfinae6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fsfinae6.C?ref=5ade1ed2c08bf2f327ee24afc57bc263fd90e6e1", "patch": "@@ -0,0 +1,83 @@\n+// DR 339\n+//\n+// Test of the use of the function call operator with SFINAE\n+typedef char yes_type;\n+struct no_type { char data[2]; };\n+\n+template<typename T> T create_a();\n+\n+template<typename T> struct type { };\n+\n+template<bool, typename T = void> struct enable_if { typedef T type; };\n+template<typename T> struct enable_if<false, T> { };\n+\n+template<typename F, typename T1, typename T2>\n+  typename enable_if<sizeof(create_a<F>()(create_a<T1>(), create_a<T2>()), 1),\n+\t\t     yes_type>::type\n+  check_is_callable2(type<F>, type<T1>, type<T2>);\n+\n+no_type check_is_callable2(...);\n+\n+template<typename F, typename T1, typename T2 = T1>\n+struct is_callable2\n+{\n+  static const bool value = \n+    (sizeof(check_is_callable2(type<F>(), type<T1>(), type<T2>()))\n+     == sizeof(yes_type));\n+};\n+\n+#define JOIN( X, Y ) DO_JOIN( X, Y )\n+#define DO_JOIN( X, Y ) DO_JOIN2(X,Y)\n+#define DO_JOIN2( X, Y ) X##Y\n+\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+#  define STATIC_ASSERT(Expr) static_assert(Expr, #Expr)\n+#else\n+#  define STATIC_ASSERT(Expr) int JOIN(a,__LINE__)[Expr? 1 : -1]\n+#endif\n+\n+\n+struct A;\n+struct B;\n+\n+struct A {\n+  A(B);\n+};\n+\n+struct B {\n+  B(A);\n+};\n+\n+struct F1 { };\n+\n+struct F2 {\n+  bool operator()(int, float);\n+};\n+\n+struct F3 {\n+  bool operator()(int);\n+};\n+\n+struct F4 {\n+  void operator()(A, A);\n+  void operator()(B, B);\n+};\n+\n+struct F5 {\n+  void operator()(A, A);\n+\n+private:\n+  void operator()(B, B);\n+};\n+\n+STATIC_ASSERT((is_callable2<int(*)(int, int), long, int>::value));\n+STATIC_ASSERT((!is_callable2<int(*)(int, int), int*, int>::value));\n+STATIC_ASSERT((!is_callable2<F1, int, int>::value));\n+STATIC_ASSERT((is_callable2<F2, int, int>::value));\n+STATIC_ASSERT((!is_callable2<F2, int*, int>::value));\n+STATIC_ASSERT((!is_callable2<F3, int, int>::value));\n+STATIC_ASSERT((is_callable2<F4, A, A>::value));\n+STATIC_ASSERT((is_callable2<F4, B, B>::value));\n+STATIC_ASSERT((!is_callable2<F4, A, B>::value));\n+STATIC_ASSERT((is_callable2<F5, A, A>::value));\n+STATIC_ASSERT((!is_callable2<F5, A, B>::value));"}, {"sha": "2df4ade47208867a7b474f24ec57776110603325", "filename": "gcc/testsuite/g++.dg/template/sfinae6_neg.C", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ade1ed2c08bf2f327ee24afc57bc263fd90e6e1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fsfinae6_neg.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ade1ed2c08bf2f327ee24afc57bc263fd90e6e1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fsfinae6_neg.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fsfinae6_neg.C?ref=5ade1ed2c08bf2f327ee24afc57bc263fd90e6e1", "patch": "@@ -0,0 +1,58 @@\n+// DR 339\n+//\n+// Test of the use of the function call operator with SFINAE\n+typedef char yes_type;\n+struct no_type { char data[2]; };\n+\n+template<typename T> T create_a();\n+\n+template<typename T> struct type { };\n+\n+template<bool, typename T = void> struct enable_if { typedef T type; };\n+template<typename T> struct enable_if<false, T> { };\n+\n+template<typename F, typename T1, typename T2>\n+  typename enable_if<sizeof(create_a<F>()(create_a<T1>(), create_a<T2>()), 1),\n+\t\t     yes_type>::type\n+  check_is_callable2(type<F>, type<T1>, type<T2>);\n+\n+no_type check_is_callable2(...);\n+\n+template<typename F, typename T1, typename T2 = T1>\n+struct is_callable2\n+{\n+  static const bool value = \n+    (sizeof(check_is_callable2(type<F>(), type<T1>(), type<T2>()))\n+     == sizeof(yes_type)); // { dg-error \"within this context\" }\n+};\n+\n+#define JOIN( X, Y ) DO_JOIN( X, Y )\n+#define DO_JOIN( X, Y ) DO_JOIN2(X,Y)\n+#define DO_JOIN2( X, Y ) X##Y\n+\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+#  define STATIC_ASSERT(Expr) static_assert(Expr, #Expr)\n+#else\n+#  define STATIC_ASSERT(Expr) int JOIN(a,__LINE__)[Expr? 1 : -1]\n+#endif\n+\n+\n+struct A;\n+struct B;\n+\n+struct A {\n+  A(B);\n+};\n+\n+struct B {\n+  B(A);\n+};\n+\n+struct F {\n+  void operator()(A, A);\n+\n+private:\n+  void operator()(B, B); // { dg-error \"is private\" }\n+};\n+\n+STATIC_ASSERT((is_callable2<F, B, B>::value));"}, {"sha": "8551eb279fe15638901fc3bc918282e42e238a0c", "filename": "gcc/testsuite/g++.dg/template/sfinae7.C", "status": "added", "additions": 199, "deletions": 0, "changes": 199, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ade1ed2c08bf2f327ee24afc57bc263fd90e6e1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fsfinae7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ade1ed2c08bf2f327ee24afc57bc263fd90e6e1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fsfinae7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fsfinae7.C?ref=5ade1ed2c08bf2f327ee24afc57bc263fd90e6e1", "patch": "@@ -0,0 +1,199 @@\n+// DR 339\n+//\n+// Test of the use of various binary operators with SFINAE\n+\n+// Boilerplate helpers\n+typedef char yes_type;\n+struct no_type { char data[2]; };\n+\n+template<typename T> T create_a();\n+template<typename T> struct type { };\n+\n+template<bool, typename T = void> struct enable_if { typedef T type; };\n+template<typename T> struct enable_if<false, T> { };\n+\n+#define JOIN( X, Y ) DO_JOIN( X, Y )\n+#define DO_JOIN( X, Y ) DO_JOIN2(X,Y)\n+#define DO_JOIN2( X, Y ) X##Y\n+\n+#define DEFINE_INFIX_BINARY_TRAIT(Name,Op)\t\t\t\t\\\n+template<typename T, typename U>\t\t\t\t\t\\\n+  typename enable_if<(sizeof(create_a<T>() Op create_a<U>(), 1) > 0),\t\\\n+\t\t     yes_type>::type\t\t\t\t\t\\\n+  JOIN(check_,Name)(type<T>, type<U>);\t\t                        \\\n+\t\t\t\t\t\t\t\t\t\\\n+no_type JOIN(check_,Name)(...);\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+template<typename T, typename U = T>\t\t\t\t\t\\\n+struct Name\t\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  static const bool value =\t\t\t\t\t\t\\\n+    (sizeof(JOIN(check_,Name)(type<T>(), type<U>())) == sizeof(yes_type)); \\\n+}\n+\n+template<typename T, typename U>\n+  typename enable_if<(sizeof(create_a<T>()[create_a<U>()], 1) > 0),\n+                     yes_type>::type\n+  check_subscript(int);\n+\n+template<typename T, typename U>\n+  no_type check_subscript(...);\n+\n+template<typename T, typename U>\n+struct can_subscript\n+{\n+  static const bool value = \n+    (sizeof(check_subscript<T, U>(0)) == sizeof(yes_type));\n+};\n+\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+#  define STATIC_ASSERT(Expr) static_assert(Expr, #Expr)\n+#else\n+#  define STATIC_ASSERT(Expr) int JOIN(a,__LINE__)[Expr? 1 : -1]\n+#endif\n+\n+struct X { };\n+struct Y { int operator[](X); };\n+\n+// is_addable\n+DEFINE_INFIX_BINARY_TRAIT(is_addable, +);\n+X operator+(X, X);\n+X operator+(X, Y);\n+STATIC_ASSERT((is_addable<int>::value));\n+STATIC_ASSERT((is_addable<int, long>::value));\n+STATIC_ASSERT((is_addable<X>::value));\n+STATIC_ASSERT((is_addable<int*, int>::value));\n+STATIC_ASSERT((!is_addable<int*>::value));\n+STATIC_ASSERT((is_addable<X, Y>::value));\n+STATIC_ASSERT((!is_addable<Y>::value));\n+\n+// is_subtractable\n+DEFINE_INFIX_BINARY_TRAIT(is_subtractable, -);\n+X operator-(X, X);\n+X operator-(X, Y);\n+STATIC_ASSERT((is_subtractable<int>::value));\n+STATIC_ASSERT((is_subtractable<int, long>::value));\n+STATIC_ASSERT((is_subtractable<X>::value));\n+STATIC_ASSERT((is_subtractable<int*, int>::value));\n+STATIC_ASSERT((is_subtractable<int*>::value));\n+STATIC_ASSERT((is_subtractable<X, Y>::value));\n+STATIC_ASSERT((!is_subtractable<Y>::value));\n+STATIC_ASSERT((!is_subtractable<int X::*>::value));\n+\n+// is_multiplicable\n+DEFINE_INFIX_BINARY_TRAIT(is_multiplicable, *);\n+X operator*(X, X);\n+X operator*(X, Y);\n+STATIC_ASSERT((is_multiplicable<int>::value));\n+STATIC_ASSERT((is_multiplicable<int, long>::value));\n+STATIC_ASSERT((is_multiplicable<X>::value));\n+STATIC_ASSERT((!is_multiplicable<int*, int>::value));\n+STATIC_ASSERT((!is_multiplicable<int*>::value));\n+STATIC_ASSERT((is_multiplicable<X, Y>::value));\n+STATIC_ASSERT((!is_multiplicable<Y>::value));\n+STATIC_ASSERT((!is_multiplicable<int X::*>::value));\n+\n+// is_divisible\n+DEFINE_INFIX_BINARY_TRAIT(is_divisible, /);\n+X operator/(X, X);\n+X operator/(X, Y);\n+STATIC_ASSERT((is_divisible<int>::value));\n+STATIC_ASSERT((is_divisible<int, long>::value));\n+STATIC_ASSERT((is_divisible<X>::value));\n+STATIC_ASSERT((!is_divisible<int*, int>::value));\n+STATIC_ASSERT((!is_divisible<int*>::value));\n+STATIC_ASSERT((is_divisible<X, Y>::value));\n+STATIC_ASSERT((!is_divisible<Y>::value));\n+STATIC_ASSERT((!is_divisible<int X::*>::value));\n+\n+// has_remainder\n+DEFINE_INFIX_BINARY_TRAIT(has_remainder, %);\n+X operator%(X, X);\n+X operator%(X, Y);\n+STATIC_ASSERT((has_remainder<int>::value));\n+STATIC_ASSERT((has_remainder<int, long>::value));\n+STATIC_ASSERT((!has_remainder<float>::value));\n+STATIC_ASSERT((has_remainder<X>::value));\n+STATIC_ASSERT((!has_remainder<int*, int>::value));\n+STATIC_ASSERT((!has_remainder<int*>::value));\n+STATIC_ASSERT((has_remainder<X, Y>::value));\n+STATIC_ASSERT((!has_remainder<Y>::value));\n+STATIC_ASSERT((!has_remainder<int X::*>::value));\n+\n+// has_xor\n+DEFINE_INFIX_BINARY_TRAIT(has_xor, ^);\n+X operator^(X, X);\n+X operator^(X, Y);\n+STATIC_ASSERT((has_xor<int>::value));\n+STATIC_ASSERT((has_xor<int, long>::value));\n+STATIC_ASSERT((!has_xor<float>::value));\n+STATIC_ASSERT((has_xor<X>::value));\n+STATIC_ASSERT((!has_xor<int*, int>::value));\n+STATIC_ASSERT((!has_xor<int*>::value));\n+STATIC_ASSERT((has_xor<X, Y>::value));\n+STATIC_ASSERT((!has_xor<Y>::value));\n+STATIC_ASSERT((!has_xor<int X::*>::value));\n+\n+// has_bitand\n+DEFINE_INFIX_BINARY_TRAIT(has_bitand, &);\n+X operator&(X, X);\n+X operator&(X, Y);\n+STATIC_ASSERT((has_bitand<int>::value));\n+STATIC_ASSERT((has_bitand<int, long>::value));\n+STATIC_ASSERT((!has_bitand<float>::value));\n+STATIC_ASSERT((has_bitand<X>::value));\n+STATIC_ASSERT((!has_bitand<int*, int>::value));\n+STATIC_ASSERT((!has_bitand<int*>::value));\n+STATIC_ASSERT((has_bitand<X, Y>::value));\n+STATIC_ASSERT((!has_bitand<Y>::value));\n+STATIC_ASSERT((!has_bitand<int X::*>::value));\n+\n+// has_bitor\n+DEFINE_INFIX_BINARY_TRAIT(has_bitor, |);\n+X operator|(X, X);\n+X operator|(X, Y);\n+STATIC_ASSERT((has_bitor<int>::value));\n+STATIC_ASSERT((has_bitor<int, long>::value));\n+STATIC_ASSERT((!has_bitor<float>::value));\n+STATIC_ASSERT((has_bitor<X>::value));\n+STATIC_ASSERT((!has_bitor<int*, int>::value));\n+STATIC_ASSERT((!has_bitor<int*>::value));\n+STATIC_ASSERT((has_bitor<X, Y>::value));\n+STATIC_ASSERT((!has_bitor<Y>::value));\n+STATIC_ASSERT((!has_bitor<int X::*>::value));\n+\n+// has_left_shift\n+DEFINE_INFIX_BINARY_TRAIT(has_left_shift, <<);\n+X operator<<(X, X);\n+X operator<<(X, Y);\n+STATIC_ASSERT((has_left_shift<int>::value));\n+STATIC_ASSERT((has_left_shift<int, long>::value));\n+STATIC_ASSERT((!has_left_shift<float>::value));\n+STATIC_ASSERT((has_left_shift<X>::value));\n+STATIC_ASSERT((!has_left_shift<int*, int>::value));\n+STATIC_ASSERT((!has_left_shift<int*>::value));\n+STATIC_ASSERT((has_left_shift<X, Y>::value));\n+STATIC_ASSERT((!has_left_shift<Y>::value));\n+STATIC_ASSERT((!has_left_shift<int X::*>::value));\n+\n+// has_right_shift\n+DEFINE_INFIX_BINARY_TRAIT(has_right_shift, >>);\n+X operator>>(X, X);\n+X operator>>(X, Y);\n+STATIC_ASSERT((has_right_shift<int>::value));\n+STATIC_ASSERT((has_right_shift<int, long>::value));\n+STATIC_ASSERT((!has_right_shift<float>::value));\n+STATIC_ASSERT((has_right_shift<X>::value));\n+STATIC_ASSERT((!has_right_shift<int*, int>::value));\n+STATIC_ASSERT((!has_right_shift<int*>::value));\n+STATIC_ASSERT((has_right_shift<X, Y>::value));\n+STATIC_ASSERT((!has_right_shift<Y>::value));\n+STATIC_ASSERT((!has_right_shift<int X::*>::value));\n+\n+// can_subscript\n+STATIC_ASSERT((can_subscript<int*, int>::value));\n+STATIC_ASSERT((can_subscript<int, int*>::value));\n+STATIC_ASSERT((can_subscript<int(&)[7], int>::value));\n+STATIC_ASSERT((can_subscript<int, int(&)[7]>::value));\n+STATIC_ASSERT((!can_subscript<X, Y>::value));\n+STATIC_ASSERT((can_subscript<Y, X>::value));"}, {"sha": "2ad68dc5dbf0496b2b25714826a9e52b3db7b93d", "filename": "gcc/testsuite/g++.dg/template/sfinae8.C", "status": "added", "additions": 182, "deletions": 0, "changes": 182, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ade1ed2c08bf2f327ee24afc57bc263fd90e6e1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fsfinae8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ade1ed2c08bf2f327ee24afc57bc263fd90e6e1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fsfinae8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fsfinae8.C?ref=5ade1ed2c08bf2f327ee24afc57bc263fd90e6e1", "patch": "@@ -0,0 +1,182 @@\n+// DR 339\n+//\n+// Test of the use of various boolean binary operators with SFINAE\n+\n+// Boilerplate helpers\n+typedef char yes_type;\n+struct no_type { char data[2]; };\n+\n+template<typename T> T create_a();\n+template<typename T> struct type { };\n+\n+template<bool, typename T = void> struct enable_if { typedef T type; };\n+template<typename T> struct enable_if<false, T> { };\n+\n+#define JOIN( X, Y ) DO_JOIN( X, Y )\n+#define DO_JOIN( X, Y ) DO_JOIN2(X,Y)\n+#define DO_JOIN2( X, Y ) X##Y\n+\n+bool accepts_bool(bool);\n+\n+#define DEFINE_BINARY_PREDICATE_TRAIT(Name,Op)\t\t\t\t\\\n+template<typename T, typename U>\t\t\t\t\t\\\n+  typename enable_if<sizeof(accepts_bool(create_a<T>() Op create_a<U>())), \\\n+\t\t     yes_type>::type\t\t\t\t\t\\\n+  JOIN(check_,Name)(type<T>, type<U>);\t\t                        \\\n+\t\t\t\t\t\t\t\t\t\\\n+no_type JOIN(check_,Name)(...);\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+template<typename T, typename U = T>\t\t\t\t\t\\\n+struct Name\t\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  static const bool value =\t\t\t\t\t\t\\\n+    (sizeof(JOIN(check_,Name)(type<T>(), type<U>())) == sizeof(yes_type)); \\\n+}\n+\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+#  define STATIC_ASSERT(Expr) static_assert(Expr, #Expr)\n+#else\n+#  define STATIC_ASSERT(Expr) int JOIN(a,__LINE__)[Expr? 1 : -1]\n+#endif\n+\n+struct X { };\n+struct Y { };\n+\n+struct convertible_to_bool { \n+  operator int convertible_to_bool::* (); \n+};\n+\n+struct not_convertible_to_bool { };\n+\n+// is_less_than_comparable\n+DEFINE_BINARY_PREDICATE_TRAIT(is_less_than_comparable,<);\n+bool                    operator<(X, X);\n+convertible_to_bool     operator<(X, Y);\n+not_convertible_to_bool operator<(Y, X);\n+\n+STATIC_ASSERT((is_less_than_comparable<int>::value));\n+STATIC_ASSERT((is_less_than_comparable<int, long>::value));\n+STATIC_ASSERT((is_less_than_comparable<int*>::value));\n+STATIC_ASSERT((is_less_than_comparable<X>::value));\n+STATIC_ASSERT((is_less_than_comparable<X, Y>::value));\n+STATIC_ASSERT((!is_less_than_comparable<Y, X>::value));\n+STATIC_ASSERT((!is_less_than_comparable<Y>::value));\n+\n+// is_less_equal_comparable\n+DEFINE_BINARY_PREDICATE_TRAIT(is_less_equal_comparable,<=);\n+bool                    operator<=(X, X);\n+convertible_to_bool     operator<=(X, Y);\n+not_convertible_to_bool operator<=(Y, X);\n+\n+STATIC_ASSERT((is_less_equal_comparable<int>::value));\n+STATIC_ASSERT((is_less_equal_comparable<int, long>::value));\n+STATIC_ASSERT((is_less_equal_comparable<int*>::value));\n+STATIC_ASSERT((is_less_equal_comparable<X>::value));\n+STATIC_ASSERT((is_less_equal_comparable<X, Y>::value));\n+STATIC_ASSERT((!is_less_equal_comparable<Y, X>::value));\n+STATIC_ASSERT((!is_less_equal_comparable<Y>::value));\n+\n+// is_greater_than_comparable\n+DEFINE_BINARY_PREDICATE_TRAIT(is_greater_than_comparable,>);\n+bool                    operator>(X, X);\n+convertible_to_bool     operator>(X, Y);\n+not_convertible_to_bool operator>(Y, X);\n+\n+STATIC_ASSERT((is_greater_than_comparable<int>::value));\n+STATIC_ASSERT((is_greater_than_comparable<int, long>::value));\n+STATIC_ASSERT((is_greater_than_comparable<int*>::value));\n+STATIC_ASSERT((is_greater_than_comparable<X>::value));\n+STATIC_ASSERT((is_greater_than_comparable<X, Y>::value));\n+STATIC_ASSERT((!is_greater_than_comparable<Y, X>::value));\n+STATIC_ASSERT((!is_greater_than_comparable<Y>::value));\n+\n+// is_greater_equal_comparable\n+DEFINE_BINARY_PREDICATE_TRAIT(is_greater_equal_comparable,>=);\n+bool                    operator>=(X, X);\n+convertible_to_bool     operator>=(X, Y);\n+not_convertible_to_bool operator>=(Y, X);\n+\n+STATIC_ASSERT((is_greater_equal_comparable<int>::value));\n+STATIC_ASSERT((is_greater_equal_comparable<int, long>::value));\n+STATIC_ASSERT((is_greater_equal_comparable<int*>::value));\n+STATIC_ASSERT((is_greater_equal_comparable<X>::value));\n+STATIC_ASSERT((is_greater_equal_comparable<X, Y>::value));\n+STATIC_ASSERT((!is_greater_equal_comparable<Y, X>::value));\n+STATIC_ASSERT((!is_greater_equal_comparable<Y>::value));\n+\n+// is_equality_comparable\n+struct Z : X { };\n+DEFINE_BINARY_PREDICATE_TRAIT(is_equality_comparable,==);\n+bool                    operator==(X, X);\n+convertible_to_bool     operator==(X, Y);\n+not_convertible_to_bool operator==(Y, X);\n+\n+STATIC_ASSERT((is_equality_comparable<int>::value));\n+STATIC_ASSERT((is_equality_comparable<int, long>::value));\n+STATIC_ASSERT((is_equality_comparable<int*>::value));\n+STATIC_ASSERT((is_equality_comparable<X>::value));\n+STATIC_ASSERT((is_equality_comparable<X, Y>::value));\n+STATIC_ASSERT((!is_equality_comparable<Y, X>::value));\n+STATIC_ASSERT((!is_equality_comparable<Y>::value));\n+STATIC_ASSERT((is_equality_comparable<int X::*>::value));\n+STATIC_ASSERT((!is_equality_comparable<int X::*, int Y::*>::value));\n+STATIC_ASSERT((is_equality_comparable<int*, float*>::value));\n+STATIC_ASSERT((is_equality_comparable<X*, Z*>::value));\n+STATIC_ASSERT((!is_equality_comparable<X*, Y*>::value));\n+\n+// is_not_equal_comparable\n+DEFINE_BINARY_PREDICATE_TRAIT(is_not_equal_comparable,!=);\n+bool                    operator!=(X, X);\n+convertible_to_bool     operator!=(X, Y);\n+not_convertible_to_bool operator!=(Y, X);\n+\n+STATIC_ASSERT((is_not_equal_comparable<int>::value));\n+STATIC_ASSERT((is_not_equal_comparable<int, long>::value));\n+STATIC_ASSERT((is_not_equal_comparable<int*>::value));\n+STATIC_ASSERT((is_not_equal_comparable<X>::value));\n+STATIC_ASSERT((is_not_equal_comparable<X, Y>::value));\n+STATIC_ASSERT((!is_not_equal_comparable<Y, X>::value));\n+STATIC_ASSERT((!is_not_equal_comparable<Y>::value));\n+STATIC_ASSERT((is_not_equal_comparable<int X::*>::value));\n+STATIC_ASSERT((!is_not_equal_comparable<int X::*, int Y::*>::value));\n+STATIC_ASSERT((is_not_equal_comparable<int*, float*>::value));\n+STATIC_ASSERT((is_not_equal_comparable<X*, Z*>::value));\n+STATIC_ASSERT((!is_not_equal_comparable<X*, Y*>::value));\n+\n+// has_logical_and\n+DEFINE_BINARY_PREDICATE_TRAIT(has_logical_and,&&);\n+bool                    operator&&(X, X);\n+convertible_to_bool     operator&&(X, Y);\n+not_convertible_to_bool operator&&(Y, X);\n+\n+STATIC_ASSERT((has_logical_and<int>::value));\n+STATIC_ASSERT((has_logical_and<int, long>::value));\n+STATIC_ASSERT((has_logical_and<int*>::value));\n+STATIC_ASSERT((has_logical_and<X>::value));\n+STATIC_ASSERT((has_logical_and<X, Y>::value));\n+STATIC_ASSERT((!has_logical_and<Y, X>::value));\n+STATIC_ASSERT((!has_logical_and<Y>::value));\n+STATIC_ASSERT((has_logical_and<int X::*>::value));\n+STATIC_ASSERT((has_logical_and<int X::*, int Y::*>::value));\n+STATIC_ASSERT((has_logical_and<int*, float*>::value));\n+STATIC_ASSERT((has_logical_and<X*, Z*>::value));\n+STATIC_ASSERT((has_logical_and<X*, Y*>::value));\n+\n+// has_logical_or\n+DEFINE_BINARY_PREDICATE_TRAIT(has_logical_or,||);\n+bool                    operator||(X, X);\n+convertible_to_bool     operator||(X, Y);\n+not_convertible_to_bool operator||(Y, X);\n+\n+STATIC_ASSERT((has_logical_or<int>::value));\n+STATIC_ASSERT((has_logical_or<int, long>::value));\n+STATIC_ASSERT((has_logical_or<int*>::value));\n+STATIC_ASSERT((has_logical_or<X>::value));\n+STATIC_ASSERT((has_logical_or<X, Y>::value));\n+STATIC_ASSERT((!has_logical_or<Y, X>::value));\n+STATIC_ASSERT((!has_logical_or<Y>::value));\n+STATIC_ASSERT((has_logical_or<int X::*>::value));\n+STATIC_ASSERT((has_logical_or<int X::*, int Y::*>::value));\n+STATIC_ASSERT((has_logical_or<int*, float*>::value));\n+STATIC_ASSERT((has_logical_or<X*, Z*>::value));\n+STATIC_ASSERT((has_logical_or<X*, Y*>::value));"}, {"sha": "4e27ff61bd5eb490cd9ce48f1b196bce4ac5d462", "filename": "gcc/testsuite/g++.dg/template/sfinae9.C", "status": "added", "additions": 207, "deletions": 0, "changes": 207, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ade1ed2c08bf2f327ee24afc57bc263fd90e6e1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fsfinae9.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ade1ed2c08bf2f327ee24afc57bc263fd90e6e1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fsfinae9.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fsfinae9.C?ref=5ade1ed2c08bf2f327ee24afc57bc263fd90e6e1", "patch": "@@ -0,0 +1,207 @@\n+// DR 339\n+//\n+// Test of the use of various assignment operators with SFINAE\n+\n+// Boilerplate helpers\n+typedef char yes_type;\n+struct no_type { char data[2]; };\n+\n+template<typename T> T create_a();\n+template<typename T> struct type { };\n+\n+template<bool, typename T = void> struct enable_if { typedef T type; };\n+template<typename T> struct enable_if<false, T> { };\n+\n+#define JOIN( X, Y ) DO_JOIN( X, Y )\n+#define DO_JOIN( X, Y ) DO_JOIN2(X,Y)\n+#define DO_JOIN2( X, Y ) X##Y\n+\n+#define DEFINE_INFIX_BINARY_TRAIT(Name,Op)\t\t\t\t\\\n+template<typename T, typename U>\t\t\t\t\t\\\n+  typename enable_if<(sizeof(create_a<T>() Op create_a<U>(), 1) > 0),\t\\\n+\t\t     yes_type>::type\t\t\t\t\t\\\n+  JOIN(check_,Name)(type<T>, type<U>);\t\t                        \\\n+\t\t\t\t\t\t\t\t\t\\\n+no_type JOIN(check_,Name)(...);\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+template<typename T, typename U = T>\t\t\t\t\t\\\n+struct Name\t\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  static const bool value =\t\t\t\t\t\t\\\n+    (sizeof(JOIN(check_,Name)(type<T&>(), type<U>())) == sizeof(yes_type)); \\\n+}\n+\n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+#  define STATIC_ASSERT(Expr) static_assert(Expr, #Expr)\n+#else\n+#  define STATIC_ASSERT(Expr) int JOIN(a,__LINE__)[Expr? 1 : -1]\n+#endif\n+\n+struct Y { \n+  Y& operator=(Y&);\n+};\n+\n+struct X { \n+  X& operator=(Y);\n+  X& operator+=(X);\n+  X& operator-=(X);\n+  X& operator*=(X);\n+  X& operator/=(X);\n+  X& operator%=(X);\n+  X& operator^=(X);\n+  X& operator&=(X);\n+  X& operator|=(X);\n+  X& operator<<=(X);\n+  X& operator>>=(X);\n+};\n+struct Z { };\n+\n+// is_assignable\n+DEFINE_INFIX_BINARY_TRAIT(is_assignable, =);\n+STATIC_ASSERT((is_assignable<int>::value));\n+STATIC_ASSERT((is_assignable<int, long>::value));\n+STATIC_ASSERT((is_assignable<X>::value));\n+STATIC_ASSERT((!is_assignable<int*, int>::value));\n+STATIC_ASSERT((is_assignable<int*>::value));\n+STATIC_ASSERT((is_assignable<X, Y>::value));\n+STATIC_ASSERT((!is_assignable<X, Z>::value));\n+STATIC_ASSERT((!is_assignable<Y>::value));\n+STATIC_ASSERT((!is_assignable<const int, long>::value));\n+\n+// has_plus_assign\n+DEFINE_INFIX_BINARY_TRAIT(has_plus_assign, +=);\n+X& operator+=(X&, Y);\n+STATIC_ASSERT((has_plus_assign<int>::value));\n+STATIC_ASSERT((has_plus_assign<int, long>::value));\n+STATIC_ASSERT((has_plus_assign<X>::value));\n+STATIC_ASSERT((has_plus_assign<int*, int>::value));\n+STATIC_ASSERT((!has_plus_assign<int*>::value));\n+STATIC_ASSERT((has_plus_assign<X, Y>::value));\n+STATIC_ASSERT((!has_plus_assign<X, Z>::value));\n+STATIC_ASSERT((!has_plus_assign<Y>::value));\n+STATIC_ASSERT((!has_plus_assign<const int, long>::value));\n+\n+// has_minus_assign\n+DEFINE_INFIX_BINARY_TRAIT(has_minus_assign, -=);\n+X& operator-=(X&, Y);\n+STATIC_ASSERT((has_minus_assign<int>::value));\n+STATIC_ASSERT((has_minus_assign<int, long>::value));\n+STATIC_ASSERT((has_minus_assign<X>::value));\n+STATIC_ASSERT((has_minus_assign<int*, int>::value));\n+STATIC_ASSERT((!has_minus_assign<int*>::value));\n+STATIC_ASSERT((has_minus_assign<X, Y>::value));\n+STATIC_ASSERT((!has_minus_assign<X, Z>::value));\n+STATIC_ASSERT((!has_minus_assign<Y>::value));\n+STATIC_ASSERT((!has_minus_assign<int X::*>::value));\n+STATIC_ASSERT((!has_minus_assign<const int, long>::value));\n+\n+// has_multiply_assign\n+DEFINE_INFIX_BINARY_TRAIT(has_multiply_assign, *=);\n+X& operator*=(X&, Y);\n+STATIC_ASSERT((has_multiply_assign<int>::value));\n+STATIC_ASSERT((has_multiply_assign<int, long>::value));\n+STATIC_ASSERT((has_multiply_assign<X>::value));\n+STATIC_ASSERT((!has_multiply_assign<int*, int>::value));\n+STATIC_ASSERT((!has_multiply_assign<int*>::value));\n+STATIC_ASSERT((has_multiply_assign<X, Y>::value));\n+STATIC_ASSERT((!has_multiply_assign<X, Z>::value));\n+STATIC_ASSERT((!has_multiply_assign<Y>::value));\n+STATIC_ASSERT((!has_multiply_assign<int X::*>::value));\n+STATIC_ASSERT((!has_multiply_assign<const int, long>::value));\n+\n+// has_divide_assign\n+DEFINE_INFIX_BINARY_TRAIT(has_divide_assign, /=);\n+X& operator/=(X&, Y);\n+STATIC_ASSERT((has_divide_assign<int>::value));\n+STATIC_ASSERT((has_divide_assign<int, long>::value));\n+STATIC_ASSERT((has_divide_assign<X>::value));\n+STATIC_ASSERT((!has_divide_assign<int*, int>::value));\n+STATIC_ASSERT((!has_divide_assign<int*>::value));\n+STATIC_ASSERT((has_divide_assign<X, Y>::value));\n+STATIC_ASSERT((!has_divide_assign<X, Z>::value));\n+STATIC_ASSERT((!has_divide_assign<Y>::value));\n+STATIC_ASSERT((!has_divide_assign<int X::*>::value));\n+\n+// has_remainder_assign\n+DEFINE_INFIX_BINARY_TRAIT(has_remainder_assign, %=);\n+X& operator%=(X&, Y);\n+STATIC_ASSERT((has_remainder_assign<int>::value));\n+STATIC_ASSERT((has_remainder_assign<int, long>::value));\n+STATIC_ASSERT((!has_remainder_assign<float>::value));\n+STATIC_ASSERT((has_remainder_assign<X>::value));\n+STATIC_ASSERT((!has_remainder_assign<int*, int>::value));\n+STATIC_ASSERT((!has_remainder_assign<int*>::value));\n+STATIC_ASSERT((has_remainder_assign<X, Y>::value));\n+STATIC_ASSERT((!has_remainder_assign<X, Z>::value));\n+STATIC_ASSERT((!has_remainder_assign<Y>::value));\n+STATIC_ASSERT((!has_remainder_assign<int X::*>::value));\n+\n+// has_xor_assign\n+DEFINE_INFIX_BINARY_TRAIT(has_xor_assign, ^=);\n+X& operator^=(X&, Y);\n+STATIC_ASSERT((has_xor_assign<int>::value));\n+STATIC_ASSERT((has_xor_assign<int, long>::value));\n+STATIC_ASSERT((!has_xor_assign<float>::value));\n+STATIC_ASSERT((has_xor_assign<X>::value));\n+STATIC_ASSERT((!has_xor_assign<int*, int>::value));\n+STATIC_ASSERT((!has_xor_assign<int*>::value));\n+STATIC_ASSERT((has_xor_assign<X, Y>::value));\n+STATIC_ASSERT((!has_xor_assign<X, Z>::value));\n+STATIC_ASSERT((!has_xor_assign<Y>::value));\n+STATIC_ASSERT((!has_xor_assign<int X::*>::value));\n+\n+// has_bitand_assign\n+DEFINE_INFIX_BINARY_TRAIT(has_bitand_assign, &=);\n+X& operator&=(X&, Y);\n+STATIC_ASSERT((has_bitand_assign<int>::value));\n+STATIC_ASSERT((has_bitand_assign<int, long>::value));\n+STATIC_ASSERT((!has_bitand_assign<float>::value));\n+STATIC_ASSERT((has_bitand_assign<X>::value));\n+STATIC_ASSERT((!has_bitand_assign<int*, int>::value));\n+STATIC_ASSERT((!has_bitand_assign<int*>::value));\n+STATIC_ASSERT((has_bitand_assign<X, Y>::value));\n+STATIC_ASSERT((!has_bitand_assign<X, Z>::value));\n+STATIC_ASSERT((!has_bitand_assign<Y>::value));\n+STATIC_ASSERT((!has_bitand_assign<int X::*>::value));\n+\n+// has_bitor_assign\n+DEFINE_INFIX_BINARY_TRAIT(has_bitor_assign, |=);\n+X& operator|=(X&, Y);\n+STATIC_ASSERT((has_bitor_assign<int>::value));\n+STATIC_ASSERT((has_bitor_assign<int, long>::value));\n+STATIC_ASSERT((!has_bitor_assign<float>::value));\n+STATIC_ASSERT((has_bitor_assign<X>::value));\n+STATIC_ASSERT((!has_bitor_assign<int*, int>::value));\n+STATIC_ASSERT((!has_bitor_assign<int*>::value));\n+STATIC_ASSERT((has_bitor_assign<X, Y>::value));\n+STATIC_ASSERT((!has_bitor_assign<X, Z>::value));\n+STATIC_ASSERT((!has_bitor_assign<Y>::value));\n+STATIC_ASSERT((!has_bitor_assign<int X::*>::value));\n+\n+// has_left_shift_assign\n+DEFINE_INFIX_BINARY_TRAIT(has_left_shift_assign, <<=);\n+X& operator<<=(X&, Y);\n+STATIC_ASSERT((has_left_shift_assign<int>::value));\n+STATIC_ASSERT((has_left_shift_assign<int, long>::value));\n+STATIC_ASSERT((!has_left_shift_assign<float>::value));\n+STATIC_ASSERT((has_left_shift_assign<X>::value));\n+STATIC_ASSERT((!has_left_shift_assign<int*, int>::value));\n+STATIC_ASSERT((!has_left_shift_assign<int*>::value));\n+STATIC_ASSERT((has_left_shift_assign<X, Y>::value));\n+STATIC_ASSERT((!has_left_shift_assign<X, Z>::value));\n+STATIC_ASSERT((!has_left_shift_assign<Y>::value));\n+STATIC_ASSERT((!has_left_shift_assign<int X::*>::value));\n+\n+// has_right_shift_assign\n+DEFINE_INFIX_BINARY_TRAIT(has_right_shift_assign, >>=);\n+X& operator>>=(X&, Y);\n+STATIC_ASSERT((has_right_shift_assign<int>::value));\n+STATIC_ASSERT((has_right_shift_assign<int, long>::value));\n+STATIC_ASSERT((!has_right_shift_assign<float>::value));\n+STATIC_ASSERT((has_right_shift_assign<X>::value));\n+STATIC_ASSERT((!has_right_shift_assign<int*, int>::value));\n+STATIC_ASSERT((!has_right_shift_assign<int*>::value));\n+STATIC_ASSERT((has_right_shift_assign<X, Y>::value));\n+STATIC_ASSERT((!has_right_shift_assign<X, Z>::value));\n+STATIC_ASSERT((!has_right_shift_assign<Y>::value));\n+STATIC_ASSERT((!has_right_shift_assign<int X::*>::value));"}]}