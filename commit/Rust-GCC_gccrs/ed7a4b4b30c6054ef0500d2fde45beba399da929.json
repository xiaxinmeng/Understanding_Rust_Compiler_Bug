{"sha": "ed7a4b4b30c6054ef0500d2fde45beba399da929", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWQ3YTRiNGIzMGM2MDU0ZWYwNTAwZDJmZGU0NWJlYmEzOTlkYTkyOQ==", "commit": {"author": {"name": "Kaveh R. Ghazi", "email": "ghazi@caip.rutgers.edu", "date": "2007-08-14T04:44:35Z"}, "committer": {"name": "Kaveh Ghazi", "email": "ghazi@gcc.gnu.org", "date": "2007-08-14T04:44:35Z"}, "message": "alias.c (rtx_equal_for_memref_p): Constify.\n\n\t* alias.c (rtx_equal_for_memref_p): Constify.\n\t* basic-block.h (const_edge, const_basic_block): New.\n\t(reg_set_to_hard_reg_set, dfs_enumerate_from, single_succ_p,\n\tsingle_pred_p, single_succ_edge, single_pred_edge, single_succ,\n\tsingle_pred, maybe_hot_bb_p, probably_cold_bb_p,\n\tprobably_never_executed_bb_p, edge_probability_reliable_p,\n\tbr_prob_note_reliable_p, forwarder_block_p, flow_nodes_print,\n\tinside_basic_block_p, control_flow_insn_p, dominated_by_p):\n\tLikewise.\n\t* bb-reorder.c (better_edge_p, push_to_next_round_p): Likewise.\n\t* bt-load.c (basic_block_freq, insn_sets_btr_p, can_move_up):\n\tLikewise.\n\t* cfganal.c (flow_active_insn_p, forwarder_block_p,\n\tflow_nodes_print, dfs_enumerate_from): Likewise.\n\t* cfgbuild.c (count_basic_blocks, inside_basic_block_p,\n\tcontrol_flow_insn_p, count_basic_blocks): Likewise.\n\t* cfgloop.c (flow_bb_inside_loop_p, glb_enum_p,\n\tget_loop_body_with_size, loop_exit_edge_p): Likewise.\n\t* cfgloop.h (flow_bb_inside_loop_p, num_loop_insns,\n\taverage_num_loop_insns, loop_exit_edge_p,\n\tjust_once_each_iteration_p, can_duplicate_loop_p): Likewise.\n\t* cfgloopanal.c (just_once_each_iteration_p, num_loop_insns,\n\taverage_num_loop_insns, seq_cost): Likewise.\n\t* cfgloopmanip.c (rpe_enum_p, can_duplicate_loop_p): Likewise.\n\t* dominance.c (dominated_by_p): Likewise.\n\t* emit-rtl.c (validate_subreg): Likewise.\n\t* except.c (can_throw_internal, can_throw_external): Likewise.\n\t* except.h (can_throw_internal, can_throw_external): Likewise.\n\t* gcse.c (gcse_constant_p, oprs_unchanged_p, oprs_anticipatable_p,\n\toprs_available_p, hash_expr, expr_equiv_p, oprs_not_set_p,\n\tcompute_transp, load_killed_in_block_p, reg_killed_on_edge,\n\tsimple_mem, store_ops_ok, load_kills_store, find_loads,\n\tstore_killed_in_insn, store_killed_after, store_killed_before,\n\tgcse_mem_operand, implicit_set_cond_p, store_killed_in_pat):\n\tLikewise.\n\t* ifcvt.c (count_bb_insns, cheap_bb_rtx_cost_p, noce_operand_ok,\n\tnoce_mem_write_may_trap_or_fault_p): Likewise.\n\t* pointer-set.c (pointer_set_contains, pointer_map_contains):\n\tLikewise.\n\t* pointer-set.h (pointer_set_contains, pointer_map_contains):\n\tLikewise.\n\t* predict.c (can_predict_insn_p, maybe_hot_bb_p,\n\tprobably_cold_bb_p, probably_never_executed_bb_p,\n\tedge_probability_reliable_p, br_prob_note_reliable_p,\n\tcan_predict_insn_p): Likewise.\n\t* regclass.c (reg_set_to_hard_reg_set): Likewise.\n\t* resource.c (return_insn_p): Likewise.\n\t* rtl.h (reg_set_between_p, reg_set_p, validate_subreg):\n\tLikewise.\n\t* rtlanal.c (reg_set_between_p, reg_set_p): Likewise.\n\t* tracer.c (count_insns, ignore_bb_p, better_p): Likewise.\n\t* tree-cfg.c (verify_gimple_unary_expr, verify_gimple_binary_expr,\n\tverify_gimple_modify_stmt): Likewise.\n\t* tree-chrec.c (is_not_constant_evolution,\n\tis_multivariate_chrec_rec, is_multivariate_chrec,\n\tchrec_contains_symbols, chrec_contains_undetermined,\n\ttree_contains_chrecs, evolution_function_is_affine_multivariate_p,\n\tevolution_function_is_univariate_p, avoid_arithmetics_in_type_p,\n\teq_evolutions_p, scev_direction): Likewise.\n\t* tree-chrec.h (automatically_generated_chrec_p, tree_is_chrec,\n\teq_evolutions_p, is_multivariate_chrec, chrec_contains_symbols,\n\tchrec_contains_symbols_defined_in_loop,\n\tchrec_contains_undetermined, tree_contains_chrecs,\n\tevolution_function_is_affine_multivariate_p,\n\tevolution_function_is_univariate_p, chrec_zerop,\n\tevolution_function_is_constant_p, evolution_function_is_affine_p,\n\tevolution_function_is_affine_or_constant_p,\n\ttree_does_not_contain_chrecs, chrec_type): Likewise.\n\t* tree-data-ref.c (tree_fold_divides_p,\n\tobject_address_invariant_in_loop_p, dr_may_alias_p,\n\tziv_subscript_p, siv_subscript_p, gcd_of_steps_may_divide_p,\n\tsame_access_functions, constant_access_functions,\n\taccess_functions_are_affine_or_constant_p, find_vertex_for_stmt):\n\tLikewise.\n\t* tree-flow.h (scev_direction): Likewise.\n\t* tree-gimple.c (is_gimple_stmt): Likewise.\n\t* tree-outof-ssa.c (identical_copies_p, identical_stmt_lists_p):\n\tLikewise.\n\t* tree-pretty-print.c (op_prio): Likewise.\n\t* tree-scalar-evolution.c (chrec_contains_symbols_defined_in_loop,\n\tanalyzable_condition, backedge_phi_arg_p): Likewise.\n\t* tree-scalar-evolution.h (get_chrec_loop): Likewise.\n\t* tree-ssa-operands.c (get_name_decl, operand_build_cmp): Likewise.\n\t* tree-ssa-threadupdate.c (dbds_continue_enumeration_p):\n\tLikewise.\n\nFrom-SVN: r127404", "tree": {"sha": "7b0192b57f9e6b8e363378896d32e63902a1f759", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7b0192b57f9e6b8e363378896d32e63902a1f759"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ed7a4b4b30c6054ef0500d2fde45beba399da929", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed7a4b4b30c6054ef0500d2fde45beba399da929", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ed7a4b4b30c6054ef0500d2fde45beba399da929", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed7a4b4b30c6054ef0500d2fde45beba399da929/comments", "author": null, "committer": null, "parents": [{"sha": "a0b7c7aef6edd442c2f5496eccdabc35b98ff391", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a0b7c7aef6edd442c2f5496eccdabc35b98ff391", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a0b7c7aef6edd442c2f5496eccdabc35b98ff391"}], "stats": {"total": 507, "additions": 296, "deletions": 211}, "files": [{"sha": "76ec1d2404a675f4907d9859c7afbf156b89f93a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed7a4b4b30c6054ef0500d2fde45beba399da929/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed7a4b4b30c6054ef0500d2fde45beba399da929/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ed7a4b4b30c6054ef0500d2fde45beba399da929", "patch": "@@ -1,3 +1,91 @@\n+2007-08-14  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\t* alias.c (rtx_equal_for_memref_p): Constify.\n+\t* basic-block.h (const_edge, const_basic_block): New.\n+\t(reg_set_to_hard_reg_set, dfs_enumerate_from, single_succ_p,\n+\tsingle_pred_p, single_succ_edge, single_pred_edge, single_succ,\n+\tsingle_pred, maybe_hot_bb_p, probably_cold_bb_p,\n+\tprobably_never_executed_bb_p, edge_probability_reliable_p,\n+\tbr_prob_note_reliable_p, forwarder_block_p, flow_nodes_print,\n+\tinside_basic_block_p, control_flow_insn_p, dominated_by_p):\n+\tLikewise.\n+\t* bb-reorder.c (better_edge_p, push_to_next_round_p): Likewise.\n+\t* bt-load.c (basic_block_freq, insn_sets_btr_p, can_move_up):\n+\tLikewise.\n+\t* cfganal.c (flow_active_insn_p, forwarder_block_p,\n+\tflow_nodes_print, dfs_enumerate_from): Likewise.\n+\t* cfgbuild.c (count_basic_blocks, inside_basic_block_p,\n+\tcontrol_flow_insn_p, count_basic_blocks): Likewise.\n+\t* cfgloop.c (flow_bb_inside_loop_p, glb_enum_p,\n+\tget_loop_body_with_size, loop_exit_edge_p): Likewise.\n+\t* cfgloop.h (flow_bb_inside_loop_p, num_loop_insns,\n+\taverage_num_loop_insns, loop_exit_edge_p,\n+\tjust_once_each_iteration_p, can_duplicate_loop_p): Likewise.\n+\t* cfgloopanal.c (just_once_each_iteration_p, num_loop_insns,\n+\taverage_num_loop_insns, seq_cost): Likewise.\n+\t* cfgloopmanip.c (rpe_enum_p, can_duplicate_loop_p): Likewise.\n+\t* dominance.c (dominated_by_p): Likewise.\n+\t* emit-rtl.c (validate_subreg): Likewise.\n+\t* except.c (can_throw_internal, can_throw_external): Likewise.\n+\t* except.h (can_throw_internal, can_throw_external): Likewise.\n+\t* gcse.c (gcse_constant_p, oprs_unchanged_p, oprs_anticipatable_p,\n+\toprs_available_p, hash_expr, expr_equiv_p, oprs_not_set_p,\n+\tcompute_transp, load_killed_in_block_p, reg_killed_on_edge,\n+\tsimple_mem, store_ops_ok, load_kills_store, find_loads,\n+\tstore_killed_in_insn, store_killed_after, store_killed_before,\n+\tgcse_mem_operand, implicit_set_cond_p, store_killed_in_pat):\n+\tLikewise.\n+\t* ifcvt.c (count_bb_insns, cheap_bb_rtx_cost_p, noce_operand_ok,\n+\tnoce_mem_write_may_trap_or_fault_p): Likewise.\n+\t* pointer-set.c (pointer_set_contains, pointer_map_contains):\n+\tLikewise.\n+\t* pointer-set.h (pointer_set_contains, pointer_map_contains):\n+\tLikewise.\n+\t* predict.c (can_predict_insn_p, maybe_hot_bb_p,\n+\tprobably_cold_bb_p, probably_never_executed_bb_p,\n+\tedge_probability_reliable_p, br_prob_note_reliable_p,\n+\tcan_predict_insn_p): Likewise.\n+\t* regclass.c (reg_set_to_hard_reg_set): Likewise.\n+\t* resource.c (return_insn_p): Likewise.\n+\t* rtl.h (reg_set_between_p, reg_set_p, validate_subreg):\n+\tLikewise.\n+\t* rtlanal.c (reg_set_between_p, reg_set_p): Likewise.\n+\t* tracer.c (count_insns, ignore_bb_p, better_p): Likewise.\n+\t* tree-cfg.c (verify_gimple_unary_expr, verify_gimple_binary_expr,\n+\tverify_gimple_modify_stmt): Likewise.\n+\t* tree-chrec.c (is_not_constant_evolution,\n+\tis_multivariate_chrec_rec, is_multivariate_chrec,\n+\tchrec_contains_symbols, chrec_contains_undetermined,\n+\ttree_contains_chrecs, evolution_function_is_affine_multivariate_p,\n+\tevolution_function_is_univariate_p, avoid_arithmetics_in_type_p,\n+\teq_evolutions_p, scev_direction): Likewise.\n+\t* tree-chrec.h (automatically_generated_chrec_p, tree_is_chrec,\n+\teq_evolutions_p, is_multivariate_chrec, chrec_contains_symbols,\n+\tchrec_contains_symbols_defined_in_loop,\n+\tchrec_contains_undetermined, tree_contains_chrecs,\n+\tevolution_function_is_affine_multivariate_p,\n+\tevolution_function_is_univariate_p, chrec_zerop,\n+\tevolution_function_is_constant_p, evolution_function_is_affine_p,\n+\tevolution_function_is_affine_or_constant_p,\n+\ttree_does_not_contain_chrecs, chrec_type): Likewise.\n+\t* tree-data-ref.c (tree_fold_divides_p,\n+\tobject_address_invariant_in_loop_p, dr_may_alias_p,\n+\tziv_subscript_p, siv_subscript_p, gcd_of_steps_may_divide_p,\n+\tsame_access_functions, constant_access_functions,\n+\taccess_functions_are_affine_or_constant_p, find_vertex_for_stmt):\n+\tLikewise.\n+\t* tree-flow.h (scev_direction): Likewise.\n+\t* tree-gimple.c (is_gimple_stmt): Likewise.\n+\t* tree-outof-ssa.c (identical_copies_p, identical_stmt_lists_p):\n+\tLikewise.\n+\t* tree-pretty-print.c (op_prio): Likewise.\n+\t* tree-scalar-evolution.c (chrec_contains_symbols_defined_in_loop,\n+\tanalyzable_condition, backedge_phi_arg_p): Likewise.\n+\t* tree-scalar-evolution.h (get_chrec_loop): Likewise.\n+\t* tree-ssa-operands.c (get_name_decl, operand_build_cmp): Likewise.\n+\t* tree-ssa-threadupdate.c (dbds_continue_enumeration_p):\n+\tLikewise.\n+\n 2007-08-13  Dan Hipschman  <dsh@google.com>\n \n \tPR c/32953"}, {"sha": "36de66333d1de8acd9bb6ac895a79e3aea8fb5f6", "filename": "gcc/alias.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed7a4b4b30c6054ef0500d2fde45beba399da929/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed7a4b4b30c6054ef0500d2fde45beba399da929/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=ed7a4b4b30c6054ef0500d2fde45beba399da929", "patch": "@@ -148,7 +148,7 @@ struct alias_set_entry GTY(())\n };\n typedef struct alias_set_entry *alias_set_entry;\n \n-static int rtx_equal_for_memref_p (rtx, rtx);\n+static int rtx_equal_for_memref_p (const_rtx, const_rtx);\n static int memrefs_conflict_p (int, rtx, int, rtx, HOST_WIDE_INT);\n static void record_set (rtx, const_rtx, void *);\n static int base_alias_check (rtx, rtx, enum machine_mode,\n@@ -1192,7 +1192,7 @@ canon_rtx (rtx x)\n    different numbers are, in fact, equivalent.  */\n \n static int\n-rtx_equal_for_memref_p (rtx x, rtx y)\n+rtx_equal_for_memref_p (const_rtx x, const_rtx y)\n {\n   int i;\n   int j;"}, {"sha": "e8a9b66e1424aec656016f0404f7e38f5a33a9f5", "filename": "gcc/basic-block.h", "status": "modified", "additions": 21, "deletions": 19, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed7a4b4b30c6054ef0500d2fde45beba399da929/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed7a4b4b30c6054ef0500d2fde45beba399da929/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=ed7a4b4b30c6054ef0500d2fde45beba399da929", "patch": "@@ -80,7 +80,7 @@ typedef bitmap regset;\n #define REGNO_REG_SET_P(TO, REG) bitmap_bit_p (TO, REG)\n \n /* Copy the hard registers in a register set to the hard register set.  */\n-extern void reg_set_to_hard_reg_set (HARD_REG_SET *, bitmap);\n+extern void reg_set_to_hard_reg_set (HARD_REG_SET *, const_bitmap);\n #define REG_SET_TO_HARD_REG_SET(TO, FROM)\t\t\t\t\\\n do {\t\t\t\t\t\t\t\t\t\\\n   CLEAR_HARD_REG_SET (TO);\t\t\t\t\t\t\\\n@@ -143,6 +143,7 @@ struct edge_def GTY(())\n };\n \n typedef struct edge_def *edge;\n+typedef const struct edge_def *const_edge;\n DEF_VEC_P(edge);\n DEF_VEC_ALLOC_P(edge,gc);\n DEF_VEC_ALLOC_P(edge,heap);\n@@ -275,6 +276,7 @@ struct tree_bb_info GTY(())\n };\n \n typedef struct basic_block_def *basic_block;\n+typedef const struct basic_block_def *const_basic_block;\n \n DEF_VEC_P(basic_block);\n DEF_VEC_ALLOC_P(basic_block,gc);\n@@ -514,8 +516,8 @@ extern int post_order_compute (int *, bool, bool);\n extern int inverted_post_order_compute (int *);\n extern int pre_and_rev_post_order_compute (int *, int *, bool);\n extern int dfs_enumerate_from (basic_block, int,\n-\t\t\t       bool (*)(basic_block, void *),\n-\t\t\t       basic_block *, int, void *);\n+\t\t\t       bool (*)(const_basic_block, const void *),\n+\t\t\t       basic_block *, int, const void *);\n extern void compute_dominance_frontiers (bitmap *);\n extern void dump_bb_info (basic_block, bool, bool, int, const char *, FILE *);\n extern void dump_edge_info (FILE *, edge, int);\n@@ -607,15 +609,15 @@ struct edge_list\n /* Returns true if BB has precisely one successor.  */\n \n static inline bool\n-single_succ_p (basic_block bb)\n+single_succ_p (const_basic_block bb)\n {\n   return EDGE_COUNT (bb->succs) == 1;\n }\n \n /* Returns true if BB has precisely one predecessor.  */\n \n static inline bool\n-single_pred_p (basic_block bb)\n+single_pred_p (const_basic_block bb)\n {\n   return EDGE_COUNT (bb->preds) == 1;\n }\n@@ -624,7 +626,7 @@ single_pred_p (basic_block bb)\n    BB does not have exactly one successor.  */\n \n static inline edge\n-single_succ_edge (basic_block bb)\n+single_succ_edge (const_basic_block bb)\n {\n   gcc_assert (single_succ_p (bb));\n   return EDGE_SUCC (bb, 0);\n@@ -634,7 +636,7 @@ single_succ_edge (basic_block bb)\n    if BB does not have exactly one predecessor.  */\n \n static inline edge\n-single_pred_edge (basic_block bb)\n+single_pred_edge (const_basic_block bb)\n {\n   gcc_assert (single_pred_p (bb));\n   return EDGE_PRED (bb, 0);\n@@ -644,7 +646,7 @@ single_pred_edge (basic_block bb)\n    if BB does not have exactly one successor.  */\n \n static inline basic_block\n-single_succ (basic_block bb)\n+single_succ (const_basic_block bb)\n {\n   return single_succ_edge (bb)->dest;\n }\n@@ -653,7 +655,7 @@ single_succ (basic_block bb)\n    if BB does not have exactly one predecessor.*/\n \n static inline basic_block\n-single_pred (basic_block bb)\n+single_pred (const_basic_block bb)\n {\n   return single_pred_edge (bb)->src;\n }\n@@ -825,18 +827,18 @@ extern struct edge_list *pre_edge_rev_lcm (int, sbitmap *,\n extern void compute_available (sbitmap *, sbitmap *, sbitmap *, sbitmap *);\n \n /* In predict.c */\n-extern bool maybe_hot_bb_p (basic_block);\n-extern bool probably_cold_bb_p (basic_block);\n-extern bool probably_never_executed_bb_p (basic_block);\n+extern bool maybe_hot_bb_p (const_basic_block);\n+extern bool probably_cold_bb_p (const_basic_block);\n+extern bool probably_never_executed_bb_p (const_basic_block);\n extern bool tree_predicted_by_p (basic_block, enum br_predictor);\n extern bool rtl_predicted_by_p (basic_block, enum br_predictor);\n extern void tree_predict_edge (edge, enum br_predictor, int);\n extern void rtl_predict_edge (edge, enum br_predictor, int);\n extern void predict_edge_def (edge, enum br_predictor, enum prediction);\n extern void guess_outgoing_edge_probabilities (basic_block);\n extern void remove_predictions_associated_with_edge (edge);\n-extern bool edge_probability_reliable_p (edge);\n-extern bool br_prob_note_reliable_p (rtx);\n+extern bool edge_probability_reliable_p (const_edge);\n+extern bool br_prob_note_reliable_p (const_rtx);\n \n /* In cfg.c  */\n extern void dump_regset (regset, FILE *);\n@@ -862,10 +864,10 @@ extern void free_aux_for_edges (void);\n \n /* In cfganal.c  */\n extern void find_unreachable_blocks (void);\n-extern bool forwarder_block_p (basic_block);\n+extern bool forwarder_block_p (const_basic_block);\n extern bool can_fallthru (basic_block, basic_block);\n extern bool could_fall_through (basic_block, basic_block);\n-extern void flow_nodes_print (const char *, const sbitmap, FILE *);\n+extern void flow_nodes_print (const char *, const_sbitmap, FILE *);\n extern void flow_edge_list_print (const char *, const edge *, int, FILE *);\n \n /* In cfgrtl.c  */\n@@ -887,8 +889,8 @@ extern bool mark_dfs_back_edges (void);\n extern void set_edge_can_fallthru_flag (void);\n extern void update_br_prob_note (basic_block);\n extern void fixup_abnormal_edges (void);\n-extern bool inside_basic_block_p (rtx);\n-extern bool control_flow_insn_p (rtx);\n+extern bool inside_basic_block_p (const_rtx);\n+extern bool control_flow_insn_p (const_rtx);\n extern rtx get_last_bb_insn (basic_block);\n \n /* In bb-reorder.c */\n@@ -914,7 +916,7 @@ extern basic_block nearest_common_dominator_for_set (enum cdi_direction,\n extern void set_immediate_dominator (enum cdi_direction, basic_block,\n \t\t\t\t     basic_block);\n extern basic_block get_immediate_dominator (enum cdi_direction, basic_block);\n-extern bool dominated_by_p (enum cdi_direction, basic_block, basic_block);\n+extern bool dominated_by_p (enum cdi_direction, const_basic_block, const_basic_block);\n extern VEC (basic_block, heap) *get_dominated_by (enum cdi_direction, basic_block);\n extern VEC (basic_block, heap) *get_dominated_by_region (enum cdi_direction,\n \t\t\t\t\t\t\t basic_block *,"}, {"sha": "432fd0e50153e19f00525af33b6d826fecadf21d", "filename": "gcc/bb-reorder.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed7a4b4b30c6054ef0500d2fde45beba399da929/gcc%2Fbb-reorder.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed7a4b4b30c6054ef0500d2fde45beba399da929/gcc%2Fbb-reorder.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbb-reorder.c?ref=ed7a4b4b30c6054ef0500d2fde45beba399da929", "patch": "@@ -174,11 +174,11 @@ static void find_traces_1_round (int, int, gcov_type, struct trace *, int *,\n \t\t\t\t int, fibheap_t *, int);\n static basic_block copy_bb (basic_block, edge, basic_block, int);\n static fibheapkey_t bb_to_key (basic_block);\n-static bool better_edge_p (basic_block, edge, int, int, int, int, edge);\n+static bool better_edge_p (const_basic_block, const_edge, int, int, int, int, const_edge);\n static void connect_traces (int, struct trace *);\n static bool copy_bb_p (basic_block, int);\n static int get_uncond_jump_length (void);\n-static bool push_to_next_round_p (basic_block, int, int, int, gcov_type);\n+static bool push_to_next_round_p (const_basic_block, int, int, int, gcov_type);\n static void find_rarely_executed_basic_blocks_and_crossing_edges (edge **,\n \t\t\t\t\t\t\t\t  int *,\n \t\t\t\t\t\t\t\t  int *);\n@@ -198,7 +198,7 @@ static void fix_crossing_unconditional_branches (void);\n    current round of trace collection.  */\n \n static bool\n-push_to_next_round_p (basic_block bb, int round, int number_of_rounds,\n+push_to_next_round_p (const_basic_block bb, int round, int number_of_rounds,\n \t\t      int exec_th, gcov_type count_th)\n {\n   bool there_exists_another_round;\n@@ -847,8 +847,8 @@ bb_to_key (basic_block bb)\n    BEST_PROB; similarly for frequency.  */\n \n static bool\n-better_edge_p (basic_block bb, edge e, int prob, int freq, int best_prob,\n-\t       int best_freq, edge cur_best_edge)\n+better_edge_p (const_basic_block bb, const_edge e, int prob, int freq, int best_prob,\n+\t       int best_freq, const_edge cur_best_edge)\n {\n   bool is_better_edge;\n "}, {"sha": "bf9214b1ae4deb27d6b585a0d770dae86ebe14d4", "filename": "gcc/bt-load.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed7a4b4b30c6054ef0500d2fde45beba399da929/gcc%2Fbt-load.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed7a4b4b30c6054ef0500d2fde45beba399da929/gcc%2Fbt-load.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbt-load.c?ref=ed7a4b4b30c6054ef0500d2fde45beba399da929", "patch": "@@ -111,8 +111,8 @@ typedef struct btr_def_s\n \n static int issue_rate;\n \n-static int basic_block_freq (basic_block);\n-static int insn_sets_btr_p (rtx, int, int *);\n+static int basic_block_freq (const_basic_block);\n+static int insn_sets_btr_p (const_rtx, int, int *);\n static rtx *find_btr_use (rtx);\n static int btr_referenced_p (rtx, rtx *);\n static int find_btr_reference (rtx *, void *);\n@@ -140,7 +140,7 @@ static void btr_def_live_range (btr_def, HARD_REG_SET *);\n static void move_btr_def (basic_block, int, btr_def, bitmap, HARD_REG_SET *);\n static int migrate_btr_def (btr_def, int);\n static void migrate_btr_defs (enum reg_class, int);\n-static int can_move_up (basic_block, rtx, int);\n+static int can_move_up (const_basic_block, const_rtx, int);\n static void note_btr_set (rtx, const_rtx, void *);\n \f\n /* The following code performs code motion of target load instructions\n@@ -179,7 +179,7 @@ static int first_btr, last_btr;\n \n /* Return an estimate of the frequency of execution of block bb.  */\n static int\n-basic_block_freq (basic_block bb)\n+basic_block_freq (const_basic_block bb)\n {\n   return bb->frequency;\n }\n@@ -222,7 +222,7 @@ btr_referenced_p (rtx x, rtx *excludep)\n    If such a set is found and REGNO is nonzero, assign the register number\n    of the destination register to *REGNO.  */\n static int\n-insn_sets_btr_p (rtx insn, int check_const, int *regno)\n+insn_sets_btr_p (const_rtx insn, int check_const, int *regno)\n {\n   rtx set;\n \n@@ -1235,7 +1235,7 @@ move_btr_def (basic_block new_def_bb, int btr, btr_def def, bitmap live_range,\n /* We anticipate intra-block scheduling to be done.  See if INSN could move\n    up within BB by N_INSNS.  */\n static int\n-can_move_up (basic_block bb, rtx insn, int n_insns)\n+can_move_up (const_basic_block bb, const_rtx insn, int n_insns)\n {\n   while (insn != BB_HEAD (bb) && n_insns > 0)\n     {"}, {"sha": "66214d7fec623710118a73faa9a4ebee4b1cd63d", "filename": "gcc/cfganal.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed7a4b4b30c6054ef0500d2fde45beba399da929/gcc%2Fcfganal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed7a4b4b30c6054ef0500d2fde45beba399da929/gcc%2Fcfganal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfganal.c?ref=ed7a4b4b30c6054ef0500d2fde45beba399da929", "patch": "@@ -53,13 +53,13 @@ static void flow_dfs_compute_reverse_add_bb (depth_first_search_ds,\n static basic_block flow_dfs_compute_reverse_execute (depth_first_search_ds,\n \t\t\t\t\t\t     basic_block);\n static void flow_dfs_compute_reverse_finish (depth_first_search_ds);\n-static bool flow_active_insn_p (rtx);\n+static bool flow_active_insn_p (const_rtx);\n \f\n /* Like active_insn_p, except keep the return value clobber around\n    even after reload.  */\n \n static bool\n-flow_active_insn_p (rtx insn)\n+flow_active_insn_p (const_rtx insn)\n {\n   if (active_insn_p (insn))\n     return true;\n@@ -81,7 +81,7 @@ flow_active_insn_p (rtx insn)\n    its single destination.  */\n \n bool\n-forwarder_block_p (basic_block bb)\n+forwarder_block_p (const_basic_block bb)\n {\n   rtx insn;\n \n@@ -518,7 +518,7 @@ find_edge_index (struct edge_list *edge_list, basic_block pred, basic_block succ\n /* Dump the list of basic blocks in the bitmap NODES.  */\n \n void\n-flow_nodes_print (const char *str, const sbitmap nodes, FILE *file)\n+flow_nodes_print (const char *str, const_sbitmap nodes, FILE *file)\n {\n   unsigned int node = 0;\n   sbitmap_iterator sbi;\n@@ -1147,8 +1147,8 @@ flow_dfs_compute_reverse_finish (depth_first_search_ds data)\n    found and their list in RSLT.  RSLT can contain at most RSLT_MAX items.  */\n int\n dfs_enumerate_from (basic_block bb, int reverse,\n-\t\t    bool (*predicate) (basic_block, void *),\n-\t\t    basic_block *rslt, int rslt_max, void *data)\n+\t\t    bool (*predicate) (const_basic_block, const void *),\n+\t\t    basic_block *rslt, int rslt_max, const void *data)\n {\n   basic_block *st, lbb;\n   int sp = 0, tv = 0;"}, {"sha": "f8c8b820541ea93f2099936ba6aa744f52867dea", "filename": "gcc/cfgbuild.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed7a4b4b30c6054ef0500d2fde45beba399da929/gcc%2Fcfgbuild.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed7a4b4b30c6054ef0500d2fde45beba399da929/gcc%2Fcfgbuild.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgbuild.c?ref=ed7a4b4b30c6054ef0500d2fde45beba399da929", "patch": "@@ -45,7 +45,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"toplev.h\"\n #include \"timevar.h\"\n \n-static int count_basic_blocks (rtx);\n+static int count_basic_blocks (const_rtx);\n static void find_basic_blocks_1 (rtx);\n static void make_edges (basic_block, basic_block, int);\n static void make_label_edge (sbitmap, basic_block, rtx, int);\n@@ -56,7 +56,7 @@ static void compute_outgoing_frequencies (basic_block);\n    block.  */\n \n bool\n-inside_basic_block_p (rtx insn)\n+inside_basic_block_p (const_rtx insn)\n {\n   switch (GET_CODE (insn))\n     {\n@@ -88,7 +88,7 @@ inside_basic_block_p (rtx insn)\n    the basic block.  */\n \n bool\n-control_flow_insn_p (rtx insn)\n+control_flow_insn_p (const_rtx insn)\n {\n   rtx note;\n \n@@ -140,11 +140,11 @@ control_flow_insn_p (rtx insn)\n /* Count the basic blocks of the function.  */\n \n static int\n-count_basic_blocks (rtx f)\n+count_basic_blocks (const_rtx f)\n {\n   int count = NUM_FIXED_BLOCKS;\n   bool saw_insn = false;\n-  rtx insn;\n+  const_rtx insn;\n \n   for (insn = f; insn; insn = NEXT_INSN (insn))\n     {"}, {"sha": "f565708ae9ed55dddb3512f342e99e6385bac2a9", "filename": "gcc/cfgloop.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed7a4b4b30c6054ef0500d2fde45beba399da929/gcc%2Fcfgloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed7a4b4b30c6054ef0500d2fde45beba399da929/gcc%2Fcfgloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.c?ref=ed7a4b4b30c6054ef0500d2fde45beba399da929", "patch": "@@ -765,7 +765,7 @@ disambiguate_loops_with_multiple_latches (void)\n \n /* Return nonzero if basic block BB belongs to LOOP.  */\n bool\n-flow_bb_inside_loop_p (const struct loop *loop, const basic_block bb)\n+flow_bb_inside_loop_p (const struct loop *loop, const_basic_block bb)\n {\n   struct loop *source_loop;\n \n@@ -778,9 +778,9 @@ flow_bb_inside_loop_p (const struct loop *loop, const basic_block bb)\n \n /* Enumeration predicate for get_loop_body_with_size.  */\n static bool\n-glb_enum_p (basic_block bb, void *glb_loop)\n+glb_enum_p (const_basic_block bb, const void *glb_loop)\n {\n-  struct loop *loop = (struct loop *) glb_loop;\n+  const struct loop *const loop = (const struct loop *) glb_loop;\n   return (bb != loop->header\n \t  && dominated_by_p (CDI_DOMINATORS, bb, loop->header));\n }\n@@ -797,7 +797,7 @@ get_loop_body_with_size (const struct loop *loop, basic_block *body,\n \t\t\t unsigned max_size)\n {\n   return dfs_enumerate_from (loop->header, 1, glb_enum_p,\n-\t\t\t     body, max_size, (void *) loop);\n+\t\t\t     body, max_size, loop);\n }\n \n /* Gets basic blocks of a LOOP.  Header is the 0-th block, rest is in dfs\n@@ -1581,7 +1581,7 @@ loop_preheader_edge (const struct loop *loop)\n /* Returns true if E is an exit of LOOP.  */\n \n bool\n-loop_exit_edge_p (const struct loop *loop, edge e)\n+loop_exit_edge_p (const struct loop *loop, const_edge e)\n {\n   return (flow_bb_inside_loop_p (loop, e->src)\n \t  && !flow_bb_inside_loop_p (loop, e->dest));"}, {"sha": "056e8f0b1e5569ee850a8dabf66f4806ac4661d3", "filename": "gcc/cfgloop.h", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed7a4b4b30c6054ef0500d2fde45beba399da929/gcc%2Fcfgloop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed7a4b4b30c6054ef0500d2fde45beba399da929/gcc%2Fcfgloop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.h?ref=ed7a4b4b30c6054ef0500d2fde45beba399da929", "patch": "@@ -218,15 +218,15 @@ extern void flow_loop_tree_node_add (struct loop *, struct loop *);\n extern void flow_loop_tree_node_remove (struct loop *);\n extern void add_loop (struct loop *, struct loop *);\n extern bool flow_loop_nested_p\t(const struct loop *, const struct loop *);\n-extern bool flow_bb_inside_loop_p (const struct loop *, const basic_block);\n+extern bool flow_bb_inside_loop_p (const struct loop *, const_basic_block);\n extern struct loop * find_common_loop (struct loop *, struct loop *);\n struct loop *superloop_at_depth (struct loop *, unsigned);\n struct eni_weights_d;\n extern unsigned tree_num_loop_insns (struct loop *, struct eni_weights_d *);\n-extern int num_loop_insns (struct loop *);\n-extern int average_num_loop_insns (struct loop *);\n+extern int num_loop_insns (const struct loop *);\n+extern int average_num_loop_insns (const struct loop *);\n extern unsigned get_loop_level (const struct loop *);\n-extern bool loop_exit_edge_p (const struct loop *, edge);\n+extern bool loop_exit_edge_p (const struct loop *, const_edge);\n extern void mark_loop_exit_edges (void);\n \n /* Loops & cfg manipulation.  */\n@@ -260,7 +260,7 @@ extern void force_single_succ_latches (void);\n extern void verify_loop_structure (void);\n \n /* Loop analysis.  */\n-extern bool just_once_each_iteration_p (const struct loop *, basic_block);\n+extern bool just_once_each_iteration_p (const struct loop *, const_basic_block);\n gcov_type expected_loop_iterations_unbounded (const struct loop *);\n extern unsigned expected_loop_iterations (const struct loop *);\n extern rtx doloop_condition_get (rtx);\n@@ -270,7 +270,7 @@ HOST_WIDE_INT estimated_loop_iterations_int (struct loop *, bool);\n bool estimated_loop_iterations (struct loop *, bool, double_int *);\n \n /* Loop manipulation.  */\n-extern bool can_duplicate_loop_p (struct loop *loop);\n+extern bool can_duplicate_loop_p (const struct loop *loop);\n \n #define DLTHE_FLAG_UPDATE_FREQ\t1\t/* Update frequencies in\n \t\t\t\t\t   duplicate_loop_to_header_edge.  */"}, {"sha": "d6a74bfe519c1ff41670cd81be07ad55a6ca501d", "filename": "gcc/cfgloopanal.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed7a4b4b30c6054ef0500d2fde45beba399da929/gcc%2Fcfgloopanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed7a4b4b30c6054ef0500d2fde45beba399da929/gcc%2Fcfgloopanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopanal.c?ref=ed7a4b4b30c6054ef0500d2fde45beba399da929", "patch": "@@ -33,7 +33,7 @@ along with GCC; see the file COPYING3.  If not see\n /* Checks whether BB is executed exactly once in each LOOP iteration.  */\n \n bool\n-just_once_each_iteration_p (const struct loop *loop, basic_block bb)\n+just_once_each_iteration_p (const struct loop *loop, const_basic_block bb)\n {\n   /* It must be executed at least once each iteration.  */\n   if (!dominated_by_p (CDI_DOMINATORS, loop->latch, bb))\n@@ -161,7 +161,7 @@ mark_irreducible_loops (void)\n \n /* Counts number of insns inside LOOP.  */\n int\n-num_loop_insns (struct loop *loop)\n+num_loop_insns (const struct loop *loop)\n {\n   basic_block *bbs, bb;\n   unsigned i, ninsns = 0;\n@@ -183,7 +183,7 @@ num_loop_insns (struct loop *loop)\n \n /* Counts number of insns executed on average per iteration LOOP.  */\n int\n-average_num_loop_insns (struct loop *loop)\n+average_num_loop_insns (const struct loop *loop)\n {\n   basic_block *bbs, bb;\n   unsigned i, binsns, ninsns, ratio;\n@@ -294,7 +294,7 @@ get_loop_level (const struct loop *loop)\n /* Returns estimate on cost of computing SEQ.  */\n \n static unsigned\n-seq_cost (rtx seq)\n+seq_cost (const_rtx seq)\n {\n   unsigned cost = 0;\n   rtx set;"}, {"sha": "dc088440f44874e3d1816ee85b46cd116631874b", "filename": "gcc/cfgloopmanip.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed7a4b4b30c6054ef0500d2fde45beba399da929/gcc%2Fcfgloopmanip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed7a4b4b30c6054ef0500d2fde45beba399da929/gcc%2Fcfgloopmanip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopmanip.c?ref=ed7a4b4b30c6054ef0500d2fde45beba399da929", "patch": "@@ -35,7 +35,7 @@ static void copy_loops_to (struct loop **, int,\n \t\t\t   struct loop *);\n static void loop_redirect_edge (edge, basic_block);\n static void remove_bbs (basic_block *, int);\n-static bool rpe_enum_p (basic_block, void *);\n+static bool rpe_enum_p (const_basic_block, const void *);\n static int find_path (edge, basic_block **);\n static void fix_loop_placements (struct loop *, bool *);\n static bool fix_bb_placement (basic_block);\n@@ -46,9 +46,9 @@ static void unloop (struct loop *, bool *);\n \n /* Checks whether basic block BB is dominated by DATA.  */\n static bool\n-rpe_enum_p (basic_block bb, void *data)\n+rpe_enum_p (const_basic_block bb, const void *data)\n {\n-  return dominated_by_p (CDI_DOMINATORS, bb, (basic_block) data);\n+  return dominated_by_p (CDI_DOMINATORS, bb, (const_basic_block) data);\n }\n \n /* Remove basic blocks BBS.  NBBS is the number of the basic blocks.  */\n@@ -712,7 +712,7 @@ loop_redirect_edge (edge e, basic_block dest)\n \n /* Check whether LOOP's body can be duplicated.  */\n bool\n-can_duplicate_loop_p (struct loop *loop)\n+can_duplicate_loop_p (const struct loop *loop)\n {\n   int ret;\n   basic_block *bbs = get_loop_body (loop);"}, {"sha": "fdd94d2c14bdda60cabd3d9d4b780fbe3e88b707", "filename": "gcc/dominance.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed7a4b4b30c6054ef0500d2fde45beba399da929/gcc%2Fdominance.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed7a4b4b30c6054ef0500d2fde45beba399da929/gcc%2Fdominance.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdominance.c?ref=ed7a4b4b30c6054ef0500d2fde45beba399da929", "patch": "@@ -922,7 +922,7 @@ nearest_common_dominator_for_set (enum cdi_direction dir, bitmap blocks)\n \n /* Return TRUE in case BB1 is dominated by BB2.  */\n bool\n-dominated_by_p (enum cdi_direction dir, basic_block bb1, basic_block bb2)\n+dominated_by_p (enum cdi_direction dir, const_basic_block bb1, const_basic_block bb2)\n { \n   unsigned int dir_index = dom_convert_dir_to_idx (dir);\n   struct et_node *n1 = bb1->dom[dir_index], *n2 = bb2->dom[dir_index];"}, {"sha": "745a10a851b5976322b7495c485a26ea6eb1cccf", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed7a4b4b30c6054ef0500d2fde45beba399da929/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed7a4b4b30c6054ef0500d2fde45beba399da929/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=ed7a4b4b30c6054ef0500d2fde45beba399da929", "patch": "@@ -622,7 +622,7 @@ gen_tmp_stack_mem (enum machine_mode mode, rtx addr)\n \n bool\n validate_subreg (enum machine_mode omode, enum machine_mode imode,\n-\t\t rtx reg, unsigned int offset)\n+\t\t const_rtx reg, unsigned int offset)\n {\n   unsigned int isize = GET_MODE_SIZE (imode);\n   unsigned int osize = GET_MODE_SIZE (omode);"}, {"sha": "02131eeb0fea1db8a7d54deeaa784498006fc66d", "filename": "gcc/except.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed7a4b4b30c6054ef0500d2fde45beba399da929/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed7a4b4b30c6054ef0500d2fde45beba399da929/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=ed7a4b4b30c6054ef0500d2fde45beba399da929", "patch": "@@ -2698,7 +2698,7 @@ can_throw_internal_1 (int region_number, bool is_resx)\n }\n \n bool\n-can_throw_internal (rtx insn)\n+can_throw_internal (const_rtx insn)\n {\n   rtx note;\n \n@@ -2752,7 +2752,7 @@ can_throw_external_1 (int region_number, bool is_resx)\n }\n \n bool\n-can_throw_external (rtx insn)\n+can_throw_external (const_rtx insn)\n {\n   rtx note;\n "}, {"sha": "b3b95b1496277ab3efdadd23e1a5a26dfc2da327", "filename": "gcc/except.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed7a4b4b30c6054ef0500d2fde45beba399da929/gcc%2Fexcept.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed7a4b4b30c6054ef0500d2fde45beba399da929/gcc%2Fexcept.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.h?ref=ed7a4b4b30c6054ef0500d2fde45beba399da929", "patch": "@@ -46,9 +46,9 @@ extern void for_each_eh_region (void (*) (struct eh_region *));\n \n /* Determine if the given INSN can throw an exception.  */\n extern bool can_throw_internal_1 (int, bool);\n-extern bool can_throw_internal (rtx);\n+extern bool can_throw_internal (const_rtx);\n extern bool can_throw_external_1 (int, bool);\n-extern bool can_throw_external (rtx);\n+extern bool can_throw_external (const_rtx);\n \n /* Set TREE_NOTHROW and cfun->all_throwers_are_sibcalls.  */\n extern unsigned int set_nothrow_function_flags (void);"}, {"sha": "be0266150945f1e81068a4d6877c9b3ac3f1e287", "filename": "gcc/gcse.c", "status": "modified", "additions": 41, "deletions": 41, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed7a4b4b30c6054ef0500d2fde45beba399da929/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed7a4b4b30c6054ef0500d2fde45beba399da929/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=ed7a4b4b30c6054ef0500d2fde45beba399da929", "patch": "@@ -531,16 +531,16 @@ static void hash_scan_clobber (rtx, rtx, struct hash_table *);\n static void hash_scan_call (rtx, rtx, struct hash_table *);\n static int want_to_gcse_p (rtx);\n static bool can_assign_to_reg_p (rtx);\n-static bool gcse_constant_p (rtx);\n-static int oprs_unchanged_p (rtx, rtx, int);\n-static int oprs_anticipatable_p (rtx, rtx);\n-static int oprs_available_p (rtx, rtx);\n+static bool gcse_constant_p (const_rtx);\n+static int oprs_unchanged_p (const_rtx, const_rtx, int);\n+static int oprs_anticipatable_p (const_rtx, const_rtx);\n+static int oprs_available_p (const_rtx, const_rtx);\n static void insert_expr_in_table (rtx, enum machine_mode, rtx, int, int,\n \t\t\t\t  struct hash_table *);\n static void insert_set_in_table (rtx, rtx, struct hash_table *);\n-static unsigned int hash_expr (rtx, enum machine_mode, int *, int);\n+static unsigned int hash_expr (const_rtx, enum machine_mode, int *, int);\n static unsigned int hash_set (int, int);\n-static int expr_equiv_p (rtx, rtx);\n+static int expr_equiv_p (const_rtx, const_rtx);\n static void record_last_reg_set_info (rtx, int);\n static void record_last_mem_set_info (rtx);\n static void record_last_set_info (rtx, const_rtx, void *);\n@@ -552,14 +552,14 @@ static void dump_hash_table (FILE *, const char *, struct hash_table *);\n static struct expr *lookup_set (unsigned int, struct hash_table *);\n static struct expr *next_set (unsigned int, struct expr *);\n static void reset_opr_set_tables (void);\n-static int oprs_not_set_p (rtx, rtx);\n+static int oprs_not_set_p (const_rtx, const_rtx);\n static void mark_call (rtx);\n static void mark_set (rtx, rtx);\n static void mark_clobber (rtx, rtx);\n static void mark_oprs_set (rtx);\n static void alloc_cprop_mem (int, int);\n static void free_cprop_mem (void);\n-static void compute_transp (rtx, int, sbitmap *, int);\n+static void compute_transp (const_rtx, int, sbitmap *, int);\n static void compute_transpout (void);\n static void compute_local_properties (sbitmap *, sbitmap *, sbitmap *,\n \t\t\t\t      struct hash_table *);\n@@ -569,15 +569,15 @@ static int try_replace_reg (rtx, rtx, rtx);\n static struct expr *find_avail_set (int, rtx);\n static int cprop_jump (basic_block, rtx, rtx, rtx, rtx);\n static void mems_conflict_for_gcse_p (rtx, const_rtx, void *);\n-static int load_killed_in_block_p (basic_block, int, rtx, int);\n+static int load_killed_in_block_p (const_basic_block, int, const_rtx, int);\n static void canon_list_insert (rtx, const_rtx, void *);\n static int cprop_insn (rtx, int);\n static int cprop (int);\n static void find_implicit_sets (void);\n static int one_cprop_pass (int, bool, bool);\n static bool constprop_register (rtx, rtx, rtx, bool);\n static struct expr *find_bypass_set (int, int);\n-static bool reg_killed_on_edge (rtx, edge);\n+static bool reg_killed_on_edge (const_rtx, const_edge);\n static int bypass_block (basic_block, rtx, rtx);\n static int bypass_conditional_jumps (void);\n static void alloc_pre_mem (int, int);\n@@ -611,23 +611,23 @@ static struct ls_expr * find_rtx_in_ldst (rtx);\n static int enumerate_ldsts (void);\n static inline struct ls_expr * first_ls_expr (void);\n static inline struct ls_expr * next_ls_expr (struct ls_expr *);\n-static int simple_mem (rtx);\n+static int simple_mem (const_rtx);\n static void invalidate_any_buried_refs (rtx);\n static void compute_ld_motion_mems (void);\n static void trim_ld_motion_mems (void);\n static void update_ld_motion_stores (struct expr *);\n static void reg_set_info (rtx, const_rtx, void *);\n static void reg_clear_last_set (rtx, const_rtx, void *);\n-static bool store_ops_ok (rtx, int *);\n+static bool store_ops_ok (const_rtx, int *);\n static rtx extract_mentioned_regs (rtx);\n static rtx extract_mentioned_regs_helper (rtx, rtx);\n static void find_moveable_store (rtx, int *, int *);\n static int compute_store_table (void);\n-static bool load_kills_store (rtx, rtx, int);\n-static bool find_loads (rtx, rtx, int);\n-static bool store_killed_in_insn (rtx, rtx, rtx, int);\n-static bool store_killed_after (rtx, rtx, rtx, basic_block, int *, rtx *);\n-static bool store_killed_before (rtx, rtx, rtx, basic_block, int *);\n+static bool load_kills_store (const_rtx, const_rtx, int);\n+static bool find_loads (const_rtx, const_rtx, int);\n+static bool store_killed_in_insn (const_rtx, const_rtx, const_rtx, int);\n+static bool store_killed_after (const_rtx, const_rtx, const_rtx, const_basic_block, int *, rtx *);\n+static bool store_killed_before (const_rtx, const_rtx, const_rtx, const_basic_block, int *);\n static void build_store_vectors (void);\n static void insert_insn_start_basic_block (rtx, basic_block);\n static int insert_store (struct ls_expr *, edge);\n@@ -1239,7 +1239,7 @@ can_assign_to_reg_p (rtx x)\n    or from INSN to the end of INSN's basic block (if AVAIL_P != 0).  */\n \n static int\n-oprs_unchanged_p (rtx x, rtx insn, int avail_p)\n+oprs_unchanged_p (const_rtx x, const_rtx insn, int avail_p)\n {\n   int i, j;\n   enum rtx_code code;\n@@ -1325,7 +1325,7 @@ static int gcse_mems_conflict_p;\n    load_killed_in_block_p.  A memory reference for a load instruction,\n    mems_conflict_for_gcse_p will see if a memory store conflicts with\n    this memory load.  */\n-static rtx gcse_mem_operand;\n+static const_rtx gcse_mem_operand;\n \n /* DEST is the output of an instruction.  If it is a memory reference, and\n    possibly conflicts with the load found in gcse_mem_operand, then set\n@@ -1370,7 +1370,7 @@ mems_conflict_for_gcse_p (rtx dest, const_rtx setter ATTRIBUTE_UNUSED,\n    AVAIL_P to 0.  */\n \n static int\n-load_killed_in_block_p (basic_block bb, int uid_limit, rtx x, int avail_p)\n+load_killed_in_block_p (const_basic_block bb, int uid_limit, const_rtx x, int avail_p)\n {\n   rtx list_entry = modify_mem_list[bb->index];\n \n@@ -1418,7 +1418,7 @@ load_killed_in_block_p (basic_block bb, int uid_limit, rtx x, int avail_p)\n    the start of INSN's basic block up to but not including INSN.  */\n \n static int\n-oprs_anticipatable_p (rtx x, rtx insn)\n+oprs_anticipatable_p (const_rtx x, const_rtx insn)\n {\n   return oprs_unchanged_p (x, insn, 0);\n }\n@@ -1427,7 +1427,7 @@ oprs_anticipatable_p (rtx x, rtx insn)\n    INSN to the end of INSN's basic block.  */\n \n static int\n-oprs_available_p (rtx x, rtx insn)\n+oprs_available_p (const_rtx x, const_rtx insn)\n {\n   return oprs_unchanged_p (x, insn, 1);\n }\n@@ -1440,7 +1440,7 @@ oprs_available_p (rtx x, rtx insn)\n    the current size of the hash table to be probed.  */\n \n static unsigned int\n-hash_expr (rtx x, enum machine_mode mode, int *do_not_record_p,\n+hash_expr (const_rtx x, enum machine_mode mode, int *do_not_record_p,\n \t   int hash_table_size)\n {\n   unsigned int hash;\n@@ -1471,7 +1471,7 @@ hash_set (int regno, int hash_table_size)\n /* Return nonzero if exp1 is equivalent to exp2.  */\n \n static int\n-expr_equiv_p (rtx x, rtx y)\n+expr_equiv_p (const_rtx x, const_rtx y)\n {\n   return exp_equiv_p (x, y, 0, true);\n }\n@@ -1660,7 +1660,7 @@ insert_set_in_table (rtx x, rtx insn, struct hash_table *table)\n    the purposes of GCSE's constant propagation.  */\n \n static bool\n-gcse_constant_p (rtx x)\n+gcse_constant_p (const_rtx x)\n {\n   /* Consider a COMPARE of two integers constant.  */\n   if (GET_CODE (x) == COMPARE\n@@ -2248,7 +2248,7 @@ reset_opr_set_tables (void)\n    INSN's basic block.  */\n \n static int\n-oprs_not_set_p (rtx x, rtx insn)\n+oprs_not_set_p (const_rtx x, const_rtx insn)\n {\n   int i, j;\n   enum rtx_code code;\n@@ -2426,7 +2426,7 @@ free_cprop_mem (void)\n    bit in BMAP.  */\n \n static void\n-compute_transp (rtx x, int indx, sbitmap *bmap, int set_p)\n+compute_transp (const_rtx x, int indx, sbitmap *bmap, int set_p)\n {\n   int i, j;\n   basic_block bb;\n@@ -3312,10 +3312,10 @@ fis_get_condition (rtx jump)\n    it.  COND is either an EQ or NE comparison.  */\n \n static bool\n-implicit_set_cond_p (rtx cond)\n+implicit_set_cond_p (const_rtx cond)\n {\n-  enum machine_mode mode = GET_MODE (XEXP (cond, 0));\n-  rtx cst = XEXP (cond, 1);\n+  const enum machine_mode mode = GET_MODE (XEXP (cond, 0));\n+  const_rtx cst = XEXP (cond, 1);\n \n   /* We can't perform this optimization if either operand might be or might\n      contain a signed zero.  */\n@@ -3503,7 +3503,7 @@ find_bypass_set (int regno, int bb)\n    valid prior to commit_edge_insertions.  */\n \n static bool\n-reg_killed_on_edge (rtx reg, edge e)\n+reg_killed_on_edge (const_rtx reg, const_edge e)\n {\n   rtx insn;\n \n@@ -5206,7 +5206,7 @@ next_ls_expr (struct ls_expr * ptr)\n    ld_motion list, otherwise we let the usual aliasing take care of it.  */\n \n static int\n-simple_mem (rtx x)\n+simple_mem (const_rtx x)\n {\n   if (! MEM_P (x))\n     return 0;\n@@ -5508,9 +5508,9 @@ reg_clear_last_set (rtx dest, const_rtx setter ATTRIBUTE_UNUSED,\n    due to set of registers in bitmap REGS_SET.  */\n \n static bool\n-store_ops_ok (rtx x, int *regs_set)\n+store_ops_ok (const_rtx x, int *regs_set)\n {\n-  rtx reg;\n+  const_rtx reg;\n \n   for (; x; x = XEXP (x, 1))\n     {\n@@ -5864,7 +5864,7 @@ compute_store_table (void)\n    after the X.  */\n \n static bool\n-load_kills_store (rtx x, rtx store_pattern, int after)\n+load_kills_store (const_rtx x, const_rtx store_pattern, int after)\n {\n   if (after)\n     return anti_dependence (x, store_pattern);\n@@ -5879,7 +5879,7 @@ load_kills_store (rtx x, rtx store_pattern, int after)\n    after the insn X.  */\n \n static bool\n-find_loads (rtx x, rtx store_pattern, int after)\n+find_loads (const_rtx x, const_rtx store_pattern, int after)\n {\n   const char * fmt;\n   int i, j;\n@@ -5912,7 +5912,7 @@ find_loads (rtx x, rtx store_pattern, int after)\n }\n \n static inline bool\n-store_killed_in_pat (rtx x, rtx pat, int after)\n+store_killed_in_pat (const_rtx x, const_rtx pat, int after)\n {\n   if (GET_CODE (pat) == SET)\n     {\n@@ -5949,9 +5949,9 @@ store_killed_in_pat (rtx x, rtx pat, int after)\n    after the insn.  Return true if it does.  */\n \n static bool\n-store_killed_in_insn (rtx x, rtx x_regs, rtx insn, int after)\n+store_killed_in_insn (const_rtx x, const_rtx x_regs, const_rtx insn, int after)\n {\n-  rtx reg, base, note, pat;\n+  const_rtx reg, base, note, pat;\n \n   if (!INSN_P (insn))\n     return false;\n@@ -6017,7 +6017,7 @@ store_killed_in_insn (rtx x, rtx x_regs, rtx insn, int after)\n    is killed, return the last insn in that it occurs in FAIL_INSN.  */\n \n static bool\n-store_killed_after (rtx x, rtx x_regs, rtx insn, basic_block bb,\n+store_killed_after (const_rtx x, const_rtx x_regs, const_rtx insn, const_basic_block bb,\n \t\t    int *regs_set_after, rtx *fail_insn)\n {\n   rtx last = BB_END (bb), act;\n@@ -6046,7 +6046,7 @@ store_killed_after (rtx x, rtx x_regs, rtx insn, basic_block bb,\n    within basic block BB. X_REGS is list of registers mentioned in X.\n    REGS_SET_BEFORE is bitmap of registers set before or in this insn.  */\n static bool\n-store_killed_before (rtx x, rtx x_regs, rtx insn, basic_block bb,\n+store_killed_before (const_rtx x, const_rtx x_regs, const_rtx insn, const_basic_block bb,\n \t\t     int *regs_set_before)\n {\n   rtx first = BB_HEAD (bb);"}, {"sha": "cea9dec60a41920660febb70f0359b1c130cf9ff", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed7a4b4b30c6054ef0500d2fde45beba399da929/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed7a4b4b30c6054ef0500d2fde45beba399da929/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=ed7a4b4b30c6054ef0500d2fde45beba399da929", "patch": "@@ -87,15 +87,15 @@ static int num_true_changes;\n static int cond_exec_changed_p;\n \n /* Forward references.  */\n-static int count_bb_insns (basic_block);\n-static bool cheap_bb_rtx_cost_p (basic_block, int);\n+static int count_bb_insns (const_basic_block);\n+static bool cheap_bb_rtx_cost_p (const_basic_block, int);\n static rtx first_active_insn (basic_block);\n static rtx last_active_insn (basic_block, int);\n static basic_block block_fallthru (basic_block);\n static int cond_exec_process_insns (ce_if_block_t *, rtx, rtx, rtx, rtx, int);\n static rtx cond_exec_get_condition (rtx);\n static rtx noce_get_condition (rtx, rtx *, bool);\n-static int noce_operand_ok (rtx);\n+static int noce_operand_ok (const_rtx);\n static void merge_if_block (ce_if_block_t *);\n static int find_cond_trap (basic_block, edge, edge);\n static basic_block find_if_header (basic_block, int);\n@@ -113,7 +113,7 @@ static rtx block_has_only_trap (basic_block);\n /* Count the number of non-jump active insns in BB.  */\n \n static int\n-count_bb_insns (basic_block bb)\n+count_bb_insns (const_basic_block bb)\n {\n   int count = 0;\n   rtx insn = BB_HEAD (bb);\n@@ -136,7 +136,7 @@ count_bb_insns (basic_block bb)\n    false if the cost of any instruction could not be estimated.  */\n \n static bool\n-cheap_bb_rtx_cost_p (basic_block bb, int max_cost)\n+cheap_bb_rtx_cost_p (const_basic_block bb, int max_cost)\n {\n   int count = 0;\n   rtx insn = BB_HEAD (bb);\n@@ -2071,7 +2071,7 @@ noce_get_condition (rtx jump, rtx *earliest, bool then_else_reversed)\n /* Return true if OP is ok for if-then-else processing.  */\n \n static int\n-noce_operand_ok (rtx op)\n+noce_operand_ok (const_rtx op)\n {\n   /* We special-case memories, so handle any of them with\n      no address side effects.  */\n@@ -2087,7 +2087,7 @@ noce_operand_ok (rtx op)\n /* Return true if a write into MEM may trap or fault.  */\n \n static bool\n-noce_mem_write_may_trap_or_fault_p (rtx mem)\n+noce_mem_write_may_trap_or_fault_p (const_rtx mem)\n {\n   rtx addr;\n "}, {"sha": "1c733a7cadb3b6c52f1121ed6818ce414913e8ea", "filename": "gcc/pointer-set.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed7a4b4b30c6054ef0500d2fde45beba399da929/gcc%2Fpointer-set.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed7a4b4b30c6054ef0500d2fde45beba399da929/gcc%2Fpointer-set.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpointer-set.c?ref=ed7a4b4b30c6054ef0500d2fde45beba399da929", "patch": "@@ -93,7 +93,7 @@ pointer_set_destroy (struct pointer_set_t *pset)\n \n    Collisions are resolved by linear probing.  */\n int\n-pointer_set_contains (struct pointer_set_t *pset, void *p)\n+pointer_set_contains (struct pointer_set_t *pset, const void *p)\n {\n   size_t n = hash1 (p, pset->n_slots, pset->log_slots);\n \n@@ -226,7 +226,7 @@ void pointer_map_destroy (struct pointer_map_t *pmap)\n \n    Collisions are resolved by linear probing.  */\n void **\n-pointer_map_contains (struct pointer_map_t *pmap, void *p)\n+pointer_map_contains (struct pointer_map_t *pmap, const void *p)\n {\n   size_t n = hash1 (p, pmap->n_slots, pmap->log_slots);\n "}, {"sha": "9c09cb0577054c24e6f057a5904e11cddfe6f063", "filename": "gcc/pointer-set.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed7a4b4b30c6054ef0500d2fde45beba399da929/gcc%2Fpointer-set.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed7a4b4b30c6054ef0500d2fde45beba399da929/gcc%2Fpointer-set.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpointer-set.h?ref=ed7a4b4b30c6054ef0500d2fde45beba399da929", "patch": "@@ -24,7 +24,7 @@ struct pointer_set_t;\n struct pointer_set_t *pointer_set_create (void);\n void pointer_set_destroy (struct pointer_set_t *pset);\n \n-int pointer_set_contains (struct pointer_set_t *pset, void *p);\n+int pointer_set_contains (struct pointer_set_t *pset, const void *p);\n int pointer_set_insert (struct pointer_set_t *pset, void *p);\n void pointer_set_traverse (struct pointer_set_t *, bool (*) (void *, void *),\n \t\t\t   void *);\n@@ -33,7 +33,7 @@ struct pointer_map_t;\n struct pointer_map_t *pointer_map_create (void);\n void pointer_map_destroy (struct pointer_map_t *pmap);\n \n-void **pointer_map_contains (struct pointer_map_t *pmap, void *p);\n+void **pointer_map_contains (struct pointer_map_t *pmap, const void *p);\n void **pointer_map_insert (struct pointer_map_t *pmap, void *p);\n void pointer_map_traverse (struct pointer_map_t *,\n \t\t\t   bool (*) (void *, void **, void *), void *);"}, {"sha": "87baaf4cd55601aba8632661aad4fe7a172b3b47", "filename": "gcc/predict.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed7a4b4b30c6054ef0500d2fde45beba399da929/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed7a4b4b30c6054ef0500d2fde45beba399da929/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=ed7a4b4b30c6054ef0500d2fde45beba399da929", "patch": "@@ -77,7 +77,7 @@ static void dump_prediction (FILE *, enum br_predictor, int, basic_block, int);\n static void predict_paths_leading_to (basic_block, int *, enum br_predictor, enum prediction);\n static void compute_function_frequency (void);\n static void choose_function_section (void);\n-static bool can_predict_insn_p (rtx);\n+static bool can_predict_insn_p (const_rtx);\n \n /* Information we hold about each branch predictor.\n    Filled using information from predict.def.  */\n@@ -111,7 +111,7 @@ static const struct predictor_info predictor_info[]= {\n    for maximal performance.  */\n \n bool\n-maybe_hot_bb_p (basic_block bb)\n+maybe_hot_bb_p (const_basic_block bb)\n {\n   if (profile_info && flag_branch_probabilities\n       && (bb->count\n@@ -132,7 +132,7 @@ maybe_hot_bb_p (basic_block bb)\n /* Return true in case BB is cold and should be optimized for size.  */\n \n bool\n-probably_cold_bb_p (basic_block bb)\n+probably_cold_bb_p (const_basic_block bb)\n {\n   if (profile_info && flag_branch_probabilities\n       && (bb->count\n@@ -148,7 +148,7 @@ probably_cold_bb_p (basic_block bb)\n \n /* Return true in case BB is probably never executed.  */\n bool\n-probably_never_executed_bb_p (basic_block bb)\n+probably_never_executed_bb_p (const_basic_block bb)\n {\n   if (profile_info && flag_branch_probabilities)\n     return ((bb->count + profile_info->runs / 2) / profile_info->runs) == 0;\n@@ -223,14 +223,14 @@ probability_reliable_p (int prob)\n \n /* Same predicate as above, working on edges.  */\n bool\n-edge_probability_reliable_p (edge e)\n+edge_probability_reliable_p (const_edge e)\n {\n   return probability_reliable_p (e->probability);\n }\n \n /* Same predicate as edge_probability_reliable_p, working on notes.  */\n bool\n-br_prob_note_reliable_p (rtx note)\n+br_prob_note_reliable_p (const_rtx note)\n {\n   gcc_assert (REG_NOTE_KIND (note) == REG_BR_PROB);\n   return probability_reliable_p (INTVAL (XEXP (note, 0)));\n@@ -358,7 +358,7 @@ clear_bb_predictions (basic_block bb)\n    At the moment we represent predictions only on conditional\n    jumps, not at computed jump or other complicated cases.  */\n static bool\n-can_predict_insn_p (rtx insn)\n+can_predict_insn_p (const_rtx insn)\n {\n   return (JUMP_P (insn)\n \t  && any_condjump_p (insn)"}, {"sha": "b9fc2ea116a2a8c23b55698f8b76f7fa3e416128", "filename": "gcc/regclass.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed7a4b4b30c6054ef0500d2fde45beba399da929/gcc%2Fregclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed7a4b4b30c6054ef0500d2fde45beba399da929/gcc%2Fregclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregclass.c?ref=ed7a4b4b30c6054ef0500d2fde45beba399da929", "patch": "@@ -262,7 +262,7 @@ unsigned char hard_regno_nregs[FIRST_PSEUDO_REGISTER][MAX_MACHINE_MODE];\n    with moving single words, but probably isn't worth the trouble.  */\n \n void\n-reg_set_to_hard_reg_set (HARD_REG_SET *to, bitmap from)\n+reg_set_to_hard_reg_set (HARD_REG_SET *to, const_bitmap from)\n {\n   unsigned i;\n   bitmap_iterator bi;"}, {"sha": "77a9e7e81ef7bf0f1232f07484f9169b8ca6da67", "filename": "gcc/resource.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed7a4b4b30c6054ef0500d2fde45beba399da929/gcc%2Fresource.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed7a4b4b30c6054ef0500d2fde45beba399da929/gcc%2Fresource.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fresource.c?ref=ed7a4b4b30c6054ef0500d2fde45beba399da929", "patch": "@@ -823,7 +823,7 @@ mark_set_resources (rtx x, struct resources *res, int in_dest,\n /* Return TRUE if INSN is a return, possibly with a filled delay slot.  */\n \n static bool\n-return_insn_p (rtx insn)\n+return_insn_p (const_rtx insn)\n {\n   if (JUMP_P (insn) && GET_CODE (PATTERN (insn)) == RETURN)\n     return true;"}, {"sha": "8bbbfaea122129e1228d027f6638a7807d44711b", "filename": "gcc/rtl.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed7a4b4b30c6054ef0500d2fde45beba399da929/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed7a4b4b30c6054ef0500d2fde45beba399da929/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=ed7a4b4b30c6054ef0500d2fde45beba399da929", "patch": "@@ -1688,13 +1688,13 @@ extern int reg_mentioned_p (const_rtx, const_rtx);\n extern int count_occurrences (const_rtx, const_rtx, int);\n extern int reg_referenced_p (const_rtx, const_rtx);\n extern int reg_used_between_p (const_rtx, const_rtx, const_rtx);\n-extern int reg_set_between_p (rtx, rtx, rtx);\n+extern int reg_set_between_p (const_rtx, const_rtx, const_rtx);\n extern int commutative_operand_precedence (rtx);\n extern bool swap_commutative_operands_p (rtx, rtx);\n extern int modified_between_p (rtx, rtx, rtx);\n extern int no_labels_between_p (const_rtx, const_rtx);\n extern int modified_in_p (rtx, rtx);\n-extern int reg_set_p (rtx, rtx);\n+extern int reg_set_p (const_rtx, const_rtx);\n extern rtx single_set_2 (const_rtx, const_rtx);\n extern int multiple_sets (const_rtx);\n extern int set_noop_p (const_rtx);\n@@ -2076,7 +2076,7 @@ extern rtx gen_const_mem (enum machine_mode, rtx);\n extern rtx gen_frame_mem (enum machine_mode, rtx);\n extern rtx gen_tmp_stack_mem (enum machine_mode, rtx);\n extern bool validate_subreg (enum machine_mode, enum machine_mode,\n-\t\t\t     rtx, unsigned int);\n+\t\t\t     const_rtx, unsigned int);\n \n /* In combine.c  */\n extern unsigned int extended_count (const_rtx, enum machine_mode, int);"}, {"sha": "b86add0ceb42f337b3ff6c43a046107d8353284d", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed7a4b4b30c6054ef0500d2fde45beba399da929/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed7a4b4b30c6054ef0500d2fde45beba399da929/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=ed7a4b4b30c6054ef0500d2fde45beba399da929", "patch": "@@ -802,9 +802,9 @@ reg_referenced_p (const_rtx x, const_rtx body)\n    FROM_INSN and TO_INSN (exclusive of those two).  */\n \n int\n-reg_set_between_p (rtx reg, rtx from_insn, rtx to_insn)\n+reg_set_between_p (const_rtx reg, const_rtx from_insn, const_rtx to_insn)\n {\n-  rtx insn;\n+  const_rtx insn;\n \n   if (from_insn == to_insn)\n     return 0;\n@@ -817,7 +817,7 @@ reg_set_between_p (rtx reg, rtx from_insn, rtx to_insn)\n \n /* Internals of reg_set_between_p.  */\n int\n-reg_set_p (rtx reg, rtx insn)\n+reg_set_p (const_rtx reg, const_rtx insn)\n {\n   /* We can be passed an insn or part of one.  If we are passed an insn,\n      check if a side-effect of the insn clobbers REG.  */"}, {"sha": "2f98c57b65c6b95d293d53c4ccda7e67fd899fc4", "filename": "gcc/tracer.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed7a4b4b30c6054ef0500d2fde45beba399da929/gcc%2Ftracer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed7a4b4b30c6054ef0500d2fde45beba399da929/gcc%2Ftracer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftracer.c?ref=ed7a4b4b30c6054ef0500d2fde45beba399da929", "patch": "@@ -50,9 +50,9 @@\n #include \"coverage.h\"\n #include \"tree-pass.h\"\n \n-static int count_insns (basic_block);\n-static bool ignore_bb_p (basic_block);\n-static bool better_p (edge, edge);\n+static int count_insns (const_basic_block);\n+static bool ignore_bb_p (const_basic_block);\n+static bool better_p (const_edge, const_edge);\n static edge find_best_successor (basic_block);\n static edge find_best_predecessor (basic_block);\n static int find_trace (basic_block, basic_block *);\n@@ -70,7 +70,7 @@ static int branch_ratio_cutoff;\n \n /* Return true if we should ignore the basic block for purposes of tracing.  */\n static bool\n-ignore_bb_p (basic_block bb)\n+ignore_bb_p (const_basic_block bb)\n {\n   if (bb->index < NUM_FIXED_BLOCKS)\n     return true;\n@@ -82,9 +82,9 @@ ignore_bb_p (basic_block bb)\n /* Return number of instructions in the block.  */\n \n static int\n-count_insns (basic_block bb)\n+count_insns (const_basic_block bb)\n {\n-  rtx insn;\n+  const_rtx insn;\n   int n = 0;\n \n   for (insn = BB_HEAD (bb);\n@@ -97,7 +97,7 @@ count_insns (basic_block bb)\n \n /* Return true if E1 is more frequent than E2.  */\n static bool\n-better_p (edge e1, edge e2)\n+better_p (const_edge e1, const_edge e2)\n {\n   if (e1->count != e2->count)\n     return e1->count > e2->count;"}, {"sha": "f5939f77c20c90f163e7b04b04293fb9e8a02871", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed7a4b4b30c6054ef0500d2fde45beba399da929/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed7a4b4b30c6054ef0500d2fde45beba399da929/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=ed7a4b4b30c6054ef0500d2fde45beba399da929", "patch": "@@ -3365,7 +3365,7 @@ verify_expr (tree *tp, int *walk_subtrees, void *data ATTRIBUTE_UNUSED)\n    if there is an error, otherwise false.  */\n \n static bool\n-verify_gimple_unary_expr (tree expr)\n+verify_gimple_unary_expr (const_tree expr)\n {\n   tree op = TREE_OPERAND (expr, 0);\n   tree type = TREE_TYPE (expr);\n@@ -3395,7 +3395,7 @@ verify_gimple_unary_expr (tree expr)\n    if there is an error, otherwise false.  */\n \n static bool\n-verify_gimple_binary_expr (tree expr)\n+verify_gimple_binary_expr (const_tree expr)\n {\n   tree op0 = TREE_OPERAND (expr, 0);\n   tree op1 = TREE_OPERAND (expr, 1);\n@@ -3906,7 +3906,7 @@ verify_gimple_expr (tree expr)\n    is an error, otherwise false.  */\n \n static bool\n-verify_gimple_modify_stmt (tree stmt)\n+verify_gimple_modify_stmt (const_tree stmt)\n {\n   tree lhs = GIMPLE_STMT_OPERAND (stmt, 0);\n   tree rhs = GIMPLE_STMT_OPERAND (stmt, 1);"}, {"sha": "d46cfda5529a8ff1f64732682c8e3a73936ac6c1", "filename": "gcc/tree-chrec.c", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed7a4b4b30c6054ef0500d2fde45beba399da929/gcc%2Ftree-chrec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed7a4b4b30c6054ef0500d2fde45beba399da929/gcc%2Ftree-chrec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-chrec.c?ref=ed7a4b4b30c6054ef0500d2fde45beba399da929", "patch": "@@ -45,7 +45,7 @@ along with GCC; see the file COPYING3.  If not see\n /* Determines whether CST is not a constant evolution.  */\n \n static inline bool\n-is_not_constant_evolution (tree cst)\n+is_not_constant_evolution (const_tree cst)\n {\n   return (TREE_CODE (cst) == POLYNOMIAL_CHREC);\n }\n@@ -835,7 +835,7 @@ chrec_merge (tree chrec1,\n /* Helper function for is_multivariate_chrec.  */\n \n static bool \n-is_multivariate_chrec_rec (tree chrec, unsigned int rec_var)\n+is_multivariate_chrec_rec (const_tree chrec, unsigned int rec_var)\n {\n   if (chrec == NULL_TREE)\n     return false;\n@@ -855,7 +855,7 @@ is_multivariate_chrec_rec (tree chrec, unsigned int rec_var)\n /* Determine whether the given chrec is multivariate or not.  */\n \n bool \n-is_multivariate_chrec (tree chrec)\n+is_multivariate_chrec (const_tree chrec)\n {\n   if (chrec == NULL_TREE)\n     return false;\n@@ -872,7 +872,7 @@ is_multivariate_chrec (tree chrec)\n /* Determines whether the chrec contains symbolic names or not.  */\n \n bool \n-chrec_contains_symbols (tree chrec)\n+chrec_contains_symbols (const_tree chrec)\n {\n   int i, n;\n \n@@ -898,7 +898,7 @@ chrec_contains_symbols (tree chrec)\n /* Determines whether the chrec contains undetermined coefficients.  */\n \n bool \n-chrec_contains_undetermined (tree chrec)\n+chrec_contains_undetermined (const_tree chrec)\n {\n   int i, n;\n \n@@ -920,7 +920,7 @@ chrec_contains_undetermined (tree chrec)\n    the tree.  */\n \n bool\n-tree_contains_chrecs (tree expr, int *size)\n+tree_contains_chrecs (const_tree expr, int *size)\n {\n   int i, n;\n \n@@ -995,7 +995,7 @@ evolution_function_is_invariant_p (tree chrec, int loopnum)\n    evolution.  */\n \n bool \n-evolution_function_is_affine_multivariate_p (tree chrec, int loopnum)\n+evolution_function_is_affine_multivariate_p (const_tree chrec, int loopnum)\n {\n   if (chrec == NULL_TREE)\n     return false;\n@@ -1040,7 +1040,7 @@ evolution_function_is_affine_multivariate_p (tree chrec, int loopnum)\n    variables.  */\n \n bool\n-evolution_function_is_univariate_p (tree chrec)\n+evolution_function_is_univariate_p (const_tree chrec)\n {\n   if (chrec == NULL_TREE)\n     return true;\n@@ -1103,7 +1103,7 @@ nb_vars_in_chrec (tree chrec)\n    arithmetics, even though it is a scalar type.  */\n \n static bool\n-avoid_arithmetics_in_type_p (tree type)\n+avoid_arithmetics_in_type_p (const_tree type)\n {\n   /* Ada frontend uses subtypes -- an arithmetic cannot be directly performed\n      in the subtype, but a base type must be used, and the result then can\n@@ -1362,8 +1362,7 @@ chrec_convert_aggressive (tree type, tree chrec)\n /* Returns true when CHREC0 == CHREC1.  */\n \n bool \n-eq_evolutions_p (tree chrec0, \n-\t\t tree chrec1)\n+eq_evolutions_p (const_tree chrec0, const_tree chrec1)\n {\n   if (chrec0 == NULL_TREE\n       || chrec1 == NULL_TREE\n@@ -1392,9 +1391,9 @@ eq_evolutions_p (tree chrec0,\n    which of these cases happens.  */\n \n enum ev_direction\n-scev_direction (tree chrec)\n+scev_direction (const_tree chrec)\n {\n-  tree step;\n+  const_tree step;\n \n   if (!evolution_function_is_affine_p (chrec))\n     return EV_DIR_UNKNOWN;"}, {"sha": "e84ecd76b0ca6c6674cc70c95b8cd57c31e27b76", "filename": "gcc/tree-chrec.h", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed7a4b4b30c6054ef0500d2fde45beba399da929/gcc%2Ftree-chrec.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed7a4b4b30c6054ef0500d2fde45beba399da929/gcc%2Ftree-chrec.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-chrec.h?ref=ed7a4b4b30c6054ef0500d2fde45beba399da929", "patch": "@@ -33,7 +33,7 @@ extern GTY(()) tree chrec_known;\n    include it in the following function.  */\n \n static inline bool\n-automatically_generated_chrec_p (tree chrec)\n+automatically_generated_chrec_p (const_tree chrec)\n {\n   return (chrec == chrec_dont_know\n \t  || chrec == chrec_known);\n@@ -42,7 +42,7 @@ automatically_generated_chrec_p (tree chrec)\n /* The tree nodes aka. CHRECs.  */\n \n static inline bool\n-tree_is_chrec (tree expr)\n+tree_is_chrec (const_tree expr)\n {\n   if (TREE_CODE (expr) == POLYNOMIAL_CHREC\n       || automatically_generated_chrec_p (expr))\n@@ -72,22 +72,22 @@ extern tree reset_evolution_in_loop (unsigned, tree, tree);\n extern tree chrec_merge (tree, tree);\n \n /* Observers.  */\n-extern bool eq_evolutions_p (tree, tree);\n-extern bool is_multivariate_chrec (tree);\n+extern bool eq_evolutions_p (const_tree, const_tree);\n+extern bool is_multivariate_chrec (const_tree);\n extern bool chrec_is_positive (tree, bool *);\n-extern bool chrec_contains_symbols (tree);\n-extern bool chrec_contains_symbols_defined_in_loop (tree, unsigned);\n-extern bool chrec_contains_undetermined (tree);\n-extern bool tree_contains_chrecs (tree, int *);\n-extern bool evolution_function_is_affine_multivariate_p (tree, int);\n-extern bool evolution_function_is_univariate_p (tree);\n+extern bool chrec_contains_symbols (const_tree);\n+extern bool chrec_contains_symbols_defined_in_loop (const_tree, unsigned);\n+extern bool chrec_contains_undetermined (const_tree);\n+extern bool tree_contains_chrecs (const_tree, int *);\n+extern bool evolution_function_is_affine_multivariate_p (const_tree, int);\n+extern bool evolution_function_is_univariate_p (const_tree);\n extern unsigned nb_vars_in_chrec (tree);\n extern bool evolution_function_is_invariant_p (tree, int);\n \n /* Determines whether CHREC is equal to zero.  */\n \n static inline bool \n-chrec_zerop (tree chrec)\n+chrec_zerop (const_tree chrec)\n {\n   if (chrec == NULL_TREE)\n     return false;\n@@ -147,7 +147,7 @@ build_polynomial_chrec (unsigned loop_num,\n /* Determines whether the expression CHREC is a constant.  */\n \n static inline bool \n-evolution_function_is_constant_p (tree chrec)\n+evolution_function_is_constant_p (const_tree chrec)\n {\n   if (chrec == NULL_TREE)\n     return false;\n@@ -166,7 +166,7 @@ evolution_function_is_constant_p (tree chrec)\n /* Determine whether the given tree is an affine evolution function or not.  */\n \n static inline bool \n-evolution_function_is_affine_p (tree chrec)\n+evolution_function_is_affine_p (const_tree chrec)\n {\n   if (chrec == NULL_TREE)\n     return false;\n@@ -191,7 +191,7 @@ evolution_function_is_affine_p (tree chrec)\n    function.  */\n \n static inline bool \n-evolution_function_is_affine_or_constant_p (tree chrec)\n+evolution_function_is_affine_or_constant_p (const_tree chrec)\n {\n   return evolution_function_is_affine_p (chrec) \n     || evolution_function_is_constant_p (chrec);\n@@ -200,15 +200,15 @@ evolution_function_is_affine_or_constant_p (tree chrec)\n /* Determines whether EXPR does not contains chrec expressions.  */\n \n static inline bool\n-tree_does_not_contain_chrecs (tree expr)\n+tree_does_not_contain_chrecs (const_tree expr)\n {\n   return !tree_contains_chrecs (expr, NULL);\n }\n \n /* Returns the type of the chrec.  */\n \n static inline tree\n-chrec_type (tree chrec)\n+chrec_type (const_tree chrec)\n {\n   if (automatically_generated_chrec_p (chrec))\n     return NULL_TREE;"}, {"sha": "4991937d2ec179253102b8d9ad3c36a78c64fb50", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 15, "deletions": 17, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed7a4b4b30c6054ef0500d2fde45beba399da929/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed7a4b4b30c6054ef0500d2fde45beba399da929/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=ed7a4b4b30c6054ef0500d2fde45beba399da929", "patch": "@@ -128,7 +128,7 @@ static bool subscript_dependence_tester_1 (struct data_dependence_relation *,\n /* Returns true iff A divides B.  */\n \n static inline bool \n-tree_fold_divides_p (tree a, tree b)\n+tree_fold_divides_p (const_tree a, const_tree b)\n {\n   gcc_assert (TREE_CODE (a) == INTEGER_CST);\n   gcc_assert (TREE_CODE (b) == INTEGER_CST);\n@@ -1040,7 +1040,7 @@ conflict_fn_no_dependence (void)\n /* Returns true if the address of OBJ is invariant in LOOP.  */\n \n static bool\n-object_address_invariant_in_loop_p (struct loop *loop, tree obj)\n+object_address_invariant_in_loop_p (const struct loop *loop, const_tree obj)\n {\n   while (handled_component_p (obj))\n     {\n@@ -1159,12 +1159,12 @@ disjoint_objects_p (tree a, tree b)\n    true otherwise.  */\n \n static bool\n-dr_may_alias_p (struct data_reference *a, struct data_reference *b)\n+dr_may_alias_p (const struct data_reference *a, const struct data_reference *b)\n {\n-  tree addr_a = DR_BASE_ADDRESS (a);\n-  tree addr_b = DR_BASE_ADDRESS (b);\n-  tree type_a, type_b;\n-  tree decl_a = NULL_TREE, decl_b = NULL_TREE;\n+  const_tree addr_a = DR_BASE_ADDRESS (a);\n+  const_tree addr_b = DR_BASE_ADDRESS (b);\n+  const_tree type_a, type_b;\n+  const_tree decl_a = NULL_TREE, decl_b = NULL_TREE;\n \n   /* If the sets of virtual operands are disjoint, the memory references do not\n      alias.  */\n@@ -1355,8 +1355,7 @@ non_affine_dependence_relation (struct data_dependence_relation *ddr)\n    variables, i.e., if the ZIV (Zero Index Variable) test is true.  */\n \n static inline bool\n-ziv_subscript_p (tree chrec_a, \n-\t\t tree chrec_b)\n+ziv_subscript_p (const_tree chrec_a, const_tree chrec_b)\n {\n   return (evolution_function_is_constant_p (chrec_a)\n \t  && evolution_function_is_constant_p (chrec_b));\n@@ -1366,8 +1365,7 @@ ziv_subscript_p (tree chrec_a,\n    variable, i.e., if the SIV (Single Index Variable) test is true.  */\n \n static bool\n-siv_subscript_p (tree chrec_a,\n-\t\t tree chrec_b)\n+siv_subscript_p (const_tree chrec_a, const_tree chrec_b)\n {\n   if ((evolution_function_is_constant_p (chrec_a)\n        && evolution_function_is_univariate_p (chrec_b))\n@@ -2416,7 +2414,7 @@ analyze_siv_subscript (tree chrec_a,\n    of CHREC does not divide CST, false otherwise.  */\n \n static bool\n-gcd_of_steps_may_divide_p (tree chrec, tree cst)\n+gcd_of_steps_may_divide_p (const_tree chrec, const_tree cst)\n {\n   HOST_WIDE_INT cd = 0, val;\n   tree step;\n@@ -2790,7 +2788,7 @@ build_classic_dist_vector_1 (struct data_dependence_relation *ddr,\n    same access functions.  */\n \n static bool\n-same_access_functions (struct data_dependence_relation *ddr)\n+same_access_functions (const struct data_dependence_relation *ddr)\n {\n   unsigned i;\n \n@@ -2805,7 +2803,7 @@ same_access_functions (struct data_dependence_relation *ddr)\n /* Return true when the DDR contains only constant access functions.  */\n \n static bool\n-constant_access_functions (struct data_dependence_relation *ddr)\n+constant_access_functions (const struct data_dependence_relation *ddr)\n {\n   unsigned i;\n \n@@ -3212,8 +3210,8 @@ subscript_dependence_tester (struct data_dependence_relation *ddr,\n    constant with respect to LOOP_NEST.  */\n \n static bool \n-access_functions_are_affine_or_constant_p (struct data_reference *a,\n-\t\t\t\t\t   struct loop *loop_nest)\n+access_functions_are_affine_or_constant_p (const struct data_reference *a,\n+\t\t\t\t\t   const struct loop *loop_nest)\n {\n   unsigned int i;\n   VEC(tree,heap) *fns = DR_ACCESS_FNS (a);\n@@ -4341,7 +4339,7 @@ free_data_refs (VEC (data_reference_p, heap) *datarefs)\n /* Returns the index of STMT in RDG.  */\n \n static int\n-find_vertex_for_stmt (struct graph *rdg, tree stmt)\n+find_vertex_for_stmt (const struct graph *rdg, const_tree stmt)\n {\n   int i;\n "}, {"sha": "ad0d18b8e937e9ff69fda539ee935d2d7ada7bbf", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed7a4b4b30c6054ef0500d2fde45beba399da929/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed7a4b4b30c6054ef0500d2fde45beba399da929/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=ed7a4b4b30c6054ef0500d2fde45beba399da929", "patch": "@@ -984,7 +984,7 @@ bool convert_affine_scev (struct loop *, tree, tree *, tree *, tree, bool);\n \n bool nowrap_type_p (tree);\n enum ev_direction {EV_DIR_GROWS, EV_DIR_DECREASES, EV_DIR_UNKNOWN};\n-enum ev_direction scev_direction (tree);\n+enum ev_direction scev_direction (const_tree);\n \n void free_numbers_of_iterations_estimates (void);\n void free_numbers_of_iterations_estimates_loop (struct loop *);"}, {"sha": "8e976e201fef594a5ede683c6a4c57c8f058afab", "filename": "gcc/tree-gimple.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed7a4b4b30c6054ef0500d2fde45beba399da929/gcc%2Ftree-gimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed7a4b4b30c6054ef0500d2fde45beba399da929/gcc%2Ftree-gimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-gimple.c?ref=ed7a4b4b30c6054ef0500d2fde45beba399da929", "patch": "@@ -202,7 +202,7 @@ is_gimple_min_invariant (const_tree t)\n bool\n is_gimple_stmt (tree t)\n {\n-  enum tree_code code = TREE_CODE (t);\n+  const enum tree_code code = TREE_CODE (t);\n \n   switch (code)\n     {"}, {"sha": "d01c663b2c5334d1e55fd7f7dad9994ff3aa8fa3", "filename": "gcc/tree-outof-ssa.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed7a4b4b30c6054ef0500d2fde45beba399da929/gcc%2Ftree-outof-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed7a4b4b30c6054ef0500d2fde45beba399da929/gcc%2Ftree-outof-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-outof-ssa.c?ref=ed7a4b4b30c6054ef0500d2fde45beba399da929", "patch": "@@ -795,7 +795,7 @@ same_stmt_list_p (edge e)\n /* Return TRUE if S1 and S2 are equivalent copies.  */\n \n static inline bool\n-identical_copies_p (tree s1, tree s2)\n+identical_copies_p (const_tree s1, const_tree s2)\n {\n #ifdef ENABLE_CHECKING\n   gcc_assert (TREE_CODE (s1) == GIMPLE_MODIFY_STMT);\n@@ -821,7 +821,7 @@ identical_copies_p (tree s1, tree s2)\n    contain the same sequence of copies.  */\n \n static inline bool \n-identical_stmt_lists_p (edge e1, edge e2)\n+identical_stmt_lists_p (const_edge e1, const_edge e2)\n {\n   tree t1 = PENDING_STMT (e1);\n   tree t2 = PENDING_STMT (e2);"}, {"sha": "b1c5f1fc524c53c4cc74ec00e303b4dd8b61e7f5", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed7a4b4b30c6054ef0500d2fde45beba399da929/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed7a4b4b30c6054ef0500d2fde45beba399da929/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=ed7a4b4b30c6054ef0500d2fde45beba399da929", "patch": "@@ -36,7 +36,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"value-prof.h\"\n \n /* Local functions, macros and variables.  */\n-static int op_prio (tree);\n+static int op_prio (const_tree);\n static const char *op_symbol (tree);\n static void pretty_print_string (pretty_printer *, const char*);\n static void print_call_name (pretty_printer *, tree);\n@@ -2291,7 +2291,7 @@ print_struct_decl (pretty_printer *buffer, tree node, int spc, int flags)\n    operators.  */\n \n static int\n-op_prio (tree op)\n+op_prio (const_tree op)\n {\n   if (op == NULL)\n     return 9999;"}, {"sha": "a3a08efcee948f30c024e0f9a38bfbf0047e1529", "filename": "gcc/tree-scalar-evolution.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed7a4b4b30c6054ef0500d2fde45beba399da929/gcc%2Ftree-scalar-evolution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed7a4b4b30c6054ef0500d2fde45beba399da929/gcc%2Ftree-scalar-evolution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-scalar-evolution.c?ref=ed7a4b4b30c6054ef0500d2fde45beba399da929", "patch": "@@ -353,7 +353,7 @@ find_var_scev_info (tree var)\n    LOOP_NB.  */\n \n bool \n-chrec_contains_symbols_defined_in_loop (tree chrec, unsigned loop_nb)\n+chrec_contains_symbols_defined_in_loop (const_tree chrec, unsigned loop_nb)\n {\n   int i, n;\n \n@@ -898,7 +898,7 @@ set_nb_iterations_in_loop (struct loop *loop,\n    EXPR.  */\n \n static bool\n-analyzable_condition (tree expr)\n+analyzable_condition (const_tree expr)\n {\n   tree condition;\n   \n@@ -1201,9 +1201,9 @@ follow_ssa_edge_in_rhs (struct loop *loop, tree at_stmt, tree rhs,\n /* Checks whether the I-th argument of a PHI comes from a backedge.  */\n \n static bool\n-backedge_phi_arg_p (tree phi, int i)\n+backedge_phi_arg_p (const_tree phi, int i)\n {\n-  edge e = PHI_ARG_EDGE (phi, i);\n+  const_edge e = PHI_ARG_EDGE (phi, i);\n \n   /* We would in fact like to test EDGE_DFS_BACK here, but we do not care\n      about updating it anywhere, and this should work as well most of the"}, {"sha": "797033ffb0ee975152d184762c41786ec0f679dd", "filename": "gcc/tree-scalar-evolution.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed7a4b4b30c6054ef0500d2fde45beba399da929/gcc%2Ftree-scalar-evolution.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed7a4b4b30c6054ef0500d2fde45beba399da929/gcc%2Ftree-scalar-evolution.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-scalar-evolution.h?ref=ed7a4b4b30c6054ef0500d2fde45beba399da929", "patch": "@@ -40,7 +40,7 @@ extern bool simple_iv (struct loop *, tree, tree, affine_iv *, bool);\n /* Returns the loop of the polynomial chrec CHREC.  */\n \n static inline struct loop *\n-get_chrec_loop (tree chrec)\n+get_chrec_loop (const_tree chrec)\n {\n   return get_loop (CHREC_VARIABLE (chrec));\n }"}, {"sha": "7a40991e22b83ea0032e135c7c34cd371dd1580c", "filename": "gcc/tree-ssa-operands.c", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed7a4b4b30c6054ef0500d2fde45beba399da929/gcc%2Ftree-ssa-operands.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed7a4b4b30c6054ef0500d2fde45beba399da929/gcc%2Ftree-ssa-operands.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-operands.c?ref=ed7a4b4b30c6054ef0500d2fde45beba399da929", "patch": "@@ -199,7 +199,7 @@ static VEC(scb_t,heap) *scb_stack;\n /* Return the DECL_UID of the base variable of T.  */\n \n static inline unsigned\n-get_name_decl (tree t)\n+get_name_decl (const_tree t)\n {\n   if (TREE_CODE (t) != SSA_NAME)\n     return DECL_UID (t);\n@@ -213,12 +213,10 @@ get_name_decl (tree t)\n static int\n operand_build_cmp (const void *p, const void *q)\n {\n-  tree e1 = *((const tree *)p);\n-  tree e2 = *((const tree *)q);\n-  unsigned int u1,u2;\n-\n-  u1 = get_name_decl (e1);\n-  u2 = get_name_decl (e2);\n+  const_tree const e1 = *((const_tree const *)p);\n+  const_tree const e2 = *((const_tree const *)q);\n+  const unsigned int u1 = get_name_decl (e1);\n+  const unsigned int u2 = get_name_decl (e2);\n \n   /* We want to sort in ascending order.  They can never be equal.  */\n #ifdef ENABLE_CHECKING"}, {"sha": "1d5500fe018a3221e9718aa86b11215bf6424272", "filename": "gcc/tree-ssa-threadupdate.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed7a4b4b30c6054ef0500d2fde45beba399da929/gcc%2Ftree-ssa-threadupdate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed7a4b4b30c6054ef0500d2fde45beba399da929/gcc%2Ftree-ssa-threadupdate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadupdate.c?ref=ed7a4b4b30c6054ef0500d2fde45beba399da929", "patch": "@@ -671,9 +671,9 @@ thread_single_edge (edge e)\n \n static basic_block dbds_ce_stop;\n static bool\n-dbds_continue_enumeration_p (basic_block bb, void *stop)\n+dbds_continue_enumeration_p (const_basic_block bb, const void *stop)\n {\n-  return (bb != (basic_block) stop\n+  return (bb != (const_basic_block) stop\n \t  && bb != dbds_ce_stop);\n }\n "}]}