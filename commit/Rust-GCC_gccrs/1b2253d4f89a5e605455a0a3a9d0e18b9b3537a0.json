{"sha": "1b2253d4f89a5e605455a0a3a9d0e18b9b3537a0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWIyMjUzZDRmODlhNWU2MDU0NTVhMGEzYTlkMGUxOGI5YjM1MzdhMA==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2013-04-03T13:41:13Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2013-04-03T13:41:13Z"}, "message": "re PR tree-optimization/56817 (ICE in hide_evolution_in_other_loops_than_loop)\n\n2013-04-03  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/56817\n\t* tree-ssa-loop-ivcanon.c (tree_unroll_loops_completely):\n\tSplit out ...\n\t(tree_unroll_loops_completely_1): ... new function to manually\n\twalk the loop tree, properly defering outer loops of unrolled\n\tloops to later iterations.\n\n\t* g++.dg/torture/pr56817.C: New testcase.\n\nFrom-SVN: r197411", "tree": {"sha": "e43fd5f30498046759be5fda1f8cf02f9c7f92ed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e43fd5f30498046759be5fda1f8cf02f9c7f92ed"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1b2253d4f89a5e605455a0a3a9d0e18b9b3537a0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b2253d4f89a5e605455a0a3a9d0e18b9b3537a0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1b2253d4f89a5e605455a0a3a9d0e18b9b3537a0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b2253d4f89a5e605455a0a3a9d0e18b9b3537a0/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "38000232d10a651d985f247550b2e41425150852", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38000232d10a651d985f247550b2e41425150852", "html_url": "https://github.com/Rust-GCC/gccrs/commit/38000232d10a651d985f247550b2e41425150852"}], "stats": {"total": 143, "additions": 112, "deletions": 31}, "files": [{"sha": "f6b00ca6700bf29e492ea1c37072a554d4246e35", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b2253d4f89a5e605455a0a3a9d0e18b9b3537a0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b2253d4f89a5e605455a0a3a9d0e18b9b3537a0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1b2253d4f89a5e605455a0a3a9d0e18b9b3537a0", "patch": "@@ -1,3 +1,12 @@\n+2013-04-03  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/56817\n+\t* tree-ssa-loop-ivcanon.c (tree_unroll_loops_completely):\n+\tSplit out ...\n+\t(tree_unroll_loops_completely_1): ... new function to manually\n+\twalk the loop tree, properly defering outer loops of unrolled\n+\tloops to later iterations.\n+\n 2013-04-03  Marc Glisse  <marc.glisse@inria.fr>\n \n \t* tree-vect-stmts.c (vectorizable_store): Accept BIT_FIELD_REF."}, {"sha": "d871b6e5960d814a90dd366e9e0e4f98aa8c7b79", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b2253d4f89a5e605455a0a3a9d0e18b9b3537a0/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b2253d4f89a5e605455a0a3a9d0e18b9b3537a0/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=1b2253d4f89a5e605455a0a3a9d0e18b9b3537a0", "patch": "@@ -1,3 +1,8 @@\n+2013-04-03  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/56817\n+\t* g++.dg/torture/pr56817.C: New testcase.\n+\n 2013-04-03  Marc Glisse  <marc.glisse@inria.fr>\n \n \t* gcc.dg/vect/bb-slp-31.c: New file."}, {"sha": "35fc6f74ff21eaa632bffc59af69351e10b3870a", "filename": "gcc/testsuite/g++.dg/torture/pr56817.C", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b2253d4f89a5e605455a0a3a9d0e18b9b3537a0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr56817.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b2253d4f89a5e605455a0a3a9d0e18b9b3537a0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr56817.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr56817.C?ref=1b2253d4f89a5e605455a0a3a9d0e18b9b3537a0", "patch": "@@ -0,0 +1,38 @@\n+// { dg-do compile }\n+// { dg-options \"--param max-unroll-times=32\" }\n+\n+struct A {};\n+A **q;\n+struct B\n+{\n+  A **j;\n+  B () { j = q; }\n+  A *& operator[] (unsigned long x) { return j[x]; }\n+};\n+struct C\n+{\n+  C (int r) : v (), s (r) {}\n+  A *& operator () (int i, int j) { return v[i * s + j]; }\n+  B v;\n+  int s;\n+};\n+struct D\n+{\n+  D ()\n+    {\n+      unsigned h = 2;\n+      for (int i = 0; i < 1; ++i, h *= 2)\n+\t{\n+\t  C w (h);\n+\t  for (unsigned j = 0; j < h; ++j)\n+\t    for (unsigned k = 0; k < h; ++k)\n+\t      w (j, k) = new A;\n+\t}\n+    }\n+};\n+void\n+foo ()\n+{\n+  for (int i = 0; i < 3; i++)\n+    A (), A (), D ();\n+}"}, {"sha": "c57e4f6a30d3ce727c15ee040debb8639d07635e", "filename": "gcc/tree-ssa-loop-ivcanon.c", "status": "modified", "additions": 60, "deletions": 31, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b2253d4f89a5e605455a0a3a9d0e18b9b3537a0/gcc%2Ftree-ssa-loop-ivcanon.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b2253d4f89a5e605455a0a3a9d0e18b9b3537a0/gcc%2Ftree-ssa-loop-ivcanon.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivcanon.c?ref=1b2253d4f89a5e605455a0a3a9d0e18b9b3537a0", "patch": "@@ -1097,6 +1097,63 @@ propagate_constants_for_unrolling (basic_block bb)\n     }\n }\n \n+/* Process loops from innermost to outer, stopping at the innermost\n+   loop we unrolled.  */\n+\n+static bool\n+tree_unroll_loops_completely_1 (bool may_increase_size, bool unroll_outer,\n+\t\t\t\tvec<loop_p, va_stack>& father_stack,\n+\t\t\t\tstruct loop *loop)\n+{\n+  struct loop *loop_father;\n+  bool changed = false;\n+  struct loop *inner;\n+  enum unroll_level ul;\n+\n+  /* Process inner loops first.  */\n+  for (inner = loop->inner; inner != NULL; inner = inner->next)\n+    changed |= tree_unroll_loops_completely_1 (may_increase_size,\n+\t\t\t\t\t       unroll_outer, father_stack,\n+\t\t\t\t\t       inner);\n+ \n+  /* If we changed an inner loop we cannot process outer loops in this\n+     iteration because SSA form is not up-to-date.  Continue with\n+     siblings of outer loops instead.  */\n+  if (changed)\n+    return true;\n+\n+  /* Try to unroll this loop.  */\n+  loop_father = loop_outer (loop);\n+  if (!loop_father)\n+    return false;\n+\n+  if (may_increase_size && optimize_loop_nest_for_speed_p (loop)\n+      /* Unroll outermost loops only if asked to do so or they do\n+\t not cause code growth.  */\n+      && (unroll_outer || loop_outer (loop_father)))\n+    ul = UL_ALL;\n+  else\n+    ul = UL_NO_GROWTH;\n+\n+  if (canonicalize_loop_induction_variables\n+        (loop, false, ul, !flag_tree_loop_ivcanon))\n+    {\n+      /* If we'll continue unrolling, we need to propagate constants\n+\t within the new basic blocks to fold away induction variable\n+\t computations; otherwise, the size might blow up before the\n+\t iteration is complete and the IR eventually cleaned up.  */\n+      if (loop_outer (loop_father) && !loop_father->aux)\n+\t{\n+\t  father_stack.safe_push (loop_father);\n+\t  loop_father->aux = loop_father;\n+\t}\n+\n+      return true;\n+    }\n+\n+  return false;\n+}\n+\n /* Unroll LOOPS completely if they iterate just few times.  Unless\n    MAY_INCREASE_SIZE is true, perform the unrolling only if the\n    size of the code does not increase.  */\n@@ -1105,10 +1162,7 @@ unsigned int\n tree_unroll_loops_completely (bool may_increase_size, bool unroll_outer)\n {\n   vec<loop_p, va_stack> father_stack;\n-  loop_iterator li;\n-  struct loop *loop;\n   bool changed;\n-  enum unroll_level ul;\n   int iteration = 0;\n   bool irred_invalidated = false;\n \n@@ -1124,34 +1178,9 @@ tree_unroll_loops_completely (bool may_increase_size, bool unroll_outer)\n       free_numbers_of_iterations_estimates ();\n       estimate_numbers_of_iterations ();\n \n-      FOR_EACH_LOOP (li, loop, LI_FROM_INNERMOST)\n-\t{\n-\t  struct loop *loop_father = loop_outer (loop);\n-\n-\t  if (may_increase_size && optimize_loop_nest_for_speed_p (loop)\n-\t      /* Unroll outermost loops only if asked to do so or they do\n-\t\t not cause code growth.  */\n-\t      && (unroll_outer || loop_outer (loop_father)))\n-\t    ul = UL_ALL;\n-\t  else\n-\t    ul = UL_NO_GROWTH;\n-\n-\t  if (canonicalize_loop_induction_variables\n-\t\t (loop, false, ul, !flag_tree_loop_ivcanon))\n-\t    {\n-\t      changed = true;\n-\t      /* If we'll continue unrolling, we need to propagate constants\n-\t\t within the new basic blocks to fold away induction variable\n-\t\t computations; otherwise, the size might blow up before the\n-\t\t iteration is complete and the IR eventually cleaned up.  */\n-\t      if (loop_outer (loop_father) && !loop_father->aux)\n-\t        {\n-\t\t  father_stack.safe_push (loop_father);\n-\t\t  loop_father->aux = loop_father;\n-\t\t}\n-\t    }\n-\t}\n-\n+      changed = tree_unroll_loops_completely_1 (may_increase_size,\n+\t\t\t\t\t\tunroll_outer, father_stack,\n+\t\t\t\t\t\tcurrent_loops->tree_root);\n       if (changed)\n \t{\n \t  struct loop **iter;"}]}