{"sha": "65a6f342653e7421f481f5dc3c79960edfd9599f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjVhNmYzNDI2NTNlNzQyMWY0ODFmNWRjM2M3OTk2MGVkZmQ5NTk5Zg==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2004-11-11T10:36:27Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2004-11-11T10:36:27Z"}, "message": "bitmap.h (nBITMAP_WORD_BITS): Remove.\n\n\t* bitmap.h (nBITMAP_WORD_BITS): Remove.\n\t(BITMAP_WORD_BITS): Force unsigned by use of 1u.\n\t(BITMAP_ELEMENT_WORDS, BITMAP_ELEMENT_ALL_BITS): Remove\n\tunnecessary casts.\n\t(bitmap_first_set_bit): Return unsigned, use ctzl.\n\t(bitmap_last_set_bit): Remove.\n\t* bitmap.c (bitmap_element_zerop, bitmap_copy): Make iterator\n\tunsigned.\n\t(bitmap_first_set_bit): Return unsigned, require non-empty bitmap,\n\tremove special case code for two word elements.\n\t(bitmap_last_set_bit): Remove.\n\t* ra-build.c (livethrough_conflicts_bb): Replace unnecessary use of\n\tbitmap_first_set_bit with bitmap_empty_p.\n\t* tree-outof-ssa.c (analyze_edges_for_bb): Likewise.\n\t* tree-ssa-pre.c (bitmap_print_value): Use simple flag rather than\n\tbitmap_last_bit_set.\n\nFrom-SVN: r90478", "tree": {"sha": "fd9d98f746f7a704c24f4125bc04202bcd0f7463", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fd9d98f746f7a704c24f4125bc04202bcd0f7463"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/65a6f342653e7421f481f5dc3c79960edfd9599f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65a6f342653e7421f481f5dc3c79960edfd9599f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/65a6f342653e7421f481f5dc3c79960edfd9599f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65a6f342653e7421f481f5dc3c79960edfd9599f/comments", "author": null, "committer": null, "parents": [{"sha": "af2a91bdce85a4bf9a5a1283b10e08e6cb3d7ae3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af2a91bdce85a4bf9a5a1283b10e08e6cb3d7ae3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/af2a91bdce85a4bf9a5a1283b10e08e6cb3d7ae3"}], "stats": {"total": 190, "additions": 74, "deletions": 116}, "files": [{"sha": "dcbf74b907d4a1ba94486728a5e9b37548ba363d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65a6f342653e7421f481f5dc3c79960edfd9599f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65a6f342653e7421f481f5dc3c79960edfd9599f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=65a6f342653e7421f481f5dc3c79960edfd9599f", "patch": "@@ -1,3 +1,22 @@\n+2004-11-11  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* bitmap.h (nBITMAP_WORD_BITS): Remove.\n+\t(BITMAP_WORD_BITS): Force unsigned by use of 1u.\n+\t(BITMAP_ELEMENT_WORDS, BITMAP_ELEMENT_ALL_BITS): Remove\n+\tunnecessary casts.\n+\t(bitmap_first_set_bit): Return unsigned, use ctzl.\n+\t(bitmap_last_set_bit): Remove.\n+\t* bitmap.c (bitmap_element_zerop, bitmap_copy): Make iterator\n+\tunsigned.\n+\t(bitmap_first_set_bit): Return unsigned, require non-empty bitmap,\n+\tremove special case code for two word elements.\n+\t(bitmap_last_set_bit): Remove.\n+\t* ra-build.c (livethrough_conflicts_bb): Replace unnecessary use of\n+\tbitmap_first_set_bit with bitmap_empty_p.\n+\t* tree-outof-ssa.c (analyze_edges_for_bb): Likewise.\n+\t* tree-ssa-pre.c (bitmap_print_value): Use simple flag rather than\n+\tbitmap_last_bit_set.\n+\n 2004-11-11  Nathan Sidwell  <nathan@codesourcery.com>\n \n \tPR target/16796"}, {"sha": "a067984457ec7c6920171295bc795e940a349c6b", "filename": "gcc/bitmap.c", "status": "modified", "additions": 41, "deletions": 98, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65a6f342653e7421f481f5dc3c79960edfd9599f/gcc%2Fbitmap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65a6f342653e7421f481f5dc3c79960edfd9599f/gcc%2Fbitmap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbitmap.c?ref=65a6f342653e7421f481f5dc3c79960edfd9599f", "patch": "@@ -174,7 +174,7 @@ bitmap_element_zerop (bitmap_element *element)\n #if BITMAP_ELEMENT_WORDS == 2\n   return (element->bits[0] | element->bits[1]) == 0;\n #else\n-  int i;\n+  unsigned i;\n \n   for (i = 0; i < BITMAP_ELEMENT_WORDS; i++)\n     if (element->bits[i] != 0)\n@@ -309,7 +309,7 @@ bitmap_copy (bitmap to, bitmap from)\n {\n   bitmap_element *from_ptr, *to_ptr = 0;\n #if BITMAP_ELEMENT_WORDS != 2\n-  int i;\n+  unsigned i;\n #endif\n \n   bitmap_clear (to);\n@@ -444,112 +444,55 @@ bitmap_bit_p (bitmap head, int bit)\n   return (ptr->bits[word_num] >> bit_num) & 1;\n }\n \f\n-/* Return the bit number of the first set bit in the bitmap, or -1\n-   if the bitmap is empty.  */\n+/* Return the bit number of the first set bit in the bitmap.  The\n+   bitmap must be non-empty.  */\n \n-int\n+unsigned\n bitmap_first_set_bit (bitmap a)\n {\n-  bitmap_element *ptr = a->first;\n+  bitmap_element *elt = a->first;\n+  unsigned bit_no;\n   BITMAP_WORD word;\n-  unsigned word_num, bit_num;\n-\n-  if (ptr == NULL)\n-    return -1;\n-\n-#if BITMAP_ELEMENT_WORDS == 2\n-  word_num = 0, word = ptr->bits[0];\n-  if (word == 0)\n-    word_num = 1, word = ptr->bits[1];\n-#else\n-  for (word_num = 0; word_num < BITMAP_ELEMENT_WORDS; ++word_num)\n-    if ((word = ptr->bits[word_num]) != 0)\n-      goto word_found;\n+  unsigned ix;\n+  \n+  gcc_assert (elt);\n+  bit_no = elt->indx * BITMAP_ELEMENT_ALL_BITS;\n+  for (ix = 0; ix != BITMAP_ELEMENT_WORDS; ix++)\n+    {\n+      word = elt->bits[ix];\n+      if (word)\n+\tgoto found_bit;\n+    }\n   gcc_unreachable ();\n- word_found:\n-#endif\n-\n-  /* Binary search for the first set bit.  */\n-  /* ??? It'd be nice to know if ffs or ffsl was available.  */\n-\n-  bit_num = 0;\n-  word = word & -word;\n-\n-#if nBITMAP_WORD_BITS > 64\n- #error \"Fill out the table.\"\n-#endif\n-#if nBITMAP_WORD_BITS > 32\n-  if ((word & 0xffffffff) == 0)\n-    word >>= 32, bit_num += 32;\n-#endif\n-  if ((word & 0xffff) == 0)\n-    word >>= 16, bit_num += 16;\n-  if ((word & 0xff) == 0)\n-    word >>= 8, bit_num += 8;\n-  if (word & 0xf0)\n-    bit_num += 4;\n-  if (word & 0xcc)\n-    bit_num += 2;\n-  if (word & 0xaa)\n-    bit_num += 1;\n-\n-  return (ptr->indx * BITMAP_ELEMENT_ALL_BITS\n-\t  + word_num * BITMAP_WORD_BITS\n-\t  + bit_num);\n-}\n-\n-/* Return the bit number of the last set bit in the bitmap, or -1\n-   if the bitmap is empty.  */\n-\n-int\n-bitmap_last_set_bit (bitmap a)\n-{\n-  bitmap_element *ptr = a->first;\n-  BITMAP_WORD word;\n-  unsigned word_num, bit_num;\n+ found_bit:\n+  bit_no += ix * BITMAP_WORD_BITS;\n \n-  if (ptr == NULL)\n-    return -1;\n-\n-  while (ptr->next != NULL)\n-    ptr = ptr->next;\n-\n-#if BITMAP_ELEMENT_WORDS == 2\n-  word_num = 1, word = ptr->bits[1];\n-  if (word == 0)\n-    word_num = 0, word = ptr->bits[0];\n+#if GCC_VERSION >= 3004\n+  gcc_assert (sizeof(long) == sizeof (word));\n+  bit_no += __builtin_ctzl (word);\n #else\n-  for (word_num = BITMAP_ELEMENT_WORDS; word_num-- > 0; )\n-    if ((word = ptr->bits[word_num]) != 0)\n-      goto word_found;\n-  gcc_unreachable ();\n- word_found:\n+  /* Binary search for the first set bit.  */\n+#if BITMAP_WORD_BITS > 64\n+#error \"Fill out the table.\"\n #endif\n-\n-  /* Binary search for the last set bit.  */\n-\n-  bit_num = 0;\n-#if nBITMAP_WORD_BITS > 64\n- #error \"Fill out the table.\"\n+#if BITMAP_WORD_BITS > 32\n+  if (!(word & 0xffffffff))\n+    word >>= 32, bit_no += 32;\n #endif\n-#if nBITMAP_WORD_BITS > 32\n-  if (word & ~(BITMAP_WORD)0xffffffff)\n-    word >>= 32, bit_num += 32;\n+  if (!(word & 0xffff))\n+    word >>= 16, bit_no += 16;\n+  if (!(word & 0xff))\n+    word >>= 8, bit_no += 8;\n+  if (!(word & 0xf))\n+    word >>= 4, bit_no += 4;\n+  if (!(word & 0x3))\n+    word >>= 2, bit_no += 2;\n+  if (!(word & 0x1))\n+    word >>= 1, bit_no += 1;\n+  \n+ gcc_assert (word & 1);\n #endif\n-  if (word & 0xffff0000)\n-    word >>= 16, bit_num += 16;\n-  if (word & 0xff00)\n-    word >>= 8, bit_num += 8;\n-  if (word & 0xf0)\n-    word >>= 4, bit_num += 4;\n-  if (word & 0xc)\n-    word >>= 2, bit_num += 2;\n-  if (word & 0x2)\n-    bit_num += 1;\n-\n-  return (ptr->indx * BITMAP_ELEMENT_ALL_BITS\n-\t  + word_num * BITMAP_WORD_BITS\n-\t  + bit_num);\n+ return bit_no;\n }\n \f\n "}, {"sha": "8732c3451aa6b0c5839b4b665c9d5f8e9ef33c65", "filename": "gcc/bitmap.h", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65a6f342653e7421f481f5dc3c79960edfd9599f/gcc%2Fbitmap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65a6f342653e7421f481f5dc3c79960edfd9599f/gcc%2Fbitmap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbitmap.h?ref=65a6f342653e7421f481f5dc3c79960edfd9599f", "patch": "@@ -24,24 +24,20 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \n /* Fundamental storage type for bitmap.  */\n \n-/* typedef unsigned HOST_WIDE_INT BITMAP_WORD; */\n-/* #define nBITMAP_WORD_BITS HOST_BITS_PER_WIDE_INT */\n typedef unsigned long BITMAP_WORD;\n-#define nBITMAP_WORD_BITS (CHAR_BIT * SIZEOF_LONG)\n-#define BITMAP_WORD_BITS (unsigned) nBITMAP_WORD_BITS\n+/* BITMAP_WORD_BITS needs to be unsigned, but cannot contain casts as\n+   it is used in preprocessor directives -- hence the 1u.  */\n+#define BITMAP_WORD_BITS (CHAR_BIT * SIZEOF_LONG * 1u)\n \n /* Number of words to use for each element in the linked list.  */\n \n #ifndef BITMAP_ELEMENT_WORDS\n-#define BITMAP_ELEMENT_WORDS ((128 + nBITMAP_WORD_BITS - 1) / nBITMAP_WORD_BITS)\n+#define BITMAP_ELEMENT_WORDS ((128 + BITMAP_WORD_BITS - 1) / BITMAP_WORD_BITS)\n #endif\n \n-/* Number of bits in each actual element of a bitmap.  We get slightly better\n-   code for bit % BITMAP_ELEMENT_ALL_BITS and bit / BITMAP_ELEMENT_ALL_BITS if\n-   bits is unsigned, assuming it is a power of 2.  */\n+/* Number of bits in each actual element of a bitmap.  */\n \n-#define BITMAP_ELEMENT_ALL_BITS \\\n-  ((unsigned) (BITMAP_ELEMENT_WORDS * BITMAP_WORD_BITS))\n+#define BITMAP_ELEMENT_ALL_BITS (BITMAP_ELEMENT_WORDS * BITMAP_WORD_BITS)\n \n /* Bitmap set element.  We use a linked list to hold only the bits that\n    are set.  This allows for use to grow the bitset dynamically without\n@@ -132,8 +128,7 @@ extern void bitmap_release_memory (void);\n /* A few compatibility/functions macros for compatibility with sbitmaps */\n #define dump_bitmap(file, bitmap) bitmap_print (file, bitmap, \"\", \"\\n\")\n #define bitmap_zero(a) bitmap_clear (a)\n-extern int bitmap_first_set_bit (bitmap);\n-extern int bitmap_last_set_bit (bitmap);\n+extern unsigned bitmap_first_set_bit (bitmap);\n \n /* Allocate a bitmap with oballoc.  */\n #define BITMAP_OBSTACK_ALLOC(OBSTACK)\t\t\t\t\\"}, {"sha": "20254ea2e86bec1527942991b59ed0d8b040b26d", "filename": "gcc/ra-build.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65a6f342653e7421f481f5dc3c79960edfd9599f/gcc%2Fra-build.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65a6f342653e7421f481f5dc3c79960edfd9599f/gcc%2Fra-build.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fra-build.c?ref=65a6f342653e7421f481f5dc3c79960edfd9599f", "patch": "@@ -1022,13 +1022,12 @@ livethrough_conflicts_bb (basic_block bb)\n   struct ra_bb_info *info = (struct ra_bb_info *) bb->aux;\n   rtx insn;\n   bitmap all_defs;\n-  int first;\n   unsigned use_id;\n   unsigned int deaths = 0;\n   unsigned int contains_call = 0;\n \n   /* If there are no deferred uses, just return.  */\n-  if ((first = bitmap_first_set_bit (info->live_throughout)) < 0)\n+  if (bitmap_empty_p (info->live_throughout))\n     return;\n \n   /* First collect the IDs of all defs, count the number of death\n@@ -1061,7 +1060,7 @@ livethrough_conflicts_bb (basic_block bb)\n     {\n       bitmap_iterator bi;\n \n-      EXECUTE_IF_SET_IN_BITMAP (info->live_throughout, first, use_id, bi)\n+      EXECUTE_IF_SET_IN_BITMAP (info->live_throughout, 0, use_id, bi)\n \t{\n \t  struct web_part *wp = &web_parts[df->def_id + use_id];\n \t  unsigned int bl = rtx_to_bits (DF_REF_REG (wp->ref));"}, {"sha": "39cf69f9ef9e1f26b2785b16a531f1659f1d87cc", "filename": "gcc/tree-outof-ssa.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65a6f342653e7421f481f5dc3c79960edfd9599f/gcc%2Ftree-outof-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65a6f342653e7421f481f5dc3c79960edfd9599f/gcc%2Ftree-outof-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-outof-ssa.c?ref=65a6f342653e7421f481f5dc3c79960edfd9599f", "patch": "@@ -2094,7 +2094,7 @@ analyze_edges_for_bb (basic_block bb, FILE *debug_file)\n #ifdef ENABLE_CHECKING\n       gcc_assert (VARRAY_ACTIVE_SIZE (edge_leader) == 0);\n       gcc_assert (VARRAY_ACTIVE_SIZE (stmt_list) == 0);\n-      gcc_assert (bitmap_first_set_bit (leader_has_match) == -1);\n+      gcc_assert (bitmap_empty_p (leader_has_match));\n #endif\n     }\n "}, {"sha": "8cc6263cd42c44cfba0202a0e4e9c6a91542f15c", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65a6f342653e7421f481f5dc3c79960edfd9599f/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65a6f342653e7421f481f5dc3c79960edfd9599f/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=65a6f342653e7421f481f5dc3c79960edfd9599f", "patch": "@@ -768,18 +768,20 @@ bitmap_print_value_set (FILE *outfile, bitmap_set_t set,\n   fprintf (outfile, \"%s[%d] := { \", setname, blockindex);\n   if (set)\n     {\n+      bool first;\n       unsigned i;\n       bitmap_iterator bi;\n \n       EXECUTE_IF_SET_IN_BITMAP (set->expressions, 0, i, bi)\n \t{\n+\t  if (!first)\n+\t    fprintf (outfile, \", \");\n+\t  first = false;\n \t  print_generic_expr (outfile, ssa_name (i), 0);\n \t\n \t  fprintf (outfile, \" (\");\n \t  print_generic_expr (outfile, get_value_handle (ssa_name (i)), 0);\n \t  fprintf (outfile, \") \");\n-\t  if (bitmap_last_set_bit (set->expressions) != (int)i)\n-\t    fprintf (outfile, \", \");\n \t}\n     }\n   fprintf (outfile, \" }\\n\");"}]}