{"sha": "1c7e67ca6425399306445a2987918af61bd5ae0f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWM3ZTY3Y2E2NDI1Mzk5MzA2NDQ1YTI5ODc5MThhZjYxYmQ1YWUwZg==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1993-08-24T19:43:07Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1993-08-24T19:43:07Z"}, "message": "-mlarge-align support; block profiling support\n\nFrom-SVN: r5208", "tree": {"sha": "905b1982bb24f0b6afc30bb64edf8fbca5083557", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/905b1982bb24f0b6afc30bb64edf8fbca5083557"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1c7e67ca6425399306445a2987918af61bd5ae0f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1c7e67ca6425399306445a2987918af61bd5ae0f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1c7e67ca6425399306445a2987918af61bd5ae0f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1c7e67ca6425399306445a2987918af61bd5ae0f/comments", "author": null, "committer": null, "parents": [{"sha": "0a7dd6e79ea22487032f1e66fc911f70e58cec2e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a7dd6e79ea22487032f1e66fc911f70e58cec2e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0a7dd6e79ea22487032f1e66fc911f70e58cec2e"}], "stats": {"total": 160, "additions": 159, "deletions": 1}, "files": [{"sha": "5886ff284e4dd50a75846a4580d115f7eeaa6233", "filename": "gcc/config/i386/osfrose.h", "status": "modified", "additions": 159, "deletions": 1, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c7e67ca6425399306445a2987918af61bd5ae0f/gcc%2Fconfig%2Fi386%2Fosfrose.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c7e67ca6425399306445a2987918af61bd5ae0f/gcc%2Fconfig%2Fi386%2Fosfrose.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fosfrose.h?ref=1c7e67ca6425399306445a2987918af61bd5ae0f", "patch": "@@ -38,6 +38,7 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #define MASK_ELF\t\t0x10000000\t/* ELF not rose */\n #define MASK_NO_IDENT\t\t0x08000000\t/* suppress .ident */\n #define MASK_NO_UNDERSCORES\t0x04000000\t/* suppress leading _ */\n+#define MASK_LARGE_ALIGN\t0x02000000\t/* align to >word boundaries */\n \n #define TARGET_HALF_PIC\t\t(target_flags & MASK_HALF_PIC)\n #define TARGET_DEBUG\t\t(target_flags & MASK_HALF_PIC_DEBUG)\n@@ -46,6 +47,7 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #define TARGET_ROSE\t\t((target_flags & MASK_ELF) == 0)\n #define TARGET_IDENT\t\t((target_flags & MASK_NO_IDENT) == 0)\n #define TARGET_UNDERSCORES\t((target_flags & MASK_NO_UNDERSCORES) == 0)\n+#define TARGET_LARGE_ALIGN\t(target_flags & MASK_LARGE_ALIGN)\n \n #undef\tSUBTARGET_SWITCHES\n #define SUBTARGET_SWITCHES \\\n@@ -58,7 +60,9 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n      { \"ident\",\t\t-MASK_NO_IDENT},\t\t\t\t\\\n      { \"no-ident\",\t MASK_NO_IDENT},\t\t\t\t\\\n      { \"underscores\",\t-MASK_NO_UNDERSCORES},\t\t\t\t\\\n-     { \"no-underscores\", MASK_NO_UNDERSCORES},\n+     { \"no-underscores\", MASK_NO_UNDERSCORES},\t\t\t\t\\\n+     { \"no-large-align\",-MASK_LARGE_ALIGN},\t\t\t\t\\\n+     { \"large-align\",\t MASK_LARGE_ALIGN},\n \n /* OSF/rose uses stabs, not dwarf.  */\n #define PREFERRED_DEBUGGING_TYPE DBX_DEBUG\n@@ -173,6 +177,92 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #undef  FUNCTION_PROFILER\n #define FUNCTION_PROFILER(FILE, LABELNO) fprintf (FILE, \"\\tcall _mcount\\n\")\n \n+/* A C statement or compound statement to output to FILE some\n+   assembler code to initialize basic-block profiling for the current\n+   object module.  This code should call the subroutine\n+   `__bb_init_func' once per object module, passing it as its sole\n+   argument the address of a block allocated in the object module.\n+\n+   The name of the block is a local symbol made with this statement:\n+\n+\tASM_GENERATE_INTERNAL_LABEL (BUFFER, \"LPBX\", 0);\n+\n+   Of course, since you are writing the definition of\n+   `ASM_GENERATE_INTERNAL_LABEL' as well as that of this macro, you\n+   can take a short cut in the definition of this macro and use the\n+   name that you know will result.\n+\n+   The first word of this block is a flag which will be nonzero if the\n+   object module has already been initialized.  So test this word\n+   first, and do not call `__bb_init_func' if the flag is nonzero.  */\n+\n+#undef\tFUNCTION_BLOCK_PROFILER\n+#define FUNCTION_BLOCK_PROFILER(STREAM, LABELNO)\t\t\t\\\n+do\t\t\t\t\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    if (!flag_pic)\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tfprintf (STREAM, \"\\tcmpl $0,%sPBX0\\n\", LPREFIX);\t\t\\\n+\tfprintf (STREAM, \"\\tjne 0f\\n\");\t\t\t\t\t\\\n+\tfprintf (STREAM, \"\\tpushl $%sPBX0\\n\", LPREFIX);\t\t\t\\\n+\tfprintf (STREAM, \"\\tcall %s__bb_init_func\\n\",\t\t\t\\\n+\t\t (TARGET_UNDERSCORES) ? \"_\" : \"\");\t\t\t\\\n+\tfprintf (STREAM, \"0:\\n\");\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+    else\t\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tfprintf (STREAM, \"\\tpushl %eax\\n\");\t\t\t\t\\\n+\tfprintf (STREAM, \"\\tmovl %sPBX0@GOT(%ebx),%eax\\n\");\t\t\\\n+\tfprintf (STREAM, \"\\tcmpl $0,(%eax)\\n\");\t\t\t\t\\\n+\tfprintf (STREAM, \"\\tjne 0f\\n\");\t\t\t\t\t\\\n+\tfprintf (STREAM, \"\\tpushl %eax\\n\");\t\t\t\t\\\n+\tfprintf (STREAM, \"\\tcall %s__bb_init_func@PLT\\n\",\t\t\\\n+\t\t (TARGET_UNDERSCORES) ? \"_\" : \"\");\t\t\t\\\n+\tfprintf (STREAM, \"0:\\n\");\t\t\t\t\t\\\n+\tfprintf (STREAM, \"\\tpopl %eax\\n\");\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+  }\t\t\t\t\t\t\t\t\t\\\n+while (0)\n+\n+/* A C statement or compound statement to increment the count\n+   associated with the basic block number BLOCKNO.  Basic blocks are\n+   numbered separately from zero within each compilation.  The count\n+   associated with block number BLOCKNO is at index BLOCKNO in a\n+   vector of words; the name of this array is a local symbol made\n+   with this statement:\n+\n+\tASM_GENERATE_INTERNAL_LABEL (BUFFER, \"LPBX\", 2);\n+\n+   Of course, since you are writing the definition of\n+   `ASM_GENERATE_INTERNAL_LABEL' as well as that of this macro, you\n+   can take a short cut in the definition of this macro and use the\n+   name that you know will result.  */\n+\n+#undef\tBLOCK_PROFILER\n+#define BLOCK_PROFILER(STREAM, BLOCKNO)\t\t\t\t\t\\\n+do\t\t\t\t\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    if (!flag_pic)\t\t\t\t\t\t\t\\\n+      fprintf (STREAM, \"\\tincl %sPBX2+%d\\n\", LPREFIX, (BLOCKNO)*4);\t\\\n+    else\t\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tfprintf (STREAM, \"\\tpushl %eax\\n\");\t\t\t\t\\\n+\tfprintf (STREAM, \"\\tmovl %sPBX2@GOT(%ebx),%eax\\n\", LPREFIX);\t\\\n+\tfprintf (STREAM, \"\\tincl %d(%eax)\\n\", (BLOCKNO)*4);\t\t\\\n+\tfprintf (STREAM, \"\\tpopl %eax\\n\");\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+  }\t\t\t\t\t\t\t\t\t\\\n+while (0)\n+\n+/* A C function or functions which are needed in the library to\n+   support block profiling.  When support goes into libc, undo\n+   the #if 0.  */\n+\n+#if 0\n+#undef\tBLOCK_PROFILING_CODE\n+#define\tBLOCK_PROFILING_CODE\n+#endif\n+\n /* Prefix for internally generated assembler labels.  If we aren't using\n    underscores, we are using prefix `.'s to identify labels that should\n    be ignored, as in `i386/gas.h' --karl@cs.umb.edu  */\n@@ -203,6 +293,39 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #define ASM_OUTPUT_LABELREF(FILE,NAME)\t\t\t\t\t\\\n   fprintf (FILE, \"%s%s\", (TARGET_UNDERSCORES) ? \"_\" : \"\", NAME)\n \n+/* A C expression to output text to align the location counter in the\n+   way that is desirable at a point in the code that is reached only\n+   by jumping.\n+\n+   This macro need not be defined if you don't want any special\n+   alignment to be done at such a time.  Most machine descriptions do\n+   not currently define the macro.  */\n+\n+#undef\tASM_OUTPUT_ALIGN_CODE\n+#define ASM_OUTPUT_ALIGN_CODE(STREAM)\t\t\t\t\t\\\n+  fprintf (STREAM, \"\\t.align\\t%d\\n\",\t\t\t\t\t\\\n+\t   (TARGET_486 && TARGET_LARGE_ALIGN) ? 4 : 2)\n+\n+/* A C expression to output text to align the location counter in the\n+   way that is desirable at the beginning of a loop.\n+\n+   This macro need not be defined if you don't want any special\n+   alignment to be done at such a time.  Most machine descriptions do\n+   not currently define the macro.  */\n+\n+#undef\tASM_OUTPUT_LOOP_ALIGN\n+#define ASM_OUTPUT_LOOP_ALIGN(STREAM) \\\n+  fprintf (STREAM, \"\\t.align\\t2\\n\")\n+\n+/* A C statement to output to the stdio stream STREAM an assembler\n+   command to advance the location counter to a multiple of 2 to the\n+   POWER bytes.  POWER will be a C expression of type `int'.  */\n+\n+#undef\tASM_OUTPUT_ALIGN\n+#define ASM_OUTPUT_ALIGN(STREAM, POWER)\t\t\t\t\t\\\n+  fprintf (STREAM, \"\\t.align\\t%d\\n\",\t\t\t\t\t\\\n+\t   (!TARGET_LARGE_ALIGN && (POWER) > 2) ? 2 : (POWER))\n+\n /* A C expression that is 1 if the RTX X is a constant which is a\n    valid address.  On most machines, this can be defined as\n    `CONSTANT_P (X)', but a few machines are more restrictive in\n@@ -347,6 +470,41 @@ do\t\t\t\t\t\t\t\t\t\\\n while (0)\n \n \n+/* On most machines, read-only variables, constants, and jump tables\n+   are placed in the text section.  If this is not the case on your\n+   machine, this macro should be defined to be the name of a function\n+   (either `data_section' or a function defined in `EXTRA_SECTIONS')\n+   that switches to the section to be used for read-only items.\n+\n+   If these items should be placed in the text section, this macro\n+   should not be defined.  */\n+\n+#if 0\n+#undef\tREADONLY_DATA_SECTION\n+#define READONLY_DATA_SECTION()\t\t\t\t\t\t\\\n+do\t\t\t\t\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    if (TARGET_ELF)\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tif (in_section != in_rodata)\t\t\t\t\t\\\n+\t  {\t\t\t\t\t\t\t\t\\\n+\t    fprintf (asm_out_file, \"\\t.section \\\"rodata\\\"\\n\");\t\t\\\n+\t    in_section = in_rodata;\t\t\t\t\t\\\n+\t  }\t\t\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+    else\t\t\t\t\t\t\t\t\\\n+      text_section ();\t\t\t\t\t\t\t\\\n+  }\t\t\t\t\t\t\t\t\t\\\n+while (0)\n+#endif\n+\n+/* A list of names for sections other than the standard two, which are\n+   `in_text' and `in_data'.  You need not define this macro on a\n+   system with no other sections (that GCC needs to use).  */\n+\n+#undef\tEXTRA_SECTIONS\n+#define\tEXTRA_SECTIONS in_rodata, in_data1\n+\n /* Given a decl node or constant node, choose the section to output it in\n    and select that section.  */\n "}]}