{"sha": "6ff9d29412643e24f930933526a837238227c68d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmZmOWQyOTQxMjY0M2UyNGY5MzA5MzM1MjZhODM3MjM4MjI3YzY4ZA==", "commit": {"author": {"name": "Oleg Endo", "email": "oleg.endo@t-online.de", "date": "2011-10-15T02:32:53Z"}, "committer": {"name": "Kaz Kojima", "email": "kkojima@gcc.gnu.org", "date": "2011-10-15T02:32:53Z"}, "message": "re PR target/49263 (SH Target: underutilized \"TST #imm, R0\" instruction)\n\n\tPR target/49263\n\t* config/sh/sh.h (ZERO_EXTRACT_ANDMASK): New macro.\n\t* config/sh/sh.c (sh_rtx_costs): Add test instruction case.\n\t* config/sh/sh.md (tstsi_t): Name existing insn.  Make inner\n\tand instruction commutative.\n\t(tsthi_t, tstqi_t, tstqi_t_zero, tstsi_t_and_not,\n\ttstsi_t_zero_extract_eq, tstsi_t_zero_extract_xor,\n\ttstsi_t_zero_extract_subreg_xor_little,\n\ttstsi_t_zero_extract_subreg_xor_big): New insns.\n\t(*movsicc_t_false, *movsicc_t_true): Replace space with tab in\n\tasm output.\n\t(*andsi_compact): Reorder alternatives so that K08 is considered\n\tfirst.\n\t* gcc.target/sh/pr49263.c: New.\n\nFrom-SVN: r180020", "tree": {"sha": "ac691d12707f29a7d4e513210d069f96be3bfa3a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ac691d12707f29a7d4e513210d069f96be3bfa3a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6ff9d29412643e24f930933526a837238227c68d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ff9d29412643e24f930933526a837238227c68d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6ff9d29412643e24f930933526a837238227c68d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ff9d29412643e24f930933526a837238227c68d/comments", "author": {"login": "olegendo", "id": 1380209, "node_id": "MDQ6VXNlcjEzODAyMDk=", "avatar_url": "https://avatars.githubusercontent.com/u/1380209?v=4", "gravatar_id": "", "url": "https://api.github.com/users/olegendo", "html_url": "https://github.com/olegendo", "followers_url": "https://api.github.com/users/olegendo/followers", "following_url": "https://api.github.com/users/olegendo/following{/other_user}", "gists_url": "https://api.github.com/users/olegendo/gists{/gist_id}", "starred_url": "https://api.github.com/users/olegendo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/olegendo/subscriptions", "organizations_url": "https://api.github.com/users/olegendo/orgs", "repos_url": "https://api.github.com/users/olegendo/repos", "events_url": "https://api.github.com/users/olegendo/events{/privacy}", "received_events_url": "https://api.github.com/users/olegendo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "94a39b90ce90b6da1069fe3d7c0360571e73ffdc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/94a39b90ce90b6da1069fe3d7c0360571e73ffdc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/94a39b90ce90b6da1069fe3d7c0360571e73ffdc"}], "stats": {"total": 201, "additions": 194, "deletions": 7}, "files": [{"sha": "8eac26e1e8ed6e367db242a0717bc943c6eeccd8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ff9d29412643e24f930933526a837238227c68d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ff9d29412643e24f930933526a837238227c68d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6ff9d29412643e24f930933526a837238227c68d", "patch": "@@ -1,3 +1,19 @@\n+2011-10-15  Oleg Endo  <oleg.endo@t-online.de>\n+\n+\tPR target/49263\n+\t* config/sh/sh.h (ZERO_EXTRACT_ANDMASK): New macro.\n+\t* config/sh/sh.c (sh_rtx_costs): Add test instruction case.\n+\t* config/sh/sh.md (tstsi_t): Name existing insn.  Make inner\n+\tand instruction commutative.\n+\t(tsthi_t, tstqi_t, tstqi_t_zero, tstsi_t_and_not,\n+\ttstsi_t_zero_extract_eq, tstsi_t_zero_extract_xor,\n+\ttstsi_t_zero_extract_subreg_xor_little,\n+\ttstsi_t_zero_extract_subreg_xor_big): New insns.\n+\t(*movsicc_t_false, *movsicc_t_true): Replace space with tab in\n+\tasm output.\n+\t(*andsi_compact): Reorder alternatives so that K08 is considered\n+\tfirst.\n+\n 2011-10-14  Eric Botcazou  <ebotcazou@adacore.com>\n \n \tPR target/50354"}, {"sha": "03c3c48c0e4ad3d0cf291725db3eeb81226f06ba", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ff9d29412643e24f930933526a837238227c68d/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ff9d29412643e24f930933526a837238227c68d/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=6ff9d29412643e24f930933526a837238227c68d", "patch": "@@ -242,7 +242,7 @@ static void sh_file_start (void);\n static int flow_dependent_p (rtx, rtx);\n static void flow_dependent_p_1 (rtx, const_rtx, void *);\n static int shiftcosts (rtx);\n-static int and_xor_ior_costs (rtx, int code);\n+static int and_xor_ior_costs (rtx, int);\n static int addsubcosts (rtx);\n static int multcosts (rtx);\n static bool unspec_caller_rtx_p (rtx);\n@@ -2995,6 +2995,20 @@ sh_rtx_costs (rtx x, int code, int outer_code, int opno ATTRIBUTE_UNUSED,\n         *total = 8;\n       return true;\n \n+    case EQ:\n+      /* An and with a constant compared against zero is\n+\t most likely going to be a TST #imm, R0 instruction.\n+\t Notice that this does not catch the zero_extract variants from\n+\t the md file.  */\n+      if (GET_CODE (XEXP (x, 0)) == AND\n+\t  && CONST_INT_P (XEXP (x, 1)) && INTVAL (XEXP (x, 1)) == 0)\n+\t{\n+\t  *total = 1;\n+\t  return true;\n+\t}\n+      else\n+\treturn false;\n+\n     case CONST:\n     case LABEL_REF:\n     case SYMBOL_REF:"}, {"sha": "1e654801334057d5f21938a139661859e9291f9e", "filename": "gcc/config/sh/sh.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ff9d29412643e24f930933526a837238227c68d/gcc%2Fconfig%2Fsh%2Fsh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ff9d29412643e24f930933526a837238227c68d/gcc%2Fconfig%2Fsh%2Fsh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.h?ref=6ff9d29412643e24f930933526a837238227c68d", "patch": "@@ -1195,6 +1195,9 @@ extern enum reg_class regno_reg_class[FIRST_PSEUDO_REGISTER];\n #define CONST_OK_FOR_K08(VALUE) (((HOST_WIDE_INT)(VALUE))>= 0 \\\n \t\t\t\t && ((HOST_WIDE_INT)(VALUE)) <= 255)\n \n+#define ZERO_EXTRACT_ANDMASK(EXTRACT_SZ_RTX, EXTRACT_POS_RTX)\\\n+  (((1 << INTVAL (EXTRACT_SZ_RTX)) - 1) << INTVAL (EXTRACT_POS_RTX))\n+\n #if 0\n #define SECONDARY_INOUT_RELOAD_CLASS(CLASS,MODE,X,ELSE) \\\n   ((((REGCLASS_HAS_FP_REG (CLASS) \t\t\t\t\t\\"}, {"sha": "ce660185dd386595c77cbb9238e93ab601a669c9", "filename": "gcc/config/sh/sh.md", "status": "modified", "additions": 155, "deletions": 6, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ff9d29412643e24f930933526a837238227c68d/gcc%2Fconfig%2Fsh%2Fsh.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ff9d29412643e24f930933526a837238227c68d/gcc%2Fconfig%2Fsh%2Fsh.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.md?ref=6ff9d29412643e24f930933526a837238227c68d", "patch": "@@ -585,15 +585,164 @@\n ;; SImode signed integer comparisons\n ;; -------------------------------------------------------------------------\n \n-(define_insn \"\"\n+;; Various patterns to generate the TST #imm, R0 instruction.\n+;; Although this adds some pressure on the R0 register, it can potentially\n+;; result in faster code, even if the operand has to be moved to R0 first.\n+;; This is because on SH4 TST #imm, R0 and MOV Rm, Rn are both MT group \n+;; instructions and thus will be executed in parallel.  On SH4A TST #imm, R0\n+;; is an EX group instruction but still can be executed in parallel with the\n+;; MT group MOV Rm, Rn instruction.\n+\n+;; Usual TST #imm, R0 patterns for SI, HI and QI\n+;; This is usually used for bit patterns other than contiguous bits \n+;; and single bits.\n+\n+(define_insn \"tstsi_t\"\n   [(set (reg:SI T_REG)\n-\t(eq:SI (and:SI (match_operand:SI 0 \"arith_reg_operand\" \"z,r\")\n+\t(eq:SI (and:SI (match_operand:SI 0 \"logical_operand\" \"%z,r\")\n \t\t       (match_operand:SI 1 \"logical_operand\" \"K08,r\"))\n \t       (const_int 0)))]\n   \"TARGET_SH1\"\n   \"tst\t%1,%0\"\n   [(set_attr \"type\" \"mt_group\")])\n \n+(define_insn \"tsthi_t\"\n+  [(set (reg:SI T_REG)\n+\t(eq:SI (subreg:SI (and:HI (match_operand:HI 0 \"logical_operand\" \"%z\")\n+\t\t\t\t  (match_operand 1 \"const_int_operand\")) 0)\n+\t       (const_int 0)))]\n+  \"TARGET_SH1\n+   && CONST_OK_FOR_K08 (INTVAL (operands[1]))\"\n+  \"tst\t%1,%0\"\n+  [(set_attr \"type\" \"mt_group\")])\n+\n+(define_insn \"tstqi_t\"\n+  [(set (reg:SI T_REG)\n+\t(eq:SI (subreg:SI (and:QI (match_operand:QI 0 \"logical_operand\" \"%z\")\n+\t\t\t\t  (match_operand 1 \"const_int_operand\")) 0)\n+\t       (const_int 0)))]\n+  \"TARGET_SH1\n+   && (CONST_OK_FOR_K08 (INTVAL (operands[1])) \n+       || CONST_OK_FOR_I08 (INTVAL (operands[1])))\"\n+{\n+  operands[1] = GEN_INT (INTVAL (operands[1]) & 255);\n+  return \"tst\t%1,%0\";\n+}\n+  [(set_attr \"type\" \"mt_group\")])\n+\n+;; Test low QI subreg against zero.\n+;; This avoids unecessary zero extension before the test.\n+\n+(define_insn \"tstqi_t_zero\"\n+  [(set (reg:SI T_REG)\n+\t(eq:SI (match_operand:QI 0 \"logical_operand\" \"z\") (const_int 0)))]\n+  \"TARGET_SH1\"\n+  \"tst\t#255,%0\"\n+  [(set_attr \"type\" \"mt_group\")])\n+\n+;; Extract LSB, negate and store in T bit.\n+\n+(define_insn \"tstsi_t_and_not\"\n+  [(set (reg:SI T_REG)\n+\t (and:SI (not:SI (match_operand:SI 0 \"logical_operand\" \"z\"))\n+\t\t (const_int 1)))]\n+  \"TARGET_SH1\"\n+  \"tst\t#1,%0\"\n+  [(set_attr \"type\" \"mt_group\")])\n+\n+;; Extract contiguous bits and compare them against zero.\n+\n+(define_insn \"tstsi_t_zero_extract_eq\"\n+  [(set (reg:SI T_REG)\n+\t(eq:SI (zero_extract:SI (match_operand 0 \"logical_operand\" \"z\")\n+\t\t(match_operand:SI 1 \"const_int_operand\")\n+\t\t(match_operand:SI 2 \"const_int_operand\"))\n+         (const_int 0)))]\n+  \"TARGET_SH1\n+   && CONST_OK_FOR_K08 (ZERO_EXTRACT_ANDMASK (operands[1], operands[2]))\"\n+{\n+  operands[1] = GEN_INT (ZERO_EXTRACT_ANDMASK (operands[1], operands[2]));\n+  return \"tst\t%1,%0\";\n+}\n+  [(set_attr \"type\" \"mt_group\")])\n+\n+;; This split is required when testing bits in a QI subreg.\n+\n+(define_split\n+  [(set (reg:SI T_REG)\n+   (eq:SI (if_then_else:SI (zero_extract:SI\n+\t\t\t    (match_operand 0 \"logical_operand\" \"\")\n+\t\t\t    (match_operand 1 \"const_int_operand\")\n+\t\t\t    (match_operand 2 \"const_int_operand\"))\n+\t\t\t   (match_operand 3 \"const_int_operand\")\n+\t\t\t   (const_int 0))\n+\t  (const_int 0)))]\n+  \"TARGET_SH1\n+   && ZERO_EXTRACT_ANDMASK (operands[1], operands[2]) == INTVAL (operands[3])\n+   && CONST_OK_FOR_K08 (INTVAL (operands[3]))\"\n+  [(set (reg:SI T_REG) (eq:SI (and:SI (match_dup 0) (match_dup 3))\n+\t\t\t      (const_int 0)))]\n+  \"\n+{\n+  if (GET_MODE (operands[0]) == QImode)\n+    operands[0] = simplify_gen_subreg (SImode, operands[0], QImode, 0);\n+}\")\n+\n+;; Extract single bit, negate and store it in the T bit.\n+;; Not used for SH4A.\n+\n+(define_insn \"tstsi_t_zero_extract_xor\"\n+  [(set (reg:SI T_REG)\n+\t(zero_extract:SI (xor:SI (match_operand:SI 0 \"logical_operand\" \"z\")\n+\t\t\t  (match_operand:SI 3 \"const_int_operand\"))\n+\t\t\t (match_operand:SI 1 \"const_int_operand\")\n+\t\t\t (match_operand:SI 2 \"const_int_operand\")))]\n+  \"TARGET_SH1\n+   && ZERO_EXTRACT_ANDMASK (operands[1], operands[2]) == INTVAL (operands[3])\n+   && CONST_OK_FOR_K08 (INTVAL (operands[3]))\"\n+  \"tst\t%3,%0\"\n+  [(set_attr \"type\" \"mt_group\")])\n+\n+;; Extract single bit, negate and store it in the T bit.\n+;; Used for SH4A little endian.\n+\n+(define_insn \"tstsi_t_zero_extract_subreg_xor_little\"\n+  [(set (reg:SI T_REG)\n+\t(zero_extract:SI\n+\t (subreg:QI (xor:SI (match_operand:SI 0 \"logical_operand\" \"z\")\n+\t\t\t    (match_operand:SI 3 \"const_int_operand\")) 0)\n+\t (match_operand:SI 1 \"const_int_operand\")\n+\t (match_operand:SI 2 \"const_int_operand\")))]\n+  \"TARGET_SH1 && TARGET_LITTLE_ENDIAN\n+   && ZERO_EXTRACT_ANDMASK (operands[1], operands[2])\n+      == (INTVAL (operands[3]) & 255)\n+   && CONST_OK_FOR_K08 (INTVAL (operands[3]) & 255)\"\n+{\n+  operands[3] = GEN_INT (INTVAL (operands[3]) & 255);\n+  return \"tst\t%3,%0\";\n+}\n+  [(set_attr \"type\" \"mt_group\")])\n+\n+;; Extract single bit, negate and store it in the T bit.\n+;; Used for SH4A big endian.\n+\n+(define_insn \"tstsi_t_zero_extract_subreg_xor_big\"\n+  [(set (reg:SI T_REG)\n+\t(zero_extract:SI\n+\t (subreg:QI (xor:SI (match_operand:SI 0 \"logical_operand\" \"z\")\n+\t\t\t    (match_operand:SI 3 \"const_int_operand\")) 3)\n+\t (match_operand:SI 1 \"const_int_operand\")\n+\t (match_operand:SI 2 \"const_int_operand\")))]\n+  \"TARGET_SH1 && ! TARGET_LITTLE_ENDIAN\n+   && ZERO_EXTRACT_ANDMASK (operands[1], operands[2])\n+      == (INTVAL (operands[3]) & 255)\n+   && CONST_OK_FOR_K08 (INTVAL (operands[3]) & 255)\"\n+{\n+  operands[3] = GEN_INT (INTVAL (operands[3]) & 255);\n+  return \"tst\t%3,%0\";\n+}\n+  [(set_attr \"type\" \"mt_group\")])\n+\n ;; ??? Perhaps should only accept reg/constant if the register is reg 0.\n ;; That would still allow reload to create cmpi instructions, but would\n ;; perhaps allow forcing the constant into a register when that is better.\n@@ -1157,7 +1306,7 @@\n    && (arith_reg_operand (operands[1], SImode)\n        || (immediate_operand (operands[1], SImode)\n \t   && satisfies_constraint_I08 (operands[1])))\"\n-  \"bt 0f\\;mov %1,%0\\\\n0:\"\n+  \"bt\t0f\\;mov\t%1,%0\\\\n0:\"\n   [(set_attr \"type\" \"mt_group,arith\") ;; poor approximation\n    (set_attr \"length\" \"4\")])\n \n@@ -1170,7 +1319,7 @@\n    && (arith_reg_operand (operands[1], SImode)\n        || (immediate_operand (operands[1], SImode)\n \t   && satisfies_constraint_I08 (operands[1])))\"\n-  \"bf 0f\\;mov %1,%0\\\\n0:\"\n+  \"bf\t0f\\;mov\t%1,%0\\\\n0:\"\n   [(set_attr \"type\" \"mt_group,arith\") ;; poor approximation\n    (set_attr \"length\" \"4\")])\n \n@@ -3015,9 +3164,9 @@ label:\n ;; -------------------------------------------------------------------------\n \n (define_insn \"*andsi3_compact\"\n-  [(set (match_operand:SI 0 \"arith_reg_dest\" \"=r,z\")\n+  [(set (match_operand:SI 0 \"arith_reg_dest\" \"=z,r\")\n \t(and:SI (match_operand:SI 1 \"arith_reg_operand\" \"%0,0\")\n-\t\t(match_operand:SI 2 \"logical_operand\" \"r,K08\")))]\n+\t\t(match_operand:SI 2 \"logical_operand\" \"K08,r\")))]\n   \"TARGET_SH1\"\n   \"and\t%2,%0\"\n   [(set_attr \"type\" \"arith\")])"}, {"sha": "c89e644d3d71137994a02be7901b317f9fd18208", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ff9d29412643e24f930933526a837238227c68d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ff9d29412643e24f930933526a837238227c68d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=6ff9d29412643e24f930933526a837238227c68d", "patch": "@@ -1,3 +1,8 @@\n+2011-10-15  Oleg Endo  <oleg.endo@t-online.de>\n+\n+\tPR target/49263\n+\t* gcc.target/sh/pr49263.c: New.\n+\n 2011-10-14  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gnat.dg/specs/debug1.ads: Tweak."}]}