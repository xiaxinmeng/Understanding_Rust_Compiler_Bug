{"sha": "95a3261e82558f703e885f5e2d772d6a7e31b255", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTVhMzI2MWU4MjU1OGY3MDNlODg1ZjVlMmQ3NzJkNmE3ZTMxYjI1NQ==", "commit": {"author": {"name": "H.J. Lu", "email": "hongjiu.lu@intel.com", "date": "2007-06-02T13:45:18Z"}, "committer": {"name": "H.J. Lu", "email": "hjl@gcc.gnu.org", "date": "2007-06-02T13:45:18Z"}, "message": "sse4_2-check.h: New.\n\n2007-06-02  H.J. Lu  <hongjiu.lu@intel.com>\n\n\t* gcc.target/i386/sse4_2-check.h: New.\n\t* gcc.target/i386/sse4_2-crc32b.c: Likewise.\n\t* gcc.target/i386/sse4_2-crc32.h: Likewise.\n\t* gcc.target/i386/sse4_2-crc32l.c: Likewise.\n\t* gcc.target/i386/sse4_2-crc32q.c: Likewise.\n\t* gcc.target/i386/sse4_2-crc32w.c: Likewise.\n\t* gcc.target/i386/sse4_2-pcmpestri-1.c: Likewise.\n\t* gcc.target/i386/sse4_2-pcmpestri-2.c: Likewise.\n\t* gcc.target/i386/sse4_2-pcmpestrm-1.c: Likewise.\n\t* gcc.target/i386/sse4_2-pcmpestrm-2.c: Likewise.\n\t* gcc.target/i386/sse4_2-pcmpgtq.c: Likewise.\n\t* gcc.target/i386/sse4_2-pcmpistri-1.c: Likewise.\n\t* gcc.target/i386/sse4_2-pcmpistri-2.c: Likewise.\n\t* gcc.target/i386/sse4_2-pcmpistrm-1.c: Likewise.\n\t* gcc.target/i386/sse4_2-pcmpistrm-2.c: Likewise.\n\t* gcc.target/i386/sse4_2-pcmpstr.h: Likewise.\n\t* gcc.target/i386/sse4_2-popcnt.h: Likewise.\n\t* gcc.target/i386/sse4_2-popcntl.c: Likewise.\n\t* gcc.target/i386/sse4_2-popcntq.c: Likewise.\n\nFrom-SVN: r125281", "tree": {"sha": "dc873ba9105e2322ec5d7895176768b896fc43e0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dc873ba9105e2322ec5d7895176768b896fc43e0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/95a3261e82558f703e885f5e2d772d6a7e31b255", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/95a3261e82558f703e885f5e2d772d6a7e31b255", "html_url": "https://github.com/Rust-GCC/gccrs/commit/95a3261e82558f703e885f5e2d772d6a7e31b255", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/95a3261e82558f703e885f5e2d772d6a7e31b255/comments", "author": {"login": "hjl-tools", "id": 1072356, "node_id": "MDQ6VXNlcjEwNzIzNTY=", "avatar_url": "https://avatars.githubusercontent.com/u/1072356?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hjl-tools", "html_url": "https://github.com/hjl-tools", "followers_url": "https://api.github.com/users/hjl-tools/followers", "following_url": "https://api.github.com/users/hjl-tools/following{/other_user}", "gists_url": "https://api.github.com/users/hjl-tools/gists{/gist_id}", "starred_url": "https://api.github.com/users/hjl-tools/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hjl-tools/subscriptions", "organizations_url": "https://api.github.com/users/hjl-tools/orgs", "repos_url": "https://api.github.com/users/hjl-tools/repos", "events_url": "https://api.github.com/users/hjl-tools/events{/privacy}", "received_events_url": "https://api.github.com/users/hjl-tools/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c7a69424c90fc575a08ac9a5bbf000cc152f3eae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7a69424c90fc575a08ac9a5bbf000cc152f3eae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c7a69424c90fc575a08ac9a5bbf000cc152f3eae"}], "stats": {"total": 1500, "additions": 1500, "deletions": 0}, "files": [{"sha": "23d32949148fda401a76d7b10931bca40231c06d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95a3261e82558f703e885f5e2d772d6a7e31b255/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95a3261e82558f703e885f5e2d772d6a7e31b255/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=95a3261e82558f703e885f5e2d772d6a7e31b255", "patch": "@@ -1,3 +1,25 @@\n+2007-06-02  H.J. Lu  <hongjiu.lu@intel.com>\n+\n+\t* gcc.target/i386/sse4_2-check.h: New.\n+\t* gcc.target/i386/sse4_2-crc32b.c: Likewise.\n+\t* gcc.target/i386/sse4_2-crc32.h: Likewise.\n+\t* gcc.target/i386/sse4_2-crc32l.c: Likewise.\n+\t* gcc.target/i386/sse4_2-crc32q.c: Likewise.\n+\t* gcc.target/i386/sse4_2-crc32w.c: Likewise.\n+\t* gcc.target/i386/sse4_2-pcmpestri-1.c: Likewise.\n+\t* gcc.target/i386/sse4_2-pcmpestri-2.c: Likewise.\n+\t* gcc.target/i386/sse4_2-pcmpestrm-1.c: Likewise.\n+\t* gcc.target/i386/sse4_2-pcmpestrm-2.c: Likewise.\n+\t* gcc.target/i386/sse4_2-pcmpgtq.c: Likewise.\n+\t* gcc.target/i386/sse4_2-pcmpistri-1.c: Likewise.\n+\t* gcc.target/i386/sse4_2-pcmpistri-2.c: Likewise.\n+\t* gcc.target/i386/sse4_2-pcmpistrm-1.c: Likewise.\n+\t* gcc.target/i386/sse4_2-pcmpistrm-2.c: Likewise.\n+\t* gcc.target/i386/sse4_2-pcmpstr.h: Likewise.\n+\t* gcc.target/i386/sse4_2-popcnt.h: Likewise.\n+\t* gcc.target/i386/sse4_2-popcntl.c: Likewise.\n+\t* gcc.target/i386/sse4_2-popcntq.c: Likewise.\n+\n 2007-06-01  Geoffrey Keating  <geoffk@apple.com>\n \n \t* gcc.dg/pie-link.c: New test."}, {"sha": "49bc0b308ab3642a7450646cb09b0a60dbbadb86", "filename": "gcc/testsuite/gcc.target/i386/sse4_2-check.h", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95a3261e82558f703e885f5e2d772d6a7e31b255/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse4_2-check.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95a3261e82558f703e885f5e2d772d6a7e31b255/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse4_2-check.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse4_2-check.h?ref=95a3261e82558f703e885f5e2d772d6a7e31b255", "patch": "@@ -0,0 +1,20 @@\n+#include <stdio.h>\n+#include <stdlib.h>\n+\n+#include \"../../gcc.dg/i386-cpuid.h\"\n+\n+static void sse4_2_test (void);\n+\n+int\n+main ()\n+{\n+  unsigned long cpu_facilities;\n+ \n+  cpu_facilities = i386_cpuid_ecx ();\n+\n+  /* Run SSE4.2 test only if host has SSE4.2 support.  */\n+  if ((cpu_facilities & bit_SSE4_2))\n+    sse4_2_test ();\n+\n+  exit (0);\n+}"}, {"sha": "c0bcd16cca1266e17a712df9bf68b110e95137a5", "filename": "gcc/testsuite/gcc.target/i386/sse4_2-crc32.h", "status": "added", "additions": 163, "deletions": 0, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95a3261e82558f703e885f5e2d772d6a7e31b255/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse4_2-crc32.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95a3261e82558f703e885f5e2d772d6a7e31b255/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse4_2-crc32.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse4_2-crc32.h?ref=95a3261e82558f703e885f5e2d772d6a7e31b255", "patch": "@@ -0,0 +1,163 @@\n+#include \"sse4_2-check.h\"\n+\n+#include <nmmintrin.h>\n+#include <string.h>\n+\n+#define POLYNOMIAL 0x11EDC6F41LL\n+\n+#define MAX_BUF 16\n+\n+static void\n+shift_mem_by1 (unsigned char* buf, int len)\n+{\n+  int i;\n+\n+  for (i = len - 1; i >= 0; i--)\n+    {\n+      buf[i] = buf[i] << 1;\n+      if (i > 0 && (buf[i-1] & 0x80))\n+\tbuf[i] |= 1;\n+   }\n+}\n+\n+static void\n+do_div (unsigned char* buf, unsigned char* div) \n+{\n+  int i;\n+  for (i = 0; i < 5; i++)\n+    buf[i] ^= div[i];\n+}\n+\n+static unsigned int\n+calc_rem (unsigned char* buf, int len)\n+{\n+  union\n+    {\n+      unsigned long long ll;\n+      unsigned char c[8];\n+    } divisor;\n+  union\n+    {\n+      unsigned int i;\n+      unsigned char c[4];\n+    } ret;\n+  unsigned char *div_buf;\n+  unsigned char divident[MAX_BUF];\n+  int disp = len / 8;\n+  int i;\n+\n+  divisor.ll = POLYNOMIAL << 7LL;\n+\n+  memcpy (divident, buf, disp);\n+\n+  div_buf = divident + disp - 5;\n+\n+  for (i = 0; i < len - 32; i++)\n+    {\n+      if ((div_buf[4] & 0x80)) \n+\tdo_div (div_buf, divisor.c);\n+      shift_mem_by1 (divident, disp);\n+   }\n+\n+  memcpy (ret.c, div_buf + 1, sizeof (ret));\n+  return ret.i;\n+}\n+\n+static void \n+reverse_bits (unsigned char *src, int len)\n+{\n+  unsigned char buf[MAX_BUF];\n+  unsigned char *tmp = buf + len - 1;\n+  unsigned char ch;\n+  int i, j;\n+\n+  for (i = 0; i < len; i++)\n+    {\n+      ch = 0;\n+      for (j = 0; j < 8; j++)\n+\tif ((src[i] & (1 << j)))\n+\t  ch |= 1 << (7 - j);\n+      *tmp-- = ch;\n+    }\n+\n+  for (i = 0; i < len; i++)\n+    src[i] = buf[i];\n+}\n+\n+static void \n+shift_mem ( unsigned char *src, unsigned char *dst, int len, int shft)\n+{\n+  int disp = shft / 8;\n+  int i;\n+   \n+  memset (dst, 0, len + disp);\n+  for (i = 0; i < len; i++)\n+    dst[i + disp] = src[i];\n+}\n+\n+static void \n+xor_mem (unsigned char *src, unsigned char *dst, int len)\n+{\n+  int disp = len / 8;\n+  int i;\n+   \n+  for (i = 0; i < disp; i++)\n+    dst[i] ^= src[i];\n+}\n+\n+static DST_T\n+compute_crc32 (DST_T crc, SRC_T inp)\n+{\n+  unsigned char crcbuf[sizeof (DST_T)];\n+  unsigned char inbuf[sizeof (SRC_T)];\n+  unsigned char tmp1[MAX_BUF], tmp2[MAX_BUF];\n+  int crc_sh, xor_sz;\n+  union\n+    {\n+      unsigned int i;\n+      unsigned char c[4];\n+    } ret;\n+\n+  crc_sh = sizeof (SRC_T) * 8;\n+  xor_sz = 32 + crc_sh;\n+  memcpy (crcbuf, &crc, sizeof (DST_T));\n+  memcpy (inbuf, &inp, sizeof (SRC_T));\n+   \n+  reverse_bits (crcbuf, 4);\n+  reverse_bits (inbuf, sizeof (SRC_T));\n+\n+  shift_mem (inbuf, tmp1, sizeof (SRC_T), 32);\n+  shift_mem (crcbuf, tmp2, 4, crc_sh);\n+\n+  xor_mem (tmp1, tmp2, xor_sz);\n+\n+  ret.i = calc_rem (tmp2, xor_sz);\n+  \n+  reverse_bits (ret.c, 4);\n+\n+  return (DST_T)ret.i;\n+}\n+\n+#define NUM 1024\n+\n+static void\n+sse4_2_test (void)\n+{\n+  DST_T dst[NUM]; \n+  SRC_T src[NUM];\n+  int i;\n+\n+ for (i = 0; i < NUM; i++)\n+   {\n+     dst[i] = rand ();\n+     if (sizeof (DST_T) > 4)\n+       dst[i] |= (DST_T)rand () << (DST_T)(sizeof (DST_T) * 4);\n+     src[i] = rand ();\n+     if (sizeof (SRC_T) > 4)\n+       src[i] |= (SRC_T)rand () << (SRC_T)(sizeof (DST_T) * 4);\n+   }\n+\n+  for (i = 0; i < NUM; i++)\n+    if (CRC32 (dst[i], src[i]) != compute_crc32 (dst[i], src[i]))\n+      abort ();\n+}"}, {"sha": "debede336be8a6f113134b04bbb353232e6bc44b", "filename": "gcc/testsuite/gcc.target/i386/sse4_2-crc32b.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95a3261e82558f703e885f5e2d772d6a7e31b255/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse4_2-crc32b.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95a3261e82558f703e885f5e2d772d6a7e31b255/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse4_2-crc32b.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse4_2-crc32b.c?ref=95a3261e82558f703e885f5e2d772d6a7e31b255", "patch": "@@ -0,0 +1,9 @@\n+/* { dg-do run { target i?86-*-* x86_64-*-* } } */\n+/* { dg-require-effective-target sse4 } */\n+/* { dg-options \"-O2 -msse4.2\" } */\n+\n+#define CRC32 _mm_crc32_u8\n+#define DST_T unsigned int\n+#define SRC_T unsigned char\n+\n+#include \"sse4_2-crc32.h\""}, {"sha": "120101bbf473d5fac7a257dfbac7c93ec6dc8234", "filename": "gcc/testsuite/gcc.target/i386/sse4_2-crc32l.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95a3261e82558f703e885f5e2d772d6a7e31b255/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse4_2-crc32l.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95a3261e82558f703e885f5e2d772d6a7e31b255/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse4_2-crc32l.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse4_2-crc32l.c?ref=95a3261e82558f703e885f5e2d772d6a7e31b255", "patch": "@@ -0,0 +1,9 @@\n+/* { dg-do run { target i?86-*-* x86_64-*-* } } */\n+/* { dg-require-effective-target sse4 } */\n+/* { dg-options \"-O2 -msse4.2\" } */\n+\n+#define CRC32 _mm_crc32_u32\n+#define DST_T unsigned int\n+#define SRC_T unsigned int\n+\n+#include \"sse4_2-crc32.h\""}, {"sha": "b6350e739ff9cdc362fee2b4fa9d3168f5ede4ce", "filename": "gcc/testsuite/gcc.target/i386/sse4_2-crc32q.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95a3261e82558f703e885f5e2d772d6a7e31b255/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse4_2-crc32q.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95a3261e82558f703e885f5e2d772d6a7e31b255/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse4_2-crc32q.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse4_2-crc32q.c?ref=95a3261e82558f703e885f5e2d772d6a7e31b255", "patch": "@@ -0,0 +1,9 @@\n+/* { dg-do run { target { { i?86-*-* x86_64-*-* } && lp64 } } } */\n+/* { dg-require-effective-target sse4 } */\n+/* { dg-options \"-O2 -msse4.2\" } */\n+\n+#define CRC32 _mm_crc32_u64\n+#define DST_T unsigned long long\n+#define SRC_T unsigned long long\n+\n+#include \"sse4_2-crc32.h\""}, {"sha": "967197410494886b093d992bb58f509488c45426", "filename": "gcc/testsuite/gcc.target/i386/sse4_2-crc32w.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95a3261e82558f703e885f5e2d772d6a7e31b255/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse4_2-crc32w.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95a3261e82558f703e885f5e2d772d6a7e31b255/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse4_2-crc32w.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse4_2-crc32w.c?ref=95a3261e82558f703e885f5e2d772d6a7e31b255", "patch": "@@ -0,0 +1,9 @@\n+/* { dg-do run { target i?86-*-* x86_64-*-* } } */\n+/* { dg-require-effective-target sse4 } */\n+/* { dg-options \"-O2 -msse4.2\" } */\n+\n+#define CRC32 _mm_crc32_u16\n+#define DST_T unsigned int\n+#define SRC_T unsigned short\n+\n+#include \"sse4_2-crc32.h\""}, {"sha": "8f7a8e9db89df147553e669c86e1dd18b6f98aaf", "filename": "gcc/testsuite/gcc.target/i386/sse4_2-pcmpestri-1.c", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95a3261e82558f703e885f5e2d772d6a7e31b255/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse4_2-pcmpestri-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95a3261e82558f703e885f5e2d772d6a7e31b255/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse4_2-pcmpestri-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse4_2-pcmpestri-1.c?ref=95a3261e82558f703e885f5e2d772d6a7e31b255", "patch": "@@ -0,0 +1,74 @@\n+/* { dg-do run { target i?86-*-* x86_64-*-* } } */\n+/* { dg-require-effective-target sse4 } */\n+/* { dg-options \"-O2 -msse4.2\" } */\n+\n+#include \"sse4_2-check.h\"\n+#include \"sse4_2-pcmpstr.h\"\n+\n+#define NUM 1024\n+\n+#define IMM_VAL0 \\\n+  (SIDD_SBYTE_OPS | SIDD_CMP_RANGES | SIDD_MASKED_POSITIVE_POLARITY)\n+#define IMM_VAL1 \\\n+ (SIDD_UBYTE_OPS | SIDD_CMP_EQUAL_EACH | SIDD_NEGATIVE_POLARITY \\\n+  | SIDD_MOST_SIGNIFICANT)\n+#define IMM_VAL2 \\\n+ (SIDD_UWORD_OPS | SIDD_CMP_EQUAL_ANY | SIDD_MASKED_NEGATIVE_POLARITY)\n+#define IMM_VAL3 \\\n+  (SIDD_SWORD_OPS | SIDD_CMP_EQUAL_ORDERED \\\n+   | SIDD_MASKED_NEGATIVE_POLARITY | SIDD_LEAST_SIGNIFICANT)\n+\n+\n+static void\n+sse4_2_test (void)\n+{\n+  union\n+    {\n+      __m128i x[NUM];\n+      char c[NUM *16];\n+    } src1, src2;\n+  int res, correct, l1, l2;\n+  int i;\n+\n+  for (i = 0; i < NUM *16; i++)\n+    {\n+      src1.c[i] = rand ();\n+      src2.c[i] = rand ();\n+    }\n+\n+  for (i = 0; i < NUM; i++)\n+    {\n+      l1 = rand () % 18;\n+      l2 = rand () % 18;\n+\n+      switch ((rand () % 4))\n+\t{\n+\tcase 0:\n+\t  res = _mm_cmpestri (src1.x[i], l1, src2.x[i], l2, IMM_VAL0);\n+\t  correct = cmp_ei (&src1.x[i], l1, &src2.x[i], l2, IMM_VAL0,\n+\t\t\t    NULL);\n+\t  break;\n+\n+\tcase 1:\n+\t  res = _mm_cmpestri (src1.x[i], l1, src2.x[i], l2, IMM_VAL1);\n+\t  correct = cmp_ei (&src1.x[i], l1, &src2.x[i], l2, IMM_VAL1,\n+\t\t\t    NULL);\n+\t  break;\n+\n+\tcase 2:\n+\t  res = _mm_cmpestri (src1.x[i], l1, src2.x[i], l2, IMM_VAL2);\n+\t  correct = cmp_ei (&src1.x[i], l1, &src2.x[i], l2, IMM_VAL2,\n+\t\t\t    NULL);\n+\t  break;\n+\n+\tdefault:\n+\t  res = _mm_cmpestri (src1.x[i], l1, src2.x[i], l2, IMM_VAL3);\n+\t  correct = cmp_ei (&src1.x[i], l1, &src2.x[i], l2, IMM_VAL3,\n+\t\t\t    NULL);\n+\t  break;\n+        }\n+\n+      if (correct != res)\n+\tabort ();\n+    }\n+}"}, {"sha": "6f5cdf3377250b2bcb876e92ef1c0092f7d6e1ee", "filename": "gcc/testsuite/gcc.target/i386/sse4_2-pcmpestri-2.c", "status": "added", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95a3261e82558f703e885f5e2d772d6a7e31b255/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse4_2-pcmpestri-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95a3261e82558f703e885f5e2d772d6a7e31b255/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse4_2-pcmpestri-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse4_2-pcmpestri-2.c?ref=95a3261e82558f703e885f5e2d772d6a7e31b255", "patch": "@@ -0,0 +1,110 @@\n+/* { dg-do run { target i?86-*-* x86_64-*-* } } */\n+/* { dg-require-effective-target sse4 } */\n+/* { dg-options \"-O2 -msse4.2\" } */\n+\n+#include \"sse4_2-check.h\"\n+#include \"sse4_2-pcmpstr.h\"\n+\n+#define NUM 1024\n+\n+#define IMM_VAL0 \\\n+  (SIDD_SBYTE_OPS | SIDD_CMP_RANGES | SIDD_MASKED_POSITIVE_POLARITY)\n+#define IMM_VAL1 \\\n+ (SIDD_UBYTE_OPS | SIDD_CMP_EQUAL_EACH | SIDD_NEGATIVE_POLARITY \\\n+  | SIDD_MOST_SIGNIFICANT)\n+#define IMM_VAL2 \\\n+ (SIDD_UWORD_OPS | SIDD_CMP_EQUAL_ANY | SIDD_MASKED_NEGATIVE_POLARITY)\n+#define IMM_VAL3 \\\n+  (SIDD_SWORD_OPS | SIDD_CMP_EQUAL_ORDERED \\\n+   | SIDD_MASKED_NEGATIVE_POLARITY | SIDD_LEAST_SIGNIFICANT)\n+\n+\n+static void\n+sse4_2_test (void)\n+{\n+  union\n+    {\n+      __m128i x[NUM];\n+      char c[NUM *16];\n+    } src1, src2;\n+  int res, correct, correct_flags, l1, l2;\n+  int flags, cf, zf, sf, of, af;\n+  int i;\n+\n+  for (i = 0; i < NUM *16; i++)\n+    {\n+      src1.c[i] = rand ();\n+      src2.c[i] = rand ();\n+    }\n+\n+  for (i = 0; i < NUM; i++)\n+    {\n+      l1 = rand () % 18;\n+      l2 = rand () % 18;\n+\n+      switch ((rand () % 4))\n+\t{\n+\tcase 0:\n+\t  res = _mm_cmpestri (src1.x[i], l1, src2.x[i], l2, IMM_VAL0);\n+\t  cf = _mm_cmpestrc (src1.x[i], l1, src2.x[i], l2, IMM_VAL0);\n+\t  zf = _mm_cmpestrz (src1.x[i], l1, src2.x[i], l2, IMM_VAL0);\n+\t  sf = _mm_cmpestrs (src1.x[i], l1, src2.x[i], l2, IMM_VAL0);\n+\t  of = _mm_cmpestro (src1.x[i], l1, src2.x[i], l2, IMM_VAL0);\n+\t  af = _mm_cmpestra (src1.x[i], l1, src2.x[i], l2, IMM_VAL0);\n+\t  correct = cmp_ei (&src1.x[i], l1, &src2.x[i], l2, IMM_VAL0,\n+\t\t\t    &correct_flags);\n+\t  break;\n+\n+\tcase 1:\n+\t  res = _mm_cmpestri (src1.x[i], l1, src2.x[i], l2, IMM_VAL1);\n+\t  cf = _mm_cmpestrc (src1.x[i], l1, src2.x[i], l2, IMM_VAL1);\n+\t  zf = _mm_cmpestrz (src1.x[i], l1, src2.x[i], l2, IMM_VAL1);\n+\t  sf = _mm_cmpestrs (src1.x[i], l1, src2.x[i], l2, IMM_VAL1);\n+\t  of = _mm_cmpestro (src1.x[i], l1, src2.x[i], l2, IMM_VAL1);\n+\t  af = _mm_cmpestra (src1.x[i], l1, src2.x[i], l2, IMM_VAL1);\n+\t  correct = cmp_ei (&src1.x[i], l1, &src2.x[i], l2, IMM_VAL1,\n+\t\t\t    &correct_flags);\n+\t  break;\n+\n+\tcase 2:\n+\t  res = _mm_cmpestri (src1.x[i], l1, src2.x[i], l2, IMM_VAL2);\n+\t  cf = _mm_cmpestrc (src1.x[i], l1, src2.x[i], l2, IMM_VAL2);\n+\t  zf = _mm_cmpestrz (src1.x[i], l1, src2.x[i], l2, IMM_VAL2);\n+\t  sf = _mm_cmpestrs (src1.x[i], l1, src2.x[i], l2, IMM_VAL2);\n+\t  of = _mm_cmpestro (src1.x[i], l1, src2.x[i], l2, IMM_VAL2);\n+\t  af = _mm_cmpestra (src1.x[i], l1, src2.x[i], l2, IMM_VAL2);\n+\t  correct = cmp_ei (&src1.x[i], l1, &src2.x[i], l2, IMM_VAL2,\n+\t\t\t    &correct_flags);\n+\t  break;\n+\n+\tdefault:\n+\t  res = _mm_cmpestri (src1.x[i], l1, src2.x[i], l2, IMM_VAL3);\n+\t  cf = _mm_cmpestrc (src1.x[i], l1, src2.x[i], l2, IMM_VAL3);\n+\t  zf = _mm_cmpestrz (src1.x[i], l1, src2.x[i], l2, IMM_VAL3);\n+\t  sf = _mm_cmpestrs (src1.x[i], l1, src2.x[i], l2, IMM_VAL3);\n+\t  of = _mm_cmpestro (src1.x[i], l1, src2.x[i], l2, IMM_VAL3);\n+\t  af = _mm_cmpestra (src1.x[i], l1, src2.x[i], l2, IMM_VAL3);\n+\t  correct = cmp_ei (&src1.x[i], l1, &src2.x[i], l2, IMM_VAL3,\n+\t\t\t    &correct_flags);\n+\t  break;\n+\t}\n+      \n+      if (correct != res)\n+\tabort ();\n+\n+      flags = 0;\n+      if (cf)\n+\tflags |= CFLAG;\n+      if (zf)\n+\tflags |= ZFLAG;\n+      if (sf)\n+\tflags |= SFLAG;\n+      if (of)\n+\tflags |= OFLAG;\n+      \n+      if (flags != correct_flags\n+\t  || (af && (cf || zf))\n+\t  || (!af && !(cf || zf)))\n+\tabort ();\n+    }\n+}"}, {"sha": "51bab00e4d878f39851ad4ae9bd0a677b53a2926", "filename": "gcc/testsuite/gcc.target/i386/sse4_2-pcmpestrm-1.c", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95a3261e82558f703e885f5e2d772d6a7e31b255/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse4_2-pcmpestrm-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95a3261e82558f703e885f5e2d772d6a7e31b255/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse4_2-pcmpestrm-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse4_2-pcmpestrm-1.c?ref=95a3261e82558f703e885f5e2d772d6a7e31b255", "patch": "@@ -0,0 +1,75 @@\n+/* { dg-do run { target i?86-*-* x86_64-*-* } } */\n+/* { dg-require-effective-target sse4 } */\n+/* { dg-options \"-O2 -msse4.2\" } */\n+\n+#include \"sse4_2-check.h\"\n+#include \"sse4_2-pcmpstr.h\"\n+\n+#define NUM 1024\n+\n+#define IMM_VAL0 \\\n+  (SIDD_SBYTE_OPS | SIDD_CMP_RANGES | SIDD_MASKED_POSITIVE_POLARITY)\n+#define IMM_VAL1 \\\n+  (SIDD_UBYTE_OPS | SIDD_CMP_EQUAL_EACH | SIDD_NEGATIVE_POLARITY \\\n+   | SIDD_BIT_MASK)\n+#define IMM_VAL2 \\\n+  (SIDD_UWORD_OPS | SIDD_CMP_EQUAL_ANY | SIDD_MASKED_NEGATIVE_POLARITY)\n+#define IMM_VAL3 \\\n+  (SIDD_SWORD_OPS | SIDD_CMP_EQUAL_ORDERED \\\n+   | SIDD_MASKED_NEGATIVE_POLARITY | SIDD_UNIT_MASK)\n+\n+\n+static void\n+sse4_2_test (void)\n+{\n+  union\n+    {\n+      __m128i x[NUM];\n+      char c[NUM *16];\n+    } src1, src2;\n+  __m128i res, correct;\n+  int l1, l2;\n+  int i;\n+\n+  for (i = 0; i < NUM *16; i++)\n+    {\n+      src1.c[i] = rand ();\n+      src2.c[i] = rand ();\n+    }\n+\n+  for (i = 0; i < NUM; i++)\n+    {\n+      l1 = rand () % 18;\n+      l2 = rand () % 18;\n+\n+      switch((rand() % 4))\n+\t{\n+\tcase 0:\n+\t  res  = _mm_cmpestrm (src1.x[i], l1, src2.x[i], l2, IMM_VAL0);\n+\t  correct = cmp_em (&src1.x[i], l1, &src2.x[i], l2, IMM_VAL0,\n+\t\t\t    NULL);\n+\t  break;\n+\n+\tcase 1:\n+\t  res  = _mm_cmpestrm (src1.x[i], l1, src2.x[i], l2, IMM_VAL1);\n+\t  correct = cmp_em (&src1.x[i], l1, &src2.x[i], l2, IMM_VAL1,\n+\t\t\t    NULL);\n+\t  break;\n+\n+\tcase 2:\n+\t  res  = _mm_cmpestrm (src1.x[i], l1, src2.x[i], l2, IMM_VAL2);\n+\t  correct = cmp_em (&src1.x[i], l1, &src2.x[i], l2, IMM_VAL2,\n+\t\t\t    NULL);\n+\t  break;\n+\n+\tdefault:\n+\t  res  = _mm_cmpestrm (src1.x[i], l1, src2.x[i], l2, IMM_VAL3);\n+\t  correct = cmp_em (&src1.x[i], l1, &src2.x[i], l2, IMM_VAL3,\n+\t\t\t    NULL);\n+\t  break;\n+        }\n+\n+      if (memcmp (&correct, &res, sizeof (res)))\n+\tabort ();\n+    }\n+}"}, {"sha": "c3dd9823589328e72fd215dcf2e1af880a55baf0", "filename": "gcc/testsuite/gcc.target/i386/sse4_2-pcmpestrm-2.c", "status": "added", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95a3261e82558f703e885f5e2d772d6a7e31b255/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse4_2-pcmpestrm-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95a3261e82558f703e885f5e2d772d6a7e31b255/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse4_2-pcmpestrm-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse4_2-pcmpestrm-2.c?ref=95a3261e82558f703e885f5e2d772d6a7e31b255", "patch": "@@ -0,0 +1,110 @@\n+/* { dg-do run { target i?86-*-* x86_64-*-* } } */\n+/* { dg-require-effective-target sse4 } */\n+/* { dg-options \"-O2 -msse4.2\" } */\n+\n+#include \"sse4_2-check.h\"\n+#include \"sse4_2-pcmpstr.h\"\n+\n+#define NUM 1024\n+\n+#define IMM_VAL0 \\\n+  (SIDD_SBYTE_OPS | SIDD_CMP_RANGES | SIDD_MASKED_POSITIVE_POLARITY)\n+#define IMM_VAL1 \\\n+  (SIDD_UBYTE_OPS | SIDD_CMP_EQUAL_EACH | SIDD_NEGATIVE_POLARITY \\\n+   | SIDD_BIT_MASK)\n+#define IMM_VAL2 \\\n+  (SIDD_UWORD_OPS | SIDD_CMP_EQUAL_ANY | SIDD_NEGATIVE_POLARITY)\n+#define IMM_VAL3 \\\n+  (SIDD_SWORD_OPS | SIDD_CMP_EQUAL_ORDERED \\\n+   | SIDD_MASKED_NEGATIVE_POLARITY | SIDD_UNIT_MASK)\n+\n+static void\n+sse4_2_test (void)\n+{\n+  union\n+    {\n+      __m128i x[NUM];\n+      char c[NUM *16];\n+    } src1, src2;\n+  __m128i res, correct;\n+  int correct_flags, l1, l2;\n+  int flags, cf, zf, sf, of, af;\n+  int i;\n+\n+  for (i = 0; i < NUM *16; i++)\n+    {\n+      src1.c[i] = rand ();\n+      src2.c[i] = rand ();\n+    }\n+\n+  for (i = 0; i < NUM; i++)\n+    {\n+      l1 = rand () % 18;\n+      l2 = rand () % 18;\n+\n+      switch ((rand () % 4))\n+\t{\n+\tcase 0:\n+\t  res = _mm_cmpestrm (src1.x[i], l1, src2.x[i], l2, IMM_VAL0);\n+\t  cf = _mm_cmpestrc (src1.x[i], l1, src2.x[i], l2, IMM_VAL0);\n+\t  zf = _mm_cmpestrz (src1.x[i], l1, src2.x[i], l2, IMM_VAL0);\n+\t  sf = _mm_cmpestrs (src1.x[i], l1, src2.x[i], l2, IMM_VAL0);\n+\t  of = _mm_cmpestro (src1.x[i], l1, src2.x[i], l2, IMM_VAL0);\n+\t  af = _mm_cmpestra (src1.x[i], l1, src2.x[i], l2, IMM_VAL0);\n+\t  correct = cmp_em (&src1.x[i], l1, &src2.x[i], l2, IMM_VAL0,\n+\t\t\t    &correct_flags);\n+\t  break;\n+\n+\tcase 1:\n+\t  res = _mm_cmpestrm (src1.x[i], l1, src2.x[i], l2, IMM_VAL1);\n+\t  cf = _mm_cmpestrc (src1.x[i], l1, src2.x[i], l2, IMM_VAL1);\n+\t  zf = _mm_cmpestrz (src1.x[i], l1, src2.x[i], l2, IMM_VAL1);\n+\t  sf = _mm_cmpestrs (src1.x[i], l1, src2.x[i], l2, IMM_VAL1);\n+\t  of = _mm_cmpestro (src1.x[i], l1, src2.x[i], l2, IMM_VAL1);\n+\t  af = _mm_cmpestra (src1.x[i], l1, src2.x[i], l2, IMM_VAL1);\n+\t  correct = cmp_em (&src1.x[i], l1, &src2.x[i], l2, IMM_VAL1,\n+\t\t\t    &correct_flags);\n+\t  break;\n+\n+\tcase 2:\n+\t  res = _mm_cmpestrm (src1.x[i], l1, src2.x[i], l2, IMM_VAL2);\n+\t  cf = _mm_cmpestrc (src1.x[i], l1, src2.x[i], l2, IMM_VAL2);\n+\t  zf = _mm_cmpestrz (src1.x[i], l1, src2.x[i], l2, IMM_VAL2);\n+\t  sf = _mm_cmpestrs (src1.x[i], l1, src2.x[i], l2, IMM_VAL2);\n+\t  of = _mm_cmpestro (src1.x[i], l1, src2.x[i], l2, IMM_VAL2);\n+\t  af = _mm_cmpestra (src1.x[i], l1, src2.x[i], l2, IMM_VAL2);\n+\t  correct = cmp_em (&src1.x[i], l1, &src2.x[i], l2, IMM_VAL2,\n+\t\t\t    &correct_flags);\n+\t  break;\n+\n+\tdefault:\t\n+\t  res = _mm_cmpestrm (src1.x[i], l1, src2.x[i], l2, IMM_VAL3);\n+\t  cf = _mm_cmpestrc (src1.x[i], l1, src2.x[i], l2, IMM_VAL3);\n+\t  zf = _mm_cmpestrz (src1.x[i], l1, src2.x[i], l2, IMM_VAL3);\n+\t  sf = _mm_cmpestrs (src1.x[i], l1, src2.x[i], l2, IMM_VAL3);\n+\t  of = _mm_cmpestro (src1.x[i], l1, src2.x[i], l2, IMM_VAL3);\n+\t  af = _mm_cmpestra (src1.x[i], l1, src2.x[i], l2, IMM_VAL3);\n+\t  correct = cmp_em (&src1.x[i], l1, &src2.x[i], l2, IMM_VAL3,\n+\t\t\t    &correct_flags);\n+\t  break;\n+\t}\n+      \n+      if (memcmp (&correct, &res, sizeof (res)))\n+\tabort ();\n+\n+      flags = 0;\n+      if (cf)\n+\tflags |= CFLAG;\n+      if (zf)\n+\tflags |= ZFLAG;\n+      if (sf)\n+\tflags |= SFLAG;\n+      if (of)\n+\tflags |= OFLAG;\n+      \n+      if (flags != correct_flags\n+\t  || (af && (cf || zf))\n+\t  || (!af && !(cf || zf)))\n+\tabort ();\n+    }\n+}"}, {"sha": "a0e7388d5956d642b0dade857cc387b3246c7bab", "filename": "gcc/testsuite/gcc.target/i386/sse4_2-pcmpgtq.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95a3261e82558f703e885f5e2d772d6a7e31b255/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse4_2-pcmpgtq.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95a3261e82558f703e885f5e2d772d6a7e31b255/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse4_2-pcmpgtq.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse4_2-pcmpgtq.c?ref=95a3261e82558f703e885f5e2d772d6a7e31b255", "patch": "@@ -0,0 +1,38 @@\n+/* { dg-do run { target i?86-*-* x86_64-*-* } } */\n+/* { dg-require-effective-target sse4 } */\n+/* { dg-options \"-O2 -msse4.2\" } */\n+\n+#include \"sse4_2-check.h\"\n+\n+#include <nmmintrin.h>\n+\n+#define NUM 64\n+\n+static void\n+sse4_2_test (void)\n+{\n+  union\n+    {\n+      __m128i x[NUM / 2];\n+      long long ll[NUM];\n+    } dst, src1, src2;\n+  int i, sign = 1;\n+  long long is_eq;\n+\n+  for (i = 0; i < NUM; i++)\n+    {\n+      src1.ll[i] = i * i * sign;\n+      src2.ll[i] = (i + 20) * sign;\n+      sign = -sign;\n+    }\n+\n+  for (i = 0; i < NUM; i += 2)\n+    dst.x[i / 2] = _mm_cmpgt_epi64 (src1.x[i / 2], src2.x[i / 2]);\n+\n+  for (i = 0; i < NUM; i++)\n+    {\n+      is_eq = src1.ll[i] > src2.ll[i] ? 0xFFFFFFFFFFFFFFFFLL : 0LL;\n+      if (is_eq != dst.ll[i])\n+\tabort ();\n+    }\n+}"}, {"sha": "033c07c4589f8ed0f6285298739171c32694973d", "filename": "gcc/testsuite/gcc.target/i386/sse4_2-pcmpistri-1.c", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95a3261e82558f703e885f5e2d772d6a7e31b255/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse4_2-pcmpistri-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95a3261e82558f703e885f5e2d772d6a7e31b255/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse4_2-pcmpistri-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse4_2-pcmpistri-1.c?ref=95a3261e82558f703e885f5e2d772d6a7e31b255", "patch": "@@ -0,0 +1,67 @@\n+/* { dg-do run { target i?86-*-* x86_64-*-* } } */\n+/* { dg-require-effective-target sse4 } */\n+/* { dg-options \"-O2 -msse4.2\" } */\n+\n+#include \"sse4_2-check.h\"\n+#include \"sse4_2-pcmpstr.h\"\n+\n+#define NUM 1024\n+\n+#define IMM_VAL0 \\\n+  (SIDD_SBYTE_OPS | SIDD_CMP_RANGES | SIDD_MASKED_POSITIVE_POLARITY)\n+#define IMM_VAL1 \\\n+ (SIDD_UBYTE_OPS | SIDD_CMP_EQUAL_EACH | SIDD_NEGATIVE_POLARITY \\\n+  | SIDD_MOST_SIGNIFICANT)\n+#define IMM_VAL2 \\\n+ (SIDD_UWORD_OPS | SIDD_CMP_EQUAL_ANY | SIDD_MASKED_NEGATIVE_POLARITY)\n+#define IMM_VAL3 \\\n+  (SIDD_SWORD_OPS | SIDD_CMP_EQUAL_ORDERED \\\n+   | SIDD_MASKED_NEGATIVE_POLARITY | SIDD_MOST_SIGNIFICANT)\n+\n+\n+static void\n+sse4_2_test (void)\n+{\n+  union\n+    {\n+      __m128i x[NUM];\n+      char c[NUM *16];\n+    } src1, src2;\n+  int res, correct;\n+  int i;\n+\n+  for (i = 0; i < NUM *16; i++)\n+    {\n+      src1.c[i] = rand ();\n+      src2.c[i] = rand ();\n+    }\n+\n+  for (i = 0; i < NUM; i++)\n+    {\n+      switch ((rand () % 4))\n+\t{\n+\tcase 0:\n+\t  res = _mm_cmpistri (src1.x[i], src2.x[i], IMM_VAL0);\n+\t  correct = cmp_ii (&src1.x[i], &src2.x[i], IMM_VAL0, NULL);\n+\t  break;\n+\n+\tcase 1:\n+\t  res = _mm_cmpistri (src1.x[i], src2.x[i], IMM_VAL1);\n+\t  correct = cmp_ii (&src1.x[i], &src2.x[i], IMM_VAL1, NULL);\n+\t  break;\n+\n+\tcase 2:\n+\t  res = _mm_cmpistri (src1.x[i], src2.x[i], IMM_VAL2);\n+\t  correct = cmp_ii (&src1.x[i], &src2.x[i], IMM_VAL2, NULL);\n+\t  break;\n+\n+\tdefault:\n+\t  res = _mm_cmpistri (src1.x[i], src2.x[i], IMM_VAL3);\n+\t  correct = cmp_ii (&src1.x[i], &src2.x[i], IMM_VAL3, NULL);\n+\t  break;\n+        }\n+\n+      if (correct != res)\n+\tabort ();\n+    }\n+}"}, {"sha": "d2379d771c06600b0d32eb463228814fa6122900", "filename": "gcc/testsuite/gcc.target/i386/sse4_2-pcmpistri-2.c", "status": "added", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95a3261e82558f703e885f5e2d772d6a7e31b255/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse4_2-pcmpistri-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95a3261e82558f703e885f5e2d772d6a7e31b255/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse4_2-pcmpistri-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse4_2-pcmpistri-2.c?ref=95a3261e82558f703e885f5e2d772d6a7e31b255", "patch": "@@ -0,0 +1,107 @@\n+/* { dg-do run { target i?86-*-* x86_64-*-* } } */\n+/* { dg-require-effective-target sse4 } */\n+/* { dg-options \"-O2 -msse4.2\" } */\n+\n+#include \"sse4_2-check.h\"\n+#include \"sse4_2-pcmpstr.h\"\n+\n+#define NUM 1024\n+\n+#define IMM_VAL0 \\\n+  (SIDD_SBYTE_OPS | SIDD_CMP_RANGES | SIDD_MASKED_POSITIVE_POLARITY)\n+#define IMM_VAL1 \\\n+ (SIDD_UBYTE_OPS | SIDD_CMP_EQUAL_EACH | SIDD_NEGATIVE_POLARITY \\\n+  | SIDD_MOST_SIGNIFICANT)\n+#define IMM_VAL2 \\\n+ (SIDD_UWORD_OPS | SIDD_CMP_EQUAL_ANY | SIDD_MASKED_NEGATIVE_POLARITY)\n+#define IMM_VAL3 \\\n+  (SIDD_SWORD_OPS | SIDD_CMP_EQUAL_ORDERED \\\n+   | SIDD_MASKED_NEGATIVE_POLARITY | SIDD_MOST_SIGNIFICANT)\n+\n+\n+static void\n+sse4_2_test (void)\n+{\n+  union\n+    {\n+      __m128i x[NUM];\n+      char c[NUM *16];\n+    } src1, src2;\n+  int res, correct, correct_flags;\n+  int flags, cf, zf, sf, of, af;\n+  int i;\n+\n+  for (i = 0; i < NUM *16; i++)\n+    {\n+      src1.c[i] = rand ();\n+      src2.c[i] = rand ();\n+    }\n+\n+  for (i = 0; i < NUM; i++)\n+    {\n+      switch ((rand () % 4))\n+\t{\n+\tcase 0:\n+\t  res = _mm_cmpistri (src1.x[i], src2.x[i], IMM_VAL0);\n+\t  cf = _mm_cmpistrc (src1.x[i], src2.x[i], IMM_VAL0);\n+\t  zf = _mm_cmpistrz (src1.x[i], src2.x[i], IMM_VAL0);\n+\t  sf = _mm_cmpistrs (src1.x[i], src2.x[i], IMM_VAL0);\n+\t  of = _mm_cmpistro (src1.x[i], src2.x[i], IMM_VAL0);\n+\t  af = _mm_cmpistra (src1.x[i], src2.x[i], IMM_VAL0);\n+\t  correct = cmp_ii (&src1.x[i], &src2.x[i], IMM_VAL0,\n+\t\t\t    &correct_flags);\n+\t  break;\n+\n+\tcase 1:\n+\t  res = _mm_cmpistri (src1.x[i], src2.x[i], IMM_VAL1);\n+\t  cf = _mm_cmpistrc (src1.x[i], src2.x[i], IMM_VAL1);\n+\t  zf = _mm_cmpistrz (src1.x[i], src2.x[i], IMM_VAL1);\n+\t  sf = _mm_cmpistrs (src1.x[i], src2.x[i], IMM_VAL1);\n+\t  of = _mm_cmpistro (src1.x[i], src2.x[i], IMM_VAL1);\n+\t  af = _mm_cmpistra (src1.x[i], src2.x[i], IMM_VAL1);\n+\t  correct = cmp_ii (&src1.x[i], &src2.x[i], IMM_VAL1,\n+\t\t\t    &correct_flags);\n+\t  break;\n+\n+\tcase 2:\n+\t  res = _mm_cmpistri (src1.x[i], src2.x[i], IMM_VAL2);\n+\t  cf = _mm_cmpistrc (src1.x[i], src2.x[i], IMM_VAL2);\n+\t  zf = _mm_cmpistrz (src1.x[i], src2.x[i], IMM_VAL2);\n+\t  sf = _mm_cmpistrs (src1.x[i], src2.x[i], IMM_VAL2);\n+\t  of = _mm_cmpistro (src1.x[i], src2.x[i], IMM_VAL2);\n+\t  af = _mm_cmpistra (src1.x[i], src2.x[i], IMM_VAL2);\n+\t  correct = cmp_ii (&src1.x[i], &src2.x[i], IMM_VAL2,\n+\t\t\t    &correct_flags);\n+\t  break;\n+\n+\tdefault:\n+\t  res = _mm_cmpistri (src1.x[i], src2.x[i], IMM_VAL3);\n+\t  cf = _mm_cmpistrc (src1.x[i], src2.x[i], IMM_VAL3);\n+\t  zf = _mm_cmpistrz (src1.x[i], src2.x[i], IMM_VAL3);\n+\t  sf = _mm_cmpistrs (src1.x[i], src2.x[i], IMM_VAL3);\n+\t  of = _mm_cmpistro (src1.x[i], src2.x[i], IMM_VAL3);\n+\t  af = _mm_cmpistra (src1.x[i], src2.x[i], IMM_VAL3);\n+\t  correct = cmp_ii (&src1.x[i], &src2.x[i], IMM_VAL3,\n+\t\t\t    &correct_flags);\n+\t  break;\n+\t}\n+      \n+      if (correct != res)\n+\tabort ();\n+\n+      flags = 0;\n+      if (cf)\n+\tflags |= CFLAG;\n+      if (zf)\n+\tflags |= ZFLAG;\n+      if (sf)\n+\tflags |= SFLAG;\n+      if (of)\n+\tflags |= OFLAG;\n+      \n+      if (flags != correct_flags\n+\t  || (af && (cf || zf))\n+\t  || (!af && !(cf || zf)))\n+\tabort ();\n+    }\n+}"}, {"sha": "3d2ef24ea85d559e65e353b626b6d200056cf61e", "filename": "gcc/testsuite/gcc.target/i386/sse4_2-pcmpistrm-1.c", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95a3261e82558f703e885f5e2d772d6a7e31b255/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse4_2-pcmpistrm-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95a3261e82558f703e885f5e2d772d6a7e31b255/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse4_2-pcmpistrm-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse4_2-pcmpistrm-1.c?ref=95a3261e82558f703e885f5e2d772d6a7e31b255", "patch": "@@ -0,0 +1,67 @@\n+/* { dg-do run { target i?86-*-* x86_64-*-* } } */\n+/* { dg-require-effective-target sse4 } */\n+/* { dg-options \"-O2 -msse4.2\" } */\n+\n+#include \"sse4_2-check.h\"\n+#include \"sse4_2-pcmpstr.h\"\n+\n+#define NUM 1024\n+\n+#define IMM_VAL0 \\\n+  (SIDD_SBYTE_OPS | SIDD_CMP_RANGES | SIDD_MASKED_POSITIVE_POLARITY)\n+#define IMM_VAL1 \\\n+  (SIDD_UBYTE_OPS | SIDD_CMP_EQUAL_EACH | SIDD_NEGATIVE_POLARITY \\\n+   | SIDD_BIT_MASK)\n+#define IMM_VAL2 \\\n+  (SIDD_UWORD_OPS | SIDD_CMP_EQUAL_ANY | SIDD_MASKED_NEGATIVE_POLARITY)\n+#define IMM_VAL3 \\\n+  (SIDD_SWORD_OPS | SIDD_CMP_EQUAL_ORDERED \\\n+   | SIDD_MASKED_NEGATIVE_POLARITY | SIDD_UNIT_MASK)\n+\n+\n+static void\n+sse4_2_test (void)\n+{\n+  union\n+    {\n+      __m128i x[NUM];\n+      char c[NUM *16];\n+    } src1, src2;\n+  __m128i res, correct;\n+  int i;\n+\n+  for (i = 0; i < NUM *16; i++)\n+    {\n+      src1.c[i] = rand ();\n+      src2.c[i] = rand ();\n+    }\n+\n+  for (i = 0; i < NUM; i++)\n+    {\n+      switch((rand() % 4))\n+\t{\n+\tcase 0:\n+\t  res  = _mm_cmpistrm (src1.x[i], src2.x[i], IMM_VAL0);\n+\t  correct = cmp_im (&src1.x[i], &src2.x[i], IMM_VAL0, NULL);\n+\t  break;\n+\n+\tcase 1:\n+\t  res  = _mm_cmpistrm (src1.x[i], src2.x[i], IMM_VAL1);\n+\t  correct = cmp_im (&src1.x[i], &src2.x[i], IMM_VAL1, NULL);\n+\t  break;\n+\n+\tcase 2:\n+\t  res  = _mm_cmpistrm (src1.x[i], src2.x[i], IMM_VAL2);\n+\t  correct = cmp_im (&src1.x[i], &src2.x[i], IMM_VAL2, NULL);\n+\t  break;\n+\n+\tdefault:\n+\t  res  = _mm_cmpistrm (src1.x[i], src2.x[i], IMM_VAL3);\n+\t  correct = cmp_im (&src1.x[i], &src2.x[i], IMM_VAL3, NULL);\n+\t  break;\n+        }\n+\n+      if (memcmp (&correct, &res, sizeof (res)))\n+\tabort ();\n+    }\n+}"}, {"sha": "1890da517b14bbbd8ae308ad4232c1e38b8fcfa9", "filename": "gcc/testsuite/gcc.target/i386/sse4_2-pcmpistrm-2.c", "status": "added", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95a3261e82558f703e885f5e2d772d6a7e31b255/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse4_2-pcmpistrm-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95a3261e82558f703e885f5e2d772d6a7e31b255/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse4_2-pcmpistrm-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse4_2-pcmpistrm-2.c?ref=95a3261e82558f703e885f5e2d772d6a7e31b255", "patch": "@@ -0,0 +1,107 @@\n+/* { dg-do run { target i?86-*-* x86_64-*-* } } */\n+/* { dg-require-effective-target sse4 } */\n+/* { dg-options \"-O2 -msse4.2\" } */\n+\n+#include \"sse4_2-check.h\"\n+#include \"sse4_2-pcmpstr.h\"\n+\n+#define NUM 1024\n+\n+#define IMM_VAL0 \\\n+  (SIDD_SBYTE_OPS | SIDD_CMP_RANGES | SIDD_MASKED_POSITIVE_POLARITY)\n+#define IMM_VAL1 \\\n+  (SIDD_UBYTE_OPS | SIDD_CMP_EQUAL_EACH | SIDD_NEGATIVE_POLARITY \\\n+   | SIDD_BIT_MASK)\n+#define IMM_VAL2 \\\n+  (SIDD_UWORD_OPS | SIDD_CMP_EQUAL_ANY | SIDD_MASKED_NEGATIVE_POLARITY)\n+#define IMM_VAL3 \\\n+  (SIDD_SWORD_OPS | SIDD_CMP_EQUAL_ORDERED \\\n+   | SIDD_POSITIVE_POLARITY | SIDD_UNIT_MASK)\n+\n+static void\n+sse4_2_test (void)\n+{\n+  union\n+    {\n+      __m128i x[NUM];\n+      char c[NUM *16];\n+    } src1, src2;\n+  __m128i res, correct;\n+  int correct_flags;\n+  int flags, cf, zf, sf, of, af;\n+  int i;\n+\n+  for (i = 0; i < NUM *16; i++)\n+    {\n+      src1.c[i] = rand ();\n+      src2.c[i] = rand ();\n+    }\n+\n+  for (i = 0; i < NUM; i++)\n+    {\n+      switch ((rand () % 4))\n+\t{\n+\tcase 0:\n+\t  res = _mm_cmpistrm (src1.x[i], src2.x[i], IMM_VAL0);\n+\t  cf = _mm_cmpistrc (src1.x[i], src2.x[i], IMM_VAL0);\n+\t  zf = _mm_cmpistrz (src1.x[i], src2.x[i], IMM_VAL0);\n+\t  sf = _mm_cmpistrs (src1.x[i], src2.x[i], IMM_VAL0);\n+\t  of = _mm_cmpistro (src1.x[i], src2.x[i], IMM_VAL0);\n+\t  af = _mm_cmpistra (src1.x[i], src2.x[i], IMM_VAL0);\n+\t  correct = cmp_im (&src1.x[i], &src2.x[i], IMM_VAL0,\n+\t\t\t    &correct_flags);\n+\t  break;\n+\n+\tcase 1:\n+\t  res = _mm_cmpistrm (src1.x[i], src2.x[i], IMM_VAL1);\n+\t  cf = _mm_cmpistrc (src1.x[i], src2.x[i], IMM_VAL1);\n+\t  zf = _mm_cmpistrz (src1.x[i], src2.x[i], IMM_VAL1);\n+\t  sf = _mm_cmpistrs (src1.x[i], src2.x[i], IMM_VAL1);\n+\t  of = _mm_cmpistro (src1.x[i], src2.x[i], IMM_VAL1);\n+\t  af = _mm_cmpistra (src1.x[i], src2.x[i], IMM_VAL1);\n+\t  correct = cmp_im (&src1.x[i], &src2.x[i], IMM_VAL1,\n+\t\t\t    &correct_flags);\n+\t  break;\n+\n+\tcase 2:\n+\t  res = _mm_cmpistrm (src1.x[i], src2.x[i], IMM_VAL2);\n+\t  cf = _mm_cmpistrc (src1.x[i], src2.x[i], IMM_VAL2);\n+\t  zf = _mm_cmpistrz (src1.x[i], src2.x[i], IMM_VAL2);\n+\t  sf = _mm_cmpistrs (src1.x[i], src2.x[i], IMM_VAL2);\n+\t  of = _mm_cmpistro (src1.x[i], src2.x[i], IMM_VAL2);\n+\t  af = _mm_cmpistra (src1.x[i], src2.x[i], IMM_VAL2);\n+\t  correct = cmp_im (&src1.x[i], &src2.x[i], IMM_VAL2,\n+\t\t\t    &correct_flags);\n+\t  break;\n+\n+\tdefault:\t\n+\t  res = _mm_cmpistrm (src1.x[i], src2.x[i], IMM_VAL3);\n+\t  cf = _mm_cmpistrc (src1.x[i], src2.x[i], IMM_VAL3);\n+\t  zf = _mm_cmpistrz (src1.x[i], src2.x[i], IMM_VAL3);\n+\t  sf = _mm_cmpistrs (src1.x[i], src2.x[i], IMM_VAL3);\n+\t  of = _mm_cmpistro (src1.x[i], src2.x[i], IMM_VAL3);\n+\t  af = _mm_cmpistra (src1.x[i], src2.x[i], IMM_VAL3);\n+\t  correct = cmp_im (&src1.x[i], &src2.x[i], IMM_VAL3,\n+\t\t\t    &correct_flags);\n+\t  break;\n+\t}\n+      \n+      if (memcmp (&correct, &res, sizeof (res)))\n+\tabort ();\n+\n+      flags = 0;\n+      if (cf)\n+\tflags |= CFLAG;\n+      if (zf)\n+\tflags |= ZFLAG;\n+      if (sf)\n+\tflags |= SFLAG;\n+      if (of)\n+\tflags |= OFLAG;\n+      \n+      if (flags != correct_flags\n+\t  || (af && (cf || zf))\n+\t  || (!af && !(cf || zf)))\n+\tabort ();\n+    }\n+}"}, {"sha": "49eb4bdb43633092c6c43a5a4f552b437a3fc171", "filename": "gcc/testsuite/gcc.target/i386/sse4_2-pcmpstr.h", "status": "added", "additions": 447, "deletions": 0, "changes": 447, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95a3261e82558f703e885f5e2d772d6a7e31b255/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse4_2-pcmpstr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95a3261e82558f703e885f5e2d772d6a7e31b255/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse4_2-pcmpstr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse4_2-pcmpstr.h?ref=95a3261e82558f703e885f5e2d772d6a7e31b255", "patch": "@@ -0,0 +1,447 @@\n+#include <nmmintrin.h>\n+#include <string.h>\n+\n+#define CFLAG 0x00000001\n+#define ZFLAG 0x00000002\n+#define SFLAG 0x00000004\n+#define OFLAG 0x00000008\n+#define AFLAG 0x00000010\n+#define PFLAG 0x00000020\n+\n+#define PCMPSTR_EQ(X, Y, RES) \\\n+  {\t\t\t\t\t\t\t\\\n+    int __size = (sizeof (*X) ^ 3) * 8;\t\t\t\\\n+    int __i, __j;\t\t\t\t\t\\\n+    for (__i = 0; __i < __size; __i++)\t\t\t\\\n+      for (__j = 0; __j < __size; __j++)\t\t\\\n+        RES[__j][__i] = (X[__i] == Y[__j]);\t\t\\\n+  }\n+\n+#define PCMPSTR_RNG(X, Y, RES) \\\n+  {\t\t\t\t\t\t\t\\\n+    int __size = (sizeof (*X) ^ 3) * 8;\t\t\t\\\n+    int __i, __j;\t\t\t\t\t\\\n+    for (__j = 0; __j < __size; __j++)\t\t\t\\\n+      for (__i = 0; __i < __size - 1; __i += 2)\t\t\\\n+\t{\t\t\t\t\t\t\\\n+\t  RES[__j][__i] = (Y[__j] >= X[__i]);\t\t\\\n+\t  RES[__j][__i+1] = (Y[__j] <= X[__i + 1]);\t\\\n+\t}\t\t\t\t\t\t\\\n+  }\n+\n+static void\n+override_invalid (unsigned char res[16][16], int la, int lb,\n+\t\t  const int mode, int dim)\n+{\n+  int i, j;\n+\n+  for (j = 0; j < dim; j++)\n+    for (i = 0; i < dim; i++)\n+      if (i < la && j >= lb)\n+\tres[j][i] = 0;\n+      else if (i >= la)\n+\tswitch ((mode & 0x0C))\n+\t  {\n+\t  case SIDD_CMP_EQUAL_ANY:\n+\t  case SIDD_CMP_RANGES:\n+\t    res[j][i] = 0;\n+\t    break;\n+\t  case SIDD_CMP_EQUAL_EACH:\n+\t    res[j][i] = (j >= lb) ? 1: 0;\n+\t    break;\n+\t  case SIDD_CMP_EQUAL_ORDERED:\n+\t    res[j][i] = 1;\n+\t    break;\n+          }\n+}\n+\n+static void  \n+calc_matrix (__m128i a, int la, __m128i b, int lb, const int mode,\n+\t     unsigned char res[16][16])\n+{\n+  union\n+    {\n+      __m128i x;\n+      signed char sc[16];\n+      unsigned char uc[16];\n+      signed short ss[8];\n+      unsigned short us[8];\n+    } d, s;\n+\n+  d.x = a;\n+  s.x = b;\n+\n+  switch ((mode & 3))\n+    {\n+    case SIDD_UBYTE_OPS:\n+      if ((mode & 0x0C) == SIDD_CMP_RANGES)\n+\t{\n+\t  PCMPSTR_RNG (d.uc, s.uc, res);\n+\t}\n+      else\n+\t{\n+\t  PCMPSTR_EQ (d.uc, s.uc, res);\n+\t}\n+      break;\n+    case SIDD_UWORD_OPS:\n+      if ((mode & 0x0C) == SIDD_CMP_RANGES)\n+\t{\n+\t  PCMPSTR_RNG (d.us, s.us, res);\n+\t}\n+      else\n+\t{\n+\t  PCMPSTR_EQ (d.us, s.us, res);\n+\t}\n+      break;\n+    case SIDD_SBYTE_OPS:\n+      if ((mode & 0x0C) == SIDD_CMP_RANGES)\n+\t{\n+\t  PCMPSTR_RNG (d.sc, s.sc, res);\n+\t}\n+      else\n+\t{\n+\t  PCMPSTR_EQ (d.sc, s.sc, res);\n+\t}\n+      break;\n+    case SIDD_SWORD_OPS:\n+      if ((mode & 0x0C) == SIDD_CMP_RANGES)\n+\t{\n+\t  PCMPSTR_RNG (d.ss, s.ss, res);\n+\t}\n+      else\n+\t{\n+\t  PCMPSTR_EQ (d.ss, s.ss, res);\n+\t}\n+      break;\n+    }\n+\n+  override_invalid (res, la, lb, mode, (mode & 1) == 0 ? 16 : 8);\n+}\n+\n+static int \n+calc_res (__m128i a, int la, __m128i b, int lb, const int mode)\n+{\n+  unsigned char mtx[16][16];\n+  int i, j, k, dim, res = 0;\n+\n+  memset (mtx, 0, sizeof (mtx));\n+\n+  dim = (mode & 1) == 0 ? 16 : 8;\n+\n+  if (la < 0)\n+    la = -la;\n+\n+  if (lb < 0)\n+    lb = -lb;\n+\n+  if (la > dim)\n+    la = dim;\n+ \n+  if (lb > dim)\n+    lb = dim;\n+\n+  calc_matrix (a, la, b, lb, mode, mtx);\n+\n+  switch ((mode & 0x0C))\n+    {\n+    case SIDD_CMP_EQUAL_ANY:\n+      for (i = 0; i < dim; i++)\n+\tfor (j = 0; j < dim; j++)\n+\t  if (mtx[i][j])\n+\t    res |= (1 << i);\n+      break;\n+\n+     case SIDD_CMP_RANGES:\n+      for (i = 0; i < dim; i += 2)\n+\tfor(j = 0; j < dim; j++)\n+\t  if (mtx[j][i] && mtx[j][i+1])\n+\t    res |= (1 << j);\n+      break;\n+\n+     case SIDD_CMP_EQUAL_EACH:\n+      for(i = 0; i < dim; i++)\n+\tif (mtx[i][i])\n+\t  res |= (1 << i);\n+      break;\n+\n+     case SIDD_CMP_EQUAL_ORDERED:\n+      for(i = 0; i < dim; i++)\n+\t{\n+\t  unsigned char val = 1;\n+\n+\t  for (j = 0, k = i; j < dim - i && k < dim; j++, k++)\n+\t    val &= mtx[k][j];\n+\t  \n+\t  if (val)\n+\t    res |= (1 << i);\n+\t  else\n+\t    res &= ~(1 << i);\n+\t}\n+      break;\n+    }\n+\n+  switch ((mode & 0x30))\n+    {\n+    case SIDD_POSITIVE_POLARITY:\n+    case SIDD_MASKED_POSITIVE_POLARITY:\n+      break;\n+\n+    case SIDD_NEGATIVE_POLARITY:\n+      res ^= -1;\n+      break;\n+\n+    case SIDD_MASKED_NEGATIVE_POLARITY:\n+      for (i = 0; i < lb; i++)\n+\tif (res & (1 << i))\n+\t  res &= ~(1 << i);\n+\telse\n+\t  res |= (1 << i);\n+      break;\n+    }\n+\n+  return res & ((dim == 8) ? 0xFF : 0xFFFF);\n+}\n+\n+static int\n+cmp_flags (__m128i a, int la, __m128i b, int lb,\n+\t   int mode, int res2, int is_implicit)\n+{\n+  int i;\n+  int flags = 0;\n+  int is_bytes_mode = (mode & 1) == 0;\n+  union\n+    {\n+      __m128i x;\n+      unsigned char uc[16];\n+      unsigned short us[8];\n+    } d, s;\n+\n+  d.x = a;\n+  s.x = b;\n+\n+  /* CF: reset if (RES2 == 0), set otherwise.  */\n+  if (res2 != 0)\n+    flags |= CFLAG;\n+\n+  if (is_implicit)\n+    {\n+      /* ZF: set if any byte/word of src xmm operand is null, reset\n+\t otherwise.\n+\t SF: set if any byte/word of dst xmm operand is null, reset\n+\t otherwise.  */\n+\n+      if (is_bytes_mode)\n+\t{\n+\t  for (i = 0; i < 16; i++)\n+\t    {\n+\t      if (s.uc[i] == 0)\n+\t\tflags |= ZFLAG;\n+\t      if (d.uc[i] == 0)\n+\t\tflags |= SFLAG;\n+            }\n+\t}\n+      else\n+\t{\n+\t  for (i = 0; i < 8; i++)\n+\t    {\n+\t      if (s.us[i] == 0)\n+\t\tflags |= ZFLAG;\n+\t      if (d.us[i] == 0)\n+\t\tflags |= SFLAG;\n+            }\n+        }\n+    }\n+  else\n+    {\n+      /* ZF: set if abs value of EDX/RDX < 16 (8), reset otherwise.\n+\t SF: set if abs value of EAX/RAX < 16 (8), reset otherwise.  */\n+      int max_ind = is_bytes_mode ? 16 : 8;\n+\n+      if (la < 0)\n+\tla = -la;\n+      if (lb < 0)\n+\tlb = -lb;\n+\n+      if (lb < max_ind)\n+\tflags |= ZFLAG;\n+      if (la < max_ind)\n+\tflags |= SFLAG;\n+    }\n+\n+  /* OF: equal to RES2[0].  */\n+  if ((res2 & 0x1))\n+    flags |= OFLAG;\n+\n+  /* AF: Reset.\n+     PF: Reset.  */\n+  return flags;\n+}\n+\n+static int\n+cmp_indexed (__m128i a, int la, __m128i b, int lb,\n+\t     const int mode, int *res2)\n+{\n+  int i, ndx;\n+  int dim = (mode & 1) == 0 ? 16 : 8;\n+  int r2;\n+  \n+  r2 = calc_res (a, la, b, lb, mode);\n+\n+  ndx = dim;\n+  if ((mode & 0x40))\n+    {\n+      for (i = dim - 1; i >= 0; i--)\n+\tif (r2 & (1 << i))\n+\t  {\n+\t    ndx = i;\n+\t    break;\n+\t  }\n+    }\n+  else\n+    {\n+      for (i = 0; i < dim; i++)\n+\tif ((r2 & (1 << i)))\n+\t  {\n+\t    ndx = i;\n+\t    break;\n+\t  }\n+    }\n+\n+   *res2 = r2;\n+   return ndx;\n+}\n+\n+static __m128i \n+cmp_masked (__m128i a, int la, __m128i b, int lb,\n+\t    const int mode, int *res2)\n+{\n+  union\n+    {\n+      __m128i x;\n+      char c[16];\n+      short s[8];\n+    } ret;\n+  int i;\n+  int dim = (mode & 1) == 0 ? 16 : 8;\n+  union\n+    {\n+      int i;\n+      char c[4];\n+      short s[2];\n+    } r2;\n+\n+  r2.i = calc_res (a, la, b, lb, mode);\n+\n+  memset (&ret, 0, sizeof (ret));\n+\n+  if (mode & 0x40)\n+    {\n+      for (i = 0; i < dim; i++)\n+\tif (dim == 8)\n+\t  ret.s [i] = (r2.i & (1 << i)) ? -1 : 0;\n+\telse\n+\t  ret.c [i] = (r2.i & (1 << i)) ? -1 : 0;\n+    }\n+  else\n+    {\n+      if (dim == 16)\n+\tret.s[0] = r2.s[0];\n+      else\n+\tret.c[0] = r2.c[0];\n+    }\n+\n+   *res2 = r2.i;\n+\n+   return ret.x;\n+}\n+\n+static int \n+calc_str_len (__m128i a, const int mode)\n+{\n+  union\n+    {\n+      __m128i x;\n+      char c[16];\n+      short s[8];\n+    } s;\n+  int i;\n+  int dim  = (mode & 1) == 0 ? 16 : 8;\n+\n+  s.x = a;\n+\n+  if ((mode & 1))\n+    {\n+      for (i = 0; i < dim; i++)\n+\tif (s.s[i] == 0)\n+\t  break;\n+    }\n+  else\n+    {\n+      for (i = 0; i < dim; i++)\n+       if (s.c[i] == 0)\n+\t break;\n+    }\n+\n+  return i;\n+}\n+\n+static inline int\n+cmp_ei (__m128i *a, int la, __m128i *b, int lb,\n+\tconst int mode, int *flags)\n+{\n+  int res2;\n+  int index = cmp_indexed (*a, la, *b, lb, mode, &res2);\n+\n+  if (flags != NULL)\n+    *flags = cmp_flags (*a, la, *b, lb, mode, res2, 0);\n+\n+  return index;\n+}\n+\n+static inline int\n+cmp_ii (__m128i *a, __m128i *b, const int mode, int *flags)\n+{\n+  int la, lb;\n+  int res2;\n+  int index;\n+\n+  la = calc_str_len (*a, mode);\n+  lb = calc_str_len (*b, mode);\n+\n+  index = cmp_indexed (*a, la, *b, lb, mode, &res2);\n+\n+  if (flags != NULL) \n+    *flags = cmp_flags (*a, la, *b, lb, mode, res2, 1);\n+\n+  return index;\n+}\n+\n+static inline __m128i\n+cmp_em (__m128i *a, int la, __m128i *b, int lb,\n+\tconst int mode, int *flags )\n+{\n+  int res2;\n+  __m128i mask = cmp_masked (*a, la, *b, lb, mode, &res2);\n+\n+  if (flags != NULL)\n+    *flags = cmp_flags (*a, la, *b, lb, mode, res2, 0);\n+\n+  return mask;\n+}\n+\n+static inline __m128i\n+cmp_im (__m128i *a, __m128i *b, const int mode, int *flags)\n+{\n+  int la, lb;\n+  int res2;\n+  __m128i mask;\n+\n+  la = calc_str_len (*a, mode);\n+  lb = calc_str_len (*b, mode);\n+\n+  mask = cmp_masked (*a, la, *b, lb, mode, &res2);\n+  if (flags != NULL)\n+    *flags = cmp_flags (*a, la, *b, lb, mode, res2, 1);\n+\n+  return mask;\n+}"}, {"sha": "ce06ba1b8d02efcaa8daaeb97d6703a3feda52e5", "filename": "gcc/testsuite/gcc.target/i386/sse4_2-popcnt.h", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95a3261e82558f703e885f5e2d772d6a7e31b255/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse4_2-popcnt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95a3261e82558f703e885f5e2d772d6a7e31b255/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse4_2-popcnt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse4_2-popcnt.h?ref=95a3261e82558f703e885f5e2d772d6a7e31b255", "patch": "@@ -0,0 +1,41 @@\n+#include \"sse4_2-check.h\"\n+\n+#include <nmmintrin.h>\n+\n+#define NUM 1024\n+\n+static int\n+compute_popcnt (TYPE v)\n+{\n+  int ret;\n+  int i;\n+\n+ ret = 0;\n+ for (i = 0; i < sizeof(v) * 8; i++)\n+   if ((v & ((TYPE)1 << (TYPE) i)))\n+     ret++;\n+\n+ return ret;\n+}\n+\n+static void\n+sse4_2_test (void)\n+{\n+  int i;\n+  TYPE vals[NUM];\n+  TYPE res;\n+\n+ for (i = 0; i < NUM; i++)\n+   {\n+     vals[i] = rand ();\n+     if (sizeof (TYPE) > 4)\n+       vals[i] |= (TYPE)rand() << (TYPE)(sizeof (TYPE) * 4);\n+   }\n+\n+ for (i=0; i < NUM; i++)\n+   { \n+     res = POPCNT (vals[i]);\n+     if (res != compute_popcnt (vals[i]))\n+       abort ();\n+   }\n+}"}, {"sha": "69a32b23de2a61de98096f5df08f3574627a1fcd", "filename": "gcc/testsuite/gcc.target/i386/sse4_2-popcntl.c", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95a3261e82558f703e885f5e2d772d6a7e31b255/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse4_2-popcntl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95a3261e82558f703e885f5e2d772d6a7e31b255/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse4_2-popcntl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse4_2-popcntl.c?ref=95a3261e82558f703e885f5e2d772d6a7e31b255", "patch": "@@ -0,0 +1,8 @@\n+/* { dg-do run { target i?86-*-* x86_64-*-* } } */\n+/* { dg-require-effective-target sse4 } */\n+/* { dg-options \"-O2 -msse4.2\" } */\n+\n+#define TYPE unsigned int\n+#define POPCNT _mm_popcnt_u32\n+\n+#include \"sse4_2-popcnt.h\""}, {"sha": "78473935d7494d31a041e7973c1c35484ee7fafb", "filename": "gcc/testsuite/gcc.target/i386/sse4_2-popcntq.c", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95a3261e82558f703e885f5e2d772d6a7e31b255/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse4_2-popcntq.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95a3261e82558f703e885f5e2d772d6a7e31b255/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse4_2-popcntq.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse4_2-popcntq.c?ref=95a3261e82558f703e885f5e2d772d6a7e31b255", "patch": "@@ -0,0 +1,8 @@\n+/* { dg-do run { target { { i?86-*-* x86_64-*-* } && lp64 } } } */\n+/* { dg-require-effective-target sse4 } */\n+/* { dg-options \"-O2 -msse4.2\" } */\n+\n+#define TYPE unsigned long long\n+#define POPCNT _mm_popcnt_u64\n+\n+#include \"sse4_2-popcnt.h\""}]}