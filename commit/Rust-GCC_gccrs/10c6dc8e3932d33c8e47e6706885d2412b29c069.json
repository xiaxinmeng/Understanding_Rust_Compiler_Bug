{"sha": "10c6dc8e3932d33c8e47e6706885d2412b29c069", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTBjNmRjOGUzOTMyZDMzYzhlNDdlNjcwNjg4NWQyNDEyYjI5YzA2OQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2013-03-29T19:51:36Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2013-03-29T19:51:36Z"}, "message": "cp-tree.h (AUTO_IS_DECLTYPE): New.\n\n\tN3582\n\t* cp-tree.h (AUTO_IS_DECLTYPE): New.\n\t* parser.c (cp_parser_decltype): Handle decltype(auto).\n\t(cp_parser_type_id_1): Allow auto without a late-specified\n\treturn in C++1y.\n\t(cp_parser_primary_expression): Use the return value of\n\tfinish_parenthesized_expr.\n\t(cp_parser_transaction_expression): Likewise.\n\t* semantics.c (force_paren_expr): New.\n\t(finish_parenthesized_expr): Use it.\n\t* call.c (build_conditional_expr_1): Likewise.\n\t* pt.c (do_auto_deduction): Handle decltype(auto).\n\t(tsubst_copy): Handle PAREN_EXPR.\n\t(tsubst_copy_and_build): Likewise.\n\t* error.c (dump_expr): Handle PAREN_EXPR.\n\t* cxx-pretty-print.c (pp_cxx_expression): Likewise.\n\t* mangle.c (write_expression): Ignore PAREN_EXPR.\n\n\t* parser.c (cp_parser_decltype_expr): Split out...\n\t(cp_parser_decltype): ...from here.\n\nFrom-SVN: r197248", "tree": {"sha": "fa1e112b1b8703b30586ff6e497de4fc62417926", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fa1e112b1b8703b30586ff6e497de4fc62417926"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/10c6dc8e3932d33c8e47e6706885d2412b29c069", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10c6dc8e3932d33c8e47e6706885d2412b29c069", "html_url": "https://github.com/Rust-GCC/gccrs/commit/10c6dc8e3932d33c8e47e6706885d2412b29c069", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10c6dc8e3932d33c8e47e6706885d2412b29c069/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "15914ac8b16b3e88dc13b08f143f90ac5baad126", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15914ac8b16b3e88dc13b08f143f90ac5baad126", "html_url": "https://github.com/Rust-GCC/gccrs/commit/15914ac8b16b3e88dc13b08f143f90ac5baad126"}], "stats": {"total": 257, "additions": 228, "deletions": 29}, "files": [{"sha": "8059562e581b470ba66cec7440c071843798cb1d", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10c6dc8e3932d33c8e47e6706885d2412b29c069/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10c6dc8e3932d33c8e47e6706885d2412b29c069/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=10c6dc8e3932d33c8e47e6706885d2412b29c069", "patch": "@@ -1,5 +1,23 @@\n 2013-03-29  Jason Merrill  <jason@redhat.com>\n \n+\tN3582\n+\t* cp-tree.h (AUTO_IS_DECLTYPE): New.\n+\t* parser.c (cp_parser_decltype): Handle decltype(auto).\n+\t(cp_parser_type_id_1): Allow auto without a late-specified\n+\treturn in C++1y.\n+\t(cp_parser_primary_expression): Use the return value of\n+\tfinish_parenthesized_expr.\n+\t(cp_parser_transaction_expression): Likewise.\n+\t* semantics.c (force_paren_expr): New.\n+\t(finish_parenthesized_expr): Use it.\n+\t* call.c (build_conditional_expr_1): Likewise.\n+\t* pt.c (do_auto_deduction): Handle decltype(auto).\n+\t(tsubst_copy): Handle PAREN_EXPR.\n+\t(tsubst_copy_and_build): Likewise.\n+\t* error.c (dump_expr): Handle PAREN_EXPR.\n+\t* cxx-pretty-print.c (pp_cxx_expression): Likewise.\n+\t* mangle.c (write_expression): Ignore PAREN_EXPR.\n+\n \t* parser.c (cp_parser_decltype_expr): Split out...\n \t(cp_parser_decltype): ...from here.\n "}, {"sha": "62d6e15ff7b059527515f0fc90d968c7230cdb02", "filename": "gcc/cp/call.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10c6dc8e3932d33c8e47e6706885d2412b29c069/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10c6dc8e3932d33c8e47e6706885d2412b29c069/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=10c6dc8e3932d33c8e47e6706885d2412b29c069", "patch": "@@ -4845,6 +4845,8 @@ build_conditional_expr_1 (tree arg1, tree arg2, tree arg3,\n \t lvalue, we must add a NON_LVALUE_EXPR.  */\n       result = rvalue (result);\n     }\n+  else\n+    result = force_paren_expr (result);\n \n   return result;\n }"}, {"sha": "521da0054abfc48fe38a66fc6a58c401f03602c9", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10c6dc8e3932d33c8e47e6706885d2412b29c069/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10c6dc8e3932d33c8e47e6706885d2412b29c069/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=10c6dc8e3932d33c8e47e6706885d2412b29c069", "patch": "@@ -121,6 +121,7 @@ c-common.h, not after.\n    4: TYPE_HAS_NONTRIVIAL_DESTRUCTOR\n    5: CLASS_TYPE_P (in RECORD_TYPE and UNION_TYPE)\n       ENUM_FIXED_UNDERLYING_TYPE_P (in ENUMERAL_TYPE)\n+      AUTO_IS_DECLTYPE (in TEMPLATE_TYPE_PARM)\n    6: TYPE_DEPENDENT_P_VALID\n \n    Usage of DECL_LANG_FLAG_?:\n@@ -4604,6 +4605,10 @@ enum overload_flags { NO_SPECIAL = 0, DTOR_FLAG, TYPENAME_FLAG };\n #define TEMPLATE_TYPE_PARAMETER_PACK(NODE) \\\n   (TEMPLATE_PARM_PARAMETER_PACK (TEMPLATE_TYPE_PARM_INDEX (NODE)))\n \n+/* True iff this TEMPLATE_TYPE_PARM represents decltype(auto).  */\n+#define AUTO_IS_DECLTYPE(NODE) \\\n+  (TYPE_LANG_FLAG_5 (TEMPLATE_TYPE_PARM_CHECK (NODE)))\n+\n /* These constants can used as bit flags in the process of tree formatting.\n \n    TFF_PLAIN_IDENTIFIER: unqualified part of a name.\n@@ -5659,6 +5664,7 @@ extern tree finish_asm_stmt\t\t\t(int, tree, tree, tree, tree,\n extern tree finish_label_stmt\t\t\t(tree);\n extern void finish_label_decl\t\t\t(tree);\n extern tree finish_parenthesized_expr\t\t(tree);\n+extern tree force_paren_expr\t\t\t(tree);\n extern tree finish_non_static_data_member       (tree, tree, tree);\n extern tree begin_stmt_expr\t\t\t(void);\n extern tree finish_stmt_expr_expr\t\t(tree, tree);"}, {"sha": "4275b45c1e75c5d73392f05dd062b9e1b92a2d8c", "filename": "gcc/cp/cxx-pretty-print.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10c6dc8e3932d33c8e47e6706885d2412b29c069/gcc%2Fcp%2Fcxx-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10c6dc8e3932d33c8e47e6706885d2412b29c069/gcc%2Fcp%2Fcxx-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcxx-pretty-print.c?ref=10c6dc8e3932d33c8e47e6706885d2412b29c069", "patch": "@@ -1167,6 +1167,12 @@ pp_cxx_expression (cxx_pretty_printer *pp, tree t)\n       pp_cxx_ws_string (pp, \"<lambda>\");\n       break;\n \n+    case PAREN_EXPR:\n+      pp_cxx_left_paren (pp);\n+      pp_cxx_expression (pp, TREE_OPERAND (t, 0));\n+      pp_cxx_right_paren (pp);\n+      break;\n+\n     default:\n       pp_c_expression (pp_c_base (pp), t);\n       break;"}, {"sha": "dd27e6cc2f3a34597b172425793bd58269bad573", "filename": "gcc/cp/error.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10c6dc8e3932d33c8e47e6706885d2412b29c069/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10c6dc8e3932d33c8e47e6706885d2412b29c069/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=10c6dc8e3932d33c8e47e6706885d2412b29c069", "patch": "@@ -2506,6 +2506,12 @@ dump_expr (tree t, int flags)\n       pp_string (cxx_pp, M_(\"<lambda>\"));\n       break;\n \n+    case PAREN_EXPR:\n+      pp_cxx_left_paren (cxx_pp);\n+      dump_expr (TREE_OPERAND (t, 0), flags | TFF_EXPR_IN_PARENS);\n+      pp_cxx_right_paren (cxx_pp);\n+      break;\n+\n       /*  This list is incomplete, but should suffice for now.\n \t  It is very important that `sorry' does not call\n \t  `report_error_function'.  That could cause an infinite loop.  */"}, {"sha": "e303ea245b1cff038603c1598d58516a369a145c", "filename": "gcc/cp/mangle.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10c6dc8e3932d33c8e47e6706885d2412b29c069/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10c6dc8e3932d33c8e47e6706885d2412b29c069/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=10c6dc8e3932d33c8e47e6706885d2412b29c069", "patch": "@@ -2555,6 +2555,8 @@ write_expression (tree expr)\n      is converted (via qualification conversions) to another\n      type.  */\n   while (TREE_CODE (expr) == NOP_EXPR\n+\t /* Parentheses aren't mangled.  */\n+\t || code == PAREN_EXPR\n \t || TREE_CODE (expr) == NON_LVALUE_EXPR)\n     {\n       expr = TREE_OPERAND (expr, 0);"}, {"sha": "8ad877ef82bb6a95aae9b25fe47cb73f9f73dab9", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10c6dc8e3932d33c8e47e6706885d2412b29c069/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10c6dc8e3932d33c8e47e6706885d2412b29c069/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=10c6dc8e3932d33c8e47e6706885d2412b29c069", "patch": "@@ -4106,7 +4106,7 @@ cp_parser_primary_expression (cp_parser *parser,\n \t       example, the expression is of the form `A::B', since\n \t       `&A::B' might be a pointer-to-member, but `&(A::B)' is\n \t       not.  */\n-\t    finish_parenthesized_expr (expr);\n+\t    expr = finish_parenthesized_expr (expr);\n \t    /* DR 705: Wrapping an unqualified name in parentheses\n \t       suppresses arg-dependent lookup.  We want to pass back\n \t       CP_ID_KIND_QUALIFIED for suppressing vtable lookup\n@@ -11399,7 +11399,9 @@ cp_parser_decltype_expr (cp_parser *parser,\n /* Parse a `decltype' type. Returns the type.\n \n    simple-type-specifier:\n-     decltype ( expression )  */\n+     decltype ( expression )\n+   C++14 proposal:\n+     decltype ( auto )  */\n \n static tree\n cp_parser_decltype (cp_parser *parser)\n@@ -11427,6 +11429,18 @@ cp_parser_decltype (cp_parser *parser)\n   if (!cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN))\n     return error_mark_node;\n \n+  /* decltype (auto) */\n+  if (cxx_dialect >= cxx1y\n+      && cp_lexer_next_token_is_keyword (parser->lexer, RID_AUTO))\n+    {\n+      cp_lexer_consume_token (parser->lexer);\n+      if (!cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN))\n+\treturn error_mark_node;\n+      expr = make_auto ();\n+      AUTO_IS_DECLTYPE (expr) = true;\n+      goto rewrite;\n+    }\n+\n   /* Types cannot be defined in a `decltype' expression.  Save away the\n      old message.  */\n   saved_message = parser->type_definition_forbidden_message;\n@@ -11485,6 +11499,7 @@ cp_parser_decltype (cp_parser *parser)\n   expr = finish_decltype_type (expr, id_expression_or_member_access_p,\n \t\t\t       tf_warning_or_error);\n \n+ rewrite:\n   /* Replace the decltype with a CPP_DECLTYPE so we don't need to parse\n      it again.  */\n   start_token->type = CPP_DECLTYPE;\n@@ -17207,6 +17222,7 @@ cp_parser_type_id_1 (cp_parser* parser, bool is_template_arg,\n     abstract_declarator = NULL;\n \n   if (type_specifier_seq.type\n+      && cxx_dialect < cxx1y\n       && type_uses_auto (type_specifier_seq.type))\n     {\n       /* A type-id with type 'auto' is only ok if the abstract declarator\n@@ -28003,7 +28019,7 @@ cp_parser_transaction_expression (cp_parser *parser, enum rid keyword)\n       cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN);\n \n       expr = cp_parser_expression (parser, /*cast_p=*/false, NULL);\n-      finish_parenthesized_expr (expr);\n+      expr = finish_parenthesized_expr (expr);\n \n       cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN);\n     }"}, {"sha": "2fc282e91121a7c4b4a92e70f5216f603c5ed847", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 38, "deletions": 26, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10c6dc8e3932d33c8e47e6706885d2412b29c069/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10c6dc8e3932d33c8e47e6706885d2412b29c069/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=10c6dc8e3932d33c8e47e6706885d2412b29c069", "patch": "@@ -12303,6 +12303,7 @@ tsubst_copy (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n     case TYPEID_EXPR:\n     case REALPART_EXPR:\n     case IMAGPART_EXPR:\n+    case PAREN_EXPR:\n       return build1\n \t(code, tsubst (TREE_TYPE (t), args, complain, in_decl),\n \t tsubst_copy (TREE_OPERAND (t, 0), args, complain, in_decl));\n@@ -14549,6 +14550,9 @@ tsubst_copy_and_build (tree t,\n       RETURN (tsubst_expr(t, args, complain, in_decl,\n \t     integral_constant_expression_p));\n \n+    case PAREN_EXPR:\n+      RETURN (finish_parenthesized_expr (RECUR (TREE_OPERAND (t, 0))));\n+\n     default:\n       /* Handle Objective-C++ constructs, if appropriate.  */\n       {\n@@ -20593,9 +20597,7 @@ listify_autos (tree type, tree auto_node)\n tree\n do_auto_deduction (tree type, tree init, tree auto_node)\n {\n-  tree parms, tparms, targs;\n-  tree args[1];\n-  int val;\n+  tree targs;\n \n   if (init == error_mark_node)\n     return error_mark_node;\n@@ -20614,32 +20616,42 @@ do_auto_deduction (tree type, tree init, tree auto_node)\n \n   init = resolve_nondeduced_context (init);\n \n-  parms = build_tree_list (NULL_TREE, type);\n-  args[0] = init;\n-  tparms = make_tree_vec (1);\n   targs = make_tree_vec (1);\n-  TREE_VEC_ELT (tparms, 0)\n-    = build_tree_list (NULL_TREE, TYPE_NAME (auto_node));\n-  val = type_unification_real (tparms, targs, parms, args, 1, 0,\n-\t\t\t       DEDUCE_CALL, LOOKUP_NORMAL,\n-\t\t\t       /*explain_p=*/false);\n-  if (val > 0)\n-    {\n-      if (processing_template_decl)\n-\t/* Try again at instantiation time.  */\n-\treturn type;\n-      if (type && type != error_mark_node)\n-\t/* If type is error_mark_node a diagnostic must have been\n-\t   emitted by now.  Also, having a mention to '<type error>'\n-\t   in the diagnostic is not really useful to the user.  */\n+  if (AUTO_IS_DECLTYPE (auto_node))\n+    {\n+      bool id = (DECL_P (init) || TREE_CODE (init) == COMPONENT_REF);\n+      TREE_VEC_ELT (targs, 0)\n+\t= finish_decltype_type (init, id, tf_warning_or_error);\n+    }\n+  else\n+    {\n+      tree parms = build_tree_list (NULL_TREE, type);\n+      tree tparms = make_tree_vec (1);\n+      int val;\n+\n+      TREE_VEC_ELT (tparms, 0)\n+\t= build_tree_list (NULL_TREE, TYPE_NAME (auto_node));\n+      val = type_unification_real (tparms, targs, parms, &init, 1, 0,\n+\t\t\t\t   DEDUCE_CALL, LOOKUP_NORMAL,\n+\t\t\t\t   /*explain_p=*/false);\n+      if (val > 0)\n \t{\n-\t  if (cfun && auto_node == current_function_auto_return_pattern\n-\t      && LAMBDA_FUNCTION_P (current_function_decl))\n-\t    error (\"unable to deduce lambda return type from %qE\", init);\n-\t  else\n-\t    error (\"unable to deduce %qT from %qE\", type, init);\n+\t  if (processing_template_decl)\n+\t    /* Try again at instantiation time.  */\n+\t    return type;\n+\t  if (type && type != error_mark_node)\n+\t    /* If type is error_mark_node a diagnostic must have been\n+\t       emitted by now.  Also, having a mention to '<type error>'\n+\t       in the diagnostic is not really useful to the user.  */\n+\t    {\n+\t      if (cfun && auto_node == current_function_auto_return_pattern\n+\t\t  && LAMBDA_FUNCTION_P (current_function_decl))\n+\t\terror (\"unable to deduce lambda return type from %qE\", init);\n+\t      else\n+\t\terror (\"unable to deduce %qT from %qE\", type, init);\n+\t    }\n+\t  return error_mark_node;\n \t}\n-      return error_mark_node;\n     }\n \n   /* If the list of declarators contains more than one declarator, the type"}, {"sha": "63f18d022f910054e06364ead0bfba4bb0644b10", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10c6dc8e3932d33c8e47e6706885d2412b29c069/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10c6dc8e3932d33c8e47e6706885d2412b29c069/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=10c6dc8e3932d33c8e47e6706885d2412b29c069", "patch": "@@ -1507,6 +1507,38 @@ finish_mem_initializers (tree mem_inits)\n     emit_mem_initializers (mem_inits);\n }\n \n+/* Obfuscate EXPR if it looks like an id-expression or member access so\n+   that the call to finish_decltype in do_auto_deduction will give the\n+   right result.  */\n+\n+tree\n+force_paren_expr (tree expr)\n+{\n+  /* This is only needed for decltype(auto) in C++14.  */\n+  if (cxx_dialect < cxx1y)\n+    return expr;\n+\n+  if (!DECL_P (expr) && TREE_CODE (expr) != COMPONENT_REF\n+      && TREE_CODE (expr) != SCOPE_REF)\n+    return expr;\n+\n+  if (processing_template_decl)\n+    expr = build1 (PAREN_EXPR, TREE_TYPE (expr), expr);\n+  else\n+    {\n+      cp_lvalue_kind kind = lvalue_kind (expr);\n+      if ((kind & ~clk_class) != clk_none)\n+\t{\n+\t  tree type = unlowered_expr_type (expr);\n+\t  bool rval = !!(kind & clk_rvalueref);\n+\t  type = cp_build_reference_type (type, rval);\n+\t  expr = build_static_cast (type, expr, tf_warning_or_error);\n+\t}\n+    }\n+\n+  return expr;\n+}\n+\n /* Finish a parenthesized expression EXPR.  */\n \n tree\n@@ -1525,6 +1557,8 @@ finish_parenthesized_expr (tree expr)\n   if (TREE_CODE (expr) == STRING_CST)\n     PAREN_STRING_LITERAL_P (expr) = 1;\n \n+  expr = force_paren_expr (expr);\n+\n   return expr;\n }\n "}, {"sha": "bab58a63b907a0fddccd29024a77d3457166eb9a", "filename": "gcc/testsuite/g++.dg/cpp1y/auto-fn15.C", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10c6dc8e3932d33c8e47e6706885d2412b29c069/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fauto-fn15.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10c6dc8e3932d33c8e47e6706885d2412b29c069/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fauto-fn15.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fauto-fn15.C?ref=10c6dc8e3932d33c8e47e6706885d2412b29c069", "patch": "@@ -0,0 +1,50 @@\n+// { dg-options \"-std=c++1y -Wno-return-local-addr\" }\n+\n+template<class,class> struct same_type;\n+template<class T> struct same_type<T,T> {};\n+\n+int& f();\n+int i;\n+\n+decltype(auto) g() { return f(); }\n+decltype(auto) h1() { return i; }\n+decltype(auto) h2() { return (i); }\n+decltype(auto) h2a() { return 0,i; }\n+\n+struct A { int i; };\n+A a;\n+\n+decltype(auto) h3() { return a.i; }\n+decltype(auto) h4() { return (a.i); }\n+\n+template <class T>\n+decltype(auto) h5(T t) { return t.i; }\n+template <class T>\n+decltype(auto) h6(T t) { return (t.i); }\n+\n+int main()\n+{\n+  decltype(auto) i = f();\n+  same_type<decltype(i),int&>();\n+  decltype(auto) i2 = i;\n+  same_type<decltype(i2),int&>();\n+  decltype(auto) i3 = ::i;\n+  same_type<decltype(i3),int>();\n+  decltype(auto) i4 = (::i);\n+  same_type<decltype(i4),int&>();\n+  decltype(auto) i5 = a.i;\n+  same_type<decltype(i5),int>();\n+  decltype(auto) i6 = (a.i);\n+  same_type<decltype(i6),int&>();\n+  decltype(auto) i7 = true ? ::i : ::i;\n+  same_type<decltype(i7),int&>();\n+\n+  same_type<decltype(g()),int&>();\n+  same_type<decltype(h1()),int>();\n+  same_type<decltype(h2()),int&>();\n+  same_type<decltype(h2a()),int&>();\n+  same_type<decltype(h3()),int>();\n+  same_type<decltype(h4()),int&>();\n+  same_type<decltype(h5(a)),int>();\n+  same_type<decltype(h6(a)),int&>();\n+}"}, {"sha": "5caec52143a0af4fe9d84a6088af62b7d15a3c6d", "filename": "gcc/testsuite/g++.dg/cpp1y/auto-fn16.C", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10c6dc8e3932d33c8e47e6706885d2412b29c069/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fauto-fn16.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10c6dc8e3932d33c8e47e6706885d2412b29c069/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fauto-fn16.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fauto-fn16.C?ref=10c6dc8e3932d33c8e47e6706885d2412b29c069", "patch": "@@ -0,0 +1,12 @@\n+// { dg-options -std=c++1y }\n+\n+template<class,class> struct ST;\n+template<class T> struct ST<T,T> {};\n+\n+int j;\n+auto x3 = []()->auto&& { return j; }; // OK: return type is int&\n+\n+int main()\n+{\n+  ST<decltype(x3()),int&>();\n+}"}, {"sha": "8bc961ebc86b07a9852bcc06b18079e1cfa14e4f", "filename": "gcc/testsuite/g++.dg/cpp1y/auto-fn17.C", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10c6dc8e3932d33c8e47e6706885d2412b29c069/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fauto-fn17.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10c6dc8e3932d33c8e47e6706885d2412b29c069/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fauto-fn17.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fauto-fn17.C?ref=10c6dc8e3932d33c8e47e6706885d2412b29c069", "patch": "@@ -0,0 +1,22 @@\n+// { dg-options -std=c++1y }\n+// { dg-do run }\n+\n+int c;\n+int d;\n+\n+struct A\n+{\n+  A() { ++c; }\n+  A(const A&) { ++c; }\n+  ~A() { ++d; }\n+};\n+\n+A g() { return A(); }\n+decltype(auto) f() { return g(); }\n+\n+int main()\n+{\n+  f();\n+  if (c < 1 || c != d)\n+    __builtin_abort ();\n+}"}, {"sha": "b593a48cc55504fa89afa54344ca2f6b73be26a0", "filename": "gcc/testsuite/g++.dg/cpp1y/mangle1.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10c6dc8e3932d33c8e47e6706885d2412b29c069/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fmangle1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10c6dc8e3932d33c8e47e6706885d2412b29c069/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fmangle1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fmangle1.C?ref=10c6dc8e3932d33c8e47e6706885d2412b29c069", "patch": "@@ -0,0 +1,13 @@\n+// Test that the parens don't show up in the mangling\n+// { dg-options \"-std=c++1y -Wno-return-local-addr\" }\n+// { dg-final { scan-assembler \"_Z1gI1AEDTdtfp_1iET_\" } }\n+\n+struct A { int i; };\n+\n+template <class T>\n+auto g(T t)->decltype((t.i)) { return t.i; }\n+\n+int main()\n+{\n+  g(A());\n+}"}]}