{"sha": "a547eea2669af282dfca4f3c38362f109b285308", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTU0N2VlYTI2NjlhZjI4MmRmY2E0ZjNjMzgzNjJmMTA5YjI4NTMwOA==", "commit": {"author": {"name": "Bob Duff", "email": "duff@adacore.com", "date": "2021-05-19T15:37:47Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2021-07-07T16:23:15Z"}, "message": "[Ada] Fix bugs in Value_Size clauses and refactor\n\ngcc/ada/\n\n\t* sem_ch13.adb (Analyze_Attribute_Definition_Clause): Combine\n\tprocessing of Size and Value_Size clauses. Ensure that\n\tValue_Size is treated the same as Size, in the cases where both\n\tare allowed (i.e. the prefix denotes a first subtype).  Misc\n\tcleanup.\n\t* einfo-utils.adb (Init_Size): Add assertions.\n\t(Size_Clause): Return a Value_Size clause if present, instead of\n\tjust looking for a Size clause.\n\t* einfo.ads (Has_Size_Clause, Size_Clause): Change documentation\n\tto include Value_Size.\n\t* sem_ch13.ads, layout.ads, layout.adb: Comment modifications.", "tree": {"sha": "5cc8c1078625afb15eaebc43737cdb63f4c7bfee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5cc8c1078625afb15eaebc43737cdb63f4c7bfee"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a547eea2669af282dfca4f3c38362f109b285308", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a547eea2669af282dfca4f3c38362f109b285308", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a547eea2669af282dfca4f3c38362f109b285308", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a547eea2669af282dfca4f3c38362f109b285308/comments", "author": {"login": "bobduff", "id": 29099567, "node_id": "MDQ6VXNlcjI5MDk5NTY3", "avatar_url": "https://avatars.githubusercontent.com/u/29099567?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bobduff", "html_url": "https://github.com/bobduff", "followers_url": "https://api.github.com/users/bobduff/followers", "following_url": "https://api.github.com/users/bobduff/following{/other_user}", "gists_url": "https://api.github.com/users/bobduff/gists{/gist_id}", "starred_url": "https://api.github.com/users/bobduff/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bobduff/subscriptions", "organizations_url": "https://api.github.com/users/bobduff/orgs", "repos_url": "https://api.github.com/users/bobduff/repos", "events_url": "https://api.github.com/users/bobduff/events{/privacy}", "received_events_url": "https://api.github.com/users/bobduff/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2d71668e64c4b20aec823dbe5a1feb6338d527a2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2d71668e64c4b20aec823dbe5a1feb6338d527a2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2d71668e64c4b20aec823dbe5a1feb6338d527a2"}], "stats": {"total": 287, "additions": 145, "deletions": 142}, "files": [{"sha": "22143d62aaa970f01bd09156d90b6524fa525f5e", "filename": "gcc/ada/einfo-utils.adb", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a547eea2669af282dfca4f3c38362f109b285308/gcc%2Fada%2Feinfo-utils.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a547eea2669af282dfca4f3c38362f109b285308/gcc%2Fada%2Feinfo-utils.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo-utils.adb?ref=a547eea2669af282dfca4f3c38362f109b285308", "patch": "@@ -481,7 +481,13 @@ package body Einfo.Utils is\n \n    procedure Init_Size (Id : E; V : Int) is\n    begin\n-      pragma Assert (not Is_Object (Id));\n+      pragma Assert (Is_Type (Id));\n+      pragma Assert\n+        (not Known_Esize (Id) or else Esize (Id) = V);\n+      pragma Assert\n+        (RM_Size (Id) = No_Uint\n+           or else RM_Size (Id) = Uint_0\n+           or else RM_Size (Id) = V);\n       Set_Esize (Id, UI_From_Int (V));\n       Set_RM_Size (Id, UI_From_Int (V));\n    end Init_Size;\n@@ -492,7 +498,7 @@ package body Einfo.Utils is\n \n    procedure Init_Size_Align (Id : E) is\n    begin\n-      pragma Assert (not Is_Object (Id));\n+      pragma Assert (Ekind (Id) in Type_Kind | E_Void);\n       Set_Esize (Id, Uint_0);\n       Set_RM_Size (Id, Uint_0);\n       Set_Alignment (Id, Uint_0);\n@@ -2927,8 +2933,13 @@ package body Einfo.Utils is\n    -----------------\n \n    function Size_Clause (Id : E) return N is\n+      Result : N := Get_Attribute_Definition_Clause (Id, Attribute_Size);\n    begin\n-      return Get_Attribute_Definition_Clause (Id, Attribute_Size);\n+      if No (Result) then\n+         Result := Get_Attribute_Definition_Clause (Id, Attribute_Value_Size);\n+      end if;\n+\n+      return Result;\n    end Size_Clause;\n \n    ------------------------"}, {"sha": "6a8d49352b8b8a154e2cd0cd053aa8e8b8b62ecc", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a547eea2669af282dfca4f3c38362f109b285308/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a547eea2669af282dfca4f3c38362f109b285308/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=a547eea2669af282dfca4f3c38362f109b285308", "patch": "@@ -2015,11 +2015,11 @@ package Einfo is\n --       which at least one of the shift operators is defined.\n \n --    Has_Size_Clause\n---       Defined in entities for types and objects. Set if a size clause is\n---       defined for the entity. Used to prevent multiple Size clauses for a\n---       given entity. Note that it is always initially cleared for a derived\n---       type, even though the Size for such a type is inherited from a Size\n---       clause given for the parent type.\n+--       Defined in entities for types and objects. Set if a size or value size\n+--       clause is defined for the entity. Used to prevent multiple clauses\n+--       for a given entity. Note that it is always initially cleared for a\n+--       derived type, even though the Size or Value_Size clause for such a\n+--       type might be inherited from an ancestor type.\n \n --    Has_Small_Clause\n --       Defined in ordinary fixed point types (but not subtypes). Indicates\n@@ -4321,13 +4321,12 @@ package Einfo is\n --       suppress this code if a subsequent address clause is encountered.\n \n --    Size_Clause (synthesized)\n---       Applies to all entities. If a size clause is present in the rep\n---       item chain for an entity then the attribute definition clause node\n---       for the size clause is returned. Otherwise Size_Clause returns Empty\n---       if no item is present. Usually this is only meaningful if the flag\n---       Has_Size_Clause is set. This is because when the representation item\n---       chain is copied for a derived type, it can inherit a size clause that\n---       is not applicable to the entity.\n+--       Applies to all entities. If a size or value size clause is present in\n+--       the rep item chain for an entity then that attribute definition clause\n+--       is returned. Otherwise Size_Clause returns Empty. Usually this is only\n+--       meaningful if the flag Has_Size_Clause is set. This is because when\n+--       the representation item chain is copied for a derived type, it can\n+--       inherit a size clause that is not applicable to the entity.\n \n --    Size_Depends_On_Discriminant\n --       Defined in all entities for types and subtypes. Indicates that the"}, {"sha": "6dc4d7fb699c70a6244dd1834ef4467a572b3c3b", "filename": "gcc/ada/layout.adb", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a547eea2669af282dfca4f3c38362f109b285308/gcc%2Fada%2Flayout.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a547eea2669af282dfca4f3c38362f109b285308/gcc%2Fada%2Flayout.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flayout.adb?ref=a547eea2669af282dfca4f3c38362f109b285308", "patch": "@@ -270,15 +270,15 @@ package body Layout is\n             Desig_Type := Non_Limited_View (Designated_Type (E));\n          end if;\n \n-         --  If Esize already set (e.g. by a size clause), then nothing further\n-         --  to be done here.\n+         --  If Esize already set (e.g. by a size or value size clause), then\n+         --  nothing further to be done here.\n \n          if Known_Esize (E) then\n             null;\n \n-         --  Access to subprogram is a strange beast, and we let the backend\n-         --  figure out what is needed (it may be some kind of fat pointer,\n-         --  including the static link for example.\n+         --  Access to protected subprogram is a strange beast, and we let the\n+         --  backend figure out what is needed (it may be some kind of fat\n+         --  pointer, including the static link for example).\n \n          elsif Is_Access_Protected_Subprogram_Type (E) then\n             null;"}, {"sha": "89ee5bde7140a5bcdcf33c3e189d2b260dfd7adc", "filename": "gcc/ada/layout.ads", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a547eea2669af282dfca4f3c38362f109b285308/gcc%2Fada%2Flayout.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a547eea2669af282dfca4f3c38362f109b285308/gcc%2Fada%2Flayout.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flayout.ads?ref=a547eea2669af282dfca4f3c38362f109b285308", "patch": "@@ -32,10 +32,9 @@ with Types; use Types;\n \n package Layout is\n \n-   --  The following procedures are called from Freeze, so all entities\n-   --  for types and objects that get frozen (which should be all such\n-   --  entities which are seen by the back end) will get laid out by one\n-   --  of these two procedures.\n+   --  The following procedures are called from Freeze, so all entities for\n+   --  types and objects that get frozen (i.e. all types and objects seen by\n+   --  the back end) will get laid out by one of these two procedures.\n \n    procedure Layout_Type (E : Entity_Id);\n    --  This procedure may set or adjust the fields Esize, RM_Size and"}, {"sha": "92d52494e49b575a2c07a15d8a3ba761ea4e77a8", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 101, "deletions": 107, "changes": 208, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a547eea2669af282dfca4f3c38362f109b285308/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a547eea2669af282dfca4f3c38362f109b285308/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=a547eea2669af282dfca4f3c38362f109b285308", "patch": "@@ -7180,109 +7180,136 @@ package body Sem_Ch13 is\n                Set_SSO_Set_High_By_Default (Base_Type (U_Ent), False);\n             end if;\n \n-         ----------\n-         -- Size --\n-         ----------\n+         ------------------------\n+         -- Size or Value_Size --\n+         ------------------------\n \n-         --  Size attribute definition clause\n+         --  Size or Value_Size attribute definition clause. These are treated\n+         --  the same, except that Size is allowed on objects, and Value_Size\n+         --  is allowed on nonfirst subtypes. First subtypes allow both Size\n+         --  and Value_Size; the treatment is the same for both.\n \n-         when Attribute_Size => Size : declare\n+         when Attribute_Size | Attribute_Value_Size => Size : declare\n             Size   : constant Uint := Static_Integer (Expr);\n-            Etyp   : Entity_Id;\n-            Biased : Boolean;\n+\n+            Attr_Name : constant String :=\n+              (if Id = Attribute_Size then \"size\"\n+               elsif Id = Attribute_Value_Size then \"value size\"\n+               else \"\"); -- can't happen\n+            --  Name of the attribute for printing in messages\n+\n+            OK_Prefix : constant Boolean :=\n+              (if Id = Attribute_Size then\n+                Ekind (U_Ent) in Type_Kind | Constant_Or_Variable_Kind\n+               elsif Id = Attribute_Value_Size then\n+                Ekind (U_Ent) in Type_Kind\n+               else False); -- can't happen\n+            --  For X'Size, X can be a type or object; for X'Value_Size,\n+            --  X can be a type. Note that we already checked that 'Size\n+            --  can be specified only for a first subytype.\n \n          begin\n             FOnly := True;\n \n-            if Duplicate_Clause then\n-               null;\n+            if not OK_Prefix then\n+               Error_Msg_N (Attr_Name & \" cannot be given for &\", Nam);\n \n-            elsif not Is_Type (U_Ent)\n-              and then Ekind (U_Ent) /= E_Variable\n-              and then Ekind (U_Ent) /= E_Constant\n-            then\n-               Error_Msg_N (\"size cannot be given for &\", Nam);\n+            elsif Duplicate_Clause then\n+               null;\n \n             elsif Is_Array_Type (U_Ent)\n               and then not Is_Constrained (U_Ent)\n             then\n                Error_Msg_N\n-                 (\"size cannot be given for unconstrained array\", Nam);\n+                 (Attr_Name & \" cannot be given for unconstrained array\", Nam);\n \n             elsif Size /= No_Uint then\n-               if Is_Type (U_Ent) then\n-                  Etyp := U_Ent;\n-               else\n-                  Etyp := Etype (U_Ent);\n-               end if;\n+               declare\n+                  Etyp : constant Entity_Id :=\n+                    (if Is_Type (U_Ent) then U_Ent else Etype (U_Ent));\n \n-               --  Check size, note that Gigi is in charge of checking that the\n-               --  size of an array or record type is OK. Also we do not check\n-               --  the size in the ordinary fixed-point case, since it is too\n-               --  early to do so (there may be subsequent small clause that\n-               --  affects the size). We can check the size if a small clause\n-               --  has already been given.\n+               begin\n+                  --  Check size, note that Gigi is in charge of checking that\n+                  --  the size of an array or record type is OK. Also we do not\n+                  --  check the size in the ordinary fixed-point case, since\n+                  --  it is too early to do so (there may be subsequent small\n+                  --  clause that affects the size). We can check the size if\n+                  --  a small clause has already been given.\n+\n+                  if not Is_Ordinary_Fixed_Point_Type (U_Ent)\n+                    or else Has_Small_Clause (U_Ent)\n+                  then\n+                     declare\n+                        Biased : Boolean;\n+                     begin\n+                        Check_Size (Expr, Etyp, Size, Biased);\n+                        Set_Biased (U_Ent, N, Attr_Name & \" clause\", Biased);\n+                     end;\n+                  end if;\n \n-               if not Is_Ordinary_Fixed_Point_Type (U_Ent)\n-                 or else Has_Small_Clause (U_Ent)\n-               then\n-                  Check_Size (Expr, Etyp, Size, Biased);\n-                  Set_Biased (U_Ent, N, \"size clause\", Biased);\n-               end if;\n+                  --  For types, set RM_Size and Esize if appropriate\n \n-               --  For types set RM_Size and Esize if possible\n+                  if Is_Type (U_Ent) then\n+                     Set_RM_Size (U_Ent, Size);\n \n-               if Is_Type (U_Ent) then\n-                  Set_RM_Size (U_Ent, Size);\n+                     --  If we are specifying the Size or Value_Size of a\n+                     --  first subtype, then for elementary types, increase\n+                     --  Object_Size to power of 2, but not less than a storage\n+                     --  unit in any case (normally this means it will be byte\n+                     --  addressable).\n \n-                  --  For elementary types, increase Object_Size to power of 2,\n-                  --  but not less than a storage unit in any case (normally\n-                  --  this means it will be byte addressable).\n+                     --  For all other types, nothing else to do, we leave\n+                     --  Esize (object size) unset; the back end will set it\n+                     --  from the size and alignment in an appropriate manner.\n \n-                  --  For all other types, nothing else to do, we leave Esize\n-                  --  (object size) unset, the back end will set it from the\n-                  --  size and alignment in an appropriate manner.\n+                     --  In both cases, we check whether the alignment must be\n+                     --  reset in the wake of the size change.\n \n-                  --  In both cases, we check whether the alignment must be\n-                  --  reset in the wake of the size change.\n+                     --  For nonfirst subtypes ('Value_Size only), we do\n+                     --  nothing here.\n \n-                  if Is_Elementary_Type (U_Ent) then\n-                     if Size <= System_Storage_Unit then\n-                        Init_Esize (U_Ent, System_Storage_Unit);\n-                     elsif Size <= 16 then\n-                        Init_Esize (U_Ent, 16);\n-                     elsif Size <= 32 then\n-                        Init_Esize (U_Ent, 32);\n-                     else\n-                        Set_Esize  (U_Ent, (Size + 63) / 64 * 64);\n+                     if Is_First_Subtype (U_Ent) then\n+                        if Is_Elementary_Type (U_Ent) then\n+                           if Size <= System_Storage_Unit then\n+                              Init_Esize (U_Ent, System_Storage_Unit);\n+                           elsif Size <= 16 then\n+                              Init_Esize (U_Ent, 16);\n+                           elsif Size <= 32 then\n+                              Init_Esize (U_Ent, 32);\n+                           else\n+                              Set_Esize  (U_Ent, (Size + 63) / 64 * 64);\n+                           end if;\n+\n+                           Alignment_Check_For_Size_Change\n+                             (U_Ent, Esize (U_Ent));\n+                        else\n+                           Alignment_Check_For_Size_Change (U_Ent, Size);\n+                        end if;\n                      end if;\n \n-                     Alignment_Check_For_Size_Change (U_Ent, Esize (U_Ent));\n-                  else\n-                     Alignment_Check_For_Size_Change (U_Ent, Size);\n-                  end if;\n+                  --  For Object'Size, set Esize only\n \n-               --  For objects, set Esize only\n+                  else\n+                     if Is_Elementary_Type (Etyp)\n+                       and then Size /= System_Storage_Unit\n+                       and then Size /= 16\n+                       and then Size /= 32\n+                       and then Size /= 64\n+                       and then Size /= System_Max_Integer_Size\n+                     then\n+                        Error_Msg_Uint_1 := UI_From_Int (System_Storage_Unit);\n+                        Error_Msg_Uint_2 :=\n+                          UI_From_Int (System_Max_Integer_Size);\n+                        Error_Msg_N\n+                          (\"size for primitive object must be a power of 2 in \"\n+                           & \"the range ^-^\", N);\n+                     end if;\n \n-               else\n-                  if Is_Elementary_Type (Etyp)\n-                    and then Size /= System_Storage_Unit\n-                    and then Size /= 16\n-                    and then Size /= 32\n-                    and then Size /= 64\n-                    and then Size /= System_Max_Integer_Size\n-                  then\n-                     Error_Msg_Uint_1 := UI_From_Int (System_Storage_Unit);\n-                     Error_Msg_Uint_2 := UI_From_Int (System_Max_Integer_Size);\n-                     Error_Msg_N\n-                       (\"size for primitive object must be a power of 2 in \"\n-                        & \"the range ^-^\", N);\n+                     Set_Esize (U_Ent, Size);\n                   end if;\n \n-                  Set_Esize (U_Ent, Size);\n-               end if;\n-\n-               Set_Has_Size_Clause (U_Ent);\n+                  Set_Has_Size_Clause (U_Ent);\n+               end;\n             end if;\n          end Size;\n \n@@ -7744,39 +7771,6 @@ package body Sem_Ch13 is\n             end if;\n          end Stream_Size;\n \n-         ----------------\n-         -- Value_Size --\n-         ----------------\n-\n-         --  Value_Size attribute definition clause\n-\n-         when Attribute_Value_Size => Value_Size : declare\n-            Size   : constant Uint := Static_Integer (Expr);\n-            Biased : Boolean;\n-\n-         begin\n-            if not Is_Type (U_Ent) then\n-               Error_Msg_N (\"Value_Size cannot be given for &\", Nam);\n-\n-            elsif Duplicate_Clause then\n-               null;\n-\n-            elsif Is_Array_Type (U_Ent)\n-              and then not Is_Constrained (U_Ent)\n-            then\n-               Error_Msg_N\n-                 (\"Value_Size cannot be given for unconstrained array\", Nam);\n-\n-            else\n-               if Is_Elementary_Type (U_Ent) then\n-                  Check_Size (Expr, U_Ent, Size, Biased);\n-                  Set_Biased (U_Ent, N, \"value size clause\", Biased);\n-               end if;\n-\n-               Set_RM_Size (U_Ent, Size);\n-            end if;\n-         end Value_Size;\n-\n          -----------------------\n          -- Variable_Indexing --\n          -----------------------"}, {"sha": "3b21484c37a95e7bc2c11d0ef8a398f692f7b4f9", "filename": "gcc/ada/sem_ch13.ads", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a547eea2669af282dfca4f3c38362f109b285308/gcc%2Fada%2Fsem_ch13.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a547eea2669af282dfca4f3c38362f109b285308/gcc%2Fada%2Fsem_ch13.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.ads?ref=a547eea2669af282dfca4f3c38362f109b285308", "patch": "@@ -115,17 +115,17 @@ package Sem_Ch13 is\n       Siz    : Uint;\n       Biased : out Boolean);\n    --  Called when size Siz is specified for subtype T. This subprogram checks\n-   --  that the size is appropriate, posting errors on node N as required.\n-   --  This check is effective for elementary types and bit-packed arrays.\n-   --  For other non-elementary types, a check is only made if an explicit\n-   --  size has been given for the type (and the specified size must match).\n-   --  The parameter Biased is set False if the size specified did not require\n-   --  the use of biased representation, and True if biased representation\n-   --  was required to meet the size requirement. Note that Biased is only\n-   --  set if the type is not currently biased, but biasing it is the only\n-   --  way to meet the requirement. If the type is currently biased, then\n-   --  this biased size is used in the initial check, and Biased is False.\n-   --  For a Component_Size clause, T is the component type.\n+   --  that the size is appropriate, posting errors on node N as required. This\n+   --  check is effective for elementary types and bit-packed arrays. For\n+   --  composite types, a check is only made if an explicit size has been given\n+   --  for the type (and the specified size must match).  The parameter Biased\n+   --  is set False if the size specified did not require the use of biased\n+   --  representation, and True if biased representation was required to meet\n+   --  the size requirement. Note that Biased is only set if the type is not\n+   --  currently biased, but biasing it is the only way to meet the\n+   --  requirement. If the type is currently biased, then this biased size is\n+   --  used in the initial check, and Biased is False. For a Component_Size\n+   --  clause, T is the component type.\n \n    function Has_Compatible_Representation\n      (Target_Type, Operand_Type : Entity_Id) return Boolean;"}]}