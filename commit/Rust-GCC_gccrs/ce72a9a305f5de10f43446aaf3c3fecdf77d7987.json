{"sha": "ce72a9a305f5de10f43446aaf3c3fecdf77d7987", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2U3MmE5YTMwNWY1ZGUxMGY0MzQ0NmFhZjNjM2ZlY2RmNzdkNzk4Nw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-10-06T19:24:49Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-10-06T19:24:49Z"}, "message": "[multiple changes]\n\n2011-10-06  Robert Dewar  <dewar@adacore.com>\n\n\t* a-ciorse.adb, a-cihase.adb, a-cihase.ads, a-coorse.adb,\n\ta-cborse.adb, a-comutr.adb, a-ciorma.adb, a-cbmutr.adb,\n\ta-cbmutr.ads, a-cbhase.adb, a-cbhase.ads: Minor reformatting and code\n\treorganization (use conditional expressions).\n\n2011-10-06  Robert Dewar  <dewar@adacore.com>\n\n\t* sem_res.adb (Resolve_Arithmetic_Op): Fix bad warning for\n\tfloating divide by zero.\n\n2011-10-06  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch6.adb: Limited interfaces that are not immutably limited\n\tare OK in return statements.\n\nFrom-SVN: r179629", "tree": {"sha": "9c94e0d985fc138c19bf5450274084c744d41e82", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9c94e0d985fc138c19bf5450274084c744d41e82"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ce72a9a305f5de10f43446aaf3c3fecdf77d7987", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce72a9a305f5de10f43446aaf3c3fecdf77d7987", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ce72a9a305f5de10f43446aaf3c3fecdf77d7987", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce72a9a305f5de10f43446aaf3c3fecdf77d7987/comments", "author": null, "committer": null, "parents": [{"sha": "908e19d0d0644e734cba0869184e15400222d6b7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/908e19d0d0644e734cba0869184e15400222d6b7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/908e19d0d0644e734cba0869184e15400222d6b7"}], "stats": {"total": 926, "additions": 322, "deletions": 604}, "files": [{"sha": "1a1bb68d318a9cfbc741bf620f6261126dabeb1d", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce72a9a305f5de10f43446aaf3c3fecdf77d7987/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce72a9a305f5de10f43446aaf3c3fecdf77d7987/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=ce72a9a305f5de10f43446aaf3c3fecdf77d7987", "patch": "@@ -1,3 +1,20 @@\n+2011-10-06  Robert Dewar  <dewar@adacore.com>\n+\n+\t* a-ciorse.adb, a-cihase.adb, a-cihase.ads, a-coorse.adb,\n+\ta-cborse.adb, a-comutr.adb, a-ciorma.adb, a-cbmutr.adb,\n+\ta-cbmutr.ads, a-cbhase.adb, a-cbhase.ads: Minor reformatting and code\n+\treorganization (use conditional expressions).\n+\n+2011-10-06  Robert Dewar  <dewar@adacore.com>\n+\n+\t* sem_res.adb (Resolve_Arithmetic_Op): Fix bad warning for\n+\tfloating divide by zero.\n+\n+2011-10-06  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch6.adb: Limited interfaces that are not immutably limited\n+\tare OK in return statements.\n+\n 2011-09-30  Iain Sandoe  <iains@gcc.gnu.org>\n \n \t* gcc-interface/Makefile.in (Darwin): Partial reversion of previous"}, {"sha": "97a765a6839793e35da55696bdf8fcd635e7df40", "filename": "gcc/ada/a-cbhase.adb", "status": "modified", "additions": 33, "deletions": 61, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce72a9a305f5de10f43446aaf3c3fecdf77d7987/gcc%2Fada%2Fa-cbhase.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce72a9a305f5de10f43446aaf3c3fecdf77d7987/gcc%2Fada%2Fa-cbhase.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cbhase.adb?ref=ce72a9a305f5de10f43446aaf3c3fecdf77d7987", "patch": "@@ -47,7 +47,7 @@ package body Ada.Containers.Bounded_Hashed_Sets is\n    overriding function First (Object : Iterator) return Cursor;\n \n    overriding function Next\n-     (Object : Iterator;\n+     (Object   : Iterator;\n       Position : Cursor) return Cursor;\n \n    -----------------------\n@@ -68,9 +68,7 @@ package body Ada.Containers.Bounded_Hashed_Sets is\n       Node      : out Count_Type;\n       Inserted  : out Boolean);\n \n-   function Is_In\n-     (HT  : Set;\n-      Key : Node_Type) return Boolean;\n+   function Is_In (HT : Set; Key : Node_Type) return Boolean;\n    pragma Inline (Is_In);\n \n    procedure Set_Element (Node : in out Node_Type; Item : Element_Type);\n@@ -169,7 +167,6 @@ package body Ada.Containers.Bounded_Hashed_Sets is\n          N : Node_Type renames Source.Nodes (Source_Node);\n          X : Count_Type;\n          B : Boolean;\n-\n       begin\n          Insert (Target, N.Element, X, B);\n          pragma Assert (B);\n@@ -233,10 +230,8 @@ package body Ada.Containers.Bounded_Hashed_Sets is\n    begin\n       if Capacity = 0 then\n          C := Source.Length;\n-\n       elsif Capacity >= Source.Length then\n          C := Capacity;\n-\n       else\n          raise Capacity_Error with \"Capacity value too small\";\n       end if;\n@@ -396,7 +391,6 @@ package body Ada.Containers.Bounded_Hashed_Sets is\n                N : Node_Type renames Left.Nodes (L_Node);\n                X : Count_Type;\n                B : Boolean;\n-\n             begin\n                if not Is_In (Right, N) then\n                   Insert (Result, N.Element, X, B);  --  optimize this ???\n@@ -428,7 +422,6 @@ package body Ada.Containers.Bounded_Hashed_Sets is\n       declare\n          S : Set renames Position.Container.all;\n          N : Node_Type renames S.Nodes (Position.Node);\n-\n       begin\n          return N.Element;\n       end;\n@@ -488,6 +481,7 @@ package body Ada.Containers.Bounded_Hashed_Sets is\n \n    function Equivalent_Elements (Left, Right : Cursor)\n      return Boolean is\n+\n    begin\n       if Left.Node = 0 then\n          raise Constraint_Error with\n@@ -505,14 +499,15 @@ package body Ada.Containers.Bounded_Hashed_Sets is\n       declare\n          LN : Node_Type renames Left.Container.Nodes (Left.Node);\n          RN : Node_Type renames Right.Container.Nodes (Right.Node);\n-\n       begin\n          return Equivalent_Elements (LN.Element, RN.Element);\n       end;\n    end Equivalent_Elements;\n \n-   function Equivalent_Elements (Left : Cursor; Right : Element_Type)\n-     return Boolean is\n+   function Equivalent_Elements\n+     (Left  : Cursor;\n+      Right : Element_Type) return Boolean\n+   is\n    begin\n       if Left.Node = 0 then\n          raise Constraint_Error with\n@@ -528,8 +523,10 @@ package body Ada.Containers.Bounded_Hashed_Sets is\n       end;\n    end Equivalent_Elements;\n \n-   function Equivalent_Elements (Left : Element_Type; Right : Cursor)\n-     return Boolean is\n+   function Equivalent_Elements\n+     (Left  : Element_Type;\n+      Right : Cursor) return Boolean\n+   is\n    begin\n       if Right.Node = 0 then\n          raise Constraint_Error with\n@@ -551,8 +548,10 @@ package body Ada.Containers.Bounded_Hashed_Sets is\n    -- Equivalent_Keys --\n    ---------------------\n \n-   function Equivalent_Keys (Key : Element_Type; Node : Node_Type)\n-     return Boolean is\n+   function Equivalent_Keys\n+     (Key  : Element_Type;\n+      Node : Node_Type) return Boolean\n+   is\n    begin\n       return Equivalent_Elements (Key, Node.Element);\n    end Equivalent_Keys;\n@@ -580,13 +579,9 @@ package body Ada.Containers.Bounded_Hashed_Sets is\n       Item      : Element_Type) return Cursor\n    is\n       Node : constant Count_Type := Element_Keys.Find (Container, Item);\n-\n    begin\n-      if Node = 0 then\n-         return No_Element;\n-      end if;\n-\n-      return Cursor'(Container'Unrestricted_Access, Node);\n+      return (if Node = 0 then No_Element\n+              else Cursor'(Container'Unrestricted_Access, Node));\n    end Find;\n \n    -----------\n@@ -595,23 +590,16 @@ package body Ada.Containers.Bounded_Hashed_Sets is\n \n    function First (Container : Set) return Cursor is\n       Node : constant Count_Type := HT_Ops.First (Container);\n-\n    begin\n-      if Node = 0 then\n-         return No_Element;\n-      end if;\n-\n-      return Cursor'(Container'Unrestricted_Access, Node);\n+      return (if Node = 0 then No_Element\n+              else Cursor'(Container'Unrestricted_Access, Node));\n    end First;\n \n    overriding function First (Object : Iterator) return Cursor is\n       Node : constant Count_Type := HT_Ops.First (Object.Container.all);\n    begin\n-      if Node = 0 then\n-         return No_Element;\n-      end if;\n-\n-      return Cursor'(Object.Container, Node);\n+      return (if Node = 0 then No_Element\n+              else Cursor'(Object.Container, Node));\n    end First;\n \n    -----------------\n@@ -999,11 +987,7 @@ package body Ada.Containers.Bounded_Hashed_Sets is\n            \"Position cursor designates wrong set\";\n       end if;\n \n-      if Position.Node = 0 then\n-         return No_Element;\n-      end if;\n-\n-      return Next (Position);\n+      return (if Position.Node = 0 then No_Element else Next (Position));\n    end Next;\n \n    -------------\n@@ -1143,12 +1127,10 @@ package body Ada.Containers.Bounded_Hashed_Sets is\n      (Container : aliased Set;\n       Position  : Cursor) return Constant_Reference_Type\n    is\n+      pragma Unreferenced (Container);\n       S : Set renames Position.Container.all;\n       N : Node_Type renames S.Nodes (Position.Node);\n-\n    begin\n-      pragma Unreferenced (Container);\n-\n       return (Element => N.Element'Unrestricted_Access);\n    end Constant_Reference;\n \n@@ -1316,7 +1298,6 @@ package body Ada.Containers.Bounded_Hashed_Sets is\n                N : Node_Type renames Left.Nodes (L_Node);\n                X : Count_Type;\n                B : Boolean;\n-\n             begin\n                if not Is_In (Right, N) then\n                   Insert (Result, N.Element, X, B);\n@@ -1344,7 +1325,6 @@ package body Ada.Containers.Bounded_Hashed_Sets is\n                N : Node_Type renames Right.Nodes (R_Node);\n                X : Count_Type;\n                B : Boolean;\n-\n             begin\n                if not Is_In (Left, N) then\n                   Insert (Result, N.Element, X, B);\n@@ -1367,7 +1347,6 @@ package body Ada.Containers.Bounded_Hashed_Sets is\n    function To_Set (New_Item : Element_Type) return Set is\n       X : Count_Type;\n       B : Boolean;\n-\n    begin\n       return Result : Set (1, 1) do\n          Insert (Result, New_Item, X, B);\n@@ -1396,7 +1375,6 @@ package body Ada.Containers.Bounded_Hashed_Sets is\n          N : Node_Type renames Source.Nodes (Src_Node);\n          X : Count_Type;\n          B : Boolean;\n-\n       begin\n          Insert (Target, N.Element, X, B);\n       end Process;\n@@ -1413,7 +1391,7 @@ package body Ada.Containers.Bounded_Hashed_Sets is\n            \"attempt to tamper with cursors (set is busy)\";\n       end if;\n \n-      --  ???\n+      --  ??? why is this code commented out ???\n       --  declare\n       --     N : constant Count_Type := Target.Length + Source.Length;\n       --  begin\n@@ -1661,15 +1639,10 @@ package body Ada.Containers.Bounded_Hashed_Sets is\n         (Container : Set;\n          Key       : Key_Type) return Cursor\n       is\n-         Node : constant Count_Type :=\n-                  Key_Keys.Find (Container, Key);\n-\n+         Node : constant Count_Type := Key_Keys.Find (Container, Key);\n       begin\n-         if Node = 0 then\n-            return No_Element;\n-         end if;\n-\n-         return Cursor'(Container'Unrestricted_Access, Node);\n+         return (if Node = 0 then No_Element\n+                 else Cursor'(Container'Unrestricted_Access, Node));\n       end Find;\n \n       ---------\n@@ -1684,7 +1657,6 @@ package body Ada.Containers.Bounded_Hashed_Sets is\n          end if;\n \n          pragma Assert (Vet (Position), \"bad cursor in function Key\");\n-\n          return Key (Position.Container.Nodes (Position.Node).Element);\n       end Key;\n \n@@ -1697,8 +1669,7 @@ package body Ada.Containers.Bounded_Hashed_Sets is\n          Key       : Key_Type;\n          New_Item  : Element_Type)\n       is\n-         Node : constant Count_Type :=\n-                  Key_Keys.Find (Container, Key);\n+         Node : constant Count_Type := Key_Keys.Find (Container, Key);\n \n       begin\n          if Node = 0 then\n@@ -1733,7 +1704,7 @@ package body Ada.Containers.Bounded_Hashed_Sets is\n               \"Position cursor designates wrong set\";\n          end if;\n \n-         --  ???\n+         --  ??? why is this code commented out ???\n          --  if HT.Buckets = null\n          --    or else HT.Buckets'Length = 0\n          --    or else HT.Length = 0\n@@ -1747,7 +1718,8 @@ package body Ada.Containers.Bounded_Hashed_Sets is\n            (Vet (Position),\n             \"bad cursor in Update_Element_Preserving_Key\");\n \n-         --  Record bucket now, in case key is changed.\n+         --  Record bucket now, in case key is changed\n+\n          Indx := HT_Ops.Index (Container.Buckets, N (Position.Node));\n \n          declare\n@@ -1823,10 +1795,10 @@ package body Ada.Containers.Bounded_Hashed_Sets is\n \n       function Reference_Preserving_Key\n         (Container : aliased in out Set;\n-         Key  : Key_Type) return Reference_Type\n+         Key       : Key_Type) return Reference_Type\n       is\n          Position : constant Cursor := Find (Container, Key);\n-         N : Node_Type renames Container.Nodes (Position.Node);\n+         N        : Node_Type renames Container.Nodes (Position.Node);\n       begin\n          return (Element => N.Element'Unrestricted_Access);\n       end Reference_Preserving_Key;"}, {"sha": "3f6b6696871cc5d2f5ea548bc80cc25da5993867", "filename": "gcc/ada/a-cbhase.ads", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce72a9a305f5de10f43446aaf3c3fecdf77d7987/gcc%2Fada%2Fa-cbhase.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce72a9a305f5de10f43446aaf3c3fecdf77d7987/gcc%2Fada%2Fa-cbhase.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cbhase.ads?ref=ce72a9a305f5de10f43446aaf3c3fecdf77d7987", "patch": "@@ -148,8 +148,7 @@ package Ada.Containers.Bounded_Hashed_Sets is\n \n    function Constant_Reference\n      (Container : aliased Set;\n-      Position  : Cursor)\n-   return Constant_Reference_Type;\n+      Position  : Cursor) return Constant_Reference_Type;\n \n    procedure Assign (Target : in out Set; Source : Set);\n    --  If Target denotes the same object as Source, then the operation has no\n@@ -355,8 +354,9 @@ package Ada.Containers.Bounded_Hashed_Sets is\n       Process   : not null access procedure (Position : Cursor));\n    --  Calls Process for each node in the set\n \n-   function Iterate (Container : Set)\n-     return Set_Iterator_Interfaces.Forward_Iterator'Class;\n+   function Iterate\n+     (Container : Set)\n+      return Set_Iterator_Interfaces.Forward_Iterator'Class;\n \n    generic\n       type Key_Type (<>) is private;\n@@ -431,13 +431,11 @@ package Ada.Containers.Bounded_Hashed_Sets is\n \n       function Reference_Preserving_Key\n         (Container : aliased in out Set;\n-         Position  : Cursor)\n-      return Reference_Type;\n+         Position  : Cursor) return Reference_Type;\n \n       function Reference_Preserving_Key\n         (Container : aliased in out Set;\n-         Key  : Key_Type)\n-      return Reference_Type;\n+         Key       : Key_Type) return Reference_Type;\n \n    private\n       type Reference_Type (Element : not null access Element_Type)\n@@ -446,7 +444,6 @@ package Ada.Containers.Bounded_Hashed_Sets is\n    end Generic_Keys;\n \n private\n-\n    pragma Inline (Next);\n \n    type Node_Type is record\n@@ -519,6 +516,6 @@ private\n    for Constant_Reference_Type'Write use Write;\n \n    Empty_Set : constant Set :=\n-     (Hash_Table_Type with Capacity => 0, Modulus => 0);\n+                 (Hash_Table_Type with Capacity => 0, Modulus => 0);\n \n end Ada.Containers.Bounded_Hashed_Sets;"}, {"sha": "7ad2de4e62ae7230f1bdbac0704ae907b5911380", "filename": "gcc/ada/a-cbmutr.adb", "status": "modified", "additions": 15, "deletions": 21, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce72a9a305f5de10f43446aaf3c3fecdf77d7987/gcc%2Fada%2Fa-cbmutr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce72a9a305f5de10f43446aaf3c3fecdf77d7987/gcc%2Fada%2Fa-cbmutr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cbmutr.adb?ref=ce72a9a305f5de10f43446aaf3c3fecdf77d7987", "patch": "@@ -54,11 +54,11 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n    overriding function First (Object : Child_Iterator) return Cursor;\n \n    overriding function Next\n-     (Object : Child_Iterator;\n+     (Object   : Child_Iterator;\n       Position : Cursor) return Cursor;\n \n    overriding function Previous\n-     (Object : Child_Iterator;\n+     (Object   : Child_Iterator;\n       Position : Cursor) return Cursor;\n \n    overriding function Last (Object : Child_Iterator) return Cursor;\n@@ -599,10 +599,8 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n    begin\n       if Capacity = 0 then\n          C := Source.Count;\n-\n       elsif Capacity >= Source.Count then\n          C := Capacity;\n-\n       else\n          raise Capacity_Error with \"Capacity value too small\";\n       end if;\n@@ -841,33 +839,33 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n       --  nodes that contain elements that have been inserted onto the tree,\n       --  and another for the \"inactive\" nodes of the free store, from which\n       --  nodes are allocated when a new child is inserted in the tree.\n-      --\n+\n       --  We desire that merely declaring a tree object should have only\n       --  minimal cost; specially, we want to avoid having to initialize the\n       --  free store (to fill in the links), especially if the capacity of the\n       --  tree object is large.\n-      --\n+\n       --  The head of the free list is indicated by Container.Free. If its\n       --  value is non-negative, then the free store has been initialized in\n       --  the \"normal\" way: Container.Free points to the head of the list of\n       --  free (inactive) nodes, and the value 0 means the free list is\n       --  empty. Each node on the free list has been initialized to point to\n       --  the next free node (via its Next component), and the value 0 means\n       --  that this is the last node of the free list.\n-      --\n+\n       --  If Container.Free is negative, then the links on the free store have\n       --  not been initialized. In this case the link values are implied: the\n       --  free store comprises the components of the node array started with\n       --  the absolute value of Container.Free, and continuing until the end of\n       --  the array (Nodes'Last).\n-      --\n+\n       --  We prefer to lazy-init the free store (in fact, we would prefer to\n       --  not initialize it at all, because such initialization is an O(n)\n       --  operation). The time when we need to actually initialize the nodes in\n       --  the free store is when the node that becomes inactive is not at the\n       --  end of the active list. The free store would then be discontigous and\n       --  so its nodes would need to be linked in the traditional way.\n-      --\n+\n       --  It might be possible to perform an optimization here. Suppose that\n       --  the free store can be represented as having two parts: one comprising\n       --  the non-contiguous inactive nodes linked together in the normal way,\n@@ -1218,8 +1216,8 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n       Right_Subtree : Count_Type) return Boolean\n    is\n    begin\n-      if Left_Tree.Elements (Left_Subtree)\n-        /= Right_Tree.Elements (Right_Subtree)\n+      if Left_Tree.Elements  (Left_Subtree) /=\n+         Right_Tree.Elements (Right_Subtree)\n       then\n          return False;\n       end if;\n@@ -1262,7 +1260,6 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n \n    function First (Object : Child_Iterator) return Cursor is\n       Node : Count_Type'Base;\n-\n    begin\n       Node := Object.Container.Nodes (Object.Position.Node).Children.First;\n       return (Object.Container, Node);\n@@ -1722,11 +1719,9 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n \n    function Is_Root (Position : Cursor) return Boolean is\n    begin\n-      if Position.Container = null then\n-         return False;\n-      end if;\n-\n-      return Position.Node = Root_Node (Position.Container.all);\n+      return\n+        (if Position.Container = null then False\n+         else Position.Node = Root_Node (Position.Container.all));\n    end Is_Root;\n \n    -------------\n@@ -1839,7 +1834,7 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n    function Iterate_Children\n      (Container : Tree;\n       Parent    : Cursor)\n-     return Tree_Iterator_Interfaces.Reversible_Iterator'Class\n+      return Tree_Iterator_Interfaces.Reversible_Iterator'Class\n    is\n       pragma Unreferenced (Container);\n    begin\n@@ -2039,10 +2034,9 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n    end Next;\n \n    function Next\n-     (Object : Child_Iterator;\n+     (Object   : Child_Iterator;\n       Position : Cursor) return Cursor\n    is\n-\n    begin\n       if Object.Container /= Position.Container then\n          raise Program_Error;\n@@ -2201,7 +2195,7 @@ package body Ada.Containers.Bounded_Multiway_Trees is\n    --------------\n \n    overriding function Previous\n-     (Object : Child_Iterator;\n+     (Object   : Child_Iterator;\n       Position : Cursor) return Cursor\n    is\n    begin"}, {"sha": "797b6ea6214185c33752a04b03b3961bc5f90819", "filename": "gcc/ada/a-cbmutr.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce72a9a305f5de10f43446aaf3c3fecdf77d7987/gcc%2Fada%2Fa-cbmutr.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce72a9a305f5de10f43446aaf3c3fecdf77d7987/gcc%2Fada%2Fa-cbmutr.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cbmutr.ads?ref=ce72a9a305f5de10f43446aaf3c3fecdf77d7987", "patch": "@@ -182,7 +182,7 @@ package Ada.Containers.Bounded_Multiway_Trees is\n    function Iterate_Children\n      (Container : Tree;\n       Parent    : Cursor)\n-     return Tree_Iterator_Interfaces.Reversible_Iterator'Class;\n+      return Tree_Iterator_Interfaces.Reversible_Iterator'Class;\n \n    function Child_Count (Parent : Cursor) return Count_Type;\n "}, {"sha": "674d2abee3358b664396c082bb1c3162f2a12781", "filename": "gcc/ada/a-cborse.adb", "status": "modified", "additions": 33, "deletions": 104, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce72a9a305f5de10f43446aaf3c3fecdf77d7987/gcc%2Fada%2Fa-cborse.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce72a9a305f5de10f43446aaf3c3fecdf77d7987/gcc%2Fada%2Fa-cborse.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cborse.adb?ref=ce72a9a305f5de10f43446aaf3c3fecdf77d7987", "patch": "@@ -326,7 +326,6 @@ package body Ada.Containers.Bounded_Ordered_Sets is\n \n          function New_Node return Count_Type is\n             Result : Count_Type;\n-\n          begin\n             Allocate (Target, Result);\n             return Result;\n@@ -376,13 +375,9 @@ package body Ada.Containers.Bounded_Ordered_Sets is\n    function Ceiling (Container : Set; Item : Element_Type) return Cursor is\n       Node : constant Count_Type :=\n                Element_Keys.Ceiling (Container, Item);\n-\n    begin\n-      if Node = 0 then\n-         return No_Element;\n-      end if;\n-\n-      return Cursor'(Container'Unrestricted_Access, Node);\n+      return (if Node = 0 then No_Element\n+              else Cursor'(Container'Unrestricted_Access, Node));\n    end Ceiling;\n \n    -----------\n@@ -425,10 +420,8 @@ package body Ada.Containers.Bounded_Ordered_Sets is\n    begin\n       if Capacity = 0 then\n          C := Source.Length;\n-\n       elsif Capacity >= Source.Length then\n          C := Capacity;\n-\n       else\n          raise Capacity_Error with \"Capacity value too small\";\n       end if;\n@@ -479,7 +472,6 @@ package body Ada.Containers.Bounded_Ordered_Sets is\n \n    procedure Delete_First (Container : in out Set) is\n       X : constant Count_Type := Container.First;\n-\n    begin\n       if X /= 0 then\n          Tree_Operations.Delete_Node_Sans_Free (Container, X);\n@@ -493,7 +485,6 @@ package body Ada.Containers.Bounded_Ordered_Sets is\n \n    procedure Delete_Last (Container : in out Set) is\n       X : constant Count_Type := Container.Last;\n-\n    begin\n       if X /= 0 then\n          Tree_Operations.Delete_Node_Sans_Free (Container, X);\n@@ -533,13 +524,7 @@ package body Ada.Containers.Bounded_Ordered_Sets is\n \n    function Equivalent_Elements (Left, Right : Element_Type) return Boolean is\n    begin\n-      if Left < Right\n-        or else Right < Left\n-      then\n-         return False;\n-      else\n-         return True;\n-      end if;\n+      return (if Left < Right or else Right < Left then False else True);\n    end Equivalent_Elements;\n \n    ---------------------\n@@ -559,13 +544,9 @@ package body Ada.Containers.Bounded_Ordered_Sets is\n \n       function Is_Equivalent_Node_Node (L, R : Node_Type) return Boolean is\n       begin\n-         if L.Element < R.Element then\n-            return False;\n-         elsif R.Element < L.Element then\n-            return False;\n-         else\n-            return True;\n-         end if;\n+         return (if L.Element < R.Element then False\n+                 elsif R.Element < L.Element then False\n+                 else True);\n       end Is_Equivalent_Node_Node;\n \n    --  Start of processing for Equivalent_Sets\n@@ -580,7 +561,6 @@ package body Ada.Containers.Bounded_Ordered_Sets is\n \n    procedure Exclude (Container : in out Set; Item : Element_Type) is\n       X : constant Count_Type := Element_Keys.Find (Container, Item);\n-\n    begin\n       if X /= 0 then\n          Tree_Operations.Delete_Node_Sans_Free (Container, X);\n@@ -594,13 +574,9 @@ package body Ada.Containers.Bounded_Ordered_Sets is\n \n    function Find (Container : Set; Item : Element_Type) return Cursor is\n       Node : constant Count_Type := Element_Keys.Find (Container, Item);\n-\n    begin\n-      if Node = 0 then\n-         return No_Element;\n-      end if;\n-\n-      return Cursor'(Container'Unrestricted_Access, Node);\n+      return (if Node = 0 then No_Element\n+              else Cursor'(Container'Unrestricted_Access, Node));\n    end Find;\n \n    -----------\n@@ -609,23 +585,15 @@ package body Ada.Containers.Bounded_Ordered_Sets is\n \n    function First (Container : Set) return Cursor is\n    begin\n-      if Container.First = 0 then\n-         return No_Element;\n-      end if;\n-\n-      return Cursor'(Container'Unrestricted_Access, Container.First);\n+      return (if Container.First = 0 then No_Element\n+              else Cursor'(Container'Unrestricted_Access, Container.First));\n    end First;\n \n    function First (Object : Iterator) return Cursor is\n    begin\n-      if Object.Container.First = 0 then\n-         return No_Element;\n-      else\n-         return\n-           Cursor'(\n-             Object.Container.all'Unrestricted_Access,\n-             Object.Container.First);\n-      end if;\n+      return (if Object.Container.First = 0 then No_Element\n+              else Cursor'(Object.Container.all'Unrestricted_Access,\n+                           Object.Container.First));\n    end First;\n \n    -------------------\n@@ -647,13 +615,9 @@ package body Ada.Containers.Bounded_Ordered_Sets is\n \n    function Floor (Container : Set; Item : Element_Type) return Cursor is\n       Node : constant Count_Type := Element_Keys.Floor (Container, Item);\n-\n    begin\n-      if Node = 0 then\n-         return No_Element;\n-      end if;\n-\n-      return Cursor'(Container'Unrestricted_Access, Node);\n+      return (if Node = 0 then No_Element\n+              else Cursor'(Container'Unrestricted_Access, Node));\n    end Floor;\n \n    ------------------\n@@ -694,13 +658,9 @@ package body Ada.Containers.Bounded_Ordered_Sets is\n       function Ceiling (Container : Set; Key : Key_Type) return Cursor is\n          Node : constant Count_Type :=\n                   Key_Keys.Ceiling (Container, Key);\n-\n       begin\n-         if Node = 0 then\n-            return No_Element;\n-         end if;\n-\n-         return Cursor'(Container'Unrestricted_Access, Node);\n+         return (if Node = 0 then No_Element\n+                 else Cursor'(Container'Unrestricted_Access, Node));\n       end Ceiling;\n \n       --------------\n@@ -749,13 +709,7 @@ package body Ada.Containers.Bounded_Ordered_Sets is\n \n       function Equivalent_Keys (Left, Right : Key_Type) return Boolean is\n       begin\n-         if Left < Right\n-           or else Right < Left\n-         then\n-            return False;\n-         else\n-            return True;\n-         end if;\n+         return (if Left < Right or else Right < Left then False else True);\n       end Equivalent_Keys;\n \n       -------------\n@@ -764,7 +718,6 @@ package body Ada.Containers.Bounded_Ordered_Sets is\n \n       procedure Exclude (Container : in out Set; Key : Key_Type) is\n          X : constant Count_Type := Key_Keys.Find (Container, Key);\n-\n       begin\n          if X /= 0 then\n             Tree_Operations.Delete_Node_Sans_Free (Container, X);\n@@ -778,13 +731,9 @@ package body Ada.Containers.Bounded_Ordered_Sets is\n \n       function Find (Container : Set; Key : Key_Type) return Cursor is\n          Node : constant Count_Type := Key_Keys.Find (Container, Key);\n-\n       begin\n-         if Node = 0 then\n-            return No_Element;\n-         end if;\n-\n-         return Cursor'(Container'Unrestricted_Access, Node);\n+         return (if Node = 0 then No_Element\n+                 else Cursor'(Container'Unrestricted_Access, Node));\n       end Find;\n \n       -----------\n@@ -793,13 +742,9 @@ package body Ada.Containers.Bounded_Ordered_Sets is\n \n       function Floor (Container : Set; Key : Key_Type) return Cursor is\n          Node : constant Count_Type := Key_Keys.Floor (Container, Key);\n-\n       begin\n-         if Node = 0 then\n-            return No_Element;\n-         end if;\n-\n-         return Cursor'(Container'Unrestricted_Access, Node);\n+         return (if Node = 0 then No_Element\n+                 else Cursor'(Container'Unrestricted_Access, Node));\n       end Floor;\n \n       -------------------------\n@@ -1069,7 +1014,6 @@ package body Ada.Containers.Bounded_Ordered_Sets is\n \n       function New_Node return Count_Type is\n          Result : Count_Type;\n-\n       begin\n          Allocate (Container, Result);\n          return Result;\n@@ -1133,7 +1077,6 @@ package body Ada.Containers.Bounded_Ordered_Sets is\n \n       function New_Node return Count_Type is\n          Result : Count_Type;\n-\n       begin\n          Allocate (Dst_Set, Result);\n          return Result;\n@@ -1287,22 +1230,15 @@ package body Ada.Containers.Bounded_Ordered_Sets is\n \n    function Last (Container : Set) return Cursor is\n    begin\n-      if Container.Last = 0 then\n-         return No_Element;\n-      end if;\n-\n-      return Cursor'(Container'Unrestricted_Access, Container.Last);\n+      return (if Container.Last = 0 then No_Element\n+              else Cursor'(Container'Unrestricted_Access, Container.Last));\n    end Last;\n \n    function Last (Object : Iterator) return Cursor is\n    begin\n-      if Object.Container.Last = 0 then\n-         return No_Element;\n-      else\n-         return Cursor'(\n-           Object.Container.all'Unrestricted_Access,\n-                        Object.Container.Last);\n-      end if;\n+      return (if Object.Container.Last = 0 then No_Element\n+              else Cursor'(Object.Container.all'Unrestricted_Access,\n+                           Object.Container.Last));\n    end Last;\n \n    ------------------\n@@ -1388,7 +1324,6 @@ package body Ada.Containers.Bounded_Ordered_Sets is\n \n    function Next (Object : Iterator; Position : Cursor) return Cursor is\n       pragma Unreferenced (Object);\n-\n    begin\n       return Next (Position);\n    end Next;\n@@ -1427,13 +1362,9 @@ package body Ada.Containers.Bounded_Ordered_Sets is\n                   Tree_Operations.Previous\n                     (Position.Container.all,\n                      Position.Node);\n-\n       begin\n-         if Node = 0 then\n-            return No_Element;\n-         end if;\n-\n-         return Cursor'(Position.Container, Node);\n+         return (if Node = 0 then No_Element\n+                 else Cursor'(Position.Container, Node));\n       end;\n    end Previous;\n \n@@ -1466,7 +1397,6 @@ package body Ada.Containers.Bounded_Ordered_Sets is\n \n       declare\n          S : Set renames Position.Container.all;\n-\n          B : Natural renames S.Busy;\n          L : Natural renames S.Lock;\n \n@@ -1608,11 +1538,10 @@ package body Ada.Containers.Bounded_Ordered_Sets is\n       function New_Node return Count_Type is\n       begin\n          Node.Element := Item;\n-         Node.Color := Red_Black_Trees.Red;\n-         Node.Parent := 0;\n-         Node.Right := 0;\n-         Node.Left := 0;\n-\n+         Node.Color   := Red_Black_Trees.Red;\n+         Node.Parent  := 0;\n+         Node.Right   := 0;\n+         Node.Left    := 0;\n          return Index;\n       end New_Node;\n "}, {"sha": "6cee303fcedcaed7ccf4eae1d95c11884300729d", "filename": "gcc/ada/a-cihase.adb", "status": "modified", "additions": 33, "deletions": 62, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce72a9a305f5de10f43446aaf3c3fecdf77d7987/gcc%2Fada%2Fa-cihase.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce72a9a305f5de10f43446aaf3c3fecdf77d7987/gcc%2Fada%2Fa-cihase.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cihase.adb?ref=ce72a9a305f5de10f43446aaf3c3fecdf77d7987", "patch": "@@ -49,7 +49,7 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n    overriding function First (Object : Iterator) return Cursor;\n \n    overriding function Next\n-     (Object : Iterator;\n+     (Object   : Iterator;\n       Position : Cursor) return Cursor;\n \n    -----------------------\n@@ -426,8 +426,7 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n    -- Equivalent_Elements --\n    -------------------------\n \n-   function Equivalent_Elements (Left, Right : Cursor)\n-     return Boolean is\n+   function Equivalent_Elements (Left, Right : Cursor) return Boolean is\n    begin\n       if Left.Node = null then\n          raise Constraint_Error with\n@@ -457,8 +456,10 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n                 Right.Node.Element.all);\n    end Equivalent_Elements;\n \n-   function Equivalent_Elements (Left : Cursor; Right : Element_Type)\n-     return Boolean is\n+   function Equivalent_Elements\n+     (Left  : Cursor;\n+      Right : Element_Type) return Boolean\n+   is\n    begin\n       if Left.Node = null then\n          raise Constraint_Error with\n@@ -475,8 +476,10 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n       return Equivalent_Elements (Left.Node.Element.all, Right);\n    end Equivalent_Elements;\n \n-   function Equivalent_Elements (Left : Element_Type; Right : Cursor)\n-     return Boolean is\n+   function Equivalent_Elements\n+     (Left  : Element_Type;\n+      Right : Cursor) return Boolean\n+   is\n    begin\n       if Right.Node = null then\n          raise Constraint_Error with\n@@ -497,8 +500,10 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n    -- Equivalent_Keys --\n    ---------------------\n \n-   function Equivalent_Keys (Key : Element_Type; Node : Node_Access)\n-     return Boolean is\n+   function Equivalent_Keys\n+     (Key  : Element_Type;\n+      Node : Node_Access) return Boolean\n+   is\n    begin\n       return Equivalent_Elements (Key, Node.Element.all);\n    end Equivalent_Keys;\n@@ -535,13 +540,9 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n       Item      : Element_Type) return Cursor\n    is\n       Node : constant Node_Access := Element_Keys.Find (Container.HT, Item);\n-\n    begin\n-      if Node = null then\n-         return No_Element;\n-      end if;\n-\n-      return Cursor'(Container'Unrestricted_Access, Node);\n+      return (if Node = null then No_Element\n+              else Cursor'(Container'Unrestricted_Access, Node));\n    end Find;\n \n    --------------------\n@@ -604,23 +605,16 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n \n    function First (Container : Set) return Cursor is\n       Node : constant Node_Access := HT_Ops.First (Container.HT);\n-\n    begin\n-      if Node = null then\n-         return No_Element;\n-      end if;\n-\n-      return Cursor'(Container'Unrestricted_Access, Node);\n+      return (if Node = null then No_Element\n+              else Cursor'(Container'Unrestricted_Access, Node));\n    end First;\n \n    function First (Object : Iterator) return Cursor is\n       Node : constant Node_Access := HT_Ops.First (Object.Container.HT);\n    begin\n-      if Node = null then\n-         return No_Element;\n-      end if;\n-\n-      return Cursor'(Object.Container, Node);\n+      return (if Node = null then No_Element\n+              else Cursor'(Object.Container, Node));\n    end First;\n \n    ----------\n@@ -750,7 +744,6 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n \n       function New_Node (Next : Node_Access) return Node_Access is\n          Element : Element_Access := new Element_Type'(New_Item);\n-\n       begin\n          return new Node_Type'(Element, Next);\n       exception\n@@ -1025,13 +1018,9 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n       declare\n          HT   : Hash_Table_Type renames Position.Container.HT;\n          Node : constant Node_Access := HT_Ops.Next (HT, Position.Node);\n-\n       begin\n-         if Node = null then\n-            return No_Element;\n-         end if;\n-\n-         return Cursor'(Position.Container, Node);\n+         return (if Node = null then No_Element\n+                 else Cursor'(Position.Container, Node));\n       end;\n    end Next;\n \n@@ -1041,7 +1030,7 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n    end Next;\n \n    function Next\n-     (Object : Iterator;\n+     (Object   : Iterator;\n       Position : Cursor) return Cursor\n    is\n    begin\n@@ -1050,11 +1039,7 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n            \"Position cursor designates wrong set\";\n       end if;\n \n-      if Position.Node = null then\n-         return No_Element;\n-      end if;\n-\n-      return Next (Position);\n+      return (if Position.Node = null then No_Element else Next (Position));\n    end Next;\n \n    -------------\n@@ -1166,7 +1151,6 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n      (Stream : not null access Root_Stream_Type'Class) return Node_Access\n    is\n       X : Element_Access := new Element_Type'(Element_Type'Input (Stream));\n-\n    begin\n       return new Node_Type'(X, null);\n    exception\n@@ -1183,9 +1167,8 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n      (Container : aliased Set;\n       Position  : Cursor) return Constant_Reference_Type\n    is\n-   begin\n       pragma Unreferenced (Container);\n-\n+   begin\n       return (Element => Position.Node.Element);\n    end Constant_Reference;\n \n@@ -1301,8 +1284,7 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n          Iterate_Source_When_Empty_Target : declare\n             procedure Process (Src_Node : Node_Access);\n \n-            procedure Iterate is\n-               new HT_Ops.Generic_Iteration (Process);\n+            procedure Iterate is new HT_Ops.Generic_Iteration (Process);\n \n             -------------\n             -- Process --\n@@ -1535,12 +1517,10 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n    ------------\n \n    function To_Set (New_Item : Element_Type) return Set is\n-      HT : Hash_Table_Type;\n-\n+      HT       : Hash_Table_Type;\n       Node     : Node_Access;\n       Inserted : Boolean;\n       pragma Unreferenced (Node, Inserted);\n-\n    begin\n       Insert (HT, New_Item, Node, Inserted);\n       return Set'(Controlled with HT);\n@@ -1578,7 +1558,6 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n \n          function New_Node (Next : Node_Access) return Node_Access is\n             Tgt : Element_Access := new Element_Type'(Src);\n-\n          begin\n             return new Node_Type'(Tgt, Next);\n          exception\n@@ -1655,14 +1634,10 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n          -------------\n \n          procedure Process (L_Node : Node_Access) is\n-            Src : Element_Type renames L_Node.Element.all;\n-\n-            J : constant Hash_Type := Hash (Src) mod Buckets'Length;\n-\n+            Src    : Element_Type renames L_Node.Element.all;\n+            J      : constant Hash_Type := Hash (Src) mod Buckets'Length;\n             Bucket : Node_Access renames Buckets (J);\n-\n-            Tgt : Element_Access := new Element_Type'(Src);\n-\n+            Tgt    : Element_Access := new Element_Type'(Src);\n          begin\n             Bucket := new Node_Type'(Tgt, Bucket);\n          exception\n@@ -1940,13 +1915,9 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n          Key       : Key_Type) return Cursor\n       is\n          Node : constant Node_Access := Key_Keys.Find (Container.HT, Key);\n-\n       begin\n-         if Node = null then\n-            return No_Element;\n-         end if;\n-\n-         return Cursor'(Container'Unrestricted_Access, Node);\n+         return (if Node = null then No_Element\n+                 else Cursor'(Container'Unrestricted_Access, Node));\n       end Find;\n \n       ---------\n@@ -2106,7 +2077,7 @@ package body Ada.Containers.Indefinite_Hashed_Sets is\n \n       function Reference_Preserving_Key\n         (Container : aliased in out Set;\n-         Key  : Key_Type) return Reference_Type\n+         Key       : Key_Type) return Reference_Type\n       is\n          Position : constant Cursor := Find (Container, Key);\n       begin"}, {"sha": "860034469ead0896d55f931fbb72ecc37f166c1a", "filename": "gcc/ada/a-cihase.ads", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce72a9a305f5de10f43446aaf3c3fecdf77d7987/gcc%2Fada%2Fa-cihase.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce72a9a305f5de10f43446aaf3c3fecdf77d7987/gcc%2Fada%2Fa-cihase.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cihase.ads?ref=ce72a9a305f5de10f43446aaf3c3fecdf77d7987", "patch": "@@ -414,21 +414,18 @@ package Ada.Containers.Indefinite_Hashed_Sets is\n \n       function Reference_Preserving_Key\n         (Container : aliased in out Set;\n-         Position  : Cursor)\n-      return Reference_Type;\n+         Position  : Cursor) return Reference_Type;\n \n       function Reference_Preserving_Key\n         (Container : aliased in out Set;\n-         Key  : Key_Type)\n-      return Reference_Type;\n+         Key       : Key_Type) return Reference_Type;\n \n    private\n       type Reference_Type (Element : not null access Element_Type)\n          is null record;\n    end Generic_Keys;\n \n private\n-\n    pragma Inline (Next);\n \n    type Node_Type;"}, {"sha": "23d7a3502ec459d0823aaea0fa46cd2b8a24153c", "filename": "gcc/ada/a-ciorma.adb", "status": "modified", "additions": 39, "deletions": 93, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce72a9a305f5de10f43446aaf3c3fecdf77d7987/gcc%2Fada%2Fa-ciorma.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce72a9a305f5de10f43446aaf3c3fecdf77d7987/gcc%2Fada%2Fa-ciorma.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ciorma.adb?ref=ce72a9a305f5de10f43446aaf3c3fecdf77d7987", "patch": "@@ -279,8 +279,7 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n    -- Adjust --\n    ------------\n \n-   procedure Adjust is\n-      new Tree_Operations.Generic_Adjust (Copy_Tree);\n+   procedure Adjust is new Tree_Operations.Generic_Adjust (Copy_Tree);\n \n    procedure Adjust (Container : in out Map) is\n    begin\n@@ -293,21 +292,16 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n \n    function Ceiling (Container : Map; Key : Key_Type) return Cursor is\n       Node : constant Node_Access := Key_Ops.Ceiling (Container.Tree, Key);\n-\n    begin\n-      if Node = null then\n-         return No_Element;\n-      end if;\n-\n-      return Cursor'(Container'Unrestricted_Access, Node);\n+      return (if Node = null then No_Element\n+                else Cursor'(Container'Unrestricted_Access, Node));\n    end Ceiling;\n \n    -----------\n    -- Clear --\n    -----------\n \n-   procedure Clear is\n-      new Tree_Operations.Generic_Clear (Delete_Tree);\n+   procedure Clear is new Tree_Operations.Generic_Clear (Delete_Tree);\n \n    procedure Clear (Container : in out Map) is\n    begin\n@@ -331,7 +325,8 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n      (Container : Map;\n       Key       : Key_Type) return Constant_Reference_Type\n    is\n-   begin return (Element => Container.Element (Key)'Unrestricted_Access);\n+   begin\n+      return (Element => Container.Element (Key)'Unrestricted_Access);\n    end Constant_Reference;\n \n    --------------\n@@ -350,6 +345,7 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n    function Copy_Node (Source : Node_Access) return Node_Access is\n       K : Key_Access := new Key_Type'(Source.Key.all);\n       E : Element_Access;\n+\n    begin\n       E := new Element_Type'(Source.Element.all);\n \n@@ -418,7 +414,6 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n \n    procedure Delete_First (Container : in out Map) is\n       X : Node_Access := Container.Tree.First;\n-\n    begin\n       if X /= null then\n          Tree_Operations.Delete_Node_Sans_Free (Container.Tree, X);\n@@ -432,7 +427,6 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n \n    procedure Delete_Last (Container : in out Map) is\n       X : Node_Access := Container.Tree.Last;\n-\n    begin\n       if X /= null then\n          Tree_Operations.Delete_Node_Sans_Free (Container.Tree, X);\n@@ -479,13 +473,7 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n \n    function Equivalent_Keys (Left, Right : Key_Type) return Boolean is\n    begin\n-      if Left < Right\n-        or else Right < Left\n-      then\n-         return False;\n-      else\n-         return True;\n-      end if;\n+      return (if Left < Right or else Right < Left then False else True);\n    end Equivalent_Keys;\n \n    -------------\n@@ -494,7 +482,6 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n \n    procedure Exclude (Container : in out Map; Key : Key_Type) is\n       X : Node_Access := Key_Ops.Find (Container.Tree, Key);\n-\n    begin\n       if X /= null then\n          Tree_Operations.Delete_Node_Sans_Free (Container.Tree, X);\n@@ -508,13 +495,9 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n \n    function Find (Container : Map; Key : Key_Type) return Cursor is\n       Node : constant Node_Access := Key_Ops.Find (Container.Tree, Key);\n-\n    begin\n-      if Node = null then\n-         return No_Element;\n-      end if;\n-\n-      return Cursor'(Container'Unrestricted_Access, Node);\n+      return (if Node = null then No_Element\n+              else Cursor'(Container'Unrestricted_Access, Node));\n    end Find;\n \n    -----------\n@@ -523,25 +506,17 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n \n    function First (Container : Map) return Cursor is\n       T : Tree_Type renames Container.Tree;\n-\n    begin\n-      if T.First = null then\n-         return No_Element;\n-      end if;\n-\n-      return Cursor'(Container'Unrestricted_Access, T.First);\n+      return (if T.First = null then No_Element\n+              else Cursor'(Container'Unrestricted_Access, T.First));\n    end First;\n \n    function First (Object : Iterator) return Cursor is\n       M : constant Map_Access  := Object.Container;\n       N : constant Node_Access := M.Tree.First;\n-\n    begin\n-      if N = null then\n-         return No_Element;\n-      else\n-         return Cursor'(Object.Container.all'Unchecked_Access, N);\n-      end if;\n+      return (if N = null then No_Element\n+              else Cursor'(Object.Container.all'Unchecked_Access, N));\n    end First;\n \n    -------------------\n@@ -580,13 +555,9 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n \n    function Floor (Container : Map; Key : Key_Type) return Cursor is\n       Node : constant Node_Access := Key_Ops.Floor (Container.Tree, Key);\n-\n    begin\n-      if Node = null then\n-         return No_Element;\n-      end if;\n-\n-      return Cursor'(Container'Unrestricted_Access, Node);\n+      return (if Node = null then No_Element\n+              else Cursor'(Container'Unrestricted_Access, Node));\n    end Floor;\n \n    ----------\n@@ -608,6 +579,7 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n \n       begin\n          Free_Key (X.Key);\n+\n       exception\n          when others =>\n             X.Key := null;\n@@ -625,6 +597,7 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n \n       begin\n          Free_Element (X.Element);\n+\n       exception\n          when others =>\n             X.Element := null;\n@@ -771,18 +744,11 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n    -- Is_Equal_Node_Node --\n    ------------------------\n \n-   function Is_Equal_Node_Node\n-     (L, R : Node_Access) return Boolean is\n+   function Is_Equal_Node_Node (L, R : Node_Access) return Boolean is\n    begin\n-      if L.Key.all < R.Key.all then\n-         return False;\n-\n-      elsif R.Key.all < L.Key.all then\n-         return False;\n-\n-      else\n-         return L.Element.all = R.Element.all;\n-      end if;\n+      return (if L.Key.all < R.Key.all then False\n+              elsif R.Key.all < L.Key.all then False\n+              else L.Element.all = R.Element.all);\n    end Is_Equal_Node_Node;\n \n    -------------------------\n@@ -856,12 +822,13 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n    is\n       Node : constant Node_Access := Container.Tree.First;\n       It   : constant Iterator := (Container'Unrestricted_Access, Node);\n-\n    begin\n       return It;\n    end Iterate;\n \n-   function Iterate (Container : Map; Start : Cursor)\n+   function Iterate\n+     (Container : Map;\n+      Start     : Cursor)\n       return Map_Iterator_Interfaces.Reversible_Iterator'class\n    is\n       It : constant Iterator := (Container'Unrestricted_Access, Start.Node);\n@@ -897,24 +864,17 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n \n    function Last (Container : Map) return Cursor is\n       T : Tree_Type renames Container.Tree;\n-\n    begin\n-      if T.Last = null then\n-         return No_Element;\n-      end if;\n-\n-      return Cursor'(Container'Unrestricted_Access, T.Last);\n+      return (if T.Last = null then No_Element\n+              else Cursor'(Container'Unrestricted_Access, T.Last));\n    end Last;\n \n    function Last (Object : Iterator) return Cursor is\n       M : constant Map_Access  := Object.Container;\n       N : constant Node_Access := M.Tree.Last;\n    begin\n-      if N = null then\n-         return No_Element;\n-      else\n-         return Cursor'(Object.Container.all'Unchecked_Access, N);\n-      end if;\n+      return (if N = null then No_Element\n+              else Cursor'(Object.Container.all'Unchecked_Access, N));\n    end Last;\n \n    ------------------\n@@ -969,8 +929,7 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n    -- Move --\n    ----------\n \n-   procedure Move is\n-      new Tree_Operations.Generic_Move (Clear);\n+   procedure Move is new Tree_Operations.Generic_Move (Clear);\n \n    procedure Move (Target : in out Map; Source : in out Map) is\n    begin\n@@ -996,13 +955,9 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n       declare\n          Node : constant Node_Access :=\n                   Tree_Operations.Next (Position.Node);\n-\n       begin\n-         if Node = null then\n-            return No_Element;\n-         else\n-            return Cursor'(Position.Container, Node);\n-         end if;\n+         return (if Node = null then No_Element\n+                 else Cursor'(Position.Container, Node));\n       end;\n    end Next;\n \n@@ -1016,11 +971,8 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n       Position : Cursor) return Cursor\n    is\n    begin\n-      if Position.Node = null then\n-         return No_Element;\n-      else\n-         return (Object.Container, Tree_Operations.Next (Position.Node));\n-      end if;\n+      return (if Position.Node = null then No_Element\n+              else (Object.Container, Tree_Operations.Next (Position.Node)));\n    end Next;\n \n    ------------\n@@ -1051,13 +1003,9 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n       declare\n          Node : constant Node_Access :=\n                   Tree_Operations.Previous (Position.Node);\n-\n       begin\n-         if Node = null then\n-            return No_Element;\n-         end if;\n-\n-         return Cursor'(Position.Container, Node);\n+         return (if Node = null then No_Element\n+                 else Cursor'(Position.Container, Node));\n       end;\n    end Previous;\n \n@@ -1071,11 +1019,9 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n       Position : Cursor) return Cursor\n    is\n    begin\n-      if Position.Node = null then\n-         return No_Element;\n-      else\n-         return (Object.Container, Tree_Operations.Previous (Position.Node));\n-      end if;\n+      return\n+        (if Position.Node = null then No_Element\n+         else (Object.Container, Tree_Operations.Previous (Position.Node)));\n    end Previous;\n \n    -------------------"}, {"sha": "4257f0974e6aa3858f6ff76e14d2720f75aa2778", "filename": "gcc/ada/a-ciorse.adb", "status": "modified", "additions": 42, "deletions": 87, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce72a9a305f5de10f43446aaf3c3fecdf77d7987/gcc%2Fada%2Fa-ciorse.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce72a9a305f5de10f43446aaf3c3fecdf77d7987/gcc%2Fada%2Fa-ciorse.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ciorse.adb?ref=ce72a9a305f5de10f43446aaf3c3fecdf77d7987", "patch": "@@ -314,8 +314,7 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n    -- Adjust --\n    ------------\n \n-   procedure Adjust is\n-      new Tree_Operations.Generic_Adjust (Copy_Tree);\n+   procedure Adjust is new Tree_Operations.Generic_Adjust (Copy_Tree);\n \n    procedure Adjust (Container : in out Set) is\n    begin\n@@ -329,13 +328,9 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n    function Ceiling (Container : Set; Item : Element_Type) return Cursor is\n       Node : constant Node_Access :=\n                Element_Keys.Ceiling (Container.Tree, Item);\n-\n    begin\n-      if Node = null then\n-         return No_Element;\n-      end if;\n-\n-      return Cursor'(Container'Unrestricted_Access, Node);\n+      return (if Node = null then No_Element\n+              else Cursor'(Container'Unrestricted_Access, Node));\n    end Ceiling;\n \n    -----------\n@@ -433,7 +428,6 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n    procedure Delete_First (Container : in out Set) is\n       Tree : Tree_Type renames Container.Tree;\n       X    : Node_Access := Tree.First;\n-\n    begin\n       if X /= null then\n          Tree_Operations.Delete_Node_Sans_Free (Tree, X);\n@@ -448,7 +442,6 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n    procedure Delete_Last (Container : in out Set) is\n       Tree : Tree_Type renames Container.Tree;\n       X    : Node_Access := Tree.Last;\n-\n    begin\n       if X /= null then\n          Tree_Operations.Delete_Node_Sans_Free (Tree, X);\n@@ -466,8 +459,7 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n    end Difference;\n \n    function Difference (Left, Right : Set) return Set is\n-      Tree : constant Tree_Type :=\n-               Set_Ops.Difference (Left.Tree, Right.Tree);\n+      Tree : constant Tree_Type := Set_Ops.Difference (Left.Tree, Right.Tree);\n    begin\n       return Set'(Controlled with Tree);\n    end Difference;\n@@ -498,9 +490,7 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n \n    function Equivalent_Elements (Left, Right : Element_Type) return Boolean is\n    begin\n-      if Left < Right\n-        or else Right < Left\n-      then\n+      if Left < Right or else Right < Left then\n          return False;\n       else\n          return True;\n@@ -547,7 +537,6 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n    procedure Exclude (Container : in out Set; Item : Element_Type) is\n       X : Node_Access :=\n             Element_Keys.Find (Container.Tree, Item);\n-\n    begin\n       if X /= null then\n          Tree_Operations.Delete_Node_Sans_Free (Container.Tree, X);\n@@ -577,11 +566,9 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n \n    function First (Container : Set) return Cursor is\n    begin\n-      if Container.Tree.First = null then\n-         return No_Element;\n-      end if;\n-\n-      return Cursor'(Container'Unrestricted_Access, Container.Tree.First);\n+      return\n+        (if Container.Tree.First = null then No_Element\n+         else Cursor'(Container'Unrestricted_Access, Container.Tree.First));\n    end First;\n \n    function First (Object : Iterator) return Cursor is\n@@ -611,11 +598,8 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n       Node : constant Node_Access :=\n                Element_Keys.Floor (Container.Tree, Item);\n    begin\n-      if Node = null then\n-         return No_Element;\n-      else\n-         return Cursor'(Container'Unrestricted_Access, Node);\n-      end if;\n+      return (if Node = null then No_Element\n+              else Cursor'(Container'Unrestricted_Access, Node));\n    end Floor;\n \n    ----------\n@@ -685,13 +669,9 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n       function Ceiling (Container : Set; Key : Key_Type) return Cursor is\n          Node : constant Node_Access :=\n                   Key_Keys.Ceiling (Container.Tree, Key);\n-\n       begin\n-         if Node = null then\n-            return No_Element;\n-         end if;\n-\n-         return Cursor'(Container'Unrestricted_Access, Node);\n+         return (if Node = null then No_Element\n+                 else Cursor'(Container'Unrestricted_Access, Node));\n       end Ceiling;\n \n       --------------\n@@ -741,9 +721,7 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n \n       function Equivalent_Keys (Left, Right : Key_Type) return Boolean is\n       begin\n-         if Left < Right\n-           or else Right < Left\n-         then\n+         if Left < Right or else Right < Left then\n             return False;\n          else\n             return True;\n@@ -756,7 +734,6 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n \n       procedure Exclude (Container : in out Set; Key : Key_Type) is\n          X : Node_Access := Key_Keys.Find (Container.Tree, Key);\n-\n       begin\n          if X /= null then\n             Tree_Operations.Delete_Node_Sans_Free (Container.Tree, X);\n@@ -771,13 +748,9 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n       function Find (Container : Set; Key : Key_Type) return Cursor is\n          Node : constant Node_Access :=\n                   Key_Keys.Find (Container.Tree, Key);\n-\n       begin\n-         if Node = null then\n-            return No_Element;\n-         end if;\n-\n-         return Cursor'(Container'Unrestricted_Access, Node);\n+         return (if Node = null then No_Element\n+                 else Cursor'(Container'Unrestricted_Access, Node));\n       end Find;\n \n       -----------\n@@ -787,13 +760,9 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n       function Floor (Container : Set; Key : Key_Type) return Cursor is\n          Node : constant Node_Access :=\n                   Key_Keys.Floor (Container.Tree, Key);\n-\n       begin\n-         if Node = null then\n-            return No_Element;\n-         end if;\n-\n-         return Cursor'(Container'Unrestricted_Access, Node);\n+         return (if Node = null then No_Element\n+                 else Cursor'(Container'Unrestricted_Access, Node));\n       end Floor;\n \n       -------------------------\n@@ -802,7 +771,8 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n \n       function Is_Greater_Key_Node\n         (Left  : Key_Type;\n-         Right : Node_Access) return Boolean is\n+         Right : Node_Access) return Boolean\n+      is\n       begin\n          return Key (Right.Element.all) < Left;\n       end Is_Greater_Key_Node;\n@@ -813,7 +783,8 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n \n       function Is_Less_Key_Node\n         (Left  : Key_Type;\n-         Right : Node_Access) return Boolean is\n+         Right : Node_Access) return Boolean\n+      is\n       begin\n          return Left < Key (Right.Element.all);\n       end Is_Less_Key_Node;\n@@ -1179,7 +1150,8 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n \n    function Is_Greater_Element_Node\n      (Left  : Element_Type;\n-      Right : Node_Access) return Boolean is\n+      Right : Node_Access) return Boolean\n+   is\n    begin\n       --  e > node same as node < e\n \n@@ -1192,7 +1164,8 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n \n    function Is_Less_Element_Node\n      (Left  : Element_Type;\n-      Right : Node_Access) return Boolean is\n+      Right : Node_Access) return Boolean\n+   is\n    begin\n       return Left < Right.Element.all;\n    end Is_Less_Element_Node;\n@@ -1283,22 +1256,16 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n \n    function Last (Container : Set) return Cursor is\n    begin\n-      if Container.Tree.Last = null then\n-         return No_Element;\n-      else\n-         return Cursor'(Container'Unrestricted_Access, Container.Tree.Last);\n-      end if;\n+      return\n+        (if Container.Tree.Last = null then No_Element\n+         else Cursor'(Container'Unrestricted_Access, Container.Tree.Last));\n    end Last;\n \n    function Last (Object : Iterator) return Cursor is\n    begin\n-      if Object.Container.Tree.Last = null then\n-         return No_Element;\n-      else\n-         return Cursor'(\n-           Object.Container.all'Unrestricted_Access,\n-           Object.Container.Tree.Last);\n-      end if;\n+      return (if Object.Container.Tree.Last = null then No_Element\n+              else Cursor'(Object.Container.all'Unrestricted_Access,\n+                           Object.Container.Tree.Last));\n    end Last;\n \n    ------------------\n@@ -1336,8 +1303,7 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n    -- Move --\n    ----------\n \n-   procedure Move is\n-      new Tree_Operations.Generic_Move (Clear);\n+   procedure Move is new Tree_Operations.Generic_Move (Clear);\n \n    procedure Move (Target : in out Set; Source : in out Set) is\n    begin\n@@ -1369,13 +1335,9 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n       declare\n          Node : constant Node_Access :=\n                   Tree_Operations.Next (Position.Node);\n-\n       begin\n-         if Node = null then\n-            return No_Element;\n-         end if;\n-\n-         return Cursor'(Position.Container, Node);\n+         return (if Node = null then No_Element\n+                 else Cursor'(Position.Container, Node));\n       end;\n    end Next;\n \n@@ -1431,13 +1393,9 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n       declare\n          Node : constant Node_Access :=\n                   Tree_Operations.Previous (Position.Node);\n-\n       begin\n-         if Node = null then\n-            return No_Element;\n-         end if;\n-\n-         return Cursor'(Position.Container, Node);\n+         return (if Node = null then No_Element\n+                 else Cursor'(Position.Container, Node));\n       end;\n    end Previous;\n \n@@ -1608,15 +1566,15 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n       pragma Inline (New_Node);\n \n       procedure Local_Insert_Post is\n-         new Element_Keys.Generic_Insert_Post (New_Node);\n+        new Element_Keys.Generic_Insert_Post (New_Node);\n \n       procedure Local_Insert_Sans_Hint is\n-         new Element_Keys.Generic_Conditional_Insert (Local_Insert_Post);\n+        new Element_Keys.Generic_Conditional_Insert (Local_Insert_Post);\n \n       procedure Local_Insert_With_Hint is\n-         new Element_Keys.Generic_Conditional_Insert_With_Hint\n-        (Local_Insert_Post,\n-         Local_Insert_Sans_Hint);\n+        new Element_Keys.Generic_Conditional_Insert_With_Hint\n+          (Local_Insert_Post,\n+           Local_Insert_Sans_Hint);\n \n       --------------\n       -- New_Node --\n@@ -1629,7 +1587,6 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n          Node.Parent := null;\n          Node.Right := null;\n          Node.Left := null;\n-\n          return Node;\n       end New_Node;\n \n@@ -1829,12 +1786,10 @@ package body Ada.Containers.Indefinite_Ordered_Sets is\n    ------------\n \n    function To_Set (New_Item : Element_Type) return Set is\n-      Tree : Tree_Type;\n-\n+      Tree     : Tree_Type;\n       Node     : Node_Access;\n       Inserted : Boolean;\n       pragma Unreferenced (Node, Inserted);\n-\n    begin\n       Insert_Sans_Hint (Tree, New_Item, Node, Inserted);\n       return Set'(Controlled with Tree);"}, {"sha": "86be79ffc35e3087e309d6f23150f87a2314a34e", "filename": "gcc/ada/a-comutr.adb", "status": "modified", "additions": 22, "deletions": 43, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce72a9a305f5de10f43446aaf3c3fecdf77d7987/gcc%2Fada%2Fa-comutr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce72a9a305f5de10f43446aaf3c3fecdf77d7987/gcc%2Fada%2Fa-comutr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-comutr.adb?ref=ce72a9a305f5de10f43446aaf3c3fecdf77d7987", "patch": "@@ -48,16 +48,16 @@ package body Ada.Containers.Multiway_Trees is\n \n    overriding function First (Object : Iterator) return Cursor;\n    overriding function Next\n-     (Object : Iterator;\n+     (Object   : Iterator;\n       Position : Cursor) return Cursor;\n \n    overriding function First (Object : Child_Iterator) return Cursor;\n    overriding function Next\n-     (Object : Child_Iterator;\n+     (Object   : Child_Iterator;\n       Position : Cursor) return Cursor;\n \n    overriding function Previous\n-     (Object : Child_Iterator;\n+     (Object   : Child_Iterator;\n       Position : Cursor) return Cursor;\n \n    overriding function Last (Object : Child_Iterator) return Cursor;\n@@ -327,11 +327,8 @@ package body Ada.Containers.Multiway_Trees is\n \n    function Child_Count (Parent : Cursor) return Count_Type is\n    begin\n-      if Parent = No_Element then\n-         return 0;\n-      else\n-         return Child_Count (Parent.Node.Children);\n-      end if;\n+      return (if Parent = No_Element\n+              then 0 else Child_Count (Parent.Node.Children));\n    end Child_Count;\n \n    function Child_Count (Children : Children_Type) return Count_Type is\n@@ -1010,12 +1007,10 @@ package body Ada.Containers.Multiway_Trees is\n       --     raise Program_Error with \"Position cursor not in container\";\n       --  end if;\n \n-      if Is_Root (Position) then\n-         Result := Find_In_Children (Position.Node, Item);\n-\n-      else\n-         Result := Find_In_Subtree (Position.Node, Item);\n-      end if;\n+      Result :=\n+        (if Is_Root (Position)\n+         then Find_In_Children (Position.Node, Item)\n+         else Find_In_Subtree  (Position.Node, Item));\n \n       if Result = null then\n          return No_Element;\n@@ -1437,7 +1432,7 @@ package body Ada.Containers.Multiway_Trees is\n    function Iterate_Children\n      (Container : Tree;\n       Parent    : Cursor)\n-     return Tree_Iterator_Interfaces.Reversible_Iterator'Class\n+      return Tree_Iterator_Interfaces.Reversible_Iterator'Class\n    is\n       pragma Unreferenced (Container);\n    begin\n@@ -1457,8 +1452,8 @@ package body Ada.Containers.Multiway_Trees is\n    end Iterate_Subtree;\n \n    procedure Iterate_Subtree\n-     (Position  : Cursor;\n-      Process   : not null access procedure (Position : Cursor))\n+     (Position : Cursor;\n+      Process  : not null access procedure (Position : Cursor))\n    is\n    begin\n       if Position = No_Element then\n@@ -1515,6 +1510,7 @@ package body Ada.Containers.Multiway_Trees is\n \n    function Last_Child (Parent : Cursor) return Cursor is\n       Node : Tree_Node_Access;\n+\n    begin\n       if Parent = No_Element then\n          raise Constraint_Error with \"Parent cursor has no element\";\n@@ -1575,7 +1571,7 @@ package body Ada.Containers.Multiway_Trees is\n    ----------\n \n    function Next\n-     (Object : Iterator;\n+     (Object   : Iterator;\n       Position : Cursor) return Cursor\n    is\n       T  : Tree renames Position.Container.all;\n@@ -1635,18 +1631,12 @@ package body Ada.Containers.Multiway_Trees is\n    end Next;\n \n    function Next\n-     (Object : Child_Iterator;\n+     (Object   : Child_Iterator;\n       Position : Cursor) return Cursor\n    is\n       C : constant Tree_Node_Access := Position.Node.Next;\n-\n    begin\n-      if C = null then\n-         return No_Element;\n-\n-      else\n-         return (Object.Container, C);\n-      end if;\n+      return (if C = null then No_Element else (Object.Container, C));\n    end Next;\n \n    ------------------\n@@ -1773,18 +1763,12 @@ package body Ada.Containers.Multiway_Trees is\n    --------------\n \n    overriding function Previous\n-     (Object : Child_Iterator;\n+     (Object   : Child_Iterator;\n       Position : Cursor) return Cursor\n    is\n       C : constant Tree_Node_Access := Position.Node.Prev;\n-\n    begin\n-      if C = null then\n-         return No_Element;\n-\n-      else\n-         return (Object.Container, C);\n-      end if;\n+      return (if C = null then No_Element else (Object.Container, C));\n    end Previous;\n \n    ----------------------\n@@ -1793,15 +1777,10 @@ package body Ada.Containers.Multiway_Trees is\n \n    function Previous_Sibling (Position : Cursor) return Cursor is\n    begin\n-      if Position = No_Element then\n-         return No_Element;\n-      end if;\n-\n-      if Position.Node.Prev = null then\n-         return No_Element;\n-      end if;\n-\n-      return Cursor'(Position.Container, Position.Node.Prev);\n+      return\n+        (if Position = No_Element        then No_Element\n+         elsif Position.Node.Prev = null then No_Element\n+         else Cursor'(Position.Container, Position.Node.Prev));\n    end Previous_Sibling;\n \n    procedure Previous_Sibling (Position : in out Cursor) is"}, {"sha": "915eed621171065703925f788a51535c2198617a", "filename": "gcc/ada/a-coorse.adb", "status": "modified", "additions": 41, "deletions": 112, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce72a9a305f5de10f43446aaf3c3fecdf77d7987/gcc%2Fada%2Fa-coorse.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce72a9a305f5de10f43446aaf3c3fecdf77d7987/gcc%2Fada%2Fa-coorse.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-coorse.adb?ref=ce72a9a305f5de10f43446aaf3c3fecdf77d7987", "patch": "@@ -288,13 +288,9 @@ package body Ada.Containers.Ordered_Sets is\n    function Ceiling (Container : Set; Item : Element_Type) return Cursor is\n       Node : constant Node_Access :=\n                Element_Keys.Ceiling (Container.Tree, Item);\n-\n    begin\n-      if Node = null then\n-         return No_Element;\n-      end if;\n-\n-      return Cursor'(Container'Unrestricted_Access, Node);\n+      return (if Node = null then No_Element\n+              else Cursor'(Container'Unrestricted_Access, Node));\n    end Ceiling;\n \n    -----------\n@@ -385,7 +381,6 @@ package body Ada.Containers.Ordered_Sets is\n    procedure Delete_First (Container : in out Set) is\n       Tree : Tree_Type renames Container.Tree;\n       X    : Node_Access := Tree.First;\n-\n    begin\n       if X /= null then\n          Tree_Operations.Delete_Node_Sans_Free (Tree, X);\n@@ -400,7 +395,6 @@ package body Ada.Containers.Ordered_Sets is\n    procedure Delete_Last (Container : in out Set) is\n       Tree : Tree_Type renames Container.Tree;\n       X    : Node_Access := Tree.Last;\n-\n    begin\n       if X /= null then\n          Tree_Operations.Delete_Node_Sans_Free (Tree, X);\n@@ -446,13 +440,7 @@ package body Ada.Containers.Ordered_Sets is\n \n    function Equivalent_Elements (Left, Right : Element_Type) return Boolean is\n    begin\n-      if Left < Right\n-        or else Right < Left\n-      then\n-         return False;\n-      else\n-         return True;\n-      end if;\n+      return (if Left < Right or else Right < Left then False else True);\n    end Equivalent_Elements;\n \n    ---------------------\n@@ -472,13 +460,9 @@ package body Ada.Containers.Ordered_Sets is\n \n       function Is_Equivalent_Node_Node (L, R : Node_Access) return Boolean is\n       begin\n-         if L.Element < R.Element then\n-            return False;\n-         elsif R.Element < L.Element then\n-            return False;\n-         else\n-            return True;\n-         end if;\n+         return (if L.Element < R.Element then False\n+                 elsif R.Element < L.Element then False\n+                 else True);\n       end Is_Equivalent_Node_Node;\n \n    --  Start of processing for Equivalent_Sets\n@@ -508,13 +492,9 @@ package body Ada.Containers.Ordered_Sets is\n    function Find (Container : Set; Item : Element_Type) return Cursor is\n       Node : constant Node_Access :=\n                Element_Keys.Find (Container.Tree, Item);\n-\n    begin\n-      if Node = null then\n-         return No_Element;\n-      end if;\n-\n-      return Cursor'(Container'Unrestricted_Access, Node);\n+      return (if Node = null then No_Element\n+              else Cursor'(Container'Unrestricted_Access, Node));\n    end Find;\n \n    -----------\n@@ -523,23 +503,16 @@ package body Ada.Containers.Ordered_Sets is\n \n    function First (Container : Set) return Cursor is\n    begin\n-      if Container.Tree.First = null then\n-         return No_Element;\n-      end if;\n-\n-      return Cursor'(Container'Unrestricted_Access, Container.Tree.First);\n+      return\n+        (if Container.Tree.First = null then No_Element\n+         else Cursor'(Container'Unrestricted_Access, Container.Tree.First));\n    end First;\n \n    function First (Object : Iterator) return Cursor is\n    begin\n-      if Object.Container = null then\n-         return No_Element;\n-      else\n-         return\n-           Cursor'(\n-             Object.Container.all'Unrestricted_Access,\n-             Object.Container.Tree.First);\n-      end if;\n+      return (if Object.Container = null then No_Element\n+              else Cursor'(Object.Container.all'Unrestricted_Access,\n+                           Object.Container.Tree.First));\n    end First;\n \n    -------------------\n@@ -562,13 +535,9 @@ package body Ada.Containers.Ordered_Sets is\n    function Floor (Container : Set; Item : Element_Type) return Cursor is\n       Node : constant Node_Access :=\n                Element_Keys.Floor (Container.Tree, Item);\n-\n    begin\n-      if Node = null then\n-         return No_Element;\n-      end if;\n-\n-      return Cursor'(Container'Unrestricted_Access, Node);\n+      return (if Node = null then No_Element\n+              else Cursor'(Container'Unrestricted_Access, Node));\n    end Floor;\n \n    ----------\n@@ -578,13 +547,11 @@ package body Ada.Containers.Ordered_Sets is\n    procedure Free (X : in out Node_Access) is\n       procedure Deallocate is\n          new Ada.Unchecked_Deallocation (Node_Type, Node_Access);\n-\n    begin\n       if X /= null then\n          X.Parent := X;\n-         X.Left := X;\n-         X.Right := X;\n-\n+         X.Left   := X;\n+         X.Right  := X;\n          Deallocate (X);\n       end if;\n    end Free;\n@@ -627,13 +594,9 @@ package body Ada.Containers.Ordered_Sets is\n       function Ceiling (Container : Set; Key : Key_Type) return Cursor is\n          Node : constant Node_Access :=\n                   Key_Keys.Ceiling (Container.Tree, Key);\n-\n       begin\n-         if Node = null then\n-            return No_Element;\n-         end if;\n-\n-         return Cursor'(Container'Unrestricted_Access, Node);\n+         return (if Node = null then No_Element\n+                 else Cursor'(Container'Unrestricted_Access, Node));\n       end Ceiling;\n \n       --------------\n@@ -683,13 +646,7 @@ package body Ada.Containers.Ordered_Sets is\n \n       function Equivalent_Keys (Left, Right : Key_Type) return Boolean is\n       begin\n-         if Left < Right\n-           or else Right < Left\n-         then\n-            return False;\n-         else\n-            return True;\n-         end if;\n+         return (if Left < Right or else Right < Left then False else True);\n       end Equivalent_Keys;\n \n       -------------\n@@ -698,7 +655,6 @@ package body Ada.Containers.Ordered_Sets is\n \n       procedure Exclude (Container : in out Set; Key : Key_Type) is\n          X : Node_Access := Key_Keys.Find (Container.Tree, Key);\n-\n       begin\n          if X /= null then\n             Delete_Node_Sans_Free (Container.Tree, X);\n@@ -712,13 +668,9 @@ package body Ada.Containers.Ordered_Sets is\n \n       function Find (Container : Set; Key : Key_Type) return Cursor is\n          Node : constant Node_Access := Key_Keys.Find (Container.Tree, Key);\n-\n       begin\n-         if Node = null then\n-            return No_Element;\n-         end if;\n-\n-         return Cursor'(Container'Unrestricted_Access, Node);\n+         return (if Node = null then No_Element\n+                 else Cursor'(Container'Unrestricted_Access, Node));\n       end Find;\n \n       -----------\n@@ -727,13 +679,9 @@ package body Ada.Containers.Ordered_Sets is\n \n       function Floor (Container : Set; Key : Key_Type) return Cursor is\n          Node : constant Node_Access := Key_Keys.Floor (Container.Tree, Key);\n-\n       begin\n-         if Node = null then\n-            return No_Element;\n-         end if;\n-\n-         return Cursor'(Container'Unrestricted_Access, Node);\n+         return (if Node = null then No_Element\n+                 else Cursor'(Container'Unrestricted_Access, Node));\n       end Floor;\n \n       -------------------------\n@@ -1214,22 +1162,16 @@ package body Ada.Containers.Ordered_Sets is\n \n    function Last (Container : Set) return Cursor is\n    begin\n-      if Container.Tree.Last = null then\n-         return No_Element;\n-      else\n-         return Cursor'(Container'Unrestricted_Access, Container.Tree.Last);\n-      end if;\n+      return\n+        (if Container.Tree.Last = null then No_Element\n+         else Cursor'(Container'Unrestricted_Access, Container.Tree.Last));\n    end Last;\n \n    function Last (Object : Iterator) return Cursor is\n    begin\n-      if Object.Container = null then\n-         return No_Element;\n-      else\n-         return Cursor'(\n-           Object.Container.all'Unrestricted_Access,\n-                        Object.Container.Tree.Last);\n-      end if;\n+      return (if Object.Container = null then No_Element\n+              else Cursor'(Object.Container.all'Unrestricted_Access,\n+                           Object.Container.Tree.Last));\n    end Last;\n \n    ------------------\n@@ -1267,8 +1209,7 @@ package body Ada.Containers.Ordered_Sets is\n    -- Move --\n    ----------\n \n-   procedure Move is\n-      new Tree_Operations.Generic_Move (Clear);\n+   procedure Move is new Tree_Operations.Generic_Move (Clear);\n \n    procedure Move (Target : in out Set; Source : in out Set) is\n    begin\n@@ -1291,13 +1232,9 @@ package body Ada.Containers.Ordered_Sets is\n       declare\n          Node : constant Node_Access :=\n                   Tree_Operations.Next (Position.Node);\n-\n       begin\n-         if Node = null then\n-            return No_Element;\n-         end if;\n-\n-         return Cursor'(Position.Container, Node);\n+         return (if Node = null then No_Element\n+                 else Cursor'(Position.Container, Node));\n       end;\n    end Next;\n \n@@ -1347,11 +1284,8 @@ package body Ada.Containers.Ordered_Sets is\n          Node : constant Node_Access :=\n                   Tree_Operations.Previous (Position.Node);\n       begin\n-         if Node = null then\n-            return No_Element;\n-         else\n-            return Cursor'(Position.Container, Node);\n-         end if;\n+         return (if Node = null then No_Element\n+                 else Cursor'(Position.Container, Node));\n       end;\n    end Previous;\n \n@@ -1429,11 +1363,9 @@ package body Ada.Containers.Ordered_Sets is\n         (Stream : not null access Root_Stream_Type'Class) return Node_Access\n       is\n          Node : Node_Access := new Node_Type;\n-\n       begin\n          Element_Type'Read (Stream, Node.Element);\n          return Node;\n-\n       exception\n          when others =>\n             Free (Node);\n@@ -1532,11 +1464,10 @@ package body Ada.Containers.Ordered_Sets is\n       function New_Node return Node_Access is\n       begin\n          Node.Element := Item;\n-         Node.Color := Red;\n-         Node.Parent := null;\n-         Node.Right := null;\n-         Node.Left := null;\n-\n+         Node.Color   := Red;\n+         Node.Parent  := null;\n+         Node.Right   := null;\n+         Node.Left    := null;\n          return Node;\n       end New_Node;\n \n@@ -1547,9 +1478,7 @@ package body Ada.Containers.Ordered_Sets is\n       --  Start of processing for Replace_Element\n \n    begin\n-      if Item < Node.Element\n-        or else Node.Element < Item\n-      then\n+      if Item < Node.Element or else Node.Element < Item then\n          null;\n \n       else"}, {"sha": "a34be0cc3da08ac1065d8146f0e08568a2cc9ee4", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce72a9a305f5de10f43446aaf3c3fecdf77d7987/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce72a9a305f5de10f43446aaf3c3fecdf77d7987/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=ce72a9a305f5de10f43446aaf3c3fecdf77d7987", "patch": "@@ -452,7 +452,18 @@ package body Sem_Ch6 is\n          --  incompatibility with Ada 95. Not clear whether this should be\n          --  enforced yet or perhaps controllable with special switch. ???\n \n-         if Is_Limited_Type (R_Type)\n+         --  A limited interface that is not immutably limited is OK.\n+\n+         if Is_Limited_Interface (R_Type)\n+           and then\n+             not (Is_Task_Interface (R_Type)\n+                   or else Is_Protected_Interface (R_Type)\n+                   or else Is_Synchronized_Interface (R_Type))\n+         then\n+            null;\n+\n+         elsif Is_Limited_Type (R_Type)\n+           and then not Is_Interface (R_Type)\n            and then Comes_From_Source (N)\n            and then not In_Instance_Body\n            and then not OK_For_Limited_Init_In_05 (R_Type, Expr)"}, {"sha": "7f10c2662251a45dbad66fe7eadaae6d6e189603", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 25, "deletions": 4, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce72a9a305f5de10f43446aaf3c3fecdf77d7987/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce72a9a305f5de10f43446aaf3c3fecdf77d7987/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=ce72a9a305f5de10f43446aaf3c3fecdf77d7987", "patch": "@@ -64,6 +64,7 @@ with Sem_Elab; use Sem_Elab;\n with Sem_Eval; use Sem_Eval;\n with Sem_Intr; use Sem_Intr;\n with Sem_Util; use Sem_Util;\n+with Targparm; use Targparm;\n with Sem_Type; use Sem_Type;\n with Sem_Warn; use Sem_Warn;\n with Sinfo;    use Sinfo;\n@@ -4874,13 +4875,33 @@ package body Sem_Res is\n                            (Is_Real_Type (Etype (Rop))\n                              and then Expr_Value_R (Rop) = Ureal_0))\n             then\n-               --  Specialize the warning message according to the operation\n+               --  Specialize the warning message according to the operation.\n+               --  The following warnings are for the case\n \n                case Nkind (N) is\n                   when N_Op_Divide =>\n-                     Apply_Compile_Time_Constraint_Error\n-                       (N, \"division by zero?\", CE_Divide_By_Zero,\n-                        Loc => Sloc (Right_Opnd (N)));\n+\n+                     --  For division, we have two cases, for float division\n+                     --  of an unconstrained float type, on a machine where\n+                     --  Machine_Overflows is false, we don't get an exception\n+                     --  at run-time, but rather an infinity or Nan. The Nan\n+                     --  case is pretty obscure, so just warn about infinities.\n+\n+                     if Is_Floating_Point_Type (Typ)\n+                       and then not Is_Constrained (Typ)\n+                       and then not Machine_Overflows_On_Target\n+                     then\n+                        Error_Msg_N\n+                          (\"float division by zero, \" &\n+                           \"may generate '+'/'- infinity?\", Right_Opnd (N));\n+\n+                        --  For all other cases, we get a Constraint_Error\n+\n+                     else\n+                        Apply_Compile_Time_Constraint_Error\n+                          (N, \"division by zero?\", CE_Divide_By_Zero,\n+                           Loc => Sloc (Right_Opnd (N)));\n+                     end if;\n \n                   when N_Op_Rem =>\n                      Apply_Compile_Time_Constraint_Error"}]}