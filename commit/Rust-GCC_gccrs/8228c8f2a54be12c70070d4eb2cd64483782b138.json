{"sha": "8228c8f2a54be12c70070d4eb2cd64483782b138", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODIyOGM4ZjJhNTRiZTEyYzcwMDcwZDRlYjJjZDY0NDgzNzgyYjEzOA==", "commit": {"author": {"name": "Iain Sandoe", "email": "iain@sandoe.co.uk", "date": "2019-10-17T19:46:52Z"}, "committer": {"name": "Iain Sandoe", "email": "iains@gcc.gnu.org", "date": "2019-10-17T19:46:52Z"}, "message": "[Darwin, PPC] Fix PR 65342.\n\nThe current Darwin load/store lo_sum patterns have neither predicate nor\nconstraint.  This means that most parts of the backend, which rely on\nrecog() to validate the rtx, can produce invalid combinations/selections.\n\nFor 32bit cases this isn't a problem since we can load/store to unaligned\naddresses using D-mode insns.\n\nConversely, for 64bit instructions that use DS mode, this can manifest as\nassemble errors (for an assembler that checks the LO14 relocations), or as\ncrashes caused by wrong offsets (or worse, wrong content for the two LSBs).\n\nWhat we want to check for \"Y\" on Darwin is:\n  - that the alignment of the Symbols' target is sufficient for DS mode\n  - that the offset is suitable for DS mode.\n(while looking through the Mach-O PIC unspecs).\n\nSo, the patch removes the Darwin-specific lo_sum patterns (we begin using\nthe movdi_internal64 patterns).  We also we need to extend the handling of the\nmem_operand_gpr constraint to allow looking through Mach-O PIC UNSPECs in\nthe lo_sum cases.\n\ngcc/ChangeLog:\n\n2019-10-17  Iain Sandoe  <iain@sandoe.co.uk>\n\n\tPR target/65342\n\t* config/rs6000/darwin.md (movdi_low, movsi_low_st): Delete.\n\t(movdi_low_st): Delete.\n\t* config/rs6000/rs6000.c\n\t(darwin_rs6000_legitimate_lo_sum_const_p): New.\n\t(mem_operand_gpr): Validate Mach-O LO_SUM cases separately.\n\t* config/rs6000/rs6000.md (movsi_low): Delete.\n\nFrom-SVN: r277130", "tree": {"sha": "4109e45b230e085a1d7ea0fd55982663629832a8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4109e45b230e085a1d7ea0fd55982663629832a8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8228c8f2a54be12c70070d4eb2cd64483782b138", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8228c8f2a54be12c70070d4eb2cd64483782b138", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8228c8f2a54be12c70070d4eb2cd64483782b138", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8228c8f2a54be12c70070d4eb2cd64483782b138/comments", "author": {"login": "iains", "id": 4039407, "node_id": "MDQ6VXNlcjQwMzk0MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4039407?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iains", "html_url": "https://github.com/iains", "followers_url": "https://api.github.com/users/iains/followers", "following_url": "https://api.github.com/users/iains/following{/other_user}", "gists_url": "https://api.github.com/users/iains/gists{/gist_id}", "starred_url": "https://api.github.com/users/iains/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iains/subscriptions", "organizations_url": "https://api.github.com/users/iains/orgs", "repos_url": "https://api.github.com/users/iains/repos", "events_url": "https://api.github.com/users/iains/events{/privacy}", "received_events_url": "https://api.github.com/users/iains/received_events", "type": "User", "site_admin": false}, "committer": {"login": "iains", "id": 4039407, "node_id": "MDQ6VXNlcjQwMzk0MDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4039407?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iains", "html_url": "https://github.com/iains", "followers_url": "https://api.github.com/users/iains/followers", "following_url": "https://api.github.com/users/iains/following{/other_user}", "gists_url": "https://api.github.com/users/iains/gists{/gist_id}", "starred_url": "https://api.github.com/users/iains/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iains/subscriptions", "organizations_url": "https://api.github.com/users/iains/orgs", "repos_url": "https://api.github.com/users/iains/repos", "events_url": "https://api.github.com/users/iains/events{/privacy}", "received_events_url": "https://api.github.com/users/iains/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6664a5f7ecb8fa96c0b754f66cc9bb73423c42fb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6664a5f7ecb8fa96c0b754f66cc9bb73423c42fb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6664a5f7ecb8fa96c0b754f66cc9bb73423c42fb"}], "stats": {"total": 149, "additions": 114, "deletions": 35}, "files": [{"sha": "ebb7cbcbda96b15b7ac5948c77d582d453f270a3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8228c8f2a54be12c70070d4eb2cd64483782b138/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8228c8f2a54be12c70070d4eb2cd64483782b138/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8228c8f2a54be12c70070d4eb2cd64483782b138", "patch": "@@ -1,3 +1,13 @@\n+2019-10-17  Iain Sandoe  <iain@sandoe.co.uk>\n+\n+\tPR target/65342\n+\t* config/rs6000/darwin.md (movdi_low, movsi_low_st): Delete.\n+\t(movdi_low_st): Delete.\n+\t* config/rs6000/rs6000.c\n+\t(darwin_rs6000_legitimate_lo_sum_const_p): New.\n+\t(mem_operand_gpr): Validate Mach-O LO_SUM cases separately.\n+\t* config/rs6000/rs6000.md (movsi_low): Delete.\n+\n 2019-10-17  Jason Merrill  <jason@redhat.com>\n \n \t* gimplify.h (get_initialized_tmp_var): Add default argument to"}, {"sha": "16f710b28bcf5bafd2293793deb5dff07e4e79b3", "filename": "gcc/config/rs6000/darwin.md", "status": "modified", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8228c8f2a54be12c70070d4eb2cd64483782b138/gcc%2Fconfig%2Frs6000%2Fdarwin.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8228c8f2a54be12c70070d4eb2cd64483782b138/gcc%2Fconfig%2Frs6000%2Fdarwin.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fdarwin.md?ref=8228c8f2a54be12c70070d4eb2cd64483782b138", "patch": "@@ -122,33 +122,6 @@ You should have received a copy of the GNU General Public License\n   [(set_attr \"type\" \"store\")])\n \n ;; 64-bit MachO load/store support\n-(define_insn \"movdi_low\"\n-  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r,*!d\")\n-        (mem:DI (lo_sum:DI (match_operand:DI 1 \"gpc_reg_operand\" \"b,b\")\n-                           (match_operand 2 \"\" \"\"))))]\n-  \"TARGET_MACHO && TARGET_64BIT\"\n-  \"@\n-   ld %0,lo16(%2)(%1)\n-   lfd %0,lo16(%2)(%1)\"\n-  [(set_attr \"type\" \"load\")])\n-\n-(define_insn \"movsi_low_st\"\n-  [(set (mem:SI (lo_sum:SI (match_operand:SI 1 \"gpc_reg_operand\" \"b\")\n-                           (match_operand 2 \"\" \"\")))\n-\t(match_operand:SI 0 \"gpc_reg_operand\" \"r\"))]\n-  \"TARGET_MACHO && ! TARGET_64BIT\"\n-  \"stw %0,lo16(%2)(%1)\"\n-  [(set_attr \"type\" \"store\")])\n-\n-(define_insn \"movdi_low_st\"\n-  [(set (mem:DI (lo_sum:DI (match_operand:DI 1 \"gpc_reg_operand\" \"b,b\")\n-                           (match_operand 2 \"\" \"\")))\n-\t(match_operand:DI 0 \"gpc_reg_operand\" \"r,*!d\"))]\n-  \"TARGET_MACHO && TARGET_64BIT\"\n-  \"@\n-   std %0,lo16(%2)(%1)\n-   stfd %0,lo16(%2)(%1)\"\n-  [(set_attr \"type\" \"store\")])\n \n ;; Mach-O PIC.\n "}, {"sha": "5876714d5626696f200c4be5f8d94ab03cb75120", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 104, "deletions": 1, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8228c8f2a54be12c70070d4eb2cd64483782b138/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8228c8f2a54be12c70070d4eb2cd64483782b138/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=8228c8f2a54be12c70070d4eb2cd64483782b138", "patch": "@@ -7329,6 +7329,103 @@ address_offset (rtx op)\n   return NULL_RTX;\n }\n \n+/* This tests that a lo_sum {constant, symbol, symbol+offset} is valid for\n+   the mode.  If we can't find (or don't know) the alignment of the symbol\n+   we assume (optimistically) that it's sufficiently aligned [??? maybe we\n+   should be pessimistic].  Offsets are validated in the same way as for\n+   reg + offset.  */\n+static bool\n+darwin_rs6000_legitimate_lo_sum_const_p (rtx x, machine_mode mode)\n+{\n+  /* We should not get here with this.  */\n+  gcc_checking_assert (! mode_supports_dq_form (mode));\n+\n+  if (GET_CODE (x) == CONST)\n+    x = XEXP (x, 0);\n+\n+  if (GET_CODE (x) == UNSPEC && XINT (x, 1) == UNSPEC_MACHOPIC_OFFSET)\n+    x =  XVECEXP (x, 0, 0);\n+\n+  rtx sym = NULL_RTX;\n+  unsigned HOST_WIDE_INT offset = 0;\n+\n+  if (GET_CODE (x) == PLUS)\n+    {\n+      sym = XEXP (x, 0);\n+      if (! SYMBOL_REF_P (sym))\n+\treturn false;\n+      if (!CONST_INT_P (XEXP (x, 1)))\n+\treturn false;\n+      offset = INTVAL (XEXP (x, 1));\n+    }\n+  else if (SYMBOL_REF_P (x))\n+    sym = x;\n+  else if (CONST_INT_P (x))\n+    offset = INTVAL (x);\n+  else if (GET_CODE (x) == LABEL_REF)\n+    offset = 0; // We assume code labels are Pmode aligned\n+  else\n+    return false; // not sure what we have here.\n+\n+  /* If we don't know the alignment of the thing to which the symbol refers,\n+     we assume optimistically it is \"enough\".\n+     ??? maybe we should be pessimistic instead.  */\n+  unsigned align = 0;\n+\n+  if (sym)\n+    {\n+      tree decl = SYMBOL_REF_DECL (sym);\n+#if TARGET_MACHO\n+      if (MACHO_SYMBOL_INDIRECTION_P (sym))\n+      /* The decl in an indirection symbol is the original one, which might\n+\t be less aligned than the indirection.  Our indirections are always\n+\t pointer-aligned.  */\n+\t;\n+      else\n+#endif\n+      if (decl && DECL_ALIGN (decl))\n+\talign = DECL_ALIGN_UNIT (decl);\n+   }\n+\n+  unsigned int extra = 0;\n+  switch (mode)\n+    {\n+    case E_DFmode:\n+    case E_DDmode:\n+    case E_DImode:\n+      /* If we are using VSX scalar loads, restrict ourselves to reg+reg\n+\t addressing.  */\n+      if (VECTOR_MEM_VSX_P (mode))\n+\treturn false;\n+\n+      if (!TARGET_POWERPC64)\n+\textra = 4;\n+      else if ((offset & 3) || (align & 3))\n+\treturn false;\n+      break;\n+\n+    case E_TFmode:\n+    case E_IFmode:\n+    case E_KFmode:\n+    case E_TDmode:\n+    case E_TImode:\n+    case E_PTImode:\n+      extra = 8;\n+      if (!TARGET_POWERPC64)\n+\textra = 12;\n+      else if ((offset & 3) || (align & 3))\n+\treturn false;\n+      break;\n+\n+    default:\n+      break;\n+    }\n+\n+  /* We only care if the access(es) would cause a change to the high part.  */\n+  offset = ((offset & 0xffff) ^ 0x8000) - 0x8000;\n+  return SIGNED_16BIT_OFFSET_EXTRA_P (offset, extra);\n+}\n+\n /* Return true if the MEM operand is a memory operand suitable for use\n    with a (full width, possibly multiple) gpr load/store.  On\n    powerpc64 this means the offset must be divisible by 4.\n@@ -7366,7 +7463,13 @@ mem_operand_gpr (rtx op, machine_mode mode)\n   if (address_is_prefixed (addr, mode, NON_PREFIXED_DS))\n     return true;\n \n-  /* Don't allow non-offsettable addresses.  See PRs 83969 and 84279.  */\n+  /* We need to look through Mach-O PIC unspecs to determine if a lo_sum is\n+     really OK.  Doing this early avoids teaching all the other machinery\n+     about them.  */\n+  if (TARGET_MACHO && GET_CODE (addr) == LO_SUM)\n+    return darwin_rs6000_legitimate_lo_sum_const_p (XEXP (addr, 1), mode);\n+\n+  /* Only allow offsettable addresses.  See PRs 83969 and 84279.  */\n   if (!rs6000_offsettable_memref_p (op, mode, false))\n     return false;\n "}, {"sha": "29dd6165205e4729692504580da3baffac3343c5", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8228c8f2a54be12c70070d4eb2cd64483782b138/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8228c8f2a54be12c70070d4eb2cd64483782b138/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=8228c8f2a54be12c70070d4eb2cd64483782b138", "patch": "@@ -6894,13 +6894,6 @@\n ;; do the load 16-bits at a time.  We could do this by loading from memory,\n ;; and this is even supposed to be faster, but it is simpler not to get\n ;; integers in the TOC.\n-(define_insn \"movsi_low\"\n-  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n-        (mem:SI (lo_sum:SI (match_operand:SI 1 \"gpc_reg_operand\" \"b\")\n-                           (match_operand 2 \"\" \"\"))))]\n-  \"TARGET_MACHO && ! TARGET_64BIT\"\n-  \"lwz %0,lo16(%2)(%1)\"\n-  [(set_attr \"type\" \"load\")])\n \n ;;\t\tMR           LA           LWZ          LFIWZX       LXSIWZX\n ;;\t\tSTW          STFIWX       STXSIWX      LI           LIS"}]}