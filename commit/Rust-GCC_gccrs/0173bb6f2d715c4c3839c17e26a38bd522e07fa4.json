{"sha": "0173bb6f2d715c4c3839c17e26a38bd522e07fa4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDE3M2JiNmYyZDcxNWM0YzM4MzljMTdlMjZhMzhiZDUyMmUwN2ZhNA==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2004-06-15T21:43:21Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2004-06-15T21:43:21Z"}, "message": "c-pragma.h (c_lex_string_translate): Change type to int.\n\ngcc/ChangeLog:\n* c-pragma.h (c_lex_string_translate): Change type to int.\n* c-parse.in: Change all assignments of c_lex_string_translate\nto true and false to 1 and 0.\n* c-lex.c (c_lex_string_translate): Likewise.\n(lex_string): Convert string without translation in the -1\ncase.\ngcc/cp/ChangeLog:\n* parser.c: Change all assignments of c_lex_string_translate\nto true and false to 1 and 0.\n(cp_lexer_read_token): Convert type of the translated string.\n(cp_parser_skip_to_closing_parentheses): Preserve original\nvalue of c_lex_string_translate, and set it to -1 while\nrunning.\n(cp_parser_cache_group): Likewise.\n(cp_parser_cache_group_1): Renamed.\n(cp_parser_asm_operand_list): Remove redundant setting of\nc_lex_string_translate.\n(cp_parser_primary_expression) [CPP_STRING, CPP_WSTRING]:\nHandle chained strings.\n\nFrom-SVN: r83201", "tree": {"sha": "67706b17f5cedee1c188770ea57183755dfc2428", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/67706b17f5cedee1c188770ea57183755dfc2428"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0173bb6f2d715c4c3839c17e26a38bd522e07fa4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0173bb6f2d715c4c3839c17e26a38bd522e07fa4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0173bb6f2d715c4c3839c17e26a38bd522e07fa4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0173bb6f2d715c4c3839c17e26a38bd522e07fa4/comments", "author": null, "committer": null, "parents": [{"sha": "d0b25f9a2b786f80b5a794f99732b7653afb1ec4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0b25f9a2b786f80b5a794f99732b7653afb1ec4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d0b25f9a2b786f80b5a794f99732b7653afb1ec4"}], "stats": {"total": 193, "additions": 155, "deletions": 38}, "files": [{"sha": "fdd411cd49150ef7593372f9efd1e28137d67321", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0173bb6f2d715c4c3839c17e26a38bd522e07fa4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0173bb6f2d715c4c3839c17e26a38bd522e07fa4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0173bb6f2d715c4c3839c17e26a38bd522e07fa4", "patch": "@@ -1,3 +1,12 @@\n+2004-06-15  Alexandre Oliva  <aoliva@redhat.com>\n+\n+\t* c-pragma.h (c_lex_string_translate): Change type to int.\n+\t* c-parse.in: Change all assignments of c_lex_string_translate\n+\tto true and false to 1 and 0.\n+\t* c-lex.c (c_lex_string_translate): Likewise.\n+\t(lex_string): Convert string without translation in the -1\n+\tcase.\n+\n 2004-06-15  Mark G. Adams  <mark.g.adams@sympatico.ca>\n \n \t* convert.h: Add include guards"}, {"sha": "81723550b1371dd934889a66cc00785ba142bb96", "filename": "gcc/c-lex.c", "status": "modified", "additions": 28, "deletions": 1, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0173bb6f2d715c4c3839c17e26a38bd522e07fa4/gcc%2Fc-lex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0173bb6f2d715c4c3839c17e26a38bd522e07fa4/gcc%2Fc-lex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-lex.c?ref=0173bb6f2d715c4c3839c17e26a38bd522e07fa4", "patch": "@@ -53,7 +53,12 @@ static splay_tree file_info_tree;\n \n int pending_lang_change; /* If we need to switch languages - C++ only */\n int c_header_level;\t /* depth in C headers - C++ only */\n-bool c_lex_string_translate = true; /* If we need to translate characters received.  */\n+\n+/* If we need to translate characters received.  This is tri-state:\n+   0 means use only the untranslated string; 1 means use only\n+   the translated string; -1 means chain the translated string\n+   to the untranslated one.  */\n+int c_lex_string_translate = 1;\n \n static tree interpret_integer (const cpp_token *, unsigned int);\n static tree interpret_float (const cpp_token *, unsigned int);\n@@ -699,6 +704,28 @@ lex_string (const cpp_token *tok, tree *valp, bool objc_string)\n     {\n       value = build_string (istr.len, (char *)istr.text);\n       free ((void *)istr.text);\n+\n+      if (c_lex_string_translate == -1)\n+\t{\n+\t  if (!cpp_interpret_string_notranslate (parse_in, strs, count,\n+\t\t\t\t\t\t &istr, wide))\n+\t    /* Assume that, if we managed to translate the string\n+\t       above, then the untranslated parsing will always\n+\t       succeed.  */\n+\t    abort ();\n+\t  \n+\t  if (TREE_STRING_LENGTH (value) != (int)istr.len\n+\t      || 0 != strncmp (TREE_STRING_POINTER (value), (char *)istr.text,\n+\t\t\t       istr.len))\n+\t    {\n+\t      /* Arrange for us to return the untranslated string in\n+\t\t *valp, but to set up the C type of the translated\n+\t\t one.  */\n+\t      *valp = build_string (istr.len, (char *)istr.text);\n+\t      valp = &TREE_CHAIN (*valp);\n+\t    }\n+\t  free ((void *)istr.text);\n+\t}\n     }\n   else\n     {"}, {"sha": "ad3fb6ef5d22a67dd3f914529f6f89c8c4392c9b", "filename": "gcc/c-parse.in", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0173bb6f2d715c4c3839c17e26a38bd522e07fa4/gcc%2Fc-parse.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0173bb6f2d715c4c3839c17e26a38bd522e07fa4/gcc%2Fc-parse.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parse.in?ref=0173bb6f2d715c4c3839c17e26a38bd522e07fa4", "patch": "@@ -2545,11 +2545,11 @@ asm_clobbers:\n \t;\n \n stop_string_translation:\n-        { c_lex_string_translate = false; }\n+        { c_lex_string_translate = 0; }\n         ;\n \n start_string_translation:\n-        { c_lex_string_translate = true; }\n+        { c_lex_string_translate = 1; }\n         ;\n \n \f"}, {"sha": "6bb10f3af704f9e94d531192413a0ada06d34f0e", "filename": "gcc/c-pragma.h", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0173bb6f2d715c4c3839c17e26a38bd522e07fa4/gcc%2Fc-pragma.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0173bb6f2d715c4c3839c17e26a38bd522e07fa4/gcc%2Fc-pragma.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-pragma.h?ref=0173bb6f2d715c4c3839c17e26a38bd522e07fa4", "patch": "@@ -57,8 +57,10 @@ extern void add_to_renaming_pragma_list (tree, tree);\n extern int c_lex (tree *);\n extern int c_lex_with_flags (tree *, unsigned char *);\n \n-/* If true, then lex strings into the execution character set.  \n-   Otherwise, lex strings into the host character set.  */\n-extern bool c_lex_string_translate;\n+/* If 1, then lex strings into the execution character set.  \n+   If 0, lex strings into the host character set.\n+   If -1, lex both, and chain them together, such that the former\n+   is the TREE_CHAIN of the latter.  */\n+extern int c_lex_string_translate;\n \n #endif /* GCC_C_PRAGMA_H */"}, {"sha": "3889e75b7cf0540f84b7b2d0e843344744ff60e8", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0173bb6f2d715c4c3839c17e26a38bd522e07fa4/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0173bb6f2d715c4c3839c17e26a38bd522e07fa4/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=0173bb6f2d715c4c3839c17e26a38bd522e07fa4", "patch": "@@ -1,3 +1,18 @@\n+2004-06-15  Alexandre Oliva  <aoliva@redhat.com>\n+\n+\t* parser.c: Change all assignments of c_lex_string_translate\n+\tto true and false to 1 and 0.\n+\t(cp_lexer_read_token): Convert type of the translated string.\n+\t(cp_parser_skip_to_closing_parentheses): Preserve original\n+\tvalue of c_lex_string_translate, and set it to -1 while\n+\trunning.\n+\t(cp_parser_cache_group): Likewise.\n+\t(cp_parser_cache_group_1): Renamed.\n+\t(cp_parser_asm_operand_list): Remove redundant setting of\n+\tc_lex_string_translate.\n+\t(cp_parser_primary_expression) [CPP_STRING, CPP_WSTRING]:\n+\tHandle chained strings.\n+\n 2004-06-12  Andrew Pinski  <apinski@apple.com>\n \n \tPR c++/14639"}, {"sha": "bc736891feff284509329a124a8d4b92b1cd29d0", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 96, "deletions": 32, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0173bb6f2d715c4c3839c17e26a38bd522e07fa4/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0173bb6f2d715c4c3839c17e26a38bd522e07fa4/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=0173bb6f2d715c4c3839c17e26a38bd522e07fa4", "patch": "@@ -501,15 +501,25 @@ cp_lexer_read_token (cp_lexer* lexer)\n   if ((token->type == CPP_STRING || token->type == CPP_WSTRING)\n       && flag_const_strings)\n     {\n-      tree type;\n+      if (c_lex_string_translate)\n+\t{\n+\t  tree value = token->value;\n+\t  tree type;\n \n-      /* Get the current type.  It will be an ARRAY_TYPE.  */\n-      type = TREE_TYPE (token->value);\n-      /* Use build_cplus_array_type to rebuild the array, thereby\n-\t getting the right type.  */\n-      type = build_cplus_array_type (TREE_TYPE (type), TYPE_DOMAIN (type));\n-      /* Reset the type of the token.  */\n-      TREE_TYPE (token->value) = type;\n+\t  /* We might as well go ahead and release the chained\n+\t     translated string such that we can reuse its memory.  */\n+\t  if (TREE_CHAIN (value))\n+\t    value = TREE_CHAIN (token->value);\n+\n+\t  /* Get the current type.  It will be an ARRAY_TYPE.  */\n+\t  type = TREE_TYPE (value);\n+\t  /* Use build_cplus_array_type to rebuild the array, thereby\n+\t     getting the right type.  */\n+\t  type = build_cplus_array_type (TREE_TYPE (type),\n+\t\t\t\t\t TYPE_DOMAIN (type));\n+\t  /* Reset the type of the token.  */\n+\t  TREE_TYPE (value) = type;\n+\t}\n     }\n \n   return token;\n@@ -2082,34 +2092,53 @@ cp_parser_skip_to_closing_parenthesis (cp_parser *parser,\n {\n   unsigned paren_depth = 0;\n   unsigned brace_depth = 0;\n+  int saved_c_lex_string_translate = c_lex_string_translate;\n+  int result;\n \n   if (recovering && !or_comma && cp_parser_parsing_tentatively (parser)\n       && !cp_parser_committed_to_tentative_parse (parser))\n     return 0;\n \n+  if (! recovering)\n+    /* If we're looking ahead, keep both translated and untranslated\n+       strings.  */\n+    c_lex_string_translate = -1;\n+\n   while (true)\n     {\n       cp_token *token;\n \n       /* If we've run out of tokens, then there is no closing `)'.  */\n       if (cp_lexer_next_token_is (parser->lexer, CPP_EOF))\n-\treturn 0;\n+\t{\n+\t  result = 0;\n+\t  break;\n+\t}\n \n       token = cp_lexer_peek_token (parser->lexer);\n \n       /* This matches the processing in skip_to_end_of_statement.  */\n       if (token->type == CPP_SEMICOLON && !brace_depth)\n-\treturn 0;\n+\t{\n+\t  result = 0;\n+\t  break;\n+\t}\n       if (token->type == CPP_OPEN_BRACE)\n \t++brace_depth;\n       if (token->type == CPP_CLOSE_BRACE)\n \t{\n \t  if (!brace_depth--)\n-\t    return 0;\n+\t    {\n+\t      result = 0;\n+\t      break;\n+\t    }\n \t}\n       if (recovering && or_comma && token->type == CPP_COMMA\n \t  && !brace_depth && !paren_depth)\n-\treturn -1;\n+\t{\n+\t  result = -1;\n+\t  break;\n+\t}\n \n       if (!brace_depth)\n \t{\n@@ -2121,13 +2150,19 @@ cp_parser_skip_to_closing_parenthesis (cp_parser *parser,\n \t    {\n \t      if (consume_paren)\n \t\tcp_lexer_consume_token (parser->lexer);\n-\t      return 1;\n+\t      {\n+\t\tresult = 1;\n+\t\tbreak;\n+\t      }\n \t    }\n \t}\n \n       /* Consume the token.  */\n       cp_lexer_consume_token (parser->lexer);\n     }\n+\n+  c_lex_string_translate = saved_c_lex_string_translate;\n+  return result;\n }\n \n /* Consume tokens until we reach the end of the current statement.\n@@ -2463,12 +2498,18 @@ cp_parser_primary_expression (cp_parser *parser,\n \t   boolean-literal  */\n     case CPP_CHAR:\n     case CPP_WCHAR:\n-    case CPP_STRING:\n-    case CPP_WSTRING:\n     case CPP_NUMBER:\n       token = cp_lexer_consume_token (parser->lexer);\n       return token->value;\n \n+    case CPP_STRING:\n+    case CPP_WSTRING:\n+      token = cp_lexer_consume_token (parser->lexer);\n+      if (TREE_CHAIN (token->value))\n+\treturn TREE_CHAIN (token->value);\n+      else\n+\treturn token->value;\n+\n     case CPP_OPEN_PAREN:\n       {\n \ttree expr;\n@@ -6437,7 +6478,7 @@ cp_parser_declaration (cp_parser* parser)\n \n   /* Set this here since we can be called after\n      pushing the linkage specification.  */\n-  c_lex_string_translate = true;\n+  c_lex_string_translate = 1;\n \n   /* Check for the `__extension__' keyword.  */\n   if (cp_parser_extension_opt (parser, &saved_pedantic))\n@@ -6455,12 +6496,12 @@ cp_parser_declaration (cp_parser* parser)\n \n   /* Don't translate the CPP_STRING in extern \"C\".  */\n   if (token1.keyword == RID_EXTERN)\n-    c_lex_string_translate = false;\n+    c_lex_string_translate = 0;\n \n   if (token1.type != CPP_EOF)\n     token2 = *cp_lexer_peek_nth_token (parser->lexer, 2);\n \n-  c_lex_string_translate = true;\n+  c_lex_string_translate = 1;\n \n   /* If the next token is `extern' and the following token is a string\n      literal, then we have a linkage specification.  */\n@@ -7086,6 +7127,10 @@ cp_parser_linkage_specification (cp_parser* parser)\n       /* Assume C++ linkage.  */\n       linkage = get_identifier (\"c++\");\n     }\n+  /* If the string is chained to another string, take the latter,\n+     that's the untranslated string.  */\n+  else if (TREE_CHAIN (token->value))\n+    linkage = get_identifier (TREE_STRING_POINTER (TREE_CHAIN (token->value)));\n   /* If it's a simple string constant, things are easier.  */\n   else\n     linkage = get_identifier (TREE_STRING_POINTER (token->value));\n@@ -9915,7 +9960,7 @@ cp_parser_asm_definition (cp_parser* parser)\n   /* Look for the opening `('.  */\n   cp_parser_require (parser, CPP_OPEN_PAREN, \"`('\");\n   /* Look for the string.  */\n-  c_lex_string_translate = false;\n+  c_lex_string_translate = 0;\n   token = cp_parser_require (parser, CPP_STRING, \"asm body\");\n   if (!token)\n     goto finish;\n@@ -10012,7 +10057,7 @@ cp_parser_asm_definition (cp_parser* parser)\n     assemble_asm (string);\n \n  finish:\n-  c_lex_string_translate = true;\n+  c_lex_string_translate = 1;\n }\n \n /* Declarators [gram.dcl.decl] */\n@@ -13447,8 +13492,6 @@ cp_parser_asm_operand_list (cp_parser* parser)\n       tree name;\n       cp_token *token;\n \n-      c_lex_string_translate = false;\n-\n       if (cp_lexer_next_token_is (parser->lexer, CPP_OPEN_SQUARE))\n \t{\n \t  /* Consume the `[' token.  */\n@@ -13466,14 +13509,14 @@ cp_parser_asm_operand_list (cp_parser* parser)\n       /* Look for the string-literal.  */\n       token = cp_parser_require (parser, CPP_STRING, \"string-literal\");\n       string_literal = token ? token->value : error_mark_node;\n-      c_lex_string_translate = true;\n+      c_lex_string_translate = 1;\n       /* Look for the `('.  */\n       cp_parser_require (parser, CPP_OPEN_PAREN, \"`('\");\n       /* Parse the expression.  */\n       expression = cp_parser_expression (parser);\n       /* Look for the `)'.  */\n       cp_parser_require (parser, CPP_CLOSE_PAREN, \"`)'\");\n-      c_lex_string_translate = false;\n+      c_lex_string_translate = 0;\n       /* Add this operand to the list.  */\n       asm_operands = tree_cons (build_tree_list (name, string_literal),\n \t\t\t\texpression,\n@@ -13599,7 +13642,7 @@ cp_parser_attribute_list (cp_parser* parser)\n {\n   tree attribute_list = NULL_TREE;\n \n-  c_lex_string_translate = false;\n+  c_lex_string_translate = 0;\n   while (true)\n     {\n       cp_token *token;\n@@ -13645,7 +13688,7 @@ cp_parser_attribute_list (cp_parser* parser)\n       /* Consume the comma and keep going.  */\n       cp_lexer_consume_token (parser->lexer);\n     }\n-  c_lex_string_translate = true;\n+  c_lex_string_translate = 1;\n \n   /* We built up the list in reverse order.  */\n   return nreverse (attribute_list);\n@@ -15343,10 +15386,10 @@ cp_parser_pre_parsed_nested_name_specifier (cp_parser *parser)\n /* Add tokens to CACHE until a non-nested END token appears.  */\n \n static void\n-cp_parser_cache_group (cp_parser *parser,\n-\t\t       cp_token_cache *cache,\n-\t\t       enum cpp_ttype end,\n-\t\t       unsigned depth)\n+cp_parser_cache_group_1 (cp_parser *parser,\n+\t\t\t cp_token_cache *cache,\n+\t\t\t enum cpp_ttype end,\n+\t\t\t unsigned depth)\n {\n   while (true)\n     {\n@@ -15366,17 +15409,38 @@ cp_parser_cache_group (cp_parser *parser,\n       /* See if it starts a new group.  */\n       if (token->type == CPP_OPEN_BRACE)\n \t{\n-\t  cp_parser_cache_group (parser, cache, CPP_CLOSE_BRACE, depth + 1);\n+\t  cp_parser_cache_group_1 (parser, cache, CPP_CLOSE_BRACE, depth + 1);\n \t  if (depth == 0)\n \t    return;\n \t}\n       else if (token->type == CPP_OPEN_PAREN)\n-\tcp_parser_cache_group (parser, cache, CPP_CLOSE_PAREN, depth + 1);\n+\tcp_parser_cache_group_1 (parser, cache, CPP_CLOSE_PAREN, depth + 1);\n       else if (token->type == end)\n \treturn;\n     }\n }\n \n+/* Convenient interface for cp_parser_cache_group_1 that makes sure we\n+   preserve string tokens in both translated and untranslated\n+   forms.  */\n+\n+static void\n+cp_parser_cache_group (cp_parser *parser,\n+\t\t\t cp_token_cache *cache,\n+\t\t\t enum cpp_ttype end,\n+\t\t\t unsigned depth)\n+{\n+  int saved_c_lex_string_translate;\n+\n+  saved_c_lex_string_translate = c_lex_string_translate;\n+  c_lex_string_translate = -1;\n+\n+  cp_parser_cache_group_1 (parser, cache, end, depth);\n+  \n+  c_lex_string_translate = saved_c_lex_string_translate;\n+}\n+\n+\n /* Begin parsing tentatively.  We always save tokens while parsing\n    tentatively so that if the tentative parsing fails we can restore the\n    tokens.  */"}]}