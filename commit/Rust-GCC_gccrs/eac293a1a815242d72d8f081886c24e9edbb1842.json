{"sha": "eac293a1a815242d72d8f081886c24e9edbb1842", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWFjMjkzYTFhODE1MjQyZDcyZDhmMDgxODg2YzI0ZTllZGJiMTg0Mg==", "commit": {"author": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1994-09-30T00:51:03Z"}, "committer": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1994-09-30T00:51:03Z"}, "message": "48th Cygnus<->FSF merge\n\nFrom-SVN: r8177", "tree": {"sha": "563d598a2adceb35b8d17abcb77d88840bff053d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/563d598a2adceb35b8d17abcb77d88840bff053d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/eac293a1a815242d72d8f081886c24e9edbb1842", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eac293a1a815242d72d8f081886c24e9edbb1842", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eac293a1a815242d72d8f081886c24e9edbb1842", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eac293a1a815242d72d8f081886c24e9edbb1842/comments", "author": null, "committer": null, "parents": [{"sha": "63f7136fd89b12e2a76b546474ae5ec88fb1f62a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63f7136fd89b12e2a76b546474ae5ec88fb1f62a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/63f7136fd89b12e2a76b546474ae5ec88fb1f62a"}], "stats": {"total": 91, "additions": 68, "deletions": 23}, "files": [{"sha": "2596c951291c46ad94607770a303447b86c79414", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac293a1a815242d72d8f081886c24e9edbb1842/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac293a1a815242d72d8f081886c24e9edbb1842/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=eac293a1a815242d72d8f081886c24e9edbb1842", "patch": "@@ -12,6 +12,33 @@ Wed Sep 14 10:17:27 1994  Michael I Bushnell  <mib@churchy.gnu.ai.mit.edu>\n \t* g++.c: Include <sys/errno.h> in case `errno' is a macro\n \tas permitted by ANSI C.\n \n+Thu Sep 29 16:58:52 1994  Mike Stump  <mrs@cygnus.com>\n+\n+\t* typeck.c (c_expand_return): Use magic so the backend can fixup the\n+\tassignment into the return register, so cleanups won't clobber it.\n+\n+Thu Sep 29 13:08:50 1994  Jason Merrill  (jason@deneb.cygnus.com)\n+\n+\t* method.c (hack_identifier): Don't call assemble_external for\n+\ttemplate decls.\n+\n+\t* decl.c (finish_decl): Also end temporary allocation if the decl in\n+\tquestion has a type of error_mark_node.\n+\n+Wed Sep 28 21:45:00 1994  Mike Stump  (mrs@cygnus.com)\n+\n+\t* typeck.c (build_modify_expr): When optimizing ?: on lhs, make sure\n+\tthat if the ?: was a reference type, that the subparts will be also.\n+\n+Wed Sep 28 16:14:04 1994  Brendan Kehoe  (brendan@lisa.cygnus.com)\n+\n+\t* except.c (register_exception_table): Use Pmode, not PTRmode.\n+\n+Fri Sep 23 13:54:27 1994  Jason Merrill  (jason@deneb.cygnus.com)\n+\n+\t* lex.c (do_pending_inlines): Do method synthesis after the\n+\tpending_inlines have been reversed.\n+\n Thu Sep 22 12:53:03 1994  Per Bothner  (bothner@kalessin.cygnus.com)\n \n \t* decl2.c (finish_file):  Fix Brendan's fix:  Only call"}, {"sha": "e6b2bcca51c75c229e3b8927bd3e1de77916aa5a", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac293a1a815242d72d8f081886c24e9edbb1842/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac293a1a815242d72d8f081886c24e9edbb1842/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=eac293a1a815242d72d8f081886c24e9edbb1842", "patch": "@@ -5773,7 +5773,12 @@ finish_decl (decl, init, asmspec_tree, need_pop)\n   type = TREE_TYPE (decl);\n \n   if (type == error_mark_node)\n-    return;\n+    {\n+      if (current_binding_level == global_binding_level && temporary)\n+\tend_temporary_allocation ();\n+\n+      return;\n+    }\n \n   was_incomplete = (DECL_SIZE (decl) == NULL_TREE);\n "}, {"sha": "2441da1ba1dda4da4920024988113fdcf4955f2c", "filename": "gcc/cp/gxxint.texi", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac293a1a815242d72d8f081886c24e9edbb1842/gcc%2Fcp%2Fgxxint.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac293a1a815242d72d8f081886c24e9edbb1842/gcc%2Fcp%2Fgxxint.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fgxxint.texi?ref=eac293a1a815242d72d8f081886c24e9edbb1842", "patch": "@@ -1199,8 +1199,7 @@ catch variables cannot be used.  Only works on a Sun sparc running SunOS\n variables are cleaned up in all unwinded scopes.  Completed parts of\n partially constructed objects are not cleaned up.  Don't expect\n exception handling to work right if you optimize, in fact the compiler\n-will probably core dump.  You can only have one source file worth of\n-exception handling code.  If two EH regions are the exact same size, the\n+will probably core dump.  If two EH regions are the exact same size, the\n backend cannot tell which one is first.  It punts by picking the last\n one, if they tie.  This is usually right.  We really should stick in a\n nop, if they are the same size.\n@@ -1223,7 +1222,8 @@ The EH object is copied like it should be, if it is passed by value,\n otherwise we get a reference directly to it.\n \n EH objects make it through unwinding, but are subject to being\n-overwritten as they are still past the top of stack.\n+overwritten as they are still past the top of stack.  Don't throw\n+automatic objects if this is a problem.\n \n Exceptions in catch handlers now go to outer block.\n "}, {"sha": "89286b5e73bc35bbbb58b89db37120a3f2ea44a8", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 19, "deletions": 12, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac293a1a815242d72d8f081886c24e9edbb1842/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac293a1a815242d72d8f081886c24e9edbb1842/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=eac293a1a815242d72d8f081886c24e9edbb1842", "patch": "@@ -1100,23 +1100,25 @@ do_pending_inlines ()\n   if (yychar == PRE_PARSED_FUNCTION_DECL)\n     return;\n \n-  /* Note that we've seen these inlines and are dealing with them.  */\n-  for (t = pending_inlines; t; t = t->next)\n-    t->deja_vu = 1;\n-\n   /* Reverse the pending inline functions, since\n      they were cons'd instead of appended.  */\n   {\n-    struct pending_inline *prev = 0, *tail;\n+    struct pending_inline *prev = 0, *tail, *bottom = 0;\n     t = pending_inlines;\n     pending_inlines = 0;\n \n     for (; t; t = tail)\n       {\n \ttail = t->next;\n+\tt->next = prev;\n+\tt->deja_vu = 1;\n+\tprev = t;\n+      }\n \n-\t/* This kludge should go away when synthesized methods are handled\n-\t   properly, i.e. only when needed.  */\n+    /* This kludge should go away when synthesized methods are handled\n+       properly, i.e. only when needed.  */\n+    for (t = prev; t; t = t->next)\n+      {\n \tif (t->lineno <= 0)\n \t  {\n \t    tree f = t->fndecl;\n@@ -1134,13 +1136,18 @@ do_pending_inlines ()\n \t      default:\n \t\t;\n \t      }\n-\t    obstack_free (&synth_obstack, t);\n-\t    continue;\n+\t    if (tail)\n+\t      tail->next = t->next;\n+\t    else\n+\t      prev = t->next;\n+\t    if (! bottom)\n+\t      bottom = t;\n \t  }\n-\n-\tt->next = prev;\n-\tprev = t;\n+\telse\n+\t  tail = t;\n       }\n+    if (bottom)\n+      obstack_free (&synth_obstack, bottom);      \n     t = prev;\n   }\n "}, {"sha": "f32d005e9b9d1250417bf11e0dcd4a74e5a51155", "filename": "gcc/cp/method.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac293a1a815242d72d8f081886c24e9edbb1842/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac293a1a815242d72d8f081886c24e9edbb1842/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=eac293a1a815242d72d8f081886c24e9edbb1842", "patch": "@@ -1480,11 +1480,13 @@ hack_identifier (value, name, yychar)\n   if (really_overloaded_fn (value))\n     {\n       tree t = get_first_fn (value);\n-      while (t)\n+      for (; t; t = DECL_CHAIN (t))\n \t{\n+\t  if (TREE_CODE (t) == TEMPLATE_DECL)\n+\t    continue;\n+\n \t  assemble_external (t);\n \t  TREE_USED (t) = 1;\n-\t  t = DECL_CHAIN (t);\n \t}\n     }\n   else if (TREE_CODE (value) == TREE_LIST)"}, {"sha": "21ae12155195b4739f76564e525f50719004e5ac", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac293a1a815242d72d8f081886c24e9edbb1842/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac293a1a815242d72d8f081886c24e9edbb1842/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=eac293a1a815242d72d8f081886c24e9edbb1842", "patch": "@@ -5388,9 +5388,9 @@ build_modify_expr (lhs, modifycode, rhs)\n \t   so the code to compute it is only emitted once.  */\n \ttree cond\n \t  = build_conditional_expr (TREE_OPERAND (lhs, 0),\n-\t\t\t\t    build_modify_expr (TREE_OPERAND (lhs, 1),\n+\t\t\t\t    build_modify_expr (convert (TREE_TYPE (lhs), TREE_OPERAND (lhs, 1)),\n \t\t\t\t\t\t       modifycode, rhs),\n-\t\t\t\t    build_modify_expr (TREE_OPERAND (lhs, 2),\n+\t\t\t\t    build_modify_expr (convert (TREE_TYPE (lhs), TREE_OPERAND (lhs, 2)),\n \t\t\t\t\t\t       modifycode, rhs));\n \tif (TREE_CODE (cond) == ERROR_MARK)\n \t  return cond;\n@@ -7099,9 +7099,11 @@ c_expand_return (retval)\n \t  /* Here is where we finally get RETVAL into RESULT.\n \t     `expand_return' does the magic of protecting\n \t     RESULT from cleanups.  */\n+\t  retval = build1 (CLEANUP_POINT_EXPR, TREE_TYPE (result), retval);\n+\t  /* This part _must_ come second, because expand_return looks for\n+\t     the INIT_EXPR as the toplevel node only.  :-( */\n \t  retval = build (INIT_EXPR, TREE_TYPE (result), result, retval);\n \t  TREE_SIDE_EFFECTS (retval) = 1;\n-\t  retval = build1 (CLEANUP_POINT_EXPR, TREE_TYPE (result), retval);\n \t  expand_return (retval);\n \t}\n       else"}, {"sha": "dd6364e0e5bac8c9f032b22f76d632c17bfa002a", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eac293a1a815242d72d8f081886c24e9edbb1842/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eac293a1a815242d72d8f081886c24e9edbb1842/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=eac293a1a815242d72d8f081886c24e9edbb1842", "patch": "@@ -906,7 +906,7 @@ process_init_constructor (type, init, elts)\n \t\t{\n \t\t  error (\"non-empty initializer for array of empty elements\");\n \t\t  /* Just ignore what we were supposed to use.  */\n-\t\t  tail1 = 0;\n+\t\t  tail1 = NULL_TREE;\n \t\t}\n \t      tail = tail1;\n \t    }\n@@ -1154,7 +1154,9 @@ build_scoped_ref (datum, types)\n   if (TREE_CODE (types) == SCOPE_REF)\n     {\n       /* We have some work to do.  */\n-      struct type_chain { tree type; struct type_chain *next; } *chain = 0, *head = 0, scratch;\n+      struct type_chain\n+\t{ tree type; struct type_chain *next; }\n+      *chain = NULL, *head = NULL, scratch;\n       ref = build_unary_op (ADDR_EXPR, datum, 0);\n       while (TREE_CODE (types) == SCOPE_REF)\n \t{"}]}