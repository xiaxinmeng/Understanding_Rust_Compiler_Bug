{"sha": "692e031294569fc76371c9eda58f01cce1716c22", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjkyZTAzMTI5NDU2OWZjNzYzNzFjOWVkYTU4ZjAxY2NlMTcxNmMyMg==", "commit": {"author": {"name": "Trevor Saunders", "email": "tbsaunde+gcc@tbsaunde.org", "date": "2015-05-22T01:04:17Z"}, "committer": {"name": "Trevor Saunders", "email": "tbsaunde@gcc.gnu.org", "date": "2015-05-22T01:04:17Z"}, "message": "remove #if HAVE_conditional_move\n\ngcc/ChangeLog:\n\n2015-05-20  Trevor Saunders  <tbsaunde+gcc@tbsaunde.org>\n\n\t* combine.c, expmed.c, expr.c, optabs.c optabs.h, toplev.c: DOn't\n\tcheck HAVE_conditional_move with the preprocessor.\n\nFrom-SVN: r223518", "tree": {"sha": "140844ad5e7d79e1b2e7a34393602b9ee0d1c5c3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/140844ad5e7d79e1b2e7a34393602b9ee0d1c5c3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/692e031294569fc76371c9eda58f01cce1716c22", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/692e031294569fc76371c9eda58f01cce1716c22", "html_url": "https://github.com/Rust-GCC/gccrs/commit/692e031294569fc76371c9eda58f01cce1716c22", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/692e031294569fc76371c9eda58f01cce1716c22/comments", "author": null, "committer": null, "parents": [{"sha": "759df569f189ce9e4d015c5b46ea5e2107923c69", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/759df569f189ce9e4d015c5b46ea5e2107923c69", "html_url": "https://github.com/Rust-GCC/gccrs/commit/759df569f189ce9e4d015c5b46ea5e2107923c69"}], "stats": {"total": 76, "additions": 32, "deletions": 44}, "files": [{"sha": "eea5da58d8bfba441294e58eb35fda6cdc5be099", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/692e031294569fc76371c9eda58f01cce1716c22/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/692e031294569fc76371c9eda58f01cce1716c22/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=692e031294569fc76371c9eda58f01cce1716c22", "patch": "@@ -1,3 +1,8 @@\n+2015-05-20  Trevor Saunders  <tbsaunde+gcc@tbsaunde.org>\n+\n+\t* combine.c, expmed.c, expr.c, optabs.c optabs.h, toplev.c: DOn't\n+\tcheck HAVE_conditional_move with the preprocessor.\n+\n 2015-05-20  Trevor Saunders  <tbsaunde+gcc@tbsaunde.org>\n \n \t* genconfig.c (main): Always define HAVE_conditional_move."}, {"sha": "4a57557fe8cf16481fa5a56d621cf8b970d3a0de", "filename": "gcc/combine.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/692e031294569fc76371c9eda58f01cce1716c22/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/692e031294569fc76371c9eda58f01cce1716c22/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=692e031294569fc76371c9eda58f01cce1716c22", "patch": "@@ -6818,9 +6818,8 @@ simplify_set (rtx x)\n       && (GET_CODE (XEXP (src, 0)) == EQ || GET_CODE (XEXP (src, 0)) == NE)\n       && XEXP (XEXP (src, 0), 1) == const0_rtx\n       && GET_MODE (src) == GET_MODE (XEXP (XEXP (src, 0), 0))\n-#if HAVE_conditional_move\n-      && ! can_conditionally_move_p (GET_MODE (src))\n-#endif\n+      && (!HAVE_conditional_move\n+\t  || ! can_conditionally_move_p (GET_MODE (src)))\n       && (num_sign_bit_copies (XEXP (XEXP (src, 0), 0),\n \t\t\t       GET_MODE (XEXP (XEXP (src, 0), 0)))\n \t  == GET_MODE_PRECISION (GET_MODE (XEXP (XEXP (src, 0), 0))))"}, {"sha": "fa13f8ced3fc47cdd3fd4e0c8dce4d76b292b4aa", "filename": "gcc/expmed.c", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/692e031294569fc76371c9eda58f01cce1716c22/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/692e031294569fc76371c9eda58f01cce1716c22/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=692e031294569fc76371c9eda58f01cce1716c22", "patch": "@@ -3797,9 +3797,8 @@ expand_sdiv_pow2 (machine_mode mode, rtx op0, HOST_WIDE_INT d)\n       return expand_shift (RSHIFT_EXPR, mode, temp, logd, NULL_RTX, 0);\n     }\n \n-#if HAVE_conditional_move\n-  if (BRANCH_COST (optimize_insn_for_speed_p (), false)\n-      >= 2)\n+  if (HAVE_conditional_move\n+      && BRANCH_COST (optimize_insn_for_speed_p (), false) >= 2)\n     {\n       rtx temp2;\n \n@@ -3821,7 +3820,6 @@ expand_sdiv_pow2 (machine_mode mode, rtx op0, HOST_WIDE_INT d)\n \t}\n       end_sequence ();\n     }\n-#endif\n \n   if (BRANCH_COST (optimize_insn_for_speed_p (),\n \t\t   false) >= 2)\n@@ -5555,7 +5553,9 @@ emit_store_flag (rtx target, enum rtx_code code, rtx op0, rtx op1,\n \t\t\t\t    target_mode);\n \t}\n \n-#if HAVE_conditional_move\n+      if (!HAVE_conditional_move)\n+\treturn 0;\n+\n       /* Try using a setcc instruction for ORDERED/UNORDERED, followed by a\n \t conditional move.  */\n       tem = emit_store_flag_1 (subtarget, first_code, op0, op1, mode, 0,\n@@ -5573,9 +5573,6 @@ emit_store_flag (rtx target, enum rtx_code code, rtx op0, rtx op1,\n       if (tem == 0)\n         delete_insns_since (last);\n       return tem;\n-#else\n-      return 0;\n-#endif\n     }\n \n   /* The remaining tricks only apply to integer comparisons.  */"}, {"sha": "3605e9942897980d63a65ab1de1fbcf1a6beac68", "filename": "gcc/expr.c", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/692e031294569fc76371c9eda58f01cce1716c22/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/692e031294569fc76371c9eda58f01cce1716c22/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=692e031294569fc76371c9eda58f01cce1716c22", "patch": "@@ -2423,7 +2423,6 @@ get_def_for_expr (tree name, enum tree_code code)\n   return def_stmt;\n }\n \n-#if HAVE_conditional_move\n /* Return the defining gimple statement for SSA_NAME NAME if it is an\n    assigment and the class of the expresion on the RHS is CLASS.  Return\n    NULL otherwise.  */\n@@ -2443,7 +2442,6 @@ get_def_for_expr_class (tree name, enum tree_code_class tclass)\n \n   return def_stmt;\n }\n-#endif\n \f\n \n /* Determine whether the LEN bytes generated by CONSTFUN can be\n@@ -7517,7 +7515,6 @@ highest_pow2_factor_for_target (const_tree target, const_tree exp)\n   return MAX (factor, talign);\n }\n \f\n-#if HAVE_conditional_move\n /* Convert the tree comparison code TCODE to the rtl one where the\n    signedness is UNSIGNEDP.  */\n \n@@ -7575,7 +7572,6 @@ convert_tree_comp_to_rtx (enum tree_code tcode, int unsignedp)\n     }\n   return code;\n }\n-#endif\n \n /* Subroutine of expand_expr.  Expand the two operands of a binary\n    expression EXP0 and EXP1 placing the results in OP0 and OP1.\n@@ -8021,7 +8017,6 @@ expand_cond_expr_using_cmove (tree treeop0 ATTRIBUTE_UNUSED,\n \t\t\t      tree treeop1 ATTRIBUTE_UNUSED,\n \t\t\t      tree treeop2 ATTRIBUTE_UNUSED)\n {\n-#if HAVE_conditional_move\n   rtx insn;\n   rtx op00, op01, op1, op2;\n   enum rtx_code comparison_code;\n@@ -8105,7 +8100,6 @@ expand_cond_expr_using_cmove (tree treeop0 ATTRIBUTE_UNUSED,\n   /* Otherwise discard the sequence and fall back to code with\n      branches.  */\n   end_sequence ();\n-#endif\n   return NULL_RTX;\n }\n \n@@ -8892,7 +8886,7 @@ expand_expr_real_2 (sepops ops, rtx target, machine_mode tmode,\n \t    if (code == MIN_EXPR)\n \t      comparison_code = LT;\n \t  }\n-#if HAVE_conditional_move\n+\n \t/* Use a conditional move if possible.  */\n \tif (can_conditionally_move_p (mode))\n \t  {\n@@ -8920,7 +8914,7 @@ expand_expr_real_2 (sepops ops, rtx target, machine_mode tmode,\n \t       branches.  */\n \t    end_sequence ();\n \t  }\n-#endif\n+\n \tif (target != op0)\n \t  emit_move_insn (target, op0);\n "}, {"sha": "21150db1b2919f71a481d2e4a9f86a729c1dd132", "filename": "gcc/optabs.c", "status": "modified", "additions": 12, "deletions": 18, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/692e031294569fc76371c9eda58f01cce1716c22/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/692e031294569fc76371c9eda58f01cce1716c22/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=692e031294569fc76371c9eda58f01cce1716c22", "patch": "@@ -929,7 +929,6 @@ expand_subword_shift (machine_mode op1_mode, optab binoptab,\n }\n \n \n-#if HAVE_conditional_move\n /* Try implementing expand_doubleword_shift using conditional moves.\n    The shift is by < BITS_PER_WORD if (CMP_CODE CMP1 CMP2) is true,\n    otherwise it is by >= BITS_PER_WORD.  SUBWORD_OP1 and SUPERWORD_OP1\n@@ -989,7 +988,6 @@ expand_doubleword_shift_condmove (machine_mode op1_mode, optab binoptab,\n \n   return true;\n }\n-#endif\n \n /* Expand a doubleword shift (ashl, ashr or lshr) using word-mode shifts.\n    OUTOF_INPUT and INTO_INPUT are the two word-sized halves of the first\n@@ -1096,20 +1094,19 @@ expand_doubleword_shift (machine_mode op1_mode, optab binoptab,\n \t\t\t\t     unsignedp, methods, shift_mask);\n     }\n \n-#if HAVE_conditional_move\n   /* Try using conditional moves to generate straight-line code.  */\n-  {\n-    rtx_insn *start = get_last_insn ();\n-    if (expand_doubleword_shift_condmove (op1_mode, binoptab,\n-\t\t\t\t\t  cmp_code, cmp1, cmp2,\n-\t\t\t\t\t  outof_input, into_input,\n-\t\t\t\t\t  op1, superword_op1,\n-\t\t\t\t\t  outof_target, into_target,\n-\t\t\t\t\t  unsignedp, methods, shift_mask))\n-      return true;\n-    delete_insns_since (start);\n-  }\n-#endif\n+  if (HAVE_conditional_move)\n+    {\n+      rtx_insn *start = get_last_insn ();\n+      if (expand_doubleword_shift_condmove (op1_mode, binoptab,\n+\t\t\t\t\t    cmp_code, cmp1, cmp2,\n+\t\t\t\t\t    outof_input, into_input,\n+\t\t\t\t\t    op1, superword_op1,\n+\t\t\t\t\t    outof_target, into_target,\n+\t\t\t\t\t    unsignedp, methods, shift_mask))\n+\treturn true;\n+      delete_insns_since (start);\n+    }\n \n   /* As a last resort, use branches to select the correct alternative.  */\n   rtx_code_label *subword_label = gen_label_rtx ();\n@@ -4518,7 +4515,6 @@ emit_indirect_jump (rtx loc ATTRIBUTE_UNUSED)\n #endif\n }\n \f\n-#if HAVE_conditional_move\n \n /* Emit a conditional move instruction if the machine supports one for that\n    condition and machine mode.\n@@ -4636,8 +4632,6 @@ can_conditionally_move_p (machine_mode mode)\n   return 0;\n }\n \n-#endif /* HAVE_conditional_move */\n-\n /* Emit a conditional addition instruction if the machine supports one for that\n    condition and machine mode.\n "}, {"sha": "8bff2f964b2fdb3b534b82c003e1c2dd8ae9cf9c", "filename": "gcc/optabs.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/692e031294569fc76371c9eda58f01cce1716c22/gcc%2Foptabs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/692e031294569fc76371c9eda58f01cce1716c22/gcc%2Foptabs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.h?ref=692e031294569fc76371c9eda58f01cce1716c22", "patch": "@@ -364,15 +364,13 @@ extern void emit_indirect_jump (rtx);\n #error \"insn-config.h must be included before optabs.h\"\n #endif\n \n-#if HAVE_conditional_move\n /* Emit a conditional move operation.  */\n rtx emit_conditional_move (rtx, enum rtx_code, rtx, rtx, machine_mode,\n \t\t\t   rtx, rtx, machine_mode, int);\n \n /* Return nonzero if the conditional move is supported.  */\n int can_conditionally_move_p (machine_mode mode);\n \n-#endif\n rtx emit_conditional_add (rtx, enum rtx_code, rtx, rtx, machine_mode,\n \t\t\t  rtx, rtx, machine_mode, int);\n "}, {"sha": "18a725a779f8abad1b69becd5eea7c0674105aa7", "filename": "gcc/toplev.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/692e031294569fc76371c9eda58f01cce1716c22/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/692e031294569fc76371c9eda58f01cce1716c22/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=692e031294569fc76371c9eda58f01cce1716c22", "patch": "@@ -1576,11 +1576,12 @@ process_options (void)\n     warning (0, \"var-tracking-assignments changes selective scheduling\");\n \n   if (flag_tree_cselim == AUTODETECT_VALUE)\n-#if HAVE_conditional_move\n-    flag_tree_cselim = 1;\n-#else\n-    flag_tree_cselim = 0;\n-#endif\n+    {\n+      if (HAVE_conditional_move)\n+\tflag_tree_cselim = 1;\n+      else\n+\tflag_tree_cselim = 0;\n+    }\n \n   /* If auxiliary info generation is desired, open the output file.\n      This goes in the same directory as the source file--unlike"}]}