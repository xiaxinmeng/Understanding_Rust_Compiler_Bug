{"sha": "38b0dcb81effec70e61bb1e652c0cab254245115", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzhiMGRjYjgxZWZmZWM3MGU2MWJiMWU2NTJjMGNhYjI1NDI0NTExNQ==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "dvorakz@suse.cz", "date": "2004-10-27T20:27:20Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2004-10-27T20:27:20Z"}, "message": "re PR tree-optimization/18048 (mgrid loop performance regression with ivopts (register pressure))\n\n\tPR tree-optimization/18048\n\t* fold-const.c (try_move_mult_to_index): New function.\n\t(fold): Use try_move_mult_to_index.\n\t* tree-ssa-loop-ivopts.c (try_add_cand_for): Prefer common candidates.\n\t* tree-ssa-loop-niter.c (number_of_iterations_cond): Produce\n\tan all-ones unsigned constant without extra bits.\n\t* tree.c (build_low_bits_mask): New function.\n\t* tree.h (build_low_bits_mask): Declare.\n\nFrom-SVN: r89708", "tree": {"sha": "36323e61beca852219425c346a9efad5a6b0dfb5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/36323e61beca852219425c346a9efad5a6b0dfb5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/38b0dcb81effec70e61bb1e652c0cab254245115", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38b0dcb81effec70e61bb1e652c0cab254245115", "html_url": "https://github.com/Rust-GCC/gccrs/commit/38b0dcb81effec70e61bb1e652c0cab254245115", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38b0dcb81effec70e61bb1e652c0cab254245115/comments", "author": null, "committer": null, "parents": [{"sha": "89e73849fd8fe510b1e5b8b91b5ce1211d377f95", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89e73849fd8fe510b1e5b8b91b5ce1211d377f95", "html_url": "https://github.com/Rust-GCC/gccrs/commit/89e73849fd8fe510b1e5b8b91b5ce1211d377f95"}], "stats": {"total": 213, "additions": 204, "deletions": 9}, "files": [{"sha": "e517dd3e8e6da5b83c38b649f6e76e15a147df8f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38b0dcb81effec70e61bb1e652c0cab254245115/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38b0dcb81effec70e61bb1e652c0cab254245115/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=38b0dcb81effec70e61bb1e652c0cab254245115", "patch": "@@ -1,3 +1,14 @@\n+2004-10-27  Zdenek Dvorak  <dvorakz@suse.cz>\n+\n+\tPR tree-optimization/18048\n+\t* fold-const.c (try_move_mult_to_index): New function.\n+\t(fold): Use try_move_mult_to_index.\n+\t* tree-ssa-loop-ivopts.c (try_add_cand_for): Prefer common candidates.\n+\t* tree-ssa-loop-niter.c (number_of_iterations_cond): Produce\n+\tan all-ones unsigned constant without extra bits.\n+\t* tree.c (build_low_bits_mask): New function.\n+\t* tree.h (build_low_bits_mask): Declare.\n+\n 2004-10-27  David Edelsohn  <edelsohn@gnu.org>\n \n \tPR target/17956"}, {"sha": "00892f4abb027ec46505abc352e571be18cea88f", "filename": "gcc/fold-const.c", "status": "modified", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38b0dcb81effec70e61bb1e652c0cab254245115/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38b0dcb81effec70e61bb1e652c0cab254245115/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=38b0dcb81effec70e61bb1e652c0cab254245115", "patch": "@@ -5967,6 +5967,84 @@ tree_swap_operands_p (tree arg0, tree arg1, bool reorder)\n   return 0;\n }\n \n+/* Tries to replace &a[idx] CODE s * delta with &a[idx CODE delta], if s is\n+   step of the array.  TYPE is the type of the expression.  ADDR is the address.\n+   MULT is the multiplicative expression.  If the function succeeds, the new\n+   address expression is returned.  Otherwise NULL_TREE is returned.  */\n+\n+static tree\n+try_move_mult_to_index (tree type, enum tree_code code, tree addr, tree mult)\n+{\n+  tree s, delta, step;\n+  tree arg0 = TREE_OPERAND (mult, 0), arg1 = TREE_OPERAND (mult, 1);\n+  tree ref = TREE_OPERAND (addr, 0), pref;\n+  tree ret, pos;\n+  tree itype;\n+\n+  STRIP_NOPS (arg0);\n+  STRIP_NOPS (arg1);\n+  \n+  if (TREE_CODE (arg0) == INTEGER_CST)\n+    {\n+      s = arg0;\n+      delta = arg1;\n+    }\n+  else if (TREE_CODE (arg1) == INTEGER_CST)\n+    {\n+      s = arg1;\n+      delta = arg0;\n+    }\n+  else\n+    return NULL_TREE;\n+\n+  for (;; ref = TREE_OPERAND (ref, 0))\n+    {\n+      if (TREE_CODE (ref) == ARRAY_REF)\n+\t{\n+\t  step = array_ref_element_size (ref);\n+\n+\t  if (TREE_CODE (step) != INTEGER_CST)\n+\t    continue;\n+\n+\t  itype = TREE_TYPE (step);\n+\n+\t  /* If the type sizes do not match, we might run into problems\n+\t     when one of them would overflow.  */\n+\t  if (TYPE_PRECISION (itype) != TYPE_PRECISION (type))\n+\t    continue;\n+\n+\t  if (!operand_equal_p (step, fold_convert (itype, s), 0))\n+\t    continue;\n+\n+\t  delta = fold_convert (itype, delta);\n+\t  break;\n+\t}\n+\n+      if (!handled_component_p (ref))\n+\treturn NULL_TREE;\n+    }\n+\n+  /* We found the suitable array reference.  So copy everything up to it,\n+     and replace the index.  */\n+\n+  pref = TREE_OPERAND (addr, 0);\n+  ret = copy_node (pref);\n+  pos = ret;\n+\n+  while (pref != ref)\n+    {\n+      pref = TREE_OPERAND (pref, 0);\n+      TREE_OPERAND (pos, 0) = copy_node (pref);\n+      pos = TREE_OPERAND (pos, 0);\n+    }\n+\n+  TREE_OPERAND (pos, 1) = fold (build2 (code, itype,\n+\t\t\t\t\tTREE_OPERAND (pos, 1),\n+\t\t\t\t\tdelta));\n+\n+  return build1 (ADDR_EXPR, type, ret);\n+}\n+\n /* Perform constant folding and related simplification of EXPR.\n    The related simplifications include x*1 => x, x*0 => 0, etc.,\n    and application of the associative law.\n@@ -6602,6 +6680,24 @@ fold (tree expr)\n \t\t\t\t\t\t   alt0, alt1)),\n \t\t\t\t     same));\n \t    }\n+\n+\t  /* Try replacing &a[i1] + c * i2 with &a[i1 + i2], if c is step\n+\t     of the array.  Loop optimizer sometimes produce this type of\n+\t     expressions.  */\n+\t  if (TREE_CODE (arg0) == ADDR_EXPR\n+\t      && TREE_CODE (arg1) == MULT_EXPR)\n+\t    {\n+\t      tem = try_move_mult_to_index (type, PLUS_EXPR, arg0, arg1);\n+\t      if (tem)\n+\t\treturn fold (tem);\n+\t    }\n+\t  else if (TREE_CODE (arg1) == ADDR_EXPR\n+\t\t   && TREE_CODE (arg0) == MULT_EXPR)\n+\t    {\n+\t      tem = try_move_mult_to_index (type, PLUS_EXPR, arg1, arg0);\n+\t      if (tem)\n+\t\treturn fold (tem);\n+\t    }\n \t}\n       else\n \t{\n@@ -6974,6 +7070,17 @@ fold (tree expr)\n \t\t\t\t     &diff))\n \t  return build_int_cst_type (type, diff);\n       }\n+\t  \n+      /* Try replacing &a[i1] - c * i2 with &a[i1 - i2], if c is step\n+\t of the array.  Loop optimizer sometimes produce this type of\n+\t expressions.  */\n+      if (TREE_CODE (arg0) == ADDR_EXPR\n+\t  && TREE_CODE (arg1) == MULT_EXPR)\n+\t{\n+\t  tem = try_move_mult_to_index (type, MINUS_EXPR, arg0, arg1);\n+\t  if (tem)\n+\t    return fold (tem);\n+\t}\n \n       if (TREE_CODE (arg0) == MULT_EXPR\n \t  && TREE_CODE (arg1) == MULT_EXPR"}, {"sha": "c0c800a7465c850b07253cd771e47a22379ab6af", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 47, "deletions": 6, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38b0dcb81effec70e61bb1e652c0cab254245115/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38b0dcb81effec70e61bb1e652c0cab254245115/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=38b0dcb81effec70e61bb1e652c0cab254245115", "patch": "@@ -3603,20 +3603,32 @@ try_add_cand_for (struct ivopts_data *data, bitmap ivs, bitmap inv,\n   bitmap act_inv = BITMAP_XMALLOC ();\n   unsigned i;\n   struct cost_pair *cp;\n+  bitmap_iterator bi;\n+  struct iv_cand *cand;\n+  bitmap depends_on;\n \n   bitmap_copy (best_ivs, ivs);\n   bitmap_copy (best_inv, inv);\n \n-  for (i = 0; i < use->n_map_members; i++)\n+  /* First try important candidates.  Only if it fails, try the specific ones.\n+     Rationale -- in loops with many variables the best choice often is to use\n+     just one generic biv.  If we added here many ivs specific to the uses,\n+     the optimization algorithm later would be likely to get stuck in a local\n+     minimum, thus causing us to create too many ivs.  The approach from\n+     few ivs to more seems more likely to be succesful -- starting from few\n+     ivs, replacing an expensive use by a specific iv should always be a\n+     win.  */\n+  EXECUTE_IF_SET_IN_BITMAP (data->important_candidates, 0, i, bi)\n     {\n-      cp = use->cost_map + i;\n-      if (cp->cost == INFTY)\n+      cand = iv_cand (data, i);\n+\n+      if (get_use_iv_cost (data, use, cand, &depends_on) == INFTY)\n \tcontinue;\n \n       bitmap_copy (act_ivs, ivs);\n-      bitmap_set_bit (act_ivs, cp->cand->id);\n-      if (cp->depends_on)\n-\tbitmap_a_or_b (act_inv, inv, cp->depends_on);\n+      bitmap_set_bit (act_ivs, cand->id);\n+      if (depends_on)\n+\tbitmap_a_or_b (act_inv, inv, depends_on);\n       else\n \tbitmap_copy (act_inv, inv);\n       act_cost = set_cost_up_to (data, act_ivs, act_inv, use->id + 1);\n@@ -3629,6 +3641,35 @@ try_add_cand_for (struct ivopts_data *data, bitmap ivs, bitmap inv,\n \t}\n     }\n \n+  if (best_cost == INFTY)\n+    {\n+      for (i = 0; i < use->n_map_members; i++)\n+\t{\n+\t  cp = use->cost_map + i;\n+\t  if (cp->cost == INFTY)\n+\t    continue;\n+\n+\t  /* Already tried this.  */\n+\t  if (cp->cand->important)\n+\t    continue;\n+\n+\t  bitmap_copy (act_ivs, ivs);\n+\t  bitmap_set_bit (act_ivs, cp->cand->id);\n+\t  if (cp->depends_on)\n+\t    bitmap_a_or_b (act_inv, inv, cp->depends_on);\n+\t  else\n+\t    bitmap_copy (act_inv, inv);\n+\t  act_cost = set_cost_up_to (data, act_ivs, act_inv, use->id + 1);\n+\n+\t  if (act_cost < best_cost)\n+\t    {\n+\t      best_cost = act_cost;\n+\t      bitmap_copy (best_ivs, act_ivs);\n+\t      bitmap_copy (best_inv, act_inv);\n+\t    }\n+\t}\n+    }\n+\n   bitmap_copy (ivs, best_ivs);\n   bitmap_copy (inv, best_inv);\n "}, {"sha": "496b3f3eebdbfbe94b07747a43eded55d379e4d8", "filename": "gcc/tree-ssa-loop-niter.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38b0dcb81effec70e61bb1e652c0cab254245115/gcc%2Ftree-ssa-loop-niter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38b0dcb81effec70e61bb1e652c0cab254245115/gcc%2Ftree-ssa-loop-niter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.c?ref=38b0dcb81effec70e61bb1e652c0cab254245115", "patch": "@@ -419,9 +419,10 @@ number_of_iterations_cond (tree type, tree base0, tree step0,\n       d = EXEC_BINARY (LSHIFT_EXPR, niter_type,\n \t\t       build_int_cst_type (niter_type, 1), bits);\n       s = EXEC_BINARY (RSHIFT_EXPR, niter_type, step0, bits);\n-      bound = EXEC_BINARY (RSHIFT_EXPR, niter_type,\n-\t\t\t   build_int_cst (niter_type, -1),\n-\t\t\t   bits);\n+\n+      bound = build_low_bits_mask (niter_type,\n+\t\t\t\t   (TYPE_PRECISION (niter_type)\n+\t\t\t\t    - tree_low_cst (bits, 1)));\n \n       assumption = fold (build2 (FLOOR_MOD_EXPR, niter_type, base1, d));\n       assumption = fold (build2 (EQ_EXPR, boolean_type_node,"}, {"sha": "9531e695d9a3aadd5440537c3c18a48296bb6bf7", "filename": "gcc/tree.c", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38b0dcb81effec70e61bb1e652c0cab254245115/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38b0dcb81effec70e61bb1e652c0cab254245115/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=38b0dcb81effec70e61bb1e652c0cab254245115", "patch": "@@ -609,6 +609,40 @@ build_int_cst_wide (tree type, unsigned HOST_WIDE_INT low, HOST_WIDE_INT hi)\n   return t;\n }\n \n+/* Builds an integer constant in TYPE such that lowest BITS bits are ones\n+   and the rest are zeros.  */\n+\n+tree\n+build_low_bits_mask (tree type, unsigned bits)\n+{\n+  unsigned HOST_WIDE_INT low;\n+  HOST_WIDE_INT high;\n+  unsigned HOST_WIDE_INT all_ones = ~(unsigned HOST_WIDE_INT) 0;\n+\n+  gcc_assert (bits <= TYPE_PRECISION (type));\n+\n+  if (bits == TYPE_PRECISION (type)\n+      && !TYPE_UNSIGNED (type))\n+    {\n+      /* Sign extended all-ones mask.  */\n+      low = all_ones;\n+      high = -1;\n+    }\n+  else if (bits <= HOST_BITS_PER_WIDE_INT)\n+    {\n+      low = all_ones >> (HOST_BITS_PER_WIDE_INT - bits);\n+      high = 0;\n+    }\n+  else\n+    {\n+      bits -= HOST_BITS_PER_WIDE_INT;\n+      low = all_ones;\n+      high = all_ones >> (HOST_BITS_PER_WIDE_INT - bits);\n+    }\n+\n+  return build_int_cst_wide (type, low, high);\n+}\n+\n /* Checks that X is integer constant that can be expressed in (unsigned)\n    HOST_WIDE_INT without loss of precision.  */\n "}, {"sha": "31a5903e86a020c36a2f2dea74face79bf7208e3", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38b0dcb81effec70e61bb1e652c0cab254245115/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38b0dcb81effec70e61bb1e652c0cab254245115/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=38b0dcb81effec70e61bb1e652c0cab254245115", "patch": "@@ -3543,6 +3543,7 @@ tree fold_build_cleanup_point_expr (tree type, tree expr);\n extern tree build_fold_addr_expr_with_type (tree, tree);\n extern tree build_fold_indirect_ref (tree);\n extern tree constant_boolean_node (int, tree);\n+extern tree build_low_bits_mask (tree, unsigned);\n \n extern bool tree_swap_operands_p (tree, tree, bool);\n extern enum tree_code swap_tree_comparison (enum tree_code);"}]}