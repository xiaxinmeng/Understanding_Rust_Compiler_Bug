{"sha": "9110a741e35c54e46c00662ddc420575376c5947", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTExMGE3NDFlMzVjNTRlNDZjMDA2NjJkZGM0MjA1NzUzNzZjNTk0Nw==", "commit": {"author": {"name": "Bryce McKinlay", "email": "bryce@waitaki.otago.ac.nz", "date": "2001-05-21T08:35:14Z"}, "committer": {"name": "Bryce McKinlay", "email": "bryce@gcc.gnu.org", "date": "2001-05-21T08:35:14Z"}, "message": "Imported version version 6.0alpha7.\n\n\t* README, README.Mac, README.OS2, README.QUICK, README.alpha,\n\tREADME.amiga, README.debugging, README.dj, README.hp, README.linux,\n\tREADME.rs6000, README.sgi, README.solaris2, README.uts,\n\tREADME.win32, SCoptions.amiga, backptr.h, barrett_diagram,\n\tdbg_mlc.h, gc.h, gc.man, gc_alloc.h, gc_cpp.h, gc_hdrs.h, gc_mark.h,\n\tgc_priv.h, gc_private.h, gc_typed.h, gcconfig.h,\n\thpux_irix_threads.c, makefile.depend, nursery.c,\n\tsolaris_threads.h, test.c, test_cpp.cc, weakpointer.h, cord/README,\n\tcord/SCOPTIONS.amiga, cord/SMakefile.amiga, cord/cord.h,\n\tcord/ec.h, cord/gc.h, cord/private/cord_pos.h, include/backptr.h,\n\tinclude/gc_copy_descr.h, include/gc_nursery.h: Remove obsolete/moved\n\tfiles.\n\nFrom-SVN: r42379", "tree": {"sha": "67e9db3b367c46dfbcccda8278d06da72494187d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/67e9db3b367c46dfbcccda8278d06da72494187d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9110a741e35c54e46c00662ddc420575376c5947", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9110a741e35c54e46c00662ddc420575376c5947", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9110a741e35c54e46c00662ddc420575376c5947", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9110a741e35c54e46c00662ddc420575376c5947/comments", "author": null, "committer": null, "parents": [{"sha": "a6951ca5dee8ed05749cdc697767910aebaedcc0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6951ca5dee8ed05749cdc697767910aebaedcc0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a6951ca5dee8ed05749cdc697767910aebaedcc0"}], "stats": {"total": 20451, "additions": 5688, "deletions": 14763}, "files": [{"sha": "a8e06827ebc9387ab5b3d534a562d5a11ba47470", "filename": "boehm-gc/BCC_MAKEFILE", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9110a741e35c54e46c00662ddc420575376c5947/boehm-gc%2FBCC_MAKEFILE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9110a741e35c54e46c00662ddc420575376c5947/boehm-gc%2FBCC_MAKEFILE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FBCC_MAKEFILE?ref=9110a741e35c54e46c00662ddc420575376c5947", "patch": "@@ -47,9 +47,9 @@ gc.lib: $(OBJS)\n         $(XXXOBJS:XXX=+)\r\n |\r\n \r\n-gctest.exe: test.obj gc.lib\r\n+gctest.exe: tests\\test.obj gc.lib\r\n     $(cc) @&&|\r\n-        $(cflags) -W -e$* test.obj gc.lib\r\n+        $(cflags) -W -e$* tests\\test.obj gc.lib\r\n |\r\n \r\n cord\\de.obj cord\\de_win.obj: cord\\cord.h cord\\private\\cord_pos.h cord\\de_win.h \\\r\n@@ -68,8 +68,8 @@ gc_cpp.obj: gc_cpp.h gc.h\n gc_cpp.cpp: gc_cpp.cc\r\n \tcopy gc_cpp.cc gc_cpp.cpp\r\n \r\n-test_cpp.cpp: test_cpp.cc\r\n-\tcopy test_cpp.cc test_cpp.cpp\r\n+test_cpp.cpp: tests\\test_cpp.cc\r\n+\tcopy tests\\test_cpp.cc test_cpp.cpp\r\n \r\n test_cpp.exe: test_cpp.obj gc_cpp.h gc.h gc.lib\r\n     $(cc) @&&|\r"}, {"sha": "467e28ca7fd27802ae6b5796ea2cd343f0a95d99", "filename": "boehm-gc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9110a741e35c54e46c00662ddc420575376c5947/boehm-gc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9110a741e35c54e46c00662ddc420575376c5947/boehm-gc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FChangeLog?ref=9110a741e35c54e46c00662ddc420575376c5947", "patch": "@@ -1,3 +1,20 @@\n+2001-05-21  Bryce McKinlay  <bryce@waitaki.otago.ac.nz>\n+\n+\tImported version version 6.0alpha7.\n+\n+\t* README, README.Mac, README.OS2, README.QUICK, README.alpha,\n+\tREADME.amiga, README.debugging, README.dj, README.hp, README.linux,\n+\tREADME.rs6000, README.sgi, README.solaris2, README.uts,\n+\tREADME.win32, SCoptions.amiga, backptr.h, barrett_diagram,\n+\tdbg_mlc.h, gc.h, gc.man, gc_alloc.h, gc_cpp.h, gc_hdrs.h, gc_mark.h,\n+\tgc_priv.h, gc_private.h, gc_typed.h, gcconfig.h,\n+\thpux_irix_threads.c, makefile.depend, nursery.c,\n+\tsolaris_threads.h, test.c, test_cpp.cc, weakpointer.h, cord/README,\n+\tcord/SCOPTIONS.amiga, cord/SMakefile.amiga, cord/cord.h,\n+\tcord/ec.h, cord/gc.h, cord/private/cord_pos.h, include/backptr.h,\n+\tinclude/gc_copy_descr.h, include/gc_nursery.h: Remove obsolete/moved\n+\tfiles.\n+\n 2001-05-19  Hans Boehm  <hans_boehm@hp.com>\n \n \t* configure.host: Build with -fexceptions."}, {"sha": "d7674b3a3e9328fca2414b27e56ad9f646ee9efa", "filename": "boehm-gc/EMX_MAKEFILE", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9110a741e35c54e46c00662ddc420575376c5947/boehm-gc%2FEMX_MAKEFILE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9110a741e35c54e46c00662ddc420575376c5947/boehm-gc%2FEMX_MAKEFILE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FEMX_MAKEFILE?ref=9110a741e35c54e46c00662ddc420575376c5947", "patch": "@@ -77,7 +77,7 @@ $(OBJS) test.o: $(srcdir)/gc_priv.h $(srcdir)/gc_hdrs.h $(srcdir)/gc.h \\\n # options such as -DSILENT affects the size of GC_arrays,\n # invalidating all .o files that rely on gc_priv.h\n \n-mark.o typd_mlc.o finalize.o: $(srcdir)/gc_mark.h\n+mark.o typd_mlc.o finalize.o: $(srcdir)/include/gc_mark.h $(srcdir)/include/private/gc_pmark.h\n \n gc.a: $(OBJS)\n \t$(AR) ru gc.a $(OBJS)\n@@ -120,13 +120,13 @@ cord/de.exe: $(srcdir)/cord/de.c $(srcdir)/cord/cordbscs.o $(srcdir)/cord/cordxt\n \t$(CC) $(CFLAGS) -o cord/de.exe $(srcdir)/cord/de.c $(srcdir)/cord/cordbscs.o $(srcdir)/cord/cordxtra.o gc.a $(CURSES)\n \n clean: \n-\trm -f gc.a test.o gctest.exe output-local output-diff $(OBJS) \\\n+\trm -f gc.a tests/test.o gctest.exe output-local output-diff $(OBJS) \\\n \t      setjmp_test  mon.out gmon.out a.out core \\\n \t      $(CORD_OBJS) cord/cordtest.exe cord/de.exe\n \t-rm -f *~\n \n-gctest.exe: test.o gc.a\n-\t$(CC) $(CFLAGS) -o gctest.exe test.o gc.a\n+gctest.exe: tests/test.o gc.a\n+\t$(CC) $(CFLAGS) -o gctest.exe tests/test.o gc.a\n \n # If an optimized setjmp_test generates a segmentation fault,\n # odds are your compiler is broken.  Gctest may still work."}, {"sha": "70808973f20593c7b2fcb1dbc3cff116b0c347eb", "filename": "boehm-gc/Makefile.am", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9110a741e35c54e46c00662ddc420575376c5947/boehm-gc%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9110a741e35c54e46c00662ddc420575376c5947/boehm-gc%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FMakefile.am?ref=9110a741e35c54e46c00662ddc420575376c5947", "patch": "@@ -25,23 +25,22 @@ endif\n \n toolexeclib_LTLIBRARIES = $(target_all)\n EXTRA_LTLIBRARIES = libgcjgc.la\n-libgcjgc_la_SOURCES = allchblk.c alloc.c blacklst.c checksums.c\t\\\n-gcconfig.h dbg_mlc.c dyn_load.c finalize.c gc.h gc_alloc.h gc_cpp.h \\\n-gc_hdrs.h gc_mark.h gc_priv.h gc_private.h gc_typed.h gcj_mlc.c headers.c \\\n-hpux_irix_threads.c linux_threads.c malloc.c mallocx.c mark.c mark_rts.c \\\n-misc.c new_hblk.c obj_map.c os_dep.c pcr_interface.c ptr_chck.c\t\\\n-real_malloc.c reclaim.c solaris_pthreads.c solaris_threads.c \\\n-solaris_threads.h stubborn.c typd_mlc.c version.h weakpointer.h\n+libgcjgc_la_SOURCES = allchblk.c alloc.c blacklst.c checksums.c dbg_mlc.c \\\n+dyn_load.c finalize.c gc_dlopen.c gcj_mlc.c headers.c irix_threads.c \\\n+linux_threads.c malloc.c mallocx.c mark.c mark_rts.c misc.c new_hblk.c \\\n+obj_map.c os_dep.c pcr_interface.c ptr_chck.c real_malloc.c reclaim.c \\\n+solaris_pthreads.c solaris_threads.c specific.c stubborn.c typd_mlc.c`\n \n # Include THREADLIBS here to ensure that the correct versions of\n # linuxthread semaphore functions get linked:\n libgcjgc_la_LIBADD = @addobjs@ $(THREADLIBS)\n libgcjgc_la_DEPENDENCIES = @addobjs@\n libgcjgc_la_LDFLAGS = -version-info 1:1:0 -rpath $(toolexeclibdir)\n \n-EXTRA_libgcjgc_la_SOURCES = alpha_mach_dep.s mips_sgi_mach_dep.s \\\n-mips_ultrix_mach_dep.s rs6000_mach_dep.s sparc_mach_dep.s \\\n-sparc_sunos4_mach_dep.s mach_dep.c ecos.cc\n+EXTRA_libgcjgc_la_SOURCES = alpha_mach_dep.s hpux_test_and_clear.s \\\n+mips_sgi_mach_dep.s mips_ultrix_mach_dep.s powerpc_macosx_mach_dep.s \\\n+rs6000_mach_dep.s sparc_mach_dep.s sparc_netbsd_mach_dep.s \\\n+sparc_sunos4_mach_dep.s\n \n AM_CXXFLAGS = @BOEHM_GC_CFLAGS@\n AM_CFLAGS = @BOEHM_GC_CFLAGS@\n@@ -55,7 +54,8 @@ TESTS = gctest\n \n ## FIXME: relies on internal code generated by automake.\n all_objs = @addobjs@ $(libgcjgc_la_OBJECTS)\n-$(all_objs) : gcconfig.h gc_priv.h gc_hdrs.h gc.h gc_mark.h\n+$(all_objs) : include/private/gcconfig.h include/private/gc_priv.h \\\n+include/private/gc_hdrs.h include/gc.h include/gc_gcj.h include/gc_mark.h\n \n ## FIXME: we shouldn't have to do this, but automake forces us to.\n .s.lo:"}, {"sha": "9b1aeb3c92c66978e45b683755e76b5976eea8d7", "filename": "boehm-gc/Makefile.dist", "status": "modified", "additions": 205, "deletions": 99, "changes": 304, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9110a741e35c54e46c00662ddc420575376c5947/boehm-gc%2FMakefile.dist", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9110a741e35c54e46c00662ddc420575376c5947/boehm-gc%2FMakefile.dist", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FMakefile.dist?ref=9110a741e35c54e46c00662ddc420575376c5947", "patch": "@@ -1,6 +1,8 @@\n+# This is the original manually generated Makefile.  It may stil be used\n+# to build the collector.\n+#\n # Primary targets:\n # gc.a - builds basic library\n-# libgc.a - builds library for use with g++ \"-fgc-keyword\" extension\n # c++ - adds C++ interface to library\n # cords - adds cords (heavyweight strings) to library\n # test - prints porting information, then builds basic version of gc.a,\n@@ -9,47 +11,67 @@\n # cord/de - builds dumb editor based on cords.\n ABI_FLAG= \n CC=cc $(ABI_FLAG)\n-HOSTCC=$(CC)\n CXX=g++ $(ABI_FLAG)\n AS=as $(ABI_FLAG)\n #  The above doesn't work with gas, which doesn't run cpp.\n #  Define AS as `gcc -c -x assembler-with-cpp' instead.\n #  Under Irix 6, you will have to specify the ABI (-o32, -n32, or -64)\n #  if you use something other than the default ABI on your machine.\n \n-CFLAGS= -O -DATOMIC_UNCOLLECTABLE -DNO_SIGNALS -DNO_EXECUTE_PERMISSION -DALL_INTERIOR_POINTERS -DSILENT\n+# Redefining srcdir allows object code for the nonPCR version of the collector\n+# to be generated in different directories.\n+srcdir= .\n+VPATH= $(srcdir)\n+\n+CFLAGS= -O -I$(srcdir)/include -DATOMIC_UNCOLLECTABLE -DNO_SIGNALS -DNO_EXECUTE_PERMISSION -DSILENT -DALL_INTERIOR_POINTERS\n+\n+# To build the parallel collector on Linux, add to the above:\n+# -DGC_LINUX_THREADS -DPARALLEL_MARK -DTHREAD_LOCAL_ALLOC\n+# To build the parallel collector n a static library on HP/UX, add to the above:\n+# -DGC_HPUX_THREADS -DPARALLEL_MARK -DTHREAD_LOCAL_ALLOC -DUSE_HPUX_TLS -D_POSIX_C_SOURCE=199506L\n+\n+# HOSTCC and HOSTCFLAGS are used to build executables that will be run as\n+# part of the build process, i.e. on the build machine.  These will usually\n+# be the same as CC and CFLAGS, except in a cross-compilation environment.\n+# Note that HOSTCFLAGS should include any -D flags that affect thread support.\n+HOSTCC=$(CC)\n+HOSTCFLAGS=$(CFLAGS)\n \n # For dynamic library builds, it may be necessary to add flags to generate\n # PIC code, e.g. -fPIC on Linux.\n \n # Setjmp_test may yield overly optimistic results when compiled\n # without optimization.\n+\n+# These define arguments influence the collector configuration:\n # -DSILENT disables statistics printing, and improves performance.\n # -DFIND_LEAK causes GC_find_leak to be initially set.\n #   This causes the collector to assume that all inaccessible\n #   objects should have been explicitly deallocated, and reports exceptions.\n #   Finalization and the test program are not usable in this mode.\n-# -DSOLARIS_THREADS enables support for Solaris (thr_) threads.\n-#   (Clients should also define SOLARIS_THREADS and then include\n+# -DGC_SOLARIS_THREADS enables support for Solaris (thr_) threads.\n+#   (Clients should also define GC_SOLARIS_THREADS and then include\n #   gc.h before performing thr_ or dl* or GC_ operations.)\n #   Must also define -D_REENTRANT.\n-# -D_SOLARIS_PTHREADS enables support for Solaris pthreads.\n+# -DGC_SOLARIS_PTHREADS enables support for Solaris pthreads.\n #   Define SOLARIS_THREADS as well.\n-# -DIRIX_THREADS enables support for Irix pthreads.  See README.irix.\n-# -DHPUX_THREADS enables support for HP/UX 11 pthreads.\n-#  Also requires -D_REENTRANT. See README.hp.\n-# -DLINUX_THREADS enables support for Xavier Leroy's Linux threads.\n+# -DGC_IRIX_THREADS enables support for Irix pthreads.  See README.irix.\n+# -DGC_HPUX_THREADS enables support for HP/UX 11 pthreads.\n+#   Also requires -D_REENTRANT or -D_POSIX_C_SOURCE=199506L. See README.hp.\n+# -DGC_LINUX_THREADS enables support for Xavier Leroy's Linux threads.\n #   see README.linux.  -D_REENTRANT may also be required.\n # -DALL_INTERIOR_POINTERS allows all pointers to the interior\n #   of objects to be recognized.  (See gc_priv.h for consequences.)\n+#   Alternatively, GC_all_interior_pointers can be set at process\n+#   initialization time.\n # -DSMALL_CONFIG tries to tune the collector for small heap sizes,\n #   usually causing it to use less space in such situations.\n #   Incremental collection no longer works in this case.\n # -DLARGE_CONFIG tunes the collector for unusually large heaps.\n #   Necessary for heaps larger than about 500 MB on most machines.\n #   Recommended for heaps larger than about 64 MB.\n-# -DDONT_ADD_BYTE_AT_END is meaningful only with\n-#   -DALL_INTERIOR_POINTERS.  Normally -DALL_INTERIOR_POINTERS\n+# -DDONT_ADD_BYTE_AT_END is meaningful only with -DALL_INTERIOR_POINTERS or\n+#   GC_all_interior_pointers = 1.  Normally -DALL_INTERIOR_POINTERS\n #   causes all objects to be padded so that pointers just past the end of\n #   an object can be recognized.  This can be expensive.  (The padding\n #   is normally more than one byte due to alignment constraints.)\n@@ -73,12 +95,19 @@ CFLAGS= -O -DATOMIC_UNCOLLECTABLE -DNO_SIGNALS -DNO_EXECUTE_PERMISSION -DALL_INT\n # -DREDIRECT_MALLOC=X causes malloc, realloc, and free to be defined\n #   as aliases for X, GC_realloc, and GC_free, respectively.\n #   Calloc is redefined in terms of the new malloc.  X should\n-#   be either GC_malloc or GC_malloc_uncollectable.\n+#   be either GC_malloc or GC_malloc_uncollectable, or\n+#   GC_debug_malloc_replacement.  (The latter invokes GC_debug_malloc\n+#   with dummy source location information, but still results in\n+#   properly remembered call stacks on Linux/X86 and Solaris/SPARC.)\n #   The former is occasionally useful for working around leaks in code\n #   you don't want to (or can't) look at.  It may not work for\n #   existing code, but it often does.  Neither works on all platforms,\n #   since some ports use malloc or calloc to obtain system memory.\n #   (Probably works for UNIX, and win32.)\n+# -DREDIRECT_REALLOC=X causes GC_realloc to be redirected to X.\n+#   The canonical use is -DREDIRECT_REALLOC=GC_debug_realloc_replacement,\n+#   together with -DREDIRECT_MALLOC=GC_debug_malloc_replacement to\n+#   generate leak reports with call stacks for both malloc and realloc.\n # -DIGNORE_FREE turns calls to free into a noop.  Only useful with\n #   -DREDIRECT_MALLOC.\n # -DNO_DEBUGGING removes GC_dump and the debugging routines it calls.\n@@ -119,13 +148,32 @@ CFLAGS= -O -DATOMIC_UNCOLLECTABLE -DNO_SIGNALS -DNO_EXECUTE_PERMISSION -DALL_INT\n #   for objects allocated with the debugging allocator.  If all objects\n #   through GC_MALLOC with GC_DEBUG defined, this allows the client\n #   to determine how particular or randomly chosen objects are reachable\n-#   for debugging/profiling purposes.  The backptr.h interface is\n+#   for debugging/profiling purposes.  The gc_backptr.h interface is\n #   implemented only if this is defined.\n # -DGC_ASSERTIONS Enable some internal GC assertion checking.  Currently\n #   this facility is only used in a few places.  It is intended primarily\n #   for debugging of the garbage collector itself, but could also\n+# -DDBG_HDRS_ALL Make sure that all objects have debug headers.  Increases\n+#   the reliability (from 99.9999% to 100%) of some of the debugging\n+#   code (especially KEEP_BACK_PTRS).  Makes -DSHORT_DBG_HDRS possible.\n+#   Assumes that all client allocation is done through debugging\n+#   allocators.\n+# -DSHORT_DBG_HDRS Assume that all objects have debug headers.  Shorten\n+#   the headers to minimize object size, at the expense of checking for\n+#   writes past the end of an object.  This is intended for environments\n+#   in which most client code is written in a \"safe\" language, such as\n+#   Scheme or Java.  Assumes that all client allocation is done using\n+#   the GC_debug_ functions, or through the macros that expand to these,\n+#   or by redirecting malloc to GC_debug_malloc_replacement.\n+#   (Also eliminates the field for the requested object size.)\n #   occasionally be useful for debugging of client code.  Slows down the\n #   collector somewhat, but not drastically.\n+# -DSAVE_CALL_COUNT=<n> Set the number of call frames saved with objects\n+#   allocated through the debugging interface.  Affects the amount of\n+#   information generated in leak reports.  Only matters on platforms\n+#   on which we can quickly generate call stacks, currently Linux/(X86 & SPARC)\n+#   and Solaris/SPARC.  Turns on call chain saving on X86.  On X86, client\n+#   code should NOT be compiled with -fomit-frame-pointer.\n # -DCHECKSUMS reports on erroneously clear dirty bits, and unexpectedly\n #   altered stubborn objects, at substantial performance cost.\n #   Use only for debugging of the incremental collector.\n@@ -143,66 +191,80 @@ CFLAGS= -O -DATOMIC_UNCOLLECTABLE -DNO_SIGNALS -DNO_EXECUTE_PERMISSION -DALL_INT\n # -DUSE_3DNOW_PREFETCH causes the collector to issue AMD 3DNow style\n #   prefetch instructions.  Same restrictions as USE_I686_PREFETCH.\n #   UNTESTED!!\n-# -DUSE_LD_WRAP in combination with the gld flags listed in README.linux\n+# -DGC_USE_LD_WRAP in combination with the gld flags listed in README.linux\n #   causes the collector some system and pthread calls in a more transparent\n #   fashion than the usual macro-based approach.  Requires GNU ld, and\n #   currently probably works only with Linux.\n+# -DTHREAD_LOCAL_ALLOC defines GC_local_malloc(), GC_local_malloc_atomic()\n+#   and GC_local_gcj_malloc().  Needed for gc_gcj.h interface.  These allocate\n+#   in a way that usually does not involve acquisition of a global lock.\n+#   Currently requires -DGC_LINUX_THREADS, but should be easy to port to\n+#   other pthreads environments.  Recommended for multiprocessors.\n+# -DPARALLEL_MARK allows the marker to run in multiple threads.  Recommended\n+#   for multiprocessors.  Currently requires Linux on X86 or IA64, though\n+#   support for other Posix platforms should be fairly easy to add,\n+#   if the thread implementation is otherwise supported.\n+# -DNO_GETENV prevents the collector from looking at environment variables.\n+#   These may otherwise alter its configuration, or turn off GC altogether.\n+#   I don't know of a reason to disable this, except possibly if the\n+#   resulting process runs as a privileged user?\n+# -DSTUBBORN_ALLOC allows allocation of \"hard to change\" objects, and thus\n+#   makes incremental collection easier.  Was enabled by default until 6.0.\n+#   Rarely used, to my knowledge.\n #\n \n-\n-LIBGC_CFLAGS= -O -DNO_SIGNALS -DSILENT \\\n-    -DREDIRECT_MALLOC=GC_malloc_uncollectable \\\n-    -DDONT_ADD_BYTE_AT_END -DALL_INTERIOR_POINTERS\n-#   Flags for building libgc.a -- the last two are required.\n-\n CXXFLAGS= $(CFLAGS) \n AR= ar\n RANLIB= ranlib\n \n \n-# Redefining srcdir allows object code for the nonPCR version of the collector\n-# to be generated in different directories.  In this case, the destination directory\n-# should contain a copy of the original include directory.\n-srcdir = .\n-VPATH = $(srcdir)\n-\n-OBJS= alloc.o reclaim.o allchblk.o misc.o mach_dep.o os_dep.o mark_rts.o headers.o mark.o obj_map.o blacklst.o finalize.o new_hblk.o dbg_mlc.o malloc.o stubborn.o checksums.o solaris_threads.o hpux_irix_threads.o linux_threads.o typd_mlc.o ptr_chck.o mallocx.o solaris_pthreads.o gcj_mlc.o\n+OBJS= alloc.o reclaim.o allchblk.o misc.o mach_dep.o os_dep.o mark_rts.o headers.o mark.o obj_map.o blacklst.o finalize.o new_hblk.o dbg_mlc.o malloc.o stubborn.o checksums.o solaris_threads.o irix_threads.o linux_threads.o typd_mlc.o ptr_chck.o mallocx.o solaris_pthreads.o gcj_mlc.o specific.o gc_dlopen.o\n \n-CSRCS= reclaim.c allchblk.c misc.c alloc.c mach_dep.c os_dep.c mark_rts.c headers.c mark.c obj_map.c pcr_interface.c blacklst.c finalize.c new_hblk.c real_malloc.c dyn_load.c dbg_mlc.c malloc.c stubborn.c checksums.c solaris_threads.c hpux_irix_threads.c linux_threads.c typd_mlc.c ptr_chck.c mallocx.c solaris_pthreads.c gcj_mlc.c\n+CSRCS= reclaim.c allchblk.c misc.c alloc.c mach_dep.c os_dep.c mark_rts.c headers.c mark.c obj_map.c pcr_interface.c blacklst.c finalize.c new_hblk.c real_malloc.c dyn_load.c dbg_mlc.c malloc.c stubborn.c checksums.c solaris_threads.c irix_threads.c linux_threads.c typd_mlc.c ptr_chck.c mallocx.c solaris_pthreads.c gcj_mlc.c specific.c gc_dlopen.c\n \n-CORD_SRCS=  cord/cordbscs.c cord/cordxtra.c cord/cordprnt.c cord/de.c cord/cordtest.c cord/cord.h cord/ec.h cord/private/cord_pos.h cord/de_win.c cord/de_win.h cord/de_cmds.h cord/de_win.ICO cord/de_win.RC cord/SCOPTIONS.amiga cord/SMakefile.amiga\n+CORD_SRCS=  cord/cordbscs.c cord/cordxtra.c cord/cordprnt.c cord/de.c cord/cordtest.c include/cord.h include/ec.h include/private/cord_pos.h cord/de_win.c cord/de_win.h cord/de_cmds.h cord/de_win.ICO cord/de_win.RC\n \n CORD_OBJS=  cord/cordbscs.o cord/cordxtra.o cord/cordprnt.o\n \n SRCS= $(CSRCS) mips_sgi_mach_dep.s rs6000_mach_dep.s alpha_mach_dep.s \\\n-    sparc_mach_dep.s gc.h gc_typed.h gc_hdrs.h gc_priv.h gc_private.h \\\n-    gcconfig.h gc_mark.h include/gc_inl.h include/gc_inline.h gc.man \\\n-    threadlibs.c if_mach.c if_not_there.c gc_cpp.cc gc_cpp.h weakpointer.h \\\n-    gcc_support.c mips_ultrix_mach_dep.s include/gc_alloc.h gc_alloc.h \\\n+    sparc_mach_dep.s include/gc.h include/gc_typed.h \\\n+    include/private/gc_hdrs.h include/private/gc_priv.h \\\n+    include/private/gcconfig.h include/private/gc_pmark.h \\\n+    include/gc_inl.h include/gc_inline.h include/gc_mark.h \\\n+    threadlibs.c if_mach.c if_not_there.c gc_cpp.cc include/gc_cpp.h \\\n+    include/weakpointer.h include/private/gc_locks.h \\\n+    gcc_support.c mips_ultrix_mach_dep.s include/gc_alloc.h \\\n     include/new_gc_alloc.h include/javaxfc.h sparc_sunos4_mach_dep.s \\\n-    solaris_threads.h backptr.h hpux_test_and_clear.s include/gc_gcj.h \\\n-    dbg_mlc.h $(CORD_SRCS)\n-\n+    sparc_netbsd_mach_dep.s \\\n+    include/private/solaris_threads.h include/gc_backptr.h \\\n+    hpux_test_and_clear.s include/gc_gcj.h \\\n+    include/gc_local_alloc.h include/private/dbg_mlc.h \\\n+    include/private/specific.h powerpc_macosx_mach_dep.s \\\n+    include/leak_detector.h include/gc_amiga_redirects.h \\\n+    include/gc_pthread_redirects.h $(CORD_SRCS)\n+\n+DOC_FILES= README.QUICK doc/README.Mac doc/README.MacOSX doc/README.OS2 \\\n+\tdoc/README.amiga doc/README.cords doc/README.debugging \\\n+\tdoc/README.dj doc/README.hp doc/README.linux doc/README.rs6000 \\\n+\tdoc/README.sgi doc/README.solaris2 doc/README.uts \\\n+\tdoc/README.win32 doc/barrett_diagram doc/README \\\n+        doc/README.contributors doc/README.changes doc/gc.man \\\n+\tdoc/README.environment\n+\n+TESTS= tests/test.c tests/test_cpp.cc tests/trace_test.c \\\n+\ttests/leak_test.c tests/thread_leak_test.c\n OTHER_FILES= Makefile PCR-Makefile OS2_MAKEFILE NT_MAKEFILE BCC_MAKEFILE \\\n-           README test.c test_cpp.cc setjmp_t.c SMakefile.amiga \\\n-           SCoptions.amiga README.amiga README.win32 cord/README \\\n-           cord/gc.h include/gc.h include/gc_typed.h include/cord.h \\\n-           include/ec.h include/private/cord_pos.h include/private/gcconfig.h \\\n-           include/private/gc_hdrs.h include/private/gc_priv.h \\\n-\t   include/gc_cpp.h README.rs6000 include/backptr.h \\\n-           include/weakpointer.h README.QUICK callprocs pc_excludes \\\n-           barrett_diagram README.OS2 README.Mac MacProjects.sit.hqx \\\n-           MacOS.c EMX_MAKEFILE makefile.depend README.debugging \\\n-           include/gc_cpp.h Mac_files/datastart.c Mac_files/dataend.c \\\n+           setjmp_t.c SMakefile.amiga configure.in Makefile.am \\\n+           callprocs pc_excludes \\\n+           MacProjects.sit.hqx MacOS.c EMX_MAKEFILE \\\n+           Mac_files/datastart.c Mac_files/dataend.c \\\n            Mac_files/MacOS_config.h Mac_files/MacOS_Test_config.h \\\n-           add_gc_prefix.c README.solaris2 README.sgi README.hp README.uts \\\n-\t   win32_threads.c NT_THREADS_MAKEFILE gc.mak README.dj Makefile.dj \\\n-\t   README.alpha README.linux version.h Makefile.DLLs \\\n-\t   WCC_MAKEFILE nursery.c include/gc_nursery.h include/gc_copy_descr.h \\\n-\t   include/leak_detector.h\n+           add_gc_prefix.c gc_cpp.cpp \\\n+\t   win32_threads.c NT_THREADS_MAKEFILE gc.mak Makefile.dj \\\n+\t   version.h Makefile.DLLs WCC_MAKEFILE AmigaOS.c $(TESTS)\n \n-CORD_INCLUDE_FILES= $(srcdir)/gc.h $(srcdir)/cord/cord.h $(srcdir)/cord/ec.h \\\n-           $(srcdir)/cord/private/cord_pos.h\n+CORD_INCLUDE_FILES= $(srcdir)/include/gc.h $(srcdir)/include/cord.h \\\n+\t$(srcdir)/include/ec.h $(srcdir)/include/private/cord_pos.h\n \n UTILS= if_mach if_not_there threadlibs\n \n@@ -214,25 +276,55 @@ CURSES= -lcurses -ltermlib\n # the SHELL environment variable.\n SHELL= /bin/sh\n \n-SPECIALCFLAGS = \n+SPECIALCFLAGS = -I$(srcdir)/include\n # Alternative flags to the C compiler for mach_dep.c.\n # Mach_dep.c often doesn't like optimization, and it's\n # not time-critical anyway.\n # Set SPECIALCFLAGS to -q nodirect_code on Encore.\n \n all: gc.a gctest\n \n-pcr: PCR-Makefile gc_private.h gc_hdrs.h gc.h gcconfig.h mach_dep.o $(SRCS)\n-\tmake -f PCR-Makefile depend\n-\tmake -f PCR-Makefile\n-\n-$(OBJS) test.o dyn_load.o dyn_load_sunos53.o: $(srcdir)/gc_priv.h $(srcdir)/gc_hdrs.h $(srcdir)/gc.h \\\n-    $(srcdir)/gcconfig.h $(srcdir)/gc_typed.h Makefile\n+BSD-pkg-all: bsd-libgc.a\n+\n+bsd-libgc.a:\n+\t$(MAKE) CFLAGS=\"$(CFLAGS)\" clean c++-t\n+\tmv gc.a bsd-libgc.a\n+\n+BSD-pkg-install: BSD-pkg-all\n+\t${CP} bsd-libgc.a libgc.a\n+\t${INSTALL_DATA} libgc.a ${PREFIX}/lib\n+\t${INSTALL_DATA} gc.h gc_cpp.h ${PREFIX}/include\n+\n+pcr: PCR-Makefile include/private/gc_private.h include/private/gc_hdrs.h \\\n+include/private/gc_locks.h include/gc.h include/private/gcconfig.h \\\n+mach_dep.o $(SRCS)\n+\t$(MAKE) -f PCR-Makefile depend\n+\t$(MAKE) -f PCR-Makefile\n+\n+$(OBJS) tests/test.o dyn_load.o dyn_load_sunos53.o: \\\n+    $(srcdir)/include/private/gc_priv.h \\\n+    $(srcdir)/include/private/gc_hdrs.h $(srcdir)/include/private/gc_locks.h \\\n+    $(srcdir)/include/gc.h \\\n+    $(srcdir)/include/private/gcconfig.h $(srcdir)/include/gc_typed.h \\\n+    Makefile\n # The dependency on Makefile is needed.  Changing\n # options such as -DSILENT affects the size of GC_arrays,\n # invalidating all .o files that rely on gc_priv.h\n \n-mark.o typd_mlc.o finalize.o: $(srcdir)/gc_mark.h\n+mark.o typd_mlc.o finalize.o ptr_chck.o: $(srcdir)/include/gc_mark.h $(srcdir)/include/private/gc_pmark.h\n+\n+specific.o linux_threads.o: $(srcdir)/include/private/specific.h\n+\n+solaris_threads.o solaris_pthreads.o: $(srcdir)/include/private/solaris_threads.h\n+\n+dbg_mlc.o gcj_mlc.o: $(srcdir)/include/private/dbg_mlc.h\n+\n+tests/test.o: tests $(srcdir)/tests/test.c\n+\t$(CC) $(CFLAGS) -c $(srcdir)/tests/test.c\n+\tmv test.o tests/test.o\n+\n+tests:\n+\tmkdir tests\n \n base_lib gc.a: $(OBJS) dyn_load.o $(UTILS)\n \techo > base_lib\n@@ -254,16 +346,22 @@ cords: $(CORD_OBJS) cord/cordtest $(UTILS)\n \t./if_not_there dont_ar_3 $(AR) ru gc.a $(CORD_OBJS)\n \t./if_not_there dont_ar_3 $(RANLIB) gc.a || cat /dev/null\n \n-gc_cpp.o: $(srcdir)/gc_cpp.cc $(srcdir)/gc_cpp.h $(srcdir)/gc.h Makefile\n+gc_cpp.o: $(srcdir)/gc_cpp.cc $(srcdir)/include/gc_cpp.h $(srcdir)/include/gc.h Makefile\n \t$(CXX) -c $(CXXFLAGS) $(srcdir)/gc_cpp.cc\n \n-test_cpp: $(srcdir)/test_cpp.cc $(srcdir)/gc_cpp.h gc_cpp.o $(srcdir)/gc.h \\\n+test_cpp: $(srcdir)/tests/test_cpp.cc $(srcdir)/include/gc_cpp.h gc_cpp.o $(srcdir)/include/gc.h \\\n base_lib $(UTILS)\n \trm -f test_cpp\n-\t./if_mach HP_PA HPUX $(CXX) $(CXXFLAGS) -o test_cpp $(srcdir)/test_cpp.cc gc_cpp.o gc.a -ldld `./threadlibs`\n-\t./if_not_there test_cpp $(CXX) $(CXXFLAGS) -o test_cpp $(srcdir)/test_cpp.cc gc_cpp.o gc.a `./threadlibs`\n+\t./if_mach HP_PA HPUX $(CXX) $(CXXFLAGS) -o test_cpp $(srcdir)/tests/test_cpp.cc gc_cpp.o gc.a -ldld `./threadlibs`\n+\t./if_not_there test_cpp $(CXX) $(CXXFLAGS) -o test_cpp $(srcdir)/tests/test_cpp.cc gc_cpp.o gc.a `./threadlibs`\n+\n+c++-t: c++\n+\t./test_cpp 1\n \n-c++: gc_cpp.o $(srcdir)/gc_cpp.h test_cpp\n+c++-nt: c++\n+\t@echo \"Use ./test_cpp 1 to test the leak library\"\n+\n+c++: gc_cpp.o $(srcdir)/include/gc_cpp.h test_cpp\n \trm -f dont_ar_4\n \t./if_mach SPARC SUNOS5 touch dont_ar_4\n \t./if_mach SPARC SUNOS5 $(AR) rus gc.a gc_cpp.o\n@@ -294,7 +392,7 @@ libirixgc.so: $(OBJS) dyn_load.o\n \n # Linux shared library version of the collector\n liblinuxgc.so: $(OBJS) dyn_load.o\n-\tgcc -shared -o liblinuxgc.so $(OBJS) dyn_load.o -lo\n+\tgcc -shared -o liblinuxgc.so $(OBJS) dyn_load.o\n \tln liblinuxgc.so libgc.so\n \n # Alternative Linux rule.  This is preferable, but is likely to break the\n@@ -310,21 +408,21 @@ liblinuxgc.so: $(OBJS) dyn_load.o\n # \tgcc -shared -Wl,-soname=libgc.so.0 -o libgc.so.0 $(LIBOBJS) dyn_load.lo\n #\ttouch liblinuxgc.so\n \n-mach_dep.o: $(srcdir)/mach_dep.c $(srcdir)/mips_sgi_mach_dep.s $(srcdir)/mips_ultrix_mach_dep.s $(srcdir)/rs6000_mach_dep.s $(UTILS)\n+mach_dep.o: $(srcdir)/mach_dep.c $(srcdir)/mips_sgi_mach_dep.s $(srcdir)/mips_ultrix_mach_dep.s \\\n+            $(srcdir)/rs6000_mach_dep.s $(srcdir)/powerpc_macosx_mach_dep.s $(UTILS)\n \trm -f mach_dep.o\n \t./if_mach MIPS IRIX5 $(AS) -o mach_dep.o $(srcdir)/mips_sgi_mach_dep.s\n \t./if_mach MIPS RISCOS $(AS) -o mach_dep.o $(srcdir)/mips_ultrix_mach_dep.s\n \t./if_mach MIPS ULTRIX $(AS) -o mach_dep.o $(srcdir)/mips_ultrix_mach_dep.s\n \t./if_mach RS6000 \"\" $(AS) -o mach_dep.o $(srcdir)/rs6000_mach_dep.s\n+\t./if_mach POWERPC MACOSX $(AS) -o mach_dep.o $(srcdir)/powerpc_macosx_mach_dep.s\n #\t./if_mach ALPHA \"\" $(AS) -o mach_dep.o $(srcdir)/alpha_mach_dep.s\n #\talpha_mach_dep.s assumes that pointers are not saved in fp registers.\n #\tGcc on a 21264 can spill pointers to fp registers.  Oops.\n \t./if_mach SPARC SUNOS5 $(AS) -o mach_dep.o $(srcdir)/sparc_mach_dep.s\n \t./if_mach SPARC SUNOS4 $(AS) -o mach_dep.o $(srcdir)/sparc_sunos4_mach_dep.s\n \t./if_mach SPARC OPENBSD $(AS) -o mach_dep.o $(srcdir)/sparc_sunos4_mach_dep.s\n-\t./if_mach HP_PA HPUX $(AS) -o hpux_test_and_clear.o $(srcdir)/hpux_test_and_clear.s\n-\t./if_mach HP_PA HPUX $(CC) -c -o md_tmp.o $(SPECIALCFLAGS) $(srcdir)/mach_dep.c\n-\t./if_mach HP_PA HPUX ld -r -o mach_dep.o md_tmp.o hpux_test_and_clear.o\n+\t./if_mach SPARC NETBSD $(AS) -o mach_dep.o $(srcdir)/sparc_netbsd_mach_dep.s\n \t./if_not_there mach_dep.o $(CC) -c $(SPECIALCFLAGS) $(srcdir)/mach_dep.c\n \n mark_rts.o: $(srcdir)/mark_rts.c $(UTILS)\n@@ -336,61 +434,67 @@ mark_rts.o: $(srcdir)/mark_rts.c $(UTILS)\n \n alloc.o: version.h\n \n-cord/cordbscs.o: $(srcdir)/cord/cordbscs.c $(CORD_INCLUDE_FILES)\n+cord:\n+\tmkdir cord\n+\n+cord/cordbscs.o: cord $(srcdir)/cord/cordbscs.c $(CORD_INCLUDE_FILES)\n \t$(CC) $(CFLAGS) -c -I$(srcdir) $(srcdir)/cord/cordbscs.c\n \tmv cordbscs.o cord/cordbscs.o\n #  not all compilers understand -o filename\n \n-cord/cordxtra.o: $(srcdir)/cord/cordxtra.c $(CORD_INCLUDE_FILES)\n+cord/cordxtra.o: cord $(srcdir)/cord/cordxtra.c $(CORD_INCLUDE_FILES)\n \t$(CC) $(CFLAGS) -c -I$(srcdir) $(srcdir)/cord/cordxtra.c\n \tmv cordxtra.o cord/cordxtra.o\n \n-cord/cordprnt.o: $(srcdir)/cord/cordprnt.c $(CORD_INCLUDE_FILES)\n+cord/cordprnt.o: cord $(srcdir)/cord/cordprnt.c $(CORD_INCLUDE_FILES)\n \t$(CC) $(CFLAGS) -c -I$(srcdir) $(srcdir)/cord/cordprnt.c\n \tmv cordprnt.o cord/cordprnt.o\n \n cord/cordtest: $(srcdir)/cord/cordtest.c $(CORD_OBJS) gc.a $(UTILS)\n \trm -f cord/cordtest\n \t./if_mach SPARC DRSNX $(CC) $(CFLAGS) -o cord/cordtest $(srcdir)/cord/cordtest.c $(CORD_OBJS) gc.a -lucb\n \t./if_mach HP_PA HPUX $(CC) $(CFLAGS) -o cord/cordtest $(srcdir)/cord/cordtest.c $(CORD_OBJS) gc.a -ldld `./threadlibs`\n+\t./if_mach M68K AMIGA $(CC) $(CFLAGS) -UGC_AMIGA_MAKINGLIB -o cord/cordtest $(srcdir)/cord/cordtest.c $(CORD_OBJS) gc.a `./threadlibs`\n \t./if_not_there cord/cordtest $(CC) $(CFLAGS) -o cord/cordtest $(srcdir)/cord/cordtest.c $(CORD_OBJS) gc.a `./threadlibs`\n \n cord/de: $(srcdir)/cord/de.c cord/cordbscs.o cord/cordxtra.o gc.a $(UTILS)\n \trm -f cord/de\n \t./if_mach SPARC DRSNX $(CC) $(CFLAGS) -o cord/de $(srcdir)/cord/de.c cord/cordbscs.o cord/cordxtra.o gc.a $(CURSES) -lucb `./threadlibs`\n \t./if_mach HP_PA HPUX $(CC) $(CFLAGS) -o cord/de $(srcdir)/cord/de.c cord/cordbscs.o cord/cordxtra.o gc.a $(CURSES) -ldld `./threadlibs`\n \t./if_mach RS6000 \"\" $(CC) $(CFLAGS) -o cord/de $(srcdir)/cord/de.c cord/cordbscs.o cord/cordxtra.o gc.a -lcurses\n+\t./if_mach POWERPC MACOSX $(CC) $(CFLAGS) -o cord/de $(srcdir)/cord/de.c cord/cordbscs.o cord/cordxtra.o gc.a\n \t./if_mach I386 LINUX $(CC) $(CFLAGS) -o cord/de $(srcdir)/cord/de.c cord/cordbscs.o cord/cordxtra.o gc.a -lcurses `./threadlibs`\n \t./if_mach ALPHA LINUX $(CC) $(CFLAGS) -o cord/de $(srcdir)/cord/de.c cord/cordbscs.o cord/cordxtra.o gc.a -lcurses `./threadlibs`\n \t./if_mach IA64 LINUX $(CC) $(CFLAGS) -o cord/de $(srcdir)/cord/de.c cord/cordbscs.o cord/cordxtra.o gc.a -lcurses `./threadlibs`\n-\t./if_mach M68K AMIGA $(CC) $(CFLAGS) -o cord/de $(srcdir)/cord/de.c cord/cordbscs.o cord/cordxtra.o gc.a -lcurses\n+\t./if_mach M68K AMIGA $(CC) $(CFLAGS) -UGC_AMIGA_MAKINGLIB -o cord/de $(srcdir)/cord/de.c cord/cordbscs.o cord/cordxtra.o gc.a -lcurses\n \t./if_not_there cord/de $(CC) $(CFLAGS) -o cord/de $(srcdir)/cord/de.c cord/cordbscs.o cord/cordxtra.o gc.a $(CURSES) `./threadlibs`\n \n-if_mach: $(srcdir)/if_mach.c $(srcdir)/gcconfig.h\n-\t$(HOSTCC) $(CFLAGS) -o if_mach $(srcdir)/if_mach.c\n+if_mach: $(srcdir)/if_mach.c $(srcdir)/include/private/gcconfig.h\n+\t$(HOSTCC) $(HOSTCFLAGS) -o if_mach $(srcdir)/if_mach.c\n \n-threadlibs: $(srcdir)/threadlibs.c $(srcdir)/gcconfig.h Makefile\n-\t$(HOSTCC) $(CFLAGS) -o threadlibs $(srcdir)/threadlibs.c\n+threadlibs: $(srcdir)/threadlibs.c $(srcdir)/include/private/gcconfig.h Makefile\n+\t$(HOSTCC) $(HOSTCFLAGS) -o threadlibs $(srcdir)/threadlibs.c\n \n if_not_there: $(srcdir)/if_not_there.c\n-\t$(HOSTCC) $(CFLAGS) -o if_not_there $(srcdir)/if_not_there.c\n+\t$(HOSTCC) $(HOSTCFLAGS) -o if_not_there $(srcdir)/if_not_there.c\n \n clean: \n-\trm -f gc.a *.o gctest gctest_dyn_link test_cpp \\\n+\trm -f gc.a *.o *.exe tests/*.o gctest gctest_dyn_link test_cpp \\\n \t      setjmp_test  mon.out gmon.out a.out core if_not_there if_mach \\\n \t      threadlibs $(CORD_OBJS) cord/cordtest cord/de\n \t-rm -f *~\n \n-gctest: test.o gc.a $(UTILS)\n+gctest: tests/test.o gc.a $(UTILS)\n \trm -f gctest\n-\t./if_mach SPARC DRSNX $(CC) $(CFLAGS) -o gctest  test.o gc.a -lucb\n-\t./if_mach HP_PA HPUX $(CC) $(CFLAGS) -o gctest  test.o gc.a -ldld `./threadlibs`\n-\t./if_not_there gctest $(CC) $(CFLAGS) -o gctest test.o gc.a `./threadlibs`\n+\t./if_mach SPARC DRSNX $(CC) $(CFLAGS) -o gctest  tests/test.o gc.a -lucb\n+\t./if_mach HP_PA HPUX $(CC) $(CFLAGS) -o gctest  tests/test.o gc.a -ldld `./threadlibs`\n+\t./if_mach M68K AMIGA $(CC) $(CFLAGS) -UGC_AMIGA_MAKINGLIB -o gctest  tests/test.o gc.a `./threadlibs`\n+\t./if_not_there gctest $(CC) $(CFLAGS) -o gctest tests/test.o gc.a `./threadlibs`\n \n # If an optimized setjmp_test generates a segmentation fault,\n # odds are your compiler is broken.  Gctest may still work.\n # Try compiling setjmp_t.c unoptimized.\n-setjmp_test: $(srcdir)/setjmp_t.c $(srcdir)/gc.h $(UTILS)\n+setjmp_test: $(srcdir)/setjmp_t.c $(srcdir)/include/gc.h $(UTILS)\n \t$(CC) $(CFLAGS) -o setjmp_test $(srcdir)/setjmp_t.c\n \n test:  KandRtest cord/cordtest\n@@ -404,8 +508,8 @@ KandRtest: setjmp_test gctest\n add_gc_prefix: add_gc_prefix.c\n \t$(CC) -o add_gc_prefix $(srcdir)/add_gc_prefix.c\n \n-gc.tar: $(SRCS) $(OTHER_FILES) add_gc_prefix\n-\t./add_gc_prefix $(SRCS) $(OTHER_FILES) > /tmp/gc.tar-files\n+gc.tar: $(SRCS) $(DOC_FILES) $(OTHER_FILES) add_gc_prefix\n+\t./add_gc_prefix $(SRCS) $(DOC_FILES) $(OTHER_FILES) > /tmp/gc.tar-files\n \ttar cvfh gc.tar `cat /tmp/gc.tar-files`\n \n pc_gc.tar: $(SRCS) $(OTHER_FILES)\n@@ -432,21 +536,23 @@ gc.tar.Z: gc.tar\n gc.tar.gz: gc.tar\n \tgzip gc.tar\n \n-lint: $(CSRCS) test.c\n-\tlint -DLINT $(CSRCS) test.c | egrep -v \"possible pointer alignment problem|abort|exit|sbrk|mprotect|syscall|change in ANSI|improper alignment\"\n+lint: $(CSRCS) tests/test.c\n+\tlint -DLINT $(CSRCS) tests/test.c | egrep -v \"possible pointer alignment problem|abort|exit|sbrk|mprotect|syscall|change in ANSI|improper alignment\"\n \n # BTL: added to test shared library version of collector.\n # Currently works only under SunOS5.  Requires GC_INIT call from statically\n # loaded client code.\n ABSDIR = `pwd`\n-gctest_dyn_link: test.o libgc.so\n-\t$(CC) -L$(ABSDIR) -R$(ABSDIR) -o gctest_dyn_link test.o -lgc -ldl -lthread\n+gctest_dyn_link: tests/test.o libgc.so\n+\t$(CC) -L$(ABSDIR) -R$(ABSDIR) -o gctest_dyn_link tests/test.o -lgc -ldl -lthread\n \n-gctest_irix_dyn_link: test.o libirixgc.so\n-\t$(CC) -L$(ABSDIR) -o gctest_irix_dyn_link test.o -lirixgc\n+gctest_irix_dyn_link: tests/test.o libirixgc.so\n+\t$(CC) -L$(ABSDIR) -o gctest_irix_dyn_link tests/test.o -lirixgc\n \n-test_dll.o: test.c libgc_globals.h\n-\t$(CC) $(CFLAGS) -DGC_USE_DLL -c test.c -o test_dll.o\n+# The following appear to be dead, especially since libgc_globals.h\n+# is apparently lost.\n+test_dll.o: tests/test.c libgc_globals.h\n+\t$(CC) $(CFLAGS) -DGC_USE_DLL -c tests/test.c -o test_dll.o\n \n test_dll: test_dll.o libgc_dll.a libgc.dll\n \t$(CC) test_dll.o -L$(ABSDIR) -lgc_dll -o test_dll\n@@ -457,13 +563,13 @@ SYM_PREFIX-libgc=GC\n # include Makefile.DLLs\n \n reserved_namespace: $(SRCS)\n-\tfor file in $(SRCS) test.c test_cpp.cc; do \\\n+\tfor file in $(SRCS) tests/test.c tests/test_cpp.cc; do \\\n \t\tsed s/GC_/_GC_/g < $$file > tmp; \\\n \t\tcp tmp $$file; \\\n \t\tdone\n \n user_namespace: $(SRCS)\n-\tfor file in $(SRCS) test.c test_cpp.cc; do \\\n+\tfor file in $(SRCS) tests/test.c tests/test_cpp.cc; do \\\n \t\tsed s/_GC_/GC_/g < $$file > tmp; \\\n \t\tcp tmp $$file; \\\n \t\tdone"}, {"sha": "264344924c6cb653c940b28af2a074ad904f6b49", "filename": "boehm-gc/Makefile.dj", "status": "modified", "additions": 96, "deletions": 105, "changes": 201, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9110a741e35c54e46c00662ddc420575376c5947/boehm-gc%2FMakefile.dj", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9110a741e35c54e46c00662ddc420575376c5947/boehm-gc%2FMakefile.dj", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FMakefile.dj?ref=9110a741e35c54e46c00662ddc420575376c5947", "patch": "@@ -1,3 +1,7 @@\n+# This Makefile is intended only for DJGPP use.\n+# It is mainly a copy of the main Makefile, but tends to get out of sync\n+# with it.  A merge would probably be appropriate.\n+\n # Primary targets:\n # gc.a - builds basic library\n # libgc.a - builds library for use with g++ \"-fgc-keyword\" extension\n@@ -20,29 +24,18 @@ AS=gcc -c -x assembler-with-cpp $(ABI_FLAG)\n CXXLD=gxx $(ABI_FLAG)\n EXE_SUFFIX=.exe\n \n-CFLAGS= -O -DATOMIC_UNCOLLECTABLE -DNO_SIGNALS -DALL_INTERIOR_POINTERS -DNO_EXECUTE_PERMISSION -DSILENT\n+srcdir= .\n+VPATH= $(srcdir)\n \n-# For dynamic library builds, it may be necessary to add flags to generate\n-# PIC code, e.g. -fPIC on Linux.\n+CFLAGS= -O -I$(srcdir)/include -DATOMIC_UNCOLLECTABLE -DNO_SIGNALS -DALL_INTERIOR_POINTERS -DNO_EXECUTE_PERMISSION -DSILENT\n \n # Setjmp_test may yield overly optimistic results when compiled\n # without optimization.\n # -DSILENT disables statistics printing, and improves performance.\n-# -DCHECKSUMS reports on erroneously clear dirty bits, and unexpectedly\n-#   altered stubborn objects, at substantial performance cost.\n-#   Use only for incremental collector debugging.\n-# -DFIND_LEAK causes the collector to assume that all inaccessible\n+# -DFIND_LEAK causes GC_find_leak to be initially set.\n+#   This causes the collector to assume that all inaccessible\n #   objects should have been explicitly deallocated, and reports exceptions.\n #   Finalization and the test program are not usable in this mode.\n-# -DSOLARIS_THREADS enables support for Solaris (thr_) threads.\n-#   (Clients should also define SOLARIS_THREADS and then include\n-#   gc.h before performing thr_ or dl* or GC_ operations.)\n-#   Must also define -D_REENTRANT.\n-# -D_SOLARIS_PTHREADS enables support for Solaris pthreads.\n-#   Define SOLARIS_THREADS as well.\n-# -DIRIX_THREADS enables support for Irix pthreads.  See README.irix.\n-# -DLINUX_THREADS enables support for Xavier Leroy's Linux threads.\n-#   see README.linux.  -D_REENTRANT may also be required.\n # -DALL_INTERIOR_POINTERS allows all pointers to the interior\n #   of objects to be recognized.  (See gc_priv.h for consequences.)\n # -DSMALL_CONFIG tries to tune the collector for small heap sizes,\n@@ -62,6 +55,8 @@ CFLAGS= -O -DATOMIC_UNCOLLECTABLE -DNO_SIGNALS -DALL_INTERIOR_POINTERS -DNO_EXEC\n #   implementations, and it sometimes has a significant performance\n #   impact.  However, it is dangerous for many not-quite-ANSI C\n #   programs that call things like printf in asynchronous signal handlers.\n+#   This is on by default.  Turning it off has not been extensively tested with\n+#   compilers that reorder stores.  It should have been.\n # -DNO_EXECUTE_PERMISSION may cause some or all of the heap to not\n #   have execute permission, i.e. it may be impossible to execute\n #   code from the heap.  Currently this only affects the incremental\n@@ -89,9 +84,12 @@ CFLAGS= -O -DATOMIC_UNCOLLECTABLE -DNO_SIGNALS -DALL_INTERIOR_POINTERS -DNO_EXEC\n #   finalize.c).  Objects reachable from finalizable objects will be marked\n #   in a sepearte postpass, and hence their memory won't be reclaimed.\n #   Not recommended unless you are implementing a language that specifies\n-#   these semantics.\n+#   these semantics.  Since 5.0, determines only only the initial value\n+#   of GC_java_finalization variable.\n # -DFINALIZE_ON_DEMAND causes finalizers to be run only in response\n #   to explicit GC_invoke_finalizers() calls.\n+#   In 5.0 this became runtime adjustable, and this only determines the\n+#   initial value of GC_finalize_on_demand.\n # -DATOMIC_UNCOLLECTABLE includes code for GC_malloc_atomic_uncollectable.\n #   This is useful if either the vendor malloc implementation is poor,\n #   or if REDIRECT_MALLOC is used.\n@@ -100,76 +98,100 @@ CFLAGS= -O -DATOMIC_UNCOLLECTABLE -DNO_SIGNALS -DALL_INTERIOR_POINTERS -DNO_EXEC\n #   kind of object.  For the incremental collector it makes sense to match\n #   the most likely page size.  Otherwise large values result in more\n #   fragmentation, but generally better performance for large heaps.\n-# -DUSE_MMAP use MMAP instead of sbrk to get new memory.\n-#   Works for Solaris and Irix.\n-# -DMMAP_STACKS (for Solaris threads) Use mmap from /dev/zero rather than\n-#   GC_scratch_alloc() to get stack memory.\n # -DPRINT_BLACK_LIST Whenever a black list entry is added, i.e. whenever\n #   the garbage collector detects a value that looks almost, but not quite,\n #   like a pointer, print both the address containing the value, and the\n #   value of the near-bogus-pointer.  Can be used to identifiy regions of\n #   memory that are likely to contribute misidentified pointers.\n-# -DOLD_BLOCK_ALLOC Use the old, possibly faster, large block\n-#   allocation strategy.  The new strategy tries harder to minimize\n-#   fragmentation, sometimes at the expense of spending more time in the\n-#   large block allocator and/or collecting more frequently.\n-#   If you expect the allocator to promtly use an explicitly expanded\n-#   heap, this is highly recommended.\n-#\n-\n-\n+# -DKEEP_BACK_PTRS Add code to save back pointers in debugging headers\n+#   for objects allocated with the debugging allocator.  If all objects\n+#   through GC_MALLOC with GC_DEBUG defined, this allows the client\n+#   to determine how particular or randomly chosen objects are reachable\n+#   for debugging/profiling purposes.  The gc_backptr.h interface is\n+#   implemented only if this is defined.\n+# -DGC_ASSERTIONS Enable some internal GC assertion checking.  Currently\n+#   this facility is only used in a few places.  It is intended primarily\n+#   for debugging of the garbage collector itself, but could also\n+# -DDBG_HDRS_ALL Make sure that all objects have debug headers.  Increases\n+#   the reliability (from 99.9999% to 100%) of some of the debugging\n+#   code (especially KEEP_BACK_PTRS).  Makes -DSHORT_DBG_HDRS possible.\n+#   Assumes that all client allocation is done through debugging\n+#   allocators.\n+# -DSHORT_DBG_HDRS Assume that all objects have debug headers.  Shorten\n+#   the headers to minimize object size, at the expense of checking for\n+#   writes past the end of an object.  This is intended for environments\n+#   in which most client code is written in a \"safe\" language, such as\n+#   Scheme or Java.  Assumes that all client allocation is done using\n+#   the GC_debug_ functions (or through the macros that expand to these.\n+#   (Also eliminates the field for the requested object size.)\n+#   occasionally be useful for debugging of client code.  Slows down the\n+#   collector somewhat, but not drastically.\n+# -DCHECKSUMS reports on erroneously clear dirty bits, and unexpectedly\n+#   altered stubborn objects, at substantial performance cost.\n+#   Use only for debugging of the incremental collector.\n+# -DGC_GCJ_SUPPORT includes support for gcj (and possibly other systems\n+#   that include a pointer to a type descriptor in each allocated object).\n+#   Building this way requires an ANSI C compiler.\n+# -DUSE_I686_PREFETCH causes the collector to issue Pentium III style\n+#   prefetch instructions.  No effect except on X86 Linux platforms.\n+#   Assumes a very recent gcc-compatible compiler and assembler.\n+#   (Gas prefetcht0 support was added around May 1999.)\n+#   Empirically the code appears to still run correctly on Pentium II\n+#   processors, though with no performance benefit.  May not run on other\n+#   X86 processors?  In some cases this improves performance by\n+#   15% or so.\n+# -DUSE_3DNOW_PREFETCH causes the collector to issue AMD 3DNow style\n+#   prefetch instructions.  Same restrictions as USE_I686_PREFETCH.\n+#   UNTESTED!!\n+# -DGC_USE_LD_WRAP in combination with the gld flags listed in README.linux\n+#   causes the collector some system and pthread calls in a more transparent\n+#   fashion than the usual macro-based approach.  Requires GNU ld, and\n+#   currently probably works only with Linux.\n \n-LIBGC_CFLAGS= -O -DNO_SIGNALS -DSILENT \\\n-    -DREDIRECT_MALLOC=GC_malloc_uncollectable \\\n-    -DDONT_ADD_BYTE_AT_END -DALL_INTERIOR_POINTERS\n-#   Flags for building libgc.a -- the last two are required.\n \n CXXFLAGS= $(CFLAGS) -DOPERATOR_NEW_ARRAY\n AR= ar\n RANLIB= ranlib\n \n \n-# Redefining srcdir allows object code for the nonPCR version of the collector\n-# to be generated in different directories.  In this case, the destination directory\n-# should contain a copy of the original include directory.\n-srcdir = .\n-VPATH = $(srcdir)\n-\n-OBJS= alloc.o reclaim.o allchblk.o misc.o mach_dep.o os_dep.o mark_rts.o headers.o mark.o obj_map.o blacklst.o finalize.o new_hblk.o dbg_mlc.o malloc.o stubborn.o checksums.o solaris_threads.o irix_threads.o linux_threads.o typd_mlc.o ptr_chck.o mallocx.o solaris_pthreads.o\n+OBJS= alloc.o reclaim.o allchblk.o misc.o mach_dep.o os_dep.o mark_rts.o headers.o mark.o obj_map.o blacklst.o finalize.o new_hblk.o dbg_mlc.o malloc.o stubborn.o checksums.o solaris_threads.o hpux_irix_threads.o linux_threads.o typd_mlc.o ptr_chck.o mallocx.o solaris_pthreads.o gcj_mlc.o specific.o\n \n-CSRCS= reclaim.c allchblk.c misc.c alloc.c mach_dep.c os_dep.c mark_rts.c headers.c mark.c obj_map.c pcr_interface.c blacklst.c finalize.c new_hblk.c real_malloc.c dyn_load.c dbg_mlc.c malloc.c stubborn.c checksums.c solaris_threads.c irix_threads.c linux_threads.c typd_mlc.c ptr_chck.c mallocx.c solaris_pthreads.c\n+CSRCS= reclaim.c allchblk.c misc.c alloc.c mach_dep.c os_dep.c mark_rts.c headers.c mark.c obj_map.c pcr_interface.c blacklst.c finalize.c new_hblk.c real_malloc.c dyn_load.c dbg_mlc.c malloc.c stubborn.c checksums.c solaris_threads.c hpux_irix_threads.c linux_threads.c typd_mlc.c ptr_chck.c mallocx.c solaris_pthreads.c gcj_mlc.c specific.c\n \n-CORD_SRCS=  cord/cordbscs.c cord/cordxtra.c cord/cordprnt.c cord/de.c cord/cordtest.c cord/cord.h cord/ec.h cord/private/cord_pos.h cord/de_win.c cord/de_win.h cord/de_cmds.h cord/de_win.ICO cord/de_win.RC cord/SCOPTIONS.amiga cord/SMakefile.amiga\n+CORD_SRCS=  cord/cordbscs.c cord/cordxtra.c cord/cordprnt.c cord/de.c cord/cordtest.c include/cord.h include/ec.h include/private/cord_pos.h cord/de_win.c cord/de_win.h cord/de_cmds.h cord/de_win.ICO cord/de_win.RC cord/SCOPTIONS.amiga cord/SMakefile.amiga\n \n CORD_OBJS=  cord/cordbscs.o cord/cordxtra.o cord/cordprnt.o\n \n SRCS= $(CSRCS) mips_sgi_mach_dep.s rs6000_mach_dep.s alpha_mach_dep.s \\\n-    sparc_mach_dep.s gc.h gc_typed.h gc_hdrs.h gc_priv.h gc_private.h \\\n-    gcconfig.h gc_mark.h include/gc_inl.h include/gc_inline.h gc.man \\\n-    threadlibs.c if_mach.c if_not_there.c gc_cpp.cc gc_cpp.h weakpointer.h \\\n-    gcc_support.c mips_ultrix_mach_dep.s include/gc_alloc.h gc_alloc.h \\\n+    sparc_mach_dep.s include/gc.h include/gc_typed.h \\\n+    include/private/gc_hdrs.h include/private/gc_priv.h \\\n+    include/private/gcconfig.h include/private/gc_mark.h \\\n+    include/gc_inl.h include/gc_inline.h gc.man \\\n+    threadlibs.c if_mach.c if_not_there.c gc_cpp.cc include/gc_cpp.h \\\n+    include/weakpointer.h include/private/gc_locks.h \\\n+    gcc_support.c mips_ultrix_mach_dep.s include/gc_alloc.h \\\n     include/new_gc_alloc.h include/javaxfc.h sparc_sunos4_mach_dep.s \\\n-    solaris_threads.h $(CORD_SRCS)\n+    include/private/solaris_threads.h include/gc_backptr.h \\\n+    hpux_test_and_clear.s include/gc_gcj.h \\\n+    include/gc_local_alloc.h include/private/dbg_mlc.h \\\n+    include/private/specific.h powerpc_macosx_mach_dep.s \\\n+    include/leak_detector.h $(CORD_SRCS)\n \n OTHER_FILES= Makefile PCR-Makefile OS2_MAKEFILE NT_MAKEFILE BCC_MAKEFILE \\\n            README test.c test_cpp.cc setjmp_t.c SMakefile.amiga \\\n            SCoptions.amiga README.amiga README.win32 cord/README \\\n-           cord/gc.h include/gc.h include/gc_typed.h include/cord.h \\\n-           include/ec.h include/private/cord_pos.h include/private/gcconfig.h \\\n-           include/private/gc_hdrs.h include/private/gc_priv.h \\\n-\t   include/gc_cpp.h README.rs6000 \\\n-           include/weakpointer.h README.QUICK callprocs pc_excludes \\\n+\t   README.rs6000 README.QUICK callprocs pc_excludes \\\n            barrett_diagram README.OS2 README.Mac MacProjects.sit.hqx \\\n-           MacOS.c EMX_MAKEFILE makefile.depend README.debugging \\\n-           include/gc_cpp.h Mac_files/datastart.c Mac_files/dataend.c \\\n+           MacOS.c EMX_MAKEFILE README.debugging \\\n+           Mac_files/datastart.c Mac_files/dataend.c \\\n            Mac_files/MacOS_config.h Mac_files/MacOS_Test_config.h \\\n            add_gc_prefix.c README.solaris2 README.sgi README.hp README.uts \\\n \t   win32_threads.c NT_THREADS_MAKEFILE gc.mak README.dj Makefile.dj \\\n-\t   README.alpha README.linux version.h Makefile.DLLs \\\n-\t   WCC_MAKEFILE\n+\t   README.alpha README.linux README.MacOSX version.h Makefile.DLLs \\\n+\t   WCC_MAKEFILE nursery.c include/gc_nursery.h include/gc_copy_descr.h\n \n-CORD_INCLUDE_FILES= $(srcdir)/gc.h $(srcdir)/cord/cord.h $(srcdir)/cord/ec.h \\\n-           $(srcdir)/cord/private/cord_pos.h\n+CORD_INCLUDE_FILES= $(srcdir)/include/gc.h $(srcdir)/include/cord.h \\\n+\t$(srcdir)/include/ec.h $(srcdir)/include/private/cord_pos.h\n \n UTILS= if_mach$(EXE_SUFFIX) if_not_there$(EXE_SUFFIX)\n \n@@ -189,12 +211,12 @@ SPECIALCFLAGS =\n \n all: gc.a gctest$(EXE_SUFFIX)\n \n-pcr: PCR-Makefile gc_private.h gc_hdrs.h gc.h gcconfig.h mach_dep.o $(SRCS)\n-\tmake -f PCR-Makefile depend\n-\tmake -f PCR-Makefile\n-\n-$(OBJS) test.o dyn_load.o dyn_load_sunos53.o: $(srcdir)/gc_priv.h $(srcdir)/gc_hdrs.h $(srcdir)/gc.h \\\n-    $(srcdir)/gcconfig.h $(srcdir)/gc_typed.h Makefile\n+$(OBJS) test.o dyn_load.o dyn_load_sunos53.o: \\\n+    $(srcdir)/include/private/gc_priv.h \\\n+    $(srcdir)/include/private/gc_hdrs.h $(srcdir)/include/private/gc_locks.h \\\n+    $(srcdir)/include/gc.h \\\n+    $(srcdir)/include/private/gcconfig.h $(srcdir)/include/gc_typed.h \\\n+    Makefile\n # The dependency on Makefile is needed.  Changing\n # options such as -DSILENT affects the size of GC_arrays,\n # invalidating all .o files that rely on gc_priv.h\n@@ -217,17 +239,17 @@ cords: $(CORD_OBJS) cord/cordtest$(EXE_SUFFIX) $(UTILS)\n \t./if_not_there on_sparc_sunos5_3 $(AR) ru gc.a $(CORD_OBJS)\n \t-./if_not_there on_sparc_sunos5_3 $(RANLIB) gc.a\n \n-gc_cpp.o: $(srcdir)/gc_cpp.cc $(srcdir)/gc_cpp.h $(srcdir)/gc.h Makefile\n+gc_cpp.o: $(srcdir)/gc_cpp.cc $(srcdir)/include/gc_cpp.h $(srcdir)/include/gc.h Makefile\n \t$(CXX) -c $(CXXFLAGS) $(srcdir)/gc_cpp.cc\n \n-test_cpp$(EXE_SUFFIX): $(srcdir)/test_cpp.cc $(srcdir)/gc_cpp.h gc_cpp.o $(srcdir)/gc.h \\\n+test_cpp$(EXE_SUFFIX): $(srcdir)/test_cpp.cc $(srcdir)/include/gc_cpp.h gc_cpp.o $(srcdir)/include/gc.h \\\n base_lib $(UTILS)\n \trm -f test_cpp test_cpp$(EXE_SUFFIX)\n \t./if_mach HP_PA \"\" $(CXX) $(CXXFLAGS) -o test_cpp $(srcdir)/test_cpp.cc gc_cpp.o gc.a -ldld\n \t./if_not_there test_cpp$(EXE_SUFFIX) $(CXXLD) $(CXXFLAGS) -o test_cpp$(EXE_SUFFIX) $(srcdir)/test_cpp.cc gc_cpp.o gc.a\n \trm -f test_cpp\n \n-c++: gc_cpp.o $(srcdir)/gc_cpp.h test_cpp$(EXE_SUFFIX)\n+c++: gc_cpp.o $(srcdir)/include/gc_cpp.h test_cpp$(EXE_SUFFIX)\n \trm -f on_sparc_sunos5_4\n \t./if_mach SPARC SUNOS5 touch on_sparc_sunos5_4\n \t./if_mach SPARC SUNOS5 $(AR) rus gc.a gc_cpp.o\n@@ -259,12 +281,14 @@ liblinuxgc.so: $(OBJS) dyn_load.o\n \tgcc -shared -o liblinuxgc.so $(OBJS) dyn_load.o -lo\n \tln liblinuxgc.so libgc.so\n \n-mach_dep.o: $(srcdir)/mach_dep.c $(srcdir)/mips_sgi_mach_dep.s $(srcdir)/mips_ultrix_mach_dep.s $(srcdir)/rs6000_mach_dep.s $(UTILS)\n+mach_dep.o: $(srcdir)/mach_dep.c $(srcdir)/mips_sgi_mach_dep.s $(srcdir)/mips_ultrix_mach_dep.s \\\n+            $(srcdir)/rs6000_mach_dep.s $(srcdir)/powerpc_macosx_mach_dep.s $(UTILS)\n \trm -f mach_dep.o\n \t./if_mach MIPS IRIX5 $(AS) -o mach_dep.o $(srcdir)/mips_sgi_mach_dep.s\n \t./if_mach MIPS RISCOS $(AS) -o mach_dep.o $(srcdir)/mips_ultrix_mach_dep.s\n \t./if_mach MIPS ULTRIX $(AS) -o mach_dep.o $(srcdir)/mips_ultrix_mach_dep.s\n \t./if_mach RS6000 \"\" $(AS) -o mach_dep.o $(srcdir)/rs6000_mach_dep.s\n+\t./if_mach POWERPC MACOSX $(AS) -o mach_dep.o $(srcdir)/powerpc_macosx_mach_dep.s\n \t./if_mach ALPHA \"\" $(AS) -o mach_dep.o $(srcdir)/alpha_mach_dep.s\n \t./if_mach SPARC SUNOS5 $(AS) -o mach_dep.o $(srcdir)/sparc_mach_dep.s\n \t./if_mach SPARC SUNOS4 $(AS) -o mach_dep.o $(srcdir)/sparc_sunos4_mach_dep.s\n@@ -312,20 +336,17 @@ cord/de$(EXE_SUFFIX): $(srcdir)/cord/de.c cord/cordbscs.o cord/cordxtra.o gc.a $\n \t./if_mach ALPHA LINUX $(CC) $(CFLAGS) -o cord/de $(srcdir)/cord/de.c cord/cordbscs.o cord/cordxtra.o gc.a -lcurses\n \t./if_not_there cord/de$(EXE_SUFFIX) $(CC) $(CFLAGS) -o cord/de$(EXE_SUFFIX) $(srcdir)/cord/de.c cord/cordbscs.o cord/cordxtra.o gc.a $(CURSES)\n \n-if_mach$(EXE_SUFFIX): $(srcdir)/if_mach.c $(srcdir)/gcconfig.h\n+if_mach$(EXE_SUFFIX): $(srcdir)/if_mach.c $(srcdir)/include/private/gcconfig.h\n \trm -f if_mach if_mach$(EXE_SUFFIX)\n \t$(CC) $(CFLAGS) -o if_mach $(srcdir)/if_mach.c\n-\trm -f if_mach\n \n-threadlibs$(EXE_SUFFIX): $(srcdir)/threadlibs.c $(srcdir)/gcconfig.h Makefile\n+threadlibs$(EXE_SUFFIX): $(srcdir)/threadlibs.c $(srcdir)include/private/gcconfig.h Makefile\n \trm -f threadlibs threadlibs$(EXE_SUFFIX)\n \t$(CC) $(CFLAGS) -o threadlibs $(srcdir)/threadlibs.c\n-\trm -f threadlibs\n \n if_not_there$(EXE_SUFFIX): $(srcdir)/if_not_there.c\n \trm -f if_not_there if_not_there$(EXE_SUFFIX)\n \t$(CC) $(CFLAGS) -o if_not_there $(srcdir)/if_not_there.c\n-\trm -f if_not_there\n \n # Clean removes *.o several times,\n # because as the first one doesn't seem to get them all!\n@@ -352,7 +373,7 @@ gctest$(EXE_SUFFIX): test.o gc.a if_mach$(EXE_SUFFIX) if_not_there$(EXE_SUFFIX)\n # If an optimized setjmp_test generates a segmentation fault,\n # odds are your compiler is broken.  Gctest may still work.\n # Try compiling setjmp_t.c unoptimized.\n-setjmp_test$(EXE_SUFFIX): $(srcdir)/setjmp_t.c $(srcdir)/gc.h \\\n+setjmp_test$(EXE_SUFFIX): $(srcdir)/setjmp_t.c $(srcdir)/include/gc.h \\\n \t\tif_mach$(EXE_SUFFIX) if_not_there$(EXE_SUFFIX)\n \trm -f setjmp_test$(EXE_SUFFIX)\n \t$(CC) $(CFLAGS) -o setjmp_test $(srcdir)/setjmp_t.c\n@@ -377,21 +398,6 @@ gc.tar: $(SRCS) $(OTHER_FILES) add_gc_prefix\n pc_gc.tar: $(SRCS) $(OTHER_FILES)\n \ttar cvfX pc_gc.tar pc_excludes $(SRCS) $(OTHER_FILES)\n \n-floppy: pc_gc.tar\n-\t-mmd a:/cord\n-\t-mmd a:/cord/private\n-\t-mmd a:/include\n-\t-mmd a:/include/private\n-\tmkdir /tmp/pc_gc\n-\tcat pc_gc.tar | (cd /tmp/pc_gc; tar xvf -)\n-\t-mcopy -tmn /tmp/pc_gc/* a:\n-\t-mcopy -tmn /tmp/pc_gc/cord/* a:/cord\n-\t-mcopy -mn /tmp/pc_gc/cord/de_win.ICO a:/cord\n-\t-mcopy -tmn /tmp/pc_gc/cord/private/* a:/cord/private\n-\t-mcopy -tmn /tmp/pc_gc/include/* a:/include\n-\t-mcopy -tmn /tmp/pc_gc/include/private/* a:/include/private\n-\trm -r /tmp/pc_gc\n-\n gc.tar.Z: gc.tar\n \tcompress gc.tar\n \n@@ -408,9 +414,6 @@ ABSDIR = `pwd`\n gctest_dyn_link: test.o libgc.so\n \t$(CC) -L$(ABSDIR) -R$(ABSDIR) -o gctest_dyn_link test.o -lgc -ldl -lthread\n \n-gctest_irix_dyn_link: test.o libirixgc.so\n-\t$(CC) -L$(ABSDIR) -o gctest_irix_dyn_link test.o -lirixgc\n-\n test_dll.o: test.c libgc_globals.h\n \t$(CC) $(CFLAGS) -DGC_USE_DLL -c test.c -o test_dll.o\n \n@@ -422,15 +425,3 @@ SYM_PREFIX-libgc=GC\n # Uncomment the following line to build a GNU win32 DLL\n # include Makefile.DLLs\n \n-reserved_namespace: $(SRCS)\n-\tfor file in $(SRCS) test.c test_cpp.cc; do \\\n-\t\tsed s/GC_/_GC_/g < $$file > tmp; \\\n-\t\tcp tmp $$file; \\\n-\t\tdone\n-\n-user_namespace: $(SRCS)\n-\tfor file in $(SRCS) test.c test_cpp.cc; do \\\n-\t\tsed s/_GC_/GC_/g < $$file > tmp; \\\n-\t\tcp tmp $$file; \\\n-\t\tdone\n-"}, {"sha": "cd9c7de8c4fc37d8e92aaaf7d79ef96aca5592f7", "filename": "boehm-gc/Makefile.in", "status": "modified", "additions": 20, "deletions": 34, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9110a741e35c54e46c00662ddc420575376c5947/boehm-gc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9110a741e35c54e46c00662ddc420575376c5947/boehm-gc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FMakefile.in?ref=9110a741e35c54e46c00662ddc420575376c5947", "patch": "@@ -102,22 +102,17 @@ MULTIDIRS =\n MULTISUBDIR = \n MULTIDO = true\n MULTICLEAN = true\n-@USE_LIBDIR_TRUE@toolexeclibdir = \\\n-@USE_LIBDIR_TRUE@$(libdir)$(MULTISUBDIR)\n-@USE_LIBDIR_FALSE@toolexeclibdir = \\\n-@USE_LIBDIR_FALSE@$(toolexecdir)/lib$(MULTISUBDIR)\n-@USE_LIBDIR_FALSE@toolexecdir = \\\n-@USE_LIBDIR_FALSE@$(exec_prefix)/$(target_alias)\n+@USE_LIBDIR_TRUE@toolexeclibdir = @USE_LIBDIR_TRUE@$(libdir)$(MULTISUBDIR)\n+@USE_LIBDIR_FALSE@toolexeclibdir = @USE_LIBDIR_FALSE@$(toolexecdir)/lib$(MULTISUBDIR)\n+@USE_LIBDIR_FALSE@toolexecdir = @USE_LIBDIR_FALSE@$(exec_prefix)/$(target_alias)\n \n toolexeclib_LTLIBRARIES = $(target_all)\n EXTRA_LTLIBRARIES = libgcjgc.la\n-libgcjgc_la_SOURCES = allchblk.c alloc.c blacklst.c checksums.c\t\\\n-gcconfig.h dbg_mlc.c dyn_load.c finalize.c gc.h gc_alloc.h gc_cpp.h \\\n-gc_hdrs.h gc_mark.h gc_priv.h gc_private.h gc_typed.h gcj_mlc.c headers.c \\\n-hpux_irix_threads.c linux_threads.c malloc.c mallocx.c mark.c mark_rts.c \\\n-misc.c new_hblk.c obj_map.c os_dep.c pcr_interface.c ptr_chck.c\t\\\n-real_malloc.c reclaim.c solaris_pthreads.c solaris_threads.c \\\n-solaris_threads.h stubborn.c typd_mlc.c version.h weakpointer.h\n+libgcjgc_la_SOURCES = allchblk.c alloc.c blacklst.c checksums.c dbg_mlc.c \\\n+dyn_load.c finalize.c gc_dlopen.c gcj_mlc.c headers.c irix_threads.c \\\n+linux_threads.c malloc.c mallocx.c mark.c mark_rts.c misc.c new_hblk.c \\\n+obj_map.c os_dep.c pcr_interface.c ptr_chck.c real_malloc.c reclaim.c \\\n+solaris_pthreads.c solaris_threads.c specific.c stubborn.c typd_mlc.c`\n \n \n # Include THREADLIBS here to ensure that the correct versions of\n@@ -126,9 +121,10 @@ libgcjgc_la_LIBADD = @addobjs@ $(THREADLIBS)\n libgcjgc_la_DEPENDENCIES = @addobjs@\n libgcjgc_la_LDFLAGS = -version-info 1:1:0 -rpath $(toolexeclibdir)\n \n-EXTRA_libgcjgc_la_SOURCES = alpha_mach_dep.s mips_sgi_mach_dep.s \\\n-mips_ultrix_mach_dep.s rs6000_mach_dep.s sparc_mach_dep.s \\\n-sparc_sunos4_mach_dep.s mach_dep.c ecos.cc\n+EXTRA_libgcjgc_la_SOURCES = alpha_mach_dep.s hpux_test_and_clear.s \\\n+mips_sgi_mach_dep.s mips_ultrix_mach_dep.s powerpc_macosx_mach_dep.s \\\n+rs6000_mach_dep.s sparc_mach_dep.s sparc_netbsd_mach_dep.s \\\n+sparc_sunos4_mach_dep.s\n \n \n AM_CXXFLAGS = @BOEHM_GC_CFLAGS@\n@@ -206,19 +202,14 @@ CPPFLAGS = @CPPFLAGS@\n LDFLAGS = @LDFLAGS@\n LIBS = @LIBS@\n libgcjgc_la_OBJECTS =  allchblk.lo alloc.lo blacklst.lo checksums.lo \\\n-dbg_mlc.lo dyn_load.lo finalize.lo gcj_mlc.lo headers.lo \\\n-hpux_irix_threads.lo linux_threads.lo malloc.lo mallocx.lo mark.lo \\\n+dbg_mlc.lo dyn_load.lo finalize.lo gc_dlopen.lo gcj_mlc.lo headers.lo \\\n+irix_threads.lo linux_threads.lo malloc.lo mallocx.lo mark.lo \\\n mark_rts.lo misc.lo new_hblk.lo obj_map.lo os_dep.lo pcr_interface.lo \\\n ptr_chck.lo real_malloc.lo reclaim.lo solaris_pthreads.lo \\\n-solaris_threads.lo stubborn.lo typd_mlc.lo\n+solaris_threads.lo specific.lo stubborn.lo\n check_PROGRAMS =  gctest$(EXEEXT)\n gctest_OBJECTS =  test.$(OBJEXT)\n gctest_DEPENDENCIES =  ./libgcjgc.la\n-CXXFLAGS = @CXXFLAGS@\n-CXXCOMPILE = $(CXX) $(DEFS) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS)\n-LTCXXCOMPILE = $(LIBTOOL) --mode=compile $(CXX) $(DEFS) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS)\n-CXXLD = $(CXX)\n-CXXLINK = $(LIBTOOL) --mode=link $(CXXLD) $(AM_CXXFLAGS) $(CXXFLAGS) $(LDFLAGS) -o $@\n CFLAGS = @CFLAGS@\n COMPILE = $(CC) $(DEFS) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)\n CCLD = $(CC)\n@@ -228,14 +219,14 @@ aclocal.m4 configure configure.in\n \n DISTFILES = $(DIST_COMMON) $(SOURCES) $(HEADERS) $(TEXINFOS) $(EXTRA_DIST)\n \n-TAR = tar\n+TAR = gtar\n GZIP_ENV = --best\n SOURCES = $(libgcjgc_la_SOURCES) $(EXTRA_libgcjgc_la_SOURCES) $(gctest_SOURCES)\n OBJECTS = $(libgcjgc_la_OBJECTS) $(gctest_OBJECTS)\n \n all: all-redirect\n .SUFFIXES:\n-.SUFFIXES: .S .c .cc .lo .o .obj .s\n+.SUFFIXES: .S .c .lo .o .obj .s\n $(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ Makefile.am $(top_srcdir)/configure.in $(ACLOCAL_M4) \n \tcd $(top_srcdir) && $(AUTOMAKE) --cygnus Makefile\n \n@@ -332,12 +323,6 @@ maintainer-clean-checkPROGRAMS:\n gctest$(EXEEXT): $(gctest_OBJECTS) $(gctest_DEPENDENCIES)\n \t@rm -f gctest$(EXEEXT)\n \t$(LINK) $(gctest_LDFLAGS) $(gctest_OBJECTS) $(gctest_LDADD) $(LIBS)\n-.cc.o:\n-\t$(CXXCOMPILE) -c $<\n-.cc.obj:\n-\t$(CXXCOMPILE) -c `cygpath -w $<`\n-.cc.lo:\n-\t$(LTCXXCOMPILE) -c $<\n \n tags: TAGS\n \n@@ -409,7 +394,7 @@ distdir: $(DISTFILES)\n \t@for file in $(DISTFILES); do \\\n \t  if test -f $$file; then d=.; else d=$(srcdir); fi; \\\n \t  if test -d $$d/$$file; then \\\n-\t    cp -pr $$/$$file $(distdir)/$$file; \\\n+\t    cp -pr $$d/$$file $(distdir)/$$file; \\\n \t  else \\\n \t    test -f $(distdir)/$$file \\\n \t    || ln $$d/$$file $(distdir)/$$file 2> /dev/null \\\n@@ -526,7 +511,8 @@ install-am install uninstall-am uninstall all-redirect all-am all \\\n installdirs mostlyclean-generic distclean-generic clean-generic \\\n maintainer-clean-generic clean mostlyclean distclean maintainer-clean\n \n-$(all_objs) : gcconfig.h gc_priv.h gc_hdrs.h gc.h gc_mark.h\n+$(all_objs) : include/private/gcconfig.h include/private/gc_priv.h \\\n+include/private/gc_hdrs.h include/gc.h include/gc_gcj.h include/gc_mark.h\n \n .s.lo:\n \t$(LTCOMPILE) -Wp,-P -x assembler-with-cpp -c $<"}, {"sha": "580e142555917a2510218b882d83ba4510f4838b", "filename": "boehm-gc/NT_MAKEFILE", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9110a741e35c54e46c00662ddc420575376c5947/boehm-gc%2FNT_MAKEFILE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9110a741e35c54e46c00662ddc420575376c5947/boehm-gc%2FNT_MAKEFILE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FNT_MAKEFILE?ref=9110a741e35c54e46c00662ddc420575376c5947", "patch": "@@ -10,29 +10,29 @@ OBJS= alloc.obj reclaim.obj allchblk.obj misc.obj mach_dep.obj os_dep.obj mark_r\n all: gctest.exe cord\\de.exe test_cpp.exe\n \n .c.obj:\n-\t$(cc) $(cdebug) $(cflags) $(cvars) -DSILENT -DALL_INTERIOR_POINTERS -D__STDC__ $*.c /Fo$*.obj\n+\t$(cc) $(cdebug) $(cflags) $(cvars) -Iinclude -DSILENT -DALL_INTERIOR_POINTERS -D__STDC__ -DGC_NOT_DLL $*.c /Fo$*.obj\n \n .cpp.obj:\n-\t$(cc) $(cdebug) $(cflags) $(cvars) -DSILENT -DALL_INTERIOR_POINTERS $*.CPP /Fo$*.obj\n+\t$(cc) $(cdebug) $(cflags) $(cvars) -Iinclude -DSILENT -DALL_INTERIOR_POINTERS -DGC_NOT_DLL $*.CPP /Fo$*.obj\n \n-$(OBJS) test.obj: gc_priv.h gc_hdrs.h gc.h\n+$(OBJS) tests\\test.obj: include\\private\\gc_priv.h include\\private\\gc_hdrs.h include\\gc.h include\\private\\gcconfig.h include\\private\\gc_locks.h include\\private\\gc_pmark.h include\\gc_mark.h\n \n gc.lib: $(OBJS)\n \tlib /MACHINE:i386 /out:gc.lib $(OBJS)\n # The original NT SDK used lib32 instead of lib\n \n-gctest.exe: test.obj gc.lib\n+gctest.exe: tests\\test.obj gc.lib\n #\tThe following works for win32 debugging.  For win32s debugging use debugtype:coff\n #\tand add mapsympe line.\n #  This produces a \"GUI\" applications that opens no windows and writes to the log file\n #  \"gc.log\".  This is done to make the result runnable under win32s.\n-\t$(link) -debug:full -debugtype:cv $(guiflags) -stack:131072 -out:$*.exe test.obj $(guilibs) gc.lib\n+\t$(link) -debug:full -debugtype:cv $(guiflags) -stack:131072 -out:$*.exe tests\\test.obj $(guilibs) gc.lib\n #\tmapsympe -n -o gctest.sym gctest.exe\n \n cord\\de_win.rbj: cord\\de_win.res\n \tcvtres -$(CPU) cord\\de_win.res -o cord\\de_win.rbj\n \n-cord\\de.obj cord\\de_win.obj: cord\\cord.h cord\\private\\cord_pos.h cord\\de_win.h cord\\de_cmds.h\n+cord\\de.obj cord\\de_win.obj: include\\cord.h include\\private\\cord_pos.h cord\\de_win.h cord\\de_cmds.h\n \n cord\\de_win.res: cord\\de_win.rc cord\\de_win.h cord\\de_cmds.h\n \t$(rc) $(rcvars) -r -fo cord\\de_win.res $(cvars) cord\\de_win.rc\n@@ -41,18 +41,18 @@ cord\\de_win.res: cord\\de_win.rc cord\\de_win.h cord\\de_cmds.h\n cord\\de.exe: cord\\cordbscs.obj cord\\cordxtra.obj cord\\de.obj cord\\de_win.obj cord\\de_win.rbj gc.lib\n \t$(link) -debug:full -debugtype:cv $(guiflags) -stack:16384 -out:cord\\de.exe  cord\\cordbscs.obj cord\\cordxtra.obj cord\\de.obj cord\\de_win.obj cord\\de_win.rbj gc.lib $(guilibs)\n \n-gc_cpp.obj: gc_cpp.h gc.h\n+gc_cpp.obj: include\\gc_cpp.h include\\gc.h\n \n gc_cpp.cpp: gc_cpp.cc\n \tcopy gc_cpp.cc gc_cpp.cpp\n \n-test_cpp.cpp: test_cpp.cc\n-\tcopy test_cpp.cc test_cpp.cpp\n+test_cpp.cpp: tests\\test_cpp.cc\n+\tcopy tests\\test_cpp.cc test_cpp.cpp\n \n # This generates the C++ test executable.  The executable expects\n # a single numeric argument, which is the number of iterations.\n # The output appears in the file \"gc.log\".\n-test_cpp.exe: test_cpp.obj gc_cpp.h gc.h gc.lib\n+test_cpp.exe: test_cpp.obj include\\gc_cpp.h include\\gc.h gc.lib\n \t$(link) -debug:full -debugtype:cv $(guiflags) -stack:16384 -out:test_cpp.exe test_cpp.obj gc.lib $(guilibs)\n \n "}, {"sha": "690598d69d4ad1ba21cdb38e34c65cf9b852b234", "filename": "boehm-gc/OS2_MAKEFILE", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9110a741e35c54e46c00662ddc420575376c5947/boehm-gc%2FOS2_MAKEFILE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9110a741e35c54e46c00662ddc420575376c5947/boehm-gc%2FOS2_MAKEFILE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FOS2_MAKEFILE?ref=9110a741e35c54e46c00662ddc420575376c5947", "patch": "@@ -17,7 +17,7 @@ CFLAGS= /O /Q /DSILENT /DSMALL_CONFIG /DALL_INTERIOR_POINTERS\n \n all: $(OBJS) gctest.exe cord\\cordtest.exe\n \n-$(OBJS) test.obj: gc_priv.h gc_hdrs.h gc.h\n+$(OBJS) test.obj: include\\private\\gc_priv.h include\\private\\gc_hdrs.h include\\gc.h include\\private\\gcconfig.h\n \n ## ERASE THE LIB FIRST - if it is already there then this command will fail\n ## (make sure its there or erase will fail!)\n@@ -32,14 +32,14 @@ mach_dep.obj: mach_dep.c\n gctest.exe: test.obj gc.lib\n         $(CC) $(CFLAGS) /B\"/STACK:524288\" /Fegctest test.obj gc.lib\n \n-cord\\cordbscs.obj: cord\\cordbscs.c cord\\cord.h cord\\private\\cord_pos.h\n+cord\\cordbscs.obj: cord\\cordbscs.c include\\cord.h include\\private\\cord_pos.h\n         $(CC) $(CFLAGS) /C /Focord\\cordbscs cord\\cordbscs.c\n \n-cord\\cordxtra.obj: cord\\cordxtra.c cord\\cord.h cord\\private\\cord_pos.h cord\\ec.h\n+cord\\cordxtra.obj: cord\\cordxtra.c include\\cord.h include\\private\\cord_pos.h include\\ec.h\n         $(CC) $(CFLAGS) /C /Focord\\cordxtra cord\\cordxtra.c\n \n-cord\\cordprnt.obj: cord\\cordprnt.c cord\\cord.h cord\\private\\cord_pos.h cord\\ec.h\n+cord\\cordprnt.obj: cord\\cordprnt.c include\\cord.h include\\private\\cord_pos.h include\\ec.h\n         $(CC) $(CFLAGS) /C /Focord\\cordprnt cord\\cordprnt.c\n \n-cord\\cordtest.exe: cord\\cordtest.c cord\\cord.h cord\\private\\cord_pos.h cord\\ec.h $(CORDOBJS) gc.lib\n+cord\\cordtest.exe: cord\\cordtest.c include\\cord.h include\\private\\cord_pos.h include\\ec.h $(CORDOBJS) gc.lib\n         $(CC) $(CFLAGS) /B\"/STACK:65536\" /Fecord\\cordtest cord\\cordtest.c gc.lib $(CORDOBJS)"}, {"sha": "7e333dbcf105102287b5a8506fab3da5910a980e", "filename": "boehm-gc/README", "status": "removed", "additions": 0, "deletions": 1646, "changes": 1646, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6951ca5dee8ed05749cdc697767910aebaedcc0/boehm-gc%2FREADME", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6951ca5dee8ed05749cdc697767910aebaedcc0/boehm-gc%2FREADME", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FREADME?ref=a6951ca5dee8ed05749cdc697767910aebaedcc0", "patch": "@@ -1,1646 +0,0 @@\n-Copyright 1988, 1989 Hans-J. Boehm, Alan J. Demers\n-Copyright (c) 1991-1996 by Xerox Corporation.  All rights reserved.\n-Copyright (c) 1996-1999 by Silicon Graphics.  All rights reserved.\n-Copyright (c) 1999 by Hewlett-Packard Company. All rights reserved.\n-\n-  [ This version of the collector modified for use in libgcj.\n-    See the file ChangeLog for details ]\n-\n-THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n-OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n-\n-Permission is hereby granted to use or copy this program\n-for any purpose,  provided the above notices are retained on all copies.\n-Permission to modify the code and to distribute modified code is granted,\n-provided the above notices are retained, and a notice that the code was\n-modified is included with the above copyright notice.\n-\n-This is version 5.1 of a conservative garbage collector for C and C++.\n-\n-You might find a more recent version of this at\n-\n-http://www.hpl.hp.com/personal/Hans_Boehm/gc\n-\n-HISTORY -\n-\n-  Early versions of this collector were developed as a part of research\n-projects supported in part by the National Science Foundation\n-and the Defense Advance Research Projects Agency.\n-Much of the code was rewritten by Hans-J. Boehm (boehm@acm.org) at Xerox PARC,\n-SGI, and HP Labs.\n-\n-Some other contributors:  \n-\n-More recent contributors are mentioned in the modification history at the\n-end of this file.  My apologies for any omissions.\n-\n-The SPARC specific code was contributed by Mark Weiser\n-(weiser@parc.xerox.com).  The Encore Multimax modifications were supplied by\n-Kevin Kenny (kenny@m.cs.uiuc.edu).  The adaptation to the RT is largely due\n-to Vernon Lee (scorpion@rice.edu), on machines made available by IBM.\n-Much of the HP specific code and a number of good suggestions for improving the\n-generic code are due to Walter Underwood (wunder@hp-ses.sde.hp.com).\n-Robert Brazile (brazile@diamond.bbn.com) originally supplied the ULTRIX code.\n-Al Dosser (dosser@src.dec.com) and Regis Cridlig (Regis.Cridlig@cl.cam.ac.uk)\n-subsequently provided updates and information on variation between ULTRIX\n-systems.  Parag Patel (parag@netcom.com) supplied the A/UX code.\n-Jesper Peterson(jep@mtiame.mtia.oz.au), Michel Schinz, and\n-Martin Tauchmann (martintauchmann@bigfoot.com) supplied the Amiga port.\n-Thomas Funke (thf@zelator.in-berlin.de(?)) and\n-Brian D.Carlstrom (bdc@clark.lcs.mit.edu) supplied the NeXT ports.\n-Douglas Steel (doug@wg.icl.co.uk) provided ICL DRS6000 code.\n-Bill Janssen (janssen@parc.xerox.com) supplied the SunOS dynamic loader\n-specific code. Manuel Serrano (serrano@cornas.inria.fr) supplied linux and\n-Sony News specific code.  Al Dosser provided Alpha/OSF/1 code.  He and\n-Dave Detlefs(detlefs@src.dec.com) also provided several generic bug fixes.\n-Alistair G. Crooks(agc@uts.amdahl.com) supplied the NetBSD and 386BSD ports.\n-Jeffrey Hsu (hsu@soda.berkeley.edu) provided the FreeBSD port.\n-Brent Benson (brent@jade.ssd.csd.harris.com) ported the collector to\n-a Motorola 88K processor running CX/UX (Harris NightHawk).\n-Ari Huttunen (Ari.Huttunen@hut.fi) generalized the OS/2 port to\n-nonIBM development environments (a nontrivial task).\n-Patrick Beard (beard@cs.ucdavis.edu) provided the initial MacOS port.\n-David Chase, then at Olivetti Research, suggested several improvements.\n-Scott Schwartz (schwartz@groucho.cse.psu.edu) supplied some of the\n-code to save and print call stacks for leak detection on a SPARC.\n-Jesse Hull and John Ellis supplied the C++ interface code.\n-Zhong Shao performed much of the experimentation that led to the\n-current typed allocation facility.  (His dynamic type inference code hasn't\n-made it into the released version of the collector, yet.)\n-(Blame for misinstallation of these modifications goes to the first author,\n-however.)\n-\n-OVERVIEW\n-\n-    This is intended to be a general purpose, garbage collecting storage\n-allocator.  The algorithms used are described in:\n-\n-Boehm, H., and M. Weiser, \"Garbage Collection in an Uncooperative Environment\",\n-Software Practice & Experience, September 1988, pp. 807-820.\n-\n-Boehm, H., A. Demers, and S. Shenker, \"Mostly Parallel Garbage Collection\",\n-Proceedings of the ACM SIGPLAN '91 Conference on Programming Language Design\n-and Implementation, SIGPLAN Notices 26, 6 (June 1991), pp. 157-164.\n-\n-Boehm, H., \"Space Efficient Conservative Garbage Collection\", Proceedings\n-of the ACM SIGPLAN '91 Conference on Programming Language Design and\n-Implementation, SIGPLAN Notices 28, 6 (June 1993), pp. 197-206.\n-\n-  Possible interactions between the collector and optimizing compilers are\n-discussed in\n-\n-Boehm, H., and D. Chase, \"A Proposal for GC-safe C Compilation\",\n-The Journal of C Language Translation 4, 2 (December 1992).\n-\n-and\n-\n-Boehm H., \"Simple GC-safe Compilation\", Proceedings\n-of the ACM SIGPLAN '96 Conference on Programming Language Design and\n-Implementation.\n-\n-(Both are also available from\n-http://reality.sgi.com/boehm/papers/, among other places.)\n-\n-  Unlike the collector described in the second reference, this collector\n-operates either with the mutator stopped during the entire collection\n-(default) or incrementally during allocations.  (The latter is supported\n-on only a few machines.)  It does not rely on threads, but is intended\n-to be thread-safe.\n-\n-  Some of the ideas underlying the collector have previously been explored\n-by others.  (Doug McIlroy wrote a vaguely similar collector that is part of\n-version 8 UNIX (tm).)  However none of this work appears to have been widely\n-disseminated.\n-\n-  Rudimentary tools for use of the collector as a leak detector are included, as\n-is a fairly sophisticated string package \"cord\" that makes use of the collector.\n-(See cord/README.)\n-\n-\n-GENERAL DESCRIPTION\n-\n-  This is a garbage collecting storage allocator that is intended to be\n-used as a plug-in replacement for C's malloc.\n-\n-  Since the collector does not require pointers to be tagged, it does not\n-attempt to ensure that all inaccessible storage is reclaimed.  However,\n-in our experience, it is typically more successful at reclaiming unused\n-memory than most C programs using explicit deallocation.  Unlike manually\n-introduced leaks, the amount of unreclaimed memory typically stays\n-bounded.\n-\n-  In the following, an \"object\" is defined to be a region of memory allocated\n-by the routines described below.  \n-\n-  Any objects not intended to be collected must be pointed to either\n-from other such accessible objects, or from the registers,\n-stack, data, or statically allocated bss segments.  Pointers from\n-the stack or registers may point to anywhere inside an object.\n-The same is true for heap pointers if the collector is compiled with\n- ALL_INTERIOR_POINTERS defined, as is now the default.\n-\n-Compiling without ALL_INTERIOR_POINTERS may reduce accidental retention\n-of garbage objects, by requiring pointers from the heap to to the beginning\n-of an object.  But this no longer appears to be a significant\n-issue for most programs.\n-\n-There are a number of routines which modify the pointer recognition\n-algorithm.  GC_register_displacement allows certain interior pointers\n-to be recognized even if ALL_INTERIOR_POINTERS is nor defined.\n-GC_malloc_ignore_off_page allows some pointers into the middle of large objects\n-to be disregarded, greatly reducing the probablility of accidental\n-retention of large objects.  For most purposes it seems best to compile\n-with ALL_INTERIOR_POINTERS and to use GC_malloc_ignore_off_page if\n-you get collector warnings from allocations of very large objects.\n-See README.debugging for details.\n-\n-  Note that pointers inside memory allocated by the standard \"malloc\" are not\n-seen by the garbage collector.  Thus objects pointed to only from such a\n-region may be prematurely deallocated.  It is thus suggested that the\n-standard \"malloc\" be used only for memory regions, such as I/O buffers, that\n-are guaranteed not to contain pointers to garbage collectable memory.\n-Pointers in C language automatic, static, or register variables,\n-are correctly recognized.  (Note that GC_malloc_uncollectable has semantics\n-similar to standard malloc, but allocates objects that are traced by the\n-collector.)\n-\n-  The collector does not always know how to find pointers in data\n-areas that are associated with dynamic libraries.  This is easy to\n-remedy IF you know how to find those data areas on your operating\n-system (see GC_add_roots).  Code for doing this under SunOS, IRIX 5.X and 6.X,\n-HP/UX, Alpha OSF/1, Linux, and win32 is included and used by default.  (See\n-README.win32 for win32 details.)  On other systems pointers from dynamic\n-library data areas may not be considered by the collector.\n-\n-  Note that the garbage collector does not need to be informed of shared\n-read-only data.  However if the shared library mechanism can introduce\n-discontiguous data areas that may contain pointers, then the collector does\n-need to be informed.\n-\n-  Signal processing for most signals may be deferred during collection,\n-and during uninterruptible parts of the allocation process.  Unlike\n-standard ANSI C mallocs, it can be safe to invoke malloc\n-from a signal handler while another malloc is in progress, provided\n-the original malloc is not restarted.  (Empirically, many UNIX\n-applications already assume this.)  To obtain this level  of signal\n-safety, remove the definition of -DNO_SIGNALS in Makefile.  This incurs\n-a minor performance penalty, and hence is no longer the default.\n-\n-  The allocator/collector can also be configured for thread-safe operation.\n-(Full signal safety can also be achieved, but only at the cost of two system\n-calls per malloc, which is usually unacceptable.)\n-\n-INSTALLATION AND PORTABILITY\n-\n-  As distributed, the macro SILENT is defined in Makefile.\n-In the event of problems, this can be removed to obtain a moderate\n-amount of descriptive output for each collection.\n-(The given statistics exhibit a few peculiarities.\n-Things don't appear to add up for a variety of reasons, most notably\n-fragmentation losses.  These are probably much more significant for the\n-contrived program \"test.c\" than for your application.)\n-\n-  Note that typing \"make test\" will automatically build the collector\n-and then run setjmp_test and gctest. Setjmp_test will give you information\n-about configuring the collector, which is useful primarily if you have\n-a machine that's not already supported.  Gctest is a somewhat superficial\n-test of collector functionality.  Failure is indicated by a core dump or\n-a message to the effect that the collector is broken.  Gctest takes about \n-35 seconds to run on a SPARCstation 2. On a slower machine,\n-expect it to take a while.  It may use up to 8 MB of memory.  (The\n-multi-threaded version will use more.)  \"Make test\" will also, as\n-its last step, attempt to build and test the \"cord\" string library.\n-This will fail without an ANSI C compiler.\n-\n-  The Makefile will generate a library gc.a which you should link against.\n-Typing \"make cords\" will add the cord library to gc.a.\n-Note that this requires an ANSI C compiler.\n-\n-  It is suggested that if you need to replace a piece of the collector\n-(e.g. GC_mark_rts.c) you simply list your version ahead of gc.a on the\n-\t\twork.)\n-ld command line, rather than replacing the one in gc.a.  (This will\n-generate numerous warnings under some versions of AIX, but it still\n-works.)\n-\n-  All include files that need to be used by clients will be put in the\n-include subdirectory.  (Normally this is just gc.h.  \"Make cords\" adds\n-\"cord.h\" and \"ec.h\".)\n-\n-  The collector currently is designed to run essentially unmodified on\n-machines that use a flat 32-bit or 64-bit address space.\n-That includes the vast majority of Workstations and X86 (X >= 3) PCs.\n-(The list here was deleted because it was getting too long and constantly\n-out of date.)\n-  It does NOT run under plain 16-bit DOS or Windows 3.X.  There are however\n-various packages (e.g. win32s, djgpp) that allow flat 32-bit address\n-applications to run under those systemsif the have at least an 80386 processor,\n-and several of those are compatible with the collector.\n-\n-  In a few cases (Amiga, OS/2, Win32, MacOS) a separate makefile\n-or equivalent is supplied.  Many of these have separate README.system\n-files.\n-\n-  Dynamic libraries are completely supported only under SunOS\n-(and even that support is not functional on the last Sun 3 release),\n-IRIX 5&6, HP-PA, Win32 (not Win32S) and OSF/1 on DEC AXP machines.\n-On other machines we recommend that you do one of the following:\n-\n-  1) Add dynamic library support (and send us the code).\n-  2) Use static versions of the libraries.\n-  3) Arrange for dynamic libraries to use the standard malloc.\n-     This is still dangerous if the library stores a pointer to a\n-     garbage collected object.  But nearly all standard interfaces\n-     prohibit this, because they deal correctly with pointers\n-     to stack allocated objects.  (Strtok is an exception.  Don't\n-     use it.)\n-\n-  In all cases we assume that pointer alignment is consistent with that\n-enforced by the standard C compilers.  If you use a nonstandard compiler\n-you may have to adjust the alignment parameters defined in gc_priv.h.\n-\n-  A port to a machine that is not byte addressed, or does not use 32 bit\n-or 64 bit addresses will require a major effort.  A port to plain MSDOS\n-or win16 is hard.\n-\n-  For machines not already mentioned, or for nonstandard compilers, the\n-following are likely to require change:\n-\n-1.  The parameters in gcconfig.h.\n-      The parameters that will usually require adjustment are\n-   STACKBOTTOM,  ALIGNMENT and DATASTART.  Setjmp_test\n-   prints its guesses of the first two.\n-      DATASTART should be an expression for computing the\n-   address of the beginning of the data segment.  This can often be\n-   &etext.  But some memory management units require that there be\n-   some unmapped space between the text and the data segment.  Thus\n-   it may be more complicated.   On UNIX systems, this is rarely\n-   documented.  But the adb \"$m\" command may be helpful.  (Note\n-   that DATASTART will usually be a function of &etext.  Thus a\n-   single experiment is usually insufficient.)\n-     STACKBOTTOM is used to initialize GC_stackbottom, which\n-   should be a sufficient approximation to the coldest stack address.\n-   On some machines, it is difficult to obtain such a value that is\n-   valid across a variety of MMUs, OS releases, etc.  A number of\n-   alternatives exist for using the collector in spite of this.  See the\n-   discussion in gcconfig.h immediately preceding the various\n-   definitions of STACKBOTTOM.\n-   \n-2.  mach_dep.c.\n-      The most important routine here is one to mark from registers.\n-    The distributed file includes a generic hack (based on setjmp) that\n-    happens to work on many machines, and may work on yours.  Try\n-    compiling and running setjmp_t.c to see whether it has a chance of\n-    working.  (This is not correct C, so don't blame your compiler if it\n-    doesn't work.  Based on limited experience, register window machines\n-    are likely to cause trouble.  If your version of setjmp claims that\n-    all accessible variables, including registers, have the value they\n-    had at the time of the longjmp, it also will not work.  Vanilla 4.2 BSD\n-    on Vaxen makes such a claim.  SunOS does not.)\n-      If your compiler does not allow in-line assembly code, or if you prefer\n-    not to use such a facility, mach_dep.c may be replaced by a .s file\n-    (as we did for the MIPS machine and the PC/RT).\n-      At this point enough architectures are supported by mach_dep.c\n-    that you will rarely need to do more than adjust for assembler\n-    syntax.\n-\n-3.  os_dep.c (and gc_priv.h).\n-  \t  Several kinds of operating system dependent routines reside here.\n-  \tMany are optional.  Several are invoked only through corresponding\n-  \tmacros in gc_priv.h, which may also be redefined as appropriate.\n-      The routine GC_register_data_segments is crucial.  It registers static\n-    data areas that must be traversed by the collector. (User calls to\n-    GC_add_roots may sometimes be used for similar effect.)\n-      Routines to obtain memory from the OS also reside here.\n-    Alternatively this can be done entirely by the macro GET_MEM\n-    defined in gc_priv.h.  Routines to disable and reenable signals\n-    also reside here if they are need by the macros DISABLE_SIGNALS\n-    and ENABLE_SIGNALS defined in gc_priv.h.\n-      In a multithreaded environment, the macros LOCK and UNLOCK\n-    in gc_priv.h will need to be suitably redefined.\n-      The incremental collector requires page dirty information, which\n-    is acquired through routines defined in os_dep.c.  Unless directed\n-    otherwise by gcconfig.h, these are implemented as stubs that simply\n-    treat all pages as dirty.  (This of course makes the incremental\n-    collector much less useful.)\n-\n-4.  dyn_load.c\n-\tThis provides a routine that allows the collector to scan data\n-\tsegments associated with dynamic libraries.  Often it is not\n-\tnecessary to provide this routine unless user-written dynamic\n-\tlibraries are used.\n-\n-  For a different version of UN*X or different machines using the\n-Motorola 68000, Vax, SPARC, 80386, NS 32000, PC/RT, or MIPS architecture,\n-it should frequently suffice to change definitions in gcconfig.h.\n-\n-\n-THE C INTERFACE TO THE ALLOCATOR\n-\n-  The following routines are intended to be directly called by the user.\n-Note that usually only GC_malloc is necessary.  GC_clear_roots and GC_add_roots\n-calls may be required if the collector has to trace from nonstandard places\n-(e.g. from dynamic library data areas on a machine on which the \n-collector doesn't already understand them.)  On some machines, it may\n-be desirable to set GC_stacktop to a good approximation of the stack base. \n-(This enhances code portability on HP PA machines, since there is no\n-good way for the collector to compute this value.)  Client code may include\n-\"gc.h\", which defines all of the following, plus many others.\n-\n-1)  GC_malloc(nbytes)\n-    - allocate an object of size nbytes.  Unlike malloc, the object is\n-      cleared before being returned to the user.  Gc_malloc will\n-      invoke the garbage collector when it determines this to be appropriate.\n-      GC_malloc may return 0 if it is unable to acquire sufficient\n-      space from the operating system.  This is the most probable\n-      consequence of running out of space.  Other possible consequences\n-      are that a function call will fail due to lack of stack space,\n-      or that the collector will fail in other ways because it cannot\n-      maintain its internal data structures, or that a crucial system\n-      process will fail and take down the machine.  Most of these\n-      possibilities are independent of the malloc implementation.\n-\n-2)  GC_malloc_atomic(nbytes)\n-    - allocate an object of size nbytes that is guaranteed not to contain any\n-      pointers.  The returned object is not guaranteed to be cleared.\n-      (Can always be replaced by GC_malloc, but results in faster collection\n-      times.  The collector will probably run faster if large character\n-      arrays, etc. are allocated with GC_malloc_atomic than if they are\n-      statically allocated.)\n-\n-3)  GC_realloc(object, new_size)\n-    - change the size of object to be new_size.  Returns a pointer to the\n-      new object, which may, or may not, be the same as the pointer to\n-      the old object.  The new object is taken to be atomic iff the old one\n-      was.  If the new object is composite and larger than the original object,\n-      then the newly added bytes are cleared (we hope).  This is very likely\n-      to allocate a new object, unless MERGE_SIZES is defined in gc_priv.h.\n-      Even then, it is likely to recycle the old object only if the object\n-      is grown in small additive increments (which, we claim, is generally bad\n-      coding practice.)\n-\n-4)  GC_free(object)\n-    - explicitly deallocate an object returned by GC_malloc or\n-      GC_malloc_atomic.  Not necessary, but can be used to minimize\n-      collections if performance is critical.  Probably a performance\n-      loss for very small objects (<= 8 bytes).\n-\n-5)  GC_expand_hp(bytes)\n-    - Explicitly increase the heap size.  (This is normally done automatically\n-      if a garbage collection failed to GC_reclaim enough memory.  Explicit\n-      calls to GC_expand_hp may prevent unnecessarily frequent collections at\n-      program startup.)\n-\n-6)  GC_malloc_ignore_off_page(bytes)\n-\t- identical to GC_malloc, but the client promises to keep a pointer to\n-\t  the somewhere within the first 256 bytes of the object while it is\n-\t  live.  (This pointer should nortmally be declared volatile to prevent\n-\t  interference from compiler optimizations.)  This is the recommended\n-\t  way to allocate anything that is likely to be larger than 100Kbytes\n-\t  or so.  (GC_malloc may result in failure to reclaim such objects.)\n-\n-7)  GC_set_warn_proc(proc)\n-\t- Can be used to redirect warnings from the collector.  Such warnings\n-\t  should be rare, and should not be ignored during code development.\n-      \n-8) GC_enable_incremental()\n-    - Enables generational and incremental collection.  Useful for large\n-      heaps on machines that provide access to page dirty information.\n-      Some dirty bit implementations may interfere with debugging\n-      (by catching address faults) and place restrictions on heap arguments\n-      to system calls (since write faults inside a system call may not be\n-      handled well).\n-\n-9) Several routines to allow for registration of finalization code.\n-   User supplied finalization code may be invoked when an object becomes\n-   unreachable.  To call (*f)(obj, x) when obj becomes inaccessible, use\n-\tGC_register_finalizer(obj, f, x, 0, 0);\n-   For more sophisticated uses, and for finalization ordering issues,\n-   see gc.h.\n-\n-  The global variable GC_free_space_divisor may be adjusted up from its\n-default value of 4 to use less space and more collection time, or down for\n-the opposite effect.  Setting it to 1 or 0 will effectively disable collections\n-and cause all allocations to simply grow the heap.\n-\n-  The variable GC_non_gc_bytes, which is normally 0, may be changed to reflect\n-the amount of memory allocated by the above routines that should not be\n-considered as a candidate for collection.  Careless use may, of course, result\n-in excessive memory consumption.\n-\n-  Some additional tuning is possible through the parameters defined\n-near the top of gc_priv.h.\n-  \n-  If only GC_malloc is intended to be used, it might be appropriate to define:\n-\n-#define malloc(n) GC_malloc(n)\n-#define calloc(m,n) GC_malloc((m)*(n))\n-\n-  For small pieces of VERY allocation intensive code, gc_inl.h\n-includes some allocation macros that may be used in place of GC_malloc\n-and friends.\n-\n-  All externally visible names in the garbage collector start with \"GC_\".\n-To avoid name conflicts, client code should avoid this prefix, except when\n-accessing garbage collector routines or variables.\n-\n-  There are provisions for allocation with explicit type information.\n-This is rarely necessary.  Details can be found in gc_typed.h.\n-\n-THE C++ INTERFACE TO THE ALLOCATOR:\n-\n-  The Ellis-Hull C++ interface to the collector is included in\n-the collector distribution.  If you intend to use this, type\n-\"make c++\" after the initial build of the collector is complete.\n-See gc_cpp.h for the definition of the interface.  This interface\n-tries to approximate the Ellis-Detlefs C++ garbage collection\n-proposal without compiler changes.\n-\n-Cautions:\n-1. Arrays allocated without new placement syntax are\n-allocated as uncollectable objects.  They are traced by the\n-collector, but will not be reclaimed.\n-\n-2. Failure to use \"make c++\" in combination with (1) will\n-result in arrays allocated using the default new operator.\n-This is likely to result in disaster without linker warnings.\n-\n-3. If your compiler supports an overloaded new[] operator,\n-then gc_cpp.cc and gc_cpp.h should be suitably modified.\n-\n-4. Many current C++ compilers have deficiencies that\n-break some of the functionality.  See the comments in gc_cpp.h\n-for suggested workarounds.\n-\n-USE AS LEAK DETECTOR:\n-\n-  The collector may be used to track down leaks in C programs that are\n-intended to run with malloc/free (e.g. code with extreme real-time or\n-portability constraints).  To do so define FIND_LEAK in Makefile\n-This will cause the collector to invoke the report_leak\n-routine defined near the top of reclaim.c whenever an inaccessible\n-object is found that has not been explicitly freed.  The collector will\n-no longer reclaim inaccessible memory; in this form it is purely a\n-debugging tool.\n-  Productive use of this facility normally involves redefining report_leak\n-to do something more intelligent.  This typically requires annotating\n-objects with additional information (e.g. creation time stack trace) that\n-identifies their origin.  Such code is typically not very portable, and is\n-not included here, except on SPARC machines.\n-  If all objects are allocated with GC_DEBUG_MALLOC (see next section),\n-then the default version of report_leak will report the source file\n-and line number at which the leaked object was allocated.  This may\n-sometimes be sufficient.  (On SPARC/SUNOS4 machines, it will also report\n-a cryptic stack trace.  This can often be turned into a sympolic stack\n-trace by invoking program \"foo\" with \"callprocs foo\".  Callprocs is\n-a short shell script that invokes adb to expand program counter values\n-to symbolic addresses.  It was largely supplied by Scott Schwartz.)\n-  Note that the debugging facilities described in the next section can\n-sometimes be slightly LESS effective in leak finding mode, since in\n-leak finding mode, GC_debug_free actually results in reuse of the object.\n-(Otherwise the object is simply marked invalid.)  Also note that the test\n-program is not designed to run meaningfully in FIND_LEAK mode.\n-Use \"make gc.a\" to build the collector.\n-\n-DEBUGGING FACILITIES:\n-\n-  The routines GC_debug_malloc, GC_debug_malloc_atomic, GC_debug_realloc,\n-and GC_debug_free provide an alternate interface to the collector, which\n-provides some help with memory overwrite errors, and the like.\n-Objects allocated in this way are annotated with additional\n-information.  Some of this information is checked during garbage\n-collections, and detected inconsistencies are reported to stderr.\n-\n-  Simple cases of writing past the end of an allocated object should\n-be caught if the object is explicitly deallocated, or if the\n-collector is invoked while the object is live.  The first deallocation\n-of an object will clear the debugging info associated with an\n-object, so accidentally repeated calls to GC_debug_free will report the\n-deallocation of an object without debugging information.  Out of\n-memory errors will be reported to stderr, in addition to returning\n-NIL.\n-\n-  GC_debug_malloc checking  during garbage collection is enabled\n-with the first call to GC_debug_malloc.  This will result in some\n-slowdown during collections.  If frequent heap checks are desired,\n-this can be achieved by explicitly invoking GC_gcollect, e.g. from\n-the debugger.\n-\n-  GC_debug_malloc allocated objects should not be passed to GC_realloc\n-or GC_free, and conversely.  It is however acceptable to allocate only\n-some objects with GC_debug_malloc, and to use GC_malloc for other objects,\n-provided the two pools are kept distinct.  In this case, there is a very\n-low probablility that GC_malloc allocated objects may be misidentified as\n-having been overwritten.  This should happen with probability at most\n-one in 2**32.  This probability is zero if GC_debug_malloc is never called.\n-\n-  GC_debug_malloc, GC_malloc_atomic, and GC_debug_realloc take two\n-additional trailing arguments, a string and an integer.  These are not\n-interpreted by the allocator.  They are stored in the object (the string is\n-not copied).  If an error involving the object is detected, they are printed.\n-\n-  The macros GC_MALLOC, GC_MALLOC_ATOMIC, GC_REALLOC, GC_FREE, and\n-GC_REGISTER_FINALIZER are also provided.  These require the same arguments\n-as the corresponding (nondebugging) routines.  If gc.h is included\n-with GC_DEBUG defined, they call the debugging versions of these\n-functions, passing the current file name and line number as the two\n-extra arguments, where appropriate.  If gc.h is included without GC_DEBUG\n-defined, then all these macros will instead be defined to their nondebugging\n-equivalents.  (GC_REGISTER_FINALIZER is necessary, since pointers to\n-objects with debugging information are really pointers to a displacement\n-of 16 bytes form the object beginning, and some translation is necessary\n-when finalization routines are invoked.  For details, about what's stored\n-in the header, see the definition of the type oh in debug_malloc.c)\n-\n-INCREMENTAL/GENERATIONAL COLLECTION:\n-\n-The collector normally interrupts client code for the duration of \n-a garbage collection mark phase.  This may be unacceptable if interactive\n-response is needed for programs with large heaps.  The collector\n-can also run in a \"generational\" mode, in which it usually attempts to\n-collect only objects allocated since the last garbage collection.\n-Furthermore, in this mode, garbage collections run mostly incrementally,\n-with a small amount of work performed in response to each of a large number of\n-GC_malloc requests.\n-\n-This mode is enabled by a call to GC_enable_incremental().\n-\n-Incremental and generational collection is effective in reducing\n-pause times only if the collector has some way to tell which objects\n-or pages have been recently modified.  The collector uses two sources\n-of information:\n-\n-1. Information provided by the VM system.  This may be provided in\n-one of several forms.  Under Solaris 2.X (and potentially under other\n-similar systems) information on dirty pages can be read from the\n-/proc file system.  Under other systems (currently SunOS4.X) it is\n-possible to write-protect the heap, and catch the resulting faults.\n-On these systems we require that system calls writing to the heap\n-(other than read) be handled specially by client code.\n-See os_dep.c for details.\n-\n-2. Information supplied by the programmer.  We define \"stubborn\"\n-objects to be objects that are rarely changed.  Such an object\n-can be allocated (and enabled for writing) with GC_malloc_stubborn.\n-Once it has been initialized, the collector should be informed with\n-a call to GC_end_stubborn_change.  Subsequent writes that store\n-pointers into the object must be preceded by a call to\n-GC_change_stubborn.\n-\n-This mechanism performs best for objects that are written only for\n-initialization, and such that only one stubborn object is writable\n-at once.  It is typically not worth using for short-lived\n-objects.  Stubborn objects are treated less efficiently than pointerfree\n-(atomic) objects.\n-\n-A rough rule of thumb is that, in the absence of VM information, garbage\n-collection pauses are proportional to the amount of pointerful storage\n-plus the amount of modified \"stubborn\" storage that is reachable during\n-the collection.  \n-\n-Initial allocation of stubborn objects takes longer than allocation\n-of other objects, since other data structures need to be maintained.\n-\n-We recommend against random use of stubborn objects in client\n-code, since bugs caused by inappropriate writes to stubborn objects\n-are likely to be very infrequently observed and hard to trace.  \n-However, their use may be appropriate in a few carefully written\n-library routines that do not make the objects themselves available\n-for writing by client code.\n-\n-\n-BUGS:\n-\n-  Any memory that does not have a recognizable pointer to it will be\n-reclaimed.  Exclusive-or'ing forward and backward links in a list\n-doesn't cut it.\n-  Some C optimizers may lose the last undisguised pointer to a memory\n-object as a consequence of clever optimizations.  This has almost\n-never been observed in practice.  Send mail to boehm@acm.org\n-for suggestions on how to fix your compiler.\n-  This is not a real-time collector.  In the standard configuration,\n-percentage of time required for collection should be constant across\n-heap sizes.  But collection pauses will increase for larger heaps.\n-(On SPARCstation 2s collection times will be on the order of 300 msecs\n-per MB of accessible memory that needs to be scanned.  Your mileage\n-may vary.)  The incremental/generational collection facility helps,\n-but is portable only if \"stubborn\" allocation is used.\n-  Please address bug reports to boehm@acm.org.  If you are\n-contemplating a major addition, you might also send mail to ask whether\n-it's already been done (or whether we tried and discarded it).\n-\n-RECENT VERSIONS:\n-\n-  Version 1.3 and immediately preceding versions contained spurious\n-assembly language assignments to TMP_SP.  Only the assignment in the PC/RT\n-code is necessary.  On other machines, with certain compiler options,\n-the assignments can lead to an unsaved register being overwritten.\n-Known to cause problems under SunOS 3.5 WITHOUT the -O option.  (With\n--O the compiler recognizes it as dead code.  It probably shouldn't,\n-but that's another story.)\n-\n-  Version 1.4 and earlier versions used compile time determined values\n-for the stack base.  This no longer works on Sun 3s, since Sun 3/80s use\n-a different stack base.  We now use a straightforward heuristic on all\n-machines on which it is known to work (incl. Sun 3s) and compile-time\n-determined values for the rest.  There should really be library calls\n-to determine such values.\n-\n-  Version 1.5 and earlier did not ensure 8 byte alignment for objects\n-allocated on a sparc based machine.\n-\n-  Version 1.8 added ULTRIX support in gc_private.h.\n-  \n-  Version 1.9 fixed a major bug in gc_realloc.\n-  \n-  Version 2.0 introduced a consistent naming convention for collector\n-routines and added support for registering dynamic library data segments\n-in the standard mark_roots.c.  Most of the data structures were revamped.\n-The treatment of interior pointers was completely changed.  Finalization\n-was added.  Support for locking was added.  Object kinds were added.\n-We added a black listing facility to avoid allocating at addresses known\n-to occur as integers somewhere in the address space.  Much of this\n-was accomplished by adapting ideas and code from the PCR collector.\n-The test program was changed and expanded.\n-\n-  Version 2.1 was the first stable version since 1.9, and added support\n-for PPCR.\n-\n-  Version 2.2 added debugging allocation, and fixed various bugs.  Among them:\n-- GC_realloc could fail to extend the size of the object for certain large object sizes.\n-- A blatant subscript range error in GC_printf, which unfortunately\n-  wasn't exercised on machines with sufficient stack alignment constraints.\n-- GC_register_displacement did the wrong thing if it was called after\n-  any allocation had taken place.\n-- The leak finding code would eventually break after 2048 byte\n-  byte objects leaked.\n-- interface.c didn't compile.\n-- The heap size remained much too small for large stacks.\n-- The stack clearing code behaved badly for large stacks, and perhaps\n-  on HP/PA machines.\n-\n-  Version 2.3 added ALL_INTERIOR_POINTERS and fixed the following bugs:\n-- Missing declaration of etext in the A/UX version.\n-- Some PCR root-finding problems.\n-- Blacklisting was not 100% effective, because the plausible future\n-  heap bounds were being miscalculated.\n-- GC_realloc didn't handle out-of-memory correctly.\n-- GC_base could return a nonzero value for addresses inside free blocks.\n-- test.c wasn't really thread safe, and could erroneously report failure\n-  in a multithreaded environment.  (The locking primitives need to be\n-  replaced for other threads packages.)\n-- GC_CONS was thoroughly broken.\n-- On a SPARC with dynamic linking, signals stayed diabled while the\n-  client code was running.\n-  (Thanks to Manuel Serrano at INRIA for reporting the last two.)\n-  \n-  Version 2.4 added GC_free_space_divisor as a tuning knob, added\n-  support for OS/2 and linux, and fixed the following bugs:\n-- On machines with unaligned pointers (e.g. Sun 3), every 128th word could\n-  fail to be considered for marking.\n-- Dynamic_load.c erroneously added 4 bytes to the length of the data and\n-  bss sections of the dynamic library.  This could result in a bad memory\n-  reference if the actual length was a multiple of a page.  (Observed on\n-  Sun 3.  Can probably also happen on a Sun 4.)\n-  (Thanks to Robert Brazile for pointing out that the Sun 3 version\n-  was broken.  Dynamic library handling is still broken on Sun 3s\n-  under 4.1.1U1, but apparently not 4.1.1.  If you have such a machine,\n-  use -Bstatic.)\n-  \n-  Version 2.5 fixed the following bugs:\n-- Removed an explicit call to exit(1)\n-- Fixed calls to GC_printf and GC_err_printf, so the correct number of\n-  arguments are always supplied.  The OS/2 C compiler gets confused if\n-  the number of actuals and the number of formals differ.  (ANSI C\n-  doesn't require this to work.  The ANSI sanctioned way of doing things\n-  causes too many compatibility problems.)\n-  \n-  Version 3.0  added generational/incremental collection and stubborn\n-  objects.\n-\n-  Version 3.1 added the following features:\n-- A workaround for a SunOS 4.X SPARC C compiler\n-  misfeature that caused problems when the collector was turned into\n-  a dynamic library.  \n-- A fix for a bug in GC_base that could result in a memory fault.\n-- A fix for a performance bug (and several other misfeatures) pointed\n-  out by Dave Detlefs and Al Dosser.\n-- Use of dirty bit information for static data under Solaris 2.X.\n-- DEC Alpha/OSF1 support (thanks to Al Dosser).\n-- Incremental collection on more platforms.\n-- A more refined heap expansion policy.  Less space usage by default.\n-- Various minor enhancements to reduce space usage, and to reduce\n-  the amount of memory scanned by the collector.\n-- Uncollectable allocation without per object overhead.\n-- More conscientious handling of out-of-memory conditions.\n-- Fixed a bug in debugging stubborn allocation.\n-- Fixed a bug that resulted in occasional erroneous reporting of smashed\n-  objects with debugging allocation.\n-- Fixed bogus leak reports of size 4096 blocks with FIND_LEAK.\n-\n-  Version 3.2 fixed a serious and not entirely repeatable bug in\n-  the incremental collector.  It appeared only when dirty bit info\n-  on the roots was available, which is normally only under Solaris.\n-  It also added GC_general_register_disappearing_link, and some\n-  testing code.  Interface.c disappeared.\n-\n-  Version 3.3 fixes several bugs and adds new ports:\n-- PCR-specific bugs.\n-- Missing locking in GC_free, redundant FASTUNLOCK\n-  in GC_malloc_stubborn, and 2 bugs in\n-  GC_unregister_disappearing_link.\n-  All of the above were pointed out by Neil Sharman\n-  (neil@cs.mu.oz.au).\n-- Common symbols allocated by the SunOS4.X dynamic loader\n-  were not included in the root set.\n-- Bug in GC_finalize (reported by Brian Beuning and Al Dosser)\n-- Merged Amiga port from Jesper Peterson (untested)\n-- Merged NeXT port from Thomas Funke (significantly\n-  modified and untested)\n-\n-  Version 3.4:\n-- Fixed a performance bug in GC_realloc.\n-- Updated the amiga port.\n-- Added NetBSD and 386BSD ports.\n-- Added cord library.\n-- Added trivial performance enhancement for\n-  ALL_INTERIOR_POINTERS.  (Don't scan last word.)\n-  \n-  Version 3.5\n-- Minor collections now mark from roots only once, if that\n-  doesn't cause an excessive pause.\n-- The stack clearing heuristic was refined to prevent anomalies\n-  with very heavily recursive programs and sparse stacks.\n-- Fixed a bug that prevented mark stack growth in some cases.\n-  GC_objects_are_marked should be set to TRUE after a call\n-  to GC_push_roots and as part of GC_push_marked, since\n-  both can now set mark bits.  I think this is only a performance\n-  bug, but I wouldn't bet on it.  It's certainly very hard to argue\n-  that the old version was correct.\n-- Fixed an incremental collection bug that prevented it from\n-  working at all when HBLKSIZE != getpagesize()\n-- Changed dynamic_loading.c to include gc_priv.h before testing\n-  DYNAMIC_LOADING.  SunOS dynamic library scanning\n-  must have been broken in 3.4.\n-- Object size rounding now adapts to program behavior.\n-- Added a workaround (provided by Manuel Serrano and\n-  colleagues) to a long-standing SunOS 4.X (and 3.X?) ld bug\n-  that I had incorrectly assumed to have been squished.\n-  The collector was broken if the text segment size was within\n-  32 bytes of a multiple of 8K bytes, and if the beginning of\n-  the data segment contained interesting roots.  The workaround\n-  assumes a demand-loadable executable.  The original may have\n-  have \"worked\" in some other cases.\n-- Added dynamic library support under IRIX5.\n-- Added support for EMX under OS/2 (thanks to Ari Huttunen).\n-  \n-Version 3.6:\n-- fixed a bug in the mark stack growth code that was introduced\n-  in 3.4.\n-- fixed Makefile to work around DEC AXP compiler tail recursion\n-  bug.\n-\n-Version 3.7:\n-- Added a workaround for an HP/UX compiler bug.\n-- Fixed another stack clearing performance bug.  Reworked\n-  that code once more.\n-  \n-Version 4.0:\n-- Added support for Solaris threads (which was possible\n-  only by reimplementing some fraction of Solaris threads,\n-  since Sun doesn't currently make the thread debugging\n-  interface available).\n-- Added non-threads win32 and win32S support.\n-- (Grudgingly, with suitable muttering of obscenities) renamed\n-  files so that the collector distribution could live on a FAT\n-  file system.  Files that are guaranteed to be useless on\n-  a PC still have long names.  Gc_inline.h and gc_private.h\n-  still exist, but now just include  gc_inl.h and gc_priv.h.\n-- Fixed a really obscure bug in finalization that could cause\n-  undetected mark stack overflows.  (I would be surprised if\n-  any real code ever tickled this one.)\n-- Changed finalization code to dynamically resize the hash\n-  tables it maintains.  (This probably does not matter for well-\n-  -written code.  It no doubt does for C++ code that overuses\n-  destructors.)\n-- Added typed allocation primitives.  Rewrote the marker to\n-  accommodate them with more reasonable efficiency.  This\n-  change should also speed up marking for GC_malloc allocated\n-  objects a little.  See gc_typed.h for new primitives.\n-- Improved debugging facilities slightly.  Allocation time\n-  stack traces are now kept by default on SPARC/SUNOS4.\n-  (Thanks to Scott Schwartz.)\n-- Added better support for small heap applications.\n-- Significantly extended cord package.  Fixed a bug in the\n-  implementation of lazily read files.  Printf and friends now\n-  have cord variants.  Cord traversals are a bit faster.\n-- Made ALL_INTERIOR_POINTERS recognition the default.\n-- Fixed de so that it can run in constant space, independent\n-  of file size.  Added simple string searching to cords and de.\n-- Added the Hull-Ellis C++ interface.\n-- Added dynamic library support for OSF/1.\n-  (Thanks to Al Dosser and Tim Bingham at DEC.)\n-- Changed argument to GC_expand_hp to be expressed\n-  in units of bytes instead of heap blocks.  (Necessary\n-  since the heap block size now varies depending on\n-  configuration.  The old version was never very clean.)\n-- Added GC_get_heap_size().  The previous \"equivalent\"\n-  was broken.\n-- Restructured the Makefile a bit.  \n-\n-Since version 4.0:\n-- Changed finalization implementation to guarantee that\n-  finalization procedures are called outside of the allocation\n-  lock, making direct use of the interface a little less dangerous.\n-  MAY BREAK EXISTING CLIENTS that assume finalizers\n-  are protected by a lock.  Since there seem to be few multithreaded\n-  clients that use finalization, this is hopefully not much of\n-  a problem.\n-- Fixed a gross bug in CORD_prev.\n-- Fixed a bug in blacklst.c that could result in unbounded\n-  heap growth during startup on machines that do not clear\n-  memory obtained from the OS (e.g. win32S).\n-- Ported de editor to win32/win32S.  (This is now the only\n-  version with a mouse-sensitive UI.)\n-- Added GC_malloc_ignore_off_page to allocate large arrays\n-  in the presence of ALL_INTERIOR_POINTERS.\n-- Changed GC_call_with_alloc_lock to not disable signals in\n-  the single-threaded case.\n-- Reduced retry count in GC_collect_or_expand for garbage\n-  collecting when out of memory.\n-- Made uncollectable allocations bypass black-listing, as they\n-  should.\n-- Fixed a bug in typed_test in test.c that could cause (legitimate)\n-  GC crashes.\n-- Fixed some potential synchronization problems in finalize.c\n-- Fixed a real locking problem in typd_mlc.c.\n-- Worked around an AIX 3.2 compiler feature that results in\n-  out of bounds memory references.\n-- Partially worked around an IRIX5.2 beta problem (which may\n-  or may not persist to the final release).\n-- Fixed a bug in the heap integrity checking code that could\n-  result in explicitly deallocated objects being identified as\n-  smashed.  Fixed a bug in the dbg_mlc stack saving code\n-  that caused old argument pointers to be considered live.\n-- Fixed a bug in CORD_ncmp (and hence CORD_str).\n-- Repaired the OS2 port, which had suffered from bit rot\n-  in 4.0.  Worked around what appears to be CSet/2 V1.0\n-  optimizer bug.\n-- Fixed a Makefile bug for target \"c++\".\n-\n-Since version 4.1:\n-- Multiple bug fixes/workarounds in the Solaris threads version.\n-  (It occasionally failed to locate some register contents for\n-  marking.  It also turns out that thr_suspend and friends are\n-  unreliable in Solaris 2.3.  Dirty bit reads appear\n-  to be unreliable under some weird \n-  circumstances.  My stack marking code\n-  contained a serious performance bug.  The new code is\n-  extremely defensive, and has not failed in several cpu\n-  hours of testing.  But  no guarantees ...)\n-- Added MacOS support (thanks to Patrick Beard.)\n-- Fixed several syntactic bugs in gc_c++.h and friends.  (These\n-  didn't bother g++, but did bother most other compilers.)\n-  Fixed gc_c++.h finalization interface.  (It didn't.)\n-- 64 bit alignment for allocated objects was not guaranteed in a\n-  few cases in which it should have been.\n-- Added GC_malloc_atomic_ignore_off_page.\n-- Added GC_collect_a_little.\n-- Added some prototypes to gc.h.\n-- Some other minor bug fixes (notably in Makefile).\n-- Fixed OS/2 / EMX port (thanks to Ari Huttunen).\n-- Fixed AmigaDOS port. (thanks to Michel Schinz).\n-- Fixed the DATASTART definition under Solaris.  There\n-  was a 1 in 16K chance of the collector missing the first\n-  64K of static data (and thus crashing).\n-- Fixed some blatant anachronisms in the README file.\n-- Fixed PCR-Makefile for upcoming PPCR release.\n-\n-Since version 4.2:\n-- Fixed SPARC alignment problem with GC_DEBUG.\n-- Fixed Solaris threads /proc workaround.  The real\n-  problem was an interaction with mprotect.\n-- Incorporated fix from Patrick Beard for gc_c++.h (now gc_cpp.h).\n-- Slightly improved allocator space utilization by\n-  fixing the GC_size_map mechanism.\n-- Integrated some Sony News and MIPS RISCos 4.51\n-  patches.  (Thanks to Nobuyuki Hikichi of\n-  Software Research Associates, Inc. Japan)\n-- Fixed HP_PA alignment problem.  (Thanks to\n-  xjam@cork.cs.berkeley.edu.)\n-- Added GC_same_obj and friends.  Changed GC_base\n-  to return 0 for pointers past the end of large objects.\n-  Improved GC_base performance with ALL_INTERIOR_POINTERS\n-  on machines with a slow integer mod operation.\n-  Added GC_PTR_ADD, GC_PTR_STORE, etc. to prepare\n-  for preprocessor.\n-- changed the default on most UNIX machines to be that\n-  signals are not disabled during critical GC operations.\n-  This is still ANSI-conforming, though somewhat dangerous\n-  in the presence of signal handlers. But the performance\n-  cost of the alternative is sometimes problematic.\n-  Can be changed back with a minor Makefile edit.\n-- renamed IS_STRING in gc.h, to CORD_IS_STRING, thus\n-  following my own naming convention.  Added the function\n-  CORD_to_const_char_star.\n-- Fixed a gross bug in GC_finalize.  Symptom: occasional\n-  address faults in that function.  (Thanks to Anselm\n-  Baird-Smith (Anselm.BairdSmith@inria.fr)\n-- Added port to ICL DRS6000 running DRS/NX.  Restructured\n-  things a bit to factor out common code, and remove obsolete\n-  code.  Collector should now run under SUNOS5 with either\n-  mprotect or /proc dirty bits.  (Thanks to Douglas Steel\n-  (doug@wg.icl.co.uk)).\n-- More bug fixes and workarounds for Solaris 2.X.  (These were\n-  mostly related to putting the collector in a dynamic library,\n-  which didn't really work before.  Also SOLARIS_THREADS\n-  didn't interact well with dl_open.)  Thanks to btlewis@eng.sun.com.\n-- Fixed a serious performance bug on the DEC Alpha.  The text\n-  segment was getting registered as part of the root set.\n-  (Amazingly, the result was still fast enough that the bug\n-  was not conspicuous.) The fix works on OSF/1, version 1.3.\n-  Hopefully it also works on other versions of OSF/1 ...\n-- Fixed a bug in GC_clear_roots.\n-- Fixed a bug in GC_generic_malloc_words_small that broke\n-  gc_inl.h.  (Reported by Antoine de Maricourt.  I broke it\n-  in trying to tweak the Mac port.) \n-- Fixed some problems with cord/de under Linux.\n-- Fixed some cord problems, notably with CORD_riter4.\n-- Added DG/UX port.\n-  Thanks to Ben A. Mesander (ben@piglet.cr.usgs.gov)\n-- Added finalization registration routines with weaker ordering\n-  constraints.  (This is necessary for C++ finalization with\n-  multiple inheritance, since the compiler often adds self-cycles.)\n-- Filled the holes in the SCO port. (Thanks to Michael Arnoldus\n-  <chime@proinf.dk>.)\n-- John Ellis' additions to the C++ support:  From John:\n-\n-* I completely rewrote the documentation in the interface gc_c++.h\n-(later renamed gc_cpp.h).  I've tried to make it both clearer and more\n-precise.\n-\n-* The definition of accessibility now ignores pointers from an\n-finalizable object (an object with a clean-up function) to itself.\n-This allows objects with virtual base classes to be finalizable by the\n-collector.  Compilers typically implement virtual base classes using\n-pointers from an object to itself, which under the old definition of\n-accessibility prevented objects with virtual base classes from ever\n-being collected or finalized.\n-\n-* gc_cleanup now includes gc as a virtual base.  This was enabled by\n-the change in the definition of accessibility.\n-\n-* I added support for operator new[].  Since most (all?) compilers\n-don't yet support operator new[], it is conditionalized on\n--DOPERATOR_NEW_ARRAY.  The code is untested, but its trivial and looks\n-correct.\n-\n-* The test program test_gc_c++ (later renamed test_cpp.cc)\n-tries to test for the C++-specific functionality not tested by the\n-other programs.\n-- Added <unistd.h> include to misc.c.  (Needed for ppcr.)\n-- Added PowerMac port. (Thanks to Patrick Beard again.)\n-- Fixed \"srcdir\"-related Makefile problems.  Changed things so\n-  that all externally visible include files always appear in the\n-  include subdirectory of the source.  Made gc.h directly\n-  includable from C++ code.  (These were at Per\n-  Bothner's suggestion.)\n-- Changed Intel code to also mark from ebp (Kevin Warne's\n-  suggestion).\n-- Renamed C++ related files so they could live in a FAT\n-  file system. (Charles Fiterman's suggestion.)\n-- Changed Windows NT Makefile to include C++ support in\n-  gc.lib.  Added C++ test as Makefile target.\n-  \n-Since version 4.3:\n- - ASM_CLEAR_CODE was erroneously defined for HP\n-   PA machines, resulting in a compile error.\n- - Fixed OS/2 Makefile to create a library.  (Thanks to\n-   Mark Boulter (mboulter@vnet.ibm.com)).\n- - Gc_cleanup objects didn't work if they were created on\n-   the stack.  Fixed.\n- - One copy of Gc_cpp.h in the distribution was out of \n-   synch, and failed to document some known compiler\n-   problems with explicit destructor invocation.  Partially\n-   fixed.  There are probably other compilers on which\n-   gc_cleanup is miscompiled.\n- - Fixed Makefile to pass C compiler flags to C++ compiler.\n- - Added Mac fixes.\n- - Fixed os_dep.c to work around what appears to be\n-   a new and different VirtualQuery bug under newer\n-   versions of win32S.\n- - GC_non_gc_bytes was not correctly maintained by\n-   GC_free.  Fixed.  Thanks to James Clark (jjc@jclark.com).\n- - Added GC_set_max_heap_size.\n- - Changed allocation code to ignore blacklisting if it is preventing\n-   use of a very large block of memory.  This has the advantage\n-   that naive code allocating very large objects is much more\n-   likely to work.  The downside is you might no\n-   longer find out that such code should really use\n-   GC_malloc_ignore_off_page.\n- - Changed GC_printf under win32 to close and reopen the file\n-   between calls.  FAT file systems otherwise make the log file\n-   useless for debugging.\n- - Added GC_try_to_collect and GC_get_bytes_since_gc.  These\n-   allow starting an abortable collection during idle times. \n-   This facility does not require special OS support.  (Thanks to\n-   Michael Spertus of Geodesic Systems for suggesting this.  It was\n-   actually an easy addition.  Kumar Srikantan previously added a similar\n-   facility to a now ancient version of the collector.  At the time\n-   this was much harder, and the result was less convincing.)\n- - Added some support for the Borland development environment.  (Thanks\n-   to John Ellis and Michael Spertus.)\n- - Removed a misfeature from checksums.c that caused unexpected \n-   heap growth.  (Thanks to Scott Schwartz.)\n- - Changed finalize.c to call WARN if it encounters a finalization cycle.\n-   WARN is defined in gc_priv.h to write a message, usually to stdout.\n-   In many environments, this may be inappropriate.\n- - Renamed NO_PARAMS in gc.h to GC_NO_PARAMS, thus adhering to my own\n-   naming convention.\n- - Added GC_set_warn_proc to intercept warnings.\n- - Fixed Amiga port. (Thanks to Michel Schinz (schinz@alphanet.ch).)\n- - Fixed a bug in mark.c that could result in an access to unmapped\n-   memory from GC_mark_from_mark_stack on machines with unaligned\n-   pointers.\n- - Fixed a win32 specific performance bug that could result in scanning of\n-   objects allocated with the system malloc.\n- - Added REDIRECT_MALLOC.\n-\n-Since version 4.4:\n- - Fixed many minor and one major README bugs. (Thanks to Franklin Chen\n-   (chen@adi.com) for pointing out many of them.)\n- - Fixed ALPHA/OSF/1 dynamic library support. (Thanks to Jonathan Bachrach\n-   (jonathan@harlequin.com)).\n- - Added incremental GC support (MPROTECT_VDB) for Linux (with some\n-   help from Bruno Haible).\n- - Altered SPARC recognition tests in gc.h and config.h (mostly as\n-   suggested by Fergus Henderson).\n- - Added basic incremental GC support for win32, as implemented by\n-   Windows NT and Windows 95.  GC_enable_incremental is a noop\n-   under win32s, which doesn't implement enough of the VM interface.\n- - Added -DLARGE_CONFIG.\n- - Fixed GC_..._ignore_off_page to also function without\n-   -DALL_INTERIOR_POINTERS.\n- - (Hopefully) fixed RS/6000 port.  (Only the test was broken.)\n- - Fixed a performance bug in the nonincremental collector running\n-   on machines supporting incremental collection with MPROTECT_VDB\n-   (e.g. SunOS 4, DEC AXP).  This turned into a correctness bug under\n-   win32s with win32 incremental collection.  (Not all memory protection\n-   was disabled.)\n- - Fixed some ppcr related bit rot.\n- - Caused dynamic libraries to be unregistered before reregistering.\n-   The old way turned out to be a performance bug on some machines.\n- - GC_root_size was not properly maintained under MSWIN32.\n- - Added -DNO_DEBUGGING and GC_dump.\n- - Fixed a couple of bugs arising with SOLARIS_THREADS +\n-   REDIRECT_MALLOC.\n- - Added NetBSD/M68K port.  (Thanks to Peter Seebach\n-   <seebs@taniemarie.solon.com>.)\n- - Fixed a serious realloc bug.  For certain object sizes, the collector\n-   wouldn't scan the expanded part of the object.  (Thanks to Clay Spence\n-   (cds@peanut.sarnoff.com) for noticing the problem, and helping me to\n-   track it down.)\n-   \n-Since version 4.5:\n- - Added Linux ELF support.  (Thanks to Arrigo Triulzi <arrigo@ic.ac.uk>.)\n- - GC_base crashed if it was called before any other GC_ routines.\n-   This could happen if a gc_cleanup object was allocated outside the heap\n-   before any heap allocation.\n- - The heap expansion heuristic was not stable if all objects had finalization\n-   enabled.  Fixed finalize.c to count memory in finalization queue and\n-   avoid explicit deallocation.  Changed alloc.c to also consider this count.\n-   (This is still not recommended.  It's expensive if nothing else.)  Thanks\n-   to John Ellis for pointing this out.\n- - GC_malloc_uncollectable(0) was broken.  Thanks to Phong Vo for pointing\n-   this out.\n- - The collector didn't compile under Linux 1.3.X.  (Thanks to Fred Gilham for\n-   pointing this out.)  The current workaround is ugly, but expected to be\n-   temporary.\n- - Fixed a formatting problem for SPARC stack traces.\n- - Fixed some '=='s in os_dep.c that should have been assignments.\n-   Fortunately these were in code that should never be executed anyway.\n-   (Thanks to Fergus Henderson.)\n- - Fixed the heap block allocator to only drop blacklisted blocks in small\n-   chunks.  Made BL_LIMIT self adjusting.  (Both of these were in response\n-   to heap growth observed by Paul Graham.)\n- - Fixed the Metrowerks/68K Mac code to also mark from a6.  (Thanks\n-   to Patrick Beard.)\n- - Significantly updated README.debugging.\n- - Fixed some problems with longjmps out of signal handlers, especially under\n-   Solaris.  Added a workaround for the fact that siglongjmp doesn't appear to\n-   do the right thing with -lthread under Solaris.\n- - Added MSDOS/djgpp port.  (Thanks to Mitch Harris  (maharri@uiuc.edu).)\n- - Added \"make reserved_namespace\" and \"make user_namespace\".  The\n-   first renames ALL \"GC_xxx\" identifiers as \"_GC_xxx\".  The second is the\n-   inverse transformation.  Note that doing this is guaranteed to break all\n-   clients written for the other names.\n- - descriptor field for kind NORMAL in GC_obj_kinds with ADD_BYTE_AT_END\n-   defined should be -ALIGNMENT not WORDS_TO_BYTES(-1).  This is\n-   a serious bug on machines with pointer alignment of less than a word.\n- - GC_ignore_self_finalize_mark_proc didn't handle pointers to very near the\n-   end of the object correctly.  Caused failures of the C++ test on a DEC Alpha\n-   with g++.\n- - gc_inl.h still had problems.  Partially fixed.  Added warnings at the\n-   beginning to hopefully specify the remaining dangers.\n- - Added DATAEND definition to config.h.\n- - Fixed some of the .h file organization.  Fixed \"make floppy\".\n- \n-Since version 4.6:\n- - Fixed some compilation problems with -DCHECKSUMS (thanks to Ian Searle)\n- - Updated some Mac specific files to synchronize with Patrick Beard.\n- - Fixed a serious bug for machines with non-word-aligned pointers.\n-   (Thanks to Patrick Beard for pointing out the problem.  The collector\n-   should fail almost any conceivable test immediately on such machines.)\n-\n-Since version 4.7:\n- - Changed a \"comment\" in a MacOS specific part of mach-dep.c that caused\n-   gcc to fail on other platforms.\n-\n-Since version 4.8\n- - More README.debugging fixes.\n- - Objects ready for finalization, but not finalized in the same GC\n-   cycle, could be prematurely collected.  This occasionally happened\n-   in test_cpp.\n- - Too little memory was obtained from the system for very large\n-   objects.  That could cause a heap explosion if these objects were\n-   not contiguous (e.g. under PCR), and too much of them was blacklisted.\n- - Due to an improper initialization, the collector was too hesitant to\n-   allocate blacklisted objects immediately after system startup.\n- - Moved GC_arrays from the data into the bss segment by not explicitly\n-   initializing it to zero.  This significantly\n-   reduces the size of executables, and probably avoids some disk accesses\n-   on program startup.  It's conceivable that it might break a port that I\n-   didn't test.\n- - Fixed EMX_MAKEFILE to reflect the gc_c++.h to gc_cpp.h renaming which\n-   occurred a while ago.\n-\n-Since 4.9:\n- - Fixed a typo around a call to GC_collect_or_expand in alloc.c.  It broke\n-   handling of out of memory.  (Thanks to Patrick Beard for noticing.)\n-\n-Since 4.10:\n- - Rationalized (hopefully) GC_try_to_collect in an incremental collection\n-   environment.  It appeared to not handle a call while a collection was in\n-   progress, and was otherwise too conservative.\n- - Merged GC_reclaim_or_delete_all into GC_reclaim_all to get rid of some\n-   code.\n- - Added Patrick Beard's Mac fixes, with substantial completely untested\n-   modifications.\n- - Fixed the MPROTECT_VDB code to deal with large pages and imprecise\n-   fault addresses (as on an UltraSPARC running Solaris 2.5).  Note that this\n-   was not a problem in the default configuration, which uses PROC_VDB.\n- - The DEC Alpha assembly code needed to restore $gp between calls.\n-   Thanks to Fergus Henderson for tracking this down and supplying a\n-   patch.\n- - The write command for \"de\" was completely broken for large files.\n-   I used the easiest portable fix, which involved changing the semantics\n-   so that f.new is written instead of overwriting f.  That's safer anyway.\n- - Added README.solaris2 with a discussion of the possible problems of\n-   mixing the collector's sbrk allocation with malloc/realloc.\n- - Changed the data segment starting address for SGI machines.  The\n-   old code failed under IRIX6.\n- - Required double word alignment for MIPS.\n- - Various minor fixes to remove warnings.\n- - Attempted to fix some Solaris threads problems reported by Zhiying Chen.\n-   In particular, the collector could try to fork a thread with the\n-   world stopped as part of GC_thr_init.  It also failed to deal with\n-   the case in which the original thread terminated before the whole\n-   process did.\n- - Added -DNO_EXECUTE_PERMISSION.  This has a major performance impact\n-   on the incremental collector under Irix, and perhaps under other\n-   operating systems.\n- - Added some code to support allocating the heap with mmap.  This may\n-   be preferable under some circumstances.\n- - Integrated dynamic library support for HP.\n-   (Thanks to Knut Tvedten <knuttv@ifi.uio.no>.)\n- - Integrated James Clark's win32 threads support, and made a number\n-   of changes to it, many of which were suggested by Pontus Rydin.\n-   This is still not 100% solid.\n- - Integrated Alistair Crooks' support for UTS4 running on an Amdahl\n-   370-class machine.\n- - Fixed a serious bug in explicitly typed allocation.  Objects requiring\n-   large descriptors where handled in a way that usually resulted in\n-   a segmentation fault in the marker.  (Thanks to Jeremy Fitzhardinge\n-   for helping to track this down.)\n- - Added partial support for GNU win32 development.  (Thanks to Fergus\n-   Henderson.)\n- - Added optional support for Java-style finalization semantics.  (Thanks\n-   to Patrick Bridges.)  This is recommended only for Java implementations.\n- - GC_malloc_uncollectable faulted instead of returning 0 when out of\n-   memory.  (Thanks to dan@math.uiuc.edu for noticing.)\n- - Calls to GC_base before the collector was initialized failed on a\n-   DEC Alpha.  (Thanks to Matthew Flatt.)\n- - Added base pointer checking to GC_REGISTER_FINALIZER in debugging\n-   mode, at the suggestion of Jeremy Fitzhardinge.\n- - GC_debug_realloc failed for uncollectable objects.  (Thanks to\n-   Jeremy Fitzhardinge.)\n- - Explicitly typed allocation could crash if it ran out of memory.\n-   (Thanks to Jeremy Fitzhardinge.)\n- - Added minimal support for a DEC Alpha running Linux.\n- - Fixed a problem with allocation of objects whose size overflowed\n-   ptrdiff_t.  (This now fails unconditionally, as it should.)\n- - Added the beginning of Irix pthread support.\n- - Integrated Xiaokun Zhu's fixes for djgpp 2.01.\n- - Added SGI-style STL allocator support (gc_alloc.h).\n- - Fixed a serious bug in README.solaris2.  Multithreaded programs must include\n-   gc.h with SOLARIS_THREADS defined.\n- - Changed GC_free so it actually deallocates uncollectable objects.\n-   (Thanks to Peter Chubb for pointing out the problem.)\n- - Added Linux ELF support for dynamic libararies.  (Thanks again to\n-   Patrick Bridges.)\n- - Changed the Borland cc configuration so that the assembler is not\n-   required.\n- - Fixed a bug in the C++ test that caused it to fail in 64-bit\n-   environments.\n-\n-Since 4.11:\n- - Fixed ElfW definition in dyn_load.c. (Thanks to Fergus Henderson.)\n-   This prevented the dynamic library support from compiling on some\n-   older ELF Linux systems.\n- - Fixed UTS4 port (which I apparently mangled during the integration)\n-   (Thanks to again to Alistair Crooks.)\n- - \"Make C++\" failed on Suns with SC4.0, due to a problem with \"bool\".\n-   Fixed in gc_priv.h.\n- - Added more pieces for GNU win32.  (Thanks to Timothy N. Newsham.)\n-   The current state of things should suffice for at least some\n-   applications.\n- - Changed the out of memory retry count handling as suggested by\n-   Kenjiro Taura.  (This matters only if GC_max_retries > 0, which\n-   is no longer the default.)\n- - If a /proc read failed repeatedly, GC_written_pages was not updated\n-   correctly.  (Thanks to Peter Chubb for diagnosing this.)\n- - Under unlikely circumstances, the allocator could infinite loop in\n-   an out of memory situation.  (Thanks again to Kenjiro Taura for\n-   identifying the problem and supplying a fix.)\n- - Fixed a syntactic error in the DJGPP code.  (Thanks to Fergus\n-   Henderson for finding this by inspection.)  Also fixed a test program\n-   problem with DJGPP (Thanks to Peter Monks.)\n- - Atomic uncollectable objects were not treated correctly by the\n-   incremental collector.  This resulted in weird log statistics and\n-   occasional performance problems.  (Thanks to Peter Chubb for pointing\n-   this out.)\n- - Fixed some problems resulting from compilers that dont define\n-   __STDC__.  In this case void * and char * were used inconsistently\n-   in some cases.  (Void * should not have been used at all.  If\n-   you have an ANSI superset compiler that does not define __STDC__,\n-   please compile with -D__STDC__=0. Thanks to Manuel Serrano and others\n-   for pointing out the problem.)\n- - Fixed a compilation problem on Irix with -n32 and -DIRIX_THREADS.\n-   Also fixed some other IRIX_THREADS problems which may or may not have\n-   had observable symptoms.\n- - Fixed an HP PA compilation problem in dyn_load.c.  (Thanks to\n-   Philippe Queinnec.)\n- - SEGV fault handlers sometimes did not get reset correctly.  (Thanks\n-   to David Pickens.)\n- - Added a fix for SOLARIS_THREADS on Intel.  (Thanks again to David\n-   Pickens.)  This probably needs more work to become functional.\n- - Fixed struct sigcontext_struct in os_dep.c for compilation under\n-   Linux 2.1.X.\t(Thanks to Fergus Henderson.)\n- - Changed the DJGPP STACKBOTTOM and DATASTART values to those suggested\n-   by Kristian Kristensen.  These may still not be right, but it is\n-   it is likely to work more often than what was there before.  They may\n-   even be exactly right.\n- - Added a #include <string.h> to test_cpp.cc.  This appears to help\n-   with HP/UX and gcc.  (Thanks to assar@sics.se.)\n- - Version 4.11 failed to run in incremental mode on recent 64-bit Irix\n-   kernels.  This was a problem related to page unaligned heap segments.\n-   Changed the code to page align heap sections on all platforms.\n-   (I had mistakenly identified this as a kernel problem earlier.\n-   It was not.)\n- - Version 4.11 did not make allocated storage executable, except on\n-   one or two platforms, due to a bug in a #if test.  (Thanks to Dave\n-   Grove for pointing this out.)\n- - Added sparc_sunos4_mach_dep.s to support Sun's compilers under SunOS4.\n- - Added GC_exclude_static_roots.\n- - Fixed the object size mapping algorithm.  This shouldn't matter,\n-   but the old code was ugly.\n- - Heap checking code could die if one of the allocated objects was\n-   larger than its base address.  (Unsigned underflow problem.  Thanks\n-   to Clay Spence for isolating the problem.)\n- - Added RS6000 (AIX) dynamic library support and fixed STACK_BOTTOM.\n-   (Thanks to Fred Stearns.)\n- - Added Fergus Henderson's patches for improved robustness with large\n-   heaps and lots of blacklisting.\n- - Added Peter Chubb's changes to support Solaris Pthreads, to support\n-   MMAP allocation in Solaris, to allow Solaris to find dynamic libraries\n-   through /proc, to add malloc_typed_ignore_off_page, and a few other\n-   minor features and bug fixes.\n- - The Solaris 2 port should not use sbrk.  I received confirmation from\n-   Sun that the use of sbrk and malloc in the same program is not\n-   supported.  The collector now defines USE_MMAP by default on Solaris.\n- - Replaced the djgpp makefile with Gary Leavens' version.\n- - Fixed MSWIN32 detection test.\n- - Added Fergus Henderson's patches to allow putting the collector into\n-   a DLL under GNU win32.\n- - Added Ivan V. Demakov's port to Watcom C on X86.\n- - Added Ian Piumarta's Linux/PowerPC port.\n- - On Brian Burton's suggestion added PointerFreeGC to the placement\n-   options in gc_cpp.h.  This is of course unsafe, and may be controversial.\n-   On the other hand, it seems to be needed often enough that it's worth\n-   adding as a standard facility.\n-\n-Since 4.12:\n- - Fixed a crucial bug in the Watcom port.  There was a redundant decl\n-   of GC_push_one in gc_priv.h.\n- - Added FINALIZE_ON_DEMAND.\n- - Fixed some pre-ANSI cc problems in test.c.\n- - Removed getpagesize() use for Solaris.  It seems to be missing in one\n-   or two versions.\n- - Fixed bool handling for SPARCCompiler version 4.2.\n- - Fixed some files in include that had gotten unlinked from the main\n-   copy.\n- - Some RS/6000 fixes (missing casts).  Thanks to Toralf Foerster.\n- - Fixed several problems in GC_debug_realloc, affecting mostly the\n-   FIND_LEAK case.\n- - GC_exclude_static_roots contained a buggy unsigned comparison to\n-   terminate a loop.  (Thanks to Wilson Ho.)\n- - CORD_str failed if the substring occurred at the last possible position.\n-   (Only affects cord users.)\n- - Fixed Linux code to deal with RedHat 5.0 and integrated Peter Bigot's\n-   os_dep.c code for dealing with various Linux versions.\n- - Added workaround for Irix pthreads sigaction bug and possible signal\n-   misdirection problems.\n-Since alpha1:\n- - Changed RS6000 STACKBOTTOM.\n- - Integrated Patrick Beard's Mac changes.\n- - Alpha1 didn't compile on Irix m.n, m < 6.\n- - Replaced Makefile.dj with a new one from Gary Leavens.\n- - Added Andrew Stitcher's changes to support SCO OpenServer.\n- - Added PRINT_BLACK_LIST, to allow debugging of high densities of false\n-   pointers.\n- - Added code to debug allocator to keep track of return address\n-   in GC_malloc caller, thus giving a bit more context.\n- - Changed default behavior of large block allocator to more\n-   aggressively avoid fragmentation.  This is likely to slow down the\n-   collector when it succeeds at reducing space cost.\n- - Integrated Fergus Henderson's CYGWIN32 changes.  They are untested,\n-   but needed for newer versions.\n- - USE_MMAP had some serious bugs.  This caused the collector to fail\n-   consistently on Solaris with -DSMALL_CONFIG.\n- - Added Linux threads support, thanks largely to Fergus Henderson.\n-Since alpha2:\n- - Fixed more Linux threads problems.\n- - Changed default GC_free_space_divisor to 3 with new large block allocation.\n-   (Thanks to Matthew Flatt for some measurements that suggest the old\n-   value sometimes favors space too much over time.)\n- - More CYGWIN32 fixes.\n- - Integrated Tyson-Dowd's Linux-M68K port.\n- - Minor HP PA and DEC UNIX fixes from Fergus Henderson.\n- - Integrated Christoffe Raffali's Linux-SPARC changes.\n- - Allowed for one more GC fixup iteration after a full GC in incremental\n-   mode.  Some quick measurements suggested that this significantly\n-   reduces pause times even with smaller GC_RATE values.\n- - Moved some more GC data structures into GC_arrays.  This decreases\n-   pause times and GC overhead, but makes debugging slightly less convenient.\n- - Fixed namespace pollution problem (\"excl_table\").\n- - Made GC_incremental a constant for -DSMALL_CONFIG, hopefully shrinking\n-   that slightly.\n- - Added some win32 threads fixes.\n- - Integrated Ivan Demakov and David Stes' Watcom fixes.\n- - Various other minor fixes contributed by many people.\n- - Renamed config.h to gcconfig.h, since config.h tends to be used for\n-   many other things.\n- - Integrated Matthew Flatt's support for 68K MacOS \"far globals\".\n- - Fixed up some of the dynamic library Makefile targets for consistency\n-   across platforms.\n- - Fixed a USE_MMAP typo that caused out-of-memory handling to fail\n-   on Solaris.\n- - Added code to test.c to test thread creation a bit more.\n- - Integrated GC_win32_free_heap, as suggested by Ivan Demakov.\n- - Fixed Solaris 2.7 stack base finding problem.  (This may actually\n-   have been done in an earlier alpha release.)\n-Since alpha3:\n- - Fixed MSWIN32 recognition test, which interfered with cygwin.\n- - Removed unnecessary gc_watcom.asm from distribution.  Removed\n-   some obsolete README.win32 text.\n- - Added Alpha Linux incremental GC support.  (Thanks to Philipp Tomsich\n-   for code for retrieving the fault address in a signal handler.)\n-   Changed Linux signal handler context argument to be a pointer.\n- - Took care of some new warnings generated by the 7.3 SGI compiler.\n- - Integrated Phillip Musumeci's FreeBSD/ELF fixes.\n- - -DIRIX_THREADS was broken with the -o32 ABI (typo in gc_priv.h>\n-\n-Since 4.13:\n- - Fixed GC_print_source_ptr to not use a prototype.\n- - generalized CYGWIN test.\n- - gc::new did the wrong thing with PointerFreeGC placement.\n-   (Thanks to Rauli Ruohonen.)\n- - In the ALL_INTERIOR_POINTERS (default) case, some callee-save register\n-   values could fail to be scanned if the register was saved and\n-   reused in a GC frame.  This showed up in verbose mode with gctest\n-   compiled with an unreleased SGI compiler.  I vaguely recall an old\n-   bug report that may have been related.  The bug was probably quite old.\n-   (The problem was that the stack scanning could be deferred until\n-   after the relevant frame was overwritten, and the new save location\n-   might be outside the scanned area.  Fixed by more eager stack scanning.)\n- - PRINT_BLACK_LIST had some problems.  A few source addresses were garbage.\n- - Replaced Makefile.dj and added -I flags to cord make targets.\n-   (Thanks to Gary Leavens.)\n- - GC_try_to_collect was broken with the nonincremental collector.\n- - gc_cleanup destructors could pass the wrong address to\n-   GC_register_finalizer_ignore_self in the presence of multiple\n-   inheritance.  (Thanks to Darrell Schiebel.)\n- - Changed PowerPC Linux stack finding code.\n-\n-Since 4.14alpha1\n- - -DSMALL_CONFIG did not work reliably with large (> 4K) pages.\n-   Recycling the mark stack during expansion could result in a size\n-   zero heap segment, which confused things.  (This was probably also an\n-   issue with the normal config and huge pages.)\n- - Did more work to make sure that callee-save registers were scanned\n-   completely, even with the setjmp-based code.  Added USE_GENERIC_PUSH_REGS\n-   macro to facilitate testing on machines I have access to.\n- - Added code to explicitly push register contents for win32 threads.\n-   This seems to be necessary.  (Thanks to Pierre de Rop.)\n-\n-Since 4.14alpha2\n- - changed STACKBOTTOM for DJGPP (Thanks to Salvador Eduardo Tropea).\n- \n-Since 4.14\n- - Reworked large block allocator.  Now uses multiple doubly linked free\n-   lists to approximate best fit.\n- - Changed heap expansion heuristic.  Entirely free blocks are no longer\n-   counted towards the heap size.  This seems to have a major impact on\n-   heap size stability; the old version could expand the heap way too\n-   much in the presence of large block fragmentation.\n- - added -DGC_ASSERTIONS and some simple assertions inside the collector.\n-   This is mainlyt for collector debugging.\n- - added -DUSE_MUNMAP to allow the heap to shrink.  Suupported on only\n-   a few UNIX-like platforms for now.\n- - added GC_dump_regions() for debugging of fragmentation issues.\n- - Changed PowerPC pointer alignment under Linux to 4.  (This needs\n-   checking by someone who has one.  The suggestions came to me via a\n-   rather circuitous path.)\n- - Changed the Linux/Alpha port to walk the data segment backwards until\n-   it encounters a SIGSEGV.  The old way to find the start of the data\n-   segment broke with a recent release.\n- - cordxtra.c needed to call GC_REGISTER_FINALIZER instead of\n-   GC_register_finalizer, so that it would continue to work with GC_DEBUG.\n- - allochblk sometimes cleared the wrong block for debugging purposes\n-   when it dropped blacklisted blocks.  This could result in spurious\n-   error reports with GC_DEBUG.\n- - added MACOS X Server support.  (Thanks to Andrew Stone.)\n- - Changed the Solaris threads code to ignore stack limits > 8 MB with\n-   a warning.  Empirically, it is not safe to access arbitrary pages\n-   in such large stacks.  And the dirty bit implementation does not\n-   guarantee that none of them will be accessed.\n- - Integrated Martin Tauchmann's Amiga changes.\n- - Integrated James Dominy's OpenBSD/SPARC port.\n-\n-Since 5.0alpha1\n- - Fixed bugs introduced in alpha1 (OpenBSD & large block initialization).\n- - Added -DKEEP_BACK_PTRS and backptr.h interface.  (The implementation\n-   idea came from Al Demers.)\n-\n-Since 5.0alpha2\n- - Added some highly incomplete code to support a copied young generation.\n-   Comments on nursery.h are appreciated.\n- - Changed -DFIND_LEAK, -DJAVA_FINALIZATION, and -DFINALIZE_ON_DEMAND,\n-   so the same effect could be obtained with a runtime switch.   This is\n-   a step towards standardizing on a single dynamic GC library.\n- - Significantly changed the way leak detection is handled, as a consequence\n-   of the above.\n-\n-Since 5.0 alpha3\n- - Added protection fault handling patch for Linux/M68K from Fergus\n-   Henderson and Roman Hodek.\n- - Removed the tests for SGI_SOURCE in new_gc_alloc.h.  This was causing that\n-   interface to fail on nonSGI platforms.\n- - Changed the Linux stack finding code to use /proc, after changing it\n-   to use HEURISTIC1.  (Thanks to David Mossberger for pointing out the\n-   /proc hook.)\n- - Added HP/UX incremental GC support and HP/UX 11 thread support.\n-   Thread support is currently still flakey.\n- - Added basic Linux/IA64 support.\n- - Integrated Anthony Green's PicoJava support.\n- - Integrated Scott Ananian's StrongARM/NetBSD support.\n- - Fixed some fairly serious performance bugs in the incremental\n-   collector.  These have probably been there essentially forever.\n-   (Mark bits were sometimes set before scanning dirty pages.\n-   The reclaim phase unnecessarily dirtied full small object pages.)\n- - Changed the reclaim phase to ignore nearly full pages to avoid\n-   touching them.\n- - Limited GC_black_list_spacing to roughly the heap growth increment.\n- - Changed full collection triggering heuristic to decrease full GC\n-   frequency by default, but to explicitly trigger full GCs during\n-   heap growth.  This doesn't always improve things, but on average it's\n-   probably a win.\n- - GC_debug_free(0, ...) failed.  Thanks to Fergus Henderson for the\n-   bug report and fix.\n-\n-Since 5.0 alpha4\n- - GC_malloc_explicitly_typed and friends sometimes failed to\n-   initialize first word.\n- - Added allocation routines and support in the marker for mark descriptors\n-   in a type structure referenced by the first word of an object.  This was\n-   introduced to support gcj, but hopefully in a way that makes it\n-   generically useful.\n- - Added GC_requested_heapsize, and inhibited collections in nonincremental\n-   mode if the actual used heap size is less than what was explicitly\n-   requested.\n- - The Solaris pthreads version of GC_pthread_create didn't handle a NULL\n-   attribute pointer.  Solaris thread support used the wrong default thread\n-   stack size.  (Thanks to Melissa O'Neill for the patch.)\n- - Changed PUSH_CONTENTS macro to no longer modify first parameter.\n-   This usually doesn't matter, but it was certainly an accident waiting\n-   to happen ...\n- - Added GC_register_finalizer_no_order and friends to gc.h.  They're\n-   needed by Java implementations.\n- - Integrated a fix for a win32 deadlock resulting from clock() calling\n-   malloc.  (Thanks to Chris Dodd.)\n- - Integrated Hiroshi Kawashima's port to Linux/MIPS.  This was designed\n-   for a handheld platform, and may or may not be sufficient for other\n-   machines.\n- - Fixed a va_arg problem with the %c specifier in cordprnt.c.  It appears\n-   that this was always broken, but recent versions of gcc are the first to\n-   report the (statically detectable) bug.\n- - Added an attempt at a more general solution to dlopen races/deadlocks.\n-   GC_dlopen now temporarily disables collection.  Still not ideal, but ...\n- - Added -DUSE_I686_PREFETCH, -DUSE_3DNOW_PREFETCH, and support for IA64\n-   prefetch instructions.  May improve performance measurably, but I'm not\n-   sure the code will run correctly on processors that don't support the\n-   instruction.  Won't build except with very recent gcc.\n- - Added caching for header lookups in the marker.  This seems to result\n-   in a barely measurable performance gain.  Added support for interleaved\n-   lookups of two pointers, but unconfigured that since the performance\n-   gain is currently near zero, and it adds to code size.\n- - Changed Linux DATA_START definition to check both data_start and\n-   __data_start, since nothing else seems to be portable.\n- - Added -DUSE_LD_WRAP to optionally take advantage of the GNU ld function\n-   wrapping mechanism.  Probably currently useful only on Linux.\n- - Moved some variables for the scratch allocator into GC_arrays, on\n-   Martin Hirzel's suggestion.\n- - Fixed a win32 threads bug that caused the collector to not look for\n-   interior pointers from one of the thread stacks without\n-   ALL_INTERIOR_POINTERS.  (Thanks to Jeff Sturm.)\n- - Added Mingw32 support.  (Thanks again to Jeff Sturm for the patch.)\n- - Changed the alpha port to use the generic register scanning code instead\n-   of alpha_mach_dep.s.  Alpha_mach_dep.s doesn't look for pointers in fp\n-   registers, but gcc sometimes spills pointers there.  (Thanks to Manuel\n-   Serrano for helping me debug this by email.)  Changed the IA64 code to\n-   do something similar for similar reasons.\n-\n-Since 5.0alpha6:\n- - -DREDIRECT_MALLOC was broken in alpha6. Fixed.\n- - Cleaned up gc_ccp.h slightly, thus also causing the HP C++ compiler to\n-   accept it.\n- - Removed accidental reference to dbg_mlc.c, which caused dbg_mlc.o to be\n-   linked into every executable.\n- - Added PREFETCH to bitmap marker.  Changed it to use the header cache.\n- - GC_push_marked sometimes pushed one object too many, resulting in a\n-   segmentation fault in GC_mark_from_mark_stack.  This was probably an old\n-   bug.  It finally showed up in gctest on win32.\n- - Gc_priv.h erroneously #defined GC_incremental to be TRUE instead of FALSE\n-   when SMALL_CONFIG was defined.  This was no doubt a major performance bug for\n-   the default win32 configuration.\n- - Removed -DSMALL_CONFIG from NT_MAKEFILE.  It seemed like an anchronism now\n-   that the average PC has 64MB or so.\n- - Integrated Bryce McKinley's patches for linux threads and dynamic loading\n-   from the libgcj tree.  Turned on dynamic loading support for Linux/PPC.\n- - Changed the stack finding code to use environ on HP/UX.  (Thanks\n-   to Gustavo Rodriguez-Rivera for the suggestion.)  This should probably\n-   be done on other platforms, too.  Since I can't test those, that'll\n-   wait until after 5.0.\n-\n-Since 5.0alpha7:\n- - Fixed threadlibs.c for linux threads.  -DUSE_LD_WRAP was broken and\n-   -ldl was omitted.  Fixed Linux stack finding code to handle\n-   -DUSE_LD_WRAP correctly.\n- - Added MSWIN32 exception handler around marker, so that the collector\n-   can recover from root segments that are unmapped during the collection.\n-   This caused occasional failures under Windows 98, and may also be\n-   an issue under Windows NT/2000.\n-\n-Since 5.0\n- - Fixed a gc.h header bug which showed up under Irix.  (Thanks to\n-   Dan Sullivan.)\n- - Fixed a typo in GC_double_descr in typd_mlc.c not getting traced correctly.\n-   This probably could result in objects described by array descriptors not\n-   getting traced correctly.  (Thanks to Ben Hutchings for pointing this out.)\n- - The block nearly full tests in reclaim.c were not correct for 64 bit\n-   environments.  This could result in unnecessary heap growth under unlikely\n-   conditions.\n- - Removed use of CLEAR_DOUBLE from generic reclaim code, since odd sizes\n-   could occur.\n-\n-To do:\n- - Integrate Linux/SPARC fixes.\n- - Very large root set sizes (> 16 MB or so) could cause the collector\n-   to abort with an unexpected mark stack overflow.  (Thanks again to\n-   Peter Chubb.)  NOT YET FIXED.  Workaround is to increase the initial\n-   size.\n- - The SGI version of the collector marks from mmapped pages, even\n-   if they are not part of dynamic library static data areas.  This\n-   causes performance problems with some SGI libraries that use mmap\n-   as a bitmap allocator.  NOT YET FIXED.  It may be possible to turn\n-   off DYNAMIC_LOADING in the collector as a workaround.  It may also\n-   be possible to conditionally intercept mmap and use GC_exclude_static_roots.\n-   The real fix is to walk rld data structures, which looks possible.\n- - Integrate MIT and DEC pthreads ports.\n- - Incremental collector should handle large objects better.  Currently,\n-   it looks like the whole object is treated as dirty if any part of it\n-   is.\n- - Cord/cordprnt.c doesn't build on a few platforms (notably PowerPC), since\n-   we make some unwarranted assumptions about how varargs are handled.  This\n-   currently makes the cord-aware versions of printf unusable on some platforms.\n-   Fixing this is unfortunately not trivial."}, {"sha": "04f468251a1e5f4b94181f9e6ad085b96e8ff442", "filename": "boehm-gc/README.Mac", "status": "removed", "additions": 0, "deletions": 385, "changes": 385, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6951ca5dee8ed05749cdc697767910aebaedcc0/boehm-gc%2FREADME.Mac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6951ca5dee8ed05749cdc697767910aebaedcc0/boehm-gc%2FREADME.Mac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FREADME.Mac?ref=a6951ca5dee8ed05749cdc697767910aebaedcc0", "patch": "@@ -1,385 +0,0 @@\n-Patrick Beard's Notes for building GC v4.12 with CodeWarrior Pro 2:\n-----------------------------------------------------------------------------\n-The current build environment for the collector is CodeWarrior Pro 2.\n-Projects for CodeWarrior Pro 2 (and for quite a few older versions)\n-are distributed in the file Mac_projects.sit.hqx. The project file\n-:Mac_projects:gc.prj builds static library versions of the collector.\n-:Mac_projects:gctest.prj builds the GC test suite.\n-\n-Configuring the collector is still done by editing the files\n-:Mac_files:MacOS_config.h and :Mac_files:MacOS_Test_config.h.\n-\n-Lars Farm's suggestions on building the collector:\n-----------------------------------------------------------------------------\n-Garbage Collection on MacOS - a manual 'MakeFile'\n--------------------------------------------------\n-\n-Project files and IDE's are great on the Macintosh, but they do have\n-problems when used as distribution media. This note tries to provide\n-porting instructions in pure TEXT form to avoid those problems. A manual\n-'makefile' if you like.\n-\n-    GC version:     4.12a2\n-    Codewarrior:    CWPro1\n-    date:           18 July 1997\n-\n-The notes may or may not apply to earlier or later versions of the\n-GC/CWPro. Actually, they do apply to earlier versions of both except that\n-until recently a project could only build one target so each target was a\n-separate project. The notes will most likely apply to future versions too.\n-Possibly with minor tweaks.\n-\n-This is just to record my experiences. These notes do not mean I now\n-provide a supported port of the GC to MacOS. It works for me. If it works\n-for you, great. If it doesn't, sorry, try again...;-) Still, if you find\n-errors, please let me know.\n-\n-    mailto:         lars.farm@ite.mh.se\n-\n-    address:        Lars Farm\n-                    Kr\ufffdnv\ufffdgen 33b\n-                    856 44 Sundsvall\n-                    Sweden\n-\n-Porting to MacOS is a bit more complex than it first seems. Which MacOS?\n-68K/PowerPC? Which compiler? Each supports both 68K and PowerPC and offer a\n-large number of (unique to each environment) compiler settings. Each\n-combination of compiler/68K/PPC/settings require a unique combination of\n-standard libraries. And the IDE's does not select them for you. They don't\n-even check that the library is built with compatible setting and this is\n-the major source of problems when porting the GC (and otherwise too).\n-\n-You will have to make choices when you configure the GC. I've made some\n-choices here, but there are other combinations of settings and #defines\n-that work too.\n-\n-As for target settings the major obstacles may be:\n-- 68K Processor: check \"4-byte Ints\".\n-- PPC Processor: uncheck \"Store Static Data in TOC\".\n-\n-What you need to do:\n-===================\n-\n-1) Build the GC as a library\n-2) Test that the library works with 'test.c'.\n-3) Test that the C++ interface 'gc_cpp.cc/h' works with 'test_cpp.cc'.\n-\n-1) The Libraries:\n-=================\n-I made one project with four targets (68K/PPC tempmem or appheap). One target\n-will suffice if you're able to decide which one you want. I wasn't...\n-\n-Codewarrior allows a large number of compiler/linker settings. I used these:\n-\n-Settings shared by all targets:\n-------------------------------\n-o Access Paths:\n-  - User Paths:   the GC folder\n-  - System Paths: {Compiler}:Metrowerks Standard Library:\n-                  {Compiler}:MacOS Support:Headers:\n-                  {Compiler}:MacOS Support:MacHeaders:\n-o C/C++ language:\n-  - inlining: normal\n-  - direct to SOM: off\n-  - enable/check: exceptions, RTTI, bool (and if you like pool strings)\n-\n-PowerPC target settings\n------------------------\n-o Target Settings:\n-  - name of target\n-  - MacOS PPC Linker\n-o PPC Target\n-  - name of library\n-o C/C++ language\n-  - prefix file as described below\n-o PPC Processor\n-  - Struct Alignment: PowerPC\n-  - uncheck \"Store Static Data in TOC\" -- important!\n-    I don't think the others matter, I use full optimization and its ok\n-o PPC Linker\n-  - Factory Settings (SYM file with full paths, faster linking, dead-strip\n-    static init, Main: __start)\n-\n-\n-68K target settings\n--------------------\n-o Target Settings:\n-  - name of target\n-  - MacOS 68K Linker\n-o 68K Target\n-  - name of library\n-  - A5 relative data\n-o C/C++ language\n-  - prefix file as described below\n-o 68K Processor\n-  - Code model: smart\n-  - Struct alignment: 68K\n-  - FP: SANE\n-  - enable 4-Byte Ints -- important!\n-    I don't think the others matter. I selected...\n-  - enable: 68020\n-  - enable: global register allocation\n-o IR Optimizer\n-  - enable: Optimize Space, Optimize Speed\n-    I suppose the others would work too, but haven't tried...\n-o 68K Linker\n-  - Factory Settings (New Style MacsBug,SYM file with full paths,\n-    A6 Frames, fast link, Merge compiler glue into segment 1,\n-    dead-strip static init)\n-\n-Prefix Files to configure the GC sources\n-----------------------------------------\n-The Codewarrior equivalent of commandline compilers -DNAME=X is to use\n-prefix-files. A TEXT file that is automatically #included before the first byte\n-of every source file. I used these:\n-\n----- ( cut here ) ----  gc_prefix_tempmem.h     -- 68K and PPC -----\n-    #include \"gc_prefix_common.h\"\n-    #undef USE_TEMPORARY_MEMORY\n-    #define USE_TEMPORARY_MEMORY\n----- ( cut here ) ----  gc_prefix_appmem.h      -- 68K and PPC -----\n-    #include \"gc_prefix_common.h\"\n-    #undef USE_TEMPORARY_MEMORY\n-//  #define USE_TEMPORARY_MEMORY\n-\n----- ( cut here ) ----  gc_prefix_common.h      --------------------\n-// gc_prefix_common.h\n-// ------------------\n-// Codewarrior prefix file to configure the GC libraries\n-//\n-//   prefix files are the Codewarrior equivalent of the\n-//   command line option -Dname=x frequently seen in makefiles\n-\n-#if !__MWERKS__\n-  #error only tried this with Codewarrior\n-#endif\n-\n-#if macintosh\n-  #define MSL_USE_PRECOMPILED_HEADERS 0\n-  #include <ansi_prefix.mac.h>\n-  #ifndef __STDC__\n-    #define __STDC__ 0\n-  #endif\n-\n-  //  See list of #defines to configure the library in: 'MakeFile'\n-  //  see also README\n-\n-  #define SILENT                // no collection messages. In case\n-                                // of trouble you might want this off\n-  #define ALL_INTERIOR_POINTERS // follows interior pointers.\n-//#define DONT_ADD_BYTE_AT_END  // disables the padding if defined.\n-//#define SMALL_CONFIG          // whether to use a smaller heap.\n-  #define NO_SIGNALS            // signals aren't real on the Macintosh.\n-  #define ATOMIC_UNCOLLECTABLE  // GC_malloc_atomic_uncollectable()\n-\n-  // define either or none as per personal preference\n-  //   used in malloc.c\n-  #define REDIRECT_MALLOC GC_malloc\n-//#define REDIRECT_MALLOC GC_malloc_uncollectable\n-  // if REDIRECT_MALLOC is #defined make sure that the GC library\n-  // is listed before the ANSI/ISO libs in the Codewarrior\n-  // 'Link order' panel\n-//#define IGNORE_FREE\n-\n-  // mac specific configs\n-//#define USE_TEMPORARY_MEMORY    // use Macintosh temporary memory.\n-//#define SHARED_LIBRARY_BUILD    // build for use in a shared library.\n-\n-#else\n-  // could build Win32 here too, or in the future\n-  // Rhapsody PPC-mach, Rhapsody PPC-MacOS,\n-  // Rhapsody Intel-mach, Rhapsody Intel-Win32,...\n-  // ... ugh this will get messy ...\n-#endif\n-\n-// make sure ints are at least 32-bit\n-// ( could be set to 16-bit by compiler settings (68K) )\n-\n-struct gc_private_assert_intsize_{ char x[ sizeof(int)>=4 ? 1 : 0 ]; };\n-\n-#if __powerc\n-  #if __option(toc_data)\n-    #error turn off \"store static data in TOC\" when using GC\n-    //     ... or find a way to add TOC to the root set...(?)\n-  #endif\n-#endif\n----- ( cut here ) ----  end of gc_prefix_common.h  -----------------\n-\n-Files to  build the GC libraries:\n---------------------------------\n-    allchblk.c\n-    alloc.c\n-    blacklst.c\n-    checksums.c\n-    dbg_mlc.c\n-    finalize.c\n-    headers.c\n-    mach_dep.c\n-    MacOS.c    -- contains MacOS code\n-    malloc.c\n-    mallocx.c\n-    mark.c\n-    mark_rts.c\n-    misc.c\n-    new_hblk.c\n-    obj_map.c\n-    os_dep.c   -- contains MacOS code\n-    ptr_chck.c\n-    reclaim.c\n-    stubborn.c\n-    typd_mlc.c\n-    gc++.cc    -- this is 'gc_cpp.cc' with less 'inline' and\n-               -- throw std::bad_alloc when out of memory\n-               -- gc_cpp.cc works just fine too\n-\n-2) Test that the library works with 'test.c'.\n-=============================================\n-\n-The test app is just an ordinary ANSI-C console app. Make sure settings\n-match the library you're testing.\n-\n-Files\n------\n-    test.c\n-    the GC library to test        -- link order before ANSI libs\n-    suitable Mac+ANSI libraries\n-\n-prefix:\n-------\n----- ( cut here ) ----  gc_prefix_testlib.h     -- all libs -----\n-#define MSL_USE_PRECOMPILED_HEADERS 0\n-#include <ansi_prefix.mac.h>\n-#undef NDEBUG\n-\n-#define ALL_INTERIOR_POINTERS\t/* for GC_priv.h */\n----- ( cut here ) ----\n-\n-3) Test that the C++ interface 'gc_cpp.cc/h' works with 'test_cpp.cc'.\n-\n-The test app is just an ordinary ANSI-C console app. Make sure settings match\n-the library you're testing.\n-\n-Files\n------\n-    test_cpp.cc\n-    the GC library to test        -- link order before ANSI libs\n-    suitable Mac+ANSI libraries\n-\n-prefix:\n-------\n-same as for test.c\n-\n-For convenience I used one test-project with several targets so that all\n-test apps are build at once. Two for each library to test: test.c and\n-gc_app.cc. When I was satisfied that the libraries were ok. I put the\n-libraries + gc.h + the c++ interface-file in a folder that I then put into\n-the MSL hierarchy so that I don't have to alter access-paths in projects\n-that use the GC.\n-\n-After that, just add the proper GC library to your project and the GC is in\n-action! malloc will call GC_malloc and free GC_free, new/delete too. You\n-don't have to call free or delete. You may have to be a bit cautious about\n-delete if you're freeing other resources than RAM. See gc_cpp.h. You can\n-also keep coding as always with delete/free. That works too. If you want,\n-\"include <gc.h> and tweak it's use a bit.\n-\n-Symantec SPM\n-============\n-It has been a while since I tried the GC in SPM, but I think that the above\n-instructions should be sufficient to guide you through in SPM too. SPM\n-needs to know where the global data is. Use the files 'datastart.c' and\n-'dataend.c'. Put 'datastart.c' at the top of your project and 'dataend.c'\n-at the bottom  of your project so that all data is surrounded. This is not\n-needed in Codewarrior because it provides intrinsic variables\n-__datastart__, __data_end__ that wraps all globals.\n-\n-Source Changes (GC 4.12a2)\n-==========================\n-Very few. Just one tiny in the GC, not strictly needed.\n-- MacOS.c line 131 in routine GC_MacFreeTemporaryMemory()\n-  change #       if !defined(SHARED_LIBRARY_BUILD)\n-  to     #       if !defined(SILENT) && !defined(SHARED_LIBRARY_BUILD)\n-  To turn off a message when the application quits (actually, I faked\n-  this change by #defining SHARED_LIBRARY_BUILD in a statically linked\n-  library for more than a year without ill effects but perhaps this is\n-  better).\n-\n-- test_cpp.cc\n-  made the first lines of main() look like this:\n-  ------------\n-  int main( int argc, char* argv[] ) {\n-  #endif\n-  #if macintosh                             // MacOS\n-    char* argv_[] = {\"test_cpp\",\"10\"};      //   doesn't\n-    argv=argv_;                             //     have a\n-    argc = sizeof(argv_)/sizeof(argv_[0]);  //       commandline\n-  #endif                                    //\n-\n-  int i, iters, n;\n-  # ifndef __GNUC__\n-   alloc dummy_to_fool_the_compiler_into_doing_things_it_currently_cant_handle;\n-  ------------\n-\n-- config.h [now gcconfig.h]\n-  __MWERKS__ does not have to mean MACOS. You can use Codewarrior to\n-  build a Win32 or BeOS library and soon a Rhapsody library. You may\n-  have to change that #if...\n-\n-\n-\n-   It worked for me, hope it works for you.\n-\n-   Lars Farm\n-   18 July 1997\n-----------------------------------------------------------------------------\n-\n-\n-Patrick Beard's instructions (may be dated):\n-\n-v4.3 of the collector now runs under Symantec C++/THINK C v7.0.4, and\n-Metrowerks C/C++ v4.5 both 68K and PowerPC. Project files are provided\n-to build and test the collector under both development systems.\n-\n-Configuration\n--------------\n-\n-To configure the collector, under both development systems, a prefix file\n-is used to set preprocessor directives. This file is called \"MacOS_config.h\".\n-Also to test the collector, \"MacOS_Test_config.h\" is provided.\n-\n-Testing\n--------\n-\n-To test the collector (always a good idea), build one of the gctest projects,\n-gctest.\ufffd (Symantec C++/THINK C), mw/gctest.68K.\ufffd, or mw/gctest.PPC.\ufffd. The\n-test will ask you how many times to run; 1 should be sufficient.\n-\n-Building \n---------\n-\n-For your convenience project files for the major Macintosh development\n-systems are provided.\n-\n-For Symantec C++/THINK C, you must build the two projects gclib-1.\ufffd and\n-gclib-2.\ufffd. It has to be split up because the collector has more than 32k\n-of static data and no library can have more than this in the Symantec\n-environment. (Future versions will probably fix this.)\n-\n-For Metrowerks C/C++ 4.5 you build gc.68K.\ufffd/gc.PPC.\ufffd and the result will\n-be a library called gc.68K.lib/gc.PPC.lib.\n-\n-Using\n------\n-\n-Under Symantec C++/THINK C, you can just add the gclib-1.\ufffd and gclib-2.\ufffd\n-projects to your own project. Under Metrowerks, you add gc.68K.lib or\n-gc.PPC.lib and two additional files. You add the files called datastart.c\n-and dataend.c to your project, bracketing all files that use the collector.\n-See mw/gctest.\ufffd for an example.\n-\n-Include the projects/libraries you built above into your own project,\n-#include \"gc.h\", and call GC_malloc. You don't have to call GC_free.\n-\n-\n-Patrick C. Beard\n-January 4, 1995"}, {"sha": "5345bbd0f654592d01fcb0f4a6ae5fb1cac0170a", "filename": "boehm-gc/README.OS2", "status": "removed", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6951ca5dee8ed05749cdc697767910aebaedcc0/boehm-gc%2FREADME.OS2", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6951ca5dee8ed05749cdc697767910aebaedcc0/boehm-gc%2FREADME.OS2", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FREADME.OS2?ref=a6951ca5dee8ed05749cdc697767910aebaedcc0", "patch": "@@ -1,6 +0,0 @@\n-The code assumes static linking, and a single thread.  The editor de has\n-not been ported.  The cord test program has.  The supplied OS2_MAKEFILE\n-assumes the IBM C Set/2 environment, but the code shouldn't.\n-\n-Since we haven't figured out hoe to do perform partial links or to build static\n-libraries, clients currently need to link against a long list of executables."}, {"sha": "ddebf82ca50b7cb3b9b4baa31f4f5d37d887418d", "filename": "boehm-gc/README.QUICK", "status": "removed", "additions": 0, "deletions": 43, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6951ca5dee8ed05749cdc697767910aebaedcc0/boehm-gc%2FREADME.QUICK", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6951ca5dee8ed05749cdc697767910aebaedcc0/boehm-gc%2FREADME.QUICK", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FREADME.QUICK?ref=a6951ca5dee8ed05749cdc697767910aebaedcc0", "patch": "@@ -1,43 +0,0 @@\n-Copyright 1988, 1989 Hans-J. Boehm, Alan J. Demers\n-Copyright (c) 1991-1995 by Xerox Corporation.  All rights reserved.\n-Copyright (c) 1996-1999 by Silicon Graphics.  All rights reserved.\n-Copyright (c) 1999 by Hewlett-Packard. All rights reserved.\n-\n-THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n-OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n-\n-Permission is hereby granted to use or copy this program\n-for any purpose,  provided the above notices are retained on all copies.\n-Permission to modify the code and to distribute modified code is granted,\n-provided the above notices are retained, and a notice that the code was\n-modified is included with the above copyright notice.\n-\n-\n-For more details and the names of other contributors, see the\n-README file and gc.h.  This file describes typical use of\n-the collector on a machine that is already supported.\n-\n-INSTALLATION:\n-Under UN*X, type \"make test\".  Under OS/2 or Windows NT, copy the\n-appropriate makefile to MAKEFILE, read it, and type \"nmake test\".\n-Read the machine specific README if one exists.  The only way to\n-develop code with the collector for Windows 3.1 is to develop under\n-Windows NT, and then to use win32S.\n-\n-If you wish to use the cord (structured string) library type\n-\"make cords\". (This requires an ANSI C compiler.  You may need\n-to redefine CC in the Makefile.)\n-\n-If you wish to use the collector from C++, type\n-\"make c++\".  These add further files to gc.a and to the include\n-subdirectory.  See cord/cord.h and gc_c++.h.\n-\n-TYPICAL USE:\n-Include \"gc.h\" from this directory.  Link against the appropriate library\n-(\"gc.a\" under UN*X).  Replace calls to malloc by calls to GC_MALLOC,\n-and calls to realloc by calls to GC_REALLOC.  If the object is known\n-to never contain pointers, use GC_MALLOC_ATOMIC instead of\n-GC_MALLOC.\n-\n-Define GC_DEBUG before including gc.h for additional checking.\n-"}, {"sha": "213a13e3fef62f21a551119826908bacdceb2e8a", "filename": "boehm-gc/README.alpha", "status": "removed", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6951ca5dee8ed05749cdc697767910aebaedcc0/boehm-gc%2FREADME.alpha", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6951ca5dee8ed05749cdc697767910aebaedcc0/boehm-gc%2FREADME.alpha", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FREADME.alpha?ref=a6951ca5dee8ed05749cdc697767910aebaedcc0", "patch": "@@ -1,22 +0,0 @@\n-Should work under OSF/1 and Linux.  Currently no VMS or NT support, though\n-the latter shouldn't be hard.\n-\n-Incremental gc not yet supported under Linux because signal handler\n-for SIGSEGV can't get a hold of fault address.  Dynamic library support\n-is also missing from Linux/alpha, probably for no good reason.\n-\n-Currently there is no thread support in the standard distribution.  There\n-exists a separate port to DEC Unix pthreads.  It should be possible to\n-port the X86 Linux threads support to Alpha without much trouble.\n-\n-If you get asssembler errors, be sure to read the first few lines of the\n-Makefile.\n-\n-From Philippe Queinnec:\n-\n-System: DEC/Alpha OSF1 v3.2, vendor cc\n-Problem: can't link if libgc has been compiled with \"cc -std1\".\n-         It works if the library has been compiled with either gcc or \"cc\"\n-         alone. The problem is because the variable \"end\" is not defined if\n-         compiling in std1 mode (see man ld).\n-Proposed fix: none. Don't use cc -std1 !"}, {"sha": "47b15884354e558f5d8423d4c3212d84b8464788", "filename": "boehm-gc/README.amiga", "status": "removed", "additions": 0, "deletions": 180, "changes": 180, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6951ca5dee8ed05749cdc697767910aebaedcc0/boehm-gc%2FREADME.amiga", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6951ca5dee8ed05749cdc697767910aebaedcc0/boehm-gc%2FREADME.amiga", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FREADME.amiga?ref=a6951ca5dee8ed05749cdc697767910aebaedcc0", "patch": "@@ -1,180 +0,0 @@\n-===========================================================================\n-\t\t\t   Martin Tauchmann's notes\t\t(1-Apr-99)\n-===========================================================================\n-\n-Works now, also with the GNU-C compiler V2.7.2.1. <ftp://ftp.unina.it/pub/amiga/geekgadgets/amiga/m68k/snapshots/971125/amiga-bin/>\n-Modify the `Makefile`\n-CC=cc $(ABI_FLAG)\n-to\n-CC=gcc $(ABI_FLAG)\n-\n-TECHNICAL NOTES\n-\n-- `GC_get_stack_base()`, `GC_register_data_segments()` works now with every\n-   C compiler; also Workbench.\n-\n-- Removed AMIGA_SKIP_SEG, but the Code-Segment must not be scanned by GC.\n-\n-\n-PROBLEMS\n-- When the Linker, does`t merge all Code-Segments to an single one. LD of GCC\n-  do it always.\n-\n-- With ixemul.library V47.3, when an GC program launched from another program\n-  (example: `Make` or `if_mach M68K AMIGA gctest`), `GC_register_data_segments()`\n-  found the Segment-List of the caller program.\n-  Can be fixed, if the run-time initialization code (for C programs, usually *crt0*)\n-  support `__data` and `__bss`.\n-\n-- PowerPC Amiga currently not supported.\n-\n-- Dynamic libraries (dyn_load.c) not supported.\n-\n-\n-TESTED WITH SOFTWARE\n-\n-`Optimized Oberon 2 C` (oo2c) <http://cognac.informatik.uni-kl.de/download/index.html>\n-\n-\n-TESTED WITH HARDWARE\n-\n-MC68030\n-\n-\n-CONTACT\n-\n-Please, contact me at <martintauchmann@bigfoot.com>, when you change the\n-Amiga port. <http://martintauchmann.home.pages.de>\n- \n-===========================================================================\n-\t\t\t   Michel Schinz's notes\n-===========================================================================\n-WHO DID WHAT\n-\n-The original Amiga port was made by Jesper Peterson. I (Michel Schinz)\n-modified it slightly to reflect the changes made in the new official\n-distributions, and to take advantage of the new SAS/C 6.x features. I also\n-created a makefile to compile the \"cord\" package (see the cord\n-subdirectory).\n-\n-TECHNICAL NOTES\n-\n-In addition to Jesper's notes, I have the following to say:\n-\n-- Starting with version 4.3, gctest checks to see if the code segment is\n-  added to the root set or not, and complains if it is. Previous versions\n-  of this Amiga port added the code segment to the root set, so I tried to\n-  fix that. The only problem is that, as far as I know, it is impossible to\n-  know which segments are code segments and which are data segments (there\n-  are indeed solutions to this problem, like scanning the program on disk\n-  or patch the LoadSeg functions, but they are rather complicated). The\n-  solution I have chosen (see os_dep.c) is to test whether the program\n-  counter is in the segment we are about to add to the root set, and if it\n-  is, to skip the segment. The problems are that this solution is rather\n-  awkward and that it works only for one code segment. This means that if\n-  your program has more than one code segment, all of them but one will be\n-  added to the root set. This isn't a big problem in fact, since the\n-  collector will continue to work correctly, but it may be slower.\n-\n-  Anyway, the code which decides whether to skip a segment or not can be\n-  removed simply by not defining AMIGA_SKIP_SEG. But notice that if you do\n-  so, gctest will complain (it will say that \"GC_is_visible produced wrong\n-  failure indication\"). However, it may be useful if you happen to have\n-  pointers stored in a code segment (you really shouldn't).\n-\n-  If anyone has a good solution to the problem of finding, when a program\n-  is loaded in memory, whether a segment is a code or a data segment,\n-  please let me know.\n-\n-PROBLEMS\n-\n-If you have any problem with this version, please contact me at\n-schinz@alphanet.ch (but do *not* send long files, since we pay for\n-every mail!).\n-\n-===========================================================================\n-\t\t\t  Jesper Peterson's notes\n-===========================================================================\n-\n-ADDITIONAL NOTES FOR AMIGA PORT\n-\n-These notes assume some familiarity with Amiga internals.\n-\n-WHY I PORTED TO THE AMIGA\n-\n-The sole reason why I made this port was as a first step in getting\n-the Sather(*) language on the Amiga. A port of this language will\n-be done as soon as the Sather 1.0 sources are made available to me.\n-Given this motivation, the garbage collection (GC) port is rather\n-minimal.\n-\n-(*) For information on Sather read the comp.lang.sather newsgroup.\n-\n-LIMITATIONS\n-\n-This port assumes that the startup code linked with target programs\n-is that supplied with SAS/C versions 6.0 or later. This allows\n-assumptions to be made about where to find the stack base pointer\n-and data segments when programs are run from WorkBench, as opposed\n-to running from the CLI. The compiler dependent code is all in the\n-GC_get_stack_base() and GC_register_data_segments() functions, but\n-may spread as I add Amiga specific features.\n-\n-Given that SAS/C was assumed, the port is set up to be built with\n-\"smake\" using the \"SMakefile\". Compiler options in \"SCoptions\" can\n-be set with \"scopts\" program. Both \"smake\" and \"scopts\" are part of\n-the SAS/C commercial development system.\n-\n-In keeping with the porting philosophy outlined above, this port\n-will not behave well with Amiga specific code. Especially not inter-\n-process comms via messages, and setting up public structures like\n-Intuition objects or anything else in the system lists. For the\n-time being the use of this library is limited to single threaded\n-ANSI/POSIX  compliant or near-complient code. (ie. Stick to stdio\n-for now). Given this limitation there is currently no mechanism for\n-allocating \"CHIP\" or \"PUBLIC\" memory under the garbage collector.\n-I'll add this after giving it considerable thought. The major\n-problem is the entire physical address space may have to me scanned,\n-since there is no telling who we may have passed memory to.\n-\n-If you allocate your own stack in client code, you will have to\n-assign the pointer plus stack size to GC_stackbottom.\n-\n-The initial stack size of the target program can be compiled in by\n-setting the __stack symbol (see SAS documentaion). It can be over-\n-ridden from the CLI by running the AmigaDOS \"stack\" program, or from\n-the WorkBench by setting the stack size in the tool types window.\n-\n-SAS/C COMPILER OPTIONS (SCoptions)\n-\n-You may wish to check the \"CPU\" code option is appropriate for your\n-intended target system.\n-\n-Under no circumstances set the \"StackExtend\" code option in either\n-compiling the library or *ANY* client code.\n-\n-All benign compiler warnings have been suppressed. These mainly\n-involve lack of prototypes in the code, and dead assignments\n-detected by the optimizer.\n-\n-THE GOOD NEWS\n-\n-The library as it stands is compatible with the GigaMem commercial\n-virtual memory software, and probably similar PD software.\n-\n-The performance of \"gctest\" on an Amiga 2630 (68030 @ 25Mhz)\n-compares favourably with an HP9000 with similar architecture (a 325\n-with a 68030 I think).\n-\n------------------------------------------------------------------------\n-\n-The Amiga port has been brought to you by:\n-\n-Jesper Peterson.\n-\n-jep@mtiame.mtia.oz.au\t\t(preferred, but 1 week turnaround)\n-jep@orca1.vic.design.telecom.au (that's orca<one>, 1 day turnaround)\n-\n-At least one of these addresses should be around for a while, even\n-though I don't work for either of the companies involved.\n-"}, {"sha": "f4dd65676aae5472806217081aae77aa1dd52ec7", "filename": "boehm-gc/README.debugging", "status": "removed", "additions": 0, "deletions": 68, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6951ca5dee8ed05749cdc697767910aebaedcc0/boehm-gc%2FREADME.debugging", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6951ca5dee8ed05749cdc697767910aebaedcc0/boehm-gc%2FREADME.debugging", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FREADME.debugging?ref=a6951ca5dee8ed05749cdc697767910aebaedcc0", "patch": "@@ -1,68 +0,0 @@\n-Debugging suggestions:\n-\n-****If you get a segmentation fault or bus error while debugging with a debugger:\n-If the fault occurred in GC_find_limit, or with incremental collection enabled, this is probably normal.  The collector installs handlers to take care of these.  You will not see these unless you are using a debugger.  Your debugger should allow you to continue.  It's preferable to tell the debugger to ignore SIGBUS and SIGSEGV (\"handle\" in gdb, \"ignore\" in most versions of dbx) and set a breakpoint in abort.  The collector will call abort if the signal had another cause, and there was not other handler previously installed.  I recommend debugging without incremental collection if possible.  (This applies directly to UNIX systems.  Debugging with incremental collection under win32 is worse.  See README.win32.)  \n-\n-****If you get warning messages informing you that the collector needed to allocate blacklisted blocks:\n-\n-0) Ignore these warnings while you are using GC_DEBUG.  Some of the routines mentioned below don't have debugging equivalents.  (Alternatively, write the missing routines and send them to me.)\n-\n-1) Replace allocator calls that request large blocks with calls to GC_malloc_ignore_off_page or GC_malloc_atomic_ignore_off_page.  You may want to set a breakpoint in GC_default_warn_proc to help you identify such calls.  Make sure that a pointer to somewhere near the beginning of the resulting block is maintained in a (preferably volatile) variable as long as the block is needed.\n-\n-2) If the large blocks are allocated with realloc, I suggest instead allocating them with something like the following.  Note that the realloc size increment should be fairly large (e.g. a factor of 3/2) for this to exhibit reasonable performance.  But we all know we should do that anyway.\n-\n-void * big_realloc(void *p, size_t new_size)\n-{\n-    size_t old_size = GC_size(p);\n-    void * result;\n- \n-    if (new_size <= 10000) return(GC_realloc(p, new_size));\n-    if (new_size <= old_size) return(p);\n-    result = GC_malloc_ignore_off_page(new_size);\n-    if (result == 0) return(0);\n-    memcpy(result,p,old_size);\n-    GC_free(p);\n-    return(result);\n-}\n-\n-3) In the unlikely case that even relatively small object (<20KB) allocations are triggering these warnings, then your address space contains lots of \"bogus pointers\", i.e. values that appear to be pointers but aren't.  Usually this can be solved by using GC_malloc_atomic or the routines in gc_typed.h to allocate large pointerfree regions of bitmaps, etc.  Sometimes the problem can be solved with trivial changes of encoding in certain values.  It is possible, though not pleasant, to identify the source of the bogus pointers by setting a breakpoint in GC_add_to_black_list_stack, and looking at the value of current_p in the GC_mark_from_mark_stack frame.  Current_p contains the address of the bogus pointer.\n-\n-4) If you get only a fixed number of these warnings, you are probably only introducing a bounded leak by ignoring them.  If the data structures being allocated are intended to be permanent, then it is also safe to ignore them.  The warnings can be turned off by calling GC_set_warn_proc with a procedure that ignores these warnings (e.g. by doing absolutely nothing).\n-\n-\n-****If the collector dies in GC_malloc while trying to remove a free list element:\n-\n-1) With > 99% probability, you wrote past the end of an allocated object.  Try setting GC_DEBUG and using the debugging facilities in gc.h.\n-\n-\n-****If the heap grows too much:\n-\n-1) Consider using GC_malloc_atomic for objects containing nonpointers.  This is especially important for large arrays containg compressed data, pseudo-random numbers, and the like.  (This isn't all that likely to solve your problem, but it's a useful and easy optimization anyway, and this is a good time to try it.)   If you allocate large objects containg only one or two pointers at the beginning, either try the typed allocation primitives is gc.h, or separate out the pointerfree component.\n-2) If you are using the collector in its default mode, with interior pointer recognition enabled, consider using GC_malloc_ignore_off_page to allocate large objects.  (See gc.h and above for details.  Large means > 100K in most environments.)\n-3) GC_print_block_list() will print a list of all currently allocated heap blocks and what size objects they contain.  GC_print_hblkfreelist() will print a list of free heap blocks, and whether they are blacklisted.  GC_dump calls both of these, and also prints information about heap sections, and root segments.\n-4) Build the collector with -DKEEP_BACK_PTRS, and use the backptr.h\n-interface to determine why objects are being retained.\n-\n-\n-****If the collector appears to be losing objects:\n-\n-1) Replace all calls to GC_malloc_atomic and typed allocation by GC_malloc calls.  If this fixes the problem, gradually reinsert your optimizations.\n-2) You may also want to try the safe(r) pointer manipulation primitives in gc.h.  But those are hard to use until the preprocessor becomes available.\n-3) Try using the GC_DEBUG facilities.  This is less likely to be successful here than if the collector crashes.\n-[The rest of these are primarily for wizards.  You shouldn't need them unless you're doing something really strange, or debugging a collector port.]\n-4) Don't turn on incremental collection.  If that fixes the problem, suspect a bug in the dirty bit implementation.  Try compiling with -DCHECKSUMS to check for modified, but supposedly clean, pages.\n-5) On a SPARC, in a single-threaded environment, GC_print_callers(GC_arrays._last_stack) prints a cryptic stack trace as of the time of the last collection.  (You will need a debugger to decipher the result.)  The question to ask then is \"why should this object have been accessible at the time of the last collection?  Where was a pointer to it stored?\".  This facility should be easy to add for some other collector ports (namely if it's easy to traverse stack frames), but will be hard for others.\n-6) \"print *GC_find_header(p)\" in dbx or gdb will print the garbage collector block header information associated with the object p (e.g. object size, etc.)\n-7) GC_is_marked(p) determines whether p is the base address of a marked object.  Note that objects allocated since the last collection should not be marked, and that unmarked objects are reclaimed incrementally.  It's usually most interesting to set a breakpoint in GC_finish_collection and then to determine how much of the damaged data structure is marked at that point.\n-8) Look at the tracing facility in mark.c.  (Ignore this suggestion unless you are very familiar with collector internals.)\n-9) [From Melissa O'Neill:]\n-If you're using multiple threads, double check that all thread\n-creation goes through the GC_ wrapper functions rather than\n-calling the thread-creation functions themselves (e.g.,\n-GC_pthread_create rather than pthread_create).  The gc.h header\n-file includes suitable preprocessor definitions to accomplish\n-this mapping transparently -- the question is: are you including\n-it in all the modules that create threads?\n-\n-\n-"}, {"sha": "613bc423cb147d95368108f3fe233047d632d0d4", "filename": "boehm-gc/README.dj", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6951ca5dee8ed05749cdc697767910aebaedcc0/boehm-gc%2FREADME.dj", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6951ca5dee8ed05749cdc697767910aebaedcc0/boehm-gc%2FREADME.dj", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FREADME.dj?ref=a6951ca5dee8ed05749cdc697767910aebaedcc0", "patch": "@@ -1,12 +0,0 @@\n-[Original version supplied by Xiaokun Zhu <xiaokun@aero.gla.ac.uk>]\n-[This version came mostly from Gary Leavens.\t\t\t  ]\n-\n-Look first at Makefile.dj, and possibly change the definitions of\n-RM and MV if you don't have rm and mv installed.\n-Then use Makefile.dj to compile the garbage collector.\n-For example, you can do:\n-\n-\tmake -f Makefile.dj test\n-\n-All the tests should work fine.\n-"}, {"sha": "072ba5386ac9895e01b8086c5acb921f9ebb03bb", "filename": "boehm-gc/README.hp", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6951ca5dee8ed05749cdc697767910aebaedcc0/boehm-gc%2FREADME.hp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6951ca5dee8ed05749cdc697767910aebaedcc0/boehm-gc%2FREADME.hp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FREADME.hp?ref=a6951ca5dee8ed05749cdc697767910aebaedcc0", "patch": "@@ -1,16 +0,0 @@\n-Dynamic loading support requires that executables be linked with -ldld.\n-The alternative is to build the collector without defining DYNAMIC_LOADING\n-in gcconfig.h and ensuring that all garbage collectable objects are\n-accessible without considering statically allocated variables in dynamic\n-libraries.\n-\n-The collector should compile with either plain cc or cc -Ae.  CC -Aa\n-fails to define _HPUX_SOURCE and thus will not configure the collector\n-correctly.\n-\n-Incremental collection support was reccently added, and should now work.\n-\n-Thread support for HP/UX 11 Pthreads was also recently added.  It is still\n-flakey in this release.  (It has only been tested on a uniprocessor.  Even\n-there some fraction of thread creation calls fail with a not-yet-understood\n-error return from sem_wait.)"}, {"sha": "e35e712ef95fbffc25f918a59261576d8287435c", "filename": "boehm-gc/README.linux", "status": "removed", "additions": 0, "deletions": 68, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6951ca5dee8ed05749cdc697767910aebaedcc0/boehm-gc%2FREADME.linux", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6951ca5dee8ed05749cdc697767910aebaedcc0/boehm-gc%2FREADME.linux", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FREADME.linux?ref=a6951ca5dee8ed05749cdc697767910aebaedcc0", "patch": "@@ -1,68 +0,0 @@\n-See README.alpha for Linux on DEC AXP info.\n-\n-This file applies mostly to Linux/Intel IA32.  Ports to Linux on an M68K\n-and PowerPC are also integrated.  They should behave similarly, except that\n-the PowerPC port lacks incremental GC support, and it is unknown to what\n-extent the Linux threads code is functional.\n-\n-Incremental GC is supported on Intel IA32 and M68K.\n-\n-Dynamic libraries are supported on an ELF system.  A static executable\n-should be linked with the gcc option \"-Wl,-defsym,_DYNAMIC=0\".\n-\n-The collector appears to work with Linux threads.  We have seen\n-intermittent hangs in sem_wait.  So far we have been unable to reproduce\n-these unless the process was being debugged or traced.  Thus it's\n-possible that the only real issue is that the debugger loses\n-signals on rare occasions.\n-\n-The garbage collector uses SIGPWR and SIGXCPU if it is used with\n-Linux threads.  These should not be touched by the client program.\n-\n-To use threads, you need to abide by the following requirements:\n-\n-1) You need to use LinuxThreads (which are included in libc6).\n-\n-   The collector relies on some implementation details of the LinuxThreads\n-   package.  It is unlikely that this code will work on other\n-   pthread implementations (in particular it will *not* work with\n-   MIT pthreads).\n-\n-2) You must compile the collector with -DLINUX_THREADS and -D_REENTRANT\n-   specified in the Makefile.\n-\n-3a) Every file that makes thread calls should define LINUX_THREADS and \n-   _REENTRANT and then include gc.h.  Gc.h redefines some of the\n-   pthread primitives as macros which also provide the collector with\n-   information it requires.\n-\n-3b) A new alternative to (3a) is to build the collector with\n-   -DUSE_LD_WRAP, and to link the final program with\n-\n-   (for ld) --wrap read --wrap dlopen --wrap pthread_create \\\n-\t    --wrap pthread_join --wrap pthread_sigmask\n-\n-   (for gcc) -Wl,--wrap -Wl,read -Wl,--wrap -Wl,dlopen -Wl,--wrap \\\n-\t     -Wl,pthread_create -Wl,--wrap -Wl,pthread_join -Wl,--wrap \\\n-\t     -Wl,pthread_sigmask\n-\n-   In any case, _REENTRANT should be defined during compilation.\n-\n-4) Dlopen() disables collection during its execution.  (It can't run\n-   concurrently with the collector, since the collector looks at its\n-   data structures.  It can't acquire the allocator lock, since arbitrary\n-   user startup code may run as part of dlopen().)  Under unusual\n-   conditions, this may cause unexpected heap growth.\n-\n-5) The combination of LINUX_THREADS, REDIRECT_MALLOC, and incremental\n-   collection fails in seemingly random places.  This hasn't been tracked\n-   down yet, but is perhaps not completely astonishing.  The thread package\n-   uses malloc, and thus can presumably get SIGSEGVs while inside the\n-   package.  There is no real guarantee that signals are handled properly\n-   at that point.\n-\n-6) Thread local storage may not be viewed as part of the root set by the\n-   collector.  This probably depends on the linuxthreads version.  For the\n-   time being, any collectable memory referenced by thread local storage should\n-   also be referenced from elsewhere, or be allocated as uncollectable.\n-   (This is really a bug that should be fixed somehow.)"}, {"sha": "f5630b20a3290a25903980435838bd935878372a", "filename": "boehm-gc/README.rs6000", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6951ca5dee8ed05749cdc697767910aebaedcc0/boehm-gc%2FREADME.rs6000", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6951ca5dee8ed05749cdc697767910aebaedcc0/boehm-gc%2FREADME.rs6000", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FREADME.rs6000?ref=a6951ca5dee8ed05749cdc697767910aebaedcc0", "patch": "@@ -1,9 +0,0 @@\n-We have so far failed to find a good way to determine the stack base.\n-It is highly recommended that GC_stackbottom be set explicitly on program\n-startup.  The supplied value sometimes causes failure under AIX 4.1, though\n-it appears to work under 3.X.  HEURISTIC2 seems to work under 4.1, but\n-involves a substantial performance penalty, and will fail if there is\n-no limit on stack size.\n-\n-There is no thread support.  (I assume recent versions of AIX provide\n-pthreads?  I no longer have access to a machine ...)"}, {"sha": "e67124b55442f15e9979f164d2cff5c13af351a0", "filename": "boehm-gc/README.sgi", "status": "removed", "additions": 0, "deletions": 41, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6951ca5dee8ed05749cdc697767910aebaedcc0/boehm-gc%2FREADME.sgi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6951ca5dee8ed05749cdc697767910aebaedcc0/boehm-gc%2FREADME.sgi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FREADME.sgi?ref=a6951ca5dee8ed05749cdc697767910aebaedcc0", "patch": "@@ -1,41 +0,0 @@\n-Performance of the incremental collector can be greatly enhanced with\n--DNO_EXECUTE_PERMISSION.\n-\n-The collector should run with all of the -32, -n32 and -64 ABIs.  Remember to\n-define the AS macro in the Makefile to be \"as -64\", or \"as -n32\".\n-\n-If you use -DREDIRECT_MALLOC=GC_malloc with C++ code, your code should make\n-at least one explicit call to malloc instead of new to ensure that the proper\n-version of malloc is linked in.\n-\n-Sproc threads are not supported in this version, though there may exist other\n-ports.\n-\n-Pthreads support is provided.  This requires that:\n-\n-1) You compile the collector with -DIRIX_THREADS specified in the Makefile.\n-\n-2) You have the latest pthreads patches installed.  \n-\n-(Though the collector makes only documented pthread calls,\n-it relies on signal/threads interactions working just right in ways\n-that are not required by the standard.  It is unlikely that this code\n-will run on other pthreads platforms.  But please tell me if it does.)\n-\n-3) Every file that makes thread calls should define IRIX_THREADS and then\n-include gc.h.  Gc.h redefines some of the pthread primitives as macros which\n-also provide the collector with information it requires.\n-\n-4) pthread_cond_wait and pthread_cond_timed_wait should be prepared for\n-premature wakeups.  (I believe the pthreads and realted standards require this\n-anyway.  Irix pthreads often terminate a wait if a signal arrives.\n-The garbage collector uses signals to stop threads.)\n-\n-5) It is expensive to stop a thread waiting in IO at the time the request is\n-initiated.  Applications with many such threads may not exhibit acceptable\n-performance with the collector.  (Increasing the heap size may help.)\n-\n-6) The collector should not be compiled with -DREDIRECT_MALLOC.  This\n-confuses some library calls made by the pthreads implementation, which\n-expect the standard malloc.\n-"}, {"sha": "cb15e30a19c5db1177d1793f2a316b63d3d281d2", "filename": "boehm-gc/README.solaris2", "status": "removed", "additions": 0, "deletions": 62, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6951ca5dee8ed05749cdc697767910aebaedcc0/boehm-gc%2FREADME.solaris2", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6951ca5dee8ed05749cdc697767910aebaedcc0/boehm-gc%2FREADME.solaris2", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FREADME.solaris2?ref=a6951ca5dee8ed05749cdc697767910aebaedcc0", "patch": "@@ -1,62 +0,0 @@\n-The collector supports both incremental collection and threads under\n-Solaris 2.  The incremental collector normally retrieves page dirty information\n-through the appropriate /proc calls.  But it can also be configured\n-(by defining MPROTECT_VDB instead of PROC_VDB in gcconfig.h) to use mprotect\n-and signals.  This may result in shorter pause times, but it is no longer\n-safe to issue arbitrary system calls that write to the heap.\n-\n-Under other UNIX versions,\n-the collector normally obtains memory through sbrk.  There is some reason\n-to expect that this is not safe if the client program also calls the system\n-malloc, or especially realloc.  The sbrk man page strongly suggests this is\n-not safe: \"Many library routines use malloc() internally, so use brk()\n-and sbrk() only when you know  that malloc() definitely will not be used by\n-any library routine.\"  This doesn't make a lot of sense to me, since there\n-seems to be no documentation as to which routines can transitively call malloc.\n-Nonetheless, under Solaris2, the collector now (since 4.12) allocates\n-memory using mmap by default.  (It defines USE_MMAP in gcconfig.h.)\n-You may want to reverse this decisions if you use -DREDIRECT_MALLOC=...\n-\n-\n-SOLARIS THREADS:\n-\n-The collector must be compiled with -DSOLARIS_THREADS to be thread safe.\n-It is also essential that gc.h be included in files that call thr_create,\n-thr_join, thr_suspend, thr_continue, or dlopen.  Gc.h macro defines\n-these to also do GC bookkeeping, etc.  Gc.h must be included with\n-SOLARIS_THREADS defined, otherwise these replacements are not visible.\n-A collector built in this way way only be used by programs that are\n-linked with the threads library.\n-\n-If you are using the Pthreads interface, also define _SOLARIS_PTHREADS.\n-\n-In this mode, the collector contains various workarounds for older Solaris\n-bugs.  Mostly, these should not be noticeable unless you look at system\n-call traces.  However, it cannot protect a guard page at the end of\n-a thread stack.  If you know that you will only be running Solaris2.5\n-or later, it should be possible to fix this by compiling the collector\n-with -DSOLARIS23_MPROTECT_BUG_FIXED.\n-\n-Since 5.0 alpha5, dlopen disables collection temporarily,\n-unless USE_PROC_FOR_LIBRARIES is defined.  In some unlikely cases, this\n-can result in unpleasant heap growth.  But it seems better than the\n-race/deadlock issues we had before.\n-\n-If solaris_threads are used on an X86 processor with malloc redirected to\n-GC_malloc, it is necessary to call GC_thr_init explicitly before forking the\n-first thread.  (This avoids a deadlock arising from calling GC_thr_init\n-with the allocation lock held.)\n-\n-It appears that there is a problem in using gc_cpp.h in conjunction with\n-Solaris threads and Sun's C++ runtime.  Apparently the overloaded new operator\n-is invoked by some iostream initialization code before threads are correctly\n-initialized.  As a result, call to thr_self() in garbage collector\n-initialization  segfaults.  Currently the only known workaround is to not\n-invoke the garbage collector from a user defined global operator new, or to\n-have it invoke the garbage-collector's allocators only after main has started.\n-(Note that the latter requires a moderately expensive test in operator\n-delete.)\n-\n-Hans-J. Boehm\n-(The above contains my personal opinions, which are probably not shared\n-by anyone else.)"}, {"sha": "6be49667d7b8852c8b38845514ad597e08a01184", "filename": "boehm-gc/README.uts", "status": "removed", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6951ca5dee8ed05749cdc697767910aebaedcc0/boehm-gc%2FREADME.uts", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6951ca5dee8ed05749cdc697767910aebaedcc0/boehm-gc%2FREADME.uts", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FREADME.uts?ref=a6951ca5dee8ed05749cdc697767910aebaedcc0", "patch": "@@ -1,2 +0,0 @@\n-Alistair Crooks supplied the port.  He used Lexa C version 2.1.3 with\n--Xa to compile."}, {"sha": "d78816b555d5dfb73f62b5d7c1382c44c29f08b6", "filename": "boehm-gc/README.win32", "status": "removed", "additions": 0, "deletions": 149, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6951ca5dee8ed05749cdc697767910aebaedcc0/boehm-gc%2FREADME.win32", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6951ca5dee8ed05749cdc697767910aebaedcc0/boehm-gc%2FREADME.win32", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FREADME.win32?ref=a6951ca5dee8ed05749cdc697767910aebaedcc0", "patch": "@@ -1,149 +0,0 @@\n-The collector has only been compiled under Windows NT, with the\n-original Microsoft SDK, with Visual C++ 2.0 and later, with\n-the GNU win32 environment, with Borland 4.5, and recently with\n-Watcom C.\n-\n-It runs under both win32s and win32, but with different semantics.\n-Under win32, all writable pages outside of the heaps and stack are\n-scanned for roots.  Thus the collector sees pointers in DLL data\n-segments.  Under win32s, only the main data segment is scanned.\n-(The main data segment should always be scanned.  Under some\n-versions of win32s, other regions may also be scanned.)\n-Thus all accessible objects should be accessible from local variables\n-or variables in the main data segment.  Alternatively, other data\n-segments (e.g. in DLLs) may be registered with the collector by\n-calling GC_init() and then GC_register_root_section(a), where\n-a is the address of some variable inside the data segment.  (Duplicate\n-registrations are ignored, but not terribly quickly.)\n-\n-(There are two reasons for this.  We didn't want to see many 16:16\n-pointers.  And the VirtualQuery call has different semantics under\n-the two systems, and under different versions of win32s.)\n-\n-The collector test program \"gctest\" is linked as a GUI application,\n-but does not open any windows.  Its output appears in the file\n-\"gc.log\".  It may be started from the file manager.  The hour glass\n-cursor will appear as long as it's running.  If it is started from the\n-command line, it will usually run in the background.  Wait a few\n-minutes (a few seconds on a modern machine) before you check the output.\n-You should see either a failure indication or a \"Collector appears to\n-work\" message.\n-\n-The cord test program has not been ported (but should port\n-easily).  A toy editor (cord/de.exe) based on cords (heavyweight\n-strings represented as trees) has been ported and is included.\n-It runs fine under either win32 or win32S.  It serves as an example\n-of a true Windows application, except that it was written by a\n-nonexpert Windows programmer.  (There are some peculiarities\n-in the way files are displayed.  The <cr> is displayed explicitly\n-for standard DOS text files.  As in the UNIX version, control\n-characters are displayed explicitly, but in this case as red text.\n-This may be suboptimal for some tastes and/or sets of default\n-window colors.)\n-\n-For Microsoft development tools, rename NT_MAKEFILE as\n-MAKEFILE.  (Make sure that the CPU environment variable is defined\n-to be i386.)\n-\n-For GNU-win32, use the regular makefile, possibly after uncommenting\n-the line \"include Makefile.DLLs\".  The latter should be necessary only\n-if you want to package the collector as a DLL.  The GNU-win32 port is\n-believed to work only for b18, not b19, probably dues to linker changes\n-in b19.  This is probably fixable with a different definition of\n-DATASTART and DATAEND in gcconfig.h.\n-\n-For Borland tools, use BCC_MAKEFILE.  Note that\n-Borland's compiler defaults to 1 byte alignment in structures (-a1),\n-whereas Visual C++ appears to default to 8 byte alignment (/Zp8).\n-The garbage collector in its default configuration EXPECTS AT\n-LEAST 4 BYTE ALIGNMENT.  Thus the BORLAND DEFAULT MUST\n-BE OVERRIDDEN.  (In my opinion, it should usually be anyway.\n-I expect that -a1 introduces major performance penalties on a\n-486 or Pentium.)  Note that this changes structure layouts.  (As a last\n-resort, gcconfig.h can be changed to allow 1 byte alignment.  But\n-this has significant negative performance implications.)\n-The Makefile is set up to assume Borland 4.5.  If you have another\n-version, change the line near the top.  By default, it does not\n-require the assembler.  If you do have the assembler, I recommend\n-removing the -DUSE_GENERIC.\n-\n-Incremental collection support was recently added.  This is\n-currently pretty simpleminded.  Pages are protected.  Protection\n-faults are caught by a handler installed at the bottom of the handler\n-stack.  This is both slow and interacts poorly with a debugger.\n-Whenever possible, I recommend adding a call to\n-GC_enable_incremental at the last possible moment, after most\n-debugging is complete.  Unlike the UNIX versions, no system\n-calls are wrapped by the collector itself.  It may be necessary\n-to wrap ReadFile calls that use a buffer in the heap, so that the\n-call does not encounter a protection fault while it's running.\n-(As usual, none of this is an issue unless GC_enable_incremental\n-is called.)\n-\n-Note that incremental collection is disabled with -DSMALL_CONFIG,\n-which is the default for win32.  If you need incremental collection,\n-undefine SMALL_CONFIG.\n-\n-Incremental collection is not supported under win32s, and it may not\n-be possible to do so.  However, win32 applications that attempt to use\n-incremental collection should continue to run, since the\n-collector detects if it's running under win32s and turns calls to\n-GC_enable_incremental() into noops.\n-\n-James Clark has contributed the necessary code to support win32 threads.\n-This code is known to exhibit some problems with incremental collection\n-enabled.  Use NT_THREADS_MAKEFILE (a.k.a gc.mak) instead of NT_MAKEFILE\n-to build this version.  Note that this requires some files whose names\n-are more than 8 + 3 characters long.  Thus you should unpack the tar file\n-so that long file names are preserved.  To build the garbage collector\n-test with VC++ from the command line, use\n-\n-nmake /F \".\\gc.mak\" CFG=\"gctest - Win32 Release\"\n-\n-This requires that the subdirectory gctest\\Release exist.\n-The test program and DLL will reside in the Release directory.\n-\n-This version relies on the collector residing in a dll.\n-\n-This version currently supports incremental collection only if it is\n-enabled before any additional threads are created.\n-Version 4.13 attempts to fix some of the earlier problems, but there\n-may be other issues.  If you need solid support for win32 threads, you\n-might check with Geodesic Systems.  Their collector must be licensed,\n-but they have invested far more time in win32-specific issues.\n-\n-Hans\n-\n-Ivan V. Demakov's README for the Watcom port:\n-\n-The collector has been compiled with Watcom C 10.6 and 11.0.\n-It runs under win32, win32s, and even under msdos with dos4gw\n-dos-extender. It should also run under OS/2, though this isn't\n-tested. Under win32 the collector can be built either as dll\n-or as static library.\n-\n-Note that all compilations were done under Windows 95 or NT.\n-For unknown reason compiling under Windows 3.11 for NT (one\n-attempt has been made) leads to broken executables.\n-\n-Incremental collection is not supported.\n-\n-cord is not ported.\n-\n-Before compiling you may need to edit WCC_MAKEFILE to set target\n-platform, library type (dynamic or static), calling conventions, and\n-optimization options.\n-\n-To compile the collector and testing programs use the command:\n-    wmake -f WCC_MAKEFILE\n-\n-All programs using gc should be compiled with 4-byte alignment.\n-For further explanations on this see comments about Borland.\n-\n-If gc compiled as dll, the macro ``GC_DLL'' should be defined before\n-including \"gc.h\" (for example, with -DGC_DLL compiler option). It's\n-important, otherwise resulting programs will not run.\n-\n-Ivan Demakov (email: ivan@tgrad.nsk.su)\n-\n-"}, {"sha": "a61e0cb1f04d9ace58d42d08f7fbc06370c20397", "filename": "boehm-gc/SCoptions.amiga", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6951ca5dee8ed05749cdc697767910aebaedcc0/boehm-gc%2FSCoptions.amiga", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6951ca5dee8ed05749cdc697767910aebaedcc0/boehm-gc%2FSCoptions.amiga", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FSCoptions.amiga?ref=a6951ca5dee8ed05749cdc697767910aebaedcc0", "patch": "@@ -1,16 +0,0 @@\n-CPU=68030\n-NOSTACKCHECK\n-OPTIMIZE\n-VERBOSE\n-MAPHUNK\n-NOVERSION\n-NOICONS\n-OPTIMIZERTIME\n-DEFINE SILENT\n-DEFINE AMIGA_SKIP_SEG\n-IGNORE=85\n-IGNORE=154\n-IGNORE=161\n-IGNORE=100\n-OPTIMIZERCOMPLEXITY=4\n-OPTIMIZERDEPTH=3"}, {"sha": "e2085051bbc940ee976e05b8ea1cbc0f07e303d2", "filename": "boehm-gc/SMakefile.amiga", "status": "modified", "additions": 149, "deletions": 19, "changes": 168, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9110a741e35c54e46c00662ddc420575376c5947/boehm-gc%2FSMakefile.amiga", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9110a741e35c54e46c00662ddc420575376c5947/boehm-gc%2FSMakefile.amiga", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FSMakefile.amiga?ref=9110a741e35c54e46c00662ddc420575376c5947", "patch": "@@ -1,48 +1,178 @@\n-OBJS= alloc.o reclaim.o allchblk.o misc.o mach_dep.o os_dep.o mark_rts.o headers.o mark.o obj_map.o blacklst.o finalize.o new_hblk.o real_malloc.o dyn_load.o dbg_mlc.o malloc.o stubborn.o checksums.o typd_mlc.o ptr_chck.o\n \n-INC=  gc_private.h gc_hdrs.h gc.h gcconfig.h\n+# Rewritten smakefile for amiga / sas/c. -Kjetil M.\n+# Dont use the cord-package if you define parm=both or parm=reg.\n+\n+\n+#----------------TOOLS--------------------------------\n+CC=sc\n+LINKER=slink\n+LIBER=oml\n+\n+#----------------CPU OPTIONS--------------------------\n+\n+CPU=68060\n+\n+#----------------FPU OPTIONS--------------------------\n+\n+MATH=8\n+MATHLIB=LIB:scm881.lib\n+\n+#----------------COMPILER OPTIONS---------------------\n+\n+IGNORE= IGNORE=85 IGNORE=154 IGNORE=161 IGNORE=100 \n+\n+OPTIMIZE=optimize optimizetime optglobal optimizerdepth=100 optimizerpeephole optloop OPTSCHED optimizerinlocal optimizerrecurdepth=100\n+# optimizerinline optimizercomplexity=100\n+\n+OPT= $(OPTIMIZE) CPU=$(CPU) math=$(MATH) NOSTACKCHECK VERBOSE \\\n+MAPHUNK NOVERSION NOICONS nodebug \\\n+DEFINE SILENT \\\n+parm=reg \\\n+DEFINE __USE_SYSBASE\n+\n+\n+SOPT= $(OPT) $(IGNORE) \\\n+DEFINE AMIGA_SKIP_SEG \\\n+DEFINE ATOMIC_UNCOLLECTABLE \\\n+DEFINE GC_AMIGA_FASTALLOC \\\n+DEFINE GC_AMIGA_RETRY \\\n+DEFINE GC_AMIGA_PRINTSTATS \\\n+DEFINE GC_AMIGA_GC\n+\n+\n+#DEFINE ALL_INTERIOR_POINTERS \\\n+\n+\n+SCOPT= $(SOPT) define GC_AMIGA_MAKINGLIB\n+\n+CSCOPT= $(OPT) DEFINE AMIGA IGNORE=100 IGNORE=161 \n+\n+#------------------LINKING----------------------------\n+\n+\n+all: gctest setjmp_t cord/cordtest\n+\n+clean:\n+   delete *.lib gctest setjmp_t *.o *.lnk cord/*.o cord/*.lib cord/*.lnk cord/cordtest\n+\tsmake\n+\n+test: setjmp_t gctest cord/cordtest\n+   setjmp_t\n+   gctest\n+   cord/cordtest\n+\n+gctest: gc$(CPU).lib GCAmigaOS$(CPU).lib test.o\n+   $(LINKER) LIB:c.o test.o TO gctest LIB gc$(CPU).lib LIB:sc.lib $(MATHLIB)\n+\n+setjmp_t: setjmp_t.o gc.h\n+   $(LINKER) LIB:c.o setjmp_t.o to setjmp_t lib LIB:sc.lib\n+\n+cord/cordtest: cord/cordtest.o cord/cord$(CPU).lib gc$(CPU).lib\n+\tslink LIB:c.o cord/cordtest.o LIB $(MATHLIB) gc$(CPU).lib cord/cord$(CPU).lib LIB:sc.lib TO cord/cordtest\n+\n+\n+#------------------LIBBING----------------------------\n+\n+OBJS= alloc.o reclaim.o allchblk.o misc.o mach_dep.o os_dep.o mark_rts.o headers.o mark.o obj_map.o blacklst.o finalize.o new_hblk.o real_malloc.o dyn_load.o dbg_mlc.o malloc.o stubborn.o checksums.o typd_mlc.o ptr_chck.o mallocx.o\n+\n+gc$(CPU).lib: $(OBJS)\n+   $(LIBER) gc$(CPU).lib r $(OBJS)\n+\n+\n+COBJS = cord/cordbscs.o cord/cordprnt.o cord/cordxtra.o\n \n-all: gctest setjmp_t\n+cord/cord$(CPU).lib: $(COBJS)\n+\toml cord/cord$(CPU).lib r $(COBJS)\n+\n+#------------------COMPILING--------------------------\n+\n+INC=  gc_private.h gc_hdrs.h gc.h gcconfig.h\n \n alloc.o : alloc.c $(INC)\n+\t$(CC) alloc.c $(SCOPT) ignore=7\n+\n reclaim.o : reclaim.c $(INC)\n+\t$(CC) reclaim.c $(SCOPT)\n+\n allchblk.o : allchblk.c $(INC)\n+\t$(CC) allchblk.c $(SCOPT)\n+\n misc.o : misc.c $(INC)\n-os_dep.o : os_dep.c $(INC)\n+\t$(CC) misc.c $(SCOPT)\n+\n+os_dep.o : os_dep.c $(INC) AmigaOS.c\n+\t$(CC) os_dep.c $(SCOPT)\n+\n mark_rts.o : mark_rts.c $(INC)\n+\t$(CC) mark_rts.c $(SCOPT)\n+\n headers.o : headers.c $(INC)\n+\t$(CC) headers.c $(SCOPT)\n+\n mark.o : mark.c $(INC)\n+\t$(CC) mark.c $(SCOPT)\n+\n obj_map.o : obj_map.c $(INC)\n+\t$(CC) obj_map.c $(SCOPT)\n+\n blacklst.o : blacklst.c $(INC)\n+\t$(CC) blacklst.c $(SCOPT)\n+\n finalize.o : finalize.c $(INC)\n-  sc noopt finalize.c # There seems to be a bug in the optimizer (V6.51).\n-                      # gctest won't work if you remove this...\n+\t$(CC) finalize.c $(SCOPT) noopt\t#Could sas/c still have problems with this one? Gctest sometimes fails to finalize all.\n+\n new_hblk.o : new_hblk.c $(INC)\n+\t$(CC) new_hblk.c $(SCOPT)\n+\n real_malloc.o : real_malloc.c $(INC)\n+\t$(CC) real_malloc.c $(SCOPT)\n+\n dyn_load.o : dyn_load.c $(INC)\n+\t$(CC) dyn_load.c $(SCOPT)\n+\n dbg_mlc.o : dbg_mlc.c $(INC)\n+\t$(CC) dbg_mlc.c $(SCOPT)\n+\n malloc.o : malloc.c $(INC)\n-mallocx.o : malloc.c $(INC)\n+\t$(CC) malloc.c $(SCOPT)\n+\n+mallocx.o : mallocx.c $(INC)\n+\t$(CC) mallocx.c $(SCOPT)\n+\n stubborn.o : stubborn.c $(INC)\n+\t$(CC) stubborn.c $(SCOPT)\n+\n checksums.o : checksums.c $(INC)\n+\t$(CC) checksums.c $(SCOPT)\n+\n typd_mlc.o: typd_mlc.c $(INC)\n+\t$(CC) typd_mlc.c $(SCOPT)\n+\n mach_dep.o : mach_dep.c $(INC)\n+\t$(CC) mach_dep.c $(SCOPT)\n+\n ptr_chck.o: ptr_chck.c $(INC)\n+\t$(CC) ptr_chck.c $(SCOPT)\n+\n test.o : test.c $(INC)\n+\t$(CC) test.c $(SOPT)\n \n-gc.lib: $(OBJS)\n-   oml gc.lib r $(OBJS)\n+setjmp_t: setjmp_t.c gc.h\n+   $(CC) setjmp_t.c $(SOPT)\n \n-clean:\n-   delete gc.lib gctest setjmp_t \\#?.o\n \n-gctest: gc.lib test.o\n-   slink LIB:c.o test.o to $@ lib gc.lib LIB:sc.lib LIB:scm.lib\n+# cords:\n+\n+cord/cordbscs.o: cord/cordbscs.c\n+\tsc cord/cordbscs.c $(CSCOPT)\n+\n+cord/cordprnt.o: cord/cordprnt.c\n+\tsc cord/cordprnt.c $(CSCOPT)\n+\n+cord/cordxtra.o: cord/cordxtra.c\n+\tsc cord/cordxtra.c $(CSCOPT)\n+\n+cord/cordtest.o: cord/cordtest.c\n+\tsc cord/cordtest.c $(CSCOPT)\n \n-setjmp_t: setjmp_t.c gc.h\n-   sc setjmp_t.c\n-   slink LIB:c.o $@.o to $@ lib LIB:sc.lib\n \n-test: setjmp_t gctest\n-   setjmp_t\n-   gctest"}, {"sha": "32b01df175415432a1d76f1bca8f25045c6779dd", "filename": "boehm-gc/WCC_MAKEFILE", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9110a741e35c54e46c00662ddc420575376c5947/boehm-gc%2FWCC_MAKEFILE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9110a741e35c54e46c00662ddc420575376c5947/boehm-gc%2FWCC_MAKEFILE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FWCC_MAKEFILE?ref=9110a741e35c54e46c00662ddc420575376c5947", "patch": "@@ -169,9 +169,9 @@ test_cpp.exe: test_cpp.obj gc.lib\n \n gc_cpp.obj: gc_cpp.cc .AUTODEPEND\n         $(CXX) $(TEST_CXXFLAGS) -iinclude $*.cc\n-test.obj: test.c .AUTODEPEND\n+test.obj: tests\\test.c .AUTODEPEND\n         $(CC) $(TEST_CFLAGS) $*.c\n-test_cpp.obj: test_cpp.cc .AUTODEPEND\n+test_cpp.obj: tests\\test_cpp.cc .AUTODEPEND\n         $(CXX) $(TEST_CXXFLAGS) -iinclude $*.cc\n \n "}, {"sha": "0be4e54cf2b1abb01d7c06f10c92f7b999f0775d", "filename": "boehm-gc/aclocal.m4", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9110a741e35c54e46c00662ddc420575376c5947/boehm-gc%2Faclocal.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9110a741e35c54e46c00662ddc420575376c5947/boehm-gc%2Faclocal.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Faclocal.m4?ref=9110a741e35c54e46c00662ddc420575376c5947", "patch": "@@ -43,7 +43,7 @@ AC_SUBST(boehm_gc_basedir)\n \n AC_CANONICAL_HOST\n \n-AM_INIT_AUTOMAKE(boehm-gc, 5.1, no-define)\n+AM_INIT_AUTOMAKE(boehm-gc, 6.0a7, no-define)\n \n # FIXME: We temporarily define our own version of AC_PROG_CC.  This is\n # copied from autoconf 2.12, but does not call AC_PROG_CC_WORKS.  We"}, {"sha": "5b7bcff050f132da70138a37afc64b4273f0330b", "filename": "boehm-gc/allchblk.c", "status": "modified", "additions": 92, "deletions": 31, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9110a741e35c54e46c00662ddc420575376c5947/boehm-gc%2Fallchblk.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9110a741e35c54e46c00662ddc420575376c5947/boehm-gc%2Fallchblk.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fallchblk.c?ref=9110a741e35c54e46c00662ddc420575376c5947", "patch": "@@ -14,10 +14,9 @@\n  * modified is included with the above copyright notice.\n  */\n \n-#define DEBUG\n-#undef DEBUG\n+/* #define DEBUG */\n #include <stdio.h>\n-#include \"gc_priv.h\"\n+#include \"private/gc_priv.h\"\n \n GC_bool GC_use_entire_heap = 0;\n \n@@ -47,6 +46,35 @@ GC_bool GC_use_entire_heap = 0;\n \n struct hblk * GC_hblkfreelist[N_HBLK_FLS+1] = { 0 };\n \n+#ifndef USE_MUNMAP\n+  word GC_free_bytes[N_HBLK_FLS+1] = { 0 };\n+\t/* Number of free bytes on each list.\t*/\n+\n+  /* Is bytes + the number of free bytes on lists n .. N_HBLK_FLS \t*/\n+  /* > GC_max_large_allocd_bytes?\t\t\t\t\t*/\n+  GC_bool GC_enough_large_bytes_left(bytes,n)\n+  word bytes;\n+  int n;\n+  {\n+    int i;\n+    for (i = N_HBLK_FLS; i >= n; --i) {\n+\tbytes += GC_free_bytes[i];\n+\tif (bytes > GC_max_large_allocd_bytes) return TRUE;\n+    }\n+    return FALSE;\n+  }\n+\n+# define INCR_FREE_BYTES(n, b) GC_free_bytes[n] += (b);\n+\n+# define FREE_ASSERT(e) GC_ASSERT(e)\n+\n+#else /* USE_MUNMAP */\n+\n+# define INCR_FREE_BYTES(n, b)\n+# define FREE_ASSERT(e)\n+\n+#endif /* USE_MUNMAP */\n+\n /* Map a number of blocks to the appropriate large block free list index. */\n int GC_hblk_fl_from_blocks(blocks_needed)\n word blocks_needed;\n@@ -79,7 +107,14 @@ void GC_print_hblkfreelist()\n     \n     for (i = 0; i <= N_HBLK_FLS; ++i) {\n       h = GC_hblkfreelist[i];\n-      if (0 != h) GC_printf1(\"Free list %ld:\\n\", (unsigned long)i);\n+#     ifdef USE_MUNMAP\n+        if (0 != h) GC_printf1(\"Free list %ld (Total size %ld):\\n\",\n+\t\t               (unsigned long)i);\n+#     else\n+        if (0 != h) GC_printf2(\"Free list %ld (Total size %ld):\\n\",\n+\t\t               (unsigned long)i,\n+\t\t\t       (unsigned long)GC_free_bytes[i]);\n+#     endif\n       while (h != 0) {\n         hhdr = HDR(h);\n         sz = hhdr -> hb_sz;\n@@ -219,21 +254,34 @@ void GC_remove_from_fl(hhdr, n)\n hdr * hhdr;\n int n;\n {\n+    int index;\n+\n     GC_ASSERT(((hhdr -> hb_sz) & (HBLKSIZE-1)) == 0);\n+#   ifndef USE_MUNMAP\n+      /* We always need index to mainatin free counts.\t*/\n+      if (FL_UNKNOWN == n) {\n+          index = GC_hblk_fl_from_blocks(divHBLKSZ(hhdr -> hb_sz));\n+      } else {\n+\t  index = n;\n+      }\n+#   endif\n     if (hhdr -> hb_prev == 0) {\n-        int index;\n-\tif (FL_UNKNOWN == n) {\n+#\tifdef USE_MUNMAP\n+\t  if (FL_UNKNOWN == n) {\n             index = GC_hblk_fl_from_blocks(divHBLKSZ(hhdr -> hb_sz));\n-\t} else {\n+\t  } else {\n \t    index = n;\n-\t}\n+\t  }\n+#\tendif\n \tGC_ASSERT(HDR(GC_hblkfreelist[index]) == hhdr);\n \tGC_hblkfreelist[index] = hhdr -> hb_next;\n     } else {\n \thdr *phdr;\n \tGET_HDR(hhdr -> hb_prev, phdr);\n \tphdr -> hb_next = hhdr -> hb_next;\n     }\n+    INCR_FREE_BYTES(index, - (signed_word)(hhdr -> hb_sz));\n+    FREE_ASSERT(GC_free_bytes[index] >= 0);\n     if (0 != hhdr -> hb_next) {\n \thdr * nhdr;\n \tGC_ASSERT(!IS_FORWARDING_ADDR_OR_NIL(NHDR(hhdr)));\n@@ -294,6 +342,8 @@ hdr * hhdr;\n #   endif\n     GC_ASSERT(((hhdr -> hb_sz) & (HBLKSIZE-1)) == 0);\n     GC_hblkfreelist[index] = h;\n+    INCR_FREE_BYTES(index, hhdr -> hb_sz);\n+    FREE_ASSERT(GC_free_bytes[index] <= GC_large_free_bytes)\n     hhdr -> hb_next = second;\n     hhdr -> hb_prev = 0;\n     if (0 != second) {\n@@ -419,7 +469,7 @@ int index;\n     rest_hdr -> hb_sz = total_size - bytes;\n     rest_hdr -> hb_flags = 0;\n #   ifdef GC_ASSERTIONS\n-      // Mark h not free, to avoid assertion about adjacent free blocks.\n+      /* Mark h not free, to avoid assertion about adjacent free blocks. */\n         hhdr -> hb_map = 0;\n #   endif\n     GC_add_to_fl(rest, rest_hdr);\n@@ -463,6 +513,8 @@ int index;\t/* Index of free list */\n       if (0 != next) {\n \tHDR(next) -> hb_prev = n;\n       }\n+      INCR_FREE_BYTES(index, -(signed_word)h_size);\n+      FREE_ASSERT(GC_free_bytes[index] > 0);\n #     ifdef GC_ASSERTIONS\n \tnhdr -> hb_map = 0;\t/* Don't fail test for consecutive\t*/\n \t\t\t\t/* free blocks in GC_add_to_fl.\t\t*/\n@@ -484,20 +536,23 @@ struct hblk * GC_allochblk_nth();\n  * NOTE: We set obj_map field in header correctly.\n  *       Caller is responsible for building an object freelist in block.\n  *\n- * We clear the block if it is destined for large objects, and if\n- * kind requires that newly allocated objects be cleared.\n+ * Unlike older versions of the collectors, the client is responsible\n+ * for clearing the block, if necessary.\n  */\n struct hblk *\n GC_allochblk(sz, kind, flags)\n word sz;\n int kind;\n-unsigned char flags;  /* IGNORE_OFF_PAGE or 0 */\n+unsigned flags;  /* IGNORE_OFF_PAGE or 0 */\n {\n-    int start_list = GC_hblk_fl_from_blocks(OBJ_SZ_TO_BLOCKS(sz));\n+    word blocks = OBJ_SZ_TO_BLOCKS(sz);\n+    int start_list = GC_hblk_fl_from_blocks(blocks);\n     int i;\n     for (i = start_list; i <= N_HBLK_FLS; ++i) {\n \tstruct hblk * result = GC_allochblk_nth(sz, kind, flags, i);\n-\tif (0 != result) return result;\n+\tif (0 != result) {\n+\t    return result;\n+\t}\n     }\n     return 0;\n }\n@@ -526,12 +581,22 @@ int n;\n \t    GET_HDR(hbp, hhdr);\n \t    size_avail = hhdr->hb_sz;\n \t    if (size_avail < size_needed) continue;\n-\t    if (!GC_use_entire_heap) {\n-\t\tif (size_avail != size_needed\n-\t\t    && USED_HEAP_SIZE >= GC_requested_heapsize\n-\t\t    && !GC_incremental && GC_should_collect()) {\n+\t    if (!GC_use_entire_heap\n+\t\t&& size_avail != size_needed\n+\t\t&& USED_HEAP_SIZE >= GC_requested_heapsize\n+\t\t&& !GC_incremental && GC_should_collect()) {\n+#\t\tifdef USE_MUNMAP\n \t\t    continue;\n-\t\t} \n+#\t\telse\n+\t\t    /* If we enough large blocks left to cover any\t*/\n+\t\t    /* previous request for large blocks, we go ahead\t*/\n+\t\t    /* and split.  Assuming a steady state, that should\t*/\n+\t\t    /* be safe.  It means that we can use the full \t*/\n+\t\t    /* heap if we allocate only small objects.\t\t*/\n+\t\t    if (!GC_enough_large_bytes_left(GC_large_allocd_bytes, n)) {\n+\t\t      continue;\n+\t\t    } \n+#\t\tendif /* !USE_MUNMAP */\n \t    }\n \t    /* If the next heap block is obviously better, go on.\t*/\n \t    /* This prevents us from disassembling a single large block */\n@@ -573,7 +638,7 @@ int n;\n \t\t  /* Make sure it's mapped before we mangle it. */\n #\t\t    ifdef USE_MUNMAP\n \t\t      if (!IS_MAPPED(hhdr)) {\n-\t\t        GC_remap((ptr_t)hbp, size_avail);\n+\t\t        GC_remap((ptr_t)hbp, hhdr -> hb_sz);\n \t\t        hhdr -> hb_flags &= ~WAS_UNMAPPED;\n \t\t      }\n #\t\t    endif\n@@ -589,8 +654,10 @@ int n;\n \t                 && orig_avail - size_needed\n \t\t\t    > (signed_word)BL_LIMIT) {\n \t        /* Punt, since anything else risks unreasonable heap growth. */\n-\t        WARN(\"Needed to allocate blacklisted block at 0x%lx\\n\",\n-\t\t     (word)hbp);\n+\t\tif (0 != GETENV(\"GC_NO_BLACKLIST_WARNING\")) {\n+\t          WARN(\"Needed to allocate blacklisted block at 0x%lx\\n\",\n+\t\t       (word)hbp);\n+\t\t}\n \t        size_avail = orig_avail;\n \t      } else if (size_avail == 0 && size_needed == HBLKSIZE\n \t\t\t && IS_MAPPED(hhdr)) {\n@@ -618,10 +685,10 @@ int n;\n \t                if (h == hbp || 0 != (hhdr = GC_install_header(h))) {\n \t                  (void) setup_header(\n \t                \t  hhdr,\n-\t              \t\t  BYTES_TO_WORDS(HBLKSIZE - HDR_BYTES),\n+\t              \t\t  BYTES_TO_WORDS(HBLKSIZE),\n \t              \t\t  PTRFREE, 0); /* Cant fail */\n \t              \t  if (GC_debugging_started) {\n-\t              \t    BZERO(h + HDR_BYTES, HBLKSIZE - HDR_BYTES);\n+\t              \t    BZERO(h, HBLKSIZE);\n \t              \t  }\n \t                }\n \t              }\n@@ -638,7 +705,7 @@ int n;\n \t    if( size_avail >= size_needed ) {\n #\t\tifdef USE_MUNMAP\n \t\t  if (!IS_MAPPED(hhdr)) {\n-\t\t    GC_remap((ptr_t)hbp, size_avail);\n+\t\t    GC_remap((ptr_t)hbp, hhdr -> hb_sz);\n \t\t    hhdr -> hb_flags &= ~WAS_UNMAPPED;\n \t\t  }\n #\t        endif\n@@ -664,12 +731,6 @@ int n;\n             return(0); /* ditto */\n         }\n         \n-    /* Clear block if necessary */\n-\tif (GC_debugging_started\n-\t    || sz > MAXOBJSZ && GC_obj_kinds[kind].ok_init) {\n-\t    BZERO(hbp + HDR_BYTES,  size_needed - HDR_BYTES);\n-\t}\n-\n     /* We just successfully allocated a block.  Restart count of\t*/\n     /* consecutive failures.\t\t\t\t\t\t*/\n     {"}, {"sha": "d8173fa3f4850beb959ce50d5499b274b9a982bc", "filename": "boehm-gc/alloc.c", "status": "modified", "additions": 85, "deletions": 35, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9110a741e35c54e46c00662ddc420575376c5947/boehm-gc%2Falloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9110a741e35c54e46c00662ddc420575376c5947/boehm-gc%2Falloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Falloc.c?ref=9110a741e35c54e46c00662ddc420575376c5947", "patch": "@@ -16,10 +16,10 @@\n  */\n \n \n-# include \"gc_priv.h\"\n+# include \"private/gc_priv.h\"\n \n # include <stdio.h>\n-# ifndef MACOS\n+# if !defined(MACOS) && !defined(MSWINCE)\n #   include <signal.h>\n #   include <sys/types.h>\n # endif\n@@ -60,9 +60,11 @@ word GC_non_gc_bytes = 0;  /* Number of bytes not intended to be collected */\n word GC_gc_no = 0;\n \n #ifndef SMALL_CONFIG\n-  int GC_incremental = 0;    /* By default, stop the world.\t*/\n+  int GC_incremental = 0;  /* By default, stop the world.\t*/\n #endif\n \n+int GC_parallel = FALSE;   /* By default, parallel GC is off.\t*/\n+\n int GC_full_freq = 19;\t   /* Every 20th collection is a full\t*/\n \t\t\t   /* collection, whether we need it \t*/\n \t\t\t   /* or not.\t\t\t        */\n@@ -76,6 +78,7 @@ char * GC_copyright[] =\n {\"Copyright 1988,1989 Hans-J. Boehm and Alan J. Demers \",\n \"Copyright (c) 1991-1995 by Xerox Corporation.  All rights reserved. \",\n \"Copyright (c) 1996-1998 by Silicon Graphics.  All rights reserved. \",\n+\"Copyright (c) 1999-2000 by Hewlett-Packard Company.  All rights reserved. \",\n \"THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY\",\n \" EXPRESSED OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\",\n \"See source code for details.\" };\n@@ -116,10 +119,12 @@ int GC_n_attempts = 0;\t\t/* Number of attempts at finishing\t*/\n     GET_TIME(current_time);\n     time_diff = MS_TIME_DIFF(current_time,GC_start_time);\n     if (time_diff >= TIME_LIMIT) {\n-#   \tifdef PRINTSTATS\n+#   \tifdef CONDPRINT\n+\t  if (GC_print_stats) {\n \t    GC_printf0(\"Abandoning stopped marking after \");\n \t    GC_printf1(\"%lu msecs\", (unsigned long)time_diff);\n \t    GC_printf1(\"(attempt %d)\\n\", (unsigned long) GC_n_attempts);\n+\t  }\n #\tendif\n     \treturn(1);\n     }\n@@ -222,7 +227,7 @@ GC_bool GC_should_collect()\n \n void GC_notify_full_gc()\n {\n-    if (GC_start_call_back != (void (*)())0) {\n+    if (GC_start_call_back != (void (*) GC_PROTO((void)))0) {\n \t(*GC_start_call_back)();\n     }\n }\n@@ -246,13 +251,18 @@ void GC_maybe_gc()\n             n_partial_gcs = 0;\n             return;\n         } else if (GC_need_full_gc || n_partial_gcs >= GC_full_freq) {\n-#   \t    ifdef PRINTSTATS\n-\t      GC_printf2(\n-\t        \"***>Full mark for collection %lu after %ld allocd bytes\\n\",\n-     \t\t(unsigned long) GC_gc_no+1,\n-\t   \t(long)WORDS_TO_BYTES(GC_words_allocd));\n+#   \t    ifdef CONDPRINT\n+\t      if (GC_print_stats) {\n+\t        GC_printf2(\n+\t          \"***>Full mark for collection %lu after %ld allocd bytes\\n\",\n+     \t\t  (unsigned long) GC_gc_no+1,\n+\t   \t  (long)WORDS_TO_BYTES(GC_words_allocd));\n+\t      }\n #           endif\n \t    GC_promote_black_lists();\n+#   \t    ifdef PARALLEL_MARK\n+\t\tGC_wait_for_reclaim();\n+#   \t    endif\n \t    (void)GC_reclaim_all((GC_stop_func)0, TRUE);\n \t    GC_clear_marks();\n             n_partial_gcs = 0;\n@@ -290,27 +300,36 @@ GC_bool GC_try_to_collect_inner(stop_func)\n GC_stop_func stop_func;\n {\n     if (GC_incremental && GC_collection_in_progress()) {\n-#   ifdef PRINTSTATS\n+#   ifdef CONDPRINT\n+      if (GC_print_stats) {\n \tGC_printf0(\n \t    \"GC_try_to_collect_inner: finishing collection in progress\\n\");\n-#    endif /* PRINTSTATS */\n+      }\n+#   endif /* CONDPRINT */\n       /* Just finish collection already in progress.\t*/\n     \twhile(GC_collection_in_progress()) {\n     \t    if (stop_func()) return(FALSE);\n     \t    GC_collect_a_little_inner(1);\n     \t}\n     }\n-#   ifdef PRINTSTATS\n+#   ifdef CONDPRINT\n+      if (GC_print_stats) {\n \tGC_printf2(\n \t   \"Initiating full world-stop collection %lu after %ld allocd bytes\\n\",\n \t   (unsigned long) GC_gc_no+1,\n \t   (long)WORDS_TO_BYTES(GC_words_allocd));\n+      }\n #   endif\n     GC_promote_black_lists();\n     /* Make sure all blocks have been reclaimed, so sweep routines\t*/\n     /* don't see cleared mark bits.\t\t\t\t\t*/\n     /* If we're guaranteed to finish, then this is unnecessary.\t\t*/\n-\tif (stop_func != GC_never_stop_func\n+    /* In the find_leak case, we have to finish to guarantee that \t*/\n+    /* previously unmarked objects are not reported as leaks.\t\t*/\n+#       ifdef PARALLEL_MARK\n+\t    GC_wait_for_reclaim();\n+#       endif\n+ \tif ((GC_find_leak || stop_func != GC_never_stop_func)\n \t    && !GC_reclaim_all(stop_func, FALSE)) {\n \t    /* Aborted.  So far everything is still consistent.\t*/\n \t    return(FALSE);\n@@ -412,18 +431,22 @@ GC_stop_func stop_func;\n {\n     register int i;\n     int dummy;\n-#   ifdef PRINTSTATS\n+#   ifdef PRINTTIMES\n \tCLOCK_TYPE start_time, current_time;\n #   endif\n \t\n     STOP_WORLD();\n-#   ifdef PRINTSTATS\n+#   ifdef PRINTTIMES\n \tGET_TIME(start_time);\n+#   endif\n+#   ifdef CONDPRINT\n+      if (GC_print_stats) {\n \tGC_printf1(\"--> Marking for collection %lu \",\n \t           (unsigned long) GC_gc_no + 1);\n \tGC_printf2(\"after %lu allocd bytes + %lu wasted bytes\\n\",\n \t   \t   (unsigned long) WORDS_TO_BYTES(GC_words_allocd),\n \t   \t   (unsigned long) WORDS_TO_BYTES(GC_words_wasted));\n+      }\n #   endif\n \n     /* Mark from all roots.  */\n@@ -433,10 +456,12 @@ GC_stop_func stop_func;\n \tGC_initiate_gc();\n \tfor(i = 0;;i++) {\n \t    if ((*stop_func)()) {\n-#   \t\t    ifdef PRINTSTATS\n+#   \t\t    ifdef CONDPRINT\n+\t\t      if (GC_print_stats) {\n \t\t    \tGC_printf0(\"Abandoned stopped marking after \");\n \t\t\tGC_printf1(\"%lu iterations\\n\",\n \t\t\t\t   (unsigned long)i);\n+\t\t      }\n #\t\t    endif\n \t\t    GC_deficit = i; /* Give the mutator a chance. */\n \t            START_WORLD();\n@@ -450,12 +475,22 @@ GC_stop_func stop_func;\n       GC_printf2(\"Collection %lu reclaimed %ld bytes\",\n \t\t  (unsigned long) GC_gc_no - 1,\n \t   \t  (long)WORDS_TO_BYTES(GC_mem_found));\n-      GC_printf1(\" ---> heapsize = %lu bytes\\n\",\n-      \t        (unsigned long) GC_heapsize);\n-      /* Printf arguments may be pushed in funny places.  Clear the\t*/\n-      /* space.\t\t\t\t\t\t\t\t*/\n-      GC_printf0(\"\");\n-#   endif      \n+#   else\n+#     ifdef CONDPRINT\n+        if (GC_print_stats) {\n+\t  GC_printf1(\"Collection %lu finished\", (unsigned long) GC_gc_no - 1);\n+\t}\n+#     endif\n+#   endif /* !PRINTSTATS */\n+#   ifdef CONDPRINT\n+      if (GC_print_stats) {\n+        GC_printf1(\" ---> heapsize = %lu bytes\\n\",\n+      \t           (unsigned long) GC_heapsize);\n+        /* Printf arguments may be pushed in funny places.  Clear the\t*/\n+        /* space.\t\t\t\t\t\t\t*/\n+        GC_printf0(\"\");\n+      }\n+#   endif  /* CONDPRINT  */\n \n     /* Check all debugged objects for consistency */\n         if (GC_debugging_started) {\n@@ -487,6 +522,11 @@ void GC_finish_collection()\n \n #   ifdef GATHERSTATS\n         GC_mem_found = 0;\n+#   endif\n+#   if defined(LINUX) && defined(__ELF__) && !defined(SMALL_CONFIG)\n+\tif (getenv(\"GC_PRINT_ADDRESS_MAP\") != 0) {\n+\t  GC_print_address_map();\n+\t}\n #   endif\n     if (GC_find_leak) {\n       /* Mark all objects on the free list.  All objects should be */\n@@ -663,22 +703,22 @@ word bytes;\n     GC_heap_sects[GC_n_heap_sects].hs_start = (ptr_t)p;\n     GC_heap_sects[GC_n_heap_sects].hs_bytes = bytes;\n     GC_n_heap_sects++;\n-    words = BYTES_TO_WORDS(bytes - HDR_BYTES);\n+    words = BYTES_TO_WORDS(bytes);\n     phdr -> hb_sz = words;\n-    phdr -> hb_map = (char *)1;   /* A value != GC_invalid_map\t*/\n+    phdr -> hb_map = (unsigned char *)1;   /* A value != GC_invalid_map\t*/\n     phdr -> hb_flags = 0;\n     GC_freehblk(p);\n     GC_heapsize += bytes;\n-    if ((ptr_t)p <= GC_least_plausible_heap_addr\n+    if ((ptr_t)p <= (ptr_t)GC_least_plausible_heap_addr\n         || GC_least_plausible_heap_addr == 0) {\n-        GC_least_plausible_heap_addr = (ptr_t)p - sizeof(word);\n+        GC_least_plausible_heap_addr = (GC_PTR)((ptr_t)p - sizeof(word));\n         \t/* Making it a little smaller than necessary prevents\t*/\n         \t/* us from getting a false hit from the variable\t*/\n         \t/* itself.  There's some unintentional reflection\t*/\n         \t/* here.\t\t\t\t\t\t*/\n     }\n-    if ((ptr_t)p + bytes >= GC_greatest_plausible_heap_addr) {\n-        GC_greatest_plausible_heap_addr = (ptr_t)p + bytes;\n+    if ((ptr_t)p + bytes >= (ptr_t)GC_greatest_plausible_heap_addr) {\n+        GC_greatest_plausible_heap_addr = (GC_PTR)((ptr_t)p + bytes);\n     }\n }\n \n@@ -705,8 +745,8 @@ void GC_print_heap_sects()\n }\n # endif\n \n-ptr_t GC_least_plausible_heap_addr = (ptr_t)ONES;\n-ptr_t GC_greatest_plausible_heap_addr = 0;\n+GC_PTR GC_least_plausible_heap_addr = (GC_PTR)ONES;\n+GC_PTR GC_greatest_plausible_heap_addr = 0;\n \n ptr_t GC_max(x,y)\n ptr_t x, y;\n@@ -762,9 +802,16 @@ word n;\n     }\n     space = GET_MEM(bytes);\n     if( space == 0 ) {\n+#\tifdef CONDPRINT\n+\t  if (GC_print_stats) {\n+\t    GC_printf1(\"Failed to expand heap by %ld bytes\\n\",\n+\t\t       (unsigned long)bytes);\n+\t  }\n+#       endif\n \treturn(FALSE);\n     }\n-#   ifdef PRINTSTATS\n+#   ifdef CONDPRINT\n+      if (GC_print_stats) {\n \tGC_printf2(\"Increasing heap size by %lu after %lu allocated bytes\\n\",\n \t           (unsigned long)bytes,\n \t           (unsigned long)WORDS_TO_BYTES(GC_words_allocd));\n@@ -773,6 +820,7 @@ word n;\n \t  GC_print_block_list(); GC_print_hblkfreelist();\n \t  GC_printf0(\"\\n\");\n #\tendif\n+      }\n #   endif\n     expansion_slop = 8 * WORDS_TO_BYTES(min_words_allocd());\n     if (5 * HBLKSIZE * MAXHINCR > expansion_slop) {\n@@ -856,12 +904,14 @@ GC_bool ignore_off_page;\n \t    GC_notify_full_gc();\n \t    GC_gcollect_inner();\n \t} else {\n-\t    WARN(\"Out of Memory!  Returning NIL!\\n\", 0);\n+#\t    if !defined(AMIGA) || !defined(GC_AMIGA_FASTALLOC)\n+\t      WARN(\"Out of Memory!  Returning NIL!\\n\", 0);\n+#\t    endif\n \t    return(FALSE);\n \t}\n       } else {\n-#\t  ifdef PRINTSTATS\n-            if (GC_fail_count) {\n+#\t  ifdef CONDPRINT\n+            if (GC_fail_count && GC_print_stats) {\n \t      GC_printf0(\"Memory available again ...\\n\");\n \t    }\n #\t  endif"}, {"sha": "f5b7c5aa2b948d732f7dfd06d214ef8e2f966980", "filename": "boehm-gc/backptr.h", "status": "removed", "additions": 0, "deletions": 63, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6951ca5dee8ed05749cdc697767910aebaedcc0/boehm-gc%2Fbackptr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6951ca5dee8ed05749cdc697767910aebaedcc0/boehm-gc%2Fbackptr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fbackptr.h?ref=a6951ca5dee8ed05749cdc697767910aebaedcc0", "patch": "@@ -1,63 +0,0 @@\n-/*\n- * This is a simple API to implement pointer back tracing, i.e.\n- * to answer questions such as \"who is pointing to this\" or\n- * \"why is this object being retained by the collector\"\n- *\n- * This API assumes that we have an ANSI C compiler.\n- *\n- * Most of these calls yield useful information on only after\n- * a garbage collection.  Usually the client will first force\n- * a full collection and then gather information, preferably\n- * before much intervening allocation.\n- *\n- * The implementation of the interface is only about 99.9999%\n- * correct.  It is intended to be good enough for profiling,\n- * but is not intended to be used with production code.\n- *\n- * Results are likely to be much more useful if all allocation is\n- * accomplished through the debugging allocators.\n- *\n- * The implementation idea is due to A. Demers.\n- */\n-\n-/* Store information about the object referencing dest in *base_p     */\n-/* and *offset_p.                                                     */\n-/* If multiple objects or roots point to dest, the one reported\t      */\n-/* will be the last on used by the garbage collector to trace the     */\n-/* object.\t\t\t\t\t\t\t      */\n-/*   source is root ==> *base_p = address, *offset_p = 0\t      */\n-/*   source is heap object ==> *base_p != 0, *offset_p = offset       */\n-/*   Returns 1 on success, 0 if source couldn't be determined.        */\n-/* Dest can be any address within a heap object.                      */\n-typedef enum {  GC_UNREFERENCED, /* No reference info available.\t*/\n-\t\tGC_NO_SPACE,\t/* Dest not allocated with debug alloc  */\n-\t\tGC_REFD_FROM_ROOT, /* Referenced directly by root *base_p */\n-\t\tGC_REFD_FROM_REG,  /* Referenced from a register, i.e.\t*/\n-\t\t\t\t   /* a root without an address.\t*/\n-\t\tGC_REFD_FROM_HEAP, /* Referenced from another heap obj. */\n-\t\tGC_FINALIZER_REFD /* Finalizable and hence accessible.  */\n-} GC_ref_kind;\n-\n-GC_ref_kind GC_get_back_ptr_info(void *dest, void **base_p, size_t *offset_p);\n-\n-/* Generate a random heap address.            */\n-/* The resulting address is in the heap, but  */\n-/* not necessarily inside a valid object.     */\n-void * GC_generate_random_heap_address(void);\n-\n-/* Generate a random address inside a valid marked heap object. */\n-void * GC_generate_random_valid_address(void);\n-\n-/* Force a garbage collection and generate a backtrace from a */\n-/* random heap address.                                       */\n-/* This uses the GC logging mechanism (GC_printf) to produce  */\n-/* output.  It can often be called from a debugger.  The      */\n-/* source in dbg_mlc.c also serves as a sample client.\t      */\n-void GC_generate_random_backtrace(void);\n-\n-/* Print a backtrace from a specific address.  Used by the \t*/\n-/* above.  The client should call GC_gcollect() immediately\t*/\n-/* before invocation.\t\t\t\t\t\t*/\n-void GC_print_backtrace(void *);\n-\n-"}, {"sha": "27e80dc15cd103b5c3ad02a2cc60972370bd2842", "filename": "boehm-gc/barrett_diagram", "status": "removed", "additions": 0, "deletions": 106, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6951ca5dee8ed05749cdc697767910aebaedcc0/boehm-gc%2Fbarrett_diagram", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6951ca5dee8ed05749cdc697767910aebaedcc0/boehm-gc%2Fbarrett_diagram", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fbarrett_diagram?ref=a6951ca5dee8ed05749cdc697767910aebaedcc0", "patch": "@@ -1,106 +0,0 @@\n-This is an ASCII diagram of the data structure used to check pointer\n-validity.  It was provided by Dave Barrett <barrett@asgard.cs.colorado.edu>,\n-and should be of use to others attempting to understand the code.\n-The data structure in GC4.X is essentially the same.   -HB\n-\n-\n-\n-\n-\t\tData Structure used by GC_base in gc3.7:\n-\t\t\t      21-Apr-94\n-\t\t\t \n-\t\t\t\n-\n-\n-    63                  LOG_TOP_SZ[11]  LOG_BOTTOM_SZ[10]   LOG_HBLKSIZE[13]\n-   +------------------+----------------+------------------+------------------+\n- p:|                  |   TL_HASH(hi)  |                  |   HBLKDISPL(p)   |\n-   +------------------+----------------+------------------+------------------+\n-    \\-----------------------HBLKPTR(p)-------------------/\n-    \\------------hi-------------------/ \n-                      \\______ ________/ \\________ _______/ \\________ _______/\n-                             V                   V                  V\n-                             |                   |                  |\n-           GC_top_index[]    |                   |                  | \n- ---      +--------------+   |                   |                  |  \n-  ^       |              |   |                   |                  |   \n-  |       |              |   |                   |                  |   \n- TOP      +--------------+<--+                   |                  |      \n- _SZ   +-<|      []      | *                     |                  |     \n-(items)|  +--------------+  if 0 < bi< HBLKSIZE  |                  |    \n-  |    |  |              | then large object     |                  |    \n-  |    |  |              | starts at the bi'th   |                  |    \n-  v    |  |              | HBLK before p.        |             i    |    \n- ---   |  +--------------+                       |          (word-  |    \n-       v                                         |         aligned) |    \n-   bi= |GET_BI(p){->hash_link}->key==hi          |                  |   \n-       v                                         |                  |    \n-       |   (bottom_index)  \\ scratch_alloc'd     |                  |    \n-       |   ( struct  bi )  / by get_index()      |                  |    \n- ---   +->+--------------+                       |                  |    \n-  ^       |              |                       |                  |\n-  ^       |              |                       |                  |\n- BOTTOM   |              |   ha=GET_HDR_ADDR(p)  |                  |\n-_SZ(items)+--------------+<----------------------+          +-------+\n-  |   +--<|   index[]    |                                  |         \n-  |   |   +--------------+                      GC_obj_map: v              \n-  |   |   |              |              from      / +-+-+-----+-+-+-+-+  --- \n-  v   |   |              |              GC_add   < 0| | |     | | | | |   ^  \n- ---  |   +--------------+             _map_entry \\ +-+-+-----+-+-+-+-+   |  \n-      |   |   asc_link   |                          +-+-+-----+-+-+-+-+ MAXOBJSZ\n-      |   +--------------+                      +-->| | |  j  | | | | |  +1   \n-      |   |     key      |                      |   +-+-+-----+-+-+-+-+   |  \n-      |   +--------------+                      |   +-+-+-----+-+-+-+-+   | \n-      |   |  hash_link   |                      |   | | |     | | | | |   v \n-      |   +--------------+                      |   +-+-+-----+-+-+-+-+  ---\n-      |                                         |   |<--MAX_OFFSET--->|   \n-      |                                         |         (bytes)\n-HDR(p)| GC_find_header(p)                       |   |<--MAP_ENTRIES-->| \n-      |                           \\ from        |    =HBLKSIZE/WORDSZ   \n-      |    (hdr) (struct hblkhdr) / alloc_hdr() |    (1024 on Alpha)\n-      +-->+----------------------+              |    (8/16 bits each)\n-GET_HDR(p)| word   hb_sz (words) |              |          \n-          +----------------------+              |     \n-          | struct hblk *hb_next |              |\n-          +----------------------+              |       \n-          |mark_proc hb_mark_proc|              |\n-          +----------------------+              |\n-          | char * hb_map        |>-------------+\n-          +----------------------+           \n-          | ushort hb_obj_kind   |           \n-          +----------------------+           \n-          |   hb_last_reclaimed  |           \n- ---      +----------------------+                \n-  ^       |                      |\n- MARK_BITS|       hb_marks[]     | *if hdr is free, hb_sz + DISCARD_WORDS\n-_SZ(words)|                      |  is the size of a heap chunk (struct hblk)\n-  v       |                      |  of at least MININCR*HBLKSIZE bytes (below),\n- ---      +----------------------+  otherwise, size of each object in chunk.\n-\n-Dynamic data structures above are interleaved throughout the heap in blocks of \n-size MININCR * HBLKSIZE bytes as done by gc_scratch_alloc which cannot be\n-freed; free lists are used (e.g. alloc_hdr).  HBLKs's below are collected.\n-\n-\t      (struct hblk)      \n- ---      +----------------------+ < HBLKSIZE ---         ---          DISCARD_\n-  ^       |garbage[DISCARD_WORDS]|   aligned   ^           ^ HDR_BYTES WORDS\n-  |       |                      |             |           v (bytes)   (words)\n-  |       +-----hb_body----------+ < WORDSZ    |          ---   ---   \n-  |       |                      |   aligned   |           ^     ^\n-  |       |      Object 0        |             |           hb_sz |\n-  |       |                      |           i |(word-    (words)|\n-  |       |                      |      (bytes)|aligned)   v     |\n-  |       + - - - - - - - - - - -+ ---         |          ---    |\n-  |       |                      |  ^          |           ^     |\n-  n *     |                      |  j (words)  |          hb_sz BODY_SZ \n- HBLKSIZE |      Object 1        |  v          v           |   (words)\n- (bytes)  |                      |---------------          v   MAX_OFFSET\n-  |       + - - - - - - - - - - -+                        ---  (bytes)\n-  |       |                      | !All_INTERIOR_PTRS      ^     |\n-  |       |                      | sets j only for       hb_sz   |\n-  |       |      Object N        | valid object offsets.   |     |\n-  v       |                      | All objects WORDSZ      v     v\n- ---      +----------------------+ aligned.               ---   ---\n-\n-DISCARD_WORDS is normally zero.  Indeed the collector has not been tested\n-with another value in ages."}, {"sha": "ae2f95cb3fe207d911dade789078327631f59aad", "filename": "boehm-gc/blacklst.c", "status": "modified", "additions": 21, "deletions": 19, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9110a741e35c54e46c00662ddc420575376c5947/boehm-gc%2Fblacklst.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9110a741e35c54e46c00662ddc420575376c5947/boehm-gc%2Fblacklst.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fblacklst.c?ref=9110a741e35c54e46c00662ddc420575376c5947", "patch": "@@ -12,7 +12,7 @@\n  * modified is included with the above copyright notice.\n  */\n /* Boehm, August 9, 1995 6:09 pm PDT */\n-# include \"gc_priv.h\"\n+# include \"private/gc_priv.h\"\n \n /*\n  * We maintain several hash tables of hblks that have had false hits.\n@@ -52,15 +52,19 @@ word GC_black_list_spacing = MINHINCR*HBLKSIZE;  /* Initial rough guess */\n \n void GC_clear_bl();\n \n-void GC_default_print_heap_obj_proc(p)\n-ptr_t p;\n+# if defined(__STDC__) || defined(__cplusplus)\n+    void GC_default_print_heap_obj_proc(ptr_t p)\n+# else\n+    void GC_default_print_heap_obj_proc(p)\n+    ptr_t p;\n+# endif\n {\n     ptr_t base = GC_base(p);\n \n     GC_err_printf2(\"start: 0x%lx, appr. length: %ld\", base, GC_size(base));\n }\n \n-void (*GC_print_heap_obj)(/* char * s, ptr_t p */) =\n+void (*GC_print_heap_obj) GC_PROTO((ptr_t p)) =\n \t\t\t\tGC_default_print_heap_obj_proc;\n \n void GC_print_source_ptr(p)\n@@ -81,18 +85,18 @@ ptr_t p;\n \n void GC_bl_init()\n {\n-# ifndef ALL_INTERIOR_POINTERS\n-    GC_old_normal_bl = (word *)\n+    if (!GC_all_interior_pointers) {\n+      GC_old_normal_bl = (word *)\n     \t\t\t GC_scratch_alloc((word)(sizeof (page_hash_table)));\n-    GC_incomplete_normal_bl = (word *)GC_scratch_alloc\n+      GC_incomplete_normal_bl = (word *)GC_scratch_alloc\n     \t\t\t\t\t((word)(sizeof(page_hash_table)));\n-    if (GC_old_normal_bl == 0 || GC_incomplete_normal_bl == 0) {\n+      if (GC_old_normal_bl == 0 || GC_incomplete_normal_bl == 0) {\n         GC_err_printf0(\"Insufficient memory for black list\\n\");\n         EXIT();\n+      }\n+      GC_clear_bl(GC_old_normal_bl);\n+      GC_clear_bl(GC_incomplete_normal_bl);\n     }\n-    GC_clear_bl(GC_old_normal_bl);\n-    GC_clear_bl(GC_incomplete_normal_bl);\n-# endif\n     GC_old_stack_bl = (word *)GC_scratch_alloc((word)(sizeof(page_hash_table)));\n     GC_incomplete_stack_bl = (word *)GC_scratch_alloc\n     \t\t\t\t\t((word)(sizeof(page_hash_table)));\n@@ -127,9 +131,9 @@ void GC_promote_black_lists()\n     \n     GC_old_normal_bl = GC_incomplete_normal_bl;\n     GC_old_stack_bl = GC_incomplete_stack_bl;\n-#   ifndef ALL_INTERIOR_POINTERS\n+    if (!GC_all_interior_pointers) {\n       GC_clear_bl(very_old_normal_bl);\n-#   endif\n+    }\n     GC_clear_bl(very_old_stack_bl);\n     GC_incomplete_normal_bl = very_old_normal_bl;\n     GC_incomplete_stack_bl = very_old_stack_bl;\n@@ -156,13 +160,12 @@ void GC_promote_black_lists()\n \n void GC_unpromote_black_lists()\n {\n-#   ifndef ALL_INTERIOR_POINTERS\n+    if (!GC_all_interior_pointers) {\n       GC_copy_bl(GC_old_normal_bl, GC_incomplete_normal_bl);\n-#   endif\n+    }\n     GC_copy_bl(GC_old_stack_bl, GC_incomplete_stack_bl);\n }\n \n-# ifndef ALL_INTERIOR_POINTERS\n /* P is not a valid pointer reference, but it falls inside\t*/\n /* the plausible heap bounds.\t\t\t\t\t*/\n /* Add it to the normal incomplete black list if appropriate.\t*/\n@@ -193,7 +196,6 @@ word p;\n           /* object, and isn't worth black listing.\t\t\t    */\n     }\n }\n-# endif\n \n /* And the same for false pointers from the stack. */\n #ifdef PRINT_BLACK_LIST\n@@ -236,12 +238,12 @@ word len;\n     register word i;\n     word nblocks = divHBLKSZ(len);\n \n-#   ifndef ALL_INTERIOR_POINTERS\n+    if (!GC_all_interior_pointers) {\n       if (get_pht_entry_from_index(GC_old_normal_bl, index)\n           || get_pht_entry_from_index(GC_incomplete_normal_bl, index)) {\n         return(h+1);\n       }\n-#   endif\n+    }\n     \n     for (i = 0; ; ) {\n         if (GC_old_stack_bl[divWORDSZ(index)] == 0"}, {"sha": "121c36d4be2f338cb5fd183ee40dd4e07380238d", "filename": "boehm-gc/checksums.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9110a741e35c54e46c00662ddc420575376c5947/boehm-gc%2Fchecksums.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9110a741e35c54e46c00662ddc420575376c5947/boehm-gc%2Fchecksums.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fchecksums.c?ref=9110a741e35c54e46c00662ddc420575376c5947", "patch": "@@ -80,7 +80,7 @@ int index;\n     if (pe -> block != 0 && pe -> block != h + OFFSET) ABORT(\"goofed\");\n     pe -> old_sum = pe -> new_sum;\n     pe -> new_sum = GC_checksum(h);\n-#   ifndef MSWIN32\n+#   if !defined(MSWIN32) && !defined(MSWINCE)\n         if (pe -> new_sum != 0 && !GC_page_was_ever_dirty(h)) {\n             GC_printf1(\"GC_page_was_ever_dirty(0x%lx) is wrong\\n\",\n         \t       (unsigned long)h);"}, {"sha": "99d69ae7fd59ff5274da039a4101c1d2e245e714", "filename": "boehm-gc/configure", "status": "modified", "additions": 77, "deletions": 88, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9110a741e35c54e46c00662ddc420575376c5947/boehm-gc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9110a741e35c54e46c00662ddc420575376c5947/boehm-gc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fconfigure?ref=9110a741e35c54e46c00662ddc420575376c5947", "patch": "@@ -57,7 +57,6 @@ program_suffix=NONE\n program_transform_name=s,x,x,\n silent=\n site=\n-sitefile=\n srcdir=\n target=NONE\n verbose=\n@@ -172,7 +171,6 @@ Configuration:\n   --help                  print this message\n   --no-create             do not create output files\n   --quiet, --silent       do not print \\`checking...' messages\n-  --site-file=FILE        use FILE as the site file\n   --version               print the version of autoconf that created configure\n Directory and file names:\n   --prefix=PREFIX         install architecture-independent files in PREFIX\n@@ -343,11 +341,6 @@ EOF\n   -site=* | --site=* | --sit=*)\n     site=\"$ac_optarg\" ;;\n \n-  -site-file | --site-file | --site-fil | --site-fi | --site-f)\n-    ac_prev=sitefile ;;\n-  -site-file=* | --site-file=* | --site-fil=* | --site-fi=* | --site-f=*)\n-    sitefile=\"$ac_optarg\" ;;\n-\n   -srcdir | --srcdir | --srcdi | --srcd | --src | --sr)\n     ac_prev=srcdir ;;\n   -srcdir=* | --srcdir=* | --srcdi=* | --srcd=* | --src=* | --sr=*)\n@@ -487,7 +480,7 @@ echo > confdefs.h\n \n # A filename unique to this package, relative to the directory that\n # configure is in, which we can look for to find out if srcdir is correct.\n-ac_unique_file=gc_mark.h\n+ac_unique_file=gcj_mlc.c\n \n # Find the source files, if location was not specified.\n if test -z \"$srcdir\"; then\n@@ -513,16 +506,12 @@ fi\n srcdir=`echo \"${srcdir}\" | sed 's%\\([^/]\\)/*$%\\1%'`\n \n # Prefer explicitly selected file to automatically selected ones.\n-if test -z \"$sitefile\"; then\n-  if test -z \"$CONFIG_SITE\"; then\n-    if test \"x$prefix\" != xNONE; then\n-      CONFIG_SITE=\"$prefix/share/config.site $prefix/etc/config.site\"\n-    else\n-      CONFIG_SITE=\"$ac_default_prefix/share/config.site $ac_default_prefix/etc/config.site\"\n-    fi\n+if test -z \"$CONFIG_SITE\"; then\n+  if test \"x$prefix\" != xNONE; then\n+    CONFIG_SITE=\"$prefix/share/config.site $prefix/etc/config.site\"\n+  else\n+    CONFIG_SITE=\"$ac_default_prefix/share/config.site $ac_default_prefix/etc/config.site\"\n   fi\n-else\n-  CONFIG_SITE=\"$sitefile\"\n fi\n for ac_site_file in $CONFIG_SITE; do\n   if test -r \"$ac_site_file\"; then\n@@ -610,7 +599,7 @@ else { echo \"configure: error: can not run $ac_config_sub\" 1>&2; exit 1; }\n fi\n \n echo $ac_n \"checking host system type\"\"... $ac_c\" 1>&6\n-echo \"configure:614: checking host system type\" >&5\n+echo \"configure:603: checking host system type\" >&5\n \n host_alias=$host\n case \"$host_alias\" in\n@@ -631,7 +620,7 @@ host_os=`echo $host | sed 's/^\\([^-]*\\)-\\([^-]*\\)-\\(.*\\)$/\\3/'`\n echo \"$ac_t\"\"$host\" 1>&6\n \n echo $ac_n \"checking target system type\"\"... $ac_c\" 1>&6\n-echo \"configure:635: checking target system type\" >&5\n+echo \"configure:624: checking target system type\" >&5\n \n target_alias=$target\n case \"$target_alias\" in\n@@ -649,7 +638,7 @@ target_os=`echo $target | sed 's/^\\([^-]*\\)-\\([^-]*\\)-\\(.*\\)$/\\3/'`\n echo \"$ac_t\"\"$target\" 1>&6\n \n echo $ac_n \"checking build system type\"\"... $ac_c\" 1>&6\n-echo \"configure:653: checking build system type\" >&5\n+echo \"configure:642: checking build system type\" >&5\n \n build_alias=$build\n case \"$build_alias\" in\n@@ -684,7 +673,7 @@ test \"$host_alias\" != \"$target_alias\" &&\n # SVR4 /usr/ucb/install, which tries to use the nonexistent group \"staff\"\n # ./install, which can be erroneously created by make from ./install.sh.\n echo $ac_n \"checking for a BSD compatible install\"\"... $ac_c\" 1>&6\n-echo \"configure:688: checking for a BSD compatible install\" >&5\n+echo \"configure:677: checking for a BSD compatible install\" >&5\n if test -z \"$INSTALL\"; then\n if eval \"test \\\"`echo '$''{'ac_cv_path_install'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n@@ -737,7 +726,7 @@ test -z \"$INSTALL_SCRIPT\" && INSTALL_SCRIPT='${INSTALL_PROGRAM}'\n test -z \"$INSTALL_DATA\" && INSTALL_DATA='${INSTALL} -m 644'\n \n echo $ac_n \"checking whether build environment is sane\"\"... $ac_c\" 1>&6\n-echo \"configure:741: checking whether build environment is sane\" >&5\n+echo \"configure:730: checking whether build environment is sane\" >&5\n # Just in case\n sleep 1\n echo timestamp > conftestfile\n@@ -794,7 +783,7 @@ test \"$program_suffix\" != NONE &&\n test \"$program_transform_name\" = \"\" && program_transform_name=\"s,x,x,\"\n \n echo $ac_n \"checking whether ${MAKE-make} sets \\${MAKE}\"\"... $ac_c\" 1>&6\n-echo \"configure:798: checking whether ${MAKE-make} sets \\${MAKE}\" >&5\n+echo \"configure:787: checking whether ${MAKE-make} sets \\${MAKE}\" >&5\n set dummy ${MAKE-make}; ac_make=`echo \"$2\" | sed 'y%./+-%__p_%'`\n if eval \"test \\\"`echo '$''{'ac_cv_prog_make_${ac_make}_set'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n@@ -827,12 +816,12 @@ else\n fi\n \n echo $ac_n \"checking for Cygwin environment\"\"... $ac_c\" 1>&6\n-echo \"configure:831: checking for Cygwin environment\" >&5\n+echo \"configure:820: checking for Cygwin environment\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_cygwin'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 836 \"configure\"\n+#line 825 \"configure\"\n #include \"confdefs.h\"\n \n int main() {\n@@ -843,7 +832,7 @@ int main() {\n return __CYGWIN__;\n ; return 0; }\n EOF\n-if { (eval echo configure:847: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n+if { (eval echo configure:836: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n   rm -rf conftest*\n   ac_cv_cygwin=yes\n else\n@@ -860,19 +849,19 @@ echo \"$ac_t\"\"$ac_cv_cygwin\" 1>&6\n CYGWIN=\n test \"$ac_cv_cygwin\" = yes && CYGWIN=yes\n echo $ac_n \"checking for mingw32 environment\"\"... $ac_c\" 1>&6\n-echo \"configure:864: checking for mingw32 environment\" >&5\n+echo \"configure:853: checking for mingw32 environment\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_mingw32'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 869 \"configure\"\n+#line 858 \"configure\"\n #include \"confdefs.h\"\n \n int main() {\n return __MINGW32__;\n ; return 0; }\n EOF\n-if { (eval echo configure:876: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n+if { (eval echo configure:865: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n   rm -rf conftest*\n   ac_cv_mingw32=yes\n else\n@@ -920,7 +909,7 @@ else { echo \"configure: error: can not run $ac_config_sub\" 1>&2; exit 1; }\n fi\n \n echo $ac_n \"checking host system type\"\"... $ac_c\" 1>&6\n-echo \"configure:924: checking host system type\" >&5\n+echo \"configure:913: checking host system type\" >&5\n \n host_alias=$host\n case \"$host_alias\" in\n@@ -954,7 +943,7 @@ fi\n \n missing_dir=`cd $ac_aux_dir && pwd`\n echo $ac_n \"checking for working aclocal\"\"... $ac_c\" 1>&6\n-echo \"configure:958: checking for working aclocal\" >&5\n+echo \"configure:947: checking for working aclocal\" >&5\n # Run test in a subshell; some versions of sh will print an error if\n # an executable is not found, even if stderr is redirected.\n # Redirect stdin to placate older versions of autoconf.  Sigh.\n@@ -967,7 +956,7 @@ else\n fi\n \n echo $ac_n \"checking for working autoconf\"\"... $ac_c\" 1>&6\n-echo \"configure:971: checking for working autoconf\" >&5\n+echo \"configure:960: checking for working autoconf\" >&5\n # Run test in a subshell; some versions of sh will print an error if\n # an executable is not found, even if stderr is redirected.\n # Redirect stdin to placate older versions of autoconf.  Sigh.\n@@ -980,7 +969,7 @@ else\n fi\n \n echo $ac_n \"checking for working automake\"\"... $ac_c\" 1>&6\n-echo \"configure:984: checking for working automake\" >&5\n+echo \"configure:973: checking for working automake\" >&5\n # Run test in a subshell; some versions of sh will print an error if\n # an executable is not found, even if stderr is redirected.\n # Redirect stdin to placate older versions of autoconf.  Sigh.\n@@ -993,7 +982,7 @@ else\n fi\n \n echo $ac_n \"checking for working autoheader\"\"... $ac_c\" 1>&6\n-echo \"configure:997: checking for working autoheader\" >&5\n+echo \"configure:986: checking for working autoheader\" >&5\n # Run test in a subshell; some versions of sh will print an error if\n # an executable is not found, even if stderr is redirected.\n # Redirect stdin to placate older versions of autoconf.  Sigh.\n@@ -1006,7 +995,7 @@ else\n fi\n \n echo $ac_n \"checking for working makeinfo\"\"... $ac_c\" 1>&6\n-echo \"configure:1010: checking for working makeinfo\" >&5\n+echo \"configure:999: checking for working makeinfo\" >&5\n # Run test in a subshell; some versions of sh will print an error if\n # an executable is not found, even if stderr is redirected.\n # Redirect stdin to placate older versions of autoconf.  Sigh.\n@@ -1032,7 +1021,7 @@ fi\n # Extract the first word of \"gcc\", so it can be a program name with args.\n set dummy gcc; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:1036: checking for $ac_word\" >&5\n+echo \"configure:1025: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_CC'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1062,7 +1051,7 @@ if test -z \"$CC\"; then\n   # Extract the first word of \"cc\", so it can be a program name with args.\n set dummy cc; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:1066: checking for $ac_word\" >&5\n+echo \"configure:1055: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_CC'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1111,7 +1100,7 @@ fi\n fi\n \n echo $ac_n \"checking whether we are using GNU C\"\"... $ac_c\" 1>&6\n-echo \"configure:1115: checking whether we are using GNU C\" >&5\n+echo \"configure:1104: checking whether we are using GNU C\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_gcc'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1120,7 +1109,7 @@ else\n   yes;\n #endif\n EOF\n-if { ac_try='${CC-cc} -E conftest.c'; { (eval echo configure:1124: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }; } | egrep yes >/dev/null 2>&1; then\n+if { ac_try='${CC-cc} -E conftest.c'; { (eval echo configure:1113: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }; } | egrep yes >/dev/null 2>&1; then\n   ac_cv_prog_gcc=yes\n else\n   ac_cv_prog_gcc=no\n@@ -1135,7 +1124,7 @@ if test $ac_cv_prog_gcc = yes; then\n   ac_save_CFLAGS=\"$CFLAGS\"\n   CFLAGS=\n   echo $ac_n \"checking whether ${CC-cc} accepts -g\"\"... $ac_c\" 1>&6\n-echo \"configure:1139: checking whether ${CC-cc} accepts -g\" >&5\n+echo \"configure:1128: checking whether ${CC-cc} accepts -g\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_cc_g'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1172,7 +1161,7 @@ do\n # Extract the first word of \"$ac_prog\", so it can be a program name with args.\n set dummy $ac_prog; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:1176: checking for $ac_word\" >&5\n+echo \"configure:1165: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_CXX'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1205,7 +1194,7 @@ test -n \"$CXX\" || CXX=\"gcc\"\n test -z \"$CXX\" && { echo \"configure: error: no acceptable c++ found in \\$PATH\" 1>&2; exit 1; }\n \n echo $ac_n \"checking whether we are using GNU C++\"\"... $ac_c\" 1>&6\n-echo \"configure:1209: checking whether we are using GNU C++\" >&5\n+echo \"configure:1198: checking whether we are using GNU C++\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_gxx'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1214,7 +1203,7 @@ else\n   yes;\n #endif\n EOF\n-if { ac_try='${CXX-g++} -E conftest.C'; { (eval echo configure:1218: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }; } | egrep yes >/dev/null 2>&1; then\n+if { ac_try='${CXX-g++} -E conftest.C'; { (eval echo configure:1207: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }; } | egrep yes >/dev/null 2>&1; then\n   ac_cv_prog_gxx=yes\n else\n   ac_cv_prog_gxx=no\n@@ -1229,7 +1218,7 @@ if test $ac_cv_prog_gxx = yes; then\n   ac_save_CXXFLAGS=\"$CXXFLAGS\"\n   CXXFLAGS=\n   echo $ac_n \"checking whether ${CXX-g++} accepts -g\"\"... $ac_c\" 1>&6\n-echo \"configure:1233: checking whether ${CXX-g++} accepts -g\" >&5\n+echo \"configure:1222: checking whether ${CXX-g++} accepts -g\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_cxx_g'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1262,7 +1251,7 @@ fi\n # NEWLIB_CONFIGURE, which doesn't work because that means that it will\n # be run before AC_CANONICAL_HOST.\n echo $ac_n \"checking build system type\"\"... $ac_c\" 1>&6\n-echo \"configure:1266: checking build system type\" >&5\n+echo \"configure:1255: checking build system type\" >&5\n \n build_alias=$build\n case \"$build_alias\" in\n@@ -1283,7 +1272,7 @@ echo \"$ac_t\"\"$build\" 1>&6\n # Extract the first word of \"${ac_tool_prefix}as\", so it can be a program name with args.\n set dummy ${ac_tool_prefix}as; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:1287: checking for $ac_word\" >&5\n+echo \"configure:1276: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_AS'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1315,7 +1304,7 @@ fi\n # Extract the first word of \"${ac_tool_prefix}ar\", so it can be a program name with args.\n set dummy ${ac_tool_prefix}ar; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:1319: checking for $ac_word\" >&5\n+echo \"configure:1308: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_AR'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1347,7 +1336,7 @@ fi\n # Extract the first word of \"${ac_tool_prefix}ranlib\", so it can be a program name with args.\n set dummy ${ac_tool_prefix}ranlib; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:1351: checking for $ac_word\" >&5\n+echo \"configure:1340: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_RANLIB'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1379,7 +1368,7 @@ if test -n \"$ac_tool_prefix\"; then\n   # Extract the first word of \"ranlib\", so it can be a program name with args.\n set dummy ranlib; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:1383: checking for $ac_word\" >&5\n+echo \"configure:1372: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_RANLIB'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1424,7 +1413,7 @@ fi\n # SVR4 /usr/ucb/install, which tries to use the nonexistent group \"staff\"\n # ./install, which can be erroneously created by make from ./install.sh.\n echo $ac_n \"checking for a BSD compatible install\"\"... $ac_c\" 1>&6\n-echo \"configure:1428: checking for a BSD compatible install\" >&5\n+echo \"configure:1417: checking for a BSD compatible install\" >&5\n if test -z \"$INSTALL\"; then\n if eval \"test \\\"`echo '$''{'ac_cv_path_install'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n@@ -1478,7 +1467,7 @@ test -z \"$INSTALL_DATA\" && INSTALL_DATA='${INSTALL} -m 644'\n \n \n echo $ac_n \"checking whether to enable maintainer-specific portions of Makefiles\"\"... $ac_c\" 1>&6\n-echo \"configure:1482: checking whether to enable maintainer-specific portions of Makefiles\" >&5\n+echo \"configure:1471: checking whether to enable maintainer-specific portions of Makefiles\" >&5\n     # Check whether --enable-maintainer-mode or --disable-maintainer-mode was given.\n if test \"${enable_maintainer_mode+set}\" = set; then\n   enableval=\"$enable_maintainer_mode\"\n@@ -1512,7 +1501,7 @@ if false; then\n   \n \n echo $ac_n \"checking for executable suffix\"\"... $ac_c\" 1>&6\n-echo \"configure:1516: checking for executable suffix\" >&5\n+echo \"configure:1505: checking for executable suffix\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_exeext'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1522,10 +1511,10 @@ else\n   rm -f conftest*\n   echo 'int main () { return 0; }' > conftest.$ac_ext\n   ac_cv_exeext=\n-  if { (eval echo configure:1526: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; }; then\n+  if { (eval echo configure:1515: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; }; then\n     for file in conftest.*; do\n       case $file in\n-      *.c | *.o | *.obj | *.ilk | *.pdb) ;;\n+      *.c | *.o | *.obj) ;;\n       *) ac_cv_exeext=`echo $file | sed -e s/conftest//` ;;\n       esac\n     done\n@@ -1645,7 +1634,7 @@ ac_prog=ld\n if test \"$GCC\" = yes; then\n   # Check if gcc -print-prog-name=ld gives a path.\n   echo $ac_n \"checking for ld used by GCC\"\"... $ac_c\" 1>&6\n-echo \"configure:1649: checking for ld used by GCC\" >&5\n+echo \"configure:1638: checking for ld used by GCC\" >&5\n   case $host in\n   *-*-mingw*)\n     # gcc leaves a trailing carriage return which upsets mingw\n@@ -1675,10 +1664,10 @@ echo \"configure:1649: checking for ld used by GCC\" >&5\n   esac\n elif test \"$with_gnu_ld\" = yes; then\n   echo $ac_n \"checking for GNU ld\"\"... $ac_c\" 1>&6\n-echo \"configure:1679: checking for GNU ld\" >&5\n+echo \"configure:1668: checking for GNU ld\" >&5\n else\n   echo $ac_n \"checking for non-GNU ld\"\"... $ac_c\" 1>&6\n-echo \"configure:1682: checking for non-GNU ld\" >&5\n+echo \"configure:1671: checking for non-GNU ld\" >&5\n fi\n if eval \"test \\\"`echo '$''{'lt_cv_path_LD'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n@@ -1713,7 +1702,7 @@ else\n fi\n test -z \"$LD\" && { echo \"configure: error: no acceptable ld found in \\$PATH\" 1>&2; exit 1; }\n echo $ac_n \"checking if the linker ($LD) is GNU ld\"\"... $ac_c\" 1>&6\n-echo \"configure:1717: checking if the linker ($LD) is GNU ld\" >&5\n+echo \"configure:1706: checking if the linker ($LD) is GNU ld\" >&5\n if eval \"test \\\"`echo '$''{'lt_cv_prog_gnu_ld'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1730,7 +1719,7 @@ with_gnu_ld=$lt_cv_prog_gnu_ld\n \n \n echo $ac_n \"checking for $LD option to reload object files\"\"... $ac_c\" 1>&6\n-echo \"configure:1734: checking for $LD option to reload object files\" >&5\n+echo \"configure:1723: checking for $LD option to reload object files\" >&5\n if eval \"test \\\"`echo '$''{'lt_cv_ld_reload_flag'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1742,7 +1731,7 @@ reload_flag=$lt_cv_ld_reload_flag\n test -n \"$reload_flag\" && reload_flag=\" $reload_flag\"\n \n echo $ac_n \"checking for BSD-compatible nm\"\"... $ac_c\" 1>&6\n-echo \"configure:1746: checking for BSD-compatible nm\" >&5\n+echo \"configure:1735: checking for BSD-compatible nm\" >&5\n if eval \"test \\\"`echo '$''{'lt_cv_path_NM'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1780,7 +1769,7 @@ NM=\"$lt_cv_path_NM\"\n echo \"$ac_t\"\"$NM\" 1>&6\n \n echo $ac_n \"checking whether ln -s works\"\"... $ac_c\" 1>&6\n-echo \"configure:1784: checking whether ln -s works\" >&5\n+echo \"configure:1773: checking whether ln -s works\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_LN_S'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1801,7 +1790,7 @@ else\n fi\n \n echo $ac_n \"checking how to recognise dependant libraries\"\"... $ac_c\" 1>&6\n-echo \"configure:1805: checking how to recognise dependant libraries\" >&5\n+echo \"configure:1794: checking how to recognise dependant libraries\" >&5\n if eval \"test \\\"`echo '$''{'lt_cv_deplibs_check_method'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1965,13 +1954,13 @@ file_magic_cmd=$lt_cv_file_magic_cmd\n deplibs_check_method=$lt_cv_deplibs_check_method\n \n echo $ac_n \"checking for object suffix\"\"... $ac_c\" 1>&6\n-echo \"configure:1969: checking for object suffix\" >&5\n+echo \"configure:1958: checking for object suffix\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_objext'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   rm -f conftest*\n echo 'int i = 1;' > conftest.$ac_ext\n-if { (eval echo configure:1975: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n+if { (eval echo configure:1964: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n   for ac_file in conftest.*; do\n     case $ac_file in\n     *.c) ;;\n@@ -1995,7 +1984,7 @@ case $deplibs_check_method in\n file_magic*)\n   if test \"$file_magic_cmd\" = '$MAGIC_CMD'; then\n     echo $ac_n \"checking for ${ac_tool_prefix}file\"\"... $ac_c\" 1>&6\n-echo \"configure:1999: checking for ${ac_tool_prefix}file\" >&5\n+echo \"configure:1988: checking for ${ac_tool_prefix}file\" >&5\n if eval \"test \\\"`echo '$''{'lt_cv_path_MAGIC_CMD'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -2057,7 +2046,7 @@ fi\n if test -z \"$lt_cv_path_MAGIC_CMD\"; then\n   if test -n \"$ac_tool_prefix\"; then\n     echo $ac_n \"checking for file\"\"... $ac_c\" 1>&6\n-echo \"configure:2061: checking for file\" >&5\n+echo \"configure:2050: checking for file\" >&5\n if eval \"test \\\"`echo '$''{'lt_cv_path_MAGIC_CMD'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -2128,7 +2117,7 @@ esac\n # Extract the first word of \"${ac_tool_prefix}ranlib\", so it can be a program name with args.\n set dummy ${ac_tool_prefix}ranlib; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:2132: checking for $ac_word\" >&5\n+echo \"configure:2121: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_RANLIB'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -2160,7 +2149,7 @@ if test -n \"$ac_tool_prefix\"; then\n   # Extract the first word of \"ranlib\", so it can be a program name with args.\n set dummy ranlib; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:2164: checking for $ac_word\" >&5\n+echo \"configure:2153: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_RANLIB'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -2195,7 +2184,7 @@ fi\n # Extract the first word of \"${ac_tool_prefix}strip\", so it can be a program name with args.\n set dummy ${ac_tool_prefix}strip; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:2199: checking for $ac_word\" >&5\n+echo \"configure:2188: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_STRIP'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -2227,7 +2216,7 @@ if test -n \"$ac_tool_prefix\"; then\n   # Extract the first word of \"strip\", so it can be a program name with args.\n set dummy strip; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:2231: checking for $ac_word\" >&5\n+echo \"configure:2220: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_STRIP'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -2294,8 +2283,8 @@ test x\"$pic_mode\" = xno && libtool_flags=\"$libtool_flags --prefer-non-pic\"\n case $host in\n *-*-irix6*)\n   # Find out which ABI we are using.\n-  echo '#line 2298 \"configure\"' > conftest.$ac_ext\n-  if { (eval echo configure:2299: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n+  echo '#line 2287 \"configure\"' > conftest.$ac_ext\n+  if { (eval echo configure:2288: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n     case `/usr/bin/file conftest.$ac_objext` in\n     *32-bit*)\n       LD=\"${LD-ld} -32\"\n@@ -2316,7 +2305,7 @@ case $host in\n   SAVE_CFLAGS=\"$CFLAGS\"\n   CFLAGS=\"$CFLAGS -belf\"\n   echo $ac_n \"checking whether the C compiler needs -belf\"\"... $ac_c\" 1>&6\n-echo \"configure:2320: checking whether the C compiler needs -belf\" >&5\n+echo \"configure:2309: checking whether the C compiler needs -belf\" >&5\n if eval \"test \\\"`echo '$''{'lt_cv_cc_needs_belf'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -2329,14 +2318,14 @@ ac_link='${CC-cc} -o conftest${ac_exeext} $CFLAGS $CPPFLAGS $LDFLAGS conftest.$a\n cross_compiling=$ac_cv_prog_cc_cross\n \n      cat > conftest.$ac_ext <<EOF\n-#line 2333 \"configure\"\n+#line 2322 \"configure\"\n #include \"confdefs.h\"\n \n int main() {\n \n ; return 0; }\n EOF\n-if { (eval echo configure:2340: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:2329: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   lt_cv_cc_needs_belf=yes\n else\n@@ -2366,7 +2355,7 @@ echo \"$ac_t\"\"$lt_cv_cc_needs_belf\" 1>&6\n esac\n \n echo $ac_n \"checking how to run the C++ preprocessor\"\"... $ac_c\" 1>&6\n-echo \"configure:2370: checking how to run the C++ preprocessor\" >&5\n+echo \"configure:2359: checking how to run the C++ preprocessor\" >&5\n if test -z \"$CXXCPP\"; then\n if eval \"test \\\"`echo '$''{'ac_cv_prog_CXXCPP'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n@@ -2379,12 +2368,12 @@ ac_link='${CXX-g++} -o conftest${ac_exeext} $CXXFLAGS $CPPFLAGS $LDFLAGS conftes\n cross_compiling=$ac_cv_prog_cxx_cross\n   CXXCPP=\"${CXX-g++} -E\"\n   cat > conftest.$ac_ext <<EOF\n-#line 2383 \"configure\"\n+#line 2372 \"configure\"\n #include \"confdefs.h\"\n #include <stdlib.h>\n EOF\n ac_try=\"$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out\"\n-{ (eval echo configure:2388: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }\n+{ (eval echo configure:2377: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }\n ac_err=`grep -v '^ *+' conftest.out | grep -v \"^conftest.${ac_ext}\\$\"`\n if test -z \"$ac_err\"; then\n   :\n@@ -2531,7 +2520,7 @@ fi\n \n \n echo $ac_n \"checking whether to enable maintainer-specific portions of Makefiles\"\"... $ac_c\" 1>&6\n-echo \"configure:2535: checking whether to enable maintainer-specific portions of Makefiles\" >&5\n+echo \"configure:2524: checking whether to enable maintainer-specific portions of Makefiles\" >&5\n     # Check whether --enable-maintainer-mode or --disable-maintainer-mode was given.\n if test \"${enable_maintainer_mode+set}\" = set; then\n   enableval=\"$enable_maintainer_mode\"\n@@ -2560,7 +2549,7 @@ if test \"x\" = \"y\"; then\n    \n \n echo $ac_n \"checking for executable suffix\"\"... $ac_c\" 1>&6\n-echo \"configure:2564: checking for executable suffix\" >&5\n+echo \"configure:2553: checking for executable suffix\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_exeext'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -2570,10 +2559,10 @@ else\n   rm -f conftest*\n   echo 'int main () { return 0; }' > conftest.$ac_ext\n   ac_cv_exeext=\n-  if { (eval echo configure:2574: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; }; then\n+  if { (eval echo configure:2563: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; }; then\n     for file in conftest.*; do\n       case $file in\n-      *.c | *.o | *.obj | *.ilk | *.pdb) ;;\n+      *.c | *.o | *.obj) ;;\n       *) ac_cv_exeext=`echo $file | sed -e s/conftest//` ;;\n       esac\n     done\n@@ -2593,11 +2582,11 @@ ac_exeext=$EXEEXT\n fi\n \n echo $ac_n \"checking for thread model used by GCC\"\"... $ac_c\" 1>&6\n-echo \"configure:2597: checking for thread model used by GCC\" >&5\n+echo \"configure:2586: checking for thread model used by GCC\" >&5\n THREADS=`$CC -v 2>&1 | sed -n 's/^Thread model: //p'`\n echo \"$ac_t\"\"$THREADS\" 1>&6\n \n-INCLUDES=\n+INCLUDES=-I${srcdir}/include\n THREADLIBS=\n case \"$THREADS\" in\n  no | none | single)\n@@ -2623,7 +2612,7 @@ EOF\n #define FREEBSD_THREADS 1\n EOF\n \n-\tINCLUDES=-pthread\n+\tINCLUDES=\"$INCLUDES -pthread\"\n \tTHREADLIBS=-pthread\n       \t;;\n      *-*-solaris*)\n@@ -2654,15 +2643,15 @@ esac\n \n \n echo $ac_n \"checking for dlopen in -ldl\"\"... $ac_c\" 1>&6\n-echo \"configure:2658: checking for dlopen in -ldl\" >&5\n+echo \"configure:2647: checking for dlopen in -ldl\" >&5\n ac_lib_var=`echo dl'_'dlopen | sed 'y%./+-%__p_%'`\n if eval \"test \\\"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   ac_save_LIBS=\"$LIBS\"\n LIBS=\"-ldl  $LIBS\"\n cat > conftest.$ac_ext <<EOF\n-#line 2666 \"configure\"\n+#line 2655 \"configure\"\n #include \"confdefs.h\"\n /* Override any gcc2 internal prototype to avoid an error.  */\n /* We use char because int might match the return type of a gcc2\n@@ -2673,7 +2662,7 @@ int main() {\n dlopen()\n ; return 0; }\n EOF\n-if { (eval echo configure:2677: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:2666: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   eval \"ac_cv_lib_$ac_lib_var=yes\"\n else"}, {"sha": "cf8a06aebf0ba1e769be238f646ff47e818a23db", "filename": "boehm-gc/configure.in", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9110a741e35c54e46c00662ddc420575376c5947/boehm-gc%2Fconfigure.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9110a741e35c54e46c00662ddc420575376c5947/boehm-gc%2Fconfigure.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fconfigure.in?ref=9110a741e35c54e46c00662ddc420575376c5947", "patch": "@@ -1,6 +1,6 @@\n dnl Process this file with autoconf to produce configure.\n \n-AC_INIT(gc_mark.h)\n+AC_INIT(gcj_mlc.c)\n \n dnl Can't be done in BOEHM_CONFIGURE because that confuses automake. \n AC_CONFIG_AUX_DIR(..)\n@@ -30,7 +30,7 @@ AC_MSG_CHECKING([for thread model used by GCC])\n THREADS=`$CC -v 2>&1 | sed -n 's/^Thread model: //p'`\n AC_MSG_RESULT([$THREADS])\n \n-INCLUDES=\n+INCLUDES=-I${srcdir}/include\n THREADLIBS=\n case \"$THREADS\" in\n  no | none | single)\n@@ -47,7 +47,7 @@ case \"$THREADS\" in\n      *-*-freebsd*)\n \tAC_MSG_WARN(\"FreeBSD does not yet fully support threads with Boehm GC.\")\n \tAC_DEFINE(FREEBSD_THREADS)\n-\tINCLUDES=-pthread\n+\tINCLUDES=\"$INCLUDES -pthread\"\n \tTHREADLIBS=-pthread\n       \t;;\n      *-*-solaris*)"}, {"sha": "62101452313098510eeb0d0a11927f685fec1545", "filename": "boehm-gc/cord/README", "status": "removed", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6951ca5dee8ed05749cdc697767910aebaedcc0/boehm-gc%2Fcord%2FREADME", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6951ca5dee8ed05749cdc697767910aebaedcc0/boehm-gc%2Fcord%2FREADME", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fcord%2FREADME?ref=a6951ca5dee8ed05749cdc697767910aebaedcc0", "patch": "@@ -1,31 +0,0 @@\n-Copyright (c) 1993-1994 by Xerox Corporation.  All rights reserved.\n-\n-THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n-OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n-\n-Permission is hereby granted to use or copy this program\n-for any purpose,  provided the above notices are retained on all copies.\n-Permission to modify the code and to distribute modified code is granted,\n-provided the above notices are retained, and a notice that the code was\n-modified is included with the above copyright notice.\n-\n-Please send bug reports to Hans-J. Boehm (boehm@sgi.com).\n-\n-This is a string packages that uses a tree-based representation.\n-See cord.h for a description of the functions provided.  Ec.h describes\n-\"extensible cords\", which are essentially output streams that write\n-to a cord.  These allow for efficient construction of cords without\n-requiring a bound on the size of a cord.\n-\n-de.c is a very dumb text editor that illustrates the use of cords.\n-It maintains a list of file versions.  Each version is simply a\n-cord representing the file contents.  Nonetheless, standard\n-editing operations are efficient, even on very large files.\n-(Its 3 line \"user manual\" can be obtained by invoking it without\n-arguments.  Note that ^R^N and ^R^P move the cursor by\n-almost a screen.  It does not understand tabs, which will show\n-up as highlighred \"I\"s.  Use the UNIX \"expand\" program first.)\n-To build the editor, type \"make cord/de\" in the gc directory.\n-\n-This package assumes an ANSI C compiler such as gcc.  It will\n-not compile with an old-style K&R compiler."}, {"sha": "2a091970b8b009ce843ba1d86af94aaab2ff0994", "filename": "boehm-gc/cord/SCOPTIONS.amiga", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6951ca5dee8ed05749cdc697767910aebaedcc0/boehm-gc%2Fcord%2FSCOPTIONS.amiga", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6951ca5dee8ed05749cdc697767910aebaedcc0/boehm-gc%2Fcord%2FSCOPTIONS.amiga", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fcord%2FSCOPTIONS.amiga?ref=a6951ca5dee8ed05749cdc697767910aebaedcc0", "patch": "@@ -1,14 +0,0 @@\n-MATH=STANDARD\n-CPU=68030\n-NOSTACKCHECK\n-OPTIMIZE\n-VERBOSE\n-NOVERSION\n-NOICONS\n-OPTIMIZERTIME\n-INCLUDEDIR=/\n-DEFINE AMIGA\n-LIBRARY=cord.lib\n-LIBRARY=/gc.lib\n-IGNORE=100\n-IGNORE=161"}, {"sha": "5aef131e606f3b585d9cb61175f30b0a3bc5a3a9", "filename": "boehm-gc/cord/SMakefile.amiga", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6951ca5dee8ed05749cdc697767910aebaedcc0/boehm-gc%2Fcord%2FSMakefile.amiga", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6951ca5dee8ed05749cdc697767910aebaedcc0/boehm-gc%2Fcord%2FSMakefile.amiga", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fcord%2FSMakefile.amiga?ref=a6951ca5dee8ed05749cdc697767910aebaedcc0", "patch": "@@ -1,20 +0,0 @@\n-# Makefile for cord.lib\n-# Michel Schinz 1994/07/20\n-\n-OBJS = cordbscs.o cordprnt.o cordxtra.o\n-\n-all: cord.lib cordtest\n-\n-cordbscs.o: cordbscs.c\n-cordprnt.o: cordprnt.c\n-cordxtra.o: cordxtra.c\n-cordtest.o: cordtest.c\n-\n-cord.lib: $(OBJS)\n-\toml cord.lib r $(OBJS)\n-\n-cordtest: cordtest.o cord.lib\n-\tsc cordtest.o link\n-\n-clean:\n-\tdelete cord.lib cordtest \\#?.o \\#?.lnk"}, {"sha": "926089e86fbb18567aa48981aa68dc152f1e7b76", "filename": "boehm-gc/cord/cord.h", "status": "removed", "additions": 0, "deletions": 327, "changes": 327, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6951ca5dee8ed05749cdc697767910aebaedcc0/boehm-gc%2Fcord%2Fcord.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6951ca5dee8ed05749cdc697767910aebaedcc0/boehm-gc%2Fcord%2Fcord.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fcord%2Fcord.h?ref=a6951ca5dee8ed05749cdc697767910aebaedcc0", "patch": "@@ -1,327 +0,0 @@\n-/* \n- * Copyright (c) 1993-1994 by Xerox Corporation.  All rights reserved.\n- *\n- * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n- * OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n- *\n- * Permission is hereby granted to use or copy this program\n- * for any purpose,  provided the above notices are retained on all copies.\n- * Permission to modify the code and to distribute modified code is granted,\n- * provided the above notices are retained, and a notice that the code was\n- * modified is included with the above copyright notice.\n- *\n- * Author: Hans-J. Boehm (boehm@parc.xerox.com)\n- */\n-/* Boehm, October 5, 1995 4:20 pm PDT */\n- \n-/*\n- * Cords are immutable character strings.  A number of operations\n- * on long cords are much more efficient than their strings.h counterpart.\n- * In particular, concatenation takes constant time independent of the length\n- * of the arguments.  (Cords are represented as trees, with internal\n- * nodes representing concatenation and leaves consisting of either C\n- * strings or a functional description of the string.)\n- *\n- * The following are reasonable applications of cords.  They would perform\n- * unacceptably if C strings were used:\n- * - A compiler that produces assembly language output by repeatedly\n- *   concatenating instructions onto a cord representing the output file.\n- * - A text editor that converts the input file to a cord, and then\n- *   performs editing operations by producing a new cord representing\n- *   the file after echa character change (and keeping the old ones in an\n- *   edit history)\n- *\n- * For optimal performance, cords should be built by\n- * concatenating short sections.\n- * This interface is designed for maximum compatibility with C strings.\n- * ASCII NUL characters may be embedded in cords using CORD_from_fn.\n- * This is handled correctly, but CORD_to_char_star will produce a string\n- * with embedded NULs when given such a cord. \n- *\n- * This interface is fairly big, largely for performance reasons.\n- * The most basic constants and functions:\n- *\n- * CORD - the type of a cord;\n- * CORD_EMPTY - empty cord;\n- * CORD_len(cord) - length of a cord;\n- * CORD_cat(cord1,cord2) - concatenation of two cords;\n- * CORD_substr(cord, start, len) - substring (or subcord);\n- * CORD_pos i;  CORD_FOR(i, cord) {  ... CORD_pos_fetch(i) ... } -\n- *    examine each character in a cord.  CORD_pos_fetch(i) is the char.\n- * CORD_fetch(int i) - Retrieve i'th character (slowly).\n- * CORD_cmp(cord1, cord2) - compare two cords.\n- * CORD_from_file(FILE * f) - turn a read-only file into a cord.\n- * CORD_to_char_star(cord) - convert to C string.\n- *   (Non-NULL C constant strings are cords.)\n- * CORD_printf (etc.) - cord version of printf. Use %r for cords.\n- */\n-# ifndef CORD_H\n-\n-# define CORD_H\n-# include <stddef.h>\n-# include <stdio.h>\n-/* Cords have type const char *.  This is cheating quite a bit, and not\t*/\n-/* 100% portable.  But it means that nonempty character string\t\t*/\n-/* constants may be used as cords directly, provided the string is\t*/\n-/* never modified in place.  The empty cord is represented by, and\t*/\n-/* can be written as, 0.\t\t\t\t\t\t*/\n-\n-typedef const char * CORD;\n-\n-/* An empty cord is always represented as nil \t*/\n-# define CORD_EMPTY 0\n-\n-/* Is a nonempty cord represented as a C string? */\n-#define CORD_IS_STRING(s) (*(s) != '\\0')\n-\n-/* Concatenate two cords.  If the arguments are C strings, they may \t*/\n-/* not be subsequently altered.\t\t\t\t\t\t*/\n-CORD CORD_cat(CORD x, CORD y);\n-\n-/* Concatenate a cord and a C string with known length.  Except for the\t*/\n-/* empty string case, this is a special case of CORD_cat.  Since the\t*/\n-/* length is known, it can be faster.\t\t\t\t\t*/\n-/* The string y is shared with the resulting CORD.  Hence it should\t*/\n-/* not be altered by the caller.\t\t\t\t\t*/\n-CORD CORD_cat_char_star(CORD x, const char * y, size_t leny);\n-\n-/* Compute the length of a cord */\n-size_t CORD_len(CORD x);\n-\n-/* Cords may be represented by functions defining the ith character */\n-typedef char (* CORD_fn)(size_t i, void * client_data);\n-\n-/* Turn a functional description into a cord. \t*/\n-CORD CORD_from_fn(CORD_fn fn, void * client_data, size_t len);\n-\n-/* Return the substring (subcord really) of x with length at most n,\t*/\n-/* starting at position i.  (The initial character has position 0.)\t*/\n-CORD CORD_substr(CORD x, size_t i, size_t n);\n-\n-/* Return the argument, but rebalanced to allow more efficient   \t*/\n-/* character retrieval, substring operations, and comparisons.\t\t*/\n-/* This is useful only for cords that were built using repeated \t*/\n-/* concatenation.  Guarantees log time access to the result, unless\t*/\n-/* x was obtained through a large number of repeated substring ops\t*/\n-/* or the embedded functional descriptions take longer to evaluate.\t*/\n-/* May reallocate significant parts of the cord.  The argument is not\t*/\n-/* modified; only the result is balanced.\t\t\t\t*/\n-CORD CORD_balance(CORD x);\n-\n-/* The following traverse a cord by applying a function to each \t*/\n-/* character.  This is occasionally appropriate, especially where\t*/\n-/* speed is crucial.  But, since C doesn't have nested functions,\t*/\n-/* clients of this sort of traversal are clumsy to write.  Consider\t*/\n-/* the functions that operate on cord positions instead.\t\t*/\n-\n-/* Function to iteratively apply to individual characters in cord.\t*/\n-typedef int (* CORD_iter_fn)(char c, void * client_data);\n-\n-/* Function to apply to substrings of a cord.  Each substring is a \t*/\n-/* a C character string, not a general cord.\t\t\t\t*/\n-typedef int (* CORD_batched_iter_fn)(const char * s, void * client_data);\n-# define CORD_NO_FN ((CORD_batched_iter_fn)0)\n-\n-/* Apply f1 to each character in the cord, in ascending order,\t\t*/\n-/* starting at position i. If\t\t\t\t\t\t*/\n-/* f2 is not CORD_NO_FN, then multiple calls to f1 may be replaced by\t*/\n-/* a single call to f2.  The parameter f2 is provided only to allow\t*/\n-/* some optimization by the client.  This terminates when the right\t*/\n-/* end of this string is reached, or when f1 or f2 return != 0.  In the\t*/\n-/* latter case CORD_iter returns != 0.  Otherwise it returns 0.\t\t*/\n-/* The specified value of i must be < CORD_len(x).\t\t\t*/\n-int CORD_iter5(CORD x, size_t i, CORD_iter_fn f1,\n-\t       CORD_batched_iter_fn f2, void * client_data);\n-\n-/* A simpler version that starts at 0, and without f2:\t*/\n-int CORD_iter(CORD x, CORD_iter_fn f1, void * client_data);\n-# define CORD_iter(x, f1, cd) CORD_iter5(x, 0, f1, CORD_NO_FN, cd)\n-\n-/* Similar to CORD_iter5, but end-to-beginning.\tNo provisions for\t*/\n-/* CORD_batched_iter_fn.\t\t\t\t\t\t*/\n-int CORD_riter4(CORD x, size_t i, CORD_iter_fn f1, void * client_data);\n-\n-/* A simpler version that starts at the end:\t*/\n-int CORD_riter(CORD x, CORD_iter_fn f1, void * client_data);\n-\n-/* Functions that operate on cord positions.  The easy way to traverse\t*/\n-/* cords.  A cord position is logically a pair consisting of a cord\t*/\n-/* and an index into that cord.  But it is much faster to retrieve a\t*/\n-/* charcter based on a position than on an index.  Unfortunately,\t*/\n-/* positions are big (order of a few 100 bytes), so allocate them with\t*/\n-/* caution.\t\t\t\t\t\t\t\t*/\n-/* Things in cord_pos.h should be treated as opaque, except as\t\t*/\n-/* described below.  Also note that\t\t\t\t\t*/\n-/* CORD_pos_fetch, CORD_next and CORD_prev have both macro and function\t*/\n-/* definitions.  The former may evaluate their argument more than once. */\n-# include \"private/cord_pos.h\"\n-\n-/*\n-\tVisible definitions from above:\n-\t\n-\ttypedef <OPAQUE but fairly big> CORD_pos[1];\n-\t\n-\t* Extract the cord from a position:\n-\tCORD CORD_pos_to_cord(CORD_pos p);\n-\t\n-\t* Extract the current index from a position:\n-\tsize_t CORD_pos_to_index(CORD_pos p);\n-\t\n-\t* Fetch the character located at the given position:\n-\tchar CORD_pos_fetch(CORD_pos p);\n-\t\n-\t* Initialize the position to refer to the given cord and index.\n-\t* Note that this is the most expensive function on positions:\n-\tvoid CORD_set_pos(CORD_pos p, CORD x, size_t i);\n-\t\n-\t* Advance the position to the next character.\n-\t* P must be initialized and valid.\n-\t* Invalidates p if past end:\n-\tvoid CORD_next(CORD_pos p);\n-\t\n-\t* Move the position to the preceding character.\n-\t* P must be initialized and valid.\n-\t* Invalidates p if past beginning:\n-\tvoid CORD_prev(CORD_pos p);\n-\t\n-\t* Is the position valid, i.e. inside the cord?\n-\tint CORD_pos_valid(CORD_pos p);\n-*/\n-# define CORD_FOR(pos, cord) \\\n-    for (CORD_set_pos(pos, cord, 0); CORD_pos_valid(pos); CORD_next(pos))\n-\n-\t\t\t\n-/* An out of memory handler to call.  May be supplied by client.\t*/\n-/* Must not return.\t\t\t\t\t\t\t*/\n-extern void (* CORD_oom_fn)(void);\n-\n-/* Dump the representation of x to stdout in an implementation defined\t*/\n-/* manner.  Intended for debugging only.\t\t\t\t*/\n-void CORD_dump(CORD x);\n-\n-/* The following could easily be implemented by the client.  They are\t*/\n-/* provided in cordxtra.c for convenience.\t\t\t\t*/\n-\n-/* Concatenate a character to the end of a cord.\t*/\n-CORD CORD_cat_char(CORD x, char c);\n-\n-/* Concatenate n cords.\t*/\n-CORD CORD_catn(int n, /* CORD */ ...);\n-\n-/* Return the character in CORD_substr(x, i, 1)  \t*/\n-char CORD_fetch(CORD x, size_t i);\n-\n-/* Return < 0, 0, or > 0, depending on whether x < y, x = y, x > y\t*/\n-int CORD_cmp(CORD x, CORD y);\n-\n-/* A generalization that takes both starting positions for the \t\t*/\n-/* comparison, and a limit on the number of characters to be compared.\t*/\n-int CORD_ncmp(CORD x, size_t x_start, CORD y, size_t y_start, size_t len);\n-\n-/* Find the first occurrence of s in x at position start or later.\t*/\n-/* Return the position of the first character of s in x, or\t\t*/\n-/* CORD_NOT_FOUND if there is none.\t\t\t\t\t*/\n-size_t CORD_str(CORD x, size_t start, CORD s);\n-\n-/* Return a cord consisting of i copies of (possibly NUL) c.  Dangerous\t*/\n-/* in conjunction with CORD_to_char_star.\t\t\t\t*/\n-/* The resulting representation takes constant space, independent of i.\t*/\n-CORD CORD_chars(char c, size_t i);\n-# define CORD_nul(i) CORD_chars('\\0', (i))\n-\n-/* Turn a file into cord.  The file must be seekable.  Its contents\t*/\n-/* must remain constant.  The file may be accessed as an immediate\t*/\n-/* result of this call and/or as a result of subsequent accesses to \t*/\n-/* the cord.  Short files are likely to be immediately read, but\t*/\n-/* long files are likely to be read on demand, possibly relying on \t*/\n-/* stdio for buffering.\t\t\t\t\t\t\t*/\n-/* We must have exclusive access to the descriptor f, i.e. we may\t*/\n-/* read it at any time, and expect the file pointer to be\t\t*/\n-/* where we left it.  Normally this should be invoked as\t\t*/\n-/* CORD_from_file(fopen(...))\t\t\t\t\t\t*/\n-/* CORD_from_file arranges to close the file descriptor when it is no\t*/\n-/* longer needed (e.g. when the result becomes inaccessible).\t\t*/ \n-/* The file f must be such that ftell reflects the actual character\t*/\n-/* position in the file, i.e. the number of characters that can be \t*/\n-/* or were read with fread.  On UNIX systems this is always true.  On\t*/\n-/* MS Windows systems, f must be opened in binary mode.\t\t\t*/\n-CORD CORD_from_file(FILE * f);\n-\n-/* Equivalent to the above, except that the entire file will be read\t*/\n-/* and the file pointer will be closed immediately.\t\t\t*/\n-/* The binary mode restriction from above does not apply.\t\t*/\n-CORD CORD_from_file_eager(FILE * f);\n-\n-/* Equivalent to the above, except that the file will be read on demand.*/\n-/* The binary mode restriction applies.\t\t\t\t\t*/\n-CORD CORD_from_file_lazy(FILE * f);\n-\n-/* Turn a cord into a C string.\tThe result shares no structure with\t*/\n-/* x, and is thus modifiable.\t\t\t\t\t\t*/\n-char * CORD_to_char_star(CORD x);\n-\n-/* Turn a C string into a CORD.  The C string is copied, and so may\t*/\n-/* subsequently be modified.\t\t\t\t\t\t*/\n-CORD CORD_from_char_star(const char *s);\n-\n-/* Identical to the above, but the result may share structure with\t*/\n-/* the argument and is thus not modifiable.\t\t\t\t*/\n-const char * CORD_to_const_char_star(CORD x); \n-\n-/* Write a cord to a file, starting at the current position.  No\t*/\n-/* trailing NULs are newlines are added.\t\t\t\t*/\n-/* Returns EOF if a write error occurs, 1 otherwise.\t\t\t*/\n-int CORD_put(CORD x, FILE * f);\n-\n-/* \"Not found\" result for the following two functions.\t\t\t*/\n-# define CORD_NOT_FOUND ((size_t)(-1))\n-\n-/* A vague analog of strchr.  Returns the position (an integer, not\t*/\n-/* a pointer) of the first occurrence of (char) c inside x at position \t*/\n-/* i or later. The value i must be < CORD_len(x).\t\t\t*/\n-size_t CORD_chr(CORD x, size_t i, int c);\n-\n-/* A vague analog of strrchr.  Returns index of the last occurrence\t*/\n-/* of (char) c inside x at position i or earlier. The value i\t\t*/\n-/* must be < CORD_len(x).\t\t\t\t\t\t*/\n-size_t CORD_rchr(CORD x, size_t i, int c);\n-\n-\n-/* The following are also not primitive, but are implemented in \t*/\n-/* cordprnt.c.  They provide functionality similar to the ANSI C\t*/\n-/* functions with corresponding names, but with the following\t\t*/\n-/* additions and changes:\t\t\t\t\t\t*/\n-/* 1. A %r conversion specification specifies a CORD argument.  Field\t*/\n-/*    width, precision, etc. have the same semantics as for %s.\t\t*/\n-/*    (Note that %c,%C, and %S were already taken.)\t\t\t*/\n-/* 2. The format string is represented as a CORD.\t\t        */\n-/* 3. CORD_sprintf and CORD_vsprintf assign the result through the 1st\t*/ \t/*    argument.\tUnlike their ANSI C versions, there is no need to guess\t*/\n-/*    the correct buffer size.\t\t\t\t\t\t*/\n-/* 4. Most of the conversions are implement through the native \t\t*/\n-/*    vsprintf.  Hence they are usually no faster, and \t\t\t*/\n-/*    idiosyncracies of the native printf are preserved.  However,\t*/\n-/*    CORD arguments to CORD_sprintf and CORD_vsprintf are NOT copied;\t*/\n-/*    the result shares the original structure.  This may make them\t*/\n-/*    very efficient in some unusual applications.\t\t\t*/\n-/*    The format string is copied.\t\t\t\t\t*/\n-/* All functions return the number of characters generated or -1 on\t*/\n-/* error.  This complies with the ANSI standard, but is inconsistent\t*/\n-/* with some older implementations of sprintf.\t\t\t\t*/\n-\n-/* The implementation of these is probably less portable than the rest\t*/\n-/* of this package.\t\t\t\t\t\t\t*/\n-\n-#ifndef CORD_NO_IO\n-\n-#include <stdarg.h>\n-\n-int CORD_sprintf(CORD * out, CORD format, ...);\n-int CORD_vsprintf(CORD * out, CORD format, va_list args);\n-int CORD_fprintf(FILE * f, CORD format, ...);\n-int CORD_vfprintf(FILE * f, CORD format, va_list args);\n-int CORD_printf(CORD format, ...);\n-int CORD_vprintf(CORD format, va_list args);\n-\n-#endif /* CORD_NO_IO */\n-\n-# endif /* CORD_H */"}, {"sha": "c829b83ad110579334a525a9c964e53e155b2462", "filename": "boehm-gc/cord/ec.h", "status": "removed", "additions": 0, "deletions": 70, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6951ca5dee8ed05749cdc697767910aebaedcc0/boehm-gc%2Fcord%2Fec.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6951ca5dee8ed05749cdc697767910aebaedcc0/boehm-gc%2Fcord%2Fec.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fcord%2Fec.h?ref=a6951ca5dee8ed05749cdc697767910aebaedcc0", "patch": "@@ -1,70 +0,0 @@\n-# ifndef EC_H\n-# define EC_H\n-\n-# ifndef CORD_H\n-#  include \"cord.h\"\n-# endif\n-\n-/* Extensible cords are strings that may be destructively appended to.\t*/\n-/* They allow fast construction of cords from characters that are\t*/\n-/* being read from a stream.\t\t\t\t\t\t*/\n-/*\n- * A client might look like:\n- *\n- *\t{\n- *\t    CORD_ec x;\n- *\t    CORD result;\n- *\t    char c;\n- *\t    FILE *f;\n- *\n- *\t    ...\n- *\t    CORD_ec_init(x);\n- *\t    while(...) {\n- *\t\tc = getc(f);\n- *\t\t...\n- *\t\tCORD_ec_append(x, c);\n- *\t    }\n- *\t    result = CORD_balance(CORD_ec_to_cord(x));\n- *\n- * If a C string is desired as the final result, the call to CORD_balance\n- * may be replaced by a call to CORD_to_char_star.\n- */\n-\n-# ifndef CORD_BUFSZ\n-#   define CORD_BUFSZ 128\n-# endif\n-\n-typedef struct CORD_ec_struct {\n-    CORD ec_cord;\n-    char * ec_bufptr;\n-    char ec_buf[CORD_BUFSZ+1];\n-} CORD_ec[1];\n-\n-/* This structure represents the concatenation of ec_cord with\t\t*/\n-/* ec_buf[0 ... (ec_bufptr-ec_buf-1)]\t\t\t\t\t*/\n-\n-/* Flush the buffer part of the extended chord into ec_cord.\t*/\n-/* Note that this is almost the only real function, and it is\t*/\n-/* implemented in 6 lines in cordxtra.c\t\t\t\t*/\n-void CORD_ec_flush_buf(CORD_ec x);\n-      \n-/* Convert an extensible cord to a cord. */\n-# define CORD_ec_to_cord(x) (CORD_ec_flush_buf(x), (x)[0].ec_cord)\n-\n-/* Initialize an extensible cord. */\n-# define CORD_ec_init(x) ((x)[0].ec_cord = 0, (x)[0].ec_bufptr = (x)[0].ec_buf)\n-\n-/* Append a character to an extensible cord.\t*/\n-# define CORD_ec_append(x, c) \\\n-    {  \\\n-\tif ((x)[0].ec_bufptr == (x)[0].ec_buf + CORD_BUFSZ) { \\\n-\t  \tCORD_ec_flush_buf(x); \\\n-\t} \\\n-\t*((x)[0].ec_bufptr)++ = (c); \\\n-    }\n-\n-/* Append a cord to an extensible cord.  Structure remains shared with \t*/\n-/* original.\t\t\t\t\t\t\t\t*/\n-void CORD_ec_append_cord(CORD_ec x, CORD s);\n-\n-# endif /* EC_H */"}, {"sha": "d7cd8996085bff60fa60408aff0662f7e054b821", "filename": "boehm-gc/cord/gc.h", "status": "removed", "additions": 0, "deletions": 804, "changes": 804, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6951ca5dee8ed05749cdc697767910aebaedcc0/boehm-gc%2Fcord%2Fgc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6951ca5dee8ed05749cdc697767910aebaedcc0/boehm-gc%2Fcord%2Fgc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fcord%2Fgc.h?ref=a6951ca5dee8ed05749cdc697767910aebaedcc0", "patch": "@@ -1,804 +0,0 @@\n-/* \n- * Copyright 1988, 1989 Hans-J. Boehm, Alan J. Demers\n- * Copyright (c) 1991-1995 by Xerox Corporation.  All rights reserved.\n- * Copyright 1996-1999 by Silicon Graphics.  All rights reserved.\n- * Copyright 1999 by Hewlett-Packard Company.  All rights reserved.\n- *\n- * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n- * OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n- *\n- * Permission is hereby granted to use or copy this program\n- * for any purpose,  provided the above notices are retained on all copies.\n- * Permission to modify the code and to distribute modified code is granted,\n- * provided the above notices are retained, and a notice that the code was\n- * modified is included with the above copyright notice.\n- */\n-\n-/*\n- * Note that this defines a large number of tuning hooks, which can\n- * safely be ignored in nearly all cases.  For normal use it suffices\n- * to call only GC_MALLOC and perhaps GC_REALLOC.\n- * For better performance, also look at GC_MALLOC_ATOMIC, and\n- * GC_enable_incremental.  If you need an action to be performed\n- * immediately before an object is collected, look at GC_register_finalizer.\n- * If you are using Solaris threads, look at the end of this file.\n- * Everything else is best ignored unless you encounter performance\n- * problems.\n- */\n- \n-#ifndef _GC_H\n-\n-# define _GC_H\n-# define __GC\n-# include <stddef.h>\n-\n-#if defined(__CYGWIN32__) && defined(GC_USE_DLL)\n-#include \"libgc_globals.h\"\n-#endif\n-\n-#if defined(__MINGW32__) && defined(WIN32_THREADS)\n-# ifdef GC_BUILD\n-#   define GC_API __declspec(dllexport)\n-# else\n-#   define GC_API __declspec(dllimport)\n-# endif\n-#endif\n-\n-#if defined(_MSC_VER) && defined(_DLL)\n-# ifdef GC_BUILD\n-#   define GC_API __declspec(dllexport)\n-# else\n-#   define GC_API __declspec(dllimport)\n-# endif\n-#endif\n-\n-#if defined(__WATCOMC__) && defined(GC_DLL)\n-# ifdef GC_BUILD\n-#   define GC_API extern __declspec(dllexport)\n-# else\n-#   define GC_API extern __declspec(dllimport)\n-# endif\n-#endif\n-\n-#ifndef GC_API\n-#define GC_API extern\n-#endif\n-\n-# if defined(__STDC__) || defined(__cplusplus)\n-#   define GC_PROTO(args) args\n-    typedef void * GC_PTR;\n-#   define GC_CONST const\n-# else\n-#   define GC_PROTO(args) ()\n-    typedef char * GC_PTR;\n-#   define GC_CONST\n-#  endif\n-\n-# ifdef __cplusplus\n-    extern \"C\" {\n-# endif\n-\n-\n-/* Define word and signed_word to be unsigned and signed types of the \t*/\n-/* size as char * or void *.  There seems to be no way to do this\t*/\n-/* even semi-portably.  The following is probably no better/worse \t*/\n-/* than almost anything else.\t\t\t\t\t\t*/\n-/* The ANSI standard suggests that size_t and ptr_diff_t might be \t*/\n-/* better choices.  But those appear to have incorrect definitions\t*/\n-/* on may systems.  Notably \"typedef int size_t\" seems to be both\t*/\n-/* frequent and WRONG.\t\t\t\t\t\t\t*/\n-typedef unsigned long GC_word;\n-typedef long GC_signed_word;\n-\n-/* Public read-only variables */\n-\n-GC_API GC_word GC_gc_no;/* Counter incremented per collection.  \t*/\n-\t\t\t/* Includes empty GCs at startup.\t\t*/\n-\t\t\t\n-\n-/* Public R/W variables */\n-\n-GC_API GC_PTR (*GC_oom_fn) GC_PROTO((size_t bytes_requested));\n-\t\t\t/* When there is insufficient memory to satisfy */\n-\t\t\t/* an allocation request, we return\t\t*/\n-\t\t\t/* (*GC_oom_fn)().  By default this just\t*/\n-\t\t\t/* returns 0.\t\t\t\t\t*/\n-\t\t\t/* If it returns, it must return 0 or a valid\t*/\n-\t\t\t/* pointer to a previously allocated heap \t*/\n-\t\t\t/* object.\t\t\t\t\t*/\n-\n-GC_API int GC_find_leak;\n-\t\t\t/* Do not actually garbage collect, but simply\t*/\n-\t\t\t/* report inaccessible memory that was not\t*/\n-\t\t\t/* deallocated with GC_free.  Initial value\t*/\n-\t\t\t/* is determined by FIND_LEAK macro.\t\t*/\n-\n-GC_API int GC_quiet;\t/* Disable statistics output.  Only matters if\t*/\n-\t\t\t/* collector has been compiled with statistics\t*/\n-\t\t\t/* enabled.  This involves a performance cost,\t*/\n-\t\t\t/* and is thus not the default.\t\t\t*/\n-\n-GC_API int GC_finalize_on_demand;\n-\t\t\t/* If nonzero, finalizers will only be run in \t*/\n-\t\t\t/* response to an eplit GC_invoke_finalizers\t*/\n-\t\t\t/* call.  The default is determined by whether\t*/\n-\t\t\t/* the FINALIZE_ON_DEMAND macro is defined\t*/\n-\t\t\t/* when the collector is built.\t\t\t*/\n-\n-GC_API int GC_java_finalization;\n-\t\t\t/* Mark objects reachable from finalizable \t*/\n-\t\t\t/* objects in a separate postpass.  This makes\t*/\n-\t\t\t/* it a bit safer to use non-topologically-\t*/\n-\t\t\t/* ordered finalization.  Default value is\t*/\n-\t\t\t/* determined by JAVA_FINALIZATION macro.\t*/\n-\n-GC_API int GC_dont_gc;\t/* Dont collect unless explicitly requested, e.g. */\n-\t\t\t/* because it's not safe.\t\t\t  */\n-\n-GC_API int GC_dont_expand;\n-\t\t\t/* Dont expand heap unless explicitly requested */\n-\t\t\t/* or forced to.\t\t\t\t*/\n-\n-GC_API int GC_use_entire_heap;\n-\t\t/* Causes the nonincremental collector to use the\t*/\n-\t\t/* entire heap before collecting.  This was the only \t*/\n-\t\t/* option for GC versions < 5.0.  This sometimes\t*/\n-\t\t/* results in more large block fragmentation, since\t*/\n-\t\t/* very larg blocks will tend to get broken up\t\t*/\n-\t\t/* during each GC cycle.  It is likely to result in a\t*/\n-\t\t/* larger working set, but lower collection\t\t*/\n-\t\t/* frequencies, and hence fewer instructions executed\t*/\n-\t\t/* in the collector.\t\t\t\t\t*/\n-\n-GC_API int GC_full_freq;    /* Number of partial collections between\t*/\n-\t\t\t    /* full collections.  Matters only if\t*/\n-\t\t\t    /* GC_incremental is set.\t\t\t*/\n-\t\t\t    /* Full collections are also triggered if\t*/\n-\t\t\t    /* the collector detects a substantial\t*/\n-\t\t\t    /* increase in the number of in-use heap\t*/\n-\t\t\t    /* blocks.  Values in the tens are now\t*/\n-\t\t\t    /* perfectly reasonable, unlike for\t\t*/\n-\t\t\t    /* earlier GC versions.\t\t\t*/\n-\t\t\t\n-GC_API GC_word GC_non_gc_bytes;\n-\t\t\t/* Bytes not considered candidates for collection. */\n-\t\t\t/* Used only to control scheduling of collections. */\n-\n-GC_API GC_word GC_free_space_divisor;\n-\t\t\t/* We try to make sure that we allocate at \t*/\n-\t\t\t/* least N/GC_free_space_divisor bytes between\t*/\n-\t\t\t/* collections, where N is the heap size plus\t*/\n-\t\t\t/* a rough estimate of the root set size.\t*/\n-\t\t\t/* Initially, GC_free_space_divisor = 4.\t*/\n-\t\t\t/* Increasing its value will use less space\t*/\n-\t\t\t/* but more collection time.  Decreasing it\t*/\n-\t\t\t/* will appreciably decrease collection time\t*/\n-\t\t\t/* at the expense of space.\t\t\t*/\n-\t\t\t/* GC_free_space_divisor = 1 will effectively\t*/\n-\t\t\t/* disable collections.\t\t\t\t*/\n-\n-GC_API GC_word GC_max_retries;\n-\t\t\t/* The maximum number of GCs attempted before\t*/\n-\t\t\t/* reporting out of memory after heap\t\t*/\n-\t\t\t/* expansion fails.  Initially 0.\t\t*/\n-\t\t\t\n-\n-GC_API char *GC_stackbottom;\t/* Cool end of user stack.\t\t*/\n-\t\t\t\t/* May be set in the client prior to\t*/\n-\t\t\t\t/* calling any GC_ routines.  This\t*/\n-\t\t\t\t/* avoids some overhead, and \t\t*/\n-\t\t\t\t/* potentially some signals that can \t*/\n-\t\t\t\t/* confuse debuggers.  Otherwise the\t*/\n-\t\t\t\t/* collector attempts to set it \t*/\n-\t\t\t\t/* automatically.\t\t\t*/\n-\t\t\t\t/* For multithreaded code, this is the\t*/\n-\t\t\t\t/* cold end of the stack for the\t*/\n-\t\t\t\t/* primordial thread.\t\t\t*/\n-\t\t\t\t\n-/* Public procedures */\n-/*\n- * general purpose allocation routines, with roughly malloc calling conv.\n- * The atomic versions promise that no relevant pointers are contained\n- * in the object.  The nonatomic versions guarantee that the new object\n- * is cleared.  GC_malloc_stubborn promises that no changes to the object\n- * will occur after GC_end_stubborn_change has been called on the\n- * result of GC_malloc_stubborn. GC_malloc_uncollectable allocates an object\n- * that is scanned for pointers to collectable objects, but is not itself\n- * collectable.  GC_malloc_uncollectable and GC_free called on the resulting\n- * object implicitly update GC_non_gc_bytes appropriately.\n- */\n-GC_API GC_PTR GC_malloc GC_PROTO((size_t size_in_bytes));\n-GC_API GC_PTR GC_malloc_atomic GC_PROTO((size_t size_in_bytes));\n-GC_API GC_PTR GC_malloc_uncollectable GC_PROTO((size_t size_in_bytes));\n-GC_API GC_PTR GC_malloc_stubborn GC_PROTO((size_t size_in_bytes));\n-\n-/* The following is only defined if the library has been suitably\t*/\n-/* compiled:\t\t\t\t\t\t\t\t*/\n-GC_API GC_PTR GC_malloc_atomic_uncollectable GC_PROTO((size_t size_in_bytes));\n-\n-/* Explicitly deallocate an object.  Dangerous if used incorrectly.     */\n-/* Requires a pointer to the base of an object.\t\t\t\t*/\n-/* If the argument is stubborn, it should not be changeable when freed. */\n-/* An object should not be enable for finalization when it is \t\t*/\n-/* explicitly deallocated.\t\t\t\t\t\t*/\n-/* GC_free(0) is a no-op, as required by ANSI C for free.\t\t*/\n-GC_API void GC_free GC_PROTO((GC_PTR object_addr));\n-\n-/*\n- * Stubborn objects may be changed only if the collector is explicitly informed.\n- * The collector is implicitly informed of coming change when such\n- * an object is first allocated.  The following routines inform the\n- * collector that an object will no longer be changed, or that it will\n- * once again be changed.  Only nonNIL pointer stores into the object\n- * are considered to be changes.  The argument to GC_end_stubborn_change\n- * must be exacly the value returned by GC_malloc_stubborn or passed to\n- * GC_change_stubborn.  (In the second case it may be an interior pointer\n- * within 512 bytes of the beginning of the objects.)\n- * There is a performance penalty for allowing more than\n- * one stubborn object to be changed at once, but it is acceptable to\n- * do so.  The same applies to dropping stubborn objects that are still\n- * changeable.\n- */\n-GC_API void GC_change_stubborn GC_PROTO((GC_PTR));\n-GC_API void GC_end_stubborn_change GC_PROTO((GC_PTR));\n-\n-/* Return a pointer to the base (lowest address) of an object given\t*/\n-/* a pointer to a location within the object.\t\t\t\t*/\n-/* Return 0 if displaced_pointer doesn't point to within a valid\t*/\n-/* object.\t\t\t\t\t\t\t\t*/\n-GC_API GC_PTR GC_base GC_PROTO((GC_PTR displaced_pointer));\n-\n-/* Given a pointer to the base of an object, return its size in bytes.\t*/\n-/* The returned size may be slightly larger than what was originally\t*/\n-/* requested.\t\t\t\t\t\t\t\t*/\n-GC_API size_t GC_size GC_PROTO((GC_PTR object_addr));\n-\n-/* For compatibility with C library.  This is occasionally faster than\t*/\n-/* a malloc followed by a bcopy.  But if you rely on that, either here\t*/\n-/* or with the standard C library, your code is broken.  In my\t\t*/\n-/* opinion, it shouldn't have been invented, but now we're stuck. -HB\t*/\n-/* The resulting object has the same kind as the original.\t\t*/\n-/* If the argument is stubborn, the result will have changes enabled.\t*/\n-/* It is an error to have changes enabled for the original object.\t*/\n-/* Follows ANSI comventions for NULL old_object.\t\t\t*/\n-GC_API GC_PTR GC_realloc\n-\tGC_PROTO((GC_PTR old_object, size_t new_size_in_bytes));\n-\t\t\t\t   \n-/* Explicitly increase the heap size.\t*/\n-/* Returns 0 on failure, 1 on success.  */\n-GC_API int GC_expand_hp GC_PROTO((size_t number_of_bytes));\n-\n-/* Limit the heap size to n bytes.  Useful when you're debugging, \t*/\n-/* especially on systems that don't handle running out of memory well.\t*/\n-/* n == 0 ==> unbounded.  This is the default.\t\t\t\t*/\n-GC_API void GC_set_max_heap_size GC_PROTO((GC_word n));\n-\n-/* Inform the collector that a certain section of statically allocated\t*/\n-/* memory contains no pointers to garbage collected memory.  Thus it \t*/\n-/* need not be scanned.  This is sometimes important if the application */\n-/* maps large read/write files into the address space, which could be\t*/\n-/* mistaken for dynamic library data segments on some systems.\t\t*/\n-GC_API void GC_exclude_static_roots GC_PROTO((GC_PTR start, GC_PTR finish));\n-\n-/* Clear the set of root segments.  Wizards only. */\n-GC_API void GC_clear_roots GC_PROTO((void));\n-\n-/* Add a root segment.  Wizards only. */\n-GC_API void GC_add_roots GC_PROTO((char * low_address,\n-\t\t\t\t   char * high_address_plus_1));\n-\n-/* Add a displacement to the set of those considered valid by the\t*/\n-/* collector.  GC_register_displacement(n) means that if p was returned */\n-/* by GC_malloc, then (char *)p + n will be considered to be a valid\t*/\n-/* pointer to n.  N must be small and less than the size of p.\t\t*/\n-/* (All pointers to the interior of objects from the stack are\t\t*/\n-/* considered valid in any case.  This applies to heap objects and\t*/\n-/* static data.)\t\t\t\t\t\t\t*/\n-/* Preferably, this should be called before any other GC procedures.\t*/\n-/* Calling it later adds to the probability of excess memory\t\t*/\n-/* retention.\t\t\t\t\t\t\t\t*/\n-/* This is a no-op if the collector was compiled with recognition of\t*/\n-/* arbitrary interior pointers enabled, which is now the default.\t*/\n-GC_API void GC_register_displacement GC_PROTO((GC_word n));\n-\n-/* The following version should be used if any debugging allocation is\t*/\n-/* being done.\t\t\t\t\t\t\t\t*/\n-GC_API void GC_debug_register_displacement GC_PROTO((GC_word n));\n-\n-/* Explicitly trigger a full, world-stop collection. \t*/\n-GC_API void GC_gcollect GC_PROTO((void));\n-\n-/* Trigger a full world-stopped collection.  Abort the collection if \t*/\n-/* and when stop_func returns a nonzero value.  Stop_func will be \t*/\n-/* called frequently, and should be reasonably fast.  This works even\t*/\n-/* if virtual dirty bits, and hence incremental collection is not \t*/\n-/* available for this architecture.  Collections can be aborted faster\t*/\n-/* than normal pause times for incremental collection.  However,\t*/\n-/* aborted collections do no useful work; the next collection needs\t*/\n-/* to start from the beginning.\t\t\t\t\t\t*/\n-/* Return 0 if the collection was aborted, 1 if it succeeded.\t\t*/\n-typedef int (* GC_stop_func) GC_PROTO((void));\n-GC_API int GC_try_to_collect GC_PROTO((GC_stop_func stop_func));\n-\n-/* Return the number of bytes in the heap.  Excludes collector private\t*/\n-/* data structures.  Includes empty blocks and fragmentation loss.\t*/\n-/* Includes some pages that were allocated but never written.\t\t*/\n-GC_API size_t GC_get_heap_size GC_PROTO((void));\n-\n-/* Return a lower bound on the number of free bytes in the heap.\t*/\n-GC_API size_t GC_get_free_bytes GC_PROTO((void));\n-\n-/* Return the number of bytes allocated since the last collection.\t*/\n-GC_API size_t GC_get_bytes_since_gc GC_PROTO((void));\n-\n-/* Enable incremental/generational collection.\t*/\n-/* Not advisable unless dirty bits are \t\t*/\n-/* available or most heap objects are\t\t*/\n-/* pointerfree(atomic) or immutable.\t\t*/\n-/* Don't use in leak finding mode.\t\t*/\n-/* Ignored if GC_dont_gc is true.\t\t*/\n-GC_API void GC_enable_incremental GC_PROTO((void));\n-\n-/* Perform some garbage collection work, if appropriate.\t*/\n-/* Return 0 if there is no more work to be done.\t\t*/\n-/* Typically performs an amount of work corresponding roughly\t*/\n-/* to marking from one page.  May do more work if further\t*/\n-/* progress requires it, e.g. if incremental collection is\t*/\n-/* disabled.  It is reasonable to call this in a wait loop\t*/\n-/* until it returns 0.\t\t\t\t\t\t*/\n-GC_API int GC_collect_a_little GC_PROTO((void));\n-\n-/* Allocate an object of size lb bytes.  The client guarantees that\t*/\n-/* as long as the object is live, it will be referenced by a pointer\t*/\n-/* that points to somewhere within the first 256 bytes of the object.\t*/\n-/* (This should normally be declared volatile to prevent the compiler\t*/\n-/* from invalidating this assertion.)  This routine is only useful\t*/\n-/* if a large array is being allocated.  It reduces the chance of \t*/\n-/* accidentally retaining such an array as a result of scanning an\t*/\n-/* integer that happens to be an address inside the array.  (Actually,\t*/\n-/* it reduces the chance of the allocator not finding space for such\t*/\n-/* an array, since it will try hard to avoid introducing such a false\t*/\n-/* reference.)  On a SunOS 4.X or MS Windows system this is recommended */\n-/* for arrays likely to be larger than 100K or so.  For other systems,\t*/\n-/* or if the collector is not configured to recognize all interior\t*/\n-/* pointers, the threshold is normally much higher.\t\t\t*/\n-GC_API GC_PTR GC_malloc_ignore_off_page GC_PROTO((size_t lb));\n-GC_API GC_PTR GC_malloc_atomic_ignore_off_page GC_PROTO((size_t lb));\n-\n-#if defined(__sgi) && !defined(__GNUC__) && _COMPILER_VERSION >= 720\n-#   define GC_ADD_CALLER\n-#   define GC_RETURN_ADDR (GC_word)__return_address\n-#endif\n-\n-#ifdef GC_ADD_CALLER\n-#  define GC_EXTRAS GC_RETURN_ADDR, __FILE__, __LINE__\n-#  define GC_EXTRA_PARAMS GC_word ra, GC_CONST char * s, int i\n-#else\n-#  define GC_EXTRAS __FILE__, __LINE__\n-#  define GC_EXTRA_PARAMS GC_CONST char * s, int i\n-#endif\n-\n-/* Debugging (annotated) allocation.  GC_gcollect will check \t\t*/\n-/* objects allocated in this way for overwrites, etc.\t\t\t*/\n-GC_API GC_PTR GC_debug_malloc\n-\tGC_PROTO((size_t size_in_bytes, GC_EXTRA_PARAMS));\n-GC_API GC_PTR GC_debug_malloc_atomic\n-\tGC_PROTO((size_t size_in_bytes, GC_EXTRA_PARAMS));\n-GC_API GC_PTR GC_debug_malloc_uncollectable\n-\tGC_PROTO((size_t size_in_bytes, GC_EXTRA_PARAMS));\n-GC_API GC_PTR GC_debug_malloc_stubborn\n-\tGC_PROTO((size_t size_in_bytes, GC_EXTRA_PARAMS));\n-GC_API void GC_debug_free GC_PROTO((GC_PTR object_addr));\n-GC_API GC_PTR GC_debug_realloc\n-\tGC_PROTO((GC_PTR old_object, size_t new_size_in_bytes,\n-  \t\t  GC_EXTRA_PARAMS));\n-  \t\t\t \t \n-GC_API void GC_debug_change_stubborn GC_PROTO((GC_PTR));\n-GC_API void GC_debug_end_stubborn_change GC_PROTO((GC_PTR));\n-# ifdef GC_DEBUG\n-#   define GC_MALLOC(sz) GC_debug_malloc(sz, GC_EXTRAS)\n-#   define GC_MALLOC_ATOMIC(sz) GC_debug_malloc_atomic(sz, GC_EXTRAS)\n-#   define GC_MALLOC_UNCOLLECTABLE(sz) GC_debug_malloc_uncollectable(sz, \\\n-\t\t\t\t\t\t\tGC_EXTRAS)\n-#   define GC_REALLOC(old, sz) GC_debug_realloc(old, sz, GC_EXTRAS)\n-#   define GC_FREE(p) GC_debug_free(p)\n-#   define GC_REGISTER_FINALIZER(p, f, d, of, od) \\\n-\tGC_debug_register_finalizer(p, f, d, of, od)\n-#   define GC_REGISTER_FINALIZER_IGNORE_SELF(p, f, d, of, od) \\\n-\tGC_debug_register_finalizer_ignore_self(p, f, d, of, od)\n-#   define GC_REGISTER_FINALIZER_NO_ORDER(p, f, d, of, od) \\\n-\tGC_debug_register_finalizer_no_order(p, f, d, of, od)\n-#   define GC_MALLOC_STUBBORN(sz) GC_debug_malloc_stubborn(sz, GC_EXTRAS);\n-#   define GC_CHANGE_STUBBORN(p) GC_debug_change_stubborn(p)\n-#   define GC_END_STUBBORN_CHANGE(p) GC_debug_end_stubborn_change(p)\n-#   define GC_GENERAL_REGISTER_DISAPPEARING_LINK(link, obj) \\\n-\tGC_general_register_disappearing_link(link, GC_base(obj))\n-#   define GC_REGISTER_DISPLACEMENT(n) GC_debug_register_displacement(n)\n-# else\n-#   define GC_MALLOC(sz) GC_malloc(sz)\n-#   define GC_MALLOC_ATOMIC(sz) GC_malloc_atomic(sz)\n-#   define GC_MALLOC_UNCOLLECTABLE(sz) GC_malloc_uncollectable(sz)\n-#   define GC_REALLOC(old, sz) GC_realloc(old, sz)\n-#   define GC_FREE(p) GC_free(p)\n-#   define GC_REGISTER_FINALIZER(p, f, d, of, od) \\\n-\tGC_register_finalizer(p, f, d, of, od)\n-#   define GC_REGISTER_FINALIZER_IGNORE_SELF(p, f, d, of, od) \\\n-\tGC_register_finalizer_ignore_self(p, f, d, of, od)\n-#   define GC_REGISTER_FINALIZER_NO_ORDER(p, f, d, of, od) \\\n-\tGC_register_finalizer_no_order(p, f, d, of, od)\n-#   define GC_MALLOC_STUBBORN(sz) GC_malloc_stubborn(sz)\n-#   define GC_CHANGE_STUBBORN(p) GC_change_stubborn(p)\n-#   define GC_END_STUBBORN_CHANGE(p) GC_end_stubborn_change(p)\n-#   define GC_GENERAL_REGISTER_DISAPPEARING_LINK(link, obj) \\\n-\tGC_general_register_disappearing_link(link, obj)\n-#   define GC_REGISTER_DISPLACEMENT(n) GC_register_displacement(n)\n-# endif\n-/* The following are included because they are often convenient, and\t*/\n-/* reduce the chance for a misspecifed size argument.  But calls may\t*/\n-/* expand to something syntactically incorrect if t is a complicated\t*/\n-/* type expression.  \t\t\t\t\t\t\t*/\n-# define GC_NEW(t) (t *)GC_MALLOC(sizeof (t))\n-# define GC_NEW_ATOMIC(t) (t *)GC_MALLOC_ATOMIC(sizeof (t))\n-# define GC_NEW_STUBBORN(t) (t *)GC_MALLOC_STUBBORN(sizeof (t))\n-# define GC_NEW_UNCOLLECTABLE(t) (t *)GC_MALLOC_UNCOLLECTABLE(sizeof (t))\n-\n-/* Finalization.  Some of these primitives are grossly unsafe.\t\t*/\n-/* The idea is to make them both cheap, and sufficient to build\t\t*/\n-/* a safer layer, closer to PCedar finalization.\t\t\t*/\n-/* The interface represents my conclusions from a long discussion\t*/\n-/* with Alan Demers, Dan Greene, Carl Hauser, Barry Hayes, \t\t*/\n-/* Christian Jacobi, and Russ Atkinson.  It's not perfect, and\t\t*/\n-/* probably nobody else agrees with it.\t    Hans-J. Boehm  3/13/92\t*/\n-typedef void (*GC_finalization_proc)\n-  \tGC_PROTO((GC_PTR obj, GC_PTR client_data));\n-\n-GC_API void GC_register_finalizer\n-    \tGC_PROTO((GC_PTR obj, GC_finalization_proc fn, GC_PTR cd,\n-\t\t  GC_finalization_proc *ofn, GC_PTR *ocd));\n-GC_API void GC_debug_register_finalizer\n-    \tGC_PROTO((GC_PTR obj, GC_finalization_proc fn, GC_PTR cd,\n-\t\t  GC_finalization_proc *ofn, GC_PTR *ocd));\n-\t/* When obj is no longer accessible, invoke\t\t*/\n-\t/* (*fn)(obj, cd).  If a and b are inaccessible, and\t*/\n-\t/* a points to b (after disappearing links have been\t*/\n-\t/* made to disappear), then only a will be\t\t*/\n-\t/* finalized.  (If this does not create any new\t\t*/\n-\t/* pointers to b, then b will be finalized after the\t*/\n-\t/* next collection.)  Any finalizable object that\t*/\n-\t/* is reachable from itself by following one or more\t*/\n-\t/* pointers will not be finalized (or collected).\t*/\n-\t/* Thus cycles involving finalizable objects should\t*/\n-\t/* be avoided, or broken by disappearing links.\t\t*/\n-\t/* All but the last finalizer registered for an object  */\n-\t/* is ignored.\t\t\t\t\t\t*/\n-\t/* Finalization may be removed by passing 0 as fn.\t*/\n-\t/* Finalizers are implicitly unregistered just before   */\n-\t/* they are invoked.\t\t\t\t\t*/\n-\t/* The old finalizer and client data are stored in\t*/\n-\t/* *ofn and *ocd.\t\t\t\t\t*/ \n-\t/* Fn is never invoked on an accessible object,\t\t*/\n-\t/* provided hidden pointers are converted to real \t*/\n-\t/* pointers only if the allocation lock is held, and\t*/\n-\t/* such conversions are not performed by finalization\t*/\n-\t/* routines.\t\t\t\t\t\t*/\n-\t/* If GC_register_finalizer is aborted as a result of\t*/\n-\t/* a signal, the object may be left with no\t\t*/\n-\t/* finalization, even if neither the old nor new\t*/\n-\t/* finalizer were NULL.\t\t\t\t\t*/\n-\t/* Obj should be the nonNULL starting address of an \t*/\n-\t/* object allocated by GC_malloc or friends.\t\t*/\n-\t/* Note that any garbage collectable object referenced\t*/\n-\t/* by cd will be considered accessible until the\t*/\n-\t/* finalizer is invoked.\t\t\t\t*/\n-\n-/* Another versions of the above follow.  It ignores\t\t*/\n-/* self-cycles, i.e. pointers from a finalizable object to\t*/\n-/* itself.  There is a stylistic argument that this is wrong,\t*/\n-/* but it's unavoidable for C++, since the compiler may\t\t*/\n-/* silently introduce these.  It's also benign in that specific\t*/\n-/* case.\t\t\t\t\t\t\t*/\n-GC_API void GC_register_finalizer_ignore_self\n-\tGC_PROTO((GC_PTR obj, GC_finalization_proc fn, GC_PTR cd,\n-\t\t  GC_finalization_proc *ofn, GC_PTR *ocd));\n-GC_API void GC_debug_register_finalizer_ignore_self\n-\tGC_PROTO((GC_PTR obj, GC_finalization_proc fn, GC_PTR cd,\n-\t\t  GC_finalization_proc *ofn, GC_PTR *ocd));\n-\n-/* Another version of the above.  It ignores all cycles.        */\n-/* It should probably only be used by Java implementations.      */\n-GC_API void GC_register_finalizer_no_order\n-\tGC_PROTO((GC_PTR obj, GC_finalization_proc fn, GC_PTR cd,\n-\t\t  GC_finalization_proc *ofn, GC_PTR *ocd));\n-GC_API void GC_debug_register_finalizer_no_order\n-\tGC_PROTO((GC_PTR obj, GC_finalization_proc fn, GC_PTR cd,\n-\t\t  GC_finalization_proc *ofn, GC_PTR *ocd));\n-\n-\n-/* The following routine may be used to break cycles between\t*/\n-/* finalizable objects, thus causing cyclic finalizable\t\t*/\n-/* objects to be finalized in the correct order.  Standard\t*/\n-/* use involves calling GC_register_disappearing_link(&p),\t*/\n-/* where p is a pointer that is not followed by finalization\t*/\n-/* code, and should not be considered in determining \t\t*/\n-/* finalization order.\t\t\t\t\t\t*/\n-GC_API int GC_register_disappearing_link GC_PROTO((GC_PTR * /* link */));\n-\t/* Link should point to a field of a heap allocated \t*/\n-\t/* object obj.  *link will be cleared when obj is\t*/\n-\t/* found to be inaccessible.  This happens BEFORE any\t*/\n-\t/* finalization code is invoked, and BEFORE any\t\t*/\n-\t/* decisions about finalization order are made.\t\t*/\n-\t/* This is useful in telling the finalizer that \t*/\n-\t/* some pointers are not essential for proper\t\t*/\n-\t/* finalization.  This may avoid finalization cycles.\t*/\n-\t/* Note that obj may be resurrected by another\t\t*/\n-\t/* finalizer, and thus the clearing of *link may\t*/\n-\t/* be visible to non-finalization code.  \t\t*/\n-\t/* There's an argument that an arbitrary action should  */\n-\t/* be allowed here, instead of just clearing a pointer. */\n-\t/* But this causes problems if that action alters, or \t*/\n-\t/* examines connectivity.\t\t\t\t*/\n-\t/* Returns 1 if link was already registered, 0\t\t*/\n-\t/* otherwise.\t\t\t\t\t\t*/\n-\t/* Only exists for backward compatibility.  See below:\t*/\n-\t\n-GC_API int GC_general_register_disappearing_link\n-\tGC_PROTO((GC_PTR * /* link */, GC_PTR obj));\n-\t/* A slight generalization of the above. *link is\t*/\n-\t/* cleared when obj first becomes inaccessible.  This\t*/\n-\t/* can be used to implement weak pointers easily and\t*/\n-\t/* safely. Typically link will point to a location\t*/\n-\t/* holding a disguised pointer to obj.  (A pointer \t*/\n-\t/* inside an \"atomic\" object is effectively  \t\t*/\n-\t/* disguised.)   In this way soft\t\t\t*/\n-\t/* pointers are broken before any object\t\t*/\n-\t/* reachable from them are finalized.  Each link\t*/\n-\t/* May be registered only once, i.e. with one obj\t*/\n-\t/* value.  This was added after a long email discussion */\n-\t/* with John Ellis.\t\t\t\t\t*/\n-\t/* Obj must be a pointer to the first word of an object */\n-\t/* we allocated.  It is unsafe to explicitly deallocate */\n-\t/* the object containing link.  Explicitly deallocating */\n-\t/* obj may or may not cause link to eventually be\t*/\n-\t/* cleared.\t\t\t\t\t\t*/\n-GC_API int GC_unregister_disappearing_link GC_PROTO((GC_PTR * /* link */));\n-\t/* Returns 0 if link was not actually registered.\t*/\n-\t/* Undoes a registration by either of the above two\t*/\n-\t/* routines.\t\t\t\t\t\t*/\n-\n-/* Auxiliary fns to make finalization work correctly with displaced\t*/\n-/* pointers introduced by the debugging allocators.\t\t\t*/\n-GC_API GC_PTR GC_make_closure GC_PROTO((GC_finalization_proc fn, GC_PTR data));\n-GC_API void GC_debug_invoke_finalizer GC_PROTO((GC_PTR obj, GC_PTR data));\n-\n-/* Returns !=0  if GC_invoke_finalizers has something to do. \t\t*/\n-GC_API int GC_should_invoke_finalizers GC_PROTO((void));\n-\n-GC_API int GC_invoke_finalizers GC_PROTO((void));\n-\t/* Run finalizers for all objects that are ready to\t*/\n-\t/* be finalized.  Return the number of finalizers\t*/\n-\t/* that were run.  Normally this is also called\t\t*/\n-\t/* implicitly during some allocations.\tIf\t\t*/\n-\t/* GC-finalize_on_demand is nonzero, it must be called\t*/\n-\t/* explicitly.\t\t\t\t\t\t*/\n-\n-/* GC_set_warn_proc can be used to redirect or filter warning messages.\t*/\n-/* p may not be a NULL pointer.\t\t\t\t\t\t*/\n-typedef void (*GC_warn_proc) GC_PROTO((char *msg, GC_word arg));\n-GC_API GC_warn_proc GC_set_warn_proc GC_PROTO((GC_warn_proc p));\n-    /* Returns old warning procedure.\t*/\n-\t\n-/* The following is intended to be used by a higher level\t*/\n-/* (e.g. cedar-like) finalization facility.  It is expected\t*/\n-/* that finalization code will arrange for hidden pointers to\t*/\n-/* disappear.  Otherwise objects can be accessed after they\t*/\n-/* have been collected.\t\t\t\t\t\t*/\n-/* Note that putting pointers in atomic objects or in \t\t*/\n-/* nonpointer slots of \"typed\" objects is equivalent to \t*/\n-/* disguising them in this way, and may have other advantages.\t*/\n-# if defined(I_HIDE_POINTERS) || defined(GC_I_HIDE_POINTERS)\n-    typedef GC_word GC_hidden_pointer;\n-#   define HIDE_POINTER(p) (~(GC_hidden_pointer)(p))\n-#   define REVEAL_POINTER(p) ((GC_PTR)(HIDE_POINTER(p)))\n-    /* Converting a hidden pointer to a real pointer requires verifying\t*/\n-    /* that the object still exists.  This involves acquiring the  \t*/\n-    /* allocator lock to avoid a race with the collector.\t\t*/\n-# endif /* I_HIDE_POINTERS */\n-\n-typedef GC_PTR (*GC_fn_type) GC_PROTO((GC_PTR client_data));\n-GC_API GC_PTR GC_call_with_alloc_lock\n-        \tGC_PROTO((GC_fn_type fn, GC_PTR client_data));\n-\n-/* Check that p and q point to the same object.  \t\t*/\n-/* Fail conspicuously if they don't.\t\t\t\t*/\n-/* Returns the first argument.  \t\t\t\t*/\n-/* Succeeds if neither p nor q points to the heap.\t\t*/\n-/* May succeed if both p and q point to between heap objects.\t*/\n-GC_API GC_PTR GC_same_obj GC_PROTO((GC_PTR p, GC_PTR q));\n-\n-/* Checked pointer pre- and post- increment operations.  Note that\t*/\n-/* the second argument is in units of bytes, not multiples of the\t*/\n-/* object size.  This should either be invoked from a macro, or the\t*/\n-/* call should be automatically generated.\t\t\t\t*/\n-GC_API GC_PTR GC_pre_incr GC_PROTO((GC_PTR *p, size_t how_much));\n-GC_API GC_PTR GC_post_incr GC_PROTO((GC_PTR *p, size_t how_much));\n-\n-/* Check that p is visible\t\t\t\t\t\t*/\n-/* to the collector as a possibly pointer containing location.\t\t*/\n-/* If it isn't fail conspicuously.\t\t\t\t\t*/\n-/* Returns the argument in all cases.  May erroneously succeed\t\t*/\n-/* in hard cases.  (This is intended for debugging use with\t\t*/\n-/* untyped allocations.  The idea is that it should be possible, though\t*/\n-/* slow, to add such a call to all indirect pointer stores.)\t\t*/\n-/* Currently useless for multithreaded worlds.\t\t\t\t*/\n-GC_API GC_PTR GC_is_visible GC_PROTO((GC_PTR p));\n-\n-/* Check that if p is a pointer to a heap page, then it points to\t*/\n-/* a valid displacement within a heap object.\t\t\t\t*/\n-/* Fail conspicuously if this property does not hold.\t\t\t*/\n-/* Uninteresting with ALL_INTERIOR_POINTERS.\t\t\t\t*/\n-/* Always returns its argument.\t\t\t\t\t\t*/\n-GC_API GC_PTR GC_is_valid_displacement GC_PROTO((GC_PTR\tp));\n-\n-/* Safer, but slow, pointer addition.  Probably useful mainly with \t*/\n-/* a preprocessor.  Useful only for heap pointers.\t\t\t*/\n-#ifdef GC_DEBUG\n-#   define GC_PTR_ADD3(x, n, type_of_result) \\\n-\t((type_of_result)GC_same_obj((x)+(n), (x)))\n-#   define GC_PRE_INCR3(x, n, type_of_result) \\\n-\t((type_of_result)GC_pre_incr(&(x), (n)*sizeof(*x))\n-#   define GC_POST_INCR2(x, type_of_result) \\\n-\t((type_of_result)GC_post_incr(&(x), sizeof(*x))\n-#   ifdef __GNUC__\n-#       define GC_PTR_ADD(x, n) \\\n-\t    GC_PTR_ADD3(x, n, typeof(x))\n-#   define GC_PRE_INCR(x, n) \\\n-\t    GC_PRE_INCR3(x, n, typeof(x))\n-#   define GC_POST_INCR(x, n) \\\n-\t    GC_POST_INCR3(x, typeof(x))\n-#   else\n-\t/* We can't do this right without typeof, which ANSI\t*/\n-\t/* decided was not sufficiently useful.  Repeatedly\t*/\n-\t/* mentioning the arguments seems too dangerous to be\t*/\n-\t/* useful.  So does not casting the result.\t\t*/\n-#   \tdefine GC_PTR_ADD(x, n) ((x)+(n))\n-#   endif\n-#else\t/* !GC_DEBUG */\n-#   define GC_PTR_ADD3(x, n, type_of_result) ((x)+(n))\n-#   define GC_PTR_ADD(x, n) ((x)+(n))\n-#   define GC_PRE_INCR3(x, n, type_of_result) ((x) += (n))\n-#   define GC_PRE_INCR(x, n) ((x) += (n))\n-#   define GC_POST_INCR2(x, n, type_of_result) ((x)++)\n-#   define GC_POST_INCR(x, n) ((x)++)\n-#endif\n-\n-/* Safer assignment of a pointer to a nonstack location.\t*/\n-#ifdef GC_DEBUG\n-# ifdef __STDC__\n-#   define GC_PTR_STORE(p, q) \\\n-\t(*(void **)GC_is_visible(p) = GC_is_valid_displacement(q))\n-# else\n-#   define GC_PTR_STORE(p, q) \\\n-\t(*(char **)GC_is_visible(p) = GC_is_valid_displacement(q))\n-# endif\n-#else /* !GC_DEBUG */\n-#   define GC_PTR_STORE(p, q) *((p) = (q))\n-#endif\n-\n-/* Fynctions called to report pointer checking errors */\n-GC_API void (*GC_same_obj_print_proc) GC_PROTO((GC_PTR p, GC_PTR q));\n-\n-GC_API void (*GC_is_valid_displacement_print_proc)\n-\tGC_PROTO((GC_PTR p));\n-\n-GC_API void (*GC_is_visible_print_proc)\n-\tGC_PROTO((GC_PTR p));\n-\n-#if defined(_SOLARIS_PTHREADS) && !defined(SOLARIS_THREADS)\n-#   define SOLARIS_THREADS\n-#endif\n-\n-#ifdef SOLARIS_THREADS\n-/* We need to intercept calls to many of the threads primitives, so \t*/\n-/* that we can locate thread stacks and stop the world.\t\t\t*/\n-/* Note also that the collector cannot see thread specific data.\t*/\n-/* Thread specific data should generally consist of pointers to\t\t*/\n-/* uncollectable objects, which are deallocated using the destructor\t*/\n-/* facility in thr_keycreate.\t\t\t\t\t\t*/\n-# include <thread.h>\n-# include <signal.h>\n-  int GC_thr_create(void *stack_base, size_t stack_size,\n-                    void *(*start_routine)(void *), void *arg, long flags,\n-                    thread_t *new_thread);\n-  int GC_thr_join(thread_t wait_for, thread_t *departed, void **status);\n-  int GC_thr_suspend(thread_t target_thread);\n-  int GC_thr_continue(thread_t target_thread);\n-  void * GC_dlopen(const char *path, int mode);\n-\n-# ifdef _SOLARIS_PTHREADS\n-#   include <pthread.h>\n-    extern int GC_pthread_create(pthread_t *new_thread,\n-    \t\t\t         const pthread_attr_t *attr,\n-          \t\t\t void * (*thread_execp)(void *), void *arg);\n-    extern int GC_pthread_join(pthread_t wait_for, void **status);\n-\n-#   undef thread_t\n-\n-#   define pthread_join GC_pthread_join\n-#   define pthread_create GC_pthread_create\n-#endif\n-\n-# define thr_create GC_thr_create\n-# define thr_join GC_thr_join\n-# define thr_suspend GC_thr_suspend\n-# define thr_continue GC_thr_continue\n-# define dlopen GC_dlopen\n-\n-# endif /* SOLARIS_THREADS */\n-\n-\n-#if !defined(USE_LD_WRAP) && \\\n-    (defined(IRIX_THREADS) || defined(LINUX_THREADS) || defined(HPUX_THREADS))\n-/* We treat these similarly. */\n-# include <pthread.h>\n-# include <signal.h>\n-\n-  int GC_pthread_create(pthread_t *new_thread,\n-                        const pthread_attr_t *attr,\n-\t\t        void *(*start_routine)(void *), void *arg);\n-  int GC_pthread_sigmask(int how, const sigset_t *set, sigset_t *oset);\n-  int GC_pthread_join(pthread_t thread, void **retval);\n-\n-# define pthread_create GC_pthread_create\n-# define pthread_sigmask GC_pthread_sigmask\n-# define pthread_join GC_pthread_join\n-# define dlopen GC_dlopen\n-\n-#endif /* xxxxx_THREADS */\n-\n-# if defined(PCR) || defined(SOLARIS_THREADS) || defined(WIN32_THREADS) || \\\n-\tdefined(IRIX_THREADS) || defined(LINUX_THREADS) || \\\n-\tdefined(IRIX_JDK_THREADS) || defined(HPUX_THREADS)\n-   \t/* Any flavor of threads except SRC_M3.\t*/\n-/* This returns a list of objects, linked through their first\t\t*/\n-/* word.  Its use can greatly reduce lock contention problems, since\t*/\n-/* the allocation lock can be acquired and released many fewer times.\t*/\n-/* lb must be large enough to hold the pointer field.\t\t\t*/\n-GC_PTR GC_malloc_many(size_t lb);\n-#define GC_NEXT(p) (*(GC_PTR *)(p)) \t/* Retrieve the next element\t*/\n-\t\t\t\t\t/* in returned list.\t\t*/\n-extern void GC_thr_init();\t/* Needed for Solaris/X86\t*/\n-\n-#endif /* THREADS && !SRC_M3 */\n-\n-/*\n- * If you are planning on putting\n- * the collector in a SunOS 5 dynamic library, you need to call GC_INIT()\n- * from the statically loaded program section.\n- * This circumvents a Solaris 2.X (X<=4) linker bug.\n- */\n-#if defined(sparc) || defined(__sparc)\n-#   define GC_INIT() { extern end, etext; \\\n-\t\t       GC_noop(&end, &etext); }\n-#else\n-# if defined(__CYGWIN32__) && defined(GC_USE_DLL)\n-    /*\n-     * Similarly gnu-win32 DLLs need explicit initialization\n-     */\n-#   define GC_INIT() { GC_add_roots(DATASTART, DATAEND); }\n-# else\n-#   define GC_INIT()\n-# endif\n-#endif\n-\n-#if (defined(_MSDOS) || defined(_MSC_VER)) && (_M_IX86 >= 300) \\\n-     || defined(_WIN32)\n-  /* win32S may not free all resources on process exit.  */\n-  /* This explicitly deallocates the heap.\t\t */\n-    GC_API void GC_win32_free_heap ();\n-#endif\n-\n-#ifdef __cplusplus\n-    }  /* end of extern \"C\" */\n-#endif\n-\n-#endif /* _GC_H */"}, {"sha": "d2b24bb8ab6d728608c4821ba93053d794f3ec34", "filename": "boehm-gc/cord/private/cord_pos.h", "status": "removed", "additions": 0, "deletions": 118, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6951ca5dee8ed05749cdc697767910aebaedcc0/boehm-gc%2Fcord%2Fprivate%2Fcord_pos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6951ca5dee8ed05749cdc697767910aebaedcc0/boehm-gc%2Fcord%2Fprivate%2Fcord_pos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fcord%2Fprivate%2Fcord_pos.h?ref=a6951ca5dee8ed05749cdc697767910aebaedcc0", "patch": "@@ -1,118 +0,0 @@\n-/* \n- * Copyright (c) 1993-1994 by Xerox Corporation.  All rights reserved.\n- *\n- * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n- * OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n- *\n- * Permission is hereby granted to use or copy this program\n- * for any purpose,  provided the above notices are retained on all copies.\n- * Permission to modify the code and to distribute modified code is granted,\n- * provided the above notices are retained, and a notice that the code was\n- * modified is included with the above copyright notice.\n- */\n-/* Boehm, May 19, 1994 2:23 pm PDT */\n-# ifndef CORD_POSITION_H\n-\n-/* The representation of CORD_position.  This is private to the\t*/\n-/* implementation, but the size is known to clients.  Also\t*/\n-/* the implementation of some exported macros relies on it.\t*/\n-/* Don't use anything defined here and not in cord.h.\t\t*/\n-\n-# define MAX_DEPTH 48\n-\t/* The maximum depth of a balanced cord + 1.\t\t*/\n-\t/* We don't let cords get deeper than MAX_DEPTH.\t*/\n-\n-struct CORD_pe {\n-    CORD pe_cord;\n-    size_t pe_start_pos;\n-};\n-\n-/* A structure describing an entry on the path from the root \t*/\n-/* to current position.\t\t\t\t\t\t*/\n-typedef struct CORD_Pos {\n-    size_t cur_pos;\n-    int path_len;\n-#\tdefine CORD_POS_INVALID (0x55555555)\n-\t\t/* path_len == INVALID <==> position invalid */\n-    const char *cur_leaf;\t/* Current leaf, if it is a string.\t*/\n-    \t\t\t\t/* If the current leaf is a function,\t*/\n-    \t\t\t\t/* then this may point to function_buf\t*/\n-    \t\t\t\t/* containing the next few characters.\t*/\n-    \t\t\t\t/* Always points to a valid string\t*/\n-    \t\t\t\t/* containing the current character \t*/\n-    \t\t\t\t/* unless cur_end is 0.\t\t\t*/\n-    size_t cur_start;\t/* Start position of cur_leaf\t*/\n-    size_t cur_end;\t/* Ending position of cur_leaf\t*/\n-    \t\t\t/* 0 if cur_leaf is invalid.\t*/\n-    struct CORD_pe path[MAX_DEPTH + 1];\n-    \t/* path[path_len] is the leaf corresponding to cur_pos\t*/\n-    \t/* path[0].pe_cord is the cord we point to.\t\t*/\n-#   define FUNCTION_BUF_SZ 8\n-    char function_buf[FUNCTION_BUF_SZ];\t/* Space for next few chars\t*/\n-    \t\t\t\t\t/* from function node.\t\t*/\n-} CORD_pos[1];\n-\n-/* Extract the cord from a position:\t*/\n-CORD CORD_pos_to_cord(CORD_pos p);\n-\t\n-/* Extract the current index from a position:\t*/\n-size_t CORD_pos_to_index(CORD_pos p);\n-\t\n-/* Fetch the character located at the given position:\t*/\n-char CORD_pos_fetch(CORD_pos p);\n-\t\n-/* Initialize the position to refer to the give cord and index.\t*/\n-/* Note that this is the most expensive function on positions:\t*/\n-void CORD_set_pos(CORD_pos p, CORD x, size_t i);\n-\t\n-/* Advance the position to the next character.\t*/\n-/* P must be initialized and valid.\t\t*/\n-/* Invalidates p if past end:\t\t\t*/\n-void CORD_next(CORD_pos p);\n-\n-/* Move the position to the preceding character.\t*/\n-/* P must be initialized and valid.\t\t\t*/\n-/* Invalidates p if past beginning:\t\t\t*/\n-void CORD_prev(CORD_pos p);\n-\t\n-/* Is the position valid, i.e. inside the cord?\t\t*/\n-int CORD_pos_valid(CORD_pos p);\n-\n-char CORD__pos_fetch(CORD_pos);\n-void CORD__next(CORD_pos);\n-void CORD__prev(CORD_pos);\n-\n-#define CORD_pos_fetch(p)\t\\\n-    (((p)[0].cur_end != 0)? \\\n-     \t(p)[0].cur_leaf[(p)[0].cur_pos - (p)[0].cur_start] \\\n-     \t: CORD__pos_fetch(p))\n-\n-#define CORD_next(p)\t\\\n-    (((p)[0].cur_pos + 1 < (p)[0].cur_end)? \\\n-    \t(p)[0].cur_pos++ \\\n-    \t: (CORD__next(p), 0))\n-\n-#define CORD_prev(p)\t\\\n-    (((p)[0].cur_end != 0 && (p)[0].cur_pos > (p)[0].cur_start)? \\\n-    \t(p)[0].cur_pos-- \\\n-    \t: (CORD__prev(p), 0))\n-\n-#define CORD_pos_to_index(p) ((p)[0].cur_pos)\n-\n-#define CORD_pos_to_cord(p) ((p)[0].path[0].pe_cord)\n-\n-#define CORD_pos_valid(p) ((p)[0].path_len != CORD_POS_INVALID)\n-\n-/* Some grubby stuff for performance-critical friends:\t*/\n-#define CORD_pos_chars_left(p) ((long)((p)[0].cur_end) - (long)((p)[0].cur_pos))\n-\t/* Number of characters in cache.  <= 0 ==> none\t*/\n-\n-#define CORD_pos_advance(p,n) ((p)[0].cur_pos += (n) - 1, CORD_next(p))\n-\t/* Advance position by n characters\t*/\n-\t/* 0 < n < CORD_pos_chars_left(p)\t*/\n-\n-#define CORD_pos_cur_char_addr(p) \\\n-\t(p)[0].cur_leaf + ((p)[0].cur_pos - (p)[0].cur_start)\n-\t/* address of current character in cache.\t*/\n-\n-#endif"}, {"sha": "abda26aa858bcf6c95da90972fa1ca56153fb24c", "filename": "boehm-gc/dbg_mlc.c", "status": "modified", "additions": 209, "deletions": 40, "changes": 249, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9110a741e35c54e46c00662ddc420575376c5947/boehm-gc%2Fdbg_mlc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9110a741e35c54e46c00662ddc420575376c5947/boehm-gc%2Fdbg_mlc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fdbg_mlc.c?ref=9110a741e35c54e46c00662ddc420575376c5947", "patch": "@@ -2,7 +2,7 @@\n  * Copyright 1988, 1989 Hans-J. Boehm, Alan J. Demers\n  * Copyright (c) 1991-1995 by Xerox Corporation.  All rights reserved.\n  * Copyright (c) 1997 by Silicon Graphics.  All rights reserved.\n- * Copyright (c) 1999 by Hewlett-Packard Company.  All rights reserved.\n+ * Copyright (c) 1999-2000 by Hewlett-Packard Company.  All rights reserved.\n  *\n  * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n  * OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n@@ -14,18 +14,25 @@\n  * modified is included with the above copyright notice.\n  */\n \n-#include \"dbg_mlc.h\"\n+#include \"private/dbg_mlc.h\"\n \n void GC_default_print_heap_obj_proc();\n GC_API void GC_register_finalizer_no_order\n     \tGC_PROTO((GC_PTR obj, GC_finalization_proc fn, GC_PTR cd,\n \t\t  GC_finalization_proc *ofn, GC_PTR *ocd));\n \n \n+#ifndef SHORT_DBG_HDRS\n /* Check whether object with base pointer p has debugging info\t*/ \n /* p is assumed to point to a legitimate object in our part\t*/\n /* of the heap.\t\t\t\t\t\t\t*/\n-GC_bool GC_has_debug_info(p)\n+/* This excludes the check as to whether tha back pointer is \t*/\n+/* odd, which is added by the GC_HAS_DEBUG_INFO macro.\t\t*/\n+/* Note that if DBG_HDRS_ALL is set, uncollectable objects\t*/\n+/* on free lists may not have debug information set.  Thus it's\t*/\n+/* not always safe to return TRUE, even if the client does\t*/\n+/* its part.\t\t\t\t\t\t\t*/\n+GC_bool GC_has_other_debug_info(p)\n ptr_t p;\n {\n     register oh * ohdr = (oh *)p;\n@@ -46,8 +53,19 @@ ptr_t p;\n     }\n     return(FALSE);\n }\n+#endif\n \n #ifdef KEEP_BACK_PTRS\n+\n+# include <stdlib.h>\n+\n+# if defined(LINUX) || defined(SUNOS4) || defined(SUNOS5) \\\n+     || defined(HPUX) || defined(IRIX) || defined(OSF1)\n+#   define RANDOM() random()\n+# else\n+#   define RANDOM() (long)rand()\n+# endif\n+\n   /* Store back pointer to source in dest, if that appears to be possible. */\n   /* This is not completely safe, since we may mistakenly conclude that\t   */\n   /* dest has a debugging wrapper.  But the error probability is very\t   */\n@@ -56,8 +74,8 @@ ptr_t p;\n   /* be a pointer to the interior of an object.\t\t\t\t   */\n   void GC_store_back_pointer(ptr_t source, ptr_t dest)\n   {\n-    if (GC_has_debug_info(dest)) {\n-      ((oh *)dest) -> oh_back_ptr = (ptr_t)HIDE_POINTER(source);\n+    if (GC_HAS_DEBUG_INFO(dest)) {\n+      ((oh *)dest) -> oh_back_ptr = HIDE_BACK_PTR(source);\n     }\n   }\n \n@@ -76,19 +94,34 @@ ptr_t p;\n     oh * hdr = (oh *)GC_base(dest);\n     ptr_t bp;\n     ptr_t bp_base;\n-    if (!GC_has_debug_info((ptr_t) hdr)) return GC_NO_SPACE;\n-    bp = hdr -> oh_back_ptr;\n+    if (!GC_HAS_DEBUG_INFO((ptr_t) hdr)) return GC_NO_SPACE;\n+    bp = REVEAL_POINTER(hdr -> oh_back_ptr);\n     if (MARKED_FOR_FINALIZATION == bp) return GC_FINALIZER_REFD;\n     if (MARKED_FROM_REGISTER == bp) return GC_REFD_FROM_REG;\n-    if (0 == bp) return GC_UNREFERENCED;\n-    bp = REVEAL_POINTER(bp);\n+    if (NOT_MARKED == bp) return GC_UNREFERENCED;\n+#   if ALIGNMENT == 1\n+      /* Heuristically try to fix off by 1 errors we introduced by \t*/\n+      /* insisting on even addresses.\t\t\t\t\t*/\n+      {\n+\tptr_t alternate_ptr = bp + 1;\n+\tptr_t target = *(ptr_t *)bp;\n+\tptr_t alternate_target = *(ptr_t *)alternate_ptr;\n+\n+\tif (alternate_target >= GC_least_plausible_heap_addr\n+\t    && alternate_target <= GC_greatest_plausible_heap_addr\n+\t    && (target < GC_least_plausible_heap_addr\n+\t\t|| target > GC_greatest_plausible_heap_addr)) {\n+\t    bp = alternate_ptr;\n+\t}\n+      }\n+#   endif\n     bp_base = GC_base(bp);\n     if (0 == bp_base) {\n       *base_p = bp;\n       *offset_p = 0;\n       return GC_REFD_FROM_ROOT;\n     } else {\n-      if (GC_has_debug_info(bp_base)) bp_base += sizeof(oh);\n+      if (GC_HAS_DEBUG_INFO(bp_base)) bp_base += sizeof(oh);\n       *base_p = bp_base;\n       *offset_p = bp - bp_base;\n       return GC_REFD_FROM_HEAP;\n@@ -101,7 +134,15 @@ ptr_t p;\n   void *GC_generate_random_heap_address(void)\n   {\n     int i;\n-    int heap_offset = random() % GC_heapsize;\n+    long heap_offset = RANDOM();\n+    if (GC_heapsize > RAND_MAX) {\n+\theap_offset *= RAND_MAX;\n+\theap_offset += RANDOM();\n+    }\n+    heap_offset %= GC_heapsize;\n+    \t/* This doesn't yield a uniform distribution, especially if\t*/\n+        /* e.g. RAND_MAX = 1.5* GC_heapsize.  But for typical cases,\t*/\n+        /* it's not too bad.\t\t\t\t\t\t*/\n     for (i = 0; i < GC_n_heap_sects; ++ i) {\n \tint size = GC_heap_sects[i].hs_bytes;\n \tif (heap_offset < size) {\n@@ -203,18 +244,50 @@ word integer;\n     /* inconsistent while we're in the handler.\t\t\t\t*/\n     LOCK();\n #   ifdef KEEP_BACK_PTRS\n-      ((oh *)p) -> oh_back_ptr = 0;\n+      ((oh *)p) -> oh_back_ptr = HIDE_BACK_PTR(NOT_MARKED);\n #   endif\n     ((oh *)p) -> oh_string = string;\n     ((oh *)p) -> oh_int = integer;\n-    ((oh *)p) -> oh_sz = sz;\n-    ((oh *)p) -> oh_sf = START_FLAG ^ (word)result;\n-    ((word *)p)[BYTES_TO_WORDS(GC_size(p))-1] =\n+#   ifndef SHORT_DBG_HDRS\n+      ((oh *)p) -> oh_sz = sz;\n+      ((oh *)p) -> oh_sf = START_FLAG ^ (word)result;\n+      ((word *)p)[BYTES_TO_WORDS(GC_size(p))-1] =\n          result[ROUNDED_UP_WORDS(sz)] = END_FLAG ^ (word)result;\n+#   endif\n     UNLOCK();\n     return((ptr_t)result);\n }\n \n+#ifdef DBG_HDRS_ALL\n+/* Store debugging info into p.  Return displaced pointer.\t   */\n+/* This version assumes we do hold the allocation lock.\t\t   */\n+ptr_t GC_store_debug_info_inner(p, sz, string, integer)\n+register ptr_t p;\t/* base pointer */\n+word sz; \t/* bytes */\n+char * string;\n+word integer;\n+{\n+    register word * result = (word *)((oh *)p + 1);\n+    \n+    /* There is some argument that we should disable signals here.\t*/\n+    /* But that's expensive.  And this way things should only appear\t*/\n+    /* inconsistent while we're in the handler.\t\t\t\t*/\n+#   ifdef KEEP_BACK_PTRS\n+      ((oh *)p) -> oh_back_ptr = 0;\n+#   endif\n+    ((oh *)p) -> oh_string = string;\n+    ((oh *)p) -> oh_int = integer;\n+#   ifndef SHORT_DBG_HDRS\n+      ((oh *)p) -> oh_sz = sz;\n+      ((oh *)p) -> oh_sf = START_FLAG ^ (word)result;\n+      ((word *)p)[BYTES_TO_WORDS(GC_size(p))-1] =\n+         result[ROUNDED_UP_WORDS(sz)] = END_FLAG ^ (word)result;\n+#   endif\n+    return((ptr_t)result);\n+}\n+#endif\n+\n+#ifndef SHORT_DBG_HDRS\n /* Check the object with debugging info at ohdr\t\t*/\n /* return NIL if it's OK.  Else return clobbered\t*/\n /* address.\t\t\t\t\t\t*/\n@@ -238,6 +311,7 @@ register oh * ohdr;\n     }\n     return(0);\n }\n+#endif /* !SHORT_DBG_HDRS */\n \n void GC_print_obj(p)\n ptr_t p;\n@@ -246,21 +320,30 @@ ptr_t p;\n     \n     GC_err_printf1(\"0x%lx (\", ((unsigned long)ohdr + sizeof(oh)));\n     GC_err_puts(ohdr -> oh_string);\n-    GC_err_printf2(\":%ld, sz=%ld)\\n\", (unsigned long)(ohdr -> oh_int),\n-        \t\t\t      (unsigned long)(ohdr -> oh_sz));\n+#   ifdef SHORT_DBG_HDRS\n+      GC_err_printf1(\":%ld, sz=%ld)\\n\", (unsigned long)(ohdr -> oh_int));\n+#   else\n+      GC_err_printf2(\":%ld, sz=%ld)\\n\", (unsigned long)(ohdr -> oh_int),\n+          \t\t\t        (unsigned long)(ohdr -> oh_sz));\n+#   endif\n     PRINT_CALL_CHAIN(ohdr);\n }\n \n-void GC_debug_print_heap_obj_proc(p)\n-ptr_t p;\n+# if defined(__STDC__) || defined(__cplusplus)\n+    void GC_debug_print_heap_obj_proc(ptr_t p)\n+# else\n+    void GC_debug_print_heap_obj_proc(p)\n+    ptr_t p;\n+# endif\n {\n-    if (GC_has_debug_info(p)) {\n+    if (GC_HAS_DEBUG_INFO(p)) {\n \tGC_print_obj(p);\n     } else {\n \tGC_default_print_heap_obj_proc(p);\n     }\n }\n \n+#ifndef SHORT_DBG_HDRS\n void GC_print_smashed_obj(p, clobbered_addr)\n ptr_t p, clobbered_addr;\n {\n@@ -283,12 +366,19 @@ ptr_t p, clobbered_addr;\n         PRINT_CALL_CHAIN(ohdr);\n     }\n }\n+#endif\n+\n+void GC_check_heap_proc GC_PROTO((void));\n \n-void GC_check_heap_proc();\n+void GC_do_nothing() {}\n \n void GC_start_debugging()\n {\n-    GC_check_heap = GC_check_heap_proc;\n+#   ifndef SHORT_DBG_HDRS\n+      GC_check_heap = GC_check_heap_proc;\n+#   else\n+      GC_check_heap = GC_do_nothing;\n+#   endif\n     GC_print_heap_obj = GC_debug_print_heap_obj_proc;\n     GC_debugging_started = TRUE;\n     GC_register_displacement((word)sizeof(oh));\n@@ -362,6 +452,43 @@ void GC_start_debugging()\n     return (GC_store_debug_info(result, (word)lb, s, (word)i));\n }\n \n+# ifdef DBG_HDRS_ALL\n+/* \n+ * An allocation function for internal use.\n+ * Normally internally allocated objects do not have debug information.\n+ * But in this case, we need to make sure that all objects have debug\n+ * headers.\n+ * We assume debugging was started in collector initialization,\n+ * and we already hold the GC lock.\n+ */\n+  GC_PTR GC_debug_generic_malloc_inner(size_t lb, int k)\n+  {\n+    GC_PTR result = GC_generic_malloc_inner(lb + DEBUG_BYTES, k);\n+    \n+    if (result == 0) {\n+        GC_err_printf1(\"GC internal allocation (%ld bytes) returning NIL\\n\",\n+        \t       (unsigned long) lb);\n+        return(0);\n+    }\n+    ADD_CALL_CHAIN(result, ra);\n+    return (GC_store_debug_info_inner(result, (word)lb, \"INTERNAL\", (word)0));\n+  }\n+\n+  GC_PTR GC_debug_generic_malloc_inner_ignore_off_page(size_t lb, int k)\n+  {\n+    GC_PTR result = GC_generic_malloc_inner_ignore_off_page(\n+\t\t\t\t\t        lb + DEBUG_BYTES, k);\n+    \n+    if (result == 0) {\n+        GC_err_printf1(\"GC internal allocation (%ld bytes) returning NIL\\n\",\n+        \t       (unsigned long) lb);\n+        return(0);\n+    }\n+    ADD_CALL_CHAIN(result, ra);\n+    return (GC_store_debug_info_inner(result, (word)lb, \"INTERNAL\", (word)0));\n+  }\n+# endif\n+\n #ifdef STUBBORN_ALLOC\n # ifdef __STDC__\n     GC_PTR GC_debug_malloc_stubborn(size_t lb, GC_EXTRA_PARAMS)\n@@ -554,18 +681,20 @@ GC_PTR p;\n         \t  \"GC_debug_free called on pointer %lx wo debugging info\\n\",\n         \t  (unsigned long)p);\n     } else {\n-      clobbered = GC_check_annotated_obj((oh *)base);\n-      if (clobbered != 0) {\n-        if (((oh *)base) -> oh_sz == GC_size(base)) {\n+#     ifndef SHORT_DBG_HDRS\n+        clobbered = GC_check_annotated_obj((oh *)base);\n+        if (clobbered != 0) {\n+          if (((oh *)base) -> oh_sz == GC_size(base)) {\n             GC_err_printf0(\n                   \"GC_debug_free: found previously deallocated (?) object at \");\n-        } else {\n+          } else {\n             GC_err_printf0(\"GC_debug_free: found smashed location at \");\n+          }\n+          GC_print_smashed_obj(p, clobbered);\n         }\n-        GC_print_smashed_obj(p, clobbered);\n-      }\n-      /* Invalidate size */\n-      ((oh *)base) -> oh_sz = GC_size(base);\n+        /* Invalidate size */\n+        ((oh *)base) -> oh_sz = GC_size(base);\n+#     endif /* SHORT_DBG_HDRS */\n     }\n     if (GC_find_leak) {\n         GC_free(base);\n@@ -585,6 +714,17 @@ GC_PTR p;\n     } /* !GC_find_leak */\n }\n \n+#ifdef THREADS\n+\n+extern void GC_free_inner(GC_PTR p);\n+\n+/* Used internally; we assume it's called correctly.\t*/\n+void GC_debug_free_inner(GC_PTR p)\n+{\n+    GC_free_inner(GC_base(p));\n+}\n+#endif\n+\n # ifdef __STDC__\n     GC_PTR GC_debug_realloc(GC_PTR p, size_t lb, GC_EXTRA_PARAMS)\n # else\n@@ -639,32 +779,41 @@ GC_PTR p;\n         GC_err_printf0(\"GC_debug_realloc: encountered bad kind\\n\");\n         ABORT(\"bad kind\");\n     }\n-    clobbered = GC_check_annotated_obj((oh *)base);\n-    if (clobbered != 0) {\n+#   ifdef SHORT_DBG_HDRS\n+      old_sz = GC_size(base) - sizeof(oh);\n+#   else\n+      clobbered = GC_check_annotated_obj((oh *)base);\n+      if (clobbered != 0) {\n         GC_err_printf0(\"GC_debug_realloc: found smashed location at \");\n         GC_print_smashed_obj(p, clobbered);\n-    }\n-    old_sz = ((oh *)base) -> oh_sz;\n+      }\n+      old_sz = ((oh *)base) -> oh_sz;\n+#   endif\n     if (old_sz < copy_sz) copy_sz = old_sz;\n     if (result == 0) return(0);\n     BCOPY(p, result,  copy_sz);\n     GC_debug_free(p);\n     return(result);\n }\n \n+#ifndef SHORT_DBG_HDRS\n /* Check all marked objects in the given block for validity */\n /*ARGSUSED*/\n-void GC_check_heap_block(hbp, dummy)\n-register struct hblk *hbp;\t/* ptr to current heap block\t\t*/\n-word dummy;\n+# if defined(__STDC__) || defined(__cplusplus)\n+    void GC_check_heap_block(register struct hblk *hbp, word dummy)\n+# else\n+    void GC_check_heap_block(hbp, dummy)\n+    register struct hblk *hbp;\t/* ptr to current heap block\t\t*/\n+    word dummy;\n+# endif\n {\n     register struct hblkhdr * hhdr = HDR(hbp);\n     register word sz = hhdr -> hb_sz;\n     register int word_no;\n     register word *p, *plim;\n     \n     p = (word *)(hbp->hb_body);\n-    word_no = HDR_WORDS;\n+    word_no = 0;\n     if (sz > MAXOBJSZ) {\n \tplim = p;\n     } else {\n@@ -673,7 +822,7 @@ word dummy;\n     /* go through all words in block */\n \twhile( p <= plim ) {\n \t    if( mark_bit_from_hdr(hhdr, word_no)\n-\t        && GC_has_debug_info((ptr_t)p)) {\n+\t        && GC_HAS_DEBUG_INFO((ptr_t)p)) {\n \t        ptr_t clobbered = GC_check_annotated_obj((oh *)p);\n \t        \n \t        if (clobbered != 0) {\n@@ -700,6 +849,8 @@ void GC_check_heap_proc()\n     GC_apply_to_all_blocks(GC_check_heap_block, (word)0);\n }\n \n+#endif /* !SHORT_DBG_HDRS */\n+\n struct closure {\n     GC_finalization_proc cl_fn;\n     GC_PTR cl_data;\n@@ -714,7 +865,12 @@ struct closure {\n # endif\n {\n     struct closure * result =\n-    \t\t(struct closure *) GC_malloc(sizeof (struct closure));\n+#\t\tifdef DBG_HDRS_ALL\n+    \t\t  (struct closure *) GC_debug_malloc(sizeof (struct closure),\n+\t\t\t\t\t\t     GC_EXTRAS);\n+#\t\telse\n+    \t\t  (struct closure *) GC_malloc(sizeof (struct closure));\n+#\t\tendif\n     \n     result -> cl_fn = fn;\n     result -> cl_data = data;\n@@ -807,3 +963,16 @@ struct closure {\n     GC_register_finalizer_ignore_self(base, GC_debug_invoke_finalizer,\n     \t\t\t  \t      GC_make_closure(fn,cd), ofn, ocd);\n }\n+\n+GC_PTR GC_debug_malloc_replacement(lb)\n+size_t lb;\n+{\n+    return GC_debug_malloc(lb, \"unknown\", 0);\n+}\n+\n+GC_PTR GC_debug_realloc_replacement(p, lb)\n+GC_PTR p;\n+size_t lb;\n+{\n+    return GC_debug_realloc(p, lb, \"unknown\", 0);\n+}"}, {"sha": "6abeda8a611a9479a0eadae6cf01f7888abd3867", "filename": "boehm-gc/dbg_mlc.h", "status": "removed", "additions": 0, "deletions": 102, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6951ca5dee8ed05749cdc697767910aebaedcc0/boehm-gc%2Fdbg_mlc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6951ca5dee8ed05749cdc697767910aebaedcc0/boehm-gc%2Fdbg_mlc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fdbg_mlc.h?ref=a6951ca5dee8ed05749cdc697767910aebaedcc0", "patch": "@@ -1,102 +0,0 @@\n-/* \n- * Copyright 1988, 1989 Hans-J. Boehm, Alan J. Demers\n- * Copyright (c) 1991-1995 by Xerox Corporation.  All rights reserved.\n- * Copyright (c) 1997 by Silicon Graphics.  All rights reserved.\n- * Copyright (c) 1999 by Hewlett-Packard Company.  All rights reserved.\n- *\n- * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n- * OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n- *\n- * Permission is hereby granted to use or copy this program\n- * for any purpose,  provided the above notices are retained on all copies.\n- * Permission to modify the code and to distribute modified code is granted,\n- * provided the above notices are retained, and a notice that the code was\n- * modified is included with the above copyright notice.\n- */\n-\n-/*\n- * This is mostly an internal header file.  Typical clients should\n- * not use it.  Clients that define their own object kinds with\n- * debugging allocators will probably want to include this, however.\n- * No attempt is made to keep the namespace clean.  This should not be\n- * included from header filrd that are frequently included by clients.\n- */\n-\n-#ifndef _DBG_MLC_H\n-\n-#define _DBG_MLC_H\n-\n-# define I_HIDE_POINTERS\n-# include \"gc_priv.h\"\n-# ifdef KEEP_BACK_PTRS\n-#   include \"backptr.h\"\n-# endif\n-\n-# define START_FLAG ((word)0xfedcedcb)\n-# define END_FLAG ((word)0xbcdecdef)\n-\t/* Stored both one past the end of user object, and one before\t*/\n-\t/* the end of the object as seen by the allocator.\t\t*/\n-\n-\n-/* Object header */\n-typedef struct {\n-#   ifdef KEEP_BACK_PTRS\n-\tptr_t oh_back_ptr;\n-#\tdefine MARKED_FOR_FINALIZATION (ptr_t)(-1)\n-\t    /* Object was marked because it is finalizable.\t*/\n-#\tdefine MARKED_FROM_REGISTER (ptr_t)(-2)\n-\t    /* Object was marked from a rgister.  Hence the\t*/\n-\t    /* source of the reference doesn't have an address.\t*/\n-#\tifdef ALIGN_DOUBLE\n-\t  word oh_dummy;\n-#\tendif\n-#   endif\n-    char * oh_string;\t\t/* object descriptor string\t*/\n-    word oh_int;\t\t/* object descriptor integers\t*/\n-#   ifdef NEED_CALLINFO\n-      struct callinfo oh_ci[NFRAMES];\n-#   endif\n-    word oh_sz;\t\t\t/* Original malloc arg.\t\t*/\n-    word oh_sf;\t\t\t/* start flag */\n-} oh;\n-/* The size of the above structure is assumed not to dealign things,\t*/\n-/* and to be a multiple of the word length.\t\t\t\t*/\n-\n-#define DEBUG_BYTES (sizeof (oh) + sizeof (word))\n-#define USR_PTR_FROM_BASE(p) ((ptr_t)(p) + sizeof(oh))\n-\n-/* There is no reason to ever add a byte at the end explicitly, since we */\n-/* already add a guard word.\t\t\t\t\t\t */\n-#undef ROUNDED_UP_WORDS\n-#define ROUNDED_UP_WORDS(n) BYTES_TO_WORDS((n) + WORDS_TO_BYTES(1) - 1)\n-\n-#ifdef SAVE_CALL_CHAIN\n-#   define ADD_CALL_CHAIN(base, ra) GC_save_callers(((oh *)(base)) -> oh_ci)\n-#   define PRINT_CALL_CHAIN(base) GC_print_callers(((oh *)(base)) -> oh_ci)\n-#else\n-# ifdef GC_ADD_CALLER\n-#   define ADD_CALL_CHAIN(base, ra) ((oh *)(base)) -> oh_ci[0].ci_pc = (ra)\n-#   define PRINT_CALL_CHAIN(base) GC_print_callers(((oh *)(base)) -> oh_ci)\n-# else\n-#   define ADD_CALL_CHAIN(base, ra)\n-#   define PRINT_CALL_CHAIN(base)\n-# endif\n-#endif\n-\n-# ifdef GC_ADD_CALLER\n-#   define OPT_RA ra,\n-# else\n-#   define OPT_RA\n-# endif\n-\n-\n-/* Check whether object with base pointer p has debugging info\t*/ \n-/* p is assumed to point to a legitimate object in our part\t*/\n-/* of the heap.\t\t\t\t\t\t\t*/\n-GC_bool GC_has_debug_info(/* p */);\n-\n-/* Store debugging info into p.  Return displaced pointer. */\n-/* Assumes we don't hold allocation lock.\t\t   */\n-ptr_t GC_store_debug_info(/* p, sz, string, integer */);\n-\n-#endif /* _DBG_MLC_H */"}, {"sha": "4f4ef51348d8d6bbec7cdddde7096dfd8ee1fb82", "filename": "boehm-gc/dyn_load.c", "status": "modified", "additions": 267, "deletions": 134, "changes": 401, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9110a741e35c54e46c00662ddc420575376c5947/boehm-gc%2Fdyn_load.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9110a741e35c54e46c00662ddc420575376c5947/boehm-gc%2Fdyn_load.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fdyn_load.c?ref=9110a741e35c54e46c00662ddc420575376c5947", "patch": "@@ -26,15 +26,15 @@\n  * None of this is safe with dlclose and incremental collection.\n  * But then not much of anything is safe in the presence of dlclose.\n  */\n-#ifndef MACOS\n+#if !defined(MACOS) && !defined(_WIN32_WCE)\n #  include <sys/types.h>\n #endif\n-#include \"gc_priv.h\"\n+#include \"private/gc_priv.h\"\n \n /* BTL: avoid circular redefinition of dlopen if SOLARIS_THREADS defined */\n # if (defined(LINUX_THREADS) || defined(SOLARIS_THREADS) \\\n       || defined(HPUX_THREADS) || defined(IRIX_THREADS)) && defined(dlopen) \\\n-     && !defined(USE_LD_WRAP)\n+     && !defined(GC_USE_LD_WRAP)\n     /* To support threads in Solaris, gc.h interposes on dlopen by       */\n     /* defining \"dlopen\" to be \"GC_dlopen\", which is implemented below.  */\n     /* However, both GC_FirstDLOpenedLinkMap() and GC_dlopen() use the   */\n@@ -46,11 +46,14 @@\n #   undef GC_must_restore_redefined_dlopen\n # endif\n \n-#if (defined(DYNAMIC_LOADING) || defined(MSWIN32)) && !defined(PCR)\n+#if (defined(DYNAMIC_LOADING) || defined(MSWIN32) || defined(MSWINCE)) \\\n+    && !defined(PCR)\n #if !defined(SUNOS4) && !defined(SUNOS5DL) && !defined(IRIX5) && \\\n-    !defined(MSWIN32) && !(defined(ALPHA) && defined(OSF1)) && \\\n+    !defined(MSWIN32) && !defined(MSWINCE) && \\\n+    !(defined(ALPHA) && defined(OSF1)) && \\\n     !defined(HPUX) && !(defined(LINUX) && defined(__ELF__)) && \\\n-    !defined(RS6000) && !defined(SCO_ELF)\n+    !defined(RS6000) && !defined(SCO_ELF) && \\\n+    !(defined(NETBSD) && defined(__ELF__))\n  --> We only know how to find data segments of dynamic libraries for the\n  --> above.  Additional SVR4 variants might not be too\n  --> hard to add.\n@@ -121,6 +124,11 @@ GC_FirstDLOpenedLinkMap()\n \n #endif /* SUNOS5DL ... */\n \n+/* BTL: added to fix circular dlopen definition if SOLARIS_THREADS defined */\n+# if defined(GC_must_restore_redefined_dlopen)\n+#   define dlopen GC_dlopen\n+# endif\n+\n #if defined(SUNOS4) && !defined(USE_PROC_FOR_LIBRARIES)\n \n #ifdef LINT\n@@ -161,69 +169,6 @@ static ptr_t GC_first_common()\n \n #endif  /* SUNOS4 ... */\n \n-# if defined(LINUX_THREADS) || defined(SOLARIS_THREADS) \\\n-     || defined(HPUX_THREADS) || defined(IRIX_THREADS)\n-  /* Make sure we're not in the middle of a collection, and make\t*/\n-  /* sure we don't start any.\tReturns previous value of GC_dont_gc.\t*/\n-  /* This is invoked prior to a dlopen call to avoid synchronization\t*/\n-  /* issues.  We can't just acquire the allocation lock, since startup \t*/\n-  /* code in dlopen may try to allocate.\t\t\t\t*/\n-  /* This solution risks heap growth in the presence of many dlopen\t*/\n-  /* calls in either a multithreaded environment, or if the library\t*/\n-  /* initialization code allocates substantial amounts of GC'ed memory.\t*/\n-  /* But I don't know of a better solution.\t\t\t\t*/\n-  /* This can still deadlock if the client explicitly starts a GC \t*/\n-  /* during the dlopen.  He shouldn't do that.\t\t\t\t*/\n-  static GC_bool disable_gc_for_dlopen()\n-  {\n-    GC_bool result;\n-    LOCK();\n-    result = GC_dont_gc;\n-    while (GC_incremental && GC_collection_in_progress()) {\n-\tGC_collect_a_little_inner(1000);\n-    }\n-    GC_dont_gc = TRUE;\n-    UNLOCK();\n-    return(result);\n-  }\n-\n-  /* Redefine dlopen to guarantee mutual exclusion with\t*/\n-  /* GC_register_dynamic_libraries.\t\t\t*/\n-  /* Should probably happen for other operating\tsystems, too. */\n-\n-#include <dlfcn.h>\n-\n-#ifdef USE_LD_WRAP\n-  void * __wrap_dlopen(const char *path, int mode)\n-#else\n-  void * GC_dlopen(path, mode)\n-  GC_CONST char * path;\n-  int mode;\n-#endif\n-{\n-    void * result;\n-    GC_bool dont_gc_save;\n-    \n-#   ifndef USE_PROC_FOR_LIBRARIES\n-      dont_gc_save = disable_gc_for_dlopen();\n-#   endif\n-#   ifdef USE_LD_WRAP\n-      result = __real_dlopen(path, mode);\n-#   else\n-      result = dlopen(path, mode);\n-#   endif\n-#   ifndef USE_PROC_FOR_LIBRARIES\n-      GC_dont_gc = dont_gc_save;\n-#   endif\n-    return(result);\n-}\n-# endif  /* SOLARIS_THREADS */\n-\n-/* BTL: added to fix circular dlopen definition if SOLARIS_THREADS defined */\n-# if defined(GC_must_restore_redefined_dlopen)\n-#   define dlopen GC_dlopen\n-# endif\n-\n # if defined(SUNOS4) || defined(SUNOS5DL)\n /* Add dynamic library data sections to the root set.\t\t*/\n # if !defined(PCR) && !defined(SOLARIS_THREADS) && defined(THREADS)\n@@ -297,14 +242,193 @@ void GC_register_dynamic_libraries()\n # endif /* !USE_PROC ... */\n # endif /* SUNOS */\n \n-#if defined(LINUX) && defined(__ELF__) || defined(SCO_ELF)\n+#if defined(LINUX) && defined(__ELF__) || defined(SCO_ELF) || \\\n+    (defined(NETBSD) && defined(__ELF__))\n+\n+\n+#ifdef USE_PROC_FOR_LIBRARIES\n+\n+#include <string.h>\n+\n+#include <sys/stat.h>\n+#include <fcntl.h>\n+#include <unistd.h>\n+\n+#define MAPS_BUF_SIZE (32*1024)\n+\n+extern ssize_t GC_repeat_read(int fd, char *buf, size_t count);\n+\t/* Repeatedly read until buffer is filled, or EOF is encountered */\n+\t/* Defined in os_dep.c.  \t\t\t\t\t */\n+\n+static char *parse_map_entry(char *buf_ptr, word *start, word *end,\n+                             char *prot_buf, unsigned int *maj_dev);\n+\n+void GC_register_dynamic_libraries()\n+{\n+    int f;\n+    int result;\n+    char prot_buf[5];\n+    int maps_size;\n+    char maps_temp[32768];\n+    char *maps_buf;\n+    char *buf_ptr;\n+    int count;\n+    word start, end;\n+    unsigned int maj_dev, min_dev;\n+    word least_ha, greatest_ha;\n+    unsigned i;\n+    word datastart = (word)(DATASTART);\n+\n+    /* Read /proc/self/maps\t*/\n+        /* Note that we may not allocate, and thus can't use stdio.\t*/\n+        f = open(\"/proc/self/maps\", O_RDONLY);\n+        if (-1 == f) ABORT(\"Couldn't open /proc/self/maps\");\n+\t/* stat() doesn't work for /proc/self/maps, so we have to\n+\t   read it to find out how large it is... */\n+\tmaps_size = 0;\n+\tdo {\n+\t    result = GC_repeat_read(f, maps_temp, sizeof(maps_temp));\n+\t    if (result <= 0) ABORT(\"Couldn't read /proc/self/maps\");\n+\t    maps_size += result;\n+\t} while (result == sizeof(maps_temp));\n+\n+\tif (maps_size > sizeof(maps_temp)) {\n+\t    /* If larger than our buffer, close and re-read it. */\n+\t    close(f);\n+\t    f = open(\"/proc/self/maps\", O_RDONLY);\n+\t    if (-1 == f) ABORT(\"Couldn't open /proc/self/maps\");\n+\t    maps_buf = alloca(maps_size);\n+\t    if (NULL == maps_buf) ABORT(\"/proc/self/maps alloca failed\");\n+\t    result = GC_repeat_read(f, maps_buf, maps_size);\n+\t    if (result <= 0) ABORT(\"Couldn't read /proc/self/maps\");\n+\t} else {\n+\t    /* Otherwise use the fixed size buffer */\n+\t    maps_buf = maps_temp;\n+\t}\n+\n+\tclose(f);\n+        maps_buf[result] = '\\0';\n+        buf_ptr = maps_buf;\n+    /* Compute heap bounds. Should be done by add_to_heap?\t*/\n+\tleast_ha = (word)(-1);\n+\tgreatest_ha = 0;\n+\tfor (i = 0; i < GC_n_heap_sects; ++i) {\n+\t    word sect_start = (word)GC_heap_sects[i].hs_start;\n+\t    word sect_end = sect_start + GC_heap_sects[i].hs_bytes;\n+\t    if (sect_start < least_ha) least_ha = sect_start;\n+\t    if (sect_end > greatest_ha) greatest_ha = sect_end;\n+        }\n+    \tif (greatest_ha < (word)GC_scratch_last_end_ptr)\n+\t    greatest_ha = (word)GC_scratch_last_end_ptr; \n+    for (;;) {\n+\n+        buf_ptr = parse_map_entry(buf_ptr, &start, &end, prot_buf, &maj_dev);\n+\tif (buf_ptr == NULL) return;\n+\n+\tif (prot_buf[1] == 'w') {\n+\t    /* This is a writable mapping.  Add it to\t\t*/\n+\t    /* the root set unless it is already otherwise\t*/\n+\t    /* accounted for.\t\t\t\t\t*/\n+\t    if (start <= (word)GC_stackbottom && end >= (word)GC_stackbottom) {\n+\t\t/* Stack mapping; discard\t*/\n+\t\tcontinue;\n+\t    }\n+\t    if (start <= datastart && end > datastart && maj_dev != 0) {\n+\t\t/* Main data segment; discard\t*/\n+\t\tcontinue;\n+\t    }\n+#\t    ifdef THREADS\n+\t      if (GC_segment_is_thread_stack(start, end)) continue;\n+#\t    endif\n+\t    /* The rest of this assumes that there is no mapping\t*/\n+\t    /* spanning the beginning of the data segment, or extending\t*/\n+\t    /* beyond the entire heap at both ends.  \t\t\t*/\n+\t    /* Empirically these assumptions hold.\t\t\t*/\n+\t    \n+\t    if (start < (word)DATAEND && end > (word)DATAEND) {\n+\t\t/* Rld may use space at the end of the main data \t*/\n+\t\t/* segment.  Thus we add that in.\t\t\t*/\n+\t\tstart = (word)DATAEND;\n+\t    }\n+\t    if (start < least_ha && end > least_ha) {\n+\t\tend = least_ha;\n+\t    }\n+\t    if (start < greatest_ha && end > greatest_ha) {\n+\t\tstart = greatest_ha;\n+\t    }\n+\t    if (start >= least_ha && end <= greatest_ha) continue;\n+\t    GC_add_roots_inner((char *)start, (char *)end, TRUE);\n+\t}\n+     }\n+}\n+\n+//\n+//  parse_map_entry parses an entry from /proc/self/maps so we can\n+//  locate all writable data segments that belong to shared libraries.\n+//  The format of one of these entries and the fields we care about\n+//  is as follows:\n+//  XXXXXXXX-XXXXXXXX r-xp 00000000 30:05 260537     name of mapping...\\n\n+//  ^^^^^^^^ ^^^^^^^^ ^^^^          ^^\n+//  start    end      prot          maj_dev\n+//  0        9        18            32\n+//\n+//  The parser is called with a pointer to the entry and the return value\n+//  is either NULL or is advanced to the next entry(the byte after the\n+//  trailing '\\n'.)\n+//\n+#define OFFSET_MAP_START   0\n+#define OFFSET_MAP_END     9\n+#define OFFSET_MAP_PROT   18\n+#define OFFSET_MAP_MAJDEV 32\n+\n+static char *parse_map_entry(char *buf_ptr, word *start, word *end,\n+                             char *prot_buf, unsigned int *maj_dev)\n+{\n+    int i;\n+    unsigned int val;\n+    char *tok;\n+\n+    if (buf_ptr == NULL || *buf_ptr == '\\0') {\n+        return NULL;\n+    }\n+\n+    memcpy(prot_buf, buf_ptr+OFFSET_MAP_PROT, 4); // do the protections first\n+    prot_buf[4] = '\\0';\n+\n+    if (prot_buf[1] == 'w') { // we can skip all of this if it's not writable\n+\n+        tok = buf_ptr;\n+        buf_ptr[OFFSET_MAP_START+8] = '\\0';\n+        *start = strtoul(tok, NULL, 16);\n+\n+        tok = buf_ptr+OFFSET_MAP_END;\n+        buf_ptr[OFFSET_MAP_END+8] = '\\0';\n+        *end = strtoul(tok, NULL, 16);\n+\n+        buf_ptr += OFFSET_MAP_MAJDEV;\n+        tok = buf_ptr;\n+        while (*buf_ptr != ':') buf_ptr++;\n+        *buf_ptr++ = '\\0';\n+        *maj_dev = strtoul(tok, NULL, 16);\n+    }\n+\n+    while (*buf_ptr && *buf_ptr++ != '\\n');\n+\n+    return buf_ptr;\n+}\n+\n+#else /* !USE_PROC_FOR_LIBRARIES */\n \n /* Dynamic loading code for Linux running ELF. Somewhat tested on\n  * Linux/x86, untested but hopefully should work on Linux/Alpha. \n  * This code was derived from the Solaris/ELF support. Thanks to\n  * whatever kind soul wrote that.  - Patrick Bridges */\n \n-#include <elf.h>\n+#if defined(NETBSD)\n+#  include <sys/exec_elf.h>\n+#else\n+#  include <elf.h>\n+#endif\n #include <link.h>\n \n /* Newer versions of Linux/Alpha and Linux/x86 define this macro.  We\n@@ -379,9 +503,11 @@ void GC_register_dynamic_libraries()\n     }\n }\n \n-#endif\n+#endif /* !USE_PROC_FOR_LIBRARIES */\n \n-#if defined(IRIX5) || defined(USE_PROC_FOR_LIBRARIES)\n+#endif /* LINUX */\n+\n+#if defined(IRIX5) || (defined(USE_PROC_FOR_LIBRARIES) && !defined(LINUX))\n \n #include <sys/procfs.h>\n #include <sys/stat.h>\n@@ -393,10 +519,6 @@ extern void * GC_roots_present();\n \t/* The type is a lie, since the real type doesn't make sense here, */\n \t/* and we only test for NULL.\t\t\t\t\t   */\n \n-#ifndef GC_scratch_last_end_ptr\n-extern ptr_t GC_scratch_last_end_ptr; /* End of GC_scratch_alloc arena\t*/\n-#endif\n-\n /* We use /proc to track down all parts of the address space that are\t*/\n /* mapped by the process, and throw out regions we know we shouldn't\t*/\n /* worry about.  This may also work under other SVR4 variants.\t\t*/\n@@ -504,7 +626,7 @@ void GC_register_dynamic_libraries()\n \n # endif /* USE_PROC || IRIX5 */\n \n-# ifdef MSWIN32\n+# if defined(MSWIN32) || defined(MSWINCE)\n \n # define WIN32_LEAN_AND_MEAN\n # define NOSERVICE\n@@ -513,86 +635,97 @@ void GC_register_dynamic_libraries()\n \n   /* We traverse the entire address space and register all segments \t*/\n   /* that could possibly have been written to.\t\t\t\t*/\n-  DWORD GC_allocation_granularity;\n   \n   extern GC_bool GC_is_heap_base (ptr_t p);\n \n # ifdef WIN32_THREADS\n     extern void GC_get_next_stack(char *start, char **lo, char **hi);\n-# endif\n-  \n-  void GC_cond_add_roots(char *base, char * limit)\n-  {\n-    char dummy;\n-    char * stack_top\n-           = (char *) ((word)(&dummy) & ~(GC_allocation_granularity-1));\n-    if (base == limit) return;\n-#   ifdef WIN32_THREADS\n+    void GC_cond_add_roots(char *base, char * limit)\n     {\n-        char * curr_base = base;\n-\tchar * next_stack_lo;\n-\tchar * next_stack_hi;\n-\t\n-\tfor(;;) {\n-\t    GC_get_next_stack(curr_base, &next_stack_lo, &next_stack_hi);\n-\t    if (next_stack_lo >= limit) break;\n-\t    GC_add_roots_inner(curr_base, next_stack_lo, TRUE);\n-\t    curr_base = next_stack_hi;\n-\t}\n-\tif (curr_base < limit) GC_add_roots_inner(curr_base, limit, TRUE);\n+      char * curr_base = base;\n+      char * next_stack_lo;\n+      char * next_stack_hi;\n+   \n+      if (base == limit) return;\n+      for(;;) {\n+\t  GC_get_next_stack(curr_base, &next_stack_lo, &next_stack_hi);\n+\t  if (next_stack_lo >= limit) break;\n+\t  GC_add_roots_inner(curr_base, next_stack_lo, TRUE);\n+\t  curr_base = next_stack_hi;\n+      }\n+      if (curr_base < limit) GC_add_roots_inner(curr_base, limit, TRUE);\n     }\n-#   else\n-        if (limit > stack_top && base < GC_stackbottom) {\n-    \t    /* Part of the stack; ignore it. */\n-    \t    return;\n-        }\n-        GC_add_roots_inner(base, limit, TRUE);\n-#   endif\n-  }\n-  \n+# else\n+    void GC_cond_add_roots(char *base, char * limit)\n+    {\n+      char dummy;\n+      char * stack_top\n+\t = (char *) ((word)(&dummy) & ~(GC_sysinfo.dwAllocationGranularity-1));\n+      if (base == limit) return;\n+      if (limit > stack_top && base < GC_stackbottom) {\n+    \t  /* Part of the stack; ignore it. */\n+    \t  return;\n+      }\n+      GC_add_roots_inner(base, limit, TRUE);\n+    }\n+# endif\n+\n+# ifndef MSWINCE\n   extern GC_bool GC_win32s;\n+# endif\n   \n   void GC_register_dynamic_libraries()\n   {\n     MEMORY_BASIC_INFORMATION buf;\n-    SYSTEM_INFO sysinfo;\n     DWORD result;\n     DWORD protect;\n     LPVOID p;\n     char * base;\n     char * limit, * new_limit;\n-    \n-    if (GC_win32s) return;\n-    GetSystemInfo(&sysinfo);\n-    base = limit = p = sysinfo.lpMinimumApplicationAddress;\n-    GC_allocation_granularity = sysinfo.dwAllocationGranularity;\n-    while (p < sysinfo.lpMaximumApplicationAddress) {\n+\n+#   ifdef MSWIN32\n+      if (GC_win32s) return;\n+#   endif\n+    base = limit = p = GC_sysinfo.lpMinimumApplicationAddress;\n+#   if defined(MSWINCE) && !defined(_WIN32_WCE_EMULATION)\n+    /* Only the first 32 MB of address space belongs to the current process */\n+    while (p < (LPVOID)0x02000000) {\n         result = VirtualQuery(p, &buf, sizeof(buf));\n-        if (result != sizeof(buf)) {\n-            ABORT(\"Weird VirtualQuery result\");\n-        }\n-        new_limit = (char *)p + buf.RegionSize;\n-        protect = buf.Protect;\n-        if (buf.State == MEM_COMMIT\n-            && (protect == PAGE_EXECUTE_READWRITE\n-                || protect == PAGE_READWRITE)\n-            && !GC_is_heap_base(buf.AllocationBase)) {\n-            if ((char *)p == limit) {\n-                limit = new_limit;\n-            } else {\n-                GC_cond_add_roots(base, limit);\n-                base = p;\n-                limit = new_limit;\n-            }\n-        }\n+\tif (result == 0) {\n+\t    /* Page is free; advance to the next possible allocation base */\n+\t    new_limit = (char *)\n+\t\t(((DWORD) p + GC_sysinfo.dwAllocationGranularity)\n+\t\t & ~(GC_sysinfo.dwAllocationGranularity-1));\n+\t} else\n+#   else\n+    while (p < GC_sysinfo.lpMaximumApplicationAddress) {\n+        result = VirtualQuery(p, &buf, sizeof(buf));\n+#   endif\n+\t{\n+\t    if (result != sizeof(buf)) {\n+\t\tABORT(\"Weird VirtualQuery result\");\n+\t    }\n+\t    new_limit = (char *)p + buf.RegionSize;\n+\t    protect = buf.Protect;\n+\t    if (buf.State == MEM_COMMIT\n+\t\t&& (protect == PAGE_EXECUTE_READWRITE\n+\t\t    || protect == PAGE_READWRITE)\n+\t\t&& !GC_is_heap_base(buf.AllocationBase)) {\n+\t\tif ((char *)p != limit) {\n+\t\t    GC_cond_add_roots(base, limit);\n+\t\t    base = p;\n+\t\t}\n+\t\tlimit = new_limit;\n+\t    }\n+\t}\n         if (p > (LPVOID)new_limit /* overflow */) break;\n         p = (LPVOID)new_limit;\n     }\n     GC_cond_add_roots(base, limit);\n   }\n \n-#endif /* MSWIN32 */\n-\n+#endif /* MSWIN32 || MSWINCE */\n+  \n #if defined(ALPHA) && defined(OSF1)\n \n #include <loader.h>"}, {"sha": "4c41eb54bf9cb99206600ac43c045a44de66907b", "filename": "boehm-gc/finalize.c", "status": "modified", "additions": 74, "deletions": 38, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9110a741e35c54e46c00662ddc420575376c5947/boehm-gc%2Ffinalize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9110a741e35c54e46c00662ddc420575376c5947/boehm-gc%2Ffinalize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Ffinalize.c?ref=9110a741e35c54e46c00662ddc420575376c5947", "patch": "@@ -14,8 +14,7 @@\n  */\n /* Boehm, February 1, 1996 1:19 pm PST */\n # define I_HIDE_POINTERS\n-# include \"gc_priv.h\"\n-# include \"gc_mark.h\"\n+# include \"private/gc_pmark.h\"\n \n # ifdef FINALIZE_ON_DEMAND\n     int GC_finalize_on_demand = 1;\n@@ -86,13 +85,13 @@ static signed_word log_fo_table_size = -1;\n \n word GC_fo_entries = 0;\n \n-# ifdef SRC_M3\n-void GC_push_finalizer_structures()\n+void GC_push_finalizer_structures GC_PROTO((void))\n {\n     GC_push_all((ptr_t)(&dl_head), (ptr_t)(&dl_head) + sizeof(word));\n     GC_push_all((ptr_t)(&fo_head), (ptr_t)(&fo_head) + sizeof(word));\n+    GC_push_all((ptr_t)(&GC_finalize_now),\n+\t\t(ptr_t)(&GC_finalize_now) + sizeof(word));\n }\n-# endif\n \n /* Double the size of a hash table. *size_ptr is the log of its current\t*/\n /* size.  May be a noop.\t\t\t\t\t\t*/\n@@ -110,7 +109,7 @@ signed_word * log_size_ptr;\n     word old_size = ((log_old_size == -1)? 0: (1 << log_old_size));\n     register word new_size = 1 << log_new_size;\n     struct hash_chain_entry **new_table = (struct hash_chain_entry **)\n-    \tGC_generic_malloc_inner_ignore_off_page(\n+    \tGC_INTERNAL_MALLOC_IGNORE_OFF_PAGE(\n     \t\t(size_t)new_size * sizeof(struct hash_chain_entry *), NORMAL);\n     \n     if (new_table == 0) {\n@@ -179,9 +178,11 @@ signed_word * log_size_ptr;\n #\tendif\n     \tGC_grow_table((struct hash_chain_entry ***)(&dl_head),\n     \t\t      &log_dl_table_size);\n-#\tifdef PRINTSTATS\n+#\tifdef CONDPRINT\n+\t  if (GC_print_stats) {\n \t    GC_printf1(\"Grew dl table to %lu entries\\n\",\n \t    \t\t(unsigned long)(1 << log_dl_table_size));\n+\t  }\n #\tendif\n #\tifndef THREADS\n \t    ENABLE_SIGNALS();\n@@ -199,13 +200,8 @@ signed_word * log_size_ptr;\n             return(1);\n         }\n     }\n-#   ifdef THREADS\n-      new_dl = (struct disappearing_link *)\n-    \tGC_generic_malloc_inner(sizeof(struct disappearing_link),NORMAL);\n-#   else\n-      new_dl = (struct disappearing_link *)\n-\tGC_malloc(sizeof(struct disappearing_link));\n-#   endif\n+    new_dl = (struct disappearing_link *)\n+    \tGC_INTERNAL_MALLOC(sizeof(struct disappearing_link),NORMAL);\n     if (new_dl != 0) {\n         new_dl -> dl_hidden_obj = HIDE_POINTER(obj);\n         new_dl -> dl_hidden_link = HIDE_POINTER(link);\n@@ -248,7 +244,11 @@ signed_word * log_size_ptr;\n             GC_dl_entries--;\n             UNLOCK();\n     \t    ENABLE_SIGNALS();\n-            GC_free((GC_PTR)curr_dl);\n+#\t    ifdef DBG_HDRS_ALL\n+\t      dl_next(curr_dl) = 0;\n+#\t    else\n+              GC_free((GC_PTR)curr_dl);\n+#\t    endif\n             return(1);\n         }\n         prev_dl = curr_dl;\n@@ -283,7 +283,7 @@ ptr_t p;\n     ptr_t scan_limit;\n     ptr_t target_limit = p + WORDS_TO_BYTES(hhdr -> hb_sz) - 1;\n     \n-    if ((descr & DS_TAGS) == DS_LENGTH) {\n+    if ((descr & GC_DS_TAGS) == GC_DS_LENGTH) {\n        scan_limit = p + descr - sizeof(word);\n     } else {\n        scan_limit = target_limit + 1 - sizeof(word);\n@@ -338,9 +338,11 @@ finalization_mark_proc * mp;\n #\tendif\n     \tGC_grow_table((struct hash_chain_entry ***)(&fo_head),\n     \t\t      &log_fo_table_size);\n-#\tifdef PRINTSTATS\n+#\tifdef CONDPRINT\n+\t  if (GC_print_stats) {\n \t    GC_printf1(\"Grew fo table to %lu entries\\n\",\n \t    \t\t(unsigned long)(1 << log_fo_table_size));\n+\t  }\n #\tendif\n #\tifndef THREADS\n \t    ENABLE_SIGNALS();\n@@ -370,7 +372,7 @@ finalization_mark_proc * mp;\n                   /* May not happen if we get a signal.  But a high\t*/\n                   /* estimate will only make the table larger than\t*/\n                   /* necessary.\t\t\t\t\t\t*/\n-#\t\tifndef THREADS\n+#\t\tif !defined(THREADS) && !defined(DBG_HDRS_ALL)\n                   GC_free((GC_PTR)curr_fo);\n #\t\tendif\n             } else {\n@@ -406,23 +408,14 @@ finalization_mark_proc * mp;\n     GET_HDR(base, hhdr);\n     if (0 == hhdr) {\n       /* We won't collect it, hence finalizer wouldn't be run. */\n-      /* This is changed for gcj, but it will be in version 6.0 of the\t*/\n-      /* standard collector distribution.  It costs virtually nothing\t*/\n-      /* here, but it's expensive to check in the hash synchronization\t*/\n-      /* code, where it matters.\t\t-HB\t\t\t*/\n #     ifdef THREADS\n           UNLOCK();\n     \t  ENABLE_SIGNALS();\n #     endif\n       return;\n     }\n-#   ifdef THREADS\n-      new_fo = (struct finalizable_object *)\n-    \tGC_generic_malloc_inner(sizeof(struct finalizable_object),NORMAL);\n-#   else\n-      new_fo = (struct finalizable_object *)\n-\tGC_malloc(sizeof(struct finalizable_object));\n-#   endif\n+    new_fo = (struct finalizable_object *)\n+    \tGC_INTERNAL_MALLOC(sizeof(struct finalizable_object),NORMAL);\n     if (new_fo != 0) {\n         new_fo -> fo_hidden_base = (word)HIDE_POINTER(base);\n \tnew_fo -> fo_fn = fn;\n@@ -492,6 +485,34 @@ finalization_mark_proc * mp;\n     \t\t\t\tocd, GC_null_finalize_mark_proc);\n }\n \n+#ifndef NO_DEBUGGING\n+void GC_dump_finalization()\n+{\n+    struct disappearing_link * curr_dl;\n+    struct finalizable_object * curr_fo;\n+    ptr_t real_ptr, real_link;\n+    int dl_size = (log_dl_table_size == -1 ) ? 0 : (1 << log_dl_table_size);\n+    int fo_size = (log_fo_table_size == -1 ) ? 0 : (1 << log_fo_table_size);\n+    int i;\n+\n+    GC_printf0(\"Disappearing links:\\n\");\n+    for (i = 0; i < dl_size; i++) {\n+      for (curr_dl = dl_head[i]; curr_dl != 0; curr_dl = dl_next(curr_dl)) {\n+        real_ptr = (ptr_t)REVEAL_POINTER(curr_dl -> dl_hidden_obj);\n+        real_link = (ptr_t)REVEAL_POINTER(curr_dl -> dl_hidden_link);\n+        GC_printf2(\"Object: 0x%lx, Link:0x%lx\\n\", real_ptr, real_link);\n+      }\n+    }\n+    GC_printf0(\"Finalizers:\\n\");\n+    for (i = 0; i < fo_size; i++) {\n+      for (curr_fo = fo_head[i]; curr_fo != 0; curr_fo = fo_next(curr_fo)) {\n+        real_ptr = (ptr_t)REVEAL_POINTER(curr_fo -> fo_hidden_base);\n+        GC_printf1(\"Finalizable object: 0x%lx\\n\", real_ptr);\n+      }\n+    }\n+}\n+#endif\n+\n /* Called with world stopped.  Cause disappearing links to disappear,\t*/\n /* and invoke finalizers.\t\t\t\t\t\t*/\n void GC_finalize()\n@@ -529,9 +550,7 @@ void GC_finalize()\n     }\n   /* Mark all objects reachable via chains of 1 or more pointers\t*/\n   /* from finalizable objects.\t\t\t\t\t\t*/\n-#   ifdef PRINTSTATS\n-        if (GC_mark_state != MS_NONE) ABORT(\"Bad mark state\");\n-#   endif\n+    GC_ASSERT(GC_mark_state == MS_NONE);\n     for (i = 0; i < fo_size; i++) {\n       for (curr_fo = fo_head[i]; curr_fo != 0; curr_fo = fo_next(curr_fo)) {\n         real_ptr = (ptr_t)REVEAL_POINTER(curr_fo -> fo_hidden_base);\n@@ -574,11 +593,7 @@ void GC_finalize()\n               GC_words_finalized +=\n                  \tALIGNED_WORDS(curr_fo -> fo_object_size)\n               \t\t+ ALIGNED_WORDS(sizeof(struct finalizable_object));\n-#\t    ifdef PRINTSTATS\n-              if (!GC_is_marked((ptr_t)curr_fo)) {\n-                ABORT(\"GC_finalize: found accessible unmarked object\\n\");\n-              }\n-#\t    endif\n+\t    GC_ASSERT(GC_is_marked((ptr_t)curr_fo));\n             curr_fo = next_fo;\n         } else {\n             prev_fo = curr_fo;\n@@ -753,6 +768,25 @@ int GC_invoke_finalizers()\n     return count;\n }\n \n+void (* GC_finalizer_notifier)() = (void (*) GC_PROTO((void)))0;\n+\n+static GC_word last_finalizer_notification = 0;\n+\n+void GC_notify_or_invoke_finalizers GC_PROTO((void))\n+{\n+    if (GC_finalize_now == 0) return;\n+    if (!GC_finalize_on_demand) {\n+\t(void) GC_invoke_finalizers();\n+\tGC_ASSERT(GC_finalize_now == 0);\n+\treturn;\n+    }\n+    if (GC_finalizer_notifier != (void (*) GC_PROTO((void)))0\n+\t&& last_finalizer_notification != GC_gc_no) {\n+\tlast_finalizer_notification = GC_gc_no;\n+\tGC_finalizer_notifier();\n+    }\n+}\n+\n # ifdef __STDC__\n     GC_PTR GC_call_with_alloc_lock(GC_fn_type fn,\n     \t\t\t\t\t GC_PTR client_data)\n@@ -772,7 +806,9 @@ int GC_invoke_finalizers()\n #   endif\n     result = (*fn)(client_data);\n #   ifdef THREADS\n-      UNSET_LOCK_HOLDER();\n+#     ifndef GC_ASSERTIONS\n+        UNSET_LOCK_HOLDER();\n+#     endif /* o.w. UNLOCK() does it implicitly */\n       UNLOCK();\n       ENABLE_SIGNALS();\n #   endif"}, {"sha": "d7cd8996085bff60fa60408aff0662f7e054b821", "filename": "boehm-gc/gc.h", "status": "removed", "additions": 0, "deletions": 804, "changes": 804, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6951ca5dee8ed05749cdc697767910aebaedcc0/boehm-gc%2Fgc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6951ca5dee8ed05749cdc697767910aebaedcc0/boehm-gc%2Fgc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fgc.h?ref=a6951ca5dee8ed05749cdc697767910aebaedcc0", "patch": "@@ -1,804 +0,0 @@\n-/* \n- * Copyright 1988, 1989 Hans-J. Boehm, Alan J. Demers\n- * Copyright (c) 1991-1995 by Xerox Corporation.  All rights reserved.\n- * Copyright 1996-1999 by Silicon Graphics.  All rights reserved.\n- * Copyright 1999 by Hewlett-Packard Company.  All rights reserved.\n- *\n- * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n- * OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n- *\n- * Permission is hereby granted to use or copy this program\n- * for any purpose,  provided the above notices are retained on all copies.\n- * Permission to modify the code and to distribute modified code is granted,\n- * provided the above notices are retained, and a notice that the code was\n- * modified is included with the above copyright notice.\n- */\n-\n-/*\n- * Note that this defines a large number of tuning hooks, which can\n- * safely be ignored in nearly all cases.  For normal use it suffices\n- * to call only GC_MALLOC and perhaps GC_REALLOC.\n- * For better performance, also look at GC_MALLOC_ATOMIC, and\n- * GC_enable_incremental.  If you need an action to be performed\n- * immediately before an object is collected, look at GC_register_finalizer.\n- * If you are using Solaris threads, look at the end of this file.\n- * Everything else is best ignored unless you encounter performance\n- * problems.\n- */\n- \n-#ifndef _GC_H\n-\n-# define _GC_H\n-# define __GC\n-# include <stddef.h>\n-\n-#if defined(__CYGWIN32__) && defined(GC_USE_DLL)\n-#include \"libgc_globals.h\"\n-#endif\n-\n-#if defined(__MINGW32__) && defined(WIN32_THREADS)\n-# ifdef GC_BUILD\n-#   define GC_API __declspec(dllexport)\n-# else\n-#   define GC_API __declspec(dllimport)\n-# endif\n-#endif\n-\n-#if defined(_MSC_VER) && defined(_DLL)\n-# ifdef GC_BUILD\n-#   define GC_API __declspec(dllexport)\n-# else\n-#   define GC_API __declspec(dllimport)\n-# endif\n-#endif\n-\n-#if defined(__WATCOMC__) && defined(GC_DLL)\n-# ifdef GC_BUILD\n-#   define GC_API extern __declspec(dllexport)\n-# else\n-#   define GC_API extern __declspec(dllimport)\n-# endif\n-#endif\n-\n-#ifndef GC_API\n-#define GC_API extern\n-#endif\n-\n-# if defined(__STDC__) || defined(__cplusplus)\n-#   define GC_PROTO(args) args\n-    typedef void * GC_PTR;\n-#   define GC_CONST const\n-# else\n-#   define GC_PROTO(args) ()\n-    typedef char * GC_PTR;\n-#   define GC_CONST\n-#  endif\n-\n-# ifdef __cplusplus\n-    extern \"C\" {\n-# endif\n-\n-\n-/* Define word and signed_word to be unsigned and signed types of the \t*/\n-/* size as char * or void *.  There seems to be no way to do this\t*/\n-/* even semi-portably.  The following is probably no better/worse \t*/\n-/* than almost anything else.\t\t\t\t\t\t*/\n-/* The ANSI standard suggests that size_t and ptr_diff_t might be \t*/\n-/* better choices.  But those appear to have incorrect definitions\t*/\n-/* on may systems.  Notably \"typedef int size_t\" seems to be both\t*/\n-/* frequent and WRONG.\t\t\t\t\t\t\t*/\n-typedef unsigned long GC_word;\n-typedef long GC_signed_word;\n-\n-/* Public read-only variables */\n-\n-GC_API GC_word GC_gc_no;/* Counter incremented per collection.  \t*/\n-\t\t\t/* Includes empty GCs at startup.\t\t*/\n-\t\t\t\n-\n-/* Public R/W variables */\n-\n-GC_API GC_PTR (*GC_oom_fn) GC_PROTO((size_t bytes_requested));\n-\t\t\t/* When there is insufficient memory to satisfy */\n-\t\t\t/* an allocation request, we return\t\t*/\n-\t\t\t/* (*GC_oom_fn)().  By default this just\t*/\n-\t\t\t/* returns 0.\t\t\t\t\t*/\n-\t\t\t/* If it returns, it must return 0 or a valid\t*/\n-\t\t\t/* pointer to a previously allocated heap \t*/\n-\t\t\t/* object.\t\t\t\t\t*/\n-\n-GC_API int GC_find_leak;\n-\t\t\t/* Do not actually garbage collect, but simply\t*/\n-\t\t\t/* report inaccessible memory that was not\t*/\n-\t\t\t/* deallocated with GC_free.  Initial value\t*/\n-\t\t\t/* is determined by FIND_LEAK macro.\t\t*/\n-\n-GC_API int GC_quiet;\t/* Disable statistics output.  Only matters if\t*/\n-\t\t\t/* collector has been compiled with statistics\t*/\n-\t\t\t/* enabled.  This involves a performance cost,\t*/\n-\t\t\t/* and is thus not the default.\t\t\t*/\n-\n-GC_API int GC_finalize_on_demand;\n-\t\t\t/* If nonzero, finalizers will only be run in \t*/\n-\t\t\t/* response to an eplit GC_invoke_finalizers\t*/\n-\t\t\t/* call.  The default is determined by whether\t*/\n-\t\t\t/* the FINALIZE_ON_DEMAND macro is defined\t*/\n-\t\t\t/* when the collector is built.\t\t\t*/\n-\n-GC_API int GC_java_finalization;\n-\t\t\t/* Mark objects reachable from finalizable \t*/\n-\t\t\t/* objects in a separate postpass.  This makes\t*/\n-\t\t\t/* it a bit safer to use non-topologically-\t*/\n-\t\t\t/* ordered finalization.  Default value is\t*/\n-\t\t\t/* determined by JAVA_FINALIZATION macro.\t*/\n-\n-GC_API int GC_dont_gc;\t/* Dont collect unless explicitly requested, e.g. */\n-\t\t\t/* because it's not safe.\t\t\t  */\n-\n-GC_API int GC_dont_expand;\n-\t\t\t/* Dont expand heap unless explicitly requested */\n-\t\t\t/* or forced to.\t\t\t\t*/\n-\n-GC_API int GC_use_entire_heap;\n-\t\t/* Causes the nonincremental collector to use the\t*/\n-\t\t/* entire heap before collecting.  This was the only \t*/\n-\t\t/* option for GC versions < 5.0.  This sometimes\t*/\n-\t\t/* results in more large block fragmentation, since\t*/\n-\t\t/* very larg blocks will tend to get broken up\t\t*/\n-\t\t/* during each GC cycle.  It is likely to result in a\t*/\n-\t\t/* larger working set, but lower collection\t\t*/\n-\t\t/* frequencies, and hence fewer instructions executed\t*/\n-\t\t/* in the collector.\t\t\t\t\t*/\n-\n-GC_API int GC_full_freq;    /* Number of partial collections between\t*/\n-\t\t\t    /* full collections.  Matters only if\t*/\n-\t\t\t    /* GC_incremental is set.\t\t\t*/\n-\t\t\t    /* Full collections are also triggered if\t*/\n-\t\t\t    /* the collector detects a substantial\t*/\n-\t\t\t    /* increase in the number of in-use heap\t*/\n-\t\t\t    /* blocks.  Values in the tens are now\t*/\n-\t\t\t    /* perfectly reasonable, unlike for\t\t*/\n-\t\t\t    /* earlier GC versions.\t\t\t*/\n-\t\t\t\n-GC_API GC_word GC_non_gc_bytes;\n-\t\t\t/* Bytes not considered candidates for collection. */\n-\t\t\t/* Used only to control scheduling of collections. */\n-\n-GC_API GC_word GC_free_space_divisor;\n-\t\t\t/* We try to make sure that we allocate at \t*/\n-\t\t\t/* least N/GC_free_space_divisor bytes between\t*/\n-\t\t\t/* collections, where N is the heap size plus\t*/\n-\t\t\t/* a rough estimate of the root set size.\t*/\n-\t\t\t/* Initially, GC_free_space_divisor = 4.\t*/\n-\t\t\t/* Increasing its value will use less space\t*/\n-\t\t\t/* but more collection time.  Decreasing it\t*/\n-\t\t\t/* will appreciably decrease collection time\t*/\n-\t\t\t/* at the expense of space.\t\t\t*/\n-\t\t\t/* GC_free_space_divisor = 1 will effectively\t*/\n-\t\t\t/* disable collections.\t\t\t\t*/\n-\n-GC_API GC_word GC_max_retries;\n-\t\t\t/* The maximum number of GCs attempted before\t*/\n-\t\t\t/* reporting out of memory after heap\t\t*/\n-\t\t\t/* expansion fails.  Initially 0.\t\t*/\n-\t\t\t\n-\n-GC_API char *GC_stackbottom;\t/* Cool end of user stack.\t\t*/\n-\t\t\t\t/* May be set in the client prior to\t*/\n-\t\t\t\t/* calling any GC_ routines.  This\t*/\n-\t\t\t\t/* avoids some overhead, and \t\t*/\n-\t\t\t\t/* potentially some signals that can \t*/\n-\t\t\t\t/* confuse debuggers.  Otherwise the\t*/\n-\t\t\t\t/* collector attempts to set it \t*/\n-\t\t\t\t/* automatically.\t\t\t*/\n-\t\t\t\t/* For multithreaded code, this is the\t*/\n-\t\t\t\t/* cold end of the stack for the\t*/\n-\t\t\t\t/* primordial thread.\t\t\t*/\n-\t\t\t\t\n-/* Public procedures */\n-/*\n- * general purpose allocation routines, with roughly malloc calling conv.\n- * The atomic versions promise that no relevant pointers are contained\n- * in the object.  The nonatomic versions guarantee that the new object\n- * is cleared.  GC_malloc_stubborn promises that no changes to the object\n- * will occur after GC_end_stubborn_change has been called on the\n- * result of GC_malloc_stubborn. GC_malloc_uncollectable allocates an object\n- * that is scanned for pointers to collectable objects, but is not itself\n- * collectable.  GC_malloc_uncollectable and GC_free called on the resulting\n- * object implicitly update GC_non_gc_bytes appropriately.\n- */\n-GC_API GC_PTR GC_malloc GC_PROTO((size_t size_in_bytes));\n-GC_API GC_PTR GC_malloc_atomic GC_PROTO((size_t size_in_bytes));\n-GC_API GC_PTR GC_malloc_uncollectable GC_PROTO((size_t size_in_bytes));\n-GC_API GC_PTR GC_malloc_stubborn GC_PROTO((size_t size_in_bytes));\n-\n-/* The following is only defined if the library has been suitably\t*/\n-/* compiled:\t\t\t\t\t\t\t\t*/\n-GC_API GC_PTR GC_malloc_atomic_uncollectable GC_PROTO((size_t size_in_bytes));\n-\n-/* Explicitly deallocate an object.  Dangerous if used incorrectly.     */\n-/* Requires a pointer to the base of an object.\t\t\t\t*/\n-/* If the argument is stubborn, it should not be changeable when freed. */\n-/* An object should not be enable for finalization when it is \t\t*/\n-/* explicitly deallocated.\t\t\t\t\t\t*/\n-/* GC_free(0) is a no-op, as required by ANSI C for free.\t\t*/\n-GC_API void GC_free GC_PROTO((GC_PTR object_addr));\n-\n-/*\n- * Stubborn objects may be changed only if the collector is explicitly informed.\n- * The collector is implicitly informed of coming change when such\n- * an object is first allocated.  The following routines inform the\n- * collector that an object will no longer be changed, or that it will\n- * once again be changed.  Only nonNIL pointer stores into the object\n- * are considered to be changes.  The argument to GC_end_stubborn_change\n- * must be exacly the value returned by GC_malloc_stubborn or passed to\n- * GC_change_stubborn.  (In the second case it may be an interior pointer\n- * within 512 bytes of the beginning of the objects.)\n- * There is a performance penalty for allowing more than\n- * one stubborn object to be changed at once, but it is acceptable to\n- * do so.  The same applies to dropping stubborn objects that are still\n- * changeable.\n- */\n-GC_API void GC_change_stubborn GC_PROTO((GC_PTR));\n-GC_API void GC_end_stubborn_change GC_PROTO((GC_PTR));\n-\n-/* Return a pointer to the base (lowest address) of an object given\t*/\n-/* a pointer to a location within the object.\t\t\t\t*/\n-/* Return 0 if displaced_pointer doesn't point to within a valid\t*/\n-/* object.\t\t\t\t\t\t\t\t*/\n-GC_API GC_PTR GC_base GC_PROTO((GC_PTR displaced_pointer));\n-\n-/* Given a pointer to the base of an object, return its size in bytes.\t*/\n-/* The returned size may be slightly larger than what was originally\t*/\n-/* requested.\t\t\t\t\t\t\t\t*/\n-GC_API size_t GC_size GC_PROTO((GC_PTR object_addr));\n-\n-/* For compatibility with C library.  This is occasionally faster than\t*/\n-/* a malloc followed by a bcopy.  But if you rely on that, either here\t*/\n-/* or with the standard C library, your code is broken.  In my\t\t*/\n-/* opinion, it shouldn't have been invented, but now we're stuck. -HB\t*/\n-/* The resulting object has the same kind as the original.\t\t*/\n-/* If the argument is stubborn, the result will have changes enabled.\t*/\n-/* It is an error to have changes enabled for the original object.\t*/\n-/* Follows ANSI comventions for NULL old_object.\t\t\t*/\n-GC_API GC_PTR GC_realloc\n-\tGC_PROTO((GC_PTR old_object, size_t new_size_in_bytes));\n-\t\t\t\t   \n-/* Explicitly increase the heap size.\t*/\n-/* Returns 0 on failure, 1 on success.  */\n-GC_API int GC_expand_hp GC_PROTO((size_t number_of_bytes));\n-\n-/* Limit the heap size to n bytes.  Useful when you're debugging, \t*/\n-/* especially on systems that don't handle running out of memory well.\t*/\n-/* n == 0 ==> unbounded.  This is the default.\t\t\t\t*/\n-GC_API void GC_set_max_heap_size GC_PROTO((GC_word n));\n-\n-/* Inform the collector that a certain section of statically allocated\t*/\n-/* memory contains no pointers to garbage collected memory.  Thus it \t*/\n-/* need not be scanned.  This is sometimes important if the application */\n-/* maps large read/write files into the address space, which could be\t*/\n-/* mistaken for dynamic library data segments on some systems.\t\t*/\n-GC_API void GC_exclude_static_roots GC_PROTO((GC_PTR start, GC_PTR finish));\n-\n-/* Clear the set of root segments.  Wizards only. */\n-GC_API void GC_clear_roots GC_PROTO((void));\n-\n-/* Add a root segment.  Wizards only. */\n-GC_API void GC_add_roots GC_PROTO((char * low_address,\n-\t\t\t\t   char * high_address_plus_1));\n-\n-/* Add a displacement to the set of those considered valid by the\t*/\n-/* collector.  GC_register_displacement(n) means that if p was returned */\n-/* by GC_malloc, then (char *)p + n will be considered to be a valid\t*/\n-/* pointer to n.  N must be small and less than the size of p.\t\t*/\n-/* (All pointers to the interior of objects from the stack are\t\t*/\n-/* considered valid in any case.  This applies to heap objects and\t*/\n-/* static data.)\t\t\t\t\t\t\t*/\n-/* Preferably, this should be called before any other GC procedures.\t*/\n-/* Calling it later adds to the probability of excess memory\t\t*/\n-/* retention.\t\t\t\t\t\t\t\t*/\n-/* This is a no-op if the collector was compiled with recognition of\t*/\n-/* arbitrary interior pointers enabled, which is now the default.\t*/\n-GC_API void GC_register_displacement GC_PROTO((GC_word n));\n-\n-/* The following version should be used if any debugging allocation is\t*/\n-/* being done.\t\t\t\t\t\t\t\t*/\n-GC_API void GC_debug_register_displacement GC_PROTO((GC_word n));\n-\n-/* Explicitly trigger a full, world-stop collection. \t*/\n-GC_API void GC_gcollect GC_PROTO((void));\n-\n-/* Trigger a full world-stopped collection.  Abort the collection if \t*/\n-/* and when stop_func returns a nonzero value.  Stop_func will be \t*/\n-/* called frequently, and should be reasonably fast.  This works even\t*/\n-/* if virtual dirty bits, and hence incremental collection is not \t*/\n-/* available for this architecture.  Collections can be aborted faster\t*/\n-/* than normal pause times for incremental collection.  However,\t*/\n-/* aborted collections do no useful work; the next collection needs\t*/\n-/* to start from the beginning.\t\t\t\t\t\t*/\n-/* Return 0 if the collection was aborted, 1 if it succeeded.\t\t*/\n-typedef int (* GC_stop_func) GC_PROTO((void));\n-GC_API int GC_try_to_collect GC_PROTO((GC_stop_func stop_func));\n-\n-/* Return the number of bytes in the heap.  Excludes collector private\t*/\n-/* data structures.  Includes empty blocks and fragmentation loss.\t*/\n-/* Includes some pages that were allocated but never written.\t\t*/\n-GC_API size_t GC_get_heap_size GC_PROTO((void));\n-\n-/* Return a lower bound on the number of free bytes in the heap.\t*/\n-GC_API size_t GC_get_free_bytes GC_PROTO((void));\n-\n-/* Return the number of bytes allocated since the last collection.\t*/\n-GC_API size_t GC_get_bytes_since_gc GC_PROTO((void));\n-\n-/* Enable incremental/generational collection.\t*/\n-/* Not advisable unless dirty bits are \t\t*/\n-/* available or most heap objects are\t\t*/\n-/* pointerfree(atomic) or immutable.\t\t*/\n-/* Don't use in leak finding mode.\t\t*/\n-/* Ignored if GC_dont_gc is true.\t\t*/\n-GC_API void GC_enable_incremental GC_PROTO((void));\n-\n-/* Perform some garbage collection work, if appropriate.\t*/\n-/* Return 0 if there is no more work to be done.\t\t*/\n-/* Typically performs an amount of work corresponding roughly\t*/\n-/* to marking from one page.  May do more work if further\t*/\n-/* progress requires it, e.g. if incremental collection is\t*/\n-/* disabled.  It is reasonable to call this in a wait loop\t*/\n-/* until it returns 0.\t\t\t\t\t\t*/\n-GC_API int GC_collect_a_little GC_PROTO((void));\n-\n-/* Allocate an object of size lb bytes.  The client guarantees that\t*/\n-/* as long as the object is live, it will be referenced by a pointer\t*/\n-/* that points to somewhere within the first 256 bytes of the object.\t*/\n-/* (This should normally be declared volatile to prevent the compiler\t*/\n-/* from invalidating this assertion.)  This routine is only useful\t*/\n-/* if a large array is being allocated.  It reduces the chance of \t*/\n-/* accidentally retaining such an array as a result of scanning an\t*/\n-/* integer that happens to be an address inside the array.  (Actually,\t*/\n-/* it reduces the chance of the allocator not finding space for such\t*/\n-/* an array, since it will try hard to avoid introducing such a false\t*/\n-/* reference.)  On a SunOS 4.X or MS Windows system this is recommended */\n-/* for arrays likely to be larger than 100K or so.  For other systems,\t*/\n-/* or if the collector is not configured to recognize all interior\t*/\n-/* pointers, the threshold is normally much higher.\t\t\t*/\n-GC_API GC_PTR GC_malloc_ignore_off_page GC_PROTO((size_t lb));\n-GC_API GC_PTR GC_malloc_atomic_ignore_off_page GC_PROTO((size_t lb));\n-\n-#if defined(__sgi) && !defined(__GNUC__) && _COMPILER_VERSION >= 720\n-#   define GC_ADD_CALLER\n-#   define GC_RETURN_ADDR (GC_word)__return_address\n-#endif\n-\n-#ifdef GC_ADD_CALLER\n-#  define GC_EXTRAS GC_RETURN_ADDR, __FILE__, __LINE__\n-#  define GC_EXTRA_PARAMS GC_word ra, GC_CONST char * s, int i\n-#else\n-#  define GC_EXTRAS __FILE__, __LINE__\n-#  define GC_EXTRA_PARAMS GC_CONST char * s, int i\n-#endif\n-\n-/* Debugging (annotated) allocation.  GC_gcollect will check \t\t*/\n-/* objects allocated in this way for overwrites, etc.\t\t\t*/\n-GC_API GC_PTR GC_debug_malloc\n-\tGC_PROTO((size_t size_in_bytes, GC_EXTRA_PARAMS));\n-GC_API GC_PTR GC_debug_malloc_atomic\n-\tGC_PROTO((size_t size_in_bytes, GC_EXTRA_PARAMS));\n-GC_API GC_PTR GC_debug_malloc_uncollectable\n-\tGC_PROTO((size_t size_in_bytes, GC_EXTRA_PARAMS));\n-GC_API GC_PTR GC_debug_malloc_stubborn\n-\tGC_PROTO((size_t size_in_bytes, GC_EXTRA_PARAMS));\n-GC_API void GC_debug_free GC_PROTO((GC_PTR object_addr));\n-GC_API GC_PTR GC_debug_realloc\n-\tGC_PROTO((GC_PTR old_object, size_t new_size_in_bytes,\n-  \t\t  GC_EXTRA_PARAMS));\n-  \t\t\t \t \n-GC_API void GC_debug_change_stubborn GC_PROTO((GC_PTR));\n-GC_API void GC_debug_end_stubborn_change GC_PROTO((GC_PTR));\n-# ifdef GC_DEBUG\n-#   define GC_MALLOC(sz) GC_debug_malloc(sz, GC_EXTRAS)\n-#   define GC_MALLOC_ATOMIC(sz) GC_debug_malloc_atomic(sz, GC_EXTRAS)\n-#   define GC_MALLOC_UNCOLLECTABLE(sz) GC_debug_malloc_uncollectable(sz, \\\n-\t\t\t\t\t\t\tGC_EXTRAS)\n-#   define GC_REALLOC(old, sz) GC_debug_realloc(old, sz, GC_EXTRAS)\n-#   define GC_FREE(p) GC_debug_free(p)\n-#   define GC_REGISTER_FINALIZER(p, f, d, of, od) \\\n-\tGC_debug_register_finalizer(p, f, d, of, od)\n-#   define GC_REGISTER_FINALIZER_IGNORE_SELF(p, f, d, of, od) \\\n-\tGC_debug_register_finalizer_ignore_self(p, f, d, of, od)\n-#   define GC_REGISTER_FINALIZER_NO_ORDER(p, f, d, of, od) \\\n-\tGC_debug_register_finalizer_no_order(p, f, d, of, od)\n-#   define GC_MALLOC_STUBBORN(sz) GC_debug_malloc_stubborn(sz, GC_EXTRAS);\n-#   define GC_CHANGE_STUBBORN(p) GC_debug_change_stubborn(p)\n-#   define GC_END_STUBBORN_CHANGE(p) GC_debug_end_stubborn_change(p)\n-#   define GC_GENERAL_REGISTER_DISAPPEARING_LINK(link, obj) \\\n-\tGC_general_register_disappearing_link(link, GC_base(obj))\n-#   define GC_REGISTER_DISPLACEMENT(n) GC_debug_register_displacement(n)\n-# else\n-#   define GC_MALLOC(sz) GC_malloc(sz)\n-#   define GC_MALLOC_ATOMIC(sz) GC_malloc_atomic(sz)\n-#   define GC_MALLOC_UNCOLLECTABLE(sz) GC_malloc_uncollectable(sz)\n-#   define GC_REALLOC(old, sz) GC_realloc(old, sz)\n-#   define GC_FREE(p) GC_free(p)\n-#   define GC_REGISTER_FINALIZER(p, f, d, of, od) \\\n-\tGC_register_finalizer(p, f, d, of, od)\n-#   define GC_REGISTER_FINALIZER_IGNORE_SELF(p, f, d, of, od) \\\n-\tGC_register_finalizer_ignore_self(p, f, d, of, od)\n-#   define GC_REGISTER_FINALIZER_NO_ORDER(p, f, d, of, od) \\\n-\tGC_register_finalizer_no_order(p, f, d, of, od)\n-#   define GC_MALLOC_STUBBORN(sz) GC_malloc_stubborn(sz)\n-#   define GC_CHANGE_STUBBORN(p) GC_change_stubborn(p)\n-#   define GC_END_STUBBORN_CHANGE(p) GC_end_stubborn_change(p)\n-#   define GC_GENERAL_REGISTER_DISAPPEARING_LINK(link, obj) \\\n-\tGC_general_register_disappearing_link(link, obj)\n-#   define GC_REGISTER_DISPLACEMENT(n) GC_register_displacement(n)\n-# endif\n-/* The following are included because they are often convenient, and\t*/\n-/* reduce the chance for a misspecifed size argument.  But calls may\t*/\n-/* expand to something syntactically incorrect if t is a complicated\t*/\n-/* type expression.  \t\t\t\t\t\t\t*/\n-# define GC_NEW(t) (t *)GC_MALLOC(sizeof (t))\n-# define GC_NEW_ATOMIC(t) (t *)GC_MALLOC_ATOMIC(sizeof (t))\n-# define GC_NEW_STUBBORN(t) (t *)GC_MALLOC_STUBBORN(sizeof (t))\n-# define GC_NEW_UNCOLLECTABLE(t) (t *)GC_MALLOC_UNCOLLECTABLE(sizeof (t))\n-\n-/* Finalization.  Some of these primitives are grossly unsafe.\t\t*/\n-/* The idea is to make them both cheap, and sufficient to build\t\t*/\n-/* a safer layer, closer to PCedar finalization.\t\t\t*/\n-/* The interface represents my conclusions from a long discussion\t*/\n-/* with Alan Demers, Dan Greene, Carl Hauser, Barry Hayes, \t\t*/\n-/* Christian Jacobi, and Russ Atkinson.  It's not perfect, and\t\t*/\n-/* probably nobody else agrees with it.\t    Hans-J. Boehm  3/13/92\t*/\n-typedef void (*GC_finalization_proc)\n-  \tGC_PROTO((GC_PTR obj, GC_PTR client_data));\n-\n-GC_API void GC_register_finalizer\n-    \tGC_PROTO((GC_PTR obj, GC_finalization_proc fn, GC_PTR cd,\n-\t\t  GC_finalization_proc *ofn, GC_PTR *ocd));\n-GC_API void GC_debug_register_finalizer\n-    \tGC_PROTO((GC_PTR obj, GC_finalization_proc fn, GC_PTR cd,\n-\t\t  GC_finalization_proc *ofn, GC_PTR *ocd));\n-\t/* When obj is no longer accessible, invoke\t\t*/\n-\t/* (*fn)(obj, cd).  If a and b are inaccessible, and\t*/\n-\t/* a points to b (after disappearing links have been\t*/\n-\t/* made to disappear), then only a will be\t\t*/\n-\t/* finalized.  (If this does not create any new\t\t*/\n-\t/* pointers to b, then b will be finalized after the\t*/\n-\t/* next collection.)  Any finalizable object that\t*/\n-\t/* is reachable from itself by following one or more\t*/\n-\t/* pointers will not be finalized (or collected).\t*/\n-\t/* Thus cycles involving finalizable objects should\t*/\n-\t/* be avoided, or broken by disappearing links.\t\t*/\n-\t/* All but the last finalizer registered for an object  */\n-\t/* is ignored.\t\t\t\t\t\t*/\n-\t/* Finalization may be removed by passing 0 as fn.\t*/\n-\t/* Finalizers are implicitly unregistered just before   */\n-\t/* they are invoked.\t\t\t\t\t*/\n-\t/* The old finalizer and client data are stored in\t*/\n-\t/* *ofn and *ocd.\t\t\t\t\t*/ \n-\t/* Fn is never invoked on an accessible object,\t\t*/\n-\t/* provided hidden pointers are converted to real \t*/\n-\t/* pointers only if the allocation lock is held, and\t*/\n-\t/* such conversions are not performed by finalization\t*/\n-\t/* routines.\t\t\t\t\t\t*/\n-\t/* If GC_register_finalizer is aborted as a result of\t*/\n-\t/* a signal, the object may be left with no\t\t*/\n-\t/* finalization, even if neither the old nor new\t*/\n-\t/* finalizer were NULL.\t\t\t\t\t*/\n-\t/* Obj should be the nonNULL starting address of an \t*/\n-\t/* object allocated by GC_malloc or friends.\t\t*/\n-\t/* Note that any garbage collectable object referenced\t*/\n-\t/* by cd will be considered accessible until the\t*/\n-\t/* finalizer is invoked.\t\t\t\t*/\n-\n-/* Another versions of the above follow.  It ignores\t\t*/\n-/* self-cycles, i.e. pointers from a finalizable object to\t*/\n-/* itself.  There is a stylistic argument that this is wrong,\t*/\n-/* but it's unavoidable for C++, since the compiler may\t\t*/\n-/* silently introduce these.  It's also benign in that specific\t*/\n-/* case.\t\t\t\t\t\t\t*/\n-GC_API void GC_register_finalizer_ignore_self\n-\tGC_PROTO((GC_PTR obj, GC_finalization_proc fn, GC_PTR cd,\n-\t\t  GC_finalization_proc *ofn, GC_PTR *ocd));\n-GC_API void GC_debug_register_finalizer_ignore_self\n-\tGC_PROTO((GC_PTR obj, GC_finalization_proc fn, GC_PTR cd,\n-\t\t  GC_finalization_proc *ofn, GC_PTR *ocd));\n-\n-/* Another version of the above.  It ignores all cycles.        */\n-/* It should probably only be used by Java implementations.      */\n-GC_API void GC_register_finalizer_no_order\n-\tGC_PROTO((GC_PTR obj, GC_finalization_proc fn, GC_PTR cd,\n-\t\t  GC_finalization_proc *ofn, GC_PTR *ocd));\n-GC_API void GC_debug_register_finalizer_no_order\n-\tGC_PROTO((GC_PTR obj, GC_finalization_proc fn, GC_PTR cd,\n-\t\t  GC_finalization_proc *ofn, GC_PTR *ocd));\n-\n-\n-/* The following routine may be used to break cycles between\t*/\n-/* finalizable objects, thus causing cyclic finalizable\t\t*/\n-/* objects to be finalized in the correct order.  Standard\t*/\n-/* use involves calling GC_register_disappearing_link(&p),\t*/\n-/* where p is a pointer that is not followed by finalization\t*/\n-/* code, and should not be considered in determining \t\t*/\n-/* finalization order.\t\t\t\t\t\t*/\n-GC_API int GC_register_disappearing_link GC_PROTO((GC_PTR * /* link */));\n-\t/* Link should point to a field of a heap allocated \t*/\n-\t/* object obj.  *link will be cleared when obj is\t*/\n-\t/* found to be inaccessible.  This happens BEFORE any\t*/\n-\t/* finalization code is invoked, and BEFORE any\t\t*/\n-\t/* decisions about finalization order are made.\t\t*/\n-\t/* This is useful in telling the finalizer that \t*/\n-\t/* some pointers are not essential for proper\t\t*/\n-\t/* finalization.  This may avoid finalization cycles.\t*/\n-\t/* Note that obj may be resurrected by another\t\t*/\n-\t/* finalizer, and thus the clearing of *link may\t*/\n-\t/* be visible to non-finalization code.  \t\t*/\n-\t/* There's an argument that an arbitrary action should  */\n-\t/* be allowed here, instead of just clearing a pointer. */\n-\t/* But this causes problems if that action alters, or \t*/\n-\t/* examines connectivity.\t\t\t\t*/\n-\t/* Returns 1 if link was already registered, 0\t\t*/\n-\t/* otherwise.\t\t\t\t\t\t*/\n-\t/* Only exists for backward compatibility.  See below:\t*/\n-\t\n-GC_API int GC_general_register_disappearing_link\n-\tGC_PROTO((GC_PTR * /* link */, GC_PTR obj));\n-\t/* A slight generalization of the above. *link is\t*/\n-\t/* cleared when obj first becomes inaccessible.  This\t*/\n-\t/* can be used to implement weak pointers easily and\t*/\n-\t/* safely. Typically link will point to a location\t*/\n-\t/* holding a disguised pointer to obj.  (A pointer \t*/\n-\t/* inside an \"atomic\" object is effectively  \t\t*/\n-\t/* disguised.)   In this way soft\t\t\t*/\n-\t/* pointers are broken before any object\t\t*/\n-\t/* reachable from them are finalized.  Each link\t*/\n-\t/* May be registered only once, i.e. with one obj\t*/\n-\t/* value.  This was added after a long email discussion */\n-\t/* with John Ellis.\t\t\t\t\t*/\n-\t/* Obj must be a pointer to the first word of an object */\n-\t/* we allocated.  It is unsafe to explicitly deallocate */\n-\t/* the object containing link.  Explicitly deallocating */\n-\t/* obj may or may not cause link to eventually be\t*/\n-\t/* cleared.\t\t\t\t\t\t*/\n-GC_API int GC_unregister_disappearing_link GC_PROTO((GC_PTR * /* link */));\n-\t/* Returns 0 if link was not actually registered.\t*/\n-\t/* Undoes a registration by either of the above two\t*/\n-\t/* routines.\t\t\t\t\t\t*/\n-\n-/* Auxiliary fns to make finalization work correctly with displaced\t*/\n-/* pointers introduced by the debugging allocators.\t\t\t*/\n-GC_API GC_PTR GC_make_closure GC_PROTO((GC_finalization_proc fn, GC_PTR data));\n-GC_API void GC_debug_invoke_finalizer GC_PROTO((GC_PTR obj, GC_PTR data));\n-\n-/* Returns !=0  if GC_invoke_finalizers has something to do. \t\t*/\n-GC_API int GC_should_invoke_finalizers GC_PROTO((void));\n-\n-GC_API int GC_invoke_finalizers GC_PROTO((void));\n-\t/* Run finalizers for all objects that are ready to\t*/\n-\t/* be finalized.  Return the number of finalizers\t*/\n-\t/* that were run.  Normally this is also called\t\t*/\n-\t/* implicitly during some allocations.\tIf\t\t*/\n-\t/* GC-finalize_on_demand is nonzero, it must be called\t*/\n-\t/* explicitly.\t\t\t\t\t\t*/\n-\n-/* GC_set_warn_proc can be used to redirect or filter warning messages.\t*/\n-/* p may not be a NULL pointer.\t\t\t\t\t\t*/\n-typedef void (*GC_warn_proc) GC_PROTO((char *msg, GC_word arg));\n-GC_API GC_warn_proc GC_set_warn_proc GC_PROTO((GC_warn_proc p));\n-    /* Returns old warning procedure.\t*/\n-\t\n-/* The following is intended to be used by a higher level\t*/\n-/* (e.g. cedar-like) finalization facility.  It is expected\t*/\n-/* that finalization code will arrange for hidden pointers to\t*/\n-/* disappear.  Otherwise objects can be accessed after they\t*/\n-/* have been collected.\t\t\t\t\t\t*/\n-/* Note that putting pointers in atomic objects or in \t\t*/\n-/* nonpointer slots of \"typed\" objects is equivalent to \t*/\n-/* disguising them in this way, and may have other advantages.\t*/\n-# if defined(I_HIDE_POINTERS) || defined(GC_I_HIDE_POINTERS)\n-    typedef GC_word GC_hidden_pointer;\n-#   define HIDE_POINTER(p) (~(GC_hidden_pointer)(p))\n-#   define REVEAL_POINTER(p) ((GC_PTR)(HIDE_POINTER(p)))\n-    /* Converting a hidden pointer to a real pointer requires verifying\t*/\n-    /* that the object still exists.  This involves acquiring the  \t*/\n-    /* allocator lock to avoid a race with the collector.\t\t*/\n-# endif /* I_HIDE_POINTERS */\n-\n-typedef GC_PTR (*GC_fn_type) GC_PROTO((GC_PTR client_data));\n-GC_API GC_PTR GC_call_with_alloc_lock\n-        \tGC_PROTO((GC_fn_type fn, GC_PTR client_data));\n-\n-/* Check that p and q point to the same object.  \t\t*/\n-/* Fail conspicuously if they don't.\t\t\t\t*/\n-/* Returns the first argument.  \t\t\t\t*/\n-/* Succeeds if neither p nor q points to the heap.\t\t*/\n-/* May succeed if both p and q point to between heap objects.\t*/\n-GC_API GC_PTR GC_same_obj GC_PROTO((GC_PTR p, GC_PTR q));\n-\n-/* Checked pointer pre- and post- increment operations.  Note that\t*/\n-/* the second argument is in units of bytes, not multiples of the\t*/\n-/* object size.  This should either be invoked from a macro, or the\t*/\n-/* call should be automatically generated.\t\t\t\t*/\n-GC_API GC_PTR GC_pre_incr GC_PROTO((GC_PTR *p, size_t how_much));\n-GC_API GC_PTR GC_post_incr GC_PROTO((GC_PTR *p, size_t how_much));\n-\n-/* Check that p is visible\t\t\t\t\t\t*/\n-/* to the collector as a possibly pointer containing location.\t\t*/\n-/* If it isn't fail conspicuously.\t\t\t\t\t*/\n-/* Returns the argument in all cases.  May erroneously succeed\t\t*/\n-/* in hard cases.  (This is intended for debugging use with\t\t*/\n-/* untyped allocations.  The idea is that it should be possible, though\t*/\n-/* slow, to add such a call to all indirect pointer stores.)\t\t*/\n-/* Currently useless for multithreaded worlds.\t\t\t\t*/\n-GC_API GC_PTR GC_is_visible GC_PROTO((GC_PTR p));\n-\n-/* Check that if p is a pointer to a heap page, then it points to\t*/\n-/* a valid displacement within a heap object.\t\t\t\t*/\n-/* Fail conspicuously if this property does not hold.\t\t\t*/\n-/* Uninteresting with ALL_INTERIOR_POINTERS.\t\t\t\t*/\n-/* Always returns its argument.\t\t\t\t\t\t*/\n-GC_API GC_PTR GC_is_valid_displacement GC_PROTO((GC_PTR\tp));\n-\n-/* Safer, but slow, pointer addition.  Probably useful mainly with \t*/\n-/* a preprocessor.  Useful only for heap pointers.\t\t\t*/\n-#ifdef GC_DEBUG\n-#   define GC_PTR_ADD3(x, n, type_of_result) \\\n-\t((type_of_result)GC_same_obj((x)+(n), (x)))\n-#   define GC_PRE_INCR3(x, n, type_of_result) \\\n-\t((type_of_result)GC_pre_incr(&(x), (n)*sizeof(*x))\n-#   define GC_POST_INCR2(x, type_of_result) \\\n-\t((type_of_result)GC_post_incr(&(x), sizeof(*x))\n-#   ifdef __GNUC__\n-#       define GC_PTR_ADD(x, n) \\\n-\t    GC_PTR_ADD3(x, n, typeof(x))\n-#   define GC_PRE_INCR(x, n) \\\n-\t    GC_PRE_INCR3(x, n, typeof(x))\n-#   define GC_POST_INCR(x, n) \\\n-\t    GC_POST_INCR3(x, typeof(x))\n-#   else\n-\t/* We can't do this right without typeof, which ANSI\t*/\n-\t/* decided was not sufficiently useful.  Repeatedly\t*/\n-\t/* mentioning the arguments seems too dangerous to be\t*/\n-\t/* useful.  So does not casting the result.\t\t*/\n-#   \tdefine GC_PTR_ADD(x, n) ((x)+(n))\n-#   endif\n-#else\t/* !GC_DEBUG */\n-#   define GC_PTR_ADD3(x, n, type_of_result) ((x)+(n))\n-#   define GC_PTR_ADD(x, n) ((x)+(n))\n-#   define GC_PRE_INCR3(x, n, type_of_result) ((x) += (n))\n-#   define GC_PRE_INCR(x, n) ((x) += (n))\n-#   define GC_POST_INCR2(x, n, type_of_result) ((x)++)\n-#   define GC_POST_INCR(x, n) ((x)++)\n-#endif\n-\n-/* Safer assignment of a pointer to a nonstack location.\t*/\n-#ifdef GC_DEBUG\n-# ifdef __STDC__\n-#   define GC_PTR_STORE(p, q) \\\n-\t(*(void **)GC_is_visible(p) = GC_is_valid_displacement(q))\n-# else\n-#   define GC_PTR_STORE(p, q) \\\n-\t(*(char **)GC_is_visible(p) = GC_is_valid_displacement(q))\n-# endif\n-#else /* !GC_DEBUG */\n-#   define GC_PTR_STORE(p, q) *((p) = (q))\n-#endif\n-\n-/* Fynctions called to report pointer checking errors */\n-GC_API void (*GC_same_obj_print_proc) GC_PROTO((GC_PTR p, GC_PTR q));\n-\n-GC_API void (*GC_is_valid_displacement_print_proc)\n-\tGC_PROTO((GC_PTR p));\n-\n-GC_API void (*GC_is_visible_print_proc)\n-\tGC_PROTO((GC_PTR p));\n-\n-#if defined(_SOLARIS_PTHREADS) && !defined(SOLARIS_THREADS)\n-#   define SOLARIS_THREADS\n-#endif\n-\n-#ifdef SOLARIS_THREADS\n-/* We need to intercept calls to many of the threads primitives, so \t*/\n-/* that we can locate thread stacks and stop the world.\t\t\t*/\n-/* Note also that the collector cannot see thread specific data.\t*/\n-/* Thread specific data should generally consist of pointers to\t\t*/\n-/* uncollectable objects, which are deallocated using the destructor\t*/\n-/* facility in thr_keycreate.\t\t\t\t\t\t*/\n-# include <thread.h>\n-# include <signal.h>\n-  int GC_thr_create(void *stack_base, size_t stack_size,\n-                    void *(*start_routine)(void *), void *arg, long flags,\n-                    thread_t *new_thread);\n-  int GC_thr_join(thread_t wait_for, thread_t *departed, void **status);\n-  int GC_thr_suspend(thread_t target_thread);\n-  int GC_thr_continue(thread_t target_thread);\n-  void * GC_dlopen(const char *path, int mode);\n-\n-# ifdef _SOLARIS_PTHREADS\n-#   include <pthread.h>\n-    extern int GC_pthread_create(pthread_t *new_thread,\n-    \t\t\t         const pthread_attr_t *attr,\n-          \t\t\t void * (*thread_execp)(void *), void *arg);\n-    extern int GC_pthread_join(pthread_t wait_for, void **status);\n-\n-#   undef thread_t\n-\n-#   define pthread_join GC_pthread_join\n-#   define pthread_create GC_pthread_create\n-#endif\n-\n-# define thr_create GC_thr_create\n-# define thr_join GC_thr_join\n-# define thr_suspend GC_thr_suspend\n-# define thr_continue GC_thr_continue\n-# define dlopen GC_dlopen\n-\n-# endif /* SOLARIS_THREADS */\n-\n-\n-#if !defined(USE_LD_WRAP) && \\\n-    (defined(IRIX_THREADS) || defined(LINUX_THREADS) || defined(HPUX_THREADS))\n-/* We treat these similarly. */\n-# include <pthread.h>\n-# include <signal.h>\n-\n-  int GC_pthread_create(pthread_t *new_thread,\n-                        const pthread_attr_t *attr,\n-\t\t        void *(*start_routine)(void *), void *arg);\n-  int GC_pthread_sigmask(int how, const sigset_t *set, sigset_t *oset);\n-  int GC_pthread_join(pthread_t thread, void **retval);\n-\n-# define pthread_create GC_pthread_create\n-# define pthread_sigmask GC_pthread_sigmask\n-# define pthread_join GC_pthread_join\n-# define dlopen GC_dlopen\n-\n-#endif /* xxxxx_THREADS */\n-\n-# if defined(PCR) || defined(SOLARIS_THREADS) || defined(WIN32_THREADS) || \\\n-\tdefined(IRIX_THREADS) || defined(LINUX_THREADS) || \\\n-\tdefined(IRIX_JDK_THREADS) || defined(HPUX_THREADS)\n-   \t/* Any flavor of threads except SRC_M3.\t*/\n-/* This returns a list of objects, linked through their first\t\t*/\n-/* word.  Its use can greatly reduce lock contention problems, since\t*/\n-/* the allocation lock can be acquired and released many fewer times.\t*/\n-/* lb must be large enough to hold the pointer field.\t\t\t*/\n-GC_PTR GC_malloc_many(size_t lb);\n-#define GC_NEXT(p) (*(GC_PTR *)(p)) \t/* Retrieve the next element\t*/\n-\t\t\t\t\t/* in returned list.\t\t*/\n-extern void GC_thr_init();\t/* Needed for Solaris/X86\t*/\n-\n-#endif /* THREADS && !SRC_M3 */\n-\n-/*\n- * If you are planning on putting\n- * the collector in a SunOS 5 dynamic library, you need to call GC_INIT()\n- * from the statically loaded program section.\n- * This circumvents a Solaris 2.X (X<=4) linker bug.\n- */\n-#if defined(sparc) || defined(__sparc)\n-#   define GC_INIT() { extern end, etext; \\\n-\t\t       GC_noop(&end, &etext); }\n-#else\n-# if defined(__CYGWIN32__) && defined(GC_USE_DLL)\n-    /*\n-     * Similarly gnu-win32 DLLs need explicit initialization\n-     */\n-#   define GC_INIT() { GC_add_roots(DATASTART, DATAEND); }\n-# else\n-#   define GC_INIT()\n-# endif\n-#endif\n-\n-#if (defined(_MSDOS) || defined(_MSC_VER)) && (_M_IX86 >= 300) \\\n-     || defined(_WIN32)\n-  /* win32S may not free all resources on process exit.  */\n-  /* This explicitly deallocates the heap.\t\t */\n-    GC_API void GC_win32_free_heap ();\n-#endif\n-\n-#ifdef __cplusplus\n-    }  /* end of extern \"C\" */\n-#endif\n-\n-#endif /* _GC_H */"}, {"sha": "c90584ec9a003dee8bfacdd99c1772d3948a16a2", "filename": "boehm-gc/gc.mak", "status": "modified", "additions": 286, "deletions": 215, "changes": 501, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9110a741e35c54e46c00662ddc420575376c5947/boehm-gc%2Fgc.mak", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9110a741e35c54e46c00662ddc420575376c5947/boehm-gc%2Fgc.mak", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fgc.mak?ref=9110a741e35c54e46c00662ddc420575376c5947", "patch": "@@ -1,5 +1,6 @@\n # Microsoft Developer Studio Generated NMAKE File, Format Version 4.10\n-# ** DO NOT EDIT **\n+# This has been hand-edited way too many times.\n+# A clean, manually generated makefile would be an improvement.\n \n # TARGTYPE \"Win32 (x86) Application\" 0x0101\n # TARGTYPE \"Win32 (x86) Dynamic-Link Library\" 0x0102\n@@ -72,6 +73,8 @@ CLEAN :\n \t-@erase \".\\Release\\finalize.obj\"\n \t-@erase \".\\Release\\finalize.sbr\"\n \t-@erase \".\\Release\\gc.bsc\"\n+\t-@erase \".\\Release\\gc_cpp.obj\"\n+\t-@erase \".\\Release\\gc_cpp.sbr\"\n \t-@erase \".\\Release\\gc.dll\"\n \t-@erase \".\\Release\\gc.exp\"\n \t-@erase \".\\Release\\gc.lib\"\n@@ -111,8 +114,8 @@ CLEAN :\n \n CPP=cl.exe\n # ADD BASE CPP /nologo /MT /W3 /GX /O2 /D \"WIN32\" /D \"NDEBUG\" /D \"_WINDOWS\" /YX /c\n-# ADD CPP /nologo /MD /W3 /GX /O2 /D \"NDEBUG\" /D \"SILENT\" /D \"GC_BUILD\" /D \"WIN32\" /D \"_WINDOWS\" /D \"ALL_INTERIOR_POINTERS\" /D \"__STDC__\" /D \"WIN32_THREADS\" /FR /YX /c\n-CPP_PROJ=/nologo /MD /W3 /GX /O2 /D \"NDEBUG\" /D \"SILENT\" /D \"GC_BUILD\" /D\\\n+# ADD CPP /nologo /MD /W3 /GX /O2 /I include /D \"NDEBUG\" /D \"SILENT\" /D \"GC_BUILD\" /D \"WIN32\" /D \"_WINDOWS\" /D \"ALL_INTERIOR_POINTERS\" /D \"__STDC__\" /D \"WIN32_THREADS\" /FR /YX /c\n+CPP_PROJ=/nologo /MD /W3 /GX /O2 /I include /D \"NDEBUG\" /D \"SILENT\" /D \"GC_BUILD\" /D\\\n  \"WIN32\" /D \"_WINDOWS\" /D \"ALL_INTERIOR_POINTERS\" /D \"__STDC__\" /D\\\n  \"WIN32_THREADS\" /FR\"$(INTDIR)/\" /Fp\"$(INTDIR)/gc.pch\" /YX /Fo\"$(INTDIR)/\" /c \n CPP_OBJS=.\\Release/\n@@ -155,6 +158,7 @@ BSC32_SBRS= \\\n \t\".\\Release\\dbg_mlc.sbr\" \\\n \t\".\\Release\\dyn_load.sbr\" \\\n \t\".\\Release\\finalize.sbr\" \\\n+\t\".\\Release\\gc_cpp.sbr\" \\\n \t\".\\Release\\headers.sbr\" \\\n \t\".\\Release\\mach_dep.sbr\" \\\n \t\".\\Release\\malloc.sbr\" \\\n@@ -192,6 +196,7 @@ LINK32_OBJS= \\\n \t\".\\Release\\dbg_mlc.obj\" \\\n \t\".\\Release\\dyn_load.obj\" \\\n \t\".\\Release\\finalize.obj\" \\\n+\t\".\\Release\\gc_cpp.obj\" \\\n \t\".\\Release\\headers.obj\" \\\n \t\".\\Release\\mach_dep.obj\" \\\n \t\".\\Release\\malloc.obj\" \\\n@@ -245,6 +250,8 @@ CLEAN :\n \t-@erase \".\\Debug\\dyn_load.sbr\"\n \t-@erase \".\\Debug\\finalize.obj\"\n \t-@erase \".\\Debug\\finalize.sbr\"\n+\t-@erase \".\\Debug\\gc_cpp.obj\"\n+\t-@erase \".\\Debug\\gc_cpp.sbr\"\n \t-@erase \".\\Debug\\gc.bsc\"\n \t-@erase \".\\Debug\\gc.dll\"\n \t-@erase \".\\Debug\\gc.exp\"\n@@ -289,8 +296,8 @@ CLEAN :\n \n CPP=cl.exe\n # ADD BASE CPP /nologo /MTd /W3 /Gm /GX /Zi /Od /D \"WIN32\" /D \"_DEBUG\" /D \"_WINDOWS\" /YX /c\n-# ADD CPP /nologo /MDd /W3 /Gm /GX /Zi /Od /D \"_DEBUG\" /D \"SILENT\" /D \"GC_BUILD\" /D \"WIN32\" /D \"_WINDOWS\" /D \"ALL_INTERIOR_POINTERS\" /D \"__STDC__\" /D \"WIN32_THREADS\" /FR /YX /c\n-CPP_PROJ=/nologo /MDd /W3 /Gm /GX /Zi /Od /D \"_DEBUG\" /D \"SILENT\" /D \"GC_BUILD\"\\\n+# ADD CPP /nologo /MDd /W3 /Gm /GX /Zi /Od /I include /D \"_DEBUG\" /D \"SILENT\" /D \"GC_BUILD\" /D \"WIN32\" /D \"_WINDOWS\" /D \"ALL_INTERIOR_POINTERS\" /D \"__STDC__\" /D \"WIN32_THREADS\" /FR /YX /c\n+CPP_PROJ=/nologo /MDd /W3 /Gm /GX /Zi /Od /I include /D \"_DEBUG\" /D \"SILENT\" /D \"GC_BUILD\"\\\n  /D \"WIN32\" /D \"_WINDOWS\" /D \"ALL_INTERIOR_POINTERS\" /D \"__STDC__\" /D\\\n  \"WIN32_THREADS\" /FR\"$(INTDIR)/\" /Fp\"$(INTDIR)/gc.pch\" /YX /Fo\"$(INTDIR)/\"\\\n  /Fd\"$(INTDIR)/\" /c \n@@ -334,6 +341,7 @@ BSC32_SBRS= \\\n \t\".\\Debug\\dbg_mlc.sbr\" \\\n \t\".\\Debug\\dyn_load.sbr\" \\\n \t\".\\Debug\\finalize.sbr\" \\\n+\t\".\\Debug\\gc_cpp.sbr\" \\\n \t\".\\Debug\\headers.sbr\" \\\n \t\".\\Debug\\mach_dep.sbr\" \\\n \t\".\\Debug\\malloc.sbr\" \\\n@@ -371,6 +379,7 @@ LINK32_OBJS= \\\n \t\".\\Debug\\dbg_mlc.obj\" \\\n \t\".\\Debug\\dyn_load.obj\" \\\n \t\".\\Debug\\finalize.obj\" \\\n+\t\".\\Debug\\gc_cpp.obj\" \\\n \t\".\\Debug\\headers.obj\" \\\n \t\".\\Debug\\mach_dep.obj\" \\\n \t\".\\Debug\\malloc.obj\" \\\n@@ -416,10 +425,13 @@ CLEAN :\n \"$(OUTDIR)\" :\n     if not exist \"$(OUTDIR)/$(NULL)\" mkdir \"$(OUTDIR)\"\n \n+test.c : tests\\test.c\n+\tcopy tests\\test.c test.c\n+\n CPP=cl.exe\n # ADD BASE CPP /nologo /W3 /GX /O2 /D \"WIN32\" /D \"NDEBUG\" /D \"_WINDOWS\" /YX /c\n-# ADD CPP /nologo /MD /W3 /GX /O2 /D \"NDEBUG\" /D \"WIN32\" /D \"_WINDOWS\" /D \"ALL_INTERIOR_POINTERS\" /D \"__STDC__\" /D \"WIN32_THREADS\" /YX /c\n-CPP_PROJ=/nologo /MD /W3 /GX /O2 /D \"NDEBUG\" /D \"WIN32\" /D \"_WINDOWS\" /D\\\n+# ADD CPP /nologo /MD /W3 /GX /O2 /I include /D \"NDEBUG\" /D \"WIN32\" /D \"_WINDOWS\" /D \"ALL_INTERIOR_POINTERS\" /D \"__STDC__\" /D \"WIN32_THREADS\" /YX /c\n+CPP_PROJ=/nologo /MD /W3 /GX /O2 /I include /D \"NDEBUG\" /D \"WIN32\" /D \"_WINDOWS\" /D\\\n  \"ALL_INTERIOR_POINTERS\" /D \"__STDC__\" /D \"WIN32_THREADS\"\\\n  /Fp\"$(INTDIR)/gctest.pch\" /YX /Fo\"$(INTDIR)/\" /c \n CPP_OBJS=.\\gctest\\Release/\n@@ -505,7 +517,7 @@ CLEAN :\n CPP=cl.exe\n # ADD BASE CPP /nologo /W3 /Gm /GX /Zi /Od /D \"WIN32\" /D \"_DEBUG\" /D \"_WINDOWS\" /YX /c\n # ADD CPP /nologo /MDd /W3 /Gm /GX /Zi /Od /D \"_DEBUG\" /D \"WIN32\" /D \"_WINDOWS\" /D \"ALL_INTERIOR_POINTERS\" /D \"__STDC__\" /D \"WIN32_THREADS\" /FR /YX /c\n-CPP_PROJ=/nologo /MDd /W3 /Gm /GX /Zi /Od /D \"_DEBUG\" /D \"WIN32\" /D \"_WINDOWS\"\\\n+CPP_PROJ=/nologo /MDd /W3 /Gm /GX /Zi /Od /I include /D \"_DEBUG\" /D \"WIN32\" /D \"_WINDOWS\"\\\n  /D \"ALL_INTERIOR_POINTERS\" /D \"__STDC__\" /D \"WIN32_THREADS\" /FR\"$(INTDIR)/\"\\\n  /Fp\"$(INTDIR)/gctest.pch\" /YX /Fo\"$(INTDIR)/\" /Fd\"$(INTDIR)/\" /c \n CPP_OBJS=.\\gctest\\Debug/\n@@ -596,7 +608,7 @@ CLEAN :\n CPP=cl.exe\n # ADD BASE CPP /nologo /W3 /GX /O2 /D \"WIN32\" /D \"NDEBUG\" /D \"_WINDOWS\" /YX /c\n # ADD CPP /nologo /MD /W3 /GX /O2 /I \".\" /D \"NDEBUG\" /D \"WIN32\" /D \"_WINDOWS\" /D \"ALL_INTERIOR_POINTERS\" /YX /c\n-CPP_PROJ=/nologo /MD /W3 /GX /O2 /I \".\" /D \"NDEBUG\" /D \"WIN32\" /D \"_WINDOWS\" /D\\\n+CPP_PROJ=/nologo /MD /W3 /GX /O2 /I \".\" /I include /D \"NDEBUG\" /D \"WIN32\" /D \"_WINDOWS\" /D\\\n  \"ALL_INTERIOR_POINTERS\" /Fp\"$(INTDIR)/cord.pch\" /YX /Fo\"$(INTDIR)/\" /c \n CPP_OBJS=.\\cord\\Release/\n CPP_SBRS=.\\.\n@@ -688,7 +700,7 @@ CLEAN :\n CPP=cl.exe\n # ADD BASE CPP /nologo /W3 /Gm /GX /Zi /Od /D \"WIN32\" /D \"_DEBUG\" /D \"_WINDOWS\" /YX /c\n # ADD CPP /nologo /MDd /W3 /Gm /GX /Zi /Od /I \".\" /D \"_DEBUG\" /D \"WIN32\" /D \"_WINDOWS\" /D \"ALL_INTERIOR_POINTERS\" /YX /c\n-CPP_PROJ=/nologo /MDd /W3 /Gm /GX /Zi /Od /I \".\" /D \"_DEBUG\" /D \"WIN32\" /D\\\n+CPP_PROJ=/nologo /MDd /W3 /Gm /GX /Zi /Od /I \".\" /I include /D \"_DEBUG\" /D \"WIN32\" /D\\\n  \"_WINDOWS\" /D \"ALL_INTERIOR_POINTERS\" /Fp\"$(INTDIR)/cord.pch\" /YX\\\n  /Fo\"$(INTDIR)/\" /Fd\"$(INTDIR)/\" /c \n CPP_OBJS=.\\cord\\Debug/\n@@ -763,15 +775,65 @@ LINK32_OBJS= \\\n ################################################################################\n # Begin Source File\n \n+SOURCE=.\\gc_cpp.cpp\n+\n+!IF  \"$(CFG)\" == \"gc - Win32 Release\"\n+\n+DEP_CPP_RECLA=\\\n+\t\".\\include\\private\\gcconfig.h\"\\\n+\t\".\\include\\gc.h\"\\\n+\t\".\\include\\private\\gc_hdrs.h\"\\\n+\t\".\\include\\private\\gc_priv.h\"\\\n+\t\".\\include\\gc_cpp.h\"\\\n+\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n+\t\n+NODEP_CPP_RECLA=\\\n+\t\".\\th\\PCR_Th.h\"\\\n+\t\".\\th\\PCR_ThCrSec.h\"\\\n+\t\".\\th\\PCR_ThCtl.h\"\\\n+\t\n+\n+\".\\Release\\gc_cpp.obj\" : $(SOURCE) $(DEP_CPP_RECLA) \"$(INTDIR)\"\n+\n+\".\\Release\\gc_cpp.sbr\" : $(SOURCE) $(DEP_CPP_RECLA) \"$(INTDIR)\"\n+\n+\n+!ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n+\n+DEP_CPP_RECLA=\\\n+\t\".\\include\\private\\gcconfig.h\"\\\n+\t\".\\include\\gc.h\"\\\n+\t\".\\include\\private\\gc_hdrs.h\"\\\n+\t\".\\include\\private\\gc_priv.h\"\\\n+\t\".\\include\\gc_cpp.h\"\\\n+\t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n+\t\n+NODEP_CPP_RECLA=\\\n+\t\".\\th\\PCR_Th.h\"\\\n+\t\".\\th\\PCR_ThCrSec.h\"\\\n+\t\".\\th\\PCR_ThCtl.h\"\\\n+\t\n+\n+\".\\Debug\\gc_cpp.obj\" : $(SOURCE) $(DEP_CPP_RECLA) \"$(INTDIR)\"\n+\n+\".\\Debug\\gc_cpp.sbr\" : $(SOURCE) $(DEP_CPP_RECLA) \"$(INTDIR)\"\n+\n+\n+!ENDIF \n+\n+# End Source File\n+################################################################################\n+# Begin Source File\n+\n SOURCE=.\\reclaim.c\n \n !IF  \"$(CFG)\" == \"gc - Win32 Release\"\n \n DEP_CPP_RECLA=\\\n-\t\".\\gcconfig.h\"\\\n-\t\".\\gc.h\"\\\n-\t\".\\gc_hdrs.h\"\\\n-\t\".\\gc_priv.h\"\\\n+\t\".\\include\\private\\gcconfig.h\"\\\n+\t\".\\include\\gc.h\"\\\n+\t\".\\include\\private\\gc_hdrs.h\"\\\n+\t\".\\include\\private\\gc_priv.h\"\\\n \t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n \t\n NODEP_CPP_RECLA=\\\n@@ -788,10 +850,10 @@ NODEP_CPP_RECLA=\\\n !ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n \n DEP_CPP_RECLA=\\\n-\t\".\\gcconfig.h\"\\\n-\t\".\\gc.h\"\\\n-\t\".\\gc_hdrs.h\"\\\n-\t\".\\gc_priv.h\"\\\n+\t\".\\include\\private\\gcconfig.h\"\\\n+\t\".\\include\\gc.h\"\\\n+\t\".\\include\\private\\gc_hdrs.h\"\\\n+\t\".\\include\\private\\gc_priv.h\"\\\n \t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n \t\n NODEP_CPP_RECLA=\\\n@@ -808,6 +870,7 @@ NODEP_CPP_RECLA=\\\n !ENDIF \n \n # End Source File\n+\n ################################################################################\n # Begin Source File\n \n@@ -816,10 +879,10 @@ SOURCE=.\\os_dep.c\n !IF  \"$(CFG)\" == \"gc - Win32 Release\"\n \n DEP_CPP_OS_DE=\\\n-\t\".\\gcconfig.h\"\\\n-\t\".\\gc.h\"\\\n-\t\".\\gc_hdrs.h\"\\\n-\t\".\\gc_priv.h\"\\\n+\t\".\\include\\private\\gcconfig.h\"\\\n+\t\".\\include\\gc.h\"\\\n+\t\".\\include\\private\\gc_hdrs.h\"\\\n+\t\".\\include\\private\\gc_priv.h\"\\\n \t{$(INCLUDE)}\"\\sys\\STAT.H\"\\\n \t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n \t\n@@ -840,10 +903,10 @@ NODEP_CPP_OS_DE=\\\n !ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n \n DEP_CPP_OS_DE=\\\n-\t\".\\gcconfig.h\"\\\n-\t\".\\gc.h\"\\\n-\t\".\\gc_hdrs.h\"\\\n-\t\".\\gc_priv.h\"\\\n+\t\".\\include\\private\\gcconfig.h\"\\\n+\t\".\\include\\gc.h\"\\\n+\t\".\\include\\private\\gc_hdrs.h\"\\\n+\t\".\\include\\private\\gc_priv.h\"\\\n \t{$(INCLUDE)}\"\\sys\\STAT.H\"\\\n \t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n \t\n@@ -872,10 +935,10 @@ SOURCE=.\\misc.c\n !IF  \"$(CFG)\" == \"gc - Win32 Release\"\n \n DEP_CPP_MISC_=\\\n-\t\".\\gcconfig.h\"\\\n-\t\".\\gc.h\"\\\n-\t\".\\gc_hdrs.h\"\\\n-\t\".\\gc_priv.h\"\\\n+\t\".\\include\\private\\gcconfig.h\"\\\n+\t\".\\include\\gc.h\"\\\n+\t\".\\include\\private\\gc_hdrs.h\"\\\n+\t\".\\include\\private\\gc_priv.h\"\\\n \t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n \t\n NODEP_CPP_MISC_=\\\n@@ -893,10 +956,10 @@ NODEP_CPP_MISC_=\\\n !ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n \n DEP_CPP_MISC_=\\\n-\t\".\\gcconfig.h\"\\\n-\t\".\\gc.h\"\\\n-\t\".\\gc_hdrs.h\"\\\n-\t\".\\gc_priv.h\"\\\n+\t\".\\include\\private\\gcconfig.h\"\\\n+\t\".\\include\\gc.h\"\\\n+\t\".\\include\\private\\gc_hdrs.h\"\\\n+\t\".\\include\\private\\gc_priv.h\"\\\n \t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n \t\n NODEP_CPP_MISC_=\\\n@@ -922,10 +985,10 @@ SOURCE=.\\mark_rts.c\n !IF  \"$(CFG)\" == \"gc - Win32 Release\"\n \n DEP_CPP_MARK_=\\\n-\t\".\\gcconfig.h\"\\\n-\t\".\\gc.h\"\\\n-\t\".\\gc_hdrs.h\"\\\n-\t\".\\gc_priv.h\"\\\n+\t\".\\include\\private\\gcconfig.h\"\\\n+\t\".\\include\\gc.h\"\\\n+\t\".\\include\\private\\gc_hdrs.h\"\\\n+\t\".\\include\\private\\gc_priv.h\"\\\n \t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n \t\n NODEP_CPP_MARK_=\\\n@@ -942,10 +1005,10 @@ NODEP_CPP_MARK_=\\\n !ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n \n DEP_CPP_MARK_=\\\n-\t\".\\gcconfig.h\"\\\n-\t\".\\gc.h\"\\\n-\t\".\\gc_hdrs.h\"\\\n-\t\".\\gc_priv.h\"\\\n+\t\".\\include\\private\\gcconfig.h\"\\\n+\t\".\\include\\gc.h\"\\\n+\t\".\\include\\private\\gc_hdrs.h\"\\\n+\t\".\\include\\private\\gc_priv.h\"\\\n \t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n \t\n NODEP_CPP_MARK_=\\\n@@ -970,10 +1033,10 @@ SOURCE=.\\mach_dep.c\n !IF  \"$(CFG)\" == \"gc - Win32 Release\"\n \n DEP_CPP_MACH_=\\\n-\t\".\\gcconfig.h\"\\\n-\t\".\\gc.h\"\\\n-\t\".\\gc_hdrs.h\"\\\n-\t\".\\gc_priv.h\"\\\n+\t\".\\include\\private\\gcconfig.h\"\\\n+\t\".\\include\\gc.h\"\\\n+\t\".\\include\\private\\gc_hdrs.h\"\\\n+\t\".\\include\\private\\gc_priv.h\"\\\n \t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n \t\n NODEP_CPP_MACH_=\\\n@@ -990,10 +1053,10 @@ NODEP_CPP_MACH_=\\\n !ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n \n DEP_CPP_MACH_=\\\n-\t\".\\gcconfig.h\"\\\n-\t\".\\gc.h\"\\\n-\t\".\\gc_hdrs.h\"\\\n-\t\".\\gc_priv.h\"\\\n+\t\".\\include\\private\\gcconfig.h\"\\\n+\t\".\\include\\gc.h\"\\\n+\t\".\\include\\private\\gc_hdrs.h\"\\\n+\t\".\\include\\private\\gc_priv.h\"\\\n \t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n \t\n NODEP_CPP_MACH_=\\\n@@ -1018,10 +1081,10 @@ SOURCE=.\\headers.c\n !IF  \"$(CFG)\" == \"gc - Win32 Release\"\n \n DEP_CPP_HEADE=\\\n-\t\".\\gcconfig.h\"\\\n-\t\".\\gc.h\"\\\n-\t\".\\gc_hdrs.h\"\\\n-\t\".\\gc_priv.h\"\\\n+\t\".\\include\\private\\gcconfig.h\"\\\n+\t\".\\include\\gc.h\"\\\n+\t\".\\include\\private\\gc_hdrs.h\"\\\n+\t\".\\include\\private\\gc_priv.h\"\\\n \t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n \t\n NODEP_CPP_HEADE=\\\n@@ -1038,10 +1101,10 @@ NODEP_CPP_HEADE=\\\n !ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n \n DEP_CPP_HEADE=\\\n-\t\".\\gcconfig.h\"\\\n-\t\".\\gc.h\"\\\n-\t\".\\gc_hdrs.h\"\\\n-\t\".\\gc_priv.h\"\\\n+\t\".\\include\\private\\gcconfig.h\"\\\n+\t\".\\include\\gc.h\"\\\n+\t\".\\include\\private\\gc_hdrs.h\"\\\n+\t\".\\include\\private\\gc_priv.h\"\\\n \t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n \t\n NODEP_CPP_HEADE=\\\n@@ -1066,10 +1129,10 @@ SOURCE=.\\alloc.c\n !IF  \"$(CFG)\" == \"gc - Win32 Release\"\n \n DEP_CPP_ALLOC=\\\n-\t\".\\gcconfig.h\"\\\n-\t\".\\gc.h\"\\\n-\t\".\\gc_hdrs.h\"\\\n-\t\".\\gc_priv.h\"\\\n+\t\".\\include\\private\\gcconfig.h\"\\\n+\t\".\\include\\gc.h\"\\\n+\t\".\\include\\private\\gc_hdrs.h\"\\\n+\t\".\\include\\private\\gc_priv.h\"\\\n \t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n \t\n NODEP_CPP_ALLOC=\\\n@@ -1086,10 +1149,10 @@ NODEP_CPP_ALLOC=\\\n !ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n \n DEP_CPP_ALLOC=\\\n-\t\".\\gcconfig.h\"\\\n-\t\".\\gc.h\"\\\n-\t\".\\gc_hdrs.h\"\\\n-\t\".\\gc_priv.h\"\\\n+\t\".\\include\\private\\gcconfig.h\"\\\n+\t\".\\include\\gc.h\"\\\n+\t\".\\include\\private\\gc_hdrs.h\"\\\n+\t\".\\include\\private\\gc_priv.h\"\\\n \t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n \t\n NODEP_CPP_ALLOC=\\\n@@ -1114,10 +1177,10 @@ SOURCE=.\\allchblk.c\n !IF  \"$(CFG)\" == \"gc - Win32 Release\"\n \n DEP_CPP_ALLCH=\\\n-\t\".\\gcconfig.h\"\\\n-\t\".\\gc.h\"\\\n-\t\".\\gc_hdrs.h\"\\\n-\t\".\\gc_priv.h\"\\\n+\t\".\\include\\private\\gcconfig.h\"\\\n+\t\".\\include\\gc.h\"\\\n+\t\".\\include\\private\\gc_hdrs.h\"\\\n+\t\".\\include\\private\\gc_priv.h\"\\\n \t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n \t\n NODEP_CPP_ALLCH=\\\n@@ -1134,10 +1197,10 @@ NODEP_CPP_ALLCH=\\\n !ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n \n DEP_CPP_ALLCH=\\\n-\t\".\\gcconfig.h\"\\\n-\t\".\\gc.h\"\\\n-\t\".\\gc_hdrs.h\"\\\n-\t\".\\gc_priv.h\"\\\n+\t\".\\include\\private\\gcconfig.h\"\\\n+\t\".\\include\\gc.h\"\\\n+\t\".\\include\\private\\gc_hdrs.h\"\\\n+\t\".\\include\\private\\gc_priv.h\"\\\n \t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n \t\n NODEP_CPP_ALLCH=\\\n@@ -1162,10 +1225,10 @@ SOURCE=.\\stubborn.c\n !IF  \"$(CFG)\" == \"gc - Win32 Release\"\n \n DEP_CPP_STUBB=\\\n-\t\".\\gcconfig.h\"\\\n-\t\".\\gc.h\"\\\n-\t\".\\gc_hdrs.h\"\\\n-\t\".\\gc_priv.h\"\\\n+\t\".\\include\\private\\gcconfig.h\"\\\n+\t\".\\include\\gc.h\"\\\n+\t\".\\include\\private\\gc_hdrs.h\"\\\n+\t\".\\include\\private\\gc_priv.h\"\\\n \t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n \t\n NODEP_CPP_STUBB=\\\n@@ -1182,10 +1245,10 @@ NODEP_CPP_STUBB=\\\n !ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n \n DEP_CPP_STUBB=\\\n-\t\".\\gcconfig.h\"\\\n-\t\".\\gc.h\"\\\n-\t\".\\gc_hdrs.h\"\\\n-\t\".\\gc_priv.h\"\\\n+\t\".\\include\\private\\gcconfig.h\"\\\n+\t\".\\include\\gc.h\"\\\n+\t\".\\include\\private\\gc_hdrs.h\"\\\n+\t\".\\include\\private\\gc_priv.h\"\\\n \t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n \t\n NODEP_CPP_STUBB=\\\n@@ -1210,10 +1273,10 @@ SOURCE=.\\obj_map.c\n !IF  \"$(CFG)\" == \"gc - Win32 Release\"\n \n DEP_CPP_OBJ_M=\\\n-\t\".\\gcconfig.h\"\\\n-\t\".\\gc.h\"\\\n-\t\".\\gc_hdrs.h\"\\\n-\t\".\\gc_priv.h\"\\\n+\t\".\\include\\private\\gcconfig.h\"\\\n+\t\".\\include\\gc.h\"\\\n+\t\".\\include\\private\\gc_hdrs.h\"\\\n+\t\".\\include\\private\\gc_priv.h\"\\\n \t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n \t\n NODEP_CPP_OBJ_M=\\\n@@ -1230,10 +1293,10 @@ NODEP_CPP_OBJ_M=\\\n !ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n \n DEP_CPP_OBJ_M=\\\n-\t\".\\gcconfig.h\"\\\n-\t\".\\gc.h\"\\\n-\t\".\\gc_hdrs.h\"\\\n-\t\".\\gc_priv.h\"\\\n+\t\".\\include\\private\\gcconfig.h\"\\\n+\t\".\\include\\gc.h\"\\\n+\t\".\\include\\private\\gc_hdrs.h\"\\\n+\t\".\\include\\private\\gc_priv.h\"\\\n \t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n \t\n NODEP_CPP_OBJ_M=\\\n@@ -1258,10 +1321,10 @@ SOURCE=.\\new_hblk.c\n !IF  \"$(CFG)\" == \"gc - Win32 Release\"\n \n DEP_CPP_NEW_H=\\\n-\t\".\\gcconfig.h\"\\\n-\t\".\\gc.h\"\\\n-\t\".\\gc_hdrs.h\"\\\n-\t\".\\gc_priv.h\"\\\n+\t\".\\include\\private\\gcconfig.h\"\\\n+\t\".\\include\\gc.h\"\\\n+\t\".\\include\\private\\gc_hdrs.h\"\\\n+\t\".\\include\\private\\gc_priv.h\"\\\n \t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n \t\n NODEP_CPP_NEW_H=\\\n@@ -1278,10 +1341,10 @@ NODEP_CPP_NEW_H=\\\n !ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n \n DEP_CPP_NEW_H=\\\n-\t\".\\gcconfig.h\"\\\n-\t\".\\gc.h\"\\\n-\t\".\\gc_hdrs.h\"\\\n-\t\".\\gc_priv.h\"\\\n+\t\".\\include\\private\\gcconfig.h\"\\\n+\t\".\\include\\gc.h\"\\\n+\t\".\\include\\private\\gc_hdrs.h\"\\\n+\t\".\\include\\private\\gc_priv.h\"\\\n \t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n \t\n NODEP_CPP_NEW_H=\\\n@@ -1306,11 +1369,12 @@ SOURCE=.\\mark.c\n !IF  \"$(CFG)\" == \"gc - Win32 Release\"\n \n DEP_CPP_MARK_C=\\\n-\t\".\\gcconfig.h\"\\\n-\t\".\\gc.h\"\\\n-\t\".\\gc_hdrs.h\"\\\n-\t\".\\gc_mark.h\"\\\n-\t\".\\gc_priv.h\"\\\n+\t\".\\include\\private\\gcconfig.h\"\\\n+\t\".\\include\\gc.h\"\\\n+\t\".\\include\\private\\gc_hdrs.h\"\\\n+\t\".\\include\\private\\gc_pmark.h\"\\\n+\t\".\\include\\gc_mark.h\"\\\n+\t\".\\include\\private\\gc_priv.h\"\\\n \t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n \t\n NODEP_CPP_MARK_C=\\\n@@ -1327,11 +1391,12 @@ NODEP_CPP_MARK_C=\\\n !ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n \n DEP_CPP_MARK_C=\\\n-\t\".\\gcconfig.h\"\\\n-\t\".\\gc.h\"\\\n-\t\".\\gc_hdrs.h\"\\\n-\t\".\\gc_mark.h\"\\\n-\t\".\\gc_priv.h\"\\\n+\t\".\\include\\private\\gcconfig.h\"\\\n+\t\".\\include\\gc.h\"\\\n+\t\".\\include\\private\\gc_hdrs.h\"\\\n+\t\".\\include\\private\\gc_pmark.h\"\\\n+\t\".\\include\\gc_mark.h\"\\\n+\t\".\\include\\private\\gc_priv.h\"\\\n \t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n \t\n NODEP_CPP_MARK_C=\\\n@@ -1356,10 +1421,10 @@ SOURCE=.\\malloc.c\n !IF  \"$(CFG)\" == \"gc - Win32 Release\"\n \n DEP_CPP_MALLO=\\\n-\t\".\\gcconfig.h\"\\\n-\t\".\\gc.h\"\\\n-\t\".\\gc_hdrs.h\"\\\n-\t\".\\gc_priv.h\"\\\n+\t\".\\include\\private\\gcconfig.h\"\\\n+\t\".\\include\\gc.h\"\\\n+\t\".\\include\\private\\gc_hdrs.h\"\\\n+\t\".\\include\\private\\gc_priv.h\"\\\n \t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n \t\n NODEP_CPP_MALLO=\\\n@@ -1376,10 +1441,10 @@ NODEP_CPP_MALLO=\\\n !ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n \n DEP_CPP_MALLO=\\\n-\t\".\\gcconfig.h\"\\\n-\t\".\\gc.h\"\\\n-\t\".\\gc_hdrs.h\"\\\n-\t\".\\gc_priv.h\"\\\n+\t\".\\include\\private\\gcconfig.h\"\\\n+\t\".\\include\\gc.h\"\\\n+\t\".\\include\\private\\gc_hdrs.h\"\\\n+\t\".\\include\\private\\gc_priv.h\"\\\n \t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n \t\n NODEP_CPP_MALLO=\\\n@@ -1404,10 +1469,10 @@ SOURCE=.\\mallocx.c\n !IF  \"$(CFG)\" == \"gc - Win32 Release\"\n \n DEP_CPP_MALLX=\\\n-\t\".\\gcconfig.h\"\\\n-\t\".\\gc.h\"\\\n-\t\".\\gc_hdrs.h\"\\\n-\t\".\\gc_priv.h\"\\\n+\t\".\\include\\private\\gcconfig.h\"\\\n+\t\".\\include\\gc.h\"\\\n+\t\".\\include\\private\\gc_hdrs.h\"\\\n+\t\".\\include\\private\\gc_priv.h\"\\\n \t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n \t\n NODEP_CPP_MALLX=\\\n@@ -1424,10 +1489,10 @@ NODEP_CPP_MALLX=\\\n !ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n \n DEP_CPP_MALLX=\\\n-\t\".\\gcconfig.h\"\\\n-\t\".\\gc.h\"\\\n-\t\".\\gc_hdrs.h\"\\\n-\t\".\\gc_priv.h\"\\\n+\t\".\\include\\private\\gcconfig.h\"\\\n+\t\".\\include\\gc.h\"\\\n+\t\".\\include\\private\\gc_hdrs.h\"\\\n+\t\".\\include\\private\\gc_priv.h\"\\\n \t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n \t\n NODEP_CPP_MALLX=\\\n@@ -1452,11 +1517,12 @@ SOURCE=.\\finalize.c\n !IF  \"$(CFG)\" == \"gc - Win32 Release\"\n \n DEP_CPP_FINAL=\\\n-\t\".\\gcconfig.h\"\\\n-\t\".\\gc.h\"\\\n-\t\".\\gc_hdrs.h\"\\\n-\t\".\\gc_mark.h\"\\\n-\t\".\\gc_priv.h\"\\\n+\t\".\\include\\private\\gcconfig.h\"\\\n+\t\".\\include\\gc.h\"\\\n+\t\".\\include\\private\\gc_hdrs.h\"\\\n+\t\".\\include\\private\\gc_pmark.h\"\\\n+\t\".\\include\\gc_mark.h\"\\\n+\t\".\\include\\private\\gc_priv.h\"\\\n \t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n \t\n NODEP_CPP_FINAL=\\\n@@ -1473,11 +1539,12 @@ NODEP_CPP_FINAL=\\\n !ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n \n DEP_CPP_FINAL=\\\n-\t\".\\gcconfig.h\"\\\n-\t\".\\gc.h\"\\\n-\t\".\\gc_hdrs.h\"\\\n-\t\".\\gc_mark.h\"\\\n-\t\".\\gc_priv.h\"\\\n+\t\".\\include\\private\\gcconfig.h\"\\\n+\t\".\\include\\gc.h\"\\\n+\t\".\\include\\private\\gc_hdrs.h\"\\\n+\t\".\\include\\private\\gc_pmark.h\"\\\n+\t\".\\include\\gc_mark.h\"\\\n+\t\".\\include\\private\\gc_priv.h\"\\\n \t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n \t\n NODEP_CPP_FINAL=\\\n@@ -1502,10 +1569,10 @@ SOURCE=.\\dbg_mlc.c\n !IF  \"$(CFG)\" == \"gc - Win32 Release\"\n \n DEP_CPP_DBG_M=\\\n-\t\".\\gcconfig.h\"\\\n-\t\".\\gc.h\"\\\n-\t\".\\gc_hdrs.h\"\\\n-\t\".\\gc_priv.h\"\\\n+\t\".\\include\\private\\gcconfig.h\"\\\n+\t\".\\include\\gc.h\"\\\n+\t\".\\include\\private\\gc_hdrs.h\"\\\n+\t\".\\include\\private\\gc_priv.h\"\\\n \t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n \t\n NODEP_CPP_DBG_M=\\\n@@ -1522,10 +1589,10 @@ NODEP_CPP_DBG_M=\\\n !ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n \n DEP_CPP_DBG_M=\\\n-\t\".\\gcconfig.h\"\\\n-\t\".\\gc.h\"\\\n-\t\".\\gc_hdrs.h\"\\\n-\t\".\\gc_priv.h\"\\\n+\t\".\\include\\private\\gcconfig.h\"\\\n+\t\".\\include\\gc.h\"\\\n+\t\".\\include\\private\\gc_hdrs.h\"\\\n+\t\".\\include\\private\\gc_priv.h\"\\\n \t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n \t\n NODEP_CPP_DBG_M=\\\n@@ -1550,10 +1617,10 @@ SOURCE=.\\blacklst.c\n !IF  \"$(CFG)\" == \"gc - Win32 Release\"\n \n DEP_CPP_BLACK=\\\n-\t\".\\gcconfig.h\"\\\n-\t\".\\gc.h\"\\\n-\t\".\\gc_hdrs.h\"\\\n-\t\".\\gc_priv.h\"\\\n+\t\".\\include\\private\\gcconfig.h\"\\\n+\t\".\\include\\gc.h\"\\\n+\t\".\\include\\private\\gc_hdrs.h\"\\\n+\t\".\\include\\private\\gc_priv.h\"\\\n \t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n \t\n NODEP_CPP_BLACK=\\\n@@ -1570,10 +1637,10 @@ NODEP_CPP_BLACK=\\\n !ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n \n DEP_CPP_BLACK=\\\n-\t\".\\gcconfig.h\"\\\n-\t\".\\gc.h\"\\\n-\t\".\\gc_hdrs.h\"\\\n-\t\".\\gc_priv.h\"\\\n+\t\".\\include\\private\\gcconfig.h\"\\\n+\t\".\\include\\gc.h\"\\\n+\t\".\\include\\private\\gc_hdrs.h\"\\\n+\t\".\\include\\private\\gc_priv.h\"\\\n \t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n \t\n NODEP_CPP_BLACK=\\\n@@ -1598,12 +1665,13 @@ SOURCE=.\\typd_mlc.c\n !IF  \"$(CFG)\" == \"gc - Win32 Release\"\n \n DEP_CPP_TYPD_=\\\n-\t\".\\gcconfig.h\"\\\n-\t\".\\gc.h\"\\\n-\t\".\\gc_hdrs.h\"\\\n-\t\".\\gc_mark.h\"\\\n-\t\".\\gc_priv.h\"\\\n-\t\".\\gc_typed.h\"\\\n+\t\".\\include\\private\\gcconfig.h\"\\\n+\t\".\\include\\gc.h\"\\\n+\t\".\\include\\private\\gc_hdrs.h\"\\\n+\t\".\\include\\private\\gc_pmark.h\"\\\n+\t\".\\include\\gc_mark.h\"\\\n+\t\".\\include\\private\\gc_priv.h\"\\\n+\t\".\\include\\gc_typed.h\"\\\n \t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n \t\n NODEP_CPP_TYPD_=\\\n@@ -1620,12 +1688,13 @@ NODEP_CPP_TYPD_=\\\n !ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n \n DEP_CPP_TYPD_=\\\n-\t\".\\gcconfig.h\"\\\n-\t\".\\gc.h\"\\\n-\t\".\\gc_hdrs.h\"\\\n-\t\".\\gc_mark.h\"\\\n-\t\".\\gc_priv.h\"\\\n-\t\".\\gc_typed.h\"\\\n+\t\".\\include\\private\\gcconfig.h\"\\\n+\t\".\\include\\gc.h\"\\\n+\t\".\\include\\private\\gc_hdrs.h\"\\\n+\t\".\\include\\private\\gc_pmark.h\"\\\n+\t\".\\include\\gc_mark.h\"\\\n+\t\".\\include\\private\\gc_priv.h\"\\\n+\t\".\\include\\gc_typed.h\"\\\n \t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n \t\n NODEP_CPP_TYPD_=\\\n@@ -1650,11 +1719,12 @@ SOURCE=.\\ptr_chck.c\n !IF  \"$(CFG)\" == \"gc - Win32 Release\"\n \n DEP_CPP_PTR_C=\\\n-\t\".\\gcconfig.h\"\\\n-\t\".\\gc.h\"\\\n-\t\".\\gc_hdrs.h\"\\\n-\t\".\\gc_mark.h\"\\\n-\t\".\\gc_priv.h\"\\\n+\t\".\\include\\private\\gcconfig.h\"\\\n+\t\".\\include\\gc.h\"\\\n+\t\".\\include\\private\\gc_hdrs.h\"\\\n+\t\".\\include\\private\\gc_pmark.h\"\\\n+\t\".\\include\\gc_mark.h\"\\\n+\t\".\\include\\private\\gc_priv.h\"\\\n \t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n \t\n NODEP_CPP_PTR_C=\\\n@@ -1671,11 +1741,12 @@ NODEP_CPP_PTR_C=\\\n !ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n \n DEP_CPP_PTR_C=\\\n-\t\".\\gcconfig.h\"\\\n-\t\".\\gc.h\"\\\n-\t\".\\gc_hdrs.h\"\\\n-\t\".\\gc_mark.h\"\\\n-\t\".\\gc_priv.h\"\\\n+\t\".\\include\\private\\gcconfig.h\"\\\n+\t\".\\include\\gc.h\"\\\n+\t\".\\include\\private\\gc_hdrs.h\"\\\n+\t\".\\include\\private\\gc_pmark.h\"\\\n+\t\".\\include\\gc_mark.h\"\\\n+\t\".\\include\\private\\gc_priv.h\"\\\n \t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n \t\n NODEP_CPP_PTR_C=\\\n@@ -1700,10 +1771,10 @@ SOURCE=.\\dyn_load.c\n !IF  \"$(CFG)\" == \"gc - Win32 Release\"\n \n DEP_CPP_DYN_L=\\\n-\t\".\\gcconfig.h\"\\\n-\t\".\\gc.h\"\\\n-\t\".\\gc_hdrs.h\"\\\n-\t\".\\gc_priv.h\"\\\n+\t\".\\include\\private\\gcconfig.h\"\\\n+\t\".\\include\\gc.h\"\\\n+\t\".\\include\\private\\gc_hdrs.h\"\\\n+\t\".\\include\\private\\gc_priv.h\"\\\n \t{$(INCLUDE)}\"\\sys\\STAT.H\"\\\n \t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n \t\n@@ -1723,10 +1794,10 @@ NODEP_CPP_DYN_L=\\\n !ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n \n DEP_CPP_DYN_L=\\\n-\t\".\\gcconfig.h\"\\\n-\t\".\\gc.h\"\\\n-\t\".\\gc_hdrs.h\"\\\n-\t\".\\gc_priv.h\"\\\n+\t\".\\include\\private\\gcconfig.h\"\\\n+\t\".\\include\\gc.h\"\\\n+\t\".\\include\\private\\gc_hdrs.h\"\\\n+\t\".\\include\\private\\gc_priv.h\"\\\n \t{$(INCLUDE)}\"\\sys\\STAT.H\"\\\n \t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n \t\n@@ -1754,10 +1825,10 @@ SOURCE=.\\win32_threads.c\n !IF  \"$(CFG)\" == \"gc - Win32 Release\"\n \n DEP_CPP_WIN32=\\\n-\t\".\\gcconfig.h\"\\\n-\t\".\\gc.h\"\\\n-\t\".\\gc_hdrs.h\"\\\n-\t\".\\gc_priv.h\"\\\n+\t\".\\include\\private\\gcconfig.h\"\\\n+\t\".\\include\\gc.h\"\\\n+\t\".\\include\\private\\gc_hdrs.h\"\\\n+\t\".\\include\\private\\gc_priv.h\"\\\n \t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n \t\n NODEP_CPP_WIN32=\\\n@@ -1774,10 +1845,10 @@ NODEP_CPP_WIN32=\\\n !ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n \n DEP_CPP_WIN32=\\\n-\t\".\\gcconfig.h\"\\\n-\t\".\\gc.h\"\\\n-\t\".\\gc_hdrs.h\"\\\n-\t\".\\gc_priv.h\"\\\n+\t\".\\include\\private\\gcconfig.h\"\\\n+\t\".\\include\\gc.h\"\\\n+\t\".\\include\\private\\gc_hdrs.h\"\\\n+\t\".\\include\\private\\gc_priv.h\"\\\n \t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n \t\n NODEP_CPP_WIN32=\\\n@@ -1802,10 +1873,10 @@ SOURCE=.\\checksums.c\n !IF  \"$(CFG)\" == \"gc - Win32 Release\"\n \n DEP_CPP_CHECK=\\\n-\t\".\\gcconfig.h\"\\\n-\t\".\\gc.h\"\\\n-\t\".\\gc_hdrs.h\"\\\n-\t\".\\gc_priv.h\"\\\n+\t\".\\include\\private\\gcconfig.h\"\\\n+\t\".\\include\\gc.h\"\\\n+\t\".\\include\\private\\gc_hdrs.h\"\\\n+\t\".\\include\\private\\gc_priv.h\"\\\n \t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n \t\n NODEP_CPP_CHECK=\\\n@@ -1822,10 +1893,10 @@ NODEP_CPP_CHECK=\\\n !ELSEIF  \"$(CFG)\" == \"gc - Win32 Debug\"\n \n DEP_CPP_CHECK=\\\n-\t\".\\gcconfig.h\"\\\n-\t\".\\gc.h\"\\\n-\t\".\\gc_hdrs.h\"\\\n-\t\".\\gc_priv.h\"\\\n+\t\".\\include\\private\\gcconfig.h\"\\\n+\t\".\\include\\gc.h\"\\\n+\t\".\\include\\private\\gc_hdrs.h\"\\\n+\t\".\\include\\private\\gc_priv.h\"\\\n \t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n \t\n NODEP_CPP_CHECK=\\\n@@ -1876,13 +1947,13 @@ NODEP_CPP_CHECK=\\\n ################################################################################\n # Begin Source File\n \n-SOURCE=.\\test.c\n+SOURCE=.\\tests\\test.c\n DEP_CPP_TEST_=\\\n-\t\".\\gcconfig.h\"\\\n-\t\".\\gc.h\"\\\n-\t\".\\gc_hdrs.h\"\\\n-\t\".\\gc_priv.h\"\\\n-\t\".\\gc_typed.h\"\\\n+\t\".\\include\\private\\gcconfig.h\"\\\n+\t\".\\include\\gc.h\"\\\n+\t\".\\include\\private\\gc_hdrs.h\"\\\n+\t\".\\include\\private\\gc_priv.h\"\\\n+\t\".\\include\\gc_typed.h\"\\\n \t{$(INCLUDE)}\"\\sys\\TYPES.H\"\\\n \t\n NODEP_CPP_TEST_=\\\n@@ -1944,13 +2015,13 @@ NODEP_CPP_TEST_=\\\n \n SOURCE=.\\cord\\de_win.c\n DEP_CPP_DE_WI=\\\n-\t\".\\cord\\cord.h\"\\\n+\t\".\\include\\cord.h\"\\\n \t\".\\cord\\de_cmds.h\"\\\n \t\".\\cord\\de_win.h\"\\\n-\t\".\\cord\\private\\cord_pos.h\"\\\n+\t\".\\include\\private\\cord_pos.h\"\\\n \t\n NODEP_CPP_DE_WI=\\\n-\t\".\\cord\\gc.h\"\\\n+\t\".\\include\\gc.h\"\\\n \t\n \n !IF  \"$(CFG)\" == \"cord - Win32 Release\"\n@@ -1975,13 +2046,13 @@ NODEP_CPP_DE_WI=\\\n \n SOURCE=.\\cord\\de.c\n DEP_CPP_DE_C2e=\\\n-\t\".\\cord\\cord.h\"\\\n+\t\".\\include\\cord.h\"\\\n \t\".\\cord\\de_cmds.h\"\\\n \t\".\\cord\\de_win.h\"\\\n-\t\".\\cord\\private\\cord_pos.h\"\\\n+\t\".\\include\\private\\cord_pos.h\"\\\n \t\n NODEP_CPP_DE_C2e=\\\n-\t\".\\cord\\gc.h\"\\\n+\t\".\\include\\gc.h\"\\\n \t\n \n !IF  \"$(CFG)\" == \"cord - Win32 Release\"\n@@ -2006,12 +2077,12 @@ NODEP_CPP_DE_C2e=\\\n \n SOURCE=.\\cord\\cordxtra.c\n DEP_CPP_CORDX=\\\n-\t\".\\cord\\cord.h\"\\\n-\t\".\\cord\\ec.h\"\\\n-\t\".\\cord\\private\\cord_pos.h\"\\\n+\t\".\\include\\cord.h\"\\\n+\t\".\\include\\ec.h\"\\\n+\t\".\\include\\private\\cord_pos.h\"\\\n \t\n NODEP_CPP_CORDX=\\\n-\t\".\\cord\\gc.h\"\\\n+\t\".\\include\\gc.h\"\\\n \t\n \n !IF  \"$(CFG)\" == \"cord - Win32 Release\"\n@@ -2036,11 +2107,11 @@ NODEP_CPP_CORDX=\\\n \n SOURCE=.\\cord\\cordbscs.c\n DEP_CPP_CORDB=\\\n-\t\".\\cord\\cord.h\"\\\n-\t\".\\cord\\private\\cord_pos.h\"\\\n+\t\".\\include\\cord.h\"\\\n+\t\".\\include\\private\\cord_pos.h\"\\\n \t\n NODEP_CPP_CORDB=\\\n-\t\".\\cord\\gc.h\"\\\n+\t\".\\include\\gc.h\"\\\n \t\n \n !IF  \"$(CFG)\" == \"cord - Win32 Release\""}, {"sha": "5409e7065502e877616da445048632efbb23be78", "filename": "boehm-gc/gc.man", "status": "removed", "additions": 0, "deletions": 80, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6951ca5dee8ed05749cdc697767910aebaedcc0/boehm-gc%2Fgc.man", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6951ca5dee8ed05749cdc697767910aebaedcc0/boehm-gc%2Fgc.man", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fgc.man?ref=a6951ca5dee8ed05749cdc697767910aebaedcc0", "patch": "@@ -1,80 +0,0 @@\n-.TH GC_MALLOC 1L \"12 February 1996\"\n-.SH NAME\n-GC_malloc, GC_malloc_atomic, GC_free, GC_realloc, GC_enable_incremental, GC_register_finalizer, GC_malloc_ignore_off_page, GC_malloc_atomic_ignore_off_page, GC_set_warn_proc \\- Garbage collecting malloc replacement\n-.SH SYNOPSIS\n-#include \"gc.h\"\n-.br\n-# define malloc(n) GC_malloc(n)\n-.br\n-... malloc(...) ...\n-.br\n-.sp\n-cc ... gc.a\n-.LP\n-.SH DESCRIPTION\n-.I GC_malloc\n-and\n-.I GC_free\n-are plug-in replacements for standard malloc and free.  However,\n-.I\n-GC_malloc\n-will attempt to reclaim inaccessible space automatically by invoking a conservative garbage collector at appropriate points.  The collector traverses all data structures accessible by following pointers from the machines registers, stack(s), data, and bss segments.  Inaccessible structures will be reclaimed.  A machine word is considered to be a valid pointer if it is an address inside an object allocated by\n-.I\n-GC_malloc\n-or friends.\n-.LP\n-See the documentation in the include file gc_cpp.h for an alternate, C++ specific interface to the garbage collector.\n-.LP\n-Unlike the standard implementations of malloc,\n-.I\n-GC_malloc\n-clears the newly allocated storage.\n-.I\n-GC_malloc_atomic\n-does not.  Furthermore, it informs the collector that the resulting object will never contain any pointers, and should therefore not be scanned by the collector.\n-.LP\n-.I\n-GC_free\n-can be used to deallocate objects, but its use is optional, and generally discouraged.\n-.I\n-GC_realloc\n-has the standard realloc semantics.  It preserves pointer-free-ness.\n-.I\n-GC_register_finalizer\n-allows for registration of functions that are invoked when an object becomes inaccessible.\n-.LP\n-The garbage collector tries to avoid allocating memory at locations that already appear to be referenced before allocation.  (Such apparent ``pointers'' are usually large integers and the like that just happen to look like an address.)  This may make it hard to allocate very large objects.  An attempt to do so may generate a warning.\n-.LP\n-.I\n-GC_malloc_ignore_off_page\n-and\n-.I\n-GC_malloc_atomic_ignore_off_page\n-inform the collector that the client code will always maintain a pointer to near the beginning of the object (within the first 512 bytes), and that pointers beyond that can be ignored by the collector.  This makes it much easier for the collector to place large objects.  These are recommended for large object allocation.  (Objects expected to be larger than about 100KBytes should be allocated this way.)\n-.LP\n-It is also possible to use the collector to find storage leaks in programs destined to be run with standard malloc/free.  The collector can be compiled for thread-safe operation.  Unlike standard malloc, it is safe to call malloc after a previous malloc call was interrupted by a signal, provided the original malloc call is not resumed.\n-.LP\n-The collector may, on rare occasion produce warning messages.  On UNIX machines these appear on stderr.  Warning messages can be filtered, redirected, or ignored with\n-.I\n-GC_set_warn_proc.\n-This is recommended for production code.  See gc.h for details.\n-.LP\n-Debugging versions of many of the above routines are provided as macros.  Their names are identical to the above, but consist of all capital letters.  If GC_DEBUG is defined before gc.h is included, these routines do additional checking, and allow the leak detecting version of the collector to produce slightly more useful output.  Without GC_DEBUG defined, they behave exactly like the lower-case versions.\n-.LP\n-On some machines, collection will be performed incrementally after a call to\n-.I\n-GC_enable_incremental.\n-This may temporarily write protect pages in the heap.  See the README file for more information on how this interacts with system calls that write to the heap.\n-.LP\n-Other facilities not discussed here include limited facilities to support incremental collection on machines without appropriate VM support, provisions for providing more explicit object layout information to the garbage collector, more direct support for ``weak'' pointers, support for ``abortable'' garbage collections during idle time, etc.\n-.LP\n-.SH \"SEE ALSO\"\n-The README and gc.h files in the distribution.  More detailed definitions of the functions exported by the collector are given there.  (The above list is not complete.)\n-.LP\n-Boehm, H., and M. Weiser, \"Garbage Collection in an Uncooperative Environment\",\n-\\fISoftware Practice & Experience\\fP, September 1988, pp. 807-820.\n-.LP\n-The malloc(3) man page.\n-.LP\n-.SH AUTHOR\n-Hans-J. Boehm (boehm@parc.xerox.com).  Some of the code was written by others, most notably Alan Demers."}, {"sha": "1f1d54aff95608531e53fb5f30bf5d1a1da18130", "filename": "boehm-gc/gc_alloc.h", "status": "removed", "additions": 0, "deletions": 380, "changes": 380, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6951ca5dee8ed05749cdc697767910aebaedcc0/boehm-gc%2Fgc_alloc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6951ca5dee8ed05749cdc697767910aebaedcc0/boehm-gc%2Fgc_alloc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fgc_alloc.h?ref=a6951ca5dee8ed05749cdc697767910aebaedcc0", "patch": "@@ -1,380 +0,0 @@\n-/*\n- * Copyright (c) 1996-1998 by Silicon Graphics.  All rights reserved.\n- *\n- * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n- * OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n- *\n- * Permission is hereby granted to use or copy this program\n- * for any purpose,  provided the above notices are retained on all copies.\n- * Permission to modify the code and to distribute modified code is granted,\n- * provided the above notices are retained, and a notice that the code was\n- * modified is included with the above copyright notice.\n- */\n-\n-//\n-// This is a C++ header file that is intended to replace the SGI STL\n-// alloc.h.  This assumes SGI STL version < 3.0.\n-//\n-// This assumes the collector has been compiled with -DATOMIC_UNCOLLECTABLE\n-// and -DALL_INTERIOR_POINTERS.  We also recommend\n-// -DREDIRECT_MALLOC=GC_uncollectable_malloc.\n-//\n-// Some of this could be faster in the explicit deallocation case.  In particular,\n-// we spend too much time clearing objects on the free lists.  That could be avoided.\n-//\n-// This uses template classes with static members, and hence does not work\n-// with g++ 2.7.2 and earlier.\n-//\n-\n-#include \"gc.h\"\n-\n-#ifndef GC_ALLOC_H\n-\n-#define GC_ALLOC_H\n-#define __ALLOC_H\t// Prevent inclusion of the default version.  Ugly.\n-#define __SGI_STL_ALLOC_H\n-#define __SGI_STL_INTERNAL_ALLOC_H\n-\n-#ifndef __ALLOC\n-#   define __ALLOC alloc\n-#endif\n-\n-#include <stddef.h>\n-#include <string.h>\n-\n-// The following is just replicated from the conventional SGI alloc.h:\n-\n-template<class T, class alloc>\n-class simple_alloc {\n-\n-public:\n-    static T *allocate(size_t n)\n-                { return 0 == n? 0 : (T*) alloc::allocate(n * sizeof (T)); }\n-    static T *allocate(void)\n-                { return (T*) alloc::allocate(sizeof (T)); }\n-    static void deallocate(T *p, size_t n)\n-                { if (0 != n) alloc::deallocate(p, n * sizeof (T)); }\n-    static void deallocate(T *p)\n-                { alloc::deallocate(p, sizeof (T)); }\n-};\n-\n-#include \"gc.h\"\n-\n-// The following need to match collector data structures.\n-// We can't include gc_priv.h, since that pulls in way too much stuff.\n-// This should eventually be factored out into another include file.\n-\n-extern \"C\" {\n-    extern void ** const GC_objfreelist_ptr;\n-    extern void ** const GC_aobjfreelist_ptr;\n-    extern void ** const GC_uobjfreelist_ptr;\n-    extern void ** const GC_auobjfreelist_ptr;\n-\n-    extern void GC_incr_words_allocd(size_t words);\n-    extern void GC_incr_mem_freed(size_t words);\n-\n-    extern char * GC_generic_malloc_words_small(size_t word, int kind);\n-}\n-\n-// Object kinds; must match PTRFREE, NORMAL, UNCOLLECTABLE, and\n-// AUNCOLLECTABLE in gc_priv.h.\n-\n-enum { GC_PTRFREE = 0, GC_NORMAL = 1, GC_UNCOLLECTABLE = 2,\n-       GC_AUNCOLLECTABLE = 3 };\n-\n-enum { GC_max_fast_bytes = 255 };\n-\n-enum { GC_bytes_per_word = sizeof(char *) };\n-\n-enum { GC_byte_alignment = 8 };\n-\n-enum { GC_word_alignment = GC_byte_alignment/GC_bytes_per_word };\n-\n-inline void * &GC_obj_link(void * p)\n-{   return *(void **)p;  }\n-\n-// Compute a number of words >= n+1 bytes.\n-// The +1 allows for pointers one past the end.\n-inline size_t GC_round_up(size_t n)\n-{\n-    return ((n + GC_byte_alignment)/GC_byte_alignment)*GC_word_alignment;\n-}\n-\n-// The same but don't allow for extra byte.\n-inline size_t GC_round_up_uncollectable(size_t n)\n-{\n-    return ((n + GC_byte_alignment - 1)/GC_byte_alignment)*GC_word_alignment;\n-}\n-\n-template <int dummy>\n-class GC_aux_template {\n-public:\n-  // File local count of allocated words.  Occasionally this is\n-  // added into the global count.  A separate count is necessary since the\n-  // real one must be updated with a procedure call.\n-  static size_t GC_words_recently_allocd;\n-\n-  // Same for uncollectable mmory.  Not yet reflected in either\n-  // GC_words_recently_allocd or GC_non_gc_bytes.\n-  static size_t GC_uncollectable_words_recently_allocd;\n-\n-  // Similar counter for explicitly deallocated memory.\n-  static size_t GC_mem_recently_freed;\n-\n-  // Again for uncollectable memory.\n-  static size_t GC_uncollectable_mem_recently_freed;\n-\n-  static void * GC_out_of_line_malloc(size_t nwords, int kind);\n-};\n-\n-template <int dummy>\n-size_t GC_aux_template<dummy>::GC_words_recently_allocd = 0;\n-\n-template <int dummy>\n-size_t GC_aux_template<dummy>::GC_uncollectable_words_recently_allocd = 0;\n-\n-template <int dummy>\n-size_t GC_aux_template<dummy>::GC_mem_recently_freed = 0;\n-\n-template <int dummy>\n-size_t GC_aux_template<dummy>::GC_uncollectable_mem_recently_freed = 0;\n-\n-template <int dummy>\n-void * GC_aux_template<dummy>::GC_out_of_line_malloc(size_t nwords, int kind)\n-{\n-    GC_words_recently_allocd += GC_uncollectable_words_recently_allocd;\n-    GC_non_gc_bytes +=\n-                GC_bytes_per_word * GC_uncollectable_words_recently_allocd;\n-    GC_uncollectable_words_recently_allocd = 0;\n-\n-    GC_mem_recently_freed += GC_uncollectable_mem_recently_freed;\n-    GC_non_gc_bytes -= \n-                GC_bytes_per_word * GC_uncollectable_mem_recently_freed;\n-    GC_uncollectable_mem_recently_freed = 0;\n-\n-    GC_incr_words_allocd(GC_words_recently_allocd);\n-    GC_words_recently_allocd = 0;\n-\n-    GC_incr_mem_freed(GC_mem_recently_freed);\n-    GC_mem_recently_freed = 0;\n-\n-    return GC_generic_malloc_words_small(nwords, kind);\n-}\n-\n-typedef GC_aux_template<0> GC_aux;\n-\n-// A fast, single-threaded, garbage-collected allocator\n-// We assume the first word will be immediately overwritten.\n-// In this version, deallocation is not a noop, and explicit\n-// deallocation is likely to help performance.\n-template <int dummy>\n-class single_client_gc_alloc_template {\n-    public:\n-     \tstatic void * allocate(size_t n)\n-        {\n-\t    size_t nwords = GC_round_up(n);\n-\t    void ** flh;\n-\t    void * op;\n-\n-  \t    if (n > GC_max_fast_bytes) return GC_malloc(n);\n-\t    flh = GC_objfreelist_ptr + nwords;\n-\t    if (0 == (op = *flh)) {\n-\t\treturn GC_aux::GC_out_of_line_malloc(nwords, GC_NORMAL);\n-\t    }\n-\t    *flh = GC_obj_link(op);\n-\t    GC_aux::GC_words_recently_allocd += nwords;\n-\t    return op;\n-        }\n-     \tstatic void * ptr_free_allocate(size_t n)\n-        {\n-\t    size_t nwords = GC_round_up(n);\n-\t    void ** flh;\n-\t    void * op;\n-\n-  \t    if (n > GC_max_fast_bytes) return GC_malloc_atomic(n);\n-\t    flh = GC_aobjfreelist_ptr + nwords;\n-\t    if (0 == (op = *flh)) {\n-\t\treturn GC_aux::GC_out_of_line_malloc(nwords, GC_PTRFREE);\n-\t    }\n-\t    *flh = GC_obj_link(op);\n-\t    GC_aux::GC_words_recently_allocd += nwords;\n-\t    return op;\n-        }\n-\tstatic void deallocate(void *p, size_t n)\n-\t{\n-            size_t nwords = GC_round_up(n);\n-            void ** flh;\n-\t   \n-\t    if (n > GC_max_fast_bytes)  {\n-\t\tGC_free(p);\n-\t    } else {\n-\t        flh = GC_objfreelist_ptr + nwords;\n-\t        GC_obj_link(p) = *flh;\n-\t\tmemset((char *)p + GC_bytes_per_word, 0,\n-\t\t       GC_bytes_per_word * (nwords - 1));\n-\t        *flh = p;\n-\t        GC_aux::GC_mem_recently_freed += nwords;\n-\t    }\n-\t}\n-\tstatic void ptr_free_deallocate(void *p, size_t n)\n-\t{\n-            size_t nwords = GC_round_up(n);\n-            void ** flh;\n-\t   \n-\t    if (n > GC_max_fast_bytes) {\n-\t\tGC_free(p);\n-\t    } else {\n-\t    \tflh = GC_aobjfreelist_ptr + nwords;\n-\t    \tGC_obj_link(p) = *flh;\n-\t    \t*flh = p;\n-\t    \tGC_aux::GC_mem_recently_freed += nwords;\n-\t    }\n-\t}\n-};\n-\n-typedef single_client_gc_alloc_template<0> single_client_gc_alloc;\n-\n-// Once more, for uncollectable objects.\n-template <int dummy>\n-class single_client_alloc_template {\n-    public:\n-     \tstatic void * allocate(size_t n)\n-        {\n-\t    size_t nwords = GC_round_up_uncollectable(n);\n-\t    void ** flh;\n-\t    void * op;\n-\n-  \t    if (n > GC_max_fast_bytes) return GC_malloc_uncollectable(n);\n-\t    flh = GC_uobjfreelist_ptr + nwords;\n-\t    if (0 == (op = *flh)) {\n-\t\treturn GC_aux::GC_out_of_line_malloc(nwords, GC_UNCOLLECTABLE);\n-\t    }\n-\t    *flh = GC_obj_link(op);\n-\t    GC_aux::GC_uncollectable_words_recently_allocd += nwords;\n-\t    return op;\n-        }\n-     \tstatic void * ptr_free_allocate(size_t n)\n-        {\n-\t    size_t nwords = GC_round_up_uncollectable(n);\n-\t    void ** flh;\n-\t    void * op;\n-\n-  \t    if (n > GC_max_fast_bytes) return GC_malloc_atomic_uncollectable(n);\n-\t    flh = GC_auobjfreelist_ptr + nwords;\n-\t    if (0 == (op = *flh)) {\n-\t\treturn GC_aux::GC_out_of_line_malloc(nwords, GC_AUNCOLLECTABLE);\n-\t    }\n-\t    *flh = GC_obj_link(op);\n-\t    GC_aux::GC_uncollectable_words_recently_allocd += nwords;\n-\t    return op;\n-        }\n-\tstatic void deallocate(void *p, size_t n)\n-\t{\n-            size_t nwords = GC_round_up_uncollectable(n);\n-            void ** flh;\n-\t   \n-\t    if (n > GC_max_fast_bytes)  {\n-\t\tGC_free(p);\n-\t    } else {\n-\t        flh = GC_uobjfreelist_ptr + nwords;\n-\t        GC_obj_link(p) = *flh;\n-\t        *flh = p;\n-\t        GC_aux::GC_uncollectable_mem_recently_freed += nwords;\n-\t    }\n-\t}\n-\tstatic void ptr_free_deallocate(void *p, size_t n)\n-\t{\n-            size_t nwords = GC_round_up_uncollectable(n);\n-            void ** flh;\n-\t   \n-\t    if (n > GC_max_fast_bytes) {\n-\t\tGC_free(p);\n-\t    } else {\n-\t    \tflh = GC_auobjfreelist_ptr + nwords;\n-\t    \tGC_obj_link(p) = *flh;\n-\t    \t*flh = p;\n-\t    \tGC_aux::GC_uncollectable_mem_recently_freed += nwords;\n-\t    }\n-\t}\n-};\n-\n-typedef single_client_alloc_template<0> single_client_alloc;\n-\n-template < int dummy >\n-class gc_alloc_template {\n-    public:\n-     \tstatic void * allocate(size_t n) { return GC_malloc(n); }\n-     \tstatic void * ptr_free_allocate(size_t n)\n-\t\t{ return GC_malloc_atomic(n); }\n-\tstatic void deallocate(void *, size_t) { }\n-\tstatic void ptr_free_deallocate(void *, size_t) { }\n-};\n-\n-typedef gc_alloc_template < 0 > gc_alloc;\n-\n-template < int dummy >\n-class alloc_template {\n-    public:\n-     \tstatic void * allocate(size_t n) { return GC_malloc_uncollectable(n); }\n-     \tstatic void * ptr_free_allocate(size_t n)\n-\t\t{ return GC_malloc_atomic_uncollectable(n); }\n-\tstatic void deallocate(void *p, size_t) { GC_free(p); }\n-\tstatic void ptr_free_deallocate(void *p, size_t) { GC_free(p); }\n-};\n-\n-typedef alloc_template < 0 > alloc;\n-\n-#ifdef _SGI_SOURCE\n-\n-// We want to specialize simple_alloc so that it does the right thing\n-// for all pointerfree types.  At the moment there is no portable way to\n-// even approximate that.  The following approximation should work for\n-// SGI compilers, and perhaps some others.\n-\n-# define __GC_SPECIALIZE(T,alloc) \\\n-class simple_alloc<T, alloc> { \\\n-public: \\\n-    static T *allocate(size_t n) \\\n-\t{ return 0 == n? 0 : \\\n-\t\t\t (T*) alloc::ptr_free_allocate(n * sizeof (T)); } \\\n-    static T *allocate(void) \\\n-\t{ return (T*) alloc::ptr_free_allocate(sizeof (T)); } \\\n-    static void deallocate(T *p, size_t n) \\\n-\t{ if (0 != n) alloc::ptr_free_deallocate(p, n * sizeof (T)); } \\\n-    static void deallocate(T *p) \\\n-\t{ alloc::ptr_free_deallocate(p, sizeof (T)); } \\\n-};\n-\n-__GC_SPECIALIZE(char, gc_alloc)\n-__GC_SPECIALIZE(int, gc_alloc)\n-__GC_SPECIALIZE(unsigned, gc_alloc)\n-__GC_SPECIALIZE(float, gc_alloc)\n-__GC_SPECIALIZE(double, gc_alloc)\n-\n-__GC_SPECIALIZE(char, alloc)\n-__GC_SPECIALIZE(int, alloc)\n-__GC_SPECIALIZE(unsigned, alloc)\n-__GC_SPECIALIZE(float, alloc)\n-__GC_SPECIALIZE(double, alloc)\n-\n-__GC_SPECIALIZE(char, single_client_gc_alloc)\n-__GC_SPECIALIZE(int, single_client_gc_alloc)\n-__GC_SPECIALIZE(unsigned, single_client_gc_alloc)\n-__GC_SPECIALIZE(float, single_client_gc_alloc)\n-__GC_SPECIALIZE(double, single_client_gc_alloc)\n-\n-__GC_SPECIALIZE(char, single_client_alloc)\n-__GC_SPECIALIZE(int, single_client_alloc)\n-__GC_SPECIALIZE(unsigned, single_client_alloc)\n-__GC_SPECIALIZE(float, single_client_alloc)\n-__GC_SPECIALIZE(double, single_client_alloc)\n-\n-#ifdef __STL_USE_STD_ALLOCATORS\n-\n-???copy stuff from stl_alloc.h or remove it to a different file ???\n-\n-#endif /* __STL_USE_STD_ALLOCATORS */\n-\n-#endif /* _SGI_SOURCE */\n-\n-#endif /* GC_ALLOC_H */"}, {"sha": "a97091c817c9037d20f22a07ade12fb8ff2d3215", "filename": "boehm-gc/gc_cpp.cc", "status": "modified", "additions": 4, "deletions": 15, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9110a741e35c54e46c00662ddc420575376c5947/boehm-gc%2Fgc_cpp.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9110a741e35c54e46c00662ddc420575376c5947/boehm-gc%2Fgc_cpp.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fgc_cpp.cc?ref=9110a741e35c54e46c00662ddc420575376c5947", "patch": "@@ -26,27 +26,14 @@ Authors: John R. Ellis and Jesse Hull\n \n #include \"gc_cpp.h\"\n \n+#ifndef _MSC_VER\n+/* In the Visual C++ case, we moved this into the header. */\n void* operator new( size_t size ) {\n     return GC_MALLOC_UNCOLLECTABLE( size );}\n   \n void operator delete( void* obj ) {\n     GC_FREE( obj );}\n   \n-#ifdef _MSC_VER\n-// This new operator is used by VC++ in case of Debug builds !\n-void* operator new( size_t size,\n-                    int ,//nBlockUse,\n-                    const char * szFileName,\n-                    int nLine\n-                    ) {\n-# ifndef GC_DEBUG\n-    return GC_malloc_uncollectable( size );\n-# else\n-    return GC_debug_malloc_uncollectable(size, szFileName, nLine);\n-# endif\n-}\n-#endif\n-\n #ifdef OPERATOR_NEW_ARRAY\n \n void* operator new[]( size_t size ) {\n@@ -57,4 +44,6 @@ void operator delete[]( void* obj ) {\n \n #endif /* OPERATOR_NEW_ARRAY */\n \n+#endif /* _MSC_VER */\n+\n "}, {"sha": "35686fc3527af57465875082e58438afbb0b571e", "filename": "boehm-gc/gc_cpp.h", "status": "removed", "additions": 0, "deletions": 299, "changes": 299, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6951ca5dee8ed05749cdc697767910aebaedcc0/boehm-gc%2Fgc_cpp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6951ca5dee8ed05749cdc697767910aebaedcc0/boehm-gc%2Fgc_cpp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fgc_cpp.h?ref=a6951ca5dee8ed05749cdc697767910aebaedcc0", "patch": "@@ -1,299 +0,0 @@\n-#ifndef GC_CPP_H\n-#define GC_CPP_H\n-/****************************************************************************\n-Copyright (c) 1994 by Xerox Corporation.  All rights reserved.\n- \n-THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n-OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n- \n-Permission is hereby granted to use or copy this program for any\n-purpose, provided the above notices are retained on all copies.\n-Permission to modify the code and to distribute modified code is\n-granted, provided the above notices are retained, and a notice that\n-the code was modified is included with the above copyright notice.\n-****************************************************************************\n-\n-C++ Interface to the Boehm Collector\n-\n-    John R. Ellis and Jesse Hull \n-\n-This interface provides access to the Boehm collector.  It provides\n-basic facilities similar to those described in \"Safe, Efficient\n-Garbage Collection for C++\", by John R. Elis and David L. Detlefs\n-(ftp://ftp.parc.xerox.com/pub/ellis/gc).\n-\n-All heap-allocated objects are either \"collectable\" or\n-\"uncollectable\".  Programs must explicitly delete uncollectable\n-objects, whereas the garbage collector will automatically delete\n-collectable objects when it discovers them to be inaccessible.\n-Collectable objects may freely point at uncollectable objects and vice\n-versa.\n-\n-Objects allocated with the built-in \"::operator new\" are uncollectable.\n-\n-Objects derived from class \"gc\" are collectable.  For example:\n-\n-    class A: public gc {...};\n-    A* a = new A;       // a is collectable. \n-\n-Collectable instances of non-class types can be allocated using the GC\n-(or UseGC) placement:\n-\n-    typedef int A[ 10 ];\n-    A* a = new (GC) A;\n-\n-Uncollectable instances of classes derived from \"gc\" can be allocated\n-using the NoGC placement:\n-\n-    class A: public gc {...};\n-    A* a = new (NoGC) A;   // a is uncollectable.\n-\n-Both uncollectable and collectable objects can be explicitly deleted\n-with \"delete\", which invokes an object's destructors and frees its\n-storage immediately.\n-\n-A collectable object may have a clean-up function, which will be\n-invoked when the collector discovers the object to be inaccessible.\n-An object derived from \"gc_cleanup\" or containing a member derived\n-from \"gc_cleanup\" has a default clean-up function that invokes the\n-object's destructors.  Explicit clean-up functions may be specified as\n-an additional placement argument:\n-\n-    A* a = ::new (GC, MyCleanup) A;\n-\n-An object is considered \"accessible\" by the collector if it can be\n-reached by a path of pointers from static variables, automatic\n-variables of active functions, or from some object with clean-up\n-enabled; pointers from an object to itself are ignored.\n-\n-Thus, if objects A and B both have clean-up functions, and A points at\n-B, B is considered accessible.  After A's clean-up is invoked and its\n-storage released, B will then become inaccessible and will have its\n-clean-up invoked.  If A points at B and B points to A, forming a\n-cycle, then that's considered a storage leak, and neither will be\n-collectable.  See the interface gc.h for low-level facilities for\n-handling such cycles of objects with clean-up.\n-\n-The collector cannot guarrantee that it will find all inaccessible\n-objects.  In practice, it finds almost all of them.\n-\n-\n-Cautions:\n-\n-1. Be sure the collector has been augmented with \"make c++\".\n-\n-2.  If your compiler supports the new \"operator new[]\" syntax, then\n-add -DOPERATOR_NEW_ARRAY to the Makefile.\n-\n-If your compiler doesn't support \"operator new[]\", beware that an\n-array of type T, where T is derived from \"gc\", may or may not be\n-allocated as a collectable object (it depends on the compiler).  Use\n-the explicit GC placement to make the array collectable.  For example:\n-\n-    class A: public gc {...};\n-    A* a1 = new A[ 10 ];        // collectable or uncollectable?\n-    A* a2 = new (GC) A[ 10 ];   // collectable\n-\n-3. The destructors of collectable arrays of objects derived from\n-\"gc_cleanup\" will not be invoked properly.  For example:\n-\n-    class A: public gc_cleanup {...};\n-    A* a = new (GC) A[ 10 ];    // destructors not invoked correctly\n-\n-Typically, only the destructor for the first element of the array will\n-be invoked when the array is garbage-collected.  To get all the\n-destructors of any array executed, you must supply an explicit\n-clean-up function:\n-\n-    A* a = new (GC, MyCleanUp) A[ 10 ];\n-\n-(Implementing clean-up of arrays correctly, portably, and in a way\n-that preserves the correct exception semantics requires a language\n-extension, e.g. the \"gc\" keyword.)\n-\n-4. Compiler bugs:\n-\n-* Solaris 2's CC (SC3.0) doesn't implement t->~T() correctly, so the\n-destructors of classes derived from gc_cleanup won't be invoked.\n-You'll have to explicitly register a clean-up function with\n-new-placement syntax.\n-\n-* Evidently cfront 3.0 does not allow destructors to be explicitly\n-invoked using the ANSI-conforming syntax t->~T().  If you're using\n-cfront 3.0, you'll have to comment out the class gc_cleanup, which\n-uses explicit invocation.\n-\n-5. GC name conflicts:\n-\n-Many other systems seem to use the identifier \"GC\" as an abbreviation\n-for \"Graphics Context\".  Since version 5.0, GC placement has been replaced\n-by UseGC.  GC is an alias for UseGC, unless GC_NAME_CONFLICT is defined.\n-\n-****************************************************************************/\n-\n-#include \"gc.h\"\n-\n-#ifndef THINK_CPLUS\n-#define _cdecl\n-#endif\n-\n-#if ! defined( OPERATOR_NEW_ARRAY ) \\\n-    && (__BORLANDC__ >= 0x450 || (__GNUC__ >= 2 && __GNUC_MINOR__ >= 6) \\\n-        || __WATCOMC__ >= 1050)\n-#   define OPERATOR_NEW_ARRAY\n-#endif\n-\n-enum GCPlacement {UseGC,\n-#ifndef GC_NAME_CONFLICT\n-\t\t  GC=UseGC,\n-#endif\n-                  NoGC, PointerFreeGC};\n-\n-class gc {public:\n-    inline void* operator new( size_t size );\n-    inline void* operator new( size_t size, GCPlacement gcp );\n-    inline void operator delete( void* obj );\n-\n-#ifdef OPERATOR_NEW_ARRAY\n-    inline void* operator new[]( size_t size );\n-    inline void* operator new[]( size_t size, GCPlacement gcp );\n-    inline void operator delete[]( void* obj );\n-#endif /* OPERATOR_NEW_ARRAY */\n-    };    \n-    /*\n-    Instances of classes derived from \"gc\" will be allocated in the \n-    collected heap by default, unless an explicit NoGC placement is\n-    specified. */\n-\n-class gc_cleanup: virtual public gc {public:\n-    inline gc_cleanup();\n-    inline virtual ~gc_cleanup();\n-private:\n-    inline static void _cdecl cleanup( void* obj, void* clientData );};\n-    /*\n-    Instances of classes derived from \"gc_cleanup\" will be allocated\n-    in the collected heap by default.  When the collector discovers an\n-    inaccessible object derived from \"gc_cleanup\" or containing a\n-    member derived from \"gc_cleanup\", its destructors will be\n-    invoked. */\n-\n-extern \"C\" {typedef void (*GCCleanUpFunc)( void* obj, void* clientData );}\n-\n-inline void* operator new( \n-    size_t size, \n-    GCPlacement gcp,\n-    GCCleanUpFunc cleanup = 0,\n-    void* clientData = 0 );\n-    /*\n-    Allocates a collectable or uncollected object, according to the\n-    value of \"gcp\".\n-\n-    For collectable objects, if \"cleanup\" is non-null, then when the\n-    allocated object \"obj\" becomes inaccessible, the collector will\n-    invoke the function \"cleanup( obj, clientData )\" but will not\n-    invoke the object's destructors.  It is an error to explicitly\n-    delete an object allocated with a non-null \"cleanup\".\n-\n-    It is an error to specify a non-null \"cleanup\" with NoGC or for\n-    classes derived from \"gc_cleanup\" or containing members derived\n-    from \"gc_cleanup\". */\n-\n-#ifdef OPERATOR_NEW_ARRAY\n-\n-inline void* operator new[](\n-    size_t size, \n-    GCPlacement gcp,\n-    GCCleanUpFunc cleanup = 0,\n-    void* clientData = 0 );\n-    /*\n-    The operator new for arrays, identical to the above. */\n-\n-#endif /* OPERATOR_NEW_ARRAY */\n-\n-/****************************************************************************\n-\n-Inline implementation\n-\n-****************************************************************************/\n-\n-inline void* gc::operator new( size_t size ) {\n-    return GC_MALLOC( size );}\n-    \n-inline void* gc::operator new( size_t size, GCPlacement gcp ) {\n-    if (gcp == UseGC) \n-        return GC_MALLOC( size );\n-    else if (gcp == PointerFreeGC)\n-\treturn GC_MALLOC_ATOMIC( size );\n-    else\n-        return GC_MALLOC_UNCOLLECTABLE( size );}\n-\n-inline void gc::operator delete( void* obj ) {\n-    GC_FREE( obj );}\n-    \n-\n-#ifdef OPERATOR_NEW_ARRAY\n-\n-inline void* gc::operator new[]( size_t size ) {\n-    return gc::operator new( size );}\n-    \n-inline void* gc::operator new[]( size_t size, GCPlacement gcp ) {\n-    return gc::operator new( size, gcp );}\n-\n-inline void gc::operator delete[]( void* obj ) {\n-    gc::operator delete( obj );}\n-    \n-#endif /* OPERATOR_NEW_ARRAY */\n-\n-\n-inline gc_cleanup::~gc_cleanup() {\n-    GC_REGISTER_FINALIZER_IGNORE_SELF( GC_base(this), 0, 0, 0, 0 );}\n-\n-inline void gc_cleanup::cleanup( void* obj, void* displ ) {\n-    ((gc_cleanup*) ((char*) obj + (ptrdiff_t) displ))->~gc_cleanup();}\n-\n-inline gc_cleanup::gc_cleanup() {\n-    GC_finalization_proc oldProc;\n-    void* oldData;\n-    void* base = GC_base( (void *) this );\n-    if (0 != base)  {\n-      GC_REGISTER_FINALIZER_IGNORE_SELF( \n-        base, (GC_finalization_proc)cleanup, (void*) ((char*) this - (char*) base), \n-        &oldProc, &oldData );\n-      if (0 != oldProc) {\n-        GC_REGISTER_FINALIZER_IGNORE_SELF( base, oldProc, oldData, 0, 0 );}}}\n-\n-inline void* operator new( \n-    size_t size, \n-    GCPlacement gcp,\n-    GCCleanUpFunc cleanup,\n-    void* clientData )\n-{\n-    void* obj;\n-\n-    if (gcp == UseGC) {\n-        obj = GC_MALLOC( size );\n-        if (cleanup != 0) \n-            GC_REGISTER_FINALIZER_IGNORE_SELF( \n-                obj, cleanup, clientData, 0, 0 );}\n-    else if (gcp == PointerFreeGC) {\n-        obj = GC_MALLOC_ATOMIC( size );}\n-    else {\n-        obj = GC_MALLOC_UNCOLLECTABLE( size );};\n-    return obj;}\n-        \n-\n-#ifdef OPERATOR_NEW_ARRAY\n-\n-inline void* operator new[]( \n-    size_t size, \n-    GCPlacement gcp,\n-    GCCleanUpFunc cleanup,\n-    void* clientData )\n-{\n-    return ::operator new( size, gcp, cleanup, clientData );}\n-\n-#endif /* OPERATOR_NEW_ARRAY */\n-\n-\n-#endif /* GC_CPP_H */\n-"}, {"sha": "6966a9a1a879fda70f0a946d1a9dd42fc1e00db5", "filename": "boehm-gc/gc_hdrs.h", "status": "removed", "additions": 0, "deletions": 303, "changes": 303, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6951ca5dee8ed05749cdc697767910aebaedcc0/boehm-gc%2Fgc_hdrs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6951ca5dee8ed05749cdc697767910aebaedcc0/boehm-gc%2Fgc_hdrs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fgc_hdrs.h?ref=a6951ca5dee8ed05749cdc697767910aebaedcc0", "patch": "@@ -1,303 +0,0 @@\n-/* \n- * Copyright 1988, 1989 Hans-J. Boehm, Alan J. Demers\n- * Copyright (c) 1991-1994 by Xerox Corporation.  All rights reserved.\n- *\n- * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n- * OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n- *\n- * Permission is hereby granted to use or copy this program\n- * for any purpose,  provided the above notices are retained on all copies.\n- * Permission to modify the code and to distribute modified code is granted,\n- * provided the above notices are retained, and a notice that the code was\n- * modified is included with the above copyright notice.\n- */\n-/* Boehm, July 11, 1995 11:54 am PDT */\n-# ifndef GC_HEADERS_H\n-# define GC_HEADERS_H\n-typedef struct hblkhdr hdr;\n-\n-# if CPP_WORDSZ != 32 && CPP_WORDSZ < 36\n-\t--> Get a real machine.\n-# endif\n-\n-/*\n- * The 2 level tree data structure that is used to find block headers.\n- * If there are more than 32 bits in a pointer, the top level is a hash\n- * table.\n- *\n- * This defines HDR, GET_HDR, and SET_HDR, the main macros used to\n- * retrieve and set object headers.  We also define some variants to\n- * retrieve 2 unrelated headers in interleaved fashion.  This\n- * slightly improves scheduling.\n- *\n- * Since 5.0 alpha 5, we can also take advantage of a header lookup\n- * cache.  This is a locally declared direct mapped cache, used inside\n- * the marker.  The HC_GET_HDR and HC_GET_HDR2 macros use and maintain this\n- * cache.  Assuming we get reasonable hit rates, this shaves a few\n- * memory references from each pointer validation.\n- */\n-\n-# if CPP_WORDSZ > 32\n-#   define HASH_TL\n-# endif\n-\n-/* Define appropriate out-degrees for each of the two tree levels\t*/\n-# ifdef SMALL_CONFIG\n-#   define LOG_BOTTOM_SZ 11\n-\t/* Keep top index size reasonable with smaller blocks. */\n-# else\n-#   define LOG_BOTTOM_SZ 10\n-# endif\n-# ifndef HASH_TL\n-#   define LOG_TOP_SZ (WORDSZ - LOG_BOTTOM_SZ - LOG_HBLKSIZE)\n-# else\n-#   define LOG_TOP_SZ 11\n-# endif\n-# define TOP_SZ (1 << LOG_TOP_SZ)\n-# define BOTTOM_SZ (1 << LOG_BOTTOM_SZ)\n-\n-#ifndef SMALL_CONFIG\n-# define USE_HDR_CACHE\n-#endif\n-\n-/* #define COUNT_HDR_CACHE_HITS  */\n-\n-extern hdr * GC_invalid_header; /* header for an imaginary block \t*/\n-\t\t\t\t/* containing no objects.\t\t*/\n-\n-\n-/* Check whether p and corresponding hhdr point to long or invalid\t*/\n-/* object.  If so, advance them\tto\t\t\t\t\t*/\n-/* beginning of\tblock, or set hhdr to GC_invalid_header.\t\t*/\n-#define ADVANCE(p, hhdr, source) \\\n-            if (IS_FORWARDING_ADDR_OR_NIL(hhdr)) { \\\n-              p = GC_FIND_START(p, hhdr, (word)source); \\\n-              if (p == 0) { \\\n-\t\thhdr = GC_invalid_header; \\\n-\t      } else { \\\n-                hhdr = GC_find_header(p); \\\n-\t      } \\\n-    \t    }\n-\n-#ifdef USE_HDR_CACHE\n-\n-# ifdef COUNT_HDR_CACHE_HITS\n-    extern word GC_hdr_cache_hits;\n-    extern word GC_hdr_cache_misses;\n-#   define HC_HIT() ++GC_hdr_cache_hits\n-#   define HC_MISS() ++GC_hdr_cache_misses\n-# else\n-#   define HC_HIT()\n-#   define HC_MISS()\n-# endif\n-\n-  typedef struct hce {\n-    word block_addr;  \t/* right shifted by LOG_HBLKSIZE */\n-    hdr * hce_hdr;\n-  } hdr_cache_entry;\n-\n-# define HDR_CACHE_SIZE 8  /* power of 2 */\n-\n-# define DECLARE_HDR_CACHE \\\n-\thdr_cache_entry hdr_cache[HDR_CACHE_SIZE]\n-\n-# define INIT_HDR_CACHE BZERO(hdr_cache, sizeof(hdr_cache));\n-\n-# define HCE(h) hdr_cache + (((word)(h) >> LOG_HBLKSIZE) & (HDR_CACHE_SIZE-1))\n-\n-# define HCE_VALID_FOR(hce,h) ((hce) -> block_addr == \\\n-\t\t\t\t((word)(h) >> LOG_HBLKSIZE))\n-\n-# define HCE_HDR(h) ((hce) -> hce_hdr)\n-\n-\n-/* Analogous to GET_HDR, except that in the case of large objects, it\t*/\n-/* Returns the header for the object beginning, and updates p.\t\t*/\n-/* Returns &GC_bad_header instead of 0.  All of this saves a branch\t*/\n-/* in the fast path.\t\t\t\t\t\t\t*/\n-# define HC_GET_HDR(p, hhdr, source) \\\n-\t{ \\\n-\t  hdr_cache_entry * hce = HCE(p); \\\n-\t  if (HCE_VALID_FOR(hce, p)) { \\\n-\t    HC_HIT(); \\\n-\t    hhdr = hce -> hce_hdr; \\\n-\t  } else { \\\n-\t    HC_MISS(); \\\n-\t    GET_HDR(p, hhdr); \\\n-\t    ADVANCE(p, hhdr, source); \\\n-\t    hce -> block_addr = (word)(p) >> LOG_HBLKSIZE; \\\n-\t    hce -> hce_hdr = hhdr; \\\n-\t  } \\\n-\t}\n-\n-# define HC_GET_HDR2(p1, hhdr1, source1, p2, hhdr2, source2) \\\n-\t{ \\\n-\t  hdr_cache_entry * hce1 = HCE(p1); \\\n-\t  hdr_cache_entry * hce2 = HCE(p2); \\\n-\t  if (HCE_VALID_FOR(hce1, p1)) { \\\n-\t    HC_HIT(); \\\n-\t    hhdr1 = hce1 -> hce_hdr; \\\n-\t  } else { \\\n-\t    HC_MISS(); \\\n-\t    GET_HDR(p1, hhdr1); \\\n-\t    ADVANCE(p1, hhdr1, source1); \\\n-\t    hce1 -> block_addr = (word)(p1) >> LOG_HBLKSIZE; \\\n-\t    hce1 -> hce_hdr = hhdr1; \\\n-\t  } \\\n-\t  if (HCE_VALID_FOR(hce2, p2)) { \\\n-\t    HC_HIT(); \\\n-\t    hhdr2 = hce2 -> hce_hdr; \\\n-\t  } else { \\\n-\t    HC_MISS(); \\\n-\t    GET_HDR(p2, hhdr2); \\\n-\t    ADVANCE(p2, hhdr2, source2); \\\n-\t    hce2 -> block_addr = (word)(p2) >> LOG_HBLKSIZE; \\\n-\t    hce2 -> hce_hdr = hhdr2; \\\n-\t  } \\\n-\t}\n-\n-#else /* !USE_HDR_CACHE */\n-\n-# define DECLARE_HDR_CACHE\n-\n-# define INIT_HDR_CACHE\n-\n-# define HC_GET_HDR(p, hhdr, source) \\\n-\t{ \\\n-\t  GET_HDR(p, hhdr); \\\n-\t  ADVANCE(p, hhdr, source); \\\n-\t}\n-\n-# define HC_GET_HDR2(p1, hhdr1, source1, p2, hhdr2, source2) \\\n-\t{ \\\n-\t  GET_HDR2(p1, hhdr1, p2, hhdr2); \\\n-\t  ADVANCE(p1, hhdr1, source1); \\\n-\t  ADVANCE(p2, hhdr2, source2); \\\n-\t}\n-\n-#endif\n-\n-typedef struct bi {\n-    hdr * index[BOTTOM_SZ];\n-\t/*\n- \t * The bottom level index contains one of three kinds of values:\n-\t * 0 means we're not responsible for this block,\n-\t *   or this is a block other than the first one in a free block.\n-\t * 1 < (long)X <= MAX_JUMP means the block starts at least\n-\t *        X * HBLKSIZE bytes before the current address.\n-\t * A valid pointer points to a hdr structure. (The above can't be\n-\t * valid pointers due to the GET_MEM return convention.)\n-\t */\n-    struct bi * asc_link;\t/* All indices are linked in\t*/\n-    \t\t\t\t/* ascending order...\t\t*/\n-    struct bi * desc_link;\t/* ... and in descending order.\t*/\n-    word key;\t\t\t/* high order address bits.\t*/\n-# ifdef HASH_TL\n-    struct bi * hash_link;\t/* Hash chain link.\t\t*/\n-# endif\n-} bottom_index;\n-\n-/* extern bottom_index GC_all_nils; - really part of GC_arrays */\n-\n-/* extern bottom_index * GC_top_index []; - really part of GC_arrays */\n-\t\t\t\t/* Each entry points to a bottom_index.\t*/\n-\t\t\t\t/* On a 32 bit machine, it points to \t*/\n-\t\t\t\t/* the index for a set of high order\t*/\n-\t\t\t\t/* bits equal to the index.  For longer\t*/\n-\t\t\t\t/* addresses, we hash the high order\t*/\n-\t\t\t\t/* bits to compute the index in \t*/\n-\t\t\t\t/* GC_top_index, and each entry points\t*/\n-\t\t\t\t/* to a hash chain.\t\t\t*/\n-\t\t\t\t/* The last entry in each chain is\t*/\n-\t\t\t\t/* GC_all_nils.\t\t\t\t*/\n-\n-\n-# define MAX_JUMP (HBLKSIZE - 1)\n-\n-# define HDR_FROM_BI(bi, p) \\\n-\t\t((bi)->index[((word)(p) >> LOG_HBLKSIZE) & (BOTTOM_SZ - 1)])\n-# ifndef HASH_TL\n-#   define BI(p) (GC_top_index \\\n-\t\t[(word)(p) >> (LOG_BOTTOM_SZ + LOG_HBLKSIZE)])\n-#   define HDR_INNER(p) HDR_FROM_BI(BI(p),p)\n-#   ifdef SMALL_CONFIG\n-#\tdefine HDR(p) GC_find_header((ptr_t)(p))\n-#   else\n-#\tdefine HDR(p) HDR_INNER(p)\n-#   endif\n-#   define GET_BI(p, bottom_indx) (bottom_indx) = BI(p)\n-#   define GET_HDR(p, hhdr) (hhdr) = HDR(p)\n-#   define SET_HDR(p, hhdr) HDR_INNER(p) = (hhdr)\n-#   define GET_HDR_ADDR(p, ha) (ha) = &(HDR_INNER(p))\n-#   define GET_HDR2(p1, hhdr1, p2, hhdr2) \\\n-\t{ GET_HDR(p1, hhdr1); GET_HDR(p2, hhdr2); }\n-# else /* hash */\n-/*  Hash function for tree top level */\n-#   define TL_HASH(hi) ((hi) & (TOP_SZ - 1))\n-/*  Set bottom_indx to point to the bottom index for address p */\n-#   define GET_BI(p, bottom_indx) \\\n-\t{ \\\n-\t    register word hi = \\\n-\t        (word)(p) >> (LOG_BOTTOM_SZ + LOG_HBLKSIZE); \\\n-\t    register bottom_index * _bi = GC_top_index[TL_HASH(hi)]; \\\n-\t    \\\n-\t    while (_bi -> key != hi && _bi != GC_all_nils) \\\n-\t    \t_bi = _bi -> hash_link; \\\n-\t    (bottom_indx) = _bi; \\\n-\t}\n-#   define GET_HDR_ADDR(p, ha) \\\n-\t{ \\\n-\t    register bottom_index * bi; \\\n-\t    \\\n-\t    GET_BI(p, bi);\t\\\n-\t    (ha) = &(HDR_FROM_BI(bi, p)); \\\n-\t}\n-#   define GET_HDR(p, hhdr) { register hdr ** _ha; GET_HDR_ADDR(p, _ha); \\\n-\t\t\t      (hhdr) = *_ha; }\n-#   define SET_HDR(p, hhdr) { register hdr ** _ha; GET_HDR_ADDR(p, _ha); \\\n-\t\t\t      *_ha = (hhdr); }\n-#   define HDR(p) GC_find_header((ptr_t)(p))\n-    /* And some interleaved versions for two pointers at once.  \t*/\n-    /* This hopefully helps scheduling on processors like IA64.\t\t*/\n-#   define GET_BI2(p1, bottom_indx1, p2, bottom_indx2) \\\n-\t{ \\\n-\t    register word hi1 = \\\n-\t        (word)(p1) >> (LOG_BOTTOM_SZ + LOG_HBLKSIZE); \\\n-\t    register word hi2 = \\\n-\t        (word)(p2) >> (LOG_BOTTOM_SZ + LOG_HBLKSIZE); \\\n-\t    register bottom_index * _bi1 = GC_top_index[TL_HASH(hi1)]; \\\n-\t    register bottom_index * _bi2 = GC_top_index[TL_HASH(hi2)]; \\\n-\t    \\\n-\t    while (_bi1 -> key != hi1 && _bi1 != GC_all_nils) \\\n-\t    \t_bi1 = _bi1 -> hash_link; \\\n-\t    while (_bi2 -> key != hi2 && _bi2 != GC_all_nils) \\\n-\t    \t_bi2 = _bi2 -> hash_link; \\\n-\t    (bottom_indx1) = _bi1; \\\n-\t    (bottom_indx2) = _bi2; \\\n-\t}\n-#   define GET_HDR_ADDR2(p1, ha1, p2, ha2) \\\n-\t{ \\\n-\t    register bottom_index * bi1; \\\n-\t    register bottom_index * bi2; \\\n-\t    \\\n-\t    GET_BI2(p1, bi1, p2, bi2);\t\\\n-\t    (ha1) = &(HDR_FROM_BI(bi1, p1)); \\\n-\t    (ha2) = &(HDR_FROM_BI(bi2, p2)); \\\n-\t}\n-#   define GET_HDR2(p1, hhdr1, p2, hhdr2) \\\n-\t{ register hdr ** _ha1;  \\\n-\t  register hdr ** _ha2;  \\\n-\t  GET_HDR_ADDR2(p1, _ha1, p2, _ha2); \\\n-\t  (hhdr1) = *_ha1;  \\\n-\t  (hhdr2) = *_ha2;  \\\n-\t}\n-# endif\n-\t\t\t    \n-/* Is the result a forwarding address to someplace closer to the\t*/\n-/* beginning of the block or NIL?\t\t\t\t\t*/\n-# define IS_FORWARDING_ADDR_OR_NIL(hhdr) ((unsigned long) (hhdr) <= MAX_JUMP)\n-\n-/* Get an HBLKSIZE aligned address closer to the beginning of the block */\n-/* h.  Assumes hhdr == HDR(h) and IS_FORWARDING_ADDR(hhdr).\t\t*/\n-# define FORWARDED_ADDR(h, hhdr) ((struct hblk *)(h) - (unsigned long)(hhdr))\n-# endif /*  GC_HEADERS_H */"}, {"sha": "295423a62a19f7321185a332eec13a6fad1bd57f", "filename": "boehm-gc/gc_mark.h", "status": "removed", "additions": 0, "deletions": 346, "changes": 346, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6951ca5dee8ed05749cdc697767910aebaedcc0/boehm-gc%2Fgc_mark.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6951ca5dee8ed05749cdc697767910aebaedcc0/boehm-gc%2Fgc_mark.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fgc_mark.h?ref=a6951ca5dee8ed05749cdc697767910aebaedcc0", "patch": "@@ -1,346 +0,0 @@\n-/*\n- * Copyright (c) 1991-1994, 2000 by Xerox Corporation.  All rights reserved.\n- *\n- * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n- * OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n- *\n- * Permission is hereby granted to use or copy this program\n- * for any purpose,  provided the above notices are retained on all copies.\n- * Permission to modify the code and to distribute modified code is granted,\n- * provided the above notices are retained, and a notice that the code was\n- * modified is included with the above copyright notice.\n- *\n- */\n-/* Boehm, November 7, 1994 4:56 pm PST */\n-\n-/*\n- * Declarations of mark stack.  Needed by marker and client supplied mark\n- * routines.  To be included after gc_priv.h.\n- */\n-#ifndef GC_MARK_H\n-# define GC_MARK_H\n-\n-# ifdef KEEP_BACK_PTRS\n-#   include \"dbg_mlc.h\"\n-# endif\n-\n-/* A client supplied mark procedure.  Returns new mark stack pointer.\t*/\n-/* Primary effect should be to push new entries on the mark stack.\t*/\n-/* Mark stack pointer values are passed and returned explicitly.\t*/\n-/* Global variables decribing mark stack are not necessarily valid.\t*/\n-/* (This usually saves a few cycles by keeping things in registers.)\t*/\n-/* Assumed to scan about PROC_BYTES on average.  If it needs to do\t*/\n-/* much more work than that, it should do it in smaller pieces by\t*/\n-/* pushing itself back on the mark stack.\t\t\t\t*/\n-/* Note that it should always do some work (defined as marking some\t*/\n-/* objects) before pushing more than one entry on the mark stack.\t*/\n-/* This is required to ensure termination in the event of mark stack\t*/\n-/* overflows.\t\t\t\t\t\t\t\t*/\n-/* This procedure is always called with at least one empty entry on the */\n-/* mark stack.\t\t\t\t\t\t\t\t*/\n-/* Currently we require that mark procedures look for pointers in a\t*/\n-/* subset of the places the conservative marker would.  It must be safe\t*/\n-/* to invoke the normal mark procedure instead.\t\t\t\t*/\n-# define PROC_BYTES 100\n-/* The real declarations of the following are in gc_priv.h, so that\t*/\n-/* we can avoid scanning the following table.\t\t\t\t*/\n-/*\n-typedef struct ms_entry * (*mark_proc)(   word * addr,\n-\t\t\t\t\t  struct ms_entry *mark_stack_ptr,\n-\t\t\t\t\t  struct ms_entry *mark_stack_limit,\n-\t\t\t\t\t  word env   );\n-\t\t\t\t\t  \n-# define LOG_MAX_MARK_PROCS 6\n-# define MAX_MARK_PROCS (1 << LOG_MAX_MARK_PROCS)\n-extern mark_proc GC_mark_procs[MAX_MARK_PROCS];\n-*/\n-\n-extern word GC_n_mark_procs;\n-\n-/* In a few cases it's necessary to assign statically known indices to\t*/\n-/* certain mark procs.  Thus we reserve a few for well known clients.\t*/\n-/* (This is necessary if mark descriptors are compiler generated.)\t*/\n-#define GC_RESERVED_MARK_PROCS 8\n-#   define GCJ_RESERVED_MARK_PROC_INDEX 0\n-\n-/* Object descriptors on mark stack or in objects.  Low order two\t*/\n-/* bits are tags distinguishing among the following 4 possibilities\t*/\n-/* for the high order 30 bits.\t\t\t\t\t\t*/\n-#define DS_TAG_BITS 2\n-#define DS_TAGS   ((1 << DS_TAG_BITS) - 1)\n-#define DS_LENGTH 0\t/* The entire word is a length in bytes that\t*/\n-\t\t\t/* must be a multiple of 4.\t\t\t*/\n-#define DS_BITMAP 1\t/* 30 bits are a bitmap describing pointer\t*/\n-\t\t\t/* fields.  The msb is 1 iff the first word\t*/\n-\t\t\t/* is a pointer.\t\t\t\t*/\n-\t\t\t/* (This unconventional ordering sometimes\t*/\n-\t\t\t/* makes the marker slightly faster.)\t\t*/\n-\t\t\t/* Zeroes indicate definite nonpointers.  Ones\t*/\n-\t\t\t/* indicate possible pointers.\t\t\t*/\n-\t\t\t/* Only usable if pointers are word aligned.\t*/\n-#   define BITMAP_BITS (WORDSZ - DS_TAG_BITS)\n-#define DS_PROC   2\n-\t\t\t/* The objects referenced by this object can be */\n-\t\t\t/* pushed on the mark stack by invoking\t\t*/\n-\t\t\t/* PROC(descr).  ENV(descr) is passed as the\t*/\n-\t\t\t/* last argument.\t\t\t\t*/\n-#   define PROC(descr) \\\n-\t\t(GC_mark_procs[((descr) >> DS_TAG_BITS) & (MAX_MARK_PROCS-1)])\n-#   define ENV(descr) \\\n-\t\t((descr) >> (DS_TAG_BITS + LOG_MAX_MARK_PROCS))\n-#   define MAX_ENV \\\n-  \t      (((word)1 << (WORDSZ - DS_TAG_BITS - LOG_MAX_MARK_PROCS)) - 1)\n-#   define MAKE_PROC(proc_index, env) \\\n-\t    (((((env) << LOG_MAX_MARK_PROCS) | (proc_index)) << DS_TAG_BITS) \\\n-\t    | DS_PROC)\n-#define DS_PER_OBJECT 3\t/* The real descriptor is at the\t\t*/\n-\t\t\t/* byte displacement from the beginning of the\t*/\n-\t\t\t/* object given by descr & ~DS_TAGS\t\t*/\n-\t\t\t/* If the descriptor is negative, the real\t*/\n-\t\t\t/* descriptor is at (*<object_start>) -\t\t*/\n-\t\t\t/* (descr & ~DS_TAGS) - INDIR_PER_OBJ_BIAS\t*/\n-\t\t\t/* The latter alternative can be used if each\t*/\n-\t\t\t/* object contains a type descriptor in the\t*/\n-\t\t\t/* first word.\t\t\t\t\t*/\n-#define INDIR_PER_OBJ_BIAS 0x10\n-\t\t\t\n-typedef struct ms_entry {\n-    word * mse_start;   /* First word of object */\n-    word mse_descr;\t/* Descriptor; low order two bits are tags,\t*/\n-    \t\t\t/* identifying the upper 30 bits as one of the\t*/\n-    \t\t\t/* following:\t\t\t\t\t*/\n-} mse;\n-\n-extern word GC_mark_stack_size;\n-\n-extern mse * GC_mark_stack_top;\n-\n-extern mse * GC_mark_stack;\n-\n-#ifdef PRINT_BLACK_LIST\n-ptr_t GC_find_start(ptr_t, hdr*, word);\n-#else\n-ptr_t GC_find_start(ptr_t, hdr*);\n-#endif\n-\n-mse * GC_signal_mark_stack_overflow(mse *);\n-\n-# ifdef GATHERSTATS\n-#   define ADD_TO_ATOMIC(sz) GC_atomic_in_use += (sz)\n-#   define ADD_TO_COMPOSITE(sz) GC_composite_in_use += (sz)\n-# else\n-#   define ADD_TO_ATOMIC(sz)\n-#   define ADD_TO_COMPOSITE(sz)\n-# endif\n-\n-/* Push the object obj with corresponding heap block header hhdr onto \t*/\n-/* the mark stack.\t\t\t\t\t\t\t*/\n-# define PUSH_OBJ(obj, hhdr, mark_stack_top, mark_stack_limit) \\\n-{ \\\n-    register word _descr = (hhdr) -> hb_descr; \\\n-        \\\n-    if (_descr == 0) { \\\n-    \tADD_TO_ATOMIC((hhdr) -> hb_sz); \\\n-    } else { \\\n-        ADD_TO_COMPOSITE((hhdr) -> hb_sz); \\\n-        mark_stack_top++; \\\n-        if (mark_stack_top >= mark_stack_limit) { \\\n-          mark_stack_top = GC_signal_mark_stack_overflow(mark_stack_top); \\\n-        } \\\n-        mark_stack_top -> mse_start = (obj); \\\n-        mark_stack_top -> mse_descr = _descr; \\\n-    } \\\n-}\n-\n-#ifdef PRINT_BLACK_LIST\n-#   define GC_FIND_START(current, hhdr, source) \\\n-\tGC_find_start(current, hhdr, source)\n-#else\n-#   define GC_FIND_START(current, hhdr, source) \\\n-\tGC_find_start(current, hhdr)\n-#endif\n-\n-/* Push the contents of current onto the mark stack if it is a valid\t*/\n-/* ptr to a currently unmarked object.  Mark it.\t\t\t*/\n-/* If we assumed a standard-conforming compiler, we could probably\t*/\n-/* generate the exit_label transparently.\t\t\t\t*/\n-# define PUSH_CONTENTS(current, mark_stack_top, mark_stack_limit, \\\n-\t\t       source, exit_label) \\\n-{ \\\n-    hdr * my_hhdr; \\\n-    ptr_t my_current = current; \\\n- \\\n-    GET_HDR(my_current, my_hhdr); \\\n-    if (IS_FORWARDING_ADDR_OR_NIL(my_hhdr)) { \\\n-         my_current = GC_FIND_START(my_current, my_hhdr, (word)source); \\\n-         if (my_current == 0) goto exit_label; \\\n-         my_hhdr = GC_find_header(my_current); \\\n-    } \\\n-    PUSH_CONTENTS_HDR(my_current, mark_stack_top, mark_stack_limit, \\\n-\t\t  source, exit_label, my_hhdr);\t\\\n-exit_label: ; \\\n-}\n-\n-/* As above, but use header cache for header lookup.\t*/\n-# define HC_PUSH_CONTENTS(current, mark_stack_top, mark_stack_limit, \\\n-\t\t       source, exit_label) \\\n-{ \\\n-    hdr * my_hhdr; \\\n-    ptr_t my_current = current; \\\n- \\\n-    HC_GET_HDR(my_current, my_hhdr, source); \\\n-    PUSH_CONTENTS_HDR(my_current, mark_stack_top, mark_stack_limit, \\\n-\t\t  source, exit_label, my_hhdr);\t\\\n-exit_label: ; \\\n-}\n-\n-/* As above, but deal with two pointers in interleaved fashion.\t*/\n-# define HC_PUSH_CONTENTS2(current1, current2, mark_stack_top, \\\n-\t\t\t   mark_stack_limit, \\\n-\t\t           source1, source2, exit_label1, exit_label2) \\\n-{ \\\n-    hdr * hhdr1; \\\n-    ptr_t my_current1 = current1; \\\n-    hdr * hhdr2; \\\n-    ptr_t my_current2 = current2; \\\n- \\\n-    HC_GET_HDR2(my_current1, hhdr1, source1, my_current2, hhdr2, source2); \\\n-    PUSH_CONTENTS_HDR(my_current1, mark_stack_top, mark_stack_limit, \\\n-\t\t  source1, exit_label1, hhdr1);\t\\\n-exit_label1: ; \\\n-    if (0 != hhdr2) { \\\n-      PUSH_CONTENTS_HDR(my_current2, mark_stack_top, mark_stack_limit, \\\n-\t\t  source2, exit_label2, hhdr2);\t\\\n-    } \\\n-exit_label2: ; \\\n-}\n-\n-# define PUSH_CONTENTS_HDR(current, mark_stack_top, mark_stack_limit, \\\n-\t\t           source, exit_label, hhdr) \\\n-{ \\\n-    int displ;  /* Displacement in block; first bytes, then words */ \\\n-    map_entry_type map_entry; \\\n-    \\\n-    displ = HBLKDISPL(current); \\\n-    map_entry = MAP_ENTRY((hhdr -> hb_map), displ); \\\n-    if (map_entry == OBJ_INVALID) { \\\n-        GC_ADD_TO_BLACK_LIST_NORMAL(current, source); goto exit_label; \\\n-    } \\\n-    displ = BYTES_TO_WORDS(displ); \\\n-    displ -= map_entry; \\\n-\t\\\n-    { \\\n-        register word * mark_word_addr = hhdr -> hb_marks + divWORDSZ(displ); \\\n-        register word mark_word = *mark_word_addr; \\\n-        register word mark_bit = (word)1 << modWORDSZ(displ); \\\n-          \\\n-        if (mark_word & mark_bit) { \\\n-\t      /* Mark bit is already set */ \\\n-\t      goto exit_label; \\\n-        } \\\n-        GC_STORE_BACK_PTR((ptr_t)source, (ptr_t)HBLKPTR(current) \\\n-\t\t\t\t      + WORDS_TO_BYTES(displ)); \\\n-        *mark_word_addr = mark_word | mark_bit; \\\n-    } \\\n-    PUSH_OBJ(((word *)(HBLKPTR(current)) + displ), hhdr, \\\n-    \t     mark_stack_top, mark_stack_limit) \\\n-}\n-\n-#if defined(PRINT_BLACK_LIST) || defined(KEEP_BACK_PTRS)\n-#   define PUSH_ONE_CHECKED(p, ip, source) \\\n-\tGC_push_one_checked(p, ip, (ptr_t)(source))\n-#else\n-#   define PUSH_ONE_CHECKED(p, ip, source) \\\n-\tGC_push_one_checked(p, ip)\n-#endif\n-\n-/*\n- * Push a single value onto mark stack. Mark from the object pointed to by p.\n- * P is considered valid even if it is an interior pointer.\n- * Previously marked objects are not pushed.  Hence we make progress even\n- * if the mark stack overflows.\n- */\n-# define GC_PUSH_ONE_STACK(p, source) \\\n-    if ((ptr_t)(p) >= GC_least_plausible_heap_addr \t\\\n-\t && (ptr_t)(p) < GC_greatest_plausible_heap_addr) {\t\\\n-\t PUSH_ONE_CHECKED(p, TRUE, source);\t\\\n-    }\n-\n-/*\n- * As above, but interior pointer recognition as for\n- * normal for heap pointers.\n- */\n-# ifdef ALL_INTERIOR_POINTERS\n-#   define AIP TRUE\n-# else\n-#   define AIP FALSE\n-# endif\n-# define GC_PUSH_ONE_HEAP(p,source) \\\n-    if ((ptr_t)(p) >= GC_least_plausible_heap_addr \t\\\n-\t && (ptr_t)(p) < GC_greatest_plausible_heap_addr) {\t\\\n-\t PUSH_ONE_CHECKED(p,AIP,source);\t\\\n-    }\n-\n-/*\n- * Mark from one finalizable object using the specified\n- * mark proc. May not mark the object pointed to by \n- * real_ptr. That is the job of the caller, if appropriate\n- */\n-# define GC_MARK_FO(real_ptr, mark_proc) \\\n-{ \\\n-    (*(mark_proc))(real_ptr); \\\n-    while (!GC_mark_stack_empty()) GC_mark_from_mark_stack(); \\\n-    if (GC_mark_state != MS_NONE) { \\\n-        GC_set_mark_bit(real_ptr); \\\n-        while (!GC_mark_some((ptr_t)0)); \\\n-    } \\\n-}\n-\n-extern GC_bool GC_mark_stack_too_small;\n-\t\t\t\t/* We need a larger mark stack.  May be\t*/\n-\t\t\t\t/* set by client supplied mark routines.*/\n-\n-typedef int mark_state_t;\t/* Current state of marking, as follows:*/\n-\t\t\t\t/* Used to remember where we are during */\n-\t\t\t\t/* concurrent marking.\t\t\t*/\n-\n-\t\t\t\t/* We say something is dirty if it was\t*/\n-\t\t\t\t/* written since the last time we\t*/\n-\t\t\t\t/* retrieved dirty bits.  We say it's \t*/\n-\t\t\t\t/* grungy if it was marked dirty in the\t*/\n-\t\t\t\t/* last set of bits we retrieved.\t*/\n-\t\t\t\t\n-\t\t\t\t/* Invariant I: all roots and marked\t*/\n-\t\t\t\t/* objects p are either dirty, or point */\n-\t\t\t\t/* to objects q that are either marked \t*/\n-\t\t\t\t/* or a pointer to q appears in a range\t*/\n-\t\t\t\t/* on the mark stack.\t\t\t*/\n-\n-# define MS_NONE 0\t\t/* No marking in progress. I holds.\t*/\n-\t\t\t\t/* Mark stack is empty.\t\t\t*/\n-\n-# define MS_PUSH_RESCUERS 1\t/* Rescuing objects are currently \t*/\n-\t\t\t\t/* being pushed.  I holds, except\t*/\n-\t\t\t\t/* that grungy roots may point to \t*/\n-\t\t\t\t/* unmarked objects, as may marked\t*/\n-\t\t\t\t/* grungy objects above scan_ptr.\t*/\n-\n-# define MS_PUSH_UNCOLLECTABLE 2\n-\t\t\t\t/* I holds, except that marked \t\t*/\n-\t\t\t\t/* uncollectable objects above scan_ptr */\n-\t\t\t\t/* may point to unmarked objects.\t*/\n-\t\t\t\t/* Roots may point to unmarked objects\t*/\n-\n-# define MS_ROOTS_PUSHED 3\t/* I holds, mark stack may be nonempty  */\n-\n-# define MS_PARTIALLY_INVALID 4\t/* I may not hold, e.g. because of M.S. */\n-\t\t\t\t/* overflow.  However marked heap\t*/\n-\t\t\t\t/* objects below scan_ptr point to\t*/\n-\t\t\t\t/* marked or stacked objects.\t\t*/\n-\n-# define MS_INVALID 5\t\t/* I may not hold.\t\t\t*/\n-\n-extern mark_state_t GC_mark_state;\n-\n-#endif  /* GC_MARK_H */\n-"}, {"sha": "260566eb3a2c2a44e52c43d54ff30345f1044554", "filename": "boehm-gc/gc_priv.h", "status": "removed", "additions": 0, "deletions": 1906, "changes": 1906, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6951ca5dee8ed05749cdc697767910aebaedcc0/boehm-gc%2Fgc_priv.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6951ca5dee8ed05749cdc697767910aebaedcc0/boehm-gc%2Fgc_priv.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fgc_priv.h?ref=a6951ca5dee8ed05749cdc697767910aebaedcc0", "patch": "@@ -1,1906 +0,0 @@\n-/* \n- * Copyright 1988, 1989 Hans-J. Boehm, Alan J. Demers\n- * Copyright (c) 1991-1994 by Xerox Corporation.  All rights reserved.\n- * Copyright (c) 1996-1999 by Silicon Graphics.  All rights reserved.\n- * Copyright (c) 1999 by Hewlett-Packard Company. All rights reserved.\n- *\n- *\n- * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n- * OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n- *\n- * Permission is hereby granted to use or copy this program\n- * for any purpose,  provided the above notices are retained on all copies.\n- * Permission to modify the code and to distribute modified code is granted,\n- * provided the above notices are retained, and a notice that the code was\n- * modified is included with the above copyright notice.\n- */\n-/* Boehm, February 16, 1996 2:30 pm PST */\n- \n-\n-# ifndef GC_PRIVATE_H\n-# define GC_PRIVATE_H\n-\n-#if defined(mips) && defined(SYSTYPE_BSD) && defined(sony_news)\n-    /* sony RISC NEWS, NEWSOS 4 */\n-#   define BSD_TIME\n-/*    typedef long ptrdiff_t;   -- necessary on some really old systems\t*/\n-#endif\n-\n-#if defined(mips) && defined(SYSTYPE_BSD43)\n-    /* MIPS RISCOS 4 */\n-#   define BSD_TIME\n-#endif\n-\n-#ifdef BSD_TIME\n-#   include <sys/types.h>\n-#   include <sys/time.h>\n-#   include <sys/resource.h>\n-#endif /* BSD_TIME */\n-\n-# ifndef GC_H\n-#   include \"gc.h\"\n-# endif\n-\n-typedef GC_word word;\n-typedef GC_signed_word signed_word;\n-\n-# ifndef GCCONFIG_H\n-#   include \"gcconfig.h\"\n-# endif\n-\n-# ifndef HEADERS_H\n-#   include \"gc_hdrs.h\"\n-# endif\n-\n-typedef int GC_bool;\n-# define TRUE 1\n-# define FALSE 0\n-\n-typedef char * ptr_t;\t/* A generic pointer to which we can add\t*/\n-\t\t\t/* byte displacements.\t\t\t\t*/\n-\t\t\t/* Preferably identical to caddr_t, if it \t*/\n-\t\t\t/* exists.\t\t\t\t\t*/\n-\t\t\t\n-#if defined(__STDC__)\n-#   include <stdlib.h>\n-#   if !(defined( sony_news ) )\n-#       include <stddef.h>\n-#   endif\n-#   define VOLATILE volatile\n-#else\n-#   ifdef MSWIN32\n-#   \tinclude <stdlib.h>\n-#   endif\n-#   define VOLATILE\n-#endif\n-\n-#define CONST GC_CONST\n-\n-#if 0 /* was once defined for AMIGA */\n-#   define GC_FAR __far\n-#else\n-#   define GC_FAR\n-#endif\n-\n-\n-/*********************************/\n-/*                               */\n-/* Definitions for conservative  */\n-/* collector                     */\n-/*                               */\n-/*********************************/\n-\n-/*********************************/\n-/*                               */\n-/* Easily changeable parameters  */\n-/*                               */\n-/*********************************/\n-\n-#define STUBBORN_ALLOC\t/* Define stubborn allocation primitives\t*/\n-#if defined(SRC_M3) || defined(SMALL_CONFIG)\n-# undef STUBBORN_ALLOC\n-#endif\n-\n-\n-/* #define ALL_INTERIOR_POINTERS */\n-\t\t    /* Forces all pointers into the interior of an \t*/\n-\t\t    /* object to be considered valid.  Also causes the\t*/\n-\t\t    /* sizes of all objects to be inflated by at least \t*/\n-\t\t    /* one byte.  This should suffice to guarantee\t*/\n-\t\t    /* that in the presence of a compiler that does\t*/\n-\t\t    /* not perform garbage-collector-unsafe\t\t*/\n-\t\t    /* optimizations, all portable, strictly ANSI\t*/\n-\t\t    /* conforming C programs should be safely usable\t*/\n-\t\t    /* with malloc replaced by GC_malloc and free\t*/\n-\t\t    /* calls removed.  There are several disadvantages: */\n-\t\t    /* 1. There are probably no interesting, portable,\t*/\n-\t\t    /*    strictly ANSI\tconforming C programs.\t\t*/\n-\t\t    /* 2. This option makes it hard for the collector\t*/\n-\t\t    /*    to allocate space that is not ``pointed to''  */\n-\t\t    /*    by integers, etc.  Under SunOS 4.X with a \t*/\n-\t\t    /*    statically linked libc, we empiricaly\t\t*/\n-\t\t    /*    observed that it would be difficult to \t*/\n-\t\t    /*\t  allocate individual objects larger than 100K.\t*/\n-\t\t    /* \t  Even if only smaller objects are allocated,\t*/\n-\t\t    /*    more swap space is likely to be needed.       */\n-\t\t    /*    Fortunately, much of this will never be\t*/\n-\t\t    /*    touched.\t\t\t\t\t*/\n-\t\t    /* If you can easily avoid using this option, do.\t*/\n-\t\t    /* If not, try to keep individual objects small.\t*/\n-\t\t    \n-#define PRINTSTATS  /* Print garbage collection statistics          \t*/\n-\t\t    /* For less verbose output, undefine in reclaim.c \t*/\n-\n-#define PRINTTIMES  /* Print the amount of time consumed by each garbage   */\n-\t\t    /* collection.                                         */\n-\n-#define PRINTBLOCKS /* Print object sizes associated with heap blocks,     */\n-\t\t    /* whether the objects are atomic or composite, and    */\n-\t\t    /* whether or not the block was found to be empty      */\n-\t\t    /* during the reclaim phase.  Typically generates       */\n-\t\t    /* about one screenful per garbage collection.         */\n-#undef PRINTBLOCKS\n-\n-#ifdef SILENT\n-#  ifdef PRINTSTATS\n-#    undef PRINTSTATS\n-#  endif\n-#  ifdef PRINTTIMES\n-#    undef PRINTTIMES\n-#  endif\n-#  ifdef PRINTNBLOCKS\n-#    undef PRINTNBLOCKS\n-#  endif\n-#endif\n-\n-#if defined(PRINTSTATS) && !defined(GATHERSTATS)\n-#   define GATHERSTATS\n-#endif\n-\n-#ifdef FINALIZE_ON_DEMAND\n-#   define GC_INVOKE_FINALIZERS()\n-#else\n-#   define GC_INVOKE_FINALIZERS() (void)GC_invoke_finalizers()\n-#endif\n-\n-#define MERGE_SIZES /* Round up some object sizes, so that fewer distinct */\n-\t\t    /* free lists are actually maintained.  This applies  */\n-\t\t    /* only to the top level routines in misc.c, not to   */\n-\t\t    /* user generated code that calls GC_allocobj and     */\n-\t\t    /* GC_allocaobj directly.                             */\n-\t\t    /* Slows down average programs slightly.  May however */\n-\t\t    /* substantially reduce fragmentation if allocation   */\n-\t\t    /* request sizes are widely scattered.                */\n-\t\t    /* May save significant amounts of space for obj_map  */\n-\t\t    /* entries.\t\t\t\t\t\t  */\n-\n-/* ALIGN_DOUBLE requires MERGE_SIZES at present. */\n-# if defined(ALIGN_DOUBLE) && !defined(MERGE_SIZES)\n-#   define MERGE_SIZES\n-# endif\n-\n-#if defined(ALL_INTERIOR_POINTERS) && !defined(DONT_ADD_BYTE_AT_END)\n-# define ADD_BYTE_AT_END\n-#endif\n-\n-\n-# ifndef LARGE_CONFIG\n-#   define MINHINCR 16\t/* Minimum heap increment, in blocks of HBLKSIZE  */\n-\t\t\t/* Must be multiple of largest page size.\t  */\n-#   define MAXHINCR 512\t/* Maximum heap increment, in blocks              */\n-# else\n-#   define MINHINCR 64\n-#   define MAXHINCR 4096\n-# endif\n-\n-# define TIME_LIMIT 50\t   /* We try to keep pause times from exceeding\t */\n-\t\t\t   /* this by much. In milliseconds.\t\t */\n-\n-# define BL_LIMIT GC_black_list_spacing\n-\t\t\t   /* If we need a block of N bytes, and we have */\n-\t\t\t   /* a block of N + BL_LIMIT bytes available, \t */\n-\t\t\t   /* and N > BL_LIMIT,\t\t\t\t */\n-\t\t\t   /* but all possible positions in it are \t */\n-\t\t\t   /* blacklisted, we just use it anyway (and\t */\n-\t\t\t   /* print a warning, if warnings are enabled). */\n-\t\t\t   /* This risks subsequently leaking the block\t */\n-\t\t\t   /* due to a false reference.  But not using\t */\n-\t\t\t   /* the block risks unreasonable immediate\t */\n-\t\t\t   /* heap growth.\t\t\t\t */\n-\n-/*********************************/\n-/*                               */\n-/* Stack saving for debugging\t */\n-/*                               */\n-/*********************************/\n-\n-#ifdef SAVE_CALL_CHAIN\n-\n-/*\n- * Number of frames and arguments to save in objects allocated by\n- * debugging allocator.\n- */\n-#   define NFRAMES 6\t/* Number of frames to save. Even for\t\t*/\n-\t\t\t/* alignment reasons.\t\t\t\t*/\n-#   define NARGS 2\t/* Mumber of arguments to save for each call.\t*/\n-\n-#   define NEED_CALLINFO\n-\n-/* Fill in the pc and argument information for up to NFRAMES of my\t*/\n-/* callers.  Ignore my frame and my callers frame.\t\t\t*/\n-void GC_save_callers (/* struct callinfo info[NFRAMES] */);\n-\n-void GC_print_callers (/* struct callinfo info[NFRAMES] */);\n-\n-#else\n-\n-# ifdef GC_ADD_CALLER\n-#   define NFRAMES 1\n-#   define NARGS 0\n-#   define NEED_CALLINFO\n-# endif\n-\n-#endif\n-\n-#ifdef NEED_CALLINFO\n-    struct callinfo {\n-\tword ci_pc;\n-#\tif NARGS > 0\n-\t    word ci_arg[NARGS];\t/* bit-wise complement to avoid retention */\n-#\tendif\n-#\tif defined(ALIGN_DOUBLE) && (NFRAMES * (NARGS + 1)) % 2 == 1\n-\t    /* Likely alignment problem. */\n-\t    word ci_dummy;\n-#\tendif\n-    };\n-#endif\n-\n-\n-/*********************************/\n-/*                               */\n-/* OS interface routines\t */\n-/*                               */\n-/*********************************/\n-\n-#ifdef BSD_TIME\n-#   undef CLOCK_TYPE\n-#   undef GET_TIME\n-#   undef MS_TIME_DIFF\n-#   define CLOCK_TYPE struct timeval\n-#   define GET_TIME(x) { struct rusage rusage; \\\n-\t\t\t getrusage (RUSAGE_SELF,  &rusage); \\\n-\t\t\t x = rusage.ru_utime; }\n-#   define MS_TIME_DIFF(a,b) ((double) (a.tv_sec - b.tv_sec) * 1000.0 \\\n-                               + (double) (a.tv_usec - b.tv_usec) / 1000.0)\n-#else /* !BSD_TIME */\n-# ifdef MSWIN32\n-#   include <windows.h>\n-#   include <winbase.h>\n-#   define CLOCK_TYPE DWORD\n-#   define GET_TIME(x) x = GetTickCount()\n-#   define MS_TIME_DIFF(a,b) ((long)((a)-(b)))\n-# else /* !MSWIN32, !BSD_TIME */\n-#   include <time.h>\n-#   if !defined(__STDC__) && defined(SPARC) && defined(SUNOS4)\n-      clock_t clock();\t/* Not in time.h, where it belongs\t*/\n-#   endif\n-#   if defined(FREEBSD) && !defined(CLOCKS_PER_SEC)\n-#     include <machine/limits.h>\n-#     define CLOCKS_PER_SEC CLK_TCK\n-#   endif\n-#   if !defined(CLOCKS_PER_SEC)\n-#     define CLOCKS_PER_SEC 1000000\n-/*\n- * This is technically a bug in the implementation.  ANSI requires that\n- * CLOCKS_PER_SEC be defined.  But at least under SunOS4.1.1, it isn't.\n- * Also note that the combination of ANSI C and POSIX is incredibly gross\n- * here. The type clock_t is used by both clock() and times().  But on\n- * some machines these use different notions of a clock tick,  CLOCKS_PER_SEC\n- * seems to apply only to clock.  Hence we use it here.  On many machines,\n- * including SunOS, clock actually uses units of microseconds (which are\n- * not really clock ticks).\n- */\n-#   endif\n-#   define CLOCK_TYPE clock_t\n-#   define GET_TIME(x) x = clock()\n-#   define MS_TIME_DIFF(a,b) ((unsigned long) \\\n-\t\t(1000.0*(double)((a)-(b))/(double)CLOCKS_PER_SEC))\n-# endif /* !MSWIN32 */\n-#endif /* !BSD_TIME */\n-\n-/* We use bzero and bcopy internally.  They may not be available.\t*/\n-# if defined(SPARC) && defined(SUNOS4)\n-#   define BCOPY_EXISTS\n-# endif\n-# if defined(M68K) && defined(AMIGA)\n-#   define BCOPY_EXISTS\n-# endif\n-# if defined(M68K) && defined(NEXT)\n-#   define BCOPY_EXISTS\n-# endif\n-# if defined(VAX)\n-#   define BCOPY_EXISTS\n-# endif\n-# if defined(AMIGA)\n-#   include <string.h>\n-#   define BCOPY_EXISTS\n-# endif\n-\n-# ifndef BCOPY_EXISTS\n-#   include <string.h>\n-#   define BCOPY(x,y,n) memcpy(y, x, (size_t)(n))\n-#   define BZERO(x,n)  memset(x, 0, (size_t)(n))\n-# else\n-#   define BCOPY(x,y,n) bcopy((char *)(x),(char *)(y),(int)(n))\n-#   define BZERO(x,n) bzero((char *)(x),(int)(n))\n-# endif\n-\n-/* HBLKSIZE aligned allocation.  0 is taken to mean failure \t*/\n-/* space is assumed to be cleared.\t\t\t\t*/\n-/* In the case os USE_MMAP, the argument must also be a \t*/\n-/* physical page size.\t\t\t\t\t\t*/\n-/* GET_MEM is currently not assumed to retrieve 0 filled space, */\n-/* though we should perhaps take advantage of the case in which */\n-/* does.\t\t\t\t\t\t\t*/\n-# ifdef PCR\n-    char * real_malloc();\n-#   define GET_MEM(bytes) HBLKPTR(real_malloc((size_t)bytes + GC_page_size) \\\n-\t\t\t\t  + GC_page_size-1)\n-# else\n-#   ifdef OS2\n-      void * os2_alloc(size_t bytes);\n-#     define GET_MEM(bytes) HBLKPTR((ptr_t)os2_alloc((size_t)bytes \\\n-\t\t\t\t    + GC_page_size) \\\n-                                    + GC_page_size-1)\n-#   else\n-#     if defined(AMIGA) || defined(NEXT) || defined(MACOSX) || defined(DOS4GW)\n-#       define GET_MEM(bytes) HBLKPTR((size_t) \\\n-\t\t\t\t      calloc(1, (size_t)bytes + GC_page_size) \\\n-                                      + GC_page_size-1)\n-#     else\n-#\tifdef MSWIN32\n-          extern ptr_t GC_win32_get_mem();\n-#         define GET_MEM(bytes) (struct hblk *)GC_win32_get_mem(bytes)\n-#\telse\n-#\t  ifdef MACOS\n-#\t    if defined(USE_TEMPORARY_MEMORY)\n-\t\textern Ptr GC_MacTemporaryNewPtr(size_t size,\n-\t\t\t\t\t\t Boolean clearMemory);\n-#               define GET_MEM(bytes) HBLKPTR( \\\n-\t\t    GC_MacTemporaryNewPtr(bytes + GC_page_size, true) \\\n-\t\t    + GC_page_size-1)\n-#\t    else\n-#         \t    define GET_MEM(bytes) HBLKPTR( \\\n-\t\t\tNewPtrClear(bytes + GC_page_size) + GC_page_size-1)\n-#\t    endif\n-#\t  else\n-              extern ptr_t GC_unix_get_mem();\n-#             define GET_MEM(bytes) (struct hblk *)GC_unix_get_mem(bytes)\n-#\t  endif\n-#\tendif\n-#     endif\n-#   endif\n-# endif\n-\n-/*\n- * Mutual exclusion between allocator/collector routines.\n- * Needed if there is more than one allocator thread.\n- * FASTLOCK() is assumed to try to acquire the lock in a cheap and\n- * dirty way that is acceptable for a few instructions, e.g. by\n- * inhibiting preemption.  This is assumed to have succeeded only\n- * if a subsequent call to FASTLOCK_SUCCEEDED() returns TRUE.\n- * FASTUNLOCK() is called whether or not FASTLOCK_SUCCEEDED().\n- * If signals cannot be tolerated with the FASTLOCK held, then\n- * FASTLOCK should disable signals.  The code executed under\n- * FASTLOCK is otherwise immune to interruption, provided it is\n- * not restarted.\n- * DCL_LOCK_STATE declares any local variables needed by LOCK and UNLOCK\n- * and/or DISABLE_SIGNALS and ENABLE_SIGNALS and/or FASTLOCK.\n- * (There is currently no equivalent for FASTLOCK.)\n- */  \n-# ifdef THREADS\n-#  ifdef PCR_OBSOLETE\t/* Faster, but broken with multiple lwp's\t*/\n-#    include  \"th/PCR_Th.h\"\n-#    include  \"th/PCR_ThCrSec.h\"\n-     extern struct PCR_Th_MLRep GC_allocate_ml;\n-#    define DCL_LOCK_STATE  PCR_sigset_t GC_old_sig_mask\n-#    define LOCK() PCR_Th_ML_Acquire(&GC_allocate_ml) \n-#    define UNLOCK() PCR_Th_ML_Release(&GC_allocate_ml)\n-#    define FASTLOCK() PCR_ThCrSec_EnterSys()\n-     /* Here we cheat (a lot): */\n-#        define FASTLOCK_SUCCEEDED() (*(int *)(&GC_allocate_ml) == 0)\n-\t\t/* TRUE if nobody currently holds the lock */\n-#    define FASTUNLOCK() PCR_ThCrSec_ExitSys()\n-#  endif\n-#  ifdef PCR\n-#    include <base/PCR_Base.h>\n-#    include <th/PCR_Th.h>\n-     extern PCR_Th_ML GC_allocate_ml;\n-#    define DCL_LOCK_STATE \\\n-\t PCR_ERes GC_fastLockRes; PCR_sigset_t GC_old_sig_mask\n-#    define LOCK() PCR_Th_ML_Acquire(&GC_allocate_ml)\n-#    define UNLOCK() PCR_Th_ML_Release(&GC_allocate_ml)\n-#    define FASTLOCK() (GC_fastLockRes = PCR_Th_ML_Try(&GC_allocate_ml))\n-#    define FASTLOCK_SUCCEEDED() (GC_fastLockRes == PCR_ERes_okay)\n-#    define FASTUNLOCK()  {\\\n-        if( FASTLOCK_SUCCEEDED() ) PCR_Th_ML_Release(&GC_allocate_ml); }\n-#  endif\n-#  ifdef SRC_M3\n-     extern word RT0u__inCritical;\n-#    define LOCK() RT0u__inCritical++\n-#    define UNLOCK() RT0u__inCritical--\n-#  endif\n-#  ifdef SOLARIS_THREADS\n-#    include <thread.h>\n-#    include <signal.h>\n-     extern mutex_t GC_allocate_ml;\n-#    define LOCK() mutex_lock(&GC_allocate_ml);\n-#    define UNLOCK() mutex_unlock(&GC_allocate_ml);\n-#  endif\n-#  if defined(LINUX_THREADS) \n-#   if defined(I386)|| defined(POWERPC) || defined(ALPHA) || defined(IA64) \\\n-    || defined(M68K) || defined(SPARC)\n-#    include <pthread.h>\n-#    define USE_SPIN_LOCK\n-#    if defined(I386)\n-       inline static int GC_test_and_set(volatile unsigned int *addr) {\n-\t  int oldval;\n-\t  /* Note: the \"xchg\" instruction does not need a \"lock\" prefix */\n-\t  __asm__ __volatile__(\"xchgl %0, %1\"\n-\t\t: \"=r\"(oldval), \"=m\"(*(addr))\n-\t\t: \"0\"(1), \"m\"(*(addr)));\n-\t  return oldval;\n-       }\n-#    endif\n-#    if defined(IA64)\n-       inline static int GC_test_and_set(volatile unsigned int *addr) {\n-\t  int oldval;\n-\t  __asm__ __volatile__(\"xchg4 %0=%1,%2\"\n-\t\t: \"=r\"(oldval), \"=m\"(*addr)\n-\t\t: \"r\"(1), \"1\"(*addr));\n-\t  return oldval;\n-       }\n-       inline static void GC_clear(volatile unsigned int *addr) {\n-\t __asm__ __volatile__(\"st4.rel %0=r0\" : \"=m\" (*addr));\n-       }\n-#      define GC_CLEAR_DEFINED\n-#    endif\n-#    ifdef SPARC\n-       inline static int GC_test_and_set(volatile unsigned int *addr) {\n-\t int oldval;\n-\n-\t __asm__ __volatile__(\"ldstub %1,%0\"\n-\t : \"=r\"(oldval), \"=m\"(*addr)\n-\t : \"m\"(*addr));\n-\t return oldval;\n-       }\n-#    endif\n-#    ifdef M68K\n-       /* Contributed by Tony Mantler.  I'm not sure how well it was\t*/\n-       /* tested.\t\t\t\t\t\t\t*/\n-       inline static int GC_test_and_set(volatile unsigned int *addr) {\n-          char oldval; /* this must be no longer than 8 bits */\n-\n-          /* The return value is semi-phony. */\n-          /* 'tas' sets bit 7 while the return */\n-          /* value pretends bit 0 was set */\n-          __asm__ __volatile__(\n-                 \"tas %1@; sne %0; negb %0\"\n-                 : \"=d\" (oldval)\n-                 : \"a\" (addr));\n-          return oldval;\n-       }\n-#    endif\n-#    if defined(POWERPC)\n-      inline static int GC_test_and_set(volatile unsigned int *addr) {\n-        int oldval;\n-        int temp = 1; // locked value\n-\n-        __asm__ __volatile__(\n-               \"1:\\tlwarx %0,0,%3\\n\"   // load and reserve\n-               \"\\tcmpwi %0, 0\\n\"       // if load is\n-               \"\\tbne 2f\\n\"            //   non-zero, return already set\n-               \"\\tstwcx. %2,0,%1\\n\"    // else store conditional\n-               \"\\tbne- 1b\\n\"           // retry if lost reservation\n-               \"2:\\t\\n\"                // oldval is zero if we set\n-              : \"=&r\"(oldval), \"=p\"(addr)\n-              : \"r\"(temp), \"1\"(addr)\n-              : \"memory\");\n-        return (int)oldval;\n-      }\n-      inline static void GC_clear(volatile unsigned int *addr) {\n-\t __asm__ __volatile__(\"eieio\");\n-         *(addr) = 0;\n-      }\n-#     define GC_CLEAR_DEFINED\n-#    endif\n-#    ifdef ALPHA\n-      inline static int GC_test_and_set(volatile unsigned int * addr)\n-      {\n-        unsigned long oldvalue;\n-        unsigned long temp;\n-\n-        __asm__ __volatile__(\n-                             \"1:     ldl_l %0,%1\\n\"\n-                             \"       and %0,%3,%2\\n\"\n-                             \"       bne %2,2f\\n\"\n-                             \"       xor %0,%3,%0\\n\"\n-                             \"       stl_c %0,%1\\n\"\n-                             \"       beq %0,3f\\n\"\n-                             \"       mb\\n\"\n-                             \"2:\\n\"\n-                             \".section .text2,\\\"ax\\\"\\n\"\n-                             \"3:     br 1b\\n\"\n-                             \".previous\"\n-                             :\"=&r\" (temp), \"=m\" (*addr), \"=&r\" (oldvalue)\n-                             :\"Ir\" (1), \"m\" (*addr));\n-\n-        return oldvalue;\n-      }\n-      /* Should probably also define GC_clear, since it needs\t*/\n-      /* a memory barrier ??\t\t\t\t\t*/\n-#    endif /* ALPHA */\n-#    ifdef ARM32\n-      inline static int GC_test_and_set(volatile unsigned int *addr) {\n-        int oldval;\n-        /* SWP on ARM is very similar to XCHG on x86.  Doesn't lock the\n-         * bus because there are no SMP ARM machines.  If/when there are,\n-         * this code will likely need to be updated. */\n-        /* See linuxthreads/sysdeps/arm/pt-machine.h in glibc-2.1 */\n-        __asm__ __volatile__(\"swp %0, %1, [%2]\"\n-      \t\t\t     : \"=r\"(oldval)\n-      \t\t\t     : \"r\"(1), \"r\"(addr));\n-        return oldval;\n-      }\n-#    endif\n-#    ifndef GC_CLEAR_DEFINED\n-       inline static void GC_clear(volatile unsigned int *addr) {\n-\t  /* Try to discourage gcc from moving anything past this. */\n-\t  __asm__ __volatile__(\" \");\n-          *(addr) = 0;\n-       }\n-#    endif\n-\n-     extern volatile unsigned int GC_allocate_lock;\n-     extern pthread_t GC_lock_holder;\n-     extern void GC_lock(void);\n-\t/* Allocation lock holder.  Only set if acquired by client through */\n-\t/* GC_call_with_alloc_lock.\t\t\t\t\t   */\n-#    define SET_LOCK_HOLDER() GC_lock_holder = pthread_self()\n-#    define NO_THREAD (pthread_t)(-1)\n-#    define UNSET_LOCK_HOLDER() GC_lock_holder = NO_THREAD\n-#    define I_HOLD_LOCK() (pthread_equal(GC_lock_holder, pthread_self()))\n-#    define LOCK() \\\n-\t\t{ if (GC_test_and_set(&GC_allocate_lock)) GC_lock(); }\n-#    define UNLOCK() \\\n-\t\tGC_clear(&GC_allocate_lock)\n-     extern VOLATILE GC_bool GC_collecting;\n-#    define ENTER_GC() \\\n-\t\t{ \\\n-\t\t    GC_collecting = 1; \\\n-\t\t}\n-#    define EXIT_GC() GC_collecting = 0;\n-#   else /* LINUX_THREADS on hardware for which we don't know how\t*/\n-\t /* to do test and set.\t\t\t\t\t\t*/\n-#    include <pthread.h>\n-     extern pthread_mutex_t GC_allocate_ml;\n-#    define LOCK() pthread_mutex_lock(&GC_allocate_ml)\n-#    define UNLOCK() pthread_mutex_unlock(&GC_allocate_ml)\n-#   endif\n-#  endif /* LINUX_THREADS */\n-#  if defined(HPUX_THREADS)\n-#    include <pthread.h>\n-     extern pthread_mutex_t GC_allocate_ml;\n-#    define LOCK() pthread_mutex_lock(&GC_allocate_ml)\n-#    define UNLOCK() pthread_mutex_unlock(&GC_allocate_ml)\n-#  endif\n-#  if defined(IRIX_THREADS) || defined(IRIX_JDK_THREADS) \n-     /* This may also eventually be appropriate for HPUX_THREADS */\n-#    include <pthread.h>\n-#    ifndef HPUX_THREADS\n-\t/* This probably should never be included, but I can't test\t*/\n-\t/* on Irix anymore.\t\t\t\t\t\t*/\n-#       include <mutex.h>\n-#    endif\n-\n-#    ifndef HPUX_THREADS\n-#      if __mips < 3 || !(defined (_ABIN32) || defined(_ABI64)) \\\n-\t|| !defined(_COMPILER_VERSION) || _COMPILER_VERSION < 700\n-#        define GC_test_and_set(addr, v) test_and_set(addr,v)\n-#      else\n-#\t define GC_test_and_set(addr, v) __test_and_set(addr,v)\n-#      endif\n-#    else\n-       /* I couldn't find a way to do this inline on HP/UX\t*/\n-#    endif\n-     extern unsigned long GC_allocate_lock;\n-\t/* This is not a mutex because mutexes that obey the (optional) \t*/\n-\t/* POSIX scheduling rules are subject to convoys in high contention\t*/\n-\t/* applications.  This is basically a spin lock.\t\t\t*/\n-     extern pthread_t GC_lock_holder;\n-     extern void GC_lock(void);\n-\t/* Allocation lock holder.  Only set if acquired by client through */\n-\t/* GC_call_with_alloc_lock.\t\t\t\t\t   */\n-#    define SET_LOCK_HOLDER() GC_lock_holder = pthread_self()\n-#    define NO_THREAD (pthread_t)(-1)\n-#    define UNSET_LOCK_HOLDER() GC_lock_holder = NO_THREAD\n-#    define I_HOLD_LOCK() (pthread_equal(GC_lock_holder, pthread_self()))\n-#    ifdef HPUX_THREADS\n-#      define LOCK() { if (!GC_test_and_clear(&GC_allocate_lock)) GC_lock(); }\n-       /* The following is INCORRECT, since the memory model is too weak. */\n-#      define UNLOCK() { GC_noop1((word)&GC_allocate_lock); \\\n-\t\t\t*(volatile unsigned long *)(&GC_allocate_lock) = 1; }\n-#    else\n-#      define LOCK() { if (GC_test_and_set(&GC_allocate_lock, 1)) GC_lock(); }\n-#      if __mips >= 3 && (defined (_ABIN32) || defined(_ABI64)) \\\n-\t   && defined(_COMPILER_VERSION) && _COMPILER_VERSION >= 700\n-#\t    define UNLOCK() __lock_release(&GC_allocate_lock)\n-#      else\n-\t    /* The function call in the following should prevent the\t*/\n-\t    /* compiler from moving assignments to below the UNLOCK.\t*/\n-\t    /* This is probably not necessary for ucode or gcc 2.8.\t*/\n-\t    /* It may be necessary for Ragnarok and future gcc\t\t*/\n-\t    /* versions.\t\t\t\t\t\t*/\n-#           define UNLOCK() { GC_noop1((word)&GC_allocate_lock); \\\n-\t\t\t*(volatile unsigned long *)(&GC_allocate_lock) = 0; }\n-#      endif\n-#    endif\n-     extern VOLATILE GC_bool GC_collecting;\n-#    define ENTER_GC() \\\n-\t\t{ \\\n-\t\t    GC_collecting = 1; \\\n-\t\t}\n-#    define EXIT_GC() GC_collecting = 0;\n-#  endif /* IRIX_THREADS || IRIX_JDK_THREADS */\n-#  ifdef WIN32_THREADS\n-#    include <windows.h>\n-     GC_API CRITICAL_SECTION GC_allocate_ml;\n-#    define LOCK() EnterCriticalSection(&GC_allocate_ml);\n-#    define UNLOCK() LeaveCriticalSection(&GC_allocate_ml);\n-#  endif\n-#  ifndef SET_LOCK_HOLDER\n-#      define SET_LOCK_HOLDER()\n-#      define UNSET_LOCK_HOLDER()\n-#      define I_HOLD_LOCK() FALSE\n-\t\t/* Used on platforms were locks can be reacquired,\t*/\n-\t\t/* so it doesn't matter if we lie.\t\t\t*/\n-#  endif\n-# else\n-#    define LOCK()\n-#    define UNLOCK()\n-# endif\n-# ifndef SET_LOCK_HOLDER\n-#   define SET_LOCK_HOLDER()\n-#   define UNSET_LOCK_HOLDER()\n-#   define I_HOLD_LOCK() FALSE\n-\t\t/* Used on platforms were locks can be reacquired,\t*/\n-\t\t/* so it doesn't matter if we lie.\t\t\t*/\n-# endif\n-# ifndef ENTER_GC\n-#   define ENTER_GC()\n-#   define EXIT_GC()\n-# endif\n-\n-# ifndef DCL_LOCK_STATE\n-#   define DCL_LOCK_STATE\n-# endif\n-# ifndef FASTLOCK\n-#   define FASTLOCK() LOCK()\n-#   define FASTLOCK_SUCCEEDED() TRUE\n-#   define FASTUNLOCK() UNLOCK()\n-# endif\n-\n-/* Delay any interrupts or signals that may abort this thread.  Data\t*/\n-/* structures are in a consistent state outside this pair of calls.\t*/\n-/* ANSI C allows both to be empty (though the standard isn't very\t*/\n-/* clear on that point).  Standard malloc implementations are usually\t*/\n-/* neither interruptable nor thread-safe, and thus correspond to\t*/\n-/* empty definitions.\t\t\t\t\t\t\t*/\n-# ifdef PCR\n-#   define DISABLE_SIGNALS() \\\n-\t\t PCR_Th_SetSigMask(PCR_allSigsBlocked,&GC_old_sig_mask)\n-#   define ENABLE_SIGNALS() \\\n-\t\tPCR_Th_SetSigMask(&GC_old_sig_mask, NIL)\n-# else\n-#   if defined(SRC_M3) || defined(AMIGA) || defined(SOLARIS_THREADS) \\\n-\t|| defined(MSWIN32) || defined(MACOS) || defined(DJGPP) \\\n-\t|| defined(NO_SIGNALS) || defined(IRIX_THREADS) \\\n-\t|| defined(IRIX_JDK_THREADS) || defined(LINUX_THREADS) \n-\t\t\t/* Also useful for debugging.\t\t*/\n-\t/* Should probably use thr_sigsetmask for SOLARIS_THREADS. */\n-#     define DISABLE_SIGNALS()\n-#     define ENABLE_SIGNALS()\n-#   else\n-#     define DISABLE_SIGNALS() GC_disable_signals()\n-\tvoid GC_disable_signals();\n-#     define ENABLE_SIGNALS() GC_enable_signals()\n-\tvoid GC_enable_signals();\n-#   endif\n-# endif\n-\n-/*\n- * Stop and restart mutator threads.\n- */\n-# ifdef PCR\n-#     include \"th/PCR_ThCtl.h\"\n-#     define STOP_WORLD() \\\n- \tPCR_ThCtl_SetExclusiveMode(PCR_ThCtl_ExclusiveMode_stopNormal, \\\n- \t\t\t\t   PCR_allSigsBlocked, \\\n- \t\t\t\t   PCR_waitForever)\n-#     define START_WORLD() \\\n-\tPCR_ThCtl_SetExclusiveMode(PCR_ThCtl_ExclusiveMode_null, \\\n- \t\t\t\t   PCR_allSigsBlocked, \\\n- \t\t\t\t   PCR_waitForever);\n-# else\n-#   if defined(SOLARIS_THREADS) || defined(WIN32_THREADS) \\\n-\t|| defined(IRIX_THREADS) || defined(LINUX_THREADS) \\\n-\t|| defined(IRIX_JDK_THREADS) || defined(HPUX_THREADS)\n-      void GC_stop_world();\n-      void GC_start_world();\n-#     define STOP_WORLD() GC_stop_world()\n-#     define START_WORLD() GC_start_world()\n-#   else\n-#     define STOP_WORLD()\n-#     define START_WORLD()\n-#   endif\n-# endif\n-\n-/* Abandon ship */\n-# ifdef PCR\n-#   define ABORT(s) PCR_Base_Panic(s)\n-# else\n-#   ifdef SMALL_CONFIG\n-#\tdefine ABORT(msg) abort();\n-#   else\n-\tGC_API void GC_abort();\n-#       define ABORT(msg) GC_abort(msg);\n-#   endif\n-# endif\n-\n-/* Exit abnormally, but without making a mess (e.g. out of memory) */\n-# ifdef PCR\n-#   define EXIT() PCR_Base_Exit(1,PCR_waitForever)\n-# else\n-#   define EXIT() (void)exit(1)\n-# endif\n-\n-/* Print warning message, e.g. almost out of memory.\t*/\n-# define WARN(msg,arg) (*GC_current_warn_proc)(msg, (GC_word)(arg))\n-extern GC_warn_proc GC_current_warn_proc;\n-\n-/*********************************/\n-/*                               */\n-/* Word-size-dependent defines   */\n-/*                               */\n-/*********************************/\n-\n-#if CPP_WORDSZ == 32\n-#  define WORDS_TO_BYTES(x)   ((x)<<2)\n-#  define BYTES_TO_WORDS(x)   ((x)>>2)\n-#  define LOGWL               ((word)5)    /* log[2] of CPP_WORDSZ */\n-#  define modWORDSZ(n) ((n) & 0x1f)        /* n mod size of word\t    */\n-#  if ALIGNMENT != 4\n-#\tdefine UNALIGNED\n-#  endif\n-#endif\n-\n-#if CPP_WORDSZ == 64\n-#  define WORDS_TO_BYTES(x)   ((x)<<3)\n-#  define BYTES_TO_WORDS(x)   ((x)>>3)\n-#  define LOGWL               ((word)6)    /* log[2] of CPP_WORDSZ */\n-#  define modWORDSZ(n) ((n) & 0x3f)        /* n mod size of word\t    */\n-#  if ALIGNMENT != 8\n-#\tdefine UNALIGNED\n-#  endif\n-#endif\n-\n-#define WORDSZ ((word)CPP_WORDSZ)\n-#define SIGNB  ((word)1 << (WORDSZ-1))\n-#define BYTES_PER_WORD      ((word)(sizeof (word)))\n-#define ONES                ((word)(-1))\n-#define divWORDSZ(n) ((n) >> LOGWL)\t   /* divide n by size of word      */\n-\n-/*********************/\n-/*                   */\n-/*  Size Parameters  */\n-/*                   */\n-/*********************/\n-\n-/*  heap block size, bytes. Should be power of 2 */\n-\n-#ifndef HBLKSIZE\n-# ifdef SMALL_CONFIG\n-#   define CPP_LOG_HBLKSIZE 10\n-# else\n-#   if CPP_WORDSZ == 32\n-#     define CPP_LOG_HBLKSIZE 12\n-#   else\n-#     define CPP_LOG_HBLKSIZE 13\n-#   endif\n-# endif\n-#else\n-# if HBLKSIZE == 512\n-#   define CPP_LOG_HBLKSIZE 9\n-# endif\n-# if HBLKSIZE == 1024\n-#   define CPP_LOG_HBLKSIZE 10\n-# endif\n-# if HBLKSIZE == 2048\n-#   define CPP_LOG_HBLKSIZE 11\n-# endif\n-# if HBLKSIZE == 4096\n-#   define CPP_LOG_HBLKSIZE 12\n-# endif\n-# if HBLKSIZE == 8192\n-#   define CPP_LOG_HBLKSIZE 13\n-# endif\n-# if HBLKSIZE == 16384\n-#   define CPP_LOG_HBLKSIZE 14\n-# endif\n-# ifndef CPP_LOG_HBLKSIZE\n-    --> fix HBLKSIZE\n-# endif\n-# undef HBLKSIZE\n-#endif\n-# define CPP_HBLKSIZE (1 << CPP_LOG_HBLKSIZE)\n-# define LOG_HBLKSIZE   ((word)CPP_LOG_HBLKSIZE)\n-# define HBLKSIZE ((word)CPP_HBLKSIZE)\n-\n-\n-/*  max size objects supported by freelist (larger objects may be   */\n-/*  allocated, but less efficiently)                                */\n-\n-#define CPP_MAXOBJSZ    BYTES_TO_WORDS(CPP_HBLKSIZE/2)\n-#define MAXOBJSZ ((word)CPP_MAXOBJSZ)\n-\t\t\n-# define divHBLKSZ(n) ((n) >> LOG_HBLKSIZE)\n-\n-# define HBLK_PTR_DIFF(p,q) divHBLKSZ((ptr_t)p - (ptr_t)q)\n-\t/* Equivalent to subtracting 2 hblk pointers.\t*/\n-\t/* We do it this way because a compiler should\t*/\n-\t/* find it hard to use an integer division\t*/\n-\t/* instead of a shift.  The bundled SunOS 4.1\t*/\n-\t/* o.w. sometimes pessimizes the subtraction to\t*/\n-\t/* involve a call to .div.\t\t\t*/\n- \n-# define modHBLKSZ(n) ((n) & (HBLKSIZE-1))\n- \n-# define HBLKPTR(objptr) ((struct hblk *)(((word) (objptr)) & ~(HBLKSIZE-1)))\n-\n-# define HBLKDISPL(objptr) (((word) (objptr)) & (HBLKSIZE-1))\n-\n-/* Round up byte allocation requests to integral number of words, etc. */\n-# ifdef ADD_BYTE_AT_END\n-#   define ROUNDED_UP_WORDS(n) BYTES_TO_WORDS((n) + WORDS_TO_BYTES(1))\n-#   ifdef ALIGN_DOUBLE\n-#       define ALIGNED_WORDS(n) (BYTES_TO_WORDS((n) + WORDS_TO_BYTES(2)) & ~1)\n-#   else\n-#       define ALIGNED_WORDS(n) ROUNDED_UP_WORDS(n)\n-#   endif\n-#   define SMALL_OBJ(bytes) ((bytes) < WORDS_TO_BYTES(MAXOBJSZ))\n-#   define ADD_SLOP(bytes) ((bytes)+1)\n-# else\n-#   define ROUNDED_UP_WORDS(n) BYTES_TO_WORDS((n) + (WORDS_TO_BYTES(1) - 1))\n-#   ifdef ALIGN_DOUBLE\n-#       define ALIGNED_WORDS(n) \\\n-\t\t\t(BYTES_TO_WORDS((n) + WORDS_TO_BYTES(2) - 1) & ~1)\n-#   else\n-#       define ALIGNED_WORDS(n) ROUNDED_UP_WORDS(n)\n-#   endif\n-#   define SMALL_OBJ(bytes) ((bytes) <= WORDS_TO_BYTES(MAXOBJSZ))\n-#   define ADD_SLOP(bytes) (bytes)\n-# endif\n-# ifndef MIN_WORDS\n-    /* MIN_WORDS is the size of the smallest allocated object.\t*/\n-    /* 1 and 2 are the only valid values.\t\t\t*/\n-    /* 2 must be used if:\t\t\t\t\t*/\n-    /* - GC_gcj_malloc can be used for objects of requested\t*/\n-    /*   size smaller than 2 words\t\t\t\t*/\n-#   if defined(GC_GCJ_SUPPORT)\n-#     define MIN_WORDS 2   \t/* Smallest allocated object.\t*/\n-#   else\n-#     define MIN_WORDS 1\n-#   endif\n-# endif\n-\n-\n-/*\n- * Hash table representation of sets of pages.  This assumes it is\n- * OK to add spurious entries to sets.\n- * Used by black-listing code, and perhaps by dirty bit maintenance code.\n- */\n- \n-# ifdef LARGE_CONFIG\n-#   define LOG_PHT_ENTRIES  17\n-# else\n-#   define LOG_PHT_ENTRIES  14\t/* Collisions are likely if heap grows\t*/\n-\t\t\t\t/* to more than 16K hblks = 64MB.\t*/\n-\t\t\t\t/* Each hash table occupies 2K bytes.   */\n-# endif\n-# define PHT_ENTRIES ((word)1 << LOG_PHT_ENTRIES)\n-# define PHT_SIZE (PHT_ENTRIES >> LOGWL)\n-typedef word page_hash_table[PHT_SIZE];\n-\n-# define PHT_HASH(addr) ((((word)(addr)) >> LOG_HBLKSIZE) & (PHT_ENTRIES - 1))\n-\n-# define get_pht_entry_from_index(bl, index) \\\n-\t\t(((bl)[divWORDSZ(index)] >> modWORDSZ(index)) & 1)\n-# define set_pht_entry_from_index(bl, index) \\\n-\t\t(bl)[divWORDSZ(index)] |= (word)1 << modWORDSZ(index)\n-# define clear_pht_entry_from_index(bl, index) \\\n-\t\t(bl)[divWORDSZ(index)] &= ~((word)1 << modWORDSZ(index))\n-\t\n-\n-\n-/********************************************/\n-/*                                          */\n-/*    H e a p   B l o c k s                 */\n-/*                                          */\n-/********************************************/\n-\n-/*  heap block header */\n-#define HBLKMASK   (HBLKSIZE-1)\n-\n-#define BITS_PER_HBLK (HBLKSIZE * 8)\n-\n-#define MARK_BITS_PER_HBLK (BITS_PER_HBLK/CPP_WORDSZ)\n-\t   /* upper bound                                    */\n-\t   /* We allocate 1 bit/word.  Only the first word   */\n-\t   /* in each object is actually marked.             */\n-\n-# ifdef ALIGN_DOUBLE\n-#   define MARK_BITS_SZ (((MARK_BITS_PER_HBLK + 2*CPP_WORDSZ - 1) \\\n-\t\t\t  / (2*CPP_WORDSZ))*2)\n-# else\n-#   define MARK_BITS_SZ ((MARK_BITS_PER_HBLK + CPP_WORDSZ - 1)/CPP_WORDSZ)\n-# endif\n-\t   /* Upper bound on number of mark words per heap block  */\n-\n-struct hblkhdr {\n-    word hb_sz;  /* If in use, size in words, of objects in the block. */\n-\t\t /* if free, the size in bytes of the whole block      */\n-    struct hblk * hb_next; \t/* Link field for hblk free list\t */\n-    \t\t\t\t/* and for lists of chunks waiting to be */\n-    \t\t\t\t/* reclaimed.\t\t\t\t */\n-    struct hblk * hb_prev;\t/* Backwards link for free list.\t*/\n-    word hb_descr;   \t\t/* object descriptor for marking.  See\t*/\n-    \t\t\t\t/* mark.h.\t\t\t\t*/\n-    char* hb_map;\t/* A pointer to a pointer validity map of the block. */\n-    \t\t      \t/* See GC_obj_map.\t\t\t\t     */\n-    \t\t     \t/* Valid for all blocks with headers.\t\t     */\n-    \t\t     \t/* Free blocks point to GC_invalid_map.\t\t     */\n-    unsigned char hb_obj_kind;\n-    \t\t\t /* Kind of objects in the block.  Each kind \t*/\n-    \t\t\t /* identifies a mark procedure and a set of \t*/\n-    \t\t\t /* list headers.  Sometimes called regions.\t*/\n-    unsigned char hb_flags;\n-#\tdefine IGNORE_OFF_PAGE\t1\t/* Ignore pointers that do not\t*/\n-\t\t\t\t\t/* point to the first page of \t*/\n-\t\t\t\t\t/* this object.\t\t\t*/\n-#\tdefine WAS_UNMAPPED 2\t/* This is a free block, which has\t*/\n-\t\t\t\t/* been unmapped from the address \t*/\n-\t\t\t\t/* space.\t\t\t\t*/\n-\t\t\t\t/* GC_remap must be invoked on it\t*/\n-\t\t\t\t/* before it can be reallocated.\t*/\n-\t\t\t\t/* Only set with USE_MUNMAP.\t\t*/\n-    unsigned short hb_last_reclaimed;\n-    \t\t\t\t/* Value of GC_gc_no when block was\t*/\n-    \t\t\t\t/* last allocated or swept. May wrap.   */\n-\t\t\t\t/* For a free block, this is maintained */\n-\t\t\t\t/* unly for USE_MUNMAP, and indicates\t*/\n-\t\t\t\t/* when the header was allocated, or\t*/\n-\t\t\t\t/* when the size of the block last\t*/\n-\t\t\t\t/* changed.\t\t\t\t*/\n-    word hb_marks[MARK_BITS_SZ];\n-\t\t\t    /* Bit i in the array refers to the             */\n-\t\t\t    /* object starting at the ith word (header      */\n-\t\t\t    /* INCLUDED) in the heap block.                 */\n-\t\t\t    /* The lsb of word 0 is numbered 0.\t\t    */\n-\t\t\t    /* Unused bits are invalid, and are \t    */\n-\t\t\t    /* occasionally set, e.g for uncollectable\t    */\n-\t\t\t    /* objects.\t\t\t\t\t    */\n-};\n-\n-/*  heap block body */\n-\n-# define DISCARD_WORDS 0\n-\t/* Number of words to be dropped at the beginning of each block\t*/\n-\t/* Must be a multiple of WORDSZ.  May reasonably be nonzero\t*/\n-\t/* on machines that don't guarantee longword alignment of\t*/\n-\t/* pointers, so that the number of false hits is minimized.\t*/\n-\t/* 0 and WORDSZ are probably the only reasonable values.\t*/\n-\n-# define BODY_SZ ((HBLKSIZE-WORDS_TO_BYTES(DISCARD_WORDS))/sizeof(word))\n-\n-struct hblk {\n-#   if (DISCARD_WORDS != 0)\n-        word garbage[DISCARD_WORDS];\n-#   endif\n-    word hb_body[BODY_SZ];\n-};\n-\n-# define HDR_WORDS ((word)DISCARD_WORDS)\n-# define HDR_BYTES ((word)WORDS_TO_BYTES(DISCARD_WORDS))\n-\n-# define OBJ_SZ_TO_BLOCKS(sz) \\\n-    divHBLKSZ(HDR_BYTES + WORDS_TO_BYTES(sz) + HBLKSIZE-1)\n-    /* Size of block (in units of HBLKSIZE) needed to hold objects of\t*/\n-    /* given sz (in words).\t\t\t\t\t\t*/\n-\n-/* Object free list link */\n-# define obj_link(p) (*(ptr_t *)(p))\n-\n-/* The type of mark procedures.  This really belongs in gc_mark.h.\t*/\n-/* But we put it here, so that we can avoid scanning the mark proc\t*/\n-/* table.\t\t\t\t\t\t\t\t*/\n-typedef struct ms_entry * (*mark_proc)(/* word * addr,\n-\t\t\t\t\t  struct ms_entry *mark_stack_ptr,\n-\t\t\t\t\t  struct ms_entry *mark_stack_limit,\n-\t\t\t\t\t  word env */);\n-# define LOG_MAX_MARK_PROCS 6\n-# define MAX_MARK_PROCS (1 << LOG_MAX_MARK_PROCS)\n-\n-/* Root sets.  Logically private to mark_rts.c.  But we don't want the\t*/\n-/* tables scanned, so we put them here.\t\t\t\t\t*/\n-/* MAX_ROOT_SETS is the maximum number of ranges that can be \t*/\n-/* registered as static roots. \t\t\t\t\t*/\n-# ifdef LARGE_CONFIG\n-#   define MAX_ROOT_SETS 4096\n-# else\n-#   ifdef PCR\n-#     define MAX_ROOT_SETS 1024\n-#   else\n-#     ifdef MSWIN32\n-#\tdefine MAX_ROOT_SETS 512\n-\t    /* Under NT, we add only written pages, which can result \t*/\n-\t    /* in many small root sets.\t\t\t\t\t*/\n-#     else\n-#       define MAX_ROOT_SETS 64\n-#     endif\n-#   endif\n-# endif\n-\n-# define MAX_EXCLUSIONS (MAX_ROOT_SETS/4)\n-/* Maximum number of segments that can be excluded from root sets.\t*/\n-\n-/*\n- * Data structure for excluded static roots.\n- */\n-struct exclusion {\n-    ptr_t e_start;\n-    ptr_t e_end;\n-};\n-\n-/* Data structure for list of root sets.\t\t\t\t*/\n-/* We keep a hash table, so that we can filter out duplicate additions.\t*/\n-/* Under Win32, we need to do a better job of filtering overlaps, so\t*/\n-/* we resort to sequential search, and pay the price.\t\t\t*/\n-struct roots {\n-\tptr_t r_start;\n-\tptr_t r_end;\n-#\tifndef MSWIN32\n-\t  struct roots * r_next;\n-#\tendif\n-\tGC_bool r_tmp;\n-\t  \t/* Delete before registering new dynamic libraries */\n-};\n-\n-#ifndef MSWIN32\n-    /* Size of hash table index to roots.\t*/\n-#   define LOG_RT_SIZE 6\n-#   define RT_SIZE (1 << LOG_RT_SIZE) /* Power of 2, may be != MAX_ROOT_SETS */\n-#endif\n-\n-/* Lists of all heap blocks and free lists\t*/\n-/* as well as other random data structures\t*/\n-/* that should not be scanned by the\t\t*/\n-/* collector.\t\t\t\t\t*/\n-/* These are grouped together in a struct\t*/\n-/* so that they can be easily skipped by the\t*/\n-/* GC_mark routine.\t\t\t\t*/\n-/* The ordering is weird to make GC_malloc\t*/\n-/* faster by keeping the important fields\t*/\n-/* sufficiently close together that a\t\t*/\n-/* single load of a base register will do.\t*/\n-/* Scalars that could easily appear to\t\t*/\n-/* be pointers are also put here.\t\t*/\n-/* The main fields should precede any \t\t*/\n-/* conditionally included fields, so that\t*/\n-/* gc_inl.h will work even if a different set\t*/\n-/* of macros is defined when the client is\t*/\n-/* compiled.\t\t\t\t\t*/\n-\n-struct _GC_arrays {\n-  word _heapsize;\n-  word _max_heapsize;\n-  word _requested_heapsize;\t/* Heap size due to explicit expansion */\n-  ptr_t _last_heap_addr;\n-  ptr_t _prev_heap_addr;\n-  word _large_free_bytes;\n-\t/* Total bytes contained in blocks on large object free */\n-\t/* list.\t\t\t\t\t\t*/\n-  word _words_allocd_before_gc;\n-\t\t/* Number of words allocated before this\t*/\n-\t\t/* collection cycle.\t\t\t\t*/\n-  word _words_allocd;\n-  \t/* Number of words allocated during this collection cycle */\n-  word _words_wasted;\n-  \t/* Number of words wasted due to internal fragmentation\t*/\n-  \t/* in large objects, or due to dropping blacklisted     */\n-\t/* blocks, since last gc.  Approximate.                 */\n-  word _words_finalized;\n-  \t/* Approximate number of words in objects (and headers)\t*/\n-  \t/* That became ready for finalization in the last \t*/\n-  \t/* collection.\t\t\t\t\t\t*/\n-  word _non_gc_bytes_at_gc;\n-  \t/* Number of explicitly managed bytes of storage \t*/\n-  \t/* at last collection.\t\t\t\t\t*/\n-  word _mem_freed;\n-  \t/* Number of explicitly deallocated words of memory\t*/\n-  \t/* since last collection.\t\t\t\t*/\n-  ptr_t _scratch_end_ptr;\n-  ptr_t _scratch_last_end_ptr;\n-\t/* Used by headers.c, and can easily appear to point to\t*/\n-\t/* heap.\t\t\t\t\t\t*/\n-  mark_proc _mark_procs[MAX_MARK_PROCS];\n-  \t/* Table of user-defined mark procedures.  There is\t*/\n-\t/* a small number of these, which can be referenced\t*/\n-\t/* by DS_PROC mark descriptors.  See gc_mark.h.\t\t*/\n-  ptr_t _objfreelist[MAXOBJSZ+1];\n-\t\t\t  /* free list for objects */\n-  ptr_t _aobjfreelist[MAXOBJSZ+1];\n-\t\t\t  /* free list for atomic objs \t*/\n-\n-  ptr_t _uobjfreelist[MAXOBJSZ+1];\n-\t\t\t  /* uncollectable but traced objs \t*/\n-\t\t\t  /* objects on this and auobjfreelist  */\n-\t\t\t  /* are always marked, except during   */\n-\t\t\t  /* garbage collections.\t\t*/\n-# ifdef ATOMIC_UNCOLLECTABLE\n-    ptr_t _auobjfreelist[MAXOBJSZ+1];\n-# endif\n-\t\t\t  /* uncollectable but traced objs \t*/\n-\n-# ifdef GATHERSTATS\n-    word _composite_in_use;\n-   \t\t/* Number of words in accessible composite\t*/\n-\t\t/* objects.\t\t\t\t\t*/\n-    word _atomic_in_use;\n-   \t\t/* Number of words in accessible atomic\t\t*/\n-\t\t/* objects.\t\t\t\t\t*/\n-# endif\n-# ifdef USE_MUNMAP\n-    word _unmapped_bytes;\n-# endif\n-# ifdef MERGE_SIZES\n-    unsigned _size_map[WORDS_TO_BYTES(MAXOBJSZ+1)];\n-    \t/* Number of words to allocate for a given allocation request in */\n-    \t/* bytes.\t\t\t\t\t\t\t */\n-# endif \n-\n-# ifdef STUBBORN_ALLOC\n-    ptr_t _sobjfreelist[MAXOBJSZ+1];\n-# endif\n-  \t\t\t  /* free list for immutable objects\t*/\n-  ptr_t _obj_map[MAXOBJSZ+1];\n-                       /* If not NIL, then a pointer to a map of valid  */\n-    \t\t       /* object addresses. _obj_map[sz][i] is j if the\t*/\n-    \t\t       /* address block_start+i is a valid pointer      */\n-    \t\t       /* to an object at\t\t\t\t*/\n-    \t\t       /* block_start+i&~3 - WORDS_TO_BYTES(j).\t\t*/\n-    \t\t       /* (If ALL_INTERIOR_POINTERS is defined, then\t*/\n-    \t\t       /* instead ((short *)(hb_map[sz])[i] is j if\t*/\n-    \t\t       /* block_start+WORDS_TO_BYTES(i) is in the\t*/\n-    \t\t       /* interior of an object starting at\t\t*/\n-    \t\t       /* block_start+WORDS_TO_BYTES(i-j)).\t\t*/\n-    \t\t       /* It is OBJ_INVALID if\t\t\t\t*/\n-    \t\t       /* block_start+WORDS_TO_BYTES(i) is not\t\t*/\n-    \t\t       /* valid as a pointer to an object.              */\n-    \t\t       /* We assume all values of j <= OBJ_INVALID.\t*/\n-    \t\t       /* The zeroth entry corresponds to large objects.*/\n-#   ifdef ALL_INTERIOR_POINTERS\n-#\tdefine map_entry_type short\n-#       define OBJ_INVALID 0x7fff\n-#\tdefine MAP_ENTRY(map, bytes) \\\n-\t\t(((map_entry_type *)(map))[BYTES_TO_WORDS(bytes)])\n-#\tdefine MAP_ENTRIES BYTES_TO_WORDS(HBLKSIZE)\n-#\tdefine MAP_SIZE (MAP_ENTRIES * sizeof(map_entry_type))\n-#\tdefine OFFSET_VALID(displ) TRUE\n-#\tdefine CPP_MAX_OFFSET (HBLKSIZE - HDR_BYTES - 1)\n-#\tdefine MAX_OFFSET ((word)CPP_MAX_OFFSET)\n-#   else\n-#\tdefine map_entry_type char\n-#       define OBJ_INVALID 0x7f\n-#\tdefine MAP_ENTRY(map, bytes) \\\n-\t\t(map)[bytes]\n-#\tdefine MAP_ENTRIES HBLKSIZE\n-#\tdefine MAP_SIZE MAP_ENTRIES\n-#\tdefine CPP_MAX_OFFSET (WORDS_TO_BYTES(OBJ_INVALID) - 1)\t\n-#\tdefine MAX_OFFSET ((word)CPP_MAX_OFFSET)\n-# \tdefine VALID_OFFSET_SZ \\\n-\t  (CPP_MAX_OFFSET > WORDS_TO_BYTES(CPP_MAXOBJSZ)? \\\n-\t   CPP_MAX_OFFSET+1 \\\n-\t   : WORDS_TO_BYTES(CPP_MAXOBJSZ)+1)\n-  \tchar _valid_offsets[VALID_OFFSET_SZ];\n-\t\t\t\t/* GC_valid_offsets[i] == TRUE ==> i \t*/\n-\t\t\t\t/* is registered as a displacement.\t*/\n-#\tdefine OFFSET_VALID(displ) GC_valid_offsets[displ]\n-  \tchar _modws_valid_offsets[sizeof(word)];\n-\t\t\t\t/* GC_valid_offsets[i] ==>\t\t  */\n-\t\t\t\t/* GC_modws_valid_offsets[i%sizeof(word)] */\n-#   endif\n-# ifdef STUBBORN_ALLOC\n-    page_hash_table _changed_pages;\n-        /* Stubborn object pages that were changes since last call to\t*/\n-\t/* GC_read_changed.\t\t\t\t\t\t*/\n-    page_hash_table _prev_changed_pages;\n-        /* Stubborn object pages that were changes before last call to\t*/\n-\t/* GC_read_changed.\t\t\t\t\t\t*/\n-# endif\n-# if defined(PROC_VDB) || defined(MPROTECT_VDB)\n-    page_hash_table _grungy_pages; /* Pages that were dirty at last \t   */\n-\t\t\t\t     /* GC_read_dirty.\t\t\t   */\n-# endif\n-# ifdef MPROTECT_VDB\n-    VOLATILE page_hash_table _dirty_pages;\t\n-\t\t\t/* Pages dirtied since last GC_read_dirty. */\n-# endif\n-# ifdef PROC_VDB\n-    page_hash_table _written_pages;\t/* Pages ever dirtied\t*/\n-# endif\n-# ifdef LARGE_CONFIG\n-#   if CPP_WORDSZ > 32\n-#     define MAX_HEAP_SECTS 4096 \t/* overflows at roughly 64 GB\t   */\n-#   else\n-#     define MAX_HEAP_SECTS 768\t\t/* Separately added heap sections. */\n-#   endif\n-# else\n-#   define MAX_HEAP_SECTS 256\n-# endif\n-  struct HeapSect {\n-      ptr_t hs_start; word hs_bytes;\n-  } _heap_sects[MAX_HEAP_SECTS];\n-# ifdef MSWIN32\n-    ptr_t _heap_bases[MAX_HEAP_SECTS];\n-    \t\t/* Start address of memory regions obtained from kernel. */\n-# endif\n-  struct roots _static_roots[MAX_ROOT_SETS];\n-# ifndef MSWIN32\n-    struct roots * _root_index[RT_SIZE];\n-# endif\n-  struct exclusion _excl_table[MAX_EXCLUSIONS];\n-  /* Block header index; see gc_headers.h */\n-  bottom_index * _all_nils;\n-  bottom_index * _top_index [TOP_SZ];\n-#ifdef SAVE_CALL_CHAIN\n-  struct callinfo _last_stack[NFRAMES];\t/* Stack at last garbage collection.*/\n-  \t\t\t\t\t/* Useful for debugging\tmysterious  */\n-  \t\t\t\t\t/* object disappearances.\t    */\n-  \t\t\t\t\t/* In the multithreaded case, we    */\n-  \t\t\t\t\t/* currently only save the calling  */\n-  \t\t\t\t\t/* stack.\t\t\t    */\n-#endif\n-};\n-\n-GC_API GC_FAR struct _GC_arrays GC_arrays; \n-\n-# define GC_objfreelist GC_arrays._objfreelist\n-# define GC_aobjfreelist GC_arrays._aobjfreelist\n-# define GC_uobjfreelist GC_arrays._uobjfreelist\n-# ifdef ATOMIC_UNCOLLECTABLE\n-#   define GC_auobjfreelist GC_arrays._auobjfreelist\n-# endif\n-# define GC_sobjfreelist GC_arrays._sobjfreelist\n-# define GC_valid_offsets GC_arrays._valid_offsets\n-# define GC_modws_valid_offsets GC_arrays._modws_valid_offsets\n-# ifdef STUBBORN_ALLOC\n-#    define GC_changed_pages GC_arrays._changed_pages\n-#    define GC_prev_changed_pages GC_arrays._prev_changed_pages\n-# endif\n-# define GC_obj_map GC_arrays._obj_map\n-# define GC_last_heap_addr GC_arrays._last_heap_addr\n-# define GC_prev_heap_addr GC_arrays._prev_heap_addr\n-# define GC_words_allocd GC_arrays._words_allocd\n-# define GC_words_wasted GC_arrays._words_wasted\n-# define GC_large_free_bytes GC_arrays._large_free_bytes\n-# define GC_words_finalized GC_arrays._words_finalized\n-# define GC_non_gc_bytes_at_gc GC_arrays._non_gc_bytes_at_gc\n-# define GC_mem_freed GC_arrays._mem_freed\n-# define GC_scratch_end_ptr GC_arrays._scratch_end_ptr\n-# define GC_scratch_last_end_ptr GC_arrays._scratch_last_end_ptr\n-# define GC_mark_procs GC_arrays._mark_procs\n-# define GC_heapsize GC_arrays._heapsize\n-# define GC_max_heapsize GC_arrays._max_heapsize\n-# define GC_requested_heapsize GC_arrays._requested_heapsize\n-# define GC_words_allocd_before_gc GC_arrays._words_allocd_before_gc\n-# define GC_heap_sects GC_arrays._heap_sects\n-# define GC_last_stack GC_arrays._last_stack\n-# ifdef USE_MUNMAP\n-#   define GC_unmapped_bytes GC_arrays._unmapped_bytes\n-# endif\n-# ifdef MSWIN32\n-#   define GC_heap_bases GC_arrays._heap_bases\n-# endif\n-# define GC_static_roots GC_arrays._static_roots\n-# define GC_root_index GC_arrays._root_index\n-# define GC_excl_table GC_arrays._excl_table\n-# define GC_all_nils GC_arrays._all_nils\n-# define GC_top_index GC_arrays._top_index\n-# if defined(PROC_VDB) || defined(MPROTECT_VDB)\n-#   define GC_grungy_pages GC_arrays._grungy_pages\n-# endif\n-# ifdef MPROTECT_VDB\n-#   define GC_dirty_pages GC_arrays._dirty_pages\n-# endif\n-# ifdef PROC_VDB\n-#   define GC_written_pages GC_arrays._written_pages\n-# endif\n-# ifdef GATHERSTATS\n-#   define GC_composite_in_use GC_arrays._composite_in_use\n-#   define GC_atomic_in_use GC_arrays._atomic_in_use\n-# endif\n-# ifdef MERGE_SIZES\n-#   define GC_size_map GC_arrays._size_map\n-# endif\n-\n-# define beginGC_arrays ((ptr_t)(&GC_arrays))\n-# define endGC_arrays (((ptr_t)(&GC_arrays)) + (sizeof GC_arrays))\n-\n-#define USED_HEAP_SIZE (GC_heapsize - GC_large_free_bytes)\n-\n-/* Object kinds: */\n-# define MAXOBJKINDS 16\n-\n-extern struct obj_kind {\n-   ptr_t *ok_freelist;\t/* Array of free listheaders for this kind of object */\n-   \t\t\t/* Point either to GC_arrays or to storage allocated */\n-   \t\t\t/* with GC_scratch_alloc.\t\t\t     */\n-   struct hblk **ok_reclaim_list;\n-   \t\t\t/* List headers for lists of blocks waiting to be */\n-   \t\t\t/* swept.\t\t\t\t\t  */\n-   word ok_descriptor;  /* Descriptor template for objects in this\t*/\n-   \t\t\t/* block.\t\t\t\t\t*/\n-   GC_bool ok_relocate_descr;\n-   \t\t\t/* Add object size in bytes to descriptor \t*/\n-   \t\t\t/* template to obtain descriptor.  Otherwise\t*/\n-   \t\t\t/* template is used as is.\t\t\t*/\n-   GC_bool ok_init;   /* Clear objects before putting them on the free list. */\n-} GC_obj_kinds[MAXOBJKINDS];\n-\n-# define endGC_obj_kinds (((ptr_t)(&GC_obj_kinds)) + (sizeof GC_obj_kinds))\n-\n-# define end_gc_area ((ptr_t)endGC_arrays == (ptr_t)(&GC_obj_kinds) ? \\\n-\t\t\tendGC_obj_kinds : endGC_arrays)\n-\n-/* Predefined kinds: */\n-# define PTRFREE 0\n-# define NORMAL  1\n-# define UNCOLLECTABLE 2\n-# ifdef ATOMIC_UNCOLLECTABLE\n-#   define AUNCOLLECTABLE 3\n-#   define STUBBORN 4\n-#   define IS_UNCOLLECTABLE(k) (((k) & ~1) == UNCOLLECTABLE)\n-# else\n-#   define STUBBORN 3\n-#   define IS_UNCOLLECTABLE(k) ((k) == UNCOLLECTABLE)\n-# endif\n-\n-extern int GC_n_kinds;\n-\n-GC_API word GC_fo_entries;\n-\n-extern word GC_n_heap_sects;\t/* Number of separately added heap\t*/\n-\t\t\t\t/* sections.\t\t\t\t*/\n-\n-extern word GC_page_size;\n-\n-# ifdef MSWIN32\n-extern word GC_n_heap_bases;\t/* See GC_heap_bases.\t*/\n-# endif\n-\n-extern word GC_total_stack_black_listed;\n-\t\t\t/* Number of bytes on stack blacklist. \t*/\n-\n-extern word GC_black_list_spacing;\n-\t\t\t/* Average number of bytes between blacklisted\t*/\n-\t\t\t/* blocks. Approximate.\t\t\t\t*/\n-\t\t\t/* Counts only blocks that are \t\t\t*/\n-\t\t\t/* \"stack-blacklisted\", i.e. that are \t\t*/\n-\t\t\t/* problematic in the interior of an object.\t*/\n-\n-extern char * GC_invalid_map;\n-\t\t\t/* Pointer to the nowhere valid hblk map */\n-\t\t\t/* Blocks pointing to this map are free. */\n-\n-extern struct hblk * GC_hblkfreelist[];\n-\t\t\t\t/* List of completely empty heap blocks\t*/\n-\t\t\t\t/* Linked through hb_next field of \t*/\n-\t\t\t\t/* header structure associated with\t*/\n-\t\t\t\t/* block.\t\t\t\t*/\n-\n-extern GC_bool GC_is_initialized;\t/* GC_init() has been run.\t*/\n-\n-extern GC_bool GC_objects_are_marked;\t/* There are marked objects in  */\n-\t\t\t\t\t/* the heap.\t\t\t*/\n-\n-#ifndef SMALL_CONFIG\n-  extern GC_bool GC_incremental;\n-\t\t\t/* Using incremental/generational collection. */\n-#else\n-# define GC_incremental FALSE\n-\t\t\t/* Hopefully allow optimizer to remove some code. */\n-#endif\n-\n-extern GC_bool GC_dirty_maintained;\n-\t\t\t\t/* Dirty bits are being maintained, \t*/\n-\t\t\t\t/* either for incremental collection,\t*/\n-\t\t\t\t/* or to limit the root set.\t\t*/\n-\n-extern word GC_root_size;\t/* Total size of registered root sections */\n-\n-extern GC_bool GC_debugging_started;\t/* GC_debug_malloc has been called. */ \n-\n-extern ptr_t GC_least_plausible_heap_addr;\n-extern ptr_t GC_greatest_plausible_heap_addr;\n-\t\t\t/* Bounds on the heap.  Guaranteed valid\t*/\n-\t\t\t/* Likely to include future heap expansion.\t*/\n-\t\t\t\n-/* Operations */\n-# ifndef abs\n-#   define abs(x)  ((x) < 0? (-(x)) : (x))\n-# endif\n-\n-\n-/*  Marks are in a reserved area in                          */\n-/*  each heap block.  Each word has one mark bit associated  */\n-/*  with it. Only those corresponding to the beginning of an */\n-/*  object are used.                                         */\n-\n-\n-/* Mark bit operations */\n-\n-/*\n- * Retrieve, set, clear the mark bit corresponding\n- * to the nth word in a given heap block.\n- *\n- * (Recall that bit n corresponds to object beginning at word n\n- * relative to the beginning of the block, including unused words)\n- */\n-\n-# define mark_bit_from_hdr(hhdr,n) (((hhdr)->hb_marks[divWORDSZ(n)] \\\n-\t\t\t    >> (modWORDSZ(n))) & (word)1)\n-# define set_mark_bit_from_hdr(hhdr,n) (hhdr)->hb_marks[divWORDSZ(n)] \\\n-\t\t\t\t|= (word)1 << modWORDSZ(n)\n-\n-# define clear_mark_bit_from_hdr(hhdr,n) (hhdr)->hb_marks[divWORDSZ(n)] \\\n-\t\t\t\t&= ~((word)1 << modWORDSZ(n))\n-\n-/* Important internal collector routines */\n-\n-ptr_t GC_approx_sp();\n-\n-GC_bool GC_should_collect();\n-\n-void GC_apply_to_all_blocks(/*fn, client_data*/);\n-\t\t\t/* Invoke fn(hbp, client_data) for each \t*/\n-\t\t\t/* allocated heap block.\t\t\t*/\n-struct hblk * GC_next_used_block(/* struct hblk * h */);\n-\t\t\t/* Return first in-use block >= h\t*/\n-struct hblk * GC_prev_block(/* struct hblk * h */);\n-\t\t\t/* Return last block <= h.  Returned block\t*/\n-\t\t\t/* is managed by GC, but may or may not be in\t*/\n-\t\t\t/* use.\t\t\t\t\t\t*/\n-void GC_mark_init();\n-void GC_clear_marks();\t/* Clear mark bits for all heap objects. */\n-void GC_invalidate_mark_state();\t/* Tell the marker that\tmarked \t   */\n-\t\t\t\t\t/* objects may point to\tunmarked   */\n-\t\t\t\t\t/* ones, and roots may point to\t   */\n-\t\t\t\t\t/* unmarked objects.\t\t   */\n-\t\t\t\t\t/* Reset mark stack.\t\t   */\n-void GC_mark_from_mark_stack(); /* Mark from everything on the mark stack. */\n-\t\t\t\t/* Return after about one pages worth of   */\n-\t\t\t\t/* work.\t\t\t\t   */\n-GC_bool GC_mark_stack_empty();\n-GC_bool GC_mark_some(/* cold_gc_frame */);\n-\t\t\t/* Perform about one pages worth of marking\t*/\n-\t\t\t/* work of whatever kind is needed.  Returns\t*/\n-\t\t\t/* quickly if no collection is in progress.\t*/\n-\t\t\t/* Return TRUE if mark phase finished.\t\t*/\n-void GC_initiate_gc();\t\t/* initiate collection.\t\t\t*/\n-\t\t\t\t/* If the mark state is invalid, this\t*/\n-\t\t\t\t/* becomes full colleection.  Otherwise */\n-\t\t\t\t/* it's partial.\t\t\t*/\n-void GC_push_all(/*b,t*/);\t/* Push everything in a range \t\t*/\n-\t\t\t\t/* onto mark stack.\t\t\t*/\n-void GC_push_dirty(/*b,t*/);      /* Push all possibly changed\t \t*/\n-\t\t\t\t  /* subintervals of [b,t) onto\t\t*/\n-\t\t\t\t  /* mark stack.\t\t\t*/\n-#ifndef SMALL_CONFIG\n-  void GC_push_conditional(/* ptr_t b, ptr_t t, GC_bool all*/);\n-#else\n-# define GC_push_conditional(b, t, all) GC_push_all(b, t)\n-#endif\n-                                /* Do either of the above, depending\t*/\n-\t\t\t\t/* on the third arg.\t\t\t*/\n-void GC_push_all_stack(/*b,t*/);    /* As above, but consider\t\t*/\n-\t\t\t\t    /*  interior pointers as valid  \t*/\n-void GC_push_all_eager(/*b,t*/);    /* Same as GC_push_all_stack, but   */\n-\t\t\t\t    /* ensures that stack is scanned\t*/\n-\t\t\t\t    /* immediately, not just scheduled  */\n-\t\t\t\t    /* for scanning.\t\t\t*/\n-#ifndef THREADS\n-  void GC_push_all_stack_partially_eager(/* bottom, top, cold_gc_frame */);\n-\t\t\t/* Similar to GC_push_all_eager, but only the\t*/\n-\t\t\t/* part hotter than cold_gc_frame is scanned\t*/\n-\t\t\t/* immediately.  Needed to endure that callee-\t*/\n-\t\t\t/* save registers are not missed.\t\t*/\n-#else\n-  /* In the threads case, we push part of the current thread stack\t*/\n-  /* with GC_push_all_eager when we push the registers.  This gets the  */\n-  /* callee-save registers that may disappear.  The remainder of the\t*/\n-  /* stacks are scheduled for scanning in *GC_push_other_roots, which\t*/\n-  /* is thread-package-specific.\t\t\t\t\t*/\n-#endif\n-void GC_push_current_stack(/* ptr_t cold_gc_frame */);\n-\t\t\t/* Push enough of the current stack eagerly to\t*/\n-\t\t\t/* ensure that callee-save registers saved in\t*/\n-\t\t\t/* GC frames are scanned.\t\t\t*/\n-\t\t\t/* In the non-threads case, schedule entire\t*/\n-\t\t\t/* stack for scanning.\t\t\t\t*/\n-void GC_push_roots(/* GC_bool all, ptr_t cold_gc_frame */);\n-\t\t\t/* Push all or dirty roots.\t*/\n-extern void (*GC_push_other_roots)();\n-\t\t\t/* Push system or application specific roots\t*/\n-\t\t\t/* onto the mark stack.  In some environments\t*/\n-\t\t\t/* (e.g. threads environments) this is\t\t*/\n-\t\t\t/* predfined to be non-zero.  A client supplied */\n-\t\t\t/* replacement should also call the original\t*/\n-\t\t\t/* function.\t\t\t\t\t*/\n-extern void (*GC_start_call_back)(/* void */);\n-\t\t\t/* Called at start of full collections.\t\t*/\n-\t\t\t/* Not called if 0.  Called with allocation \t*/\n-\t\t\t/* lock held.\t\t\t\t\t*/\n-\t\t\t/* 0 by default.\t\t\t\t*/\n-void GC_push_regs();\t/* Push register contents onto mark stack.\t*/\n-\t\t\t/* If NURSERY is defined, the default push\t*/\n-\t\t\t/* action can be overridden with GC_push_proc\t*/\n-void GC_remark();\t/* Mark from all marked objects.  Used\t*/\n-\t\t \t/* only if we had to drop something.\t*/\n-\n-# ifdef NURSERY\n-    extern void (*GC_push_proc)(ptr_t);\n-# endif\n-# if defined(MSWIN32)\n-  void __cdecl GC_push_one();\n-# else\n-  void GC_push_one(/*p*/);    /* If p points to an object, mark it    */\n-                              /* and push contents on the mark stack  */\n-# endif\n-void GC_push_one_checked(/*p*/); /* Ditto, omits plausibility test\t*/\n-void GC_push_marked(/* struct hblk h, hdr * hhdr */);\n-\t\t/* Push contents of all marked objects in h onto\t*/\n-\t\t/* mark stack.\t\t\t\t\t\t*/\n-#ifdef SMALL_CONFIG\n-# define GC_push_next_marked_dirty(h) GC_push_next_marked(h)\n-#else\n-  struct hblk * GC_push_next_marked_dirty(/* h */);\n-\t\t/* Invoke GC_push_marked on next dirty block above h.\t*/\n-\t\t/* Return a pointer just past the end of this block.\t*/\n-#endif /* !SMALL_CONFIG */\n-struct hblk * GC_push_next_marked(/* h */);\n-\t\t/* Ditto, but also mark from clean pages.\t*/\n-struct hblk * GC_push_next_marked_uncollectable(/* h */);\n-\t\t/* Ditto, but mark only from uncollectable pages.\t*/\n-GC_bool GC_stopped_mark(); /* Stop world and mark from all roots\t*/\n-\t\t\t/* and rescuers.\t\t\t*/\n-void GC_clear_hdr_marks(/* hhdr */);  /* Clear the mark bits in a header */\n-void GC_set_hdr_marks(/* hhdr */);  /* Set the mark bits in a header */\n-void GC_add_roots_inner();\n-GC_bool GC_is_static_root(/* ptr_t p */);\n-\t\t/* Is the address p in one of the registered static\t*/\n-\t\t/* root sections?\t\t\t\t\t*/\n-void GC_register_dynamic_libraries();\n-\t\t/* Add dynamic library data sections to the root set. */\n-\n-/* Machine dependent startup routines */\n-ptr_t GC_get_stack_base();\n-void GC_register_data_segments();\n-\n-/* Black listing: */\n-void GC_bl_init(); \t\n-# ifndef ALL_INTERIOR_POINTERS\n-    void GC_add_to_black_list_normal(word /* bits, maybe source */);\n-\t\t\t/* Register bits as a possible future false\t*/\n-\t\t\t/* reference from the heap or static data\t*/\n-#   ifdef PRINT_BLACK_LIST\n-#     define GC_ADD_TO_BLACK_LIST_NORMAL(bits, source) \\\n-\t\t\tGC_add_to_black_list_normal((word) bits, source)\n-#   else\n-#     define GC_ADD_TO_BLACK_LIST_NORMAL(bits, source) \\\n-\t\t\tGC_add_to_black_list_normal((word) bits)\n-#   endif\n-# else\n-#   ifdef PRINT_BLACK_LIST\n-#     define GC_ADD_TO_BLACK_LIST_NORMAL(bits, source) \\\n-\t\t\tGC_add_to_black_list_stack((word) bits, source)\n-#   else\n-#     define GC_ADD_TO_BLACK_LIST_NORMAL(bits, source) \\\n-\t\t\tGC_add_to_black_list_stack((word) bits)\n-#   endif\n-# endif\n-\n-void GC_add_to_black_list_stack(/* bits, maybe source */);\n-struct hblk * GC_is_black_listed(/* h, len */);\n-\t\t\t/* If there are likely to be false references\t*/\n-\t\t\t/* to a block starting at h of the indicated    */\n-\t\t\t/* length, then return the next plausible\t*/\n-\t\t\t/* starting location for h that might avoid\t*/\n-\t\t\t/* these false references.\t\t\t*/\n-void GC_promote_black_lists();\n-\t\t\t/* Declare an end to a black listing phase.\t*/\n-void GC_unpromote_black_lists();\n-\t\t\t/* Approximately undo the effect of the above.\t*/\n-\t\t\t/* This actually loses some information, but\t*/\n-\t\t\t/* only in a reasonably safe way.\t\t*/\n-word GC_number_stack_black_listed(/*struct hblk *start, struct hblk *endp1 */);\n-\t\t\t/* Return the number of (stack) blacklisted\t*/\n-\t\t\t/* blocks in the range for statistical\t\t*/\n-\t\t\t/* purposes.\t\t\t\t\t*/\n-\t\t \t\n-ptr_t GC_scratch_alloc(/*bytes*/);\n-\t\t\t\t/* GC internal memory allocation for\t*/\n-\t\t\t\t/* small objects.  Deallocation is not  */\n-\t\t\t\t/* possible.\t\t\t\t*/\n-\t\n-/* Heap block layout maps: */\t\t\t\n-void GC_invalidate_map(/* hdr */);\n-\t\t\t\t/* Remove the object map associated\t*/\n-\t\t\t\t/* with the block.  This identifies\t*/\n-\t\t\t\t/* the block as invalid to the mark\t*/\n-\t\t\t\t/* routines.\t\t\t\t*/\n-GC_bool GC_add_map_entry(/*sz*/);\n-\t\t\t\t/* Add a heap block map for objects of\t*/\n-\t\t\t\t/* size sz to obj_map.\t\t\t*/\n-\t\t\t\t/* Return FALSE on failure.\t\t*/\n-void GC_register_displacement_inner(/*offset*/);\n-\t\t\t\t/* Version of GC_register_displacement\t*/\n-\t\t\t\t/* that assumes lock is already held\t*/\n-\t\t\t\t/* and signals are already disabled.\t*/\n-\n-/*  hblk allocation: */\t\t\n-void GC_new_hblk(/*size_in_words, kind*/);\n-\t\t\t\t/* Allocate a new heap block, and build */\n-\t\t\t\t/* a free list in it.\t\t\t*/\t\t\t\t\n-struct hblk * GC_allochblk(/*size_in_words, kind*/);\n-\t\t\t\t/* Allocate a heap block, clear it if\t*/\n-\t\t\t\t/* for composite objects, inform\t*/\n-\t\t\t\t/* the marker that block is valid\t*/\n-\t\t\t\t/* for objects of indicated size.\t*/\n-\t\t\t\t/* sz < 0 ==> atomic.\t\t\t*/ \n-void GC_freehblk();\t\t/* Deallocate a heap block and mark it  */\n-\t\t\t\t/* as invalid.\t\t\t\t*/\n-\t\t\t\t\n-/*  Misc GC: */\n-void GC_init_inner();\n-GC_bool GC_expand_hp_inner();\n-void GC_start_reclaim(/*abort_if_found*/);\n-\t\t\t\t/* Restore unmarked objects to free\t*/\n-\t\t\t\t/* lists, or (if abort_if_found is\t*/\n-\t\t\t\t/* TRUE) report them.\t\t\t*/\n-\t\t\t\t/* Sweeping of small object pages is\t*/\n-\t\t\t\t/* largely deferred.\t\t\t*/\n-void GC_continue_reclaim(/*size, kind*/);\n-\t\t\t\t/* Sweep pages of the given size and\t*/\n-\t\t\t\t/* kind, as long as possible, and\t*/\n-\t\t\t\t/* as long as the corr. free list is    */\n-\t\t\t\t/* empty.\t\t\t\t*/\n-void GC_reclaim_or_delete_all();\n-\t\t\t\t/* Arrange for all reclaim lists to be\t*/\n-\t\t\t\t/* empty.  Judiciously choose between\t*/\n-\t\t\t\t/* sweeping and discarding each page.\t*/\n-GC_bool GC_reclaim_all(/* GC_stop_func f*/);\n-\t\t\t\t/* Reclaim all blocks.  Abort (in a\t*/\n-\t\t\t\t/* consistent state) if f returns TRUE. */\n-GC_bool GC_block_empty(/* hhdr */); /* Block completely unmarked? \t*/\n-GC_bool GC_never_stop_func();\t/* Returns FALSE.\t\t*/\n-GC_bool GC_try_to_collect_inner(/* GC_stop_func f */);\n-\t\t\t\t/* Collect; caller must have acquired\t*/\n-\t\t\t\t/* lock and disabled signals.\t\t*/\n-\t\t\t\t/* Collection is aborted if f returns\t*/\n-\t\t\t\t/* TRUE.  Returns TRUE if it completes\t*/\n-\t\t\t\t/* successfully.\t\t\t*/\n-# define GC_gcollect_inner() \\\n-\t(void) GC_try_to_collect_inner(GC_never_stop_func)\n-void GC_finish_collection();\t/* Finish collection.  Mark bits are\t*/\n-\t\t\t\t/* consistent and lock is still held.\t*/\n-GC_bool GC_collect_or_expand(/* needed_blocks */);\n-\t\t\t\t/* Collect or expand heap in an attempt */\n-\t\t\t\t/* make the indicated number of free\t*/\n-\t\t\t\t/* blocks available.  Should be called\t*/\n-\t\t\t\t/* until the blocks are available or\t*/\n-\t\t\t\t/* until it fails by returning FALSE.\t*/\n-GC_API void GC_init();\t\t/* Initialize collector.\t\t*/\n-void GC_collect_a_little_inner(/* int n */);\n-\t\t\t\t/* Do n units worth of garbage \t\t*/\n-\t\t\t\t/* collection work, if appropriate.\t*/\n-\t\t\t\t/* A unit is an amount appropriate for  */\n-\t\t\t\t/* HBLKSIZE bytes of allocation.\t*/\n-ptr_t GC_generic_malloc(word bytes, int kind);\n-\t\t\t\t/* Allocate an object of the given\t*/\n-\t\t\t\t/* kind.  By default, there are only\t*/\n-\t\t\t\t/* a few kinds: composite(pointerfree), */\n-\t\t\t\t/* atomic, uncollectable, etc.\t\t*/\n-\t\t\t\t/* We claim it's possible for clever\t*/\n-\t\t\t\t/* client code that understands GC\t*/\n-\t\t\t\t/* internals to add more, e.g. to\t*/\n-\t\t\t\t/* communicate object layout info\t*/\n-\t\t\t\t/* to the collector.\t\t\t*/\n-ptr_t GC_generic_malloc_ignore_off_page(/* bytes, kind */);\n-\t\t\t\t/* As above, but pointers past the \t*/\n-\t\t\t\t/* first page of the resulting object\t*/\n-\t\t\t\t/* are ignored.\t\t\t\t*/\n-ptr_t GC_generic_malloc_inner(word bytes, int kind);\n-\t\t\t\t/* Ditto, but I already hold lock, etc.\t*/\n-ptr_t GC_generic_malloc_words_small GC_PROTO((size_t words, int kind));\n-\t\t\t\t/* As above, but size in units of words */\n-\t\t\t\t/* Bypasses MERGE_SIZES.  Assumes\t*/\n-\t\t\t\t/* words <= MAXOBJSZ.\t\t\t*/\n-ptr_t GC_generic_malloc_inner_ignore_off_page(/* bytes, kind */);\n-\t\t\t\t/* Allocate an object, where\t\t*/\n-\t\t\t\t/* the client guarantees that there\t*/\n-\t\t\t\t/* will always be a pointer to the \t*/\n-\t\t\t\t/* beginning of the object while the\t*/\n-\t\t\t\t/* object is live.\t\t\t*/\n-ptr_t GC_allocobj(/* sz_inn_words, kind */);\n-\t\t\t\t/* Make the indicated \t\t\t*/\n-\t\t\t\t/* free list nonempty, and return its\t*/\n-\t\t\t\t/* head.\t\t\t\t*/\n-\n-void GC_init_headers();\n-struct hblkhdr * GC_install_header(/*h*/);\n-\t\t\t\t/* Install a header for block h.\t*/\n-\t\t\t\t/* Return 0 on failure, or the header\t*/\n-\t\t\t\t/* otherwise.\t\t\t\t*/\n-GC_bool GC_install_counts(/*h, sz*/);\n-\t\t\t\t/* Set up forwarding counts for block\t*/\n-\t\t\t\t/* h of size sz.\t\t\t*/\n-\t\t\t\t/* Return FALSE on failure.\t\t*/\n-void GC_remove_header(/*h*/);\n-\t\t\t\t/* Remove the header for block h.\t*/\n-void GC_remove_counts(/*h, sz*/);\n-\t\t\t\t/* Remove forwarding counts for h.\t*/\n-hdr * GC_find_header(ptr_t /*p*/);\t/* Debugging only.\t\t\t*/\n-\n-void GC_finalize();\t/* Perform all indicated finalization actions\t*/\n-\t\t\t/* on unmarked objects.\t\t\t\t*/\n-\t\t\t/* Unreachable finalizable objects are enqueued\t*/\n-\t\t\t/* for processing by GC_invoke_finalizers.\t*/\n-\t\t\t/* Invoked with lock.\t\t\t\t*/\n-\t\t\t\n-void GC_add_to_heap(/*p, bytes*/);\n-\t\t\t/* Add a HBLKSIZE aligned chunk to the heap.\t*/\n-\n-void GC_print_obj(/* ptr_t p */);\n-\t\t\t/* P points to somewhere inside an object with\t*/\n-\t\t\t/* debugging info.  Print a human readable\t*/\n-\t\t\t/* description of the object to stderr.\t\t*/\n-extern void (*GC_check_heap)();\n-\t\t\t/* Check that all objects in the heap with \t*/\n-\t\t\t/* debugging info are intact.  Print \t\t*/\n-\t\t\t/* descriptions of any that are not.\t\t*/\n-extern void (*GC_print_heap_obj)(/* ptr_t p */);\n-\t\t\t/* If possible print s followed by a more\t*/\n-\t\t\t/* detailed description of the object \t\t*/\n-\t\t\t/* referred to by p.\t\t\t\t*/\n-\t\t\t\n-/* Memory unmapping: */\n-#ifdef USE_MUNMAP\n-  void GC_unmap_old(void);\n-  void GC_merge_unmapped(void);\n-  void GC_unmap(ptr_t start, word bytes);\n-  void GC_remap(ptr_t start, word bytes);\n-  void GC_unmap_gap(ptr_t start1, word bytes1, ptr_t start2, word bytes2);\n-#endif\n-\n-/* Virtual dirty bit implementation:\t\t*/\n-/* Each implementation exports the following:\t*/\n-void GC_read_dirty();\t/* Retrieve dirty bits.\t*/\n-GC_bool GC_page_was_dirty(/* struct hblk * h  */);\n-\t\t\t/* Read retrieved dirty bits.\t*/\n-GC_bool GC_page_was_ever_dirty(/* struct hblk * h  */);\n-\t\t\t/* Could the page contain valid heap pointers?\t*/\n-void GC_is_fresh(/* struct hblk * h, word number_of_blocks  */);\n-\t\t\t/* Assert the region currently contains no\t*/\n-\t\t\t/* valid pointers.\t\t\t\t*/\n-void GC_write_hint(/* struct hblk * h  */);\n-\t\t\t/* h is about to be written.\t*/\n-void GC_dirty_init();\n-\n-/* Slow/general mark bit manipulation: */\n-GC_API GC_bool GC_is_marked();\n-void GC_clear_mark_bit();\n-void GC_set_mark_bit();\n-\n-/* Stubborn objects: */\n-void GC_read_changed();\t/* Analogous to GC_read_dirty */\n-GC_bool GC_page_was_changed(/* h */);\t/* Analogous to GC_page_was_dirty */\n-void GC_clean_changing_list();\t/* Collect obsolete changing list entries */\n-void GC_stubborn_init();\n-\n-/* Debugging print routines: */\n-void GC_print_block_list();\n-void GC_print_hblkfreelist();\n-void GC_print_heap_sects();\n-void GC_print_static_roots();\n-void GC_dump();\n-\n-#ifdef KEEP_BACK_PTRS\n-   void GC_store_back_pointer(ptr_t source, ptr_t dest);\n-   void GC_marked_for_finalization(ptr_t dest);\n-#  define GC_STORE_BACK_PTR(source, dest) GC_store_back_pointer(source, dest)\n-#  define GC_MARKED_FOR_FINALIZATION(dest) GC_marked_for_finalization(dest)\n-#else\n-#  define GC_STORE_BACK_PTR(source, dest) \n-#  define GC_MARKED_FOR_FINALIZATION(dest)\n-#endif\n-\n-/* Make arguments appear live to compiler */\n-# ifdef __WATCOMC__\n-  void GC_noop(void*, ...);\n-# else\n-  GC_API void GC_noop();\n-# endif\n-\n-void GC_noop1(word);\n-\n-/* Logging and diagnostic output: \t*/\n-GC_API void GC_printf GC_PROTO((char * format, long, long, long, long, long, long));\n-\t\t\t/* A version of printf that doesn't allocate,\t*/\n-\t\t\t/* is restricted to long arguments, and\t\t*/\n-\t\t\t/* (unfortunately) doesn't use varargs for\t*/\n-\t\t\t/* portability.  Restricted to 6 args and\t*/\n-\t\t\t/* 1K total output length.\t\t\t*/\n-\t\t\t/* (We use sprintf.  Hopefully that doesn't\t*/\n-\t\t\t/* allocate for long arguments.)  \t\t*/\n-# define GC_printf0(f) GC_printf(f, 0l, 0l, 0l, 0l, 0l, 0l)\n-# define GC_printf1(f,a) GC_printf(f, (long)a, 0l, 0l, 0l, 0l, 0l)\n-# define GC_printf2(f,a,b) GC_printf(f, (long)a, (long)b, 0l, 0l, 0l, 0l)\n-# define GC_printf3(f,a,b,c) GC_printf(f, (long)a, (long)b, (long)c, 0l, 0l, 0l)\n-# define GC_printf4(f,a,b,c,d) GC_printf(f, (long)a, (long)b, (long)c, \\\n-\t\t\t\t\t    (long)d, 0l, 0l)\n-# define GC_printf5(f,a,b,c,d,e) GC_printf(f, (long)a, (long)b, (long)c, \\\n-\t\t\t\t\t      (long)d, (long)e, 0l)\n-# define GC_printf6(f,a,b,c,d,e,g) GC_printf(f, (long)a, (long)b, (long)c, \\\n-\t\t\t\t\t\t(long)d, (long)e, (long)g)\n-\n-void GC_err_printf(/* format, a, b, c, d, e, f */);\n-# define GC_err_printf0(f) GC_err_puts(f)\n-# define GC_err_printf1(f,a) GC_err_printf(f, (long)a, 0l, 0l, 0l, 0l, 0l)\n-# define GC_err_printf2(f,a,b) GC_err_printf(f, (long)a, (long)b, 0l, 0l, 0l, 0l)\n-# define GC_err_printf3(f,a,b,c) GC_err_printf(f, (long)a, (long)b, (long)c, \\\n-\t\t\t\t\t\t  0l, 0l, 0l)\n-# define GC_err_printf4(f,a,b,c,d) GC_err_printf(f, (long)a, (long)b, \\\n-\t\t\t\t\t\t    (long)c, (long)d, 0l, 0l)\n-# define GC_err_printf5(f,a,b,c,d,e) GC_err_printf(f, (long)a, (long)b, \\\n-\t\t\t\t\t\t      (long)c, (long)d, \\\n-\t\t\t\t\t\t      (long)e, 0l)\n-# define GC_err_printf6(f,a,b,c,d,e,g) GC_err_printf(f, (long)a, (long)b, \\\n-\t\t\t\t\t\t\t(long)c, (long)d, \\\n-\t\t\t\t\t\t\t(long)e, (long)g)\n-\t\t\t/* Ditto, writes to stderr.\t\t\t*/\n-\t\t\t\n-void GC_err_puts(/* char *s */);\n-\t\t\t/* Write s to stderr, don't buffer, don't add\t*/\n-\t\t\t/* newlines, don't ...\t\t\t\t*/\n-\n-\n-#   ifdef GC_ASSERTIONS\n-#\tdefine GC_ASSERT(expr) if(!(expr)) {\\\n-\t\tGC_err_printf2(\"Assertion failure: %s:%ld\\n\", \\\n-\t\t\t\t__FILE__, (unsigned long)__LINE__); \\\n-\t\tABORT(\"assertion failure\"); }\n-#   else \n-#\tdefine GC_ASSERT(expr)\n-#   endif\n-\n-# endif /* GC_PRIVATE_H */"}, {"sha": "3dd7c8553bb687832fe3376bdd754d175166e277", "filename": "boehm-gc/gc_private.h", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6951ca5dee8ed05749cdc697767910aebaedcc0/boehm-gc%2Fgc_private.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6951ca5dee8ed05749cdc697767910aebaedcc0/boehm-gc%2Fgc_private.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fgc_private.h?ref=a6951ca5dee8ed05749cdc697767910aebaedcc0", "patch": "@@ -1 +0,0 @@\n-# include \"gc_priv.h\""}, {"sha": "2e0598f204c71fa11ede4f2322d8de31dbd5b841", "filename": "boehm-gc/gc_typed.h", "status": "removed", "additions": 0, "deletions": 93, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6951ca5dee8ed05749cdc697767910aebaedcc0/boehm-gc%2Fgc_typed.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6951ca5dee8ed05749cdc697767910aebaedcc0/boehm-gc%2Fgc_typed.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fgc_typed.h?ref=a6951ca5dee8ed05749cdc697767910aebaedcc0", "patch": "@@ -1,93 +0,0 @@\n-/* \n- * Copyright 1988, 1989 Hans-J. Boehm, Alan J. Demers\n- * Copyright (c) 1991-1994 by Xerox Corporation.  All rights reserved.\n- * Copyright 1996 Silicon Graphics.  All rights reserved.\n- *\n- * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n- * OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n- *\n- * Permission is hereby granted to use or copy this program\n- * for any purpose,  provided the above notices are retained on all copies.\n- * Permission to modify the code and to distribute modified code is granted,\n- * provided the above notices are retained, and a notice that the code was\n- * modified is included with the above copyright notice.\n- */\n-/*\n- * Some simple primitives for allocation with explicit type information.\n- * Facilities for dynamic type inference may be added later.\n- * Should be used only for extremely performance critical applications,\n- * or if conservative collector leakage is otherwise a problem (unlikely).\n- * Note that this is implemented completely separately from the rest\n- * of the collector, and is not linked in unless referenced.\n- * This does not currently support GC_DEBUG in any interesting way.\n- */\n-/* Boehm, May 19, 1994 2:13 pm PDT */\n-\n-#ifndef _GC_TYPED_H\n-# define _GC_TYPED_H\n-# ifndef _GC_H\n-#   include \"gc.h\"\n-# endif\n-\n-typedef GC_word * GC_bitmap;\n-\t/* The least significant bit of the first word is one if\t*/\n-\t/* the first word in the object may be a pointer.\t\t*/\n-\t\n-# define GC_get_bit(bm, index) \\\n-\t\t(((bm)[divWORDSZ(index)] >> modWORDSZ(index)) & 1)\n-# define GC_set_bit(bm, index) \\\n-\t\t(bm)[divWORDSZ(index)] |= (word)1 << modWORDSZ(index)\n-\n-typedef GC_word GC_descr;\n-\n-GC_API GC_descr GC_make_descriptor GC_PROTO((GC_bitmap bm, size_t len));\n-\t\t/* Return a type descriptor for the object whose layout\t*/\n-\t\t/* is described by the argument.\t\t\t*/\n-\t\t/* The least significant bit of the first word is one\t*/\n-\t\t/* if the first word in the object may be a pointer.\t*/\n-\t\t/* The second argument specifies the number of\t\t*/\n-\t\t/* meaningful bits in the bitmap.  The actual object \t*/\n-\t\t/* may be larger (but not smaller).  Any additional\t*/\n-\t\t/* words in the object are assumed not to contain \t*/\n-\t\t/* pointers.\t\t\t\t\t\t*/\n-\t\t/* Returns a conservative approximation in the\t\t*/\n-\t\t/* (unlikely) case of insufficient memory to build\t*/\n-\t\t/* the descriptor.  Calls to GC_make_descriptor\t\t*/\n-\t\t/* may consume some amount of a finite resource.  This\t*/\n-\t\t/* is intended to be called once per type, not once\t*/\n-\t\t/* per allocation.\t\t\t\t\t*/\n-\n-GC_API GC_PTR GC_malloc_explicitly_typed\n-\t\t\tGC_PROTO((size_t size_in_bytes, GC_descr d));\n-\t\t/* Allocate an object whose layout is described by d.\t*/\n-\t\t/* The resulting object MAY NOT BE PASSED TO REALLOC.\t*/\n-\t\t/* The returned object is cleared.\t\t\t*/\n-\n-GC_API GC_PTR GC_malloc_explicitly_typed_ignore_off_page\n-                        GC_PROTO((size_t size_in_bytes, GC_descr d));\n-\t\t\n-GC_API GC_PTR GC_calloc_explicitly_typed\n-\t\t\tGC_PROTO((size_t nelements,\n-  \t\t\t\t  size_t element_size_in_bytes,\n-  \t\t\t\t  GC_descr d));\n-  \t/* Allocate an array of nelements elements, each of the\t*/\n-  \t/* given size, and with the given descriptor.\t\t*/\n-  \t/* The elemnt size must be a multiple of the byte\t*/\n-  \t/* alignment required for pointers.  E.g. on a 32-bit\t*/\n-  \t/* machine with 16-bit aligned pointers, size_in_bytes\t*/\n-  \t/* must be a multiple of 2.\t\t\t\t*/\n-\t/* Returned object is cleared.\t\t\t\t*/\n-\n-#ifdef GC_DEBUG\n-#   define GC_MALLOC_EXPLICTLY_TYPED(bytes, d) GC_MALLOC(bytes)\n-#   define GC_CALLOC_EXPLICTLY_TYPED(n, bytes, d) GC_MALLOC(n*bytes)\n-#else\n-#  define GC_MALLOC_EXPLICTLY_TYPED(bytes, d) \\\n-\tGC_malloc_explicitly_typed(bytes, d)\n-#  define GC_CALLOC_EXPLICTLY_TYPED(n, bytes, d) \\\n-\tGC_calloc_explicitly_typed(n, bytes, d)\n-#endif /* !GC_DEBUG */\n-\n-\n-#endif /* _GC_TYPED_H */\n-"}, {"sha": "84a4b3ccc46f4e6ed23c468e4a06372ca700b8b7", "filename": "boehm-gc/gcconfig.h", "status": "removed", "additions": 0, "deletions": 1383, "changes": 1383, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6951ca5dee8ed05749cdc697767910aebaedcc0/boehm-gc%2Fgcconfig.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6951ca5dee8ed05749cdc697767910aebaedcc0/boehm-gc%2Fgcconfig.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fgcconfig.h?ref=a6951ca5dee8ed05749cdc697767910aebaedcc0", "patch": "@@ -1,1383 +0,0 @@\n-/* \n- * Copyright 1988, 1989 Hans-J. Boehm, Alan J. Demers\n- * Copyright (c) 1991-1994, 2001 by Xerox Corporation.  All rights reserved.\n- * Copyright (c) 1996 by Silicon Graphics.  All rights reserved.\n- *\n- * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n- * OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n- *\n- * Permission is hereby granted to use or copy this program\n- * for any purpose,  provided the above notices are retained on all copies.\n- * Permission to modify the code and to distribute modified code is granted,\n- * provided the above notices are retained, and a notice that the code was\n- * modified is included with the above copyright notice.\n- */\n- \n-#ifndef GCCONFIG_H\n-\n-# define GCCONFIG_H\n-\n-/* Machine dependent parameters.  Some tuning parameters can be found\t*/\n-/* near the top of gc_private.h.\t\t\t\t\t*/\n-\n-/* Machine specific parts contributed by various people.  See README file. */\n-\n-/* First a unified test for Linux: */\n-# if defined(linux) || defined(__linux__)\n-#    define LINUX\n-# endif\n-\n-/* Determine the machine type: */\n-# if defined(sun) && defined(mc68000)\n-#    define M68K\n-#    define SUNOS4\n-#    define mach_type_known\n-# endif\n-# if defined(hp9000s300)\n-#    define M68K\n-#    define HP\n-#    define mach_type_known\n-# endif\n-# if defined(__OpenBSD__) && defined(m68k)\n-#    define M68K\n-#    define OPENBSD\n-#    define mach_type_known\n-# endif\n-# if defined(__OpenBSD__) && defined(__sparc__)\n-#    define SPARC\n-#    define OPENBSD\n-#    define mach_type_known\n-# endif\n-# if defined(__NetBSD__) && defined(m68k)\n-#    define M68K\n-#    define NETBSD\n-#    define mach_type_known\n-# endif\n-# if defined(__NetBSD__) && defined(arm32)\n-#    define ARM32\n-#    define NETBSD\n-#    define mach_type_known\n-# endif\n-# if defined(vax)\n-#    define VAX\n-#    ifdef ultrix\n-#\tdefine ULTRIX\n-#    else\n-#\tdefine BSD\n-#    endif\n-#    define mach_type_known\n-# endif\n-# if defined(mips) || defined(__mips)\n-#    define MIPS\n-#    if !defined(LINUX)\n-#      if defined(ultrix) || defined(__ultrix) || defined(__NetBSD__)\n-#\t define ULTRIX\n-#      else\n-#\t if defined(_SYSTYPE_SVR4) || defined(SYSTYPE_SVR4) \\\n-\t    || defined(__SYSTYPE_SVR4__)\n-#\t   define IRIX5   /* or IRIX 6.X */\n-#\t else\n-#\t   define RISCOS  /* or IRIX 4.X */\n-#\t endif\n-#      endif\n-#    endif /* !LINUX */\n-#    define mach_type_known\n-# endif\n-# if defined(sequent) && defined(i386)\n-#    define I386\n-#    define SEQUENT\n-#    define mach_type_known\n-# endif\n-# if defined(sun) && defined(i386)\n-#    define I386\n-#    define SUNOS5\n-#    define mach_type_known\n-# endif\n-# if (defined(__OS2__) || defined(__EMX__)) && defined(__32BIT__)\n-#    define I386\n-#    define OS2\n-#    define mach_type_known\n-# endif\n-# if defined(ibm032)\n-#   define RT\n-#   define mach_type_known\n-# endif\n-# if defined(sun) && (defined(sparc) || defined(__sparc))\n-#   define SPARC\n-    /* Test for SunOS 5.x */\n-#     include <errno.h>\n-#     ifdef ECHRNG\n-#       define SUNOS5\n-#     else\n-#\tdefine SUNOS4\n-#     endif\n-#   define mach_type_known\n-# endif\n-# if defined(sparc) && defined(unix) && !defined(sun) && !defined(linux) \\\n-     && !defined(__OpenBSD__)\n-#   define SPARC\n-#   define DRSNX\n-#   define mach_type_known\n-# endif\n-# if defined(_IBMR2)\n-#   define RS6000\n-#   define mach_type_known\n-# endif\n-# if defined(_M_XENIX) && defined(_M_SYSV) && defined(_M_I386)\n-\t/* The above test may need refinement\t*/\n-#   define I386\n-#   if defined(_SCO_ELF)\n-#     define SCO_ELF\n-#   else\n-#     define SCO\n-#   endif\n-#   define mach_type_known\n-# endif\n-# if defined(_AUX_SOURCE)\n-#   define M68K\n-#   define SYSV\n-#   define mach_type_known\n-# endif\n-# if defined(_PA_RISC1_0) || defined(_PA_RISC1_1) || defined(_PA_RISC2_0) \\\n-     || defined(hppa) || defined(__hppa__)\n-#   define HP_PA\n-#   ifndef LINUX\n-#     define HPUX\n-#   endif\n-#   define mach_type_known\n-# endif\n-# if defined(LINUX) && (defined(i386) || defined(__i386__))\n-#    define I386\n-#    define mach_type_known\n-# endif\n-# if defined(LINUX) && (defined(__ia64__) || defined(__ia64))\n-#    define IA64\n-#    define mach_type_known\n-# endif\n-# if defined(LINUX) && defined(powerpc)\n-#    define POWERPC\n-#    define mach_type_known\n-# endif\n-# if defined(LINUX) && defined(__mc68000__)\n-#    define M68K\n-#    define mach_type_known\n-# endif\n-# if defined(LINUX) && (defined(sparc) || defined(__sparc__))\n-#    define SPARC\n-#    define mach_type_known\n-# endif\n-# if defined(LINUX) && defined(__arm__)\n-#    define ARM32\n-#    define mach_type_known\n-# endif\n-# if defined(__alpha) || defined(__alpha__)\n-#   define ALPHA\n-#   if !defined(LINUX)\n-#     define OSF1\t/* a.k.a Digital Unix */\n-#   endif\n-#   define mach_type_known\n-# endif\n-# if defined(_AMIGA) && !defined(AMIGA)\n-#   define AMIGA\n-# endif\n-# ifdef AMIGA \n-#   define M68K\n-#   define mach_type_known\n-# endif\n-# if defined(THINK_C) || defined(__MWERKS__) && !defined(__powerc)\n-#   define M68K\n-#   define MACOS\n-#   define mach_type_known\n-# endif\n-# if defined(__MWERKS__) && defined(__powerc)\n-#   define POWERPC\n-#   define MACOS\n-#   define mach_type_known\n-# endif\n-# if defined(macosx)\n-#    define MACOSX\n-#    define POWERPC\n-#    define mach_type_known\n-# endif\n-# if defined(NeXT) && defined(mc68000)\n-#   define M68K\n-#   define NEXT\n-#   define mach_type_known\n-# endif\n-# if defined(NeXT) && defined(i386)\n-#   define I386\n-#   define NEXT\n-#   define mach_type_known\n-# endif\n-# if defined(__OpenBSD__) && defined(i386)\n-#   define I386\n-#   define OPENBSD\n-#   define mach_type_known\n-# endif\n-# if defined(__FreeBSD__) && defined(i386)\n-#   define I386\n-#   define FREEBSD\n-#   define mach_type_known\n-# endif\n-# if defined(__NetBSD__) && defined(i386)\n-#   define I386\n-#   define NETBSD\n-#   define mach_type_known\n-# endif\n-# if defined(bsdi) && defined(i386)\n-#    define I386\n-#    define BSDI\n-#    define mach_type_known\n-# endif\n-# if !defined(mach_type_known) && defined(__386BSD__)\n-#   define I386\n-#   define THREE86BSD\n-#   define mach_type_known\n-# endif\n-# if defined(_CX_UX) && defined(_M88K)\n-#   define M88K\n-#   define CX_UX\n-#   define mach_type_known\n-# endif\n-# if defined(DGUX)\n-#   define M88K\n-    /* DGUX defined */\n-#   define mach_type_known\n-# endif\n-# if (defined(_MSDOS) || defined(_MSC_VER)) && (_M_IX86 >= 300) \\\n-     || defined(_WIN32) && !defined(__CYGWIN32__) && !defined(__CYGWIN__)\n-#   define I386\n-#   define MSWIN32\t/* or Win32s */\n-#   define mach_type_known\n-# endif\n-# if defined(__DJGPP__)\n-#   define I386\n-#   ifndef DJGPP\n-#     define DJGPP  /* MSDOS running the DJGPP port of GCC */\n-#   endif\n-#   define mach_type_known\n-# endif\n-# if defined(__CYGWIN32__) || defined(__CYGWIN__)\n-#   define I386\n-#   define CYGWIN32\n-#   define mach_type_known\n-# endif\n-# if defined(__MINGW32__)\n-#   define I386\n-#   define MSWIN32\n-#   define mach_type_known\n-# endif\n-# if defined(__BORLANDC__)\n-#   define I386\n-#   define MSWIN32\n-#   define mach_type_known\n-# endif\n-# if defined(_UTS) && !defined(mach_type_known)\n-#   define S370\n-#   define UTS4\n-#   define mach_type_known\n-# endif\n-# if defined(__pj__)\n-#   define PJ\n-#   define mach_type_known\n-# endif\n-/* Ivan Demakov */\n-# if defined(__WATCOMC__) && defined(__386__)\n-#   define I386\n-#   if !defined(OS2) && !defined(MSWIN32) && !defined(DOS4GW)\n-#     if defined(__OS2__)\n-#       define OS2\n-#     else\n-#       if defined(__WINDOWS_386__) || defined(__NT__)\n-#         define MSWIN32\n-#       else\n-#         define DOS4GW\n-#       endif\n-#     endif\n-#   endif\n-#   define mach_type_known\n-# endif\n-# if defined(__embedded__) && defined(PPC)\n-#    define POWERPC\n-#    define mach_type_known\n-# endif\n-\n-/* Feel free to add more clauses here */\n-\n-/* Or manually define the machine type here.  A machine type is \t*/\n-/* characterized by the architecture.  Some\t\t\t\t*/\n-/* machine types are further subdivided by OS.\t\t\t\t*/\n-/* the macros ULTRIX, RISCOS, and BSD to distinguish.\t\t\t*/\n-/* Note that SGI IRIX is treated identically to RISCOS.\t\t\t*/\n-/* SYSV on an M68K actually means A/UX.\t\t\t\t\t*/\n-/* The distinction in these cases is usually the stack starting address */\n-# ifndef mach_type_known\n-\t--> unknown machine type\n-# endif\n-\t\t    /* Mapping is: M68K       ==> Motorola 680X0\t*/\n-\t\t    /*\t\t   (SUNOS4,HP,NEXT, and SYSV (A/UX),\t*/\n-\t\t    /*\t\t   MACOS and AMIGA variants)\t\t*/\n-\t\t    /*             I386       ==> Intel 386\t \t*/\n-\t\t    /*\t\t    (SEQUENT, OS2, SCO, LINUX, NETBSD,\t*/\n-\t\t    /*\t\t     FREEBSD, THREE86BSD, MSWIN32,\t*/\n-\t\t    /* \t\t     BSDI,SUNOS5, NEXT, other variants)\t*/\n-                    /*             NS32K      ==> Encore Multimax \t*/\n-                    /*             MIPS       ==> R2000 or R3000\t*/\n-                    /*\t\t\t(RISCOS, ULTRIX variants)\t*/\n-                    /*\t\t   VAX\t      ==> DEC VAX\t\t*/\n-                    /*\t\t\t(BSD, ULTRIX variants)\t\t*/\n-                    /*\t\t   RS6000     ==> IBM RS/6000 AIX3.X\t*/\n-                    /*\t\t   RT\t      ==> IBM PC/RT\t\t*/\n-                    /*\t\t   HP_PA      ==> HP9000/700 & /800\t*/\n-                    /*\t\t\t\t  HP/UX\t\t\t*/\n-\t\t    /*\t\t   SPARC      ==> SPARC\tv7/v8/v9\t*/\n-\t\t    /*\t\t\t(SUNOS4, SUNOS5, LINUX,\t\t*/\n-\t\t    /*\t\t\t DRSNX variants)\t\t*/\n-\t\t    /* \t\t   ALPHA      ==> DEC Alpha \t\t*/\n-\t\t    /*\t\t\t(OSF1 and LINUX variants)\t*/\n-\t\t    /* \t\t   M88K       ==> Motorola 88XX0        */\n-\t\t    /* \t\t        (CX_UX and DGUX)\t\t*/\n-\t\t    /* \t\t   S370\t      ==> 370-like machine\t*/\n-\t\t    /* \t\t\trunning Amdahl UTS4\t\t*/\n-\t\t    /* \t\t   ARM32      ==> Intel StrongARM\t*/\n-\t\t    /* \t\t   IA64\t      ==> Intel IA64\t\t*/\n-\t\t    /*\t\t\t\t  (e.g. Itanium)\t*/\n-\n-\n-/*\n- * For each architecture and OS, the following need to be defined:\n- *\n- * CPP_WORD_SZ is a simple integer constant representing the word size.\n- * in bits.  We assume byte addressibility, where a byte has 8 bits.\n- * We also assume CPP_WORD_SZ is either 32 or 64.\n- * (We care about the length of pointers, not hardware\n- * bus widths.  Thus a 64 bit processor with a C compiler that uses\n- * 32 bit pointers should use CPP_WORD_SZ of 32, not 64. Default is 32.)\n- *\n- * MACH_TYPE is a string representation of the machine type.\n- * OS_TYPE is analogous for the OS.\n- *\n- * ALIGNMENT is the largest N, such that\n- * all pointer are guaranteed to be aligned on N byte boundaries.\n- * defining it to be 1 will always work, but perform poorly.\n- *\n- * DATASTART is the beginning of the data segment.\n- * On UNIX systems, the collector will scan the area between DATASTART\n- * and DATAEND for root pointers.\n- *\n- * DATAEND, if not &end.\n- *\n- * ALIGN_DOUBLE of GC_malloc should return blocks aligned to twice\n- * the pointer size.\n- *\n- * STACKBOTTOM is the cool end of the stack, which is usually the\n- * highest address in the stack.\n- * Under PCR or OS/2, we have other ways of finding thread stacks.\n- * For each machine, the following should:\n- * 1) define STACK_GROWS_UP if the stack grows toward higher addresses, and\n- * 2) define exactly one of\n- *\tSTACKBOTTOM (should be defined to be an expression)\n- *\tHEURISTIC1\n- *\tHEURISTIC2\n- * If either of the last two macros are defined, then STACKBOTTOM is computed\n- * during collector startup using one of the following two heuristics:\n- * HEURISTIC1:  Take an address inside GC_init's frame, and round it up to\n- *\t\tthe next multiple of STACK_GRAN.\n- * HEURISTIC2:  Take an address inside GC_init's frame, increment it repeatedly\n- *\t\tin small steps (decrement if STACK_GROWS_UP), and read the value\n- *\t\tat each location.  Remember the value when the first\n- *\t\tSegmentation violation or Bus error is signalled.  Round that\n- *\t\tto the nearest plausible page boundary, and use that instead\n- *\t\tof STACKBOTTOM.\n- *\n- * Gustavo Rodriguez-Rivera points out that on most (all?) Unix machines,\n- * the value of environ is a pointer that can serve as STACKBOTTOM.\n- * I expect that HEURISTIC2 can be replaced by this approach, which\n- * interferes far less with debugging. \n- *\n- * If no expression for STACKBOTTOM can be found, and neither of the above\n- * heuristics are usable, the collector can still be used with all of the above\n- * undefined, provided one of the following is done:\n- * 1) GC_mark_roots can be changed to somehow mark from the correct stack(s)\n- *    without reference to STACKBOTTOM.  This is appropriate for use in\n- *    conjunction with thread packages, since there will be multiple stacks.\n- *    (Allocating thread stacks in the heap, and treating them as ordinary\n- *    heap data objects is also possible as a last resort.  However, this is\n- *    likely to introduce significant amounts of excess storage retention\n- *    unless the dead parts of the thread stacks are periodically cleared.)\n- * 2) Client code may set GC_stackbottom before calling any GC_ routines.\n- *    If the author of the client code controls the main program, this is\n- *    easily accomplished by introducing a new main program, setting\n- *    GC_stackbottom to the address of a local variable, and then calling\n- *    the original main program.  The new main program would read something\n- *    like:\n- *\n- *\t\t# include \"gc_private.h\"\n- *\n- *\t\tmain(argc, argv, envp)\n- *\t\tint argc;\n- *\t\tchar **argv, **envp;\n- *\t\t{\n- *\t\t    int dummy;\n- *\n- *\t\t    GC_stackbottom = (ptr_t)(&dummy);\n- *\t\t    return(real_main(argc, argv, envp));\n- *\t\t}\n- *\n- *\n- * Each architecture may also define the style of virtual dirty bit\n- * implementation to be used:\n- *   MPROTECT_VDB: Write protect the heap and catch faults.\n- *   PROC_VDB: Use the SVR4 /proc primitives to read dirty bits.\n- *\n- * An architecture may define DYNAMIC_LOADING if dynamic_load.c\n- * defined GC_register_dynamic_libraries() for the architecture.\n- *\n- * An architecture may define PREFETCH(x) to preload the cache with *x.\n- * This defaults to a no-op.\n- *\n- * PREFETCH_FOR_WRITE(x) is used if *x is about to be written.\n- *\n- * An architecture may also define CLEAR_DOUBLE(x) to be a fast way to\n- * clear the two words at GC_malloc-aligned address x.  By default,\n- * word stores of 0 are used instead.\n- */\n-\n-\n-# define STACK_GRAN 0x1000000\n-# ifdef M68K\n-#   define MACH_TYPE \"M68K\"\n-#   define ALIGNMENT 2\n-#   ifdef OPENBSD\n-#\tdefine OS_TYPE \"OPENBSD\"\n-#\tdefine HEURISTIC2\n-\textern char etext;\n-#\tdefine DATASTART ((ptr_t)(&etext))\n-#   endif\n-#   ifdef NETBSD\n-#\tdefine OS_TYPE \"NETBSD\"\n-#\tdefine HEURISTIC2\n-\textern char etext;\n-#\tdefine DATASTART ((ptr_t)(&etext))\n-#   endif\n-#   ifdef LINUX\n-#       define OS_TYPE \"LINUX\"\n-#       define STACKBOTTOM ((ptr_t)0xf0000000)\n-#       define MPROTECT_VDB\n-#       ifdef __ELF__\n-#            define DYNAMIC_LOADING\n-             extern char **__environ;\n-#            define DATASTART ((ptr_t)(&__environ))\n-                             /* hideous kludge: __environ is the first */\n-                             /* word in crt0.o, and delimits the start */\n-                             /* of the data segment, no matter which   */\n-                             /* ld options were passed through.        */\n-                             /* We could use _etext instead, but that  */\n-                             /* would include .rodata, which may       */\n-                             /* contain large read-only data tables    */\n-                             /* that we'd rather not scan.             */\n-             extern int _end;\n-#            define DATAEND (&_end)\n-#       else\n-             extern int etext;\n-#            define DATASTART ((ptr_t)((((word) (&etext)) + 0xfff) & ~0xfff))\n-#       endif\n-#   endif\n-#   ifdef SUNOS4\n-#\tdefine OS_TYPE \"SUNOS4\"\n-\textern char etext;\n-#\tdefine DATASTART ((ptr_t)((((word) (&etext)) + 0x1ffff) & ~0x1ffff))\n-#\tdefine HEURISTIC1\t/* differs\t*/\n-#\tdefine DYNAMIC_LOADING\n-#   endif\n-#   ifdef HP\n-#\tdefine OS_TYPE \"HP\"\n-\textern char etext;\n-#       define DATASTART ((ptr_t)((((word) (&etext)) + 0xfff) & ~0xfff))\n-#       define STACKBOTTOM ((ptr_t) 0xffeffffc)\n-\t\t\t      /* empirically determined.  seems to work. */\n-#  \tinclude <unistd.h>\n-#\tdefine GETPAGESIZE() sysconf(_SC_PAGE_SIZE)\n-#   endif\n-#   ifdef SYSV\n-#\tdefine OS_TYPE \"SYSV\"\n-\textern etext;\n-#   \tdefine DATASTART ((ptr_t)((((word) (&etext)) + 0x3fffff) \\\n-\t\t\t\t   & ~0x3fffff) \\\n-\t\t\t\t  +((word)&etext & 0x1fff))\n-\t/* This only works for shared-text binaries with magic number 0413.\n-\t   The other sorts of SysV binaries put the data at the end of the text,\n-\t   in which case the default of &etext would work.  Unfortunately,\n-\t   handling both would require having the magic-number available.\n-\t   \t   \t\t-- Parag\n-\t   */\n-#\tdefine STACKBOTTOM ((ptr_t)0xFFFFFFFE)\n-\t\t\t/* The stack starts at the top of memory, but   */\n-\t\t\t/* 0x0 cannot be used as setjump_test complains */\n-\t\t\t/* that the stack direction is incorrect.  Two  */\n-\t\t\t/* bytes down from 0x0 should be safe enough.   */\n-\t\t\t/* \t\t--Parag\t\t\t\t*/\n-#   \tinclude <sys/mmu.h>\n-#\tdefine GETPAGESIZE() PAGESIZE\t/* Is this still right? */\n-#   endif\n-#   ifdef AMIGA\n-#\tdefine OS_TYPE \"AMIGA\"\n- \t    \t/* STACKBOTTOM and DATASTART handled specially\t*/\n- \t    \t/* in os_dep.c\t\t\t\t\t*/\n-# \tdefine DATAEND\t/* not needed */\n-#\tdefine GETPAGESIZE() 4096\n-#   endif\n-#   ifdef MACOS\n-#     ifndef __LOWMEM__\n-#     include <LowMem.h>\n-#     endif\n-#     define OS_TYPE \"MACOS\"\n-\t\t\t/* see os_dep.c for details of global data segments. */\n-#     define STACKBOTTOM ((ptr_t) LMGetCurStackBase())\n-#     define DATAEND\t/* not needed */\n-#     define GETPAGESIZE() 4096\n-#   endif\n-#   ifdef NEXT\n-#\tdefine OS_TYPE \"NEXT\"\n-#\tdefine DATASTART ((ptr_t) get_etext())\n-#\tdefine STACKBOTTOM ((ptr_t) 0x4000000)\n-#\tdefine DATAEND\t/* not needed */\n-#   endif\n-# endif\n-\n-# ifdef POWERPC\n-#   define MACH_TYPE \"POWERPC\"\n-#   ifdef MACOS\n-#     define ALIGNMENT 2  /* Still necessary?  Could it be 4?\t*/\n-#     ifndef __LOWMEM__\n-#     include <LowMem.h>\n-#     endif\n-#     define OS_TYPE \"MACOS\"\n-\t\t\t/* see os_dep.c for details of global data segments. */\n-#     define STACKBOTTOM ((ptr_t) LMGetCurStackBase())\n-#     define DATAEND  /* not needed */\n-#   endif\n-#   ifdef LINUX\n-#     define ALIGNMENT 4\t/* Guess.  Can someone verify?\t*/\n-\t\t\t\t/* This was 2, but that didn't sound right. */\n-#     define OS_TYPE \"LINUX\"\n-#     define HEURISTIC1\n-#     define DYNAMIC_LOADING\n-#     undef STACK_GRAN\n-#     define STACK_GRAN 0x10000000\n-\t/* Stack usually starts at 0x80000000 */\n-#     define LINUX_DATA_START\n-      extern int _end;\n-#     define DATAEND (&_end)\n-#   endif\n-#   ifdef MACOSX\n-#     define ALIGNMENT 4\n-#     define OS_TYPE \"MACOSX\"\n-#     define DATASTART ((ptr_t) get_etext())\n-#     define STACKBOTTOM ((ptr_t) 0xc0000000)\n-#     define DATAEND\t/* not needed */\n-#   endif\n-#   ifdef __embedded__\n-#     define ALIGNMENT 4\n-#     define OS_TYPE \"EMBEDDED\"\n-      extern void __end, __dso_handle;\n-#     define DATASTART (&__dso_handle)  /* OK, that's ugly.  */\n-#     define DATAEND (&__end)\n-\t/* Stack starts at 0xE0000000 for the simulator.  */\n-#     undef STACK_GRAN\n-#     define STACK_GRAN 0x10000000\n-#     define HEURISTIC1\n-#   endif\n-# endif\n-\n-# ifdef VAX\n-#   define MACH_TYPE \"VAX\"\n-#   define ALIGNMENT 4\t/* Pointers are longword aligned by 4.2 C compiler */\n-    extern char etext;\n-#   define DATASTART ((ptr_t)(&etext))\n-#   ifdef BSD\n-#\tdefine OS_TYPE \"BSD\"\n-#\tdefine HEURISTIC1\n-\t\t\t/* HEURISTIC2 may be OK, but it's hard to test. */\n-#   endif\n-#   ifdef ULTRIX\n-#\tdefine OS_TYPE \"ULTRIX\"\n-#\tdefine STACKBOTTOM ((ptr_t) 0x7fffc800)\n-#   endif\n-# endif\n-\n-# ifdef RT\n-#   define MACH_TYPE \"RT\"\n-#   define ALIGNMENT 4\n-#   define DATASTART ((ptr_t) 0x10000000)\n-#   define STACKBOTTOM ((ptr_t) 0x1fffd800)\n-# endif\n-\n-# ifdef SPARC\n-#   define MACH_TYPE \"SPARC\"\n-#   if defined(__arch64__) || defined(__sparcv9)\n-#     define ALIGNMENT 8\n-#   else\n-#     define ALIGNMENT 4\t/* Required by hardware\t*/\n-#   endif\n-#   define ALIGN_DOUBLE\n-    extern int etext;\n-#   ifdef SUNOS5\n-#\tdefine OS_TYPE \"SUNOS5\"\n-\textern int _etext;\n-\textern int _end;\n-\textern char * GC_SysVGetDataStart();\n-#       define DATASTART (ptr_t)GC_SysVGetDataStart(0x10000, &_etext)\n-#\tdefine DATAEND (&_end)\n-#\tifndef USE_MMAP\n-#\t    define USE_MMAP\n-#\tendif\n-#       ifdef USE_MMAP\n-#         define HEAP_START (ptr_t)0x40000000\n-#       else\n-#\t  define HEAP_START DATAEND\n-#       endif\n-#\tdefine PROC_VDB\n-/*\tHEURISTIC1 reportedly no longer works under 2.7.  Thus we\t*/\n-/* \tswitched to HEURISTIC2, eventhough it creates some debugging\t*/\n-/*\tissues.\t\t\t\t\t\t\t\t*/\n-#\tdefine HEURISTIC2\n-#\tinclude <unistd.h>\n-#       define GETPAGESIZE()  sysconf(_SC_PAGESIZE)\n-\t\t/* getpagesize() appeared to be missing from at least one */\n-\t\t/* Solaris 5.4 installation.  Weird.\t\t\t  */\n-#\tdefine DYNAMIC_LOADING\n-#   endif\n-#   ifdef SUNOS4\n-#\tdefine OS_TYPE \"SUNOS4\"\n-\t/* [If you have a weak stomach, don't read this.]\t\t*/\n-\t/* We would like to use:\t\t\t\t\t*/\n-/* #       define DATASTART ((ptr_t)((((word) (&etext)) + 0x1fff) & ~0x1fff)) */\n-\t/* This fails occasionally, due to an ancient, but very \t*/\n-\t/* persistent ld bug.  &etext is set 32 bytes too high.\t\t*/\n-\t/* We instead read the text segment size from the a.out\t\t*/\n-\t/* header, which happens to be mapped into our address space\t*/\n-\t/* at the start of the text segment.  The detective work here\t*/\n-\t/* was done by Robert Ehrlich, Manuel Serrano, and Bernard\t*/\n-\t/* Serpette of INRIA.\t\t\t\t\t\t*/\n-\t/* This assumes ZMAGIC, i.e. demand-loadable executables.\t*/\n-#\tdefine TEXTSTART 0x2000\n-#       define DATASTART ((ptr_t)(*(int *)(TEXTSTART+0x4)+TEXTSTART))\n-#\tdefine MPROTECT_VDB\n-#\tdefine HEURISTIC1\n-# \tdefine DYNAMIC_LOADING\n-#   endif\n-#   ifdef DRSNX\n-#       define CPP_WORDSZ 32\n-#\tdefine OS_TYPE \"DRSNX\"\n-\textern char * GC_SysVGetDataStart();\n-\textern int etext;\n-#       define DATASTART (ptr_t)GC_SysVGetDataStart(0x10000, &etext)\n-#\tdefine MPROTECT_VDB\n-#       define STACKBOTTOM ((ptr_t) 0xdfff0000)\n-#\tdefine DYNAMIC_LOADING\n-#   endif\n-#   ifdef LINUX\n-#     define OS_TYPE \"LINUX\"\n-#     ifdef __ELF__\n-#       define DYNAMIC_LOADING\n-#     else\n-          Linux Sparc/a.out not supported\n-#     endif\n-      extern int _etext;\n-      extern int _end;\n-#     define DATAEND (&_end)\n-#     define SVR4\n-#     ifdef __arch64__\n-#       define STACKBOTTOM ((ptr_t) 0x80000000000ULL)\n-#\tdefine DATASTART (ptr_t)GC_SysVGetDataStart(0x100000, &_etext)\n-#\tdefine CPP_WORDSZ 64\n-#     else\n-#       define STACKBOTTOM ((ptr_t) 0xf0000000)\n-#\tdefine DATASTART (ptr_t)GC_SysVGetDataStart(0x10000, &_etext)\n-#     endif\n-#   endif\n-#   ifdef OPENBSD\n-#     define OS_TYPE \"OPENBSD\"\n-#     define STACKBOTTOM ((ptr_t) 0xf8000000)\n-#     define DATASTART ((ptr_t)(&etext))\n-#   endif\n-# endif\n-\n-# ifdef I386\n-#   define MACH_TYPE \"I386\"\n-#   define ALIGNMENT 4\t/* Appears to hold for all \"32 bit\" compilers\t*/\n-\t\t\t/* except Borland.  The -a4 option fixes \t*/\n-\t\t\t/* Borland.\t\t\t\t\t*/\n-                        /* Ivan Demakov: For Watcom the option is -zp4. */\n-#   ifndef SMALL_CONFIG\n-#     define ALIGN_DOUBLE /* Not strictly necessary, but may give speed   */\n-\t\t\t  /* improvement on Pentiums.\t\t\t  */\n-#   endif\n-#   ifdef SEQUENT\n-#\tdefine OS_TYPE \"SEQUENT\"\n-\textern int etext;\n-#       define DATASTART ((ptr_t)((((word) (&etext)) + 0xfff) & ~0xfff))\n-#       define STACKBOTTOM ((ptr_t) 0x3ffff000) \n-#   endif\n-#   ifdef SUNOS5\n-#\tdefine OS_TYPE \"SUNOS5\"\n-  \textern int etext, _start;\n-  \textern char * GC_SysVGetDataStart();\n-#       define DATASTART GC_SysVGetDataStart(0x1000, &etext)\n-#\tdefine STACKBOTTOM ((ptr_t)(&_start))\n-/** At least in Solaris 2.5, PROC_VDB gives wrong values for dirty bits. */\n-/*#\tdefine PROC_VDB*/\n-#\tdefine DYNAMIC_LOADING\n-#\tifndef USE_MMAP\n-#\t    define USE_MMAP\n-#\tendif\n-#       ifdef USE_MMAP\n-#         define HEAP_START (ptr_t)0x40000000\n-#       else\n-#\t  define HEAP_START DATAEND\n-#       endif\n-#   endif\n-#   ifdef SCO\n-#\tdefine OS_TYPE \"SCO\"\n-\textern int etext;\n-#   \tdefine DATASTART ((ptr_t)((((word) (&etext)) + 0x3fffff) \\\n-\t\t\t\t  & ~0x3fffff) \\\n-\t\t\t\t +((word)&etext & 0xfff))\n-#\tdefine STACKBOTTOM ((ptr_t) 0x7ffffffc)\n-#   endif\n-#   ifdef SCO_ELF\n-#       define OS_TYPE \"SCO_ELF\"\n-        extern int etext;\n-#       define DATASTART ((ptr_t)(&etext))\n-#       define STACKBOTTOM ((ptr_t) 0x08048000)\n-#       define DYNAMIC_LOADING\n-#\tdefine ELF_CLASS ELFCLASS32\n-#   endif\n-#   ifdef LINUX\n-#\tdefine OS_TYPE \"LINUX\"\n-#       define LINUX_STACKBOTTOM\n-#\tif 0\n-#\t  define HEURISTIC1\n-#         undef STACK_GRAN\n-#         define STACK_GRAN 0x10000000\n-\t  /* STACKBOTTOM is usually 0xc0000000, but this changes with\t*/\n-\t  /* different kernel configurations.  In particular, systems\t*/\n-\t  /* with 2GB physical memory will usually move the user\t*/\n-\t  /* address space limit, and hence initial SP to 0x80000000.\t*/\n-#       endif\n-#       if !defined(LINUX_THREADS) || !defined(REDIRECT_MALLOC)\n-\t/* libgcj: Linux threads don't interact well with the read() wrapper.\n-\t   Not defining MPROTECT_VDB fixes this.  */\n-/* #\t    define MPROTECT_VDB */\n-#\telse\n-\t    /* We seem to get random errors in incremental mode,\t*/\n-\t    /* possibly because Linux threads is itself a malloc client */\n-\t    /* and can't deal with the signals.\t\t\t\t*/\n-#\tendif\n-#       ifdef __ELF__\n-#            define DYNAMIC_LOADING\n-#\t     ifdef UNDEFINED\t/* includes ro data */\n-\t       extern int _etext;\n-#              define DATASTART ((ptr_t)((((word) (&_etext)) + 0xfff) & ~0xfff))\n-#\t     endif\n-#\t     include <features.h>\n-#\t     if defined(__GLIBC__) && __GLIBC__ >= 2\n-#\t\t define LINUX_DATA_START\n-#\t     else\n-     \t         extern char **__environ;\n-#                define DATASTART ((ptr_t)(&__environ))\n-\t\t\t      /* hideous kludge: __environ is the first */\n-\t\t\t      /* word in crt0.o, and delimits the start */\n-\t\t\t      /* of the data segment, no matter which   */\n-\t\t\t      /* ld options were passed through.        */\n-\t\t\t      /* We could use _etext instead, but that  */\n-\t\t\t      /* would include .rodata, which may       */\n-\t\t\t      /* contain large read-only data tables    */\n-\t\t\t      /* that we'd rather not scan.\t\t*/\n-#\t     endif\n-\t     extern int _end;\n-#\t     define DATAEND (&_end)\n-#\telse\n-\t     extern int etext;\n-#            define DATASTART ((ptr_t)((((word) (&etext)) + 0xfff) & ~0xfff))\n-#       endif\n-#\tifdef USE_I686_PREFETCH\n-#\t  define PREFETCH(x) \\\n-\t    __asm__ __volatile__ (\"\tprefetchnta\t%0\": : \"m\"(*(char *)(x)))\n-\t    /* Empirically prefetcht0 is much more effective at reducing\t*/\n-\t    /* cache miss stalls for the targetted load instructions.  But it\t*/\n-\t    /* seems to interfere enough with other cache traffic that the net\t*/\n-\t    /* result is worse than prefetchnta.\t\t\t\t*/\n-#         if 0 \n-\t    /* Using prefetches for write seems to have a slight negative\t*/\n-\t    /* impact on performance, at least for a PIII/500.\t\t\t*/\n-#\t    define PREFETCH_FOR_WRITE(x) \\\n-\t      __asm__ __volatile__ (\"\tprefetcht0\t%0\": : \"m\"(*(char *)(x)))\n-#\t  endif\n-#\tendif\n-#\tifdef USE_3DNOW_PREFETCH\n-#\t  define PREFETCH(x) \\\n-\t    __asm__ __volatile__ (\"\tprefetch\t%0\": : \"m\"(*(char *)(x)))\n-#\t  define PREFETCH_FOR_WRITE(x) \n-\t    __asm__ __volatile__ (\"\tprefetchw\t%0\": : \"m\"(*(char *)(x)))\n-#\tendif\n-#   endif\n-#   ifdef CYGWIN32\n-#       define OS_TYPE \"CYGWIN32\"\n-          extern int _data_start__;\n-          extern int _data_end__;\n-          extern int _bss_start__;\n-          extern int _bss_end__;\n-  \t/* For binutils 2.9.1, we have\t\t\t*/\n-  \t/*\tDATASTART   = _data_start__\t\t*/\n-  \t/*\tDATAEND\t    = _bss_end__\t\t*/\n-  \t/* whereas for some earlier versions it was\t*/\n-  \t/*\tDATASTART   = _bss_start__\t\t*/\n-  \t/*\tDATAEND\t    = _data_end__\t\t*/\n-  \t/* To get it right for both, we take the\t*/\n-  \t/* minumum/maximum of the two.\t\t\t*/\n-#   \tdefine MAX(x,y) ((x) > (y) ? (x) : (y))\n-#   \tdefine MIN(x,y) ((x) < (y) ? (x) : (y))\n-#       define DATASTART ((ptr_t) MIN(&_data_start__, &_bss_start__))\n-#       define DATAEND\t ((ptr_t) MAX(&_data_end__, &_bss_end__))\n-#\tundef STACK_GRAN\n-#       define STACK_GRAN 0x10000\n-#       define HEURISTIC1\n-#   endif\n-#   ifdef OS2\n-#\tdefine OS_TYPE \"OS2\"\n- \t    \t/* STACKBOTTOM and DATASTART are handled specially in \t*/\n-\t\t/* os_dep.c. OS2 actually has the right\t\t\t*/\n-\t\t/* system call!\t\t\t\t\t\t*/\n-#\tdefine DATAEND\t/* not needed */\n-#   endif\n-#   ifdef MSWIN32\n-#\tdefine OS_TYPE \"MSWIN32\"\n-\t\t/* STACKBOTTOM and DATASTART are handled specially in \t*/\n-\t\t/* os_dep.c.\t\t\t\t\t\t*/\n-#       ifndef __WATCOMC__\n-#\t  define MPROTECT_VDB\n-#\tendif\n-#       define DATAEND  /* not needed */\n-#   endif\n-#   ifdef DJGPP\n-#       define OS_TYPE \"DJGPP\"\n-#       include \"stubinfo.h\"\n-        extern int etext;\n-        extern int _stklen;\n-        extern int __djgpp_stack_limit;\n-#       define DATASTART ((ptr_t)((((word) (&etext)) + 0x1ff) & ~0x1ff))\n-/* #       define STACKBOTTOM ((ptr_t)((word) _stubinfo + _stubinfo->size \\\n-                                                     + _stklen)) */\n-#       define STACKBOTTOM ((ptr_t)((word) __djgpp_stack_limit + _stklen))\n-\t\t/* This may not be right.  */\n-#   endif\n-#   ifdef OPENBSD\n-#\tdefine OS_TYPE \"OPENBSD\"\n-#   endif\n-#   ifdef FREEBSD\n-#\tdefine OS_TYPE \"FREEBSD\"\n-#\tdefine MPROTECT_VDB\n-#   endif\n-#   ifdef NETBSD\n-#\tdefine OS_TYPE \"NETBSD\"\n-#   endif\n-#   ifdef THREE86BSD\n-#\tdefine OS_TYPE \"THREE86BSD\"\n-#   endif\n-#   ifdef BSDI\n-#\tdefine OS_TYPE \"BSDI\"\n-#   endif\n-#   if defined(OPENBSD) || defined(FREEBSD) || defined(NETBSD) \\\n-        || defined(THREE86BSD) || defined(BSDI)\n-#\tdefine HEURISTIC2\n-\textern char etext;\n-#\tdefine DATASTART ((ptr_t)(&etext))\n-#   endif\n-#   ifdef NEXT\n-#\tdefine OS_TYPE \"NEXT\"\n-#\tdefine DATASTART ((ptr_t) get_etext())\n-#\tdefine STACKBOTTOM ((ptr_t)0xc0000000)\n-#\tdefine DATAEND\t/* not needed */\n-#   endif\n-#   ifdef DOS4GW\n-#     define OS_TYPE \"DOS4GW\"\n-      extern long __nullarea;\n-      extern char _end;\n-      extern char *_STACKTOP;\n-      /* Depending on calling conventions Watcom C either precedes\n-         or does not precedes with undescore names of C-variables.\n-         Make sure startup code variables always have the same names.  */\n-      #pragma aux __nullarea \"*\";\n-      #pragma aux _end \"*\";\n-#     define STACKBOTTOM ((ptr_t) _STACKTOP)\n-                         /* confused? me too. */\n-#     define DATASTART ((ptr_t) &__nullarea)\n-#     define DATAEND ((ptr_t) &_end)\n-#   endif\n-# endif\n-\n-# ifdef NS32K\n-#   define MACH_TYPE \"NS32K\"\n-#   define ALIGNMENT 4\n-    extern char **environ;\n-#   define DATASTART ((ptr_t)(&environ))\n-\t\t\t      /* hideous kludge: environ is the first   */\n-\t\t\t      /* word in crt0.o, and delimits the start */\n-\t\t\t      /* of the data segment, no matter which   */\n-\t\t\t      /* ld options were passed through.        */\n-#   define STACKBOTTOM ((ptr_t) 0xfffff000) /* for Encore */\n-# endif\n-\n-# ifdef MIPS\n-# ifndef ECOS\n-#   define MACH_TYPE \"MIPS\"\n-\t/* LIBGCJ LOCAL: respect predefined DATASTART_IS_ETEXT.  */\n-#   ifdef DATASTART_IS_ETEXT\n-        extern int _etext;\n-#     define DATASTART ((ptr_t)(&_etext))\n-#   else\n-/* #   define STACKBOTTOM ((ptr_t)0x7fff8000)  sometimes also works.  */\n-#   ifdef LINUX\n-      /* This was developed for a linuxce style platform.  Probably\t*/\n-      /* needs to be tweaked for workstation class machines.\t\t*/\n-#     define OS_TYPE \"LINUX\"\n-      extern int __data_start;\n-#     define DATASTART ((ptr_t)(&__data_start))\n-#     define ALIGNMENT 4\n-#     define USE_GENERIC_PUSH_REGS 1\n-#     define STACKBOTTOM 0x80000000\n-\t/* In many cases, this should probably use LINUX_STACKBOTTOM \t*/\n-\t/* instead. But some kernel versions seem to give the wrong\t*/\n-\t/* value from /proc.\t\t\t\t\t\t*/\n-#   endif /* Linux */\n-#   ifdef ULTRIX\n-#\tdefine HEURISTIC2\n-#       define DATASTART (ptr_t)0x10000000\n-\t\t\t      /* Could probably be slightly higher since */\n-\t\t\t      /* startup code allocates lots of stuff.   */\n-#\tdefine OS_TYPE \"ULTRIX\"\n-#       define ALIGNMENT 4\n-#   endif\n-#   ifdef RISCOS\n-#\tdefine HEURISTIC2\n-#       define DATASTART (ptr_t)0x10000000\n-#\tdefine OS_TYPE \"RISCOS\"\n-#   \tdefine ALIGNMENT 4  /* Required by hardware */\n-#   endif\n-#   ifdef IRIX5\n-#\tdefine HEURISTIC2\n-        extern int _fdata;\n-#       define DATASTART ((ptr_t)(&_fdata))\n-#       ifdef USE_MMAP\n-#         define HEAP_START (ptr_t)0x30000000\n-#       else\n-#\t  define HEAP_START DATASTART\n-#       endif\n-\t\t\t      /* Lowest plausible heap address.\t\t*/\n-\t\t\t      /* In the MMAP case, we map there.\t*/\n-\t\t\t      /* In either case it is used to identify\t*/\n-\t\t\t      /* heap sections so they're not \t\t*/\n-\t\t\t      /* considered as roots.\t\t\t*/\n-#\tdefine OS_TYPE \"IRIX5\"\n-#       define MPROTECT_VDB\n-#       ifdef _MIPS_SZPTR\n-#\t  define CPP_WORDSZ _MIPS_SZPTR\n-#\t  define ALIGNMENT (_MIPS_SZPTR/8)\n-#\t  if CPP_WORDSZ != 64\n-#\t    define ALIGN_DOUBLE\n-#\t  endif\n-#\telse\n-#         define ALIGNMENT 4\n-#\t  define ALIGN_DOUBLE\n-#\tendif\n-#\tdefine DYNAMIC_LOADING\n-#   endif\n-#   endif /* DATASTART_IS_ETEXT */\n-#   endif /* ECOS */\n-# ifdef ECOS\n-    extern char __ram_data_start;\n-    extern char __ram_data_end;\n-#   define MACH_TYPE \"MIPS\"\n-#   define DATASTART (ptr_t)(&__ram_data_start)\n-#   define DATAEND (ptr_t)(&__ram_data_end)\n-\n-#   define HEURISTIC2\n-#   define ALIGNMENT 4\n-#   define ALIGN_DOUBLE\n-#   endif /* ECOS */\n-# endif\n-\n-# ifdef RS6000\n-#   define MACH_TYPE \"RS6000\"\n-#   define ALIGNMENT 4\n-#   define DATASTART ((ptr_t)0x20000000)\n-    extern int errno;\n-#   define STACKBOTTOM ((ptr_t)((ulong)&errno))\n-#   define DYNAMIC_LOADING\n-\t/* For really old versions of AIX, this may have to be removed. */\n-# endif\n-\n-# ifdef HP_PA\n-    /* OS is assumed to be HP/UX\t*/\n-#   define MACH_TYPE \"HP_PA\"\n-#   define OS_TYPE \"HPUX\"\n-#   ifdef __LP64__\n-#     define CPP_WORDSZ 64\n-#     define ALIGNMENT 8\n-#   else\n-#     define CPP_WORDSZ 32\n-#     define ALIGNMENT 4\n-#     define ALIGN_DOUBLE\n-#   endif\n-    extern int __data_start;\n-#   define DATASTART ((ptr_t)(&__data_start))\n-#   if 0\n-\t/* The following appears to work for 7xx systems running HP/UX\t*/\n-\t/* 9.xx Furthermore, it might result in much faster\t\t*/\n-\t/* collections than HEURISTIC2, which may involve scanning\t*/\n-\t/* segments that directly precede the stack.  It is not the\t*/\n-\t/* default, since it may not work on older machine/OS\t\t*/\n-\t/* combinations. (Thanks to Raymond X.T. Nijssen for uncovering\t*/\n-\t/* this.)\t\t\t\t\t\t\t*/\n-#       define STACKBOTTOM ((ptr_t) 0x7b033000)  /* from /etc/conf/h/param.h */\n-#   else\n-\t/* Gustavo Rodriguez-Rivera suggested changing HEURISTIC2\t*/\n-\t/* to this.  We'll probably do this on other platforms, too.\t*/\n-\t/* For now I'll use it where I can test it.\t\t\t*/\n-\textern char ** environ;\n-#       define STACKBOTTOM ((ptr_t)environ)\n-#   endif\n-#   define STACK_GROWS_UP\n-#   define DYNAMIC_LOADING\n-#   ifndef HPUX_THREADS\n-#     define MPROTECT_VDB\n-#   endif\n-#   include <unistd.h>\n-#   define GETPAGESIZE() sysconf(_SC_PAGE_SIZE)\n-# endif\n-\n-# ifdef ALPHA\n-#   define MACH_TYPE \"ALPHA\"\n-#   define ALIGNMENT 8\n-#   define USE_GENERIC_PUSH_REGS\n-\t/* Gcc and probably the DEC/Compaq compiler spill pointers to preserved\t*/\n-\t/* fp registers in some cases when the target is a 21264.  The assembly\t*/\n-\t/* code doesn't handle that yet, and version dependencies make that a\t*/\n-\t/* bit tricky.  Do the easy thing for now.\t\t\t\t*/\n-#   ifdef OSF1\n-#\tdefine OS_TYPE \"OSF1\"\n-#   \tdefine DATASTART ((ptr_t) 0x140000000)\n-\textern int _end;\n-#   \tdefine DATAEND ((ptr_t) &_end)\n-#   \tdefine HEURISTIC2\n-\t/* Normally HEURISTIC2 is too conervative, since\t\t*/\n-\t/* the text segment immediately follows the stack.\t\t*/\n-\t/* Hence we give an upper pound.\t\t\t\t*/\n-    \textern int __start;\n-#   \tdefine HEURISTIC2_LIMIT ((ptr_t)((word)(&__start) & ~(getpagesize()-1)))\n-#   \tdefine CPP_WORDSZ 64\n-#   \tdefine MPROTECT_VDB\n-#   \tdefine DYNAMIC_LOADING\n-#   endif\n-#   ifdef LINUX\n-#       define OS_TYPE \"LINUX\"\n-#       define CPP_WORDSZ 64\n-#       define STACKBOTTOM ((ptr_t) 0x120000000)\n-#       ifdef __ELF__\n-#\t  define LINUX_DATA_START\n-#         define DYNAMIC_LOADING\n-\t  /* This doesn't work if the collector is in a dynamic library. */\n-#       else\n-#           define DATASTART ((ptr_t) 0x140000000)\n-#       endif\n-\textern int _end;\n-#\tdefine DATAEND (&_end)\n-#\tundef MPROTECT_VDB\n-\t\t/* Has only been superficially tested.  May not\t*/\n-\t\t/* work on all versions.\t\t\t*/\n-#   endif\n-# endif\n-\n-# ifdef IA64\n-#   define MACH_TYPE \"IA64\"\n-#   define ALIGN_DOUBLE\n-\t/* Requires 16 byte alignment for malloc */\n-#   define ALIGNMENT 8\n-#   define USE_GENERIC_PUSH_REGS\n-\t/* We need to get preserved registers in addition to register windows.\t*/\n-\t/* That's easiest to do with setjmp.\t\t\t\t\t*/\n-#   ifdef HPUX\n-\t--> needs work\n-#   endif\n-#   ifdef LINUX\n-#       define OS_TYPE \"LINUX\"\n-#       define CPP_WORDSZ 64\n-\t/* This should really be done through /proc, but that\t*/\n-\t/* requires we run on an IA64 kernel.\t\t\t*/\n-\t/* The following works on NUE and older kernels:\t*/\n-/* #       define STACKBOTTOM ((ptr_t) 0xa000000000000000l)\t*/\n-\t/* This does not work on NUE:\t\t\t\t*/\n-#       define LINUX_STACKBOTTOM\n-\t/* We also need the base address of the register stack\t*/\n-\t/* backing store.  There should be a better way to get\t*/\n-\t/* this:\t\t\t\t\t\t*/\n-#\tdefine APPROX_BS_BASE ((word)GC_stackbottom-0x80000000)\n-\t/* We round to the next multiple of 1 MB, to compensate\t*/\n-\t/* for the fact that the stack base is displaced by\t*/\n-\t/* the environment, etc.\t\t\t\t*/\n-#\tdefine BACKING_STORE_BASE \\\n-\t\t(ptr_t)((APPROX_BS_BASE + 0xfffff) & ~0xfffff)\n-\n-#\tif 1\n-#\t    define SEARCH_FOR_DATA_START\n-#\t    define DATASTART GC_data_start\n-#\telse\n-\t    extern int data_start;\n-#\t    define DATASTART ((ptr_t)(&data_start))\n-#\tendif\n-#       define DYNAMIC_LOADING\n-#\tdefine MPROTECT_VDB\n-\t\t/* Requires Linux 2.3.47 or later.\t*/\n-\textern int _end;\n-#\tdefine DATAEND (&_end)\n-#\tdefine PREFETCH(x) \\\n-\t  __asm__ (\"\tlfetch\t[%0]\": : \"r\"((void *)(x)))\n-#\tdefine PREFETCH_FOR_WRITE(x) \\\n-\t  __asm__ (\"\tlfetch.excl\t[%0]\": : \"r\"((void *)(x)))\n-#\tdefine CLEAR_DOUBLE(x) \\\n-\t  __asm__ (\"\tstf.spill\t[%0]=f0\": : \"r\"((void *)(x)))\n-#   endif\n-# endif\n-\n-# ifdef M88K\n-#   define MACH_TYPE \"M88K\"\n-#   define ALIGNMENT 4\n-#   define ALIGN_DOUBLE\n-    extern int etext;\n-#   ifdef CX_UX\n-#\tdefine OS_TYPE \"CX_UX\"\n-#       define DATASTART ((((word)&etext + 0x3fffff) & ~0x3fffff) + 0x10000)\n-#   endif\n-#   ifdef  DGUX\n-#\tdefine OS_TYPE \"DGUX\"\n-\textern char * GC_SysVGetDataStart();\n-#       define DATASTART (ptr_t)GC_SysVGetDataStart(0x10000, &etext)\n-#   endif\n-#   define STACKBOTTOM ((char*)0xf0000000) /* determined empirically */\n-# endif\n-\n-# ifdef S370\n-#   define MACH_TYPE \"S370\"\n-#   define OS_TYPE \"UTS4\"\n-#   define ALIGNMENT 4\t/* Required by hardware\t*/\n-    extern int etext;\n-\textern int _etext;\n-\textern int _end;\n-\textern char * GC_SysVGetDataStart();\n-#       define DATASTART (ptr_t)GC_SysVGetDataStart(0x10000, &_etext)\n-#\tdefine DATAEND (&_end)\n-#\tdefine HEURISTIC2\n-# endif\n-\n-# if defined(PJ)\n-#   define ALIGNMENT 4\n-    extern int _etext;\n-#   define DATASTART ((ptr_t)(&_etext))\n-#   define HEURISTIC1\n-# endif\n-\n-# ifdef ARM32\n-#   define CPP_WORDSZ 32\n-#   define MACH_TYPE \"ARM32\"\n-#   define ALIGNMENT 4\n-#   ifdef NETBSD\n-#       define OS_TYPE \"NETBSD\"\n-#       define HEURISTIC2\n-        extern char etext;\n-#       define DATASTART ((ptr_t)(&etext))\n-#       define USE_GENERIC_PUSH_REGS\n-#   endif\n-#   ifdef LINUX\n-#       define OS_TYPE \"LINUX\"\n-#       define HEURISTIC1\n-#       undef STACK_GRAN\n-#       define STACK_GRAN 0x10000000\n-#       define USE_GENERIC_PUSH_REGS\n-#       ifdef __ELF__\n-#            define DYNAMIC_LOADING\n-#\t     include <features.h>\n-#\t     if defined(__GLIBC__) && __GLIBC__ >= 2\n-#\t\t define LINUX_DATA_START\n-#\t     else\n-     \t         extern char **__environ;\n-#                define DATASTART ((ptr_t)(&__environ))\n-\t\t\t      /* hideous kludge: __environ is the first */\n-\t\t\t      /* word in crt0.o, and delimits the start */\n-\t\t\t      /* of the data segment, no matter which   */\n-\t\t\t      /* ld options were passed through.        */\n-\t\t\t      /* We could use _etext instead, but that  */\n-\t\t\t      /* would include .rodata, which may       */\n-\t\t\t      /* contain large read-only data tables    */\n-\t\t\t      /* that we'd rather not scan.\t\t*/\n-#\t     endif\n-\t     extern int _end;\n-#\t     define DATAEND (&_end)\n-#\telse\n-\t     extern int etext;\n-#            define DATASTART ((ptr_t)((((word) (&etext)) + 0xfff) & ~0xfff))\n-#       endif\n-#   endif\n-#endif\n-\n-#ifdef LINUX_DATA_START\n-    /* Some Linux distributions arrange to define __data_start.  Some\t*/\n-    /* define data_start as a weak symbol.  The latter is technically\t*/\n-    /* broken, since the user program may define data_start, in which\t*/\n-    /* case we lose.  Nonetheless, we try both, prefering __data_start.\t*/\n-    /* We assume gcc.\t*/\n-#   pragma weak __data_start\n-    extern int __data_start;\n-#   pragma weak data_start\n-    extern int data_start;\n-#   define DATASTART ((ptr_t)(&__data_start != 0? &__data_start : &data_start))\n-#endif\n-\n-# ifndef STACK_GROWS_UP\n-#   define STACK_GROWS_DOWN\n-# endif\n-\n-# ifndef CPP_WORDSZ\n-#   define CPP_WORDSZ 32\n-# endif\n-\n-# ifndef OS_TYPE\n-#   define OS_TYPE \"\"\n-# endif\n-\n-# ifndef DATAEND\n-    extern int end;\n-#   define DATAEND (&end)\n-# endif\n-\n-# if defined(SVR4) && !defined(GETPAGESIZE)\n-#    include <unistd.h>\n-#    define GETPAGESIZE()  sysconf(_SC_PAGESIZE)\n-# endif\n-\n-# ifndef GETPAGESIZE\n-#   if defined(SUNOS5) || defined(IRIX5)\n-#\tinclude <unistd.h>\n-#   endif\n-#   define GETPAGESIZE() getpagesize()\n-# endif\n-\n-# if defined(SUNOS5) || defined(DRSNX) || defined(UTS4)\n-    /* OS has SVR4 generic features.  Probably others also qualify.\t*/\n-#   define SVR4\n-# endif\n-\n-# if defined(SUNOS5) || defined(DRSNX)\n-    /* OS has SUNOS5 style semi-undocumented interface to dynamic \t*/\n-    /* loader.\t\t\t\t\t\t\t\t*/\n-#   define SUNOS5DL\n-    /* OS has SUNOS5 style signal handlers.\t\t\t\t*/\n-#   define SUNOS5SIGS\n-# endif\n-\n-# if defined(HPUX)\n-#   define SUNOS5SIGS\n-# endif\n-\n-# if CPP_WORDSZ != 32 && CPP_WORDSZ != 64\n-   -> bad word size\n-# endif\n-\n-# ifdef PCR\n-#   undef DYNAMIC_LOADING\n-#   undef STACKBOTTOM\n-#   undef HEURISTIC1\n-#   undef HEURISTIC2\n-#   undef PROC_VDB\n-#   undef MPROTECT_VDB\n-#   define PCR_VDB\n-# endif\n-\n-# ifdef SRC_M3\n-/* Postponed for now. */\n-#   undef PROC_VDB\n-#   undef MPROTECT_VDB\n-# endif\n-\n-# ifdef SMALL_CONFIG\n-/* Presumably not worth the space it takes. */\n-#   undef PROC_VDB\n-#   undef MPROTECT_VDB\n-# endif\n-\n-# ifdef USE_MUNMAP\n-#   undef MPROTECT_VDB  /* Can't deal with address space holes. */\n-# endif\n-\n-# if !defined(PCR_VDB) && !defined(PROC_VDB) && !defined(MPROTECT_VDB)\n-#   define DEFAULT_VDB\n-# endif\n-\n-# ifndef PREFETCH\n-#   define PREFETCH(x)\n-#   define NO_PREFETCH\n-# endif\n-\n-# ifndef PREFETCH_FOR_WRITE\n-#   define PREFETCH_FOR_WRITE(x)\n-#   define NO_PREFETCH_FOR_WRITE\n-# endif\n-\n-# ifndef CACHE_LINE_SIZE\n-#   define CACHE_LINE_SIZE 32\t/* Wild guess\t*/\n-# endif\n-\n-# ifndef CLEAR_DOUBLE\n-#   define CLEAR_DOUBLE(x) \\\n-\t((word*)x)[0] = 0; \\\n-\t((word*)x)[1] = 0;\n-# endif /* CLEAR_DOUBLE */\n-\n-# if defined(_SOLARIS_PTHREADS) && !defined(SOLARIS_THREADS)\n-#   define SOLARIS_THREADS\n-# endif\n-# if defined(IRIX_THREADS) && !defined(IRIX5)\n---> inconsistent configuration\n-# endif\n-# if defined(IRIX_JDK_THREADS) && !defined(IRIX5)\n---> inconsistent configuration\n-# endif\n-# if defined(LINUX_THREADS) && !defined(LINUX)\n---> inconsistent configuration\n-# endif\n-# if defined(SOLARIS_THREADS) && !defined(SUNOS5)\n---> inconsistent configuration\n-# endif\n-# if defined(HPUX_THREADS) && !defined(HPUX)\n---> inconsistent configuration\n-# endif\n-# if defined(PCR) || defined(SRC_M3) || \\\n-\tdefined(SOLARIS_THREADS) || defined(WIN32_THREADS) || \\\n-\tdefined(IRIX_THREADS) || defined(LINUX_THREADS) || \\\n-\tdefined(IRIX_JDK_THREADS) || defined(HPUX_THREADS)\n-#   define THREADS\n-# endif\n-\n-# if defined(HP_PA) || defined(M88K) || defined(POWERPC) \\\n-     || (defined(I386) && defined(OS2)) || defined(UTS4) || defined(LINT)\n-\t/* Use setjmp based hack to mark from callee-save registers. */\n-#\tdefine USE_GENERIC_PUSH_REGS\n-# endif\n-# if defined(SPARC)\n-#   define SAVE_CALL_CHAIN\n-#   define ASM_CLEAR_CODE\t/* Stack clearing is crucial, and we \t*/\n-\t\t\t\t/* include assembly code to do it well.\t*/\n-# endif\n-\n-# endif /* GCCONFIG_H */"}, {"sha": "5f5636d02a5d70edc95234cc7ffafae77a17a1df", "filename": "boehm-gc/gcj_mlc.c", "status": "modified", "additions": 22, "deletions": 24, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9110a741e35c54e46c00662ddc420575376c5947/boehm-gc%2Fgcj_mlc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9110a741e35c54e46c00662ddc420575376c5947/boehm-gc%2Fgcj_mlc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fgcj_mlc.c?ref=9110a741e35c54e46c00662ddc420575376c5947", "patch": "@@ -17,13 +17,13 @@\n #ifdef GC_GCJ_SUPPORT\n \n /*\n- * This is an allocator interface tuned for gcj (the GNU/Cygnus static\n+ * This is an allocator interface tuned for gcj (the GNU static\n  * java compiler).\n  *\n  * Each allocated object has a pointer in its first word to a vtable,\n  * which for our purposes is simply a structure describing the type of\n  * the object.\n- * This descriptor structur contains a GC marking descriptor at offset\n+ * This descriptor structure contains a GC marking descriptor at offset\n  * MARK_DESCR_OFFSET.\n  *\n  * It is hoped that this interface may also be useful for other systems,\n@@ -36,10 +36,10 @@\n  *  3) FASTLOCK is not a significant win.\n  */\n \n-#include \"gc_priv.h\"\n-#include \"gc_mark.h\"\n-#include \"include/gc_gcj.h\"\n-#include \"dbg_mlc.h\"\n+#include \"private/gc_priv.h\"\n+#include \"private/gc_pmark.h\"\n+#include \"gc_gcj.h\"\n+#include \"private/dbg_mlc.h\"\n \n GC_bool GC_gcj_malloc_initialized = FALSE;\n \n@@ -51,12 +51,8 @@ int GC_gcj_debug_kind;\t/* The kind of objects that is always marked \t*/\n ptr_t * GC_gcjobjfreelist;\n ptr_t * GC_gcjdebugobjfreelist;\n \n-void * GC_default_oom_action(void) { return 0; }\n-\n-void * (*GC_oom_action)(void) = GC_default_oom_action;\n-\n /* Caller does not hold allocation lock. */\n-void GC_init_gcj_malloc(int mp_index, void * /* really mark_proc */mp)\n+void GC_init_gcj_malloc(int mp_index, void * /* really GC_mark_proc */mp)\n {\n     register int i;\n     DCL_LOCK_STATE;\n@@ -70,31 +66,31 @@ void GC_init_gcj_malloc(int mp_index, void * /* really mark_proc */mp)\n       return;\n     }\n     GC_gcj_malloc_initialized = TRUE;\n-    GC_mark_procs[mp_index] = (mark_proc)mp;\n+    GC_mark_procs[mp_index] = (GC_mark_proc)mp;\n     if (mp_index >= GC_n_mark_procs) ABORT(\"GC_init_gcj_malloc: bad index\");\n     /* Set up object kind gcj-style indirect descriptor. */\n       GC_gcjobjfreelist = (ptr_t *)\n-          GC_generic_malloc_inner((MAXOBJSZ+1)*sizeof(ptr_t), PTRFREE);\n+          GC_INTERNAL_MALLOC((MAXOBJSZ+1)*sizeof(ptr_t), PTRFREE);\n       if (GC_gcjobjfreelist == 0) ABORT(\"Couldn't allocate GC_gcjobjfreelist\");\n       BZERO(GC_gcjobjfreelist, (MAXOBJSZ+1)*sizeof(ptr_t));\n       GC_gcj_kind = GC_n_kinds++;\n       GC_obj_kinds[GC_gcj_kind].ok_freelist = GC_gcjobjfreelist;\n       GC_obj_kinds[GC_gcj_kind].ok_reclaim_list = 0;\n       GC_obj_kinds[GC_gcj_kind].ok_descriptor =\n-    \t(((word)(-MARK_DESCR_OFFSET - INDIR_PER_OBJ_BIAS)) | DS_PER_OBJECT);\n+    \t(((word)(-MARK_DESCR_OFFSET - GC_INDIR_PER_OBJ_BIAS)) | GC_DS_PER_OBJECT);\n       GC_obj_kinds[GC_gcj_kind].ok_relocate_descr = FALSE;\n       GC_obj_kinds[GC_gcj_kind].ok_init = TRUE;\n     /* Set up object kind for objects that require mark proc call.\t*/\n       GC_gcjdebugobjfreelist = (ptr_t *)\n-          GC_generic_malloc_inner((MAXOBJSZ+1)*sizeof(ptr_t), PTRFREE);\n+          GC_INTERNAL_MALLOC((MAXOBJSZ+1)*sizeof(ptr_t), PTRFREE);\n       if (GC_gcjdebugobjfreelist == 0)\n \t  ABORT(\"Couldn't allocate GC_gcjdebugobjfreelist\");\n       BZERO(GC_gcjdebugobjfreelist, (MAXOBJSZ+1)*sizeof(ptr_t));\n       GC_gcj_debug_kind = GC_n_kinds++;\n       GC_obj_kinds[GC_gcj_debug_kind].ok_freelist = GC_gcjdebugobjfreelist;\n       GC_obj_kinds[GC_gcj_debug_kind].ok_reclaim_list = 0;\n       GC_obj_kinds[GC_gcj_debug_kind].ok_descriptor =\n-    \tMAKE_PROC(mp_index, 1 /* allocated with debug info */);\n+    \tGC_MAKE_PROC(mp_index, 1 /* allocated with debug info */);\n       GC_obj_kinds[GC_gcj_debug_kind].ok_relocate_descr = FALSE;\n       GC_obj_kinds[GC_gcj_debug_kind].ok_init = TRUE;\n     UNLOCK();\n@@ -119,19 +115,20 @@ register ptr_t * opp;\n register word lw;\n DCL_LOCK_STATE;\n \n-    if( SMALL_OBJ(lb) ) {\n+    if( EXPECT(SMALL_OBJ(lb), 1) ) {\n #       ifdef MERGE_SIZES\n \t  lw = GC_size_map[lb];\n #\telse\n \t  lw = ALIGNED_WORDS(lb);\n #       endif\n \topp = &(GC_gcjobjfreelist[lw]);\n \tLOCK();\n-        if( (op = *opp) == 0 ) {\n+\top = *opp;\n+        if( EXPECT(op == 0, 0)) {\n             op = (ptr_t)GENERAL_MALLOC((word)lb, GC_gcj_kind);\n \t    if (0 == op) {\n \t\tUNLOCK();\n-\t\treturn(GC_oom_action());\n+\t\treturn(GC_oom_fn(lb));\n \t    }\n #\t    ifdef MERGE_SIZES\n \t\tlw = GC_size_map[lb];\t/* May have been uninitialized.\t*/\n@@ -147,7 +144,7 @@ DCL_LOCK_STATE;\n \top = (ptr_t)GENERAL_MALLOC((word)lb, GC_gcj_kind);\n \tif (0 == op) {\n \t    UNLOCK();\n-\t    return(GC_oom_action());\n+\t    return(GC_oom_fn(lb));\n \t}\n \t*(void **)op = ptr_to_struct_containing_descr;\n \tUNLOCK();\n@@ -174,7 +171,7 @@ GC_PTR GC_debug_gcj_malloc(size_t lb, void * ptr_to_struct_containing_descr,\n \t\t       (unsigned long) ptr_to_struct_containing_descr);\n         GC_err_puts(s);\n         GC_err_printf1(\":%ld)\\n\", (unsigned long)i);\n-        return(GC_oom_action());\n+        return(GC_oom_fn(lb));\n     }\n     *((void **)((ptr_t)result + sizeof(oh))) = ptr_to_struct_containing_descr;\n     UNLOCK();\n@@ -196,12 +193,13 @@ DCL_LOCK_STATE;\n \n     opp = &(GC_gcjobjfreelist[lw]);\n     LOCK();\n-    if( (op = *opp) == 0 ) {\n+    op = *opp;\n+    if( EXPECT(op == 0, 0) ) {\n         op = (ptr_t)GC_clear_stack(\n \t\tGC_generic_malloc_words_small_inner(lw, GC_gcj_kind));\n \tif (0 == op) {\n \t    UNLOCK();\n-\t    return(GC_oom_action());\n+\t    return GC_oom_fn(WORDS_TO_BYTES(lw));\n \t}\n     } else {\n         *opp = obj_link(op);\n@@ -232,7 +230,7 @@ void * GC_debug_gcj_fast_malloc(size_t lw,\n \t\t       (unsigned long) ptr_to_struct_containing_descr);\n         GC_err_puts(s);\n         GC_err_printf1(\":%ld)\\n\", (unsigned long)i);\n-        return(GC_oom_action());\n+        return GC_oom_fn(WORDS_TO_BYTES(lw));\n     }\n     *((void **)((ptr_t)result + sizeof(oh))) = ptr_to_struct_containing_descr;\n     UNLOCK();"}, {"sha": "0aa513973c96af518637ccaff28d3814575abc47", "filename": "boehm-gc/headers.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9110a741e35c54e46c00662ddc420575376c5947/boehm-gc%2Fheaders.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9110a741e35c54e46c00662ddc420575376c5947/boehm-gc%2Fheaders.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fheaders.c?ref=9110a741e35c54e46c00662ddc420575376c5947", "patch": "@@ -22,7 +22,7 @@\n  * level tree.\n  */\n  \n-# include \"gc_priv.h\"\n+# include \"private/gc_priv.h\"\n \n bottom_index * GC_all_bottom_indices = 0;\n \t\t\t\t/* Pointer to first (lowest addr) */\n@@ -260,7 +260,7 @@ register word sz; /* bytes */\n /* Apply fn to all allocated blocks */\n /*VARARGS1*/\n void GC_apply_to_all_blocks(fn, client_data)\n-void (*fn)(/* struct hblk *h, word client_data */);\n+void (*fn) GC_PROTO((struct hblk *h, word client_data));\n word client_data;\n {\n     register int j;"}, {"sha": "fd6009e1c354a694234a187b14db8392c90261c1", "filename": "boehm-gc/if_mach.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9110a741e35c54e46c00662ddc420575376c5947/boehm-gc%2Fif_mach.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9110a741e35c54e46c00662ddc420575376c5947/boehm-gc%2Fif_mach.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fif_mach.c?ref=9110a741e35c54e46c00662ddc420575376c5947", "patch": "@@ -1,7 +1,9 @@\n /* Conditionally execute a command based on machine and OS from gcconfig.h */\n \n-# include \"gcconfig.h\"\n+# include \"private/gcconfig.h\"\n # include <stdio.h>\n+# include <string.h>\n+# include <unistd.h>\n \n int main(argc, argv, envp)\n int argc;\n@@ -13,6 +15,7 @@ char ** envp;\n     if (strcmp(OS_TYPE, \"\") != 0 && strcmp(argv[2], \"\") != 0\n         && strcmp(OS_TYPE, argv[2]) != 0) return(0);\n     printf(\"^^^^Starting command^^^^\\n\");\n+    fflush(stdout);\n     execvp(argv[3], argv+3);\n     perror(\"Couldn't execute\");\n     "}, {"sha": "42dd8034ac7e8d6021dd4a72aec7e038653250c5", "filename": "boehm-gc/if_not_there.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9110a741e35c54e46c00662ddc420575376c5947/boehm-gc%2Fif_not_there.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9110a741e35c54e46c00662ddc420575376c5947/boehm-gc%2Fif_not_there.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fif_not_there.c?ref=9110a741e35c54e46c00662ddc420575376c5947", "patch": "@@ -1,7 +1,9 @@\n /* Conditionally execute a command based if the file argv[1] doesn't exist */\n /* Except for execvp, we stick to ANSI C.\t\t\t\t   */\n-# include \"gcconfig.h\"\n+# include \"private/gcconfig.h\"\n # include <stdio.h>\n+# include <stdlib.h>\n+# include <unistd.h>\n \n int main(argc, argv, envp)\n int argc;\n@@ -16,6 +18,7 @@ char ** envp;\n         return(0);\n     }\n     printf(\"^^^^Starting command^^^^\\n\");\n+    fflush(stdout);\n     execvp(argv[2], argv+2);\n     exit(1);\n     "}, {"sha": "f5b7c5aa2b948d732f7dfd06d214ef8e2f966980", "filename": "boehm-gc/include/backptr.h", "status": "removed", "additions": 0, "deletions": 63, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6951ca5dee8ed05749cdc697767910aebaedcc0/boehm-gc%2Finclude%2Fbackptr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6951ca5dee8ed05749cdc697767910aebaedcc0/boehm-gc%2Finclude%2Fbackptr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fbackptr.h?ref=a6951ca5dee8ed05749cdc697767910aebaedcc0", "patch": "@@ -1,63 +0,0 @@\n-/*\n- * This is a simple API to implement pointer back tracing, i.e.\n- * to answer questions such as \"who is pointing to this\" or\n- * \"why is this object being retained by the collector\"\n- *\n- * This API assumes that we have an ANSI C compiler.\n- *\n- * Most of these calls yield useful information on only after\n- * a garbage collection.  Usually the client will first force\n- * a full collection and then gather information, preferably\n- * before much intervening allocation.\n- *\n- * The implementation of the interface is only about 99.9999%\n- * correct.  It is intended to be good enough for profiling,\n- * but is not intended to be used with production code.\n- *\n- * Results are likely to be much more useful if all allocation is\n- * accomplished through the debugging allocators.\n- *\n- * The implementation idea is due to A. Demers.\n- */\n-\n-/* Store information about the object referencing dest in *base_p     */\n-/* and *offset_p.                                                     */\n-/* If multiple objects or roots point to dest, the one reported\t      */\n-/* will be the last on used by the garbage collector to trace the     */\n-/* object.\t\t\t\t\t\t\t      */\n-/*   source is root ==> *base_p = address, *offset_p = 0\t      */\n-/*   source is heap object ==> *base_p != 0, *offset_p = offset       */\n-/*   Returns 1 on success, 0 if source couldn't be determined.        */\n-/* Dest can be any address within a heap object.                      */\n-typedef enum {  GC_UNREFERENCED, /* No reference info available.\t*/\n-\t\tGC_NO_SPACE,\t/* Dest not allocated with debug alloc  */\n-\t\tGC_REFD_FROM_ROOT, /* Referenced directly by root *base_p */\n-\t\tGC_REFD_FROM_REG,  /* Referenced from a register, i.e.\t*/\n-\t\t\t\t   /* a root without an address.\t*/\n-\t\tGC_REFD_FROM_HEAP, /* Referenced from another heap obj. */\n-\t\tGC_FINALIZER_REFD /* Finalizable and hence accessible.  */\n-} GC_ref_kind;\n-\n-GC_ref_kind GC_get_back_ptr_info(void *dest, void **base_p, size_t *offset_p);\n-\n-/* Generate a random heap address.            */\n-/* The resulting address is in the heap, but  */\n-/* not necessarily inside a valid object.     */\n-void * GC_generate_random_heap_address(void);\n-\n-/* Generate a random address inside a valid marked heap object. */\n-void * GC_generate_random_valid_address(void);\n-\n-/* Force a garbage collection and generate a backtrace from a */\n-/* random heap address.                                       */\n-/* This uses the GC logging mechanism (GC_printf) to produce  */\n-/* output.  It can often be called from a debugger.  The      */\n-/* source in dbg_mlc.c also serves as a sample client.\t      */\n-void GC_generate_random_backtrace(void);\n-\n-/* Print a backtrace from a specific address.  Used by the \t*/\n-/* above.  The client should call GC_gcollect() immediately\t*/\n-/* before invocation.\t\t\t\t\t\t*/\n-void GC_print_backtrace(void *);\n-\n-"}, {"sha": "212c99e28dce62a8d9e072442a0cb5aa3d4fabaf", "filename": "boehm-gc/include/gc_copy_descr.h", "status": "removed", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6951ca5dee8ed05749cdc697767910aebaedcc0/boehm-gc%2Finclude%2Fgc_copy_descr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6951ca5dee8ed05749cdc697767910aebaedcc0/boehm-gc%2Finclude%2Fgc_copy_descr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fgc_copy_descr.h?ref=a6951ca5dee8ed05749cdc697767910aebaedcc0", "patch": "@@ -1,26 +0,0 @@\n-\n-/* \n- * Copyright (c) 1999 by Silicon Graphics.  All rights reserved.\n- *\n- * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n- * OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n- *\n- * Permission is hereby granted to use or copy this program\n- * for any purpose,  provided the above notices are retained on all copies.\n- * Permission to modify the code and to distribute modified code is granted,\n- * provided the above notices are retained, and a notice that the code was\n- * modified is included with the above copyright notice.\n- */\n-/* Descriptor for allocation request. May be redefined by client. */\n-typedef struct {\n-    GC_word bitmap;\t/* Bitmap describing pointer locations.\t*/\n-\t\t\t/* High order bit correspond to 0th\t*/\n-\t\t\t/* word.  2 lsbs must be 0.\t\t*/\n-    size_t length;      /* In bytes, must be multiple of word\t*/\n-\t\t\t/* size.  Must be >0, <= 512\t\t*/\n-} * GC_copy_descriptor;\n-\n-/* The collector accesses descriptors only through these two macros. */\n-#define GC_SIZE_FROM_DESCRIPTOR(d) ((d) -> length)\n-#define GC_BIT_MAP_FROM_DESCRIPTOR(d) ((d) -> bitmap)\n-"}, {"sha": "d109ff090dc162c5b8894d3395f80eae33a2a881", "filename": "boehm-gc/include/gc_nursery.h", "status": "removed", "additions": 0, "deletions": 90, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6951ca5dee8ed05749cdc697767910aebaedcc0/boehm-gc%2Finclude%2Fgc_nursery.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6951ca5dee8ed05749cdc697767910aebaedcc0/boehm-gc%2Finclude%2Fgc_nursery.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fgc_nursery.h?ref=a6951ca5dee8ed05749cdc697767910aebaedcc0", "patch": "@@ -1,90 +0,0 @@\n-\n-/* \n- * Copyright (c) 1999 by Silicon Graphics.  All rights reserved.\n- *\n- * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n- * OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n- *\n- * Permission is hereby granted to use or copy this program\n- * for any purpose,  provided the above notices are retained on all copies.\n- * Permission to modify the code and to distribute modified code is granted,\n- * provided the above notices are retained, and a notice that the code was\n- * modified is included with the above copyright notice.\n- */\n-\n-/*\n- * THIS IMPLEMENTATION FOR THIS INTERFACE IS INCOMPLETE.\n- * NONE OF THIS HAS BEEN TESTED.  DO NOT USE.\n- *\n- * Comments on the interface are appreciated, especially from\n- * potential users of the interface.\n- *\n- * This is a Bartlett style copying collector for young objects.\n- * We assume for now that all objects allocated through this\n- * mechanism have pointers only in the first BITMAP_BITS words.\n- * (On a 32-bit machine, BITMAP_BITS is 30.)\n- * Objects allocated in this manner should be rarely referenced\n- * by objects not allocated either through this interface, or through\n- * the typed allocation interface.\n- * If this interface is used, we assume that type information provided\n- * through either this or the typed allocation interface is valid\n- * in a stronger sense:\n- *\n- * 1) No pointers are stored in fields not marked as such.\n- *    (Otherwise it is only necessary that objects referenced by\n- *    fields marked as nonpointers are also reachable via another\n- *    path.)\n- * 2) Values stored in pointer fields are either not addresses in\n- *    the heap, or they really are pointers.  In the latter case, it\n- *    is acceptable to move the object they refer to, and to update\n- *    the pointer.\n- *\n- * GC_free may not be invoked on objects allocated with GC_copying_malloc.\n- *\n- * No extra space is added to the end of objects allocated through this\n- * interface.  If the client needs to maintain pointers past the\n- * end, the size should be explicitly padded.\n- * \n- * We assume that calls to this will usually be compiler generated.\n- * Hence the interface is allowed to be a bit ugly in return for speed.\n- */\n-\n-#include \"gc_copy_descr.h\"\n-\n-/* GC_copy_descr.h must define\t\t\t\t\t\t*/\n-/* GC_SIZE_FROM_DESCRIPTOR(descr) and\t\t\t\t\t*/\n-/* GC_BIT_MAP_FROM_DESCRIPTOR(descr).\t\t\t\t\t*/\n-/* It may either be the GC supplied version of the header file, or a\t*/\n-/* client specific one that derives the information from a client-\t*/\n-/* specific type descriptor.\t\t\t\t\t\t*/\n-\n-typedef GC_PTR GC_copy_alloc_state;\n-\t\t\t\t/* Current allocator state.\t*/\n-\t\t\t\t/* Multiple allocation states\t*/\n-\t\t\t\t/* may be used for concurrent\t*/\n-\t\t\t\t/* allocation, or to enhance\t*/\n-\t\t\t\t/* locality.\t\t\t*/\n-\t\t\t\t/* Should be treated as opaque.\t*/\n-\n-/* Allocate a memory block of size given in the descriptor, and with\t*/\n-/* pointer layout given by the descriptor.  The resulting block may not\t*/\n-/* be cleared, and should immediately be initialized by the client.\t*/\n-/* (A concurrent GC may see an uninitialized pointer field.  If it\t*/\n-/* points outside the nursery, that's fine.  If it points inside, it\t*/\n-/* may retain an object, and be relocated.  But that's also fine, since\t*/\n-/* the new value will be immediately overwritten.\t\t\t*/\n-/* This variant acquires the allocation lock, and uses a default \t*/\n-/* global allocation state.\t\t\t\t\t\t*/\n-GC_PTR GC_copying_malloc(GC_copy_descriptor);\n-\n-/* A variant of the above that does no locking on the fast path,\t*/\n-/* and passes an explicit pointer to an allocation state.\t\t*/\n-/* The allocation state is updated.\t\t\t\t\t*/\n-/* There will eventually need to be a macro or inline function version\t*/\n-/* of this.\t\t\t\t\t\t\t\t*/\n-GC_PTR GC_copying_malloc2(GC_copy_descriptor, GC_copy_alloc_state *);\n-\n-/* Initialize an allocation state so that it can be used for \t*/\n-/* allocation.  This implicitly reserves a small section of the\t*/\n-/* nursery for use with this allocator.\t\t\t\t*/\n-void GC_init_copy_alloc_state(GC_copy_alloc_state *);"}, {"sha": "0eec53376a8c9b21f9eba3eaa5561dd610798c12", "filename": "boehm-gc/include/private/gc_pmark.h", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9110a741e35c54e46c00662ddc420575376c5947/boehm-gc%2Finclude%2Fprivate%2Fgc_pmark.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9110a741e35c54e46c00662ddc420575376c5947/boehm-gc%2Finclude%2Fprivate%2Fgc_pmark.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Finclude%2Fprivate%2Fgc_pmark.h?ref=9110a741e35c54e46c00662ddc420575376c5947", "patch": "@@ -132,9 +132,14 @@ extern mse * GC_mark_stack;\n      */\n #endif /* PARALLEL_MARK */\n \n-ptr_t GC_find_start();\n+# ifdef PRINT_BLACK_LIST\n+  ptr_t GC_find_start(ptr_t current, hdr *hhdr, word source);\n+# else\n+  ptr_t GC_find_start(ptr_t current, hdr *hhdr);\n+# define source 0\n+# endif\n \n-mse * GC_signal_mark_stack_overflow();\n+mse *GC_signal_mark_stack_overflow(mse *msp);\n \n # ifdef GATHERSTATS\n #   define ADD_TO_ATOMIC(sz) GC_atomic_in_use += (sz)\n@@ -245,7 +250,6 @@ exit_label2: ; \\\n #   define SET_MARK_BIT_EXIT_IF_SET(hhdr,displ,exit_label) \\\n     { \\\n         register word * mark_word_addr = hhdr -> hb_marks + divWORDSZ(displ); \\\n-        register word mark_word = *mark_word_addr; \\\n           \\\n         OR_WORD_EXIT_IF_SET(mark_word_addr, (word)1 << modWORDSZ(displ), \\\n \t\t\t    exit_label); \\"}, {"sha": "101f5b1f412a7259205e4c770cb70176d762a5d7", "filename": "boehm-gc/irix_threads.c", "status": "renamed", "additions": 41, "deletions": 58, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9110a741e35c54e46c00662ddc420575376c5947/boehm-gc%2Firix_threads.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9110a741e35c54e46c00662ddc420575376c5947/boehm-gc%2Firix_threads.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Firix_threads.c?ref=9110a741e35c54e46c00662ddc420575376c5947", "patch": "@@ -25,13 +25,9 @@\n  * there too.\n  */\n \n-# if defined(IRIX_THREADS) || defined(HPUX_THREADS)\n+# if defined(GC_IRIX_THREADS) || defined(IRIX_THREADS)\n \n-# if defined(HPUX_THREADS)\n-#   include <sys/semaphore.h>\n-# endif\n-\n-# include \"gc_priv.h\"\n+# include \"private/gc_priv.h\"\n # include <pthread.h>\n # include <semaphore.h>\n # include <time.h>\n@@ -43,6 +39,7 @@\n #undef pthread_create\n #undef pthread_sigmask\n #undef pthread_join\n+#undef pthread_detach\n \n void GC_thr_init();\n \n@@ -208,6 +205,11 @@ void GC_stack_free(ptr_t stack, size_t size)\n # define THREAD_TABLE_SZ 128\t/* Must be power of 2\t*/\n volatile GC_thread GC_threads[THREAD_TABLE_SZ];\n \n+void GC_push_thread_structures GC_PROTO((void))\n+{\n+    GC_push_all((ptr_t)(GC_threads), (ptr_t)(GC_threads)+sizeof(GC_threads));\n+}\n+\n /* Add a thread to GC_threads.  We assume it wasn't already there.\t*/\n /* Caller holds allocation lock.\t\t\t\t\t*/\n GC_thread GC_new_thread(pthread_t id)\n@@ -223,7 +225,7 @@ GC_thread GC_new_thread(pthread_t id)\n     \t/* Dont acquire allocation lock, since we may already hold it. */\n     } else {\n         result = (struct GC_Thread_Rep *)\n-        \t GC_generic_malloc_inner(sizeof(struct GC_Thread_Rep), NORMAL);\n+        \t GC_INTERNAL_MALLOC(sizeof(struct GC_Thread_Rep), NORMAL);\n     }\n     if (result == 0) return(0);\n     result -> id = id;\n@@ -503,10 +505,33 @@ int GC_pthread_join(pthread_t thread, void **retval)\n     /* Some versions of the Irix pthreads library can erroneously \t*/\n     /* return EINTR when the call succeeds.\t\t\t\t*/\n \tif (EINTR == result) result = 0;\n+    if (result == 0) {\n+        LOCK();\n+        /* Here the pthread thread id may have been recycled. */\n+        GC_delete_gc_thread(thread, thread_gc_id);\n+        UNLOCK();\n+    }\n+    return result;\n+}\n+\n+int GC_pthread_detach(pthread_t thread)\n+{\n+    int result;\n+    GC_thread thread_gc_id;\n+    \n     LOCK();\n-    /* Here the pthread thread id may have been recycled. */\n-    GC_delete_gc_thread(thread, thread_gc_id);\n+    thread_gc_id = GC_lookup_thread(thread);\n     UNLOCK();\n+    result = REAL_FUNC(pthread_detach)(thread);\n+    if (result == 0) {\n+      LOCK();\n+      thread_gc_id -> flags |= DETACHED;\n+      /* Here the pthread thread id may have been recycled. */\n+      if (thread_gc_id -> flags & FINISHED) {\n+        GC_delete_gc_thread(thread, thread_gc_id);\n+      }\n+      UNLOCK();\n+    }\n     return result;\n }\n \n@@ -552,39 +577,7 @@ void * GC_start_routine(void * arg)\n     return(result);\n }\n \n-# ifdef HPUX_THREADS\n-  /* pthread_attr_t is not a structure, thus a simple structure copy\t*/\n-  /* won't work.\t\t\t\t\t\t\t*/\n-  static void copy_attr(pthread_attr_t * pa_ptr,\n-\t\t\tconst pthread_attr_t  * source) {\n-    int tmp;\n-    size_t stmp;\n-    void * vtmp;\n-    struct sched_param sp_tmp;\n-    pthread_spu_t ps_tmp;\n-    (void) pthread_attr_init(pa_ptr);\n-    (void) pthread_attr_getdetachstate(source, &tmp);\n-    (void) pthread_attr_setdetachstate(pa_ptr, tmp);\n-    (void) pthread_attr_getinheritsched(source, &tmp);\n-    (void) pthread_attr_setinheritsched(pa_ptr, tmp);\n-    (void) pthread_attr_getschedpolicy(source, &tmp);\n-    (void) pthread_attr_setschedpolicy(pa_ptr, tmp);\n-    (void) pthread_attr_getstacksize(source, &stmp);\n-    (void) pthread_attr_setstacksize(pa_ptr, stmp);\n-    (void) pthread_attr_getguardsize(source, &stmp);\n-    (void) pthread_attr_setguardsize(pa_ptr, stmp);\n-    (void) pthread_attr_getstackaddr(source, &vtmp);\n-    (void) pthread_attr_setstackaddr(pa_ptr, vtmp);\n-    (void) pthread_attr_getscope(source, &tmp);\n-    (void) pthread_attr_setscope(pa_ptr, tmp);\n-    (void) pthread_attr_getschedparam(source, &sp_tmp);\n-    (void) pthread_attr_setschedparam(pa_ptr, &sp_tmp);\n-    (void) pthread_attr_getprocessor_np(source, &ps_tmp, &tmp);\n-    (void) pthread_attr_setprocessor_np(pa_ptr, ps_tmp, tmp);\n-  }\n-# else\n-#   define copy_attr(pa_ptr, source) *(pa_ptr) = *(source)\n-# endif\n+# define copy_attr(pa_ptr, source) *(pa_ptr) = *(source)\n \n int\n GC_pthread_create(pthread_t *new_thread,\n@@ -650,14 +643,12 @@ GC_pthread_create(pthread_t *new_thread,\n \t  }\n \t}\n         sem_destroy(&(si -> registered));\n-    pthread_attr_destroy(&new_attr);  /* Not a no-op under HPUX */\n+    pthread_attr_destroy(&new_attr);  /* Probably unnecessary under Irix */\n     return(result);\n }\n \n-#ifndef HPUX_THREADS\n-/* For now we use the pthreads locking primitives on HP/UX */\n-\n-GC_bool GC_collecting = 0; /* A hint that we're in the collector and       */\n+VOLATILE GC_bool GC_collecting = 0;\n+\t\t\t/* A hint that we're in the collector and       */\n                         /* holding the allocation lock for an           */\n                         /* extended period.                             */\n \n@@ -666,15 +657,9 @@ GC_bool GC_collecting = 0; /* A hint that we're in the collector and       */\n \n #define SLEEP_THRESHOLD 3\n \n-#ifdef HPUX\n-   unsigned long GC_allocate_lock = 1;\n-#  define GC_TRY_LOCK() GC_test_and_clear(&GC_allocate_lock)\n-#  define GC_LOCK_TAKEN !GC_allocate_lock\n-#else\n-   unsigned long GC_allocate_lock = 0;\n-#  define GC_TRY_LOCK() !GC_test_and_set(&GC_allocate_lock,1)\n-#  define GC_LOCK_TAKEN GC_allocate_lock\n-#endif\n+unsigned long GC_allocate_lock = 0;\n+# define GC_TRY_LOCK() !GC_test_and_set(&GC_allocate_lock,1)\n+# define GC_LOCK_TAKEN GC_allocate_lock\n \n void GC_lock()\n {\n@@ -734,8 +719,6 @@ void GC_lock()\n     }\n }\n \n-#endif /* !HPUX_THREADS */\n-\n # else\n \n #ifndef LINT", "previous_filename": "boehm-gc/hpux_irix_threads.c"}, {"sha": "37537bcef3e0d699fdf674ecf0ace1034b9bdb2b", "filename": "boehm-gc/linux_threads.c", "status": "modified", "additions": 955, "deletions": 93, "changes": 1048, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9110a741e35c54e46c00662ddc420575376c5947/boehm-gc%2Flinux_threads.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9110a741e35c54e46c00662ddc420575376c5947/boehm-gc%2Flinux_threads.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Flinux_threads.c?ref=9110a741e35c54e46c00662ddc420575376c5947", "patch": "@@ -2,6 +2,7 @@\n  * Copyright (c) 1994 by Xerox Corporation.  All rights reserved.\n  * Copyright (c) 1996 by Silicon Graphics.  All rights reserved.\n  * Copyright (c) 1998 by Fergus Henderson.  All rights reserved.\n+ * Copyright (c) 2000-2001 by Hewlett-Packard Company.  All rights reserved.\n  *\n  * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n  * OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n@@ -17,24 +18,61 @@\n  * thread package for Linux which is included in libc6.\n  *\n  * This code relies on implementation details of LinuxThreads,\n- * (i.e. properties not guaranteed by the Pthread standard):\n- *\n- *\t- the function GC_linux_thread_top_of_stack(void)\n- *\t  relies on the way LinuxThreads lays out thread stacks\n- *\t  in the address space.\n+ * (i.e. properties not guaranteed by the Pthread standard),\n+ * though this version now does less of that than the other Pthreads\n+ * support code.\n  *\n  * Note that there is a lot of code duplication between linux_threads.c\n- * and irix_threads.c; any changes made here may need to be reflected\n- * there too.\n+ * and thread support for some of the other Posix platforms; any changes\n+ * made here may need to be reflected there too.\n+ */\n+/*\n+ * Linux_threads.c now also includes some code to support HPUX and\n+ * OSF1 (Compaq Tru64 Unix, really).  The OSF1 support is not yet\n+ * functional.  The OSF1 code is based on Eric Benson's\n+ * patch, though that was originally against hpux_irix_threads.  The code\n+ * here is completely untested.  With 0.0000001% probability, it might\n+ * actually work.\n+ *\n+ * Eric also suggested an alternate basis for a lock implementation in\n+ * his code:\n+ * + #elif defined(OSF1)\n+ * +    unsigned long GC_allocate_lock = 0;\n+ * +    msemaphore GC_allocate_semaphore;\n+ * + #  define GC_TRY_LOCK() \\\n+ * +    ((msem_lock(&GC_allocate_semaphore, MSEM_IF_NOWAIT) == 0) \\\n+ * +     ? (GC_allocate_lock = 1) \\\n+ * +     : 0)\n+ * + #  define GC_LOCK_TAKEN GC_allocate_lock\n  */\n \n /* #define DEBUG_THREADS 1 */\n \n /* ANSI C requires that a compilation unit contains something */\n-# include \"gc_priv.h\"\n \n-# if defined(LINUX_THREADS)\n+# if defined(GC_LINUX_THREADS) || defined(LINUX_THREADS) \\\n+     || defined(GC_HPUX_THREADS) || defined(HPUX_THREADS) \\\n+     || defined(GC_OSF1_THREADS) || defined(OSF1_THREADS) \\\n \n+# include \"private/gc_priv.h\"\n+# ifdef THREAD_LOCAL_ALLOC\n+#   if !defined(USE_PTHREAD_SPECIFIC) && !defined(USE_HPUX_TLS)\n+#     include \"private/specific.h\"\n+#   endif\n+#   if defined(USE_PTHREAD_SPECIFIC)\n+#     define GC_getspecific pthread_getspecific\n+#     define GC_setspecific pthread_setspecific\n+#     define GC_key_create pthread_key_create\n+      typedef pthread_key_t GC_key_t;\n+#   endif\n+#   if defined(USE_HPUX_TLS)\n+#     define GC_getspecific(x) (x)\n+#     define GC_setspecific(key, v) ((key) = (v), 0)\n+#     define GC_key_create(key, d) 0\n+      typedef void * GC_key_t;\n+#   endif\n+# endif\n+# include <stdlib.h>\n # include <pthread.h>\n # include <sched.h>\n # include <time.h>\n@@ -44,8 +82,15 @@\n # include <sys/time.h>\n # include <semaphore.h>\n # include <signal.h>\n+# include <sys/types.h>\n+# include <sys/stat.h>\n+# include <fcntl.h>\n+\n+#ifndef __GNUC__\n+#   define __inline__\n+#endif\n \n-#ifdef USE_LD_WRAP\n+#ifdef GC_USE_LD_WRAP\n #   define WRAP_FUNC(f) __wrap_##f\n #   define REAL_FUNC(f) __real_##f\n #else\n@@ -54,6 +99,7 @@\n #   undef pthread_create\n #   undef pthread_sigmask\n #   undef pthread_join\n+#   undef pthread_detach\n #endif\n \n \n@@ -75,14 +121,13 @@ void GC_print_sig_mask()\n }\n #endif\n \n+\n /* We use the allocation lock to protect thread-related data structures. */\n \n /* The set of all known threads.  We intercept thread creation and \t*/\n-/* joins.  We never actually create detached threads.  We allocate all \t*/\n-/* new thread stacks ourselves.  These allow us to maintain this\t*/\n-/* data structure.\t\t\t\t\t\t\t*/\n-/* Protected by GC_thr_lock.\t\t\t\t\t\t*/\n-/* Some of this should be declared volatile, but that's incosnsistent\t*/\n+/* joins.\t\t\t\t\t\t\t\t*/\n+/* Protected by allocation/GC lock.\t\t\t\t\t*/\n+/* Some of this should be declared volatile, but that's inconsistent\t*/\n /* with some library routine declarations.  \t\t \t\t*/\n typedef struct GC_Thread_Rep {\n     struct GC_Thread_Rep * next;  /* More recently allocated threads\t*/\n@@ -91,11 +136,17 @@ typedef struct GC_Thread_Rep {\n \t\t\t\t  /* guaranteed to be dead, but we may  */\n \t\t\t\t  /* not yet have registered the join.) */\n     pthread_t id;\n-    word flags;\n+    short flags;\n #\tdefine FINISHED 1   \t/* Thread has exited.\t*/\n #\tdefine DETACHED 2\t/* Thread is intended to be detached.\t*/\n #\tdefine MAIN_THREAD 4\t/* True for the original thread only.\t*/\n-\n+    short thread_blocked;\t/* Protected by GC lock.\t\t*/\n+    \t\t\t\t/* Treated as a boolean value.  If set,\t*/\n+    \t\t\t\t/* thread will acquire GC lock before\t*/\n+    \t\t\t\t/* doing any pointer manipulations, and\t*/\n+    \t\t\t\t/* has set its sp value.  Thus it does\t*/\n+    \t\t\t\t/* not need to be sent a signal to stop\t*/\n+    \t\t\t\t/* it.\t\t\t\t\t*/\n     ptr_t stack_end;\t\t/* Cold end of the stack.\t\t*/\n     ptr_t stack_ptr;  \t\t/* Valid only when stopped.      \t*/\n #   ifdef IA64\n@@ -107,10 +158,262 @@ typedef struct GC_Thread_Rep {\n     \t\t\t\t/* Used only to avoid premature \t*/\n \t\t\t\t/* reclamation of any data it might \t*/\n \t\t\t\t/* reference.\t\t\t\t*/\n+#   ifdef THREAD_LOCAL_ALLOC\n+#\tif CPP_WORDSZ == 64 && defined(ALIGN_DOUBLE)\n+#\t    define GRANULARITY 16\n+#\t    define NFREELISTS 48\n+#\telse\n+#\t    define GRANULARITY 8\n+#\t    define NFREELISTS 64\n+#\tendif\n+\t/* The ith free list corresponds to size (i+1)*GRANULARITY */\n+#\tdefine INDEX_FROM_BYTES(n) (ADD_SLOP(n) - 1)/GRANULARITY\n+#\tdefine BYTES_FROM_INDEX(i) (((i) + 1) * GRANULARITY - EXTRA_BYTES)\n+#\tdefine SMALL_ENOUGH(bytes) (ADD_SLOP(bytes) <= NFREELISTS*GRANULARITY)\n+\tptr_t ptrfree_freelists[NFREELISTS];\n+\tptr_t normal_freelists[NFREELISTS];\n+#\tifdef GC_GCJ_SUPPORT\n+\t  ptr_t gcj_freelists[NFREELISTS];\n+#\tendif\n+\t\t/* Free lists contain either a pointer or a small count */\n+\t\t/* reflecting the number of granules allocated at that\t*/\n+\t\t/* size.\t\t\t\t\t\t*/\n+\t\t/* 0 ==> thread-local allocation in use, free list\t*/\n+\t\t/*       empty.\t\t\t\t\t\t*/\n+\t\t/* > 0, <= DIRECT_GRANULES ==> Using global allocation,\t*/\n+\t\t/*       too few objects of this size have been\t\t*/\n+\t\t/* \t allocated by this thread.\t\t\t*/\n+\t\t/* >= HBLKSIZE  => pointer to nonempty free list.\t*/\n+\t\t/* > DIRECT_GRANULES, < HBLKSIZE ==> transition to\t*/\n+\t\t/*    local alloc, equivalent to 0.\t\t\t*/\n+#\tdefine DIRECT_GRANULES (HBLKSIZE/GRANULARITY)\n+\t\t/* Don't use local free lists for up to this much \t*/\n+\t\t/* allocation.\t\t\t\t\t\t*/\n+#   endif\n } * GC_thread;\n \n GC_thread GC_lookup_thread(pthread_t id);\n \n+static GC_bool fully_initialized = FALSE;\n+\n+# if defined(__GNUC__)\n+    void GC_full_init() __attribute__ ((constructor));\n+# else\n+    void GC_full_init();\n+# endif\n+\n+# if defined(THREAD_LOCAL_ALLOC) && !defined(DBG_HDRS_ALL)\n+\n+/* We don't really support thread-local allocation with DBG_HDRS_ALL */\n+\n+#ifdef USE_HPUX_TLS\n+  __thread\n+#endif\n+GC_key_t GC_thread_key;\n+\n+static GC_bool keys_initialized;\n+\n+/* Recover the contents of the freelist array fl into the global one gfl.*/\n+/* Note that the indexing scheme differs, in that gfl has finer size\t*/\n+/* resolution, even if not all entries are used.\t\t\t*/\n+/* We hold the allocator lock.\t\t\t\t\t\t*/\n+static void return_freelists(ptr_t *fl, ptr_t *gfl)\n+{\n+    int i;\n+    ptr_t q, *qptr;\n+    size_t nwords;\n+\n+    for (i = 0; i < NFREELISTS; ++i) {\n+\tnwords = (i + 1) * (GRANULARITY/sizeof(word));\n+        qptr = fl + i;\t\n+\tq = *qptr;\n+\tif ((word)q < HBLKSIZE) continue;\n+\tif (gfl[nwords] == 0) {\n+\t    gfl[nwords] = q;\n+\t} else {\n+\t    /* Concatenate: */\n+\t    for (; (word)q >= HBLKSIZE; qptr = &(obj_link(q)), q = *qptr);\n+\t    GC_ASSERT(0 == q);\n+\t    *qptr = gfl[nwords];\n+\t    gfl[nwords] = fl[i];\n+\t}\n+\t/* Clear fl[i], since the thread structure may hang around.\t*/\n+\t/* Do it in a way that is likely to trap if we access it.\t*/\n+\tfl[i] = (ptr_t)HBLKSIZE;\n+    }\n+}\n+\n+/* Each thread structure must be initialized.\t*/\n+/* This call must be made from the new thread.\t*/\n+/* Caller holds allocation lock.\t\t*/\n+void GC_init_thread_local(GC_thread p)\n+{\n+    int i;\n+\n+    if (!keys_initialized) {\n+\tif (0 != GC_key_create(&GC_thread_key, 0)) {\n+\t    ABORT(\"Failed to create key for local allocator\");\n+        }\n+\tkeys_initialized = TRUE;\n+    }\n+    if (0 != GC_setspecific(GC_thread_key, p)) {\n+\tABORT(\"Failed to set thread specific allocation pointers\");\n+    }\n+    for (i = 0; i < NFREELISTS; ++i) {\n+\tp -> ptrfree_freelists[i] = (ptr_t)1;\n+\tp -> normal_freelists[i] = (ptr_t)1;\n+#\tifdef GC_GCJ_SUPPORT\n+\t  p -> gcj_freelists[i] = (ptr_t)1;\n+#\tendif\n+    }   \n+}\n+\n+#ifdef GC_GCJ_SUPPORT\n+  extern ptr_t * GC_gcjobjfreelist;\n+#endif\n+\n+/* We hold the allocator lock.\t*/\n+void GC_destroy_thread_local(GC_thread p)\n+{\n+    /* We currently only do this from the thread itself.\t*/\n+\tGC_ASSERT(GC_getspecific(GC_thread_key) == (void *)p);\n+    return_freelists(p -> ptrfree_freelists, GC_aobjfreelist);\n+    return_freelists(p -> normal_freelists, GC_objfreelist);\n+#   ifdef GC_GCJ_SUPPORT\n+   \treturn_freelists(p -> gcj_freelists, GC_gcjobjfreelist);\n+#   endif\n+}\n+\n+extern GC_PTR GC_generic_malloc_many();\n+\n+GC_PTR GC_local_malloc(size_t bytes)\n+{\n+    if (EXPECT(!SMALL_ENOUGH(bytes),0)) {\n+        return(GC_malloc(bytes));\n+    } else {\n+\tint index = INDEX_FROM_BYTES(bytes);\n+\tptr_t * my_fl;\n+\tptr_t my_entry;\n+\tGC_key_t k = GC_thread_key;\n+\tvoid * tsd;\n+\n+#\tif defined(REDIRECT_MALLOC) && !defined(USE_PTHREAD_SPECIFIC) \\\n+\t   || !defined(__GNUC__)\n+\t    if (EXPECT(0 == k, 0)) {\n+\t\t/* This can happen if we get called when the world is\t*/\n+\t\t/* being initialized.  Whether we can actually complete\t*/\n+\t\t/* the initialization then is unclear.\t\t\t*/\n+\t\tGC_full_init();\n+\t\tk = GC_thread_key;\n+\t    }\n+#\tendif\n+\ttsd = GC_getspecific(GC_thread_key);\n+#\tifdef GC_ASSERTIONS\n+\t  LOCK();\n+\t  GC_ASSERT(tsd == (void *)GC_lookup_thread(pthread_self()));\n+\t  UNLOCK();\n+#\tendif\n+\tmy_fl = ((GC_thread)tsd) -> normal_freelists + index;\n+\tmy_entry = *my_fl;\n+\tif (EXPECT((word)my_entry >= HBLKSIZE, 1)) {\n+\t    ptr_t next = obj_link(my_entry);\n+\t    GC_PTR result = (GC_PTR)my_entry;\n+\t    *my_fl = next;\n+\t    obj_link(my_entry) = 0;\n+\t    PREFETCH_FOR_WRITE(next);\n+\t    return result;\n+\t} else if ((word)my_entry - 1 < DIRECT_GRANULES) {\n+\t    *my_fl = my_entry + index + 1;\n+            return GC_malloc(bytes);\n+\t} else {\n+\t    my_entry = GC_generic_malloc_many(BYTES_FROM_INDEX(index),\n+\t\t\t\t\t      NORMAL);\n+\t    *my_fl = my_entry;\n+\t    if (my_entry == 0) return GC_oom_fn(bytes);\n+\t    return GC_local_malloc(bytes);\n+\t}\n+    }\n+}\n+\n+GC_PTR GC_local_malloc_atomic(size_t bytes)\n+{\n+    if (EXPECT(!SMALL_ENOUGH(bytes), 0)) {\n+        return(GC_malloc_atomic(bytes));\n+    } else {\n+\tint index = INDEX_FROM_BYTES(bytes);\n+\tptr_t * my_fl = ((GC_thread)GC_getspecific(GC_thread_key))\n+\t\t        -> ptrfree_freelists + index;\n+\tptr_t my_entry = *my_fl;\n+\tif (EXPECT((word)my_entry >= HBLKSIZE, 1)) {\n+\t    GC_PTR result = (GC_PTR)my_entry;\n+\t    *my_fl = obj_link(my_entry);\n+\t    return result;\n+\t} else if ((word)my_entry - 1 < DIRECT_GRANULES) {\n+\t    *my_fl = my_entry + index + 1;\n+            return GC_malloc_atomic(bytes);\n+\t} else {\n+\t    my_entry = GC_generic_malloc_many(BYTES_FROM_INDEX(index),\n+\t\t\t\t\t      PTRFREE);\n+\t    *my_fl = my_entry;\n+\t    if (my_entry == 0) return GC_oom_fn(bytes);\n+\t    return GC_local_malloc_atomic(bytes);\n+\t}\n+    }\n+}\n+\n+#ifdef GC_GCJ_SUPPORT\n+\n+#include \"include/gc_gcj.h\"\n+\n+#ifdef GC_ASSERTIONS\n+  extern GC_bool GC_gcj_malloc_initialized;\n+#endif\n+\n+extern int GC_gcj_kind;\n+\n+GC_PTR GC_local_gcj_malloc(size_t bytes,\n+\t\t\t   void * ptr_to_struct_containing_descr)\n+{\n+    GC_ASSERT(GC_gcj_malloc_initialized);\n+    if (EXPECT(!SMALL_ENOUGH(bytes), 0)) {\n+        return GC_gcj_malloc(bytes, ptr_to_struct_containing_descr);\n+    } else {\n+\tint index = INDEX_FROM_BYTES(bytes);\n+\tptr_t * my_fl = ((GC_thread)GC_getspecific(GC_thread_key))\n+\t                -> gcj_freelists + index;\n+\tptr_t my_entry = *my_fl;\n+\tif (EXPECT((word)my_entry >= HBLKSIZE, 1)) {\n+\t    GC_PTR result = (GC_PTR)my_entry;\n+\t    GC_ASSERT(!GC_incremental);\n+\t    /* We assert that any concurrent marker will stop us.\t*/\n+\t    /* Thus it is impossible for a mark procedure to see the \t*/\n+\t    /* allocation of the next object, but to see this object \t*/\n+\t    /* still containing a free list pointer.  Otherwise the \t*/\n+\t    /* marker might find a random \"mark descriptor\".\t\t*/\n+\t    *my_fl = obj_link(my_entry);\n+\t    *(void **)result = ptr_to_struct_containing_descr; \n+\t    return result;\n+\t} else if ((word)my_entry - 1 < DIRECT_GRANULES) {\n+\t    *my_fl = my_entry + index + 1;\n+            return GC_gcj_malloc(bytes, ptr_to_struct_containing_descr);\n+\t} else {\n+\t    my_entry = GC_generic_malloc_many(BYTES_FROM_INDEX(index),\n+\t\t\t\t\t      GC_gcj_kind);\n+\t    *my_fl = my_entry;\n+\t    if (my_entry == 0) return GC_oom_fn(bytes);\n+\t    return GC_gcj_malloc(bytes, ptr_to_struct_containing_descr);\n+\t}\n+    }\n+}\n+\n+#endif /* GC_GCJ_SUPPORT */\n+\n+# else  /* !THREAD_LOCAL_ALLOC  && !DBG_HDRS_ALL */\n+\n+#   define GC_destroy_thread_local(t)\n+\n+# endif /* !THREAD_LOCAL_ALLOC */\n+\n /*\n  * The only way to suspend threads given the pthread interface is to send\n  * signals.  We can't use SIGSTOP directly, because we need to get the\n@@ -121,40 +424,122 @@ GC_thread GC_lookup_thread(pthread_t id);\n  * so we need to reuse something else.  I chose SIGPWR.\n  * (Perhaps SIGUNUSED would be a better choice.)\n  */\n-#define SIG_SUSPEND SIGPWR\n+#ifndef SIG_SUSPEND\n+#  if defined(HPUX_THREADS) || defined(GC_OSF1_THREADS)\n+#   define SIG_SUSPEND _SIGRTMIN + 6\n+#  else\n+#   define SIG_SUSPEND SIGPWR\n+#  endif\n+#endif\n \n-#define SIG_RESTART SIGXCPU\n+#ifndef SIG_THR_RESTART\n+#  if defined(HPUX_THREADS) || defined(GC_OSF1_THREADS)\n+#   define SIG_THR_RESTART _SIGRTMIN + 5\n+#  else\n+#   define SIG_THR_RESTART SIGXCPU\n+#  endif\n+#endif\n+\n+/* SPARC/Linux doesn't properly define SIGPWR in <signal.h>.\n+ * It is aliased to SIGLOST in asm/signal.h, though.\t\t*/\n+#if defined(SPARC) && !defined(SIGPWR)\n+#   define SIGPWR SIGLOST\n+#endif\n \n sem_t GC_suspend_ack_sem;\n \n+#if !defined(HPUX_THREADS) && !defined(GC_OSF1_THREADS)\n /*\n-GC_linux_thread_top_of_stack() relies on implementation details of\n-LinuxThreads, namely that thread stacks are allocated on 2M boundaries\n-and grow to no more than 2M.\n To make sure that we're using LinuxThreads and not some other thread\n package, we generate a dummy reference to `pthread_kill_other_threads_np'\n (was `__pthread_initial_thread_bos' but that disappeared),\n which is a symbol defined in LinuxThreads, but (hopefully) not in other\n thread packages.\n */\n void (*dummy_var_to_force_linux_threads)() = pthread_kill_other_threads_np;\n+#endif /* !HPUX_THREADS */\n+\n+#if defined(SPARC) || defined(IA64)\n+  extern word GC_save_regs_in_stack();\n+#endif\n \n-#define LINUX_THREADS_STACK_SIZE  (2 * 1024 * 1024)\n+long GC_nprocs = 1;\t/* Number of processors.  We may not have\t*/\n+\t\t\t/* access to all of them, but this is as good\t*/\n+\t\t\t/* a guess as any ...\t\t\t\t*/\n \n-static inline ptr_t GC_linux_thread_top_of_stack(void)\n+#ifdef PARALLEL_MARK\n+\n+# ifndef MAX_MARKERS\n+#   define MAX_MARKERS 16\n+# endif\n+\n+static ptr_t marker_sp[MAX_MARKERS] = {0};\n+\n+void * GC_mark_thread(void * id)\n {\n-  char *sp = GC_approx_sp();\n-  ptr_t tos = (ptr_t) (((unsigned long)sp | (LINUX_THREADS_STACK_SIZE - 1)) + 1);\n-#if DEBUG_THREADS\n-  GC_printf1(\"SP = %lx\\n\", (unsigned long)sp);\n-  GC_printf1(\"TOS = %lx\\n\", (unsigned long)tos);\n-#endif\n-  return tos;\n+  word my_mark_no = 0;\n+\n+  marker_sp[(word)id] = GC_approx_sp();\n+  for (;; ++my_mark_no) {\n+    /* GC_mark_no is passed only to allow GC_help_marker to terminate\t*/\n+    /* promptly.  This is important if it were called from the signal\t*/\n+    /* handler or from the GC lock acquisition code.  Under Linux, it's\t*/\n+    /* not safe to call it from a signal handler, since it uses mutexes\t*/\n+    /* and condition variables.  Since it is called only here, the \t*/\n+    /* argument is unnecessary.\t\t\t\t\t\t*/\n+    if (my_mark_no < GC_mark_no || my_mark_no > GC_mark_no + 2) {\n+\t/* resynchronize if we get far off, e.g. because GC_mark_no\t*/\n+\t/* wrapped.\t\t\t\t\t\t\t*/\n+\tmy_mark_no = GC_mark_no;\n+    }\n+#   ifdef DEBUG_THREADS\n+\tGC_printf1(\"Starting mark helper for mark number %ld\\n\", my_mark_no);\n+#   endif\n+    GC_help_marker(my_mark_no);\n+  }\n }\n \n-#if defined(SPARC) || defined(IA64)\n-  extern word GC_save_regs_in_stack();\n-#endif\n+extern long GC_markers;\t\t/* Number of mark threads we would\t*/\n+\t\t\t\t/* like to have.  Includes the \t\t*/\n+\t\t\t\t/* initiating thread.\t\t\t*/\n+\n+pthread_t GC_mark_threads[MAX_MARKERS];\n+\n+#define PTHREAD_CREATE REAL_FUNC(pthread_create)\n+\n+static void start_mark_threads()\n+{\n+    unsigned i;\n+    pthread_attr_t attr;\n+\n+    if (GC_markers > MAX_MARKERS) {\n+\tWARN(\"Limiting number of mark threads\\n\", 0);\n+\tGC_markers = MAX_MARKERS;\n+    }\n+    if (0 != pthread_attr_init(&attr)) ABORT(\"pthread_attr_init failed\");\n+\t\n+    if (0 != pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED))\n+\tABORT(\"pthread_attr_setdetachstate failed\");\n+#   ifdef CONDPRINT\n+      if (GC_print_stats) {\n+\tGC_printf1(\"Starting %ld marker threads\\n\", GC_markers - 1);\n+      }\n+#   endif\n+    for (i = 0; i < GC_markers - 1; ++i) {\n+      if (0 != PTHREAD_CREATE(GC_mark_threads + i, &attr,\n+\t\t\t      GC_mark_thread, (void *)(word)i)) {\n+\tWARN(\"Marker thread creation failed, errno = %ld.\\n\", errno);\n+      }\n+    }\n+}\n+\n+#else  /* !PARALLEL_MARK */\n+\n+static __inline__ void start_mark_threads()\n+{\n+}\n+\n+#endif /* !PARALLEL_MARK */\n \n void GC_suspend_handler(int sig)\n {\n@@ -165,6 +550,12 @@ void GC_suspend_handler(int sig)\n     sigset_t old_sigs;\n     int i;\n     sigset_t mask;\n+#   ifdef PARALLEL_MARK\n+\tword my_mark_no = GC_mark_no;\n+\t/* Marker can't proceed until we acknowledge.  Thus this is\t*/\n+\t/* guaranteed to be the mark_no correspending to our \t\t*/\n+\t/* suspension, i.e. the marker can't have incremented it yet.\t*/\n+#   endif\n \n     if (sig != SIG_SUSPEND) ABORT(\"Bad signal in suspend_handler\");\n \n@@ -192,11 +583,11 @@ void GC_suspend_handler(int sig)\n     sem_post(&GC_suspend_ack_sem);\n \n     /* Wait until that thread tells us to restart by sending    */\n-    /* this thread a SIG_RESTART signal.\t\t\t*/\n-    /* SIG_RESTART should be masked at this point.  Thus there\t*/\n+    /* this thread a SIG_THR_RESTART signal.\t\t\t*/\n+    /* SIG_THR_RESTART should be masked at this point.  Thus there\t*/\n     /* is no race.\t\t\t\t\t\t*/\n     if (sigfillset(&mask) != 0) ABORT(\"sigfillset() failed\");\n-    if (sigdelset(&mask, SIG_RESTART) != 0) ABORT(\"sigdelset() failed\");\n+    if (sigdelset(&mask, SIG_THR_RESTART) != 0) ABORT(\"sigdelset() failed\");\n #   ifdef NO_SIGNALS\n       if (sigdelset(&mask, SIGINT) != 0) ABORT(\"sigdelset() failed\");\n       if (sigdelset(&mask, SIGQUIT) != 0) ABORT(\"sigdelset() failed\");\n@@ -206,7 +597,7 @@ void GC_suspend_handler(int sig)\n     do {\n \t    me->signal = 0;\n \t    sigsuspend(&mask);             /* Wait for signal */\n-    } while (me->signal != SIG_RESTART);\n+    } while (me->signal != SIG_THR_RESTART);\n \n #if DEBUG_THREADS\n     GC_printf1(\"Continuing 0x%x\\n\", my_thread);\n@@ -217,15 +608,15 @@ void GC_restart_handler(int sig)\n {\n     GC_thread me;\n \n-    if (sig != SIG_RESTART) ABORT(\"Bad signal in suspend_handler\");\n+    if (sig != SIG_THR_RESTART) ABORT(\"Bad signal in suspend_handler\");\n \n-    /* Let the GC_suspend_handler() know that we got a SIG_RESTART. */\n+    /* Let the GC_suspend_handler() know that we got a SIG_THR_RESTART. */\n     /* The lookup here is safe, since I'm doing this on behalf  */\n     /* of a thread which holds the allocation lock in order\t*/\n     /* to stop the world.  Thus concurrent modification of the\t*/\n     /* data structure is impossible.\t\t\t\t*/\n     me = GC_lookup_thread(pthread_self());\n-    me->signal = SIG_RESTART;\n+    me->signal = SIG_THR_RESTART;\n \n     /*\n     ** Note: even if we didn't do anything useful here,\n@@ -240,11 +631,29 @@ void GC_restart_handler(int sig)\n #endif\n }\n \n+/* Defining INSTALL_LOOPING_SEGV_HANDLER causes SIGSEGV and SIGBUS to \t*/\n+/* result in an infinite loop in a signal handler.  This can be very\t*/\n+/* useful for debugging, since (as of RH7) gdb still seems to have\t*/\n+/* serious problems with threads.\t\t\t\t\t*/\n+#ifdef INSTALL_LOOPING_SEGV_HANDLER\n+void GC_looping_handler(int sig)\n+{\n+    GC_printf3(\"Signal %ld in thread %lx, pid %ld\\n\",\n+\t       sig, pthread_self(), getpid());\n+    for (;;);\n+}\n+#endif\n+\n GC_bool GC_thr_initialized = FALSE;\n \n # define THREAD_TABLE_SZ 128\t/* Must be power of 2\t*/\n volatile GC_thread GC_threads[THREAD_TABLE_SZ];\n \n+void GC_push_thread_structures GC_PROTO((void))\n+{\n+    GC_push_all((ptr_t)(GC_threads), (ptr_t)(GC_threads)+sizeof(GC_threads));\n+}\n+\n /* Add a thread to GC_threads.  We assume it wasn't already there.\t*/\n /* Caller holds allocation lock.\t\t\t\t\t*/\n GC_thread GC_new_thread(pthread_t id)\n@@ -257,16 +666,15 @@ GC_thread GC_new_thread(pthread_t id)\n     if (!first_thread_used) {\n     \tresult = &first_thread;\n     \tfirst_thread_used = TRUE;\n-    \t/* Dont acquire allocation lock, since we may already hold it. */\n     } else {\n         result = (struct GC_Thread_Rep *)\n-        \t GC_generic_malloc_inner(sizeof(struct GC_Thread_Rep), NORMAL);\n+        \t GC_INTERNAL_MALLOC(sizeof(struct GC_Thread_Rep), NORMAL);\n     }\n     if (result == 0) return(0);\n     result -> id = id;\n     result -> next = GC_threads[hv];\n     GC_threads[hv] = result;\n-    /* result -> flags = 0; */\n+    GC_ASSERT(result -> flags == 0 && result -> thread_blocked == 0);\n     return(result);\n }\n \n@@ -288,6 +696,7 @@ void GC_delete_thread(pthread_t id)\n     } else {\n         prev -> next = p -> next;\n     }\n+    GC_INTERNAL_FREE(p);\n }\n \n /* If a thread has been joined, but we have not yet\t\t*/\n@@ -309,6 +718,7 @@ void GC_delete_gc_thread(pthread_t id, GC_thread gc_id)\n     } else {\n         prev -> next = p -> next;\n     }\n+    GC_INTERNAL_FREE(p);\n }\n \n /* Return a GC_thread corresponding to a given thread_t.\t*/\n@@ -326,8 +736,8 @@ GC_thread GC_lookup_thread(pthread_t id)\n     return(p);\n }\n \n-/* There seems to be a very rare thread stopping problem.  To help us \t*/\n-/* debug that, we save the ids of the stopping thread. \t\t\t*/\n+/* There seems to be a very rare thread stopping problem.  To help us  */\n+/* debug that, we save the ids of the stopping thread. */\n pthread_t GC_stopping_thread;\n int GC_stopping_pid;\n \n@@ -340,12 +750,23 @@ void GC_stop_world()\n     register int n_live_threads = 0;\n     register int result;\n \n-    GC_stopping_thread = my_thread;\t/* debugging only.\t*/\n-    GC_stopping_pid = getpid();\t\t/* debugging only.\t*/\n+    GC_stopping_thread = my_thread;    /* debugging only.      */\n+    GC_stopping_pid = getpid();                /* debugging only.      */\n+\n+    /* Make sure all free list construction has stopped before we start. */\n+    /* No new construction can start, since free list construction is\t*/\n+    /* required to acquire and release the GC lock before it starts,\t*/\n+    /* and we have the lock.\t\t\t\t\t\t*/\n+#   ifdef PARALLEL_MARK\n+      GC_acquire_mark_lock();\n+      GC_ASSERT(GC_fl_builder_count == 0);\n+      /* We should have previously waited for it to become zero. */\n+#   endif /* PARALLEL_MARK */\n     for (i = 0; i < THREAD_TABLE_SZ; i++) {\n       for (p = GC_threads[i]; p != 0; p = p -> next) {\n         if (p -> id != my_thread) {\n             if (p -> flags & FINISHED) continue;\n+\t    if (p -> thread_blocked) /* Will wait */ continue;\n             n_live_threads++;\n \t    #if DEBUG_THREADS\n \t      GC_printf1(\"Sending suspend signal to 0x%x\\n\", p -> id);\n@@ -365,14 +786,19 @@ void GC_stop_world()\n       }\n     }\n     for (i = 0; i < n_live_threads; i++) {\n-    \tsem_wait(&GC_suspend_ack_sem);\n+    \tif (0 != sem_wait(&GC_suspend_ack_sem))\n+\t    ABORT(\"sem_wait in handler failed\");\n     }\n+#   ifdef PARALLEL_MARK\n+      GC_release_mark_lock();\n+#   endif\n     #if DEBUG_THREADS\n-    GC_printf1(\"World stopped 0x%x\\n\", pthread_self());\n+      GC_printf1(\"World stopped 0x%x\\n\", pthread_self());\n     #endif\n }\n \n-/* Caller holds allocation lock.\t*/\n+/* Caller holds allocation lock, and has held it continuously since\t*/\n+/* the world stopped.\t\t\t\t\t\t\t*/\n void GC_start_world()\n {\n     pthread_t my_thread = pthread_self();\n@@ -389,11 +815,12 @@ void GC_start_world()\n       for (p = GC_threads[i]; p != 0; p = p -> next) {\n         if (p -> id != my_thread) {\n             if (p -> flags & FINISHED) continue;\n+\t    if (p -> thread_blocked) continue;\n             n_live_threads++;\n \t    #if DEBUG_THREADS\n \t      GC_printf1(\"Sending restart signal to 0x%x\\n\", p -> id);\n \t    #endif\n-            result = pthread_kill(p -> id, SIG_RESTART);\n+            result = pthread_kill(p -> id, SIG_THR_RESTART);\n \t    switch(result) {\n                 case ESRCH:\n                     /* Not really there anymore.  Possible? */\n@@ -438,11 +865,11 @@ void GC_push_all_stacks()\n       for (p = GC_threads[i]; p != 0; p = p -> next) {\n         if (p -> flags & FINISHED) continue;\n         if (pthread_equal(p -> id, me)) {\n-#  ifdef SPARC\n-\t    lo = (ptr_t)GC_save_regs_in_stack();\n-#  else\n-\t    lo = GC_approx_sp();\n-#  endif\n+#  \t    ifdef SPARC\n+\t        lo = (ptr_t)GC_save_regs_in_stack();\n+#  \t    else\n+ \t        lo = GC_approx_sp();\n+#           endif\n \t    IF_IA64(bs_hi = (ptr_t)GC_save_regs_in_stack();)\n \t} else {\n \t    lo = p -> stack_ptr;\n@@ -462,7 +889,12 @@ void GC_push_all_stacks()\n \t\t(unsigned long) lo, (unsigned long) hi);\n         #endif\n \tif (0 == lo) ABORT(\"GC_push_all_stacks: sp not set!\\n\");\n-        GC_push_all_stack(lo, hi);\n+#       ifdef STACK_GROWS_UP\n+\t  /* We got them backwards! */\n+          GC_push_all_stack(hi, lo);\n+#       else\n+          GC_push_all_stack(lo, hi);\n+#\tendif\n #\tifdef IA64\n           if (pthread_equal(p -> id, me)) {\n \t    GC_push_all_eager(bs_lo, bs_hi);\n@@ -474,6 +906,69 @@ void GC_push_all_stacks()\n     }\n }\n \n+#ifdef USE_PROC_FOR_LIBRARIES\n+int GC_segment_is_thread_stack(ptr_t lo, ptr_t hi)\n+{\n+    int i;\n+    GC_thread p;\n+    \n+#   ifdef PARALLEL_MARK\n+      for (i = 0; i < GC_markers; ++i) {\n+\tif (marker_sp[i] > lo & marker_sp[i] < hi) return 1;\n+      }\n+#   endif\n+    for (i = 0; i < THREAD_TABLE_SZ; i++) {\n+      for (p = GC_threads[i]; p != 0; p = p -> next) {\n+\tif (0 != p -> stack_end) {\n+#\t  ifdef STACK_GROWS_UP\n+            if (p -> stack_end >= lo && p -> stack_end < hi) return 1;\n+#\t  else /* STACK_GROWS_DOWN */\n+            if (p -> stack_end > lo && p -> stack_end <= hi) return 1;\n+#\t  endif\n+\t}\n+      }\n+    }\n+    return 0;\n+}\n+#endif /* USE_PROC_FOR_LIBRARIES */\n+\n+#ifdef LINUX_THREADS\n+/* Return the number of processors, or i<= 0 if it can't be determined.\t*/\n+int GC_get_nprocs()\n+{\n+    /* Should be \"return sysconf(_SC_NPROCESSORS_ONLN);\" but that\t*/\n+    /* appears to be buggy in many cases.\t\t\t\t*/\n+    /* We look for lines \"cpu<n>\" in /proc/stat.\t\t\t*/\n+#   define STAT_BUF_SIZE 4096\n+#   if defined(GC_USE_LD_WRAP)\n+#\tdefine STAT_READ __real_read\n+#   else\n+#\tdefine STAT_READ read\n+#   endif    \n+    char stat_buf[STAT_BUF_SIZE];\n+    int f;\n+    char c;\n+    word result = 1;\n+\t/* Some old kernels only have a single \"cpu nnnn ...\"\t*/\n+\t/* entry in /proc/stat.  We identify those as \t\t*/\n+\t/* uniprocessors.\t\t\t\t\t*/\n+    size_t i, len = 0;\n+\n+    f = open(\"/proc/stat\", O_RDONLY);\n+    if (f < 0 || (len = STAT_READ(f, stat_buf, STAT_BUF_SIZE)) < 100) {\n+\tWARN(\"Couldn't read /proc/stat\\n\", 0);\n+\treturn -1;\n+    }\n+    for (i = 0; i < len - 100; ++i) {\n+        if (stat_buf[i] == '\\n' && stat_buf[i+1] == 'c'\n+\t    && stat_buf[i+2] == 'p' && stat_buf[i+3] == 'u') {\n+\t    int cpu_no = atoi(stat_buf + i + 4);\n+\t    if (cpu_no >= result) result = cpu_no + 1;\n+\t}\n+    }\n+    return result;\n+}\n+#endif /* LINUX_THREADS */\n \n /* We hold the allocation lock.\t*/\n void GC_thr_init()\n@@ -492,33 +987,109 @@ void GC_thr_init()\n     if (sigfillset(&act.sa_mask) != 0) {\n     \tABORT(\"sigfillset() failed\");\n     }\n-\n #   ifdef NO_SIGNALS\n       if (sigdelset(&act.sa_mask, SIGINT) != 0\n \t  || sigdelset(&act.sa_mask, SIGQUIT != 0)\n-\t  || sigdelset(&act.sa_mask, SIGTERM != 0)\n-\t  || sigdelset(&act.sa_mask, SIGABRT != 0)) {\n+\t  || sigdelset(&act.sa_mask, SIGABRT != 0)\n+\t  || sigdelset(&act.sa_mask, SIGTERM != 0)) {\n         ABORT(\"sigdelset() failed\");\n       }\n #   endif\n \n-    /* SIG_RESTART is unmasked by the handler when necessary. \t*/\n+    /* SIG_THR_RESTART is unmasked by the handler when necessary. \t*/\n     act.sa_handler = GC_suspend_handler;\n     if (sigaction(SIG_SUSPEND, &act, NULL) != 0) {\n     \tABORT(\"Cannot set SIG_SUSPEND handler\");\n     }\n \n     act.sa_handler = GC_restart_handler;\n-    if (sigaction(SIG_RESTART, &act, NULL) != 0) {\n-    \tABORT(\"Cannot set SIG_SUSPEND handler\");\n+    if (sigaction(SIG_THR_RESTART, &act, NULL) != 0) {\n+    \tABORT(\"Cannot set SIG_THR_RESTART handler\");\n     }\n+#   ifdef INSTALL_LOOPING_SEGV_HANDLER\n+        act.sa_handler = GC_looping_handler;\n+\tif (sigaction(SIGSEGV, &act, NULL) != 0\n+\t    || sigaction(SIGBUS, &act, NULL) != 0) {\n+\t    ABORT(\"Cannot set SIGSEGV or SIGBUS looping handler\");\n+\t}\n+#   endif  /* INSTALL_LOOPING_SEGV_HANDLER */\n \n     /* Add the initial thread, so we can stop it.\t*/\n       t = GC_new_thread(pthread_self());\n       t -> stack_ptr = (ptr_t)(&dummy);\n       t -> flags = DETACHED | MAIN_THREAD;\n+\n+    /* Set GC_nprocs.  */\n+      {\n+\tchar * nprocs_string = GETENV(\"GC_NPROCS\");\n+\tGC_nprocs = -1;\n+\tif (nprocs_string != NULL) GC_nprocs = atoi(nprocs_string);\n+      }\n+      if (GC_nprocs <= 0) {\n+#       if defined(HPUX_THREADS)\n+\t  GC_nprocs = pthread_num_processors_np();\n+#       endif\n+#       if defined(OSF1_THREADS)\n+          GC_nprocs = 1;\n+#       endif\n+#\tifdef LINUX_THREADS\n+          GC_nprocs = GC_get_nprocs();\n+#\tendif\n+      }\n+      if (GC_nprocs <= 0) {\n+\tWARN(\"GC_get_nprocs() returned %ld\\n\", GC_nprocs);\n+\tGC_nprocs = 2;\n+#\tifdef PARALLEL_MARK\n+\t  GC_markers = 1;\n+#\tendif\n+      } else {\n+#\tifdef PARALLEL_MARK\n+\t  GC_markers = GC_nprocs;\n+#\tendif\n+      }\n+#   ifdef PARALLEL_MARK\n+#     ifdef CONDPRINT\n+        if (GC_print_stats) {\n+          GC_printf2(\"Number of processors = %ld, \"\n+\t\t \"number of marker threads = %ld\\n\", GC_nprocs, GC_markers);\n+\t}\n+#     endif\n+      if (GC_markers == 1) {\n+\tGC_parallel = FALSE;\n+#\tifdef CONDPRINT\n+\t  if (GC_print_stats) {\n+\t    GC_printf0(\"Single marker thread, turning off parallel marking\\n\");\n+\t  }\n+#\tendif\n+      } else {\n+\tGC_parallel = TRUE;\n+      }\n+#   endif\n+}\n+\n+\n+/* Perform all initializations, including those that\t*/\n+/* may require allocation.\t\t\t\t*/\n+/* Called as constructor without allocation lock.\t*/\n+/* Must be called before a second thread is created.\t*/\n+void GC_full_init()\n+{\n+    if (fully_initialized) return;\n+    if (!GC_is_initialized) GC_init();\n+    /* If we are using a parallel marker, start the helper threads.  */\n+#     ifdef PARALLEL_MARK\n+        if (GC_parallel) start_mark_threads();\n+#     endif\n+    /* Initialize thread local free lists if used.\t*/\n+#   if defined(THREAD_LOCAL_ALLOC) && !defined(DBG_HDRS_ALL)\n+      LOCK();\n+      GC_init_thread_local(GC_lookup_thread(pthread_self()));\n+      UNLOCK();\n+#   endif\n+    fully_initialized = TRUE;\n }\n \n+\n int WRAP_FUNC(pthread_sigmask)(int how, const sigset_t *set, sigset_t *oset)\n {\n     sigset_t fudged_set;\n@@ -531,6 +1102,56 @@ int WRAP_FUNC(pthread_sigmask)(int how, const sigset_t *set, sigset_t *oset)\n     return(REAL_FUNC(pthread_sigmask)(how, set, oset));\n }\n \n+/* Wrappers for functions that are likely to block for an appreciable\t*/\n+/* length of time.  Must be called in pairs, if at all.\t\t\t*/\n+/* Nothing much beyond the system call itself should be executed\t*/\n+/* between these.\t\t\t\t\t\t\t*/\n+\n+void GC_start_blocking(void) {\n+#   define SP_SLOP 128\n+    GC_thread me;\n+    LOCK();\n+    me = GC_lookup_thread(pthread_self());\n+    GC_ASSERT(!(me -> thread_blocked));\n+#   ifdef SPARC\n+\tme -> stack_ptr = (ptr_t)GC_save_regs_in_stack();\n+#   else\n+\tme -> stack_ptr = (ptr_t)GC_approx_sp();\n+#   endif\n+#   ifdef IA64\n+\tme -> backing_store_ptr = (ptr_t)GC_save_regs_in_stack() + SP_SLOP;\n+#   endif\n+    /* Add some slop to the stack pointer, since the wrapped call may \t*/\n+    /* end up pushing more callee-save registers.\t\t\t*/\n+#   ifdef STACK_GROWS_UP\n+\tme -> stack_ptr += SP_SLOP;\n+#   else\n+\tme -> stack_ptr -= SP_SLOP;\n+#   endif\n+    me -> thread_blocked = TRUE;\n+    UNLOCK();\n+}\n+\n+GC_end_blocking(void) {\n+    GC_thread me;\n+    LOCK();   /* This will block if the world is stopped.\t*/\n+    me = GC_lookup_thread(pthread_self());\n+    GC_ASSERT(me -> thread_blocked);\n+    me -> thread_blocked = FALSE;\n+    UNLOCK();\n+}\n+    \n+/* A wrapper for the standard C sleep function\t*/\n+int WRAP_FUNC(sleep) (unsigned int seconds)\n+{\n+    int result;\n+\n+    GC_start_blocking();\n+    result = REAL_FUNC(sleep)(seconds);\n+    GC_end_blocking();\n+    return result;\n+}\n+\n struct start_info {\n     void *(*start_routine)(void *);\n     void *arg;\n@@ -539,19 +1160,27 @@ struct start_info {\n \t\t\t\t/* parent hasn't yet noticed.\t\t*/\n };\n \n-\n+/* Called at thread exit.\t\t\t\t*/\n+/* Never called for main thread.  That's OK, since it\t*/\n+/* results in at most a tiny one-time leak.  And \t*/\n+/* linuxthreads doesn't reclaim the main threads \t*/\n+/* resources or id anyway.\t\t\t\t*/\n void GC_thread_exit_proc(void *arg)\n {\n     GC_thread me;\n-    struct start_info * si = arg;\n \n     LOCK();\n     me = GC_lookup_thread(pthread_self());\n+    GC_destroy_thread_local(me);\n     if (me -> flags & DETACHED) {\n     \tGC_delete_thread(pthread_self());\n     } else {\n \tme -> flags |= FINISHED;\n     }\n+#   if defined(THREAD_LOCAL_ALLOC) && !defined(USE_PTHREAD_SPECIFIC) \\\n+       && !defined(USE_HPUX_TLS) && !defined(DBG_HDRS_ALL)\n+      GC_remove_specific(GC_thread_key);\n+#   endif\n     if (GC_incremental && GC_collection_in_progress()) {\n \tint old_gc_no = GC_gc_no;\n \n@@ -581,10 +1210,34 @@ int WRAP_FUNC(pthread_join)(pthread_t thread, void **retval)\n     /* cant have been recycled by pthreads.\t\t\t\t*/\n     UNLOCK();\n     result = REAL_FUNC(pthread_join)(thread, retval);\n+    if (result == 0) {\n+        LOCK();\n+        /* Here the pthread thread id may have been recycled. */\n+        GC_delete_gc_thread(thread, thread_gc_id);\n+        UNLOCK();\n+    }\n+    return result;\n+}\n+\n+int\n+WRAP_FUNC(pthread_detach)(pthread_t thread)\n+{\n+    int result;\n+    GC_thread thread_gc_id;\n+    \n     LOCK();\n-    /* Here the pthread thread id may have been recycled. */\n-    GC_delete_gc_thread(thread, thread_gc_id);\n+    thread_gc_id = GC_lookup_thread(thread);\n     UNLOCK();\n+    result = REAL_FUNC(pthread_detach)(thread);\n+    if (result == 0) {\n+      LOCK();\n+      thread_gc_id -> flags |= DETACHED;\n+      /* Here the pthread thread id may have been recycled. */\n+      if (thread_gc_id -> flags & FINISHED) {\n+        GC_delete_gc_thread(thread, thread_gc_id);\n+      }\n+      UNLOCK();\n+    }\n     return result;\n }\n \n@@ -636,8 +1289,14 @@ void * GC_start_routine(void * arg)\n \tGC_printf1(\"start_routine = 0x%lx\\n\", start);\n #   endif\n     start_arg = si -> arg;\n-    sem_post(&(si -> registered));\n-    pthread_cleanup_push(GC_thread_exit_proc, si);\n+    sem_post(&(si -> registered));\t/* Last action on si.\t*/\n+    \t\t\t\t\t/* OK to deallocate.\t*/\n+    pthread_cleanup_push(GC_thread_exit_proc, 0);\n+#   if defined(THREAD_LOCAL_ALLOC) && !defined(DBG_HDRS_ALL)\n+ \tLOCK();\n+        GC_init_thread_local(me);\n+\tUNLOCK();\n+#   endif\n     result = (*start)(start_arg);\n #if DEBUG_THREADS\n         GC_printf1(\"Finishing thread 0x%x\\n\", pthread_self());\n@@ -659,57 +1318,149 @@ WRAP_FUNC(pthread_create)(pthread_t *new_thread,\n     int result;\n     GC_thread t;\n     pthread_t my_new_thread;\n-    void * stack;\n-    size_t stacksize;\n-    pthread_attr_t new_attr;\n     int detachstate;\n     word my_flags = 0;\n-    struct start_info * si = GC_malloc(sizeof(struct start_info)); \n+    struct start_info * si; \n \t/* This is otherwise saved only in an area mmapped by the thread */\n \t/* library, which isn't visible to the collector.\t\t */\n-\n+ \n+    LOCK();\n+    si = (struct start_info *)GC_INTERNAL_MALLOC(sizeof(struct start_info), NORMAL);\n+    UNLOCK();\n+    if (!fully_initialized) GC_full_init();\n     if (0 == si) return(ENOMEM);\n     sem_init(&(si -> registered), 0, 0);\n     si -> start_routine = start_routine;\n     si -> arg = arg;\n     LOCK();\n     if (!GC_thr_initialized) GC_thr_init();\n     if (NULL == attr) {\n-        stack = 0;\n-\t(void) pthread_attr_init(&new_attr);\n+\tdetachstate = PTHREAD_CREATE_JOINABLE;\n     } else {\n-        new_attr = *attr;\n+        pthread_attr_getdetachstate(attr, &detachstate);\n     }\n-    pthread_attr_getdetachstate(&new_attr, &detachstate);\n     if (PTHREAD_CREATE_DETACHED == detachstate) my_flags |= DETACHED;\n     si -> flags = my_flags;\n     UNLOCK();\n #   ifdef DEBUG_THREADS\n         GC_printf1(\"About to start new thread from thread 0x%X\\n\",\n \t\t   pthread_self());\n #   endif\n-    result = REAL_FUNC(pthread_create)(new_thread, &new_attr, GC_start_routine, si);\n+    result = REAL_FUNC(pthread_create)(new_thread, attr, GC_start_routine, si);\n #   ifdef DEBUG_THREADS\n         GC_printf1(\"Started thread 0x%X\\n\", *new_thread);\n #   endif\n     /* Wait until child has been added to the thread table.\t\t*/\n     /* This also ensures that we hold onto si until the child is done\t*/\n     /* with it.  Thus it doesn't matter whether it is otherwise\t\t*/\n     /* visible to the collector.\t\t\t\t\t*/\n-        if (0 != sem_wait(&(si -> registered))) ABORT(\"sem_wait failed\");\n+        while (0 != sem_wait(&(si -> registered))) {\n+\t    if (EINTR != errno) ABORT(\"sem_wait failed\");\n+\t}\n         sem_destroy(&(si -> registered));\n-    /* pthread_attr_destroy(&new_attr); */\n-    /* pthread_attr_destroy(&new_attr); */\n+\tLOCK();\n+\tGC_INTERNAL_FREE(si);\n+\tUNLOCK();\n     return(result);\n }\n \n-#if defined(USE_SPIN_LOCK)\n+#ifdef GENERIC_COMPARE_AND_SWAP\n+  pthread_mutex_t GC_compare_and_swap_lock = PTHREAD_MUTEX_INITIALIZER;\n+\n+  GC_bool GC_compare_and_exchange(volatile GC_word *addr,\n+  \t\t\t          GC_word old, GC_word new_val)\n+  {\n+    GC_bool result;\n+    pthread_mutex_lock(&GC_compare_and_swap_lock);\n+    if (*addr == old) {\n+      *addr = new_val;\n+      result = TRUE;\n+    } else {\n+      result = FALSE;\n+    }\n+    pthread_mutex_unlock(&GC_compare_and_swap_lock);\n+    return result;\n+  }\n+  \n+  GC_word GC_atomic_add(volatile GC_word *addr, GC_word how_much)\n+  {\n+    GC_word old;\n+    pthread_mutex_lock(&GC_compare_and_swap_lock);\n+    old = *addr;\n+    *addr = old + how_much;\n+    pthread_mutex_unlock(&GC_compare_and_swap_lock);\n+    return old;\n+  }\n+\n+#endif /* GENERIC_COMPARE_AND_SWAP */\n+/* Spend a few cycles in a way that can't introduce contention with\t*/\n+/* othre threads.\t\t\t\t\t\t\t*/\n+void GC_pause()\n+{\n+    int i;\n+    volatile word dummy = 0;\n+\n+    for (i = 0; i < 10; ++i) { \n+#     ifdef __GNUC__\n+        __asm__ __volatile__ (\" \" : : : \"memory\");\n+#     else\n+\t/* Something that's unlikely to be optimized away. */\n+\tGC_noop(++dummy);\n+#     endif\n+    }\n+}\n+    \n+#define SPIN_MAX 1024\t/* Maximum number of calls to GC_pause before\t*/\n+\t\t\t/* give up.\t\t\t\t\t*/\n \n VOLATILE GC_bool GC_collecting = 0;\n \t\t\t/* A hint that we're in the collector and       */\n                         /* holding the allocation lock for an           */\n                         /* extended period.                             */\n \n+#if !defined(USE_SPIN_LOCK) || defined(PARALLEL_MARK)\n+/* If we don't want to use the below spinlock implementation, either\t*/\n+/* because we don't have a GC_test_and_set implementation, or because \t*/\n+/* we don't want to risk sleeping, we can still try spinning on \t*/\n+/* pthread_mutex_trylock for a while.  This appears to be very\t\t*/\n+/* beneficial in many cases.\t\t\t\t\t\t*/\n+/* I suspect that under high contention this is nearly always better\t*/\n+/* than the spin lock.  But it's a bit slower on a uniprocessor.\t*/\n+/* Hence we still default to the spin lock.\t\t\t\t*/\n+/* This is also used to acquire the mark lock for the parallel\t\t*/\n+/* marker.\t\t\t\t\t\t\t\t*/\n+\n+/* Here we use a strict exponential backoff scheme.  I don't know \t*/\n+/* whether that's better or worse than the above.  We eventually \t*/\n+/* yield by calling pthread_mutex_lock(); it never makes sense to\t*/\n+/* explicitly sleep.\t\t\t\t\t\t\t*/\n+\n+void GC_generic_lock(pthread_mutex_t * lock)\n+{\n+    unsigned pause_length = 1;\n+    unsigned i;\n+    \n+    if (0 == pthread_mutex_trylock(lock)) return;\n+    for (; pause_length <= SPIN_MAX; pause_length <<= 1) {\n+\tfor (i = 0; i < pause_length; ++i) {\n+\t    GC_pause();\n+\t}\n+        switch(pthread_mutex_trylock(lock)) {\n+\t    case 0:\n+\t\treturn;\n+\t    case EBUSY:\n+\t\tbreak;\n+\t    default:\n+\t\tABORT(\"Unexpected error from pthread_mutex_trylock\");\n+        }\n+    }\n+    pthread_mutex_lock(lock);\n+}\n+\n+#endif /* !USE_SPIN_LOCK || PARALLEL_MARK */\n+\n+#if defined(USE_SPIN_LOCK)\n+\n /* Reasonably fast spin locks.  Basically the same implementation */\n /* as STL alloc.h.  This isn't really the right way to do this.   */\n /* but until the POSIX scheduling mess gets straightened out ...  */\n@@ -720,25 +1471,22 @@ volatile unsigned int GC_allocate_lock = 0;\n void GC_lock()\n {\n #   define low_spin_max 30  /* spin cycles if we suspect uniprocessor */\n-#   define high_spin_max 1000 /* spin cycles for multiprocessor */\n+#   define high_spin_max SPIN_MAX /* spin cycles for multiprocessor */\n     static unsigned spin_max = low_spin_max;\n     unsigned my_spin_max;\n     static unsigned last_spins = 0;\n     unsigned my_last_spins;\n-    volatile unsigned junk;\n-#   define PAUSE junk *= junk; junk *= junk; junk *= junk; junk *= junk\n     int i;\n \n     if (!GC_test_and_set(&GC_allocate_lock)) {\n         return;\n     }\n-    junk = 0;\n     my_spin_max = spin_max;\n     my_last_spins = last_spins;\n     for (i = 0; i < my_spin_max; i++) {\n-        if (GC_collecting) goto yield;\n+        if (GC_collecting || GC_nprocs == 1) goto yield;\n         if (i < my_last_spins/2 || GC_allocate_lock) {\n-            PAUSE; \n+            GC_pause();\n             continue;\n         }\n         if (!GC_test_and_set(&GC_allocate_lock)) {\n@@ -768,8 +1516,8 @@ void GC_lock()\n \t} else {\n \t    struct timespec ts;\n \t\n-\t    if (i > 26) i = 26;\n-\t\t\t/* Don't wait for more than about 60msecs, even\t*/\n+\t    if (i > 24) i = 24;\n+\t\t\t/* Don't wait for more than about 15msecs, even\t*/\n \t\t\t/* under extreme contention.\t\t\t*/\n \t    ts.tv_sec = 0;\n \t    ts.tv_nsec = 1 << i;\n@@ -778,7 +1526,121 @@ void GC_lock()\n     }\n }\n \n-#endif /* known architecture */\n+#else  /* !USE_SPINLOCK */\n+\n+void GC_lock()\n+{\n+    if (1 == GC_nprocs || GC_collecting) {\n+\tpthread_mutex_lock(&GC_allocate_ml);\n+    } else {\n+        GC_generic_lock(&GC_allocate_ml);\n+    }\n+}\n+\n+#endif /* !USE_SPINLOCK */\n+\n+#ifdef PARALLEL_MARK\n+\n+#ifdef GC_ASSERTIONS\n+  pthread_t GC_mark_lock_holder = NO_THREAD;\n+#endif\n+\n+#ifdef IA64\n+  /* Ugly workaround for a linux threads bug in the final versions      */\n+  /* of glibc2.1.  Pthread_mutex_trylock sets the mutex owner           */\n+  /* field even when it fails to acquire the mutex.  This causes        */\n+  /* pthread_cond_wait to die.  Remove for glibc2.2.                    */\n+  /* According to the man page, we should use                           */\n+  /* PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP, but that isn't actually   */\n+  /* defined.                                                           */\n+  static pthread_mutex_t mark_mutex =\n+        {0, 0, 0, PTHREAD_MUTEX_ERRORCHECK_NP, {0, 0}};\n+#else\n+  static pthread_mutex_t mark_mutex = PTHREAD_MUTEX_INITIALIZER;\n+#endif\n+\n+static pthread_cond_t mark_cv = PTHREAD_COND_INITIALIZER;\n+\n+static pthread_cond_t builder_cv = PTHREAD_COND_INITIALIZER;\n+\n+void GC_acquire_mark_lock()\n+{\n+/*\n+    if (pthread_mutex_lock(&mark_mutex) != 0) {\n+\tABORT(\"pthread_mutex_lock failed\");\n+    }\n+*/\n+    GC_generic_lock(&mark_mutex);\n+#   ifdef GC_ASSERTIONS\n+\tGC_mark_lock_holder = pthread_self();\n+#   endif\n+}\n+\n+void GC_release_mark_lock()\n+{\n+    GC_ASSERT(GC_mark_lock_holder == pthread_self());\n+#   ifdef GC_ASSERTIONS\n+\tGC_mark_lock_holder = NO_THREAD;\n+#   endif\n+    if (pthread_mutex_unlock(&mark_mutex) != 0) {\n+\tABORT(\"pthread_mutex_unlock failed\");\n+    }\n+}\n+\n+void GC_wait_marker()\n+{\n+    GC_ASSERT(GC_mark_lock_holder == pthread_self());\n+#   ifdef GC_ASSERTIONS\n+\tGC_mark_lock_holder = NO_THREAD;\n+#   endif\n+    if (pthread_cond_wait(&mark_cv, &mark_mutex) != 0) {\n+\tABORT(\"pthread_cond_wait failed\");\n+    }\n+    GC_ASSERT(GC_mark_lock_holder == NO_THREAD);\n+#   ifdef GC_ASSERTIONS\n+\tGC_mark_lock_holder = pthread_self();\n+#   endif\n+}\n+\n+void GC_wait_builder()\n+{\n+    GC_ASSERT(GC_mark_lock_holder == pthread_self());\n+#   ifdef GC_ASSERTIONS\n+\tGC_mark_lock_holder = NO_THREAD;\n+#   endif\n+    if (pthread_cond_wait(&builder_cv, &mark_mutex) != 0) {\n+\tABORT(\"pthread_cond_wait failed\");\n+    }\n+    GC_ASSERT(GC_mark_lock_holder == NO_THREAD);\n+#   ifdef GC_ASSERTIONS\n+\tGC_mark_lock_holder = pthread_self();\n+#   endif\n+}\n+\n+void GC_notify_all_marker()\n+{\n+    if (pthread_cond_broadcast(&mark_cv) != 0) {\n+\tABORT(\"pthread_cond_broadcast failed\");\n+    }\n+}\n+\n+void GC_notify_all_builder()\n+{\n+    GC_ASSERT(GC_mark_lock_holder == pthread_self());\n+    if (pthread_cond_broadcast(&builder_cv) != 0) {\n+\tABORT(\"pthread_cond_broadcast failed\");\n+    }\n+}\n+\n+void GC_wait_for_reclaim()\n+{\n+    GC_acquire_mark_lock();\n+    while (GC_fl_builder_count > 0) {\n+\tGC_wait_builder();\n+    }\n+    GC_release_mark_lock();\n+}\n+#endif /* PARALLEL_MARK */\n \n # endif /* LINUX_THREADS */\n "}, {"sha": "45cae1f8c39d23b07c31e2d2d14088d5e4afc432", "filename": "boehm-gc/mach_dep.c", "status": "modified", "additions": 44, "deletions": 15, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9110a741e35c54e46c00662ddc420575376c5947/boehm-gc%2Fmach_dep.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9110a741e35c54e46c00662ddc420575376c5947/boehm-gc%2Fmach_dep.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fmach_dep.c?ref=9110a741e35c54e46c00662ddc420575376c5947", "patch": "@@ -12,7 +12,7 @@\n  * modified is included with the above copyright notice.\n  */\n /* Boehm, November 17, 1995 12:13 pm PST */\n-# include \"gc_priv.h\"\n+# include \"private/gc_priv.h\"\n # include <stdio.h>\n # include <setjmp.h>\n # if defined(OS2) || defined(CX_UX)\n@@ -21,7 +21,7 @@\n # endif\n # ifdef AMIGA\n #   ifndef __GNUC__\n-#     include <dos/dos.h>\n+#     include <dos.h>\n #   else\n #     include <machine/reg.h>\n #   endif\n@@ -178,7 +178,10 @@ void GC_push_regs()\n #        else /* !__GNUC__ */\n \t  GC_push_one(getreg(REG_A2));\n \t  GC_push_one(getreg(REG_A3));\n-\t  GC_push_one(getreg(REG_A4));\n+#         ifndef __SASC\n+\t      /* Can probably be changed to #if 0 -Kjetil M. (a4=globals)*/\n+\t    GC_push_one(getreg(REG_A4));\n+#\t  endif\n \t  GC_push_one(getreg(REG_A5));\n \t  GC_push_one(getreg(REG_A6));\n \t  /* Skip stack pointer */\n@@ -220,8 +223,11 @@ void GC_push_regs()\n #       if defined(I386) &&!defined(OS2) &&!defined(SVR4) \\\n \t&& (defined(__MINGW32__) || !defined(MSWIN32)) \\\n \t&& !defined(SCO) && !defined(SCO_ELF) \\\n- \t&& !(defined(LINUX)       && defined(__ELF__)) \\\n+ \t&& !(defined(LINUX) && defined(__ELF__)) \\\n \t&& !(defined(FREEBSD) && defined(__ELF__)) \\\n+\t&& !(defined(NETBSD) && defined(__ELF__)) \\\n+\t&& !(defined(OPENBSD) && defined(__ELF__)) \\\n+\t&& !(defined(BEOS) && defined(__ELF__)) \\\n \t&& !defined(DOS4GW)\n \t/* I386 code, generic code does not appear to work */\n \t/* It does appear to work under OS2, and asms dont */\n@@ -236,7 +242,9 @@ void GC_push_regs()\n #       endif\n \n #\tif ( defined(I386) && defined(LINUX) && defined(__ELF__) ) \\\n-\t|| ( defined(I386) && defined(FREEBSD) && defined(__ELF__) )\n+\t|| ( defined(I386) && defined(FREEBSD) && defined(__ELF__) ) \\\n+\t|| ( defined(I386) && defined(NETBSD) && defined(__ELF__) ) \\\n+\t|| ( defined(I386) && defined(OPENBSD) && defined(__ELF__) )\n \n \t/* This is modified for Linux with ELF (Note: _ELF_ only) */\n \t/* This section handles FreeBSD with ELF. */\n@@ -253,6 +261,17 @@ void GC_push_regs()\n \t  asm(\"pushl %ebx; call GC_push_one; addl $4,%esp\");\n #\tendif\n \n+#\tif ( defined(I386) && defined(BEOS) && defined(__ELF__) )\n+\t/* As far as I can understand from\t\t\t\t*/\n+\t/* http://www.beunited.org/articles/jbq/nasm.shtml,\t\t*/\n+\t/* only ebp, esi, edi and ebx are not scratch. How MMX \t\t*/\n+\t/* etc. registers should be treated, I have no idea. \t\t*/\n+\t  asm(\"pushl %ebp; call GC_push_one; addl $4,%esp\");\n+\t  asm(\"pushl %esi; call GC_push_one; addl $4,%esp\");\n+\t  asm(\"pushl %edi; call GC_push_one; addl $4,%esp\");\n+\t  asm(\"pushl %ebx; call GC_push_one; addl $4,%esp\");\n+#       endif\n+\n #       if defined(I386) && defined(MSWIN32) && !defined(__MINGW32__) \\\n \t   && !defined(USE_GENERIC)\n \t/* I386 code, Microsoft variant\t\t*/\n@@ -402,7 +421,8 @@ ptr_t cold_gc_frame;\n \t\tfor (; (char *)i < lim; i++) {\n \t\t    *i = 0;\n \t\t}\n-#\t    if defined(POWERPC) || defined(MSWIN32) || defined(UTS4) || defined(LINUX)\n+#\t    if defined(POWERPC) || defined(MSWIN32) || defined(MSWINCE) \\\n+\t       || defined(UTS4) || defined(LINUX)\n \t\t(void) setjmp(regs);\n #\t    else\n \t        (void) _setjmp(regs);\n@@ -438,15 +458,15 @@ ptr_t cold_gc_frame;\n       asm(\"_GC_save_regs_in_stack:\");\n #   endif\n #   if defined(__arch64__) || defined(__sparcv9)\n-    asm(\"\tsave\t%sp,-128,%sp\");\n-    asm(\"\tflushw\");\n-    asm(\"\tret\");\n-    asm(\"\trestore %sp,2047+128,%o0\");\n+      asm(\"\tsave\t%sp,-128,%sp\");\n+      asm(\"\tflushw\");\n+      asm(\"\tret\");\n+      asm(\"\trestore %sp,2047+128,%o0\");\n #   else\n-    asm(\"\tta\t0x3   ! ST_FLUSH_WINDOWS\");\n-    asm(\"\tretl\");\n-    asm(\"\tmov\t%sp,%o0\");\n-#endif\n+      asm(\"\tta\t0x3   ! ST_FLUSH_WINDOWS\");\n+      asm(\"\tretl\");\n+      asm(\"\tmov\t%sp,%o0\");\n+#   endif\n #   ifdef SVR4\n       asm(\"\t.GC_save_regs_in_stack_end:\");\n       asm(\"\t.size GC_save_regs_in_stack,.GC_save_regs_in_stack_end-GC_save_regs_in_stack\");\n@@ -460,6 +480,7 @@ ptr_t cold_gc_frame;\n /* up on the other side of the stack segment.\t\t\t\t*/\n /* Returns the backing store pointer for the register stack.\t\t*/\n # ifdef IA64\n+#   ifdef __GNUC__\n \tasm(\"        .text\");\n \tasm(\"        .psr abi64\");\n \tasm(\"        .psr lsb\");\n@@ -476,6 +497,14 @@ ptr_t cold_gc_frame;\n \tasm(\"        mov r8=ar.bsp\");\n \tasm(\"        br.ret.sptk.few rp\");\n \tasm(\"        .endp GC_save_regs_in_stack\");\n+#   else\n+\tvoid GC_save_regs_in_stack() {\n+\t  asm(\"        flushrs\");\n+\t  asm(\"        ;;\");\n+\t  asm(\"        mov r8=ar.bsp\");\n+\t  asm(\"        br.ret.sptk.few rp\");\n+\t}\n+#   endif\n # endif\n \n /* GC_clear_stack_inner(arg, limit) clears stack area up to limit and\t*/\n@@ -523,7 +552,7 @@ ptr_t cold_gc_frame;\n     asm(\"add %o3,-8,%o3\");\t/* p -= 8 (delay slot) */\n   asm(\"retl\");\n     asm(\"mov %o2,%sp\");\t\t/* Restore sp., delay slot\t*/\n-#endif\n+#endif /* old SPARC */\n   /* First argument = %o0 = return value */\n #   ifdef SVR4\n       asm(\"\t.GC_clear_stack_inner_end:\");"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "boehm-gc/makefile.depend", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6951ca5dee8ed05749cdc697767910aebaedcc0/boehm-gc%2Fmakefile.depend", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6951ca5dee8ed05749cdc697767910aebaedcc0/boehm-gc%2Fmakefile.depend", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fmakefile.depend?ref=a6951ca5dee8ed05749cdc697767910aebaedcc0"}, {"sha": "0bbb96abec09c77b01e88cb5513ec7e53998869a", "filename": "boehm-gc/malloc.c", "status": "modified", "additions": 167, "deletions": 159, "changes": 326, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9110a741e35c54e46c00662ddc420575376c5947/boehm-gc%2Fmalloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9110a741e35c54e46c00662ddc420575376c5947/boehm-gc%2Fmalloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fmalloc.c?ref=9110a741e35c54e46c00662ddc420575376c5947", "patch": "@@ -1,6 +1,7 @@\n /* \n  * Copyright 1988, 1989 Hans-J. Boehm, Alan J. Demers\n  * Copyright (c) 1991-1994 by Xerox Corporation.  All rights reserved.\n+ * Copyright (c) 2000 by Hewlett-Packard Company.  All rights reserved.\n  *\n  * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n  * OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n@@ -14,7 +15,7 @@\n /* Boehm, February 7, 1996 4:32 pm PST */\n  \n #include <stdio.h>\n-#include \"gc_priv.h\"\n+#include \"private/gc_priv.h\"\n \n extern ptr_t GC_clear_stack();\t/* in misc.c, behaves like identity */\n void GC_extend_size_map();\t/* in misc.c. */\n@@ -32,7 +33,66 @@ register struct obj_kind * kind;\n     return(TRUE);\n }\n \n-/* allocate lb bytes for an object of kind.\t*/\n+/* Allocate a large block of size lw words.\t*/\n+/* The block is not cleared.\t\t\t*/\n+/* Flags is 0 or IGNORE_OFF_PAGE.\t\t*/\n+ptr_t GC_alloc_large(lw, k, flags)\n+word lw;\n+int k;\n+unsigned flags;\n+{\n+    struct hblk * h;\n+    word n_blocks = OBJ_SZ_TO_BLOCKS(lw);\n+    ptr_t result;\n+\t\n+    if (!GC_is_initialized) GC_init_inner();\n+    /* Do our share of marking work */\n+        if(GC_incremental && !GC_dont_gc)\n+\t    GC_collect_a_little_inner((int)n_blocks);\n+    h = GC_allochblk(lw, k, flags);\n+#   ifdef USE_MUNMAP\n+\tif (0 == h) {\n+\t    GC_merge_unmapped();\n+\t    h = GC_allochblk(lw, k, flags);\n+\t}\n+#   endif\n+    while (0 == h && GC_collect_or_expand(n_blocks, (flags != 0))) {\n+\th = GC_allochblk(lw, k, flags);\n+    }\n+    if (h == 0) {\n+\tresult = 0;\n+    } else {\n+\tint total_bytes = BYTES_TO_WORDS(n_blocks * HBLKSIZE);\n+\tif (n_blocks > 1) {\n+\t    GC_large_allocd_bytes += n_blocks * HBLKSIZE;\n+\t    if (GC_large_allocd_bytes > GC_max_large_allocd_bytes)\n+\t        GC_max_large_allocd_bytes = GC_large_allocd_bytes;\n+\t}\n+\tresult = (ptr_t) (h -> hb_body);\n+\tGC_words_wasted += total_bytes - lw;\n+    }\n+    return result;\n+}\n+\n+\n+/* Allocate a large block of size lb bytes.  Clear if appropriate.\t*/\n+ptr_t GC_alloc_large_and_clear(lw, k, flags)\n+word lw;\n+int k;\n+unsigned flags;\n+{\n+    ptr_t result = GC_alloc_large(lw, k, flags);\n+    word n_blocks = OBJ_SZ_TO_BLOCKS(lw);\n+\n+    if (0 == result) return 0;\n+    if (GC_debugging_started || GC_obj_kinds[k].ok_init) {\n+\t/* Clear the whole block, in case of GC_realloc call. */\n+\tBZERO(result, n_blocks * HBLKSIZE);\n+    }\n+    return result;\n+}\n+\n+/* allocate lb bytes for an object of kind k.\t*/\n /* Should not be used to directly to allocate\t*/\n /* objects such as STUBBORN objects that\t*/\n /* require special handling on allocation.\t*/\n@@ -88,36 +148,31 @@ register ptr_t *opp;\n         *opp = obj_link(op);\n         obj_link(op) = 0;\n     } else {\n-\tregister struct hblk * h;\n-\tregister word n_blocks = divHBLKSZ(ADD_SLOP(lb)\n-\t\t\t\t\t   + HDR_BYTES + HBLKSIZE-1);\n-\t\n-\tif (!GC_is_initialized) GC_init_inner();\n-\t/* Do our share of marking work */\n-          if(GC_incremental && !GC_dont_gc)\n-\t\tGC_collect_a_little_inner((int)n_blocks);\n \tlw = ROUNDED_UP_WORDS(lb);\n-        h = GC_allochblk(lw, k, 0);\n-#       ifdef USE_MUNMAP\n-\t  if (0 == h) {\n-\t    GC_merge_unmapped();\n-\t    h = GC_allochblk(lw, k, 0);\n-\t  }\n-#\tendif\n-\twhile (0 == h && GC_collect_or_expand(n_blocks, FALSE)) {\n-\t  h = GC_allochblk(lw, k, 0);\n-\t}\n-\tif (h == 0) {\n-\t    op = 0;\n-\t} else {\n-\t    op = (ptr_t) (h -> hb_body);\n-\t    GC_words_wasted += BYTES_TO_WORDS(n_blocks * HBLKSIZE) - lw;\n-\t}\n+\top = (ptr_t)GC_alloc_large_and_clear(lw, k, 0);\n     }\n     GC_words_allocd += lw;\n     \n out:\n-    return((ptr_t)op);\n+    return op;\n+}\n+\n+/* Allocate a composite object of size n bytes.  The caller guarantees  */\n+/* that pointers past the first page are not relevant.  Caller holds    */\n+/* allocation lock.                                                     */\n+ptr_t GC_generic_malloc_inner_ignore_off_page(lb, k)\n+register size_t lb;\n+register int k;\n+{\n+    register word lw;\n+    ptr_t op;\n+\n+    if (lb <= HBLKSIZE)\n+        return(GC_generic_malloc_inner((word)lb, k));\n+    lw = ROUNDED_UP_WORDS(lb);\n+    op = (ptr_t)GC_alloc_large_and_clear(lw, k, IGNORE_OFF_PAGE);\n+    GC_words_allocd += lw;\n+    return op;\n }\n \n ptr_t GC_generic_malloc(lb, k)\n@@ -128,11 +183,43 @@ register int k;\n     DCL_LOCK_STATE;\n \n     GC_INVOKE_FINALIZERS();\n-    DISABLE_SIGNALS();\n-    LOCK();\n-    result = GC_generic_malloc_inner(lb, k);\n-    UNLOCK();\n-    ENABLE_SIGNALS();\n+    if (SMALL_OBJ(lb)) {\n+    \tDISABLE_SIGNALS();\n+\tLOCK();\n+        result = GC_generic_malloc_inner((word)lb, k);\n+\tUNLOCK();\n+\tENABLE_SIGNALS();\n+    } else {\n+\tword lw;\n+\tword n_blocks;\n+\tGC_bool init;\n+\tlw = ROUNDED_UP_WORDS(lb);\n+\tn_blocks = OBJ_SZ_TO_BLOCKS(lw);\n+\tinit = GC_obj_kinds[k].ok_init;\n+\tDISABLE_SIGNALS();\n+\tLOCK();\n+\tresult = (ptr_t)GC_alloc_large(lw, k, 0);\n+\tif (0 != result) {\n+\t  if (GC_debugging_started) {\n+\t    BZERO(result, n_blocks * HBLKSIZE);\n+\t  } else {\n+#           ifdef THREADS\n+\t      /* Clear any memory that might be used for GC descriptors */\n+\t      /* before we release the lock.\t\t\t      */\n+\t        ((word *)result)[0] = 0;\n+\t        ((word *)result)[1] = 0;\n+\t        ((word *)result)[lw-1] = 0;\n+\t        ((word *)result)[lw-2] = 0;\n+#\t    endif\n+\t  }\n+\t}\n+\tGC_words_allocd += lw;\n+\tUNLOCK();\n+\tENABLE_SIGNALS();\n+    \tif (init & !GC_debugging_started && 0 != result) {\n+\t    BZERO(result, n_blocks * HBLKSIZE);\n+        }\n+    }\n     if (0 == result) {\n         return((*GC_oom_fn)(lb));\n     } else {\n@@ -159,15 +246,15 @@ register ptr_t * opp;\n register word lw;\n DCL_LOCK_STATE;\n \n-    if( SMALL_OBJ(lb) ) {\n+    if( EXPECT(SMALL_OBJ(lb), 1) ) {\n #       ifdef MERGE_SIZES\n \t  lw = GC_size_map[lb];\n #\telse\n \t  lw = ALIGNED_WORDS(lb);\n #       endif\n \topp = &(GC_aobjfreelist[lw]);\n \tFASTLOCK();\n-        if( !FASTLOCK_SUCCEEDED() || (op = *opp) == 0 ) {\n+        if( EXPECT(!FASTLOCK_SUCCEEDED() || (op = *opp) == 0, 0) ) {\n             FASTUNLOCK();\n             return(GENERAL_MALLOC((word)lb, PTRFREE));\n         }\n@@ -194,15 +281,15 @@ register ptr_t *opp;\n register word lw;\n DCL_LOCK_STATE;\n \n-    if( SMALL_OBJ(lb) ) {\n+    if( EXPECT(SMALL_OBJ(lb), 1) ) {\n #       ifdef MERGE_SIZES\n \t  lw = GC_size_map[lb];\n #\telse\n \t  lw = ALIGNED_WORDS(lb);\n #       endif\n \topp = &(GC_objfreelist[lw]);\n \tFASTLOCK();\n-        if( !FASTLOCK_SUCCEEDED() || (op = *opp) == 0 ) {\n+        if( EXPECT(!FASTLOCK_SUCCEEDED() || (op = *opp) == 0, 0) ) {\n             FASTUNLOCK();\n             return(GENERAL_MALLOC((word)lb, NORMAL));\n         }\n@@ -238,7 +325,7 @@ DCL_LOCK_STATE;\n        */\n       if (!GC_is_initialized) return sbrk(lb);\n #   endif /* I386 && SOLARIS_THREADS */\n-    return(REDIRECT_MALLOC(lb));\n+    return((GC_PTR)REDIRECT_MALLOC(lb));\n   }\n \n # ifdef __STDC__\n@@ -248,125 +335,7 @@ DCL_LOCK_STATE;\n     size_t n, lb;\n # endif\n   {\n-    return(REDIRECT_MALLOC(n*lb));\n-  }\n-# endif /* REDIRECT_MALLOC */\n-\n-GC_PTR GC_generic_or_special_malloc(lb,knd)\n-word lb;\n-int knd;\n-{\n-    switch(knd) {\n-#     ifdef STUBBORN_ALLOC\n-\tcase STUBBORN:\n-\t    return(GC_malloc_stubborn((size_t)lb));\n-#     endif\n-\tcase PTRFREE:\n-\t    return(GC_malloc_atomic((size_t)lb));\n-\tcase NORMAL:\n-\t    return(GC_malloc((size_t)lb));\n-\tcase UNCOLLECTABLE:\n-\t    return(GC_malloc_uncollectable((size_t)lb));\n-#       ifdef ATOMIC_UNCOLLECTABLE\n-\t  case AUNCOLLECTABLE:\n-\t    return(GC_malloc_atomic_uncollectable((size_t)lb));\n-#\tendif /* ATOMIC_UNCOLLECTABLE */\n-\tdefault:\n-\t    return(GC_generic_malloc(lb,knd));\n-    }\n-}\n-\n-\n-/* Change the size of the block pointed to by p to contain at least   */\n-/* lb bytes.  The object may be (and quite likely will be) moved.     */\n-/* The kind (e.g. atomic) is the same as that of the old.\t      */\n-/* Shrinking of large blocks is not implemented well.                 */\n-# ifdef __STDC__\n-    GC_PTR GC_realloc(GC_PTR p, size_t lb)\n-# else\n-    GC_PTR GC_realloc(p,lb)\n-    GC_PTR p;\n-    size_t lb;\n-# endif\n-{\n-register struct hblk * h;\n-register hdr * hhdr;\n-register word sz;\t /* Current size in bytes\t*/\n-register word orig_sz;\t /* Original sz in bytes\t*/\n-int obj_kind;\n-\n-    if (p == 0) return(GC_malloc(lb));\t/* Required by ANSI */\n-    h = HBLKPTR(p);\n-    hhdr = HDR(h);\n-    sz = hhdr -> hb_sz;\n-    obj_kind = hhdr -> hb_obj_kind;\n-    sz = WORDS_TO_BYTES(sz);\n-    orig_sz = sz;\n-\n-    if (sz > WORDS_TO_BYTES(MAXOBJSZ)) {\n-\t/* Round it up to the next whole heap block */\n-\t  register word descr;\n-\t  \n-\t  sz = (sz+HDR_BYTES+HBLKSIZE-1)\n-\t\t& (~HBLKMASK);\n-\t  sz -= HDR_BYTES;\n-\t  hhdr -> hb_sz = BYTES_TO_WORDS(sz);\n-\t  descr = GC_obj_kinds[obj_kind].ok_descriptor;\n-          if (GC_obj_kinds[obj_kind].ok_relocate_descr) descr += sz;\n-          hhdr -> hb_descr = descr;\n-\t  if (IS_UNCOLLECTABLE(obj_kind)) GC_non_gc_bytes += (sz - orig_sz);\n-\t  /* Extra area is already cleared by allochblk. */\n-    }\n-    if (ADD_SLOP(lb) <= sz) {\n-\tif (lb >= (sz >> 1)) {\n-#\t    ifdef STUBBORN_ALLOC\n-\t        if (obj_kind == STUBBORN) GC_change_stubborn(p);\n-#\t    endif\n-\t    if (orig_sz > lb) {\n-\t      /* Clear unneeded part of object to avoid bogus pointer */\n-\t      /* tracing.\t\t\t\t\t      */\n-\t      /* Safe for stubborn objects.\t\t\t      */\n-\t        BZERO(((ptr_t)p) + lb, orig_sz - lb);\n-\t    }\n-\t    return(p);\n-\t} else {\n-\t    /* shrink */\n-\t      GC_PTR result =\n-\t      \t\tGC_generic_or_special_malloc((word)lb, obj_kind);\n-\n-\t      if (result == 0) return(0);\n-\t          /* Could also return original object.  But this \t*/\n-\t          /* gives the client warning of imminent disaster.\t*/\n-\t      BCOPY(p, result, lb);\n-#\t      ifndef IGNORE_FREE\n-\t        GC_free(p);\n-#\t      endif\n-\t      return(result);\n-\t}\n-    } else {\n-\t/* grow */\n-\t  GC_PTR result =\n-\t  \tGC_generic_or_special_malloc((word)lb, obj_kind);\n-\n-\t  if (result == 0) return(0);\n-\t  BCOPY(p, result, sz);\n-#\t  ifndef IGNORE_FREE\n-\t    GC_free(p);\n-#\t  endif\n-\t  return(result);\n-    }\n-}\n-\n-# ifdef REDIRECT_MALLOC\n-# ifdef __STDC__\n-    GC_PTR realloc(GC_PTR p, size_t lb)\n-# else\n-    GC_PTR realloc(p,lb)\n-    GC_PTR p;\n-    size_t lb;\n-# endif\n-  {\n-    return(GC_realloc(p, lb));\n+    return((GC_PTR)REDIRECT_MALLOC(n*lb));\n   }\n # endif /* REDIRECT_MALLOC */\n \n@@ -391,15 +360,18 @@ int obj_kind;\n     h = HBLKPTR(p);\n     hhdr = HDR(h);\n #   if defined(REDIRECT_MALLOC) && \\\n-\t(defined(SOLARIS_THREADS) || defined(LINUX_THREADS))\n-\t/* We have to redirect malloc calls during initialization.\t*/\n+\t(defined(SOLARIS_THREADS) || defined(LINUX_THREADS) \\\n+\t || defined(__MINGW32__)) /* Should this be MSWIN32 in general? */\n+\t/* For Solaris, we have to redirect malloc calls during\t\t*/\n+\t/* initialization.  For the others, this seems to happen \t*/\n+ \t/* implicitly.\t\t\t\t\t\t\t*/\n \t/* Don't try to deallocate that memory.\t\t\t\t*/\n \tif (0 == hhdr) return;\n #   endif\n     knd = hhdr -> hb_obj_kind;\n     sz = hhdr -> hb_sz;\n     ok = &GC_obj_kinds[knd];\n-    if (sz <= MAXOBJSZ) {\n+    if (EXPECT((sz <= MAXOBJSZ), 1)) {\n #\tifdef THREADS\n \t    DISABLE_SIGNALS();\n \t    LOCK();\n@@ -432,6 +404,42 @@ int obj_kind;\n     }\n }\n \n+/* Explicitly deallocate an object p when we already hold lock.\t\t*/\n+/* Only used for internally allocated objects, so we can take some \t*/\n+/* shortcuts.\t\t\t\t\t\t\t\t*/\n+#ifdef THREADS\n+void GC_free_inner(GC_PTR p)\n+{\n+    register struct hblk *h;\n+    register hdr *hhdr;\n+    register signed_word sz;\n+    register ptr_t * flh;\n+    register int knd;\n+    register struct obj_kind * ok;\n+    DCL_LOCK_STATE;\n+\n+    h = HBLKPTR(p);\n+    hhdr = HDR(h);\n+    knd = hhdr -> hb_obj_kind;\n+    sz = hhdr -> hb_sz;\n+    ok = &GC_obj_kinds[knd];\n+    if (sz <= MAXOBJSZ) {\n+\tGC_mem_freed += sz;\n+\tif (IS_UNCOLLECTABLE(knd)) GC_non_gc_bytes -= WORDS_TO_BYTES(sz);\n+\tif (ok -> ok_init) {\n+\t    BZERO((word *)p + 1, WORDS_TO_BYTES(sz-1));\n+\t}\n+\tflh = &(ok -> ok_freelist[sz]);\n+\tobj_link(p) = *flh;\n+\t*flh = (ptr_t)p;\n+    } else {\n+        GC_mem_freed += sz;\n+\tif (IS_UNCOLLECTABLE(knd)) GC_non_gc_bytes -= WORDS_TO_BYTES(sz);\n+        GC_freehblk(h);\n+    }\n+}\n+#endif /* THREADS */\n+\n # ifdef REDIRECT_MALLOC\n #   ifdef __STDC__\n       void free(GC_PTR p)"}, {"sha": "77c750fafbcf36718402d7b44a6e9c95f33dfcb3", "filename": "boehm-gc/mallocx.c", "status": "modified", "additions": 305, "deletions": 71, "changes": 376, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9110a741e35c54e46c00662ddc420575376c5947/boehm-gc%2Fmallocx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9110a741e35c54e46c00662ddc420575376c5947/boehm-gc%2Fmallocx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fmallocx.c?ref=9110a741e35c54e46c00662ddc420575376c5947", "patch": "@@ -2,6 +2,7 @@\n  * Copyright 1988, 1989 Hans-J. Boehm, Alan J. Demers\n  * Copyright (c) 1991-1994 by Xerox Corporation.  All rights reserved.\n  * Copyright (c) 1996 by Silicon Graphics.  All rights reserved.\n+ * Copyright (c) 2000 by Hewlett-Packard Company.  All rights reserved.\n  *\n  * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n  * OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n@@ -21,7 +22,7 @@\n  */\n \n #include <stdio.h>\n-#include \"gc_priv.h\"\n+#include \"private/gc_priv.h\"\n \n extern ptr_t GC_clear_stack();  /* in misc.c, behaves like identity */\n void GC_extend_size_map();      /* in misc.c. */\n@@ -30,69 +31,179 @@ GC_bool GC_alloc_reclaim_list();\t/* in malloc.c */\n /* Some externally visible but unadvertised variables to allow access to */\n /* free lists from inlined allocators without including gc_priv.h\t */\n /* or introducing dependencies on internal data structure layouts.\t */\n-ptr_t * CONST GC_objfreelist_ptr = GC_objfreelist;\n-ptr_t * CONST GC_aobjfreelist_ptr = GC_aobjfreelist;\n-ptr_t * CONST GC_uobjfreelist_ptr = GC_uobjfreelist;\n+ptr_t * GC_CONST GC_objfreelist_ptr = GC_objfreelist;\n+ptr_t * GC_CONST GC_aobjfreelist_ptr = GC_aobjfreelist;\n+ptr_t * GC_CONST GC_uobjfreelist_ptr = GC_uobjfreelist;\n # ifdef ATOMIC_UNCOLLECTABLE\n-    ptr_t * CONST GC_auobjfreelist_ptr = GC_auobjfreelist;\n+    ptr_t * GC_CONST GC_auobjfreelist_ptr = GC_auobjfreelist;\n # endif\n \n-/* Allocate a composite object of size n bytes.  The caller guarantees  */\n-/* that pointers past the first page are not relevant.  Caller holds    */\n-/* allocation lock.                                                     */\n-ptr_t GC_generic_malloc_inner_ignore_off_page(lb, k)\n-register size_t lb;\n-register int k;\n+\n+GC_PTR GC_generic_or_special_malloc(lb,knd)\n+word lb;\n+int knd;\n {\n-    register struct hblk * h;\n-    register word n_blocks;\n-    register word lw;\n-    register ptr_t op;\n-\n-    if (lb <= HBLKSIZE)\n-        return(GC_generic_malloc_inner((word)lb, k));\n-    n_blocks = divHBLKSZ(ADD_SLOP(lb) + HDR_BYTES + HBLKSIZE-1);\n-    if (!GC_is_initialized) GC_init_inner();\n-    /* Do our share of marking work */\n-    if(GC_incremental && !GC_dont_gc)\n-        GC_collect_a_little_inner((int)n_blocks);\n-    lw = ROUNDED_UP_WORDS(lb);\n-    h = GC_allochblk(lw, k, IGNORE_OFF_PAGE);\n-#   ifdef USE_MUNMAP\n-      if (0 == h) {\n-        GC_merge_unmapped();\n-        h = GC_allochblk(lw, k, IGNORE_OFF_PAGE);\n-      }\n-#   endif\n-    while (0 == h && GC_collect_or_expand(n_blocks, TRUE)) {\n-      h = GC_allochblk(lw, k, IGNORE_OFF_PAGE);\n+    switch(knd) {\n+#     ifdef STUBBORN_ALLOC\n+\tcase STUBBORN:\n+\t    return(GC_malloc_stubborn((size_t)lb));\n+#     endif\n+\tcase PTRFREE:\n+\t    return(GC_malloc_atomic((size_t)lb));\n+\tcase NORMAL:\n+\t    return(GC_malloc((size_t)lb));\n+\tcase UNCOLLECTABLE:\n+\t    return(GC_malloc_uncollectable((size_t)lb));\n+#       ifdef ATOMIC_UNCOLLECTABLE\n+\t  case AUNCOLLECTABLE:\n+\t    return(GC_malloc_atomic_uncollectable((size_t)lb));\n+#\tendif /* ATOMIC_UNCOLLECTABLE */\n+\tdefault:\n+\t    return(GC_generic_malloc(lb,knd));\n     }\n-    if (h == 0) {\n-        op = 0;\n+}\n+\n+\n+/* Change the size of the block pointed to by p to contain at least   */\n+/* lb bytes.  The object may be (and quite likely will be) moved.     */\n+/* The kind (e.g. atomic) is the same as that of the old.\t      */\n+/* Shrinking of large blocks is not implemented well.                 */\n+# ifdef __STDC__\n+    GC_PTR GC_realloc(GC_PTR p, size_t lb)\n+# else\n+    GC_PTR GC_realloc(p,lb)\n+    GC_PTR p;\n+    size_t lb;\n+# endif\n+{\n+register struct hblk * h;\n+register hdr * hhdr;\n+register word sz;\t /* Current size in bytes\t*/\n+register word orig_sz;\t /* Original sz in bytes\t*/\n+int obj_kind;\n+\n+    if (p == 0) return(GC_malloc(lb));\t/* Required by ANSI */\n+    h = HBLKPTR(p);\n+    hhdr = HDR(h);\n+    sz = hhdr -> hb_sz;\n+    obj_kind = hhdr -> hb_obj_kind;\n+    sz = WORDS_TO_BYTES(sz);\n+    orig_sz = sz;\n+\n+    if (sz > MAXOBJBYTES) {\n+\t/* Round it up to the next whole heap block */\n+\t  register word descr;\n+\t  \n+\t  sz = (sz+HBLKSIZE-1) & (~HBLKMASK);\n+\t  hhdr -> hb_sz = BYTES_TO_WORDS(sz);\n+\t  descr = GC_obj_kinds[obj_kind].ok_descriptor;\n+          if (GC_obj_kinds[obj_kind].ok_relocate_descr) descr += sz;\n+          hhdr -> hb_descr = descr;\n+\t  if (IS_UNCOLLECTABLE(obj_kind)) GC_non_gc_bytes += (sz - orig_sz);\n+\t  /* Extra area is already cleared by GC_alloc_large_and_clear. */\n+    }\n+    if (ADD_SLOP(lb) <= sz) {\n+\tif (lb >= (sz >> 1)) {\n+#\t    ifdef STUBBORN_ALLOC\n+\t        if (obj_kind == STUBBORN) GC_change_stubborn(p);\n+#\t    endif\n+\t    if (orig_sz > lb) {\n+\t      /* Clear unneeded part of object to avoid bogus pointer */\n+\t      /* tracing.\t\t\t\t\t      */\n+\t      /* Safe for stubborn objects.\t\t\t      */\n+\t        BZERO(((ptr_t)p) + lb, orig_sz - lb);\n+\t    }\n+\t    return(p);\n+\t} else {\n+\t    /* shrink */\n+\t      GC_PTR result =\n+\t      \t\tGC_generic_or_special_malloc((word)lb, obj_kind);\n+\n+\t      if (result == 0) return(0);\n+\t          /* Could also return original object.  But this \t*/\n+\t          /* gives the client warning of imminent disaster.\t*/\n+\t      BCOPY(p, result, lb);\n+#\t      ifndef IGNORE_FREE\n+\t        GC_free(p);\n+#\t      endif\n+\t      return(result);\n+\t}\n     } else {\n-        op = (ptr_t) (h -> hb_body);\n-        GC_words_wasted += BYTES_TO_WORDS(n_blocks * HBLKSIZE) - lw;\n+\t/* grow */\n+\t  GC_PTR result =\n+\t  \tGC_generic_or_special_malloc((word)lb, obj_kind);\n+\n+\t  if (result == 0) return(0);\n+\t  BCOPY(p, result, sz);\n+#\t  ifndef IGNORE_FREE\n+\t    GC_free(p);\n+#\t  endif\n+\t  return(result);\n     }\n-    GC_words_allocd += lw;\n-    return((ptr_t)op);\n }\n \n+# if defined(REDIRECT_MALLOC) || defined(REDIRECT_REALLOC)\n+# ifdef __STDC__\n+    GC_PTR realloc(GC_PTR p, size_t lb)\n+# else\n+    GC_PTR realloc(p,lb)\n+    GC_PTR p;\n+    size_t lb;\n+# endif\n+  {\n+#   ifdef REDIRECT_REALLOC\n+      return(REDIRECT_REALLOC(p, lb));\n+#   else\n+      return(GC_realloc(p, lb));\n+#   endif\n+  }\n+# endif /* REDIRECT_MALLOC */\n+\n+\n+/* The same thing, except caller does not hold allocation lock.\t*/\n+/* We avoid holding allocation lock while we clear memory.\t*/\n ptr_t GC_generic_malloc_ignore_off_page(lb, k)\n register size_t lb;\n register int k;\n {\n     register ptr_t result;\n+    word lw;\n+    word n_blocks;\n+    GC_bool init;\n     DCL_LOCK_STATE;\n     \n+    if (SMALL_OBJ(lb))\n+        return(GC_generic_malloc((word)lb, k));\n+    lw = ROUNDED_UP_WORDS(lb);\n+    n_blocks = OBJ_SZ_TO_BLOCKS(lw);\n+    init = GC_obj_kinds[k].ok_init;\n     GC_INVOKE_FINALIZERS();\n     DISABLE_SIGNALS();\n     LOCK();\n-    result = GC_generic_malloc_inner_ignore_off_page(lb,k);\n+    result = (ptr_t)GC_alloc_large(lw, k, IGNORE_OFF_PAGE);\n+    if (0 != result) {\n+        if (GC_debugging_started) {\n+\t    BZERO(result, n_blocks * HBLKSIZE);\n+        } else {\n+#           ifdef THREADS\n+\t      /* Clear any memory that might be used for GC descriptors */\n+\t      /* before we release the lock.\t\t\t      */\n+\t        ((word *)result)[0] = 0;\n+\t        ((word *)result)[1] = 0;\n+\t        ((word *)result)[lw-1] = 0;\n+\t        ((word *)result)[lw-2] = 0;\n+#\t    endif\n+        }\n+    }\n+    GC_words_allocd += lw;\n     UNLOCK();\n     ENABLE_SIGNALS();\n     if (0 == result) {\n         return((*GC_oom_fn)(lb));\n     } else {\n+    \tif (init & !GC_debugging_started) {\n+\t    BZERO(result, n_blocks * HBLKSIZE);\n+        }\n         return(result);\n     }\n }\n@@ -185,6 +296,24 @@ DCL_LOCK_STATE;\n }\n \n #if defined(THREADS) && !defined(SRC_M3)\n+\n+extern signed_word GC_mem_found;   /* Protected by GC lock.  */\n+\n+#ifdef PARALLEL_MARK\n+volatile signed_word GC_words_allocd_tmp = 0;\n+                        /* Number of words of memory allocated since    */\n+                        /* we released the GC lock.  Instead of         */\n+                        /* reacquiring the GC lock just to add this in, */\n+                        /* we add it in the next time we reacquire      */\n+                        /* the lock.  (Atomically adding it doesn't     */\n+                        /* work, since we would have to atomically      */\n+                        /* update it in GC_malloc, which is too         */\n+                        /* expensive.                                   */\n+#endif /* PARALLEL_MARK */\n+\n+/* See reclaim.c: */\n+extern ptr_t GC_reclaim_generic();\n+\n /* Return a list of 1 or more objects of the indicated size, linked\t*/\n /* through the first word in the object.  This has the advantage that\t*/\n /* it acquires the allocation lock only once, and may greatly reduce\t*/\n@@ -200,12 +329,19 @@ register word lb;\n register int k;\n {\n ptr_t op;\n-register ptr_t p;\n+ptr_t p;\n ptr_t *opp;\n word lw;\n-register word my_words_allocd;\n+word my_words_allocd = 0;\n+struct obj_kind * ok = &(GC_obj_kinds[k]);\n DCL_LOCK_STATE;\n \n+#   if defined(GATHERSTATS) || defined(PARALLEL_MARK)\n+#     define COUNT_ARG , &my_words_allocd\n+#   else\n+#     define COUNT_ARG\n+#     define NEED_TO_COUNT\n+#   endif\n     if (!SMALL_OBJ(lb)) {\n         op = GC_generic_malloc(lb, k);\n         if(0 != op) obj_link(op) = 0;\n@@ -215,40 +351,142 @@ DCL_LOCK_STATE;\n     GC_INVOKE_FINALIZERS();\n     DISABLE_SIGNALS();\n     LOCK();\n-    opp = &(GC_obj_kinds[k].ok_freelist[lw]);\n-    if( (op = *opp) == 0 ) {\n-        if (!GC_is_initialized) {\n-            GC_init_inner();\n-        }\n-\top = GC_clear_stack(GC_allocobj(lw, k));\n-\tif (op == 0) {\n-\t    UNLOCK();\n-\t    ENABLE_SIGNALS();\n-\t    op = (*GC_oom_fn)(lb);\n-\t    if(0 != op) obj_link(op) = 0;\n-            return(op);\n-\t}\n+    if (!GC_is_initialized) GC_init_inner();\n+    /* First see if we can reclaim a page of objects waiting to be */\n+    /* reclaimed.\t\t\t\t\t\t   */\n+    {\n+\tstruct hblk ** rlh = ok -> ok_reclaim_list;\n+\tstruct hblk * hbp;\n+\thdr * hhdr;\n+\n+\trlh += lw;\n+    \twhile ((hbp = *rlh) != 0) {\n+            hhdr = HDR(hbp);\n+            *rlh = hhdr -> hb_next;\n+#\t    ifdef PARALLEL_MARK\n+\t\t{\n+\t\t  signed_word my_words_allocd_tmp = GC_words_allocd_tmp;\n+\n+\t\t  GC_ASSERT(my_words_allocd_tmp >= 0);\n+\t\t  /* We only decrement it while holding the GC lock.\t*/\n+\t\t  /* Thus we can't accidentally adjust it down in more\t*/\n+\t\t  /* than one thread simultaneously.\t\t\t*/\n+\t\t  if (my_words_allocd_tmp != 0) {\n+\t\t    (void)GC_atomic_add(\n+\t\t\t\t(volatile GC_word *)(&GC_words_allocd_tmp),\n+\t\t\t\t(GC_word)(-my_words_allocd_tmp));\n+\t\t    GC_words_allocd += my_words_allocd_tmp;\n+\t\t  }\n+\t\t}\n+\t\tGC_acquire_mark_lock();\n+\t\t++ GC_fl_builder_count;\n+\t\tUNLOCK();\n+\t\tENABLE_SIGNALS();\n+\t\tGC_release_mark_lock();\n+#\t    endif\n+\t    op = GC_reclaim_generic(hbp, hhdr, lw,\n+\t\t\t\t    ok -> ok_init, 0 COUNT_ARG);\n+            if (op != 0) {\n+#\t      ifdef NEED_TO_COUNT\n+\t\t/* We are neither gathering statistics, nor marking in\t*/\n+\t\t/* parallel.  Thus GC_reclaim_generic doesn't count\t*/\n+\t\t/* for us.\t\t\t\t\t\t*/\n+    \t\tfor (p = op; p != 0; p = obj_link(p)) {\n+        \t  my_words_allocd += lw;\n+\t\t}\n+#\t      endif\n+#\t      if defined(GATHERSTATS)\n+\t        /* We also reclaimed memory, so we need to adjust \t*/\n+\t        /* that count.\t\t\t\t\t\t*/\n+\t\t/* This should be atomic, so the results may be\t\t*/\n+\t\t/* inaccurate.\t\t\t\t\t\t*/\n+\t\tGC_mem_found += my_words_allocd;\n+#\t      endif\n+#\t      ifdef PARALLEL_MARK\n+\t\t(void)GC_atomic_add(\n+\t\t\t\t(volatile GC_word *)(&GC_words_allocd_tmp),\n+\t\t\t\t(GC_word)(my_words_allocd));\n+\t\tGC_acquire_mark_lock();\n+\t\t-- GC_fl_builder_count;\n+\t\tif (GC_fl_builder_count == 0) GC_notify_all_builder();\n+\t\tGC_release_mark_lock();\n+\t\treturn GC_clear_stack(op);\n+#\t      else\n+\t        GC_words_allocd += my_words_allocd;\n+\t        goto out;\n+#\t      endif\n+\t    }\n+#\t    ifdef PARALLEL_MARK\n+\t      GC_acquire_mark_lock();\n+\t      -- GC_fl_builder_count;\n+\t      if (GC_fl_builder_count == 0) GC_notify_all_builder();\n+\t      GC_release_mark_lock();\n+\t      DISABLE_SIGNALS();\n+\t      LOCK();\n+\t      /* GC lock is needed for reclaim list access.\tWe\t*/\n+\t      /* must decrement fl_builder_count before reaquiring GC\t*/\n+\t      /* lock.  Hopefully this path is rare.\t\t\t*/\n+#\t    endif\n+    \t}\n     }\n-    *opp = 0;\n-    my_words_allocd = 0;\n-    for (p = op; p != 0; p = obj_link(p)) {\n-        my_words_allocd += lw;\n-        if (my_words_allocd >= BODY_SZ) {\n+    /* Next try to use prefix of global free list if there is one.\t*/\n+    /* We don't refill it, but we need to use it up before allocating\t*/\n+    /* a new block ourselves.\t\t\t\t\t\t*/\n+      opp = &(GC_obj_kinds[k].ok_freelist[lw]);\n+      if ( (op = *opp) != 0 ) {\n+\t*opp = 0;\n+        my_words_allocd = 0;\n+        for (p = op; p != 0; p = obj_link(p)) {\n+          my_words_allocd += lw;\n+          if (my_words_allocd >= BODY_SZ) {\n             *opp = obj_link(p);\n             obj_link(p) = 0;\n             break;\n+\t  }\n         }\n+\tGC_words_allocd += my_words_allocd;\n+\tgoto out;\n+      }\n+    /* Next try to allocate a new block worth of objects of this size.\t*/\n+    {\n+\tstruct hblk *h = GC_allochblk(lw, k, 0);\n+\tif (h != 0) {\n+\t  if (IS_UNCOLLECTABLE(k)) GC_set_hdr_marks(HDR(h));\n+\t  GC_words_allocd += BYTES_TO_WORDS(HBLKSIZE)\n+\t\t\t       - BYTES_TO_WORDS(HBLKSIZE) % lw;\n+#\t  ifdef PARALLEL_MARK\n+\t    GC_acquire_mark_lock();\n+\t    ++ GC_fl_builder_count;\n+\t    UNLOCK();\n+\t    ENABLE_SIGNALS();\n+\t    GC_release_mark_lock();\n+#\t  endif\n+\n+\t  op = GC_build_fl(h, lw, ok -> ok_init, 0);\n+#\t  ifdef PARALLEL_MARK\n+\t    GC_acquire_mark_lock();\n+\t    -- GC_fl_builder_count;\n+\t    if (GC_fl_builder_count == 0) GC_notify_all_builder();\n+\t    GC_release_mark_lock();\n+\t    return GC_clear_stack(op);\n+#\t  else\n+\t    goto out;\n+#\t  endif\n+\t}\n     }\n-    GC_words_allocd += my_words_allocd;\n     \n-out:\n+    /* As a last attempt, try allocating a single object.  Note that\t*/\n+    /* this may trigger a collection or expand the heap.\t\t*/\n+      op = GC_generic_malloc_inner(lb, k);\n+      if (0 != op) obj_link(op) = 0;\n+    \n+  out:\n     UNLOCK();\n     ENABLE_SIGNALS();\n-    return(op);\n-\n+    return(GC_clear_stack(op));\n }\n \n-void * GC_malloc_many(size_t lb)\n+GC_PTR GC_malloc_many(size_t lb)\n {\n     return(GC_generic_malloc_many(lb, NORMAL));\n }\n@@ -272,11 +510,9 @@ DCL_LOCK_STATE;\n \n     if( SMALL_OBJ(lb) ) {\n #       ifdef MERGE_SIZES\n-#\t  ifdef ADD_BYTE_AT_END\n-\t    if (lb != 0) lb--;\n+\t  if (EXTRA_BYTES != 0 && lb != 0) lb--;\n \t    \t  /* We don't need the extra byte, since this won't be\t*/\n \t    \t  /* collected anyway.\t\t\t\t\t*/\n-#\t  endif\n \t  lw = GC_size_map[lb];\n #\telse\n \t  lw = ALIGNED_WORDS(lb);\n@@ -338,11 +574,9 @@ DCL_LOCK_STATE;\n \n     if( SMALL_OBJ(lb) ) {\n #       ifdef MERGE_SIZES\n-#\t  ifdef ADD_BYTE_AT_END\n-\t    if (lb != 0) lb--;\n+\t  if (EXTRA_BYTES != 0 && lb != 0) lb--;\n \t    \t  /* We don't need the extra byte, since this won't be\t*/\n \t    \t  /* collected anyway.\t\t\t\t\t*/\n-#\t  endif\n \t  lw = GC_size_map[lb];\n #\telse\n \t  lw = ALIGNED_WORDS(lb);"}, {"sha": "18b5749c351cc04b42aadc51f121241fba580041", "filename": "boehm-gc/mark.c", "status": "modified", "additions": 560, "deletions": 142, "changes": 702, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9110a741e35c54e46c00662ddc420575376c5947/boehm-gc%2Fmark.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9110a741e35c54e46c00662ddc420575376c5947/boehm-gc%2Fmark.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fmark.c?ref=9110a741e35c54e46c00662ddc420575376c5947", "patch": "@@ -2,6 +2,7 @@\n /*\n  * Copyright 1988, 1989 Hans-J. Boehm, Alan J. Demers\n  * Copyright (c) 1991-1995 by Xerox Corporation.  All rights reserved.\n+ * Copyright (c) 2000 by Hewlett-Packard Company.  All rights reserved.\n  *\n  * THIS MATERIAL IS PROVIDED AS IS, WITH ABSOLUTELY NO WARRANTY EXPRESSED\n  * OR IMPLIED.  ANY USE IS AT YOUR OWN RISK.\n@@ -16,8 +17,7 @@\n \n \n # include <stdio.h>\n-# include \"gc_priv.h\"\n-# include \"gc_mark.h\"\n+# include \"private/gc_pmark.h\"\n \n /* We put this here to minimize the risk of inlining. */\n /*VARARGS*/\n@@ -46,25 +46,21 @@ word GC_n_mark_procs = GC_RESERVED_MARK_PROCS;\n /* It's done here, since we need to deal with mark descriptors.\t\t*/\n struct obj_kind GC_obj_kinds[MAXOBJKINDS] = {\n /* PTRFREE */ { &GC_aobjfreelist[0], 0 /* filled in dynamically */,\n-\t\t0 | DS_LENGTH, FALSE, FALSE },\n+\t\t0 | GC_DS_LENGTH, FALSE, FALSE },\n /* NORMAL  */ { &GC_objfreelist[0], 0,\n-#\t\tif defined(ADD_BYTE_AT_END) && ALIGNMENT > DS_TAGS\n-\t\t(word)(-ALIGNMENT) | DS_LENGTH,\n-#\t\telse\n-\t\t0 | DS_LENGTH,\n-#\t\tendif\n+\t\t0 | GC_DS_LENGTH,  /* Adjusted in GC_init_inner for EXTRA_BYTES */\n \t\tTRUE /* add length to descr */, TRUE },\n /* UNCOLLECTABLE */\n \t      { &GC_uobjfreelist[0], 0,\n-\t\t0 | DS_LENGTH, TRUE /* add length to descr */, TRUE },\n+\t\t0 | GC_DS_LENGTH, TRUE /* add length to descr */, TRUE },\n # ifdef ATOMIC_UNCOLLECTABLE\n    /* AUNCOLLECTABLE */\n \t      { &GC_auobjfreelist[0], 0,\n-\t\t0 | DS_LENGTH, FALSE /* add length to descr */, FALSE },\n+\t\t0 | GC_DS_LENGTH, FALSE /* add length to descr */, FALSE },\n # endif\n # ifdef STUBBORN_ALLOC\n /*STUBBORN*/ { &GC_sobjfreelist[0], 0,\n-\t\t0 | DS_LENGTH, TRUE /* add length to descr */, TRUE },\n+\t\t0 | GC_DS_LENGTH, TRUE /* add length to descr */, TRUE },\n # endif\n };\n \n@@ -104,9 +100,15 @@ word GC_n_rescuing_pages;\t/* Number of dirty pages we marked from */\n \n mse * GC_mark_stack;\n \n+mse * GC_mark_stack_limit;\n+\n word GC_mark_stack_size = 0;\n  \n-mse * GC_mark_stack_top;\n+#ifdef PARALLEL_MARK\n+  mse * VOLATILE GC_mark_stack_top;\n+#else\n+  mse * GC_mark_stack_top;\n+#endif\n \n static struct hblk * scan_ptr;\n \n@@ -129,7 +131,11 @@ GC_bool GC_collection_in_progress()\n void GC_clear_hdr_marks(hhdr)\n register hdr * hhdr;\n {\n-    BZERO(hhdr -> hb_marks, MARK_BITS_SZ*sizeof(word));\n+#   ifdef USE_MARK_BYTES\n+      BZERO(hhdr -> hb_marks, MARK_BITS_SZ);\n+#   else\n+      BZERO(hhdr -> hb_marks, MARK_BITS_SZ*sizeof(word));\n+#   endif\n }\n \n /* Set all mark bits in the header.  Used for uncollectable blocks. */\n@@ -139,17 +145,25 @@ register hdr * hhdr;\n     register int i;\n \n     for (i = 0; i < MARK_BITS_SZ; ++i) {\n+#     ifdef USE_MARK_BYTES\n+    \thhdr -> hb_marks[i] = 1;\n+#     else\n     \thhdr -> hb_marks[i] = ONES;\n+#     endif\n     }\n }\n \n /*\n  * Clear all mark bits associated with block h.\n  */\n /*ARGSUSED*/\n-static void clear_marks_for_block(h, dummy)\n-struct hblk *h;\n-word dummy;\n+# if defined(__STDC__) || defined(__cplusplus)\n+    static void clear_marks_for_block(struct hblk *h, word dummy)\n+# else\n+    static void clear_marks_for_block(h, dummy)\n+    struct hblk *h;\n+    word dummy;\n+# endif\n {\n     register hdr * hhdr = HDR(h);\n     \n@@ -227,9 +241,7 @@ void GC_initiate_gc()\n \t    if (GC_dirty_maintained) GC_check_dirty();\n \t}\n #   endif\n-#   ifdef GATHERSTATS\n-\tGC_n_rescuing_pages = 0;\n-#   endif\n+    GC_n_rescuing_pages = 0;\n     if (GC_mark_state == MS_NONE) {\n         GC_mark_state = MS_PUSH_RESCUERS;\n     } else if (GC_mark_state != MS_INVALID) {\n@@ -269,20 +281,21 @@ ptr_t cold_gc_frame;\n     \t    \n     \tcase MS_PUSH_RESCUERS:\n     \t    if (GC_mark_stack_top\n-    \t        >= GC_mark_stack + GC_mark_stack_size\n-\t\t   - INITIAL_MARK_STACK_SIZE/2) {\n+    \t        >= GC_mark_stack_limit - INITIAL_MARK_STACK_SIZE/2) {\n \t\t/* Go ahead and mark, even though that might cause us to */\n \t\t/* see more marked dirty objects later on.  Avoid this\t */\n \t\t/* in the future.\t\t\t\t\t */\n \t\tGC_mark_stack_too_small = TRUE;\n-    \t        GC_mark_from_mark_stack();\n+    \t        MARK_FROM_MARK_STACK();\n     \t        return(FALSE);\n     \t    } else {\n     \t        scan_ptr = GC_push_next_marked_dirty(scan_ptr);\n     \t        if (scan_ptr == 0) {\n-#\t\t    ifdef PRINTSTATS\n+#\t\t    ifdef CONDPRINT\n+\t\t      if (GC_print_stats) {\n \t\t\tGC_printf1(\"Marked from %lu dirty pages\\n\",\n \t\t\t\t   (unsigned long)GC_n_rescuing_pages);\n+\t\t      }\n #\t\t    endif\n     \t    \t    GC_push_roots(FALSE, cold_gc_frame);\n     \t    \t    GC_objects_are_marked = TRUE;\n@@ -295,8 +308,13 @@ ptr_t cold_gc_frame;\n     \t\n     \tcase MS_PUSH_UNCOLLECTABLE:\n     \t    if (GC_mark_stack_top\n-    \t        >= GC_mark_stack + INITIAL_MARK_STACK_SIZE/4) {\n-    \t        GC_mark_from_mark_stack();\n+    \t        >= GC_mark_stack + GC_mark_stack_size/4) {\n+#\t\tifdef PARALLEL_MARK\n+\t\t  /* Avoid this, since we don't parallelize the marker\t*/\n+\t\t  /* here.\t\t\t\t\t\t*/\n+\t\t  if (GC_parallel) GC_mark_stack_too_small = TRUE;\n+#\t\tendif\n+    \t        MARK_FROM_MARK_STACK();\n     \t        return(FALSE);\n     \t    } else {\n     \t        scan_ptr = GC_push_next_marked_uncollectable(scan_ptr);\n@@ -311,8 +329,32 @@ ptr_t cold_gc_frame;\n     \t    return(FALSE);\n     \t\n     \tcase MS_ROOTS_PUSHED:\n+#\t    ifdef PARALLEL_MARK\n+\t      /* In the incremental GC case, this currently doesn't\t*/\n+\t      /* quite do the right thing, since it runs to\t\t*/\n+\t      /* completion.  On the other hand, starting a\t\t*/\n+\t      /* parallel marker is expensive, so perhaps it is\t\t*/\n+\t      /* the right thing?\t\t\t\t\t*/\n+\t      /* Eventually, incremental marking should run\t\t*/\n+\t      /* asynchronously in multiple threads, without grabbing\t*/\n+\t      /* the allocation lock.\t\t\t\t\t*/\n+\t        if (GC_parallel) {\n+\t\t  GC_do_parallel_mark();\n+\t\t  GC_ASSERT(GC_mark_stack_top < GC_first_nonempty);\n+\t\t  GC_mark_stack_top = GC_mark_stack - 1;\n+    \t          if (GC_mark_stack_too_small) {\n+    \t            alloc_mark_stack(2*GC_mark_stack_size);\n+    \t          }\n+\t\t  if (GC_mark_state == MS_ROOTS_PUSHED) {\n+    \t            GC_mark_state = MS_NONE;\n+    \t            return(TRUE);\n+\t\t  } else {\n+\t\t    return(FALSE);\n+\t          }\n+\t\t}\n+#\t    endif\n     \t    if (GC_mark_stack_top >= GC_mark_stack) {\n-    \t        GC_mark_from_mark_stack();\n+    \t        MARK_FROM_MARK_STACK();\n     \t        return(FALSE);\n     \t    } else {\n     \t        GC_mark_state = MS_NONE;\n@@ -329,7 +371,7 @@ ptr_t cold_gc_frame;\n \t\treturn(FALSE);\n \t    }\n     \t    if (GC_mark_stack_top >= GC_mark_stack) {\n-    \t        GC_mark_from_mark_stack();\n+    \t        MARK_FROM_MARK_STACK();\n     \t        return(FALSE);\n     \t    }\n     \t    if (scan_ptr == 0 && GC_mark_state == MS_INVALID) {\n@@ -356,10 +398,12 @@ ptr_t cold_gc_frame;\n #ifdef MSWIN32\n   } __except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?\n \t    EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) {\n-#   ifdef PRINTSTATS\n+#   ifdef CONDPRINT\n+      if (GC_print_stats) {\n \tGC_printf0(\"Caught ACCESS_VIOLATION in marker. \"\n \t\t   \"Memory mapping disappeared.\\n\");\n-#   endif /* PRINTSTATS */\n+      }\n+#   endif /* CONDPRINT */\n     /* We have bad roots on the stack.  Discard mark stack.  \t*/\n     /* Rescan from marked objects.  Redetermine roots.\t\t*/\n     GC_invalidate_mark_state();\t\n@@ -399,11 +443,11 @@ GC_bool GC_mark_stack_empty()\n register ptr_t current;\n register hdr * hhdr;\n {\n-#   ifdef ALL_INTERIOR_POINTERS\n+    if (GC_all_interior_pointers) {\n \tif (hhdr != 0) {\n \t    register ptr_t orig = current;\n \t    \n-\t    current = (ptr_t)HBLKPTR(current) + HDR_BYTES;\n+\t    current = (ptr_t)HBLKPTR(current);\n \t    do {\n \t      current = current - HBLKSIZE*(word)hhdr;\n \t      hhdr = HDR(current);\n@@ -413,18 +457,18 @@ register hdr * hhdr;\n \t    if ((word *)orig - (word *)current\n \t         >= (ptrdiff_t)(hhdr->hb_sz)) {\n \t        /* Pointer past the end of the block */\n-\t        GC_ADD_TO_BLACK_LIST_NORMAL(orig, source);\n+\t        GC_ADD_TO_BLACK_LIST_NORMAL((word)orig, source);\n \t        return(0);\n \t    }\n \t    return(current);\n \t} else {\n-\t    GC_ADD_TO_BLACK_LIST_NORMAL(current, source);\n+\t    GC_ADD_TO_BLACK_LIST_NORMAL((word)current, source);\n \t    return(0);\n         }\n-#   else\n-        GC_ADD_TO_BLACK_LIST_NORMAL(current, source);\n+    } else {\n+        GC_ADD_TO_BLACK_LIST_NORMAL((word)current, source);\n         return(0);\n-#   endif\n+    }\n #   undef source\n }\n \n@@ -439,14 +483,15 @@ mse * msp;\n {\n     GC_mark_state = MS_INVALID;\n     GC_mark_stack_too_small = TRUE;\n-#   ifdef PRINTSTATS\n+#   ifdef CONDPRINT\n+      if (GC_print_stats) {\n \tGC_printf1(\"Mark stack overflow; current size = %lu entries\\n\",\n \t    \t    GC_mark_stack_size);\n-#    endif\n-     return(msp-INITIAL_MARK_STACK_SIZE/8);\n+      }\n+#   endif\n+    return(msp - GC_MARK_STACK_DISCARDS);\n }\n \n-\n /*\n  * Mark objects pointed to by the regions described by\n  * mark stack entries between GC_mark_stack and GC_mark_stack_top,\n@@ -461,11 +506,11 @@ mse * msp;\n  * encoding, we optionally maintain a cache for the block address to\n  * header mapping, we prefetch when an object is \"grayed\", etc. \n  */\n-void GC_mark_from_mark_stack()\n+mse * GC_mark_from(mark_stack_top, mark_stack, mark_stack_limit)\n+mse * mark_stack_top;\n+mse * mark_stack;\n+mse * mark_stack_limit;\n {\n-  mse * GC_mark_stack_reg = GC_mark_stack;\n-  mse * GC_mark_stack_top_reg = GC_mark_stack_top;\n-  mse * mark_stack_limit = &(GC_mark_stack[GC_mark_stack_size]);\n   int credit = HBLKSIZE;\t/* Remaining credit for marking work\t*/\n   register word * current_p;\t/* Pointer to current candidate ptr.\t*/\n   register word current;\t/* Candidate pointer.\t\t\t*/\n@@ -481,64 +526,81 @@ void GC_mark_from_mark_stack()\n   GC_objects_are_marked = TRUE;\n   INIT_HDR_CACHE;\n # ifdef OS2 /* Use untweaked version to circumvent compiler problem */\n-  while (GC_mark_stack_top_reg >= GC_mark_stack_reg && credit >= 0) {\n+  while (mark_stack_top >= mark_stack && credit >= 0) {\n # else\n-  while ((((ptr_t)GC_mark_stack_top_reg - (ptr_t)GC_mark_stack_reg) | credit)\n+  while ((((ptr_t)mark_stack_top - (ptr_t)mark_stack) | credit)\n   \t>= 0) {\n # endif\n-    current_p = GC_mark_stack_top_reg -> mse_start;\n-    descr = GC_mark_stack_top_reg -> mse_descr;\n+    current_p = mark_stack_top -> mse_start;\n+    descr = mark_stack_top -> mse_descr;\n   retry:\n     /* current_p and descr describe the current object.\t\t*/\n-    /* *GC_mark_stack_top_reg is vacant.\t\t\t*/\n+    /* *mark_stack_top is vacant.\t\t\t\t*/\n     /* The following is 0 only for small objects described by a simple\t*/\n     /* length descriptor.  For many applications this is the common\t*/\n     /* case, so we try to detect it quickly.\t\t\t\t*/\n-    if (descr & ((~(WORDS_TO_BYTES(SPLIT_RANGE_WORDS) - 1)) | DS_TAGS)) {\n-      word tag = descr & DS_TAGS;\n+    if (descr & ((~(WORDS_TO_BYTES(SPLIT_RANGE_WORDS) - 1)) | GC_DS_TAGS)) {\n+      word tag = descr & GC_DS_TAGS;\n       \n       switch(tag) {\n-        case DS_LENGTH:\n+        case GC_DS_LENGTH:\n           /* Large length.\t\t\t\t\t        */\n           /* Process part of the range to avoid pushing too much on the\t*/\n           /* stack.\t\t\t\t\t\t\t*/\n-          GC_mark_stack_top_reg -> mse_start =\n+#\t  ifdef PARALLEL_MARK\n+#\t    define SHARE_BYTES 2048\n+\t    if (descr > SHARE_BYTES && GC_parallel\n+\t\t&& mark_stack_top < mark_stack_limit - 1) {\n+\t      int new_size = (descr/2) & ~(sizeof(word)-1);\n+\t      GC_ASSERT(descr < GC_greatest_plausible_heap_addr\n+\t\t\t        - GC_least_plausible_heap_addr);\n+\t      mark_stack_top -> mse_start = current_p;\n+\t      mark_stack_top -> mse_descr = new_size + sizeof(word);\n+\t\t\t\t\t/* makes sure we handle \t*/\n+\t\t\t\t\t/* misaligned pointers.\t\t*/\n+\t      mark_stack_top++;\n+\t      current_p = (word *) ((char *)current_p + new_size);\n+\t      descr -= new_size;\n+\t      goto retry;\n+\t    }\n+#\t  endif /* PARALLEL_MARK */\n+          mark_stack_top -> mse_start =\n          \tlimit = current_p + SPLIT_RANGE_WORDS-1;\n-          GC_mark_stack_top_reg -> mse_descr =\n+          mark_stack_top -> mse_descr =\n           \t\tdescr - WORDS_TO_BYTES(SPLIT_RANGE_WORDS-1);\n           /* Make sure that pointers overlapping the two ranges are\t*/\n           /* considered. \t\t\t\t\t\t*/\n           limit = (word *)((char *)limit + sizeof(word) - ALIGNMENT);\n           break;\n-        case DS_BITMAP:\n-          GC_mark_stack_top_reg--;\n-          descr &= ~DS_TAGS;\n+        case GC_DS_BITMAP:\n+          mark_stack_top--;\n+          descr &= ~GC_DS_TAGS;\n           credit -= WORDS_TO_BYTES(WORDSZ/2); /* guess */\n           while (descr != 0) {\n             if ((signed_word)descr < 0) {\n               current = *current_p;\n \t      if ((ptr_t)current >= least_ha && (ptr_t)current < greatest_ha) {\n \t\tPREFETCH(current);\n-                HC_PUSH_CONTENTS((ptr_t)current, GC_mark_stack_top_reg,\n+                HC_PUSH_CONTENTS((ptr_t)current, mark_stack_top,\n \t\t\t      mark_stack_limit, current_p, exit1);\n \t      }\n             }\n \t    descr <<= 1;\n \t    ++ current_p;\n           }\n           continue;\n-        case DS_PROC:\n-          GC_mark_stack_top_reg--;\n-          credit -= PROC_BYTES;\n-          GC_mark_stack_top_reg =\n+        case GC_DS_PROC:\n+          mark_stack_top--;\n+          credit -= GC_PROC_BYTES;\n+          mark_stack_top =\n               (*PROC(descr))\n-              \t    (current_p, GC_mark_stack_top_reg,\n+              \t    (current_p, mark_stack_top,\n               \t    mark_stack_limit, ENV(descr));\n           continue;\n-        case DS_PER_OBJECT:\n+        case GC_DS_PER_OBJECT:\n \t  if ((signed_word)descr >= 0) {\n \t    /* Descriptor is in the object.\t*/\n-            descr = *(word *)((ptr_t)current_p + descr - DS_PER_OBJECT);\n+            descr = *(word *)((ptr_t)current_p + descr - GC_DS_PER_OBJECT);\n \t  } else {\n \t    /* Descriptor is in type descriptor pointed to by first\t*/\n \t    /* word in object.\t\t\t\t\t\t*/\n@@ -552,19 +614,27 @@ void GC_mark_from_mark_stack()\n \t    /* object case explicitly.\t\t\t\t\t*/\n \t    if (0 == type_descr) {\n \t\t/* Rarely executed.\t*/\n-\t\tGC_mark_stack_top_reg--;\n+\t\tmark_stack_top--;\n \t\tcontinue;\n \t    }\n             descr = *(word *)(type_descr\n-\t\t\t      - (descr - (DS_PER_OBJECT - INDIR_PER_OBJ_BIAS)));\n+\t\t\t      - (descr - (GC_DS_PER_OBJECT\n+\t\t\t\t\t  - GC_INDIR_PER_OBJ_BIAS)));\n+\t  }\n+\t  if (0 == descr) {\n+\t      /* Can happen either because we generated a 0 descriptor\t*/\n+\t      /* or we saw a pointer to a free object.\t\t\t*/\n+\t      mark_stack_top--;\n+\t      continue;\n \t  }\n           goto retry;\n       }\n     } else /* Small object with length descriptor */ {\n-      GC_mark_stack_top_reg--;\n+      mark_stack_top--;\n       limit = (word *)(((ptr_t)current_p) + (word)descr);\n     }\n     /* The simple case in which we're scanning a range.\t*/\n+    GC_ASSERT(!((word)current_p & (ALIGNMENT-1)));\n     credit -= (ptr_t)limit - (ptr_t)current_p;\n     limit -= 1;\n     {\n@@ -581,6 +651,7 @@ void GC_mark_from_mark_stack()\n \t/* for this loop is still not great.\t\t\t\t*/\n \tfor(;;) {\n \t  PREFETCH((ptr_t)limit - PREF_DIST*CACHE_LINE_SIZE);\n+\t  GC_ASSERT(limit >= current_p);\n \t  deferred = *limit;\n \t  limit = (word *)((char *)limit - ALIGNMENT);\n \t  if ((ptr_t)deferred >= least_ha && (ptr_t)deferred <  greatest_ha) {\n@@ -610,7 +681,7 @@ void GC_mark_from_mark_stack()\n   \t  /* Prefetch the contents of the object we just pushed.  It's\t*/\n   \t  /* likely we will need them soon.\t\t\t\t*/\n   \t  PREFETCH(current);\n-          HC_PUSH_CONTENTS((ptr_t)current, GC_mark_stack_top_reg,\n+          HC_PUSH_CONTENTS((ptr_t)current, mark_stack_top,\n   \t\t           mark_stack_limit, current_p, exit2);\n         }\n         current_p = (word *)((char *)current_p + ALIGNMENT);\n@@ -620,27 +691,337 @@ void GC_mark_from_mark_stack()\n \t/* We still need to mark the entry we previously prefetched.\t*/\n \t/* We alrady know that it passes the preliminary pointer\t*/\n \t/* validity test.\t\t\t\t\t\t*/\n-        HC_PUSH_CONTENTS((ptr_t)deferred, GC_mark_stack_top_reg,\n+        HC_PUSH_CONTENTS((ptr_t)deferred, mark_stack_top,\n   \t\t         mark_stack_limit, current_p, exit4);\n \tnext_object:;\n #     endif\n     }\n   }\n-  GC_mark_stack_top = GC_mark_stack_top_reg;\n+  return mark_stack_top;\n }\n \n+#ifdef PARALLEL_MARK\n+\n+/* We assume we have an ANSI C Compiler.\t*/\n+GC_bool GC_help_wanted = FALSE;\n+unsigned GC_helper_count = 0;\n+unsigned GC_active_count = 0;\n+mse * VOLATILE GC_first_nonempty;\n+word GC_mark_no = 0;\n+\n+#define LOCAL_MARK_STACK_SIZE HBLKSIZE\n+\t/* Under normal circumstances, this is big enough to guarantee\t*/\n+\t/* We don't overflow half of it in a single call to \t\t*/\n+\t/* GC_mark_from.\t\t\t\t\t\t*/\n+\n+\n+/* Steal mark stack entries starting at mse low into mark stack local\t*/\n+/* until we either steal mse high, or we have max entries.\t\t*/\n+/* Return a pointer to the top of the local mark stack.\t\t        */\n+/* *next is replaced by a pointer to the next unscanned mark stack\t*/\n+/* entry.\t\t\t\t\t\t\t\t*/\n+mse * GC_steal_mark_stack(mse * low, mse * high, mse * local,\n+\t\t\t  unsigned max, mse **next)\n+{\n+    mse *p;\n+    mse *top = local - 1;\n+    unsigned i = 0;\n+\n+    GC_ASSERT(high >= low-1 && high - low + 1 <= GC_mark_stack_size);\n+    for (p = low; p <= high && i <= max; ++p) {\n+\tword descr = *(volatile word *) &(p -> mse_descr);\n+\tif (descr != 0) {\n+\t    *(volatile word *) &(p -> mse_descr) = 0;\n+\t    ++top;\n+\t    top -> mse_descr = descr;\n+\t    top -> mse_start = p -> mse_start;\n+\t    GC_ASSERT(  top -> mse_descr & GC_DS_TAGS != GC_DS_LENGTH || \n+\t\t\ttop -> mse_descr < GC_greatest_plausible_heap_addr\n+\t\t\t                   - GC_least_plausible_heap_addr);\n+\t    /* There is no synchronization here.  We assume that at\t*/\n+\t    /* least one thread will see the original descriptor.\t*/\n+\t    /* Otherwise we need a barrier.\t\t\t\t*/\n+\t    /* More than one thread may get this entry, but that's only */\n+\t    /* a minor performance problem.\t\t\t\t*/\n+\t    /* If this is a big object, count it as\t\t\t*/\n+\t    /* size/256 + 1 objects.\t\t\t\t\t*/\n+\t    ++i;\n+\t    if ((descr & GC_DS_TAGS) == GC_DS_LENGTH) i += (descr >> 8);\n+\t}\n+    }\n+    *next = p;\n+    return top;\n+}\n+\n+/* Copy back a local mark stack.\t*/\n+/* low and high are inclusive bounds.\t*/\n+void GC_return_mark_stack(mse * low, mse * high)\n+{\n+    mse * my_top;\n+    mse * my_start;\n+    size_t stack_size;\n+\n+    if (high < low) return;\n+    stack_size = high - low + 1;\n+    GC_acquire_mark_lock();\n+    my_top = GC_mark_stack_top;\n+    my_start = my_top + 1;\n+    if (my_start - GC_mark_stack + stack_size > GC_mark_stack_size) {\n+#     ifdef CONDPRINT\n+\tif (GC_print_stats) {\n+\t  GC_printf0(\"No room to copy back mark stack.\");\n+\t}\n+#     endif\n+      GC_mark_state = MS_INVALID;\n+      GC_mark_stack_too_small = TRUE;\n+      /* We drop the local mark stack.  We'll fix things later.\t*/\n+    } else {\n+      BCOPY(low, my_start, stack_size * sizeof(mse));\n+      GC_ASSERT(GC_mark_stack_top = my_top);\n+#     if !defined(IA64) && !defined(HP_PA)\n+        GC_memory_write_barrier();\n+#     endif\n+\t/* On IA64, the volatile write acts as a release barrier. */\n+      GC_mark_stack_top = my_top + stack_size;\n+    }\n+    GC_release_mark_lock();\n+    GC_notify_all_marker();\n+}\n+\n+/* Mark from the local mark stack.\t\t*/\n+/* On return, the local mark stack is empty.\t*/\n+/* But this may be achieved by copying the\t*/\n+/* local mark stack back into the global one.\t*/\n+void GC_do_local_mark(mse *local_mark_stack, mse *local_top)\n+{\n+    unsigned n;\n+#   define N_LOCAL_ITERS 1\n+\n+#   ifdef GC_ASSERTIONS\n+      /* Make sure we don't hold mark lock. */\n+\tGC_acquire_mark_lock();\n+\tGC_release_mark_lock();\n+#   endif\n+    for (;;) {\n+        for (n = 0; n < N_LOCAL_ITERS; ++n) {\n+\t    local_top = GC_mark_from(local_top, local_mark_stack,\n+\t\t\t\t     local_mark_stack + LOCAL_MARK_STACK_SIZE);\n+\t    if (local_top < local_mark_stack) return;\n+\t    if (local_top - local_mark_stack >= LOCAL_MARK_STACK_SIZE/2) {\n+\t \tGC_return_mark_stack(local_mark_stack, local_top);\n+\t\treturn;\n+\t    }\n+\t}\n+\tif (GC_mark_stack_top < GC_first_nonempty &&\n+\t    GC_active_count < GC_helper_count\n+\t    && local_top > local_mark_stack + 1) {\n+\t    /* Try to share the load, since the main stack is empty,\t*/\n+\t    /* and helper threads are waiting for a refill.\t\t*/\n+\t    /* The entries near the bottom of the stack are likely\t*/\n+\t    /* to require more work.  Thus we return those, eventhough\t*/\n+\t    /* it's harder.\t\t\t\t\t\t*/\n+\t    mse * p;\n+ \t    mse * new_bottom = local_mark_stack\n+\t\t\t\t+ (local_top - local_mark_stack)/2;\n+\t    GC_ASSERT(new_bottom > local_mark_stack\n+\t\t      && new_bottom < local_top);\n+\t    GC_return_mark_stack(local_mark_stack, new_bottom - 1);\n+\t    memmove(local_mark_stack, new_bottom,\n+\t\t    (local_top - new_bottom + 1) * sizeof(mse));\n+\t    local_top -= (new_bottom - local_mark_stack);\n+\t}\n+    }\n+}\n+\n+#define ENTRIES_TO_GET 5\n+\n+long GC_markers = 2;\t\t/* Normally changed by thread-library-\t*/\n+\t\t\t\t/* -specific code.\t\t\t*/\n+\n+/* Mark using the local mark stack until the global mark stack is empty\t*/\n+/* and ther are no active workers.  Update GC_first_nonempty to reflect\t*/\n+/* progress.\t\t\t\t\t\t\t\t*/\n+/* Caller does not hold mark lock.\t\t\t\t\t*/\n+/* Caller has already incremented GC_helper_count.  We decrement it,\t*/\n+/* and maintain GC_active_count.\t\t\t\t\t*/\n+void GC_mark_local(mse *local_mark_stack, int id)\n+{\n+    mse * my_first_nonempty;\n+\n+    GC_acquire_mark_lock();\n+    GC_active_count++;\n+    my_first_nonempty = GC_first_nonempty;\n+    GC_ASSERT(GC_first_nonempty >= GC_mark_stack && \n+\t      GC_first_nonempty <= GC_mark_stack_top + 1);\n+#   ifdef PRINTSTATS\n+\tGC_printf1(\"Starting mark helper %lu\\n\", (unsigned long)id);\n+#   endif\n+    GC_release_mark_lock();\n+    for (;;) {\n+  \tsize_t n_on_stack;\n+        size_t n_to_get;\n+\tmse *next;\n+\tmse * my_top;\n+\tmse * local_top;\n+        mse * global_first_nonempty = GC_first_nonempty;\n+\n+    \tGC_ASSERT(my_first_nonempty >= GC_mark_stack && \n+\t\t  my_first_nonempty <= GC_mark_stack_top + 1);\n+    \tGC_ASSERT(global_first_nonempty >= GC_mark_stack && \n+\t\t  global_first_nonempty <= GC_mark_stack_top + 1);\n+\tif (my_first_nonempty < global_first_nonempty) {\n+\t    my_first_nonempty = global_first_nonempty;\n+        } else if (global_first_nonempty < my_first_nonempty) {\n+\t    GC_compare_and_exchange((word *)(&GC_first_nonempty), \n+\t\t\t\t   (word) global_first_nonempty,\n+\t\t\t\t   (word) my_first_nonempty);\n+\t    /* If this fails, we just go ahead, without updating\t*/\n+\t    /* GC_first_nonempty.\t\t\t\t\t*/\n+\t}\n+\t/* Perhaps we should also update GC_first_nonempty, if it */\n+\t/* is less.  But that would require using atomic updates. */\n+\tmy_top = GC_mark_stack_top;\n+\tn_on_stack = my_top - my_first_nonempty + 1;\n+        if (0 == n_on_stack) {\n+\t    GC_acquire_mark_lock();\n+            my_top = GC_mark_stack_top;\n+            n_on_stack = my_top - my_first_nonempty + 1;\n+\t    if (0 == n_on_stack) {\n+\t\tGC_active_count--;\n+\t\tGC_ASSERT(GC_active_count <= GC_helper_count);\n+\t\t/* Other markers may redeposit objects\t*/\n+\t\t/* on the stack.\t\t\t\t*/\n+\t\tif (0 == GC_active_count) GC_notify_all_marker();\n+\t\twhile (GC_active_count > 0\n+\t\t       && GC_first_nonempty > GC_mark_stack_top) {\n+\t\t    /* We will be notified if either GC_active_count\t*/\n+\t\t    /* reaches zero, or if more objects are pushed on\t*/\n+\t\t    /* the global mark stack.\t\t\t\t*/\n+\t\t    GC_wait_marker();\n+\t\t}\n+\t\tif (GC_active_count == 0 &&\n+\t\t    GC_first_nonempty > GC_mark_stack_top) { \n+\t\t    GC_bool need_to_notify = FALSE;\n+\t\t    /* The above conditions can't be falsified while we\t*/\n+\t\t    /* hold the mark lock, since neither \t\t*/\n+\t\t    /* GC_active_count nor GC_mark_stack_top can\t*/\n+\t\t    /* change.  GC_first_nonempty can only be\t\t*/\n+\t\t    /* incremented asynchronously.  Thus we know that\t*/\n+\t\t    /* both conditions actually held simultaneously.\t*/\n+\t\t    GC_helper_count--;\n+\t\t    if (0 == GC_helper_count) need_to_notify = TRUE;\n+#\t\t    ifdef PRINTSTATS\n+\t\t      GC_printf1(\n+\t\t        \"Finished mark helper %lu\\n\", (unsigned long)id);\n+#   \t\t    endif\n+\t\t    GC_release_mark_lock();\n+\t\t    if (need_to_notify) GC_notify_all_marker();\n+\t\t    return;\n+\t\t}\n+\t\t/* else there's something on the stack again, or\t*/\n+\t\t/* another help may push something.\t\t\t*/\n+\t\tGC_active_count++;\n+\t        GC_ASSERT(GC_active_count > 0);\n+\t\tGC_release_mark_lock();\n+\t\tcontinue;\n+\t    } else {\n+\t\tGC_release_mark_lock();\n+\t    }\n+\t}\n+\tn_to_get = ENTRIES_TO_GET;\n+\tif (n_on_stack < 2 * ENTRIES_TO_GET) n_to_get = 1;\n+\tlocal_top = GC_steal_mark_stack(my_first_nonempty, my_top,\n+\t\t\t\t\tlocal_mark_stack, n_to_get,\n+\t\t\t\t        &my_first_nonempty);\n+        GC_ASSERT(my_first_nonempty >= GC_mark_stack && \n+\t          my_first_nonempty <= GC_mark_stack_top + 1);\n+\tGC_do_local_mark(local_mark_stack, local_top);\n+    }\n+}\n+\n+/* Perform Parallel mark.\t\t\t*/\n+/* We hold the GC lock, not the mark lock.\t*/\n+/* Currently runs until the mark stack is\t*/\n+/* empty.\t\t\t\t\t*/\n+void GC_do_parallel_mark()\n+{\n+    mse local_mark_stack[LOCAL_MARK_STACK_SIZE];\n+    mse * local_top;\n+    mse * my_top;\n+\n+    GC_acquire_mark_lock();\n+    GC_ASSERT(I_HOLD_LOCK());\n+    GC_ASSERT(!GC_help_wanted);\n+    GC_ASSERT(GC_active_count == 0);\n+#   ifdef PRINTSTATS\n+\tGC_printf1(\"Starting marking for mark phase number %lu\\n\",\n+\t\t   (unsigned long)GC_mark_no);\n+#   endif\n+    GC_first_nonempty = GC_mark_stack;\n+    GC_active_count = 0;\n+    GC_helper_count = 1;\n+    GC_help_wanted = TRUE;\n+    GC_release_mark_lock();\n+    GC_notify_all_marker();\n+\t/* Wake up potential helpers.\t*/\n+    GC_mark_local(local_mark_stack, 0);\n+    GC_acquire_mark_lock();\n+    GC_help_wanted = FALSE;\n+    /* Done; clean up.\t*/\n+    while (GC_helper_count > 0) GC_wait_marker();\n+    /* GC_helper_count cannot be incremented while GC_help_wanted == FALSE */\n+#   ifdef PRINTSTATS\n+\tGC_printf1(\n+\t    \"Finished marking for mark phase number %lu\\n\",\n+\t    (unsigned long)GC_mark_no);\n+#   endif\n+    GC_mark_no++;\n+    GC_release_mark_lock();\n+    GC_notify_all_marker();\n+}\n+\n+\n+/* Try to help out the marker, if it's running.\t        */\n+/* We do not hold the GC lock, but the requestor does.\t*/\n+void GC_help_marker(word my_mark_no)\n+{\n+    mse local_mark_stack[LOCAL_MARK_STACK_SIZE];\n+    unsigned my_id;\n+    mse * my_first_nonempty;\n+\n+    if (!GC_parallel) return;\n+    GC_acquire_mark_lock();\n+    while (GC_mark_no < my_mark_no\n+           || !GC_help_wanted && GC_mark_no == my_mark_no) {\n+      GC_wait_marker();\n+    }\n+    my_id = GC_helper_count;\n+    if (GC_mark_no != my_mark_no || my_id >= GC_markers) {\n+      /* Second test is useful only if original threads can also\t*/\n+      /* act as helpers.  Under Linux they can't.\t\t\t*/\n+      GC_release_mark_lock();\n+      return;\n+    }\n+    GC_helper_count = my_id + 1;\n+    GC_release_mark_lock();\n+    GC_mark_local(local_mark_stack, my_id);\n+    /* GC_mark_local decrements GC_helper_count. */\n+}\n+\n+#endif /* PARALLEL_MARK */\n+\n /* Allocate or reallocate space for mark stack of size s words  */\n /* May silently fail.\t\t\t\t\t\t*/\n static void alloc_mark_stack(n)\n word n;\n {\n-    mse * new_stack = (mse *)GC_scratch_alloc(n * sizeof(struct ms_entry));\n+    mse * new_stack = (mse *)GC_scratch_alloc(n * sizeof(struct GC_ms_entry));\n     \n     GC_mark_stack_too_small = FALSE;\n     if (GC_mark_stack_size != 0) {\n         if (new_stack != 0) {\n           word displ = (word)GC_mark_stack & (GC_page_size - 1);\n-          signed_word size = GC_mark_stack_size * sizeof(struct ms_entry);\n+          signed_word size = GC_mark_stack_size * sizeof(struct GC_ms_entry);\n           \n           /* Recycle old space */\n \t      if (0 != displ) displ = GC_page_size - displ;\n@@ -651,14 +1032,19 @@ word n;\n \t      }\n           GC_mark_stack = new_stack;\n           GC_mark_stack_size = n;\n-#\t  ifdef PRINTSTATS\n+\t  GC_mark_stack_limit = new_stack + n;\n+#\t  ifdef CONDPRINT\n+\t    if (GC_print_stats) {\n \t      GC_printf1(\"Grew mark stack to %lu frames\\n\",\n \t\t    \t (unsigned long) GC_mark_stack_size);\n+\t    }\n #\t  endif\n         } else {\n-#\t  ifdef PRINTSTATS\n+#\t  ifdef CONDPRINT\n+\t    if (GC_print_stats) {\n \t      GC_printf1(\"Failed to grow mark stack to %lu frames\\n\",\n \t\t    \t (unsigned long) n);\n+\t    }\n #\t  endif\n         }\n     } else {\n@@ -668,6 +1054,7 @@ word n;\n         }\n         GC_mark_stack = new_stack;\n         GC_mark_stack_size = n;\n+\tGC_mark_stack_limit = new_stack + n;\n     }\n     GC_mark_stack_top = GC_mark_stack-1;\n }\n@@ -694,32 +1081,33 @@ ptr_t top;\n     top = (ptr_t)(((word) top) & ~(ALIGNMENT-1));\n     if (top == 0 || bottom == top) return;\n     GC_mark_stack_top++;\n-    if (GC_mark_stack_top >= GC_mark_stack + GC_mark_stack_size) {\n+    if (GC_mark_stack_top >= GC_mark_stack_limit) {\n \tABORT(\"unexpected mark stack overflow\");\n     }\n     length = top - bottom;\n-#   if DS_TAGS > ALIGNMENT - 1\n-\tlength += DS_TAGS;\n-\tlength &= ~DS_TAGS;\n+#   if GC_DS_TAGS > ALIGNMENT - 1\n+\tlength += GC_DS_TAGS;\n+\tlength &= ~GC_DS_TAGS;\n #   endif\n     GC_mark_stack_top -> mse_start = (word *)bottom;\n     GC_mark_stack_top -> mse_descr = length;\n }\n \n /*\n- * Analogous to the above, but push only those pages that may have been\n- * dirtied.  A block h is assumed dirty if dirty_fn(h) != 0.\n+ * Analogous to the above, but push only those pages h with dirty_fn(h) != 0.\n  * We use push_fn to actually push the block.\n+ * Used both to selectively push dirty pages, or to push a block\n+ * in piecemeal fashion, to allow for more marking concurrency.\n  * Will not overflow mark stack if push_fn pushes a small fixed number\n  * of entries.  (This is invoked only if push_fn pushes a single entry,\n  * or if it marks each object before pushing it, thus ensuring progress\n  * in the event of a stack overflow.)\n  */\n-void GC_push_dirty(bottom, top, dirty_fn, push_fn)\n+void GC_push_selected(bottom, top, dirty_fn, push_fn)\n ptr_t bottom;\n ptr_t top;\n-int (*dirty_fn)(/* struct hblk * h */);\n-void (*push_fn)(/* ptr_t bottom, ptr_t top */);\n+int (*dirty_fn) GC_PROTO((struct hblk * h));\n+void (*push_fn) GC_PROTO((ptr_t bottom, ptr_t top));\n {\n     register struct hblk * h;\n \n@@ -755,12 +1143,23 @@ void (*push_fn)(/* ptr_t bottom, ptr_t top */);\n             (*push_fn)((ptr_t)h, top);\n         }\n     }\n-    if (GC_mark_stack_top >= GC_mark_stack + GC_mark_stack_size) {\n+    if (GC_mark_stack_top >= GC_mark_stack_limit) {\n         ABORT(\"unexpected mark stack overflow\");\n     }\n }\n \n # ifndef SMALL_CONFIG\n+\n+#ifdef PARALLEL_MARK\n+    /* Break up root sections into page size chunks to better spread \t*/\n+    /* out work.\t\t\t\t\t\t\t*/\n+    GC_bool GC_true_func(struct hblk *h) { return TRUE; }\n+#   define GC_PUSH_ALL(b,t) GC_push_selected(b,t,GC_true_func,GC_push_all);\n+#else\n+#   define GC_PUSH_ALL(b,t) GC_push_all(b,t);\n+#endif\n+\n+\n void GC_push_conditional(bottom, top, all)\n ptr_t bottom;\n ptr_t top;\n@@ -770,83 +1169,88 @@ int all;\n       if (GC_dirty_maintained) {\n #\tifdef PROC_VDB\n \t    /* Pages that were never dirtied cannot contain pointers\t*/\n-\t    GC_push_dirty(bottom, top, GC_page_was_ever_dirty, GC_push_all);\n+\t    GC_push_selected(bottom, top, GC_page_was_ever_dirty, GC_push_all);\n #\telse\n \t    GC_push_all(bottom, top);\n #\tendif\n       } else {\n       \tGC_push_all(bottom, top);\n       }\n     } else {\n-\tGC_push_dirty(bottom, top, GC_page_was_dirty, GC_push_all);\n+\tGC_push_selected(bottom, top, GC_page_was_dirty, GC_push_all);\n     }\n }\n #endif\n \n-# ifdef MSWIN32\n+# if defined(MSWIN32) || defined(MSWINCE)\n   void __cdecl GC_push_one(p)\n # else\n   void GC_push_one(p)\n # endif\n word p;\n {\n-#   ifdef NURSERY\n-      if (0 != GC_push_proc) {\n-\tGC_push_proc(p);\n-\treturn;\n-      }\n-#   endif\n     GC_PUSH_ONE_STACK(p, MARKED_FROM_REGISTER);\n }\n \n+struct GC_ms_entry *GC_mark_and_push(obj, mark_stack_ptr, mark_stack_limit, src)\n+GC_PTR obj;\n+struct GC_ms_entry * mark_stack_ptr;\n+struct GC_ms_entry * mark_stack_limit;\n+GC_PTR *src;\n+{\n+   PREFETCH(obj);\n+   PUSH_CONTENTS(obj, mark_stack_ptr /* modified */, mark_stack_limit, src,\n+\t\t was_marked /* internally generated exit label */);\n+   return mark_stack_ptr;\n+}\n+\n # ifdef __STDC__\n #   define BASE(p) (word)GC_base((void *)(p))\n # else\n #   define BASE(p) (word)GC_base((char *)(p))\n # endif\n \n-/* As above, but argument passed preliminary test. */\n+/* Mark and push (i.e. gray) a single object p onto the main\t*/\n+/* mark stack.  Consider p to be valid if it is an interior\t*/\n+/* pointer.\t\t\t\t\t\t\t*/\n+/* The object p has passed a preliminary pointer validity\t*/\n+/* test, but we do not definitely know whether it is valid.\t*/\n+/* Mark bits are NOT atomically updated.  Thus this must be the\t*/\n+/* only thread setting them.\t\t\t\t\t*/\n # if defined(PRINT_BLACK_LIST) || defined(KEEP_BACK_PTRS)\n-    void GC_push_one_checked(p, interior_ptrs, source)\n+    void GC_mark_and_push_stack(p, source)\n     ptr_t source;\n # else\n-    void GC_push_one_checked(p, interior_ptrs)\n+    void GC_mark_and_push_stack(p)\n #   define source 0\n # endif\n register word p;\n-register GC_bool interior_ptrs;\n {\n     register word r;\n     register hdr * hhdr; \n     register int displ;\n   \n     GET_HDR(p, hhdr);\n     if (IS_FORWARDING_ADDR_OR_NIL(hhdr)) {\n-        if (hhdr != 0 && interior_ptrs) {\n+        if (hhdr != 0) {\n           r = BASE(p);\n \t  hhdr = HDR(r);\n \t  displ = BYTES_TO_WORDS(HBLKDISPL(r));\n-\t} else {\n-\t  hhdr = 0;\n \t}\n     } else {\n         register map_entry_type map_entry;\n         \n         displ = HBLKDISPL(p);\n         map_entry = MAP_ENTRY((hhdr -> hb_map), displ);\n-        if (map_entry == OBJ_INVALID) {\n-#\t  ifndef ALL_INTERIOR_POINTERS\n-            if (interior_ptrs) {\n+        if (map_entry >= MAX_OFFSET) {\n+          if (map_entry == OFFSET_TOO_BIG || !GC_all_interior_pointers) {\n               r = BASE(p);\n \t      displ = BYTES_TO_WORDS(HBLKDISPL(r));\n \t      if (r == 0) hhdr = 0;\n-            } else {\n+          } else {\n+\t      /* Offset invalid, but map reflects interior pointers \t*/\n               hhdr = 0;\n-            }\n-#\t  else\n-\t    /* map already reflects interior pointers */\n-\t    hhdr = 0;\n-#\t  endif\n+          }\n         } else {\n           displ = BYTES_TO_WORDS(displ);\n           displ -= map_entry;\n@@ -856,22 +1260,18 @@ register GC_bool interior_ptrs;\n     /* If hhdr != 0 then r == GC_base(p), only we did it faster. */\n     /* displ is the word index within the block.\t\t */\n     if (hhdr == 0) {\n-    \tif (interior_ptrs) {\n-#\t    ifdef PRINT_BLACK_LIST\n-\t      GC_add_to_black_list_stack(p, source);\n-#\t    else\n-\t      GC_add_to_black_list_stack(p);\n-#\t    endif\n-\t} else {\n-\t    GC_ADD_TO_BLACK_LIST_NORMAL(p, source);\n-#\t    undef source  /* In case we had to define it. */\n-\t}\n+#\tifdef PRINT_BLACK_LIST\n+\t  GC_add_to_black_list_stack(p, source);\n+#\telse\n+\t  GC_add_to_black_list_stack(p);\n+#\tendif\n+#\tundef source  /* In case we had to define it. */\n     } else {\n \tif (!mark_bit_from_hdr(hhdr, displ)) {\n \t    set_mark_bit_from_hdr(hhdr, displ);\n  \t    GC_STORE_BACK_PTR(source, (ptr_t)r);\n \t    PUSH_OBJ((word *)r, hhdr, GC_mark_stack_top,\n-\t             &(GC_mark_stack[GC_mark_stack_size]));\n+\t             GC_mark_stack_limit);\n \t}\n     }\n }\n@@ -965,7 +1365,7 @@ ptr_t bottom;\n ptr_t top;\n ptr_t cold_gc_frame;\n {\n-# ifdef ALL_INTERIOR_POINTERS\n+  if (GC_all_interior_pointers) {\n #   define EAGER_BYTES 1024\n     /* Push the hot end of the stack eagerly, so that register values   */\n     /* saved inside GC frames are marked before they disappear.\t\t*/\n@@ -981,9 +1381,9 @@ ptr_t cold_gc_frame;\n \tGC_push_all_eager(cold_gc_frame, top);\n \tGC_push_all(bottom, cold_gc_frame + sizeof(ptr_t));\n #   endif /* STACK_GROWS_UP */\n-# else\n+  } else {\n     GC_push_all_eager(bottom, top);\n-# endif\n+  }\n # ifdef TRACE_BUF\n       GC_add_trace_entry(\"GC_push_all_stack\", bottom, top);\n # endif\n@@ -994,28 +1394,32 @@ void GC_push_all_stack(bottom, top)\n ptr_t bottom;\n ptr_t top;\n {\n-# ifdef ALL_INTERIOR_POINTERS\n+  if (GC_all_interior_pointers) {\n     GC_push_all(bottom, top);\n-# else\n+  } else {\n     GC_push_all_eager(bottom, top);\n-# endif\n+  }\n }\n \n-#ifndef SMALL_CONFIG\n+#if !defined(SMALL_CONFIG) && !defined(USE_MARK_BYTES)\n /* Push all objects reachable from marked objects in the given block */\n /* of size 1 objects.\t\t\t\t\t\t     */\n void GC_push_marked1(h, hhdr)\n struct hblk *h;\n register hdr * hhdr;\n {\n-    word * mark_word_addr = &(hhdr->hb_marks[divWORDSZ(HDR_WORDS)]);\n+    word * mark_word_addr = &(hhdr->hb_marks[0]);\n     register word *p;\n     word *plim;\n     register int i;\n     register word q;\n     register word mark_word;\n     register ptr_t greatest_ha = GC_greatest_plausible_heap_addr;\n     register ptr_t least_ha = GC_least_plausible_heap_addr;\n+    register mse * mark_stack_top = GC_mark_stack_top;\n+    register mse * mark_stack_limit = GC_mark_stack_limit;\n+#   define GC_mark_stack_top mark_stack_top\n+#   define GC_mark_stack_limit mark_stack_limit\n #   define GC_greatest_plausible_heap_addr greatest_ha\n #   define GC_least_plausible_heap_addr least_ha\n     \n@@ -1038,6 +1442,9 @@ register hdr * hhdr;\n \t}\n #   undef GC_greatest_plausible_heap_addr\n #   undef GC_least_plausible_heap_addr        \n+#   undef GC_mark_stack_top\n+#   undef GC_mark_stack_limit\n+    GC_mark_stack_top = mark_stack_top;\n }\n \n \n@@ -1049,14 +1456,18 @@ void GC_push_marked2(h, hhdr)\n struct hblk *h;\n register hdr * hhdr;\n {\n-    word * mark_word_addr = &(hhdr->hb_marks[divWORDSZ(HDR_WORDS)]);\n+    word * mark_word_addr = &(hhdr->hb_marks[0]);\n     register word *p;\n     word *plim;\n     register int i;\n     register word q;\n     register word mark_word;\n     register ptr_t greatest_ha = GC_greatest_plausible_heap_addr;\n     register ptr_t least_ha = GC_least_plausible_heap_addr;\n+    register mse * mark_stack_top = GC_mark_stack_top;\n+    register mse * mark_stack_limit = GC_mark_stack_limit;\n+#   define GC_mark_stack_top mark_stack_top\n+#   define GC_mark_stack_limit mark_stack_limit\n #   define GC_greatest_plausible_heap_addr greatest_ha\n #   define GC_least_plausible_heap_addr least_ha\n     \n@@ -1081,6 +1492,9 @@ register hdr * hhdr;\n \t}\n #   undef GC_greatest_plausible_heap_addr\n #   undef GC_least_plausible_heap_addr        \n+#   undef GC_mark_stack_top\n+#   undef GC_mark_stack_limit\n+    GC_mark_stack_top = mark_stack_top;\n }\n \n /* Push all objects reachable from marked objects in the given block */\n@@ -1091,14 +1505,18 @@ void GC_push_marked4(h, hhdr)\n struct hblk *h;\n register hdr * hhdr;\n {\n-    word * mark_word_addr = &(hhdr->hb_marks[divWORDSZ(HDR_WORDS)]);\n+    word * mark_word_addr = &(hhdr->hb_marks[0]);\n     register word *p;\n     word *plim;\n     register int i;\n     register word q;\n     register word mark_word;\n     register ptr_t greatest_ha = GC_greatest_plausible_heap_addr;\n     register ptr_t least_ha = GC_least_plausible_heap_addr;\n+    register mse * mark_stack_top = GC_mark_stack_top;\n+    register mse * mark_stack_limit = GC_mark_stack_limit;\n+#   define GC_mark_stack_top mark_stack_top\n+#   define GC_mark_stack_limit mark_stack_limit\n #   define GC_greatest_plausible_heap_addr greatest_ha\n #   define GC_least_plausible_heap_addr least_ha\n     \n@@ -1127,6 +1545,9 @@ register hdr * hhdr;\n \t}\n #   undef GC_greatest_plausible_heap_addr\n #   undef GC_least_plausible_heap_addr        \n+#   undef GC_mark_stack_top\n+#   undef GC_mark_stack_limit\n+    GC_mark_stack_top = mark_stack_top;\n }\n \n #endif /* UNALIGNED */\n@@ -1144,28 +1565,27 @@ register hdr * hhdr;\n     register int word_no;\n     register word * lim;\n     register mse * GC_mark_stack_top_reg;\n-    register mse * mark_stack_limit = &(GC_mark_stack[GC_mark_stack_size]);\n+    register mse * mark_stack_limit = GC_mark_stack_limit;\n     \n     /* Some quick shortcuts: */\n-\tif ((0 | DS_LENGTH) == descr) return;\n+\tif ((0 | GC_DS_LENGTH) == descr) return;\n         if (GC_block_empty(hhdr)/* nothing marked */) return;\n-#   ifdef GATHERSTATS\n-        GC_n_rescuing_pages++;\n-#   endif\n+    GC_n_rescuing_pages++;\n     GC_objects_are_marked = TRUE;\n     if (sz > MAXOBJSZ) {\n-        lim = (word *)h + HDR_WORDS;\n+        lim = (word *)h;\n     } else {\n         lim = (word *)(h + 1) - sz;\n     }\n     \n     switch(sz) {\n-#   if !defined(SMALL_CONFIG)    \n+#   if !defined(SMALL_CONFIG) && !defined(USE_MARK_BYTES)   \n      case 1:\n        GC_push_marked1(h, hhdr);\n        break;\n #   endif\n-#   if !defined(SMALL_CONFIG) && !defined(UNALIGNED)\n+#   if !defined(SMALL_CONFIG) && !defined(UNALIGNED) && \\\n+       !defined(USE_MARK_BYTES)\n      case 2:\n        GC_push_marked2(h, hhdr);\n        break;\n@@ -1175,8 +1595,7 @@ register hdr * hhdr;\n #   endif       \n      default:\n       GC_mark_stack_top_reg = GC_mark_stack_top;\n-      for (p = (word *)h + HDR_WORDS, word_no = HDR_WORDS; p <= lim;\n-         p += sz, word_no += sz) {\n+      for (p = (word *)h, word_no = 0; p <= lim; p += sz, word_no += sz) {\n          if (mark_bit_from_hdr(hhdr, word_no)) {\n            /* Mark from fields inside the object */\n              PUSH_OBJ((word *)p, hhdr, GC_mark_stack_top_reg, mark_stack_limit);\n@@ -1203,7 +1622,6 @@ register hdr * hhdr;\n          return(GC_page_was_dirty(h));\n     } else {\n     \t register ptr_t p = (ptr_t)h;\n-         sz += HDR_WORDS;\n          sz = WORDS_TO_BYTES(sz);\n          while (p < (ptr_t)h + sz) {\n              if (GC_page_was_dirty((struct hblk *)p)) return(TRUE);"}, {"sha": "8480a0e1a4ace1241c3785914a98deede01c3648", "filename": "boehm-gc/mark_rts.c", "status": "modified", "additions": 76, "deletions": 19, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9110a741e35c54e46c00662ddc420575376c5947/boehm-gc%2Fmark_rts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9110a741e35c54e46c00662ddc420575376c5947/boehm-gc%2Fmark_rts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fmark_rts.c?ref=9110a741e35c54e46c00662ddc420575376c5947", "patch": "@@ -11,9 +11,8 @@\n  * provided the above notices are retained, and a notice that the code was\n  * modified is included with the above copyright notice.\n  */\n-/* Boehm, October 9, 1995 1:06 pm PDT */\n # include <stdio.h>\n-# include \"gc_priv.h\"\n+# include \"private/gc_priv.h\"\n \n /* Data structure for list of root sets.\t\t\t\t*/\n /* We keep a hash table, so that we can filter out duplicate additions.\t*/\n@@ -23,7 +22,7 @@\n struct roots {\n \tptr_t r_start;\n \tptr_t r_end;\n- #\tifndef MSWIN32\n+ #\tif !defined(MSWIN32) && !defined(MSWINCE)\n \t  struct roots * r_next;\n  #\tendif\n \tGC_bool r_tmp;\n@@ -33,6 +32,8 @@ struct roots {\n struct roots GC_static_roots[MAX_ROOT_SETS];\n */\n \n+int GC_no_dls = 0;\t/* Register dynamic library data segments.\t*/\n+\n static int n_root_sets = 0;\n \n \t/* GC_static_roots[0..n_root_sets) contains the valid root sets. */\n@@ -69,11 +70,12 @@ void GC_print_static_roots()\n GC_bool GC_is_static_root(p)\n ptr_t p;\n {\n-    static int last_root_set = 0;\n+    static int last_root_set = MAX_ROOT_SETS;\n     register int i;\n     \n     \n-    if (p >= GC_static_roots[last_root_set].r_start\n+    if (last_root_set < n_root_sets\n+\t&& p >= GC_static_roots[last_root_set].r_start\n         && p < GC_static_roots[last_root_set].r_end) return(TRUE);\n     for (i = 0; i < n_root_sets; i++) {\n     \tif (p >= GC_static_roots[i].r_start\n@@ -85,7 +87,7 @@ ptr_t p;\n     return(FALSE);\n }\n \n-#ifndef MSWIN32\n+#if !defined(MSWIN32) && !defined(MSWINCE)\n /* \n #   define LOG_RT_SIZE 6\n #   define RT_SIZE (1 << LOG_RT_SIZE)  -- Power of 2, may be != MAX_ROOT_SETS\n@@ -137,7 +139,7 @@ struct roots *p;\n     GC_root_index[h] = p;\n }\n \n-# else /* MSWIN32 */\n+# else /* MSWIN32 || MSWINCE */\n \n #   define add_roots_to_index(p)\n \n@@ -173,7 +175,7 @@ GC_bool tmp;\n {\n     struct roots * old;\n     \n-#   ifdef MSWIN32\n+#   if defined(MSWIN32) || defined(MSWINCE)\n       /* Spend the time to ensure that there are no overlapping\t*/\n       /* or adjacent intervals.\t\t\t\t\t*/\n       /* This could be done faster with e.g. a\t\t\t*/\n@@ -242,23 +244,26 @@ GC_bool tmp;\n     GC_static_roots[n_root_sets].r_start = (ptr_t)b;\n     GC_static_roots[n_root_sets].r_end = (ptr_t)e;\n     GC_static_roots[n_root_sets].r_tmp = tmp;\n-#   ifndef MSWIN32\n+#   if !defined(MSWIN32) && !defined(MSWINCE)\n       GC_static_roots[n_root_sets].r_next = 0;\n #   endif\n     add_roots_to_index(GC_static_roots + n_root_sets);\n     GC_root_size += (ptr_t)e - (ptr_t)b;\n     n_root_sets++;\n }\n \n+static roots_were_cleared = FALSE;\n+\n void GC_clear_roots GC_PROTO((void))\n {\n     DCL_LOCK_STATE;\n     \n     DISABLE_SIGNALS();\n     LOCK();\n+    roots_were_cleared = TRUE;\n     n_root_sets = 0;\n     GC_root_size = 0;\n-#   ifndef MSWIN32\n+#   if !defined(MSWIN32) && !defined(MSWINCE)\n     {\n     \tregister int i;\n     \t\n@@ -286,7 +291,7 @@ void GC_remove_tmp_roots()\n     \t    i++;\n     \t}\n     }\n-#   ifndef MSWIN32\n+#   if !defined(MSWIN32) && !defined(MSWINCE)\n     {\n     \tregister int i;\n     \t\n@@ -298,11 +303,41 @@ void GC_remove_tmp_roots()\n     \n }\n \n+#if defined(MSWIN32) || defined(_WIN32_WCE_EMULATION)\n+/* Workaround for the OS mapping and unmapping behind our back:\t\t*/\n+/* Is the address p in one of the temporary static root sections?\t*/\n+GC_bool GC_is_tmp_root(p)\n+ptr_t p;\n+{\n+    static int last_root_set = MAX_ROOT_SETS;\n+    register int i;\n+    \n+    if (last_root_set < n_root_sets\n+\t&& p >= GC_static_roots[last_root_set].r_start\n+        && p < GC_static_roots[last_root_set].r_end)\n+\treturn GC_static_roots[last_root_set].r_tmp;\n+    for (i = 0; i < n_root_sets; i++) {\n+    \tif (p >= GC_static_roots[i].r_start\n+            && p < GC_static_roots[i].r_end) {\n+            last_root_set = i;\n+            return GC_static_roots[i].r_tmp;\n+        }\n+    }\n+    return(FALSE);\n+}\n+#endif /* MSWIN32 || _WIN32_WCE_EMULATION */\n+\n ptr_t GC_approx_sp()\n {\n     word dummy;\n-    \n+\n+#   ifdef _MSC_VER\n+#     pragma warning(disable:4172)\n+#   endif\n     return((ptr_t)(&dummy));\n+#   ifdef _MSC_VER\n+#     pragma warning(default:4172)\n+#   endif\n }\n \n /*\n@@ -432,15 +467,15 @@ ptr_t cold_gc_frame;\n \t\t\t/* Previously set to backing store pointer.\t*/\n \t\tptr_t bsp = (ptr_t) GC_save_regs_ret_val;\n \t        ptr_t cold_gc_bs_pointer;\n-#\t\tifdef ALL_INTERIOR_POINTERS\n+\t\tif (GC_all_interior_pointers) {\n \t          cold_gc_bs_pointer = bsp - 2048;\n \t\t  if (cold_gc_bs_pointer < BACKING_STORE_BASE) {\n \t\t    cold_gc_bs_pointer = BACKING_STORE_BASE;\n \t\t  }\n-\t\t  GC_push_all(BACKING_STORE_BASE, cold_gc_bs_pointer);\n-#\t\telse\n+\t\t  GC_push_all_stack(BACKING_STORE_BASE, cold_gc_bs_pointer);\n+\t\t} else {\n \t\t  cold_gc_bs_pointer = BACKING_STORE_BASE;\n-#\t\tendif\n+\t\t}\n \t\tGC_push_all_eager(cold_gc_bs_pointer, bsp);\n \t\t/* All values should be sufficiently aligned that we\t*/\n \t\t/* dont have to worry about the boundary.\t\t*/\n@@ -453,6 +488,19 @@ ptr_t cold_gc_frame;\n #   endif /* !THREADS */\n }\n \n+/*\n+ * Push GC internal roots.  Only called if there is some reason to believe\n+ * these would not otherwise get registered.\n+ */\n+void GC_push_gc_structures GC_PROTO((void))\n+{\n+    GC_push_finalizer_structures();\n+    GC_push_stubborn_structures();\n+#   if defined(THREADS)\n+      GC_push_thread_structures();\n+#   endif\n+}\n+\n /*\n  * Call the mark routines (GC_tl_push for a single pointer, GC_push_conditional\n  * on groups of pointers) on every top level accessible pointer.\n@@ -483,18 +531,27 @@ ptr_t cold_gc_frame;\n      * not robust against mark stack overflow.\n      */\n      /* Reregister dynamic libraries, in case one got added.\t*/\n-#      if (defined(DYNAMIC_LOADING) || defined(MSWIN32) || defined(PCR)) \\\n-           && !defined(SRC_M3)\n+#      if (defined(DYNAMIC_LOADING) || defined(MSWIN32) || defined(MSWINCE) \\\n+\t   || defined(PCR)) && !defined(SRC_M3)\n          GC_remove_tmp_roots();\n-         GC_register_dynamic_libraries();\n+         if (!GC_no_dls) GC_register_dynamic_libraries();\n+#      else\n+\t GC_no_dls = TRUE;\n #      endif\n+\n      /* Mark everything in static data areas                             */\n        for (i = 0; i < n_root_sets; i++) {\n          GC_push_conditional_with_exclusions(\n \t\t\t     GC_static_roots[i].r_start,\n \t\t\t     GC_static_roots[i].r_end, all);\n        }\n \n+     /* Mark from GC internal roots if those might otherwise have\t*/\n+     /* been excluded.\t\t\t\t\t\t\t*/\n+       if (GC_no_dls || roots_were_cleared) {\n+\t   GC_push_gc_structures();\n+       }\n+\n     /*\n      * Now traverse stacks.\n      */"}, {"sha": "8ece80d915489c3f033ce0cbae3f1f1bd7a5c71f", "filename": "boehm-gc/misc.c", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9110a741e35c54e46c00662ddc420575376c5947/boehm-gc%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9110a741e35c54e46c00662ddc420575376c5947/boehm-gc%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fmisc.c?ref=9110a741e35c54e46c00662ddc420575376c5947"}, {"sha": "d904aedc53e4493d282991c9062012bf1d9d3a7b", "filename": "boehm-gc/new_hblk.c", "status": "modified", "additions": 70, "deletions": 57, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9110a741e35c54e46c00662ddc420575376c5947/boehm-gc%2Fnew_hblk.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9110a741e35c54e46c00662ddc420575376c5947/boehm-gc%2Fnew_hblk.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fnew_hblk.c?ref=9110a741e35c54e46c00662ddc420575376c5947"}, {"sha": "ab83afbaaf2f58e38d4a15de2ecba66f3c011683", "filename": "boehm-gc/nursery.c", "status": "removed", "additions": 0, "deletions": 312, "changes": 312, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6951ca5dee8ed05749cdc697767910aebaedcc0/boehm-gc%2Fnursery.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6951ca5dee8ed05749cdc697767910aebaedcc0/boehm-gc%2Fnursery.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fnursery.c?ref=a6951ca5dee8ed05749cdc697767910aebaedcc0"}, {"sha": "d002d65b4dda05092dc23a6b74bf1f1e451f0063", "filename": "boehm-gc/obj_map.c", "status": "modified", "additions": 24, "deletions": 19, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9110a741e35c54e46c00662ddc420575376c5947/boehm-gc%2Fobj_map.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9110a741e35c54e46c00662ddc420575376c5947/boehm-gc%2Fobj_map.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fobj_map.c?ref=9110a741e35c54e46c00662ddc420575376c5947"}, {"sha": "a7f6d1940054120b3b6ad2ed1ec63f816849549e", "filename": "boehm-gc/os_dep.c", "status": "modified", "additions": 693, "deletions": 323, "changes": 1016, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9110a741e35c54e46c00662ddc420575376c5947/boehm-gc%2Fos_dep.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9110a741e35c54e46c00662ddc420575376c5947/boehm-gc%2Fos_dep.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fos_dep.c?ref=9110a741e35c54e46c00662ddc420575376c5947"}, {"sha": "15c904551be78a62c9a181af0cda0bc8c7759247", "filename": "boehm-gc/pc_excludes", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9110a741e35c54e46c00662ddc420575376c5947/boehm-gc%2Fpc_excludes", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9110a741e35c54e46c00662ddc420575376c5947/boehm-gc%2Fpc_excludes", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fpc_excludes?ref=9110a741e35c54e46c00662ddc420575376c5947"}, {"sha": "7bf02a45c69e177ea4d988cb63fcc61604ec05a3", "filename": "boehm-gc/pcr_interface.c", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9110a741e35c54e46c00662ddc420575376c5947/boehm-gc%2Fpcr_interface.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9110a741e35c54e46c00662ddc420575376c5947/boehm-gc%2Fpcr_interface.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fpcr_interface.c?ref=9110a741e35c54e46c00662ddc420575376c5947"}, {"sha": "af49d5f5b791d378de9a29fc18f0c53acad6b14d", "filename": "boehm-gc/ptr_chck.c", "status": "modified", "additions": 42, "deletions": 40, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9110a741e35c54e46c00662ddc420575376c5947/boehm-gc%2Fptr_chck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9110a741e35c54e46c00662ddc420575376c5947/boehm-gc%2Fptr_chck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fptr_chck.c?ref=9110a741e35c54e46c00662ddc420575376c5947"}, {"sha": "f8f057d6171d445b5f1cac0d9fb78f98d3e98817", "filename": "boehm-gc/reclaim.c", "status": "modified", "additions": 237, "deletions": 173, "changes": 410, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9110a741e35c54e46c00662ddc420575376c5947/boehm-gc%2Freclaim.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9110a741e35c54e46c00662ddc420575376c5947/boehm-gc%2Freclaim.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Freclaim.c?ref=9110a741e35c54e46c00662ddc420575376c5947"}, {"sha": "07686ef0808db48d17858c6930fc2b5da53e5f95", "filename": "boehm-gc/setjmp_t.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9110a741e35c54e46c00662ddc420575376c5947/boehm-gc%2Fsetjmp_t.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9110a741e35c54e46c00662ddc420575376c5947/boehm-gc%2Fsetjmp_t.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fsetjmp_t.c?ref=9110a741e35c54e46c00662ddc420575376c5947"}, {"sha": "c7359e24b7f56e725d784ec5503f21e76de63259", "filename": "boehm-gc/solaris_pthreads.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9110a741e35c54e46c00662ddc420575376c5947/boehm-gc%2Fsolaris_pthreads.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9110a741e35c54e46c00662ddc420575376c5947/boehm-gc%2Fsolaris_pthreads.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fsolaris_pthreads.c?ref=9110a741e35c54e46c00662ddc420575376c5947"}, {"sha": "8cc6319cd22e82ef528ef6fecad157c3b72753b0", "filename": "boehm-gc/solaris_threads.c", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9110a741e35c54e46c00662ddc420575376c5947/boehm-gc%2Fsolaris_threads.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9110a741e35c54e46c00662ddc420575376c5947/boehm-gc%2Fsolaris_threads.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fsolaris_threads.c?ref=9110a741e35c54e46c00662ddc420575376c5947"}, {"sha": "b2cdb36e98d9734447c77b3c41c5f4352362552a", "filename": "boehm-gc/solaris_threads.h", "status": "removed", "additions": 0, "deletions": 34, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6951ca5dee8ed05749cdc697767910aebaedcc0/boehm-gc%2Fsolaris_threads.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6951ca5dee8ed05749cdc697767910aebaedcc0/boehm-gc%2Fsolaris_threads.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fsolaris_threads.h?ref=a6951ca5dee8ed05749cdc697767910aebaedcc0"}, {"sha": "bb137616fa8bbab4ca8a951ce7d56d7f23f69347", "filename": "boehm-gc/stubborn.c", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9110a741e35c54e46c00662ddc420575376c5947/boehm-gc%2Fstubborn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9110a741e35c54e46c00662ddc420575376c5947/boehm-gc%2Fstubborn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fstubborn.c?ref=9110a741e35c54e46c00662ddc420575376c5947"}, {"sha": "9254fa8370dd77d21ae49ed210092ffc1af583ca", "filename": "boehm-gc/test.c", "status": "removed", "additions": 0, "deletions": 1390, "changes": 1390, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6951ca5dee8ed05749cdc697767910aebaedcc0/boehm-gc%2Ftest.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6951ca5dee8ed05749cdc697767910aebaedcc0/boehm-gc%2Ftest.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Ftest.c?ref=a6951ca5dee8ed05749cdc697767910aebaedcc0"}, {"sha": "0d45077658f495a15dfa240162316e5a78a63eb1", "filename": "boehm-gc/test_cpp.cc", "status": "removed", "additions": 0, "deletions": 271, "changes": 271, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6951ca5dee8ed05749cdc697767910aebaedcc0/boehm-gc%2Ftest_cpp.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6951ca5dee8ed05749cdc697767910aebaedcc0/boehm-gc%2Ftest_cpp.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Ftest_cpp.cc?ref=a6951ca5dee8ed05749cdc697767910aebaedcc0"}, {"sha": "0ac54510cc3c78da306fb7f3e10f601a17e98b5e", "filename": "boehm-gc/threadlibs.c", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9110a741e35c54e46c00662ddc420575376c5947/boehm-gc%2Fthreadlibs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9110a741e35c54e46c00662ddc420575376c5947/boehm-gc%2Fthreadlibs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fthreadlibs.c?ref=9110a741e35c54e46c00662ddc420575376c5947"}, {"sha": "07717001e9d1eb7327386ac4602e9d9860f07add", "filename": "boehm-gc/typd_mlc.c", "status": "modified", "additions": 58, "deletions": 43, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9110a741e35c54e46c00662ddc420575376c5947/boehm-gc%2Ftypd_mlc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9110a741e35c54e46c00662ddc420575376c5947/boehm-gc%2Ftypd_mlc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Ftypd_mlc.c?ref=9110a741e35c54e46c00662ddc420575376c5947"}, {"sha": "b265b9760f59d172923814fa37082fb5bbaed52e", "filename": "boehm-gc/version.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9110a741e35c54e46c00662ddc420575376c5947/boehm-gc%2Fversion.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9110a741e35c54e46c00662ddc420575376c5947/boehm-gc%2Fversion.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fversion.h?ref=9110a741e35c54e46c00662ddc420575376c5947"}, {"sha": "84906b00a68489f158f12c9e86dba9eb0d73a2a9", "filename": "boehm-gc/weakpointer.h", "status": "removed", "additions": 0, "deletions": 221, "changes": 221, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6951ca5dee8ed05749cdc697767910aebaedcc0/boehm-gc%2Fweakpointer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6951ca5dee8ed05749cdc697767910aebaedcc0/boehm-gc%2Fweakpointer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fweakpointer.h?ref=a6951ca5dee8ed05749cdc697767910aebaedcc0"}, {"sha": "e0d19d51b35c8c59ceb2d1fe8896bce2ca4638d2", "filename": "boehm-gc/win32_threads.c", "status": "modified", "additions": 449, "deletions": 43, "changes": 492, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9110a741e35c54e46c00662ddc420575376c5947/boehm-gc%2Fwin32_threads.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9110a741e35c54e46c00662ddc420575376c5947/boehm-gc%2Fwin32_threads.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2Fwin32_threads.c?ref=9110a741e35c54e46c00662ddc420575376c5947"}]}