{"sha": "1e7f0a48cf6e9c5d1435f3da96990c5d299f4953", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWU3ZjBhNDhjZjZlOWM1ZDE0MzVmM2RhOTY5OTBjNWQyOTlmNDk1Mw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2000-03-14T14:38:52Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2000-03-14T14:38:52Z"}, "message": "regmove.c (combine_stack_adjustments): New.\n\n        * regmove.c (combine_stack_adjustments): New.\n        (stack_memref_p, single_set_for_csa): New.\n        (free_csa_memlist, record_one_stack_memref): New.\n        (try_apply_stack_adjustment): New.\n        (combine_stack_adjustments_for_block): New.\n        * rtl.h (combine_stack_adjustments): Declare.\n        * toplev.c (rest_of_compilation): Call it.\n\n        * i386.md: Revert 2000-01-16 change.\n\nFrom-SVN: r32526", "tree": {"sha": "1a629149dede4a23ade805cc2e7cfad2448f3b60", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1a629149dede4a23ade805cc2e7cfad2448f3b60"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1e7f0a48cf6e9c5d1435f3da96990c5d299f4953", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e7f0a48cf6e9c5d1435f3da96990c5d299f4953", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1e7f0a48cf6e9c5d1435f3da96990c5d299f4953", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e7f0a48cf6e9c5d1435f3da96990c5d299f4953/comments", "author": null, "committer": null, "parents": [{"sha": "d5fb67d394088d1574f098923dfe5c09d456738a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d5fb67d394088d1574f098923dfe5c09d456738a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d5fb67d394088d1574f098923dfe5c09d456738a"}], "stats": {"total": 387, "additions": 359, "deletions": 28}, "files": [{"sha": "48ea28cdd832d0758fbc0350e6b120897360d10f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e7f0a48cf6e9c5d1435f3da96990c5d299f4953/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e7f0a48cf6e9c5d1435f3da96990c5d299f4953/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1e7f0a48cf6e9c5d1435f3da96990c5d299f4953", "patch": "@@ -1,3 +1,15 @@\n+2000-03-14  Richard Henderson  <rth@cygnus.com>\n+\n+\t* regmove.c (combine_stack_adjustments): New.\n+\t(stack_memref_p, single_set_for_csa): New.\n+\t(free_csa_memlist, record_one_stack_memref): New.\n+\t(try_apply_stack_adjustment): New.\n+\t(combine_stack_adjustments_for_block): New.\n+\t* rtl.h (combine_stack_adjustments): Declare.\n+\t* toplev.c (rest_of_compilation): Call it.\n+\n+\t* i386.md: Revert 2000-01-16 change.\n+\n 2000-03-14  Martin v. L\ufffdwis  <loewis@informatik.hu-berlin.de>\n \n \t* gccbug.in: Add web category, gcc specific classes.\n@@ -370,8 +382,8 @@ Thu Mar  9 20:01:38 2000  Jim Wilson  <wilson@cygnus.com>\n \n Thu Mar  9 18:10:02 2000  Jeffrey A Law  (law@cygnus.com)\n \n-        * config/pa/pa-hpux10.h (LIB_SPEC): Correct typo in !p case.\n-        (MD_STARTFILE_PREFIX_1): New macro.\n+\t* config/pa/pa-hpux10.h (LIB_SPEC): Correct typo in !p case.\n+\t(MD_STARTFILE_PREFIX_1): New macro.\n \n 2000-03-09  Robert Lipe  <robertl@sco.com>\n \n@@ -1483,7 +1495,7 @@ Mon Feb 28 21:07:59 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \t(SET_DEFAULT_TYPE_ATTRIBUTES): Define.\n \n \t* config/arm/arm.md (call): Call arm_is_longcall_p to decide\n-        if a long call is needed.\n+\tif a long call is needed.\n \t(call_value): Ditto.\n \t(call_symbol): Ditto.\n "}, {"sha": "be2b035b94de53a30ef97593ecd60a14042e024f", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e7f0a48cf6e9c5d1435f3da96990c5d299f4953/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e7f0a48cf6e9c5d1435f3da96990c5d299f4953/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=1e7f0a48cf6e9c5d1435f3da96990c5d299f4953", "patch": "@@ -9386,25 +9386,6 @@\n   [(parallel [(set (match_dup 0) (ashift:SI (match_dup 0) (match_dup 2)))\n \t      (clobber (reg:CC 17))])]\n   \"operands[2] = GEN_INT (exact_log2 (INTVAL (operands[1])));\")\n-\n-;; Merge two successive stack adjusts.  The combiner doesn't know how\n-;; to do this, and doesn't see all of them.\n-;; (reg:SI 7) is %esp.\n-(define_peephole2\n-  [(parallel[\n-    (set (reg:SI 7)\n-\t (plus:SI (reg:SI 7) (match_operand:SI 0 \"const_int_operand\" \"\")))\n-    (clobber (reg:CC 17))])\n-   (parallel[\n-    (set (reg:SI 7)\n-\t (plus:SI (reg:SI 7) (match_operand:SI 1 \"const_int_operand\" \"\")))\n-    (clobber (reg:CC 17))])]\n-  \"\"\n-  [(parallel[\n-    (set (reg:SI 7)\n-\t (plus:SI (reg:SI 7) (match_dup 2)))\n-    (clobber (reg:CC 17))])]\n-  \"operands[2] = GEN_INT (INTVAL (operands[0]) + INTVAL (operands[1]));\")\n \f\n ;; Call-value patterns last so that the wildcard operand does not\n ;; disrupt insn-recog's switch tables."}, {"sha": "fa82f8f95e9ccead9f7fb9106b36ef1d6ad79cea", "filename": "gcc/regmove.c", "status": "modified", "additions": 333, "deletions": 0, "changes": 333, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e7f0a48cf6e9c5d1435f3da96990c5d299f4953/gcc%2Fregmove.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e7f0a48cf6e9c5d1435f3da96990c5d299f4953/gcc%2Fregmove.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregmove.c?ref=1e7f0a48cf6e9c5d1435f3da96990c5d299f4953", "patch": "@@ -2060,3 +2060,336 @@ stable_and_no_regs_but_for_p (x, src, dst)\n       return ! rtx_unstable_p (x);\n     }\n }\n+\f\n+/* Track stack adjustments and stack memory references.  Attempt to \n+   reduce the number of stack adjustments by back-propogating across\n+   the memory references.\n+\n+   This is intended primarily for use with targets that do not define\n+   ACCUMULATE_OUTGOING_ARGS.  It is of significantly more value to\n+   targets that define PREFERRED_STACK_BOUNDARY more aligned than\n+   STACK_BOUNDARY (e.g. x86), or if not all registers can be pushed\n+   (e.g. x86 fp regs) which would ordinarily have to be implemented\n+   as a sub/mov pair due to restrictions in calls.c.\n+\n+   Propogation stops when any of the insns that need adjusting are\n+   (a) no longer valid because we've exceeded their range, (b) a\n+   non-trivial push instruction, or (c) a call instruction.\n+\n+   Restriction B is based on the assumption that push instructions\n+   are smaller or faster.  If a port really wants to remove all\n+   pushes, it should have defined ACCUMULATE_OUTGOING_ARGS.  The\n+   one exception that is made is for an add immediately followed\n+   by a push.  */\n+\n+/* This structure records stack memory references between stack adjusting\n+   instructions.  */\n+\n+struct csa_memlist\n+{\n+  HOST_WIDE_INT sp_offset;\n+  rtx insn, mem;\n+  struct csa_memlist *next;\n+};\n+\n+static int stack_memref_p\t\tPARAMS ((rtx));\n+static rtx single_set_for_csa\t\tPARAMS ((rtx));\n+static void free_csa_memlist\t\tPARAMS ((struct csa_memlist *));\n+static struct csa_memlist *record_one_stack_memref\n+  PARAMS ((rtx, rtx, struct csa_memlist *));\n+static int try_apply_stack_adjustment\n+  PARAMS ((rtx, struct csa_memlist *, HOST_WIDE_INT, HOST_WIDE_INT));\n+static void combine_stack_adjustments_for_block PARAMS ((basic_block));\n+\n+\n+/* Main entry point for stack adjustment combination.  */\n+\n+void\n+combine_stack_adjustments ()\n+{\n+  int i;\n+\n+  for (i = 0; i < n_basic_blocks; ++i)\n+    combine_stack_adjustments_for_block (BASIC_BLOCK (i));\n+}\n+\n+/* Recognize a MEM of the form (sp) or (plus sp const).  */\n+\n+static int\n+stack_memref_p (mem)\n+     rtx mem;\n+{\n+  return (GET_CODE (mem) == MEM\n+\t  && (XEXP (mem, 0) == stack_pointer_rtx\n+\t      || (GET_CODE (XEXP (mem, 0)) == PLUS\n+\t\t  && XEXP (XEXP (mem, 0), 0) == stack_pointer_rtx\n+\t\t  && GET_CODE (XEXP (XEXP (mem, 0), 0)) == CONST_INT)));\n+}\n+\n+/* Recognize either normal single_set or the hack in i386.md for\n+   tying fp and sp adjustments.  */\n+\n+static rtx\n+single_set_for_csa (insn)\n+     rtx insn;\n+{\n+  int i;\n+  rtx tmp = single_set (insn);\n+  if (tmp)\n+    return tmp;\n+\n+  if (GET_CODE (insn) != INSN\n+      || GET_CODE (PATTERN (insn)) != PARALLEL)\n+    return NULL_RTX;\n+\n+  tmp = PATTERN (insn);\n+  if (GET_CODE (XVECEXP (tmp, 0, 0)) != SET)\n+    return NULL_RTX;\n+\n+  for (i = 1; i < XVECLEN (tmp, 0); ++i)\n+    {\n+      rtx this = XVECEXP (tmp, 0, i);\n+\n+      /* The special case is allowing a no-op set.  */\n+      if (GET_CODE (this) == SET\n+\t  && SET_SRC (this) == SET_DEST (this))\n+\t;\n+      else if (GET_CODE (this) != CLOBBER\n+\t       && GET_CODE (this) != USE)\n+\treturn NULL_RTX;\n+    }\n+\n+  return XVECEXP (tmp, 0, 0);\n+}\n+\n+/* Free the list of csa_memlist nodes.  */\n+\n+static void\n+free_csa_memlist (memlist)\n+     struct csa_memlist *memlist;\n+{\n+  struct csa_memlist *next;\n+  for (; memlist ; memlist = next)\n+    {\n+      next = memlist->next;\n+      free (memlist);\n+    }\n+}\n+\n+/* Create a new csa_memlist node from the given memory reference.\n+   It is already known that the memory is stack_memref_p.  */\n+\n+static struct csa_memlist *\n+record_one_stack_memref (insn, mem, next_memlist)\n+     rtx insn, mem;\n+     struct csa_memlist *next_memlist;\n+{\n+  struct csa_memlist *ml;\n+\n+  ml = (struct csa_memlist *) xmalloc (sizeof (*ml));\n+\n+  if (XEXP (mem, 0) == stack_pointer_rtx)\n+    ml->sp_offset = 0;\n+  else\n+    ml->sp_offset = INTVAL (XEXP (XEXP (mem, 0), 1));\n+\n+  ml->insn = insn;\n+  ml->mem = mem;\n+  ml->next = next_memlist;\n+\n+  return ml;\n+}\n+\n+/* Attempt to apply ADJUST to the stack adjusting insn INSN, as well\n+   as each of the memories in MEMLIST.  Return true on success.  */\n+\n+static int\n+try_apply_stack_adjustment (insn, memlist, new_adjust, delta)\n+     rtx insn;\n+     struct csa_memlist *memlist;\n+     HOST_WIDE_INT new_adjust, delta;\n+{\n+  struct csa_memlist *ml;\n+  rtx set;\n+\n+  /* We know INSN matches single_set_for_csa, because that's what we\n+     recognized earlier.  However, if INSN is not single_set, it is\n+     doing double duty as a barrier for frame pointer memory accesses,\n+     which we are not recording.  Therefore, an adjust insn that is not\n+     single_set may not have a positive delta applied.  */\n+\n+  if (delta > 0 && ! single_set (insn))\n+    return 0;\n+  set = single_set_for_csa (insn);\n+  validate_change (insn, &XEXP (SET_SRC (set), 1), GEN_INT (new_adjust), 1);\n+\n+  for (ml = memlist; ml ; ml = ml->next)\n+    {\n+      HOST_WIDE_INT c = ml->sp_offset - delta;\n+\n+      /* Don't reference memory below the stack pointer.  */\n+      if (c < 0)\n+\t{\n+\t  cancel_changes (0);\n+\t  return 0;\n+\t}\n+\n+      validate_change (ml->insn, &XEXP (ml->mem, 0),\n+\t\t       plus_constant (stack_pointer_rtx, c), 1);\n+    }\n+\n+  if (apply_change_group ())\n+    {\n+      /* Succeeded.  Update our knowledge of the memory references.  */\n+      for (ml = memlist; ml ; ml = ml->next)\n+\tml->sp_offset -= delta;\n+\n+      return 1;\n+    }\n+  else\n+    return 0;\n+}\n+\n+/* Subroutine of combine_stack_adjustments, called for each basic block.  */\n+\n+static void \n+combine_stack_adjustments_for_block (bb)\n+     basic_block bb;\n+{\n+  HOST_WIDE_INT last_sp_adjust = 0;\n+  rtx last_sp_set = NULL_RTX;\n+  struct csa_memlist *memlist = NULL;\n+  rtx pending_delete;\n+  rtx insn, next;\n+\n+  for (insn = bb->head; ; insn = next)\n+    {\n+      rtx set;\n+\n+      pending_delete = NULL_RTX;\n+      next = NEXT_INSN (insn);\n+\n+      if (GET_RTX_CLASS (GET_CODE (insn)) != 'i')\n+\tgoto processed;\n+\n+      set = single_set_for_csa (insn);\n+      if (set)\n+\t{\n+\t  rtx dest = SET_DEST (set);\n+\t  rtx src = SET_SRC (set);\n+\n+\t  /* Find constant additions to the stack pointer.  */\n+\t  if (dest == stack_pointer_rtx\n+\t      && GET_CODE (src) == PLUS\n+\t      && XEXP (src, 0) == stack_pointer_rtx\n+\t      && GET_CODE (XEXP (src, 1)) == CONST_INT)\n+\t    {\n+\t      HOST_WIDE_INT this_adjust = INTVAL (XEXP (src, 1));\n+\n+\t      /* If we've not seen an adjustment previously, record\n+\t\t it now and continue.  */\n+\t      if (! last_sp_set)\n+\t\t{\n+\t\t  last_sp_set = insn;\n+\t\t  last_sp_adjust = this_adjust;\n+\t\t  goto processed;\n+\t\t}\n+\n+\t      /* If not all recorded memrefs can be adjusted, or the\n+\t\t adjustment is now too large for a constant addition,\n+\t\t we cannot merge the two stack adjustments.  */\n+\t      if (! try_apply_stack_adjustment (last_sp_set, memlist,\n+\t\t\t\t\t\tlast_sp_adjust + this_adjust,\n+\t\t\t\t\t\tthis_adjust))\n+\t\t{\n+\t\t  free_csa_memlist (memlist);\n+\t\t  memlist = NULL;\n+\t\t  last_sp_set = insn;\n+\t\t  last_sp_adjust = this_adjust;\n+\t\t  goto processed;\n+\t\t}\n+\n+\t      /* It worked!  */\n+\t      pending_delete = insn;\n+\t      last_sp_adjust += this_adjust;\n+\n+\t      /* If, by some accident, the adjustments cancel out,\n+\t\t delete both insns and start from scratch.  */\n+\t      if (last_sp_adjust == 0)\n+\t\t{\n+\t\t  if (last_sp_set == bb->head)\n+\t\t    bb->head = NEXT_INSN (last_sp_set);\n+\t\t  flow_delete_insn (last_sp_set);\n+\n+\t\t  free_csa_memlist (memlist);\n+\t\t  memlist = NULL;\n+\t\t  last_sp_set = NULL_RTX;\n+\t\t}\n+\n+\t      goto processed;\n+\t    }\n+\n+\t  /* Find loads from stack memory and record them.  */\n+\t  if (last_sp_set && stack_memref_p (src))\n+\t    {\n+\t      memlist = record_one_stack_memref (insn, src, memlist);\n+\t      goto processed;\n+\t    }\n+\n+\t  /* Find stores to stack memory and record them.  */\n+\t  if (last_sp_set && stack_memref_p (dest))\n+\t    {\n+\t      memlist = record_one_stack_memref (insn, dest, memlist);\n+\t      goto processed;\n+\t    }\n+\n+\t  /* Find a predecrement of exactly the previous adjustment and\n+\t     turn it into a direct store.  Obviously we can't do this if\n+\t     there were any intervening uses of the stack pointer.  */\n+\t  if (memlist == NULL\n+\t      && last_sp_adjust == GET_MODE_SIZE (GET_MODE (dest))\n+\t      && GET_CODE (dest) == MEM\n+\t      && GET_CODE (XEXP (dest, 0)) == PRE_DEC\n+\t      && XEXP (XEXP (dest, 0), 0) == stack_pointer_rtx\n+\t      && validate_change (insn, &SET_DEST (set),\n+\t\t\t\t  change_address (dest, VOIDmode,\n+\t\t\t\t\t\t  stack_pointer_rtx), 0))\n+\t    {\n+\t      if (last_sp_set == bb->head)\n+\t\tbb->head = NEXT_INSN (last_sp_set);\n+\t      flow_delete_insn (last_sp_set);\n+\n+\t      free_csa_memlist (memlist);\n+\t      memlist = NULL;\n+\t      last_sp_set = NULL_RTX;\n+\t      last_sp_adjust = 0;\n+\t      goto processed;\n+\t    }\n+\t}\n+\n+      /* Otherwise, we were not able to process the instruction. \n+\t Do not continue collecting data across such a one.  */\n+      if (last_sp_set\n+\t  && (GET_CODE (insn) == CALL_INSN\n+\t      || reg_mentioned_p (stack_pointer_rtx, PATTERN (insn))))\n+\t{\n+\t  free_csa_memlist (memlist);\n+\t  memlist = NULL;\n+\t  last_sp_set = NULL_RTX;\n+\t  last_sp_adjust = 0;\n+\t}\n+\n+    processed:\n+      if (insn == bb->end)\n+\tbreak;\n+\n+      if (pending_delete)\n+\tflow_delete_insn (pending_delete);\n+    }\n+\n+  if (pending_delete)\n+    {\n+      bb->end = PREV_INSN (pending_delete);\n+      flow_delete_insn (pending_delete);\n+    }\n+}"}, {"sha": "6629667b1acbcdae69f2cc21db30547a9a87f495", "filename": "gcc/rtl.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e7f0a48cf6e9c5d1435f3da96990c5d299f4953/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e7f0a48cf6e9c5d1435f3da96990c5d299f4953/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=1e7f0a48cf6e9c5d1435f3da96990c5d299f4953", "patch": "@@ -1580,6 +1580,7 @@ extern void delete_null_pointer_checks\tPARAMS ((rtx));\n #ifdef BUFSIZ\n extern void regmove_optimize\t\tPARAMS ((rtx, int, FILE *));\n #endif\n+extern void combine_stack_adjustments\tPARAMS ((void));\n \n /* In reorg.c */\n #ifdef BUFSIZ"}, {"sha": "fa7494d0e21f7ce66dbc1f4b295ba2e449eef010", "filename": "gcc/toplev.c", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1e7f0a48cf6e9c5d1435f3da96990c5d299f4953/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1e7f0a48cf6e9c5d1435f3da96990c5d299f4953/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=1e7f0a48cf6e9c5d1435f3da96990c5d299f4953", "patch": "@@ -3547,12 +3547,16 @@ rest_of_compilation (decl)\n \n   if (optimize)\n     {\n-      TIMEVAR\n-\t(flow2_time,\n-\t {\n-\t   cleanup_cfg (insns);\n-\t   life_analysis (insns, max_reg_num (), rtl_dump_file, 1);\n-\t });\n+      TIMEVAR (flow2_time, { cleanup_cfg (insns); });\n+\n+#ifndef ACCUMULATE_OUTGOING_ARGS\n+      TIMEVAR (flow2_time, { combine_stack_adjustments (); });\n+#endif\n+\n+      TIMEVAR (flow2_time, \n+\t       {\n+\t\t life_analysis (insns, max_reg_num (), rtl_dump_file, 1);\n+\t       });\n \n       if (ggc_p)\n \tggc_collect ();"}]}