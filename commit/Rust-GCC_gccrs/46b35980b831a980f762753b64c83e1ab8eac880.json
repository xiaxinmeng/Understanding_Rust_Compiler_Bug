{"sha": "46b35980b831a980f762753b64c83e1ab8eac880", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDZiMzU5ODBiODMxYTk4MGY3NjI3NTNiNjRjODNlMWFiOGVhYzg4MA==", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2015-05-12T20:01:47Z"}, "committer": {"name": "Andrew Macleod", "email": "amacleod@gcc.gnu.org", "date": "2015-05-12T20:01:47Z"}, "message": "re PR target/65697 (__atomic memory barriers not strong enough for __sync builtins)\n\n2015-05-12  Andrew MacLeod  <amacleod@redhat.com>\n\n\tPR target/65697\n\t* coretypes.h (MEMMODEL_SYNC, MEMMODEL_BASE_MASK): New macros.\n\t(enum memmodel): Add SYNC_{ACQUIRE,RELEASE,SEQ_CST}.\n\t* tree.h (memmodel_from_int, memmodel_base, is_mm_relaxed,\n\tis_mm_consume,is_mm_acquire, is_mm_release, is_mm_acq_rel,\n\tis_mm_seq_cst, is_mm_sync): New accessor functions.\n\t* builtins.c (expand_builtin_sync_operation,\n\texpand_builtin_compare_and_swap): Use MEMMODEL_SYNC_SEQ_CST.\n\t(expand_builtin_sync_lock_release): Use MEMMODEL_SYNC_RELEASE.\n\t(get_memmodel,  expand_builtin_atomic_compare_exchange,\n\texpand_builtin_atomic_load, expand_builtin_atomic_store,\n\texpand_builtin_atomic_clear): Use new accessor routines.\n\t(expand_builtin_sync_synchronize): Use MEMMODEL_SYNC_SEQ_CST.\n\t* optabs.c (expand_compare_and_swap_loop): Use MEMMODEL_SYNC_SEQ_CST.\n\t(maybe_emit_sync_lock_test_and_set): Use new accessors and\n\tMEMMODEL_SYNC_ACQUIRE.\n\t(expand_sync_lock_test_and_set): Use MEMMODEL_SYNC_ACQUIRE.\n\t(expand_mem_thread_fence, expand_mem_signal_fence, expand_atomic_load,\n\texpand_atomic_store): Use new accessors.\n\t* emit-rtl.c (need_atomic_barrier_p): Add additional enum cases.\n\t* tsan.c (instrument_builtin_call): Update check for memory model beyond\n\tfinal enum to use MEMMODEL_LAST.\n\t* c-family/c-common.c: Use new accessor for memmodel_base.\n\t* config/aarch64/aarch64.c (aarch64_expand_compare_and_swap): Use new\n\taccessors.\n\t* config/aarch64/atomics.md (atomic_load<mode>,atomic_store<mode>,\n\tarch64_load_exclusive<mode>, aarch64_store_exclusive<mode>,\n\tmem_thread_fence, *dmb): Likewise.\n\t* config/alpha/alpha.c (alpha_split_compare_and_swap,\n\talpha_split_compare_and_swap_12): Likewise.\n\t* config/arm/arm.c (arm_expand_compare_and_swap,\n\tarm_split_compare_and_swap, arm_split_atomic_op): Likewise.\n\t* config/arm/sync.md (atomic_load<mode>, atomic_store<mode>,\n\tatomic_loaddi): Likewise.\n\t* config/i386/i386.c (ix86_destroy_cost_data, ix86_memmodel_check):\n\tLikewise.\n\t* config/i386/sync.md (mem_thread_fence, atomic_store<mode>): Likewise.\n\t* config/ia64/ia64.c (ia64_expand_atomic_op): Add new memmodel cases and\n\tuse new accessors.\n\t* config/ia64/sync.md (mem_thread_fence, atomic_load<mode>,\n\tatomic_store<mode>, atomic_compare_and_swap<mode>,\n\tatomic_exchange<mode>): Use new accessors.\n\t* config/mips/mips.c (mips_process_sync_loop): Likewise.\n\t* config/pa/pa.md (atomic_loaddi, atomic_storedi): Likewise.\n\t* config/rs6000/rs6000.c (rs6000_pre_atomic_barrier,\n\trs6000_post_atomic_barrier): Add new cases.\n\t(rs6000_expand_atomic_compare_and_swap): Use new accessors.\n\t* config/rs6000/sync.md (mem_thread_fence): Add new cases.\n\t(atomic_load<mode>): Add new cases and use new accessors.\n\t(store_quadpti): Add new cases.\n\t* config/s390/s390.md (mem_thread_fence, atomic_store<mode>): Use new\n\taccessors.\n\t* config/sparc/sparc.c (sparc_emit_membar_for_model): Use new accessors.\n\t* doc/extend.texi: Update docs to indicate 16 bits are used for memory\n\tmodel, not 8.\n\nFrom-SVN: r223096", "tree": {"sha": "46ecdae55c6167da9fe60411b19d39051ad5e4c1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/46ecdae55c6167da9fe60411b19d39051ad5e4c1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/46b35980b831a980f762753b64c83e1ab8eac880", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46b35980b831a980f762753b64c83e1ab8eac880", "html_url": "https://github.com/Rust-GCC/gccrs/commit/46b35980b831a980f762753b64c83e1ab8eac880", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46b35980b831a980f762753b64c83e1ab8eac880/comments", "author": null, "committer": null, "parents": [{"sha": "e7a677ca1a53221276c0b382811c0351d381b35a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e7a677ca1a53221276c0b382811c0351d381b35a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e7a677ca1a53221276c0b382811c0351d381b35a"}], "stats": {"total": 417, "additions": 274, "deletions": 143}, "files": [{"sha": "4f55ef01935f7787eb72fe6f55cdbcf0e62e1b8a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46b35980b831a980f762753b64c83e1ab8eac880/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46b35980b831a980f762753b64c83e1ab8eac880/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=46b35980b831a980f762753b64c83e1ab8eac880", "patch": "@@ -1,3 +1,61 @@\n+2015-05-12  Andrew MacLeod  <amacleod@redhat.com>\n+\n+\tPR target/65697\n+\t* coretypes.h (MEMMODEL_SYNC, MEMMODEL_BASE_MASK): New macros.\n+\t(enum memmodel): Add SYNC_{ACQUIRE,RELEASE,SEQ_CST}.\n+\t* tree.h (memmodel_from_int, memmodel_base, is_mm_relaxed,\n+\tis_mm_consume,is_mm_acquire, is_mm_release, is_mm_acq_rel,\n+\tis_mm_seq_cst, is_mm_sync): New accessor functions.\n+\t* builtins.c (expand_builtin_sync_operation,\n+\texpand_builtin_compare_and_swap): Use MEMMODEL_SYNC_SEQ_CST.\n+\t(expand_builtin_sync_lock_release): Use MEMMODEL_SYNC_RELEASE.\n+\t(get_memmodel,  expand_builtin_atomic_compare_exchange,\n+\texpand_builtin_atomic_load, expand_builtin_atomic_store,\n+\texpand_builtin_atomic_clear): Use new accessor routines.\n+\t(expand_builtin_sync_synchronize): Use MEMMODEL_SYNC_SEQ_CST.\n+\t* optabs.c (expand_compare_and_swap_loop): Use MEMMODEL_SYNC_SEQ_CST.\n+\t(maybe_emit_sync_lock_test_and_set): Use new accessors and\n+\tMEMMODEL_SYNC_ACQUIRE.\n+\t(expand_sync_lock_test_and_set): Use MEMMODEL_SYNC_ACQUIRE.\n+\t(expand_mem_thread_fence, expand_mem_signal_fence, expand_atomic_load,\n+\texpand_atomic_store): Use new accessors.\n+\t* emit-rtl.c (need_atomic_barrier_p): Add additional enum cases.\n+\t* tsan.c (instrument_builtin_call): Update check for memory model beyond\n+\tfinal enum to use MEMMODEL_LAST.\n+\t* c-family/c-common.c: Use new accessor for memmodel_base.\n+\t* config/aarch64/aarch64.c (aarch64_expand_compare_and_swap): Use new\n+\taccessors.\n+\t* config/aarch64/atomics.md (atomic_load<mode>,atomic_store<mode>,\n+\tarch64_load_exclusive<mode>, aarch64_store_exclusive<mode>,\n+\tmem_thread_fence, *dmb): Likewise.\n+\t* config/alpha/alpha.c (alpha_split_compare_and_swap,\n+\talpha_split_compare_and_swap_12): Likewise.\n+\t* config/arm/arm.c (arm_expand_compare_and_swap,\n+\tarm_split_compare_and_swap, arm_split_atomic_op): Likewise.\n+\t* config/arm/sync.md (atomic_load<mode>, atomic_store<mode>,\n+\tatomic_loaddi): Likewise.\n+\t* config/i386/i386.c (ix86_destroy_cost_data, ix86_memmodel_check):\n+\tLikewise.\n+\t* config/i386/sync.md (mem_thread_fence, atomic_store<mode>): Likewise.\n+\t* config/ia64/ia64.c (ia64_expand_atomic_op): Add new memmodel cases and\n+\tuse new accessors.\n+\t* config/ia64/sync.md (mem_thread_fence, atomic_load<mode>,\n+\tatomic_store<mode>, atomic_compare_and_swap<mode>,\n+\tatomic_exchange<mode>): Use new accessors.\n+\t* config/mips/mips.c (mips_process_sync_loop): Likewise.\n+\t* config/pa/pa.md (atomic_loaddi, atomic_storedi): Likewise.\n+\t* config/rs6000/rs6000.c (rs6000_pre_atomic_barrier,\n+\trs6000_post_atomic_barrier): Add new cases.\n+\t(rs6000_expand_atomic_compare_and_swap): Use new accessors.\n+\t* config/rs6000/sync.md (mem_thread_fence): Add new cases.\n+\t(atomic_load<mode>): Add new cases and use new accessors.\n+\t(store_quadpti): Add new cases.\n+\t* config/s390/s390.md (mem_thread_fence, atomic_store<mode>): Use new\n+\taccessors.\n+\t* config/sparc/sparc.c (sparc_emit_membar_for_model): Use new accessors.\n+\t* doc/extend.texi: Update docs to indicate 16 bits are used for memory\n+\tmodel, not 8.\n+\n 2015-05-12  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* ipa-devirt.c (type_with_linkage_p): New function."}, {"sha": "95445247c128cb2ac5fcccd9009ad22e3ed5eec3", "filename": "gcc/builtins.c", "status": "modified", "additions": 12, "deletions": 16, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46b35980b831a980f762753b64c83e1ab8eac880/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46b35980b831a980f762753b64c83e1ab8eac880/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=46b35980b831a980f762753b64c83e1ab8eac880", "patch": "@@ -5271,7 +5271,7 @@ expand_builtin_sync_operation (machine_mode mode, tree exp,\n   mem = get_builtin_sync_mem (CALL_EXPR_ARG (exp, 0), mode);\n   val = expand_expr_force_mode (CALL_EXPR_ARG (exp, 1), mode);\n \n-  return expand_atomic_fetch_op (target, mem, val, code, MEMMODEL_SEQ_CST,\n+  return expand_atomic_fetch_op (target, mem, val, code, MEMMODEL_SYNC_SEQ_CST,\n \t\t\t\t after);\n }\n \n@@ -5301,8 +5301,8 @@ expand_builtin_compare_and_swap (machine_mode mode, tree exp,\n \tpoval = &target;\n     }\n   if (!expand_atomic_compare_and_swap (pbool, poval, mem, old_val, new_val,\n-\t\t\t\t       false, MEMMODEL_SEQ_CST,\n-\t\t\t\t       MEMMODEL_SEQ_CST))\n+\t\t\t\t       false, MEMMODEL_SYNC_SEQ_CST,\n+\t\t\t\t       MEMMODEL_SYNC_SEQ_CST))\n     return NULL_RTX;\n \n   return target;\n@@ -5337,7 +5337,7 @@ expand_builtin_sync_lock_release (machine_mode mode, tree exp)\n   /* Expand the operands.  */\n   mem = get_builtin_sync_mem (CALL_EXPR_ARG (exp, 0), mode);\n \n-  expand_atomic_store (mem, const0_rtx, MEMMODEL_RELEASE, true);\n+  expand_atomic_store (mem, const0_rtx, MEMMODEL_SYNC_RELEASE, true);\n }\n \n /* Given an integer representing an ``enum memmodel'', verify its\n@@ -5366,7 +5366,8 @@ get_memmodel (tree exp)\n       return MEMMODEL_SEQ_CST;\n     }\n \n-  if ((INTVAL (op) & MEMMODEL_MASK) >= MEMMODEL_LAST)\n+  /* Should never see a user explicit SYNC memodel model, so >= LAST works. */\n+  if (memmodel_base (val) >= MEMMODEL_LAST)\n     {\n       warning (OPT_Winvalid_memory_model,\n \t       \"invalid memory model argument to builtin\");\n@@ -5433,8 +5434,7 @@ expand_builtin_atomic_compare_exchange (machine_mode mode, tree exp,\n       success = MEMMODEL_SEQ_CST;\n     }\n  \n-  if ((failure & MEMMODEL_MASK) == MEMMODEL_RELEASE\n-      || (failure & MEMMODEL_MASK) == MEMMODEL_ACQ_REL)\n+  if (is_mm_release (failure) || is_mm_acq_rel (failure))\n     {\n       warning (OPT_Winvalid_memory_model,\n \t       \"invalid failure memory model for \"\n@@ -5496,8 +5496,7 @@ expand_builtin_atomic_load (machine_mode mode, tree exp, rtx target)\n   enum memmodel model;\n \n   model = get_memmodel (CALL_EXPR_ARG (exp, 1));\n-  if ((model & MEMMODEL_MASK) == MEMMODEL_RELEASE\n-      || (model & MEMMODEL_MASK) == MEMMODEL_ACQ_REL)\n+  if (is_mm_release (model) || is_mm_acq_rel (model))\n     {\n       warning (OPT_Winvalid_memory_model,\n \t       \"invalid memory model for %<__atomic_load%>\");\n@@ -5526,9 +5525,8 @@ expand_builtin_atomic_store (machine_mode mode, tree exp)\n   enum memmodel model;\n \n   model = get_memmodel (CALL_EXPR_ARG (exp, 2));\n-  if ((model & MEMMODEL_MASK) != MEMMODEL_RELAXED\n-      && (model & MEMMODEL_MASK) != MEMMODEL_SEQ_CST\n-      && (model & MEMMODEL_MASK) != MEMMODEL_RELEASE)\n+  if (!(is_mm_relaxed (model) || is_mm_seq_cst (model)\n+\t|| is_mm_release (model)))\n     {\n       warning (OPT_Winvalid_memory_model,\n \t       \"invalid memory model for %<__atomic_store%>\");\n@@ -5635,9 +5633,7 @@ expand_builtin_atomic_clear (tree exp)\n   mem = get_builtin_sync_mem (CALL_EXPR_ARG (exp, 0), mode);\n   model = get_memmodel (CALL_EXPR_ARG (exp, 1));\n \n-  if ((model & MEMMODEL_MASK) == MEMMODEL_CONSUME\n-      || (model & MEMMODEL_MASK) == MEMMODEL_ACQUIRE\n-      || (model & MEMMODEL_MASK) == MEMMODEL_ACQ_REL)\n+  if (is_mm_consume (model) || is_mm_acquire (model) || is_mm_acq_rel (model))\n     {\n       warning (OPT_Winvalid_memory_model,\n \t       \"invalid memory model for %<__atomic_store%>\");\n@@ -5833,7 +5829,7 @@ expand_builtin_atomic_signal_fence (tree exp)\n static void\n expand_builtin_sync_synchronize (void)\n {\n-  expand_mem_thread_fence (MEMMODEL_SEQ_CST);\n+  expand_mem_thread_fence (MEMMODEL_SYNC_SEQ_CST);\n }\n \n static rtx"}, {"sha": "7e5ac72900b6f83e58f5dee45b098ef32196a4fb", "filename": "gcc/c-family/c-common.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46b35980b831a980f762753b64c83e1ab8eac880/gcc%2Fc-family%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46b35980b831a980f762753b64c83e1ab8eac880/gcc%2Fc-family%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.c?ref=46b35980b831a980f762753b64c83e1ab8eac880", "patch": "@@ -10792,7 +10792,7 @@ get_atomic_generic_size (location_t loc, tree function,\n       if (TREE_CODE (p) == INTEGER_CST)\n         {\n \t  int i = tree_to_uhwi (p);\n-\t  if (i < 0 || (i & MEMMODEL_MASK) >= MEMMODEL_LAST)\n+\t  if (i < 0 || (memmodel_base (i) >= MEMMODEL_LAST))\n \t    {\n \t      warning_at (loc, OPT_Winvalid_memory_model,\n \t\t\t  \"invalid memory model argument %d of %qE\", x + 1,"}, {"sha": "7f0cc0dad1a7126d2062ac1a856c331a4c8e3395", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46b35980b831a980f762753b64c83e1ab8eac880/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46b35980b831a980f762753b64c83e1ab8eac880/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=46b35980b831a980f762753b64c83e1ab8eac880", "patch": "@@ -9203,8 +9203,8 @@ aarch64_expand_compare_and_swap (rtx operands[])\n      unlikely event of fail being ACQUIRE and succ being RELEASE we need to\n      promote succ to ACQ_REL so that we don't lose the acquire semantics.  */\n \n-  if (INTVAL (mod_f) == MEMMODEL_ACQUIRE\n-      && INTVAL (mod_s) == MEMMODEL_RELEASE)\n+  if (is_mm_acquire (memmodel_from_int (INTVAL (mod_f)))\n+      && is_mm_release (memmodel_from_int (INTVAL (mod_s))))\n     mod_s = GEN_INT (MEMMODEL_ACQ_REL);\n \n   switch (mode)"}, {"sha": "1a38ac0e237ba5418bb7212e1e5d7c3589c263f9", "filename": "gcc/config/aarch64/atomics.md", "status": "modified", "additions": 14, "deletions": 24, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46b35980b831a980f762753b64c83e1ab8eac880/gcc%2Fconfig%2Faarch64%2Fatomics.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46b35980b831a980f762753b64c83e1ab8eac880/gcc%2Fconfig%2Faarch64%2Fatomics.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Fatomics.md?ref=46b35980b831a980f762753b64c83e1ab8eac880", "patch": "@@ -260,10 +260,8 @@\n       UNSPECV_LDA))]\n   \"\"\n   {\n-    enum memmodel model = (enum memmodel) INTVAL (operands[2]);\n-    if (model == MEMMODEL_RELAXED\n-\t|| model == MEMMODEL_CONSUME\n-\t|| model == MEMMODEL_RELEASE)\n+    enum memmodel model = memmodel_from_int (INTVAL (operands[2]));\n+    if (is_mm_relaxed (model) || is_mm_consume (model) || is_mm_release (model))\n       return \"ldr<atomic_sfx>\\t%<w>0, %1\";\n     else\n       return \"ldar<atomic_sfx>\\t%<w>0, %1\";\n@@ -278,10 +276,8 @@\n       UNSPECV_STL))]\n   \"\"\n   {\n-    enum memmodel model = (enum memmodel) INTVAL (operands[2]);\n-    if (model == MEMMODEL_RELAXED\n-\t|| model == MEMMODEL_CONSUME\n-\t|| model == MEMMODEL_ACQUIRE)\n+    enum memmodel model = memmodel_from_int (INTVAL (operands[2]));\n+    if (is_mm_relaxed (model) || is_mm_consume (model) || is_mm_acquire (model))\n       return \"str<atomic_sfx>\\t%<w>1, %0\";\n     else\n       return \"stlr<atomic_sfx>\\t%<w>1, %0\";\n@@ -297,10 +293,8 @@\n \tUNSPECV_LX)))]\n   \"\"\n   {\n-    enum memmodel model = (enum memmodel) INTVAL (operands[2]);\n-    if (model == MEMMODEL_RELAXED\n-\t|| model == MEMMODEL_CONSUME\n-\t|| model == MEMMODEL_RELEASE)\n+    enum memmodel model = memmodel_from_int (INTVAL (operands[2]));\n+    if (is_mm_relaxed (model) || is_mm_consume (model) || is_mm_release (model))\n       return \"ldxr<atomic_sfx>\\t%w0, %1\";\n     else\n       return \"ldaxr<atomic_sfx>\\t%w0, %1\";\n@@ -315,10 +309,8 @@\n       UNSPECV_LX))]\n   \"\"\n   {\n-    enum memmodel model = (enum memmodel) INTVAL (operands[2]);\n-    if (model == MEMMODEL_RELAXED\n-\t|| model == MEMMODEL_CONSUME\n-\t|| model == MEMMODEL_RELEASE)\n+    enum memmodel model = memmodel_from_int (INTVAL (operands[2]));\n+    if (is_mm_relaxed (model) || is_mm_consume (model) || is_mm_release (model))\n       return \"ldxr\\t%<w>0, %1\";\n     else\n       return \"ldaxr\\t%<w>0, %1\";\n@@ -335,10 +327,8 @@\n       UNSPECV_SX))]\n   \"\"\n   {\n-    enum memmodel model = (enum memmodel) INTVAL (operands[3]);\n-    if (model == MEMMODEL_RELAXED\n-\t|| model == MEMMODEL_CONSUME\n-\t|| model == MEMMODEL_ACQUIRE)\n+    enum memmodel model = memmodel_from_int (INTVAL (operands[3]));\n+    if (is_mm_relaxed (model) || is_mm_consume (model) || is_mm_acquire (model))\n       return \"stxr<atomic_sfx>\\t%w0, %<w>2, %1\";\n     else\n       return \"stlxr<atomic_sfx>\\t%w0, %<w>2, %1\";\n@@ -349,8 +339,8 @@\n   [(match_operand:SI 0 \"const_int_operand\" \"\")]\n   \"\"\n   {\n-    enum memmodel model = (enum memmodel) INTVAL (operands[0]);\n-    if (model != MEMMODEL_RELAXED && model != MEMMODEL_CONSUME)\n+    enum memmodel model = memmodel_from_int (INTVAL (operands[0]));\n+    if (!(is_mm_relaxed (model) || is_mm_consume (model)))\n       emit_insn (gen_dmb (operands[0]));\n     DONE;\n   }\n@@ -373,8 +363,8 @@\n      UNSPEC_MB))]\n   \"\"\n   {\n-    enum memmodel model = (enum memmodel) INTVAL (operands[1]);\n-    if (model == MEMMODEL_ACQUIRE)\n+    enum memmodel model = memmodel_from_int (INTVAL (operands[1]));\n+    if (is_mm_acquire (model))\n       return \"dmb\\\\tishld\";\n     else\n       return \"dmb\\\\tish\";"}, {"sha": "4af0dbec7a0c0841689de21e2bfee95b55b9804b", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46b35980b831a980f762753b64c83e1ab8eac880/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46b35980b831a980f762753b64c83e1ab8eac880/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=46b35980b831a980f762753b64c83e1ab8eac880", "patch": "@@ -4493,8 +4493,8 @@ alpha_split_compare_and_swap (rtx operands[])\n   oldval = operands[3];\n   newval = operands[4];\n   is_weak = (operands[5] != const0_rtx);\n-  mod_s = (enum memmodel) INTVAL (operands[6]);\n-  mod_f = (enum memmodel) INTVAL (operands[7]);\n+  mod_s = memmodel_from_int (INTVAL (operands[6]));\n+  mod_f = memmodel_from_int (INTVAL (operands[7]));\n   mode = GET_MODE (mem);\n \n   alpha_pre_atomic_barrier (mod_s);\n@@ -4532,12 +4532,12 @@ alpha_split_compare_and_swap (rtx operands[])\n       emit_unlikely_jump (x, label1);\n     }\n \n-  if (mod_f != MEMMODEL_RELAXED)\n+  if (!is_mm_relaxed (mod_f))\n     emit_label (XEXP (label2, 0));\n \n   alpha_post_atomic_barrier (mod_s);\n \n-  if (mod_f == MEMMODEL_RELAXED)\n+  if (is_mm_relaxed (mod_f))\n     emit_label (XEXP (label2, 0));\n }\n \n@@ -4598,8 +4598,8 @@ alpha_split_compare_and_swap_12 (rtx operands[])\n   newval = operands[4];\n   align = operands[5];\n   is_weak = (operands[6] != const0_rtx);\n-  mod_s = (enum memmodel) INTVAL (operands[7]);\n-  mod_f = (enum memmodel) INTVAL (operands[8]);\n+  mod_s = memmodel_from_int (INTVAL (operands[7]));\n+  mod_f = memmodel_from_int (INTVAL (operands[8]));\n   scratch = operands[9];\n   mode = GET_MODE (orig_mem);\n   addr = XEXP (orig_mem, 0);\n@@ -4651,12 +4651,12 @@ alpha_split_compare_and_swap_12 (rtx operands[])\n       emit_unlikely_jump (x, label1);\n     }\n \n-  if (mod_f != MEMMODEL_RELAXED)\n+  if (!is_mm_relaxed (mod_f))\n     emit_label (XEXP (label2, 0));\n \n   alpha_post_atomic_barrier (mod_s);\n \n-  if (mod_f == MEMMODEL_RELAXED)\n+  if (is_mm_relaxed (mod_f))\n     emit_label (XEXP (label2, 0));\n }\n "}, {"sha": "19b73853eeec3219e1badb35cb9f0594021671f1", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 16, "deletions": 20, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46b35980b831a980f762753b64c83e1ab8eac880/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46b35980b831a980f762753b64c83e1ab8eac880/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=46b35980b831a980f762753b64c83e1ab8eac880", "patch": "@@ -27461,8 +27461,8 @@ arm_expand_compare_and_swap (rtx operands[])\n      promote succ to ACQ_REL so that we don't lose the acquire semantics.  */\n \n   if (TARGET_HAVE_LDACQ\n-      && INTVAL (mod_f) == MEMMODEL_ACQUIRE\n-      && INTVAL (mod_s) == MEMMODEL_RELEASE)\n+      && is_mm_acquire (memmodel_from_int (INTVAL (mod_f)))\n+      && is_mm_release (memmodel_from_int (INTVAL (mod_s))))\n     mod_s = GEN_INT (MEMMODEL_ACQ_REL);\n \n   switch (mode)\n@@ -27535,20 +27535,18 @@ arm_split_compare_and_swap (rtx operands[])\n   oldval = operands[2];\n   newval = operands[3];\n   is_weak = (operands[4] != const0_rtx);\n-  mod_s = (enum memmodel) INTVAL (operands[5]);\n-  mod_f = (enum memmodel) INTVAL (operands[6]);\n+  mod_s = memmodel_from_int (INTVAL (operands[5]));\n+  mod_f = memmodel_from_int (INTVAL (operands[6]));\n   scratch = operands[7];\n   mode = GET_MODE (mem);\n \n   bool use_acquire = TARGET_HAVE_LDACQ\n-                     && !(mod_s == MEMMODEL_RELAXED\n-                          || mod_s == MEMMODEL_CONSUME\n-                          || mod_s == MEMMODEL_RELEASE);\n-\n+                     && !(is_mm_relaxed (mod_s) || is_mm_consume (mod_s)\n+\t\t\t  || is_mm_release (mod_s));\n+\t\t\n   bool use_release = TARGET_HAVE_LDACQ\n-                     && !(mod_s == MEMMODEL_RELAXED\n-                          || mod_s == MEMMODEL_CONSUME\n-                          || mod_s == MEMMODEL_ACQUIRE);\n+                     && !(is_mm_relaxed (mod_s) || is_mm_consume (mod_s)\n+\t\t\t  || is_mm_acquire (mod_s));\n \n   /* Checks whether a barrier is needed and emits one accordingly.  */\n   if (!(use_acquire || use_release))\n@@ -27586,36 +27584,34 @@ arm_split_compare_and_swap (rtx operands[])\n       emit_unlikely_jump (gen_rtx_SET (pc_rtx, x));\n     }\n \n-  if (mod_f != MEMMODEL_RELAXED)\n+  if (!is_mm_relaxed (mod_f))\n     emit_label (label2);\n \n   /* Checks whether a barrier is needed and emits one accordingly.  */\n   if (!(use_acquire || use_release))\n     arm_post_atomic_barrier (mod_s);\n \n-  if (mod_f == MEMMODEL_RELAXED)\n+  if (is_mm_relaxed (mod_f))\n     emit_label (label2);\n }\n \n void\n arm_split_atomic_op (enum rtx_code code, rtx old_out, rtx new_out, rtx mem,\n \t\t     rtx value, rtx model_rtx, rtx cond)\n {\n-  enum memmodel model = (enum memmodel) INTVAL (model_rtx);\n+  enum memmodel model = memmodel_from_int (INTVAL (model_rtx));\n   machine_mode mode = GET_MODE (mem);\n   machine_mode wmode = (mode == DImode ? DImode : SImode);\n   rtx_code_label *label;\n   rtx x;\n \n   bool use_acquire = TARGET_HAVE_LDACQ\n-                     && !(model == MEMMODEL_RELAXED\n-                          || model == MEMMODEL_CONSUME\n-                          || model == MEMMODEL_RELEASE);\n+                     && !(is_mm_relaxed (model) || is_mm_consume (model)\n+\t\t\t  || is_mm_release (model));\n \n   bool use_release = TARGET_HAVE_LDACQ\n-                     && !(model == MEMMODEL_RELAXED\n-                          || model == MEMMODEL_CONSUME\n-                          || model == MEMMODEL_ACQUIRE);\n+                     && !(is_mm_relaxed (model) || is_mm_consume (model)\n+\t\t\t  || is_mm_acquire (model));\n \n   /* Checks whether a barrier is needed and emits one accordingly.  */\n   if (!(use_acquire || use_release))"}, {"sha": "44cda61d2738c4be61ee12dd5055e5ecfd471a93", "filename": "gcc/config/arm/sync.md", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46b35980b831a980f762753b64c83e1ab8eac880/gcc%2Fconfig%2Farm%2Fsync.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46b35980b831a980f762753b64c83e1ab8eac880/gcc%2Fconfig%2Farm%2Fsync.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fsync.md?ref=46b35980b831a980f762753b64c83e1ab8eac880", "patch": "@@ -73,10 +73,8 @@\n       VUNSPEC_LDA))]\n   \"TARGET_HAVE_LDACQ\"\n   {\n-    enum memmodel model = (enum memmodel) INTVAL (operands[2]);\n-    if (model == MEMMODEL_RELAXED\n-        || model == MEMMODEL_CONSUME\n-        || model == MEMMODEL_RELEASE)\n+    enum memmodel model = memmodel_from_int (INTVAL (operands[2]));\n+    if (is_mm_relaxed (model) || is_mm_consume (model) || is_mm_release (model))\n       return \\\"ldr<sync_sfx>\\\\t%0, %1\\\";\n     else\n       return \\\"lda<sync_sfx>\\\\t%0, %1\\\";\n@@ -91,10 +89,8 @@\n       VUNSPEC_STL))]\n   \"TARGET_HAVE_LDACQ\"\n   {\n-    enum memmodel model = (enum memmodel) INTVAL (operands[2]);\n-    if (model == MEMMODEL_RELAXED\n-        || model == MEMMODEL_CONSUME\n-        || model == MEMMODEL_ACQUIRE)\n+    enum memmodel model = memmodel_from_int (INTVAL (operands[2]));\n+    if (is_mm_relaxed (model) || is_mm_consume (model) || is_mm_acquire (model))\n       return \\\"str<sync_sfx>\\t%1, %0\\\";\n     else\n       return \\\"stl<sync_sfx>\\t%1, %0\\\";\n@@ -110,10 +106,10 @@\n    (match_operand:SI 2 \"const_int_operand\")]\t\t;; model\n   \"TARGET_HAVE_LDREXD && ARM_DOUBLEWORD_ALIGN\"\n {\n-  enum memmodel model = (enum memmodel) INTVAL (operands[2]);\n+  enum memmodel model = memmodel_from_int (INTVAL (operands[2]));\n   expand_mem_thread_fence (model);\n   emit_insn (gen_atomic_loaddi_1 (operands[0], operands[1]));\n-  if (model == MEMMODEL_SEQ_CST)\n+  if (is_mm_seq_cst (model))\n     expand_mem_thread_fence (model);\n   DONE;\n })"}, {"sha": "d87dd01f0a7087696008b7f158d2d55c156f2b91", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46b35980b831a980f762753b64c83e1ab8eac880/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46b35980b831a980f762753b64c83e1ab8eac880/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=46b35980b831a980f762753b64c83e1ab8eac880", "patch": "@@ -51222,7 +51222,7 @@ ix86_destroy_cost_data (void *data)\n static unsigned HOST_WIDE_INT\n ix86_memmodel_check (unsigned HOST_WIDE_INT val)\n {\n-  unsigned HOST_WIDE_INT model = val & MEMMODEL_MASK;\n+  enum memmodel model = memmodel_from_int (val);\n   bool strong;\n \n   if (val & ~(unsigned HOST_WIDE_INT)(IX86_HLE_ACQUIRE|IX86_HLE_RELEASE\n@@ -51233,14 +51233,14 @@ ix86_memmodel_check (unsigned HOST_WIDE_INT val)\n \t       \"Unknown architecture specific memory model\");\n       return MEMMODEL_SEQ_CST;\n     }\n-  strong = (model == MEMMODEL_ACQ_REL || model == MEMMODEL_SEQ_CST);\n-  if (val & IX86_HLE_ACQUIRE && !(model == MEMMODEL_ACQUIRE || strong))\n+  strong = (is_mm_acq_rel (model) || is_mm_seq_cst (model));\n+  if (val & IX86_HLE_ACQUIRE && !(is_mm_acquire (model) || strong))\n     {\n       warning (OPT_Winvalid_memory_model,\n               \"HLE_ACQUIRE not used with ACQUIRE or stronger memory model\");\n       return MEMMODEL_SEQ_CST | IX86_HLE_ACQUIRE;\n     }\n-   if (val & IX86_HLE_RELEASE && !(model == MEMMODEL_RELEASE || strong))\n+  if (val & IX86_HLE_RELEASE && !(is_mm_release (model) || strong))\n     {\n       warning (OPT_Winvalid_memory_model,\n               \"HLE_RELEASE not used with RELEASE or stronger memory model\");"}, {"sha": "59573d40a999ae87388428fdb6e7a29642fdf2ff", "filename": "gcc/config/i386/sync.md", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46b35980b831a980f762753b64c83e1ab8eac880/gcc%2Fconfig%2Fi386%2Fsync.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46b35980b831a980f762753b64c83e1ab8eac880/gcc%2Fconfig%2Fi386%2Fsync.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsync.md?ref=46b35980b831a980f762753b64c83e1ab8eac880", "patch": "@@ -105,11 +105,11 @@\n   [(match_operand:SI 0 \"const_int_operand\")]\t\t;; model\n   \"\"\n {\n-  enum memmodel model = (enum memmodel) (INTVAL (operands[0]) & MEMMODEL_MASK);\n+  enum memmodel model = memmodel_from_int (INTVAL (operands[0]));\n \n   /* Unless this is a SEQ_CST fence, the i386 memory model is strong\n      enough not to require barriers of any kind.  */\n-  if (model == MEMMODEL_SEQ_CST)\n+  if (is_mm_seq_cst (model))\n     {\n       rtx (*mfence_insn)(rtx);\n       rtx mem;\n@@ -217,7 +217,7 @@\n \t\t       UNSPEC_STA))]\n   \"\"\n {\n-  enum memmodel model = (enum memmodel) (INTVAL (operands[2]) & MEMMODEL_MASK);\n+  enum memmodel model = memmodel_from_int (INTVAL (operands[2]));\n \n   if (<MODE>mode == DImode && !TARGET_64BIT)\n     {\n@@ -233,7 +233,7 @@\n       operands[1] = force_reg (<MODE>mode, operands[1]);\n \n       /* For seq-cst stores, when we lack MFENCE, use XCHG.  */\n-      if (model == MEMMODEL_SEQ_CST && !(TARGET_64BIT || TARGET_SSE2))\n+      if (is_mm_seq_cst (model) && !(TARGET_64BIT || TARGET_SSE2))\n \t{\n \t  emit_insn (gen_atomic_exchange<mode> (gen_reg_rtx (<MODE>mode),\n \t\t\t\t\t\toperands[0], operands[1],\n@@ -246,7 +246,7 @@\n \t\t\t\t\t   operands[2]));\n     }\n   /* ... followed by an MFENCE, if required.  */\n-  if (model == MEMMODEL_SEQ_CST)\n+  if (is_mm_seq_cst (model))\n     emit_insn (gen_mem_thread_fence (operands[2]));\n   DONE;\n })"}, {"sha": "c1e2ecdf0d856c4c290cbe34ce4bac49b26fc535", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46b35980b831a980f762753b64c83e1ab8eac880/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46b35980b831a980f762753b64c83e1ab8eac880/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=46b35980b831a980f762753b64c83e1ab8eac880", "patch": "@@ -2386,17 +2386,20 @@ ia64_expand_atomic_op (enum rtx_code code, rtx mem, rtx val,\n \t{\n \tcase MEMMODEL_ACQ_REL:\n \tcase MEMMODEL_SEQ_CST:\n+\tcase MEMMODEL_SYNC_SEQ_CST:\n \t  emit_insn (gen_memory_barrier ());\n \t  /* FALLTHRU */\n \tcase MEMMODEL_RELAXED:\n \tcase MEMMODEL_ACQUIRE:\n+\tcase MEMMODEL_SYNC_ACQUIRE:\n \tcase MEMMODEL_CONSUME:\n \t  if (mode == SImode)\n \t    icode = CODE_FOR_fetchadd_acq_si;\n \t  else\n \t    icode = CODE_FOR_fetchadd_acq_di;\n \t  break;\n \tcase MEMMODEL_RELEASE:\n+\tcase MEMMODEL_SYNC_RELEASE:\n \t  if (mode == SImode)\n \t    icode = CODE_FOR_fetchadd_rel_si;\n \t  else\n@@ -2423,8 +2426,7 @@ ia64_expand_atomic_op (enum rtx_code code, rtx mem, rtx val,\n      front half of the full barrier.  The end half is the cmpxchg.rel.\n      For relaxed and release memory models, we don't need this.  But we\n      also don't bother trying to prevent it either.  */\n-  gcc_assert (model == MEMMODEL_RELAXED\n-\t      || model == MEMMODEL_RELEASE\n+  gcc_assert (is_mm_relaxed (model) || is_mm_release (model)\n \t      || MEM_VOLATILE_P (mem));\n \n   old_reg = gen_reg_rtx (DImode);\n@@ -2468,6 +2470,7 @@ ia64_expand_atomic_op (enum rtx_code code, rtx mem, rtx val,\n     {\n     case MEMMODEL_RELAXED:\n     case MEMMODEL_ACQUIRE:\n+    case MEMMODEL_SYNC_ACQUIRE:\n     case MEMMODEL_CONSUME:\n       switch (mode)\n \t{\n@@ -2481,8 +2484,10 @@ ia64_expand_atomic_op (enum rtx_code code, rtx mem, rtx val,\n       break;\n \n     case MEMMODEL_RELEASE:\n+    case MEMMODEL_SYNC_RELEASE:\n     case MEMMODEL_ACQ_REL:\n     case MEMMODEL_SEQ_CST:\n+    case MEMMODEL_SYNC_SEQ_CST:\n       switch (mode)\n \t{\n \tcase QImode: icode = CODE_FOR_cmpxchg_rel_qi;  break;"}, {"sha": "9c178b826b1f4e2134773ef954c72ee64342eec4", "filename": "gcc/config/ia64/sync.md", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46b35980b831a980f762753b64c83e1ab8eac880/gcc%2Fconfig%2Fia64%2Fsync.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46b35980b831a980f762753b64c83e1ab8eac880/gcc%2Fconfig%2Fia64%2Fsync.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fsync.md?ref=46b35980b831a980f762753b64c83e1ab8eac880", "patch": "@@ -33,7 +33,7 @@\n   [(match_operand:SI 0 \"const_int_operand\" \"\")]\t\t;; model\n   \"\"\n {\n-  if (INTVAL (operands[0]) == MEMMODEL_SEQ_CST)\n+  if (is_mm_seq_cst (memmodel_from_int (INTVAL (operands[0]))))\n     emit_insn (gen_memory_barrier ());\n   DONE;\n })\n@@ -60,11 +60,11 @@\n    (match_operand:SI 2 \"const_int_operand\" \"\")]\t\t\t;; model\n   \"\"\n {\n-  enum memmodel model = (enum memmodel) INTVAL (operands[2]);\n+  enum memmodel model = memmodel_from_int (INTVAL (operands[2]));\n \n   /* Unless the memory model is relaxed, we want to emit ld.acq, which\n      will happen automatically for volatile memories.  */\n-  gcc_assert (model == MEMMODEL_RELAXED || MEM_VOLATILE_P (operands[1]));\n+  gcc_assert (is_mm_relaxed (model) || MEM_VOLATILE_P (operands[1]));\n   emit_move_insn (operands[0], operands[1]);\n   DONE;\n })\n@@ -75,17 +75,17 @@\n    (match_operand:SI 2 \"const_int_operand\" \"\")]\t\t\t;; model\n   \"\"\n {\n-  enum memmodel model = (enum memmodel) INTVAL (operands[2]);\n+  enum memmodel model = memmodel_from_int (INTVAL (operands[2]));\n \n   /* Unless the memory model is relaxed, we want to emit st.rel, which\n      will happen automatically for volatile memories.  */\n-  gcc_assert (model == MEMMODEL_RELAXED || MEM_VOLATILE_P (operands[0]));\n+  gcc_assert (is_mm_relaxed (model) || MEM_VOLATILE_P (operands[0]));\n   emit_move_insn (operands[0], operands[1]);\n \n   /* Sequentially consistent stores need a subsequent MF.  See\n      http://www.decadent.org.uk/pipermail/cpp-threads/2008-December/001952.html\n      for a discussion of why a MF is needed here, but not for atomic_load.  */\n-  if (model == MEMMODEL_SEQ_CST)\n+  if (is_mm_seq_cst (model))\n     emit_insn (gen_memory_barrier ());\n   DONE;\n })\n@@ -101,7 +101,8 @@\n    (match_operand:SI 7 \"const_int_operand\" \"\")]\t\t\t;; fail model\n   \"\"\n {\n-  enum memmodel model = (enum memmodel) INTVAL (operands[6]);\n+  /* No need to distinquish __sync from __atomic, so get base value.  */\n+  enum memmodel model = memmodel_base (INTVAL (operands[6]));\n   rtx ccv = gen_rtx_REG (DImode, AR_CCV_REGNUM);\n   rtx dval, eval;\n \n@@ -200,7 +201,8 @@\n    (match_operand:SI 3 \"const_int_operand\" \"\")]\t\t\t;; succ model\n   \"\"\n {\n-  enum memmodel model = (enum memmodel) INTVAL (operands[3]);\n+  /* No need to distinquish __sync from __atomic, so get base value.  */\n+  enum memmodel model = memmodel_base (INTVAL (operands[3]));\n \n   switch (model)\n     {"}, {"sha": "c6e40a13fd70f6ebfb065271f54529f4404cca4a", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46b35980b831a980f762753b64c83e1ab8eac880/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46b35980b831a980f762753b64c83e1ab8eac880/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=46b35980b831a980f762753b64c83e1ab8eac880", "patch": "@@ -13106,7 +13106,7 @@ mips_process_sync_loop (rtx_insn *insn, rtx *operands)\n       model = MEMMODEL_ACQUIRE;\n       break;\n     default:\n-      model = (enum memmodel) INTVAL (operands[memmodel_attr]);\n+      model = memmodel_from_int (INTVAL (operands[memmodel_attr]));\n     }\n \n   mips_multi_start ();"}, {"sha": "cc077a419e5c81970981d2cb395cd69fcc96658e", "filename": "gcc/config/pa/pa.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46b35980b831a980f762753b64c83e1ab8eac880/gcc%2Fconfig%2Fpa%2Fpa.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46b35980b831a980f762753b64c83e1ab8eac880/gcc%2Fconfig%2Fpa%2Fpa.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.md?ref=46b35980b831a980f762753b64c83e1ab8eac880", "patch": "@@ -707,12 +707,12 @@\n    (match_operand:SI 2 \"const_int_operand\")]            ;; model\n   \"!TARGET_64BIT && !TARGET_SOFT_FLOAT\"\n {\n-  enum memmodel model = (enum memmodel) INTVAL (operands[2]);\n+  enum memmodel model = memmodel_from_int (INTVAL (operands[2]));\n   operands[1] = force_reg (SImode, XEXP (operands[1], 0));\n   operands[2] = gen_reg_rtx (DImode);\n   expand_mem_thread_fence (model);\n   emit_insn (gen_atomic_loaddi_1 (operands[0], operands[1], operands[2]));\n-  if ((model & MEMMODEL_MASK) == MEMMODEL_SEQ_CST)\n+  if (is_mm_seq_cst (model))\n     expand_mem_thread_fence (model);\n   DONE;\n })\n@@ -734,12 +734,12 @@\n    (match_operand:SI 2 \"const_int_operand\")]            ;; model\n   \"!TARGET_64BIT && !TARGET_SOFT_FLOAT\"\n {\n-  enum memmodel model = (enum memmodel) INTVAL (operands[2]);\n+  enum memmodel model = memmodel_from_int (INTVAL (operands[2]));\n   operands[0] = force_reg (SImode, XEXP (operands[0], 0));\n   operands[2] = gen_reg_rtx (DImode);\n   expand_mem_thread_fence (model);\n   emit_insn (gen_atomic_storedi_1 (operands[0], operands[1], operands[2]));\n-  if ((model & MEMMODEL_MASK) == MEMMODEL_SEQ_CST)\n+  if (is_mm_seq_cst (model))\n     expand_mem_thread_fence (model);\n   DONE;\n })"}, {"sha": "ec7332c996373eab662d4635bfbed8707181fbd9", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46b35980b831a980f762753b64c83e1ab8eac880/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46b35980b831a980f762753b64c83e1ab8eac880/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=46b35980b831a980f762753b64c83e1ab8eac880", "patch": "@@ -20516,12 +20516,15 @@ rs6000_pre_atomic_barrier (rtx mem, enum memmodel model)\n     case MEMMODEL_RELAXED:\n     case MEMMODEL_CONSUME:\n     case MEMMODEL_ACQUIRE:\n+    case MEMMODEL_SYNC_ACQUIRE:\n       break;\n     case MEMMODEL_RELEASE:\n+    case MEMMODEL_SYNC_RELEASE:\n     case MEMMODEL_ACQ_REL:\n       emit_insn (gen_lwsync ());\n       break;\n     case MEMMODEL_SEQ_CST:\n+    case MEMMODEL_SYNC_SEQ_CST:\n       emit_insn (gen_hwsync ());\n       break;\n     default:\n@@ -20538,10 +20541,13 @@ rs6000_post_atomic_barrier (enum memmodel model)\n     case MEMMODEL_RELAXED:\n     case MEMMODEL_CONSUME:\n     case MEMMODEL_RELEASE:\n+    case MEMMODEL_SYNC_RELEASE:\n       break;\n     case MEMMODEL_ACQUIRE:\n+    case MEMMODEL_SYNC_ACQUIRE:\n     case MEMMODEL_ACQ_REL:\n     case MEMMODEL_SEQ_CST:\n+    case MEMMODEL_SYNC_SEQ_CST:\n       emit_insn (gen_isync ());\n       break;\n     default:\n@@ -20642,8 +20648,8 @@ rs6000_expand_atomic_compare_and_swap (rtx operands[])\n   oldval = operands[3];\n   newval = operands[4];\n   is_weak = (INTVAL (operands[5]) != 0);\n-  mod_s = (enum memmodel) INTVAL (operands[6]);\n-  mod_f = (enum memmodel) INTVAL (operands[7]);\n+  mod_s = memmodel_from_int (INTVAL (operands[6]));\n+  mod_f = memmodel_from_int (INTVAL (operands[7]));\n   orig_mode = mode = GET_MODE (mem);\n \n   mask = shift = NULL_RTX;\n@@ -20731,12 +20737,12 @@ rs6000_expand_atomic_compare_and_swap (rtx operands[])\n       emit_unlikely_jump (x, label1);\n     }\n \n-  if (mod_f != MEMMODEL_RELAXED)\n+  if (!is_mm_relaxed (mod_f))\n     emit_label (XEXP (label2, 0));\n \n   rs6000_post_atomic_barrier (mod_s);\n \n-  if (mod_f == MEMMODEL_RELAXED)\n+  if (is_mm_relaxed (mod_f))\n     emit_label (XEXP (label2, 0));\n \n   if (shift)"}, {"sha": "8ba30b98658181c52c14b32a7f13c457827916ac", "filename": "gcc/config/rs6000/sync.md", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46b35980b831a980f762753b64c83e1ab8eac880/gcc%2Fconfig%2Frs6000%2Fsync.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46b35980b831a980f762753b64c83e1ab8eac880/gcc%2Fconfig%2Frs6000%2Fsync.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fsync.md?ref=46b35980b831a980f762753b64c83e1ab8eac880", "patch": "@@ -41,18 +41,21 @@\n   [(match_operand:SI 0 \"const_int_operand\" \"\")]\t\t;; model\n   \"\"\n {\n-  enum memmodel model = (enum memmodel) INTVAL (operands[0]);\n+  enum memmodel model = memmodel_from_int (INTVAL (operands[0]));\n   switch (model)\n     {\n     case MEMMODEL_RELAXED:\n       break;\n     case MEMMODEL_CONSUME:\n     case MEMMODEL_ACQUIRE:\n+    case MEMMODEL_SYNC_ACQUIRE:\n     case MEMMODEL_RELEASE:\n+    case MEMMODEL_SYNC_RELEASE:\n     case MEMMODEL_ACQ_REL:\n       emit_insn (gen_lwsync ());\n       break;\n     case MEMMODEL_SEQ_CST:\n+    case MEMMODEL_SYNC_SEQ_CST:\n       emit_insn (gen_hwsync ());\n       break;\n     default:\n@@ -144,9 +147,9 @@\n   if (<MODE>mode == TImode && !TARGET_SYNC_TI)\n     FAIL;\n \n-  enum memmodel model = (enum memmodel) INTVAL (operands[2]);\n+  enum memmodel model = memmodel_from_int (INTVAL (operands[2]));\n \n-  if (model == MEMMODEL_SEQ_CST)\n+  if (is_mm_seq_cst (model))\n     emit_insn (gen_hwsync ());\n \n   if (<MODE>mode != TImode)\n@@ -182,7 +185,9 @@\n       break;\n     case MEMMODEL_CONSUME:\n     case MEMMODEL_ACQUIRE:\n+    case MEMMODEL_SYNC_ACQUIRE:\n     case MEMMODEL_SEQ_CST:\n+    case MEMMODEL_SYNC_SEQ_CST:\n       emit_insn (gen_loadsync_<mode> (operands[0]));\n       break;\n     default:\n@@ -209,15 +214,17 @@\n   if (<MODE>mode == TImode && !TARGET_SYNC_TI)\n     FAIL;\n \n-  enum memmodel model = (enum memmodel) INTVAL (operands[2]);\n+  enum memmodel model = memmodel_from_int (INTVAL (operands[2]));\n   switch (model)\n     {\n     case MEMMODEL_RELAXED:\n       break;\n     case MEMMODEL_RELEASE:\n+    case MEMMODEL_SYNC_RELEASE:\n       emit_insn (gen_lwsync ());\n       break;\n     case MEMMODEL_SEQ_CST:\n+    case MEMMODEL_SYNC_SEQ_CST:\n       emit_insn (gen_hwsync ());\n       break;\n     default:"}, {"sha": "ad06721c8f8514ab4a67ac4e8df2c1544b28eed6", "filename": "gcc/config/s390/s390.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46b35980b831a980f762753b64c83e1ab8eac880/gcc%2Fconfig%2Fs390%2Fs390.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46b35980b831a980f762753b64c83e1ab8eac880/gcc%2Fconfig%2Fs390%2Fs390.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.md?ref=46b35980b831a980f762753b64c83e1ab8eac880", "patch": "@@ -9225,7 +9225,7 @@\n {\n   /* Unless this is a SEQ_CST fence, the s390 memory model is strong\n      enough not to require barriers of any kind.  */\n-  if (INTVAL (operands[0]) == MEMMODEL_SEQ_CST)\n+  if (is_mm_seq_cst (memmodel_from_int (INTVAL (operands[0]))))\n     {\n       rtx mem = gen_rtx_MEM (BLKmode, gen_rtx_SCRATCH (Pmode));\n       MEM_VOLATILE_P (mem) = 1;\n@@ -9306,7 +9306,7 @@\n    (match_operand:SI 2 \"const_int_operand\")]\t;; model\n   \"\"\n {\n-  enum memmodel model = (enum memmodel) INTVAL (operands[2]);\n+  enum memmodel model = memmodel_from_int (INTVAL (operands[2]));\n \n   if (MEM_ALIGN (operands[0]) < GET_MODE_BITSIZE (GET_MODE (operands[0])))\n     FAIL;\n@@ -9317,7 +9317,7 @@\n     emit_insn (gen_atomic_storedi_1 (operands[0], operands[1]));\n   else\n     emit_move_insn (operands[0], operands[1]);\n-  if (model == MEMMODEL_SEQ_CST)\n+  if (is_mm_seq_cst (model))\n     emit_insn (gen_mem_thread_fence (operands[2]));\n   DONE;\n })"}, {"sha": "a1562ad863035be0033a06c79039c31c0995398b", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46b35980b831a980f762753b64c83e1ab8eac880/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46b35980b831a980f762753b64c83e1ab8eac880/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=46b35980b831a980f762753b64c83e1ab8eac880", "patch": "@@ -11631,9 +11631,8 @@ sparc_emit_membar_for_model (enum memmodel model,\n \n   if (before_after & 1)\n     {\n-      if (model == MEMMODEL_RELEASE\n-\t  || model == MEMMODEL_ACQ_REL\n-\t  || model == MEMMODEL_SEQ_CST)\n+      if (is_mm_release (model) || is_mm_acq_rel (model)\n+\t  || is_mm_seq_cst (model))\n \t{\n \t  if (load_store & 1)\n \t    mm |= LoadLoad | StoreLoad;\n@@ -11643,9 +11642,8 @@ sparc_emit_membar_for_model (enum memmodel model,\n     }\n   if (before_after & 2)\n     {\n-      if (model == MEMMODEL_ACQUIRE\n-\t  || model == MEMMODEL_ACQ_REL\n-\t  || model == MEMMODEL_SEQ_CST)\n+      if (is_mm_acquire (model) || is_mm_acq_rel (model)\n+\t  || is_mm_seq_cst (model))\n \t{\n \t  if (load_store & 1)\n \t    mm |= LoadLoad | LoadStore;"}, {"sha": "0ee8633c7279c0fc684a4c96ec81525e4d38caa7", "filename": "gcc/coretypes.h", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46b35980b831a980f762753b64c83e1ab8eac880/gcc%2Fcoretypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46b35980b831a980f762753b64c83e1ab8eac880/gcc%2Fcoretypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcoretypes.h?ref=46b35980b831a980f762753b64c83e1ab8eac880", "patch": "@@ -263,6 +263,18 @@ enum function_class {\n   function_c11_misc\n };\n \n+/* Suppose that higher bits are target dependent. */\n+#define MEMMODEL_MASK ((1<<16)-1)\n+\n+/* Legacy sync operations set this upper flag in the memory model.  This allows\n+   targets that need to do something stronger for sync operations to\n+   differentiate with their target patterns and issue a more appropriate insn\n+   sequence.  See bugzilla 65697 for background.  */\n+#define MEMMODEL_SYNC (1<<15)\n+\n+/* Memory model without SYNC bit for targets/operations that do not care.  */\n+#define MEMMODEL_BASE_MASK (MEMMODEL_SYNC-1)\n+\n /* Memory model types for the __atomic* builtins. \n    This must match the order in libstdc++-v3/include/bits/atomic_base.h.  */\n enum memmodel\n@@ -273,12 +285,12 @@ enum memmodel\n   MEMMODEL_RELEASE = 3,\n   MEMMODEL_ACQ_REL = 4,\n   MEMMODEL_SEQ_CST = 5,\n-  MEMMODEL_LAST = 6\n+  MEMMODEL_LAST = 6,\n+  MEMMODEL_SYNC_ACQUIRE = MEMMODEL_ACQUIRE | MEMMODEL_SYNC,\n+  MEMMODEL_SYNC_RELEASE = MEMMODEL_RELEASE | MEMMODEL_SYNC,\n+  MEMMODEL_SYNC_SEQ_CST = MEMMODEL_SEQ_CST | MEMMODEL_SYNC\n };\n \n-/* Suppose that higher bits are target dependent. */\n-#define MEMMODEL_MASK ((1<<16)-1)\n-\n /* Support for user-provided GGC and PCH markers.  The first parameter\n    is a pointer to a pointer, the second a cookie.  */\n typedef void (*gt_pointer_operator) (void *, void *);"}, {"sha": "60046810af25d5e6117116ff653224bb4d8991a4", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46b35980b831a980f762753b64c83e1ab8eac880/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46b35980b831a980f762753b64c83e1ab8eac880/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=46b35980b831a980f762753b64c83e1ab8eac880", "patch": "@@ -8946,9 +8946,9 @@ functions map any run-time value to @code{__ATOMIC_SEQ_CST} rather\n than invoke a runtime library call or inline a switch statement.  This is\n standard compliant, safe, and the simplest approach for now.\n \n-The memory model parameter is a signed int, but only the lower 8 bits are\n+The memory model parameter is a signed int, but only the lower 16 bits are\n reserved for the memory model.  The remainder of the signed int is reserved\n-for future use and should be 0.  Use of the predefined atomic values\n+for target use and should be 0.  Use of the predefined atomic values\n ensures proper usage.\n \n @deftypefn {Built-in Function} @var{type} __atomic_load_n (@var{type} *ptr, int memmodel)"}, {"sha": "40af6aeef57c5985035006e8c7ad352e0861ab13", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46b35980b831a980f762753b64c83e1ab8eac880/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46b35980b831a980f762753b64c83e1ab8eac880/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=46b35980b831a980f762753b64c83e1ab8eac880", "patch": "@@ -6296,11 +6296,14 @@ need_atomic_barrier_p (enum memmodel model, bool pre)\n     case MEMMODEL_CONSUME:\n       return false;\n     case MEMMODEL_RELEASE:\n+    case MEMMODEL_SYNC_RELEASE:\n       return pre;\n     case MEMMODEL_ACQUIRE:\n+    case MEMMODEL_SYNC_ACQUIRE:\n       return !pre;\n     case MEMMODEL_ACQ_REL:\n     case MEMMODEL_SEQ_CST:\n+    case MEMMODEL_SYNC_SEQ_CST:\n       return true;\n     default:\n       gcc_unreachable ();"}, {"sha": "bd03fc1f5fe8d33b54e36ec12831a292a32764e4", "filename": "gcc/optabs.c", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46b35980b831a980f762753b64c83e1ab8eac880/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46b35980b831a980f762753b64c83e1ab8eac880/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=46b35980b831a980f762753b64c83e1ab8eac880", "patch": "@@ -7188,7 +7188,7 @@ expand_compare_and_swap_loop (rtx mem, rtx old_reg, rtx new_reg, rtx seq)\n   success = NULL_RTX;\n   oldval = cmp_reg;\n   if (!expand_atomic_compare_and_swap (&success, &oldval, mem, old_reg,\n-\t\t\t\t       new_reg, false, MEMMODEL_SEQ_CST,\n+\t\t\t\t       new_reg, false, MEMMODEL_SYNC_SEQ_CST,\n \t\t\t\t       MEMMODEL_RELAXED))\n     return false;\n \n@@ -7249,9 +7249,7 @@ maybe_emit_sync_lock_test_and_set (rtx target, rtx mem, rtx val,\n      exists, and the memory model is stronger than acquire, add a release \n      barrier before the instruction.  */\n \n-  if ((model & MEMMODEL_MASK) == MEMMODEL_SEQ_CST\n-      || (model & MEMMODEL_MASK) == MEMMODEL_RELEASE\n-      || (model & MEMMODEL_MASK) == MEMMODEL_ACQ_REL)\n+  if (is_mm_seq_cst (model) || is_mm_release (model) || is_mm_acq_rel (model))\n     expand_mem_thread_fence (model);\n \n   if (icode != CODE_FOR_nothing)\n@@ -7358,11 +7356,12 @@ expand_sync_lock_test_and_set (rtx target, rtx mem, rtx val)\n   rtx ret;\n \n   /* Try an atomic_exchange first.  */\n-  ret = maybe_emit_atomic_exchange (target, mem, val, MEMMODEL_ACQUIRE);\n+  ret = maybe_emit_atomic_exchange (target, mem, val, MEMMODEL_SYNC_ACQUIRE);\n   if (ret)\n     return ret;\n \n-  ret = maybe_emit_sync_lock_test_and_set (target, mem, val, MEMMODEL_ACQUIRE);\n+  ret = maybe_emit_sync_lock_test_and_set (target, mem, val,\n+\t\t\t\t\t   MEMMODEL_SYNC_ACQUIRE);\n   if (ret)\n     return ret;\n \n@@ -7373,7 +7372,7 @@ expand_sync_lock_test_and_set (rtx target, rtx mem, rtx val)\n   /* If there are no other options, try atomic_test_and_set if the value\n      being stored is 1.  */\n   if (val == const1_rtx)\n-    ret = maybe_emit_atomic_test_and_set (target, mem, MEMMODEL_ACQUIRE);\n+    ret = maybe_emit_atomic_test_and_set (target, mem, MEMMODEL_SYNC_ACQUIRE);\n \n   return ret;\n }\n@@ -7630,7 +7629,7 @@ expand_mem_thread_fence (enum memmodel model)\n {\n   if (HAVE_mem_thread_fence)\n     emit_insn (gen_mem_thread_fence (GEN_INT (model)));\n-  else if ((model & MEMMODEL_MASK) != MEMMODEL_RELAXED)\n+  else if (!is_mm_relaxed (model))\n     {\n       if (HAVE_memory_barrier)\n \temit_insn (gen_memory_barrier ());\n@@ -7654,7 +7653,7 @@ expand_mem_signal_fence (enum memmodel model)\n {\n   if (HAVE_mem_signal_fence)\n     emit_insn (gen_mem_signal_fence (GEN_INT (model)));\n-  else if ((model & MEMMODEL_MASK) != MEMMODEL_RELAXED)\n+  else if (!is_mm_relaxed (model))\n     {\n       /* By default targets are coherent between a thread and the signal\n \t handler running on the same thread.  Thus this really becomes a\n@@ -7709,7 +7708,7 @@ expand_atomic_load (rtx target, rtx mem, enum memmodel model)\n     target = gen_reg_rtx (mode);\n \n   /* For SEQ_CST, emit a barrier before the load.  */\n-  if ((model & MEMMODEL_MASK) == MEMMODEL_SEQ_CST)\n+  if (is_mm_seq_cst (model))\n     expand_mem_thread_fence (model);\n \n   emit_move_insn (target, mem);\n@@ -7755,7 +7754,7 @@ expand_atomic_store (rtx mem, rtx val, enum memmodel model, bool use_release)\n \t  if (maybe_expand_insn (icode, 2, ops))\n \t    {\n \t      /* lock_release is only a release barrier.  */\n-\t      if ((model & MEMMODEL_MASK) == MEMMODEL_SEQ_CST)\n+\t      if (is_mm_seq_cst (model))\n \t\texpand_mem_thread_fence (model);\n \t      return const0_rtx;\n \t    }\n@@ -7782,7 +7781,7 @@ expand_atomic_store (rtx mem, rtx val, enum memmodel model, bool use_release)\n   emit_move_insn (mem, val);\n \n   /* For SEQ_CST, also emit a barrier after the store.  */\n-  if ((model & MEMMODEL_MASK) == MEMMODEL_SEQ_CST)\n+  if (is_mm_seq_cst (model))\n     expand_mem_thread_fence (model);\n \n   return const0_rtx;"}, {"sha": "6d5254dcb438617dccef1692fdf1b627b78b93e1", "filename": "gcc/tree.h", "status": "modified", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46b35980b831a980f762753b64c83e1ab8eac880/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46b35980b831a980f762753b64c83e1ab8eac880/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=46b35980b831a980f762753b64c83e1ab8eac880", "patch": "@@ -4384,6 +4384,69 @@ extern void assign_assembler_name_if_neeeded (tree);\n extern void warn_deprecated_use (tree, tree);\n extern void cache_integer_cst (tree);\n \n+/* Return the memory model from a host integer.  */\n+static inline enum memmodel\n+memmodel_from_int (unsigned HOST_WIDE_INT val)\n+{\n+  return (enum memmodel) (val & MEMMODEL_MASK);\n+}\n+\n+/* Return the base memory model from a host integer.  */\n+static inline enum memmodel\n+memmodel_base (unsigned HOST_WIDE_INT val)\n+{\n+  return (enum memmodel) (val & MEMMODEL_BASE_MASK);\n+}\n+\n+/* Return TRUE if the memory model is RELAXED.  */\n+static inline bool\n+is_mm_relaxed (enum memmodel model)\n+{\n+  return (model & MEMMODEL_BASE_MASK) == MEMMODEL_RELAXED;\n+}\n+\n+/* Return TRUE if the memory model is CONSUME.  */\n+static inline bool\n+is_mm_consume (enum memmodel model)\n+{\n+  return (model & MEMMODEL_BASE_MASK) == MEMMODEL_CONSUME;\n+}\n+\n+/* Return TRUE if the memory model is ACQUIRE.  */\n+static inline bool\n+is_mm_acquire (enum memmodel model)\n+{\n+  return (model & MEMMODEL_BASE_MASK) == MEMMODEL_ACQUIRE;\n+}\n+\n+/* Return TRUE if the memory model is RELEASE.  */\n+static inline bool\n+is_mm_release (enum memmodel model)\n+{\n+  return (model & MEMMODEL_BASE_MASK) == MEMMODEL_RELEASE;\n+}\n+\n+/* Return TRUE if the memory model is ACQ_REL.  */\n+static inline bool\n+is_mm_acq_rel (enum memmodel model)\n+{\n+  return (model & MEMMODEL_BASE_MASK) == MEMMODEL_ACQ_REL;\n+}\n+\n+/* Return TRUE if the memory model is SEQ_CST.  */\n+static inline bool\n+is_mm_seq_cst (enum memmodel model)\n+{\n+  return (model & MEMMODEL_BASE_MASK) == MEMMODEL_SEQ_CST;\n+}\n+\n+/* Return TRUE if the memory model is a SYNC variant.  */\n+static inline bool\n+is_mm_sync (enum memmodel model)\n+{\n+  return (model & MEMMODEL_SYNC);\n+}\n+\n /* Compare and hash for any structure which begins with a canonical\n    pointer.  Assumes all pointers are interchangeable, which is sort\n    of already assumed by gcc elsewhere IIRC.  */"}, {"sha": "2752182bb5245cf44e2bf59be73fc9048b327020", "filename": "gcc/tsan.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46b35980b831a980f762753b64c83e1ab8eac880/gcc%2Ftsan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46b35980b831a980f762753b64c83e1ab8eac880/gcc%2Ftsan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftsan.c?ref=46b35980b831a980f762753b64c83e1ab8eac880", "patch": "@@ -535,7 +535,7 @@ instrument_builtin_call (gimple_stmt_iterator *gsi)\n \t  case fetch_op:\n \t    last_arg = gimple_call_arg (stmt, num - 1);\n \t    if (!tree_fits_uhwi_p (last_arg)\n-\t\t|| tree_to_uhwi (last_arg) > MEMMODEL_SEQ_CST)\n+\t\t|| memmodel_base (tree_to_uhwi (last_arg)) >= MEMMODEL_LAST)\n \t      return;\n \t    gimple_call_set_fndecl (stmt, decl);\n \t    update_stmt (stmt);\n@@ -600,10 +600,10 @@ instrument_builtin_call (gimple_stmt_iterator *gsi)\n \t    for (j = 0; j < 6; j++)\n \t      args[j] = gimple_call_arg (stmt, j);\n \t    if (!tree_fits_uhwi_p (args[4])\n-\t\t|| tree_to_uhwi (args[4]) > MEMMODEL_SEQ_CST)\n+\t\t|| memmodel_base (tree_to_uhwi (args[4])) >= MEMMODEL_LAST)\n \t      return;\n \t    if (!tree_fits_uhwi_p (args[5])\n-\t\t|| tree_to_uhwi (args[5]) > MEMMODEL_SEQ_CST)\n+\t\t|| memmodel_base (tree_to_uhwi (args[5])) >= MEMMODEL_LAST)\n \t      return;\n \t    update_gimple_call (gsi, decl, 5, args[0], args[1], args[2],\n \t\t\t\targs[4], args[5]);"}]}