{"sha": "b826bea7f3a828f9a8d23a0828572452101ced42", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjgyNmJlYTdmM2E4MjhmOWE4ZDIzYTA4Mjg1NzI0NTIxMDFjZWQ0Mg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2011-12-13T20:07:01Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2011-12-13T20:07:01Z"}, "message": "Revert two unintended commits\n\nFrom-SVN: r182301", "tree": {"sha": "b51ff1980c56c199511e2a406274c144de43fd81", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b51ff1980c56c199511e2a406274c144de43fd81"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b826bea7f3a828f9a8d23a0828572452101ced42", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b826bea7f3a828f9a8d23a0828572452101ced42", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b826bea7f3a828f9a8d23a0828572452101ced42", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b826bea7f3a828f9a8d23a0828572452101ced42/comments", "author": null, "committer": null, "parents": [{"sha": "38a53a0e25ac25724fae62ec6c340337805e6bc8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38a53a0e25ac25724fae62ec6c340337805e6bc8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/38a53a0e25ac25724fae62ec6c340337805e6bc8"}], "stats": {"total": 858, "additions": 162, "deletions": 696}, "files": [{"sha": "295d6246a0e8158f02a53d896169af6c81de9366", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b826bea7f3a828f9a8d23a0828572452101ced42/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b826bea7f3a828f9a8d23a0828572452101ced42/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=b826bea7f3a828f9a8d23a0828572452101ced42", "patch": "@@ -3451,6 +3451,8 @@ expand_debug_expr (tree exp)\n     case VEC_COND_EXPR:\n     case VEC_EXTRACT_EVEN_EXPR:\n     case VEC_EXTRACT_ODD_EXPR:\n+    case VEC_INTERLEAVE_HIGH_EXPR:\n+    case VEC_INTERLEAVE_LOW_EXPR:\n     case VEC_LSHIFT_EXPR:\n     case VEC_PACK_FIX_TRUNC_EXPR:\n     case VEC_PACK_SAT_EXPR:"}, {"sha": "296550aff1c0c10b3be9465b0675e05bc3df3832", "filename": "gcc/config/arm/arm-protos.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b826bea7f3a828f9a8d23a0828572452101ced42/gcc%2Fconfig%2Farm%2Farm-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b826bea7f3a828f9a8d23a0828572452101ced42/gcc%2Fconfig%2Farm%2Farm-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-protos.h?ref=b826bea7f3a828f9a8d23a0828572452101ced42", "patch": "@@ -244,7 +244,4 @@ extern const struct tune_params *current_tune;\n extern int vfp3_const_double_for_fract_bits (rtx);\n #endif /* RTX_CODE */\n \n-extern void arm_expand_vec_perm (rtx target, rtx op0, rtx op1, rtx sel);\n-extern bool arm_expand_vec_perm_const (rtx target, rtx op0, rtx op1, rtx sel);\n-\n #endif /* ! GCC_ARM_PROTOS_H */"}, {"sha": "65b4e9d58ae9ca93c2f3469c492371715794423a", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 1, "deletions": 525, "changes": 526, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b826bea7f3a828f9a8d23a0828572452101ced42/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b826bea7f3a828f9a8d23a0828572452101ced42/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=b826bea7f3a828f9a8d23a0828572452101ced42", "patch": "@@ -267,9 +267,6 @@ static unsigned int arm_autovectorize_vector_sizes (void);\n static int arm_default_branch_cost (bool, bool);\n static int arm_cortex_a5_branch_cost (bool, bool);\n \n-static bool arm_vectorize_vec_perm_const_ok (enum machine_mode vmode,\n-\t\t\t\t\t     const unsigned char *sel);\n-\n \f\n /* Table of machine attributes.  */\n static const struct attribute_spec arm_attribute_table[] =\n@@ -607,10 +604,6 @@ static const struct attribute_spec arm_attribute_table[] =\n #define TARGET_PREFERRED_RENAME_CLASS \\\n   arm_preferred_rename_class\n \n-#undef TARGET_VECTORIZE_VEC_PERM_CONST_OK\n-#define TARGET_VECTORIZE_VEC_PERM_CONST_OK \\\n-  arm_vectorize_vec_perm_const_ok\n-\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n /* Obstack for minipool constant handling.  */\n@@ -25071,523 +25064,6 @@ vfp3_const_double_for_fract_bits (rtx operand)\n     }\n   return 0;\n }\n-\f\n-#define MAX_VECT_LEN 16\n-\n-struct expand_vec_perm_d\n-{\n-  rtx target, op0, op1;\n-  unsigned char perm[MAX_VECT_LEN];\n-  enum machine_mode vmode;\n-  unsigned char nelt;\n-  bool one_vector_p;\n-  bool testing_p;\n-};\n-\n-/* Generate a variable permutation.  */\n-\n-static void\n-arm_expand_vec_perm_1 (rtx target, rtx op0, rtx op1, rtx sel)\n-{\n-  enum machine_mode vmode = GET_MODE (target);\n-  bool one_vector_p = rtx_equal_p (op0, op1);\n-\n-  gcc_checking_assert (vmode == V8QImode || vmode == V16QImode);\n-  gcc_checking_assert (GET_MODE (op0) == vmode);\n-  gcc_checking_assert (GET_MODE (op1) == vmode);\n-  gcc_checking_assert (GET_MODE (sel) == vmode);\n-  gcc_checking_assert (TARGET_NEON);\n-\n-  if (one_vector_p)\n-    {\n-      if (vmode == V8QImode)\n-\temit_insn (gen_neon_vtbl1v8qi (target, op0, sel));\n-      else\n-\temit_insn (gen_neon_vtbl1v16qi (target, op0, sel));\n-    }\n-  else\n-    {\n-      enum machine_mode mode1, mode2;\n-      rtx pair, part;\n-\n-      if (vmode == V8QImode)\n-\tmode1 = DImode, mode2 = TImode;\n-      else\n-\tmode1 = TImode, mode2 = OImode;\n-\n-      pair = gen_reg_rtx (mode2);\n-      emit_insn (gen_rtx_CLOBBER (VOIDmode, pair));\n-\n-      part = simplify_gen_subreg (mode1, pair, mode2,\n-\t\t\t\t  subreg_lowpart_offset (mode1, mode2));\n-      emit_move_insn (part, gen_lowpart (mode1, op0));\n-\n-      part = simplify_gen_subreg (mode1, pair, mode2,\n-\t\t\t\t  subreg_highpart_offset (mode1, mode2));\n-      emit_move_insn (part, gen_lowpart (mode1, op1));\n-\n-      if (vmode == V8QImode)\n-\temit_insn (gen_neon_vtbl2v8qi (target, pair, sel));\n-      else\n-\temit_insn (gen_neon_vtbl2v16qi (target, pair, sel));\n-    }\n-}\n-\n-void\n-arm_expand_vec_perm (rtx target, rtx op0, rtx op1, rtx sel)\n-{\n-  enum machine_mode vmode = GET_MODE (target);\n-  unsigned int i, nelt = GET_MODE_NUNITS (vmode);\n-  bool one_vector_p = rtx_equal_p (op0, op1);\n-  rtx rmask[MAX_VECT_LEN], mask;\n-\n-  /* TODO: ARM's VTBL indexing is little-endian.  In order to handle GCC's\n-     numbering of elements for big-endian, we must reverse the order.  */\n-  gcc_checking_assert (!BYTES_BIG_ENDIAN);\n-\n-  /* The VTBL instruction does not use a modulo index, so we must take care\n-     of that ourselves.  */\n-  mask = GEN_INT (one_vector_p ? nelt - 1 : 2 * nelt - 1);\n-  for (i = 0; i < nelt; ++i)\n-    rmask[i] = mask;\n-  mask = gen_rtx_CONST_VECTOR (vmode, gen_rtvec_v (nelt, rmask));\n-  sel = expand_simple_binop (vmode, AND, sel, mask, NULL, 0, OPTAB_LIB_WIDEN);\n-\n-  arm_expand_vec_perm_1 (target, op0, op1, sel);\n-}\n-\n-/* Generate or test for an insn that supports a constant permutation.  */\n-\n-/* Recognize patterns for the VUZP insns.  */\n-\n-static bool\n-arm_evpc_neon_vuzp (struct expand_vec_perm_d *d)\n-{\n-  unsigned int i, odd, mask, nelt = d->nelt;\n-  rtx out0, out1, in0, in1, x;\n-  rtx (*gen)(rtx, rtx, rtx, rtx);\n-\n-  if (GET_MODE_UNIT_SIZE (d->vmode) >= 8)\n-    return false;\n-\n-  /* Note that these are little-endian tests.  Adjust for big-endian later.  */\n-  if (d->perm[0] == 0)\n-    odd = 0;\n-  else if (d->perm[0] == 1)\n-    odd = 1;\n-  else\n-    return false;\n-  mask = (d->one_vector_p ? nelt - 1 : 2 * nelt - 1);\n-\n-  for (i = 0; i < nelt; i++)\n-    {\n-      unsigned elt = (i * 2 + odd) & mask;\n-      if (d->perm[i] != elt)\n-\treturn false;\n-    }\n-\n-  /* Success!  */\n-  if (d->testing_p)\n-    return true;\n-\n-  switch (d->vmode)\n-    {\n-    case V16QImode: gen = gen_neon_vuzpv16qi_internal; break;\n-    case V8QImode:  gen = gen_neon_vuzpv8qi_internal;  break;\n-    case V8HImode:  gen = gen_neon_vuzpv8hi_internal;  break;\n-    case V4HImode:  gen = gen_neon_vuzpv4hi_internal;  break;\n-    case V4SImode:  gen = gen_neon_vuzpv4si_internal;  break;\n-    case V2SImode:  gen = gen_neon_vuzpv2si_internal;  break;\n-    case V2SFmode:  gen = gen_neon_vuzpv2sf_internal;  break;\n-    case V4SFmode:  gen = gen_neon_vuzpv4sf_internal;  break;\n-    default:\n-      gcc_unreachable ();\n-    }\n-\n-  in0 = d->op0;\n-  in1 = d->op1;\n-  if (BYTES_BIG_ENDIAN)\n-    {\n-      x = in0, in0 = in1, in1 = x;\n-      odd = !odd;\n-    }\n \n-  out0 = d->target;\n-  out1 = gen_reg_rtx (d->vmode);\n-  if (odd)\n-    x = out0, out0 = out1, out1 = x;\n-\n-  emit_insn (gen (out0, in0, in1, out1));\n-  return true;\n-}\n-\n-/* Recognize patterns for the VZIP insns.  */\n-\n-static bool\n-arm_evpc_neon_vzip (struct expand_vec_perm_d *d)\n-{\n-  unsigned int i, high, mask, nelt = d->nelt;\n-  rtx out0, out1, in0, in1, x;\n-  rtx (*gen)(rtx, rtx, rtx, rtx);\n-\n-  if (GET_MODE_UNIT_SIZE (d->vmode) >= 8)\n-    return false;\n-\n-  /* Note that these are little-endian tests.  Adjust for big-endian later.  */\n-  high = nelt / 2;\n-  if (d->perm[0] == high)\n-    ;\n-  else if (d->perm[0] == 0)\n-    high = 0;\n-  else\n-    return false;\n-  mask = (d->one_vector_p ? nelt - 1 : 2 * nelt - 1);\n-\n-  for (i = 0; i < nelt / 2; i++)\n-    {\n-      unsigned elt = (i + high) & mask;\n-      if (d->perm[i * 2] != elt)\n-\treturn false;\n-      elt = (elt + nelt) & mask;\n-      if (d->perm[i * 2 + 1] != elt)\n-\treturn false;\n-    }\n-\n-  /* Success!  */\n-  if (d->testing_p)\n-    return true;\n-\n-  switch (d->vmode)\n-    {\n-    case V16QImode: gen = gen_neon_vzipv16qi_internal; break;\n-    case V8QImode:  gen = gen_neon_vzipv8qi_internal;  break;\n-    case V8HImode:  gen = gen_neon_vzipv8hi_internal;  break;\n-    case V4HImode:  gen = gen_neon_vzipv4hi_internal;  break;\n-    case V4SImode:  gen = gen_neon_vzipv4si_internal;  break;\n-    case V2SImode:  gen = gen_neon_vzipv2si_internal;  break;\n-    case V2SFmode:  gen = gen_neon_vzipv2sf_internal;  break;\n-    case V4SFmode:  gen = gen_neon_vzipv4sf_internal;  break;\n-    default:\n-      gcc_unreachable ();\n-    }\n-\n-  in0 = d->op0;\n-  in1 = d->op1;\n-  if (BYTES_BIG_ENDIAN)\n-    {\n-      x = in0, in0 = in1, in1 = x;\n-      high = !high;\n-    }\n-\n-  out0 = d->target;\n-  out1 = gen_reg_rtx (d->vmode);\n-  if (high)\n-    x = out0, out0 = out1, out1 = x;\n-\n-  emit_insn (gen (out0, in0, in1, out1));\n-  return true;\n-}\n-\n-/* Recognize patterns for the VREV insns.  */\n-\n-static bool\n-arm_evpc_neon_vrev (struct expand_vec_perm_d *d)\n-{\n-  unsigned int i, j, diff, nelt = d->nelt;\n-  rtx (*gen)(rtx, rtx, rtx);\n-\n-  if (!d->one_vector_p)\n-    return false;\n-\n-  diff = d->perm[0];\n-  switch (diff)\n-    {\n-    case 7:\n-      switch (d->vmode)\n-\t{\n-\tcase V16QImode: gen = gen_neon_vrev64v16qi; break;\n-\tcase V8QImode:  gen = gen_neon_vrev64v8qi;  break;\n-\tdefault:\n-\t  return false;\n-\t}\n-      break;\n-    case 3:\n-      switch (d->vmode)\n-\t{\n-\tcase V16QImode: gen = gen_neon_vrev32v16qi; break;\n-\tcase V8QImode:  gen = gen_neon_vrev32v8qi;  break;\n-\tcase V8HImode:  gen = gen_neon_vrev64v8hi;  break;\n-\tcase V4HImode:  gen = gen_neon_vrev64v4hi;  break;\n-\tdefault:\n-\t  return false;\n-\t}\n-      break;\n-    case 1:\n-      switch (d->vmode)\n-\t{\n-\tcase V16QImode: gen = gen_neon_vrev16v16qi; break;\n-\tcase V8QImode:  gen = gen_neon_vrev16v8qi;  break;\n-\tcase V8HImode:  gen = gen_neon_vrev32v8hi;  break;\n-\tcase V4HImode:  gen = gen_neon_vrev32v4hi;  break;\n-\tcase V4SImode:  gen = gen_neon_vrev64v4si;  break;\n-\tcase V2SImode:  gen = gen_neon_vrev64v2si;  break;\n-\tcase V4SFmode:  gen = gen_neon_vrev64v4sf;  break;\n-\tcase V2SFmode:  gen = gen_neon_vrev64v2sf;  break;\n-\tdefault:\n-\t  return false;\n-\t}\n-      break;\n-    default:\n-      return false;\n-    }\n-\n-  for (i = 0; i < nelt; i += diff)\n-    for (j = 0; j <= diff; j += 1)\n-      if (d->perm[i + j] != i + diff - j)\n-\treturn false;\n-\n-  /* Success! */\n-  if (d->testing_p)\n-    return true;\n-\n-  /* ??? The third operand is an artifact of the builtin infrastructure\n-     and is ignored by the actual instruction.  */\n-  emit_insn (gen (d->target, d->op0, const0_rtx));\n-  return true;\n-}\n-\n-/* Recognize patterns for the VTRN insns.  */\n-\n-static bool\n-arm_evpc_neon_vtrn (struct expand_vec_perm_d *d)\n-{\n-  unsigned int i, odd, mask, nelt = d->nelt;\n-  rtx out0, out1, in0, in1, x;\n-  rtx (*gen)(rtx, rtx, rtx, rtx);\n-\n-  if (GET_MODE_UNIT_SIZE (d->vmode) >= 8)\n-    return false;\n-\n-  /* Note that these are little-endian tests.  Adjust for big-endian later.  */\n-  if (d->perm[0] == 0)\n-    odd = 0;\n-  else if (d->perm[0] == 1)\n-    odd = 1;\n-  else\n-    return false;\n-  mask = (d->one_vector_p ? nelt - 1 : 2 * nelt - 1);\n-\n-  for (i = 0; i < nelt; i += 2)\n-    {\n-      if (d->perm[i] != i + odd)\n-\treturn false;\n-      if (d->perm[i + 1] != ((i + nelt + odd) & mask))\n-\treturn false;\n-    }\n-\n-  /* Success!  */\n-  if (d->testing_p)\n-    return true;\n-\n-  switch (d->vmode)\n-    {\n-    case V16QImode: gen = gen_neon_vtrnv16qi_internal; break;\n-    case V8QImode:  gen = gen_neon_vtrnv8qi_internal;  break;\n-    case V8HImode:  gen = gen_neon_vtrnv8hi_internal;  break;\n-    case V4HImode:  gen = gen_neon_vtrnv4hi_internal;  break;\n-    case V4SImode:  gen = gen_neon_vtrnv4si_internal;  break;\n-    case V2SImode:  gen = gen_neon_vtrnv2si_internal;  break;\n-    case V2SFmode:  gen = gen_neon_vtrnv2sf_internal;  break;\n-    case V4SFmode:  gen = gen_neon_vtrnv4sf_internal;  break;\n-    default:\n-      gcc_unreachable ();\n-    }\n-\n-  in0 = d->op0;\n-  in1 = d->op1;\n-  if (BYTES_BIG_ENDIAN)\n-    {\n-      x = in0, in0 = in1, in1 = x;\n-      odd = !odd;\n-    }\n-\n-  out0 = d->target;\n-  out1 = gen_reg_rtx (d->vmode);\n-  if (odd)\n-    x = out0, out0 = out1, out1 = x;\n-\n-  emit_insn (gen (out0, in0, in1, out1));\n-  return true;\n-}\n-\n-/* The NEON VTBL instruction is a fully variable permuation that's even\n-   stronger than what we expose via VEC_PERM_EXPR.  What it doesn't do\n-   is mask the index operand as VEC_PERM_EXPR requires.  Therefore we\n-   can do slightly better by expanding this as a constant where we don't\n-   have to apply a mask.  */\n-\n-static bool\n-arm_evpc_neon_vtbl (struct expand_vec_perm_d *d)\n-{\n-  rtx rperm[MAX_VECT_LEN], sel;\n-  enum machine_mode vmode = d->vmode;\n-  unsigned int i, nelt = d->nelt;\n-\n-  /* TODO: ARM's VTBL indexing is little-endian.  In order to handle GCC's\n-     numbering of elements for big-endian, we must reverse the order.  */\n-  if (BYTES_BIG_ENDIAN)\n-    return false;\n-\n-  if (d->testing_p)\n-    return true;\n-\n-  /* Generic code will try constant permutation twice.  Once with the\n-     original mode and again with the elements lowered to QImode.\n-     So wait and don't do the selector expansion ourselves.  */\n-  if (vmode != V8QImode && vmode != V16QImode)\n-    return false;\n-\n-  for (i = 0; i < nelt; ++i)\n-    rperm[i] = GEN_INT (d->perm[i]);\n-  sel = gen_rtx_CONST_VECTOR (vmode, gen_rtvec_v (nelt, rperm));\n-  sel = force_reg (vmode, sel);\n-\n-  arm_expand_vec_perm_1 (d->target, d->op0, d->op1, sel);\n-  return true;\n-}\n-\n-static bool\n-arm_expand_vec_perm_const_1 (struct expand_vec_perm_d *d)\n-{\n-  /* The pattern matching functions above are written to look for a small\n-     number to begin the sequence (0, 1, N/2).  If we begin with an index\n-     from the second operand, we can swap the operands.  */\n-  if (d->perm[0] >= d->nelt)\n-    {\n-      unsigned i, nelt = d->nelt;\n-      rtx x;\n-\n-      for (i = 0; i < nelt; ++i)\n-\td->perm[i] = (d->perm[i] + nelt) & (2 * nelt - 1);\n-\n-      x = d->op0;\n-      d->op0 = d->op1;\n-      d->op1 = x;\n-    }\n-\n-  if (TARGET_NEON)\n-    {\n-      if (arm_evpc_neon_vuzp (d))\n-\treturn true;\n-      if (arm_evpc_neon_vzip (d))\n-\treturn true;\n-      if (arm_evpc_neon_vrev (d))\n-\treturn true;\n-      if (arm_evpc_neon_vtrn (d))\n-\treturn true;\n-      return arm_evpc_neon_vtbl (d);\n-    }\n-  return false;\n-}\n-\n-/* Expand a vec_perm_const pattern.  */\n-\n-bool\n-arm_expand_vec_perm_const (rtx target, rtx op0, rtx op1, rtx sel)\n-{\n-  struct expand_vec_perm_d d;\n-  int i, nelt, which;\n-\n-  d.target = target;\n-  d.op0 = op0;\n-  d.op1 = op1;\n-\n-  d.vmode = GET_MODE (target);\n-  gcc_assert (VECTOR_MODE_P (d.vmode));\n-  d.nelt = nelt = GET_MODE_NUNITS (d.vmode);\n-  d.testing_p = false;\n-\n-  for (i = which = 0; i < nelt; ++i)\n-    {\n-      rtx e = XVECEXP (sel, 0, i);\n-      int ei = INTVAL (e) & (2 * nelt - 1);\n-      which |= (ei < nelt ? 1 : 2);\n-      d.perm[i] = ei;\n-    }\n-\n-  switch (which)\n-    {\n-    default:\n-      gcc_unreachable();\n-\n-    case 3:\n-      d.one_vector_p = false;\n-      if (!rtx_equal_p (op0, op1))\n-\tbreak;\n-\n-      /* The elements of PERM do not suggest that only the first operand\n-\t is used, but both operands are identical.  Allow easier matching\n-\t of the permutation by folding the permutation into the single\n-\t input vector.  */\n-      /* FALLTHRU */\n-    case 2:\n-      for (i = 0; i < nelt; ++i)\n-        d.perm[i] &= nelt - 1;\n-      d.op0 = op1;\n-      d.one_vector_p = true;\n-      break;\n-\n-    case 1:\n-      d.op1 = op0;\n-      d.one_vector_p = true;\n-      break;\n-    }\n-\n-  return arm_expand_vec_perm_const_1 (&d);\n-}\n-\n-/* Implement TARGET_VECTORIZE_VEC_PERM_CONST_OK.  */\n-\n-static bool\n-arm_vectorize_vec_perm_const_ok (enum machine_mode vmode,\n-\t\t\t\t const unsigned char *sel)\n-{\n-  struct expand_vec_perm_d d;\n-  unsigned int i, nelt, which;\n-  bool ret;\n-\n-  d.vmode = vmode;\n-  d.nelt = nelt = GET_MODE_NUNITS (d.vmode);\n-  d.testing_p = true;\n-  memcpy (d.perm, sel, nelt);\n-\n-  /* Categorize the set of elements in the selector.  */\n-  for (i = which = 0; i < nelt; ++i)\n-    {\n-      unsigned char e = d.perm[i];\n-      gcc_assert (e < 2 * nelt);\n-      which |= (e < nelt ? 1 : 2);\n-    }\n-\n-  /* For all elements from second vector, fold the elements to first.  */\n-  if (which == 2)\n-    for (i = 0; i < nelt; ++i)\n-      d.perm[i] -= nelt;\n-\n-  /* Check whether the mask can be applied to the vector type.  */\n-  d.one_vector_p = (which != 3);\n-\n-  d.target = gen_raw_REG (d.vmode, LAST_VIRTUAL_REGISTER + 1);\n-  d.op1 = d.op0 = gen_raw_REG (d.vmode, LAST_VIRTUAL_REGISTER + 2);\n-  if (!d.one_vector_p)\n-    d.op1 = gen_raw_REG (d.vmode, LAST_VIRTUAL_REGISTER + 3);\n-\n-  start_sequence ();\n-  ret = arm_expand_vec_perm_const_1 (&d);\n-  end_sequence ();\n-\n-  return ret;\n-}\n-\n-\f\n #include \"gt-arm.h\"\n+"}, {"sha": "94e0a5fd08cefba418ff9e8d94a09af1d8042681", "filename": "gcc/config/arm/neon.md", "status": "modified", "additions": 0, "deletions": 59, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b826bea7f3a828f9a8d23a0828572452101ced42/gcc%2Fconfig%2Farm%2Fneon.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b826bea7f3a828f9a8d23a0828572452101ced42/gcc%2Fconfig%2Farm%2Fneon.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fneon.md?ref=b826bea7f3a828f9a8d23a0828572452101ced42", "patch": "@@ -3876,65 +3876,6 @@\n   [(set_attr \"neon_type\" \"neon_bp_3cycle\")]\n )\n \n-;; These two are used by the vec_perm infrastructure for V16QImode.\n-(define_insn_and_split \"neon_vtbl1v16qi\"\n-  [(set (match_operand:V16QI 0 \"s_register_operand\" \"=w\")\n-\t(unspec:V16QI [(match_operand:V16QI 1 \"s_register_operand\" \"w\")\n-\t\t       (match_operand:V16QI 2 \"s_register_operand\" \"w\")]\n-\t\t      UNSPEC_VTBL))]\n-  \"TARGET_NEON\"\n-  \"#\"\n-  \"&& reload_completed\"\n-  [(const_int 0)]\n-{\n-  rtx op0, op1, op2, part0, part2;\n-  unsigned ofs;\n-\n-  op0 = operands[0];\n-  op1 = gen_lowpart (TImode, operands[1]);\n-  op2 = operands[2];\n-\n-  ofs = subreg_lowpart_offset (V8QImode, V16QImode);\n-  part0 = simplify_subreg (V8QImode, op0, V16QImode, ofs);\n-  part2 = simplify_subreg (V8QImode, op2, V16QImode, ofs);\n-  emit_insn (gen_neon_vtbl2v8qi (part0, op1, part2));\n-\n-  ofs = subreg_highpart_offset (V8QImode, V16QImode);\n-  part0 = simplify_subreg (V8QImode, op0, V16QImode, ofs);\n-  part2 = simplify_subreg (V8QImode, op2, V16QImode, ofs);\n-  emit_insn (gen_neon_vtbl2v8qi (part0, op1, part2));\n-  DONE;\n-})\n-\n-(define_insn_and_split \"neon_vtbl2v16qi\"\n-  [(set (match_operand:V16QI 0 \"s_register_operand\" \"=w\")\n-\t(unspec:V16QI [(match_operand:OI 1 \"s_register_operand\" \"w\")\n-\t\t       (match_operand:V16QI 2 \"s_register_operand\" \"w\")]\n-\t\t      UNSPEC_VTBL))]\n-  \"TARGET_NEON\"\n-  \"#\"\n-  \"&& reload_completed\"\n-  [(const_int 0)]\n-{\n-  rtx op0, op1, op2, part0, part2;\n-  unsigned ofs;\n-\n-  op0 = operands[0];\n-  op1 = operands[1];\n-  op2 = operands[2];\n-\n-  ofs = subreg_lowpart_offset (V8QImode, V16QImode);\n-  part0 = simplify_subreg (V8QImode, op0, V16QImode, ofs);\n-  part2 = simplify_subreg (V8QImode, op2, V16QImode, ofs);\n-  emit_insn (gen_neon_vtbl2v8qi (part0, op1, part2));\n-\n-  ofs = subreg_highpart_offset (V8QImode, V16QImode);\n-  part0 = simplify_subreg (V8QImode, op0, V16QImode, ofs);\n-  part2 = simplify_subreg (V8QImode, op2, V16QImode, ofs);\n-  emit_insn (gen_neon_vtbl2v8qi (part0, op1, part2));\n-  DONE;\n-})\n-\n (define_insn \"neon_vtbx1v8qi\"\n   [(set (match_operand:V8QI 0 \"s_register_operand\" \"=w\")\n \t(unspec:V8QI [(match_operand:V8QI 1 \"s_register_operand\" \"0\")"}, {"sha": "c27c414116033bede9e3dd649f76e6794f8012eb", "filename": "gcc/config/arm/vec-common.md", "status": "modified", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b826bea7f3a828f9a8d23a0828572452101ced42/gcc%2Fconfig%2Farm%2Fvec-common.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b826bea7f3a828f9a8d23a0828572452101ced42/gcc%2Fconfig%2Farm%2Fvec-common.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fvec-common.md?ref=b826bea7f3a828f9a8d23a0828572452101ced42", "patch": "@@ -108,29 +108,3 @@\n    || (TARGET_REALLY_IWMMXT && VALID_IWMMXT_REG_MODE (<MODE>mode))\"\n {\n })\n-\n-(define_expand \"vec_perm_const<mode>\"\n-  [(match_operand:VALL 0 \"s_register_operand\" \"\")\n-   (match_operand:VALL 1 \"s_register_operand\" \"\")\n-   (match_operand:VALL 2 \"s_register_operand\" \"\")\n-   (match_operand:<V_cmp_result> 3 \"\" \"\")]\n-  \"TARGET_NEON\n-   || (TARGET_REALLY_IWMMXT && VALID_IWMMXT_REG_MODE (<MODE>mode))\"\n-{\n-  if (arm_expand_vec_perm_const (operands[0], operands[1],\n-\t\t\t\t operands[2], operands[3]))\n-    DONE;\n-  else\n-    FAIL;\n-})\n-\n-(define_expand \"vec_perm<mode>\"\n-  [(match_operand:VE 0 \"s_register_operand\" \"\")\n-   (match_operand:VE 1 \"s_register_operand\" \"\")\n-   (match_operand:VE 2 \"s_register_operand\" \"\")\n-   (match_operand:VE 3 \"s_register_operand\" \"\")]\n-  \"TARGET_NEON && !BYTES_BIG_ENDIAN\"\n-{\n-  arm_expand_vec_perm (operands[0], operands[1], operands[2], operands[3]);\n-  DONE;\n-})"}, {"sha": "216ab0b713c0eaed6b23d36a4ef4e066fb443767", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 4, "deletions": 22, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b826bea7f3a828f9a8d23a0828572452101ced42/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b826bea7f3a828f9a8d23a0828572452101ced42/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=b826bea7f3a828f9a8d23a0828572452101ced42", "patch": "@@ -35984,8 +35984,6 @@ expand_vec_perm_palignr (struct expand_vec_perm_d *d)\n   return ok;\n }\n \n-static bool expand_vec_perm_interleave3 (struct expand_vec_perm_d *d);\n-\n /* A subroutine of ix86_expand_vec_perm_builtin_1.  Try to simplify\n    a two vector permutation into a single vector permutation by using\n    an interleave operation to merge the vectors.  */\n@@ -36012,17 +36010,6 @@ expand_vec_perm_interleave2 (struct expand_vec_perm_d *d)\n       /* For 32-byte modes allow even d->op0 == d->op1.\n \t The lack of cross-lane shuffling in some instructions\n \t might prevent a single insn shuffle.  */\n-      dfinal = *d;\n-      dfinal.testing_p = true;\n-      /* If expand_vec_perm_interleave3 can expand this into\n-\t a 3 insn sequence, give up and let it be expanded as\n-\t 3 insn sequence.  While that is one insn longer,\n-\t it doesn't need a memory operand and in the common\n-\t case that both interleave low and high permutations\n-\t with the same operands are adjacent needs 4 insns\n-\t for both after CSE.  */\n-      if (expand_vec_perm_interleave3 (&dfinal))\n-\treturn false;\n     }\n   else\n     return false;\n@@ -36862,23 +36849,18 @@ expand_vec_perm_broadcast_1 (struct expand_vec_perm_d *d)\n \t stopping once we have promoted to V4SImode and then use pshufd.  */\n       do\n \t{\n-\t  rtx dest;\n-\t  rtx (*gen) (rtx, rtx, rtx)\n-\t    = vmode == V16QImode ? gen_vec_interleave_lowv16qi\n-\t\t\t\t : gen_vec_interleave_lowv8hi;\n+\t  optab otab = vec_interleave_low_optab;\n \n \t  if (elt >= nelt2)\n \t    {\n-\t      gen = vmode == V16QImode ? gen_vec_interleave_highv16qi\n-\t\t\t\t       : gen_vec_interleave_highv8hi;\n+\t      otab = vec_interleave_high_optab;\n \t      elt -= nelt2;\n \t    }\n \t  nelt2 /= 2;\n \n-\t  dest = gen_reg_rtx (vmode);\n-\t  emit_insn (gen (dest, op0, op0));\n+\t  op0 = expand_binop (vmode, otab, op0, op0, NULL, 0, OPTAB_DIRECT);\n \t  vmode = get_mode_wider_vector (vmode);\n-\t  op0 = gen_lowpart (vmode, dest);\n+\t  op0 = gen_lowpart (vmode, op0);\n \t}\n       while (vmode != V4SImode);\n "}, {"sha": "82b2663694673f71e530b14925d8ce8f38522e6e", "filename": "gcc/doc/generic.texi", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b826bea7f3a828f9a8d23a0828572452101ced42/gcc%2Fdoc%2Fgeneric.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b826bea7f3a828f9a8d23a0828572452101ced42/gcc%2Fdoc%2Fgeneric.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgeneric.texi?ref=b826bea7f3a828f9a8d23a0828572452101ced42", "patch": "@@ -1697,6 +1697,8 @@ its sole argument yields the representation for @code{ap}.\n @tindex VEC_PACK_FIX_TRUNC_EXPR\n @tindex VEC_EXTRACT_EVEN_EXPR\n @tindex VEC_EXTRACT_ODD_EXPR\n+@tindex VEC_INTERLEAVE_HIGH_EXPR\n+@tindex VEC_INTERLEAVE_LOW_EXPR\n \n @table @code\n @item VEC_LSHIFT_EXPR\n@@ -1772,6 +1774,17 @@ These nodes represent extracting of the even/odd elements of the two input\n vectors, respectively. Their operands and result are vectors that contain the\n same number of elements of the same type.\n \n+@item VEC_INTERLEAVE_HIGH_EXPR\n+@itemx VEC_INTERLEAVE_LOW_EXPR\n+These nodes represent merging and interleaving of the high/low elements of the\n+two input vectors, respectively. The operands and the result are vectors that\n+contain the same number of elements (@code{N}) of the same type.\n+In the case of @code{VEC_INTERLEAVE_HIGH_EXPR}, the high @code{N/2} elements of\n+the first input vector are interleaved with the high @code{N/2} elements of the\n+second input vector. In the case of @code{VEC_INTERLEAVE_LOW_EXPR}, the low\n+@code{N/2} elements of the first input vector are interleaved with the low\n+@code{N/2} elements of the second input vector.\n+\n @end table\n \n "}, {"sha": "dc87ca732d3b6bb37a26263479816d9c4fa7a691", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b826bea7f3a828f9a8d23a0828572452101ced42/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b826bea7f3a828f9a8d23a0828572452101ced42/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=b826bea7f3a828f9a8d23a0828572452101ced42", "patch": "@@ -4159,6 +4159,20 @@ The odd elements of operand 2 are concatenated to the odd elements of operand\n 1 in their original order. The result is stored in operand 0.\n The output and input vectors should have the same modes.\n \n+@cindex @code{vec_interleave_high@var{m}} instruction pattern\n+@item @samp{vec_interleave_high@var{m}}\n+Merge high elements of the two input vectors into the output vector. The output\n+and input vectors should have the same modes (@code{N} elements). The high\n+@code{N/2} elements of the first input vector are interleaved with the high\n+@code{N/2} elements of the second input vector.\n+\n+@cindex @code{vec_interleave_low@var{m}} instruction pattern\n+@item @samp{vec_interleave_low@var{m}}\n+Merge low elements of the two input vectors into the output vector. The output\n+and input vectors should have the same modes (@code{N} elements). The low\n+@code{N/2} elements of the first input vector are interleaved with the low\n+@code{N/2} elements of the second input vector.\n+\n @cindex @code{vec_init@var{m}} instruction pattern\n @item @samp{vec_init@var{m}}\n Initialize the vector to given values.  Operand 0 is the vector to initialize"}, {"sha": "aa78468a96be92b854327e28bea6063600696a70", "filename": "gcc/expr.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b826bea7f3a828f9a8d23a0828572452101ced42/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b826bea7f3a828f9a8d23a0828572452101ced42/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=b826bea7f3a828f9a8d23a0828572452101ced42", "patch": "@@ -8647,6 +8647,8 @@ expand_expr_real_2 (sepops ops, rtx target, enum machine_mode tmode,\n \n     case VEC_EXTRACT_EVEN_EXPR:\n     case VEC_EXTRACT_ODD_EXPR:\n+    case VEC_INTERLEAVE_HIGH_EXPR:\n+    case VEC_INTERLEAVE_LOW_EXPR:\n       goto binop;\n \n     case VEC_LSHIFT_EXPR:"}, {"sha": "a32ea9000e6d79a10084f1756c5d0c6ba8e310ce", "filename": "gcc/fold-const.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b826bea7f3a828f9a8d23a0828572452101ced42/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b826bea7f3a828f9a8d23a0828572452101ced42/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=b826bea7f3a828f9a8d23a0828572452101ced42", "patch": "@@ -13503,6 +13503,8 @@ fold_binary_loc (location_t loc,\n \n     case VEC_EXTRACT_EVEN_EXPR:\n     case VEC_EXTRACT_ODD_EXPR:\n+    case VEC_INTERLEAVE_HIGH_EXPR:\n+    case VEC_INTERLEAVE_LOW_EXPR:\n       if ((TREE_CODE (arg0) == VECTOR_CST\n \t   || TREE_CODE (arg0) == CONSTRUCTOR)\n \t  && (TREE_CODE (arg1) == VECTOR_CST\n@@ -13520,6 +13522,14 @@ fold_binary_loc (location_t loc,\n \t      case VEC_EXTRACT_ODD_EXPR:\n \t\tsel[i] = i * 2 + 1;\n \t\tbreak;\n+\t      case VEC_INTERLEAVE_HIGH_EXPR:\n+\t\tsel[i] = (i + (BYTES_BIG_ENDIAN ? 0 : nelts)) / 2\n+\t\t\t + ((i & 1) ? nelts : 0);\n+\t\tbreak;\n+\t      case VEC_INTERLEAVE_LOW_EXPR:\n+\t\tsel[i] = (i + (BYTES_BIG_ENDIAN ? nelts : 0)) / 2\n+\t\t\t + ((i & 1) ? nelts : 0);\n+\t\tbreak;\n \t      default:\n \t\tgcc_unreachable ();\n \t      }"}, {"sha": "63c58a8237ab8a4f703c9461d820a9445b144e19", "filename": "gcc/genopinit.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b826bea7f3a828f9a8d23a0828572452101ced42/gcc%2Fgenopinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b826bea7f3a828f9a8d23a0828572452101ced42/gcc%2Fgenopinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenopinit.c?ref=b826bea7f3a828f9a8d23a0828572452101ced42", "patch": "@@ -1,6 +1,6 @@\n /* Generate code to initialize optabs from machine description.\n    Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,\n-   2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2010, 2011\n+   2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2010\n    Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -269,6 +269,8 @@ static const char * const optabs[] =\n   \"set_optab_handler (vec_extract_optab, $A, CODE_FOR_$(vec_extract$a$))\",\n   \"set_optab_handler (vec_extract_even_optab, $A, CODE_FOR_$(vec_extract_even$a$))\",\n   \"set_optab_handler (vec_extract_odd_optab, $A, CODE_FOR_$(vec_extract_odd$a$))\",\n+  \"set_optab_handler (vec_interleave_high_optab, $A, CODE_FOR_$(vec_interleave_high$a$))\",\n+  \"set_optab_handler (vec_interleave_low_optab, $A, CODE_FOR_$(vec_interleave_low$a$))\",\n   \"set_optab_handler (vec_init_optab, $A, CODE_FOR_$(vec_init$a$))\",\n   \"set_optab_handler (vec_shl_optab, $A, CODE_FOR_$(vec_shl_$a$))\",\n   \"set_optab_handler (vec_shr_optab, $A, CODE_FOR_$(vec_shr_$a$))\","}, {"sha": "3b5f670e60e102fc10425258f1f5d14cf35faf90", "filename": "gcc/gimple-pretty-print.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b826bea7f3a828f9a8d23a0828572452101ced42/gcc%2Fgimple-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b826bea7f3a828f9a8d23a0828572452101ced42/gcc%2Fgimple-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-pretty-print.c?ref=b826bea7f3a828f9a8d23a0828572452101ced42", "patch": "@@ -347,6 +347,8 @@ dump_binary_rhs (pretty_printer *buffer, gimple gs, int spc, int flags)\n     case VEC_PACK_FIX_TRUNC_EXPR:\n     case VEC_EXTRACT_EVEN_EXPR:\n     case VEC_EXTRACT_ODD_EXPR:\n+    case VEC_INTERLEAVE_HIGH_EXPR:\n+    case VEC_INTERLEAVE_LOW_EXPR:\n     case VEC_WIDEN_LSHIFT_HI_EXPR:\n     case VEC_WIDEN_LSHIFT_LO_EXPR:\n       for (p = tree_code_name [(int) code]; *p; p++)"}, {"sha": "0d5cd73c3a2417de85df24dfbd5dab7c6ffc5dd0", "filename": "gcc/optabs.c", "status": "modified", "additions": 26, "deletions": 2, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b826bea7f3a828f9a8d23a0828572452101ced42/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b826bea7f3a828f9a8d23a0828572452101ced42/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=b826bea7f3a828f9a8d23a0828572452101ced42", "patch": "@@ -553,6 +553,12 @@ optab_for_tree_code (enum tree_code code, const_tree type,\n     case VEC_EXTRACT_ODD_EXPR:\n       return vec_extract_odd_optab;\n \n+    case VEC_INTERLEAVE_HIGH_EXPR:\n+      return vec_interleave_high_optab;\n+\n+    case VEC_INTERLEAVE_LOW_EXPR:\n+      return vec_interleave_low_optab;\n+\n     default:\n       return NULL;\n     }\n@@ -1606,7 +1612,11 @@ expand_binop (enum machine_mode mode, optab binoptab, rtx op0, rtx op1,\n       enum tree_code tcode = ERROR_MARK;\n       rtx sel;\n \n-      if (binoptab == vec_extract_even_optab)\n+      if (binoptab == vec_interleave_high_optab)\n+\ttcode = VEC_INTERLEAVE_HIGH_EXPR;\n+      else if (binoptab == vec_interleave_low_optab)\n+\ttcode = VEC_INTERLEAVE_LOW_EXPR;\n+      else if (binoptab == vec_extract_even_optab)\n \ttcode = VEC_EXTRACT_EVEN_EXPR;\n       else if (binoptab == vec_extract_odd_optab)\n \ttcode = VEC_EXTRACT_ODD_EXPR;\n@@ -6261,6 +6271,8 @@ init_optabs (void)\n   init_optab (vec_extract_optab, UNKNOWN);\n   init_optab (vec_extract_even_optab, UNKNOWN);\n   init_optab (vec_extract_odd_optab, UNKNOWN);\n+  init_optab (vec_interleave_high_optab, UNKNOWN);\n+  init_optab (vec_interleave_low_optab, UNKNOWN);\n   init_optab (vec_set_optab, UNKNOWN);\n   init_optab (vec_init_optab, UNKNOWN);\n   init_optab (vec_shl_optab, UNKNOWN);\n@@ -6868,7 +6880,8 @@ can_vec_perm_p (enum machine_mode mode, bool variable,\n   return true;\n }\n \n-/* Return true if we can implement with VEC_PERM_EXPR for this target.\n+/* Return true if we can implement VEC_INTERLEAVE_{HIGH,LOW}_EXPR or\n+   VEC_EXTRACT_{EVEN,ODD}_EXPR with VEC_PERM_EXPR for this target.\n    If PSEL is non-null, return the selector for the permutation.  */\n \n bool\n@@ -6918,6 +6931,17 @@ can_vec_perm_for_code_p (enum tree_code code, enum machine_mode mode,\n \t    data[i] = i * 2 + alt;\n \t  break;\n \n+\tcase VEC_INTERLEAVE_HIGH_EXPR:\n+\tcase VEC_INTERLEAVE_LOW_EXPR:\n+\t  if ((BYTES_BIG_ENDIAN != 0) ^ (code == VEC_INTERLEAVE_HIGH_EXPR))\n+\t    alt = nelt / 2;\n+\t  for (i = 0; i < nelt / 2; ++i)\n+\t    {\n+\t      data[i * 2] = i + alt;\n+\t      data[i * 2 + 1] = i + nelt + alt;\n+\t    }\n+\t  break;\n+\n \tdefault:\n \t  gcc_unreachable ();\n \t}"}, {"sha": "ec13f6ff3017d4c33912ed03ace710937a6d59d7", "filename": "gcc/optabs.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b826bea7f3a828f9a8d23a0828572452101ced42/gcc%2Foptabs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b826bea7f3a828f9a8d23a0828572452101ced42/gcc%2Foptabs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.h?ref=b826bea7f3a828f9a8d23a0828572452101ced42", "patch": "@@ -335,6 +335,9 @@ enum optab_index\n   /* Extract even/odd fields of vector operands.  */\n   OTI_vec_extract_even,\n   OTI_vec_extract_odd,\n+  /* Interleave fields of vector operands.  */\n+  OTI_vec_interleave_high,\n+  OTI_vec_interleave_low,\n   /* Initialize vector operand.  */\n   OTI_vec_init,\n   /* Whole vector shift. The shift amount is in bits.  */\n@@ -561,6 +564,8 @@ enum optab_index\n #define vec_extract_optab (&optab_table[OTI_vec_extract])\n #define vec_extract_even_optab (&optab_table[OTI_vec_extract_even])\n #define vec_extract_odd_optab (&optab_table[OTI_vec_extract_odd])\n+#define vec_interleave_high_optab (&optab_table[OTI_vec_interleave_high])\n+#define vec_interleave_low_optab (&optab_table[OTI_vec_interleave_low])\n #define vec_init_optab (&optab_table[OTI_vec_init])\n #define vec_shl_optab (&optab_table[OTI_vec_shl])\n #define vec_shr_optab (&optab_table[OTI_vec_shr])"}, {"sha": "78223afe601a90c43b68f9359eb06e557bd0aa60", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b826bea7f3a828f9a8d23a0828572452101ced42/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b826bea7f3a828f9a8d23a0828572452101ced42/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=b826bea7f3a828f9a8d23a0828572452101ced42", "patch": "@@ -2725,8 +2725,7 @@ proc check_effective_target_vect_perm { } {\n         verbose \"check_effective_target_vect_perm: using cached result\" 2\n     } else {\n         set et_vect_perm_saved 0\n-        if { [is-effective-target arm_neon_ok]\n-\t     || [istarget powerpc*-*-*]\n+        if { [istarget powerpc*-*-*]\n              || [istarget spu-*-*]\n \t     || [istarget i?86-*-*]\n \t     || [istarget x86_64-*-*] } {\n@@ -2749,8 +2748,7 @@ proc check_effective_target_vect_perm_byte { } {\n         verbose \"check_effective_target_vect_perm_byte: using cached result\" 2\n     } else {\n         set et_vect_perm_byte_saved 0\n-        if { [is-effective-target arm_neon_ok]\n-\t     || [istarget powerpc*-*-*]\n+        if { [istarget powerpc*-*-*]\n              || [istarget spu-*-*] } {\n             set et_vect_perm_byte_saved 1\n         }\n@@ -2771,8 +2769,7 @@ proc check_effective_target_vect_perm_short { } {\n         verbose \"check_effective_target_vect_perm_short: using cached result\" 2\n     } else {\n         set et_vect_perm_short_saved 0\n-        if { [is-effective-target arm_neon_ok]\n-\t     || [istarget powerpc*-*-*]\n+        if { [istarget powerpc*-*-*]\n              || [istarget spu-*-*] } {\n             set et_vect_perm_short_saved 1\n         }"}, {"sha": "db10daf6abc7da55bb2711ed2f22504521f6a499", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b826bea7f3a828f9a8d23a0828572452101ced42/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b826bea7f3a828f9a8d23a0828572452101ced42/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=b826bea7f3a828f9a8d23a0828572452101ced42", "patch": "@@ -3704,6 +3704,8 @@ verify_gimple_assign_binary (gimple stmt)\n     case VEC_PACK_FIX_TRUNC_EXPR:\n     case VEC_EXTRACT_EVEN_EXPR:\n     case VEC_EXTRACT_ODD_EXPR:\n+    case VEC_INTERLEAVE_HIGH_EXPR:\n+    case VEC_INTERLEAVE_LOW_EXPR:\n       /* FIXME.  */\n       return false;\n "}, {"sha": "13ad8153fa9ab2f0e8c92b85302992c829860387", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b826bea7f3a828f9a8d23a0828572452101ced42/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b826bea7f3a828f9a8d23a0828572452101ced42/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=b826bea7f3a828f9a8d23a0828572452101ced42", "patch": "@@ -3401,6 +3401,8 @@ estimate_operator_cost (enum tree_code code, eni_weights *weights,\n     case VEC_PACK_FIX_TRUNC_EXPR:\n     case VEC_EXTRACT_EVEN_EXPR:\n     case VEC_EXTRACT_ODD_EXPR:\n+    case VEC_INTERLEAVE_HIGH_EXPR:\n+    case VEC_INTERLEAVE_LOW_EXPR:\n     case VEC_WIDEN_LSHIFT_HI_EXPR:\n     case VEC_WIDEN_LSHIFT_LO_EXPR:\n "}, {"sha": "9abe004280bd3a725a49ac518483c4e72210e02a", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b826bea7f3a828f9a8d23a0828572452101ced42/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b826bea7f3a828f9a8d23a0828572452101ced42/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=b826bea7f3a828f9a8d23a0828572452101ced42", "patch": "@@ -2404,6 +2404,22 @@ dump_generic_node (pretty_printer *buffer, tree node, int spc, int flags,\n       pp_string (buffer, \" > \");\n       break;\n \n+    case VEC_INTERLEAVE_HIGH_EXPR:\n+      pp_string (buffer, \" VEC_INTERLEAVE_HIGH_EXPR < \");\n+      dump_generic_node (buffer, TREE_OPERAND (node, 0), spc, flags, false);\n+      pp_string (buffer, \", \");\n+      dump_generic_node (buffer, TREE_OPERAND (node, 1), spc, flags, false);\n+      pp_string (buffer, \" > \");\n+      break;\n+\n+    case VEC_INTERLEAVE_LOW_EXPR:\n+      pp_string (buffer, \" VEC_INTERLEAVE_LOW_EXPR < \");\n+      dump_generic_node (buffer, TREE_OPERAND (node, 0), spc, flags, false);\n+      pp_string (buffer, \", \");\n+      dump_generic_node (buffer, TREE_OPERAND (node, 1), spc, flags, false);\n+      pp_string (buffer, \" > \");\n+      break;\n+\n     default:\n       NIY;\n     }"}, {"sha": "6a85b7bf4aa35819a02075ebbfc4d2a0bca962e1", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 43, "deletions": 43, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b826bea7f3a828f9a8d23a0828572452101ced42/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b826bea7f3a828f9a8d23a0828572452101ced42/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=b826bea7f3a828f9a8d23a0828572452101ced42", "patch": "@@ -3800,6 +3800,7 @@ vect_create_destination_var (tree scalar_dest, tree vectype)\n bool\n vect_strided_store_supported (tree vectype, unsigned HOST_WIDE_INT count)\n {\n+  optab ih_optab, il_optab;\n   enum machine_mode mode;\n \n   mode = TYPE_MODE (vectype);\n@@ -3814,23 +3815,18 @@ vect_strided_store_supported (tree vectype, unsigned HOST_WIDE_INT count)\n     }\n \n   /* Check that the operation is supported.  */\n-  if (VECTOR_MODE_P (mode))\n-    {\n-      unsigned int i, nelt = GET_MODE_NUNITS (mode);\n-      unsigned char *sel = XALLOCAVEC (unsigned char, nelt);\n-      for (i = 0; i < nelt / 2; i++)\n-\t{\n-\t  sel[i * 2] = i;\n-\t  sel[i * 2 + 1] = i + nelt;\n-\t}\n-      if (can_vec_perm_p (mode, false, sel))\n-\t{\n-\t  for (i = 0; i < nelt; i++)\n-\t    sel[i] += nelt / 2;\n-\t  if (can_vec_perm_p (mode, false, sel))\n-\t    return true;\n-\t}\n-    }\n+  ih_optab = optab_for_tree_code (VEC_INTERLEAVE_HIGH_EXPR,\n+\t\t\t\t  vectype, optab_default);\n+  il_optab = optab_for_tree_code (VEC_INTERLEAVE_LOW_EXPR,\n+\t\t\t\t  vectype, optab_default);\n+  if (il_optab && ih_optab\n+      && optab_handler (ih_optab, mode) != CODE_FOR_nothing\n+      && optab_handler (il_optab, mode) != CODE_FOR_nothing)\n+    return true;\n+\n+  if (can_vec_perm_for_code_p (VEC_INTERLEAVE_HIGH_EXPR, mode, NULL)\n+      && can_vec_perm_for_code_p (VEC_INTERLEAVE_LOW_EXPR, mode, NULL))\n+    return true;\n \n   if (vect_print_dump_info (REPORT_DETAILS))\n     fprintf (vect_dump, \"interleave op not supported by target.\");\n@@ -3921,54 +3917,58 @@ vect_permute_store_chain (VEC(tree,heap) *dr_chain,\n   tree perm_dest, vect1, vect2, high, low;\n   gimple perm_stmt;\n   tree vectype = STMT_VINFO_VECTYPE (vinfo_for_stmt (stmt));\n-  tree perm_mask_low, perm_mask_high;\n-  unsigned int i, n;\n-  unsigned int j, nelt = GET_MODE_NUNITS (TYPE_MODE (vectype));\n-  unsigned char *sel = XALLOCAVEC (unsigned char, nelt);\n+  int i;\n+  unsigned int j;\n+  enum tree_code high_code, low_code;\n \n   gcc_assert (vect_strided_store_supported (vectype, length));\n \n   *result_chain = VEC_copy (tree, heap, dr_chain);\n \n-  for (i = 0, n = nelt / 2; i < n; i++)\n-    {\n-      sel[i * 2] = i;\n-      sel[i * 2 + 1] = i + nelt;\n-    }\n-  perm_mask_high = vect_gen_perm_mask (vectype, sel);\n-  for (i = 0; i < nelt; i++)\n-    sel[i] += nelt / 2;\n-  perm_mask_low = vect_gen_perm_mask (vectype, sel);\n-\n-  for (i = 0, n = exact_log2 (length); i < n; i++)\n+  for (i = 0; i < exact_log2 (length); i++)\n     {\n       for (j = 0; j < length/2; j++)\n \t{\n \t  vect1 = VEC_index (tree, dr_chain, j);\n \t  vect2 = VEC_index (tree, dr_chain, j+length/2);\n \n \t  /* Create interleaving stmt:\n-\t     high = VEC_PERM_EXPR <vect1, vect2, {0, nelt, 1, nelt+1, ...}>  */\n+\t     in the case of big endian:\n+                                high = interleave_high (vect1, vect2)\n+             and in the case of little endian:\n+                                high = interleave_low (vect1, vect2).  */\n \t  perm_dest = create_tmp_var (vectype, \"vect_inter_high\");\n \t  DECL_GIMPLE_REG_P (perm_dest) = 1;\n \t  add_referenced_var (perm_dest);\n-\t  high = make_ssa_name (perm_dest, NULL);\n-\t  perm_stmt\n-\t    = gimple_build_assign_with_ops3 (VEC_PERM_EXPR, high,\n-\t\t\t\t\t     vect1, vect2, perm_mask_high);\n+          if (BYTES_BIG_ENDIAN)\n+\t    {\n+\t      high_code = VEC_INTERLEAVE_HIGH_EXPR;\n+\t      low_code = VEC_INTERLEAVE_LOW_EXPR;\n+\t    }\n+\t  else\n+\t    {\n+\t      low_code = VEC_INTERLEAVE_HIGH_EXPR;\n+\t      high_code = VEC_INTERLEAVE_LOW_EXPR;\n+\t    }\n+\t  perm_stmt = gimple_build_assign_with_ops (high_code, perm_dest,\n+\t\t\t\t\t\t    vect1, vect2);\n+\t  high = make_ssa_name (perm_dest, perm_stmt);\n+\t  gimple_assign_set_lhs (perm_stmt, high);\n \t  vect_finish_stmt_generation (stmt, perm_stmt, gsi);\n \t  VEC_replace (tree, *result_chain, 2*j, high);\n \n \t  /* Create interleaving stmt:\n-\t     low = VEC_PERM_EXPR <vect1, vect2, {nelt/2, nelt*3/2, nelt/2+1,\n-\t\t\t\t\t\t nelt*3/2+1, ...}>  */\n+             in the case of big endian:\n+                               low  = interleave_low (vect1, vect2)\n+             and in the case of little endian:\n+                               low  = interleave_high (vect1, vect2).  */\n \t  perm_dest = create_tmp_var (vectype, \"vect_inter_low\");\n \t  DECL_GIMPLE_REG_P (perm_dest) = 1;\n \t  add_referenced_var (perm_dest);\n-\t  low = make_ssa_name (perm_dest, NULL);\n-\t  perm_stmt\n-\t    = gimple_build_assign_with_ops3 (VEC_PERM_EXPR, low,\n-\t\t\t\t\t     vect1, vect2, perm_mask_low);\n+\t  perm_stmt = gimple_build_assign_with_ops (low_code, perm_dest,\n+\t\t\t\t\t\t    vect1, vect2);\n+\t  low = make_ssa_name (perm_dest, perm_stmt);\n+\t  gimple_assign_set_lhs (perm_stmt, low);\n \t  vect_finish_stmt_generation (stmt, perm_stmt, gsi);\n \t  VEC_replace (tree, *result_chain, 2*j+1, low);\n \t}"}, {"sha": "dc01ce7b24cf220207860454edbd3fa5fb1369fb", "filename": "gcc/tree-vect-generic.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b826bea7f3a828f9a8d23a0828572452101ced42/gcc%2Ftree-vect-generic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b826bea7f3a828f9a8d23a0828572452101ced42/gcc%2Ftree-vect-generic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-generic.c?ref=b826bea7f3a828f9a8d23a0828572452101ced42", "patch": "@@ -776,7 +776,9 @@ expand_vector_operations_1 (gimple_stmt_iterator *gsi)\n   /* These are only created by the vectorizer, after having queried\n      the target support.  It's more than just looking at the optab,\n      and there's no need to do it again.  */\n-  if (code == VEC_EXTRACT_EVEN_EXPR\n+  if (code == VEC_INTERLEAVE_HIGH_EXPR\n+      || code == VEC_INTERLEAVE_LOW_EXPR\n+      || code == VEC_EXTRACT_EVEN_EXPR\n       || code == VEC_EXTRACT_ODD_EXPR)\n     return;\n "}, {"sha": "046a76fd8ae016fbceb5b706d537bbbb3146152b", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b826bea7f3a828f9a8d23a0828572452101ced42/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b826bea7f3a828f9a8d23a0828572452101ced42/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=b826bea7f3a828f9a8d23a0828572452101ced42", "patch": "@@ -3828,8 +3828,8 @@ vectorizable_store (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n \n      Then permutation statements are generated:\n \n-\tVS5: vx5 = VEC_PERM_EXPR < vx0, vx3, {0, 8, 1, 9, 2, 10, 3, 11} >\n-\tVS6: vx6 = VEC_PERM_EXPR < vx0, vx3, {4, 12, 5, 13, 6, 14, 7, 15} >\n+        VS5: vx5 = VEC_INTERLEAVE_HIGH_EXPR < vx0, vx3 >\n+        VS6: vx6 = VEC_INTERLEAVE_LOW_EXPR < vx0, vx3 >\n \t...\n \n      And they are put in STMT_VINFO_VEC_STMT of the corresponding scalar stmts\n@@ -4026,8 +4026,8 @@ vectorizable_store (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n    the VECTOR_CST mask that implements the permutation of the\n    vector elements.  If that is impossible to do, returns NULL.  */\n \n-tree\n-vect_gen_perm_mask (tree vectype, unsigned char *sel)\n+static tree\n+gen_perm_mask (tree vectype, unsigned char *sel)\n {\n   tree mask_elt_type, mask_type, mask_vec;\n   int i, nunits;\n@@ -4067,7 +4067,7 @@ perm_mask_for_reverse (tree vectype)\n   for (i = 0; i < nunits; ++i)\n     sel[i] = nunits - 1 - i;\n \n-  return vect_gen_perm_mask (vectype, sel);\n+  return gen_perm_mask (vectype, sel);\n }\n \n /* Given a vector variable X and Y, that was generated for the scalar\n@@ -4314,7 +4314,7 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n \t  for (i = 0; i < gather_off_nunits; ++i)\n \t    sel[i] = i | nunits;\n \n-\t  perm_mask = vect_gen_perm_mask (gather_off_vectype, sel);\n+\t  perm_mask = gen_perm_mask (gather_off_vectype, sel);\n \t  gcc_assert (perm_mask != NULL_TREE);\n \t}\n       else if (nunits == gather_off_nunits * 2)\n@@ -4326,7 +4326,7 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n \t    sel[i] = i < gather_off_nunits\n \t\t     ? i : i + nunits - gather_off_nunits;\n \n-\t  perm_mask = vect_gen_perm_mask (vectype, sel);\n+\t  perm_mask = gen_perm_mask (vectype, sel);\n \t  gcc_assert (perm_mask != NULL_TREE);\n \t  ncopies *= 2;\n \t}"}, {"sha": "927c0bd8cb5763542db56d82202c4c056658f67f", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b826bea7f3a828f9a8d23a0828572452101ced42/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b826bea7f3a828f9a8d23a0828572452101ced42/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=b826bea7f3a828f9a8d23a0828572452101ced42", "patch": "@@ -848,7 +848,6 @@ extern void vect_get_store_cost (struct data_reference *, int, unsigned int *);\n extern bool vect_supportable_shift (enum tree_code, tree);\n extern void vect_get_vec_defs (tree, tree, gimple, VEC (tree, heap) **,\n \t\t\t       VEC (tree, heap) **, slp_tree, int);\n-extern tree vect_gen_perm_mask (tree, unsigned char *);\n \n /* In tree-vect-data-refs.c.  */\n extern bool vect_can_force_dr_alignment_p (const_tree, unsigned int);"}, {"sha": "11ce8b5b7568df728270882fbb67b1b26bc9d1af", "filename": "gcc/tree.def", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b826bea7f3a828f9a8d23a0828572452101ced42/gcc%2Ftree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b826bea7f3a828f9a8d23a0828572452101ced42/gcc%2Ftree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.def?ref=b826bea7f3a828f9a8d23a0828572452101ced42", "patch": "@@ -1192,6 +1192,10 @@ DEFTREECODE (VEC_PACK_FIX_TRUNC_EXPR, \"vec_pack_fix_trunc_expr\", tcc_binary, 2)\n DEFTREECODE (VEC_EXTRACT_EVEN_EXPR, \"vec_extract_even_expr\", tcc_binary, 2)\n DEFTREECODE (VEC_EXTRACT_ODD_EXPR, \"vec_extract_odd_expr\", tcc_binary, 2)\n \n+/* Merge input vectors interleaving their fields.  */\n+DEFTREECODE (VEC_INTERLEAVE_HIGH_EXPR, \"vec_interleave_high_expr\", tcc_binary, 2)\n+DEFTREECODE (VEC_INTERLEAVE_LOW_EXPR, \"vec_interleave_low_expr\", tcc_binary, 2)\n+\n /* Widening vector shift left in bits.\n    Operand 0 is a vector to be shifted with N elements of size S.\n    Operand 1 is an integer shift amount in bits."}]}