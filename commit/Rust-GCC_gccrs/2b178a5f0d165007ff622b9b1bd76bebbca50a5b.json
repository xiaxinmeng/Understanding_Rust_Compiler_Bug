{"sha": "2b178a5f0d165007ff622b9b1bd76bebbca50a5b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmIxNzhhNWYwZDE2NTAwN2ZmNjIyYjliMWJkNzZiZWJiY2E1MGE1Yg==", "commit": {"author": {"name": "Li Feng", "email": "nemokingdom@gmail.com", "date": "2009-11-25T05:19:32Z"}, "committer": {"name": "Sebastian Pop", "email": "spop@gcc.gnu.org", "date": "2009-11-25T05:19:32Z"}, "message": "graphite-sese-to-poly.c (free_data_refs_aux): Update to free the new structure.\n\n2009-10-20  Li Feng  <nemokingdom@gmail.com>\n\n\t* graphite-sese-to-poly.c (free_data_refs_aux): Update to free\n\tthe new structure.\n\t(pdr_add_alias_set): Update retrieving alias_set_num.\n\t(build_poly_dr): Update retrieving dr_base_object_set.\n\t(partition_drs_to_sets): Remove.\n\t(build_alias_set_optimal_p): New.\n\t(build_alias_set_for_drs): Rename.\n\t(build_scop_drs): Update.\n\t* graphite-sese-to-poly.h (struct base_alias_pair): New.\n\t(ALIAS_SET_INDEX): Remove.\n\t(BASE_OBJECT_SET_INDEX): Remove.\n\nFrom-SVN: r154614", "tree": {"sha": "bb4cdaef9f176870449a2ee4eb8295c1323c68a8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bb4cdaef9f176870449a2ee4eb8295c1323c68a8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2b178a5f0d165007ff622b9b1bd76bebbca50a5b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b178a5f0d165007ff622b9b1bd76bebbca50a5b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2b178a5f0d165007ff622b9b1bd76bebbca50a5b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b178a5f0d165007ff622b9b1bd76bebbca50a5b/comments", "author": {"login": "LiFeng", "id": 117740, "node_id": "MDQ6VXNlcjExNzc0MA==", "avatar_url": "https://avatars.githubusercontent.com/u/117740?v=4", "gravatar_id": "", "url": "https://api.github.com/users/LiFeng", "html_url": "https://github.com/LiFeng", "followers_url": "https://api.github.com/users/LiFeng/followers", "following_url": "https://api.github.com/users/LiFeng/following{/other_user}", "gists_url": "https://api.github.com/users/LiFeng/gists{/gist_id}", "starred_url": "https://api.github.com/users/LiFeng/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/LiFeng/subscriptions", "organizations_url": "https://api.github.com/users/LiFeng/orgs", "repos_url": "https://api.github.com/users/LiFeng/repos", "events_url": "https://api.github.com/users/LiFeng/events{/privacy}", "received_events_url": "https://api.github.com/users/LiFeng/received_events", "type": "User", "site_admin": false}, "committer": {"login": "sebpop", "id": 568397, "node_id": "MDQ6VXNlcjU2ODM5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/568397?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sebpop", "html_url": "https://github.com/sebpop", "followers_url": "https://api.github.com/users/sebpop/followers", "following_url": "https://api.github.com/users/sebpop/following{/other_user}", "gists_url": "https://api.github.com/users/sebpop/gists{/gist_id}", "starred_url": "https://api.github.com/users/sebpop/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sebpop/subscriptions", "organizations_url": "https://api.github.com/users/sebpop/orgs", "repos_url": "https://api.github.com/users/sebpop/repos", "events_url": "https://api.github.com/users/sebpop/events{/privacy}", "received_events_url": "https://api.github.com/users/sebpop/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e8af484268dee77eba449dc151dc7dad718376d8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e8af484268dee77eba449dc151dc7dad718376d8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e8af484268dee77eba449dc151dc7dad718376d8"}], "stats": {"total": 135, "additions": 94, "deletions": 41}, "files": [{"sha": "e61abc5e2ef612a87652870074db95709c4e8067", "filename": "gcc/ChangeLog.graphite", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b178a5f0d165007ff622b9b1bd76bebbca50a5b/gcc%2FChangeLog.graphite", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b178a5f0d165007ff622b9b1bd76bebbca50a5b/gcc%2FChangeLog.graphite", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog.graphite?ref=2b178a5f0d165007ff622b9b1bd76bebbca50a5b", "patch": "@@ -1,3 +1,17 @@\n+2009-10-20  Li Feng  <nemokingdom@gmail.com>\n+\n+\t* graphite-sese-to-poly.c (free_data_refs_aux): Update to free\n+\tthe new structure.\n+\t(pdr_add_alias_set): Update retrieving alias_set_num.\n+\t(build_poly_dr): Update retrieving dr_base_object_set.\n+\t(partition_drs_to_sets): Remove.\n+\t(build_alias_set_optimal_p): New.\n+\t(build_alias_set_for_drs): Rename.\n+\t(build_scop_drs): Update.\n+\t* graphite-sese-to-poly.h (struct base_alias_pair): New.\n+\t(ALIAS_SET_INDEX): Remove.\n+\t(BASE_OBJECT_SET_INDEX): Remove.\n+\n 2009-10-20  Sebastian Pop  <sebastian.pop@amd.com>\n \n \t* sese.c (get_vdef_before_sese): Handle GIMPLE_ASSIGN and GIMPLE_CALL."}, {"sha": "b0f385b0a20454f0be3c59c3a066fdd90f4fb5cc", "filename": "gcc/graphite-sese-to-poly.c", "status": "modified", "additions": 74, "deletions": 39, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b178a5f0d165007ff622b9b1bd76bebbca50a5b/gcc%2Fgraphite-sese-to-poly.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b178a5f0d165007ff622b9b1bd76bebbca50a5b/gcc%2Fgraphite-sese-to-poly.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-sese-to-poly.c?ref=2b178a5f0d165007ff622b9b1bd76bebbca50a5b", "patch": "@@ -290,15 +290,16 @@ free_data_refs_aux (VEC (data_reference_p, heap) *datarefs)\n {\n   unsigned int i;\n   struct data_reference *dr;\n-\n-  for (i = 0; VEC_iterate (data_reference_p, datarefs, i, dr); i++)\n-    if (!dr->aux)\n+   for (i = 0; VEC_iterate (data_reference_p, datarefs, i, dr); i++)\n+    if (dr->aux != NULL)\n       {\n-\tfree (dr->aux);\n+\tbase_alias_pair *bap = (base_alias_pair *)(dr->aux);\n+\tif (bap->alias_set != NULL)\n+\t  free (bap->alias_set);\n+\tfree (bap);\n \tdr->aux = NULL;\n       }\n }\n-\n /* Frees GBB.  */\n \n static void\n@@ -1628,9 +1629,10 @@ pdr_add_alias_set (ppl_Polyhedron_t accesses, data_reference_p dr,\n   ppl_Linear_Expression_t alias;\n   ppl_Constraint_t cstr;\n   int alias_set_num = 0;\n+  base_alias_pair *bap = (base_alias_pair *)(dr->aux);\n \n-  if (dr->aux != NULL)\n-    alias_set_num = ((int *)(dr->aux))[ALIAS_SET_INDEX];\n+  if (bap != NULL && bap->alias_set != NULL)\n+    alias_set_num = *(bap->alias_set);\n \n   ppl_new_Linear_Expression_with_dimension (&alias, accessp_nb_dims);\n \n@@ -1773,7 +1775,8 @@ build_poly_dr (data_reference_p dr, poly_bb_p pbb)\n \t\t\t\t\t\t\t    accesses);\n   ppl_delete_Polyhedron (accesses);\n \n-  dr_base_object_set = ((int *)(dr->aux))[BASE_OBJECT_SET_INDEX];\n+  if (dr->aux != NULL)\n+    dr_base_object_set = ((base_alias_pair *)(dr->aux))->base_obj_set;\n \n   new_poly_dr (pbb, dr_base_object_set, accesses_ps, DR_IS_READ (dr) ? PDR_READ : PDR_WRITE,\n \t       dr, DR_NUM_DIMENSIONS (dr));\n@@ -1869,17 +1872,22 @@ write_alias_graph_to_ascii_ecc (FILE *file, char *comment,\n   return true;\n }\n \n+/* Check if DR1 and DR2 are in the same object set.  */\n+\n+static bool\n+dr_same_base_object_p (const struct data_reference *dr1,\n+\t\t       const struct data_reference *dr2)\n+{\n+  return operand_equal_p (DR_BASE_OBJECT (dr1), DR_BASE_OBJECT (dr2), 0);\n+}\n \n /* Uses DFS component number as representative of alias-sets. Also tests for\n    optimality by verifying if every connected component is a clique. Returns\n    true (1) if the above test is true, and false (0) otherwise.  */\n \n static int\n-partition_drs_to_sets (VEC (data_reference_p, heap) *drs, int choice,\n-\t\t       bool (* edge_exist_p) (const struct data_reference *,\n-\t\t\t\t\t      const struct data_reference *))\n+build_alias_set_optimal_p (VEC (data_reference_p, heap) *drs)\n {\n-\n   int num_vertices = VEC_length (data_reference_p, drs);\n   struct graph *g = new_graph (num_vertices);\n   data_reference_p dr1, dr2;\n@@ -1893,7 +1901,7 @@ partition_drs_to_sets (VEC (data_reference_p, heap) *drs, int choice,\n \n   for (i = 0; VEC_iterate (data_reference_p, drs, i, dr1); i++)\n     for (j = i+1; VEC_iterate (data_reference_p, drs, j, dr2); j++)\n-      if (edge_exist_p (dr1, dr2))\n+      if (dr_may_alias_p (dr1, dr2))\n \t{\n \t  add_edge (g, i, j);\n \t  add_edge (g, j, i);\n@@ -1904,7 +1912,18 @@ partition_drs_to_sets (VEC (data_reference_p, heap) *drs, int choice,\n   for (i = 0; i < num_vertices; i++)\n     all_vertices[i] = i;\n \n-  num_connected_components = graphds_dfs (g, all_vertices, num_vertices, NULL, true, NULL);\n+  num_connected_components = graphds_dfs (g, all_vertices, num_vertices,\n+\t\t\t\t\t  NULL, true, NULL);\n+  for (i = 0; i < g->n_vertices; i++)\n+    {\n+      data_reference_p dr = VEC_index (data_reference_p, drs, i);\n+      base_alias_pair *bap;\n+      if (dr->aux != NULL)\n+\tbap = (base_alias_pair *)(dr->aux);\n+      bap->alias_set = XNEW (int);\n+      *(bap->alias_set) = g->vertices[i].component + 1;\n+    }\n+\n \n   /* Verify if the DFS numbering results in optimal solution.  */\n   for (i = 0; i < num_connected_components; i++)\n@@ -1942,41 +1961,49 @@ partition_drs_to_sets (VEC (data_reference_p, heap) *drs, int choice,\n \t}\n     }\n \n-  for (i = 0; i < g->n_vertices; i++)\n-    {\n-      data_reference_p dr = VEC_index (data_reference_p, drs, i);\n-      if (!dr->aux)\n-\tdr->aux = XNEWVEC (int, 2);\n-      ((int *)(dr->aux))[choice] = g->vertices[i].component + 1;\n-    }\n-\n   free (all_vertices);\n   free (vertices);\n   free_graph (g);\n   return all_components_are_cliques;\n }\n \n-static bool\n-dr_same_base_object_p (const struct data_reference *dr1,\n-\t\t       const struct data_reference *dr2)\n-{\n-  return operand_equal_p (DR_BASE_OBJECT (dr1), DR_BASE_OBJECT (dr2), 0);\n-}\n-\n-/* Group each data reference in DRS with it's alias set num.  */\n-\n-static void\n-build_alias_set_for_drs (VEC (data_reference_p, heap) *drs)\n-{\n-  partition_drs_to_sets (drs, ALIAS_SET_INDEX, dr_may_alias_p);\n-}\n-\n /* Group each data reference in DRS with it's base object set num.  */\n \n static void\n build_base_obj_set_for_drs (VEC (data_reference_p, heap) *drs)\n {\n-  partition_drs_to_sets (drs, BASE_OBJECT_SET_INDEX, dr_same_base_object_p);\n+  int num_vertex = VEC_length (data_reference_p, drs);\n+  struct graph *g = new_graph (num_vertex);\n+  data_reference_p dr1, dr2;\n+  int i, j;\n+  int num_component;\n+  int *queue;\n+\n+  for (i = 0; VEC_iterate (data_reference_p, drs, i, dr1); i++)\n+    for (j = i + 1; VEC_iterate (data_reference_p, drs, j, dr2); j++)\n+      if (dr_same_base_object_p (dr1, dr2))\n+\t{\n+\t  add_edge (g, i, j);\n+\t  add_edge (g, j, i);\n+\t}\n+\n+  queue = XNEWVEC (int, num_vertex);\n+  for (i = 0; i < num_vertex; i++)\n+    queue[i] = i;\n+\n+  num_component = graphds_dfs (g, queue, num_vertex, NULL, true, NULL);\n+\n+  for (i = 0; i < g->n_vertices; i++)\n+    {\n+      data_reference_p dr = VEC_index (data_reference_p, drs, i);\n+      base_alias_pair *bap;\n+      if (dr->aux != NULL)\n+\tbap = (base_alias_pair *)(dr->aux);\n+      bap->base_obj_set = g->vertices[i].component + 1;\n+    }\n+\n+  free (queue);\n+  free_graph (g);\n }\n \n /* Build the data references for PBB.  */\n@@ -2007,7 +2034,15 @@ build_scop_drs (scop_p scop)\n \t\t\t     GBB_DATA_REFS (PBB_BLACK_BOX (pbb)), j, dr); j++)\n       VEC_safe_push (data_reference_p, heap, drs, dr);\n \n-  build_alias_set_for_drs (drs);\n+  for (i = 0; VEC_iterate (data_reference_p, drs, i, dr); i++)\n+    dr->aux = XNEW (base_alias_pair);\n+\n+  if (!build_alias_set_optimal_p (drs))\n+    {\n+      /* TODO: Add support when building alias set is not optimal.  */\n+      ;\n+    }\n+\n   build_base_obj_set_for_drs (drs);\n \n   /* When debugging, enable the following code.  This cannot be used"}, {"sha": "0737c49bd944e8eea5eb7c0819e1f561cc3cdfe8", "filename": "gcc/graphite-sese-to-poly.h", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b178a5f0d165007ff622b9b1bd76bebbca50a5b/gcc%2Fgraphite-sese-to-poly.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b178a5f0d165007ff622b9b1bd76bebbca50a5b/gcc%2Fgraphite-sese-to-poly.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-sese-to-poly.h?ref=2b178a5f0d165007ff622b9b1bd76bebbca50a5b", "patch": "@@ -21,8 +21,12 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef GCC_GRAPHITE_SESE_TO_POLY_H\n #define GCC_GRAPHITE_SESE_TO_POLY_H\n \n-#define ALIAS_SET_INDEX 0\n-#define BASE_OBJECT_SET_INDEX 1\n+typedef struct base_alias_pair base_alias_pair;\n+struct base_alias_pair\n+{\n+  int base_obj_set;\n+  int *alias_set;\n+};\n \n bool build_poly_scop (scop_p);\n void check_poly_representation (scop_p);"}]}