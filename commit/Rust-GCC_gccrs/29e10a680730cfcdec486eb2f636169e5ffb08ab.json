{"sha": "29e10a680730cfcdec486eb2f636169e5ffb08ab", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjllMTBhNjgwNzMwY2ZjZGVjNDg2ZWIyZjYzNjE2OWU1ZmZiMDhhYg==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2018-02-13T14:22:07Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2018-02-13T14:22:07Z"}, "message": "Fix more variadic capture issues.\n\n\t* pt.c (find_parameter_packs_r): Also look at explicit captures.\n\t(check_for_bare_parameter_packs): Check current_class_type for\n\tlambda context.\n\t(extract_locals_r): Handle seeing a full instantiation of a pack.\n\t(tsubst_pack_expansion): Likewise.  Force lambda capture.\n\t* parser.c (cp_parser_lambda_introducer): Don't\n\tcheck_for_bare_parameter_packs.\n\nFrom-SVN: r257627", "tree": {"sha": "602834c72b6c4146330bf07aa0709513ff34785f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/602834c72b6c4146330bf07aa0709513ff34785f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/29e10a680730cfcdec486eb2f636169e5ffb08ab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29e10a680730cfcdec486eb2f636169e5ffb08ab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/29e10a680730cfcdec486eb2f636169e5ffb08ab", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29e10a680730cfcdec486eb2f636169e5ffb08ab/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "812c0795283d5eaebf84922e3d1951fdba1936c5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/812c0795283d5eaebf84922e3d1951fdba1936c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/812c0795283d5eaebf84922e3d1951fdba1936c5"}], "stats": {"total": 107, "additions": 90, "deletions": 17}, "files": [{"sha": "3f37392061670a840d0294beef2a121c91777675", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29e10a680730cfcdec486eb2f636169e5ffb08ab/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29e10a680730cfcdec486eb2f636169e5ffb08ab/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=29e10a680730cfcdec486eb2f636169e5ffb08ab", "patch": "@@ -1,5 +1,14 @@\n 2018-02-13  Jason Merrill  <jason@redhat.com>\n \n+\tFix more variadic capture issues.\n+\t* pt.c (find_parameter_packs_r): Also look at explicit captures.\n+\t(check_for_bare_parameter_packs): Check current_class_type for\n+\tlambda context.\n+\t(extract_locals_r): Handle seeing a full instantiation of a pack.\n+\t(tsubst_pack_expansion): Likewise.  Force lambda capture.\n+\t* parser.c (cp_parser_lambda_introducer): Don't\n+\tcheck_for_bare_parameter_packs.\n+\n \tPR c++/84338 - wrong variadic sizeof.\n \t* pt.c (argument_pack_select_arg): Like the macro, but look through\n \ta pack expansion."}, {"sha": "81c6f0128e63b690fc231fed8a1902afb7dac972", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29e10a680730cfcdec486eb2f636169e5ffb08ab/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29e10a680730cfcdec486eb2f636169e5ffb08ab/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=29e10a680730cfcdec486eb2f636169e5ffb08ab", "patch": "@@ -10412,8 +10412,6 @@ cp_parser_lambda_introducer (cp_parser* parser, tree lambda_expr)\n \t      cp_lexer_consume_token (parser->lexer);\n \t      capture_init_expr = make_pack_expansion (capture_init_expr);\n \t    }\n-\t  else\n-\t    check_for_bare_parameter_packs (capture_init_expr);\n \t}\n \n       if (LAMBDA_EXPR_DEFAULT_CAPTURE_MODE (lambda_expr) != CPLD_NONE"}, {"sha": "02d448e99b67d1a866c064688d8b3485dd6a3aff", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 64, "deletions": 15, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29e10a680730cfcdec486eb2f636169e5ffb08ab/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29e10a680730cfcdec486eb2f636169e5ffb08ab/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=29e10a680730cfcdec486eb2f636169e5ffb08ab", "patch": "@@ -3587,7 +3587,6 @@ find_parameter_packs_r (tree *tp, int *walk_subtrees, void* data)\n         }\n       break;\n \n-      /* Look through a lambda capture proxy to the field pack.  */\n     case VAR_DECL:\n       if (DECL_PACK_P (t))\n         {\n@@ -3707,6 +3706,12 @@ find_parameter_packs_r (tree *tp, int *walk_subtrees, void* data)\n \n     case LAMBDA_EXPR:\n       {\n+\t/* Look at explicit captures.  */\n+\tfor (tree cap = LAMBDA_EXPR_CAPTURE_LIST (t);\n+\t     cap; cap = TREE_CHAIN (cap))\n+\t  cp_walk_tree (&TREE_VALUE (cap), &find_parameter_packs_r, ppd,\n+\t\t\tppd->visited);\n+\t/* Since we defer implicit capture, look in the body as well.  */\n \ttree fn = lambda_function (t);\n \tcp_walk_tree (&DECL_SAVED_TREE (fn), &find_parameter_packs_r, ppd,\n \t\t      ppd->visited);\n@@ -3907,7 +3912,7 @@ check_for_bare_parameter_packs (tree t)\n     return false;\n \n   /* A lambda might use a parameter pack from the containing context.  */\n-  if (current_function_decl && LAMBDA_FUNCTION_P (current_function_decl))\n+  if (current_class_type && LAMBDA_TYPE_P (current_class_type))\n     return false;\n \n   if (TREE_CODE (t) == TYPE_DECL)\n@@ -11410,30 +11415,72 @@ tsubst_binary_right_fold (tree t, tree args, tsubst_flags_t complain,\n /* Walk through the pattern of a pack expansion, adding everything in\n    local_specializations to a list.  */\n \n+struct el_data\n+{\n+  tree extra;\n+  tsubst_flags_t complain;\n+};\n static tree\n-extract_locals_r (tree *tp, int */*walk_subtrees*/, void *data)\n+extract_locals_r (tree *tp, int */*walk_subtrees*/, void *data_)\n {\n-  tree *extra = reinterpret_cast<tree*>(data);\n+  el_data &data = *reinterpret_cast<el_data*>(data_);\n+  tree *extra = &data.extra;\n+  tsubst_flags_t complain = data.complain;\n   if (tree spec = retrieve_local_specialization (*tp))\n     {\n       if (TREE_CODE (spec) == NONTYPE_ARGUMENT_PACK)\n \t{\n-\t  /* Pull out the actual PARM_DECL for the partial instantiation.  */\n+\t  /* Maybe pull out the PARM_DECL for a partial instantiation.  */\n \t  tree args = ARGUMENT_PACK_ARGS (spec);\n-\t  gcc_assert (TREE_VEC_LENGTH (args) == 1);\n-\t  tree arg = TREE_VEC_ELT (args, 0);\n-\t  spec = PACK_EXPANSION_PATTERN (arg);\n+\t  if (TREE_VEC_LENGTH (args) == 1)\n+\t    {\n+\t      tree elt = TREE_VEC_ELT (args, 0);\n+\t      if (PACK_EXPANSION_P (elt))\n+\t\telt = PACK_EXPANSION_PATTERN (elt);\n+\t      if (DECL_PACK_P (elt))\n+\t\tspec = elt;\n+\t    }\n+\t  if (TREE_CODE (spec) == NONTYPE_ARGUMENT_PACK)\n+\t    {\n+\t      /* Handle lambda capture here, since we aren't doing any\n+\t\t substitution now, and so tsubst_copy won't call\n+\t\t process_outer_var_ref.  */\n+\t      tree args = ARGUMENT_PACK_ARGS (spec);\n+\t      int len = TREE_VEC_LENGTH (args);\n+\t      for (int i = 0; i < len; ++i)\n+\t\t{\n+\t\t  tree arg = TREE_VEC_ELT (args, i);\n+\t\t  tree carg = arg;\n+\t\t  if (outer_automatic_var_p (arg))\n+\t\t    carg = process_outer_var_ref (arg, complain);\n+\t\t  if (carg != arg)\n+\t\t    {\n+\t\t      /* Make a new NONTYPE_ARGUMENT_PACK of the capture\n+\t\t\t proxies.  */\n+\t\t      if (i == 0)\n+\t\t\t{\n+\t\t\t  spec = copy_node (spec);\n+\t\t\t  args = copy_node (args);\n+\t\t\t  SET_ARGUMENT_PACK_ARGS (spec, args);\n+\t\t\t  register_local_specialization (spec, *tp);\n+\t\t\t}\n+\t\t      TREE_VEC_ELT (args, i) = carg;\n+\t\t    }\n+\t\t}\n+\t    }\n \t}\n+      if (outer_automatic_var_p (spec))\n+\tspec = process_outer_var_ref (spec, complain);\n       *extra = tree_cons (*tp, spec, *extra);\n     }\n   return NULL_TREE;\n }\n static tree\n-extract_local_specs (tree pattern)\n+extract_local_specs (tree pattern, tsubst_flags_t complain)\n {\n-  tree extra = NULL_TREE;\n-  cp_walk_tree_without_duplicates (&pattern, extract_locals_r, &extra);\n-  return extra;\n+  el_data data = { NULL_TREE, complain };\n+  cp_walk_tree_without_duplicates (&pattern, extract_locals_r, &data);\n+  return data.extra;\n }\n \n /* Substitute ARGS into T, which is an pack expansion\n@@ -11468,8 +11515,10 @@ tsubst_pack_expansion (tree t, tree args, tsubst_flags_t complain,\n \t     extract_local_specs; map from the general template to our local\n \t     context.  */\n \t  tree gen = TREE_PURPOSE (elt);\n-\t  tree partial = TREE_VALUE (elt);\n-\t  tree inst = retrieve_local_specialization (partial);\n+\t  tree inst = TREE_VALUE (elt);\n+\t  if (DECL_PACK_P (inst))\n+\t    inst = retrieve_local_specialization (inst);\n+\t  /* else inst is already a full instantiation of the pack.  */\n \t  register_local_specialization (inst, gen);\n \t}\n       gcc_assert (!TREE_PURPOSE (extra));\n@@ -11651,7 +11700,7 @@ tsubst_pack_expansion (tree t, tree args, tsubst_flags_t complain,\n       t = make_pack_expansion (pattern, complain);\n       tree extra = args;\n       if (local_specializations)\n-\tif (tree locals = extract_local_specs (pattern))\n+\tif (tree locals = extract_local_specs (pattern, complain))\n \t  extra = tree_cons (NULL_TREE, extra, locals);\n       PACK_EXPANSION_EXTRA_ARGS (t) = extra;\n       return t;"}, {"sha": "97f64cd761a7af041d52709ea8c0e4f7f0fb54b3", "filename": "gcc/testsuite/g++.dg/cpp0x/lambda/lambda-variadic5.C", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29e10a680730cfcdec486eb2f636169e5ffb08ab/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-variadic5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29e10a680730cfcdec486eb2f636169e5ffb08ab/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-variadic5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-variadic5.C?ref=29e10a680730cfcdec486eb2f636169e5ffb08ab", "patch": "@@ -11,6 +11,7 @@ template<class... T>\n void print_all(const T&... t)\n {\n   accept_all([&]()->int { print(t); return 0; }...);\n+  accept_all([&t]()->int { print(t); return 0; }...);\n }\n \n int main()"}, {"sha": "811332040fa6675723428eeb4966c8649c939f96", "filename": "gcc/testsuite/g++.dg/cpp1y/lambda-generic-variadic12.C", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29e10a680730cfcdec486eb2f636169e5ffb08ab/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Flambda-generic-variadic12.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29e10a680730cfcdec486eb2f636169e5ffb08ab/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Flambda-generic-variadic12.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Flambda-generic-variadic12.C?ref=29e10a680730cfcdec486eb2f636169e5ffb08ab", "patch": "@@ -0,0 +1,16 @@\n+// { dg-do compile { target c++14 } }\n+\n+template < typename... T > void sink(T ...){}\n+\n+template < typename... T >\n+auto f(T... t){\n+  [=](auto ... j){\n+    sink((t + j)...);\n+  }(t...);\n+}\n+\n+int main(){\n+  f(0);\n+  f();\n+  f(0.1,0.2);\n+}"}]}