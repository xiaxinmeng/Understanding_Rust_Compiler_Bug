{"sha": "7295570dd4a8099c010d511ffb3327fd8b0e36d7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzI5NTU3MGRkNGE4MDk5YzAxMGQ1MTFmZmIzMzI3ZmQ4YjBlMzZkNw==", "commit": {"author": {"name": "Chris Manghane", "email": "cmang@google.com", "date": "2016-08-02T21:43:48Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2016-08-02T21:43:48Z"}, "message": "escape: Add basic debugging.\n\n    \n    Emit basic debug information when compiling with the flag\n    -fgo-debug-escape#.\n    \n    Reviewed-on: https://go-review.googlesource.com/22376\n\n\t2016-08-02  Chris Manghane  <cmang@google.com>\n\n\t* lang.opt: Add -fgo-debug-escape option.\n\t* go-c.h (go_create_gogo): Add debug_escape_level parameter.\n\t* go-lang.c (go_langhook_init): Pass go_debug_escape_level to\n\tgo_create_gogo.\n\nFrom-SVN: r239002", "tree": {"sha": "ac31176b0c6aef7d08708c3dacd42fb6edbc23d4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ac31176b0c6aef7d08708c3dacd42fb6edbc23d4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7295570dd4a8099c010d511ffb3327fd8b0e36d7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7295570dd4a8099c010d511ffb3327fd8b0e36d7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7295570dd4a8099c010d511ffb3327fd8b0e36d7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7295570dd4a8099c010d511ffb3327fd8b0e36d7/comments", "author": null, "committer": null, "parents": [{"sha": "00803109af736deacbec676f03564c7cafce7eea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00803109af736deacbec676f03564c7cafce7eea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/00803109af736deacbec676f03564c7cafce7eea"}], "stats": {"total": 584, "additions": 577, "deletions": 7}, "files": [{"sha": "60d6e14640a15a2506b68a4724bb6bdbaf091d11", "filename": "gcc/go/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7295570dd4a8099c010d511ffb3327fd8b0e36d7/gcc%2Fgo%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7295570dd4a8099c010d511ffb3327fd8b0e36d7/gcc%2Fgo%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2FChangeLog?ref=7295570dd4a8099c010d511ffb3327fd8b0e36d7", "patch": "@@ -1,3 +1,10 @@\n+2016-08-02  Chris Manghane  <cmang@google.com>\n+\n+\t* lang.opt: Add -fgo-debug-escape option.\n+\t* go-c.h (go_create_gogo): Add debug_escape_level parameter.\n+\t* go-lang.c (go_langhook_init): Pass go_debug_escape_level to\n+\tgo_create_gogo.\n+\n 2016-05-06  Chris Manghane  <cmang@google.com>\n \n \t* Make-lang.in (GO_OBJS): Add go/escape.o (based on an entirely"}, {"sha": "690d6db7ab96bf132f6a48fbccfa01b8c3c8dcc5", "filename": "gcc/go/go-c.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7295570dd4a8099c010d511ffb3327fd8b0e36d7/gcc%2Fgo%2Fgo-c.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7295570dd4a8099c010d511ffb3327fd8b0e36d7/gcc%2Fgo%2Fgo-c.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgo-c.h?ref=7295570dd4a8099c010d511ffb3327fd8b0e36d7", "patch": "@@ -34,7 +34,8 @@ extern void go_add_search_path (const char*);\n extern void go_create_gogo (int int_type_size, int pointer_size,\n \t\t\t    const char* pkgpath, const char *prefix,\n \t\t\t    const char *relative_import_path,\n-\t\t\t    bool check_divide_zero, bool check_divide_overflow);\n+\t\t\t    bool check_divide_zero, bool check_divide_overflow,\n+\t\t\t    int debug_escape_level);\n \n extern void go_parse_input_files (const char**, unsigned int,\n \t\t\t\t  bool only_check_syntax,"}, {"sha": "570f5e06e8d8ddeed113af026750269f185f1819", "filename": "gcc/go/go-lang.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7295570dd4a8099c010d511ffb3327fd8b0e36d7/gcc%2Fgo%2Fgo-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7295570dd4a8099c010d511ffb3327fd8b0e36d7/gcc%2Fgo%2Fgo-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgo-lang.c?ref=7295570dd4a8099c010d511ffb3327fd8b0e36d7", "patch": "@@ -101,7 +101,7 @@ go_langhook_init (void)\n      go_type_for_size).  */\n   go_create_gogo (INT_TYPE_SIZE, POINTER_SIZE, go_pkgpath, go_prefix,\n \t\t  go_relative_import_path, go_check_divide_zero,\n-\t\t  go_check_divide_overflow);\n+\t\t  go_check_divide_overflow, go_debug_escape_level);\n \n   build_common_builtin_nodes ();\n "}, {"sha": "7e1cc13ef9350f6449858b5652f767c5a82639ed", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7295570dd4a8099c010d511ffb3327fd8b0e36d7/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7295570dd4a8099c010d511ffb3327fd8b0e36d7/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=7295570dd4a8099c010d511ffb3327fd8b0e36d7", "patch": "@@ -1,4 +1,4 @@\n-d4b47fef149fc905ae6b418934f6be8cf6be433e\n+89a0b3a04f80df388242166b8835f12e82ceb194\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "6814c7ea74d57cf34819c297077b9d0145aa4dcf", "filename": "gcc/go/gofrontend/escape.cc", "status": "modified", "additions": 516, "deletions": 1, "changes": 517, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7295570dd4a8099c010d511ffb3327fd8b0e36d7/gcc%2Fgo%2Fgofrontend%2Fescape.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7295570dd4a8099c010d511ffb3327fd8b0e36d7/gcc%2Fgo%2Fgofrontend%2Fescape.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fescape.cc?ref=7295570dd4a8099c010d511ffb3327fd8b0e36d7", "patch": "@@ -6,12 +6,14 @@\n \n #include <limits>\n #include <stack>\n+#include <sstream>\n \n #include \"gogo.h\"\n #include \"types.h\"\n #include \"expressions.h\"\n #include \"statements.h\"\n #include \"escape.h\"\n+#include \"ast-dump.h\"\n \n // class Node.\n \n@@ -47,6 +49,305 @@ Node::location() const\n     return Linemap::unknown_location();\n }\n \n+// To match the cmd/gc debug output, strip away the packed prefixes on functions\n+// and variable/expressions.\n+\n+std::string\n+strip_packed_prefix(Gogo* gogo, const std::string& s)\n+{\n+  std::string packed_prefix = \".\" + gogo->pkgpath() + \".\";\n+  std::string fmt = s;\n+  for (size_t pos = fmt.find(packed_prefix);\n+       pos != std::string::npos;\n+       pos = fmt.find(packed_prefix))\n+    fmt.erase(pos, packed_prefix.length());\n+  return fmt;\n+}\n+\n+// A helper for debugging; return this node's AST formatted string.\n+// This is an implementation of gc's Nconv with obj.FmtShort.\n+\n+std::string\n+Node::ast_format(Gogo* gogo) const\n+{\n+  std::ostringstream ss;\n+  if (this->is_sink())\n+    ss << \".sink\";\n+  else if (this->object() != NULL)\n+    {\n+      Named_object* no = this->object();\n+      if (no->is_function() && no->func_value()->enclosing() != NULL)\n+\treturn \"func literal\";\n+      ss << no->name();\n+    }\n+  else if (this->expr() != NULL)\n+    {\n+      Expression* e = this->expr();\n+      bool is_call = e->call_expression() != NULL;\n+      if (is_call)\n+\te->call_expression()->fn();\n+      Func_expression* fe = e->func_expression();;\n+\n+      bool is_closure = fe != NULL && fe->closure() != NULL;\n+      if (is_closure)\n+\t{\n+\t  if (is_call)\n+\t    return \"(func literal)()\";\n+\t  return \"func literal\";\n+\t}\n+      Ast_dump_context::dump_to_stream(this->expr(), &ss);\n+    }\n+  else\n+    {\n+      Statement* s = this->statement();\n+      Goto_unnamed_statement* unnamed = s->goto_unnamed_statement();\n+      if (unnamed != NULL)\n+\t{\n+\t  Statement* derived = unnamed->unnamed_label()->derived_from();\n+\t  if (derived != NULL)\n+\t    {\n+\t      switch (derived->classification())\n+\t\t{\n+\t\tcase Statement::STATEMENT_FOR:\n+\t\tcase Statement::STATEMENT_FOR_RANGE:\n+\t\t  return \"for loop\";\n+\t\t  break;\n+\n+\t\tcase Statement::STATEMENT_SWITCH:\n+\t\t  return \"switch\";\n+\t\t  break;\n+\n+\t\tcase Statement::STATEMENT_TYPE_SWITCH:\n+\t\t  return \"type switch\";\n+\t\t  break;\n+\n+\t\tdefault:\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n+      Ast_dump_context::dump_to_stream(s, &ss);\n+    }\n+\n+  return strip_packed_prefix(gogo, ss.str());\n+}\n+\n+// A helper for debugging; return this node's detailed format string.\n+// This is an implementation of gc's Jconv with obj.FmtShort.\n+\n+std::string\n+Node::details() const\n+{\n+  std::stringstream details;\n+\n+  if (!this->is_sink())\n+    details << \" l(\" << LOCATION_LINE(this->location().gcc_location()) << \")\";\n+\n+  bool is_varargs = false;\n+  bool is_address_taken = false;\n+  bool is_in_heap = false;\n+  bool is_assigned = false;\n+  std::string class_name;\n+\n+  Expression* e = this->expr();\n+  Named_object* node_object = NULL;\n+  if (this->object() != NULL)\n+    node_object = this->object();\n+  else if (e != NULL && e->var_expression() != NULL)\n+    node_object = e->var_expression()->named_object();\n+\n+  if (node_object)\n+    {\n+      // TODO(cmang): For named variables and functions, we want to output\n+      // the function depth.\n+      if (node_object->is_variable())\n+\t{\n+\t  Variable* var = node_object->var_value();\n+\t  is_varargs = var->is_varargs_parameter();\n+\t  is_address_taken = (var->is_address_taken()\n+\t\t\t      || var->is_non_escaping_address_taken());\n+\t  is_in_heap = var->is_in_heap();\n+\t  is_assigned = var->init() != NULL;\n+\n+\t  if (var->is_global())\n+\t    class_name = \"PEXTERN\";\n+\t  else if (var->is_parameter())\n+\t    class_name = \"PPARAM\";\n+\t  else if (var->is_closure())\n+\t    class_name = \"PPARAMREF\";\n+\t  else\n+\t    class_name = \"PAUTO\";\n+\t}\n+      else if (node_object->is_result_variable())\n+\tclass_name = \"PPARAMOUT\";\n+      else if (node_object->is_function()\n+\t       || node_object->is_function_declaration())\n+\tclass_name = \"PFUNC\";\n+    }\n+  else if (e != NULL && e->enclosed_var_expression() != NULL)\n+    {\n+      Named_object* enclosed = e->enclosed_var_expression()->variable();\n+      if (enclosed->is_variable())\n+\t{\n+\t  Variable* var = enclosed->var_value();\n+\t  is_address_taken = (var->is_address_taken()\n+\t\t\t      || var->is_non_escaping_address_taken());\n+\t}\n+      else\n+\t{\n+\t  Result_variable* var = enclosed->result_var_value();\n+\t  is_address_taken = (var->is_address_taken()\n+\t\t\t      || var->is_non_escaping_address_taken());\n+\t}\n+      class_name = \"PPARAMREF\";\n+    }\n+\n+  if (!class_name.empty())\n+    {\n+      details << \" class(\" << class_name;\n+      if (is_in_heap)\n+\tdetails << \",heap\";\n+      details << \")\";\n+    }\n+\n+  switch ((this->encoding() & ESCAPE_MASK))\n+    {\n+    case Node::ESCAPE_UNKNOWN:\n+      break;\n+\n+    case Node::ESCAPE_HEAP:\n+      details << \" esc(h)\";\n+      break;\n+\n+    case Node::ESCAPE_SCOPE:\n+      details << \" esc(s)\";\n+      break;\n+\n+    case Node::ESCAPE_NONE:\n+      details << \" esc(no)\";\n+      break;\n+\n+    case Node::ESCAPE_NEVER:\n+      details << \" esc(N)\";\n+      break;\n+\n+    default:\n+      details << \" esc(\" << this->encoding() << \")\";\n+      break;\n+    }\n+\n+  if (this->state_ != NULL && this->state_->loop_depth != 0)\n+    details << \" ld(\" << this->state_->loop_depth << \")\";\n+\n+  if (is_varargs)\n+    details << \" isddd(1)\";\n+  if (is_address_taken)\n+    details << \" addrtaken\";\n+  if (is_assigned)\n+    details << \" assigned\";\n+\n+  return details.str();\n+}\n+\n+std::string\n+Node::op_format() const\n+{\n+  std::stringstream op;\n+  Ast_dump_context adc(&op, false);\n+  if (this->expr() != NULL)\n+    {\n+      Expression* e = this->expr();\n+      switch (e->classification())\n+\t{\n+\tcase Expression::EXPRESSION_UNARY:\n+\t  adc.dump_operator(e->unary_expression()->op());\n+\t  break;\n+\n+\tcase Expression::EXPRESSION_BINARY:\n+\t  adc.dump_operator(e->binary_expression()->op());\n+\t  break;\n+\n+\tcase Expression::EXPRESSION_CALL:\n+\t  op << \"function call\";\n+\t  break;\n+\n+\tcase Expression::EXPRESSION_FUNC_REFERENCE:\n+\t  if (e->func_expression()->is_runtime_function())\n+\t    {\n+\t      switch (e->func_expression()->runtime_code())\n+\t\t{\n+\t\tcase Runtime::PANIC:\n+\t\t  op << \"panic\";\n+\n+\t\tcase Runtime::APPEND:\n+\t\t  op << \"append\";\n+\t\t  break;\n+\n+\t\tcase Runtime::COPY:\n+\t\t  op << \"copy\";\n+\t\t  break;\n+\n+\t\tcase Runtime::MAKECHAN:\n+\t\tcase Runtime::MAKECHANBIG:\n+\t\tcase Runtime::MAKEMAP:\n+\t\tcase Runtime::MAKEMAPBIG:\n+\t\tcase Runtime::MAKESLICE1:\n+\t\tcase Runtime::MAKESLICE2:\n+\t\tcase Runtime::MAKESLICE1BIG:\n+\t\tcase Runtime::MAKESLICE2BIG:\n+\t\t  op << \"make\";\n+\t\t  break;\n+\n+\t\tcase Runtime::DEFER:\n+\t\t  op << \"defer\";\n+\t\t  break;\n+\n+\t\tcase Runtime::RECOVER:\n+\t\t  op << \"recover\";\n+\t\t  break;\n+\n+\t\tcase Runtime::CLOSE:\n+\t\t  op << \"close\";\n+\t\t  break;\n+\n+\t\tdefault:\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t  break;\n+\n+\tcase Expression::EXPRESSION_ALLOCATION:\n+\t  op << \"new\";\n+\t  break;\n+\n+\tcase Expression::EXPRESSION_RECEIVE:\n+\t  op << \"<-\";\n+\t  break;\n+\n+\tdefault:\n+\t  break;\n+\t}\n+    }\n+\n+  if (this->statement() != NULL)\n+    {\n+      switch (this->statement()->classification())\n+\t{\n+\tcase Statement::STATEMENT_DEFER:\n+\t  op << \"defer\";\n+\t  break;\n+\n+\tcase Statement::STATEMENT_RETURN:\n+\t  op << \"return\";\n+\t  break;\n+\n+\tdefault:\n+\t  break;\n+\t}\n+    }\n+  return op.str();\n+}\n+\n // Return this node's state, creating it if has not been initialized.\n \n Node::Escape_state*\n@@ -255,6 +556,41 @@ Escape_context::Escape_context(Gogo* gogo, bool recursive)\n   state->loop_depth = -1;\n }\n \n+std::string\n+debug_function_name(Named_object* fn)\n+{\n+  if (fn == NULL)\n+    return \"<S>\";\n+\n+  if (!fn->is_function()\n+      || fn->func_value()->enclosing() == NULL)\n+    return Gogo::unpack_hidden_name(fn->name());\n+\n+  // Closures are named \".$nested#\" where # starts from 0 to distinguish\n+  // between closures.  The cmd/gc closures are named in the format\n+  // \"enclosing.func#\" where # starts from 1.  If this is a closure, format\n+  // its name to match cmd/gc.\n+  Named_object* enclosing = fn->func_value()->enclosing();\n+\n+  // Extract #.\n+  std::string name = Gogo::unpack_hidden_name(fn->name());\n+  int closure_num = (int)strtol(name.substr(6).c_str(), NULL, 0);\n+  closure_num++;\n+\n+  name = Gogo::unpack_hidden_name(enclosing->name());\n+  char buf[200];\n+  snprintf(buf, sizeof buf, \"%s.func%d\", name.c_str(), closure_num);\n+  return buf;\n+}\n+\n+// Return the name of the current function.\n+\n+std::string\n+Escape_context::current_function_name() const\n+{\n+  return debug_function_name(this->current_function_);\n+}\n+\n // Initialize the dummy return values for this Node N using the results\n // in FNTYPE.\n \n@@ -381,6 +717,21 @@ Gogo::analyze_escape()\n            ++fn)\n         this->tag_function(context, *fn);\n \n+      if (this->debug_escape_level() != 0)\n+\t{\n+\t  std::vector<Node*> noesc = context->non_escaping_nodes();\n+\t  for (std::vector<Node*>::const_iterator n = noesc.begin();\n+\t       n != noesc.end();\n+\t       ++n)\n+\t    {\n+\t      Node::Escape_state* state = (*n)->state(context, NULL);\n+\t      if (((*n)->encoding() & ESCAPE_MASK) == int(Node::ESCAPE_NONE))\n+\t\tinform((*n)->location(), \"%s %s does not escape\",\n+\t\t       strip_packed_prefix(this, debug_function_name(state->fn)).c_str(),\n+\t\t       (*n)->ast_format(this).c_str());\n+\t    }\n+\t  // TODO(cmang): Which objects in context->noesc actually don't escape.\n+\t}\n       delete context;\n     }\n }\n@@ -668,6 +1019,20 @@ Escape_analysis_assign::statement(Block*, size_t*, Statement* s)\n   if (is_for_statement)\n     this->context_->decrease_loop_depth();\n \n+  Gogo* gogo = this->context_->gogo();\n+  int debug_level = gogo->debug_escape_level();\n+  if (debug_level > 1\n+      && s->unnamed_label_statement() == NULL\n+      && s->expression_statement() == NULL\n+      && !s->is_block_statement())\n+    {\n+      Node* n = Node::make_node(s);\n+      std::string fn_name = this->context_->current_function_name();\n+      inform(s->location(), \"[%d] %s esc: %s\",\n+\t     this->context_->loop_depth(), fn_name.c_str(),\n+\t     n->ast_format(gogo).c_str());\n+    }\n+\n   switch (s->classification())\n     {\n     case Statement::STATEMENT_VARIABLE_DECLARATION:\n@@ -689,8 +1054,19 @@ Escape_analysis_assign::statement(Block*, size_t*, Statement* s)\n \n     case Statement::STATEMENT_LABEL:\n       {\n-\tif (s->label_statement()->label()->looping())\n+\tLabel_statement* label_stmt = s->label_statement();\n+\tif (label_stmt->label()->looping())\n \t  this->context_->increase_loop_depth();\n+\n+\tif (debug_level > 1)\n+\t  {\n+\t    std::string label_type = (label_stmt->label()->looping()\n+\t\t\t\t      ? \"looping\"\n+\t\t\t\t      : \"nonlooping\");\n+\t    inform(s->location(), \"%s %s label\",\n+\t\t   label_stmt->label()->name().c_str(),\n+\t\t   label_type.c_str());\n+\t  }\n       }\n       break;\n \n@@ -767,11 +1143,16 @@ Escape_analysis_assign::statement(Block*, size_t*, Statement* s)\n int\n Escape_analysis_assign::expression(Expression** pexpr)\n {\n+  Gogo* gogo = this->context_->gogo();\n+  int debug_level = gogo->debug_escape_level();\n+\n   // Big stuff escapes unconditionally.\n   Node* n = Node::make_node(*pexpr);\n   if ((n->encoding() & ESCAPE_MASK) != int(Node::ESCAPE_HEAP)\n       && n->is_big(this->context_))\n     {\n+      if (debug_level > 1)\n+\tinform((*pexpr)->location(), \"too large for stack\");\n       n->set_encoding(Node::ESCAPE_HEAP);\n       (*pexpr)->address_taken(true);\n       this->assign(this->context_->sink(), n);\n@@ -780,6 +1161,15 @@ Escape_analysis_assign::expression(Expression** pexpr)\n   if ((*pexpr)->func_expression() == NULL)\n     (*pexpr)->traverse_subexpressions(this);\n \n+  if (debug_level > 1)\n+    {\n+      Node* n = Node::make_node(*pexpr);\n+      std::string fn_name = this->context_->current_function_name();\n+      inform((*pexpr)->location(), \"[%d] %s esc: %s\",\n+\t     this->context_->loop_depth(), fn_name.c_str(),\n+\t     n->ast_format(gogo).c_str());\n+    }\n+\n   switch ((*pexpr)->classification())\n     {\n     case Expression::EXPRESSION_CALL:\n@@ -808,6 +1198,10 @@ Escape_analysis_assign::expression(Expression** pexpr)\n \t\t  Node* appended = Node::make_node(call->args()->back());\n \t\t  this->assign_deref(this->context_->sink(), appended);\n \n+\t\t  if (debug_level > 2)\n+\t\t    error_at((*pexpr)->location(),\n+\t\t\t     \"special treatment of append(slice1, slice2...)\");\n+\n \t\t  // The content of the original slice leaks as well.\n \t\t  Node* appendee = Node::make_node(call->args()->back());\n \t\t  this->assign_deref(this->context_->sink(), appendee);\n@@ -1060,6 +1454,9 @@ Escape_analysis_assign::expression(Expression** pexpr)\n void\n Escape_analysis_assign::call(Call_expression* call)\n {\n+  Gogo* gogo = this->context_->gogo();\n+  int debug_level = gogo->debug_escape_level();\n+\n   Func_expression* fn = call->fn()->func_expression();\n   Function_type* fntype = call->get_function_type();\n   bool indirect = false;\n@@ -1099,6 +1496,10 @@ Escape_analysis_assign::call(Call_expression* call)\n            p != arg_nodes.end();\n            ++p)\n \t{\n+\t  if (debug_level > 2)\n+\t    inform(call->location(),\n+\t\t   \"esccall:: indirect call <- %s, untracked\",\n+\t\t   (*p)->ast_format(gogo).c_str());\n \t  this->assign(this->context_->sink(), *p);\n \t}\n \n@@ -1111,6 +1512,10 @@ Escape_analysis_assign::call(Call_expression* call)\n       && fn->named_object()->is_function()\n       && !fntype->is_tagged())\n     {\n+      if (debug_level > 2)\n+\tinform(call->location(), \"esccall:: %s in recursive group\",\n+\t       call_node->ast_format(gogo).c_str());\n+\n       Function* f = fn->named_object()->func_value();\n       const Bindings* callee_bindings = f->block()->bindings();\n \n@@ -1176,14 +1581,23 @@ Escape_analysis_assign::call(Call_expression* call)\n \n \t  for (; p != arg_nodes.end(); ++p)\n \t    {\n+\t      if (debug_level > 2)\n+\t\tinform(call->location(), \"esccall:: ... <- %s, untracked\",\n+\t\t       (*p)->ast_format(gogo).c_str());\n \t      this->assign(this->context_->sink(), *p);\n \t    }\n \t}\n \n       return;\n     }\n \n+  if (debug_level > 2)\n+    inform(call->location(), \"esccall:: %s not recursive\",\n+\t   call_node->ast_format(gogo).c_str());\n+\n   Node::Escape_state* call_state = call_node->state(this->context_, NULL);\n+  if (!call_state->retvals.empty())\n+    error(\"esc already decorated call %s\", call_node->ast_format(gogo).c_str());\n   this->context_->init_retvals(call_node, fntype);\n \n   // Receiver.\n@@ -1251,6 +1665,9 @@ Escape_analysis_assign::call(Call_expression* call)\n \n       for (; p != arg_nodes.end(); ++p)\n \t{\n+\t  if (debug_level > 2)\n+\t    inform(call->location(), \"esccall:: ... <- %s, untracked\",\n+\t\t   (*p)->ast_format(gogo).c_str());\n \t  this->assign(this->context_->sink(), *p);\n \t}\n     }\n@@ -1265,6 +1682,17 @@ Escape_analysis_assign::call(Call_expression* call)\n void\n Escape_analysis_assign::assign(Node* dst, Node* src)\n {\n+  Gogo* gogo = this->context_->gogo();\n+  int debug_level = gogo->debug_escape_level();\n+  if (debug_level > 1)\n+    inform(dst->location(), \"[%d] %s escassign: %s(%s)[%s] = %s(%s)[%s]\",\n+\t   this->context_->loop_depth(),\n+\t   strip_packed_prefix(gogo, this->context_->current_function_name()).c_str(),\n+\t   dst->ast_format(gogo).c_str(), dst->details().c_str(),\n+\t   dst->op_format().c_str(),\n+\t   src->ast_format(gogo).c_str(), src->details().c_str(),\n+\t   src->op_format().c_str());\n+\n   if (dst->expr() != NULL)\n     {\n       // Analyze the lhs of the assignment.\n@@ -1684,6 +2112,10 @@ Escape_analysis_assign::assign_from_note(std::string* note,\n         }\n     }\n \n+  if (this->context_->gogo()->debug_escape_level() > 2)\n+    inform(src->location(), \"assignfromtag:: src=  em=%s\",\n+\t   Escape_note::make_tag(enc).c_str());\n+\n   if (enc == Node::ESCAPE_UNKNOWN)\n     {\n       // Lost track of the value.\n@@ -1750,6 +2182,11 @@ Escape_analysis_assign::flows(Node* dst, Node* src)\n       || src_state->flows.find(dst) != src_state->flows.end())\n     return;\n \n+  Gogo* gogo = this->context_->gogo();\n+  if (gogo->debug_escape_level() > 2)\n+    inform(Linemap::unknown_location(), \"flows:: %s <- %s\",\n+\t   dst->ast_format(gogo).c_str(), src->ast_format(gogo).c_str());\n+\n   if (dst_state->flows.empty())\n     this->context_->add_dst(dst);\n \n@@ -1905,6 +2342,22 @@ Escape_analysis_flood::flood(Level level, Node* dst, Node* src,\n   src_state->level = level;\n   int mod_loop_depth = std::max(extra_loop_depth, src_state->loop_depth);\n \n+  Gogo* gogo = this->context_->gogo();\n+  int debug_level = gogo->debug_escape_level();\n+  if (debug_level > 1)\n+    inform(Linemap::unknown_location(),\n+\t   \"escwalk: level:{%d %d} depth:%d \"\n+\t   \"op=%s %s(%s) \"\n+\t   \"scope:%s[%d] \"\n+\t   \"extraloopdepth=%d\",\n+\t   level.value(), level.suffix_value(), this->context_->pdepth(),\n+\t   src->op_format().c_str(),\n+\t   src->ast_format(gogo).c_str(),\n+\t   src->details().c_str(),\n+\t   debug_function_name(src_state->fn).c_str(),\n+\t   src_state->loop_depth,\n+\t   extra_loop_depth);\n+\n   this->context_->increase_pdepth();\n \n   // Input parameter flowing into output parameter?\n@@ -1934,6 +2387,20 @@ Escape_analysis_flood::flood(Level level, Node* dst, Node* src,\n       // 2. return &in\n       // 3. tmp := in; return &tmp\n       // 4. return *in\n+      if (debug_level != 0)\n+\t{\n+\t  if (debug_level == 1)\n+\t    inform(src->location(),\n+\t\t   \"leaking param: %s to result %s level=%d\",\n+\t\t   src->ast_format(gogo).c_str(), dst->ast_format(gogo).c_str(),\n+\t\t   level.value());\n+\t  else\n+\t    inform(src->location(),\n+\t\t   \"leaking param: %s to result %s level={%d %d}\",\n+\t\t   src->ast_format(gogo).c_str(), dst->ast_format(gogo).c_str(),\n+\t\t   level.value(), level.suffix_value());\n+\t}\n+\n       if ((src->encoding() & ESCAPE_MASK) != Node::ESCAPE_RETURN)\n \t{\n \t  int enc =\n@@ -1968,6 +2435,9 @@ Escape_analysis_flood::flood(Level level, Node* dst, Node* src,\n \tNode::max_encoding((src->encoding() | ESCAPE_CONTENT_ESCAPES),\n \t\t\t   Node::ESCAPE_NONE);\n       src->set_encoding(enc);\n+      if (debug_level != 0)\n+\tinform(src->location(), \"mark escaped content: %s\",\n+\t       src->ast_format(gogo).c_str());\n     }\n \n   // A src object leaks if its value or address is assigned to a dst object\n@@ -1987,9 +2457,14 @@ Escape_analysis_flood::flood(Level level, Node* dst, Node* src,\n \t    Node::max_encoding((src->encoding() | ESCAPE_CONTENT_ESCAPES),\n \t\t\t       Node::ESCAPE_NONE);\n \t  src->set_encoding(enc);\n+\t  if (debug_level != 0)\n+\t    inform(src->location(), \"leaking param content: %s\",\n+\t\t   src->ast_format(gogo).c_str());\n \t}\n       else\n \t{\n+\t  if (debug_level != 0)\n+\t    inform(src->location(), \"leaking param\");\n \t  src->set_encoding(Node::ESCAPE_SCOPE);\n \t}\n     }\n@@ -1998,6 +2473,10 @@ Escape_analysis_flood::flood(Level level, Node* dst, Node* src,\n       Expression* e = src->expr();\n       if (e->enclosed_var_expression() != NULL)\n \t{\n+\t  if (src_leaks && debug_level != 0)\n+\t    inform(src->location(), \"leaking closure reference %s\",\n+\t\t   src->ast_format(gogo).c_str());\n+\n \t  Node* enclosed_node =\n \t    Node::make_node(e->enclosed_var_expression()->variable());\n \t  this->flood(level, dst, enclosed_node, -1);\n@@ -2020,6 +2499,23 @@ Escape_analysis_flood::flood(Level level, Node* dst, Node* src,\n \t  if (src_leaks)\n \t    {\n \t      src->set_encoding(Node::ESCAPE_HEAP);\n+\t      if (debug_level != 0)\n+\t\t{\n+\t\t  inform(underlying->location(), \"moved to heap: %s\",\n+\t\t\t underlying_node->ast_format(gogo).c_str());\n+\n+\t\t  if (debug_level > 1)\n+\t\t    inform(src->location(),\n+\t\t\t   \"%s escapes to heap, level={%d %d}, \"\n+\t\t\t   \"dst.eld=%d, src.eld=%d\",\n+\t\t\t   src->ast_format(gogo).c_str(), level.value(),\n+\t\t\t   level.suffix_value(), dst_state->loop_depth,\n+\t\t\t   mod_loop_depth);\n+\t\t  else\n+\t\t    inform(src->location(), \"%s escapes to heap\",\n+\t\t\t   src->ast_format(gogo).c_str());\n+\t\t}\n+\n \t      this->flood(level.decrease(), dst,\n \t\t\t  underlying_node, mod_loop_depth);\n \t      extra_loop_depth = mod_loop_depth;\n@@ -2046,6 +2542,9 @@ Escape_analysis_flood::flood(Level level, Node* dst, Node* src,\n \t  if (src_leaks)\n \t    {\n \t      src->set_encoding(Node::ESCAPE_HEAP);\n+\t      if (debug_level != 0)\n+\t\tinform(src->location(), \"%s escapes to heap\",\n+\t\t       src->ast_format(gogo).c_str());\n \t      extra_loop_depth = mod_loop_depth;\n \t    }\n \t}\n@@ -2089,6 +2588,9 @@ Escape_analysis_flood::flood(Level level, Node* dst, Node* src,\n \t\t      if (src_leaks)\n \t\t\t{\n \t\t\t  src->set_encoding(Node::ESCAPE_HEAP);\n+\t\t\t  if (debug_level != 0)\n+\t\t\t    inform(src->location(), \"%s escapes to heap\",\n+\t\t\t\t   src->ast_format(gogo).c_str());\n \t\t\t  extra_loop_depth = mod_loop_depth;\n \t\t\t}\n \t\t      break;\n@@ -2104,13 +2606,19 @@ Escape_analysis_flood::flood(Level level, Node* dst, Node* src,\n \t\t  // A closure or bound method; we lost track of actual function\n \t\t  // so if this leaks, this call must be done on the heap.\n \t\t  src->set_encoding(Node::ESCAPE_HEAP);\n+\t\t  if (debug_level != 0)\n+\t\t    inform(src->location(), \"%s escapes to heap\",\n+\t\t\t   src->ast_format(gogo).c_str());\n \t\t}\n \t    }\n \t}\n       else if (e->allocation_expression() != NULL && src_leaks)\n \t{\n \t  // Calls to Runtime::NEW get lowered into an allocation expression.\n \t  src->set_encoding(Node::ESCAPE_HEAP);\n+\t  if (debug_level != 0)\n+\t    inform(src->location(), \"%s escapes to heap\",\n+\t\t   src->ast_format(gogo).c_str());\n \t}\n       else if ((e->field_reference_expression() != NULL\n \t\t&& e->field_reference_expression()->expr()->unary_expression() == NULL)\n@@ -2184,6 +2692,13 @@ void\n Gogo::propagate_escape(Escape_context* context, Node* dst)\n {\n   Node::Escape_state* state = dst->state(context, NULL);\n+  Gogo* gogo = context->gogo();\n+  if (gogo->debug_escape_level() > 1)\n+    inform(Linemap::unknown_location(), \"escflood:%d: dst %s scope:%s[%d]\",\n+\t   context->flood_id(), dst->ast_format(gogo).c_str(),\n+\t   debug_function_name(state->fn).c_str(),\n+\t   state->loop_depth);\n+\n   Escape_analysis_flood eaf(context);\n   for (std::set<Node*>::const_iterator p = state->flows.begin();\n        p != state->flows.end();"}, {"sha": "e6d1a3d6e1a1d550d415f034f2fd01e05ff263fe", "filename": "gcc/go/gofrontend/escape.h", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7295570dd4a8099c010d511ffb3327fd8b0e36d7/gcc%2Fgo%2Fgofrontend%2Fescape.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7295570dd4a8099c010d511ffb3327fd8b0e36d7/gcc%2Fgo%2Fgofrontend%2Fescape.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fescape.h?ref=7295570dd4a8099c010d511ffb3327fd8b0e36d7", "patch": "@@ -193,6 +193,17 @@ class Node\n   Location\n   location() const;\n \n+  // Return this node's AST formatted string.\n+  std::string\n+  ast_format(Gogo*) const;\n+\n+  // Return this node's detailed format string.\n+  std::string\n+  details() const;\n+\n+  std::string\n+  op_format() const;\n+\n   // Return this node's escape state.\n   Escape_state*\n   state(Escape_context* context, Named_object* fn);\n@@ -343,6 +354,10 @@ class Escape_context\n   set_current_function(Named_object* fn)\n   { this->current_function_ = fn; }\n \n+  // Return the name of the current function.\n+  std::string\n+  current_function_name() const;\n+\n   // Return true if this is the context for a mutually recursive set of functions.\n   bool\n   recursive() const"}, {"sha": "a0c74228158cde0235a342b119311fdb492e4654", "filename": "gcc/go/gofrontend/go.cc", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7295570dd4a8099c010d511ffb3327fd8b0e36d7/gcc%2Fgo%2Fgofrontend%2Fgo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7295570dd4a8099c010d511ffb3327fd8b0e36d7/gcc%2Fgo%2Fgofrontend%2Fgo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgo.cc?ref=7295570dd4a8099c010d511ffb3327fd8b0e36d7", "patch": "@@ -22,7 +22,8 @@ GO_EXTERN_C\n void\n go_create_gogo(int int_type_size, int pointer_size, const char *pkgpath,\n \t       const char *prefix, const char *relative_import_path,\n-\t       bool check_divide_by_zero, bool check_divide_overflow)\n+\t       bool check_divide_by_zero, bool check_divide_overflow,\n+\t       int debug_escape_level)\n {\n   go_assert(::gogo == NULL);\n   Linemap* linemap = go_get_linemap();\n@@ -39,6 +40,7 @@ go_create_gogo(int int_type_size, int pointer_size, const char *pkgpath,\n     ::gogo->set_check_divide_by_zero(check_divide_by_zero);\n   if (check_divide_overflow)\n     ::gogo->set_check_divide_overflow(check_divide_overflow);\n+  ::gogo->set_debug_escape_level(debug_escape_level);\n }\n \n // Parse the input files."}, {"sha": "07234fbb06c7bd0c99b99d67041bd4fefcf646fa", "filename": "gcc/go/gofrontend/gogo.h", "status": "modified", "additions": 27, "deletions": 1, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7295570dd4a8099c010d511ffb3327fd8b0e36d7/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7295570dd4a8099c010d511ffb3327fd8b0e36d7/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.h?ref=7295570dd4a8099c010d511ffb3327fd8b0e36d7", "patch": "@@ -239,6 +239,16 @@ class Gogo\n   set_check_divide_overflow(bool b)\n   { this->check_divide_overflow_ = b; }\n \n+  // Return the level of escape analysis debug information to emit.\n+  int\n+  debug_escape_level() const\n+  { return this->debug_escape_level_; }\n+\n+  // Set the level of escape analysis debugging from a command line option.\n+  void\n+  set_debug_escape_level(int level)\n+  { this->debug_escape_level_ = level; }\n+\n   // Return the priority to use for the package we are compiling.\n   // This is two more than the largest priority of any package we\n   // import.\n@@ -786,6 +796,9 @@ class Gogo\n   // Whether or not to check for division overflow, from the\n   // -fgo-check-divide-overflow option.\n   bool check_divide_overflow_;\n+  // The level of escape analysis debug information to emit, from the\n+  // -fgo-debug-escape option.\n+  int debug_escape_level_;\n   // A list of types to verify.\n   std::vector<Type*> verify_types_;\n   // A list of interface types defined while parsing.\n@@ -2715,7 +2728,7 @@ class Unnamed_label\n {\n  public:\n   Unnamed_label(Location location)\n-    : location_(location), blabel_(NULL)\n+    : location_(location), derived_from_(NULL), blabel_(NULL)\n   { }\n \n   // Get the location where the label is defined.\n@@ -2728,6 +2741,16 @@ class Unnamed_label\n   set_location(Location location)\n   { this->location_ = location; }\n \n+  // Get the top level statement this unnamed label is derived from.\n+  Statement*\n+  derived_from() const\n+  { return this->derived_from_; }\n+\n+  // Set the top level statement this unnamed label is derived from.\n+  void\n+  set_derived_from(Statement* s)\n+  { this->derived_from_ = s; }\n+\n   // Return a statement which defines this label.\n   Bstatement*\n   get_definition(Translate_context*);\n@@ -2743,6 +2766,9 @@ class Unnamed_label\n \n   // The location where the label is defined.\n   Location location_;\n+  // The top-level statement this unnamed label was derived/lowered from.\n+  // This is NULL is this label is not the top-level of a lowered statement.\n+  Statement* derived_from_;\n   // The backend representation of this label.\n   Blabel* blabel_;\n };"}, {"sha": "9066c016730ab35ed734522fc32521d07674ef5b", "filename": "gcc/go/gofrontend/statements.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7295570dd4a8099c010d511ffb3327fd8b0e36d7/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7295570dd4a8099c010d511ffb3327fd8b0e36d7/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fstatements.cc?ref=7295570dd4a8099c010d511ffb3327fd8b0e36d7", "patch": "@@ -3058,7 +3058,6 @@ Unnamed_label_statement::do_get_backend(Translate_context* context)\n   return this->label_->get_definition(context);\n }\n \n-\n // Dump the AST representation for an unnamed label definition statement.\n \n void\n@@ -5091,6 +5090,7 @@ For_statement::do_lower(Gogo*, Named_object*, Block* enclosing,\n     }\n \n   Unnamed_label* top = new Unnamed_label(this->location());\n+  top->set_derived_from(this);\n   b->add_statement(Statement::make_unnamed_label_statement(top));\n \n   s = Statement::make_block_statement(this->statements_,"}, {"sha": "7de9386f92a5617fa607fd0e27811e52dd1c0ba3", "filename": "gcc/go/lang.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7295570dd4a8099c010d511ffb3327fd8b0e36d7/gcc%2Fgo%2Flang.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7295570dd4a8099c010d511ffb3327fd8b0e36d7/gcc%2Fgo%2Flang.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Flang.opt?ref=7295570dd4a8099c010d511ffb3327fd8b0e36d7", "patch": "@@ -69,6 +69,10 @@ frequire-return-statement\n Go Var(go_require_return_statement) Init(1) Warning\n Functions which return values must end with return statements.\n \n+fgo-debug-escape\n+Go Joined UInteger Var(go_debug_escape_level) Init(0)\n+Emit debugging information related to the escape analysis pass when run with -fgo-optimize-allocs.\n+\n o\n Go Joined Separate\n ; Documented in common.opt"}]}