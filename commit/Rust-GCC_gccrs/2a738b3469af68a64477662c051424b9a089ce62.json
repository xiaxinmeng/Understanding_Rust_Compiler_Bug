{"sha": "2a738b3469af68a64477662c051424b9a089ce62", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmE3MzhiMzQ2OWFmNjhhNjQ0Nzc2NjJjMDUxNDI0YjlhMDg5Y2U2Mg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-10-16T13:08:04Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-10-16T13:08:04Z"}, "message": "[multiple changes]\n\n2015-10-16  Bob Duff  <duff@adacore.com>\n\n\t* a-contai.ads: Add two check names: Container_Checks and\n\tTampering_Check.  Move the tampering check machinery from\n\tAda.Containers.Vectors to Ada.Containers. Later we can share it\n\twith other containers.\n\tDisable the tampering machinery in the presence of\n\tSuppress(Tampering_Check).\n\tSimplify the implementation of tampering checks. E.g. use RAII\n\tto make incrementing/decrementing of the counts more concise.\n\t* a-contai.adb: New package body, implementing the above.\n\t* a-convec.ads, a-convec.adb: Use tampering check machinery\n\tin Ada.Containers.\n\tDisable all checking code when checks are suppressed.\n\tSimplify many of the operations. Implement \"&\" in terms of Append,\n\trather than \"by hand\".\n\tRemove: function \"=\" (L, R : Elements_Array) return Boolean is\n\tabstract; so we can call the predefined \"=\" on Elements_Array.\n\tFor \"=\" on Vectors: Previously, we returned True immediately if\n\tLeft'Address = Right'Address.  That seems like a non-optimization\n\t(\"if X = X\" is unusual), so removed that.  Simplify by using\n\tslice comparison (\"=\" on Element_Array will automatically call\n\t\"=\" on the components, even if user defined).\n\n2015-10-16  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch13.adb (Chek_Record_Representation_Clause): When\n\titerating over components, skip anonymous subtypes created for\n\tconstrained array components.\n\nFrom-SVN: r228896", "tree": {"sha": "1d41250e0f7f27f5af42b4a3299081020a910f31", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1d41250e0f7f27f5af42b4a3299081020a910f31"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2a738b3469af68a64477662c051424b9a089ce62", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a738b3469af68a64477662c051424b9a089ce62", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2a738b3469af68a64477662c051424b9a089ce62", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a738b3469af68a64477662c051424b9a089ce62/comments", "author": null, "committer": null, "parents": [{"sha": "00c93ba2f24b4f23328c7f98c366a5fb2ec65108", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00c93ba2f24b4f23328c7f98c366a5fb2ec65108", "html_url": "https://github.com/Rust-GCC/gccrs/commit/00c93ba2f24b4f23328c7f98c366a5fb2ec65108"}], "stats": {"total": 1623, "additions": 728, "deletions": 895}, "files": [{"sha": "0e63938393517be130394637770faec157e660b5", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a738b3469af68a64477662c051424b9a089ce62/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a738b3469af68a64477662c051424b9a089ce62/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=2a738b3469af68a64477662c051424b9a089ce62", "patch": "@@ -1,3 +1,33 @@\n+2015-10-16  Bob Duff  <duff@adacore.com>\n+\n+\t* a-contai.ads: Add two check names: Container_Checks and\n+\tTampering_Check.  Move the tampering check machinery from\n+\tAda.Containers.Vectors to Ada.Containers. Later we can share it\n+\twith other containers.\n+\tDisable the tampering machinery in the presence of\n+\tSuppress(Tampering_Check).\n+\tSimplify the implementation of tampering checks. E.g. use RAII\n+\tto make incrementing/decrementing of the counts more concise.\n+\t* a-contai.adb: New package body, implementing the above.\n+\t* a-convec.ads, a-convec.adb: Use tampering check machinery\n+\tin Ada.Containers.\n+\tDisable all checking code when checks are suppressed.\n+\tSimplify many of the operations. Implement \"&\" in terms of Append,\n+\trather than \"by hand\".\n+\tRemove: function \"=\" (L, R : Elements_Array) return Boolean is\n+\tabstract; so we can call the predefined \"=\" on Elements_Array.\n+\tFor \"=\" on Vectors: Previously, we returned True immediately if\n+\tLeft'Address = Right'Address.  That seems like a non-optimization\n+\t(\"if X = X\" is unusual), so removed that.  Simplify by using\n+\tslice comparison (\"=\" on Element_Array will automatically call\n+\t\"=\" on the components, even if user defined).\n+\n+2015-10-16  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch13.adb (Chek_Record_Representation_Clause): When\n+\titerating over components, skip anonymous subtypes created for\n+\tconstrained array components.\n+\n 2015-10-16  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* a-tags.ads (Parent_Size): Remove obsolete pragma Export."}, {"sha": "2ed760cb3ba3e51124ed164e9ba6122396940a79", "filename": "gcc/ada/a-contai.adb", "status": "added", "additions": 189, "deletions": 0, "changes": 189, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a738b3469af68a64477662c051424b9a089ce62/gcc%2Fada%2Fa-contai.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a738b3469af68a64477662c051424b9a089ce62/gcc%2Fada%2Fa-contai.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-contai.adb?ref=2a738b3469af68a64477662c051424b9a089ce62", "patch": "@@ -0,0 +1,189 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT LIBRARY COMPONENTS                          --\n+--                                                                          --\n+--                       A D A . C O N T A I N E R S                        --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--            Copyright (C) 2015, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+------------------------------------------------------------------------------\n+\n+package body Ada.Containers is\n+\n+   package body Generic_Implementation is\n+\n+      ------------\n+      -- Adjust --\n+      ------------\n+\n+      procedure Adjust (Control : in out Reference_Control_Type) is\n+         pragma Assert (T_Check); -- not called if check suppressed\n+      begin\n+         if Control.T_Counts /= null then\n+            Lock (Control.T_Counts.all);\n+         end if;\n+      end Adjust;\n+\n+      ----------\n+      -- Busy --\n+      ----------\n+\n+      procedure Busy (T_Counts : in out Tamper_Counts) is\n+      begin\n+         if T_Check then\n+            declare\n+               B : Natural renames T_Counts.Busy;\n+            begin\n+               B := B + 1;\n+            end;\n+         end if;\n+      end Busy;\n+\n+      --------------\n+      -- Finalize --\n+      --------------\n+\n+      procedure Finalize (Control : in out Reference_Control_Type) is\n+         pragma Assert (T_Check); -- not called if check suppressed\n+      begin\n+         if Control.T_Counts /= null then\n+            Unlock (Control.T_Counts.all);\n+            Control.T_Counts := null;\n+         end if;\n+      end Finalize;\n+\n+      --  No need to protect against double Finalize here, because these types\n+      --  are limited.\n+\n+      procedure Finalize (Busy : in out With_Busy) is\n+         pragma Assert (T_Check); -- not called if check suppressed\n+      begin\n+         Unbusy (Busy.T_Counts.all);\n+      end Finalize;\n+\n+      procedure Finalize (Lock : in out With_Lock) is\n+         pragma Assert (T_Check); -- not called if check suppressed\n+      begin\n+         Unlock (Lock.T_Counts.all);\n+      end Finalize;\n+\n+      ----------------\n+      -- Initialize --\n+      ----------------\n+\n+      procedure Initialize (Busy : in out With_Busy) is\n+         pragma Assert (T_Check); -- not called if check suppressed\n+      begin\n+         Generic_Implementation.Busy (Busy.T_Counts.all);\n+      end Initialize;\n+\n+      procedure Initialize (Lock : in out With_Lock) is\n+         pragma Assert (T_Check); -- not called if check suppressed\n+      begin\n+         Generic_Implementation.Lock (Lock.T_Counts.all);\n+      end Initialize;\n+\n+      ----------\n+      -- Lock --\n+      ----------\n+\n+      procedure Lock (T_Counts : in out Tamper_Counts) is\n+      begin\n+         if T_Check then\n+            declare\n+               B : Natural renames T_Counts.Busy;\n+               L : Natural renames T_Counts.Lock;\n+            begin\n+               L := L + 1;\n+               B := B + 1;\n+            end;\n+         end if;\n+      end Lock;\n+\n+      --------------\n+      -- TC_Check --\n+      --------------\n+\n+      procedure TC_Check (T_Counts : Tamper_Counts) is\n+      begin\n+         if T_Check and then T_Counts.Busy > 0 then\n+            raise Program_Error with\n+              \"attempt to tamper with cursors\";\n+         end if;\n+      end TC_Check;\n+\n+      --------------\n+      -- TE_Check --\n+      --------------\n+\n+      procedure TE_Check (T_Counts : Tamper_Counts) is\n+      begin\n+         if T_Check and then T_Counts.Lock > 0 then\n+            raise Program_Error with\n+              \"attempt to tamper with elements\";\n+         end if;\n+      end TE_Check;\n+\n+      ------------\n+      -- Unbusy --\n+      ------------\n+\n+      procedure Unbusy (T_Counts : in out Tamper_Counts) is\n+      begin\n+         if T_Check then\n+            declare\n+               B : Natural renames T_Counts.Busy;\n+            begin\n+               B := B - 1;\n+            end;\n+         end if;\n+      end Unbusy;\n+\n+      ------------\n+      -- Unlock --\n+      ------------\n+\n+      procedure Unlock (T_Counts : in out Tamper_Counts) is\n+      begin\n+         if T_Check then\n+            declare\n+               B : Natural renames T_Counts.Busy;\n+               L : Natural renames T_Counts.Lock;\n+            begin\n+               L := L - 1;\n+               B := B - 1;\n+            end;\n+         end if;\n+      end Unlock;\n+\n+      -----------------\n+      -- Zero_Counts --\n+      -----------------\n+\n+      procedure Zero_Counts (T_Counts : out Tamper_Counts) is\n+      begin\n+         if T_Check then\n+            T_Counts := (others => <>);\n+         end if;\n+      end Zero_Counts;\n+\n+   end Generic_Implementation;\n+\n+end Ada.Containers;"}, {"sha": "26f1f8d5ce9e9234fc70113cbb4f141075d76d40", "filename": "gcc/ada/a-contai.ads", "status": "modified", "additions": 130, "deletions": 0, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a738b3469af68a64477662c051424b9a089ce62/gcc%2Fada%2Fa-contai.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a738b3469af68a64477662c051424b9a089ce62/gcc%2Fada%2Fa-contai.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-contai.ads?ref=2a738b3469af68a64477662c051424b9a089ce62", "patch": "@@ -13,6 +13,17 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n+pragma Check_Name (Container_Checks);\n+pragma Check_Name (Tampering_Check);\n+--  The above checks are not in the Ada RM. They are added in order to allow\n+--  suppression of checks within containers packages. Suppressing\n+--  Tampering_Check suppresses the tampering checks and associated machinery,\n+--  which is very expensive. Suppressing Container_Checks suppresses\n+--  Tampering_Check as well as all the other (not-so-expensive) containers\n+--  checks.\n+\n+private with Ada.Finalization;\n+\n package Ada.Containers is\n    pragma Pure;\n \n@@ -21,4 +32,123 @@ package Ada.Containers is\n \n    Capacity_Error : exception;\n \n+private\n+\n+   type Tamper_Counts is record\n+      Busy : Natural := 0;\n+      Lock : Natural := 0;\n+   end record;\n+\n+   --  Busy is positive when tampering with cursors is prohibited. Busy and\n+   --  Lock are both positive when tampering with elements is prohibited.\n+\n+   type Tamper_Counts_Access is access all Tamper_Counts;\n+   for Tamper_Counts_Access'Storage_Size use 0;\n+\n+   generic\n+   package Generic_Implementation is\n+\n+      --  Generic package used in the implementation of containers.\n+      --  ???Currently used by Vectors; not yet by all other containers.\n+\n+      --  This needs to be generic so that the 'Enabled attribute will return\n+      --  the value that is relevant at the point where a container generic is\n+      --  instantiated. For example:\n+      --\n+      --     pragma Suppress (Container_Checks);\n+      --     package My_Vectors is new Ada.Containers.Vectors (...);\n+      --\n+      --  should suppress all container-related checks within the instance\n+      --  My_Vectors.\n+\n+      --  Shorthands for \"checks enabled\" and \"tampering checks enabled\". Note\n+      --  that suppressing either Container_Checks or Tampering_Check disables\n+      --  tampering checks. Note that this code needs to be in a generic\n+      --  package, because we want to take account of check suppressions at the\n+      --  instance. We use these flags, along with pragma Inline, to ensure\n+      --  that the compiler can optimize away the checks, as well as the\n+      --  tampering check machinery, when checks are suppressed.\n+\n+      Checks : constant Boolean := Container_Checks'Enabled;\n+      T_Check : constant Boolean :=\n+        Container_Checks'Enabled and Tampering_Check'Enabled;\n+\n+      --  Reference_Control_Type is used as a component of reference types, to\n+      --  prohibit tampering with elements so long as references exist.\n+\n+      type Reference_Control_Type is\n+         new Finalization.Controlled with record\n+            T_Counts : Tamper_Counts_Access;\n+         end record\n+           with Disable_Controlled => not T_Check;\n+\n+      overriding procedure Adjust (Control : in out Reference_Control_Type);\n+      pragma Inline (Adjust);\n+\n+      overriding procedure Finalize (Control : in out Reference_Control_Type);\n+      pragma Inline (Finalize);\n+\n+      procedure Zero_Counts (T_Counts : out Tamper_Counts);\n+      pragma Inline (Zero_Counts);\n+      --  Set Busy and Lock to zero\n+\n+      procedure Busy (T_Counts : in out Tamper_Counts);\n+      pragma Inline (Busy);\n+      --  Prohibit tampering with cursors\n+\n+      procedure Unbusy (T_Counts : in out Tamper_Counts);\n+      pragma Inline (Unbusy);\n+      --  Allow tampering with cursors\n+\n+      procedure Lock (T_Counts : in out Tamper_Counts);\n+      pragma Inline (Lock);\n+      --  Prohibit tampering with elements\n+\n+      procedure Unlock (T_Counts : in out Tamper_Counts);\n+      pragma Inline (Unlock);\n+      --  Allow tampering with elements\n+\n+      procedure TC_Check (T_Counts : Tamper_Counts);\n+      pragma Inline (TC_Check);\n+      --  Tampering-with-cursors check\n+\n+      procedure TE_Check (T_Counts : Tamper_Counts);\n+      pragma Inline (TE_Check);\n+      --  Tampering-with-elements check\n+\n+      -----------------\n+      --  RAII Types --\n+      -----------------\n+\n+      --  Initialize of With_Busy increments the Busy count, and Finalize\n+      --  decrements it. Thus, to prohibit tampering with elements within a\n+      --  given scope, declare an object of type With_Busy. The Busy count\n+      --  will be correctly decremented in case of exception or abort.\n+\n+      --  With_Lock is the same as With_Busy, except it increments/decrements\n+      --  BOTH Busy and Lock, thus prohibiting tampering with cursors.\n+\n+      type With_Busy (T_Counts : not null access Tamper_Counts) is\n+        new Finalization.Limited_Controlled with null record\n+          with Disable_Controlled => not T_Check;\n+      overriding procedure Initialize (Busy : in out With_Busy);\n+      overriding procedure Finalize (Busy : in out With_Busy);\n+\n+      type With_Lock (T_Counts : not null access Tamper_Counts) is\n+        new Finalization.Limited_Controlled with null record\n+          with Disable_Controlled => not T_Check;\n+      overriding procedure Initialize (Lock : in out With_Lock);\n+      overriding procedure Finalize (Lock : in out With_Lock);\n+\n+      --  Variables of type With_Busy and With_Lock are declared only for the\n+      --  effects of Initialize and Finalize, so they are not referenced;\n+      --  disable warnings about that. Note that all variables of these types\n+      --  have names starting with \"Busy\" or \"Lock\". These pragmas need to be\n+      --  present wherever these types are used.\n+\n+      pragma Warnings (Off, \"variable \"\"Busy*\"\" is not referenced\");\n+      pragma Warnings (Off, \"variable \"\"Lock*\"\" is not referenced\");\n+\n+   end Generic_Implementation;\n+\n end Ada.Containers;"}, {"sha": "23d8d9766c068b68b9ee5bbf8944cf93cc0f3f9b", "filename": "gcc/ada/a-convec.adb", "status": "modified", "additions": 342, "deletions": 878, "changes": 1220, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a738b3469af68a64477662c051424b9a089ce62/gcc%2Fada%2Fa-convec.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a738b3469af68a64477662c051424b9a089ce62/gcc%2Fada%2Fa-convec.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-convec.adb?ref=2a738b3469af68a64477662c051424b9a089ce62", "patch": "@@ -36,29 +36,13 @@ package body Ada.Containers.Vectors is\n \n    pragma Annotate (CodePeer, Skip_Analysis);\n \n+   pragma Warnings (Off, \"variable \"\"Busy*\"\" is not referenced\");\n+   pragma Warnings (Off, \"variable \"\"Lock*\"\" is not referenced\");\n+   --  See comment in Ada.Containers\n+\n    procedure Free is\n      new Ada.Unchecked_Deallocation (Elements_Type, Elements_Access);\n \n-   type Iterator is new Limited_Controlled and\n-     Vector_Iterator_Interfaces.Reversible_Iterator with\n-   record\n-      Container : Vector_Access;\n-      Index     : Index_Type'Base;\n-   end record;\n-\n-   overriding procedure Finalize (Object : in out Iterator);\n-\n-   overriding function First (Object : Iterator) return Cursor;\n-   overriding function Last  (Object : Iterator) return Cursor;\n-\n-   overriding function Next\n-     (Object   : Iterator;\n-      Position : Cursor) return Cursor;\n-\n-   overriding function Previous\n-     (Object   : Iterator;\n-      Position : Cursor) return Cursor;\n-\n    procedure Append_Slow_Path\n      (Container : in out Vector;\n       New_Item  : Element_Type;\n@@ -70,331 +54,66 @@ package body Ada.Containers.Vectors is\n    -- \"&\" --\n    ---------\n \n-   function \"&\" (Left, Right : Vector) return Vector is\n-      LN   : constant Count_Type := Length (Left);\n-      RN   : constant Count_Type := Length (Right);\n-      N    : Count_Type'Base;  -- length of result\n-      J    : Count_Type'Base;  -- for computing intermediate index values\n-      Last : Index_Type'Base;  -- Last index of result\n+   --  We decide that the capacity of the result of \"&\" is the minimum needed\n+   --  -- the sum of the lengths of the vector parameters. We could decide to\n+   --  make it larger, but we have no basis for knowing how much larger, so we\n+   --  just allocate the minimum amount of storage.\n \n+   function \"&\" (Left, Right : Vector) return Vector is\n    begin\n-      --  We decide that the capacity of the result is the sum of the lengths\n-      --  of the vector parameters. We could decide to make it larger, but we\n-      --  have no basis for knowing how much larger, so we just allocate the\n-      --  minimum amount of storage.\n-\n-      --  Here we handle the easy cases first, when one of the vector\n-      --  parameters is empty. (We say \"easy\" because there's nothing to\n-      --  compute, that can potentially overflow.)\n-\n-      if LN = 0 then\n-         if RN = 0 then\n-            return Empty_Vector;\n-         end if;\n-\n-         declare\n-            RE       : Elements_Array renames\n-                         Right.Elements.EA (Index_Type'First .. Right.Last);\n-            Elements : constant Elements_Access :=\n-                         new Elements_Type'(Right.Last, RE);\n-         begin\n-            return (Controlled with Elements, Right.Last, others => <>);\n-         end;\n-      end if;\n-\n-      if RN = 0 then\n-         declare\n-            LE       : Elements_Array renames\n-                         Left.Elements.EA (Index_Type'First .. Left.Last);\n-            Elements : constant Elements_Access :=\n-                         new Elements_Type'(Left.Last, LE);\n-         begin\n-            return (Controlled with Elements, Left.Last, others => <>);\n-         end;\n-\n-      end if;\n-\n-      --  Neither of the vector parameters is empty, so must compute the length\n-      --  of the result vector and its last index. (This is the harder case,\n-      --  because our computations must avoid overflow.)\n-\n-      --  There are two constraints we need to satisfy. The first constraint is\n-      --  that a container cannot have more than Count_Type'Last elements, so\n-      --  we must check the sum of the combined lengths. Note that we cannot\n-      --  simply add the lengths, because of the possibility of overflow.\n-\n-      if LN > Count_Type'Last - RN then\n-         raise Constraint_Error with \"new length is out of range\";\n-      end if;\n-\n-      --  It is now safe compute the length of the new vector, without fear of\n-      --  overflow.\n-\n-      N := LN + RN;\n-\n-      --  The second constraint is that the new Last index value cannot\n-      --  exceed Index_Type'Last. We use the wider of Index_Type'Base and\n-      --  Count_Type'Base as the type for intermediate values.\n-\n-      if Index_Type'Base'Last >= Count_Type_Last then\n-\n-         --  We perform a two-part test. First we determine whether the\n-         --  computed Last value lies in the base range of the type, and then\n-         --  determine whether it lies in the range of the index (sub)type.\n-\n-         --  Last must satisfy this relation:\n-         --    First + Length - 1 <= Last\n-         --  We regroup terms:\n-         --    First - 1 <= Last - Length\n-         --  Which can rewrite as:\n-         --    No_Index <= Last - Length\n-\n-         if Index_Type'Base'Last - Index_Type'Base (N) < No_Index then\n-            raise Constraint_Error with \"new length is out of range\";\n-         end if;\n-\n-         --  We now know that the computed value of Last is within the base\n-         --  range of the type, so it is safe to compute its value:\n-\n-         Last := No_Index + Index_Type'Base (N);\n-\n-         --  Finally we test whether the value is within the range of the\n-         --  generic actual index subtype:\n-\n-         if Last > Index_Type'Last then\n-            raise Constraint_Error with \"new length is out of range\";\n-         end if;\n-\n-      elsif Index_Type'First <= 0 then\n-\n-         --  Here we can compute Last directly, in the normal way. We know that\n-         --  No_Index is less than 0, so there is no danger of overflow when\n-         --  adding the (positive) value of length.\n-\n-         J := Count_Type'Base (No_Index) + N;  -- Last\n-\n-         if J > Count_Type'Base (Index_Type'Last) then\n-            raise Constraint_Error with \"new length is out of range\";\n-         end if;\n-\n-         --  We know that the computed value (having type Count_Type) of Last\n-         --  is within the range of the generic actual index subtype, so it is\n-         --  safe to convert to Index_Type:\n-\n-         Last := Index_Type'Base (J);\n-\n-      else\n-         --  Here Index_Type'First (and Index_Type'Last) is positive, so we\n-         --  must test the length indirectly (by working backwards from the\n-         --  largest possible value of Last), in order to prevent overflow.\n-\n-         J := Count_Type'Base (Index_Type'Last) - N;  -- No_Index\n-\n-         if J < Count_Type'Base (No_Index) then\n-            raise Constraint_Error with \"new length is out of range\";\n-         end if;\n-\n-         --  We have determined that the result length would not create a Last\n-         --  index value outside of the range of Index_Type, so we can now\n-         --  safely compute its value.\n-\n-         Last := Index_Type'Base (Count_Type'Base (No_Index) + N);\n-      end if;\n-\n-      declare\n-         LE       : Elements_Array renames\n-                      Left.Elements.EA (Index_Type'First .. Left.Last);\n-         RE       : Elements_Array renames\n-                      Right.Elements.EA (Index_Type'First .. Right.Last);\n-         Elements : constant Elements_Access :=\n-                      new Elements_Type'(Last, LE & RE);\n-      begin\n-         return (Controlled with Elements, Last, others => <>);\n-      end;\n+      return Result : Vector do\n+         Reserve_Capacity (Result, Length (Left) + Length (Right));\n+         Append (Result, Left);\n+         Append (Result, Right);\n+      end return;\n    end \"&\";\n \n    function \"&\" (Left  : Vector; Right : Element_Type) return Vector is\n    begin\n-      --  We decide that the capacity of the result is the sum of the lengths\n-      --  of the parameters. We could decide to make it larger, but we have no\n-      --  basis for knowing how much larger, so we just allocate the minimum\n-      --  amount of storage.\n-\n-      --  Handle easy case first, when the vector parameter (Left) is empty\n-\n-      if Left.Is_Empty then\n-         declare\n-            Elements : constant Elements_Access :=\n-              new Elements_Type'\n-                (Last => Index_Type'First,\n-                 EA   => (others => Right));\n-\n-         begin\n-            return (Controlled with Elements, Index_Type'First, others => <>);\n-         end;\n-      end if;\n-\n-      --  The vector parameter is not empty, so we must compute the length of\n-      --  the result vector and its last index, but in such a way that overflow\n-      --  is avoided. We must satisfy two constraints: the new length cannot\n-      --  exceed Count_Type'Last, and the new Last index cannot exceed\n-      --  Index_Type'Last.\n-\n-      if Left.Length = Count_Type'Last then\n-         raise Constraint_Error with \"new length is out of range\";\n-      end if;\n-\n-      if Left.Last >= Index_Type'Last then\n-         raise Constraint_Error with \"new length is out of range\";\n-      end if;\n-\n-      declare\n-         Last     : constant Index_Type := Left.Last + 1;\n-         LE       : Elements_Array renames\n-                      Left.Elements.EA (Index_Type'First .. Left.Last);\n-         Elements : constant Elements_Access :=\n-                      new Elements_Type'(Last => Last, EA => LE & Right);\n-      begin\n-         return (Controlled with Elements, Last, others => <>);\n-      end;\n+      return Result : Vector do\n+         Reserve_Capacity (Result, Length (Left) + 1);\n+         Append (Result, Left);\n+         Append (Result, Right);\n+      end return;\n    end \"&\";\n \n    function \"&\" (Left  : Element_Type; Right : Vector) return Vector is\n    begin\n-      --  We decide that the capacity of the result is the sum of the lengths\n-      --  of the parameters. We could decide to make it larger, but we have no\n-      --  basis for knowing how much larger, so we just allocate the minimum\n-      --  amount of storage.\n-\n-      --  Handle easy case first, when the vector parameter (Right) is empty\n-\n-      if Right.Is_Empty then\n-         declare\n-            Elements : constant Elements_Access :=\n-              new Elements_Type'\n-                (Last => Index_Type'First,\n-                 EA   => (others => Left));\n-         begin\n-            return (Controlled with Elements, Index_Type'First, others => <>);\n-         end;\n-      end if;\n-\n-      --  The vector parameter is not empty, so we must compute the length of\n-      --  the result vector and its last index, but in such a way that overflow\n-      --  is avoided. We must satisfy two constraints: the new length cannot\n-      --  exceed Count_Type'Last, and the new Last index cannot exceed\n-      --  Index_Type'Last.\n-\n-      if Right.Length = Count_Type'Last then\n-         raise Constraint_Error with \"new length is out of range\";\n-      end if;\n-\n-      if Right.Last >= Index_Type'Last then\n-         raise Constraint_Error with \"new length is out of range\";\n-      end if;\n-\n-      declare\n-         Last : constant Index_Type := Right.Last + 1;\n-\n-         RE : Elements_Array renames\n-                Right.Elements.EA (Index_Type'First .. Right.Last);\n-\n-         Elements : constant Elements_Access :=\n-           new Elements_Type'\n-             (Last => Last,\n-              EA   => Left & RE);\n-\n-      begin\n-         return (Controlled with Elements, Last, others => <>);\n-      end;\n+      return Result : Vector do\n+         Reserve_Capacity (Result, 1 + Length (Right));\n+         Append (Result, Left);\n+         Append (Result, Right);\n+      end return;\n    end \"&\";\n \n    function \"&\" (Left, Right : Element_Type) return Vector is\n    begin\n-      --  We decide that the capacity of the result is the sum of the lengths\n-      --  of the parameters. We could decide to make it larger, but we have no\n-      --  basis for knowing how much larger, so we just allocate the minimum\n-      --  amount of storage.\n-\n-      --  We must compute the length of the result vector and its last index,\n-      --  but in such a way that overflow is avoided. We must satisfy two\n-      --  constraints: the new length cannot exceed Count_Type'Last (here, we\n-      --  know that that condition is satisfied), and the new Last index cannot\n-      --  exceed Index_Type'Last.\n-\n-      if Index_Type'First >= Index_Type'Last then\n-         raise Constraint_Error with \"new length is out of range\";\n-      end if;\n-\n-      declare\n-         Last : constant Index_Type := Index_Type'First + 1;\n-\n-         Elements : constant Elements_Access :=\n-           new Elements_Type'\n-             (Last => Last,\n-              EA   => (Left, Right));\n-\n-      begin\n-         return (Controlled with Elements, Last, others => <>);\n-      end;\n+      return Result : Vector do\n+         Reserve_Capacity (Result, 1 + 1);\n+         Append (Result, Left);\n+         Append (Result, Right);\n+      end return;\n    end \"&\";\n \n    ---------\n    -- \"=\" --\n    ---------\n \n    overriding function \"=\" (Left, Right : Vector) return Boolean is\n-      BL : Natural renames Left'Unrestricted_Access.Busy;\n-      LL : Natural renames Left'Unrestricted_Access.Lock;\n-\n-      BR : Natural renames Right'Unrestricted_Access.Busy;\n-      LR : Natural renames Right'Unrestricted_Access.Lock;\n-\n-      Result : Boolean;\n-\n    begin\n-      if Left'Address = Right'Address then\n-         return True;\n-      end if;\n-\n-      if Left.Last /= Right.Last then\n-         return False;\n-      end if;\n-\n       --  Per AI05-0022, the container implementation is required to detect\n       --  element tampering by a generic actual subprogram.\n \n-      BL := BL + 1;\n-      LL := LL + 1;\n-\n-      BR := BR + 1;\n-      LR := LR + 1;\n-\n-      Result := True;\n-      for J in Index_Type range Index_Type'First .. Left.Last loop\n-         if Left.Elements.EA (J) /= Right.Elements.EA (J) then\n-            Result := False;\n-            exit;\n-         end if;\n-      end loop;\n-\n-      BL := BL - 1;\n-      LL := LL - 1;\n-\n-      BR := BR - 1;\n-      LR := LR - 1;\n-\n-      return Result;\n-\n-   exception\n-      when others =>\n-         BL := BL - 1;\n-         LL := LL - 1;\n-\n-         BR := BR - 1;\n-         LR := LR - 1;\n-\n-         raise;\n+      declare\n+         Lock_Left : With_Lock (Left.TC'Unrestricted_Access);\n+         Lock_Right : With_Lock (Right.TC'Unrestricted_Access);\n+         Left_Valid : Elements_Array renames\n+           Left.Elements.EA (Index_Type'First .. Left.Last);\n+         Right_Valid : Elements_Array renames\n+           Right.Elements.EA (Index_Type'First .. Right.Last);\n+      begin\n+         return Left_Valid = Right_Valid;\n+      end;\n    end \"=\";\n \n    ------------\n@@ -415,8 +134,7 @@ package body Ada.Containers.Vectors is\n \n       begin\n          Container.Elements := null;\n-         Container.Busy := 0;\n-         Container.Lock := 0;\n+         Zero_Counts (Container.TC);\n \n          --  Note: it may seem that the following assignment to Container.Last\n          --  is useless, since we assign it to L below. However this code is\n@@ -429,20 +147,6 @@ package body Ada.Containers.Vectors is\n       end;\n    end Adjust;\n \n-   procedure Adjust (Control : in out Reference_Control_Type) is\n-   begin\n-      if Control.Container /= null then\n-         declare\n-            C : Vector renames Control.Container.all;\n-            B : Natural renames C.Busy;\n-            L : Natural renames C.Lock;\n-         begin\n-            B := B + 1;\n-            L := L + 1;\n-         end;\n-      end if;\n-   end Adjust;\n-\n    ------------\n    -- Append --\n    ------------\n@@ -451,7 +155,7 @@ package body Ada.Containers.Vectors is\n    begin\n       if Is_Empty (New_Item) then\n          return;\n-      elsif Container.Last = Index_Type'Last then\n+      elsif Checks and then Container.Last = Index_Type'Last then\n          raise Constraint_Error with \"vector is already at its maximum length\";\n       else\n          Insert (Container, Container.Last + 1, New_Item);\n@@ -472,10 +176,7 @@ package body Ada.Containers.Vectors is\n         and then Container.Elements /= null\n         and then Container.Last /= Container.Elements.Last\n       then\n-         if Container.Busy > 0 then\n-            raise Program_Error with\n-              \"attempt to tamper with cursors (vector is busy)\";\n-         end if;\n+         TC_Check (Container.TC);\n \n          --  Increment Container.Last after assigning the New_Item, so we\n          --  leave the Container unmodified in case Finalize/Adjust raises\n@@ -505,7 +206,7 @@ package body Ada.Containers.Vectors is\n    begin\n       if Count = 0 then\n          return;\n-      elsif Container.Last = Index_Type'Last then\n+      elsif Checks and then Container.Last = Index_Type'Last then\n          raise Constraint_Error with \"vector is already at its maximum length\";\n       else\n          Insert (Container, Container.Last + 1, New_Item, Count);\n@@ -545,12 +246,8 @@ package body Ada.Containers.Vectors is\n \n    procedure Clear (Container : in out Vector) is\n    begin\n-      if Container.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with cursors (vector is busy)\";\n-      else\n-         Container.Last := No_Index;\n-      end if;\n+      TC_Check (Container.TC);\n+      Container.Last := No_Index;\n    end Clear;\n \n    ------------------------\n@@ -562,54 +259,64 @@ package body Ada.Containers.Vectors is\n       Position  : Cursor) return Constant_Reference_Type\n    is\n    begin\n-      if Position.Container = null then\n-         raise Constraint_Error with \"Position cursor has no element\";\n-      end if;\n+      if Checks then\n+         if Position.Container = null then\n+            raise Constraint_Error with \"Position cursor has no element\";\n+         end if;\n \n-      if Position.Container /= Container'Unrestricted_Access then\n-         raise Program_Error with \"Position cursor denotes wrong container\";\n-      end if;\n+         if Position.Container /= Container'Unrestricted_Access then\n+            raise Program_Error with \"Position cursor denotes wrong container\";\n+         end if;\n \n-      if Position.Index > Position.Container.Last then\n-         raise Constraint_Error with \"Position cursor is out of range\";\n+         if Position.Index > Position.Container.Last then\n+            raise Constraint_Error with \"Position cursor is out of range\";\n+         end if;\n       end if;\n \n-      declare\n-         C : Vector renames Position.Container.all;\n-         B : Natural renames C.Busy;\n-         L : Natural renames C.Lock;\n-      begin\n+      if T_Check then\n+         declare\n+            TC : constant Tamper_Counts_Access :=\n+              Container.TC'Unrestricted_Access;\n+         begin\n+            return R : constant Constant_Reference_Type :=\n+              (Element => Container.Elements.EA (Position.Index)'Access,\n+               Control => (Controlled with TC))\n+            do\n+               Lock (TC.all);\n+            end return;\n+         end;\n+      else\n          return R : constant Constant_Reference_Type :=\n            (Element => Container.Elements.EA (Position.Index)'Access,\n-            Control => (Controlled with Container'Unrestricted_Access))\n-         do\n-            B := B + 1;\n-            L := L + 1;\n-         end return;\n-      end;\n+            Control => (Controlled with null));\n+      end if;\n    end Constant_Reference;\n \n    function Constant_Reference\n      (Container : aliased Vector;\n       Index     : Index_Type) return Constant_Reference_Type\n    is\n    begin\n-      if Index > Container.Last then\n+      if Checks and then Index > Container.Last then\n          raise Constraint_Error with \"Index is out of range\";\n-      else\n+      end if;\n+\n+      if T_Check then\n          declare\n-            C : Vector renames Container'Unrestricted_Access.all;\n-            B : Natural renames C.Busy;\n-            L : Natural renames C.Lock;\n+            TC : constant Tamper_Counts_Access :=\n+              Container.TC'Unrestricted_Access;\n          begin\n             return R : constant Constant_Reference_Type :=\n               (Element => Container.Elements.EA (Index)'Access,\n-               Control => (Controlled with Container'Unrestricted_Access))\n+               Control => (Controlled with TC))\n             do\n-               B := B + 1;\n-               L := L + 1;\n+               Lock (TC.all);\n             end return;\n          end;\n+      else\n+         return R : constant Constant_Reference_Type :=\n+           (Element => Container.Elements.EA (Index)'Access,\n+            Control => (Controlled with null));\n       end if;\n    end Constant_Reference;\n \n@@ -642,7 +349,7 @@ package body Ada.Containers.Vectors is\n       elsif Capacity >= Source.Length then\n          C := Capacity;\n \n-      else\n+      elsif Checks then\n          raise Capacity_Error with\n            \"Requested capacity is less than Source length\";\n       end if;\n@@ -685,7 +392,7 @@ package body Ada.Containers.Vectors is\n       --  in the base range that immediately precede and immediately follow the\n       --  values in the Index_Type.)\n \n-      if Index < Index_Type'First then\n+      if Checks and then Index < Index_Type'First then\n          raise Constraint_Error with \"Index is out of range (too small)\";\n       end if;\n \n@@ -697,7 +404,7 @@ package body Ada.Containers.Vectors is\n       --  algorithm, so that case is treated as a proper error.)\n \n       if Index > Old_Last then\n-         if Index > Old_Last + 1 then\n+         if Checks and then Index > Old_Last + 1 then\n             raise Constraint_Error with \"Index is out of range (too large)\";\n          else\n             return;\n@@ -717,10 +424,7 @@ package body Ada.Containers.Vectors is\n       --  the count on exit. Delete checks the count to determine whether it is\n       --  being called while the associated callback procedure is executing.\n \n-      if Container.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with cursors (vector is busy)\";\n-      end if;\n+      TC_Check (Container.TC);\n \n       --  We first calculate what's available for deletion starting at\n       --  Index. Here and elsewhere we use the wider of Index_Type'Base and\n@@ -778,22 +482,21 @@ package body Ada.Containers.Vectors is\n       Position  : in out Cursor;\n       Count     : Count_Type := 1)\n    is\n-      pragma Warnings (Off, Position);\n-\n    begin\n-      if Position.Container = null then\n-         raise Constraint_Error with \"Position cursor has no element\";\n-\n-      elsif Position.Container /= Container'Unrestricted_Access then\n-         raise Program_Error with \"Position cursor denotes wrong container\";\n+      if Checks then\n+         if Position.Container = null then\n+            raise Constraint_Error with \"Position cursor has no element\";\n \n-      elsif Position.Index > Container.Last then\n-         raise Program_Error with \"Position index is out of range\";\n+         elsif Position.Container /= Container'Unrestricted_Access then\n+            raise Program_Error with \"Position cursor denotes wrong container\";\n \n-      else\n-         Delete (Container, Position.Index, Count);\n-         Position := No_Element;\n+         elsif Position.Index > Container.Last then\n+            raise Program_Error with \"Position index is out of range\";\n+         end if;\n       end if;\n+\n+      Delete (Container, Position.Index, Count);\n+      Position := No_Element;\n    end Delete;\n \n    ------------------\n@@ -842,10 +545,7 @@ package body Ada.Containers.Vectors is\n       --  it is being called while the associated callback procedure is\n       --  executing.\n \n-      if Container.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with cursors (vector is busy)\";\n-      end if;\n+      TC_Check (Container.TC);\n \n       --  There is no restriction on how large Count can be when deleting\n       --  items. If it is equal or greater than the current length, then this\n@@ -878,7 +578,7 @@ package body Ada.Containers.Vectors is\n       Index     : Index_Type) return Element_Type\n    is\n    begin\n-      if Index > Container.Last then\n+      if Checks and then Index > Container.Last then\n          raise Constraint_Error with \"Index is out of range\";\n       else\n          return Container.Elements.EA (Index);\n@@ -887,13 +587,15 @@ package body Ada.Containers.Vectors is\n \n    function Element (Position : Cursor) return Element_Type is\n    begin\n-      if Position.Container = null then\n-         raise Constraint_Error with \"Position cursor has no element\";\n-      elsif Position.Index > Position.Container.Last then\n-         raise Constraint_Error with \"Position cursor is out of range\";\n-      else\n-         return Position.Container.Elements.EA (Position.Index);\n+      if Checks then\n+         if Position.Container = null then\n+            raise Constraint_Error with \"Position cursor has no element\";\n+         elsif Position.Index > Position.Container.Last then\n+            raise Constraint_Error with \"Position cursor is out of range\";\n+         end if;\n       end if;\n+\n+      return Position.Container.Elements.EA (Position.Index);\n    end Element;\n \n    --------------\n@@ -909,32 +611,13 @@ package body Ada.Containers.Vectors is\n \n       Free (X);\n \n-      if Container.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with cursors (vector is busy)\";\n-      end if;\n+      TC_Check (Container.TC);\n    end Finalize;\n \n    procedure Finalize (Object : in out Iterator) is\n-      B : Natural renames Object.Container.Busy;\n-   begin\n-      B := B - 1;\n-   end Finalize;\n-\n-   procedure Finalize (Control : in out Reference_Control_Type) is\n+      pragma Assert (T_Check); -- not called if check suppressed\n    begin\n-      if Control.Container /= null then\n-         declare\n-            C : Vector renames Control.Container.all;\n-            B : Natural renames C.Busy;\n-            L : Natural renames C.Lock;\n-         begin\n-            B := B - 1;\n-            L := L - 1;\n-         end;\n-\n-         Control.Container := null;\n-      end if;\n+      Unbusy (Object.Container.TC);\n    end Finalize;\n \n    ----------\n@@ -947,7 +630,7 @@ package body Ada.Containers.Vectors is\n       Position  : Cursor := No_Element) return Cursor\n    is\n    begin\n-      if Position.Container /= null then\n+      if Checks and then Position.Container /= null then\n          if Position.Container /= Container'Unrestricted_Access then\n             raise Program_Error with \"Position cursor denotes wrong container\";\n          end if;\n@@ -961,38 +644,15 @@ package body Ada.Containers.Vectors is\n       --  element tampering by a generic actual subprogram.\n \n       declare\n-         B : Natural renames Container'Unrestricted_Access.Busy;\n-         L : Natural renames Container'Unrestricted_Access.Lock;\n-\n-         Result : Index_Type'Base;\n-\n+         Lock : With_Lock (Container.TC'Unrestricted_Access);\n       begin\n-         B := B + 1;\n-         L := L + 1;\n-\n-         Result := No_Index;\n          for J in Position.Index .. Container.Last loop\n             if Container.Elements.EA (J) = Item then\n-               Result := J;\n-               exit;\n+               return Cursor'(Container'Unrestricted_Access, J);\n             end if;\n          end loop;\n \n-         B := B - 1;\n-         L := L - 1;\n-\n-         if Result = No_Index then\n-            return No_Element;\n-         else\n-            return Cursor'(Container'Unrestricted_Access, Result);\n-         end if;\n-\n-      exception\n-         when others =>\n-            B := B - 1;\n-            L := L - 1;\n-\n-            raise;\n+         return No_Element;\n       end;\n    end Find;\n \n@@ -1005,37 +665,18 @@ package body Ada.Containers.Vectors is\n       Item      : Element_Type;\n       Index     : Index_Type := Index_Type'First) return Extended_Index\n    is\n-      B : Natural renames Container'Unrestricted_Access.Busy;\n-      L : Natural renames Container'Unrestricted_Access.Lock;\n-\n-      Result : Index_Type'Base;\n-\n-   begin\n       --  Per AI05-0022, the container implementation is required to detect\n       --  element tampering by a generic actual subprogram.\n \n-      B := B + 1;\n-      L := L + 1;\n-\n-      Result := No_Index;\n+      Lock : With_Lock (Container.TC'Unrestricted_Access);\n+   begin\n       for Indx in Index .. Container.Last loop\n          if Container.Elements.EA (Indx) = Item then\n-            Result := Indx;\n-            exit;\n+            return Indx;\n          end if;\n       end loop;\n \n-      B := B - 1;\n-      L := L - 1;\n-\n-      return Result;\n-\n-   exception\n-      when others =>\n-         B := B - 1;\n-         L := L - 1;\n-\n-         raise;\n+      return No_Index;\n    end Find_Index;\n \n    -----------\n@@ -1080,7 +721,7 @@ package body Ada.Containers.Vectors is\n \n    function First_Element (Container : Vector) return Element_Type is\n    begin\n-      if Container.Last = No_Index then\n+      if Checks and then Container.Last = No_Index then\n          raise Constraint_Error with \"Container is empty\";\n       else\n          return Container.Elements.EA (Index_Type'First);\n@@ -1117,36 +758,16 @@ package body Ada.Containers.Vectors is\n          --  element tampering by a generic actual subprogram.\n \n          declare\n-            EA : Elements_Array renames Container.Elements.EA;\n-\n-            B : Natural renames Container'Unrestricted_Access.Busy;\n-            L : Natural renames Container'Unrestricted_Access.Lock;\n-\n-            Result : Boolean;\n-\n+            Lock : With_Lock (Container.TC'Unrestricted_Access);\n+            EA   : Elements_Array renames Container.Elements.EA;\n          begin\n-            B := B + 1;\n-            L := L + 1;\n-\n-            Result := True;\n             for J in Index_Type'First .. Container.Last - 1 loop\n                if EA (J + 1) < EA (J) then\n-                  Result := False;\n-                  exit;\n+                  return False;\n                end if;\n             end loop;\n \n-            B := B - 1;\n-            L := L - 1;\n-\n-            return Result;\n-\n-         exception\n-            when others =>\n-               B := B - 1;\n-               L := L - 1;\n-\n-               raise;\n+            return True;\n          end;\n       end Is_Sorted;\n \n@@ -1171,7 +792,7 @@ package body Ada.Containers.Vectors is\n             return;\n          end if;\n \n-         if Target'Address = Source'Address then\n+         if Checks and then Target'Address = Source'Address then\n             raise Program_Error with\n               \"Target and Source denote same non-empty container\";\n          end if;\n@@ -1181,10 +802,7 @@ package body Ada.Containers.Vectors is\n             return;\n          end if;\n \n-         if Source.Busy > 0 then\n-            raise Program_Error with\n-              \"attempt to tamper with cursors (vector is busy)\";\n-         end if;\n+         TC_Check (Source.TC);\n \n          Target.Set_Length (Length (Target) + Length (Source));\n \n@@ -1195,19 +813,9 @@ package body Ada.Containers.Vectors is\n             TA : Elements_Array renames Target.Elements.EA;\n             SA : Elements_Array renames Source.Elements.EA;\n \n-            TB : Natural renames Target.Busy;\n-            TL : Natural renames Target.Lock;\n-\n-            SB : Natural renames Source.Busy;\n-            SL : Natural renames Source.Lock;\n-\n+            Lock_Target : With_Lock (Target.TC'Unchecked_Access);\n+            Lock_Source : With_Lock (Source.TC'Unchecked_Access);\n          begin\n-            TB := TB + 1;\n-            TL := TL + 1;\n-\n-            SB := SB + 1;\n-            SL := SL + 1;\n-\n             J := Target.Last;\n             while Source.Last >= Index_Type'First loop\n                pragma Assert (Source.Last <= Index_Type'First\n@@ -1236,22 +844,6 @@ package body Ada.Containers.Vectors is\n \n                J := J - 1;\n             end loop;\n-\n-            TB := TB - 1;\n-            TL := TL - 1;\n-\n-            SB := SB - 1;\n-            SL := SL - 1;\n-\n-         exception\n-            when others =>\n-               TB := TB - 1;\n-               TL := TL - 1;\n-\n-               SB := SB - 1;\n-               SL := SL - 1;\n-\n-               raise;\n          end;\n       end Merge;\n \n@@ -1283,33 +875,15 @@ package body Ada.Containers.Vectors is\n          --  an artifact of our array-based implementation. Logically Sort\n          --  requires a check for cursor tampering.\n \n-         if Container.Busy > 0 then\n-            raise Program_Error with\n-              \"attempt to tamper with cursors (vector is busy)\";\n-         end if;\n+         TC_Check (Container.TC);\n \n          --  Per AI05-0022, the container implementation is required to detect\n          --  element tampering by a generic actual subprogram.\n \n          declare\n-            B : Natural renames Container.Busy;\n-            L : Natural renames Container.Lock;\n-\n+            Lock : With_Lock (Container.TC'Unchecked_Access);\n          begin\n-            B := B + 1;\n-            L := L + 1;\n-\n             Sort (Container.Elements.EA (Index_Type'First .. Container.Last));\n-\n-            B := B - 1;\n-            L := L - 1;\n-\n-         exception\n-            when others =>\n-               B := B - 1;\n-               L := L - 1;\n-\n-               raise;\n          end;\n       end Sort;\n \n@@ -1358,31 +932,33 @@ package body Ada.Containers.Vectors is\n       Dst          : Elements_Access;  -- new, expanded internal array\n \n    begin\n-      --  As a precondition on the generic actual Index_Type, the base type\n-      --  must include Index_Type'Pred (Index_Type'First); this is the value\n-      --  that Container.Last assumes when the vector is empty. However, we do\n-      --  not allow that as the value for Index when specifying where the new\n-      --  items should be inserted, so we must manually check. (That the user\n-      --  is allowed to specify the value at all here is a consequence of the\n-      --  declaration of the Extended_Index subtype, which includes the values\n-      --  in the base range that immediately precede and immediately follow the\n-      --  values in the Index_Type.)\n+      if Checks then\n+         --  As a precondition on the generic actual Index_Type, the base type\n+         --  must include Index_Type'Pred (Index_Type'First); this is the value\n+         --  that Container.Last assumes when the vector is empty. However, we\n+         --  do not allow that as the value for Index when specifying where the\n+         --  new items should be inserted, so we must manually check. (That the\n+         --  user is allowed to specify the value at all here is a consequence\n+         --  of the declaration of the Extended_Index subtype, which includes\n+         --  the values in the base range that immediately precede and\n+         --  immediately follow the values in the Index_Type.)\n \n-      if Before < Index_Type'First then\n-         raise Constraint_Error with\n-           \"Before index is out of range (too small)\";\n-      end if;\n+         if Before < Index_Type'First then\n+            raise Constraint_Error with\n+              \"Before index is out of range (too small)\";\n+         end if;\n \n-      --  We do allow a value greater than Container.Last to be specified as\n-      --  the Index, but only if it's immediately greater. This allows for the\n-      --  case of appending items to the back end of the vector. (It is assumed\n-      --  that specifying an index value greater than Last + 1 indicates some\n-      --  deeper flaw in the caller's algorithm, so that case is treated as a\n-      --  proper error.)\n+         --  We do allow a value greater than Container.Last to be specified as\n+         --  the Index, but only if it's immediately greater. This allows for\n+         --  the case of appending items to the back end of the vector. (It is\n+         --  assumed that specifying an index value greater than Last + 1\n+         --  indicates some deeper flaw in the caller's algorithm, so that case\n+         --  is treated as a proper error.)\n \n-      if Before > Container.Last + 1 then\n-         raise Constraint_Error with\n-           \"Before index is out of range (too large)\";\n+         if Before > Container.Last + 1 then\n+            raise Constraint_Error with\n+              \"Before index is out of range (too large)\";\n+         end if;\n       end if;\n \n       --  We treat inserting 0 items into the container as a no-op, even when\n@@ -1398,7 +974,7 @@ package body Ada.Containers.Vectors is\n       --  Note: we cannot simply add these values, because of the possibility\n       --  of overflow.\n \n-      if Old_Length > Count_Type'Last - Count then\n+      if Checks and then Old_Length > Count_Type'Last - Count then\n          raise Constraint_Error with \"Count is out of range\";\n       end if;\n \n@@ -1506,7 +1082,7 @@ package body Ada.Containers.Vectors is\n       --  an internal array with a last index value greater than\n       --  Index_Type'Last, with no way to index those elements).\n \n-      if New_Length > Max_Length then\n+      if Checks and then New_Length > Max_Length then\n          raise Constraint_Error with \"Count is out of range\";\n       end if;\n \n@@ -1551,10 +1127,7 @@ package body Ada.Containers.Vectors is\n       --  exit. Insert checks the count to determine whether it is being called\n       --  while the associated callback procedure is executing.\n \n-      if Container.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with cursors (vector is busy)\";\n-      end if;\n+      TC_Check (Container.TC);\n \n       --  An internal array has already been allocated, so we must determine\n       --  whether there is enough unused storage for the new items.\n@@ -1828,7 +1401,7 @@ package body Ada.Containers.Vectors is\n       Index : Index_Type'Base;\n \n    begin\n-      if Before.Container /= null\n+      if Checks and then Before.Container /= null\n         and then Before.Container /= Container'Unrestricted_Access\n       then\n          raise Program_Error with \"Before cursor denotes wrong container\";\n@@ -1839,7 +1412,7 @@ package body Ada.Containers.Vectors is\n       end if;\n \n       if Before.Container = null or else Before.Index > Container.Last then\n-         if Container.Last = Index_Type'Last then\n+         if Checks and then Container.Last = Index_Type'Last then\n             raise Constraint_Error with\n               \"vector is already at its maximum length\";\n          end if;\n@@ -1862,7 +1435,7 @@ package body Ada.Containers.Vectors is\n       Index : Index_Type'Base;\n \n    begin\n-      if Before.Container /= null\n+      if Checks and then Before.Container /= null\n         and then Before.Container /= Container'Unrestricted_Access\n       then\n          raise Program_Error with \"Before cursor denotes wrong container\";\n@@ -1879,7 +1452,7 @@ package body Ada.Containers.Vectors is\n       end if;\n \n       if Before.Container = null or else Before.Index > Container.Last then\n-         if Container.Last = Index_Type'Last then\n+         if Checks and then Container.Last = Index_Type'Last then\n             raise Constraint_Error with\n               \"vector is already at its maximum length\";\n          end if;\n@@ -1904,7 +1477,7 @@ package body Ada.Containers.Vectors is\n       Index : Index_Type'Base;\n \n    begin\n-      if Before.Container /= null\n+      if Checks and then Before.Container /= null\n         and then Before.Container /= Container'Unrestricted_Access\n       then\n          raise Program_Error with \"Before cursor denotes wrong container\";\n@@ -1915,7 +1488,7 @@ package body Ada.Containers.Vectors is\n       end if;\n \n       if Before.Container = null or else Before.Index > Container.Last then\n-         if Container.Last = Index_Type'Last then\n+         if Checks and then Container.Last = Index_Type'Last then\n             raise Constraint_Error with\n               \"vector is already at its maximum length\";\n          else\n@@ -1939,7 +1512,7 @@ package body Ada.Containers.Vectors is\n       Index : Index_Type'Base;\n \n    begin\n-      if Before.Container /= null\n+      if Checks and then Before.Container /= null\n         and then Before.Container /= Container'Unrestricted_Access\n       then\n          raise Program_Error with \"Before cursor denotes wrong container\";\n@@ -1956,7 +1529,7 @@ package body Ada.Containers.Vectors is\n       end if;\n \n       if Before.Container = null or else Before.Index > Container.Last then\n-         if Container.Last = Index_Type'Last then\n+         if Checks and then Container.Last = Index_Type'Last then\n             raise Constraint_Error with\n               \"vector is already at its maximum length\";\n          end if;\n@@ -2019,31 +1592,33 @@ package body Ada.Containers.Vectors is\n       Dst          : Elements_Access;  -- new, expanded internal array\n \n    begin\n-      --  As a precondition on the generic actual Index_Type, the base type\n-      --  must include Index_Type'Pred (Index_Type'First); this is the value\n-      --  that Container.Last assumes when the vector is empty. However, we do\n-      --  not allow that as the value for Index when specifying where the new\n-      --  items should be inserted, so we must manually check. (That the user\n-      --  is allowed to specify the value at all here is a consequence of the\n-      --  declaration of the Extended_Index subtype, which includes the values\n-      --  in the base range that immediately precede and immediately follow the\n-      --  values in the Index_Type.)\n+      if Checks then\n+         --  As a precondition on the generic actual Index_Type, the base type\n+         --  must include Index_Type'Pred (Index_Type'First); this is the value\n+         --  that Container.Last assumes when the vector is empty. However, we\n+         --  do not allow that as the value for Index when specifying where the\n+         --  new items should be inserted, so we must manually check. (That the\n+         --  user is allowed to specify the value at all here is a consequence\n+         --  of the declaration of the Extended_Index subtype, which includes\n+         --  the values in the base range that immediately precede and\n+         --  immediately follow the values in the Index_Type.)\n \n-      if Before < Index_Type'First then\n-         raise Constraint_Error with\n-           \"Before index is out of range (too small)\";\n-      end if;\n+         if Before < Index_Type'First then\n+            raise Constraint_Error with\n+              \"Before index is out of range (too small)\";\n+         end if;\n \n-      --  We do allow a value greater than Container.Last to be specified as\n-      --  the Index, but only if it's immediately greater. This allows for the\n-      --  case of appending items to the back end of the vector. (It is assumed\n-      --  that specifying an index value greater than Last + 1 indicates some\n-      --  deeper flaw in the caller's algorithm, so that case is treated as a\n-      --  proper error.)\n+         --  We do allow a value greater than Container.Last to be specified as\n+         --  the Index, but only if it's immediately greater. This allows for\n+         --  the case of appending items to the back end of the vector. (It is\n+         --  assumed that specifying an index value greater than Last + 1\n+         --  indicates some deeper flaw in the caller's algorithm, so that case\n+         --  is treated as a proper error.)\n \n-      if Before > Container.Last + 1 then\n-         raise Constraint_Error with\n-           \"Before index is out of range (too large)\";\n+         if Before > Container.Last + 1 then\n+            raise Constraint_Error with\n+              \"Before index is out of range (too large)\";\n+         end if;\n       end if;\n \n       --  We treat inserting 0 items into the container as a no-op, even when\n@@ -2059,7 +1634,7 @@ package body Ada.Containers.Vectors is\n       --  Note: we cannot simply add these values, because of the possibility\n       --  of overflow.\n \n-      if Old_Length > Count_Type'Last - Count then\n+      if Checks and then Old_Length > Count_Type'Last - Count then\n          raise Constraint_Error with \"Count is out of range\";\n       end if;\n \n@@ -2167,7 +1742,7 @@ package body Ada.Containers.Vectors is\n       --  an internal array with a last index value greater than\n       --  Index_Type'Last, with no way to index those elements).\n \n-      if New_Length > Max_Length then\n+      if Checks and then New_Length > Max_Length then\n          raise Constraint_Error with \"Count is out of range\";\n       end if;\n \n@@ -2211,10 +1786,7 @@ package body Ada.Containers.Vectors is\n       --  exit. Insert checks the count to determine whether it is being called\n       --  while the associated callback procedure is executing.\n \n-      if Container.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with cursors (vector is busy)\";\n-      end if;\n+      TC_Check (Container.TC);\n \n       --  An internal array has already been allocated, so we must determine\n       --  whether there is enough unused storage for the new items.\n@@ -2360,7 +1932,7 @@ package body Ada.Containers.Vectors is\n       Index : Index_Type'Base;\n \n    begin\n-      if Before.Container /= null\n+      if Checks and then Before.Container /= null\n         and then Before.Container /= Container'Unrestricted_Access\n       then\n          raise Program_Error with \"Before cursor denotes wrong container\";\n@@ -2377,7 +1949,7 @@ package body Ada.Containers.Vectors is\n       end if;\n \n       if Before.Container = null or else Before.Index > Container.Last then\n-         if Container.Last = Index_Type'Last then\n+         if Checks and then Container.Last = Index_Type'Last then\n             raise Constraint_Error with\n               \"vector is already at its maximum length\";\n          else\n@@ -2410,31 +1982,18 @@ package body Ada.Containers.Vectors is\n      (Container : Vector;\n       Process   : not null access procedure (Position : Cursor))\n    is\n-      B : Natural renames Container'Unrestricted_Access.all.Busy;\n-\n+      Busy : With_Busy (Container.TC'Unrestricted_Access);\n    begin\n-      B := B + 1;\n-\n-      begin\n-         for Indx in Index_Type'First .. Container.Last loop\n-            Process (Cursor'(Container'Unrestricted_Access, Indx));\n-         end loop;\n-      exception\n-         when others =>\n-            B := B - 1;\n-            raise;\n-      end;\n-\n-      B := B - 1;\n+      for Indx in Index_Type'First .. Container.Last loop\n+         Process (Cursor'(Container'Unrestricted_Access, Indx));\n+      end loop;\n    end Iterate;\n \n    function Iterate\n      (Container : Vector)\n       return Vector_Iterator_Interfaces.Reversible_Iterator'Class\n    is\n       V : constant Vector_Access := Container'Unrestricted_Access;\n-      B : Natural renames V.Busy;\n-\n    begin\n       --  The value of its Index component influences the behavior of the First\n       --  and Last selector functions of the iterator object. When the Index\n@@ -2451,7 +2010,7 @@ package body Ada.Containers.Vectors is\n                        Container => V,\n                        Index     => No_Index)\n       do\n-         B := B + 1;\n+         Busy (Container.TC'Unrestricted_Access.all);\n       end return;\n    end Iterate;\n \n@@ -2461,8 +2020,6 @@ package body Ada.Containers.Vectors is\n       return Vector_Iterator_Interfaces.Reversible_Iterator'class\n    is\n       V : constant Vector_Access := Container'Unrestricted_Access;\n-      B : Natural renames V.Busy;\n-\n    begin\n       --  It was formerly the case that when Start = No_Element, the partial\n       --  iterator was defined to behave the same as for a complete iterator,\n@@ -2475,19 +2032,21 @@ package body Ada.Containers.Vectors is\n       --  however, that it is not possible to use a partial iterator to specify\n       --  an empty sequence of items.\n \n-      if Start.Container = null then\n-         raise Constraint_Error with\n-           \"Start position for iterator equals No_Element\";\n-      end if;\n+      if Checks then\n+         if Start.Container = null then\n+            raise Constraint_Error with\n+              \"Start position for iterator equals No_Element\";\n+         end if;\n \n-      if Start.Container /= V then\n-         raise Program_Error with\n-           \"Start cursor of Iterate designates wrong vector\";\n-      end if;\n+         if Start.Container /= V then\n+            raise Program_Error with\n+              \"Start cursor of Iterate designates wrong vector\";\n+         end if;\n \n-      if Start.Index > V.Last then\n-         raise Constraint_Error with\n-           \"Start position for iterator equals No_Element\";\n+         if Start.Index > V.Last then\n+            raise Constraint_Error with\n+              \"Start position for iterator equals No_Element\";\n+         end if;\n       end if;\n \n       --  The value of its Index component influences the behavior of the First\n@@ -2504,7 +2063,7 @@ package body Ada.Containers.Vectors is\n                        Container => V,\n                        Index     => Start.Index)\n       do\n-         B := B + 1;\n+         Busy (Container.TC'Unrestricted_Access.all);\n       end return;\n    end Iterate;\n \n@@ -2549,7 +2108,7 @@ package body Ada.Containers.Vectors is\n \n    function Last_Element (Container : Vector) return Element_Type is\n    begin\n-      if Container.Last = No_Index then\n+      if Checks and then Container.Last = No_Index then\n          raise Constraint_Error with \"Container is empty\";\n       else\n          return Container.Elements.EA (Container.Last);\n@@ -2612,15 +2171,8 @@ package body Ada.Containers.Vectors is\n          return;\n       end if;\n \n-      if Target.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with cursors (Target is busy)\";\n-      end if;\n-\n-      if Source.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with cursors (Source is busy)\";\n-      end if;\n+      TC_Check (Target.TC);\n+      TC_Check (Source.TC);\n \n       declare\n          Target_Elements : constant Elements_Access := Target.Elements;\n@@ -2652,7 +2204,7 @@ package body Ada.Containers.Vectors is\n    begin\n       if Position.Container = null then\n          return No_Element;\n-      elsif Position.Container /= Object.Container then\n+      elsif Checks and then Position.Container /= Object.Container then\n          raise Program_Error with\n            \"Position cursor of Next designates wrong vector\";\n       else\n@@ -2708,7 +2260,7 @@ package body Ada.Containers.Vectors is\n    begin\n       if Position.Container = null then\n          return No_Element;\n-      elsif Position.Container /= Object.Container then\n+      elsif Checks and then Position.Container /= Object.Container then\n          raise Program_Error with\n            \"Position cursor of Previous designates wrong vector\";\n       else\n@@ -2734,15 +2286,10 @@ package body Ada.Containers.Vectors is\n    function Pseudo_Reference\n      (Container : aliased Vector'Class) return Reference_Control_Type\n    is\n-      C : constant Vector_Access := Container'Unrestricted_Access;\n-      B : Natural renames C.Busy;\n-      L : Natural renames C.Lock;\n+      TC : constant Tamper_Counts_Access := Container.TC'Unrestricted_Access;\n    begin\n-      return R : constant Reference_Control_Type :=\n-        (Controlled with C)\n-      do\n-         B := B + 1;\n-         L := L + 1;\n+      return R : constant Reference_Control_Type := (Controlled with TC) do\n+         Lock (TC.all);\n       end return;\n    end Pseudo_Reference;\n \n@@ -2755,37 +2302,23 @@ package body Ada.Containers.Vectors is\n       Index     : Index_Type;\n       Process   : not null access procedure (Element : Element_Type))\n    is\n+      Lock : With_Lock (Container.TC'Unrestricted_Access);\n       V : Vector renames Container'Unrestricted_Access.all;\n-      B : Natural renames V.Busy;\n-      L : Natural renames V.Lock;\n \n    begin\n-      if Index > Container.Last then\n+      if Checks and then Index > Container.Last then\n          raise Constraint_Error with \"Index is out of range\";\n       end if;\n \n-      B := B + 1;\n-      L := L + 1;\n-\n-      begin\n-         Process (V.Elements.EA (Index));\n-      exception\n-         when others =>\n-            L := L - 1;\n-            B := B - 1;\n-            raise;\n-      end;\n-\n-      L := L - 1;\n-      B := B - 1;\n+      Process (V.Elements.EA (Index));\n    end Query_Element;\n \n    procedure Query_Element\n      (Position : Cursor;\n       Process  : not null access procedure (Element : Element_Type))\n    is\n    begin\n-      if Position.Container = null then\n+      if Checks and then Position.Container = null then\n          raise Constraint_Error with \"Position cursor has no element\";\n       else\n          Query_Element (Position.Container.all, Position.Index, Process);\n@@ -2852,55 +2385,64 @@ package body Ada.Containers.Vectors is\n       Position  : Cursor) return Reference_Type\n    is\n    begin\n-      if Position.Container = null then\n-         raise Constraint_Error with \"Position cursor has no element\";\n-      end if;\n+      if Checks then\n+         if Position.Container = null then\n+            raise Constraint_Error with \"Position cursor has no element\";\n+         end if;\n \n-      if Position.Container /= Container'Unrestricted_Access then\n-         raise Program_Error with \"Position cursor denotes wrong container\";\n-      end if;\n+         if Position.Container /= Container'Unrestricted_Access then\n+            raise Program_Error with \"Position cursor denotes wrong container\";\n+         end if;\n \n-      if Position.Index > Position.Container.Last then\n-         raise Constraint_Error with \"Position cursor is out of range\";\n+         if Position.Index > Position.Container.Last then\n+            raise Constraint_Error with \"Position cursor is out of range\";\n+         end if;\n       end if;\n \n-      declare\n-         C : Vector renames Position.Container.all;\n-         B : Natural renames C.Busy;\n-         L : Natural renames C.Lock;\n-      begin\n+      if T_Check then\n+         declare\n+            TC : constant Tamper_Counts_Access :=\n+              Container.TC'Unrestricted_Access;\n+         begin\n+            return R : constant Reference_Type :=\n+              (Element => Container.Elements.EA (Position.Index)'Access,\n+               Control => (Controlled with TC))\n+            do\n+               Lock (TC.all);\n+            end return;\n+         end;\n+      else\n          return R : constant Reference_Type :=\n            (Element => Container.Elements.EA (Position.Index)'Access,\n-            Control => (Controlled with Position.Container))\n-         do\n-            B := B + 1;\n-            L := L + 1;\n-         end return;\n-      end;\n+            Control => (Controlled with null));\n+      end if;\n    end Reference;\n \n    function Reference\n      (Container : aliased in out Vector;\n       Index     : Index_Type) return Reference_Type\n    is\n    begin\n-      if Index > Container.Last then\n+      if Checks and then Index > Container.Last then\n          raise Constraint_Error with \"Index is out of range\";\n+      end if;\n \n-      else\n+      if T_Check then\n          declare\n-            C : Vector renames Container'Unrestricted_Access.all;\n-            B : Natural renames C.Busy;\n-            L : Natural renames C.Lock;\n+            TC : constant Tamper_Counts_Access :=\n+              Container.TC'Unrestricted_Access;\n          begin\n             return R : constant Reference_Type :=\n               (Element => Container.Elements.EA (Index)'Access,\n-               Control => (Controlled with Container'Unrestricted_Access))\n+               Control => (Controlled with TC))\n             do\n-               B := B + 1;\n-               L := L + 1;\n+               Lock (TC.all);\n             end return;\n          end;\n+      else\n+         return R : constant Reference_Type :=\n+           (Element => Container.Elements.EA (Index)'Access,\n+            Control => (Controlled with null));\n       end if;\n    end Reference;\n \n@@ -2914,14 +2456,12 @@ package body Ada.Containers.Vectors is\n       New_Item  : Element_Type)\n    is\n    begin\n-      if Index > Container.Last then\n+      if Checks and then Index > Container.Last then\n          raise Constraint_Error with \"Index is out of range\";\n-      elsif Container.Lock > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with elements (vector is locked)\";\n-      else\n-         Container.Elements.EA (Index) := New_Item;\n       end if;\n+\n+      TE_Check (Container.TC);\n+      Container.Elements.EA (Index) := New_Item;\n    end Replace_Element;\n \n    procedure Replace_Element\n@@ -2930,23 +2470,20 @@ package body Ada.Containers.Vectors is\n       New_Item  : Element_Type)\n    is\n    begin\n-      if Position.Container = null then\n-         raise Constraint_Error with \"Position cursor has no element\";\n+      if Checks then\n+         if Position.Container = null then\n+            raise Constraint_Error with \"Position cursor has no element\";\n \n-      elsif Position.Container /= Container'Unrestricted_Access then\n-         raise Program_Error with \"Position cursor denotes wrong container\";\n-\n-      elsif Position.Index > Container.Last then\n-         raise Constraint_Error with \"Position cursor is out of range\";\n+         elsif Position.Container /= Container'Unrestricted_Access then\n+            raise Program_Error with \"Position cursor denotes wrong container\";\n \n-      else\n-         if Container.Lock > 0 then\n-            raise Program_Error with\n-              \"attempt to tamper with elements (vector is locked)\";\n+         elsif Position.Index > Container.Last then\n+            raise Constraint_Error with \"Position cursor is out of range\";\n          end if;\n-\n-         Container.Elements.EA (Position.Index) := New_Item;\n       end if;\n+\n+      TE_Check (Container.TC);\n+      Container.Elements.EA (Position.Index) := New_Item;\n    end Replace_Element;\n \n    ----------------------\n@@ -3008,10 +2545,7 @@ package body Ada.Containers.Vectors is\n             --  so this is the best we can do with respect to minimizing\n             --  storage).\n \n-            if Container.Busy > 0 then\n-               raise Program_Error with\n-                 \"attempt to tamper with cursors (vector is busy)\";\n-            end if;\n+            TC_Check (Container.TC);\n \n             declare\n                subtype Src_Index_Subtype is Index_Type'Base range\n@@ -3068,7 +2602,9 @@ package body Ada.Containers.Vectors is\n          --  Which can rewrite as:\n          --    No_Index <= Last - Length\n \n-         if Index_Type'Base'Last - Index_Type'Base (Capacity) < No_Index then\n+         if Checks and then\n+           Index_Type'Base'Last - Index_Type'Base (Capacity) < No_Index\n+         then\n             raise Constraint_Error with \"Capacity is out of range\";\n          end if;\n \n@@ -3080,7 +2616,7 @@ package body Ada.Containers.Vectors is\n          --  Finally we test whether the value is within the range of the\n          --  generic actual index subtype:\n \n-         if Last > Index_Type'Last then\n+         if Checks and then Last > Index_Type'Last then\n             raise Constraint_Error with \"Capacity is out of range\";\n          end if;\n \n@@ -3092,7 +2628,7 @@ package body Ada.Containers.Vectors is\n \n          Index := Count_Type'Base (No_Index) + Capacity;  -- Last\n \n-         if Index > Count_Type'Base (Index_Type'Last) then\n+         if Checks and then Index > Count_Type'Base (Index_Type'Last) then\n             raise Constraint_Error with \"Capacity is out of range\";\n          end if;\n \n@@ -3109,7 +2645,7 @@ package body Ada.Containers.Vectors is\n \n          Index := Count_Type'Base (Index_Type'Last) - Capacity;  -- No_Index\n \n-         if Index < Count_Type'Base (No_Index) then\n+         if Checks and then Index < Count_Type'Base (No_Index) then\n             raise Constraint_Error with \"Capacity is out of range\";\n          end if;\n \n@@ -3148,10 +2684,7 @@ package body Ada.Containers.Vectors is\n             --  new internal array having a length that exactly matches the\n             --  number of items in the container.\n \n-            if Container.Busy > 0 then\n-               raise Program_Error with\n-                 \"attempt to tamper with cursors (vector is busy)\";\n-            end if;\n+            TC_Check (Container.TC);\n \n             declare\n                subtype Src_Index_Subtype is Index_Type'Base range\n@@ -3208,10 +2741,7 @@ package body Ada.Containers.Vectors is\n       --  number of active elements in the container.) We must check whether\n       --  the container is busy before doing anything else.\n \n-      if Container.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with cursors (vector is busy)\";\n-      end if;\n+      TC_Check (Container.TC);\n \n       --  We now allocate a new internal array, having a length different from\n       --  its current value.\n@@ -3283,10 +2813,7 @@ package body Ada.Containers.Vectors is\n       --  implementation. Logically Reverse_Elements requires a check for\n       --  cursor tampering.\n \n-      if Container.Busy > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with cursors (vector is busy)\";\n-      end if;\n+      TC_Check (Container.TC);\n \n       declare\n          K : Index_Type;\n@@ -3322,7 +2849,7 @@ package body Ada.Containers.Vectors is\n       Last : Index_Type'Base;\n \n    begin\n-      if Position.Container /= null\n+      if Checks and then Position.Container /= null\n         and then Position.Container /= Container'Unrestricted_Access\n       then\n          raise Program_Error with \"Position cursor denotes wrong container\";\n@@ -3337,38 +2864,15 @@ package body Ada.Containers.Vectors is\n       --  element tampering by a generic actual subprogram.\n \n       declare\n-         B : Natural renames Container'Unrestricted_Access.Busy;\n-         L : Natural renames Container'Unrestricted_Access.Lock;\n-\n-         Result : Index_Type'Base;\n-\n+         Lock : With_Lock (Container.TC'Unrestricted_Access);\n       begin\n-         B := B + 1;\n-         L := L + 1;\n-\n-         Result := No_Index;\n          for Indx in reverse Index_Type'First .. Last loop\n             if Container.Elements.EA (Indx) = Item then\n-               Result := Indx;\n-               exit;\n+               return Cursor'(Container'Unrestricted_Access, Indx);\n             end if;\n          end loop;\n \n-         B := B - 1;\n-         L := L - 1;\n-\n-         if Result = No_Index then\n-            return No_Element;\n-         else\n-            return Cursor'(Container'Unrestricted_Access, Result);\n-         end if;\n-\n-      exception\n-         when others =>\n-            B := B - 1;\n-            L := L - 1;\n-\n-            raise;\n+         return No_Element;\n       end;\n    end Reverse_Find;\n \n@@ -3381,67 +2885,36 @@ package body Ada.Containers.Vectors is\n       Item      : Element_Type;\n       Index     : Index_Type := Index_Type'Last) return Extended_Index\n    is\n-      B : Natural renames Container'Unrestricted_Access.Busy;\n-      L : Natural renames Container'Unrestricted_Access.Lock;\n+      --  Per AI05-0022, the container implementation is required to detect\n+      --  element tampering by a generic actual subprogram.\n+\n+      Lock : With_Lock (Container.TC'Unrestricted_Access);\n \n       Last : constant Index_Type'Base :=\n         Index_Type'Min (Container.Last, Index);\n \n-      Result : Index_Type'Base;\n-\n    begin\n-      --  Per AI05-0022, the container implementation is required to detect\n-      --  element tampering by a generic actual subprogram.\n-\n-      B := B + 1;\n-      L := L + 1;\n-\n-      Result := No_Index;\n       for Indx in reverse Index_Type'First .. Last loop\n          if Container.Elements.EA (Indx) = Item then\n-            Result := Indx;\n-            exit;\n+            return Indx;\n          end if;\n       end loop;\n \n-      B := B - 1;\n-      L := L - 1;\n-\n-      return Result;\n-\n-   exception\n-      when others =>\n-         B := B - 1;\n-         L := L - 1;\n-\n-         raise;\n+      return No_Index;\n    end Reverse_Find_Index;\n \n    ---------------------\n    -- Reverse_Iterate --\n    ---------------------\n-\n    procedure Reverse_Iterate\n      (Container : Vector;\n       Process   : not null access procedure (Position : Cursor))\n    is\n-      V : Vector renames Container'Unrestricted_Access.all;\n-      B : Natural renames V.Busy;\n-\n+      Busy : With_Busy (Container.TC'Unrestricted_Access);\n    begin\n-      B := B + 1;\n-\n-      begin\n-         for Indx in reverse Index_Type'First .. Container.Last loop\n-            Process (Cursor'(Container'Unrestricted_Access, Indx));\n-         end loop;\n-      exception\n-         when others =>\n-            B := B - 1;\n-            raise;\n-      end;\n-\n-      B := B - 1;\n+      for Indx in reverse Index_Type'First .. Container.Last loop\n+         Process (Cursor'(Container'Unrestricted_Access, Indx));\n+      end loop;\n    end Reverse_Iterate;\n \n    ----------------\n@@ -3462,7 +2935,7 @@ package body Ada.Containers.Vectors is\n       if Count >= 0 then\n          Container.Delete_Last (Count);\n \n-      elsif Container.Last >= Index_Type'Last then\n+      elsif Checks and then Container.Last >= Index_Type'Last then\n          raise Constraint_Error with \"vector is already at its maximum length\";\n \n       else\n@@ -3476,22 +2949,21 @@ package body Ada.Containers.Vectors is\n \n    procedure Swap (Container : in out Vector; I, J : Index_Type) is\n    begin\n-      if I > Container.Last then\n-         raise Constraint_Error with \"I index is out of range\";\n-      end if;\n+      if Checks then\n+         if I > Container.Last then\n+            raise Constraint_Error with \"I index is out of range\";\n+         end if;\n \n-      if J > Container.Last then\n-         raise Constraint_Error with \"J index is out of range\";\n+         if J > Container.Last then\n+            raise Constraint_Error with \"J index is out of range\";\n+         end if;\n       end if;\n \n       if I = J then\n          return;\n       end if;\n \n-      if Container.Lock > 0 then\n-         raise Program_Error with\n-           \"attempt to tamper with elements (vector is locked)\";\n-      end if;\n+      TE_Check (Container.TC);\n \n       declare\n          EI_Copy : constant Element_Type := Container.Elements.EA (I);\n@@ -3503,21 +2975,22 @@ package body Ada.Containers.Vectors is\n \n    procedure Swap (Container : in out Vector; I, J : Cursor) is\n    begin\n-      if I.Container = null then\n-         raise Constraint_Error with \"I cursor has no element\";\n+      if Checks then\n+         if I.Container = null then\n+            raise Constraint_Error with \"I cursor has no element\";\n \n-      elsif J.Container = null then\n-         raise Constraint_Error with \"J cursor has no element\";\n+         elsif J.Container = null then\n+            raise Constraint_Error with \"J cursor has no element\";\n \n-      elsif I.Container /= Container'Unrestricted_Access then\n-         raise Program_Error with \"I cursor denotes wrong container\";\n+         elsif I.Container /= Container'Unrestricted_Access then\n+            raise Program_Error with \"I cursor denotes wrong container\";\n \n-      elsif J.Container /= Container'Unrestricted_Access then\n-         raise Program_Error with \"J cursor denotes wrong container\";\n-\n-      else\n-         Swap (Container, I.Index, J.Index);\n+         elsif J.Container /= Container'Unrestricted_Access then\n+            raise Program_Error with \"J cursor denotes wrong container\";\n+         end if;\n       end if;\n+\n+      Swap (Container, I.Index, J.Index);\n    end Swap;\n \n    ---------------\n@@ -3585,7 +3058,9 @@ package body Ada.Containers.Vectors is\n          --  Which can rewrite as:\n          --    No_Index <= Last - Length\n \n-         if Index_Type'Base'Last - Index_Type'Base (Length) < No_Index then\n+         if Checks and then\n+           Index_Type'Base'Last - Index_Type'Base (Length) < No_Index\n+         then\n             raise Constraint_Error with \"Length is out of range\";\n          end if;\n \n@@ -3597,7 +3072,7 @@ package body Ada.Containers.Vectors is\n          --  Finally we test whether the value is within the range of the\n          --  generic actual index subtype:\n \n-         if Last > Index_Type'Last then\n+         if Checks and then Last > Index_Type'Last then\n             raise Constraint_Error with \"Length is out of range\";\n          end if;\n \n@@ -3609,7 +3084,7 @@ package body Ada.Containers.Vectors is\n \n          Index := Count_Type'Base (No_Index) + Length;  -- Last\n \n-         if Index > Count_Type'Base (Index_Type'Last) then\n+         if Checks and then Index > Count_Type'Base (Index_Type'Last) then\n             raise Constraint_Error with \"Length is out of range\";\n          end if;\n \n@@ -3626,7 +3101,7 @@ package body Ada.Containers.Vectors is\n \n          Index := Count_Type'Base (Index_Type'Last) - Length;  -- No_Index\n \n-         if Index < Count_Type'Base (No_Index) then\n+         if Checks and then Index < Count_Type'Base (No_Index) then\n             raise Constraint_Error with \"Length is out of range\";\n          end if;\n \n@@ -3675,7 +3150,9 @@ package body Ada.Containers.Vectors is\n          --  Which can rewrite as:\n          --    No_Index <= Last - Length\n \n-         if Index_Type'Base'Last - Index_Type'Base (Length) < No_Index then\n+         if Checks and then\n+           Index_Type'Base'Last - Index_Type'Base (Length) < No_Index\n+         then\n             raise Constraint_Error with \"Length is out of range\";\n          end if;\n \n@@ -3687,7 +3164,7 @@ package body Ada.Containers.Vectors is\n          --  Finally we test whether the value is within the range of the\n          --  generic actual index subtype:\n \n-         if Last > Index_Type'Last then\n+         if Checks and then Last > Index_Type'Last then\n             raise Constraint_Error with \"Length is out of range\";\n          end if;\n \n@@ -3699,7 +3176,7 @@ package body Ada.Containers.Vectors is\n \n          Index := Count_Type'Base (No_Index) + Length;  -- same value as V.Last\n \n-         if Index > Count_Type'Base (Index_Type'Last) then\n+         if Checks and then Index > Count_Type'Base (Index_Type'Last) then\n             raise Constraint_Error with \"Length is out of range\";\n          end if;\n \n@@ -3716,7 +3193,7 @@ package body Ada.Containers.Vectors is\n \n          Index := Count_Type'Base (Index_Type'Last) - Length;  -- No_Index\n \n-         if Index < Count_Type'Base (No_Index) then\n+         if Checks and then Index < Count_Type'Base (No_Index) then\n             raise Constraint_Error with \"Length is out of range\";\n          end if;\n \n@@ -3741,28 +3218,13 @@ package body Ada.Containers.Vectors is\n       Index     : Index_Type;\n       Process   : not null access procedure (Element : in out Element_Type))\n    is\n-      B : Natural renames Container.Busy;\n-      L : Natural renames Container.Lock;\n-\n+      Lock : With_Lock (Container.TC'Unchecked_Access);\n    begin\n-      if Index > Container.Last then\n+      if Checks and then Index > Container.Last then\n          raise Constraint_Error with \"Index is out of range\";\n       end if;\n \n-      B := B + 1;\n-      L := L + 1;\n-\n-      begin\n-         Process (Container.Elements.EA (Index));\n-      exception\n-         when others =>\n-            L := L - 1;\n-            B := B - 1;\n-            raise;\n-      end;\n-\n-      L := L - 1;\n-      B := B - 1;\n+      Process (Container.Elements.EA (Index));\n    end Update_Element;\n \n    procedure Update_Element\n@@ -3771,13 +3233,15 @@ package body Ada.Containers.Vectors is\n       Process   : not null access procedure (Element : in out Element_Type))\n    is\n    begin\n-      if Position.Container = null then\n-         raise Constraint_Error with \"Position cursor has no element\";\n-      elsif Position.Container /= Container'Unrestricted_Access then\n-         raise Program_Error with \"Position cursor denotes wrong container\";\n-      else\n-         Update_Element (Container, Position.Index, Process);\n+      if Checks then\n+         if Position.Container = null then\n+            raise Constraint_Error with \"Position cursor has no element\";\n+         elsif Position.Container /= Container'Unrestricted_Access then\n+            raise Program_Error with \"Position cursor denotes wrong container\";\n+         end if;\n       end if;\n+\n+      Update_Element (Container, Position.Index, Process);\n    end Update_Element;\n \n    -----------"}, {"sha": "e494386504d5ad4f75c754392b698210fde3c20e", "filename": "gcc/ada/a-convec.ads", "status": "modified", "additions": 30, "deletions": 16, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a738b3469af68a64477662c051424b9a089ce62/gcc%2Fada%2Fa-convec.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a738b3469af68a64477662c051424b9a089ce62/gcc%2Fada%2Fa-convec.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-convec.ads?ref=2a738b3469af68a64477662c051424b9a089ce62", "patch": "@@ -366,23 +366,24 @@ private\n    pragma Inline (Next);\n    pragma Inline (Previous);\n \n+   package Implementation is new Generic_Implementation;\n+   use Implementation;\n+\n    type Elements_Array is array (Index_Type range <>) of aliased Element_Type;\n-   function \"=\" (L, R : Elements_Array) return Boolean is abstract;\n \n    type Elements_Type (Last : Extended_Index) is limited record\n       EA : Elements_Array (Index_Type'First .. Last);\n    end record;\n \n    type Elements_Access is access all Elements_Type;\n \n-   use Ada.Finalization;\n-   use Ada.Streams;\n+   use Finalization;\n+   use Streams;\n \n    type Vector is new Controlled with record\n       Elements : Elements_Access := null;\n       Last     : Extended_Index := No_Index;\n-      Busy     : Natural := 0;\n-      Lock     : Natural := 0;\n+      TC       : aliased Tamper_Counts;\n    end record;\n \n    overriding procedure Adjust (Container : in out Vector);\n@@ -420,16 +421,8 @@ private\n \n    for Cursor'Write use Write;\n \n-   type Reference_Control_Type is\n-      new Controlled with record\n-         Container : Vector_Access;\n-      end record;\n-\n-   overriding procedure Adjust (Control : in out Reference_Control_Type);\n-   pragma Inline (Adjust);\n-\n-   overriding procedure Finalize (Control : in out Reference_Control_Type);\n-   pragma Inline (Finalize);\n+   subtype Reference_Control_Type is Implementation.Reference_Control_Type;\n+   --  It is necessary to rename this here, so that the compiler can find it\n \n    type Constant_Reference_Type\n      (Element : not null access constant Element_Type) is\n@@ -477,7 +470,7 @@ private\n \n    --  Three operations are used to optimize in the expansion of \"for ... of\"\n    --  loops: the Next(Cursor) procedure in the visible part, and the following\n-   --  Pseudo_Reference and Get_Element_Access functions. See Sem_Ch5 for\n+   --  Pseudo_Reference and Get_Element_Access functions. See Exp_Ch5 for\n    --  details.\n \n    function Pseudo_Reference\n@@ -501,4 +494,25 @@ private\n    --  Count_Type'Last as a universal_integer, so we can compare Index_Type\n    --  values against this without type conversions that might overflow.\n \n+   type Iterator is new Limited_Controlled and\n+     Vector_Iterator_Interfaces.Reversible_Iterator with\n+   record\n+      Container : Vector_Access;\n+      Index     : Index_Type'Base;\n+   end record\n+     with Disable_Controlled => not T_Check;\n+\n+   overriding procedure Finalize (Object : in out Iterator);\n+\n+   overriding function First (Object : Iterator) return Cursor;\n+   overriding function Last  (Object : Iterator) return Cursor;\n+\n+   overriding function Next\n+     (Object   : Iterator;\n+      Position : Cursor) return Cursor;\n+\n+   overriding function Previous\n+     (Object   : Iterator;\n+      Position : Cursor) return Cursor;\n+\n end Ada.Containers.Vectors;"}, {"sha": "2354b988a428e6c0949b24f89e8467eadae4a1c1", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a738b3469af68a64477662c051424b9a089ce62/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a738b3469af68a64477662c051424b9a089ce62/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=2a738b3469af68a64477662c051424b9a089ce62", "patch": "@@ -9840,9 +9840,15 @@ package body Sem_Ch13 is\n                          (Parent_Last_Bit,\n                           Component_Bit_Offset (Pcomp) + Esize (Pcomp) - 1);\n                   end if;\n+               else\n+\n+                  --  Skip anonymous types generated for constrained array\n+                  --  or record components.\n \n-                  Next_Entity (Pcomp);\n+                  null;\n                end if;\n+\n+               Next_Entity (Pcomp);\n             end loop;\n          end if;\n       end;"}]}