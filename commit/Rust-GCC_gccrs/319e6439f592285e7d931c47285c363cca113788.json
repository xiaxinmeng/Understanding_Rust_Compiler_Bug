{"sha": "319e6439f592285e7d931c47285c363cca113788", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzE5ZTY0MzlmNTkyMjg1ZTdkOTMxYzQ3Mjg1YzM2M2NjYTExMzc4OA==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2012-05-11T12:03:10Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2012-05-11T12:03:10Z"}, "message": "re PR tree-optimization/53295 (Vectorizer support for non-constant strided loads depends on gather support overwriting the data-ref with bogus data)\n\n2012-05-11  Richard Guenther  <rguenther@suse.de>\n\n        PR tree-optimization/53295\n\t* tree-data-ref.h (stride_of_unit_type_p): Handle non-constant\n\tstrides.\n\t* tree-data-ref.c (dr_analyze_innermost): Allow non-constant\n\tstrides when analyzing data-references in a loop context.\n\t* tree-vect-data-refs.c (vect_mark_for_runtime_alias_test): Reject\n\tnon-constant strides for now.\n\t(vect_enhance_data_refs_alignment): Ignore data references\n\tthat are strided loads.\n\t(vect_analyze_data_ref_access): Handle non-constant strides.\n\t(vect_check_strided_load): Verify the data-reference is a load.\n\t(vect_analyze_data_refs): Restructure to make strided load\n\tsupport not dependent on gather support.\n\t* tree-vect-stmts.c (vectorizable_load): Avoid useless work\n\twhen doing strided or gather loads.\n\t* tree-vect-loop-manip.c (vect_vfa_segment_size): Use\n\tinteger_zerop to compare stride with zero.\n\nFrom-SVN: r187402", "tree": {"sha": "c7417b74792b46bcd03c94c197dcf0d6da80c8c3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c7417b74792b46bcd03c94c197dcf0d6da80c8c3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/319e6439f592285e7d931c47285c363cca113788", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/319e6439f592285e7d931c47285c363cca113788", "html_url": "https://github.com/Rust-GCC/gccrs/commit/319e6439f592285e7d931c47285c363cca113788", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/319e6439f592285e7d931c47285c363cca113788/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "76a02e42c00f4e2d79087c77f0c7970d24f4c3c0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76a02e42c00f4e2d79087c77f0c7970d24f4c3c0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/76a02e42c00f4e2d79087c77f0c7970d24f4c3c0"}], "stats": {"total": 190, "additions": 132, "deletions": 58}, "files": [{"sha": "c5d733aa88cbd0ff4d12c24073a0066770d44ed6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/319e6439f592285e7d931c47285c363cca113788/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/319e6439f592285e7d931c47285c363cca113788/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=319e6439f592285e7d931c47285c363cca113788", "patch": "@@ -1,3 +1,23 @@\n+2012-05-11  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR tree-optimization/53295\n+\t* tree-data-ref.h (stride_of_unit_type_p): Handle non-constant\n+\tstrides.\n+\t* tree-data-ref.c (dr_analyze_innermost): Allow non-constant\n+\tstrides when analyzing data-references in a loop context.\n+\t* tree-vect-data-refs.c (vect_mark_for_runtime_alias_test): Reject\n+\tnon-constant strides for now.\n+\t(vect_enhance_data_refs_alignment): Ignore data references\n+\tthat are strided loads.\n+\t(vect_analyze_data_ref_access): Handle non-constant strides.\n+\t(vect_check_strided_load): Verify the data-reference is a load.\n+\t(vect_analyze_data_refs): Restructure to make strided load\n+\tsupport not dependent on gather support.\n+\t* tree-vect-stmts.c (vectorizable_load): Avoid useless work\n+\twhen doing strided or gather loads.\n+\t* tree-vect-loop-manip.c (vect_vfa_segment_size): Use\n+\tinteger_zerop to compare stride with zero.\n+\n 2012-05-11  H.J. Lu  <hongjiu.lu@intel.com>\n \n \t* config/i386/driver-i386.c (host_detect_local_cpu): Support"}, {"sha": "90b6f70e4a912e7c177e08491ae6a3282c347b79", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/319e6439f592285e7d931c47285c363cca113788/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/319e6439f592285e7d931c47285c363cca113788/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=319e6439f592285e7d931c47285c363cca113788", "patch": "@@ -736,7 +736,7 @@ dr_analyze_innermost (struct data_reference *dr, struct loop *nest)\n   if (in_loop)\n     {\n       if (!simple_iv (loop, loop_containing_stmt (stmt), base, &base_iv,\n-                      false))\n+                      nest ? true : false))\n         {\n           if (nest)\n             {\n@@ -773,7 +773,8 @@ dr_analyze_innermost (struct data_reference *dr, struct loop *nest)\n           offset_iv.step = ssize_int (0);\n         }\n       else if (!simple_iv (loop, loop_containing_stmt (stmt),\n-                           poffset, &offset_iv, false))\n+                           poffset, &offset_iv,\n+\t\t\t   nest ? true : false))\n         {\n           if (nest)\n             {"}, {"sha": "efce845625fb39a9973ee7b4cd14ee75363f4ab0", "filename": "gcc/tree-data-ref.h", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/319e6439f592285e7d931c47285c363cca113788/gcc%2Ftree-data-ref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/319e6439f592285e7d931c47285c363cca113788/gcc%2Ftree-data-ref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.h?ref=319e6439f592285e7d931c47285c363cca113788", "patch": "@@ -618,9 +618,10 @@ bool stmt_with_adjacent_zero_store_dr_p (gimple);\n static inline bool\n stride_of_unit_type_p (tree stride, tree type)\n {\n-  return tree_int_cst_equal (fold_unary (ABS_EXPR, TREE_TYPE (stride),\n-\t\t\t\t\t stride),\n-\t\t\t     TYPE_SIZE_UNIT (type));\n+  return (TREE_CODE (stride) == INTEGER_CST\n+\t  && tree_int_cst_equal (fold_unary (ABS_EXPR, TREE_TYPE (stride),\n+\t\t\t\t\t     stride),\n+\t\t\t\t TYPE_SIZE_UNIT (type)));\n }\n \n /* Determines whether RDG vertices V1 and V2 access to similar memory"}, {"sha": "e536321fcdc3bb55c4338e804997438ed1aa0ee5", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 68, "deletions": 21, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/319e6439f592285e7d931c47285c363cca113788/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/319e6439f592285e7d931c47285c363cca113788/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=319e6439f592285e7d931c47285c363cca113788", "patch": "@@ -542,6 +542,17 @@ vect_mark_for_runtime_alias_test (ddr_p ddr, loop_vec_info loop_vinfo)\n       return false;\n     }\n \n+  /* FORNOW: We don't support creating runtime alias tests for non-constant\n+     step.  */\n+  if (TREE_CODE (DR_STEP (DDR_A (ddr))) != INTEGER_CST\n+      || TREE_CODE (DR_STEP (DDR_B (ddr))) != INTEGER_CST)\n+    {\n+      if (vect_print_dump_info (REPORT_DR_DETAILS))\n+\tfprintf (vect_dump, \"versioning not yet supported for non-constant \"\n+\t\t \"step\");\n+      return false;\n+    }\n+\n   VEC_safe_push (ddr_p, heap, LOOP_VINFO_MAY_ALIAS_DDRS (loop_vinfo), ddr);\n   return true;\n }\n@@ -1522,6 +1533,11 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n       if (integer_zerop (DR_STEP (dr)))\n \tcontinue;\n \n+      /* Strided loads perform only component accesses, alignment is\n+\t irrelevant for them.  */\n+      if (STMT_VINFO_STRIDE_LOAD_P (stmt_info))\n+\tcontinue;\n+\n       supportable_dr_alignment = vect_supportable_dr_alignment (dr, true);\n       do_peeling = vector_alignment_reachable_p (dr);\n       if (do_peeling)\n@@ -1779,6 +1795,11 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n \t      && GROUP_FIRST_ELEMENT (stmt_info) != stmt)\n \t    continue;\n \n+\t  /* Strided loads perform only component accesses, alignment is\n+\t     irrelevant for them.  */\n+\t  if (STMT_VINFO_STRIDE_LOAD_P (stmt_info))\n+\t    continue;\n+\n \t  save_misalignment = DR_MISALIGNMENT (dr);\n \t  vect_update_misalignment_for_peel (dr, dr0, npeel);\n \t  supportable_dr_alignment = vect_supportable_dr_alignment (dr, false);\n@@ -1861,6 +1882,11 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n \t\t  && GROUP_FIRST_ELEMENT (stmt_info) != stmt))\n \t    continue;\n \n+\t  /* Strided loads perform only component accesses, alignment is\n+\t     irrelevant for them.  */\n+\t  if (STMT_VINFO_STRIDE_LOAD_P (stmt_info))\n+\t    continue;\n+\n \t  supportable_dr_alignment = vect_supportable_dr_alignment (dr, false);\n \n           if (!supportable_dr_alignment)\n@@ -2329,7 +2355,6 @@ vect_analyze_data_ref_access (struct data_reference *dr)\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n   struct loop *loop = NULL;\n-  HOST_WIDE_INT dr_step;\n \n   if (loop_vinfo)\n     loop = LOOP_VINFO_LOOP (loop_vinfo);\n@@ -2342,8 +2367,7 @@ vect_analyze_data_ref_access (struct data_reference *dr)\n     }\n \n   /* Allow invariant loads in loops.  */\n-  dr_step = TREE_INT_CST_LOW (step);\n-  if (loop_vinfo && dr_step == 0)\n+  if (loop_vinfo && integer_zerop (step))\n     {\n       GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt)) = NULL;\n       return DR_IS_READ (dr);\n@@ -2357,9 +2381,7 @@ vect_analyze_data_ref_access (struct data_reference *dr)\n \n       /* For the rest of the analysis we use the outer-loop step.  */\n       step = STMT_VINFO_DR_STEP (stmt_info);\n-      dr_step = TREE_INT_CST_LOW (step);\n-\n-      if (dr_step == 0)\n+      if (integer_zerop (step))\n \t{\n \t  if (vect_print_dump_info (REPORT_ALIGNMENT))\n \t    fprintf (vect_dump, \"zero step in outer loop.\");\n@@ -2371,13 +2393,17 @@ vect_analyze_data_ref_access (struct data_reference *dr)\n     }\n \n   /* Consecutive?  */\n-  if (!tree_int_cst_compare (step, TYPE_SIZE_UNIT (scalar_type))\n-      || (dr_step < 0\n-\t  && !compare_tree_int (TYPE_SIZE_UNIT (scalar_type), -dr_step)))\n+  if (TREE_CODE (step) == INTEGER_CST)\n     {\n-      /* Mark that it is not interleaving.  */\n-      GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt)) = NULL;\n-      return true;\n+      HOST_WIDE_INT dr_step = TREE_INT_CST_LOW (step);\n+      if (!tree_int_cst_compare (step, TYPE_SIZE_UNIT (scalar_type))\n+\t  || (dr_step < 0\n+\t      && !compare_tree_int (TYPE_SIZE_UNIT (scalar_type), -dr_step)))\n+\t{\n+\t  /* Mark that it is not interleaving.  */\n+\t  GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt)) = NULL;\n+\t  return true;\n+\t}\n     }\n \n   if (loop && nested_in_vect_loop_p (loop, stmt))\n@@ -2387,6 +2413,10 @@ vect_analyze_data_ref_access (struct data_reference *dr)\n       return false;\n     }\n \n+  /* Assume this is a DR handled by non-constant strided load case.  */\n+  if (TREE_CODE (step) != INTEGER_CST)\n+    return STMT_VINFO_STRIDE_LOAD_P (stmt_info);\n+\n   /* Not consecutive access - check if it's a part of interleaving group.  */\n   return vect_analyze_group_access (dr);\n }\n@@ -2720,6 +2750,9 @@ vect_check_strided_load (gimple stmt, loop_vec_info loop_vinfo, tree *basep,\n   tree base, off;\n   affine_iv iv;\n \n+  if (!DR_IS_READ (dr))\n+    return false;\n+\n   base = DR_REF (dr);\n \n   if (TREE_CODE (base) == ARRAY_REF)\n@@ -3148,21 +3181,19 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo,\n \t  VEC (ddr_p, heap) *ddrs = LOOP_VINFO_DDRS (loop_vinfo);\n \t  struct data_dependence_relation *ddr, *newddr;\n \t  bool bad = false;\n-\t  bool strided_load = false;\n \t  tree off;\n \t  VEC (loop_p, heap) *nest = LOOP_VINFO_LOOP_NEST (loop_vinfo);\n \n-\t  strided_load = vect_check_strided_load (stmt, loop_vinfo, NULL, NULL);\n \t  gather = 0 != vect_check_gather (stmt, loop_vinfo, NULL, &off, NULL);\n \t  if (gather\n \t      && get_vectype_for_scalar_type (TREE_TYPE (off)) == NULL_TREE)\n \t    gather = false;\n-\t  if (!gather && !strided_load)\n+\t  if (!gather)\n \t    {\n \t      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOCATIONS))\n \t\t{\n \t\t  fprintf (vect_dump,\n-\t\t\t   \"not vectorized: not suitable for gather/strided load \");\n+\t\t\t   \"not vectorized: not suitable for gather load \");\n \t\t  print_gimple_stmt (vect_dump, stmt, 0, TDF_SLIM);\n \t\t}\n \t      return false;\n@@ -3215,16 +3246,32 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo,\n \t\t{\n \t\t  fprintf (vect_dump,\n \t\t\t   \"not vectorized: data dependence conflict\"\n-\t\t\t   \" prevents gather/strided load\");\n+\t\t\t   \" prevents gather load\");\n \t\t  print_gimple_stmt (vect_dump, stmt, 0, TDF_SLIM);\n \t\t}\n \t      return false;\n \t    }\n \n-\t  if (gather)\n-\t    STMT_VINFO_GATHER_P (stmt_info) = true;\n-\t  else if (strided_load)\n-\t    STMT_VINFO_STRIDE_LOAD_P (stmt_info) = true;\n+\t  STMT_VINFO_GATHER_P (stmt_info) = true;\n+\t}\n+      else if (loop_vinfo\n+\t       && TREE_CODE (DR_STEP (dr)) != INTEGER_CST)\n+\t{\n+\t  bool strided_load = false;\n+\t  if (!nested_in_vect_loop_p (loop, stmt))\n+\t    strided_load\n+\t      = vect_check_strided_load (stmt, loop_vinfo, NULL, NULL);\n+\t  if (!strided_load)\n+\t    {\n+\t      if (vect_print_dump_info (REPORT_UNVECTORIZED_LOCATIONS))\n+\t\t{\n+\t\t  fprintf (vect_dump,\n+\t\t\t   \"not vectorized: not suitable for strided load \");\n+\t\t  print_gimple_stmt (vect_dump, stmt, 0, TDF_SLIM);\n+\t\t}\n+\t      return false;\n+\t    }\n+\t  STMT_VINFO_STRIDE_LOAD_P (stmt_info) = true;\n \t}\n     }\n "}, {"sha": "ac2eb767cf9c6189d3d4b3d29d020d8c7c94a555", "filename": "gcc/tree-vect-loop-manip.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/319e6439f592285e7d931c47285c363cca113788/gcc%2Ftree-vect-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/319e6439f592285e7d931c47285c363cca113788/gcc%2Ftree-vect-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop-manip.c?ref=319e6439f592285e7d931c47285c363cca113788", "patch": "@@ -2334,7 +2334,7 @@ vect_vfa_segment_size (struct data_reference *dr, tree length_factor)\n {\n   tree segment_length;\n \n-  if (!compare_tree_int (DR_STEP (dr), 0))\n+  if (integer_zerop (DR_STEP (dr)))\n     segment_length = TYPE_SIZE_UNIT (TREE_TYPE (DR_REF (dr)));\n   else\n     segment_length = size_binop (MULT_EXPR,"}, {"sha": "88204fec2d342d6c1825c72f10e82e0262ce458c", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 36, "deletions": 31, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/319e6439f592285e7d931c47285c363cca113788/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/319e6439f592285e7d931c47285c363cca113788/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=319e6439f592285e7d931c47285c363cca113788", "patch": "@@ -4210,7 +4210,7 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n   bool load_lanes_p = false;\n   gimple first_stmt;\n   bool inv_p;\n-  bool negative;\n+  bool negative = false;\n   bool compute_in_loop = false;\n   struct loop *at_loop;\n   int vec_num;\n@@ -4280,17 +4280,6 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n   if (!STMT_VINFO_DATA_REF (stmt_info))\n     return false;\n \n-  negative = tree_int_cst_compare (nested_in_vect_loop\n-\t\t\t\t   ? STMT_VINFO_DR_STEP (stmt_info)\n-\t\t\t\t   : DR_STEP (dr),\n-\t\t\t\t   size_zero_node) < 0;\n-  if (negative && ncopies > 1)\n-    {\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-        fprintf (vect_dump, \"multiple types with negative step.\");\n-      return false;\n-    }\n-\n   elem_type = TREE_TYPE (vectype);\n   mode = TYPE_MODE (vectype);\n \n@@ -4321,24 +4310,6 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n \t}\n     }\n \n-  if (negative)\n-    {\n-      gcc_assert (!grouped_load && !STMT_VINFO_GATHER_P (stmt_info));\n-      alignment_support_scheme = vect_supportable_dr_alignment (dr, false);\n-      if (alignment_support_scheme != dr_aligned\n-\t  && alignment_support_scheme != dr_unaligned_supported)\n-\t{\n-\t  if (vect_print_dump_info (REPORT_DETAILS))\n-\t    fprintf (vect_dump, \"negative step but alignment required.\");\n-\t  return false;\n-\t}\n-      if (!perm_mask_for_reverse (vectype))\n-\t{\n-\t  if (vect_print_dump_info (REPORT_DETAILS))\n-\t    fprintf (vect_dump, \"negative step and reversing not supported.\");\n-\t  return false;\n-\t}\n-    }\n \n   if (STMT_VINFO_GATHER_P (stmt_info))\n     {\n@@ -4358,7 +4329,41 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n     }\n   else if (STMT_VINFO_STRIDE_LOAD_P (stmt_info))\n     {\n-      vect_check_strided_load (stmt, loop_vinfo, &stride_base, &stride_step);\n+      if (!vect_check_strided_load (stmt, loop_vinfo,\n+\t\t\t\t    &stride_base, &stride_step))\n+\treturn false;\n+    }\n+  else\n+    {\n+      negative = tree_int_cst_compare (nested_in_vect_loop\n+\t\t\t\t       ? STMT_VINFO_DR_STEP (stmt_info)\n+\t\t\t\t       : DR_STEP (dr),\n+\t\t\t\t       size_zero_node) < 0;\n+      if (negative && ncopies > 1)\n+\t{\n+\t  if (vect_print_dump_info (REPORT_DETAILS))\n+\t    fprintf (vect_dump, \"multiple types with negative step.\");\n+\t  return false;\n+\t}\n+\n+      if (negative)\n+\t{\n+\t  gcc_assert (!grouped_load);\n+\t  alignment_support_scheme = vect_supportable_dr_alignment (dr, false);\n+\t  if (alignment_support_scheme != dr_aligned\n+\t      && alignment_support_scheme != dr_unaligned_supported)\n+\t    {\n+\t      if (vect_print_dump_info (REPORT_DETAILS))\n+\t\tfprintf (vect_dump, \"negative step but alignment required.\");\n+\t      return false;\n+\t    }\n+\t  if (!perm_mask_for_reverse (vectype))\n+\t    {\n+\t      if (vect_print_dump_info (REPORT_DETAILS))\n+\t\tfprintf (vect_dump, \"negative step and reversing not supported.\");\n+\t      return false;\n+\t    }\n+\t}\n     }\n \n   if (!vec_stmt) /* transformation not required.  */"}]}