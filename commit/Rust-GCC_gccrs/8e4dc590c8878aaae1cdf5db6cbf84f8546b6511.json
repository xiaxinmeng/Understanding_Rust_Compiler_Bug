{"sha": "8e4dc590c8878aaae1cdf5db6cbf84f8546b6511", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGU0ZGM1OTBjODg3OGFhYWUxY2RmNWRiNmNiZjg0Zjg1NDZiNjUxMQ==", "commit": {"author": {"name": "Aditya Kumar", "email": "aditya.k7@samsung.com", "date": "2015-10-06T15:56:03Z"}, "committer": {"name": "Sebastian Pop", "email": "spop@gcc.gnu.org", "date": "2015-10-06T15:56:03Z"}, "message": "Move declarations, assign types, renaming.\n\n1. Move declarations near the assignment/usage.\n2. Assign type to members which were void*.\n3. Rename scop->context to scop::param_context, and scop::ctx to\nscop::isl_context\n\nNo functional changes intended. Passes regtest and bootstrap.\n\ngcc/ChangeLog:\n\n2015-10-05  Aditya Kumar  <aditya.k7@samsung.com>\n\n        * graphite-dependences.c (scop_get_reads): Renamed scop->context to scop->param_context.\n        (scop_get_must_writes): Same.\n        (scop_get_may_writes): Same.\n        (scop_get_original_schedule): Same.\n        (scop_get_transformed_schedule): Same.\n        (subtract_commutative_associative_deps): Same.\n        * graphite-isl-ast-to-gimple.c (add_parameters_to_ivs_params): Same.\n        (generate_isl_context): Same.\n        (generate_isl_schedule): Same.\n        (scop_to_isl_ast): Same.\n        (graphite_regenerate_ast_isl): Same.\n        * graphite-optimize-isl.c (scop_get_domains): Same.\n        (optimize_isl): Renamed scop->context to scop->param_context.\n        * graphite-poly.c (new_poly_bb): Change the type of argument to gimple_poly_bb_p.\n        (new_scop): Renamed scop->context to scop->param_context.\n        (free_scop): Same.\n        (print_scop_context): Same.\n        * graphite-poly.h (new_poly_dr): Change the type of argument from void* to data_reference_p.\n        (struct poly_bb): Change the type of black_box to gimple_poly_bb_p.\n        (new_poly_bb): Change the type of argument from void* to gimple_poly_bb_p.\n        (pbb_set_black_box): Same.\n        (struct scop): Rename context to param_context, ctx to isl_context.\n        * graphite-scop-detection.c (scop_detection::build_scop_bbs_1): Move declarations closer to assignment.\n        (find_params_in_bb): Same.\n        (find_scop_parameters): Same.\n        * graphite-sese-to-poly.c (unsigned ssa_name_version_typesize): Global to be used for statement IDs.\n        (isl_id_for_pbb): Use ssa_name_version_typesize.\n        (simple_copy_phi_p): Move declarations closer to assignment.\n        (build_pbb_scattering_polyhedrons): Same.\n        (build_scop_scattering): Same.\n        (isl_id_for_ssa_name): Same.\n        (extract_affine_name): Same.\n        (extract_affine_int): Same.\n        (extract_affine): Same.\n        (set_scop_parameter_dim): Use renamed member.\n        (build_loop_iteration_domains): Same.\n        (add_param_constraints): Same.\n        (build_scop_iteration_domain): Same.\n        (pdr_add_data_dimensions): Same.\n        (build_poly_dr): Same.\n        (build_scop_drs): Move declarations closer to assignment.\n        (analyze_drs_in_stmts): Same.\n        (insert_out_of_ssa_copy): Same.\n        (insert_out_of_ssa_copy_on_edge): Same.\n        (propagate_expr_outside_region): Same.\n        (rewrite_phi_out_of_ssa): Same.\n        (rewrite_degenerate_phi): Same.\n        (rewrite_reductions_out_of_ssa): Same.\n        (rewrite_cross_bb_scalar_dependence): Same.\n        (handle_scalar_deps_crossing_scop_limits): Same.\n        (rewrite_cross_bb_scalar_deps): Same.\n        * graphite.c (graphite_transform_loops): Use renamed member.\n\nFrom-SVN: r228528", "tree": {"sha": "d5edbcbc1752ee868796944f0fa314603b831cb2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d5edbcbc1752ee868796944f0fa314603b831cb2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8e4dc590c8878aaae1cdf5db6cbf84f8546b6511", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e4dc590c8878aaae1cdf5db6cbf84f8546b6511", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8e4dc590c8878aaae1cdf5db6cbf84f8546b6511", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e4dc590c8878aaae1cdf5db6cbf84f8546b6511/comments", "author": null, "committer": {"login": "sebpop", "id": 568397, "node_id": "MDQ6VXNlcjU2ODM5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/568397?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sebpop", "html_url": "https://github.com/sebpop", "followers_url": "https://api.github.com/users/sebpop/followers", "following_url": "https://api.github.com/users/sebpop/following{/other_user}", "gists_url": "https://api.github.com/users/sebpop/gists{/gist_id}", "starred_url": "https://api.github.com/users/sebpop/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sebpop/subscriptions", "organizations_url": "https://api.github.com/users/sebpop/orgs", "repos_url": "https://api.github.com/users/sebpop/repos", "events_url": "https://api.github.com/users/sebpop/events{/privacy}", "received_events_url": "https://api.github.com/users/sebpop/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0711992144a5d8f06a4f174786f8344917c9d707", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0711992144a5d8f06a4f174786f8344917c9d707", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0711992144a5d8f06a4f174786f8344917c9d707"}], "stats": {"total": 369, "additions": 195, "deletions": 174}, "files": [{"sha": "08efe78faabc304476b09eb30f1c075fe04ad2f2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e4dc590c8878aaae1cdf5db6cbf84f8546b6511/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e4dc590c8878aaae1cdf5db6cbf84f8546b6511/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8e4dc590c8878aaae1cdf5db6cbf84f8546b6511", "patch": "@@ -1,3 +1,64 @@\n+2015-10-05  Aditya Kumar  <aditya.k7@samsung.com>\n+\n+\t* graphite-dependences.c (scop_get_reads): Renamed scop->context\n+\tto scop->param_context.\n+\t(scop_get_must_writes): Same.\n+\t(scop_get_may_writes): Same.\n+\t(scop_get_original_schedule): Same.\n+\t(scop_get_transformed_schedule): Same.\n+\t(subtract_commutative_associative_deps): Same.\n+\t* graphite-isl-ast-to-gimple.c (add_parameters_to_ivs_params): Same.\n+\t(generate_isl_context): Same.\n+\t(generate_isl_schedule): Same.\n+\t(scop_to_isl_ast): Same.\n+\t(graphite_regenerate_ast_isl): Same.\n+\t* graphite-optimize-isl.c (scop_get_domains): Same.\n+\t(optimize_isl): Renamed scop->context to scop->param_context.\n+\t* graphite-poly.c (new_poly_bb): Change the type of argument to\n+\tgimple_poly_bb_p.\n+\t(new_scop): Renamed scop->context to scop->param_context.\n+\t(free_scop): Same.\n+\t(print_scop_context): Same.\n+\t* graphite-poly.h (new_poly_dr): Change the type of argument from\n+\tvoid* to data_reference_p.\n+\t(struct poly_bb): Change the type of black_box to gimple_poly_bb_p.\n+\t(new_poly_bb): Change the type of argument from void* to\n+\tgimple_poly_bb_p.\n+\t(pbb_set_black_box): Same.\n+\t(struct scop): Rename context to param_context, ctx to isl_context.\n+\t* graphite-scop-detection.c (scop_detection::build_scop_bbs_1):\n+\tMove declarations closer to assignment.\n+\t(find_params_in_bb): Same.\n+\t(find_scop_parameters): Same.\n+\t* graphite-sese-to-poly.c (unsigned ssa_name_version_typesize):\n+\tGlobal to be used for statement IDs.\n+\t(isl_id_for_pbb): Use ssa_name_version_typesize.\n+\t(simple_copy_phi_p): Move declarations closer to assignment.\n+\t(build_pbb_scattering_polyhedrons): Same.\n+\t(build_scop_scattering): Same.\n+\t(isl_id_for_ssa_name): Same.\n+\t(extract_affine_name): Same.\n+\t(extract_affine_int): Same.\n+\t(extract_affine): Same.\n+\t(set_scop_parameter_dim): Use renamed member.\n+\t(build_loop_iteration_domains): Same.\n+\t(add_param_constraints): Same.\n+\t(build_scop_iteration_domain): Same.\n+\t(pdr_add_data_dimensions): Same.\n+\t(build_poly_dr): Same.\n+\t(build_scop_drs): Move declarations closer to assignment.\n+\t(analyze_drs_in_stmts): Same.\n+\t(insert_out_of_ssa_copy): Same.\n+\t(insert_out_of_ssa_copy_on_edge): Same.\n+\t(propagate_expr_outside_region): Same.\n+\t(rewrite_phi_out_of_ssa): Same.\n+\t(rewrite_degenerate_phi): Same.\n+\t(rewrite_reductions_out_of_ssa): Same.\n+\t(rewrite_cross_bb_scalar_dependence): Same.\n+\t(handle_scalar_deps_crossing_scop_limits): Same.\n+\t(rewrite_cross_bb_scalar_deps): Same.\n+\t* graphite.c (graphite_transform_loops): Use renamed member.\n+\n 2015-10-06  Uros Bizjak  <ubizjak@gmail.com>\n \n \tPR c/65345"}, {"sha": "4752133399f3a7f989165ed4b57945f9721f93bc", "filename": "gcc/graphite-dependences.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e4dc590c8878aaae1cdf5db6cbf84f8546b6511/gcc%2Fgraphite-dependences.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e4dc590c8878aaae1cdf5db6cbf84f8546b6511/gcc%2Fgraphite-dependences.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-dependences.c?ref=8e4dc590c8878aaae1cdf5db6cbf84f8546b6511", "patch": "@@ -79,7 +79,7 @@ scop_get_reads (scop_p scop, vec<poly_bb_p> pbbs)\n   int i, j;\n   poly_bb_p pbb;\n   poly_dr_p pdr;\n-  isl_space *space = isl_set_get_space (scop->context);\n+  isl_space *space = isl_set_get_space (scop->param_context);\n   isl_union_map *res = isl_union_map_empty (space);\n \n   FOR_EACH_VEC_ELT (pbbs, i, pbb)\n@@ -100,7 +100,7 @@ scop_get_must_writes (scop_p scop, vec<poly_bb_p> pbbs)\n   int i, j;\n   poly_bb_p pbb;\n   poly_dr_p pdr;\n-  isl_space *space = isl_set_get_space (scop->context);\n+  isl_space *space = isl_set_get_space (scop->param_context);\n   isl_union_map *res = isl_union_map_empty (space);\n \n   FOR_EACH_VEC_ELT (pbbs, i, pbb)\n@@ -121,7 +121,7 @@ scop_get_may_writes (scop_p scop, vec<poly_bb_p> pbbs)\n   int i, j;\n   poly_bb_p pbb;\n   poly_dr_p pdr;\n-  isl_space *space = isl_set_get_space (scop->context);\n+  isl_space *space = isl_set_get_space (scop->param_context);\n   isl_union_map *res = isl_union_map_empty (space);\n \n   FOR_EACH_VEC_ELT (pbbs, i, pbb)\n@@ -141,7 +141,7 @@ scop_get_original_schedule (scop_p scop, vec<poly_bb_p> pbbs)\n {\n   int i;\n   poly_bb_p pbb;\n-  isl_space *space = isl_set_get_space (scop->context);\n+  isl_space *space = isl_set_get_space (scop->param_context);\n   isl_union_map *res = isl_union_map_empty (space);\n \n   FOR_EACH_VEC_ELT (pbbs, i, pbb)\n@@ -161,7 +161,7 @@ scop_get_transformed_schedule (scop_p scop, vec<poly_bb_p> pbbs)\n {\n   int i;\n   poly_bb_p pbb;\n-  isl_space *space = isl_set_get_space (scop->context);\n+  isl_space *space = isl_set_get_space (scop->param_context);\n   isl_union_map *res = isl_union_map_empty (space);\n \n   FOR_EACH_VEC_ELT (pbbs, i, pbb)\n@@ -356,7 +356,7 @@ subtract_commutative_associative_deps (scop_p scop,\n   int i, j;\n   poly_bb_p pbb;\n   poly_dr_p pdr;\n-  isl_space *space = isl_set_get_space (scop->context);\n+  isl_space *space = isl_set_get_space (scop->param_context);\n \n   FOR_EACH_VEC_ELT (pbbs, i, pbb)\n     if (PBB_IS_REDUCTION (pbb))"}, {"sha": "43cb7ddfe3c1565b1b1c2ba6a32dc343b73c2c77", "filename": "gcc/graphite-isl-ast-to-gimple.c", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e4dc590c8878aaae1cdf5db6cbf84f8546b6511/gcc%2Fgraphite-isl-ast-to-gimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e4dc590c8878aaae1cdf5db6cbf84f8546b6511/gcc%2Fgraphite-isl-ast-to-gimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-isl-ast-to-gimple.c?ref=8e4dc590c8878aaae1cdf5db6cbf84f8546b6511", "patch": "@@ -911,12 +911,13 @@ static void\n add_parameters_to_ivs_params (scop_p scop, ivs_params &ip)\n {\n   sese region = SCOP_REGION (scop);\n-  unsigned nb_parameters = isl_set_dim (scop->context, isl_dim_param);\n+  unsigned nb_parameters = isl_set_dim (scop->param_context, isl_dim_param);\n   gcc_assert (nb_parameters == SESE_PARAMS (region).length ());\n   unsigned i;\n   for (i = 0; i < nb_parameters; i++)\n     {\n-      isl_id *tmp_id = isl_set_get_dim_id (scop->context, isl_dim_param, i);\n+      isl_id *tmp_id = isl_set_get_dim_id (scop->param_context,\n+                                           isl_dim_param, i);\n       ip[tmp_id] = SESE_PARAMS (region)[i];\n     }\n }\n@@ -927,7 +928,7 @@ add_parameters_to_ivs_params (scop_p scop, ivs_params &ip)\n static __isl_give isl_ast_build *\n generate_isl_context (scop_p scop)\n {\n-  isl_set *context_isl = isl_set_params (isl_set_copy (scop->context));\n+  isl_set *context_isl = isl_set_params (isl_set_copy (scop->param_context));\n   return isl_ast_build_from_context (context_isl);\n }\n \n@@ -985,7 +986,7 @@ generate_isl_schedule (scop_p scop)\n   int i;\n   poly_bb_p pbb;\n   isl_union_map *schedule_isl =\n-    isl_union_map_empty (isl_set_get_space (scop->context));\n+    isl_union_map_empty (isl_set_get_space (scop->param_context));\n \n   FOR_EACH_VEC_ELT (SCOP_BBS (scop), i, pbb)\n     {\n@@ -1048,7 +1049,7 @@ scop_to_isl_ast (scop_p scop, ivs_params &ip)\n   an operator (< or <=) and an expression not involving the iterator.\n   If this option is not set, then the current loop iterator may appear several\n   times in the upper bound. See the isl manual for more details.  */\n-  isl_options_set_ast_build_atomic_upper_bound (scop->ctx, true);\n+  isl_options_set_ast_build_atomic_upper_bound (scop->isl_context, true);\n \n   add_parameters_to_ivs_params (scop, ip);\n   isl_union_map *schedule_isl = generate_isl_schedule (scop);\n@@ -1155,7 +1156,7 @@ graphite_regenerate_ast_isl (scop_p scop)\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n       fprintf (dump_file, \"\\nISL AST generated by ISL: \\n\");\n-      print_isl_ast_node (dump_file, root_node, scop->ctx);\n+      print_isl_ast_node (dump_file, root_node, scop->isl_context);\n       fprintf (dump_file, \"\\n\");\n     }\n "}, {"sha": "3fe313374ad063cf8301f6995cd71ed01992f095", "filename": "gcc/graphite-optimize-isl.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e4dc590c8878aaae1cdf5db6cbf84f8546b6511/gcc%2Fgraphite-optimize-isl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e4dc590c8878aaae1cdf5db6cbf84f8546b6511/gcc%2Fgraphite-optimize-isl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-optimize-isl.c?ref=8e4dc590c8878aaae1cdf5db6cbf84f8546b6511", "patch": "@@ -55,7 +55,7 @@ scop_get_domains (scop_p scop ATTRIBUTE_UNUSED)\n {\n   int i;\n   poly_bb_p pbb;\n-  isl_space *space = isl_set_get_space (scop->context);\n+  isl_space *space = isl_set_get_space (scop->param_context);\n   isl_union_set *res = isl_union_set_empty (space);\n \n   FOR_EACH_VEC_ELT (scop->bbs, i, pbb)\n@@ -294,12 +294,12 @@ bool\n optimize_isl (scop_p scop)\n {\n #ifdef HAVE_ISL_CTX_MAX_OPERATIONS\n-  int old_max_operations = isl_ctx_get_max_operations (scop->ctx);\n+  int old_max_operations = isl_ctx_get_max_operations (scop->isl_context);\n   int max_operations = PARAM_VALUE (PARAM_MAX_ISL_OPERATIONS);\n   if (max_operations)\n-    isl_ctx_set_max_operations (scop->ctx, max_operations);\n+    isl_ctx_set_max_operations (scop->isl_context, max_operations);\n #endif\n-  isl_options_set_on_error (scop->ctx, ISL_ON_ERROR_CONTINUE);\n+  isl_options_set_on_error (scop->isl_context, ISL_ON_ERROR_CONTINUE);\n \n   isl_union_set *domain = scop_get_domains (scop);\n   isl_union_map *dependences = scop_get_dependences (scop);\n@@ -324,11 +324,11 @@ optimize_isl (scop_p scop)\n \t\t\t\t\t\tvalidity);\n #endif\n \n-  isl_options_set_schedule_max_constant_term (scop->ctx, CONSTANT_BOUND);\n-  isl_options_set_schedule_maximize_band_depth (scop->ctx, 1);\n+  isl_options_set_schedule_max_constant_term (scop->isl_context, CONSTANT_BOUND);\n+  isl_options_set_schedule_maximize_band_depth (scop->isl_context, 1);\n #ifdef HAVE_ISL_OPTIONS_SET_SCHEDULE_SERIALIZE_SCCS\n   /* ISL-0.15 or later.  */\n-  isl_options_set_schedule_serialize_sccs (scop->ctx, 1);\n+  isl_options_set_schedule_serialize_sccs (scop->isl_context, 1);\n #else\n   isl_options_set_schedule_fuse (scop->ctx, ISL_SCHEDULE_FUSE_MIN);\n #endif\n@@ -341,12 +341,12 @@ optimize_isl (scop_p scop)\n     = isl_union_set_compute_schedule (domain, validity, proximity);\n #endif\n \n-  isl_options_set_on_error (scop->ctx, ISL_ON_ERROR_ABORT);\n+  isl_options_set_on_error (scop->isl_context, ISL_ON_ERROR_ABORT);\n \n #ifdef HAVE_ISL_CTX_MAX_OPERATIONS\n-  isl_ctx_reset_operations (scop->ctx);\n-  isl_ctx_set_max_operations (scop->ctx, old_max_operations);\n-  if (!schedule || isl_ctx_last_error (scop->ctx) == isl_error_quota)\n+  isl_ctx_reset_operations (scop->isl_context);\n+  isl_ctx_set_max_operations (scop->isl_context, old_max_operations);\n+  if (!schedule || isl_ctx_last_error (scop->isl_context) == isl_error_quota)\n     {\n       if (dump_file && dump_flags)\n \tfprintf (dump_file, \"ISL timed out at %d operations\\n\","}, {"sha": "5d6a669e2d2e2bd82d7a8c7cb150c207d1f6d60a", "filename": "gcc/graphite-poly.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e4dc590c8878aaae1cdf5db6cbf84f8546b6511/gcc%2Fgraphite-poly.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e4dc590c8878aaae1cdf5db6cbf84f8546b6511/gcc%2Fgraphite-poly.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-poly.c?ref=8e4dc590c8878aaae1cdf5db6cbf84f8546b6511", "patch": "@@ -137,7 +137,7 @@ apply_poly_transforms (scop_p scop)\n \n void\n new_poly_dr (poly_bb_p pbb, int dr_base_object_set,\n-\t     enum poly_dr_type type, void *cdr, graphite_dim_t nb_subscripts,\n+\t     enum poly_dr_type type, data_reference_p cdr, graphite_dim_t nb_subscripts,\n \t     isl_map *acc, isl_set *subscript_sizes)\n {\n   static int id = 0;\n@@ -168,7 +168,7 @@ free_poly_dr (poly_dr_p pdr)\n /* Create a new polyhedral black box.  */\n \n poly_bb_p\n-new_poly_bb (scop_p scop, void *black_box)\n+new_poly_bb (scop_p scop, gimple_poly_bb_p black_box)\n {\n   poly_bb_p pbb = XNEW (struct poly_bb);\n \n@@ -325,7 +325,7 @@ new_scop (edge entry, edge exit)\n   sese region = new_sese (entry, exit);\n   scop_p scop = XNEW (struct scop);\n \n-  scop->context = NULL;\n+  scop->param_context = NULL;\n   scop->must_raw = NULL;\n   scop->may_raw = NULL;\n   scop->must_raw_no_source = NULL;\n@@ -361,7 +361,7 @@ free_scop (scop_p scop)\n \n   SCOP_BBS (scop).release ();\n \n-  isl_set_free (scop->context);\n+  isl_set_free (scop->param_context);\n   isl_union_map_free (scop->must_raw);\n   isl_union_map_free (scop->may_raw);\n   isl_union_map_free (scop->must_raw_no_source);\n@@ -620,8 +620,8 @@ print_scop_context (FILE *file, scop_p scop, int verbosity)\n   if (verbosity > 0)\n     fprintf (file, \"# Context (\\n\");\n \n-  if (scop->context)\n-    print_isl_set (file, scop->context);\n+  if (scop->param_context)\n+    print_isl_set (file, scop->param_context);\n \n   if (verbosity > 0)\n     fprintf (file, \"# )\\n\");"}, {"sha": "3618b662821cc4ec447096d2c08886f701cba2cb", "filename": "gcc/graphite-poly.h", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e4dc590c8878aaae1cdf5db6cbf84f8546b6511/gcc%2Fgraphite-poly.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e4dc590c8878aaae1cdf5db6cbf84f8546b6511/gcc%2Fgraphite-poly.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-poly.h?ref=8e4dc590c8878aaae1cdf5db6cbf84f8546b6511", "patch": "@@ -59,7 +59,7 @@ struct poly_dr\n   int nb_refs;\n \n   /* A pointer to compiler's data reference description.  */\n-  void *compiler_dr;\n+  data_reference_p compiler_dr;\n \n   /* A pointer to the PBB that contains this data reference.  */\n   poly_bb_p pbb;\n@@ -199,7 +199,7 @@ struct poly_dr\n #define PDR_BASE_OBJECT_SET(PDR) (PDR->dr_base_object_set)\n #define PDR_NB_SUBSCRIPTS(PDR) (PDR->nb_subscripts)\n \n-void new_poly_dr (poly_bb_p, int, enum poly_dr_type, void *,\n+void new_poly_dr (poly_bb_p, int, enum poly_dr_type, data_reference_p,\n \t\t  graphite_dim_t, isl_map *, isl_set *);\n void free_poly_dr (poly_dr_p);\n void debug_pdr (poly_dr_p, int);\n@@ -232,7 +232,7 @@ pdr_may_write_p (poly_dr_p pdr)\n struct poly_bb\n {\n   /* Pointer to a basic block or a statement in the compiler.  */\n-  void *black_box;\n+  gimple_poly_bb_p black_box;\n \n   /* Pointer to the SCOP containing this PBB.  */\n   scop_p scop;\n@@ -282,7 +282,7 @@ struct poly_bb\n #define PBB_DRS(PBB) (PBB->drs)\n #define PBB_IS_REDUCTION(PBB) (PBB->is_reduction)\n \n-extern poly_bb_p new_poly_bb (scop_p, void *);\n+extern poly_bb_p new_poly_bb (scop_p, gimple_poly_bb_p);\n extern void free_poly_bb (poly_bb_p);\n extern void debug_loop_vec (poly_bb_p);\n extern void print_pbb_domain (FILE *, poly_bb_p, int);\n@@ -366,7 +366,7 @@ pdr_scop (poly_dr_p pdr)\n /* Set black box of PBB to BLACKBOX.  */\n \n static inline void\n-pbb_set_black_box (poly_bb_p pbb, void *black_box)\n+pbb_set_black_box (poly_bb_p pbb, gimple_poly_bb_p black_box)\n {\n   pbb->black_box = black_box;\n }\n@@ -399,10 +399,10 @@ struct scop\n   -128 >= a >= 127\n      0 >= b >= 65,535\n      c = 2a + b  */\n-  isl_set *context;\n+  isl_set *param_context;\n \n   /* The context used internally by ISL.  */\n-  isl_ctx *ctx;\n+  isl_ctx *isl_context;\n \n   /* The original dependence relations:\n      RAW are read after write dependences,"}, {"sha": "4b04315e8a0193094392015435d2b5ea4fc1e143", "filename": "gcc/graphite-scop-detection.c", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e4dc590c8878aaae1cdf5db6cbf84f8546b6511/gcc%2Fgraphite-scop-detection.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e4dc590c8878aaae1cdf5db6cbf84f8546b6511/gcc%2Fgraphite-scop-detection.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-scop-detection.c?ref=8e4dc590c8878aaae1cdf5db6cbf84f8546b6511", "patch": "@@ -1610,17 +1610,15 @@ void\n scop_detection::build_scop_bbs_1 (scop_p scop, sbitmap visited, basic_block bb)\n {\n   sese region = SCOP_REGION (scop);\n-  vec<basic_block> dom;\n-  poly_bb_p pbb;\n \n   if (bitmap_bit_p (visited, bb->index) || !bb_in_sese_p (bb, region))\n     return;\n \n-  pbb = new_poly_bb (scop, try_generate_gimple_bb (scop, bb));\n+  poly_bb_p pbb = new_poly_bb (scop, try_generate_gimple_bb (scop, bb));\n   SCOP_BBS (scop).safe_push (pbb);\n   bitmap_set_bit (visited, bb->index);\n \n-  dom = get_dominated_by (CDI_DOMINATORS, bb);\n+  vec<basic_block> dom = get_dominated_by (CDI_DOMINATORS, bb);\n \n   if (!dom.exists ())\n     return;\n@@ -1781,18 +1779,16 @@ scan_tree_for_params (sese s, tree e)\n static void\n find_params_in_bb (sese region, gimple_poly_bb_p gbb)\n {\n+  /* Find parameters in the access functions of data references.  */\n   int i;\n-  unsigned j;\n   data_reference_p dr;\n-  gimple *stmt;\n-  loop_p loop = GBB_BB (gbb)->loop_father;\n-\n-  /* Find parameters in the access functions of data references.  */\n   FOR_EACH_VEC_ELT (GBB_DATA_REFS (gbb), i, dr)\n-    for (j = 0; j < DR_NUM_DIMENSIONS (dr); j++)\n+    for (unsigned j = 0; j < DR_NUM_DIMENSIONS (dr); j++)\n       scan_tree_for_params (region, DR_ACCESS_FN (dr, j));\n \n   /* Find parameters in conditional statements.  */\n+  gimple *stmt;\n+  loop_p loop = GBB_BB (gbb)->loop_father;\n   FOR_EACH_VEC_ELT (GBB_CONDITIONS (gbb), i, stmt)\n     {\n       tree lhs = scalar_evolution_in_region (region, loop,\n@@ -1811,11 +1807,9 @@ find_params_in_bb (sese region, gimple_poly_bb_p gbb)\n static void\n find_scop_parameters (scop_p scop)\n {\n-  poly_bb_p pbb;\n   unsigned i;\n   sese region = SCOP_REGION (scop);\n   struct loop *loop;\n-  int nbp;\n \n   /* Find the parameters used in the loop bounds.  */\n   FOR_EACH_VEC_ELT (SESE_LOOP_NEST (region), i, loop)\n@@ -1830,10 +1824,11 @@ find_scop_parameters (scop_p scop)\n     }\n \n   /* Find the parameters used in data accesses.  */\n+  poly_bb_p pbb;\n   FOR_EACH_VEC_ELT (SCOP_BBS (scop), i, pbb)\n     find_params_in_bb (region, PBB_BLACK_BOX (pbb));\n \n-  nbp = sese_nb_params (region);\n+  int nbp = sese_nb_params (region);\n   scop_set_nb_params (scop, nbp);\n   SESE_ADD_PARAMS (region) = false;\n }"}, {"sha": "15d16c1a488eb0fc717953e74592e8a3259d1738", "filename": "gcc/graphite-sese-to-poly.c", "status": "modified", "additions": 88, "deletions": 124, "changes": 212, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e4dc590c8878aaae1cdf5db6cbf84f8546b6511/gcc%2Fgraphite-sese-to-poly.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e4dc590c8878aaae1cdf5db6cbf84f8546b6511/gcc%2Fgraphite-sese-to-poly.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-sese-to-poly.c?ref=8e4dc590c8878aaae1cdf5db6cbf84f8546b6511", "patch": "@@ -68,6 +68,8 @@ extern \"C\" {\n #include \"graphite-sese-to-poly.h\"\n \n \n+static const unsigned ssa_name_version_typesize =  sizeof(unsigned);\n+\n /* Assigns to RES the value of the INTEGER_CST T.  */\n \n static inline void\n@@ -146,12 +148,10 @@ remove_invariant_phi (sese region, gphi_iterator *psi)\n static inline bool\n simple_copy_phi_p (gphi *phi)\n {\n-  tree res;\n-\n   if (gimple_phi_num_args (phi) != 2)\n     return false;\n \n-  res = gimple_phi_result (phi);\n+  tree res = gimple_phi_result (phi);\n   return (res == gimple_phi_arg_def (phi, 0)\n \t  || res == gimple_phi_arg_def (phi, 1));\n }\n@@ -201,9 +201,9 @@ reduction_phi_p (sese region, gphi_iterator *psi)\n static isl_id *\n isl_id_for_pbb (scop_p s, poly_bb_p pbb)\n {\n-  char name[50];\n+  char name[ssa_name_version_typesize];\n   snprintf (name, sizeof (name), \"S_%d\", pbb_index (pbb));\n-  return isl_id_alloc (s->ctx, name, pbb);\n+  return isl_id_alloc (s->isl_context, name, pbb);\n }\n \n /* Converts the STATIC_SCHEDULE of PBB into a scattering polyhedron.\n@@ -237,18 +237,16 @@ static void\n build_pbb_scattering_polyhedrons (isl_aff *static_sched,\n \t\t\t\t  poly_bb_p pbb)\n {\n-  int i;\n   isl_val *val;\n-  isl_space *dc, *dm;\n \n   int scattering_dimensions = isl_set_dim (pbb->domain, isl_dim_set) * 2 + 1;\n \n-  dc = isl_set_get_space (pbb->domain);\n-  dm = isl_space_add_dims (isl_space_from_domain (dc),\n-\t\t\t   isl_dim_out, scattering_dimensions);\n+  isl_space *dc = isl_set_get_space (pbb->domain);\n+  isl_space *dm = isl_space_add_dims (isl_space_from_domain (dc),\n+\t\t\t\t      isl_dim_out, scattering_dimensions);\n   pbb->schedule = isl_map_universe (dm);\n \n-  for (i = 0; i < scattering_dimensions; i++)\n+  for (int i = 0; i < scattering_dimensions; i++)\n     {\n       /* Textual order inside this loop.  */\n       if ((i % 2) == 0)\n@@ -316,10 +314,8 @@ build_pbb_scattering_polyhedrons (isl_aff *static_sched,\n static void\n build_scop_scattering (scop_p scop)\n {\n-  int i;\n-  poly_bb_p pbb;\n   gimple_poly_bb_p previous_gbb = NULL;\n-  isl_space *dc = isl_set_get_space (scop->context);\n+  isl_space *dc = isl_set_get_space (scop->param_context);\n   isl_aff *static_sched;\n \n   dc = isl_space_add_dims (dc, isl_dim_set, number_of_loops (cfun));\n@@ -331,15 +327,15 @@ build_scop_scattering (scop_p scop)\n      incremented before copying.  */\n   static_sched = isl_aff_add_coefficient_si (static_sched, isl_dim_in, 0, -1);\n \n+  int i;\n+  poly_bb_p pbb;\n   FOR_EACH_VEC_ELT (SCOP_BBS (scop), i, pbb)\n     {\n       gimple_poly_bb_p gbb = PBB_BLACK_BOX (pbb);\n-      int prefix;\n+      int prefix = 0;\n \n       if (previous_gbb)\n \tprefix = nb_common_loops (SCOP_REGION (scop), previous_gbb, gbb);\n-      else\n-\tprefix = 0;\n \n       previous_gbb = gbb;\n \n@@ -402,12 +398,12 @@ isl_id_for_ssa_name (scop_p s, tree e)\n   isl_id *id;\n \n   if (name)\n-    id = isl_id_alloc (s->ctx, name, e);\n+    id = isl_id_alloc (s->isl_context, name, e);\n   else\n     {\n-      char name1[50];\n+      char name1[ssa_name_version_typesize];\n       snprintf (name1, sizeof (name1), \"P_%d\", SSA_NAME_VERSION (e));\n-      id = isl_id_alloc (s->ctx, name1, e);\n+      id = isl_id_alloc (s->isl_context, name1, e);\n     }\n \n   return id;\n@@ -421,24 +417,19 @@ isl_id_for_dr (scop_p s, data_reference_p dr ATTRIBUTE_UNUSED)\n   /* Data references all get the same isl_id.  They need to be comparable\n      and are distinguished through the first dimension, which contains the\n      alias set number.  */\n-  return isl_id_alloc (s->ctx, \"\", 0);\n+  return isl_id_alloc (s->isl_context, \"\", 0);\n }\n \n /* Extract an affine expression from the ssa_name E.  */\n \n static isl_pw_aff *\n extract_affine_name (scop_p s, tree e, __isl_take isl_space *space)\n {\n-  isl_aff *aff;\n-  isl_set *dom;\n-  isl_id *id;\n-  int dimension;\n-\n-  id = isl_id_for_ssa_name (s, e);\n-  dimension = isl_space_find_dim_by_id (space, isl_dim_param, id);\n+  isl_id *id = isl_id_for_ssa_name (s, e);\n+  int dimension = isl_space_find_dim_by_id (space, isl_dim_param, id);\n   isl_id_free (id);\n-  dom = isl_set_universe (isl_space_copy (space));\n-  aff = isl_aff_zero_on_domain (isl_local_space_from_space (space));\n+  isl_set *dom = isl_set_universe (isl_space_copy (space));\n+  isl_aff *aff = isl_aff_zero_on_domain (isl_local_space_from_space (space));\n   aff = isl_aff_add_coefficient_si (aff, isl_dim_param, dimension, 1);\n   return isl_pw_aff_alloc (dom, aff);\n }\n@@ -451,11 +442,8 @@ extract_affine_gmp (mpz_t g, __isl_take isl_space *space)\n   isl_local_space *ls = isl_local_space_from_space (isl_space_copy (space));\n   isl_aff *aff = isl_aff_zero_on_domain (ls);\n   isl_set *dom = isl_set_universe (space);\n-  isl_val *v;\n-  isl_ctx *ct;\n-\n-  ct = isl_aff_get_ctx (aff);\n-  v = isl_val_int_from_gmp (ct, g);\n+  isl_ctx *ct = isl_aff_get_ctx (aff);\n+  isl_val *v = isl_val_int_from_gmp (ct, g);\n   aff = isl_aff_add_constant_val (aff, v);\n \n   return isl_pw_aff_alloc (dom, aff);\n@@ -466,12 +454,11 @@ extract_affine_gmp (mpz_t g, __isl_take isl_space *space)\n static isl_pw_aff *\n extract_affine_int (tree e, __isl_take isl_space *space)\n {\n-  isl_pw_aff *res;\n   mpz_t g;\n \n   mpz_init (g);\n   tree_int_to_gmp (e, g);\n-  res = extract_affine_gmp (g, space);\n+  isl_pw_aff *res = extract_affine_gmp (g, space);\n   mpz_clear (g);\n \n   return res;\n@@ -515,7 +502,6 @@ static isl_pw_aff *\n extract_affine (scop_p s, tree e, __isl_take isl_space *space)\n {\n   isl_pw_aff *lhs, *rhs, *res;\n-  tree type;\n \n   if (e == chrec_dont_know) {\n     isl_space_free (space);\n@@ -573,7 +559,7 @@ extract_affine (scop_p s, tree e, __isl_take isl_space *space)\n       break;\n     }\n \n-  type = TREE_TYPE (e);\n+  tree type = TREE_TYPE (e);\n   if (TYPE_UNSIGNED (type))\n     res = wrap (res, TYPE_PRECISION (type));\n \n@@ -587,15 +573,15 @@ set_scop_parameter_dim (scop_p scop)\n {\n   sese region = SCOP_REGION (scop);\n   unsigned nbp = sese_nb_params (region);\n-  isl_space *space = isl_space_set_alloc (scop->ctx, nbp, 0);\n+  isl_space *space = isl_space_set_alloc (scop->isl_context, nbp, 0);\n \n   unsigned i;\n   tree e;\n   FOR_EACH_VEC_ELT (SESE_PARAMS (region), i, e)\n     space = isl_space_set_dim_id (space, isl_dim_param, i,\n                                   isl_id_for_ssa_name (scop, e));\n \n-  scop->context = isl_set_universe (space);\n+  scop->param_context = isl_set_universe (space);\n }\n \n /* Builds the constraint polyhedra for LOOP in SCOP.  OUTER_PH gives\n@@ -606,23 +592,22 @@ build_loop_iteration_domains (scop_p scop, struct loop *loop,\n                               int nb,\n \t\t\t      isl_set *outer, isl_set **doms)\n {\n+\n   tree nb_iters = number_of_latch_executions (loop);\n   sese region = SCOP_REGION (scop);\n \n   isl_set *inner = isl_set_copy (outer);\n-  isl_space *space;\n-  isl_constraint *c;\n   int pos = isl_set_dim (outer, isl_dim_set);\n   isl_val *v;\n   mpz_t g;\n \n   mpz_init (g);\n \n   inner = isl_set_add_dims (inner, isl_dim_set, 1);\n-  space = isl_set_get_space (inner);\n+  isl_space *space = isl_set_get_space (inner);\n \n   /* 0 <= loop_i */\n-  c = isl_inequality_alloc\n+  isl_constraint *c = isl_inequality_alloc\n       (isl_local_space_from_space (isl_space_copy (space)));\n   c = isl_constraint_set_coefficient_si (c, isl_dim_set, pos, 1);\n   inner = isl_set_add_constraint (inner, c);\n@@ -634,36 +619,32 @@ build_loop_iteration_domains (scop_p scop, struct loop *loop,\n \t  (isl_local_space_from_space (isl_space_copy (space)));\n       c = isl_constraint_set_coefficient_si (c, isl_dim_set, pos, -1);\n       tree_int_to_gmp (nb_iters, g);\n-      v = isl_val_int_from_gmp (scop->ctx, g);\n+      v = isl_val_int_from_gmp (scop->isl_context, g);\n       c = isl_constraint_set_constant_val (c, v);\n       inner = isl_set_add_constraint (inner, c);\n     }\n \n   /* loop_i <= expr_nb_iters */\n   else if (!chrec_contains_undetermined (nb_iters))\n     {\n-      widest_int nit;\n       isl_pw_aff *aff;\n-      isl_set *valid;\n-      isl_local_space *ls;\n-      isl_aff *al;\n-      isl_set *le;\n \n       nb_iters = scalar_evolution_in_region (region, loop, nb_iters);\n \n       aff = extract_affine (scop, nb_iters, isl_set_get_space (inner));\n-      valid = isl_pw_aff_nonneg_set (isl_pw_aff_copy (aff));\n+      isl_set *valid = isl_pw_aff_nonneg_set (isl_pw_aff_copy (aff));\n       valid = isl_set_project_out (valid, isl_dim_set, 0,\n \t\t\t\t   isl_set_dim (valid, isl_dim_set));\n-      scop->context = isl_set_intersect (scop->context, valid);\n+      scop->param_context = isl_set_intersect (scop->param_context, valid);\n \n-      ls = isl_local_space_from_space (isl_space_copy (space));\n-      al = isl_aff_set_coefficient_si (isl_aff_zero_on_domain (ls),\n-\t\t\t\t       isl_dim_in, pos, 1);\n-      le = isl_pw_aff_le_set (isl_pw_aff_from_aff (al),\n-\t\t\t      isl_pw_aff_copy (aff));\n+      isl_local_space *ls = isl_local_space_from_space (isl_space_copy (space));\n+      isl_aff *al = isl_aff_set_coefficient_si (isl_aff_zero_on_domain (ls),\n+\t\t\t\t\t\tisl_dim_in, pos, 1);\n+      isl_set *le = isl_pw_aff_le_set (isl_pw_aff_from_aff (al),\n+\t\t\t\t       isl_pw_aff_copy (aff));\n       inner = isl_set_intersect (inner, le);\n \n+      widest_int nit;\n       if (max_stmt_executions (loop, &nit))\n \t{\n \t  /* Insert in the context the constraints from the\n@@ -672,24 +653,22 @@ build_loop_iteration_domains (scop_p scop, struct loop *loop,\n \t     names) NB_ITERS.  First, build the affine expression\n \t     \"NIT - NB_ITERS\" and then say that it is positive,\n \t     i.e., NIT approximates NB_ITERS: \"NIT >= NB_ITERS\".  */\n-\t  isl_pw_aff *approx;\n \t  mpz_t g;\n-\t  isl_set *x;\n-\t  isl_constraint *c;\n-\n \t  mpz_init (g);\n \t  wi::to_mpz (nit, g, SIGNED);\n \t  mpz_sub_ui (g, g, 1);\n-\t  approx = extract_affine_gmp (g, isl_set_get_space (inner));\n-\t  x = isl_pw_aff_ge_set (approx, aff);\n+\n+\t  isl_pw_aff *approx\n+\t    = extract_affine_gmp (g, isl_set_get_space (inner));\n+\t  isl_set *x = isl_pw_aff_ge_set (approx, aff);\n \t  x = isl_set_project_out (x, isl_dim_set, 0,\n \t\t\t\t   isl_set_dim (x, isl_dim_set));\n-\t  scop->context = isl_set_intersect (scop->context, x);\n+\t  scop->param_context = isl_set_intersect (scop->param_context, x);\n \n-\t  c = isl_inequality_alloc\n+\t  isl_constraint *c = isl_inequality_alloc\n \t      (isl_local_space_from_space (isl_space_copy (space)));\n \t  c = isl_constraint_set_coefficient_si (c, isl_dim_set, pos, -1);\n-\t  v = isl_val_int_from_gmp (scop->ctx, g);\n+\t  v = isl_val_int_from_gmp (scop->isl_context, g);\n \t  mpz_clear (g);\n \t  c = isl_constraint_set_constant_val (c, v);\n \t  inner = isl_set_add_constraint (inner, c);\n@@ -855,26 +834,26 @@ add_param_constraints (scop_p scop, graphite_dim_t p)\n \n   if (lb)\n     {\n-      isl_space *space = isl_set_get_space (scop->context);\n+      isl_space *space = isl_set_get_space (scop->param_context);\n       isl_constraint *c;\n       mpz_t g;\n       isl_val *v;\n \n       c = isl_inequality_alloc (isl_local_space_from_space (space));\n       mpz_init (g);\n       tree_int_to_gmp (lb, g);\n-      v = isl_val_int_from_gmp (scop->ctx, g);\n+      v = isl_val_int_from_gmp (scop->isl_context, g);\n       v = isl_val_neg (v);\n       mpz_clear (g);\n       c = isl_constraint_set_constant_val (c, v);\n       c = isl_constraint_set_coefficient_si (c, isl_dim_param, p, 1);\n \n-      scop->context = isl_set_add_constraint (scop->context, c);\n+      scop->param_context = isl_set_add_constraint (scop->param_context, c);\n     }\n \n   if (ub)\n     {\n-      isl_space *space = isl_set_get_space (scop->context);\n+      isl_space *space = isl_set_get_space (scop->param_context);\n       isl_constraint *c;\n       mpz_t g;\n       isl_val *v;\n@@ -883,12 +862,12 @@ add_param_constraints (scop_p scop, graphite_dim_t p)\n \n       mpz_init (g);\n       tree_int_to_gmp (ub, g);\n-      v = isl_val_int_from_gmp (scop->ctx, g);\n+      v = isl_val_int_from_gmp (scop->isl_context, g);\n       mpz_clear (g);\n       c = isl_constraint_set_constant_val (c, v);\n       c = isl_constraint_set_coefficient_si (c, isl_dim_param, p, -1);\n \n-      scop->context = isl_set_add_constraint (scop->context, c);\n+      scop->param_context = isl_set_add_constraint (scop->param_context, c);\n     }\n }\n \n@@ -912,32 +891,32 @@ build_scop_context (scop_p scop)\n static void\n build_scop_iteration_domain (scop_p scop)\n {\n-  struct loop *loop;\n   sese region = SCOP_REGION (scop);\n-  int i;\n-  poly_bb_p pbb;\n   int nb_loops = number_of_loops (cfun);\n   isl_set **doms = XCNEWVEC (isl_set *, nb_loops);\n \n+  int i;\n+  struct loop *loop;\n   FOR_EACH_VEC_ELT (SESE_LOOP_NEST (region), i, loop)\n     if (!loop_in_sese_p (loop_outer (loop), region))\n       build_loop_iteration_domains (scop, loop, 0,\n-\t\t\t\t    isl_set_copy (scop->context), doms);\n+\t\t\t\t    isl_set_copy (scop->param_context), doms);\n \n+  poly_bb_p pbb;\n   FOR_EACH_VEC_ELT (SCOP_BBS (scop), i, pbb)\n     {\n       loop = pbb_loop (pbb);\n \n       if (doms[loop->num])\n \tpbb->domain = isl_set_copy (doms[loop->num]);\n       else\n-\tpbb->domain = isl_set_copy (scop->context);\n+\tpbb->domain = isl_set_copy (scop->param_context);\n \n       pbb->domain = isl_set_set_tuple_id (pbb->domain,\n \t\t\t\t\t  isl_id_for_pbb (scop, pbb));\n     }\n \n-  for (i = 0; i < nb_loops; i++)\n+  for (int i = 0; i < nb_loops; i++)\n     if (doms[i])\n       isl_set_free (doms[i]);\n \n@@ -1058,7 +1037,7 @@ pdr_add_data_dimensions (isl_set *subscript_sizes, scop_p scop,\n \t  valid = isl_pw_aff_nonneg_set (isl_pw_aff_copy (ub));\n \t  valid = isl_set_project_out (valid, isl_dim_set, 0,\n \t\t\t\t       isl_set_dim (valid, isl_dim_set));\n-\t  scop->context = isl_set_intersect (scop->context, valid);\n+\t  scop->param_context = isl_set_intersect (scop->param_context, valid);\n \n \t  aff = isl_aff_zero_on_domain (isl_local_space_from_space (space));\n \t  aff = isl_aff_add_coefficient_si (aff, isl_dim_in, i + 1, 1);\n@@ -1106,7 +1085,7 @@ build_poly_dr (data_reference_p dr, poly_bb_p pbb)\n   {\n     isl_id *id = isl_id_for_dr (scop, dr);\n     int nb = 1 + DR_NUM_DIMENSIONS (dr);\n-    isl_space *space = isl_space_set_alloc (scop->ctx, 0, nb);\n+    isl_space *space = isl_space_set_alloc (scop->isl_context, 0, nb);\n     int alias_set_num = 0;\n     base_alias_pair *bap = (base_alias_pair *)(dr->aux);\n \n@@ -1411,8 +1390,6 @@ build_scop_drs (scop_p scop)\n {\n   int i, j;\n   poly_bb_p pbb;\n-  data_reference_p dr;\n-  auto_vec<data_reference_p, 3> drs;\n \n   /* Remove all the PBBs that do not have data references: these basic\n      blocks are not handled in the polyhedral representation.  */\n@@ -1425,6 +1402,8 @@ build_scop_drs (scop_p scop)\n \ti--;\n       }\n \n+  data_reference_p dr;\n+  auto_vec<data_reference_p, 3> drs;\n   FOR_EACH_VEC_ELT (SCOP_BBS (scop), i, pbb)\n     for (j = 0; GBB_DATA_REFS (PBB_BLACK_BOX (pbb)).iterate (j, &dr); j++)\n       drs.safe_push (dr);\n@@ -1457,23 +1436,19 @@ build_scop_drs (scop_p scop)\n static void\n analyze_drs_in_stmts (scop_p scop, basic_block bb, vec<gimple *> stmts)\n {\n-  loop_p nest;\n-  gimple_poly_bb_p gbb;\n-  gimple *stmt;\n-  int i;\n   sese region = SCOP_REGION (scop);\n-\n   if (!bb_in_sese_p (bb, region))\n     return;\n \n-  nest = outermost_loop_in_sese (region, bb);\n-\n+  loop_p nest = outermost_loop_in_sese (region, bb);\n   loop_p loop = bb->loop_father;\n   if (!loop_in_sese_p (loop, region))\n     loop = nest;\n \n-  gbb = gbb_from_bb (bb);\n+  gimple_poly_bb_p gbb = gbb_from_bb (bb);\n \n+  gimple *stmt;\n+  int i;\n   FOR_EACH_VEC_ELT (stmts, i, stmt)\n     {\n       if (is_gimple_debug (stmt))\n@@ -1508,13 +1483,14 @@ insert_stmts (scop_p scop, gimple *stmt, gimple_seq stmts,\n static void\n insert_out_of_ssa_copy (scop_p scop, tree res, tree expr, gimple *after_stmt)\n {\n-  gimple_seq stmts;\n   gimple_stmt_iterator gsi;\n+  auto_vec<gimple *, 3> x;\n+  gimple_seq stmts;\n   tree var = force_gimple_operand (expr, &stmts, true, NULL_TREE);\n   gassign *stmt = gimple_build_assign (unshare_expr (res), var);\n-  auto_vec<gimple *, 3> x;\n \n   gimple_seq_add_stmt (&stmts, stmt);\n+\n   for (gsi = gsi_start (stmts); !gsi_end_p (gsi); gsi_next (&gsi))\n     x.safe_push (gsi_stmt (gsi));\n \n@@ -1564,20 +1540,19 @@ new_pbb_from_pbb (scop_p scop, poly_bb_p pbb, basic_block bb)\n static void\n insert_out_of_ssa_copy_on_edge (scop_p scop, edge e, tree res, tree expr)\n {\n-  gimple_stmt_iterator gsi;\n   gimple_seq stmts = NULL;\n   tree var = force_gimple_operand (expr, &stmts, true, NULL_TREE);\n   gimple *stmt = gimple_build_assign (unshare_expr (res), var);\n-  basic_block bb;\n   auto_vec<gimple *, 3> x;\n \n   gimple_seq_add_stmt (&stmts, stmt);\n+  gimple_stmt_iterator gsi;\n   for (gsi = gsi_start (stmts); !gsi_end_p (gsi); gsi_next (&gsi))\n     x.safe_push (gsi_stmt (gsi));\n \n   gsi_insert_seq_on_edge (e, stmts);\n   gsi_commit_edge_inserts ();\n-  bb = gimple_bb (stmt);\n+  basic_block bb = gimple_bb (stmt);\n \n   if (!bb_in_sese_p (bb, SCOP_REGION (scop)))\n     return;\n@@ -1623,8 +1598,6 @@ scalar_close_phi_node_p (gimple *phi)\n static void\n propagate_expr_outside_region (tree def, tree expr, sese region)\n {\n-  imm_use_iterator imm_iter;\n-  gimple *use_stmt;\n   gimple_seq stmts;\n   bool replaced_once = false;\n \n@@ -1633,6 +1606,8 @@ propagate_expr_outside_region (tree def, tree expr, sese region)\n   expr = force_gimple_operand (unshare_expr (expr), &stmts, true,\n \t\t\t       NULL_TREE);\n \n+  imm_use_iterator imm_iter;\n+  gimple *use_stmt;\n   FOR_EACH_IMM_USE_STMT (use_stmt, imm_iter, def)\n     if (!is_gimple_debug (use_stmt)\n \t&& !bb_in_sese_p (gimple_bb (use_stmt), region))\n@@ -1742,14 +1717,12 @@ rewrite_close_phi_out_of_ssa (scop_p scop, gimple_stmt_iterator *psi)\n static void\n rewrite_phi_out_of_ssa (scop_p scop, gphi_iterator *psi)\n {\n-  size_t i;\n   gphi *phi = psi->phi ();\n   basic_block bb = gimple_bb (phi);\n   tree res = gimple_phi_result (phi);\n   tree zero_dim_array = create_zero_dim_array (res, \"phi_out_of_ssa\");\n-  gimple *stmt;\n \n-  for (i = 0; i < gimple_phi_num_args (phi); i++)\n+  for (size_t i = 0; i < gimple_phi_num_args (phi); i++)\n     {\n       tree arg = gimple_phi_arg_def (phi, i);\n       edge e = gimple_phi_arg_edge (phi, i);\n@@ -1765,7 +1738,7 @@ rewrite_phi_out_of_ssa (scop_p scop, gphi_iterator *psi)\n \tinsert_out_of_ssa_copy_on_edge (scop, e, zero_dim_array, arg);\n     }\n \n-  stmt = gimple_build_assign (res, unshare_expr (zero_dim_array));\n+  gimple *stmt = gimple_build_assign (res, unshare_expr (zero_dim_array));\n   remove_phi_node (psi, false);\n   insert_stmts (scop, stmt, NULL, gsi_after_labels (bb));\n }\n@@ -1776,21 +1749,17 @@ rewrite_phi_out_of_ssa (scop_p scop, gphi_iterator *psi)\n static void\n rewrite_degenerate_phi (gphi_iterator *psi)\n {\n-  tree rhs;\n-  gimple *stmt;\n-  gimple_stmt_iterator gsi;\n   gphi *phi = psi->phi ();\n   tree res = gimple_phi_result (phi);\n-  basic_block bb;\n \n-  bb = gimple_bb (phi);\n-  rhs = degenerate_phi_result (phi);\n+  basic_block bb = gimple_bb (phi);\n+  tree rhs = degenerate_phi_result (phi);\n   gcc_assert (rhs);\n \n-  stmt = gimple_build_assign (res, rhs);\n+  gimple *stmt = gimple_build_assign (res, rhs);\n   remove_phi_node (psi, false);\n \n-  gsi = gsi_after_labels (bb);\n+  gimple_stmt_iterator gsi = gsi_after_labels (bb);\n   gsi_insert_before (&gsi, stmt, GSI_NEW_STMT);\n }\n \n@@ -1800,12 +1769,11 @@ static void\n rewrite_reductions_out_of_ssa (scop_p scop)\n {\n   basic_block bb;\n-  gphi_iterator psi;\n   sese region = SCOP_REGION (scop);\n \n   FOR_EACH_BB_FN (bb, cfun)\n     if (bb_in_sese_p (bb, region))\n-      for (psi = gsi_start_phis (bb); !gsi_end_p (psi);)\n+      for (gphi_iterator psi = gsi_start_phis (bb); !gsi_end_p (psi);)\n \t{\n \t  gphi *phi = psi.phi ();\n \n@@ -1839,19 +1807,16 @@ static void\n rewrite_cross_bb_scalar_dependence (scop_p scop, tree zero_dim_array,\n \t\t\t\t    tree def, gimple *use_stmt)\n {\n-  gimple *name_stmt;\n-  tree name;\n-  ssa_op_iter iter;\n-  use_operand_p use_p;\n-\n   gcc_assert (gimple_code (use_stmt) != GIMPLE_PHI);\n \n-  name = copy_ssa_name (def);\n-  name_stmt = gimple_build_assign (name, zero_dim_array);\n+  tree name = copy_ssa_name (def);\n+  gimple *name_stmt = gimple_build_assign (name, zero_dim_array);\n \n   gimple_assign_set_lhs (name_stmt, name);\n   insert_stmts (scop, name_stmt, NULL, gsi_for_stmt (use_stmt));\n \n+  ssa_op_iter iter;\n+  use_operand_p use_p;\n   FOR_EACH_SSA_USE_OPERAND (use_p, use_stmt, iter, SSA_OP_ALL_USES)\n     if (operand_equal_p (def, USE_FROM_PTR (use_p), 0))\n       replace_exp (use_p, name);\n@@ -1869,15 +1834,15 @@ handle_scalar_deps_crossing_scop_limits (scop_p scop, tree def, gimple *stmt)\n   tree var = create_tmp_reg (TREE_TYPE (def));\n   tree new_name = make_ssa_name (var, stmt);\n   bool needs_copy = false;\n-  use_operand_p use_p;\n-  imm_use_iterator imm_iter;\n-  gimple *use_stmt;\n   sese region = SCOP_REGION (scop);\n \n+  imm_use_iterator imm_iter;\n+  gimple *use_stmt;\n   FOR_EACH_IMM_USE_STMT (use_stmt, imm_iter, def)\n     {\n       if (!bb_in_sese_p (gimple_bb (use_stmt), region))\n \t{\n+\t  use_operand_p use_p;\n \t  FOR_EACH_IMM_USE_ON_STMT (use_p, imm_iter)\n \t    {\n \t      SET_USE (use_p, new_name);\n@@ -1911,7 +1876,6 @@ rewrite_cross_bb_scalar_deps (scop_p scop, gimple_stmt_iterator *gsi)\n   gimple *stmt = gsi_stmt (*gsi);\n   imm_use_iterator imm_iter;\n   tree def;\n-  basic_block def_bb;\n   tree zero_dim_array = NULL_TREE;\n   gimple *use_stmt;\n   bool res = false;\n@@ -1946,7 +1910,7 @@ rewrite_cross_bb_scalar_deps (scop_p scop, gimple_stmt_iterator *gsi)\n       return true;\n     }\n \n-  def_bb = gimple_bb (stmt);\n+  basic_block def_bb = gimple_bb (stmt);\n \n   handle_scalar_deps_crossing_scop_limits (scop, def, stmt);\n "}, {"sha": "3d02b8f1f1b8bd1a0929d053200cc96e74b45d25", "filename": "gcc/graphite.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e4dc590c8878aaae1cdf5db6cbf84f8546b6511/gcc%2Fgraphite.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e4dc590c8878aaae1cdf5db6cbf84f8546b6511/gcc%2Fgraphite.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite.c?ref=8e4dc590c8878aaae1cdf5db6cbf84f8546b6511", "patch": "@@ -328,7 +328,7 @@ graphite_transform_loops (void)\n   FOR_EACH_VEC_ELT (scops, i, scop)\n     if (dbg_cnt (graphite_scop))\n       {\n-\tscop->ctx = ctx;\n+\tscop->isl_context = ctx;\n \tbuild_poly_scop (scop);\n \n \tif (dump_file && dump_flags)"}]}