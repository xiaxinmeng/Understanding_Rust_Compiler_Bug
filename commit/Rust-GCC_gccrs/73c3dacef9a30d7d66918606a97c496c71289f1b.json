{"sha": "73c3dacef9a30d7d66918606a97c496c71289f1b", "node_id": "C_kwDOANBUbNoAKDczYzNkYWNlZjlhMzBkN2Q2NjkxODYwNmE5N2M0OTZjNzEyODlmMWI", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2021-12-15T12:19:00Z"}, "committer": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2021-12-15T12:19:00Z"}, "message": "aarch64: Don't classify vector pairs as short vectors [PR103094]\n\nIn this PR we were wrongly classifying a pair of 8-byte vectors\nas a 16-byte \u201cshort vector\u201d (in the AAPCS64 sense).  As the\ncomment in the patch says, this stems from an old condition\nin aarch64_short_vector_p that is too loose, but that would\nbe difficult to tighten now.\n\nWe can still do the right thing for the newly-added modes though,\nsince there are no backwards compatibility concerns there.\n\nCo-authored-by: Tamar Christina <tamar.christina@arm.com>\n\ngcc/\n\tPR target/103094\n\t* config/aarch64/aarch64.c (aarch64_short_vector_p): Return false\n\tfor structure modes, rather than ignoring the type in that case.\n\ngcc/testsuite/\n\tPR target/103094\n\t* gcc.target/aarch64/pr103094.c: New test.", "tree": {"sha": "10eb66864a051e17c90aae0821ff6d8a55085bbd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/10eb66864a051e17c90aae0821ff6d8a55085bbd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/73c3dacef9a30d7d66918606a97c496c71289f1b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73c3dacef9a30d7d66918606a97c496c71289f1b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/73c3dacef9a30d7d66918606a97c496c71289f1b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73c3dacef9a30d7d66918606a97c496c71289f1b/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7527ddecef4721b3f4b00e8ad22d390b457c310b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7527ddecef4721b3f4b00e8ad22d390b457c310b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7527ddecef4721b3f4b00e8ad22d390b457c310b"}], "stats": {"total": 41, "additions": 39, "deletions": 2}, "files": [{"sha": "ff4a808629bd382c7cefa9ba1d2917a5894245d6", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73c3dacef9a30d7d66918606a97c496c71289f1b/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73c3dacef9a30d7d66918606a97c496c71289f1b/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=73c3dacef9a30d7d66918606a97c496c71289f1b", "patch": "@@ -19299,7 +19299,21 @@ aarch64_short_vector_p (const_tree type,\n   else if (GET_MODE_CLASS (mode) == MODE_VECTOR_INT\n \t   || GET_MODE_CLASS (mode) == MODE_VECTOR_FLOAT)\n     {\n-      /* Rely only on the type, not the mode, when processing SVE types.  */\n+      /* The containing \"else if\" is too loose: it means that we look at TYPE\n+\t if the type is a vector type (good), but that we otherwise ignore TYPE\n+\t and look only at the mode.  This is wrong because the type describes\n+\t the language-level information whereas the mode is purely an internal\n+\t GCC concept.  We can therefore reach here for types that are not\n+\t vectors in the AAPCS64 sense.\n+\n+\t We can't \"fix\" that for the traditional Advanced SIMD vector modes\n+\t without breaking backwards compatibility.  However, there's no such\n+\t baggage for the structure modes, which were introduced in GCC 12.  */\n+      if (aarch64_advsimd_struct_mode_p (mode))\n+\treturn false;\n+\n+      /* For similar reasons, rely only on the type, not the mode, when\n+\t processing SVE types.  */\n       if (type && aarch64_some_values_include_pst_objects_p (type))\n \t/* Leave later code to report an error if SVE is disabled.  */\n \tgcc_assert (!TARGET_SVE || aarch64_sve_mode_p (mode));\n@@ -19310,7 +19324,8 @@ aarch64_short_vector_p (const_tree type,\n     {\n       /* 64-bit and 128-bit vectors should only acquire an SVE mode if\n \t they are being treated as scalable AAPCS64 types.  */\n-      gcc_assert (!aarch64_sve_mode_p (mode));\n+      gcc_assert (!aarch64_sve_mode_p (mode)\n+\t\t  && !aarch64_advsimd_struct_mode_p (mode));\n       return true;\n     }\n   return false;"}, {"sha": "beda99dc1f6fc91b73111ef6824023a5feac317e", "filename": "gcc/testsuite/gcc.target/aarch64/pr103094.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73c3dacef9a30d7d66918606a97c496c71289f1b/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fpr103094.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73c3dacef9a30d7d66918606a97c496c71289f1b/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fpr103094.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fpr103094.c?ref=73c3dacef9a30d7d66918606a97c496c71289f1b", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-fdump-rtl-expand -w\" } */\n+\n+#include <arm_neon.h>\n+\n+void foo (uint8x8x2_t cols_01_23, uint8x8x2_t cols_45_67, uint16_t*\n+outptr0) {\n+  uint16x4x4_t cols_01_23_45_67 = { {\n+    vreinterpret_u16_u8(cols_01_23.val[0]),\n+    vreinterpret_u16_u8(cols_01_23.val[1]),\n+    vreinterpret_u16_u8(cols_45_67.val[0]),\n+    vreinterpret_u16_u8(cols_45_67.val[1])\n+  } };\n+\n+  vst4_lane_u16(outptr0, cols_01_23_45_67, 0); }\n+\n+/* Check that we expand to v0 and v2 from the function arguments.  */\n+/* { dg-final { scan-rtl-dump {\\(reg:V2x8QI \\d+ v0 \\[ cols_01_23\n+\\]\\)} expand } } */\n+/* { dg-final { scan-rtl-dump {\\(reg:V2x8QI \\d+ v2 \\[ cols_45_67\n+\\]\\)} expand } } */\n+"}]}