{"sha": "79c7de844ccc9f50c3e5ebdee6fd0afd409e2f0d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzljN2RlODQ0Y2NjOWY1MGMzZTVlYmRlZTZmZDBhZmQ0MDllMmYwZA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2014-02-10T11:15:38Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2014-02-10T11:15:38Z"}, "message": "ipa-devirt.c (get_polymorphic_call_info_from_invariant): Return proper constants and fix formatting.\n\n\t* ipa-devirt.c (get_polymorphic_call_info_from_invariant): Return\n\tproper constants and fix formatting.\n\t(possible_polymorphic_call_targets): Fix formatting.\n\nFrom-SVN: r207653", "tree": {"sha": "812d405048539d60be09437b713c1ba4da8f794e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/812d405048539d60be09437b713c1ba4da8f794e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/79c7de844ccc9f50c3e5ebdee6fd0afd409e2f0d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79c7de844ccc9f50c3e5ebdee6fd0afd409e2f0d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/79c7de844ccc9f50c3e5ebdee6fd0afd409e2f0d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79c7de844ccc9f50c3e5ebdee6fd0afd409e2f0d/comments", "author": null, "committer": null, "parents": [{"sha": "04ea60cbe629648f8c9c0c4f5af682e8b53e51c1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/04ea60cbe629648f8c9c0c4f5af682e8b53e51c1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/04ea60cbe629648f8c9c0c4f5af682e8b53e51c1"}], "stats": {"total": 42, "additions": 23, "deletions": 19}, "files": [{"sha": "67d7c4bf3d5f10c79adab1ece6dac960f347c703", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79c7de844ccc9f50c3e5ebdee6fd0afd409e2f0d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79c7de844ccc9f50c3e5ebdee6fd0afd409e2f0d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=79c7de844ccc9f50c3e5ebdee6fd0afd409e2f0d", "patch": "@@ -1,3 +1,9 @@\n+2014-02-10  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* ipa-devirt.c (get_polymorphic_call_info_from_invariant): Return\n+\tproper constants and fix formatting.\n+\t(possible_polymorphic_call_targets): Fix formatting.\n+\n 2014-02-10  Kirill Yukhin  <kirill.yukhin@intel.com>\n \t    Ilya Tocar  <ilya.tocar@intel.com>\n "}, {"sha": "f1e447f13f3e21db3622c7e5a9887546d0598b64", "filename": "gcc/ipa-devirt.c", "status": "modified", "additions": 17, "deletions": 19, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79c7de844ccc9f50c3e5ebdee6fd0afd409e2f0d/gcc%2Fipa-devirt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79c7de844ccc9f50c3e5ebdee6fd0afd409e2f0d/gcc%2Fipa-devirt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-devirt.c?ref=79c7de844ccc9f50c3e5ebdee6fd0afd409e2f0d", "patch": "@@ -1102,23 +1102,19 @@ get_polymorphic_call_info_from_invariant (ipa_polymorphic_call_context *context,\n   tree base;\n \n   if (TREE_CODE (cst) != ADDR_EXPR)\n-    return NULL_TREE;\n+    return false;\n \n   cst = TREE_OPERAND (cst, 0);\n   base = get_ref_base_and_extent (cst, &offset2, &size, &max_size);\n-  if (!DECL_P (base)\n-      || max_size == -1\n-      || max_size != size)\n-    return NULL_TREE;\n+  if (!DECL_P (base) || max_size == -1 || max_size != size)\n+    return false;\n \n   /* Only type inconsistent programs can have otr_type that is\n      not part of outer type.  */\n-  if (!contains_type_p (TREE_TYPE (base),\n-\t\t\toffset, otr_type))\n-    return NULL_TREE;\n+  if (!contains_type_p (TREE_TYPE (base), offset, otr_type))\n+    return false;\n \n-  get_polymorphic_call_info_for_decl (context,\n-\t\t\t\t     base, offset);\n+  get_polymorphic_call_info_for_decl (context, base, offset);\n   return true;\n }\n \n@@ -1383,20 +1379,20 @@ possible_polymorphic_call_targets (tree otr_type,\n   tree binfo, target;\n   bool final;\n \n-  if (!odr_hash.is_created ())                                                                                                                    \n-    {                                                                                                                                             \n-      if (completep)                                                                                                                              \n-\t*completep = false;                                                                                                                        \n-      return nodes;                                                                                                                               \n-    }                                                                                                                                             \n+  if (!odr_hash.is_created ())\n+    {\n+      if (completep)\n+\t*completep = false;\n+      return nodes;\n+    }\n \n   type = get_odr_type (otr_type, true);\n \n   /* Lookup the outer class type we want to walk.  */\n   if (context.outer_type)\n     get_class_context (&context, otr_type);\n \n-  /* We now canonicalize our query, so we do not need extra hashtable entries.  */\n+  /* We canonicalize our query, so we do not need extra hashtable entries.  */\n \n   /* Without outer type, we have no use for offset.  Just do the\n      basic search from innter type  */\n@@ -1457,7 +1453,6 @@ possible_polymorphic_call_targets (tree otr_type,\n   matched_vtables = pointer_set_create ();\n \n   /* First see virtual method of type itself.  */\n-\n   binfo = get_binfo_at_offset (TYPE_BINFO (outer_type->type),\n \t\t\t       context.offset, otr_type);\n   target = gimple_get_virt_method_for_binfo (otr_token, binfo);\n@@ -1474,6 +1469,7 @@ possible_polymorphic_call_targets (tree otr_type,\n      is that it has been fully optimized out.  */\n   else if (flag_ltrans || !type->anonymous_namespace)\n     final = false;\n+\n   pointer_set_insert (matched_vtables, BINFO_VTABLE (binfo));\n \n   /* Next walk bases, if asked to.  */\n@@ -1492,10 +1488,12 @@ possible_polymorphic_call_targets (tree otr_type,\n       for (i = 0; i < outer_type->derived_types.length(); i++)\n \tpossible_polymorphic_call_targets_1 (nodes, inserted,\n \t\t\t\t\t     matched_vtables,\n-\t\t\t\t\t     otr_type, outer_type->derived_types[i],\n+\t\t\t\t\t     otr_type,\n+\t\t\t\t\t     outer_type->derived_types[i],\n \t\t\t\t\t     otr_token, outer_type->type,\n \t\t\t\t\t     context.offset);\n     }\n+\n   (*slot)->targets = nodes;\n   (*slot)->final = final;\n   if (completep)"}]}