{"sha": "f57fc998eeab27e8292de128b37c94ffa37d8409", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjU3ZmM5OThlZWFiMjdlODI5MmRlMTI4YjM3Yzk0ZmZhMzdkODQwOQ==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2004-01-16T01:27:38Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2004-01-16T01:27:38Z"}, "message": "ia64.md (*movti_internal): C output template extracted to ia64.c.\n\n\t* config/ia64/ia64.md (*movti_internal): C output template\n\textracted to ia64.c.\n\t(*movti_internal_reg): Delete.\n\t(reload_inti, reload_outti): Use the correct mode on operand 2\n\tin the first place, don't fix it up in the output template.\n\t(movtf, reload_ointf, reload_outtf): New expanders.\n\t(*movtf_internal): New define_insn_and_split.\n\t* config/ia64/ia64.c (ia64_split_timode): Rename to ia64_split_tmode;\n\tmake static; do not hand TFmode CONST_DOUBLEs to split_double.\n\t(ia64_split_tmode_move): New function, body mostly pulled\n\tfrom ia64.md:*movti_internal.\n\t(ia64_function_arg_words): New function, extracted common\n\tlogic from ia64_function_arg et seq.\n\t(ia64_function_arg_offset): Likewise.  Handle correctly the\n\tcase of a scalar quantity 16 bytes wide with only 8-byte alignment.\n\t(ia64_function_arg, ia64_function_arg_partial_nregs)\n\t(ia64_function_arg_advance): Use ia64_function_arg_words and\n\tia64_function_arg_offset.\n\t(ia64_function_value): TCmode does not go in float regs.\n\t(ia64_secondary_reload_class): Also handle TFmode.\n\t* config/ia64/ia64-protos.h: Remove prototype for\n\tia64_split_timode; add prototype for ia64_split_tmode_move.\n\nFrom-SVN: r75956", "tree": {"sha": "8c8acf6e85b0ef4b2cdeb4d1ce751bdf47265a9a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8c8acf6e85b0ef4b2cdeb4d1ce751bdf47265a9a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f57fc998eeab27e8292de128b37c94ffa37d8409", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f57fc998eeab27e8292de128b37c94ffa37d8409", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f57fc998eeab27e8292de128b37c94ffa37d8409", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f57fc998eeab27e8292de128b37c94ffa37d8409/comments", "author": null, "committer": null, "parents": [{"sha": "16a9a2803f9e25933a2ca2bc28590464b1f42c9f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16a9a2803f9e25933a2ca2bc28590464b1f42c9f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/16a9a2803f9e25933a2ca2bc28590464b1f42c9f"}], "stats": {"total": 348, "additions": 211, "deletions": 137}, "files": [{"sha": "4a2e9aaea12480437774f08137cfe13d4a81ff62", "filename": "gcc/ChangeLog", "status": "modified", "additions": 32, "deletions": 7, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f57fc998eeab27e8292de128b37c94ffa37d8409/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f57fc998eeab27e8292de128b37c94ffa37d8409/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f57fc998eeab27e8292de128b37c94ffa37d8409", "patch": "@@ -1,3 +1,28 @@\n+2004-01-15  Zack Weinberg  <zack@codesourcery.com>\n+\n+\t* config/ia64/ia64.md (*movti_internal): C output template\n+\textracted to ia64.c.\n+\t(*movti_internal_reg): Delete.\n+\t(reload_inti, reload_outti): Use the correct mode on operand 2\n+\tin the first place, don't fix it up in the output template.\n+\t(movtf, reload_ointf, reload_outtf): New expanders.\n+\t(*movtf_internal): New define_insn_and_split.\n+\t* config/ia64/ia64.c (ia64_split_timode): Rename to ia64_split_tmode;\n+\tmake static; do not hand TFmode CONST_DOUBLEs to split_double.\n+\t(ia64_split_tmode_move): New function, body mostly pulled\n+\tfrom ia64.md:*movti_internal.\n+\t(ia64_function_arg_words): New function, extracted common\n+\tlogic from ia64_function_arg et seq.\n+\t(ia64_function_arg_offset): Likewise.  Handle correctly the\n+\tcase of a scalar quantity 16 bytes wide with only 8-byte alignment.\n+\t(ia64_function_arg, ia64_function_arg_partial_nregs)\n+\t(ia64_function_arg_advance): Use ia64_function_arg_words and\n+\tia64_function_arg_offset.\n+\t(ia64_function_value): TCmode does not go in float regs.\n+\t(ia64_secondary_reload_class): Also handle TFmode.\n+\t* config/ia64/ia64-protos.h: Remove prototype for\n+\tia64_split_timode; add prototype for ia64_split_tmode_move.\n+\n 2004-01-15  Kelley Cook  <kcook@gcc.gnu.org>\n \n \t* Makefile.in (MAINT): Make it an immediate assignment.\n@@ -224,7 +249,7 @@\n \n 2004-01-14  Richard Earnshaw  <rearnsha@arm.com>\n \n-\t* regrename.c (find_oldest_value_reg): If the replacement uses \n+\t* regrename.c (find_oldest_value_reg): If the replacement uses\n \tmultiple hard registers, check that all of them are in CLASS.\n \n 2004-01-14  Jan Hubicka  <jh@suse.cz>\n@@ -301,14 +326,14 @@\n 2004-01-13  Bernardo Innocenti  <bernie@develer.com>\n \n \t* config/m68k/netbsd-elf.h (REGISTER_NAMES): Add missing \"argptr\"\n-\tpseudo-register. \n+\tpseudo-register.\n \n 2004-01-13  Devang Patel <dpatel@apple.com\n \n \tPR debug/7078\n-\t* dbxout.c (dbxout_symbol_name): Emit mangled names for \n+\t* dbxout.c (dbxout_symbol_name): Emit mangled names for\n \tNAMESPACE_DECL memebers.\n-\t\n+\n 2004-01-13  Andrew Pinski  <pinskia@physics.uc.edu>\n \n \tPR c++/12709\n@@ -318,7 +343,7 @@\n 2004-01-13  Vladimir Makarov  <vmakarov@redhat.com>\n \n \t* rtl.def: Add comment about new option in automata_option.\n-\t\n+\n \t* genautomata.c (PROGRESS_OPTION): New macro.\n \t(progress_flag): New global variable.\n \t(gen_automata_option): Process `progress'.\n@@ -329,14 +354,14 @@\n \t(initiate_automaton_gen): Process command line flag `-progress'.\n \n \t* doc/md.texi: Describe the new option.\n-\t\n+\n 2004-01-13  Zdenek Dvorak  <rakdver@atrey.karlin.mff.cuni.cz>\n \n \t* cfg.c (dump_bb): Dump entry edges.\n \n 2004-01-13  Richard Earnshaw  <rearnsha@arm.com>\n \n-\t* arm.c (thumb_legitimate_address_p): Only allow constant pool \n+\t* arm.c (thumb_legitimate_address_p): Only allow constant pool\n \treferences from SImode.\n \t* arm.md (thumb_movhi_insn): Don't allow minipool references.\n "}, {"sha": "c6920fabf4d811a777fa2a0eeb60b4dea8c30195", "filename": "gcc/config/ia64/ia64-protos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f57fc998eeab27e8292de128b37c94ffa37d8409/gcc%2Fconfig%2Fia64%2Fia64-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f57fc998eeab27e8292de128b37c94ffa37d8409/gcc%2Fconfig%2Fia64%2Fia64-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64-protos.h?ref=f57fc998eeab27e8292de128b37c94ffa37d8409", "patch": "@@ -80,7 +80,7 @@ extern int ia64_move_ok (rtx, rtx);\n extern int addp4_optimize_ok (rtx, rtx);\n extern void ia64_emit_cond_move (rtx, rtx, rtx);\n extern int ia64_depz_field_mask (rtx, rtx);\n-extern rtx ia64_split_timode (rtx[], rtx, rtx);\n+extern void ia64_split_tmode_move (rtx[]);\n extern rtx spill_xfmode_operand (rtx, int);\n extern rtx ia64_expand_compare (enum rtx_code, enum machine_mode);\n extern void ia64_expand_call (rtx, rtx, rtx, int);"}, {"sha": "a0af1b4b505c46b6c9366f9b1170e8353abfc50e", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 126, "deletions": 49, "changes": 175, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f57fc998eeab27e8292de128b37c94ffa37d8409/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f57fc998eeab27e8292de128b37c94ffa37d8409/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=f57fc998eeab27e8292de128b37c94ffa37d8409", "patch": "@@ -1361,10 +1361,11 @@ ia64_emit_cond_move (rtx op0, rtx op1, rtx cond)\n \t\t\t\t\t  PATTERN (insn));\n }\n \n-/* Split a post-reload TImode reference into two DImode components.  */\n+/* Split a post-reload TImode or TFmode reference into two DImode\n+   components.  */\n \n-rtx\n-ia64_split_timode (rtx out[2], rtx in, rtx scratch)\n+static rtx\n+ia64_split_tmode (rtx out[2], rtx in, rtx scratch)\n {\n   switch (GET_CODE (in))\n     {\n@@ -1417,14 +1418,79 @@ ia64_split_timode (rtx out[2], rtx in, rtx scratch)\n \n     case CONST_INT:\n     case CONST_DOUBLE:\n-      split_double (in, &out[0], &out[1]);\n+      if (GET_MODE (in) != TFmode)\n+\tsplit_double (in, &out[0], &out[1]);\n+      else\n+\t/* split_double does not understand how to split a TFmode\n+\t   quantity into a pair of DImode constants.  */\n+\t{\n+\t  REAL_VALUE_TYPE r;\n+\t  unsigned HOST_WIDE_INT p[2];\n+\t  long l[4];  /* TFmode is 128 bits */\n+\n+\t  REAL_VALUE_FROM_CONST_DOUBLE (r, in);\n+\t  real_to_target (l, &r, TFmode);\n+\n+\t  if (FLOAT_WORDS_BIG_ENDIAN)\n+\t    {\n+\t      p[0] = (((unsigned HOST_WIDE_INT) l[0]) << 32) + l[1];\n+\t      p[1] = (((unsigned HOST_WIDE_INT) l[2]) << 32) + l[3];\n+\t    }\n+\t  else\n+\t    {\n+\t      p[0] = (((unsigned HOST_WIDE_INT) l[3]) << 32) + l[2];\n+\t      p[1] = (((unsigned HOST_WIDE_INT) l[1]) << 32) + l[0];\n+\t    }\n+\t  out[0] = GEN_INT (p[0]);\n+\t  out[1] = GEN_INT (p[1]);\n+\t}\n       return NULL_RTX;\n \n     default:\n       abort ();\n     }\n }\n \n+/* Split a TImode or TFmode move instruction after reload.\n+   This is used by *movtf_internal and *movti_internal.  */\n+void\n+ia64_split_tmode_move (rtx operands[])\n+{\n+  rtx adj1, adj2, in[2], out[2], insn;\n+  int first;\n+\n+  adj1 = ia64_split_tmode (in, operands[1], operands[2]);\n+  adj2 = ia64_split_tmode (out, operands[0], operands[2]);\n+\n+  first = 0;\n+  if (reg_overlap_mentioned_p (out[0], in[1]))\n+    {\n+      if (reg_overlap_mentioned_p (out[1], in[0]))\n+\tabort ();\n+      first = 1;\n+    }\n+\n+  if (adj1 && adj2)\n+    abort ();\n+  if (adj1)\n+    emit_insn (adj1);\n+  if (adj2)\n+    emit_insn (adj2);\n+  insn = emit_insn (gen_rtx_SET (VOIDmode, out[first], in[first]));\n+  if (GET_CODE (out[first]) == MEM\n+      && GET_CODE (XEXP (out[first], 0)) == POST_MODIFY)\n+    REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_INC,\n+\t\t\t\t\t  XEXP (XEXP (out[first], 0), 0),\n+\t\t\t\t\t  REG_NOTES (insn));\n+  insn = emit_insn (gen_rtx_SET (VOIDmode, out[!first], in[!first]));\n+  if (GET_CODE (out[!first]) == MEM\n+      && GET_CODE (XEXP (out[!first], 0)) == POST_MODIFY)\n+    REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_INC,\n+\t\t\t\t\t  XEXP (XEXP (out[!first], 0), 0),\n+\t\t\t\t\t  REG_NOTES (insn));\n+\n+}\n+\n /* ??? Fixing GR->FR XFmode moves during reload is hard.  You need to go\n    through memory plus an extra GR scratch register.  Except that you can\n    either get the first from SECONDARY_MEMORY_NEEDED or the second from\n@@ -3407,9 +3473,50 @@ hfa_element_mode (tree type, int nested)\n   return VOIDmode;\n }\n \n+/* Return the number of words required to hold a quantity of TYPE and MODE\n+   when passed as an argument.  */\n+static int\n+ia64_function_arg_words (tree type, enum machine_mode mode)\n+{\n+  int words;\n+\n+  if (mode == BLKmode)\n+    words = int_size_in_bytes (type);\n+  else\n+    words = GET_MODE_SIZE (mode);\n+\n+  return (words + UNITS_PER_WORD - 1) / UNITS_PER_WORD;  /* round up */\n+}\n+\n+/* Return the number of registers that should be skipped so the current\n+   argument (described by TYPE and WORDS) will be properly aligned.\n+\n+   Integer and float arguments larger than 8 bytes start at the next\n+   even boundary.  Aggregates larger than 8 bytes start at the next\n+   even boundary if the aggregate has 16 byte alignment.  Note that\n+   in the 32-bit ABI, TImode and TFmode have only 8-byte alignment\n+   but are still to be aligned in registers.\n+\n+   ??? The ABI does not specify how to handle aggregates with\n+   alignment from 9 to 15 bytes, or greater than 16.  We handle them\n+   all as if they had 16 byte alignment.  Such aggregates can occur\n+   only if gcc extensions are used.  */\n+static int\n+ia64_function_arg_offset (CUMULATIVE_ARGS *cum, tree type, int words)\n+{\n+  if ((cum->words & 1) == 0)\n+    return 0;\n+\n+  if (type\n+      && TREE_CODE (type) != INTEGER_TYPE\n+      && TREE_CODE (type) != REAL_TYPE)\n+    return TYPE_ALIGN (type) > 8 * BITS_PER_UNIT;\n+  else\n+    return words > 1;\n+}\n+\n /* Return rtx for register where argument is passed, or zero if it is passed\n    on the stack.  */\n-\n /* ??? 128-bit quad-precision floats are always passed in general\n    registers.  */\n \n@@ -3418,25 +3525,10 @@ ia64_function_arg (CUMULATIVE_ARGS *cum, enum machine_mode mode, tree type,\n \t\t   int named, int incoming)\n {\n   int basereg = (incoming ? GR_ARG_FIRST : AR_ARG_FIRST);\n-  int words = (((mode == BLKmode ? int_size_in_bytes (type)\n-\t\t : GET_MODE_SIZE (mode)) + UNITS_PER_WORD - 1)\n-\t       / UNITS_PER_WORD);\n-  int offset = 0;\n+  int words = ia64_function_arg_words (type, mode);\n+  int offset = ia64_function_arg_offset (cum, type, words);\n   enum machine_mode hfa_mode = VOIDmode;\n \n-  /* Integer and float arguments larger than 8 bytes start at the next even\n-     boundary.  Aggregates larger than 8 bytes start at the next even boundary\n-     if the aggregate has 16 byte alignment.  Net effect is that types with\n-     alignment greater than 8 start at the next even boundary.  */\n-  /* ??? The ABI does not specify how to handle aggregates with alignment from\n-     9 to 15 bytes, or greater than 16.   We handle them all as if they had\n-     16 byte alignment.  Such aggregates can occur only if gcc extensions are\n-     used.  */\n-  if ((type ? (TYPE_ALIGN (type) > 8 * BITS_PER_UNIT)\n-       : (words > 1))\n-      && (cum->words & 1))\n-    offset = 1;\n-\n   /* If all argument slots are used, then it must go on the stack.  */\n   if (cum->words + offset >= MAX_ARGUMENT_SLOTS)\n     return 0;\n@@ -3590,17 +3682,8 @@ int\n ia64_function_arg_partial_nregs (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n \t\t\t\t tree type, int named ATTRIBUTE_UNUSED)\n {\n-  int words = (((mode == BLKmode ? int_size_in_bytes (type)\n-\t\t : GET_MODE_SIZE (mode)) + UNITS_PER_WORD - 1)\n-\t       / UNITS_PER_WORD);\n-  int offset = 0;\n-\n-  /* Arguments with alignment larger than 8 bytes start at the next even\n-     boundary.  */\n-  if ((type ? (TYPE_ALIGN (type) > 8 * BITS_PER_UNIT)\n-       : (words > 1))\n-      && (cum->words & 1))\n-    offset = 1;\n+  int words = ia64_function_arg_words (type, mode);\n+  int offset = ia64_function_arg_offset (cum, type, words);\n \n   /* If all argument slots are used, then it must go on the stack.  */\n   if (cum->words + offset >= MAX_ARGUMENT_SLOTS)\n@@ -3624,23 +3707,14 @@ void\n ia64_function_arg_advance (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n \t\t\t   tree type, int named)\n {\n-  int words = (((mode == BLKmode ? int_size_in_bytes (type)\n-\t\t : GET_MODE_SIZE (mode)) + UNITS_PER_WORD - 1)\n-\t       / UNITS_PER_WORD);\n-  int offset = 0;\n+  int words = ia64_function_arg_words (type, mode);\n+  int offset = ia64_function_arg_offset (cum, type, words);\n   enum machine_mode hfa_mode = VOIDmode;\n \n   /* If all arg slots are already full, then there is nothing to do.  */\n   if (cum->words >= MAX_ARGUMENT_SLOTS)\n     return;\n \n-  /* Arguments with alignment larger than 8 bytes start at the next even\n-     boundary.  */\n-  if ((type ? (TYPE_ALIGN (type) > 8 * BITS_PER_UNIT)\n-       : (words > 1))\n-      && (cum->words & 1))\n-    offset = 1;\n-\n   cum->words += words + offset;\n \n   /* Check for and handle homogeneous FP aggregates.  */\n@@ -3750,9 +3824,12 @@ ia64_va_arg (tree valist, tree type)\n       return gen_rtx_MEM (ptr_mode, addr);\n     }\n \n-  /* Arguments with alignment larger than 8 bytes start at the next even\n-     boundary.  */\n-  if (TYPE_ALIGN (type) > 8 * BITS_PER_UNIT)\n+  /* Aggregate arguments with alignment larger than 8 bytes start at\n+     the next even boundary.  Integer and floating point arguments\n+     do so if they are larger than 8 bytes, whether or not they are\n+     also aligned larger than 8 bytes.  */\n+  if ((TREE_CODE (type) == REAL_TYPE || TREE_CODE (type) == INTEGER_TYPE)\n+      ? int_size_in_bytes (type) > 8 : TYPE_ALIGN (type) > 8 * BITS_PER_UNIT)\n     {\n       t = build (PLUS_EXPR, TREE_TYPE (valist), valist,\n \t\t build_int_2 (2 * UNITS_PER_WORD - 1, 0));\n@@ -3839,7 +3916,7 @@ ia64_function_value (tree valtype, tree func ATTRIBUTE_UNUSED)\n       else\n \treturn gen_rtx_PARALLEL (mode, gen_rtvec_v (i, loc));\n     }\n-  else if (FLOAT_TYPE_P (valtype) && mode != TFmode)\n+  else if (FLOAT_TYPE_P (valtype) && mode != TFmode && mode != TCmode)\n     return gen_rtx_REG (mode, FR_ARG_FIRST);\n   else\n     {\n@@ -4380,7 +4457,7 @@ ia64_secondary_reload_class (enum reg_class class,\n     case GR_REGS:\n       /* Since we have no offsettable memory addresses, we need a temporary\n \t to hold the address of the second word.  */\n-      if (mode == TImode)\n+      if (mode == TImode || mode == TFmode)\n \treturn GR_REGS;\n       break;\n "}, {"sha": "169569ac980c72930a502451cec7ae2df0a465fe", "filename": "gcc/config/ia64/ia64.md", "status": "modified", "additions": 52, "deletions": 80, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f57fc998eeab27e8292de128b37c94ffa37d8409/gcc%2Fconfig%2Fia64%2Fia64.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f57fc998eeab27e8292de128b37c94ffa37d8409/gcc%2Fconfig%2Fia64%2Fia64.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.md?ref=f57fc998eeab27e8292de128b37c94ffa37d8409", "patch": "@@ -606,98 +606,25 @@\n   \"reload_completed\"\n   [(const_int 0)]\n {\n-  rtx adj1, adj2, in[2], out[2], insn;\n-  int first;\n-\n-  adj1 = ia64_split_timode (in, operands[1], operands[2]);\n-  adj2 = ia64_split_timode (out, operands[0], operands[2]);\n-\n-  first = 0;\n-  if (reg_overlap_mentioned_p (out[0], in[1]))\n-    {\n-      if (reg_overlap_mentioned_p (out[1], in[0]))\n-\tabort ();\n-      first = 1;\n-    }\n-\n-  if (adj1 && adj2)\n-    abort ();\n-  if (adj1)\n-    emit_insn (adj1);\n-  if (adj2)\n-    emit_insn (adj2);\n-  insn = emit_insn (gen_rtx_SET (VOIDmode, out[first], in[first]));\n-  if (GET_CODE (out[first]) == MEM\n-      && GET_CODE (XEXP (out[first], 0)) == POST_MODIFY)\n-    REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_INC,\n-\t\t\t\t\t  XEXP (XEXP (out[first], 0), 0),\n-\t\t\t\t\t  REG_NOTES (insn));\n-  insn = emit_insn (gen_rtx_SET (VOIDmode, out[!first], in[!first]));\n-  if (GET_CODE (out[!first]) == MEM\n-      && GET_CODE (XEXP (out[!first], 0)) == POST_MODIFY)\n-    REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_INC,\n-\t\t\t\t\t  XEXP (XEXP (out[!first], 0), 0),\n-\t\t\t\t\t  REG_NOTES (insn));\n-  DONE;\n-}\n-  [(set_attr \"itanium_class\" \"unknown\")\n-   (set_attr \"predicable\" \"no\")])\n-\n-;; ??? SSA creates these.  Can't allow memories since we don't have\n-;; the scratch register.  Fortunately combine will know how to add\n-;; the clobber and scratch.\n-(define_insn_and_split \"*movti_internal_reg\"\n-  [(set (match_operand:TI 0 \"register_operand\"  \"=r\")\n-\t(match_operand:TI 1 \"nonmemory_operand\" \"ri\"))]\n-  \"\"\n-  \"#\"\n-  \"reload_completed\"\n-  [(const_int 0)]\n-{\n-  rtx in[2], out[2];\n-  int first;\n-\n-  ia64_split_timode (in, operands[1], NULL_RTX);\n-  ia64_split_timode (out, operands[0], NULL_RTX);\n-\n-  first = 0;\n-  if (reg_overlap_mentioned_p (out[0], in[1]))\n-    {\n-      if (reg_overlap_mentioned_p (out[1], in[0]))\n-\tabort ();\n-      first = 1;\n-    }\n-\n-  emit_insn (gen_rtx_SET (VOIDmode, out[first], in[first]));\n-  emit_insn (gen_rtx_SET (VOIDmode, out[!first], in[!first]));\n+  ia64_split_tmode_move (operands);\n   DONE;\n }\n   [(set_attr \"itanium_class\" \"unknown\")\n    (set_attr \"predicable\" \"no\")])\n \n (define_expand \"reload_inti\"\n   [(parallel [(set (match_operand:TI 0 \"register_operand\" \"=r\")\n-\t\t   (match_operand:TI 1 \"\" \"m\"))\n-\t      (clobber (match_operand:TI 2 \"register_operand\" \"=&r\"))])]\n+\t\t   (match_operand:TI 1 \"memory_operand\" \"m\"))\n+\t      (clobber (match_operand:DI 2 \"register_operand\" \"=&r\"))])]\n   \"\"\n-{\n-  unsigned int s_regno = REGNO (operands[2]);\n-  if (s_regno == REGNO (operands[0]))\n-    s_regno += 1;\n-  operands[2] = gen_rtx_REG (DImode, s_regno);\n-})\n+  \"\")\n \n (define_expand \"reload_outti\"\n-  [(parallel [(set (match_operand:TI 0 \"\" \"=m\")\n+  [(parallel [(set (match_operand:TI 0 \"memory_operand\" \"=m\")\n \t\t   (match_operand:TI 1 \"register_operand\" \"r\"))\n-\t      (clobber (match_operand:TI 2 \"register_operand\" \"=&r\"))])]\n+\t      (clobber (match_operand:DI 2 \"register_operand\" \"=&r\"))])]\n   \"\"\n-{\n-  unsigned int s_regno = REGNO (operands[2]);\n-  if (s_regno == REGNO (operands[1]))\n-    s_regno += 1;\n-  operands[2] = gen_rtx_REG (DImode, s_regno);\n-})\n+  \"\")\n \n ;; Floating Point Moves\n ;;\n@@ -835,6 +762,51 @@\n    ldfe %0 = %1%P1\n    stfe %0 = %F1%P0\"\n   [(set_attr \"itanium_class\" \"fmisc,fld,stf\")])\n+\n+;; Better code generation via insns that deal with TFmode register pairs\n+;; directly.\n+;; With no offsettable memory references, we've got to have a scratch\n+;; around to play with the second word.\n+(define_expand \"movtf\"\n+  [(parallel [(set (match_operand:TF 0 \"general_operand\" \"\")\n+\t\t   (match_operand:TF 1 \"general_operand\" \"\"))\n+\t      (clobber (match_scratch:DI 2 \"\"))])]\n+  \"\"\n+{\n+  rtx op1 = ia64_expand_move (operands[0], operands[1]);\n+  if (!op1)\n+    DONE;\n+  operands[1] = op1;\n+})\n+\n+(define_insn_and_split \"*movtf_internal\"\n+  [(set (match_operand:TF 0 \"nonimmediate_operand\" \"=r,r,m\")\n+\t(match_operand:TF 1 \"general_operand\"      \"ri,m,r\"))\n+   (clobber (match_scratch:DI 2 \"=X,&r,&r\"))]\n+  \"ia64_move_ok (operands[0], operands[1])\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(const_int 0)]\n+{\n+  ia64_split_tmode_move (operands);\n+  DONE;\n+}\n+  [(set_attr \"itanium_class\" \"unknown\")\n+   (set_attr \"predicable\" \"no\")])\n+\n+(define_expand \"reload_intf\"\n+  [(parallel [(set (match_operand:TF 0 \"register_operand\" \"=r\")\n+\t\t   (match_operand:TF 1 \"memory_operand\" \"m\"))\n+\t      (clobber (match_operand:DI 2 \"register_operand\" \"=&r\"))])]\n+  \"\"\n+  \"\")\n+\n+(define_expand \"reload_outtf\"\n+  [(parallel [(set (match_operand:TF 0 \"memory_operand\" \"=m\")\n+\t\t   (match_operand:TF 1 \"register_operand\" \"r\"))\n+\t      (clobber (match_operand:DI 2 \"register_operand\" \"=&r\"))])]\n+  \"\"\n+  \"\")\n \f\n ;; ::::::::::::::::::::\n ;; ::"}]}