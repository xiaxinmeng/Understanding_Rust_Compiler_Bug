{"sha": "0a2409728b6ff51520182f6583416811c7d1a0f3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGEyNDA5NzI4YjZmZjUxNTIwMTgyZjY1ODM0MTY4MTFjN2QxYTBmMw==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2000-04-20T14:25:33Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2000-04-20T14:25:33Z"}, "message": "rtti.c (init_rtti_processing): Set tinfo_var_id in new-abi.\n\n\t* rtti.c (init_rtti_processing): Set tinfo_var_id in new-abi.\n\t(target_incomplete_p): New function.\n\t(tinfo_base_init): Create comdat NTBS name variable.\n\t(ptr_initializer): Add non_public parameter. Calculate it.\n\t(ptmd_initializer): Likewise.\n\t(synthesize_tinfo_var): Adjust. Emit incomplete class tinfo.\n\t(create_real_tinfo_var): Add non_public parameter. Use it.\n\tPush proxy into global namespace.\n\t* inc/cxxabi.h (__pointer_type_info::incomplete_class_mask):\n\tNew enumeration.\n\t* inc/typeinfo (type_info::before, type_info::operator==):\n\tCompare __name addresses.\n\n\t* tinfo2.cc: Remove new-abi builtins comment.\n\nFrom-SVN: r33281", "tree": {"sha": "78c7d04301dc2fc055e7c193b6bd02efec2ae63a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/78c7d04301dc2fc055e7c193b6bd02efec2ae63a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0a2409728b6ff51520182f6583416811c7d1a0f3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a2409728b6ff51520182f6583416811c7d1a0f3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0a2409728b6ff51520182f6583416811c7d1a0f3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a2409728b6ff51520182f6583416811c7d1a0f3/comments", "author": null, "committer": null, "parents": [{"sha": "f8a097cd17f2e2465f5bc98aff3f4eaf616a0f2c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8a097cd17f2e2465f5bc98aff3f4eaf616a0f2c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f8a097cd17f2e2465f5bc98aff3f4eaf616a0f2c"}], "stats": {"total": 159, "additions": 128, "deletions": 31}, "files": [{"sha": "5022e8311cc143ec983c4b6440bb2aca78334770", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a2409728b6ff51520182f6583416811c7d1a0f3/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a2409728b6ff51520182f6583416811c7d1a0f3/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=0a2409728b6ff51520182f6583416811c7d1a0f3", "patch": "@@ -1,3 +1,20 @@\n+2000-04-20  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* rtti.c (init_rtti_processing): Set tinfo_var_id in new-abi.\n+\t(target_incomplete_p): New function.\n+\t(tinfo_base_init): Create comdat NTBS name variable.\n+\t(ptr_initializer): Add non_public parameter. Calculate it.\n+\t(ptmd_initializer): Likewise.\n+\t(synthesize_tinfo_var): Adjust. Emit incomplete class tinfo.\n+\t(create_real_tinfo_var): Add non_public parameter. Use it.\n+\tPush proxy into global namespace.\n+\t* inc/cxxabi.h (__pointer_type_info::incomplete_class_mask):\n+\tNew enumeration.\n+\t* inc/typeinfo (type_info::before, type_info::operator==):\n+\tCompare __name addresses.\n+\t\n+\t* tinfo2.cc: Remove new-abi builtins comment.\n+\n 2000-04-20  Jason Merrill  <jason@casey.cygnus.com>\n \n \t* typeck.c (build_x_function_call): Resolve an OFFSET_REF."}, {"sha": "416b046e71a48326370a147a418dad06cbac6c74", "filename": "gcc/cp/inc/cxxabi.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a2409728b6ff51520182f6583416811c7d1a0f3/gcc%2Fcp%2Finc%2Fcxxabi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a2409728b6ff51520182f6583416811c7d1a0f3/gcc%2Fcp%2Finc%2Fcxxabi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finc%2Fcxxabi.h?ref=0a2409728b6ff51520182f6583416811c7d1a0f3", "patch": "@@ -68,7 +68,8 @@ class __pointer_type_info\n     const_mask = 0x1,\n     volatile_mask = 0x2,\n     restrict_mask = 0x4,\n-    incomplete_mask = 0x8\n+    incomplete_mask = 0x8,\n+    incomplete_class_mask = 0x10\n   };\n \n /* implementation defined member functions */"}, {"sha": "8c5bbd839ad92e52ea28a80d72eaa7a8bd1cc02c", "filename": "gcc/cp/inc/typeinfo", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a2409728b6ff51520182f6583416811c7d1a0f3/gcc%2Fcp%2Finc%2Ftypeinfo", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a2409728b6ff51520182f6583416811c7d1a0f3/gcc%2Fcp%2Finc%2Ftypeinfo", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finc%2Ftypeinfo?ref=0a2409728b6ff51520182f6583416811c7d1a0f3", "patch": "@@ -56,14 +56,14 @@ public:\n     { return !operator== (__arg); }\n \n #else\n-  // In new abi we can rely on type_info's being unique,\n+  // In new abi we can rely on type_info's NTBS being unique,\n   // and therefore address comparisons are sufficient.\n   bool before (const type_info& __arg) const\n-    { return this < &__arg; }\n+    { return __name < __arg.__name; }\n   const char* name () const\n     { return __name; }\n   bool operator== (const type_info& __arg) const\n-    { return &__arg == this; }\n+    { return __name == __arg.__name; }\n   bool operator!= (const type_info& __arg) const\n     { return !operator== (__arg); }\n #endif"}, {"sha": "b16faf7358e5ab69ab0901b9392e73b3c0e8be1a", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 106, "deletions": 22, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a2409728b6ff51520182f6583416811c7d1a0f3/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a2409728b6ff51520182f6583416811c7d1a0f3/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=0a2409728b6ff51520182f6583416811c7d1a0f3", "patch": "@@ -62,16 +62,17 @@ static tree throw_bad_typeid PARAMS((void));\n static tree get_tinfo_decl_dynamic PARAMS((tree));\n static tree tinfo_from_decl PARAMS((tree));\n static int qualifier_flags PARAMS((tree));\n+static int target_incomplete_p PARAMS((tree));\n static tree tinfo_base_init PARAMS((tree, tree));\n static tree generic_initializer PARAMS((tree, tree));\n-static tree ptr_initializer PARAMS((tree, tree));\n-static tree ptmd_initializer PARAMS((tree, tree));\n+static tree ptr_initializer PARAMS((tree, tree, int *));\n+static tree ptmd_initializer PARAMS((tree, tree, int *));\n static tree dfs_class_hint_mark PARAMS ((tree, void *));\n static tree dfs_class_hint_unmark PARAMS ((tree, void *));\n static int class_hint_flags PARAMS((tree));\n static tree class_initializer PARAMS((tree, tree, tree));\n static tree synthesize_tinfo_var PARAMS((tree, tree));\n-static tree create_real_tinfo_var PARAMS((tree, tree, tree));\n+static tree create_real_tinfo_var PARAMS((tree, tree, tree, int));\n static tree create_pseudo_type_info PARAMS((const char *, int, ...));\n static tree get_vmi_pseudo_type_info PARAMS((int));\n static void create_tinfo_types PARAMS((void));\n@@ -95,14 +96,16 @@ init_rtti_processing ()\n           (build_qualified_type\n             (type_info_type_node, TYPE_QUAL_CONST)),\n          void_list_node);\n+      tinfo_var_id = get_identifier (\"__ti\");\n     }\n   else\n     {\n+      /* FIXME: These identifier prefixes are not set in stone yet.  */\n       tinfo_decl_id = get_identifier (\"__ti\");\n+      tinfo_var_id = get_identifier (\"__tn\");\n       tinfo_decl_type = build_qualified_type\n                           (type_info_type_node, TYPE_QUAL_CONST);\n     }\n-  tinfo_var_id = get_identifier (\"__ti\");\n }\n \n /* Given a pointer to an object with at least one virtual table\n@@ -1296,24 +1299,69 @@ qualifier_flags (type)\n   return flags;\n }\n \n+/* Return non-zero, if the pointer chain TYPE ends at an incomplete type, or\n+   contains a pointer to member of an incomplete class.  */\n+\n+static int\n+target_incomplete_p (type)\n+     tree type;\n+{\n+  while (TREE_CODE (type) == POINTER_TYPE)\n+    if (TYPE_PTRMEM_P (type))\n+      {\n+        if (!COMPLETE_TYPE_P (TYPE_PTRMEM_CLASS_TYPE (type)))\n+          return 1;\n+        type = TYPE_PTRMEM_POINTED_TO_TYPE (type);\n+      }\n+    else\n+      type = TREE_TYPE (type);\n+  if (!COMPLETE_OR_VOID_TYPE_P (type))\n+    return 1;\n+  \n+  return 0;\n+}\n+\n /* Return a CONSTRUCTOR for the common part of the type_info objects. This\n-   is the vtable pointer and NTBS name.  */\n+   is the vtable pointer and NTBS name.  The NTBS name is emitted as a\n+   comdat const char array, so it becomes a unique key for the type. Generate\n+   and emit that VAR_DECL here.  (We can't always emit the type_info itself\n+   as comdat, because of pointers to incomplete.) */\n \n static tree\n tinfo_base_init (desc, target)\n      tree desc;\n      tree target;\n {\n-  tree name_string = tinfo_name (target);\n   tree init = NULL_TREE;\n+  tree name_decl;\n+  \n+  {\n+    /* Generate the NTBS array variable.  */\n+    tree name_name = build_overload_with_type (tinfo_var_id, target);\n+    tree name_type = build_cplus_array_type\n+                     (build_qualified_type (char_type_node, TYPE_QUAL_CONST),\n+                     NULL_TREE);\n+    tree name_string = tinfo_name (target);\n+    name_decl = build_lang_decl (VAR_DECL, name_name, name_type);\n+    \n+    DECL_ARTIFICIAL (name_decl) = 1;\n+    TREE_READONLY (name_decl) = 1;\n+    TREE_STATIC (name_decl) = 1;\n+    DECL_EXTERNAL (name_decl) = 0;\n+    TREE_PUBLIC (name_decl) = 1;\n+    comdat_linkage (name_decl);\n+    DECL_ASSEMBLER_NAME (name_decl) = DECL_NAME (name_decl);\n+    DECL_INITIAL (name_decl) = name_string;\n+    cp_finish_decl (name_decl, name_string, NULL_TREE, 0);\n+  }\n   \n   if (TINFO_VTABLE_DECL (desc))\n     {\n       tree vtbl_ptr = TINFO_VTABLE_DECL (desc);\n       init = tree_cons (NULL_TREE, vtbl_ptr, init);\n     }\n   \n-  init = tree_cons (NULL_TREE, decay_conversion (name_string), init);\n+  init = tree_cons (NULL_TREE, decay_conversion (name_decl), init);\n   \n   init = build (CONSTRUCTOR, NULL_TREE, NULL_TREE, nreverse (init));\n   TREE_HAS_CONSTRUCTOR (init) = TREE_CONSTANT (init) = TREE_STATIC (init) = 1;\n@@ -1343,14 +1391,21 @@ generic_initializer (desc, target)\n    which adds target type and qualifier flags members to the type_info base.  */\n \n static tree\n-ptr_initializer (desc, target)\n+ptr_initializer (desc, target, non_public_ptr)\n      tree desc;\n      tree target;\n+     int *non_public_ptr;\n {\n   tree init = tinfo_base_init (desc, target);\n   tree to = TREE_TYPE (target);\n   int flags = qualifier_flags (to);\n+  int incomplete = target_incomplete_p (to);\n   \n+  if (incomplete)\n+    {\n+      flags |= 8;\n+      *non_public_ptr = 1;\n+    }\n   init = tree_cons (NULL_TREE, build_int_2 (flags, 0), init);\n   init = tree_cons (NULL_TREE,\n                     build_unary_op (ADDR_EXPR,\n@@ -1364,18 +1419,28 @@ ptr_initializer (desc, target)\n \n /* Return the CONSTRUCTOR expr for a type_info of pointer to member data TYPE.\n    DESC provides information about the particular type_info derivation,\n-   which adds target type and qualifier flags members to the type_info base.  */\n+   which adds class, target type and qualifier flags members to the type_info\n+   base.  */\n \n static tree\n-ptmd_initializer (desc, target)\n+ptmd_initializer (desc, target, non_public_ptr)\n      tree desc;\n      tree target;\n+     int *non_public_ptr;\n {\n   tree init = tinfo_base_init (desc, target);\n   tree to = TYPE_PTRMEM_POINTED_TO_TYPE (target);\n   tree klass = TYPE_PTRMEM_CLASS_TYPE (target);\n   int flags = qualifier_flags (to);\n+  int incomplete = target_incomplete_p (to);\n   \n+  if (incomplete)\n+    {\n+      flags |= 0x8;\n+      *non_public_ptr = 1;\n+    }\n+  if (!COMPLETE_TYPE_P (klass))\n+    flags |= 0x10;\n   init = tree_cons (NULL_TREE, build_int_2 (flags, 0), init);\n   init = tree_cons (NULL_TREE,\n                     build_unary_op (ADDR_EXPR,\n@@ -1489,6 +1554,7 @@ synthesize_tinfo_var (target_type, real_name)\n {\n   tree var_init = NULL_TREE;\n   tree var_type = NULL_TREE;\n+  int non_public = 0;\n   \n   my_friendly_assert (new_abi_rtti_p (), 20000118);\n \n@@ -1498,7 +1564,7 @@ synthesize_tinfo_var (target_type, real_name)\n       if (TYPE_PTRMEM_P (target_type))\n         {\n           var_type = ptmd_desc_type_node;\n-          var_init = ptmd_initializer (var_type, target_type);\n+          var_init = ptmd_initializer (var_type, target_type, &non_public);\n         }\n       else\n         {\n@@ -1513,7 +1579,7 @@ synthesize_tinfo_var (target_type, real_name)\n             /* These are in the runtime.  */\n             return NULL_TREE;\n           var_type = ptr_desc_type_node;\n-          var_init = ptr_initializer (var_type, target_type);\n+          var_init = ptr_initializer (var_type, target_type, &non_public);\n         }\n       break;\n     case ENUMERAL_TYPE:\n@@ -1532,8 +1598,10 @@ synthesize_tinfo_var (target_type, real_name)\n     case RECORD_TYPE:\n       if (!COMPLETE_TYPE_P (target_type))\n         {\n-          /* FIXME: incomplete type. Awaiting specification.  */\n-          return NULL_TREE;\n+          /* Emit a non-public class_type_info.  */\n+          non_public = 1;\n+          var_type = class_desc_type_node;\n+          var_init = class_initializer (var_type, target_type, NULL_TREE);\n         }\n       else if (!CLASSTYPE_N_BASECLASSES (target_type))\n         {\n@@ -1620,32 +1688,48 @@ synthesize_tinfo_var (target_type, real_name)\n       my_friendly_abort (20000117);\n     }\n   \n-  return create_real_tinfo_var (real_name, TINFO_PSEUDO_TYPE (var_type), var_init);\n+  \n+  return create_real_tinfo_var (real_name, TINFO_PSEUDO_TYPE (var_type),\n+                                var_init, non_public);\n }\n \n-/* Create the real typeinfo variable.  */\n+/* Create the real typeinfo variable.  NON_PUBLIC indicates that we cannot\n+   make this variable public (comdat). */\n \n static tree\n-create_real_tinfo_var (name, type, init)\n+create_real_tinfo_var (name, type, init, non_public)\n      tree name;\n      tree type;\n      tree init;\n+     int non_public;\n {\n+  static int count = 0;\n   tree decl;\n+  tree hidden_name;\n+  char hidden[30];\n+  \n+  sprintf (hidden, \"%.*s_%d\",\n+           IDENTIFIER_LENGTH (tinfo_decl_id), IDENTIFIER_POINTER (tinfo_decl_id),\n+           count++);\n+  hidden_name = get_identifier (hidden);\n   \n-  decl = build_lang_decl (VAR_DECL, name,\n+  decl = build_lang_decl (VAR_DECL, hidden_name,\n                           build_qualified_type (type, TYPE_QUAL_CONST));\n   DECL_ARTIFICIAL (decl) = 1;\n   TREE_READONLY (decl) = 1;\n   TREE_STATIC (decl) = 1;\n-  TREE_PUBLIC (decl) = 1;\n   DECL_EXTERNAL (decl) = 0;\n   \n-  comdat_linkage (decl);\n+  if (!non_public)\n+    {\n+      TREE_PUBLIC (decl) = 1;\n+      comdat_linkage (decl);\n+    }\n   DECL_ASSEMBLER_NAME (decl) = name;\n   DECL_INITIAL (decl) = init;\n   cp_finish_decl (decl, init, NULL_TREE, 0);\n-  \n+  pushdecl_top_level (decl);\n+  TREE_USED (decl) = 1;\n   return decl;\n }\n \n@@ -1951,7 +2035,7 @@ tinfo_decl_p (t, data)\n    actual type this is describing. The DECL_ASSEMBLER_NAME of the generated\n    definition is set to that of the supplied decl, so that they can be tied\n    up. Mark the supplied decl as having been dealt with. Emitting one\n-   definitions might cause other declarations to be emitted.\n+   definition might cause other definitions to be required.\n    \n    We need to do things this way, because we're trying to do something like\n    "}, {"sha": "2be647a54df14b04df49f6398bab7547cb2415c5", "filename": "gcc/cp/tinfo2.cc", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0a2409728b6ff51520182f6583416811c7d1a0f3/gcc%2Fcp%2Ftinfo2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0a2409728b6ff51520182f6583416811c7d1a0f3/gcc%2Fcp%2Ftinfo2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftinfo2.cc?ref=0a2409728b6ff51520182f6583416811c7d1a0f3", "patch": "@@ -438,10 +438,5 @@ BUILTIN (v); BUILTIN (x); BUILTIN (l); BUILTIN (i); BUILTIN (s); BUILTIN (b);\n BUILTIN (c); BUILTIN (w); BUILTIN (r); BUILTIN (d); BUILTIN (f);\n BUILTIN (Ui); BUILTIN (Ul); BUILTIN (Ux); BUILTIN (Us); BUILTIN (Uc);\n BUILTIN (Sc);\n-#else\n-// new abi\n-\n-// we need to define the fundamental type type_info's, but the name mangling is\n-// not yet defined.\n \n #endif"}]}