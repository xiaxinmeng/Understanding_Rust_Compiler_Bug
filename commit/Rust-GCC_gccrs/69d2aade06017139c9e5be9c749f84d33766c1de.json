{"sha": "69d2aade06017139c9e5be9c749f84d33766c1de", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjlkMmFhZGUwNjAxNzEzOWM5ZTViZTljNzQ5Zjg0ZDMzNzY2YzFkZQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2011-10-06T17:49:36Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2011-10-06T17:49:36Z"}, "message": "re PR tree-optimization/50596 (Problems in vectorization of condition expression)\n\n\tPR tree-optimization/50596\n\t* tree-vectorizer.h (vect_is_simple_cond): New prototype.\n\t(NUM_PATTERNS): Change to 6.\n\t* tree-vect-patterns.c (vect_recog_mixed_size_cond_pattern): New\n\tfunction.\n\t(vect_vect_recog_func_ptrs): Add vect_recog_mixed_size_cond_pattern.\n\t(vect_mark_pattern_stmts): Don't create stmt_vinfo for def_stmt\n\tif it already has one, and don't set STMT_VINFO_VECTYPE in it\n\tif it is already set.\n\t* tree-vect-stmts.c (vect_mark_stmts_to_be_vectorized): Handle\n\tCOND_EXPR in pattern stmts.\n\t(vect_is_simple_cond): No longer static.\n\n\t* lib/target-supports.exp (check_effective_target_vect_cond_mixed):\n\tNew.\n\t* gcc.dg/vect/vect-cond-8.c: New test.\n\nFrom-SVN: r179626", "tree": {"sha": "7b76d530ce6387f36c6a3185daad85fe6b8d400a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7b76d530ce6387f36c6a3185daad85fe6b8d400a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/69d2aade06017139c9e5be9c749f84d33766c1de", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/69d2aade06017139c9e5be9c749f84d33766c1de", "html_url": "https://github.com/Rust-GCC/gccrs/commit/69d2aade06017139c9e5be9c749f84d33766c1de", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/69d2aade06017139c9e5be9c749f84d33766c1de/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "810cfbebfad8981bd8e4aea6a247ad4ee1c24ec0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/810cfbebfad8981bd8e4aea6a247ad4ee1c24ec0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/810cfbebfad8981bd8e4aea6a247ad4ee1c24ec0"}], "stats": {"total": 322, "additions": 312, "deletions": 10}, "files": [{"sha": "a8cc8334070a274a2db51a812f176091bae52d0b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69d2aade06017139c9e5be9c749f84d33766c1de/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69d2aade06017139c9e5be9c749f84d33766c1de/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=69d2aade06017139c9e5be9c749f84d33766c1de", "patch": "@@ -1,3 +1,18 @@\n+2011-10-06  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR tree-optimization/50596\n+\t* tree-vectorizer.h (vect_is_simple_cond): New prototype.\n+\t(NUM_PATTERNS): Change to 6.\n+\t* tree-vect-patterns.c (vect_recog_mixed_size_cond_pattern): New\n+\tfunction.\n+\t(vect_vect_recog_func_ptrs): Add vect_recog_mixed_size_cond_pattern.\n+\t(vect_mark_pattern_stmts): Don't create stmt_vinfo for def_stmt\n+\tif it already has one, and don't set STMT_VINFO_VECTYPE in it\n+\tif it is already set.\n+\t* tree-vect-stmts.c (vect_mark_stmts_to_be_vectorized): Handle\n+\tCOND_EXPR in pattern stmts.\n+\t(vect_is_simple_cond): No longer static.\n+\n 2001-10-06  Richard Henderson  <rth@redhat.com>\n \n \t* config/i386/i386.c (ix86_expand_vshuffle): Add AVX2 support."}, {"sha": "ccd5187fb6b75d92fe0870c2e60b67087462432e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69d2aade06017139c9e5be9c749f84d33766c1de/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69d2aade06017139c9e5be9c749f84d33766c1de/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=69d2aade06017139c9e5be9c749f84d33766c1de", "patch": "@@ -1,3 +1,10 @@\n+2011-10-06  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR tree-optimization/50596\n+\t* lib/target-supports.exp (check_effective_target_vect_cond_mixed):\n+\tNew.\n+\t* gcc.dg/vect/vect-cond-8.c: New test.\n+\n 2011-10-06  Richard Henderson  <rth@redhat.com>\n \n \t* gcc.c-torture/execute/vect-shuffle-1.c: Remove."}, {"sha": "e5702c25a1d3c46110d5bc008237f6adb414df16", "filename": "gcc/testsuite/gcc.dg/vect/vect-cond-8.c", "status": "added", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69d2aade06017139c9e5be9c749f84d33766c1de/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-cond-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69d2aade06017139c9e5be9c749f84d33766c1de/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-cond-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-cond-8.c?ref=69d2aade06017139c9e5be9c749f84d33766c1de", "patch": "@@ -0,0 +1,122 @@\n+/* { dg-require-effective-target vect_cond_mixed } */\n+\n+#include \"tree-vect.h\"\n+\n+#define N 1024\n+float a[N], b[N], c[N];\n+int d[N], e[N], f[N];\n+unsigned char k[N];\n+\n+__attribute__((noinline, noclone)) void\n+f1 (void)\n+{\n+  int i;\n+  for (i = 0; i < N; ++i)\n+    k[i] = a[i] < b[i] ? 17 : 0;\n+}\n+\n+__attribute__((noinline, noclone)) void\n+f2 (void)\n+{\n+  int i;\n+  for (i = 0; i < N; ++i)\n+    k[i] = a[i] < b[i] ? 0 : 24;\n+}\n+\n+__attribute__((noinline, noclone)) void\n+f3 (void)\n+{\n+  int i;\n+  for (i = 0; i < N; ++i)\n+    k[i] = a[i] < b[i] ? 51 : 12;\n+}\n+\n+__attribute__((noinline, noclone)) void\n+f4 (void)\n+{\n+  int i;\n+  for (i = 0; i < N; ++i)\n+    {\n+      int d2 = d[i], e2 = e[i];\n+      f[i] = a[i] < b[i] ? d2 : e2;\n+    }\n+}\n+\n+__attribute__((noinline, noclone)) void\n+f5 (void)\n+{\n+  int i;\n+  for (i = 0; i < N; ++i)\n+    {\n+      float a2 = a[i], b2 = b[i];\n+      c[i] = d[i] < e[i] ? a2 : b2;\n+    }\n+}\n+\n+int\n+main ()\n+{\n+  int i;\n+\n+  check_vect ();\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      switch (i % 9)\n+\t{\n+\tcase 0: asm (\"\"); a[i] = - i - 1; b[i] = i + 1; break;\n+\tcase 1: a[i] = 0; b[i] = 0; break;\n+\tcase 2: a[i] = i + 1; b[i] = - i - 1; break;\n+\tcase 3: a[i] = i; b[i] = i + 7; break;\n+\tcase 4: a[i] = i; b[i] = i; break;\n+\tcase 5: a[i] = i + 16; b[i] = i + 3; break;\n+\tcase 6: a[i] = - i - 5; b[i] = - i; break;\n+\tcase 7: a[i] = - i; b[i] = - i; break;\n+\tcase 8: a[i] = - i; b[i] = - i - 7; break;\n+\t}\n+      d[i] = i;\n+      e[i] = 2 * i;\n+    }\n+  f1 ();\n+  for (i = 0; i < N; i++)\n+    if (k[i] != ((i % 3) == 0 ? 17 : 0))\n+      abort ();\n+  f2 ();\n+  for (i = 0; i < N; i++)\n+    if (k[i] != ((i % 3) == 0 ? 0 : 24))\n+      abort ();\n+  f3 ();\n+  for (i = 0; i < N; i++)\n+    if (k[i] != ((i % 3) == 0 ? 51 : 12))\n+      abort ();\n+  f4 ();\n+  for (i = 0; i < N; i++)\n+    if (f[i] != ((i % 3) == 0 ? d[i] : e[i]))\n+      abort ();\n+  for (i = 0; i < N; i++)\n+    {\n+      switch (i % 9)\n+\t{\n+\tcase 0: asm (\"\"); d[i] = - i - 1; e[i] = i + 1; break;\n+\tcase 1: d[i] = 0; e[i] = 0; break;\n+\tcase 2: d[i] = i + 1; e[i] = - i - 1; break;\n+\tcase 3: d[i] = i; e[i] = i + 7; break;\n+\tcase 4: d[i] = i; e[i] = i; break;\n+\tcase 5: d[i] = i + 16; e[i] = i + 3; break;\n+\tcase 6: d[i] = - i - 5; e[i] = - i; break;\n+\tcase 7: d[i] = - i; e[i] = - i; break;\n+\tcase 8: d[i] = - i; e[i] = - i - 7; break;\n+\t}\n+      a[i] = i;\n+      b[i] = i / 2;\n+    }\n+  f5 ();\n+  for (i = 0; i < N; i++)\n+    if (c[i] != ((i % 3) == 0 ? a[i] : b[i]))\n+      abort ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"note: vectorized 1 loops\" 5 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "550d53452445693cea4980e3908dbb5f80926d31", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69d2aade06017139c9e5be9c749f84d33766c1de/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69d2aade06017139c9e5be9c749f84d33766c1de/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=69d2aade06017139c9e5be9c749f84d33766c1de", "patch": "@@ -3234,6 +3234,26 @@ proc check_effective_target_vect_condition { } {\n     return $et_vect_cond_saved\n }\n \n+# Return 1 if the target supports vector conditional operations where\n+# the comparison has different type from the lhs, 0 otherwise.\n+\n+proc check_effective_target_vect_cond_mixed { } {\n+    global et_vect_cond_mixed_saved\n+\n+    if [info exists et_vect_cond_mixed_saved] {\n+\tverbose \"check_effective_target_vect_cond_mixed: using cached result\" 2\n+    } else {\n+\tset et_vect_cond_mixed_saved 0\n+\tif { [istarget i?86-*-*]\n+\t     || [istarget x86_64-*-*] } {\n+\t   set et_vect_cond_mixed_saved 1\n+\t}\n+    }\n+\n+    verbose \"check_effective_target_vect_cond_mixed: returning $et_vect_cond_mixed_saved\" 2\n+    return $et_vect_cond_mixed_saved\n+}\n+\n # Return 1 if the target supports vector char multiplication, 0 otherwise.\n \n proc check_effective_target_vect_char_mult { } {"}, {"sha": "0cd350d2dca1b29f55b955c5970a7eed22c33d5e", "filename": "gcc/tree-vect-patterns.c", "status": "modified", "additions": 126, "deletions": 5, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69d2aade06017139c9e5be9c749f84d33766c1de/gcc%2Ftree-vect-patterns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69d2aade06017139c9e5be9c749f84d33766c1de/gcc%2Ftree-vect-patterns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-patterns.c?ref=69d2aade06017139c9e5be9c749f84d33766c1de", "patch": "@@ -49,12 +49,15 @@ static gimple vect_recog_dot_prod_pattern (VEC (gimple, heap) **, tree *,\n static gimple vect_recog_pow_pattern (VEC (gimple, heap) **, tree *, tree *);\n static gimple vect_recog_over_widening_pattern (VEC (gimple, heap) **, tree *,\n                                                  tree *);\n+static gimple vect_recog_mixed_size_cond_pattern (VEC (gimple, heap) **,\n+\t\t\t\t\t\t  tree *, tree *);\n static vect_recog_func_ptr vect_vect_recog_func_ptrs[NUM_PATTERNS] = {\n \tvect_recog_widen_mult_pattern,\n \tvect_recog_widen_sum_pattern,\n \tvect_recog_dot_prod_pattern,\n \tvect_recog_pow_pattern,\n-        vect_recog_over_widening_pattern};\n+\tvect_recog_over_widening_pattern,\n+\tvect_recog_mixed_size_cond_pattern};\n \n \n /* Function widened_name_p\n@@ -1211,6 +1214,120 @@ vect_recog_over_widening_pattern (VEC (gimple, heap) **stmts,\n }\n \n \n+/* Function vect_recog_mixed_size_cond_pattern\n+\n+   Try to find the following pattern:\n+\n+     type x_t, y_t;\n+     TYPE a_T, b_T, c_T;\n+   loop:\n+     S1  a_T = x_t CMP y_t ? b_T : c_T;\n+\n+   where type 'TYPE' is an integral type which has different size\n+   from 'type'.  b_T and c_T are constants and if 'TYPE' is wider\n+   than 'type', the constants need to fit into an integer type\n+   with the same width as 'type'.\n+\n+   Input:\n+\n+   * LAST_STMT: A stmt from which the pattern search begins.\n+\n+   Output:\n+\n+   * TYPE_IN: The type of the input arguments to the pattern.\n+\n+   * TYPE_OUT: The type of the output of this pattern.\n+\n+   * Return value: A new stmt that will be used to replace the pattern.\n+\tAdditionally a def_stmt is added.\n+\n+\ta_it = x_t CMP y_t ? b_it : c_it;\n+\ta_T = (TYPE) a_it;  */\n+\n+static gimple\n+vect_recog_mixed_size_cond_pattern (VEC (gimple, heap) **stmts, tree *type_in,\n+\t\t\t\t    tree *type_out)\n+{\n+  gimple last_stmt = VEC_index (gimple, *stmts, 0);\n+  tree cond_expr, then_clause, else_clause;\n+  stmt_vec_info stmt_vinfo = vinfo_for_stmt (last_stmt), def_stmt_info;\n+  tree type, vectype, comp_vectype, itype, vecitype;\n+  enum machine_mode cmpmode;\n+  gimple pattern_stmt, def_stmt;\n+  loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_vinfo);\n+\n+  if (!is_gimple_assign (last_stmt)\n+      || gimple_assign_rhs_code (last_stmt) != COND_EXPR\n+      || STMT_VINFO_DEF_TYPE (stmt_vinfo) != vect_internal_def)\n+    return NULL;\n+\n+  cond_expr = gimple_assign_rhs1 (last_stmt);\n+  then_clause = gimple_assign_rhs2 (last_stmt);\n+  else_clause = gimple_assign_rhs3 (last_stmt);\n+\n+  if (TREE_CODE (then_clause) != INTEGER_CST\n+      || TREE_CODE (else_clause) != INTEGER_CST)\n+    return NULL;\n+\n+  if (!vect_is_simple_cond (cond_expr, loop_vinfo, &comp_vectype)\n+      || !comp_vectype)\n+    return NULL;\n+\n+  type = gimple_expr_type (last_stmt);\n+  cmpmode = GET_MODE_INNER (TYPE_MODE (comp_vectype));\n+\n+  if (GET_MODE_BITSIZE (TYPE_MODE (type)) == GET_MODE_BITSIZE (cmpmode))\n+    return NULL;\n+\n+  vectype = get_vectype_for_scalar_type (type);\n+  if (vectype == NULL_TREE)\n+    return NULL;\n+\n+  if (expand_vec_cond_expr_p (vectype, comp_vectype))\n+    return NULL;\n+\n+  itype = build_nonstandard_integer_type (GET_MODE_BITSIZE (cmpmode),\n+\t\t\t\t\t  TYPE_UNSIGNED (type));\n+  if (itype == NULL_TREE\n+      || GET_MODE_BITSIZE (TYPE_MODE (itype)) != GET_MODE_BITSIZE (cmpmode))\n+    return NULL;\n+\n+  vecitype = get_vectype_for_scalar_type (itype);\n+  if (vecitype == NULL_TREE)\n+    return NULL;\n+\n+  if (!expand_vec_cond_expr_p (vecitype, comp_vectype))\n+    return NULL;\n+\n+  if (GET_MODE_BITSIZE (TYPE_MODE (type)) > GET_MODE_BITSIZE (cmpmode))\n+    {\n+      if (!int_fits_type_p (then_clause, itype)\n+\t  || !int_fits_type_p (else_clause, itype))\n+\treturn NULL;\n+    }\n+\n+  def_stmt\n+    = gimple_build_assign_with_ops3 (COND_EXPR,\n+\t\t\t\t     vect_recog_temp_ssa_var (itype, NULL),\n+\t\t\t\t     unshare_expr (cond_expr),\n+\t\t\t\t     fold_convert (itype, then_clause),\n+\t\t\t\t     fold_convert (itype, else_clause));\n+  pattern_stmt\n+    = gimple_build_assign_with_ops (NOP_EXPR,\n+\t\t\t\t    vect_recog_temp_ssa_var (type, NULL),\n+\t\t\t\t    gimple_assign_lhs (def_stmt), NULL_TREE);\n+\n+  STMT_VINFO_PATTERN_DEF_STMT (stmt_vinfo) = def_stmt;\n+  def_stmt_info = new_stmt_vec_info (def_stmt, loop_vinfo, NULL);\n+  set_vinfo_for_stmt (def_stmt, def_stmt_info);\n+  STMT_VINFO_VECTYPE (def_stmt_info) = vecitype;\n+  *type_in = vecitype;\n+  *type_out = vectype;\n+\n+  return pattern_stmt;\n+}\n+\n+\n /* Mark statements that are involved in a pattern.  */\n \n static inline void\n@@ -1238,14 +1355,18 @@ vect_mark_pattern_stmts (gimple orig_stmt, gimple pattern_stmt,\n   if (STMT_VINFO_PATTERN_DEF_STMT (pattern_stmt_info))\n     {\n       def_stmt = STMT_VINFO_PATTERN_DEF_STMT (pattern_stmt_info);\n-      set_vinfo_for_stmt (def_stmt,\n-                          new_stmt_vec_info (def_stmt, loop_vinfo, NULL));\n-      gimple_set_bb (def_stmt, gimple_bb (orig_stmt));\n       def_stmt_info = vinfo_for_stmt (def_stmt);\n+      if (def_stmt_info == NULL)\n+\t{\n+\t  def_stmt_info = new_stmt_vec_info (def_stmt, loop_vinfo, NULL);\n+\t  set_vinfo_for_stmt (def_stmt, def_stmt_info);\n+\t}\n+      gimple_set_bb (def_stmt, gimple_bb (orig_stmt));\n       STMT_VINFO_RELATED_STMT (def_stmt_info) = orig_stmt;\n       STMT_VINFO_DEF_TYPE (def_stmt_info)\n \t= STMT_VINFO_DEF_TYPE (orig_stmt_info);\n-      STMT_VINFO_VECTYPE (def_stmt_info) = pattern_vectype;\n+      if (STMT_VINFO_VECTYPE (def_stmt_info) == NULL_TREE)\n+\tSTMT_VINFO_VECTYPE (def_stmt_info) = pattern_vectype;\n     }\n }\n "}, {"sha": "2110c9601573c700389ddb445c9d1b36c9b99f65", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69d2aade06017139c9e5be9c749f84d33766c1de/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69d2aade06017139c9e5be9c749f84d33766c1de/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=69d2aade06017139c9e5be9c749f84d33766c1de", "patch": "@@ -652,9 +652,25 @@ vect_mark_stmts_to_be_vectorized (loop_vec_info loop_vinfo)\n              have to scan the RHS or function arguments instead.  */\n           if (is_gimple_assign (stmt))\n             {\n-              for (i = 1; i < gimple_num_ops (stmt); i++)\n+\t      enum tree_code rhs_code = gimple_assign_rhs_code (stmt);\n+\t      tree op = gimple_assign_rhs1 (stmt);\n+\n+\t      i = 1;\n+\t      if (rhs_code == COND_EXPR && COMPARISON_CLASS_P (op))\n+\t\t{\n+\t\t  if (!process_use (stmt, TREE_OPERAND (op, 0), loop_vinfo,\n+\t\t\t\t    live_p, relevant, &worklist)\n+\t\t      || !process_use (stmt, TREE_OPERAND (op, 1), loop_vinfo,\n+\t\t\t\t       live_p, relevant, &worklist))\n+\t\t    {\n+\t\t      VEC_free (gimple, heap, worklist);\n+\t\t      return false;\n+\t\t    }\n+\t\t  i = 2;\n+\t\t}\n+\t      for (; i < gimple_num_ops (stmt); i++)\n                 {\n-                  tree op = gimple_op (stmt, i);\n+\t\t  op = gimple_op (stmt, i);\n                   if (!process_use (stmt, op, loop_vinfo, live_p, relevant,\n                                     &worklist))\n                     {\n@@ -4682,7 +4698,7 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n    Returns whether a COND can be vectorized.  Checks whether\n    condition operands are supportable using vec_is_simple_use.  */\n \n-static bool\n+bool\n vect_is_simple_cond (tree cond, loop_vec_info loop_vinfo, tree *comp_vectype)\n {\n   tree lhs, rhs;"}, {"sha": "27820820bd5be03bd80189011fd4ab5e86eb6886", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69d2aade06017139c9e5be9c749f84d33766c1de/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69d2aade06017139c9e5be9c749f84d33766c1de/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=69d2aade06017139c9e5be9c749f84d33766c1de", "patch": "@@ -1,5 +1,5 @@\n /* Vectorizer\n-   Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010\n+   Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011\n    Free Software Foundation, Inc.\n    Contributed by Dorit Naishlos <dorit@il.ibm.com>\n \n@@ -818,6 +818,7 @@ extern bool vect_transform_stmt (gimple, gimple_stmt_iterator *,\n                                  bool *, slp_tree, slp_instance);\n extern void vect_remove_stores (gimple);\n extern bool vect_analyze_stmt (gimple, bool *, slp_tree);\n+extern bool vect_is_simple_cond (tree, loop_vec_info, tree *);\n extern bool vectorizable_condition (gimple, gimple_stmt_iterator *, gimple *,\n                                     tree, int);\n extern void vect_get_load_cost (struct data_reference *, int, bool,\n@@ -902,7 +903,7 @@ extern void vect_slp_transform_bb (basic_block);\n    Additional pattern recognition functions can (and will) be added\n    in the future.  */\n typedef gimple (* vect_recog_func_ptr) (VEC (gimple, heap) **, tree *, tree *);\n-#define NUM_PATTERNS 5\n+#define NUM_PATTERNS 6\n void vect_pattern_recog (loop_vec_info);\n \n /* In tree-vectorizer.c.  */"}]}