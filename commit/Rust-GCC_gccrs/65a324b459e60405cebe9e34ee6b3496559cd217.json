{"sha": "65a324b459e60405cebe9e34ee6b3496559cd217", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjVhMzI0YjQ1OWU2MDQwNWNlYmU5ZTM0ZWU2YjM0OTY1NTljZDIxNw==", "commit": {"author": {"name": "Nick Clifton", "email": "nickc@redhat.com", "date": "2009-10-26T16:30:15Z"}, "committer": {"name": "Nick Clifton", "email": "nickc@gcc.gnu.org", "date": "2009-10-26T16:30:15Z"}, "message": "MAINTAINERS: Add myself as a maintainer for the RX port.\n\n        * MAINTAINERS: Add myself as a maintainer for the RX port.\n\ngcc\n        * config.gcc: Add support for RX target.\n        * config/rx: New directory.\n        * config/rx/constraints.md: New file.\n        * config/rx/predicates.md: New file.\n        * config/rx/rx.c: New file.\n        * config/rx/rx.h: New file.\n        * config/rx/rx.md: New file.\n        * config/rx/rx.opt: New file.\n        * config/rx/rx-protos.h: New file.\n        * config/rx/t-rx: New file.\n        * doc/extend.texi: Document RX function attributes.\n        * doc/invoke.texi: Document RX specific command line options.\n        * doc/contrib.texi: Document RX contribution.\n        * doc/md.texi: Document RX constraints.\n        * doc/install.texi: Document RX support.\n\nlibgcc\n        * config.host: Add support for RX target.\n        * config/rx: New directory.\n        * config/rx/rx-abi-functions.c: New file. Supplementary\n        functions for libgcc to support the RX ABI.\n        * config/rx/rx-abi.h: New file.  Supplementary header file for\n        libgcc RX ABI functions.\n        * config/rx/t-rx: New file: Makefile fragment for building\n        libgcc for the RX.\n\ngcc/testsuite\n        * lib/target-supports.exp (check_profiling_available):\n        Profiling is not, currently, available for the RX port.\n        (check_effective_target_hard_float): Add support for RX\n        target.\n        * gcc.target/rx: New directory.\n        * gcc.target/rx/builtins.c: New test file.\n        * gcc.target/rx/interrupts.c: New test file.\n        * gcc.target/rx/rx-abi-function-tests.c: New test file.\n        * gcc.target/rx/zero-width-bitfield.c: New test file.\n        * gcc.target/rx/i272091.c: New test file.\n        * gcc.target/rx/packed-struct.c: New test file.\n        * gcc.target/rx/rx.exp: New file: Drives RX tests.\n\nFrom-SVN: r153557", "tree": {"sha": "e1437bbfc9a877b53e0a37ddd53113c0601389c2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e1437bbfc9a877b53e0a37ddd53113c0601389c2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/65a324b459e60405cebe9e34ee6b3496559cd217", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65a324b459e60405cebe9e34ee6b3496559cd217", "html_url": "https://github.com/Rust-GCC/gccrs/commit/65a324b459e60405cebe9e34ee6b3496559cd217", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65a324b459e60405cebe9e34ee6b3496559cd217/comments", "author": {"login": "nickclifton", "id": 31441682, "node_id": "MDQ6VXNlcjMxNDQxNjgy", "avatar_url": "https://avatars.githubusercontent.com/u/31441682?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nickclifton", "html_url": "https://github.com/nickclifton", "followers_url": "https://api.github.com/users/nickclifton/followers", "following_url": "https://api.github.com/users/nickclifton/following{/other_user}", "gists_url": "https://api.github.com/users/nickclifton/gists{/gist_id}", "starred_url": "https://api.github.com/users/nickclifton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nickclifton/subscriptions", "organizations_url": "https://api.github.com/users/nickclifton/orgs", "repos_url": "https://api.github.com/users/nickclifton/repos", "events_url": "https://api.github.com/users/nickclifton/events{/privacy}", "received_events_url": "https://api.github.com/users/nickclifton/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "03428d41b13382c2772efba5d1d2582312afbd40", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03428d41b13382c2772efba5d1d2582312afbd40", "html_url": "https://github.com/Rust-GCC/gccrs/commit/03428d41b13382c2772efba5d1d2582312afbd40"}], "stats": {"total": 6607, "additions": 6578, "deletions": 29}, "files": [{"sha": "7c9bcf60b2b5e8b4dc1209c7188585ee3e88a011", "filename": "ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65a324b459e60405cebe9e34ee6b3496559cd217/ChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65a324b459e60405cebe9e34ee6b3496559cd217/ChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/ChangeLog?ref=65a324b459e60405cebe9e34ee6b3496559cd217", "patch": "@@ -1,3 +1,7 @@\n+2009-10-16  Nick Clifton  <nickc@redhat.com>\n+\n+\t* MAINTAINERS: Add myself as a maintainer for the RX port.\n+\n 2009-10-26  Johannes Singler <singler@kit.edu>\n \n         * MAINTAINERS (Write After Approval): Update my e-mail address."}, {"sha": "ed045813a06b1894f936873224b70041da9e47b5", "filename": "MAINTAINERS", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65a324b459e60405cebe9e34ee6b3496559cd217/MAINTAINERS", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65a324b459e60405cebe9e34ee6b3496559cd217/MAINTAINERS", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/MAINTAINERS?ref=65a324b459e60405cebe9e34ee6b3496559cd217", "patch": "@@ -82,6 +82,7 @@ picochip port\t\tDaniel Towner\t\tdant@picochip.com\n rs6000 port\t\tGeoff Keating\t\tgeoffk@geoffk.org\n rs6000 port\t\tDavid Edelsohn\t\tedelsohn@gnu.org\n rs6000 vector extns\tAldy Hernandez\t\taldyh@redhat.com\n+rx port\t      \t\tNick Clifton\t\tnickc@redhat.com\n s390 port\t\tHartmut Penner\t\thpenner@de.ibm.com\n s390 port\t\tUlrich Weigand\t\tuweigand@de.ibm.com\n s390 port\t\tAndreas Krebbel\t\tAndreas.Krebbel@de.ibm.com"}, {"sha": "ea4e772bfb250996e0991ed1454f37d58342f957", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65a324b459e60405cebe9e34ee6b3496559cd217/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65a324b459e60405cebe9e34ee6b3496559cd217/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=65a324b459e60405cebe9e34ee6b3496559cd217", "patch": "@@ -1,3 +1,21 @@\n+2009-10-26  Nick Clifton  <nickc@redhat.com>\n+\n+\t* config.gcc: Add support for RX target.\n+\t* config/rx: New directory.\n+\t* config/rx/constraints.md: New file.\n+\t* config/rx/predicates.md: New file.\n+\t* config/rx/rx.c: New file.\n+\t* config/rx/rx.h: New file.\n+\t* config/rx/rx.md: New file.\n+\t* config/rx/rx.opt: New file.\n+\t* config/rx/rx-protos.h: New file.\n+\t* config/rx/t-rx: New file.\n+\t* doc/extend.texi: Document RX function attributes.\n+\t* doc/invoke.texi: Document RX specific command line options.\n+\t* doc/contrib.texi: Document RX contribution.\n+\t* doc/md.texi: Document RX constraints.\n+\t* doc/install.texi: Document RX support.\n+\n 2009-10-26  Michael Matz  <matz@suse.de>\n \n \tPR tree-optimization/41783"}, {"sha": "7dac3004cd8fd5e5723175443b174dd03a747350", "filename": "gcc/config.gcc", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65a324b459e60405cebe9e34ee6b3496559cd217/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65a324b459e60405cebe9e34ee6b3496559cd217/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=65a324b459e60405cebe9e34ee6b3496559cd217", "patch": "@@ -287,7 +287,7 @@ i[34567]86-*-*)\n \textra_headers=\"cpuid.h mmintrin.h mm3dnow.h xmmintrin.h emmintrin.h\n \t\t       pmmintrin.h tmmintrin.h ammintrin.h smmintrin.h\n \t\t       nmmintrin.h bmmintrin.h fma4intrin.h wmmintrin.h\n-\t\t       immintrin.h x86intrin.h avxintrin.h \n+\t\t       immintrin.h x86intrin.h avxintrin.h\n \t\t       ia32intrin.h cross-stdarg.h\"\n \t;;\n x86_64-*-*)\n@@ -2077,6 +2077,10 @@ rs6000-ibm-aix[6789].* | powerpc-ibm-aix[6789].*)\n \tuse_gcc_stdint=wrap\n \textra_headers=altivec.h\n \t;;\n+rx-*-elf*)\n+\ttm_file=\"dbxelf.h elfos.h svr4.h newlib-stdint.h ${tm_file} ../../libgcc/config/rx/rx-abi.h\"\n+\ttmake_file=\"${tmake_file} rx/t-rx\"\n+\t;;\n s390-*-linux*)\n \ttm_file=\"s390/s390.h dbxelf.h elfos.h svr4.h linux.h glibc-stdint.h s390/linux.h\"\n \t;;"}, {"sha": "f15b586afb5403f364a19821b33c08bf452913b8", "filename": "gcc/config/rx/constraints.md", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65a324b459e60405cebe9e34ee6b3496559cd217/gcc%2Fconfig%2Frx%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65a324b459e60405cebe9e34ee6b3496559cd217/gcc%2Fconfig%2Frx%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frx%2Fconstraints.md?ref=65a324b459e60405cebe9e34ee6b3496559cd217", "patch": "@@ -0,0 +1,81 @@\n+;; Constraint definitions for Renesas RX.\n+;; Copyright (C) 2008, 2009 Free Software Foundation, Inc.\n+;; Contributed by Red Hat.\n+;;\n+;; This file is part of GCC.\n+;;\n+;; GCC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 3, or (at your option)\n+;; any later version.\n+;;\n+;; GCC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING3.  If not see\n+;; <http://www.gnu.org/licenses/>.\n+\n+\n+(define_constraint \"Symbol\"\n+  \"@internal Constraint on the type of rtx allowed in call insns\"\n+  (match_test \"GET_CODE (op) == SYMBOL_REF\")\n+)\n+\n+\n+(define_constraint \"Int08\"\n+  \"@internal A signed or unsigned 8-bit immediate value\"\n+  (and (match_code \"const_int\")\n+       (match_test \"IN_RANGE (ival, (-1 << 8), (1 << 8) - 1)\")\n+  )\n+)\n+\n+(define_constraint \"Sint08\"\n+  \"@internal A signed 8-bit immediate value\"\n+  (and (match_code \"const_int\")\n+       (match_test \"IN_RANGE (ival, (-1 << 7), (1 << 7) - 1)\")\n+  )\n+)\n+\n+(define_constraint \"Sint16\"\n+  \"@internal A signed 16-bit immediate value\"\n+  (and (match_code \"const_int\")\n+       (match_test \"IN_RANGE (ival, (-1 << 15), (1 << 15) - 1)\")\n+  )\n+)\n+\n+(define_constraint \"Sint24\"\n+  \"@internal A signed 24-bit immediate value\"\n+  (and (match_code \"const_int\")\n+       (match_test \"IN_RANGE (ival, (-1 << 23), (1 << 23) - 1)\")\n+  )\n+)\n+\n+;; This constraint is used by the SUBSI3 pattern because the\n+;; RX SUB instruction can only take a 4-bit unsigned integer\n+;; value.\n+(define_constraint \"Uint04\"\n+  \"@internal An unsigned 4-bit immediate value\"\n+  (and (match_code \"const_int\")\n+       (match_test \"IN_RANGE (ival, 0, 15)\")\n+  )\n+)\n+\n+;; This is used in arithmetic and logic instructions for\n+;; a source operand that lies in memory and which satisfies\n+;; rx_restricted_memory_address().\n+\n+(define_memory_constraint \"Q\"\n+  \"A MEM which only uses REG or REG+INT addressing.\"\n+  (and (match_code \"mem\")\n+       (ior (match_code \"reg\" \"0\")\n+\t    (and (match_code \"plus\" \"0\")\n+\t         (and (match_code \"reg,subreg\" \"00\")\n+\t\t      (match_code \"const_int\" \"01\")\n+\t\t )\n+\t    )\n+       )\n+  )\n+)"}, {"sha": "75cf8ebaed8234136fe412a39f1b6ff5549848fa", "filename": "gcc/config/rx/predicates.md", "status": "added", "additions": 282, "deletions": 0, "changes": 282, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65a324b459e60405cebe9e34ee6b3496559cd217/gcc%2Fconfig%2Frx%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65a324b459e60405cebe9e34ee6b3496559cd217/gcc%2Fconfig%2Frx%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frx%2Fpredicates.md?ref=65a324b459e60405cebe9e34ee6b3496559cd217", "patch": "@@ -0,0 +1,282 @@\n+;; Predicate definitions for Renesas RX.\n+;; Copyright (C) 2008, 2009 Free Software Foundation, Inc.\n+;; Contributed by Red Hat.\n+;;\n+;; This file is part of GCC.\n+;;\n+;; GCC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 3, or (at your option)\n+;; any later version.\n+;;\n+;; GCC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING3.  If not see\n+;; <http://www.gnu.org/licenses/>.\n+\n+\n+\n+;; Check that the operand is suitable for a call insn.\n+;; Only registers and symbol refs are allowed.\n+\n+(define_predicate \"rx_call_operand\"\n+  (match_code \"symbol_ref,reg\")\n+)\n+\n+;; For sibcall operations we can only use a symbolic address.\n+\n+(define_predicate \"rx_symbolic_call_operand\"\n+  (match_code \"symbol_ref\")\n+)\n+\n+;; Check that the operand is suitable for a shift insn\n+;; Only small integers or a value in a register are permitted.\n+\n+(define_predicate \"rx_shift_operand\"\n+  (match_code \"const_int,reg\")\n+  {\n+    if (CONST_INT_P (op))\n+      return IN_RANGE (INTVAL (op), 0, 31);\n+    return true;\n+  }\n+)\n+\n+;; Check that the operand is suitable as the source operand\n+;; for a logic or arithmeitc instruction.  Registers, integers\n+;; and a restricted subset of memory addresses are allowed.\n+\n+(define_predicate \"rx_source_operand\"\n+  (match_code \"const_int,reg,mem\")\n+  {\n+    if (CONST_INT_P (op))\n+      return rx_is_legitimate_constant (op);\n+\n+    if (! MEM_P (op))\n+      return true;\n+      \n+    /* Do not allow size conversions whilst accessing memory.  */\n+    if (GET_MODE (op) != mode)\n+      return false;\n+\n+    return rx_is_restricted_memory_address (XEXP (op, 0), mode);\n+  }\n+)\n+\n+;; Check that the operand is suitable as the source operand\n+;; for a comparison instruction.  This is the same as\n+;; rx_source_operand except that SUBREGs are allowed but\n+;; CONST_INTs are not.\n+\n+(define_predicate \"rx_compare_operand\"\n+  (match_code \"subreg,reg,mem\")\n+  {\n+    if (GET_CODE (op) == SUBREG)\n+      return REG_P (XEXP (op, 0));\n+    \n+    if (! MEM_P (op))\n+      return true;\n+\n+    return rx_is_restricted_memory_address (XEXP (op, 0), mode);\n+  }\n+)\n+\n+;; Return true if OP is a store multiple operation.  This looks like:\n+;;\n+;;   [(set (SP) (MINUS (SP) (INT)))\n+;;    (set (MEM (SP)) (REG))\n+;;    (set (MEM (MINUS (SP) (INT))) (REG)) {optionally repeated}\n+;;   ]\n+\n+(define_special_predicate \"rx_store_multiple_vector\"\n+  (match_code \"parallel\")\n+{\n+  int count = XVECLEN (op, 0);\n+  unsigned int src_regno;\n+  rtx element;\n+  int i;\n+\n+  /* Perform a quick check so we don't blow up below.  */\n+  if (count <= 2)\n+    return false;\n+\n+  /* Check that the first element of the vector is the stack adjust.  */\n+  element = XVECEXP (op, 0, 0);\n+  if (   ! SET_P (element)\n+      || ! REG_P (SET_DEST (element))\n+      ||   REGNO (SET_DEST (element)) != SP_REG\n+      ||   GET_CODE (SET_SRC (element)) != MINUS\n+      || ! REG_P (XEXP (SET_SRC (element), 0))\n+      ||   REGNO (XEXP (SET_SRC (element), 0)) != SP_REG\n+      || ! CONST_INT_P (XEXP (SET_SRC (element), 1)))\n+    return false;\n+\t \n+  /* Check that the next element is the first push.  */\n+  element = XVECEXP (op, 0, 1);\n+  if (   ! SET_P (element)\n+      || ! MEM_P (SET_DEST (element))\n+      || ! REG_P (XEXP (SET_DEST (element), 0))\n+      ||   REGNO (XEXP (SET_DEST (element), 0)) != SP_REG\n+      || ! REG_P (SET_SRC (element)))\n+    return false;\n+\n+  src_regno = REGNO (SET_SRC (element));\n+\n+  /* Check that the remaining elements use SP-<disp>\n+     addressing and incremental register numbers.  */\n+  for (i = 2; i < count; i++)\n+    {\n+      element = XVECEXP (op, 0, i);\n+\n+      if (   ! SET_P (element)\n+\t  || ! REG_P (SET_SRC (element))\n+\t  || GET_MODE (SET_SRC (element)) != SImode\n+\t  || REGNO (SET_SRC (element)) != src_regno + (i - 1)\n+\t  || ! MEM_P (SET_DEST (element))\n+\t  || GET_MODE (SET_DEST (element)) != SImode\n+\t  || GET_CODE (XEXP (SET_DEST (element), 0)) != MINUS\n+          || ! REG_P (XEXP (XEXP (SET_DEST (element), 0), 0))\n+          ||   REGNO (XEXP (XEXP (SET_DEST (element), 0), 0)) != SP_REG\n+\t  || ! CONST_INT_P (XEXP (XEXP (SET_DEST (element), 0), 1))\n+\t  || INTVAL (XEXP (XEXP (SET_DEST (element), 0), 1))\n+\t     != (i - 1) * GET_MODE_SIZE (SImode))\n+\treturn false;\n+    }\n+  return true;\n+})\n+\n+;; Return true if OP is a load multiple operation.\n+;; This looks like:\n+;;  [(set (SP) (PLUS (SP) (INT)))\n+;;   (set (REG) (MEM (SP)))\n+;;   (set (REG) (MEM (PLUS (SP) (INT)))) {optionally repeated}\n+;;  ]\n+\n+(define_special_predicate \"rx_load_multiple_vector\"\n+  (match_code \"parallel\")\n+{\n+  int count = XVECLEN (op, 0);\n+  unsigned int dest_regno;\n+  rtx element;\n+  int i;\n+\n+  /* Perform a quick check so we don't blow up below.  */\n+  if (count <= 2)\n+    return false;\n+\n+  /* Check that the first element of the vector is the stack adjust.  */\n+  element = XVECEXP (op, 0, 0);\n+  if (   ! SET_P (element)\n+      || ! REG_P (SET_DEST (element))\n+      ||   REGNO (SET_DEST (element)) != SP_REG\n+      ||   GET_CODE (SET_SRC (element)) != PLUS\n+      || ! REG_P (XEXP (SET_SRC (element), 0))\n+      ||   REGNO (XEXP (SET_SRC (element), 0)) != SP_REG\n+      || ! CONST_INT_P (XEXP (SET_SRC (element), 1)))\n+    return false;\n+\t \n+  /* Check that the next element is the first push.  */\n+  element = XVECEXP (op, 0, 1);\n+  if (   ! SET_P (element)\n+      || ! REG_P (SET_DEST (element))\n+      || ! MEM_P (SET_SRC (element))\n+      || ! REG_P (XEXP (SET_SRC (element), 0))\n+      ||   REGNO (XEXP (SET_SRC (element), 0)) != SP_REG)\n+    return false;\n+\n+  dest_regno = REGNO (SET_DEST (element));\n+\n+  /* Check that the remaining elements use SP+<disp>\n+     addressing and incremental register numbers.  */\n+  for (i = 2; i < count; i++)\n+    {\n+      element = XVECEXP (op, 0, i);\n+\n+      if (   ! SET_P (element)\n+\t  || ! REG_P (SET_DEST (element))\n+\t  || GET_MODE (SET_DEST (element)) != SImode\n+\t  || REGNO (SET_DEST (element)) != dest_regno + (i - 1)\n+\t  || ! MEM_P (SET_SRC (element))\n+\t  || GET_MODE (SET_SRC (element)) != SImode\n+\t  || GET_CODE (XEXP (SET_SRC (element), 0)) != PLUS\n+          || ! REG_P (XEXP (XEXP (SET_SRC (element), 0), 0))\n+          ||   REGNO (XEXP (XEXP (SET_SRC (element), 0), 0)) != SP_REG\n+\t  || ! CONST_INT_P (XEXP (XEXP (SET_SRC (element), 0), 1))\n+\t  || INTVAL (XEXP (XEXP (SET_SRC (element), 0), 1))\n+\t     != (i - 1) * GET_MODE_SIZE (SImode))\n+\treturn false;\n+    }\n+  return true;\n+})\n+\n+;; Return true if OP is a pop-and-return load multiple operation.\n+;; This looks like:\n+;;  [(set (SP) (PLUS (SP) (INT)))\n+;;   (set (REG) (MEM (SP)))\n+;;   (set (REG) (MEM (PLUS (SP) (INT)))) {optional and possibly repeated}\n+;;   (return)\n+;;  ]\n+\n+(define_special_predicate \"rx_rtsd_vector\"\n+  (match_code \"parallel\")\n+{\n+  int count = XVECLEN (op, 0);\n+  unsigned int dest_regno;\n+  rtx element;\n+  int i;\n+\n+  /* Perform a quick check so we don't blow up below.  */\n+  if (count <= 2)\n+    return false;\n+\n+  /* Check that the first element of the vector is the stack adjust.  */\n+  element = XVECEXP (op, 0, 0);\n+  if (   ! SET_P (element)\n+      || ! REG_P (SET_DEST (element))\n+      ||   REGNO (SET_DEST (element)) != SP_REG\n+      ||   GET_CODE (SET_SRC (element)) != PLUS\n+      || ! REG_P (XEXP (SET_SRC (element), 0))\n+      ||   REGNO (XEXP (SET_SRC (element), 0)) != SP_REG\n+      || ! CONST_INT_P (XEXP (SET_SRC (element), 1)))\n+    return false;\n+\t \n+  /* Check that the next element is the first push.  */\n+  element = XVECEXP (op, 0, 1);\n+  if (   ! SET_P (element)\n+      || ! REG_P (SET_DEST (element))\n+      || ! MEM_P (SET_SRC (element))\n+      || ! REG_P (XEXP (SET_SRC (element), 0))\n+      ||   REGNO (XEXP (SET_SRC (element), 0)) != SP_REG)\n+    return false;\n+\n+  dest_regno = REGNO (SET_DEST (element));\n+\n+  /* Check that the remaining elements, if any, and except\n+     for the last one, use SP+<disp> addressing and incremental\n+     register numbers.  */\n+  for (i = 2; i < count - 1; i++)\n+    {\n+      element = XVECEXP (op, 0, i);\n+\n+      if (   ! SET_P (element)\n+\t  || ! REG_P (SET_DEST (element))\n+\t  || GET_MODE (SET_DEST (element)) != SImode\n+\t  || REGNO (SET_DEST (element)) != dest_regno + (i - 1)\n+\t  || ! MEM_P (SET_SRC (element))\n+\t  || GET_MODE (SET_SRC (element)) != SImode\n+\t  || GET_CODE (XEXP (SET_SRC (element), 0)) != PLUS\n+          || ! REG_P (XEXP (XEXP (SET_SRC (element), 0), 0))\n+          ||   REGNO (XEXP (XEXP (SET_SRC (element), 0), 0)) != SP_REG\n+\t  || ! CONST_INT_P (XEXP (XEXP (SET_SRC (element), 0), 1))\n+\t  || INTVAL (XEXP (XEXP (SET_SRC (element), 0), 1))\n+\t     != (i - 1) * GET_MODE_SIZE (SImode))\n+\treturn false;\n+    }\n+\n+  /* The last element must be a RETURN.  */    \n+  element = XVECEXP (op, 0, count - 1);\n+  return GET_CODE (element) == RETURN;\n+})"}, {"sha": "5c37fe0a83c6b6d728c238ded0c8b6d619b0146e", "filename": "gcc/config/rx/rx-protos.h", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65a324b459e60405cebe9e34ee6b3496559cd217/gcc%2Fconfig%2Frx%2Frx-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65a324b459e60405cebe9e34ee6b3496559cd217/gcc%2Fconfig%2Frx%2Frx-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frx%2Frx-protos.h?ref=65a324b459e60405cebe9e34ee6b3496559cd217", "patch": "@@ -0,0 +1,52 @@\n+/* Exported function prototypes from the Renesas RX backend.\n+   Copyright (C) 2008, 2009 Free Software Foundation, Inc.\n+   Contributed by Red Hat.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   GCC is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_RX_PROTOS_H\n+#define GCC_RX_PROTOS_H\n+\n+/* A few abbreviations to make the prototypes shorter.  */\n+#define Mmode \tenum machine_mode\n+#define Fargs\tCUMULATIVE_ARGS\n+\f\n+extern void\t\trx_conditional_register_usage (void);\n+extern void\t\trx_expand_prologue (void);\n+extern int\t\trx_initial_elimination_offset (int, int);\n+\n+#ifdef RTX_CODE\n+extern void             rx_emit_stack_popm (rtx *, bool);\n+extern void             rx_emit_stack_pushm (rtx *);\n+extern void\t\trx_expand_epilogue (bool);\n+extern bool\t\trx_expand_insv (rtx *);\n+extern const char *\trx_gen_cond_branch_template (rtx, bool);\n+extern char *\t\trx_gen_move_template (rtx *, bool);\n+extern bool\t\trx_is_legitimate_constant (rtx);\n+extern bool \t\trx_is_mode_dependent_addr (rtx);\n+extern bool\t\trx_is_restricted_memory_address (rtx, Mmode);\n+extern void\t\trx_notice_update_cc (rtx body, rtx insn);\n+extern void\t\trx_print_operand (FILE *, rtx, int);\n+extern void\t\trx_print_operand_address (FILE *, rtx);\n+#endif\n+\n+#ifdef TREE_CODE\n+extern unsigned int     rx_function_arg_size (Mmode, const_tree);\n+extern struct rtx_def * rx_function_arg (Fargs *, Mmode, const_tree, bool);\n+#endif\n+\n+#endif /* GCC_RX_PROTOS_H */"}, {"sha": "cf2b098e83cf989c22e67d7e54859d6353fbf439", "filename": "gcc/config/rx/rx.c", "status": "added", "additions": 2363, "deletions": 0, "changes": 2363, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65a324b459e60405cebe9e34ee6b3496559cd217/gcc%2Fconfig%2Frx%2Frx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65a324b459e60405cebe9e34ee6b3496559cd217/gcc%2Fconfig%2Frx%2Frx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frx%2Frx.c?ref=65a324b459e60405cebe9e34ee6b3496559cd217", "patch": "@@ -0,0 +1,2363 @@\n+/* Subroutines used for code generation on Renesas RX processors.\n+   Copyright (C) 2008, 2009 Free Software Foundation, Inc.\n+   Contributed by Red Hat.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   GCC is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+/* To Do:\n+\n+ * Re-enable memory-to-memory copies and fix up reload.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"tree.h\"\n+#include \"rtl.h\"\n+#include \"regs.h\"\n+#include \"hard-reg-set.h\"\n+#include \"real.h\"\n+#include \"insn-config.h\"\n+#include \"conditions.h\"\n+#include \"output.h\"\n+#include \"insn-attr.h\"\n+#include \"flags.h\"\n+#include \"function.h\"\n+#include \"expr.h\"\n+#include \"optabs.h\"\n+#include \"libfuncs.h\"\n+#include \"recog.h\"\n+#include \"toplev.h\"\n+#include \"reload.h\"\n+#include \"df.h\"\n+#include \"ggc.h\"\n+#include \"tm_p.h\"\n+#include \"debug.h\"\n+#include \"target.h\"\n+#include \"target-def.h\"\n+#include \"langhooks.h\"\n+\f\n+/* Return true if OP is a reference to an object in a small data area.  */\n+\n+static bool\n+rx_small_data_operand (rtx op)\n+{\n+  if (rx_small_data_limit == 0)\n+    return false;\n+\n+  if (GET_CODE (op) == SYMBOL_REF)\n+    return SYMBOL_REF_SMALL_P (op);\n+\n+  return false;\n+}\n+\n+static bool\n+rx_is_legitimate_address (Mmode mode, rtx x, bool strict ATTRIBUTE_UNUSED)\n+{\n+  if (RTX_OK_FOR_BASE (x, strict))\n+    /* Register Indirect.  */\n+    return true;\n+\n+  if (GET_MODE_SIZE (mode) == 4\n+      && (GET_CODE (x) == PRE_DEC || GET_CODE (x) == POST_INC))\n+    /* Pre-decrement Register Indirect or\n+       Post-increment Register Indirect.  */\n+    return RTX_OK_FOR_BASE (XEXP (x, 0), strict);\n+\n+  if (GET_CODE (x) == PLUS)\n+    {\n+      rtx arg1 = XEXP (x, 0);\n+      rtx arg2 = XEXP (x, 1);\n+      rtx index = NULL_RTX;\n+\n+      if (REG_P (arg1) && RTX_OK_FOR_BASE (arg1, strict))\n+\tindex = arg2;\n+      else if (REG_P (arg2) && RTX_OK_FOR_BASE (arg2, strict))\n+\tindex = arg1;\n+      else\n+\treturn false;\n+\n+      switch (GET_CODE (index))\n+\t{\n+\tcase CONST_INT:\n+\t  {\n+\t    /* Register Relative: REG + INT.\n+\t       Only positive, mode-aligned, mode-sized\n+\t       displacements are allowed.  */\n+\t    HOST_WIDE_INT val = INTVAL (index);\n+\t    int factor;\n+\n+\t    if (val < 0)\n+\t      return false;\n+\t    \n+\t    switch (GET_MODE_SIZE (mode))\n+\t      {\n+\t      default: \n+\t      case 4: factor = 4; break;\n+\t      case 2: factor = 2; break;\n+\t      case 1: factor = 1; break;\n+\t      }\n+\n+\t    if (val > (65535 * factor))\n+\t      return false;\n+\t    return (val % factor) == 0;\n+\t  }\n+\n+\tcase REG:\n+\t  /* Unscaled Indexed Register Indirect: REG + REG\n+\t     Size has to be \"QI\", REG has to be valid.  */\n+\t  return GET_MODE_SIZE (mode) == 1 && RTX_OK_FOR_BASE (index, strict);\n+\n+\tcase MULT:\n+\t  {\n+\t    /* Scaled Indexed Register Indirect: REG + (REG * FACTOR)\n+\t       Factor has to equal the mode size, REG has to be valid.  */\n+\t    rtx factor;\n+\n+\t    factor = XEXP (index, 1);\n+\t    index = XEXP (index, 0);\n+\n+\t    return REG_P (index)\n+\t      && RTX_OK_FOR_BASE (index, strict)\n+\t      && CONST_INT_P (factor)\n+\t      && GET_MODE_SIZE (mode) == INTVAL (factor);\n+\t  }\n+\n+\tdefault:\n+\t  return false;\n+\t}\n+    }\n+\n+  /* Small data area accesses turn into register relative offsets.  */\n+  return rx_small_data_operand (x);\n+}\n+\n+/* Returns TRUE for simple memory addreses, ie ones\n+   that do not involve register indirect addressing\n+   or pre/post increment/decrement.  */\n+\n+bool\n+rx_is_restricted_memory_address (rtx mem, enum machine_mode mode)\n+{\n+  rtx base, index;\n+\n+  if (! rx_is_legitimate_address\n+      (mode, mem, reload_in_progress || reload_completed))\n+    return false;\n+\n+  switch (GET_CODE (mem))\n+    {\n+    case REG:\n+      /* Simple memory addresses are OK.  */\n+      return true;\n+\n+    case PRE_DEC:\n+    case POST_INC:\n+      return false;\n+\n+    case PLUS:\n+      /* Only allow REG+INT addressing.  */\n+      base = XEXP (mem, 0);\n+      index = XEXP (mem, 1);\n+\n+      return RX_REG_P (base) && CONST_INT_P (index);\n+\n+    case SYMBOL_REF:\n+      /* Can happen when small data is being supported.\n+         Assume that it will be resolved into GP+INT.  */\n+      return true;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n+bool\n+rx_is_mode_dependent_addr (rtx addr)\n+{\n+  if (GET_CODE (addr) == CONST)\n+    addr = XEXP (addr, 0);\n+\n+  switch (GET_CODE (addr))\n+    {\n+      /* --REG and REG++ only work in SImode.  */\n+    case PRE_DEC:\n+    case POST_INC:\n+      return true;\n+\n+    case MINUS:\n+    case PLUS:\n+      if (! REG_P (XEXP (addr, 0)))\n+\treturn true;\n+\n+      addr = XEXP (addr, 1);\n+\n+      switch (GET_CODE (addr))\n+\t{\n+\tcase REG:\n+\t  /* REG+REG only works in SImode.  */\n+\t  return true;\n+\n+\tcase CONST_INT:\n+\t  /* REG+INT is only mode independent if INT is a\n+\t     multiple of 4, positive and will fit into 8-bits.  */\n+\t  if (((INTVAL (addr) & 3) == 0)\n+\t      && IN_RANGE (INTVAL (addr), 4, 252))\n+\t    return false;\n+\t  return true;\n+\n+\tcase SYMBOL_REF:\n+\tcase LABEL_REF:\n+\t  return true;\n+\n+\tcase MULT:\n+\t  gcc_assert (REG_P (XEXP (addr, 0)));\n+\t  gcc_assert (CONST_INT_P (XEXP (addr, 1)));\n+\t  /* REG+REG*SCALE is always mode dependent.  */\n+\t  return true;\n+\n+\tdefault:\n+\t  /* Not recognized, so treat as mode dependent.  */\n+\t  return true;\n+\t}\n+\n+    case CONST_INT:\n+    case SYMBOL_REF:\n+    case LABEL_REF:\n+    case REG:\n+      /* These are all mode independent.  */\n+      return false;\n+\n+    default:\n+      /* Everything else is unrecognized,\n+\t so treat as mode dependent.  */\n+      return true;\n+    }\n+}\n+\f\n+\n+/* A C compound statement to output to stdio stream FILE the\n+   assembler syntax for an instruction operand that is a memory\n+   reference whose address is ADDR.  */\n+\n+void\n+rx_print_operand_address (FILE * file, rtx addr)\n+{\n+  switch (GET_CODE (addr))\n+    {\n+    case REG:\n+      fprintf (file, \"[\");\n+      rx_print_operand (file, addr, 0);\n+      fprintf (file, \"]\");\n+      break;\n+\n+    case PRE_DEC:\n+      fprintf (file, \"[-\");\n+      rx_print_operand (file, XEXP (addr, 0), 0);\n+      fprintf (file, \"]\");\n+      break;\n+\n+    case POST_INC:\n+      fprintf (file, \"[\");\n+      rx_print_operand (file, XEXP (addr, 0), 0);\n+      fprintf (file, \"+]\");\n+      break;\n+\n+    case PLUS:\n+      {\n+\trtx arg1 = XEXP (addr, 0);\n+\trtx arg2 = XEXP (addr, 1);\n+\trtx base, index;\n+\n+\tif (REG_P (arg1) && RTX_OK_FOR_BASE (arg1, true))\n+\t  base = arg1, index = arg2;\n+\telse if (REG_P (arg2) && RTX_OK_FOR_BASE (arg2, true))\n+\t  base = arg2, index = arg1;\n+\telse\n+\t  {\n+\t    rx_print_operand (file, arg1, 0);\n+\t    fprintf (file, \" + \");\n+\t    rx_print_operand (file, arg2, 0);\n+\t    break;\n+\t  }\n+\n+\tif (REG_P (index) || GET_CODE (index) == MULT)\n+\t  {\n+\t    fprintf (file, \"[\");\n+\t    rx_print_operand (file, index, 'A');\n+\t    fprintf (file, \",\");\n+\t  }\n+\telse /* GET_CODE (index) == CONST_INT  */\n+\t  {\n+\t    rx_print_operand (file, index, 'A');\n+\t    fprintf (file, \"[\");\n+\t  }\n+\trx_print_operand (file, base, 0);\n+\tfprintf (file, \"]\");\n+\tbreak;\n+      }\n+\n+    case LABEL_REF:\n+    case SYMBOL_REF:\n+    case CONST:\n+      fprintf (file, \"#\");\n+    default:\n+      output_addr_const (file, addr);\n+      break;\n+    }\n+}\n+\n+static void\n+rx_print_integer (FILE * file, HOST_WIDE_INT val)\n+{\n+  if (IN_RANGE (val, -64, 64))\n+    fprintf (file, HOST_WIDE_INT_PRINT_DEC, val);\n+  else\n+    fprintf (file,\n+\t     TARGET_AS100_SYNTAX\n+\t     ? \"0%\" HOST_WIDE_INT_PRINT \"xH\" : HOST_WIDE_INT_PRINT_HEX,\n+\t     val);\n+}\n+\n+static bool\n+rx_assemble_integer (rtx x, unsigned int size, int is_aligned)\n+{\n+  const char *  op = integer_asm_op (size, is_aligned);\n+\n+  if (! CONST_INT_P (x))\n+    return default_assemble_integer (x, size, is_aligned);\n+\n+  if (op == NULL)\n+    return false;\n+  fputs (op, asm_out_file);\n+\n+  rx_print_integer (asm_out_file, INTVAL (x));\n+  fputc ('\\n', asm_out_file);\n+  return true;\n+}\n+\n+\n+int rx_float_compare_mode;\n+\n+/* Handles the insertion of a single operand into the assembler output.\n+   The %<letter> directives supported are:\n+\n+     %A  Print an operand without a leading # character.\n+     %B  Print an integer comparison name.\n+     %C  Print a control register name.\n+     %F  Print a condition code flag name.\n+     %H  Print high part of a DImode register, integer or address.\n+     %L  Print low part of a DImode register, integer or address.\n+     %Q  If the operand is a MEM, then correctly generate\n+         register indirect or register relative addressing.  */\n+\n+void\n+rx_print_operand (FILE * file, rtx op, int letter)\n+{\n+  switch (letter)\n+    {\n+    case 'A':\n+      /* Print an operand without a leading #.  */\n+      if (MEM_P (op))\n+\top = XEXP (op, 0);\n+\n+      switch (GET_CODE (op))\n+\t{\n+\tcase LABEL_REF:\n+\tcase SYMBOL_REF:\n+\t  output_addr_const (file, op);\n+\t  break;\n+\tcase CONST_INT:\n+\t  fprintf (file, \"%ld\", (long) INTVAL (op));\n+\t  break;\n+\tdefault:\n+\t  rx_print_operand (file, op, 0);\n+\t  break;\n+\t}\n+      break;\n+\n+    case 'B':\n+      switch (GET_CODE (op))\n+\t{\n+\tcase LT:  fprintf (file, \"lt\"); break;\n+\tcase GE:  fprintf (file, \"ge\"); break;\n+\tcase GT:  fprintf (file, \"gt\"); break;\n+\tcase LE:  fprintf (file, \"le\"); break;\n+\tcase GEU: fprintf (file, \"geu\"); break;\n+\tcase LTU: fprintf (file, \"ltu\"); break;\n+\tcase GTU: fprintf (file, \"gtu\"); break;\n+\tcase LEU: fprintf (file, \"leu\"); break;\n+\tcase EQ:  fprintf (file, \"eq\"); break;\n+\tcase NE:  fprintf (file, \"ne\"); break;\n+\tdefault:  debug_rtx (op); gcc_unreachable ();\n+\t}\n+      break;\n+\n+    case 'C':\n+      gcc_assert (CONST_INT_P (op));\n+      switch (INTVAL (op))\n+\t{\n+\tcase 0:   fprintf (file, \"psw\"); break;\n+\tcase 2:   fprintf (file, \"usp\"); break;\n+\tcase 3:   fprintf (file, \"fpsw\"); break;\n+\tcase 4:   fprintf (file, \"cpen\"); break;\n+\tcase 8:   fprintf (file, \"bpsw\"); break;\n+\tcase 9:   fprintf (file, \"bpc\"); break;\n+\tcase 0xa: fprintf (file, \"isp\"); break;\n+\tcase 0xb: fprintf (file, \"fintv\"); break;\n+\tcase 0xc: fprintf (file, \"intb\"); break;\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+      break;\n+\n+    case 'F':\n+      gcc_assert (CONST_INT_P (op));\n+      switch (INTVAL (op))\n+\t{\n+\tcase 0: case 'c': case 'C': fprintf (file, \"C\"); break;\n+\tcase 1:\tcase 'z': case 'Z': fprintf (file, \"Z\"); break;\n+\tcase 2: case 's': case 'S': fprintf (file, \"S\"); break;\n+\tcase 3: case 'o': case 'O': fprintf (file, \"O\"); break;\n+\tcase 8: case 'i': case 'I': fprintf (file, \"I\"); break;\n+\tcase 9: case 'u': case 'U': fprintf (file, \"U\"); break;\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+      break;\n+\n+    case 'H':\n+      if (REG_P (op))\n+\tfprintf (file, \"%s\", reg_names [REGNO (op) + (WORDS_BIG_ENDIAN ? 0 : 1)]);\n+      else if (CONST_INT_P (op))\n+\t{\n+\t  fprintf (file, \"#\");\n+\t  rx_print_integer (file, INTVAL (op) >> 32);\n+\t}\n+      else\n+\t{\n+\t  gcc_assert (MEM_P (op));\n+\n+\t  if (! WORDS_BIG_ENDIAN)\n+\t    op = adjust_address (op, SImode, 4);\n+\t  output_address (XEXP (op, 0));\n+\t}\n+      break;\n+\n+    case 'L':\n+      if (REG_P (op))\n+\tfprintf (file, \"%s\", reg_names [REGNO (op) + (WORDS_BIG_ENDIAN ? 1 : 0)]);\n+      else if (CONST_INT_P (op))\n+\t{\n+\t  fprintf (file, \"#\");\n+\t  rx_print_integer (file, INTVAL (op) & 0xffffffff);\n+\t}\n+      else\n+\t{\n+\t  gcc_assert (MEM_P (op));\n+\n+\t  if (WORDS_BIG_ENDIAN)\n+\t    op = adjust_address (op, SImode, 4);\n+\t  output_address (XEXP (op, 0));\n+\t}\n+      break;\n+\n+    case 'Q':\n+      if (MEM_P (op))\n+\t{\n+\t  HOST_WIDE_INT offset;\n+\n+\t  op = XEXP (op, 0);\n+\n+\t  if (REG_P (op))\n+\t    offset = 0;\n+\t  else if (GET_CODE (op) == PLUS)\n+\t    {\n+\t      rtx displacement;\n+\n+\t      if (REG_P (XEXP (op, 0)))\n+\t\t{\n+\t\t  displacement = XEXP (op, 1);\n+\t\t  op = XEXP (op, 0);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  displacement = XEXP (op, 0);\n+\t\t  op = XEXP (op, 1);\n+\t\t  gcc_assert (REG_P (op));\n+\t\t}\n+\n+\t      gcc_assert (CONST_INT_P (displacement));\n+\t      offset = INTVAL (displacement);\n+\t      gcc_assert (offset >= 0);\n+\n+\t      fprintf (file, \"%ld\", offset);\n+\t    }\n+\t  else\n+\t    gcc_unreachable ();\n+\n+\t  fprintf (file, \"[\");\n+\t  rx_print_operand (file, op, 0);\n+\t  fprintf (file, \"].\");\n+\n+\t  switch (GET_MODE_SIZE (GET_MODE (op)))\n+\t    {\n+\t    case 1:\n+\t      gcc_assert (offset < 65535 * 1);\n+\t      fprintf (file, \"B\");\n+\t      break;\n+\t    case 2:\n+\t      gcc_assert (offset % 2 == 0);\n+\t      gcc_assert (offset < 65535 * 2);\n+\t      fprintf (file, \"W\");\n+\t      break;\n+\t    default:\n+\t      gcc_assert (offset % 4 == 0);\n+\t      gcc_assert (offset < 65535 * 4);\n+\t      fprintf (file, \"L\");\n+\t      break;\n+\t    }\n+\t  break;\n+\t}\n+\n+      /* Fall through.  */\n+\n+    default:\n+      switch (GET_CODE (op))\n+\t{\n+\tcase MULT:\n+\t  /* Should be the scaled part of an\n+\t     indexed register indirect address.  */\n+\t  {\n+\t    rtx base = XEXP (op, 0);\n+\t    rtx index = XEXP (op, 1);\n+\n+\t    /* Check for a swaped index register and scaling factor.\n+\t       Not sure if this can happen, but be prepared to handle it.  */\n+\t    if (CONST_INT_P (base) && REG_P (index))\n+\t      {\n+\t\trtx tmp = base;\n+\t\tbase = index;\n+\t\tindex = tmp;\n+\t      }\n+\n+\t    gcc_assert (REG_P (base));\n+\t    gcc_assert (REGNO (base) < FIRST_PSEUDO_REGISTER);\n+\t    gcc_assert (CONST_INT_P (index));\n+\t    /* Do not try to verify the value of the scalar as it is based\n+\t       on the mode of the MEM not the mode of the MULT.  (Which\n+\t       will always be SImode).  */\n+\t    fprintf (file, \"%s\", reg_names [REGNO (base)]);\n+\t    break;\n+\t  }\n+\n+\tcase MEM:\n+\t  output_address (XEXP (op, 0));\n+\t  break;\n+\n+\tcase PLUS:\n+\t  output_address (op);\n+\t  break;\n+\n+\tcase REG:\n+\t  gcc_assert (REGNO (op) < FIRST_PSEUDO_REGISTER);\n+\t  fprintf (file, \"%s\", reg_names [REGNO (op)]);\n+\t  break;\n+\n+\tcase SUBREG:\n+\t  gcc_assert (subreg_regno (op) < FIRST_PSEUDO_REGISTER);\n+\t  fprintf (file, \"%s\", reg_names [subreg_regno (op)]);\n+\t  break;\n+\n+\t  /* This will only be single precision....  */\n+\tcase CONST_DOUBLE:\n+\t  {\n+\t    unsigned long val;\n+\t    REAL_VALUE_TYPE rv;\n+\n+\t    REAL_VALUE_FROM_CONST_DOUBLE (rv, op);\n+\t    REAL_VALUE_TO_TARGET_SINGLE (rv, val);\n+\t    fprintf (file, TARGET_AS100_SYNTAX ? \"#0%lxH\" : \"#0x%lx\", val);\n+\t    break;\n+\t  }\n+\n+\tcase CONST_INT:\n+\t  fprintf (file, \"#\");\n+\t  rx_print_integer (file, INTVAL (op));\n+\t  break;\n+\n+\tcase SYMBOL_REF:\n+\tcase CONST:\n+\tcase LABEL_REF:\n+\tcase CODE_LABEL:\n+\tcase UNSPEC:\n+\t  rx_print_operand_address (file, op);\n+\t  break;\n+\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+      break;\n+    }\n+}\n+\n+/* Returns an assembler template for a move instruction.  */\n+\n+char *\n+rx_gen_move_template (rtx * operands, bool is_movu)\n+{\n+  static char  template [64];\n+  const char * extension = TARGET_AS100_SYNTAX ? \".L\" : \"\";\n+  const char * src_template;\n+  const char * dst_template;\n+  rtx          dest = operands[0];\n+  rtx          src  = operands[1];\n+\n+  /* Decide which extension, if any, should be given to the move instruction.  */\n+  switch (CONST_INT_P (src) ? GET_MODE (dest) : GET_MODE (src))\n+    {\n+    case QImode:\n+      /* The .B extension is not valid when\n+\t loading an immediate into a register.  */\n+      if (! REG_P (dest) || ! CONST_INT_P (src))\n+\textension = \".B\";\n+      break;\n+    case HImode:\n+      if (! REG_P (dest) || ! CONST_INT_P (src))\n+\t/* The .W extension is not valid when\n+\t   loading an immediate into a register.  */\n+\textension = \".W\";\n+      break;\n+    case SFmode:\n+    case SImode:\n+      extension = \".L\";\n+      break;\n+    case VOIDmode:\n+      /* This mode is used by constants.  */\n+      break;\n+    default:\n+      debug_rtx (src);\n+      gcc_unreachable ();\n+    }\n+\n+  if (MEM_P (src) && rx_small_data_operand (XEXP (src, 0)))\n+    src_template = \"%%gp(%A1)[r13]\";\n+  else\n+    src_template = \"%1\";\n+\n+  if (MEM_P (dest) && rx_small_data_operand (XEXP (dest, 0)))\n+    dst_template = \"%%gp(%A0)[r13]\";\n+  else\n+    dst_template = \"%0\";\n+\n+  sprintf (template, \"%s%s\\t%s, %s\", is_movu ? \"movu\" : \"mov\",\n+\t   extension, src_template, dst_template);\n+  return template;\n+}\n+\n+/* Returns an assembler template for a conditional branch instruction.  */\n+\n+const char *\n+rx_gen_cond_branch_template (rtx condition, bool reversed)\n+{\n+  enum rtx_code code = GET_CODE (condition);\n+\n+\n+  if ((cc_status.flags & CC_NO_OVERFLOW) && ! rx_float_compare_mode)\n+    gcc_assert (code != GT && code != GE && code != LE && code != LT);\n+\n+  if ((cc_status.flags & CC_NO_CARRY) || rx_float_compare_mode)\n+    gcc_assert (code != GEU && code != GTU && code != LEU && code != LTU);\n+\n+  if (reversed)\n+    {\n+      if (rx_float_compare_mode)\n+\tcode = reverse_condition_maybe_unordered (code);\n+      else\n+\tcode = reverse_condition (code);\n+    }\n+\n+  /* We do not worry about encoding the branch length here as GAS knows\n+     how to choose the smallest version, and how to expand a branch that\n+     is to a destination that is out of range.  */\n+\n+  switch (code)\n+    {\n+    case UNEQ:\t    return \"bo\\t1f\\n\\tbeq\\t%0\\n1:\";\n+    case LTGT:\t    return \"bo\\t1f\\n\\tbne\\t%0\\n1:\";\n+    case UNLT:      return \"bo\\t1f\\n\\tbn\\t%0\\n1:\";\n+    case UNGE:      return \"bo\\t1f\\n\\tbpz\\t%0\\n1:\";\n+    case UNLE:      return \"bo\\t1f\\n\\tbgt\\t1f\\n\\tbra\\t%0\\n1:\";\n+    case UNGT:      return \"bo\\t1f\\n\\tble\\t1f\\n\\tbra\\t%0\\n1:\";\n+    case UNORDERED: return \"bo\\t%0\";\n+    case ORDERED:   return \"bno\\t%0\";\n+\n+    case LT:        return rx_float_compare_mode ? \"bn\\t%0\" : \"blt\\t%0\";\n+    case GE:        return rx_float_compare_mode ? \"bpz\\t%0\" : \"bge\\t%0\";\n+    case GT:        return \"bgt\\t%0\";\n+    case LE:        return \"ble\\t%0\";\n+    case GEU:       return \"bgeu\\t%0\";\n+    case LTU:       return \"bltu\\t%0\";\n+    case GTU:       return \"bgtu\\t%0\";\n+    case LEU:       return \"bleu\\t%0\";\n+    case EQ:        return \"beq\\t%0\";\n+    case NE:        return \"bne\\t%0\";\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\f\n+/* Return VALUE rounded up to the next ALIGNMENT boundary.  */\n+\n+static inline unsigned int\n+rx_round_up (unsigned int value, unsigned int alignment)\n+{\n+  alignment -= 1;\n+  return (value + alignment) & (~ alignment);\n+}\n+\n+/* Return the number of bytes in the argument registers\n+   occupied by an argument of type TYPE and mode MODE.  */\n+\n+unsigned int\n+rx_function_arg_size (Mmode mode, const_tree type)\n+{\n+  unsigned int num_bytes;\n+\n+  num_bytes = (mode == BLKmode)\n+    ? int_size_in_bytes (type) : GET_MODE_SIZE (mode);\n+  return rx_round_up (num_bytes, UNITS_PER_WORD);\n+}\n+\n+#define NUM_ARG_REGS\t\t4\n+#define MAX_NUM_ARG_BYTES\t(NUM_ARG_REGS * UNITS_PER_WORD)\n+\n+/* Return an RTL expression describing the register holding a function\n+   parameter of mode MODE and type TYPE or NULL_RTX if the parameter should\n+   be passed on the stack.  CUM describes the previous parameters to the\n+   function and NAMED is false if the parameter is part of a variable\n+   parameter list, or the last named parameter before the start of a\n+   variable parameter list.  */\n+\n+rtx\n+rx_function_arg (Fargs * cum, Mmode mode, const_tree type, bool named)\n+{\n+  unsigned int next_reg;\n+  unsigned int bytes_so_far = *cum;\n+  unsigned int size;\n+  unsigned int rounded_size;\n+\n+  /* An exploded version of rx_function_arg_size.  */\n+  size = (mode == BLKmode) ? int_size_in_bytes (type) : GET_MODE_SIZE (mode);\n+\n+  rounded_size = rx_round_up (size, UNITS_PER_WORD);\n+\n+  /* Don't pass this arg via registers if there\n+     are insufficient registers to hold all of it.  */\n+  if (rounded_size + bytes_so_far > MAX_NUM_ARG_BYTES)\n+    return NULL_RTX;\n+\n+  /* Unnamed arguments and the last named argument in a\n+     variadic function are always passed on the stack.  */\n+  if (!named)\n+    return NULL_RTX;\n+\n+  /* Structures must occupy an exact number of registers,\n+     otherwise they are passed on the stack.  */\n+  if ((type == NULL || AGGREGATE_TYPE_P (type))\n+      && (size % UNITS_PER_WORD) != 0)\n+    return NULL_RTX;\n+\n+  next_reg = (bytes_so_far / UNITS_PER_WORD) + 1;\n+\n+  return gen_rtx_REG (mode, next_reg);\n+}\n+\n+/* Return an RTL describing where a function return value of type RET_TYPE\n+   is held.  */\n+\n+static rtx\n+rx_function_value (const_tree ret_type,\n+\t\t   const_tree fn_decl_or_type ATTRIBUTE_UNUSED,\n+\t\t   bool       outgoing ATTRIBUTE_UNUSED)\n+{\n+  return gen_rtx_REG (TYPE_MODE (ret_type), FUNC_RETURN_REGNUM);\n+}\n+\n+static bool\n+rx_return_in_memory (const_tree type, const_tree fntype ATTRIBUTE_UNUSED)\n+{\n+  HOST_WIDE_INT size;\n+\n+  if (TYPE_MODE (type) != BLKmode\n+      && ! AGGREGATE_TYPE_P (type))\n+    return false;\n+\n+  size = int_size_in_bytes (type);\n+  /* Large structs and those whose size is not an\n+     exact multiple of 4 are returned in memory.  */\n+  return size < 1\n+    || size > 16\n+    || (size % UNITS_PER_WORD) != 0;\n+}\n+\n+static rtx\n+rx_struct_value_rtx (tree fndecl ATTRIBUTE_UNUSED,\n+\t\t     int incoming ATTRIBUTE_UNUSED)\n+{\n+  return gen_rtx_REG (Pmode, STRUCT_VAL_REGNUM);\n+}\n+\n+static bool\n+rx_return_in_msb (const_tree valtype)\n+{\n+  return TARGET_BIG_ENDIAN_DATA\n+    && (AGGREGATE_TYPE_P (valtype) || TREE_CODE (valtype) == COMPLEX_TYPE);\n+}\n+\n+/* Returns true if the provided function has the specified attribute.  */\n+\n+static inline bool\n+has_func_attr (const_tree decl, const char * func_attr)\n+{\n+  if (decl == NULL_TREE)\n+    decl = current_function_decl;\n+\n+  return lookup_attribute (func_attr, DECL_ATTRIBUTES (decl)) != NULL_TREE;\n+}\n+\n+/* Returns true if the provided function has\n+   the \"[fast_]interrupt\" attribute.  */\n+\n+static inline bool\n+is_fast_interrupt_func (const_tree decl)\n+{\n+  return has_func_attr (decl, \"interrupt\")\n+    || has_func_attr (decl, \"fast_interrupt\") ;\n+}\n+\n+/* Returns true if the provided function has the \"exception\" attribute.  */\n+\n+static inline bool\n+is_exception_func (const_tree decl)\n+{\n+  return has_func_attr (decl, \"exception\");\n+}\n+\n+/* Returns true if the provided function has the \"naked\" attribute.  */\n+\n+static inline bool\n+is_naked_func (const_tree decl)\n+{\n+  return has_func_attr (decl, \"naked\");\n+}\n+\f\n+static bool use_fixed_regs = false;\n+\n+void\n+rx_conditional_register_usage (void)\n+{\n+  static bool using_fixed_regs = false;\n+\n+  if (rx_small_data_limit > 0)\n+    fixed_regs[GP_BASE_REGNUM] = call_used_regs [GP_BASE_REGNUM] = 1;\n+\n+  if (use_fixed_regs != using_fixed_regs)\n+    {\n+      static char saved_fixed_regs[FIRST_PSEUDO_REGISTER];\n+      static char saved_call_used_regs[FIRST_PSEUDO_REGISTER];\n+\n+      if (use_fixed_regs)\n+\t{\n+\t  unsigned int switched = 0;\n+\t  unsigned int r;\n+\n+\t  /* This is for fast interrupt handlers.  Any register in\n+\t     the range r10 to r13 (inclusive) that is currently\n+\t     marked as fixed is now a viable, call-saved register.\n+\t     All other registers are fixed.  */\n+\t  memcpy (saved_fixed_regs, fixed_regs, sizeof fixed_regs);\n+\t  memcpy (saved_call_used_regs, call_used_regs, sizeof call_used_regs);\n+\t  \n+\t  for (r = 1; r < 10; r++)\n+\t    fixed_regs[r] = call_used_regs[r] = 1;\n+\t  \n+\t  for (r = 10; r <= 13; r++)\n+\t    if (fixed_regs[r])\n+\t      {\n+\t\tfixed_regs[r] = 0;\n+\t\tcall_used_regs[r] = 1;\n+\t\t++ switched;\n+\t      }\n+\t    else\n+\t      {\n+\t\tfixed_regs[r] = 1;\n+\t\tcall_used_regs[r] = 1;\n+\t      }\n+\n+\t  fixed_regs[14] = call_used_regs[14] = 1;\n+\t  fixed_regs[15] = call_used_regs[15] = 1;\n+\n+\t  if (switched == 0)\n+\t    {\n+\t      static bool warned = false;\n+\n+\t      if (! warned)\n+\t\t{\n+\t\t  warning (0, \"no fixed registers available \"\n+\t\t\t   \"for use by fast interrupt handler\");\n+\t\t  warned = true;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  /* Restore the normal register masks.  */\n+\t  memcpy (fixed_regs, saved_fixed_regs, sizeof fixed_regs);\n+\t  memcpy (call_used_regs, saved_call_used_regs, sizeof call_used_regs);\n+\t}\n+\n+      using_fixed_regs = use_fixed_regs;\n+    }\n+}\n+\n+/* Perform any actions necessary before starting to compile FNDECL.\n+   For the RX we use this to make sure that we have the correct\n+   set of register masks selected.  If FNDECL is NULL then we are\n+   compiling top level things.  */\n+\n+static void\n+rx_set_current_function (tree fndecl)\n+{\n+  /* Remember the last target of rx_set_current_function.  */\n+  static tree rx_previous_fndecl;\n+  bool prev_was_interrupt;\n+  bool current_is_interrupt;\n+\n+  /* Only change the context if the function changes.  This hook is called\n+     several times in the course of compiling a function, and we don't want\n+     to slow things down too much or call target_reinit when it isn't safe.  */\n+  if (fndecl == rx_previous_fndecl)\n+    return;\n+\n+  prev_was_interrupt\n+    = rx_previous_fndecl\n+    ? is_fast_interrupt_func (rx_previous_fndecl) : false;\n+  current_is_interrupt\n+    = fndecl ? is_fast_interrupt_func (fndecl) : false;\n+      \n+  if (prev_was_interrupt != current_is_interrupt)\n+    {\n+      use_fixed_regs = current_is_interrupt;\n+      target_reinit ();\n+    }\n+      \n+  rx_previous_fndecl = fndecl;\n+}\n+\f\n+/* Typical stack layout should looks like this after the function's prologue:\n+\n+                            |    |\n+                              --                       ^\n+                            |    | \\                   |\n+                            |    |   arguments saved   | Increasing\n+                            |    |   on the stack      |  addresses\n+    PARENT   arg pointer -> |    | /\n+  -------------------------- ---- -------------------\n+    CHILD                   |ret |   return address\n+                              --\n+                            |    | \\\n+                            |    |   call saved\n+                            |    |   registers\n+\t\t\t    |    | /\n+                              --\n+                            |    | \\\n+                            |    |   local\n+                            |    |   variables\n+        frame pointer ->    |    | /\n+                              --\n+                            |    | \\\n+                            |    |   outgoing          | Decreasing\n+                            |    |   arguments         |  addresses\n+   current stack pointer -> |    | /                   |\n+  -------------------------- ---- ------------------   V\n+                            |    |                 */\n+\n+static unsigned int\n+bit_count (unsigned int x)\n+{\n+  const unsigned int m1 = 0x55555555;\n+  const unsigned int m2 = 0x33333333;\n+  const unsigned int m4 = 0x0f0f0f0f;\n+\n+  x -= (x >> 1) & m1;\n+  x = (x & m2) + ((x >> 2) & m2);\n+  x = (x + (x >> 4)) & m4;\n+  x += x >>  8;\n+\n+  return (x + (x >> 16)) & 0x3f;\n+}\n+\n+/* Returns either the lowest numbered and highest numbered registers that\n+   occupy the call-saved area of the stack frame, if the registers are\n+   stored as a contiguous block, or else a bitmask of the individual\n+   registers if they are stored piecemeal.\n+\n+   Also computes the size of the frame and the size of the outgoing\n+   arguments block (in bytes).  */\n+\n+static void\n+rx_get_stack_layout (unsigned int * lowest,\n+\t\t     unsigned int * highest,\n+\t\t     unsigned int * register_mask,\n+\t\t     unsigned int * frame_size,\n+\t\t     unsigned int * stack_size)\n+{\n+  unsigned int reg;\n+  unsigned int low;\n+  unsigned int high;\n+  unsigned int fixed_reg = 0;\n+  unsigned int save_mask;\n+  unsigned int pushed_mask;\n+  unsigned int unneeded_pushes;\n+\n+  if (is_naked_func (NULL_TREE)\n+      || is_fast_interrupt_func (NULL_TREE))\n+    {\n+      /* Naked functions do not create their own stack frame.\n+\t Instead the programmer must do that for us.\n+\n+\t Fast interrupt handlers use fixed registers that have\n+\t been epsecially released to the function, so they do\n+\t not need or want a stack frame.  */\n+      * lowest = 0;\n+      * highest = 0;\n+      * register_mask = 0;\n+      * frame_size = 0;\n+      * stack_size = 0;\n+      return;\n+    }\n+\n+  for (save_mask = high = low = 0, reg = 1; reg < FIRST_PSEUDO_REGISTER; reg++)\n+    {\n+      if (df_regs_ever_live_p (reg)\n+\t  && (! call_used_regs[reg]\n+\t      /* Even call clobbered registered must\n+\t\t be pushed inside exception handlers.  */\n+\t      || is_exception_func (NULL_TREE)))\n+\t{\n+\t  if (low == 0)\n+\t    low = reg;\n+\t  high = reg;\n+\n+\t  save_mask |= 1 << reg;\n+\t}\n+\n+      /* Remember if we see a fixed register\n+\t after having found the low register.  */\n+      if (low != 0 && fixed_reg == 0 && fixed_regs [reg])\n+\tfixed_reg = reg;\n+    }\n+\n+  /* Decide if it would be faster fill in the call-saved area of the stack\n+     frame using multiple PUSH instructions instead of a single PUSHM\n+     instruction.\n+\n+     SAVE_MASK is a bitmask of the registers that must be stored in the\n+     call-save area.  PUSHED_MASK is a bitmask of the registers that would\n+     be pushed into the area if we used a PUSHM instruction.  UNNEEDED_PUSHES\n+     is a bitmask of those registers in pushed_mask that are not in\n+     save_mask.\n+\n+     We use a simple heuristic that says that it is better to use\n+     multiple PUSH instructions if the number of unnecessary pushes is\n+     greater than the number of necessary pushes.\n+\n+     We also use multiple PUSH instructions if there are any fixed registers\n+     between LOW and HIGH.  The only way that this can happen is if the user\n+     has specified --fixed-<reg-name> on the command line and in such\n+     circumstances we do not want to touch the fixed registers at all.\n+\n+     FIXME: Is it worth improving this heuristic ?  */\n+  pushed_mask = (-1 << low) & ~(-1 << (high + 1));\n+  unneeded_pushes = (pushed_mask & (~ save_mask)) & pushed_mask;\n+\n+  if ((fixed_reg && fixed_reg <= high)\n+      || (optimize_function_for_speed_p (cfun)\n+\t  && bit_count (save_mask) < bit_count (unneeded_pushes)))\n+    {\n+      /* Use multiple pushes.  */\n+      * lowest = 0;\n+      * highest = 0;\n+      * register_mask = save_mask;\n+    }\n+  else\n+    {\n+      /* Use one push multiple instruction.  */\n+      * lowest = low;\n+      * highest = high;\n+      * register_mask = 0;\n+    }\n+\n+  * frame_size = rx_round_up\n+    (get_frame_size (), STACK_BOUNDARY / BITS_PER_UNIT);\n+\n+  if (crtl->args.size > 0)\n+    * frame_size += rx_round_up\n+      (crtl->args.size, STACK_BOUNDARY / BITS_PER_UNIT);\n+\n+  * stack_size = rx_round_up\n+    (crtl->outgoing_args_size, STACK_BOUNDARY / BITS_PER_UNIT);\n+}\n+\n+/* Generate a PUSHM instruction that matches the given operands.  */\n+\n+void\n+rx_emit_stack_pushm (rtx * operands)\n+{\n+  HOST_WIDE_INT last_reg;\n+  rtx first_push;\n+\n+  gcc_assert (CONST_INT_P (operands[0]));\n+  last_reg = (INTVAL (operands[0]) / UNITS_PER_WORD) - 1;\n+\n+  gcc_assert (GET_CODE (operands[1]) == PARALLEL);\n+  first_push = XVECEXP (operands[1], 0, 1);\n+  gcc_assert (SET_P (first_push));\n+  first_push = SET_SRC (first_push);\n+  gcc_assert (REG_P (first_push));\n+\n+  asm_fprintf (asm_out_file, \"\\tpushm\\t%s-%s\\n\",\n+\t       reg_names [REGNO (first_push)],\n+\t       reg_names [REGNO (first_push) + last_reg]);\n+  \n+}\n+\n+/* Generate a PARALLEL that will pass the rx_store_multiple_vector predicate.  */\n+\n+static rtx\n+gen_rx_store_vector (unsigned int low, unsigned int high)\n+{\n+  unsigned int i;\n+  unsigned int count = (high - low) + 2;\n+  rtx vector;\n+\n+  vector = gen_rtx_PARALLEL (VOIDmode, rtvec_alloc (count));\n+\n+  XVECEXP (vector, 0, 0) =\n+    gen_rtx_SET (SImode, stack_pointer_rtx,\n+\t\t gen_rtx_MINUS (SImode, stack_pointer_rtx,\n+\t\t\t\tGEN_INT ((count - 1) * UNITS_PER_WORD)));\n+\n+  for (i = 0; i < count - 1; i++)\n+    XVECEXP (vector, 0, i + 1) =\n+      gen_rtx_SET (SImode,\n+\t\t   gen_rtx_MEM (SImode,\n+\t\t\t\ti == 0 ? stack_pointer_rtx\n+\t\t\t\t: gen_rtx_MINUS (SImode, stack_pointer_rtx,\n+\t\t\t\t\t\t GEN_INT (i * UNITS_PER_WORD))),\n+\t\t   gen_rtx_REG (SImode, low + i));\n+\n+  return vector;\n+}\n+\n+void\n+rx_expand_prologue (void)\n+{\n+  unsigned int stack_size;\n+  unsigned int frame_size;\n+  unsigned int mask;\n+  unsigned int low;\n+  unsigned int high;\n+  rtx insn;\n+\n+  /* Naked functions use their own, programmer provided prologues.  */\n+  if (is_naked_func (NULL_TREE)\n+      /* Fast interrupt functions never use the stack.  */\n+      || is_fast_interrupt_func (NULL_TREE))\n+    return;\n+\n+  rx_get_stack_layout (& low, & high, & mask, & frame_size, & stack_size);\n+\n+  /* If we use any of the callee-saved registers, save them now.  */\n+  if (mask)\n+    {\n+      unsigned int reg;\n+\n+      /* Push registers in reverse order.  */\n+      for (reg = FIRST_PSEUDO_REGISTER; reg --;)\n+\tif (mask & (1 << reg))\n+\t  {\n+\t    insn = emit_insn (gen_stack_push (gen_rtx_REG (SImode, reg)));\n+\t    RTX_FRAME_RELATED_P (insn) = 1;\n+\t  }\n+    }\n+  else if (low)\n+    {\n+      if (high == low)\n+\tinsn = emit_insn (gen_stack_push (gen_rtx_REG (SImode, low)));\n+      else\n+\tinsn = emit_insn (gen_stack_pushm (GEN_INT (((high - low) + 1)\n+\t\t\t\t\t\t    * UNITS_PER_WORD),\n+\t\t\t\t\t   gen_rx_store_vector (low, high)));\n+      RTX_FRAME_RELATED_P (insn) = 1;\n+    }\n+\n+  /* If needed, set up the frame pointer.  */\n+  if (frame_pointer_needed)\n+    {\n+      if (frame_size)\n+\tinsn = emit_insn (gen_addsi3 (frame_pointer_rtx, stack_pointer_rtx,\n+\t\t\t\t      GEN_INT (- (HOST_WIDE_INT) frame_size)));\n+      else\n+\tinsn = emit_move_insn (frame_pointer_rtx, stack_pointer_rtx);\n+\n+      RTX_FRAME_RELATED_P (insn) = 1;\n+    }\n+\n+  insn = NULL_RTX;\n+\n+  /* Allocate space for the outgoing args.\n+     If the stack frame has not already been set up then handle this as well.  */\n+  if (stack_size)\n+    {\n+      if (frame_size)\n+\t{\n+\t  if (frame_pointer_needed)\n+\t    insn = emit_insn (gen_addsi3 (stack_pointer_rtx, frame_pointer_rtx,\n+\t\t\t\t\t  GEN_INT (- (HOST_WIDE_INT)\n+\t\t\t\t\t\t   stack_size)));\n+\t  else\n+\t    insn = emit_insn (gen_addsi3 (stack_pointer_rtx, stack_pointer_rtx,\n+\t\t\t\t\t  GEN_INT (- (HOST_WIDE_INT)\n+\t\t\t\t\t\t   (frame_size + stack_size))));\n+\t}\n+      else\n+\tinsn = emit_insn (gen_addsi3 (stack_pointer_rtx, stack_pointer_rtx,\n+\t\t\t\t      GEN_INT (- (HOST_WIDE_INT) stack_size)));\n+    }\n+  else if (frame_size)\n+    {\n+      if (! frame_pointer_needed)\n+\tinsn = emit_insn (gen_addsi3 (stack_pointer_rtx, stack_pointer_rtx,\n+\t\t\t\t      GEN_INT (- (HOST_WIDE_INT) frame_size)));\n+      else\n+\tinsn = emit_move_insn (stack_pointer_rtx, frame_pointer_rtx);\n+    }\n+\n+  if (insn != NULL_RTX)\n+    RTX_FRAME_RELATED_P (insn) = 1;\n+}\n+\n+static void\n+rx_output_function_prologue (FILE * file,\n+\t\t\t     HOST_WIDE_INT frame_size ATTRIBUTE_UNUSED)\n+{\n+  if (is_fast_interrupt_func (NULL_TREE))\n+    asm_fprintf (file, \"\\t; Note: Fast Interrupt Handler\\n\");\n+\n+  if (is_exception_func (NULL_TREE))\n+    asm_fprintf (file, \"\\t; Note: Exception Handler\\n\");\n+\n+  if (is_naked_func (NULL_TREE))\n+    asm_fprintf (file, \"\\t; Note: Naked Function\\n\");\n+\n+  if (cfun->static_chain_decl != NULL)\n+    asm_fprintf (file, \"\\t; Note: Nested function declared \"\n+\t\t \"inside another function.\\n\");\n+\n+  if (crtl->calls_eh_return)\n+    asm_fprintf (file, \"\\t; Note: Calls __builtin_eh_return.\\n\");\n+}\n+\n+/* Generate a POPM or RTSD instruction that matches the given operands.  */\n+\n+void\n+rx_emit_stack_popm (rtx * operands, bool is_popm)\n+{\n+  HOST_WIDE_INT stack_adjust;\n+  HOST_WIDE_INT last_reg;\n+  rtx first_push;\n+\n+  gcc_assert (CONST_INT_P (operands[0]));\n+  stack_adjust = INTVAL (operands[0]);\n+  \n+  gcc_assert (GET_CODE (operands[1]) == PARALLEL);\n+  last_reg = XVECLEN (operands[1], 0) - (is_popm ? 2 : 3);\n+\n+  first_push = XVECEXP (operands[1], 0, 1);\n+  gcc_assert (SET_P (first_push));\n+  first_push = SET_DEST (first_push);\n+  gcc_assert (REG_P (first_push));\n+\n+  if (is_popm)\n+    asm_fprintf (asm_out_file, \"\\tpopm\\t%s-%s\\n\",\n+\t\t reg_names [REGNO (first_push)],\n+\t\t reg_names [REGNO (first_push) + last_reg]);\n+  else\n+    asm_fprintf (asm_out_file, \"\\trtsd\\t#%d, %s-%s\\n\",\n+\t\t (int) stack_adjust,\n+\t\t reg_names [REGNO (first_push)],\n+\t\t reg_names [REGNO (first_push) + last_reg]);\n+}\n+\n+/* Generate a PARALLEL which will satisfy the rx_rtsd_vector predicate.  */\n+\n+static rtx\n+gen_rx_rtsd_vector (unsigned int adjust, unsigned int low, unsigned int high)\n+{\n+  unsigned int i;\n+  unsigned int bias = 3;\n+  unsigned int count = (high - low) + bias;\n+  rtx vector;\n+\n+  vector = gen_rtx_PARALLEL (VOIDmode, rtvec_alloc (count));\n+\n+  XVECEXP (vector, 0, 0) =\n+    gen_rtx_SET (SImode, stack_pointer_rtx,\n+\t\t plus_constant (stack_pointer_rtx, adjust));\n+\n+  for (i = 0; i < count - 2; i++)\n+    XVECEXP (vector, 0, i + 1) =\n+      gen_rtx_SET (SImode,\n+\t\t   gen_rtx_REG (SImode, low + i),\n+\t\t   gen_rtx_MEM (SImode,\n+\t\t\t\ti == 0 ? stack_pointer_rtx\n+\t\t\t\t: plus_constant (stack_pointer_rtx,\n+\t\t\t\t\t\t i * UNITS_PER_WORD)));\n+\n+  XVECEXP (vector, 0, count - 1) = gen_rtx_RETURN (VOIDmode);\n+\n+  return vector;\n+}\n+  \n+/* Generate a PARALLEL which will satisfy the rx_load_multiple_vector predicate.  */\n+\n+static rtx\n+gen_rx_popm_vector (unsigned int low, unsigned int high)\n+{\n+  unsigned int i;  \n+  unsigned int count = (high - low) + 2;\n+  rtx vector;\n+\n+  vector = gen_rtx_PARALLEL (VOIDmode, rtvec_alloc (count));\n+\n+  XVECEXP (vector, 0, 0) =\n+    gen_rtx_SET (SImode, stack_pointer_rtx,\n+\t\t plus_constant (stack_pointer_rtx,\n+\t\t\t\t(count - 1) * UNITS_PER_WORD));\n+\n+  for (i = 0; i < count - 1; i++)\n+    XVECEXP (vector, 0, i + 1) =\n+      gen_rtx_SET (SImode,\n+\t\t   gen_rtx_REG (SImode, low + i),\n+\t\t   gen_rtx_MEM (SImode,\n+\t\t\t\ti == 0 ? stack_pointer_rtx\n+\t\t\t\t: plus_constant (stack_pointer_rtx,\n+\t\t\t\t\t\t i * UNITS_PER_WORD)));\n+\n+  return vector;\n+}\n+  \n+void\n+rx_expand_epilogue (bool is_sibcall)\n+{\n+  unsigned int low;\n+  unsigned int high;\n+  unsigned int frame_size;\n+  unsigned int stack_size;\n+  unsigned int register_mask;\n+  unsigned int regs_size;\n+  unsigned HOST_WIDE_INT total_size;\n+\n+  if (is_naked_func (NULL_TREE))\n+    {\n+      /* Naked functions use their own, programmer provided epilogues.\n+\t But, in order to keep gcc happy we have to generate some kind of\n+\t epilogue RTL.  */\n+      emit_jump_insn (gen_naked_return ());\n+      return;\n+    }\n+\n+  rx_get_stack_layout (& low, & high, & register_mask,\n+\t\t       & frame_size, & stack_size);\n+\n+  total_size = frame_size + stack_size;\n+  regs_size = ((high - low) + 1) * UNITS_PER_WORD;\n+\n+  /* See if we are unable to use the special stack frame deconstruct and\n+     return instructions.  In most cases we can use them, but the exceptions\n+     are:\n+\n+     - Sibling calling functions deconstruct the frame but do not return to\n+       their caller.  Instead they branch to their sibling and allow their\n+       return instruction to return to this function's parent.\n+\n+     - Fast interrupt and exception handling functions have to use special\n+       return instructions.\n+\n+     - Functions where we have pushed a fragmented set of registers into the\n+       call-save area must have the same set of registers popped.  */\n+  if (is_sibcall\n+      || is_fast_interrupt_func (NULL_TREE)\n+      || is_exception_func (NULL_TREE)\n+      || register_mask)\n+    {\n+      /* Cannot use the special instructions - deconstruct by hand.  */\n+      if (total_size)\n+\temit_insn (gen_addsi3 (stack_pointer_rtx, stack_pointer_rtx,\n+\t\t\t       GEN_INT (total_size)));\n+\n+      if (register_mask)\n+\t{\n+\t  unsigned int reg;\n+\n+\t  for (reg = 0; reg < FIRST_PSEUDO_REGISTER; reg ++)\n+\t    if (register_mask & (1 << reg))\n+\t      emit_insn (gen_stack_pop (gen_rtx_REG (SImode, reg)));\n+\t}\n+      else if (low)\n+\t{\n+\t  if (high == low)\n+\t    emit_insn (gen_stack_pop (gen_rtx_REG (SImode, low)));\n+\t  else\n+\t    emit_insn (gen_stack_popm (GEN_INT (regs_size),\n+\t\t\t\t       gen_rx_popm_vector (low, high)));\n+\t}\n+\n+      if (is_fast_interrupt_func (NULL_TREE))\n+\temit_jump_insn (gen_fast_interrupt_return ());\n+      else if (is_exception_func (NULL_TREE))\n+\temit_jump_insn (gen_exception_return ());\n+      else if (! is_sibcall)\n+\temit_jump_insn (gen_simple_return ());\n+\n+      return;\n+    }\n+\n+  /* If we allocated space on the stack, free it now.  */\n+  if (total_size)\n+    {\n+      unsigned HOST_WIDE_INT rtsd_size;\n+\n+      /* See if we can use the RTSD instruction.  */\n+      rtsd_size = total_size + regs_size;\n+      if (rtsd_size < 1024 && (rtsd_size % 4) == 0)\n+\t{\n+\t  if (low)\n+\t    emit_jump_insn (gen_pop_and_return\n+\t\t\t    (GEN_INT (rtsd_size),\n+\t\t\t     gen_rx_rtsd_vector (rtsd_size, low, high)));\n+\t  else\n+\t    emit_jump_insn (gen_deallocate_and_return (GEN_INT (total_size)));\n+\n+\t  return;\n+\t}\n+\n+      emit_insn (gen_addsi3 (stack_pointer_rtx, stack_pointer_rtx,\n+\t\t\t     GEN_INT (total_size)));\n+    }\n+\n+  if (low)\n+    emit_jump_insn (gen_pop_and_return (GEN_INT (regs_size),\n+\t\t\t\t\tgen_rx_rtsd_vector (regs_size,\n+\t\t\t\t\t\t\t    low, high)));\n+  else\n+    emit_jump_insn (gen_simple_return ());\n+}\n+\n+\n+/* Compute the offset (in words) between FROM (arg pointer\n+   or frame pointer) and TO (frame pointer or stack pointer).\n+   See ASCII art comment at the start of rx_expand_prologue\n+   for more information.  */\n+\n+int\n+rx_initial_elimination_offset (int from, int to)\n+{\n+  unsigned int low;\n+  unsigned int high;\n+  unsigned int frame_size;\n+  unsigned int stack_size;\n+  unsigned int mask;\n+\n+  rx_get_stack_layout (& low, & high, & mask, & frame_size, & stack_size);\n+\n+  if (from == ARG_POINTER_REGNUM)\n+    {\n+      /* Extend the computed size of the stack frame to\n+\t include the registers pushed in the prologue.  */\n+      if (low)\n+\tframe_size += ((high - low) + 1) * UNITS_PER_WORD;\n+      else\n+\tframe_size += bit_count (mask) * UNITS_PER_WORD;\n+\n+      /* Remember to include the return address.  */\n+      frame_size += 1 * UNITS_PER_WORD;\n+\n+      if (to == FRAME_POINTER_REGNUM)\n+\treturn frame_size;\n+\n+      gcc_assert (to == STACK_POINTER_REGNUM);\n+      return frame_size + stack_size;\n+    }\n+\n+  gcc_assert (from == FRAME_POINTER_REGNUM && to == STACK_POINTER_REGNUM);\n+  return stack_size;\n+}\n+\n+/* Update the status of the condition\n+   codes (cc0) based on the given INSN.  */\n+\n+void\n+rx_notice_update_cc (rtx body, rtx insn)\n+{\n+  switch (get_attr_cc (insn))\n+    {\n+    case CC_NONE:\n+      /* Insn does not affect cc0 at all.  */\n+      break;\n+    case CC_CLOBBER:\n+      /* Insn doesn't leave cc0 in a usable state.  */\n+      CC_STATUS_INIT;\n+      break;\n+    case CC_SET_ZSOC:\n+      /* The insn sets all the condition code bits.  */\n+      CC_STATUS_INIT;\n+      cc_status.value1 = SET_SRC (body);\n+      break;\n+    case CC_SET_ZSO:\n+      /* Insn sets the Z,S and O flags, but not the C flag.  */\n+      CC_STATUS_INIT;\n+      cc_status.flags |= CC_NO_CARRY;\n+      /* Do not set the value1 field in this case.  The final_scan_insn()\n+\t function naively believes that if cc_status.value1 is set then\n+\t it can eliminate *any* comparison against that value, even if\n+\t the type of comparison cannot be satisfied by the range of flag\n+\t bits being set here.  See gcc.c-torture/execute/20041210-1.c\n+\t for an example of this in action.  */\n+      break;\n+    case CC_SET_ZS:\n+      /* Insn sets the Z and S flags, but not the O or C flags.  */\n+      CC_STATUS_INIT;\n+      cc_status.flags |= (CC_NO_CARRY | CC_NO_OVERFLOW);\n+      /* See comment above regarding cc_status.value1.  */\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n+/* Decide if a variable should go into one of the small data sections.  */\n+\n+static bool\n+rx_in_small_data (const_tree decl)\n+{\n+  int size;\n+  const_tree section;\n+\n+  if (rx_small_data_limit == 0)\n+    return false;\n+\n+  if (TREE_CODE (decl) != VAR_DECL)\n+    return false;\n+\n+  /* We do not put read-only variables into a small data area because\n+     they would be placed with the other read-only sections, far away\n+     from the read-write data sections, and we only have one small\n+     data area pointer.\n+     Similarly commons are placed in the .bss section which might be\n+     far away (and out of alignment with respect to) the .data section.  */\n+  if (TREE_READONLY (decl) || DECL_COMMON (decl))\n+    return false;\n+\n+  section = DECL_SECTION_NAME (decl);\n+  if (section)\n+    {\n+      const char * const name = TREE_STRING_POINTER (section);\n+\n+      return (strcmp (name, \"D_2\") == 0) || (strcmp (name, \"B_2\") == 0);\n+    }\n+\n+  size = int_size_in_bytes (TREE_TYPE (decl));\n+\n+  return (size > 0) && (size <= rx_small_data_limit);\n+}\n+\n+/* Return a section for X.\n+   The only special thing we do here is to honor small data.  */\n+\n+static section *\n+rx_select_rtx_section (enum machine_mode mode,\n+\t\t       rtx x,\n+\t\t       unsigned HOST_WIDE_INT align)\n+{\n+  if (rx_small_data_limit > 0\n+      && GET_MODE_SIZE (mode) <= rx_small_data_limit\n+      && align <= (unsigned HOST_WIDE_INT) rx_small_data_limit * BITS_PER_UNIT)\n+    return sdata_section;\n+\n+  return default_elf_select_rtx_section (mode, x, align);\n+}\n+\n+static section *\n+rx_select_section (tree decl,\n+\t\t   int reloc,\n+\t\t   unsigned HOST_WIDE_INT align)\n+{\n+  if (rx_small_data_limit > 0)\n+    {\n+      switch (categorize_decl_for_section (decl, reloc))\n+\t{\n+\tcase SECCAT_SDATA:\treturn sdata_section;\n+\tcase SECCAT_SBSS:\treturn sbss_section;\n+\tcase SECCAT_SRODATA:\n+\t  /* Fall through.  We do not put small, read only\n+\t     data into the C_2 section because we are not\n+\t     using the C_2 section.  We do not use the C_2\n+\t     section because it is located with the other\n+\t     read-only data sections, far away from the read-write\n+\t     data sections and we only have one small data\n+\t     pointer (r13).  */\n+\tdefault:\n+\t  break;\n+\t}\n+    }\n+\n+  /* If we are supporting the Renesas assembler\n+     we cannot use mergeable sections.  */\n+  if (TARGET_AS100_SYNTAX)\n+    switch (categorize_decl_for_section (decl, reloc))\n+      {\n+      case SECCAT_RODATA_MERGE_CONST:\n+      case SECCAT_RODATA_MERGE_STR_INIT:\n+      case SECCAT_RODATA_MERGE_STR:\n+\treturn readonly_data_section;\n+\n+      default:\n+\tbreak;\n+      }\n+\n+  return default_elf_select_section (decl, reloc, align);\n+}\n+\f\n+enum rx_builtin\n+{\n+  RX_BUILTIN_BRK,\n+  RX_BUILTIN_CLRPSW,\n+  RX_BUILTIN_INT,\n+  RX_BUILTIN_MACHI,\n+  RX_BUILTIN_MACLO,\n+  RX_BUILTIN_MULHI,\n+  RX_BUILTIN_MULLO,\n+  RX_BUILTIN_MVFACHI,\n+  RX_BUILTIN_MVFACMI,\n+  RX_BUILTIN_MVFC,\n+  RX_BUILTIN_MVTACHI,\n+  RX_BUILTIN_MVTACLO,\n+  RX_BUILTIN_MVTC,\n+  RX_BUILTIN_RACW,\n+  RX_BUILTIN_REVW,\n+  RX_BUILTIN_RMPA,\n+  RX_BUILTIN_ROUND,\n+  RX_BUILTIN_SAT,\n+  RX_BUILTIN_SETPSW,\n+  RX_BUILTIN_WAIT,\n+  RX_BUILTIN_max\n+};\n+\n+static void\n+rx_init_builtins (void)\n+{\n+#define ADD_RX_BUILTIN1(UC_NAME, LC_NAME, RET_TYPE, ARG_TYPE)\t\t\\\n+  add_builtin_function (\"__builtin_rx_\" LC_NAME,\t\t\t\\\n+\t\t\tbuild_function_type_list (RET_TYPE##_type_node, \\\n+\t\t\t\t\t\t  ARG_TYPE##_type_node, \\\n+\t\t\t\t\t\t  NULL_TREE),\t\t\\\n+\t\t\tRX_BUILTIN_##UC_NAME,\t\t\t\t\\\n+\t\t\tBUILT_IN_MD, NULL, NULL_TREE)\n+\n+#define ADD_RX_BUILTIN2(UC_NAME, LC_NAME, RET_TYPE, ARG_TYPE1, ARG_TYPE2) \\\n+  add_builtin_function (\"__builtin_rx_\" LC_NAME,\t\t\t\\\n+\t\t\tbuild_function_type_list (RET_TYPE##_type_node, \\\n+\t\t\t\t\t\t  ARG_TYPE1##_type_node,\\\n+\t\t\t\t\t\t  ARG_TYPE2##_type_node,\\\n+\t\t\t\t\t\t  NULL_TREE),\t\t\\\n+\t\t\tRX_BUILTIN_##UC_NAME,\t\t\t\t\\\n+\t\t\tBUILT_IN_MD, NULL, NULL_TREE)\n+\n+#define ADD_RX_BUILTIN3(UC_NAME,LC_NAME,RET_TYPE,ARG_TYPE1,ARG_TYPE2,ARG_TYPE3) \\\n+  add_builtin_function (\"__builtin_rx_\" LC_NAME,\t\t\t\\\n+\t\t\tbuild_function_type_list (RET_TYPE##_type_node, \\\n+\t\t\t\t\t\t  ARG_TYPE1##_type_node,\\\n+\t\t\t\t\t\t  ARG_TYPE2##_type_node,\\\n+\t\t\t\t\t\t  ARG_TYPE3##_type_node,\\\n+\t\t\t\t\t\t  NULL_TREE),\t\t\\\n+\t\t\tRX_BUILTIN_##UC_NAME,\t\t\t\t\\\n+\t\t\tBUILT_IN_MD, NULL, NULL_TREE)\n+\n+  ADD_RX_BUILTIN1 (BRK,     \"brk\",     void,  void);\n+  ADD_RX_BUILTIN1 (CLRPSW,  \"clrpsw\",  void,  integer);\n+  ADD_RX_BUILTIN1 (SETPSW,  \"setpsw\",  void,  integer);\n+  ADD_RX_BUILTIN1 (INT,     \"int\",     void,  integer);\n+  ADD_RX_BUILTIN2 (MACHI,   \"machi\",   void,  intSI, intSI);\n+  ADD_RX_BUILTIN2 (MACLO,   \"maclo\",   void,  intSI, intSI);\n+  ADD_RX_BUILTIN2 (MULHI,   \"mulhi\",   void,  intSI, intSI);\n+  ADD_RX_BUILTIN2 (MULLO,   \"mullo\",   void,  intSI, intSI);\n+  ADD_RX_BUILTIN1 (MVFACHI, \"mvfachi\", intSI, void);\n+  ADD_RX_BUILTIN1 (MVFACMI, \"mvfacmi\", intSI, void);\n+  ADD_RX_BUILTIN1 (MVTACHI, \"mvtachi\", void,  intSI);\n+  ADD_RX_BUILTIN1 (MVTACLO, \"mvtaclo\", void,  intSI);\n+  ADD_RX_BUILTIN1 (RMPA,    \"rmpa\",    void,  void);\n+  ADD_RX_BUILTIN1 (MVFC,    \"mvfc\",    intSI, integer);\n+  ADD_RX_BUILTIN2 (MVTC,    \"mvtc\",    void,  integer, integer);\n+  ADD_RX_BUILTIN1 (RACW,    \"racw\",    void,  integer);\n+  ADD_RX_BUILTIN1 (ROUND,   \"round\",   intSI, float);\n+  ADD_RX_BUILTIN1 (REVW,    \"revw\",    intSI, intSI);\n+  ADD_RX_BUILTIN1 (SAT,     \"sat\",     intSI, intSI);\n+  ADD_RX_BUILTIN1 (WAIT,    \"wait\",    void,  void);\n+}\n+\n+static rtx\n+rx_expand_builtin_stz (rtx arg, rtx target, rtx (* gen_func)(rtx, rtx))\n+{\n+  if (! CONST_INT_P (arg))\n+    return NULL_RTX;\n+\n+  if (target == NULL_RTX || ! REG_P (target))\n+    target = gen_reg_rtx (SImode);\n+\n+  emit_insn (gen_func (target, arg));\n+\n+  return target;\n+}\n+\n+static rtx\n+rx_expand_void_builtin_1_arg (rtx arg, rtx (* gen_func)(rtx), bool reg)\n+{\n+  if (reg && ! REG_P (arg))\n+    arg = force_reg (SImode, arg);\n+\n+  emit_insn (gen_func (arg));\n+\n+  return NULL_RTX;\n+}\n+\n+static rtx\n+rx_expand_builtin_mvtc (tree exp)\n+{\n+  rtx arg1 = expand_normal (CALL_EXPR_ARG (exp, 0));\n+  rtx arg2 = expand_normal (CALL_EXPR_ARG (exp, 1));\n+\n+  if (! CONST_INT_P (arg1))\n+    return NULL_RTX;\n+\n+  if (! REG_P (arg2))\n+    arg2 = force_reg (SImode, arg2);\n+\n+  emit_insn (gen_mvtc (arg1, arg2));\n+\n+  return NULL_RTX;\n+}\n+\n+static rtx\n+rx_expand_builtin_mvfc (tree t_arg, rtx target)\n+{\n+  rtx arg = expand_normal (t_arg);\n+\n+  if (! CONST_INT_P (arg))\n+    return NULL_RTX;\n+\n+  if (! REG_P (target))\n+    target = force_reg (SImode, target);\n+\n+  emit_insn (gen_mvfc (target, arg));\n+\n+  return target;\n+}\n+\n+static rtx\n+rx_expand_builtin_mac (tree exp, rtx (* gen_func)(rtx, rtx))\n+{\n+  rtx arg1 = expand_normal (CALL_EXPR_ARG (exp, 0));\n+  rtx arg2 = expand_normal (CALL_EXPR_ARG (exp, 1));\n+\n+  if (! REG_P (arg1))\n+    arg1 = force_reg (SImode, arg1);\n+\n+  if (! REG_P (arg2))\n+    arg2 = force_reg (SImode, arg2);\n+\n+  emit_insn (gen_func (arg1, arg2));\n+\n+  return NULL_RTX;\n+}\n+\n+static rtx\n+rx_expand_int_builtin_1_arg (rtx arg,\n+\t\t\t     rtx target,\n+\t\t\t     rtx (* gen_func)(rtx, rtx),\n+\t\t\t     bool mem_ok)\n+{\n+  if (! REG_P (arg))\n+    if (!mem_ok || ! MEM_P (arg))\n+      arg = force_reg (SImode, arg);\n+\n+  if (target == NULL_RTX || ! REG_P (target))\n+    target = gen_reg_rtx (SImode);\n+\n+  emit_insn (gen_func (target, arg));\n+\n+  return target;\n+}\n+\n+static rtx\n+rx_expand_int_builtin_0_arg (rtx target, rtx (* gen_func)(rtx))\n+{\n+  if (target == NULL_RTX || ! REG_P (target))\n+    target = gen_reg_rtx (SImode);\n+\n+  emit_insn (gen_func (target));\n+\n+  return target;\n+}\n+\n+static rtx\n+rx_expand_builtin_round (rtx arg, rtx target)\n+{\n+  if ((! REG_P (arg) && ! MEM_P (arg))\n+      || GET_MODE (arg) != SFmode)\n+    arg = force_reg (SFmode, arg);\n+\n+  if (target == NULL_RTX || ! REG_P (target))\n+    target = gen_reg_rtx (SImode);\n+\n+  emit_insn (gen_lrintsf2 (target, arg));\n+\n+  return target;\n+}\n+\n+static rtx\n+rx_expand_builtin (tree exp,\n+\t\t   rtx target,\n+\t\t   rtx subtarget ATTRIBUTE_UNUSED,\n+\t\t   enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t   int ignore ATTRIBUTE_UNUSED)\n+{\n+  tree fndecl = TREE_OPERAND (CALL_EXPR_FN (exp), 0);\n+  tree arg    = CALL_EXPR_ARGS (exp) ? CALL_EXPR_ARG (exp, 0) : NULL_TREE;\n+  rtx  op     = arg ? expand_normal (arg) : NULL_RTX;\n+  unsigned int fcode = DECL_FUNCTION_CODE (fndecl);\n+\n+  switch (fcode)\n+    {\n+    case RX_BUILTIN_BRK:     emit_insn (gen_brk ()); return NULL_RTX;\n+    case RX_BUILTIN_CLRPSW:  return rx_expand_void_builtin_1_arg\n+\t(op, gen_clrpsw, false);\n+    case RX_BUILTIN_SETPSW:  return rx_expand_void_builtin_1_arg\n+\t(op, gen_setpsw, false);\n+    case RX_BUILTIN_INT:     return rx_expand_void_builtin_1_arg\n+\t(op, gen_int, false);\n+    case RX_BUILTIN_MACHI:   return rx_expand_builtin_mac (exp, gen_machi);\n+    case RX_BUILTIN_MACLO:   return rx_expand_builtin_mac (exp, gen_maclo);\n+    case RX_BUILTIN_MULHI:   return rx_expand_builtin_mac (exp, gen_mulhi);\n+    case RX_BUILTIN_MULLO:   return rx_expand_builtin_mac (exp, gen_mullo);\n+    case RX_BUILTIN_MVFACHI: return rx_expand_int_builtin_0_arg\n+\t(target, gen_mvfachi);\n+    case RX_BUILTIN_MVFACMI: return rx_expand_int_builtin_0_arg\n+\t(target, gen_mvfacmi);\n+    case RX_BUILTIN_MVTACHI: return rx_expand_void_builtin_1_arg\n+\t(op, gen_mvtachi, true);\n+    case RX_BUILTIN_MVTACLO: return rx_expand_void_builtin_1_arg\n+\t(op, gen_mvtaclo, true);\n+    case RX_BUILTIN_RMPA:    emit_insn (gen_rmpa ()); return NULL_RTX;\n+    case RX_BUILTIN_MVFC:    return rx_expand_builtin_mvfc (arg, target);\n+    case RX_BUILTIN_MVTC:    return rx_expand_builtin_mvtc (exp);\n+    case RX_BUILTIN_RACW:    return rx_expand_void_builtin_1_arg\n+\t(op, gen_racw, false);\n+    case RX_BUILTIN_ROUND:   return rx_expand_builtin_round (op, target);\n+    case RX_BUILTIN_REVW:    return rx_expand_int_builtin_1_arg\n+\t(op, target, gen_revw, false);\n+    case RX_BUILTIN_SAT:     return rx_expand_int_builtin_1_arg\n+\t(op, target, gen_sat, false);\n+    case RX_BUILTIN_WAIT:    emit_insn (gen_wait ()); return NULL_RTX;\n+\n+    default:\n+      internal_error (\"bad builtin code\");\n+      break;\n+    }\n+\n+  return NULL_RTX;\n+}\n+\f\n+/* Place an element into a constructor or destructor section.\n+   Like default_ctor_section_asm_out_constructor in varasm.c\n+   except that it uses .init_array (or .fini_array) and it\n+   handles constructor priorities.  */\n+\n+static void\n+rx_elf_asm_cdtor (rtx symbol, int priority, bool is_ctor)\n+{\n+  section * s;\n+\n+  if (priority != DEFAULT_INIT_PRIORITY)\n+    {\n+      char buf[18];\n+\n+      sprintf (buf, \"%s.%.5u\",\n+\t       is_ctor ? \".init_array\" : \".fini_array\",\n+\t       priority);\n+      s = get_section (buf, SECTION_WRITE, NULL_TREE);\n+    }\n+  else if (is_ctor)\n+    s = ctors_section;\n+  else\n+    s = dtors_section;\n+\n+  switch_to_section (s);\n+  assemble_align (POINTER_SIZE);\n+  assemble_integer (symbol, POINTER_SIZE / BITS_PER_UNIT, POINTER_SIZE, 1);\n+}\n+\n+static void\n+rx_elf_asm_constructor (rtx symbol, int priority)\n+{\n+  rx_elf_asm_cdtor (symbol, priority, /* is_ctor= */true);\n+}\n+\n+static void\n+rx_elf_asm_destructor (rtx symbol, int priority)\n+{\n+  rx_elf_asm_cdtor (symbol, priority, /* is_ctor= */false);\n+}\n+\f\n+/* Check \"interrupt\", \"exception\" and \"naked\" attributes.  */\n+\n+static tree\n+rx_handle_func_attribute (tree * node,\n+\t\t\t  tree   name,\n+\t\t\t  tree   args,\n+\t\t\t  int    flags ATTRIBUTE_UNUSED,\n+\t\t\t  bool * no_add_attrs)\n+{\n+  gcc_assert (DECL_P (* node));\n+  gcc_assert (args == NULL_TREE);\n+\n+  if (TREE_CODE (* node) != FUNCTION_DECL)\n+    {\n+      warning (OPT_Wattributes, \"%qE attribute only applies to functions\",\n+\t       name);\n+      * no_add_attrs = true;\n+    }\n+\n+  /* FIXME: We ought to check for conflicting attributes.  */\n+\n+  /* FIXME: We ought to check that the interrupt and exception\n+     handler attributes have been applied to void functions.  */\n+  return NULL_TREE;\n+}\n+\n+/* Table of RX specific attributes.  */\n+const struct attribute_spec rx_attribute_table[] =\n+{\n+  /* Name, min_len, max_len, decl_req, type_req, fn_type_req, handler.  */\n+  { \"interrupt\",      0, 0, true, false, false, rx_handle_func_attribute },\n+  { \"fast_interrupt\", 0, 0, true, false, false, rx_handle_func_attribute },\n+  { \"exception\",      0, 0, true, false, false, rx_handle_func_attribute },\n+  { \"naked\",          0, 0, true, false, false, rx_handle_func_attribute },\n+  { NULL,             0, 0, false, false, false, NULL }\n+};\n+\n+static bool\n+rx_allocate_stack_slots_for_args (void)\n+{\n+  /* Naked functions should not allocate stack slots for arguments.  */\n+  return ! is_naked_func (NULL_TREE);\n+}\n+\n+static bool\n+rx_func_attr_inlinable (const_tree decl)\n+{\n+  return ! is_fast_interrupt_func (decl)\n+    &&   ! is_exception_func (decl)\n+    &&   ! is_naked_func (decl);  \n+}\n+\n+static void\n+rx_file_start (void)\n+{\n+  if (! TARGET_AS100_SYNTAX)\n+    default_file_start ();\n+}\n+\n+static bool\n+rx_is_ms_bitfield_layout (const_tree record_type ATTRIBUTE_UNUSED)\n+{\n+  return TRUE;\n+}\n+\n+/* Try to generate code for the \"isnv\" pattern which inserts bits\n+   into a word.\n+     operands[0] => Location to be altered.\n+     operands[1] => Number of bits to change.\n+     operands[2] => Starting bit.\n+     operands[3] => Value to insert.\n+   Returns TRUE if successful, FALSE otherwise.  */\n+\n+bool\n+rx_expand_insv (rtx * operands)\n+{\n+  if (INTVAL (operands[1]) != 1\n+      || ! CONST_INT_P (operands[3]))\n+    return false;\n+\n+  if (MEM_P (operands[0])\n+      && INTVAL (operands[2]) > 7)\n+    return false;\n+\n+  switch (INTVAL (operands[3]))\n+    {\n+    case 0:\n+      if (MEM_P (operands[0]))\n+\temit_insn (gen_bitclr_in_memory (operands[0], operands[0],\n+\t\t\t\t\t operands[2]));\n+      else\n+\temit_insn (gen_bitclr (operands[0], operands[0], operands[2]));\n+      break;\n+    case 1:\n+    case -1:\n+      if (MEM_P (operands[0]))\n+\temit_insn (gen_bitset_in_memory (operands[0], operands[0],\n+\t\t\t\t\t operands[2]));\n+      else\n+\temit_insn (gen_bitset (operands[0], operands[0], operands[2]));\n+      break;\n+   default:\n+      return false;\n+    }\n+  return true;\n+}\n+\f\n+/* Returns true if X a legitimate constant for an immediate\n+   operand on the RX.  X is already known to satisfy CONSTANT_P.  */\n+\n+bool\n+rx_is_legitimate_constant (rtx x)\n+{\n+  HOST_WIDE_INT val;\n+\n+  switch (GET_CODE (x))\n+    {\n+    case CONST:\n+      x = XEXP (x, 0);\n+\n+      if (GET_CODE (x) == PLUS)\n+\t{\n+\t  if (! CONST_INT_P (XEXP (x, 1)))\n+\t    return false;\n+\n+\t  /* GCC would not pass us CONST_INT + CONST_INT so we\n+\t     know that we have {SYMBOL|LABEL} + CONST_INT.  */\n+\t  x = XEXP (x, 0);\n+\t  gcc_assert (! CONST_INT_P (x));\n+\t}\n+\n+      switch (GET_CODE (x))\n+\t{\n+\tcase LABEL_REF:\n+\tcase SYMBOL_REF:\n+\t  return true;\n+\n+\t  /* One day we may have to handle UNSPEC constants here.  */\n+\tdefault:\n+\t  /* FIXME: Can this ever happen ?  */\n+\t  abort ();\n+\t  return false;\n+\t}\n+      break;\n+      \n+    case LABEL_REF:\n+    case SYMBOL_REF:\n+      return true;\n+    case CONST_DOUBLE:\n+      return rx_max_constant_size == 0;\n+    case CONST_VECTOR:\n+      return false;\n+    default:\n+      gcc_assert (CONST_INT_P (x));\n+      break;\n+    }\n+\n+  if (rx_max_constant_size == 0)\n+    /* If there is no constraint on the size of constants\n+       used as operands, then any value is legitimate.  */\n+    return true;\n+\n+  val = INTVAL (x);\n+\n+  /* rx_max_constant_size specifies the maximum number\n+     of bytes that can be used to hold a signed value.  */\n+  return IN_RANGE (val, (-1 << (rx_max_constant_size * 8)),\n+\t\t        ( 1 << (rx_max_constant_size * 8)));\n+}\n+\n+/* Extra processing for target specific command line options.  */\n+\n+static bool\n+rx_handle_option (size_t code, const char *  arg ATTRIBUTE_UNUSED, int value)\n+{\n+  switch (code)\n+    {\n+    case OPT_mint_register_:\n+      switch (value)\n+\t{\n+\tcase 4:\n+\t  fixed_regs[10] = call_used_regs [10] = 1;\n+\t  /* Fall through.  */\n+\tcase 3:\n+\t  fixed_regs[11] = call_used_regs [11] = 1;\n+\t  /* Fall through.  */\n+\tcase 2:\n+\t  fixed_regs[12] = call_used_regs [12] = 1;\n+\t  /* Fall through.  */\n+\tcase 1:\n+\t  fixed_regs[13] = call_used_regs [13] = 1;\n+\t  /* Fall through.  */\n+\tcase 0:\n+\t  return true;\n+\tdefault:\n+\t  return false;\n+\t}\n+      break;\n+\n+    case OPT_mmax_constant_size_:\n+      /* Make sure that the the -mmax-constant_size option is in range.  */\n+      return IN_RANGE (value, 0, 4);\n+\n+    default:\n+      return true;\n+    }\n+}\n+\n+static int\n+rx_address_cost (rtx addr, bool speed)\n+{\n+  rtx a, b;\n+\n+  if (GET_CODE (addr) != PLUS)\n+    return COSTS_N_INSNS (1);\n+\n+  a = XEXP (addr, 0);\n+  b = XEXP (addr, 1);\n+\n+  if (REG_P (a) && REG_P (b))\n+    /* Try to discourage REG+REG addressing as it keeps two registers live.  */\n+    return COSTS_N_INSNS (4);\n+\n+  if (speed)\n+    /* [REG+OFF] is just as fast as [REG].  */\n+    return COSTS_N_INSNS (1);\n+\n+  if (CONST_INT_P (b)\n+      && ((INTVAL (b) > 128) || INTVAL (b) < -127))\n+    /* Try to discourage REG + <large OFF> when optimizing for size.  */\n+    return COSTS_N_INSNS (2);\n+    \n+  return COSTS_N_INSNS (1);\n+}\n+\n+static bool\n+rx_can_eliminate (const int from ATTRIBUTE_UNUSED, const int to)\n+{\n+  /* We can always eliminate to the frame pointer.\n+     We can eliminate to the stack pointer unless a frame\n+     pointer is needed.  */\n+\n+  return to == FRAME_POINTER_REGNUM\n+    || ( to == STACK_POINTER_REGNUM && ! frame_pointer_needed);\n+}\n+\f\n+\n+static void\n+rx_trampoline_template (FILE * file)\n+{\n+  /* Output assembler code for a block containing the constant\n+     part of a trampoline, leaving space for the variable parts.\n+\n+     On the RX, (where r8 is the static chain regnum) the trampoline\n+     looks like:\n+\n+\t   mov \t\t#<static chain value>, r8\n+\t   mov          #<function's address>, r9\n+\t   jmp\t\tr9\n+\n+     In big-endian-data-mode however instructions are read into the CPU\n+     4 bytes at a time.  These bytes are then swapped around before being\n+     passed to the decoder.  So...we must partition our trampoline into\n+     4 byte packets and swap these packets around so that the instruction\n+     reader will reverse the process.  But, in order to avoid splitting\n+     the 32-bit constants across these packet boundaries, (making inserting\n+     them into the constructed trampoline very difficult) we have to pad the\n+     instruction sequence with NOP insns.  ie:\n+\n+           nop\n+\t   nop\n+           mov.l\t#<...>, r8\n+\t   nop\n+\t   nop\n+           mov.l\t#<...>, r9\n+           jmp\t\tr9\n+\t   nop\n+\t   nop             */\n+\n+  if (! TARGET_BIG_ENDIAN_DATA)\n+    {\n+      asm_fprintf (file, \"\\tmov.L\\t#0deadbeefH, r%d\\n\", STATIC_CHAIN_REGNUM);\n+      asm_fprintf (file, \"\\tmov.L\\t#0deadbeefH, r%d\\n\", TRAMPOLINE_TEMP_REGNUM);\n+      asm_fprintf (file, \"\\tjmp\\tr%d\\n\",                TRAMPOLINE_TEMP_REGNUM);\n+    }\n+  else\n+    {\n+      char r8 = '0' + STATIC_CHAIN_REGNUM;\n+      char r9 = '0' + TRAMPOLINE_TEMP_REGNUM;\n+\n+      if (TARGET_AS100_SYNTAX)\n+        {\n+          asm_fprintf (file, \"\\t.BYTE 0%c2H, 0fbH, 003H,  003H\\n\", r8);\n+          asm_fprintf (file, \"\\t.BYTE 0deH,  0adH, 0beH,  0efH\\n\");\n+          asm_fprintf (file, \"\\t.BYTE 0%c2H, 0fbH, 003H,  003H\\n\", r9);\n+          asm_fprintf (file, \"\\t.BYTE 0deH,  0adH, 0beH,  0efH\\n\");\n+          asm_fprintf (file, \"\\t.BYTE 003H,  003H, 00%cH, 07fH\\n\", r9);\n+        }\n+      else\n+        {\n+          asm_fprintf (file, \"\\t.byte 0x%c2, 0xfb, 0x03,  0x03\\n\", r8);\n+          asm_fprintf (file, \"\\t.byte 0xde,  0xad, 0xbe,  0xef\\n\");\n+          asm_fprintf (file, \"\\t.byte 0x%c2, 0xfb, 0x03,  0x03\\n\", r9);\n+          asm_fprintf (file, \"\\t.byte 0xde,  0xad, 0xbe,  0xef\\n\");\n+          asm_fprintf (file, \"\\t.byte 0x03,  0x03, 0x0%c, 0x7f\\n\", r9);\n+        }\n+    }\n+}\n+\n+static void\n+rx_trampoline_init (rtx tramp, tree fndecl, rtx chain)\n+{\n+  rtx fnaddr = XEXP (DECL_RTL (fndecl), 0);\n+\n+  emit_block_move (tramp, assemble_trampoline_template (),\n+\t\t   GEN_INT (TRAMPOLINE_SIZE), BLOCK_OP_NORMAL);\n+\n+  if (TARGET_BIG_ENDIAN_DATA)\n+    {\n+      emit_move_insn (adjust_address (tramp, SImode, 4), chain);\n+      emit_move_insn (adjust_address (tramp, SImode, 12), fnaddr);\n+    }\n+  else\n+    {\n+      emit_move_insn (adjust_address (tramp, SImode, 2), chain);\n+      emit_move_insn (adjust_address (tramp, SImode, 6 + 2), fnaddr);\n+    }\n+}\n+\f\n+#undef  TARGET_FUNCTION_VALUE\n+#define TARGET_FUNCTION_VALUE\t\trx_function_value\n+\n+#undef  TARGET_RETURN_IN_MSB\n+#define TARGET_RETURN_IN_MSB\t\trx_return_in_msb\n+\n+#undef  TARGET_IN_SMALL_DATA_P\n+#define TARGET_IN_SMALL_DATA_P\t\trx_in_small_data\n+\n+#undef  TARGET_RETURN_IN_MEMORY\n+#define TARGET_RETURN_IN_MEMORY\t\trx_return_in_memory\n+\n+#undef  TARGET_HAVE_SRODATA_SECTION\n+#define TARGET_HAVE_SRODATA_SECTION\ttrue\n+\n+#undef\tTARGET_ASM_SELECT_RTX_SECTION\n+#define\tTARGET_ASM_SELECT_RTX_SECTION\trx_select_rtx_section\n+\n+#undef\tTARGET_ASM_SELECT_SECTION\n+#define\tTARGET_ASM_SELECT_SECTION\trx_select_section\n+\n+#undef  TARGET_INIT_BUILTINS\n+#define TARGET_INIT_BUILTINS\t\trx_init_builtins\n+\n+#undef  TARGET_EXPAND_BUILTIN\n+#define TARGET_EXPAND_BUILTIN\t\trx_expand_builtin\n+\n+#undef  TARGET_ASM_CONSTRUCTOR\n+#define TARGET_ASM_CONSTRUCTOR\t\trx_elf_asm_constructor\n+\n+#undef  TARGET_ASM_DESTRUCTOR\n+#define TARGET_ASM_DESTRUCTOR\t\trx_elf_asm_destructor\n+\n+#undef  TARGET_STRUCT_VALUE_RTX\n+#define TARGET_STRUCT_VALUE_RTX\t\trx_struct_value_rtx\n+\n+#undef  TARGET_ATTRIBUTE_TABLE\n+#define TARGET_ATTRIBUTE_TABLE\t\trx_attribute_table\n+\n+#undef  TARGET_ASM_FILE_START\n+#define TARGET_ASM_FILE_START\t\t\trx_file_start\n+\n+#undef  TARGET_MS_BITFIELD_LAYOUT_P\n+#define TARGET_MS_BITFIELD_LAYOUT_P\t\trx_is_ms_bitfield_layout\n+\n+#undef  TARGET_LEGITIMATE_ADDRESS_P\n+#define TARGET_LEGITIMATE_ADDRESS_P\t\trx_is_legitimate_address\n+\n+#undef  TARGET_ALLOCATE_STACK_SLOTS_FOR_ARGS\n+#define TARGET_ALLOCATE_STACK_SLOTS_FOR_ARGS\trx_allocate_stack_slots_for_args\n+\n+#undef  TARGET_ASM_FUNCTION_PROLOGUE\n+#define TARGET_ASM_FUNCTION_PROLOGUE \t\trx_output_function_prologue\n+\n+#undef  TARGET_FUNCTION_ATTRIBUTE_INLINABLE_P\n+#define TARGET_FUNCTION_ATTRIBUTE_INLINABLE_P \trx_func_attr_inlinable\n+\n+#undef  TARGET_SET_CURRENT_FUNCTION\n+#define TARGET_SET_CURRENT_FUNCTION\t\trx_set_current_function\n+\n+#undef  TARGET_HANDLE_OPTION\n+#define TARGET_HANDLE_OPTION\t\t\trx_handle_option\n+\n+#undef  TARGET_ASM_INTEGER\n+#define TARGET_ASM_INTEGER\t\t\trx_assemble_integer\n+\n+#undef  TARGET_USE_BLOCKS_FOR_CONSTANT_P\n+#define TARGET_USE_BLOCKS_FOR_CONSTANT_P\thook_bool_mode_const_rtx_true\n+\n+#undef  TARGET_MAX_ANCHOR_OFFSET\n+#define TARGET_MAX_ANCHOR_OFFSET\t\t32\n+\n+#undef  TARGET_ADDRESS_COST\n+#define TARGET_ADDRESS_COST\t\t\trx_address_cost\n+\n+#undef  TARGET_CAN_ELIMINATE\n+#define TARGET_CAN_ELIMINATE\t\t\trx_can_eliminate\n+\n+#undef  TARGET_ASM_TRAMPOLINE_TEMPLATE\n+#define TARGET_ASM_TRAMPOLINE_TEMPLATE\t\trx_trampoline_template\n+\n+#undef  TARGET_TRAMPOLINE_INIT\n+#define TARGET_TRAMPOLINE_INIT\t\t\trx_trampoline_init\n+\n+struct gcc_target targetm = TARGET_INITIALIZER;\n+\n+/* #include \"gt-rx.h\" */"}, {"sha": "a01e194910ba555a889ace7e7f186a2a913d0134", "filename": "gcc/config/rx/rx.h", "status": "added", "additions": 632, "deletions": 0, "changes": 632, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65a324b459e60405cebe9e34ee6b3496559cd217/gcc%2Fconfig%2Frx%2Frx.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65a324b459e60405cebe9e34ee6b3496559cd217/gcc%2Fconfig%2Frx%2Frx.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frx%2Frx.h?ref=65a324b459e60405cebe9e34ee6b3496559cd217", "patch": "@@ -0,0 +1,632 @@\n+/* GCC backend definitions for the Renesas RX processor.\n+   Copyright (C) 2008, 2009 Free Software Foundation, Inc.\n+   Contributed by Red Hat.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 3, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\f\n+\n+#define TARGET_CPU_CPP_BUILTINS()               \\\n+  do                                            \\\n+    {                                           \\\n+      builtin_define (\"__RX__\"); \t\t\\\n+      builtin_assert (\"cpu=RX\"); \t\t\\\n+      builtin_assert (\"machine=RX\");\t\t\\\n+      \t\t\t\t\t\t\\\n+      if (TARGET_BIG_ENDIAN_DATA)\t\t\\\n+\tbuiltin_define (\"__RX_BIG_ENDIAN__\");\t\\\n+      else\t\t\t\t\t\\\n+\tbuiltin_define (\"__RX_LITTLE_ENDIAN__\");\\\n+      \t\t\t\t\t\t\\\n+      if (TARGET_64BIT_DOUBLES)\t\t\t\\\n+\tbuiltin_define (\"__RX_64BIT_DOUBLES__\");\\\n+      else\t\t\t\t\t\\\n+\tbuiltin_define (\"__RX_32BIT_DOUBLES__\");\\\n+      \t\t\t\t\t\t\\\n+      if (TARGET_AS100_SYNTAX)\t\t\t\\\n+\tbuiltin_define (\"__RX_AS100_SYNTAX__\"); \\\n+      else\t\t\t\t\t\\\n+\tbuiltin_define (\"__RX_GAS_SYNTAX__\");   \\\n+    }                                           \\\n+  while (0)\n+\n+#undef  STARTFILE_SPEC\n+#define STARTFILE_SPEC \"%{pg:gcrt0.o%s}%{!pg:crt0.o%s} crtbegin.o%s\"\n+\n+#undef  ENDFILE_SPEC\n+#define ENDFILE_SPEC \"crtend.o%s crtn.o%s\"\n+\n+#undef  ASM_SPEC\n+#define ASM_SPEC \"\\\n+%{mbig-endian-data:-mbig-endian-data} \\\n+%{m64bit-doubles:-m64bit-doubles} \\\n+%{msmall-data-limit*:-msmall-data-limit} \\\n+%{mrelax:-relax} \\\n+\"\n+\n+#undef  LIB_SPEC\n+#define LIB_SPEC \"\t\t\t\t\t\\\n+--start-group\t\t\t\t\t\t\\\n+-lc\t\t\t\t\t\t\t\\\n+%{msim*:-lsim}%{!msim*:-lnosys}\t\t\t\t\\\n+%{fprofile-arcs|fprofile-generate|coverage:-lgcov} \t\\\n+--end-group\t\t\t\t\t   \t\\\n+%{!T*: %{msim*:%Trx-sim.ld}%{!msim*:%Trx.ld}}\t\t\\\n+\"\n+\n+#undef  LINK_SPEC\n+#define LINK_SPEC \"%{mbig-endian-data:--oformat elf32-rx-be} %{mrelax:-relax}\"\n+\f\n+\n+#define BITS_BIG_ENDIAN \t\t0\n+#define BYTES_BIG_ENDIAN \t\tTARGET_BIG_ENDIAN_DATA\n+#define WORDS_BIG_ENDIAN \t\tTARGET_BIG_ENDIAN_DATA\n+\n+#ifdef __RX_BIG_ENDIAN__\n+#define LIBGCC2_WORDS_BIG_ENDIAN\t1\n+#else\n+#define LIBGCC2_WORDS_BIG_ENDIAN\t0\n+#endif\n+\n+#define UNITS_PER_WORD \t\t\t4\n+\n+#define INT_TYPE_SIZE\t\t\t32\n+#define LONG_TYPE_SIZE\t\t\t32\n+#define LONG_LONG_TYPE_SIZE\t\t64\n+\n+#define FLOAT_TYPE_SIZE \t\t32\n+#define DOUBLE_TYPE_SIZE \t\t(TARGET_64BIT_DOUBLES ? 64 : 32)\n+#define LONG_DOUBLE_TYPE_SIZE\t\tDOUBLE_TYPE_SIZE\n+\n+#ifdef __RX_64BIT_DOUBLES__\n+#define LIBGCC2_LONG_DOUBLE_TYPE_SIZE   64\n+#define LIBGCC2_DOUBLE_TYPE_SIZE\t64\n+#define LIBGCC2_HAS_DF_MODE\t\t1\n+#else\n+#define LIBGCC2_LONG_DOUBLE_TYPE_SIZE   32\n+#define LIBGCC2_DOUBLE_TYPE_SIZE\t32\n+#endif\n+\n+#define DEFAULT_SIGNED_CHAR\t\t0\n+\n+#define STRICT_ALIGNMENT \t\t1\n+#define FUNCTION_BOUNDARY \t\t8\n+#define BIGGEST_ALIGNMENT \t\t32\n+#define STACK_BOUNDARY \t\t\t32\n+#define PARM_BOUNDARY \t\t\t8\n+\n+#define FUNCTION_ARG_BOUNDARY(MODE, TYPE) 32\n+\n+#define STACK_GROWS_DOWNWARD\t\t1\n+#define FRAME_GROWS_DOWNWARD\t\t0\n+#define FIRST_PARM_OFFSET(FNDECL) \t0\n+\n+#define MAX_REGS_PER_ADDRESS \t\t2\n+\n+#define Pmode \t\t\t\tSImode\n+#define POINTER_SIZE\t\t\t32\n+#undef  SIZE_TYPE\n+#define SIZE_TYPE\t\t\t\"long unsigned int\"\n+#define POINTERS_EXTEND_UNSIGNED\t1\n+#define FUNCTION_MODE \t\t\tQImode\n+#define CASE_VECTOR_MODE\t\tPmode\n+#define WORD_REGISTER_OPERATIONS\t1\n+#define HAS_LONG_COND_BRANCH\t\t0\n+#define HAS_LONG_UNCOND_BRANCH\t\t0\n+\n+#define MOVE_MAX \t\t\t4\n+#define STARTING_FRAME_OFFSET\t\t0\n+\n+#define RETURN_POPS_ARGS(FUNDECL, FUNTYPE, SIZE) 0\n+#define TRULY_NOOP_TRUNCATION(OUTPREC, INPREC)   1\n+\n+#define LEGITIMATE_CONSTANT_P(X) \trx_is_legitimate_constant (X)\n+\n+#define HANDLE_PRAGMA_PACK_PUSH_POP\t1\n+\n+#define HAVE_PRE_DECCREMENT\t\t1\n+#define HAVE_POST_INCREMENT\t\t1\n+\n+#define MOVE_RATIO(SPEED) \t\t((SPEED) ? 4 : 2)\n+#define SLOW_BYTE_ACCESS\t\t1\n+\n+#define STORE_FLAG_VALUE\t\t1\n+#define LOAD_EXTEND_OP(MODE)\t\tSIGN_EXTEND\n+#define SHORT_IMMEDIATES_SIGN_EXTEND\t1\n+\f\n+enum reg_class\n+{\n+  NO_REGS,\t\t\t/* No registers in set.  */\n+  GR_REGS,\t\t\t/* Integer registers.  */\n+  ALL_REGS,\t\t\t/* All registers.  */\n+  LIM_REG_CLASSES\t\t/* Max value + 1.  */\n+};\n+\n+#define REG_CLASS_NAMES\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\\\n+  \"NO_REGS\",\t\t\t\t\t\t\\\n+  \"GR_REGS\",\t\t\t\t\t\t\\\n+  \"ALL_REGS\"\t\t\t\t\t\t\\\n+}\n+\n+#define REG_CLASS_CONTENTS\t\t\t\t\\\n+{\t\t\t\t\t\t\t\\\n+  { 0x00000000 },\t/* No registers,  */\t\t\\\n+  { 0x0000ffff },\t/* Integer registers.  */\t\\\n+  { 0x0000ffff }\t/* All registers.  */\t\t\\\n+}\n+\n+#define IRA_COVER_CLASSES\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\\\n+    GR_REGS, LIM_REG_CLASSES\t\t\t\t\\\n+  }\n+\n+#define SMALL_REGISTER_CLASSES \t\t0\n+#define N_REG_CLASSES\t\t\t(int) LIM_REG_CLASSES\n+#define CLASS_MAX_NREGS(CLASS, MODE)    ((GET_MODE_SIZE (MODE) \\\n+\t\t\t\t\t  + UNITS_PER_WORD - 1) \\\n+\t\t\t\t\t / UNITS_PER_WORD)\n+\n+#define GENERAL_REGS\t\t\tGR_REGS\n+#define BASE_REG_CLASS  \t\tGR_REGS\n+#define INDEX_REG_CLASS\t\t\tGR_REGS\n+\n+#define FIRST_PSEUDO_REGISTER \t\t16\n+\n+#define REGNO_REG_CLASS(REGNO)          ((REGNO) < FIRST_PSEUDO_REGISTER \\\n+\t\t\t\t\t ? GR_REGS : NO_REGS)\n+\n+#define STACK_POINTER_REGNUM \t        0\n+#define FUNC_RETURN_REGNUM              1\n+#define FRAME_POINTER_REGNUM \t\t6\n+#define ARG_POINTER_REGNUM \t\t7\n+#define STATIC_CHAIN_REGNUM \t\t8\n+#define TRAMPOLINE_TEMP_REGNUM\t\t9\n+#define STRUCT_VAL_REGNUM\t\t15\n+\n+/* This is the register which is used to hold the address of the start\n+   of the small data area, if that feature is being used.  Note - this\n+   register must not be call_used because otherwise library functions\n+   that are compiled without small data support might clobber it.\n+\n+   FIXME: The function gcc/config/rx/rx.c:rx_gen_move_template() has a\n+   built in copy of this register's name, rather than constructing the\n+   name from this #define.  */\n+#define GP_BASE_REGNUM\t\t\t13\n+\n+#define ELIMINABLE_REGS\t\t\t\t\t\\\n+{{ ARG_POINTER_REGNUM,   STACK_POINTER_REGNUM },\t\\\n+ { ARG_POINTER_REGNUM,   FRAME_POINTER_REGNUM },\t\\\n+ { FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM }}\n+\n+#define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET)\t\\\n+  (OFFSET) = rx_initial_elimination_offset ((FROM), (TO))\n+\n+\n+#define FUNCTION_ARG_REGNO_P(N)\t  \t(((N) >= 1) && ((N) <= 4))\n+#define FUNCTION_VALUE_REGNO_P(N) \t((N) == FUNC_RETURN_REGNUM)\n+#define DEFAULT_PCC_STRUCT_RETURN\t0\n+\n+#define FIXED_REGISTERS\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\\\n+  1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\t\\\n+}\n+\n+#define CALL_USED_REGISTERS\t\t\t\t\\\n+{\t\t\t\t\t\t\t\\\n+  1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1\t\\\n+}\n+\n+#define CONDITIONAL_REGISTER_USAGE\t\t\t\\\n+  rx_conditional_register_usage ()\n+\n+#define LIBCALL_VALUE(MODE)\t\t\t\t\\\n+  gen_rtx_REG (((GET_MODE_CLASS (MODE) != MODE_INT\t\\\n+\t\t || GET_MODE_SIZE (MODE) >= 4)\t\t\\\n+\t\t? (MODE)\t\t\t\t\\\n+\t\t: SImode),\t\t\t\t\\\n+\t       FUNC_RETURN_REGNUM)\n+\n+/* Order of allocation of registers.  */\n+\n+#define REG_ALLOC_ORDER\t\t\t\t\t\t\\\n+{  7,  10,  11,  12,  13,  14,  4,  3,  2,  1, 9, 8, 6, 5, 15\t\\\n+}\n+\n+#define PREFERRED_RELOAD_CLASS(X,CLASS)\t\tCLASS\n+\n+#define REGNO_IN_RANGE(REGNO, MIN, MAX)\t\t\\\n+  (IN_RANGE ((REGNO), (MIN), (MAX)) \t\t\\\n+   || (reg_renumber != NULL\t\t\t\\\n+       && reg_renumber[(REGNO)] >= (MIN)\t\\\n+       && reg_renumber[(REGNO)] <= (MAX)))\n+\n+#ifdef REG_OK_STRICT\n+#define REGNO_OK_FOR_BASE_P(regno)      REGNO_IN_RANGE (regno, 0, 15)\n+#else\n+#define REGNO_OK_FOR_BASE_P(regno)\t1\n+#endif\n+\n+#define REGNO_OK_FOR_INDEX_P(regno)\tREGNO_OK_FOR_BASE_P (regno)\n+\n+#define RTX_OK_FOR_BASE(X, STRICT)\t\t\t\t\\\n+  ((STRICT) ?\t\t\t\t\t\t\t\\\n+   (   (REG_P (X)\t\t\t\t\t\t\\\n+        && REGNO_IN_RANGE (REGNO (X), 0, 15))\t\t\t\\\n+    || (GET_CODE (X) == SUBREG\t\t\t\t\t\\\n+        && REG_P (SUBREG_REG (X))\t\t\t\t\\\n+        && REGNO_IN_RANGE (REGNO (SUBREG_REG (X)), 0, 15)))\t\\\n+   :\t\t\t\t\t\t\t\t\\\n+    ( (REG_P (X)\t\t\t\t\t\t\\\n+       || (GET_CODE (X) == SUBREG\t\t\t\t\\\n+\t   && REG_P (SUBREG_REG (X))))))\n+\n+#define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR, LABEL)\t\\\n+  do\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      if (rx_is_mode_dependent_addr (ADDR))\t\t\\\n+        goto LABEL;\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\\\n+  while (0)\n+\f\n+\n+#define RETURN_ADDR_RTX(COUNT, FRAMEADDR)\t\t\t\t\\\n+  ((COUNT) == 0\t\t\t\t\t\t\t\t\\\n+   ? gen_rtx_MEM (Pmode, gen_rtx_PLUS (Pmode, arg_pointer_rtx, GEN_INT (-4))) \\\n+   : NULL_RTX)\n+\n+#define INCOMING_RETURN_ADDR_RTX\tgen_rtx_MEM (Pmode, stack_pointer_rtx)\n+\n+#define ACCUMULATE_OUTGOING_ARGS\t1\n+\n+typedef unsigned int CUMULATIVE_ARGS;\n+\n+#define INIT_CUMULATIVE_ARGS(CUM, FNTYPE, LIBNAME, INDIRECT, N_NAMED_ARGS) \\\n+  (CUM) = 0\n+\n+#define FUNCTION_ARG(CUM, MODE, TYPE, NAMED) \\\n+  rx_function_arg (& CUM, MODE, TYPE, NAMED)\n+\n+#define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED)\t\\\n+  (CUM) += rx_function_arg_size (MODE, TYPE)\n+\f\n+#define TRAMPOLINE_SIZE \t(! TARGET_BIG_ENDIAN_DATA ? 14 : 20)\n+#define TRAMPOLINE_ALIGNMENT \t32\n+\f\n+#define NO_PROFILE_COUNTERS     1\n+#define PROFILE_BEFORE_PROLOGUE 1\n+\n+#define FUNCTION_PROFILER(FILE, LABELNO)\t\\\n+    fprintf (FILE, \"\\tbsr\\t__mcount\\n\");\n+\f\n+\n+#define HARD_REGNO_NREGS(REGNO, MODE)   CLASS_MAX_NREGS (0, MODE)\n+\n+#define HARD_REGNO_MODE_OK(REGNO, MODE) \t\t\t\\\n+  REGNO_REG_CLASS (REGNO) == GR_REGS\n+\n+#define MODES_TIEABLE_P(MODE1, MODE2)\t\t\t\t\\\n+  (   (   GET_MODE_CLASS (MODE1) == MODE_FLOAT\t\t\t\\\n+       || GET_MODE_CLASS (MODE1) == MODE_COMPLEX_FLOAT)\t\t\\\n+   == (   GET_MODE_CLASS (MODE2) == MODE_FLOAT\t\t\t\\\n+       || GET_MODE_CLASS (MODE2) == MODE_COMPLEX_FLOAT))\n+\f\n+\n+#define REGISTER_NAMES\t\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\\\n+    \"r0\",  \"r1\",  \"r2\",   \"r3\",   \"r4\",   \"r5\",   \"r6\",   \"r7\",\t\\\n+    \"r8\",  \"r9\",  \"r10\",  \"r11\",  \"r12\",  \"r13\",  \"r14\",  \"r15\" \\\n+  };\n+\n+#define ADDITIONAL_REGISTER_NAMES\t\\\n+{\t\t\t\t\t\\\n+    { \"sp\",    STACK_POINTER_REGNUM }\t\\\n+  , { \"fp\",    FRAME_POINTER_REGNUM }\t\\\n+  , { \"arg\",   ARG_POINTER_REGNUM }\t\\\n+  , { \"chain\", STATIC_CHAIN_REGNUM }\t\\\n+}\n+\n+#define DATA_SECTION_ASM_OP\t      \t\t\t\\\n+  (TARGET_AS100_SYNTAX ? \"\\t.SECTION D,DATA\" \t\t\\\n+   : \"\\t.section D,\\\"aw\\\",@progbits\\n\\t.p2align 2\")\n+\n+#define SDATA_SECTION_ASM_OP\t      \t\t\t\\\n+  (TARGET_AS100_SYNTAX ? \"\\t.SECTION D_2,DATA,ALIGN=2\" \t\\\n+   : \"\\t.section D_2,\\\"aw\\\",@progbits\\n\\t.p2align 1\")\n+\n+#undef  READONLY_DATA_SECTION_ASM_OP\n+#define READONLY_DATA_SECTION_ASM_OP  \t\t\t\\\n+  (TARGET_AS100_SYNTAX ? \"\\t.SECTION C,ROMDATA,ALIGN=4\" \\\n+   : \"\\t.section C,\\\"a\\\",@progbits\\n\\t.p2align 2\")\n+\n+#define BSS_SECTION_ASM_OP\t      \t\t\t\\\n+  (TARGET_AS100_SYNTAX ? \"\\t.SECTION B,DATA,ALIGN=4\" \t\\\n+   : \"\\t.section B,\\\"w\\\",@nobits\\n\\t.p2align 2\")\n+\n+#define SBSS_SECTION_ASM_OP\t      \t\t\t\\\n+  (TARGET_AS100_SYNTAX ? \"\\t.SECTION B_2,DATA,ALIGN=2\" \t\\\n+   : \"\\t.section B_2,\\\"w\\\",@nobits\\n\\t.p2align 1\")\n+\n+/* The following definitions are conditional depending upon whether the\n+   compiler is being built or crtstuff.c is being compiled by the built\n+   compiler.  */\n+#if defined CRT_BEGIN || defined CRT_END\n+# ifdef __RX_AS100_SYNTAX\n+#  define TEXT_SECTION_ASM_OP\t      \"\\t.SECTION P,CODE\"\n+#  define CTORS_SECTION_ASM_OP\t      \"\\t.SECTION init_array,CODE\"\n+#  define DTORS_SECTION_ASM_OP\t      \"\\t.SECTION fini_array,CODE\"\n+#  define INIT_ARRAY_SECTION_ASM_OP   \"\\t.SECTION init_array,CODE\"\n+#  define FINI_ARRAY_SECTION_ASM_OP   \"\\t.SECTION fini_array,CODE\"\n+# else\n+#  define TEXT_SECTION_ASM_OP\t      \"\\t.section P,\\\"ax\\\"\"\n+#  define CTORS_SECTION_ASM_OP\t      \\\n+  \"\\t.section\\t.init_array,\\\"aw\\\",@init_array\"\n+#  define DTORS_SECTION_ASM_OP\t      \\\n+  \"\\t.section\\t.fini_array,\\\"aw\\\",@fini_array\"\n+#  define INIT_ARRAY_SECTION_ASM_OP   \\\n+  \"\\t.section\\t.init_array,\\\"aw\\\",@init_array\"\n+#  define FINI_ARRAY_SECTION_ASM_OP   \\\n+  \"\\t.section\\t.fini_array,\\\"aw\\\",@fini_array\"\n+# endif\n+#else\n+# define TEXT_SECTION_ASM_OP\t      \\\n+  (TARGET_AS100_SYNTAX ? \"\\t.SECTION P,CODE\" : \"\\t.section P,\\\"ax\\\"\")\n+\n+# define CTORS_SECTION_ASM_OP\t\t\t      \\\n+  (TARGET_AS100_SYNTAX ? \"\\t.SECTION init_array,CODE\" \\\n+   : \"\\t.section\\t.init_array,\\\"aw\\\",@init_array\")\n+\n+# define DTORS_SECTION_ASM_OP\t\t\t      \\\n+  (TARGET_AS100_SYNTAX ? \"\\t.SECTION fini_array,CODE\" \\\n+   : \"\\t.section\\t.fini_array,\\\"aw\\\",@fini_array\")\n+\n+# define INIT_ARRAY_SECTION_ASM_OP\t\t      \\\n+  (TARGET_AS100_SYNTAX ? \"\\t.SECTION init_array,CODE\" \\\n+   : \"\\t.section\\t.init_array,\\\"aw\\\",@init_array\")\n+\n+# define FINI_ARRAY_SECTION_ASM_OP\t\t      \\\n+  (TARGET_AS100_SYNTAX ? \"\\t.SECTION fini_array,CODE\" \\\n+   : \"\\t.section\\t.fini_array,\\\"aw\\\",@fini_array\")\n+#endif\n+\n+#define GLOBAL_ASM_OP \t\t\\\n+  (TARGET_AS100_SYNTAX ? \"\\t.GLB\\t\" : \"\\t.global\\t\")\n+#define ASM_COMMENT_START\t\" ;\"\n+#define ASM_APP_ON\t\t\"\"\n+#define ASM_APP_OFF \t\t\"\"\n+#define LOCAL_LABEL_PREFIX\t\"L\"\n+#undef  USER_LABEL_PREFIX\n+#define USER_LABEL_PREFIX\t\"_\"\n+\n+#define ASM_OUTPUT_ALIGN(STREAM, LOG)\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      if ((LOG) == 0)\t\t\t\t\\\n+        break;\t\t\t\t\t\\\n+      if (TARGET_AS100_SYNTAX)\t\t\t\\\n+\t{\t\t\t\t\t\\\n+\t  if ((LOG) >= 2)\t\t\t\\\n+\t    fprintf (STREAM, \"\\t.ALIGN 4\\t; %d alignment actually requested\\n\", 1 << (LOG)); \\\n+\t  else\t\t\t\t\t\\\n+\t    fprintf (STREAM, \"\\t.ALIGN 2\\n\");\t\\\n+\t}\t\t\t\t\t\\\n+      else\t\t\t\t\t\\\n+\tfprintf (STREAM, \"\\t.balign %d\\n\", 1 << (LOG));\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+\n+#define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE) \\\n+  fprintf (FILE, TARGET_AS100_SYNTAX ? \"\\t.LWORD L%d\\n\" : \"\\t.long .L%d\\n\", \\\n+\t   VALUE)\n+\n+/* This is how to output an element of a case-vector that is relative.\n+   Note: The local label referenced by the \"3b\" below is emitted by\n+   the tablejump insn.  */\n+\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL) \\\n+  fprintf (FILE, TARGET_AS100_SYNTAX \\\n+\t   ? \"\\t.LWORD L%d - ?-\\n\" : \"\\t.long .L%d - 1b\\n\", VALUE)\n+\n+#define ASM_OUTPUT_SIZE_DIRECTIVE(STREAM, NAME, SIZE)\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      HOST_WIDE_INT size_ = (SIZE);\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      /* The as100 assembler does not have an equivalent of the SVR4    \\\n+\t .size pseudo-op.  */\t\t\t\t\t\t\\\n+      if (TARGET_AS100_SYNTAX)\t\t\t\t\t\t\\\n+\tbreak;\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      fputs (SIZE_ASM_OP, STREAM);\t\t\t\t\t\\\n+      assemble_name (STREAM, NAME);\t\t\t\t\t\\\n+      fprintf (STREAM, \", \" HOST_WIDE_INT_PRINT_DEC \"\\n\", size_);\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  while (0)\n+\n+#define ASM_OUTPUT_MEASURED_SIZE(STREAM, NAME)\t\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      /* The as100 assembler does not have an equivalent of the SVR4    \\\n+\t .size pseudo-op.  */\t\t\t\t\t\t\\\n+      if (TARGET_AS100_SYNTAX)\t\t\t\t\t\t\\\n+\tbreak;\t\t\t\t\t\t\t\t\\\n+      fputs (SIZE_ASM_OP, STREAM);\t\t\t\t\t\\\n+      assemble_name (STREAM, NAME);\t\t\t\t\t\\\n+      fputs (\", .-\", STREAM);\t\t\t\t\t\t\\\n+      assemble_name (STREAM, NAME);\t\t\t\t\t\\\n+      putc ('\\n', STREAM);\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  while (0)\n+\n+#define ASM_OUTPUT_TYPE_DIRECTIVE(STREAM, NAME, TYPE)\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      /* The as100 assembler does not have an equivalent of the SVR4    \\\n+\t .size pseudo-op.  */\t\t\t\t\t\t\\\n+      if (TARGET_AS100_SYNTAX)\t\t\t\t\t\t\\\n+\tbreak;\t\t\t\t\t\t\t\t\\\n+      fputs (TYPE_ASM_OP, STREAM);\t\t\t\t\t\\\n+      assemble_name (STREAM, NAME);\t\t\t\t\t\\\n+      fputs (\", \", STREAM);\t\t\t\t\t\t\\\n+      fprintf (STREAM, TYPE_OPERAND_FMT, TYPE);\t\t\t\t\\\n+      putc ('\\n', STREAM);\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  while (0)\n+\n+#undef  ASM_GENERATE_INTERNAL_LABEL\n+#define ASM_GENERATE_INTERNAL_LABEL(LABEL, PREFIX, NUM)\t\t\\\n+  do\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      sprintf (LABEL, TARGET_AS100_SYNTAX ? \"*%s%u\" : \"*.%s%u\", \\\n+\t       PREFIX, (unsigned) (NUM));\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  while (0)\n+\n+#undef  ASM_OUTPUT_EXTERNAL\n+#define ASM_OUTPUT_EXTERNAL(FILE, DECL, NAME)\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      if (TARGET_AS100_SYNTAX)\t\t\t\t\t\\\n+\ttargetm.asm_out.globalize_label (FILE, NAME);\t\t\\\n+      default_elf_asm_output_external (FILE, DECL, NAME);\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  while (0)\n+\n+#undef  ASM_OUTPUT_ALIGNED_COMMON\n+#define ASM_OUTPUT_ALIGNED_COMMON(FILE, NAME, SIZE, ALIGN)\t\t\\\n+  do\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      if (TARGET_AS100_SYNTAX)\t\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  fprintf ((FILE), \"\\t.GLB\\t\");\t\t\t\t\t\\\n+\t  assemble_name ((FILE), (NAME));\t\t\t\t\\\n+\t  fprintf ((FILE), \"\\n\");\t\t\t\t\t\\\n+          assemble_name ((FILE), (NAME));\t\t\t\t\\\n+\t  switch ((ALIGN) / BITS_PER_UNIT)\t\t\t\t\\\n+            {\t\t\t\t\t\t\t\t\\\n+            case 4:\t\t\t\t\t\t\t\\\n+              fprintf ((FILE), \":\\t.BLKL\\t\"HOST_WIDE_INT_PRINT_UNSIGNED\"\\n\",\\\n+\t\t       (SIZE) / 4);\t\t\t\t\t\\\n+\t      break;\t\t\t\t\t\t\t\\\n+            case 2:\t\t\t\t\t\t\t\\\n+              fprintf ((FILE), \":\\t.BLKW\\t\"HOST_WIDE_INT_PRINT_UNSIGNED\"\\n\",\\\n+\t\t       (SIZE) / 2);\t\t\t\t\t\\\n+\t      break;\t\t\t\t\t\t\t\\\n+            default:\t\t\t\t\t\t\t\\\n+              fprintf ((FILE), \":\\t.BLKB\\t\"HOST_WIDE_INT_PRINT_UNSIGNED\"\\n\",\\\n+\t\t       (SIZE));\t\t\t\t\t\t\\\n+\t      break;\t\t\t\t\t\t\t\\\n+            }\t\t\t\t\t\t\t\t\\\n+        }\t\t\t\t\t\t\t\t\\\n+      else\t\t\t\t\t\t\t\t\\\n+        {\t\t\t\t\t\t\t\t\\\n+          fprintf ((FILE), \"%s\", COMMON_ASM_OP);\t\t\t\\\n+          assemble_name ((FILE), (NAME));\t\t\t\t\\\n+          fprintf ((FILE), \",\"HOST_WIDE_INT_PRINT_UNSIGNED\",%u\\n\",\t\\\n+\t           (SIZE), (ALIGN) / BITS_PER_UNIT);\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  while (0)\n+\n+#undef  SKIP_ASM_OP\n+#define SKIP_ASM_OP   (TARGET_AS100_SYNTAX ? \"\\t.BLKB\\t\" : \"\\t.zero\\t\")\n+\n+#undef  ASM_OUTPUT_LIMITED_STRING\n+#define ASM_OUTPUT_LIMITED_STRING(FILE, STR)\t\t\\\n+  do\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      const unsigned char *_limited_str =\t\t\\\n+\t(const unsigned char *) (STR);\t\t\t\\\n+      unsigned ch;\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\\\n+      fprintf ((FILE), TARGET_AS100_SYNTAX \t\t\\\n+\t       ? \"\\t.BYTE\\t\\\"\" : \"\\t.string\\t\\\"\");\t\\\n+\t\t\t\t\t\t\t\\\n+      for (; (ch = *_limited_str); _limited_str++)\t\\\n+        {\t\t\t\t\t\t\\\n+\t  int escape;\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\\\n+\t  switch (escape = ESCAPES[ch])\t\t\t\\\n+\t    {\t\t\t\t\t\t\\\n+\t    case 0:\t\t\t\t\t\\\n+\t      putc (ch, (FILE));\t\t\t\\\n+\t      break;\t\t\t\t\t\\\n+\t    case 1:\t\t\t\t\t\\\n+\t      fprintf ((FILE), \"\\\\%03o\", ch);\t\t\\\n+\t      break;\t\t\t\t\t\\\n+\t    default:\t\t\t\t\t\\\n+\t      putc ('\\\\', (FILE));\t\t\t\\\n+\t      putc (escape, (FILE));\t\t\t\\\n+\t      break;\t\t\t\t\t\\\n+\t    }\t\t\t\t\t\t\\\n+        }\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\\\n+      fprintf ((FILE), TARGET_AS100_SYNTAX ? \"\\\"\\n\\t.BYTE\\t0\\n\" : \"\\\"\\n\");\\\n+    }\t\t\t\t\t\t\t\\\n+  while (0)\n+\n+#undef  IDENT_ASM_OP\n+#define IDENT_ASM_OP  (TARGET_AS100_SYNTAX \\\n+\t\t       ? \"\\t.END\\t; Built by: \": \"\\t.ident\\t\")\n+\n+/* For PIC put jump tables into the text section so that the offsets that\n+   they contain are always computed between two same-section symbols.  */\n+#define JUMP_TABLES_IN_TEXT_SECTION\t(flag_pic)\n+\f\n+#define PRINT_OPERAND(FILE, X, CODE)\t\t\\\n+  rx_print_operand (FILE, X, CODE)\n+#define PRINT_OPERAND_ADDRESS(FILE, ADDR)\t\\\n+  rx_print_operand_address (FILE, ADDR)\n+\f\n+\n+#define CC_NO_CARRY\t\t\t0400\n+#define NOTICE_UPDATE_CC(EXP, INSN)\trx_notice_update_cc (EXP, INSN)\n+\n+extern int rx_float_compare_mode;\n+\f\n+/* This is a version of REG_P that also returns TRUE for SUBREGs.  */\n+#define RX_REG_P(rtl) (REG_P (rtl) || GET_CODE (rtl) == SUBREG)\n+\n+/* Like REG_P except that this macro is true for SET expressions.  */\n+#define SET_P(rtl)    (GET_CODE (rtl) == SET)\n+\f\n+#define CAN_DEBUG_WITHOUT_FP 1\n+\n+/* The AS100 assembler does not support .leb128 and .uleb128, but\n+   the compiler-build-time configure tests will have enabled their\n+   use because GAS supports them.  So default to generating STABS\n+   debug information instead of DWARF2 when generating AS100\n+   compatible output.  */\n+#undef  PREFERRED_DEBUGGING_TYPE\n+#define PREFERRED_DEBUGGING_TYPE (TARGET_AS100_SYNTAX \\\n+\t\t\t\t  ? DBX_DEBUG : DWARF2_DEBUG)\n+\n+#undef  CC1_SPEC\n+#define CC1_SPEC \"%{mas100-syntax:%{gdwarf*:%e-mas100-syntax is incompatible with -gdwarf}}\"\n+\n+/* For some unknown reason LTO compression is not working, at\n+   least on my local system.  So set the default compression\n+   level to none, for now.  */\n+#define OVERRIDE_OPTIONS\t\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      if (flag_lto_compression_level == -1)\t\\\n+        flag_lto_compression_level = 0;\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+\n+/* This macro is used to decide when RX FPU instructions can be used.  */\n+#define ALLOW_RX_FPU_INSNS\tflag_unsafe_math_optimizations"}, {"sha": "165da4f41a13c9e2ab01f74a2c89b81c1772f718", "filename": "gcc/config/rx/rx.md", "status": "added", "additions": 1780, "deletions": 0, "changes": 1780, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65a324b459e60405cebe9e34ee6b3496559cd217/gcc%2Fconfig%2Frx%2Frx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65a324b459e60405cebe9e34ee6b3496559cd217/gcc%2Fconfig%2Frx%2Frx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frx%2Frx.md?ref=65a324b459e60405cebe9e34ee6b3496559cd217", "patch": "@@ -0,0 +1,1780 @@\n+;;  Machine Description for Renesas RX processors\n+;;  Copyright (C) 2008, 2009 Free Software Foundation, Inc.\n+;;  Contributed by Red Hat.\n+\n+;; This file is part of GCC.\n+\n+;; GCC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 3, or (at your option)\n+;; any later version.\n+\n+;; GCC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING3.  If not see\n+;; <http://www.gnu.org/licenses/>.\n+\f\n+\n+;; This code iterator allows all branch instructions to\n+;; be generated from a single define_expand template.\n+(define_code_iterator most_cond [eq ne gt ge lt le gtu geu ltu leu\n+\t\t\t\t unordered ordered ])\n+\n+;; This code iterator is used for sign- and zero- extensions.\n+(define_mode_iterator small_int_modes [(HI \"\") (QI \"\")])\n+\n+;; We do not handle DFmode here because by default it is\n+;; the same as SFmode, and if -m64bit-doubles is active\n+;; then all operations on doubles have to be handled by\n+;; library functions.\n+(define_mode_iterator register_modes\n+  [(SF \"ALLOW_RX_FPU_INSNS\") (SI \"\") (HI \"\") (QI \"\")])\n+\n+\n+;; Used to map RX condition names to GCC\n+;; condition names for builtin instructions.\n+(define_code_iterator gcc_conds [eq ne gt ge lt le gtu geu ltu leu\n+\t\t\t\tunge unlt uneq ltgt])\n+(define_code_attr rx_conds [(eq \"eq\") (ne \"ne\") (gt \"gt\") (ge \"ge\") (lt \"lt\")\n+\t\t\t    (le \"le\") (gtu \"gtu\") (geu \"geu\") (ltu \"ltu\")\n+\t\t\t    (leu \"leu\") (unge \"pz\") (unlt \"n\") (uneq \"o\")\n+\t\t\t    (ltgt \"no\")])\n+\n+(define_constants\n+  [\n+   (SP_REG 0)\n+\n+   (UNSPEC_LOW_REG         0)\n+   (UNSPEC_HIGH_REG        1)\n+\n+   (UNSPEC_RTE             10)\n+   (UNSPEC_RTFI            11)\n+   (UNSPEC_NAKED           12)\n+   \n+   (UNSPEC_MOVSTR          20)\n+   (UNSPEC_MOVMEM          21)\n+   (UNSPEC_SETMEM          22)\n+   (UNSPEC_STRLEN          23)\n+   (UNSPEC_CMPSTRN         24)\n+\n+   (UNSPEC_BUILTIN_BRK     30)\n+   (UNSPEC_BUILTIN_CLRPSW  31)\n+   (UNSPEC_BUILTIN_INT     32)\n+   (UNSPEC_BUILTIN_MACHI   33)\n+   (UNSPEC_BUILTIN_MACLO   34)\n+   (UNSPEC_BUILTIN_MULHI   35)\n+   (UNSPEC_BUILTIN_MULLO   36)\n+   (UNSPEC_BUILTIN_MVFACHI 37)\n+   (UNSPEC_BUILTIN_MVFACMI 38)\n+   (UNSPEC_BUILTIN_MVFC    39)\n+   (UNSPEC_BUILTIN_MVFCP   40)\n+   (UNSPEC_BUILTIN_MVTACHI 41)\n+   (UNSPEC_BUILTIN_MVTACLO 42)\n+   (UNSPEC_BUILTIN_MVTC    43)\n+   (UNSPEC_BUILTIN_MVTCP   44)\n+   (UNSPEC_BUILTIN_OPEPC   45)\n+   (UNSPEC_BUILTIN_RACW\t   46)\n+   (UNSPEC_BUILTIN_REVW    47)\n+   (UNSPEC_BUILTIN_RMPA\t   48)\n+   (UNSPEC_BUILTIN_ROUND   49)\n+   (UNSPEC_BUILTIN_SAT     50)\n+   (UNSPEC_BUILTIN_SETPSW  51)\n+   (UNSPEC_BUILTIN_WAIT\t   52)\n+  ]\n+)\n+\n+;; Condition code settings:\n+;;   none     - insn does not affect the condition code bits\n+;;   set_zs   - insn sets z,s to usable values;\n+;;   set_zso  - insn sets z,s,o to usable values;\n+;;   set_zsoc - insn sets z,s,o,c to usable values;\n+;;   clobber  - value of cc0 is unknown\n+(define_attr \"cc\" \"none,set_zs,set_zso,set_zsoc,clobber\" (const_string \"none\"))\n+\n+(define_attr \"length\" \"\" (const_int 8))\n+\n+(include \"predicates.md\")\n+(include \"constraints.md\")\n+\n+;; Pipeline description.\n+\n+;; The RX only has a single pipeline.  It has five stages (fetch,\n+;; decode, execute, memory access, writeback) each of which normally\n+;; takes a single CPU clock cycle.\n+\n+;; The timings attribute consists of two numbers, the first is the\n+;; throughput, which is the number of cycles the instruction takes\n+;; to execute and generate a result.  The second is the latency\n+;; which is the effective number of cycles the instruction takes to\n+;; execute if its result is used by the following instruction.  The\n+;; latency is always greater than or equal to the throughput.\n+;; These values were taken from tables 2.13 and 2.14 in section 2.8\n+;; of the RX610 Group Hardware Manual v0.11\n+\n+;; Note - it would be nice to use strings rather than integers for\n+;; the possible values of this attribute, so that we can have the\n+;; gcc build mechanism check for values that are not supported by\n+;; the reservations below.  But this will not work because the code\n+;; in rx_adjust_sched_cost() needs integers not strings.\n+\n+(define_attr \"timings\" \"\" (const_int 11))\n+\n+(define_automaton \"pipelining\")\n+(define_cpu_unit \"throughput\" \"pipelining\")\n+\n+(define_insn_reservation \"throughput__1_latency__1\"  1\n+  (eq_attr \"timings\" \"11\") \"throughput\")\n+(define_insn_reservation \"throughput__1_latency__2\"  2\n+  (eq_attr \"timings\" \"12\") \"throughput,nothing\")\n+(define_insn_reservation \"throughput__2_latency__2\"  1\n+  (eq_attr \"timings\" \"22\") \"throughput*2\")\n+(define_insn_reservation \"throughput__3_latency__3\"  1\n+  (eq_attr \"timings\" \"33\") \"throughput*3\")\n+(define_insn_reservation \"throughput__3_latency__4\"  2\n+  (eq_attr \"timings\" \"34\") \"throughput*3,nothing\")\n+(define_insn_reservation \"throughput__4_latency__4\"  1\n+  (eq_attr \"timings\" \"44\") \"throughput*4\")\n+(define_insn_reservation \"throughput__4_latency__5\"  2\n+  (eq_attr \"timings\" \"45\") \"throughput*4,nothing\")\n+(define_insn_reservation \"throughput__5_latency__5\"  1\n+  (eq_attr \"timings\" \"55\") \"throughput*5\")\n+(define_insn_reservation \"throughput__5_latency__6\"  2\n+  (eq_attr \"timings\" \"56\") \"throughput*5,nothing\")\n+(define_insn_reservation \"throughput__6_latency__6\"  1\n+  (eq_attr \"timings\" \"66\") \"throughput*6\")\n+(define_insn_reservation \"throughput_10_latency_10\"  1\n+  (eq_attr \"timings\" \"1010\") \"throughput*10\")\n+(define_insn_reservation \"throughput_11_latency_11\"  1\n+  (eq_attr \"timings\" \"1111\") \"throughput*11\")\n+(define_insn_reservation \"throughput_16_latency_16\"  1\n+  (eq_attr \"timings\" \"1616\") \"throughput*16\")\n+(define_insn_reservation \"throughput_18_latency_18\"  1\n+  (eq_attr \"timings\" \"1818\") \"throughput*18\")\n+\n+;; Comparisons\n+\n+(define_expand \"cbranchsi4\"\n+  [(set (cc0) (compare:CC (match_operand:SI 1 \"register_operand\")\n+\t\t\t  (match_operand:SI 2 \"rx_source_operand\")))\n+   (set (pc)\n+\t(if_then_else (match_operator:SI  0 \"comparison_operator\"\n+\t\t\t\t\t  [(cc0) (const_int 0)])\n+\t\t      (label_ref (match_operand 3 \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\"\n+)\n+\n+(define_expand \"cbranchsf4\"\n+  [(set (cc0) (compare:CC (match_operand:SF 1 \"register_operand\")\n+\t\t\t  (match_operand:SF 2 \"rx_source_operand\")))\n+   (set (pc)\n+\t(if_then_else (match_operator:SI  0 \"comparison_operator\"\n+\t\t\t\t\t  [(cc0) (const_int 0)])\n+\t\t      (label_ref (match_operand 3 \"\"))\n+\t\t      (pc)))]\n+  \"ALLOW_RX_FPU_INSNS && ! flag_non_call_exceptions\"\n+  \"\"\n+)\n+\n+;; The TST instruction is not used as it does not set the Carry flag,\n+;; so for example, the LessThan comparison cannot be tested.\n+;;\n+;; (define_insn \"tstsi\"\n+;;   [(set (cc0)\n+;;         (match_operand:SI 0 \"rx_source_operand\"  \"r,i,Q\")))]\n+;;   \"\"\n+;;   {\n+;;     rx_float_compare_mode = false;\n+;;     return \"tst\\t%Q0\";\n+;;   }\n+;;   [(set_attr \"cc\" \"set_zs\")\n+;;    (set_attr \"timings\" \"11,11,33\")\n+;;    (set_attr \"length\" \"3,7,6\")]\n+;; )\n+\n+(define_insn \"cmpsi\"\n+  [(set (cc0) (compare:CC\n+\t       (match_operand:SI 0 \"register_operand\"  \"r,r,r,r,r,r,r\")\n+\t       (match_operand:SI 1 \"rx_source_operand\"\n+\t\t\t\t \"r,Uint04,Int08,Sint16,Sint24,i,Q\")))]\n+  \"\"\n+  {\n+    rx_float_compare_mode = false;\n+    return \"cmp\\t%Q1, %Q0\";\n+  }\n+  [(set_attr \"cc\" \"set_zsoc\")\n+   (set_attr \"timings\" \"11,11,11,11,11,11,33\")\n+   (set_attr \"length\"  \"2,2,3,4,5,6,5\")]\n+)\n+\n+;; This pattern is disabled when -fnon-call-exceptions is active because\n+;; it could generate a floating point exception, which would introduce an\n+;; edge into the flow graph between this insn and the conditional branch\n+;; insn to follow, thus breaking the cc0 relationship.  Run the g++ test\n+;; g++.dg/eh/080514-1.C to see this happen.\n+(define_insn \"cmpsf\"\n+  [(set (cc0)\n+\t(compare:CC (match_operand:SF 0 \"register_operand\"  \"r,r,r\")\n+\t\t    (match_operand:SF 1 \"rx_source_operand\" \"r,i,Q\")))]\n+  \"ALLOW_RX_FPU_INSNS && ! flag_non_call_exceptions\"\n+  {\n+    rx_float_compare_mode = true;\n+    return \"fcmp\\t%1, %0\";\n+  }\n+  [(set_attr \"cc\" \"set_zso\")\n+   (set_attr \"timings\" \"11,11,33\")\n+   (set_attr \"length\" \"3,7,5\")]\n+)\n+\n+;; Flow Control Instructions:\n+\n+(define_expand \"b<code>\"\n+  [(set (pc)\n+        (if_then_else (most_cond (cc0) (const_int 0))\n+                      (label_ref (match_operand 0))\n+                      (pc)))]\n+  \"\"\n+  \"\"\n+)\n+\n+(define_insn \"*conditional_branch\"\n+  [(set (pc)\n+\t(if_then_else (match_operator           1 \"comparison_operator\"\n+\t\t\t\t\t\t[(cc0) (const_int 0)])\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  {\n+    return rx_gen_cond_branch_template (operands[1], false);\n+  }\n+  [(set_attr \"length\" \"8\")    ;; This length is wrong, but it is\n+                              ;; too hard to compute statically.\n+   (set_attr \"timings\" \"33\")  ;; The timing assumes that the branch is taken.\n+   (set_attr \"cc\" \"clobber\")] ;; FIXME: This clobber is wrong.\n+)\n+\n+(define_insn \"*reveresed_conditional_branch\"\n+  [(set (pc)\n+\t(if_then_else (match_operator 1 \"comparison_operator\"\n+\t\t\t\t      [(cc0) (const_int 0)])\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"\"\n+  {\n+    return rx_gen_cond_branch_template (operands[1], true);\n+  }\n+  [(set_attr \"length\" \"8\")    ;; This length is wrong, but it is\n+                              ;; too hard to compute statically.\n+   (set_attr \"timings\" \"33\")  ;; The timing assumes that the branch is taken.\n+   (set_attr \"cc\" \"clobber\")] ;; FIXME: This clobber is wrong.\n+)\n+\n+(define_insn \"jump\"\n+  [(set (pc) (label_ref (match_operand 0 \"\" \"\")))]\n+  \"\"\n+  \"bra\\t%0\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"timings\" \"33\")\n+   (set_attr \"cc\" \"clobber\")] ;; FIXME: This clobber is wrong.\n+)\n+\n+(define_insn \"indirect_jump\"\n+  [(set (pc) (match_operand:SI 0 \"register_operand\" \"r\"))]\n+  \"\"\n+  \"jmp\\t%0\"\n+  [(set_attr \"length\" \"2\")\n+   (set_attr \"timings\" \"33\")\n+   (set_attr \"cc\" \"clobber\")] ;; FIXME: This clobber is wrong.\n+)\n+\n+(define_insn \"tablejump\"\n+  [(set (pc) (match_operand:SI     0 \"register_operand\" \"r\"))\n+   (use (label_ref (match_operand  1 \"\" \"\")))]\n+  \"\"\n+  { return flag_pic ? (TARGET_AS100_SYNTAX ? \"\\n?:\\tbra\\t%0\"\n+\t\t\t\t\t   : \"\\n1:\\tbra\\t%0\")\n+\t                                   : \"jmp\\t%0\";\n+  }\n+  [(set_attr \"cc\" \"clobber\") ;; FIXME: This clobber is wrong.\n+   (set_attr \"timings\" \"33\")\n+   (set_attr \"length\" \"2\")]\n+)\n+\n+(define_insn \"simple_return\"\n+  [(return)]\n+  \"\"\n+  \"rts\"\n+  [(set_attr \"length\" \"1\")\n+   (set_attr \"timings\" \"55\")]\n+)\n+\n+(define_insn \"deallocate_and_return\"\n+  [(set (reg:SI SP_REG)\n+\t(plus:SI (reg:SI SP_REG)\n+\t\t (match_operand:SI 0 \"immediate_operand\" \"i\")))\n+   (return)]\n+  \"\"\n+  \"rtsd\\t%0\"\n+  [(set_attr \"length\" \"2\")\n+   (set_attr \"timings\" \"55\")]\n+)\n+\n+(define_insn \"pop_and_return\"\n+  [(match_parallel                    1 \"rx_rtsd_vector\"\n+\t\t   [(set:SI (reg:SI SP_REG)\n+\t\t\t    (plus:SI (reg:SI SP_REG)\n+\t\t\t\t     (match_operand:SI\n+\t\t\t\t      0 \"const_int_operand\" \"n\")))])]\n+  \"reload_completed\"\n+  {\n+    rx_emit_stack_popm (operands, false);\n+    return \"\";\n+  }\n+  [(set_attr \"length\" \"3\")\n+   (set_attr \"timings\" \"56\")]\n+)\n+\n+(define_insn \"fast_interrupt_return\"\n+  [(unspec_volatile [(return)] UNSPEC_RTFI) ]\n+  \"\"\n+  \"rtfi\"\n+  [(set_attr \"length\" \"2\")\n+   (set_attr \"timings\" \"33\")]\n+)\n+\n+(define_insn \"exception_return\"\n+  [(unspec_volatile [(return)] UNSPEC_RTE) ]\n+  \"\"\n+  \"rte\"\n+  [(set_attr \"length\" \"2\")\n+   (set_attr \"timings\" \"66\")]\n+)\n+\n+(define_insn \"naked_return\"\n+  [(unspec_volatile [(return)] UNSPEC_NAKED) ]\n+  \"\"\n+  \"; Naked function: epilogue provided by programmer.\"\n+)\n+\n+\n+;; Note - the following set of patterns do not use the \"memory_operand\"\n+;; predicate or an \"m\" constraint because we do not allow symbol_refs\n+;; or label_refs as legitmate memory addresses.  This matches the\n+;; behaviour of most of the RX instructions.  Only the call/branch\n+;; instructions are allowed to refer to symbols/labels directly.\n+;; The call operands are in QImode because that is the value of\n+;; FUNCTION_MODE\n+\n+(define_expand \"call\"\n+  [(call (match_operand:QI 0 \"general_operand\")\n+\t (match_operand:SI 1 \"general_operand\"))]\n+  \"\"\n+  {\n+    rtx dest = XEXP (operands[0], 0);\n+\n+    if (! rx_call_operand (dest, Pmode))\n+      dest = force_reg (Pmode, dest);\n+    emit_call_insn (gen_call_internal (dest, operands[1]));\n+    DONE;\n+  }\n+)\n+\n+(define_insn \"call_internal\"\n+  [(call (mem:QI (match_operand:SI 0 \"rx_call_operand\" \"r,Symbol\"))\n+\t (match_operand:SI         1 \"general_operand\" \"g,g\"))]\n+  \"\"\n+  \"@\n+  jsr\\t%A0\n+  bsr\\t%A0\"\n+  [(set_attr \"length\" \"2,4\")\n+   (set_attr \"timings\" \"33\")]\n+)\n+\n+(define_expand \"call_value\"\n+  [(set (match_operand          0 \"register_operand\")\n+\t(call (match_operand:QI 1 \"general_operand\")\n+\t      (match_operand:SI 2 \"general_operand\")))]\n+  \"\"\n+  {\n+    rtx dest = XEXP (operands[1], 0);\n+\n+    if (! rx_call_operand (dest, Pmode))\n+      dest = force_reg (Pmode, dest);\n+    emit_call_insn (gen_call_value_internal (operands[0], dest, operands[2]));\n+    DONE;\n+  }\n+)\n+\n+(define_insn \"call_value_internal\"\n+  [(set (match_operand                  0 \"register_operand\" \"=r,r\")\n+\t(call (mem:QI (match_operand:SI 1 \"rx_call_operand\"   \"r,Symbol\"))\n+\t      (match_operand:SI         2 \"general_operand\"   \"g,g\")))]\n+  \"\"\n+  \"@\n+  jsr\\t%A1\n+  bsr\\t%A1\"\n+  [(set_attr \"length\" \"2,4\")\n+   (set_attr \"timings\" \"33\")]\n+)\n+\n+(define_insn \"sibcall\"\n+ [(call (mem:QI (match_operand:SI 0 \"rx_symbolic_call_operand\" \"Symbol\"))\n+\t(match_operand:SI         1 \"general_operand\"          \"g\"))\n+  (return)\n+  (use (match_operand             2 \"\" \"\"))]\n+  \"\"\n+  \"bra\\t%A0\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"timings\" \"33\")]\n+)\n+\n+(define_insn \"sibcall_value\"\n+ [(set (match_operand                  0 \"register_operand\"         \"=r\")\n+       (call (mem:QI (match_operand:SI 1 \"rx_symbolic_call_operand\" \"Symbol\"))\n+\t     (match_operand:SI         2 \"general_operand\"          \"g\")))\n+  (return)\n+  (use (match_operand                  3 \"\" \"\"))]\n+  \"\"\n+  \"bra\\t%A1\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"timings\" \"33\")]\n+)\n+\n+;; Function Prologue/Epilogue Instructions\n+\n+(define_expand \"prologue\"\n+  [(const_int 0)]\n+  \"\"\n+  \"rx_expand_prologue (); DONE;\"\n+)\n+\n+(define_expand \"epilogue\"\n+  [(return)]\n+  \"\"\n+  \"rx_expand_epilogue (false); DONE;\"\n+)\n+\n+(define_expand \"sibcall_epilogue\"\n+  [(return)]\n+  \"\"\n+  \"rx_expand_epilogue (true); DONE;\"\n+)\n+\n+;; Move Instructions\n+\n+;; Note - we do not allow memory to memory moves, even though the ISA\n+;; supports them.  The reason is that the conditions on such moves are\n+;; too restrictive, specifically the source addressing mode is limited\n+;; by the destination addressing mode and vice versa.  (For example it\n+;; is not possible to use indexed register indirect addressing for one\n+;; of the operands if the other operand is anything other than a register,\n+;; but it is possible to use register relative addressing when the other\n+;; operand also uses register relative or register indirect addressing).\n+;;\n+;; GCC does not support computing legitimate addresses based on the\n+;; nature of other operands involved in the instruction, and reload is\n+;; not smart enough to cope with a whole variety of different memory\n+;; addressing constraints, so it is simpler and safer to just refuse\n+;; to support memory to memory moves.\n+\n+(define_expand \"mov<register_modes:mode>\"\n+  [(set (match_operand:register_modes 0 \"general_operand\")\n+\t(match_operand:register_modes 1 \"general_operand\"))]\n+  \"\"\n+  {\n+    if (MEM_P (operand0) && MEM_P (operand1))\n+      operands[1] = copy_to_mode_reg (<register_modes:MODE>mode, operand1);\n+  }\n+)\n+\n+(define_insn \"*mov<register_modes:mode>_internal\"\n+  [(set (match_operand:register_modes\n+\t 0 \"nonimmediate_operand\" \"=r,r,r,r,r,r,m,Q,Q,Q,Q\")\n+\t(match_operand:register_modes\n+\t 1 \"general_operand\" \"Int08,Sint16,Sint24,i,r,m,r,Int08,Sint16,Sint24,i\"))]\n+  \"\"\n+  { return rx_gen_move_template (operands, false); }\n+  [(set_attr \"length\" \"3,4,5,6,2,4,6,5,6,7,8\")\n+   (set_attr \"timings\" \"11,11,11,11,11,12,11,11,11,11,11\")]\n+)\n+\n+(define_insn \"extend<small_int_modes:mode>si2\"\n+  [(set (match_operand:SI 0 \"register_operand\"    \"=r,r\")\n+        (sign_extend:SI (match_operand:small_int_modes\n+\t\t\t  1 \"nonimmediate_operand\" \"r,m\")))]\n+  \"\"\n+  { return rx_gen_move_template (operands, false); }\n+  [(set_attr \"length\" \"2,6\")\n+   (set_attr \"timings\" \"11,12\")]\n+)\n+\n+(define_insn \"zero_extend<small_int_modes:mode>si2\"\n+  [(set (match_operand:SI 0 \"register_operand\"     \"=r,r\")\n+        (zero_extend:SI (match_operand:small_int_modes\n+\t\t\t  1 \"nonimmediate_operand\"  \"r,m\")))]\n+  \"\"\n+  { return rx_gen_move_template (operands, true); }\n+  [(set_attr \"length\" \"2,4\")\n+   (set_attr \"timings\" \"11,12\")]\n+)\n+\n+(define_insn \"stack_push\"\n+  [(set:SI (reg:SI SP_REG)\n+\t   (minus:SI (reg:SI SP_REG)\n+\t\t     (const_int 4)))\n+   (set:SI (mem:SI (reg:SI SP_REG))\n+\t   (match_operand:SI 0 \"register_operand\" \"r\"))]\n+  \"\"\n+  \"push.l\\t%0\"\n+  [(set_attr \"length\" \"2\")]\n+)\n+\n+(define_insn \"stack_pushm\"\n+  [(match_parallel                     1 \"rx_store_multiple_vector\"\n+\t\t   [(set:SI (reg:SI SP_REG)\n+\t\t\t    (minus:SI (reg:SI SP_REG)\n+\t\t\t\t      (match_operand:SI\n+\t\t\t\t       0 \"const_int_operand\" \"n\")))])]\n+  \"reload_completed\"\n+  {\n+    rx_emit_stack_pushm (operands);\n+    return \"\";\n+  }\n+  [(set_attr \"length\" \"2\")\n+   (set_attr \"timings\" \"44\")] ;; The timing is a guesstimate average timing.\n+)\n+\n+(define_insn \"stack_pop\"\n+  [(set:SI (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t   (mem:SI (reg:SI SP_REG)))\n+   (set:SI (reg:SI SP_REG)\n+\t   (plus:SI (reg:SI SP_REG)\n+\t\t    (const_int 4)))]\n+  \"\"\n+  \"pop\\t%0\"\n+  [(set_attr \"length\" \"2\")\n+   (set_attr \"timings\" \"12\")]\n+)\n+\n+(define_insn \"stack_popm\"\n+  [(match_parallel                     1 \"rx_load_multiple_vector\"\n+\t\t   [(set:SI (reg:SI SP_REG)\n+\t\t\t    (plus:SI (reg:SI SP_REG)\n+\t\t\t\t     (match_operand:SI\n+\t\t\t\t      0 \"const_int_operand\" \"n\")))])]\n+  \"reload_completed\"\n+  {\n+    rx_emit_stack_popm (operands, true);\n+    return \"\";\n+  }\n+  [(set_attr \"length\" \"2\")\n+   (set_attr \"timings\" \"45\")] ;; The timing is a guesstimate average timing.\n+)\n+\n+(define_insn \"cstoresi4\"\n+  [(set (match_operand:SI  0 \"register_operand\" \"=r,r,r,r,r,r,r\")\n+\t(match_operator:SI\n+\t 1 \"comparison_operator\"\n+\t [(match_operand:SI\n+\t   2 \"register_operand\"  \"r,r,r,r,r,r,r\")\n+\t  (match_operand:SI\n+\t   3 \"rx_source_operand\" \"r,Uint04,Int08,Sint16,Sint24,i,Q\")]))]\n+  \"\"\n+  {\n+    rx_float_compare_mode = false;\n+    return \"cmp\\t%Q3, %Q2\\n\\tsc%B1.L\\t%0\";\n+  }\n+  [(set_attr \"cc\" \"set_zsoc\")\n+   (set_attr \"timings\" \"22,22,22,22,22,22,44\")\n+   (set_attr \"length\"  \"5,5,6,7,8,9,8\")]\n+)\n+\n+(define_expand \"movsicc\"\n+  [(set (match_operand:SI                   0 \"register_operand\")\n+        (if_then_else:SI (match_operand:SI 1 \"comparison_operator\")\n+\t\t\t (match_operand:SI  2 \"nonmemory_operand\")\n+\t\t\t (match_operand:SI  3 \"immediate_operand\")))]\n+  \"\"\n+  {\n+    if (GET_CODE (operands[1]) != EQ && GET_CODE (operands[1]) != NE)\n+      FAIL;\n+    if (! CONST_INT_P (operands[3]))\n+      FAIL;\n+  }\n+)\n+\n+(define_insn \"*movsieq\"\n+  [(set (match_operand:SI     0 \"register_operand\" \"=r,r,r\")\n+\t(if_then_else:SI (eq (match_operand:SI\n+\t\t\t      3 \"register_operand\"  \"r,r,r\")\n+\t\t\t     (match_operand:SI\n+\t\t\t      4 \"rx_source_operand\" \"riQ,riQ,riQ\"))\n+\t\t\t (match_operand:SI\n+\t\t\t  1 \"nonmemory_operand\"     \"0,i,r\")\n+\t\t\t (match_operand:SI\n+\t\t\t  2 \"immediate_operand\"     \"i,i,i\")))]\n+  \"\"\n+  \"@\n+  cmp\\t%Q4, %Q3\\n\\tstnz\\t%2, %0\n+  cmp\\t%Q4, %Q3\\n\\tmov.l\\t%2, %0\\n\\tstz\\t%1, %0\n+  cmp\\t%Q4, %Q3\\n\\tmov.l\\t%1, %0\\n\\tstnz\\t%2, %0\"\n+  [(set_attr \"cc\"      \"set_zsoc\")\n+   (set_attr \"length\"  \"13,19,15\")\n+   (set_attr \"timings\" \"22,33,33\")]\n+)\n+\n+(define_insn \"*movsine\"\n+  [(set (match_operand:SI                      0 \"register_operand\" \"=r,r,r\")\n+\t(if_then_else:SI (ne (match_operand:SI 3 \"register_operand\"  \"r,r,r\")\n+\t\t\t     (match_operand:SI 4 \"rx_source_operand\" \"riQ,riQ,riQ\"))\n+\t\t\t (match_operand:SI     1 \"nonmemory_operand\" \"0,i,r\")\n+\t\t\t (match_operand:SI     2 \"immediate_operand\" \"i,i,i\")))]\n+  \"\"\n+  \"@\n+  cmp\\t%Q4, %Q3\\n\\tstz\\t%2, %0\n+  cmp\\t%Q4, %Q3\\n\\tmov.l\\t%2, %0\\n\\tstnz\\t%1, %0\n+  cmp\\t%Q4, %Q3\\n\\tmov.l\\t%1, %0\\n\\tstz\\t%2, %0\"\n+  [(set_attr \"cc\"      \"set_zsoc\")\n+   (set_attr \"length\"  \"13,19,15\")\n+   (set_attr \"timings\" \"22,33,33\")]\n+)\n+\n+;; Arithmetic Instructions\n+\n+(define_insn \"abssi2\"\n+  [(set (match_operand:SI         0 \"register_operand\" \"=r,r\")\n+        (abs:SI (match_operand:SI 1 \"register_operand\"  \"0,r\")))]\n+  \"\"\n+  \"@\n+  abs\\t%0\n+  abs\\t%1, %0\"\n+  [(set_attr \"cc\" \"set_zso\")\n+   (set_attr \"length\" \"2,3\")]\n+)\n+\n+(define_insn \"addsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\"\n+\t\t\t  \"=r,r,r,r,r,r,r,r,r,r,r,r\")\n+\t(plus:SI (match_operand:SI\n+\t\t  1 \"register_operand\"\n+\t\t  \"%0,0,0,0,0,0,r,r,r,r,r,0\")\n+\t\t (match_operand:SI\n+\t\t  2 \"rx_source_operand\"\n+\t\t  \"r,Uint04,Sint08,Sint16,Sint24,i,r,Sint08,Sint16,Sint24,i,Q\")))]\n+  \"\"\n+  \"@\n+  add\\t%2, %0\n+  add\\t%2, %0\n+  add\\t%2, %0\n+  add\\t%2, %0\n+  add\\t%2, %0\n+  add\\t%2, %0\n+  add\\t%2, %1, %0\n+  add\\t%2, %1, %0\n+  add\\t%2, %1, %0\n+  add\\t%2, %1, %0\n+  add\\t%2, %1, %0\n+  add\\t%Q2, %0\"\n+  [(set_attr \"cc\" \"set_zsoc\")\n+   (set_attr \"timings\" \"11,11,11,11,11,11,11,11,11,11,11,33\")\n+   (set_attr \"length\" \"2,2,3,4,5,6,3,3,4,5,6,5\")]\n+)\n+\n+(define_insn \"adddi3\"\n+  [(set (match_operand:DI          0 \"register_operand\" \"=r,r,r,r,r,r\")\n+\t(plus:DI (match_operand:DI 1 \"register_operand\" \"%0,0,0,0,0,0\")\n+\t\t (match_operand:DI 2 \"rx_source_operand\"\n+\t\t\t\t   \"r,Sint08,Sint16,Sint24,i,Q\")))]\n+  \"\"\n+  \"add\\t%L2, %L0\\n\\tadc\\t%H2, %H0\"\n+  [(set_attr \"cc\" \"set_zsoc\")\n+   (set_attr \"timings\" \"22,22,22,22,22,44\")\n+   (set_attr \"length\" \"5,7,9,11,13,11\")]\n+)\n+\n+(define_insn \"andsi3\"\n+  [(set (match_operand:SI         0 \"register_operand\"  \"=r,r,r,r,r,r,r,r,r\")\n+\t(and:SI (match_operand:SI 1 \"register_operand\"  \"%0,0,0,0,0,0,r,0,Q\")\n+\t\t(match_operand:SI\n+\t\t 2 \"rx_source_operand\"\n+\t\t \"r,Uint04,Sint08,Sint16,Sint24,i,r,Q,0\")))]\n+  \"\"\n+  \"@\n+  and\\t%2, %0\n+  and\\t%2, %0\n+  and\\t%2, %0\n+  and\\t%2, %0\n+  and\\t%2, %0\n+  and\\t%2, %0\n+  and\\t%2, %1, %0\n+  and\\t%Q2, %0\n+  and\\t%Q1, %0\"\n+  [(set_attr \"cc\" \"set_zs\")\n+   (set_attr \"timings\" \"11,11,11,11,11,11,11,33,33\")\n+   (set_attr \"length\" \"2,2,3,4,5,6,3,5,5\")]\n+)\n+\n+;; Byte swap (single 32-bit value).\n+(define_insn \"bswapsi2\"\n+  [(set (match_operand:SI           0 \"register_operand\" \"+r\")\n+\t(bswap:SI (match_operand:SI 1 \"register_operand\"  \"r\")))]\n+  \"\"\n+  \"revl\\t%1, %0\"\n+  [(set_attr \"length\" \"3\")]\n+)\n+\n+;; Byte swap (single 16-bit value).  Note - we ignore the swapping of the high 16-bits.\n+(define_insn \"bswaphi2\"\n+  [(set (match_operand:HI           0 \"register_operand\" \"+r\")\n+\t(bswap:HI (match_operand:HI 1 \"register_operand\"  \"r\")))]\n+  \"\"\n+  \"revw\\t%1, %0\"\n+  [(set_attr \"length\" \"3\")]\n+)\n+\n+(define_insn \"divsi3\"\n+  [(set (match_operand:SI         0 \"register_operand\" \"=r,r,r,r,r,r\")\n+\t(div:SI (match_operand:SI 1 \"register_operand\"  \"0,0,0,0,0,0\")\n+\t\t(match_operand:SI\n+\t\t 2 \"rx_source_operand\" \"r,Sint08,Sint16,Sint24,i,Q\")))]\n+  \"\"\n+  \"div\\t%Q2, %0\"\n+  [(set_attr \"cc\" \"clobber\")\n+   (set_attr \"timings\" \"1111\") ;; Strictly speaking the timing should be\n+                               ;; 2222, but that is a worst case sceanario.\n+   (set_attr \"length\" \"3,4,5,6,7,6\")]\n+)\n+\n+(define_insn \"udivsi3\"\n+  [(set (match_operand:SI          0 \"register_operand\"  \"=r,r,r,r,r,r\")\n+\t(udiv:SI (match_operand:SI 1 \"register_operand\"   \"0,0,0,0,0,0\")\n+\t\t (match_operand:SI\n+\t\t  2 \"rx_source_operand\"  \"r,Sint08,Sint16,Sint24,i,Q\")))]\n+  \"\"\n+  \"divu\\t%Q2, %0\"\n+  [(set_attr \"cc\" \"clobber\")\n+   (set_attr \"timings\" \"1010\") ;; Strictly speaking the timing should be\n+                               ;; 2020, but that is a worst case sceanario.\n+   (set_attr \"length\" \"3,4,5,6,7,6\")]\n+)\n+\n+;; Note - these patterns are suppressed in big-endian mode because they\n+;; generate a little endian result.  ie the most significant word of the\n+;; result is placed in the higher numbered register of the destination\n+;; register pair.\n+\n+(define_insn \"mulsidi3\"\n+  [(set (match_operand:DI          0 \"register_operand\"  \"=r,r,r,r,r,r\")\n+        (mult:DI (sign_extend:DI (match_operand:SI\n+\t\t\t\t  1 \"register_operand\"  \"%0,0,0,0,0,0\"))\n+                 (sign_extend:DI (match_operand:SI\n+\t\t\t\t  2 \"rx_source_operand\"\n+\t\t\t\t  \"r,Sint08,Sint16,Sint24,i,Q\"))))]\n+  \"! TARGET_BIG_ENDIAN_DATA\"\n+  \"@\n+  emul\\t%Q2, %0\n+  emul\\t%Q2, %0\n+  emul\\t%Q2, %0\n+  emul\\t%Q2, %0\n+  emul\\t%Q2, %0\n+  emul\\t%Q2, %0\"\n+  [(set_attr \"length\" \"3,4,5,6,7,6\")   \n+   (set_attr \"timings\" \"22,22,22,22,22,44\")]\n+)\n+\n+;; See comment for mulsidi3.\n+;; Note - the zero_extends are to distinguish this pattern from the\n+;; mulsidi3 pattern.  Immediate mode addressing is not supported\n+;; because gcc cannot handle the expression: (zero_extend (const_int)).\n+(define_insn \"umulsidi3\"\n+  [(set (match_operand:DI                          0 \"register_operand\"\n+\t\t\t\t\t\t   \"=r,r\")\n+        (mult:DI (zero_extend:DI (match_operand:SI 1 \"register_operand\"\n+\t\t\t\t\t\t   \"%0,0\"))\n+                 (zero_extend:DI (match_operand:SI 2 \"rx_compare_operand\"\n+\t\t\t\t\t\t   \"r,Q\"))))]\n+  \"! TARGET_BIG_ENDIAN_DATA\"\n+  \"@\n+  emulu\\t%Q2, %0\n+  emulu\\t%Q2, %0\"\n+  [(set_attr \"length\" \"3,6\")\n+   (set_attr \"timings\" \"22,44\")]\n+)\n+\n+(define_insn \"smaxsi3\"\n+  [(set (match_operand:SI          0 \"register_operand\" \"=r,r,r,r,r,r\")\n+\t(smax:SI (match_operand:SI 1 \"register_operand\" \"%0,0,0,0,0,0\")\n+\t\t (match_operand:SI 2 \"rx_source_operand\"\n+\t\t\t\t   \"r,Sint08,Sint16,Sint24,i,Q\")))]\n+  \"\"\n+  \"max\\t%Q2, %0\"\n+  [(set_attr \"length\" \"3,4,5,6,7,6\")\n+   (set_attr \"timings\" \"11,11,11,11,11,33\")]\n+)\n+\n+(define_insn \"sminsi3\"\n+  [(set (match_operand:SI          0 \"register_operand\" \"=r,r,r,r,r,r,r\")\n+\t(smin:SI (match_operand:SI 1 \"register_operand\" \"%0,0,0,0,0,0,r\")\n+\t\t (match_operand:SI 2 \"rx_source_operand\"\n+\t\t\t\t   \"r,Sint08,Sint16,Sint24,i,Q,r\")))]\n+  \"\"\n+  \"@\n+  min\\t%Q2, %0\n+  min\\t%Q2, %0\n+  min\\t%Q2, %0\n+  min\\t%Q2, %0\n+  min\\t%Q2, %0\n+  min\\t%Q2, %0\n+  mov.l\\t%1,%0\\n\\tmin\\t%Q2, %0\"\n+  [(set_attr \"length\"  \"3,4,5,6,7,6,5\")\n+   (set_attr \"timings\" \"11,11,11,11,11,33,22\")]\n+)\n+\n+(define_insn \"mulsi3\"\n+  [(set (match_operand:SI          0 \"register_operand\" \"=r,r,r,r,r,r,r,r,r\")\n+        (mult:SI (match_operand:SI 1 \"register_operand\" \"%0,0,0,0,0,0,0,Q,r\")\n+                 (match_operand:SI 2 \"rx_source_operand\"\n+\t\t\t\t   \"r,Uint04,Sint08,Sint16,Sint24,i,Q,0,r\")))]\n+  \"\"\n+  \"@\n+  mul\\t%Q2, %0\n+  mul\\t%Q2, %0\n+  mul\\t%Q2, %0\n+  mul\\t%Q2, %0\n+  mul\\t%Q2, %0\n+  mul\\t%Q2, %0\n+  mul\\t%Q2, %0\n+  mul\\t%Q1, %0\n+  mul\\t%Q2, %1, %0\"\n+  [(set_attr \"length\"  \"2,2,3,4,5,6,5,5,3\")\n+   (set_attr \"timings\" \"11,11,11,11,11,11,33,33,11\")]\n+)\n+\n+(define_insn \"negsi2\"\n+  [(set (match_operand:SI         0 \"register_operand\" \"=r,r\")\n+        (neg:SI (match_operand:SI 1 \"register_operand\"  \"0,r\")))]\n+  ;; The NEG instruction does not comply with -fwrapv semantics.\n+  ;; See gcc.c-torture/execute/pr22493-1.c for an example of this.\n+  \"! flag_wrapv\"\n+  \"@\n+  neg\\t%0\n+  neg\\t%1, %0\"\n+  [(set_attr \"length\" \"2,3\")]\n+)\n+\n+(define_insn \"one_cmplsi2\"\n+  [(set (match_operand:SI         0 \"register_operand\" \"=r,r\")\n+\t(not:SI (match_operand:SI 1 \"register_operand\"  \"0,r\")))]\n+  \"\"\n+  \"@\n+  not\\t%0\n+  not\\t%1, %0\"\n+  [(set_attr \"cc\" \"set_zs\")\n+   (set_attr \"length\" \"2,3\")]\n+)\n+\n+(define_insn \"iorsi3\"\n+  [(set (match_operand:SI         0 \"register_operand\" \"=r,r,r,r,r,r,r,r,r\")\n+\t(ior:SI (match_operand:SI 1 \"register_operand\" \"%0,0,0,0,0,0,r,0,Q\")\n+\t        (match_operand:SI 2 \"rx_source_operand\"\n+\t\t\t\t  \"r,Uint04,Sint08,Sint16,Sint24,i,r,Q,0\")))]\n+  \"\"\n+  \"@\n+  or\\t%2, %0\n+  or\\t%2, %0\n+  or\\t%2, %0\n+  or\\t%2, %0\n+  or\\t%2, %0\n+  or\\t%2, %0\n+  or\\t%2, %1, %0\n+  or\\t%Q2, %0\n+  or\\t%Q1, %0\"\n+  [(set_attr \"cc\" \"set_zs\")\n+   (set_attr \"timings\" \"11,11,11,11,11,11,11,33,33\")\n+   (set_attr \"length\"  \"2,2,3,4,5,6,3,5,5\")]\n+)\n+\n+(define_insn \"rotlsi3\"\n+  [(set (match_operand:SI            0 \"register_operand\" \"=r\")\n+\t(rotate:SI (match_operand:SI 1 \"register_operand\"  \"0\")\n+\t\t   (match_operand:SI 2 \"rx_shift_operand\" \"rn\")))]\n+  \"\"\n+  \"rotl\\t%2, %0\"\n+  [(set_attr \"cc\" \"set_zs\")\n+   (set_attr \"length\" \"3\")]\n+)\n+\n+(define_insn \"rotrsi3\"\n+  [(set (match_operand:SI              0 \"register_operand\" \"=r\")\n+\t(rotatert:SI (match_operand:SI 1 \"register_operand\"  \"0\")\n+\t\t     (match_operand:SI 2 \"rx_shift_operand\" \"rn\")))]\n+  \"\"\n+  \"rotr\\t%2, %0\"\n+  [(set_attr \"cc\" \"set_zs\")\n+   (set_attr \"length\" \"3\")]\n+)\n+\n+(define_insn \"ashrsi3\"\n+  [(set (match_operand:SI              0 \"register_operand\" \"=r,r,r\")\n+\t(ashiftrt:SI (match_operand:SI 1 \"register_operand\"  \"0,0,r\")\n+\t\t     (match_operand:SI 2 \"rx_shift_operand\"  \"r,n,n\")))]\n+  \"\"\n+  \"@\n+  shar\\t%2, %0\n+  shar\\t%2, %0\n+  shar\\t%2, %1, %0\"\n+  [(set_attr \"cc\" \"set_zsoc\")\n+   (set_attr \"length\" \"3,2,3\")]\n+)\n+\n+(define_insn \"lshrsi3\"\n+  [(set (match_operand:SI              0 \"register_operand\" \"=r,r,r\")\n+\t(lshiftrt:SI (match_operand:SI 1 \"register_operand\"  \"0,0,r\")\n+\t\t     (match_operand:SI 2 \"rx_shift_operand\"  \"r,n,n\")))]\n+  \"\"\n+  \"@\n+  shlr\\t%2, %0\n+  shlr\\t%2, %0\n+  shlr\\t%2, %1, %0\"\n+  [(set_attr \"cc\" \"set_zsoc\")\n+   (set_attr \"length\" \"3,2,3\")]\n+)\n+\n+(define_insn \"ashlsi3\"\n+  [(set (match_operand:SI            0 \"register_operand\" \"=r,r,r\")\n+\t(ashift:SI (match_operand:SI 1 \"register_operand\"  \"0,0,r\")\n+\t           (match_operand:SI 2 \"rx_shift_operand\"  \"r,n,n\")))]\n+  \"\"\n+  \"@\n+  shll\\t%2, %0\n+  shll\\t%2, %0\n+  shll\\t%2, %1, %0\"\n+  [(set_attr \"cc\" \"set_zsoc\")\n+   (set_attr \"length\" \"3,2,3\")]\n+)\n+\n+(define_insn \"subsi3\"\n+  [(set (match_operand:SI           0 \"register_operand\" \"=r,r,r,r,r\")\n+\t(minus:SI (match_operand:SI 1 \"register_operand\"  \"0,0,0,r,0\")\n+\t\t  (match_operand:SI 2 \"rx_source_operand\" \"r,Uint04,n,r,Q\")))]\n+  \"\"\n+  \"@\n+  sub\\t%2, %0\n+  sub\\t%2, %0\n+  add\\t%N2, %0\n+  sub\\t%2, %1, %0\n+  sub\\t%Q2, %0\"\n+  [(set_attr \"cc\" \"set_zsoc\")\n+   (set_attr \"timings\" \"11,11,11,11,33\")\n+   (set_attr \"length\" \"2,2,6,3,5\")]\n+)\n+\n+(define_insn \"subdi3\"\n+  [(set (match_operand:DI           0 \"register_operand\" \"=r,r\")\n+\t(minus:DI (match_operand:DI 1 \"register_operand\"  \"0,0\")\n+\t\t  (match_operand:DI 2 \"rx_source_operand\" \"r,Q\")))]\n+  \"\"\n+  \"sub\\t%L2, %L0\\n\\tsbb\\t%H2, %H0\"\n+  [(set_attr \"cc\" \"set_zsoc\")\n+   (set_attr \"timings\" \"22,44\")\n+   (set_attr \"length\" \"5,11\")]\n+)\n+\n+(define_insn \"xorsi3\"\n+  [(set (match_operand:SI         0 \"register_operand\" \"=r,r,r,r,r,r\")\n+\t(xor:SI (match_operand:SI 1 \"register_operand\" \"%0,0,0,0,0,0\")\n+\t        (match_operand:SI 2 \"rx_source_operand\"\n+\t\t\t\t  \"r,Sint08,Sint16,Sint24,i,Q\")))]\n+  \"\"\n+  \"@\n+  xor\\t%Q2, %0\n+  xor\\t%Q2, %0\n+  xor\\t%Q2, %0\n+  xor\\t%Q2, %0\n+  xor\\t%Q2, %0\n+  xor\\t%Q2, %0\"\n+  [(set_attr \"cc\" \"set_zs\")\n+   (set_attr \"timings\" \"11,11,11,11,11,33\")\n+   (set_attr \"length\" \"3,4,5,6,7,6\")]\n+)\n+\n+;; Floating Point Instructions\n+;; These patterns are only enabled with -ffast-math because the RX FPU\n+;; cannot handle sub-normal values.\n+\n+(define_insn \"addsf3\"\n+  [(set (match_operand:SF          0 \"register_operand\"  \"=r,r,r\")\n+\t(plus:SF (match_operand:SF 1 \"register_operand\"  \"%0,0,0\")\n+\t\t (match_operand:SF 2 \"rx_source_operand\"  \"r,F,Q\")))]\n+  \"ALLOW_RX_FPU_INSNS\"\n+  \"@\n+  fadd\\t%2, %0\n+  fadd\\t%2, %0\n+  fadd\\t%2, %0\"\n+  [(set_attr \"cc\" \"set_zs\")\n+   (set_attr \"timings\" \"44,44,66\")\n+   (set_attr \"length\" \"3,7,5\")]\n+)\n+\n+(define_insn \"divsf3\"\n+  [(set (match_operand:SF         0 \"register_operand\" \"=r,r,r\")\n+\t(div:SF (match_operand:SF 1 \"register_operand\"  \"0,0,0\")\n+\t\t(match_operand:SF 2 \"rx_source_operand\" \"r,F,Q\")))]\n+  \"ALLOW_RX_FPU_INSNS\"\n+  \"fdiv\\t%2, %0\"\n+  [(set_attr \"cc\" \"set_zs\")\n+   (set_attr \"timings\" \"1616,1616,1818\")\n+   (set_attr \"length\" \"3,7,5\")]\n+)\n+\n+(define_insn \"mulsf3\"\n+  [(set (match_operand:SF          0 \"register_operand\" \"=r,r,r\")\n+\t(mult:SF (match_operand:SF 1 \"register_operand\" \"%0,0,0\")\n+\t\t(match_operand:SF  2 \"rx_source_operand\" \"r,F,Q\")))]\n+  \"ALLOW_RX_FPU_INSNS\"\n+  \"@\n+  fmul\\t%2, %0\n+  fmul\\t%2, %0\n+  fmul\\t%2, %0\"\n+  [(set_attr \"cc\" \"set_zs\")\n+   (set_attr \"timings\" \"33,33,55\")\n+   (set_attr \"length\"  \"3,7,5\")]\n+)\n+\n+(define_insn \"subsf3\"\n+  [(set (match_operand:SF           0 \"register_operand\" \"=r,r,r\")\n+\t(minus:SF (match_operand:SF 1 \"register_operand\"  \"0,0,0\")\n+\t\t  (match_operand:SF 2 \"rx_source_operand\" \"r,F,Q\")))]\n+  \"ALLOW_RX_FPU_INSNS\"\n+  \"fsub\\t%2, %0\"\n+  [(set_attr \"cc\" \"set_zs\")\n+   (set_attr \"timings\" \"44,44,66\")\n+   (set_attr \"length\" \"3,7,5\")]\n+)\n+\n+(define_insn \"fix_truncsfsi2\"\n+  [(set (match_operand:SI         0 \"register_operand\"  \"=r,r\")\n+\t(fix:SI (match_operand:SF 1 \"rx_compare_operand\" \"r,Q\")))]\n+  \"ALLOW_RX_FPU_INSNS\"\n+  \"ftoi\\t%1, %0\"\n+  [(set_attr \"cc\" \"set_zs\")\n+   (set_attr \"timings\" \"22,44\")\n+   (set_attr \"length\" \"3,5\")]\n+)\n+\n+(define_insn \"floatsisf2\"\n+  [(set (match_operand:SF           0 \"register_operand\"  \"=r,r\")\n+\t(float:SF (match_operand:SI 1 \"rx_compare_operand\" \"r,Q\")))]\n+  \"ALLOW_RX_FPU_INSNS\"\n+  \"itof\\t%1, %0\"\n+  [(set_attr \"cc\" \"set_zs\")\n+   (set_attr \"timings\" \"22,44\")\n+   (set_attr \"length\" \"3,6\")]\n+)\n+\f\n+;; Bit manipulation instructions.\n+;; Note - there are two versions of each pattern because the memory\n+;; accessing versions use QImode whilst the register accessing\n+;; versions use SImode.\n+;; The peephole are here because the combiner only looks at a maximum\n+;; of three instructions at a time.\n+\n+(define_insn \"bitset\"\n+  [(set:SI (match_operand:SI 0 \"register_operand\" \"+r\")\n+\t   (ior:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+\t\t   (ashift:SI (const_int 1)\n+\t\t\t      (match_operand:SI 2 \"nonmemory_operand\" \"ri\"))))]\n+  \"\"\n+  \"bset\\t%2, %0\"\n+  [(set_attr \"length\" \"3\")]\n+)\n+\n+(define_insn \"bitset_in_memory\"\n+  [(set:QI (match_operand:QI 0 \"memory_operand\" \"+m\")\n+\t   (ior:QI (match_operand:QI 1 \"memory_operand\" \"0\")\n+\t\t   (ashift:QI (const_int 1)\n+\t\t\t      (match_operand:QI 2 \"nonmemory_operand\" \"ri\"))))]\n+  \"\"\n+  \"bset\\t%2, %0.B\"\n+  [(set_attr \"length\" \"3\")\n+   (set_attr \"timings\" \"34\")]\n+)\n+\n+;; (set (reg A) (const_int 1))\n+;; (set (reg A) (ashift (reg A) (reg B)))\n+;; (set (reg C) (ior (reg A) (reg C)))\n+(define_peephole2\n+  [(set:SI (match_operand:SI 0 \"register_operand\" \"\")\n+\t   (const_int 1))\n+   (set:SI (match_dup 0)\n+\t   (ashift:SI (match_dup 0)\n+\t\t      (match_operand:SI 1 \"register_operand\" \"\")))\n+   (set:SI (match_operand:SI 2 \"register_operand\" \"\")\n+\t   (ior:SI (match_dup 0)\n+\t\t   (match_dup 2)))]\n+  \"dead_or_set_p (insn, operands[0])\"\n+  [(set:SI (match_dup 2)\n+\t   (ior:SI (match_dup 2)\n+\t\t   (ashift:SI (const_int 1)\n+\t\t\t      (match_dup 1))))]\n+)\n+  \n+;; (set (reg A) (const_int 1))\n+;; (set (reg A) (ashift (reg A) (reg B)))\n+;; (set (reg A) (ior (reg A) (reg C)))\n+;; (set (reg C) (reg A)\n+(define_peephole2\n+  [(set:SI (match_operand:SI 0 \"register_operand\" \"\")\n+\t   (const_int 1))\n+   (set:SI (match_dup 0)\n+\t   (ashift:SI (match_dup 0)\n+\t\t      (match_operand:SI 1 \"register_operand\" \"\")))\n+   (set:SI (match_dup 0)\n+\t   (ior:SI (match_dup 0)\n+\t\t   (match_operand:SI 2 \"register_operand\" \"\")))\n+   (set:SI (match_dup 2) (match_dup 0))]\n+  \"dead_or_set_p (insn, operands[0])\"\n+  [(set:SI (match_dup 2)\n+\t   (ior:SI (match_dup 2)\n+\t\t   (ashift:SI (const_int 1)\n+\t\t\t      (match_dup 1))))]\n+)\n+  \n+(define_insn \"bitinvert\"\n+  [(set:SI (match_operand:SI 0 \"register_operand\" \"+r\")\n+\t   (xor:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+\t\t   (ashift:SI (const_int 1)\n+\t\t\t      (match_operand:SI 2 \"nonmemory_operand\" \"ri\"))))]\n+  \"\"\n+  \"bnot\\t%2, %0\"\n+  [(set_attr \"length\" \"3\")]\n+)\n+\n+(define_insn \"bitinvert_in_memory\"\n+  [(set:QI (match_operand:QI 0 \"memory_operand\" \"+m\")\n+\t   (xor:QI (match_operand:QI 1 \"register_operand\" \"0\")\n+\t\t   (ashift:QI (const_int 1)\n+\t\t\t      (match_operand:QI 2 \"nonmemory_operand\" \"ri\"))))]\n+  \"\"\n+  \"bnot\\t%2, %0.B\"\n+  [(set_attr \"length\" \"5\")\n+   (set_attr \"timings\" \"33\")]\n+)\n+\n+;; (set (reg A) (const_int 1))\n+;; (set (reg A) (ashift (reg A) (reg B)))\n+;; (set (reg C) (xor (reg A) (reg C)))\n+(define_peephole2\n+  [(set:SI (match_operand:SI 0 \"register_operand\" \"\")\n+\t   (const_int 1))\n+   (set:SI (match_dup 0)\n+\t   (ashift:SI (match_dup 0)\n+\t\t      (match_operand:SI 1 \"register_operand\" \"\")))\n+   (set:SI (match_operand:SI 2 \"register_operand\" \"\")\n+\t   (xor:SI (match_dup 0)\n+\t\t   (match_dup 2)))]\n+  \"dead_or_set_p (insn, operands[0])\"\n+  [(set:SI (match_dup 2)\n+\t   (xor:SI (match_dup 2)\n+\t\t   (ashift:SI (const_int 1)\n+\t\t\t      (match_dup 1))))]\n+  \"\"\n+)\n+  \n+;; (set (reg A) (const_int 1))\n+;; (set (reg A) (ashift (reg A) (reg B)))\n+;; (set (reg A) (xor (reg A) (reg C)))\n+;; (set (reg C) (reg A))\n+(define_peephole2\n+  [(set:SI (match_operand:SI 0 \"register_operand\" \"\")\n+\t   (const_int 1))\n+   (set:SI (match_dup 0)\n+\t   (ashift:SI (match_dup 0)\n+\t\t      (match_operand:SI 1 \"register_operand\" \"\")))\n+   (set:SI (match_dup 0)\n+\t   (xor:SI (match_dup 0)\n+\t\t   (match_operand:SI 2 \"register_operand\" \"\")))\n+   (set:SI (match_dup 2) (match_dup 0))]\n+  \"dead_or_set_p (insn, operands[0])\"\n+  [(set:SI (match_dup 2)\n+\t   (xor:SI (match_dup 2)\n+\t\t   (ashift:SI (const_int 1)\n+\t\t\t      (match_dup 1))))]\n+  \"\"\n+)\n+\n+(define_insn \"bitclr\"\n+  [(set:SI (match_operand:SI 0 \"register_operand\" \"+r\")\n+\t   (and:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+\t\t   (not:SI (ashift:SI (const_int 1)\n+\t\t\t\t      (match_operand:SI 2 \"nonmemory_operand\" \"ri\")))))]\n+  \"\"\n+  \"bclr\\t%2, %0\"\n+  [(set_attr \"length\" \"3\")]\n+)\n+\n+(define_insn \"bitclr_in_memory\"\n+  [(set:QI (match_operand:QI 0 \"memory_operand\" \"+m\")\n+\t   (and:QI (match_operand:QI 1 \"memory_operand\" \"0\")\n+\t\t   (not:QI (ashift:QI (const_int 1)\n+\t\t\t\t      (match_operand:QI 2 \"nonmemory_operand\" \"ri\")))))]\n+  \"\"\n+  \"bclr\\t%2, %0.B\"\n+  [(set_attr \"length\" \"3\")\n+   (set_attr \"timings\" \"34\")]\n+)\n+\n+;; (set (reg A) (const_int -2))\n+;; (set (reg A) (rotate (reg A) (reg B)))\n+;; (set (reg C) (and (reg A) (reg C)))\n+(define_peephole2\n+  [(set:SI (match_operand:SI 0 \"register_operand\" \"\")\n+\t   (const_int -2))\n+   (set:SI (match_dup 0)\n+\t   (rotate:SI (match_dup 0)\n+\t\t      (match_operand:SI 1 \"register_operand\" \"\")))\n+   (set:SI (match_operand:SI 2 \"register_operand\" \"\")\n+\t   (and:SI (match_dup 0)\n+\t\t   (match_dup 2)))]\n+  \"dead_or_set_p (insn, operands[0])\"\n+  [(set:SI (match_dup 2)\n+\t   (and:SI (match_dup 2)\n+\t\t   (not:SI (ashift:SI (const_int 1)\n+\t\t\t\t      (match_dup 1)))))]\n+)\n+  \n+;; (set (reg A) (const_int -2))\n+;; (set (reg A) (rotate (reg A) (reg B)))\n+;; (set (reg A) (and (reg A) (reg C)))\n+;; (set (reg C) (reg A)\n+(define_peephole2\n+  [(set:SI (match_operand:SI 0 \"register_operand\" \"\")\n+\t   (const_int -2))\n+   (set:SI (match_dup 0)\n+\t   (rotate:SI (match_dup 0)\n+\t\t      (match_operand:SI 1 \"register_operand\" \"\")))\n+   (set:SI (match_dup 0)\n+\t   (and:SI (match_dup 0)\n+\t\t   (match_operand:SI 2 \"register_operand\" \"\")))\n+   (set:SI (match_dup 2) (match_dup 0))]\n+  \"dead_or_set_p (insn, operands[0])\"\n+  [(set:SI (match_dup 2)\n+\t   (and:SI (match_dup 2)\n+\t\t   (not:SI (ashift:SI (const_int 1)\n+\t\t\t\t      (match_dup 1)))))]\n+)\n+\n+(define_expand \"insv\"\n+  [(set:SI (zero_extract:SI (match_operand:SI\n+\t\t\t     0 \"nonimmediate_operand\") ;; Destination\n+\t\t            (match_operand\n+\t\t\t     1 \"immediate_operand\")    ;; # of bits to set\n+\t\t\t    (match_operand\n+\t\t\t     2 \"immediate_operand\"))   ;; Starting bit\n+\t   (match_operand\n+\t    3 \"immediate_operand\"))]  ;; Bits to insert\n+  \"\"\n+  {\n+    if (rx_expand_insv (operands))\n+      DONE;\n+    FAIL;\n+  }\n+)   \n+\f\n+;; Atomic exchange operation.\n+\n+(define_insn \"sync_lock_test_and_setsi\"\n+  [(set:SI (match_operand:SI 0 \"register_operand\"   \"=r,r\")\n+\t   (match_operand:SI 1 \"rx_compare_operand\" \"=r,Q\"))\n+   (set:SI (match_dup 1)\n+\t   (match_operand:SI 2 \"register_operand\"    \"0,0\"))]\n+  \"\"\n+  \"xchg\\t%1, %0\"\n+  [(set_attr \"length\" \"3,6\")\n+   (set_attr \"timings\" \"22\")]\n+)\n+\n+\f\n+;; Block move functions.\n+\n+(define_expand \"movstr\"\n+  [(set:SI (match_operand:BLK 1 \"memory_operand\")    ;; Dest\n+\t   (match_operand:BLK 2 \"memory_operand\"))   ;; Source\n+   (use (match_operand:SI     0 \"register_operand\")) ;; Updated Dest\n+  ]\n+  \"\"\n+  {\n+    rtx addr1 = gen_rtx_REG (SImode, 1);\n+    rtx addr2 = gen_rtx_REG (SImode, 2);\n+    rtx len   = gen_rtx_REG (SImode, 3);\n+    rtx dest_copy = gen_reg_rtx (SImode);\n+\n+    emit_move_insn (len, GEN_INT (-1));\n+    emit_move_insn (addr1, force_operand (XEXP (operands[1], 0), NULL_RTX));\n+    emit_move_insn (addr2, force_operand (XEXP (operands[2], 0), NULL_RTX));\n+    operands[1] = replace_equiv_address_nv (operands[1], addr1);\n+    operands[2] = replace_equiv_address_nv (operands[2], addr2);\n+    emit_move_insn (dest_copy, addr1);\n+    emit_insn (gen_rx_movstr ());\n+    emit_move_insn (len, GEN_INT (-1));\n+    emit_insn (gen_rx_strend (operands[0], dest_copy));\n+    DONE;\n+  }\n+)\n+\n+(define_insn \"rx_movstr\"\n+  [(set:SI (mem:BLK (reg:SI 1))\n+\t   (mem:BLK (reg:SI 2)))\n+   (unspec_volatile:BLK [(reg:SI 1) (reg:SI 2) (reg:SI 3)] UNSPEC_MOVSTR)\n+   (clobber (reg:SI 1))\n+   (clobber (reg:SI 2))\n+   (clobber (reg:SI 3))\n+  ]\n+  \"\"\n+  \"smovu\"\n+  [(set_attr \"length\" \"2\")\n+   (set_attr \"timings\" \"1111\")] ;; The timing is a guesstimate.\n+)\n+\n+(define_insn \"rx_strend\"\n+  [(set:SI (match_operand:SI                      0 \"register_operand\" \"=r\")\n+\t   (unspec_volatile:SI [(match_operand:SI 1 \"register_operand\"  \"r\")\n+\t\t\t\t(reg:SI 3)] UNSPEC_STRLEN))\n+   (clobber (reg:SI 1))\n+   (clobber (reg:SI 2))\n+   (clobber (reg:SI 3))\n+  ]\n+  \"\"\n+  \"mov\\t%1, r1\\n\\tmov\\t#0, r2\\n\\tsuntil.b\\n\\tmov\\tr1, %0\\n\\tsub\\t#1, %0\"\n+  [(set_attr \"length\" \"10\")\n+   (set_attr \"cc\" \"clobber\")\n+   (set_attr \"timings\" \"1111\")] ;; The timing is a guesstimate.\n+)\n+\n+(define_expand \"movmemsi\"\n+  [(parallel\n+    [(set (match_operand:BLK 0 \"memory_operand\")    ;; Dest\n+\t  (match_operand:BLK 1 \"memory_operand\"))   ;; Source\n+     (use (match_operand:SI  2 \"register_operand\")) ;; Length in bytes\n+     (match_operand          3 \"immediate_operand\") ;; Align\n+     (unspec_volatile:BLK [(reg:SI 1) (reg:SI 2) (reg:SI 3)] UNSPEC_MOVMEM)]\n+    )]\n+  \"\"\n+  {\n+    rtx addr1 = gen_rtx_REG (SImode, 1);\n+    rtx addr2 = gen_rtx_REG (SImode, 2);\n+    rtx len   = gen_rtx_REG (SImode, 3);\n+\n+    if (REG_P (operands[0]) && (REGNO (operands[0]) == 2\n+\t\t\t\t      || REGNO (operands[0]) == 3))\n+      FAIL;\n+    if (REG_P (operands[1]) && (REGNO (operands[1]) == 1\n+\t\t\t\t      || REGNO (operands[1]) == 3))\n+      FAIL;\n+    if (REG_P (operands[2]) && (REGNO (operands[2]) == 1\n+\t\t\t\t      || REGNO (operands[2]) == 2))\n+      FAIL;\n+    emit_move_insn (addr1, force_operand (XEXP (operands[0], 0), NULL_RTX));\n+    emit_move_insn (addr2, force_operand (XEXP (operands[1], 0), NULL_RTX));\n+    emit_move_insn (len, force_operand (operands[2], NULL_RTX));\n+    operands[0] = replace_equiv_address_nv (operands[0], addr1);\n+    operands[1] = replace_equiv_address_nv (operands[1], addr2);\n+    emit_insn (gen_rx_movmem ());\n+    DONE;\n+  }\n+)\n+\n+(define_insn \"rx_movmem\"\n+  [(set (mem:BLK (reg:SI 1))\n+\t(mem:BLK (reg:SI 2)))\n+   (use (reg:SI 3))\n+   (unspec_volatile:BLK [(reg:SI 1) (reg:SI 2) (reg:SI 3)] UNSPEC_MOVMEM)\n+   (clobber (reg:SI 1))\n+   (clobber (reg:SI 2))\n+   (clobber (reg:SI 3))]\n+  \"\"\n+  \"smovf\"\n+  [(set_attr \"length\" \"2\")\n+   (set_attr \"timings\" \"1111\")] ;; The timing is a guesstimate.\n+)\n+\n+(define_expand \"setmemsi\"\n+  [(set (match_operand:BLK 0 \"memory_operand\")     ;; Dest\n+        (match_operand:QI  2 \"nonmemory_operand\")) ;; Value\n+   (use (match_operand:SI  1 \"nonmemory_operand\")) ;; Length\n+   (match_operand          3 \"immediate_operand\")  ;; Align\n+   (unspec_volatile:BLK [(reg:SI 1) (reg:SI 2) (reg:SI 3)] UNSPEC_SETMEM)]\n+  \"\"\n+  {\n+    rtx addr = gen_rtx_REG (SImode, 1);\n+    rtx val  = gen_rtx_REG (QImode, 2);\n+    rtx len  = gen_rtx_REG (SImode, 3);\n+\n+    emit_move_insn (addr, force_operand (XEXP (operands[0], 0), NULL_RTX));\n+    emit_move_insn (len, force_operand (operands[1], NULL_RTX));\n+    emit_move_insn (val, operands[2]);\n+    emit_insn (gen_rx_setmem ());\n+    DONE;\n+  }\n+)\n+\n+(define_insn \"rx_setmem\"\n+  [(set:BLK (mem:BLK (reg:SI 1)) (reg 2))\n+   (unspec_volatile:BLK [(reg:SI 1) (reg:SI 2) (reg:SI 3)] UNSPEC_SETMEM)\n+   (clobber (reg:SI 1))\n+   (clobber (reg:SI 3))]\n+  \"\"\n+  \"sstr.b\"\n+  [(set_attr \"length\" \"2\")\n+   (set_attr \"timings\" \"1111\")] ;; The timing is a guesstimate.\n+)\n+\n+(define_expand \"cmpstrnsi\"\n+  [(set (match_operand:SI\n+\t 0 \"register_operand\") ;; Result\n+\t(unspec_volatile:SI [(match_operand:BLK\n+\t\t\t      1 \"memory_operand\") ;; String1\n+\t\t\t     (match_operand:BLK\n+\t\t\t      2 \"memory_operand\")] ;; String2\n+\t\t\t    UNSPEC_CMPSTRN))\n+   (use (match_operand:SI\n+\t 3 \"register_operand\")) ;; Max Length\n+   (match_operand:SI\n+    4 \"immediate_operand\")] ;; Known Align\n+  \"\"\n+  {\n+    rtx str1 = gen_rtx_REG (SImode, 1);\n+    rtx str2 = gen_rtx_REG (SImode, 2);\n+    rtx len  = gen_rtx_REG (SImode, 3);\n+  \n+    emit_move_insn (str1, force_operand (XEXP (operands[1], 0), NULL_RTX));\n+    emit_move_insn (str2, force_operand (XEXP (operands[2], 0), NULL_RTX));\n+    emit_move_insn (len, force_operand (operands[3], NULL_RTX));\n+\n+    emit_insn (gen_rx_cmpstrn (operands[0], operands[1], operands[2]));\n+    DONE;\n+  }\n+)\n+\n+(define_expand \"cmpstrsi\"\n+  [(set (match_operand:SI\n+\t 0 \"register_operand\") ;; Result\n+\t(unspec_volatile:SI [(match_operand:BLK\n+\t\t\t      1 \"memory_operand\")  ;; String1\n+\t\t\t     (match_operand:BLK\n+\t\t\t      2 \"memory_operand\")] ;; String2\n+\t\t\t    UNSPEC_CMPSTRN))\n+   (match_operand:SI\n+    3 \"immediate_operand\")] ;; Known Align\n+  \"\"\n+  {\n+    rtx str1 = gen_rtx_REG (SImode, 1);\n+    rtx str2 = gen_rtx_REG (SImode, 2);\n+    rtx len  = gen_rtx_REG (SImode, 3);\n+  \n+    emit_move_insn (str1, force_reg (SImode, XEXP (operands[1], 0)));\n+    emit_move_insn (str2, force_reg (SImode, XEXP (operands[2], 0)));\n+    emit_move_insn (len, GEN_INT (-1));\n+\n+    emit_insn (gen_rx_cmpstrn (operands[0], operands[1], operands[2]));\n+    DONE;\n+  }\n+)\n+\n+(define_insn \"rx_cmpstrn\"\n+  [(set:SI (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t   (unspec_volatile:SI [(reg:SI 1) (reg:SI 2) (reg:SI 3)]\n+\t\t\t       UNSPEC_CMPSTRN))\n+   (use (match_operand:BLK   1 \"memory_operand\" \"m\"))\n+   (use (match_operand:BLK   2 \"memory_operand\" \"m\"))\n+   (clobber (reg:SI 1))\n+   (clobber (reg:SI 2))\n+   (clobber (reg:SI 3))]\n+  \"\"\n+  \"scmpu\t\t; Perform the string comparison\n+   mov     #-1, %0      ; Set up -1 result (which cannot be created\n+                        ; by the SC insn)\n+   bnc\t   ?+\t\t; If Carry is not set skip over\n+   scne.L  %0\t\t; Set result based on Z flag\n+?:              \t\n+\"\n+  [(set_attr \"length\" \"9\")\n+   (set_attr \"timings\" \"1111\")] ;; The timing is a guesstimate.\n+)\n+\f\n+;;   Builtin Functions\n+;;\n+;; GCC does not have the ability to generate the following instructions\n+;; on its own so they are provided as builtins instead.  To use them from\n+;; a program for example invoke them as __builtin_rx_<insn_name>.  For\n+;; example:\n+;;\n+;;    int short_byte_swap (int arg) { return __builtin_rx_revw (arg); }\n+\n+;;---------- Accumulator Support ------------------------\n+\n+;; Multiply & Accumulate (high)\n+(define_insn \"machi\"\n+  [(unspec:SI [(match_operand:SI 0 \"register_operand\" \"r\")\n+\t       (match_operand:SI 1 \"register_operand\" \"r\")]\n+\t      UNSPEC_BUILTIN_MACHI)]\n+  \"\"\n+  \"machi\\t%0, %1\"\n+  [(set_attr \"length\" \"3\")]\n+)\n+\n+;; Multiply & Accumulate (low)\n+(define_insn \"maclo\"\n+  [(unspec:SI [(match_operand:SI 0 \"register_operand\" \"r\")\n+\t       (match_operand:SI 1 \"register_operand\" \"r\")]\n+\t      UNSPEC_BUILTIN_MACLO)]\n+  \"\"\n+  \"maclo\\t%0, %1\"\n+  [(set_attr \"length\" \"3\")]\n+)\n+\n+;; Multiply (high)\n+(define_insn \"mulhi\"\n+  [(unspec:SI [(match_operand:SI 0 \"register_operand\" \"r\")\n+\t       (match_operand:SI 1 \"register_operand\" \"r\")]\n+\t      UNSPEC_BUILTIN_MULHI)]\n+  \"\"\n+  \"mulhi\\t%0, %1\"\n+  [(set_attr \"length\" \"3\")]\n+)\n+\n+;; Multiply (low)\n+(define_insn \"mullo\"\n+  [(unspec:SI [(match_operand:SI 0 \"register_operand\" \"r\")\n+\t       (match_operand:SI 1 \"register_operand\" \"r\")]\n+\t      UNSPEC_BUILTIN_MULLO)]\n+  \"\"\n+  \"mullo\\t%0, %1\"\n+  [(set_attr \"length\" \"3\")]\n+)\n+\n+;; Move from Accumulator (high)\n+(define_insn \"mvfachi\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(unspec:SI [(const_int 0)]\n+\t\t   UNSPEC_BUILTIN_MVFACHI))]\n+  \"\"\n+  \"mvfachi\\t%0\"\n+  [(set_attr \"length\" \"3\")]\n+)\n+\n+;; Move from Accumulator (middle)\n+(define_insn \"mvfacmi\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(unspec:SI [(const_int 0)]\n+\t\t   UNSPEC_BUILTIN_MVFACMI))]\n+  \"\"\n+  \"mvfacmi\\t%0\"\n+  [(set_attr \"length\" \"3\")]\n+)\n+\n+;; Move to Accumulator (high)\n+(define_insn \"mvtachi\"\n+  [(unspec:SI [(match_operand:SI 0 \"register_operand\" \"r\")]\n+\t      UNSPEC_BUILTIN_MVTACHI)]\n+  \"\"\n+  \"mvtachi\\t%0\"\n+  [(set_attr \"length\" \"3\")]\n+)\n+\n+;; Move to Accumulator (low)\n+(define_insn \"mvtaclo\"\n+  [(unspec:SI [(match_operand:SI 0 \"register_operand\" \"r\")]\n+\t      UNSPEC_BUILTIN_MVTACLO)]\n+  \"\"\n+  \"mvtaclo\\t%0\"\n+  [(set_attr \"length\" \"3\")]\n+)\n+\n+;; Round Accumulator\n+(define_insn \"racw\"\n+  [(unspec:SI [(match_operand:SI 0 \"immediate_operand\" \"i\")]\n+\t      UNSPEC_BUILTIN_RACW)]\n+  \"\"\n+  \"racw\\t%0\"\n+  [(set_attr \"length\" \"3\")]\n+)\n+\n+;; Repeat multiply and accumulate\n+(define_insn \"rmpa\"\n+  [(unspec:SI [(const_int 0) (reg:SI 1) (reg:SI 2) (reg:SI 3)\n+\t       (reg:SI 4) (reg:SI 5) (reg:SI 6)]\n+\t      UNSPEC_BUILTIN_RMPA)\n+  (clobber (reg:SI 1))\n+  (clobber (reg:SI 2))\n+  (clobber (reg:SI 3))]\n+  \"\"\n+  \"rmpa\"\n+  [(set_attr \"length\" \"2\")\n+   (set_attr \"timings\" \"1010\")]\n+)\n+\n+;;---------- Arithmetic ------------------------\n+\n+;; Byte swap (two 16-bit values).\n+(define_insn \"revw\"\n+  [(set (match_operand:SI             0 \"register_operand\" \"+r\")\n+\t(unspec:SI [(match_operand:SI 1 \"register_operand\"  \"r\")]\n+\t\t   UNSPEC_BUILTIN_REVW))]\n+  \"\"\n+  \"revw\\t%1, %0\"\n+  [(set_attr \"length\" \"3\")]\n+)\n+\n+;; Round to integer.\n+(define_insn \"lrintsf2\"\n+  [(set (match_operand:SI             0 \"register_operand\"  \"=r,r\")\n+\t(unspec:SI [(match_operand:SF 1 \"rx_compare_operand\" \"r,Q\")]\n+\t\t   UNSPEC_BUILTIN_ROUND))]\n+  \"\"\n+  \"round\\t%1, %0\"\n+  [(set_attr \"cc\" \"set_zs\")\n+   (set_attr \"timings\" \"22,44\")   \n+   (set_attr \"length\" \"3,5\")]\n+)\n+\n+;; Saturate to 32-bits\n+(define_insn \"sat\"\n+  [(set (match_operand:SI             0 \"register_operand\" \"=r\")\n+\t(unspec:SI [(match_operand:SI 1 \"register_operand\"  \"0\")]\n+\t\t   UNSPEC_BUILTIN_SAT))]\n+  \"\"\n+  \"sat\\t%0\"\n+  [(set_attr \"length\" \"2\")]\n+)\n+\n+;;---------- Control Registers ------------------------\n+\n+;; Clear Processor Status Word\n+(define_insn \"clrpsw\"\n+  [(unspec:SI [(match_operand:SI 0 \"immediate_operand\" \"i\")]\n+\t      UNSPEC_BUILTIN_CLRPSW)\n+   (clobber (cc0))]\n+  \"\"\n+  \"clrpsw\\t%F0\"\n+  [(set_attr \"length\" \"2\")\n+   (set_attr \"cc\" \"clobber\")]\n+)\n+\n+;; Set Processor Status Word\n+(define_insn \"setpsw\"\n+  [(unspec:SI [(match_operand:SI 0 \"immediate_operand\" \"i\")]\n+\t      UNSPEC_BUILTIN_SETPSW)\n+   (clobber (cc0))]\n+  \"\"\n+  \"setpsw\\t%F0\"\n+  [(set_attr \"length\" \"2\")\n+   (set_attr \"cc\" \"clobber\")]\n+)\n+\n+;; Move from control register\n+(define_insn \"mvfc\"\n+  [(set (match_operand:SI                      0 \"register_operand\" \"=r\")\n+\t(unspec:SI [(match_operand:SI 1 \"immediate_operand\" \"i\")]\n+\t\t   UNSPEC_BUILTIN_MVFC))]\n+  \"\"\n+  \"mvfc\\t%C1, %0\"\n+  [(set_attr \"length\" \"3\")]\n+)\n+\n+;; Move to control register\n+(define_insn \"mvtc\"\n+  [(unspec:SI [(match_operand:SI 0 \"immediate_operand\" \"i,i\")\n+\t       (match_operand:SI 1 \"nonmemory_operand\" \"r,i\")]\n+\t      UNSPEC_BUILTIN_MVTC)\n+   (clobber (cc0))]\n+  \"\"\n+  \"mvtc\\t%1, %C0\"\n+  [(set_attr \"length\" \"3,7\")\n+   (set_attr \"cc\" \"clobber\")]  ;; Just in case the control\n+                               ;; register selected is the psw.\n+)\n+\n+;;---------- Interrupts ------------------------\n+\n+;; Break\n+(define_insn \"brk\"\n+  [(unspec_volatile [(const_int 0)]\n+\t\t    UNSPEC_BUILTIN_BRK)]\n+  \"\"\n+  \"brk\"\n+  [(set_attr \"length\" \"1\")\n+   (set_attr \"timings\" \"66\")]\n+)\n+\n+;; Interrupt\n+(define_insn \"int\"\n+  [(unspec_volatile:SI [(match_operand:SI 0 \"immediate_operand\" \"i\")]\n+\t\t       UNSPEC_BUILTIN_INT)]\n+  \"\"\n+  \"int\\t%0\"\n+  [(set_attr \"length\" \"3\")]\n+)\n+\n+;; Wait\n+(define_insn \"wait\"\n+  [(unspec_volatile [(const_int 0)]\n+\t\t    UNSPEC_BUILTIN_WAIT)]\n+  \"\"\n+  \"wait\"\n+  [(set_attr \"length\" \"2\")]\n+)\n+\n+;;---------- CoProcessor Support ------------------------\n+\n+;; FIXME: The instructions are currently commented out because\n+;; the bit patterns have not been finalized, so the assembler\n+;; does not support them.  Once they are decided and the assembler\n+;; supports them, enable the instructions here.\n+\n+;; Move from co-processor register\n+(define_insn \"mvfcp\"\n+  [(set (match_operand:SI             0 \"register_operand\" \"=r\")\n+\t(unspec:SI [(match_operand:SI 1 \"immediate_operand\" \"i\")\n+\t\t    (match_operand:SI 2 \"immediate_operand\" \"i\")]\n+\t\t   UNSPEC_BUILTIN_MVFCP))]\n+  \"\"\n+  \"; mvfcp\\t%1, %0, %2\"\n+  [(set_attr \"length\" \"5\")]\n+)\n+\n+;; Move to co-processor register\n+(define_insn \"mvtcp\"\n+  [(unspec:SI [(match_operand:SI 0 \"immediate_operand\" \"i,i\")\n+\t       (match_operand:SI 1 \"nonmemory_operand\" \"i,r\")\n+\t       (match_operand:SI 2 \"immediate_operand\" \"i,i\")]\n+\t      UNSPEC_BUILTIN_MVTCP)]\n+  \"\"\n+  \"; mvtcp\\t%0, %1, %2\"\n+  [(set_attr \"length\" \"7,5\")]\n+)\n+\n+;; Co-processor operation\n+(define_insn \"opecp\"\n+  [(unspec:SI [(match_operand:SI 0 \"immediate_operand\" \"i\")\n+\t       (match_operand:SI 1 \"immediate_operand\" \"i\")]\n+\t      UNSPEC_BUILTIN_OPEPC)]\n+  \"\"\n+  \"; opecp\\t%0, %1\"\n+  [(set_attr \"length\" \"5\")]\n+)\n+\n+;;---------- Misc ------------------------\n+\n+;; Required by cfglayout.c...\n+(define_insn \"nop\"\n+  [(const_int 0)]\n+  \"\"\n+  \"nop\"\n+  [(set_attr \"length\" \"1\")]\n+)"}, {"sha": "83e75bfba768a2c99c4a804a3e5ca3898e0a3791", "filename": "gcc/config/rx/rx.opt", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65a324b459e60405cebe9e34ee6b3496559cd217/gcc%2Fconfig%2Frx%2Frx.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65a324b459e60405cebe9e34ee6b3496559cd217/gcc%2Fconfig%2Frx%2Frx.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frx%2Frx.opt?ref=65a324b459e60405cebe9e34ee6b3496559cd217", "patch": "@@ -0,0 +1,74 @@\n+; Command line options for the Renesas RX port of GCC.\n+; Copyright (C) 2008, 2009 Free Software Foundation, Inc.\n+; Contributed by Red Hat.\n+;\n+; This file is part of GCC.\n+;\n+; GCC is free software; you can redistribute it and/or modify it under\n+; the terms of the GNU General Public License as published by the Free\n+; Software Foundation; either version 3, or (at your option) any later\n+; version.\n+;\n+; GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+; WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+; FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+; for more details.\n+;\n+; You should have received a copy of the GNU General Public License\n+; along with GCC; see the file COPYING3.  If not see\n+; <http://www.gnu.org/licenses/>.\n+;---------------------------------------------------\n+\n+m64bit-doubles\n+Target RejectNegative Mask(64BIT_DOUBLES)\n+Store doubles in 64 bits.\n+\n+m32bit-doubles\n+Target RejectNegative InverseMask(64BIT_DOUBLES)\n+Stores doubles in 32 bits.  This is the default.\n+\n+;---------------------------------------------------\n+\n+mbig-endian-data\n+Target RejectNegative Mask(BIG_ENDIAN_DATA)\n+Data is stored in big-endian format.\n+\n+mlittle-endian-data\n+Target RejectNegative InverseMask(BIG_ENDIAN_DATA)\n+Data is stored in little-endian format.  (Default).\n+\n+;---------------------------------------------------\n+\n+msmall-data-limit=\n+Target RejectNegative Joined UInteger Var(rx_small_data_limit) Init(0)\n+Maximum size of global and static variables which can be placed into the small data area.\n+\n+;---------------------------------------------------\n+\n+msim\n+Target\n+Use the simulator runtime.\n+\n+;---------------------------------------------------\n+\n+mas100-syntax\n+Target Mask(AS100_SYNTAX)\n+Generate assembler output that is compatible with the Renesas AS100 assembler.  This may restrict some of the compiler's capabilities.  The default is to generate GAS compatable syntax.\n+\n+;---------------------------------------------------\n+\n+mrelax\n+Target\n+Enable linker relaxation.\n+\n+;---------------------------------------------------\n+\n+mmax-constant-size=\n+Target RejectNegative Joined UInteger Var(rx_max_constant_size) Init(0)\n+Maximum size in bytes of constant values allowed as operands.\n+\n+;---------------------------------------------------\n+\n+mint-register=\n+Target RejectNegative Joined UInteger Var(rx_interrupt_registers) Init(0)\n+Specifies the number of registers to reserve for interrupt handlers."}, {"sha": "39cda72af5743211db3074bf6a7515073b9aaa63", "filename": "gcc/config/rx/t-rx", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65a324b459e60405cebe9e34ee6b3496559cd217/gcc%2Fconfig%2Frx%2Ft-rx", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65a324b459e60405cebe9e34ee6b3496559cd217/gcc%2Fconfig%2Frx%2Ft-rx", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frx%2Ft-rx?ref=65a324b459e60405cebe9e34ee6b3496559cd217", "patch": "@@ -0,0 +1,32 @@\n+# Makefile fragment for building GCC for the Renesas RX target.\n+# Copyright (C) 2008, 2009 Free Software Foundation, Inc.\n+# Contributed by Red Hat.\n+#\n+# This file is part of GCC.\n+#\n+# GCC is free software; you can redistribute it and/or modify it\n+# under the terms of the GNU General Public License as published\n+# by the Free Software Foundation; either version 3, or (at your\n+# option) any later version.\n+#\n+# GCC is distributed in the hope that it will be useful, but\n+# WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.   See\n+# the GNU General Public License for more details.\n+#\n+# You should have received a copy of the  GNU General Public\n+# License along with GCC; see the file COPYING3.  If not see\n+# <http://www.gnu.org/licenses/>.\n+\n+# Enable multilibs:\n+\n+MULTILIB_OPTIONS    = m64bit-doubles mbig-endian-data\n+MULTILIB_DIRNAMES   = 64fp           big-endian-data\n+MULTILIB_MATCHES    = m64bit-doubles=mieee\n+MULTILIB_EXCEPTIONS =\n+MULTILIB_EXTRA_OPTS = \n+\n+LIBGCC = stmp-multilib\n+INSTALL_LIBGCC = install-multilib\n+\n+EXTRA_MULTILIB_PARTS = crtbegin.o crtend.o"}, {"sha": "ca86f28dd3999a192172679b7c7e291e8ded0f14", "filename": "gcc/doc/contrib.texi", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65a324b459e60405cebe9e34ee6b3496559cd217/gcc%2Fdoc%2Fcontrib.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65a324b459e60405cebe9e34ee6b3496559cd217/gcc%2Fdoc%2Fcontrib.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fcontrib.texi?ref=65a324b459e60405cebe9e34ee6b3496559cd217", "patch": "@@ -173,8 +173,8 @@ The @uref{http://www.gnu.org/software/classpath/,,GNU Classpath project}\n for all of their merged runtime code.\n \n @item\n-Nick Clifton for arm, mcore, fr30, v850, m32r work, @option{--help}, and\n-other random hacking.\n+Nick Clifton for arm, mcore, fr30, v850, m32r, rx work,\n+@option{--help}, and other random hacking.\n \n @item\n Michael Cook for libstdc++ cleanup patches to reduce warnings."}, {"sha": "6883766cfc6ad0fa1abed1466d242b6550d1e1c9", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 127, "deletions": 5, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65a324b459e60405cebe9e34ee6b3496559cd217/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65a324b459e60405cebe9e34ee6b3496559cd217/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=65a324b459e60405cebe9e34ee6b3496559cd217", "patch": "@@ -2244,6 +2244,13 @@ on data in the eight bit data area.  Note the eight bit data area is limited to\n You must use GAS and GLD from GNU binutils version 2.7 or later for\n this attribute to work correctly.\n \n+@item exception\n+@cindex exception handler functions on the RX processor\n+Use this attribute on the RX to indicate that the specified function\n+is an exception handler.  The compiler will generate function entry and\n+exit sequences suitable for use in an exception handler when this\n+attribute is present.\n+\n @item exception_handler\n @cindex exception handler functions on the Blackfin processor\n Use this attribute on the Blackfin to indicate that the specified function\n@@ -2280,7 +2287,7 @@ addressing modes.\n \n @item fast_interrupt\n @cindex interrupt handler functions\n-Use this attribute on the M32C port to indicate that the specified\n+Use this attribute on the M32C and RX ports to indicate that the specified\n function is a fast interrupt handler.  This is just like the\n @code{interrupt} attribute, except that @code{freit} is used to return\n instead of @code{reit}.\n@@ -2472,8 +2479,8 @@ This attribute is ignored for R8C target.\n \n @item interrupt\n @cindex interrupt handler functions\n-Use this attribute on the ARM, AVR, CRX, M32C, M32R/D, m68k, MeP, MIPS\n-and Xstormy16 ports to indicate that the specified function is an\n+Use this attribute on the ARM, AVR, CRX, M32C, M32R/D, m68k, MeP, MIPS,\n+RX and Xstormy16 ports to indicate that the specified function is an\n interrupt handler.  The compiler will generate function entry and exit\n sequences suitable for use in an interrupt handler when this attribute\n is present.\n@@ -2689,7 +2696,7 @@ support for the swap suffix in the assembler. (GNU Binutils 2.19.51 or later)\n \n @item naked\n @cindex function without a prologue/epilogue code\n-Use this attribute on the ARM, AVR, IP2K and SPU ports to indicate that\n+Use this attribute on the ARM, AVR, IP2K, RX and SPU ports to indicate that\n the specified function does not need prologue/epilogue sequences generated by\n the compiler.  It is up to the programmer to provide these sequences. The \n only statements that can be safely included in naked functions are \n@@ -7460,6 +7467,7 @@ instructions, but allow the compiler to schedule those calls.\n * Other MIPS Built-in Functions::\n * picoChip Built-in Functions::\n * PowerPC AltiVec/VSX Built-in Functions::\n+* RX Built-in Functions::\n * SPARC VIS Built-in Functions::\n * SPU Built-in Functions::\n @end menu\n@@ -11754,6 +11762,121 @@ long __builtin_bpermd (long, long);\n int __builtin_bswap16 (int);\n @end smallexample\n \n+@node RX Built-in Functions\n+@subsection RX Built-in Functions\n+GCC supports some of the RX instructions which cannot be expressed in\n+the C programming language via the use of built-in functions.  The\n+following functions are supported:\n+\n+@deftypefn {Built-in Function}  void __builtin_rx_brk (void)\n+Generates the @code{brk} machine instruction.\n+@end deftypefn\n+\n+@deftypefn {Built-in Function}  void __builtin_rx_clrpsw (int)\n+Generates the @code{clrpsw} machine instruction to clear the specified\n+bit in the processor status word.\n+@end deftypefn\n+\n+@deftypefn {Built-in Function}  void __builtin_rx_int (int)\n+Generates the @code{int} machine instruction to generate an interrupt\n+with the specified value.\n+@end deftypefn\n+\n+@deftypefn {Built-in Function}  void __builtin_rx_machi (int, int)\n+Generates the @code{machi} machine instruction to add the result of\n+multiplying the top 16-bits of the two arguments into the\n+accumulator.\n+@end deftypefn\n+\n+@deftypefn {Built-in Function}  void __builtin_rx_maclo (int, int)\n+Generates the @code{maclo} machine instruction to add the result of\n+multiplying the bottom 16-bits of the two arguments into the\n+accumulator.\n+@end deftypefn\n+\n+@deftypefn {Built-in Function}  void __builtin_rx_mulhi (int, int)\n+Generates the @code{mulhi} machine instruction to place the result of\n+multiplying the top 16-bits of the two arguments into the\n+accumulator.\n+@end deftypefn\n+\n+@deftypefn {Built-in Function}  void __builtin_rx_mullo (int, int)\n+Generates the @code{mullo} machine instruction to place the result of\n+multiplying the bottom 16-bits of the two arguments into the\n+accumulator.\n+@end deftypefn\n+\n+@deftypefn {Built-in Function}  int  __builtin_rx_mvfachi (void)\n+Generates the @code{mvfachi} machine instruction to read the top\n+32-bits of the accumulator.\n+@end deftypefn\n+\n+@deftypefn {Built-in Function}  int  __builtin_rx_mvfacmi (void)\n+Generates the @code{mvfacmi} machine instruction to read the middle\n+32-bits of the accumulator.\n+@end deftypefn\n+\n+@deftypefn {Built-in Function}  int __builtin_rx_mvfc (int)\n+Generates the @code{mvfc} machine instruction which reads the control\n+register specified in its argument and returns its value.\n+@end deftypefn\n+\n+@deftypefn {Built-in Function}  void __builtin_rx_mvtachi (int)\n+Generates the @code{mvtachi} machine instruction to set the top\n+32-bits of the accumulator.\n+@end deftypefn\n+\n+@deftypefn {Built-in Function}  void __builtin_rx_mvtaclo (int)\n+Generates the @code{mvtaclo} machine instruction to set the bottom\n+32-bits of the accumulator.\n+@end deftypefn\n+\n+@deftypefn {Built-in Function}  void __builtin_rx_mvtc (int reg, int val)\n+Generates the @code{mvtc} machine instruction which sets control\n+register number @code{reg} to @code{val}.\n+@end deftypefn\n+\n+@deftypefn {Built-in Function}  void __builtin_rx_mvtipl (int)\n+Generates the @code{mvtipl} machine instruction set the interrupt\n+priority level.\n+@end deftypefn\n+\n+@deftypefn {Built-in Function}  void __builtin_rx_racw (int)\n+Generates the @code{racw} machine instruction to round the accumulator\n+according to the specified mode.\n+@end deftypefn\n+\n+@deftypefn {Built-in Function}  int __builtin_rx_revw (int)\n+Generates the @code{revw} machine instruction which swaps the bytes in\n+the argument so that bits 0--7 now occupy bits 8--15 and vice versa,\n+and also bits 16--23 occupy bits 24--31 and vice versa.\n+@end deftypefn\n+\n+@deftypefn {Built-in Function}  void __builtin_rx_rmpa (void)\n+Generates the @code{rmpa} machine instruction which initiates a\n+repeated multiply and accumulate sequence.\n+@end deftypefn\n+\n+@deftypefn {Built-in Function}  void __builtin_rx_round (float)\n+Generates the @code{round} machine instruction which returns the\n+floating point argument rounded according to the current rounding mode\n+set in the floating point status word register.\n+@end deftypefn\n+\n+@deftypefn {Built-in Function}  int __builtin_rx_sat (int)\n+Generates the @code{sat} machine instruction which returns the\n+saturated value of the argument.\n+@end deftypefn\n+\n+@deftypefn {Built-in Function}  void __builtin_rx_setpsw (int)\n+Generates the @code{setpsw} machine instruction to set the specified\n+bit in the processor status word.\n+@end deftypefn\n+\n+@deftypefn {Built-in Function}  void __builtin_rx_wait (void)\n+Generates the @code{wait} machine instruction.\n+@end deftypefn\n+\n @node SPARC VIS Built-in Functions\n @subsection SPARC VIS Built-in Functions\n \n@@ -12003,7 +12126,6 @@ extern int foo ();\n \n @end table\n \n-\n @node RS/6000 and PowerPC Pragmas\n @subsection RS/6000 and PowerPC Pragmas\n "}, {"sha": "0fd68244ea7e6bb26fa27dae490796210bc446c9", "filename": "gcc/doc/install.texi", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65a324b459e60405cebe9e34ee6b3496559cd217/gcc%2Fdoc%2Finstall.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65a324b459e60405cebe9e34ee6b3496559cd217/gcc%2Fdoc%2Finstall.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finstall.texi?ref=65a324b459e60405cebe9e34ee6b3496559cd217", "patch": "@@ -4001,6 +4001,14 @@ the PSIM simulator.\n @heading @anchor{powerpcle-x-eabi}powerpcle-*-eabi\n Embedded PowerPC system in little endian mode.\n \n+@html\n+<hr />\n+@end html\n+@heading @anchor{rx-x-elf}rx-*-elf\n+The Renesas RX processor.  See\n+@uref{http://eu.renesas.com/fmwk.jsp?cnt=rx600_series_landing.jsp&fp=/products/mpumcu/rx_family/rx600_series}\n+for more information about this processor.\n+\n @html\n <hr />\n @end html"}, {"sha": "b45df833f2e883d833aafaec1d5779a6edde9d88", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 118, "deletions": 1, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65a324b459e60405cebe9e34ee6b3496559cd217/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65a324b459e60405cebe9e34ee6b3496559cd217/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=65a324b459e60405cebe9e34ee6b3496559cd217", "patch": "@@ -783,6 +783,16 @@ See RS/6000 and PowerPC Options.\n -msim  -mmvme  -mads  -myellowknife  -memb  -msdata @gol\n -msdata=@var{opt}  -mvxworks  -G @var{num}  -pthread}\n \n+@emph{RX Options}\n+@gccoptlist{-m64bit-doubles  -m32bit-doubles  -mieee  -mno-ieee@gol\n+-mbig-endian-data -mlittle-endian-data @gol\n+-msmall-data @gol\n+-msim  -mno-sim@gol\n+-mas100-syntax -mno-as100-syntax@gol\n+-mrelax@gol\n+-mmax-constant-size=@gol\n+-mint-register=}\n+\n @emph{S/390 and zSeries Options}\n @gccoptlist{-mtune=@var{cpu-type}  -march=@var{cpu-type} @gol\n -mhard-float  -msoft-float  -mhard-dfp -mno-hard-dfp @gol\n@@ -9530,6 +9540,7 @@ platform.\n * picoChip Options::\n * PowerPC Options::\n * RS/6000 and PowerPC Options::\n+* RX Options::\n * S/390 and zSeries Options::\n * Score Options::\n * SH Options::\n@@ -10943,7 +10954,7 @@ These @samp{-m} options are defined for the DEC Alpha/VMS implementations:\n @table @gcctabopt\n @item -mvms-return-codes\n @opindex mvms-return-codes\n-Return VMS condition codes from main. The default is to return POSIX\n+Return VMS condition codes from main.  The default is to return POSIX\n style condition (e.g.@: error) codes.\n \n @item -mdebug-main=@var{prefix}\n@@ -15362,6 +15373,112 @@ This option sets flags for both the preprocessor and linker.\n \n @end table\n \n+@node RX Options\n+@subsection RX Options\n+@cindex RX Options\n+\n+These @option{-m} options are defined for RX implementations:\n+\n+@table @gcctabopt\n+@item -m64bit-doubles\n+@itemx -m32bit-doubles\n+@opindex m64bit-doubles\n+@opindex m32bit-doubles\n+Make the @code{double} data type be 64-bits (@option{-m64bit-doubles})\n+or 32-bits (@option{-m32bit-doubles}) in size.  The default is\n+@option{-m32bit-doubles}.  @emph{Note} the RX's hardware floating\n+point instructions are only used for 32-bit floating point values, and\n+then only if @option{-ffast-math} has been specified on the command\n+line.  This is because the RX FPU instructions do not properly support\n+denormal (or sub-normal) values.\n+\n+@item -mbig-endian-data\n+@itemx -mlittle-endian-data\n+@opindex mbig-endian-data\n+@opindex mlittle-endian-data\n+Store data (but not code) in the big-endian format.  The default is\n+@option{-mlittle-endian-data}, ie to store data in the little endian\n+format.\n+\n+@item -msmall-data-limit=@var{N}\n+@opindex msmall-data-limit\n+Specifies the maximum size in bytes of global and static variables\n+which can be placed into the small data area.  Using the small data\n+area can lead to smaller and faster code, but the size of area is\n+limited and it is up to the programmer to ensure that the area does\n+not overflow.  Also when the small data area is used one of the RX's\n+registers (@code{r13}) is reserved for use pointing to this area, so\n+it is no longer available for use by the compiler.  This could result\n+in slower and/or larger code if variables which once could have been\n+held in @code{r13} are now pushed onto the stack.\n+\n+Note, common variables (variables which have not been initialised) and\n+constants are not placed into the small data area as they are assigned\n+to other sections in the output executeable.\n+\n+The default value is zero, which disables this feature.  Note, this\n+feature is not enabled by default with higher optimization levels\n+(@option{-O2} etc) because of the potentially deterimental effects of\n+reserving register @code{r13}.  It is up to the programmer to\n+experiment and discover whether this feature is of benefit to their\n+program.\n+\n+@item -msim\n+@item -mno-sim\n+@opindex msim\n+@opindex mno-sim\n+Use the simulator runtime.  The default is to use the libgloss board\n+specific runtime.\n+\n+@item -mas100-syntax\n+@item -mno-as100-syntax\n+@opindex mas100-syntax\n+@opindex mno-as100-syntax\n+When generating assembler output use a syntax that is compatible with\n+Renesas's AS100 assembler.  This syntax can also be handled by the GAS\n+assembler but it has some restrictions so generating it is not the\n+default option.\n+\n+@item -mmax-constant-size=@var{N}\n+@opindex mmax-constant-size\n+Specifies the maxium size, in bytes, of a constant that can be used as\n+an operand in a RX instruction.  Although the RX instruction set does\n+allow consants of up to 4 bytes in length to be used in instructions,\n+a longer value equates to a longer instruction.  Thus in some\n+circumstances it can be beneficial to restrict the size of constants\n+that are used in instructions.  Constants that are too big are instead\n+placed into a constant pool and referenced via register indirection.\n+\n+The value @var{N} can be between 0 and 3.  A value of 0, the default,\n+means that constants of any size are allowed.\n+\n+@item -mrelax\n+@opindex mrelax\n+Enable linker relaxation.  Linker relaxation is a process whereby the\n+linker will attempt to reduce the size of a program by finding shorter\n+versions of various instructions.  Disabled by default.\n+\n+@item -mint-register=@var{N}\n+@opindex mint-register\n+Specify the number of registers to reserve for fast interrupt handler\n+functions.  The value @var{N} can be between 0 and 4.  A value of 1\n+means that register @code{r13} will be reserved for ther exclusive use\n+of fast interrupt handlers.  A value of 2 reserves @code{r13} and\n+@code{r12}.  A value of 3 reserves @code{r13}, @code{r12} and\n+@code{r11}, and a value of 4 reserves @code{r13} through @code{r10}.\n+A value of 0, the default, does not reserve any registers.\n+@end table\n+\n+@emph{Note:} The generic GCC command line @option{-ffixed-@var{reg}}\n+has special significance to the RX port when used with the\n+@code{interrupt} function attribute.  This attribute indicates a\n+function intended to process fast interrupts.  GCC will will ensure\n+that it only uses the registers @code{r10}, @code{r11}, @code{r12}\n+and/or @code{r13} and only provided that the normal use of the\n+corresponding registers have been restricted via the\n+@option{-ffixed-@var{reg}} or @option{-mint-register} command line\n+options.\n+\n @node S/390 and zSeries Options\n @subsection S/390 and zSeries Options\n @cindex S/390 and zSeries Options"}, {"sha": "dcfba921207a9aa25d48c51311da213224f372a1", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65a324b459e60405cebe9e34ee6b3496559cd217/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65a324b459e60405cebe9e34ee6b3496559cd217/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=65a324b459e60405cebe9e34ee6b3496559cd217", "patch": "@@ -2897,6 +2897,32 @@ A constant in the range of 0 to @minus{}255.\n \n @end table\n \n+@item RX---@file{config/rx/constraints.md}\n+@table @code\n+@item Q\n+An address which does not involve register indirect addressing or\n+pre/post increment/decrement addressing.\n+\n+@item Symbol\n+A symbol reference.\n+\n+@item Int08\n+A constant in the range @minus{}256 to 255, inclusive.\n+\n+@item Sint08\n+A constant in the range @minus{}128 to 127, inclusive.\n+\n+@item Sint16\n+A constant in the range @minus{}32768 to 32767, inclusive.\n+\n+@item Sint24\n+A constant in the range @minus{}8388608 to 8388607, inclusive.\n+\n+@item Uint04\n+A constant in the range 0 to 15, inclusive.\n+\n+@end table\n+\n @need 1000\n @item SPARC---@file{config/sparc/sparc.h}\n @table @code"}, {"sha": "ba86a08487e74e8af8ae2890bfb174636ecc335a", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 25, "deletions": 17, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65a324b459e60405cebe9e34ee6b3496559cd217/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65a324b459e60405cebe9e34ee6b3496559cd217/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=65a324b459e60405cebe9e34ee6b3496559cd217", "patch": "@@ -3529,7 +3529,7 @@ dynamically if their size exceeds @code{STACK_CHECK_MAX_VAR_SIZE} bytes.\n @defmac STACK_CHECK_BUILTIN\n A nonzero value if stack checking is done by the configuration files in a\n machine-dependent manner.  You should define this macro if stack checking\n-is require by the ABI of your machine or if you would like to do stack\n+is required by the ABI of your machine or if you would like to do stack\n checking in some more efficient way than the generic approach.  The default\n value of this macro is zero.\n @end defmac\n@@ -3788,7 +3788,7 @@ registers @code{regs_ever_live} and @code{call_used_regs}.\n \n If @code{ELIMINABLE_REGS} is defined, this macro will be not be used and\n need not be defined.  Otherwise, it must be defined even if\n-@code{TARGET_FRAME_POINTER_REQUIRED} is always return true; in that\n+@code{TARGET_FRAME_POINTER_REQUIRED} always returns true; in that\n case, you may set @var{depth-var} to anything.\n @end defmac\n \n@@ -4205,7 +4205,6 @@ on the stack.  The compiler knows how to track the amount of stack space\n used for arguments without any special help.\n @end defmac\n \n-\n @defmac FUNCTION_ARG_OFFSET (@var{mode}, @var{type})\n If defined, a C expression that is the number of bytes to add to the\n offset of the argument passed in memory.  This is needed for the SPU,\n@@ -5370,9 +5369,10 @@ post-address side-effect generation involving a register displacement.\n \n @defmac CONSTANT_ADDRESS_P (@var{x})\n A C expression that is 1 if the RTX @var{x} is a constant which\n-is a valid address.  On most machines, this can be defined as\n-@code{CONSTANT_P (@var{x})}, but a few machines are more restrictive\n-in which constant addresses are supported.\n+is a valid address.  On most machines the default definition of\n+@code{(CONSTANT_P (@var{x}) && GET_CODE (@var{x}) != CONST_DOUBLE)}\n+is acceptable, but a few machines are more restrictive as to which\n+constant addresses are supported. \n @end defmac\n \n @defmac CONSTANT_P (@var{x})\n@@ -6127,7 +6127,7 @@ this macro is defined, it should produce a nonzero value when\n @code{STRICT_ALIGNMENT} is nonzero.\n @end defmac\n \n-@defmac MOVE_RATIO\n+@defmac MOVE_RATIO (@var{speed})\n The threshold of number of scalar memory-to-memory move insns, @emph{below}\n which a sequence of insns should be generated instead of a\n string move insn or a library call.  Increasing the value will always\n@@ -6137,6 +6137,9 @@ Note that on machines where the corresponding move insn is a\n @code{define_expand} that emits a sequence of insns, this macro counts\n the number of such sequences.\n \n+The parameter @var{speed} is true if the code is currently being\n+optimized for speed rather than size.\n+\n If you don't define this, a reasonable default is used.\n @end defmac\n \n@@ -6152,12 +6155,15 @@ A C expression used by @code{move_by_pieces} to determine the largest unit\n a load or store used to copy memory is.  Defaults to @code{MOVE_MAX}.\n @end defmac\n \n-@defmac CLEAR_RATIO\n+@defmac CLEAR_RATIO (@var{speed})\n The threshold of number of scalar move insns, @emph{below} which a sequence\n of insns should be generated to clear memory instead of a string clear insn\n or a library call.  Increasing the value will always make code faster, but\n eventually incurs high cost in increased code size.\n \n+The parameter @var{speed} is true if the code is currently being\n+optimized for speed rather than size.\n+\n If you don't define this, a reasonable default is used.\n @end defmac\n \n@@ -6168,13 +6174,16 @@ will be used.  Defaults to 1 if @code{move_by_pieces_ninsns} returns less\n than @code{CLEAR_RATIO}.\n @end defmac\n \n-@defmac SET_RATIO\n+@defmac SET_RATIO (@var{speed})\n The threshold of number of scalar move insns, @emph{below} which a sequence\n of insns should be generated to set memory to a constant value, instead of\n a block set insn or a library call.  \n Increasing the value will always make code faster, but\n eventually incurs high cost in increased code size.\n \n+The parameter @var{speed} is true if the code is currently being\n+optimized for speed rather than size.\n+\n If you don't define this, it defaults to the value of @code{MOVE_RATIO}.\n @end defmac\n \n@@ -6189,7 +6198,7 @@ than @code{SET_RATIO}.\n \n @defmac STORE_BY_PIECES_P (@var{size}, @var{alignment})\n A C expression used to determine whether @code{store_by_pieces} will be\n-used to set a chunk of memory to a constant string value, or whether some \n+used to set a chunk of memory to a constant string value, or whether some\n other mechanism will be used.  Used by @code{__builtin_strcpy} when\n called with a constant source string.\n Defaults to 1 if @code{move_by_pieces_ninsns} returns less\n@@ -6255,7 +6264,7 @@ Define this macro if a non-short-circuit operation produced by\n @code{BRANCH_COST} is greater than or equal to the value 2.\n @end defmac\n \n-@deftypefn {Target Hook} bool TARGET_RTX_COSTS (rtx @var{x}, int @var{code}, int @var{outer_code}, int *@var{total})\n+@deftypefn {Target Hook} bool TARGET_RTX_COSTS (rtx @var{x}, int @var{code}, int @var{outer_code}, int *@var{total}, bool @var{speed})\n This target hook describes the relative costs of RTL expressions.\n \n The cost may depend on the precise form of the expression, which is\n@@ -6274,15 +6283,15 @@ necessary.  Traditionally, the default costs are @code{COSTS_N_INSNS (5)}\n for multiplications, @code{COSTS_N_INSNS (7)} for division and modulus\n operations, and @code{COSTS_N_INSNS (1)} for all other operations.\n \n-When optimizing for code size, i.e.@: when @code{optimize_size} is\n-nonzero, this target hook should be used to estimate the relative\n+When optimizing for code size, i.e.@: when @code{speed} is\n+false, this target hook should be used to estimate the relative\n size cost of an expression, again relative to @code{COSTS_N_INSNS}.\n \n The hook returns true when all subexpressions of @var{x} have been\n processed, and false when @code{rtx_cost} should recurse.\n @end deftypefn\n \n-@deftypefn {Target Hook} int TARGET_ADDRESS_COST (rtx @var{address})\n+@deftypefn {Target Hook} int TARGET_ADDRESS_COST (rtx @var{address}, bool @var{speed})\n This hook computes the cost of an addressing mode that contains\n @var{address}.  If not defined, the cost is computed from\n the @var{address} expression and the @code{TARGET_RTX_COST} hook.\n@@ -6384,7 +6393,7 @@ debug output to.  @var{verbose} is the verbose level provided by\n list of instructions that are ready to be scheduled.  @var{n_readyp} is\n a pointer to the number of elements in the ready list.  The scheduler\n reads the ready list in reverse order, starting with\n-@var{ready}[@var{*n_readyp}-1] and going to @var{ready}[0].  @var{clock}\n+@var{ready}[@var{*n_readyp} @minus{} 1] and going to @var{ready}[0].  @var{clock}\n is the timer tick of the scheduler.  You may modify the ready list and\n the number of ready insns.  The return value is the number of insns that\n can issue this cycle; normally this is just @code{issue_rate}.  See also\n@@ -9516,7 +9525,7 @@ attributes, or a copy of the list may be made if further changes are\n needed.\n @end deftypefn\n \n-@deftypefn {Target Hook} bool TARGET_FUNCTION_ATTRIBUTE_INLINABLE_P (tree @var{fndecl})\n+@deftypefn {Target Hook} bool TARGET_FUNCTION_ATTRIBUTE_INLINABLE_P (const_tree @var{fndecl})\n @cindex inlining\n This target hook returns @code{true} if it is ok to inline @var{fndecl}\n into the current function, despite its having target-specific\n@@ -10910,7 +10919,6 @@ to the stack.  Therefore, this hook should return true in general, but\n false for naked functions.  The default implementation always returns true.\n @end deftypefn\n \n-\n @deftypevr {Target Hook} {unsigned HOST_WIDE_INT} TARGET_CONST_ANCHOR\n On some architectures it can take multiple instructions to synthesize\n a constant.  If there is another constant already in a register that"}, {"sha": "08a7de5fa03851fa5a5a0b6b8cc7cc027b4413a8", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65a324b459e60405cebe9e34ee6b3496559cd217/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65a324b459e60405cebe9e34ee6b3496559cd217/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=65a324b459e60405cebe9e34ee6b3496559cd217", "patch": "@@ -1,3 +1,18 @@\n+2009-10-26  Nick Clifton  <nickc@redhat.com>\n+\n+\t* lib/target-supports.exp (check_profiling_available):\n+\tProfiling is not, currently, available for the RX port.\n+\t(check_effective_target_hard_float): Add support for RX\n+\ttarget.\n+\t* gcc.target/rx: New directory.\n+\t* gcc.target/rx/builtins.c: New test file.\n+\t* gcc.target/rx/interrupts.c: New test file.\n+\t* gcc.target/rx/rx-abi-function-tests.c: New test file.\n+\t* gcc.target/rx/zero-width-bitfield.c: New test file.\n+\t* gcc.target/rx/i272091.c: New test file.\n+\t* gcc.target/rx/packed-struct.c: New test file.\n+\t* gcc.target/rx/rx.exp: New file: Drives RX tests.\n+\t\n 2009-10-26  Andrew Pinski  <pinskia@gcc.gnu.org>\n \n \t* gcc.dg/lto/20091014-1_0.c: Replace -shared with -r -nostlib."}, {"sha": "07448024b44ce11ccb208ae20d506d0e050ed8be", "filename": "gcc/testsuite/gcc.target/rx/builtins.c", "status": "added", "additions": 159, "deletions": 0, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65a324b459e60405cebe9e34ee6b3496559cd217/gcc%2Ftestsuite%2Fgcc.target%2Frx%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65a324b459e60405cebe9e34ee6b3496559cd217/gcc%2Ftestsuite%2Fgcc.target%2Frx%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Frx%2Fbuiltins.c?ref=65a324b459e60405cebe9e34ee6b3496559cd217", "patch": "@@ -0,0 +1,159 @@\n+/* { dg-do run } */\n+/* { dg-options \"-fno-ipa-cp-clone\" } */\n+\n+/* Verify that the RX specific builtin functions work.  */\n+\n+/* IPA CP cloning is disabled because the constant propagation\n+   has no understanding of the saturation behaviour of the\n+   __builtin_rx_sat function and so it will optimize away the\n+   saturation addition test.  */\n+   \n+#include <stdlib.h>\n+#include <stdio.h>\n+\n+/* We need to prevent these functions from being inlined\n+   as otherwise gcc will attempt to optimize away their\n+   arguments and we need the operations on them in order\n+   to correctly set the psw flags.  */\n+\n+int saturate_add         (int, int)      __attribute__((__noinline__));\n+int subtract_with_borrow (int, int, int) __attribute__((__noinline__));\n+int exchange             (int, int)      __attribute__((__noinline__));\n+\n+int\n+half_word_swap (int arg)\n+{\n+  return __builtin_rx_revw (arg);\n+}\n+\n+int\n+saturate_add (int arg1, int arg2)\n+{\n+  arg1 += arg2;\n+  return __builtin_rx_sat (arg1);\n+}\n+\n+long\n+multiply_and_accumulate (long arg1, long arg2, long arg3)\n+{\n+  __builtin_rx_mvtaclo (0);\n+  __builtin_rx_mvtachi (0);\n+\n+  __builtin_rx_mullo (arg1, arg2);\n+  __builtin_rx_mulhi (arg1, arg2);\n+  __builtin_rx_maclo (arg1, arg3);\n+  __builtin_rx_machi (arg1, arg3);\n+\n+  __builtin_rx_racw (1);\n+  \n+  arg1 = __builtin_rx_mvfachi ();\n+  arg1 += __builtin_rx_mvfacmi ();\n+\n+  return arg1;\n+}\n+\n+int\n+rxround (float arg)\n+{\n+  return __builtin_rx_round (arg);\n+}\n+\n+/* #define DEBUG 1 */\n+\n+#ifdef DEBUG\n+#define CHECK_0ARG(func, result)\t\t\t\t\t\\\n+  if (func () != result)\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      printf (#func \" () fails: %x not %x\\n\", func (), result);\t\t\\\n+      abort ();\t\t\t\t\t\t\t\t\\\n+    }\n+\n+#define CHECK_1ARG(func, arg, result)\t\t\t\t\t\\\n+  if (func (arg) != result)\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      printf (#func \" (\" #arg \") fails: %x not %x\\n\", func (arg), result); \\\n+      abort ();\t\t\t\t\t\t\t\t\\\n+    }\n+\n+#define CHECK_2ARG(func, arg1, arg2, result)\t\t\t\t\\\n+  if (func (arg1, arg2) != result)\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      printf (#func \" (\" #arg1 \",\" #arg2 \") fails: %x not %x\\n\",\t\\\n+\t      func (arg1, arg2), result);\t\t\t\t\\\n+      abort ();\t\t\t\t\t\t\t\t\\\n+    }\n+\n+#define CHECK_3ARG(func, arg1, arg2, arg3, result)\t\t\t\\\n+  if (func (arg1, arg2, arg3) != result)\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      printf (#func \" (\" #arg1 \",\" #arg2 \",\" #arg3 \") fails: %x not %x\\n\",\t\\\n+\t      func (arg1, arg2, arg3), result);\t\t\t\t\\\n+      abort ();\t\t\t\t\t\t\t\t\\\n+    }\n+#else\n+#define CHECK_0ARG(func, result)\t\t\t\t\t\\\n+  if (func () != result)\t\t\t\t\t\t\\\n+    abort ();\n+\n+#define CHECK_1ARG(func, arg, result)\t\t\t\t\t\\\n+  if (func (arg) != result)\t\t\t\t\t\t\\\n+    abort ();\n+\n+#define CHECK_2ARG(func, arg1, arg2, result)\t\t\t\t\\\n+  if (func (arg1, arg2) != result)\t\t\t\t\t\\\n+    abort ();\n+\n+#define CHECK_3ARG(func, arg1, arg2, arg3, result)\t\t\t\\\n+  if (func (arg1, arg2, arg3) != result)\t\t\t\t\\\n+    abort ();\n+#endif\n+\n+int\n+main (void)\n+{\n+  CHECK_1ARG (half_word_swap, 0x12345678, 0x34127856);\n+  CHECK_2ARG (saturate_add, 0x80000000, 0x80000000, 0x80000000);\n+  CHECK_3ARG (multiply_and_accumulate, 0x111, 0x222, 0x333, 0x70007);\n+  CHECK_1ARG (rxround, 0.5, 1);\n+  return 0;\n+}\n+\n+/* The following builtins are compiled but\n+   not executed because they need OS support.  */\n+\n+void\n+rxbreak (void)\n+{\n+  __builtin_rx_brk ();\n+}\n+\n+void\n+interrupt (void)\n+{\n+  __builtin_rx_int (0x12);\n+}\n+\n+int\n+get_stack_pointer (void)\n+{\n+  return __builtin_rx_mvfc (2);\n+}\n+\n+void\n+set_stack_pointer (int value)\n+{\n+  __builtin_rx_mvtc (2, value);\n+  __builtin_rx_mvtc (2, 0x1234);\n+}\n+\n+void\n+wait (void)\n+{\n+  __builtin_rx_wait ();\n+}\n+\n+void\n+rmpa (int * multiplicand, int * multiplier, int num)\n+{\n+  __builtin_rx_rmpa ();\n+}"}, {"sha": "39da576326f9b125383b2e67cdda179422741306", "filename": "gcc/testsuite/gcc.target/rx/i272091.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65a324b459e60405cebe9e34ee6b3496559cd217/gcc%2Ftestsuite%2Fgcc.target%2Frx%2Fi272091.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65a324b459e60405cebe9e34ee6b3496559cd217/gcc%2Ftestsuite%2Fgcc.target%2Frx%2Fi272091.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Frx%2Fi272091.c?ref=65a324b459e60405cebe9e34ee6b3496559cd217", "patch": "@@ -0,0 +1,27 @@\n+/* { dg-do compile } */\r\n+/* { dg-options \"-msmall-data-limit=100\" } */\r\n+\r\n+double a=6.76,b=7.34,c=0.54;\r\n+double x_1= 45.46;\r\n+static double SD_1;\r\n+static double SD_init = 45.54;\r\n+double DD_1;\r\n+double DD_init=769.0;\r\n+\r\n+\r\n+int main()\r\n+{\r\n+   volatile double x,y,z;\r\n+   \r\n+   x = 56.76;\r\n+   y = 4.5645;\r\n+\r\n+   z = x + y;\r\n+   z = x - 4.65;\r\n+   z = 4.566 - x;\r\n+   z = x * y;\r\n+   b = 8;\r\n+   c = 34;\r\n+   return 0;\r\n+}\r\n+\r"}, {"sha": "910e870f11bb10ff309adab74ac94c5cf1ec6105", "filename": "gcc/testsuite/gcc.target/rx/interrupts.c", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65a324b459e60405cebe9e34ee6b3496559cd217/gcc%2Ftestsuite%2Fgcc.target%2Frx%2Finterrupts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65a324b459e60405cebe9e34ee6b3496559cd217/gcc%2Ftestsuite%2Fgcc.target%2Frx%2Finterrupts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Frx%2Finterrupts.c?ref=65a324b459e60405cebe9e34ee6b3496559cd217", "patch": "@@ -0,0 +1,58 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-mint-register=3\" } */\n+\n+/* Verify that the RX specific function attributes work.  */\n+\n+void interrupt (void) __attribute__((__interrupt__));\n+void exception (void) __attribute__((__exception__));\n+int naked (int) __attribute__((__naked__));\n+\n+int flag = 0;\n+\n+/* Fast interrupt handler.  Only uses registers marked as fixed\n+   by the -fixed-xxx gcc command line option.  Returns via RTFI.  */\n+\n+void\n+interrupt (void)\n+{\n+  flag = 1;\n+}\n+\n+/* Exception handler.  Must preserve any register it uses, even\n+   call clobbered ones.  Returns via RTE.  */\n+\n+void\n+exception (void)\n+{\n+  switch (flag)\n+    {\n+    case 0:\n+      flag = -1;\n+      break;\n+    case 1:\n+    case 2:\n+    case 4:\n+      flag = flag - 2;\n+      break;\n+    case 5:\n+    case 7:\n+    case 6:\n+      flag ^= 3;\n+      break;\n+    default:\n+      naked (flag * 2);\n+      break;\n+    }\n+}\n+\n+/* Naked function.  The programmer must supply the function's\n+   prologue and epilogue instructions.  */\n+\n+int\n+naked (int arg)\n+{\n+  flag = arg;\n+}\n+\n+/* { dg-final { scan-assembler \"rtfi\" } } */\n+/* { dg-final { scan-assembler \"rte\" } } */"}, {"sha": "8c2a4345b8297776a8c78c9609e82d2465cd98e7", "filename": "gcc/testsuite/gcc.target/rx/packed-struct.c", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65a324b459e60405cebe9e34ee6b3496559cd217/gcc%2Ftestsuite%2Fgcc.target%2Frx%2Fpacked-struct.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65a324b459e60405cebe9e34ee6b3496559cd217/gcc%2Ftestsuite%2Fgcc.target%2Frx%2Fpacked-struct.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Frx%2Fpacked-struct.c?ref=65a324b459e60405cebe9e34ee6b3496559cd217", "patch": "@@ -0,0 +1,55 @@\n+/* { dg-do compile } */\n+\n+struct unpacked\n+{\n+  int i;\n+  char c;\n+};\n+\n+#pragma pack(1)\n+\n+struct packed\n+{\n+  int i;\n+  char c;\n+};\n+\n+struct packed_contains_unpacked\n+{\n+  char c;\n+  struct unpacked uuuu;  /* This should generate an error message.  */\n+}; \t\t\t/* { dg-error \"unpacked structure/union inside a packed struct\" \"XFAILed until patch for generic GCC structure layout code is accepted\" { xfail rx-*-* } } */\n+\n+union contains_unpacked\n+{\n+  char c;\n+  struct unpacked uuuu;  /* This should not.  */\n+};\n+\n+struct packed_contains_packed\n+{\n+  char c;\n+  struct packed ppppp;   /* This should not.  */\n+};\n+\n+#pragma pack()\n+\n+struct unpacked_contains_packed\n+{\n+  char c;\n+  struct packed p;\n+};\n+\n+struct unpacked_contains_unpacked\n+{\n+  char c;\n+  struct unpacked u;\n+};\n+\n+\n+int s1 = sizeof (struct unpacked);\n+int s2 = sizeof (struct packed);\n+int s3 = sizeof (struct packed_contains_unpacked);\n+int s4 = sizeof (struct packed_contains_packed);\n+int s5 = sizeof (struct unpacked_contains_packed);\n+int s6 = sizeof (struct unpacked_contains_unpacked);"}, {"sha": "0c4ec3f6b05cc2ce96c7818ec774e9c043cf8385", "filename": "gcc/testsuite/gcc.target/rx/rx-abi-function-tests.c", "status": "added", "additions": 159, "deletions": 0, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65a324b459e60405cebe9e34ee6b3496559cd217/gcc%2Ftestsuite%2Fgcc.target%2Frx%2Frx-abi-function-tests.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65a324b459e60405cebe9e34ee6b3496559cd217/gcc%2Ftestsuite%2Fgcc.target%2Frx%2Frx-abi-function-tests.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Frx%2Frx-abi-function-tests.c?ref=65a324b459e60405cebe9e34ee6b3496559cd217", "patch": "@@ -0,0 +1,159 @@\n+/* { dg-do run } */\n+/* { dg-options \"-msim\" } */\n+/* Note: The -msim abiove is actually there to override the default\n+   options which include -ansi -pendantic and -Wlong-long...   */\n+\n+extern int printf (const char *, ...);\n+extern void exit (int);\n+extern void abort (void);\n+\n+extern signed long        _COM_CONVf32s (float);\n+extern unsigned long      _COM_CONVf32u (float);\n+extern float              _COM_CONV32sf (signed long);\n+extern float              _COM_CONV32uf (unsigned long);\n+extern float              _COM_ADDf (float, float);\n+extern float              _COM_SUBf (float, float);\n+extern float              _COM_MULf (float, float);\n+extern float              _COM_DIVf (float, float);\n+extern int                _COM_CMPLTf (float, float);\n+\n+extern long long          _COM_MUL64 (long long, long long);\n+extern signed long long   _COM_DIV64s (long long, long long);\n+extern unsigned long long _COM_DIV64u (unsigned long long, unsigned long long);\n+extern long long          _COM_SHLL64 (long long, int);\n+extern long long          _COM_SHLR64 (long long, int);\n+extern long long          _COM_SHAR64 (long long, int);\n+extern signed long long   _COM_CONVf64s (float);\n+extern unsigned long long _COM_CONVf64u (float);\n+extern signed long long   _COM_CONVd64s (double);\n+extern unsigned long long _COM_CONVd64u (double);\n+extern float              _COM_CONV64sf (signed long long);\n+extern float              _COM_CONV64uf (unsigned long long);\n+extern double             _COM_CONV64sd (signed long long);\n+extern double             _COM_CONV64ud (unsigned long long);\n+extern signed long long   _COM_MOD64s (long long, long long);\n+extern unsigned long long _COM_MOD64u (unsigned long long, unsigned long long);\n+extern int                _COM_CMPLT64s (long long, long long);\n+extern int                _COM_CMPLT64u (unsigned long long, unsigned long long);\n+extern int                _COM_CMPGT64s (long long, long long);\n+extern int                _COM_CMPGT64u (unsigned long long, unsigned long long);\n+extern int                _COM_CMPLE64s (long long, long long);\n+extern int                _COM_CMPLE64u (unsigned long long, unsigned long long);\n+extern int                _COM_CMPGE64s (long long, long long);\n+extern int                _COM_CMPGE64u (unsigned long long, unsigned long long);\n+extern int                _COM_CMPEQ64 (long long, long long);\n+extern int                _COM_CMPNE64 (long long, long long);\n+\n+extern double             _COM_ADDd (double, double);\n+extern double             _COM_SUBd (double, double);\n+extern double             _COM_MULd (double, double);\n+extern double             _COM_DIVd (double, double);\n+extern signed long        _COM_CONVd32s (double);\n+extern unsigned long      _COM_CONVd32u (double);\n+extern double             _COM_CONV32sd (signed long);\n+extern double             _COM_CONV32ud (unsigned long);\n+extern double             _COM_CONVfd (float);\n+extern float              _COM_CONVdf (double);\n+extern double             _COM_NEGd (double);\n+\n+\n+/* #define DEBUG 1 */\n+\n+#ifdef DEBUG\n+# define TEST1(func,arg1,result)\tif (func (arg1) != result) printf (\"fail: \" #func \" (\" #arg1 \") returns %x rather than \" #result \"\\n\", func (arg1))\n+# define TEST2(func,arg1,arg2,result)\tif (func (arg1, arg2) != result) printf (\"fail: \" #func \" (\" #arg1 \", \" #arg2 \") returns %x rather than \" #result \"\\n\", func (arg1, arg2))\n+# define TEST_CMP(func, low_arg, high_arg, lt_result, eq_result, gt_result)\t\\\n+  do\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      int res;\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      if ((res = func (low_arg, high_arg)) != lt_result)   printf (\"fail: \" #func \" (\" #low_arg \", \" #high_arg \") returns %d rather than %d\\n\", res, lt_result); \\\n+      if ((res = func (high_arg, low_arg)) != gt_result)   printf (\"fail: \" #func \" (\" #high_arg \", \" #low_arg \") returns %d rather than %d\\n\", res, gt_result); \\\n+      if ((res = func (low_arg, low_arg))  != eq_result)   printf (\"fail: \" #func \" (\" #low_arg \", \" #low_arg \") returns %d rather than %d\\n\", res, eq_result); \\\n+    } \\\n+  while (0)\n+#else\n+# define TEST1(func,arg1,result)\tif (func (arg1) != result) abort ()\n+# define TEST2(func,arg1,arg2,result)\tif (func (arg1, arg2) != result) abort ()\n+# define TEST_CMP(func,low,high,lt_res,eq_res,gt_res)\t\\\n+  if (   (func (low, high) != lt_res)\t\t\t\\\n+      || (func (high, low) != gt_res)\t\t\t\\\n+      || (func (low, low)  != eq_res))\t\t\t\\\n+    abort ();\n+#endif\n+\n+\n+int\n+main (void)\n+{\n+#ifdef DEBUG\n+  printf (\"Tests starting\\n\");\n+#endif\n+\n+  TEST1 (_COM_CONVf32s, -2.0f, -2);\n+  TEST1 (_COM_CONVf32u, -2.0f, (unsigned) -2);\n+  TEST1 (_COM_CONV32sf, -2, -2.0f);\n+  TEST1 (_COM_CONV32uf, 2, 2.0f);\n+  TEST2 (_COM_ADDf, 1.0f, 2.0f, 3.0f);\n+  TEST2 (_COM_SUBf, 3.0f, 2.0f, 1.0f);\n+  TEST2 (_COM_MULf, 2.0f, 3.0f, 6.0f);\n+  TEST2 (_COM_DIVf, 6.0f, 2.0f, 3.0f);\n+  TEST_CMP (_COM_CMPLTf, 1.0f, 2.0f, 1, 0, 0);\n+  TEST_CMP (_COM_CMPGTf, 1.0f, 2.0f, 0, 0, 1);\n+  TEST_CMP (_COM_CMPLEf, 1.0f, 2.0f, 1, 1, 0);\n+  TEST_CMP (_COM_CMPGEf, 1.0f, 2.0f, 0, 1, 1);\n+  TEST_CMP (_COM_CMPEQf, 1.0f, 2.0f, 0, 1, 0);\n+  TEST_CMP (_COM_CMPNEf, 1.0f, 2.0f, 1, 0, 1);\n+\n+\n+  TEST2 (_COM_MUL64, 2LL, 4LL, 8LL);\n+  TEST2 (_COM_DIV64s, 6LL, 3LL, 2LL);\n+  TEST2 (_COM_DIV64u, 6ULL, 3ULL, 2ULL);\n+  TEST2 (_COM_SHLL64, 6LL, 3, 48LL);\n+  TEST2 (_COM_SHLR64, 8LL, 2, 2LL);\n+  TEST2 (_COM_SHAR64, -1LL, 2, -1LL);  \n+  TEST1 (_COM_CONVf64s, -2.0f, -2LL);\n+  TEST1 (_COM_CONVf64u, 2.0f, 2ULL);\n+  TEST1 (_COM_CONVd64s, -2.0, -2LL);\n+  TEST1 (_COM_CONVd64u, 2.0, 2ULL);\n+  TEST1 (_COM_CONV64sf, -2LL, -2.0f);\n+  TEST1 (_COM_CONV64uf, 2ULL, 2.0f);\n+  TEST1 (_COM_CONV64sd, -2LL, -2.0);\n+  TEST1 (_COM_CONV64ud, 2ULL, 2.0);\n+  TEST2 (_COM_MOD64s, 4LL, 3LL, 1LL);\n+  TEST2 (_COM_MOD64u, 4ULL, 3ULL, 1ULL);\n+  TEST_CMP (_COM_CMPLT64s, 1LL, 2LL, 1, 0, 0);\n+  TEST_CMP (_COM_CMPLT64u, 1ULL, 2ULL, 1, 0, 0);\n+  TEST_CMP (_COM_CMPGT64s, 1LL, 2LL, 0, 0, 1);\n+  TEST_CMP (_COM_CMPGT64u, 1ULL, 2ULL, 0, 0, 1);\n+  TEST_CMP (_COM_CMPLE64s, 1LL, 2LL, 1, 1, 0);\n+  TEST_CMP (_COM_CMPLE64u, 1ULL, 2ULL, 1, 1, 0);\n+  TEST_CMP (_COM_CMPGE64s, 1LL, 2LL, 0, 1, 1);\n+  TEST_CMP (_COM_CMPGE64u, 1ULL, 2ULL, 0, 1, 1);\n+  TEST_CMP (_COM_CMPEQ64, 1LL, 2LL, 0, 1, 0);\n+  TEST_CMP (_COM_CMPNE64, 1LL, 2LL, 1, 0, 1);\n+\n+\n+  TEST2 (_COM_ADDd, 1.0, 2.0, 3.0);\n+  TEST2 (_COM_SUBd, 3.0, 2.0, 1.0);\n+  TEST2 (_COM_MULd, 2.0, 3.0, 6.0);\n+  TEST2 (_COM_DIVd, 6.0, 2.0, 3.0);\n+  TEST1 (_COM_CONVd32s, -2.0, -2);\n+  TEST1 (_COM_CONVd32u, -2.0, (unsigned) -2);\n+  TEST1 (_COM_CONV32sd, -2, -2.0);\n+  TEST1 (_COM_CONV32ud, 2, 2.0);\n+  TEST1 (_COM_CONVfd, 2.0f, 2.0);\n+  TEST1 (_COM_CONVdf, 2.0, 2.0f);\n+  TEST1 (_COM_NEGd, -2.0, 2.0);\n+  TEST_CMP (_COM_CMPLTd, 1.0, 2.0, 1, 0, 0);\n+  TEST_CMP (_COM_CMPGTd, 1.0, 2.0, 0, 0, 1);\n+  TEST_CMP (_COM_CMPLEd, 1.0, 2.0, 1, 1, 0);\n+  TEST_CMP (_COM_CMPGEd, 1.0, 2.0, 0, 1, 1);\n+  TEST_CMP (_COM_CMPEQd, 1.0, 2.0, 0, 1, 0);\n+  TEST_CMP (_COM_CMPNEd, 1.0, 2.0, 1, 0, 1);\n+  \n+#ifdef DEBUG\n+  printf (\"Tests finished\\n\");\n+#endif\n+  exit (0);\n+}"}, {"sha": "aa516e4555d8998e8b9d9081bf3eda180108a92b", "filename": "gcc/testsuite/gcc.target/rx/rx.exp", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65a324b459e60405cebe9e34ee6b3496559cd217/gcc%2Ftestsuite%2Fgcc.target%2Frx%2Frx.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65a324b459e60405cebe9e34ee6b3496559cd217/gcc%2Ftestsuite%2Fgcc.target%2Frx%2Frx.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Frx%2Frx.exp?ref=65a324b459e60405cebe9e34ee6b3496559cd217", "patch": "@@ -0,0 +1,43 @@\n+# Copyright (C) 2008 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3 of the License, or\n+# (at your option) any later version.\n+# \n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+# \n+# You should have received a copy of the GNU General Public License\n+# along with this program; if not, write to the Free Software\n+# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  \n+\n+# GCC testsuite that uses the `dg.exp' driver.\n+\n+# Exit immediately if this isn't the right target.\n+if { ![istarget rx-*-*] } then {\n+  return\n+}\n+\n+# Load support procs.\n+load_lib gcc-dg.exp\n+\n+# If a testcase doesn't have special options, use these.\n+global DEFAULT_CFLAGS\n+if ![info exists DEFAULT_CFLAGS] then {\n+    set DEFAULT_CFLAGS \"\"\n+}\n+\n+# Initialize `dg'.\n+dg-init\n+\n+# Find all tests\n+set tests [lsort [find $srcdir/$subdir *.\\[cS\\]]]\n+\n+# Main loop.\n+gcc-dg-runtest $tests $DEFAULT_CFLAGS\n+\n+# All done.\n+dg-finish"}, {"sha": "26cf5a2b542e2be0992f9697f639f0855440f4a2", "filename": "gcc/testsuite/gcc.target/rx/zero-width-bitfield.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65a324b459e60405cebe9e34ee6b3496559cd217/gcc%2Ftestsuite%2Fgcc.target%2Frx%2Fzero-width-bitfield.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65a324b459e60405cebe9e34ee6b3496559cd217/gcc%2Ftestsuite%2Fgcc.target%2Frx%2Fzero-width-bitfield.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Frx%2Fzero-width-bitfield.c?ref=65a324b459e60405cebe9e34ee6b3496559cd217", "patch": "@@ -0,0 +1,32 @@\n+/* { dg-do run { xfail rx-*-* } } */\n+/* { dg-skip-if \"skipped until patch for generic zero=width bit-field handling is accepted\" { rx-*-* } { \"*\" } { \"\" } } */\n+/* { dg-options \"-msim\" } */\n+/* Note: The -msim abiove is actually there to override the default\n+   options which do not allow the GCC extension of zero-width bitfields.  */\n+\n+extern void abort (void);\n+extern void exit  (int);\n+\n+struct S_zero\n+{\n+  int   f1: 4;\n+  int   f2: 0;\n+  short f3: 4;\n+} S_zero;\n+\n+struct S_norm\n+{\n+  int   f1: 4;\n+  short f3: 4;\n+} S_norm;\n+ \n+ \n+int\n+main (void)\n+{\n+  if (sizeof (S_zero) != 4 || sizeof (S_norm) != 8)\n+    abort ();\n+\n+  exit (0);\n+  return 0;\n+}"}, {"sha": "51a6a39738600afddd58790998bc0e64505927ca", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65a324b459e60405cebe9e34ee6b3496559cd217/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65a324b459e60405cebe9e34ee6b3496559cd217/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=65a324b459e60405cebe9e34ee6b3496559cd217", "patch": "@@ -501,6 +501,7 @@ proc check_profiling_available { test_what } {\n \t     || [istarget mep-*-elf]\n \t     || [istarget mips*-*-elf*]\n \t     || [istarget moxie-*-elf*]\n+\t     || [istarget rx-*-*]\t\n \t     || [istarget xstormy16-*]\n \t     || [istarget xtensa*-*-elf]\n \t     || [istarget *-*-rtems*]\n@@ -686,6 +687,18 @@ proc check_effective_target_hard_float { } {\n \t}]\n     }\n \n+    # This proc is actually checking the availabilty of FPU\n+    # support for doubles, so on the RX we must fail if the\n+    # 64-bit double multilib has been selected.\n+    if { [istarget rx-*-*] } {\n+\treturn 0\n+\t# return [check_no_compiler_messages hard_float assembly {\n+\t\t#if defined __RX_64_BIT_DOUBLES__\n+\t\t#error FOO\n+\t\t#endif\n+\t# }]\n+    }\n+\n     # The generic test equates hard_float with \"no call for adding doubles\".\n     return [check_no_messages_and_pattern hard_float \"!\\\\(call\" rtl-expand {\n \tdouble a (double b, double c) { return b + c; }\n@@ -2505,8 +2518,8 @@ proc check_effective_target_vect_short_mult { } {\n \tif { [istarget ia64-*-*]\n \t     || [istarget spu-*-*]\n \t     || [istarget i?86-*-*]\n-\t     || [istarget x86_64-*-*] \n-             || [istarget powerpc*-*-*] \n+\t     || [istarget x86_64-*-*]\n+             || [istarget powerpc*-*-*]\n              || [check_effective_target_arm32] } {\n \t   set et_vect_short_mult_saved 1\n \t}\n@@ -2646,7 +2659,7 @@ proc check_effective_target_section_anchors { } {\n         verbose \"check_effective_target_section_anchors: using cached result\" 2\n     } else {\n         set et_section_anchors_saved 0\n-        if { [istarget powerpc*-*-*] \n+        if { [istarget powerpc*-*-*]\n \t      || [istarget arm*-*-*] } {\n            set et_section_anchors_saved 1\n         }"}, {"sha": "2db5d2901c8bef712caa9196e5853efc1f030298", "filename": "libgcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65a324b459e60405cebe9e34ee6b3496559cd217/libgcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65a324b459e60405cebe9e34ee6b3496559cd217/libgcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FChangeLog?ref=65a324b459e60405cebe9e34ee6b3496559cd217", "patch": "@@ -1,3 +1,14 @@\n+2009-10-26  Nick Clifton  <nickc@redhat.com>\n+\n+\t* config.host: Add support for RX target.\n+\t* config/rx: New directory.\n+\t* config/rx/rx-abi-functions.c: New file. Supplementary\n+\tfunctions for libgcc to support the RX ABI.\n+\t* config/rx/rx-abi.h: New file.  Supplementary header file for\n+\tlibgcc RX ABI functions.\n+\t* config/rx/t-rx: New file: Makefile fragment for building\n+\tlibgcc for the RX.\n+\n 2009-10-09  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* config/i386/32/sfp-machine.h (__FP_FRAC_SUB_4): Change operand"}, {"sha": "f0861159adc0142f1966de339d07b47f40046642", "filename": "libgcc/config.host", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65a324b459e60405cebe9e34ee6b3496559cd217/libgcc%2Fconfig.host", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65a324b459e60405cebe9e34ee6b3496559cd217/libgcc%2Fconfig.host", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig.host?ref=65a324b459e60405cebe9e34ee6b3496559cd217", "patch": "@@ -482,6 +482,10 @@ rs6000-ibm-aix5.1.* | powerpc-ibm-aix5.1.*)\n \t;;\n rs6000-ibm-aix[56789].* | powerpc-ibm-aix[56789].*)\n \t;;\n+rx-*-elf)\n+\textra_parts=\"crtbegin.o crtend.o\"\n+\ttmake_file=\"rx/t-rx\"\n+\t;;\n s390-*-linux*)\n \ttmake_file=\"${tmake_file} s390/t-crtstuff s390/t-linux s390/32/t-floattodi\"\n \t;;"}, {"sha": "10dd9530d6b004186f12837812f1f263d8634611", "filename": "libgcc/config/rx/rx-abi-functions.c", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65a324b459e60405cebe9e34ee6b3496559cd217/libgcc%2Fconfig%2Frx%2Frx-abi-functions.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65a324b459e60405cebe9e34ee6b3496559cd217/libgcc%2Fconfig%2Frx%2Frx-abi-functions.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Frx%2Frx-abi-functions.c?ref=65a324b459e60405cebe9e34ee6b3496559cd217", "patch": "@@ -0,0 +1,90 @@\n+/* RX C ABI functions\n+   Copyright (C) 2009 Free Software Foundation, Inc.\n+   Contributed by Red Hat.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   GCC is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+\n+/* The RX C ABI includes the specification of a set of compiler support\n+   functions.  Libgcc2 includes some of them, although the names have to\n+   be changed (see rx-abi.h), and the rest are defined here.\n+\n+   FIXME: Given that FINE_GRAINED_LIBRARIES is defined we ought to consider\n+   compiling this file multiple times with one function per iteration being\n+   compiled.  */\n+\n+#ifdef __RX_64BIT_DOUBLES__\n+\n+int _COM_CMPLTd (double a, double b) { return __ltdf2 (a, b) == -1; }\n+int _COM_CMPGTd (double a, double b) { return __gtdf2 (a, b) == 1; }\n+int _COM_CMPLEd (double a, double b) { return __ledf2 (a, b) != 1; }\n+int _COM_CMPGEd (double a, double b) { return __gedf2 (a, b) != -1; }\n+int _COM_CMPEQd (double a, double b) { return __eqdf2 (a, b) == 0; }\n+int _COM_CMPNEd (double a, double b) { return __nedf2 (a, b) != 0; }\n+\n+int _COM_CMPLTf (double, double) __attribute__ ((weak, alias (\"_COM_CMPLTd\")));\n+int _COM_CMPGTf (double, double) __attribute__ ((weak, alias (\"_COM_CMPGTd\")));\n+int _COM_CMPLEf (double, double) __attribute__ ((weak, alias (\"_COM_CMPLEd\")));\n+int _COM_CMPGEf (double, double) __attribute__ ((weak, alias (\"_COM_CMPGEd\")));\n+int _COM_CMPEQf (double, double) __attribute__ ((weak, alias (\"_COM_CMPEQd\")));\n+int _COM_CMPNEf (double, double) __attribute__ ((weak, alias (\"_COM_CMPNEd\")));\n+\n+#else /* 32-bit doubles.  */\n+\n+double _COM_CONVfd (float a) { return a; }\n+float  _COM_CONVdf (double a) { return a; }\n+\n+int _COM_CMPLTd (double a, double b) __attribute__ ((weak, alias (\"_COM_CMPLTf\")));\n+int _COM_CMPGTd (double a, double b) __attribute__ ((weak, alias (\"_COM_CMPGTf\")));\n+int _COM_CMPLEd (double a, double b) __attribute__ ((weak, alias (\"_COM_CMPLEf\")));\n+int _COM_CMPGEd (double a, double b) __attribute__ ((weak, alias (\"_COM_CMPGEf\")));\n+int _COM_CMPEQd (double a, double b) __attribute__ ((weak, alias (\"_COM_CMPEQf\")));\n+int _COM_CMPNEd (double a, double b) __attribute__ ((weak, alias (\"_COM_CMPNEf\")));\n+\n+signed long long   _COM_CONVd64s (double a) { return (signed long long) a; }\n+unsigned long long _COM_CONVd64u (double a)  { return (unsigned long long) a; }\n+\n+int _COM_CMPLTf (float a, float b) { return __ltsf2 (a, b) == -1; }\n+int _COM_CMPGTf (float a, float b) { return __gtsf2 (a, b) == 1; }\n+int _COM_CMPLEf (float a, float b) { return __lesf2 (a, b) != 1; }\n+int _COM_CMPGEf (float a, float b) { return __gesf2 (a, b) != -1; }\n+int _COM_CMPEQf (float a, float b) { return __eqsf2 (a, b) == 0; }\n+int _COM_CMPNEf (float a, float b) { return __nesf2 (a, b) != 0; }\n+\n+#endif /* 64-bit vs 32-bit doubles.  */\n+\n+double _COM_CONV64sd (signed long long a)   { return (double) a; }\n+double _COM_CONV64ud (unsigned long long a) { return (double) a; }\n+\n+extern int __cmpdi2 (long long, long long);\n+extern int __ucmpdi2 (long long, long long);\n+\n+int _COM_CMPLT64s (long long a, long long b) { return __cmpdi2 (a, b)  == 0; }\n+int _COM_CMPLT64u (long long a, long long b) { return __ucmpdi2 (a, b) == 0; }\n+int _COM_CMPGT64s (long long a, long long b) { return __cmpdi2 (a, b)  == 2; }\n+int _COM_CMPGT64u (long long a, long long b) { return __ucmpdi2 (a, b) == 2; }\n+int _COM_CMPLE64s (long long a, long long b) { return __cmpdi2 (a, b)  != 2; }\n+int _COM_CMPLE64u (long long a, long long b) { return __ucmpdi2 (a, b) != 2; }\n+int _COM_CMPGE64s (long long a, long long b) { return __cmpdi2 (a, b)  != 0; }\n+int _COM_CMPGE64u (long long a, long long b) { return __ucmpdi2 (a, b) != 0; }\n+int _COM_CMPEQ64  (long long a, long long b) { return __cmpdi2 (a, b)  == 1; }\n+int _COM_CMPNE64  (long long a, long long b) { return __cmpdi2 (a, b)  != 1; }\n+"}, {"sha": "8a0bbdcd82c8c1c8139252cd8af76598987b4716", "filename": "libgcc/config/rx/rx-abi.h", "status": "added", "additions": 235, "deletions": 0, "changes": 235, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65a324b459e60405cebe9e34ee6b3496559cd217/libgcc%2Fconfig%2Frx%2Frx-abi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65a324b459e60405cebe9e34ee6b3496559cd217/libgcc%2Fconfig%2Frx%2Frx-abi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Frx%2Frx-abi.h?ref=65a324b459e60405cebe9e34ee6b3496559cd217", "patch": "@@ -0,0 +1,235 @@\n+/* Header file for RX ABI versions of libgcc functions.\n+   Copyright (C) 2009\n+   Free Software Foundation, Inc.\n+   Contributed by Red Hat.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 3, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   Under Section 7 of GPL version 3, you are granted additional\n+   permissions described in the GCC Runtime Library Exception, version\n+   3.1, as published by the Free Software Foundation.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+/* Make __COM_<RX_NAME> an alias for __<GCC_NAME>.  */\n+#define RENAME_LIBRARY(GCC_NAME, RX_NAME)\t\t\\\n+  __asm__ (\".globl\\t__COM_\" #RX_NAME \"\\n\"\t\t\\\n+\t   \".set\\t__COM_\" #RX_NAME \", ___\" #GCC_NAME \"\\n\");\n+\n+\n+/* The long-long aliases...  */\n+\n+#ifdef L_muldi3\n+#define DECLARE_LIBRARY_RENAMES RENAME_LIBRARY (muldi3, MUL64)\n+#endif\n+\n+#ifdef L_divdi3\n+#define DECLARE_LIBRARY_RENAMES RENAME_LIBRARY (divdi3, DIV64s)\n+#endif\n+\n+#ifdef L_udivdi3\n+#define DECLARE_LIBRARY_RENAMES RENAME_LIBRARY (udivdi3, DIV64u)\n+#endif\n+\n+#ifdef L_ashldi3\n+#define DECLARE_LIBRARY_RENAMES RENAME_LIBRARY (ashldi3, SHLL64)\n+#endif\n+\n+#ifdef L_lshrdi3\n+#define DECLARE_LIBRARY_RENAMES RENAME_LIBRARY (lshrdi3, SHLR64)\n+#endif\n+\n+#ifdef L_ashrdi3\n+#define DECLARE_LIBRARY_RENAMES RENAME_LIBRARY (ashrdi3, SHAR64)\n+#endif\n+\n+#ifdef L_fixsfdi\n+#define DECLARE_LIBRARY_RENAMES RENAME_LIBRARY (fixsfdi, CONVf64s)\n+#endif\n+\n+#ifdef L_fixunssfdi\n+#define DECLARE_LIBRARY_RENAMES RENAME_LIBRARY (fixunssfdi, CONVf64u)\n+#endif\n+\n+#ifdef L_floatdisf\n+#define DECLARE_LIBRARY_RENAMES RENAME_LIBRARY (floatdisf, CONV64sf)\n+#endif\n+\n+#ifdef L_floatundisf\n+#define DECLARE_LIBRARY_RENAMES RENAME_LIBRARY (floatundisf, CONV64uf)\n+#endif\n+\n+#ifdef L_moddi3\n+#define DECLARE_LIBRARY_RENAMES RENAME_LIBRARY (moddi3, MOD64s)\n+#endif\n+\n+#ifdef L_umoddi3\n+#define DECLARE_LIBRARY_RENAMES RENAME_LIBRARY (umoddi3, MOD64u)\n+#endif\n+\n+\n+#ifdef L_si_to_sf\n+#define DECLARE_LIBRARY_RENAMES RENAME_LIBRARY (floatsisf, CONV32sf)\n+#endif\n+\n+#ifdef L_usi_to_sf\n+#define DECLARE_LIBRARY_RENAMES RENAME_LIBRARY (floatunsisf, CONV32uf)\n+#endif\n+\n+\n+\n+#ifdef __RX_64BIT_DOUBLES__\n+\n+/* Float (32-bit) aliases...  */\n+\n+#ifdef L_sf_to_si\n+#define DECLARE_LIBRARY_RENAMES RENAME_LIBRARY (fixsfsi, CONVf32s)\n+#endif\n+\n+#ifdef L_fixunssfsi\n+#define DECLARE_LIBRARY_RENAMES RENAME_LIBRARY (fixunssfsi, CONVf32u)\n+#endif\n+\n+#ifdef L_addsub_sf\n+#define DECLARE_LIBRARY_RENAMES \\\n+  RENAME_LIBRARY (addsf3, ADDf) \\\n+  RENAME_LIBRARY (subsf3, SUBf)\n+#endif\n+\n+#ifdef L_mul_sf\n+#define DECLARE_LIBRARY_RENAMES RENAME_LIBRARY (mulsf3, MULf)\n+#endif\n+\n+#ifdef L_div_sf\n+#define DECLARE_LIBRARY_RENAMES RENAME_LIBRARY (divsf3, DIVf)\n+#endif\n+\n+/* Double (64-bit) aliases...  */\n+\n+#ifdef L_addsub_df\n+#define DECLARE_LIBRARY_RENAMES \\\n+  RENAME_LIBRARY (adddf3, ADDd) \\\n+  RENAME_LIBRARY (subdf3, SUBd)\n+#endif\n+\n+#ifdef L_mul_df\n+#define DECLARE_LIBRARY_RENAMES RENAME_LIBRARY (muldf3, MULd)\n+#endif\n+\n+#ifdef L_div_df\n+#define DECLARE_LIBRARY_RENAMES RENAME_LIBRARY (divdf3, DIVd)\n+#endif\n+\n+#ifdef L_fixdfdi\n+#define DECLARE_LIBRARY_RENAMES RENAME_LIBRARY (fixdfdi, CONVd64s)\n+#endif\n+\n+#ifdef L_fixunsdfdi\n+#define DECLARE_LIBRARY_RENAMES RENAME_LIBRARY (fixunsdfdi, CONVd64u)\n+#endif\n+\n+#ifdef L_floatdidf\n+#define DECLARE_LIBRARY_RENAMES RENAME_LIBRARY (floatdisf, CONV64sd)\n+#endif\n+\n+#ifdef L_floatundidf\n+#define DECLARE_LIBRARY_RENAMES RENAME_LIBRARY (floatdisf, CONV64ud)\n+#endif\n+\n+#ifdef L_df_to_si\n+#define DECLARE_LIBRARY_RENAMES RENAME_LIBRARY (fixdfsi, CONVd32s)\n+#endif\n+\n+#ifdef L_fixunsdfsi\n+#define DECLARE_LIBRARY_RENAMES RENAME_LIBRARY (fixunsdfsi, CONVd32u)\n+#endif\n+\n+#ifdef L_si_to_df\n+#define DECLARE_LIBRARY_RENAMES RENAME_LIBRARY (floatsidf, CONV32sd)\n+#endif\n+\n+#ifdef L_usi_to_df\n+#define DECLARE_LIBRARY_RENAMES RENAME_LIBRARY (floatunsidf, CONV32ud)\n+#endif\n+\n+#ifdef L_sf_to_df\n+#define DECLARE_LIBRARY_RENAMES RENAME_LIBRARY (extendsfdf2, CONVfd)\n+#endif\n+\n+#ifdef L_df_to_sf\n+#define DECLARE_LIBRARY_RENAMES RENAME_LIBRARY (truncdfsf2, CONVdf)\n+#endif\n+\n+#ifdef L_negate_df\n+#define DECLARE_LIBRARY_RENAMES RENAME_LIBRARY (negdf2, NEGd)\n+#endif\n+\n+/* The 64-bit comparison functions do not have aliases because libgcc2\n+   does not provide them.  Instead they have to be supplied in\n+   rx-abi-functions.c.  */\n+\n+\n+#else /* 32-bit doubles.  */\n+\n+\n+#ifdef L_addsub_sf\n+#define DECLARE_LIBRARY_RENAMES \\\n+  RENAME_LIBRARY (addsf3, ADDd) \\\n+  RENAME_LIBRARY (subsf3, SUBd) \\\n+  RENAME_LIBRARY (addsf3, ADDf) \\\n+  RENAME_LIBRARY (subsf3, SUBf)\n+#endif\n+\n+#ifdef L_mul_sf\n+#define DECLARE_LIBRARY_RENAMES \\\n+  RENAME_LIBRARY (mulsf3, MULd) \\\n+  RENAME_LIBRARY (mulsf3, MULf)\n+#endif\n+\n+#ifdef L_div_sf\n+#define DECLARE_LIBRARY_RENAMES \\\n+  RENAME_LIBRARY (divsf3, DIVd) \\\n+  RENAME_LIBRARY (divsf3, DIVf)\n+#endif\n+\n+#ifdef L_sf_to_si\n+#define DECLARE_LIBRARY_RENAMES \\\n+  RENAME_LIBRARY (fixsfsi, CONVd32s) \\\n+  RENAME_LIBRARY (fixsfsi, CONVf32s)\n+#endif\n+\n+#ifdef L_fixunssfsi\n+#define DECLARE_LIBRARY_RENAMES \\\n+  RENAME_LIBRARY (fixunssfsi, CONVd32u) \\\n+  RENAME_LIBRARY (fixunssfsi, CONVf32u)\n+#endif\n+\n+#ifdef L_si_to_sf\n+#define DECLARE_LIBRARY_RENAMES \\\n+  RENAME_LIBRARY (floatsisf, CONV32sd) \\\n+  RENAME_LIBRARY (floatsisf, CONV32sf)\n+#endif\n+\n+#ifdef L_usi_to_sf\n+#define DECLARE_LIBRARY_RENAMES \\\n+  RENAME_LIBRARY (floatunsisf, CONV32ud) \\\n+  RENAME_LIBRARY (floatunsisf, CONV32uf)\n+#endif\n+\n+#ifdef L_negate_sf\n+#define DECLARE_LIBRARY_RENAMES RENAME_LIBRARY (negsf2, NEGd)\n+#endif\n+\n+#endif /* 64-bit vs 32-bit doubles.  */"}, {"sha": "1e66af0c8d38556302148a9f310c279c797e0886", "filename": "libgcc/config/rx/t-rx", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65a324b459e60405cebe9e34ee6b3496559cd217/libgcc%2Fconfig%2Frx%2Ft-rx", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65a324b459e60405cebe9e34ee6b3496559cd217/libgcc%2Fconfig%2Frx%2Ft-rx", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Frx%2Ft-rx?ref=65a324b459e60405cebe9e34ee6b3496559cd217", "patch": "@@ -0,0 +1,44 @@\n+# Makefile fragment for building LIBGCC for the Renesas RX target.\n+# Copyright (C) 2008, 2009 Free Software Foundation, Inc.\n+# Contributed by Red Hat.\n+#\n+# This file is part of GCC.\n+#\n+# GCC is free software; you can redistribute it and/or modify it\n+# under the terms of the GNU General Public License as published\n+# by the Free Software Foundation; either version 3, or (at your\n+# option) any later version.\n+#\n+# GCC is distributed in the hope that it will be useful, but\n+# WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.   See\n+# the GNU General Public License for more details.\n+#\n+# You should have received a copy of the  GNU General Public\n+# License along with GCC; see the file COPYING3.  If not see\n+# <http://www.gnu.org/licenses/>.\n+\n+\n+# Add functions required by the RX ABI which are not part of\n+# the normal libgcc sources:\n+\n+LIB2ADD = $(srcdir)/config/rx/rx-abi-functions.c\n+\n+\n+# We need special handling of the floating point conversion\n+# routines, to allow for the varying size of a double:\n+\n+FPBIT = fp-bit.c\n+$(gcc_objdir)/fp-bit.c: $(gcc_srcdir)/config/fp-bit.c\n+\techo '#define FLOAT'\t\t     > $@\n+\techo '#ifndef __RX_64BIT_DOUBLES__' >> $@\n+\techo '#define DF SF'\t\t    >> $@\n+\techo '#define FLOAT_ONLY'\t    >> $@\n+\techo '#endif' \t\t\t    >> $@\n+\tcat $(gcc_srcdir)/config/fp-bit.c   >> $@\n+\n+DPBIT = dp-bit.c\n+$(gcc_objdir)/dp-bit.c: $(gcc_srcdir)/config/fp-bit.c\n+\techo '#ifdef __RX_64BIT_DOUBLES__'   > $@\n+\tcat $(gcc_srcdir)/config/fp-bit.c   >> $@\n+\techo '#endif'\t\t      \t    >> $@"}]}