{"sha": "9a775e9df5f72a8a9627fca8d412361562c8186a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWE3NzVlOWRmNWY3MmE4YTk2MjdmY2E4ZDQxMjM2MTU2MmM4MTg2YQ==", "commit": {"author": {"name": "Max Filippov", "email": "jcmvbkbc@gmail.com", "date": "2018-06-19T18:26:07Z"}, "committer": {"name": "Max Filippov", "email": "jcmvbkbc@gcc.gnu.org", "date": "2018-06-19T18:26:07Z"}, "message": "xtensa: fix PR target/65416\n\nThe issue is caused by reordering of stack pointer update after stack\nspace allocation with instructions that write to the allocated stack\nspace. In windowed ABI register spill area for the previous call frame\nis located just below the stack pointer and may be reloaded back into\nthe register file on movsp.\nImplement allocate_stack pattern for windowed ABI configuration and\ninsert an instruction that prevents reordering of frame memory access\nand stack pointer update.\n\ngcc/\n2018-06-19  Max Filippov  <jcmvbkbc@gmail.com>\n\n\t* config/xtensa/xtensa.md (UNSPEC_FRAME_BLOCKAGE): New unspec\n\tconstant.\n\t(allocate_stack, frame_blockage, *frame_blockage): New patterns.\n\nFrom-SVN: r261755", "tree": {"sha": "4479ffdb6075a786a8317fd3f4c48fdaa7003797", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4479ffdb6075a786a8317fd3f4c48fdaa7003797"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9a775e9df5f72a8a9627fca8d412361562c8186a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a775e9df5f72a8a9627fca8d412361562c8186a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9a775e9df5f72a8a9627fca8d412361562c8186a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a775e9df5f72a8a9627fca8d412361562c8186a/comments", "author": {"login": "jcmvbkbc", "id": 166731, "node_id": "MDQ6VXNlcjE2NjczMQ==", "avatar_url": "https://avatars.githubusercontent.com/u/166731?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jcmvbkbc", "html_url": "https://github.com/jcmvbkbc", "followers_url": "https://api.github.com/users/jcmvbkbc/followers", "following_url": "https://api.github.com/users/jcmvbkbc/following{/other_user}", "gists_url": "https://api.github.com/users/jcmvbkbc/gists{/gist_id}", "starred_url": "https://api.github.com/users/jcmvbkbc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jcmvbkbc/subscriptions", "organizations_url": "https://api.github.com/users/jcmvbkbc/orgs", "repos_url": "https://api.github.com/users/jcmvbkbc/repos", "events_url": "https://api.github.com/users/jcmvbkbc/events{/privacy}", "received_events_url": "https://api.github.com/users/jcmvbkbc/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5f21ea6739d9dae27a1c6ffe94ea28792f02124a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f21ea6739d9dae27a1c6ffe94ea28792f02124a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5f21ea6739d9dae27a1c6ffe94ea28792f02124a"}], "stats": {"total": 52, "additions": 52, "deletions": 0}, "files": [{"sha": "7e93801049cd6c2e49d45bc084f2267e57996fe7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a775e9df5f72a8a9627fca8d412361562c8186a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a775e9df5f72a8a9627fca8d412361562c8186a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9a775e9df5f72a8a9627fca8d412361562c8186a", "patch": "@@ -1,3 +1,9 @@\n+2018-06-19  Max Filippov  <jcmvbkbc@gmail.com>\n+\n+\t* config/xtensa/xtensa.md (UNSPEC_FRAME_BLOCKAGE): New unspec\n+\tconstant.\n+\t(allocate_stack, frame_blockage, *frame_blockage): New patterns.\n+\n 2018-06-19  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* tree.c (find_decls_types_r): Remove all non-VAR_DECLs from"}, {"sha": "209f839cfb0f929d68469bb35dc5f5e5a9a8728c", "filename": "gcc/config/xtensa/xtensa.md", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a775e9df5f72a8a9627fca8d412361562c8186a/gcc%2Fconfig%2Fxtensa%2Fxtensa.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a775e9df5f72a8a9627fca8d412361562c8186a/gcc%2Fconfig%2Fxtensa%2Fxtensa.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa.md?ref=9a775e9df5f72a8a9627fca8d412361562c8186a", "patch": "@@ -38,6 +38,7 @@\n   (UNSPEC_MEMW\t\t11)\n   (UNSPEC_LSETUP_START  12)\n   (UNSPEC_LSETUP_END    13)\n+  (UNSPEC_FRAME_BLOCKAGE 14)\n \n   (UNSPECV_SET_FP\t1)\n   (UNSPECV_ENTRY\t2)\n@@ -1676,6 +1677,32 @@\n \f\n ;; Miscellaneous instructions.\n \n+;; In windowed ABI stack pointer adjustment must happen before any access\n+;; to the space allocated on stack is allowed, otherwise register spill\n+;; area may be clobbered.  That's what frame blockage is supposed to enforce.\n+\n+(define_expand \"allocate_stack\"\n+  [(set (match_operand 0 \"nonimmed_operand\")\n+        (minus (reg A1_REG) (match_operand 1 \"add_operand\")))\n+   (set (reg A1_REG)\n+        (minus (reg A1_REG) (match_dup 1)))]\n+  \"TARGET_WINDOWED_ABI\"\n+{\n+  if (CONST_INT_P (operands[1]))\n+    {\n+      rtx neg_op0 = GEN_INT (-INTVAL (operands[1]));\n+      emit_insn (gen_addsi3 (stack_pointer_rtx, stack_pointer_rtx, neg_op0));\n+    }\n+  else\n+    {\n+      emit_insn (gen_subsi3 (stack_pointer_rtx, stack_pointer_rtx,\n+\t\t\t     operands[1]));\n+    }\n+  emit_move_insn (operands[0], virtual_stack_dynamic_rtx);\n+  emit_insn (gen_frame_blockage ());\n+  DONE;\n+})\n+\n (define_expand \"prologue\"\n   [(const_int 0)]\n   \"\"\n@@ -1767,6 +1794,25 @@\n   [(set_attr \"length\" \"0\")\n    (set_attr \"type\" \"nop\")])\n \n+;; Do not schedule instructions accessing memory before this point.\n+\n+(define_expand \"frame_blockage\"\n+  [(set (match_dup 0)\n+        (unspec:BLK [(match_dup 1)] UNSPEC_FRAME_BLOCKAGE))]\n+  \"\"\n+{\n+  operands[0] = gen_rtx_MEM (BLKmode, gen_rtx_SCRATCH (Pmode));\n+  MEM_VOLATILE_P (operands[0]) = 1;\n+  operands[1] = stack_pointer_rtx;\n+})\n+\n+(define_insn \"*frame_blockage\"\n+  [(set (match_operand:BLK 0 \"\" \"\")\n+        (unspec:BLK [(match_operand:SI 1 \"\" \"\")] UNSPEC_FRAME_BLOCKAGE))]\n+  \"\"\n+  \"\"\n+  [(set_attr \"length\" \"0\")])\n+\n (define_insn \"trap\"\n   [(trap_if (const_int 1) (const_int 0))]\n   \"\""}]}