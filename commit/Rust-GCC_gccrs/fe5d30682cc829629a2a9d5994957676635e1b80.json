{"sha": "fe5d30682cc829629a2a9d5994957676635e1b80", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmU1ZDMwNjgyY2M4Mjk2MjlhMmE5ZDU5OTQ5NTc2NzY2MzVlMWI4MA==", "commit": {"author": {"name": "Yannick Moy", "email": "moy@adacore.com", "date": "2011-08-02T09:05:58Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-08-02T09:05:58Z"}, "message": "errout.adb, errout.ads (Check_Formal_Restriction): new procedure which issues an error in formal mode if...\n\n2011-08-02  Yannick Moy  <moy@adacore.com>\n\n\t* errout.adb, errout.ads (Check_Formal_Restriction): new procedure\n\twhich issues an error in formal mode if its argument node is originally\n\tfrom source\n\t* sem_ch3.adb (Analyze_Full_Type_Declaration): move test that a type\n\thas a discriminant specification so that it does not include the case\n\tof derived types\n\t(Derived_Type_Declaration): move here the test that a derived type has a\n\tdiscriminant specification\n\t* sem_aggr.adb (Resolve_Record_Aggregate): test the presence of the\n\tfirst element of a component association before accessing its choices\n\t(presence of component association is not enough)\n\t* exp_ch6.adb (Expand_N_Subprogram_Declaration): test if a subprogram\n\tdeclaration is a library item before accessing the next element in a\n\tlist, as library items are not member of lists\n\t* sem_attr.adb, sem_ch11.adb, sem_ch4.adb, sem_ch5.adb, sem_ch6.adb,\n\tsem_ch8.adb, sem_ch9.adb, sem_res.adb, sem_util.adb: use\n\tCheck_Formal_Restriction whenever possible.\n\nFrom-SVN: r177099", "tree": {"sha": "cb9b7a1d6235246bd0d94db6e3ea4af1b309ef91", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cb9b7a1d6235246bd0d94db6e3ea4af1b309ef91"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fe5d30682cc829629a2a9d5994957676635e1b80", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe5d30682cc829629a2a9d5994957676635e1b80", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fe5d30682cc829629a2a9d5994957676635e1b80", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe5d30682cc829629a2a9d5994957676635e1b80/comments", "author": {"login": "yannickmoy", "id": 859440, "node_id": "MDQ6VXNlcjg1OTQ0MA==", "avatar_url": "https://avatars.githubusercontent.com/u/859440?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yannickmoy", "html_url": "https://github.com/yannickmoy", "followers_url": "https://api.github.com/users/yannickmoy/followers", "following_url": "https://api.github.com/users/yannickmoy/following{/other_user}", "gists_url": "https://api.github.com/users/yannickmoy/gists{/gist_id}", "starred_url": "https://api.github.com/users/yannickmoy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yannickmoy/subscriptions", "organizations_url": "https://api.github.com/users/yannickmoy/orgs", "repos_url": "https://api.github.com/users/yannickmoy/repos", "events_url": "https://api.github.com/users/yannickmoy/events{/privacy}", "received_events_url": "https://api.github.com/users/yannickmoy/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b60a3f26749e5aa873754f022ed8be0c6c67bf1d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b60a3f26749e5aa873754f022ed8be0c6c67bf1d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b60a3f26749e5aa873754f022ed8be0c6c67bf1d"}], "stats": {"total": 897, "additions": 328, "deletions": 569}, "files": [{"sha": "19849b307e35fe3dbb1b411b6a2b13de6595ea01", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe5d30682cc829629a2a9d5994957676635e1b80/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe5d30682cc829629a2a9d5994957676635e1b80/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=fe5d30682cc829629a2a9d5994957676635e1b80", "patch": "@@ -1,3 +1,23 @@\n+2011-08-02  Yannick Moy  <moy@adacore.com>\n+\n+\t* errout.adb, errout.ads (Check_Formal_Restriction): new procedure\n+\twhich issues an error in formal mode if its argument node is originally\n+\tfrom source\n+\t* sem_ch3.adb (Analyze_Full_Type_Declaration): move test that a type\n+\thas a discriminant specification so that it does not include the case\n+\tof derived types\n+\t(Derived_Type_Declaration): move here the test that a derived type has a\n+\tdiscriminant specification\n+\t* sem_aggr.adb (Resolve_Record_Aggregate): test the presence of the\n+\tfirst element of a component association before accessing its choices\n+\t(presence of component association is not enough)\n+\t* exp_ch6.adb (Expand_N_Subprogram_Declaration): test if a subprogram\n+\tdeclaration is a library item before accessing the next element in a\n+\tlist, as library items are not member of lists\n+\t* sem_attr.adb, sem_ch11.adb, sem_ch4.adb, sem_ch5.adb, sem_ch6.adb,\n+\tsem_ch8.adb, sem_ch9.adb, sem_res.adb, sem_util.adb: use\n+\tCheck_Formal_Restriction whenever possible.\n+\n 2011-08-02  Ed Schonberg  <schonberg@adacore.com>\n \n \t* sem_ch3.adb (Find_Type_Of_Object): In ASIS mode, create an itype"}, {"sha": "dcc1159cffe0680839776ac553dfebe8982269cb", "filename": "gcc/ada/errout.adb", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe5d30682cc829629a2a9d5994957676635e1b80/gcc%2Fada%2Ferrout.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe5d30682cc829629a2a9d5994957676635e1b80/gcc%2Fada%2Ferrout.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ferrout.adb?ref=fe5d30682cc829629a2a9d5994957676635e1b80", "patch": "@@ -224,6 +224,19 @@ package body Errout is\n       end if;\n    end Change_Error_Text;\n \n+   ------------------------------\n+   -- Check_Formal_Restriction --\n+   ------------------------------\n+\n+   procedure Check_Formal_Restriction (Msg : String; N : Node_Id) is\n+   begin\n+      if Formal_Verification_Mode\n+        and then Comes_From_Source (Original_Node (N))\n+      then\n+         Error_Msg_F (\"|~~\" & Msg, N);\n+      end if;\n+   end Check_Formal_Restriction;\n+\n    ------------------------\n    -- Compilation_Errors --\n    ------------------------"}, {"sha": "933f58dad5ecfd06c875f6c4b998be16905e50e7", "filename": "gcc/ada/errout.ads", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe5d30682cc829629a2a9d5994957676635e1b80/gcc%2Fada%2Ferrout.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe5d30682cc829629a2a9d5994957676635e1b80/gcc%2Fada%2Ferrout.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ferrout.ads?ref=fe5d30682cc829629a2a9d5994957676635e1b80", "patch": "@@ -740,6 +740,13 @@ package Errout is\n    --  the given text. This text may contain insertion characters in the\n    --  usual manner, and need not be the same length as the original text.\n \n+   procedure Check_Formal_Restriction (Msg : String; N : Node_Id);\n+   --  Provides a wrappper on Error_Msg_F which prepends the special characters\n+   --  \"|~~\" (error not serious, language prepended) provided:\n+   --  * the current mode is formal verification.\n+   --  * the node N comes originally from source.\n+   --  Otherwise, does nothing.\n+\n    function First_Node (C : Node_Id) return Node_Id;\n    --  Given a construct C, finds the first node in the construct, i.e. the\n    --  one with the lowest Sloc value. This is useful in placing error msgs."}, {"sha": "b922297a53102a3c2efed016ecb616f317e96fce", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe5d30682cc829629a2a9d5994957676635e1b80/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe5d30682cc829629a2a9d5994957676635e1b80/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=fe5d30682cc829629a2a9d5994957676635e1b80", "patch": "@@ -5409,11 +5409,12 @@ package body Exp_Ch6 is\n       --  In SPARK or ALFA, subprogram declarations are only allowed in\n       --  package specifications.\n \n-      if Formal_Verification_Mode\n-        and then Comes_From_Source (Original_Node (N))\n-        and then Nkind (Parent (N)) /= N_Package_Specification\n-      then\n-         if Present (Next (N))\n+      if Nkind (Parent (N)) /= N_Package_Specification then\n+         if Nkind (Parent (N)) = N_Compilation_Unit then\n+            Check_Formal_Restriction\n+              (\"subprogram declaration is not a library item\", N);\n+\n+         elsif Present (Next (N))\n            and then Nkind (Next (N)) = N_Pragma\n            and then Get_Pragma_Id (Pragma_Name (Next (N))) = Pragma_Import\n          then\n@@ -5424,7 +5425,8 @@ package body Exp_Ch6 is\n \n             null;\n          else\n-            Error_Msg_F (\"|~~subprogram declaration is not allowed here\", N);\n+            Check_Formal_Restriction\n+              (\"subprogram declaration is not allowed here\", N);\n          end if;\n       end if;\n "}, {"sha": "1b93494625644481314a326018784cf95be344e0", "filename": "gcc/ada/sem_aggr.adb", "status": "modified", "additions": 45, "deletions": 53, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe5d30682cc829629a2a9d5994957676635e1b80/gcc%2Fada%2Fsem_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe5d30682cc829629a2a9d5994957676635e1b80/gcc%2Fada%2Fsem_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aggr.adb?ref=fe5d30682cc829629a2a9d5994957676635e1b80", "patch": "@@ -1097,42 +1097,39 @@ package body Sem_Aggr is\n          Error_Msg_N (\"illegal context for aggregate\", N);\n       end if;\n \n-      if Formal_Verification_Mode and then Comes_From_Source (N) then\n-\n-         --  An unqualified aggregate is restricted in SPARK or ALFA to:\n-         --    An 'aggregate item' inside an multi-dimensional aggregate\n-         --    An expression being assigned to an unconstrained array, but only\n-         --    if the aggregate specifies a value for OTHERS only.\n-\n-         if Nkind (Parent (N)) /= N_Qualified_Expression then\n-            if Is_Array_Type (Etype (N)) then\n-               if Nkind (Parent (N)) = N_Assignment_Statement\n-                 and then not Is_Constrained (Etype (Name (Parent (N))))\n-               then\n-                  if not Is_Others_Aggregate (N) then\n-                     Error_Msg_F\n-                       (\"|~~array aggregate should have only OTHERS\", N);\n-                  end if;\n-\n-               elsif not (Nkind (Parent (N)) = N_Aggregate\n-                           and then Is_Array_Type (Etype (Parent (N)))\n-                           and then Number_Dimensions (Etype (Parent (N))) > 1)\n-               then\n-                  Error_Msg_F (\"|~~array aggregate should be qualified\", N);\n-               else\n-                  null;\n+      --  An unqualified aggregate is restricted in SPARK or ALFA to:\n+      --  * an 'aggregate item' inside an aggregate for a multi-dimensional\n+      --    array.\n+      --  * an expression being assigned to an unconstrained array, but only\n+      --    if the aggregate specifies a value for OTHERS only.\n+\n+      if Nkind (Parent (N)) /= N_Qualified_Expression then\n+         if Is_Array_Type (Etype (N)) then\n+            if Nkind (Parent (N)) = N_Assignment_Statement\n+              and then not Is_Constrained (Etype (Name (Parent (N))))\n+            then\n+               if not Is_Others_Aggregate (N) then\n+                  Check_Formal_Restriction\n+                    (\"array aggregate should have only OTHERS\", N);\n                end if;\n+            elsif not (Nkind (Parent (N)) = N_Aggregate\n+                       and then Is_Array_Type (Etype (Parent (N)))\n+                       and then Number_Dimensions (Etype (Parent (N))) > 1)\n+            then\n+               Check_Formal_Restriction\n+                 (\"array aggregate should be qualified\", N);\n+            else\n+               null;\n+            end if;\n \n-            elsif Is_Record_Type (Etype (N)) then\n-               Error_Msg_F (\"|~~record aggregate should be qualified\", N);\n+         elsif Is_Record_Type (Etype (N)) then\n+            Check_Formal_Restriction\n+              (\"record aggregate should be qualified\", N);\n \n             --  The type of aggregate is neither array nor record, so an error\n             --  must have occurred during resolution. Do not report an\n             --  additional message here.\n \n-            else\n-               null;\n-            end if;\n          end if;\n       end if;\n \n@@ -1785,11 +1782,9 @@ package body Sem_Aggr is\n \n                      --  In SPARK or ALFA, the choice must be static\n \n-                     if Formal_Verification_Mode\n-                       and then Comes_From_Source (Original_Node (Choice))\n-                       and then not Is_Static_Expression (Choice)\n-                     then\n-                        Error_Msg_F (\"|~~choice should be static\", Choice);\n+                     if not Is_Static_Expression (Choice) then\n+                        Check_Formal_Restriction\n+                          (\"choice should be static\", Choice);\n                      end if;\n                   end if;\n \n@@ -2434,12 +2429,11 @@ package body Sem_Aggr is\n \n       --  In SPARK or ALFA, the ancestor part cannot be a subtype mark\n \n-      if Formal_Verification_Mode\n-        and then Comes_From_Source (N)\n-        and then Is_Entity_Name (A)\n+      if Is_Entity_Name (A)\n         and then Is_Type (Entity (A))\n       then\n-         Error_Msg_F (\"|~~ancestor part cannot be a subtype mark\", A);\n+         Check_Formal_Restriction\n+           (\"ancestor part cannot be a subtype mark\", A);\n       end if;\n \n       if not Is_Tagged_Type (Typ) then\n@@ -3114,37 +3108,35 @@ package body Sem_Aggr is\n \n    begin\n       --  A record aggregate is restricted in SPARK or ALFA:\n-      --    Each named association can have only a single choice.\n-      --    OTHERS cannot be used.\n-      --    Positional and named associations cannot be mixed.\n+      --  * each named association can have only a single choice.\n+      --  * OTHERS cannot be used.\n+      --  * positional and named associations cannot be mixed.\n \n-      if Formal_Verification_Mode\n-        and then Comes_From_Source (N)\n-        and then Present (Component_Associations (N))\n+      if Present (Component_Associations (N))\n+        and then Present (First (Component_Associations (N)))\n       then\n+\n          if Present (Expressions (N)) then\n-            Error_Msg_F\n-              (\"|~~named association cannot follow positional association\",\n+            Check_Formal_Restriction\n+              (\"named association cannot follow positional association\",\n                First (Choices (First (Component_Associations (N)))));\n          end if;\n \n          declare\n             Assoc : Node_Id;\n-\n          begin\n             Assoc := First (Component_Associations (N));\n+\n             while Present (Assoc) loop\n                if List_Length (Choices (Assoc)) > 1 then\n-                  Error_Msg_F\n-                    (\"|~~component association in record aggregate must \"\n+                  Check_Formal_Restriction\n+                    (\"component association in record aggregate must \"\n                      & \"contain a single choice\", Assoc);\n                end if;\n-\n                if Nkind (First (Choices (Assoc))) = N_Others_Choice then\n-                  Error_Msg_F\n-                    (\"|~~record aggregate cannot contain OTHERS\", Assoc);\n+                  Check_Formal_Restriction\n+                    (\"record aggregate cannot contain OTHERS\", Assoc);\n                end if;\n-\n                Assoc := Next (Assoc);\n             end loop;\n          end;"}, {"sha": "aadcb04be52547091947a79aaa08f8476f3ec3d4", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe5d30682cc829629a2a9d5994957676635e1b80/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe5d30682cc829629a2a9d5994957676635e1b80/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=fe5d30682cc829629a2a9d5994957676635e1b80", "patch": "@@ -2067,6 +2067,7 @@ package body Sem_Attr is\n       --  the full type declaration is visible\n \n       if Formal_Verification_Mode\n+        and then Comes_From_Source (Original_Node (N))\n         and then Is_Entity_Name (P)\n         and then Is_Type (Entity (P))\n         and then Is_Private_Type (P_Type)"}, {"sha": "26ac6d0c209e9faae10fd3f8ea1e61e60704c362", "filename": "gcc/ada/sem_ch11.adb", "status": "modified", "additions": 2, "deletions": 17, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe5d30682cc829629a2a9d5994957676635e1b80/gcc%2Fada%2Fsem_ch11.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe5d30682cc829629a2a9d5994957676635e1b80/gcc%2Fada%2Fsem_ch11.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch11.adb?ref=fe5d30682cc829629a2a9d5994957676635e1b80", "patch": "@@ -443,14 +443,7 @@ package body Sem_Ch11 is\n       P              : Node_Id;\n \n    begin\n-      --  Raise statement is not allowed in SPARK or ALFA\n-\n-      if Formal_Verification_Mode then\n-         Error_Msg_F (\"|~~raise statement is not allowed\", N);\n-      end if;\n-\n-      --  Proceed with analysis\n-\n+      Check_Formal_Restriction (\"raise statement is not allowed\", N);\n       Check_Unreachable_Code (N);\n \n       --  Check exception restrictions on the original source\n@@ -617,15 +610,7 @@ package body Sem_Ch11 is\n    --  Start of processing for Analyze_Raise_xxx_Error\n \n    begin\n-      --  Source-code raise statement is not allowed in SPARK or ALFA\n-\n-      if Formal_Verification_Mode\n-        and then Comes_From_Source (N)\n-      then\n-         Error_Msg_F (\"|~~raise statement is not allowed\", N);\n-      end if;\n-\n-      --  Proceed with analysis\n+      Check_Formal_Restriction (\"raise statement is not allowed\", N);\n \n       if No (Etype (N)) then\n          Set_Etype (N, Standard_Void_Type);"}, {"sha": "e468e1d7c401a5b05240080a25fe5517f2b8b106", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 65, "deletions": 137, "changes": 202, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe5d30682cc829629a2a9d5994957676635e1b80/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe5d30682cc829629a2a9d5994957676635e1b80/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=fe5d30682cc829629a2a9d5994957676635e1b80", "patch": "@@ -715,15 +715,7 @@ package body Sem_Ch3 is\n       Enclosing_Prot_Type : Entity_Id := Empty;\n \n    begin\n-      --  Access type is not allowed in SPARK or ALFA\n-\n-      if Formal_Verification_Mode\n-        and then Comes_From_Source (N)\n-      then\n-         Error_Msg_F (\"|~~access type is not allowed\", N);\n-      end if;\n-\n-      --  Proceed with analysis\n+      Check_Formal_Restriction (\"access type is not allowed\", N);\n \n       if Is_Entry (Current_Scope)\n         and then Is_Task_Type (Etype (Scope (Current_Scope)))\n@@ -1037,13 +1029,7 @@ package body Sem_Ch3 is\n    --  Start of processing for Access_Subprogram_Declaration\n \n    begin\n-      --  Access type is not allowed in SPARK or ALFA\n-\n-      if Formal_Verification_Mode\n-        and then Comes_From_Source (T_Def)\n-      then\n-         Error_Msg_F (\"|~~access type is not allowed\", T_Def);\n-      end if;\n+      Check_Formal_Restriction (\"access type is not allowed\", T_Def);\n \n       --  Associate the Itype node with the inner full-type declaration or\n       --  subprogram spec or entry body. This is required to handle nested\n@@ -1297,13 +1283,7 @@ package body Sem_Ch3 is\n       S : constant Node_Id := Subtype_Indication (Def);\n       P : constant Node_Id := Parent (Def);\n    begin\n-      --  Access type is not allowed in SPARK or ALFA\n-\n-      if Formal_Verification_Mode\n-        and then Comes_From_Source (Def)\n-      then\n-         Error_Msg_F (\"|~~access type is not allowed\", Def);\n-      end if;\n+      Check_Formal_Restriction (\"access type is not allowed\", Def);\n \n       --  Check for permissible use of incomplete type\n \n@@ -2058,12 +2038,11 @@ package body Sem_Ch3 is\n          --  Package specification cannot contain a package declaration in\n          --  SPARK or ALFA.\n \n-         if Formal_Verification_Mode\n-           and then Nkind (D) = N_Package_Declaration\n+         if Nkind (D) = N_Package_Declaration\n            and then Nkind (Parent (L)) = N_Package_Specification\n          then\n-            Error_Msg_F (\"|~~package specification cannot contain \"\n-                         & \"a package declaration\", D);\n+            Check_Formal_Restriction (\"package specification cannot contain \"\n+                                      & \"a package declaration\", D);\n          end if;\n \n          --  Complete analysis of declaration\n@@ -2281,10 +2260,16 @@ package body Sem_Ch3 is\n          when N_Derived_Type_Definition =>\n             null;\n \n-         --  For record types, discriminants are allowed\n+         --  For record types, discriminants are allowed, unless we are in\n+         --  SPARK or ALFA.\n \n          when N_Record_Definition =>\n-            null;\n+            if Present (Discriminant_Specifications (N)) then\n+               Check_Formal_Restriction\n+                 (\"discriminant type is not allowed\",\n+                  Defining_Identifier\n+                  (First (Discriminant_Specifications (N))));\n+            end if;\n \n          when others =>\n             if Present (Discriminant_Specifications (N)) then\n@@ -2386,19 +2371,10 @@ package body Sem_Ch3 is\n          return;\n       end if;\n \n-      if Formal_Verification_Mode then\n+      --  Controlled type is not allowed in SPARK and ALFA\n \n-         --  Controlled type is not allowed in SPARK and ALFA\n-\n-         if Is_Visibly_Controlled (T) then\n-            Error_Msg_F (\"|~~controlled type is not allowed\", N);\n-         end if;\n-\n-         --  Discriminant type is not allowed in SPARK and ALFA\n-\n-         if Present (Discriminant_Specifications (N)) then\n-            Error_Msg_F (\"|~~discriminant type is not allowed\", N);\n-         end if;\n+      if Is_Visibly_Controlled (T) then\n+         Check_Formal_Restriction (\"controlled type is not allowed\", N);\n       end if;\n \n       --  Some common processing for all types\n@@ -2507,15 +2483,7 @@ package body Sem_Ch3 is\n       T : Entity_Id;\n \n    begin\n-      --  Incomplete type is not allowed in SPARK or ALFA\n-\n-      if Formal_Verification_Mode\n-        and then Comes_From_Source (Original_Node (N))\n-      then\n-         Error_Msg_F (\"|~~incomplete type is not allowed\", N);\n-      end if;\n-\n-      --  Proceed with analysis\n+      Check_Formal_Restriction (\"incomplete type is not allowed\", N);\n \n       Generate_Definition (Defining_Identifier (N));\n \n@@ -3054,33 +3022,30 @@ package body Sem_Ch3 is\n       --  is considered, so that the Object_Definition node is still the same\n       --  as in source code.\n \n-      if Formal_Verification_Mode\n-        and then Comes_From_Source (Original_Node (N))\n-      then\n-         --  In SPARK or ALFA, the nominal subtype shall be given by a subtype\n-         --  mark and shall not be unconstrained. (The only exception to this\n-         --  is the admission of declarations of constants of type String.)\n+      --  In SPARK or ALFA, the nominal subtype shall be given by a subtype\n+      --  mark and shall not be unconstrained. (The only exception to this\n+      --  is the admission of declarations of constants of type String.)\n \n-         if not Nkind_In (Object_Definition (N),\n-                          N_Identifier,\n-                          N_Expanded_Name)\n-         then\n-            Error_Msg_F (\"|~~subtype mark expected\", Object_Definition (N));\n-         elsif Is_Array_Type (T)\n-           and then not Is_Constrained (T)\n-           and then T /= Standard_String\n-         then\n-            Error_Msg_F (\"|~~subtype mark of constrained type expected\",\n-                         Object_Definition (N));\n-         else\n-            null;\n-         end if;\n+      if not Nkind_In (Object_Definition (N),\n+                       N_Identifier,\n+                       N_Expanded_Name)\n+      then\n+         Check_Formal_Restriction\n+           (\"subtype mark expected\", Object_Definition (N));\n+      elsif Is_Array_Type (T)\n+        and then not Is_Constrained (T)\n+        and then T /= Standard_String\n+      then\n+         Check_Formal_Restriction (\"subtype mark of constrained type expected\",\n+                                   Object_Definition (N));\n+      else\n+         null;\n+      end if;\n \n-         --  There are no aliased objects in SPARK or ALFA\n+      --  There are no aliased objects in SPARK or ALFA\n \n-         if Aliased_Present (N) then\n-            Error_Msg_F (\"|~~aliased object is not allowed\", N);\n-         end if;\n+      if Aliased_Present (N) then\n+         Check_Formal_Restriction (\"aliased object is not allowed\", N);\n       end if;\n \n       --  Process initialization expression if present and not in error\n@@ -4029,12 +3994,11 @@ package body Sem_Ch3 is\n       --  Subtype of Boolean is not allowed to have a constraint in SPARK or\n       --  ALFA.\n \n-      if Formal_Verification_Mode\n-        and then Comes_From_Source (Original_Node (N))\n-        and then Is_Boolean_Type (T)\n+      if Is_Boolean_Type (T)\n         and then Nkind (Subtype_Indication (N)) = N_Subtype_Indication\n       then\n-         Error_Msg_F (\"|~~subtype of Boolean cannot have constraint\", N);\n+         Check_Formal_Restriction\n+           (\"subtype of Boolean cannot have constraint\", N);\n       end if;\n \n       --  In the case where there is no constraint given in the subtype\n@@ -4047,17 +4011,13 @@ package body Sem_Ch3 is\n          --  Subtype of unconstrained array without constraint is not allowed\n          --  in SPARK or ALFA.\n \n-         if Formal_Verification_Mode\n-           and then Comes_From_Source (Original_Node (N))\n-           and then Is_Array_Type (T)\n+         if Is_Array_Type (T)\n            and then not Is_Constrained (T)\n          then\n-            Error_Msg_F\n-              (\"|~~subtype of unconstrained array must have constraint\", N);\n+            Check_Formal_Restriction\n+              (\"subtype of unconstrained array must have constraint\", N);\n          end if;\n \n-         --  Proceed with analysis\n-\n          case Ekind (T) is\n             when Array_Kind =>\n                Set_Ekind                       (Id, E_Array_Subtype);\n@@ -11254,15 +11214,7 @@ package body Sem_Ch3 is\n       else\n          pragma Assert (Nkind (C) = N_Digits_Constraint);\n \n-         --  Digits constraint is not allowed in SPARK or ALFA\n-\n-         if Formal_Verification_Mode\n-           and then Comes_From_Source (Original_Node (S))\n-         then\n-            Error_Msg_F (\"|~~digits constraint is not allowed\", S);\n-         end if;\n-\n-         --  Proceed with analysis\n+         Check_Formal_Restriction (\"digits constraint is not allowed\", S);\n \n          Digits_Expr := Digits_Expression (C);\n          Analyze_And_Resolve (Digits_Expr, Any_Integer);\n@@ -11491,16 +11443,7 @@ package body Sem_Ch3 is\n \n       if Nkind (C) = N_Digits_Constraint then\n \n-         --  Digits constraint is not allowed in SPARK or ALFA\n-\n-         if Formal_Verification_Mode\n-           and then Comes_From_Source (Original_Node (S))\n-         then\n-            Error_Msg_F (\"|~~digits constraint is not allowed\", S);\n-         end if;\n-\n-         --  Proceed with analysis\n-\n+         Check_Formal_Restriction (\"digits constraint is not allowed\", S);\n          Check_Restriction (No_Obsolescent_Features, C);\n \n          if Warn_On_Obsolescent_Feature then\n@@ -11721,16 +11664,8 @@ package body Sem_Ch3 is\n       --  Delta constraint present\n \n       if Nkind (C) = N_Delta_Constraint then\n-         --  Delta constraint is not allowed in SPARK or ALFA\n-\n-         if Formal_Verification_Mode\n-           and then Comes_From_Source (Original_Node (S))\n-         then\n-            Error_Msg_F (\"|~~delta constraint is not allowed\", S);\n-         end if;\n-\n-         --  Proceed with analysis\n \n+         Check_Formal_Restriction (\"delta constraint is not allowed\", S);\n          Check_Restriction (No_Obsolescent_Features, C);\n \n          if Warn_On_Obsolescent_Feature then\n@@ -12387,17 +12322,8 @@ package body Sem_Ch3 is\n       Bound_Val     : Ureal;\n \n    begin\n-      --  Decimal fixed point type is not allowed in SPARK or ALFA\n-\n-      if Formal_Verification_Mode\n-        and then Comes_From_Source (Original_Node (Def))\n-      then\n-         Error_Msg_F\n-           (\"|~~decimal fixed point type is not allowed\", Def);\n-      end if;\n-\n-      --  Proceed with analysis\n-\n+      Check_Formal_Restriction\n+        (\"decimal fixed point type is not allowed\", Def);\n       Check_Restriction (No_Fixed_Point, Def);\n \n       --  Create implicit base type\n@@ -14143,17 +14069,21 @@ package body Sem_Ch3 is\n       end if;\n \n       --  Only composite types other than array types are allowed to have\n+      --  discriminants. In SPARK in ALFA, no types are allowed to have\n       --  discriminants.\n \n-      if Present (Discriminant_Specifications (N))\n-        and then (Is_Elementary_Type (Parent_Type)\n-                  or else Is_Array_Type (Parent_Type))\n-        and then not Error_Posted (N)\n-      then\n-         Error_Msg_N\n-           (\"elementary or array type cannot have discriminants\",\n-            Defining_Identifier (First (Discriminant_Specifications (N))));\n-         Set_Has_Discriminants (T, False);\n+      if Present (Discriminant_Specifications (N)) then\n+         if (Is_Elementary_Type (Parent_Type)\n+              or else Is_Array_Type (Parent_Type))\n+           and then not Error_Posted (N)\n+         then\n+            Error_Msg_N\n+              (\"elementary or array type cannot have discriminants\",\n+               Defining_Identifier (First (Discriminant_Specifications (N))));\n+            Set_Has_Discriminants (T, False);\n+         else\n+            Check_Formal_Restriction (\"discriminant type is not allowed\", N);\n+         end if;\n       end if;\n \n       --  In Ada 83, a derived type defined in a package specification cannot\n@@ -14349,10 +14279,8 @@ package body Sem_Ch3 is\n       --  In SPARK or ALFA, there are no derived type definitions other than\n       --  type extensions of tagged record types.\n \n-      if Formal_Verification_Mode\n-        and then No (Extension)\n-      then\n-         Error_Msg_F (\"|~~derived type is not allowed\", N);\n+      if No (Extension) then\n+         Check_Formal_Restriction (\"derived type is not allowed\", N);\n       end if;\n    end Derived_Type_Declaration;\n "}, {"sha": "4d179d0ebe53f8e6bb1235e0d18428740f0f9806", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 6, "deletions": 42, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe5d30682cc829629a2a9d5994957676635e1b80/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe5d30682cc829629a2a9d5994957676635e1b80/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=fe5d30682cc829629a2a9d5994957676635e1b80", "patch": "@@ -369,13 +369,7 @@ package body Sem_Ch4 is\n       C        : Node_Id;\n \n    begin\n-      --  Allocator is not allowed in SPARK or ALFA\n-\n-      if Formal_Verification_Mode then\n-         Error_Msg_F (\"|~~allocator is not allowed\", N);\n-      end if;\n-\n-      --  Proceed with analysis\n+      Check_Formal_Restriction (\"allocator is not allowed\", N);\n \n       --  Deal with allocator restrictions\n \n@@ -1475,13 +1469,7 @@ package body Sem_Ch4 is\n          return;\n       end if;\n \n-      --  Conditional expression is not allowed in SPARK or ALFA\n-\n-      if Formal_Verification_Mode then\n-         Error_Msg_F (\"|~~conditional expression is not allowed\", N);\n-      end if;\n-\n-      --  Proceed with analysis\n+      Check_Formal_Restriction (\"conditional expression is not allowed\", N);\n \n       Else_Expr := Next (Then_Expr);\n \n@@ -1681,13 +1669,7 @@ package body Sem_Ch4 is\n    --  Start of processing for Analyze_Explicit_Dereference\n \n    begin\n-      --  Explicit dereference is not allowed in SPARK or ALFA\n-\n-      if Formal_Verification_Mode then\n-         Error_Msg_F (\"|~~explicit dereference is not allowed\", N);\n-      end if;\n-\n-      --  Proceed with analysis\n+      Check_Formal_Restriction (\"explicit dereference is not allowed\", N);\n \n       Analyze (P);\n       Set_Etype (N, Any_Type);\n@@ -2569,13 +2551,7 @@ package body Sem_Ch4 is\n \n    procedure Analyze_Null (N : Node_Id) is\n    begin\n-      --  Null is not allowed in SPARK or ALFA\n-\n-      if Formal_Verification_Mode then\n-         Error_Msg_F (\"|~~null is not allowed\", N);\n-      end if;\n-\n-      --  Proceed with analysis\n+      Check_Formal_Restriction (\"null is not allowed\", N);\n \n       Set_Etype (N, Any_Access);\n    end Analyze_Null;\n@@ -3261,13 +3237,7 @@ package body Sem_Ch4 is\n       Iterator : Node_Id;\n \n    begin\n-      --  Quantified expression is not allowed in SPARK or ALFA\n-\n-      if Formal_Verification_Mode then\n-         Error_Msg_F (\"|~~quantified expression is not allowed\", N);\n-      end if;\n-\n-      --  Proceed with analysis\n+      Check_Formal_Restriction (\"quantified expression is not allowed\", N);\n \n       Set_Etype  (Ent,  Standard_Void_Type);\n       Set_Parent (Ent, N);\n@@ -4295,13 +4265,7 @@ package body Sem_Ch4 is\n    --  Start of processing for Analyze_Slice\n \n    begin\n-      --  Slice is not allowed in SPARK or ALFA\n-\n-      if Formal_Verification_Mode then\n-         Error_Msg_F (\"|~~slice is not allowed\", N);\n-      end if;\n-\n-      --  Proceed with analysis\n+      Check_Formal_Restriction (\"slice is not allowed\", N);\n \n       Analyze (P);\n       Analyze (D);"}, {"sha": "7d960c82b3ad6506d6dae9783041b566fdb4cc10", "filename": "gcc/ada/sem_ch5.adb", "status": "modified", "additions": 33, "deletions": 48, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe5d30682cc829629a2a9d5994957676635e1b80/gcc%2Fada%2Fsem_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe5d30682cc829629a2a9d5994957676635e1b80/gcc%2Fada%2Fsem_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch5.adb?ref=fe5d30682cc829629a2a9d5994957676635e1b80", "patch": "@@ -806,13 +806,7 @@ package body Sem_Ch5 is\n       HSS   : constant Node_Id := Handled_Statement_Sequence (N);\n \n    begin\n-      --  Block statement is not allowed in SPARK or ALFA\n-\n-      if Formal_Verification_Mode\n-        and then Comes_From_Source (N)\n-      then\n-         Error_Msg_F (\"|~~block statement is not allowed\", N);\n-      end if;\n+      Check_Formal_Restriction (\"block statement is not allowed\", N);\n \n       --  If no handled statement sequence is present, things are really\n       --  messed up, and we just return immediately (this is a defence\n@@ -1104,12 +1098,11 @@ package body Sem_Ch5 is\n       --  A case statement with a single OTHERS alternative is not allowed\n       --  in SPARK or ALFA.\n \n-      if Formal_Verification_Mode\n-        and then Others_Present\n+      if Others_Present\n         and then List_Length (Alternatives (N)) = 1\n       then\n-         Error_Msg_F\n-           (\"|~~OTHERS as unique case alternative is not allowed\", N);\n+         Check_Formal_Restriction\n+           (\"OTHERS as unique case alternative is not allowed\", N);\n       end if;\n \n       if Exp_Type = Universal_Integer and then not Others_Present then\n@@ -1183,16 +1176,14 @@ package body Sem_Ch5 is\n          if not In_Open_Scopes (U_Name) or else Ekind (U_Name) /= E_Loop then\n             Error_Msg_N (\"invalid loop name in exit statement\", N);\n             return;\n-         elsif Formal_Verification_Mode\n-           and then Has_Loop_In_Inner_Open_Scopes (U_Name)\n-         then\n-            Error_Msg_F\n-              (\"|~~exit label must name the closest enclosing loop\", N);\n-            return;\n          else\n+            if Has_Loop_In_Inner_Open_Scopes (U_Name) then\n+               Check_Formal_Restriction\n+                 (\"exit label must name the closest enclosing loop\", N);\n+            end if;\n+\n             Set_Has_Exit (U_Name);\n          end if;\n-\n       else\n          U_Name := Empty;\n       end if;\n@@ -1229,36 +1220,36 @@ package body Sem_Ch5 is\n       --  In formal mode, verify that the exit statement respects the SPARK\n       --  restrictions.\n \n-      if Formal_Verification_Mode then\n-         if Present (Cond) then\n-            if Nkind (Parent (N)) /= N_Loop_Statement then\n-               Error_Msg_F\n-                 (\"|~~exit with when clause must be directly in loop\", N);\n-            end if;\n+      if Present (Cond) then\n+         if Nkind (Parent (N)) /= N_Loop_Statement then\n+            Check_Formal_Restriction\n+              (\"exit with when clause must be directly in loop\", N);\n+         end if;\n \n-         else\n-            if Nkind (Parent (N)) /= N_If_Statement then\n-               if Nkind (Parent (N)) = N_Elsif_Part then\n-                  Error_Msg_F (\"|~~exit must be in IF without ELSIF\", N);\n-               else\n-                  Error_Msg_F (\"|~~exit must be directly in IF\", N);\n-               end if;\n+      else\n+         if Nkind (Parent (N)) /= N_If_Statement then\n+            if Nkind (Parent (N)) = N_Elsif_Part then\n+               Check_Formal_Restriction\n+                 (\"exit must be in IF without ELSIF\", N);\n+            else\n+               Check_Formal_Restriction (\"exit must be directly in IF\", N);\n+            end if;\n \n-            elsif Nkind (Parent (Parent (N))) /= N_Loop_Statement then\n-               Error_Msg_F (\"|~~exit must be in IF directly in loop\", N);\n+         elsif Nkind (Parent (Parent (N))) /= N_Loop_Statement then\n+            Check_Formal_Restriction\n+              (\"exit must be in IF directly in loop\", N);\n \n             --  First test the presence of ELSE, so that an exit in an ELSE\n             --  leads to an error mentioning the ELSE.\n \n-            elsif Present (Else_Statements (Parent (N))) then\n-               Error_Msg_F (\"|~~exit must be in IF without ELSE\", N);\n+         elsif Present (Else_Statements (Parent (N))) then\n+            Check_Formal_Restriction (\"exit must be in IF without ELSE\", N);\n \n             --  An exit in an ELSIF does not reach here, as it would have been\n             --  detected in the case (Nkind (Parent (N)) /= N_If_Statement).\n \n-            elsif Present (Elsif_Parts (Parent (N))) then\n-               Error_Msg_F (\"|~~exit must be in IF without ELSIF\", N);\n-            end if;\n+         elsif Present (Elsif_Parts (Parent (N))) then\n+            Check_Formal_Restriction (\"exit must be in IF without ELSIF\", N);\n          end if;\n       end if;\n \n@@ -1286,11 +1277,7 @@ package body Sem_Ch5 is\n       Label_Ent   : Entity_Id;\n \n    begin\n-      --  Goto statement is not allowed in SPARK or ALFA\n-\n-      if Formal_Verification_Mode then\n-         Error_Msg_F (\"|~~goto statement is not allowed\", N);\n-      end if;\n+      Check_Formal_Restriction (\"goto statement is not allowed\", N);\n \n       --  Actual semantic checks\n \n@@ -1872,11 +1859,9 @@ package body Sem_Ch5 is\n                --  Loop parameter specification must include subtype mark in\n                --  SPARK or ALFA.\n \n-               if Formal_Verification_Mode\n-                 and then Nkind (DS) = N_Range\n-               then\n-                  Error_Msg_F (\"|~~loop parameter specification must \"\n-                               & \"include subtype mark\", N);\n+               if Nkind (DS) = N_Range then\n+                  Check_Formal_Restriction (\"loop parameter specification \"\n+                                            & \"must include subtype mark\", N);\n                end if;\n \n                --  Now analyze the subtype definition. If it is a range, create"}, {"sha": "260edc2faa2c2df08904b1a0e9acc51c6565694e", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 50, "deletions": 76, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe5d30682cc829629a2a9d5994957676635e1b80/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe5d30682cc829629a2a9d5994957676635e1b80/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=fe5d30682cc829629a2a9d5994957676635e1b80", "patch": "@@ -227,13 +227,7 @@ package body Sem_Ch6 is\n       Scop       : constant Entity_Id := Current_Scope;\n \n    begin\n-      --  Abstract subprogram is not allowed in SPARK or ALFA\n-\n-      if Formal_Verification_Mode then\n-         Error_Msg_F (\"|~~abstract subprogram is not allowed\", N);\n-      end if;\n-\n-      --  Proceed with analysis\n+      Check_Formal_Restriction (\"abstract subprogram is not allowed\", N);\n \n       Generate_Definition (Designator);\n       Set_Is_Abstract_Subprogram (Designator);\n@@ -607,22 +601,17 @@ package body Sem_Ch6 is\n          --  The only RETURN allowed in SPARK or ALFA is as the last statement\n          --  of the function.\n \n-         if Formal_Verification_Mode\n-           and then Nkind (Parent (N)) /= N_Handled_Sequence_Of_Statements\n+         if Nkind (Parent (N)) /= N_Handled_Sequence_Of_Statements\n            and then\n              (Nkind (Parent (Parent (N))) /= N_Subprogram_Body\n                or else Present (Next (N)))\n          then\n-            Error_Msg_F\n-              (\"|~~RETURN should be the last statement in function\", N);\n+            Check_Formal_Restriction\n+              (\"RETURN should be the last statement in function\", N);\n          end if;\n \n       else\n-         --  Extended return is not allowed in SPARK or ALFA\n-\n-         if Formal_Verification_Mode then\n-            Error_Msg_F (\"|~~extended RETURN is not allowed\", N);\n-         end if;\n+         Check_Formal_Restriction (\"extended RETURN is not allowed\", N);\n \n          --  Analyze parts specific to extended_return_statement:\n \n@@ -1404,12 +1393,8 @@ package body Sem_Ch6 is\n       if Result_Definition (N) /= Error then\n          if Nkind (Result_Definition (N)) = N_Access_Definition then\n \n-            --  Access result is not allowed in SPARK or ALFA\n-\n-            if Formal_Verification_Mode then\n-               Error_Msg_F\n-                 (\"|~~access result is not allowed\", Result_Definition (N));\n-            end if;\n+            Check_Formal_Restriction\n+              (\"access result is not allowed\", Result_Definition (N));\n \n             --  Ada 2005 (AI-254): Handle anonymous access to subprograms\n \n@@ -1441,12 +1426,11 @@ package body Sem_Ch6 is\n \n             --  Unconstrained array as result is not allowed in SPARK or ALFA\n \n-            if Formal_Verification_Mode\n-              and then Is_Array_Type (Typ)\n+            if Is_Array_Type (Typ)\n               and then not Is_Constrained (Typ)\n             then\n-               Error_Msg_F\n-                 (\"|~~returning an unconstrained array is not allowed\",\n+               Check_Formal_Restriction\n+                 (\"returning an unconstrained array is not allowed\",\n                  Result_Definition (N));\n             end if;\n \n@@ -1851,24 +1835,7 @@ package body Sem_Ch6 is\n                Id := Body_Id;\n             end if;\n \n-            --  In formal mode, the last statement of a function should be a\n-            --  return statement.\n-\n-            if Formal_Verification_Mode then\n-               declare\n-                  Stat : constant Node_Id := Last_Source_Statement (HSS);\n-               begin\n-                  if Present (Stat)\n-                    and then not Nkind_In (Stat,\n-                                           N_Simple_Return_Statement,\n-                                           N_Extended_Return_Statement)\n-                  then\n-                     Error_Msg_F (\"|~~last statement in function should \"\n-                                  & \"be RETURN\", Stat);\n-                  end if;\n-               end;\n-\n-            elsif Return_Present (Id) then\n+            if Return_Present (Id) then\n                Check_Returns (HSS, 'F', Missing_Ret);\n \n                if Missing_Ret then\n@@ -1882,11 +1849,37 @@ package body Sem_Ch6 is\n                Error_Msg_N (\"missing RETURN statement in function body\", N);\n             end if;\n \n-         --  In formal mode, verify that a procedure has no return\n+         --  If procedure with No_Return, check returns\n \n-         elsif Formal_Verification_Mode\n-           and then Nkind (Body_Spec) = N_Procedure_Specification\n+         elsif Nkind (Body_Spec) = N_Procedure_Specification\n+           and then Present (Spec_Id)\n+           and then No_Return (Spec_Id)\n          then\n+            Check_Returns (HSS, 'P', Missing_Ret, Spec_Id);\n+         end if;\n+\n+         --  Special checks in formal mode\n+\n+         if Nkind (Body_Spec) = N_Function_Specification then\n+            --  In formal mode, the last statement of a function should be a\n+            --  return statement.\n+\n+            declare\n+               Stat : constant Node_Id := Last_Source_Statement (HSS);\n+            begin\n+               if Present (Stat)\n+                 and then not Nkind_In (Stat,\n+                                        N_Simple_Return_Statement,\n+                                        N_Extended_Return_Statement)\n+               then\n+                  Check_Formal_Restriction\n+                    (\"last statement in function should be RETURN\", Stat);\n+               end if;\n+            end;\n+\n+         --  In formal mode, verify that a procedure has no return\n+\n+         elsif Nkind (Body_Spec) = N_Procedure_Specification then\n             if Present (Spec_Id) then\n                Id := Spec_Id;\n             else\n@@ -1897,16 +1890,9 @@ package body Sem_Ch6 is\n             --  borrow the Check_Returns procedure here ???\n \n             if Return_Present (Id) then\n-               Error_Msg_F (\"|~~procedure should not have RETURN\", N);\n+               Check_Formal_Restriction\n+                 (\"procedure should not have RETURN\", N);\n             end if;\n-\n-         --  If procedure with No_Return, check returns\n-\n-         elsif Nkind (Body_Spec) = N_Procedure_Specification\n-           and then Present (Spec_Id)\n-           and then No_Return (Spec_Id)\n-         then\n-            Check_Returns (HSS, 'P', Missing_Ret, Spec_Id);\n          end if;\n       end Check_Missing_Return;\n \n@@ -2844,11 +2830,10 @@ package body Sem_Ch6 is\n    begin\n       --  Null procedures are not allowed in SPARK or ALFA\n \n-      if Formal_Verification_Mode\n-        and then Nkind (Specification (N)) = N_Procedure_Specification\n+      if Nkind (Specification (N)) = N_Procedure_Specification\n         and then Null_Present (Specification (N))\n       then\n-         Error_Msg_F (\"|~~null procedure not allowed\", N);\n+         Check_Formal_Restriction (\"null procedure is not allowed\", N);\n       end if;\n \n       --  For a null procedure, capture the profile before analysis, for\n@@ -3092,11 +3077,8 @@ package body Sem_Ch6 is\n    begin\n       --  User-defined operator is not allowed in SPARK or ALFA\n \n-      if Formal_Verification_Mode\n-        and then Comes_From_Source (N)\n-        and then Nkind (Defining_Unit_Name (N)) = N_Defining_Operator_Symbol\n-      then\n-         Error_Msg_F (\"|~~user-defined operator is not allowed\", N);\n+      if Nkind (Defining_Unit_Name (N)) = N_Defining_Operator_Symbol then\n+         Check_Formal_Restriction (\"user-defined operator is not allowed\", N);\n       end if;\n \n       --  Proceed with analysis\n@@ -8525,12 +8507,8 @@ package body Sem_Ch6 is\n \n          --  Overloading is not allowed in SPARK or ALFA\n \n-         if Formal_Verification_Mode\n-           and then Comes_From_Source (S)\n-         then\n-            Error_Msg_Sloc := Sloc (Homonym (S));\n-            Error_Msg_F (\"|~~overloading not allowed with entity#\", S);\n-         end if;\n+         Error_Msg_Sloc := Sloc (Homonym (S));\n+         Check_Formal_Restriction (\"overloading not allowed with entity#\", S);\n \n          --  If S is a derived operation for an untagged type then by\n          --  definition it's not a dispatching operation (even if the parent\n@@ -8791,13 +8769,9 @@ package body Sem_Ch6 is\n          Default := Expression (Param_Spec);\n \n          if Present (Default) then\n-            --  Default expression is not allowed in SPARK or ALFA\n-\n-            if Formal_Verification_Mode then\n-               Error_Msg_F (\"|~~default expression is not allowed\", Default);\n-            end if;\n \n-            --  Proceed with analysis\n+            Check_Formal_Restriction\n+              (\"default expression is not allowed\", Default);\n \n             if Out_Present (Param_Spec) then\n                Error_Msg_N"}, {"sha": "de3b9ff3ec7e649c5483f72c6067fe3d4f49f4ac", "filename": "gcc/ada/sem_ch8.adb", "status": "modified", "additions": 6, "deletions": 31, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe5d30682cc829629a2a9d5994957676635e1b80/gcc%2Fada%2Fsem_ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe5d30682cc829629a2a9d5994957676635e1b80/gcc%2Fada%2Fsem_ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch8.adb?ref=fe5d30682cc829629a2a9d5994957676635e1b80", "patch": "@@ -529,13 +529,7 @@ package body Sem_Ch8 is\n       Nam : constant Node_Id := Name (N);\n \n    begin\n-      --  Exception renaming is not allowed in SPARK or ALFA\n-\n-      if Formal_Verification_Mode then\n-         Error_Msg_F (\"|~~exception renaming is not allowed\", N);\n-      end if;\n-\n-      --  Proceed with analysis\n+      Check_Formal_Restriction (\"exception renaming is not allowed\", N);\n \n       Enter_Name (Id);\n       Analyze (Nam);\n@@ -628,18 +622,12 @@ package body Sem_Ch8 is\n       Inst  : Boolean   := False; -- prevent junk warning\n \n    begin\n-      --  Generic renaming is not allowed in SPARK or ALFA\n-\n-      if Formal_Verification_Mode then\n-         Error_Msg_F (\"|~~generic renaming is not allowed\", N);\n-      end if;\n-\n-      --  Proceed with analysis\n-\n       if Name (N) = Error then\n          return;\n       end if;\n \n+      Check_Formal_Restriction (\"generic renaming is not allowed\", N);\n+\n       Generate_Definition (New_P);\n \n       if Current_Scope /= Standard_Standard then\n@@ -726,18 +714,12 @@ package body Sem_Ch8 is\n    --  Start of processing for Analyze_Object_Renaming\n \n    begin\n-      --  Object renaming is not allowed in SPARK or ALFA\n-\n-      if Formal_Verification_Mode then\n-         Error_Msg_F (\"|~~object renaming is not allowed\", N);\n-      end if;\n-\n-      --  Proceed with analysis\n-\n       if Nam = Error then\n          return;\n       end if;\n \n+      Check_Formal_Restriction (\"object renaming is not allowed\", N);\n+\n       Set_Is_Pure (Id, Is_Pure (Current_Scope));\n       Enter_Name (Id);\n \n@@ -2567,14 +2549,7 @@ package body Sem_Ch8 is\n    --  Start of processing for Analyze_Use_Package\n \n    begin\n-      --  Use package is not allowed in SPARK or ALFA\n-\n-      if Formal_Verification_Mode then\n-         Error_Msg_F (\"|~~use clause is not allowed\", N);\n-         return;\n-      end if;\n-\n-      --  Proceed with analysis\n+      Check_Formal_Restriction (\"use clause is not allowed\", N);\n \n       Set_Hidden_By_Use_Clause (N, No_Elist);\n "}, {"sha": "09214b87ad35937f41bd2fc71986d420896236a3", "filename": "gcc/ada/sem_ch9.adb", "status": "modified", "additions": 18, "deletions": 101, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe5d30682cc829629a2a9d5994957676635e1b80/gcc%2Fada%2Fsem_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe5d30682cc829629a2a9d5994957676635e1b80/gcc%2Fada%2Fsem_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch9.adb?ref=fe5d30682cc829629a2a9d5994957676635e1b80", "patch": "@@ -100,15 +100,9 @@ package body Sem_Ch9 is\n       T_Name : Node_Id;\n \n    begin\n-      --  Abort statement is not allowed in SPARK or ALFA\n-\n-      if Formal_Verification_Mode then\n-         Error_Msg_F (\"|~~abort statement is not allowed\", N);\n-      end if;\n-\n-      --  Proceed with analysis\n-\n       Tasking_Used := True;\n+      Check_Formal_Restriction (\"abort statement is not allowed\", N);\n+\n       T_Name := First (Names (N));\n       while Present (T_Name) loop\n          Analyze (T_Name);\n@@ -177,15 +171,8 @@ package body Sem_Ch9 is\n       Task_Nam  : Entity_Id;\n \n    begin\n-      --  Accept statement is not allowed in SPARK or ALFA\n-\n-      if Formal_Verification_Mode then\n-         Error_Msg_F (\"|~~accept statement is not allowed\", N);\n-      end if;\n-\n-      --  Proceed with analysis\n-\n       Tasking_Used := True;\n+      Check_Formal_Restriction (\"accept statement is not allowed\", N);\n \n       --  Entry name is initialized to Any_Id. It should get reset to the\n       --  matching entry entity. An error is signalled if it is not reset.\n@@ -415,15 +402,8 @@ package body Sem_Ch9 is\n       Trigger        : Node_Id;\n \n    begin\n-      --  Select statement is not allowed in SPARK or ALFA\n-\n-      if Formal_Verification_Mode then\n-         Error_Msg_F (\"|~~select statement is not allowed\", N);\n-      end if;\n-\n-      --  Proceed with analysis\n-\n       Tasking_Used := True;\n+      Check_Formal_Restriction (\"select statement is not allowed\", N);\n       Check_Restriction (Max_Asynchronous_Select_Nesting, N);\n       Check_Restriction (No_Select_Statements, N);\n \n@@ -468,16 +448,9 @@ package body Sem_Ch9 is\n       Is_Disp_Select : Boolean := False;\n \n    begin\n-      --  Select statement is not allowed in SPARK or ALFA\n-\n-      if Formal_Verification_Mode then\n-         Error_Msg_F (\"|~~select statement is not allowed\", N);\n-      end if;\n-\n-      --  Proceed with analysis\n-\n-      Check_Restriction (No_Select_Statements, N);\n       Tasking_Used := True;\n+      Check_Formal_Restriction (\"select statement is not allowed\", N);\n+      Check_Restriction (No_Select_Statements, N);\n \n       --  Ada 2005 (AI-345): The trigger may be a dispatching call\n \n@@ -572,16 +545,9 @@ package body Sem_Ch9 is\n    procedure Analyze_Delay_Relative (N : Node_Id) is\n       E : constant Node_Id := Expression (N);\n    begin\n-      --  Delay statement is not allowed in SPARK or ALFA\n-\n-      if Formal_Verification_Mode then\n-         Error_Msg_F (\"|~~delay statement is not allowed\", N);\n-      end if;\n-\n-      --  Proceed with analysis\n-\n-      Check_Restriction (No_Relative_Delay, N);\n       Tasking_Used := True;\n+      Check_Formal_Restriction (\"delay statement is not allowed\", N);\n+      Check_Restriction (No_Relative_Delay, N);\n       Check_Restriction (No_Delay, N);\n       Check_Potentially_Blocking_Operation (N);\n       Analyze_And_Resolve (E, Standard_Duration);\n@@ -597,15 +563,8 @@ package body Sem_Ch9 is\n       Typ : Entity_Id;\n \n    begin\n-      --  Delay statement is not allowed in SPARK or ALFA\n-\n-      if Formal_Verification_Mode then\n-         Error_Msg_F (\"|~~delay statement is not allowed\", N);\n-      end if;\n-\n-      --  Proceed with analysis\n-\n       Tasking_Used := True;\n+      Check_Formal_Restriction (\"delay statement is not allowed\", N);\n       Check_Restriction (No_Delay, N);\n       Check_Potentially_Blocking_Operation (N);\n       Analyze (E);\n@@ -891,15 +850,8 @@ package body Sem_Ch9 is\n       Call : constant Node_Id := Entry_Call_Statement (N);\n \n    begin\n-      --  Entry call is not allowed in SPARK or ALFA\n-\n-      if Formal_Verification_Mode then\n-         Error_Msg_F (\"|~~entry call is not allowed\", N);\n-      end if;\n-\n-      --  Proceed with analysis\n-\n       Tasking_Used := True;\n+      Check_Formal_Restriction (\"entry call is not allowed\", N);\n \n       if Present (Pragmas_Before (N)) then\n          Analyze_List (Pragmas_Before (N));\n@@ -1161,15 +1113,8 @@ package body Sem_Ch9 is\n    --  Start of processing for Analyze_Protected_Definition\n \n    begin\n-      --  Protected definition is not allowed in SPARK or ALFA\n-\n-      if Formal_Verification_Mode then\n-         Error_Msg_F (\"|~~protected definition is not allowed\", N);\n-      end if;\n-\n-      --  Proceed with analysis\n-\n       Tasking_Used := True;\n+      Check_Formal_Restriction (\"protected definition is not allowed\", N);\n       Analyze_Declarations (Visible_Declarations (N));\n \n       if Present (Private_Declarations (N))\n@@ -1362,17 +1307,10 @@ package body Sem_Ch9 is\n       Outer_Ent   : Entity_Id;\n \n    begin\n-      --  Requeue statement is not allowed in SPARK or ALFA\n-\n-      if Formal_Verification_Mode then\n-         Error_Msg_F (\"|~~requeue statement is not allowed\", N);\n-      end if;\n-\n-      --  Proceed with analysis\n-\n+      Tasking_Used := True;\n+      Check_Formal_Restriction (\"requeue statement is not allowed\", N);\n       Check_Restriction (No_Requeue_Statements, N);\n       Check_Unreachable_Code (N);\n-      Tasking_Used := True;\n \n       Enclosing := Empty;\n       for J in reverse 0 .. Scope_Stack.Last loop\n@@ -1643,16 +1581,9 @@ package body Sem_Ch9 is\n       Alt_Count         : Uint    := Uint_0;\n \n    begin\n-      --  Select statement is not allowed in SPARK or ALFA\n-\n-      if Formal_Verification_Mode then\n-         Error_Msg_F (\"|~~select statement is not allowed\", N);\n-      end if;\n-\n-      --  Proceed with analysis\n-\n-      Check_Restriction (No_Select_Statements, N);\n       Tasking_Used := True;\n+      Check_Formal_Restriction (\"select statement is not allowed\", N);\n+      Check_Restriction (No_Select_Statements, N);\n \n       --  Loop to analyze alternatives\n \n@@ -2028,15 +1959,8 @@ package body Sem_Ch9 is\n       L : Entity_Id;\n \n    begin\n-      --  Task definition is not allowed in SPARK or ALFA\n-\n-      if Formal_Verification_Mode then\n-         Error_Msg_F (\"|~~task definition is not allowed\", N);\n-      end if;\n-\n-      --  Proceed with analysis\n-\n       Tasking_Used := True;\n+      Check_Formal_Restriction (\"task definition is not allowed\", N);\n \n       if Present (Visible_Declarations (N)) then\n          Analyze_Declarations (Visible_Declarations (N));\n@@ -2195,16 +2119,9 @@ package body Sem_Ch9 is\n       Is_Disp_Select : Boolean := False;\n \n    begin\n-      --  Select statement is not allowed in SPARK or ALFA\n-\n-      if Formal_Verification_Mode then\n-         Error_Msg_F (\"|~~select statement is not allowed\", N);\n-      end if;\n-\n-      --  Proceed with analysis\n-\n-      Check_Restriction (No_Select_Statements, N);\n       Tasking_Used := True;\n+      Check_Formal_Restriction (\"select statement is not allowed\", N);\n+      Check_Restriction (No_Select_Statements, N);\n \n       --  Ada 2005 (AI-345): The trigger may be a dispatching call\n "}, {"sha": "cc88f4315dcb9341156a776966437717536058eb", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 44, "deletions": 56, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe5d30682cc829629a2a9d5994957676635e1b80/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe5d30682cc829629a2a9d5994957676635e1b80/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=fe5d30682cc829629a2a9d5994957676635e1b80", "patch": "@@ -3560,9 +3560,7 @@ package body Sem_Res is\n             --  In SPARK or ALFA, the only view conversions are those involving\n             --  ancestor conversion of an extended type.\n \n-            if Formal_Verification_Mode\n-              and then Comes_From_Source (Original_Node (A))\n-              and then Nkind (A) = N_Type_Conversion\n+            if Nkind (A) = N_Type_Conversion\n               and then Ekind_In (F, E_Out_Parameter, E_In_Out_Parameter)\n             then\n                declare\n@@ -3577,8 +3575,9 @@ package body Sem_Res is\n                            and then not Is_Class_Wide_Type (Operand_Typ)\n                            and then Is_Ancestor (Target_Typ, Operand_Typ))\n                   then\n-                     Error_Msg_F (\"|~~ancestor conversion is the only \"\n-                                  & \"permitted view conversion\", A);\n+                     Check_Formal_Restriction\n+                       (\"ancestor conversion is the only permitted view \"\n+                        & \"conversion\", A);\n                   end if;\n                end;\n             end if;\n@@ -4827,15 +4826,14 @@ package body Sem_Res is\n       --  fixed point types shall be qualified or explicitly converted to\n       --  identify the result type.\n \n-      if Formal_Verification_Mode\n-        and then (Is_Fixed_Point_Type (Etype (L))\n-                   or else Is_Fixed_Point_Type (Etype (R)))\n+      if (Is_Fixed_Point_Type (Etype (L))\n+           or else Is_Fixed_Point_Type (Etype (R)))\n         and then Nkind_In (N, N_Op_Multiply, N_Op_Divide)\n         and then\n           not Nkind_In (Parent (N), N_Qualified_Expression, N_Type_Conversion)\n       then\n-         Error_Msg_F\n-           (\"|~~operation should be qualified or explicitly converted\", N);\n+         Check_Formal_Restriction\n+           (\"operation should be qualified or explicitly converted\", N);\n       end if;\n \n       --  Set overflow and division checking bit. Much cleverer code needed\n@@ -5842,18 +5840,16 @@ package body Sem_Res is\n       --  In SPARK or ALFA, ordering operators <, <=, >, >= are not defined\n       --  for Boolean types or array types except String.\n \n-      if Formal_Verification_Mode\n-        and then Comes_From_Source (Original_Node (N))\n+      if Is_Boolean_Type (T) then\n+         Check_Formal_Restriction\n+           (\"comparison is not defined on Boolean type\", N);\n+      elsif Is_Array_Type (T)\n+        and then Base_Type (T) /= Standard_String\n       then\n-         if Is_Boolean_Type (T) then\n-            Error_Msg_F (\"|~~comparison is not defined on Boolean type\", N);\n-         elsif Is_Array_Type (T)\n-           and then Base_Type (T) /= Standard_String\n-         then\n-            Error_Msg_F\n-              (\"|~~comparison is not defined on array types \" &\n-               \"other than String\", N);\n-         end if;\n+         Check_Formal_Restriction\n+           (\"comparison is not defined on array types other than String\", N);\n+      else\n+         null;\n       end if;\n \n       --  Check comparison on unordered enumeration\n@@ -6703,14 +6699,12 @@ package body Sem_Res is\n          --  other than String are only defined when, for each index position,\n          --  the operands have equal static bounds.\n \n-         if Formal_Verification_Mode\n-           and then Comes_From_Source (Original_Node (N))\n-           and then Is_Array_Type (T)\n+         if Is_Array_Type (T)\n            and then Base_Type (T) /= Standard_String\n            and then not Matching_Static_Array_Bounds (Etype (L), Etype (R))\n          then\n-            Error_Msg_F\n-              (\"|~~array types should have matching static bounds\", N);\n+            Check_Formal_Restriction\n+              (\"array types should have matching static bounds\", N);\n          end if;\n \n          --  If the unique type is a class-wide type then it will be expanded\n@@ -7239,13 +7233,12 @@ package body Sem_Res is\n       --  defined only when both operands have same static lower and higher\n       --  bounds.\n \n-      if Formal_Verification_Mode\n-        and then Comes_From_Source (Original_Node (N))\n-        and then Is_Array_Type (B_Typ)\n+      if Is_Array_Type (B_Typ)\n         and then not Matching_Static_Array_Bounds (Etype (Left_Opnd (N)),\n                                                    Etype (Right_Opnd (N)))\n       then\n-         Error_Msg_F (\"|~~array types should have matching static bounds\", N);\n+         Check_Formal_Restriction\n+           (\"array types should have matching static bounds\", N);\n       end if;\n \n    end Resolve_Logical_Op;\n@@ -7495,10 +7488,9 @@ package body Sem_Res is\n          NN := Parent (NN);\n       end loop;\n \n-      if Formal_Verification_Mode\n-        and then Base_Type (Etype (N)) /= Standard_String\n-      then\n-         Error_Msg_F (\"|~~result of concatenation should have type String\", N);\n+      if Base_Type (Etype (N)) /= Standard_String then\n+         Check_Formal_Restriction\n+           (\"result of concatenation should have type String\", N);\n       end if;\n    end Resolve_Op_Concat;\n \n@@ -7609,25 +7601,23 @@ package body Sem_Res is\n       --  Resolve_Op_Concat_Arg call it separately on each final operand, past\n       --  concatenation operations.\n \n-      if Formal_Verification_Mode then\n-         if Is_Character_Type (Etype (Arg)) then\n-            if not Is_Static_Expression (Arg) then\n-               Error_Msg_F (\"|~~character operand for concatenation should be \"\n-                            & \"static\", N);\n-            end if;\n+      if Is_Character_Type (Etype (Arg)) then\n+         if not Is_Static_Expression (Arg) then\n+            Check_Formal_Restriction\n+              (\"character operand for concatenation should be static\", N);\n+         end if;\n \n-         elsif Is_String_Type (Etype (Arg)) then\n-            if Nkind (Arg) /= N_String_Literal then\n-               Error_Msg_F (\"|~~string operand for concatenation should be \"\n-                            & \"a literal\", N);\n-            end if;\n+      elsif Is_String_Type (Etype (Arg)) then\n+         if Nkind (Arg) /= N_String_Literal then\n+            Check_Formal_Restriction\n+              (\"string operand for concatenation should be a literal\", N);\n+         end if;\n \n          --  Do not issue error on an operand that is neither a character nor\n          --  a string, as the error is issued in Resolve_Op_Concat.\n \n-         else\n-            null;\n-         end if;\n+      else\n+         null;\n       end if;\n \n       Check_Unset_Reference (Arg);\n@@ -7898,13 +7888,12 @@ package body Sem_Res is\n    begin\n       Resolve (Expr, Target_Typ);\n \n-      if Formal_Verification_Mode\n-        and then Comes_From_Source (Original_Node (N))\n-        and then Is_Array_Type (Target_Typ)\n+      if Is_Array_Type (Target_Typ)\n         and then Is_Array_Type (Etype (Expr))\n         and then not Matching_Static_Array_Bounds (Target_Typ, Etype (Expr))\n       then\n-         Error_Msg_F (\"|~~array types should have matching static bounds\", N);\n+         Check_Formal_Restriction\n+           (\"array types should have matching static bounds\", N);\n       end if;\n \n       --  A qualified expression requires an exact match of the type,\n@@ -9024,13 +9013,12 @@ package body Sem_Res is\n       --  In SPARK or ALFA, a type conversion between array types should be\n       --  restricted to types which have matching static bounds.\n \n-      if Formal_Verification_Mode\n-        and then Comes_From_Source (Original_Node (N))\n-        and then Is_Array_Type (Target_Typ)\n+      if Is_Array_Type (Target_Typ)\n         and then Is_Array_Type (Operand_Typ)\n         and then not Matching_Static_Array_Bounds (Target_Typ, Operand_Typ)\n       then\n-         Error_Msg_F (\"|~~array types should have matching static bounds\", N);\n+         Check_Formal_Restriction\n+           (\"array types should have matching static bounds\", N);\n       end if;\n \n       --  Note: we do the Eval_Type_Conversion call before applying the"}, {"sha": "e69b0946edc9511044f96edd76eecb2a8ab549f0", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe5d30682cc829629a2a9d5994957676635e1b80/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe5d30682cc829629a2a9d5994957676635e1b80/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=fe5d30682cc829629a2a9d5994957676635e1b80", "patch": "@@ -3202,7 +3202,7 @@ package body Sem_Util is\n \n       --  Declaring a homonym is not allowed in SPARK or ALFA ...\n \n-      if Formal_Verification_Mode and then Present (C)\n+      if Present (C)\n \n         --  ... unless the new declaration is in a subprogram, and the visible\n         --  declaration is a variable declaration or a parameter specification\n@@ -3234,7 +3234,7 @@ package body Sem_Util is\n         and then Comes_From_Source (C)\n       then\n          Error_Msg_Sloc := Sloc (C);\n-         Error_Msg_F (\"|~~redeclaration of identifier &#\", Def_Id);\n+         Check_Formal_Restriction (\"redeclaration of identifier &#\", Def_Id);\n       end if;\n \n       --  Warn if new entity hides an old one\n@@ -8030,6 +8030,14 @@ package body Sem_Util is\n       L_Index := First_Index (L_Typ);\n       R_Index := First_Index (R_Typ);\n \n+      --  There may not be an index available even if the type is constrained,\n+      --  see for example 0100-C23 when this function is called from\n+      --  Resolve_Qualified_Expression. Temporarily return False in that case.\n+\n+      if No (L_Index) or else No (R_Index) then\n+         return False;\n+      end if;\n+\n       for Indx in 1 .. L_Ndims loop\n          Get_Index_Bounds (L_Index, L_Low, L_High);\n          Get_Index_Bounds (R_Index, R_Low, R_High);"}]}