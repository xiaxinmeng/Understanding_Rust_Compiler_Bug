{"sha": "47b90d6b3215bac43ff7134461cb03a4857b3143", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDdiOTBkNmIzMjE1YmFjNDNmZjcxMzQ0NjFjYjAzYTQ4NTdiMzE0Mw==", "commit": {"author": {"name": "David Krauss", "email": "potswa@mac.com", "date": "2010-10-06T00:17:28Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2010-10-06T00:17:28Z"}, "message": "re PR libstdc++/45841 (r164529 cris-elf libstdc++ 27_io/basic_filebuf/seekoff/char/2-io.cc)\n\n2010-10-05  David Krauss  <potswa@mac.com>\n\n\tPR libstdc++/45841\n\t* include/bits/fstream.h (basic_filebuf::underflow): Overflow\n\tsuccess does not preclude returning failure.\n\t(basic_filebuf::pbackfail): Likewise.\n\t(basic_filebuf::xsputn): Fix indentation problem.\n\t(basic_filebuf::xsgetn): Likewise. Also, add similar overflow\n\tcall to enable optimized case from write mode.\n\t* testsuite/27_io/basic_filebuf/underflow/char/45841.cc: New.\n\t* testsuite/27_io/basic_filebuf/underflow/wchar_t/45841.cc: Likewise.\n\nFrom-SVN: r165009", "tree": {"sha": "18fe427c552ba9001525397586833ca0ed3484e3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/18fe427c552ba9001525397586833ca0ed3484e3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/47b90d6b3215bac43ff7134461cb03a4857b3143", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47b90d6b3215bac43ff7134461cb03a4857b3143", "html_url": "https://github.com/Rust-GCC/gccrs/commit/47b90d6b3215bac43ff7134461cb03a4857b3143", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47b90d6b3215bac43ff7134461cb03a4857b3143/comments", "author": null, "committer": null, "parents": [{"sha": "94a9600ce3147de36fdd06dba2e3cae693a21b4d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/94a9600ce3147de36fdd06dba2e3cae693a21b4d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/94a9600ce3147de36fdd06dba2e3cae693a21b4d"}], "stats": {"total": 322, "additions": 211, "deletions": 111}, "files": [{"sha": "94aa9f1aa80eb118f18a4f767e80542645d9d24a", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47b90d6b3215bac43ff7134461cb03a4857b3143/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47b90d6b3215bac43ff7134461cb03a4857b3143/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=47b90d6b3215bac43ff7134461cb03a4857b3143", "patch": "@@ -1,3 +1,15 @@\n+2010-10-05  David Krauss  <potswa@mac.com>\n+\n+\tPR libstdc++/45841\n+\t* include/bits/fstream.h (basic_filebuf::underflow): Overflow\n+\tsuccess does not preclude returning failure.\n+\t(basic_filebuf::pbackfail): Likewise.\n+\t(basic_filebuf::xsputn): Fix indentation problem.\n+\t(basic_filebuf::xsgetn): Likewise. Also, add similar overflow\n+\tcall to enable optimized case from write mode.\n+\t* testsuite/27_io/basic_filebuf/underflow/char/45841.cc: New.\n+\t* testsuite/27_io/basic_filebuf/underflow/wchar_t/45841.cc: Likewise.\n+\n 2010-10-05  Jonathan Wakely  <jwakely.gcc@gmail.com>\n \n \t* include/bits/locale_facets_nonio.h (time_get::get_time): Doc typo."}, {"sha": "d32de8f8d376f08a993f7d13a0d1b27e2d97d287", "filename": "libstdc++-v3/include/bits/fstream.tcc", "status": "modified", "additions": 117, "deletions": 111, "changes": 228, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47b90d6b3215bac43ff7134461cb03a4857b3143/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ffstream.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47b90d6b3215bac43ff7134461cb03a4857b3143/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ffstream.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ffstream.tcc?ref=47b90d6b3215bac43ff7134461cb03a4857b3143", "patch": "@@ -207,14 +207,13 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n       const bool __testin = _M_mode & ios_base::in;\n       if (__testin)\n \t{\n-         if (_M_writing)\n-           {\n-             __ret = overflow();\n-             if (__ret == traits_type::eof())\n-               return __ret;\n-             _M_set_buffer(-1);\n-             _M_writing = false;\n-           }\n+\t  if (_M_writing)\n+\t    {\n+\t      if (overflow() == traits_type::eof())\n+\t\treturn __ret;\n+\t      _M_set_buffer(-1);\n+\t      _M_writing = false;\n+\t    }\n \t  // Check for pback madness, and if so switch back to the\n \t  // normal buffers and jet outta here before expensive\n \t  // fileops happen...\n@@ -367,14 +366,13 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n       const bool __testin = _M_mode & ios_base::in;\n       if (__testin)\n \t{\n-         if (_M_writing)\n-           {\n-             __ret = overflow();\n-             if (__ret == traits_type::eof())\n-               return __ret;\n-             _M_set_buffer(-1);\n-             _M_writing = false;\n-           }\n+\t  if (_M_writing)\n+\t    {\n+\t      if (overflow() == traits_type::eof())\n+\t\treturn __ret;\n+\t      _M_set_buffer(-1);\n+\t      _M_writing = false;\n+\t    }\n \t  // Remember whether the pback buffer is active, otherwise below\n \t  // we may try to store in it a second char (libstdc++/9761).\n \t  const bool __testpb = _M_pback_init;\n@@ -545,101 +543,108 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n       return __elen == __plen;\n     }\n \n-   template<typename _CharT, typename _Traits>\n-     streamsize\n-     basic_filebuf<_CharT, _Traits>::\n-     xsgetn(_CharT* __s, streamsize __n)\n-     {\n-       // Clear out pback buffer before going on to the real deal...\n-       streamsize __ret = 0;\n-       if (_M_pback_init)\n-\t {\n-\t   if (__n > 0 && this->gptr() == this->eback())\n-\t     {\n-\t       *__s++ = *this->gptr();\n-\t       this->gbump(1);\n-\t       __ret = 1;\n-\t       --__n;\n-\t     }\n-\t   _M_destroy_pback();\n-\t }\n-       \n-       // Optimization in the always_noconv() case, to be generalized in the\n-       // future: when __n > __buflen we read directly instead of using the\n-       // buffer repeatedly.\n-       const bool __testin = _M_mode & ios_base::in;\n-       const streamsize __buflen = _M_buf_size > 1 ? _M_buf_size - 1 : 1;\n-\n-       if (__n > __buflen && __check_facet(_M_codecvt).always_noconv()\n-\t   && __testin && !_M_writing)\n-\t {\n-\t   // First, copy the chars already present in the buffer.\n-\t   const streamsize __avail = this->egptr() - this->gptr();\n-\t   if (__avail != 0)\n-\t     {\n-\t       if (__avail == 1)\n-\t\t *__s = *this->gptr();\n-\t       else\n-\t\t traits_type::copy(__s, this->gptr(), __avail);\n-\t       __s += __avail;\n-\t       this->gbump(__avail);\n-\t       __ret += __avail;\n-\t       __n -= __avail;\n-\t     }\n-\n-\t   // Need to loop in case of short reads (relatively common\n-\t   // with pipes).\n-\t   streamsize __len;\n-\t   for (;;)\n-\t     {\n-\t       __len = _M_file.xsgetn(reinterpret_cast<char*>(__s),\n-\t\t\t\t      __n);\n-\t       if (__len == -1)\n-\t\t __throw_ios_failure(__N(\"basic_filebuf::xsgetn \"\n-\t\t\t\t\t \"error reading the file\"));\n-\t       if (__len == 0)\n-\t\t break;\n-\n-\t       __n -= __len;\n-\t       __ret += __len;\n-\t       if (__n == 0)\n-\t\t break;\n-\n-\t       __s += __len;\n-\t     }\n-\n-\t   if (__n == 0)\n-\t     {\n-\t       _M_set_buffer(0);\n-\t       _M_reading = true;\n-\t     }\n-\t   else if (__len == 0)\n-\t     {\n-\t       // If end of file is reached, set 'uncommitted'\n-\t       // mode, thus allowing an immediate write without\n-\t       // an intervening seek.\n-\t       _M_set_buffer(-1);\n-\t       _M_reading = false;\n-\t     }\n-\t }\n-       else\n-\t __ret += __streambuf_type::xsgetn(__s, __n);\n+  template<typename _CharT, typename _Traits>\n+    streamsize\n+    basic_filebuf<_CharT, _Traits>::\n+    xsgetn(_CharT* __s, streamsize __n)\n+    {\n+      // Clear out pback buffer before going on to the real deal...\n+      streamsize __ret = 0;\n+      if (_M_pback_init)\n+\t{\n+\t  if (__n > 0 && this->gptr() == this->eback())\n+\t    {\n+\t      *__s++ = *this->gptr(); // emulate non-underflowing sbumpc\n+\t      this->gbump(1);\n+\t      __ret = 1;\n+\t      --__n;\n+\t    }\n+\t  _M_destroy_pback();\n+\t}\n+      else if (_M_writing)\n+\t{\n+ \t  if (overflow() == traits_type::eof())\n+ \t    return __ret;\n+ \t  _M_set_buffer(-1);\n+ \t  _M_writing = false;\n+ \t}\n+ \n+      // Optimization in the always_noconv() case, to be generalized in the\n+      // future: when __n > __buflen we read directly instead of using the\n+      // buffer repeatedly.\n+      const bool __testin = _M_mode & ios_base::in;\n+      const streamsize __buflen = _M_buf_size > 1 ? _M_buf_size - 1 : 1;\n+ \n+      if (__n > __buflen && __check_facet(_M_codecvt).always_noconv()\n+ \t   && __testin)\n+ \t {\n+ \t   // First, copy the chars already present in the buffer.\n+ \t   const streamsize __avail = this->egptr() - this->gptr();\n+ \t   if (__avail != 0)\n+ \t     {\n+ \t       if (__avail == 1)\n+ \t\t *__s = *this->gptr();\n+ \t       else\n+ \t\t traits_type::copy(__s, this->gptr(), __avail);\n+ \t       __s += __avail;\n+ \t       this->gbump(__avail);\n+ \t       __ret += __avail;\n+ \t       __n -= __avail;\n+ \t     }\n+ \n+ \t   // Need to loop in case of short reads (relatively common\n+ \t   // with pipes).\n+ \t   streamsize __len;\n+ \t   for (;;)\n+ \t     {\n+ \t       __len = _M_file.xsgetn(reinterpret_cast<char*>(__s),\n+ \t\t\t\t      __n);\n+ \t       if (__len == -1)\n+ \t\t __throw_ios_failure(__N(\"basic_filebuf::xsgetn \"\n+ \t\t\t\t\t \"error reading the file\"));\n+ \t       if (__len == 0)\n+ \t\t break;\n+ \n+ \t       __n -= __len;\n+ \t       __ret += __len;\n+ \t       if (__n == 0)\n+ \t\t break;\n+ \n+ \t       __s += __len;\n+ \t     }\n+ \n+ \t   if (__n == 0)\n+ \t     {\n+ \t       _M_set_buffer(0);\n+ \t       _M_reading = true;\n+ \t     }\n+ \t   else if (__len == 0)\n+ \t     {\n+ \t       // If end of file is reached, set 'uncommitted'\n+ \t       // mode, thus allowing an immediate write without\n+ \t       // an intervening seek.\n+ \t       _M_set_buffer(-1);\n+ \t       _M_reading = false;\n+ \t     }\n+ \t }\n+      else\n+ \t __ret += __streambuf_type::xsgetn(__s, __n);\n+ \n+      return __ret;\n+    }\n \n-       return __ret;\n-     }\n-\n-   template<typename _CharT, typename _Traits>\n-     streamsize\n-     basic_filebuf<_CharT, _Traits>::\n-     xsputn(const _CharT* __s, streamsize __n)\n-     {\n-       // Optimization in the always_noconv() case, to be generalized in the\n-       // future: when __n is sufficiently large we write directly instead of\n-       // using the buffer.\n-       streamsize __ret = 0;\n-       const bool __testout = _M_mode & ios_base::out;\n-       if (__check_facet(_M_codecvt).always_noconv()\n-\t   && __testout && !_M_reading)\n+  template<typename _CharT, typename _Traits>\n+    streamsize\n+    basic_filebuf<_CharT, _Traits>::\n+    xsputn(const _CharT* __s, streamsize __n)\n+    {\n+      streamsize __ret = 0;\n+      // Optimization in the always_noconv() case, to be generalized in the\n+      // future: when __n is sufficiently large we write directly instead of\n+      // using the buffer.\n+      const bool __testout = _M_mode & ios_base::out;\n+      if (__check_facet(_M_codecvt).always_noconv()\n+ \t   && __testout && !_M_reading)\n \t{\n \t  // Measurement would reveal the best choice.\n \t  const streamsize __chunk = 1ul << 10;\n@@ -933,7 +938,8 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n \t\t    {\n \t\t      // External position corresponding to gptr().\n \t\t      _M_ext_next = _M_ext_buf\n-\t\t\t+ _M_codecvt->length(_M_state_last, _M_ext_buf, _M_ext_next,\n+\t\t\t+ _M_codecvt->length(_M_state_last, _M_ext_buf,\n+\t\t\t\t\t     _M_ext_next,\n \t\t\t\t\t     this->gptr() - this->eback());\n \t\t      const streamsize __remainder = _M_ext_end - _M_ext_next;\n \t\t      if (__remainder)"}, {"sha": "a356d626e066267dd8e108b29b3e37ad149db183", "filename": "libstdc++-v3/testsuite/27_io/basic_filebuf/underflow/char/45841.cc", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47b90d6b3215bac43ff7134461cb03a4857b3143/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_filebuf%2Funderflow%2Fchar%2F45841.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47b90d6b3215bac43ff7134461cb03a4857b3143/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_filebuf%2Funderflow%2Fchar%2F45841.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_filebuf%2Funderflow%2Fchar%2F45841.cc?ref=47b90d6b3215bac43ff7134461cb03a4857b3143", "patch": "@@ -0,0 +1,41 @@\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-require-fileio \"\" }\n+\n+#include <fstream>\n+#include <testsuite_hooks.h>\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  using namespace std;\n+\n+  filebuf fb_in_out;\n+\n+  fb_in_out.open(\"tmp_underflow.tst\", ios::in | ios::out | ios::trunc);\n+\n+  VERIFY( fb_in_out.sputc('x') == 'x' );\n+  VERIFY( fb_in_out.sgetc() == filebuf::traits_type::eof() );\n+  fb_in_out.close();\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "2d7cb7af22a8b10f47996378f25b45f20da9a9cb", "filename": "libstdc++-v3/testsuite/27_io/basic_filebuf/underflow/wchar_t/45841.cc", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47b90d6b3215bac43ff7134461cb03a4857b3143/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_filebuf%2Funderflow%2Fwchar_t%2F45841.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47b90d6b3215bac43ff7134461cb03a4857b3143/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_filebuf%2Funderflow%2Fwchar_t%2F45841.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_filebuf%2Funderflow%2Fwchar_t%2F45841.cc?ref=47b90d6b3215bac43ff7134461cb03a4857b3143", "patch": "@@ -0,0 +1,41 @@\n+// Copyright (C) 2010 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-require-fileio \"\" }\n+\n+#include <fstream>\n+#include <testsuite_hooks.h>\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  using namespace std;\n+\n+  wfilebuf fb_in_out;\n+\n+  fb_in_out.open(\"tmp_underflow.tst\", ios::in | ios::out | ios::trunc);\n+\n+  VERIFY( fb_in_out.sputc(L'x') == L'x' );\n+  VERIFY( fb_in_out.sgetc() == wfilebuf::traits_type::eof() );\n+  fb_in_out.close();\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}]}