{"sha": "939b37da6ded55070bd78fc28d3fd2222b4278fa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTM5YjM3ZGE2ZGVkNTUwNzBiZDc4ZmMyOGQzZmQyMjIyYjQyNzhmYQ==", "commit": {"author": {"name": "Balaji V. Iyer", "email": "balaji.v.iyer@intel.com", "date": "2013-10-29T18:36:31Z"}, "committer": {"name": "Balaji V. Iyer", "email": "bviyer@gcc.gnu.org", "date": "2013-10-29T18:36:31Z"}, "message": "Added _Cilk_spawn and _Cilk_sync (2 cilk keywords) for C.\n\ngcc/ChangeLog:\n2013-10-29  Balaji V. Iyer  <balaji.v.iyer@intel.com>\n\n\t* builtins.c (is_builtin_name): Added a check for __cilkrts_detach and\n\t__cilkrts_pop_frame.  If matched, then return true for built-in\n\tfunction name.\n\t(expand_builtin): Added BUILT_IN_CILK_DETACH and\n\tBUILT_IN_CILK_POP_FRAME case.\n\t* langhooks-def.h (lhd_install_body_with_frame_cleanup): New prototype.\n\t(lhs_cilk_detect_spawn): Likewise.\n\t(LANG_HOOKS_DECLS): Added LANG_HOOKS_CILKPLUS.\n\t(LANG_HOOKS_CILKPLUS_DETECT_SPAWN_AND_UNWRAP): New #define.\n\t(LANG_HOOKS_CILKPLUS_FRAME_CLEANUP): Likewise.\n\t(LANG_HOOKS_CILKPLUS_GIMPLIFY_SPAWN): Likewise.\n\t(LANG_HOOKS_CILKPLUS): Likewise.\n\t* tree.h (CILK_SPAWN_FN): Likewise.\n\t* builtin.def (DEF_CILK_BUILTIN_STUB): Likewise.\n\t* Makefile.in (C_COMMON_OBJS): Added c-family/cilk.o.\n\t(OBJS): Added cilk-common.o.\n\t(CILK_H): Added a new define.\n\t(gimplify.o): Added CILK_H into dependency list.\n\t(builtins.o): Likewise.\n\t(ipa-inline.o): Likewise.\n\t(ipa-inline-analysis.o): Likewise.\n\t(BUILTINS_DEF): Added cilk-builtins.def.\n\t* langhooks.c (lhd_install_body_with_frame_cleanup): New function.\n\t(lhd_cilk_detect_spawn): Likewise.\n\t* langhooks.h (lang_hooks_for_cilkplus): New struct.\n\t(struct lang_hooks): Added new field called \"cilkplus.\"\n\t* cilk-common.c: New file.\n\t* cilk.h: Likewise.\n\t* cilk-builtins.def: Likewise.\n\t* cppbuiltin.c (define_builtin_macros_for_compilation_flags): Added\n\t\"__cilk\" macro and set it to 200.\n\t* function.h (struct function::cilk_frame_decl): New field.\n\t(struct function::is_cilk_function): Likewise.\n\t(struct function::calls_cilk_spawn): Likewise.\n\t* gimplify.c (gimplify_call_expr): Added a check if the function call\n\tbeing gimplified is a spawn detach point.  If so, then add pop_frame\n\tand detach function calls.\n\t(gimplify_expr): Added a CILK_SPAWN_STMT and CILK_SYNC_STMT case\n\tfor gimplifying _Cilk_spawn and _Cilk_sync statements.\n\t(gimplify_return_expr): Added a check for _Cilk_spawn usage in\n\tfunction.  If so, added a _Cilk_sync and gimplified it.\n\t(gimplify_modify_expr): Added a check for _Cilk_spawn in MODIFY and\n\tINIT_EXPRs.  If so, then call gimplify_cilk_spawn.\n\t* ipa-inline-analysis (initialize_inline_failed): Prevent inlining of\n\tspawner function.\n\t(can_inline_edge_p): Prevent inling of spawnee function.\n\t* ira.c (ira_setup_eliminable_regset): Force usage of frame pointer\n\tfor functions that use Cilk keywords.\n\t* tree-inline.h (struct copy_body_data::remap_var_for_cilk): New field.\n\t* tree-pretty-print.c (dump_generic_node): Added CILK_SPAWN_STMT and\n\tCILK_SYNC_STMT cases.\n\t* tree.def (DEFTREECODE): Added CILK_SPAWN_STMT and CILK_SYNC_STMT\n\ttrees.\n\t* generic.texi (CILK_SPAWN_STMT): Added documentation for _Cilk_spawn.\n\t(CILK_SYNC_STMT): Added documentation for _Cilk_sync.\n\t* passes.texi (Cilk Keywords): New section that describes the compiler\n\tcode changes for handling Cilk Keywords.\n\ngcc/c/ChangeLog:\n2013-10-29  Balaji V. Iyer  <balaji.v.iyer@intel.com>\n\n\t* c-decl.c (finish_function): Added a call for insert_cilk_frame when\n\ta spawning function is found.\n\t* c-objc-common.h (LANG_HOOKS_CILKPLUS_GIMPLIFY_SPAWN): New #define.\n\t(LANG_HOOKS_CILKPLUS_FRAME_CLEANUP): Likewise.\n\t(LANG_HOOKS_CILKPLUS_DETECT_SPAWN_AND_UNWRAP): Likewise.\n\t* c-parser.c (c_parser_statement_after_labels): Added RID_CILK_SYNC\n\tcase.\n\t(c_parser_postfix_expression): Added RID_CILK_SPAWN case.\n\t* c-typeck.c (build_compound_expr): Reject _Cilk_spawn in a comma\n\texpr.\n\t(c_finish_return): Added a check to reject _Cilk_spawn in return\n\texpression.\n\t(build_cilk_spawn): New function.\n\t(build_cilk_sync): Likewise.\n\t* Makefile.in (c-decl.o): Added cilk.h in dependency list.\n\ngcc/c-family/ChangeLog\n2013-10-29  Balaji V. Iyer  <balaji.v.iyer@intel.com>\n\n\t* c-common.c (c_common_reswords[]): Added _Cilk_spawn and _Cilk_sync\n\tfields.\n\t(c_define_builtins): Called cilk_init_builtins if Cilk Plus is\n\tenabled.\n\t* c-common.h (enum rid): Added RID_CILK_SPAWN and RID_CILK_SYNC.\n\t(insert_cilk_frame): New prototype.\n\t(cilk_init_builtins): Likewise.\n\t(gimplify_cilk_spawn): Likewise.\n\t(c_cilk_install_body_w_frame_cleanup): Likewise.\n\t(cilk_detect_spawn_and_unwrap): Likewise.\n\t(cilk_set_spawn_marker): Likewise.\n\t(build_cilk_sync): Likewise.\n\t(build_cilk_spawn): Likewise.\n\t* cilk.c: New file.\n\ngcc/lto/ChangeLog\n2013-10-29  Balaji V. Iyer  <balaji.v.iyer@intel.com>\n\n\t* Make-lang.in (lto/lto-lang.o): Added cilk.h in dependency list.\n\t* lto-lang.c (lto_init): Added a call to cilk_init_builtins if Cilk\n\tPlus is enabled.\n\ngcc/testsuite/ChangeLog\n2013-10-29  Balaji V. Iyer  <balaji.v.iyer@intel.com>\n\n\t* c-c++-common/cilk-plus/CK/compound_cilk_spawn.c: New test.\n\t* c-c++-common/cilk-plus/CK/concec_cilk_spawn.c: Likewise.\n\t* c-c++-common/cilk-plus/CK/fib.c: Likewise.\n\t* c-c++-common/cilk-plus/CK/no_args_error.c: Likewise.\n\t* c-c++-common/cilk-plus/CK/spawnee_inline.c: Likewise.\n\t* c-c++-common/cilk-plus/CK/spawner_inline.c: Likewise.\n\t* c-c++-common/cilk-plus/CK/spawning_arg.c: Likewise.\n\t* c-c++-common/cilk-plus/CK/steal_check.c: Likewise.\n\t* c-c++-common/cilk-plus/CK/test__cilk.c: Likewise.\n\t* c-c++-common/cilk-plus/CK/varargs_test.c: Likewise.\n\t* c-c++-common/cilk-plus/CK/sync_wo_spawn.c: Likewise.\n\t* c-c++-common/cilk-plus/CK/invalid_spawn.c: Likewise.\n\t* c-c++-common/cilk-plus/CK/spawn_in_return.c: Likewise.\n\t* c-c++-common/cilk-plus/CK/fib_init_expr_xy.c: Likewise.\n\t* c-c++-common/cilk-plus/CK/fib_no_sync.c: Likewise.\n\t* c-c++-common/cilk-plus/CK/fib_no_return.c: Likewise.\n\t* gcc.dg/cilk-plus/cilk-plus.exp: Added support to run Cilk Keywords\n\ttest stored in c-c++-common.  Also, added the Cilk runtime's library\n\tto the ld_library_path.\n\nFrom-SVN: r204172", "tree": {"sha": "14c7dd8b636c3ec3f3957e767f7e6ef4f3421824", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/14c7dd8b636c3ec3f3957e767f7e6ef4f3421824"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/939b37da6ded55070bd78fc28d3fd2222b4278fa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/939b37da6ded55070bd78fc28d3fd2222b4278fa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/939b37da6ded55070bd78fc28d3fd2222b4278fa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/939b37da6ded55070bd78fc28d3fd2222b4278fa/comments", "author": null, "committer": null, "parents": [{"sha": "67348ccc9ca5c667400851fa252a0e542847cb66", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/67348ccc9ca5c667400851fa252a0e542847cb66", "html_url": "https://github.com/Rust-GCC/gccrs/commit/67348ccc9ca5c667400851fa252a0e542847cb66"}], "stats": {"total": 3012, "additions": 3004, "deletions": 8}, "files": [{"sha": "625dc71d5d406a76503e93cafba3a392e3e6fa6f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/939b37da6ded55070bd78fc28d3fd2222b4278fa/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/939b37da6ded55070bd78fc28d3fd2222b4278fa/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=939b37da6ded55070bd78fc28d3fd2222b4278fa", "patch": "@@ -1,3 +1,58 @@\n+2013-10-29  Balaji V. Iyer  <balaji.v.iyer@intel.com>\n+\n+\t* builtins.c (is_builtin_name): Added a check for __cilkrts_detach and\n+\t__cilkrts_pop_frame.  If matched, then return true for built-in\n+\tfunction name.\n+\t(expand_builtin): Added BUILT_IN_CILK_DETACH and\n+\tBUILT_IN_CILK_POP_FRAME case.\n+\t* langhooks-def.h (lhd_install_body_with_frame_cleanup): New prototype.\n+\t(lhs_cilk_detect_spawn): Likewise.\n+\t(LANG_HOOKS_DECLS): Added LANG_HOOKS_CILKPLUS.\n+\t(LANG_HOOKS_CILKPLUS_DETECT_SPAWN_AND_UNWRAP): New #define.\n+\t(LANG_HOOKS_CILKPLUS_FRAME_CLEANUP): Likewise.\n+\t(LANG_HOOKS_CILKPLUS_GIMPLIFY_SPAWN): Likewise.\n+\t(LANG_HOOKS_CILKPLUS): Likewise.\n+\t* tree.h (CILK_SPAWN_FN): Likewise.\n+\t* builtin.def (DEF_CILK_BUILTIN_STUB): Likewise.\n+\t* Makefile.in (C_COMMON_OBJS): Added c-family/cilk.o.\n+\t(OBJS): Added cilk-common.o.\n+\t(BUILTINS_DEF): Added cilk-builtins.def.\n+\t* langhooks.c (lhd_install_body_with_frame_cleanup): New function.\n+\t(lhd_cilk_detect_spawn): Likewise.\n+\t* langhooks.h (lang_hooks_for_cilkplus): New struct.\n+\t(struct lang_hooks): Added new field called \"cilkplus.\"\n+\t* cilk-common.c: New file.\n+\t* cilk.h: Likewise.\n+\t* cilk-builtins.def: Likewise.\n+\t* cppbuiltin.c (define_builtin_macros_for_compilation_flags): Added\n+\t\"__cilk\" macro and set it to 200.\n+\t* function.h (struct function::cilk_frame_decl): New field.\n+\t(struct function::is_cilk_function): Likewise.\n+\t(struct function::calls_cilk_spawn): Likewise.\n+\t* gimplify.c (gimplify_call_expr): Added a check if the function call\n+\tbeing gimplified is a spawn detach point.  If so, then add pop_frame\n+\tand detach function calls.\n+\t(gimplify_expr): Added a CILK_SPAWN_STMT and CILK_SYNC_STMT case\n+\tfor gimplifying _Cilk_spawn and _Cilk_sync statements.\n+\t(gimplify_return_expr): Added a check for _Cilk_spawn usage in\n+\tfunction.  If so, added a _Cilk_sync and gimplified it.\n+\t(gimplify_modify_expr): Added a check for _Cilk_spawn in MODIFY and\n+\tINIT_EXPRs.  If so, then call gimplify_cilk_spawn.\n+\t* ipa-inline-analysis (initialize_inline_failed): Prevent inlining of\n+\tspawner function.\n+\t(can_inline_edge_p): Prevent inling of spawnee function.\n+\t* ira.c (ira_setup_eliminable_regset): Force usage of frame pointer\n+\tfor functions that use Cilk keywords.\n+\t* tree-inline.h (struct copy_body_data::remap_var_for_cilk): New field.\n+\t* tree-pretty-print.c (dump_generic_node): Added CILK_SPAWN_STMT and\n+\tCILK_SYNC_STMT cases.\n+\t* tree.def (DEFTREECODE): Added CILK_SPAWN_STMT and CILK_SYNC_STMT\n+\ttrees.\n+\t* generic.texi (CILK_SPAWN_STMT): Added documentation for _Cilk_spawn.\n+\t(CILK_SYNC_STMT): Added documentation for _Cilk_sync.\n+\t* passes.texi (Cilk Keywords): New section that describes the compiler\n+\tcode changes for handling Cilk Keywords.\n+\t\n 2013-10-29  David Malcolm  <dmalcolm@redhat.com>\n \n \tPatch autogenerated by refactor_symtab.py from"}, {"sha": "3e26d78eea2be826cf25e91305252e25b1f16bf3", "filename": "gcc/Makefile.in", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/939b37da6ded55070bd78fc28d3fd2222b4278fa/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/939b37da6ded55070bd78fc28d3fd2222b4278fa/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=939b37da6ded55070bd78fc28d3fd2222b4278fa", "patch": "@@ -872,7 +872,7 @@ RTL_H = $(RTL_BASE_H) $(FLAGS_H) genrtl.h\n READ_MD_H = $(OBSTACK_H) $(HASHTAB_H) read-md.h\n PARAMS_H = params.h params.def\n BUILTINS_DEF = builtins.def sync-builtins.def omp-builtins.def \\\n-\tgtm-builtins.def sanitizer.def cilkplus.def\n+\tgtm-builtins.def sanitizer.def cilkplus.def cilk-builtins.def\n INTERNAL_FN_DEF = internal-fn.def\n INTERNAL_FN_H = internal-fn.h $(INTERNAL_FN_DEF)\n TREE_CORE_H = tree-core.h coretypes.h all-tree.def tree.def \\\n@@ -1137,7 +1137,7 @@ C_COMMON_OBJS = c-family/c-common.o c-family/c-cppbuiltin.o c-family/c-dump.o \\\n   c-family/c-omp.o c-family/c-opts.o c-family/c-pch.o \\\n   c-family/c-ppoutput.o c-family/c-pragma.o c-family/c-pretty-print.o \\\n   c-family/c-semantics.o c-family/c-ada-spec.o \\\n-  c-family/array-notation-common.o c-family/c-ubsan.o\n+  c-family/array-notation-common.o c-family/cilk.o c-family/c-ubsan.o\n \n # Language-independent object files.\n # We put the insn-*.o files first so that a parallel make will build\n@@ -1182,6 +1182,7 @@ OBJS = \\\n \tcgraphbuild.o \\\n \tcgraphunit.o \\\n \tcgraphclones.o \\\n+\tcilk-common.o \\\n \tcombine.o \\\n \tcombine-stack-adj.o \\\n \tcompare-elim.o \\"}, {"sha": "cfe9be533b5373a0a69ce0fcde3a3b71d6f0a853", "filename": "gcc/builtins.c", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/939b37da6ded55070bd78fc28d3fd2222b4278fa/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/939b37da6ded55070bd78fc28d3fd2222b4278fa/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=939b37da6ded55070bd78fc28d3fd2222b4278fa", "patch": "@@ -49,6 +49,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"diagnostic-core.h\"\n #include \"builtins.h\"\n #include \"ubsan.h\"\n+#include \"cilk.h\"\n \n \n static tree do_mpc_arg1 (tree, tree, int (*)(mpc_ptr, mpc_srcptr, mpc_rnd_t));\n@@ -235,6 +236,10 @@ is_builtin_name (const char *name)\n     return true;\n   if (strncmp (name, \"__atomic_\", 9) == 0)\n     return true;\n+  if (flag_enable_cilkplus \n+      && (!strcmp (name, \"__cilkrts_detach\")   \n+\t  || !strcmp (name, \"__cilkrts_pop_frame\")))\n+    return true;\n   return false;\n }\n \n@@ -6685,6 +6690,14 @@ expand_builtin (tree exp, rtx target, rtx subtarget, enum machine_mode mode,\n       expand_builtin_set_thread_pointer (exp);\n       return const0_rtx;\n \n+    case BUILT_IN_CILK_DETACH:\n+      expand_builtin_cilk_detach (exp);\n+      return const0_rtx;\n+      \n+    case BUILT_IN_CILK_POP_FRAME:\n+      expand_builtin_cilk_pop_frame (exp);\n+      return const0_rtx;\n+\n     default:\t/* just do library call, if unknown builtin */\n       break;\n     }"}, {"sha": "12c56be5c5b0c0686d6d784b4ac41729381ff3cd", "filename": "gcc/builtins.def", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/939b37da6ded55070bd78fc28d3fd2222b4278fa/gcc%2Fbuiltins.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/939b37da6ded55070bd78fc28d3fd2222b4278fa/gcc%2Fbuiltins.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.def?ref=939b37da6ded55070bd78fc28d3fd2222b4278fa", "patch": "@@ -147,6 +147,13 @@ along with GCC; see the file COPYING3.  If not see\n                false, true, true, ATTRS, false, \\\n \t       (flag_openmp || flag_tree_parallelize_loops))\n \n+/* Builtin used by implementation of Cilk Plus.  Most of these are decomposed\n+   by the compiler but a few are implemented in libcilkrts.  */ \n+#undef DEF_CILK_BUILTIN_STUB\n+#define DEF_CILK_BUILTIN_STUB(ENUM, NAME) \\\n+  DEF_BUILTIN (ENUM, NAME, BUILT_IN_NORMAL, BT_LAST, BT_LAST, false, false, \\\n+\t       false, ATTR_LAST, false, false)\n+\n /* Builtin used by the implementation of GNU TM.  These\n    functions are mapped to the actual implementation of the STM library. */\n #undef DEF_TM_BUILTIN\n@@ -846,6 +853,9 @@ DEF_GCC_BUILTIN (BUILT_IN_LINE, \"LINE\", BT_FN_INT, ATTR_NOTHROW_LEAF_LIST)\n /* OpenMP builtins.  */\n #include \"omp-builtins.def\"\n \n+/* Cilk keywords builtins.  */\n+#include \"cilk-builtins.def\"\n+\n /* GTM builtins. */\n #include \"gtm-builtins.def\"\n "}, {"sha": "b9fed63105798d1b95f97b51892d6b0ad67d900c", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/939b37da6ded55070bd78fc28d3fd2222b4278fa/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/939b37da6ded55070bd78fc28d3fd2222b4278fa/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=939b37da6ded55070bd78fc28d3fd2222b4278fa", "patch": "@@ -1,3 +1,20 @@\n+2013-10-29  Balaji V. Iyer  <balaji.v.iyer@intel.com>\n+\n+\t* c-common.c (c_common_reswords[]): Added _Cilk_spawn and _Cilk_sync\n+\tfields.\n+\t(c_define_builtins): Called cilk_init_builtins if Cilk Plus is\n+\tenabled.\n+\t* c-common.h (enum rid): Added RID_CILK_SPAWN and RID_CILK_SYNC.\n+\t(insert_cilk_frame): New prototype.\n+\t(cilk_init_builtins): Likewise.\n+\t(gimplify_cilk_spawn): Likewise.\n+\t(c_cilk_install_body_w_frame_cleanup): Likewise.\n+\t(cilk_detect_spawn_and_unwrap): Likewise.\n+\t(cilk_set_spawn_marker): Likewise.\n+\t(build_cilk_sync): Likewise.\n+\t(build_cilk_spawn): Likewise.\n+\t* cilk.c: New file.\n+\n 2013-10-29  David Malcolm  <dmalcolm@redhat.com>\n \n \tPatch autogenerated by refactor_symtab.py from"}, {"sha": "647316839612f759a1fac801ac7e35f09e7cc00d", "filename": "gcc/c-family/c-common.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/939b37da6ded55070bd78fc28d3fd2222b4278fa/gcc%2Fc-family%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/939b37da6ded55070bd78fc28d3fd2222b4278fa/gcc%2Fc-family%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.c?ref=939b37da6ded55070bd78fc28d3fd2222b4278fa", "patch": "@@ -409,6 +409,8 @@ const struct c_common_resword c_common_reswords[] =\n   { \"_Alignof\",\t\tRID_ALIGNOF,   D_CONLY },\n   { \"_Bool\",\t\tRID_BOOL,      D_CONLY },\n   { \"_Complex\",\t\tRID_COMPLEX,\t0 },\n+  { \"_Cilk_spawn\",      RID_CILK_SPAWN, 0 },\n+  { \"_Cilk_sync\",       RID_CILK_SYNC,  0 },\n   { \"_Imaginary\",\tRID_IMAGINARY, D_CONLY },\n   { \"_Decimal32\",       RID_DFLOAT32,  D_CONLY | D_EXT },\n   { \"_Decimal64\",       RID_DFLOAT64,  D_CONLY | D_EXT },\n@@ -5219,6 +5221,9 @@ c_define_builtins (tree va_list_ref_type_node, tree va_list_arg_type_node)\n   targetm.init_builtins ();\n \n   build_common_builtin_nodes ();\n+\n+  if (flag_enable_cilkplus)\n+    cilk_init_builtins ();\n }\n \n /* Like get_identifier, but avoid warnings about null arguments when"}, {"sha": "8dd40c83e01a4306d04e10ce84061aab29cb2996", "filename": "gcc/c-family/c-common.h", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/939b37da6ded55070bd78fc28d3fd2222b4278fa/gcc%2Fc-family%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/939b37da6ded55070bd78fc28d3fd2222b4278fa/gcc%2Fc-family%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.h?ref=939b37da6ded55070bd78fc28d3fd2222b4278fa", "patch": "@@ -148,6 +148,9 @@ enum rid\n   /* C++11 */\n   RID_CONSTEXPR, RID_DECLTYPE, RID_NOEXCEPT, RID_NULLPTR, RID_STATIC_ASSERT,\n \n+  /* Cilk Plus keywords.  */\n+  RID_CILK_SPAWN, RID_CILK_SYNC,\n+  \n   /* Objective-C (\"AT\" reserved words - they are only keywords when\n      they follow '@')  */\n   RID_AT_ENCODE,   RID_AT_END,\n@@ -1356,4 +1359,18 @@ extern void cilkplus_extract_an_triplets (vec<tree, va_gc> *, size_t, size_t,\n \t\t\t\t\t  vec<vec<an_parts> > *);\n extern vec <tree, va_gc> *fix_sec_implicit_args\n   (location_t, vec <tree, va_gc> *, vec<an_loop_parts>, size_t, tree);\n+\n+/* In cilk.c.  */\n+extern tree insert_cilk_frame (tree);\n+extern void cilk_init_builtins (void);\n+extern int gimplify_cilk_spawn (tree *, gimple_seq *, gimple_seq *);\n+extern void c_cilk_install_body_w_frame_cleanup (tree, tree);\n+extern bool cilk_detect_spawn_and_unwrap (tree *);\n+extern bool cilk_set_spawn_marker (location_t, tree);\n+extern tree build_cilk_sync (void);\n+extern tree build_cilk_spawn (location_t, tree);\n+extern tree make_cilk_frame (tree);\n+extern tree create_cilk_function_exit (tree, bool, bool);\n+extern tree cilk_install_body_pedigree_operations (tree);\n+\n #endif /* ! GCC_C_COMMON_H */"}, {"sha": "91f10d5f283ae74bc7afe921aef8704b6cdefadb", "filename": "gcc/c-family/cilk.c", "status": "added", "additions": 1305, "deletions": 0, "changes": 1305, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/939b37da6ded55070bd78fc28d3fd2222b4278fa/gcc%2Fc-family%2Fcilk.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/939b37da6ded55070bd78fc28d3fd2222b4278fa/gcc%2Fc-family%2Fcilk.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fcilk.c?ref=939b37da6ded55070bd78fc28d3fd2222b4278fa", "patch": "@@ -0,0 +1,1305 @@\n+/* This file is part of the Intel(R) Cilk(TM) Plus support\n+   This file contains the CilkPlus Intrinsics\n+   Copyright (C) 2013 Free Software Foundation, Inc.\n+   Contributed by Balaji V. Iyer <balaji.v.iyer@intel.com>,\n+   Intel Corporation\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tree.h\"\n+#include \"langhooks.h\"\n+#include \"gimple.h\"\n+#include \"tree-iterator.h\"\n+#include \"tree-inline.h\"\n+#include \"c-family/c-common.h\"\n+#include \"toplev.h\" \n+#include \"cgraph.h\"\n+#include \"diagnostic.h\"\n+#include \"cilk.h\"\n+\n+enum add_variable_type {\n+    /* Reference to previously-defined variable.  */\n+    ADD_READ,\n+    /* Definition of a new variable in inner-scope.  */\n+    ADD_BIND,\n+    /* Write to possibly previously-defined variable.  */\n+    ADD_WRITE\n+};\n+\n+enum cilk_block_type {\n+    /* Indicates a _Cilk_spawn block.  30 was an arbitary number picked for \n+       ease of debugging.  */\n+    CILK_BLOCK_SPAWN = 30,\n+    /* Indicates _Cilk_for statement block.  */\n+    CILK_BLOCK_FOR\n+};\n+\n+struct wrapper_data\n+{\n+  /* Kind of function to be created.  */\n+  enum cilk_block_type type;\n+  /* Signature of helper function.  */\n+  tree fntype;\n+  /* Containing function.  */\n+  tree context;\n+  /* Disposition of all variables in the inner statement.  */\n+  struct pointer_map_t *decl_map;\n+  /* True if this function needs a static chain.  */\n+  bool nested;\n+  /* Arguments to be passed to wrapper function, currently a list.  */\n+  tree arglist;\n+  /* Argument types, a list.  */\n+  tree argtypes;\n+  /* Incoming parameters.  */\n+  tree parms;\n+  /* Outer BLOCK object.  */\n+  tree block;\n+};\n+\n+static void extract_free_variables (tree, struct wrapper_data *,\n+\t\t\t\t    enum add_variable_type);\n+static HOST_WIDE_INT cilk_wrapper_count;\n+\n+/* Marks the CALL_EXPR or FUNCTION_DECL, FCALL, as a spawned function call\n+   and the current function as a spawner.  Emit error if the function call\n+   is outside a function or if a non function-call is spawned.  */\n+\n+inline bool\n+cilk_set_spawn_marker (location_t loc, tree fcall)\n+{\n+  if (!current_function_decl)\n+    {\n+      error_at (loc, \"%<_Cilk_spawn%> may only be used inside a function\");\n+      return false;\n+    }\n+  else if (fcall == error_mark_node)\n+    /* Error reporting here is not necessary here since if FCALL is an\n+       error_mark_node, the function marking it as error would have reported\n+       it.  */\n+    return false; \n+  else if (TREE_CODE (fcall) != CALL_EXPR\n+\t   && TREE_CODE (fcall) != FUNCTION_DECL\n+\t   /* In C++, TARGET_EXPR is generated when we have an overloaded\n+\t      '=' operator.  */\n+\t   && TREE_CODE (fcall) != TARGET_EXPR)\n+    { \n+      error_at (loc, \"only function calls can be spawned\");\n+      return false;\n+    }\n+  else\n+    {\n+      cfun->calls_cilk_spawn = true;\n+      return true;\n+    }\n+}\n+\n+/* This function will output the exit conditions for a spawn call.  */\n+\n+tree\n+create_cilk_function_exit (tree frame, bool detaches, bool needs_sync)\n+{\n+  tree epi = alloc_stmt_list ();\n+\n+  if (needs_sync) \n+    append_to_statement_list (build_cilk_sync (), &epi);\n+  tree func_ptr = build1 (ADDR_EXPR, cilk_frame_ptr_type_decl, frame);\n+  tree pop_frame = build_call_expr (cilk_pop_fndecl, 1, func_ptr);\n+  tree worker = cilk_dot (frame, CILK_TI_FRAME_WORKER, 0);\n+  tree current = cilk_arrow (worker, CILK_TI_WORKER_CUR, 0);\n+  tree parent = cilk_dot (frame, CILK_TI_FRAME_PARENT, 0);\n+  tree set_current = build2 (MODIFY_EXPR, void_type_node, current, parent);\n+  append_to_statement_list (set_current, &epi);\n+  append_to_statement_list (pop_frame, &epi);\n+  tree call = build_call_expr (cilk_leave_fndecl, 1, func_ptr);\n+  if (!detaches)\n+    {\n+      tree flags = cilk_dot (frame, CILK_TI_FRAME_FLAGS, false);\n+      tree flags_cmp_expr = fold_build2 (NE_EXPR, TREE_TYPE (flags), flags, \n+\t\t\t\t\t build_int_cst (TREE_TYPE (flags), \n+\t\t\t\t\t\t\tCILK_FRAME_VERSION));\n+      call = fold_build3 (COND_EXPR, void_type_node, flags_cmp_expr,\n+\t\t\t  call, build_empty_stmt (EXPR_LOCATION (flags)));\n+    }\n+  append_to_statement_list (call, &epi);  \n+  return epi;\n+}\n+\n+/* Trying to get the correct cfun for the FUNCTION_DECL indicated by OUTER.  */\n+\n+static void\n+pop_cfun_to (tree outer)\n+{\n+  pop_cfun ();\n+  current_function_decl = outer;\n+  gcc_assert (cfun == DECL_STRUCT_FUNCTION (current_function_decl));\n+  gcc_assert (cfun->decl == current_function_decl);\n+}\n+\n+/* This function does whatever is necessary to make the compiler emit a newly \n+   generated function, FNDECL.  */\n+\n+static void\n+call_graph_add_fn (tree fndecl)\n+{\n+  const tree outer = current_function_decl;\n+  struct function *f = DECL_STRUCT_FUNCTION (fndecl);\n+  gcc_assert (TREE_CODE (fndecl) == FUNCTION_DECL);\n+\n+  f->is_cilk_function = 1;\n+  f->curr_properties = cfun->curr_properties;\n+  gcc_assert (cfun == DECL_STRUCT_FUNCTION (outer)); \n+  gcc_assert (cfun->decl == outer);\n+\n+  push_cfun (f);\n+  cgraph_create_node (fndecl);\n+  pop_cfun_to (outer);\n+}\n+\n+/* Return true if this is a tree which is allowed to contain a spawn as \n+   operand 0.\n+   A spawn call may be wrapped in a series of unary operations such\n+   as conversions.  These conversions need not be \"useless\"\n+   to be disregarded because they are retained in the spawned\n+   statement.  They are bypassed only to look for a spawn\n+   within.\n+   A comparison to constant is simple enough to allow, and\n+   is used to convert to bool.  */\n+\n+static bool\n+cilk_ignorable_spawn_rhs_op (tree exp)\n+{\n+  enum tree_code code = TREE_CODE (exp);\n+  switch (TREE_CODE_CLASS (code))\n+    {\n+    case tcc_expression:\n+      return code == ADDR_EXPR;\n+    case tcc_comparison:\n+      /* We need the spawn as operand 0 for now.   That's where it\n+\t appears in the only case we really care about, conversion\n+\t to bool.  */\n+      return (TREE_CODE (TREE_OPERAND (exp, 1)) == INTEGER_CST);\n+    case tcc_unary:\n+    case tcc_reference:\n+      return true;\n+    default:\n+      return false;\n+    }\n+}\n+\n+/* Helper function for walk_tree.  If *TP is a CILK_SPAWN_STMT, then unwrap\n+   this \"wrapper.\"  The function returns NULL_TREE regardless.  */\n+\n+static tree\n+unwrap_cilk_spawn_stmt (tree *tp, int *walk_subtrees, void *)\n+{\n+  if (TREE_CODE (*tp) == CILK_SPAWN_STMT)\n+    {\n+      *tp = CILK_SPAWN_FN (*tp);\n+      *walk_subtrees = 0;\n+    }\n+  return NULL_TREE;\n+}\n+\n+/* Returns true when EXP is a CALL_EXPR with _Cilk_spawn in front.  Unwraps\n+   CILK_SPAWN_STMT wrapper from the CALL_EXPR in *EXP0 statement.  */\n+\n+static bool\n+recognize_spawn (tree exp, tree *exp0)\n+{\n+  bool spawn_found = false;\n+  if (TREE_CODE (exp) == CILK_SPAWN_STMT)\n+    {\n+      /* Remove the CALL_EXPR from CILK_SPAWN_STMT wrapper.  */\n+      exp = CILK_SPAWN_FN (exp);\n+      walk_tree (exp0, unwrap_cilk_spawn_stmt, NULL, NULL);\n+      spawn_found = true;\n+    }\n+  return spawn_found;\n+}\n+\n+/* Returns true if *EXP0 is a recognized form of spawn.  Recognized forms are,\n+   after conversion to void, a call expression at outer level or an assignment\n+   at outer level with the right hand side being a spawned call.\n+   In addition to this, it also unwraps the CILK_SPAWN_STMT cover from the\n+   CALL_EXPR that is being spawned.\n+   Note that `=' in C++ may turn into a CALL_EXPR rather than a MODIFY_EXPR.  */\n+\n+bool\n+cilk_detect_spawn_and_unwrap (tree *exp0)\n+{\n+  tree exp = *exp0;\n+\n+  if (!TREE_SIDE_EFFECTS (exp))\n+    return false;\n+\n+  /* Strip off any conversion to void.  It does not affect whether spawn \n+     is supported here.  */\n+  if (TREE_CODE (exp) == CONVERT_EXPR && VOID_TYPE_P (TREE_TYPE (exp)))\n+    exp = TREE_OPERAND (exp, 0);\n+\n+  if (TREE_CODE (exp) == MODIFY_EXPR || TREE_CODE (exp) == INIT_EXPR)\n+    exp = TREE_OPERAND (exp, 1);\n+\n+  while (cilk_ignorable_spawn_rhs_op (exp))\n+    exp = TREE_OPERAND (exp, 0);\n+\n+  if (TREE_CODE (exp) == TARGET_EXPR)\n+    if (TARGET_EXPR_INITIAL (exp)\n+\t&& TREE_CODE (TARGET_EXPR_INITIAL (exp)) != AGGR_INIT_EXPR)\n+      exp = TARGET_EXPR_INITIAL (exp);\n+\n+  /* Happens with C++ TARGET_EXPR.  */\n+  if (exp == NULL_TREE)\n+    return false;\n+\n+  while (TREE_CODE (exp) == CLEANUP_POINT_EXPR || TREE_CODE (exp) == EXPR_STMT)\n+    exp = TREE_OPERAND (exp, 0);\n+  \n+  /* Now we should have a CALL_EXPR with a CILK_SPAWN_STMT wrapper around \n+     it, or return false.  */\n+  if (recognize_spawn (exp, exp0))\n+    return true;\n+  return false;\n+}\n+\n+/* This function will build and return a FUNCTION_DECL using information \n+   from *WD.  */\n+\n+static tree\n+create_cilk_helper_decl (struct wrapper_data *wd)\n+{\n+  char name[20];\n+  if (wd->type == CILK_BLOCK_FOR)\n+    sprintf (name, \"_cilk_for_%ld\", cilk_wrapper_count++);\n+  else if (wd->type == CILK_BLOCK_SPAWN)\n+    sprintf (name, \"_cilk_spn_%ld\", cilk_wrapper_count++);\n+  else\n+    gcc_unreachable (); \n+  \n+  clean_symbol_name (name);\n+  tree fndecl = build_decl (UNKNOWN_LOCATION, FUNCTION_DECL, \n+\t\t\t    get_identifier (name), wd->fntype);\n+\n+  TREE_PUBLIC (fndecl) = 0;\n+  TREE_STATIC (fndecl) = 1;\n+  TREE_USED (fndecl) = 1;\n+  DECL_ARTIFICIAL (fndecl) = 0;\n+  DECL_IGNORED_P (fndecl) = 0;\n+  DECL_EXTERNAL (fndecl) = 0;\n+\n+  DECL_CONTEXT (fndecl) = wd->context; \n+  tree block = make_node (BLOCK);\n+  DECL_INITIAL (fndecl) = block;\n+  TREE_USED (block) = 1;\n+  gcc_assert (!DECL_SAVED_TREE (fndecl));\n+\n+  /* Inlining would defeat the purpose of this wrapper.\n+     Either it secretly switches stack frames or it allocates\n+     a stable stack frame to hold function arguments even if\n+     the parent stack frame is stolen.  */\n+  DECL_UNINLINABLE (fndecl) = 1;\n+\n+  tree result_decl = build_decl (UNKNOWN_LOCATION, RESULT_DECL, NULL_TREE, \n+\t\t\t\t void_type_node);\n+  DECL_ARTIFICIAL (result_decl) = 0;\n+  DECL_IGNORED_P (result_decl) = 1;\n+  DECL_CONTEXT (result_decl) = fndecl;\n+  DECL_RESULT (fndecl) = result_decl;\n+  \n+  return fndecl;\n+}\n+\n+/* A function used by walk tree to find wrapper parms.  */\n+\n+static bool\n+wrapper_parm_cb (const void *key0, void **val0, void *data)\n+{\n+  struct wrapper_data *wd = (struct wrapper_data *) data;\n+  tree arg = * (tree *)&key0;\n+  tree val = (tree)*val0;\n+  tree parm;\n+\n+  if (val == error_mark_node || val == arg)\n+    return true;\n+\n+  if (TREE_CODE (val) == PAREN_EXPR)\n+    {\n+      /* We should not reach here with a register receiver.\n+\t We may see a register variable modified in the\n+\t argument list.  Because register variables are\n+\t worker-local we don't need to work hard to support\n+\t them in code that spawns.  */\n+      if ((TREE_CODE (arg) == VAR_DECL) && DECL_HARD_REGISTER (arg))\n+\t{\n+\t  error_at (EXPR_LOCATION (arg),\n+\t\t    \"explicit register variable %qD may not be modified in \"\n+\t\t    \"spawn\", arg);\n+\t  arg = null_pointer_node;\n+\t}\n+      else\n+\targ = build1 (ADDR_EXPR, build_pointer_type (TREE_TYPE (arg)), arg);\n+\t\n+      val = TREE_OPERAND (val, 0);\n+      *val0 = val;\n+      gcc_assert (TREE_CODE (val) == INDIRECT_REF);\n+      parm = TREE_OPERAND (val, 0);\n+      STRIP_NOPS (parm);\n+    }\n+  else\n+    parm = val;\n+  TREE_CHAIN (parm) = wd->parms;\n+  wd->parms = parm;\n+  wd->argtypes = tree_cons (NULL_TREE, TREE_TYPE (parm), wd->argtypes); \n+  wd->arglist = tree_cons (NULL_TREE, arg, wd->arglist); \n+  return true;\n+}\n+\n+/* This function is used to build a wrapper of a certain type.  */\n+\n+static void\n+build_wrapper_type (struct wrapper_data *wd)\n+{\n+  wd->arglist = NULL_TREE;\n+  wd->parms = NULL_TREE;\n+  wd->argtypes = void_list_node;\n+\n+  pointer_map_traverse (wd->decl_map, wrapper_parm_cb, wd);\n+  gcc_assert (wd->type != CILK_BLOCK_FOR);\n+\n+  /* Now build a function.\n+     Its return type is void (all side effects are via explicit parameters).\n+     Its parameters are WRAPPER_PARMS with type WRAPPER_TYPES.\n+     Actual arguments in the caller are WRAPPER_ARGS.  */\n+  wd->fntype = build_function_type (void_type_node, wd->argtypes);\n+}\n+\n+/* This function checks all the CALL_EXPRs in *TP found by cilk_outline.  */\n+\n+static tree\n+check_outlined_calls (tree *tp, int *walk_subtrees ATTRIBUTE_UNUSED, \n+\t\t      void *data)\n+{\n+  bool *throws = (bool *) data;\n+  tree t = *tp;\n+  int flags;\n+\n+  if (TREE_CODE (t) != CALL_EXPR)\n+    return 0;\n+  flags = call_expr_flags (t);\n+\n+  if (!(flags & ECF_NOTHROW) && flag_exceptions)\n+    *throws = true;\n+  if (flags & ECF_RETURNS_TWICE)\n+    error_at (EXPR_LOCATION (t), \n+\t      \"cannot spawn call to function that returns twice\");\n+  return 0;\n+}\n+\n+/* Each DECL in the source code (spawned statement) is passed to this function\n+   once.  Each instance of the DECL is replaced with the result of this \n+   function.\n+\n+   The parameters of the wrapper should have been entered into the map already.\n+   This function only deals with variables with scope limited to the \n+   spawned expression.  */\n+\n+static tree\n+copy_decl_for_cilk (tree decl, copy_body_data *id)\n+{\n+  switch (TREE_CODE (decl))\n+    {\n+    case VAR_DECL:\n+      return copy_decl_no_change (decl, id);\n+\n+    case LABEL_DECL:\n+      error_at (EXPR_LOCATION (decl), \"invalid use of label %q+D in \"\n+\t\t\"%<_Cilk_spawn%>\", \n+\t\tdecl);\n+      return error_mark_node;\n+\n+    case RESULT_DECL:\n+    case PARM_DECL:\n+      /* RESULT_DECL and PARM_DECL has already been entered into the map.  */\n+    default:\n+      gcc_unreachable ();\n+      return error_mark_node;\n+    }\n+}\n+\n+/* Copy all local variables.  */\n+\n+static bool\n+for_local_cb (const void *k_v, void **vp, void *p)\n+{\n+  tree k = *(tree *) &k_v;\n+  tree v = (tree) *vp;\n+\n+  if (v == error_mark_node)\n+    *vp = copy_decl_no_change (k, (copy_body_data *) p);\n+  return true;\n+}\n+\n+/* Copy all local declarations from a _Cilk_spawned function's body.  */\n+\n+static bool\n+wrapper_local_cb (const void *k_v, void **vp, void *data)\n+{\n+  copy_body_data *id = (copy_body_data *) data;\n+  tree key = *(tree *) &k_v;\n+  tree val = (tree) *vp;\n+\n+  if (val == error_mark_node)\n+    *vp = copy_decl_for_cilk (key, id);\n+\n+  return true;\n+}\n+\n+/* Alter a tree STMT from OUTER_FN to form the body of INNER_FN.  */\n+\n+static void\n+cilk_outline (tree inner_fn, tree *stmt_p, struct wrapper_data *wd)\n+{\n+  const tree outer_fn = wd->context;\t      \n+  const bool nested = (wd->type == CILK_BLOCK_FOR);\n+  copy_body_data id;\n+  bool throws;\n+\n+  DECL_STATIC_CHAIN (outer_fn) = 1;\n+\n+  memset (&id, 0, sizeof (id));\n+  /* Copy from the function containing the spawn...  */\n+  id.src_fn = outer_fn;\n+\n+  /* ...to the wrapper.  */\n+  id.dst_fn = inner_fn; \n+  id.src_cfun = DECL_STRUCT_FUNCTION (outer_fn);\n+\n+  /* There shall be no RETURN in spawn helper.  */\n+  id.retvar = 0; \n+  id.decl_map = wd->decl_map;\n+  id.copy_decl = nested ? copy_decl_no_change : copy_decl_for_cilk;\n+  id.block = DECL_INITIAL (inner_fn);\n+  id.transform_lang_insert_block = NULL;\n+\n+  id.transform_new_cfg = true;\n+  id.transform_call_graph_edges = CB_CGE_MOVE;\n+  id.remap_var_for_cilk = true;\n+  id.regimplify = true; /* unused? */\n+\n+  insert_decl_map (&id, wd->block, DECL_INITIAL (inner_fn));\n+\n+  /* We don't want the private variables any more.  */\n+  pointer_map_traverse (wd->decl_map, nested ? for_local_cb : wrapper_local_cb,\n+\t\t\t&id);\n+\n+  walk_tree (stmt_p, copy_tree_body_r, &id, NULL);\n+\n+  /* See if this function can throw or calls something that should\n+     not be spawned.  The exception part is only necessary if\n+     flag_exceptions && !flag_non_call_exceptions.  */\n+  throws = false ;\n+  (void) walk_tree_without_duplicates (stmt_p, check_outlined_calls, &throws);\n+}\n+\n+/* Generate the body of a wrapper function that assigns the\n+   result of the expression RHS into RECEIVER.  RECEIVER must\n+   be NULL if this is not a spawn -- the wrapper will return\n+   a value.  If this is a spawn, the wrapper will return void.  */\n+\n+static tree\n+create_cilk_wrapper_body (tree stmt, struct wrapper_data *wd)\n+{\n+  const tree outer = current_function_decl;\n+  tree fndecl;\n+  tree p;\n+\n+   /* Build the type of the wrapper and its argument list from the\n+     variables that it requires.  */\n+  build_wrapper_type (wd);\n+\n+  /* Emit a function that takes WRAPPER_PARMS incoming and applies ARGS \n+     (modified) to the wrapped function.  Return the wrapper and modified ARGS \n+     to the caller to generate a function call.  */\n+  fndecl = create_cilk_helper_decl (wd);\n+  push_struct_function (fndecl);\n+  if (wd->nested && (wd->type == CILK_BLOCK_FOR))\n+    {\n+      gcc_assert (TREE_VALUE (wd->arglist) == NULL_TREE);\n+      TREE_VALUE (wd->arglist) = build2 (FDESC_EXPR, ptr_type_node,\n+\t\t\t\t\t fndecl, integer_one_node);\n+    }\n+  DECL_ARGUMENTS (fndecl) = wd->parms;\n+\n+  for (p = wd->parms; p; p = TREE_CHAIN (p))\n+    DECL_CONTEXT (p) = fndecl;\n+\n+  cilk_outline (fndecl, &stmt, wd);\n+  stmt = fold_build_cleanup_point_expr (void_type_node, stmt);\n+  gcc_assert (!DECL_SAVED_TREE (fndecl));\n+  lang_hooks.cilkplus.install_body_with_frame_cleanup (fndecl, stmt);\n+  gcc_assert (DECL_SAVED_TREE (fndecl));\n+\n+  pop_cfun_to (outer);\n+\n+  /* Recognize the new function.  */\n+  call_graph_add_fn (fndecl);\n+  return fndecl;\n+}\n+\n+/* Initializes the wrapper data structure.  */\n+\n+static void\n+init_wd (struct wrapper_data *wd, enum cilk_block_type type)\n+{\n+  wd->type = type;\n+  wd->fntype = NULL_TREE;\n+  wd->context = current_function_decl;\n+  wd->decl_map = pointer_map_create ();\n+  /* _Cilk_for bodies are always nested.  Others start off as \n+     normal functions.  */\n+  wd->nested = (type == CILK_BLOCK_FOR);\n+  wd->arglist = NULL_TREE;\n+  wd->argtypes = NULL_TREE;\n+  wd->block = NULL_TREE;\n+}\n+\n+/* Clears the wrapper data structure.  */\n+\n+static void\n+free_wd (struct wrapper_data *wd)\n+{\n+  pointer_map_destroy (wd->decl_map);\n+  wd->nested = false;\n+  wd->arglist = NULL_TREE;\n+  wd->argtypes = NULL_TREE;\n+  wd->parms = NULL_TREE;\n+}\n+\n+\n+ /* Given a variable in an expression to be extracted into\n+   a helper function, declare the helper function parameter\n+   to receive it.\n+\n+   On entry the value of the (key, value) pair may be\n+\n+   (*, error_mark_node) -- Variable is private to helper function,\n+   do nothing.\n+\n+   (var, var) -- Reference to outer scope (function or global scope).\n+\n+   (var, integer 0) -- Capture by value, save newly-declared PARM_DECL\n+   for value in value slot.\n+\n+   (var, integer 1) -- Capture by reference, declare pointer to type\n+   as new PARM_DECL and store (spawn_stmt (indirect_ref (parm)).\n+   \n+   (var, ???) -- Pure output argument, handled similarly to above.\n+*/\n+\n+static bool\n+declare_one_free_variable (const void *var0, void **map0,\n+\t\t\t   void *data ATTRIBUTE_UNUSED)\n+{\n+  const_tree var = (const_tree) var0;\n+  tree map = (tree)*map0;\n+  tree var_type = TREE_TYPE (var), arg_type;\n+  bool by_reference;\n+  tree parm;\n+\n+  gcc_assert (DECL_P (var));\n+\n+  /* Ignore truly local variables.  */\n+  if (map == error_mark_node)\n+    return true;\n+  /* Ignore references to the parent function.  */\n+  if (map == var)\n+    return true;\n+\n+  gcc_assert (TREE_CODE (map) == INTEGER_CST);\n+\n+  /* A value is passed by reference if:\n+\n+     1. It is addressable, so that a copy may not be made.\n+     2. It is modified in the spawned statement.\n+     In the future this function may want to arrange\n+     a warning if the spawned statement is a loop body\n+     because an output argument would indicate a race.\n+     Note: Earlier passes must have marked the variable addressable.\n+     3. It is expensive to copy.  */\n+  by_reference =\n+    (TREE_ADDRESSABLE (var_type)\n+     /* Arrays must be passed by reference.  This is required for C\n+\tsemantics -- arrays are not first class objects.  Other\n+\taggregate types can and should be passed by reference if\n+\tthey are not passed to the spawned function.  We aren't yet\n+\tdistinguishing safe uses in argument calculation from unsafe\n+\tuses as outgoing function arguments, so we make a copy to\n+\tstabilize the value.  */\n+     || TREE_CODE (var_type) == ARRAY_TYPE\n+     || (tree) map == integer_one_node);\n+\n+  if (by_reference)\n+    var_type = build_qualified_type (build_pointer_type (var_type),\n+\t\t\t\t     TYPE_QUAL_RESTRICT);\n+  gcc_assert (!TREE_ADDRESSABLE (var_type));\n+\n+  /* Maybe promote to int.  */\n+  if (INTEGRAL_TYPE_P (var_type) && COMPLETE_TYPE_P (var_type)\n+      && INT_CST_LT_UNSIGNED (TYPE_SIZE (var_type),\n+\t\t\t      TYPE_SIZE (integer_type_node)))\n+    arg_type = integer_type_node;\n+  else\n+    arg_type = var_type;\n+\n+  parm = build_decl (UNKNOWN_LOCATION, PARM_DECL, NULL_TREE, var_type);\n+  DECL_ARG_TYPE (parm) = arg_type;\n+  DECL_ARTIFICIAL (parm) = 0;\n+  TREE_READONLY (parm) = 1;\n+  \n+  if (by_reference)\n+    {\n+      parm = build1 (INDIRECT_REF, TREE_TYPE (var_type), parm);\n+      parm = build1 (PAREN_EXPR, void_type_node, parm);\n+    }\n+  *map0 = parm;\n+  return true;\n+}\n+ \n+/* Returns a wrapper function for a _Cilk_spawn.  */\n+\n+static tree\n+create_cilk_wrapper (tree exp, tree *args_out)\n+{\n+  struct wrapper_data wd;\n+  tree fndecl;\n+\n+  init_wd (&wd, CILK_BLOCK_SPAWN);\n+\n+  if (TREE_CODE (exp) == CONVERT_EXPR)\n+    exp = TREE_OPERAND (exp, 0);\n+  \n+  /* Special handling for top level INIT_EXPR.  Usually INIT_EXPR means the \n+     variable is defined in the spawned expression and can be private to the \n+     spawn helper.  A top level INIT_EXPR defines a variable to be initialized \n+     by spawn and the variable must remain in the outer function.  */\n+  if (TREE_CODE (exp) == INIT_EXPR)\n+    {\n+      extract_free_variables (TREE_OPERAND (exp, 0), &wd, ADD_WRITE);\n+      extract_free_variables (TREE_OPERAND (exp, 1), &wd, ADD_READ);\n+      /* TREE_TYPE should be void.  Be defensive.  */\n+      if (TREE_TYPE (exp) != void_type_node)\n+\textract_free_variables (TREE_TYPE (exp), &wd, ADD_READ);\n+    }\n+  else\n+    extract_free_variables (exp, &wd, ADD_READ);\n+  pointer_map_traverse (wd.decl_map, declare_one_free_variable, &wd);\n+  wd.block = TREE_BLOCK (exp);\n+  if (!wd.block)\n+    wd.block = DECL_INITIAL (current_function_decl);\n+\n+  /* Now fvars maps the old variable to incoming variable.  Update\n+     the expression and arguments to refer to the new names.  */\n+  fndecl = create_cilk_wrapper_body (exp, &wd);\n+  *args_out = wd.arglist;\n+  \n+  free_wd (&wd);\n+\n+  return fndecl;\n+}\n+\n+/* Transform *SPAWN_P, a spawned CALL_EXPR, to gimple.  *SPAWN_P can be a\n+   CALL_EXPR, INIT_EXPR or MODIFY_EXPR.  Returns GS_OK if everything is fine,\n+   and GS_UNHANDLED, otherwise.  */\n+\n+int\n+gimplify_cilk_spawn (tree *spawn_p, gimple_seq *before ATTRIBUTE_UNUSED,\n+\t\t     gimple_seq *after ATTRIBUTE_UNUSED)\n+{\n+  tree expr = *spawn_p;\n+  tree function, call1, call2, new_args;\n+  tree ii_args = NULL_TREE;\n+  int total_args = 0, ii = 0;\n+  tree *arg_array;\n+  tree setjmp_cond_expr = NULL_TREE;\n+  tree setjmp_expr, spawn_expr, setjmp_value = NULL_TREE;\n+\n+  cfun->calls_cilk_spawn = 1;\n+  cfun->is_cilk_function = 1;\n+\n+  /* Remove CLEANUP_POINT_EXPR and EXPR_STMT from *spawn_p.  */\n+  while (TREE_CODE (expr) == CLEANUP_POINT_EXPR\n+\t || TREE_CODE (expr) == EXPR_STMT)\n+    expr = TREE_OPERAND (expr, 0);\n+  \n+  new_args = NULL;\n+  function = create_cilk_wrapper (expr, &new_args);\n+\n+  /* This should give the number of parameters.  */\n+  total_args = list_length (new_args);\n+  arg_array = XNEWVEC (tree, total_args);\n+\n+  ii_args = new_args;\n+  for (ii = 0; ii < total_args; ii++)\n+    {\n+      arg_array[ii] = TREE_VALUE (ii_args);\n+      ii_args = TREE_CHAIN (ii_args);\n+    }\n+  \n+  TREE_USED (function) = 1;\n+  rest_of_decl_compilation (function, 0, 0);\n+\n+  call1 = cilk_call_setjmp (cfun->cilk_frame_decl);\n+\n+  if (*arg_array == NULL_TREE)\n+    call2 = build_call_expr (function, 0);\n+  else \n+    call2 = build_call_expr_loc_array (EXPR_LOCATION (*spawn_p), function, \n+\t\t\t\t\t total_args, arg_array);\n+  *spawn_p = alloc_stmt_list ();\n+  tree f_ptr_type = build_pointer_type (TREE_TYPE (cfun->cilk_frame_decl));\n+  tree frame_ptr = build1 (ADDR_EXPR, f_ptr_type, cfun->cilk_frame_decl);\n+  tree save_fp = build_call_expr (cilk_save_fp_fndecl, 1, frame_ptr);\n+  append_to_statement_list (save_fp, spawn_p);\t\t  \n+  setjmp_value = create_tmp_var (TREE_TYPE (call1), NULL);\n+  setjmp_expr = fold_build2 (MODIFY_EXPR, void_type_node, setjmp_value, call1);\n+\n+  append_to_statement_list_force (setjmp_expr, spawn_p);\n+  \n+  setjmp_cond_expr = fold_build2 (EQ_EXPR, TREE_TYPE (call1), setjmp_value,\n+\t\t\t\t  build_int_cst (TREE_TYPE (call1), 0));\n+  spawn_expr = fold_build3 (COND_EXPR, void_type_node, setjmp_cond_expr,\n+\t\t\t    call2, build_empty_stmt (EXPR_LOCATION (call1)));\n+  append_to_statement_list (spawn_expr, spawn_p);\n+\n+  return GS_OK;\n+}\n+\n+/* Make the frames necessary for a spawn call.  */\n+\n+tree\n+make_cilk_frame (tree fn)\n+{\n+  struct function *f = DECL_STRUCT_FUNCTION (fn);\n+  tree decl;\n+\n+  if (f->cilk_frame_decl)\n+    return f->cilk_frame_decl;\n+\n+  decl = build_decl (EXPR_LOCATION (fn), VAR_DECL, NULL_TREE, \n+\t\t     cilk_frame_type_decl);\n+  DECL_CONTEXT (decl) = fn;\n+  DECL_SEEN_IN_BIND_EXPR_P (decl) = 1;\n+  f->cilk_frame_decl = decl;\n+  return decl;\n+}\n+\n+/* Returns a STATEMENT_LIST with all the pedigree operations required for\n+   install body with frame cleanup functions.  FRAME_PTR is the pointer to\n+   __cilkrts_stack_frame created by make_cilk_frame.  */\n+\n+tree\n+cilk_install_body_pedigree_operations (tree frame_ptr)\n+{\n+  tree body_list = alloc_stmt_list ();\n+  tree enter_frame = build_call_expr (cilk_enter_fast_fndecl, 1, frame_ptr); \n+  append_to_statement_list (enter_frame, &body_list);\n+  \n+  tree parent = cilk_arrow (frame_ptr, CILK_TI_FRAME_PARENT, 0);\n+  tree worker = cilk_arrow (frame_ptr, CILK_TI_FRAME_WORKER, 0);\n+\n+  tree pedigree = cilk_arrow (frame_ptr, CILK_TI_FRAME_PEDIGREE, 0);\n+  tree pedigree_rank = cilk_dot (pedigree, CILK_TI_PEDIGREE_RANK, 0);\n+  tree parent_pedigree = cilk_dot (pedigree, CILK_TI_PEDIGREE_PARENT, 0);\n+  tree pedigree_parent = cilk_arrow (parent, CILK_TI_FRAME_PEDIGREE, 0);\n+  tree pedigree_parent_rank = cilk_dot (pedigree_parent, \n+\t\t\t\t\tCILK_TI_PEDIGREE_RANK, 0);\n+  tree pedigree_parent_parent = cilk_dot (pedigree_parent, \n+\t\t\t\t     CILK_TI_PEDIGREE_PARENT, 0);\n+  tree worker_pedigree = cilk_arrow (worker, CILK_TI_WORKER_PEDIGREE, 1);\n+  tree w_pedigree_rank = cilk_dot (worker_pedigree, CILK_TI_PEDIGREE_RANK, 0);\n+  tree w_pedigree_parent = cilk_dot (worker_pedigree, \n+\t\t\t\t     CILK_TI_PEDIGREE_PARENT, 0);\n+\n+  /* sf.pedigree.rank = worker->pedigree.rank.  */\n+  tree exp1 = build2 (MODIFY_EXPR, void_type_node, pedigree_rank,\n+\t\t     w_pedigree_rank);\n+  append_to_statement_list (exp1, &body_list);\n+\n+  /* sf.pedigree.parent = worker->pedigree.parent.  */\n+  exp1 = build2 (MODIFY_EXPR, void_type_node, parent_pedigree,\n+\t\t w_pedigree_parent);\n+  append_to_statement_list (exp1, &body_list);\n+\n+  /* sf.call_parent->pedigree.rank = worker->pedigree.rank.  */\n+  exp1 = build2 (MODIFY_EXPR, void_type_node, pedigree_parent_rank,\n+\t\t w_pedigree_rank);\n+  append_to_statement_list (exp1, &body_list);\n+\n+  /* sf.call_parent->pedigree.parent = worker->pedigree.parent.  */\n+  exp1 = build2 (MODIFY_EXPR, void_type_node, pedigree_parent_parent,\n+\t\t w_pedigree_parent);\n+  append_to_statement_list (exp1, &body_list);\n+\n+  /* sf->worker.pedigree.rank = 0.  */\n+  exp1 = build2 (MODIFY_EXPR, void_type_node, w_pedigree_rank, \n+\t\t build_zero_cst (uint64_type_node));\n+  append_to_statement_list (exp1, &body_list);\n+\n+  /* sf->pedigree.parent = &sf->pedigree.  */\n+  exp1 = build2 (MODIFY_EXPR, void_type_node, w_pedigree_parent,\n+\t\t build1 (ADDR_EXPR,\n+\t\t\t build_pointer_type (cilk_pedigree_type_decl),\n+\t\t\t pedigree));\n+  append_to_statement_list (exp1, &body_list);\n+  return body_list;\n+}\n+\n+/* Inserts \"cleanup\" functions after the function-body of FNDECL.  FNDECL is a \n+   spawn-helper and BODY is the newly created body for FNDECL.  */\n+\n+void\n+c_cilk_install_body_w_frame_cleanup (tree fndecl, tree body)\n+{\n+  tree list = alloc_stmt_list ();\n+  tree frame = make_cilk_frame (fndecl);\n+  tree dtor = create_cilk_function_exit (frame, false, true);\n+  add_local_decl (cfun, frame);\n+  \n+  DECL_SAVED_TREE (fndecl) = list;\n+  tree frame_ptr = build1 (ADDR_EXPR, build_pointer_type (TREE_TYPE (frame)), \n+\t\t\t   frame);\n+  tree body_list = cilk_install_body_pedigree_operations (frame_ptr);\n+  gcc_assert (TREE_CODE (body_list) == STATEMENT_LIST);\n+  \n+  tree detach_expr = build_call_expr (cilk_detach_fndecl, 1, frame_ptr); \n+  append_to_statement_list (detach_expr, &body_list);\n+  append_to_statement_list (body, &body_list);\n+  append_to_statement_list (build_stmt (EXPR_LOCATION (body), TRY_FINALLY_EXPR,\n+\t\t\t\t       \tbody_list, dtor), &list);\n+}\n+\n+/* Add a new variable, VAR to a variable list in WD->DECL_MAP.  HOW indicates\n+   whether the variable is previously defined, currently defined, or a variable \n+   that is being written to.  */\n+\n+static void\n+add_variable (struct wrapper_data *wd, tree var, enum add_variable_type how)\n+{\n+  void **valp;\n+  \n+  valp = pointer_map_contains (wd->decl_map, (void *) var);\n+  if (valp)\n+    {\n+      tree val = (tree) *valp;\n+      /* If the variable is local, do nothing.  */\n+      if (val == error_mark_node)\n+\treturn;\n+      /* If the variable was entered with itself as value,\n+\t meaning it belongs to an outer scope, do not alter\n+\t the value.  */\n+      if (val == var) \n+\treturn;\n+      /* A statement expression may cause a variable to be\n+\t bound twice, once in BIND_EXPR and again in a\n+\t DECL_EXPR.  That case caused a return in the \n+\t test above.  Any other duplicate definition is\n+\t an error.  */\n+      gcc_assert (how != ADD_BIND);\n+      if (how != ADD_WRITE)\n+\treturn;\n+      /* This variable might have been entered as read but is now written.  */\n+      *valp = (void *) var;\n+      wd->nested = true;\n+      return;\n+    }\n+  else\n+    {\n+      tree val = NULL_TREE;\n+\n+      /* Nested function rewriting silently discards hard register\n+\t assignments for function scope variables, and they wouldn't\n+\t work anyway.  Warn here.  This misses one case: if the\n+\t register variable is used as the loop bound or increment it\n+\t has already been added to the map.  */\n+      if ((how != ADD_BIND) && (TREE_CODE (var) == VAR_DECL)\n+\t  && !DECL_EXTERNAL (var) && DECL_HARD_REGISTER (var))\n+\twarning (0, \"register assignment ignored for %qD used in Cilk block\",\n+\t\t var);\n+\n+      switch (how)\n+\t{\n+\t  /* ADD_BIND means always make a fresh new variable.  */\n+\tcase ADD_BIND:\n+\t  val = error_mark_node;\n+\t  break;\n+\t  /* ADD_READ means\n+\t     1. For cilk_for, refer to the outer scope definition as-is\n+\t     2. For a spawned block, take a scalar in an rgument\n+\t     and otherwise refer to the outer scope definition as-is.\n+\t     3. For a spawned call, take a scalar in an argument.  */\n+\tcase ADD_READ:\n+\t  switch (wd->type)\n+\t    {\n+\t    case CILK_BLOCK_FOR:\n+\t      val = var;\n+\t      break;\n+\t    case CILK_BLOCK_SPAWN:\n+\t      if (TREE_ADDRESSABLE (var))\n+\t\t{\n+\t\t  val = var;\n+\t\t  wd->nested = true;\n+\t\t  break;\n+\t\t}\n+\t      val = integer_zero_node;\n+\t      break;\n+\t    }\n+\t  break;\n+\tcase ADD_WRITE:\n+\t  switch (wd->type)\n+\t    {\n+\t    case CILK_BLOCK_FOR:\n+\t      val = var;\n+\t      wd->nested = true;\n+\t      break;\n+\t    case CILK_BLOCK_SPAWN:\n+\t      if (TREE_ADDRESSABLE (var))\n+\t\tval = integer_one_node;\n+\t      else\n+\t\t{\n+\t\t  val = var;\n+\t\t  wd->nested = true;\n+\t\t}\n+\t      break;\n+\t    }\n+\t}\n+      *pointer_map_insert (wd->decl_map, (void *) var) = val;\n+    }\n+}\n+\n+/* Find the variables referenced in an expression T.  This does not avoid \n+   duplicates because a variable may be read in one context and written in \n+   another.  HOW describes the context in which the reference is seen.  If \n+   NESTED is true a nested function is being generated and variables in the \n+   original context should not be remapped.  */\n+\n+static void\n+extract_free_variables (tree t, struct wrapper_data *wd,\n+\t\t\tenum add_variable_type how)\n+{  \n+  if (t == NULL_TREE)\n+    return;\n+\n+  enum tree_code code = TREE_CODE (t);\n+  bool is_expr = IS_EXPR_CODE_CLASS (TREE_CODE_CLASS (code));\n+\n+  if (is_expr)\n+    extract_free_variables (TREE_TYPE (t), wd, ADD_READ);\n+\n+  switch (code)\n+    {\n+    case ERROR_MARK:\n+    case IDENTIFIER_NODE:\n+    case INTEGER_CST:\n+    case REAL_CST:\n+    case FIXED_CST:\n+    case STRING_CST:\n+    case BLOCK:\n+    case PLACEHOLDER_EXPR:\n+    case FIELD_DECL:\n+    case VOID_TYPE:\n+    case REAL_TYPE:\n+      /* These do not contain variable references.  */\n+      return;\n+\n+    case SSA_NAME:\n+      /* Currently we don't see SSA_NAME.  */\n+      extract_free_variables (SSA_NAME_VAR (t), wd, how);\n+      return;\n+\n+    case LABEL_DECL:\n+      /* This might be a reference to a label outside the Cilk block,\n+\t which is an error, or a reference to a label in the Cilk block\n+\t that we haven't seen yet.  We can't tell.  Ignore it.  An\n+\t invalid use will cause an error later in copy_decl_for_cilk.  */\n+      return;\n+\n+    case RESULT_DECL:\n+      if (wd->type != CILK_BLOCK_SPAWN)\n+\tTREE_ADDRESSABLE (t) = 1;\n+    case VAR_DECL:\n+    case PARM_DECL:\n+      if (!TREE_STATIC (t) && !DECL_EXTERNAL (t))\n+\tadd_variable (wd, t, how);\n+      return;\n+\n+    case NON_LVALUE_EXPR:\n+    case CONVERT_EXPR:\n+    case NOP_EXPR:\n+      extract_free_variables (TREE_OPERAND (t, 0), wd, ADD_READ);\n+      return;\n+\n+    case INIT_EXPR:\n+      extract_free_variables (TREE_OPERAND (t, 0), wd, ADD_BIND);\n+      extract_free_variables (TREE_OPERAND (t, 1), wd, ADD_READ);\n+      return;\n+\n+    case MODIFY_EXPR:\n+    case PREDECREMENT_EXPR:\n+    case PREINCREMENT_EXPR:\n+    case POSTDECREMENT_EXPR:\n+    case POSTINCREMENT_EXPR:\n+      /* These write their result.  */\n+      extract_free_variables (TREE_OPERAND (t, 0), wd, ADD_WRITE);\n+      extract_free_variables (TREE_OPERAND (t, 1), wd, ADD_READ);\n+      return;\n+\n+    case ADDR_EXPR:\n+      /* This might modify its argument, and the value needs to be\n+\t passed by reference in any case to preserve identity and\n+\t type if is a promoting type.  In the case of a nested loop\n+\t just notice that we touch the variable.  It will already\n+\t be addressable, and marking it modified will cause a spurious\n+\t warning about writing the control variable.  */\n+      if (wd->type != CILK_BLOCK_SPAWN)\n+\textract_free_variables (TREE_OPERAND (t, 0), wd, ADD_READ);\n+      else \n+\textract_free_variables (TREE_OPERAND (t, 0), wd, ADD_WRITE);\n+      return;\n+\n+    case ARRAY_REF:\n+      /* Treating ARRAY_REF and BIT_FIELD_REF identically may\n+\t mark the array as written but the end result is correct\n+\t because the array is passed by pointer anyway.  */\n+    case BIT_FIELD_REF:\n+      /* Propagate the access type to the object part of which\n+\t is being accessed here.  As for ADDR_EXPR, don't do this\n+\t in a nested loop, unless the access is to a fixed index.  */\n+      if (wd->type != CILK_BLOCK_FOR || TREE_CONSTANT (TREE_OPERAND (t, 1)))\n+\textract_free_variables (TREE_OPERAND (t, 0), wd, how);\n+      else\n+\textract_free_variables (TREE_OPERAND (t, 0), wd, ADD_READ);\n+      extract_free_variables (TREE_OPERAND (t, 1), wd, ADD_READ);\n+      extract_free_variables (TREE_OPERAND (t, 2), wd, ADD_READ);\n+      return;\n+\n+    case TREE_LIST:\n+      extract_free_variables (TREE_PURPOSE (t), wd, ADD_READ);\n+      extract_free_variables (TREE_VALUE (t), wd, ADD_READ);\n+      extract_free_variables (TREE_CHAIN (t), wd, ADD_READ);\n+      return;\n+\n+    case TREE_VEC:\n+      {\n+\tint len = TREE_VEC_LENGTH (t);\n+\tint i;\n+\tfor (i = 0; i < len; i++)\n+\t  extract_free_variables (TREE_VEC_ELT (t, i), wd, ADD_READ);\n+\treturn;\n+      }\n+\n+    case VECTOR_CST:\n+      {\n+\tunsigned ii = 0;\n+\tfor (ii = 0; ii < VECTOR_CST_NELTS (t); ii++)\n+\t  extract_free_variables (VECTOR_CST_ELT (t, ii), wd, ADD_READ); \n+\tbreak;\n+      }\n+\n+    case COMPLEX_CST:\n+      extract_free_variables (TREE_REALPART (t), wd, ADD_READ);\n+      extract_free_variables (TREE_IMAGPART (t), wd, ADD_READ);\n+      return;\n+\n+    case BIND_EXPR:\n+      {\n+\ttree decl;\n+\tfor (decl = BIND_EXPR_VARS (t); decl; decl = TREE_CHAIN (decl))\n+\t  {\n+\t    add_variable (wd, decl, ADD_BIND);\n+\t    /* A self-referential initialization is no problem because\n+\t       we already entered the variable into the map as local.  */\n+\t    extract_free_variables (DECL_INITIAL (decl), wd, ADD_READ);\n+\t    extract_free_variables (DECL_SIZE (decl), wd, ADD_READ);\n+\t    extract_free_variables (DECL_SIZE_UNIT (decl), wd, ADD_READ);\n+\t  }\n+\textract_free_variables (BIND_EXPR_BODY (t), wd, ADD_READ);\n+\treturn;\n+      }\n+\n+    case STATEMENT_LIST:\n+      {\n+\ttree_stmt_iterator i;\n+\tfor (i = tsi_start (t); !tsi_end_p (i); tsi_next (&i))\n+\t  extract_free_variables (*tsi_stmt_ptr (i), wd, ADD_READ);\n+\treturn;\n+      }\n+\n+    case TARGET_EXPR:\n+      {\n+\textract_free_variables (TREE_OPERAND (t, 0), wd, ADD_BIND);\n+\textract_free_variables (TREE_OPERAND (t, 1), wd, ADD_READ);\n+\textract_free_variables (TREE_OPERAND (t, 2), wd, ADD_READ);\n+\tif (TREE_OPERAND (t, 3) != TREE_OPERAND (t, 1))\n+\t  extract_free_variables (TREE_OPERAND (t, 3), wd, ADD_READ);\n+\treturn;\n+      }\n+\n+    case RETURN_EXPR:\n+      if (TREE_NO_WARNING (t))\n+\t{\n+\t  gcc_assert (errorcount);\n+\t  return;\n+\t}\n+      return;\n+\n+    case DECL_EXPR:\n+      if (TREE_CODE (DECL_EXPR_DECL (t)) != TYPE_DECL)\n+\textract_free_variables (DECL_EXPR_DECL (t), wd, ADD_BIND);\n+      return;\n+\n+    case INTEGER_TYPE:\n+    case ENUMERAL_TYPE:\n+    case BOOLEAN_TYPE:\n+      extract_free_variables (TYPE_MIN_VALUE (t), wd, ADD_READ);\n+      extract_free_variables (TYPE_MAX_VALUE (t), wd, ADD_READ);\n+      return;\n+\n+    case POINTER_TYPE:\n+      extract_free_variables (TREE_TYPE (t), wd, ADD_READ);\n+      break;\n+\n+    case ARRAY_TYPE:\n+      extract_free_variables (TREE_TYPE (t), wd, ADD_READ);\n+      extract_free_variables (TYPE_DOMAIN (t), wd, ADD_READ);\n+      return;\n+\n+    case RECORD_TYPE:\n+      extract_free_variables (TYPE_FIELDS (t), wd, ADD_READ);\n+      return;\n+    \n+    case METHOD_TYPE:\n+      extract_free_variables (TYPE_ARG_TYPES (t), wd, ADD_READ);\n+      extract_free_variables (TYPE_METHOD_BASETYPE (t), wd, ADD_READ);\n+      return;\n+\n+    case AGGR_INIT_EXPR:\n+    case CALL_EXPR:\n+      {\n+\tint len = 0;\n+\tint ii = 0;\n+\tif (TREE_CODE (TREE_OPERAND (t, 0)) == INTEGER_CST)\n+\t  {\n+\t    len = TREE_INT_CST_LOW (TREE_OPERAND (t, 0));\n+\n+\t    for (ii = 0; ii < len; ii++)\n+\t      extract_free_variables (TREE_OPERAND (t, ii), wd, ADD_READ);\n+\t    extract_free_variables (TREE_TYPE (t), wd, ADD_READ);\n+\t  }\n+\tbreak;\n+      }\n+\n+    default:\n+      if (is_expr)\n+\t{\n+\t  int i, len;\n+\n+\t  /* Walk over all the sub-trees of this operand.  */\n+\t  len = TREE_CODE_LENGTH (code);\n+\n+\t  /* Go through the subtrees.  We need to do this in forward order so\n+\t     that the scope of a FOR_EXPR is handled properly.  */\n+\t  for (i = 0; i < len; ++i)\n+\t    extract_free_variables (TREE_OPERAND (t, i), wd, ADD_READ);\n+\t}\n+    }\n+}\n+\n+\n+/* Add appropriate frames needed for a Cilk spawned function call, FNDECL. \n+   Returns the __cilkrts_stack_frame * variable.  */\n+\n+tree\n+insert_cilk_frame (tree fndecl)\n+{\n+  tree addr, body, enter, out, orig_body;\n+  location_t loc = EXPR_LOCATION (fndecl);\n+\n+  if (!cfun || cfun->decl != fndecl)\n+    push_cfun (DECL_STRUCT_FUNCTION (fndecl)); \n+\n+  tree decl = cfun->cilk_frame_decl;\n+  if (!decl)\n+    {\n+      tree *saved_tree = &DECL_SAVED_TREE (fndecl);\n+      decl = make_cilk_frame (fndecl);\n+      add_local_decl (cfun, decl);\n+\n+      addr = build1 (ADDR_EXPR, cilk_frame_ptr_type_decl, decl);\n+      enter = build_call_expr (cilk_enter_fndecl, 1, addr);\n+      out = create_cilk_function_exit (cfun->cilk_frame_decl, false, true);\n+\n+      /* The new body will be:\n+\t __cilkrts_enter_frame_1 (&sf);\n+\t try {\n+\t    orig_body;\n+\t } \n+\t finally {\n+\t     __cilkrts_pop_frame (&sf);\n+\t     __cilkrts_leave_frame (&sf);\n+         }  */\n+\n+      body = alloc_stmt_list ();\n+      orig_body = *saved_tree;\n+\n+      if (TREE_CODE (orig_body) == BIND_EXPR)\n+\torig_body = BIND_EXPR_BODY (orig_body);\n+ \n+      append_to_statement_list (enter, &body);\n+      append_to_statement_list (build_stmt (loc, TRY_FINALLY_EXPR, orig_body, \n+\t\t\t\t\t    out), &body);\n+      if (TREE_CODE (*saved_tree) == BIND_EXPR)\n+\tBIND_EXPR_BODY (*saved_tree) = body;\n+      else\n+\t*saved_tree = body;\n+    }\n+  return decl;\n+}\n+\n+/* Wraps CALL, a CALL_EXPR, into a CILK_SPAWN_STMT tree and returns it.  */\n+\n+tree\n+build_cilk_spawn (location_t loc, tree call)\n+{\n+  if (!cilk_set_spawn_marker (loc, call))\n+    return error_mark_node;\n+  tree spawn_stmt = build1 (CILK_SPAWN_STMT, TREE_TYPE (call), call);\n+  TREE_SIDE_EFFECTS (spawn_stmt) = 1;\n+  return spawn_stmt;\n+}\n+\n+/* Returns a tree of type CILK_SYNC_STMT.  */\n+\n+tree\n+build_cilk_sync (void)\n+{\n+  tree sync = build0 (CILK_SYNC_STMT, void_type_node);\n+  TREE_SIDE_EFFECTS (sync) = 1;\n+  return sync;\n+}"}, {"sha": "ed60988a150dbcb11d312d0017f7b1da14b3c957", "filename": "gcc/c/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/939b37da6ded55070bd78fc28d3fd2222b4278fa/gcc%2Fc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/939b37da6ded55070bd78fc28d3fd2222b4278fa/gcc%2Fc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FChangeLog?ref=939b37da6ded55070bd78fc28d3fd2222b4278fa", "patch": "@@ -1,3 +1,21 @@\n+2013-10-29  Balaji V. Iyer  <balaji.v.iyer@intel.com>\n+\n+\t* c-decl.c (finish_function): Added a call for insert_cilk_frame when\n+\ta spawning function is found.\n+\t* c-objc-common.h (LANG_HOOKS_CILKPLUS_GIMPLIFY_SPAWN): New #define.\n+\t(LANG_HOOKS_CILKPLUS_FRAME_CLEANUP): Likewise.\n+\t(LANG_HOOKS_CILKPLUS_DETECT_SPAWN_AND_UNWRAP): Likewise.\n+\t* c-parser.c (c_parser_statement_after_labels): Added RID_CILK_SYNC\n+\tcase.\n+\t(c_parser_postfix_expression): Added RID_CILK_SPAWN case.\n+\t* c-typeck.c (build_compound_expr): Reject _Cilk_spawn in a comma\n+\texpr.\n+\t(c_finish_return): Added a check to reject _Cilk_spawn in return\n+\texpression.\n+\t(build_cilk_spawn): New function.\n+\t(build_cilk_sync): Likewise.\n+\t* Makefile.in (c-decl.o): Added cilk.h in dependency list.\n+\t\n 2013-10-27  Tobias Burnus  <burnus@net-b.de>\n \n \tPR other/33426"}, {"sha": "64718c552941802baff9f97d9da5812aaf2c614c", "filename": "gcc/c/c-decl.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/939b37da6ded55070bd78fc28d3fd2222b4278fa/gcc%2Fc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/939b37da6ded55070bd78fc28d3fd2222b4278fa/gcc%2Fc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-decl.c?ref=939b37da6ded55070bd78fc28d3fd2222b4278fa", "patch": "@@ -56,6 +56,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"pointer-set.h\"\n #include \"plugin.h\"\n #include \"c-family/c-ada-spec.h\"\n+#include \"cilk.h\"\n \n /* In grokdeclarator, distinguish syntactic contexts of declarators.  */\n enum decl_context\n@@ -8447,6 +8448,12 @@ finish_function (void)\n   /* Tie off the statement tree for this function.  */\n   DECL_SAVED_TREE (fndecl) = pop_stmt_list (DECL_SAVED_TREE (fndecl));\n \n+  /* If the function has _Cilk_spawn in front of a function call inside it\n+     i.e. it is a spawning function, then add the appropriate Cilk plus\n+     functions inside.  */\n+  if (fn_contains_cilk_spawn_p (cfun))\n+    cfun->cilk_frame_decl = insert_cilk_frame (fndecl);\n+\n   finish_fname_decls ();\n \n   /* Complain if there's just no return statement.  */"}, {"sha": "6ae7b3e0fb73b1ccef87b7d6a567ae00d2dfe533", "filename": "gcc/c/c-objc-common.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/939b37da6ded55070bd78fc28d3fd2222b4278fa/gcc%2Fc%2Fc-objc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/939b37da6ded55070bd78fc28d3fd2222b4278fa/gcc%2Fc%2Fc-objc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-objc-common.h?ref=939b37da6ded55070bd78fc28d3fd2222b4278fa", "patch": "@@ -105,4 +105,13 @@ along with GCC; see the file COPYING3.  If not see\n #undef LANG_HOOKS_TREE_INLINING_VAR_MOD_TYPE_P\n #define LANG_HOOKS_TREE_INLINING_VAR_MOD_TYPE_P c_vla_unspec_p\n \n+#undef  LANG_HOOKS_CILKPLUS_GIMPLIFY_SPAWN\n+#define LANG_HOOKS_CILKPLUS_GIMPLIFY_SPAWN gimplify_cilk_spawn\n+\n+#undef  LANG_HOOKS_CILKPLUS_FRAME_CLEANUP\n+#define LANG_HOOKS_CILKPLUS_FRAME_CLEANUP c_cilk_install_body_w_frame_cleanup\n+\n+#undef  LANG_HOOKS_CILKPLUS_DETECT_SPAWN_AND_UNWRAP\n+#define LANG_HOOKS_CILKPLUS_DETECT_SPAWN_AND_UNWRAP  \\\n+  cilk_detect_spawn_and_unwrap\n #endif /* GCC_C_OBJC_COMMON */"}, {"sha": "a8f4774136d3875e9af0e70d74631d50df6af403", "filename": "gcc/c/c-parser.c", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/939b37da6ded55070bd78fc28d3fd2222b4278fa/gcc%2Fc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/939b37da6ded55070bd78fc28d3fd2222b4278fa/gcc%2Fc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-parser.c?ref=939b37da6ded55070bd78fc28d3fd2222b4278fa", "patch": "@@ -4587,6 +4587,14 @@ c_parser_statement_after_labels (c_parser *parser)\n \tcase RID_FOR:\n \t  c_parser_for_statement (parser, false);\n \t  break;\n+\tcase RID_CILK_SYNC:\n+\t  c_parser_consume_token (parser);\n+\t  c_parser_skip_until_found (parser, CPP_SEMICOLON, \"expected %<;%>\");\n+\t  if (!flag_enable_cilkplus) \n+\t    error_at (loc, \"-fcilkplus must be enabled to use %<_Cilk_sync%>\");\n+\t  else \n+\t    add_stmt (build_cilk_sync ());\n+\t  break;\n \tcase RID_GOTO:\n \t  c_parser_consume_token (parser);\n \t  if (c_parser_next_token_is (parser, CPP_NAME))\n@@ -7174,6 +7182,30 @@ c_parser_postfix_expression (c_parser *parser)\n \tcase RID_GENERIC:\n \t  expr = c_parser_generic_selection (parser);\n \t  break;\n+\tcase RID_CILK_SPAWN:\n+\t  c_parser_consume_token (parser);\n+\t  if (!flag_enable_cilkplus)\n+\t    {\n+\t      error_at (loc, \"-fcilkplus must be enabled to use \"\n+\t\t\t\"%<_Cilk_spawn%>\");\n+\t      expr = c_parser_postfix_expression (parser);\n+\t      expr.value = error_mark_node;\t      \n+\t    }\n+\t  if (c_parser_peek_token (parser)->keyword == RID_CILK_SPAWN)\n+\t    {\n+\t      error_at (loc, \"consecutive %<_Cilk_spawn%> keywords \"\n+\t\t\t\"are not permitted\");\n+\t      /* Now flush out all the _Cilk_spawns.  */\n+\t      while (c_parser_peek_token (parser)->keyword == RID_CILK_SPAWN)\n+\t\tc_parser_consume_token (parser);\n+\t      expr = c_parser_postfix_expression (parser);\n+\t    }\n+\t  else\n+\t    {\n+\t      expr = c_parser_postfix_expression (parser);\n+\t      expr.value = build_cilk_spawn (loc, expr.value);\n+\t    }\n+\t  break; \n \tdefault:\n \t  c_parser_error (parser, \"expected expression\");\n \t  expr.value = error_mark_node;"}, {"sha": "1034cee1fcce50d4cae82e812a466ed91eab3452", "filename": "gcc/c/c-typeck.c", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/939b37da6ded55070bd78fc28d3fd2222b4278fa/gcc%2Fc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/939b37da6ded55070bd78fc28d3fd2222b4278fa/gcc%2Fc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-typeck.c?ref=939b37da6ded55070bd78fc28d3fd2222b4278fa", "patch": "@@ -4387,6 +4387,14 @@ build_compound_expr (location_t loc, tree expr1, tree expr2)\n   tree eptype = NULL_TREE;\n   tree ret;\n \n+  if (flag_enable_cilkplus\n+      && (TREE_CODE (expr1) == CILK_SPAWN_STMT\n+\t  || TREE_CODE (expr2) == CILK_SPAWN_STMT))\n+    {\n+      error_at (loc,\n+\t\t\"spawned function call cannot be part of a comma expression\");\n+      return error_mark_node;\n+    }\n   expr1_int_operands = EXPR_INT_CONST_OPERANDS (expr1);\n   if (expr1_int_operands)\n     expr1 = remove_c_maybe_const_expr (expr1);\n@@ -8694,6 +8702,12 @@ c_finish_return (location_t loc, tree retval, tree origtype)\n \t  return error_mark_node;\n \t}\n     }\n+  if (flag_enable_cilkplus && retval && TREE_CODE (retval) == CILK_SPAWN_STMT)\n+    {\n+      error_at (loc, \"use of %<_Cilk_spawn%> in a return statement is not \"\n+\t\t\"allowed\");\n+      return error_mark_node;\n+    }\n   if (retval)\n     {\n       tree semantic_type = NULL_TREE;"}, {"sha": "8634194d722da4a2cc237dc1abff828f01d32110", "filename": "gcc/cilk-builtins.def", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/939b37da6ded55070bd78fc28d3fd2222b4278fa/gcc%2Fcilk-builtins.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/939b37da6ded55070bd78fc28d3fd2222b4278fa/gcc%2Fcilk-builtins.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcilk-builtins.def?ref=939b37da6ded55070bd78fc28d3fd2222b4278fa", "patch": "@@ -0,0 +1,33 @@\n+/* This file contains the definitions and documentation for the\n+   Cilk Plus builtins used in the GNU compiler.\n+   Copyright (C) 2013 Free Software Foundation, Inc.\n+\n+   Contributed by Balaji V. Iyer <balaji.v.iyer@intel.com>\n+   \t          Intel Corporation.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+DEF_CILK_BUILTIN_STUB (BUILT_IN_CILK_ENTER_FRAME, \"__cilkrts_enter_frame_1\")\n+DEF_CILK_BUILTIN_STUB (BUILT_IN_CILK_ENTER_FRAME_FAST, \n+\t\t       \"__cilkrts_enter_frame_fast_1\")\n+DEF_CILK_BUILTIN_STUB (BUILT_IN_CILK_DETACH, \"__cilkrts_detach\")\n+DEF_CILK_BUILTIN_STUB (BUILT_IN_CILK_RETHROW, \"__cilkrts_rethrow\")\n+DEF_CILK_BUILTIN_STUB (BUILT_IN_CILK_SYNCHED, \"__cilkrts_synched\")\n+DEF_CILK_BUILTIN_STUB (BUILT_IN_CILK_SYNC, \"__cilkrts_sync\")\n+DEF_CILK_BUILTIN_STUB (BUILT_IN_CILK_LEAVE_FRAME, \"__cilkrts_leave_frame\")\n+DEF_CILK_BUILTIN_STUB (BUILT_IN_CILK_POP_FRAME, \"__cilkrts_pop_frame\")\n+DEF_CILK_BUILTIN_STUB (BUILT_IN_CILK_SAVE_FP, \"__cilkrts_save_fp_ctrl_state\")"}, {"sha": "ca178c00cd365f3e2d39924baf944154a1b160ea", "filename": "gcc/cilk-common.c", "status": "added", "additions": 484, "deletions": 0, "changes": 484, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/939b37da6ded55070bd78fc28d3fd2222b4278fa/gcc%2Fcilk-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/939b37da6ded55070bd78fc28d3fd2222b4278fa/gcc%2Fcilk-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcilk-common.c?ref=939b37da6ded55070bd78fc28d3fd2222b4278fa", "patch": "@@ -0,0 +1,484 @@\n+/* This file is part of the Intel(R) Cilk(TM) Plus support\n+   This file contains the CilkPlus Intrinsics\n+   Copyright (C) 2013 Free Software Foundation, Inc.\n+   Contributed by Balaji V. Iyer <balaji.v.iyer@intel.com>,\n+   Intel Corporation\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tree.h\"\n+#include \"langhooks.h\"\n+#include \"expr.h\"\n+#include \"optabs.h\"\n+#include \"recog.h\"\n+#include \"tree-iterator.h\"\n+#include \"gimple.h\"\n+#include \"cilk.h\"\n+\n+/* This structure holds all the important fields of the internal structures,\n+   internal built-in functions, and Cilk-specific data types.  Explanation of \n+   all the these fielsd are given in cilk.h.  */\n+tree cilk_trees[(int) CILK_TI_MAX];\n+\n+/* Returns the value in structure FRAME pointed by the FIELD_NUMBER\n+   (e.g. X.y).  \n+   FIELD_NUMBER is an index to the structure FRAME_PTR.  For details\n+   about these fields, refer to cilk_trees structure in cilk.h and\n+   cilk_init_builtins function  in this file.  Returns a TREE that is the type \n+   of the field represented by FIELD_NUMBER.  If VOLATIL parameter is set\n+   to true then the returning field is set as volatile.  */\n+\n+tree\n+cilk_dot (tree frame, int field_number, bool volatil)\n+{\n+  tree field = cilk_trees[field_number];\n+  field = fold_build3 (COMPONENT_REF, TREE_TYPE (field), frame, field, \n+\t\t       NULL_TREE);\n+  TREE_THIS_VOLATILE (field) = volatil;\n+  return field;\n+}\n+\n+/* Returns the address of a field in FRAME_PTR, pointed by FIELD_NUMBER.  \n+   (e.g. (&X)->y).   Please see cilk_dot function for explanation of the \n+   FIELD_NUMBER.  Returns a tree that is the type of the field represented \n+   by FIELD_NUMBER. If VOLATIL parameter is set to true then the returning\n+   field is set as volatile.  */\n+\n+tree\n+cilk_arrow (tree frame_ptr, int field_number, bool volatil)\n+{\n+  return cilk_dot (fold_build1 (INDIRECT_REF, \n+\t\t\t\tTREE_TYPE (TREE_TYPE (frame_ptr)), frame_ptr), \n+\t\t   field_number, volatil);\n+}\n+\n+\n+/* This function will add FIELD of type TYPE to a defined built-in \n+   structure.  *NAME is the name of the field to be added.  */\n+\n+static tree\n+add_field (const char *name, tree type, tree fields)\n+{\n+  tree t = get_identifier (name);\n+  tree field = build_decl (BUILTINS_LOCATION, FIELD_DECL, t, type);\n+  TREE_CHAIN (field) = fields;\n+  return field;\n+}\n+\n+/* This function will define a built-in function of NAME, of type FNTYPE and\n+   register it under the built-in function code CODE.  If PUBLISH is set then\n+   the declaration is pushed into the declaration list.  CODE is the index\n+   to the cilk_trees array.  *NAME is the name of the function to be added.  */\n+\n+static tree\n+install_builtin (const char *name, tree fntype, enum built_in_function code,\n+                 bool publish)\n+{\n+  tree fndecl = build_fn_decl (name, fntype);\n+  DECL_BUILT_IN_CLASS (fndecl) = BUILT_IN_NORMAL;\n+  DECL_FUNCTION_CODE (fndecl) = code;\n+  if (publish)\n+    {\n+      tree t = lang_hooks.decls.pushdecl (fndecl);\n+      if (t)\n+        fndecl = t;\n+    }\n+  set_builtin_decl (code, fndecl, true);\n+  return fndecl;\n+}\n+\n+/* Creates and initializes all the built-in Cilk keywords functions and three\n+   structures: __cilkrts_stack_frame, __cilkrts_pedigree and __cilkrts_worker.\n+   Detailed information about __cilkrts_stack_frame and\n+   __cilkrts_worker structures are given in libcilkrts/include/internal/abi.h.\n+   __cilkrts_pedigree is described in libcilkrts/include/cilk/common.h.  */\n+\n+void\n+cilk_init_builtins (void)\n+{\n+  /* Now build the following __cilkrts_pedigree struct:\n+     struct __cilkrts_pedigree {\n+        uint64_t rank;\n+        struct __cilkrts_pedigree *parent;\n+      }  */\n+       \n+  tree pedigree_type = lang_hooks.types.make_type (RECORD_TYPE);\n+  tree pedigree_ptr  = build_pointer_type (pedigree_type);\n+  tree field = add_field (\"rank\", uint64_type_node, NULL_TREE);\n+  cilk_trees[CILK_TI_PEDIGREE_RANK] = field;\n+  field = add_field (\"parent\", pedigree_ptr, field);\n+  cilk_trees[CILK_TI_PEDIGREE_PARENT] = field;\n+  finish_builtin_struct (pedigree_type, \"__cilkrts_pedigree_GCC\", field,\n+\t\t\t NULL_TREE);\n+  lang_hooks.types.register_builtin_type (pedigree_type,\n+\t\t\t\t\t  \"__cilkrts_pedigree_t\");\n+  cilk_pedigree_type_decl = pedigree_type; \n+  \n+  /* Build the Cilk Stack Frame:\n+     struct __cilkrts_stack_frame {\n+       uint32_t flags;\n+       uint32_t size;\n+       struct __cilkrts_stack_frame *call_parent;\n+       __cilkrts_worker *worker;\n+       void *except_data;\n+       void *ctx[4];\n+       uint32_t mxcsr;\n+       uint16_t fpcsr;\n+       uint16_t reserved;\n+       __cilkrts_pedigree pedigree;\n+     };  */\n+\n+  tree frame = lang_hooks.types.make_type (RECORD_TYPE);\n+  tree frame_ptr = build_pointer_type (frame);\n+  tree worker_type = lang_hooks.types.make_type (RECORD_TYPE);\n+  tree worker_ptr = build_pointer_type (worker_type);\n+  tree s_type_node = build_int_cst (size_type_node, 4);\n+\n+  tree flags = add_field (\"flags\", uint32_type_node, NULL_TREE);\n+  tree size = add_field (\"size\", uint32_type_node, flags);\n+  tree parent = add_field (\"call_parent\", frame_ptr, size);\n+  tree worker = add_field (\"worker\", worker_ptr, parent);\n+  tree except = add_field (\"except_data\", frame_ptr, worker);\n+  tree context = add_field (\"ctx\",\n+\t\t\t    build_array_type (ptr_type_node,\n+\t\t\t\t\t      build_index_type (s_type_node)),\n+\t\t\t    except);\n+  tree mxcsr = add_field (\"mxcsr\", uint32_type_node, context);\n+  tree fpcsr = add_field (\"fpcsr\", uint16_type_node, mxcsr);\n+  tree reserved = add_field (\"reserved\", uint16_type_node, fpcsr);\n+  tree pedigree = add_field (\"pedigree\", pedigree_type, reserved);\n+  \n+  /* Now add them to a common structure whose fields are #defined to something\n+     that is used at a later stage.  */\n+  cilk_trees[CILK_TI_FRAME_FLAGS] = flags;\n+  cilk_trees[CILK_TI_FRAME_PARENT] = parent;\n+  cilk_trees[CILK_TI_FRAME_WORKER] = worker;\n+  cilk_trees[CILK_TI_FRAME_EXCEPTION] = except;\n+  cilk_trees[CILK_TI_FRAME_CONTEXT] = context;\n+  /* We don't care about reserved, so no need to store it in cilk_trees.  */\n+  cilk_trees[CILK_TI_FRAME_PEDIGREE] = pedigree;\n+  TREE_ADDRESSABLE (frame) = 1;\n+\n+  finish_builtin_struct (frame, \"__cilkrts_st_frame_GCC\", pedigree, NULL_TREE);\n+  cilk_frame_type_decl = frame;\n+  lang_hooks.types.register_builtin_type (frame, \"__cilkrts_frame_t\");\n+\n+  cilk_frame_ptr_type_decl = build_qualified_type (frame_ptr,\n+\t\t\t\t\t\t   TYPE_QUAL_VOLATILE);\n+  /* Now let's do the following worker struct:\n+\n+     struct __cilkrts_worker {\n+       __cilkrts_stack_frame *volatile *volatile tail;\n+       __cilkrts_stack_frame *volatile *volatile head;\n+       __cilkrts_stack_frame *volatile *volatile exc;\n+       __cilkrts_stack_frame *volatile *volatile protected_tail;\n+       __cilkrts_stack_frame *volatile *ltq_limit;\n+       int32_t self;\n+       global_state_t *g;\n+       local_state *l;\n+       cilkred_map *reducer_map;\n+       __cilkrts_stack_frame *current_stack_frame;\n+       void *reserved;\n+       __cilkrts_worker_sysdep_state *sysdep;\n+       __cilkrts_pedigree pedigree;\n+    }   */\n+\n+  tree fptr_volatil_type = build_qualified_type (frame_ptr, TYPE_QUAL_VOLATILE);\n+  tree fptr_volatile_ptr = build_pointer_type (fptr_volatil_type);\n+  tree fptr_vol_ptr_vol = build_qualified_type (fptr_volatile_ptr,\n+\t\t\t\t\t\tTYPE_QUAL_VOLATILE);\n+  tree g = lang_hooks.types.make_type (RECORD_TYPE);\n+  finish_builtin_struct (g, \"__cilkrts_global_state\", NULL_TREE, NULL_TREE);\n+  tree l = lang_hooks.types.make_type (RECORD_TYPE);\n+  finish_builtin_struct (l, \"__cilkrts_local_state\", NULL_TREE, NULL_TREE);\n+  tree sysdep_t = lang_hooks.types.make_type (RECORD_TYPE);\n+  finish_builtin_struct (sysdep_t, \"__cilkrts_worker_sysdep_state\", NULL_TREE,\n+\t\t\t NULL_TREE);\n+  \n+  field = add_field (\"tail\", fptr_vol_ptr_vol, NULL_TREE);\n+  cilk_trees[CILK_TI_WORKER_TAIL] = field;\n+  field = add_field (\"head\", fptr_vol_ptr_vol, field);\n+  field  = add_field (\"exc\", fptr_vol_ptr_vol, field);\n+  field = add_field (\"protected_tail\", fptr_vol_ptr_vol, field);\n+  field = add_field (\"ltq_limit\", fptr_volatile_ptr, field);\n+  field = add_field (\"self\", integer_type_node, field);\n+  field = add_field (\"g\", build_pointer_type (g), field);\n+  field = add_field (\"l\", build_pointer_type (g), field);\n+  field = add_field (\"reducer_map\", ptr_type_node, field);\n+  field = add_field (\"current_stack_frame\", frame_ptr, field);\n+  cilk_trees[CILK_TI_WORKER_CUR] = field;\n+  field = add_field (\"saved_protected_tail\", fptr_volatile_ptr, field);\n+  field = add_field (\"sysdep\", build_pointer_type (sysdep_t), field);\n+  field = add_field (\"pedigree\", pedigree_type, field);\n+  cilk_trees[CILK_TI_WORKER_PEDIGREE] = field;\n+  finish_builtin_struct (worker_type, \"__cilkrts_worker_GCC\", field,\n+\t\t\t NULL_TREE);\n+\n+  tree fptr_arglist = tree_cons (NULL_TREE, frame_ptr, void_list_node);\n+  tree fptr_fun = build_function_type (void_type_node, fptr_arglist);\n+  \n+  /* void __cilkrts_enter_frame_1 (__cilkrts_stack_frame *);  */\n+  cilk_enter_fndecl = install_builtin (\"__cilkrts_enter_frame_1\", fptr_fun,\n+\t\t\t\t       BUILT_IN_CILK_ENTER_FRAME, false);\n+\n+  /* void __cilkrts_enter_frame_fast_1 (__cilkrts_stack_frame *);  */\n+  cilk_enter_fast_fndecl = \n+    install_builtin (\"__cilkrts_enter_frame_fast_1\", fptr_fun, \n+\t\t     BUILT_IN_CILK_ENTER_FRAME_FAST, false);\n+  \n+  /* void __cilkrts_pop_frame (__cilkrts_stack_frame *);  */\n+  cilk_pop_fndecl = install_builtin (\"__cilkrts_pop_frame\", fptr_fun,\n+\t\t\t\t     BUILT_IN_CILK_POP_FRAME, false);\n+\n+  /* void __cilkrts_leave_frame (__cilkrts_stack_frame *);  */\n+  cilk_leave_fndecl = install_builtin (\"__cilkrts_leave_frame\", fptr_fun,\n+\t\t\t\t       BUILT_IN_CILK_LEAVE_FRAME, false);\n+\n+  /* void __cilkrts_sync (__cilkrts_stack_frame *);  */\n+  cilk_sync_fndecl = install_builtin (\"__cilkrts_sync\", fptr_fun,\n+\t\t\t\t      BUILT_IN_CILK_SYNC, false);\n+\n+  /* void __cilkrts_detach (__cilkrts_stack_frame *);  */\n+  cilk_detach_fndecl = install_builtin (\"__cilkrts_detach\", fptr_fun,\n+\t\t\t\t\tBUILT_IN_CILK_DETACH, false);\n+\n+  /* __cilkrts_rethrow (struct stack_frame *);  */\n+  cilk_rethrow_fndecl = install_builtin (\"__cilkrts_rethrow\", fptr_fun, \n+\t\t\t\t\t BUILT_IN_CILK_RETHROW, false);\n+\n+  /* __cilkrts_save_fp_ctrl_state (__cilkrts_stack_frame *);  */\n+  cilk_save_fp_fndecl = install_builtin (\"__cilkrts_save_fp_ctrl_state\", \n+\t\t\t\t\t fptr_fun, BUILT_IN_CILK_SAVE_FP,\n+\t\t\t\t\t false);\n+}\n+\n+/* Get the appropriate frame arguments for CALL that is of type CALL_EXPR.  */\n+\n+static tree\n+get_frame_arg (tree call)\n+{\n+  tree arg, argtype;\n+\n+  gcc_assert (call_expr_nargs (call) >= 1);\n+    \n+  arg = CALL_EXPR_ARG (call, 0);\n+  argtype = TREE_TYPE (arg);\n+  gcc_assert (TREE_CODE (argtype) == POINTER_TYPE);\n+\n+  argtype = TREE_TYPE (argtype);\n+  \n+  gcc_assert (!lang_hooks.types_compatible_p\n+\t      || lang_hooks.types_compatible_p (argtype, cilk_frame_type_decl));\n+\n+  /* If it is passed in as an address, then just use the value directly \n+     since the function is inlined.  */\n+  if (TREE_CODE (arg) == INDIRECT_REF || TREE_CODE (arg) == ADDR_EXPR)\n+    return TREE_OPERAND (arg, 0);\n+  return arg;\n+}\n+\n+/* Expands the __cilkrts_pop_frame function call stored in EXP.  */\n+\n+void\n+expand_builtin_cilk_pop_frame (tree exp)\n+{\n+  tree frame = get_frame_arg (exp);\n+  tree parent = cilk_dot (frame, CILK_TI_FRAME_PARENT, 0);\n+\n+  tree clear_parent = build2 (MODIFY_EXPR, void_type_node, parent,\n+\t\t\t      build_int_cst (TREE_TYPE (parent), 0));\n+  expand_expr (clear_parent, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+\n+  /* During LTO, the is_cilk_function flag gets cleared.\n+     If __cilkrts_pop_frame is called, then this definitely must be a\n+     cilk function.  */\n+  if (cfun)\n+    cfun->is_cilk_function = 1;\n+}\n+\n+/* Expands the cilk_detach function call stored in EXP.  */\n+\n+void\n+expand_builtin_cilk_detach (tree exp)\n+{\n+  rtx insn;\n+  tree fptr = get_frame_arg (exp);\n+\n+  if (fptr == NULL_TREE)\n+    return;\n+\n+  tree parent = cilk_dot (fptr, CILK_TI_FRAME_PARENT, 0);\n+  tree worker = cilk_dot (fptr, CILK_TI_FRAME_WORKER, 0);\n+  tree tail = cilk_dot (worker, CILK_TI_WORKER_TAIL, 1);\n+\n+  rtx wreg = expand_expr (worker, NULL_RTX, Pmode, EXPAND_NORMAL);\n+  if (GET_CODE (wreg) != REG)\n+    wreg = copy_to_reg (wreg);\n+  rtx preg = expand_expr (parent, NULL_RTX, Pmode, EXPAND_NORMAL);\n+\n+  /* TMP <- WORKER.TAIL\n+    *TMP <- PARENT\n+     TMP <- TMP + 1\n+     WORKER.TAIL <- TMP   */\n+\n+  HOST_WIDE_INT worker_tail_offset =\n+    tree_low_cst (DECL_FIELD_OFFSET (cilk_trees[CILK_TI_WORKER_TAIL]), 0) +\n+    tree_low_cst (DECL_FIELD_BIT_OFFSET (cilk_trees[CILK_TI_WORKER_TAIL]), 0) /\n+    BITS_PER_UNIT;\n+  rtx tmem0 = gen_rtx_MEM (Pmode,\n+\t\t\t   plus_constant (Pmode, wreg, worker_tail_offset));\n+  set_mem_attributes (tmem0, tail, 0);\n+  MEM_NOTRAP_P (tmem0) = 1;\n+  gcc_assert (MEM_VOLATILE_P (tmem0));\n+  rtx treg = copy_to_mode_reg (Pmode, tmem0);\n+  rtx tmem1 = gen_rtx_MEM (Pmode, treg);\n+  set_mem_attributes (tmem1, TREE_TYPE (TREE_TYPE (tail)), 0);\n+  MEM_NOTRAP_P (tmem1) = 1;\n+  emit_move_insn (tmem1, preg);\n+  emit_move_insn (treg, plus_constant (Pmode, treg, GET_MODE_SIZE (Pmode)));\n+\n+  /* There is a release barrier (st8.rel, membar #StoreStore,\n+     sfence, lwsync, etc.) between the two stores.  On x86\n+     normal volatile stores have proper semantics; the sfence\n+     would only be needed for nontemporal stores (which we\n+     could generate using the storent optab, for no benefit\n+     in this case).\n+\n+     The predicate may return false even for a REG if this is\n+     the limited release operation that only stores 0.  */\n+  enum insn_code icode = direct_optab_handler (sync_lock_release_optab, Pmode); \n+  if (icode != CODE_FOR_nothing\n+      && insn_data[icode].operand[1].predicate (treg, Pmode)\n+      && (insn = GEN_FCN (icode) (tmem0, treg)) != NULL_RTX)\n+    emit_insn (insn);\n+  else\n+    emit_move_insn (tmem0, treg);\n+\n+  /* The memory barrier inserted above should not prevent\n+     the load of flags from being moved before the stores,\n+     but in practice it does because it is implemented with\n+     unspec_volatile.  In-order RISC machines should\n+     explicitly load flags earlier.  */\n+\n+  tree flags = cilk_dot (fptr, CILK_TI_FRAME_FLAGS, 0);\n+  expand_expr (build2 (MODIFY_EXPR, void_type_node, flags,\n+\t\t       build2 (BIT_IOR_EXPR, TREE_TYPE (flags), flags,\n+\t\t\t       build_int_cst (TREE_TYPE (flags),\n+\t\t\t\t\t      CILK_FRAME_DETACHED))),\n+\t       const0_rtx, VOIDmode, EXPAND_NORMAL);\n+}\n+\n+/* Returns a setjmp CALL_EXPR with FRAME->context as its parameter.  */\n+\n+tree\n+cilk_call_setjmp (tree frame)\n+{\n+  tree c = cilk_dot (frame, CILK_TI_FRAME_CONTEXT, false);\n+  c = build1 (ADDR_EXPR, build_pointer_type (ptr_type_node), c);\n+  return build_call_expr (builtin_decl_implicit (BUILT_IN_SETJMP), 1, c);\n+}\n+\n+/* This function will expand the _Cilk_sync keyword.  */\n+\n+static tree\n+expand_cilk_sync (void)\n+{\n+  tree frame = cfun->cilk_frame_decl;\n+\n+  /* Cilk_sync is converted to the following code:\n+\n+     sf.pedigree = sf.worker->pedigree;\n+     if (frame.flags & CILK_FRAME_UNSYNCHED)\n+     {\n+        __cilkrts_save_fp_state (&sf);\n+        if (!builtin_setjmp (sf.ctx) \n+\t    __cilkrts_sync (&sf); \n+\telse \n+\t   if (sf.flags & CILK_FRAME_EXCEPTING) \n+\t     __cilkrts_rethrow (&sf); \n+      }\n+      sf.worker->pedigree.rank = sf.worker->pedigree.rank + 1;  */\n+\n+  tree flags = cilk_dot (frame, CILK_TI_FRAME_FLAGS, false);\n+  \n+  tree unsynched = fold_build2 (BIT_AND_EXPR, TREE_TYPE (flags), flags,\n+\t\t\t\tbuild_int_cst (TREE_TYPE (flags),\n+\t\t\t\t\t       CILK_FRAME_UNSYNCHED));\n+\n+  unsynched = fold_build2 (NE_EXPR, TREE_TYPE (unsynched), unsynched,\n+\t\t\t   build_int_cst (TREE_TYPE (unsynched), 0));\n+\n+  tree frame_addr = build1 (ADDR_EXPR, cilk_frame_ptr_type_decl, frame);\n+\n+  /* Check if exception (0x10) bit is set in the sf->flags.  */\n+  tree except_flag = fold_build2 (BIT_AND_EXPR, TREE_TYPE (flags), flags,\n+\t\t\t\t  build_int_cst (TREE_TYPE (flags),\n+\t\t\t\t\t\t CILK_FRAME_EXCEPTING));\n+  except_flag = fold_build2 (NE_EXPR, TREE_TYPE (except_flag), except_flag,\n+\t\t\t     build_int_cst (TREE_TYPE (except_flag), 0));\n+\n+  /* If the exception flag is set then call the __cilkrts_rethrow (&sf).  */\n+  tree except_cond = fold_build3 (COND_EXPR, void_type_node, except_flag,\n+\t\t\t\t  build_call_expr (cilk_rethrow_fndecl, 1,\n+\t\t\t\t\t\t   frame_addr),\n+\t\t\t\t  build_empty_stmt (EXPR_LOCATION (unsynched)));\n+  \n+  tree sync_expr = build_call_expr (cilk_sync_fndecl, 1, frame_addr);\n+  tree setjmp_expr = cilk_call_setjmp (frame);\n+  setjmp_expr = fold_build2 (EQ_EXPR, TREE_TYPE (setjmp_expr), setjmp_expr,\n+\t\t\t     build_int_cst (TREE_TYPE (setjmp_expr), 0));\n+  \n+  setjmp_expr = fold_build3 (COND_EXPR, void_type_node, setjmp_expr,\n+\t\t\t     sync_expr, except_cond);\n+  tree sync_list = alloc_stmt_list ();\n+  append_to_statement_list (build_call_expr (cilk_save_fp_fndecl, 1,\n+\t\t\t\t\t     frame_addr), &sync_list);\n+  append_to_statement_list (setjmp_expr, &sync_list);\n+  tree sync = fold_build3 (COND_EXPR, void_type_node, unsynched, sync_list,\n+\t\t\t   build_empty_stmt (EXPR_LOCATION (unsynched)));\n+  tree parent_pedigree = cilk_dot (frame, CILK_TI_FRAME_PEDIGREE, false);\n+  tree worker = cilk_dot (frame, CILK_TI_FRAME_WORKER, false);\n+  tree worker_pedigree = cilk_arrow (worker, CILK_TI_WORKER_PEDIGREE, false);\n+  tree assign_pedigree = fold_build2 (MODIFY_EXPR, void_type_node,\n+\t\t\t\t      parent_pedigree, worker_pedigree);\n+  tree w_ped_rank = cilk_dot (unshare_expr (worker_pedigree), \n+\t\t\t      CILK_TI_PEDIGREE_RANK, false);\n+  tree incr_ped_rank = fold_build2 (PLUS_EXPR, TREE_TYPE (w_ped_rank),\n+\t\t\t\t    w_ped_rank,\n+\t\t\t\t    build_one_cst (TREE_TYPE (w_ped_rank)));\n+  incr_ped_rank = fold_build2 (MODIFY_EXPR, void_type_node, w_ped_rank,\n+\t\t\t       incr_ped_rank);\n+  tree ret_sync_exp = alloc_stmt_list ();\n+  append_to_statement_list (assign_pedigree, &ret_sync_exp);\n+  append_to_statement_list (sync, &ret_sync_exp);\n+  append_to_statement_list (incr_ped_rank, &ret_sync_exp);\n+  return ret_sync_exp;\n+}\n+\n+/* Gimplifies the cilk_sync expression passed in *EXPR_P.  Returns GS_ALL_DONE \n+   when finished.  */\n+\n+void\n+gimplify_cilk_sync (tree *expr_p, gimple_seq *pre_p)\n+{\n+  tree sync_expr = expand_cilk_sync ();\n+  *expr_p = NULL_TREE;\n+  gimplify_and_add (sync_expr, pre_p);\n+}"}, {"sha": "99b4d782af4ccbabea2a2f3f080927b82f356d30", "filename": "gcc/cilk.h", "status": "added", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/939b37da6ded55070bd78fc28d3fd2222b4278fa/gcc%2Fcilk.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/939b37da6ded55070bd78fc28d3fd2222b4278fa/gcc%2Fcilk.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcilk.h?ref=939b37da6ded55070bd78fc28d3fd2222b4278fa", "patch": "@@ -0,0 +1,102 @@\n+/* This file is part of the Intel(R) Cilk(TM) Plus support\n+   This file contains Cilk Support files.\n+   Copyright (C) 2013 Free Software Foundation, Inc.\n+   Contributed by Balaji V. Iyer <balaji.v.iyer@intel.com>,\n+                  Intel Corporation\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_CILK_H\n+#define GCC_CILK_H\n+\n+/* Frame status bits known to compiler.  */\n+#define CILK_FRAME_UNSYNCHED 0x02\n+#define CILK_FRAME_DETACHED  0x04\n+#define CILK_FRAME_EXCEPTING 0x10\n+#define CILK_FRAME_VERSION   (1 << 24)\n+\n+enum cilk_tree_index  {\n+/* All the built-in functions for Cilk keywords.  */\n+  CILK_TI_F_WORKER = 0,               /* __cilkrts_get_worker ().  */\n+  CILK_TI_F_SYNC,                     /* __cilkrts_sync ().  */\n+  CILK_TI_F_DETACH,                   /* __cilkrts_detach (...).   */\n+  CILK_TI_F_ENTER,                    /* __cilkrts_enter_frame (...).  */\n+  CILK_TI_F_ENTER_FAST,               /* __cilkrts_enter_frame_fast (.).  */\n+  CILK_TI_F_LEAVE,                    /* __cilkrts_leave_frame (...).  */\n+  CILK_TI_F_POP,                      /* __cilkrts_pop_frame (...).  */\n+  CILK_TI_F_RETHROW,                  /* __cilkrts_rethrow (...).  */\n+  CILK_TI_F_SAVE_FP,                  /* __cilkrts_save_fp_ctrl_state (...).  */\n+  /* __cilkrts_stack_frame struct fields.  */\n+  CILK_TI_FRAME_FLAGS,                /* stack_frame->flags.  */\n+  CILK_TI_FRAME_PARENT,               /* stack_frame->parent.  */\n+  CILK_TI_FRAME_WORKER,               /* stack_frame->worker.  */\n+  CILK_TI_FRAME_EXCEPTION,            /* stack_frame->except_data.  */\n+  CILK_TI_FRAME_CONTEXT,              /* stack_frame->context[4].  */\n+  CILK_TI_FRAME_PEDIGREE,             /* stack_frame->pedigree.  */\n+\n+  /* __cilkrts_worker struct fields.  */\n+  CILK_TI_WORKER_CUR,                 /* worker->current_stack_frame.  */\n+  CILK_TI_WORKER_TAIL,                /* worker->tail.  */\n+  CILK_TI_WORKER_PEDIGREE,            /* worker->pedigree.  */\n+\n+  /* __cilkrts_pedigree struct fields.  */\n+  CILK_TI_PEDIGREE_RANK,              /* pedigree->rank.  */\n+  CILK_TI_PEDIGREE_PARENT,            /* pedigree->parent.  */\n+  \n+  /* Types.  */\n+  CILK_TI_FRAME_TYPE,                 /* struct __cilkrts_stack_frame.  */\n+  CILK_TI_FRAME_PTR,                  /* __cilkrts_stack_frame *.  */\n+  CILK_TI_WORKER_TYPE,                /* struct __cilkrts_worker.  */\n+  CILK_TI_PEDIGREE_TYPE,              /* struct __cilkrts_pedigree.  */\n+  CILK_TI_MAX\n+};\n+\n+extern GTY (()) tree cilk_trees[CILK_TI_MAX];\n+\n+#define cilk_worker_fndecl            cilk_trees[CILK_TI_F_WORKER]\n+#define cilk_sync_fndecl              cilk_trees[CILK_TI_F_SYNC]\n+#define cilk_synched_fndecl           cilk_trees[CILK_TI_F_SYNCED]\n+#define cilk_detach_fndecl            cilk_trees[CILK_TI_F_DETACH]\n+#define cilk_enter_fndecl             cilk_trees[CILK_TI_F_ENTER]\n+#define cilk_enter_fast_fndecl        cilk_trees[CILK_TI_F_ENTER_FAST]\n+#define cilk_leave_fndecl             cilk_trees[CILK_TI_F_LEAVE]\n+#define cilk_rethrow_fndecl           cilk_trees[CILK_TI_F_RETHROW]\n+#define cilk_pop_fndecl               cilk_trees[CILK_TI_F_POP]\n+#define cilk_save_fp_fndecl           cilk_trees[CILK_TI_F_SAVE_FP]\n+\n+#define cilk_worker_type_fndecl       cilk_trees[CILK_TI_WORKER_TYPE]\n+#define cilk_frame_type_decl          cilk_trees[CILK_TI_FRAME_TYPE]\n+#define cilk_frame_ptr_type_decl      cilk_trees[CILK_TI_FRAME_PTR]\n+#define cilk_pedigree_type_decl       cilk_trees[CILK_TI_PEDIGREE_TYPE]\n+\n+extern void expand_builtin_cilk_detach (tree);\n+extern void expand_builtin_cilk_pop_frame (tree);\n+extern tree cilk_arrow (tree, int, bool);\n+extern tree cilk_dot (tree, int, bool);\n+extern void cilk_init_builtins (void);\n+extern void gimplify_cilk_sync (tree *, gimple_seq *);\n+extern tree cilk_call_setjmp (tree);\n+/* Returns true if Cilk Plus is enabled and if F->cilk_frame_decl is not\n+   NULL_TREE.  */\n+\n+inline bool\n+fn_contains_cilk_spawn_p (function *f)\n+{\n+  return (flag_enable_cilkplus \n+\t  && (f->calls_cilk_spawn || f->cilk_frame_decl != NULL_TREE));\n+}\n+#endif"}, {"sha": "cd74e2349c4a97107a3421a7946de54eb56cca8d", "filename": "gcc/cppbuiltin.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/939b37da6ded55070bd78fc28d3fd2222b4278fa/gcc%2Fcppbuiltin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/939b37da6ded55070bd78fc28d3fd2222b4278fa/gcc%2Fcppbuiltin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppbuiltin.c?ref=939b37da6ded55070bd78fc28d3fd2222b4278fa", "patch": "@@ -105,6 +105,8 @@ define_builtin_macros_for_compilation_flags (cpp_reader *pfile)\n \n   cpp_define_formatted (pfile, \"__FINITE_MATH_ONLY__=%d\",\n \t\t\tflag_finite_math_only);\n+  if (flag_enable_cilkplus)\n+    cpp_define (pfile, \"__cilk=200\");\n }\n \n "}, {"sha": "73dd1236412468e38a1e9b081c4e67d2f6000a41", "filename": "gcc/doc/generic.texi", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/939b37da6ded55070bd78fc28d3fd2222b4278fa/gcc%2Fdoc%2Fgeneric.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/939b37da6ded55070bd78fc28d3fd2222b4278fa/gcc%2Fdoc%2Fgeneric.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgeneric.texi?ref=939b37da6ded55070bd78fc28d3fd2222b4278fa", "patch": "@@ -3166,6 +3166,30 @@ several statements chained together.\n Used to represent a @code{break} statement.  There are no additional\n fields.\n \n+@item CILK_SPAWN_STMT\n+\n+Used to represent a spawning function in the Cilk Plus language extension.  \n+This tree has one field that holds the name of the spawning function.\n+@code{_Cilk_spawn} can be written in C in the following way:\n+\n+@smallexample\n+@code{_Cilk_spawn} <function_name> (<parameters>);\n+@end smallexample\n+\n+Detailed description for usage and functionality of @code{_Cilk_spawn} can be \n+found at http://www.cilkplus.org\n+\n+@item CILK_SYNC_STMT\n+\n+This statement is part of the Cilk Plus language extension.  It indicates that\n+the current function cannot continue in parallel with its spawned children.  \n+There are no additional fields.  @code{_Cilk_sync} can be written in C in the \n+following way:\n+\n+@smallexample\n+@code{_Cilk_sync};\n+@end smallexample\n+\n @item CLEANUP_STMT\n \n Used to represent an action that should take place upon exit from the"}, {"sha": "073f899608826823be68e38f317a5e4842d6e76a", "filename": "gcc/doc/passes.texi", "status": "modified", "additions": 37, "deletions": 5, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/939b37da6ded55070bd78fc28d3fd2222b4278fa/gcc%2Fdoc%2Fpasses.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/939b37da6ded55070bd78fc28d3fd2222b4278fa/gcc%2Fdoc%2Fpasses.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fpasses.texi?ref=939b37da6ded55070bd78fc28d3fd2222b4278fa", "patch": "@@ -124,13 +124,45 @@ true, then we expand them using either @code{expand_array_notation_exprs} or\n inside conditions, they are transformed using the function \n @code{fix_conditional_array_notations}.  The C language-specific routines are \n located in @file{c/c-array-notation.c} and the equivalent C++ routines are in \n-file @file{cp/cp-array-notation.c}.  Common routines such as functions to \n-initialize builtin functions are stored in @file{array-notation-common.c}.\n+the file @file{cp/cp-array-notation.c}.  Common routines such as functions to \n+initialize built-in functions are stored in @file{array-notation-common.c}.\n+\n+@item Cilk keywords:\n+@itemize @bullet \n+@item @code{_Cilk_spawn}:\n+The @code{_Cilk_spawn} keyword is parsed and the function it contains is marked \n+as a spawning function.  The spawning function is called the spawner.  At \n+the end of the parsing phase, appropriate built-in functions are \n+added to the spawner that are defined in the Cilk runtime.  The appropriate \n+locations of these functions, and the internal structures are detailed in \n+@code{cilk_init_builtins} in the file @file{cilk-common.c}.  The pointers to \n+Cilk functions and fields of internal structures are described \n+in @file{cilk.h}.  The built-in functions are described in \n+@file{cilk-builtins.def}.\n+\n+During gimplification, a new \"spawn-helper\" function is created.  \n+The spawned function is replaced with a spawn helper function in the spawner.  \n+The spawned function-call is moved into the spawn helper.  The main function\n+that does these transformations is @code{gimplify_cilk_spawn} in\n+@file{c-family/cilk.c}.  In the spawn-helper, the gimplification function \n+@code{gimplify_call_expr}, inserts a function call @code{__cilkrts_detach}.\n+This function is expanded by @code{builtin_expand_cilk_detach} located in\n+@file{c-family/cilk.c}.\n+\n+@item @code{_Cilk_sync}:\n+@code{_Cilk_sync} is parsed like a keyword.  During gimplification, \n+the function @code{gimplify_cilk_sync} in @file{c-family/cilk.c}, will replace\n+this keyword with a set of functions that are stored in the Cilk runtime.  \n+One of the internal functions inserted during gimplification, \n+@code{__cilkrts_pop_frame} must be expanded by the compiler and is \n+done by @code{builtin_expand_cilk_pop_frame} in @file{cilk-common.c}.\n+\n+@end itemize\n @end itemize\n \n-Detailed information about Cilk Plus and language specification is provided in \n-@w{@uref{http://www.cilkplus.org/}}.  It is worth mentioning that the current \n-implementation follows ABI 0.9.\n+Documentation about Cilk Plus and language specification is provided under the\n+\"Learn\" section in @w{@uref{http://www.cilkplus.org/}}.  It is worth mentioning\n+that the current implementation follows ABI 1.1.\n \n @node Gimplification pass\n @section Gimplification pass"}, {"sha": "9bb6ff04c5013cca34abb4bf5c6aa0466604ee81", "filename": "gcc/function.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/939b37da6ded55070bd78fc28d3fd2222b4278fa/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/939b37da6ded55070bd78fc28d3fd2222b4278fa/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=939b37da6ded55070bd78fc28d3fd2222b4278fa", "patch": "@@ -552,6 +552,9 @@ struct GTY(()) function {\n   /* Vector of function local variables, functions, types and constants.  */\n   vec<tree, va_gc> *local_decls;\n \n+  /* In a Cilk function, the VAR_DECL for the frame descriptor. */\n+  tree cilk_frame_decl;\n+\n   /* For md files.  */\n \n   /* tm.h can use this to store whatever it likes.  */\n@@ -607,6 +610,12 @@ struct GTY(()) function {\n      either as a subroutine or builtin.  */\n   unsigned int calls_alloca : 1;\n \n+  /* This will indicate whether a function is a cilk function */\n+  unsigned int is_cilk_function : 1;\n+\n+  /* Nonzero if this is a Cilk function that spawns. */\n+  unsigned int calls_cilk_spawn : 1;\n+  \n   /* Nonzero if function being compiled receives nonlocal gotos\n      from nested functions.  */\n   unsigned int has_nonlocal_label : 1;"}, {"sha": "5edc6e8c33d9e484809df4fe09ba92420d65a6f2", "filename": "gcc/gimplify.c", "status": "modified", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/939b37da6ded55070bd78fc28d3fd2222b4278fa/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/939b37da6ded55070bd78fc28d3fd2222b4278fa/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=939b37da6ded55070bd78fc28d3fd2222b4278fa", "patch": "@@ -48,6 +48,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"vec.h\"\n #include \"omp-low.h\"\n #include \"gimple-low.h\"\n+#include \"cilk.h\"\n \n #include \"langhooks-def.h\"\t/* FIXME: for lhd_set_decl_assembler_name */\n #include \"tree-pass.h\"\t\t/* FIXME: only for PROP_gimple_any */\n@@ -1309,6 +1310,15 @@ gimplify_return_expr (tree stmt, gimple_seq *pre_p)\n   if (ret_expr == error_mark_node)\n     return GS_ERROR;\n \n+  /* Implicit _Cilk_sync must be inserted right before any return statement \n+     if there is a _Cilk_spawn in the function.  If the user has provided a \n+     _Cilk_sync, the optimizer should remove this duplicate one.  */\n+  if (fn_contains_cilk_spawn_p (cfun))\n+    {\n+      tree impl_sync = build0 (CILK_SYNC_STMT, void_type_node);\n+      gimplify_and_add (impl_sync, pre_p);\n+    }\n+\n   if (!ret_expr\n       || TREE_CODE (ret_expr) == RESULT_DECL\n       || ret_expr == error_mark_node)\n@@ -2498,6 +2508,12 @@ gimplify_call_expr (tree *expr_p, gimple_seq *pre_p, bool want_value)\n   if (! EXPR_HAS_LOCATION (*expr_p))\n     SET_EXPR_LOCATION (*expr_p, input_location);\n \n+  if (fn_contains_cilk_spawn_p (cfun)\n+      && lang_hooks.cilkplus.cilk_detect_spawn_and_unwrap (expr_p) \n+      && !seen_error ())\n+    return (enum gimplify_status) \n+      lang_hooks.cilkplus.gimplify_cilk_spawn (expr_p, pre_p, NULL);\n+\n   /* This may be a call to a builtin function.\n \n      Builtin function calls may be transformed into different\n@@ -4714,6 +4730,12 @@ gimplify_modify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n \n   gcc_assert (TREE_CODE (*expr_p) == MODIFY_EXPR\n \t      || TREE_CODE (*expr_p) == INIT_EXPR);\n+  \n+  if (fn_contains_cilk_spawn_p (cfun)\n+      && lang_hooks.cilkplus.cilk_detect_spawn_and_unwrap (expr_p) \n+      && !seen_error ())\n+    return (enum gimplify_status) \n+      lang_hooks.cilkplus.gimplify_cilk_spawn (expr_p, pre_p, post_p);\n \n   /* Trying to simplify a clobber using normal logic doesn't work,\n      so handle it here.  */\n@@ -7660,6 +7682,19 @@ gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n \t    }\n \t  break;\n \n+\tcase CILK_SPAWN_STMT:\n+\t  gcc_assert \n+\t    (fn_contains_cilk_spawn_p (cfun) \n+\t     && lang_hooks.cilkplus.cilk_detect_spawn_and_unwrap (expr_p));\n+\t  if (!seen_error ())\n+\t    {\n+\t      ret = (enum gimplify_status)\n+\t\tlang_hooks.cilkplus.gimplify_cilk_spawn (expr_p, pre_p,\n+\t\t\t\t\t\t\t post_p);\n+\t      break;\n+\t    }\n+\t  /* If errors are seen, then just process it as a CALL_EXPR.  */\n+\n \tcase CALL_EXPR:\n \t  ret = gimplify_call_expr (expr_p, pre_p, fallback != fb_none);\n \n@@ -8295,6 +8330,22 @@ gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n \t    break;\n \t  }\n \n+\tcase CILK_SYNC_STMT:\n+\t  {\n+\t    if (!fn_contains_cilk_spawn_p (cfun))\n+\t      {\n+\t\terror_at (EXPR_LOCATION (*expr_p),\n+\t\t\t  \"expected %<_Cilk_spawn%> before %<_Cilk_sync%>\");\n+\t\tret = GS_ERROR;\n+\t      }\n+\t    else\n+\t      {\n+\t\tgimplify_cilk_sync (expr_p, pre_p);\n+\t\tret = GS_ALL_DONE;\n+\t      }\n+\t    break;\n+\t  }\n+\t\n \tdefault:\n \t  switch (TREE_CODE_CLASS (TREE_CODE (*expr_p)))\n \t    {"}, {"sha": "83bd47933b92001f13441cfa064c5b7a01c59848", "filename": "gcc/ipa-inline-analysis.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/939b37da6ded55070bd78fc28d3fd2222b4278fa/gcc%2Fipa-inline-analysis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/939b37da6ded55070bd78fc28d3fd2222b4278fa/gcc%2Fipa-inline-analysis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-analysis.c?ref=939b37da6ded55070bd78fc28d3fd2222b4278fa", "patch": "@@ -95,6 +95,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"cfgloop.h\"\n #include \"tree-scalar-evolution.h\"\n #include \"ipa-utils.h\"\n+#include \"cilk.h\"\n \n /* Estimate runtime of function can easilly run into huge numbers with many\n    nested loops.  Be sure we can compute time * INLINE_SIZE_SCALE * 2 in an\n@@ -1440,6 +1441,9 @@ initialize_inline_failed (struct cgraph_edge *e)\n     e->inline_failed = CIF_REDEFINED_EXTERN_INLINE;\n   else if (e->call_stmt_cannot_inline_p)\n     e->inline_failed = CIF_MISMATCHED_ARGUMENTS;\n+  else if (cfun && fn_contains_cilk_spawn_p (cfun))\n+    /* We can't inline if the function is spawing a function.  */\n+    e->inline_failed = CIF_FUNCTION_NOT_INLINABLE;\n   else\n     e->inline_failed = CIF_FUNCTION_NOT_CONSIDERED;\n }"}, {"sha": "f4cb72a9c2b0d0755425f5c620b3c9f2f968b2b4", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/939b37da6ded55070bd78fc28d3fd2222b4278fa/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/939b37da6ded55070bd78fc28d3fd2222b4278fa/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=939b37da6ded55070bd78fc28d3fd2222b4278fa", "patch": "@@ -115,6 +115,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"ipa-inline.h\"\n #include \"ipa-utils.h\"\n #include \"sreal.h\"\n+#include \"cilk.h\"\n \n /* Statistics we collect about inlining algorithm.  */\n static int overall_size;\n@@ -264,7 +265,8 @@ can_inline_edge_p (struct cgraph_edge *e, bool report,\n       e->inline_failed = CIF_BODY_NOT_AVAILABLE;\n       inlinable = false;\n     }\n-  else if (!inline_summary (callee)->inlinable)\n+  else if (!inline_summary (callee)->inlinable \n+\t   || (caller_cfun && fn_contains_cilk_spawn_p (caller_cfun)))\n     {\n       e->inline_failed = CIF_FUNCTION_NOT_INLINABLE;\n       inlinable = false;"}, {"sha": "628fd031208460c6db8456bfda521795fbd67dda", "filename": "gcc/ira.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/939b37da6ded55070bd78fc28d3fd2222b4278fa/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/939b37da6ded55070bd78fc28d3fd2222b4278fa/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=939b37da6ded55070bd78fc28d3fd2222b4278fa", "patch": "@@ -1874,6 +1874,9 @@ ira_setup_eliminable_regset (bool from_ira_p)\n        || (flag_stack_check && STACK_CHECK_MOVING_SP)\n        || crtl->accesses_prior_frames\n        || crtl->stack_realign_needed\n+       /* We need a frame pointer for all Cilk Plus functions that use\n+\t  Cilk keywords.  */\n+       || (flag_enable_cilkplus && cfun->is_cilk_function)\n        || targetm.frame_pointer_required ());\n \n   if (from_ira_p && ira_use_lra_p)"}, {"sha": "411cf74b666c3200e069ad350e1d426637417ee9", "filename": "gcc/langhooks-def.h", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/939b37da6ded55070bd78fc28d3fd2222b4278fa/gcc%2Flanghooks-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/939b37da6ded55070bd78fc28d3fd2222b4278fa/gcc%2Flanghooks-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks-def.h?ref=939b37da6ded55070bd78fc28d3fd2222b4278fa", "patch": "@@ -214,6 +214,18 @@ extern tree lhd_make_node (enum tree_code);\n #define LANG_HOOKS_OMP_CLAUSE_DTOR hook_tree_tree_tree_null\n #define LANG_HOOKS_OMP_FINISH_CLAUSE hook_void_tree\n \n+extern void lhd_install_body_with_frame_cleanup (tree, tree);\n+extern bool lhd_cilk_detect_spawn (tree *);\n+#define LANG_HOOKS_CILKPLUS_DETECT_SPAWN_AND_UNWRAP lhd_cilk_detect_spawn\n+#define LANG_HOOKS_CILKPLUS_FRAME_CLEANUP lhd_install_body_with_frame_cleanup\n+#define LANG_HOOKS_CILKPLUS_GIMPLIFY_SPAWN lhd_gimplify_expr\n+\n+#define LANG_HOOKS_CILKPLUS {\t\t\t\\\n+  LANG_HOOKS_CILKPLUS_DETECT_SPAWN_AND_UNWRAP,\t\\\n+  LANG_HOOKS_CILKPLUS_FRAME_CLEANUP,\t\t\\\n+  LANG_HOOKS_CILKPLUS_GIMPLIFY_SPAWN            \\\n+}\n+\n #define LANG_HOOKS_DECLS { \\\n   LANG_HOOKS_GLOBAL_BINDINGS_P, \\\n   LANG_HOOKS_PUSHDECL, \\\n@@ -291,6 +303,7 @@ extern void lhd_end_section (void);\n   LANG_HOOKS_TREE_DUMP_INITIALIZER, \\\n   LANG_HOOKS_DECLS, \\\n   LANG_HOOKS_FOR_TYPES_INITIALIZER, \\\n+  LANG_HOOKS_CILKPLUS, \\\n   LANG_HOOKS_LTO, \\\n   LANG_HOOKS_GET_INNERMOST_GENERIC_PARMS, \\\n   LANG_HOOKS_GET_INNERMOST_GENERIC_ARGS, \\"}, {"sha": "5d1457b1b22f92563eaed7b1989fce480c455d20", "filename": "gcc/langhooks.c", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/939b37da6ded55070bd78fc28d3fd2222b4278fa/gcc%2Flanghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/939b37da6ded55070bd78fc28d3fd2222b4278fa/gcc%2Flanghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks.c?ref=939b37da6ded55070bd78fc28d3fd2222b4278fa", "patch": "@@ -675,3 +675,18 @@ lhd_end_section (void)\n       saved_section = NULL;\n     }\n }\n+\n+/* Empty function that is replaced with appropriate language dependent\n+   frame cleanup function for _Cilk_spawn.  */\n+\n+void\n+lhd_install_body_with_frame_cleanup (tree, tree)\n+{\n+}\n+\n+/* Empty function to handle cilk_valid_spawn.  */\n+bool\n+lhd_cilk_detect_spawn (tree *)\n+{\n+  return false;\n+}"}, {"sha": "9539e7d5b7aa8e9185e2d210b06df79ea22084b2", "filename": "gcc/langhooks.h", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/939b37da6ded55070bd78fc28d3fd2222b4278fa/gcc%2Flanghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/939b37da6ded55070bd78fc28d3fd2222b4278fa/gcc%2Flanghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks.h?ref=939b37da6ded55070bd78fc28d3fd2222b4278fa", "patch": "@@ -139,6 +139,23 @@ struct lang_hooks_for_types\n   tree (*reconstruct_complex_type) (tree, tree);\n };\n \n+/* Language hooks related to Cilk Plus.  */\n+\n+struct lang_hooks_for_cilkplus\n+{\n+  /* Returns true if the expression passed in has a spawned function call.  */\n+  bool (*cilk_detect_spawn_and_unwrap) (tree *);\n+\n+  /* Function to add the clean up functions after spawn.  The reason why it is\n+     language dependent is because in C++, it must handle exceptions.  */\n+  void (*install_body_with_frame_cleanup) (tree, tree);\n+\n+  /* Function to gimplify a spawned function call.  Returns enum gimplify\n+     status, but as mentioned in a previous comment, we can't see that type \n+     here, so just return an int.  */\n+  int (*gimplify_cilk_spawn) (tree *, gimple_seq *, gimple_seq *);\n+};\n+\n /* Language hooks related to decls and the symbol table.  */\n \n struct lang_hooks_for_decls\n@@ -408,6 +425,8 @@ struct lang_hooks\n \n   struct lang_hooks_for_types types;\n \n+  struct lang_hooks_for_cilkplus cilkplus;\n+  \n   struct lang_hooks_for_lto lto;\n \n   /* Returns a TREE_VEC of the generic parameters of an instantiation of"}, {"sha": "6606e590fb63f3465d77b94ca1a1daf23553ed0d", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/939b37da6ded55070bd78fc28d3fd2222b4278fa/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/939b37da6ded55070bd78fc28d3fd2222b4278fa/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=939b37da6ded55070bd78fc28d3fd2222b4278fa", "patch": "@@ -1,3 +1,9 @@\n+2013-10-29  Balaji V. Iyer  <balaji.v.iyer@intel.com>\n+\n+\t* Make-lang.in (lto/lto-lang.o): Added cilk.h in dependency list.\n+\t* lto-lang.c (lto_init): Added a call to cilk_init_builtins if Cilk\n+\tPlus is enabled.\n+\n 2013-10-29  David Malcolm  <dmalcolm@redhat.com>\n \n \tPatch autogenerated by refactor_symtab.py from"}, {"sha": "b56c22b8a87d01c3b3fe7d8cd924687e1a6bcc46", "filename": "gcc/lto/lto-lang.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/939b37da6ded55070bd78fc28d3fd2222b4278fa/gcc%2Flto%2Flto-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/939b37da6ded55070bd78fc28d3fd2222b4278fa/gcc%2Flto%2Flto-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-lang.c?ref=939b37da6ded55070bd78fc28d3fd2222b4278fa", "patch": "@@ -35,6 +35,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"diagnostic-core.h\"\n #include \"toplev.h\"\n #include \"lto-streamer.h\"\n+#include \"cilk.h\"\n \n static tree lto_type_for_size (unsigned, int);\n \n@@ -1174,6 +1175,9 @@ lto_init (void)\n       lto_define_builtins (va_list_type_node,\n \t\t\t   build_reference_type (va_list_type_node));\n     }\n+  \n+  if (flag_enable_cilkplus)\n+    cilk_init_builtins ();\n \n   targetm.init_builtins ();\n   build_common_builtin_nodes ();"}, {"sha": "621b951bfa3f17ff8933348f5ed420bf9bb7977c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/939b37da6ded55070bd78fc28d3fd2222b4278fa/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/939b37da6ded55070bd78fc28d3fd2222b4278fa/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=939b37da6ded55070bd78fc28d3fd2222b4278fa", "patch": "@@ -1,3 +1,25 @@\n+2013-10-29  Balaji V. Iyer  <balaji.v.iyer@intel.com>\n+\n+\t* c-c++-common/cilk-plus/CK/compound_cilk_spawn.c: New test.\n+\t* c-c++-common/cilk-plus/CK/concec_cilk_spawn.c: Likewise.\n+\t* c-c++-common/cilk-plus/CK/fib.c: Likewise.\n+\t* c-c++-common/cilk-plus/CK/no_args_error.c: Likewise.\n+\t* c-c++-common/cilk-plus/CK/spawnee_inline.c: Likewise.\n+\t* c-c++-common/cilk-plus/CK/spawner_inline.c: Likewise.\n+\t* c-c++-common/cilk-plus/CK/spawning_arg.c: Likewise.\n+\t* c-c++-common/cilk-plus/CK/steal_check.c: Likewise.\n+\t* c-c++-common/cilk-plus/CK/test__cilk.c: Likewise.\n+\t* c-c++-common/cilk-plus/CK/varargs_test.c: Likewise.\n+\t* c-c++-common/cilk-plus/CK/sync_wo_spawn.c: Likewise.\n+\t* c-c++-common/cilk-plus/CK/invalid_spawn.c: Likewise.\n+\t* c-c++-common/cilk-plus/CK/spawn_in_return.c: Likewise.\n+\t* c-c++-common/cilk-plus/CK/fib_init_expr_xy.c: Likewise.\n+\t* c-c++-common/cilk-plus/CK/fib_no_sync.c: Likewise.\n+\t* c-c++-common/cilk-plus/CK/fib_no_return.c: Likewise.\n+\t* gcc.dg/cilk-plus/cilk-plus.exp: Added support to run Cilk Keywords\n+\ttest stored in c-c++-common.  Also, added the Cilk runtime's library\n+\tto the ld_library_path.\n+\n 2013-10-29  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/58888"}, {"sha": "5e687bd0a0c8cd6dc1aac1555c8722bee5a7fc8a", "filename": "gcc/testsuite/c-c++-common/cilk-plus/CK/compound_cilk_spawn.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/939b37da6ded55070bd78fc28d3fd2222b4278fa/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fcompound_cilk_spawn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/939b37da6ded55070bd78fc28d3fd2222b4278fa/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fcompound_cilk_spawn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fcompound_cilk_spawn.c?ref=939b37da6ded55070bd78fc28d3fd2222b4278fa", "patch": "@@ -0,0 +1,26 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fcilkplus\" } */\n+\n+/* <feature>\n+   A program is considered ill formed if the _Cilk_spawn form of this\n+    expression appears other than in one of the following contexts:\n+    as the entire body of an expression statement,\n+    as the entire right hand side of an assignment expression that is the entire\n+    body of an expression statement, or as the entire initializer-clause in a \n+    simple declaration.\n+   </feature>\n+*/\n+\n+int spawn_func (int arg)\n+{\n+  return arg + 1;\n+}\n+\n+int check()\n+{\n+  int z;\n+  z = 23, _Cilk_spawn spawn_func (3), 3424; /* { dg-error \"spawned function call cannot be part of a comma expression\" } */\n+  23, spawn_func (5), _Cilk_spawn spawn_func (3); /* { dg-error \"spawned function call cannot be part of a comma expression\" } */\n+  _Cilk_spawn spawn_func (0), _Cilk_spawn spawn_func (3), 3, spawn_func (0); /* { dg-error \"spawned function call cannot be part of a comma expression\" } */\n+  return 23;\n+}"}, {"sha": "b93c9626d189e342100fd25c8ed6bc5f46ac43af", "filename": "gcc/testsuite/c-c++-common/cilk-plus/CK/concec_cilk_spawn.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/939b37da6ded55070bd78fc28d3fd2222b4278fa/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fconcec_cilk_spawn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/939b37da6ded55070bd78fc28d3fd2222b4278fa/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fconcec_cilk_spawn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fconcec_cilk_spawn.c?ref=939b37da6ded55070bd78fc28d3fd2222b4278fa", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fcilkplus\" } */\n+\n+/* <feature> Consecutive _Cilk_spawn tokens are not permitted\n+   </feature>\n+*/\n+\n+int spawn_func (int arg)\n+{\n+  return arg + 1;\n+}\n+\n+void func ()\n+{\n+  int a;\n+  a = _Cilk_spawn _Cilk_spawn spawn_func (4); /* { dg-error \"consecutive\" } */\n+  a = _Cilk_spawn _Cilk_spawn _Cilk_spawn spawn_func (4); /* { dg-error \"consecutive\" } */\n+  a = _Cilk_spawn _Cilk_spawn _Cilk_spawn _Cilk_spawn spawn_func (4); /* { dg-error \"consecutive\" } */\n+  return;\n+}"}, {"sha": "6612936a05c00dbe650a6a48c8253d01a52800f1", "filename": "gcc/testsuite/c-c++-common/cilk-plus/CK/fib.c", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/939b37da6ded55070bd78fc28d3fd2222b4278fa/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Ffib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/939b37da6ded55070bd78fc28d3fd2222b4278fa/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Ffib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Ffib.c?ref=939b37da6ded55070bd78fc28d3fd2222b4278fa", "patch": "@@ -0,0 +1,61 @@\n+/* { dg-options \"-fcilkplus\" } */\n+/* { dg-do run { target i?86-*-* x86_64-*-* } } */\n+/* { dg-options \"-fcilkplus -lcilkrts\" { target { i?86-*-* x86_64-*-* } } } */\n+\n+#if HAVE_IO\n+#include <stdio.h>\n+#endif\n+\n+int fib        (int);\n+int fib_serial (int);\n+\n+int main(void)\n+{\n+  int ii = 0, error = 0;\n+  int fib_result[41], fib_serial_result[41];\n+#if HAVE_IO\n+\n+  for (ii = 0; ii <= 40; ii++)\n+    printf(\"fib (%2d) = %10d\\n\", ii, fib (ii));\n+#else\n+  for (ii = 0; ii <= 40; ii++)\n+    {\n+      fib_result[ii]        = fib (ii);\n+      fib_serial_result[ii] = fib_serial (ii);\n+    }\n+\n+  for (ii = 0; ii <= 40; ii++)\n+    {\n+      if (fib_result[ii] != fib_serial_result[ii])\n+\terror = 1;\n+    }\n+#endif\n+  return error;\n+}\n+\n+int fib_serial (int n)\n+{\n+  int x = 0, y = 0;\n+  if (n < 2)\n+    return n;\n+  else\n+    {\n+      x = fib (n-1);\n+      y = fib (n-2);\n+      return (x+y);\n+    }\n+}\n+\n+int fib(int n)\n+{\n+  int x = 0, y = 0;\n+  if (n < 2) \n+    return n;\n+  else\n+  {\n+    x = _Cilk_spawn fib(n-1);\n+    y = fib(n-2);\n+    _Cilk_sync;\n+    return (x+y);\n+  }\n+}"}, {"sha": "6b09918a420efeed85a1f39ddbfe1d61bb69f597", "filename": "gcc/testsuite/c-c++-common/cilk-plus/CK/fib_init_expr_xy.c", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/939b37da6ded55070bd78fc28d3fd2222b4278fa/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Ffib_init_expr_xy.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/939b37da6ded55070bd78fc28d3fd2222b4278fa/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Ffib_init_expr_xy.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Ffib_init_expr_xy.c?ref=939b37da6ded55070bd78fc28d3fd2222b4278fa", "patch": "@@ -0,0 +1,60 @@\n+/* { dg-options \"-fcilkplus\" } */\n+/* { dg-do run { target i?86-*-* x86_64-*-* } } */\n+/* { dg-options \"-fcilkplus -lcilkrts\" { target { i?86-*-* x86_64-*-* } } } */\n+\n+#if HAVE_IO\n+#include <stdio.h>\n+#endif\n+\n+int fib        (int);\n+int fib_serial (int);\n+\n+int main(void)\n+{\n+  int ii = 0, error = 0;\n+  int fib_result[41], fib_serial_result[41];\n+#if HAVE_IO\n+\n+  for (ii = 0; ii <= 40; ii++)\n+    printf(\"fib (%2d) = %10d\\n\", ii, fib (ii));\n+#else\n+  for (ii = 0; ii <= 40; ii++)\n+    {\n+      fib_result[ii]        = fib (ii);\n+      fib_serial_result[ii] = fib_serial (ii);\n+    }\n+\n+  for (ii = 0; ii <= 40; ii++)\n+    {\n+      if (fib_result[ii] != fib_serial_result[ii])\n+\terror = 1;\n+    }\n+#endif\n+  return error;\n+}\n+\n+int fib_serial (int n)\n+{\n+  int x = 0, y = 0;\n+  if (n < 2)\n+    return n;\n+  else\n+    {\n+      x = fib (n-1);\n+      y = fib (n-2);\n+      return (x+y);\n+    }\n+}\n+\n+int fib(int n)\n+{\n+  if (n < 2) \n+    return n;\n+  else\n+  {\n+    int x = _Cilk_spawn fib(n-1);\n+    int y = fib(n-2);\n+    _Cilk_sync;\n+    return (x+y);\n+  }\n+}"}, {"sha": "2adf3a2f6e1c7890fd9437ffefd3fc4caeee8b52", "filename": "gcc/testsuite/c-c++-common/cilk-plus/CK/fib_no_return.c", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/939b37da6ded55070bd78fc28d3fd2222b4278fa/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Ffib_no_return.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/939b37da6ded55070bd78fc28d3fd2222b4278fa/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Ffib_no_return.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Ffib_no_return.c?ref=939b37da6ded55070bd78fc28d3fd2222b4278fa", "patch": "@@ -0,0 +1,65 @@\n+/* { dg-options \"-fcilkplus\" } */\n+/* { dg-do run { target i?86-*-* x86_64-*-* } } */\n+/* { dg-options \"-fcilkplus -lcilkrts\" { target { i?86-*-* x86_64-*-* } } } */\n+\n+#if HAVE_IO\n+#include <stdio.h>\n+#endif\n+\n+void fib        (int *, int);\n+int fib_serial (int);\n+\n+int main(void)\n+{\n+  int ii = 0, error = 0;\n+  int fib_result[41], fib_serial_result[41];\n+\n+#if HAVE_IO\n+  for (ii = 0; ii <= 40; ii++)\n+    {\n+      int result = 0;\n+      fib (&result, ii); \n+      printf(\"fib (%2d) = %10d\\n\", ii, result);\n+    }\n+#else\n+  for (ii = 0; ii <= 40; ii++)\n+    {\n+      fib (&fib_result[ii], ii);\n+      fib_serial_result[ii] = fib_serial (ii);\n+    }\n+\n+  for (ii = 0; ii <= 40; ii++)\n+    {\n+      if (fib_result[ii] != fib_serial_result[ii])\n+\terror = 1;\n+    }\n+#endif\n+  return error;\n+}\n+\n+int fib_serial (int n)\n+{\n+  int x = 0, y = 0;\n+  if (n < 2)\n+    return n;\n+  else\n+    {\n+      fib (&x, n-1);\n+      fib (&y, n-2);\n+      return (x+y);\n+    }\n+}\n+\n+void fib(int *result, int n)\n+{\n+  int x = 0, y = 0;\n+  if (n < 2) \n+    x = n;\n+  else\n+  {\n+    _Cilk_spawn fib(&x, n-1);\n+    fib(&y, n-2);\n+    _Cilk_sync;\n+  } \n+ *result = (x+y);\n+}"}, {"sha": "9de70be75844acbc8aab073abaca007719ad56fe", "filename": "gcc/testsuite/c-c++-common/cilk-plus/CK/fib_no_sync.c", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/939b37da6ded55070bd78fc28d3fd2222b4278fa/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Ffib_no_sync.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/939b37da6ded55070bd78fc28d3fd2222b4278fa/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Ffib_no_sync.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Ffib_no_sync.c?ref=939b37da6ded55070bd78fc28d3fd2222b4278fa", "patch": "@@ -0,0 +1,59 @@\n+/* { dg-options \"-fcilkplus\" } */\n+/* { dg-do run { target i?86-*-* x86_64-*-* } } */\n+/* { dg-options \"-fcilkplus -lcilkrts\" { target { i?86-*-* x86_64-*-* } } } */\n+\n+#if HAVE_IO\n+#include <stdio.h>\n+#endif\n+\n+int fib        (int);\n+int fib_serial (int);\n+\n+int main(void)\n+{\n+  int ii = 0, error = 0;\n+  int fib_result[41], fib_serial_result[41];\n+#if HAVE_IO\n+\n+  for (ii = 0; ii <= 40; ii++)\n+    printf(\"fib (%2d) = %10d\\n\", ii, fib (ii));\n+#else\n+  for (ii = 0; ii <= 40; ii++)\n+    {\n+      fib_result[ii]        = fib (ii);\n+      fib_serial_result[ii] = fib_serial (ii);\n+    }\n+\n+  for (ii = 0; ii <= 40; ii++)\n+    {\n+      if (fib_result[ii] != fib_serial_result[ii])\n+\terror = 1;\n+    }\n+#endif\n+  return error;\n+}\n+\n+int fib_serial (int n)\n+{\n+  int x = 0, y = 0;\n+  if (n < 2)\n+    return n;\n+  else\n+    {\n+      x = fib (n-1);\n+      y = fib (n-2);\n+      return (x+y);\n+    }\n+}\n+\n+int fib(int n)\n+{\n+  if (n < 2) \n+    return n;\n+  else\n+  {\n+    int x = _Cilk_spawn fib(n-1);\n+    int y = fib(n-2);\n+    return (x+y);\n+  }\n+}"}, {"sha": "90dd5c130b41f9e7fee7ff4e3c205a2bb176d58d", "filename": "gcc/testsuite/c-c++-common/cilk-plus/CK/invalid_spawns.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/939b37da6ded55070bd78fc28d3fd2222b4278fa/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Finvalid_spawns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/939b37da6ded55070bd78fc28d3fd2222b4278fa/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Finvalid_spawns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Finvalid_spawns.c?ref=939b37da6ded55070bd78fc28d3fd2222b4278fa", "patch": "@@ -0,0 +1,11 @@\n+extern int foo ();\n+int bar = _Cilk_spawn foo (); /* { dg-error \"may only be used inside a function\" } */\n+\n+\n+int main (void)\n+{\n+  int x; \n+\n+  _Cilk_spawn x; /* { dg-error \"only function calls can be spawned\" } */\n+  return x;\n+}"}, {"sha": "593732ef5abda48728a48785013992144f4e0b17", "filename": "gcc/testsuite/c-c++-common/cilk-plus/CK/no_args_error.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/939b37da6ded55070bd78fc28d3fd2222b4278fa/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fno_args_error.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/939b37da6ded55070bd78fc28d3fd2222b4278fa/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fno_args_error.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fno_args_error.c?ref=939b37da6ded55070bd78fc28d3fd2222b4278fa", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fcilkplus\" } */\n+\n+int spawn_1 ();\n+typedef int(*func) (int);\n+\n+void check () {\n+      func var = spawn_1; /* { dg-error \"invalid conversion from\" \"\" { target c++ } 8 } */\n+        _Cilk_spawn var (); /* { dg-error \"too few arguments to function\" } */ \n+}\n+"}, {"sha": "14b7eef1276a1718b0738413b64b2b58659cb7de", "filename": "gcc/testsuite/c-c++-common/cilk-plus/CK/spawn_in_return.c", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/939b37da6ded55070bd78fc28d3fd2222b4278fa/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fspawn_in_return.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/939b37da6ded55070bd78fc28d3fd2222b4278fa/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fspawn_in_return.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fspawn_in_return.c?ref=939b37da6ded55070bd78fc28d3fd2222b4278fa", "patch": "@@ -0,0 +1,8 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fcilkplus\" } */\n+\n+int main (void)\n+{\n+  extern int foo ();\n+  return _Cilk_spawn foo (); /* { dg-error \"return statement is not allowed\" } */\n+}"}, {"sha": "8060c6ceb15cac301583faba23f36132381e4ee7", "filename": "gcc/testsuite/c-c++-common/cilk-plus/CK/spawnee_inline.c", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/939b37da6ded55070bd78fc28d3fd2222b4278fa/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fspawnee_inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/939b37da6ded55070bd78fc28d3fd2222b4278fa/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fspawnee_inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fspawnee_inline.c?ref=939b37da6ded55070bd78fc28d3fd2222b4278fa", "patch": "@@ -0,0 +1,80 @@\n+/* { dg-do run  { target { i?86-*-* x86_64-*-* } } } */\n+/* { dg-options \"-fcilkplus -w\" } */\n+/* { dg-options \"-lcilkrts\" { target { i?86-*-* x86_64-*-* } } } */\n+\n+#include <stdio.h>\n+#include <stdlib.h>\n+#define DEFAULT_VALUE \"30\"\n+\n+int fib (char *n_char)\n+{\n+  int n;\n+  char n_char_minus_one[20], n_char_minus_two[20];\n+  if (n_char)\n+    n = atoi (n_char);\n+  else\n+    n = atoi(DEFAULT_VALUE);\n+  \n+  if (n < 2)\n+    return n;\n+  else\n+    {\t   \n+      int x, y;\n+      sprintf (n_char_minus_one,\"%d\", n-1); \n+      sprintf (n_char_minus_two,\"%d\", n-2); \n+      x = _Cilk_spawn fib (n_char_minus_one);\n+      y = _Cilk_spawn fib (n_char_minus_two);\n+      _Cilk_sync;\n+      return (x+y);\n+    }\n+}\n+\n+int fib_serial (int n)\n+{\n+  int x, y;\n+  if (n < 2)\n+    return n;\n+  else\n+    {\n+      x = fib_serial (n-1);\n+      y = fib_serial (n-2);\n+      return (x+y);\n+    }\n+  return 0;\n+}\n+\n+int main2_parallel (int argc, char *argv[])\n+{\n+  int n, result_parallel = 0;\n+\n+  if (argc == 2)\n+    {\n+      result_parallel = _Cilk_spawn fib (argv[1]);\n+      _Cilk_sync; \n+    }\n+  else\n+    {\n+      result_parallel = _Cilk_spawn fib((char *)\"30\");\n+      _Cilk_sync; \n+    }\n+  return result_parallel;\n+}\n+\n+int main2_serial (int argc, char *argv[])\n+{\n+  int n, result_serial = 0;\n+  if (argc == 2) \n+    result_serial = fib_serial (atoi (argv[1]));\n+  else\n+    result_serial = fib_serial (atoi (DEFAULT_VALUE));\n+\n+  return result_serial;\n+}\n+\n+int main (void)\n+{\n+  if (main2_serial (1, 0) != main2_parallel (1,0))\n+    return 1;\n+  return 0;\n+}\n+"}, {"sha": "eab9e4206a05eccba8647c8f808bcaa5e0e4d357", "filename": "gcc/testsuite/c-c++-common/cilk-plus/CK/spawner_inline.c", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/939b37da6ded55070bd78fc28d3fd2222b4278fa/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fspawner_inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/939b37da6ded55070bd78fc28d3fd2222b4278fa/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fspawner_inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fspawner_inline.c?ref=939b37da6ded55070bd78fc28d3fd2222b4278fa", "patch": "@@ -0,0 +1,67 @@\n+/* { dg-do run  { target { i?86-*-* x86_64-*-* } } } */\n+/* { dg-options \"-fcilkplus\" } */\n+/* { dg-options \"-lcilkrts\" { target { i?86-*-* x86_64-*-* } } } */\n+\n+#include <stdlib.h>\n+#define DEFAULT_VALUE 30\n+int fib (int n)\n+{\n+  if (n<2)\n+    return n;\n+  else\n+    {\n+      int x, y;\n+      x = _Cilk_spawn fib (n-1);\n+      y = _Cilk_spawn fib (n-2);\n+      _Cilk_sync;\n+      return (x+y);\n+      return 5;\n+    }\n+}\n+\n+int main_parallel (int argc, char *argv[])\n+{\n+  int n, result;\n+  if (argc == 2)\n+    n = atoi(argv[1]);\n+  else\n+    n = DEFAULT_VALUE;\n+  result = _Cilk_spawn fib(n);\n+  _Cilk_sync; \n+  return result;\n+}\n+\n+int fib_serial (int n)\n+{\n+  int x, y;\n+  if (n < 2)\n+    return n;\n+  else\n+    {\n+      x = fib (n-1);\n+      y = fib (n-2);\n+      return (x+y);\n+    }\n+}\n+  \n+int main_serial (int argc, char *argv[])\n+{\n+  int n, result;\n+\n+  if (argc == 2)\n+    n = atoi (argv[1]);\n+  else\n+    n = DEFAULT_VALUE;\n+  result = fib_serial (n);\n+\n+  return result;\n+}\n+\n+int main (void)\n+{\n+  if (main_serial (1, 0) != main_parallel (1,0))\n+    return 1;\n+  else \n+    return 0;\n+}\n+"}, {"sha": "ac37952837953714ae312cccd666ba9b65ad0d15", "filename": "gcc/testsuite/c-c++-common/cilk-plus/CK/spawning_arg.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/939b37da6ded55070bd78fc28d3fd2222b4278fa/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fspawning_arg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/939b37da6ded55070bd78fc28d3fd2222b4278fa/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fspawning_arg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fspawning_arg.c?ref=939b37da6ded55070bd78fc28d3fd2222b4278fa", "patch": "@@ -0,0 +1,37 @@\n+/* { dg-do run  { target { i?86-*-* x86_64-*-* } } } */\n+/* { dg-options \"-fcilkplus\" } */\n+/* { dg-options \"-lcilkrts\" { target { i?86-*-* x86_64-*-* } } } */\n+\n+void f0(volatile int *steal_flag)\n+{ \n+  int i = 0;\n+  /* Wait for steal_flag to be set */\n+  while (!*steal_flag) \n+    ;\n+}\n+\n+int f1()\n+{\n+\n+  volatile int steal_flag = 0;\n+  _Cilk_spawn f0(&steal_flag);\n+  steal_flag = 1;  // Indicate stolen\n+  _Cilk_sync; \n+  return 0;\n+}\n+\n+void f2(int q)\n+{\n+  q = 5;\n+}\n+\n+void f3()\n+{\n+   _Cilk_spawn f2(f1());\n+}\n+\n+int main()\n+{\n+  f3();\n+  return 0;\n+}"}, {"sha": "21d6797857dcdd5864f374390a1bf444556642a6", "filename": "gcc/testsuite/c-c++-common/cilk-plus/CK/steal_check.c", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/939b37da6ded55070bd78fc28d3fd2222b4278fa/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fsteal_check.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/939b37da6ded55070bd78fc28d3fd2222b4278fa/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fsteal_check.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fsteal_check.c?ref=939b37da6ded55070bd78fc28d3fd2222b4278fa", "patch": "@@ -0,0 +1,43 @@\n+/* { dg-do run  { target { i?86-*-* x86_64-*-* } } } */\n+/* { dg-options \"-fcilkplus\" } */\n+/* { dg-options \"-lcilkrts\" { target { i?86-*-* x86_64-*-* } } } */\n+\n+// #include <cilk/cilk_api.h>\n+extern void __cilkrts_set_param (char *, char *);\n+\n+void foo(volatile int *);\n+\n+void main2(void);\n+\n+int main(void)\n+{\n+ //  __cilkrts_set_param ((char *)\"nworkers\", (char *)\"2\");\n+  main2();\n+  return 0;\n+}\n+\n+\n+void main2(void)\n+{\n+  int some_var = 0;\n+\n+  _Cilk_spawn foo(&some_var);\n+\n+  some_var=1;\n+  some_var=5;\n+  some_var=3;\n+  some_var=4;\n+\n+  _Cilk_sync; \n+  return;\n+}\n+\n+void foo(volatile int *some_other_var)\n+{\n+  while (*some_other_var == 0)\n+  {\n+   ;\n+  }\n+}\n+\n+"}, {"sha": "51be796e562416116e2d43fda4c547af1e77df8a", "filename": "gcc/testsuite/c-c++-common/cilk-plus/CK/sync_wo_spawn.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/939b37da6ded55070bd78fc28d3fd2222b4278fa/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fsync_wo_spawn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/939b37da6ded55070bd78fc28d3fd2222b4278fa/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fsync_wo_spawn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fsync_wo_spawn.c?ref=939b37da6ded55070bd78fc28d3fd2222b4278fa", "patch": "@@ -0,0 +1,9 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fcilkplus\" } */\n+\n+int main (void)\n+{\n+  _Cilk_sync; /* { dg-error \"expected '_Cilk_spawn' before '_Cilk_sync'\" } */\n+  return 0;\n+}\n+"}, {"sha": "2b37cd664c1bf566fcaf65712ca672661ca3dde7", "filename": "gcc/testsuite/c-c++-common/cilk-plus/CK/test__cilk.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/939b37da6ded55070bd78fc28d3fd2222b4278fa/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Ftest__cilk.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/939b37da6ded55070bd78fc28d3fd2222b4278fa/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Ftest__cilk.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Ftest__cilk.c?ref=939b37da6ded55070bd78fc28d3fd2222b4278fa", "patch": "@@ -0,0 +1,10 @@\n+/* { dg-do compile } */\n+/* { dg-do run  { target { i?86-*-* x86_64-*-* } } } */\n+/* { dg-options \"-fcilkplus\" } */\n+\n+int main (void)\n+{\n+  if (__cilk == 200)\n+   return 0; \n+  return 1;\n+}"}, {"sha": "ab5d63a3f4c635005d7931394bd7dab7a3c8a2c5", "filename": "gcc/testsuite/c-c++-common/cilk-plus/CK/varargs_test.c", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/939b37da6ded55070bd78fc28d3fd2222b4278fa/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fvarargs_test.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/939b37da6ded55070bd78fc28d3fd2222b4278fa/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fvarargs_test.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FCK%2Fvarargs_test.c?ref=939b37da6ded55070bd78fc28d3fd2222b4278fa", "patch": "@@ -0,0 +1,47 @@\n+/* { dg-do run  { target { i?86-*-* x86_64-*-* } } } */\n+/* { dg-options \"-fcilkplus\" } */\n+/* { dg-options \"-lcilkrts\" { target { i?86-*-* x86_64-*-* } } } */\n+\n+#include <stdarg.h>\n+#include <stdlib.h>\n+\n+\n+double compute_total (int no_elements, ...);\n+\n+int main(void)\n+{\n+  double array[5] = {5.0, 4.0, 9.0, 3.0, 4.0};\n+  double array2[5] = {5.0, 6.0, 8.0, 6.0};\n+  double yy=0, xx=0, xx_serial, yy_serial;\n+\n+  yy = _Cilk_spawn compute_total(5,array[0],array[1],array[2],\n+                                 array[3], array[4]);\n+  xx= compute_total(4,array2[0],array2[1],array2[2], array2[3]);\n+  \n+  _Cilk_sync;\n+\n+  yy_serial = compute_total(5,array[0],array[1],array[2], array[3], array[4]);\n+  xx_serial = compute_total(4,array2[0],array2[1],array2[2], array2[3]);\n+\n+  if ((xx + yy) != (xx_serial + yy_serial)) \n+    return 1;\n+  return 0;\n+  \n+}\n+\n+\n+double compute_total (int no_elements, ...)\n+{\n+  double total = 0;\n+  va_list args;\n+  va_start(args, no_elements);\n+  int ii = 0;\n+  for (ii = 0; ii < no_elements; ii++)\n+  {\n+    total += va_arg(args,double);\n+  }\n+  va_end(args);\n+\n+  return total;\n+}\n+"}, {"sha": "a8f00d493ee99d7a83093203186e0075d7cab6d7", "filename": "gcc/testsuite/gcc.dg/cilk-plus/cilk-plus.exp", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/939b37da6ded55070bd78fc28d3fd2222b4278fa/gcc%2Ftestsuite%2Fgcc.dg%2Fcilk-plus%2Fcilk-plus.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/939b37da6ded55070bd78fc28d3fd2222b4278fa/gcc%2Ftestsuite%2Fgcc.dg%2Fcilk-plus%2Fcilk-plus.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcilk-plus%2Fcilk-plus.exp?ref=939b37da6ded55070bd78fc28d3fd2222b4278fa", "patch": "@@ -23,6 +23,11 @@ if { ![check_effective_target_cilkplus] } {\n     return;\n }\n \n+verbose \"$tool $libdir\" 1\n+set library_var [get_multilibs]\n+# Pointing the ld_library_path to the Cilk Runtime library binaries. \n+set ld_library_path \"${library_var}/libcilkrts/.libs\"\n+\n dg-init\n dg-runtest [lsort [glob -nocomplain $srcdir/c-c++-common/cilk-plus/AN/*.c]] \" -fcilkplus\" \" \"\n dg-runtest [lsort [glob -nocomplain $srcdir/c-c++-common/cilk-plus/AN/*.c]] \" -O0 -fcilkplus\" \" \"\n@@ -46,4 +51,31 @@ dg-runtest [lsort [glob -nocomplain $srcdir/c-c++-common/cilk-plus/AN/*.c]] \" -f\n dg-runtest [lsort [glob -nocomplain $srcdir/c-c++-common/cilk-plus/AN/*.c]] \" -fcilkplus -g -O2 -ftree-vectorize -std=c99\" \" \"\n dg-runtest [lsort [glob -nocomplain $srcdir/c-c++-common/cilk-plus/AN/*.c]] \" -fcilkplus -g -O3 -std=c99\" \" \"\n dg-runtest [lsort [glob -nocomplain $srcdir/c-c++-common/cilk-plus/AN/*.c]] \" -O3 -ftree-vectorize -std=c99 -g -fcilkplus\" \" \"\n+\n+\n+dg-runtest [lsort [glob -nocomplain $srcdir/c-c++-common/cilk-plus/CK/*.c]] \" -fcilkplus\" \" \"\n+dg-runtest [lsort [glob -nocomplain $srcdir/c-c++-common/cilk-plus/CK/*.c]] \" -O0 -fcilkplus\" \" \"\n+dg-runtest [lsort [glob -nocomplain $srcdir/c-c++-common/cilk-plus/CK/*.c]] \" -O1 -fcilkplus\" \" \"\n+dg-runtest [lsort [glob -nocomplain $srcdir/c-c++-common/cilk-plus/CK/*.c]] \" -O2 -ftree-vectorize -fcilkplus\" \" \"\n+dg-runtest [lsort [glob -nocomplain $srcdir/c-c++-common/cilk-plus/CK/*.c]] \" -O3 -fcilkplus\" \" \"\n+dg-runtest [lsort [glob -nocomplain $srcdir/c-c++-common/cilk-plus/CK/*.c]] \" -g -fcilkplus\" \" \"\n+dg-runtest [lsort [glob -nocomplain $srcdir/c-c++-common/cilk-plus/CK/*.c]] \" -g -O0 -fcilkplus\" \" \"\n+dg-runtest [lsort [glob -nocomplain $srcdir/c-c++-common/cilk-plus/CK/*.c]] \" -g -O1 -fcilkplus\" \" \"\n+dg-runtest [lsort [glob -nocomplain $srcdir/c-c++-common/cilk-plus/CK/*.c]] \" -g -O2 -ftree-vectorize -fcilkplus\" \" \"\n+dg-runtest [lsort [glob -nocomplain $srcdir/c-c++-common/cilk-plus/CK/*.c]] \" -g -O3 -fcilkplus\" \" \"\n+dg-runtest [lsort [glob -nocomplain $srcdir/c-c++-common/cilk-plus/CK/*.c]] \" -O3 -ftree-vectorize -fcilkplus -g\" \" \"\n+dg-runtest [lsort [glob -nocomplain $srcdir/c-c++-common/cilk-plus/CK/*.c]] \" -fcilkplus -std=c99\" \" \"\n+dg-runtest [lsort [glob -nocomplain $srcdir/c-c++-common/cilk-plus/CK/*.c]] \" -fcilkplus -O0 -std=c99\" \" \"\n+dg-runtest [lsort [glob -nocomplain $srcdir/c-c++-common/cilk-plus/CK/*.c]] \" -fcilkplus -O1 -std=c99\" \" \"\n+dg-runtest [lsort [glob -nocomplain $srcdir/c-c++-common/cilk-plus/CK/*.c]] \" -fcilkplus -O2 -ftree-vectorize -std=c99\" \" \"\n+dg-runtest [lsort [glob -nocomplain $srcdir/c-c++-common/cilk-plus/CK/*.c]] \" -fcilkplus -O3 -std=c99\" \" \"\n+dg-runtest [lsort [glob -nocomplain $srcdir/c-c++-common/cilk-plus/CK/*.c]] \" -fcilkplus -g -std=c99\" \" \"\n+dg-runtest [lsort [glob -nocomplain $srcdir/c-c++-common/cilk-plus/CK/*.c]] \" -fcilkplus -g -O0 -std=c99\" \" \"\n+dg-runtest [lsort [glob -nocomplain $srcdir/c-c++-common/cilk-plus/CK/*.c]] \" -fcilkplus -g -O1 -std=c99\" \" \"\n+dg-runtest [lsort [glob -nocomplain $srcdir/c-c++-common/cilk-plus/CK/*.c]] \" -fcilkplus -g -O2 -ftree-vectorize -std=c99\" \" \"\n+dg-runtest [lsort [glob -nocomplain $srcdir/c-c++-common/cilk-plus/CK/*.c]] \" -fcilkplus -g -O3 -std=c99\" \" \"\n+dg-runtest [lsort [glob -nocomplain $srcdir/c-c++-common/cilk-plus/CK/*.c]] \" -O3 -ftree-vectorize -std=c99 -g -fcilkplus\" \" \"\n+dg-runtest [lsort [glob -nocomplain $srcdir/c-c++-common/cilk-plus/CK/*.c]] \" -O0 -flto -g -fcilkplus\" \" \"\n+dg-runtest [lsort [glob -nocomplain $srcdir/c-c++-common/cilk-plus/CK/*.c]] \" -O2 -flto -g -fcilkplus\" \" \"\n+dg-runtest [lsort [glob -nocomplain $srcdir/c-c++-common/cilk-plus/CK/*.c]] \" -O3  -flto -g -fcilkplus\" \" \"\n dg-finish"}, {"sha": "cd3271545605ba8557d88fc45052033ce33cc563", "filename": "gcc/tree-inline.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/939b37da6ded55070bd78fc28d3fd2222b4278fa/gcc%2Ftree-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/939b37da6ded55070bd78fc28d3fd2222b4278fa/gcc%2Ftree-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.h?ref=939b37da6ded55070bd78fc28d3fd2222b4278fa", "patch": "@@ -131,6 +131,10 @@ typedef struct copy_body_data\n      the originals have been mapped to a value rather than to a\n      variable.  */\n   struct pointer_map_t *debug_map;\n+ \n+  /* Cilk keywords currently need to replace some variables that\n+     ordinary nested functions do not.  */ \n+  bool remap_var_for_cilk;\n } copy_body_data;\n \n /* Weights of constructions for estimate_num_insns.  */"}, {"sha": "fe756339f6d420110222352b7b51092238f2f505", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/939b37da6ded55070bd78fc28d3fd2222b4278fa/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/939b37da6ded55070bd78fc28d3fd2222b4278fa/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=939b37da6ded55070bd78fc28d3fd2222b4278fa", "patch": "@@ -2644,6 +2644,15 @@ dump_generic_node (pretty_printer *buffer, tree node, int spc, int flags,\n       dump_block_node (buffer, node, spc, flags);\n       break;\n \n+    case CILK_SPAWN_STMT:\n+      pp_string (buffer, \"_Cilk_spawn \");\n+      dump_generic_node (buffer, TREE_OPERAND (node, 0), spc, flags, false);\n+      break;\n+\n+    case CILK_SYNC_STMT:\n+      pp_string (buffer, \"_Cilk_sync\");\n+      break;\n+\n     default:\n       NIY;\n     }"}, {"sha": "399b5af6cbeecbf5719415f4642976890189651b", "filename": "gcc/tree.def", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/939b37da6ded55070bd78fc28d3fd2222b4278fa/gcc%2Ftree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/939b37da6ded55070bd78fc28d3fd2222b4278fa/gcc%2Ftree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.def?ref=939b37da6ded55070bd78fc28d3fd2222b4278fa", "patch": "@@ -1271,6 +1271,12 @@ DEFTREECODE (TARGET_OPTION_NODE, \"target_option_node\", tcc_exceptional, 0)\n    Operand 1 is the annotation id. */\n DEFTREECODE (ANNOTATE_EXPR, \"annotate_expr\", tcc_expression, 2)\n \n+/* Cilk spawn statement\n+   Operand 0 is the CALL_EXPR.  */\n+DEFTREECODE (CILK_SPAWN_STMT, \"cilk_spawn_stmt\", tcc_statement, 1)\n+\n+/* Cilk Sync statement: Does not have any operands.  */\n+DEFTREECODE (CILK_SYNC_STMT, \"cilk_sync_stmt\", tcc_statement, 0)\n \n /*\n Local variables:"}, {"sha": "cbe8272f646108cc2996dc4fd1284ff1ca2352e3", "filename": "gcc/tree.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/939b37da6ded55070bd78fc28d3fd2222b4278fa/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/939b37da6ded55070bd78fc28d3fd2222b4278fa/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=939b37da6ded55070bd78fc28d3fd2222b4278fa", "patch": "@@ -790,6 +790,9 @@ extern void omp_clause_range_check_failed (const_tree, const char *, int,\n #define CALL_EXPR_RETURN_SLOT_OPT(NODE) \\\n   (CALL_EXPR_CHECK (NODE)->base.private_flag)\n \n+/* Cilk keywords accessors.  */\n+#define CILK_SPAWN_FN(NODE) TREE_OPERAND (CILK_SPAWN_STMT_CHECK (NODE), 0)\n+\n /* In a RESULT_DECL, PARM_DECL and VAR_DECL, means that it is\n    passed by invisible reference (and the TREE_TYPE is a pointer to the true\n    type).  */"}]}