{"sha": "347248143da1f13b0e856e07eb69773a6512349a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzQ3MjQ4MTQzZGExZjEzYjBlODU2ZTA3ZWI2OTc3M2E2NTEyMzQ5YQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-02-21T22:58:19Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-02-21T22:58:19Z"}, "message": "New rules to allow attributes in a prefix position.\n\nFrom-SVN: r8995", "tree": {"sha": "41b78e1379377378bf8906947acac72bbb3ed434", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/41b78e1379377378bf8906947acac72bbb3ed434"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/347248143da1f13b0e856e07eb69773a6512349a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/347248143da1f13b0e856e07eb69773a6512349a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/347248143da1f13b0e856e07eb69773a6512349a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/347248143da1f13b0e856e07eb69773a6512349a/comments", "author": null, "committer": null, "parents": [{"sha": "4b4e3407104f39db5e654c96925d60e7b03dab7c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4b4e3407104f39db5e654c96925d60e7b03dab7c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4b4e3407104f39db5e654c96925d60e7b03dab7c"}], "stats": {"total": 39, "additions": 27, "deletions": 12}, "files": [{"sha": "c23d15f6c5117ed723ceef6f93030e7ec72f48e8", "filename": "gcc/c-parse.in", "status": "modified", "additions": 27, "deletions": 12, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/347248143da1f13b0e856e07eb69773a6512349a/gcc%2Fc-parse.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/347248143da1f13b0e856e07eb69773a6512349a/gcc%2Fc-parse.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parse.in?ref=347248143da1f13b0e856e07eb69773a6512349a", "patch": "@@ -30,7 +30,7 @@ ifobjc\n %expect 22\n end ifobjc\n ifc\n-%expect 10\n+%expect 23\n \n /* These are the 10 conflicts you should get in parse.output;\n    the state numbers may vary if minor changes in the grammar are made.\n@@ -227,6 +227,7 @@ static int if_stmt_line;\n \n /* List of types and structure classes of the current declaration.  */\n static tree current_declspecs;\n+static tree prefix_attributes = NULL_TREE;\n \n /* Stack of saved values of current_declspecs.  */\n static tree declspec_stack;\n@@ -879,7 +880,12 @@ setspecs: /* empty */\n \t\t  pending_xref_error ();\n \t\t  declspec_stack = tree_cons (NULL_TREE, current_declspecs,\n \t\t\t\t\t      declspec_stack);\n-\t\t  current_declspecs = $<ttype>0; }\n+\t\t  current_declspecs = $<ttype>0; \n+\t\t  prefix_attributes = NULL_TREE; }\n+\t;\n+\n+setattrs: /* empty */\n+\t\t{ prefix_attributes = $<ttype>0; }\n \t;\n \n decl:\n@@ -1017,32 +1023,33 @@ maybeasm:\n initdcl:\n \t  declarator maybeasm maybe_attribute '='\n \t\t{ $<ttype>$ = start_decl ($1, current_declspecs, 1);\n-\t\t  decl_attributes ($<ttype>$, $3);\n+\t\t  decl_attributes ($<ttype>$, $3, prefix_attributes);\n \t\t  start_init ($<ttype>$, $2, global_bindings_p ()); }\n \t  init\n /* Note how the declaration of the variable is in effect while its init is parsed! */\n \t\t{ finish_init ();\n-\t\t  decl_attributes ($<ttype>5, $3);\n+\t\t  decl_attributes ($<ttype>5, $3, prefix_attributes);\n \t\t  finish_decl ($<ttype>5, $6, $2); }\n \t| declarator maybeasm maybe_attribute\n \t\t{ tree d = start_decl ($1, current_declspecs, 0);\n-\t\t  decl_attributes (d, $3);\n-\t\t  finish_decl (d, NULL_TREE, $2); }\n+\t\t  decl_attributes (d, $3, prefix_attributes);\n+\t\t  finish_decl (d, NULL_TREE, $2); \n+                }\n \t;\n \n notype_initdcl:\n \t  notype_declarator maybeasm maybe_attribute '='\n \t\t{ $<ttype>$ = start_decl ($1, current_declspecs, 1);\n-\t\t  decl_attributes ($<ttype>$, $3);\n+\t\t  decl_attributes ($<ttype>$, $3, prefix_attributes);\n \t\t  start_init ($<ttype>$, $2, global_bindings_p ()); }\n \t  init\n /* Note how the declaration of the variable is in effect while its init is parsed! */\n \t\t{ finish_init ();\n-\t\t  decl_attributes ($<ttype>5, $3);\n+\t\t  decl_attributes ($<ttype>5, $3, prefix_attributes);\n \t\t  finish_decl ($<ttype>5, $6, $2); }\n \t| notype_declarator maybeasm maybe_attribute\n \t\t{ tree d = start_decl ($1, current_declspecs, 0);\n-\t\t  decl_attributes (d, $3);\n+\t\t  decl_attributes (d, $3, prefix_attributes);\n \t\t  finish_decl (d, NULL_TREE, $2); }\n \t;\n /* the * rules are dummies to accept the Apollo extended syntax\n@@ -1230,6 +1237,8 @@ after_type_declarator:\n \t\t{ $$ = build_nt (ARRAY_REF, $1, NULL_TREE); }\n \t| '*' type_quals after_type_declarator  %prec UNARY\n \t\t{ $$ = make_pointer_declarator ($2, $3); }\n+\t| attributes setattrs after_type_declarator\n+\t\t{ $$ = $3; }\n \t| TYPENAME\n ifobjc\n \t| OBJECTNAME\n@@ -1253,6 +1262,8 @@ parm_declarator:\n \t\t{ $$ = build_nt (ARRAY_REF, $1, NULL_TREE); }\n \t| '*' type_quals parm_declarator  %prec UNARY\n \t\t{ $$ = make_pointer_declarator ($2, $3); }\n+\t| attributes setattrs parm_declarator\n+\t\t{ $$ = $3; }\n \t| TYPENAME\n \t;\n \n@@ -1273,6 +1284,8 @@ notype_declarator:\n \t\t{ $$ = build_nt (ARRAY_REF, $1, $3); }\n \t| notype_declarator '[' ']'  %prec '.'\n \t\t{ $$ = build_nt (ARRAY_REF, $1, NULL_TREE); }\n+\t| attributes setattrs notype_declarator\n+\t\t{ $$ = $3; }\n \t| IDENTIFIER\n \t;\n \n@@ -1402,14 +1415,14 @@ components:\n component_declarator:\n \t  save_filename save_lineno declarator maybe_attribute\n \t\t{ $$ = grokfield ($1, $2, $3, current_declspecs, NULL_TREE);\n-\t\t  decl_attributes ($$, $4); }\n+\t\t  decl_attributes ($$, $4, prefix_attributes); }\n \t| save_filename save_lineno\n \t  declarator ':' expr_no_commas maybe_attribute\n \t\t{ $$ = grokfield ($1, $2, $3, current_declspecs, $5);\n-\t\t  decl_attributes ($$, $6); }\n+\t\t  decl_attributes ($$, $6, prefix_attributes); }\n \t| save_filename save_lineno ':' expr_no_commas maybe_attribute\n \t\t{ $$ = grokfield ($1, $2, NULL_TREE, current_declspecs, $4);\n-\t\t  decl_attributes ($$, $5); }\n+\t\t  decl_attributes ($$, $5, prefix_attributes); }\n \t;\n \n /* We chain the enumerators in reverse order.\n@@ -1480,6 +1493,8 @@ absdcl1:  /* a nonempty absolute declarator */\n \t\t{ $$ = build_nt (ARRAY_REF, NULL_TREE, $2); }\n \t| '[' ']'  %prec '.'\n \t\t{ $$ = build_nt (ARRAY_REF, NULL_TREE, NULL_TREE); }\n+\t| attributes setattrs absdcl1\n+\t\t{ $$ = $3; }\n \t;\n \n /* at least one statement, the first of which parses without error.  */"}]}