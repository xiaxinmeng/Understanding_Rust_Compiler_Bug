{"sha": "23356f93866e55ba44925bb03ef7b3d51f300fcb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjMzNTZmOTM4NjZlNTViYTQ0OTI1YmIwM2VmN2IzZDUxZjMwMGZjYg==", "commit": {"author": {"name": "Zack Weinberg", "email": "zackw@stanford.edu", "date": "2000-11-02T08:05:45Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2000-11-02T08:05:45Z"}, "message": "c-lex.c (init_c_lex): Update cpp_start_read call.\n\n        * c-lex.c (init_c_lex): Update cpp_start_read call.\n        (cb_ident): Update for new callback prototype.\n        (cb_def_pragma): Update for new cpp_get_token prototype.\n        (c_lex): Similarly.  Use cpp_get_line.\n\n        * c-parse.in (finish_parse): Update for new cpp_finish\n        prototype.\n\n        * cp/lex.c (finish_parse): Similarly.\n\nFrom-SVN: r37201", "tree": {"sha": "327fd8707268cc1943c8a1da483dc0412da3e575", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/327fd8707268cc1943c8a1da483dc0412da3e575"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/23356f93866e55ba44925bb03ef7b3d51f300fcb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/23356f93866e55ba44925bb03ef7b3d51f300fcb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/23356f93866e55ba44925bb03ef7b3d51f300fcb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/23356f93866e55ba44925bb03ef7b3d51f300fcb/comments", "author": null, "committer": null, "parents": [{"sha": "d83c7eb40da8e67095300c482a036744110e6203", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d83c7eb40da8e67095300c482a036744110e6203", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d83c7eb40da8e67095300c482a036744110e6203"}], "stats": {"total": 80, "additions": 44, "deletions": 36}, "files": [{"sha": "2d802eea99beba74c2396df71377af28099b1c3b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23356f93866e55ba44925bb03ef7b3d51f300fcb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23356f93866e55ba44925bb03ef7b3d51f300fcb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=23356f93866e55ba44925bb03ef7b3d51f300fcb", "patch": "@@ -1,3 +1,17 @@\n+2000-11-02  Zack Weinberg <zackw@Stanford.EDU>\n+\n+        Integrated CPP.\n+\t  \n+        * c-lex.c (init_c_lex): Update cpp_start_read call.\n+        (cb_ident): Update for new callback prototype.\n+        (cb_def_pragma): Update for new cpp_get_token prototype.\n+        (c_lex): Similarly.  Use cpp_get_line.\n+\t  \n+        * c-parse.in (finish_parse): Update for new cpp_finish\n+        prototype.\n+\t  \n+        * cp/lex.c (finish_parse): Similarly.\n+\n 2000-11-01  Geoff Keating  <geoffk@cygnus.com>\n \n \t* machmode.def: Add V16QImode."}, {"sha": "18a50cb42af6b4bfdf3fcce55d712c015e2f5003", "filename": "gcc/c-lex.c", "status": "modified", "additions": 28, "deletions": 34, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23356f93866e55ba44925bb03ef7b3d51f300fcb/gcc%2Fc-lex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23356f93866e55ba44925bb03ef7b3d51f300fcb/gcc%2Fc-lex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-lex.c?ref=23356f93866e55ba44925bb03ef7b3d51f300fcb", "patch": "@@ -159,8 +159,7 @@ static void extend_token_buffer_to\tPARAMS ((int));\n static int read_line_number\t\tPARAMS ((int *));\n static void process_directive\t\tPARAMS ((void));\n #else\n-static void cb_ident\t\tPARAMS ((cpp_reader *, const unsigned char *,\n-\t\t\t\t\t unsigned int));\n+static void cb_ident\t\tPARAMS ((cpp_reader *, const cpp_string *));\n static void cb_enter_file\tPARAMS ((cpp_reader *));\n static void cb_leave_file\tPARAMS ((cpp_reader *));\n static void cb_rename_file\tPARAMS ((cpp_reader *));\n@@ -221,7 +220,7 @@ init_c_lex (filename)\n   /* Make sure parse_in.digraphs matches flag_digraphs.  */\n   CPP_OPTION (&parse_in, digraphs) = flag_digraphs;\n \n-  if (! cpp_start_read (&parse_in, 0 /* no printer */, filename))\n+  if (! cpp_start_read (&parse_in, filename))\n     abort ();\n \n   if (filename == 0 || !strcmp (filename, \"-\"))\n@@ -673,16 +672,15 @@ process_directive ()\n    No need to deal with linemarkers under normal conditions.  */\n \n static void\n-cb_ident (pfile, str, len)\n+cb_ident (pfile, str)\n      cpp_reader *pfile ATTRIBUTE_UNUSED;\n-     const unsigned char *str;\n-     unsigned int len;\n+     const cpp_string *str;\n {\n #ifdef ASM_OUTPUT_IDENT\n   if (! flag_no_ident)\n     {\n       /* Convert escapes in the string.  */\n-      tree value = lex_string ((const char *)str, len, 0);\n+      tree value = lex_string ((const char *)str->text, str->len, 0);\n       ASM_OUTPUT_IDENT (asm_out_file, TREE_STRING_POINTER (value));\n     }\n #endif\n@@ -785,11 +783,15 @@ cb_def_pragma (pfile)\n      -Wunknown-pragmas has been given. */\n   if (warn_unknown_pragmas > in_system_header)\n     {\n-      const unsigned char *space, *name;\n-      const cpp_token *t = pfile->first_directive_token + 2;\n+      const unsigned char *space, *name = 0;\n+      cpp_token s;\n+\n+      cpp_get_token (pfile, &s);\n+      space = cpp_token_as_text (pfile, &s);\n+      cpp_get_token (pfile, &s);\n+      if (s.type == CPP_NAME)\n+\tname = cpp_token_as_text (pfile, &s);\n \n-      space = t[0].val.node->name;\n-      name  = t[1].type == CPP_NAME ? t[1].val.node->name : 0;\n       if (name)\n \twarning (\"ignoring #pragma %s %s\", space, name);\n       else\n@@ -1417,64 +1419,56 @@ c_lex (value)\n      tree *value;\n {\n #if USE_CPPLIB\n-  const cpp_token *tok;\n+  cpp_token tok;\n   enum cpp_ttype type;\n \n   retry:\n   timevar_push (TV_CPP);\n-  tok = cpp_get_token (&parse_in);\n+  cpp_get_token (&parse_in, &tok);\n   timevar_pop (TV_CPP);\n \n   /* The C++ front end does horrible things with the current line\n      number.  To ensure an accurate line number, we must reset it\n-     every time we return a token.  If we reset it from tok->line\n-     every time, we'll get line numbers inside macros referring to the\n-     macro definition; this is nice, but we don't want to change the\n-     behavior until integrated mode is the only option.  So we keep our\n-     own idea of the line number, and reset it from tok->line at each\n-     new line (which never happens inside a macro).  */\n-  if (tok->flags & BOL)\n-    lex_lineno = tok->line;\n+     every time we return a token.  */\n+  lex_lineno = cpp_get_line (&parse_in)->line;\n \n   *value = NULL_TREE;\n   lineno = lex_lineno;\n-  type = tok->type;\n+  type = tok.type;\n   switch (type)\n     {\n     case CPP_OPEN_BRACE:  indent_level++;  break;\n     case CPP_CLOSE_BRACE: indent_level--;  break;\n \n-    /* Issue this error here, where we can get at tok->val.aux.  */\n+    /* Issue this error here, where we can get at tok.val.aux.  */\n     case CPP_OTHER:\n-      if (ISGRAPH (tok->val.aux))\n-\terror (\"stray '%c' in program\", tok->val.aux);\n+      if (ISGRAPH (tok.val.aux))\n+\terror (\"stray '%c' in program\", tok.val.aux);\n       else\n-\terror (\"stray '\\\\%#o' in program\", tok->val.aux);\n+\terror (\"stray '\\\\%#o' in program\", tok.val.aux);\n       goto retry;\n       \n-    case CPP_DEFINED:\n-      type = CPP_NAME;\n     case CPP_NAME:\n-      *value = get_identifier ((const char *)tok->val.node->name);\n+      *value = get_identifier ((const char *)tok.val.node->name);\n       break;\n \n     case CPP_INT:\n     case CPP_FLOAT:\n     case CPP_NUMBER:\n-      *value = lex_number ((const char *)tok->val.str.text, tok->val.str.len);\n+      *value = lex_number ((const char *)tok.val.str.text, tok.val.str.len);\n       break;\n \n     case CPP_CHAR:\n     case CPP_WCHAR:\n-      *value = lex_charconst ((const char *)tok->val.str.text,\n-\t\t\t      tok->val.str.len, tok->type == CPP_WCHAR);\n+      *value = lex_charconst ((const char *)tok.val.str.text,\n+\t\t\t      tok.val.str.len, tok.type == CPP_WCHAR);\n       break;\n \n     case CPP_STRING:\n     case CPP_WSTRING:\n     case CPP_OSTRING:\n-      *value = lex_string ((const char *)tok->val.str.text,\n-\t\t\t   tok->val.str.len, tok->type == CPP_WSTRING);\n+      *value = lex_string ((const char *)tok.val.str.text,\n+\t\t\t   tok.val.str.len, tok.type == CPP_WSTRING);\n       break;\n \n       /* These tokens should not be visible outside cpplib.  */"}, {"sha": "ed272c8fe80c8ef97680c90e55aa86d93b3349c3", "filename": "gcc/c-parse.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23356f93866e55ba44925bb03ef7b3d51f300fcb/gcc%2Fc-parse.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23356f93866e55ba44925bb03ef7b3d51f300fcb/gcc%2Fc-parse.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parse.in?ref=23356f93866e55ba44925bb03ef7b3d51f300fcb", "patch": "@@ -3060,7 +3060,7 @@ void\n finish_parse ()\n {\n #if USE_CPPLIB\n-  cpp_finish (&parse_in, 0 /* no printer */);\n+  cpp_finish (&parse_in);\n   errorcount += parse_in.errors;\n #else\n   fclose (finput);"}, {"sha": "e5cdbf1c402b4c17d4bd58e00ec3696b10bcf139", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23356f93866e55ba44925bb03ef7b3d51f300fcb/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23356f93866e55ba44925bb03ef7b3d51f300fcb/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=23356f93866e55ba44925bb03ef7b3d51f300fcb", "patch": "@@ -775,7 +775,7 @@ void\n finish_parse ()\n {\n #if USE_CPPLIB\n-  cpp_finish (&parse_in, 0 /* no printer */);\n+  cpp_finish (&parse_in);\n   errorcount += parse_in.errors;\n #else\n   fclose (finput);"}]}