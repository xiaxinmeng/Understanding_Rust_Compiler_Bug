{"sha": "73701e27366b20395ad5c3e296983b20ae0235b1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzM3MDFlMjczNjZiMjAzOTVhZDVjM2UyOTY5ODNiMjBhZTAyMzViMQ==", "commit": {"author": {"name": "Trevor Smigiel", "email": "Trevor_Smigiel@playstation.sony.com", "date": "2007-02-21T23:28:46Z"}, "committer": {"name": "Trevor Smigiel", "email": "tsmigiel@gcc.gnu.org", "date": "2007-02-21T23:28:46Z"}, "message": "Change the defaults of some parameters and options.\n\n2007-02-21  Trevor Smigiel  <trevor_smigiel@playstation.sony.com>\n\n\tChange the defaults of some parameters and options.\n\t* config/spu/spu-protos.h (spu_optimization_options): Declare.\n\t* config/spu/spu.c (spu_optimization_options): Add.\n\t(spu_override_options): Change params in spu_optimization_options.\n\t* config/spu/spu.h (OPTIMIZATION_OPTIONS): Define.\n\n\tRegister 127 is only 16 byte aligned when used as a frame pointer.\n\t* config/spu/spu-protos.h (spu_init_expanders): Declare.\n\t* config/spu/spu.c (spu_expand_prologue): Set REGNO_POINTER_ALIGN for\n\tHARD_FRAME_POINTER_REGNUM.\n\t(spu_legitimate_address):  Use regno_aligned_for_reload.\n\t(regno_aligned_for_load):  HARD_FRAME_POINTER_REGNUM is only 16 byte\n\taligned when frame_pointer_needed is true.\n\t(spu_init_expanders): New.  Set alignment of HARD_FRAME_POINTER_REGNUM\n\tto 8 bits.\n\t* config/spu/spu.h (INIT_EXPANDERS): Define.\n\n\tMake sure shift and rotate instructions have valid immediate operands.\n\t* config/spu/predicates.md (spu_shift_operand): Remove.\n\t* config/spu/spu.c (print_operand): Add [efghEFGH] modifiers.\n\t* config/spu/constraints.md (W, O): Extend range. \n\t* config/spu/spu.md (umask, nmask): Define.\n\t(ashl<mode>3, ashldi3, ashlti3_imm, shlqbybi_ti, shlqbi_ti, shlqby_ti,\n\tlshr<mode>3, rotm_<mode>, lshr<mode>3_imm, rotqmbybi_<mode>,\n\trotqmbi_<mode>, rotqmby_<mode>, ashr<mode>3, rotma_<mode>,\n\trotl<mode>3, rotlti3, rotqbybi_ti, rotqby_ti, rotqbi_ti): Use\n\tspu_nonmem_operand instead of spu_shift_operands.  Use new modifiers.\n\t(lshr<mode>3_reg):  Fix rtl description.\n\n\tMake sure mulhisi immediate operands are valid.\n\t* config/spu/predicates.md (imm_K_operand): Add.\n\t* config/spu/spu.md (mulhisi3_imm, umulhisi3_imm): Use imm_K_operand.\n\n\tGenerate constants using fsmbi and andi.\n\t* config/spu/spu.c (enum immediate_class): Add IC_FSMBI2.\n\t(print_operand, spu_split_immediate, classify_immediate,\n\tfsmbi_const_p): Handle IC_FSMBI2.\n\n\tCorrectly handle a CONST_VECTOR containing symbols.\n\t* config/spu/spu.c (print_operand): Handle HIGH correctly.\n\t(spu_split_immediate): Split CONST_VECTORs with -mlarge-mem.\n\t(immediate_load_p): Allow symbols that use 2 instructions to create.\n\t(classify_immediate, spu_builtin_splats):  Don't accept a CONST_VECTOR\n\twith symbols when flag_pic is set.\n\t(const_vector_immediate_p): New.\n\t(logical_immediate_p, iohl_immediate_p, arith_immediate_p): Don't\n\taccept a CONST_VECTOR with symbols.\n\t(spu_legitimate_constant_p): Use const_vector_immediate_p.  Don't\n\taccept a CONST_VECTOR with symbols when flag_pic is set.  Handle HIGH\n\tcorrectly.\n\t* config/spu/spu.md (high, low): Delete.\n\t(low_<mode>): Define.\n\n\tRemove INTRmode and INTR_REGNUM, which didn't work.\n\t* config/spu/spu.c (spu_conditional_register_usage): Remove reference\n\tof INTR_REGNUM.\n\t* config/spu/spu-builtins.md (spu_idisable, spu_ienable, set_intr,\n\tset_intr_pic, set_intr_cc, set_intr_cc_pic, set_intr_return, unnamed\n\tpeephole2 pattern): Don't use INTR or 131.\n\t(movintrcc): Delete.\n\t* config/spu/spu.h (FIRST_PSEUDO_REGISTER, FIXED_REGISTERS,\n\tCALL_USED_REGISTERS, REGISTER_NAMES, INTR_REGNUM): Remove INTR_REGNUM.\n\t* config/spu/spu.md (UNSPEC_IDISABLE, UNSPEC_IENABLE): Remove.\n\t(UNSPEC_SET_INTR): Add.\n\t* config/spu/spu-modes.def (INTR): Remove.\n\n\tMore accurate warnings about run-time relocations.\n\t* config/spu/spu.c (reloc_diagnostic): Test in_section.\n\n\tCorrectly warn about immediate arguments to specific intrinsics.\n\t* config/spu/spu.c (spu_check_builtin_parm): Handle CONST_VECTORs.\n\t(spu_expand_builtin_1): Call spu_check_builtin_parm before checking\n\tthe instruction predicate.\n\n\tFix tree check errors with latest update.\n\t* config/spu/spu.c (expand_builtin_args, spu_expand_builtin_1): Use\n\tCALL_EXPR_ARG.\n\t(spu_expand_builtin): Use CALL_EXPR_FN.\n\n\tAdd missing specific intrinsics.\n\t* config/spu/spu-builtins.def: Add si_bisled, si_bisledd and\n\tsi_bislede.\n\t* config/spu/spu_internals.h: Ditto.\n\n\tFix incorrect operand modifiers.\n\t* config/spu/spu-builtins.md (spu_mpy, spu_mpyu):  Remove use of %H.\n\t* config/spu/spu.md (xor<mode>3):  Change %S to %J.\n\n\tOptimize one case of zero_extend of a vec_select.\n\t* config/spu/spu.md (_vec_extractv8hi_ze):  Add.\n\n\tAccept any immediate for hbr.\n\t* config/spu/spu.md (hbr):  Change s constraints to i.\n\nFrom-SVN: r122210", "tree": {"sha": "8e9c6dc9eb86af757f25cdc1cdc8310d88ab4222", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8e9c6dc9eb86af757f25cdc1cdc8310d88ab4222"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/73701e27366b20395ad5c3e296983b20ae0235b1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73701e27366b20395ad5c3e296983b20ae0235b1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/73701e27366b20395ad5c3e296983b20ae0235b1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73701e27366b20395ad5c3e296983b20ae0235b1/comments", "author": null, "committer": null, "parents": [{"sha": "c0bca7e18124cf5b3097f1422d12c5f9f01e3344", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0bca7e18124cf5b3097f1422d12c5f9f01e3344", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c0bca7e18124cf5b3097f1422d12c5f9f01e3344"}], "stats": {"total": 585, "additions": 404, "deletions": 181}, "files": [{"sha": "f85cc7957af4b75b2614570b79f64e81c5f4695f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73701e27366b20395ad5c3e296983b20ae0235b1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73701e27366b20395ad5c3e296983b20ae0235b1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=73701e27366b20395ad5c3e296983b20ae0235b1", "patch": "@@ -1,3 +1,99 @@\n+2007-02-21  Trevor Smigiel  <trevor_smigiel@playstation.sony.com>\n+\n+\tChange the defaults of some parameters and options.\n+\t* config/spu/spu-protos.h (spu_optimization_options): Declare.\n+\t* config/spu/spu.c (spu_optimization_options): Add.\n+\t(spu_override_options): Change params in spu_optimization_options.\n+\t* config/spu/spu.h (OPTIMIZATION_OPTIONS): Define.\n+\n+\tRegister 127 is only 16 byte aligned when used as a frame pointer.\n+\t* config/spu/spu-protos.h (spu_init_expanders): Declare.\n+\t* config/spu/spu.c (spu_expand_prologue): Set REGNO_POINTER_ALIGN for\n+\tHARD_FRAME_POINTER_REGNUM.\n+\t(spu_legitimate_address):  Use regno_aligned_for_reload.\n+\t(regno_aligned_for_load):  HARD_FRAME_POINTER_REGNUM is only 16 byte\n+\taligned when frame_pointer_needed is true.\n+\t(spu_init_expanders): New.  Set alignment of HARD_FRAME_POINTER_REGNUM\n+\tto 8 bits.\n+\t* config/spu/spu.h (INIT_EXPANDERS): Define.\n+\n+\tMake sure shift and rotate instructions have valid immediate operands.\n+\t* config/spu/predicates.md (spu_shift_operand): Remove.\n+\t* config/spu/spu.c (print_operand): Add [efghEFGH] modifiers.\n+\t* config/spu/constraints.md (W, O): Extend range. \n+\t* config/spu/spu.md (umask, nmask): Define.\n+\t(ashl<mode>3, ashldi3, ashlti3_imm, shlqbybi_ti, shlqbi_ti, shlqby_ti,\n+\tlshr<mode>3, rotm_<mode>, lshr<mode>3_imm, rotqmbybi_<mode>,\n+\trotqmbi_<mode>, rotqmby_<mode>, ashr<mode>3, rotma_<mode>,\n+\trotl<mode>3, rotlti3, rotqbybi_ti, rotqby_ti, rotqbi_ti): Use\n+\tspu_nonmem_operand instead of spu_shift_operands.  Use new modifiers.\n+\t(lshr<mode>3_reg):  Fix rtl description.\n+\n+\tMake sure mulhisi immediate operands are valid.\n+\t* config/spu/predicates.md (imm_K_operand): Add.\n+\t* config/spu/spu.md (mulhisi3_imm, umulhisi3_imm): Use imm_K_operand.\n+\n+\tGenerate constants using fsmbi and andi.\n+\t* config/spu/spu.c (enum immediate_class): Add IC_FSMBI2.\n+\t(print_operand, spu_split_immediate, classify_immediate,\n+\tfsmbi_const_p): Handle IC_FSMBI2.\n+\n+\tCorrectly handle a CONST_VECTOR containing symbols.\n+\t* config/spu/spu.c (print_operand): Handle HIGH correctly.\n+\t(spu_split_immediate): Split CONST_VECTORs with -mlarge-mem.\n+\t(immediate_load_p): Allow symbols that use 2 instructions to create.\n+\t(classify_immediate, spu_builtin_splats):  Don't accept a CONST_VECTOR\n+\twith symbols when flag_pic is set.\n+\t(const_vector_immediate_p): New.\n+\t(logical_immediate_p, iohl_immediate_p, arith_immediate_p): Don't\n+\taccept a CONST_VECTOR with symbols.\n+\t(spu_legitimate_constant_p): Use const_vector_immediate_p.  Don't\n+\taccept a CONST_VECTOR with symbols when flag_pic is set.  Handle HIGH\n+\tcorrectly.\n+\t* config/spu/spu.md (high, low): Delete.\n+\t(low_<mode>): Define.\n+\n+\tRemove INTRmode and INTR_REGNUM, which didn't work.\n+\t* config/spu/spu.c (spu_conditional_register_usage): Remove reference\n+\tof INTR_REGNUM.\n+\t* config/spu/spu-builtins.md (spu_idisable, spu_ienable, set_intr,\n+\tset_intr_pic, set_intr_cc, set_intr_cc_pic, set_intr_return, unnamed\n+\tpeephole2 pattern): Don't use INTR or 131.\n+\t(movintrcc): Delete.\n+\t* config/spu/spu.h (FIRST_PSEUDO_REGISTER, FIXED_REGISTERS,\n+\tCALL_USED_REGISTERS, REGISTER_NAMES, INTR_REGNUM): Remove INTR_REGNUM.\n+\t* config/spu/spu.md (UNSPEC_IDISABLE, UNSPEC_IENABLE): Remove.\n+\t(UNSPEC_SET_INTR): Add.\n+\t* config/spu/spu-modes.def (INTR): Remove.\n+\n+\tMore accurate warnings about run-time relocations.\n+\t* config/spu/spu.c (reloc_diagnostic): Test in_section.\n+\n+\tCorrectly warn about immediate arguments to specific intrinsics.\n+\t* config/spu/spu.c (spu_check_builtin_parm): Handle CONST_VECTORs.\n+\t(spu_expand_builtin_1): Call spu_check_builtin_parm before checking\n+\tthe instruction predicate.\n+\n+\tFix tree check errors with latest update.\n+\t* config/spu/spu.c (expand_builtin_args, spu_expand_builtin_1): Use\n+\tCALL_EXPR_ARG.\n+\t(spu_expand_builtin): Use CALL_EXPR_FN.\n+\n+\tAdd missing specific intrinsics.\n+\t* config/spu/spu-builtins.def: Add si_bisled, si_bisledd and\n+\tsi_bislede.\n+\t* config/spu/spu_internals.h: Ditto.\n+\n+\tFix incorrect operand modifiers.\n+\t* config/spu/spu-builtins.md (spu_mpy, spu_mpyu):  Remove use of %H.\n+\t* config/spu/spu.md (xor<mode>3):  Change %S to %J.\n+\n+\tOptimize one case of zero_extend of a vec_select.\n+\t* config/spu/spu.md (_vec_extractv8hi_ze):  Add.\n+\n+\tAccept any immediate for hbr.\n+\t* config/spu/spu.md (hbr):  Change s constraints to i.\n+\n 2007-02-21  Paul Brook  <paul@codesourcery.com>\n \n \t* config/arm/arm.c (thumb2_final_prescan_insn): Don't incrememnt"}, {"sha": "1006b07ecaf474614724758af318259a9153b8af", "filename": "gcc/config/spu/constraints.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73701e27366b20395ad5c3e296983b20ae0235b1/gcc%2Fconfig%2Fspu%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73701e27366b20395ad5c3e296983b20ae0235b1/gcc%2Fconfig%2Fspu%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fconstraints.md?ref=73701e27366b20395ad5c3e296983b20ae0235b1", "patch": "@@ -53,7 +53,7 @@\n (define_constraint \"W\"\n   \"An immediate for shift and rotate instructions.  const_int is treated as a 32-bit value.\"\n   (and (match_code \"const_int,const_double,const_vector\")\n-       (match_test \"arith_immediate_p (op, SImode, -0x40, 0x3f)\")))\n+       (match_test \"arith_immediate_p (op, SImode, -0x80000000ll, 0x7fffffffll)\")))\n \n (define_constraint \"Y\"\n   \"An immediate for and/xor/or instructions.  const_int is sign extended as a 128 bit.\"\n@@ -131,7 +131,7 @@\n (define_constraint \"O\"\n   \"An unsigned 7-bit constant whose 3 least significant bits are 0.\"\n   (and (match_code \"const_int\")\n-       (match_test \"ival >= 0 && ival <= 0x7f && (ival & 7) == 0\")))\n+       (match_test \"(ival & 7) == 0\")))\n \n (define_constraint \"P\"\n   \"An unsigned 3-bit constant for 16-byte rotates and shifts\""}, {"sha": "8b31e65e6f530b3963af3381fc7ab22277e8ef74", "filename": "gcc/config/spu/predicates.md", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73701e27366b20395ad5c3e296983b20ae0235b1/gcc%2Fconfig%2Fspu%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73701e27366b20395ad5c3e296983b20ae0235b1/gcc%2Fconfig%2Fspu%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fpredicates.md?ref=73701e27366b20395ad5c3e296983b20ae0235b1", "patch": "@@ -85,15 +85,9 @@\n     return 0;\n   })\n \n-(define_predicate \"spu_shift_operand\"\n-  (match_code \"reg,subreg,const_int,const_vector\")\n-  {\n-    if (spu_reg_operand (op, mode))\n-      return 1;\n-    if (GET_CODE (op) == CONST_INT || GET_CODE (op) == CONST_VECTOR)\n-      return arith_immediate_p (op, mode, -0x40, 0x3f);\n-    return 0;\n-  })\n+(define_predicate \"imm_K_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"arith_immediate_p (op, mode, -0x200, 0x1ff)\")))\n \n ;; Return 1 if OP is a comparison operation that is valid for a branch insn.\n ;; We only check the opcode against the mode of the register value here. "}, {"sha": "6ae382fdd9b671893c7428fd4be842c3fdfbf762", "filename": "gcc/config/spu/spu-builtins.def", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73701e27366b20395ad5c3e296983b20ae0235b1/gcc%2Fconfig%2Fspu%2Fspu-builtins.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73701e27366b20395ad5c3e296983b20ae0235b1/gcc%2Fconfig%2Fspu%2Fspu-builtins.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu-builtins.def?ref=73701e27366b20395ad5c3e296983b20ae0235b1", "patch": "@@ -163,6 +163,9 @@ DEF_BUILTIN (SI_CLGTH,       CODE_FOR_clgt_v8hi,     \"si_clgth\",       B_INSN,\n DEF_BUILTIN (SI_CLGTHI,      CODE_FOR_clgt_v8hi,     \"si_clgthi\",      B_INSN,   _A3(SPU_BTI_QUADWORD, SPU_BTI_QUADWORD, SPU_BTI_S10))\n DEF_BUILTIN (SI_CLGT,        CODE_FOR_clgt_v4si,     \"si_clgt\",        B_INSN,   _A3(SPU_BTI_QUADWORD, SPU_BTI_QUADWORD, SPU_BTI_QUADWORD))\n DEF_BUILTIN (SI_CLGTI,       CODE_FOR_clgt_v4si,     \"si_clgti\",       B_INSN,   _A3(SPU_BTI_QUADWORD, SPU_BTI_QUADWORD, SPU_BTI_S10))\n+DEF_BUILTIN (SI_BISLED,      CODE_FOR_spu_bisled,    \"si_bisled\",      B_BISLED, _A3(SPU_BTI_VOID,     SPU_BTI_QUADWORD, SPU_BTI_PTR))\n+DEF_BUILTIN (SI_BISLEDD,     CODE_FOR_spu_bisledd,   \"si_bisledd\",     B_BISLED, _A3(SPU_BTI_VOID,     SPU_BTI_QUADWORD, SPU_BTI_PTR))\n+DEF_BUILTIN (SI_BISLEDE,     CODE_FOR_spu_bislede,   \"si_bislede\",     B_BISLED, _A3(SPU_BTI_VOID,     SPU_BTI_QUADWORD, SPU_BTI_PTR))\n DEF_BUILTIN (SI_FA,          CODE_FOR_addv4sf3,      \"si_fa\",          B_INSN,   _A3(SPU_BTI_QUADWORD, SPU_BTI_QUADWORD, SPU_BTI_QUADWORD))\n DEF_BUILTIN (SI_DFA,         CODE_FOR_addv2df3,      \"si_dfa\",         B_INSN,   _A3(SPU_BTI_QUADWORD, SPU_BTI_QUADWORD, SPU_BTI_QUADWORD))\n DEF_BUILTIN (SI_FS,          CODE_FOR_subv4sf3,      \"si_fs\",          B_INSN,   _A3(SPU_BTI_QUADWORD, SPU_BTI_QUADWORD, SPU_BTI_QUADWORD))"}, {"sha": "5cd3b54b9e261d9b6b3d6f442a7a788b506c1504", "filename": "gcc/config/spu/spu-builtins.md", "status": "modified", "additions": 22, "deletions": 46, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73701e27366b20395ad5c3e296983b20ae0235b1/gcc%2Fconfig%2Fspu%2Fspu-builtins.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73701e27366b20395ad5c3e296983b20ae0235b1/gcc%2Fconfig%2Fspu%2Fspu-builtins.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu-builtins.md?ref=73701e27366b20395ad5c3e296983b20ae0235b1", "patch": "@@ -213,7 +213,7 @@\n   \"\"\n   \"@\n    mpy\\t%0,%1,%2\n-   mpyi\\t%0,%1,%H2\"\n+   mpyi\\t%0,%1,%2\"\n   [(set_attr \"type\" \"fp7\")])\n \n (define_insn \"spu_mpyu\"\n@@ -230,7 +230,7 @@\n   \"\"\n   \"@\n    mpyu\\t%0,%1,%2\n-   mpyui\\t%0,%1,%H2\"\n+   mpyui\\t%0,%1,%2\"\n   [(set_attr \"type\" \"fp7\")])\n \n (define_insn \"spu_mpya\"\n@@ -607,27 +607,24 @@\n   [(set_attr \"type\" \"br\")])\n \n ;; interrupt disable/enable\n-;; Register 131 is used exclusively for enabling/disabling interrupts.\n-;; It is marked as a global reg and the instructions clobber mem, so it will\n-;; not be incorrectly optimized.\n (define_expand \"spu_idisable\"\n   [(parallel\n-    [(set (reg:INTR 131) (const_int 0))\n+    [(unspec_volatile [(const_int 0)] UNSPEC_SET_INTR)\n      (clobber (match_dup:SI 0))\n      (clobber (mem:BLK (scratch)))])]\n   \"\"\n   \"operands[0] = gen_reg_rtx (SImode);\")\n \n (define_expand \"spu_ienable\"\n   [(parallel\n-    [(set (reg:INTR 131) (const_int 1))\n+    [(unspec_volatile [(const_int 1)] UNSPEC_SET_INTR)\n      (clobber (match_dup:SI 0))\n      (clobber (mem:BLK (scratch)))])]\n   \"\"\n   \"operands[0] = gen_reg_rtx (SImode);\")\n \n (define_insn \"set_intr\"\n-  [(set (reg:INTR 131) (match_operand 1 \"const_int_operand\" \"i\"))\n+  [(unspec_volatile [(match_operand 1 \"const_int_operand\" \"i\")] UNSPEC_SET_INTR)\n    (clobber (match_operand:SI 0 \"spu_reg_operand\" \"=&r\"))\n    (clobber (mem:BLK (scratch)))]\n   \"! flag_pic\"\n@@ -636,77 +633,56 @@\n    (set_attr \"type\" \"multi0\")])\n \n (define_insn \"set_intr_pic\"\n-  [(set (reg:INTR 131) (match_operand 1 \"const_int_operand\" \"i\"))\n+  [(unspec_volatile [(match_operand 1 \"const_int_operand\" \"i\")] UNSPEC_SET_INTR)\n    (clobber (match_operand:SI 0 \"spu_reg_operand\" \"=&r\"))\n    (clobber (mem:BLK (scratch)))]\n   \"flag_pic\"\n   \"brsl\\t%0,.+4\\;ai\\t%0,%0,8\\;bi%I1\\t%0\"\n   [(set_attr \"length\" \"12\")\n    (set_attr \"type\" \"multi1\")])\n \n-(define_expand \"movintrcc\"\n-  [(parallel\n-    [(set (match_operand:INTR 0 \"spu_reg_operand\" \"\")\n-\t  (if_then_else:INTR (match_operand 1 \"branch_comparison_operator\" \"\")\n-\t\t\t(match_operand 3 \"const_int_operand\" \"\")\n-\t\t\t(match_operand:INTR 2 \"spu_reg_operand\" \"\")))\n-     (clobber (match_dup:SI 4))\n-     (clobber (mem:BLK (scratch)))])]\n-  \"\"\n-  { /* We've swapped operands 2 and 3 in the pattern, reverse the\n-       condition code too. */\n-    PUT_CODE (operands[1], reverse_condition (GET_CODE (operands[1])));\n-    operands[4] = gen_reg_rtx (SImode);\n-  })\n-\n (define_insn \"set_intr_cc\"\n-  [(set (reg:INTR 131)\n-\t(if_then_else:INTR\n-\t  (match_operator 1 \"branch_comparison_operator\"\n-\t    [(match_operand 2 \"spu_reg_operand\" \"r\")\n-\t     (const_int 0)])\n-\t  (match_operand:SI 3 \"const_int_operand\" \"i\")\n-\t  (reg:INTR 131)))\n-   (clobber (match_operand:SI 0 \"spu_reg_operand\" \"=&r\"))\n-   (clobber (mem:BLK (scratch)))]\n+  [(cond_exec (match_operator 1 \"branch_comparison_operator\"\n+\t\t[(match_operand 2 \"spu_reg_operand\" \"r\")\n+\t\t (const_int 0)])\n+              (parallel [(unspec_volatile [(match_operand:SI 3 \"const_int_operand\" \"i\")] UNSPEC_SET_INTR)\n+                         (clobber (match_operand:SI 0 \"spu_reg_operand\" \"=&r\"))\n+\t\t\t (clobber (mem:BLK (scratch)))]))]\n   \"! flag_pic\"\n   \"ila\\t%0,.+8\\;bi%b2%b1z%I3\\t%2,%0\"\n   [(set_attr \"length\" \"8\")\n    (set_attr \"type\" \"multi0\")])\n \n (define_insn \"set_intr_cc_pic\"\n-  [(set (reg:INTR 131)\n-\t(if_then_else:INTR\n-\t  (match_operator 1 \"branch_comparison_operator\"\n-\t    [(match_operand 2 \"spu_reg_operand\" \"r\")\n-\t     (const_int 0)])\n-\t  (match_operand:SI 3 \"const_int_operand\" \"i\")\n-\t  (reg:INTR 131)))\n-   (clobber (match_operand:SI 0 \"spu_reg_operand\" \"=&r\"))\n-   (clobber (mem:BLK (scratch)))]\n+  [(cond_exec (match_operator 1 \"branch_comparison_operator\"\n+\t\t[(match_operand 2 \"spu_reg_operand\" \"r\")\n+\t\t (const_int 0)])\n+              (parallel [(unspec_volatile [(match_operand:SI 3 \"const_int_operand\" \"i\")] UNSPEC_SET_INTR)\n+                         (clobber (match_operand:SI 0 \"spu_reg_operand\" \"=&r\"))\n+\t\t\t (clobber (mem:BLK (scratch)))]))]\n   \"flag_pic\"\n-  \"brsl\\t%0,.+4\\;ai\\t%0,%0,8\\;%b2%b1z%I3\\t%2,%0\"\n+  \"brsl\\t%0,.+4\\;ai\\t%0,%0,8\\;bi%b2%b1z%I3\\t%2,%0\"\n   [(set_attr \"length\" \"12\")\n    (set_attr \"type\" \"multi1\")])\n \n (define_insn \"set_intr_return\"\n-  [(set (reg:INTR 131) (match_operand 0 \"const_int_operand\" \"i\"))\n+  [(unspec_volatile [(match_operand:SI 0 \"const_int_operand\" \"i\")] UNSPEC_SET_INTR)\n    (return)]\n   \"\"\n   \"bi%I0\\t$lr\"\n   [(set_attr \"type\" \"br\")])\n \n (define_peephole2\n   [(parallel\n-    [(set (reg:INTR 131) (match_operand 0 \"const_int_operand\"))\n+    [(unspec_volatile [(match_operand:SI 0 \"const_int_operand\")] UNSPEC_SET_INTR)\n      (clobber (match_operand:SI 1 \"spu_reg_operand\"))\n      (clobber (mem:BLK (scratch)))])\n    (use (reg:SI 0))\n    (return)]\n   \"\"\n   [(use (reg:SI 0))\n    (parallel\n-    [(set (reg:INTR 131) (match_dup 0))\n+    [(unspec_volatile [(match_dup:SI 0)] UNSPEC_SET_INTR)\n      (return)])]\n   \"\")\n "}, {"sha": "9d33fefb92d52d781a7ffd1f4e0b54d2766737ee", "filename": "gcc/config/spu/spu-modes.def", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73701e27366b20395ad5c3e296983b20ae0235b1/gcc%2Fconfig%2Fspu%2Fspu-modes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73701e27366b20395ad5c3e296983b20ae0235b1/gcc%2Fconfig%2Fspu%2Fspu-modes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu-modes.def?ref=73701e27366b20395ad5c3e296983b20ae0235b1", "patch": "@@ -25,10 +25,6 @@ VECTOR_MODES (INT, 16);       /* V16QI V8HI V4SI V2DI */\n VECTOR_MODES (FLOAT, 8);      /*            V4HF V2SF */ \n VECTOR_MODES (FLOAT, 16);     /*       V8HF V4SF V2DF */ \n         \n-/* A special mode for the intr register so we can treat it differently\n-   for conditional moves.  */\n-RANDOM_MODE (INTR);\n-\n /* cse_insn needs an INT_MODE larger than WORD_MODE, otherwise some\n    parts of it will go into an infinite loop. */\n INT_MODE (OI, 32);"}, {"sha": "4caaf1b8a6966e4fe145b82f6fc86052d7dd03f3", "filename": "gcc/config/spu/spu-protos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73701e27366b20395ad5c3e296983b20ae0235b1/gcc%2Fconfig%2Fspu%2Fspu-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73701e27366b20395ad5c3e296983b20ae0235b1/gcc%2Fconfig%2Fspu%2Fspu-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu-protos.h?ref=73701e27366b20395ad5c3e296983b20ae0235b1", "patch": "@@ -23,6 +23,7 @@\n extern enum machine_mode spu_eh_return_filter_mode (void);\n extern void spu_cpu_cpp_builtins (struct cpp_reader * pfile);\n extern void builtin_define_std (const char *);\n+extern void spu_optimization_options (int level, int size);\n extern void spu_override_options (void);\n extern void spu_c_common_override_options (void);\n extern int valid_subreg (rtx op);\n@@ -88,6 +89,7 @@ extern void spu_builtin_promote (rtx ops[]);\n extern void spu_initialize_trampoline (rtx tramp, rtx fnaddr, rtx cxt);\n extern void spu_expand_sign_extend (rtx ops[]);\n extern void spu_expand_vector_init (rtx target, rtx vals);\n+extern void spu_init_expanders (void);\n \n /* spu-c.c */\n extern tree spu_resolve_overloaded_builtin (tree fndecl, tree fnargs);"}, {"sha": "252183b8b788815c64410c20852c05581557da54", "filename": "gcc/config/spu/spu.c", "status": "modified", "additions": 205, "deletions": 63, "changes": 268, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73701e27366b20395ad5c3e296983b20ae0235b1/gcc%2Fconfig%2Fspu%2Fspu.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73701e27366b20395ad5c3e296983b20ae0235b1/gcc%2Fconfig%2Fspu%2Fspu.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu.c?ref=73701e27366b20395ad5c3e296983b20ae0235b1", "patch": "@@ -157,6 +157,7 @@ enum immediate_class\n   IC_IL2s,\t\t\t/* both ilhu and iohl instructions */\n   IC_FSMBI,\t\t\t/* the fsmbi instruction */\n   IC_CPAT,\t\t\t/* one of the c*d instructions */\n+  IC_FSMBI2\t\t\t/* fsmbi plus 1 other instruction */\n };\n \n static enum spu_immediate which_immediate_load (HOST_WIDE_INT val);\n@@ -262,20 +263,29 @@ const struct attribute_spec spu_attribute_table[];\n \n struct gcc_target targetm = TARGET_INITIALIZER;\n \n+void\n+spu_optimization_options (int level ATTRIBUTE_UNUSED, int size ATTRIBUTE_UNUSED)\n+{\n+  /* Small loops will be unpeeled at -O3.  For SPU it is more important\n+     to keep code small by default. */\n+  if (!flag_unroll_loops && !flag_peel_loops)\n+    PARAM_VALUE (PARAM_MAX_COMPLETELY_PEEL_TIMES) = 1;\n+\n+  /* Override some of the default param values.  With so many registers\n+     larger values are better for these params.  */\n+  MAX_PENDING_LIST_LENGTH = 128;\n+\n+  /* With so many registers this is better on by default. */\n+  flag_rename_registers = 1;\n+}\n+\n /* Sometimes certain combinations of command options do not make sense\n    on a particular target machine.  You can define a macro\n    OVERRIDE_OPTIONS to take account of this. This macro, if defined, is\n    executed once just after all the command options have been parsed.  */\n void\n spu_override_options (void)\n {\n-  /* Override some of the default param values.  With so many registers\n-     larger values are better for these params.  */\n-  if (MAX_UNROLLED_INSNS == 100)\n-    MAX_UNROLLED_INSNS = 250;\n-  if (MAX_PENDING_LIST_LENGTH == 32)\n-    MAX_PENDING_LIST_LENGTH = 128;\n-\n   flag_omit_frame_pointer = 1;\n \n   if (align_functions < 8)\n@@ -1142,6 +1152,7 @@ print_operand (FILE * file, rtx x, int code)\n \t\tfprintf (file, \"hu\");\n \t      break;\n \t    case IC_FSMBI:\n+\t    case IC_FSMBI2:\n \t    case IC_IL2:\n \t    case IC_IL2s:\n \t    case IC_POOL:\n@@ -1194,21 +1205,17 @@ print_operand (FILE * file, rtx x, int code)\n \t      fprintf (file, HOST_WIDE_INT_PRINT_DEC, (HOST_WIDE_INT)info);\n \t      break;\n \t    case IC_IL1s:\n-\t      if (xcode == CONST_VECTOR)\n-\t\t{\n-\t\t  x = CONST_VECTOR_ELT (x, 0);\n-\t\t  xcode = GET_CODE (x);\n-\t\t}\n \t      if (xcode == HIGH)\n-\t\t{\n-\t\t  output_addr_const (file, XEXP (x, 0));\n-\t\t  fprintf (file, \"@h\");\n-\t\t}\n-\t      else\n-\t\toutput_addr_const (file, x);\n+\t\tx = XEXP (x, 0);\n+\t      if (GET_CODE (x) == CONST_VECTOR)\n+\t\tx = CONST_VECTOR_ELT (x, 0);\n+\t      output_addr_const (file, x);\n+\t      if (xcode == HIGH)\n+\t\tfprintf (file, \"@h\");\n \t      break;\n \t    case IC_IL2:\n \t    case IC_IL2s:\n+\t    case IC_FSMBI2:\n \t    case IC_POOL:\n \t      abort ();\n \t    }\n@@ -1307,6 +1314,58 @@ print_operand (FILE * file, rtx x, int code)\n \t}\n       return;\n \n+    case 'e':\n+      val = xcode == CONST_INT ? INTVAL (x) : INTVAL (CONST_VECTOR_ELT (x, 0));\n+      val &= 0x7;\n+      output_addr_const (file, GEN_INT (val));\n+      return;\n+\n+    case 'f':\n+      val = xcode == CONST_INT ? INTVAL (x) : INTVAL (CONST_VECTOR_ELT (x, 0));\n+      val &= 0x1f;\n+      output_addr_const (file, GEN_INT (val));\n+      return;\n+\n+    case 'g':\n+      val = xcode == CONST_INT ? INTVAL (x) : INTVAL (CONST_VECTOR_ELT (x, 0));\n+      val &= 0x3f;\n+      output_addr_const (file, GEN_INT (val));\n+      return;\n+\n+    case 'h':\n+      val = xcode == CONST_INT ? INTVAL (x) : INTVAL (CONST_VECTOR_ELT (x, 0));\n+      val = (val >> 3) & 0x1f;\n+      output_addr_const (file, GEN_INT (val));\n+      return;\n+\n+    case 'E':\n+      val = xcode == CONST_INT ? INTVAL (x) : INTVAL (CONST_VECTOR_ELT (x, 0));\n+      val = -val;\n+      val &= 0x7;\n+      output_addr_const (file, GEN_INT (val));\n+      return;\n+\n+    case 'F':\n+      val = xcode == CONST_INT ? INTVAL (x) : INTVAL (CONST_VECTOR_ELT (x, 0));\n+      val = -val;\n+      val &= 0x1f;\n+      output_addr_const (file, GEN_INT (val));\n+      return;\n+\n+    case 'G':\n+      val = xcode == CONST_INT ? INTVAL (x) : INTVAL (CONST_VECTOR_ELT (x, 0));\n+      val = -val;\n+      val &= 0x3f;\n+      output_addr_const (file, GEN_INT (val));\n+      return;\n+\n+    case 'H':\n+      val = xcode == CONST_INT ? INTVAL (x) : INTVAL (CONST_VECTOR_ELT (x, 0));\n+      val = -(val & -8ll);\n+      val = (val >> 3) & 0x1f;\n+      output_addr_const (file, GEN_INT (val));\n+      return;\n+\n     case 0:\n       if (xcode == REG)\n \tfprintf (file, \"%s\", reg_names[REGNO (x)]);\n@@ -1318,6 +1377,9 @@ print_operand (FILE * file, rtx x, int code)\n \toutput_addr_const (file, x);\n       return;\n \n+      /* unsed letters\n+\t              o qr  uvw yz\n+\tAB            OPQR  UVWXYZ */\n     default:\n       output_operand_lossage (\"invalid %%xn code\");\n     }\n@@ -1341,8 +1403,9 @@ get_pic_reg (void)\n   return pic_reg;\n }\n \n-/* Split constant addresses to handle cases that are too large.  Also, add in\n-   the pic register when in PIC mode. */\n+/* Split constant addresses to handle cases that are too large. \n+   Add in the pic register when in PIC mode.\n+   Split immediates that require more than 1 instruction. */\n int\n spu_split_immediate (rtx * ops)\n {\n@@ -1373,6 +1436,36 @@ spu_split_immediate (rtx * ops)\n \t\t   (VOIDmode, ops[0], gen_rtx_IOR (mode, to, lo)));\n \treturn 1;\n       }\n+    case IC_FSMBI2:\n+      {\n+\tunsigned char arr_fsmbi[16];\n+\tunsigned char arr_andbi[16];\n+\trtx to, reg_fsmbi, reg_and;\n+\tint i;\n+\tenum machine_mode imode = mode;\n+\t/* We need to do reals as ints because the constant used in the\n+\t * AND might not be a legitimate real constant. */\n+\timode = int_mode_for_mode (mode);\n+\tconstant_to_array (mode, ops[1], arr_fsmbi);\n+\tif (imode != mode)\n+\t  to = simplify_gen_subreg(imode, ops[0], GET_MODE (ops[0]), 0);\n+\telse\n+\t  to = ops[0];\n+\tfor (i = 0; i < 16; i++)\n+\t  if (arr_fsmbi[i] != 0)\n+\t    {\n+\t      arr_andbi[0] = arr_fsmbi[i];\n+\t      arr_fsmbi[i] = 0xff;\n+\t    }\n+\tfor (i = 1; i < 16; i++)\n+\t  arr_andbi[i] = arr_andbi[0];\n+\treg_fsmbi = array_to_constant (imode, arr_fsmbi);\n+\treg_and = array_to_constant (imode, arr_andbi);\n+\temit_move_insn (to, reg_fsmbi);\n+\temit_insn (gen_rtx_SET\n+\t\t   (VOIDmode, to, gen_rtx_AND (imode, to, reg_and)));\n+\treturn 1;\n+      }\n     case IC_POOL:\n       if (reload_in_progress || reload_completed)\n \t{\n@@ -1393,8 +1486,8 @@ spu_split_immediate (rtx * ops)\n \t{\n \t  if (c == IC_IL2s)\n \t    {\n-\t      emit_insn (gen_high (ops[0], ops[1]));\n-\t      emit_insn (gen_low (ops[0], ops[0], ops[1]));\n+\t      emit_move_insn (ops[0], gen_rtx_HIGH (mode, ops[1]));\n+\t      emit_move_insn (ops[0], gen_rtx_LO_SUM (mode, ops[0], ops[1]));\n \t    }\n \t  else if (flag_pic)\n \t    emit_insn (gen_pic (ops[0], ops[1]));\n@@ -1667,6 +1760,7 @@ spu_expand_prologue (void)\n \t  REG_NOTES (insn) = \n \t    gen_rtx_EXPR_LIST (REG_FRAME_RELATED_EXPR,\n \t\t\t       real, REG_NOTES (insn));\n+          REGNO_POINTER_ALIGN (HARD_FRAME_POINTER_REGNUM) = STACK_BOUNDARY;\n \t}\n     }\n \n@@ -2329,7 +2423,8 @@ immediate_load_p (rtx op, enum machine_mode mode)\n   if (CONSTANT_P (op))\n     {\n       enum immediate_class c = classify_immediate (op, mode);\n-      return c == IC_IL1 || (!flow2_completed && c == IC_IL2);\n+      return c == IC_IL1 || c == IC_IL1s\n+\t     || (!flow2_completed && (c == IC_IL2 || c == IC_IL2s));\n     }\n   return 0;\n }\n@@ -2390,15 +2485,16 @@ classify_immediate (rtx op, enum machine_mode mode)\n {\n   HOST_WIDE_INT val;\n   unsigned char arr[16];\n-  int i, j, repeated, fsmbi;\n+  int i, j, repeated, fsmbi, repeat;\n \n   gcc_assert (CONSTANT_P (op));\n \n   if (GET_MODE (op) != VOIDmode)\n     mode = GET_MODE (op);\n \n   /* A V4SI const_vector with all identical symbols is ok. */\n-  if (mode == V4SImode\n+  if (!flag_pic\n+      && mode == V4SImode\n       && GET_CODE (op) == CONST_VECTOR\n       && GET_CODE (CONST_VECTOR_ELT (op, 0)) != CONST_INT\n       && GET_CODE (CONST_VECTOR_ELT (op, 0)) != CONST_DOUBLE\n@@ -2452,11 +2548,14 @@ classify_immediate (rtx op, enum machine_mode mode)\n       gcc_assert (GET_MODE_SIZE (mode) > 2);\n \n       fsmbi = 1;\n+      repeat = 0;\n       for (i = 0; i < 16 && fsmbi; i++)\n-\tif (arr[i] != 0 && arr[i] != 0xff)\n+\tif (arr[i] != 0 && repeat == 0)\n+\t  repeat = arr[i];\n+\telse if (arr[i] != 0 && arr[i] != repeat)\n \t  fsmbi = 0;\n       if (fsmbi)\n-\treturn IC_FSMBI;\n+\treturn repeat == 0xff ? IC_FSMBI : IC_FSMBI2;\n \n       if (cpat_info (arr, GET_MODE_SIZE (mode), 0, 0))\n \treturn IC_CPAT;\n@@ -2495,6 +2594,20 @@ which_logical_immediate (HOST_WIDE_INT val)\n   return SPU_NONE;\n }\n \n+/* Return TRUE when X, a CONST_VECTOR, only contains CONST_INTs or\n+   CONST_DOUBLEs. */\n+static int\n+const_vector_immediate_p (rtx x)\n+{\n+  int i;\n+  gcc_assert (GET_CODE (x) == CONST_VECTOR);\n+  for (i = 0; i < GET_MODE_NUNITS (GET_MODE (x)); i++)\n+    if (GET_CODE (CONST_VECTOR_ELT (x, i)) != CONST_INT\n+\t&& GET_CODE (CONST_VECTOR_ELT (x, i)) != CONST_DOUBLE)\n+      return 0;\n+  return 1;\n+}\n+\n int\n logical_immediate_p (rtx op, enum machine_mode mode)\n {\n@@ -2505,6 +2618,10 @@ logical_immediate_p (rtx op, enum machine_mode mode)\n   gcc_assert (GET_CODE (op) == CONST_INT || GET_CODE (op) == CONST_DOUBLE\n \t      || GET_CODE (op) == CONST_VECTOR);\n \n+  if (GET_CODE (op) == CONST_VECTOR\n+      && !const_vector_immediate_p (op))\n+    return 0;\n+\n   if (GET_MODE (op) != VOIDmode)\n     mode = GET_MODE (op);\n \n@@ -2533,6 +2650,10 @@ iohl_immediate_p (rtx op, enum machine_mode mode)\n   gcc_assert (GET_CODE (op) == CONST_INT || GET_CODE (op) == CONST_DOUBLE\n \t      || GET_CODE (op) == CONST_VECTOR);\n \n+  if (GET_CODE (op) == CONST_VECTOR\n+      && !const_vector_immediate_p (op))\n+    return 0;\n+\n   if (GET_MODE (op) != VOIDmode)\n     mode = GET_MODE (op);\n \n@@ -2561,6 +2682,10 @@ arith_immediate_p (rtx op, enum machine_mode mode,\n   gcc_assert (GET_CODE (op) == CONST_INT || GET_CODE (op) == CONST_DOUBLE\n \t      || GET_CODE (op) == CONST_VECTOR);\n \n+  if (GET_CODE (op) == CONST_VECTOR\n+      && !const_vector_immediate_p (op))\n+    return 0;\n+\n   if (GET_MODE (op) != VOIDmode)\n     mode = GET_MODE (op);\n \n@@ -2596,22 +2721,21 @@ arith_immediate_p (rtx op, enum machine_mode mode,\n int\n spu_legitimate_constant_p (rtx x)\n {\n-  int i;\n+  if (GET_CODE (x) == HIGH)\n+    x = XEXP (x, 0);\n   /* V4SI with all identical symbols is valid. */\n-  if (GET_MODE (x) == V4SImode\n+  if (!flag_pic\n+      && GET_MODE (x) == V4SImode\n       && (GET_CODE (CONST_VECTOR_ELT (x, 0)) == SYMBOL_REF\n \t  || GET_CODE (CONST_VECTOR_ELT (x, 0)) == LABEL_REF\n-\t  || GET_CODE (CONST_VECTOR_ELT (x, 0)) == CONST\n-\t  || GET_CODE (CONST_VECTOR_ELT (x, 0)) == HIGH))\n+\t  || GET_CODE (CONST_VECTOR_ELT (x, 0)) == CONST))\n     return CONST_VECTOR_ELT (x, 0) == CONST_VECTOR_ELT (x, 1)\n \t   && CONST_VECTOR_ELT (x, 1) == CONST_VECTOR_ELT (x, 2)\n \t   && CONST_VECTOR_ELT (x, 2) == CONST_VECTOR_ELT (x, 3);\n \n-  if (VECTOR_MODE_P (GET_MODE (x)))\n-    for (i = 0; i < GET_MODE_NUNITS (GET_MODE (x)); i++)\n-      if (GET_CODE (CONST_VECTOR_ELT (x, i)) != CONST_INT\n-\t  && GET_CODE (CONST_VECTOR_ELT (x, i)) != CONST_DOUBLE)\n-\treturn 0;\n+  if (GET_CODE (x) == CONST_VECTOR\n+      && !const_vector_immediate_p (x))\n+    return 0;\n   return 1;\n }\n \n@@ -2668,7 +2792,7 @@ spu_legitimate_address (enum machine_mode mode ATTRIBUTE_UNUSED,\n \t    && GET_CODE (op1) == CONST_INT\n \t    && INTVAL (op1) >= -0x2000\n \t    && INTVAL (op1) <= 0x1fff\n-\t    && (REGNO_PTR_FRAME_P (REGNO (op0)) || (INTVAL (op1) & 15) == 0))\n+\t    && (regno_aligned_for_load (REGNO (op0)) || (INTVAL (op1) & 15) == 0))\n \t  return 1;\n \tif (GET_CODE (op0) == REG\n \t    && INT_REG_OK_FOR_BASE_P (op0, reg_ok_strict)\n@@ -3135,7 +3259,6 @@ spu_conditional_register_usage (void)\n       fixed_regs[PIC_OFFSET_TABLE_REGNUM] = 1;\n       call_used_regs[PIC_OFFSET_TABLE_REGNUM] = 1;\n     }\n-  global_regs[INTR_REGNUM] = 1;\n }\n \n /* This is called to decide when we can simplify a load instruction.  We\n@@ -3149,9 +3272,10 @@ static int\n regno_aligned_for_load (int regno)\n {\n   return regno == FRAME_POINTER_REGNUM\n-    || regno == HARD_FRAME_POINTER_REGNUM\n+    || (frame_pointer_needed && regno == HARD_FRAME_POINTER_REGNUM)\n     || regno == STACK_POINTER_REGNUM\n-    || (regno >= FIRST_VIRTUAL_REGISTER && regno <= LAST_VIRTUAL_REGISTER);\n+    || (regno >= FIRST_VIRTUAL_REGISTER \n+\t&& regno <= LAST_VIRTUAL_REGISTER);\n }\n \n /* Return TRUE when mem is known to be 16-byte aligned. */\n@@ -3706,10 +3830,10 @@ fsmbi_const_p (rtx x)\n {\n   if (CONSTANT_P (x))\n     {\n-      /* We can always choose DImode for CONST_INT because the high bits\n+      /* We can always choose TImode for CONST_INT because the high bits\n          of an SImode will always be all 1s, i.e., valid for fsmbi. */\n-      enum immediate_class c = classify_immediate (x, DImode);\n-      return c == IC_FSMBI;\n+      enum immediate_class c = classify_immediate (x, TImode);\n+      return c == IC_FSMBI || (!flow2_completed && c == IC_FSMBI2);\n     }\n   return 0;\n }\n@@ -3929,7 +4053,7 @@ reloc_diagnostic (rtx x)\n   /* We use last_assemble_variable_decl to get line information.  It's\n      not always going to be right and might not even be close, but will\n      be right for the more common cases. */\n-  if (!last_assemble_variable_decl)\n+  if (!last_assemble_variable_decl || in_section == ctors_section)\n     loc_decl = decl;\n   else\n     loc_decl = last_assemble_variable_decl;\n@@ -4346,7 +4470,7 @@ spu_builtin_splats (rtx ops[])\n       constant_to_array (GET_MODE_INNER (mode), ops[1], arr);\n       emit_move_insn (ops[0], array_to_constant (mode, arr));\n     }\n-  else if (GET_MODE (ops[0]) == V4SImode && CONSTANT_P (ops[1]))\n+  else if (!flag_pic && GET_MODE (ops[0]) == V4SImode && CONSTANT_P (ops[1]))\n     {\n       rtvec v = rtvec_alloc (4);\n       RTVEC_ELT (v, 0) = ops[1];\n@@ -4773,10 +4897,8 @@ spu_check_builtin_parm (struct spu_builtin_description *d, rtx op, int p)\n   if (p >= SPU_BTI_7 && p <= SPU_BTI_U18)\n     {\n       int range = p - SPU_BTI_7;\n-      if (!CONSTANT_P (op)\n-\t  || (GET_CODE (op) == CONST_INT\n-\t      && (INTVAL (op) < spu_builtin_range[range].low\n-\t\t  || INTVAL (op) > spu_builtin_range[range].high)))\n+\n+      if (!CONSTANT_P (op))\n \terror (\"%s expects an integer literal in the range [%d, %d].\",\n \t       d->name,\n \t       spu_builtin_range[range].low, spu_builtin_range[range].high);\n@@ -4790,6 +4912,18 @@ spu_check_builtin_parm (struct spu_builtin_description *d, rtx op, int p)\n \t}\n       else if (GET_CODE (op) == CONST_INT)\n \tv = INTVAL (op);\n+      else if (GET_CODE (op) == CONST_VECTOR\n+\t       && GET_CODE (CONST_VECTOR_ELT (op, 0)) == CONST_INT)\n+\tv = INTVAL (CONST_VECTOR_ELT (op, 0));\n+\n+      /* The default for v is 0 which is valid in every range. */\n+      if (v < spu_builtin_range[range].low\n+\t  || v > spu_builtin_range[range].high)\n+\terror (\"%s expects an integer literal in the range [%d, %d]. (\"\n+\t       HOST_WIDE_INT_PRINT_DEC \")\",\n+\t       d->name,\n+\t       spu_builtin_range[range].low, spu_builtin_range[range].high,\n+\t       v);\n \n       switch (p)\n \t{\n@@ -4814,38 +4948,37 @@ spu_check_builtin_parm (struct spu_builtin_description *d, rtx op, int p)\n       if (GET_CODE (op) == LABEL_REF\n \t  || (GET_CODE (op) == SYMBOL_REF\n \t      && SYMBOL_REF_FUNCTION_P (op))\n-\t  || (INTVAL (op) & ((1 << lsbits) - 1)) != 0)\n+\t  || (v & ((1 << lsbits) - 1)) != 0)\n \twarning (0, \"%d least significant bits of %s are ignored.\", lsbits,\n \t\t d->name);\n     }\n }\n \n \n static void\n-expand_builtin_args (struct spu_builtin_description *d, tree arglist,\n+expand_builtin_args (struct spu_builtin_description *d, tree exp,\n \t\t     rtx target, rtx ops[])\n {\n   enum insn_code icode = d->icode;\n-  int i = 0;\n+  int i = 0, a;\n \n   /* Expand the arguments into rtl. */\n \n   if (d->parm[0] != SPU_BTI_VOID)\n     ops[i++] = target;\n \n-  for (; i < insn_data[icode].n_operands; i++)\n+  for (a = 0; i < insn_data[icode].n_operands; i++, a++)\n     {\n-      tree arg = TREE_VALUE (arglist);\n+      tree arg = CALL_EXPR_ARG (exp, a);\n       if (arg == 0)\n \tabort ();\n       ops[i] = expand_expr (arg, NULL_RTX, VOIDmode, 0);\n-      arglist = TREE_CHAIN (arglist);\n     }\n }\n \n static rtx\n spu_expand_builtin_1 (struct spu_builtin_description *d,\n-\t\t      tree arglist, rtx target)\n+\t\t      tree exp, rtx target)\n {\n   rtx pat;\n   rtx ops[8];\n@@ -4855,7 +4988,7 @@ spu_expand_builtin_1 (struct spu_builtin_description *d,\n   tree return_type;\n \n   /* Set up ops[] with values from arglist. */\n-  expand_builtin_args (d, arglist, target, ops);\n+  expand_builtin_args (d, exp, target, ops);\n \n   /* Handle the target operand which must be operand 0. */\n   i = 0;\n@@ -4889,7 +5022,7 @@ spu_expand_builtin_1 (struct spu_builtin_description *d,\n       rtx addr, op, pat;\n \n       /* get addr */\n-      arg = TREE_VALUE (arglist);\n+      arg = CALL_EXPR_ARG (exp, 0);\n       gcc_assert (TREE_CODE (TREE_TYPE (arg)) == POINTER_TYPE);\n       op = expand_expr (arg, NULL_RTX, Pmode, EXPAND_NORMAL);\n       addr = memory_address (mode, op);\n@@ -4947,10 +5080,10 @@ spu_expand_builtin_1 (struct spu_builtin_description *d,\n \t    }\n \t}\n \n+      spu_check_builtin_parm (d, ops[i], d->parm[p]);\n+\n       if (!(*insn_data[icode].operand[i].predicate) (ops[i], mode))\n \tops[i] = spu_force_reg (mode, ops[i]);\n-\n-      spu_check_builtin_parm (d, ops[i], d->parm[p]);\n     }\n \n   switch (insn_data[icode].n_operands)\n@@ -5012,16 +5145,15 @@ spu_expand_builtin (tree exp,\n \t\t    enum machine_mode mode ATTRIBUTE_UNUSED,\n \t\t    int ignore ATTRIBUTE_UNUSED)\n {\n-  tree fndecl = TREE_OPERAND (TREE_OPERAND (exp, 0), 0);\n+  tree fndecl = TREE_OPERAND (CALL_EXPR_FN (exp), 0);\n   unsigned int fcode = DECL_FUNCTION_CODE (fndecl) - END_BUILTINS;\n-  tree arglist = TREE_OPERAND (exp, 1);\n   struct spu_builtin_description *d;\n \n   if (fcode < NUM_SPU_BUILTINS)\n     {\n       d = &spu_builtins[fcode];\n \n-      return spu_expand_builtin_1 (d, arglist, target);\n+      return spu_expand_builtin_1 (d, exp, target);\n     }\n   abort ();\n }\n@@ -5068,3 +5200,13 @@ spu_builtin_mask_for_load (void)\n   gcc_assert (d);\n   return d->fndecl;\n }\n+\n+void\n+spu_init_expanders (void)\n+{   \n+  /* HARD_FRAME_REGISTER is only 128 bit aligned when\n+   * frame_pointer_needed is true.  We don't know that until we're\n+   * expanding the prologue. */\n+  if (cfun)\n+    REGNO_POINTER_ALIGN (HARD_FRAME_POINTER_REGNUM) = 8;\n+}       "}, {"sha": "1fcc2349facdf302756ad50cf498dd3320f8a7bd", "filename": "gcc/config/spu/spu.h", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73701e27366b20395ad5c3e296983b20ae0235b1/gcc%2Fconfig%2Fspu%2Fspu.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73701e27366b20395ad5c3e296983b20ae0235b1/gcc%2Fconfig%2Fspu%2Fspu.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu.h?ref=73701e27366b20395ad5c3e296983b20ae0235b1", "patch": "@@ -24,6 +24,11 @@\n #define OVERRIDE_OPTIONS spu_override_options()\n #define C_COMMON_OVERRIDE_OPTIONS spu_c_common_override_options()\n \n+#define OPTIMIZATION_OPTIONS(level,size) \\\n+\t  spu_optimization_options(level,size)\n+\n+#define INIT_EXPANDERS spu_init_expanders()\n+\n extern int target_flags;\n extern const char *spu_fixed_range_string;\n \n@@ -152,7 +157,7 @@ extern const char *spu_fixed_range_string;\n /* Register Basics */\n \n /* 128-130 are special registers that never appear in assembly code. */\n-#define FIRST_PSEUDO_REGISTER 132\n+#define FIRST_PSEUDO_REGISTER 131\n \n #define FIXED_REGISTERS {\t\t\t    \\\n     1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n@@ -163,7 +168,7 @@ extern const char *spu_fixed_range_string;\n     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n-    1, 1, 1, 1 \\\n+    1, 1, 1 \\\n }\n \n #define CALL_USED_REGISTERS {\t\t\t    \\\n@@ -175,7 +180,7 @@ extern const char *spu_fixed_range_string;\n     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n-    1, 1, 1, 1 \\\n+    1, 1, 1 \\\n }\n \n #define CONDITIONAL_REGISTER_USAGE \\\n@@ -299,9 +304,6 @@ targetm.resolve_overloaded_builtin = spu_resolve_overloaded_builtin;\t\\\n  * buffer.  Users can also specify it in inline asm. */\n #define HBR_REGNUM 130\n \n-/* Used to keep track of enabling and disabling interrupts. */\n-#define INTR_REGNUM 131\n-\n #define MAX_REGISTER_ARGS    72\n #define FIRST_ARG_REGNUM     3\n #define LAST_ARG_REGNUM      (FIRST_ARG_REGNUM + MAX_REGISTER_ARGS - 1)\n@@ -512,7 +514,7 @@ targetm.resolve_overloaded_builtin = spu_resolve_overloaded_builtin;\t\\\n  \"$80\", \"$81\", \"$82\", \"$83\", \"$84\", \"$85\", \"$86\", \"$87\", \"$88\", \"$89\", \"$90\", \"$91\", \"$92\", \"$93\", \"$94\", \"$95\", \\\n  \"$96\", \"$97\", \"$98\", \"$99\", \"$100\", \"$101\", \"$102\", \"$103\", \"$104\", \"$105\", \"$106\", \"$107\", \"$108\", \"$109\", \"$110\", \"$111\", \\\n  \"$112\", \"$113\", \"$114\", \"$115\", \"$116\", \"$117\", \"$118\", \"$119\", \"$120\", \"$121\", \"$122\", \"$123\", \"$124\", \"$125\", \"$126\", \"$127\", \\\n- \"$vfp\", \"$vap\", \"hbr\", \"intr\" \\\n+ \"$vfp\", \"$vap\", \"hbr\" \\\n }\n \n #define PRINT_OPERAND(FILE, X, CODE)  print_operand(FILE, X, CODE)"}, {"sha": "ccaf485e1668f8698c3b2e27689847ba4b1b6fe5", "filename": "gcc/config/spu/spu.md", "status": "modified", "additions": 59, "deletions": 50, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73701e27366b20395ad5c3e296983b20ae0235b1/gcc%2Fconfig%2Fspu%2Fspu.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73701e27366b20395ad5c3e296983b20ae0235b1/gcc%2Fconfig%2Fspu%2Fspu.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu.md?ref=73701e27366b20395ad5c3e296983b20ae0235b1", "patch": "@@ -134,8 +134,7 @@\n  (UNSPEC_CFLTU          37)\n  (UNSPEC_STOP           38)\n  (UNSPEC_STOPD          39)\n- (UNSPEC_IDISABLE       40)\n- (UNSPEC_IENABLE        41)\n+ (UNSPEC_SET_INTR       40)\n  (UNSPEC_FSCRRD         42)\n  (UNSPEC_FSCRWR         43)\n  (UNSPEC_MFSPR          44)\n@@ -204,6 +203,11 @@\n (define_mode_attr f2i [(SF \"SI\") (V4SF \"V4SI\")\n                        (DF \"DI\") (V2DF \"V2DI\")])\n \n+(define_mode_attr umask  [(HI \"f\")  (V8HI \"f\")\n+\t\t          (SI \"g\")  (V4SI \"g\")])\n+(define_mode_attr nmask  [(HI \"F\")  (V8HI \"F\")\n+\t\t          (SI \"G\")  (V4SI \"G\")])\n+\n ;; Used for carry and borrow instructions.\n (define_mode_macro CBOP  [SI DI V4SI V2DI])\n \n@@ -293,16 +297,10 @@\n    stq%p0\\t%1,%0\"\n   [(set_attr \"type\" \"fx2,fx2,shuf,shuf,load,store\")])\n \n-(define_insn \"high\"\n-  [(set (match_operand:SI 0 \"spu_reg_operand\" \"=r\")\n-\t(high:SI (match_operand:SI 1 \"immediate_operand\" \"i\")))]\n-  \"\"\n-  \"ilhu\\t%0,%1@h\")\n-\n-(define_insn \"low\"\n-  [(set (match_operand:SI 0 \"spu_reg_operand\" \"=r\")\n-\t(lo_sum:SI (match_operand:SI 1 \"spu_reg_operand\" \"0\")\n-\t\t   (match_operand:SI 2 \"immediate_operand\" \"i\")))]\n+(define_insn \"low_<mode>\"\n+  [(set (match_operand:VSI 0 \"spu_reg_operand\" \"=r\")\n+\t(lo_sum:VSI (match_operand:VSI 1 \"spu_reg_operand\" \"0\")\n+\t\t    (match_operand:VSI 2 \"immediate_operand\" \"i\")))]\n   \"\"\n   \"iohl\\t%0,%2@l\")\n \n@@ -1193,7 +1191,7 @@\n (define_insn \"mulhisi3_imm\"\n   [(set (match_operand:SI 0 \"spu_reg_operand\" \"=r\")\n \t(mult:SI (sign_extend:SI (match_operand:HI 1 \"spu_reg_operand\" \"r\"))\n-\t\t (match_operand:SI 2 \"immediate_operand\" \"K\")))]\n+\t\t (match_operand:SI 2 \"imm_K_operand\" \"K\")))]\n   \"\"\n   \"mpyi\\t%0,%1,%2\"\n   [(set_attr \"type\" \"fp7\")])\n@@ -1209,7 +1207,7 @@\n (define_insn \"umulhisi3_imm\"\n   [(set (match_operand:SI 0 \"spu_reg_operand\" \"=r\")\n \t(mult:SI (zero_extend:SI (match_operand:HI 1 \"spu_reg_operand\" \"r\"))\n-\t\t (and:SI (match_operand:SI 2 \"immediate_operand\" \"K\") (const_int 65535))))]\n+\t\t (and:SI (match_operand:SI 2 \"imm_K_operand\" \"K\") (const_int 65535))))]\n   \"\"\n   \"mpyui\\t%0,%1,%2\"\n   [(set_attr \"type\" \"fp7\")])\n@@ -1753,7 +1751,7 @@\n   \"\"\n   \"@\n   xor\\t%0,%1,%2\n-  xor%j2i\\t%0,%1,%S2\")\n+  xor%j2i\\t%0,%1,%J2\")\n \n (define_insn \"xordi3\"\n   [(set (match_operand:DI 0 \"spu_reg_operand\" \"=r,r\")\n@@ -1912,17 +1910,17 @@\n (define_insn \"ashl<mode>3\"\n   [(set (match_operand:VHSI 0 \"spu_reg_operand\" \"=r,r\")\n \t(ashift:VHSI (match_operand:VHSI 1 \"spu_reg_operand\" \"r,r\")\n-\t\t     (match_operand:VHSI 2 \"spu_shift_operand\" \"r,W\")))]\n+\t\t     (match_operand:VHSI 2 \"spu_nonmem_operand\" \"r,W\")))]\n   \"\"\n   \"@\n   shl<bh>\\t%0,%1,%2\n-  shl<bh>i\\t%0,%1,%2\"\n+  shl<bh>i\\t%0,%1,%<umask>2\"\n   [(set_attr \"type\" \"fx3\")])\n \n (define_insn_and_split \"ashldi3\"\n   [(set (match_operand:DI 0 \"spu_reg_operand\" \"=r,r\")\n \t(ashift:DI (match_operand:DI 1 \"spu_reg_operand\" \"r,r\")\n-\t           (match_operand:SI 2 \"spu_shift_operand\" \"r,I\")))\n+\t           (match_operand:SI 2 \"spu_nonmem_operand\" \"r,I\")))\n    (clobber (match_scratch:SI 3 \"=&r,X\"))]\n   \"\"\n   \"#\"\n@@ -1973,8 +1971,8 @@\n \t\t   (match_operand:SI 2 \"immediate_operand\" \"O,P\")))]\n   \"\"\n   \"@\n-   shlqbyi\\t%0,%1,%2/8\n-   shlqbii\\t%0,%1,%2\"\n+   shlqbyi\\t%0,%1,%h2\n+   shlqbii\\t%0,%1,%e2\"\n   \"!satisfies_constraint_O (operands[2]) && !satisfies_constraint_P (operands[2])\"\n   [(set (match_dup:TI 0)\n \t(ashift:TI (match_dup:TI 1)\n@@ -1985,7 +1983,7 @@\n   {\n     HOST_WIDE_INT val = INTVAL(operands[2]);\n     operands[3] = GEN_INT (val&7);\n-    operands[4] = GEN_INT (val&0x78);\n+    operands[4] = GEN_INT (val&-8);\n   }\n   [(set_attr \"type\" \"shuf,shuf\")])\n \n@@ -2015,7 +2013,7 @@\n   \"\"\n   \"@\n    shlqbybi\\t%0,%1,%2\n-   shlqbyi\\t%0,%1,%2/8\"\n+   shlqbyi\\t%0,%1,%h2\"\n   [(set_attr \"type\" \"shuf,shuf\")])\n \n (define_insn \"shlqbi_ti\"\n@@ -2026,7 +2024,7 @@\n   \"\"\n   \"@\n    shlqbi\\t%0,%1,%2\n-   shlqbii\\t%0,%1,%2\"\n+   shlqbii\\t%0,%1,%e2\"\n   [(set_attr \"type\" \"shuf,shuf\")])\n \n (define_insn \"shlqby_ti\"\n@@ -2037,7 +2035,7 @@\n   \"\"\n   \"@\n    shlqby\\t%0,%1,%2\n-   shlqbyi\\t%0,%1,%2\"\n+   shlqbyi\\t%0,%1,%f2\"\n   [(set_attr \"type\" \"shuf,shuf\")])\n \n \f\n@@ -2046,12 +2044,12 @@\n (define_insn_and_split \"lshr<mode>3\"\n   [(set (match_operand:VHSI 0 \"spu_reg_operand\" \"=r,r\")\n \t(lshiftrt:VHSI (match_operand:VHSI 1 \"spu_reg_operand\" \"r,r\")\n-\t\t       (match_operand:VHSI 2 \"spu_shift_operand\" \"r,W\")))\n+\t\t       (match_operand:VHSI 2 \"spu_nonmem_operand\" \"r,W\")))\n    (clobber (match_scratch:VHSI 3 \"=&r,X\"))]\n   \"\"\n   \"@\n    #\n-   rot<bh>mi\\t%0,%1,%N2\"\n+   rot<bh>mi\\t%0,%1,-%<umask>2\"\n   \"reload_completed && GET_CODE (operands[2]) == REG\"\n   [(set (match_dup:VHSI 3)\n \t(neg:VHSI (match_dup:VHSI 2)))\n@@ -2065,11 +2063,11 @@\n (define_insn \"rotm_<mode>\"\n   [(set (match_operand:VHSI 0 \"spu_reg_operand\" \"=r,r\")\n \t(lshiftrt:VHSI (match_operand:VHSI 1 \"spu_reg_operand\" \"r,r\")\n-\t\t       (neg:VHSI (match_operand:VHSI 2 \"spu_shift_operand\" \"r,W\"))))]\n+\t\t       (neg:VHSI (match_operand:VHSI 2 \"spu_nonmem_operand\" \"r,W\"))))]\n   \"\"\n   \"@\n    rot<bh>m\\t%0,%1,%2\n-   rot<bh>mi\\t%0,%1,%2\"\n+   rot<bh>mi\\t%0,%1,-%<nmask>2\"\n   [(set_attr \"type\" \"fx3\")])\n  \n (define_expand \"lshr<mode>3\"\n@@ -2095,8 +2093,8 @@\n \t\t      (match_operand:SI 2 \"immediate_operand\" \"O,P\")))]\n   \"\"\n   \"@\n-   rotqmbyi\\t%0,%1,%N2/8\n-   rotqmbii\\t%0,%1,%N2\"\n+   rotqmbyi\\t%0,%1,-%h2\n+   rotqmbii\\t%0,%1,-%e2\"\n   \"!satisfies_constraint_O (operands[2]) && !satisfies_constraint_P (operands[2])\"\n   [(set (match_dup:DTI 0)\n \t(lshiftrt:DTI (match_dup:DTI 1)\n@@ -2107,7 +2105,7 @@\n   {\n     HOST_WIDE_INT val = INTVAL(operands[2]);\n     operands[4] = GEN_INT (val&7);\n-    operands[5] = GEN_INT (val&0x78);\n+    operands[5] = GEN_INT (val&-8);\n   }\n   [(set_attr \"type\" \"shuf,shuf\")])\n \n@@ -2127,7 +2125,8 @@\n \t\t\t     (const_int 7))))\n    (set (match_dup:DTI 0)\n \t(lshiftrt:DTI (match_dup:DTI 3)\n-\t\t     (and:SI (neg:SI (match_dup:SI 5))\n+\t\t     (and:SI (neg:SI (and:SI (match_dup:SI 5)\n+\t\t\t\t\t     (const_int -8)))\n \t\t\t     (const_int -8))))]\n   {\n     emit_insn(gen_subsi3(operands[4], GEN_INT(0), operands[2]));\n@@ -2137,12 +2136,13 @@\n (define_insn \"rotqmbybi_<mode>\"\n   [(set (match_operand:DTI 0 \"spu_reg_operand\" \"=r,r\")\n \t(lshiftrt:DTI (match_operand:DTI 1 \"spu_reg_operand\" \"r,r\")\n-\t\t      (and:SI (neg:SI (match_operand:SI 2 \"spu_nonmem_operand\" \"r,I\"))\n+\t\t      (and:SI (neg:SI (and:SI (match_operand:SI 2 \"spu_nonmem_operand\" \"r,I\")\n+\t\t\t\t\t      (const_int -8)))\n \t\t\t      (const_int -8))))]\n   \"\"\n   \"@\n    rotqmbybi\\t%0,%1,%2\n-   rotqmbyi\\t%0,%1,%2/8\"\n+   rotqmbyi\\t%0,%1,-%H2\"\n   [(set_attr \"type\" \"shuf\")])\n \n (define_insn \"rotqmbi_<mode>\"\n@@ -2153,7 +2153,7 @@\n   \"\"\n   \"@\n    rotqmbi\\t%0,%1,%2\n-   rotqmbii\\t%0,%1,%2\"\n+   rotqmbii\\t%0,%1,-%E2\"\n   [(set_attr \"type\" \"shuf\")])\n \n (define_insn \"rotqmby_<mode>\"\n@@ -2164,7 +2164,7 @@\n   \"\"\n   \"@\n    rotqmby\\t%0,%1,%2\n-   rotqmbyi\\t%0,%1,%2\"\n+   rotqmbyi\\t%0,%1,-%F2\"\n   [(set_attr \"type\" \"shuf\")])\n \n \f\n@@ -2173,12 +2173,12 @@\n (define_insn_and_split \"ashr<mode>3\"\n   [(set (match_operand:VHSI 0 \"spu_reg_operand\" \"=r,r\")\n \t(ashiftrt:VHSI (match_operand:VHSI 1 \"spu_reg_operand\" \"r,r\")\n-\t\t       (match_operand:VHSI 2 \"spu_shift_operand\" \"r,W\")))\n+\t\t       (match_operand:VHSI 2 \"spu_nonmem_operand\" \"r,W\")))\n    (clobber (match_scratch:VHSI 3 \"=&r,X\"))]\n   \"\"\n   \"@\n    #\n-   rotma<bh>i\\t%0,%1,%N2\"\n+   rotma<bh>i\\t%0,%1,-%<umask>2\"\n   \"reload_completed && GET_CODE (operands[2]) == REG\"\n   [(set (match_dup:VHSI 3)\n \t(neg:VHSI (match_dup:VHSI 2)))\n@@ -2192,11 +2192,11 @@\n (define_insn \"rotma_<mode>\"\n   [(set (match_operand:VHSI 0 \"spu_reg_operand\" \"=r,r\")\n \t(ashiftrt:VHSI (match_operand:VHSI 1 \"spu_reg_operand\" \"r,r\")\n-\t\t       (neg:VHSI (match_operand:VHSI 2 \"spu_shift_operand\" \"r,W\"))))]\n+\t\t       (neg:VHSI (match_operand:VHSI 2 \"spu_nonmem_operand\" \"r,W\"))))]\n   \"\"\n   \"@\n    rotma<bh>\\t%0,%1,%2\n-   rotma<bh>i\\t%0,%1,%2\"\n+   rotma<bh>i\\t%0,%1,-%<nmask>2\"\n   [(set_attr \"type\" \"fx3\")])\n  \n (define_insn_and_split \"ashrdi3\"\n@@ -2306,11 +2306,11 @@\n (define_insn \"rotl<mode>3\"\n   [(set (match_operand:VHSI 0 \"spu_reg_operand\" \"=r,r\")\n \t(rotate:VHSI (match_operand:VHSI 1 \"spu_reg_operand\" \"r,r\")\n-\t\t     (match_operand:VHSI 2 \"spu_shift_operand\" \"r,W\")))]\n+\t\t     (match_operand:VHSI 2 \"spu_nonmem_operand\" \"r,W\")))]\n   \"\"\n   \"@\n   rot<bh>\\t%0,%1,%2\n-  rot<bh>i\\t%0,%1,%2\"\n+  rot<bh>i\\t%0,%1,%<umask>2\"\n   [(set_attr \"type\" \"fx3\")])\n \n (define_insn \"rotlti3\"\n@@ -2320,9 +2320,9 @@\n   \"\"\n   \"@\n   rotqbybi\\t%0,%1,%2\\;rotqbi\\t%0,%0,%2\n-  rotqbyi\\t%0,%1,%2/8\n-  rotqbii\\t%0,%1,%2\n-  rotqbyi\\t%0,%1,%2/8\\;rotqbii\\t%0,%0,%2%%8\"\n+  rotqbyi\\t%0,%1,%h2\n+  rotqbii\\t%0,%1,%e2\n+  rotqbyi\\t%0,%1,%h2\\;rotqbii\\t%0,%0,%e2\"\n   [(set_attr \"length\" \"8,4,4,8\")\n    (set_attr \"type\" \"multi1,shuf,shuf,multi1\")])\n \n@@ -2334,7 +2334,7 @@\n   \"\"\n   \"@\n   rotqbybi\\t%0,%1,%2\n-  rotqbyi\\t%0,%1,%2/8\"\n+  rotqbyi\\t%0,%1,%h2\"\n   [(set_attr \"type\" \"shuf,shuf\")])\n \n (define_insn \"rotqby_ti\"\n@@ -2345,7 +2345,7 @@\n   \"\"\n   \"@\n   rotqby\\t%0,%1,%2\n-  rotqbyi\\t%0,%1,%2\"\n+  rotqbyi\\t%0,%1,%f2\"\n   [(set_attr \"type\" \"shuf,shuf\")])\n \n (define_insn \"rotqbi_ti\"\n@@ -2356,7 +2356,7 @@\n   \"\"\n   \"@\n   rotqbi\\t%0,%1,%2\n-  rotqbii\\t%0,%1,%2%%8\"\n+  rotqbii\\t%0,%1,%e2\"\n   [(set_attr \"type\" \"shuf,shuf\")])\n \n \f\n@@ -3090,7 +3090,8 @@ selb\\t%0,%4,%0,%3\"\n   [(unspec_volatile [(const_int 0)] UNSPEC_BLOCKAGE)]\n   \"\"\n   \"\"\n-  [(set_attr \"length\" \"0\")])\n+  [(set_attr \"type\" \"convert\")\n+   (set_attr \"length\" \"0\")])\n \n (define_expand \"epilogue\"\n   [(const_int 2)]\n@@ -3234,6 +3235,14 @@ selb\\t%0,%4,%0,%3\"\n   \"rotqbyi\\t%0,%1,(%2*<vmult>+<voff>)%%16\"\n   [(set_attr \"type\" \"shuf\")])\n \n+(define_insn \"_vec_extractv8hi_ze\"\n+  [(set (match_operand:SI 0 \"spu_reg_operand\" \"=r\")\n+\t(zero_extend:SI (vec_select:HI (match_operand:V8HI 1 \"spu_reg_operand\" \"r\")\n+\t\t\t\t       (parallel [(const_int 0)]))))]\n+  \"\"\n+  \"rotqmbyi\\t%0,%1,-2\"\n+  [(set_attr \"type\" \"shuf\")])\n+\n \f\n ;; misc\n \n@@ -3285,7 +3294,7 @@ selb\\t%0,%4,%0,%3\"\n \n (define_insn \"hbr\"\n   [(set (reg:SI 130)\n-\t(unspec:SI [(match_operand:SI 0 \"immediate_operand\" \"s,s,s\")\n+\t(unspec:SI [(match_operand:SI 0 \"immediate_operand\" \"i,i,i\")\n \t\t    (match_operand:SI 1 \"nonmemory_operand\" \"r,s,i\")] UNSPEC_HBR))\n    (unspec [(const_int 0)] UNSPEC_HBR)]\n   \"\""}, {"sha": "ecc8dc552ae5c94074dbf9e932bc7e6df5f1d790", "filename": "gcc/config/spu/spu_internals.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73701e27366b20395ad5c3e296983b20ae0235b1/gcc%2Fconfig%2Fspu%2Fspu_internals.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73701e27366b20395ad5c3e296983b20ae0235b1/gcc%2Fconfig%2Fspu%2Fspu_internals.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu_internals.h?ref=73701e27366b20395ad5c3e296983b20ae0235b1", "patch": "@@ -189,6 +189,9 @@\n #define si_clgthi(ra,imm)    __builtin_si_clgthi(ra,imm)\n #define si_clgt(ra,rb)       __builtin_si_clgt(ra,rb)\n #define si_clgti(ra,imm)     __builtin_si_clgti(ra,imm)\n+#define si_bisled(ra)        __builtin_si_bisled(ra,0)\n+#define si_bisledd(ra)       __builtin_si_bisledd(ra,0)\n+#define si_bislede(ra)       __builtin_si_bislede(ra,0)\n #define si_fa(ra,rb)         __builtin_si_fa(ra,rb)\n #define si_dfa(ra,rb)        __builtin_si_dfa(ra,rb)\n #define si_fs(ra,rb)         __builtin_si_fs(ra,rb)"}]}