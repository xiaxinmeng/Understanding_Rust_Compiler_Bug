{"sha": "17c5cbdf0fe98348a5bdef7bd6d4857270318091", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTdjNWNiZGYwZmU5ODM0OGE1YmRlZjdiZDZkNDg1NzI3MDMxODA5MQ==", "commit": {"author": {"name": "Bin Cheng", "email": "bin.cheng@arm.com", "date": "2017-07-05T12:01:03Z"}, "committer": {"name": "Bin Cheng", "email": "amker@gcc.gnu.org", "date": "2017-07-05T12:01:03Z"}, "message": "tree-loop-distribution.c (struct ddr_hasher): New.\n\n\t* tree-loop-distribution.c (struct ddr_hasher): New.\n\t(ddr_hasher::hash, ::equal, get_data_dependence): New function.\n\t(ddrs_table): New.\n\t(classify_partition): Call get_data_dependence.\n\t(pg_add_dependence_edges): Ditto.\n\t(distribute_loop): Release data dependence hash table.\n\nFrom-SVN: r249991", "tree": {"sha": "0f91ca4ef9dd0e45eb97a3836facf72dba412e00", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0f91ca4ef9dd0e45eb97a3836facf72dba412e00"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/17c5cbdf0fe98348a5bdef7bd6d4857270318091", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/17c5cbdf0fe98348a5bdef7bd6d4857270318091", "html_url": "https://github.com/Rust-GCC/gccrs/commit/17c5cbdf0fe98348a5bdef7bd6d4857270318091", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/17c5cbdf0fe98348a5bdef7bd6d4857270318091/comments", "author": null, "committer": null, "parents": [{"sha": "95f7d11b0ac6d7f4d82ba4045c6d8a747a23db60", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/95f7d11b0ac6d7f4d82ba4045c6d8a747a23db60", "html_url": "https://github.com/Rust-GCC/gccrs/commit/95f7d11b0ac6d7f4d82ba4045c6d8a747a23db60"}], "stats": {"total": 108, "additions": 82, "deletions": 26}, "files": [{"sha": "0b6d86ee2244f4e17ea7e59e7061ccaffe7649c9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17c5cbdf0fe98348a5bdef7bd6d4857270318091/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17c5cbdf0fe98348a5bdef7bd6d4857270318091/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=17c5cbdf0fe98348a5bdef7bd6d4857270318091", "patch": "@@ -1,3 +1,12 @@\n+2017-07-05  Bin Cheng  <bin.cheng@arm.com>\n+\n+\t* tree-loop-distribution.c (struct ddr_hasher): New.\n+\t(ddr_hasher::hash, ::equal, get_data_dependence): New function.\n+\t(ddrs_table): New.\n+\t(classify_partition): Call get_data_dependence.\n+\t(pg_add_dependence_edges): Ditto.\n+\t(distribute_loop): Release data dependence hash table.\n+\n 2017-07-05  Bin Cheng  <bin.cheng@arm.com>\n \n \t* tree-loop-distribution.c (ref_base_address): Delete."}, {"sha": "516d5f7ad11cbbd1396a57d18669906985d6c1d2", "filename": "gcc/tree-loop-distribution.c", "status": "modified", "additions": 73, "deletions": 26, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17c5cbdf0fe98348a5bdef7bd6d4857270318091/gcc%2Ftree-loop-distribution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17c5cbdf0fe98348a5bdef7bd6d4857270318091/gcc%2Ftree-loop-distribution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-loop-distribution.c?ref=17c5cbdf0fe98348a5bdef7bd6d4857270318091", "patch": "@@ -70,6 +70,35 @@ along with GCC; see the file COPYING3.  If not see\n #define MAX_DATAREFS_NUM \\\n \t((unsigned) PARAM_VALUE (PARAM_LOOP_MAX_DATAREFS_FOR_DATADEPS))\n \n+/* Hashtable helpers.  */\n+\n+struct ddr_hasher : nofree_ptr_hash <struct data_dependence_relation>\n+{\n+  static inline hashval_t hash (const data_dependence_relation *);\n+  static inline bool equal (const data_dependence_relation *,\n+\t\t\t    const data_dependence_relation *);\n+};\n+\n+/* Hash function for data dependence.  */\n+\n+inline hashval_t\n+ddr_hasher::hash (const data_dependence_relation *ddr)\n+{\n+  inchash::hash h;\n+  h.add_ptr (DDR_A (ddr));\n+  h.add_ptr (DDR_B (ddr));\n+  return h.end ();\n+}\n+\n+/* Hash table equality function for data dependence.  */\n+\n+inline bool\n+ddr_hasher::equal (const data_dependence_relation *ddr1,\n+\t\t   const data_dependence_relation *ddr2)\n+{\n+  return (DDR_A (ddr1) == DDR_A (ddr2) && DDR_B (ddr1) == DDR_B (ddr2));\n+}\n+\n /* The loop (nest) to be distributed.  */\n static vec<loop_p> loop_nest;\n \n@@ -79,6 +108,10 @@ static vec<data_reference_p> datarefs_vec;\n /* Store index of data reference in aux field.  */\n #define DR_INDEX(dr)      ((uintptr_t) (dr)->aux)\n \n+/* Hash table for data dependence relation in the loop to be distributed.  */\n+static hash_table<ddr_hasher> ddrs_table (389);\n+\n+\n /* A Reduced Dependence Graph (RDG) vertex representing a statement.  */\n struct rdg_vertex\n {\n@@ -1057,6 +1090,32 @@ generate_code_for_partition (struct loop *loop,\n   return false;\n }\n \n+/* Return data dependence relation for data references A and B.  The two\n+   data references must be in lexicographic order wrto reduced dependence\n+   graph RDG.  We firstly try to find ddr from global ddr hash table.  If\n+   it doesn't exist, compute the ddr and cache it.  */\n+\n+static data_dependence_relation *\n+get_data_dependence (struct graph *rdg, data_reference_p a, data_reference_p b)\n+{\n+  struct data_dependence_relation ent, **slot;\n+  struct data_dependence_relation *ddr;\n+\n+  gcc_assert (DR_IS_WRITE (a) || DR_IS_WRITE (b));\n+  gcc_assert (rdg_vertex_for_stmt (rdg, DR_STMT (a))\n+\t      <= rdg_vertex_for_stmt (rdg, DR_STMT (b)));\n+  ent.a = a;\n+  ent.b = b;\n+  slot = ddrs_table.find_slot (&ent, INSERT);\n+  if (*slot == NULL)\n+    {\n+      ddr = initialize_data_dependence_relation (a, b, loop_nest);\n+      compute_affine_dependence (ddr, loop_nest[0]);\n+      *slot = ddr;\n+    }\n+\n+  return *slot;\n+}\n \n /* Returns a partition with all the statements needed for computing\n    the vertex V of the RDG, also including the loop exit conditions.  */\n@@ -1223,44 +1282,27 @@ classify_partition (loop_p loop, struct graph *rdg, partition *partition)\n \treturn;\n       /* Now check that if there is a dependence this dependence is\n          of a suitable form for memmove.  */\n-      vec<loop_p> loops = vNULL;\n-      ddr_p ddr;\n-      loops.safe_push (loop);\n-      ddr = initialize_data_dependence_relation (single_load, single_store,\n-\t\t\t\t\t\t loops);\n-      compute_affine_dependence (ddr, loop);\n+      ddr_p ddr = get_data_dependence (rdg, single_load, single_store);\n       if (DDR_ARE_DEPENDENT (ddr) == chrec_dont_know)\n-\t{\n-\t  free_dependence_relation (ddr);\n-\t  loops.release ();\n-\t  return;\n-\t}\n+\treturn;\n+\n       if (DDR_ARE_DEPENDENT (ddr) != chrec_known)\n \t{\n \t  if (DDR_NUM_DIST_VECTS (ddr) == 0)\n-\t    {\n-\t      free_dependence_relation (ddr);\n-\t      loops.release ();\n-\t      return;\n-\t    }\n+\t    return;\n+\n \t  lambda_vector dist_v;\n \t  FOR_EACH_VEC_ELT (DDR_DIST_VECTS (ddr), i, dist_v)\n \t    {\n \t      int dist = dist_v[index_in_loop_nest (loop->num,\n \t\t\t\t\t\t    DDR_LOOP_NEST (ddr))];\n \t      if (dist > 0 && !DDR_REVERSED_P (ddr))\n-\t\t{\n-\t\t  free_dependence_relation (ddr);\n-\t\t  loops.release ();\n-\t\t  return;\n-\t\t}\n+\t\treturn;\n \t    }\n \t  partition->kind = PKIND_MEMMOVE;\n \t}\n       else\n \tpartition->kind = PKIND_MEMCPY;\n-      free_dependence_relation (ddr);\n-      loops.release ();\n       partition->main_dr = single_store;\n       partition->secondary_dr = single_load;\n       partition->niter = nb_iter;\n@@ -1472,8 +1514,7 @@ pg_add_dependence_edges (struct graph *rdg, int dir,\n \t      std::swap (dr1, dr2);\n \t      this_dir = -this_dir;\n \t    }\n-\t  ddr = initialize_data_dependence_relation (dr1, dr2, loop_nest);\n-\t  compute_affine_dependence (ddr, loop_nest[0]);\n+\t  ddr = get_data_dependence (rdg, dr1, dr2);\n \t  if (DDR_ARE_DEPENDENT (ddr) == chrec_dont_know)\n \t    this_dir = 2;\n \t  else if (DDR_ARE_DEPENDENT (ddr) == NULL_TREE)\n@@ -1499,7 +1540,6 @@ pg_add_dependence_edges (struct graph *rdg, int dir,\n \t    }\n \t  else\n \t    this_dir = 0;\n-\t  free_dependence_relation (ddr);\n \t  if (this_dir == 2)\n \t    return 2;\n \t  else if (dir == 0)\n@@ -1762,6 +1802,13 @@ distribute_loop (struct loop *loop, vec<gimple *> stmts,\n  ldist_done:\n   loop_nest.release ();\n   free_data_refs (datarefs_vec);\n+  for (hash_table<ddr_hasher>::iterator iter = ddrs_table.begin ();\n+       iter != ddrs_table.end (); ++iter)\n+    {\n+      free_dependence_relation (*iter);\n+      *iter = NULL;\n+    }\n+  ddrs_table.empty ();\n \n   FOR_EACH_VEC_ELT (partitions, i, partition)\n     partition_free (partition);"}]}