{"sha": "385e0e0837c50581978a97fd16fdc2465462197d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mzg1ZTBlMDgzN2M1MDU4MTk3OGE5N2ZkMTZmZGMyNDY1NDYyMTk3ZA==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2005-05-30T18:02:08Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2005-05-30T18:02:08Z"}, "message": "re PR rtl-optimization/15422 (fmod loop exposes non-efficient code generation in reg-stack.c)\n\n\n\tPR rtl-optimization/15422\n\t* reg-stack.c (starting_stack_p): New static global.\n\t(straighten_stack): Delete prototype. Change to update the stack\n\tbefore the current insn.\n\t(subst_stack_regs): Update call to straighten stack.\n\t(emit_swap_insn): Delete prototype.  For the first insn in a\n\tbasic block, update stack_in instead of emitting a real swap.\n\t(change_stack): When changing the stack before the first insn\n\tin a basic block, update stack_in instead of emitting real code.\n\t(compensate_edges): Clear starting_stack_p during compensation.\n\t(convert_regs_1): Keep track of starting_stack_p whilst processing\n\ta basic block.\n\nFrom-SVN: r100370", "tree": {"sha": "4a8e9e9d59588ac48464063dc8028433429b91f7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4a8e9e9d59588ac48464063dc8028433429b91f7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/385e0e0837c50581978a97fd16fdc2465462197d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/385e0e0837c50581978a97fd16fdc2465462197d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/385e0e0837c50581978a97fd16fdc2465462197d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/385e0e0837c50581978a97fd16fdc2465462197d/comments", "author": null, "committer": null, "parents": [{"sha": "c13971f3893b89a3e0d23a406a57909535329e10", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c13971f3893b89a3e0d23a406a57909535329e10", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c13971f3893b89a3e0d23a406a57909535329e10"}], "stats": {"total": 60, "additions": 52, "deletions": 8}, "files": [{"sha": "370ea010def70c1772d1803730f212858c87294d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/385e0e0837c50581978a97fd16fdc2465462197d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/385e0e0837c50581978a97fd16fdc2465462197d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=385e0e0837c50581978a97fd16fdc2465462197d", "patch": "@@ -1,3 +1,18 @@\n+2005-05-30  Roger Sayle  <roger@eyesopen.com>\n+\n+\tPR rtl-optimization/15422\n+\t* reg-stack.c (starting_stack_p): New static global.\n+\t(straighten_stack): Delete prototype. Change to update the stack\n+\tbefore the current insn.\n+\t(subst_stack_regs): Update call to straighten stack.\n+\t(emit_swap_insn): Delete prototype.  For the first insn in a\n+\tbasic block, update stack_in instead of emitting a real swap.\n+\t(change_stack): When changing the stack before the first insn\n+\tin a basic block, update stack_in instead of emitting real code.\n+\t(compensate_edges): Clear starting_stack_p during compensation.\n+\t(convert_regs_1): Keep track of starting_stack_p whilst processing\n+\ta basic block.\n+\n 2005-05-30  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* tree-ssa-ccp.c (const_val): Make it static."}, {"sha": "5e5fcc74744bfdf7b9e9a591b4857175e424a773", "filename": "gcc/reg-stack.c", "status": "modified", "additions": 37, "deletions": 8, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/385e0e0837c50581978a97fd16fdc2465462197d/gcc%2Freg-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/385e0e0837c50581978a97fd16fdc2465462197d/gcc%2Freg-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.c?ref=385e0e0837c50581978a97fd16fdc2465462197d", "patch": "@@ -224,6 +224,11 @@ enum emit_where\n /* The block we're currently working on.  */\n static basic_block current_block;\n \n+/* In the current_block, whether we're processing the first register\n+   stack or call instruction, i.e. the the regstack is currently the\n+   same as BLOCK_INFO(current_block)->stack_in.  */\n+static bool starting_stack_p;\n+\n /* This is the register file for all register after conversion.  */\n static rtx\n   FP_mode_reg[LAST_STACK_REG+1-FIRST_STACK_REG][(int) MAX_MACHINE_MODE];\n@@ -237,7 +242,6 @@ static rtx not_a_num;\n /* Forward declarations */\n \n static int stack_regs_mentioned_p (rtx pat);\n-static void straighten_stack (rtx, stack);\n static void pop_stack (stack, int);\n static rtx *get_true_reg (rtx *);\n \n@@ -248,7 +252,6 @@ static void replace_reg (rtx *, int);\n static void remove_regno_note (rtx, enum reg_note, unsigned int);\n static int get_hard_regnum (stack, rtx);\n static rtx emit_pop_insn (rtx, stack, rtx, enum emit_where);\n-static void emit_swap_insn (rtx, stack, rtx);\n static void swap_to_top(rtx, stack, rtx, rtx);\n static bool move_for_stack_reg (rtx, stack, rtx);\n static bool move_nan_for_stack_reg (rtx, stack, rtx);\n@@ -344,8 +347,7 @@ next_flags_user (rtx insn)\n   return NULL_RTX;\n }\n \f\n-/* Reorganize the stack into ascending numbers,\n-   after this insn.  */\n+/* Reorganize the stack into ascending numbers, before this insn.  */\n \n static void\n straighten_stack (rtx insn, stack regstack)\n@@ -365,7 +367,7 @@ straighten_stack (rtx insn, stack regstack)\n   for (top = temp_stack.top = regstack->top; top >= 0; top--)\n     temp_stack.reg[top] = FIRST_STACK_REG + temp_stack.top - top;\n \n-  change_stack (insn, regstack, &temp_stack, EMIT_AFTER);\n+  change_stack (insn, regstack, &temp_stack, EMIT_BEFORE);\n }\n \n /* Pop a register from the stack.  */\n@@ -864,6 +866,16 @@ emit_swap_insn (rtx insn, stack regstack, rtx reg)\n \treturn;\n     }\n \n+  /* Avoid emitting the swap if this is the first register stack insn\n+     of the current_block.  Instead update the current_block's stack_in\n+     and let compensate edges take care of this for us.  */\n+  if (current_block && starting_stack_p)\n+    {\n+      BLOCK_INFO (current_block)->stack_in = *regstack;\n+      starting_stack_p = false;\n+      return;\n+    }\n+\n   swap_rtx = gen_swapxf (FP_MODE_REG (hard_regno, XFmode),\n \t\t\t FP_MODE_REG (FIRST_STACK_REG, XFmode));\n \n@@ -2205,7 +2217,7 @@ subst_stack_regs (rtx insn, stack regstack)\n \n       if (top >= 0)\n \t{\n-\t  straighten_stack (PREV_INSN (insn), regstack);\n+\t  straighten_stack (insn, regstack);\n \n \t  /* Now mark the arguments as dead after the call.  */\n \n@@ -2296,6 +2308,19 @@ change_stack (rtx insn, stack old, stack new, enum emit_where where)\n   int reg;\n   int update_end = 0;\n \n+  /* Stack adjustments for the first insn in a block update the\n+     current_block's stack_in instead of inserting insns directly.\n+     compensate_edges will add the necessary code later.  */\n+  if (current_block\n+      && starting_stack_p\n+      && where == EMIT_BEFORE)\n+    {\n+      BLOCK_INFO (current_block)->stack_in = *new;\n+      starting_stack_p = false;\n+      *old = *new;\n+      return;\n+    }\n+\n   /* We will be inserting new insns \"backwards\".  If we are to insert\n      after INSN, find the next insn, and insert before it.  */\n \n@@ -2720,6 +2745,8 @@ compensate_edges (FILE *file)\n   bool inserted = false;\n   basic_block bb;\n \n+  starting_stack_p = false;\n+\n   FOR_EACH_BB (bb)\n     if (bb != ENTRY_BLOCK_PTR)\n       {\n@@ -2800,8 +2827,6 @@ convert_regs_1 (FILE *file, basic_block block)\n \t}\n     }\n \n-  current_block = block;\n-\n   if (file)\n     {\n       fprintf (file, \"\\nBasic block %d\\nInput stack: \", block->index);\n@@ -2810,8 +2835,11 @@ convert_regs_1 (FILE *file, basic_block block)\n \n   /* Process all insns in this block.  Keep track of NEXT so that we\n      don't process insns emitted while substituting in INSN.  */\n+  current_block = block;\n   next = BB_HEAD (block);\n   regstack = bi->stack_in;\n+  starting_stack_p = true;\n+\n   do\n     {\n       insn = next;\n@@ -2834,6 +2862,7 @@ convert_regs_1 (FILE *file, basic_block block)\n \t      print_stack (file, &regstack);\n \t    }\n \t  control_flow_insn_deleted |= subst_stack_regs (insn, &regstack);\n+\t  starting_stack_p = false;\n \t}\n     }\n   while (next);"}]}