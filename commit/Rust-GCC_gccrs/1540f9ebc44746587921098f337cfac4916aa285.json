{"sha": "1540f9ebc44746587921098f337cfac4916aa285", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTU0MGY5ZWJjNDQ3NDY1ODc5MjEwOThmMzM3Y2ZhYzQ5MTZhYTI4NQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2002-03-30T13:26:19Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2002-03-30T13:26:19Z"}, "message": "local-alloc.c (local_alloc): Avoid call of update_equiv_regs when not optimizing.\n\n\t* local-alloc.c (local_alloc): Avoid call of update_equiv_regs when not optimizing.\n\n\t* toplev.c (rest_of_compilation): Cann mark_constant_function\n\tonly when optimizing.\n\n\t* flow.c (calculate_global_regs_live): Ensure that all AUX fields are NULL.\n\n\t* cfgcleanup.c (bb_flags): Add BB_NONTHREADABLE_BLOCK.\n\t(thread_jump): Set BB_NONTHREADABLE_BLOCK, check it.\n\t(try_optimize_cfg): clear all AUX fields.\n\n\t* i386.c (aligned_operand): Be prepared for SUBREGed registers.\n\t(ix86_decompose_address): Use REG_P instead of GET_CODE (...) == REG.\n\t(ix86_address_cost): Be prepared for SUBREGed registers.\n\t(legitimate_address_p): Accept SUBREGed registers.\n\nFrom-SVN: r51604", "tree": {"sha": "12369072c4ba8d9aa884e9c5cd3c573fb0e9abc2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/12369072c4ba8d9aa884e9c5cd3c573fb0e9abc2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1540f9ebc44746587921098f337cfac4916aa285", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1540f9ebc44746587921098f337cfac4916aa285", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1540f9ebc44746587921098f337cfac4916aa285", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1540f9ebc44746587921098f337cfac4916aa285/comments", "author": null, "committer": null, "parents": [{"sha": "d83975041fbb3eb13524c5f8af1743e5e11c8f9e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d83975041fbb3eb13524c5f8af1743e5e11c8f9e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d83975041fbb3eb13524c5f8af1743e5e11c8f9e"}], "stats": {"total": 103, "additions": 86, "deletions": 17}, "files": [{"sha": "a320e7a90fe73a16e917943dcc7709b59cf7e767", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1540f9ebc44746587921098f337cfac4916aa285/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1540f9ebc44746587921098f337cfac4916aa285/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1540f9ebc44746587921098f337cfac4916aa285", "patch": "@@ -1,3 +1,21 @@\n+Sat Mar 30 14:08:55 CET 2002  Jan Hubicka  <jh@suse.cz>\n+\n+\t* local-alloc.c (local_alloc): Avoid call of update_equiv_regs when not optimizing.\n+\n+\t* toplev.c (rest_of_compilation): Cann mark_constant_function\n+\tonly when optimizing.\n+\n+\t* flow.c (calculate_global_regs_live): Ensure that all AUX fields are NULL.\n+\n+\t* cfgcleanup.c (bb_flags): Add BB_NONTHREADABLE_BLOCK.\n+\t(thread_jump): Set BB_NONTHREADABLE_BLOCK, check it.\n+\t(try_optimize_cfg): clear all AUX fields.\n+\n+\t* i386.c (aligned_operand): Be prepared for SUBREGed registers.\n+\t(ix86_decompose_address): Use REG_P instead of GET_CODE (...) == REG.\n+\t(ix86_address_cost): Be prepared for SUBREGed registers.\n+\t(legitimate_address_p): Accept SUBREGed registers.\n+\n 2002-03-29  Richard Henderson  <rth@redhat.com>\n \n \tPR target/5672"}, {"sha": "b6a7f0cc4eabc0c758b6840e7ad35c31f8026be1", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 25, "deletions": 8, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1540f9ebc44746587921098f337cfac4916aa285/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1540f9ebc44746587921098f337cfac4916aa285/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=1540f9ebc44746587921098f337cfac4916aa285", "patch": "@@ -54,7 +54,8 @@ enum bb_flags\n {\n     /* Set if BB is the forwarder block to avoid too many\n        forwarder_block_p calls.  */\n-    BB_FORWARDER_BLOCK = 1\n+    BB_FORWARDER_BLOCK = 1,\n+    BB_NONTHREADABLE_BLOCK = 2\n };\n \n #define BB_FLAGS(BB) (enum bb_flags) (BB)->aux\n@@ -279,17 +280,28 @@ thread_jump (mode, e, b)\n   regset nonequal;\n   bool failed = false;\n \n+  if (BB_FLAGS (b) & BB_NONTHREADABLE_BLOCK)\n+    return NULL;\n+\n   /* At the moment, we do handle only conditional jumps, but later we may\n      want to extend this code to tablejumps and others.  */\n   if (!e->src->succ->succ_next || e->src->succ->succ_next->succ_next)\n     return NULL;\n   if (!b->succ || !b->succ->succ_next || b->succ->succ_next->succ_next)\n-    return NULL;\n+    {\n+      BB_SET_FLAG (b, BB_NONTHREADABLE_BLOCK);\n+      return NULL;\n+    }\n \n   /* Second branch must end with onlyjump, as we will eliminate the jump.  */\n-  if (!any_condjump_p (e->src->end) || !any_condjump_p (b->end)\n-      || !onlyjump_p (b->end))\n+  if (!any_condjump_p (e->src->end))\n     return NULL;\n+  \n+  if (!any_condjump_p (b->end) || !onlyjump_p (b->end))\n+    {\n+      BB_SET_FLAG (b, BB_NONTHREADABLE_BLOCK);\n+      return NULL;\n+    }\n \n   set1 = pc_set (e->src->end);\n   set2 = pc_set (b->end);\n@@ -324,7 +336,10 @@ thread_jump (mode, e, b)\n   for (insn = NEXT_INSN (b->head); insn != NEXT_INSN (b->end);\n        insn = NEXT_INSN (insn))\n     if (INSN_P (insn) && side_effects_p (PATTERN (insn)))\n-      return NULL;\n+      {\n+\tBB_SET_FLAG (b, BB_NONTHREADABLE_BLOCK);\n+\treturn NULL;\n+      }\n \n   cselib_init ();\n \n@@ -363,7 +378,10 @@ thread_jump (mode, e, b)\n   /* Later we should clear nonequal of dead registers.  So far we don't\n      have life information in cfg_cleanup.  */\n   if (failed)\n-    goto failed_exit;\n+    {\n+      BB_SET_FLAG (b, BB_NONTHREADABLE_BLOCK);\n+      goto failed_exit;\n+    }\n \n   /* cond2 must not mention any register that is not equal to the\n      former block.  */\n@@ -1723,8 +1741,7 @@ try_optimize_cfg (mode)\n   if (mode & CLEANUP_CROSSJUMP)\n     remove_fake_edges ();\n \n-  for (i = 0; i < n_basic_blocks; i++)\n-    BASIC_BLOCK (i)->aux = NULL;\n+  clear_aux_for_blocks ();\n \n   return changed_overall;\n }"}, {"sha": "f36495eeae5906e2a544d57446c4eedbe49da3b0", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 29, "deletions": 7, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1540f9ebc44746587921098f337cfac4916aa285/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1540f9ebc44746587921098f337cfac4916aa285/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=1540f9ebc44746587921098f337cfac4916aa285", "patch": "@@ -3467,6 +3467,11 @@ aligned_operand (op, mode)\n   if (! ix86_decompose_address (op, &parts))\n     abort ();\n \n+  if (parts.base && GET_CODE (parts.base) == SUBREG)\n+    parts.base = SUBREG_REG (parts.base);\n+  if (parts.index && GET_CODE (parts.index) == SUBREG)\n+    parts.index = SUBREG_REG (parts.index);\n+\n   /* Look for some component that isn't known to be aligned.  */\n   if (parts.index)\n     {\n@@ -4404,7 +4409,7 @@ ix86_decompose_address (addr, out)\n   rtx scale_rtx = NULL_RTX;\n   int retval = 1;\n \n-  if (GET_CODE (addr) == REG || GET_CODE (addr) == SUBREG)\n+  if (REG_P (addr) || GET_CODE (addr) == SUBREG)\n     base = addr;\n   else if (GET_CODE (addr) == PLUS)\n     {\n@@ -4531,6 +4536,11 @@ ix86_address_cost (x)\n   if (!ix86_decompose_address (x, &parts))\n     abort ();\n \n+  if (parts.base && GET_CODE (parts.base) == SUBREG)\n+    parts.base = SUBREG_REG (parts.base);\n+  if (parts.index && GET_CODE (parts.index) == SUBREG)\n+    parts.index = SUBREG_REG (parts.index);\n+\n   /* More complex memory references are better.  */\n   if (parts.disp && parts.disp != const0_rtx)\n     cost--;\n@@ -4745,9 +4755,15 @@ legitimate_address_p (mode, addr, strict)\n \n   if (base)\n     {\n+      rtx reg;\n       reason_rtx = base;\n \n-      if (GET_CODE (base) != REG)\n+      if (GET_CODE (base) == SUBREG)\n+\treg = SUBREG_REG (base);\n+      else\n+\treg = base;\n+\n+      if (GET_CODE (reg) != REG)\n \t{\n \t  reason = \"base is not a register\";\n \t  goto report_error;\n@@ -4759,8 +4775,8 @@ legitimate_address_p (mode, addr, strict)\n \t  goto report_error;\n \t}\n \n-      if ((strict && ! REG_OK_FOR_BASE_STRICT_P (base))\n-\t  || (! strict && ! REG_OK_FOR_BASE_NONSTRICT_P (base)))\n+      if ((strict && ! REG_OK_FOR_BASE_STRICT_P (reg))\n+\t  || (! strict && ! REG_OK_FOR_BASE_NONSTRICT_P (reg)))\n \t{\n \t  reason = \"base is not valid\";\n \t  goto report_error;\n@@ -4775,9 +4791,15 @@ legitimate_address_p (mode, addr, strict)\n \n   if (index)\n     {\n+      rtx reg;\n       reason_rtx = index;\n \n-      if (GET_CODE (index) != REG)\n+      if (GET_CODE (index) == SUBREG)\n+\treg = SUBREG_REG (index);\n+      else\n+\treg = index;\n+\n+      if (GET_CODE (reg) != REG)\n \t{\n \t  reason = \"index is not a register\";\n \t  goto report_error;\n@@ -4789,8 +4811,8 @@ legitimate_address_p (mode, addr, strict)\n \t  goto report_error;\n \t}\n \n-      if ((strict && ! REG_OK_FOR_INDEX_STRICT_P (index))\n-\t  || (! strict && ! REG_OK_FOR_INDEX_NONSTRICT_P (index)))\n+      if ((strict && ! REG_OK_FOR_INDEX_STRICT_P (reg))\n+\t  || (! strict && ! REG_OK_FOR_INDEX_NONSTRICT_P (reg)))\n \t{\n \t  reason = \"index is not valid\";\n \t  goto report_error;"}, {"sha": "332d5434f682ac9132b913d8b67b80bf5cda65e3", "filename": "gcc/flow.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1540f9ebc44746587921098f337cfac4916aa285/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1540f9ebc44746587921098f337cfac4916aa285/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=1540f9ebc44746587921098f337cfac4916aa285", "patch": "@@ -1071,6 +1071,16 @@ calculate_global_regs_live (blocks_in, blocks_out, flags)\n   regset_head new_live_at_end_head;\n   int i;\n \n+  /* Some passes used to forget clear aux field of basic block causing\n+     sick behaviour here.  */\n+#ifdef ENABLE_CHECKING\n+  if (ENTRY_BLOCK_PTR->aux || EXIT_BLOCK_PTR->aux)\n+    abort ();\n+  for (i = 0; i < n_basic_blocks; i++)\n+    if (BASIC_BLOCK (i)->aux)\n+      abort ();\n+#endif\n+\n   tmp = INITIALIZE_REG_SET (tmp_head);\n   new_live_at_end = INITIALIZE_REG_SET (new_live_at_end_head);\n   call_used = INITIALIZE_REG_SET (call_used_head);"}, {"sha": "4da7eac849ad283b74ec4f9eb30e32573aedaf47", "filename": "gcc/local-alloc.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1540f9ebc44746587921098f337cfac4916aa285/gcc%2Flocal-alloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1540f9ebc44746587921098f337cfac4916aa285/gcc%2Flocal-alloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flocal-alloc.c?ref=1540f9ebc44746587921098f337cfac4916aa285", "patch": "@@ -352,7 +352,8 @@ local_alloc ()\n \n   /* Promote REG_EQUAL notes to REG_EQUIV notes and adjust status of affected\n      registers.  */\n-  update_equiv_regs ();\n+  if (optimize)\n+    update_equiv_regs ();\n \n   /* This sets the maximum number of quantities we can have.  Quantity\n      numbers start at zero and we can have one for each pseudo.  */"}, {"sha": "1baf772452bddc0178ee7a3b184a73fff77b941b", "filename": "gcc/toplev.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1540f9ebc44746587921098f337cfac4916aa285/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1540f9ebc44746587921098f337cfac4916aa285/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=1540f9ebc44746587921098f337cfac4916aa285", "patch": "@@ -2856,7 +2856,8 @@ rest_of_compilation (decl)\n \n      life_analyzis rarely eliminates modification of external memory.\n    */\n-  mark_constant_function ();\n+  if (optimize)\n+    mark_constant_function ();\n \n   close_dump_file (DFI_cfg, print_rtl_with_bb, insns);\n "}]}