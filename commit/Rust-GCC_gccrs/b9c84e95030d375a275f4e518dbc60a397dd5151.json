{"sha": "b9c84e95030d375a275f4e518dbc60a397dd5151", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjljODRlOTUwMzBkMzc1YTI3NWY0ZTUxOGRiYzYwYTM5N2RkNTE1MQ==", "commit": {"author": {"name": "Fran\u00e7ois Dumont", "email": "fdumont@gcc.gnu.org", "date": "2020-01-09T05:40:08Z"}, "committer": {"name": "Fran\u00e7ois Dumont", "email": "fdumont@gcc.gnu.org", "date": "2020-01-09T05:40:08Z"}, "message": "PR libstdc++/92124 fix incorrect unordered container move assignment\n\n\t* include/bits/hashtable.h (_Hashtable<>::__alloc_node_gen_t): New\n\ttemplate alias.\n\t(_Hashtable<>::__fwd_value_for): New.\n\t(_Hashtable<>::_M_assign_elements<>): Remove _NodeGenerator template\n\tparameter.\n\t(_Hashtable<>::_M_assign<>): Add _Ht template parameter.\n\t(_Hashtable<>::operator=(const _Hashtable<>&)): Adapt.\n\t(_Hashtable<>::_M_move_assign): Adapt. Replace std::move_if_noexcept\n\twith std::move.\n\t(_Hashtable<>::_Hashtable(const _Hashtable&)): Adapt.\n\t(_Hashtable<>::_Hashtable(const _Hashtable&, const allocator_type&)):\n\tAdapt.\n\t(_Hashtable<>::_Hashtable(_Hashtable&&, const allocator_type&)):\n\tAdapt.\n\t* testsuite/23_containers/unordered_set/92124.cc: New.\n\nFrom-SVN: r280028", "tree": {"sha": "5cb9344bf433dbc115142125b2b2822b996fe39e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5cb9344bf433dbc115142125b2b2822b996fe39e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b9c84e95030d375a275f4e518dbc60a397dd5151", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9c84e95030d375a275f4e518dbc60a397dd5151", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b9c84e95030d375a275f4e518dbc60a397dd5151", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9c84e95030d375a275f4e518dbc60a397dd5151/comments", "author": null, "committer": null, "parents": [{"sha": "e4d2203e31e7c017266e61dbf0d24ee85e59fa55", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4d2203e31e7c017266e61dbf0d24ee85e59fa55", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e4d2203e31e7c017266e61dbf0d24ee85e59fa55"}], "stats": {"total": 171, "additions": 135, "deletions": 36}, "files": [{"sha": "0cbdc07375d7d42caff33aef8bb5130e70e2e036", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9c84e95030d375a275f4e518dbc60a397dd5151/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9c84e95030d375a275f4e518dbc60a397dd5151/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=b9c84e95030d375a275f4e518dbc60a397dd5151", "patch": "@@ -1,3 +1,22 @@\n+2020-01-09  Fran\u00e7ois Dumont  <fdumont@gcc.gnu.org>\n+\n+\tPR libstdc++/92124\n+\t* include/bits/hashtable.h (_Hashtable<>::__alloc_node_gen_t): New\n+\ttemplate alias.\n+\t(_Hashtable<>::__fwd_value_for): New.\n+\t(_Hashtable<>::_M_assign_elements<>): Remove _NodeGenerator template\n+\tparameter.\n+\t(_Hashtable<>::_M_assign<>): Add _Ht template parameter.\n+\t(_Hashtable<>::operator=(const _Hashtable<>&)): Adapt.\n+\t(_Hashtable<>::_M_move_assign): Adapt. Replace std::move_if_noexcept\n+\twith std::move.\n+\t(_Hashtable<>::_Hashtable(const _Hashtable&)): Adapt.\n+\t(_Hashtable<>::_Hashtable(const _Hashtable&, const allocator_type&)):\n+\tAdapt.\n+\t(_Hashtable<>::_Hashtable(_Hashtable&&, const allocator_type&)):\n+\tAdapt.\n+\t* testsuite/23_containers/unordered_set/92124.cc: New.\n+\n 2020-01-08  Jonathan Wakely  <jwakely@redhat.com>\n \n \tPR libstdc++/93201"}, {"sha": "8fac385570b125724187e2fee58d1bf073bb8be6", "filename": "libstdc++-v3/include/bits/hashtable.h", "status": "modified", "additions": 37, "deletions": 36, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9c84e95030d375a275f4e518dbc60a397dd5151/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9c84e95030d375a275f4e518dbc60a397dd5151/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h?ref=b9c84e95030d375a275f4e518dbc60a397dd5151", "patch": "@@ -255,6 +255,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n       using __reuse_or_alloc_node_gen_t =\n \t__detail::_ReuseOrAllocNode<__node_alloc_type>;\n+      using __alloc_node_gen_t =\n+\t__detail::_AllocNode<__node_alloc_type>;\n \n       // Simple RAII type for managing a node containing an element\n       struct _Scoped_node\n@@ -280,6 +282,13 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t__node_type* _M_node;\n       };\n \n+      template<typename _Ht>\n+\tstatic constexpr\n+\ttypename conditional<std::is_lvalue_reference<_Ht>::value,\n+\t\t\t     const value_type&, value_type&&>::type\n+\t__fwd_value_for(value_type& __val) noexcept\n+\t{ return std::move(__val); }\n+\n       // Metaprogramming for picking apart hash caching.\n       template<typename _Cond>\n \tusing __if_hash_cached = __or_<__not_<__hash_cached>, _Cond>;\n@@ -404,15 +413,15 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       _M_begin() const\n       { return static_cast<__node_type*>(_M_before_begin._M_nxt); }\n \n-      // Assign *this using another _Hashtable instance. Either elements\n-      // are copy or move depends on the _NodeGenerator.\n-      template<typename _Ht, typename _NodeGenerator>\n+      // Assign *this using another _Hashtable instance. Whether elements\n+      // are copied or moved depends on the _Ht reference.\n+      template<typename _Ht>\n \tvoid\n-\t_M_assign_elements(_Ht&&, const _NodeGenerator&);\n+\t_M_assign_elements(_Ht&&);\n \n-      template<typename _NodeGenerator>\n+      template<typename _Ht, typename _NodeGenerator>\n \tvoid\n-\t_M_assign(const _Hashtable&, const _NodeGenerator&);\n+\t_M_assign(_Ht&&, const _NodeGenerator&);\n \n       void\n       _M_move_assign(_Hashtable&&, true_type);\n@@ -1051,11 +1060,10 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t      _M_bucket_count = __ht._M_bucket_count;\n \t      _M_element_count = __ht._M_element_count;\n \t      _M_rehash_policy = __ht._M_rehash_policy;\n+\t      __alloc_node_gen_t __alloc_node_gen(*this);\n \t      __try\n \t\t{\n-\t\t  _M_assign(__ht,\n-\t\t\t    [this](const __node_type* __n)\n-\t\t\t    { return this->_M_allocate_node(__n->_M_v()); });\n+\t\t  _M_assign(__ht, __alloc_node_gen);\n \t\t}\n \t      __catch(...)\n \t\t{\n@@ -1070,21 +1078,19 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t}\n \n       // Reuse allocated buckets and nodes.\n-      _M_assign_elements(__ht,\n-\t[](const __reuse_or_alloc_node_gen_t& __roan, const __node_type* __n)\n-\t{ return __roan(__n->_M_v()); });\n+      _M_assign_elements(__ht);\n       return *this;\n     }\n \n   template<typename _Key, typename _Value,\n \t   typename _Alloc, typename _ExtractKey, typename _Equal,\n \t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n \t   typename _Traits>\n-    template<typename _Ht, typename _NodeGenerator>\n+    template<typename _Ht>\n       void\n       _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n \t\t _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n-      _M_assign_elements(_Ht&& __ht, const _NodeGenerator& __node_gen)\n+      _M_assign_elements(_Ht&& __ht)\n       {\n \t__bucket_type* __former_buckets = nullptr;\n \tstd::size_t __former_bucket_count = _M_bucket_count;\n@@ -1107,9 +1113,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t    _M_rehash_policy = __ht._M_rehash_policy;\n \t    __reuse_or_alloc_node_gen_t __roan(_M_begin(), *this);\n \t    _M_before_begin._M_nxt = nullptr;\n-\t    _M_assign(__ht,\n-\t\t      [&__node_gen, &__roan](__node_type* __n)\n-\t\t      { return __node_gen(__roan, __n); });\n+\t    _M_assign(std::forward<_Ht>(__ht), __roan);\n \t    if (__former_buckets)\n \t      _M_deallocate_buckets(__former_buckets, __former_bucket_count);\n \t  }\n@@ -1133,11 +1137,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t   typename _Alloc, typename _ExtractKey, typename _Equal,\n \t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n \t   typename _Traits>\n-    template<typename _NodeGenerator>\n+    template<typename _Ht, typename _NodeGenerator>\n       void\n       _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n \t\t _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n-      _M_assign(const _Hashtable& __ht, const _NodeGenerator& __node_gen)\n+      _M_assign(_Ht&& __ht, const _NodeGenerator& __node_gen)\n       {\n \t__bucket_type* __buckets = nullptr;\n \tif (!_M_buckets)\n@@ -1151,7 +1155,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t    // First deal with the special first node pointed to by\n \t    // _M_before_begin.\n \t    __node_type* __ht_n = __ht._M_begin();\n-\t    __node_type* __this_n = __node_gen(__ht_n);\n+\t    __node_type* __this_n\n+\t      = __node_gen(__fwd_value_for<_Ht>(__ht_n->_M_v()));\n \t    this->_M_copy_code(__this_n, __ht_n);\n \t    _M_before_begin._M_nxt = __this_n;\n \t    _M_buckets[_M_bucket_index(__this_n)] = &_M_before_begin;\n@@ -1160,7 +1165,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t    __node_base* __prev_n = __this_n;\n \t    for (__ht_n = __ht_n->_M_next(); __ht_n; __ht_n = __ht_n->_M_next())\n \t      {\n-\t\t__this_n = __node_gen(__ht_n);\n+\t\t__this_n = __node_gen(__fwd_value_for<_Ht>(__ht_n->_M_v()));\n \t\t__prev_n->_M_nxt = __this_n;\n \t\tthis->_M_copy_code(__this_n, __ht_n);\n \t\tsize_type __bkt = _M_bucket_index(__this_n);\n@@ -1241,9 +1246,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       else\n \t{\n \t  // Can't move memory, move elements then.\n-\t  _M_assign_elements(std::move(__ht),\n-\t\t[](const __reuse_or_alloc_node_gen_t& __roan, __node_type* __n)\n-\t\t{ return __roan(std::move_if_noexcept(__n->_M_v())); });\n+\t  _M_assign_elements(std::move(__ht));\n \t  __ht.clear();\n \t}\n     }\n@@ -1265,9 +1268,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       _M_element_count(__ht._M_element_count),\n       _M_rehash_policy(__ht._M_rehash_policy)\n     {\n-      _M_assign(__ht,\n-\t\t[this](const __node_type* __n)\n-\t\t{ return this->_M_allocate_node(__n->_M_v()); });\n+      __alloc_node_gen_t __alloc_node_gen(*this);\n+      _M_assign(__ht, __alloc_node_gen);\n     }\n \n   template<typename _Key, typename _Value,\n@@ -1318,9 +1320,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       _M_element_count(__ht._M_element_count),\n       _M_rehash_policy(__ht._M_rehash_policy)\n     {\n-      _M_assign(__ht,\n-\t\t[this](const __node_type* __n)\n-\t\t{ return this->_M_allocate_node(__n->_M_v()); });\n+      __alloc_node_gen_t __alloc_node_gen(*this);\n+      _M_assign(__ht, __alloc_node_gen);\n     }\n \n   template<typename _Key, typename _Value,\n@@ -1358,12 +1359,12 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t}\n       else\n \t{\n-\t  _M_assign(__ht,\n-\t\t    [this](__node_type* __n)\n-\t\t    {\n-\t\t      return this->_M_allocate_node(\n-\t\t\t\t\tstd::move_if_noexcept(__n->_M_v()));\n-\t\t    });\n+\t  __alloc_node_gen_t __alloc_gen(*this);\n+\n+\t  using _Fwd_Ht = typename\n+\t    conditional<__move_if_noexcept_cond<value_type>::value,\n+\t\t\tconst _Hashtable&, _Hashtable&&>::type;\n+\t  _M_assign(forward<_Fwd_Ht>(__ht), __alloc_gen);\n \t  __ht.clear();\n \t}\n     }"}, {"sha": "6dd1ef8701e64939e68cf1cc9675a168544e2fda", "filename": "libstdc++-v3/testsuite/23_containers/unordered_set/92124.cc", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9c84e95030d375a275f4e518dbc60a397dd5151/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2F92124.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9c84e95030d375a275f4e518dbc60a397dd5151/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2F92124.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2F92124.cc?ref=b9c84e95030d375a275f4e518dbc60a397dd5151", "patch": "@@ -0,0 +1,79 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-do run { target c++11 } }\n+\n+#include <unordered_set>\n+\n+#include <testsuite_allocator.h>\n+#include <testsuite_hooks.h>\n+\n+int moves = 0;\n+\n+struct X\n+{\n+  X() = default;\n+  X(const X&) = default;\n+  X(int i) : _i(i) {}\n+\n+  // Move constructor might throw\n+  X(X&& x) noexcept(false)\n+  {\n+    this->_i = x._i;\n+    x._i = -1;\n+    ++moves;\n+  }\n+\n+  int _i;\n+};\n+\n+struct XHasher\n+{\n+  std::size_t\n+  operator()(const X& x) const noexcept\n+  { return x._i; }\n+};\n+\n+struct XEqualTo\n+{\n+  bool\n+  operator()(const X& lhs, const X& rhs) const noexcept\n+  { return lhs._i == rhs._i; }\n+};\n+\n+void\n+test01()\n+{\n+  using A = __gnu_test::propagating_allocator<X, false>;\n+  A a1(1), a2(2);\n+  std::unordered_set<X, XHasher, XEqualTo, A> u1(a1), u2(a2);\n+  u1 = { X(0), X(1), X(2) };\n+  u2 = { X(3), X(4), X(5) };\n+\n+  moves = 0;\n+  u1 = std::move(u2);\n+\n+  VERIFY( moves == 3 );\n+  VERIFY( u1.count(X(1)) == 0 );\n+  VERIFY( u1.count(X(3)) == 1 );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+}"}]}