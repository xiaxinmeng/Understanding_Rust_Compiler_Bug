{"sha": "b1357021b832988e12895b1fa3ca6a24c1677009", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjEzNTcwMjFiODMyOTg4ZTEyODk1YjFmYTNjYTZhMjRjMTY3NzAwOQ==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1997-03-06T21:28:31Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1997-03-06T21:28:31Z"}, "message": "(root_type_1, write_modifier_bytes_1): New functions.\n\n(root_type): Call root_type_1.\n(write_modifier_bytes): Call write_modifier_bytes_1.\n(output_type, case POINTER_TYPE): Set TREE_ASM_WRITTEN before\nrecursive call.\n\nFrom-SVN: r13693", "tree": {"sha": "68778ff202d2a983c81d23befd85b59014e2a3ea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/68778ff202d2a983c81d23befd85b59014e2a3ea"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b1357021b832988e12895b1fa3ca6a24c1677009", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b1357021b832988e12895b1fa3ca6a24c1677009", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b1357021b832988e12895b1fa3ca6a24c1677009", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b1357021b832988e12895b1fa3ca6a24c1677009/comments", "author": null, "committer": null, "parents": [{"sha": "2dfe5480598b33c904aa769a75325f4025ada70e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2dfe5480598b33c904aa769a75325f4025ada70e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2dfe5480598b33c904aa769a75325f4025ada70e"}], "stats": {"total": 49, "additions": 42, "deletions": 7}, "files": [{"sha": "ed201898c6cdc8557e58ac700a8f11ac9eb1e734", "filename": "gcc/dwarfout.c", "status": "modified", "additions": 42, "deletions": 7, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1357021b832988e12895b1fa3ca6a24c1677009/gcc%2Fdwarfout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1357021b832988e12895b1fa3ca6a24c1677009/gcc%2Fdwarfout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarfout.c?ref=b1357021b832988e12895b1fa3ca6a24c1677009", "patch": "@@ -319,7 +319,9 @@ static void output_unsigned_leb128\tPROTO((unsigned long));\n static void output_signed_leb128\tPROTO((long));\n static inline int is_body_block\t\tPROTO((tree));\n static int fundamental_type_code\tPROTO((tree));\n+static tree root_type_1\t\t\tPROTO((tree, int));\n static tree root_type\t\t\tPROTO((tree));\n+static void write_modifier_bytes_1\tPROTO((tree, int, int, int));\n static void write_modifier_bytes\tPROTO((tree, int, int));\n static inline int type_is_fundamental\tPROTO((tree));\n static void equate_decl_number_to_die_number PROTO((tree));\n@@ -1447,10 +1449,14 @@ fundamental_type_code (type)\n    qualifiers.  */\n \n static tree\n-root_type (type)\n+root_type_1 (type, count)\n      register tree type;\n+     register int count;\n {\n-  if (TREE_CODE (type) == ERROR_MARK)\n+  /* Give up after searching 1000 levels, in case this is a recursive\n+     pointer type.  Such types are possible in Ada, but it is not possible\n+     to represent them in DWARF1 debug info.  */\n+  if (count > 1000)\n     return error_mark_node;\n \n   switch (TREE_CODE (type))\n@@ -1460,25 +1466,42 @@ root_type (type)\n \n       case POINTER_TYPE:\n       case REFERENCE_TYPE:\n-\treturn type_main_variant (root_type (TREE_TYPE (type)));\n+\treturn root_type_1 (TREE_TYPE (type), count+1);\n \n       default:\n-\treturn type_main_variant (type);\n+\treturn type;\n     }\n }\n \n+static tree\n+root_type (type)\n+     register tree type;\n+{\n+  type = root_type_1 (type, 0);\n+  if (type != error_mark_node)\n+    type = type_main_variant (type);\n+  return type;\n+}\n+\n /* Given a pointer to an arbitrary ..._TYPE tree node, write out a sequence\n    of zero or more Dwarf \"type-modifier\" bytes applicable to the type.\t*/\n \n static void\n-write_modifier_bytes (type, decl_const, decl_volatile)\n+write_modifier_bytes_1 (type, decl_const, decl_volatile, count)\n      register tree type;\n      register int decl_const;\n      register int decl_volatile;\n+     register int count;\n {\n   if (TREE_CODE (type) == ERROR_MARK)\n     return;\n \n+  /* Give up after searching 1000 levels, in case this is a recursive\n+     pointer type.  Such types are possible in Ada, but it is not possible\n+     to represent them in DWARF1 debug info.  */\n+  if (count > 1000)\n+    return;\n+\n   if (TYPE_READONLY (type) || decl_const)\n     ASM_OUTPUT_DWARF_TYPE_MODIFIER (asm_out_file, MOD_const);\n   if (TYPE_VOLATILE (type) || decl_volatile)\n@@ -1487,19 +1510,28 @@ write_modifier_bytes (type, decl_const, decl_volatile)\n     {\n       case POINTER_TYPE:\n \tASM_OUTPUT_DWARF_TYPE_MODIFIER (asm_out_file, MOD_pointer_to);\n-\twrite_modifier_bytes (TREE_TYPE (type), 0, 0);\n+\twrite_modifier_bytes_1 (TREE_TYPE (type), 0, 0, count+1);\n \treturn;\n \n       case REFERENCE_TYPE:\n \tASM_OUTPUT_DWARF_TYPE_MODIFIER (asm_out_file, MOD_reference_to);\n-\twrite_modifier_bytes (TREE_TYPE (type), 0, 0);\n+\twrite_modifier_bytes_1 (TREE_TYPE (type), 0, 0, count+1);\n \treturn;\n \n       case ERROR_MARK:\n       default:\n \treturn;\n     }\n }\n+\n+static void\n+write_modifier_bytes (type, decl_const, decl_volatile)\n+     register tree type;\n+     register int decl_const;\n+     register int decl_volatile;\n+{\n+  write_modifier_bytes_1 (type, decl_const, decl_volatile, 0);\n+}\n \f\n /* Given a pointer to an arbitrary ..._TYPE tree node, return non-zero if the\n    given input type is a Dwarf \"fundamental\" type.  Otherwise return zero.  */\n@@ -4152,6 +4184,9 @@ output_type (type, containing_scope)\n \n       case POINTER_TYPE:\n       case REFERENCE_TYPE:\n+\t/* Prevent infinite recursion in cases where this is a recursive\n+\t   type.  Recursive types are possible in Ada.  */\n+\tTREE_ASM_WRITTEN (type) = 1;\n \t/* For these types, all that is required is that we output a DIE\n \t   (or a set of DIEs) to represent the \"basis\" type.  */\n \toutput_type (TREE_TYPE (type), containing_scope);"}]}