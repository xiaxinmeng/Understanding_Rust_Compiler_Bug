{"sha": "b928a6517e21c8f8929cd21cb78075418a4c3666", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjkyOGE2NTE3ZTIxYzhmODkyOWNkMjFjYjc4MDc1NDE4YTRjMzY2Ng==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "1999-05-22T01:30:11Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-05-22T01:30:11Z"}, "message": "cp-tree.h (cplus_expand_constant): Declare.\n\n\t* cp-tree.h (cplus_expand_constant): Declare.\n\t* cvt.c (convert_to_pointer): Expand PTRMEM_CSTs when they're\n\tconverted from one pointer-to-object type to another.\n\t* expr.c (cplus_expand_constant): Don't make it static.\n\t* typeck.c (build_component_ref): Don't crash when presented with\n\ta component which is a TEMPLATE_DECL.\n\t(build_ptrmemfunc): Tidy.  Clarify comment.  Make sure that even a\n\tcast from a pointer-to-member constant to its own type does not\n\tresult in a valid non-type template argument.\n\nFrom-SVN: r27092", "tree": {"sha": "3a205f0cf17eb8c1639d2bf054726a1987381549", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3a205f0cf17eb8c1639d2bf054726a1987381549"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b928a6517e21c8f8929cd21cb78075418a4c3666", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b928a6517e21c8f8929cd21cb78075418a4c3666", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b928a6517e21c8f8929cd21cb78075418a4c3666", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b928a6517e21c8f8929cd21cb78075418a4c3666/comments", "author": null, "committer": null, "parents": [{"sha": "4d49638c24e1f1e9f0f363913f20109b6829dbe7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d49638c24e1f1e9f0f363913f20109b6829dbe7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4d49638c24e1f1e9f0f363913f20109b6829dbe7"}], "stats": {"total": 101, "additions": 72, "deletions": 29}, "files": [{"sha": "39cec74814627534fdbef661e1f661c88cd4c239", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b928a6517e21c8f8929cd21cb78075418a4c3666/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b928a6517e21c8f8929cd21cb78075418a4c3666/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=b928a6517e21c8f8929cd21cb78075418a4c3666", "patch": "@@ -1,3 +1,15 @@\n+1999-05-22  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* cp-tree.h (cplus_expand_constant): Declare.\n+\t* cvt.c (convert_to_pointer): Expand PTRMEM_CSTs when they're\n+\tconverted from one pointer-to-object type to another.\n+\t* expr.c (cplus_expand_constant): Don't make it static.\n+\t* typeck.c (build_component_ref): Don't crash when presented with\n+\ta component which is a TEMPLATE_DECL.\n+\t(build_ptrmemfunc): Tidy.  Clarify comment.  Make sure that even a\n+\tcast from a pointer-to-member constant to its own type does not\n+\tresult in a valid non-type template argument.\n+\n 1999-05-21  Mark Mitchell  <mark@codesourcery.com>\n             Nathan Sidwell  <nathan@acm.org>\n \t"}, {"sha": "ec5ef45ba72ad28d914226bc510b3e9fe4adb802", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b928a6517e21c8f8929cd21cb78075418a4c3666/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b928a6517e21c8f8929cd21cb78075418a4c3666/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=b928a6517e21c8f8929cd21cb78075418a4c3666", "patch": "@@ -3007,6 +3007,7 @@ extern void init_cplus_expand\t\t\tPROTO((void));\n extern void fixup_result_decl\t\t\tPROTO((tree, struct rtx_def *));\n extern int extract_init\t\t\t\tPROTO((tree, tree));\n extern void do_case\t\t\t\tPROTO((tree, tree));\n+extern tree cplus_expand_constant               PROTO((tree));\n \n /* friend.c */\n extern int is_friend\t\t\t\tPROTO((tree, tree));"}, {"sha": "d24dbf1f4ecab598a4afe60b2c0482a759adb0fd", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b928a6517e21c8f8929cd21cb78075418a4c3666/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b928a6517e21c8f8929cd21cb78075418a4c3666/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=b928a6517e21c8f8929cd21cb78075418a4c3666", "patch": "@@ -179,19 +179,29 @@ cp_convert_to_pointer (type, expr)\n \n       if (TYPE_PTRMEM_P (type) && TYPE_PTRMEM_P (intype))\n \t{\n-\t  tree b1 = TYPE_OFFSET_BASETYPE (TREE_TYPE (type));\n-\t  tree b2 = TYPE_OFFSET_BASETYPE (TREE_TYPE (intype));\n-\t  tree binfo = get_binfo (b2, b1, 1);\n-\t  enum tree_code code = PLUS_EXPR;\n+\t  tree b1; \n+\t  tree b2;\n+\t  tree binfo;\n+\t  enum tree_code code;\n+\n+\t  b1 = TYPE_OFFSET_BASETYPE (TREE_TYPE (type));\n+\t  b2 = TYPE_OFFSET_BASETYPE (TREE_TYPE (intype));\n+\t  binfo = get_binfo (b2, b1, 1);\n \n \t  if (binfo == NULL_TREE)\n \t    {\n \t      binfo = get_binfo (b1, b2, 1);\n \t      code = MINUS_EXPR;\n \t    }\n+\t  else\n+\t    code = PLUS_EXPR;\n \n \t  if (binfo == error_mark_node)\n \t    return error_mark_node;\n+\n+\t  if (TREE_CODE (expr) == PTRMEM_CST)\n+\t    expr = cplus_expand_constant (expr);\n+\n \t  if (binfo && ! TREE_VIA_VIRTUAL (binfo))\n \t    expr = size_binop (code, expr, BINFO_OFFSET (binfo));\n \t}"}, {"sha": "d5250ae603ff7b12d7864fe88857843fb2a80a99", "filename": "gcc/cp/expr.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b928a6517e21c8f8929cd21cb78075418a4c3666/gcc%2Fcp%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b928a6517e21c8f8929cd21cb78075418a4c3666/gcc%2Fcp%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexpr.c?ref=b928a6517e21c8f8929cd21cb78075418a4c3666", "patch": "@@ -39,7 +39,7 @@ static rtx cplus_expand_expr PROTO((tree, rtx, enum machine_mode,\n /* Hook used by output_constant to expand language-specific\n    constants.  */\n \n-static tree\n+tree\n cplus_expand_constant (cst)\n      tree cst;\n {"}, {"sha": "1514ed7a9a93fc0409657d6e748ef067064f082c", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 29, "deletions": 23, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b928a6517e21c8f8929cd21cb78075418a4c3666/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b928a6517e21c8f8929cd21cb78075418a4c3666/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=b928a6517e21c8f8929cd21cb78075418a4c3666", "patch": "@@ -2138,6 +2138,11 @@ build_component_ref (datum, component, basetype_path, protect)\n       cp_error (\"invalid use of type decl `%#D' as expression\", component);\n       return error_mark_node;\n     }\n+  else if (TREE_CODE (component) == TEMPLATE_DECL)\n+    {\n+      cp_error (\"invalid use of template `%#D' as expression\", component);\n+      return error_mark_node;\n+    }\n   else\n     {\n       tree name = component;\n@@ -6516,7 +6521,9 @@ build_ptrmemfunc (type, pfn, force)\n      int force;\n {\n   tree fn;\n-  \n+  tree pfn_type = TREE_TYPE (pfn);\n+  tree to_type = build_ptrmemfunc_type (type);\n+\n   /* Handle multiple conversions of pointer to member functions.  */\n   if (TYPE_PTRMEMFUNC_P (TREE_TYPE (pfn)))\n     {\n@@ -6526,34 +6533,34 @@ build_ptrmemfunc (type, pfn, force)\n       tree npfn = NULL_TREE;\n       tree ndelta, ndelta2;\n       tree e1, e2, e3, n;\n-      tree pfn_type;\n \n-      /* Is is already the right type? */\n-      if (type == TYPE_PTRMEMFUNC_FN_TYPE (TREE_TYPE (pfn)))\n-\treturn pfn;\n-\n-      pfn_type = TYPE_PTRMEMFUNC_FN_TYPE (TREE_TYPE (pfn));\n-      if (!force\n-\t  && comp_target_types (type, pfn_type, 1) != 1)\n-\tcp_error (\"conversion to `%T' from `%T'\", type, pfn_type);\n+      if (!force \n+\t  && !can_convert_arg (to_type, TREE_TYPE (pfn), pfn))\n+\tcp_error (\"conversion to `%T' from `%T'\", \n+\t\t  to_type, pfn_type);\n \n       if (TREE_CODE (pfn) == PTRMEM_CST)\n \t{\n \t  /* We could just build the resulting CONSTRUCTOR now, but we\n \t     don't, relying on the general machinery below, together\n \t     with constant-folding, to do the right thing.  We don't\n-\t     want to return a PTRMEM_CST here, even though we could,\n-\t     because a pointer-to-member constant ceases to be a\n-\t     constant (from the point of view of the language) when it\n-\t     is cast to another type.  */\n-\n+\t     want to return a PTRMEM_CST here, since a\n+\t     pointer-to-member constant is no longer a valid template\n+\t     argument once it is cast to any type, including its\n+\t     original type.  */\n \t  expand_ptrmemfunc_cst (pfn, &ndelta, &idx, &npfn, &ndelta2);\n \t  if (npfn)\n \t    /* This constant points to a non-virtual function.\n \t       NDELTA2 will be NULL, but it's value doesn't really\n \t       matter since we won't use it anyhow.  */\n \t    ndelta2 = integer_zero_node;\n \t}\n+      else if (same_type_p (to_type, pfn_type))\n+\t/* We don't have to do any conversion.  Note that we do this\n+\t   after checking for a PTRMEM_CST so that a PTRMEM_CST, cast\n+\t   to its own type, will not be considered a legal non-type\n+\t   template argument.  */\n+\treturn pfn;\n       else\n \t{\n \t  ndelta = cp_convert (ptrdiff_type_node, \n@@ -6565,15 +6572,15 @@ build_ptrmemfunc (type, pfn, force)\n \t  idx = build_component_ref (pfn, index_identifier, NULL_TREE, 0);\n \t}\n \n-      n = get_delta_difference (TYPE_METHOD_BASETYPE (TREE_TYPE (pfn_type)),\n-\t\t\t\tTYPE_METHOD_BASETYPE (TREE_TYPE (type)),\n+      n = get_delta_difference (TYPE_PTRMEMFUNC_OBJECT_TYPE (pfn_type),\n+\t\t\t\tTYPE_PTRMEMFUNC_OBJECT_TYPE (to_type),\n \t\t\t\tforce);\n       delta = build_binary_op (PLUS_EXPR, ndelta, n);\n       delta2 = build_binary_op (PLUS_EXPR, ndelta2, n);\n       e1 = fold (build (GT_EXPR, boolean_type_node, idx, integer_zero_node));\n \t  \n       /* If it's a virtual function, this is what we want.  */\n-      e2 = build_ptrmemfunc1 (TYPE_GET_PTRMEMFUNC_TYPE (type), delta, idx,\n+      e2 = build_ptrmemfunc1 (to_type, delta, idx,\n \t\t\t      NULL_TREE, delta2);\n \n       pfn = PFN_FROM_PTRMEMFUNC (pfn);\n@@ -6582,7 +6589,7 @@ build_ptrmemfunc (type, pfn, force)\n \n       /* But if it's a non-virtual function, or NULL, we use this\n \t instead.  */\n-      e3 = build_ptrmemfunc1 (TYPE_GET_PTRMEMFUNC_TYPE (type), delta,\n+      e3 = build_ptrmemfunc1 (to_type, delta,\n \t\t\t      idx, npfn, NULL_TREE);\n       return build_conditional_expr (e1, e2, e3);\n     }\n@@ -6591,7 +6598,7 @@ build_ptrmemfunc (type, pfn, force)\n   if (integer_zerop (pfn))\n     {\n       pfn = build_c_cast (type, integer_zero_node);\n-      return build_ptrmemfunc1 (TYPE_GET_PTRMEMFUNC_TYPE (type),\n+      return build_ptrmemfunc1 (to_type,\n \t\t\t\tinteger_zero_node, integer_zero_node,\n \t\t\t\tpfn, NULL_TREE);\n     }\n@@ -6601,7 +6608,7 @@ build_ptrmemfunc (type, pfn, force)\n \n   fn = TREE_OPERAND (pfn, 0);\n   my_friendly_assert (TREE_CODE (fn) == FUNCTION_DECL, 0);\n-  return make_ptrmem_cst (build_ptrmemfunc_type (type), fn);\n+  return make_ptrmem_cst (to_type, fn);\n }\n \n /* Return the DELTA, IDX, PFN, and DELTA2 values for the PTRMEM_CST\n@@ -6621,8 +6628,7 @@ expand_ptrmemfunc_cst (cst, delta, idx, pfn, delta2)\n   my_friendly_assert (TREE_CODE (fn) == FUNCTION_DECL, 0);\n   \n   *delta \n-    = get_delta_difference (TYPE_METHOD_BASETYPE \n-\t\t\t    (TREE_TYPE (fn)),\n+    = get_delta_difference (TYPE_METHOD_BASETYPE (TREE_TYPE (fn)),\n \t\t\t    TYPE_PTRMEMFUNC_OBJECT_TYPE (type),\n \t\t\t    /*force=*/0);\n   if (!DECL_VIRTUAL_P (fn))"}, {"sha": "69df5352381aed50730c324a0afc77f055ceeb91", "filename": "gcc/testsuite/g++.old-deja/g++.pt/crash42.C", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b928a6517e21c8f8929cd21cb78075418a4c3666/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fcrash42.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b928a6517e21c8f8929cd21cb78075418a4c3666/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fcrash42.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fcrash42.C?ref=b928a6517e21c8f8929cd21cb78075418a4c3666", "patch": "@@ -0,0 +1,14 @@\n+// Build don't link:\n+// Origin: Walter Brisken <walterfb@puppsr14.princeton.edu>\n+\n+template <class T> class list {};\n+\n+class newtype\n+{\n+};\n+\n+void crash()\n+{\n+  newtype* n;\n+  n->list.size (); // ERROR - invalid use of template\n+}"}, {"sha": "e7750ddf969ef41417b820b8cc3d01b254b36dd6", "filename": "gcc/testsuite/g++.old-deja/g++.pt/ptrmem6.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b928a6517e21c8f8929cd21cb78075418a4c3666/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fptrmem6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b928a6517e21c8f8929cd21cb78075418a4c3666/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fptrmem6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fptrmem6.C?ref=b928a6517e21c8f8929cd21cb78075418a4c3666", "patch": "@@ -23,7 +23,7 @@ int main() {\n   h<&A::i>();\n   g<&B::f>(); // ERROR - \n   h<&B::j>(); // ERROR - \n-  g<(void (A::*)()) &A::f>(); // ERROR - XFAIL *-*-*\n+  g<(void (A::*)()) &A::f>(); // ERROR - \n   h<(int A::*) &A::i>(); // ERROR - \n   g<(void (A::*)()) &B::f>(); // ERROR - \n   h<(int A::*) &B::j>(); // ERROR - "}]}