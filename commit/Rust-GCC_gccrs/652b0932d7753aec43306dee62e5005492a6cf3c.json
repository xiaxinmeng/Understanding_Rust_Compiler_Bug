{"sha": "652b0932d7753aec43306dee62e5005492a6cf3c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjUyYjA5MzJkNzc1M2FlYzQzMzA2ZGVlNjJlNTAwNTQ5MmE2Y2YzYw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2005-09-17T18:38:36Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2005-09-17T18:38:36Z"}, "message": "expr.c (emit_move_via_integer): Add force argument, pass it on to emit_move_change_mode.\n\n        * expr.c (emit_move_via_integer): Add force argument, pass it on\n        to emit_move_change_mode.  Update callers.\n        (emit_move_complex): Pass true to new force argument.\n        * function.c (expand_function_end): Move expand_eh_return call\n        earlier.  Merge sub-word complex values into a pseudo before\n        copying to the return hard register.\n\nFrom-SVN: r104371", "tree": {"sha": "586ee19cf00f968f147f254400212285835033a4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/586ee19cf00f968f147f254400212285835033a4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/652b0932d7753aec43306dee62e5005492a6cf3c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/652b0932d7753aec43306dee62e5005492a6cf3c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/652b0932d7753aec43306dee62e5005492a6cf3c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/652b0932d7753aec43306dee62e5005492a6cf3c/comments", "author": null, "committer": null, "parents": [{"sha": "3fb90446b48b875877c4f09c0085fe59b836bbfe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3fb90446b48b875877c4f09c0085fe59b836bbfe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3fb90446b48b875877c4f09c0085fe59b836bbfe"}], "stats": {"total": 47, "additions": 37, "deletions": 10}, "files": [{"sha": "abf9fe06017d8df8685f24fa74dd018985d21cef", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/652b0932d7753aec43306dee62e5005492a6cf3c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/652b0932d7753aec43306dee62e5005492a6cf3c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=652b0932d7753aec43306dee62e5005492a6cf3c", "patch": "@@ -1,3 +1,12 @@\n+2005-09-17  Richard Henderson  <rth@redhat.com>\n+\n+\t* expr.c (emit_move_via_integer): Add force argument, pass it on\n+\tto emit_move_change_mode.  Update callers.\n+\t(emit_move_complex): Pass true to new force argument.\n+\t* function.c (expand_function_end): Move expand_eh_return call\n+\tearlier.  Merge sub-word complex values into a pseudo before\n+\tcopying to the return hard register.\n+\n 2005-09-17  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* varasm.c (output_constant): Do not abort on VIEW_CONVERT_EXPRs"}, {"sha": "e99be6c40a640cf816328ef84a2ba14022a048b9", "filename": "gcc/expr.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/652b0932d7753aec43306dee62e5005492a6cf3c/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/652b0932d7753aec43306dee62e5005492a6cf3c/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=652b0932d7753aec43306dee62e5005492a6cf3c", "patch": "@@ -2812,7 +2812,7 @@ emit_move_change_mode (enum machine_mode new_mode,\n    emitted, or NULL if such a move could not be generated.  */\n \n static rtx\n-emit_move_via_integer (enum machine_mode mode, rtx x, rtx y)\n+emit_move_via_integer (enum machine_mode mode, rtx x, rtx y, bool force)\n {\n   enum machine_mode imode;\n   enum insn_code code;\n@@ -2827,10 +2827,10 @@ emit_move_via_integer (enum machine_mode mode, rtx x, rtx y)\n   if (code == CODE_FOR_nothing)\n     return NULL_RTX;\n \n-  x = emit_move_change_mode (imode, mode, x, false);\n+  x = emit_move_change_mode (imode, mode, x, force);\n   if (x == NULL_RTX)\n     return NULL_RTX;\n-  y = emit_move_change_mode (imode, mode, y, false);\n+  y = emit_move_change_mode (imode, mode, y, force);\n   if (y == NULL_RTX)\n     return NULL_RTX;\n   return emit_insn (GEN_FCN (code) (x, y));\n@@ -2973,7 +2973,7 @@ emit_move_complex (enum machine_mode mode, rtx x, rtx y)\n \t  return get_last_insn ();\n \t}\n \n-      ret = emit_move_via_integer (mode, x, y);\n+      ret = emit_move_via_integer (mode, x, y, true);\n       if (ret)\n \treturn ret;\n     }\n@@ -3011,7 +3011,7 @@ emit_move_ccmode (enum machine_mode mode, rtx x, rtx y)\n     }\n \n   /* Otherwise, find the MODE_INT mode of the same width.  */\n-  ret = emit_move_via_integer (mode, x, y);\n+  ret = emit_move_via_integer (mode, x, y, false);\n   gcc_assert (ret != NULL);\n   return ret;\n }\n@@ -3119,7 +3119,7 @@ emit_move_insn_1 (rtx x, rtx y)\n      fits within a HOST_WIDE_INT.  */\n   if (!CONSTANT_P (y) || GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT)\n     {\n-      rtx ret = emit_move_via_integer (mode, x, y);\n+      rtx ret = emit_move_via_integer (mode, x, y, false);\n       if (ret)\n \treturn ret;\n     }"}, {"sha": "2df1eff5b44995569225fe1dacd800858ef2f9d1", "filename": "gcc/function.c", "status": "modified", "additions": 22, "deletions": 4, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/652b0932d7753aec43306dee62e5005492a6cf3c/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/652b0932d7753aec43306dee62e5005492a6cf3c/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=652b0932d7753aec43306dee62e5005492a6cf3c", "patch": "@@ -4403,6 +4403,10 @@ expand_function_end (void)\n   if (flag_exceptions && USING_SJLJ_EXCEPTIONS)\n     sjlj_emit_function_exit_after (get_last_insn ());\n \n+  /* If this is an implementation of throw, do what's necessary to\n+     communicate between __builtin_eh_return and the epilogue.  */\n+  expand_eh_return ();\n+\n   /* If scalar return value was computed in a pseudo-reg, or was a named\n      return value that got dumped to the stack, copy that to the hard\n      return register.  */\n@@ -4464,6 +4468,24 @@ expand_function_end (void)\n \t\t\t\t TREE_TYPE (decl_result),\n \t\t\t\t int_size_in_bytes (TREE_TYPE (decl_result)));\n \t    }\n+\t  /* In the case of complex integer modes smaller than a word, we'll\n+\t     need to generate some non-trivial bitfield insertions.  Do that\n+\t     on a pseudo and not the hard register.  */\n+\t  else if (GET_CODE (decl_rtl) == CONCAT\n+\t\t   && GET_MODE_CLASS (GET_MODE (decl_rtl)) == MODE_COMPLEX_INT\n+\t\t   && GET_MODE_BITSIZE (GET_MODE (decl_rtl)) <= BITS_PER_WORD)\n+\t    {\n+\t      int old_generating_concat_p;\n+\t      rtx tmp;\n+\n+\t      old_generating_concat_p = generating_concat_p;\n+\t      generating_concat_p = 0;\n+\t      tmp = gen_reg_rtx (GET_MODE (decl_rtl));\n+\t      generating_concat_p = old_generating_concat_p;\n+\n+\t      emit_move_insn (tmp, decl_rtl);\n+\t      emit_move_insn (real_decl_rtl, tmp);\n+\t    }\n \t  else\n \t    emit_move_insn (real_decl_rtl, decl_rtl);\n \t}\n@@ -4505,10 +4527,6 @@ expand_function_end (void)\n       current_function_return_rtx = outgoing;\n     }\n \n-  /* If this is an implementation of throw, do what's necessary to\n-     communicate between __builtin_eh_return and the epilogue.  */\n-  expand_eh_return ();\n-\n   /* Emit the actual code to clobber return register.  */\n   {\n     rtx seq;"}]}