{"sha": "353127c220a706cc624d7ef553c042ba63dc0d89", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzUzMTI3YzIyMGE3MDZjYzYyNGQ3ZWY1NTNjMDQyYmE2M2RjMGQ4OQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-07-14T12:21:01Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-07-14T12:21:01Z"}, "message": "(loop_number_exit_count): New global variable.\n\n(loop_optimize): Allocate space for it.\n(find_and_verify_loops, mark_loop_jump): Set it.\n(strength_reduce, check_dbra_loop): Use loop_number_exit_count instead\nof loop_number_exit_labels.\n\nFrom-SVN: r10128", "tree": {"sha": "b30946f39cfd3add2a430af96a9040c5b621d199", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b30946f39cfd3add2a430af96a9040c5b621d199"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/353127c220a706cc624d7ef553c042ba63dc0d89", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/353127c220a706cc624d7ef553c042ba63dc0d89", "html_url": "https://github.com/Rust-GCC/gccrs/commit/353127c220a706cc624d7ef553c042ba63dc0d89", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/353127c220a706cc624d7ef553c042ba63dc0d89/comments", "author": null, "committer": null, "parents": [{"sha": "e6a125a009ce35346ccc1afa40d9dd3714cef210", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e6a125a009ce35346ccc1afa40d9dd3714cef210", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e6a125a009ce35346ccc1afa40d9dd3714cef210"}], "stats": {"total": 32, "additions": 28, "deletions": 4}, "files": [{"sha": "027e1aa9e8d234d439357d09259aa2368612a267", "filename": "gcc/loop.c", "status": "modified", "additions": 28, "deletions": 4, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/353127c220a706cc624d7ef553c042ba63dc0d89/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/353127c220a706cc624d7ef553c042ba63dc0d89/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=353127c220a706cc624d7ef553c042ba63dc0d89", "patch": "@@ -97,6 +97,11 @@ static char *loop_invalid;\n \n rtx *loop_number_exit_labels;\n \n+/* Indexed by loop number, counts the number of LABEL_REFs on\n+   loop_number_exit_labels for this loop and all loops nested inside it.  */\n+\n+int *loop_number_exit_count;\n+\n /* Holds the number of loop iterations.  It is zero if the number could not be\n    calculated.  Must be unsigned since the number of iterations can\n    be as high as 2^wordsize-1.  For loops with a wider iterator, this number\n@@ -372,6 +377,7 @@ loop_optimize (f, dumpfile)\n   loop_outer_loop = (int *) alloca (max_loop_num * sizeof (int));\n   loop_invalid = (char *) alloca (max_loop_num * sizeof (char));\n   loop_number_exit_labels = (rtx *) alloca (max_loop_num * sizeof (rtx));\n+  loop_number_exit_count = (int *) alloca (max_loop_num * sizeof (int));\n \n   /* Find and process each loop.\n      First, find them, and record them in order of their beginnings.  */\n@@ -2240,6 +2246,7 @@ find_and_verify_loops (f)\n \t    loop_outer_loop[next_loop] = current_loop;\n \t    loop_invalid[next_loop] = 0;\n \t    loop_number_exit_labels[next_loop] = 0;\n+\t    loop_number_exit_count[next_loop] = 0;\n \t    current_loop = next_loop;\n \t    break;\n \n@@ -2407,6 +2414,8 @@ find_and_verify_loops (f)\n \t\t\t  LABEL_OUTSIDE_LOOP_P bit.  */\n \t\t       if (JUMP_LABEL (insn))\n \t\t\t {\n+\t\t\t   int loop_num;\n+\n \t\t\t   for (q = 0,\n \t\t\t\tr = loop_number_exit_labels[this_loop_num];\n \t\t\t\tr; q = r, r = LABEL_NEXTREF (r))\n@@ -2421,6 +2430,11 @@ find_and_verify_loops (f)\n \t\t\t\t break;\n \t\t\t       }\n \n+\t\t\t   for (loop_num = this_loop_num;\n+\t\t\t\tloop_num != -1 && loop_num != target_loop_num;\n+\t\t\t\tloop_num = loop_outer_loop[loop_num])\n+\t\t\t     loop_number_exit_count[loop_num]--;\n+\n \t\t\t   /* If we didn't find it, then something is wrong. */\n \t\t\t   if (! r)\n \t\t\t     abort ();\n@@ -2513,6 +2527,11 @@ mark_loop_jump (x, loop_num)\n \t  LABEL_OUTSIDE_LOOP_P (x) = 1;\n \t  LABEL_NEXTREF (x) = loop_number_exit_labels[loop_num];\n \t  loop_number_exit_labels[loop_num] = x;\n+\n+\t  for (outer_loop = loop_num;\n+\t       outer_loop != -1 && outer_loop != dest_loop;\n+\t       outer_loop = loop_outer_loop[outer_loop])\n+\t    loop_number_exit_count[outer_loop]++;\n \t}\n \n       /* If this is inside a loop, but not in the current loop or one enclosed\n@@ -2569,8 +2588,13 @@ mark_loop_jump (x, loop_num)\n \t as a branch out of this loop, but not into any loop.  */\n \n       if (loop_num != -1)\n-\tloop_number_exit_labels[loop_num] = x;\n+\t{\n+\t  loop_number_exit_labels[loop_num] = x;\n \n+\t  for (outer_loop = loop_num; outer_loop != -1;\n+\t       outer_loop = loop_outer_loop[outer_loop])\n+\t    loop_number_exit_count[outer_loop]++;\n+\t}\n       return;\n     }\n }\n@@ -3905,7 +3929,7 @@ strength_reduce (scan_start, end, loop_top, insn_count,\n \t\t loop to ensure that it will always be executed no matter\n \t\t how the loop exits.  Otherwise, emit the insn after the loop,\n \t\t since this is slightly more efficient.  */\n-\t      if (loop_number_exit_labels[uid_loop_num[INSN_UID (loop_start)]])\n+\t      if (loop_number_exit_count[uid_loop_num[INSN_UID (loop_start)]])\n \t\tinsert_before = loop_start;\n \t      else\n \t\tinsert_before = end_insert_before;\n@@ -3997,7 +4021,7 @@ strength_reduce (scan_start, end, loop_top, insn_count,\n \t\t loop to ensure that it will always be executed no matter\n \t\t how the loop exits.  Otherwise, emit the insn after the\n \t\t loop, since this is slightly more efficient.  */\n-\t      if (loop_number_exit_labels[uid_loop_num[INSN_UID (loop_start)]])\n+\t      if (loop_number_exit_count[uid_loop_num[INSN_UID (loop_start)]])\n \t\tinsert_before = loop_start;\n \t      else\n \t\tinsert_before = end_insert_before;\n@@ -5712,7 +5736,7 @@ check_dbra_loop (loop_end, insn_count, loop_start)\n \t  num_nonfixed_reads += count_nonfixed_reads (PATTERN (p));\n \n       if (bl->giv_count == 0\n-\t  && ! loop_number_exit_labels[uid_loop_num[INSN_UID (loop_start)]])\n+\t  && ! loop_number_exit_count[uid_loop_num[INSN_UID (loop_start)]])\n \t{\n \t  rtx bivreg = regno_reg_rtx[bl->regno];\n "}]}