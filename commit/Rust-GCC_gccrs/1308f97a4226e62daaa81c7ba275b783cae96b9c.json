{"sha": "1308f97a4226e62daaa81c7ba275b783cae96b9c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTMwOGY5N2E0MjI2ZTYyZGFhYTgxYzdiYTI3NWI3ODNjYWU5NmI5Yw==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-10-26T23:32:59Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-10-26T23:32:59Z"}, "message": "Initial revision\n\nFrom-SVN: r5909", "tree": {"sha": "bc279b29971c7a6e9407bc2cddaf2b168567c30d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bc279b29971c7a6e9407bc2cddaf2b168567c30d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1308f97a4226e62daaa81c7ba275b783cae96b9c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1308f97a4226e62daaa81c7ba275b783cae96b9c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1308f97a4226e62daaa81c7ba275b783cae96b9c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1308f97a4226e62daaa81c7ba275b783cae96b9c/comments", "author": null, "committer": null, "parents": [{"sha": "115d1e8ec72c3d625b49743af264a5e71988cfaf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/115d1e8ec72c3d625b49743af264a5e71988cfaf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/115d1e8ec72c3d625b49743af264a5e71988cfaf"}], "stats": {"total": 240, "additions": 240, "deletions": 0}, "files": [{"sha": "153b4f4afa944eb95bacb4420baac4960ce2db24", "filename": "gcc/config/i860/paragon.h", "status": "added", "additions": 240, "deletions": 0, "changes": 240, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1308f97a4226e62daaa81c7ba275b783cae96b9c/gcc%2Fconfig%2Fi860%2Fparagon.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1308f97a4226e62daaa81c7ba275b783cae96b9c/gcc%2Fconfig%2Fi860%2Fparagon.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi860%2Fparagon.h?ref=1308f97a4226e62daaa81c7ba275b783cae96b9c", "patch": "@@ -0,0 +1,240 @@\n+/* Target definitions for GNU compiler for Intel 80860 running OSF/1AD\n+   Copyright (C) 1991 Free Software Foundation, Inc.\n+\n+   Based upon original work of Ron Guilmette (rfg@ncd.com).\n+   Whacked into submission by Andy Pfiffer (andyp@ssd.intel.com).\n+   Additional support from:\n+\tPete Beckman @ Indiana University (beckman@cs.indiana.edu)\n+\tHarry Dolan of Intel Corporation (dolan@ssd.intel.com)\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+#include \"i860/i860.h\"\n+#include \"svr3.h\"\n+\n+/* For the sake of libgcc2.c, indicate target supports atexit.  */\n+#define HAVE_ATEXIT\n+\n+#undef TARGET_SWITCHES\n+#define TARGET_SWITCHES  \\\n+  { {\"xp\", 1},                  \\\n+    {\"noxp\", -1},               \\\n+    {\"xr\", -1},                 \\\n+    {\"noieee\", -1},\t\t\\\n+    {\"nx\", 2},                  \\\n+    { \"\", TARGET_DEFAULT}}\n+ \n+#undef TARGET_DEFAULT\n+#define TARGET_DEFAULT 1\n+\n+/* The Intel as860 assembler does not understand .stabs, must use COFF */\n+#define PREFERRED_DEBUGGING_TYPE SDB_DEBUG\n+\n+#undef TARGET_VERSION\n+#define TARGET_VERSION fprintf (stderr, \" (i860 OSF/1AD)\");\n+\n+#undef CPP_PREDEFINES\n+#define CPP_PREDEFINES\t\"-Di860 -D__i860 -D__i860__ -D__PARAGON__ -D__OSF1__ -D_COFF -Dunix -DMACH -DCMU\"\n+\n+#define CPP_SPEC \"%{mnx:-D__NODE}\"\n+\n+/* autoinit.o autolaunches NX applications */\n+#define STARTFILE_SPEC \"-ycrt0.o%s %{mnx:-yoptions/autoinit.o%s}\"\n+\n+/* libic.a is the PGI intrisic library */\n+/* libpm.o and guard.o are for the performance monitoring modules (ignored) */\n+/* /usr/lib/noieee contains non-IEEE compliant (but faster) math routines */\n+#if\tHAVE_DASH_G\n+#define LIB_SPEC \"%{mnoieee:-L/usr/lib/noieee} -L/usr/lib %{mnx:-lnx -lmach} %\n+{g*:-lg} -lc -lic\"\n+#else\t/* HAVE_DASH_G */\n+/* can't use -g for -lg; libg.a doesn't have a symbol table and ld complains */\n+#define LIB_SPEC \"%{mnoieee:-L/usr/lib/noieee} -L/usr/lib %{mnx:-lnx -lmach} -lc -lic\"\n+#endif\t/* HAVE_DASH_G */\n+\n+\n+#undef\tI860_REG_PREFIX\n+\n+#undef\tASM_COMMENT_START\n+#define ASM_COMMENT_START \"//\"\n+\n+#undef TYPE_OPERAND_FMT\n+#define TYPE_OPERAND_FMT      \"\\\"%s\\\"\"\n+\n+#define DBX_REGISTER_NUMBER(REGNO) (REGNO)\n+\n+#undef ASCII_DATA_ASM_OP\n+#define ASCII_DATA_ASM_OP\t\".byte\"\n+\n+/*\n+ *\tthe assembler we're using doesn't grok .ident...\n+ */\n+#undef\tASM_OUTPUT_IDENT\n+#define ASM_OUTPUT_IDENT(FILE, NAME) \\\n+  fprintf (FILE, \"//\\t.ident \\\"%s\\\"\\n\", NAME);\n+\n+/*\n+ *\tthe assembler doesn't grok .double INF and the like\n+ *\tbut does understand .long with hex numbers, so special\n+ *\tcase the \"symbolic\" IEEE numbers.\n+ */\n+#undef ASM_OUTPUT_DOUBLE\n+#define ASM_OUTPUT_DOUBLE(FILE,VALUE)\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\\\n+    if (REAL_VALUE_ISINF (VALUE)\t\t\t\t\\\n+        || REAL_VALUE_ISNAN (VALUE)\t\t\t\t\\\n+\t|| REAL_VALUE_MINUS_ZERO (VALUE))\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\tlong t[2];\t\t\t\t\t\t\\\n+\tREAL_VALUE_TO_TARGET_DOUBLE ((VALUE), t);\t\t\\\n+\tfprintf (FILE, \"\\t.long 0x%lx\\n\\t.long 0x%lx\\n\", t[0], t[1]); \\\n+      }\t\t\t\t\t\t\t\t\\\n+    else\t\t\t\t\t\t\t\\\n+      fprintf (FILE, \"\\t.double %.20e\\n\", VALUE);\t\t\\\n+  }\n+\n+#undef ASM_OUTPUT_FLOAT\n+#define ASM_OUTPUT_FLOAT(FILE,VALUE)\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\\\n+    if (REAL_VALUE_ISINF (VALUE)\t\t\t\t\\\n+        || REAL_VALUE_ISNAN (VALUE)\t\t\t\t\\\n+\t|| REAL_VALUE_MINUS_ZERO (VALUE))\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\tlong t;\t\t\t\t\t\t\t\\\n+\tREAL_VALUE_TO_TARGET_SINGLE ((VALUE), t);\t\t\\\n+\tfprintf (FILE, \"\\t.long 0x%lx\\n\", t);\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+    else\t\t\t\t\t\t\t\\\n+      fprintf (FILE, \"\\t.float %.12e\\n\", VALUE);\t\t\\\n+  }\n+\n+#undef\tASM_OUTPUT_ASCII\n+#define ASM_OUTPUT_ASCII(FILE, STR, LENGTH)\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      register unsigned char *str = (unsigned char *) (STR);\t\\\n+      register unsigned char *limit = str + (LENGTH);\t\t\\\n+      register unsigned bytes_in_chunk = 0;\t\t\t\\\n+      for (; str < limit; str++)\t\t\t\t\\\n+        {\t\t\t\t\t\t\t\\\n+          register unsigned ch = *str;\t\t\t\t\\\n+          if (ch < 32 || ch == '\\\\' || ch == '\"' || ch >= 127)\t\\\n+\t    {\t\t\t\t\t\t\t\\\n+\t      if (bytes_in_chunk > 0)\t\t\t\t\\\n+\t        {\t\t\t\t\t\t\\\n+\t          fprintf ((FILE), \"\\\"\\n\");\t\t\t\\\n+\t          bytes_in_chunk = 0;\t\t\t\t\\\n+\t        }\t\t\t\t\t\t\\\n+\t      fprintf ((FILE), \"\\t%s\\t%d\\n\", ASM_BYTE_OP, ch);\t\\\n+\t    }\t\t\t\t\t\t\t\\\n+          else\t\t\t\t\t\t\t\\\n+\t    {\t\t\t\t\t\t\t\\\n+\t      if (bytes_in_chunk >= 60)\t\t\t\t\\\n+\t        {\t\t\t\t\t\t\\\n+\t          fprintf ((FILE), \"\\\"\\n\");\t\t\t\\\n+\t          bytes_in_chunk = 0;\t\t\t\t\\\n+\t        }\t\t\t\t\t\t\\\n+\t      if (bytes_in_chunk == 0)\t\t\t\t\\\n+\t        fprintf ((FILE), \"\\t%s\\t\\\"\", ASCII_DATA_ASM_OP);\\\n+\t      putc (ch, (FILE));\t\t\t\t\\\n+\t      bytes_in_chunk++;\t\t\t\t\t\\\n+\t    }\t\t\t\t\t\t\t\\\n+        }\t\t\t\t\t\t\t\\\n+      if (bytes_in_chunk > 0)\t\t\t\t\t\\\n+        fprintf ((FILE), \"\\\"\\n\");\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  while (0)\n+\n+\n+/* This says how to output an assembler line\n+   to define a local common symbol.  */\n+\n+#undef ASM_OUTPUT_LOCAL\n+#define ASM_OUTPUT_LOCAL(FILE, NAME, SIZE, ROUNDED)  \\\n+( fputs (\".lcomm \", (FILE)),\t\t\t\\\n+  assemble_name ((FILE), (NAME)),\t\t\\\n+  fprintf ((FILE), \",%u\\n\", (ROUNDED)))\n+\n+/*\n+ *\tnot defining ASM_STABS_OP yields .stabs in the .s file\n+ *\twhen using g++ -- so, I'll define it.\n+ */\n+#define\tASM_STABS_OP\t\"//.stabs\"\n+\n+/* Define this macro if an argument declared as `char' or `short' in a\n+   prototype should actually be passed as an `int'.  In addition to\n+   avoiding errors in certain cases of mismatch, it also makes for\n+   better code on certain machines. */\n+/*#define PROMOTE_PROTOTYPES*/\n+\n+/* Define this macro if an instruction to load a value narrower\n+   than a word from memory into a register also zero-extends the\n+   value to the whole  register.  */\n+/*#define BYTE_LOADS_ZERO_EXTEND*/\n+\n+/* Define this macro as a C expression which is nonzero if\n+   accessing less than a word of memory (i.e. a `char' or a\n+   `short') is no faster than accessing a word of memory, i.e., if\n+   such access require more than one instruction or if there is no\n+   difference in cost between byte and (aligned) word loads.\n+\n+   On RISC machines, it tends to generate better code to define\n+   this as 1, since it avoids making a QI or HI mode register.  */\n+/*\n+#undef SLOW_BYTE_ACCESS\n+#define SLOW_BYTE_ACCESS 1\n+*/\n+\n+/* Define if shifts truncate the shift count\n+   which implies one can omit a sign-extension or zero-extension\n+   of a shift count. */\n+#define SHIFT_COUNT_TRUNCATED 1\n+\n+\n+#define FASTEST_ALIGNMENT 32\n+\n+/* Make strings word-aligned so strcpy from constants will be faster.  */\n+#define CONSTANT_ALIGNMENT(EXP, ALIGN)  \\\n+  (TREE_CODE (EXP) == STRING_CST\t\\\n+   && (ALIGN) < FASTEST_ALIGNMENT ? FASTEST_ALIGNMENT : (ALIGN))\n+\n+/* Make arrays of chars word-aligned for the same reasons.  */\n+#define DATA_ALIGNMENT(TYPE, ALIGN)\t\t\\\n+  (TREE_CODE (TYPE) == ARRAY_TYPE\t\t\\\n+   && TYPE_MODE (TREE_TYPE (TYPE)) == QImode\t\\\n+   && (ALIGN) < FASTEST_ALIGNMENT ? FASTEST_ALIGNMENT : (ALIGN))\n+\n+/*\n+ *\tdisable a few things picked up from svr3.h\n+ */\n+#undef INIT_SECTION_ASM_OP\n+#undef FINI_SECTION_ASM_OP\n+#undef CONST_SECTION_ASM_OP\n+#undef CTORS_SECTION_ASM_OP\n+#undef DTORS_SECTION_ASM_OP\n+#undef DO_GLOBAL_CTORS_BODY\n+#undef ASM_OUTPUT_DESTRUCTOR\n+#undef SELECT_SECTION\n+#undef SELECT_RTX_SECTION\n+#undef READONLY_DATA_SECTION\n+\n+#define\tBSS_SECTION_ASM_OP\t\".bss\"\t\t/* XXX */\n+#undef EXTRA_SECTIONS\n+#define\tEXTRA_SECTIONS\tin_bss\n+#undef EXTRA_SECTION_FUNCTIONS\n+#define\tEXTRA_SECTION_FUNCTIONS\t\t\\\n+\tBSS_SECTION_FUNCTION"}]}