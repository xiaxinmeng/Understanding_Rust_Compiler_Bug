{"sha": "a5c0f6fe8787df483b1fe914e13bc6576bdd3342", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTVjMGY2ZmU4Nzg3ZGY0ODNiMWZlOTE0ZTEzYmM2NTc2YmRkMzM0Mg==", "commit": {"author": {"name": "Gary Benson", "email": "gbenson@redhat.com", "date": "2007-01-15T10:25:38Z"}, "committer": {"name": "Gary Benson", "email": "gary@gcc.gnu.org", "date": "2007-01-15T10:25:38Z"}, "message": "URLClassLoader.java: Removed.\n\n2007-01-15  Gary Benson  <gbenson@redhat.com>\n\n\t* java/net/URLClassLoader.java: Removed.\n\t* gnu/java/net/loader/Load_gcjlib.java: New file.\n\t* gnu/gcj/runtime/BootClassLoader.java: Ensure core\n\tURL handler is present in static executables.\n\t* sources.am, Makefile.in: Rebuilt.\n\nFrom-SVN: r120791", "tree": {"sha": "4fd1e5d43e9e9e5d5e92941734f010014917598e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4fd1e5d43e9e9e5d5e92941734f010014917598e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a5c0f6fe8787df483b1fe914e13bc6576bdd3342", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5c0f6fe8787df483b1fe914e13bc6576bdd3342", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a5c0f6fe8787df483b1fe914e13bc6576bdd3342", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5c0f6fe8787df483b1fe914e13bc6576bdd3342/comments", "author": null, "committer": null, "parents": [{"sha": "9ebe2d22e7201bca8e75111ec66ccae8454896ae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ebe2d22e7201bca8e75111ec66ccae8454896ae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9ebe2d22e7201bca8e75111ec66ccae8454896ae"}], "stats": {"total": 1683, "additions": 224, "deletions": 1459}, "files": [{"sha": "ad6c1fba4ef3d74a872d4371b0f083246e784273", "filename": "libjava/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5c0f6fe8787df483b1fe914e13bc6576bdd3342/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5c0f6fe8787df483b1fe914e13bc6576bdd3342/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=a5c0f6fe8787df483b1fe914e13bc6576bdd3342", "patch": "@@ -1,3 +1,11 @@\n+2007-01-15  Gary Benson  <gbenson@redhat.com>\n+\n+\t* java/net/URLClassLoader.java: Removed.\n+\t* gnu/java/net/loader/Load_gcjlib.java: New file.\n+\t* gnu/gcj/runtime/BootClassLoader.java: Ensure core\n+\tURL handler is present in static executables.\n+\t* sources.am, Makefile.in: Rebuilt.\n+\n 2007-01-14  H.J. Lu  <hongjiu.lu@intel.com>\n \n \t* Makefile.am (libgcj_la_LDFLAGS): Add"}, {"sha": "e03542934f2b194384197990d353d6a2936f11ff", "filename": "libjava/Makefile.in", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5c0f6fe8787df483b1fe914e13bc6576bdd3342/libjava%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5c0f6fe8787df483b1fe914e13bc6576bdd3342/libjava%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.in?ref=a5c0f6fe8787df483b1fe914e13bc6576bdd3342", "patch": "@@ -1922,6 +1922,7 @@ classpath/gnu/java/net/loader/FileResource.java \\\n classpath/gnu/java/net/loader/FileURLLoader.java \\\n classpath/gnu/java/net/loader/JarURLLoader.java \\\n classpath/gnu/java/net/loader/JarURLResource.java \\\n+gnu/java/net/loader/Load_gcjlib.java \\\n classpath/gnu/java/net/loader/RemoteResource.java \\\n classpath/gnu/java/net/loader/RemoteURLLoader.java \\\n classpath/gnu/java/net/loader/Resource.java \\\n@@ -4402,7 +4403,7 @@ classpath/java/net/SocketTimeoutException.java \\\n classpath/java/net/URI.java \\\n classpath/java/net/URISyntaxException.java \\\n classpath/java/net/URL.java \\\n-java/net/URLClassLoader.java \\\n+classpath/java/net/URLClassLoader.java \\\n classpath/java/net/URLConnection.java \\\n classpath/java/net/URLDecoder.java \\\n classpath/java/net/URLEncoder.java \\"}, {"sha": "857b7a17cbae26fe6ebc9f2d9185e45cd236f5bc", "filename": "libjava/classpath/lib/gnu/gcj/runtime/BootClassLoader.class", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5c0f6fe8787df483b1fe914e13bc6576bdd3342/libjava%2Fclasspath%2Flib%2Fgnu%2Fgcj%2Fruntime%2FBootClassLoader.class", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5c0f6fe8787df483b1fe914e13bc6576bdd3342/libjava%2Fclasspath%2Flib%2Fgnu%2Fgcj%2Fruntime%2FBootClassLoader.class", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Flib%2Fgnu%2Fgcj%2Fruntime%2FBootClassLoader.class?ref=a5c0f6fe8787df483b1fe914e13bc6576bdd3342"}, {"sha": "86c42ea8020e2017c4b286c1279b730e4479ac97", "filename": "libjava/classpath/lib/gnu/java/net/loader/Load_gcjlib$SoResource.class", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5c0f6fe8787df483b1fe914e13bc6576bdd3342/libjava%2Fclasspath%2Flib%2Fgnu%2Fjava%2Fnet%2Floader%2FLoad_gcjlib%24SoResource.class", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5c0f6fe8787df483b1fe914e13bc6576bdd3342/libjava%2Fclasspath%2Flib%2Fgnu%2Fjava%2Fnet%2Floader%2FLoad_gcjlib%24SoResource.class", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Flib%2Fgnu%2Fjava%2Fnet%2Floader%2FLoad_gcjlib%24SoResource.class?ref=a5c0f6fe8787df483b1fe914e13bc6576bdd3342"}, {"sha": "3293b2e59e7c578a976c1a50f872f709a356f18e", "filename": "libjava/classpath/lib/gnu/java/net/loader/Load_gcjlib.class", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5c0f6fe8787df483b1fe914e13bc6576bdd3342/libjava%2Fclasspath%2Flib%2Fgnu%2Fjava%2Fnet%2Floader%2FLoad_gcjlib.class", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5c0f6fe8787df483b1fe914e13bc6576bdd3342/libjava%2Fclasspath%2Flib%2Fgnu%2Fjava%2Fnet%2Floader%2FLoad_gcjlib.class", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Flib%2Fgnu%2Fjava%2Fnet%2Floader%2FLoad_gcjlib.class?ref=a5c0f6fe8787df483b1fe914e13bc6576bdd3342"}, {"sha": "762625a3c7a4ee79560032d80f91af0b47e5701a", "filename": "libjava/classpath/lib/java/net/URLClassLoader$1.class", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5c0f6fe8787df483b1fe914e13bc6576bdd3342/libjava%2Fclasspath%2Flib%2Fjava%2Fnet%2FURLClassLoader%241.class", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5c0f6fe8787df483b1fe914e13bc6576bdd3342/libjava%2Fclasspath%2Flib%2Fjava%2Fnet%2FURLClassLoader%241.class", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Flib%2Fjava%2Fnet%2FURLClassLoader%241.class?ref=a5c0f6fe8787df483b1fe914e13bc6576bdd3342"}, {"sha": "741aa3bf03ffe0692c4c8625f7e1df044691fb13", "filename": "libjava/classpath/lib/java/net/URLClassLoader$2.class", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5c0f6fe8787df483b1fe914e13bc6576bdd3342/libjava%2Fclasspath%2Flib%2Fjava%2Fnet%2FURLClassLoader%242.class", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5c0f6fe8787df483b1fe914e13bc6576bdd3342/libjava%2Fclasspath%2Flib%2Fjava%2Fnet%2FURLClassLoader%242.class", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Flib%2Fjava%2Fnet%2FURLClassLoader%242.class?ref=a5c0f6fe8787df483b1fe914e13bc6576bdd3342"}, {"sha": "f37294203816396a639c8c2f7fd6b5660afcaf1b", "filename": "libjava/classpath/lib/java/net/URLClassLoader$CoreResource.class", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ebe2d22e7201bca8e75111ec66ccae8454896ae/libjava%2Fclasspath%2Flib%2Fjava%2Fnet%2FURLClassLoader%24CoreResource.class", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ebe2d22e7201bca8e75111ec66ccae8454896ae/libjava%2Fclasspath%2Flib%2Fjava%2Fnet%2FURLClassLoader%24CoreResource.class", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Flib%2Fjava%2Fnet%2FURLClassLoader%24CoreResource.class?ref=9ebe2d22e7201bca8e75111ec66ccae8454896ae"}, {"sha": "050f529734c058f06e8ccac681ce9cf564474568", "filename": "libjava/classpath/lib/java/net/URLClassLoader$CoreURLLoader.class", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ebe2d22e7201bca8e75111ec66ccae8454896ae/libjava%2Fclasspath%2Flib%2Fjava%2Fnet%2FURLClassLoader%24CoreURLLoader.class", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ebe2d22e7201bca8e75111ec66ccae8454896ae/libjava%2Fclasspath%2Flib%2Fjava%2Fnet%2FURLClassLoader%24CoreURLLoader.class", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Flib%2Fjava%2Fnet%2FURLClassLoader%24CoreURLLoader.class?ref=9ebe2d22e7201bca8e75111ec66ccae8454896ae"}, {"sha": "e7a12687ef3ace5bc33cd42ce722aca8e5189210", "filename": "libjava/classpath/lib/java/net/URLClassLoader$FileResource.class", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ebe2d22e7201bca8e75111ec66ccae8454896ae/libjava%2Fclasspath%2Flib%2Fjava%2Fnet%2FURLClassLoader%24FileResource.class", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ebe2d22e7201bca8e75111ec66ccae8454896ae/libjava%2Fclasspath%2Flib%2Fjava%2Fnet%2FURLClassLoader%24FileResource.class", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Flib%2Fjava%2Fnet%2FURLClassLoader%24FileResource.class?ref=9ebe2d22e7201bca8e75111ec66ccae8454896ae"}, {"sha": "d750821a99e68f363b88448ffa4f5d12f5db51e5", "filename": "libjava/classpath/lib/java/net/URLClassLoader$FileURLLoader.class", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ebe2d22e7201bca8e75111ec66ccae8454896ae/libjava%2Fclasspath%2Flib%2Fjava%2Fnet%2FURLClassLoader%24FileURLLoader.class", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ebe2d22e7201bca8e75111ec66ccae8454896ae/libjava%2Fclasspath%2Flib%2Fjava%2Fnet%2FURLClassLoader%24FileURLLoader.class", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Flib%2Fjava%2Fnet%2FURLClassLoader%24FileURLLoader.class?ref=9ebe2d22e7201bca8e75111ec66ccae8454896ae"}, {"sha": "11c1e9dc61ad6a38e1a3b63e0f8b4aad06d836dd", "filename": "libjava/classpath/lib/java/net/URLClassLoader$JarURLLoader.class", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ebe2d22e7201bca8e75111ec66ccae8454896ae/libjava%2Fclasspath%2Flib%2Fjava%2Fnet%2FURLClassLoader%24JarURLLoader.class", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ebe2d22e7201bca8e75111ec66ccae8454896ae/libjava%2Fclasspath%2Flib%2Fjava%2Fnet%2FURLClassLoader%24JarURLLoader.class", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Flib%2Fjava%2Fnet%2FURLClassLoader%24JarURLLoader.class?ref=9ebe2d22e7201bca8e75111ec66ccae8454896ae"}, {"sha": "74ebc39810169e5085ce183bcda9a30250221746", "filename": "libjava/classpath/lib/java/net/URLClassLoader$JarURLResource.class", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ebe2d22e7201bca8e75111ec66ccae8454896ae/libjava%2Fclasspath%2Flib%2Fjava%2Fnet%2FURLClassLoader%24JarURLResource.class", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ebe2d22e7201bca8e75111ec66ccae8454896ae/libjava%2Fclasspath%2Flib%2Fjava%2Fnet%2FURLClassLoader%24JarURLResource.class", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Flib%2Fjava%2Fnet%2FURLClassLoader%24JarURLResource.class?ref=9ebe2d22e7201bca8e75111ec66ccae8454896ae"}, {"sha": "19b703190ee1b31646e64629a2529090fe437492", "filename": "libjava/classpath/lib/java/net/URLClassLoader$RemoteResource.class", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ebe2d22e7201bca8e75111ec66ccae8454896ae/libjava%2Fclasspath%2Flib%2Fjava%2Fnet%2FURLClassLoader%24RemoteResource.class", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ebe2d22e7201bca8e75111ec66ccae8454896ae/libjava%2Fclasspath%2Flib%2Fjava%2Fnet%2FURLClassLoader%24RemoteResource.class", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Flib%2Fjava%2Fnet%2FURLClassLoader%24RemoteResource.class?ref=9ebe2d22e7201bca8e75111ec66ccae8454896ae"}, {"sha": "d32ac11656c6789416c63a24f19fa03a89744ba9", "filename": "libjava/classpath/lib/java/net/URLClassLoader$RemoteURLLoader.class", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ebe2d22e7201bca8e75111ec66ccae8454896ae/libjava%2Fclasspath%2Flib%2Fjava%2Fnet%2FURLClassLoader%24RemoteURLLoader.class", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ebe2d22e7201bca8e75111ec66ccae8454896ae/libjava%2Fclasspath%2Flib%2Fjava%2Fnet%2FURLClassLoader%24RemoteURLLoader.class", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Flib%2Fjava%2Fnet%2FURLClassLoader%24RemoteURLLoader.class?ref=9ebe2d22e7201bca8e75111ec66ccae8454896ae"}, {"sha": "bb4d13a6ba0a72e9ef51b3a99bc7dd0e3170d131", "filename": "libjava/classpath/lib/java/net/URLClassLoader$Resource.class", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ebe2d22e7201bca8e75111ec66ccae8454896ae/libjava%2Fclasspath%2Flib%2Fjava%2Fnet%2FURLClassLoader%24Resource.class", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ebe2d22e7201bca8e75111ec66ccae8454896ae/libjava%2Fclasspath%2Flib%2Fjava%2Fnet%2FURLClassLoader%24Resource.class", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Flib%2Fjava%2Fnet%2FURLClassLoader%24Resource.class?ref=9ebe2d22e7201bca8e75111ec66ccae8454896ae"}, {"sha": "4e7417a7d6328318c4fd85785fd9bfef2c8e0e64", "filename": "libjava/classpath/lib/java/net/URLClassLoader$SoResource.class", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ebe2d22e7201bca8e75111ec66ccae8454896ae/libjava%2Fclasspath%2Flib%2Fjava%2Fnet%2FURLClassLoader%24SoResource.class", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ebe2d22e7201bca8e75111ec66ccae8454896ae/libjava%2Fclasspath%2Flib%2Fjava%2Fnet%2FURLClassLoader%24SoResource.class", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Flib%2Fjava%2Fnet%2FURLClassLoader%24SoResource.class?ref=9ebe2d22e7201bca8e75111ec66ccae8454896ae"}, {"sha": "403dfafd09cf61f3724c31cee279f35a00db67e4", "filename": "libjava/classpath/lib/java/net/URLClassLoader$SoURLLoader.class", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ebe2d22e7201bca8e75111ec66ccae8454896ae/libjava%2Fclasspath%2Flib%2Fjava%2Fnet%2FURLClassLoader%24SoURLLoader.class", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ebe2d22e7201bca8e75111ec66ccae8454896ae/libjava%2Fclasspath%2Flib%2Fjava%2Fnet%2FURLClassLoader%24SoURLLoader.class", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Flib%2Fjava%2Fnet%2FURLClassLoader%24SoURLLoader.class?ref=9ebe2d22e7201bca8e75111ec66ccae8454896ae"}, {"sha": "8b272bdb36db93f3e4839605d8c5f2ffc5439748", "filename": "libjava/classpath/lib/java/net/URLClassLoader$URLLoader.class", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ebe2d22e7201bca8e75111ec66ccae8454896ae/libjava%2Fclasspath%2Flib%2Fjava%2Fnet%2FURLClassLoader%24URLLoader.class", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ebe2d22e7201bca8e75111ec66ccae8454896ae/libjava%2Fclasspath%2Flib%2Fjava%2Fnet%2FURLClassLoader%24URLLoader.class", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Flib%2Fjava%2Fnet%2FURLClassLoader%24URLLoader.class?ref=9ebe2d22e7201bca8e75111ec66ccae8454896ae"}, {"sha": "ceb736bdc91f43d320a3cb4beec1c882abdf0dcb", "filename": "libjava/classpath/lib/java/net/URLClassLoader.class", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5c0f6fe8787df483b1fe914e13bc6576bdd3342/libjava%2Fclasspath%2Flib%2Fjava%2Fnet%2FURLClassLoader.class", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5c0f6fe8787df483b1fe914e13bc6576bdd3342/libjava%2Fclasspath%2Flib%2Fjava%2Fnet%2FURLClassLoader.class", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Flib%2Fjava%2Fnet%2FURLClassLoader.class?ref=a5c0f6fe8787df483b1fe914e13bc6576bdd3342"}, {"sha": "df9fcdbe43bb2cfce374b8f913eb221c34c991fb", "filename": "libjava/gnu/gcj/runtime/BootClassLoader.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5c0f6fe8787df483b1fe914e13bc6576bdd3342/libjava%2Fgnu%2Fgcj%2Fruntime%2FBootClassLoader.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5c0f6fe8787df483b1fe914e13bc6576bdd3342/libjava%2Fgnu%2Fgcj%2Fruntime%2FBootClassLoader.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Fruntime%2FBootClassLoader.h?ref=a5c0f6fe8787df483b1fe914e13bc6576bdd3342", "patch": "@@ -37,6 +37,9 @@ class gnu::gcj::runtime::BootClassLoader : public ::gnu::gcj::runtime::HelperCla\n   ::java::lang::Class * bootLoadClass(::java::lang::String *);\n   ::java::net::URL * bootGetResource(::java::lang::String *);\n   ::java::util::Enumeration * bootGetResources(::java::lang::String *);\n+public: // actually package-private\n+  static ::java::lang::Class * coreHandler;\n+public:\n   static ::java::lang::Class class$;\n };\n "}, {"sha": "731703ab8f34467a8ba588ae754d3ee05bfda8c6", "filename": "libjava/gnu/gcj/runtime/BootClassLoader.java", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5c0f6fe8787df483b1fe914e13bc6576bdd3342/libjava%2Fgnu%2Fgcj%2Fruntime%2FBootClassLoader.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5c0f6fe8787df483b1fe914e13bc6576bdd3342/libjava%2Fgnu%2Fgcj%2Fruntime%2FBootClassLoader.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Fruntime%2FBootClassLoader.java?ref=a5c0f6fe8787df483b1fe914e13bc6576bdd3342", "patch": "@@ -1,4 +1,4 @@\n-/* Copyright (C) 2005  Free Software Foundation\n+/* Copyright (C) 2005, 2007  Free Software Foundation\n \n    This file is part of libgcj.\n \n@@ -8,6 +8,7 @@\n \n package gnu.gcj.runtime;\n \n+import gnu.java.net.protocol.core.Handler;\n import java.io.IOException;\n import java.net.URL;\n import java.util.Enumeration;\n@@ -21,6 +22,11 @@\n  */\n public final class BootClassLoader extends HelperClassLoader\n {\n+  // This forces the core URL handler to be included in statically\n+  // linked executables.  The line that adds core:/ to the search\n+  // path fails otherwise.\n+  static Class coreHandler = gnu.java.net.protocol.core.Handler.class;\n+\n   BootClassLoader(String libdir)\n   {\n     // The BootClassLoader is the top of the delegation chain. It does not"}, {"sha": "da8a2aca194a7d9110862627ae05d6ccc5b44263", "filename": "libjava/gnu/java/net/loader/Load_gcjlib$SoResource.h", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5c0f6fe8787df483b1fe914e13bc6576bdd3342/libjava%2Fgnu%2Fjava%2Fnet%2Floader%2FLoad_gcjlib%24SoResource.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5c0f6fe8787df483b1fe914e13bc6576bdd3342/libjava%2Fgnu%2Fjava%2Fnet%2Floader%2FLoad_gcjlib%24SoResource.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnet%2Floader%2FLoad_gcjlib%24SoResource.h?ref=a5c0f6fe8787df483b1fe914e13bc6576bdd3342", "patch": "@@ -0,0 +1,50 @@\n+\n+// DO NOT EDIT THIS FILE - it is machine generated -*- c++ -*-\n+\n+#ifndef __gnu_java_net_loader_Load_gcjlib$SoResource__\n+#define __gnu_java_net_loader_Load_gcjlib$SoResource__\n+\n+#pragma interface\n+\n+#include <gnu/java/net/loader/Resource.h>\n+extern \"Java\"\n+{\n+  namespace gnu\n+  {\n+    namespace java\n+    {\n+      namespace net\n+      {\n+        namespace loader\n+        {\n+            class Load_gcjlib;\n+            class Load_gcjlib$SoResource;\n+        }\n+      }\n+    }\n+  }\n+  namespace java\n+  {\n+    namespace net\n+    {\n+        class URL;\n+    }\n+  }\n+}\n+\n+class gnu::java::net::loader::Load_gcjlib$SoResource : public ::gnu::java::net::loader::Resource\n+{\n+\n+public: // actually package-private\n+  Load_gcjlib$SoResource(::gnu::java::net::loader::Load_gcjlib *, ::java::net::URL *);\n+public:\n+  ::java::io::InputStream * getInputStream();\n+  jint getLength();\n+  ::java::net::URL * getURL();\n+private:\n+  ::java::net::URL * __attribute__((aligned(__alignof__( ::gnu::java::net::loader::Resource)))) url;\n+public:\n+  static ::java::lang::Class class$;\n+};\n+\n+#endif // __gnu_java_net_loader_Load_gcjlib$SoResource__"}, {"sha": "69d2ef5ac6f5ddde636b8acd87fb97526b89c09b", "filename": "libjava/gnu/java/net/loader/Load_gcjlib.h", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5c0f6fe8787df483b1fe914e13bc6576bdd3342/libjava%2Fgnu%2Fjava%2Fnet%2Floader%2FLoad_gcjlib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5c0f6fe8787df483b1fe914e13bc6576bdd3342/libjava%2Fgnu%2Fjava%2Fnet%2Floader%2FLoad_gcjlib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnet%2Floader%2FLoad_gcjlib.h?ref=a5c0f6fe8787df483b1fe914e13bc6576bdd3342", "patch": "@@ -0,0 +1,58 @@\n+\n+// DO NOT EDIT THIS FILE - it is machine generated -*- c++ -*-\n+\n+#ifndef __gnu_java_net_loader_Load_gcjlib__\n+#define __gnu_java_net_loader_Load_gcjlib__\n+\n+#pragma interface\n+\n+#include <gnu/java/net/loader/URLLoader.h>\n+extern \"Java\"\n+{\n+  namespace gnu\n+  {\n+    namespace gcj\n+    {\n+      namespace runtime\n+      {\n+          class SharedLibHelper;\n+      }\n+    }\n+    namespace java\n+    {\n+      namespace net\n+      {\n+        namespace loader\n+        {\n+            class Load_gcjlib;\n+            class Resource;\n+            class URLStreamHandlerCache;\n+        }\n+      }\n+    }\n+  }\n+  namespace java\n+  {\n+    namespace net\n+    {\n+        class URL;\n+        class URLClassLoader;\n+        class URLStreamHandlerFactory;\n+    }\n+  }\n+}\n+\n+class gnu::java::net::loader::Load_gcjlib : public ::gnu::java::net::loader::URLLoader\n+{\n+\n+public:\n+  Load_gcjlib(::java::net::URLClassLoader *, ::gnu::java::net::loader::URLStreamHandlerCache *, ::java::net::URLStreamHandlerFactory *, ::java::net::URL *, ::java::net::URL *);\n+  ::java::lang::Class * getClass(::java::lang::String *);\n+  ::gnu::java::net::loader::Resource * getResource(::java::lang::String *);\n+private:\n+  ::gnu::gcj::runtime::SharedLibHelper * __attribute__((aligned(__alignof__( ::gnu::java::net::loader::URLLoader)))) helper;\n+public:\n+  static ::java::lang::Class class$;\n+};\n+\n+#endif // __gnu_java_net_loader_Load_gcjlib__"}, {"sha": "ea392041f91f35b08cb9acdafeeb61cebd375e5b", "filename": "libjava/gnu/java/net/loader/Load_gcjlib.java", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5c0f6fe8787df483b1fe914e13bc6576bdd3342/libjava%2Fgnu%2Fjava%2Fnet%2Floader%2FLoad_gcjlib.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5c0f6fe8787df483b1fe914e13bc6576bdd3342/libjava%2Fgnu%2Fjava%2Fnet%2Floader%2FLoad_gcjlib.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnet%2Floader%2FLoad_gcjlib.java?ref=a5c0f6fe8787df483b1fe914e13bc6576bdd3342", "patch": "@@ -0,0 +1,77 @@\n+/* Copyright (C) 2007  Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package gnu.java.net.loader;\n+\n+import gnu.gcj.runtime.SharedLibHelper;\n+import java.io.InputStream;\n+import java.io.IOException;\n+import java.net.URL;\n+import java.net.URLClassLoader;\n+import java.net.URLConnection;\n+import java.net.URLStreamHandlerFactory;\n+\n+/**\n+ * A <code>Load_gcjlib</code> is a type of <code>URLLoader</code>\n+ * that loads classes and resources from a shared library.\n+ */\n+public final class Load_gcjlib extends URLLoader\n+{\n+  private SharedLibHelper helper;\n+\n+  public Load_gcjlib(URLClassLoader classloader,\n+\t\t     URLStreamHandlerCache cache,\n+\t\t     URLStreamHandlerFactory factory,\n+\t\t     URL url, URL absoluteUrl)\n+  {\n+    super(classloader, cache, factory, url, absoluteUrl);\n+    helper = SharedLibHelper.findHelper(classloader, url.getFile(),\n+\t\t\t\t\tnoCertCodeSource, true);\n+  }\n+\n+  public Class getClass(String className)\n+  {\n+    return helper.findClass(className);\n+  }\n+\n+  public Resource getResource(String name)\n+  {\n+    URL url = helper.findResource(name);\n+    if (url == null)\n+      return null;\n+    return new SoResource(this, url);\n+  }\n+\n+  final static class SoResource extends Resource\n+  {\n+    private final URL url;\n+\n+    SoResource(Load_gcjlib loader, URL url)\n+    {\n+      super(loader);\n+      this.url = url;\n+    }\n+\n+    public InputStream getInputStream() throws IOException\n+    {\n+      URLConnection conn = url.openConnection();\n+      return conn.getInputStream();\n+    }\n+\n+    public int getLength()\n+    {\n+      // FIXME we could find this by asking the core object.\n+      return -1;\n+    }\n+\n+    public URL getURL ()\n+    {\n+      return url;\n+    }\n+  }\n+}"}, {"sha": "2e5f15c9bdadc508328fd316df485f564d0c9604", "filename": "libjava/java/net/URLClassLoader.h", "status": "modified", "additions": 17, "deletions": 8, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5c0f6fe8787df483b1fe914e13bc6576bdd3342/libjava%2Fjava%2Fnet%2FURLClassLoader.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5c0f6fe8787df483b1fe914e13bc6576bdd3342/libjava%2Fjava%2Fnet%2FURLClassLoader.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FURLClassLoader.h?ref=a5c0f6fe8787df483b1fe914e13bc6576bdd3342", "patch": "@@ -11,14 +11,26 @@\n \n extern \"Java\"\n {\n+  namespace gnu\n+  {\n+    namespace java\n+    {\n+      namespace net\n+      {\n+        namespace loader\n+        {\n+            class Resource;\n+            class URLStreamHandlerCache;\n+        }\n+      }\n+    }\n+  }\n   namespace java\n   {\n     namespace net\n     {\n         class URL;\n         class URLClassLoader;\n-        class URLClassLoader$Resource;\n-        class URLStreamHandler;\n         class URLStreamHandlerFactory;\n     }\n     namespace security\n@@ -52,12 +64,9 @@ class java::net::URLClassLoader : public ::java::security::SecureClassLoader\n public:\n   virtual ::java::lang::String * toString();\n private:\n-  ::java::net::URLClassLoader$Resource * findURLResource(::java::lang::String *);\n+  ::gnu::java::net::loader::Resource * findURLResource(::java::lang::String *);\n public:\n   virtual ::java::net::URL * findResource(::java::lang::String *);\n-public: // actually package-private\n-  virtual ::java::net::URLStreamHandler * getURLStreamHandler(::java::lang::String *);\n-public:\n   virtual ::java::util::Enumeration * findResources(::java::lang::String *);\n public: // actually protected\n   virtual ::java::security::PermissionCollection * getPermissions(::java::security::CodeSource *);\n@@ -68,8 +77,8 @@ class java::net::URLClassLoader : public ::java::security::SecureClassLoader\n public: // actually package-private\n   static ::java::lang::Class * access$0(::java::net::URLClassLoader *, ::java::lang::String *, JArray< jbyte > *, jint, jint, ::java::security::CodeSource *);\n private:\n-  static ::java::util::HashMap * urlloaders;\n-  static ::java::util::HashMap * factoryCache;\n+  static ::gnu::java::net::loader::URLStreamHandlerCache * factoryCache;\n+  static ::java::lang::String * URL_LOADER_PREFIX;\n   ::java::util::Vector * __attribute__((aligned(__alignof__( ::java::security::SecureClassLoader)))) urls;\n   ::java::util::Vector * urlinfos;\n   ::java::net::URLStreamHandlerFactory * factory;"}, {"sha": "fd70fdf2045a8dcbcb157d344cbb6e787933480d", "filename": "libjava/java/net/URLClassLoader.java", "status": "removed", "additions": 0, "deletions": 1448, "changes": 1448, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ebe2d22e7201bca8e75111ec66ccae8454896ae/libjava%2Fjava%2Fnet%2FURLClassLoader.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ebe2d22e7201bca8e75111ec66ccae8454896ae/libjava%2Fjava%2Fnet%2FURLClassLoader.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FURLClassLoader.java?ref=9ebe2d22e7201bca8e75111ec66ccae8454896ae", "patch": "@@ -1,1448 +0,0 @@\n-/* URLClassLoader.java --  ClassLoader that loads classes from one or more URLs\n-   Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006\n-   Free Software Foundation, Inc.\n-\n-This file is part of GNU Classpath.\n-\n-GNU Classpath is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU Classpath is distributed in the hope that it will be useful, but\n-WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU Classpath; see the file COPYING.  If not, write to the\n-Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n-02110-1301 USA.\n-\n-Linking this library statically or dynamically with other modules is\n-making a combined work based on this library.  Thus, the terms and\n-conditions of the GNU General Public License cover the whole\n-combination.\n-\n-As a special exception, the copyright holders of this library give you\n-permission to link this library with independent modules to produce an\n-executable, regardless of the license terms of these independent\n-modules, and to copy and distribute the resulting executable under\n-terms of your choice, provided that you also meet, for each linked\n-independent module, the terms and conditions of the license of that\n-module.  An independent module is a module which is not derived from\n-or based on this library.  If you modify this library, you may extend\n-this exception to your version of the library, but you are not\n-obligated to do so.  If you do not wish to do so, delete this\n-exception statement from your version. */\n-\n-\n-package java.net;\n-\n-import java.io.ByteArrayOutputStream;\n-import java.io.EOFException;\n-import java.io.File;\n-import java.io.FileInputStream;\n-import java.io.FilePermission;\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.security.AccessControlContext;\n-import java.security.AccessController;\n-import java.security.CodeSource;\n-import java.security.PermissionCollection;\n-import java.security.PrivilegedAction;\n-import java.security.SecureClassLoader;\n-import java.security.cert.Certificate;\n-import java.util.Enumeration;\n-import java.util.HashMap;\n-import java.util.Iterator;\n-import java.util.StringTokenizer;\n-import java.util.Vector;\n-import java.util.jar.Attributes;\n-import java.util.jar.JarEntry;\n-import java.util.jar.JarFile;\n-import java.util.jar.Manifest;\n-import gnu.gcj.runtime.SharedLibHelper;\n-import gnu.gcj.Core;\n-import gnu.java.net.protocol.core.CoreInputStream;\n-\n-/**\n- * A secure class loader that can load classes and resources from\n- * multiple locations.  Given an array of <code>URL</code>s this class\n- * loader will retrieve classes and resources by fetching them from\n- * possible remote locations.  Each <code>URL</code> is searched in\n- * order in which it was added.  If the file portion of the\n- * <code>URL</code> ends with a '/' character then it is interpreted\n- * as a base directory, otherwise it is interpreted as a jar file from\n- * which the classes/resources are resolved.\n- *\n- * <p>New instances can be created by two static\n- * <code>newInstance()</code> methods or by three public\n- * contructors. Both ways give the option to supply an initial array\n- * of <code>URL</code>s and (optionally) a parent classloader (that is\n- * different from the standard system class loader).</p>\n- *\n- * <p>Normally creating a <code>URLClassLoader</code> throws a\n- * <code>SecurityException</code> if a <code>SecurityManager</code> is\n- * installed and the <code>checkCreateClassLoader()</code> method does\n- * not return true.  But the <code>newInstance()</code> methods may be\n- * used by any code as long as it has permission to acces the given\n- * <code>URL</code>s.  <code>URLClassLoaders</code> created by the\n- * <code>newInstance()</code> methods also explicitly call the\n- * <code>checkPackageAccess()</code> method of\n- * <code>SecurityManager</code> if one is installed before trying to\n- * load a class.  Note that only subclasses of\n- * <code>URLClassLoader</code> can add new URLs after the\n- * URLClassLoader had been created. But it is always possible to get\n- * an array of all URLs that the class loader uses to resolve classes\n- * and resources by way of the <code>getURLs()</code> method.</p>\n- *\n- * <p>Open issues:\n- * <ul>\n- *\n- * <li>Should the URLClassLoader actually add the locations found in\n- * the manifest or is this the responsibility of some other\n- * loader/(sub)class?  (see <a\n- * href=\"http://java.sun.com/products/jdk/1.4/docs/guide/extensions/spec.html\">\n- * Extension Mechanism Architecture - Bundles Extensions</a>)</li>\n- *\n- * <li>How does <code>definePackage()</code> and sealing work\n- * precisely?</li>\n- *\n- * <li>We save and use the security context (when a created by\n- * <code>newInstance()</code> but do we have to use it in more\n- * places?</li>\n- *\n- * <li>The use of <code>URLStreamHandler</code>s has not been tested.</li>\n- *\n- * </ul>\n- * </p>\n- *\n- * @since 1.2\n- *\n- * @author Mark Wielaard (mark@klomp.org)\n- * @author Wu Gansha (gansha.wu@intel.com)\n- */\n-public class URLClassLoader extends SecureClassLoader\n-{\n-  // Class Variables\n-\n-  /**\n-   * A global cache to store mappings between URLLoader and URL,\n-   * so we can avoid do all the homework each time the same URL\n-   * comes.\n-   * XXX - Keeps these loaders forever which prevents garbage collection.\n-   */\n-  private static HashMap urlloaders = new HashMap();\n-\n-  /**\n-   * A cache to store mappings between handler factory and its\n-   * private protocol handler cache (also a HashMap), so we can avoid\n-   * create handlers each time the same protocol comes.\n-   */\n-  private static HashMap factoryCache = new HashMap(5);\n-\n-  // Instance variables\n-\n-  /** Locations to load classes from */\n-  private final Vector urls = new Vector();\n-\n-  /**\n-   * Store pre-parsed information for each url into this vector: each\n-   * element is a URL loader.  A jar file has its own class-path\n-   * attribute which adds to the URLs that will be searched, but this\n-   * does not add to the list of urls.\n-   */\n-  private final Vector urlinfos = new Vector();\n-\n-  /** Factory used to get the protocol handlers of the URLs */\n-  private final URLStreamHandlerFactory factory;\n-\n-  /**\n-   * The security context when created from <code>newInstance()</code>\n-   * or null when created through a normal constructor or when no\n-   * <code>SecurityManager</code> was installed.\n-   */\n-  private final AccessControlContext securityContext;\n-\n-  // Helper classes\n-\n-  /**\n-   * A <code>URLLoader</code> contains all logic to load resources from a\n-   * given base <code>URL</code>.\n-   */\n-  abstract static class URLLoader\n-  {\n-    /**\n-     * Our classloader to get info from if needed.\n-     */\n-    final URLClassLoader classloader;\n-\n-    /**\n-     * The base URL from which all resources are loaded.\n-     */\n-    final URL baseURL;\n-\n-    /**\n-     * A <code>CodeSource</code> without any associated certificates.\n-     * It is common for classes to not have certificates associated\n-     * with them.  If they come from the same <code>URLLoader</code>\n-     * then it is safe to share the associated <code>CodeSource</code>\n-     * between them since <code>CodeSource</code> is immutable.\n-     */\n-    final CodeSource noCertCodeSource;\n-\n-    URLLoader(URLClassLoader classloader, URL baseURL)\n-    {\n-      this(classloader, baseURL, baseURL);\n-    }\n-\n-    URLLoader(URLClassLoader classloader, URL baseURL, URL overrideURL)\n-    {\n-      this.classloader = classloader;\n-      this.baseURL = baseURL;\n-      this.noCertCodeSource = new CodeSource(overrideURL, null);\n-    }\n-\n-    /**\n-     * Returns a <code>Class</code> loaded by this\n-     * <code>URLLoader</code>, or <code>null</code> when this loader\n-     * either can't load the class or doesn't know how to load classes\n-     * at all.\n-     */\n-    Class getClass(String className)\n-    {\n-      return null;\n-    }\n-\n-    /**\n-     * Returns a <code>Resource</code> loaded by this\n-     * <code>URLLoader</code>, or <code>null</code> when no\n-     * <code>Resource</code> with the given name exists.\n-     */\n-    abstract Resource getResource(String s);\n-\n-    /**\n-     * Returns the <code>Manifest</code> associated with the\n-     * <code>Resource</code>s loaded by this <code>URLLoader</code> or\n-     * <code>null</code> there is no such <code>Manifest</code>.\n-     */\n-    Manifest getManifest()\n-    {\n-      return null;\n-    }\n-\n-    Vector getClassPath()\n-    {\n-      return null;\n-    }\n-  }\n-\n-  /**\n-   * A <code>Resource</code> represents a resource in some\n-   * <code>URLLoader</code>. It also contains all information (e.g.,\n-   * <code>URL</code>, <code>CodeSource</code>, <code>Manifest</code> and\n-   * <code>InputStream</code>) that is necessary for loading resources\n-   * and creating classes from a <code>URL</code>.\n-   */\n-  abstract static class Resource\n-  {\n-    final URLLoader loader;\n-\n-    Resource(URLLoader loader)\n-    {\n-      this.loader = loader;\n-    }\n-\n-    /**\n-     * Returns the non-null <code>CodeSource</code> associated with\n-     * this resource.\n-     */\n-    CodeSource getCodeSource()\n-    {\n-      Certificate[] certs = getCertificates();\n-      if (certs == null)\n-        return loader.noCertCodeSource;\n-      else\n-        return new CodeSource(loader.baseURL, certs);\n-    }\n-\n-    /**\n-     * Returns <code>Certificates</code> associated with this\n-     * resource, or null when there are none.\n-     */\n-    Certificate[] getCertificates()\n-    {\n-      return null;\n-    }\n-\n-    /**\n-     * Return a <code>URL</code> that can be used to access this resource.\n-     */\n-    abstract URL getURL();\n-\n-    /**\n-     * Returns the size of this <code>Resource</code> in bytes or\n-     * <code>-1</code> when unknown.\n-     */\n-    abstract int getLength();\n-\n-    /**\n-     * Returns the non-null <code>InputStream</code> through which\n-     * this resource can be loaded.\n-     */\n-    abstract InputStream getInputStream() throws IOException;\n-  }\n-\n-  /**\n-   * A <code>JarURLLoader</code> is a type of <code>URLLoader</code>\n-   * only loading from jar url.\n-   */\n-  static final class JarURLLoader extends URLLoader\n-  {\n-    final JarFile jarfile; // The jar file for this url\n-    final URL baseJarURL; // Base jar: url for all resources loaded from jar\n-\n-    Vector classPath;\t// The \"Class-Path\" attribute of this Jar's manifest\n-\n-    public JarURLLoader(URLClassLoader classloader, URL baseURL,\n-\t\t\tURL absoluteUrl)\n-    {\n-      super(classloader, baseURL, absoluteUrl);\n-\n-      // Cache url prefix for all resources in this jar url.\n-      String external = baseURL.toExternalForm();\n-      StringBuffer sb = new StringBuffer(external.length() + 6);\n-      sb.append(\"jar:\");\n-      sb.append(external);\n-      sb.append(\"!/\");\n-      String jarURL = sb.toString();\n-\n-      this.classPath = null;\n-      URL baseJarURL = null;\n-      JarFile jarfile = null;\n-      try\n-\t{\n-\t  baseJarURL =\n-\t    new URL(null, jarURL, classloader.getURLStreamHandler(\"jar\"));\n-\t  \n-\t  jarfile =\n-\t    ((JarURLConnection) baseJarURL.openConnection()).getJarFile();\n-\t  \n-\t  Manifest manifest;\n-\t  Attributes attributes;\n-\t  String classPathString;\n-\n-\t  if ((manifest = jarfile.getManifest()) != null\n-\t      && (attributes = manifest.getMainAttributes()) != null\n-\t      && ((classPathString \n-\t\t   = attributes.getValue(Attributes.Name.CLASS_PATH)) \n-\t\t  != null))\n-\t    {\n-\t      this.classPath = new Vector();\n-\t      \n-\t      StringTokenizer st = new StringTokenizer(classPathString, \" \");\n-\t      while (st.hasMoreElements ()) \n-\t\t{  \n-\t\t  String e = st.nextToken ();\n-\t\t  try\n-\t\t    {\n-\t\t      URL url = new URL(baseURL, e);\n-\t\t      this.classPath.add(url);\n-\t\t    } \n-\t\t  catch (java.net.MalformedURLException xx)\n-\t\t    {\n-\t\t      // Give up\n-\t\t    }\n-\t\t}\n-\t    }\n-\t}\n-      catch (IOException ioe)\n-        {\n-\t  /* ignored */\n-        }\n-\n-      this.baseJarURL = baseJarURL;\n-      this.jarfile = jarfile;\n-    }\n-\n-    /** get resource with the name \"name\" in the jar url */\n-    Resource getResource(String name)\n-    {\n-      if (jarfile == null)\n-        return null;\n-\n-      if (name.startsWith(\"/\"))\n-        name = name.substring(1);\n-\n-      JarEntry je = jarfile.getJarEntry(name);\n-      if (je != null)\n-        return new JarURLResource(this, name, je);\n-      else\n-        return null;\n-    }\n-\n-    Manifest getManifest()\n-    {\n-      try\n-        {\n-          return (jarfile == null) ? null : jarfile.getManifest();\n-        }\n-      catch (IOException ioe)\n-        {\n-          return null;\n-        }\n-    }\n-\n-    Vector getClassPath()\n-    {\n-      return classPath;\n-    }\n-  }\n-\n-  static final class JarURLResource extends Resource\n-  {\n-    private final JarEntry entry;\n-    private final String name;\n-\n-    JarURLResource(JarURLLoader loader, String name, JarEntry entry)\n-    {\n-      super(loader);\n-      this.entry = entry;\n-      this.name = name;\n-    }\n-\n-    InputStream getInputStream() throws IOException\n-    {\n-      return ((JarURLLoader) loader).jarfile.getInputStream(entry);\n-    }\n-\n-    int getLength()\n-    {\n-      return (int) entry.getSize();\n-    }\n-\n-    Certificate[] getCertificates()\n-    {\n-      // We have to get the entry from the jar file again, because the\n-      // certificates will not be available until the entire entry has\n-      // been read.\n-      return ((JarEntry) ((JarURLLoader) loader).jarfile.getEntry(name))\n-        .getCertificates();\n-    }\n-\n-    URL getURL()\n-    {\n-      try\n-        {\n-          return new URL(((JarURLLoader) loader).baseJarURL, name,\n-                         loader.classloader.getURLStreamHandler(\"jar\"));\n-        }\n-      catch (MalformedURLException e)\n-        {\n-          InternalError ie = new InternalError();\n-          ie.initCause(e);\n-          throw ie;\n-        }\n-    }\n-  }\n-\n-  /**\n-   * Loader for remote directories.\n-   */\n-  static final class RemoteURLLoader extends URLLoader\n-  {\n-    private final String protocol;\n-\n-    RemoteURLLoader(URLClassLoader classloader, URL url)\n-    {\n-      super(classloader, url);\n-      protocol = url.getProtocol();\n-    }\n-\n-    /**\n-     * Get a remote resource.\n-     * Returns null if no such resource exists.\n-     */\n-    Resource getResource(String name)\n-    {\n-      try\n-        {\n-          URL url =\n-            new URL(baseURL, name, classloader.getURLStreamHandler(protocol));\n-          URLConnection connection = url.openConnection();\n-\n-          // Open the connection and check the stream\n-          // just to be sure it exists.\n-          int length = connection.getContentLength();\n-          InputStream stream = connection.getInputStream();\n-\n-          // We can do some extra checking if it is a http request\n-          if (connection instanceof HttpURLConnection)\n-            {\n-              int response =\n-                ((HttpURLConnection) connection).getResponseCode();\n-              if (response / 100 != 2)\n-                return null;\n-            }\n-\n-          if (stream != null)\n-            return new RemoteResource(this, name, url, stream, length);\n-          else\n-            return null;\n-        }\n-      catch (IOException ioe)\n-        {\n-          return null;\n-        }\n-    }\n-  }\n-\n-  /**\n-   * A resource from some remote location.\n-   */\n-  static final class RemoteResource extends Resource\n-  {\n-    private final URL url;\n-    private final InputStream stream;\n-    private final int length;\n-\n-    RemoteResource(RemoteURLLoader loader, String name, URL url,\n-                   InputStream stream, int length)\n-    {\n-      super(loader);\n-      this.url = url;\n-      this.stream = stream;\n-      this.length = length;\n-    }\n-\n-    InputStream getInputStream() throws IOException\n-    {\n-      return stream;\n-    }\n-\n-    public int getLength()\n-    {\n-      return length;\n-    }\n-\n-    public URL getURL()\n-    {\n-      return url;\n-    }\n-  }\n-\n-  /**\n-   * A <code>SoURLLoader</code> is a type of <code>URLLoader</code>\n-   * that loads classes and resources from a shared library.\n-   */\n-  final static class SoURLLoader extends URLLoader\n-  {\n-    SharedLibHelper helper;\n-\n-    SoURLLoader(URLClassLoader classloader, URL url)\n-    {\n-      this(classloader, url, url);\n-    }\n-\n-    SoURLLoader(URLClassLoader classloader, URL url, URL overrideURL)\n-    {\n-      super(classloader, url, overrideURL);\n-      helper = SharedLibHelper.findHelper(classloader, url.getFile(),\n-\t\t\t\t\t  noCertCodeSource, true);\n-    }\n-\n-    Class getClass(String className)\n-    {\n-      return helper.findClass(className);\n-    }\n-\n-    Resource getResource(String name)\n-    {\n-      URL url = helper.findResource(name);\n-      if (url == null)\n-\treturn null;\n-      return new SoResource(this, url);\n-    }\n-  }\n-\n-  final static class SoResource extends Resource\n-  {\n-    SoResource(SoURLLoader loader, URL url)\n-    {\n-      super(loader);\n-      this.url = url;\n-    }\n-\n-    InputStream getInputStream() throws IOException\n-    {\n-      URLConnection conn = url.openConnection();\n-      return conn.getInputStream();\n-    }\n-\n-    public int getLength()\n-    {\n-      // FIXME we could find this by asking the core object.\n-      return -1;\n-    }\n-\n-    public URL getURL ()\n-    {\n-      return url;\n-    }\n-\n-    final URL url;\n-  }\n-\n-  /**\n-   * A <code>FileURLLoader</code> is a type of <code>URLLoader</code>\n-   * only loading from file url.\n-   */\n-  static final class FileURLLoader extends URLLoader\n-  {\n-    File dir; //the file for this file url\n-\n-    FileURLLoader(URLClassLoader classloader, URL url, URL absoluteUrl)\n-    {\n-      super(classloader, url, absoluteUrl);\n-      dir = new File(absoluteUrl.getFile());\n-    }\n-\n-    /** get resource with the name \"name\" in the file url */\n-    Resource getResource(String name)\n-    {\n-      try \n- \t{\n- \t  File file = new File(dir, name).getCanonicalFile();\n- \t  if (file.exists() && !file.isDirectory())\n- \t    return new FileResource(this, file);\n- \t}\n-      catch (IOException e)\n- \t{\n- \t  // Fall through...\n- \t}\n-      return null;\n-    }\n-  }\n-\n-  static final class FileResource extends Resource\n-  {\n-    final File file;\n-\n-    FileResource(FileURLLoader loader, File file)\n-    {\n-      super(loader);\n-      this.file = file;\n-    }\n-\n-    InputStream getInputStream() throws IOException\n-    {\n-      // Delegate to the URL content handler mechanism to retrieve an\n-      // HTML representation of the directory listing if a directory\n-      if (file.isDirectory())\n-        {\n-          URL url = getURL();\n-          return url.openStream();\n-        }\n-      // Otherwise simply return a FileInputStream\n-      return new FileInputStream(file);\n-    }\n-\n-    public int getLength()\n-    {\n-      // Delegate to the URL content handler mechanism to retrieve the\n-      // length of the HTML representation of the directory listing if\n-      // a directory, or -1 if an exception occurs opening the directory.\n-      if (file.isDirectory())\n-        {\n-          URL url = getURL();\n-          try\n-            {\n-              URLConnection connection = url.openConnection();\n-              return connection.getContentLength();\n-            }\n-          catch (IOException e)\n-            {\n-              return -1;\n-            }\n-        }\n-      // Otherwise simply return the file length\n-      return (int) file.length();\n-    }\n-\n-    public URL getURL()\n-    {\n-      try\n-        {\n-          return file.toURL();\n-        }\n-      catch (MalformedURLException e)\n-        {\n-          InternalError ie = new InternalError();\n-          ie.initCause(e);\n-          throw ie;\n-        }\n-    }\n-  }\n-\n-  /**\n-   * A <code>CoreURLLoader</code> is a type of <code>URLLoader</code>\n-   * only loading from core url.\n-   */\n-  static final class CoreURLLoader extends URLLoader\n-  {\n-    private String dir;\n-\n-    CoreURLLoader(URLClassLoader classloader, URL url)\n-    {\n-      super(classloader, url);\n-      dir = baseURL.getFile();\n-    }\n-\n-    /** get resource with the name \"name\" in the core url */\n-    Resource getResource(String name)\n-    {\n-      Core core = Core.find (dir + name);\n-      if (core != null)\n-        return new CoreResource(this, name, core);\n-      return null;\n-    }\n-  }\n-\n-  static final class CoreResource extends Resource\n-  {\n-    private final Core core;\n-    private final String name;\n-\n-    CoreResource(CoreURLLoader loader, String name, Core core)\n-    {\n-      super(loader);\n-      this.core = core;\n-      this.name = name;\n-    }\n-\n-    InputStream getInputStream() throws IOException\n-    {\n-      return new CoreInputStream(core);\n-    }\n-\n-    public int getLength()\n-    {\n-      return core.length;\n-    }\n-\n-    public URL getURL()\n-    {\n-      try\n-        {\n-          return new URL(loader.baseURL, name,\n-                         loader.classloader.getURLStreamHandler(\"core\"));\n-        }\n-      catch (MalformedURLException e)\n-        {\n-          InternalError ie = new InternalError();\n-          ie.initCause(e);\n-          throw ie;\n-        }\n-    }\n-  }\n-\n-  // Constructors\n-\n-  /**\n-   * Creates a URLClassLoader that gets classes from the supplied URLs.\n-   * To determine if this classloader may be created the constructor of\n-   * the super class (<code>SecureClassLoader</code>) is called first, which\n-   * can throw a SecurityException. Then the supplied URLs are added\n-   * in the order given to the URLClassLoader which uses these URLs to\n-   * load classes and resources (after using the default parent ClassLoader).\n-   *\n-   * @param urls Locations that should be searched by this ClassLoader when\n-   * resolving Classes or Resources.\n-   * @exception SecurityException if the SecurityManager disallows the\n-   * creation of a ClassLoader.\n-   * @see SecureClassLoader\n-   */\n-  public URLClassLoader(URL[] urls) throws SecurityException\n-  {\n-    super();\n-    this.factory = null;\n-    this.securityContext = null;\n-    addURLs(urls);\n-  }\n-\n-  /**\n-   * Creates a <code>URLClassLoader</code> that gets classes from the supplied\n-   * <code>URL</code>s.\n-   * To determine if this classloader may be created the constructor of\n-   * the super class (<code>SecureClassLoader</code>) is called first, which\n-   * can throw a SecurityException. Then the supplied URLs are added\n-   * in the order given to the URLClassLoader which uses these URLs to\n-   * load classes and resources (after using the supplied parent ClassLoader).\n-   * @param urls Locations that should be searched by this ClassLoader when\n-   * resolving Classes or Resources.\n-   * @param parent The parent class loader used before trying this class\n-   * loader.\n-   * @exception SecurityException if the SecurityManager disallows the\n-   * creation of a ClassLoader.\n-   * @exception SecurityException\n-   * @see SecureClassLoader\n-   */\n-  public URLClassLoader(URL[] urls, ClassLoader parent)\n-    throws SecurityException\n-  {\n-    super(parent);\n-    this.factory = null;\n-    this.securityContext = null;\n-    addURLs(urls);\n-  }\n-\n-  // Package-private to avoid a trampoline constructor.\n-  /**\n-   * Package-private constructor used by the static\n-   * <code>newInstance(URL[])</code> method.  Creates an\n-   * <code>URLClassLoader</code> with the given parent but without any\n-   * <code>URL</code>s yet. This is used to bypass the normal security\n-   * check for creating classloaders, but remembers the security\n-   * context which will be used when defining classes.  The\n-   * <code>URL</code>s to load from must be added by the\n-   * <code>newInstance()</code> method in the security context of the\n-   * caller.\n-   *\n-   * @param securityContext the security context of the unprivileged code.\n-   */\n-  URLClassLoader(ClassLoader parent, AccessControlContext securityContext)\n-  {\n-    super(parent);\n-    this.factory = null;\n-    this.securityContext = securityContext;\n-  }\n-\n-  /**\n-   * Creates a URLClassLoader that gets classes from the supplied URLs.\n-   * To determine if this classloader may be created the constructor of\n-   * the super class (<CODE>SecureClassLoader</CODE>) is called first, which\n-   * can throw a SecurityException. Then the supplied URLs are added\n-   * in the order given to the URLClassLoader which uses these URLs to\n-   * load classes and resources (after using the supplied parent ClassLoader).\n-   * It will use the supplied <CODE>URLStreamHandlerFactory</CODE> to get the\n-   * protocol handlers of the supplied URLs.\n-   * @param urls Locations that should be searched by this ClassLoader when\n-   * resolving Classes or Resources.\n-   * @param parent The parent class loader used before trying this class\n-   * loader.\n-   * @param factory Used to get the protocol handler for the URLs.\n-   * @exception SecurityException if the SecurityManager disallows the\n-   * creation of a ClassLoader.\n-   * @exception SecurityException\n-   * @see SecureClassLoader\n-   */\n-  public URLClassLoader(URL[] urls, ClassLoader parent,\n-                        URLStreamHandlerFactory factory)\n-    throws SecurityException\n-  {\n-    super(parent);\n-    this.securityContext = null;\n-    this.factory = factory;\n-    addURLs(urls);\n-\n-    // If this factory is still not in factoryCache, add it,\n-    //   since we only support three protocols so far, 5 is enough\n-    //   for cache initial size\n-    synchronized (factoryCache)\n-      {\n-        if (factory != null && factoryCache.get(factory) == null)\n-          factoryCache.put(factory, new HashMap(5));\n-      }\n-  }\n-\n-  // Methods\n-\n-  /**\n-   * Adds a new location to the end of the internal URL store.\n-   * @param newUrl the location to add\n-   */\n-  protected void addURL(URL newUrl)\n-  {\n-    urls.add(newUrl);\n-    addURLImpl(newUrl);\n-  }\n-\n-  private void addURLImpl(URL newUrl)\n-  {\n-    synchronized (this)\n-      {\n-        if (newUrl == null)\n-          return; // Silently ignore...\n-\n-\t// Reset the toString() value.\n-\tthisString = null;\n-\n-        // Check global cache to see if there're already url loader\n-        // for this url.\n-        URLLoader loader = (URLLoader) urlloaders.get(newUrl);\n-        if (loader == null)\n-          {\n-            String file = newUrl.getFile();\n-            String protocol = newUrl.getProtocol();\n-\n-\t    // If we have a file: URL, we want to make it absolute\n-\t    // here, before we decide whether it is really a jar.\n-\t    URL absoluteURL;\n-\t    if (\"file\".equals (protocol))\n-\t      {\n-\t\tFile dir = new File(file);\n-\t\tURL absUrl;\n-\t\ttry\n-\t\t  {\n-\t\t    absoluteURL = dir.getCanonicalFile().toURL();\n-\t\t  }\n-\t\tcatch (IOException ignore)\n-\t\t  {\n-\t\t    try\n-\t\t      {\n-\t\t\tabsoluteURL = dir.getAbsoluteFile().toURL();\n-\t\t      }\n-\t\t    catch (MalformedURLException _)\n-\t\t      {\n-\t\t\t// This really should not happen.\n-\t\t\tabsoluteURL = newUrl;\n-\t\t      }\n-\t\t  }\n-\t      }\n-\t    else\n-\t      {\n-\t\t// This doesn't hurt, and it simplifies the logic a\n-\t\t// little.\n-\t\tabsoluteURL = newUrl;\n-\t      }\n-\n-            // Check that it is not a directory\n-\t    if (\"gcjlib\".equals(protocol))\n-\t      loader = new SoURLLoader(this, newUrl);\n-\t    else if (! (file.endsWith(\"/\") || file.endsWith(File.separator)))\n-              loader = new JarURLLoader(this, newUrl, absoluteURL);\n-            else if (\"file\".equals(protocol))\n-\t      loader = new FileURLLoader(this, newUrl, absoluteURL);\n-\t    else if (\"core\".equals(protocol))\n-\t      loader = new CoreURLLoader(this, newUrl);\n-            else\n-              loader = new RemoteURLLoader(this, newUrl);\n-\n-            // Cache it.\n-            urlloaders.put(newUrl, loader);\n-          }\n-\n-\turlinfos.add(loader);\n-\n-\tVector extraUrls = loader.getClassPath();\n-\tif (extraUrls != null)\n-\t  {\n-\t    Iterator it = extraUrls.iterator();\n-\t    while (it.hasNext())\n-\t      {\n-\t\tURL url = (URL)it.next();\n-\t\tURLLoader extraLoader = (URLLoader) urlloaders.get(url);\n-\t\tif (! urlinfos.contains (extraLoader))\n-\t\t  addURLImpl(url);\n-\t      }\n-\t  }\n-\n-      }\n-  }\n-\n-  /**\n-   * Adds an array of new locations to the end of the internal URL\n-   * store.  Called from the the constructors. Should not call to the\n-   * protected addURL() method since that can be overridden and\n-   * subclasses are not yet in a good state at this point.\n-   * jboss 4.0.3 for example depends on this.\n-   *\n-   * @param newUrls the locations to add\n-   */\n-  private void addURLs(URL[] newUrls)\n-  {\n-    for (int i = 0; i < newUrls.length; i++)\n-      {\n-\turls.add(newUrls[i]);\n-\taddURLImpl(newUrls[i]);\n-      }\n-  }\n-\n-  /**\n-   * Look in both Attributes for a given value.  The first Attributes\n-   * object, if not null, has precedence.\n-   */\n-  private String getAttributeValue(Attributes.Name name, Attributes first,\n-\t\t\t\t   Attributes second)\n-  {\n-    String result = null;\n-    if (first != null)\n-      result = first.getValue(name);\n-    if (result == null)\n-      result = second.getValue(name);\n-    return result;\n-  }\n-\n-  /**\n-   * Defines a Package based on the given name and the supplied manifest\n-   * information. The manifest indicates the title, version and\n-   * vendor information of the specification and implementation and whether the\n-   * package is sealed. If the Manifest indicates that the package is sealed\n-   * then the Package will be sealed with respect to the supplied URL.\n-   *\n-   * @param name The name of the package\n-   * @param manifest The manifest describing the specification,\n-   * implementation and sealing details of the package\n-   * @param url the code source url to seal the package\n-   * @return the defined Package\n-   * @throws IllegalArgumentException If this package name already exists\n-   * in this class loader\n-   */\n-  protected Package definePackage(String name, Manifest manifest, URL url)\n-    throws IllegalArgumentException\n-  {\n-    // Compute the name of the package as it may appear in the\n-    // Manifest.\n-    StringBuffer xform = new StringBuffer(name);\n-    for (int i = xform.length () - 1; i >= 0; --i)\n-      if (xform.charAt(i) == '.')\n-\txform.setCharAt(i, '/');\n-    xform.append('/');\n-    String xformName = xform.toString();\n-\n-    Attributes entryAttr = manifest.getAttributes(xformName);\n-    Attributes attr = manifest.getMainAttributes();\n-\n-    String specTitle\n-      = getAttributeValue(Attributes.Name.SPECIFICATION_TITLE,\n-\t\t\t  entryAttr, attr);\n-    String specVersion\n-      = getAttributeValue(Attributes.Name.SPECIFICATION_VERSION,\n-\t\t\t  entryAttr, attr);\n-    String specVendor\n-      = getAttributeValue(Attributes.Name.SPECIFICATION_VENDOR,\n-\t\t\t  entryAttr, attr);\n-    String implTitle\n-      = getAttributeValue(Attributes.Name.IMPLEMENTATION_TITLE,\n-\t\t\t  entryAttr, attr);\n-    String implVersion\n-      = getAttributeValue(Attributes.Name.IMPLEMENTATION_VERSION,\n-\t\t\t  entryAttr, attr);\n-    String implVendor\n-      = getAttributeValue(Attributes.Name.IMPLEMENTATION_VENDOR,\n-\t\t\t  entryAttr, attr);\n-\n-    // Look if the Manifest indicates that this package is sealed\n-    // XXX - most likely not completely correct!\n-    // Shouldn't we also check the sealed attribute of the complete jar?\n-    // http://java.sun.com/products/jdk/1.4/docs/guide/extensions/spec.html#bundled\n-    // But how do we get that jar manifest here?\n-    String sealed = attr.getValue(Attributes.Name.SEALED);\n-    if (\"false\".equals(sealed))\n-      // make sure that the URL is null so the package is not sealed\n-      url = null;\n-\n-    return definePackage(name,\n-\t\t\t specTitle, specVendor, specVersion,\n-\t\t\t implTitle, implVendor, implVersion,\n-\t\t\t url);\n-  }\n-\n-  /**\n-   * Finds (the first) class by name from one of the locations. The locations\n-   * are searched in the order they were added to the URLClassLoader.\n-   *\n-   * @param className the classname to find\n-   * @exception ClassNotFoundException when the class could not be found or\n-   * loaded\n-   * @return a Class object representing the found class\n-   */\n-  protected Class findClass(final String className)\n-    throws ClassNotFoundException\n-  {\n-    // Just try to find the resource by the (almost) same name\n-    String resourceName = className.replace('.', '/') + \".class\";\n-    int max = urlinfos.size();\n-    Resource resource = null;\n-    for (int i = 0; i < max && resource == null; i++)\n-      {\n-\tURLLoader loader = (URLLoader)urlinfos.elementAt(i);\n-\tif (loader == null)\n-\t  continue;\n-\n-\tClass k = loader.getClass(className);\n-\tif (k != null)\n-\t  return k;\n-\n-\tresource = loader.getResource(resourceName);\n-      }\n-    if (resource == null)\n-      {\n-\tString message = className + \" not found\";\n-\t// Calling this.toString() during VM startup when a\n-\t// security manager is in force causes the stack to\n-\t// be unwound before it can properly be decoded.\n-\tif (Thread.currentThread() != null)\n-\t  message += \" in \" + this;\n-\tthrow new ClassNotFoundException(message);\n-      }\n-\n-    // Try to read the class data, create the CodeSource, Package and\n-    // construct the class (and watch out for those nasty IOExceptions)\n-    try\n-      {\n-\tbyte[] data;\n-\tInputStream in = resource.getInputStream();\n-\ttry\n-\t  {\n-\t    int length = resource.getLength();\n-\t    if (length != -1)\n-\t      {\n-\t\t// We know the length of the data.\n-\t\t// Just try to read it in all at once\n-\t\tdata = new byte[length];\n-\t\tint pos = 0;\n-\t\twhile (length - pos > 0)\n-\t\t  {\n-\t\t    int len = in.read(data, pos, length - pos);\n-\t\t    if (len == -1)\n-\t\t      throw new EOFException(\"Not enough data reading from: \"\n-\t\t\t\t\t     + in);\n-\t\t    pos += len;\n-\t\t  }\n-\t      }\n-\t    else\n-\t      {\n-\t\t// We don't know the data length.\n-\t\t// Have to read it in chunks.\n-\t\tByteArrayOutputStream out = new ByteArrayOutputStream(4096);\n-\t\tbyte[] b = new byte[4096];\n-\t\tint l = 0;\n-\t\twhile (l != -1)\n-\t\t  {\n-\t\t    l = in.read(b);\n-\t\t    if (l != -1)\n-\t\t      out.write(b, 0, l);\n-\t\t  }\n-\t\tdata = out.toByteArray();\n-\t      }\n-\t  }\n-\tfinally\n-\t  {\n-\t    in.close();\n-\t  }\n-\tfinal byte[] classData = data;\n-\n-        // Now get the CodeSource\n-        final CodeSource source = resource.getCodeSource();\n-\n-        // Find out package name\n-        String packageName = null;\n-        int lastDot = className.lastIndexOf('.');\n-        if (lastDot != -1)\n-          packageName = className.substring(0, lastDot);\n-\n-        if (packageName != null && getPackage(packageName) == null)\n-          {\n-            // define the package\n-            Manifest manifest = resource.loader.getManifest();\n-            if (manifest == null)\n-              definePackage(packageName, null, null, null, null, null, null,\n-                            null);\n-            else\n-              definePackage(packageName, manifest, resource.loader.baseURL);\n-          }\n-\n-        // And finally construct the class!\n-        SecurityManager sm = System.getSecurityManager();\n-        Class result = null;\n-        if (sm != null && securityContext != null)\n-          {\n-            result = (Class)AccessController.doPrivileged\n-              (new PrivilegedAction()\n-                {\n-                  public Object run()\n-                  {\n-                    return defineClass(className, classData,\n-                                       0, classData.length,\n-                                       source);\n-                  }\n-                }, securityContext);\n-          }\n-        else\n-          result = defineClass(className, classData, 0, classData.length, source);\n-\n-        // Avoid NullPointerExceptions.\n-        Certificate[] resourceCertificates = resource.getCertificates();\n-        if(resourceCertificates != null)\n-          super.setSigners(result, resourceCertificates);\n-        \n-        return result;\n-      }\n-    catch (IOException ioe)\n-      {\n-\tClassNotFoundException cnfe;\n-\tcnfe = new ClassNotFoundException(className + \" not found in \" + this);\n-\tcnfe.initCause(ioe);\n-\tthrow cnfe;\n-      }\n-  }\n-  \n-  // Cached String representation of this URLClassLoader\n-  private String thisString;\n-  \n-  /**\n-   * Returns a String representation of this URLClassLoader giving the\n-   * actual Class name, the URLs that are searched and the parent\n-   * ClassLoader.\n-   */\n-  public String toString()\n-  {\n-    synchronized (this)\n-      {\n-\tif (thisString == null)\n-\t  {\n-\t    StringBuffer sb = new StringBuffer();\n-\t    sb.append(this.getClass().getName());\n-\t    sb.append(\"{urls=[\" );\n-\t    URL[] thisURLs = getURLs();\n-\t    for (int i = 0; i < thisURLs.length; i++)\n-\t      {\n-\t\tsb.append(thisURLs[i]);\n-\t\tif (i < thisURLs.length - 1)\n-\t\t  sb.append(',');\n-\t      }\n-\t    sb.append(']');\n-\t    sb.append(\", parent=\");\n-\t    sb.append(getParent());\n-\t    sb.append('}');\n-\t    thisString = sb.toString();\n-\t  }\n-\treturn thisString;\n-      }\n-  }\n-\n-  /**\n-   * Finds the first occurrence of a resource that can be found. The locations\n-   * are searched in the order they were added to the URLClassLoader.\n-   *\n-   * @param resourceName the resource name to look for\n-   * @return the URLResource for the resource if found, null otherwise\n-   */\n-  private Resource findURLResource(String resourceName)\n-  {\n-    int max = urlinfos.size();\n-    for (int i = 0; i < max; i++)\n-      {\n-        URLLoader loader = (URLLoader) urlinfos.elementAt(i);\n-        if (loader == null)\n-          continue;\n-\n-        Resource resource = loader.getResource(resourceName);\n-        if (resource != null)\n-          return resource;\n-      }\n-    return null;\n-  }\n-\n-  /**\n-   * Finds the first occurrence of a resource that can be found.\n-   *\n-   * @param resourceName the resource name to look for\n-   * @return the URL if found, null otherwise\n-   */\n-  public URL findResource(String resourceName)\n-  {\n-    Resource resource = findURLResource(resourceName);\n-    if (resource != null)\n-      return resource.getURL();\n-\n-    // Resource not found\n-    return null;\n-  }\n-\n-  /**\n-   * If the URLStreamHandlerFactory has been set this return the appropriate\n-   * URLStreamHandler for the given protocol, if not set returns null.\n-   *\n-   * @param protocol the protocol for which we need a URLStreamHandler\n-   * @return the appropriate URLStreamHandler or null\n-   */\n-  URLStreamHandler getURLStreamHandler(String protocol)\n-  {\n-    if (factory == null)\n-      return null;\n-\n-    URLStreamHandler handler;\n-    synchronized (factoryCache)\n-      {\n-        // Check if there're handler for the same protocol in cache.\n-        HashMap cache = (HashMap) factoryCache.get(factory);\n-        handler = (URLStreamHandler) cache.get(protocol);\n-        if (handler == null)\n-          {\n-            // Add it to cache.\n-            handler = factory.createURLStreamHandler(protocol);\n-            cache.put(protocol, handler);\n-          }\n-      }\n-    return handler;\n-  }\n-\n-  /**\n-   * Finds all the resources with a particular name from all the locations.\n-   *\n-   * @param resourceName the name of the resource to lookup\n-   * @return a (possible empty) enumeration of URLs where the resource can be\n-   * found\n-   * @exception IOException when an error occurs accessing one of the\n-   * locations\n-   */\n-  public Enumeration findResources(String resourceName)\n-    throws IOException\n-  {\n-    Vector resources = new Vector();\n-    int max = urlinfos.size();\n-    for (int i = 0; i < max; i++)\n-      {\n-        URLLoader loader = (URLLoader) urlinfos.elementAt(i);\n-        Resource resource = loader.getResource(resourceName);\n-        if (resource != null)\n-          resources.add(resource.getURL());\n-      }\n-    return resources.elements();\n-  }\n-\n-  /**\n-   * Returns the permissions needed to access a particular code\n-   * source.  These permissions includes those returned by\n-   * <code>SecureClassLoader.getPermissions()</code> and the actual\n-   * permissions to access the objects referenced by the URL of the\n-   * code source.  The extra permissions added depend on the protocol\n-   * and file portion of the URL in the code source. If the URL has\n-   * the \"file\" protocol ends with a '/' character then it must be a\n-   * directory and a file Permission to read everything in that\n-   * directory and all subdirectories is added. If the URL had the\n-   * \"file\" protocol and doesn't end with a '/' character then it must\n-   * be a normal file and a file permission to read that file is\n-   * added. If the <code>URL</code> has any other protocol then a\n-   * socket permission to connect and accept connections from the host\n-   * portion of the URL is added.\n-   *\n-   * @param source The codesource that needs the permissions to be accessed\n-   * @return the collection of permissions needed to access the code resource\n-   * @see java.security.SecureClassLoader#getPermissions(CodeSource)\n-   */\n-  protected PermissionCollection getPermissions(CodeSource source)\n-  {\n-    // XXX - This implementation does exactly as the Javadoc describes.\n-    // But maybe we should/could use URLConnection.getPermissions()?\n-    // First get the permissions that would normally be granted\n-    PermissionCollection permissions = super.getPermissions(source);\n-\n-    // Now add any extra permissions depending on the URL location.\n-    URL url = source.getLocation();\n-    String protocol = url.getProtocol();\n-    if (protocol.equals(\"file\"))\n-      {\n-        String file = url.getFile();\n-\n-        // If the file end in / it must be an directory.\n-        if (file.endsWith(\"/\") || file.endsWith(File.separator))\n-          {\n-            // Grant permission to read everything in that directory and\n-            // all subdirectories.\n-            permissions.add(new FilePermission(file + \"-\", \"read\"));\n-          }\n-        else\n-          {\n-            // It is a 'normal' file.\n-            // Grant permission to access that file.\n-            permissions.add(new FilePermission(file, \"read\"));\n-          }\n-      }\n-    else\n-      {\n-        // Grant permission to connect to and accept connections from host\n-        String host = url.getHost();\n-        if (host != null)\n-          permissions.add(new SocketPermission(host, \"connect,accept\"));\n-      }\n-\n-    return permissions;\n-  }\n-\n-  /**\n-   * Returns all the locations that this class loader currently uses the\n-   * resolve classes and resource. This includes both the initially supplied\n-   * URLs as any URLs added later by the loader.\n-   * @return All the currently used URLs\n-   */\n-  public URL[] getURLs()\n-  {\n-    return (URL[]) urls.toArray(new URL[urls.size()]);\n-  }\n-\n-  /**\n-   * Creates a new instance of a <code>URLClassLoader</code> that gets\n-   * classes from the supplied <code>URL</code>s. This class loader\n-   * will have as parent the standard system class loader.\n-   *\n-   * @param urls the initial URLs used to resolve classes and\n-   * resources\n-   *\n-   * @return the class loader\n-   *\n-   * @exception SecurityException when the calling code does not have\n-   * permission to access the given <code>URL</code>s\n-   */\n-  public static URLClassLoader newInstance(URL[] urls)\n-    throws SecurityException\n-  {\n-    return newInstance(urls, null);\n-  }\n-\n-  /**\n-   * Creates a new instance of a <code>URLClassLoader</code> that gets\n-   * classes from the supplied <code>URL</code>s and with the supplied\n-   * loader as parent class loader.\n-   *\n-   * @param urls the initial URLs used to resolve classes and\n-   * resources\n-   * @param parent the parent class loader\n-   *\n-   * @return the class loader\n-   *\n-   * @exception SecurityException when the calling code does not have\n-   * permission to access the given <code>URL</code>s\n-   */\n-  public static URLClassLoader newInstance(URL[] urls, final ClassLoader parent)\n-    throws SecurityException\n-  {\n-    SecurityManager sm = System.getSecurityManager();\n-    if (sm == null)\n-      return new URLClassLoader(urls, parent);\n-    else\n-      {\n-        final Object securityContext = sm.getSecurityContext();\n-\n-        // XXX - What to do with anything else then an AccessControlContext?\n-        if (! (securityContext instanceof AccessControlContext))\n-          throw new SecurityException(\"securityContext must be AccessControlContext: \"\n-                                      + securityContext);\n-\n-        URLClassLoader loader =\n-          (URLClassLoader) AccessController.doPrivileged(new PrivilegedAction()\n-              {\n-                public Object run()\n-                {\n-                  return new URLClassLoader(parent,\n-                                            (AccessControlContext) securityContext);\n-                }\n-              });\n-        loader.addURLs(urls);\n-        return loader;\n-      }\n-  }\n-}"}, {"sha": "418bd8d7c52a2b35a695c3520be53c47371ca3c0", "filename": "libjava/sources.am", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5c0f6fe8787df483b1fe914e13bc6576bdd3342/libjava%2Fsources.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5c0f6fe8787df483b1fe914e13bc6576bdd3342/libjava%2Fsources.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fsources.am?ref=a5c0f6fe8787df483b1fe914e13bc6576bdd3342", "patch": "@@ -1338,6 +1338,7 @@ classpath/gnu/java/net/loader/FileResource.java \\\n classpath/gnu/java/net/loader/FileURLLoader.java \\\n classpath/gnu/java/net/loader/JarURLLoader.java \\\n classpath/gnu/java/net/loader/JarURLResource.java \\\n+gnu/java/net/loader/Load_gcjlib.java \\\n classpath/gnu/java/net/loader/RemoteResource.java \\\n classpath/gnu/java/net/loader/RemoteURLLoader.java \\\n classpath/gnu/java/net/loader/Resource.java \\\n@@ -4846,7 +4847,7 @@ classpath/java/net/SocketTimeoutException.java \\\n classpath/java/net/URI.java \\\n classpath/java/net/URISyntaxException.java \\\n classpath/java/net/URL.java \\\n-java/net/URLClassLoader.java \\\n+classpath/java/net/URLClassLoader.java \\\n classpath/java/net/URLConnection.java \\\n classpath/java/net/URLDecoder.java \\\n classpath/java/net/URLEncoder.java \\"}]}