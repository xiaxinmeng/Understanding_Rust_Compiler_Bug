{"sha": "ab0b65811bd9a0ed2408e16d756c712818d9a8d8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWIwYjY1ODExYmQ5YTBlZDI0MDhlMTZkNzU2YzcxMjgxOGQ5YThkOA==", "commit": {"author": {"name": "Torbjorn Granlund", "email": "tege@gnu.org", "date": "1994-07-01T11:40:45Z"}, "committer": {"name": "Torbjorn Granlund", "email": "tege@gnu.org", "date": "1994-07-01T11:40:45Z"}, "message": "(expand_divmod): Put OP0 in a register when computing\nremainder, or when OP1 is constant.\n\nFrom-SVN: r7628", "tree": {"sha": "1ca7498e0f6ebe70a9687650f3a5cfa8ad806238", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1ca7498e0f6ebe70a9687650f3a5cfa8ad806238"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ab0b65811bd9a0ed2408e16d756c712818d9a8d8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab0b65811bd9a0ed2408e16d756c712818d9a8d8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ab0b65811bd9a0ed2408e16d756c712818d9a8d8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab0b65811bd9a0ed2408e16d756c712818d9a8d8/comments", "author": null, "committer": null, "parents": [{"sha": "e9c1141151358c5713eefd54d900a816db88fa22", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9c1141151358c5713eefd54d900a816db88fa22", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e9c1141151358c5713eefd54d900a816db88fa22"}], "stats": {"total": 7, "additions": 4, "deletions": 3}, "files": [{"sha": "50ebb674714470ff5053072cb059c053e83dbbf9", "filename": "gcc/expmed.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab0b65811bd9a0ed2408e16d756c712818d9a8d8/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab0b65811bd9a0ed2408e16d756c712818d9a8d8/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=ab0b65811bd9a0ed2408e16d756c712818d9a8d8", "patch": "@@ -2680,9 +2680,10 @@ expand_divmod (rem_flag, code, mode, op0, op1, target, unsignedp)\n   if (GET_CODE (op1) == MEM && MEM_VOLATILE_P (op1))\n     op1 = force_reg (compute_mode, op1);\n \n-#if 0\n-  op0 = force_reg (mode, op0);\n-#endif\n+  /* If we need the remainder or if OP1 is constant, we need to\n+     put OP0 in a register in case it has any queued subexpressions.  */\n+  if (rem_flag || op1_is_constant)\n+    op0 = force_reg (compute_mode, op0);\n \n   last = get_last_insn ();\n "}]}