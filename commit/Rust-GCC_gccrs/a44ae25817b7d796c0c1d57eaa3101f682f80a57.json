{"sha": "a44ae25817b7d796c0c1d57eaa3101f682f80a57", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTQ0YWUyNTgxN2I3ZDc5NmMwYzFkNTdlYWEzMTAxZjY4MmY4MGE1Nw==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2019-05-23T16:07:07Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2019-05-23T16:07:07Z"}, "message": "re PR tree-optimization/90576 (SPEC CPU2006 450.soplex miscompiled with -Os -flto after r271413)\n\n\tPR tree-optimization/90576\n\t* tree-ssa-alias.c (compare_sizes): Remove dead calls to\n\tpoly_int_tree_p.\n\t(aliasing_component_refs_p): Fix three way size compare conditional;\n\tgive up earlier in case we can not decide on equivalence.\n\nCo-Authored-By: Martin Liska <mliska@suse.cz>\n\nFrom-SVN: r271572", "tree": {"sha": "a12fca07aed108f69318ae5b88c45ec1a979f9b7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a12fca07aed108f69318ae5b88c45ec1a979f9b7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a44ae25817b7d796c0c1d57eaa3101f682f80a57", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a44ae25817b7d796c0c1d57eaa3101f682f80a57", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a44ae25817b7d796c0c1d57eaa3101f682f80a57", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a44ae25817b7d796c0c1d57eaa3101f682f80a57/comments", "author": null, "committer": null, "parents": [{"sha": "1a4f7c1b05389e5d4469571ca510e4c519d5fe51", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a4f7c1b05389e5d4469571ca510e4c519d5fe51", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1a4f7c1b05389e5d4469571ca510e4c519d5fe51"}], "stats": {"total": 30, "additions": 22, "deletions": 8}, "files": [{"sha": "ff91bfe77faba1fe3609d8acadf2839066eaef42", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a44ae25817b7d796c0c1d57eaa3101f682f80a57/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a44ae25817b7d796c0c1d57eaa3101f682f80a57/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a44ae25817b7d796c0c1d57eaa3101f682f80a57", "patch": "@@ -1,3 +1,12 @@\n+2019-05-23  Jan Hubicka  <jh@suse.cz>\n+\t    Martin Liska  <mliska@suse.cz>\n+\n+\tPR tree-optimization/90576\n+\t* tree-ssa-alias.c (compare_sizes): Remove dead calls to\n+\tpoly_int_tree_p.\n+\t(aliasing_component_refs_p): Fix three way size compare conditional;\n+\tgive up earlier in case we can not decide on equivalence.\n+\n 2019-05-23  Bill Schmidt  <wschmidt@linux.ibm.com>\n \t    Michael Meissner  <meissner@linux.ibm.com>\n \t    Segher Boessenkool  <segher@kernel.crashing.org>"}, {"sha": "33c15f52bebaff770ff857e20a7e61d7c6c553e7", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a44ae25817b7d796c0c1d57eaa3101f682f80a57/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a44ae25817b7d796c0c1d57eaa3101f682f80a57/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=a44ae25817b7d796c0c1d57eaa3101f682f80a57", "patch": "@@ -746,8 +746,8 @@ compare_sizes (tree s1, tree s2)\n   if (!s1 || !s2)\n     return 0;\n \n-  poly_uint64 size1 = poly_int_tree_p (s1, &size1);\n-  poly_uint64 size2 = poly_int_tree_p (s2, &size2);\n+  poly_uint64 size1;\n+  poly_uint64 size2;\n \n   if (!poly_int_tree_p (s1, &size1) || !poly_int_tree_p (s2, &size2))\n     return 0;\n@@ -873,7 +873,7 @@ aliasing_component_refs_p (tree ref1,\n \t    break;\n \t  /* If types may be of same size, see if we can decide about their\n \t     equality.  */\n-\t  if (cmp >= 0)\n+\t  if (cmp == 0)\n \t    {\n \t      same_p2 = same_type_for_tbaa (TREE_TYPE (*refp), type1);\n \t      if (same_p2 != 0)\n@@ -915,7 +915,7 @@ aliasing_component_refs_p (tree ref1,\n \t    break;\n \t  /* If types may be of same size, see if we can decide about their\n \t     equality.  */\n-\t  if (cmp >= 0)\n+\t  if (cmp == 0)\n \t    {\n \t      same_p1 = same_type_for_tbaa (TREE_TYPE (*refp), type2);\n \t      if (same_p1 != 0)\n@@ -947,15 +947,21 @@ aliasing_component_refs_p (tree ref1,\n \t}\n     }\n \n+  /* In the following code we make an assumption that the types in access\n+     paths do not overlap and thus accesses alias only if one path can be\n+     continuation of another.  If we was not able to decide about equivalence,\n+     we need to give up.  */\n+  if (same_p1 == -1 || same_p2 == -1)\n+    return true;\n+\n   /* If we have two type access paths B1.path1 and B2.path2 they may\n      only alias if either B1 is in B2.path2 or B2 is in B1.path1.\n      But we can still have a path that goes B1.path1...B2.path2 with\n      a part that we do not see.  So we can only disambiguate now\n      if there is no B2 in the tail of path1 and no B1 on the\n      tail of path2.  */\n   if (compare_type_sizes (TREE_TYPE (ref2), type1) >= 0\n-      && (same_p2 == -1\n-          || base1_alias_set == ref2_alias_set\n+      && (base1_alias_set == ref2_alias_set\n           || alias_set_subset_of (base1_alias_set, ref2_alias_set)))\n     {\n       ++alias_stats.aliasing_component_refs_p_may_alias;\n@@ -964,8 +970,7 @@ aliasing_component_refs_p (tree ref1,\n   /* If this is ptr vs. decl then we know there is no ptr ... decl path.  */\n   if (!ref2_is_decl\n       && compare_type_sizes (TREE_TYPE (ref1), type2) >= 0\n-      && (same_p1 == -1\n-\t  || base2_alias_set == ref1_alias_set\n+      && (base2_alias_set == ref1_alias_set\n \t  || alias_set_subset_of (base2_alias_set, ref1_alias_set)))\n     {\n       ++alias_stats.aliasing_component_refs_p_may_alias;"}]}