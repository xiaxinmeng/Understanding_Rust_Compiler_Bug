{"sha": "4f7aa145b796c044526c93f390e68f3b56a1b30a", "node_id": "C_kwDOANBUbNoAKDRmN2FhMTQ1Yjc5NmMwNDQ1MjZjOTNmMzkwZTY4ZjNiNTZhMWIzMGE", "commit": {"author": {"name": "David Faust", "email": "david.faust@oracle.com", "date": "2022-12-07T19:47:26Z"}, "committer": {"name": "David Faust", "email": "david.faust@oracle.com", "date": "2022-12-14T18:20:52Z"}, "message": "btf: fix 'extern const void' variables [PR106773]\n\nThe eBPF loader expects to find BTF_KIND_VAR records for references to\nextern const void symbols. We were mistakenly identifing these as\nunsupported types, and as a result skipping emitting VAR records for\nthem.\n\nIn addition, the internal DWARF representation from which BTF is\nproduced does not generate 'const' modifier DIEs for the void type,\nwhich meant in BTF the 'const' qualifier was dropped for 'extern const\nvoid' variables. This patch also adds support for generating a const\nvoid type in BTF to correct emission for these variables.\n\n\tPR target/106773\n\ngcc/\n\n\t* btfout.cc (btf_collect_datasec): Correct size of void entries.\n\t(btf_dvd_emit_preprocess_cb): Do not skip emitting variables which\n\trefer to void types.\n\t(btf_init_postprocess): Create 'const void' type record if needed and\n\tadjust variables to refer to it as appropriate.\n\ngcc/testsuite/\n\n\t* gcc.dg/debug/btf/btf-pr106773.c: New test.", "tree": {"sha": "d00cafaed17f579619ed3a981a3e289e57725731", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d00cafaed17f579619ed3a981a3e289e57725731"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4f7aa145b796c044526c93f390e68f3b56a1b30a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f7aa145b796c044526c93f390e68f3b56a1b30a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4f7aa145b796c044526c93f390e68f3b56a1b30a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f7aa145b796c044526c93f390e68f3b56a1b30a/comments", "author": {"login": "dafaust", "id": 4460334, "node_id": "MDQ6VXNlcjQ0NjAzMzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4460334?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dafaust", "html_url": "https://github.com/dafaust", "followers_url": "https://api.github.com/users/dafaust/followers", "following_url": "https://api.github.com/users/dafaust/following{/other_user}", "gists_url": "https://api.github.com/users/dafaust/gists{/gist_id}", "starred_url": "https://api.github.com/users/dafaust/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dafaust/subscriptions", "organizations_url": "https://api.github.com/users/dafaust/orgs", "repos_url": "https://api.github.com/users/dafaust/repos", "events_url": "https://api.github.com/users/dafaust/events{/privacy}", "received_events_url": "https://api.github.com/users/dafaust/received_events", "type": "User", "site_admin": false}, "committer": {"login": "dafaust", "id": 4460334, "node_id": "MDQ6VXNlcjQ0NjAzMzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4460334?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dafaust", "html_url": "https://github.com/dafaust", "followers_url": "https://api.github.com/users/dafaust/followers", "following_url": "https://api.github.com/users/dafaust/following{/other_user}", "gists_url": "https://api.github.com/users/dafaust/gists{/gist_id}", "starred_url": "https://api.github.com/users/dafaust/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dafaust/subscriptions", "organizations_url": "https://api.github.com/users/dafaust/orgs", "repos_url": "https://api.github.com/users/dafaust/repos", "events_url": "https://api.github.com/users/dafaust/events{/privacy}", "received_events_url": "https://api.github.com/users/dafaust/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2bce22e88e1c8486a0f2d42311506a8d3da20fb7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2bce22e88e1c8486a0f2d42311506a8d3da20fb7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2bce22e88e1c8486a0f2d42311506a8d3da20fb7"}], "stats": {"total": 69, "additions": 65, "deletions": 4}, "files": [{"sha": "204b11d4e9f2fb5c5c7feba8a80fdc99bf66d47c", "filename": "gcc/btfout.cc", "status": "modified", "additions": 40, "deletions": 4, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f7aa145b796c044526c93f390e68f3b56a1b30a/gcc%2Fbtfout.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f7aa145b796c044526c93f390e68f3b56a1b30a/gcc%2Fbtfout.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbtfout.cc?ref=4f7aa145b796c044526c93f390e68f3b56a1b30a", "patch": "@@ -350,6 +350,8 @@ btf_collect_datasec (ctf_container_ref ctfc)\n       tree size = DECL_SIZE_UNIT (node->decl);\n       if (tree_fits_uhwi_p (size))\n \tinfo.size = tree_to_uhwi (size);\n+      else if (VOID_TYPE_P (TREE_TYPE (node->decl)))\n+\tinfo.size = 1;\n \n       /* Offset is left as 0 at compile time, to be filled in by loaders such\n \t as libbpf.  */\n@@ -441,7 +443,7 @@ btf_dvd_emit_preprocess_cb (ctf_dvdef_ref *slot, ctf_container_ref arg_ctfc)\n     return 1;\n \n   /* Do not add variables which refer to unsupported types.  */\n-  if (btf_removed_type_p (var->dvd_type))\n+  if (!voids.contains (var->dvd_type) && btf_removed_type_p (var->dvd_type))\n     return 1;\n \n   arg_ctfc->ctfc_vars_list[num_vars_added] = var;\n@@ -1075,15 +1077,49 @@ btf_init_postprocess (void)\n {\n   ctf_container_ref tu_ctfc = ctf_get_tu_ctfc ();\n \n-  size_t i;\n-  size_t num_ctf_types = tu_ctfc->ctfc_types->elements ();\n-\n   holes.create (0);\n   voids.create (0);\n \n   num_types_added = 0;\n   num_types_created = 0;\n \n+  /* Workaround for 'const void' variables.  These variables are sometimes used\n+     in eBPF programs to address kernel symbols.  DWARF does not generate const\n+     qualifier on void type, so we would incorrectly emit these variables\n+     without the const qualifier.\n+     Unfortunately we need the TREE node to know it was const, and we need\n+     to create the const modifier type (if needed) now, before making the types\n+     list.  So we can't avoid iterating with FOR_EACH_VARIABLE here, and then\n+     again when creating the DATASEC entries.  */\n+  ctf_id_t constvoid_id = CTF_NULL_TYPEID;\n+  varpool_node *var;\n+  FOR_EACH_VARIABLE (var)\n+    {\n+      if (!var->decl)\n+\tcontinue;\n+\n+      tree type = TREE_TYPE (var->decl);\n+      if (type && VOID_TYPE_P (type) && TYPE_READONLY (type))\n+\t{\n+\t  dw_die_ref die = lookup_decl_die (var->decl);\n+\t  if (die == NULL)\n+\t    continue;\n+\n+\t  ctf_dvdef_ref dvd = ctf_dvd_lookup (tu_ctfc, die);\n+\t  if (dvd == NULL)\n+\t    continue;\n+\n+\t  /* Create the 'const' modifier type for void.  */\n+\t  if (constvoid_id == CTF_NULL_TYPEID)\n+\t    constvoid_id = ctf_add_reftype (tu_ctfc, CTF_ADD_ROOT,\n+\t\t\t\t\t    dvd->dvd_type, CTF_K_CONST, NULL);\n+\t  dvd->dvd_type = constvoid_id;\n+\t}\n+    }\n+\n+  size_t i;\n+  size_t num_ctf_types = tu_ctfc->ctfc_types->elements ();\n+\n   if (num_ctf_types)\n     {\n       init_btf_id_map (num_ctf_types + 1);"}, {"sha": "f90fa773a4bedf06d1f88be8ff697618919e2960", "filename": "gcc/testsuite/gcc.dg/debug/btf/btf-pr106773.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f7aa145b796c044526c93f390e68f3b56a1b30a/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fbtf%2Fbtf-pr106773.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f7aa145b796c044526c93f390e68f3b56a1b30a/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fbtf%2Fbtf-pr106773.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fbtf%2Fbtf-pr106773.c?ref=4f7aa145b796c044526c93f390e68f3b56a1b30a", "patch": "@@ -0,0 +1,25 @@\n+/* Test BTF generation for extern const void symbols.\n+   BTF_KIND_VAR records should be emitted for such symbols if they are used,\n+   as well as a corresponding entry in the appropriate DATASEC record.  */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-O0 -gbtf -dA\" } */\n+\n+/* Expect 1 variable record only for foo, with 'extern' (2) linkage.  */\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]0xe000000\\[\\t \\]+\\[^\\n\\]*btv_info\" 1 } } */\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]0x2\\[\\t \\]+\\[^\\n\\]*btv_linkage\" 1 } } */\n+\n+/* { dg-final { scan-assembler-times \"ascii \\\"foo.0\\\"\\[\\t \\]+\\[^\\n\\]*btf_string\" 1 } } */\n+\n+/* { dg-final { scan-assembler-times \"0\\[\\t \\]+\\[^\\n\\]*bts_offset\" 1 } } */\n+/* { dg-final { scan-assembler-times \"1\\[\\t \\]+\\[^\\n\\]*bts_size\" 1 } } */\n+\n+extern const void foo __attribute__((weak)) __attribute__((section (\".ksyms\")));\n+extern const void bar __attribute__((weak)) __attribute__((section (\".ksyms\")));\n+\n+unsigned long func () {\n+  unsigned long x = (unsigned long) &foo;\n+\n+  return x;\n+}\n+"}]}