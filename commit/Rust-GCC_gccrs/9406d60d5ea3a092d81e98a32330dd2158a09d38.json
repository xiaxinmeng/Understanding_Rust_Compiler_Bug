{"sha": "9406d60d5ea3a092d81e98a32330dd2158a09d38", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTQwNmQ2MGQ1ZWEzYTA5MmQ4MWU5OGEzMjMzMGRkMjE1OGEwOWQzOA==", "commit": {"author": {"name": "Michael Matz", "email": "matz@gcc.gnu.org", "date": "2002-07-16T13:36:30Z"}, "committer": {"name": "Michael Matz", "email": "matz@gcc.gnu.org", "date": "2002-07-16T13:36:30Z"}, "message": "Add a new register allocator.\n\n\t* ra.c: New file.\n\t* ra.h: New file.\n\t* ra-build.c: New file.\n\t* ra-colorize.c: New file.\n\t* ra-debug.c: New file.\n\t* ra-rewrite.c: New file.\n\n\t* Makefile.in (ra.o, ra-build.o, ra-colorize.o, ra-debug.o,\n\t(ra-rewrite.o): New .o files for libbackend.a.\n\t(GTFILES): Add basic-block.h.\n\n\t* toplev.c (flag_new_regalloc): New.\n\t(f_options): New option \"new-ra\".\n\t(rest_of_compilation): Call initialize_uninitialized_subregs()\n\tonly for the old allocator.  If flag_new_regalloc is set, call\n\tnew allocator, instead of local_alloc(), global_alloc() and\n\tfriends.\n\n\t* doc/invoke.texi: Document -fnew-ra.\n\t* basic-block.h (FOR_ALL_BB): New.\n\t* config/rs6000/rs6000.c (print_operand): Write small constants\n\tas @l+80.\n\n\t* df.c (read_modify_subreg_p): Narrow down cases for a rmw subreg.\n\t(df_reg_table_realloc): Make size at least as large as max_reg_num().\n\t(df_insn_table_realloc): Size argument now is absolute, not relative.\n\tChanged all callers.\n\n\t* gengtype.c (main): Add the pseudo-type \"HARD_REG_SET\".\n\t* regclass.c (reg_scan_mark_refs): Ignore NULL rtx's.\n\n\t2002-06-20  Michael Matz  <matz@suse.de>\n\n\t* df.h (struct ref.id): Make unsigned.\n\t* df.c (df_bb_reg_def_chain_create): Remove unsigned cast.\n\n\t2002-06-13  Michael Matz  <matz@suse.de>\n\n\t* df.h (DF_REF_MODE_CHANGE): New flag.\n\t* df.c (df_def_record_1, df_uses_record): Set this flag for refs\n\tinvolving subregs with invalid mode changes, when\n\tCLASS_CANNOT_CHANGE_MODE is defined.\n\n\t2002-05-07  Michael Matz  <matz@suse.de>\n\n\t* reload1.c (fixup_abnormal_edges): Don't insert on NULL edge.\n\n\t2002-05-03  Michael Matz  <matz@suse.de>\n\n\t* sbitmap.c (sbitmap_difference): Accept sbitmaps of different size.\n\n\tSat Feb  2 18:58:07 2002  Denis Chertykov  <denisc@overta.ru>\n\n\t* regclass.c (regclass): Work with all regs which have sets or\n\trefs.\n\t(reg_scan_mark_refs): Count regs inside (clobber ...).\n\n\t2002-01-04  Michael Matz  <matzmich@cs.tu-berlin.de>\n\n\t* df.c (df_ref_record): Correctly calculate SUBREGs of hardregs.\n\t(df_bb_reg_def_chain_create, df_bb_reg_use_chain_create): Only\n\tadd new refs.\n\t(df_bb_refs_update): Don't clear insns_modified here, ...\n\t(df_analyse): ... but here.\n\n\t* sbitmap.c (dump_sbitmap_file): New.\n\t(debug_sbitmap): Use it.\n\n\t* sbitmap.h (dump_sbitmap_file): Add prototype.\n\n\t2001-08-07  Daniel Berlin  <dan@cgsoftware.com>\n\n\t* df.c (df_insn_modify): Grow the UID table if necessary, rather\n\tthan assume all emits go through df_insns_modify.\n\n\t2001-07-26  Daniel Berlin  <dan@cgsoftware.com>\n\n\t* regclass.c (reg_scan_mark_refs): When we increase REG_N_SETS,\n\tincrease REG_N_REFS (like flow does), so that regclass doesn't\n\tthink a reg is useless, and thus, not calculate a class, when it\n\treally should have.\n\n\t2001-01-28  Daniel Berlin  <dberlin@redhat.com>\n\n\t* sbitmap.h (EXECUTE_IF_SET_IN_SBITMAP_REV): New macro, needed for\n\tdataflow analysis.\n\nFrom-SVN: r55485", "tree": {"sha": "1b0486e550160f809a3abbe6daf1be6b5650785f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1b0486e550160f809a3abbe6daf1be6b5650785f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9406d60d5ea3a092d81e98a32330dd2158a09d38", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9406d60d5ea3a092d81e98a32330dd2158a09d38", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9406d60d5ea3a092d81e98a32330dd2158a09d38", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9406d60d5ea3a092d81e98a32330dd2158a09d38/comments", "author": null, "committer": null, "parents": [{"sha": "e0b89be2e2ed70e5001cc39529d7425e4d58dc2e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0b89be2e2ed70e5001cc39529d7425e4d58dc2e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e0b89be2e2ed70e5001cc39529d7425e4d58dc2e"}], "stats": {"total": 88, "additions": 71, "deletions": 17}, "files": [{"sha": "7b8b85e8fca165a33042ecc2e39f96f6719633eb", "filename": "gcc/df.c", "status": "modified", "additions": 71, "deletions": 17, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9406d60d5ea3a092d81e98a32330dd2158a09d38/gcc%2Fdf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9406d60d5ea3a092d81e98a32330dd2158a09d38/gcc%2Fdf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf.c?ref=9406d60d5ea3a092d81e98a32330dd2158a09d38", "patch": "@@ -311,17 +311,20 @@ static inline bool read_modify_subreg_p PARAMS ((rtx));\n /* Local memory allocation/deallocation routines.  */\n \n \n-/* Increase the insn info table by SIZE more elements.  */\n+/* Increase the insn info table to have space for at least SIZE + 1\n+   elements.  */\n static void\n df_insn_table_realloc (df, size)\n      struct df *df;\n      int size;\n {\n-  /* Make table 25 percent larger by default.  */\n-  if (! size)\n-    size = df->insn_size / 4;\n+  size++;\n+  if (size <= df->insn_size)\n+    return;\n \n-  size += df->insn_size;\n+  /* Make the table a little larger than requested, so we don't need\n+     to enlarge it so often.  */\n+  size += df->insn_size / 4;\n \n   df->insns = (struct insn_info *)\n     xrealloc (df->insns, size * sizeof (struct insn_info));\n@@ -350,6 +353,8 @@ df_reg_table_realloc (df, size)\n     size = df->reg_size / 4;\n \n   size += df->reg_size;\n+  if (size < max_reg_num ())\n+    size = max_reg_num ();\n \n   df->regs = (struct reg_info *)\n     xrealloc (df->regs, size * sizeof (struct reg_info));\n@@ -892,7 +897,11 @@ df_ref_record (df, reg, loc, insn, ref_type, ref_flags)\n \t are really referenced.  E.g. a (subreg:SI (reg:DI 0) 0) does _not_\n \t reference the whole reg 0 in DI mode (which would also include\n \t reg 1, at least, if 0 and 1 are SImode registers).  */\n-      endregno = regno + HARD_REGNO_NREGS (regno, GET_MODE (reg));\n+      endregno = HARD_REGNO_NREGS (regno, GET_MODE (reg));\n+      if (GET_CODE (reg) == SUBREG)\n+        regno += subreg_regno_offset (regno, GET_MODE (SUBREG_REG (reg)),\n+\t\t\t\t      SUBREG_BYTE (reg), GET_MODE (reg));\n+      endregno += regno;\n \n       for (i = regno; i < endregno; i++)\n \tdf_ref_record_1 (df, regno_reg_rtx[i],\n@@ -904,18 +913,23 @@ df_ref_record (df, reg, loc, insn, ref_type, ref_flags)\n     }\n }\n \n-/* Writes to SUBREG of inndermode wider than word and outermode shorter than\n-   word are read-modify-write.  */\n+/* Writes to paradoxical subregs, or subregs which are too narrow\n+   are read-modify-write.  */\n \n static inline bool\n read_modify_subreg_p (x)\n      rtx x;\n {\n+  unsigned int isize, osize;\n   if (GET_CODE (x) != SUBREG)\n     return false;\n-  if (GET_MODE_SIZE (GET_MODE (SUBREG_REG (x))) <= UNITS_PER_WORD)\n+  isize = GET_MODE_SIZE (GET_MODE (SUBREG_REG (x)));\n+  osize = GET_MODE_SIZE (GET_MODE (x));\n+  if (isize <= osize)\n+    return true;\n+  if (isize <= UNITS_PER_WORD)\n     return false;\n-  if (GET_MODE_SIZE (GET_MODE (x)) > UNITS_PER_WORD)\n+  if (osize >= UNITS_PER_WORD)\n     return false;\n   return true;\n }\n@@ -943,6 +957,13 @@ df_def_record_1 (df, x, bb, insn)\n       return;\n     }\n \n+#ifdef CLASS_CANNOT_CHANGE_MODE\n+  if (GET_CODE (dst) == SUBREG\n+      && CLASS_CANNOT_CHANGE_MODE_P (GET_MODE (dst),\n+\t\t\t\t     GET_MODE (SUBREG_REG (dst))))\n+    flags |= DF_REF_MODE_CHANGE;\n+#endif\n+\n   /* May be, we should flag the use of strict_low_part somehow.  Might be\n      handy for the reg allocator.  */\n   while (GET_CODE (dst) == STRICT_LOW_PART\n@@ -957,6 +978,12 @@ df_def_record_1 (df, x, bb, insn)\n \t  loc = &XEXP (dst, 0);\n \t  dst = *loc;\n \t}\n+#ifdef CLASS_CANNOT_CHANGE_MODE\n+      if (GET_CODE (dst) == SUBREG\n+\t  && CLASS_CANNOT_CHANGE_MODE_P (GET_MODE (dst),\n+\t\t\t\t         GET_MODE (SUBREG_REG (dst))))\n+        flags |= DF_REF_MODE_CHANGE;\n+#endif\n       loc = &XEXP (dst, 0);\n       dst = *loc;\n       flags |= DF_REF_READ_WRITE;\n@@ -1052,6 +1079,11 @@ df_uses_record (df, loc, ref_type, bb, insn, flags)\n \t  df_uses_record (df, loc, ref_type, bb, insn, flags);\n \t  return;\n \t}\n+#ifdef CLASS_CANNOT_CHANGE_MODE\n+      if (CLASS_CANNOT_CHANGE_MODE_P (GET_MODE (x),\n+\t\t\t\t      GET_MODE (SUBREG_REG (x))))\n+        flags |= DF_REF_MODE_CHANGE;\n+#endif\n \n       /* ... Fall through ...  */\n \n@@ -1068,16 +1100,24 @@ df_uses_record (df, loc, ref_type, bb, insn, flags)\n \n \tswitch (GET_CODE (dst))\n \t  {\n+\t    enum df_ref_flags use_flags;\n \t    case SUBREG:\n \t      if (read_modify_subreg_p (dst))\n \t\t{\n+\t\t  use_flags = DF_REF_READ_WRITE;\n+#ifdef CLASS_CANNOT_CHANGE_MODE\n+\t\t  if (CLASS_CANNOT_CHANGE_MODE_P (GET_MODE (dst),\n+\t\t\t\t\t\t  GET_MODE (SUBREG_REG (dst))))\n+\t\t    use_flags |= DF_REF_MODE_CHANGE;\n+#endif\n \t\t  df_uses_record (df, &SUBREG_REG (dst), DF_REF_REG_USE, bb,\n-\t\t\t\t  insn, DF_REF_READ_WRITE);\n+\t\t\t\t  insn, use_flags);\n \t\t  break;\n \t\t}\n \t      /* ... FALLTHRU ...  */\n \t    case REG:\n \t    case PC:\n+\t    case PARALLEL:\n \t      break;\n \t    case MEM:\n \t      df_uses_record (df, &XEXP (dst, 0),\n@@ -1089,8 +1129,14 @@ df_uses_record (df, loc, ref_type, bb, insn, flags)\n \t      dst = XEXP (dst, 0);\n \t      if (GET_CODE (dst) != SUBREG)\n \t\tabort ();\n+\t      use_flags = DF_REF_READ_WRITE;\n+#ifdef CLASS_CANNOT_CHANGE_MODE\n+\t      if (CLASS_CANNOT_CHANGE_MODE_P (GET_MODE (dst),\n+\t\t\t\t\t      GET_MODE (SUBREG_REG (dst))))\n+\t\tuse_flags |= DF_REF_MODE_CHANGE;\n+#endif\n \t      df_uses_record (df, &SUBREG_REG (dst), DF_REF_REG_USE, bb,\n-\t\t\t     insn, DF_REF_READ_WRITE);\n+\t\t\t     insn, use_flags);\n \t      break;\n \t    case ZERO_EXTRACT:\n \t    case SIGN_EXTRACT:\n@@ -1345,6 +1391,11 @@ df_bb_reg_def_chain_create (df, bb)\n \t{\n \t  struct ref *def = link->ref;\n \t  unsigned int dregno = DF_REF_REGNO (def);\n+          /* Don't add ref's to the chain two times.  I.e. only add\n+             new refs.  XXX the same could be done by testing if the current\n+             insn is a modified (or a new) one.  This would be faster.  */\n+          if (DF_REF_ID (def) < df->def_id_save)\n+            continue;\n \n \t  df->regs[dregno].defs\n \t    = df_link_create (def, df->regs[dregno].defs);\n@@ -1394,6 +1445,11 @@ df_bb_reg_use_chain_create (df, bb)\n \t{\n \t  struct ref *use = link->ref;\n \t  unsigned int uregno = DF_REF_REGNO (use);\n+          /* Don't add ref's to the chain two times.  I.e. only add\n+             new refs.  XXX the same could be done by testing if the current\n+             insn is a modified (or a new) one.  This would be faster.  */\n+          if (DF_REF_ID (use) < df->use_id_save)\n+            continue;\n \n \t  df->regs[uregno].uses\n \t    = df_link_create (use, df->regs[uregno].uses);\n@@ -2218,8 +2274,6 @@ df_bb_refs_update (df, bb)\n \t  /* Scan the insn for refs.  */\n \t  df_insn_refs_record (df, bb, insn);\n \n-\n-\t  bitmap_clear_bit (df->insns_modified, uid);\n \t  count++;\n \t}\n       if (insn == bb->end)\n@@ -2318,6 +2372,7 @@ df_analyse (df, blocks, flags)\n \n \t  df_analyse_1 (df, blocks, flags, 1);\n \t  bitmap_zero (df->bbs_modified);\n+\t  bitmap_zero (df->insns_modified);\n \t}\n     }\n   return update;\n@@ -2445,9 +2500,8 @@ df_insn_modify (df, bb, insn)\n   unsigned int uid;\n \n   uid = INSN_UID (insn);\n-\n   if (uid >= df->insn_size)\n-    df_insn_table_realloc (df, 0);\n+    df_insn_table_realloc (df, uid);\n \n   bitmap_set_bit (df->bbs_modified, bb->index);\n   bitmap_set_bit (df->insns_modified, uid);\n@@ -2734,7 +2788,7 @@ df_insns_modify (df, bb, first_insn, last_insn)\n       uid = INSN_UID (insn);\n \n       if (uid >= df->insn_size)\n-\tdf_insn_table_realloc (df, 0);\n+\tdf_insn_table_realloc (df, uid);\n \n       df_insn_modify (df, bb, insn);\n "}]}