{"sha": "d12d8efea8fcb3122b78b3eafb7e35fe7ec2f4bd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDEyZDhlZmVhOGZjYjMxMjJiNzhiM2VhZmI3ZTM1ZmU3ZWMyZjRiZA==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2011-05-30T09:19:58Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2011-05-30T09:19:58Z"}, "message": "tree-ssa-forwprop.c (forward_propagate_into_comparison): New function split out from ...\n\n2011-05-30  Richard Guenther  <rguenther@suse.de>\n\n\t* tree-ssa-forwprop.c (forward_propagate_into_comparison):\n\tNew function split out from ...\n\t(forward_propagate_into_gimple_cond): ... here.  Adjust.\n\t(forward_propagate_into_cond): Likewise.\n\t(forward_propagate_comparison): Also propagate into\n\tcomparisons on assignment RHS.  Change return value to\n\tbehave similar to forward_propagate_into_cond.\n\t(tree_ssa_forward_propagate_single_use_vars): Handle\n\tstrict-overflow warnings properly for forward_propagate_comparison.\n\nFrom-SVN: r174428", "tree": {"sha": "a787d0d8161ab475fc5a672ebe57020ae15b9262", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a787d0d8161ab475fc5a672ebe57020ae15b9262"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d12d8efea8fcb3122b78b3eafb7e35fe7ec2f4bd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d12d8efea8fcb3122b78b3eafb7e35fe7ec2f4bd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d12d8efea8fcb3122b78b3eafb7e35fe7ec2f4bd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d12d8efea8fcb3122b78b3eafb7e35fe7ec2f4bd/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "df33b41f117cd769424e9f0d5a393c9d714f189d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df33b41f117cd769424e9f0d5a393c9d714f189d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/df33b41f117cd769424e9f0d5a393c9d714f189d"}], "stats": {"total": 424, "additions": 222, "deletions": 202}, "files": [{"sha": "55522d6d85efda519120e2eaafe685cb25f94663", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d12d8efea8fcb3122b78b3eafb7e35fe7ec2f4bd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d12d8efea8fcb3122b78b3eafb7e35fe7ec2f4bd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d12d8efea8fcb3122b78b3eafb7e35fe7ec2f4bd", "patch": "@@ -1,3 +1,15 @@\n+2011-05-30  Richard Guenther  <rguenther@suse.de>\n+\n+\t* tree-ssa-forwprop.c (forward_propagate_into_comparison):\n+\tNew function split out from ...\n+\t(forward_propagate_into_gimple_cond): ... here.  Adjust.\n+\t(forward_propagate_into_cond): Likewise.\n+\t(forward_propagate_comparison): Also propagate into\n+\tcomparisons on assignment RHS.  Change return value to\n+\tbehave similar to forward_propagate_into_cond.\n+\t(tree_ssa_forward_propagate_single_use_vars): Handle\n+\tstrict-overflow warnings properly for forward_propagate_comparison.\n+\n 2011-05-30  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n \n \t* configure.ac (gcc_cv_lto_plugin): Determine lto plugin support"}, {"sha": "ddc1ac4187d62c84d29fb8e37b81219d45635277", "filename": "gcc/tree-ssa-forwprop.c", "status": "modified", "additions": 210, "deletions": 202, "changes": 412, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d12d8efea8fcb3122b78b3eafb7e35fe7ec2f4bd/gcc%2Ftree-ssa-forwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d12d8efea8fcb3122b78b3eafb7e35fe7ec2f4bd/gcc%2Ftree-ssa-forwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-forwprop.c?ref=d12d8efea8fcb3122b78b3eafb7e35fe7ec2f4bd", "patch": "@@ -387,6 +387,195 @@ combine_cond_expr_cond (location_t loc, enum tree_code code, tree type,\n   return t;\n }\n \n+/* Combine the comparison OP0 CODE OP1 at LOC with the defining statements\n+   of its operand.  Return a new comparison tree or NULL_TREE if there\n+   were no simplifying combines.  */\n+\n+static tree\n+forward_propagate_into_comparison (location_t loc,\n+\t\t\t\t   enum tree_code code, tree type,\n+\t\t\t\t   tree op0, tree op1)\n+{\n+  tree tmp = NULL_TREE;\n+  tree rhs0 = NULL_TREE, rhs1 = NULL_TREE;\n+  bool single_use0_p = false, single_use1_p = false;\n+\n+  /* For comparisons use the first operand, that is likely to\n+     simplify comparisons against constants.  */\n+  if (TREE_CODE (op0) == SSA_NAME)\n+    {\n+      gimple def_stmt = get_prop_source_stmt (op0, false, &single_use0_p);\n+      if (def_stmt && can_propagate_from (def_stmt))\n+\t{\n+\t  rhs0 = rhs_to_tree (TREE_TYPE (op1), def_stmt);\n+\t  tmp = combine_cond_expr_cond (loc, code, type,\n+\t\t\t\t\trhs0, op1, !single_use0_p);\n+\t  if (tmp)\n+\t    return tmp;\n+\t}\n+    }\n+\n+  /* If that wasn't successful, try the second operand.  */\n+  if (TREE_CODE (op1) == SSA_NAME)\n+    {\n+      gimple def_stmt = get_prop_source_stmt (op1, false, &single_use1_p);\n+      if (def_stmt && can_propagate_from (def_stmt))\n+\t{\n+\t  rhs1 = rhs_to_tree (TREE_TYPE (op0), def_stmt);\n+\t  tmp = combine_cond_expr_cond (loc, code, type,\n+\t\t\t\t\top0, rhs1, !single_use1_p);\n+\t  if (tmp)\n+\t    return tmp;\n+\t}\n+    }\n+\n+  /* If that wasn't successful either, try both operands.  */\n+  if (rhs0 != NULL_TREE\n+      && rhs1 != NULL_TREE)\n+    tmp = combine_cond_expr_cond (loc, code, type,\n+\t\t\t\t  rhs0, rhs1,\n+\t\t\t\t  !(single_use0_p && single_use1_p));\n+\n+  return tmp;\n+}\n+\n+/* Forward propagate the comparison defined in STMT like\n+   cond_1 = x CMP y to uses of the form\n+     a_1 = (T')cond_1\n+     a_1 = !cond_1\n+     a_1 = cond_1 != 0\n+   Returns 1 if a transformation was done and 2 if the CFG should\n+   be cleaned up.  Else returns 0.  */\n+\n+static int \n+forward_propagate_comparison (gimple stmt)\n+{\n+  tree name = gimple_assign_lhs (stmt);\n+  gimple use_stmt;\n+  tree tmp = NULL_TREE;\n+  int did_something = 0;\n+\n+  /* Combine the comparison with defining statements.  */\n+  do\n+    {\n+      tmp = forward_propagate_into_comparison (gimple_location (stmt),\n+\t\t\t\t\t       gimple_assign_rhs_code (stmt),\n+\t\t\t\t\t       TREE_TYPE (name),\n+\t\t\t\t\t       gimple_assign_rhs1 (stmt),\n+\t\t\t\t\t       gimple_assign_rhs2 (stmt));\n+      if (tmp)\n+\t{\n+\t  gimple_stmt_iterator gsi = gsi_for_stmt (stmt);\n+\t  bool inv = is_gimple_min_invariant (tmp);\n+\t  gimple_assign_set_rhs_from_tree (&gsi, tmp);\n+\t  gcc_assert (gsi_stmt (gsi) == stmt);\n+\t  update_stmt (stmt);\n+\t  did_something = MAX (did_something, inv ? 2 : 1);\n+\t  if (TREE_CODE_CLASS (gimple_assign_rhs_code (stmt)) != tcc_comparison)\n+\t    return did_something;\n+\t}\n+    }\n+  while (tmp);\n+\n+  /* Don't propagate ssa names that occur in abnormal phis.  */\n+  if ((TREE_CODE (gimple_assign_rhs1 (stmt)) == SSA_NAME\n+       && SSA_NAME_OCCURS_IN_ABNORMAL_PHI (gimple_assign_rhs1 (stmt)))\n+      || (TREE_CODE (gimple_assign_rhs2 (stmt)) == SSA_NAME\n+        && SSA_NAME_OCCURS_IN_ABNORMAL_PHI (gimple_assign_rhs2 (stmt))))\n+    return did_something;\n+\n+  /* Do not un-cse comparisons.  But propagate through copies.  */\n+  use_stmt = get_prop_dest_stmt (name, &name);\n+  if (!use_stmt)\n+    return did_something;\n+\n+  /* Conversion of the condition result to another integral type.  */\n+  if (is_gimple_assign (use_stmt)\n+      && (CONVERT_EXPR_CODE_P (gimple_assign_rhs_code (use_stmt))\n+\t  || TREE_CODE_CLASS (gimple_assign_rhs_code (use_stmt))\n+\t     == tcc_comparison\n+          || gimple_assign_rhs_code (use_stmt) == TRUTH_NOT_EXPR)\n+      && INTEGRAL_TYPE_P (TREE_TYPE (gimple_assign_lhs (use_stmt))))\n+    {\n+      tree lhs = gimple_assign_lhs (use_stmt);\n+\n+      /* We can propagate the condition into a conversion.  */\n+      if (CONVERT_EXPR_CODE_P (gimple_assign_rhs_code (use_stmt)))\n+\t{\n+\t  /* Avoid using fold here as that may create a COND_EXPR with\n+\t     non-boolean condition as canonical form.  */\n+\t  tmp = build2 (gimple_assign_rhs_code (stmt), TREE_TYPE (lhs),\n+                        gimple_assign_rhs1 (stmt), gimple_assign_rhs2 (stmt));\n+\t}\n+      /* We can propagate the condition into X op CST where op\n+\t is EQ_EXPR or NE_EXPR and CST is either one or zero.  */\n+      else if (TREE_CODE_CLASS (gimple_assign_rhs_code (use_stmt))\n+              == tcc_comparison\n+             && TREE_CODE (gimple_assign_rhs1 (use_stmt)) == SSA_NAME\n+             && TREE_CODE (gimple_assign_rhs2 (use_stmt)) == INTEGER_CST)\n+      {\n+        enum tree_code code = gimple_assign_rhs_code (use_stmt);\n+        tree cst = gimple_assign_rhs2 (use_stmt);\n+\ttree cond;\n+\n+\tcond = build2 (gimple_assign_rhs_code (stmt),\n+\t\t       TREE_TYPE (cst),\n+\t\t       gimple_assign_rhs1 (stmt),\n+\t\t       gimple_assign_rhs2 (stmt));\n+\n+        tmp = combine_cond_expr_cond (gimple_location (use_stmt),\n+\t\t\t\t      code, TREE_TYPE (lhs),\n+\t\t\t\t      cond, cst, false);\n+        if (tmp == NULL_TREE)\n+          return did_something;\n+      }\n+      /* We can propagate the condition into a statement that\n+\t computes the logical negation of the comparison result.  */\n+      else if (gimple_assign_rhs_code (use_stmt) == TRUTH_NOT_EXPR)\n+\t{\n+\t  tree type = TREE_TYPE (gimple_assign_rhs1 (stmt));\n+\t  bool nans = HONOR_NANS (TYPE_MODE (type));\n+\t  enum tree_code code;\n+\t  code = invert_tree_comparison (gimple_assign_rhs_code (stmt), nans);\n+\t  if (code == ERROR_MARK)\n+\t    return did_something;\n+\n+\t  tmp = build2 (code, TREE_TYPE (lhs), gimple_assign_rhs1 (stmt),\n+                        gimple_assign_rhs2 (stmt));\n+\t}\n+      else\n+\treturn did_something;\n+\n+      {\n+\tgimple_stmt_iterator gsi = gsi_for_stmt (use_stmt);\n+\tbool inv = is_gimple_min_invariant (tmp);\n+\tgimple_assign_set_rhs_from_tree (&gsi, unshare_expr (tmp));\n+\tdid_something = MAX (did_something, inv ? 2 : 1);\n+\tuse_stmt = gsi_stmt (gsi);\n+\tupdate_stmt (use_stmt);\n+      }\n+\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t{\n+\t  tree old_rhs = rhs_to_tree (TREE_TYPE (gimple_assign_lhs (stmt)),\n+                                      stmt);\n+\t  fprintf (dump_file, \"  Replaced '\");\n+\t  print_generic_expr (dump_file, old_rhs, dump_flags);\n+\t  fprintf (dump_file, \"' with '\");\n+\t  print_generic_expr (dump_file, tmp, dump_flags);\n+\t  fprintf (dump_file, \"'\\n\");\n+\t}\n+\n+      /* Remove defining statements.  */\n+      if (remove_prop_source_from_use (name))\n+\tdid_something = 2;\n+      else\n+\tdid_something = MAX (did_something, 1);\n+    }\n+\n+  return did_something;\n+}\n+\n /* Propagate from the ssa name definition statements of COND_EXPR\n    in GIMPLE_COND statement STMT into the conditional if that simplifies it.\n    Returns zero if no statement was changed, one if there were\n@@ -402,52 +591,14 @@ forward_propagate_into_gimple_cond (gimple stmt)\n \n   do {\n     tree tmp = NULL_TREE;\n-    tree name = NULL_TREE, rhs0 = NULL_TREE, rhs1 = NULL_TREE;\n-    gimple def_stmt;\n-    bool single_use0_p = false, single_use1_p = false;\n     enum tree_code code = gimple_cond_code (stmt);\n \n     /* We can do tree combining on SSA_NAME and comparison expressions.  */\n     if (TREE_CODE_CLASS (gimple_cond_code (stmt)) == tcc_comparison)\n-      {\n-\t/* For comparisons use the first operand, that is likely to\n-\t   simplify comparisons against constants.  */\n-\tif (TREE_CODE (gimple_cond_lhs (stmt)) == SSA_NAME)\n-\t  {\n-\t    name = gimple_cond_lhs (stmt);\n-\t    def_stmt = get_prop_source_stmt (name, false, &single_use0_p);\n-\t    if (def_stmt && can_propagate_from (def_stmt))\n-\t      {\n-\t\ttree op1 = gimple_cond_rhs (stmt);\n-\t\trhs0 = rhs_to_tree (TREE_TYPE (op1), def_stmt);\n-\t\ttmp = combine_cond_expr_cond (loc, code, boolean_type_node,\n-\t\t\t\t\t      rhs0, op1, !single_use0_p);\n-\t      }\n-\t  }\n-\t/* If that wasn't successful, try the second operand.  */\n-\tif (tmp == NULL_TREE\n-\t    && TREE_CODE (gimple_cond_rhs (stmt)) == SSA_NAME)\n-\t  {\n-\t    tree op0 = gimple_cond_lhs (stmt);\n-\t    name = gimple_cond_rhs (stmt);\n-\t    def_stmt = get_prop_source_stmt (name, false, &single_use1_p);\n-\t    if (!def_stmt || !can_propagate_from (def_stmt))\n-\t      return did_something;\n-\n-\t    rhs1 = rhs_to_tree (TREE_TYPE (op0), def_stmt);\n-\t    tmp = combine_cond_expr_cond (loc, code, boolean_type_node, op0,\n-\t\t\t\t\t  rhs1, !single_use1_p);\n-\t  }\n-\t/* If that wasn't successful either, try both operands.  */\n-\tif (tmp == NULL_TREE\n-\t    && rhs0 != NULL_TREE\n-\t    && rhs1 != NULL_TREE)\n-\t  tmp = combine_cond_expr_cond (loc, code, boolean_type_node, rhs0,\n-\t\t\t\t\tfold_convert_loc (loc,\n-\t\t\t\t\t\t\t  TREE_TYPE (rhs0),\n-\t\t\t\t\t\t\t  rhs1),\n-\t\t\t\t\t!(single_use0_p && single_use1_p));\n-      }\n+      tmp = forward_propagate_into_comparison (loc, code,\n+\t\t\t\t\t       boolean_type_node,\n+\t\t\t\t\t       gimple_cond_lhs (stmt),\n+\t\t\t\t\t       gimple_cond_rhs (stmt));\n \n     if (tmp)\n       {\n@@ -468,8 +619,7 @@ forward_propagate_into_gimple_cond (gimple stmt)\n \tupdate_stmt (stmt);\n \n \t/* Remove defining statements.  */\n-\tif (remove_prop_source_from_use (name)\n-\t    || is_gimple_min_invariant (tmp))\n+\tif (is_gimple_min_invariant (tmp))\n \t  did_something = 2;\n \telse if (did_something == 0)\n \t  did_something = 1;\n@@ -502,57 +652,17 @@ forward_propagate_into_cond (gimple_stmt_iterator *gsi_p)\n   do {\n     tree tmp = NULL_TREE;\n     tree cond = gimple_assign_rhs1 (stmt);\n-    tree name, rhs0 = NULL_TREE, rhs1 = NULL_TREE;\n-    gimple def_stmt;\n-    bool single_use0_p = false, single_use1_p = false;\n \n     /* We can do tree combining on SSA_NAME and comparison expressions.  */\n-    if (COMPARISON_CLASS_P (cond)\n-\t&& TREE_CODE (TREE_OPERAND (cond, 0)) == SSA_NAME)\n-      {\n-\t/* For comparisons use the first operand, that is likely to\n-\t   simplify comparisons against constants.  */\n-\tname = TREE_OPERAND (cond, 0);\n-\tdef_stmt = get_prop_source_stmt (name, false, &single_use0_p);\n-\tif (def_stmt && can_propagate_from (def_stmt))\n-\t  {\n-\t    tree op1 = TREE_OPERAND (cond, 1);\n-\t    rhs0 = rhs_to_tree (TREE_TYPE (op1), def_stmt);\n-\t    tmp = combine_cond_expr_cond (loc, TREE_CODE (cond),\n-\t\t\t\t\t  boolean_type_node,\n-\t\t\t\t\t  rhs0, op1, !single_use0_p);\n-\t  }\n-\t/* If that wasn't successful, try the second operand.  */\n-\tif (tmp == NULL_TREE\n-\t    && TREE_CODE (TREE_OPERAND (cond, 1)) == SSA_NAME)\n-\t  {\n-\t    tree op0 = TREE_OPERAND (cond, 0);\n-\t    name = TREE_OPERAND (cond, 1);\n-\t    def_stmt = get_prop_source_stmt (name, false, &single_use1_p);\n-\t    if (!def_stmt || !can_propagate_from (def_stmt))\n-\t      return did_something;\n-\n-\t    rhs1 = rhs_to_tree (TREE_TYPE (op0), def_stmt);\n-\t    tmp = combine_cond_expr_cond (loc, TREE_CODE (cond),\n-\t\t\t\t\t  boolean_type_node,\n-\t\t\t\t\t  op0, rhs1, !single_use1_p);\n-\t  }\n-\t/* If that wasn't successful either, try both operands.  */\n-\tif (tmp == NULL_TREE\n-\t    && rhs0 != NULL_TREE\n-\t    && rhs1 != NULL_TREE)\n-\t  tmp = combine_cond_expr_cond (loc, TREE_CODE (cond),\n-\t\t\t\t\tboolean_type_node,\n-\t\t\t\t\trhs0,\n-\t\t\t\t\tfold_convert_loc (loc,\n-\t\t\t\t\t\t\t  TREE_TYPE (rhs0),\n-\t\t\t\t\t\t\t  rhs1),\n-\t\t\t\t\t!(single_use0_p && single_use1_p));\n-      }\n+    if (COMPARISON_CLASS_P (cond))\n+      tmp = forward_propagate_into_comparison (loc, TREE_CODE (cond),\n+\t\t\t\t\t       boolean_type_node,\n+\t\t\t\t\t       TREE_OPERAND (cond, 0),\n+\t\t\t\t\t       TREE_OPERAND (cond, 1));\n     else if (TREE_CODE (cond) == SSA_NAME)\n       {\n-\tname = cond;\n-\tdef_stmt = get_prop_source_stmt (name, true, NULL);\n+\ttree name = cond, rhs0;\n+\tgimple def_stmt = get_prop_source_stmt (name, true, NULL);\n \tif (!def_stmt || !can_propagate_from (def_stmt))\n \t  return did_something;\n \n@@ -578,8 +688,7 @@ forward_propagate_into_cond (gimple_stmt_iterator *gsi_p)\n \tupdate_stmt (stmt);\n \n \t/* Remove defining statements.  */\n-\tif (remove_prop_source_from_use (name)\n-\t    || is_gimple_min_invariant (tmp))\n+\tif (is_gimple_min_invariant (tmp))\n \t  did_something = 2;\n \telse if (did_something == 0)\n \t  did_something = 1;\n@@ -1115,114 +1224,6 @@ forward_propagate_addr_expr (tree name, tree rhs)\n   return all && has_zero_uses (name);\n }\n \n-/* Forward propagate the comparison defined in STMT like\n-   cond_1 = x CMP y to uses of the form\n-     a_1 = (T')cond_1\n-     a_1 = !cond_1\n-     a_1 = cond_1 != 0\n-   Returns true if stmt is now unused.  */\n-\n-static bool\n-forward_propagate_comparison (gimple stmt)\n-{\n-  tree name = gimple_assign_lhs (stmt);\n-  gimple use_stmt;\n-  tree tmp = NULL_TREE;\n-\n-  /* Don't propagate ssa names that occur in abnormal phis.  */\n-  if ((TREE_CODE (gimple_assign_rhs1 (stmt)) == SSA_NAME\n-       && SSA_NAME_OCCURS_IN_ABNORMAL_PHI (gimple_assign_rhs1 (stmt)))\n-      || (TREE_CODE (gimple_assign_rhs2 (stmt)) == SSA_NAME\n-        && SSA_NAME_OCCURS_IN_ABNORMAL_PHI (gimple_assign_rhs2 (stmt))))\n-    return false;\n-\n-  /* Do not un-cse comparisons.  But propagate through copies.  */\n-  use_stmt = get_prop_dest_stmt (name, &name);\n-  if (!use_stmt)\n-    return false;\n-\n-  /* Conversion of the condition result to another integral type.  */\n-  if (is_gimple_assign (use_stmt)\n-      && (CONVERT_EXPR_CODE_P (gimple_assign_rhs_code (use_stmt))\n-\t  || TREE_CODE_CLASS (gimple_assign_rhs_code (use_stmt))\n-\t     == tcc_comparison\n-          || gimple_assign_rhs_code (use_stmt) == TRUTH_NOT_EXPR)\n-      && INTEGRAL_TYPE_P (TREE_TYPE (gimple_assign_lhs (use_stmt))))\n-    {\n-      tree lhs = gimple_assign_lhs (use_stmt);\n-\n-      /* We can propagate the condition into a conversion.  */\n-      if (CONVERT_EXPR_CODE_P (gimple_assign_rhs_code (use_stmt)))\n-\t{\n-\t  /* Avoid using fold here as that may create a COND_EXPR with\n-\t     non-boolean condition as canonical form.  */\n-\t  tmp = build2 (gimple_assign_rhs_code (stmt), TREE_TYPE (lhs),\n-                        gimple_assign_rhs1 (stmt), gimple_assign_rhs2 (stmt));\n-\t}\n-      /* We can propagate the condition into X op CST where op\n-\t is EQ_EXPR or NE_EXPR and CST is either one or zero.  */\n-      else if (TREE_CODE_CLASS (gimple_assign_rhs_code (use_stmt))\n-              == tcc_comparison\n-             && TREE_CODE (gimple_assign_rhs1 (use_stmt)) == SSA_NAME\n-             && TREE_CODE (gimple_assign_rhs2 (use_stmt)) == INTEGER_CST)\n-      {\n-        enum tree_code code = gimple_assign_rhs_code (use_stmt);\n-        tree cst = gimple_assign_rhs2 (use_stmt);\n-\ttree cond;\n-\n-\tcond = build2 (gimple_assign_rhs_code (stmt),\n-\t\t       TREE_TYPE (cst),\n-\t\t       gimple_assign_rhs1 (stmt),\n-\t\t       gimple_assign_rhs2 (stmt));\n-\n-        tmp = combine_cond_expr_cond (gimple_location (use_stmt),\n-\t\t\t\t      code, TREE_TYPE (lhs),\n-\t\t\t\t      cond, cst, false);\n-        if (tmp == NULL_TREE)\n-          return false;\n-      }\n-      /* We can propagate the condition into a statement that\n-\t computes the logical negation of the comparison result.  */\n-      else if (gimple_assign_rhs_code (use_stmt) == TRUTH_NOT_EXPR)\n-\t{\n-\t  tree type = TREE_TYPE (gimple_assign_rhs1 (stmt));\n-\t  bool nans = HONOR_NANS (TYPE_MODE (type));\n-\t  enum tree_code code;\n-\t  code = invert_tree_comparison (gimple_assign_rhs_code (stmt), nans);\n-\t  if (code == ERROR_MARK)\n-\t    return false;\n-\n-\t  tmp = build2 (code, TREE_TYPE (lhs), gimple_assign_rhs1 (stmt),\n-                        gimple_assign_rhs2 (stmt));\n-\t}\n-      else\n-\treturn false;\n-\n-      {\n-\tgimple_stmt_iterator gsi = gsi_for_stmt (use_stmt);\n-\tgimple_assign_set_rhs_from_tree (&gsi, unshare_expr (tmp));\n-\tuse_stmt = gsi_stmt (gsi);\n-\tupdate_stmt (use_stmt);\n-      }\n-\n-      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t{\n-\t  tree old_rhs = rhs_to_tree (TREE_TYPE (gimple_assign_lhs (stmt)),\n-                                      stmt);\n-\t  fprintf (dump_file, \"  Replaced '\");\n-\t  print_generic_expr (dump_file, old_rhs, dump_flags);\n-\t  fprintf (dump_file, \"' with '\");\n-\t  print_generic_expr (dump_file, tmp, dump_flags);\n-\t  fprintf (dump_file, \"'\\n\");\n-\t}\n-\n-      /* Remove defining statements.  */\n-      return remove_prop_source_from_use (name);\n-    }\n-\n-  return false;\n-}\n-\n /* If we have lhs = ~x (STMT), look and see if earlier we had x = ~y.\n    If so, we can change STMT into lhs = y which can later be copy\n    propagated.  Similarly for negation.\n@@ -2314,8 +2315,15 @@ tree_ssa_forward_propagate_single_use_vars (void)\n                 }\n \t      else if (TREE_CODE_CLASS (code) == tcc_comparison)\n \t\t{\n-\t\t  if (forward_propagate_comparison (stmt))\n+\t\t  bool no_warning = gimple_no_warning_p (stmt);\n+\t\t  int did_something;\n+\t\t  fold_defer_overflow_warnings ();\n+\t\t  did_something = forward_propagate_comparison (stmt);\n+\t\t  if (did_something == 2)\n \t\t    cfg_changed = true;\n+\t\t  fold_undefer_overflow_warnings\n+\t\t    (!no_warning && did_something,\n+\t\t     stmt, WARN_STRICT_OVERFLOW_CONDITIONAL);\n \t\t  gsi_next (&gsi);\n \t\t}\n \t      else if (code == BIT_AND_EXPR"}]}