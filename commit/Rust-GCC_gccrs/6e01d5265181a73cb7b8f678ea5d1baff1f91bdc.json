{"sha": "6e01d5265181a73cb7b8f678ea5d1baff1f91bdc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmUwMWQ1MjY1MTgxYTczY2I3YjhmNjc4ZWE1ZDFiYWZmMWY5MWJkYw==", "commit": {"author": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2012-08-22T22:52:17Z"}, "committer": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2012-08-22T22:52:17Z"}, "message": "re PR target/54089 ([SH] Refactor shift patterns)\n\n\tPR target/54089\n\t* config/sh/predicates (p27_rshift_count_operand,\n\tnot_p27_rshift_count_operand): New predicates.\n\t* config/sh/sh.c (sh_ashlsi_clobbers_t_reg_p,\n\tsh_lshrsi_clobbers_t_reg_p, sh_dynamicalize_shift_p): Handle special\n\tcase when shift amount is 31.\n\t(gen_ashift): Emit gen_shlr instead of gen_lshrsi3_m.\n\t* config/sh/sh.md (ashlsi3_d): Set type to 'dyn_shift' instead\n\tof 'arith'.\n\t(ashlsi_c): Rename to shll.  Adapt calls to gen_ashlsi_c throughout\n\tthe file.\n\t(lshrsi3): Remove clobber from expander.  Use shift_count_operand\n\tinstead of nonmemory_operand predicate for second operand.  Add\n\thandling of case lshrsi3_n_clobbers_t.\n\t(lshrsi3_k): Use p27_rshift_count_operand for second operand.\n\t(lshrsi3_d): Make insn_and_split.  Split dynamic shift to constant\n\tshift sequences if beneficial.\n\t(lshrsi3_n): Make insn_and_split.  Split constant shift sequence to\n\tdynamic shift if beneficial.\n\t(lshrsi3_n_clobbers_t): New insn_and_split.\n\t(lshrsi3_m): Delete.\n\n\tPR target/54089\n\t* gcc.target/sh/pr54089-2.c: New.\n\nFrom-SVN: r190603", "tree": {"sha": "036a6368ca64516b6be1aed09908a8c533e43618", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/036a6368ca64516b6be1aed09908a8c533e43618"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6e01d5265181a73cb7b8f678ea5d1baff1f91bdc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e01d5265181a73cb7b8f678ea5d1baff1f91bdc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e01d5265181a73cb7b8f678ea5d1baff1f91bdc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e01d5265181a73cb7b8f678ea5d1baff1f91bdc/comments", "author": null, "committer": null, "parents": [{"sha": "131db6b8b25c6cb2349045f8c8196be6e376f454", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/131db6b8b25c6cb2349045f8c8196be6e376f454", "html_url": "https://github.com/Rust-GCC/gccrs/commit/131db6b8b25c6cb2349045f8c8196be6e376f454"}], "stats": {"total": 298, "additions": 233, "deletions": 65}, "files": [{"sha": "3bf9a38c77b8816556c5c760151a647d3f4249bf", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e01d5265181a73cb7b8f678ea5d1baff1f91bdc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e01d5265181a73cb7b8f678ea5d1baff1f91bdc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6e01d5265181a73cb7b8f678ea5d1baff1f91bdc", "patch": "@@ -1,3 +1,27 @@\n+2012-08-22  Oleg Endo  <olegendo@gcc.gnu.org>\n+\n+\tPR target/54089\n+\t* config/sh/predicates (p27_rshift_count_operand,\n+\tnot_p27_rshift_count_operand): New predicates.\n+\t* config/sh/sh.c (sh_ashlsi_clobbers_t_reg_p,\n+\tsh_lshrsi_clobbers_t_reg_p, sh_dynamicalize_shift_p): Handle special\n+\tcase when shift amount is 31.\n+\t(gen_ashift): Emit gen_shlr instead of gen_lshrsi3_m.\n+\t* config/sh/sh.md (ashlsi3_d): Set type to 'dyn_shift' instead\n+\tof 'arith'.\n+\t(ashlsi_c): Rename to shll.  Adapt calls to gen_ashlsi_c throughout\n+\tthe file.\n+\t(lshrsi3): Remove clobber from expander.  Use shift_count_operand\n+\tinstead of nonmemory_operand predicate for second operand.  Add\n+\thandling of case lshrsi3_n_clobbers_t.\n+\t(lshrsi3_k): Use p27_rshift_count_operand for second operand.\n+\t(lshrsi3_d): Make insn_and_split.  Split dynamic shift to constant\n+\tshift sequences if beneficial.\n+\t(lshrsi3_n): Make insn_and_split.  Split constant shift sequence to\n+\tdynamic shift if beneficial.\n+\t(lshrsi3_n_clobbers_t): New insn_and_split.\n+\t(lshrsi3_m): Delete.\n+\n 2012-08-22  Steven Bosscher  <steven@gcc.gnu.org>\n \n \t* tracer.c (mark_bb_seen): Use SBITMAP_SIZE."}, {"sha": "92a7b689c847aaa940665134f75179169100d537", "filename": "gcc/config/sh/predicates.md", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e01d5265181a73cb7b8f678ea5d1baff1f91bdc/gcc%2Fconfig%2Fsh%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e01d5265181a73cb7b8f678ea5d1baff1f91bdc/gcc%2Fconfig%2Fsh%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fpredicates.md?ref=6e01d5265181a73cb7b8f678ea5d1baff1f91bdc", "patch": "@@ -825,6 +825,8 @@\n   return arith_reg_operand (op, mode);\n })\n \n+;; Predicates for matching operands that are constant shift\n+;; amounts 1, 2, 8, 16.\n (define_predicate \"p27_shift_count_operand\"\n   (and (match_code \"const_int\")\n        (match_test \"satisfies_constraint_P27 (op)\")))\n@@ -833,6 +835,19 @@\n   (and (match_code \"const_int\")\n        (match_test \"! satisfies_constraint_P27 (op)\")))\n \n+;; For right shifts the constant 1 is a special case because the shlr insn\n+;; clobbers the T_REG and is handled by the T_REG clobbering version of the\n+;; insn, which is also used for non-P27 shift sequences.\n+(define_predicate \"p27_rshift_count_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"satisfies_constraint_P27 (op)\")\n+       (match_test \"! satisfies_constraint_M (op)\")))\n+\n+(define_predicate \"not_p27_rshift_count_operand\"\n+  (and (match_code \"const_int\")\n+       (ior (match_test \"! satisfies_constraint_P27 (op)\")\n+\t    (match_test \"satisfies_constraint_M (op)\"))))\n+\n ;; TODO: Add a comment here.\n \n (define_predicate \"shift_operator\""}, {"sha": "3851ec6d50f3fed0ca195ad2ca349a6ac2ff2b52", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 44, "deletions": 16, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e01d5265181a73cb7b8f678ea5d1baff1f91bdc/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e01d5265181a73cb7b8f678ea5d1baff1f91bdc/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=6e01d5265181a73cb7b8f678ea5d1baff1f91bdc", "patch": "@@ -2840,6 +2840,11 @@ static const struct ashl_lshr_sequence ashl_lshr_seq[32] =\n   { 4, { 16, 8, 2, 2 },\t    0 },\n   { 4, { 16, -1, -2, 16 },  ASHL_CLOBBERS_T },\n   { 3, { 16, -2, 16 },\t    0 },\n+\n+  /* For a right shift by 31 a 2 insn shll-movt sequence can be used.\n+     For a left shift by 31 a 2 insn and-rotl sequences can be used.\n+     However, the shift-and combiner code needs this entry here to be in\n+     terms of real shift insns.  */\n   { 3, { 16, -1, 16 },\t    ASHL_CLOBBERS_T }\n };\n \n@@ -2888,18 +2893,54 @@ bool\n sh_ashlsi_clobbers_t_reg_p (rtx shift_amount)\n {\n   gcc_assert (CONST_INT_P (shift_amount));\n-  return (ashl_lshr_seq[INTVAL (shift_amount) & 31].clobbers_t\n+  \n+  const int shift_amount_i = INTVAL (shift_amount) & 31;\n+\n+  /* Special case for shift count of 31: use and-rotl sequence.  */\n+  if (shift_amount_i == 31)\n+    return true;\n+\n+  return (ashl_lshr_seq[shift_amount_i].clobbers_t\n \t  & ASHL_CLOBBERS_T) != 0;\n }\n \n bool\n sh_lshrsi_clobbers_t_reg_p (rtx shift_amount)\n {\n   gcc_assert (CONST_INT_P (shift_amount));\n-  return (ashl_lshr_seq[INTVAL (shift_amount) & 31].clobbers_t\n+\n+  const int shift_amount_i = INTVAL (shift_amount) & 31;\n+ \n+  /* Special case for shift count of 31: use shll-movt sequence.  */\n+  if (shift_amount_i == 31)\n+    return true;\n+\n+  return (ashl_lshr_seq[shift_amount_i].clobbers_t\n \t  & LSHR_CLOBBERS_T) != 0;\n }\n \n+/* Return true if it is potentially beneficial to use a dynamic shift\n+   instruction (shad / shar) instead of a combination of 1/2/8/16 \n+   shift instructions for the specified shift count.\n+   If dynamic shifts are not available, always return false.  */\n+bool\n+sh_dynamicalize_shift_p (rtx count)\n+{\n+  gcc_assert (CONST_INT_P (count));\n+\n+  const int shift_amount_i = INTVAL (count) & 31;\n+  int insn_count;\n+\n+  /* For left and right shifts, there are shorter 2 insn sequences for\n+     shift amounts of 31.  */\n+  if (shift_amount_i == 31)\n+    insn_count = 2;\n+  else\n+    insn_count = ashl_lshr_seq[shift_amount_i].insn_count;\n+\n+  return TARGET_DYNSHIFT && (insn_count > 1 + SH_DYNAMIC_SHIFT_COST);\n+}\n+\n /* Assuming we have a value that has been sign-extended by at least one bit,\n    can we use the ext_shift_amounts with the last shift turned to an arithmetic shift\n    to shift it by N without data loss, and quicker than by other means?  */\n@@ -3385,7 +3426,7 @@ gen_ashift (int type, int n, rtx reg)\n       break;\n     case LSHIFTRT:\n       if (n == 1)\n-\temit_insn (gen_lshrsi3_m (reg, reg, n_rtx));\n+        emit_insn (gen_shlr (reg, reg));\n       else\n \temit_insn (gen_lshrsi3_k (reg, reg, n_rtx));\n       break;\n@@ -3596,19 +3637,6 @@ expand_ashiftrt (rtx *operands)\n   return true;\n }\n \n-/* Return true if it is potentially beneficial to use a dynamic shift\n-   instruction (shad / shar) instead of a combination of 1/2/8/16 \n-   shift instructions for the specified shift count.\n-   If dynamic shifts are not available, always return false.  */\n-bool\n-sh_dynamicalize_shift_p (rtx count)\n-{\n-  int insn_count;\n-  gcc_assert (CONST_INT_P (count));\n-  insn_count = ashl_lshr_seq[INTVAL (count) & 31].insn_count;\n-  return TARGET_DYNSHIFT && (insn_count > 1 + SH_DYNAMIC_SHIFT_COST);\n-}\n-\n /* Try to find a good way to implement the combiner pattern\n   [(set (match_operand:SI 0 \"register_operand\" \"r\")\n         (and:SI (ashift:SI (match_operand:SI 1 \"register_operand\" \"r\")"}, {"sha": "ede916effb4a8309c0e434da71042bc2af4c3120", "filename": "gcc/config/sh/sh.md", "status": "modified", "additions": 123, "deletions": 49, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e01d5265181a73cb7b8f678ea5d1baff1f91bdc/gcc%2Fconfig%2Fsh%2Fsh.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e01d5265181a73cb7b8f678ea5d1baff1f91bdc/gcc%2Fconfig%2Fsh%2Fsh.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.md?ref=6e01d5265181a73cb7b8f678ea5d1baff1f91bdc", "patch": "@@ -4058,7 +4058,7 @@ label:\n \n   FAIL;\n }\n-  [(set_attr \"type\" \"arith\")])\n+  [(set_attr \"type\" \"dyn_shift\")])\n \n (define_insn_and_split \"ashlsi3_n\"\n   [(set (match_operand:SI 0 \"arith_reg_dest\" \"=r\")\n@@ -4116,7 +4116,7 @@ label:\n   DONE;\n })\n \n-(define_insn \"ashlsi_c\"\n+(define_insn \"shll\"\n   [(set (match_operand:SI 0 \"arith_reg_dest\" \"=r\")\n \t(ashift:SI (match_operand:SI 1 \"arith_reg_operand\" \"0\") (const_int 1)))\n    (set (reg:SI T_REG)\n@@ -4142,7 +4142,7 @@ label:\n    && peep2_reg_dead_p (2, operands[1])\"\n   [(const_int 0)]\n {\n-  emit_insn (gen_ashlsi_c (operands[1], operands[1]));\n+  emit_insn (gen_shll (operands[1], operands[1]));\n   DONE;\n })\n \n@@ -4349,7 +4349,7 @@ label:\n   \"&& 1\"\n   [(const_int 0)]\n {\n-  emit_insn (gen_ashlsi_c (operands[0], operands[1]));\n+  emit_insn (gen_shll (operands[0], operands[1]));\n   emit_insn (gen_mov_neg_si_t (operands[0], get_t_reg_rtx ()));\n   DONE;\n })\n@@ -4463,84 +4463,158 @@ label:\n ;; . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n ;; SImode logical shift right\n \n-;; Only the single bit shift clobbers the T bit.\n (define_expand \"lshrsi3\"\n-  [(parallel [(set (match_operand:SI 0 \"arith_reg_dest\" \"\")\n-\t\t   (lshiftrt:SI (match_operand:SI 1 \"arith_reg_operand\" \"\")\n-\t\t\t\t(match_operand:SI 2 \"nonmemory_operand\" \"\")))\n-\t      (clobber (reg:SI T_REG))])]\n+  [(set (match_operand:SI 0 \"arith_reg_dest\" \"\")\n+\t(lshiftrt:SI (match_operand:SI 1 \"arith_reg_operand\" \"\")\n+\t\t     (match_operand:SI 2 \"shift_count_operand\" \"\")))]\n   \"\"\n {\n   if (TARGET_SHMEDIA)\n     {\n       emit_insn (gen_lshrsi3_media (operands[0], operands[1], operands[2]));\n       DONE;\n     }\n-  if (CONST_INT_P (operands[2])\n-      && sh_dynamicalize_shift_p (operands[2]))\n-    operands[2] = force_reg (SImode, operands[2]);\n+\n+  /* If a dynamic shift is supposed to be used, expand the lshrsi3_d insn\n+     here, otherwise the pattern will never match due to the shift amount reg\n+     negation.  */\n   if (TARGET_DYNSHIFT\n-      && arith_reg_operand (operands[2], GET_MODE (operands[2])))\n+      && CONST_INT_P (operands[2]) && sh_dynamicalize_shift_p (operands[2]))\n     {\n-      rtx count = copy_to_mode_reg (SImode, operands[2]);\n-      emit_insn (gen_negsi2 (count, count));\n-      emit_insn (gen_lshrsi3_d (operands[0], operands[1], count));\n+      rtx neg_count = force_reg (SImode,\n+\t\t\t         gen_int_mode (- INTVAL (operands[2]), SImode));\n+      emit_insn (gen_lshrsi3_d (operands[0], operands[1], neg_count));\n       DONE;\n     }\n-  if (! immediate_operand (operands[2], GET_MODE (operands[2])))\n-    FAIL;\n-})\n \n-(define_insn \"lshrsi3_d\"\n-  [(set (match_operand:SI 0 \"arith_reg_dest\" \"=r\")\n-\t(lshiftrt:SI (match_operand:SI 1 \"arith_reg_operand\" \"0\")\n-\t\t     (neg:SI (match_operand:SI 2 \"arith_reg_operand\" \"r\"))))]\n-  \"TARGET_DYNSHIFT\"\n-  \"shld\t%2,%0\"\n-  [(set_attr \"type\" \"dyn_shift\")])\n+  if (TARGET_DYNSHIFT && ! CONST_INT_P (operands[2]))\n+    {\n+      rtx neg_count = gen_reg_rtx (SImode);\n+      emit_insn (gen_negsi2 (neg_count, operands[2]));\n+      emit_insn (gen_lshrsi3_d (operands[0], operands[1], neg_count));\n+      DONE;\n+    }\n \n-(define_insn \"shlr\"\n+  /* If the lshrsi3_* insn is going to clobber the T_REG it must be\n+     expanded here.  */\n+  if (CONST_INT_P (operands[2])\n+      && sh_lshrsi_clobbers_t_reg_p (operands[2])\n+      && ! sh_dynamicalize_shift_p (operands[2]))\n+    {\n+      emit_insn (gen_lshrsi3_n_clobbers_t (operands[0], operands[1],\n+\t\t operands[2]));\n+      DONE;\n+    }\n+})\n+\n+(define_insn \"lshrsi3_k\"\n   [(set (match_operand:SI 0 \"arith_reg_dest\" \"=r\")\n \t(lshiftrt:SI (match_operand:SI 1 \"arith_reg_operand\" \"0\")\n-\t\t     (const_int 1)))\n-   (set (reg:SI T_REG)\n-\t(and:SI (match_dup 1) (const_int 1)))]\n+\t\t     (match_operand:SI 2 \"p27_rshift_count_operand\" \"P27\")))]\n   \"TARGET_SH1\"\n-  \"shlr\t%0\"\n+  \"shlr%O2\t%0\"\n   [(set_attr \"type\" \"arith\")])\n \n-(define_insn \"lshrsi3_m\"\n+(define_insn_and_split \"lshrsi3_d\"\n   [(set (match_operand:SI 0 \"arith_reg_dest\" \"=r\")\n \t(lshiftrt:SI (match_operand:SI 1 \"arith_reg_operand\" \"0\")\n-\t\t     (match_operand:SI 2 \"const_int_operand\" \"M\")))\n-   (clobber (reg:SI T_REG))]\n-  \"TARGET_SH1 && satisfies_constraint_M (operands[2])\"\n-  \"shlr\t%0\"\n-  [(set_attr \"type\" \"arith\")])\n+\t\t     (neg:SI (match_operand:SI 2 \"shift_count_operand\" \"r\"))))]\n+  \"TARGET_DYNSHIFT\"\n+  \"shld\t%2,%0\"\n+  \"&& CONST_INT_P (operands[2]) && ! sh_dynamicalize_shift_p (operands[2])\n+   && ! sh_lshrsi_clobbers_t_reg_p (operands[2])\"\n+  [(const_int 0)]\n+{\n+  if (satisfies_constraint_P27 (operands[2]))\n+    {\n+      /* This will not be done for a shift amount of 1, because it would\n+\t clobber the T_REG.  */\n+      emit_insn (gen_lshrsi3_k (operands[0], operands[1], operands[2]));\n+      DONE;\n+    }\n+  else if (! satisfies_constraint_P27 (operands[2]))\n+    {\n+      /* This must happen before reload, otherwise the constant will be moved\n+\t into a register due to the \"r\" constraint, after which this split\n+\t cannot be done anymore.\n+\t Unfortunately the move insn will not always be eliminated.\n+\t Also, here we must not create a shift sequence that clobbers the\n+\t T_REG.  */\n+      emit_move_insn (operands[0], operands[1]);\n+      gen_shifty_op (LSHIFTRT, operands);\n+      DONE;\n+    }\n \n-(define_insn \"lshrsi3_k\"\n+  FAIL;\n+}\n+  [(set_attr \"type\" \"dyn_shift\")])\n+\n+(define_insn_and_split \"lshrsi3_n\"\n   [(set (match_operand:SI 0 \"arith_reg_dest\" \"=r\")\n \t(lshiftrt:SI (match_operand:SI 1 \"arith_reg_operand\" \"0\")\n-\t\t     (match_operand:SI 2 \"const_int_operand\" \"P27\")))]\n-  \"TARGET_SH1 && satisfies_constraint_P27 (operands[2])\n-   && ! satisfies_constraint_M (operands[2])\"\n-  \"shlr%O2\t%0\"\n-  [(set_attr \"type\" \"arith\")])\n+\t\t     (match_operand:SI 2 \"not_p27_rshift_count_operand\")))]\n+  \"TARGET_SH1 && ! sh_lshrsi_clobbers_t_reg_p (operands[2])\"\n+  \"#\"\n+  \"&& (reload_completed\n+       || (sh_dynamicalize_shift_p (operands[2]) && can_create_pseudo_p ()))\"\n+  [(const_int 0)]\n+{\n+  if (sh_dynamicalize_shift_p (operands[2]) && can_create_pseudo_p ())\n+    {\n+      /* If this pattern was picked and dynamic shifts are supported, switch\n+\t to dynamic shift pattern before reload.  */\n+      operands[2] = force_reg (SImode,\n+\t\t\t       gen_int_mode (- INTVAL (operands[2]), SImode));\n+      emit_insn (gen_lshrsi3_d (operands[0], operands[1], operands[2]));\n+    }\n+  else\n+    gen_shifty_op (LSHIFTRT, operands);\n \n-(define_insn_and_split \"lshrsi3_n\"\n+  DONE;\n+})\n+\n+;; The lshrsi3_n_clobbers_t pattern also works as a simplified version of\n+;; the shlr pattern.\n+(define_insn_and_split \"lshrsi3_n_clobbers_t\"\n   [(set (match_operand:SI 0 \"arith_reg_dest\" \"=r\")\n \t(lshiftrt:SI (match_operand:SI 1 \"arith_reg_operand\" \"0\")\n-\t\t     (match_operand:SI 2 \"const_int_operand\" \"n\")))\n+\t\t     (match_operand:SI 2 \"not_p27_rshift_count_operand\")))\n    (clobber (reg:SI T_REG))]\n-  \"TARGET_SH1 && ! sh_dynamicalize_shift_p (operands[2])\"\n+  \"TARGET_SH1 && sh_lshrsi_clobbers_t_reg_p (operands[2])\"\n   \"#\"\n-  \"TARGET_SH1 && reload_completed\"\n-  [(use (reg:SI R0_REG))]\n+  \"&& (reload_completed || INTVAL (operands[2]) == 31\n+       || (sh_dynamicalize_shift_p (operands[2]) && can_create_pseudo_p ()))\"\n+  [(const_int 0)]\n {\n-  gen_shifty_op (LSHIFTRT, operands);\n+  if (INTVAL (operands[2]) == 31)\n+    {\n+      emit_insn (gen_shll (operands[0], operands[1]));\n+      emit_insn (gen_movt (operands[0], get_t_reg_rtx ()));\n+    }\n+  else if (sh_dynamicalize_shift_p (operands[2]) && can_create_pseudo_p ())\n+    {\n+      /* If this pattern was picked and dynamic shifts are supported, switch\n+\t to dynamic shift pattern before reload.  */\n+      operands[2] = force_reg (SImode,\n+\t\t\t       gen_int_mode (- INTVAL (operands[2]), SImode));\n+      emit_insn (gen_lshrsi3_d (operands[0], operands[1], operands[2]));\n+    }\n+  else\n+    gen_shifty_op (LSHIFTRT, operands);\n+\n   DONE;\n })\n \n+(define_insn \"shlr\"\n+  [(set (match_operand:SI 0 \"arith_reg_dest\" \"=r\")\n+\t(lshiftrt:SI (match_operand:SI 1 \"arith_reg_operand\" \"0\")\n+\t\t     (const_int 1)))\n+   (set (reg:SI T_REG)\n+\t(and:SI (match_dup 1) (const_int 1)))]\n+  \"TARGET_SH1\"\n+  \"shlr\t%0\"\n+  [(set_attr \"type\" \"arith\")])\n+\n (define_insn \"lshrsi3_media\"\n   [(set (match_operand:SI 0 \"arith_reg_dest\" \"=r,r\")\n \t(lshiftrt:SI (match_operand:SI 1 \"extend_reg_operand\" \"r,r\")"}, {"sha": "3c4db30985b17ff44674dc2e09b19d9a74a15043", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e01d5265181a73cb7b8f678ea5d1baff1f91bdc/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e01d5265181a73cb7b8f678ea5d1baff1f91bdc/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=6e01d5265181a73cb7b8f678ea5d1baff1f91bdc", "patch": "@@ -1,3 +1,8 @@\n+2012-08-22  Oleg Endo  <olegendo@gcc.gnu.org>\n+\n+\tPR target/54089\n+\t* gcc.target/sh/pr54089-2.c: New.\n+\n 2012-08-22  H.J. Lu  <hongjiu.lu@intel.com>\n \n \t* gcc.target/i386/long-double-64-1.c: New file."}, {"sha": "61b703d4dfe83c4413db9df4a682906cb1747e15", "filename": "gcc/testsuite/gcc.target/sh/pr54089-2.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e01d5265181a73cb7b8f678ea5d1baff1f91bdc/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr54089-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e01d5265181a73cb7b8f678ea5d1baff1f91bdc/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr54089-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr54089-2.c?ref=6e01d5265181a73cb7b8f678ea5d1baff1f91bdc", "patch": "@@ -0,0 +1,22 @@\n+/* Check that for dynamic logical right shifts with a constant the negated\n+   constant is loaded directly, instead of loading the postitive constant\n+   and negating it separately.  This was a case that happened at optimization\n+   level -O2 and looked like:\n+\tcmp/eq\tr6,r5\n+\tmov\t#30,r1\n+\tneg\tr1,r1\n+\tshld\tr1,r4\n+\tmov\tr4,r0\n+\trts\n+\trotcr\tr0  */\n+/* { dg-do compile { target \"sh*-*-*\" } } */\n+/* { dg-options \"-O2\" } */\n+/* { dg-skip-if \"\" { \"sh*-*-*\" } { \"*\"} { \"-m3* -m2a* -m4*\" } }  */\n+/* { dg-final { scan-assembler-not \"neg\" } } */\n+\n+unsigned int\n+test (unsigned int a, int b, int c)\n+{\n+  unsigned char r = b == c;\n+  return ((a >> 31) | (r << 31));\n+}"}]}