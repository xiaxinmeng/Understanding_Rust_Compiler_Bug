{"sha": "9ae8b993cd362e8aea4f65580aaf1453120207f2", "node_id": "C_kwDOANBUbNoAKDlhZThiOTkzY2QzNjJlOGFlYTRmNjU1ODBhYWYxNDUzMTIwMjA3ZjI", "commit": {"author": {"name": "Sebastian Huber", "email": "sebastian.huber@embedded-brains.de", "date": "2022-04-08T15:16:09Z"}, "committer": {"name": "Sebastian Huber", "email": "sebastian.huber@embedded-brains.de", "date": "2022-04-28T18:46:50Z"}, "message": "gcov: Add section for freestanding environments\n\ngcc/\n\n\t* doc/gcov.texi (Profiling and Test Coverage in Freestanding\n\tEnvironments): New section.", "tree": {"sha": "ee4c80acfdcf7e25dd35ee176e8e6f8e394020ae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ee4c80acfdcf7e25dd35ee176e8e6f8e394020ae"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9ae8b993cd362e8aea4f65580aaf1453120207f2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ae8b993cd362e8aea4f65580aaf1453120207f2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9ae8b993cd362e8aea4f65580aaf1453120207f2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ae8b993cd362e8aea4f65580aaf1453120207f2/comments", "author": {"login": "sebhub", "id": 932056, "node_id": "MDQ6VXNlcjkzMjA1Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/932056?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sebhub", "html_url": "https://github.com/sebhub", "followers_url": "https://api.github.com/users/sebhub/followers", "following_url": "https://api.github.com/users/sebhub/following{/other_user}", "gists_url": "https://api.github.com/users/sebhub/gists{/gist_id}", "starred_url": "https://api.github.com/users/sebhub/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sebhub/subscriptions", "organizations_url": "https://api.github.com/users/sebhub/orgs", "repos_url": "https://api.github.com/users/sebhub/repos", "events_url": "https://api.github.com/users/sebhub/events{/privacy}", "received_events_url": "https://api.github.com/users/sebhub/received_events", "type": "User", "site_admin": false}, "committer": {"login": "sebhub", "id": 932056, "node_id": "MDQ6VXNlcjkzMjA1Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/932056?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sebhub", "html_url": "https://github.com/sebhub", "followers_url": "https://api.github.com/users/sebhub/followers", "following_url": "https://api.github.com/users/sebhub/following{/other_user}", "gists_url": "https://api.github.com/users/sebhub/gists{/gist_id}", "starred_url": "https://api.github.com/users/sebhub/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sebhub/subscriptions", "organizations_url": "https://api.github.com/users/sebhub/orgs", "repos_url": "https://api.github.com/users/sebhub/repos", "events_url": "https://api.github.com/users/sebhub/events{/privacy}", "received_events_url": "https://api.github.com/users/sebhub/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "92475ea84f69ad2bb92dbecd6b5c33be174c4777", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92475ea84f69ad2bb92dbecd6b5c33be174c4777", "html_url": "https://github.com/Rust-GCC/gccrs/commit/92475ea84f69ad2bb92dbecd6b5c33be174c4777"}], "stats": {"total": 389, "additions": 389, "deletions": 0}, "files": [{"sha": "a1f7d26e610cc38e8238ae1a14362d0a4deeba84", "filename": "gcc/doc/gcov.texi", "status": "modified", "additions": 389, "deletions": 0, "changes": 389, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ae8b993cd362e8aea4f65580aaf1453120207f2/gcc%2Fdoc%2Fgcov.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ae8b993cd362e8aea4f65580aaf1453120207f2/gcc%2Fdoc%2Fgcov.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgcov.texi?ref=9ae8b993cd362e8aea4f65580aaf1453120207f2", "patch": "@@ -41,6 +41,8 @@ test code coverage in your programs.\n * Gcov and Optimization::       Using gcov with GCC optimization.\n * Gcov Data Files::             The files used by gcov.\n * Cross-profiling::             Data file relocation.\n+* Freestanding Environments::   How to use profiling and test\n+                                coverage in freestanding environments.\n @end menu\n \n @node Gcov Intro\n@@ -971,3 +973,390 @@ setting will name the data file @file{/target/run/build/foo.gcda}.\n You must move the data files to the expected directory tree in order to\n use them for profile directed optimizations (@option{-fprofile-use}), or to\n use the @command{gcov} tool.\n+\n+@node Freestanding Environments\n+@section Profiling and Test Coverage in Freestanding Environments\n+\n+In case your application runs in a hosted environment such as GNU/Linux, then\n+this section is likely not relevant to you.  This section is intended for\n+application developers targeting freestanding environments (for example\n+embedded systems) with limited resources.  In particular, systems or test cases\n+which do not support constructors/destructors or the C library file I/O.  In\n+this section, the @dfn{target system} runs your application instrumented for\n+profiling or test coverage.  You develop and analyze your application on the\n+@dfn{host system}.  We now provide an overview how profiling and test coverage\n+can be obtained in this scenario followed by a tutorial which can be exercised\n+on the host system.  Finally, some system initialization caveats are listed.\n+\n+@subsection Overview\n+\n+For an application instrumented for profiling or test coverage, the compiler\n+generates some global data structures which are updated by instrumentation code\n+while the application runs.  These data structures are called the @dfn{gcov\n+information}.  Normally, when the application exits, the gcov information is\n+stored to @file{.gcda} files.  There is one file per translation unit\n+instrumented for profiling or test coverage.  The function\n+@code{__gcov_exit()}, which stores the gcov information to a file, is called by\n+a global destructor function for each translation unit instrumented for\n+profiling or test coverage.  It runs at process exit.  In a global constructor\n+function, the @code{__gcov_init()} function is called to register the gcov\n+information of a translation unit in a global list.  In some situations, this\n+procedure does not work.  Firstly, if you want to profile the global\n+constructor or exit processing of an operating system, the compiler generated\n+functions may conflict with the test objectives.  Secondly, you may want to\n+test early parts of the system initialization or abnormal program behaviour\n+which do not allow a global constructor or exit processing.  Thirdly, you need\n+a filesystem to store the files.\n+\n+The @option{-fprofile-info-section} GCC option enables you to use profiling and\n+test coverage in freestanding environments.  This option disables the use of\n+global constructors and destructors for the gcov information.  Instead, a\n+pointer to the gcov information is stored in a special linker input section for\n+each translation unit which is compiled with this option.  By default, the\n+section name is @code{.gcov_info}.  The gcov information is statically\n+initialized.  The pointers to the gcov information from all translation units\n+of an executable can be collected by the linker in a contiguous memory block.\n+For the GNU linker, the below linker script output section definition can be\n+used to achieve this:\n+\n+@smallexample\n+  .gcov_info      :\n+  @{\n+    PROVIDE (__gcov_info_start = .);\n+    KEEP (*(.gcov_info))\n+    PROVIDE (__gcov_info_end = .);\n+  @}\n+@end smallexample\n+\n+The linker will provide two global symbols, @code{__gcov_info_start} and\n+@code{__gcov_info_end}, which define the start and end of the array of pointers\n+to gcov information blocks, respectively.  The @code{KEEP ()} directive is\n+required to prevent a garbage collection of the pointers.  They are not\n+directly referenced by anything in the executable.  The section may be placed\n+in a read-only memory area.\n+\n+In order to transfer the profiling and test coverage data from the target to\n+the host system, the application has to provide a function to produce a\n+reliable in order byte stream from the target to the host.  The byte stream may\n+be compressed and encoded using error detection and correction codes to meet\n+application-specific requirements.  The GCC provided @file{libgcov} target\n+library provides two functions, @code{__gcov_info_to_gcda()} and\n+@code{__gcov_filename_to_gcfn()}, to generate a byte stream from a gcov\n+information bock.  The functions are declared in @code{#include <gcov.h>}.  The\n+byte stream can be deserialized by the @command{merge-stream} subcommand of the\n+@command{gcov-tool} to create or update @file{.gcda} files in the host\n+filesystem for the instrumented application.\n+\n+@subsection Tutorial\n+\n+This tutorial should be exercised on the host system.  We will build a program\n+instrumented for test coverage.  The program runs an application and dumps the\n+gcov information to @file{stderr} encoded as a printable character stream.  The\n+application simply decodes such character streams from @file{stdin} and writes\n+the decoded character stream to @file{stdout} (warning: this is binary data).\n+The decoded character stream is consumed by the @command{merge-stream}\n+subcommand of the @command{gcov-tool} to create or update the @file{.gcda}\n+files.\n+\n+To get started, create an empty directory.  Change into the new directory.\n+Then you will create the following three files in this directory\n+\n+@enumerate\n+@item\n+@file{app.h} - a header file included by @file{app.c} and @file{main.c},\n+\n+@item\n+@file{app.c} - a source file which contains an example application, and\n+\n+@item\n+@file{main.c} - a source file which contains the program main function and code\n+to dump the gcov information.\n+@end enumerate\n+\n+Firstly, create the header file @file{app.h} with the following content:\n+\n+@smallexample\n+static const unsigned char a = 'a';\n+\n+static inline unsigned char *\n+encode (unsigned char c, unsigned char buf[2])\n+@{\n+  buf[0] = c % 16 + a;\n+  buf[1] = (c / 16) % 16 + a;\n+  return buf;\n+@}\n+\n+extern void application (void);\n+@end smallexample\n+\n+Secondly, create the source file @file{app.c} with the following content:\n+\n+@smallexample\n+#include \"app.h\"\n+\n+#include <stdio.h>\n+\n+/* The application reads a character stream encoded by encode() from stdin,\n+   decodes it, and writes the decoded characters to stdout.  Characters other\n+   than the 16 characters 'a' to 'p' are ignored.  */\n+\n+static int can_decode (unsigned char c)\n+@{\n+  return (unsigned char)(c - a) < 16;\n+@}\n+\n+void\n+application (void)\n+@{\n+  int first = 1;\n+  int i;\n+  unsigned char c;\n+\n+  while ((i = fgetc (stdin)) != EOF)\n+    @{\n+      unsigned char x = (unsigned char)i;\n+\n+      if (can_decode (x))\n+        @{\n+          if (first)\n+            c = x - a;\n+          else\n+            fputc (c + 16 * (x - a), stdout);\n+          first = !first;\n+        @}\n+      else\n+        first = 1;\n+    @}\n+@}\n+@end smallexample\n+\n+Thirdly, create the source file @file{main.c} with the following content:\n+\n+@smallexample\n+#include \"app.h\"\n+\n+#include <gcov.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+\n+/* The start and end symbols are provided by the linker script.  We use the\n+   array notation to avoid issues with a potential small-data area.  */\n+\n+extern const struct gcov_info *const __gcov_info_start[];\n+extern const struct gcov_info *const __gcov_info_end[];\n+\n+/* This function shall produce a reliable in order byte stream to transfer the\n+   gcov information from the target to the host system.  */\n+\n+static void\n+dump (const void *d, unsigned n, void *arg)\n+@{\n+  (void)arg;\n+  const unsigned char *c = d;\n+  unsigned char buf[2];\n+\n+  for (unsigned i = 0; i < n; ++i)\n+    fwrite (encode (c[i], buf), sizeof (buf), 1, stderr);\n+@}\n+\n+/* The filename is serialized to a gcfn data stream by the\n+   __gcov_filename_to_gcfn() function.  The gcfn data is used by the\n+   \"merge-stream\" subcommand of the \"gcov-tool\" to figure out the filename\n+   associated with the gcov information. */\n+\n+static void\n+filename (const char *f, void *arg)\n+@{\n+  __gcov_filename_to_gcfn (f, dump, arg);\n+@}\n+\n+/* The __gcov_info_to_gcda() function may have to allocate memory under\n+   certain conditions.  Simply try it out if it is needed for your application\n+   or not.  */\n+\n+static void *\n+allocate (unsigned length, void *arg)\n+@{\n+  (void)arg;\n+  return malloc (length);\n+@}\n+\n+/* Dump the gcov information of all translation units.  */\n+\n+static void\n+dump_gcov_info (void)\n+@{\n+  const struct gcov_info *const *info = __gcov_info_start;\n+  const struct gcov_info *const *end = __gcov_info_end;\n+\n+  /* Obfuscate variable to prevent compiler optimizations.  */\n+  __asm__ (\"\" : \"+r\" (info));\n+\n+  while (info != end)\n+  @{\n+    void *arg = NULL;\n+    __gcov_info_to_gcda (*info, filename, dump, allocate, arg);\n+    fputc ('\\n', stderr);\n+    ++info;\n+  @}\n+@}\n+\n+/* The main() function just runs the application and then dumps the gcov\n+   information to stderr.  */\n+\n+int\n+main (void)\n+@{\n+  application ();\n+  dump_gcov_info ();\n+  return 0;\n+@}\n+@end smallexample\n+\n+If we compile @file{app.c} with test coverage and no extra profiling options,\n+then a global constructor (@code{_sub_I_00100_0} here, it may have a different\n+name in your environment) and destructor (@code{_sub_D_00100_1}) is used to\n+register and dump the gcov information, respectively.  We also see undefined\n+references to @code{__gcov_init} and @code{__gcov_exit}:\n+\n+@smallexample\n+$ gcc --coverage -c app.c\n+$ nm app.o\n+0000000000000000 r a\n+0000000000000030 T application\n+0000000000000000 t can_decode\n+                 U fgetc\n+                 U fputc\n+0000000000000000 b __gcov0.application\n+0000000000000038 b __gcov0.can_decode\n+0000000000000000 d __gcov_.application\n+00000000000000c0 d __gcov_.can_decode\n+                 U __gcov_exit\n+                 U __gcov_init\n+                 U __gcov_merge_add\n+                 U stdin\n+                 U stdout\n+0000000000000161 t _sub_D_00100_1\n+0000000000000151 t _sub_I_00100_0\n+@end smallexample\n+\n+Compile @file{app.c} and @file{main.c} with test coverage and\n+@option{-fprofile-info-section}.  Now, a read-only pointer size object is\n+present in the @code{.gcov_info} section and there are no undefined references\n+to @code{__gcov_init} and @code{__gcov_exit}:\n+\n+@smallexample\n+$ gcc --coverage -fprofile-info-section -c main.c\n+$ gcc --coverage -fprofile-info-section -c app.c\n+$ objdump -h app.o\n+\n+app.o:     file format elf64-x86-64\n+\n+Sections:\n+Idx Name          Size      VMA               LMA               File off  Algn\n+  0 .text         00000151  0000000000000000  0000000000000000  00000040  2**0\n+                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE\n+  1 .data         00000100  0000000000000000  0000000000000000  000001a0  2**5\n+                  CONTENTS, ALLOC, LOAD, RELOC, DATA\n+  2 .bss          00000040  0000000000000000  0000000000000000  000002a0  2**5\n+                  ALLOC\n+  3 .rodata       0000003c  0000000000000000  0000000000000000  000002a0  2**3\n+                  CONTENTS, ALLOC, LOAD, READONLY, DATA\n+  4 .gcov_info    00000008  0000000000000000  0000000000000000  000002e0  2**3\n+                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA\n+  5 .comment      0000004e  0000000000000000  0000000000000000  000002e8  2**0\n+                  CONTENTS, READONLY\n+  6 .note.GNU-stack 00000000  0000000000000000  0000000000000000  00000336  2**0\n+                  CONTENTS, READONLY\n+  7 .eh_frame     00000058  0000000000000000  0000000000000000  00000338  2**3\n+                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA\n+@end smallexample\n+\n+We have to customize the program link procedure so that all the\n+@code{.gcov_info} linker input sections are placed in a contiguous memory block\n+with a begin and end symbol.  Firstly, get the default linker script using the\n+following commands (we assume a GNU linker):\n+\n+@smallexample\n+$ ld --verbose | sed '1,/^===/d' | sed '/^===/d' > linkcmds\n+@end smallexample\n+\n+Secondly, open the file @file{linkcmds} with a text editor and place the linker\n+output section definition from the overview after the @code{.rodata} section\n+definition.  Link the program executable using the customized linker script:\n+\n+@smallexample\n+$ gcc --coverage main.o app.o -T linkcmds -Wl,-Map,app.map\n+@end smallexample\n+\n+In the linker map file @file{app.map}, we see that the linker placed the\n+read-only pointer size objects of our objects files @file{main.o} and\n+@file{app.o} into a contiguous memory block and provided the symbols\n+@code{__gcov_info_start} and @code{__gcov_info_end}:\n+\n+@smallexample\n+$ grep -C 1 \"\\.gcov_info\" app.map\n+\n+.gcov_info      0x0000000000403ac0       0x10\n+                0x0000000000403ac0                PROVIDE (__gcov_info_start = .)\n+ *(.gcov_info)\n+ .gcov_info     0x0000000000403ac0        0x8 main.o\n+ .gcov_info     0x0000000000403ac8        0x8 app.o\n+                0x0000000000403ad0                PROVIDE (__gcov_info_end = .)\n+@end smallexample\n+\n+Make sure no @file{.gcda} files are present.  Run the program with nothing to\n+decode and dump @file{stderr} to the file @file{gcda-0.txt} (first run).  Run\n+the program to decode @file{gcda-0.txt} and send it to the @command{gcov-tool}\n+using the @command{merge-stream} subcommand to create the @file{.gcda} files\n+(second run).  Run @command{gcov} to produce a report for @file{app.c}.  We see\n+that the first run with nothing to decode results in a partially covered\n+application:\n+\n+@smallexample\n+$ rm -f app.gcda main.gcda\n+$ echo \"\" | ./a.out 2>gcda-0.txt\n+$ ./a.out <gcda-0.txt 2>gcda-1.txt | gcov-tool merge-stream\n+$ gcov -bc app.c\n+File 'app.c'\n+Lines executed:69.23% of 13\n+Branches executed:66.67% of 6\n+Taken at least once:50.00% of 6\n+Calls executed:66.67% of 3\n+Creating 'app.c.gcov'\n+\n+Lines executed:69.23% of 13\n+@end smallexample\n+\n+Run the program to decode @file{gcda-1.txt} and send it to the\n+@command{gcov-tool} using the @command{merge-stream} subcommand to update the\n+@file{.gcda} files.  Run @command{gcov} to produce a report for @file{app.c}.\n+Since the second run decoded the gcov information of the first run, we have now\n+a fully covered application:\n+\n+@smallexample\n+$ ./a.out <gcda-1.txt 2>gcda-2.txt | gcov-tool merge-stream\n+$ gcov -bc app.c\n+File 'app.c'\n+Lines executed:100.00% of 13\n+Branches executed:100.00% of 6\n+Taken at least once:100.00% of 6\n+Calls executed:100.00% of 3\n+Creating 'app.c.gcov'\n+\n+Lines executed:100.00% of 13\n+@end smallexample\n+\n+@subsection System Initialization Caveats\n+\n+The gcov information of a translation unit consists of several global data\n+structures.  For example, the instrumented code may update program flow graph\n+edge counters in a zero-initialized data structure.  It is safe to run\n+instrumented code before the zero-initialized data is cleared to zero.  The\n+coverage information obtained before the zero-initialized data is cleared to\n+zero is unusable.  Dumping the gcov information using\n+@code{__gcov_info_to_gcda()} before the zero-initialized data is cleared to\n+zero or the initialized data is loaded, is undefined behaviour.  Clearing the\n+zero-initialized data to zero through a function instrumented for profiling or\n+test coverage is undefined behaviour, since it may produce inconsistent program\n+flow graph edge counters for example."}]}