{"sha": "18b526e806ab64557cd575ff407fcb1da16ee8fd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MThiNTI2ZTgwNmFiNjQ1NTdjZDU3NWZmNDA3ZmNiMWRhMTZlZThmZA==", "commit": {"author": {"name": "Richard Sandiford", "email": "rsandifo@nildram.co.uk", "date": "2008-03-22T19:37:53Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2008-03-22T19:37:53Z"}, "message": "re PR rtl-optimization/33927 (replace_read in dse.c could handle cases where GET_MODE_CLASS (read_mode) != GET_MODE_CLASS (store_mode) (and the size is the same))\n\ngcc/\n\tPR rtl-optimization/33927\n\t* Makefile.in (dse.o): Depend on $(TM_P_H).\n\t* expr.h (extract_low_bits): Declare.\n\t* expmed.c (extract_low_bits): New function.\n\t* rtlhooks.c (gen_lowpart_general): Generalize SUBREG handling.\n\t* dse.c: Include tm_p.h.\n\t(find_shift_sequence): Remove the read_reg argument and return the\n\tread value.  Emit the instructions instead of returning them.\n\tIterate on new_mode rather than calculating it each time.\n\tCheck MODES_TIEABLE_P.  Use simplify_gen_subreg to convert the\n\tsource to NEW_MODE and extract_low_bits to convert the shifted\n\tvalue to READ_MODE.\n\t(replace_read): Allow the load and store to have different mode\n\tclasses.  Use extract_low_bits when SHIFT == 0.  Create the shift\n\tor extraction instructions before trying the replacement.  Update\n\tdump-file code accordingly, avoiding use of REGNO (store_info->rhs).\n\ngcc/testsuite/\n\t* gcc.target/mips/dse-1.c: Add checks for zeros.\n\nFrom-SVN: r133452", "tree": {"sha": "bb912a45ce2ff3b1666c9a26271e0833dc4b7c16", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bb912a45ce2ff3b1666c9a26271e0833dc4b7c16"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/18b526e806ab64557cd575ff407fcb1da16ee8fd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18b526e806ab64557cd575ff407fcb1da16ee8fd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/18b526e806ab64557cd575ff407fcb1da16ee8fd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18b526e806ab64557cd575ff407fcb1da16ee8fd/comments", "author": null, "committer": null, "parents": [{"sha": "48e55066d5d0cd652b6527f08cb67768c4aaabe7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/48e55066d5d0cd652b6527f08cb67768c4aaabe7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/48e55066d5d0cd652b6527f08cb67768c4aaabe7"}], "stats": {"total": 265, "additions": 165, "deletions": 100}, "files": [{"sha": "03ea12a4efd25b948981b7629a88853b627ad636", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18b526e806ab64557cd575ff407fcb1da16ee8fd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18b526e806ab64557cd575ff407fcb1da16ee8fd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=18b526e806ab64557cd575ff407fcb1da16ee8fd", "patch": "@@ -1,3 +1,22 @@\n+2008-03-22  Richard Sandiford  <rsandifo@nildram.co.uk>\n+\n+\tPR rtl-optimization/33927\n+\t* Makefile.in (dse.o): Depend on $(TM_P_H).\n+\t* expr.h (extract_low_bits): Declare.\n+\t* expmed.c (extract_low_bits): New function.\n+\t* rtlhooks.c (gen_lowpart_general): Generalize SUBREG handling.\n+\t* dse.c: Include tm_p.h.\n+\t(find_shift_sequence): Remove the read_reg argument and return the\n+\tread value.  Emit the instructions instead of returning them.\n+\tIterate on new_mode rather than calculating it each time.\n+\tCheck MODES_TIEABLE_P.  Use simplify_gen_subreg to convert the\n+\tsource to NEW_MODE and extract_low_bits to convert the shifted\n+\tvalue to READ_MODE.\n+\t(replace_read): Allow the load and store to have different mode\n+\tclasses.  Use extract_low_bits when SHIFT == 0.  Create the shift\n+\tor extraction instructions before trying the replacement.  Update\n+\tdump-file code accordingly, avoiding use of REGNO (store_info->rhs).\n+\n 2008-03-22  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* config/i386/i386.c (assign_386_stack_local): Align DImode slots"}, {"sha": "407e2fefdbde5f3890f22cc537ef86026c0fb8a5", "filename": "gcc/Makefile.in", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18b526e806ab64557cd575ff407fcb1da16ee8fd/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18b526e806ab64557cd575ff407fcb1da16ee8fd/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=18b526e806ab64557cd575ff407fcb1da16ee8fd", "patch": "@@ -2555,8 +2555,8 @@ dce.o : dce.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(TREE_H) $(REGS_H) hard-reg-set.h $(FLAGS_H) $(DF_H) cselib.h \\\n    $(DBGCNT_H) dce.h timevar.h tree-pass.h $(DBGCNT_H)\n dse.o : dse.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n-   $(TREE_H) $(REGS_H) hard-reg-set.h $(FLAGS_H) insn-config.h $(RECOG_H) \\\n-   $(EXPR_H) $(DF_H) cselib.h $(DBGCNT_H) timevar.h tree-pass.h \\\n+   $(TREE_H) $(TM_P_H) $(REGS_H) hard-reg-set.h $(FLAGS_H) insn-config.h \\\n+   $(RECOG_H) $(EXPR_H) $(DF_H) cselib.h $(DBGCNT_H) timevar.h tree-pass.h \\\n    alloc-pool.h $(ALIAS_H) dse.h $(OPTABS_H)\n fwprop.o : fwprop.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    toplev.h insn-config.h $(RECOG_H) $(FLAGS_H) $(OBSTACK_H) $(BASIC_BLOCK_H) \\"}, {"sha": "696b2d84ff31b3ae4df506f41b9386a7294fa86c", "filename": "gcc/dse.c", "status": "modified", "additions": 66, "deletions": 87, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18b526e806ab64557cd575ff407fcb1da16ee8fd/gcc%2Fdse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18b526e806ab64557cd575ff407fcb1da16ee8fd/gcc%2Fdse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdse.c?ref=18b526e806ab64557cd575ff407fcb1da16ee8fd", "patch": "@@ -29,6 +29,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tm.h\"\n #include \"rtl.h\"\n #include \"tree.h\"\n+#include \"tm_p.h\"\n #include \"regs.h\"\n #include \"hard-reg-set.h\"\n #include \"flags.h\"\n@@ -1383,9 +1384,9 @@ record_store (rtx body, bb_info_t bb_info)\n   if (store_info->is_set \n       /* No place to keep the value after ra.  */\n       && !reload_completed\n-      /* The careful reviewer may wish to comment my checking that the\n-\t rhs of a store is always a reg.  */\n-      && REG_P (SET_SRC (body))\n+      && (REG_P (SET_SRC (body))\n+\t  || GET_CODE (SET_SRC (body)) == SUBREG\n+\t  || CONSTANT_P (SET_SRC (body)))\n       /* Sometimes the store and reload is used for truncation and\n \t rounding.  */\n       && !(FLOAT_MODE_P (GET_MODE (mem)) && (flag_float_store)))\n@@ -1418,15 +1419,15 @@ dump_insn_info (const char * start, insn_info_t insn_info)\n    shift.  */\n \n static rtx\n-find_shift_sequence (rtx read_reg,\n-\t\t     int access_size,\n+find_shift_sequence (int access_size,\n \t\t     store_info_t store_info,\n \t\t     read_info_t read_info,\n \t\t     int shift)\n {\n   enum machine_mode store_mode = GET_MODE (store_info->mem);\n   enum machine_mode read_mode = GET_MODE (read_info->mem);\n-  rtx chosen_seq = NULL;\n+  enum machine_mode new_mode;\n+  rtx read_reg = NULL;\n \n   /* Some machines like the x86 have shift insns for each size of\n      operand.  Other machines like the ppc or the ia-64 may only have\n@@ -1435,21 +1436,31 @@ find_shift_sequence (rtx read_reg,\n      justify the value we want to read but is available in one insn on\n      the machine.  */\n \n-  for (; access_size <= UNITS_PER_WORD; access_size *= 2)\n+  for (new_mode = smallest_mode_for_size (access_size * BITS_PER_UNIT,\n+\t\t\t\t\t  MODE_INT);\n+       GET_MODE_BITSIZE (new_mode) <= BITS_PER_WORD;\n+       new_mode = GET_MODE_WIDER_MODE (new_mode))\n     {\n-      rtx target, new_reg, shift_seq, insn;\n-      enum machine_mode new_mode;\n+      rtx target, new_reg, shift_seq, insn, new_lhs;\n       int cost;\n \n-      /* Try a wider mode if truncating the store mode to ACCESS_SIZE\n-\t bytes requires a real instruction.  */\n-      if (access_size < GET_MODE_SIZE (store_mode)\n-\t  && !TRULY_NOOP_TRUNCATION (access_size * BITS_PER_UNIT,\n+      /* Try a wider mode if truncating the store mode to NEW_MODE\n+\t requires a real instruction.  */\n+      if (GET_MODE_BITSIZE (new_mode) < GET_MODE_BITSIZE (store_mode)\n+\t  && !TRULY_NOOP_TRUNCATION (GET_MODE_BITSIZE (new_mode),\n \t\t\t\t     GET_MODE_BITSIZE (store_mode)))\n \tcontinue;\n \n-      new_mode = smallest_mode_for_size (access_size * BITS_PER_UNIT,\n-\t\t\t\t\t MODE_INT);\n+      /* Also try a wider mode if the necessary punning is either not\n+\t desirable or not possible.  */\n+      if (!CONSTANT_P (store_info->rhs)\n+\t  && !MODES_TIEABLE_P (new_mode, store_mode))\n+\tcontinue;\n+      new_lhs = simplify_gen_subreg (new_mode, copy_rtx (store_info->rhs),\n+\t\t\t\t     store_mode, 0);\n+      if (new_lhs == NULL_RTX)\n+\tcontinue;\n+\n       new_reg = gen_reg_rtx (new_mode);\n \n       start_sequence ();\n@@ -1485,31 +1496,13 @@ find_shift_sequence (rtx read_reg,\n \t take the value from the store and put it into the\n \t shift pseudo, then shift it, then generate another\n \t move to put in into the target of the read.  */\n-      start_sequence ();\n-      emit_move_insn (new_reg, gen_lowpart (new_mode, store_info->rhs));\n+      emit_move_insn (new_reg, new_lhs);\n       emit_insn (shift_seq);\n-      convert_move (read_reg, new_reg, 1);\n-\t\t  \n-      if (dump_file)\n-\t{\n-\t  fprintf (dump_file, \" -- adding extract insn r%d:%s = r%d:%s\\n\",\n-\t\t   REGNO (new_reg), GET_MODE_NAME (new_mode),\n-\t\t   REGNO (store_info->rhs), GET_MODE_NAME (store_mode));\n-\t\t      \n-\t  fprintf (dump_file, \" -- with shift of r%d by %d\\n\",\n-\t\t   REGNO(new_reg), shift);\n-\t  fprintf (dump_file, \" -- and second extract insn r%d:%s = r%d:%s\\n\",\n-\t\t   REGNO (read_reg), GET_MODE_NAME (read_mode),\n-\t\t   REGNO (new_reg), GET_MODE_NAME (new_mode));\n-\t}\n-\t\t  \n-      /* Get the three insn sequence and return it.  */\n-      chosen_seq = get_insns ();\n-      end_sequence ();\n+      read_reg = extract_low_bits (read_mode, new_mode, new_reg);\n       break;\n     }\n \n-  return chosen_seq;\n+  return read_reg;\n }\n \n \n@@ -1552,16 +1545,11 @@ replace_read (store_info_t store_info, insn_info_t store_insn,\n   enum machine_mode read_mode = GET_MODE (read_info->mem);\n   int shift;\n   int access_size; /* In bytes.  */\n-  rtx read_reg = gen_reg_rtx (read_mode);\n-  rtx shift_seq = NULL;\n+  rtx insns, read_reg;\n \n   if (!dbg_cnt (dse))\n     return false;\n \n-  if (GET_MODE_CLASS (read_mode) != MODE_INT\n-      || GET_MODE_CLASS (store_mode) != MODE_INT)\n-    return false;\n-\n   /* To get here the read is within the boundaries of the write so\n      shift will never be negative.  Start out with the shift being in\n      bytes.  */\n@@ -1575,62 +1563,43 @@ replace_read (store_info_t store_info, insn_info_t store_insn,\n   /* From now on it is bits.  */\n   shift *= BITS_PER_UNIT;\n \n-  /* We need to keep this in perspective.  We are replacing a read\n+  /* Create a sequence of instructions to set up the read register.\n+     This sequence goes immediately before the store and its result\n+     is read by the load.\n+\n+     We need to keep this in perspective.  We are replacing a read\n      with a sequence of insns, but the read will almost certainly be\n      in cache, so it is not going to be an expensive one.  Thus, we\n      are not willing to do a multi insn shift or worse a subroutine\n      call to get rid of the read.  */\n+  if (dump_file)\n+    fprintf (dump_file, \"trying to replace %smode load in insn %d\"\n+\t     \" from %smode store in insn %d\\n\",\n+\t     GET_MODE_NAME (read_mode), INSN_UID (read_insn->insn),\n+\t     GET_MODE_NAME (store_mode), INSN_UID (store_insn->insn));\n+  start_sequence ();\n   if (shift)\n+    read_reg = find_shift_sequence (access_size, store_info, read_info, shift);\n+  else\n+    read_reg = extract_low_bits (read_mode, store_mode,\n+\t\t\t\t copy_rtx (store_info->rhs));\n+  if (read_reg == NULL_RTX)\n     {\n-      if (access_size > UNITS_PER_WORD)\n-\treturn false;\n-\n-      shift_seq = find_shift_sequence (read_reg, access_size, store_info,\n-\t\t\t\t       read_info, shift);\n-      if (!shift_seq)\n-\treturn false;\n+      end_sequence ();\n+      if (dump_file)\n+\tfprintf (dump_file, \" -- could not extract bits of stored value\\n\");\n+      return false;\n     }\n-\n-  if (dump_file)\n-    fprintf (dump_file, \"replacing load at %d from store at %d\\n\",\n-\t     INSN_UID (read_insn->insn), INSN_UID (store_insn->insn)); \n+  /* Force the value into a new register so that it won't be clobbered\n+     between the store and the load.  */\n+  read_reg = copy_to_mode_reg (read_mode, read_reg);\n+  insns = get_insns ();\n+  end_sequence ();\n \n   if (validate_change (read_insn->insn, loc, read_reg, 0))\n     {\n-      rtx insns;\n       deferred_change_t deferred_change = pool_alloc (deferred_change_pool);\n       \n-      if (read_mode == store_mode)\n-\t{\n-\t  start_sequence ();\n-\t  \n-\t  /* The modes are the same and everything lines up.  Just\n-\t     generate a simple move.  */\n-\t  emit_move_insn (read_reg, store_info->rhs);\n-\t  if (dump_file)\n-\t    fprintf (dump_file, \" -- adding move insn r%d = r%d\\n\",\n-\t\t     REGNO (read_reg), REGNO (store_info->rhs));\n-\t  insns = get_insns ();\n-\t  end_sequence ();\n-\t}\n-      else if (shift)\n-\tinsns = shift_seq;\n-      else\n-\t{\n-\t  /* The modes are different but the lsb are in the same\n-\t     place, we need to extract the value in the right from the\n-\t     rhs of the store.  */\n-\t  start_sequence ();\n-\t  convert_move (read_reg, store_info->rhs, 1);\n-\t  \n-\t  if (dump_file)\n-\t    fprintf (dump_file, \" -- adding extract insn r%d:%s = r%d:%s\\n\",\n-\t\t     REGNO (read_reg), GET_MODE_NAME (read_mode),\n-\t\t     REGNO (store_info->rhs), GET_MODE_NAME (store_mode));\n-\t  insns = get_insns ();\n-\t  end_sequence ();\n-\t}\n-\n       /* Insert this right before the store insn where it will be safe\n \t from later insns that might change it before the read.  */\n       emit_insn_before (insns, store_insn->insn);\n@@ -1668,12 +1637,22 @@ replace_read (store_info_t store_info, insn_info_t store_insn,\n \t rest of dse, play like this read never happened.  */\n       read_insn->read_rec = read_info->next;\n       pool_free (read_info_pool, read_info);\n+      if (dump_file)\n+\t{\n+\t  fprintf (dump_file, \" -- replaced the loaded MEM with \");\n+\t  print_simple_rtl (dump_file, read_reg);\n+\t  fprintf (dump_file, \"\\n\");\n+\t}\n       return true;\n     }\n   else \n     {\n       if (dump_file)\n-\tfprintf (dump_file, \" -- validation failure\\n\"); \n+\t{\n+\t  fprintf (dump_file, \" -- replacing the loaded MEM with \");\n+\t  print_simple_rtl (dump_file, read_reg);\n+\t  fprintf (dump_file, \" led to an invalid instruction\\n\");\n+\t}\n       return false;\n     }\n }"}, {"sha": "2f2e3cc657d755c8419b64b50b91ebe09dc2b467", "filename": "gcc/expmed.c", "status": "modified", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18b526e806ab64557cd575ff407fcb1da16ee8fd/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18b526e806ab64557cd575ff407fcb1da16ee8fd/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=18b526e806ab64557cd575ff407fcb1da16ee8fd", "patch": "@@ -2098,6 +2098,66 @@ extract_split_bit_field (rtx op0, unsigned HOST_WIDE_INT bitsize,\n \t\t       NULL_RTX, 0);\n }\n \f\n+/* Try to read the low bits of SRC as an rvalue of mode MODE, preserving\n+   the bit pattern.  SRC_MODE is the mode of SRC; if this is smaller than\n+   MODE, fill the upper bits with zeros.  Fail if the layout of either\n+   mode is unknown (as for CC modes) or if the extraction would involve\n+   unprofitable mode punning.  Return the value on success, otherwise\n+   return null.\n+\n+   This is different from gen_lowpart* in these respects:\n+\n+     - the returned value must always be considered an rvalue\n+\n+     - when MODE is wider than SRC_MODE, the extraction involves\n+       a zero extension\n+\n+     - when MODE is smaller than SRC_MODE, the extraction involves\n+       a truncation (and is thus subject to TRULY_NOOP_TRUNCATION).\n+\n+   In other words, this routine performs a computation, whereas the\n+   gen_lowpart* routines are conceptually lvalue or rvalue subreg\n+   operations.  */\n+\n+rtx\n+extract_low_bits (enum machine_mode mode, enum machine_mode src_mode, rtx src)\n+{\n+  enum machine_mode int_mode, src_int_mode;\n+\n+  if (mode == src_mode)\n+    return src;\n+\n+  if (CONSTANT_P (src))\n+    return simplify_gen_subreg (mode, src, src_mode,\n+\t\t\t\tsubreg_lowpart_offset (mode, src_mode));\n+\n+  if (GET_MODE_CLASS (mode) == MODE_CC || GET_MODE_CLASS (src_mode) == MODE_CC)\n+    return NULL_RTX;\n+\n+  if (GET_MODE_BITSIZE (mode) == GET_MODE_BITSIZE (src_mode)\n+      && MODES_TIEABLE_P (mode, src_mode))\n+    {\n+      rtx x = gen_lowpart_common (mode, src);\n+      if (x)\n+        return x;\n+    }\n+\n+  src_int_mode = int_mode_for_mode (src_mode);\n+  int_mode = int_mode_for_mode (mode);\n+  if (src_int_mode == BLKmode || int_mode == BLKmode)\n+    return NULL_RTX;\n+\n+  if (!MODES_TIEABLE_P (src_int_mode, src_mode))\n+    return NULL_RTX;\n+  if (!MODES_TIEABLE_P (int_mode, mode))\n+    return NULL_RTX;\n+\n+  src = gen_lowpart (src_int_mode, src);\n+  src = convert_modes (int_mode, src_int_mode, src, true);\n+  src = gen_lowpart (mode, src);\n+  return src;\n+}\n+\f\n /* Add INC into TARGET.  */\n \n void"}, {"sha": "e3b2471393a4712abe222a760f185845a41ba584", "filename": "gcc/expr.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18b526e806ab64557cd575ff407fcb1da16ee8fd/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18b526e806ab64557cd575ff407fcb1da16ee8fd/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=18b526e806ab64557cd575ff407fcb1da16ee8fd", "patch": "@@ -744,6 +744,7 @@ extern void store_bit_field (rtx, unsigned HOST_WIDE_INT,\n extern rtx extract_bit_field (rtx, unsigned HOST_WIDE_INT,\n \t\t\t      unsigned HOST_WIDE_INT, int, rtx,\n \t\t\t      enum machine_mode, enum machine_mode);\n+extern rtx extract_low_bits (enum machine_mode, enum machine_mode, rtx);\n extern rtx expand_mult (enum machine_mode, rtx, rtx, rtx, int);\n extern rtx expand_mult_highpart_adjust (enum machine_mode, rtx, rtx, rtx, rtx, int);\n "}, {"sha": "432b286c1d88c0f8c64c132c1ab7997bef01eb40", "filename": "gcc/rtlhooks.c", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18b526e806ab64557cd575ff407fcb1da16ee8fd/gcc%2Frtlhooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18b526e806ab64557cd575ff407fcb1da16ee8fd/gcc%2Frtlhooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlhooks.c?ref=18b526e806ab64557cd575ff407fcb1da16ee8fd", "patch": "@@ -43,11 +43,9 @@ gen_lowpart_general (enum machine_mode mode, rtx x)\n \n   if (result)\n     return result;\n-  /* If it's a REG, it must be a hard reg that's not valid in MODE.  */\n-  else if (REG_P (x)\n-\t   /* Or we could have a subreg of a floating point value.  */\n-\t   || (GET_CODE (x) == SUBREG\n-\t       && FLOAT_MODE_P (GET_MODE (SUBREG_REG (x)))))\n+  /* Handle SUBREGs and hard REGs that were rejected by\n+     simplify_gen_subreg.  */\n+  else if (REG_P (x) || GET_CODE (x) == SUBREG)\n     {\n       result = gen_lowpart_common (mode, copy_to_reg (x));\n       gcc_assert (result != 0);"}, {"sha": "e952bef7e2ae85169c68d605e212f55628232d84", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18b526e806ab64557cd575ff407fcb1da16ee8fd/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18b526e806ab64557cd575ff407fcb1da16ee8fd/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=18b526e806ab64557cd575ff407fcb1da16ee8fd", "patch": "@@ -1,3 +1,7 @@\n+2008-03-22  Richard Sandiford  <rsandifo@nildram.co.uk>\n+\n+\t* gcc.target/mips/dse-1.c: Add checks for zeros.\n+\n 2008-03-21  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n \n \tPR target/27946"}, {"sha": "30ceb73f461f157543aab978cd04c9ddbf9453c1", "filename": "gcc/testsuite/gcc.target/mips/dse-1.c", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18b526e806ab64557cd575ff407fcb1da16ee8fd/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fdse-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18b526e806ab64557cd575ff407fcb1da16ee8fd/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fdse-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fdse-1.c?ref=18b526e806ab64557cd575ff407fcb1da16ee8fd", "patch": "@@ -1,7 +1,4 @@\n-/* ??? Further to the subreg comment below, we can't rely on any of the\n-   tests passing unless we handle subregs, and the patch to do so has\n-   been rejected for the time being.  */\n-/* { dg-do compile { target { ! *-*-* } } } */\n+/* { dg-do compile } */\n /* { dg-mips-options \"-mgp64 -O\" } */\n \n #define TEST(ID, TYPE1, TYPE2)\t\t\t\t\t\\\n@@ -18,6 +15,13 @@\n     u->m2 = x;\t\t\t\t\t\t\t\\\n     return (u->m1[0]\t\t\t\t\t\t\\\n \t    + u->m1[sizeof (TYPE2) / sizeof (TYPE1) - 1]);\t\\\n+  }\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\\\n+  TYPE1 __attribute__((nomips16))\t\t\t\t\\\n+  g##ID (union u##ID *u)\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\\\n+    u->m2 = 0;\t\t\t\t\t\t\t\\\n+    return (u->m1[0] | u->m1[1]);\t\t\t\t\\\n   }\n \n TEST (1, unsigned int, unsigned long long);\n@@ -32,8 +36,8 @@ TEST (8, short, int);\n TEST (9, unsigned char, unsigned int);\n TEST (10, signed char, int);\n \n-/* DSE isn't yet read to consider stores of subregs, so the corresponding\n-   (char, short) tests won't pass.  */\n+TEST (11, unsigned char, unsigned short);\n+TEST (12, signed char, short);\n \n /* { dg-final { scan-assembler-not \"\\tlh\\t\" } } */\n /* { dg-final { scan-assembler-not \"\\tlhu\\t\" } } */"}]}