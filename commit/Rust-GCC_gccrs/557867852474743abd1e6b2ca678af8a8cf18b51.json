{"sha": "557867852474743abd1e6b2ca678af8a8cf18b51", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTU3ODY3ODUyNDc0NzQzYWJkMWU2YjJjYTY3OGFmOGE4Y2YxOGI1MQ==", "commit": {"author": {"name": "Ville Voutilainen", "email": "ville.voutilainen@gmail.com", "date": "2016-09-21T17:25:16Z"}, "committer": {"name": "Ville Voutilainen", "email": "ville@gcc.gnu.org", "date": "2016-09-21T17:25:16Z"}, "message": "Implement LWG 2729 for tuple.\n\n\t* include/std/tuple (_Tuple_impl(_Tuple_impl&&)):\n\tSuppress conditionally.\n\t(_Tuple_impl(_Tuple_impl<_Idx, _UHead, _UTails...>&&)): Likewise.\n\t(__is_tuple_impl_trait_impl, __is_tuple_impl_trait): New.\n\t(_Tuple_impl(const _Head&)): Constrain.\n\t(_Tuple_impl(_UHead&&)): Likewise.\n\t(_Tuple_impl(_Tuple_impl&&)): Suppress conditionally.\n\t(_Tuple_impl(const _Tuple_impl<_Idx, _UHead>&)): Constrain.\n\t(_Tuple_impl(_Tuple_impl<_Idx, _UHead>&&)): Likewise.\n\t(operator=(const tuple&)): Enable conditionally.\n\t(operator=(tuple&&)): Suppress conditionally.\n\t(operator=(const tuple<_UElements...>&)): Constrain.\n\t(operator=(tuple<_UElements...>&&)): Likewise.\n\t(operator=(const tuple&)): Enable conditionally (2-param tuple).\n\t(operator=(tuple&&)): Suppress conditionally (2-param tuple).\n\t(operator=(const tuple<_U1, _U2>&)): Constrain.\n\t(operator=(tuple<_U1, _U2>&&)): Likewise.\n\t(operator=(const pair<_U1, _U2>&)): Likewise.\n\t(operator=(pair<_U1, _U2>&&)): Likewise.\n\t* testsuite/20_util/tuple/element_access/get_neg.cc: Adjust.\n\t* testsuite/20_util/tuple/tuple_traits.cc: New.\n\nFrom-SVN: r240323", "tree": {"sha": "b4550db8a90a68c2afeea53d7398291da5409cc6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b4550db8a90a68c2afeea53d7398291da5409cc6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/557867852474743abd1e6b2ca678af8a8cf18b51", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/557867852474743abd1e6b2ca678af8a8cf18b51", "html_url": "https://github.com/Rust-GCC/gccrs/commit/557867852474743abd1e6b2ca678af8a8cf18b51", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/557867852474743abd1e6b2ca678af8a8cf18b51/comments", "author": {"login": "villevoutilainen", "id": 963599, "node_id": "MDQ6VXNlcjk2MzU5OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/963599?v=4", "gravatar_id": "", "url": "https://api.github.com/users/villevoutilainen", "html_url": "https://github.com/villevoutilainen", "followers_url": "https://api.github.com/users/villevoutilainen/followers", "following_url": "https://api.github.com/users/villevoutilainen/following{/other_user}", "gists_url": "https://api.github.com/users/villevoutilainen/gists{/gist_id}", "starred_url": "https://api.github.com/users/villevoutilainen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/villevoutilainen/subscriptions", "organizations_url": "https://api.github.com/users/villevoutilainen/orgs", "repos_url": "https://api.github.com/users/villevoutilainen/repos", "events_url": "https://api.github.com/users/villevoutilainen/events{/privacy}", "received_events_url": "https://api.github.com/users/villevoutilainen/received_events", "type": "User", "site_admin": false}, "committer": {"login": "villevoutilainen", "id": 963599, "node_id": "MDQ6VXNlcjk2MzU5OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/963599?v=4", "gravatar_id": "", "url": "https://api.github.com/users/villevoutilainen", "html_url": "https://github.com/villevoutilainen", "followers_url": "https://api.github.com/users/villevoutilainen/followers", "following_url": "https://api.github.com/users/villevoutilainen/following{/other_user}", "gists_url": "https://api.github.com/users/villevoutilainen/gists{/gist_id}", "starred_url": "https://api.github.com/users/villevoutilainen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/villevoutilainen/subscriptions", "organizations_url": "https://api.github.com/users/villevoutilainen/orgs", "repos_url": "https://api.github.com/users/villevoutilainen/repos", "events_url": "https://api.github.com/users/villevoutilainen/events{/privacy}", "received_events_url": "https://api.github.com/users/villevoutilainen/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f524d5b34aaac95cb4b2ce7126002cd4fa9d5bae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f524d5b34aaac95cb4b2ce7126002cd4fa9d5bae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f524d5b34aaac95cb4b2ce7126002cd4fa9d5bae"}], "stats": {"total": 367, "additions": 349, "deletions": 18}, "files": [{"sha": "35dc2b5734894b39505946659549a1136f2c2756", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/557867852474743abd1e6b2ca678af8a8cf18b51/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/557867852474743abd1e6b2ca678af8a8cf18b51/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=557867852474743abd1e6b2ca678af8a8cf18b51", "patch": "@@ -1,3 +1,28 @@\n+2016-09-21  Ville Voutilainen  <ville.voutilainen@gmail.com>\n+\n+\tImplement LWG 2729 for tuple.\n+\t* include/std/tuple (_Tuple_impl(_Tuple_impl&&)):\n+\tSuppress conditionally.\n+\t(_Tuple_impl(_Tuple_impl<_Idx, _UHead, _UTails...>&&)): Likewise.\n+\t(__is_tuple_impl_trait_impl, __is_tuple_impl_trait): New.\n+\t(_Tuple_impl(const _Head&)): Constrain.\n+\t(_Tuple_impl(_UHead&&)): Likewise.\n+\t(_Tuple_impl(_Tuple_impl&&)): Suppress conditionally.\n+\t(_Tuple_impl(const _Tuple_impl<_Idx, _UHead>&)): Constrain.\n+\t(_Tuple_impl(_Tuple_impl<_Idx, _UHead>&&)): Likewise.\n+\t(operator=(const tuple&)): Enable conditionally.\n+\t(operator=(tuple&&)): Suppress conditionally.\n+\t(operator=(const tuple<_UElements...>&)): Constrain.\n+\t(operator=(tuple<_UElements...>&&)): Likewise.\n+\t(operator=(const tuple&)): Enable conditionally (2-param tuple).\n+\t(operator=(tuple&&)): Suppress conditionally (2-param tuple).\n+\t(operator=(const tuple<_U1, _U2>&)): Constrain.\n+\t(operator=(tuple<_U1, _U2>&&)): Likewise.\n+\t(operator=(const pair<_U1, _U2>&)): Likewise.\n+\t(operator=(pair<_U1, _U2>&&)): Likewise.\n+\t* testsuite/20_util/tuple/element_access/get_neg.cc: Adjust.\n+\t* testsuite/20_util/tuple/tuple_traits.cc: New.\n+\n 2016-09-21  Ville Voutilainen  <ville.voutilainen@gmail.com>\n \n \tPR libstdc++/77537"}, {"sha": "32b932f79fd4144931a21acdb3d3c520b98bd182", "filename": "libstdc++-v3/include/std/tuple", "status": "modified", "additions": 79, "deletions": 17, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/557867852474743abd1e6b2ca678af8a8cf18b51/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftuple", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/557867852474743abd1e6b2ca678af8a8cf18b51/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftuple", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftuple?ref=557867852474743abd1e6b2ca678af8a8cf18b51", "patch": "@@ -220,8 +220,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       constexpr _Tuple_impl(const _Tuple_impl&) = default;\n \n       constexpr\n-      _Tuple_impl(_Tuple_impl&& __in)\n-      noexcept(__and_<is_nothrow_move_constructible<_Head>,\n+      _Tuple_impl(typename conditional<\n+\t\t  __and_<is_move_constructible<_Head>,\n+\t\t         is_move_constructible<_Inherited>>::value,\n+\t\t  _Tuple_impl&&, __nonesuch&&>::type __in)\n+\tnoexcept(__and_<is_nothrow_move_constructible<_Head>,\n \t              is_nothrow_move_constructible<_Inherited>>::value)\n       : _Inherited(std::move(_M_tail(__in))),\n \t_Base(std::forward<_Head>(_M_head(__in))) { }\n@@ -232,7 +235,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  _Base(_Tuple_impl<_Idx, _UElements...>::_M_head(__in)) { }\n \n       template<typename _UHead, typename... _UTails>\n-        constexpr _Tuple_impl(_Tuple_impl<_Idx, _UHead, _UTails...>&& __in)\n+        constexpr _Tuple_impl(typename conditional<\n+\t\t\t      __and_<is_move_constructible<_Head>,\n+\t\t\t      is_move_constructible<_Inherited>>::value,\n+\t\t\t      _Tuple_impl<_Idx, _UHead, _UTails...>&&,\n+\t\t\t      __nonesuch&&>::type __in)\n \t: _Inherited(std::move\n \t\t     (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_tail(__in))),\n \t  _Base(std::forward<_UHead>\n@@ -338,6 +345,18 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       }\n     };\n \n+  template<typename...>\n+    struct __is_tuple_impl_trait_impl : false_type\n+    { };\n+\n+  template<std::size_t _Idx, typename... _Tp>\n+    struct __is_tuple_impl_trait_impl<_Tuple_impl<_Idx, _Tp...>> : true_type\n+    { };\n+\n+  template<typename _Tp>\n+    struct __is_tuple_impl_trait : public __is_tuple_impl_trait_impl<_Tp>\n+    { };\n+\n   // Basis case of inheritance recursion.\n   template<std::size_t _Idx, typename _Head>\n     struct _Tuple_impl<_Idx, _Head>\n@@ -356,27 +375,42 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       constexpr _Tuple_impl()\n       : _Base() { }\n \n+      template<typename _Dummy=void,\n+\t       typename enable_if<is_constructible<_Base, const _Head&>::value,\n+\t\t\t\t  bool>::type=true>\n       explicit\n       constexpr _Tuple_impl(const _Head& __head)\n       : _Base(__head) { }\n \n-      template<typename _UHead>\n+      template<typename _UHead,\n+\t       typename enable_if<__and_<is_constructible<_Base, _UHead&&>,\n+\t\t\t\t\t __not_<__is_tuple_impl_trait<\n+\t\t\t\t\t   typename\n+\t\t\t\t\t     remove_reference<_UHead>::type>>\n+\t\t\t\t\t >::value,\n+\t\t\t\t  bool>::type = true>\n         explicit\n         constexpr _Tuple_impl(_UHead&& __head)\n \t: _Base(std::forward<_UHead>(__head)) { }\n \n       constexpr _Tuple_impl(const _Tuple_impl&) = default;\n \n       constexpr\n-      _Tuple_impl(_Tuple_impl&& __in)\n+      _Tuple_impl(typename conditional<\n+\t\t  is_move_constructible<_Head>::value,\n+\t\t  _Tuple_impl&&, __nonesuch&&>::type __in)\n       noexcept(is_nothrow_move_constructible<_Head>::value)\n       : _Base(std::forward<_Head>(_M_head(__in))) { }\n \n-      template<typename _UHead>\n+      template<typename _UHead,\n+\t       typename enable_if<!is_same<_Head, _UHead>::value,\n+\t\t\t\t  bool>::type = true>\n         constexpr _Tuple_impl(const _Tuple_impl<_Idx, _UHead>& __in)\n \t: _Base(_Tuple_impl<_Idx, _UHead>::_M_head(__in)) { }\n \n-      template<typename _UHead>\n+      template<typename _UHead,\n+\t       typename enable_if<!is_same<_Head, _UHead>::value,\n+\t\t\t\t  bool>::type = true>\n         constexpr _Tuple_impl(_Tuple_impl<_Idx, _UHead>&& __in)\n \t: _Base(std::forward<_UHead>(_Tuple_impl<_Idx, _UHead>::_M_head(__in)))\n \t{ }\n@@ -832,14 +866,18 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t{ }\n \n       tuple&\n-      operator=(const tuple& __in)\n+      operator=(typename\n+\t\tconditional<__and_<is_copy_assignable<_Elements>...>::value,\n+\t\tconst tuple&, const __nonesuch&>::type __in)\n       {\n \tstatic_cast<_Inherited&>(*this) = __in;\n \treturn *this;\n       }\n \n       tuple&\n-      operator=(tuple&& __in)\n+      operator=(typename\n+\t\tconditional<__and_<is_move_assignable<_Elements>...>::value,\n+\t\ttuple&&, __nonesuch&&>::type __in)\n       noexcept(is_nothrow_move_assignable<_Inherited>::value)\n       {\n \tstatic_cast<_Inherited&>(*this) = std::move(__in);\n@@ -848,7 +886,10 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n       template<typename... _UElements, typename = typename\n \t       enable_if<sizeof...(_UElements)\n-\t\t\t == sizeof...(_Elements)>::type>\n+\t\t\t == sizeof...(_Elements)\n+\t       &&\n+\t       __and_<is_assignable<_Elements&,\n+\t\t\t\t    const _UElements&>...>::value>::type>\n         tuple&\n         operator=(const tuple<_UElements...>& __in)\n         {\n@@ -858,7 +899,10 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n       template<typename... _UElements, typename = typename\n \t       enable_if<sizeof...(_UElements)\n-\t\t\t == sizeof...(_Elements)>::type>\n+\t\t\t == sizeof...(_Elements)\n+\t       &&\n+\t       __and_<is_assignable<_Elements&,\n+\t\t\t\t    _UElements&&>...>::value>::type>\n         tuple&\n         operator=(tuple<_UElements...>&& __in)\n         {\n@@ -1189,38 +1233,53 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\t     std::forward<_U2>(__in.second)) { }\n \n       tuple&\n-      operator=(const tuple& __in)\n+      operator=(typename\n+\t\tconditional<__and_<is_copy_assignable<_T1>,\n+\t\t                   is_copy_assignable<_T2>>::value,\n+\t\tconst tuple&, const __nonesuch&>::type __in)\n       {\n \tstatic_cast<_Inherited&>(*this) = __in;\n \treturn *this;\n       }\n \n       tuple&\n-      operator=(tuple&& __in)\n+      operator=(typename\n+\t\tconditional<__and_<is_move_assignable<_T1>,\n+\t\t                   is_move_assignable<_T2>>::value,\n+\t\ttuple&&, __nonesuch&&>::type __in)\n       noexcept(is_nothrow_move_assignable<_Inherited>::value)\n       {\n \tstatic_cast<_Inherited&>(*this) = std::move(__in);\n \treturn *this;\n       }\n \n       template<typename _U1, typename _U2>\n-        tuple&\n+        typename\n+          enable_if<__and_<is_assignable<_T1&, const _U1&>,\n+\t\t\t   is_assignable<_T2&, const _U2&>>::value,\n+\t\t\t   tuple&>::type\n         operator=(const tuple<_U1, _U2>& __in)\n         {\n \t  static_cast<_Inherited&>(*this) = __in;\n \t  return *this;\n \t}\n \n       template<typename _U1, typename _U2>\n-        tuple&\n+        typename\n+          enable_if<__and_<is_assignable<_T1&, _U1&&>,\n+\t\t\t   is_assignable<_T2&, _U2&&>>::value,\n+\t\t\t   tuple&>::type\n         operator=(tuple<_U1, _U2>&& __in)\n         {\n \t  static_cast<_Inherited&>(*this) = std::move(__in);\n \t  return *this;\n \t}\n \n       template<typename _U1, typename _U2>\n-        tuple&\n+        typename\n+          enable_if<__and_<is_assignable<_T1&, const _U1&>,\n+\t\t\t   is_assignable<_T2&, const _U2&>>::value,\n+\t\t\t   tuple&>::type\n         operator=(const pair<_U1, _U2>& __in)\n         {\n \t  this->_M_head(*this) = __in.first;\n@@ -1229,7 +1288,10 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t}\n \n       template<typename _U1, typename _U2>\n-        tuple&\n+        typename\n+          enable_if<__and_<is_assignable<_T1&, _U1&&>,\n+\t\t\t   is_assignable<_T2&, _U2&&>>::value,\n+\t\t\t   tuple&>::type\n         operator=(pair<_U1, _U2>&& __in)\n         {\n \t  this->_M_head(*this) = std::forward<_U1>(__in.first);"}, {"sha": "1c08d459648d7513ca48807473fbab70da39cb3a", "filename": "libstdc++-v3/testsuite/20_util/tuple/element_access/get_neg.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/557867852474743abd1e6b2ca678af8a8cf18b51/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ftuple%2Felement_access%2Fget_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/557867852474743abd1e6b2ca678af8a8cf18b51/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ftuple%2Felement_access%2Fget_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ftuple%2Felement_access%2Fget_neg.cc?ref=557867852474743abd1e6b2ca678af8a8cf18b51", "patch": "@@ -17,7 +17,7 @@\n \n // { dg-options \"-fno-show-column\" }\n // { dg-do compile { target c++14 } }\n-// { dg-error \"in range\" \"\" { target *-*-* } 1280 }\n+// { dg-error \"in range\" \"\" { target *-*-* } 1342 }\n \n #include <tuple>\n "}, {"sha": "b72f535a6fc1977239ba4cd0d3886213bd21797f", "filename": "libstdc++-v3/testsuite/20_util/tuple/tuple_traits.cc", "status": "added", "additions": 244, "deletions": 0, "changes": 244, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/557867852474743abd1e6b2ca678af8a8cf18b51/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ftuple%2Ftuple_traits.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/557867852474743abd1e6b2ca678af8a8cf18b51/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ftuple%2Ftuple_traits.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ftuple%2Ftuple_traits.cc?ref=557867852474743abd1e6b2ca678af8a8cf18b51", "patch": "@@ -0,0 +1,244 @@\n+// { dg-do compile { target c++11 } }\n+\n+// Copyright (C) 2016 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <tuple>\n+#include <type_traits>\n+#include <utility>\n+#include <vector>\n+#include <memory>\n+\n+using namespace std;\n+\n+struct Poison\n+{\n+\tPoison(Poison&&) = delete;\n+};\n+\n+\n+int main()\n+{\n+\tstatic_assert(!is_copy_constructible<Poison>::value, \"\");\n+\tstatic_assert(!is_move_constructible<Poison>::value, \"\");\n+\tstatic_assert(!is_copy_assignable<Poison>::value, \"\");\n+\tstatic_assert(!is_move_assignable<Poison>::value, \"\");\n+\n+\tstatic_assert(!is_copy_constructible<std::tuple<Poison>>::value, \"\");\n+\tstatic_assert(!is_move_constructible<std::tuple<Poison>>::value, \"\");\n+\tstatic_assert(!is_copy_assignable<std::tuple<Poison>>::value, \"\");\n+\tstatic_assert(!is_move_assignable<std::tuple<Poison>>::value, \"\");\n+\n+\tstatic_assert(!is_copy_constructible<std::tuple<int, Poison>>::value,\n+\t\t      \"\");\n+\tstatic_assert(!is_move_constructible<std::tuple<int, Poison>>::value,\n+\t\t      \"\");\n+\tstatic_assert(!is_copy_assignable<std::tuple<int, Poison>>::value, \"\");\n+\tstatic_assert(!is_move_assignable<std::tuple<int, Poison>>::value, \"\");\n+\tstatic_assert(!is_constructible<std::tuple<int, Poison>&,\n+\t\t      std::tuple<char, Poison>&>::value, \"\");\n+\tstatic_assert(!is_assignable<std::tuple<int, Poison>&,\n+\t\t      std::tuple<char, Poison>&>::value, \"\");\n+\tstatic_assert(!is_constructible<std::tuple<int, Poison>&,\n+\t\t      std::tuple<char, Poison>>::value, \"\");\n+\tstatic_assert(!is_assignable<std::tuple<int, Poison>&,\n+\t\t      std::tuple<char, Poison>>::value, \"\");\n+\tstatic_assert(!is_constructible<std::tuple<int, Poison>&,\n+\t\t      std::pair<char, Poison>&>::value, \"\");\n+\tstatic_assert(!is_assignable<std::tuple<int, Poison>&,\n+\t\t      std::pair<char, Poison>&>::value, \"\");\n+\tstatic_assert(!is_constructible<std::tuple<int, Poison>&,\n+\t\t      std::pair<char, Poison>>::value, \"\");\n+\tstatic_assert(!is_assignable<std::tuple<int, Poison>&,\n+\t\t      std::pair<char, Poison>>::value, \"\");\n+\n+\tstatic_assert(!is_copy_constructible<\n+\t\t      std::tuple<int, int, Poison>>::value, \"\");\n+\tstatic_assert(!is_move_constructible<\n+\t\t      std::tuple<int, int, Poison>>::value, \"\");\n+\tstatic_assert(!is_copy_assignable<\n+\t\t      std::tuple<int, int, Poison>>::value, \"\");\n+\tstatic_assert(!is_move_assignable<\n+\t\t      std::tuple<int, int, Poison>>::value, \"\");\n+\tstatic_assert(!is_constructible<\n+\t\t      std::tuple<int, int,Poison>&,\n+\t\t      std::tuple<int, char, Poison>&>::value, \"\");\n+\tstatic_assert(!is_assignable<\n+\t\t      std::tuple<int, int, Poison>&,\n+\t\t      std::tuple<int, char, Poison>&>::value, \"\");\n+\tstatic_assert(!is_constructible<\n+\t\t      std::tuple<int, int, Poison>&,\n+\t\t      std::tuple<int, char, Poison>>::value, \"\");\n+\tstatic_assert(!is_assignable<\n+\t\t      std::tuple<int, int, Poison>&,\n+\t\t      std::tuple<int, char, Poison>>::value, \"\");\n+\tstatic_assert(!is_constructible<\n+\t\t      std::tuple<int, int, Poison>&,\n+\t\t      std::pair<char, Poison>&>::value, \"\");\n+\tstatic_assert(!is_assignable<\n+\t\t      std::tuple<int, int, Poison>&,\n+\t\t      std::pair<char, Poison>&>::value, \"\");\n+\tstatic_assert(!is_constructible<\n+\t\t      std::tuple<int, int, Poison>&,\n+\t\t      std::pair<char, Poison>>::value, \"\");\n+\tstatic_assert(!is_assignable<\n+\t\t      std::tuple<int, int, Poison>&,\n+\t\t      std::pair<char, Poison>>::value, \"\");\n+\n+\tstatic_assert(is_trivially_copy_constructible<tuple<int>>::value, \"\");\n+\tstatic_assert(!is_trivially_move_constructible<tuple<int>>::value, \"\");\n+\n+\tstatic_assert(!is_trivially_copy_assignable<tuple<int>>::value, \"\");\n+\tstatic_assert(!is_trivially_move_assignable<tuple<int>>::value, \"\");\n+\n+\tstatic_assert(is_copy_constructible<tuple<int>>::value, \"\");\n+\tstatic_assert(is_move_constructible<tuple<int>>::value, \"\");\n+\n+\tstatic_assert(is_copy_assignable<tuple<int>>::value, \"\");\n+\tstatic_assert(is_move_assignable<tuple<int>>::value, \"\");\n+\n+\tstatic_assert(!is_trivially_copy_constructible<\n+\t\t      tuple<vector<int>>>::value, \"\");\n+\tstatic_assert(!is_trivially_move_constructible<\n+\t\t      tuple<vector<int>>>::value, \"\");\n+\n+\tstatic_assert(!is_trivially_copy_assignable<\n+\t\t      tuple<vector<int>>>::value, \"\");\n+\tstatic_assert(!is_trivially_move_assignable<\n+\t\t      tuple<vector<int>>>::value, \"\");\n+\n+\tstatic_assert(is_copy_constructible<tuple<vector<int>>>::value, \"\");\n+\tstatic_assert(is_move_constructible<tuple<vector<int>>>::value, \"\");\n+\n+\tstatic_assert(is_copy_assignable<tuple<vector<int>>>::value, \"\");\n+\tstatic_assert(is_move_assignable<tuple<vector<int>>>::value, \"\");\n+\n+\tstatic_assert(!is_trivially_copy_constructible<\n+\t\t      tuple<unique_ptr<int>>>::value, \"\");\n+\tstatic_assert(!is_trivially_move_constructible<\n+\t\t      tuple<unique_ptr<int>>>::value, \"\");\n+\n+\tstatic_assert(!is_trivially_copy_assignable<\n+\t\t      tuple<unique_ptr<int>>>::value, \"\");\n+\tstatic_assert(!is_trivially_move_assignable<\n+\t\t      tuple<unique_ptr<int>>>::value, \"\");\n+\tstatic_assert(!is_copy_constructible<\n+\t\t      tuple<unique_ptr<int>>>::value, \"\");\n+\tstatic_assert(is_move_constructible<tuple<unique_ptr<int>>>::value, \"\");\n+\n+\tstatic_assert(!is_copy_assignable<tuple<unique_ptr<int>>>::value, \"\");\n+\tstatic_assert(is_move_assignable<tuple<unique_ptr<int>>>::value, \"\");\n+\n+\tstatic_assert(is_trivially_copy_constructible<\n+\t\t      tuple<int, int>>::value, \"\");\n+\tstatic_assert(!is_trivially_move_constructible<\n+\t\t      tuple<int, int>>::value, \"\");\n+\n+\tstatic_assert(!is_trivially_copy_assignable<\n+\t\t      tuple<int, int>>::value, \"\");\n+\tstatic_assert(!is_trivially_move_assignable<\n+\t\t      tuple<int, int>>::value, \"\");\n+\n+\tstatic_assert(is_copy_constructible<tuple<int, int>>::value, \"\");\n+\tstatic_assert(is_move_constructible<tuple<int, int>>::value, \"\");\n+\n+\tstatic_assert(is_copy_assignable<tuple<int, int>>::value, \"\");\n+\tstatic_assert(is_move_assignable<tuple<int, int>>::value, \"\");\n+\tstatic_assert(!is_trivially_copy_constructible<\n+\t\t      tuple<int, vector<int>>>::value, \"\");\n+\tstatic_assert(!is_trivially_move_constructible<\n+\t\t      tuple<int, vector<int>>>::value, \"\");\n+\n+\tstatic_assert(!is_trivially_copy_assignable<\n+\t\t      tuple<int, vector<int>>>::value, \"\");\n+\tstatic_assert(!is_trivially_move_assignable<\n+\t\t      tuple<int, vector<int>>>::value, \"\");\n+\n+\tstatic_assert(is_copy_constructible<\n+\t\t      tuple<int, vector<int>>>::value, \"\");\n+\tstatic_assert(is_move_constructible<\n+\t\t      tuple<int, vector<int>>>::value, \"\");\n+\n+\tstatic_assert(is_copy_assignable<tuple<int, vector<int>>>::value, \"\");\n+\tstatic_assert(is_move_assignable<tuple<int, vector<int>>>::value, \"\");\n+\n+\tstatic_assert(!is_trivially_copy_constructible<\n+\t\t      tuple<int, unique_ptr<int>>>::value, \"\");\n+\tstatic_assert(!is_trivially_move_constructible<\n+\t\t      tuple<int, unique_ptr<int>>>::value, \"\");\n+\n+\tstatic_assert(!is_trivially_copy_assignable<\n+\t\t      tuple<int, unique_ptr<int>>>::value, \"\");\n+\tstatic_assert(!is_trivially_move_assignable<\n+\t\t      tuple<int, unique_ptr<int>>>::value, \"\");\n+\n+\tstatic_assert(!is_copy_constructible<\n+\t\t      tuple<int, unique_ptr<int>>>::value, \"\");\n+\tstatic_assert(is_move_constructible<\n+\t\t      tuple<int, unique_ptr<int>>>::value, \"\");\n+\n+\tstatic_assert(!is_copy_assignable<\n+\t\t      tuple<int, unique_ptr<int>>>::value, \"\");\n+\tstatic_assert(is_move_assignable<\n+\t\t      tuple<int, unique_ptr<int>>>::value, \"\");\n+\n+\tstatic_assert(is_copy_constructible<tuple<int, int, int>>::value, \"\");\n+\tstatic_assert(is_move_constructible<tuple<int, int, int>>::value, \"\");\n+\n+\tstatic_assert(is_copy_assignable<tuple<int, int, int>>::value, \"\");\n+\tstatic_assert(is_move_assignable<tuple<int, int, int>>::value, \"\");\n+\n+\tstatic_assert(!is_trivially_copy_constructible<\n+\t\t      tuple<int, int, vector<int>>>::value, \"\");\n+\tstatic_assert(!is_trivially_move_constructible<\n+\t\t      tuple<int, int, vector<int>>>::value, \"\");\n+\n+\tstatic_assert(!is_trivially_copy_assignable<\n+\t\t      tuple<int, int, vector<int>>>::value, \"\");\n+\tstatic_assert(!is_trivially_move_assignable<\n+\t\t      tuple<int, int, vector<int>>>::value, \"\");\n+\n+\tstatic_assert(is_copy_constructible<\n+\t\t      tuple<int, int, vector<int>>>::value, \"\");\n+\tstatic_assert(is_move_constructible<\n+\t\t      tuple<int, int, vector<int>>>::value, \"\");\n+\n+\tstatic_assert(is_copy_assignable<\n+\t\t      tuple<int, int, vector<int>>>::value, \"\");\n+\tstatic_assert(is_move_assignable<\n+\t\t      tuple<int, int, vector<int>>>::value, \"\");\n+\n+\tstatic_assert(!is_trivially_copy_constructible<\n+\t\t      tuple<int, int, unique_ptr<int>>>::value, \"\");\n+\tstatic_assert(!is_trivially_move_constructible<\n+\t\t      tuple<int, int, unique_ptr<int>>>::value, \"\");\n+\n+\tstatic_assert(!is_trivially_copy_assignable<\n+\t\t      tuple<int, int, unique_ptr<int>>>::value, \"\");\n+\tstatic_assert(!is_trivially_move_assignable<\n+\t\t      tuple<int, int, unique_ptr<int>>>::value, \"\");\n+\n+\tstatic_assert(!is_copy_constructible<\n+\t\t      tuple<int, int, unique_ptr<int>>>::value, \"\");\n+\tstatic_assert(is_move_constructible<\n+\t\t      tuple<int, int, unique_ptr<int>>>::value, \"\");\n+\n+\tstatic_assert(!is_copy_assignable<\n+\t\t      tuple<int, int, unique_ptr<int>>>::value, \"\");\n+\tstatic_assert(is_move_assignable<\n+\t\t      tuple<int, int, unique_ptr<int>>>::value, \"\");\n+}"}]}