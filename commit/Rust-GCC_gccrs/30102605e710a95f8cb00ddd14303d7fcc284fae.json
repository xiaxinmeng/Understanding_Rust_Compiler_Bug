{"sha": "30102605e710a95f8cb00ddd14303d7fcc284fae", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzAxMDI2MDVlNzEwYTk1ZjhjYjAwZGRkMTQzMDNkN2ZjYzI4NGZhZQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2001-09-11T08:52:39Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2001-09-11T08:52:39Z"}, "message": "Cray T3E port.\n\nFrom-SVN: r45539", "tree": {"sha": "89de0166f267747621eba79ef570f0cb00c9654a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/89de0166f267747621eba79ef570f0cb00c9654a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/30102605e710a95f8cb00ddd14303d7fcc284fae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30102605e710a95f8cb00ddd14303d7fcc284fae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/30102605e710a95f8cb00ddd14303d7fcc284fae", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30102605e710a95f8cb00ddd14303d7fcc284fae/comments", "author": null, "committer": null, "parents": [{"sha": "b1c4394d5db5b1c73458e8927dbcedc101874e04", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b1c4394d5db5b1c73458e8927dbcedc101874e04", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b1c4394d5db5b1c73458e8927dbcedc101874e04"}], "stats": {"total": 3567, "additions": 3228, "deletions": 339}, "files": [{"sha": "7b9891e3f06300ea94e3b677baefea8dfd8f036e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30102605e710a95f8cb00ddd14303d7fcc284fae/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30102605e710a95f8cb00ddd14303d7fcc284fae/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=30102605e710a95f8cb00ddd14303d7fcc284fae", "patch": "@@ -1,3 +1,93 @@\n+2001-09-11  Richard Henderson  <rth@redhat.com>\n+\n+\t* config/alpha/alpha.c: Tidy formatting.\n+\t(local_symbolic_operand): Verify mode.\n+\t(alpha_sa_mask): Ignore unicos for eh_return.\n+\t(alpha_expand_epilogue): Handle sp_adj2 zero, not NULL.\n+\t* config/alpha/alpha.md (umk divsi patterns): Remove.\n+\t(extendsfdf2): Remove unicos check.\n+\t(tablejump): Merge vms and unicos code; always use direct set\n+\tplus label_ref use.\n+\n+2001-09-11  Roman Lechtchinsky  <rl@cs.tu-berlin.de>\n+\n+\t* config.gcc (alpha*-*-unicosmk*): New target.\n+\n+\t* config/alpha/alpha-protos.h (symbolic_operand,\n+\tunicosmk_add_call_info_word, unicosmk_add_extern,\n+\tunicosmk_defer_case_vector, unicosmk_unique_section,\n+\tunicosmk_output_align, unicosmk_text_section, unicosmk_data_section,\n+\tunicosmk_asm_file_start, unicosmk_asm_file_end,\n+\tunicosmk_output_common): Declare.\n+\n+\t* config/alpha/alpha.c (NUM_ARGS, override_options, call_operand,\n+\tdirect_return, function_arg, alpha_va_start, alpha_va_arg,\n+\talpha_does_function_need_gp, alpha_end_function): Support Cray\n+\tUnicos/Mk.\n+\t(alpha_init_machine_status, alpha_mark_machine_status,\n+\talpha_free_machine_status, unicosmk_output_deferred_case_vectors,\n+\tunicosmk_gen_dsib, unicosmk_output_ssib, unicosmk_need_dex,\n+\tunicosmk_asm_named_section, unicosmk_insert_attributes,\n+\tunicosmk_section_type_flags, symbolic_operand,\n+\tunicosmk_output_module_name, unicosmk_output_default_externs,\n+\tunicosmk_output_dex, unicosmk_output_externs,\n+\tunicosmk_output_addr_vec, unicosmk_ssib_name,\n+\tunicosmk_initial_elimination_offset, unicosmk_asm_file_start,\n+\tunicosmk_asm_file_end, unicosmk_output_common,\n+\tunicosmk_section_type_flags, unicosmk_unique_section,\n+\tunicosmk_add_call_info_word, unicosmk_text_section,\n+\tunicosmk_data_section, unicosmk_extern_list, unicosmk_extern_head,\n+\tunicosmk_add_extern, unicosmk_dex, unicosmk_dex_list,\n+\tunicosmk_dex_count, unicosmk_special_name): New.\n+\t(TARGET_INSERT_ATTRIBUTES, TARGET_SECTION_TYPE_FLAGS): Define for\n+\tTARGET_ABI_UNICOSMK.\n+\t(get_aligned_mem, alpha_expand_unaligned_load,\n+\talpha_expand_unaligned_store, alpha_expand_unaligned_load_words,\n+\talpha_expand_unaligned_store_words): Support big-endian mode.\n+\t(print_operand): Likewise. New format specifier 't'. Use\n+\tTARGET_AS_SLASH_BEFORE_SUFFIX.\n+\t(alpha_is_stack_procedure): Rename from vms_is_stack_procedure.\n+\t(alpha_pv_save_size): Update with above change.\n+\t(alpha_sa_mask, alpha_sa_size, alpha_expand_prologue,\n+\talpha_start_function, alpha_expand_epilogue): Likewise. Support Cray\n+\tUnicos/Mk.\n+\n+\t* config/alpha/alpha.h (TARGET_ABI_UNICOSMK): New.\n+\t(TARGET_ABI_OSF): Exclude TARGET_ABI_UNICOSMK.\n+\t(TARGET_AS_SLASH_BEFORE_SUFFIX): New.\n+\t(EXTRA_CONSTRAINT): New constraint 'U'.\n+\t(PREDICATE_CODES): Add symbolic_operand.\n+\n+\t* config/alpha/alpha.md (UNSPEC_UMK_LAUM, UNSPEC_UMK_LALM,\n+\tUNSPEC_UMK_LAL, UNSPEC_UMK_LOAD_CIW): New constants.\n+\t(mulsi3, *mulsi_se, mulvsi3): Disable for TARGET_ABI_UNICOSMK.\n+\t(integer division and modulus patterns): Split in default and\n+\tUnicos/Mk versions.\n+\t(*divmodsi_internal, *divmoddi_internal): Disable for\n+\tTARGET_ABI_UNICOSMK.\n+\t(unaligned_extend?idi, unaligned_load?i, unaligned_store?i): Split in \n+\tlittle-endian and big-endian versions.\n+\t(ext, ins, msk): Likewise.\n+\t(extv, extzv, insv): Support big-endian mode.\n+\t(call, call_value, tablejump): Support TARGET_ABI_UNICOSMK.\n+\t(call_umk, call_value_umk, *call_umk, tablejump_umk,\n+\t*tablejump_umk_internal, *call_value_umk): New.\n+\t(*movdi_nofix): Add pattern for loading an address into a register on\n+\tTARGET_ABI_UNICOSMK.\n+\t(umk_laum, umk_lal, umk_lalm, *umk_load_ciw): New.\n+\t(umk_mismatch_args, arg_home_umk): New.\n+\t(various insns): Don't use mov, fmov, nop, fnop and unop.\n+\t(realign): Support TARGET_ABI_UNICOSMK.\n+\n+\t* config/alpha/unicosmk.h: New file.\n+\t* config/alpha/t-unicosmk: New file.\n+\n+\t* fixinc/inclhack.def (unicosmk_restrict): New.\n+\t* fixinc/fixincl.x: Regenerate.\n+\n+\t* ginclude/stddef.h (size_t): Check for and define __SIZE_T__.\n+\t(wchar_t): Check for and define __WCHAR_T__.\n+\n 2001-09-11  Richard Sandiford  <rsandifo@redhat.com>\n \n \t* combine.c (simplify_shift_const): Treat shifts by the mode"}, {"sha": "00ed9b32f55a5016cf3e89e62fd8b5fbd7cdb603", "filename": "gcc/config.gcc", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30102605e710a95f8cb00ddd14303d7fcc284fae/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30102605e710a95f8cb00ddd14303d7fcc284fae/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=30102605e710a95f8cb00ddd14303d7fcc284fae", "patch": "@@ -398,6 +398,14 @@ a29k-wrs-vxworks*)\n a29k-*-*)\t\t\t# Default a29k environment.\n \tuse_collect2=yes\n \t;;\n+alpha*-*-unicosmk*)\n+\tuse_collect2=yes\n+\ttm_file=\"${tm_file} alpha/unicosmk.h\"\n+\t\n+\t# Don't include t-ieee for now because we don't support that yet\n+\t# tmake_file=\"alpha/t-ieee\"\n+\ttmake_file=\"alpha/t-unicosmk\"\n+\t;;\n alpha-*-interix)\n \ttm_file=\"${tm_file} alpha/alpha32.h interix.h alpha/alpha-interix.h\"\n "}, {"sha": "c8ff11228b700adb77b31e6d4f4ba05af7e41390", "filename": "gcc/config/alpha/alpha-protos.h", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30102605e710a95f8cb00ddd14303d7fcc284fae/gcc%2Fconfig%2Falpha%2Falpha-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30102605e710a95f8cb00ddd14303d7fcc284fae/gcc%2Fconfig%2Falpha%2Falpha-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha-protos.h?ref=30102605e710a95f8cb00ddd14303d7fcc284fae", "patch": "@@ -56,6 +56,7 @@ extern int input_operand PARAMS ((rtx, enum machine_mode));\n extern int current_file_function_operand PARAMS ((rtx, enum machine_mode));\n extern int local_symbolic_operand PARAMS ((rtx, enum machine_mode));\n extern int call_operand PARAMS ((rtx, enum machine_mode));\n+extern int symbolic_operand PARAMS ((rtx, enum machine_mode));\n extern int alpha_comparison_operator PARAMS ((rtx, enum machine_mode));\n extern int alpha_zero_comparison_operator PARAMS ((rtx, enum machine_mode));\n extern int alpha_swapped_comparison_operator PARAMS ((rtx, enum machine_mode));\n@@ -149,3 +150,23 @@ extern void alpha_start_function PARAMS ((FILE *, const char *, tree));\n extern void alpha_end_function PARAMS ((FILE *, const char *, tree));\n extern void alpha_encode_section_info PARAMS ((tree));\n #endif /* TREE CODE */\n+\n+#ifdef RTX_CODE\n+extern rtx unicosmk_add_call_info_word PARAMS ((rtx));\n+#endif\n+\n+#if TARGET_ABI_UNICOSMK\n+#ifdef RTX_CODE\n+extern void unicosmk_defer_case_vector PARAMS ((rtx, rtx));\n+#endif\n+#ifdef TREE_CODE\n+extern void unicosmk_unique_section PARAMS ((tree, int));\n+#endif\n+extern void unicosmk_add_extern PARAMS ((const char *));\n+extern void unicosmk_output_align PARAMS ((FILE *, int));\n+extern char * unicosmk_text_section PARAMS ((void));\n+extern char * unicosmk_data_section PARAMS ((void));\n+extern void unicosmk_asm_file_start PARAMS ((FILE *));\n+extern void unicosmk_asm_file_end PARAMS ((FILE *));\n+extern void unicosmk_output_common PARAMS ((FILE *, const char *, int, int));\n+#endif /* TARGET_ABI_UNICOSMK */"}, {"sha": "8ee718f29fd1554b233d32fa776ee3da08493ac9", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 1537, "deletions": 190, "changes": 1727, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30102605e710a95f8cb00ddd14303d7fcc284fae/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30102605e710a95f8cb00ddd14303d7fcc284fae/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=30102605e710a95f8cb00ddd14303d7fcc284fae", "patch": "@@ -153,8 +153,22 @@ static int alpha_issue_rate\n static int alpha_variable_issue\n   PARAMS ((FILE *, int, rtx, int));\n \n+#if TARGET_ABI_UNICOSMK\n+static void alpha_init_machine_status\n+  PARAMS ((struct function *p));\n+static void alpha_mark_machine_status\n+  PARAMS ((struct function *p));\n+static void alpha_free_machine_status\n+  PARAMS ((struct function *p));\n+#endif\n+\n+static void unicosmk_output_deferred_case_vectors PARAMS ((FILE *));\n+static void unicosmk_gen_dsib PARAMS ((unsigned long *imaskP));\n+static void unicosmk_output_ssib PARAMS ((FILE *, const char *));\n+static int unicosmk_need_dex PARAMS ((rtx));\n+\n /* Get the number of args of a function in one of two ways.  */\n-#if TARGET_ABI_OPEN_VMS\n+#if TARGET_ABI_OPEN_VMS || TARGET_ABI_UNICOSMK\n #define NUM_ARGS current_function_args_info.num_args\n #else\n #define NUM_ARGS current_function_args_info\n@@ -176,6 +190,17 @@ static void vms_asm_out_destructor PARAMS ((rtx, int));\n # define TARGET_SECTION_TYPE_FLAGS vms_section_type_flags\n #endif\n \n+#if TARGET_ABI_UNICOSMK\n+static void unicosmk_asm_named_section PARAMS ((const char *, unsigned int));\n+static void unicosmk_insert_attributes PARAMS ((tree, tree *));\n+static unsigned int unicosmk_section_type_flags PARAMS ((tree, const char *, \n+\t\t\t\t\t\t\t int));\n+# undef TARGET_INSERT_ATTRIBUTES\n+# define TARGET_INSERT_ATTRIBUTES unicosmk_insert_attributes\n+# undef TARGET_SECTION_TYPE_FLAGS\n+# define TARGET_SECTION_TYPE_FLAGS unicosmk_section_type_flags\n+#endif\n+\n #undef TARGET_ASM_FUNCTION_END_PROLOGUE\n #define TARGET_ASM_FUNCTION_END_PROLOGUE alpha_output_function_end_prologue\n \n@@ -218,20 +243,50 @@ override_options ()\n     { 0, 0, 0 }\n   };\n                   \n+  /* Unicos/Mk doesn't have shared libraries.  */\n+  if (TARGET_ABI_UNICOSMK && flag_pic)\n+    {\n+      warning (\"-f%s ignored for Unicos/Mk (not supported)\",\n+\t       (flag_pic > 1) ? \"PIC\" : \"pic\");\n+      flag_pic = 0;\n+    }\n+\n+  /* On Unicos/Mk, the native compiler consistenly generates /d suffices for \n+     floating-point instructions.  Make that the default for this target.  */\n+  if (TARGET_ABI_UNICOSMK)\n+    alpha_fprm = ALPHA_FPRM_DYN;\n+  else\n+    alpha_fprm = ALPHA_FPRM_NORM;\n+\n   alpha_tp = ALPHA_TP_PROG;\n-  alpha_fprm = ALPHA_FPRM_NORM;\n   alpha_fptm = ALPHA_FPTM_N;\n \n+  /* We cannot use su and sui qualifiers for conversion instructions on \n+     Unicos/Mk.  I'm not sure if this is due to assembler or hardware\n+     limitations.  Right now, we issue a warning if -mieee is specified\n+     and then ignore it; eventually, we should either get it right or\n+     disable the option altogether.  */\n+\n   if (TARGET_IEEE)\n     {\n-      alpha_tp = ALPHA_TP_INSN;\n-      alpha_fptm = ALPHA_FPTM_SU;\n+      if (TARGET_ABI_UNICOSMK)\n+\twarning (\"-mieee not supported on Unicos/Mk\");\n+      else\n+\t{\n+\t  alpha_tp = ALPHA_TP_INSN;\n+\t  alpha_fptm = ALPHA_FPTM_SU;\n+\t}\n     }\n \n   if (TARGET_IEEE_WITH_INEXACT)\n     {\n-      alpha_tp = ALPHA_TP_INSN;\n-      alpha_fptm = ALPHA_FPTM_SUI;\n+      if (TARGET_ABI_UNICOSMK)\n+\twarning (\"-mieee-with-inexact not supported on Unicos/Mk\");\n+      else\n+\t{\n+\t  alpha_tp = ALPHA_TP_INSN;\n+\t  alpha_fptm = ALPHA_FPTM_SUI;\n+\t}\n     }\n \n   if (alpha_tp_string)\n@@ -308,6 +363,12 @@ override_options ()\n \n   /* Do some sanity checks on the above options. */\n \n+  if (TARGET_ABI_UNICOSMK && alpha_fptm != ALPHA_FPTM_N)\n+    {\n+      warning (\"trap mode not supported on Unicos/Mk\");\n+      alpha_fptm = ALPHA_FPTM_N;\n+    }\n+\n   if ((alpha_fptm == ALPHA_FPTM_SU || alpha_fptm == ALPHA_FPTM_SUI)\n       && alpha_tp != ALPHA_TP_INSN && ! TARGET_CPU_EV6)\n     {\n@@ -402,6 +463,15 @@ override_options ()\n \n   /* Acquire a unique set number for our register saves and restores.  */\n   alpha_sr_alias_set = new_alias_set ();\n+\n+  /* Register variables and functions with the garbage collector.  */\n+\n+#if TARGET_ABI_UNICOSMK\n+  /* Set up function hooks.  */\n+  init_machine_status = alpha_init_machine_status;\n+  mark_machine_status = alpha_mark_machine_status;\n+  free_machine_status = alpha_free_machine_status;\n+#endif\n }\n \f\n /* Returns 1 if VALUE is a mask that contains full bytes of zero or ones.  */\n@@ -774,10 +844,13 @@ current_file_function_operand (op, mode)\n int\n local_symbolic_operand (op, mode)\n      rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n+     enum machine_mode mode;\n {\n   const char *str;\n \n+  if (mode != VOIDmode && GET_MODE (op) != VOIDmode && mode != GET_MODE (op))\n+    return 0;\n+\n   if (GET_CODE (op) == LABEL_REF)\n     return 1;\n \n@@ -813,6 +886,8 @@ call_operand (op, mode)\n   if (mode != Pmode)\n     return 0;\n \n+  if (TARGET_ABI_UNICOSMK)\n+    return GET_CODE (op) == REG;\n   if (GET_CODE (op) == SYMBOL_REF)\n     return 1;\n   if (GET_CODE (op) == REG)\n@@ -826,6 +901,26 @@ call_operand (op, mode)\n   return 0;\n }\n \n+/* Returns 1 if OP is a symbolic operand, i.e. a symbol_ref or a label_ref,\n+   possibly with an offset.  */\n+\n+int\n+symbolic_operand (op, mode)\n+      register rtx op;\n+      enum machine_mode mode;\n+{\n+  if (mode != VOIDmode && GET_MODE (op) != VOIDmode && mode != GET_MODE (op))\n+    return 0;\n+  if (GET_CODE (op) == SYMBOL_REF || GET_CODE (op) == LABEL_REF)\n+    return 1;\n+  if (GET_CODE (op) == CONST\n+      && GET_CODE (XEXP (op,0)) == PLUS\n+      && GET_CODE (XEXP (XEXP (op,0), 0)) == SYMBOL_REF\n+      && GET_CODE (XEXP (XEXP (op,0), 1)) == CONST_INT)\n+    return 1;\n+  return 0;\n+}\n+\n /* Return 1 if OP is a valid Alpha comparison operator.  Here we know which\n    comparisons are valid in which insn.  */\n \n@@ -1140,7 +1235,7 @@ addition_operation (op, mode)\n int\n direct_return ()\n {\n-  return (! TARGET_ABI_OPEN_VMS\n+  return (! TARGET_ABI_OPEN_VMS && ! TARGET_ABI_UNICOSMK\n \t  && reload_completed\n \t  && alpha_sa_size () == 0\n \t  && get_frame_size () == 0\n@@ -1582,7 +1677,11 @@ get_aligned_mem (ref, paligned_mem, pbitnum)\n      data in a different alias set.  */\n   set_mem_alias_set (*paligned_mem, 0);\n \n-  *pbitnum = GEN_INT ((offset & 3) * 8);\n+  if (WORDS_BIG_ENDIAN)\n+    *pbitnum = GEN_INT (32 - (GET_MODE_BITSIZE (GET_MODE (ref))\n+\t\t\t      + (offset & 3) * 8));\n+  else\n+    *pbitnum = GEN_INT ((offset & 3) * 8);\n }\n \n /* Similar, but just get the address.  Handle the two reload cases.  \n@@ -1912,7 +2011,7 @@ alpha_emit_set_const_1 (target, mode, c, n)\n       /* Now try high-order 1 bits.  We get that with a sign-extension.\n \t But one bit isn't enough here.  Be careful to avoid shifting outside\n \t the mode and to avoid shifting outside the host wide int size. */\n-      \n+\n       if ((bits = (MIN (HOST_BITS_PER_WIDE_INT, GET_MODE_SIZE (mode) * 8)\n \t\t   - floor_log2 (~ c) - 2)) > 0)\n \tfor (; bits > 0; bits--)\n@@ -3197,12 +3296,23 @@ alpha_expand_unaligned_load (tgt, mem, size, ofs, sign)\n   set_mem_alias_set (tmp, 0);\n   emit_move_insn (memh, tmp);\n \n-  if (sign && size == 2)\n+  if (WORDS_BIG_ENDIAN && sign && (size == 2 || size == 4))\n+    {\n+      emit_move_insn (addr, plus_constant (mema, -1));\n+\n+      emit_insn (gen_extqh_be (extl, meml, addr));\n+      emit_insn (gen_extxl_be (exth, memh, GEN_INT (64), addr));\n+\n+      addr = expand_binop (DImode, ior_optab, extl, exth, tgt, 1, OPTAB_WIDEN);\n+      addr = expand_binop (DImode, ashr_optab, addr, GEN_INT (64 - size*8),\n+\t\t\t   addr, 1, OPTAB_WIDEN);\n+    }\n+  else if (sign && size == 2)\n     {\n       emit_move_insn (addr, plus_constant (mema, ofs+2));\n \n-      emit_insn (gen_extxl (extl, meml, GEN_INT (64), addr));\n-      emit_insn (gen_extqh (exth, memh, addr));\n+      emit_insn (gen_extxl_le (extl, meml, GEN_INT (64), addr));\n+      emit_insn (gen_extqh_le (exth, memh, addr));\n \n       /* We must use tgt here for the target.  Alpha-vms port fails if we use\n \t addr for the target, because addr is marked as a pointer and combine\n@@ -3213,27 +3323,55 @@ alpha_expand_unaligned_load (tgt, mem, size, ofs, sign)\n     }\n   else\n     {\n-      emit_move_insn (addr, plus_constant (mema, ofs));\n-      emit_insn (gen_extxl (extl, meml, GEN_INT (size*8), addr));\n-      switch ((int) size)\n+      if (WORDS_BIG_ENDIAN)\n \t{\n-\tcase 2:\n-\t  emit_insn (gen_extwh (exth, memh, addr));\n-\t  mode = HImode;\n-\t  break;\n+\t  emit_move_insn (addr, plus_constant (mema, ofs+size-1));\n+\t  switch ((int) size)\n+\t    {\n+\t    case 2:\n+\t      emit_insn (gen_extwh_be (extl, meml, addr));\n+\t      mode = HImode;\n+\t      break;\n \n-\tcase 4:\n-\t  emit_insn (gen_extlh (exth, memh, addr));\n-\t  mode = SImode;\n-\t  break;\n+\t    case 4:\n+\t      emit_insn (gen_extlh_be (extl, meml, addr));\n+\t      mode = SImode;\n+\t      break;\n \n-\tcase 8:\n-\t  emit_insn (gen_extqh (exth, memh, addr));\n-\t  mode = DImode;\n-\t  break;\n+\t    case 8:\n+\t      emit_insn (gen_extqh_be (extl, meml, addr));\n+\t      mode = DImode;\n+\t      break;\n \n-\tdefault:\n-\t  abort();\n+\t    default:\n+\t      abort ();\n+\t    }\n+\t  emit_insn (gen_extxl_be (exth, memh, GEN_INT (size*8), addr));\n+\t}\n+      else\n+\t{\n+\t  emit_move_insn (addr, plus_constant (mema, ofs));\n+\t  emit_insn (gen_extxl_le (extl, meml, GEN_INT (size*8), addr));\n+\t  switch ((int) size)\n+\t    {\n+\t    case 2:\n+\t      emit_insn (gen_extwh_le (exth, memh, addr));\n+\t      mode = HImode;\n+\t      break;\n+\n+\t    case 4:\n+\t      emit_insn (gen_extlh_le (exth, memh, addr));\n+\t      mode = SImode;\n+\t      break;\n+\n+\t    case 8:\n+\t      emit_insn (gen_extqh_le (exth, memh, addr));\n+\t      mode = DImode;\n+\t      break;\n+\n+\t    default:\n+\t      abort();\n+\t    }\n \t}\n \n       addr = expand_binop (mode, ior_optab, gen_lowpart (mode, extl),\n@@ -3281,58 +3419,113 @@ alpha_expand_unaligned_store (dst, src, size, ofs)\n \n   emit_move_insn (dsth, memh);\n   emit_move_insn (dstl, meml);\n-  addr = copy_addr_to_reg (plus_constant (dsta, ofs));\n-\n-  if (src != const0_rtx)\n+  if (WORDS_BIG_ENDIAN)\n     {\n-      emit_insn (gen_insxh (insh, gen_lowpart (DImode, src),\n-\t\t\t    GEN_INT (size*8), addr));\n+      addr = copy_addr_to_reg (plus_constant (dsta, ofs+size-1));\n+\n+      if (src != const0_rtx)\n+\t{\n+\t  switch ((int) size)\n+\t    {\n+\t    case 2:\n+\t      emit_insn (gen_inswl_be (insh, gen_lowpart (HImode,src), addr));\n+\t      break;\n+\t    case 4:\n+\t      emit_insn (gen_insll_be (insh, gen_lowpart (SImode,src), addr));\n+\t      break;\n+\t    case 8:\n+\t      emit_insn (gen_insql_be (insh, gen_lowpart (DImode,src), addr));\n+\t      break;\n+\t    }\n+\t  emit_insn (gen_insxh (insl, gen_lowpart (DImode, src),\n+\t\t\t\tGEN_INT (size*8), addr));\n+\t}\n \n       switch ((int) size)\n \t{\n \tcase 2:\n-\t  emit_insn (gen_inswl (insl, gen_lowpart (HImode, src), addr));\n+\t  emit_insn (gen_mskxl_be (dsth, dsth, GEN_INT (0xffff), addr));\n \t  break;\n \tcase 4:\n-\t  emit_insn (gen_insll (insl, gen_lowpart (SImode, src), addr));\n+\t  emit_insn (gen_mskxl_be (dsth, dsth, GEN_INT (0xffffffff), addr));\n \t  break;\n \tcase 8:\n-\t  emit_insn (gen_insql (insl, src, addr));\n+\t  {\n+#if HOST_BITS_PER_WIDE_INT == 32\n+\t    rtx msk = immed_double_const (0xffffffff, 0xffffffff, DImode);\n+#else\n+\t    rtx msk = immed_double_const (0xffffffffffffffff, 0, DImode);\n+#endif\n+\t    emit_insn (gen_mskxl_be (dsth, dsth, msk, addr));\n+\t  }\n \t  break;\n \t}\n+\n+      emit_insn (gen_mskxh (dstl, dstl, GEN_INT (size*8), addr));\n     }\n+  else\n+    {\n+      addr = copy_addr_to_reg (plus_constant (dsta, ofs));\n \n-  emit_insn (gen_mskxh (dsth, dsth, GEN_INT (size*8), addr));\n+      if (src != const0_rtx)\n+\t{\n+\t  emit_insn (gen_insxh (insh, gen_lowpart (DImode, src),\n+\t\t\t\tGEN_INT (size*8), addr));\n \n-  switch ((int) size)\n-    {\n-    case 2:\n-      emit_insn (gen_mskxl (dstl, dstl, GEN_INT (0xffff), addr));\n-      break;\n-    case 4:\n-      emit_insn (gen_mskxl (dstl, dstl, GEN_INT (0xffffffff), addr));\n-      break;\n-    case 8:\n-      {\n+\t  switch ((int) size)\n+\t    {\n+\t    case 2:\n+\t      emit_insn (gen_inswl_le (insl, gen_lowpart (HImode, src), addr));\n+\t      break;\n+\t    case 4:\n+\t      emit_insn (gen_insll_le (insl, gen_lowpart (SImode, src), addr));\n+\t      break;\n+\t    case 8:\n+\t      emit_insn (gen_insql_le (insl, src, addr));\n+\t      break;\n+\t    }\n+\t}\n+\n+      emit_insn (gen_mskxh (dsth, dsth, GEN_INT (size*8), addr));\n+\n+      switch ((int) size)\n+\t{\n+\tcase 2:\n+\t  emit_insn (gen_mskxl_le (dstl, dstl, GEN_INT (0xffff), addr));\n+\t  break;\n+\tcase 4:\n+\t  emit_insn (gen_mskxl_le (dstl, dstl, GEN_INT (0xffffffff), addr));\n+\t  break;\n+\tcase 8:\n+\t  {\n #if HOST_BITS_PER_WIDE_INT == 32\n-\trtx msk = immed_double_const (0xffffffff, 0xffffffff, DImode);\n+\t    rtx msk = immed_double_const (0xffffffff, 0xffffffff, DImode);\n #else\n-\trtx msk = immed_double_const (0xffffffffffffffff, 0, DImode);\n+\t    rtx msk = immed_double_const (0xffffffffffffffff, 0, DImode);\n #endif\n-\temit_insn (gen_mskxl (dstl, dstl, msk, addr));\n-      }\n-      break;\n+\t    emit_insn (gen_mskxl_le (dstl, dstl, msk, addr));\n+\t  }\n+\t  break;\n+\t}\n     }\n \n   if (src != const0_rtx)\n     {\n       dsth = expand_binop (DImode, ior_optab, insh, dsth, dsth, 0, OPTAB_WIDEN);\n       dstl = expand_binop (DImode, ior_optab, insl, dstl, dstl, 0, OPTAB_WIDEN);\n     }\n-  \n-  /* Must store high before low for degenerate case of aligned.  */\n-  emit_move_insn (memh, dsth);\n-  emit_move_insn (meml, dstl);\n+ \n+  if (WORDS_BIG_ENDIAN)\n+    {\n+      emit_move_insn (meml, dstl);\n+      emit_move_insn (memh, dsth);\n+    }\n+  else\n+    {\n+      /* Must store high before low for degenerate case of aligned.  */\n+      emit_move_insn (memh, dsth);\n+      emit_move_insn (meml, dstl);\n+    }\n }\n \n /* The block move code tries to maximize speed by separating loads and\n@@ -3397,11 +3590,20 @@ alpha_expand_unaligned_load_words (out_regs, smem, words, ofs)\n   sreg = copy_addr_to_reg (smema);\n   areg = expand_binop (DImode, and_optab, sreg, GEN_INT (7), NULL, \n \t\t       1, OPTAB_WIDEN);\n+  if (WORDS_BIG_ENDIAN)\n+    emit_move_insn (sreg, plus_constant (sreg, 7));\n   for (i = 0; i < words; ++i)\n     {\n-      emit_insn (gen_extxl (data_regs[i], data_regs[i], i64, sreg));\n-\n-      emit_insn (gen_extqh (ext_tmps[i], data_regs[i+1], sreg));\n+      if (WORDS_BIG_ENDIAN)\n+\t{\n+\t  emit_insn (gen_extqh_be (data_regs[i], data_regs[i], sreg));\n+\t  emit_insn (gen_extxl_be (ext_tmps[i], data_regs[i+1], i64, sreg));\n+\t}\n+      else\n+\t{\n+\t  emit_insn (gen_extxl_le (data_regs[i], data_regs[i], i64, sreg));\n+\t  emit_insn (gen_extqh_le (ext_tmps[i], data_regs[i+1], sreg));\n+\t}\n       emit_insn (gen_rtx_SET (VOIDmode, ext_tmps[i],\n \t\t\t      gen_rtx_IF_THEN_ELSE (DImode,\n \t\t\t\t\t\t    gen_rtx_EQ (DImode, areg,\n@@ -3468,12 +3670,22 @@ alpha_expand_unaligned_store_words (data_regs, dmem, words, ofs)\n \n   /* Shift the input data into place.  */\n   dreg = copy_addr_to_reg (dmema);\n+  if (WORDS_BIG_ENDIAN)\n+    emit_move_insn (dreg, plus_constant (dreg, 7));\n   if (data_regs != NULL)\n     {\n       for (i = words-1; i >= 0; --i)\n \t{\n-\t  emit_insn (gen_insxh (ins_tmps[i], data_regs[i], i64, dreg));\n-\t  emit_insn (gen_insql (data_regs[i], data_regs[i], dreg));\n+\t  if (WORDS_BIG_ENDIAN)\n+\t    {\n+\t      emit_insn (gen_insql_be (ins_tmps[i], data_regs[i], dreg));\n+\t      emit_insn (gen_insxh (data_regs[i], data_regs[i], i64, dreg));\n+\t    }\n+\t  else\n+\t    {\n+\t      emit_insn (gen_insxh (ins_tmps[i], data_regs[i], i64, dreg));\n+\t      emit_insn (gen_insql_le (data_regs[i], data_regs[i], dreg));\n+\t    }\n \t}\n       for (i = words-1; i > 0; --i)\n \t{\n@@ -3484,8 +3696,16 @@ alpha_expand_unaligned_store_words (data_regs, dmem, words, ofs)\n     }\n \n   /* Split and merge the ends with the destination data.  */\n-  emit_insn (gen_mskxh (st_tmp_2, st_tmp_2, i64, dreg));\n-  emit_insn (gen_mskxl (st_tmp_1, st_tmp_1, im1, dreg));\n+  if (WORDS_BIG_ENDIAN)\n+    {\n+      emit_insn (gen_mskxl_be (st_tmp_2, st_tmp_2, im1, dreg));\n+      emit_insn (gen_mskxh (st_tmp_1, st_tmp_1, i64, dreg));\n+    }\n+  else\n+    {\n+      emit_insn (gen_mskxh (st_tmp_2, st_tmp_2, i64, dreg));\n+      emit_insn (gen_mskxl_le (st_tmp_1, st_tmp_1, im1, dreg));\n+    }\n \n   if (data_regs != NULL)\n     {\n@@ -3496,17 +3716,24 @@ alpha_expand_unaligned_store_words (data_regs, dmem, words, ofs)\n     }\n \n   /* Store it all.  */\n-  emit_move_insn (st_addr_2, st_tmp_2);\n+  if (WORDS_BIG_ENDIAN)\n+    emit_move_insn (st_addr_1, st_tmp_1);\n+  else\n+    emit_move_insn (st_addr_2, st_tmp_2);\n   for (i = words-1; i > 0; --i)\n     {\n       rtx tmp = change_address (dmem, DImode,\n \t\t\t\tgen_rtx_AND (DImode,\n-\t\t\t\t\t     plus_constant(dmema, i*8),\n+\t\t\t\t\t     plus_constant(dmema,\n+\t\t\t\t\t     WORDS_BIG_ENDIAN ? i*8-1 : i*8),\n \t\t\t\t\t     im8));\n       set_mem_alias_set (tmp, 0);\n       emit_move_insn (tmp, data_regs ? ins_tmps[i-1] : const0_rtx);\n     }\n-  emit_move_insn (st_addr_1, st_tmp_1);\n+  if (WORDS_BIG_ENDIAN)\n+    emit_move_insn (st_addr_2, st_tmp_2);\n+  else\n+    emit_move_insn (st_addr_1, st_tmp_1);\n }\n \n \n@@ -4312,6 +4539,45 @@ alpha_variable_issue (dump, verbose, insn, cim)\n }\n \n \f\n+/* Register global variables and machine-specific functions with the\n+   garbage collector.  */\n+\n+#if TARGET_ABI_UNICOSMK\n+static void\n+alpha_init_machine_status (p)\n+     struct function *p;\n+{\n+  p->machine =\n+    (struct machine_function *) xcalloc (1, sizeof (struct machine_function));\n+\n+  p->machine->first_ciw = NULL_RTX;\n+  p->machine->last_ciw = NULL_RTX;\n+  p->machine->ciw_count = 0;\n+  p->machine->addr_list = NULL_RTX;\n+}\n+\n+static void\n+alpha_mark_machine_status (p)\n+     struct function *p;\n+{\n+  struct machine_function *machine = p->machine;\n+\n+  if (machine)\n+    {\n+      ggc_mark_rtx (machine->first_ciw);\n+      ggc_mark_rtx (machine->addr_list);\n+    }\n+}\n+\n+static void\n+alpha_free_machine_status (p)\n+     struct function *p;\n+{\n+  free (p->machine);\n+  p->machine = NULL;\n+}\n+#endif /* TARGET_ABI_UNICOSMK */\n+\n /* Functions to save and restore alpha_return_addr_rtx.  */\n \n /* Start the ball rolling with RETURN_ADDR_RTX.  */\n@@ -4478,8 +4744,8 @@ print_operand (file, x, code)\n \tconst char *round = get_round_mode_suffix ();\n \n \tif (trap || round)\n-\t  fprintf (file, \"%s%s\", (trap ? trap : \"\"), (round ? round : \"\"));\n-\n+\t  fprintf (file, (TARGET_AS_SLASH_BEFORE_SUFFIX ? \"/%s%s\" : \"%s%s\"),\n+\t\t   (trap ? trap : \"\"), (round ? round : \"\"));\n \tbreak;\n       }\n \n@@ -4648,13 +4914,20 @@ print_operand (file, x, code)\n       break;\n \n     case 's':\n-      /* Write the constant value divided by 8.  */\n+      /* Write the constant value divided by 8 for little-endian mode or\n+\t (56 - value) / 8 for big-endian mode.  */\n+\n       if (GET_CODE (x) != CONST_INT\n-\t  && (unsigned HOST_WIDE_INT) INTVAL (x) >= 64\n-\t  && (INTVAL (x) & 7) != 8)\n+\t  || (unsigned HOST_WIDE_INT) INTVAL (x) >= (WORDS_BIG_ENDIAN\n+\t\t\t\t\t\t     ? 56\n+\t\t\t\t\t\t     : 64)  \n+\t  || (INTVAL (x) & 7) != 0)\n \toutput_operand_lossage (\"invalid %%s value\");\n \n-      fprintf (file, HOST_WIDE_INT_PRINT_DEC, INTVAL (x) / 8);\n+      fprintf (file, HOST_WIDE_INT_PRINT_DEC,\n+\t       WORDS_BIG_ENDIAN\n+\t       ? (56 - INTVAL (x)) / 8\n+\t       : INTVAL (x) / 8);\n       break;\n \n     case 'S':\n@@ -4668,6 +4941,18 @@ print_operand (file, x, code)\n       fprintf (file, HOST_WIDE_INT_PRINT_DEC, (64 - INTVAL (x)) / 8);\n       break;\n \n+    case 't':\n+      {\n+        /* On Unicos/Mk systems: use a DEX expression if the symbol\n+\t   clashes with a register name.  */\n+\tint dex = unicosmk_need_dex (x);\n+\tif (dex)\n+\t  fprintf (file, \"DEX(%d)\", dex);\n+\telse\n+\t  output_addr_const (file, x);\n+      }\n+      break;\n+\n     case 'C': case 'D': case 'c': case 'd':\n       /* Write out comparison name.  */\n       {\n@@ -4878,32 +5163,106 @@ function_arg (cum, mode, type, named)\n   int basereg;\n   int num_args;\n \n+  /* Set up defaults for FP operands passed in FP registers, and\n+     integral operands passed in integer registers.  */\n+  if (TARGET_FPREGS\n+      && (GET_MODE_CLASS (mode) == MODE_COMPLEX_FLOAT\n+\t  || GET_MODE_CLASS (mode) == MODE_FLOAT))\n+    basereg = 32 + 16;\n+  else\n+    basereg = 16;\n+\n+  /* ??? Irritatingly, the definition of CUMULATIVE_ARGS is different for\n+     the three platforms, so we can't avoid conditional compilation.  */\n #if TARGET_ABI_OPEN_VMS\n-  if (mode == VOIDmode)\n-    return alpha_arg_info_reg_val (cum);\n+    {\n+      if (mode == VOIDmode)\n+\treturn alpha_arg_info_reg_val (cum);\n \n-  num_args = cum.num_args;\n-  if (num_args >= 6 || MUST_PASS_IN_STACK (mode, type))\n-    return NULL_RTX;\n+      num_args = cum.num_args;\n+      if (num_args >= 6 || MUST_PASS_IN_STACK (mode, type))\n+\treturn NULL_RTX;\n+    }\n #else\n-  if (cum >= 6)\n-    return NULL_RTX;\n-  num_args = cum;\n+#if TARGET_ABI_UNICOSMK\n+    {\n+      int size;\n \n-  /* VOID is passed as a special flag for \"last argument\".  */\n-  if (type == void_type_node)\n-    basereg = 16;\n-  else if (MUST_PASS_IN_STACK (mode, type))\n-    return NULL_RTX;\n-  else if (FUNCTION_ARG_PASS_BY_REFERENCE (cum, mode, type, named))\n-    basereg = 16;\n+      /* If this is the last argument, generate the call info word (CIW).  */\n+      /* ??? We don't include the caller's line number in the CIW because\n+\t I don't know how to determine it if debug infos are turned off.  */\n+      if (mode == VOIDmode)\n+\t{\n+\t  int i;\n+\t  HOST_WIDE_INT lo;\n+\t  HOST_WIDE_INT hi;\n+\t  rtx ciw;\n+\n+\t  lo = 0;\n+\n+\t  for (i = 0; i < cum.num_reg_words && i < 5; i++)\n+\t    if (cum.reg_args_type[i])\n+\t      lo |= (1 << (7 - i));\n+\n+\t  if (cum.num_reg_words == 6 && cum.reg_args_type[5])\n+\t    lo |= 7;\n+\t  else\n+\t    lo |= cum.num_reg_words;\n+\n+#if HOST_BITS_PER_WIDE_INT == 32\n+\t  hi = (cum.num_args << 20) | cum.num_arg_words;\n+#else\n+\t  lo = lo | (cum.num_args << 52) | (cum.num_arg_words << 32);\n+\t  hi = 0;\n+#endif\n+\t  ciw = immed_double_const (lo, hi, DImode);\n+\n+\t  return gen_rtx_UNSPEC (DImode, gen_rtvec (1, ciw),\n+\t\t\t\t UNSPEC_UMK_LOAD_CIW);\n+\t}\n+\n+      size = ALPHA_ARG_SIZE (mode, type, named);\n+      num_args = cum.num_reg_words;\n+      if (MUST_PASS_IN_STACK (mode, type)\n+\t  || cum.num_reg_words + size > 6 || cum.force_stack)\n+\treturn NULL_RTX;\n+      else if (type && TYPE_MODE (type) == BLKmode)\n+\t{\n+\t  rtx reg1, reg2;\n+\n+\t  reg1 = gen_rtx_REG (DImode, num_args + 16);\n+\t  reg1 = gen_rtx_EXPR_LIST (DImode, reg1, const0_rtx);\n+\n+\t  /* The argument fits in two registers. Note that we still need to\n+\t     reserve a register for empty structures.  */\n+\t  if (size == 0)\n+\t    return NULL_RTX;\n+\t  else if (size == 1)\n+\t    return gen_rtx_PARALLEL (mode, gen_rtvec (1, reg1));\n+\t  else\n+\t    {\n+\t      reg2 = gen_rtx_REG (DImode, num_args + 17);\n+\t      reg2 = gen_rtx_EXPR_LIST (DImode, reg2, GEN_INT (8));\n+\t      return gen_rtx_PARALLEL (mode, gen_rtvec (2, reg1, reg2));\n+\t    }\n+\t}\n+    }\n+#else\n+    {\n+      if (cum >= 6)\n+\treturn NULL_RTX;\n+      num_args = cum;\n+\n+      /* VOID is passed as a special flag for \"last argument\".  */\n+      if (type == void_type_node)\n+\tbasereg = 16;\n+      else if (MUST_PASS_IN_STACK (mode, type))\n+\treturn NULL_RTX;\n+      else if (FUNCTION_ARG_PASS_BY_REFERENCE (cum, mode, type, named))\n+\tbasereg = 16;\n+    }\n+#endif /* TARGET_ABI_UNICOSMK */\n #endif /* TARGET_ABI_OPEN_VMS */\n-  else if (TARGET_FPREGS\n-\t   && (GET_MODE_CLASS (mode) == MODE_COMPLEX_FLOAT\n-\t       || GET_MODE_CLASS (mode) == MODE_FLOAT))\n-    basereg = 32 + 16;\n-  else\n-    basereg = 16;\n \n   return gen_rtx_REG (mode, num_args + basereg);\n }\n@@ -4913,7 +5272,7 @@ alpha_build_va_list ()\n {\n   tree base, ofs, record, type_decl;\n \n-  if (TARGET_ABI_OPEN_VMS)\n+  if (TARGET_ABI_OPEN_VMS || TARGET_ABI_UNICOSMK)\n     return ptr_type_node;\n \n   record = make_lang_type (RECORD_TYPE);\n@@ -4950,7 +5309,7 @@ alpha_va_start (stdarg_p, valist, nextarg)\n   if (TREE_CODE (TREE_TYPE (valist)) == ERROR_MARK)\n     return;\n \n-  if (TARGET_ABI_OPEN_VMS)\n+  if (TARGET_ABI_OPEN_VMS || TARGET_ABI_UNICOSMK)\n     std_expand_builtin_va_start (stdarg_p, valist, nextarg);\n \n   /* For Unix, SETUP_INCOMING_VARARGS moves the starting address base\n@@ -4998,7 +5357,7 @@ alpha_va_arg (valist, type)\n   tree wide_type, wide_ofs;\n   int indirect = 0;\n \n-  if (TARGET_ABI_OPEN_VMS)\n+  if (TARGET_ABI_OPEN_VMS || TARGET_ABI_UNICOSMK)\n     return std_expand_builtin_va_arg (valist, type);\n \n   tsize = ((TREE_INT_CST_LOW (TYPE_SIZE (type)) / BITS_PER_UNIT + 7) / 8) * 8;\n@@ -5067,7 +5426,7 @@ alpha_va_arg (valist, type)\n    descriptior to generate. */\n \n /* Nonzero if we need a stack procedure.  */\n-static int vms_is_stack_procedure;\n+static int alpha_is_stack_procedure;\n \n /* Register number (either FP or SP) that is used to unwind the frame.  */\n static int vms_unwind_regno;\n@@ -5095,13 +5454,14 @@ alpha_sa_mask (imaskP, fmaskP)\n   if (!current_function_is_thunk)\n #endif\n     {\n-      if (TARGET_ABI_OPEN_VMS && vms_is_stack_procedure)\n+      if (TARGET_ABI_OPEN_VMS && alpha_is_stack_procedure)\n \timask |= (1L << HARD_FRAME_POINTER_REGNUM);\n \n       /* One for every register we have to save.  */\n       for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n \tif (! fixed_regs[i] && ! call_used_regs[i]\n-\t    && regs_ever_live[i] && i != REG_RA)\n+\t    && regs_ever_live[i] && i != REG_RA\n+\t    && (!TARGET_ABI_UNICOSMK || i != HARD_FRAME_POINTER_REGNUM))\n \t  {\n \t    if (i < 32)\n \t      imask |= (1L << i);\n@@ -5120,9 +5480,15 @@ alpha_sa_mask (imaskP, fmaskP)\n \t      imask |= 1L << regno;\n \t    }\n \t}\n-\n-      if (imask || fmask || alpha_ra_ever_killed ())\n-\timask |= (1L << REG_RA);\n+     \n+      if (!TARGET_ABI_UNICOSMK)\n+\t{\n+\t  /* If any register spilled, then spill the return address also.  */\n+\t  /* ??? This is required by the Digital stack unwind specification\n+\t     and isn't needed if we're doing Dwarf2 unwinding.  */\n+\t  if (imask || fmask || alpha_ra_ever_killed ())\n+\t    imask |= (1L << REG_RA);\n+\t}\n     }\n \n   *imaskP = imask;\n@@ -5141,27 +5507,63 @@ alpha_sa_size ()\n   else\n #endif\n     {\n-      /* One for every register we have to save.  */\n-      for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-\tif (! fixed_regs[i] && ! call_used_regs[i]\n-\t    && regs_ever_live[i] && i != REG_RA)\n-\t  sa_size++;\n+      if (TARGET_ABI_UNICOSMK)\n+\t{\n+\t  for (i = 9; i < 15 && sa_size == 0; i++)\n+\t    if (! fixed_regs[i] && ! call_used_regs[i]\n+\t\t&& regs_ever_live[i])\n+\t      sa_size = 14;\n+\t  for (i = 32 + 2; i < 32 + 10 && sa_size == 0; i++)\n+\t    if (! fixed_regs[i] && ! call_used_regs[i]\n+\t\t&& regs_ever_live[i])\n+\t      sa_size = 14;\n+\t}\n+      else\n+\t{\n+\t  /* One for every register we have to save.  */\n+\t  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n+\t    if (! fixed_regs[i] && ! call_used_regs[i]\n+\t        && regs_ever_live[i] && i != REG_RA)\n+\t      sa_size++;\n+\t}\n     }\n \n-  if (TARGET_ABI_OPEN_VMS)\n+  if (TARGET_ABI_UNICOSMK)\n+    {\n+      /* We might not need to generate a frame if we don't make any calls\n+\t (including calls to __T3E_MISMATCH if this is a vararg function),\n+\t don't have any local variables which require stack slots, don't\n+\t use alloca and have not determined that we need a frame for other\n+\t reasons.  */\n+\n+      alpha_is_stack_procedure = sa_size != 0\n+\t\t\t\t|| alpha_ra_ever_killed ()\n+\t\t\t\t|| get_frame_size() != 0\n+\t\t\t\t|| current_function_outgoing_args_size\n+\t\t\t\t|| current_function_varargs\n+\t\t\t\t|| current_function_stdarg\n+\t\t\t\t|| current_function_calls_alloca\n+\t\t\t\t|| frame_pointer_needed;\n+\n+      /* Always reserve space for saving callee-saved registers if we\n+\t need a frame as required by the calling convention.  */\n+      if (alpha_is_stack_procedure)\n+        sa_size = 14;\n+    }\n+  else if (TARGET_ABI_OPEN_VMS)\n     {\n       /* Start by assuming we can use a register procedure if we don't\n \t make any calls (REG_RA not used) or need to save any\n \t registers and a stack procedure if we do.  */\n-      vms_is_stack_procedure = sa_size != 0 || alpha_ra_ever_killed ();\n+      alpha_is_stack_procedure = sa_size != 0 || alpha_ra_ever_killed ();\n \n       /* Decide whether to refer to objects off our PV via FP or PV.\n \t If we need FP for something else or if we receive a nonlocal\n \t goto (which expects PV to contain the value), we must use PV.\n \t Otherwise, start by assuming we can use FP.  */\n       vms_base_regno = (frame_pointer_needed\n \t\t\t|| current_function_has_nonlocal_label\n-\t\t\t|| vms_is_stack_procedure\n+\t\t\t|| alpha_is_stack_procedure\n \t\t\t|| current_function_outgoing_args_size\n \t\t\t? REG_PV : HARD_FRAME_POINTER_REGNUM);\n \n@@ -5175,21 +5577,21 @@ alpha_sa_size ()\n \t    vms_save_fp_regno = i;\n \n       if (vms_save_fp_regno == -1)\n-\tvms_base_regno = REG_PV, vms_is_stack_procedure = 1;\n+\tvms_base_regno = REG_PV, alpha_is_stack_procedure = 1;\n \n       /* Stack unwinding should be done via FP unless we use it for PV.  */\n       vms_unwind_regno = (vms_base_regno == REG_PV\n \t\t\t  ? HARD_FRAME_POINTER_REGNUM : STACK_POINTER_REGNUM);\n \n       /* If this is a stack procedure, allow space for saving FP and RA.  */\n-      if (vms_is_stack_procedure)\n+      if (alpha_is_stack_procedure)\n \tsa_size += 2;\n     }\n   else\n     {\n       /* If some registers were saved but not RA, RA must also be saved,\n \t so leave space for it.  */\n-      if (sa_size != 0 || alpha_ra_ever_killed ())\n+      if (!TARGET_ABI_UNICOSMK && (sa_size != 0 || alpha_ra_ever_killed ()))\n \tsa_size++;\n \n       /* Our size must be even (multiple of 16 bytes).  */\n@@ -5204,7 +5606,7 @@ int\n alpha_pv_save_size ()\n {\n   alpha_sa_size ();\n-  return vms_is_stack_procedure ? 8 : 0;\n+  return alpha_is_stack_procedure ? 8 : 0;\n }\n \n int\n@@ -5243,8 +5645,8 @@ alpha_does_function_need_gp ()\n {\n   rtx insn;\n \n-  /* We never need a GP for Windows/NT or VMS.  */\n-  if (TARGET_ABI_WINDOWS_NT || TARGET_ABI_OPEN_VMS)\n+  /* The GP being variable is an OSF abi thing.  */\n+  if (! TARGET_ABI_OSF)\n     return 0;\n \n   if (TARGET_PROFILING_NEEDS_GP && profile_flag)\n@@ -5358,9 +5760,15 @@ alpha_expand_prologue ()\n   frame_size = get_frame_size ();\n   if (TARGET_ABI_OPEN_VMS)\n     frame_size = ALPHA_ROUND (sa_size \n-\t\t\t      + (vms_is_stack_procedure ? 8 : 0)\n+\t\t\t      + (alpha_is_stack_procedure ? 8 : 0)\n \t\t\t      + frame_size\n \t\t\t      + current_function_pretend_args_size);\n+  else if (TARGET_ABI_UNICOSMK)\n+    /* We have to allocate space for the DSIB if we generate a frame.  */\n+    frame_size = ALPHA_ROUND (sa_size\n+\t\t\t      + (alpha_is_stack_procedure ? 48 : 0))\n+\t\t + ALPHA_ROUND (frame_size\n+\t\t\t\t+ current_function_outgoing_args_size);\n   else\n     frame_size = (ALPHA_ROUND (current_function_outgoing_args_size)\n \t\t  + sa_size\n@@ -5388,7 +5796,10 @@ alpha_expand_prologue ()\n      don't represent the call as a call.  */\n   if (TARGET_PROFILING_NEEDS_GP && profile_flag)\n     emit_insn (gen_prologue_mcount ());\n-      \n+\n+  if (TARGET_ABI_UNICOSMK)\n+    unicosmk_gen_dsib (&imask);\n+\n   /* Adjust the stack by the frame size.  If the frame size is > 4096\n      bytes, we need to be sure we probe somewhere in the first and last\n      4096 bytes (we can probably get away without the latter test) and\n@@ -5405,7 +5816,9 @@ alpha_expand_prologue ()\n \t  int probed = 4096;\n \n \t  do\n-\t    emit_insn (gen_probe_stack (GEN_INT (-probed)));\n+\t    emit_insn (gen_probe_stack (GEN_INT (TARGET_ABI_UNICOSMK\n+\t\t\t\t\t\t ? -probed + 64\n+\t\t\t\t\t\t : -probed)));\n \t  while ((probed += 8192) < frame_size);\n \n \t  /* We only have to do this probe if we aren't saving registers.  */\n@@ -5415,7 +5828,9 @@ alpha_expand_prologue ()\n \n       if (frame_size != 0)\n \tFRP (emit_insn (gen_adddi3 (stack_pointer_rtx, stack_pointer_rtx,\n-\t\t\t\t    GEN_INT (-frame_size))));\n+\t\t\t\t    GEN_INT (TARGET_ABI_UNICOSMK\n+\t\t\t\t\t     ? -frame_size + 64\n+\t\t\t\t\t     : -frame_size))));\n     }\n   else\n     {\n@@ -5432,7 +5847,8 @@ alpha_expand_prologue ()\n       rtx seq;\n \n       emit_move_insn (count, GEN_INT (blocks));\n-      emit_insn (gen_adddi3 (ptr, stack_pointer_rtx, GEN_INT (4096)));\n+      emit_insn (gen_adddi3 (ptr, stack_pointer_rtx,\n+\t\t\t     GEN_INT (TARGET_ABI_UNICOSMK ? 4096 - 64 : 4096)));\n \n       /* Because of the difficulty in emitting a new basic block this\n \t late in the compilation, generate the loop as a single insn.  */\n@@ -5479,66 +5895,98 @@ alpha_expand_prologue ()\n         = gen_rtx_EXPR_LIST (REG_FRAME_RELATED_EXPR,\n \t\t\t     gen_rtx_SET (VOIDmode, stack_pointer_rtx,\n \t\t\t       gen_rtx_PLUS (Pmode, stack_pointer_rtx,\n-\t\t\t\t\t     GEN_INT (-frame_size))),\n+\t\t\t\t\t     GEN_INT (TARGET_ABI_UNICOSMK\n+\t\t\t\t\t\t      ? -frame_size + 64\n+\t\t\t\t\t\t      : -frame_size))),\n \t\t\t     REG_NOTES (seq));\n     }\n \n-  /* Cope with very large offsets to the register save area.  */\n-  sa_reg = stack_pointer_rtx;\n-  if (reg_offset + sa_size > 0x8000)\n+  if (!TARGET_ABI_UNICOSMK)\n     {\n-      int low = ((reg_offset & 0xffff) ^ 0x8000) - 0x8000;\n-      HOST_WIDE_INT bias;\n+      /* Cope with very large offsets to the register save area.  */\n+      sa_reg = stack_pointer_rtx;\n+      if (reg_offset + sa_size > 0x8000)\n+\t{\n+\t  int low = ((reg_offset & 0xffff) ^ 0x8000) - 0x8000;\n+\t  HOST_WIDE_INT bias;\n \n-      if (low + sa_size <= 0x8000)\n-\tbias = reg_offset - low, reg_offset = low;\n-      else \n-\tbias = reg_offset, reg_offset = 0;\n+\t  if (low + sa_size <= 0x8000)\n+\t    bias = reg_offset - low, reg_offset = low;\n+\t  else \n+\t    bias = reg_offset, reg_offset = 0;\n \n-      sa_reg = gen_rtx_REG (DImode, 24);\n-      FRP (emit_insn (gen_adddi3 (sa_reg, stack_pointer_rtx, GEN_INT (bias))));\n-    }\n+\t  sa_reg = gen_rtx_REG (DImode, 24);\n+\t  FRP (emit_insn (gen_adddi3 (sa_reg, stack_pointer_rtx,\n+\t\t\t\t      GEN_INT (bias))));\n+\t}\n     \n-  /* Save regs in stack order.  Beginning with VMS PV.  */\n-  if (TARGET_ABI_OPEN_VMS && vms_is_stack_procedure)\n-    {\n-      mem = gen_rtx_MEM (DImode, stack_pointer_rtx);\n-      set_mem_alias_set (mem, alpha_sr_alias_set);\n-      FRP (emit_move_insn (mem, gen_rtx_REG (DImode, REG_PV)));\n-    }\n+      /* Save regs in stack order.  Beginning with VMS PV.  */\n+      if (TARGET_ABI_OPEN_VMS && alpha_is_stack_procedure)\n+\t{\n+\t  mem = gen_rtx_MEM (DImode, stack_pointer_rtx);\n+\t  set_mem_alias_set (mem, alpha_sr_alias_set);\n+\t  FRP (emit_move_insn (mem, gen_rtx_REG (DImode, REG_PV)));\n+\t}\n \n-  /* Save register RA next.  */\n-  if (imask & (1L << REG_RA))\n-    {\n-      mem = gen_rtx_MEM (DImode, plus_constant (sa_reg, reg_offset));\n-      set_mem_alias_set (mem, alpha_sr_alias_set);\n-      FRP (emit_move_insn (mem, gen_rtx_REG (DImode, REG_RA)));\n-      imask &= ~(1L << REG_RA);\n-      reg_offset += 8;\n-    }\n+      /* Save register RA next.  */\n+      if (imask & (1L << REG_RA))\n+\t{\n+\t  mem = gen_rtx_MEM (DImode, plus_constant (sa_reg, reg_offset));\n+\t  set_mem_alias_set (mem, alpha_sr_alias_set);\n+\t  FRP (emit_move_insn (mem, gen_rtx_REG (DImode, REG_RA)));\n+\t  imask &= ~(1L << REG_RA);\n+\t  reg_offset += 8;\n+\t}\n \n-  /* Now save any other registers required to be saved.  */\n-  for (i = 0; i < 32; i++)\n-    if (imask & (1L << i))\n-      {\n-\tmem = gen_rtx_MEM (DImode, plus_constant (sa_reg, reg_offset));\n-\tset_mem_alias_set (mem, alpha_sr_alias_set);\n-\tFRP (emit_move_insn (mem, gen_rtx_REG (DImode, i)));\n-\treg_offset += 8;\n-      }\n+      /* Now save any other registers required to be saved.  */\n+      for (i = 0; i < 32; i++)\n+\tif (imask & (1L << i))\n+\t  {\n+\t    mem = gen_rtx_MEM (DImode, plus_constant (sa_reg, reg_offset));\n+\t    set_mem_alias_set (mem, alpha_sr_alias_set);\n+\t    FRP (emit_move_insn (mem, gen_rtx_REG (DImode, i)));\n+\t    reg_offset += 8;\n+\t  }\n \n-  for (i = 0; i < 32; i++)\n-    if (fmask & (1L << i))\n-      {\n-\tmem = gen_rtx_MEM (DFmode, plus_constant (sa_reg, reg_offset));\n-\tset_mem_alias_set (mem, alpha_sr_alias_set);\n-\tFRP (emit_move_insn (mem, gen_rtx_REG (DFmode, i+32)));\n-\treg_offset += 8;\n-      }\n+      for (i = 0; i < 32; i++)\n+\tif (fmask & (1L << i))\n+\t  {\n+\t    mem = gen_rtx_MEM (DFmode, plus_constant (sa_reg, reg_offset));\n+\t    set_mem_alias_set (mem, alpha_sr_alias_set);\n+\t    FRP (emit_move_insn (mem, gen_rtx_REG (DFmode, i+32)));\n+\t    reg_offset += 8;\n+\t  }\n+    }\n+  else if (TARGET_ABI_UNICOSMK && alpha_is_stack_procedure)\n+    {\n+      /* The standard frame on the T3E includes space for saving registers.\n+\t We just have to use it. We don't have to save the return address and\n+\t the old frame pointer here - they are saved in the DSIB.  */\n+\n+      reg_offset = -56;\n+      for (i = 9; i < 15; i++)\n+\tif (imask & (1L << i))\n+\t  {\n+\t    mem = gen_rtx_MEM (DImode, plus_constant(hard_frame_pointer_rtx,\n+\t\t\t\t\t\t     reg_offset));\n+\t    set_mem_alias_set (mem, alpha_sr_alias_set);\n+\t    FRP (emit_move_insn (mem, gen_rtx_REG (DImode, i)));\n+\t    reg_offset -= 8;\n+\t  }\n+      for (i = 2; i < 10; i++)\n+\tif (fmask & (1L << i))\n+\t  {\n+\t    mem = gen_rtx_MEM (DFmode, plus_constant (hard_frame_pointer_rtx,\n+\t\t\t\t\t\t      reg_offset));\n+\t    set_mem_alias_set (mem, alpha_sr_alias_set);\n+\t    FRP (emit_move_insn (mem, gen_rtx_REG (DFmode, i+32)));\n+\t    reg_offset -= 8;\n+\t  }\n+    }\n \n   if (TARGET_ABI_OPEN_VMS)\n     {\n-      if (!vms_is_stack_procedure)\n+      if (!alpha_is_stack_procedure)\n \t/* Register frame procedures save the fp.  */\n \t/* ??? Ought to have a dwarf2 save for this.  */\n \temit_move_insn (gen_rtx_REG (DImode, vms_save_fp_regno),\n@@ -5559,7 +6007,7 @@ alpha_expand_prologue ()\n \t\t\t     - (ALPHA_ROUND\n \t\t\t\t(current_function_outgoing_args_size)))));\n     }\n-  else\n+  else if (!TARGET_ABI_UNICOSMK)\n     {\n       /* If we need a frame pointer, set it from the stack pointer.  */\n       if (frame_pointer_needed)\n@@ -5607,15 +6055,28 @@ alpha_start_function (file, fnname, decl)\n   char *entry_label = (char *) alloca (strlen (fnname) + 6);\n   int i;\n \n+  /* Don't emit an extern directive for functions defined in the same file.  */\n+  if (TARGET_ABI_UNICOSMK)\n+    {\n+      tree name_tree;\n+      name_tree = get_identifier (fnname);\n+      TREE_ASM_WRITTEN (name_tree) = 1;\n+    }\n+\n   alpha_fnname = fnname;\n   sa_size = alpha_sa_size ();\n \n   frame_size = get_frame_size ();\n   if (TARGET_ABI_OPEN_VMS)\n     frame_size = ALPHA_ROUND (sa_size \n-\t\t\t      + (vms_is_stack_procedure ? 8 : 0)\n+\t\t\t      + (alpha_is_stack_procedure ? 8 : 0)\n \t\t\t      + frame_size\n \t\t\t      + current_function_pretend_args_size);\n+  else if (TARGET_ABI_UNICOSMK)\n+    frame_size = ALPHA_ROUND (sa_size\n+\t\t\t      + (alpha_is_stack_procedure ? 48 : 0))\n+\t\t + ALPHA_ROUND (frame_size\n+\t\t\t      + current_function_outgoing_args_size);\n   else\n     frame_size = (ALPHA_ROUND (current_function_outgoing_args_size)\n \t\t  + sa_size\n@@ -5639,15 +6100,20 @@ alpha_start_function (file, fnname, decl)\n \n   if (write_symbols == SDB_DEBUG)\n     {\n+#ifdef ASM_OUTPUT_SOURCE_FILENAME\n       ASM_OUTPUT_SOURCE_FILENAME (file,\n \t\t\t\t  DECL_SOURCE_FILE (current_function_decl));\n+#endif\n+#ifdef ASM_OUTPUT_SOURCE_LINE\n       if (debug_info_level != DINFO_LEVEL_TERSE)\n         ASM_OUTPUT_SOURCE_LINE (file,\n \t\t\t\tDECL_SOURCE_LINE (current_function_decl));\n+#endif\n     }\n \n   /* Issue function start and label.  */\n-  if (TARGET_ABI_OPEN_VMS || !flag_inhibit_size_directive)\n+  if (TARGET_ABI_OPEN_VMS\n+      || (!TARGET_ABI_UNICOSMK && !flag_inhibit_size_directive))\n     {\n       fputs (\"\\t.ent \", file);\n       assemble_name (file, fnname);\n@@ -5666,13 +6132,19 @@ alpha_start_function (file, fnname, decl)\n   strcpy (entry_label, fnname);\n   if (TARGET_ABI_OPEN_VMS)\n     strcat (entry_label, \"..en\");\n+\n+  /* For public functions, the label must be globalized by appending an\n+     additional colon.  */\n+  if (TARGET_ABI_UNICOSMK && TREE_PUBLIC (decl))\n+    strcat (entry_label, \":\");\n+\n   ASM_OUTPUT_LABEL (file, entry_label);\n   inside_function = TRUE;\n \n   if (TARGET_ABI_OPEN_VMS)\n     fprintf (file, \"\\t.base $%d\\n\", vms_base_regno);\n \n-  if (!TARGET_ABI_OPEN_VMS && TARGET_IEEE_CONFORMANT\n+  if (!TARGET_ABI_OPEN_VMS && !TARGET_ABI_UNICOSMK && TARGET_IEEE_CONFORMANT\n       && !flag_inhibit_size_directive)\n     {\n       /* Set flags in procedure descriptor to request IEEE-conformant\n@@ -5688,7 +6160,9 @@ alpha_start_function (file, fnname, decl)\n   /* Describe our frame.  If the frame size is larger than an integer,\n      print it as zero to avoid an assembler error.  We won't be\n      properly describing such a frame, but that's the best we can do.  */\n-  if (TARGET_ABI_OPEN_VMS)\n+  if (TARGET_ABI_UNICOSMK)\n+    ;\n+  else if (TARGET_ABI_OPEN_VMS)\n     {\n       fprintf (file, \"\\t.frame $%d,\", vms_unwind_regno);\n       fprintf (file, HOST_WIDE_INT_PRINT_DEC,\n@@ -5708,15 +6182,17 @@ alpha_start_function (file, fnname, decl)\n     }\n \n   /* Describe which registers were spilled.  */\n-  if (TARGET_ABI_OPEN_VMS)\n+  if (TARGET_ABI_UNICOSMK)\n+    ;\n+  else if (TARGET_ABI_OPEN_VMS)\n     {\n       if (imask)\n-        /* ??? Does VMS care if mask contains ra?  The old code did'nt\n+        /* ??? Does VMS care if mask contains ra?  The old code didn't\n            set it, so I don't here.  */\n \tfprintf (file, \"\\t.mask 0x%lx,0\\n\", imask & ~(1L << REG_RA));\n       if (fmask)\n \tfprintf (file, \"\\t.fmask 0x%lx,0\\n\", fmask);\n-      if (!vms_is_stack_procedure)\n+      if (!alpha_is_stack_procedure)\n \tfprintf (file, \"\\t.fp_save $%d\\n\", vms_save_fp_regno);\n     }\n   else if (!flag_inhibit_size_directive)\n@@ -5760,7 +6236,7 @@ alpha_start_function (file, fnname, decl)\n   ASM_OUTPUT_LABEL (file, fnname);\n   fprintf (file, \"\\t.pdesc \");\n   assemble_name (file, fnname);\n-  fprintf (file, \"..en,%s\\n\", vms_is_stack_procedure ? \"stack\" : \"reg\");\n+  fprintf (file, \"..en,%s\\n\", alpha_is_stack_procedure ? \"stack\" : \"reg\");\n   alpha_need_linkage (fnname, 1);\n   text_section ();\n #endif\n@@ -5772,7 +6248,9 @@ static void\n alpha_output_function_end_prologue (file)\n      FILE *file;\n {\n-  if (TARGET_ABI_OPEN_VMS)\n+  if (TARGET_ABI_UNICOSMK)\n+    ;\n+  else if (TARGET_ABI_OPEN_VMS)\n     fputs (\"\\t.prologue\\n\", file);\n   else if (TARGET_ABI_WINDOWS_NT)\n     fputs (\"\\t.prologue 0\\n\", file);\n@@ -5811,9 +6289,14 @@ alpha_expand_epilogue ()\n   frame_size = get_frame_size ();\n   if (TARGET_ABI_OPEN_VMS)\n     frame_size = ALPHA_ROUND (sa_size \n-\t\t\t      + (vms_is_stack_procedure ? 8 : 0)\n+\t\t\t      + (alpha_is_stack_procedure ? 8 : 0)\n \t\t\t      + frame_size\n \t\t\t      + current_function_pretend_args_size);\n+  else if (TARGET_ABI_UNICOSMK)\n+    frame_size = ALPHA_ROUND (sa_size\n+\t\t\t      + (alpha_is_stack_procedure ? 48 : 0))\n+\t\t + ALPHA_ROUND (frame_size\n+\t\t\t      + current_function_outgoing_args_size);\n   else\n     frame_size = (ALPHA_ROUND (current_function_outgoing_args_size)\n \t\t  + sa_size\n@@ -5827,7 +6310,7 @@ alpha_expand_epilogue ()\n \n   alpha_sa_mask (&imask, &fmask);\n \n-  fp_is_frame_pointer = ((TARGET_ABI_OPEN_VMS && vms_is_stack_procedure)\n+  fp_is_frame_pointer = ((TARGET_ABI_OPEN_VMS && alpha_is_stack_procedure)\n \t\t\t || (!TARGET_ABI_OPEN_VMS && frame_pointer_needed));\n   fp_offset = 0;\n   sa_reg = stack_pointer_rtx;\n@@ -5837,7 +6320,7 @@ alpha_expand_epilogue ()\n   else\n     eh_ofs = NULL_RTX;\n \n-  if (sa_size)\n+  if (!TARGET_ABI_UNICOSMK && sa_size)\n     {\n       /* If we have a frame pointer, restore SP from it.  */\n       if ((TARGET_ABI_OPEN_VMS\n@@ -5895,6 +6378,38 @@ alpha_expand_epilogue ()\n \t    reg_offset += 8;\n \t  }\n     }\n+  else if (TARGET_ABI_UNICOSMK && alpha_is_stack_procedure)\n+    {\n+      /* Restore callee-saved general-purpose registers.  */\n+\n+      reg_offset = -56;\n+\n+      for (i = 9; i < 15; i++)\n+\tif (imask & (1L << i))\n+\t  {\n+\t    mem = gen_rtx_MEM (DImode, plus_constant(hard_frame_pointer_rtx,\n+\t\t\t\t\t\t     reg_offset));\n+\t    set_mem_alias_set (mem, alpha_sr_alias_set);\n+\t    FRP (emit_move_insn (gen_rtx_REG (DImode, i), mem));\n+\t    reg_offset -= 8;\n+\t  }\n+\n+      for (i = 2; i < 10; i++)\n+\tif (fmask & (1L << i))\n+\t  {\n+\t    mem = gen_rtx_MEM (DFmode, plus_constant(hard_frame_pointer_rtx,\n+\t\t\t\t\t\t     reg_offset));\n+\t    set_mem_alias_set (mem, alpha_sr_alias_set);\n+\t    FRP (emit_move_insn (gen_rtx_REG (DFmode, i+32), mem));\n+\t    reg_offset -= 8;\n+\t  }\n+\n+      /* Restore the return address from the DSIB.  */\n+\n+      mem = gen_rtx_MEM (DImode, plus_constant(hard_frame_pointer_rtx, -8));\n+      set_mem_alias_set (mem, alpha_sr_alias_set);\n+      FRP (emit_move_insn (gen_rtx_REG (DImode, REG_RA), mem));\n+    }\n \n   if (frame_size || eh_ofs)\n     {\n@@ -5910,8 +6425,15 @@ alpha_expand_epilogue ()\n       /* If the stack size is large, begin computation into a temporary\n \t register so as not to interfere with a potential fp restore,\n \t which must be consecutive with an SP restore.  */\n-      if (frame_size < 32768)\n+      if (frame_size < 32768\n+\t  && ! (TARGET_ABI_UNICOSMK && current_function_calls_alloca))\n \tsp_adj2 = GEN_INT (frame_size);\n+      else if (TARGET_ABI_UNICOSMK)\n+\t{\n+\t  sp_adj1 = gen_rtx_REG (DImode, 23);\n+\t  FRP (emit_move_insn (sp_adj1, hard_frame_pointer_rtx));\n+\t  sp_adj2 = const0_rtx;\n+\t}\n       else if (frame_size < 0x40007fffL)\n \t{\n \t  int low = ((frame_size & 0xffff) ^ 0x8000) - 0x8000;\n@@ -5944,7 +6466,15 @@ alpha_expand_epilogue ()\n       /* From now on, things must be in order.  So emit blockages.  */\n \n       /* Restore the frame pointer.  */\n-      if (fp_is_frame_pointer)\n+      if (TARGET_ABI_UNICOSMK)\n+\t{\n+\t  emit_insn (gen_blockage ());\n+\t  mem = gen_rtx_MEM (DImode,\n+\t\t\t     plus_constant (hard_frame_pointer_rtx, -16));\n+\t  set_mem_alias_set (mem, alpha_sr_alias_set);\n+\t  FRP (emit_move_insn (hard_frame_pointer_rtx, mem));\n+\t}\n+      else if (fp_is_frame_pointer)\n \t{\n \t  emit_insn (gen_blockage ());\n \t  mem = gen_rtx_MEM (DImode, plus_constant (sa_reg, fp_offset));\n@@ -5960,17 +6490,29 @@ alpha_expand_epilogue ()\n \n       /* Restore the stack pointer.  */\n       emit_insn (gen_blockage ());\n-      FRP (emit_move_insn (stack_pointer_rtx,\n-\t\t           gen_rtx_PLUS (DImode, sp_adj1, sp_adj2)));\n+      if (sp_adj2 == const0_rtx)\n+\tFRP (emit_move_insn (stack_pointer_rtx, sp_adj1));\n+      else\n+\tFRP (emit_move_insn (stack_pointer_rtx,\n+\t\t\t     gen_rtx_PLUS (DImode, sp_adj1, sp_adj2)));\n     }\n   else \n     {\n-      if (TARGET_ABI_OPEN_VMS && !vms_is_stack_procedure)\n+      if (TARGET_ABI_OPEN_VMS && !alpha_is_stack_procedure)\n         {\n           emit_insn (gen_blockage ());\n           FRP (emit_move_insn (hard_frame_pointer_rtx,\n \t\t\t       gen_rtx_REG (DImode, vms_save_fp_regno)));\n         }\n+      else if (TARGET_ABI_UNICOSMK && !alpha_is_stack_procedure)\n+\t{\n+\t  /* Decrement the frame pointer if the function does not have a\n+\t     frame.  */\n+\n+\t  emit_insn (gen_blockage ());\n+\t  FRP (emit_insn (gen_adddi3 (hard_frame_pointer_rtx,\n+\t\t\t\t      hard_frame_pointer_rtx, GEN_INT (-1))));\n+        }\n     }\n }\n \n@@ -5983,7 +6525,7 @@ alpha_end_function (file, fnname, decl)\n      tree decl ATTRIBUTE_UNUSED;\n {\n   /* End the function.  */\n-  if (!flag_inhibit_size_directive)\n+  if (!TARGET_ABI_UNICOSMK && !flag_inhibit_size_directive)\n     {\n       fputs (\"\\t.end \", file);\n       assemble_name (file, fnname);\n@@ -6000,6 +6542,13 @@ alpha_end_function (file, fnname, decl)\n   if (!DECL_WEAK (current_function_decl)\n       && (!flag_pic || !TREE_PUBLIC (current_function_decl)))\n     SYMBOL_REF_FLAG (XEXP (DECL_RTL (current_function_decl), 0)) = 1;\n+\n+  /* Output jump tables and the static subroutine information block.  */\n+  if (TARGET_ABI_UNICOSMK)\n+    {\n+      unicosmk_output_ssib (file, fnname);\n+      unicosmk_output_deferred_case_vectors (file);\n+    }\n }\n \f\n /* Debugging support.  */\n@@ -7032,7 +7581,7 @@ check_float_value (mode, d, overflow)\n \n   return 0;\n }\n-\n+\f\n #if TARGET_ABI_OPEN_VMS\n \n /* Return the VMS argument type corresponding to MODE.  */\n@@ -7296,3 +7845,801 @@ alpha_need_linkage (name, is_local)\n }\n \n #endif /* TARGET_ABI_OPEN_VMS */\n+\f\n+#if TARGET_ABI_UNICOSMK\n+\n+static void unicosmk_output_module_name PARAMS ((FILE *));\n+static void unicosmk_output_default_externs PARAMS ((FILE *));\n+static void unicosmk_output_dex PARAMS ((FILE *));\n+static void unicosmk_output_externs PARAMS ((FILE *));\n+static void unicosmk_output_addr_vec PARAMS ((FILE *, rtx));\n+static const char *unicosmk_ssib_name PARAMS ((void));\n+\n+\n+/* Define the offset between two registers, one to be eliminated, and the\n+   other its replacement, at the start of a routine.  */\n+\n+int\n+unicosmk_initial_elimination_offset (from, to)\n+      int from;\n+      int to;\n+{\n+  int fixed_size;\n+  \n+  fixed_size = alpha_sa_size();\n+  if (fixed_size != 0)\n+    fixed_size += 48;\n+\n+  if (from == FRAME_POINTER_REGNUM && to == HARD_FRAME_POINTER_REGNUM)\n+    return -fixed_size; \n+  else if (from == ARG_POINTER_REGNUM && to == HARD_FRAME_POINTER_REGNUM)\n+    return 0;\n+  else if (from == FRAME_POINTER_REGNUM && to == STACK_POINTER_REGNUM)\n+    return (ALPHA_ROUND (current_function_outgoing_args_size)\n+\t    + ALPHA_ROUND (get_frame_size()));\n+  else if (from == ARG_POINTER_REGNUM && to == STACK_POINTER_REGNUM)\n+    return (ALPHA_ROUND (fixed_size)\n+\t    + ALPHA_ROUND (get_frame_size() \n+\t\t\t   + current_function_outgoing_args_size));\n+  else\n+    abort ();\n+}\n+\n+/* Output the module name for .ident and .end directives. We have to strip\n+   directories and add make sure that the module name starts with a letter\n+   or '$'.  */\n+\n+static void\n+unicosmk_output_module_name (file)\n+      FILE *file;\n+{\n+  const char *name;\n+\n+  /* Strip directories.  */\n+\n+  name = strrchr (main_input_filename, '/');\n+  if (name)\n+    ++name;\n+  else\n+    name = main_input_filename;\n+\n+  /* CAM only accepts module names that start with a letter or '$'. We\n+     prefix the module name with a '$' if necessary.  */\n+\n+  if (!ISALPHA (*name))\n+    fprintf (file, \"$%s\", name);\n+  else\n+    fputs (name, file);\n+}\n+\n+/* Output text that to appear at the beginning of an assembler file.  */\n+\n+void \n+unicosmk_asm_file_start (file)\n+      FILE *file;\n+{\n+  int i;\n+\n+  fputs (\"\\t.ident\\t\", file);\n+  unicosmk_output_module_name (file);\n+  fputs (\"\\n\\n\", file);\n+\n+  /* The Unicos/Mk assembler uses different register names. Instead of trying\n+     to support them, we simply use micro definitions.  */\n+\n+  /* CAM has different register names: rN for the integer register N and fN\n+     for the floating-point register N. Instead of trying to use these in\n+     alpha.md, we define the symbols $N and $fN to refer to the appropriate\n+     register.  */\n+\n+  for (i = 0; i < 32; ++i)\n+    fprintf (file, \"$%d <- r%d\\n\", i, i);\n+\n+  for (i = 0; i < 32; ++i)\n+    fprintf (file, \"$f%d <- f%d\\n\", i, i);\n+\n+  putc ('\\n', file);\n+\n+  /* The .align directive fill unused space with zeroes which does not work\n+     in code sections. We define the macro 'gcc@code@align' which uses nops\n+     instead. Note that it assumes that code sections always have the\n+     biggest possible alignment since . refers to the current offset from\n+     the beginning of the section.  */\n+\n+  fputs (\"\\t.macro gcc@code@align n\\n\", file);\n+  fputs (\"gcc@n@bytes = 1 << n\\n\", file);\n+  fputs (\"gcc@here = . % gcc@n@bytes\\n\", file);\n+  fputs (\"\\t.if ne, gcc@here, 0\\n\", file);\n+  fputs (\"\\t.repeat (gcc@n@bytes - gcc@here) / 4\\n\", file);\n+  fputs (\"\\tbis r31,r31,r31\\n\", file);\n+  fputs (\"\\t.endr\\n\", file);\n+  fputs (\"\\t.endif\\n\", file);\n+  fputs (\"\\t.endm gcc@code@align\\n\\n\", file);\n+\n+  /* Output extern declarations which should always be visible.  */\n+  unicosmk_output_default_externs (file);\n+\n+  /* Open a dummy section. We always need to be inside a section for the\n+     section-switching code to work correctly.\n+     ??? This should be a module id or something like that. I still have to\n+     figure out what the rules for those are.  */\n+  fputs (\"\\n\\t.psect\\t$SG00000,data\\n\", file);\n+}\n+\n+/* Output text to appear at the end of an assembler file. This includes all\n+   pending extern declarations and DEX expressions.  */\n+\n+void\n+unicosmk_asm_file_end (file)\n+      FILE *file;\n+{\n+  fputs (\"\\t.endp\\n\\n\", file);\n+\n+  /* Output all pending externs.  */\n+\n+  unicosmk_output_externs (file);\n+\n+  /* Output dex definitions used for functions whose names conflict with \n+     register names.  */\n+\n+  unicosmk_output_dex (file);\n+\n+  fputs (\"\\t.end\\t\", file);\n+  unicosmk_output_module_name (file);\n+  putc ('\\n', file);\n+}\n+\n+/* Output the definition of a common variable.  */\n+\n+void\n+unicosmk_output_common (file, name, size, align)\n+      FILE *file;\n+      const char *name;\n+      int size;\n+      int align;\n+{\n+  tree name_tree;\n+  printf (\"T3E__: common %s\\n\", name);\n+\n+  common_section ();\n+  fputs(\"\\t.endp\\n\\n\\t.psect \", file);\n+  assemble_name(file, name);\n+  fprintf(file, \",%d,common\\n\", floor_log2 (align / BITS_PER_UNIT));\n+  fprintf(file, \"\\t.byte\\t0:%d\\n\", size);\n+\n+  /* Mark the symbol as defined in this module.  */\n+  name_tree = get_identifier (name);\n+  TREE_ASM_WRITTEN (name_tree) = 1;\n+}\n+\n+#define SECTION_PUBLIC SECTION_MACH_DEP\n+#define SECTION_MAIN (SECTION_PUBLIC << 1)\n+static int current_section_align;\n+\n+static unsigned int\n+unicosmk_section_type_flags (decl, name, reloc)\n+     tree decl;\n+     const char *name;\n+     int reloc ATTRIBUTE_UNUSED;\n+{\n+  unsigned int flags = default_section_type_flags (decl, name, reloc);\n+\n+  if (!decl)\n+    return flags;\n+\n+  if (TREE_CODE (decl) == FUNCTION_DECL)\n+    {\n+      current_section_align = floor_log2 (FUNCTION_BOUNDARY / BITS_PER_UNIT);\n+      if (align_functions_log > current_section_align)\n+\tcurrent_section_align = align_functions_log;\n+\n+      if (! strcmp (IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl)), \"main\"))\n+\tflags |= SECTION_MAIN;\n+    }\n+  else\n+    current_section_align = floor_log2 (DECL_ALIGN (decl) / BITS_PER_UNIT);\n+\n+  if (TREE_PUBLIC (decl))\n+    flags |= SECTION_PUBLIC;\n+\n+  return flags;\n+}\n+\n+/* Generate a section name for decl and associate it with the\n+   declaration.  */\n+\n+void\n+unicosmk_unique_section (decl, reloc)\n+      tree decl;\n+      int reloc ATTRIBUTE_UNUSED;\n+{\n+  const char *name;\n+  int len;\n+\n+  if (!decl) \n+    abort ();\n+\n+  name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl));\n+  STRIP_NAME_ENCODING (name, name);\n+  len = strlen (name);\n+\n+  if (TREE_CODE (decl) == FUNCTION_DECL)\n+    {\n+      char *string;\n+\n+      /* It is essential that we prefix the section name here because \n+\t otherwise the section names generated for constructors and \n+\t destructors confuse collect2.  */\n+\n+      string = alloca (len + 6);\n+      sprintf (string, \"code@%s\", name);\n+      DECL_SECTION_NAME (decl) = build_string (len + 5, string);\n+    }\n+  else if (TREE_PUBLIC (decl))\n+    DECL_SECTION_NAME (decl) = build_string (len, name);\n+  else\n+    {\n+      char *string;\n+\n+      string = alloca (len + 6);\n+      sprintf (string, \"data@%s\", name);\n+      DECL_SECTION_NAME (decl) = build_string (len + 5, string);\n+    }\n+}\n+\n+/* Switch to an arbitrary section NAME with attributes as specified\n+   by FLAGS.  ALIGN specifies any known alignment requirements for\n+   the section; 0 if the default should be used.  */\n+\n+static void\n+unicosmk_asm_named_section (name, flags)\n+     const char *name;\n+     unsigned int flags;\n+{\n+  const char *kind;\n+\n+  /* Close the previous section.  */\n+\n+  fputs (\"\\t.endp\\n\\n\", asm_out_file);\n+\n+  /* Find out what kind of section we are opening.  */\n+\n+  if (flags & SECTION_MAIN)\n+    fputs (\"\\t.start\\tmain\\n\", asm_out_file);\n+\n+  if (flags & SECTION_CODE)\n+    kind = \"code\";\n+  else if (flags & SECTION_PUBLIC)\n+    kind = \"common\";\n+  else\n+    kind = \"data\";\n+\n+  if (current_section_align != 0)\n+    fprintf (asm_out_file, \"\\t.psect\\t%s,%d,%s\\n\", name,\n+\t     current_section_align, kind);\n+  else\n+    fprintf (asm_out_file, \"\\t.psect\\t%s,%s\\n\", name, kind);\n+}\n+\n+static void\n+unicosmk_insert_attributes (decl, attr_ptr)\n+     tree decl;\n+     tree *attr_ptr ATTRIBUTE_UNUSED;\n+{\n+  if (DECL_P (decl)\n+      && (TREE_PUBLIC (decl) || TREE_CODE (decl) == FUNCTION_DECL))\n+    UNIQUE_SECTION (decl, 0);\n+}\n+\n+/* Output an alignment directive. We have to use the macro 'gcc@code@align'\n+   in code sections because .align fill unused space with zeroes.  */\n+      \n+void\n+unicosmk_output_align (file, align)\n+      FILE *file;\n+      int align;\n+{\n+  if (inside_function)\n+    fprintf (file, \"\\tgcc@code@align\\t%d\\n\", align);\n+  else\n+    fprintf (file, \"\\t.align\\t%d\\n\", align);\n+}\n+\n+/* Add a case vector to the current function's list of deferred case\n+   vectors. Case vectors have to be put into a separate section because CAM\n+   does not allow data definitions in code sections.  */\n+\n+void\n+unicosmk_defer_case_vector (lab, vec)\n+      rtx lab;\n+      rtx vec;\n+{\n+  struct machine_function *machine = cfun->machine;\n+  \n+  vec = gen_rtx_EXPR_LIST (VOIDmode, lab, vec);\n+  machine->addr_list = gen_rtx_EXPR_LIST (VOIDmode, vec,\n+\t\t\t\t\t  machine->addr_list); \n+}\n+\n+/* Output a case vector.  */\n+\n+static void\n+unicosmk_output_addr_vec (file, vec)\n+      FILE *file;\n+      rtx vec;\n+{\n+  rtx lab  = XEXP (vec, 0);\n+  rtx body = XEXP (vec, 1);\n+  int vlen = XVECLEN (body, 0);\n+  int idx;\n+\n+  ASM_OUTPUT_INTERNAL_LABEL (file, \"L\", CODE_LABEL_NUMBER (lab));\n+\n+  for (idx = 0; idx < vlen; idx++)\n+    {\n+      ASM_OUTPUT_ADDR_VEC_ELT\n+        (file, CODE_LABEL_NUMBER (XEXP (XVECEXP (body, 0, idx), 0)));\n+    }\n+}\n+\n+/* Output current function's deferred case vectors.  */\n+\n+static void\n+unicosmk_output_deferred_case_vectors (file)\n+      FILE *file;\n+{\n+  struct machine_function *machine = cfun->machine;\n+  rtx t;\n+\n+  if (machine->addr_list == NULL_RTX)\n+    return;\n+\n+  data_section ();\n+  for (t = machine->addr_list; t; t = XEXP (t, 1))\n+    unicosmk_output_addr_vec (file, XEXP (t, 0));\n+}\n+\n+/* Set up the dynamic subprogram information block (DSIB) and update the \n+   frame pointer register ($15) for subroutines which have a frame. If the \n+   subroutine doesn't have a frame, simply increment $15.  */\n+\n+static void\n+unicosmk_gen_dsib (imaskP)\n+      unsigned long * imaskP;\n+{\n+  if (alpha_is_stack_procedure)\n+    {\n+      const char *ssib_name;\n+      rtx mem;\n+\n+      /* Allocate 64 bytes for the DSIB.  */\n+\n+      FRP (emit_insn (gen_adddi3 (stack_pointer_rtx, stack_pointer_rtx,\n+                                  GEN_INT (-64))));\n+      emit_insn (gen_blockage ());\n+\n+      /* Save the return address.  */\n+\n+      mem = gen_rtx_MEM (DImode, plus_constant (stack_pointer_rtx, 56));\n+      set_mem_alias_set (mem, alpha_sr_alias_set);\n+      FRP (emit_move_insn (mem, gen_rtx_REG (DImode, REG_RA)));\n+      (*imaskP) &= ~(1L << REG_RA);\n+\n+      /* Save the old frame pointer.  */\n+\n+      mem = gen_rtx_MEM (DImode, plus_constant (stack_pointer_rtx, 48));\n+      set_mem_alias_set (mem, alpha_sr_alias_set);\n+      FRP (emit_move_insn (mem, hard_frame_pointer_rtx));\n+      (*imaskP) &= ~(1L << HARD_FRAME_POINTER_REGNUM);\n+\n+      emit_insn (gen_blockage ());\n+\n+      /* Store the SSIB pointer.  */\n+\n+      ssib_name = ggc_strdup (unicosmk_ssib_name ());\n+      mem = gen_rtx_MEM (DImode, plus_constant (stack_pointer_rtx, 32));\n+      set_mem_alias_set (mem, alpha_sr_alias_set);\n+\n+      FRP (emit_move_insn (gen_rtx_REG (DImode, 5),\n+                           gen_rtx_SYMBOL_REF (Pmode, ssib_name)));\n+      FRP (emit_move_insn (mem, gen_rtx_REG (DImode, 5)));\n+\n+      /* Save the CIW index.  */\n+\n+      mem = gen_rtx_MEM (DImode, plus_constant (stack_pointer_rtx, 24));\n+      set_mem_alias_set (mem, alpha_sr_alias_set);\n+      FRP (emit_move_insn (mem, gen_rtx_REG (DImode, 25)));\n+\n+      emit_insn (gen_blockage ());\n+\n+      /* Set the new frame pointer.  */\n+\n+      FRP (emit_insn (gen_adddi3 (hard_frame_pointer_rtx,\n+                                  stack_pointer_rtx, GEN_INT (64))));\n+\n+    }\n+  else\n+    {\n+      /* Increment the frame pointer register to indicate that we do not\n+         have a frame.  */\n+\n+      FRP (emit_insn (gen_adddi3 (hard_frame_pointer_rtx,\n+                                  hard_frame_pointer_rtx, GEN_INT (1))));\n+    }\n+}\n+\n+#define SSIB_PREFIX \"__SSIB_\"\n+#define SSIB_PREFIX_LEN 7\n+\n+/* Generate the name of the SSIB section for the current function.  */\n+\n+static const char *\n+unicosmk_ssib_name ()\n+{\n+  /* This is ok since CAM won't be able to deal with names longer than that \n+     anyway.  */\n+\n+  static char name[256];\n+\n+  rtx x;\n+  const char *fnname;\n+  char *ssib_name;\n+  int len;\n+\n+  x = DECL_RTL (cfun->decl);\n+  if (GET_CODE (x) != MEM)\n+    abort ();\n+  x = XEXP (x, 0);\n+  if (GET_CODE (x) != SYMBOL_REF)\n+    abort ();\n+  fnname = XSTR (x, 0);\n+  STRIP_NAME_ENCODING (fnname, fnname);\n+\n+  len = strlen (fnname);\n+  if (len + SSIB_PREFIX_LEN > 255)\n+    len = 255 - SSIB_PREFIX_LEN;\n+\n+  strcpy (name, SSIB_PREFIX);\n+  strncpy (name + SSIB_PREFIX_LEN, fnname, len);\n+  name[len + SSIB_PREFIX_LEN] = 0;\n+\n+  return name;\n+}\n+\n+/* Output the static subroutine information block for the current\n+   function.  */\n+\n+static void\n+unicosmk_output_ssib (file, fnname)\n+      FILE *file;\n+      const char *fnname;\n+{\n+  int len;\n+  int i;\n+  rtx x;\n+  rtx ciw;\n+  struct machine_function *machine = cfun->machine;\n+\n+  ssib_section ();\n+  fprintf (file, \"\\t.endp\\n\\n\\t.psect\\t%s%s,data\\n\", user_label_prefix,\n+\t   unicosmk_ssib_name ());\n+\n+  /* Some required stuff and the function name length.  */\n+\n+  len = strlen (fnname);\n+  fprintf (file, \"\\t.quad\\t^X20008%2.2X28\\n\", len);\n+\n+  /* Saved registers\n+     ??? We don't do that yet.  */\n+\n+  fputs (\"\\t.quad\\t0\\n\", file);\n+\n+  /* Function address.  */\n+\n+  fputs (\"\\t.quad\\t\", file);\n+  assemble_name (file, fnname);\n+  putc ('\\n', file);\n+\n+  fputs (\"\\t.quad\\t0\\n\", file);\n+  fputs (\"\\t.quad\\t0\\n\", file);\n+\n+  /* Function name.\n+     ??? We do it the same way Cray CC does it but this could be\n+     simplified.  */\n+\n+  for( i = 0; i < len; i++ )\n+    fprintf (file, \"\\t.byte\\t%d\\n\", (int)(fnname[i]));\n+  if( (len % 8) == 0 )\n+    fputs (\"\\t.quad\\t0\\n\", file);\n+  else\n+    fprintf (file, \"\\t.bits\\t%d : 0\\n\", (8 - (len % 8))*8);\n+\n+  /* All call information words used in the function.  */\n+\n+  for (x = machine->first_ciw; x; x = XEXP (x, 1))\n+    {\n+      ciw = XEXP (x, 0);\n+      fprintf (file, \"\\t.quad\\t\");\n+#if HOST_BITS_PER_WIDE_INT == 32\n+      fprintf (file, HOST_WIDE_INT_PRINT_DOUBLE_HEX,\n+\t       CONST_DOUBLE_HIGH (ciw), CONST_DOUBLE_LOW (ciw));\n+#else\n+      fprintf (file, HOST_WIDE_INT_PRINT_HEX, INTVAL (ciw));\n+#endif\n+      fprintf (file, \"\\n\");\n+    }\n+}\n+\n+/* Add a call information word (CIW) to the list of the current function's\n+   CIWs and return its index.\n+\n+   X is a CONST_INT or CONST_DOUBLE representing the CIW.  */\n+\n+rtx\n+unicosmk_add_call_info_word (x)\n+      rtx x;\n+{\n+  rtx node;\n+  struct machine_function *machine = cfun->machine;\n+\n+  node = gen_rtx_EXPR_LIST (VOIDmode, x, NULL_RTX);\n+  if (machine->first_ciw == NULL_RTX)\n+    machine->first_ciw = node;\n+  else\n+    XEXP (machine->last_ciw, 1) = node;\n+\n+  machine->last_ciw = node;\n+  ++machine->ciw_count;\n+\n+  return GEN_INT (machine->ciw_count\n+\t\t  + strlen (current_function_name)/8 + 5);\n+}\n+\n+static char unicosmk_section_buf[100];\n+\n+char *\n+unicosmk_text_section ()\n+{\n+  static int count = 0;\n+  sprintf (unicosmk_section_buf, \"\\t.endp\\n\\n\\t.psect\\tgcc@text___%d,code\", \n+\t\t\t\t count++);\n+  return unicosmk_section_buf;\n+}\n+\n+char *\n+unicosmk_data_section ()\n+{\n+  static int count = 1;\n+  sprintf (unicosmk_section_buf, \"\\t.endp\\n\\n\\t.psect\\tgcc@data___%d,data\", \n+\t\t\t\t count++);\n+  return unicosmk_section_buf;\n+}\n+\n+/* The Cray assembler doesn't accept extern declarations for symbols which\n+   are defined in the same file. We have to keep track of all global\n+   symbols which are referenced and/or defined in a source file and output\n+   extern declarations for those which are referenced but not defined at\n+   the end of file.  */\n+\n+/* List of identifiers for which an extern declaration might have to be\n+   emitted.  */\n+\n+struct unicosmk_extern_list\n+{\n+  struct unicosmk_extern_list *next;\n+  const char *name;\n+};\n+\n+static struct unicosmk_extern_list *unicosmk_extern_head = 0;\n+\n+/* Output extern declarations which are required for every asm file.  */\n+\n+static void\n+unicosmk_output_default_externs (file)\n+\tFILE *file;\n+{\n+  static const char *externs[] =\n+    { \"__T3E_MISMATCH\" };\n+\n+  int i;\n+  int n;\n+\n+  n = ARRAY_SIZE (externs);\n+\n+  for (i = 0; i < n; i++)\n+    fprintf (file, \"\\t.extern\\t%s\\n\", externs[i]);\n+}\n+\n+/* Output extern declarations for global symbols which are have been\n+   referenced but not defined.  */\n+\n+static void\n+unicosmk_output_externs (file)\n+      FILE *file;\n+{\n+  struct unicosmk_extern_list *p;\n+  const char *real_name;\n+  int len;\n+  tree name_tree;\n+\n+  len = strlen (user_label_prefix);\n+  for (p = unicosmk_extern_head; p != 0; p = p->next)\n+    {\n+      /* We have to strip the encoding and possibly remove user_label_prefix \n+\t from the identifier in order to handle -fleading-underscore and\n+\t explicit asm names correctly (cf. gcc.dg/asm-names-1.c).  */\n+      STRIP_NAME_ENCODING (real_name, p->name);\n+      if (len && p->name[0] == '*'\n+\t  && !memcmp (real_name, user_label_prefix, len))\n+\treal_name += len;\n+\t\n+      name_tree = get_identifier (real_name);\n+      if (! TREE_ASM_WRITTEN (name_tree))\n+\t{\n+\t  TREE_ASM_WRITTEN (name_tree) = 1;\n+\t  fputs (\"\\t.extern\\t\", file);\n+\t  assemble_name (file, p->name);\n+\t  putc ('\\n', file);\n+\t}\n+    }\n+}\n+      \n+/* Record an extern.  */\n+\n+void\n+unicosmk_add_extern (name)\n+     const char *name;\n+{\n+  struct unicosmk_extern_list *p;\n+\n+  p = (struct unicosmk_extern_list *)\n+       permalloc (sizeof (struct unicosmk_extern_list));\n+  p->next = unicosmk_extern_head;\n+  p->name = name;\n+  unicosmk_extern_head = p;\n+}\n+\n+/* The Cray assembler generates incorrect code if identifiers which\n+   conflict with register names are used as instruction operands. We have\n+   to replace such identifiers with DEX expressions.  */\n+\n+/* Structure to collect identifiers which have been replaced by DEX\n+   expressions.  */\n+\n+struct unicosmk_dex {\n+  struct unicosmk_dex *next;\n+  const char *name;\n+};\n+\n+/* List of identifiers which have been replaced by DEX expressions. The DEX \n+   number is determined by the position in the list.  */\n+\n+static struct unicosmk_dex *unicosmk_dex_list = NULL; \n+\n+/* The number of elements in the DEX list.  */\n+\n+static int unicosmk_dex_count = 0;\n+\n+/* Check if NAME must be replaced by a DEX expression.  */\n+\n+static int\n+unicosmk_special_name (name)\n+      const char *name;\n+{\n+  if (name[0] == '*')\n+    ++name;\n+\n+  if (name[0] == '$')\n+    ++name;\n+\n+  if (name[0] != 'r' && name[0] != 'f' && name[0] != 'R' && name[0] != 'F')\n+    return 0;\n+\n+  switch (name[1])\n+    {\n+    case '1':  case '2':\n+      return (name[2] == '\\0' || (ISDIGIT (name[2]) && name[3] == '\\0'));\n+\n+    case '3':\n+      return (name[2] == '\\0'\n+\t       || ((name[2] == '0' || name[2] == '1') && name[3] == '\\0'));\n+\n+    default:\n+      return (ISDIGIT (name[1]) && name[2] == '\\0');\n+    }\n+}\n+\n+/* Return the DEX number if X must be replaced by a DEX expression and 0\n+   otherwise.  */\n+\n+static int\n+unicosmk_need_dex (x)\n+      rtx x;\n+{\n+  struct unicosmk_dex *dex;\n+  const char *name;\n+  int i;\n+  \n+  if (GET_CODE (x) != SYMBOL_REF)\n+    return 0;\n+\n+  name = XSTR (x,0);\n+  if (! unicosmk_special_name (name))\n+    return 0;\n+\n+  i = unicosmk_dex_count;\n+  for (dex = unicosmk_dex_list; dex; dex = dex->next)\n+    {\n+      if (! strcmp (name, dex->name))\n+        return i;\n+      --i;\n+    }\n+      \n+  dex = (struct unicosmk_dex *) permalloc (sizeof (struct unicosmk_dex));\n+  dex->name = name;\n+  dex->next = unicosmk_dex_list;\n+  unicosmk_dex_list = dex;\n+\n+  ++unicosmk_dex_count;\n+  return unicosmk_dex_count;\n+}\n+\n+/* Output the DEX definitions for this file.  */\n+\n+static void\n+unicosmk_output_dex (file)\n+      FILE *file;\n+{\n+  struct unicosmk_dex *dex;\n+  int i;\n+\n+  if (unicosmk_dex_list == NULL)\n+    return;\n+\n+  fprintf (file, \"\\t.dexstart\\n\");\n+\n+  i = unicosmk_dex_count;\n+  for (dex = unicosmk_dex_list; dex; dex = dex->next)\n+    {\n+      fprintf (file, \"\\tDEX (%d) = \", i);\n+      assemble_name (file, dex->name);\n+      putc ('\\n', file);\n+      --i;\n+    }\n+  \n+  fprintf (file, \"\\t.dexend\\n\");\n+}\n+\n+#else\n+\n+static void\n+unicosmk_output_deferred_case_vectors (file)\n+      FILE *file ATTRIBUTE_UNUSED;\n+{}\n+\n+static void\n+unicosmk_gen_dsib (imaskP)\n+      unsigned long * imaskP ATTRIBUTE_UNUSED;\n+{}\n+\n+static void\n+unicosmk_output_ssib (file, fnname)\n+      FILE * file ATTRIBUTE_UNUSED;\n+      const char * fnname ATTRIBUTE_UNUSED;\n+{}\n+\n+rtx\n+unicosmk_add_call_info_word (x)\n+     rtx x ATTRIBUTE_UNUSED;\n+{\n+  return NULL_RTX;\n+}\n+\n+static int\n+unicosmk_need_dex (x)\n+      rtx x ATTRIBUTE_UNUSED;\n+{\n+  return 0;\n+}\n+\n+#endif /* TARGET_ABI_UNICOSMK */"}, {"sha": "3b030b27002885e03ff145660256daacd746a88d", "filename": "gcc/config/alpha/alpha.h", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30102605e710a95f8cb00ddd14303d7fcc284fae/gcc%2Fconfig%2Falpha%2Falpha.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30102605e710a95f8cb00ddd14303d7fcc284fae/gcc%2Fconfig%2Falpha%2Falpha.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.h?ref=30102605e710a95f8cb00ddd14303d7fcc284fae", "patch": "@@ -179,11 +179,17 @@ extern enum alpha_fp_trap_mode alpha_fptm;\n /* These are for target os support and cannot be changed at runtime.  */\n #define TARGET_ABI_WINDOWS_NT 0\n #define TARGET_ABI_OPEN_VMS 0\n-#define TARGET_ABI_OSF (!TARGET_ABI_WINDOWS_NT && !TARGET_ABI_OPEN_VMS)\n+#define TARGET_ABI_UNICOSMK 0\n+#define TARGET_ABI_OSF (!TARGET_ABI_WINDOWS_NT\t\\\n+\t\t\t&& !TARGET_ABI_OPEN_VMS\t\\\n+\t\t\t&& !TARGET_ABI_UNICOSMK)\n \n #ifndef TARGET_AS_CAN_SUBTRACT_LABELS\n #define TARGET_AS_CAN_SUBTRACT_LABELS TARGET_GAS\n #endif\n+#ifndef TARGET_AS_SLASH_BEFORE_SUFFIX\n+#define TARGET_AS_SLASH_BEFORE_SUFFIX TARGET_GAS\n+#endif\n #ifndef TARGET_CAN_FAULT_IN_PROLOGUE\n #define TARGET_CAN_FAULT_IN_PROLOGUE 0\n #endif\n@@ -792,14 +798,18 @@ enum reg_class { NO_REGS, PV_REG, GENERAL_REGS, FLOAT_REGS, ALL_REGS,\n    `R' is a SYMBOL_REF that has SYMBOL_REF_FLAG set or is the current\n    function.\n \n-   'S' is a 6-bit constant (valid for a shift insn).  */\n+   'S' is a 6-bit constant (valid for a shift insn).  \n+\n+   'U' is a symbolic operand.  */\n \n #define EXTRA_CONSTRAINT(OP, C)\t\t\t\t\\\n   ((C) == 'Q' ? normal_memory_operand (OP, VOIDmode)\t\t\t\\\n    : (C) == 'R' ? current_file_function_operand (OP, Pmode)\t\t\\\n    : (C) == 'S' ? (GET_CODE (OP) == CONST_INT\t\t\t\t\\\n \t\t   && (unsigned HOST_WIDE_INT) INTVAL (OP) < 64)\t\\\n    : (C) == 'T' ? GET_CODE (OP) == HIGH\t\t\t\t\t\\\n+   : (TARGET_ABI_UNICOSMK && (C) == 'U')\t\t\t\t\\\n+\t\t? symbolic_operand (OP, VOIDmode)\t\t\t\\\n    : 0)\n \n /* Given an rtx X being reloaded into a reg required to be\n@@ -2174,7 +2184,8 @@ do {\t\t\t\t\t\t\t\t\t\\\n   {\"hard_int_register_operand\", {SUBREG, REG}},\t\t\t\t\\\n   {\"reg_not_elim_operand\", {SUBREG, REG}},\t\t\t\t\\\n   {\"reg_no_subreg_operand\", {REG}},\t\t\t\t\t\\\n-  {\"addition_operation\", {PLUS}},\n+  {\"addition_operation\", {PLUS}},\t\t\t\t\t\\\n+  {\"symbolic_operand\", {SYMBOL_REF, LABEL_REF, CONST}},\n \f\n /* Define the `__builtin_va_list' type for the ABI.  */\n #define BUILD_VA_LIST_TYPE(VALIST) \\"}, {"sha": "34280f7f772d60e66b85e74bcd4bb0c52fc05c17", "filename": "gcc/config/alpha/alpha.md", "status": "modified", "additions": 819, "deletions": 142, "changes": 961, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30102605e710a95f8cb00ddd14303d7fcc284fae/gcc%2Fconfig%2Falpha%2Falpha.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30102605e710a95f8cb00ddd14303d7fcc284fae/gcc%2Fconfig%2Falpha%2Falpha.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.md?ref=30102605e710a95f8cb00ddd14303d7fcc284fae", "patch": "@@ -31,6 +31,10 @@\n    (UNSPEC_MSKXH\t3)\n    (UNSPEC_CVTQL\t4)\n    (UNSPEC_NT_LDA\t5)\n+   (UNSPEC_UMK_LAUM\t6)\n+   (UNSPEC_UMK_LALM\t7)\n+   (UNSPEC_UMK_LAL\t8)\n+   (UNSPEC_UMK_LOAD_CIW\t9)\n   ])\n \n ;; UNSPEC_VOLATILE:\n@@ -49,6 +53,12 @@\n    (UNSPECV_LDGP2\t10)\n    (UNSPECV_FORCE_MOV\t11)\n   ])\n+\n+;; Where necessary, the suffixes _le and _be are used to distinguish between\n+;; little-endian and big-endian patterns.\n+;;\n+;; Note that the Unicos/Mk assembler does not support the following\n+;; opcodes: mov, fmov, nop, fnop, unop.\n \f\n ;; Processor type -- this attribute must exactly match the processor_type\n ;; enumeration in alpha.h.\n@@ -904,11 +914,13 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi\"\n   \"\"\n   \"subqv %r1,%2,%0\")\n \n+;; The Unicos/Mk assembler doesn't support mull.\n+\n (define_insn \"mulsi3\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(mult:SI (match_operand:SI 1 \"reg_or_0_operand\" \"%rJ\")\n \t\t (match_operand:SI 2 \"reg_or_8bit_operand\" \"rI\")))]\n-  \"\"\n+  \"!TARGET_ABI_UNICOSMK\"\n   \"mull %r1,%2,%0\"\n   [(set_attr \"type\" \"imul\")\n    (set_attr \"opsize\" \"si\")])\n@@ -918,7 +930,7 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi\"\n \t(sign_extend:DI\n \t  (mult:SI (match_operand:SI 1 \"reg_or_0_operand\" \"%rJ\")\n \t\t   (match_operand:SI 2 \"reg_or_8bit_operand\" \"rI\"))))]\n-  \"\"\n+  \"!TARGET_ABI_UNICOSMK\"\n   \"mull %r1,%2,%0\"\n   [(set_attr \"type\" \"imul\")\n    (set_attr \"opsize\" \"si\")])\n@@ -932,7 +944,7 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi\"\n \t\t(sign_extend:DI (mult:SI (match_dup 1)\n \t\t\t\t\t (match_dup 2))))\n \t    (const_int 0))]\n-  \"\"\n+  \"!TARGET_ABI_UNICOSMK\"\n   \"mullv %r1,%2,%0\"\n   [(set_attr \"type\" \"imul\")\n    (set_attr \"opsize\" \"si\")])\n@@ -984,14 +996,17 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi\"\n   [(set_attr \"type\" \"imul\")\n    (set_attr \"opsize\" \"udi\")])\n \f\n-;; The divide and remainder operations always take their inputs from\n-;; r24 and r25, put their output in r27, and clobber r23 and r28.\n-\n-;; ??? Force sign-extension here because some versions of OSF/1 don't\n-;; do the right thing if the inputs are not properly sign-extended.\n-;; But Linux, for instance, does not have this problem.  Is it worth\n-;; the complication here to eliminate the sign extension?\n-;; Interix/NT has the same sign-extension problem.\n+;; The divide and remainder operations take their inputs from r24 and\n+;; r25, put their output in r27, and clobber r23 and r28 on all\n+;; systems except Unicos/Mk. On Unicos, the standard library provides\n+;; subroutines which use the standard calling convention and work on\n+;; DImode operands.\n+\n+;; ??? Force sign-extension here because some versions of OSF/1 and\n+;; Interix/NT don't do the right thing if the inputs are not properly\n+;; sign-extended.  But Linux, for instance, does not have this\n+;; problem.  Is it worth the complication here to eliminate the sign\n+;; extension?\n \n (define_expand \"divsi3\"\n   [(set (reg:DI 24)\n@@ -1004,7 +1019,7 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi\"\n \t      (clobber (reg:DI 28))])\n    (set (match_operand:SI 0 \"nonimmediate_operand\" \"\")\n \t(subreg:SI (reg:DI 27) 0))]\n-  \"! TARGET_ABI_OPEN_VMS\"\n+  \"! TARGET_ABI_OPEN_VMS && ! TARGET_ABI_UNICOSMK\"\n   \"\")\n \n (define_expand \"udivsi3\"\n@@ -1018,7 +1033,7 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi\"\n \t      (clobber (reg:DI 28))])\n    (set (match_operand:SI 0 \"nonimmediate_operand\" \"\")\n \t(subreg:SI (reg:DI 27) 0))]\n-  \"! TARGET_ABI_OPEN_VMS\"\n+  \"! TARGET_ABI_OPEN_VMS && ! TARGET_ABI_UNICOSMK\"\n   \"\")\n \n (define_expand \"modsi3\"\n@@ -1032,7 +1047,7 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi\"\n \t      (clobber (reg:DI 28))])\n    (set (match_operand:SI 0 \"nonimmediate_operand\" \"\")\n \t(subreg:SI (reg:DI 27) 0))]\n-  \"! TARGET_ABI_OPEN_VMS\"\n+  \"! TARGET_ABI_OPEN_VMS && ! TARGET_ABI_UNICOSMK\"\n   \"\")\n \n (define_expand \"umodsi3\"\n@@ -1046,7 +1061,7 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi\"\n \t      (clobber (reg:DI 28))])\n    (set (match_operand:SI 0 \"nonimmediate_operand\" \"\")\n \t(subreg:SI (reg:DI 27) 0))]\n-  \"! TARGET_ABI_OPEN_VMS\"\n+  \"! TARGET_ABI_OPEN_VMS && ! TARGET_ABI_UNICOSMK\"\n   \"\")\n \n (define_expand \"divdi3\"\n@@ -1059,7 +1074,7 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi\"\n \t      (clobber (reg:DI 28))])\n    (set (match_operand:DI 0 \"nonimmediate_operand\" \"\")\n \t(reg:DI 27))]\n-  \"! TARGET_ABI_OPEN_VMS\"\n+  \"! TARGET_ABI_OPEN_VMS && ! TARGET_ABI_UNICOSMK\"\n   \"\")\n \n (define_expand \"udivdi3\"\n@@ -1072,10 +1087,23 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi\"\n \t      (clobber (reg:DI 28))])\n    (set (match_operand:DI 0 \"nonimmediate_operand\" \"\")\n \t(reg:DI 27))]\n-  \"! TARGET_ABI_OPEN_VMS\"\n+  \"! TARGET_ABI_OPEN_VMS && ! TARGET_ABI_UNICOSMK\"\n   \"\")\n \n (define_expand \"moddi3\"\n+  [(use (match_operand:DI 0 \"nonimmediate_operand\" \"\"))\n+   (use (match_operand:DI 1 \"input_operand\" \"\"))\n+   (use (match_operand:DI 2 \"input_operand\" \"\"))]\n+  \"!TARGET_ABI_OPEN_VMS\"\n+{\n+  if (TARGET_ABI_UNICOSMK)\n+    emit_insn (gen_moddi3_umk (operands[0], operands[1], operands[2]));\n+  else\n+    emit_insn (gen_moddi3_dft (operands[0], operands[1], operands[2]));\n+  DONE;\n+})\n+\n+(define_expand \"moddi3_dft\"\n   [(set (reg:DI 24) (match_operand:DI 1 \"input_operand\" \"\"))\n    (set (reg:DI 25) (match_operand:DI 2 \"input_operand\" \"\"))\n    (parallel [(set (reg:DI 27)\n@@ -1085,10 +1113,48 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi\"\n \t      (clobber (reg:DI 28))])\n    (set (match_operand:DI 0 \"nonimmediate_operand\" \"\")\n \t(reg:DI 27))]\n-  \"! TARGET_ABI_OPEN_VMS\"\n+  \"! TARGET_ABI_OPEN_VMS && ! TARGET_ABI_UNICOSMK\"\n   \"\")\n \n+;; On Unicos/Mk, we do as the system's C compiler does:\n+;; compute the quotient, multiply and subtract.\n+\n+(define_expand \"moddi3_umk\"\n+  [(use (match_operand:DI 0 \"nonimmediate_operand\" \"\"))\n+   (use (match_operand:DI 1 \"input_operand\" \"\"))\n+   (use (match_operand:DI 2 \"input_operand\" \"\"))]\n+  \"TARGET_ABI_UNICOSMK\"\n+{\n+  rtx mul, div, tmp;\n+\n+  mul = gen_reg_rtx (DImode);\n+  tmp = gen_reg_rtx (DImode);\n+  operands[1] = force_reg (DImode, operands[1]);\n+  operands[2] = force_reg (DImode, operands[2]);\n+\n+  div = expand_binop (DImode, sdiv_optab, operands[1], operands[2],\n+\t\t      NULL_RTX, 0, OPTAB_LIB);\n+  div = force_reg (DImode, div);\n+  emit_insn (gen_muldi3 (mul, operands[2], div));\n+  emit_insn (gen_subdi3 (tmp, operands[1], mul));\n+  emit_move_insn (operands[0], tmp);\n+  DONE;\n+})\n+\n (define_expand \"umoddi3\"\n+  [(use (match_operand:DI 0 \"nonimmediate_operand\" \"\"))\n+   (use (match_operand:DI 1 \"input_operand\" \"\"))\n+   (use (match_operand:DI 2 \"input_operand\" \"\"))]\n+  \"! TARGET_ABI_OPEN_VMS\"\n+{\n+  if (TARGET_ABI_UNICOSMK)\n+    emit_insn (gen_umoddi3_umk (operands[0], operands[1], operands[2]));\n+  else\n+    emit_insn (gen_umoddi3_dft (operands[0], operands[1], operands[2]));\n+  DONE;\n+})\n+\n+(define_expand \"umoddi3_dft\"\n   [(set (reg:DI 24) (match_operand:DI 1 \"input_operand\" \"\"))\n    (set (reg:DI 25) (match_operand:DI 2 \"input_operand\" \"\"))\n    (parallel [(set (reg:DI 27)\n@@ -1098,9 +1164,31 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi\"\n \t      (clobber (reg:DI 28))])\n    (set (match_operand:DI 0 \"nonimmediate_operand\" \"\")\n \t(reg:DI 27))]\n-  \"! TARGET_ABI_OPEN_VMS\"\n+  \"! TARGET_ABI_OPEN_VMS && ! TARGET_ABI_UNICOSMK\"\n   \"\")\n \n+(define_expand \"umoddi3_umk\"\n+  [(use (match_operand:DI 0 \"nonimmediate_operand\" \"\"))\n+   (use (match_operand:DI 1 \"input_operand\" \"\"))\n+   (use (match_operand:DI 2 \"input_operand\" \"\"))]\n+  \"TARGET_ABI_UNICOSMK\"\n+{\n+  rtx mul, div, tmp;\n+\n+  mul = gen_reg_rtx (DImode);\n+  tmp = gen_reg_rtx (DImode);\n+  operands[1] = force_reg (DImode, operands[1]);\n+  operands[2] = force_reg (DImode, operands[2]);\n+\n+  div = expand_binop (DImode, udiv_optab, operands[1], operands[2],\n+\t\t      NULL_RTX, 1, OPTAB_LIB);\n+  div = force_reg (DImode, div);\n+  emit_insn (gen_muldi3 (mul, operands[2], div));\n+  emit_insn (gen_subdi3 (tmp, operands[1], mul));\n+  emit_move_insn (operands[0], tmp);\n+  DONE;\n+})\n+\n ;; Lengths of 8 for ldq $t12,__divq($gp); jsr $t9,($t12),__divq as\n ;; expanded by the assembler.\n \n@@ -1121,7 +1209,7 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi\"\n \t\t\t[(reg:DI 24) (reg:DI 25)])))\n    (clobber (reg:DI 23))\n    (clobber (reg:DI 28))]\n-  \"! TARGET_ABI_OPEN_VMS\"\n+  \"! TARGET_ABI_OPEN_VMS && ! TARGET_ABI_UNICOSMK\"\n   \"%E0 $24,$25,$27\"\n   [(set_attr \"type\" \"jsr\")\n    (set_attr \"length\" \"8\")])\n@@ -1143,7 +1231,7 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi\"\n \t\t\t[(reg:DI 24) (reg:DI 25)]))\n    (clobber (reg:DI 23))\n    (clobber (reg:DI 28))]\n-  \"! TARGET_ABI_OPEN_VMS\"\n+  \"! TARGET_ABI_OPEN_VMS && ! TARGET_ABI_UNICOSMK\"\n   \"%E0 $24,$25,$27\"\n   [(set_attr \"type\" \"jsr\")\n    (set_attr \"length\" \"8\")])\n@@ -1655,6 +1743,18 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi\"\n ;;\n ;; Operand 1 is the address + 1 (+2 for HI), operand 0 is the result.\n (define_expand \"unaligned_extendqidi\"\n+  [(use (match_operand:QI 0 \"register_operand\" \"\"))\n+   (use (match_operand:DI 1 \"address_operand\" \"\"))]\n+  \"\"\n+{\n+  if (WORDS_BIG_ENDIAN)\n+    emit_insn (gen_unaligned_extendqidi_be (operands[0], operands[1]));\n+  else\n+    emit_insn (gen_unaligned_extendqidi_le (operands[0], operands[1]));\n+  DONE;\n+})\n+\n+(define_expand \"unaligned_extendqidi_le\"\n   [(set (match_dup 2) (match_operand:DI 1 \"address_operand\" \"\"))\n    (set (match_dup 3)\n \t(mem:DI (and:DI (plus:DI (match_dup 2) (const_int -1))\n@@ -1667,14 +1767,51 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi\"\n \t\t\t      (const_int 3)))))\n    (set (subreg:DI (match_operand:QI 0 \"register_operand\" \"\") 0)\n \t(ashiftrt:DI (match_dup 4) (const_int 56)))]\n-  \"\"\n+  \"! WORDS_BIG_ENDIAN\"\n+{\n+  operands[2] = gen_reg_rtx (DImode);\n+  operands[3] = gen_reg_rtx (DImode);\n+  operands[4] = gen_reg_rtx (DImode);\n+})\n+\n+(define_expand \"unaligned_extendqidi_be\"\n+  [(set (match_dup 2) (match_operand:DI 1 \"address_operand\" \"\"))\n+   (set (match_dup 3) (plus:DI (match_dup 2) (const_int -1)))\n+   (set (match_dup 4)\n+\t(mem:DI (and:DI (match_dup 3)\n+\t\t\t(const_int -8))))\n+   (set (match_dup 5) (plus:DI (match_dup 2) (const_int -2)))\n+   (set (match_dup 6)\n+\t(ashift:DI (match_dup 4)\n+\t\t   (ashift:DI\n+\t\t     (and:DI\n+\t\t       (plus:DI (match_dup 5) (const_int 1))\n+\t\t       (const_int 7))\n+\t\t     (const_int 3))))\n+   (set (subreg:DI (match_operand:QI 0 \"register_operand\" \"\") 0)\n+\t(ashiftrt:DI (match_dup 6) (const_int 56)))]\n+  \"WORDS_BIG_ENDIAN\"\n {\n   operands[2] = gen_reg_rtx (DImode);\n   operands[3] = gen_reg_rtx (DImode);\n   operands[4] = gen_reg_rtx (DImode);\n+  operands[5] = gen_reg_rtx (DImode);\n+  operands[6] = gen_reg_rtx (DImode);\n })\n \n (define_expand \"unaligned_extendhidi\"\n+  [(use (match_operand:QI 0 \"register_operand\" \"\"))\n+   (use (match_operand:DI 1 \"address_operand\" \"\"))]\n+  \"\"\n+{\n+  if (WORDS_BIG_ENDIAN)\n+    emit_insn (gen_unaligned_extendhidi_be (operands[0], operands[1]));\n+  else\n+    emit_insn (gen_unaligned_extendhidi_le (operands[0], operands[1]));\n+  DONE;\n+})\n+\n+(define_expand \"unaligned_extendhidi_le\"\n   [(set (match_dup 2) (match_operand:DI 1 \"address_operand\" \"\"))\n    (set (match_dup 3)\n \t(mem:DI (and:DI (plus:DI (match_dup 2) (const_int -2))\n@@ -1687,13 +1824,36 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi\"\n \t\t\t      (const_int 3)))))\n    (set (subreg:DI (match_operand:QI 0 \"register_operand\" \"\") 0)\n \t(ashiftrt:DI (match_dup 4) (const_int 48)))]\n-  \"\"\n+  \"! WORDS_BIG_ENDIAN\"\n {\n   operands[2] = gen_reg_rtx (DImode);\n   operands[3] = gen_reg_rtx (DImode);\n   operands[4] = gen_reg_rtx (DImode);\n })\n \n+(define_expand \"unaligned_extendhidi_be\"\n+  [(set (match_dup 2) (match_operand:DI 1 \"address_operand\" \"\"))\n+   (set (match_dup 3) (plus:DI (match_dup 2) (const_int -2)))\n+   (set (match_dup 4)\n+\t(mem:DI (and:DI (match_dup 3)\n+\t\t\t(const_int -8))))\n+   (set (match_dup 5) (plus:DI (match_dup 2) (const_int -3)))\n+   (set (match_dup 6)\n+\t(ashift:DI (match_dup 4)\n+\t\t   (ashift:DI\n+\t\t     (and:DI (match_dup 5) (const_int 7))\n+\t\t     (const_int 8))))\n+   (set (subreg:DI (match_operand:QI 0 \"register_operand\" \"\") 0)\n+\t(ashiftrt:DI (match_dup 6) (const_int 48)))]\n+  \"WORDS_BIG_ENDIAN\"\n+{\n+  operands[2] = gen_reg_rtx (DImode);\n+  operands[3] = gen_reg_rtx (DImode);\n+  operands[4] = gen_reg_rtx (DImode);\n+  operands[5] = gen_reg_rtx (DImode);\n+  operands[6] = gen_reg_rtx (DImode);\n+})\n+\n (define_insn \"*extxl_const\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(zero_extract:DI (match_operand:DI 1 \"reg_or_0_operand\" \"rJ\")\n@@ -1703,40 +1863,77 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi\"\n   \"ext%M2l %r1,%s3,%0\"\n   [(set_attr \"type\" \"shift\")])\n \n-(define_insn \"extxl\"\n+(define_insn \"extxl_le\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(zero_extract:DI (match_operand:DI 1 \"reg_or_0_operand\" \"rJ\")\n \t\t\t (match_operand:DI 2 \"mode_width_operand\" \"n\")\n \t\t\t (ashift:DI (match_operand:DI 3 \"reg_or_8bit_operand\" \"rI\")\n \t\t\t\t    (const_int 3))))]\n-  \"\"\n+  \"! WORDS_BIG_ENDIAN\"\n+  \"ext%M2l %r1,%3,%0\"\n+  [(set_attr \"type\" \"shift\")])\n+\n+(define_insn \"extxl_be\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(zero_extract:DI (match_operand:DI 1 \"reg_or_0_operand\" \"rJ\")\n+\t\t\t (match_operand:DI 2 \"mode_width_operand\" \"n\")\n+\t\t\t (minus:DI\n+\t\t\t   (const_int 56)\n+\t\t\t   (ashift:DI\n+\t\t\t     (match_operand:DI 3 \"reg_or_8bit_operand\" \"rI\")\n+\t\t\t     (const_int 3)))))]\n+  \"WORDS_BIG_ENDIAN\"\n   \"ext%M2l %r1,%3,%0\"\n   [(set_attr \"type\" \"shift\")])\n \n ;; Combine has some strange notion of preserving existing undefined behaviour\n ;; in shifts larger than a word size.  So capture these patterns that it\n ;; should have turned into zero_extracts.\n \n-(define_insn \"*extxl_1\"\n+(define_insn \"*extxl_1_le\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(and:DI (lshiftrt:DI (match_operand:DI 1 \"reg_or_0_operand\" \"rJ\")\n \t\t  (ashift:DI (match_operand:DI 2 \"reg_or_8bit_operand\" \"rI\")\n \t\t\t     (const_int 3)))\n \t     (match_operand:DI 3 \"mode_mask_operand\" \"n\")))]\n-  \"\"\n+  \"! WORDS_BIG_ENDIAN\"\n   \"ext%U3l %1,%2,%0\"\n   [(set_attr \"type\" \"shift\")])\n \n-(define_insn \"*extql_2\"\n+(define_insn \"*extxl_1_be\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(and:DI (lshiftrt:DI\n+\t\t  (match_operand:DI 1 \"reg_or_0_operand\" \"rJ\")\n+\t\t  (minus:DI (const_int 56)\n+\t\t    (ashift:DI (match_operand:DI 2 \"reg_or_8bit_operand\" \"rI\")\n+\t\t\t       (const_int 3))))\n+\t\t(match_operand:DI 3 \"mode_mask_operand\" \"n\")))]\n+  \"WORDS_BIG_ENDIAN\"\n+  \"ext%U3l %1,%2,%0\"\n+  [(set_attr \"type\" \"shift\")])\n+\n+(define_insn \"*extql_2_le\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(lshiftrt:DI (match_operand:DI 1 \"reg_or_0_operand\" \"rJ\")\n \t  (ashift:DI (match_operand:DI 2 \"reg_or_8bit_operand\" \"rI\")\n \t\t     (const_int 3))))]\n-  \"\"\n+  \"! WORDS_BIG_ENDIAN\"\n   \"extql %1,%2,%0\"\n   [(set_attr \"type\" \"shift\")])\n \n-(define_insn \"extqh\"\n+(define_insn \"*extql_2_be\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(lshiftrt:DI\n+\t  (match_operand:DI 1 \"reg_or_0_operand\" \"rJ\")\n+\t  (minus:DI (const_int 56)\n+\t\t    (ashift:DI\n+\t\t      (match_operand:DI 2 \"reg_or_8bit_operand\" \"rI\")\n+\t\t      (const_int 3)))))]\n+  \"WORDS_BIG_ENDIAN\"\n+  \"extql %1,%2,%0\"\n+  [(set_attr \"type\" \"shift\")])\n+\n+(define_insn \"extqh_le\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(ashift:DI\n \t (match_operand:DI 1 \"reg_or_0_operand\" \"rJ\")\n@@ -1746,11 +1943,25 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi\"\n \t\t      (match_operand:DI 2 \"reg_or_8bit_operand\" \"rI\")\n \t\t      (const_int 7))\n \t\t     (const_int 3)))))]\n-  \"\"\n+  \"! WORDS_BIG_ENDIAN\"\n   \"extqh %r1,%2,%0\"\n   [(set_attr \"type\" \"shift\")])\n \n-(define_insn \"extlh\"\n+(define_insn \"extqh_be\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(ashift:DI\n+\t  (match_operand:DI 1 \"reg_or_0_operand\" \"rJ\")\n+\t  (ashift:DI\n+\t    (and:DI\n+\t      (plus:DI (match_operand:DI 2 \"reg_or_8bit_operand\" \"rI\")\n+\t\t       (const_int 1))\n+\t      (const_int 7))\n+\t    (const_int 3))))]\n+  \"WORDS_BIG_ENDIAN\"\n+  \"extqh %r1,%2,%0\"\n+  [(set_attr \"type\" \"shift\")])\n+\n+(define_insn \"extlh_le\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(ashift:DI\n \t (and:DI (match_operand:DI 1 \"reg_or_0_operand\" \"rJ\")\n@@ -1761,11 +1972,28 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi\"\n \t\t      (match_operand:DI 2 \"reg_or_8bit_operand\" \"rI\")\n \t\t      (const_int 7))\n \t\t     (const_int 3)))))]\n-  \"\"\n+  \"! WORDS_BIG_ENDIAN\"\n+  \"extlh %r1,%2,%0\"\n+  [(set_attr \"type\" \"shift\")])\n+\n+(define_insn \"extlh_be\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(and:DI\n+\t  (ashift:DI\n+\t    (match_operand:DI 1 \"reg_or_0_operand\" \"rJ\")\n+\t    (ashift:DI\n+\t      (and:DI\n+\t\t(plus:DI\n+\t\t  (match_operand:DI 2 \"reg_or_8bit_operand\" \"rI\")\n+\t\t  (const_int 1))\n+\t\t(const_int 7))\n+\t      (const_int 3)))\n+\t  (const_int 2147483647)))]\n+  \"WORDS_BIG_ENDIAN\"\n   \"extlh %r1,%2,%0\"\n   [(set_attr \"type\" \"shift\")])\n \n-(define_insn \"extwh\"\n+(define_insn \"extwh_le\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(ashift:DI\n \t (and:DI (match_operand:DI 1 \"reg_or_0_operand\" \"rJ\")\n@@ -1776,7 +2004,23 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi\"\n \t\t      (match_operand:DI 2 \"reg_or_8bit_operand\" \"rI\")\n \t\t      (const_int 7))\n \t\t     (const_int 3)))))]\n-  \"\"\n+  \"! WORDS_BIG_ENDIAN\"\n+  \"extwh %r1,%2,%0\"\n+  [(set_attr \"type\" \"shift\")])\n+\n+(define_insn \"extwh_be\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(and:DI\n+\t  (ashift:DI (match_operand:DI 1 \"reg_or_0_operand\" \"rJ\")\n+\t\t     (ashift:DI\n+\t\t       (and:DI\n+\t\t\t (plus:DI\n+\t\t\t   (match_operand:DI 2 \"reg_or_8bit_operand\" \"rI\")\n+\t\t\t   (const_int 1))\n+\t\t\t (const_int 7))\n+\t\t       (const_int 3)))\n+\t  (const_int 65535)))]\n+  \"WORDS_BIG_ENDIAN\"\n   \"extwh %r1,%2,%0\"\n   [(set_attr \"type\" \"shift\")])\n \n@@ -1830,39 +2074,79 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi\"\n   \"insll %1,%s2,%0\"\n   [(set_attr \"type\" \"shift\")])\n \n-(define_insn \"insbl\"\n+(define_insn \"insbl_le\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(ashift:DI (zero_extend:DI (match_operand:QI 1 \"register_operand\" \"r\"))\n \t\t   (ashift:DI (match_operand:DI 2 \"reg_or_8bit_operand\" \"rI\")\n \t\t\t      (const_int 3))))]\n-  \"\"\n+  \"! WORDS_BIG_ENDIAN\"\n+  \"insbl %1,%2,%0\"\n+  [(set_attr \"type\" \"shift\")])\n+\n+(define_insn \"insbl_be\"\n+ [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+       (ashift:DI (zero_extend:DI (match_operand:QI 1 \"register_operand\" \"r\"))\n+\t (minus:DI (const_int 56)\n+\t   (ashift:DI (match_operand:DI 2 \"reg_or_8bit_operand\" \"rI\")\n+\t\t      (const_int 3)))))]\n+  \"WORDS_BIG_ENDIAN\"\n   \"insbl %1,%2,%0\"\n   [(set_attr \"type\" \"shift\")])\n \n-(define_insn \"inswl\"\n+(define_insn \"inswl_le\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(ashift:DI (zero_extend:DI (match_operand:HI 1 \"register_operand\" \"r\"))\n \t\t   (ashift:DI (match_operand:DI 2 \"reg_or_8bit_operand\" \"rI\")\n \t\t\t      (const_int 3))))]\n-  \"\"\n+  \"! WORDS_BIG_ENDIAN\"\n   \"inswl %1,%2,%0\"\n   [(set_attr \"type\" \"shift\")])\n \n-(define_insn \"insll\"\n+(define_insn \"inswl_be\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(ashift:DI (zero_extend:DI (match_operand:HI 1 \"register_operand\" \"r\"))\n+\t  (minus:DI (const_int 56)\n+\t    (ashift:DI (match_operand:DI 2 \"reg_or_8bit_operand\" \"rI\")\n+\t\t       (const_int 3)))))]\n+  \"WORDS_BIG_ENDIAN\"\n+  \"inswl %1,%2,%0\"\n+  [(set_attr \"type\" \"shift\")])\n+\n+(define_insn \"insll_le\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(ashift:DI (zero_extend:DI (match_operand:SI 1 \"register_operand\" \"r\"))\n \t\t   (ashift:DI (match_operand:DI 2 \"reg_or_8bit_operand\" \"rI\")\n \t\t\t      (const_int 3))))]\n-  \"\"\n+  \"! WORDS_BIG_ENDIAN\"\n   \"insll %1,%2,%0\"\n   [(set_attr \"type\" \"shift\")])\n \n-(define_insn \"insql\"\n+(define_insn \"insll_be\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(ashift:DI (zero_extend:DI (match_operand:SI 1 \"register_operand\" \"r\"))\n+\t  (minus:DI (const_int 56)\n+\t    (ashift:DI (match_operand:DI 2 \"reg_or_8bit_operand\" \"rI\")\n+\t\t       (const_int 3)))))]\n+  \"WORDS_BIG_ENDIAN\"\n+  \"insll %1,%2,%0\"\n+  [(set_attr \"type\" \"shift\")])\n+\n+(define_insn \"insql_le\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(ashift:DI (match_operand:DI 1 \"register_operand\" \"r\")\n \t\t   (ashift:DI (match_operand:DI 2 \"reg_or_8bit_operand\" \"rI\")\n \t\t\t      (const_int 3))))]\n-  \"\"\n+  \"! WORDS_BIG_ENDIAN\"\n+  \"insql %1,%2,%0\"\n+  [(set_attr \"type\" \"shift\")])\n+\n+(define_insn \"insql_be\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(ashift:DI (match_operand:DI 1 \"register_operand\" \"r\")\n+\t  (minus:DI (const_int 56)\n+\t    (ashift:DI (match_operand:DI 2 \"reg_or_8bit_operand\" \"rI\")\n+\t\t       (const_int 3)))))]\n+  \"WORDS_BIG_ENDIAN\"\n   \"insql %1,%2,%0\"\n   [(set_attr \"type\" \"shift\")])\n \n@@ -1913,15 +2197,28 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi\"\n   \"ins%M2h %1,%3,%0\"\n   [(set_attr \"type\" \"shift\")])\n \n-(define_insn \"mskxl\"\n+(define_insn \"mskxl_le\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(and:DI (not:DI (ashift:DI\n \t\t\t (match_operand:DI 2 \"mode_mask_operand\" \"n\")\n \t\t\t (ashift:DI\n \t\t\t  (match_operand:DI 3 \"reg_or_8bit_operand\" \"rI\")\n \t\t\t  (const_int 3))))\n \t\t(match_operand:DI 1 \"reg_or_0_operand\" \"rJ\")))]\n-  \"\"\n+  \"! WORDS_BIG_ENDIAN\"\n+  \"msk%U2l %r1,%3,%0\"\n+  [(set_attr \"type\" \"shift\")])\n+\n+(define_insn \"mskxl_be\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(and:DI (not:DI (ashift:DI\n+\t\t\t  (match_operand:DI 2 \"mode_mask_operand\" \"n\")\n+\t\t\t  (minus:DI (const_int 56)\n+\t\t\t    (ashift:DI\n+\t\t\t      (match_operand:DI 3 \"reg_or_8bit_operand\" \"rI\")\n+\t\t\t      (const_int 3)))))\n+\t\t(match_operand:DI 1 \"reg_or_0_operand\" \"rJ\")))]\n+  \"WORDS_BIG_ENDIAN\"\n   \"msk%U2l %r1,%3,%0\"\n   [(set_attr \"type\" \"shift\")])\n \n@@ -2328,6 +2625,9 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi\"\n     operands[1] = force_reg (SFmode, operands[1]);\n })\n \n+;; The Unicos/Mk assembler doesn't support cvtst, but we've already\n+;; asserted that alpha_fptm == ALPHA_FPTM_N.\n+\n (define_insn \"*extendsfdf2_ieee\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=&f\")\n \t(float_extend:DF (match_operand:SF 1 \"register_operand\" \"f\")))]\n@@ -2341,7 +2641,7 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi\"\n \t(float_extend:DF (match_operand:SF 1 \"nonimmediate_operand\" \"f,m,f\")))]\n   \"TARGET_FP && alpha_fptm < ALPHA_FPTM_SU\"\n   \"@\n-   fmov %1,%0\n+   cpys %1,%1,%0\n    ld%, %0,%1\n    st%- %1,%0\"\n   [(set_attr \"type\" \"fcpys,fld,fst\")])\n@@ -4164,6 +4464,16 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi\"\n ;; Here are the CALL and unconditional branch insns.  Calls on NT and OSF\n ;; work differently, so we have different patterns for each.\n \n+;; On Unicos/Mk a call information word (CIW) must be generated for each\n+;; call. The CIW contains information about arguments passed in registers\n+;; and is stored in the caller's SSIB. Its offset relative to the beginning\n+;; of the SSIB is passed in $25. Handling this properly is quite complicated\n+;; in the presence of inlining since the CIWs for calls performed by the\n+;; inlined function must be stored in the SSIB of the function it is inlined\n+;; into as well. We encode the CIW in an unspec and append it to the list\n+;; of the CIWs for the current function only when the instruction for loading\n+;; $25 is generated.\n+\n (define_expand \"call\"\n   [(use (match_operand:DI 0 \"\" \"\"))\n    (use (match_operand 1 \"\" \"\"))\n@@ -4175,6 +4485,8 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi\"\n     emit_call_insn (gen_call_nt (operands[0], operands[1]));\n   else if (TARGET_ABI_OPEN_VMS)\n     emit_call_insn (gen_call_vms (operands[0], operands[2]));\n+  else if (TARGET_ABI_UNICOSMK)\n+    emit_call_insn (gen_call_umk (operands[0], operands[2]));\n   else\n     emit_call_insn (gen_call_osf (operands[0], operands[1]));\n   DONE;\n@@ -4225,6 +4537,30 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi\"\n     operands[0] = force_reg (DImode, operands[0]);\n })\n \n+;; Calls on Unicos/Mk are always indirect.\n+;; op 0: symbol ref for called function\n+;; op 1: CIW for $25 represented by an unspec\n+\n+(define_expand \"call_umk\"\n+   [(parallel [(call (mem:DI (match_operand 0 \"\" \"\"))\n+\t\t     (match_operand 1 \"\" \"\"))\n+\t       (use (reg:DI 25))\n+\t       (clobber (reg:DI 26))])]\n+   \"\"\n+{\n+  if (GET_CODE (operands[0]) != MEM)\n+    abort ();\n+\n+  /* Always load the address of the called function into a register;\n+     load the CIW in $25.  */\n+\n+  operands[0] = XEXP (operands[0], 0);\n+  if (GET_CODE (operands[0]) != REG)\n+    operands[0] = force_reg (DImode, operands[0]);\n+\n+  emit_move_insn (gen_rtx_REG (DImode, 25), operands[1]);\n+})\n+\n ;;\n ;; call openvms/alpha\n ;; op 0: symbol ref for called function\n@@ -4279,6 +4615,9 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi\"\n   else if (TARGET_ABI_OPEN_VMS)\n     emit_call_insn (gen_call_value_vms (operands[0], operands[1],\n \t\t\t\t\toperands[3]));\n+  else if (TARGET_ABI_UNICOSMK)\n+    emit_call_insn (gen_call_value_umk (operands[0], operands[1],\n+\t\t\t\t\toperands[3]));\n   else\n     emit_call_insn (gen_call_value_osf (operands[0], operands[1],\n \t\t\t\t\toperands[2]));\n@@ -4369,6 +4708,24 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi\"\n     }\n })\n \n+(define_expand \"call_value_umk\"\n+  [(parallel [(set (match_operand 0 \"\" \"\")\n+\t\t   (call (mem:DI (match_operand 1 \"\" \"\"))\n+\t\t\t (match_operand 2 \"\" \"\")))\n+\t      (use (reg:DI 25))\n+\t      (clobber (reg:DI 26))])]\n+  \"\"\n+{\n+  if (GET_CODE (operands[1]) != MEM)\n+    abort ();\n+\n+  operands[1] = XEXP (operands[1], 0);\n+  if (GET_CODE (operands[1]) != REG)\n+    operands[1] = force_reg (DImode, operands[1]);\n+\n+  emit_move_insn (gen_rtx_REG (DImode, 25), operands[2]);\n+})\n+\n (define_insn \"*call_osf_1_er_noreturn\"\n   [(call (mem:DI (match_operand:DI 0 \"call_operand\" \"c,R,i\"))\n \t (match_operand 1 \"\" \"\"))\n@@ -4455,6 +4812,15 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi\"\n   [(set_attr \"type\" \"jsr\")\n    (set_attr \"length\" \"12,16\")])\n \n+(define_insn \"*call_umk_1\"\n+  [(call (mem:DI (match_operand:DI 0 \"call_operand\" \"r\"))\n+\t (match_operand 1 \"\" \"\"))\n+   (use (reg:DI 25))\n+   (clobber (reg:DI 26))]\n+  \"TARGET_ABI_UNICOSMK\"\n+  \"jsr $26,(%0)\"\n+  [(set_attr \"type\" \"jsr\")])\n+\n ;; Call subroutine returning any type.\n \n (define_expand \"untyped_call\"\n@@ -4517,58 +4883,30 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi\"\n   [(set_attr \"type\" \"ibr\")])\n \n (define_expand \"tablejump\"\n-  [(use (match_operand:SI 0 \"register_operand\" \"\"))\n-   (use (match_operand:SI 1 \"\" \"\"))]\n+  [(parallel [(set (pc)\n+\t\t   (match_operand 0 \"register_operand\" \"\"))\n+\t      (use (label_ref:DI (match_operand 1 \"\" \"\")))])]\n   \"\"\n {\n   if (TARGET_ABI_WINDOWS_NT)\n-    emit_jump_insn (gen_tablejump_nt (operands[0], operands[1]));\n-  else if (TARGET_ABI_OPEN_VMS)\n-    emit_jump_insn (gen_tablejump_vms (operands[0], operands[1]));\n-  else\n-    emit_jump_insn (gen_tablejump_osf (operands[0], operands[1]));\n-\n-  DONE;\n+    {\n+      rtx dest = gen_reg_rtx (DImode);\n+      emit_insn (gen_extendsidi2 (dest, operands[0]));\n+      operands[0] = dest;\n+    }\n+  else if (TARGET_ABI_OSF)\n+    {\n+      rtx dest = gen_reg_rtx (DImode);\n+      emit_insn (gen_extendsidi2 (dest, operands[0]));\n+      emit_insn (gen_adddi3 (dest, gen_rtx_REG (DImode, 29), dest));\t\n+      operands[0] = dest;\n+    }\n })\n \n-(define_expand \"tablejump_osf\"\n-  [(set (match_dup 3)\n-\t(sign_extend:DI (match_operand:SI 0 \"register_operand\" \"\")))\n-   (set (match_dup 3)\n-\t(plus:DI (reg:DI 29) (match_dup 3)))\n-   (parallel [(set (pc)\n-\t\t   (match_dup 3))\n-\t      (use (label_ref (match_operand 1 \"\" \"\")))])]\n-  \"\"\n-  { operands[3] = gen_reg_rtx (DImode); })\n-\n-(define_expand \"tablejump_nt\"\n-  [(set (match_dup 3)\n-\t(sign_extend:DI (match_operand:SI 0 \"register_operand\" \"\")))\n-   (parallel [(set (pc)\n-\t\t   (match_dup 3))\n-\t      (use (label_ref (match_operand 1 \"\" \"\")))])]\n-  \"\"\n-  { operands[3] = gen_reg_rtx (DImode); })\n-\n-;;\n-;; tablejump, openVMS way\n-;; op 0: offset\n-;; op 1: label preceding jump-table\n-;;\n-(define_expand \"tablejump_vms\"\n-  [(set (match_dup 2)\n-      (match_operand:DI 0 \"register_operand\" \"\"))\n-        (set (pc)\n-\t(plus:DI (match_dup 2)\n-\t\t(label_ref (match_operand 1 \"\" \"\"))))]\n-  \"\"\n-  { operands[2] = gen_reg_rtx (DImode); })\n-\n (define_insn \"*tablejump_osf_nt_internal\"\n   [(set (pc)\n \t(match_operand:DI 0 \"register_operand\" \"r\"))\n-   (use (label_ref (match_operand 1 \"\" \"\")))]\n+   (use (label_ref:DI (match_operand 1 \"\" \"\")))]\n   \"(TARGET_ABI_OSF || TARGET_ABI_WINDOWS_NT)\n    && alpha_tablejump_addr_vec (insn)\"\n {\n@@ -4577,16 +4915,11 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi\"\n }\n   [(set_attr \"type\" \"ibr\")])\n \n-;;\n-;; op 0 is table offset\n-;; op 1 is table label\n-;;\n-\n-(define_insn \"*tablejump_vms_internal\"\n+(define_insn \"*tablejump_internal\"\n   [(set (pc)\n-\t(plus (match_operand:DI 0 \"register_operand\" \"r\")\n-\t      (label_ref (match_operand 1 \"\" \"\"))))]\n-  \"TARGET_ABI_OPEN_VMS\"\n+\t(match_operand:DI 0 \"register_operand\" \"r\"))\n+   (use (label_ref (match_operand 1 \"\" \"\")))]\n+  \"\"\n   \"jmp $31,(%0),0\"\n   [(set_attr \"type\" \"ibr\")])\n \n@@ -4613,9 +4946,9 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi\"\n    && (register_operand (operands[0], SFmode)\n        || reg_or_fp0_operand (operands[1], SFmode))\"\n   \"@\n-   fmov %R1,%0\n+   cpys %R1,%R1,%0\n    ld%, %0,%1\n-   mov %r1,%0\n+   bis $31,%r1,%0\n    ldl %0,%1\n    st%, %R1,%0\n    stl %r1,%0\"\n@@ -4628,9 +4961,9 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi\"\n    && (register_operand (operands[0], SFmode)\n        || reg_or_fp0_operand (operands[1], SFmode))\"\n   \"@\n-   fmov %R1,%0\n+   cpys %R1,%R1,%0\n    ld%, %0,%1\n-   mov %r1,%0\n+   bis $31,%r1,%0\n    ldl %0,%1\n    st%, %R1,%0\n    stl %r1,%0\n@@ -4645,7 +4978,7 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi\"\n    && (register_operand (operands[0], SFmode)\n        || reg_or_fp0_operand (operands[1], SFmode))\"\n   \"@\n-   mov %r1,%0\n+   bis $31,%r1,%0\n    ldl %0,%1\n    stl %r1,%0\"\n   [(set_attr \"type\" \"ilog,ild,ist\")])\n@@ -4657,9 +4990,9 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi\"\n    && (register_operand (operands[0], DFmode)\n        || reg_or_fp0_operand (operands[1], DFmode))\"\n   \"@\n-   fmov %R1,%0\n+   cpys %R1,%R1,%0\n    ld%- %0,%1\n-   mov %r1,%0\n+   bis $31,%r1,%0\n    ldq %0,%1\n    st%- %R1,%0\n    stq %r1,%0\"\n@@ -4672,9 +5005,9 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi\"\n    && (register_operand (operands[0], DFmode)\n        || reg_or_fp0_operand (operands[1], DFmode))\"\n   \"@\n-   fmov %R1,%0\n+   cpys %R1,%R1,%0\n    ld%- %0,%1\n-   mov %r1,%0\n+   bis $31,%r1,%0\n    ldq %0,%1\n    st%- %R1,%0\n    stq %r1,%0\n@@ -4689,7 +5022,7 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi\"\n    && (register_operand (operands[0], DFmode)\n        || reg_or_fp0_operand (operands[1], DFmode))\"\n   \"@\n-   mov %r1,%0\n+   bis $31,%r1,%0\n    ldq %0,%1\n    stq %r1,%0\"\n   [(set_attr \"type\" \"ilog,ild,ist\")])\n@@ -4749,16 +5082,16 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi\"\n (define_insn \"*movsi_nofix\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r,r,r,r,m,*f,*f,m\")\n \t(match_operand:SI 1 \"input_operand\" \"rJ,K,L,m,rJ,*fJ,m,*f\"))]\n-  \"TARGET_ABI_OSF && ! TARGET_FIX\n+  \"(TARGET_ABI_OSF || TARGET_ABI_UNICOSMK) && ! TARGET_FIX\n    && (register_operand (operands[0], SImode)\n        || reg_or_0_operand (operands[1], SImode))\"\n   \"@\n-   mov %r1,%0\n+   bis $31,%r1,%0\n    lda %0,%1($31)\n    ldah %0,%h1($31)\n    ldl %0,%1\n    stl %r1,%0\n-   fmov %R1,%0\n+   cpys %R1,%R1,%0\n    ld%, %0,%1\n    st%, %R1,%0\"\n   [(set_attr \"type\" \"ilog,iadd,iadd,ild,ist,fcpys,fld,fst\")])\n@@ -4770,12 +5103,12 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi\"\n    && (register_operand (operands[0], SImode)\n        || reg_or_0_operand (operands[1], SImode))\"\n   \"@\n-   mov %r1,%0\n+   bis $31,%r1,%0\n    lda %0,%1($31)\n    ldah %0,%h1($31)\n    ldl %0,%1\n    stl %r1,%0\n-   fmov %R1,%0\n+   cpys %R1,%R1,%0\n    ld%, %0,%1\n    st%, %R1,%0\n    ftois %1,%0\n@@ -4789,13 +5122,13 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi\"\n     && (register_operand (operands[0], SImode)\n         || reg_or_0_operand (operands[1], SImode))\"\n   \"@\n-   mov %1,%0\n+   bis $31,%1,%0\n    lda %0,%1\n    ldah %0,%h1\n    lda %0,%1\n    ldl %0,%1\n    stl %r1,%0\n-   fmov %R1,%0\n+   cpys %R1,%R1,%0\n    ld%, %0,%1\n    st%, %R1,%0\"\n   [(set_attr \"type\" \"ilog,iadd,iadd,ldsym,ild,ist,fcpys,fld,fst\")])\n@@ -4807,7 +5140,7 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi\"\n    && (register_operand (operands[0], HImode)\n        || register_operand (operands[1], HImode))\"\n   \"@\n-   mov %r1,%0\n+   bis $31,%r1,%0\n    lda %0,%L1($31)\"\n   [(set_attr \"type\" \"ilog,iadd\")])\n \n@@ -4818,7 +5151,7 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi\"\n    && (register_operand (operands[0], HImode)\n        || reg_or_0_operand (operands[1], HImode))\"\n   \"@\n-   mov %r1,%0\n+   bis $31,%r1,%0\n    lda %0,%L1($31)\n    ldwu %0,%1\n    stw %r1,%0\"\n@@ -4831,7 +5164,7 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi\"\n    && (register_operand (operands[0], QImode)\n        || register_operand (operands[1], QImode))\"\n   \"@\n-   mov %r1,%0\n+   bis $31,%r1,%0\n    lda %0,%L1($31)\"\n   [(set_attr \"type\" \"ilog,iadd\")])\n \n@@ -4842,7 +5175,7 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi\"\n    && (register_operand (operands[0], QImode)\n        || reg_or_0_operand (operands[1], QImode))\"\n   \"@\n-   mov %r1,%0\n+   bis $31,%r1,%0\n    lda %0,%L1($31)\n    ldbu %0,%1\n    stb %r1,%0\"\n@@ -4879,6 +5212,87 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi\"\n     FAIL;\n })\n \n+;; Split the load of an address into a four-insn sequence on Unicos/Mk.\n+;; Always generate a REG_EQUAL note for the last instruction to facilitate\n+;; optimisations. If the symbolic operand is a label_ref, generate REG_LABEL\n+;; notes and update LABEL_NUSES because this is not done automatically.\n+;; Labels may be incorrectly deleted if we don't do this.\n+;;\n+;; Describing what the individual instructions do correctly is too complicated\n+;; so use UNSPECs for each of the three parts of an address.\n+\n+(define_split\n+  [(set (match_operand:DI 0 \"register_operand\" \"\")\n+\t(match_operand:DI 1 \"symbolic_operand\" \"\"))]\n+  \"TARGET_ABI_UNICOSMK && reload_completed\"\n+  [(const_int 0)]\n+{\n+  rtx insn1, insn2, insn3;\n+\n+  insn1 = emit_insn (gen_umk_laum (operands[0], operands[1]));\n+  emit_insn (gen_ashldi3 (operands[0], operands[0], GEN_INT (32)));\n+  insn2 = emit_insn (gen_umk_lalm (operands[0], operands[0], operands[1]));\n+  insn3 = emit_insn (gen_umk_lal (operands[0], operands[0], operands[1]));\n+  REG_NOTES (insn3) = gen_rtx_EXPR_LIST (REG_EQUAL, operands[1],\n+\t\t\t\t\t REG_NOTES (insn3));\n+  if (GET_CODE (operands[1]) == LABEL_REF)\n+    {\n+      rtx label;\n+\n+      label = XEXP (operands[1], 0);\n+      REG_NOTES (insn1) = gen_rtx_EXPR_LIST (REG_LABEL, label,\n+\t\t\t\t\t     REG_NOTES (insn1));\n+      REG_NOTES (insn2) = gen_rtx_EXPR_LIST (REG_LABEL, label,\n+\t\t\t\t\t     REG_NOTES (insn2));\n+      REG_NOTES (insn3) = gen_rtx_EXPR_LIST (REG_LABEL, label,\n+\t\t\t\t\t     REG_NOTES (insn3));\n+      LABEL_NUSES (label) += 3;\n+    }\n+  DONE;\n+})\n+\n+;; Instructions for loading the three parts of an address on Unicos/Mk.\n+\n+(define_insn \"umk_laum\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(unspec:DI [(match_operand:DI 1 \"symbolic_operand\" \"\")]\n+\t\t   UNSPEC_UMK_LAUM))]\n+  \"TARGET_ABI_UNICOSMK\"\n+  \"laum %r0,%t1($31)\"\n+  [(set_attr \"type\" \"iadd\")])\n+\n+(define_insn \"umk_lalm\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(plus:DI (match_operand:DI 1 \"register_operand\" \"r\")\n+\t\t (unspec:DI [(match_operand:DI 2 \"symbolic_operand\" \"\")]\n+\t\t\t    UNSPEC_UMK_LALM)))] \n+  \"TARGET_ABI_UNICOSMK\"\n+  \"lalm %r0,%t2(%r1)\"\n+  [(set_attr \"type\" \"iadd\")])\n+\n+(define_insn \"umk_lal\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(plus:DI (match_operand:DI 1 \"register_operand\" \"r\")\n+\t\t (unspec:DI [(match_operand:DI 2 \"symbolic_operand\" \"\")]\n+\t\t\t    UNSPEC_UMK_LAL)))]\n+  \"TARGET_ABI_UNICOSMK\"\n+  \"lal %r0,%t2(%r1)\"\n+  [(set_attr \"type\" \"iadd\")])\n+\n+;; Add a new call information word to the current function's list of CIWs\n+;; and load its index into $25. Doing it here ensures that the CIW will be\n+;; associated with the correct function even in the presence of inlining.\n+\n+(define_insn \"*umk_load_ciw\"\n+  [(set (reg:DI 25)\n+\t(unspec:DI [(match_operand 0 \"\" \"\")] UNSPEC_UMK_LOAD_CIW))]\n+  \"TARGET_ABI_UNICOSMK\"\n+{\n+  operands[0] = unicosmk_add_call_info_word (operands[0]);\n+  return \"lda $25,%0\";\n+}\n+  [(set_attr \"type\" \"iadd\")])\n+\n (define_insn \"*movdi_er_low\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(lo_sum:DI (match_operand:DI 1 \"register_operand\" \"r\")\n@@ -4906,23 +5320,29 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi\"\n    stt %R1,%0\"\n   [(set_attr \"type\" \"ilog,iadd,iadd,iadd,ldsym,ild,ist,fcpys,fld,fst\")])\n \n+;; The 'U' constraint matches symbolic operands on Unicos/Mk. Those should\n+;; have been split up by the rules above but we shouldn't reject the\n+;; possibility of them getting through.\n+\n (define_insn \"*movdi_nofix\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,r,r,r,r,m,*f,*f,Q\")\n-\t(match_operand:DI 1 \"input_operand\" \"rJ,K,L,s,m,rJ,*fJ,Q,*f\"))]\n-  \"! TARGET_EXPLICIT_RELOCS && ! TARGET_FIX\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,r,r,r,r,r,m,*f,*f,Q\")\n+\t(match_operand:DI 1 \"input_operand\" \"rJ,K,L,U,s,m,rJ,*fJ,Q,*f\"))]\n+  \"! TARGET_FIX\n    && (register_operand (operands[0], DImode)\n        || reg_or_0_operand (operands[1], DImode))\"\n   \"@\n-   mov %r1,%0\n+   bis $31,%r1,%0\n    lda %0,%1($31)\n    ldah %0,%h1($31)\n+   laum %0,%t1($31)\\;sll %0,32,%0\\;lalm %0,%t1(%0)\\;lal %0,%t1(%0)\n    lda %0,%1\n    ldq%A1 %0,%1\n    stq%A0 %r1,%0\n-   fmov %R1,%0\n+   cpys %R1,%R1,%0\n    ldt %0,%1\n    stt %R1,%0\"\n-  [(set_attr \"type\" \"ilog,iadd,iadd,ldsym,ild,ist,fcpys,fld,fst\")])\n+  [(set_attr \"type\" \"ilog,iadd,iadd,ldsym,ldsym,ild,ist,fcpys,fld,fst\")\n+   (set_attr \"length\" \"*,*,*,16,*,*,*,*,*,*\")])\n \n (define_insn \"*movdi_er_fix\"\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,r,r,r,r,r,m,*f,*f,Q,r,*f\")\n@@ -4953,13 +5373,13 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi\"\n    && (register_operand (operands[0], DImode)\n        || reg_or_0_operand (operands[1], DImode))\"\n   \"@\n-   mov %r1,%0\n+   bis $31,%r1,%0\n    lda %0,%1($31)\n    ldah %0,%h1($31)\n    lda %0,%1\n    ldq%A1 %0,%1\n    stq%A0 %r1,%0\n-   fmov %R1,%0\n+   cpys %R1,%R1,%0\n    ldt %0,%1\n    stt %R1,%0\n    ftoit %1,%0\n@@ -5041,12 +5461,29 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi\"\n   \"\")\n \n ;; Similar for unaligned loads, where we use the sequence from the\n-;; Alpha Architecture manual.\n+;; Alpha Architecture manual. We have to distinguish between little-endian\n+;; and big-endian systems as the sequences are different.\n ;;\n ;; Operand 1 is the address.  Operands 2 and 3 are temporaries, where\n ;; operand 3 can overlap the input and output registers.\n \n (define_expand \"unaligned_loadqi\"\n+  [(use (match_operand:QI 0 \"register_operand\" \"\"))\n+   (use (match_operand:DI 1 \"address_operand\" \"\"))\n+   (use (match_operand:DI 2 \"register_operand\" \"\"))\n+   (use (match_operand:DI 3 \"register_operand\" \"\"))]\n+  \"\"\n+{\n+  if (WORDS_BIG_ENDIAN)\n+    emit_insn (gen_unaligned_loadqi_be (operands[0], operands[1],\n+\t\t\t\t\toperands[2], operands[3]));\n+  else\n+    emit_insn (gen_unaligned_loadqi_le (operands[0], operands[1],\n+\t\t\t\t\toperands[2], operands[3]));\n+  DONE;\n+})\n+\n+(define_expand \"unaligned_loadqi_le\"\n   [(set (match_operand:DI 2 \"register_operand\" \"\")\n \t(mem:DI (and:DI (match_operand:DI 1 \"address_operand\" \"\")\n \t\t\t(const_int -8))))\n@@ -5056,10 +5493,41 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi\"\n \t(zero_extract:DI (match_dup 2)\n \t\t\t (const_int 8)\n \t\t\t (ashift:DI (match_dup 3) (const_int 3))))]\n-  \"\"\n+  \"! WORDS_BIG_ENDIAN\"\n+  \"\")\n+\n+(define_expand \"unaligned_loadqi_be\"\n+  [(set (match_operand:DI 2 \"register_operand\" \"\")\n+\t(mem:DI (and:DI (match_operand:DI 1 \"address_operand\" \"\")\n+\t\t\t(const_int -8))))\n+   (set (match_operand:DI 3 \"register_operand\" \"\")\n+\t(match_dup 1))\n+   (set (subreg:DI (match_operand:QI 0 \"register_operand\" \"\") 0)\n+\t(zero_extract:DI (match_dup 2)\n+\t\t\t (const_int 8)\n+\t\t\t (minus:DI\n+\t\t\t   (const_int 56)\n+\t\t\t   (ashift:DI (match_dup 3) (const_int 3)))))]\n+  \"WORDS_BIG_ENDIAN\"\n   \"\")\n \n (define_expand \"unaligned_loadhi\"\n+  [(use (match_operand:QI 0 \"register_operand\" \"\"))\n+   (use (match_operand:DI 1 \"address_operand\" \"\"))\n+   (use (match_operand:DI 2 \"register_operand\" \"\"))\n+   (use (match_operand:DI 3 \"register_operand\" \"\"))]\n+  \"\"\n+{\n+  if (WORDS_BIG_ENDIAN)\n+    emit_insn (gen_unaligned_loadhi_be (operands[0], operands[1],\n+\t\t\t\t\toperands[2], operands[3]));\n+  else\n+    emit_insn (gen_unaligned_loadhi_le (operands[0], operands[1],\n+\t\t\t\t\toperands[2], operands[3]));\n+  DONE;\n+})\n+\n+(define_expand \"unaligned_loadhi_le\"\n   [(set (match_operand:DI 2 \"register_operand\" \"\")\n \t(mem:DI (and:DI (match_operand:DI 1 \"address_operand\" \"\")\n \t\t\t(const_int -8))))\n@@ -5069,7 +5537,22 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi\"\n \t(zero_extract:DI (match_dup 2)\n \t\t\t (const_int 16)\n \t\t\t (ashift:DI (match_dup 3) (const_int 3))))]\n-  \"\"\n+  \"! WORDS_BIG_ENDIAN\"\n+  \"\")\n+\n+(define_expand \"unaligned_loadhi_be\"\n+  [(set (match_operand:DI 2 \"register_operand\" \"\")\n+\t(mem:DI (and:DI (match_operand:DI 1 \"address_operand\" \"\")\n+\t\t\t(const_int -8))))\n+   (set (match_operand:DI 3 \"register_operand\" \"\")\n+\t(plus:DI (match_dup 1) (const_int 1)))\n+   (set (subreg:DI (match_operand:QI 0 \"register_operand\" \"\") 0)\n+\t(zero_extract:DI (match_dup 2)\n+\t\t\t (const_int 16)\n+\t\t\t (minus:DI\n+\t\t\t   (const_int 56)\n+\t\t\t   (ashift:DI (match_dup 3) (const_int 3)))))]\n+  \"WORDS_BIG_ENDIAN\"\n   \"\")\n \n ;; Storing an aligned byte or word requires two temporaries.  Operand 0 is the\n@@ -5102,6 +5585,25 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi\"\n ;; operand 2 can be that register.\n \n (define_expand \"unaligned_storeqi\"\n+  [(use (match_operand:DI 0 \"address_operand\" \"\"))\n+   (use (match_operand:QI 1 \"register_operand\" \"\"))\n+   (use (match_operand:DI 2 \"register_operand\" \"\"))\n+   (use (match_operand:DI 3 \"register_operand\" \"\"))\n+   (use (match_operand:DI 4 \"register_operand\" \"\"))]\n+  \"\"\n+{\n+  if (WORDS_BIG_ENDIAN)\n+    emit_insn (gen_unaligned_storeqi_be (operands[0], operands[1],\n+\t\t\t\t\t operands[2], operands[3],\n+\t\t\t\t\t operands[4]));\n+  else\n+    emit_insn (gen_unaligned_storeqi_le (operands[0], operands[1],\n+\t\t\t\t\t operands[2], operands[3],\n+\t\t\t\t\t operands[4]));\n+  DONE;\n+})\n+\n+(define_expand \"unaligned_storeqi_le\"\n   [(set (match_operand:DI 3 \"register_operand\" \"\")\n \t(mem:DI (and:DI (match_operand:DI 0 \"address_operand\" \"\")\n \t\t\t(const_int -8))))\n@@ -5117,10 +5619,50 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi\"\n    (set (match_dup 4) (ior:DI (match_dup 4) (match_dup 3)))\n    (set (mem:DI (and:DI (match_dup 0) (const_int -8)))\n \t(match_dup 4))]\n-  \"\"\n+  \"! WORDS_BIG_ENDIAN\"\n+  \"\")\n+\n+(define_expand \"unaligned_storeqi_be\"\n+  [(set (match_operand:DI 3 \"register_operand\" \"\")\n+\t(mem:DI (and:DI (match_operand:DI 0 \"address_operand\" \"\")\n+\t\t\t(const_int -8))))\n+   (set (match_operand:DI 2 \"register_operand\" \"\")\n+\t(match_dup 0))\n+   (set (match_dup 3)\n+\t(and:DI (not:DI (ashift:DI (const_int 255)\n+\t\t\t  (minus:DI (const_int 56)\n+\t\t\t\t    (ashift:DI (match_dup 2) (const_int 3)))))\n+\t\t(match_dup 3)))\n+   (set (match_operand:DI 4 \"register_operand\" \"\")\n+\t(ashift:DI (zero_extend:DI (match_operand:QI 1 \"register_operand\" \"\"))\n+\t\t   (minus:DI (const_int 56)\n+\t\t     (ashift:DI (match_dup 2) (const_int 3)))))\n+   (set (match_dup 4) (ior:DI (match_dup 4) (match_dup 3)))\n+   (set (mem:DI (and:DI (match_dup 0) (const_int -8)))\n+\t(match_dup 4))]\n+  \"WORDS_BIG_ENDIAN\"\n   \"\")\n \n (define_expand \"unaligned_storehi\"\n+  [(use (match_operand:DI 0 \"address_operand\" \"\"))\n+   (use (match_operand:HI 1 \"register_operand\" \"\"))\n+   (use (match_operand:DI 2 \"register_operand\" \"\"))\n+   (use (match_operand:DI 3 \"register_operand\" \"\"))\n+   (use (match_operand:DI 4 \"register_operand\" \"\"))]\n+  \"\"\n+{\n+  if (WORDS_BIG_ENDIAN)\n+    emit_insn (gen_unaligned_storehi_be (operands[0], operands[1],\n+\t\t\t\t\t operands[2], operands[3],\n+\t\t\t\t\t operands[4]));\n+  else\n+    emit_insn (gen_unaligned_storehi_le (operands[0], operands[1],\n+\t\t\t\t\t operands[2], operands[3],\n+\t\t\t\t\t operands[4]));\n+  DONE;\n+})\n+\n+(define_expand \"unaligned_storehi_le\"\n   [(set (match_operand:DI 3 \"register_operand\" \"\")\n \t(mem:DI (and:DI (match_operand:DI 0 \"address_operand\" \"\")\n \t\t\t(const_int -8))))\n@@ -5136,7 +5678,29 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi\"\n    (set (match_dup 4) (ior:DI (match_dup 4) (match_dup 3)))\n    (set (mem:DI (and:DI (match_dup 0) (const_int -8)))\n \t(match_dup 4))]\n-  \"\"\n+  \"! WORDS_BIG_ENDIAN\"\n+  \"\")\n+\n+(define_expand \"unaligned_storehi_be\"\n+  [(set (match_operand:DI 3 \"register_operand\" \"\")\n+\t(mem:DI (and:DI (match_operand:DI 0 \"address_operand\" \"\")\n+\t\t\t(const_int -8))))\n+   (set (match_operand:DI 2 \"register_operand\" \"\")\n+\t(plus:DI (match_dup 0) (const_int 1)))\n+   (set (match_dup 3)\n+\t(and:DI (not:DI (ashift:DI\n+\t\t\t  (const_int 65535)\n+\t\t\t  (minus:DI (const_int 56)\n+\t\t\t\t    (ashift:DI (match_dup 2) (const_int 3)))))\n+\t\t(match_dup 3)))\n+   (set (match_operand:DI 4 \"register_operand\" \"\")\n+\t(ashift:DI (zero_extend:DI (match_operand:HI 1 \"register_operand\" \"\"))\n+\t\t   (minus:DI (const_int 56)\n+\t\t\t     (ashift:DI (match_dup 2) (const_int 3)))))\n+   (set (match_dup 4) (ior:DI (match_dup 4) (match_dup 3)))\n+   (set (mem:DI (and:DI (match_dup 0) (const_int -8)))\n+\t(match_dup 4))]\n+  \"WORDS_BIG_ENDIAN\"\n   \"\")\n \f\n ;; Here are the define_expand's for QI and HI moves that use the above\n@@ -5356,6 +5920,7 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi\"\n {\n   rtx aligned_mem, bitnum;\n   get_aligned_mem (operands[1], &aligned_mem, &bitnum);\n+\n   emit_insn (gen_aligned_loadqi (operands[0], aligned_mem, bitnum,\n \t\t\t\t operands[2]));\n   DONE;\n@@ -5370,6 +5935,7 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi\"\n {\n   rtx aligned_mem, bitnum;\n   get_aligned_mem (operands[1], &aligned_mem, &bitnum);\n+\n   emit_insn (gen_aligned_loadhi (operands[0], aligned_mem, bitnum,\n \t\t\t\t operands[2]));\n   DONE;\n@@ -5414,6 +5980,8 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi\"\n \t\t\t (match_operand:DI 3 \"immediate_operand\" \"\")))]\n   \"\"\n {\n+  int ofs;\n+\n   /* We can do 16, 32 and 64 bit fields, if aligned on byte boundaries.  */\n   if (INTVAL (operands[3]) % 8 != 0\n       || (INTVAL (operands[2]) != 16\n@@ -5426,9 +5994,21 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi\"\n   if (GET_CODE (operands[1]) != MEM)\n     FAIL;\n \n+  /* The bit number is relative to the mode of operand 1 which is\n+     usually QImode (this might actually be a bug in expmed.c). Note \n+     that the bit number is negative in big-endian mode in this case.\n+     We have to convert that to the offset.  */\n+  if (WORDS_BIG_ENDIAN)\n+    ofs = GET_MODE_BITSIZE (GET_MODE (operands[1]))\n+          - INTVAL (operands[2]) - INTVAL (operands[3]);\n+  else\n+    ofs = INTVAL (operands[3]);\n+\n+  ofs = ofs / 8;\n+\n   alpha_expand_unaligned_load (operands[0], operands[1],\n \t\t\t       INTVAL (operands[2]) / 8,\n-\t\t\t       INTVAL (operands[3]) / 8, 1);\n+\t\t\t       ofs, 1);\n   DONE;\n })\n \n@@ -5449,13 +6029,27 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi\"\n \n   if (GET_CODE (operands[1]) == MEM)\n     {\n+      int ofs;\n+\n       /* Fail 8 bit fields, falling back on a simple byte load.  */\n       if (INTVAL (operands[2]) == 8)\n \tFAIL;\n \n+      /* The bit number is relative to the mode of operand 1 which is\n+\t usually QImode (this might actually be a bug in expmed.c). Note \n+\t that the bit number is negative in big-endian mode in this case.\n+\t We have to convert that to the offset.  */\n+      if (WORDS_BIG_ENDIAN)\n+\tofs = GET_MODE_BITSIZE (GET_MODE (operands[1]))\n+\t      - INTVAL (operands[2]) - INTVAL (operands[3]);\n+      else\n+\tofs = INTVAL (operands[3]);\n+\n+      ofs = ofs / 8;\n+\n       alpha_expand_unaligned_load (operands[0], operands[1],\n \t\t\t           INTVAL (operands[2]) / 8,\n-\t\t\t           INTVAL (operands[3]) / 8, 0);\n+\t\t\t\t   ofs, 0);\n       DONE;\n     }\n })\n@@ -5467,6 +6061,8 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi\"\n \t(match_operand:DI 3 \"register_operand\" \"\"))]\n   \"\"\n {\n+  int ofs;\n+\n   /* We can do 16, 32 and 64 bit fields, if aligned on byte boundaries.  */\n   if (INTVAL (operands[2]) % 8 != 0\n       || (INTVAL (operands[1]) != 16\n@@ -5479,9 +6075,20 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi\"\n   if (GET_CODE (operands[0]) != MEM)\n     FAIL;\n \n+  /* The bit number is relative to the mode of operand 1 which is\n+     usually QImode (this might actually be a bug in expmed.c). Note \n+     that the bit number is negative in big-endian mode in this case.\n+     We have to convert that to the offset.  */\n+  if (WORDS_BIG_ENDIAN)\n+    ofs = GET_MODE_BITSIZE (GET_MODE (operands[0]))\n+          - INTVAL (operands[1]) - INTVAL (operands[2]);\n+  else\n+    ofs = INTVAL (operands[2]);\n+\n+  ofs = ofs / 8;\n+\n   alpha_expand_unaligned_store (operands[0], operands[3],\n-\t\t\t        INTVAL (operands[1]) / 8,\n-\t\t\t        INTVAL (operands[2]) / 8);\n+\t\t\t        INTVAL (operands[1]) / 8, ofs);\n   DONE;\n })\n \n@@ -5675,7 +6282,7 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi\"\n         (match_operand:DI 1 \"register_operand\" \"r\"))\n    (clobber (mem:BLK (match_operand:DI 2 \"register_operand\" \"=r\")))]\n   \"\"\n-  \"mov %1,%0\")\n+  \"bis $31,%1,%0\")\n \n (define_expand \"epilogue\"\n   [(return)]\n@@ -5836,6 +6443,58 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi\"\n   [(set_attr \"length\" \"16\")\n    (set_attr \"type\" \"multi\")])\n \n+;; Load the CIW into r2 for calling __T3E_MISMATCH\n+\n+(define_expand \"umk_mismatch_args\"\n+  [(set:DI (match_dup 1) (mem:DI (plus:DI (reg:DI 15) (const_int -16))))\n+   (set:DI (match_dup 2) (mem:DI (plus:DI (match_dup 1) (const_int -32))))\n+   (set:DI (reg:DI 1) (match_operand:DI 0 \"const_int_operand\" \"\"))\n+   (set:DI (match_dup 3) (plus:DI (mult:DI (reg:DI 25)\n+\t\t\t\t\t   (const_int 8))\n+\t\t\t\t  (match_dup 2)))\n+   (set:DI (reg:DI 2) (mem:DI (match_dup 3)))]\n+  \"TARGET_ABI_UNICOSMK\"\n+{\n+  operands[1] = gen_reg_rtx (DImode);\n+  operands[2] = gen_reg_rtx (DImode);\n+  operands[3] = gen_reg_rtx (DImode);\n+})\n+\n+(define_insn \"arg_home_umk\"\n+  [(unspec [(const_int 0)] UNSPEC_ARG_HOME)\n+   (use (reg:DI 1))\n+   (use (reg:DI 2))\n+   (use (reg:DI 16))\n+   (use (reg:DI 17))\n+   (use (reg:DI 18))\n+   (use (reg:DI 19))\n+   (use (reg:DI 20))\n+   (use (reg:DI 21))\n+   (use (reg:DI 48))\n+   (use (reg:DI 49))\n+   (use (reg:DI 50))\n+   (use (reg:DI 51))\n+   (use (reg:DI 52))\n+   (use (reg:DI 53))\n+   (clobber (mem:BLK (const_int 0)))\n+   (parallel [\n+   (clobber (reg:DI 22))\n+   (clobber (reg:DI 23))\n+   (clobber (reg:DI 24))\n+   (clobber (reg:DI 0))\n+   (clobber (reg:DI 1))\n+   (clobber (reg:DI 2))\n+   (clobber (reg:DI 3))\n+   (clobber (reg:DI 4))\n+   (clobber (reg:DI 5))\n+   (clobber (reg:DI 6))\n+   (clobber (reg:DI 7))\n+   (clobber (reg:DI 8))])]\n+  \"TARGET_ABI_UNICOSMK\"\n+  \"laum $4,__T3E_MISMATCH($31)\\;sll $4,32,$4\\;lalm $4,__T3E_MISMATCH($4)\\;lal $4,__T3E_MISMATCH($4)\\;jsr $3,($4)\"\n+  [(set_attr \"length\" \"16\")\n+   (set_attr \"type\" \"multi\")])\n+\n ;; Close the trap shadow of preceeding instructions.  This is generated\n ;; by alpha_reorg.\n \n@@ -5847,33 +6506,51 @@ fadd,fmul,fcpys,fdiv,fsqrt,misc,mvi,ftoi,itof,multi\"\n \n ;; No-op instructions used by machine-dependant reorg to preserve\n ;; alignment for instruction issue.\n+;; The Unicos/Mk assembler does not support these opcodes.\n \n (define_insn \"nop\"\n   [(const_int 0)]\n   \"\"\n-  \"nop\"\n+  \"bis $31,$31,$31\"\n   [(set_attr \"type\" \"ilog\")])\n \n (define_insn \"fnop\"\n   [(const_int 1)]\n   \"TARGET_FP\"\n-  \"fnop\"\n+  \"cpys $f31,$f31,$f31\"\n   [(set_attr \"type\" \"fcpys\")])\n \n (define_insn \"unop\"\n   [(const_int 2)]\n   \"\"\n-  \"unop\")\n+  \"ldq_u $31,($31)\")\n+\n+;; On Unicos/Mk we use a macro for aligning code.\n \n (define_insn \"realign\"\n   [(unspec_volatile [(match_operand 0 \"immediate_operand\" \"i\")]\n \t\t    UNSPECV_REALIGN)]\n   \"\"\n-  \".align %0 #realign\")\n+{\n+  if (TARGET_ABI_UNICOSMK)\n+    return \"gcc@code@align %0\";\n+  else\n+    return \".align %0 #realign\";\n+})\n \n ;; The call patterns are at the end of the file because their\n ;; wildcard operand0 interferes with nice recognition.\n \n+(define_insn \"*call_value_umk\"\n+  [(set (match_operand 0 \"\" \"\")\n+\t(call (mem:DI (match_operand:DI 1 \"call_operand\" \"r\"))\n+\t      (match_operand 2 \"\" \"\")))\n+   (use (reg:DI 25))\n+   (clobber (reg:DI 26))]\n+  \"TARGET_ABI_UNICOSMK\"\n+  \"jsr $26,(%1)\"\n+  [(set_attr \"type\" \"jsr\")])\n+\n (define_insn \"*call_value_osf_1_er\"\n   [(set (match_operand 0 \"\" \"\")\n \t(call (mem:DI (match_operand:DI 1 \"call_operand\" \"c,R,i\"))"}, {"sha": "9c52b98471847ae6439d70bac69be5d33cfee1bb", "filename": "gcc/config/alpha/t-unicosmk", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30102605e710a95f8cb00ddd14303d7fcc284fae/gcc%2Fconfig%2Falpha%2Ft-unicosmk", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30102605e710a95f8cb00ddd14303d7fcc284fae/gcc%2Fconfig%2Falpha%2Ft-unicosmk", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Ft-unicosmk?ref=30102605e710a95f8cb00ddd14303d7fcc284fae", "patch": "@@ -0,0 +1,2 @@\n+# This file is empty for now.\n+"}, {"sha": "6ecc3d2e0fe5de0e8e048810e5e7622502fa22f7", "filename": "gcc/config/alpha/unicosmk.h", "status": "added", "additions": 667, "deletions": 0, "changes": 667, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30102605e710a95f8cb00ddd14303d7fcc284fae/gcc%2Fconfig%2Falpha%2Funicosmk.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30102605e710a95f8cb00ddd14303d7fcc284fae/gcc%2Fconfig%2Falpha%2Funicosmk.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Funicosmk.h?ref=30102605e710a95f8cb00ddd14303d7fcc284fae", "patch": "@@ -0,0 +1,667 @@\n+/* Definitions of target machine for GNU compiler, for DEC Alpha on Cray\n+   T3E running Unicos/Mk.\n+   Copyright (C) 2001\n+   Free Software Foundation, Inc.\n+   Contributed by Roman Lechtchinsky (rl@cs.tu-berlin.de)\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+#undef TARGET_ABI_UNICOSMK\n+#define TARGET_ABI_UNICOSMK 1\n+\n+/* CAM requires a slash before floating-pointing instruction suffixes.  */\n+\n+#undef TARGET_AS_SLASH_BEFORE_SUFFIX\n+#define TARGET_AS_SLASH_BEFORE_SUFFIX 1\n+\n+/* The following defines are necessary for the standard headers to work\n+   correctly.  */\n+\n+#undef CPP_PREDEFINES\n+#define CPP_PREDEFINES \"-D__unix=1 -D_UNICOS=205 -D_CRAY=1 -D_CRAYT3E=1 -D_CRAYMPP=1 -D_CRAYIEEE=1 -D_ADDR64=1 -D_LD64=1 -D__UNICOSMK__ -D__INT_MAX__=9223372036854775807 -D__SHRT_MAX__=2147483647\"\n+\n+/* Disable software floating point emulation because it requires a 16-bit\n+   type which we do not have.  */\n+\n+#ifndef __GNUC__\n+#undef REAL_ARITHMETIC\n+#endif\n+\n+#define SHORT_TYPE_SIZE 32\n+\n+#undef INT_TYPE_SIZE\n+#define INT_TYPE_SIZE 64\n+\n+/* This is consistent with the definition Cray CC uses. */\n+#undef WCHAR_TYPE\n+#define WCHAR_TYPE \"int\"\n+#undef WCHAR_TYPE_SIZE\n+#define WCHAR_TYPE_SIZE 64\n+\n+/*\n+#define SIZE_TYPE \"unsigned int\"\n+#define PTRDIFF_TYPE \"int\"\n+*/\n+\n+/* Alphas are operated in big endian mode on the Cray T3E.  */\n+\n+#undef BITS_BIG_ENDIAN\n+#undef BYTES_BIG_ENDIAN\n+#undef WORDS_BIG_ENDIAN\n+#define BITS_BIG_ENDIAN 0\n+#define BYTES_BIG_ENDIAN 1\n+#define WORDS_BIG_ENDIAN 1\n+\n+\n+/* Every structure's size must be a multiple of this.  */\n+\n+#undef STRUCTURE_SIZE_BOUNDARY\n+#define STRUCTURE_SIZE_BOUNDARY 64\n+\n+/* Allocation boundary (in *bits*) for the code of a function. Functions\n+   should be cache-aligned on the T3E.  */\n+\n+#undef FUNCTION_BOUNDARY\n+#define FUNCTION_BOUNDARY 256\n+\n+/* No data type wants to be aligned rounder than this.  */\n+\n+#undef BIGGEST_ALIGNMENT\n+#define BIGGEST_ALIGNMENT 256\n+\n+/* Include the frame pointer in fixed_regs and call_used_regs as it can't be \n+   used as a general-purpose register even in frameless functions.\n+   ??? The global_regs hack is needed for now because -O2 sometimes tries to \n+   eliminate $15 increments/decrements in frameless functions.  */\n+\n+#undef CONDITIONAL_REGISTER_USAGE\n+#define CONDITIONAL_REGISTER_USAGE\t\\\n+  do {\t\t\t\t\t\\\n+    fixed_regs[15] = 1;\t\t\t\\\n+    call_used_regs[15] = 1;\t\t\\\n+    global_regs[15] = 1;\t\t\\\n+  } while(0)\n+\f\n+/* The stack frame grows downward.  */\n+\n+#define FRAME_GROWS_DOWNWARD\n+\n+/* Define the offset between two registers, one to be eliminated, and the\n+   other its replacement, at the start of a routine. This is somewhat\n+   complicated on the T3E which is why we use a function.  */\n+\n+extern int unicosmk_initial_elimination_offset PARAMS ((int, int));\n+\n+#undef INITIAL_ELIMINATION_OFFSET\n+#define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET)\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    (OFFSET) = unicosmk_initial_elimination_offset ((FROM), (TO));\t\\\n+  } while (0)\n+\n+\n+/* Define this if stack space is still allocated for a parameter passed\n+   in a register. On the T3E, stack space is preallocated for all outgoing\n+   arguments, including those passed in registers. To avoid problems, we\n+   assume that at least 48 bytes (i.e. enough space for all arguments passed\n+   in registers) are allocated.  */\n+\n+#define REG_PARM_STACK_SPACE(DECL) 48\n+#define OUTGOING_REG_PARM_STACK_SPACE\n+\n+/* If an argument can't be passed in registers even though not all argument\n+   registers have been used yet, it is passed on the stack in the space \n+   preallocated for these registers.  */\n+\n+#define STACK_PARMS_IN_REG_PARM_AREA\n+\n+/* This evaluates to nonzero if we do not know how to pass TYPE solely in\n+   registers. This is the case for all arguments that do not fit in two\n+   registers.  */\n+\n+#define MUST_PASS_IN_STACK(MODE,TYPE)\t\t\t\t\t\\\n+  ((TYPE) != 0                                          \t\t\\\n+   && (TREE_CODE (TYPE_SIZE (TYPE)) != INTEGER_CST      \t\t\\\n+       || (TREE_ADDRESSABLE (TYPE) || ALPHA_ARG_SIZE (MODE, TYPE, 0) > 2)))\n+\n+/* Define a data type for recording info about an argument list\n+   during the scan of that argument list.  This data type should\n+   hold all necessary information about the function itself\n+   and about the args processed so far, enough to enable macros\n+   such as FUNCTION_ARG to determine where the next arg should go.\n+\n+   On Unicos/Mk, this is a structure that contains various information for\n+   the static subroutine information block (SSIB) and the call information\n+   word (CIW).  */\n+\n+typedef struct {\n+\n+  /* The overall number of arguments.  */\n+  int num_args;\n+\n+  /* The overall size of the arguments in words.  */\n+  int num_arg_words;\n+\n+  /* The number of words passed in registers.  */\n+  int num_reg_words;\n+\n+  /* If an argument must be passed in the stack, all subsequent arguments\n+     must be passed there, too. This flag indicates whether this is the\n+     case.  */\n+  int force_stack;\n+\n+  /* This array indicates whether a word is passed in an integer register or\n+     a floating point one.  */\n+\n+  /* For each of the 6 register arguments, the corresponding flag in this\n+     array indicates whether the argument is passed in an integer or a\n+     floating point register.  */\n+  int reg_args_type[6];\n+\n+} unicosmk_arg_info;\n+\n+#undef CUMULATIVE_ARGS\n+#define CUMULATIVE_ARGS unicosmk_arg_info\n+\n+/* Initialize a variable CUM of type CUMULATIVE_ARGS for a call to a\n+   function whose data type is FNTYPE.  For a library call, FNTYPE is 0.  */\n+\n+#undef INIT_CUMULATIVE_ARGS\n+#define INIT_CUMULATIVE_ARGS(CUM,FNTYPE,LIBNAME,INDIRECT)\t\\\n+  do { (CUM).num_args = 0;\t\t\t\t\t\\\n+       (CUM).num_arg_words = 0;\t\t\t\t\t\\\n+       (CUM).num_reg_words = 0;\t\t\t\t\t\\\n+       (CUM).force_stack = 0;\t\t\t\t\t\\\n+  } while(0)\n+\n+/* Update the data in CUM to advance over an argument of mode MODE and data\n+   type TYPE. (TYPE is null for libcalls where that information may not be\n+   available.)\n+\n+   On Unicos/Mk, at most 6 words can be passed in registers. Structures\n+   which fit in two words are passed in registers, larger structures are\n+   passed on stack.  */\n+\n+#undef FUNCTION_ARG_ADVANCE\n+#define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED)\t\t\\\n+do {\t\t\t\t\t\t\t\t\\\n+  int size;\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\\\n+  size = ALPHA_ARG_SIZE (MODE, TYPE, NAMED);\t\t\t\\\n+                                                                \\\n+  if (size > 2 || MUST_PASS_IN_STACK (MODE, TYPE)\t\t\\\n+      || (CUM).num_reg_words + size > 6)\t\t\t\\\n+    (CUM).force_stack = 1;\t\t\t\t\t\\\n+                                                                \\\n+  if (! (CUM).force_stack)\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      int i;\t\t\t\t\t\t\t\\\n+      int isfloat;\t\t\t\t\t\t\\\n+      isfloat = (GET_MODE_CLASS (MODE) == MODE_COMPLEX_FLOAT\t\\\n+              || GET_MODE_CLASS (MODE) == MODE_FLOAT);\t\t\\\n+      for (i = 0; i < size; i++)\t\t\t\t\\\n+        {\t\t\t\t\t\t\t\\\n+          (CUM).reg_args_type[(CUM).num_reg_words] = isfloat;\t\\\n+          ++(CUM).num_reg_words;\t\t\t\t\\\n+        }\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  (CUM).num_arg_words += size;\t\t\t\t\t\\\n+  ++(CUM).num_args;\t\t\t\t\t\t\\\n+} while(0)\n+\n+/* We want the default definition for this.\n+   ??? In fact, we should delete the definition from alpha.h as it\n+   corresponds to the default definition for little-endian machines.  */\n+\n+#undef FUNCTION_ARG_PADDING\n+\n+/* An argument is passed either entirely in registers or entirely on stack. */\n+ \n+#undef FUNCTION_ARG_PARTIAL_NREGS\n+/* #define FUNCTION_ARG_PARTIAL_NREGS(CUM,MODE,TYPE,NAMED) 0 */\n+\n+/* Perform any needed actions needed for a function that is receiving a\n+   variable number of arguments.\n+\n+   On Unicos/Mk, the standard subroutine __T3E_MISMATCH stores all register\n+   arguments on the stack. Unfortunately, it doesn't always store the first\n+   one (i.e. the one that arrives in $16 or $f16). This is not a problem\n+   with stdargs as we always have at least one named argument there. This is\n+   not always the case when varargs.h is used, however. In such cases, we\n+   have to store the first argument ourselves. We use the information from\n+   the CIW to determine whether the first argument arrives in $16 or $f16.  */\n+\n+#undef SETUP_INCOMING_VARARGS\n+#define SETUP_INCOMING_VARARGS(CUM,MODE,TYPE,PRETEND_SIZE,NO_RTL)\t\\\n+{ if ((CUM).num_reg_words < 6)\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      if (! (NO_RTL))\t\t\t\t\t\t\t\\\n+        {\t\t\t\t\t\t\t\t\\\n+\t  int start;\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\t  start = (CUM).num_reg_words;\t\t\t\t\t\\\n+\t  if (!current_function_varargs || start == 0)\t\t\t\\\n+\t    ++start;\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+          emit_insn (gen_umk_mismatch_args (GEN_INT (start)));\t\t\\\n+\t  if (current_function_varargs && (CUM).num_reg_words == 0)\t\\\n+\t    {\t\t\t\t\t\t\t\t\\\n+\t      rtx tmp;\t\t\t\t\t\t\t\\\n+\t      rtx int_label, end_label;\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\t      tmp = gen_reg_rtx (DImode);\t\t\t\t\\\n+\t      emit_move_insn (tmp,\t\t\t\t\t\\\n+\t\t\t      gen_rtx_ZERO_EXTRACT (DImode,\t\t\\\n+\t\t\t\t\t\t    gen_rtx_REG (DImode, 2),\\\n+\t\t\t\t\t\t    (GEN_INT (1)),\t\\\n+\t\t\t\t\t\t    (GEN_INT (7))));\t\\\n+\t      int_label = gen_label_rtx ();\t\t\t\t\\\n+\t      end_label = gen_label_rtx ();\t\t\t\t\\\n+\t      emit_insn (gen_cmpdi (tmp, GEN_INT (0)));\t\t\t\\\n+\t      emit_jump_insn (gen_beq (int_label));\t\t\t\\\n+\t      emit_move_insn (gen_rtx_MEM (DFmode, virtual_incoming_args_rtx),\\\n+\t\t\t      gen_rtx_REG (DFmode, 48));\t\t\\\n+\t      emit_jump (end_label);\t\t\t\t\t\\\n+\t      emit_label (int_label);\t\t\t\t\t\\\n+\t      emit_move_insn (gen_rtx_MEM (DImode, virtual_incoming_args_rtx),\\\n+\t\t\t      gen_rtx_REG (DImode, 16));\t\t\\\n+\t      emit_label (end_label);\t\t\t\t\t\\\n+\t    }\t\t\t\t\t\t\t\t\\\n+\t  emit_insn (gen_arg_home_umk ());\t\t\t\t\\\n+        }\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      PRETEND_SIZE = 0;\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+}\n+\n+/* This ensures that $15 increments/decrements in leaf functions won't get\n+   eliminated.  */\n+\n+#undef EPILOGUE_USES\n+#define EPILOGUE_USES(REGNO)  ((REGNO) == 26 || (REGNO) == 15)\n+\n+/* Machine-specific function data.  */\n+\n+struct machine_function\n+{\n+  /* List of call information words for calls from this function.  */\n+  struct rtx_def *first_ciw;\n+  struct rtx_def *last_ciw;\n+  int ciw_count;\n+\n+  /* List of deferred case vectors.  */\n+  struct rtx_def *addr_list;\n+};\n+\n+/* Would have worked, only the stack doesn't seem to be executable\n+#undef TRAMPOLINE_TEMPLATE\n+#define TRAMPOLINE_TEMPLATE(FILE)\t\t\t\\\n+do { fprintf (FILE, \"\\tbr $1,0\\n\");\t\t\t\\\n+     fprintf (FILE, \"\\tldq $0,12($1)\\n\");\t\t\\\n+     fprintf (FILE, \"\\tldq $1,20($1)\\n\");\t\t\\\n+     fprintf (FILE, \"\\tjmp $31,(r0)\\n\");\t\t\\\n+     fprintf (FILE, \"\\tbis $31,$31,$31\\n\");\t\t\\\n+     fprintf (FILE, \"\\tbis $31,$31,$31\\n\");\t\t\\\n+} while (0) */\n+\n+/* We don't support nested functions (yet).  */\n+\n+#undef TRAMPOLINE_TEMPLATE\n+#define TRAMPOLINE_TEMPLATE(FILE) abort ()\n+\f\n+/* Specify the machine mode that this machine uses for the index in the\n+   tablejump instruction. On Unicos/Mk, we don't support relative case\n+   vectors yet, thus the entries should be absolute addresses. */ \n+\n+#undef CASE_VECTOR_MODE\n+#define CASE_VECTOR_MODE DImode\n+\n+#undef CASE_VECTOR_PC_RELATIVE\n+\n+/* Define this as 1 if `char' should by default be signed; else as 0.  */\n+/* #define DEFAULT_SIGNED_CHAR 1 */\n+\n+/* The Cray assembler is really weird with respect to sections. It has only\n+   named sections and you can't reopen a section once it has been closed.\n+   This means that we have to generate unique names whenever we want to\n+   reenter the text or the data section. The following is a rather bad hack\n+   as TEXT_SECTION_ASM_OP and DATA_SECTION_ASM_OP are supposed to be\n+   constants.  */\n+\n+#undef TEXT_SECTION_ASM_OP\n+#define TEXT_SECTION_ASM_OP unicosmk_text_section ()\n+\n+#undef DATA_SECTION_ASM_OP\n+#define DATA_SECTION_ASM_OP unicosmk_data_section ()\n+\n+/* There are ni read-only sections on Unicos/Mk.  */\n+\n+#undef READONLY_DATA_SECTION\n+#define READONLY_DATA_SECTION data_section\n+\n+/* Define extra sections for common data and SSIBs (static subroutine\n+   information blocks). The actual section header is output by the callers\n+   of these functions.  */\n+\n+#undef EXTRA_SECTIONS\n+#undef EXTRA_SECTION_FUNCTIONS\n+\n+#define EXTRA_SECTIONS in_common, in_ssib\n+#define EXTRA_SECTION_FUNCTIONS\t\\\n+COMMON_SECTION\t\t\t\\\n+SSIB_SECTION\t\n+\n+#define COMMON_SECTION\t\t\\\n+void\t\t\t\t\\\n+common_section ()\t\t\\\n+{\t\t\t\t\\\n+  in_section = in_common;\t\\\n+}\n+\n+#define SSIB_SECTION\t\t\\\n+void\t\t\t\t\\\n+ssib_section ()\t\t\t\\\n+{\t\t\t\t\\\n+  in_section = in_ssib;\t\t\\\n+}\n+\n+/* A C expression which evaluates to true if declshould be placed into a\n+   unique section for some target-specific reason. On Unicos/Mk, functions\n+   and public variables are always placed in unique sections.  */ \n+\n+/*\n+#define UNIQUE_SECTION_P(DECL) (TREE_PUBLIC (DECL)\t\t\\\n+\t\t\t\t|| TREE_CODE (DECL) == FUNCTION_DECL)\n+*/\n+#define UNIQUE_SECTION(DECL, RELOC) unicosmk_unique_section (DECL, RELOC)\n+\n+/* This outputs text to go at the start of an assembler file.  */\n+\n+#undef ASM_FILE_START\n+#define ASM_FILE_START(FILE)\tunicosmk_asm_file_start (FILE)\n+\n+/* This outputs text to go at the end of an assembler file.  */\n+\n+#undef ASM_FILE_END\n+#define ASM_FILE_END(FILE)\tunicosmk_asm_file_end (FILE)\n+\n+/* We take care of that in ASM_FILE_START. */\n+\n+#undef ASM_OUTPUT_SOURCE_FILENAME\n+\n+/* There is no directive for declaring a label as global. Instead, an \n+   additional colon must be appended when the label is defined.  */\n+\n+#undef ASM_GLOBALIZE_LABEL\n+#define ASM_GLOBALIZE_LABEL(FILE,NAME)\n+\n+/* This is how to output a label for a jump table.  Arguments are the same as\n+   for ASM_OUTPUT_INTERNAL_LABEL, except the insn for the jump table is\n+   passed.  */\n+\n+#undef ASM_OUTPUT_CASE_LABEL\n+#define ASM_OUTPUT_CASE_LABEL(FILE,PREFIX,NUM,TABLEINSN)\t\\\n+  ASM_OUTPUT_INTERNAL_LABEL (FILE, PREFIX, NUM)\n+\n+/* This is how to output an assembler line defining a `double' constant.  */\n+\n+#undef ASM_OUTPUT_DOUBLE\n+#ifdef REAL_ARITHMETIC\n+#define ASM_OUTPUT_DOUBLE(FILE,VALUE)\t\t\t\\\n+  do { long t[2];\t\t\t\t\t\\\n+       REAL_VALUE_TO_TARGET_DOUBLE ((VALUE), t);\t\\\n+       fprintf (FILE, \"\\t.quad ^X%lx%08lx\\n\",\t\t\\\n+\t\tt[0] & 0xffffffff, t[1] & 0xffffffff);\t\\\n+  } while (0)\n+#else\n+#define ASM_OUTPUT_DOUBLE(FILE,VALUE)\t\t\t\\\n+  do { long t[2];\t\t\t\t\t\\\n+       REAL_VALUE_TO_TARGET_DOUBLE ((VALUE), t);\t\\\n+       fprintf (FILE, \"\\t.quad ^X%x\\n\", t[0]);\t\t\\\n+  } while(0)\n+#endif\n+ \n+\n+/* This is how to output an assembler line defining a `long double'\n+   constant. `long double'  and `double' are the same on the Cray T3E.  */\n+ \n+#undef ASM_OUTPUT_LONG_DOUBLE\n+#define ASM_OUTPUT_LONG_DOUBLE(FILE,VALUE)\t\t\\\n+  ASM_OUTPUT_DOUBLE (FILE,VALUE)\n+\n+/* This is how to output an assembler line defining a `float' constant.\n+   ??? Somehow, REAL_VALUE_TO_TARGET_SINGLE gets confused and returns the\n+   value in the upper bits of the int.  */\n+\n+#undef ASM_OUTPUT_FLOAT\n+#ifdef REAL_ARITHMETIC\n+#define ASM_OUTPUT_FLOAT(FILE,VALUE)\t\t\t\\\n+  do { long t;\t\t\t\t\t\t\\\n+       REAL_VALUE_TO_TARGET_SINGLE ((VALUE), t);\t\\\n+       fprintf (FILE, \"\\t.long ^X%x\\n\", t & 0xffffffff);\\\n+  } while (0)\n+#else\n+#define ASM_OUTPUT_FLOAT(FILE,VALUE)\t\t\t\\\n+  do { long t;\t\t\t\t\t\t\\\n+       REAL_VALUE_TO_TARGET_SINGLE ((VALUE), t);\t\\\n+       fprintf (FILE, \"\\t.long ^X%x\\n\", (t >> 32) & 0xffffffff);\\\n+  } while(0)\n+#endif\n+\n+/* CAM has some restrictions with respect to string literals. It won't\n+   accept lines with more that 256 characters which means that we have\n+   to split long strings. Moreover, it only accepts escape sequences of\n+   the form \\nnn in the range 0 to 127. We generate .byte directives for\n+   escapes characters greater than 127. And finally, ` must be escaped.  */\n+\n+#undef ASM_OUTPUT_ASCII\n+#define ASM_OUTPUT_ASCII(MYFILE, MYSTRING, MYLENGTH) \\\n+  do {\t\t\t\t\t\t\t\t\t      \\\n+    FILE *_hide_asm_out_file = (MYFILE);\t\t\t\t      \\\n+    const unsigned char *_hide_p = (const unsigned char *) (MYSTRING);\t      \\\n+    int _hide_thissize = (MYLENGTH);\t\t\t\t\t      \\\n+    int _size_so_far = 0;\t\t\t\t\t\t      \\\n+    {\t\t\t\t\t\t\t\t\t      \\\n+      FILE *asm_out_file = _hide_asm_out_file;\t\t\t\t      \\\n+      const unsigned char *p = _hide_p;\t\t\t\t\t      \\\n+      int thissize = _hide_thissize;\t\t\t\t\t      \\\n+      int in_ascii = 0;\t\t\t\t\t\t\t      \\\n+      int i;\t\t\t\t\t\t\t\t      \\\n+\t\t\t\t\t\t\t\t\t      \\\n+      for (i = 0; i < thissize; i++)\t\t\t\t\t      \\\n+\t{\t\t\t\t\t\t\t\t      \\\n+\t  register int c = p[i];\t\t\t\t\t      \\\n+\t\t\t\t\t\t\t\t\t      \\\n+\t  if (c > 127)\t\t\t\t\t\t\t      \\\n+\t    {\t\t\t\t\t\t\t\t      \\\n+\t      if (in_ascii)\t\t\t\t\t\t      \\\n+\t\t{\t\t\t\t\t\t\t      \\\n+\t\t  fprintf (asm_out_file, \"\\\"\\n\");\t\t\t      \\\n+\t\t  in_ascii = 0;\t\t\t\t\t\t      \\\n+\t\t}\t\t\t\t\t\t\t      \\\n+\t\t\t\t\t\t\t\t\t      \\\n+\t      fprintf (asm_out_file, \"\\t.byte\\t%d\\n\", c);\t\t      \\\n+\t    }\t\t\t\t\t\t\t\t      \\\n+\t  else\t\t\t\t\t\t\t\t      \\\n+\t    {\t\t\t\t\t\t\t\t      \\\n+\t      if (! in_ascii)\t\t\t\t\t\t      \\\n+\t\t{\t\t\t\t\t\t\t      \\\n+\t\t  fprintf (asm_out_file, \"\\t.ascii\\t\\\"\");\t\t      \\\n+\t\t  in_ascii = 1;\t\t\t\t\t\t      \\\n+\t\t  _size_so_far = 0;\t\t\t\t\t      \\\n+\t\t}\t\t\t\t\t\t\t      \\\n+\t      else if (_size_so_far >= 64)\t\t\t\t      \\\n+\t\t{\t\t\t\t\t\t\t      \\\n+\t\t  fprintf (asm_out_file, \"\\\"\\n\\t.ascii\\t\\\"\");\t\t      \\\n+\t\t  _size_so_far = 0;\t\t\t\t\t      \\\n+\t\t}\t\t\t\t\t\t\t      \\\n+\t\t\t\t\t\t\t\t\t      \\\n+\t      if (c == '\\\"' || c == '\\\\' || c == '`')\t\t\t      \\\n+\t\tputc ('\\\\', asm_out_file);\t\t\t\t      \\\n+\t      if (c >= ' ')\t\t\t\t\t\t      \\\n+\t\tputc (c, asm_out_file);\t\t\t\t\t      \\\n+\t      else\t\t\t\t\t\t\t      \\\n+\t\tfprintf (asm_out_file, \"\\\\%.3o\", c);\t\t\t      \\\n+\t      ++ _size_so_far;\t\t\t\t\t\t      \\\n+\t    }\t\t\t\t\t\t\t\t      \\\n+\t}\t\t\t\t\t\t\t\t      \\\n+      if (in_ascii)\t\t\t\t\t\t\t      \\\n+\tfprintf (asm_out_file, \"\\\"\\n\");\t\t\t\t\t      \\\n+    }\t\t\t\t\t\t\t\t\t      \\\n+  } while(0)\n+\n+/* This is how to output an element of a case-vector that is absolute.  */\n+\n+#undef ASM_OUTPUT_ADDR_VEC_ELT\n+#define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)\t\\\n+  fprintf (FILE, \"\\t.quad $L%d\\n\", (VALUE))\n+\n+/* This is how to output an element of a case-vector that is relative.\n+   (Unicos/Mk does not use such vectors yet).  */\n+\n+#undef ASM_OUTPUT_ADDR_DIFF_ELT\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL) abort ()\n+\n+/* We can't output case vectors in the same section as the function code\n+   because CAM doesn't allow data definitions in code sections. Thus, we\n+   simply record the case vectors and put them in a separate section after\n+   the function.  */\n+\n+#define ASM_OUTPUT_ADDR_VEC(LAB,VEC) \\\n+  unicosmk_defer_case_vector ((LAB),(VEC))\n+\n+#define ASM_OUTPUT_ADDR_DIFF_VEC(LAB,VEC) abort ()\n+\n+/* This is how to output an assembler line that says to advance the location\n+   counter to a multiple of 2**LOG bytes. Annoyingly, CAM always uses zeroes\n+   to fill the unused space which does not work in code sections. We have to \n+   be careful not to use the .align directive in code sections.  */\n+\n+#undef ASM_OUTPUT_ALIGN\n+#define ASM_OUTPUT_ALIGN(STREAM,LOG) unicosmk_output_align (STREAM, LOG)\n+\n+/* This is how to advance the location counter by SIZE bytes.  */\n+\n+#undef ASM_OUTPUT_SKIP\n+#define ASM_OUTPUT_SKIP(STREAM,SIZE)\t\t\t\\\n+  fprintf ((STREAM), \"\\t.byte\\t0:%d\\n\", (SIZE));\n+\n+/* This says how to output an assembler line to define a global common\n+   symbol. We need the alignment information because it has to be supplied\n+   in the section header.  */ \n+\n+#undef ASM_OUTPUT_COMMON\n+#define ASM_OUTPUT_ALIGNED_COMMON(FILE, NAME, SIZE, ALIGN)\t\\\n+  unicosmk_output_common ((FILE), (NAME), (SIZE), (ALIGN))\n+\n+/* This says how to output an assembler line to define a local symbol.  */\n+\n+#undef ASM_OUTPUT_LOCAL\n+#define ASM_OUTPUT_ALIGNED_LOCAL(FILE, NAME, SIZE, ALIGN) \\\n+  do { data_section ();\t\t\t\t\t\\\n+       fprintf (FILE, \"\\t.align\\t%d\\n\", floor_log2 ((ALIGN) / BITS_PER_UNIT));\\\n+       ASM_OUTPUT_LABEL ((FILE), (NAME));\t\t\\\n+       fprintf (FILE, \"\\t.byte 0:%d\\n\", SIZE);\t\t\\\n+  } while (0)\n+\n+/* CAM does not allow us to declare a symbol as external first and then\n+   define it in the same file later. Thus, we keep a list of all external\n+   references, remove all symbols defined locally from it and output it at\n+   the end of the asm file.  */\n+   \n+#define ASM_OUTPUT_EXTERNAL(FILE,DECL,NAME) \\\n+  unicosmk_add_extern ((NAME))\n+\n+#define ASM_OUTPUT_EXTERNAL_LIBCALL(STREAM,SYMREF)\t\\\n+  unicosmk_add_extern (XSTR ((SYMREF), 0))\n+\n+/* This is how to declare an object. We don't have to output anything if\n+   it is a global variable because those go into unique `common' sections\n+   and the section name is globally visible. For local variables, we simply\n+   output the label. In any case, we have to record that no extern\n+   declaration should be generated for the symbol.  */\n+\n+#define ASM_DECLARE_OBJECT_NAME(STREAM,NAME,DECL) \t\\\n+  do { tree name_tree;\t\t\t\t\t\\\n+       name_tree = get_identifier ((NAME));\t\t\\\n+       TREE_ASM_WRITTEN (name_tree) = 1;\t\t\\\n+       if (!TREE_PUBLIC (DECL))\t\t\t\t\\\n+\t {\t\t\t\t\t\t\\\n+\t   assemble_name (STREAM, NAME);\t\t\\\n+\t   fputs (\":\\n\", STREAM);\t\t\t\\\n+         }\t\t\t\t\t\t\\\n+  } while(0)\n+\n+/*\n+#define ASM_OUTPUT_SECTION_NAME(STREAM, DECL, NAME, RELOC)\t\\\n+  unicosmk_output_section_name ((STREAM), (DECL), (NAME), (RELOC))\n+*/\n+\n+/* Switch into a generic section.  */\n+#define TARGET_ASM_NAMED_SECTION unicosmk_asm_named_section\n+\n+#undef ASM_OUTPUT_MAX_SKIP_ALIGN\n+#define ASM_OUTPUT_MAX_SKIP_ALIGN(STREAM,POWER,MAXSKIP)\n+\f\n+/* We have to define these because we do not use the floating-point\n+   emulation. Unfortunately, atof does not accept hex literals.  */ \n+\n+#ifndef REAL_ARITHMETIC\n+#define REAL_VALUE_ATOF(x,s) atof(x)\n+#define REAL_VALUE_HTOF(x,s) atof(x)\n+#endif\n+\n+#undef NM_FLAGS\n+\n+#undef OBJECT_FORMAT_COFF\n+\n+/* We cannot generate debugging information on Unicos/Mk.  */\n+\n+#undef SDB_DEBUGGING_INFO\n+#undef MIPS_DEBUGGING_INFO\n+#undef DBX_DEBUGGING_INFO\n+#undef DWARF_DEBUGGING_INFO\n+#undef DWARF2_DEBUGGING_INFO\n+#undef DWARF2_UNWIND_INFO\n+#undef INCOMING_RETURN_ADDR_RTX\n+\n+\n+/* We use the functions provided by the system library for integer\n+   division.  */\n+\n+#undef UDIVDI3_LIBCALL\n+#undef DIVDI3_LIBCALL\n+#define UDIVDI3_LIBCALL\t\"$uldiv\"\n+#define DIVDI3_LIBCALL \"$sldiv\"\n+\n+#undef ASM_OUTPUT_SOURCE_LINE\n+\n+/* We don't need a start file.  */\n+\n+#undef STARTFILE_SPEC\n+#define STARTFILE_SPEC \"\"\n+\n+/* These are the libraries we have to link with.\n+   ??? The Craylibs directory should be autoconfed.  */\n+#undef LIB_SPEC\n+#define LIB_SPEC \"-L/opt/ctl/craylibs/craylibs -lu -lm -lc -lsma\"\n+\n+#undef BUILD_VA_LIST_TYPE\n+#undef EXPAND_BUILTIN_VA_START\n+#undef EXPAND_BUILTIN_VA_ARG\n+\n+#define EH_FRAME_IN_DATA_SECTION 1"}, {"sha": "79b3e7e67fdd2dd25e44f5cb18058c3eba56d358", "filename": "gcc/fixinc/fixincl.x", "status": "modified", "additions": 47, "deletions": 4, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30102605e710a95f8cb00ddd14303d7fcc284fae/gcc%2Ffixinc%2Ffixincl.x", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30102605e710a95f8cb00ddd14303d7fcc284fae/gcc%2Ffixinc%2Ffixincl.x", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffixinc%2Ffixincl.x?ref=30102605e710a95f8cb00ddd14303d7fcc284fae", "patch": "@@ -5,7 +5,7 @@\n  * files which are fixed to work correctly with ANSI C and placed in a\n  * directory that GNU C will search.\n  *\n- * This file contains 143 fixup descriptions.\n+ * This file contains 144 fixup descriptions.\n  *\n  * See README for more information.\n  *\n@@ -1954,7 +1954,7 @@ tSCC zHpux10_Cpp_Pow_InlineName[] =\n  *  File name selection pattern\n  */\n tSCC zHpux10_Cpp_Pow_InlineList[] =\n-  \"|math.h|\";\n+  \"|fixinc-test-limits.h|math.h|\";\n /*\n  *  Machine/OS name selection pattern\n  */\n@@ -5105,6 +5105,43 @@ static const char* apzUndefine_NullPatch[] = {\n ]+)([\\r]*)\\n\",\n     (char*)NULL };\n \n+/* * * * * * * * * * * * * * * * * * * * * * * * * *\n+ *\n+ *  Description of Unicosmk_Restrict fix\n+ */\n+tSCC zUnicosmk_RestrictName[] =\n+     \"unicosmk_restrict\";\n+\n+/*\n+ *  File name selection pattern\n+ */\n+tSCC zUnicosmk_RestrictList[] =\n+  \"|stdio.h|stdlib.h|wchar.h|\";\n+/*\n+ *  Machine/OS name selection pattern\n+ */\n+tSCC* apzUnicosmk_RestrictMachs[] = {\n+        \"*-*-unicosmk*\",\n+        (const char*)NULL };\n+\n+/*\n+ *  content selection pattern - do fix if pattern found\n+ */\n+tSCC zUnicosmk_RestrictSelect0[] =\n+       \"(\\\\*[ \\t]*)restrict([ \\t]+)\";\n+\n+#define    UNICOSMK_RESTRICT_TEST_CT  1\n+static tTestDesc aUnicosmk_RestrictTests[] = {\n+  { TT_EGREP,    zUnicosmk_RestrictSelect0, (regex_t*)NULL }, };\n+\n+/*\n+ *  Fix Command Arguments for Unicosmk_Restrict\n+ */\n+static const char* apzUnicosmk_RestrictPatch[] = {\n+    \"format\",\n+    \"%1__restrict__%2\",\n+    (char*)NULL };\n+\n /* * * * * * * * * * * * * * * * * * * * * * * * * *\n  *\n  *  Description of Uw7_Byteorder_Fix fix\n@@ -5577,9 +5614,9 @@ static const char* apzX11_SprintfPatch[] = {\n  *\n  *  List of all fixes\n  */\n-#define REGEX_COUNT          150\n+#define REGEX_COUNT          151\n #define MACH_LIST_SIZE_LIMIT 279\n-#define FIX_COUNT            143\n+#define FIX_COUNT            144\n \n /*\n  *  Enumerate the fixes\n@@ -5717,6 +5754,7 @@ typedef enum {\n     ULTRIX_STATIC_FIXIDX,\n     ULTRIX_STRINGS_FIXIDX,\n     UNDEFINE_NULL_FIXIDX,\n+    UNICOSMK_RESTRICT_FIXIDX,\n     UW7_BYTEORDER_FIX_FIXIDX,\n     VA_I960_MACRO_FIXIDX,\n     VOID_NULL_FIXIDX,\n@@ -6391,6 +6429,11 @@ tFixDesc fixDescList[ FIX_COUNT ] = {\n      UNDEFINE_NULL_TEST_CT, FD_MACH_ONLY | FD_SUBROUTINE,\n      aUndefine_NullTests,   apzUndefine_NullPatch, 0 },\n \n+  {  zUnicosmk_RestrictName,    zUnicosmk_RestrictList,\n+     apzUnicosmk_RestrictMachs,\n+     UNICOSMK_RESTRICT_TEST_CT, FD_MACH_ONLY | FD_SUBROUTINE,\n+     aUnicosmk_RestrictTests,   apzUnicosmk_RestrictPatch, 0 },\n+\n   {  zUw7_Byteorder_FixName,    zUw7_Byteorder_FixList,\n      apzUw7_Byteorder_FixMachs,\n      UW7_BYTEORDER_FIX_TEST_CT, FD_MACH_ONLY | FD_SUBROUTINE,"}, {"sha": "40194e2fd08bf0c018622f3d73f7f4e3eaaee7c8", "filename": "gcc/fixinc/inclhack.def", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30102605e710a95f8cb00ddd14303d7fcc284fae/gcc%2Ffixinc%2Finclhack.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30102605e710a95f8cb00ddd14303d7fcc284fae/gcc%2Ffixinc%2Finclhack.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffixinc%2Finclhack.def?ref=30102605e710a95f8cb00ddd14303d7fcc284fae", "patch": "@@ -3102,6 +3102,23 @@ fix = {\n     test_text = \"#define NULL 0UL\\r\\n#define NULL\\t((void*)0)\\n\";\n };\n \n+/*\n+ * On Cray Unicos/Mk some standard headers use the C99 keyword \"restrict\"\n+ * which must be replaced by __restrict__ for GCC.\n+ */\n+fix = {\n+    hackname = unicosmk_restrict;\n+    files    = stdio.h;\n+    files    = stdlib.h;\n+    files    = wchar.h;\n+    mach     = \"*-*-unicosmk*\";\n+    select   = \"(\\\\*[ \\t]*)restrict([ \\t]+)\";\n+\n+    c_fix     = format;\n+    c_fix_arg = \"%1__restrict__%2\";\n+\n+    test_text = \"void f (char * restrict x);\";\n+};\n \n /*\n  * If arpa/inet.h prototypes are incompatible with the ones we just"}, {"sha": "cce87e5b6ed82eceff3cc60fcee6593758181096", "filename": "gcc/ginclude/stddef.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30102605e710a95f8cb00ddd14303d7fcc284fae/gcc%2Fginclude%2Fstddef.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30102605e710a95f8cb00ddd14303d7fcc284fae/gcc%2Fginclude%2Fstddef.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fginclude%2Fstddef.h?ref=30102605e710a95f8cb00ddd14303d7fcc284fae", "patch": "@@ -165,6 +165,7 @@ typedef __PTRDIFF_TYPE__ ptrdiff_t;\n    or if we want this type in particular.  */\n #if defined (_STDDEF_H) || defined (__need_size_t)\n #ifndef __size_t__\t/* BeOS */\n+#ifndef __SIZE_T__\t/* Cray Unicos/Mk */\n #ifndef _SIZE_T\t/* in case <sys/types.h> has defined it. */\n #ifndef _SYS_SIZE_T_H\n #ifndef _T_SIZE_\n@@ -179,6 +180,7 @@ typedef __PTRDIFF_TYPE__ ptrdiff_t;\n #ifndef _SIZET_\n #ifndef __size_t\n #define __size_t__\t/* BeOS */\n+#define __SIZE_T__\t/* Cray Unicos/Mk */\n #define _SIZE_T\n #define _SYS_SIZE_T_H\n #define _T_SIZE_\n@@ -214,6 +216,7 @@ typedef long ssize_t;\n #endif /* _T_SIZE_ */\n #endif /* _SYS_SIZE_T_H */\n #endif /* _SIZE_T */\n+#endif /* __SIZE_T__ */\n #endif /* __size_t__ */\n #undef\t__need_size_t\n #endif /* _STDDEF_H or __need_size_t.  */\n@@ -228,6 +231,7 @@ typedef long ssize_t;\n    or if we want this type in particular.  */\n #if defined (_STDDEF_H) || defined (__need_wchar_t)\n #ifndef __wchar_t__\t/* BeOS */\n+#ifndef __WCHAR_T__\t/* Cray Unicos/Mk */\n #ifndef _WCHAR_T\n #ifndef _T_WCHAR_\n #ifndef _T_WCHAR\n@@ -242,6 +246,7 @@ typedef long ssize_t;\n #ifndef __INT_WCHAR_T_H\n #ifndef _GCC_WCHAR_T\n #define __wchar_t__\t/* BeOS */\n+#define __WCHAR_T__\t/* Cray Unicos/Mk */\n #define _WCHAR_T\n #define _T_WCHAR_\n #define _T_WCHAR\n@@ -300,6 +305,7 @@ typedef __WCHAR_TYPE__ wchar_t;\n #endif\n #endif\n #endif\n+#endif /* __WCHAR_T__ */\n #endif /* __wchar_t__ */\n #undef\t__need_wchar_t\n #endif /* _STDDEF_H or __need_wchar_t.  */"}]}