{"sha": "18e0c3d1718157761e3f23ddc33ae22393bef15f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MThlMGMzZDE3MTgxNTc3NjFlM2YyM2RkYzMzYWUyMjM5M2JlZjE1Zg==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2018-11-05T10:28:19Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2018-11-05T10:28:19Z"}, "message": "re PR tree-optimization/87859 (store-merging miscompilation of mesa)\n\n\tPR tree-optimization/87859\n\t* gimple-ssa-store-merging.c (struct merged_store_group): Add\n\tonly_constants and first_nonmergeable_order members.\n\t(merged_store_group::merged_store_group): Initialize them.\n\t(merged_store_group::do_merge): Clear only_constants member if\n\tadding something other than INTEGER_CST store.\n\t(imm_store_chain_info::coalesce_immediate_stores): Don't merge\n\tstores with order >= first_nonmergeable_order.  Use\n\tmerged_store->only_constants instead of always recomputing it.\n\tSet merged_store->first_nonmergeable_order if we've skipped any\n\tstores.  Attempt to merge overlapping INTEGER_CST stores that\n\twe would otherwise skip.\n\n\t* gcc.dg/store_merging_24.c: New test.\n\t* gcc.dg/store_merging_25.c: New test.\n\nFrom-SVN: r265794", "tree": {"sha": "d44029bd0f91d888f3a5188839bab890b970e2c4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d44029bd0f91d888f3a5188839bab890b970e2c4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/18e0c3d1718157761e3f23ddc33ae22393bef15f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18e0c3d1718157761e3f23ddc33ae22393bef15f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/18e0c3d1718157761e3f23ddc33ae22393bef15f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18e0c3d1718157761e3f23ddc33ae22393bef15f/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "cbd429001f3a6c2338c695cc71a28cd8320e3bd2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cbd429001f3a6c2338c695cc71a28cd8320e3bd2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cbd429001f3a6c2338c695cc71a28cd8320e3bd2"}], "stats": {"total": 298, "additions": 263, "deletions": 35}, "files": [{"sha": "7e7fd22ee21007100eee0e5d98b097bf3cd3004e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18e0c3d1718157761e3f23ddc33ae22393bef15f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18e0c3d1718157761e3f23ddc33ae22393bef15f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=18e0c3d1718157761e3f23ddc33ae22393bef15f", "patch": "@@ -1,5 +1,18 @@\n 2018-11-05  Jakub Jelinek  <jakub@redhat.com>\n \n+\tPR tree-optimization/87859\n+\t* gimple-ssa-store-merging.c (struct merged_store_group): Add\n+\tonly_constants and first_nonmergeable_order members.\n+\t(merged_store_group::merged_store_group): Initialize them.\n+\t(merged_store_group::do_merge): Clear only_constants member if\n+\tadding something other than INTEGER_CST store.\n+\t(imm_store_chain_info::coalesce_immediate_stores): Don't merge\n+\tstores with order >= first_nonmergeable_order.  Use\n+\tmerged_store->only_constants instead of always recomputing it.\n+\tSet merged_store->first_nonmergeable_order if we've skipped any\n+\tstores.  Attempt to merge overlapping INTEGER_CST stores that\n+\twe would otherwise skip.\n+\n \tPR sanitizer/87837\n \t* match.pd (X + Y < X): Don't optimize if TYPE_OVERFLOW_SANITIZED.\n "}, {"sha": "e813e456d28fa58d716de6e27e984b32c8741b79", "filename": "gcc/gimple-ssa-store-merging.c", "status": "modified", "additions": 96, "deletions": 35, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18e0c3d1718157761e3f23ddc33ae22393bef15f/gcc%2Fgimple-ssa-store-merging.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18e0c3d1718157761e3f23ddc33ae22393bef15f/gcc%2Fgimple-ssa-store-merging.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-store-merging.c?ref=18e0c3d1718157761e3f23ddc33ae22393bef15f", "patch": "@@ -1429,6 +1429,8 @@ struct merged_store_group\n   unsigned int first_order;\n   unsigned int last_order;\n   bool bit_insertion;\n+  bool only_constants;\n+  unsigned int first_nonmergeable_order;\n \n   auto_vec<store_immediate_info *> stores;\n   /* We record the first and last original statements in the sequence because\n@@ -1821,6 +1823,8 @@ merged_store_group::merged_store_group (store_immediate_info *info)\n   val = NULL;\n   mask = NULL;\n   bit_insertion = false;\n+  only_constants = info->rhs_code == INTEGER_CST;\n+  first_nonmergeable_order = ~0U;\n   unsigned HOST_WIDE_INT align_bitpos = 0;\n   get_object_alignment_1 (gimple_assign_lhs (info->stmt),\n \t\t\t  &align, &align_bitpos);\n@@ -1936,6 +1940,8 @@ merged_store_group::do_merge (store_immediate_info *info)\n       first_order = info->order;\n       first_stmt = stmt;\n     }\n+  if (info->rhs_code != INTEGER_CST)\n+    only_constants = false;\n }\n \n /* Merge a store recorded by INFO into this merged store.\n@@ -2696,32 +2702,25 @@ imm_store_chain_info::coalesce_immediate_stores ()\n \t    }\n \t}\n \n+      if (info->order >= merged_store->first_nonmergeable_order)\n+\t;\n+\n       /* |---store 1---|\n \t       |---store 2---|\n \t Overlapping stores.  */\n-      if (IN_RANGE (info->bitpos, merged_store->start,\n-\t\t    merged_store->start + merged_store->width - 1))\n+      else if (IN_RANGE (info->bitpos, merged_store->start,\n+\t\t\t merged_store->start + merged_store->width - 1))\n \t{\n \t  /* Only allow overlapping stores of constants.  */\n-\t  if (info->rhs_code == INTEGER_CST)\n+\t  if (info->rhs_code == INTEGER_CST && merged_store->only_constants)\n \t    {\n-\t      bool only_constants = true;\n-\t      store_immediate_info *infoj;\n-\t      unsigned int j;\n-\t      FOR_EACH_VEC_ELT (merged_store->stores, j, infoj)\n-\t\tif (infoj->rhs_code != INTEGER_CST)\n-\t\t  {\n-\t\t    only_constants = false;\n-\t\t    break;\n-\t\t  }\n \t      unsigned int last_order\n \t\t= MAX (merged_store->last_order, info->order);\n \t      unsigned HOST_WIDE_INT end\n \t\t= MAX (merged_store->start + merged_store->width,\n \t\t       info->bitpos + info->bitsize);\n-\t      if (only_constants\n-\t\t  && check_no_overlap (m_store_info, i, INTEGER_CST,\n-\t\t\t\t       last_order, end))\n+\t      if (check_no_overlap (m_store_info, i, INTEGER_CST,\n+\t\t\t\t    last_order, end))\n \t\t{\n \t\t  /* check_no_overlap call above made sure there are no\n \t\t     overlapping stores with non-INTEGER_CST rhs_code\n@@ -2741,44 +2740,106 @@ imm_store_chain_info::coalesce_immediate_stores ()\n \t\t     store_by_bitpos order it comes after the last store that\n \t\t     we can't merge with them.  We can merge the first 3 stores\n \t\t     and keep the last store as is though.  */\n-\t\t  unsigned int len = m_store_info.length (), k = i;\n-\t\t  for (unsigned int j = i + 1; j < len; ++j)\n+\t\t  unsigned int len = m_store_info.length ();\n+\t\t  unsigned int try_order = last_order;\n+\t\t  unsigned int first_nonmergeable_order;\n+\t\t  unsigned int k;\n+\t\t  bool last_iter = false;\n+\t\t  int attempts = 0;\n+\t\t  do\n \t\t    {\n-\t\t      store_immediate_info *info2 = m_store_info[j];\n-\t\t      if (info2->bitpos >= end)\n-\t\t\tbreak;\n-\t\t      if (info2->order < last_order)\n+\t\t      unsigned int max_order = 0;\n+\t\t      unsigned first_nonmergeable_int_order = ~0U;\n+\t\t      unsigned HOST_WIDE_INT this_end = end;\n+\t\t      k = i;\n+\t\t      first_nonmergeable_order = ~0U;\n+\t\t      for (unsigned int j = i + 1; j < len; ++j)\n \t\t\t{\n-\t\t\t  if (info2->rhs_code != INTEGER_CST)\n+\t\t\t  store_immediate_info *info2 = m_store_info[j];\n+\t\t\t  if (info2->bitpos >= this_end)\n+\t\t\t    break;\n+\t\t\t  if (info2->order < try_order)\n+\t\t\t    {\n+\t\t\t      if (info2->rhs_code != INTEGER_CST)\n+\t\t\t\t{\n+\t\t\t\t  /* Normally check_no_overlap makes sure this\n+\t\t\t\t     doesn't happen, but if end grows below,\n+\t\t\t\t     then we need to process more stores than\n+\t\t\t\t     check_no_overlap verified.  Example:\n+\t\t\t\t      MEM[(int *)p_5] = 0;\n+\t\t\t\t      MEM[(short *)p_5 + 3B] = 1;\n+\t\t\t\t      MEM[(char *)p_5 + 4B] = _9;\n+\t\t\t\t      MEM[(char *)p_5 + 2B] = 2;  */\n+\t\t\t\t  k = 0;\n+\t\t\t\t  break;\n+\t\t\t\t}\n+\t\t\t      k = j;\n+\t\t\t      this_end = MAX (this_end,\n+\t\t\t\t\t      info2->bitpos + info2->bitsize);\n+\t\t\t    }\n+\t\t\t  else if (info2->rhs_code == INTEGER_CST\n+\t\t\t\t   && !last_iter)\n \t\t\t    {\n-\t\t\t      /* Normally check_no_overlap makes sure this\n-\t\t\t\t doesn't happen, but if end grows below, then\n-\t\t\t\t we need to process more stores than\n-\t\t\t\t check_no_overlap verified.  Example:\n-\t\t\t\t    MEM[(int *)p_5] = 0;\n-\t\t\t\t    MEM[(short *)p_5 + 3B] = 1;\n-\t\t\t\t    MEM[(char *)p_5 + 4B] = _9;\n-\t\t\t\t    MEM[(char *)p_5 + 2B] = 2;  */\n-\t\t\t      k = 0;\n-\t\t\t      break;\n+\t\t\t      max_order = MAX (max_order, info2->order + 1);\n+\t\t\t      first_nonmergeable_int_order\n+\t\t\t\t= MIN (first_nonmergeable_int_order,\n+\t\t\t\t       info2->order);\n \t\t\t    }\n-\t\t\t  k = j;\n-\t\t\t  end = MAX (end, info2->bitpos + info2->bitsize);\n+\t\t\t  else\n+\t\t\t    first_nonmergeable_order\n+\t\t\t      = MIN (first_nonmergeable_order, info2->order);\n+\t\t\t}\n+\t\t      if (k == 0)\n+\t\t\t{\n+\t\t\t  if (last_order == try_order)\n+\t\t\t    break;\n+\t\t\t  /* If this failed, but only because we grew\n+\t\t\t     try_order, retry with the last working one,\n+\t\t\t     so that we merge at least something.  */\n+\t\t\t  try_order = last_order;\n+\t\t\t  last_iter = true;\n+\t\t\t  continue;\n \t\t\t}\n+\t\t      last_order = try_order;\n+\t\t      /* Retry with a larger try_order to see if we could\n+\t\t\t merge some further INTEGER_CST stores.  */\n+\t\t      if (max_order\n+\t\t\t  && (first_nonmergeable_int_order\n+\t\t\t      < first_nonmergeable_order))\n+\t\t\t{\n+\t\t\t  try_order = MIN (max_order,\n+\t\t\t\t\t   first_nonmergeable_order);\n+\t\t\t  try_order\n+\t\t\t    = MIN (try_order,\n+\t\t\t\t   merged_store->first_nonmergeable_order);\n+\t\t\t  if (try_order > last_order && ++attempts < 16)\n+\t\t\t    continue;\n+\t\t\t}\n+\t\t      first_nonmergeable_order\n+\t\t\t= MIN (first_nonmergeable_order,\n+\t\t\t       first_nonmergeable_int_order);\n+\t\t      end = this_end;\n+\t\t      break;\n \t\t    }\n+\t\t  while (1);\n \n \t\t  if (k != 0)\n \t\t    {\n \t\t      merged_store->merge_overlapping (info);\n \n+\t\t      merged_store->first_nonmergeable_order\n+\t\t\t= MIN (merged_store->first_nonmergeable_order,\n+\t\t\t       first_nonmergeable_order);\n+\n \t\t      for (unsigned int j = i + 1; j <= k; j++)\n \t\t\t{\n \t\t\t  store_immediate_info *info2 = m_store_info[j];\n \t\t\t  gcc_assert (info2->bitpos < end);\n \t\t\t  if (info2->order < last_order)\n \t\t\t    {\n \t\t\t      gcc_assert (info2->rhs_code == INTEGER_CST);\n-\t\t\t      merged_store->merge_overlapping (info2);\n+\t\t\t      if (info != info2)\n+\t\t\t\tmerged_store->merge_overlapping (info2);\n \t\t\t    }\n \t\t\t  /* Other stores are kept and not merged in any\n \t\t\t     way.  */"}, {"sha": "712f513aa270f93697cd588c220ae6fda3e833a8", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18e0c3d1718157761e3f23ddc33ae22393bef15f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18e0c3d1718157761e3f23ddc33ae22393bef15f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=18e0c3d1718157761e3f23ddc33ae22393bef15f", "patch": "@@ -1,5 +1,9 @@\n 2018-11-05  Jakub Jelinek  <jakub@redhat.com>\n \n+\tPR tree-optimization/87859\n+\t* gcc.dg/store_merging_24.c: New test.\n+\t* gcc.dg/store_merging_25.c: New test.\n+\n \tPR sanitizer/87837\n \t* c-c++-common/ubsan/pr87837.c: New test.\n "}, {"sha": "744fe60e8e0bc58b38f32b3a17cdef601101f378", "filename": "gcc/testsuite/gcc.dg/store_merging_24.c", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18e0c3d1718157761e3f23ddc33ae22393bef15f/gcc%2Ftestsuite%2Fgcc.dg%2Fstore_merging_24.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18e0c3d1718157761e3f23ddc33ae22393bef15f/gcc%2Ftestsuite%2Fgcc.dg%2Fstore_merging_24.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstore_merging_24.c?ref=18e0c3d1718157761e3f23ddc33ae22393bef15f", "patch": "@@ -0,0 +1,75 @@\n+/* PR tree-optimization/87859 */\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -fdump-tree-store-merging-details\" } */\n+/* { dg-final { scan-tree-dump \"New sequence of \\[23] stores to replace old one of 19 stores\" \"store-merging\" { target i?86-*-* x86_64-*-* } } } */\n+/* { dg-final { scan-tree-dump \"New sequence of 1 stores to replace old one of 6 stores\" \"store-merging\" { target i?86-*-* x86_64-*-* } } } */\n+\n+struct S {\n+  union F {\n+    struct T {\n+#define A(n) unsigned n:1;\n+#define B(n) A(n##0) A(n##1) A(n##2) A(n##3) A(n##4) \\\n+\t     A(n##5) A(n##6) A(n##7) A(n##8) A(n##9)\n+      B(f) B(f1) B(f2) B(f3) B(f4) B(f5)\n+      A(f60) A(f61) A(f62) A(f63) A(f64) A(f65) A(f66)\n+    } q;\n+    unsigned int i[3];\n+  } f;\n+};\n+\n+struct S s = {\n+  .f.q.f0 = 1, .f.q.f1 = 1, .f.q.f2 = 1, .f.q.f5 = 1, .f.q.f6 = 1,\n+  .f.q.f7 = 1, .f.q.f8 = 1, .f.q.f9 = 1, .f.q.f13 = 1, .f.q.f14 = 1,\n+  .f.q.f15 = 1, .f.q.f16 = 1, .f.q.f17 = 1, .f.q.f19 = 1, .f.q.f21 = 1,\n+  .f.q.f66 = 1\n+};\n+\n+__attribute__((noipa)) void\n+bar (unsigned *x)\n+{\n+  if (x[0] != s.f.i[0] || x[1] != s.f.i[1] || x[2] != s.f.i[2])\n+    __builtin_abort ();\n+}\n+\n+__attribute__((noipa)) void\n+foo (unsigned char *state)\n+{\n+  struct S i;\n+  i.f.i[0] = 0;\n+  i.f.i[1] = 0;\n+  i.f.i[2] = 0;\n+  i.f.q.f7 = 1;\n+  i.f.q.f2 = 1;\n+  i.f.q.f21 = 1;\n+  i.f.q.f19 = 1;\n+  i.f.q.f14 = 1;\n+  i.f.q.f5 = 1;\n+  i.f.q.f0 = 1;\n+  i.f.q.f15 = 1;\n+  i.f.q.f16 = 1;\n+  i.f.q.f6 = 1;\n+  i.f.q.f9 = 1;\n+  i.f.q.f17 = 1;\n+  i.f.q.f1 = 1;\n+  i.f.q.f8 = 1;\n+  i.f.q.f13 = 1;\n+  i.f.q.f66 = 1;\n+  if (*state)\n+    {\n+      i.f.q.f37 = 1;\n+      i.f.q.f38 = 1;\n+      i.f.q.f39 = 1;\n+      i.f.q.f40 = 1;\n+      i.f.q.f41 = 1;\n+      i.f.q.f36 = 1;\n+    }\n+  bar (i.f.i);\n+}\n+\n+int\n+main ()\n+{\n+  unsigned char z = 0;\n+  foo (&z);\n+  return 0;\n+}"}, {"sha": "cf182190e9152dce3a87a489c19d6f639158e86c", "filename": "gcc/testsuite/gcc.dg/store_merging_25.c", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/18e0c3d1718157761e3f23ddc33ae22393bef15f/gcc%2Ftestsuite%2Fgcc.dg%2Fstore_merging_25.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/18e0c3d1718157761e3f23ddc33ae22393bef15f/gcc%2Ftestsuite%2Fgcc.dg%2Fstore_merging_25.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstore_merging_25.c?ref=18e0c3d1718157761e3f23ddc33ae22393bef15f", "patch": "@@ -0,0 +1,75 @@\n+/* PR tree-optimization/87859 */\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -fdump-tree-store-merging-details\" } */\n+/* { dg-final { scan-tree-dump \"New sequence of \\[23] stores to replace old one of 14 stores\" \"store-merging\" { target i?86-*-* x86_64-*-* } } } */\n+/* { dg-final { scan-tree-dump \"New sequence of 1 stores to replace old one of 6 stores\" \"store-merging\" { target i?86-*-* x86_64-*-* } } } */\n+\n+struct S {\n+  union F {\n+    struct T {\n+#define A(n) unsigned n:1;\n+#define B(n) A(n##0) A(n##1) A(n##2) A(n##3) A(n##4) \\\n+\t     A(n##5) A(n##6) A(n##7) A(n##8) A(n##9)\n+      B(f) B(f1) B(f2) B(f3) B(f4) B(f5)\n+      A(f60) A(f61) A(f62) A(f63) A(f64) A(f65) A(f66)\n+    } q;\n+    unsigned int i[3];\n+  } f;\n+};\n+\n+struct S s = {\n+  .f.q.f0 = 1, .f.q.f1 = 1, .f.q.f2 = 1, .f.q.f5 = 1, .f.q.f6 = 1,\n+  .f.q.f7 = 1, .f.q.f8 = 1, .f.q.f9 = 1, .f.q.f13 = 1, .f.q.f14 = 1,\n+  .f.q.f15 = 1, .f.q.f16 = 1, .f.q.f17 = 1, .f.q.f19 = 1, .f.q.f21 = 1,\n+  .f.q.f66 = 1\n+};\n+\n+__attribute__((noipa)) void\n+bar (unsigned *x)\n+{\n+  if (x[0] != s.f.i[0] || x[1] != s.f.i[1] || x[2] != s.f.i[2])\n+    __builtin_abort ();\n+}\n+\n+__attribute__((noipa)) void\n+foo (unsigned char *state, unsigned char c)\n+{\n+  struct S i;\n+  i.f.i[0] = 0;\n+  i.f.i[1] = 0;\n+  i.f.i[2] = 0;\n+  i.f.q.f7 = 1;\n+  i.f.q.f2 = 1;\n+  i.f.q.f21 = 1;\n+  i.f.q.f19 = 1;\n+  i.f.q.f14 = 1;\n+  i.f.q.f5 = 1;\n+  i.f.q.f0 = 1;\n+  i.f.q.f15 = 1;\n+  i.f.q.f16 = 1;\n+  i.f.q.f6 = 1;\n+  i.f.q.f9 = 1;\n+  i.f.q.f17 = c;\n+  i.f.q.f1 = 1;\n+  i.f.q.f8 = 1;\n+  i.f.q.f13 = 1;\n+  i.f.q.f66 = 1;\n+  if (*state)\n+    {\n+      i.f.q.f37 = 1;\n+      i.f.q.f38 = 1;\n+      i.f.q.f39 = 1;\n+      i.f.q.f40 = 1;\n+      i.f.q.f41 = 1;\n+      i.f.q.f36 = 1;\n+    }\n+  bar (i.f.i);\n+}\n+\n+int\n+main ()\n+{\n+  unsigned char z = 0;\n+  foo (&z, 1);\n+  return 0;\n+}"}]}