{"sha": "a211917585ca978a84123c4c934f2f68bb545bcd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTIxMTkxNzU4NWNhOTc4YTg0MTIzYzRjOTM0ZjJmNjhiYjU0NWJjZA==", "commit": {"author": {"name": "Yannick Moy", "email": "moy@adacore.com", "date": "2019-07-22T13:58:23Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2019-07-22T13:58:23Z"}, "message": "[Ada] Adapt ownership checking in SPARK to traversal functions\n\nA traversal function, especially when implemented as an expression\nfunction, may need to return an if-expression or case-expression, while\nstill respecting Legality Rule SPARK RM 3.10(5). This case is now\nallowed in GNATprove.\n\nThere is no impact on compilation.\n\n2019-07-22  Yannick Moy  <moy@adacore.com>\n\ngcc/ada/\n\n\t* sem_spark.adb (Get_Root_Object, Is_Path_Expression,\n\tIs_Subpath_Expression): Add parameter Is_Traversal to adapt\n\tthese functions to the case of paths returned from a traversal\n\tfunction.\n\t(Read_Indexes): Handle the case of an if-expression or\n\tcase-expression.\n\t(Check_Statement): Check Emit_Messages only when issuing an\n\terror message. This is important as Emit_Messages may store the\n\tinformation that an error was detected.\n\nFrom-SVN: r273693", "tree": {"sha": "e3c7490668db893acc003edd9ee3062f84c3f77b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e3c7490668db893acc003edd9ee3062f84c3f77b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a211917585ca978a84123c4c934f2f68bb545bcd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a211917585ca978a84123c4c934f2f68bb545bcd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a211917585ca978a84123c4c934f2f68bb545bcd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a211917585ca978a84123c4c934f2f68bb545bcd/comments", "author": {"login": "yannickmoy", "id": 859440, "node_id": "MDQ6VXNlcjg1OTQ0MA==", "avatar_url": "https://avatars.githubusercontent.com/u/859440?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yannickmoy", "html_url": "https://github.com/yannickmoy", "followers_url": "https://api.github.com/users/yannickmoy/followers", "following_url": "https://api.github.com/users/yannickmoy/following{/other_user}", "gists_url": "https://api.github.com/users/yannickmoy/gists{/gist_id}", "starred_url": "https://api.github.com/users/yannickmoy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yannickmoy/subscriptions", "organizations_url": "https://api.github.com/users/yannickmoy/orgs", "repos_url": "https://api.github.com/users/yannickmoy/repos", "events_url": "https://api.github.com/users/yannickmoy/events{/privacy}", "received_events_url": "https://api.github.com/users/yannickmoy/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8113b0c7385727d9969db2c8420bc0a3d6b8f0ed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8113b0c7385727d9969db2c8420bc0a3d6b8f0ed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8113b0c7385727d9969db2c8420bc0a3d6b8f0ed"}], "stats": {"total": 235, "additions": 217, "deletions": 18}, "files": [{"sha": "17d21f5430645b0a95a093682e44f8064357e89a", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a211917585ca978a84123c4c934f2f68bb545bcd/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a211917585ca978a84123c4c934f2f68bb545bcd/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=a211917585ca978a84123c4c934f2f68bb545bcd", "patch": "@@ -1,3 +1,15 @@\n+2019-07-22  Yannick Moy  <moy@adacore.com>\n+\n+\t* sem_spark.adb (Get_Root_Object, Is_Path_Expression,\n+\tIs_Subpath_Expression): Add parameter Is_Traversal to adapt\n+\tthese functions to the case of paths returned from a traversal\n+\tfunction.\n+\t(Read_Indexes): Handle the case of an if-expression or\n+\tcase-expression.\n+\t(Check_Statement): Check Emit_Messages only when issuing an\n+\terror message. This is important as Emit_Messages may store the\n+\tinformation that an error was detected.\n+\n 2019-07-22  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* checks.adb (Apply_Type_Conversion_Checks): Do not set"}, {"sha": "0de51f866fa52b9a62a12866d43b592ed1f08ed4", "filename": "gcc/ada/sem_spark.adb", "status": "modified", "additions": 205, "deletions": 18, "changes": 223, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a211917585ca978a84123c4c934f2f68bb545bcd/gcc%2Fada%2Fsem_spark.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a211917585ca978a84123c4c934f2f68bb545bcd/gcc%2Fada%2Fsem_spark.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_spark.adb?ref=a211917585ca978a84123c4c934f2f68bb545bcd", "patch": "@@ -715,10 +715,14 @@ package body Sem_SPARK is\n \n    function Get_Root_Object\n      (Expr              : Node_Id;\n-      Through_Traversal : Boolean := True) return Entity_Id;\n+      Through_Traversal : Boolean := True;\n+      Is_Traversal      : Boolean := False) return Entity_Id;\n    --  Return the root of the path expression Expr, or Empty for an allocator,\n    --  NULL, or a function call. Through_Traversal is True if it should follow\n-   --  through calls to traversal functions.\n+   --  through calls to traversal functions. Is_Traversal is True if this\n+   --  corresponds to a value returned from a traversal function, which should\n+   --  allow if-expressions and case-expressions that refer to the same root,\n+   --  even if the paths are not the same in all branches.\n \n    generic\n       with procedure Handle_Parameter_Or_Global\n@@ -745,11 +749,19 @@ package body Sem_SPARK is\n    --  A procedure that is called when deep globals or aliased globals are used\n    --  without any global aspect.\n \n-   function Is_Path_Expression (Expr : Node_Id) return Boolean;\n-   --  Return whether Expr corresponds to a path\n+   function Is_Path_Expression\n+     (Expr         : Node_Id;\n+      Is_Traversal : Boolean := False) return Boolean;\n+   --  Return whether Expr corresponds to a path. Is_Traversal is True if this\n+   --  corresponds to a value returned from a traversal function, which should\n+   --  allow if-expressions and case-expressions.\n \n-   function Is_Subpath_Expression (Expr : Node_Id) return Boolean;\n-   --  Return True if Expr can be part of a path expression\n+   function Is_Subpath_Expression\n+     (Expr         : Node_Id;\n+      Is_Traversal : Boolean := False) return Boolean;\n+   --  Return True if Expr can be part of a path expression. Is_Traversal is\n+   --  True if this corresponds to a value returned from a traversal function,\n+   --  which should allow if-expressions and case-expressions.\n \n    function Is_Prefix_Or_Almost (Pref, Expr : Node_Id) return Boolean;\n    --  Determine if the candidate Prefix is indeed a prefix of Expr, or almost\n@@ -1749,6 +1761,31 @@ package body Sem_SPARK is\n                   end loop;\n                end;\n \n+            when N_If_Expression =>\n+               declare\n+                  Cond      : constant Node_Id := First (Expressions (Expr));\n+                  Then_Part : constant Node_Id := Next (Cond);\n+                  Else_Part : constant Node_Id := Next (Then_Part);\n+               begin\n+                  Read_Expression (Cond);\n+                  Read_Indexes (Then_Part);\n+                  Read_Indexes (Else_Part);\n+               end;\n+\n+            when N_Case_Expression =>\n+               declare\n+                  Cases    : constant List_Id := Alternatives (Expr);\n+                  Cur_Case : Node_Id := First (Cases);\n+\n+               begin\n+                  Read_Expression (Expression (Expr));\n+\n+                  while Present (Cur_Case) loop\n+                     Read_Indexes (Expression (Cur_Case));\n+                     Next (Cur_Case);\n+                  end loop;\n+               end;\n+\n             when N_Attribute_Reference =>\n                pragma Assert\n                  (Get_Attribute_Id (Attribute_Name (Expr)) =\n@@ -3115,14 +3152,14 @@ package body Sem_SPARK is\n                      if Is_Anonymous_Access_Type (Return_Typ) then\n                         pragma Assert (Is_Traversal_Function (Subp));\n \n-                        if Nkind (Expr) /= N_Null and then Emit_Messages then\n+                        if Nkind (Expr) /= N_Null then\n                            declare\n                               Expr_Root : constant Entity_Id :=\n-                                Get_Root_Object (Expr);\n+                                Get_Root_Object (Expr, Is_Traversal => True);\n                               Param     : constant Entity_Id :=\n                                 First_Formal (Subp);\n                            begin\n-                              if Param /= Expr_Root then\n+                              if Param /= Expr_Root and then Emit_Messages then\n                                  Error_Msg_NE\n                                    (\"returned value must be rooted in \"\n                                     & \"traversed parameter & \"\n@@ -3642,10 +3679,31 @@ package body Sem_SPARK is\n \n    function Get_Root_Object\n      (Expr              : Node_Id;\n-      Through_Traversal : Boolean := True) return Entity_Id\n+      Through_Traversal : Boolean := True;\n+      Is_Traversal      : Boolean := False) return Entity_Id\n    is\n+      function GRO (Expr : Node_Id) return Entity_Id;\n+      --  Local wrapper on the actual function, to propagate the values of\n+      --  optional parameters.\n+\n+      ---------\n+      -- GRO --\n+      ---------\n+\n+      function GRO (Expr : Node_Id) return Entity_Id is\n+      begin\n+         return Get_Root_Object (Expr, Through_Traversal, Is_Traversal);\n+      end GRO;\n+\n+      Get_Root_Object : Boolean;\n+      pragma Unmodified (Get_Root_Object);\n+      --  Local variable to mask the name of function Get_Root_Object, to\n+      --  prevent direct call. Instead GRO wrapper should be called.\n+\n+   --  Start of processing for Get_Root_Object\n+\n    begin\n-      if not Is_Subpath_Expression (Expr) then\n+      if not Is_Subpath_Expression (Expr, Is_Traversal) then\n          if Emit_Messages then\n             Error_Msg_N (\"name expected here for path\", Expr);\n          end if;\n@@ -3663,7 +3721,7 @@ package body Sem_SPARK is\n             | N_Selected_Component\n             | N_Slice\n          =>\n-            return Get_Root_Object (Prefix (Expr), Through_Traversal);\n+            return GRO (Prefix (Expr));\n \n          --  There is no root object for an (extension) aggregate, allocator,\n          --  concat, or NULL.\n@@ -3684,7 +3742,7 @@ package body Sem_SPARK is\n             if Through_Traversal\n               and then Is_Traversal_Function_Call (Expr)\n             then\n-               return Get_Root_Object (First_Actual (Expr), Through_Traversal);\n+               return GRO (First_Actual (Expr));\n             else\n                return Empty;\n             end if;\n@@ -3693,7 +3751,7 @@ package body Sem_SPARK is\n             | N_Type_Conversion\n             | N_Unchecked_Type_Conversion\n          =>\n-            return Get_Root_Object (Expression (Expr), Through_Traversal);\n+            return GRO (Expression (Expr));\n \n          when N_Attribute_Reference =>\n             pragma Assert\n@@ -3706,6 +3764,69 @@ package body Sem_SPARK is\n                  Attribute_Image);\n             return Empty;\n \n+         when N_If_Expression =>\n+            if Is_Traversal then\n+               declare\n+                  Cond      : constant Node_Id := First (Expressions (Expr));\n+                  Then_Part : constant Node_Id := Next (Cond);\n+                  Else_Part : constant Node_Id := Next (Then_Part);\n+                  Then_Root : constant Entity_Id := GRO (Then_Part);\n+                  Else_Root : constant Entity_Id := GRO (Else_Part);\n+               begin\n+                  if Nkind (Then_Part) = N_Null then\n+                     return Else_Root;\n+                  elsif Nkind (Else_Part) = N_Null then\n+                     return Then_Part;\n+                  elsif Then_Root = Else_Root then\n+                     return Then_Root;\n+                  else\n+                     if Emit_Messages then\n+                        Error_Msg_N\n+                          (\"same name expected here in each branch\", Expr);\n+                     end if;\n+                     return Empty;\n+                  end if;\n+               end;\n+            else\n+               if Emit_Messages then\n+                  Error_Msg_N (\"name expected here for path\", Expr);\n+               end if;\n+               return Empty;\n+            end if;\n+\n+         when N_Case_Expression =>\n+            if Is_Traversal then\n+               declare\n+                  Cases       : constant List_Id := Alternatives (Expr);\n+                  Cur_Case    : Node_Id := First (Cases);\n+                  Cur_Root    : Entity_Id;\n+                  Common_Root : Entity_Id := Empty;\n+\n+               begin\n+                  while Present (Cur_Case) loop\n+                     Cur_Root := GRO (Expression (Cur_Case));\n+\n+                     if Common_Root = Empty then\n+                        Common_Root := Cur_Root;\n+                     elsif Common_Root /= Cur_Root then\n+                        if Emit_Messages then\n+                           Error_Msg_N\n+                             (\"same name expected here in each branch\", Expr);\n+                        end if;\n+                        return Empty;\n+                     end if;\n+                     Next (Cur_Case);\n+                  end loop;\n+\n+                  return Common_Root;\n+               end;\n+            else\n+               if Emit_Messages then\n+                  Error_Msg_N (\"name expected here for path\", Expr);\n+               end if;\n+               return Empty;\n+            end if;\n+\n          when others =>\n             raise Program_Error;\n       end case;\n@@ -3876,7 +3997,30 @@ package body Sem_SPARK is\n    -- Is_Path_Expression --\n    ------------------------\n \n-   function Is_Path_Expression (Expr : Node_Id) return Boolean is\n+   function Is_Path_Expression\n+     (Expr         : Node_Id;\n+      Is_Traversal : Boolean := False) return Boolean\n+   is\n+      function IPE (Expr : Node_Id) return Boolean;\n+      --  Local wrapper on the actual function, to propagate the values of\n+      --  optional parameter Is_Traversal.\n+\n+      ---------\n+      -- IPE --\n+      ---------\n+\n+      function IPE (Expr : Node_Id) return Boolean is\n+      begin\n+         return Is_Path_Expression (Expr, Is_Traversal);\n+      end IPE;\n+\n+      Is_Path_Expression : Boolean;\n+      pragma Unmodified (Is_Path_Expression);\n+      --  Local variable to mask the name of function Is_Path_Expression, to\n+      --  prevent direct call. Instead IPE wrapper should be called.\n+\n+   --  Start of processing for Is_Path_Expression\n+\n    begin\n       case Nkind (Expr) is\n          when N_Expanded_Name\n@@ -3907,7 +4051,47 @@ package body Sem_SPARK is\n             | N_Type_Conversion\n             | N_Unchecked_Type_Conversion\n          =>\n-            return Is_Path_Expression (Expression (Expr));\n+            return IPE (Expression (Expr));\n+\n+         --  When returning from a traversal function, consider an\n+         --  if-expression as a possible path expression.\n+\n+         when N_If_Expression =>\n+            if Is_Traversal then\n+               declare\n+                  Cond      : constant Node_Id := First (Expressions (Expr));\n+                  Then_Part : constant Node_Id := Next (Cond);\n+                  Else_Part : constant Node_Id := Next (Then_Part);\n+               begin\n+                  return IPE (Then_Part)\n+                    and then IPE (Else_Part);\n+               end;\n+            else\n+               return False;\n+            end if;\n+\n+         --  When returning from a traversal function, consider\n+         --  a case-expression as a possible path expression.\n+\n+         when N_Case_Expression =>\n+            if Is_Traversal then\n+               declare\n+                  Cases    : constant List_Id := Alternatives (Expr);\n+                  Cur_Case : Node_Id := First (Cases);\n+\n+               begin\n+                  while Present (Cur_Case) loop\n+                     if not IPE (Expression (Cur_Case)) then\n+                        return False;\n+                     end if;\n+                     Next (Cur_Case);\n+                  end loop;\n+\n+                  return True;\n+               end;\n+            else\n+               return False;\n+            end if;\n \n          when others =>\n             return False;\n@@ -4033,9 +4217,12 @@ package body Sem_SPARK is\n    -- Is_Subpath_Expression --\n    ---------------------------\n \n-   function Is_Subpath_Expression (Expr : Node_Id) return Boolean is\n+   function Is_Subpath_Expression\n+     (Expr         : Node_Id;\n+      Is_Traversal : Boolean := False) return Boolean\n+   is\n    begin\n-      return Is_Path_Expression (Expr)\n+      return Is_Path_Expression (Expr, Is_Traversal)\n         or else (Nkind (Expr) = N_Attribute_Reference\n                   and then\n                     (Get_Attribute_Id (Attribute_Name (Expr)) ="}]}