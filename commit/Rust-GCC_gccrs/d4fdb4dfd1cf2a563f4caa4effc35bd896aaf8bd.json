{"sha": "d4fdb4dfd1cf2a563f4caa4effc35bd896aaf8bd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDRmZGI0ZGZkMWNmMmE1NjNmNGNhYTRlZmZjMzViZDg5NmFhZjhiZA==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2013-11-22T18:52:23Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2013-11-22T18:52:23Z"}, "message": "tree-ssa-threadedge.c (record_temporary_equivalence): Handle NULL for RHS, which we used to invalidate equivalences.\n\n\t* tree-ssa-threadedge.c (record_temporary_equivalence): Handle\n\tNULL for RHS, which we used to invalidate equivalences.\n\t(record_temporary_equivalences_from_phis): New bitmap arguments\n\tand a boolean indicating if we have passed a backedge.  If we\n\thave passed a backedge, then set the appropriate bit in the\n\tbitmaps for the SRC & DEST of PHIs creating equivalences.\n\t(invalidate_equivalences, dummy_simplify): New functions.\n\t(cond_arg_set_in_b): Remove.\n\t(record_temporary_equivalences_from_stmts_at_dest): New bitmap\n\targuments and a boolean indicating if we have passed a backedge.\n\tIf we have passed a backedge, then perform invalidations as\n\tneeded.\n\t(thread_around_empty_blocks): If we have seen a backedge, then\n\tuse the dummy simplify routine.\n\t(thread_through_normal_block): Likewise.  Pass bitmaps and\n\tbackedge status to children.  Do not pessimize so much when\n\ttraversing backedges in the CFG.\n\t(thread_across_edge): Manage the SRC_MAP/DST_MAP bitmaps.\n\tIf we have seen a backedge, then use the dummy simplify routine.\n\tDo not pessimize so much when traversing backedges.\n\nFrom-SVN: r205279", "tree": {"sha": "730948c2473885606c6944bb48f26a75b3b88427", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/730948c2473885606c6944bb48f26a75b3b88427"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d4fdb4dfd1cf2a563f4caa4effc35bd896aaf8bd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d4fdb4dfd1cf2a563f4caa4effc35bd896aaf8bd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d4fdb4dfd1cf2a563f4caa4effc35bd896aaf8bd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d4fdb4dfd1cf2a563f4caa4effc35bd896aaf8bd/comments", "author": null, "committer": null, "parents": [{"sha": "7d20ca6146e4ee527f9c48fb96d0ca83d3fb68c3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d20ca6146e4ee527f9c48fb96d0ca83d3fb68c3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7d20ca6146e4ee527f9c48fb96d0ca83d3fb68c3"}], "stats": {"total": 268, "additions": 183, "deletions": 85}, "files": [{"sha": "c404713119f18e75e52ec41f95c2cd75a99f00de", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4fdb4dfd1cf2a563f4caa4effc35bd896aaf8bd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4fdb4dfd1cf2a563f4caa4effc35bd896aaf8bd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d4fdb4dfd1cf2a563f4caa4effc35bd896aaf8bd", "patch": "@@ -1,3 +1,26 @@\n+2013-11-22  Jeff Law  <law@redhat.com>\n+\n+\t* tree-ssa-threadedge.c (record_temporary_equivalence): Handle\n+\tNULL for RHS, which we used to invalidate equivalences.\n+\t(record_temporary_equivalences_from_phis): New bitmap arguments\n+\tand a boolean indicating if we have passed a backedge.  If we\n+\thave passed a backedge, then set the appropriate bit in the\n+\tbitmaps for the SRC & DEST of PHIs creating equivalences.\n+\t(invalidate_equivalences, dummy_simplify): New functions.\n+\t(cond_arg_set_in_b): Remove.\n+\t(record_temporary_equivalences_from_stmts_at_dest): New bitmap\n+\targuments and a boolean indicating if we have passed a backedge.\n+\tIf we have passed a backedge, then perform invalidations as\n+\tneeded.\n+\t(thread_around_empty_blocks): If we have seen a backedge, then\n+\tuse the dummy simplify routine.\n+\t(thread_through_normal_block): Likewise.  Pass bitmaps and\n+\tbackedge status to children.  Do not pessimize so much when\n+\ttraversing backedges in the CFG.\n+\t(thread_across_edge): Manage the SRC_MAP/DST_MAP bitmaps.\n+\tIf we have seen a backedge, then use the dummy simplify routine.\n+\tDo not pessimize so much when traversing backedges.\n+\n 2013-11-22  Hans-Peter Nilsson  <hp@axis.com>\n \n \t* config/cris/cris.c (cris_atomic_align_for_mode): New function."}, {"sha": "cb6accf08f4e6693ee15ad7a62c80d8764725f14", "filename": "gcc/tree-ssa-threadedge.c", "status": "modified", "additions": 160, "deletions": 85, "changes": 245, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4fdb4dfd1cf2a563f4caa4effc35bd896aaf8bd/gcc%2Ftree-ssa-threadedge.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4fdb4dfd1cf2a563f4caa4effc35bd896aaf8bd/gcc%2Ftree-ssa-threadedge.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadedge.c?ref=d4fdb4dfd1cf2a563f4caa4effc35bd896aaf8bd", "patch": "@@ -175,7 +175,8 @@ record_temporary_equivalence (tree x, tree y, vec<tree> *stack)\n {\n   tree prev_x = SSA_NAME_VALUE (x);\n \n-  if (TREE_CODE (y) == SSA_NAME)\n+  /* Y may be NULL if we are invalidating entries in the table.  */\n+  if (y && TREE_CODE (y) == SSA_NAME)\n     {\n       tree tmp = SSA_NAME_VALUE (y);\n       y = tmp ? tmp : y;\n@@ -191,10 +192,16 @@ record_temporary_equivalence (tree x, tree y, vec<tree> *stack)\n    edge E.  Record unwind information for the equivalences onto STACK.\n \n    If a PHI which prevents threading is encountered, then return FALSE\n-   indicating we should not thread this edge, else return TRUE.  */\n+   indicating we should not thread this edge, else return TRUE. \n+\n+   If SRC_MAP/DST_MAP exist, then mark the source and destination SSA_NAMEs\n+   of any equivalences recorded.  We use this to make invalidation after\n+   traversing back edges less painful.  */\n \n static bool\n-record_temporary_equivalences_from_phis (edge e, vec<tree> *stack)\n+record_temporary_equivalences_from_phis (edge e, vec<tree> *stack,\n+\t\t\t\t\t bool backedge_seen,\n+\t\t\t\t\t bitmap src_map, bitmap dst_map)\n {\n   gimple_stmt_iterator gsi;\n \n@@ -222,6 +229,14 @@ record_temporary_equivalences_from_phis (edge e, vec<tree> *stack)\n \tstmt_count++;\n \n       record_temporary_equivalence (dst, src, stack);\n+\n+      /* If we have crossed a backedge, then start recording equivalences\n+\t we might need to invalidate.  */\n+      if (backedge_seen && TREE_CODE (src) == SSA_NAME)\n+\t{\n+\t  bitmap_set_bit (src_map, SSA_NAME_VERSION (src));\n+\t  bitmap_set_bit (dst_map, SSA_NAME_VERSION (dst));\n+\t}\n     }\n   return true;\n }\n@@ -276,6 +291,34 @@ fold_assignment_stmt (gimple stmt)\n     }\n }\n \n+/* A new value has been assigned to LHS.  If necessary, invalidate any\n+   equivalences that are no longer valid.  */\n+static void\n+invalidate_equivalences (tree lhs, vec<tree> *stack,\n+\t\t\t bitmap src_map, bitmap dst_map)\n+{\n+  /* SRC_MAP contains the source SSA_NAMEs for equivalences created by PHI\n+     nodes.  If an entry in SRC_MAP changes, there's some destination that\n+     has been recorded as equivalent to the source and that equivalency\n+     needs to be eliminated.  */\n+  if (bitmap_bit_p (src_map, SSA_NAME_VERSION (lhs)))\n+    {\n+      unsigned int i;\n+      bitmap_iterator bi;\n+\n+      /* We know that the LHS of STMT was used as the RHS in an equivalency\n+\t created by a PHI.  All the LHS of such PHIs were recorded into DST_MAP.\n+\t So we can iterate over them to see if any have the LHS of STMT as\n+\t an equivalence, and if so, remove the equivalence as it is no longer\n+\t valid.  */\n+      EXECUTE_IF_SET_IN_BITMAP (dst_map, 0, i, bi)\n+\t{\n+\t  if (SSA_NAME_VALUE (ssa_name (i)) == lhs)\n+\t    record_temporary_equivalence (ssa_name (i), NULL_TREE, stack);\n+\t}\n+    }\n+}\n+\n /* Try to simplify each statement in E->dest, ultimately leading to\n    a simplification of the COND_EXPR at the end of E->dest.\n \n@@ -297,7 +340,10 @@ static gimple\n record_temporary_equivalences_from_stmts_at_dest (edge e,\n \t\t\t\t\t\t  vec<tree> *stack,\n \t\t\t\t\t\t  tree (*simplify) (gimple,\n-\t\t\t\t\t\t\t\t    gimple))\n+\t\t\t\t\t\t\t\t    gimple),\n+\t\t\t\t\t\t  bool backedge_seen,\n+\t\t\t\t\t\t  bitmap src_map,\n+\t\t\t\t\t\t  bitmap dst_map)\n {\n   gimple stmt = NULL;\n   gimple_stmt_iterator gsi;\n@@ -374,7 +420,15 @@ record_temporary_equivalences_from_stmts_at_dest (edge e,\n \t  if (fndecl\n \t      && (DECL_FUNCTION_CODE (fndecl) == BUILT_IN_OBJECT_SIZE\n \t\t  || DECL_FUNCTION_CODE (fndecl) == BUILT_IN_CONSTANT_P))\n-\t    continue;\n+\t    {\n+\t      if (backedge_seen)\n+\t\t{\n+\t\t  tree lhs = gimple_get_lhs (stmt);\n+\t\t  record_temporary_equivalence (lhs, NULL_TREE, stack);\n+\t\t  invalidate_equivalences (lhs, stack, src_map, dst_map);\n+\t\t}\n+\t      continue;\n+\t    }\n \t}\n \n       /* At this point we have a statement which assigns an RHS to an\n@@ -438,15 +492,36 @@ record_temporary_equivalences_from_stmts_at_dest (edge e,\n \t}\n \n       /* Record the context sensitive equivalence if we were able\n-\t to simplify this statement.  */\n+\t to simplify this statement. \n+\n+\t If we have traversed a backedge at some point during threading,\n+\t then always enter something here.  Either a real equivalence, \n+\t or a NULL_TREE equivalence which is effectively invalidation of\n+\t prior equivalences.  */\n       if (cached_lhs\n \t  && (TREE_CODE (cached_lhs) == SSA_NAME\n \t      || is_gimple_min_invariant (cached_lhs)))\n \trecord_temporary_equivalence (gimple_get_lhs (stmt), cached_lhs, stack);\n+      else if (backedge_seen)\n+\trecord_temporary_equivalence (gimple_get_lhs (stmt), NULL_TREE, stack);\n+\n+      if (backedge_seen)\n+\tinvalidate_equivalences (gimple_get_lhs (stmt), stack,\n+\t\t\t\t src_map, dst_map);\n     }\n   return stmt;\n }\n \n+/* Once we have passed a backedge in the CFG when threading, we do not want to\n+   utilize edge equivalences for simplification purpose.  They are no longer\n+   necessarily valid.  We use this callback rather than the ones provided by\n+   DOM/VRP to achieve that effect.  */\n+static tree\n+dummy_simplify (gimple stmt1 ATTRIBUTE_UNUSED, gimple stmt2 ATTRIBUTE_UNUSED)\n+{\n+  return NULL_TREE;\n+}\n+\n /* Simplify the control statement at the end of the block E->dest.\n \n    To avoid allocating memory unnecessarily, a scratch GIMPLE_COND\n@@ -586,44 +661,6 @@ simplify_control_stmt_condition (edge e,\n   return cached_lhs;\n }\n \n-/* Return TRUE if the statement at the end of e->dest depends on\n-   the output of any statement in BB.   Otherwise return FALSE.\n-\n-   This is used when we are threading a backedge and need to ensure\n-   that temporary equivalences from BB do not affect the condition\n-   in e->dest.  */\n-\n-static bool\n-cond_arg_set_in_bb (edge e, basic_block bb)\n-{\n-  ssa_op_iter iter;\n-  use_operand_p use_p;\n-  gimple last = last_stmt (e->dest);\n-\n-  /* E->dest does not have to end with a control transferring\n-     instruction.  This can occur when we try to extend a jump\n-     threading opportunity deeper into the CFG.  In that case\n-     it is safe for this check to return false.  */\n-  if (!last)\n-    return false;\n-\n-  if (gimple_code (last) != GIMPLE_COND\n-      && gimple_code (last) != GIMPLE_GOTO\n-      && gimple_code (last) != GIMPLE_SWITCH)\n-    return false;\n-\n-  FOR_EACH_SSA_USE_OPERAND (use_p, last, iter, SSA_OP_USE | SSA_OP_VUSE)\n-    {\n-      tree use = USE_FROM_PTR (use_p);\n-\n-      if (TREE_CODE (use) == SSA_NAME\n-\t  && gimple_code (SSA_NAME_DEF_STMT (use)) != GIMPLE_PHI\n-\t  && gimple_bb (SSA_NAME_DEF_STMT (use)) == bb)\n-\treturn true;\n-    }\n-  return false;\n-}\n-\n /* Copy debug stmts from DEST's chain of single predecessors up to\n    SRC, so that we don't lose the bindings as PHI nodes are introduced\n    when DEST gains new predecessors.  */\n@@ -810,6 +847,8 @@ thread_around_empty_blocks (edge taken_edge,\n \t      path->safe_push (x);\n \t      bitmap_set_bit (visited, taken_edge->dest->index);\n \t      *backedge_seen_p |= ((taken_edge->flags & EDGE_DFS_BACK) != 0);\n+\t      if (*backedge_seen_p)\n+\t\tsimplify = dummy_simplify;\n \t      return thread_around_empty_blocks (taken_edge,\n \t\t\t\t\t\t dummy_cond,\n \t\t\t\t\t\t handle_dominating_asserts,\n@@ -832,6 +871,13 @@ thread_around_empty_blocks (edge taken_edge,\n       && gimple_code (stmt) != GIMPLE_SWITCH)\n     return false;\n \n+  /* If we have traversed a backedge, then we do not want to look\n+     at certain expressions in the table that can not be relied upon.\n+     Luckily the only code that looked at those expressions is the\n+     SIMPLIFY callback, which we replace if we can no longer use it.  */\n+  if (*backedge_seen_p)\n+    simplify = dummy_simplify;\n+\n   /* Extract and simplify the condition.  */\n   cond = simplify_control_stmt_condition (taken_edge, stmt, dummy_cond,\n \t\t\t\t\t  simplify, handle_dominating_asserts);\n@@ -851,6 +897,8 @@ thread_around_empty_blocks (edge taken_edge,\n \t= new jump_thread_edge (taken_edge, EDGE_NO_COPY_SRC_BLOCK);\n       path->safe_push (x);\n       *backedge_seen_p |= ((taken_edge->flags & EDGE_DFS_BACK) != 0);\n+      if (*backedge_seen_p)\n+\tsimplify = dummy_simplify;\n \n       thread_around_empty_blocks (taken_edge,\n \t\t\t\t  dummy_cond,\n@@ -901,24 +949,28 @@ thread_through_normal_block (edge e,\n \t\t\t     tree (*simplify) (gimple, gimple),\n \t\t\t     vec<jump_thread_edge *> *path,\n \t\t\t     bitmap visited,\n-\t\t\t     bool *backedge_seen_p)\n+\t\t\t     bool *backedge_seen_p,\n+\t\t\t     bitmap src_map,\n+\t\t\t     bitmap dst_map)\n {\n-  /* If we have crossed a backedge, then we want to verify that the COND_EXPR,\n-     SWITCH_EXPR or GOTO_EXPR at the end of e->dest is not affected\n-     by any statements in e->dest.  If it is affected, then it is not\n-     safe to thread this edge.  */\n-  if (*backedge_seen_p\n-      && cond_arg_set_in_bb (e, e->dest))\n-    return false;\n+  /* If we have traversed a backedge, then we do not want to look\n+     at certain expressions in the table that can not be relied upon.\n+     Luckily the only code that looked at those expressions is the\n+     SIMPLIFY callback, which we replace if we can no longer use it.  */\n+  if (*backedge_seen_p)\n+    simplify = dummy_simplify;\n \n   /* PHIs create temporary equivalences.  */\n-  if (!record_temporary_equivalences_from_phis (e, stack))\n+  if (!record_temporary_equivalences_from_phis (e, stack, *backedge_seen_p,\n+\t\t\t\t\t\tsrc_map, dst_map))\n     return false;\n \n   /* Now walk each statement recording any context sensitive\n      temporary equivalences we can detect.  */\n   gimple stmt\n-    = record_temporary_equivalences_from_stmts_at_dest (e, stack, simplify);\n+    = record_temporary_equivalences_from_stmts_at_dest (e, stack, simplify,\n+\t\t\t\t\t\t\t*backedge_seen_p,\n+\t\t\t\t\t\t\tsrc_map, dst_map);\n   if (!stmt)\n     return false;\n \n@@ -960,25 +1012,24 @@ thread_through_normal_block (edge e,\n \t    = new jump_thread_edge (taken_edge, EDGE_COPY_SRC_BLOCK);\n \t  path->safe_push (x);\n \t  *backedge_seen_p |= ((taken_edge->flags & EDGE_DFS_BACK) != 0);\n+\t  if (*backedge_seen_p)\n+\t    simplify = dummy_simplify;\n \n \t  /* See if we can thread through DEST as well, this helps capture\n \t     secondary effects of threading without having to re-run DOM or\n-\t     VRP.  */\n-\t  if (!*backedge_seen_p\n-\t      || ! cond_arg_set_in_bb (taken_edge, e->dest))\n-\t    {\n-\t      /* We don't want to thread back to a block we have already\n- \t\t visited.  This may be overly conservative.  */\n-\t      bitmap_set_bit (visited, dest->index);\n-\t      bitmap_set_bit (visited, e->dest->index);\n-\t      thread_around_empty_blocks (taken_edge,\n-\t\t\t\t\t  dummy_cond,\n-\t\t\t\t\t  handle_dominating_asserts,\n-\t\t\t\t\t  simplify,\n-\t\t\t\t\t  visited,\n-\t\t\t\t\t  path,\n-\t\t\t\t\t  backedge_seen_p);\n-\t    }\n+\t     VRP. \n+\n+\t     We don't want to thread back to a block we have already\n+ \t     visited.  This may be overly conservative.  */\n+\t  bitmap_set_bit (visited, dest->index);\n+\t  bitmap_set_bit (visited, e->dest->index);\n+\t  thread_around_empty_blocks (taken_edge,\n+\t\t\t\t      dummy_cond,\n+\t\t\t\t      handle_dominating_asserts,\n+\t\t\t\t      simplify,\n+\t\t\t\t      visited,\n+\t\t\t\t      path,\n+\t\t\t\t      backedge_seen_p);\n \t  return true;\n \t}\n     }\n@@ -1020,6 +1071,8 @@ thread_across_edge (gimple dummy_cond,\n \t\t    tree (*simplify) (gimple, gimple))\n {\n   bitmap visited = BITMAP_ALLOC (NULL);\n+  bitmap src_map = BITMAP_ALLOC (NULL);\n+  bitmap dst_map = BITMAP_ALLOC (NULL);\n   bool backedge_seen;\n \n   stmt_count = 0;\n@@ -1029,14 +1082,19 @@ thread_across_edge (gimple dummy_cond,\n   bitmap_set_bit (visited, e->src->index);\n   bitmap_set_bit (visited, e->dest->index);\n   backedge_seen = ((e->flags & EDGE_DFS_BACK) != 0);\n+  if (backedge_seen)\n+    simplify = dummy_simplify;\n+\n   if (thread_through_normal_block (e, dummy_cond, handle_dominating_asserts,\n \t\t\t\t   stack, simplify, path, visited,\n-\t\t\t\t   &backedge_seen))\n+\t\t\t\t   &backedge_seen, src_map, dst_map))\n     {\n       propagate_threaded_block_debug_into (path->last ()->e->dest,\n \t\t\t\t\t   e->dest);\n       remove_temporary_equivalences (stack);\n       BITMAP_FREE (visited);\n+      BITMAP_FREE (src_map);\n+      BITMAP_FREE (dst_map);\n       register_jump_thread (path);\n       return;\n     }\n@@ -1071,15 +1129,26 @@ thread_across_edge (gimple dummy_cond,\n \t{\n \t  remove_temporary_equivalences (stack);\n \t  BITMAP_FREE (visited);\n+\t  BITMAP_FREE (src_map);\n+\t  BITMAP_FREE (dst_map);\n \t  return;\n \t}\n \n+    /* We need to restore the state of the maps to this point each loop\n+       iteration.  */\n+    bitmap src_map_copy = BITMAP_ALLOC (NULL);\n+    bitmap dst_map_copy = BITMAP_ALLOC (NULL);\n+    bitmap_copy (src_map_copy, src_map);\n+    bitmap_copy (dst_map_copy, dst_map);\n+\n     /* Look at each successor of E->dest to see if we can thread through it.  */\n     FOR_EACH_EDGE (taken_edge, ei, e->dest->succs)\n       {\n \t/* Push a fresh marker so we can unwind the equivalences created\n \t   for each of E->dest's successors.  */\n \tstack->safe_push (NULL_TREE);\n+\tbitmap_copy (src_map, src_map_copy);\n+\tbitmap_copy (dst_map, dst_map_copy);\n      \n \t/* Avoid threading to any block we have already visited.  */\n \tbitmap_clear (visited);\n@@ -1098,23 +1167,25 @@ thread_across_edge (gimple dummy_cond,\n \tfound = false;\n \tbackedge_seen = ((e->flags & EDGE_DFS_BACK) != 0);\n \tbackedge_seen |= ((taken_edge->flags & EDGE_DFS_BACK) != 0);\n-\tif (!backedge_seen\n-\t    || ! cond_arg_set_in_bb (path->last ()->e, e->dest))\n-\t  found = thread_around_empty_blocks (taken_edge,\n-\t\t\t\t\t      dummy_cond,\n-\t\t\t\t\t      handle_dominating_asserts,\n-\t\t\t\t\t      simplify,\n-\t\t\t\t\t      visited,\n-\t\t\t\t\t      path,\n-\t\t\t\t\t      &backedge_seen);\n-\n-\tif (!found\n-\t    && (!backedge_seen\n-\t\t|| ! cond_arg_set_in_bb (path->last ()->e, e->dest)))\n+\tif (backedge_seen)\n+\t  simplify = dummy_simplify;\n+\tfound = thread_around_empty_blocks (taken_edge,\n+\t\t\t\t\t    dummy_cond,\n+\t\t\t\t\t    handle_dominating_asserts,\n+\t\t\t\t\t    simplify,\n+\t\t\t\t\t    visited,\n+\t\t\t\t\t    path,\n+\t\t\t\t\t    &backedge_seen);\n+\n+\tif (backedge_seen)\n+\t  simplify = dummy_simplify;\n+\n+\tif (!found)\n \t  found = thread_through_normal_block (path->last ()->e, dummy_cond,\n \t\t\t\t\t       handle_dominating_asserts,\n \t\t\t\t\t       stack, simplify, path, visited,\n-\t\t\t\t\t       &backedge_seen);\n+\t\t\t\t\t       &backedge_seen,\n+\t\t\t\t\t       src_map, dst_map);\n \n \t/* If we were able to thread through a successor of E->dest, then\n \t   record the jump threading opportunity.  */\n@@ -1133,6 +1204,10 @@ thread_across_edge (gimple dummy_cond,\n \tremove_temporary_equivalences (stack);\n       }\n     BITMAP_FREE (visited);\n+    BITMAP_FREE (src_map);\n+    BITMAP_FREE (dst_map);\n+    BITMAP_FREE (src_map_copy);\n+    BITMAP_FREE (dst_map_copy);\n   }\n \n   remove_temporary_equivalences (stack);"}]}