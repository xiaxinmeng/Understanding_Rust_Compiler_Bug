{"sha": "7c209481147555ddd22296b1eff0fd1833588d35", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2MyMDk0ODExNDc1NTVkZGQyMjI5NmIxZWZmMGZkMTgzMzU4OGQzNQ==", "commit": {"author": {"name": "Georg-Johann Lay", "email": "avr@gjlay.de", "date": "2011-11-15T09:01:46Z"}, "committer": {"name": "Georg-Johann Lay", "email": "gjl@gcc.gnu.org", "date": "2011-11-15T09:01:46Z"}, "message": "re PR target/49868 (Implement named address space to place/access data in flash memory)\n\ngcc/\n\tPR target/49868\n\t* config/avr/avr.h (ADDR_SPACE_PGM): New address spaces.\n\t(REGISTER_TARGET_PRAGMAS): New define.\n\t* config/avr/avr-protos.h (avr_mem_pgm_p): New.\n\t(avr_load_libgcc_p): New.\n\t(asm_output_external_libcall): Remove.\n\t(avr_register_target_pragmas): New.\n\t(avr_log_t): Add field \"progmem\".  Order alphabetically.\n\t* config/avr/avr-log.c (avr_log_set_avr_log): Set avr_log.progmem.\n\t* config/avr/avr-c.c (langhooks.h): New include.\n\t(avr_register_target_pragmas): New function. Register address\n\tspace __pgm.\n\t(avr_cpu_cpp_builtins): Add built-in define __PGM.\n\t* config/avr/avr.c: Include \"c-family/c-common.h\".\n\t(TARGET_LEGITIMATE_ADDRESS_P): Remove define.\n\t(TARGET_LEGITIMIZE_ADDRESS): Remove define.\n\t(TARGET_ADDR_SPACE_SUBSET_P): Define to...\n\t(avr_addr_space_subset_p): ...this new static function.\n\t(TARGET_ADDR_SPACE_CONVERT): Define to...\n\t(avr_addr_space_convert): ...this new static function.\n\t(TARGET_ADDR_SPACE_ADDRESS_MODE): Define to...\n\t(avr_addr_space_address_mode): ...this new static function.\n\t(TARGET_ADDR_SPACE_POINTER_MODE): Define to...\n\t(avr_addr_space_pointer_mode): ...this new static function.\n\t(TARGET_ADDR_SPACE_LEGITIMATE_ADDRESS_P): Define to...\n\t(avr_addr_space_legitimate_address_p): ...this new static function.\n\t(TARGET_ADDR_SPACE_LEGITIMIZE_ADDRESS): Define to...\n\t(avr_addr_space_legitimize_address): ...this new static function.\n\t(avr_mode_code_base_reg_class): Handle address spaces.\n\t(avr_regno_mode_code_ok_for_base_p): Ditto.\n\t(lpm_addr_reg_rtx, lpm_reg_rtx, all_regs_rtx): New static variables.\n\t(avr_option_override): Initialize them.\n\t(output_reload_in_const): Use all_regs_rtx. Fix signedness of loop\n\tvariables.\n\t(avr_pgm_segment): New static function.\n\t(avr_decl_pgm_p, avr_mem_pgm_p): New static functions.\n\t(avr_out_lpm, avr_out_lpm_no_lpmx): New static functions.\n\t(output_movqi, output_movhi, output_movsisf, avr_out_movpsi): Call\n\tavr_out_lpm to handle loads from progmem.\n\t(avr_load_libgcc_p): New static function.\n\t(avr_progmem_p): Test if decl is in flash.\n\t(avr_pgm_pointer_const_p): New static function.\n\t(avr_nonconst_pointer_addrspace): New static function.\n\t(avr_pgm_check_var_decl): New static function.\n\t(avr_insert_attributes): Use it.  Change error message to report\n\tcause (progmem or address space) when code wants to write to flash.\n\t(avr_section_type_flags): Unset section flag SECTION_BSS for\n\tdata in progmem.\n\t* config/avr/predicates.md (nop_general_operand): New predicate.\n\t(nox_general_operand): New predicate.\n\t* config/avr/avr.md (LPM_REGNO): New define_constant.\n\t(load<mode>_libgcc): New expander.\n\t(*load.<mode>.libgcc): New insn.\n\t(mov<mode>): Handle loads from non-generic AS.\n\t(movmemhi): Ditto.  Propagate address space information to newly\n\tcreated MEM.\n\t(movqi_insn, *movhi, *movpsi, *movsi, *movsf): Change predicate #1\n\tto nox_general_operand.\n\t(ashrqi3, ashrhi3, ashrsi3): Change predicate #1 to nop_general_operand.\n\t(ashlqi3, *ashlqi3, ashlhi3, ashlsi3): Ditto.\n\t(lshrqi3, *lshrqi3, lshrhi3, lshrsi3): Ditto.\n\t(split-lpmx): New split.\n\t(*ashlhi3_const, *ashlsi3_const, *ashrhi3_const, *ashrsi3_const,\n\t*lshrhi3_const, *lshrsi3_const): Indent, unquote C.\n\nlibgcc/\n\tPR target/49868\n\t* config/avr/t-avr (LIB1ASMFUNCS): Add _load_3,  _load_4.\n\t* config/avr/lib1funcs.S (__load_3, __load_4, __xload_2): New functions.\n\nFrom-SVN: r181378", "tree": {"sha": "d14a2d46c8fe802218d215ec2c637cf93da45aa2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d14a2d46c8fe802218d215ec2c637cf93da45aa2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7c209481147555ddd22296b1eff0fd1833588d35", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c209481147555ddd22296b1eff0fd1833588d35", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7c209481147555ddd22296b1eff0fd1833588d35", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7c209481147555ddd22296b1eff0fd1833588d35/comments", "author": null, "committer": {"login": "sprintersb", "id": 8905355, "node_id": "MDQ6VXNlcjg5MDUzNTU=", "avatar_url": "https://avatars.githubusercontent.com/u/8905355?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sprintersb", "html_url": "https://github.com/sprintersb", "followers_url": "https://api.github.com/users/sprintersb/followers", "following_url": "https://api.github.com/users/sprintersb/following{/other_user}", "gists_url": "https://api.github.com/users/sprintersb/gists{/gist_id}", "starred_url": "https://api.github.com/users/sprintersb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sprintersb/subscriptions", "organizations_url": "https://api.github.com/users/sprintersb/orgs", "repos_url": "https://api.github.com/users/sprintersb/repos", "events_url": "https://api.github.com/users/sprintersb/events{/privacy}", "received_events_url": "https://api.github.com/users/sprintersb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d2d668fbbb3625987fa4117e63df38fa745874bd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d2d668fbbb3625987fa4117e63df38fa745874bd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d2d668fbbb3625987fa4117e63df38fa745874bd"}], "stats": {"total": 1164, "additions": 1036, "deletions": 128}, "files": [{"sha": "8e81d69718d2eb7cc9d5f7363bda75159f387221", "filename": "gcc/ChangeLog", "status": "modified", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c209481147555ddd22296b1eff0fd1833588d35/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c209481147555ddd22296b1eff0fd1833588d35/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7c209481147555ddd22296b1eff0fd1833588d35", "patch": "@@ -1,3 +1,72 @@\n+2011-11-15  Georg-Johann Lay  <avr@gjlay.de>\n+\n+\tPR target/49868\n+\t* config/avr/avr.h (ADDR_SPACE_PGM): New address spaces.\n+\t(REGISTER_TARGET_PRAGMAS): New define.\n+\t* config/avr/avr-protos.h (avr_mem_pgm_p): New.\n+\t(avr_load_libgcc_p): New.\n+\t(avr_register_target_pragmas): New.\n+\t(asm_output_external_libcall): Remove.\n+\t(avr_log_t): Add field \"progmem\".  Order alphabetically.\n+\t* config/avr/avr-log.c (avr_log_set_avr_log): Set avr_log.progmem.\n+\t* config/avr/avr-c.c (langhooks.h): New include.\n+\t(avr_register_target_pragmas): New function. Register address\n+\tspace __pgm.\n+\t(avr_cpu_cpp_builtins): Add built-in define __PGM.\n+\t\n+\t* config/avr/avr.c: Include \"c-family/c-common.h\".\n+\t(TARGET_LEGITIMATE_ADDRESS_P): Remove define.\n+\t(TARGET_LEGITIMIZE_ADDRESS): Remove define.\n+\t(TARGET_ADDR_SPACE_SUBSET_P): Define to...\n+\t(avr_addr_space_subset_p): ...this new static function.\n+\t(TARGET_ADDR_SPACE_CONVERT): Define to...\n+\t(avr_addr_space_convert): ...this new static function.\n+\t(TARGET_ADDR_SPACE_ADDRESS_MODE): Define to...\n+\t(avr_addr_space_address_mode): ...this new static function.\n+\t(TARGET_ADDR_SPACE_POINTER_MODE): Define to...\n+\t(avr_addr_space_pointer_mode): ...this new static function.\n+\t(TARGET_ADDR_SPACE_LEGITIMATE_ADDRESS_P): Define to...\n+\t(avr_addr_space_legitimate_address_p): ...this new static function.\n+\t(TARGET_ADDR_SPACE_LEGITIMIZE_ADDRESS): Define to...\n+\t(avr_addr_space_legitimize_address): ...this new static function.\n+\t(avr_mode_code_base_reg_class): Handle address spaces.\n+\t(avr_regno_mode_code_ok_for_base_p): Ditto.\n+\t(lpm_addr_reg_rtx, lpm_reg_rtx, all_regs_rtx): New static variables.\n+\t(avr_option_override): Initialize them.\n+\t(output_reload_in_const): Use all_regs_rtx. Fix signedness of loop\n+\tvariables.\n+\t(avr_pgm_segment): New static function.\n+\t(avr_decl_pgm_p, avr_mem_pgm_p): New static functions.\n+\t(avr_out_lpm, avr_out_lpm_no_lpmx): New static functions.\n+\t(output_movqi, output_movhi, output_movsisf, avr_out_movpsi): Call\n+\tavr_out_lpm to handle loads from progmem.\n+\t(avr_load_libgcc_p): New static function.\n+\t(avr_progmem_p): Test if decl is in flash.\n+\t(avr_pgm_pointer_const_p): New static function.\n+\t(avr_nonconst_pointer_addrspace): New static function.\n+\t(avr_pgm_check_var_decl): New static function.\n+\t(avr_insert_attributes): Use it.  Change error message to report\n+\tcause (progmem or address space) when code wants to write to flash.\n+\t(avr_section_type_flags): Unset section flag SECTION_BSS for\n+\tdata in progmem.\n+\t\n+\t* config/avr/predicates.md (nop_general_operand): New predicate.\n+\t(nox_general_operand): New predicate.\n+\t* config/avr/avr.md (LPM_REGNO): New define_constant.\n+\t(load<mode>_libgcc): New expander.\n+\t(*load.<mode>.libgcc): New insn.\n+\t(mov<mode>): Handle loads from non-generic AS.\n+\t(movmemhi): Ditto.  Propagate address space information to newly\n+\tcreated MEM.\n+\t(movqi_insn, *movhi, *movpsi, *movsi, *movsf): Change predicate #1\n+\tto nox_general_operand.\n+\t(ashrqi3, ashrhi3, ashrsi3): Change predicate #1 to nop_general_operand.\n+\t(ashlqi3, *ashlqi3, ashlhi3, ashlsi3): Ditto.\n+\t(lshrqi3, *lshrqi3, lshrhi3, lshrsi3): Ditto.\n+\t(split-lpmx): New split.\n+\t(*ashlhi3_const, *ashlsi3_const, *ashrhi3_const, *ashrsi3_const,\n+\t*lshrhi3_const, *lshrsi3_const): Indent, unquote C.\n+\n 2011-11-15  Maxim Kuvyrkov  <maxim@codesourcery.com>\n \n \t* ipa-cp.c (ipa_value_from_jfunc): Make global."}, {"sha": "63408c033ca0dd3b971b62b1a62481f31a3167c1", "filename": "gcc/config/avr/avr-c.c", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c209481147555ddd22296b1eff0fd1833588d35/gcc%2Fconfig%2Favr%2Favr-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c209481147555ddd22296b1eff0fd1833588d35/gcc%2Fconfig%2Favr%2Favr-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr-c.c?ref=7c209481147555ddd22296b1eff0fd1833588d35", "patch": "@@ -18,6 +18,7 @@\n    along with GCC; see the file COPYING3.  If not see\n    <http://www.gnu.org/licenses/>.  */\n \n+/* Not included in avr.c since this requires C front end.  */\n \n #include \"config.h\"\n #include \"system.h\"\n@@ -27,8 +28,17 @@\n #include \"cpplib.h\"\n #include \"tree.h\"\n #include \"c-family/c-common.h\"\n+#include \"langhooks.h\"\n+\n+\n+/* Implement `REGISTER_TARGET_PRAGMAS'.  */\n+\n+void\n+avr_register_target_pragmas (void)\n+{\n+  c_register_addr_space (\"__pgm\", ADDR_SPACE_PGM);\n+}\n \n-/* Not included in avr.c since this requires C front end.  */\n \n /* Worker function for TARGET_CPU_CPP_BUILTINS.  */\n \n@@ -90,6 +100,17 @@ avr_cpu_cpp_builtins (struct cpp_reader *pfile)\n         cpp_define (pfile, \"__AVR_ERRATA_SKIP_JMP_CALL__\");\n     }\n \n+  /* Define builtin macros so that the user can easily query if or if not\n+     non-generic address spaces (and which) are supported.\n+     This is only supported for C.  For C++, a language extension is needed\n+     (as mentioned in ISO/IEC DTR 18037; Annex F.2) which is not\n+     implemented in GCC up to now.  */\n+  \n+  if (!strcmp (lang_hooks.name, \"GNU C\"))\n+    {\n+      cpp_define (pfile, \"__PGM=__pgm\");\n+    }\n+\n   /* Define builtin macros so that the user can\n      easily query if or if not a specific builtin\n      is available. */"}, {"sha": "2f6b0aa651996988b59d03ecbecca6bfcf358213", "filename": "gcc/config/avr/avr-log.c", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c209481147555ddd22296b1eff0fd1833588d35/gcc%2Fconfig%2Favr%2Favr-log.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c209481147555ddd22296b1eff0fd1833588d35/gcc%2Fconfig%2Favr%2Favr-log.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr-log.c?ref=7c209481147555ddd22296b1eff0fd1833588d35", "patch": "@@ -59,6 +59,8 @@\n   F: caller (via __FUNCTION__)\n   P: Pass name and number\n   ?: Print caller, current function and pass info\n+  !: Ditto, but only print if in a pass with static pass number,\n+     else return.\n \n   == same as printf ==\n   \n@@ -318,12 +320,13 @@ avr_log_set_avr_log (void)\n                    || NULL != strstr (str, \",\" #S \",\")                  \\\n                    || NULL != strstr (str, \",all,\"))\n \n-      SET_DUMP_DETAIL (rtx_costs);\n+      SET_DUMP_DETAIL (address_cost);\n+      SET_DUMP_DETAIL (constraints);\n       SET_DUMP_DETAIL (legitimate_address_p);\n       SET_DUMP_DETAIL (legitimize_address);\n       SET_DUMP_DETAIL (legitimize_reload_address);\n-      SET_DUMP_DETAIL (constraints);\n-      SET_DUMP_DETAIL (address_cost);\n+      SET_DUMP_DETAIL (progmem);\n+      SET_DUMP_DETAIL (rtx_costs);\n \n #undef SET_DUMP_DETAIL\n     }"}, {"sha": "6c017e19b409d58d19d74b1c7cd6bd84d8ebebe3", "filename": "gcc/config/avr/avr-protos.h", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c209481147555ddd22296b1eff0fd1833588d35/gcc%2Fconfig%2Favr%2Favr-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c209481147555ddd22296b1eff0fd1833588d35/gcc%2Fconfig%2Favr%2Favr-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr-protos.h?ref=7c209481147555ddd22296b1eff0fd1833588d35", "patch": "@@ -32,6 +32,7 @@ extern int avr_initial_elimination_offset (int from, int to);\n extern int avr_simple_epilogue (void);\n extern int avr_hard_regno_rename_ok (unsigned int, unsigned int);\n extern rtx avr_return_addr_rtx (int count, rtx tem);\n+extern void avr_register_target_pragmas (void);\n extern bool avr_accumulate_outgoing_args (void);\n \n #ifdef TREE_CODE\n@@ -47,7 +48,6 @@ extern void init_cumulative_args (CUMULATIVE_ARGS *cum, tree fntype,\n #endif /* TREE_CODE */\n \n #ifdef RTX_CODE\n-extern void asm_output_external_libcall (FILE *file, rtx symref);\n extern const char *output_movqi (rtx insn, rtx operands[], int *l);\n extern const char *output_movhi (rtx insn, rtx operands[], int *l);\n extern const char *out_movqi_r_mr (rtx insn, rtx op[], int *l);\n@@ -121,6 +121,8 @@ extern reg_class_t avr_mode_code_base_reg_class (enum machine_mode, addr_space_t\n extern bool avr_regno_mode_code_ok_for_base_p (int, enum machine_mode, addr_space_t, RTX_CODE, RTX_CODE);\n extern rtx avr_incoming_return_addr_rtx (void);\n extern rtx avr_legitimize_reload_address (rtx*, enum machine_mode, int, int, int, int, rtx (*)(rtx,int));\n+extern bool avr_mem_pgm_p (rtx);\n+extern bool avr_load_libgcc_p (rtx);\n #endif /* RTX_CODE */\n \n #ifdef REAL_VALUE_TYPE\n@@ -139,12 +141,13 @@ extern void avr_log_set_avr_log (void);\n \n typedef struct\n {\n-  unsigned rtx_costs :1;\n+  unsigned address_cost :1;\n+  unsigned constraints :1;\n   unsigned legitimate_address_p :1;\n   unsigned legitimize_address :1;\n   unsigned legitimize_reload_address :1;\n-  unsigned constraints :1;\n-  unsigned address_cost :1;\n+  unsigned progmem :1;\n+  unsigned rtx_costs :1;\n } avr_log_t;\n \n extern avr_log_t avr_log;"}, {"sha": "f33c0c509035673a8c1890db0ca1c040387a85a4", "filename": "gcc/config/avr/avr.c", "status": "modified", "additions": 627, "deletions": 27, "changes": 654, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c209481147555ddd22296b1eff0fd1833588d35/gcc%2Fconfig%2Favr%2Favr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c209481147555ddd22296b1eff0fd1833588d35/gcc%2Fconfig%2Favr%2Favr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.c?ref=7c209481147555ddd22296b1eff0fd1833588d35", "patch": "@@ -35,6 +35,7 @@\n #include \"tree.h\"\n #include \"output.h\"\n #include \"expr.h\"\n+#include \"c-family/c-common.h\"\n #include \"diagnostic-core.h\"\n #include \"obstack.h\"\n #include \"function.h\"\n@@ -84,12 +85,21 @@ static bool avr_rtx_costs (rtx, int, int, int, int *, bool);\n /* Allocate registers from r25 to r8 for parameters for function calls.  */\n #define FIRST_CUM_REG 26\n \n+/* Implicit target register of LPM instruction (R0) */\n+static GTY(()) rtx lpm_reg_rtx;\n+\n+/* (Implicit) address register of LPM instruction (R31:R30 = Z) */\n+static GTY(()) rtx lpm_addr_reg_rtx;\n+\n /* Temporary register RTX (gen_rtx_REG (QImode, TMP_REGNO)) */\n static GTY(()) rtx tmp_reg_rtx;\n \n /* Zeroed register RTX (gen_rtx_REG (QImode, ZERO_REGNO)) */\n static GTY(()) rtx zero_reg_rtx;\n \n+/* RTXs for all general purpose registers as QImode */\n+static GTY(()) rtx all_regs_rtx[32];\n+\n /* AVR register names {\"r0\", \"r1\", ..., \"r31\"} */\n static const char *const avr_regnames[] = REGISTER_NAMES;\n \n@@ -172,9 +182,6 @@ bool avr_need_copy_data_p = false;\n #undef TARGET_FUNCTION_ARG_ADVANCE\n #define TARGET_FUNCTION_ARG_ADVANCE avr_function_arg_advance\n \n-#undef TARGET_LEGITIMIZE_ADDRESS\n-#define TARGET_LEGITIMIZE_ADDRESS avr_legitimize_address\n-\n #undef TARGET_RETURN_IN_MEMORY\n #define TARGET_RETURN_IN_MEMORY avr_return_in_memory\n \n@@ -189,9 +196,6 @@ bool avr_need_copy_data_p = false;\n #undef TARGET_CASE_VALUES_THRESHOLD\n #define TARGET_CASE_VALUES_THRESHOLD avr_case_values_threshold\n \n-#undef TARGET_LEGITIMATE_ADDRESS_P\n-#define TARGET_LEGITIMATE_ADDRESS_P avr_legitimate_address_p\n-\n #undef TARGET_FRAME_POINTER_REQUIRED\n #define TARGET_FRAME_POINTER_REQUIRED avr_frame_pointer_required_p\n #undef TARGET_CAN_ELIMINATE\n@@ -221,6 +225,24 @@ bool avr_need_copy_data_p = false;\n #undef  TARGET_SCALAR_MODE_SUPPORTED_P\n #define TARGET_SCALAR_MODE_SUPPORTED_P avr_scalar_mode_supported_p\n \n+#undef  TARGET_ADDR_SPACE_SUBSET_P\n+#define TARGET_ADDR_SPACE_SUBSET_P avr_addr_space_subset_p\n+\n+#undef  TARGET_ADDR_SPACE_CONVERT\n+#define TARGET_ADDR_SPACE_CONVERT avr_addr_space_convert\n+\n+#undef  TARGET_ADDR_SPACE_ADDRESS_MODE\n+#define TARGET_ADDR_SPACE_ADDRESS_MODE avr_addr_space_address_mode\n+\n+#undef  TARGET_ADDR_SPACE_POINTER_MODE\n+#define TARGET_ADDR_SPACE_POINTER_MODE avr_addr_space_pointer_mode\n+\n+#undef  TARGET_ADDR_SPACE_LEGITIMATE_ADDRESS_P\n+#define TARGET_ADDR_SPACE_LEGITIMATE_ADDRESS_P avr_addr_space_legitimate_address_p\n+\n+#undef TARGET_ADDR_SPACE_LEGITIMIZE_ADDRESS\n+#define TARGET_ADDR_SPACE_LEGITIMIZE_ADDRESS avr_addr_space_legitimize_address\n+\n \f\n \n /* Custom function to replace string prefix.\n@@ -295,6 +317,8 @@ avr_popcount_each_byte (rtx xval, int n_bytes, int pop_mask)\n static void\n avr_option_override (void)\n {\n+  int regno;\n+  \n   flag_delete_null_pointer_checks = 0;\n \n   /* caller-save.c looks for call-clobbered hard registers that are assigned\n@@ -323,8 +347,14 @@ avr_option_override (void)\n   avr_current_arch = &avr_arch_types[avr_current_device->arch];\n   avr_extra_arch_macro = avr_current_device->macro;\n \n-  tmp_reg_rtx  = gen_rtx_REG (QImode, TMP_REGNO);\n-  zero_reg_rtx = gen_rtx_REG (QImode, ZERO_REGNO);\n+  for (regno = 0; regno < 32; regno ++)\n+    all_regs_rtx[regno] = gen_rtx_REG (QImode, regno);\n+\n+  lpm_reg_rtx  = all_regs_rtx[LPM_REGNO];\n+  tmp_reg_rtx  = all_regs_rtx[TMP_REGNO];\n+  zero_reg_rtx = all_regs_rtx[ZERO_REGNO];\n+\n+  lpm_addr_reg_rtx = gen_rtx_REG (HImode, REG_Z);\n \n   init_machine_status = avr_init_machine_status;\n \n@@ -384,6 +414,28 @@ avr_scalar_mode_supported_p (enum machine_mode mode)\n }\n \n \n+/* Return TRUE if DECL is a VAR_DECL located in Flash and FALSE, otherwise.  */\n+\n+static bool\n+avr_decl_pgm_p (tree decl)\n+{\n+  if (TREE_CODE (decl) != VAR_DECL)\n+    return false;\n+\n+  return !ADDR_SPACE_GENERIC_P (TYPE_ADDR_SPACE (TREE_TYPE (decl)));\n+}\n+\n+\n+/* Return TRUE if X is a MEM rtx located in Flash and FALSE, otherwise.  */\n+\n+bool\n+avr_mem_pgm_p (rtx x)\n+{\n+  return (MEM_P (x)\n+          && !ADDR_SPACE_GENERIC_P (MEM_ADDR_SPACE (x)));\n+}\n+\n+\n /* A helper for the subsequent function attribute used to dig for\n    attribute 'name' in a FUNCTION_DECL or FUNCTION_TYPE */\n \n@@ -1379,6 +1431,9 @@ avr_legitimate_address_p (enum machine_mode mode, rtx x, bool strict)\n   return ok;\n }\n \n+\n+/* Former implementation of TARGET_LEGITIMIZE_ADDRESS,\n+   now only a helper for avr_addr_space_legitimize_address.  */\n /* Attempts to replace X with a valid\n    memory address for an operand of mode MODE  */\n \n@@ -2177,6 +2232,231 @@ avr_function_ok_for_sibcall (tree decl_callee, tree exp_callee)\n /***********************************************************************\n   Functions for outputting various mov's for a various modes\n ************************************************************************/\n+\n+/* Return true if a value of mode MODE is read from flash by\n+   __load_* function from libgcc.  */\n+\n+bool\n+avr_load_libgcc_p (rtx op)\n+{\n+  enum machine_mode mode = GET_MODE (op);\n+  int n_bytes = GET_MODE_SIZE (mode);\n+        \n+  return (n_bytes > 2\n+          && !AVR_HAVE_LPMX\n+          && avr_mem_pgm_p (op));\n+}\n+\n+\n+/* Helper function for the next function in the case where only restricted\n+   version of LPM instruction is available.  */\n+\n+static const char*\n+avr_out_lpm_no_lpmx (rtx insn, rtx *xop, int *plen)\n+{\n+  rtx dest = xop[0];\n+  rtx addr = xop[1];\n+  int n_bytes = GET_MODE_SIZE (GET_MODE (dest));\n+  int regno_dest;\n+\n+  regno_dest = REGNO (dest);\n+\n+  /* The implicit target register of LPM.  */\n+  xop[3] = lpm_reg_rtx;\n+\n+  switch (GET_CODE (addr))\n+    {\n+    default:\n+      gcc_unreachable();\n+\n+    case REG:\n+\n+      gcc_assert (REG_Z == REGNO (addr));\n+\n+      switch (n_bytes)\n+        {\n+        default:\n+          gcc_unreachable();\n+\n+        case 1:\n+          return avr_asm_len (\"lpm\" CR_TAB\n+                              \"mov %0,%3\", xop, plen, 2);\n+\n+        case 2:\n+          if (REGNO (dest) == REG_Z)\n+            return avr_asm_len (\"lpm\"        CR_TAB\n+                                \"push %3\"    CR_TAB\n+                                \"adiw %2,1\"  CR_TAB\n+                                \"lpm\"        CR_TAB\n+                                \"mov %B0,%3\" CR_TAB\n+                                \"pop %A0\", xop, plen, 6);\n+          else\n+            {\n+              avr_asm_len (\"lpm\"        CR_TAB\n+                           \"mov %A0,%3\" CR_TAB\n+                           \"adiw %2,1\"  CR_TAB\n+                           \"lpm\"        CR_TAB\n+                           \"mov %B0,%3\", xop, plen, 5);\n+                \n+              if (!reg_unused_after (insn, addr))\n+                avr_asm_len (\"sbiw %2,1\", xop, plen, 1);\n+            }\n+          \n+          break; /* 2 */\n+        }\n+      \n+      break; /* REG */\n+\n+    case POST_INC:\n+\n+      gcc_assert (REG_Z == REGNO (XEXP (addr, 0))\n+                  && n_bytes <= 2);\n+\n+      avr_asm_len (\"lpm\"        CR_TAB\n+                   \"mov %A0,%3\" CR_TAB\n+                   \"adiw %2,1\", xop, plen, 3);\n+\n+      if (n_bytes >= 2)\n+        avr_asm_len (\"lpm\"        CR_TAB\n+                     \"mov %B0,%3\" CR_TAB\n+                     \"adiw %2,1\", xop, plen, 3);\n+\n+      break; /* POST_INC */\n+      \n+    } /* switch CODE (addr) */\n+      \n+  return \"\";\n+}\n+\n+\n+/* If PLEN == NULL: Ouput instructions to load a value from a memory location\n+   OP[1] in AS1 to register OP[0].\n+   If PLEN != 0 set *PLEN to the length in words of the instruction sequence.\n+   Return \"\".  */\n+\n+static const char*\n+avr_out_lpm (rtx insn, rtx *op, int *plen)\n+{\n+  rtx xop[5];\n+  rtx dest = op[0];\n+  rtx src = SET_SRC (single_set (insn));\n+  rtx addr;\n+  int n_bytes = GET_MODE_SIZE (GET_MODE (dest));\n+  int regno_dest;\n+\n+  if (plen)\n+    *plen = 0;\n+  \n+  if (MEM_P (dest))\n+    {\n+      warning (0, \"writing to address space %qs not supported\",\n+               c_addr_space_name (MEM_ADDR_SPACE (dest)));\n+      \n+      return \"\";\n+    }\n+\n+  addr = XEXP (src, 0);\n+\n+  gcc_assert (!avr_load_libgcc_p (src)\n+              && REG_P (dest)\n+              && (REG_P (addr) || POST_INC == GET_CODE (addr)));\n+\n+  xop[0] = dest;\n+  xop[1] = addr;\n+  xop[2] = lpm_addr_reg_rtx;\n+\n+  regno_dest = REGNO (dest);\n+\n+  if (!AVR_HAVE_LPMX)\n+    {\n+      return avr_out_lpm_no_lpmx (insn, xop, plen);\n+    }\n+\n+  switch (GET_CODE (addr))\n+    {\n+    default:\n+      gcc_unreachable();\n+\n+    case REG:\n+\n+      gcc_assert (REG_Z == REGNO (addr));\n+\n+      switch (n_bytes)\n+        {\n+        default:\n+          gcc_unreachable();\n+\n+        case 1:\n+          return avr_asm_len (\"lpm %0,%a2\", xop, plen, -1);\n+\n+        case 2:\n+          if (REGNO (dest) == REG_Z)\n+            return avr_asm_len (\"lpm __tmp_reg__,%a2+\" CR_TAB\n+                                \"lpm %B0,%a2\"          CR_TAB\n+                                \"mov %A0,__tmp_reg__\", xop, plen, -3);\n+          else\n+            {\n+              avr_asm_len (\"lpm %A0,%a2+\" CR_TAB\n+                           \"lpm %B0,%a2\", xop, plen, -2);\n+                \n+              if (!reg_unused_after (insn, addr))\n+                avr_asm_len (\"sbiw %2,1\", xop, plen, 1);\n+            }\n+          \n+          break; /* 2 */\n+\n+        case 3:\n+\n+          avr_asm_len (\"lpm %A0,%a2+\" CR_TAB\n+                       \"lpm %B0,%a2+\" CR_TAB\n+                       \"lpm %C0,%a2\", xop, plen, -3);\n+                \n+          if (!reg_unused_after (insn, addr))\n+            avr_asm_len (\"sbiw %2,2\", xop, plen, 1);\n+\n+          break; /* 3 */\n+      \n+        case 4:\n+\n+          avr_asm_len (\"lpm %A0,%a2+\" CR_TAB\n+                       \"lpm %B0,%a2+\", xop, plen, -2);\n+          \n+          if (REGNO (dest) == REG_Z - 2)\n+            return avr_asm_len (\"lpm __tmp_reg__,%a2+\" CR_TAB\n+                                \"lpm %C0,%a2\"          CR_TAB\n+                                \"mov %D0,__tmp_reg__\", xop, plen, 3);\n+          else\n+            {\n+              avr_asm_len (\"lpm %C0,%a2+\" CR_TAB\n+                           \"lpm %D0,%a2\", xop, plen, 2);\n+                \n+              if (!reg_unused_after (insn, addr))\n+                avr_asm_len (\"sbiw %2,3\", xop, plen, 1);\n+            }\n+\n+          break; /* 4 */\n+        } /* n_bytes */\n+      \n+      break; /* REG */\n+\n+    case POST_INC:\n+\n+      gcc_assert (REG_Z == REGNO (XEXP (addr, 0))\n+                  && n_bytes <= 4);\n+\n+      avr_asm_len                    (\"lpm %A0,%a2+\", xop, plen, -1);\n+      if (n_bytes >= 2)  avr_asm_len (\"lpm %B0,%a2+\", xop, plen, 1);\n+      if (n_bytes >= 3)  avr_asm_len (\"lpm %C0,%a2+\", xop, plen, 1);\n+      if (n_bytes >= 4)  avr_asm_len (\"lpm %D0,%a2+\", xop, plen, 1);\n+\n+      break; /* POST_INC */\n+\n+    } /* switch CODE (addr) */\n+      \n+  return \"\";\n+}\n+\n+\n const char *\n output_movqi (rtx insn, rtx operands[], int *l)\n {\n@@ -2185,6 +2465,12 @@ output_movqi (rtx insn, rtx operands[], int *l)\n   rtx src = operands[1];\n   int *real_l = l;\n   \n+  if (avr_mem_pgm_p (src)\n+      || avr_mem_pgm_p (dest))\n+    {\n+      return avr_out_lpm (insn, operands, real_l);\n+    }\n+\n   if (!l)\n     l = &dummy;\n \n@@ -2235,6 +2521,12 @@ output_movhi (rtx insn, rtx operands[], int *l)\n   rtx src = operands[1];\n   int *real_l = l;\n   \n+  if (avr_mem_pgm_p (src)\n+      || avr_mem_pgm_p (dest))\n+    {\n+      return avr_out_lpm (insn, operands, real_l);\n+    }\n+\n   if (!l)\n     l = &dummy;\n   \n@@ -2848,6 +3140,12 @@ output_movsisf (rtx insn, rtx operands[], int *l)\n   rtx src = operands[1];\n   int *real_l = l;\n   \n+  if (avr_mem_pgm_p (src)\n+      || avr_mem_pgm_p (dest))\n+    {\n+      return avr_out_lpm (insn, operands, real_l);\n+    }\n+\n   if (!l)\n     l = &dummy;\n   \n@@ -3167,6 +3465,12 @@ avr_out_movpsi (rtx insn, rtx *op, int *plen)\n   rtx dest = op[0];\n   rtx src = op[1];\n   \n+  if (avr_mem_pgm_p (src)\n+      || avr_mem_pgm_p (dest))\n+    {\n+      return avr_out_lpm (insn, op, plen);\n+    }\n+  \n   if (register_operand (dest, VOIDmode))\n     {\n       if (register_operand (src, VOIDmode)) /* mov r,r */\n@@ -3764,9 +4068,10 @@ out_shift_with_cnt (const char *templ, rtx insn, rtx operands[],\n   if (len)\n     *len = 1;\n \n-  if (GET_CODE (operands[2]) == CONST_INT)\n+  if (CONST_INT_P (operands[2]))\n     {\n-      int scratch = (GET_CODE (PATTERN (insn)) == PARALLEL);\n+      bool scratch = (GET_CODE (PATTERN (insn)) == PARALLEL\n+                      && REG_P (operands[3]));\n       int count = INTVAL (operands[2]);\n       int max_len = 10;  /* If larger than this, always use a loop.  */\n \n@@ -3819,8 +4124,7 @@ out_shift_with_cnt (const char *templ, rtx insn, rtx operands[],\n \t  /* No scratch register available, use one from LD_REGS (saved in\n \t     __tmp_reg__) that doesn't overlap with registers to shift.  */\n \n-\t  op[3] = gen_rtx_REG (QImode,\n-\t\t\t   ((true_regnum (operands[0]) - 1) & 15) + 16);\n+\t  op[3] = all_regs_rtx[((REGNO (operands[0]) - 1) & 15) + 16];\n \t  op[4] = tmp_reg_rtx;\n \t  saved_in_tmp = 1;\n \n@@ -6208,8 +6512,15 @@ avr_attribute_table[] =\n   { NULL,        0, 0, false, false, false, NULL, false }\n };\n \n-/* Look for attribute `progmem' in DECL\n-   if found return 1, otherwise 0.  */\n+\n+/* Look if DECL shall be placed in program memory space by\n+   means of attribute `progmem' or some address-space qualifier.\n+   Return non-zero if DECL is data that must end up in Flash and\n+   zero if the data lives in RAM (.bss, .data, .rodata, ...).\n+   \n+   Return 1   if DECL is located in 16-bit flash address-space\n+   Return -1  if attribute `progmem' occurs in DECL or ATTRIBUTES\n+   Return 0   otherwise  */\n \n int\n avr_progmem_p (tree decl, tree attributes)\n@@ -6219,11 +6530,15 @@ avr_progmem_p (tree decl, tree attributes)\n   if (TREE_CODE (decl) != VAR_DECL)\n     return 0;\n \n+  if (avr_decl_pgm_p (decl))\n+    return 1;\n+\n   if (NULL_TREE\n       != lookup_attribute (\"progmem\", attributes))\n-    return 1;\n+    return -1;\n \n-  a=decl;\n+  a = decl;\n+ \n   do\n     a = TREE_TYPE(a);\n   while (TREE_CODE (a) == ARRAY_TYPE);\n@@ -6232,16 +6547,123 @@ avr_progmem_p (tree decl, tree attributes)\n     return 0;\n \n   if (NULL_TREE != lookup_attribute (\"progmem\", TYPE_ATTRIBUTES (a)))\n-    return 1;\n+    return -1;\n   \n   return 0;\n }\n \n+\n+/* Scan type TYP for pointer references to address space ASn.\n+   Return ADDR_SPACE_GENERIC (i.e. 0) if all pointers targeting\n+   the AS are also declared to be CONST.\n+   Otherwise, return the respective addres space, i.e. a value != 0.  */\n+   \n+static addr_space_t\n+avr_nonconst_pointer_addrspace (tree typ)\n+{\n+  while (ARRAY_TYPE == TREE_CODE (typ))\n+    typ = TREE_TYPE (typ);\n+\n+  if (POINTER_TYPE_P (typ))\n+    {\n+      tree target = TREE_TYPE (typ);\n+\n+      /* Pointer to function: Test the function's return type.  */\n+      \n+      if (FUNCTION_TYPE == TREE_CODE (target))\n+        return avr_nonconst_pointer_addrspace (TREE_TYPE (target));\n+\n+      /* \"Ordinary\" pointers... */\n+\n+      while (TREE_CODE (target) == ARRAY_TYPE)\n+        target = TREE_TYPE (target);\n+\n+      if (!ADDR_SPACE_GENERIC_P (TYPE_ADDR_SPACE (target))\n+          && !TYPE_READONLY (target))\n+        {\n+          /* Pointers to non-generic address space must be const.  */\n+          \n+          return TYPE_ADDR_SPACE (target);\n+        }\n+\n+      /* Scan pointer's target type.  */\n+      \n+      return avr_nonconst_pointer_addrspace (target);\n+    }\n+\n+  return ADDR_SPACE_GENERIC;\n+}\n+\n+\n+/* Sanity check NODE so that all pointers targeting address space AS1\n+   go along with CONST qualifier.  Writing to this address space should\n+   be detected and complained about as early as possible.  */\n+\n+static bool\n+avr_pgm_check_var_decl (tree node)\n+{\n+  const char *reason = NULL;\n+  \n+  addr_space_t as = ADDR_SPACE_GENERIC;\n+\n+  gcc_assert (as == 0);\n+  \n+  if (avr_log.progmem)\n+    avr_edump (\"%?: %t\\n\", node);\n+  \n+  switch (TREE_CODE (node))\n+    {\n+    default:\n+      break;\n+\n+    case VAR_DECL:\n+      if (as = avr_nonconst_pointer_addrspace (TREE_TYPE (node)), as)\n+        reason = \"variable\";\n+      break;\n+\n+    case PARM_DECL:\n+      if (as = avr_nonconst_pointer_addrspace (TREE_TYPE (node)), as)\n+        reason = \"function parameter\";\n+      break;\n+        \n+    case FIELD_DECL:\n+      if (as = avr_nonconst_pointer_addrspace (TREE_TYPE (node)), as)\n+        reason = \"structure field\";\n+      break;\n+        \n+    case FUNCTION_DECL:\n+      if (as = avr_nonconst_pointer_addrspace (TREE_TYPE (TREE_TYPE (node))),\n+          as)\n+        reason = \"return type of function\";\n+      break;\n+\n+    case POINTER_TYPE:\n+      if (as = avr_nonconst_pointer_addrspace (node), as)\n+        reason = \"pointer\";\n+      break;\n+    }\n+\n+  if (reason)\n+    {\n+      if (TYPE_P (node))\n+        error (\"pointer targeting address space %qs must be const in %qT\",\n+               c_addr_space_name (as), node);\n+      else\n+        error (\"pointer targeting address space %qs must be const in %s %q+D\",\n+               c_addr_space_name (as), reason, node);\n+    }\n+\n+  return reason == NULL;\n+}\n+\n+\n /* Add the section attribute if the variable is in progmem.  */\n \n static void\n avr_insert_attributes (tree node, tree *attributes)\n {\n+  avr_pgm_check_var_decl (node);\n+\n   if (TREE_CODE (node) == VAR_DECL\n       && (TREE_STATIC (node) || DECL_EXTERNAL (node))\n       && avr_progmem_p (node, *attributes))\n@@ -6258,11 +6680,20 @@ avr_insert_attributes (tree node, tree *attributes)\n       if (error_mark_node == node0)\n         return;\n       \n-      if (!TYPE_READONLY (node0))\n+      if (!TYPE_READONLY (node0)\n+          && !TREE_READONLY (node))\n         {\n+          addr_space_t as = TYPE_ADDR_SPACE (TREE_TYPE (node));\n+          const char *reason = \"__attribute__((progmem))\";\n+\n+          if (!ADDR_SPACE_GENERIC_P (as))\n+            reason = c_addr_space_name (as);\n+          \n+          if (avr_log.progmem)\n+            avr_edump (\"\\n%?: %t\\n%t\\n\", node, node0);\n+          \n           error (\"variable %q+D must be const in order to be put into\"\n-                 \" read-only section by means of %<__attribute__((progmem))%>\",\n-                 node);\n+                 \" read-only section by means of %qs\", node, reason);\n         }\n     }\n }\n@@ -6462,6 +6893,7 @@ avr_section_type_flags (tree decl, const char *name, int reloc)\n       && avr_progmem_p (decl, DECL_ATTRIBUTES (decl)))\n     {\n       flags &= ~SECTION_WRITE;\n+      flags &= ~SECTION_BSS;\n       flags |= AVR_SECTION_PROGMEM;\n     }\n   \n@@ -8049,10 +8481,14 @@ avr_hard_regno_mode_ok (int regno, enum machine_mode mode)\n \n reg_class_t\n avr_mode_code_base_reg_class (enum machine_mode mode ATTRIBUTE_UNUSED,\n-                              addr_space_t as ATTRIBUTE_UNUSED,\n-                              RTX_CODE outer_code,\n+                              addr_space_t as, RTX_CODE outer_code,\n                               RTX_CODE index_code ATTRIBUTE_UNUSED)\n {\n+  if (!ADDR_SPACE_GENERIC_P (as))\n+    {\n+      return POINTER_Z_REGS;\n+    }\n+ \n   if (!avr_strict_X)\n     return reload_completed ? BASE_POINTER_REGS : POINTER_REGS;\n \n@@ -8071,6 +8507,27 @@ avr_regno_mode_code_ok_for_base_p (int regno,\n {\n   bool ok = false;\n   \n+  if (!ADDR_SPACE_GENERIC_P (as))\n+    {\n+      if (regno < FIRST_PSEUDO_REGISTER\n+          && regno == REG_Z)\n+        {\n+          return true;\n+        }\n+      \n+      if (reg_renumber)\n+        {\n+          regno = reg_renumber[regno];\n+          \n+          if (regno == REG_Z)\n+            {\n+              return true;\n+            }\n+        }\n+      \n+      return false;\n+    }\n+\n   if (regno < FIRST_PSEUDO_REGISTER\n       && (regno == REG_X\n           || regno == REG_Y\n@@ -8122,9 +8579,8 @@ output_reload_in_const (rtx *op, rtx clobber_reg, int *len, bool clear_p)\n   int clobber_val = 1234;\n   bool cooked_clobber_p = false;\n   bool set_p = false;\n-  unsigned int n;\n   enum machine_mode mode = GET_MODE (dest);\n-  int n_bytes = GET_MODE_SIZE (mode);\n+  int n, n_bytes = GET_MODE_SIZE (mode);\n   \n   gcc_assert (REG_P (dest)\n               && CONSTANT_P (src));\n@@ -8138,7 +8594,7 @@ output_reload_in_const (rtx *op, rtx clobber_reg, int *len, bool clear_p)\n   if (REGNO (dest) < 16\n       && REGNO (dest) + GET_MODE_SIZE (mode) > 16)\n     {\n-      clobber_reg = gen_rtx_REG (QImode, REGNO (dest) + n_bytes - 1);\n+      clobber_reg = all_regs_rtx[REGNO (dest) + n_bytes - 1];\n     }\n \n   /* We might need a clobber reg but don't have one.  Look at the value to\n@@ -8155,7 +8611,7 @@ output_reload_in_const (rtx *op, rtx clobber_reg, int *len, bool clear_p)\n          That's cheaper than loading from constant pool.  */\n       \n       cooked_clobber_p = true;\n-      clobber_reg = gen_rtx_REG (QImode, REG_Z + 1);\n+      clobber_reg = all_regs_rtx[REG_Z + 1];\n       avr_asm_len (\"mov __tmp_reg__,%0\", &clobber_reg, len, 1);\n     }\n \n@@ -8165,7 +8621,7 @@ output_reload_in_const (rtx *op, rtx clobber_reg, int *len, bool clear_p)\n     {\n       int ldreg_p;\n       bool done_byte = false;\n-      unsigned int j;\n+      int j;\n       rtx xop[3];\n \n       /* Crop the n-th destination byte.  */\n@@ -8595,6 +9051,150 @@ avr_case_values_threshold (void)\n   return (!AVR_HAVE_JMP_CALL || TARGET_CALL_PROLOGUES) ? 8 : 17;\n }\n \n+\n+/* Implement `TARGET_ADDR_SPACE_ADDRESS_MODE'.  */\n+\n+static enum machine_mode\n+avr_addr_space_address_mode (addr_space_t as ATTRIBUTE_UNUSED)\n+{\n+  return HImode;\n+}\n+\n+\n+/* Implement `TARGET_ADDR_SPACE_POINTER_MODE'.  */\n+\n+static enum machine_mode\n+avr_addr_space_pointer_mode (addr_space_t as ATTRIBUTE_UNUSED)\n+{\n+  return HImode;\n+}\n+\n+\n+/* Helper for following function.  */\n+\n+static bool\n+avr_reg_ok_for_pgm_addr (rtx reg, bool strict)\n+{\n+  gcc_assert (REG_P (reg));\n+\n+  if (strict)\n+    {\n+      return REGNO (reg) == REG_Z;\n+    }\n+  \n+  /* Avoid combine to propagate hard regs.  */\n+  \n+  if (can_create_pseudo_p()\n+      && REGNO (reg) < REG_Z)\n+    {\n+      return false;\n+    }\n+  \n+  return true;\n+}\n+\n+\n+/* Implement `TARGET_ADDR_SPACE_LEGITIMATE_ADDRESS_P'.  */\n+\n+static bool\n+avr_addr_space_legitimate_address_p (enum machine_mode mode, rtx x,\n+                                     bool strict, addr_space_t as)\n+{\n+  bool ok = false;\n+\n+  switch (as)\n+    {\n+    default:\n+      gcc_unreachable();\n+      \n+    case ADDR_SPACE_GENERIC:\n+      return avr_legitimate_address_p (mode, x, strict);\n+\n+    case ADDR_SPACE_PGM:\n+\n+      switch (GET_CODE (x))\n+        {\n+        case REG:\n+          ok = avr_reg_ok_for_pgm_addr (x, strict);\n+          break;\n+          \n+        case POST_INC:\n+          ok = (!avr_load_libgcc_p (x)\n+                && avr_reg_ok_for_pgm_addr (XEXP (x, 0), strict));\n+          break;\n+          \n+        default:\n+          break;\n+        }\n+\n+      break; /* PGM */\n+    }\n+\n+  if (avr_log.legitimate_address_p)\n+    {\n+      avr_edump (\"\\n%?: ret=%b, mode=%m strict=%d \"\n+                 \"reload_completed=%d reload_in_progress=%d %s:\",\n+                 ok, mode, strict, reload_completed, reload_in_progress,\n+                 reg_renumber ? \"(reg_renumber)\" : \"\");\n+      \n+      if (GET_CODE (x) == PLUS\n+          && REG_P (XEXP (x, 0))\n+          && CONST_INT_P (XEXP (x, 1))\n+          && IN_RANGE (INTVAL (XEXP (x, 1)), 0, MAX_LD_OFFSET (mode))\n+          && reg_renumber)\n+        {\n+          avr_edump (\"(r%d ---> r%d)\", REGNO (XEXP (x, 0)),\n+                     true_regnum (XEXP (x, 0)));\n+        }\n+      \n+      avr_edump (\"\\n%r\\n\", x);\n+    }\n+\n+  return ok;\n+}\n+\n+\n+/* Implement `TARGET_ADDR_SPACE_LEGITIMIZE_ADDRESS'.  */\n+\n+static rtx\n+avr_addr_space_legitimize_address (rtx x, rtx old_x,\n+                                   enum machine_mode mode, addr_space_t as)\n+{\n+  if (ADDR_SPACE_GENERIC_P (as))\n+    return avr_legitimize_address (x, old_x, mode);\n+\n+  if (avr_log.legitimize_address)\n+    {\n+      avr_edump (\"\\n%?: mode=%m\\n %r\\n\", mode, old_x);\n+    }\n+\n+  return old_x;\n+}\n+\n+\n+/* Implement `TARGET_ADDR_SPACE_CONVERT'.  */\n+\n+static rtx\n+avr_addr_space_convert (rtx src, tree type_from, tree type_to)\n+{\n+  if (avr_log.progmem)\n+    avr_edump (\"\\n%!: op = %r\\nfrom = %t\\nto = %t\\n\",\n+               src, type_from, type_to);\n+\n+  return src;\n+}\n+\n+\n+/* Implement `TARGET_ADDR_SPACE_SUBSET_P'.  */\n+\n+static bool\n+avr_addr_space_subset_p (addr_space_t subset ATTRIBUTE_UNUSED,\n+                         addr_space_t superset ATTRIBUTE_UNUSED)\n+{\n+  return true;\n+}\n+\n+\n /* Helper for __builtin_avr_delay_cycles */\n \n static void"}, {"sha": "24a687b309b60630df66a0b88a4ffd34f4bad706", "filename": "gcc/config/avr/avr.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c209481147555ddd22296b1eff0fd1833588d35/gcc%2Fconfig%2Favr%2Favr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c209481147555ddd22296b1eff0fd1833588d35/gcc%2Fconfig%2Favr%2Favr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.h?ref=7c209481147555ddd22296b1eff0fd1833588d35", "patch": "@@ -391,6 +391,14 @@ typedef struct avr_args {\n \n #define NO_FUNCTION_CSE\n \n+\n+#define ADDR_SPACE_PGM  1\n+\n+#define REGISTER_TARGET_PRAGMAS()                                       \\\n+  do {                                                                  \\\n+    avr_register_target_pragmas();                                      \\\n+  } while (0)\n+\n #define TEXT_SECTION_ASM_OP \"\\t.text\"\n \n #define DATA_SECTION_ASM_OP \"\\t.data\""}, {"sha": "78ffe866bbcc02fc671a26f56166ee8c60ca6cdc", "filename": "gcc/config/avr/avr.md", "status": "modified", "additions": 233, "deletions": 93, "changes": 326, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c209481147555ddd22296b1eff0fd1833588d35/gcc%2Fconfig%2Favr%2Favr.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c209481147555ddd22296b1eff0fd1833588d35/gcc%2Fconfig%2Favr%2Favr.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.md?ref=7c209481147555ddd22296b1eff0fd1833588d35", "patch": "@@ -42,6 +42,7 @@\n    (REG_Z\t30)\n    (REG_W\t24)\n    (REG_SP\t32)\n+   (LPM_REGNO\t0)\t; implicit target register of LPM\n    (TMP_REGNO\t0)\t; temporary register r0\n    (ZERO_REGNO\t1)\t; zero register r1\n    \n@@ -315,6 +316,39 @@\n   \"\")\n \n ;;========================================================================\n+;; Move stuff around\n+\n+(define_expand \"load<mode>_libgcc\"\n+  [(set (match_dup 3)\n+        (match_dup 2))\n+   (set (reg:MOVMODE 22)\n+        (match_operand:MOVMODE 1 \"memory_operand\" \"\"))\n+   (set (match_operand:MOVMODE 0 \"register_operand\" \"\")\n+        (reg:MOVMODE 22))]\n+  \"avr_load_libgcc_p (operands[1])\"\n+  {\n+    operands[3] = gen_rtx_REG (HImode, REG_Z);\n+    operands[2] = force_operand (XEXP (operands[1], 0), NULL_RTX);\n+    operands[1] = replace_equiv_address (operands[1], operands[3]);\n+    set_mem_addr_space (operands[1], ADDR_SPACE_PGM);\n+  })\n+    \n+(define_insn \"*load.<mode>.libgcc\"\n+  [(set (reg:MOVMODE 22)\n+        (match_operand:MOVMODE 0 \"memory_operand\" \"m,m\"))]\n+  \"avr_load_libgcc_p (operands[0])\n+   && REG_P (XEXP (operands[0], 0))\n+   && REG_Z == REGNO (XEXP (operands[0], 0))\"\n+  {\n+    operands[0] = GEN_INT (GET_MODE_SIZE (<MODE>mode));\n+    return \"%~call __load_%0\";\n+  }\n+  [(set_attr \"length\" \"1,2\")\n+   (set_attr \"isa\" \"rjmp,jmp\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+\n+;; General move expanders\n \n ;; \"movqi\"\n ;; \"movhi\"\n@@ -327,12 +361,25 @@\n         (match_operand:MOVMODE 1 \"general_operand\" \"\"))]\n   \"\"\n   {\n-    /* One of the ops has to be in a register.  */\n-    if (!register_operand (operands[0], <MODE>mode)\n-        && !(register_operand (operands[1], <MODE>mode)\n-             || CONST0_RTX (<MODE>mode) == operands[1]))\n+    rtx dest = operands[0];\n+    rtx src  = operands[1]; \n+    \n+    if (avr_mem_pgm_p (dest))\n+      DONE;\n+  \n+    /* One of the operands has to be in a register.  */\n+    if (!register_operand (dest, <MODE>mode)\n+        && !(register_operand (src, <MODE>mode)\n+             || src == CONST0_RTX (<MODE>mode)))\n+      {\n+        operands[1] = src = copy_to_mode_reg (<MODE>mode, src);\n+      }\n+\n+    if (avr_load_libgcc_p (src))\n       {\n-        operands[1] = copy_to_mode_reg (<MODE>mode, operands[1]);\n+        /* For the small devices, do loads per libgcc call.  */\n+        emit_insn (gen_load<mode>_libgcc (dest, src));\n+        DONE;\n       }\n   })\n \n@@ -346,11 +393,14 @@\n ;; so this may still be a win for registers live across function calls.\n \n (define_insn \"movqi_insn\"\n-  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=r,d,Qm,r,q,r,*r\")\n-\t(match_operand:QI 1 \"general_operand\"       \"rL,i,rL,Qm,r,q,i\"))]\n-  \"(register_operand (operands[0],QImode)\n-    || register_operand (operands[1], QImode) || const0_rtx == operands[1])\"\n-  \"* return output_movqi (insn, operands, NULL);\"\n+  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=r ,d,Qm,r ,q,r,*r\")\n+        (match_operand:QI 1 \"nox_general_operand\"   \"rL,i,rL,Qm,r,q,i\"))]\n+  \"register_operand (operands[0], QImode)\n+   || register_operand (operands[1], QImode)\n+   || const0_rtx == operands[1]\"\n+  {\n+    return output_movqi (insn, operands, NULL);\n+  }\n   [(set_attr \"length\" \"1,1,5,5,1,1,4\")\n    (set_attr \"adjust_len\" \"mov8\")\n    (set_attr \"cc\" \"none,none,clobber,clobber,none,none,clobber\")])\n@@ -425,11 +475,14 @@\n    (set_attr \"cc\" \"none\")])\n \n (define_insn \"*movhi\"\n-  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=r,r,r,m,d,*r,q,r\")\n-        (match_operand:HI 1 \"general_operand\"       \"r,L,m,rL,i,i,r,q\"))]\n-  \"(register_operand (operands[0],HImode)\n-    || register_operand (operands[1],HImode) || const0_rtx == operands[1])\"\n-  \"* return output_movhi (insn, operands, NULL);\"\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=r,r,r,m ,d,*r,q,r\")\n+        (match_operand:HI 1 \"nox_general_operand\"   \"r,L,m,rL,i,i ,r,q\"))]\n+  \"register_operand (operands[0], HImode)\n+   || register_operand (operands[1], HImode)\n+   || const0_rtx == operands[1]\"\n+  {\n+    return output_movhi (insn, operands, NULL);\n+  }\n   [(set_attr \"length\" \"2,2,6,7,2,6,5,2\")\n    (set_attr \"adjust_len\" \"mov16\")\n    (set_attr \"cc\" \"none,clobber,clobber,clobber,none,clobber,none,none\")])\n@@ -462,6 +515,40 @@\n     operands[5] = gen_rtx_REG (HImode, REGNO (operands[3]));\n   })\n \n+;; For LPM loads from AS1 we split \n+;;    R = *Z\n+;; to\n+;;    R = *Z++\n+;;    Z = Z - sizeof (R)\n+;;\n+;; so that the second instruction can be optimized out.\n+\n+(define_split ; \"split-lpmx\"\n+  [(set (match_operand:HISI 0 \"register_operand\" \"\")\n+        (match_operand:HISI 1 \"memory_operand\" \"\"))]\n+  \"reload_completed\n+   && AVR_HAVE_LPMX\"\n+  [(set (match_dup 0)\n+        (match_dup 2))\n+   (set (match_dup 3)\n+        (plus:HI (match_dup 3)\n+                 (match_dup 4)))]\n+  {\n+     rtx addr = XEXP (operands[1], 0);\n+\n+     if (!avr_mem_pgm_p (operands[1])\n+         || !REG_P (addr)\n+         || reg_overlap_mentioned_p (addr, operands[0]))\n+       {\n+         FAIL;\n+       }\n+\n+    operands[2] = replace_equiv_address (operands[1],\n+                                         gen_rtx_POST_INC (Pmode, addr));\n+    operands[3] = addr;\n+    operands[4] = gen_int_mode (-GET_MODE_SIZE (<MODE>mode), HImode);\n+  })\n+\n ;;==========================================================================\n ;; xpointer move (24 bit)\n   \n@@ -492,7 +579,7 @@\n \n (define_insn \"*movpsi\"\n   [(set (match_operand:PSI 0 \"nonimmediate_operand\" \"=r,r,r ,Qm,!d,r\")\n-        (match_operand:PSI 1 \"general_operand\"       \"r,L,Qm,rL,i ,i\"))]\n+        (match_operand:PSI 1 \"nox_general_operand\"   \"r,L,Qm,rL,i ,i\"))]\n   \"register_operand (operands[0], PSImode)\n    || register_operand (operands[1], PSImode)\n    || const0_rtx == operands[1]\"\n@@ -532,10 +619,11 @@\n \n \n (define_insn \"*movsi\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r,r,r,Qm,!d,r\")\n-        (match_operand:SI 1 \"general_operand\"       \"r,L,Qm,rL,i,i\"))]\n-  \"(register_operand (operands[0],SImode)\n-    || register_operand (operands[1],SImode) || const0_rtx == operands[1])\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r,r,r ,Qm,!d,r\")\n+        (match_operand:SI 1 \"nox_general_operand\"   \"r,L,Qm,rL,i ,i\"))]\n+  \"register_operand (operands[0], SImode)\n+   || register_operand (operands[1], SImode)\n+   || const0_rtx == operands[1]\"\n   {\n     return output_movsisf (insn, operands, NULL);\n   }\n@@ -547,8 +635,8 @@\n ;; move floating point numbers (32 bit)\n \n (define_insn \"*movsf\"\n-  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=r,r,r,Qm,!d,r\")\n-        (match_operand:SF 1 \"general_operand\"       \"r,G,Qm,rG,F,F\"))]\n+  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=r,r,r ,Qm,!d,r\")\n+        (match_operand:SF 1 \"nox_general_operand\"   \"r,G,Qm,rG,F ,F\"))]\n   \"register_operand (operands[0], SFmode)\n    || register_operand (operands[1], SFmode)\n    || operands[1] == CONST0_RTX (SFmode)\"\n@@ -599,7 +687,7 @@\n   enum machine_mode mode;\n   rtx label = gen_label_rtx ();\n   rtx loop_reg;\n-  rtx jump;\n+  rtx jump, src;\n \n   /* Copy pointers into new psuedos - they will be changed.  */\n   rtx addr0 = copy_to_mode_reg (Pmode, XEXP (operands[0], 0));\n@@ -608,6 +696,9 @@\n   /* Create rtx for tmp register - we use this as scratch.  */\n   rtx tmp_reg_rtx  = gen_rtx_REG (QImode, TMP_REGNO);\n \n+  if (avr_mem_pgm_p (operands[0]))\n+    DONE;\n+\n   if (GET_CODE (operands[2]) != CONST_INT)\n     FAIL;\n \n@@ -628,7 +719,9 @@\n   emit_label (label);\n \n   /* Move one byte into scratch and inc pointer.  */\n-  emit_move_insn (tmp_reg_rtx, gen_rtx_MEM (QImode, addr1));\n+  src = gen_rtx_MEM (QImode, addr1);\n+  set_mem_addr_space (src, MEM_ADDR_SPACE (operands[1]));\n+  emit_move_insn (tmp_reg_rtx, src);\n   emit_move_insn (addr1, gen_rtx_PLUS (Pmode, addr1, const1_rtx));\n \n   /* Move to mem and inc pointer.  */\n@@ -2868,10 +2961,8 @@\n \n (define_expand \"ashlqi3\"\n   [(set (match_operand:QI 0 \"register_operand\"            \"\")\n-\t(ashift:QI (match_operand:QI 1 \"register_operand\" \"\")\n-\t\t   (match_operand:QI 2 \"general_operand\"  \"\")))]\n-  \"\"\n-  \"\")\n+        (ashift:QI (match_operand:QI 1 \"register_operand\" \"\")\n+                   (match_operand:QI 2 \"nop_general_operand\" \"\")))])\n \n (define_split ; ashlqi3_const4\n   [(set (match_operand:QI 0 \"d_register_operand\" \"\")\n@@ -2903,21 +2994,25 @@\n   \"\")\n \n (define_insn \"*ashlqi3\"\n-  [(set (match_operand:QI 0 \"register_operand\"           \"=r,r,r,r,!d,r,r\")\n-\t(ashift:QI (match_operand:QI 1 \"register_operand\" \"0,0,0,0,0,0,0\")\n-\t\t   (match_operand:QI 2 \"general_operand\"  \"r,L,P,K,n,n,Qm\")))]\n+  [(set (match_operand:QI 0 \"register_operand\"              \"=r,r,r,r,!d,r,r\")\n+        (ashift:QI (match_operand:QI 1 \"register_operand\"    \"0,0,0,0,0 ,0,0\")\n+                   (match_operand:QI 2 \"nop_general_operand\" \"r,L,P,K,n ,n,Qm\")))]\n   \"\"\n-  \"* return ashlqi3_out (insn, operands, NULL);\"\n+  {\n+    return ashlqi3_out (insn, operands, NULL);\n+  }\n   [(set_attr \"length\" \"5,0,1,2,4,6,9\")\n    (set_attr \"adjust_len\" \"ashlqi\")\n    (set_attr \"cc\" \"clobber,none,set_czn,set_czn,set_czn,set_czn,clobber\")])\n \n (define_insn \"ashlhi3\"\n-  [(set (match_operand:HI 0 \"register_operand\"           \"=r,r,r,r,r,r,r\")\n-\t(ashift:HI (match_operand:HI 1 \"register_operand\" \"0,0,0,r,0,0,0\")\n-\t\t   (match_operand:QI 2 \"general_operand\"  \"r,L,P,O,K,n,Qm\")))]\n+  [(set (match_operand:HI 0 \"register_operand\"              \"=r,r,r,r,r,r,r\")\n+        (ashift:HI (match_operand:HI 1 \"register_operand\"    \"0,0,0,r,0,0,0\")\n+                   (match_operand:QI 2 \"nop_general_operand\" \"r,L,P,O,K,n,Qm\")))]\n   \"\"\n-  \"* return ashlhi3_out (insn, operands, NULL);\"\n+  {\n+    return ashlhi3_out (insn, operands, NULL);\n+  }\n   [(set_attr \"length\" \"6,0,2,2,4,10,10\")\n    (set_attr \"adjust_len\" \"ashlhi\")\n    (set_attr \"cc\" \"clobber,none,set_n,clobber,set_n,clobber,clobber\")])\n@@ -3005,11 +3100,13 @@\n \n \n (define_insn \"ashlsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\"           \"=r,r,r,r,r,r,r\")\n-\t(ashift:SI (match_operand:SI 1 \"register_operand\" \"0,0,0,r,0,0,0\")\n-\t\t   (match_operand:QI 2 \"general_operand\"  \"r,L,P,O,K,n,Qm\")))]\n+  [(set (match_operand:SI 0 \"register_operand\"              \"=r,r,r,r,r,r,r\")\n+        (ashift:SI (match_operand:SI 1 \"register_operand\"    \"0,0,0,r,0,0,0\")\n+                   (match_operand:QI 2 \"nop_general_operand\" \"r,L,P,O,K,n,Qm\")))]\n   \"\"\n-  \"* return ashlsi3_out (insn, operands, NULL);\"\n+  {\n+    return ashlsi3_out (insn, operands, NULL);\n+  }\n   [(set_attr \"length\" \"8,0,4,4,8,10,12\")\n    (set_attr \"adjust_len\" \"ashlsi\")\n    (set_attr \"cc\" \"clobber,none,set_n,clobber,set_n,clobber,clobber\")])\n@@ -3063,11 +3160,13 @@\n \n (define_insn \"*ashlhi3_const\"\n   [(set (match_operand:HI 0 \"register_operand\"            \"=r,r,r,r,r\")\n-\t(ashift:HI (match_operand:HI 1 \"register_operand\"  \"0,0,r,0,0\")\n-\t\t   (match_operand:QI 2 \"const_int_operand\" \"L,P,O,K,n\")))\n-   (clobber (match_scratch:QI 3 \"=X,X,X,X,&d\"))]\n+        (ashift:HI (match_operand:HI 1 \"register_operand\"  \"0,0,r,0,0\")\n+                   (match_operand:QI 2 \"const_int_operand\" \"L,P,O,K,n\")))\n+   (clobber (match_scratch:QI 3                           \"=X,X,X,X,&d\"))]\n   \"reload_completed\"\n-  \"* return ashlhi3_out (insn, operands, NULL);\"\n+  {\n+    return ashlhi3_out (insn, operands, NULL);\n+  }\n   [(set_attr \"length\" \"0,2,2,4,10\")\n    (set_attr \"adjust_len\" \"ashlhi\")\n    (set_attr \"cc\" \"none,set_n,clobber,set_n,clobber\")])\n@@ -3084,11 +3183,13 @@\n \n (define_insn \"*ashlsi3_const\"\n   [(set (match_operand:SI 0 \"register_operand\"            \"=r,r,r,r\")\n-\t(ashift:SI (match_operand:SI 1 \"register_operand\"  \"0,0,r,0\")\n-\t\t   (match_operand:QI 2 \"const_int_operand\" \"L,P,O,n\")))\n-   (clobber (match_scratch:QI 3 \"=X,X,X,&d\"))]\n+        (ashift:SI (match_operand:SI 1 \"register_operand\"  \"0,0,r,0\")\n+                   (match_operand:QI 2 \"const_int_operand\" \"L,P,O,n\")))\n+   (clobber (match_scratch:QI 3                           \"=X,X,X,&d\"))]\n   \"reload_completed\"\n-  \"* return ashlsi3_out (insn, operands, NULL);\"\n+  {\n+    return ashlsi3_out (insn, operands, NULL);\n+  }\n   [(set_attr \"length\" \"0,4,4,10\")\n    (set_attr \"adjust_len\" \"ashlsi\")\n    (set_attr \"cc\" \"none,set_n,clobber,clobber\")])\n@@ -3109,21 +3210,25 @@\n ;; arithmetic shift right\n \n (define_insn \"ashrqi3\"\n-  [(set (match_operand:QI 0 \"register_operand\"             \"=r,r,r,r,r          ,r      ,r\")\n-        (ashiftrt:QI (match_operand:QI 1 \"register_operand\" \"0,0,0,0,0          ,0      ,0\")\n-                     (match_operand:QI 2 \"general_operand\"  \"r,L,P,K,C03 C04 C05,C06 C07,Qm\")))]\n+  [(set (match_operand:QI 0 \"register_operand\"                \"=r,r,r,r,r          ,r      ,r\")\n+        (ashiftrt:QI (match_operand:QI 1 \"register_operand\"    \"0,0,0,0,0          ,0      ,0\")\n+                     (match_operand:QI 2 \"nop_general_operand\" \"r,L,P,K,C03 C04 C05,C06 C07,Qm\")))]\n   \"\"\n-  \"* return ashrqi3_out (insn, operands, NULL);\"\n+  {\n+    return ashrqi3_out (insn, operands, NULL);\n+  }\n   [(set_attr \"length\" \"5,0,1,2,5,4,9\")\n    (set_attr \"adjust_len\" \"ashrqi\")\n    (set_attr \"cc\" \"clobber,none,set_czn,set_czn,set_czn,clobber,clobber\")])\n \n (define_insn \"ashrhi3\"\n-  [(set (match_operand:HI 0 \"register_operand\"             \"=r,r,r,r,r,r,r\")\n-\t(ashiftrt:HI (match_operand:HI 1 \"register_operand\" \"0,0,0,r,0,0,0\")\n-\t\t     (match_operand:QI 2 \"general_operand\"  \"r,L,P,O,K,n,Qm\")))]\n+  [(set (match_operand:HI 0 \"register_operand\"                \"=r,r,r,r,r,r,r\")\n+        (ashiftrt:HI (match_operand:HI 1 \"register_operand\"    \"0,0,0,r,0,0,0\")\n+                     (match_operand:QI 2 \"nop_general_operand\" \"r,L,P,O,K,n,Qm\")))]\n   \"\"\n-  \"* return ashrhi3_out (insn, operands, NULL);\"\n+  {\n+    return ashrhi3_out (insn, operands, NULL);\n+  }\n   [(set_attr \"length\" \"6,0,2,4,4,10,10\")\n    (set_attr \"adjust_len\" \"ashrhi\")\n    (set_attr \"cc\" \"clobber,none,clobber,set_n,clobber,clobber,clobber\")])\n@@ -3141,11 +3246,13 @@\n    (set_attr \"cc\" \"clobber\")])\n \n (define_insn \"ashrsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\"             \"=r,r,r,r,r,r,r\")\n-\t(ashiftrt:SI (match_operand:SI 1 \"register_operand\" \"0,0,0,r,0,0,0\")\n-\t\t     (match_operand:QI 2 \"general_operand\"  \"r,L,P,O,K,n,Qm\")))]\n+  [(set (match_operand:SI 0 \"register_operand\"                \"=r,r,r,r,r,r,r\")\n+        (ashiftrt:SI (match_operand:SI 1 \"register_operand\"    \"0,0,0,r,0,0,0\")\n+                     (match_operand:QI 2 \"nop_general_operand\" \"r,L,P,O,K,n,Qm\")))]\n   \"\"\n-  \"* return ashrsi3_out (insn, operands, NULL);\"\n+  {\n+    return ashrsi3_out (insn, operands, NULL);\n+  }\n   [(set_attr \"length\" \"8,0,4,6,8,10,12\")\n    (set_attr \"adjust_len\" \"ashrsi\")\n    (set_attr \"cc\" \"clobber,none,clobber,set_n,clobber,clobber,clobber\")])\n@@ -3164,11 +3271,13 @@\n \n (define_insn \"*ashrhi3_const\"\n   [(set (match_operand:HI 0 \"register_operand\"              \"=r,r,r,r,r\")\n-\t(ashiftrt:HI (match_operand:HI 1 \"register_operand\"  \"0,0,r,0,0\")\n-\t\t     (match_operand:QI 2 \"const_int_operand\" \"L,P,O,K,n\")))\n-   (clobber (match_scratch:QI 3 \"=X,X,X,X,&d\"))]\n+        (ashiftrt:HI (match_operand:HI 1 \"register_operand\"  \"0,0,r,0,0\")\n+                     (match_operand:QI 2 \"const_int_operand\" \"L,P,O,K,n\")))\n+   (clobber (match_scratch:QI 3                             \"=X,X,X,X,&d\"))]\n   \"reload_completed\"\n-  \"* return ashrhi3_out (insn, operands, NULL);\"\n+  {\n+    return ashrhi3_out (insn, operands, NULL);\n+  }\n   [(set_attr \"length\" \"0,2,4,4,10\")\n    (set_attr \"adjust_len\" \"ashrhi\")\n    (set_attr \"cc\" \"none,clobber,set_n,clobber,clobber\")])\n@@ -3185,11 +3294,13 @@\n \n (define_insn \"*ashrsi3_const\"\n   [(set (match_operand:SI 0 \"register_operand\"              \"=r,r,r,r\")\n-\t(ashiftrt:SI (match_operand:SI 1 \"register_operand\"  \"0,0,r,0\")\n-\t\t     (match_operand:QI 2 \"const_int_operand\" \"L,P,O,n\")))\n-   (clobber (match_scratch:QI 3 \"=X,X,X,&d\"))]\n+        (ashiftrt:SI (match_operand:SI 1 \"register_operand\"  \"0,0,r,0\")\n+                     (match_operand:QI 2 \"const_int_operand\" \"L,P,O,n\")))\n+   (clobber (match_scratch:QI 3                             \"=X,X,X,&d\"))]\n   \"reload_completed\"\n-  \"* return ashrsi3_out (insn, operands, NULL);\"\n+  {\n+    return ashrsi3_out (insn, operands, NULL);\n+  }\n   [(set_attr \"length\" \"0,4,4,10\")\n    (set_attr \"adjust_len\" \"ashrsi\")\n    (set_attr \"cc\" \"none,clobber,set_n,clobber\")])\n@@ -3198,11 +3309,9 @@\n ;; logical shift right\n \n (define_expand \"lshrqi3\"\n-  [(set (match_operand:QI 0 \"register_operand\"              \"\")\n-\t(lshiftrt:QI (match_operand:QI 1 \"register_operand\" \"\")\n-\t\t     (match_operand:QI 2 \"general_operand\"  \"\")))]\n-  \"\"\n-  \"\")\n+  [(set (match_operand:QI 0 \"register_operand\" \"\")\n+        (lshiftrt:QI (match_operand:QI 1 \"register_operand\" \"\")\n+                     (match_operand:QI 2 \"nop_general_operand\" \"\")))])\n \n (define_split\t; lshrqi3_const4\n   [(set (match_operand:QI 0 \"d_register_operand\" \"\")\n@@ -3234,21 +3343,25 @@\n   \"\")\n \n (define_insn \"*lshrqi3\"\n-  [(set (match_operand:QI 0 \"register_operand\"             \"=r,r,r,r,!d,r,r\")\n-\t(lshiftrt:QI (match_operand:QI 1 \"register_operand\" \"0,0,0,0,0,0,0\")\n-\t\t     (match_operand:QI 2 \"general_operand\"  \"r,L,P,K,n,n,Qm\")))]\n+  [(set (match_operand:QI 0 \"register_operand\"                \"=r,r,r,r,!d,r,r\")\n+        (lshiftrt:QI (match_operand:QI 1 \"register_operand\"    \"0,0,0,0,0 ,0,0\")\n+                     (match_operand:QI 2 \"nop_general_operand\" \"r,L,P,K,n ,n,Qm\")))]\n   \"\"\n-  \"* return lshrqi3_out (insn, operands, NULL);\"\n+  {\n+    return lshrqi3_out (insn, operands, NULL);\n+  }\n   [(set_attr \"length\" \"5,0,1,2,4,6,9\")\n    (set_attr \"adjust_len\" \"lshrqi\")\n    (set_attr \"cc\" \"clobber,none,set_czn,set_czn,set_czn,set_czn,clobber\")])\n \n (define_insn \"lshrhi3\"\n-  [(set (match_operand:HI 0 \"register_operand\"             \"=r,r,r,r,r,r,r\")\n-\t(lshiftrt:HI (match_operand:HI 1 \"register_operand\" \"0,0,0,r,0,0,0\")\n-\t\t     (match_operand:QI 2 \"general_operand\"  \"r,L,P,O,K,n,Qm\")))]\n+  [(set (match_operand:HI 0 \"register_operand\"                \"=r,r,r,r,r,r,r\")\n+        (lshiftrt:HI (match_operand:HI 1 \"register_operand\"    \"0,0,0,r,0,0,0\")\n+                     (match_operand:QI 2 \"nop_general_operand\" \"r,L,P,O,K,n,Qm\")))]\n   \"\"\n-  \"* return lshrhi3_out (insn, operands, NULL);\"\n+  {\n+    return lshrhi3_out (insn, operands, NULL);\n+  }\n   [(set_attr \"length\" \"6,0,2,2,4,10,10\")\n    (set_attr \"adjust_len\" \"lshrhi\")\n    (set_attr \"cc\" \"clobber,none,clobber,clobber,clobber,clobber,clobber\")])\n@@ -3266,11 +3379,13 @@\n    (set_attr \"cc\" \"clobber\")])\n \n (define_insn \"lshrsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\"             \"=r,r,r,r,r,r,r\")\n-\t(lshiftrt:SI (match_operand:SI 1 \"register_operand\" \"0,0,0,r,0,0,0\")\n-\t\t     (match_operand:QI 2 \"general_operand\"  \"r,L,P,O,K,n,Qm\")))]\n+  [(set (match_operand:SI 0 \"register_operand\"                \"=r,r,r,r,r,r,r\")\n+        (lshiftrt:SI (match_operand:SI 1 \"register_operand\"    \"0,0,0,r,0,0,0\")\n+                     (match_operand:QI 2 \"nop_general_operand\" \"r,L,P,O,K,n,Qm\")))]\n   \"\"\n-  \"* return lshrsi3_out (insn, operands, NULL);\"\n+  {\n+    return lshrsi3_out (insn, operands, NULL);\n+  }\n   [(set_attr \"length\" \"8,0,4,4,8,10,12\")\n    (set_attr \"adjust_len\" \"lshrsi\")\n    (set_attr \"cc\" \"clobber,none,clobber,clobber,clobber,clobber,clobber\")])\n@@ -3324,11 +3439,13 @@\n \n (define_insn \"*lshrhi3_const\"\n   [(set (match_operand:HI 0 \"register_operand\"              \"=r,r,r,r,r\")\n-\t(lshiftrt:HI (match_operand:HI 1 \"register_operand\"  \"0,0,r,0,0\")\n-\t\t     (match_operand:QI 2 \"const_int_operand\" \"L,P,O,K,n\")))\n-   (clobber (match_scratch:QI 3 \"=X,X,X,X,&d\"))]\n+        (lshiftrt:HI (match_operand:HI 1 \"register_operand\"  \"0,0,r,0,0\")\n+                     (match_operand:QI 2 \"const_int_operand\" \"L,P,O,K,n\")))\n+   (clobber (match_scratch:QI 3                             \"=X,X,X,X,&d\"))]\n   \"reload_completed\"\n-  \"* return lshrhi3_out (insn, operands, NULL);\"\n+  {\n+    return lshrhi3_out (insn, operands, NULL);\n+  }\n   [(set_attr \"length\" \"0,2,2,4,10\")\n    (set_attr \"adjust_len\" \"lshrhi\")\n    (set_attr \"cc\" \"none,clobber,clobber,clobber,clobber\")])\n@@ -3345,11 +3462,13 @@\n \n (define_insn \"*lshrsi3_const\"\n   [(set (match_operand:SI 0 \"register_operand\"              \"=r,r,r,r\")\n-\t(lshiftrt:SI (match_operand:SI 1 \"register_operand\"  \"0,0,r,0\")\n-\t\t     (match_operand:QI 2 \"const_int_operand\" \"L,P,O,n\")))\n-   (clobber (match_scratch:QI 3 \"=X,X,X,&d\"))]\n+        (lshiftrt:SI (match_operand:SI 1 \"register_operand\"  \"0,0,r,0\")\n+                     (match_operand:QI 2 \"const_int_operand\" \"L,P,O,n\")))\n+   (clobber (match_scratch:QI 3                             \"=X,X,X,&d\"))]\n   \"reload_completed\"\n-  \"* return lshrsi3_out (insn, operands, NULL);\"\n+  {\n+    return lshrsi3_out (insn, operands, NULL);\n+  }\n   [(set_attr \"length\" \"0,4,4,10\")\n    (set_attr \"adjust_len\" \"lshrsi\")\n    (set_attr \"cc\" \"none,clobber,clobber,clobber\")])\n@@ -3615,6 +3734,27 @@\n     operands[3] = simplify_gen_subreg (QImode, operands[0], PSImode, 2);\n   })\n \n+(define_insn_and_split \"n_extendhipsi2\"\n+  [(set (match_operand:PSI 0 \"register_operand\"            \"=r,r,d,r\")\n+        (lo_sum:PSI (match_operand:QI 1 \"const_int_operand\" \"L,P,n,n\")\n+                    (match_operand:HI 2 \"register_operand\"  \"r,r,r,r\")))\n+   (clobber (match_scratch:QI 3                            \"=X,X,X,&d\"))]\n+  \"\"\n+  \"#\"\n+  \"reload_completed\"\n+  [(set (match_dup 4) (match_dup 2))\n+   (set (match_dup 3) (match_dup 6))\n+   ; no-op move in the case where no scratch is needed\n+   (set (match_dup 5) (match_dup 3))]\n+  {\n+    operands[4] = simplify_gen_subreg (HImode, operands[0], PSImode, 0);\n+    operands[5] = simplify_gen_subreg (QImode, operands[0], PSImode, 2);\n+    operands[6] = operands[1];\n+\n+    if (GET_CODE (operands[3]) == SCRATCH)\n+      operands[3] = operands[5];\n+  })\n+\n (define_insn_and_split \"zero_extendhisi2\"\n   [(set (match_operand:SI 0 \"register_operand\"                               \"=r\")\n         (zero_extend:SI (match_operand:HI 1 \"combine_pseudo_register_operand\" \"r\")))]"}, {"sha": "9f595cbfb2922c9f0838ca3aa36eb0458f011781", "filename": "gcc/config/avr/predicates.md", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c209481147555ddd22296b1eff0fd1833588d35/gcc%2Fconfig%2Favr%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c209481147555ddd22296b1eff0fd1833588d35/gcc%2Fconfig%2Favr%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Fpredicates.md?ref=7c209481147555ddd22296b1eff0fd1833588d35", "patch": "@@ -57,6 +57,17 @@\n   (and (match_code \"const_int\")\n        (match_test \"IN_RANGE((INTVAL (op)), 0x20, (0x60 - GET_MODE_SIZE(mode)))\")))\n \n+;; Return 1 if OP is a general operand not in program memory\n+(define_predicate \"nop_general_operand\"\n+  (and (match_operand 0 \"general_operand\")\n+       (match_test \"!avr_mem_pgm_p (op)\")))\n+\n+;; Return 1 if OP is an \"ordinary\" general operand, i.e. a general\n+;; operand whose load is not handled by a libgcc call.\n+(define_predicate \"nox_general_operand\"\n+  (and (match_operand 0 \"general_operand\")\n+       (match_test \"!avr_load_libgcc_p (op)\")))\n+\n ;; Return 1 if OP is the zero constant for MODE.\n (define_predicate \"const0_operand\"\n   (and (match_code \"const_int,const_double\")"}, {"sha": "c4bb2f2274b917f40dc96754fea1364fa438a5e4", "filename": "libgcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c209481147555ddd22296b1eff0fd1833588d35/libgcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c209481147555ddd22296b1eff0fd1833588d35/libgcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FChangeLog?ref=7c209481147555ddd22296b1eff0fd1833588d35", "patch": "@@ -1,3 +1,9 @@\n+2011-11-15  Georg-Johann Lay  <avr@gjlay.de>\n+\n+\tPR target/49868\n+\t* config/avr/t-avr (LIB1ASMFUNCS): Add _load_3,  _load_4.\n+\t* config/avr/lib1funcs.S (__load_3, __load_4, __xload_2): New functions.\n+\n 2011-11-13  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>\n \n \t* config.host (hppa*64*-*-hpux11*): Remove pa/t-stublib64 from"}, {"sha": "573761b619a9c54295a69671d39f555f005a2af1", "filename": "libgcc/config/avr/lib1funcs.S", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c209481147555ddd22296b1eff0fd1833588d35/libgcc%2Fconfig%2Favr%2Flib1funcs.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c209481147555ddd22296b1eff0fd1833588d35/libgcc%2Fconfig%2Favr%2Flib1funcs.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Favr%2Flib1funcs.S?ref=7c209481147555ddd22296b1eff0fd1833588d35", "patch": "@@ -1181,6 +1181,52 @@ DEFUN __tablejump_elpm__\n ENDF __tablejump_elpm__\n #endif /* defined (L_tablejump_elpm) */\n \n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;; Loading n bytes from Flash; n = 3,4\n+;; R22... = Flash[Z]\n+;; Clobbers: __tmp_reg__\n+\n+#if (defined (L_load_3)        \\\n+     || defined (L_load_4))    \\\n+    && !defined (__AVR_HAVE_LPMX__)\n+\n+;; Destination\n+#define D0  22\n+#define D1  D0+1\n+#define D2  D0+2\n+#define D3  D0+3\n+\n+.macro  .load dest, n\n+    lpm\n+    mov     \\dest, r0\n+.if \\dest != D0+\\n-1\n+    adiw    r30, 1\n+.else\n+    sbiw    r30, \\n-1\n+.endif\n+.endm\n+\n+#if defined (L_load_3)\n+DEFUN __load_3\n+    push  D3\n+    XCALL __load_4\n+    pop   D3\n+    ret\n+ENDF __load_3\n+#endif /* L_load_3 */\n+\n+#if defined (L_load_4)\n+DEFUN __load_4\n+    .load D0, 4\n+    .load D1, 4\n+    .load D2, 4\n+    .load D3, 4\n+    ret\n+ENDF __load_4\n+#endif /* L_load_4 */\n+\n+#endif /* L_load_3 || L_load_3 */\n+\n \f\n .section .text.libgcc.builtins, \"ax\", @progbits\n "}, {"sha": "486214cf31b4b9a7eb96e9c193b66682e2ff30b7", "filename": "libgcc/config/avr/t-avr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7c209481147555ddd22296b1eff0fd1833588d35/libgcc%2Fconfig%2Favr%2Ft-avr", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7c209481147555ddd22296b1eff0fd1833588d35/libgcc%2Fconfig%2Favr%2Ft-avr", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Favr%2Ft-avr?ref=7c209481147555ddd22296b1eff0fd1833588d35", "patch": "@@ -21,6 +21,7 @@ LIB1ASMFUNCS = \\\n \t_cleanup \\\n \t_tablejump \\\n \t_tablejump_elpm \\\n+\t_load_3 _load_4 \\\n \t_copy_data \\\n \t_clear_bss \\\n \t_ctors \\"}]}