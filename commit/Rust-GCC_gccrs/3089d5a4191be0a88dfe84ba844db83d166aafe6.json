{"sha": "3089d5a4191be0a88dfe84ba844db83d166aafe6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzA4OWQ1YTQxOTFiZTBhODhkZmU4NGJhODQ0ZGI4M2QxNjZhYWZlNg==", "commit": {"author": {"name": "Paolo Carlini", "email": "pcarlini@suse.de", "date": "2006-02-08T21:51:55Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2006-02-08T21:51:55Z"}, "message": "PR libstdc++/26133 (DR 241, [WP])\n\n2006-02-08  Paolo Carlini  <pcarlini@suse.de>\n\n\tPR libstdc++/26133  (DR 241, [WP])\n\t* include/bits/stl_algo.h (__unique_copy(,,, forward_iterator_tag,\n\toutput_iterator_tag), __unique_copy(,,, input_iterator_tag,\n\toutput_iterator_tag), __unique_copy(,,, input_iterator_tag,\n\tforward_iterator_tag), and predicated counterparts): Add.\n\t(__unique_copy(,,, output_iterator_tag), __unique_copy(,,,\n\tforward_iterator_tag), and predicated counterparts): Remove.\n\t(unique_copy): Adjust, dispatch to the three helpers above.\n\t* testsuite/25_algorithms/unique_copy/2.cc: New.\n\t* testsuite/25_algorithms/unique_copy/26133.cc: Likewise.\n\t* testsuite/25_algorithms/unique_copy/3.cc: Likewise.\t\n\t* docs/html/ext/howto.html: Add an entry for DR 241.\n\n\t* testsuite/25_algorithms/unique_copy/1.cc: Minor cosmetic changes.\n\nFrom-SVN: r110772", "tree": {"sha": "afc9e7468effc2459be7ba1df3d25e2c9349c86f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/afc9e7468effc2459be7ba1df3d25e2c9349c86f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3089d5a4191be0a88dfe84ba844db83d166aafe6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3089d5a4191be0a88dfe84ba844db83d166aafe6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3089d5a4191be0a88dfe84ba844db83d166aafe6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3089d5a4191be0a88dfe84ba844db83d166aafe6/comments", "author": null, "committer": null, "parents": [{"sha": "5f8f531322798fed73c507580e602903b96ab122", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f8f531322798fed73c507580e602903b96ab122", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5f8f531322798fed73c507580e602903b96ab122"}], "stats": {"total": 434, "additions": 380, "deletions": 54}, "files": [{"sha": "84e399303c82db847afbccddd9ef8dc66d353306", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3089d5a4191be0a88dfe84ba844db83d166aafe6/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3089d5a4191be0a88dfe84ba844db83d166aafe6/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=3089d5a4191be0a88dfe84ba844db83d166aafe6", "patch": "@@ -1,3 +1,20 @@\n+2006-02-08  Paolo Carlini  <pcarlini@suse.de>\n+\n+\tPR libstdc++/26133  (DR 241, [WP])\n+\t* include/bits/stl_algo.h (__unique_copy(,,, forward_iterator_tag,\n+\toutput_iterator_tag), __unique_copy(,,, input_iterator_tag,\n+\toutput_iterator_tag), __unique_copy(,,, input_iterator_tag,\n+\tforward_iterator_tag), and predicated counterparts): Add.\n+\t(__unique_copy(,,, output_iterator_tag), __unique_copy(,,,\n+\tforward_iterator_tag), and predicated counterparts): Remove.\n+\t(unique_copy): Adjust, dispatch to the three helpers above.\n+\t* testsuite/25_algorithms/unique_copy/2.cc: New.\n+\t* testsuite/25_algorithms/unique_copy/26133.cc: Likewise.\n+\t* testsuite/25_algorithms/unique_copy/3.cc: Likewise.\t\n+\t* docs/html/ext/howto.html: Add an entry for DR 241.\n+\n+\t* testsuite/25_algorithms/unique_copy/1.cc: Minor cosmetic changes.\n+\n 2006-02-07  Jakub Jelinek  <jakub@redhat.com>\n \t    Benjamin Kosnik  <bkoz@redhat.com>\n "}, {"sha": "6aaf994ae50810e7d70052d1df1764c0f8138931", "filename": "libstdc++-v3/docs/html/ext/howto.html", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3089d5a4191be0a88dfe84ba844db83d166aafe6/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Fext%2Fhowto.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3089d5a4191be0a88dfe84ba844db83d166aafe6/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Fext%2Fhowto.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Fext%2Fhowto.html?ref=3089d5a4191be0a88dfe84ba844db83d166aafe6", "patch": "@@ -413,6 +413,13 @@ <h2><a name=\"5\">LWG Issues</a></h2>\n         However, no specification is given what this constructor should do.\n     </dd>\n \n+    <dt><a href=\"lwg-defects.html#241\">241</a>:\n+        <em>Does unique_copy() require CopyConstructible and Assignable?</em>\n+    </dt>\n+    <dd>Add an helper for forward_iterator/output_iterator, fix the existing\n+        one for input_iterator/output_iterator not to rely on Assignability.\n+    </dd>\n+\n     <dt><a href=\"lwg-defects.html#243\">243</a>:\n         <em>get and getline when sentry reports failure</em>\n     </dt>"}, {"sha": "d5c8f9ddde67a3bf77d5d65ebc986112f5f32bae", "filename": "libstdc++-v3/include/bits/stl_algo.h", "status": "modified", "additions": 116, "deletions": 43, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3089d5a4191be0a88dfe84ba844db83d166aafe6/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3089d5a4191be0a88dfe84ba844db83d166aafe6/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algo.h?ref=3089d5a4191be0a88dfe84ba844db83d166aafe6", "patch": "@@ -1,6 +1,7 @@\n // Algorithm implementation -*- C++ -*-\n \n-// Copyright (C) 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.\n+// Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006\n+// Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -1294,23 +1295,23 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n    *  @if maint\n    *  This is an uglified unique_copy(_InputIterator, _InputIterator,\n    *                                  _OutputIterator)\n-   *  overloaded for output iterators.\n+   *  overloaded for forward iterators and output iterator as result.\n    *  @endif\n   */\n-  template<typename _InputIterator, typename _OutputIterator>\n+  template<typename _ForwardIterator, typename _OutputIterator>\n     _OutputIterator\n-    __unique_copy(_InputIterator __first, _InputIterator __last,\n+    __unique_copy(_ForwardIterator __first, _ForwardIterator __last,\n \t\t  _OutputIterator __result,\n-\t\t  output_iterator_tag)\n+\t\t  forward_iterator_tag, output_iterator_tag)\n     {\n       // concept requirements -- taken care of in dispatching function\n-      typename iterator_traits<_InputIterator>::value_type __value = *__first;\n-      *__result = __value;\n-      while (++__first != __last)\n-\tif (!(__value == *__first))\n+      _ForwardIterator __next = __first;\n+      *__result = *__first;\n+      while (++__next != __last)\n+\tif (!(*__first == *__next))\n \t  {\n-\t    __value = *__first;\n-\t    *++__result = __value;\n+\t    __first = __next;\n+\t    *++__result = *__first;\n \t  }\n       return ++__result;\n     }\n@@ -1319,14 +1320,43 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n    *  @if maint\n    *  This is an uglified unique_copy(_InputIterator, _InputIterator,\n    *                                  _OutputIterator)\n-   *  overloaded for forward iterators.\n+   *  overloaded for input iterators and output iterator as result.\n+   *  @endif\n+  */\n+  template<typename _InputIterator, typename _OutputIterator>\n+    _OutputIterator\n+    __unique_copy(_InputIterator __first, _InputIterator __last,\n+\t\t  _OutputIterator __result,\n+\t\t  input_iterator_tag, output_iterator_tag)\n+    {\n+      // concept requirements -- taken care of in dispatching function\n+      *__result = *__first;\n+      while (true)\n+\t{\n+\t  typename\n+\t    iterator_traits<_InputIterator>::value_type __value = *__first;\n+\n+\t  if (++__first == __last)\n+\t    break;\n+\t  \n+\t  if (!(__value == *__first))\n+\t    *++__result = *__first;\n+\t}\n+      return ++__result;\n+    }\n+\n+  /**\n+   *  @if maint\n+   *  This is an uglified unique_copy(_InputIterator, _InputIterator,\n+   *                                  _OutputIterator)\n+   *  overloaded for input iterators and forward iterator as result.\n    *  @endif\n   */\n   template<typename _InputIterator, typename _ForwardIterator>\n     _ForwardIterator\n     __unique_copy(_InputIterator __first, _InputIterator __last,\n \t\t  _ForwardIterator __result,\n-\t\t  forward_iterator_tag)\n+\t\t  input_iterator_tag, forward_iterator_tag)\n     {\n       // concept requirements -- taken care of in dispatching function\n       *__result = *__first;\n@@ -1341,30 +1371,64 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n    *  This is an uglified\n    *  unique_copy(_InputIterator, _InputIterator, _OutputIterator,\n    *              _BinaryPredicate)\n-   *  overloaded for output iterators.\n+   *  overloaded for forward iterators and output iterator as result.\n+   *  @endif\n+  */\n+  template<typename _ForwardIterator, typename _OutputIterator,\n+\t   typename _BinaryPredicate>\n+    _OutputIterator\n+    __unique_copy(_ForwardIterator __first, _ForwardIterator __last,\n+\t\t  _OutputIterator __result, _BinaryPredicate __binary_pred,\n+\t\t  forward_iterator_tag, output_iterator_tag)\n+    {\n+      // concept requirements -- iterators already checked\n+      __glibcxx_function_requires(_BinaryPredicateConcept<_BinaryPredicate,\n+\t  typename iterator_traits<_ForwardIterator>::value_type,\n+\t  typename iterator_traits<_ForwardIterator>::value_type>)\n+\n+      _ForwardIterator __next = __first;\n+      *__result = *__first;\n+      while (++__next != __last)\n+\tif (!__binary_pred(*__first, *__next))\n+\t  {\n+\t    __first = __next;\n+\t    *++__result = *__first;\n+\t  }\n+      return ++__result;\n+    }\n+\n+  /**\n+   *  @if maint\n+   *  This is an uglified\n+   *  unique_copy(_InputIterator, _InputIterator, _OutputIterator,\n+   *              _BinaryPredicate)\n+   *  overloaded for input iterators and output iterator as result.\n    *  @endif\n   */\n   template<typename _InputIterator, typename _OutputIterator,\n \t   typename _BinaryPredicate>\n     _OutputIterator\n     __unique_copy(_InputIterator __first, _InputIterator __last,\n-\t\t  _OutputIterator __result,\n-\t\t  _BinaryPredicate __binary_pred,\n-\t\t  output_iterator_tag)\n+\t\t  _OutputIterator __result, _BinaryPredicate __binary_pred,\n+\t\t  input_iterator_tag, output_iterator_tag)\n     {\n       // concept requirements -- iterators already checked\n       __glibcxx_function_requires(_BinaryPredicateConcept<_BinaryPredicate,\n \t  typename iterator_traits<_InputIterator>::value_type,\n \t  typename iterator_traits<_InputIterator>::value_type>)\n \n-      typename iterator_traits<_InputIterator>::value_type __value = *__first;\n-      *__result = __value;\n-      while (++__first != __last)\n-\tif (!__binary_pred(__value, *__first))\n-\t  {\n-\t    __value = *__first;\n-\t    *++__result = __value;\n-\t  }\n+      *__result = *__first;\n+      while (true)\n+\t{\n+\t  typename\n+\t    iterator_traits<_InputIterator>::value_type __value = *__first;\n+\n+\t  if (++__first == __last)\n+\t    break;\n+\t  \n+\t  if (!__binary_pred(__value, *__first))\n+\t    *++__result = *__first;\n+\t}\n       return ++__result;\n     }\n \n@@ -1373,25 +1437,25 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n    *  This is an uglified\n    *  unique_copy(_InputIterator, _InputIterator, _OutputIterator,\n    *              _BinaryPredicate)\n-   *  overloaded for forward iterators.\n+   *  overloaded for input iterators and forward iterator as result.\n    *  @endif\n   */\n   template<typename _InputIterator, typename _ForwardIterator,\n \t   typename _BinaryPredicate>\n     _ForwardIterator\n     __unique_copy(_InputIterator __first, _InputIterator __last,\n-\t\t  _ForwardIterator __result,\n-\t\t  _BinaryPredicate __binary_pred,\n-\t\t  forward_iterator_tag)\n+\t\t  _ForwardIterator __result, _BinaryPredicate __binary_pred,\n+\t\t  input_iterator_tag, forward_iterator_tag)\n     {\n       // concept requirements -- iterators already checked\n       __glibcxx_function_requires(_BinaryPredicateConcept<_BinaryPredicate,\n-\t    typename iterator_traits<_ForwardIterator>::value_type,\n-\t    typename iterator_traits<_InputIterator>::value_type>)\n+\t  typename iterator_traits<_ForwardIterator>::value_type,\n+\t  typename iterator_traits<_InputIterator>::value_type>)\n \n       *__result = *__first;\n       while (++__first != __last)\n-\tif (!__binary_pred(*__result, *__first)) *++__result = *__first;\n+\tif (!__binary_pred(*__result, *__first))\n+\t  *++__result = *__first;\n       return ++__result;\n     }\n \n@@ -1407,6 +1471,11 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n    *  from groups of consecutive elements that compare equal.\n    *  unique_copy() is stable, so the relative order of elements that are\n    *  copied is unchanged.\n+   *\n+   *  @if maint\n+   *  _GLIBCXX_RESOLVE_LIB_DEFECTS\n+   *  DR 241. Does unique_copy() require CopyConstructible and Assignable?\n+   *  @endif\n   */\n   template<typename _InputIterator, typename _OutputIterator>\n     inline _OutputIterator\n@@ -1421,11 +1490,11 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n \t    typename iterator_traits<_InputIterator>::value_type>)\n       __glibcxx_requires_valid_range(__first, __last);\n \n-      typedef typename iterator_traits<_OutputIterator>::iterator_category\n-\t_IterType;\n-\n-      if (__first == __last) return __result;\n-      return std::__unique_copy(__first, __last, __result, _IterType());\n+      if (__first == __last)\n+\treturn __result;\n+      return std::__unique_copy(__first, __last, __result,\n+\t\t\t\tstd::__iterator_category(__first),\n+\t\t\t\tstd::__iterator_category(__result));\n     }\n \n   /**\n@@ -1442,6 +1511,11 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n    *  true.\n    *  unique_copy() is stable, so the relative order of elements that are\n    *  copied is unchanged.\n+   *\n+   *  @if maint\n+   *  _GLIBCXX_RESOLVE_LIB_DEFECTS\n+   *  DR 241. Does unique_copy() require CopyConstructible and Assignable?\n+   *  @endif\n   */\n   template<typename _InputIterator, typename _OutputIterator,\n \t   typename _BinaryPredicate>\n@@ -1456,12 +1530,11 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n \t    typename iterator_traits<_InputIterator>::value_type>)\n       __glibcxx_requires_valid_range(__first, __last);\n \n-      typedef typename iterator_traits<_OutputIterator>::iterator_category\n-\t_IterType;\n-\n-      if (__first == __last) return __result;\n-      return std::__unique_copy(__first, __last, __result,\n-\t\t\t\t__binary_pred, _IterType());\n+      if (__first == __last)\n+\treturn __result;\n+      return std::__unique_copy(__first, __last, __result, __binary_pred,\n+\t\t\t\tstd::__iterator_category(__first),\n+\t\t\t\tstd::__iterator_category(__result));\n     }\n \n   /**"}, {"sha": "06a38f8fee1ec5cc6f6027f4e04e7528831c1942", "filename": "libstdc++-v3/testsuite/25_algorithms/unique_copy/1.cc", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3089d5a4191be0a88dfe84ba844db83d166aafe6/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Funique_copy%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3089d5a4191be0a88dfe84ba844db83d166aafe6/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Funique_copy%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Funique_copy%2F1.cc?ref=3089d5a4191be0a88dfe84ba844db83d166aafe6", "patch": "@@ -1,4 +1,4 @@\n-// Copyright (C) 2005 Free Software Foundation, Inc.\n+// Copyright (C) 2005, 2006 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -16,7 +16,7 @@\n // Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n // USA.\n \n-// 25.5.8 [lib.alg.unique]\n+// 25.2.8 [lib.alg.unique]\n \n #include <algorithm>\n #include <testsuite_hooks.h>\n@@ -26,7 +26,7 @@ using __gnu_test::test_container;\n using __gnu_test::input_iterator_wrapper;\n using __gnu_test::forward_iterator_wrapper;\n using __gnu_test::output_iterator_wrapper;\n-using std::unique;\n+using std::unique_copy;\n \n typedef test_container<int, input_iterator_wrapper> Icontainer;\n typedef test_container<int, forward_iterator_wrapper> Fcontainer;\n@@ -41,7 +41,7 @@ test1()\n   bool test __attribute__((unused)) = true;\n   Icontainer con1(array1, array1);\n   Ocontainer con2(array2, array2);\n-  VERIFY(unique_copy(con1.begin(), con1.end(), con2.begin()).ptr == array2);\n+  VERIFY( unique_copy(con1.begin(), con1.end(), con2.begin()).ptr == array2 );\n }\n \n void\n@@ -50,9 +50,9 @@ test2()\n   bool test __attribute__((unused)) = true;\n   Icontainer con1(array1, array1 + 6);\n   Ocontainer con2(array2, array2 + 2);\n-  VERIFY(unique_copy(con1.begin(), con1.end(), con2.begin()).ptr \n-         == array2 + 2);\n-  VERIFY(array2[0] == 0 && array2[1] == 1);\n+  VERIFY( unique_copy(con1.begin(), con1.end(), con2.begin()).ptr \n+\t  == array2 + 2 );\n+  VERIFY( array2[0] == 0 && array2[1] == 1 );\n }\n \n void\n@@ -61,7 +61,7 @@ test3()\n   bool test __attribute__((unused)) = true;\n   Icontainer con1(array1, array1);\n   Fcontainer con2(array2, array2);\n-  VERIFY(unique_copy(con1.begin(), con1.end(), con2.begin()).ptr == array2);\n+  VERIFY( unique_copy(con1.begin(), con1.end(), con2.begin()).ptr == array2 );\n }\n \n void\n@@ -70,9 +70,9 @@ test4()\n   bool test __attribute__((unused)) = true;\n   Icontainer con1(array1, array1 + 6);\n   Fcontainer con2(array2, array2 + 2);\n-  VERIFY(unique_copy(con1.begin(), con1.end(), con2.begin()).ptr\n-         == array2 + 2);\n-  VERIFY(array2[0] == 0 && array2[1] == 1);\n+  VERIFY( unique_copy(con1.begin(), con1.end(), con2.begin()).ptr\n+\t  == array2 + 2 );\n+  VERIFY( array2[0] == 0 && array2[1] == 1 );\n }\n \n int "}, {"sha": "135009165420891e4cf2ba04ea337c7368411961", "filename": "libstdc++-v3/testsuite/25_algorithms/unique_copy/2.cc", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3089d5a4191be0a88dfe84ba844db83d166aafe6/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Funique_copy%2F2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3089d5a4191be0a88dfe84ba844db83d166aafe6/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Funique_copy%2F2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Funique_copy%2F2.cc?ref=3089d5a4191be0a88dfe84ba844db83d166aafe6", "patch": "@@ -0,0 +1,85 @@\n+// Copyright (C) 2006 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// 25.2.8 [lib.alg.unique]\n+\n+#include <algorithm>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+using __gnu_test::test_container;\n+using __gnu_test::forward_iterator_wrapper;\n+using __gnu_test::output_iterator_wrapper;\n+using std::unique_copy;\n+using std::equal_to;\n+\n+typedef test_container<int, forward_iterator_wrapper> Fcontainer;\n+typedef test_container<int, output_iterator_wrapper> Ocontainer;\n+\n+int array1[] = {0, 0, 0, 1, 1, 1};\n+int array2[2];\n+\n+void\n+test1()\n+{\n+  bool test __attribute__((unused)) = true;\n+  Fcontainer con1(array1, array1);\n+  Ocontainer con2(array2, array2);\n+  VERIFY( unique_copy(con1.begin(), con1.end(), con2.begin()).ptr == array2 );\n+}\n+\n+void\n+test2()\n+{\n+  bool test __attribute__((unused)) = true;\n+  Fcontainer con1(array1, array1 + 6);\n+  Ocontainer con2(array2, array2 + 2);\n+  VERIFY( unique_copy(con1.begin(), con1.end(), con2.begin()).ptr\n+\t  == array2 + 2 );\n+  VERIFY( array2[0] == 0 && array2[1] == 1 );\n+}\n+\n+void\n+test3()\n+{\n+  bool test __attribute__((unused)) = true;\n+  Fcontainer con1(array1, array1);\n+  Ocontainer con2(array2, array2);\n+  VERIFY( unique_copy(con1.begin(), con1.end(), con2.begin(),\n+\t\t      equal_to<int>()).ptr == array2 );\n+}\n+\n+void\n+test4()\n+{\n+  bool test __attribute__((unused)) = true;\n+  Fcontainer con1(array1, array1 + 6);\n+  Ocontainer con2(array2, array2 + 2);\n+  VERIFY( unique_copy(con1.begin(), con1.end(), con2.begin(),\n+\t\t      equal_to<int>()).ptr == array2 + 2 );\n+  VERIFY( array2[0] == 0 && array2[1] == 1 );\n+}\n+\n+int \n+main()\n+{\n+  test1();\n+  test2();\n+  test3();\n+  test4();\n+}"}, {"sha": "2c77667a12c4db85db9809a8bfada6c2de405862", "filename": "libstdc++-v3/testsuite/25_algorithms/unique_copy/26133.cc", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3089d5a4191be0a88dfe84ba844db83d166aafe6/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Funique_copy%2F26133.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3089d5a4191be0a88dfe84ba844db83d166aafe6/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Funique_copy%2F26133.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Funique_copy%2F26133.cc?ref=3089d5a4191be0a88dfe84ba844db83d166aafe6", "patch": "@@ -0,0 +1,51 @@\n+// Copyright (C) 2006 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+#include <algorithm>\n+#include <iterator>\n+#include <sstream>\n+#include <testsuite_hooks.h>\n+\n+struct no_assign\n+{\n+  int const x;\n+  no_assign() : x(23) { }\n+  operator int() const { return x; }\n+};\n+\n+// libstdc++/26133\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  std::ostringstream oss1, oss2;\n+\n+  no_assign in[4];\n+\n+  std::unique_copy(in, in + 4, std::ostream_iterator<int>(oss1, \"\\n\"));\n+  VERIFY( oss1.str() == \"23\\n\" );\n+\n+  std::unique_copy(in, in + 4, std::ostream_iterator<int>(oss2, \"\\n\"),\n+\t\t   std::equal_to<int>());\n+  VERIFY( oss2.str() == \"23\\n\" );\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "2245821f7c1233f2152bca8406aba59c8881b41e", "filename": "libstdc++-v3/testsuite/25_algorithms/unique_copy/3.cc", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3089d5a4191be0a88dfe84ba844db83d166aafe6/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Funique_copy%2F3.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3089d5a4191be0a88dfe84ba844db83d166aafe6/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Funique_copy%2F3.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Funique_copy%2F3.cc?ref=3089d5a4191be0a88dfe84ba844db83d166aafe6", "patch": "@@ -0,0 +1,93 @@\n+// Copyright (C) 2006 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n+// USA.\n+\n+// 25.2.8 [lib.alg.unique]\n+\n+#include <algorithm>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+using __gnu_test::test_container;\n+using __gnu_test::input_iterator_wrapper;\n+using __gnu_test::output_iterator_wrapper;\n+using std::unique_copy;\n+using std::equal_to;\n+\n+struct no_assign\n+{\n+  int const x;\n+  no_assign() : x(23) { }\n+  no_assign(int val) : x(val) { }\n+  operator int() const { return x; }\n+};\n+\n+typedef test_container<no_assign, input_iterator_wrapper> Icontainer;\n+typedef test_container<int, output_iterator_wrapper> Ocontainer;\n+\n+no_assign array1[] = {0, 0, 0, 1, 1, 1};\n+int array2[2];\n+\n+void\n+test1()\n+{\n+  bool test __attribute__((unused)) = true;\n+  Icontainer con1(array1, array1);\n+  Ocontainer con2(array2, array2);\n+  VERIFY( unique_copy(con1.begin(), con1.end(), con2.begin()).ptr == array2 );\n+}\n+\n+void\n+test2()\n+{\n+  bool test __attribute__((unused)) = true;\n+  Icontainer con1(array1, array1 + 6);\n+  Ocontainer con2(array2, array2 + 2);\n+  VERIFY( unique_copy(con1.begin(), con1.end(), con2.begin()).ptr\n+\t  == array2 + 2 );\n+  VERIFY( array2[0] == 0 && array2[1] == 1 );\n+}\n+\n+void\n+test3()\n+{\n+  bool test __attribute__((unused)) = true;\n+  Icontainer con1(array1, array1);\n+  Ocontainer con2(array2, array2);\n+  VERIFY( unique_copy(con1.begin(), con1.end(), con2.begin(),\n+\t\t      equal_to<int>()).ptr == array2 );\n+}\n+\n+void\n+test4()\n+{\n+  bool test __attribute__((unused)) = true;\n+  Icontainer con1(array1, array1 + 6);\n+  Ocontainer con2(array2, array2 + 2);\n+  VERIFY( unique_copy(con1.begin(), con1.end(), con2.begin(),\n+\t\t      equal_to<int>()).ptr == array2 + 2 );\n+  VERIFY( array2[0] == 0 && array2[1] == 1 );\n+}\n+\n+int \n+main()\n+{\n+  test1();\n+  test2();\n+  test3();\n+  test4();\n+}"}]}