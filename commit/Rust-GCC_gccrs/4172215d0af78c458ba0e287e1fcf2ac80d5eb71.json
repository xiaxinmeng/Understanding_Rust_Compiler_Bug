{"sha": "4172215d0af78c458ba0e287e1fcf2ac80d5eb71", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDE3MjIxNWQwYWY3OGM0NThiYTBlMjg3ZTFmY2YyYWM4MGQ1ZWI3MQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2013-05-31T19:12:05Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2013-05-31T19:12:05Z"}, "message": "predicates.md (rs6000_cbranch_operator): Accept some unordered comparison operators when...\n\n\t* config/rs6000/predicates.md (rs6000_cbranch_operator): Accept some\n\tunordered comparison operators when -fno-trapping-math is in effect\n\ton the e500.\n\t* config/rs6000/rs6000.c (rs6000_generate_compare): Remove dead code\n\tand implement unordered comparison operators properly on the e500.\n\nFrom-SVN: r199557", "tree": {"sha": "8839e3f25e5f8ccb1211432eea5838353cb12a4b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8839e3f25e5f8ccb1211432eea5838353cb12a4b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4172215d0af78c458ba0e287e1fcf2ac80d5eb71", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4172215d0af78c458ba0e287e1fcf2ac80d5eb71", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4172215d0af78c458ba0e287e1fcf2ac80d5eb71", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4172215d0af78c458ba0e287e1fcf2ac80d5eb71/comments", "author": null, "committer": null, "parents": [{"sha": "a8c50132e9e2c02c1692088b0f8aaad7a8716f4d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8c50132e9e2c02c1692088b0f8aaad7a8716f4d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a8c50132e9e2c02c1692088b0f8aaad7a8716f4d"}], "stats": {"total": 198, "additions": 175, "deletions": 23}, "files": [{"sha": "2ec1dccf6f84257141018e68eeb464604e9ad475", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4172215d0af78c458ba0e287e1fcf2ac80d5eb71/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4172215d0af78c458ba0e287e1fcf2ac80d5eb71/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4172215d0af78c458ba0e287e1fcf2ac80d5eb71", "patch": "@@ -1,3 +1,11 @@\n+2013-05-31  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* config/rs6000/predicates.md (rs6000_cbranch_operator): Accept some\n+\tunordered comparison operators when -fno-trapping-math is in effect\n+\ton the e500.\n+\t* config/rs6000/rs6000.c (rs6000_generate_compare): Remove dead code\n+\tand implement unordered comparison operators properly on the e500.\n+\n 2013-05-31  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* simplify-rtx.c (simplify_byte_swapping_operation): Use proper macro"}, {"sha": "7fdf7d1b6cb98d83a67400cdf63ccf3e88877544", "filename": "gcc/config/rs6000/predicates.md", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4172215d0af78c458ba0e287e1fcf2ac80d5eb71/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4172215d0af78c458ba0e287e1fcf2ac80d5eb71/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fpredicates.md?ref=4172215d0af78c458ba0e287e1fcf2ac80d5eb71", "patch": "@@ -1121,9 +1121,16 @@\n \t\t\t\t\t\t   GET_MODE (XEXP (op, 0))),\n \t\t\t  1\"))))\n \n+;; Return 1 if OP is a valid comparison operator for \"cbranch\" instructions.\n+;; If we're assuming that FP operations cannot generate user-visible traps,\n+;; then on e500 we can use the ordered-signaling instructions to implement\n+;; the unordered-quiet FP comparison predicates modulo a reversal.\n (define_predicate \"rs6000_cbranch_operator\"\n   (if_then_else (match_test \"TARGET_HARD_FLOAT && !TARGET_FPRS\")\n-\t\t(match_operand 0 \"ordered_comparison_operator\")\n+\t\t(if_then_else (match_test \"flag_trapping_math\")\n+\t\t\t      (match_operand 0 \"ordered_comparison_operator\")\n+\t\t\t      (ior (match_operand 0 \"ordered_comparison_operator\")\n+\t\t\t\t   (match_code (\"unlt,unle,ungt,unge\"))))\n \t\t(match_operand 0 \"comparison_operator\")))\n \n ;; Return 1 if OP is a comparison operation that is valid for an SCC insn --"}, {"sha": "9c4b7f04c35d7cf976e0b273ec2023cf65bcba0c", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 36, "deletions": 22, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4172215d0af78c458ba0e287e1fcf2ac80d5eb71/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4172215d0af78c458ba0e287e1fcf2ac80d5eb71/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=4172215d0af78c458ba0e287e1fcf2ac80d5eb71", "patch": "@@ -16087,16 +16087,41 @@ rs6000_generate_compare (rtx cmp, enum machine_mode mode)\n     {\n       rtx cmp, or_result, compare_result2;\n       enum machine_mode op_mode = GET_MODE (op0);\n+      bool reverse_p;\n \n       if (op_mode == VOIDmode)\n \top_mode = GET_MODE (op1);\n \n+      /* First reverse the condition codes that aren't directly supported.  */\n+      switch (code)\n+\t{\n+\t  case NE:\n+\t  case UNLT:\n+\t  case UNLE:\n+\t  case UNGT:\n+\t  case UNGE:\n+\t    code = reverse_condition_maybe_unordered (code);\n+\t    reverse_p = true;\n+\t    break;\n+\n+\t  case EQ:\n+\t  case LT:\n+\t  case LE:\n+\t  case GT:\n+\t  case GE:\n+\t    reverse_p = false;\n+\t    break;\n+\n+\t  default:\n+\t    gcc_unreachable ();\n+\t}\n+\n       /* The E500 FP compare instructions toggle the GT bit (CR bit 1) only.\n \t This explains the following mess.  */\n \n       switch (code)\n \t{\n-\tcase EQ: case UNEQ: case NE: case LTGT:\n+\tcase EQ:\n \t  switch (op_mode)\n \t    {\n \t    case SFmode:\n@@ -16122,7 +16147,8 @@ rs6000_generate_compare (rtx cmp, enum machine_mode mode)\n \t    }\n \t  break;\n \n-\tcase GT: case GTU: case UNGT: case UNGE: case GE: case GEU:\n+\tcase GT:\n+\tcase GE:\n \t  switch (op_mode)\n \t    {\n \t    case SFmode:\n@@ -16148,7 +16174,8 @@ rs6000_generate_compare (rtx cmp, enum machine_mode mode)\n \t    }\n \t  break;\n \n-\tcase LT: case LTU: case UNLT: case UNLE: case LE: case LEU:\n+\tcase LT: \n+\tcase LE:\n \t  switch (op_mode)\n \t    {\n \t    case SFmode:\n@@ -16173,24 +16200,16 @@ rs6000_generate_compare (rtx cmp, enum machine_mode mode)\n \t      gcc_unreachable ();\n \t    }\n \t  break;\n+\n         default:\n           gcc_unreachable ();\n \t}\n \n       /* Synthesize LE and GE from LT/GT || EQ.  */\n-      if (code == LE || code == GE || code == LEU || code == GEU)\n+      if (code == LE || code == GE)\n \t{\n \t  emit_insn (cmp);\n \n-\t  switch (code)\n-\t    {\n-\t    case LE: code = LT; break;\n-\t    case GE: code = GT; break;\n-\t    case LEU: code = LT; break;\n-\t    case GEU: code = GT; break;\n-\t    default: gcc_unreachable ();\n-\t    }\n-\n \t  compare_result2 = gen_reg_rtx (CCFPmode);\n \n \t  /* Do the EQ.  */\n@@ -16217,23 +16236,18 @@ rs6000_generate_compare (rtx cmp, enum machine_mode mode)\n \t    default:\n \t      gcc_unreachable ();\n \t    }\n+\n \t  emit_insn (cmp);\n \n \t  /* OR them together.  */\n \t  or_result = gen_reg_rtx (CCFPmode);\n \t  cmp = gen_e500_cr_ior_compare (or_result, compare_result,\n-\t\t\t\t\t   compare_result2);\n+\t\t\t\t\t compare_result2);\n \t  compare_result = or_result;\n-\t  code = EQ;\n-\t}\n-      else\n-\t{\n-\t  if (code == NE || code == LTGT)\n-\t    code = NE;\n-\t  else\n-\t    code = EQ;\n \t}\n \n+      code = reverse_p ? NE : EQ;\n+\n       emit_insn (cmp);\n     }\n   else"}, {"sha": "fb6c69430cf2abfc329c6ca65f331eff0c38463b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4172215d0af78c458ba0e287e1fcf2ac80d5eb71/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4172215d0af78c458ba0e287e1fcf2ac80d5eb71/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4172215d0af78c458ba0e287e1fcf2ac80d5eb71", "patch": "@@ -1,3 +1,10 @@\n+2013-05-31  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc.target/powerpc/e500-ord-1.c: New test.\n+\t* gcc.target/powerpc/e500-ord-2.c: Likewise.\n+\t* gcc.target/powerpc/e500-unord-1.c: Likewise.\n+\t* gcc.target/powerpc/e500-unord-2.c: Likewise.\n+\n 2013-05-31  Marcus Shawcroft  <marcus.shawcroft@arm.com>\n \n \t* g++.dg/torture/pr54684.C: Add -fno-short-enums."}, {"sha": "c4f2769901c793f49cfa51b223735ebff868325c", "filename": "gcc/testsuite/gcc.target/powerpc/e500-ord-1.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4172215d0af78c458ba0e287e1fcf2ac80d5eb71/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fe500-ord-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4172215d0af78c458ba0e287e1fcf2ac80d5eb71/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fe500-ord-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fe500-ord-1.c?ref=4172215d0af78c458ba0e287e1fcf2ac80d5eb71", "patch": "@@ -0,0 +1,29 @@\n+/* { dg-do compile { target powerpc*-*-eabi* } } */\n+/* { dg-options \"-O -ftrapping-math -fdump-rtl-final\" } */\n+\n+int isgreater (float f1, float f2)\n+{\n+  int r = (f1 > f2);\n+  return !r ?  -1 : 1;\n+}\n+\n+int isgreaterequal (float f1, float f2)\n+{\n+  int r = (f1 >= f2);\n+  return !r ?  -1 : 1;\n+}\n+\n+int isless (float f1, float f2)\n+{\n+  int r = (f1 < f2);\n+  return !r ?  -1 : 1;\n+}\n+\n+int islessequal (float f1, float f2)\n+{\n+  int r = (f1 <= f2);\n+  return !r ?  -1 : 1;\n+}\n+\n+/* { dg-final { scan-rtl-dump-not \"__unordsf2\" \"final\" } } */\n+/* { dg-final { cleanup-rtl-dump \"final\" } } */"}, {"sha": "a6b5c297370327978d07d462b57928c3a19a4c28", "filename": "gcc/testsuite/gcc.target/powerpc/e500-ord-2.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4172215d0af78c458ba0e287e1fcf2ac80d5eb71/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fe500-ord-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4172215d0af78c458ba0e287e1fcf2ac80d5eb71/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fe500-ord-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fe500-ord-2.c?ref=4172215d0af78c458ba0e287e1fcf2ac80d5eb71", "patch": "@@ -0,0 +1,29 @@\n+/* { dg-do compile { target powerpc*-*-eabi* } } */\n+/* { dg-options \"-O -fno-trapping-math -fdump-rtl-final\" } */\n+\n+int isgreater (float f1, float f2)\n+{\n+  int r = (f1 > f2);\n+  return !r ?  -1 : 1;\n+}\n+\n+int isgreaterequal (float f1, float f2)\n+{\n+  int r = (f1 >= f2);\n+  return !r ?  -1 : 1;\n+}\n+\n+int isless (float f1, float f2)\n+{\n+  int r = (f1 < f2);\n+  return !r ?  -1 : 1;\n+}\n+\n+int islessequal (float f1, float f2)\n+{\n+  int r = (f1 <= f2);\n+  return !r ?  -1 : 1;\n+}\n+\n+/* { dg-final { scan-rtl-dump-not \"__unordsf2\" \"final\" } } */\n+/* { dg-final { cleanup-rtl-dump \"final\" } } */"}, {"sha": "0cd75d8d30d472b652a30c8bc8e050e99adecda8", "filename": "gcc/testsuite/gcc.target/powerpc/e500-unord-1.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4172215d0af78c458ba0e287e1fcf2ac80d5eb71/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fe500-unord-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4172215d0af78c458ba0e287e1fcf2ac80d5eb71/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fe500-unord-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fe500-unord-1.c?ref=4172215d0af78c458ba0e287e1fcf2ac80d5eb71", "patch": "@@ -0,0 +1,29 @@\n+/* { dg-do compile { target powerpc*-*-eabi* } } */\n+/* { dg-options \"-O -ftrapping-math -fdump-rtl-final\" } */\n+\n+int isgreater (float f1, float f2)\n+{\n+  int r = __builtin_isgreater (f1, f2);\n+  return !r ?  -1 : 1;\n+}\n+\n+int isgreaterequal (float f1, float f2)\n+{\n+  int r = __builtin_isgreaterequal (f1, f2);\n+  return !r ?  -1 : 1;\n+}\n+\n+int isless (float f1, float f2)\n+{\n+  int r = __builtin_isless (f1, f2);\n+  return !r ?  -1 : 1;\n+}\n+\n+int islessequal (float f1, float f2)\n+{\n+  int r = __builtin_islessequal (f1, f2);\n+  return !r ?  -1 : 1;\n+}\n+\n+/* { dg-final { scan-rtl-dump-times \"__unordsf2\" 4 \"final\" } } */\n+/* { dg-final { cleanup-rtl-dump \"final\" } } */"}, {"sha": "51b1316f271dd213505bedc608c2ff67dc4f85fa", "filename": "gcc/testsuite/gcc.target/powerpc/e500-unord-2.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4172215d0af78c458ba0e287e1fcf2ac80d5eb71/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fe500-unord-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4172215d0af78c458ba0e287e1fcf2ac80d5eb71/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fe500-unord-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fe500-unord-2.c?ref=4172215d0af78c458ba0e287e1fcf2ac80d5eb71", "patch": "@@ -0,0 +1,29 @@\n+/* { dg-do compile { target powerpc*-*-eabi* } } */\n+/* { dg-options \"-O -fno-trapping-math -fdump-rtl-final\" } */\n+\n+int isgreater (float f1, float f2)\n+{\n+  int r = __builtin_isgreater (f1, f2);\n+  return !r ?  -1 : 1;\n+}\n+\n+int isgreaterequal (float f1, float f2)\n+{\n+  int r = __builtin_isgreaterequal (f1, f2);\n+  return !r ?  -1 : 1;\n+}\n+\n+int isless (float f1, float f2)\n+{\n+  int r = __builtin_isless (f1, f2);\n+  return !r ?  -1 : 1;\n+}\n+\n+int islessequal (float f1, float f2)\n+{\n+  int r = __builtin_islessequal (f1, f2);\n+  return !r ?  -1 : 1;\n+}\n+\n+/* { dg-final { scan-rtl-dump-not \"__unordsf2\" \"final\" } } */\n+/* { dg-final { cleanup-rtl-dump \"final\" } } */"}]}