{"sha": "6326a5f515dfa3922d0fdfc20baf005b40503b61", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjMyNmE1ZjUxNWRmYTM5MjJkMGZkZmMyMGJhZjAwNWI0MDUwM2I2MQ==", "commit": {"author": {"name": "Bin Cheng", "email": "bin.cheng@arm.com", "date": "2014-12-18T02:53:42Z"}, "committer": {"name": "Bin Cheng", "email": "amker@gcc.gnu.org", "date": "2014-12-18T02:53:42Z"}, "message": "re PR middle-end/62178 ([AArch64] Performance regression on matrix matrix multiply due to r211211)\n\n\n\tPR tree-optimization/62178\n\t* tree-ssa-loop-ivopts.c (cheaper_cost_with_cand): New function.\n\t(iv_ca_replace): New function.\n\t(try_improve_iv_set): New parameter try_replace_p.\n\tBreak local optimal fixed-point by calling iv_ca_replace.\n\t(find_optimal_iv_set_1): Pass new argument to try_improve_iv_set.\n\n\tgcc/testsuite/ChangeLog\n\tPR tree-optimization/62178\n\t* gcc.target/aarch64/pr62178.c: New test.\n\nFrom-SVN: r218855", "tree": {"sha": "d21aa5196aa4af2765aa35beba33169adc7adccb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d21aa5196aa4af2765aa35beba33169adc7adccb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6326a5f515dfa3922d0fdfc20baf005b40503b61", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6326a5f515dfa3922d0fdfc20baf005b40503b61", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6326a5f515dfa3922d0fdfc20baf005b40503b61", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6326a5f515dfa3922d0fdfc20baf005b40503b61/comments", "author": null, "committer": null, "parents": [{"sha": "29ca9bfb905a864546e5b22ca3f5b3ebd5cbb0a8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29ca9bfb905a864546e5b22ca3f5b3ebd5cbb0a8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/29ca9bfb905a864546e5b22ca3f5b3ebd5cbb0a8"}], "stats": {"total": 158, "additions": 154, "deletions": 4}, "files": [{"sha": "3757021fff54da052faaf5feca56c0f2257436aa", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6326a5f515dfa3922d0fdfc20baf005b40503b61/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6326a5f515dfa3922d0fdfc20baf005b40503b61/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6326a5f515dfa3922d0fdfc20baf005b40503b61", "patch": "@@ -1,3 +1,12 @@\n+2014-12-18  Bin Cheng  <bin.cheng@arm.com>\n+\n+\tPR tree-optimization/62178\n+\t* tree-ssa-loop-ivopts.c (cheaper_cost_with_cand): New function.\n+\t(iv_ca_replace): New function.\n+\t(try_improve_iv_set): New parameter try_replace_p.\n+\tBreak local optimal fixed-point by calling iv_ca_replace.\n+\t(find_optimal_iv_set_1): Pass new argument to try_improve_iv_set.\n+\n 2014-12-17  Dehao Chen  <dehao@google.com>\n \n \t* auto-profile.c (afdo_annotate_cfg): Invoke update_ssa in the right"}, {"sha": "3f33ac66cf5f2d0efb573e86373c83670e537154", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6326a5f515dfa3922d0fdfc20baf005b40503b61/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6326a5f515dfa3922d0fdfc20baf005b40503b61/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=6326a5f515dfa3922d0fdfc20baf005b40503b61", "patch": "@@ -1,3 +1,8 @@\n+2014-12-18  Bin Cheng  <bin.cheng@arm.com>\n+\n+\tPR tree-optimization/62178\n+\t* gcc.target/aarch64/pr62178.c: New test.\n+\n 2014-12-17  Janus Weil  <janus@gcc.gnu.org>\n \n \tPR fortran/64173"}, {"sha": "b80ce68656076864bb71c76949cef5d7b530021a", "filename": "gcc/testsuite/gcc.target/aarch64/pr62178.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6326a5f515dfa3922d0fdfc20baf005b40503b61/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fpr62178.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6326a5f515dfa3922d0fdfc20baf005b40503b61/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fpr62178.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fpr62178.c?ref=6326a5f515dfa3922d0fdfc20baf005b40503b61", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3\" } */\n+\n+int a[30 +1][30 +1], b[30 +1][30 +1], r[30 +1][30 +1];\n+\n+void foo (void) {\n+  int i, j, k;\n+\n+  for ( i = 1; i <= 30; i++ )\n+    for ( j = 1; j <= 30; j++ ) {\n+      r[i][j] = 0;\n+      for(k = 1; k <= 30; k++ )\n+        r[i][j] += a[i][k]*b[k][j];\n+    }\n+}\n+\n+/* { dg-final { scan-assembler \"ld1r\\\\t\\{v\\[0-9\\]+\\.\"} } */"}, {"sha": "fe5d77abb54af5d54ac4eadb2343f82dac422374", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 123, "deletions": 4, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6326a5f515dfa3922d0fdfc20baf005b40503b61/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6326a5f515dfa3922d0fdfc20baf005b40503b61/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=6326a5f515dfa3922d0fdfc20baf005b40503b61", "patch": "@@ -5862,6 +5862,108 @@ iv_ca_prune (struct ivopts_data *data, struct iv_ca *ivs,\n   return best_cost;\n }\n \n+/* Check if CAND_IDX is a candidate other than OLD_CAND and has\n+   cheaper local cost for USE than BEST_CP.  Return pointer to\n+   the corresponding cost_pair, otherwise just return BEST_CP.  */\n+\n+static struct cost_pair*\n+cheaper_cost_with_cand (struct ivopts_data *data, struct iv_use *use,\n+\t\t\tunsigned int cand_idx, struct iv_cand *old_cand,\n+\t\t\tstruct cost_pair *best_cp)\n+{\n+  struct iv_cand *cand;\n+  struct cost_pair *cp;\n+\n+  gcc_assert (old_cand != NULL && best_cp != NULL);\n+  if (cand_idx == old_cand->id)\n+    return best_cp;\n+\n+  cand = iv_cand (data, cand_idx);\n+  cp = get_use_iv_cost (data, use, cand);\n+  if (cp != NULL && cheaper_cost_pair (cp, best_cp))\n+    return cp;\n+\n+  return best_cp;\n+}\n+\n+/* Try breaking local optimal fixed-point for IVS by replacing candidates\n+   which are used by more than one iv uses.  For each of those candidates,\n+   this function tries to represent iv uses under that candidate using\n+   other ones with lower local cost, then tries to prune the new set.\n+   If the new set has lower cost, It returns the new cost after recording\n+   candidate replacement in list DELTA.  */\n+\n+static comp_cost\n+iv_ca_replace (struct ivopts_data *data, struct iv_ca *ivs,\n+\t       struct iv_ca_delta **delta)\n+{\n+  bitmap_iterator bi, bj;\n+  unsigned int i, j, k;\n+  struct iv_use *use;\n+  struct iv_cand *cand;\n+  comp_cost orig_cost, acost;\n+  struct iv_ca_delta *act_delta, *tmp_delta;\n+  struct cost_pair *old_cp, *best_cp = NULL;\n+\n+  *delta = NULL;\n+  orig_cost = iv_ca_cost (ivs);\n+\n+  EXECUTE_IF_SET_IN_BITMAP (ivs->cands, 0, i, bi)\n+    {\n+      if (ivs->n_cand_uses[i] == 1\n+\t  || ivs->n_cand_uses[i] > ALWAYS_PRUNE_CAND_SET_BOUND)\n+\tcontinue;\n+\n+      cand = iv_cand (data, i);\n+  \n+      act_delta = NULL;\n+      /*  Represent uses under current candidate using other ones with\n+\t  lower local cost.  */\n+      for (j = 0; j < ivs->upto; j++)\n+\t{\n+\t  use = iv_use (data, j);\n+\t  old_cp = iv_ca_cand_for_use (ivs, use);\n+\n+\t  if (old_cp->cand != cand)\n+\t    continue;\n+\n+\t  best_cp = old_cp;\n+\t  if (data->consider_all_candidates)\n+\t    for (k = 0; k < n_iv_cands (data); k++)\n+\t      best_cp = cheaper_cost_with_cand (data, use, k,\n+\t\t\t\t\t\told_cp->cand, best_cp);\n+\t  else\n+\t    EXECUTE_IF_SET_IN_BITMAP (use->related_cands, 0, k, bj)\n+\t      best_cp = cheaper_cost_with_cand (data, use, k,\n+\t\t\t\t\t\told_cp->cand, best_cp);\n+\n+\t  if (best_cp == old_cp)\n+\t    continue;\n+\n+\t  act_delta = iv_ca_delta_add (use, old_cp, best_cp, act_delta);\n+\t}\n+      /* No need for further prune.  */\n+      if (!act_delta)\n+\tcontinue;\n+\n+      /* Prune the new candidate set.  */\n+      iv_ca_delta_commit (data, ivs, act_delta, true);\n+      acost = iv_ca_prune (data, ivs, NULL, &tmp_delta);\n+      iv_ca_delta_commit (data, ivs, act_delta, false);\n+      act_delta = iv_ca_delta_join (act_delta, tmp_delta);\n+\n+      if (compare_costs (acost, orig_cost) < 0)\n+\t{\n+\t  *delta = act_delta;\n+\t  return acost;\n+\t}\n+      else\n+\tiv_ca_delta_free (&act_delta);\n+    }\n+\n+  return orig_cost;\n+}\n+\n /* Tries to extend the sets IVS in the best possible way in order\n    to express the USE.  If ORIGINALP is true, prefer candidates from\n    the original set of IVs, otherwise favor important candidates not\n@@ -5995,10 +6097,13 @@ get_initial_solution (struct ivopts_data *data, bool originalp)\n   return ivs;\n }\n \n-/* Tries to improve set of induction variables IVS.  */\n+/* Tries to improve set of induction variables IVS.  TRY_REPLACE_P\n+   points to a bool variable, this function tries to break local\n+   optimal fixed-point by replacing candidates in IVS if it's true.  */\n \n static bool\n-try_improve_iv_set (struct ivopts_data *data, struct iv_ca *ivs)\n+try_improve_iv_set (struct ivopts_data *data,\n+\t\t    struct iv_ca *ivs, bool *try_replace_p)\n {\n   unsigned i, n_ivs;\n   comp_cost acost, best_cost = iv_ca_cost (ivs);\n@@ -6042,7 +6147,20 @@ try_improve_iv_set (struct ivopts_data *data, struct iv_ca *ivs)\n       /* Try removing the candidates from the set instead.  */\n       best_cost = iv_ca_prune (data, ivs, NULL, &best_delta);\n \n-      /* Nothing more we can do.  */\n+      if (!best_delta && *try_replace_p)\n+\t{\n+\t  *try_replace_p = false;\n+\t  /* So far candidate selecting algorithm tends to choose fewer IVs\n+\t     so that it can handle cases in which loops have many variables\n+\t     but the best choice is often to use only one general biv.  One\n+\t     weakness is it can't handle opposite cases, in which different\n+\t     candidates should be chosen with respect to each use.  To solve\n+\t     the problem, we replace candidates in a manner described by the\n+\t     comments of iv_ca_replace, thus give general algorithm a chance\n+\t     to break local optimal fixed-point in these cases.  */\n+\t  best_cost = iv_ca_replace (data, ivs, &best_delta);\n+\t}\n+\n       if (!best_delta)\n \treturn false;\n     }\n@@ -6061,6 +6179,7 @@ static struct iv_ca *\n find_optimal_iv_set_1 (struct ivopts_data *data, bool originalp)\n {\n   struct iv_ca *set;\n+  bool try_replace_p = true;\n \n   /* Get the initial solution.  */\n   set = get_initial_solution (data, originalp);\n@@ -6077,7 +6196,7 @@ find_optimal_iv_set_1 (struct ivopts_data *data, bool originalp)\n       iv_ca_dump (data, dump_file, set);\n     }\n \n-  while (try_improve_iv_set (data, set))\n+  while (try_improve_iv_set (data, set, &try_replace_p))\n     {\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \t{"}]}