{"sha": "ab8efbd82444a0246d024e7b1709820ba289b2a8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWI4ZWZiZDgyNDQ0YTAyNDZkMDI0ZTdiMTcwOTgyMGJhMjg5YjJhOA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2005-04-13T04:59:33Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2005-04-13T04:59:33Z"}, "message": "i386.c (ix86_prepare_sse_fp_compare_args): Split ...\n\n        * config/i386/i386.c (ix86_prepare_sse_fp_compare_args): Split ...\n        (ix86_expand_sse_fp_minmax): ... from ...\n        (ix86_expand_fp_movcc): ... here.\n        (ix86_expand_sse_movcc): Rewrite from ix86_split_sse_movcc.\n        * config/i386/i386-protos.h: Update.\n        * config/i386/i386.md (UNSPEC_IEEE_MIN, UNSPEC_IEEE_MAX): New.\n        (sse_setccsf, sse_setccdf): Allow before reload.\n        (movsfcc_1_sse_min, movsfcc_1_sse_max, movsfcc_1_sse): Remove.\n        (movdfcc_1_sse_min, movdfcc_1_sse_max, movdfcc_1_sse): Remove.\n        (ieee_sminsf3, ieee_smaxsf3, ieee_smindf3, ieee_smaxdf3): New.\n        * config/i386/sse.md (andsf3, nandsf3, iorsf3, xorsf3): New.\n        (anddf3, nanddf3, iordf3, xordf3): New.\n\nFrom-SVN: r98068", "tree": {"sha": "b3ddeaca5e526319efacc6ddfe069dc8c7b2ca67", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b3ddeaca5e526319efacc6ddfe069dc8c7b2ca67"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ab8efbd82444a0246d024e7b1709820ba289b2a8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab8efbd82444a0246d024e7b1709820ba289b2a8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ab8efbd82444a0246d024e7b1709820ba289b2a8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab8efbd82444a0246d024e7b1709820ba289b2a8/comments", "author": null, "committer": null, "parents": [{"sha": "0b90f180b7676fdf5cd89938a0f13eaeaedecf75", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b90f180b7676fdf5cd89938a0f13eaeaedecf75", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0b90f180b7676fdf5cd89938a0f13eaeaedecf75"}], "stats": {"total": 599, "additions": 336, "deletions": 263}, "files": [{"sha": "523237ac94fdafdbdf46352946f2139eec9cb8a5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab8efbd82444a0246d024e7b1709820ba289b2a8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab8efbd82444a0246d024e7b1709820ba289b2a8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ab8efbd82444a0246d024e7b1709820ba289b2a8", "patch": "@@ -1,3 +1,18 @@\n+2005-04-12  Richard Henderson  <rth@redhat.com>\n+\n+\t* config/i386/i386.c (ix86_prepare_sse_fp_compare_args): Split ...\n+\t(ix86_expand_sse_fp_minmax): ... from ... \n+\t(ix86_expand_fp_movcc): ... here.\n+\t(ix86_expand_sse_movcc): Rewrite from ix86_split_sse_movcc.\n+\t* config/i386/i386-protos.h: Update.\n+\t* config/i386/i386.md (UNSPEC_IEEE_MIN, UNSPEC_IEEE_MAX): New.\n+\t(sse_setccsf, sse_setccdf): Allow before reload.\n+\t(movsfcc_1_sse_min, movsfcc_1_sse_max, movsfcc_1_sse): Remove.\n+\t(movdfcc_1_sse_min, movdfcc_1_sse_max, movdfcc_1_sse): Remove.\n+\t(ieee_sminsf3, ieee_smaxsf3, ieee_smindf3, ieee_smaxdf3): New.\n+\t* config/i386/sse.md (andsf3, nandsf3, iorsf3, xorsf3): New.\n+\t(anddf3, nanddf3, iordf3, xordf3): New.\n+\n 2005-04-12  Jeff Law  <law@redhat.com>\n \n \t* Makefile.in (OBJS-common): Add tree-ssa-uncprop.o."}, {"sha": "41a70a8e3a299c1b5700bd492fa22738ecadb658", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab8efbd82444a0246d024e7b1709820ba289b2a8/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab8efbd82444a0246d024e7b1709820ba289b2a8/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=ab8efbd82444a0246d024e7b1709820ba289b2a8", "patch": "@@ -150,7 +150,6 @@ extern void ix86_expand_branch (enum rtx_code, rtx);\n extern int ix86_expand_setcc (enum rtx_code, rtx);\n extern int ix86_expand_int_movcc (rtx[]);\n extern int ix86_expand_fp_movcc (rtx[]);\n-extern void ix86_split_sse_movcc (rtx[]);\n extern int ix86_expand_int_addcc (rtx[]);\n extern void ix86_expand_call (rtx, rtx, rtx, rtx, rtx, int);\n extern void x86_initialize_trampoline (rtx, rtx, rtx);"}, {"sha": "e82cefc76eca738b16495eba7632979b1ad2428b", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 187, "deletions": 165, "changes": 352, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab8efbd82444a0246d024e7b1709820ba289b2a8/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab8efbd82444a0246d024e7b1709820ba289b2a8/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=ab8efbd82444a0246d024e7b1709820ba289b2a8", "patch": "@@ -10025,6 +10025,180 @@ ix86_expand_int_movcc (rtx operands[])\n   return 1; /* DONE */\n }\n \n+/* Swap, force into registers, or otherwise massage the two operands\n+   to an sse comparison with a mask result.  Thus we differ a bit from\n+   ix86_prepare_fp_compare_args which expects to produce a flags result.\n+\n+   The DEST operand exists to help determine whether to commute commutative\n+   operators.  The POP0/POP1 operands are updated in place.  The new\n+   comparison code is returned, or UNKNOWN if not implementable.  */\n+\n+static enum rtx_code\n+ix86_prepare_sse_fp_compare_args (rtx dest, enum rtx_code code,\n+\t\t\t\t  rtx *pop0, rtx *pop1)\n+{\n+  rtx tmp;\n+\n+  switch (code)\n+    {\n+    case LTGT:\n+    case UNEQ:\n+      /* We have no LTGT as an operator.  We could implement it with\n+\t NE & ORDERED, but this requires an extra temporary.  It's\n+\t not clear that it's worth it.  */\n+      return UNKNOWN;\n+\n+    case LT:\n+    case LE:\n+    case UNGT:\n+    case UNGE:\n+      /* These are supported directly.  */\n+      break;\n+\n+    case EQ:\n+    case NE:\n+    case UNORDERED:\n+    case ORDERED:\n+      /* For commutative operators, try to canonicalize the destination\n+\t operand to be first in the comparison - this helps reload to\n+\t avoid extra moves.  */\n+      if (!dest || !rtx_equal_p (dest, *pop1))\n+\tbreak;\n+      /* FALLTHRU */\n+\n+    case GE:\n+    case GT:\n+    case UNLE:\n+    case UNLT:\n+      /* These are not supported directly.  Swap the comparison operands\n+\t to transform into something that is supported.  */\n+      tmp = *pop0;\n+      *pop0 = *pop1;\n+      *pop1 = tmp;\n+      code = swap_condition (code);\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  return code;\n+}\n+\n+/* Detect conditional moves that exactly match min/max operational\n+   semantics.  Note that this is IEEE safe, as long as we don't\n+   interchange the operands.\n+\n+   Returns FALSE if this conditional move doesn't match a MIN/MAX,\n+   and TRUE if the operation is successful and instructions are emitted.  */\n+\n+static bool\n+ix86_expand_sse_fp_minmax (rtx dest, enum rtx_code code, rtx cmp_op0,\n+\t\t\t   rtx cmp_op1, rtx if_true, rtx if_false)\n+{\n+  enum machine_mode mode;\n+  bool is_min;\n+  rtx tmp;\n+\n+  if (code == LT)\n+    ;\n+  else if (code == UNGE)\n+    {\n+      tmp = if_true;\n+      if_true = if_false;\n+      if_false = tmp;\n+    }\n+  else\n+    return false;\n+\n+  if (rtx_equal_p (cmp_op0, if_true) && rtx_equal_p (cmp_op1, if_false))\n+    is_min = true;\n+  else if (rtx_equal_p (cmp_op1, if_true) && rtx_equal_p (cmp_op0, if_false))\n+    is_min = false;\n+  else\n+    return false;\n+\n+  mode = GET_MODE (dest);\n+\n+  /* We want to check HONOR_NANS and HONOR_SIGNED_ZEROS here,\n+     but MODE may be a vector mode and thus not appropriate.  */\n+  if (!flag_finite_math_only || !flag_unsafe_math_optimizations)\n+    {\n+      int u = is_min ? UNSPEC_IEEE_MIN : UNSPEC_IEEE_MAX;\n+      rtvec v;\n+\n+      if_true = force_reg (mode, if_true);\n+      v = gen_rtvec (2, if_true, if_false);\n+      tmp = gen_rtx_UNSPEC (mode, v, u);\n+    }\n+  else\n+    {\n+      code = is_min ? SMIN : SMAX;\n+      tmp = gen_rtx_fmt_ee (code, mode, if_true, if_false);\n+    }\n+\n+  emit_insn (gen_rtx_SET (VOIDmode, dest, tmp));\n+  return true;\n+}\n+\n+static void\n+ix86_expand_sse_movcc (rtx dest, enum rtx_code code, rtx cmp_op0, rtx cmp_op1,\n+\t\t       rtx op_true, rtx op_false)\n+{\n+  enum machine_mode mode = GET_MODE (dest);\n+  rtx t1, t2, t3, x;\n+\n+  cmp_op0 = force_reg (mode, cmp_op0);\n+  if (!nonimmediate_operand (cmp_op1, mode))\n+    cmp_op1 = force_reg (mode, cmp_op1);\n+\n+  if (optimize\n+      || reg_overlap_mentioned_p (dest, op_true)\n+      || reg_overlap_mentioned_p (dest, op_false))\n+    t1 = gen_reg_rtx (mode);\n+  else\n+    t1 = dest;\n+\n+  x = gen_rtx_fmt_ee (code, mode, cmp_op0, cmp_op1);\n+  gcc_assert (sse_comparison_operator (x, VOIDmode));\n+  emit_insn (gen_rtx_SET (VOIDmode, t1, x));\n+\n+  if (op_false == CONST0_RTX (mode))\n+    {\n+      op_true = force_reg (mode, op_true);\n+      x = gen_rtx_AND (mode, t1, op_true);\n+      emit_insn (gen_rtx_SET (VOIDmode, dest, x));\n+    }\n+  else if (op_true == CONST0_RTX (mode))\n+    {\n+      op_false = force_reg (mode, op_false);\n+      x = gen_rtx_NOT (mode, t1);\n+      x = gen_rtx_AND (mode, x, op_false);\n+      emit_insn (gen_rtx_SET (VOIDmode, dest, x));\n+    }\n+  else\n+    {\n+      op_true = force_reg (mode, op_true);\n+      op_false = force_reg (mode, op_false);\n+\n+      t2 = gen_reg_rtx (mode);\n+      if (optimize)\n+\tt3 = gen_reg_rtx (mode);\n+      else\n+\tt3 = dest;\n+\n+      x = gen_rtx_AND (mode, op_true, t1);\n+      emit_insn (gen_rtx_SET (VOIDmode, t2, x));\n+\n+      x = gen_rtx_NOT (mode, t1);\n+      x = gen_rtx_AND (mode, x, op_false);\n+      emit_insn (gen_rtx_SET (VOIDmode, t3, x));\n+\n+      x = gen_rtx_IOR (mode, t3, t2);\n+      emit_insn (gen_rtx_SET (VOIDmode, dest, x));\n+    }\n+}\n+\n int\n ix86_expand_fp_movcc (rtx operands[])\n {\n@@ -10034,88 +10208,30 @@ ix86_expand_fp_movcc (rtx operands[])\n \n   if (TARGET_SSE_MATH && SSE_FLOAT_MODE_P (mode))\n     {\n-      rtx cmp_op0, cmp_op1, if_true, if_false;\n-      rtx clob;\n-      enum machine_mode vmode, cmode;\n-      bool is_minmax = false;\n-\n-      cmp_op0 = ix86_compare_op0;\n-      cmp_op1 = ix86_compare_op1;\n-      if_true = operands[2];\n-      if_false = operands[3];\n+      enum machine_mode cmode;\n \n       /* Since we've no cmove for sse registers, don't force bad register\n \t allocation just to gain access to it.  Deny movcc when the\n \t comparison mode doesn't match the move mode.  */\n-      cmode = GET_MODE (cmp_op0);\n+      cmode = GET_MODE (ix86_compare_op0);\n       if (cmode == VOIDmode)\n-\tcmode = GET_MODE (cmp_op1);\n+\tcmode = GET_MODE (ix86_compare_op1);\n       if (cmode != mode)\n \treturn 0;\n \n-      /* We have no LTGT as an operator.  We could implement it with\n-\t NE & ORDERED, but this requires an extra temporary.  It's\n-\t not clear that it's worth it.  */\n-      if (code == LTGT || code == UNEQ)\n+      code = ix86_prepare_sse_fp_compare_args (operands[0], code,\n+\t\t\t\t\t       &ix86_compare_op0,\n+\t\t\t\t\t       &ix86_compare_op1);\n+      if (code == UNKNOWN)\n \treturn 0;\n \n-      /* Massage condition to satisfy sse_comparison_operator.  Try\n-\t to canonicalize the destination operand to be first in the\n-\t comparison - this helps reload to avoid extra moves.  */\n-      if (!sse_comparison_operator (operands[1], VOIDmode)\n-\t  || (COMMUTATIVE_P (operands[1])\n-\t      && rtx_equal_p (operands[0], cmp_op1)))\n-\t{\n-\t  tmp = cmp_op0;\n-\t  cmp_op0 = cmp_op1;\n-\t  cmp_op1 = tmp;\n-\t  code = swap_condition (code);\n-\t}\n-\n-      /* Detect conditional moves that exactly match min/max operational\n-\t semantics.  Note that this is IEEE safe, as long as we don't\n-\t interchange the operands.  Which is why we keep this in the form\n-\t if an IF_THEN_ELSE instead of reducing to SMIN/SMAX.  */\n-      if ((code == LT || code == UNGE) && REG_P (cmp_op0) && REG_P (cmp_op1))\n-\t{\n-\t  if (((cmp_op0 == if_true && cmp_op1 == if_false)\n-\t      || (cmp_op0 == if_false && cmp_op1 == if_true)))\n-\t    {\n-\t      is_minmax = true;\n-\t      if (code == UNGE)\n-\t\t{\n-\t\t  code = LT;\n-\t\t  tmp = if_true;\n-\t\t  if_true = if_false;\n-\t\t  if_false = tmp;\n-\t\t}\n-\t    }\n-\t}\n-\n-      if (mode == SFmode)\n-\tvmode = V4SFmode;\n-      else if (mode == DFmode)\n-\tvmode = V2DFmode;\n-      else\n-\tgcc_unreachable ();\n-\n-      cmp_op0 = force_reg (mode, cmp_op0);\n-      if (!nonimmediate_operand (cmp_op1, mode))\n-\tcmp_op1 = force_reg (mode, cmp_op1);\n-\n-      tmp = gen_rtx_fmt_ee (code, mode, cmp_op0, cmp_op1);\n-      gcc_assert (sse_comparison_operator (tmp, VOIDmode));\n-\n-      tmp = gen_rtx_IF_THEN_ELSE (mode, tmp, if_true, if_false);\n-      tmp = gen_rtx_SET (VOIDmode, operands[0], tmp);\n-\n-      if (!is_minmax)\n-\t{\n-\t  clob = gen_rtx_CLOBBER (VOIDmode, gen_rtx_SCRATCH (vmode));\n-\t  tmp = gen_rtx_PARALLEL (VOIDmode, gen_rtvec (2, tmp, clob));\n-\t}\n+      if (ix86_expand_sse_fp_minmax (operands[0], code, ix86_compare_op0,\n+\t\t\t\t     ix86_compare_op1, operands[2],\n+\t\t\t\t     operands[3]))\n+\treturn 1;\n \n-      emit_insn (tmp);\n+      ix86_expand_sse_movcc (operands[0], code, ix86_compare_op0,\n+\t\t\t     ix86_compare_op1, operands[2], operands[3]);\n       return 1;\n     }\n \n@@ -10166,100 +10282,6 @@ ix86_expand_fp_movcc (rtx operands[])\n   return 1;\n }\n \n-void\n-ix86_split_sse_movcc (rtx operands[])\n-{\n-  rtx dest, scratch, cmp, op_true, op_false, x;\n-  enum machine_mode mode, vmode;\n-\n-  /* Note that the operator CMP has been set up with matching constraints\n-     such that dest is valid for the comparison.  Unless one of the true\n-     or false operands are zero, the true operand has already been placed\n-     in SCRATCH.  */\n-  dest = operands[0];\n-  scratch = operands[1];\n-  op_true = operands[2];\n-  op_false = operands[3];\n-  cmp = operands[4];\n-\n-  mode = GET_MODE (dest);\n-  vmode = GET_MODE (scratch);\n-\n-  /* We need to make sure that the TRUE and FALSE operands are out of the\n-     way of the destination.  Marking the destination earlyclobber doesn't\n-     work, since we want matching constraints for the actual comparison, so\n-     at some point we always wind up having to do a copy ourselves here.\n-     We very much prefer the TRUE value to be in SCRATCH.  If it turns out\n-     that FALSE overlaps DEST, then we invert the comparison so that we\n-     still only have to do one move.  */\n-  if (rtx_equal_p (op_false, dest))\n-    {\n-      enum rtx_code code;\n-\n-      if (rtx_equal_p (op_true, dest))\n-\t{\n-\t  /* ??? Really ought not happen.  It means some optimizer managed\n-\t     to prove the operands were identical, but failed to fold the\n-\t     conditional move to a straight move.  Do so here, because \n-\t     otherwise we'll generate incorrect code.  And since they're\n-\t     both already in the destination register, nothing to do.  */\n-\t  return;\n-\t}\n-\n-      x = gen_rtx_REG (mode, REGNO (scratch));\n-      emit_move_insn (x, op_false);\n-      op_false = op_true;\n-      op_true = x;\n-\n-      code = GET_CODE (cmp);\n-      code = reverse_condition_maybe_unordered (code);\n-      cmp = gen_rtx_fmt_ee (code, mode, XEXP (cmp, 0), XEXP (cmp, 1));\n-    }\n-  else if (op_true == CONST0_RTX (mode))\n-    ;\n-  else if (op_false == CONST0_RTX (mode) && !rtx_equal_p (op_true, dest))\n-    ;\n-  else\n-    {\n-      x = gen_rtx_REG (mode, REGNO (scratch));\n-      emit_move_insn (x, op_true);\n-      op_true = x;\n-    }\n-\n-  emit_insn (gen_rtx_SET (VOIDmode, dest, cmp));\n-  dest = simplify_gen_subreg (vmode, dest, mode, 0);\n-\n-  if (op_false == CONST0_RTX (mode))\n-    {\n-      op_true = simplify_gen_subreg (vmode, op_true, mode, 0);\n-      x = gen_rtx_AND (vmode, dest, op_true);\n-      emit_insn (gen_rtx_SET (VOIDmode, dest, x));\n-    }\n-  else\n-    {\n-      op_false = simplify_gen_subreg (vmode, op_false, mode, 0);\n-\n-      if (op_true == CONST0_RTX (mode))\n-\t{\n-\t  x = gen_rtx_NOT (vmode, dest);\n-\t  x = gen_rtx_AND (vmode, x, op_false);\n-\t  emit_insn (gen_rtx_SET (VOIDmode, dest, x));\n-\t}\n-      else\n-\t{\n-\t  x = gen_rtx_AND (vmode, scratch, dest);\n-\t  emit_insn (gen_rtx_SET (VOIDmode, scratch, x));\n-\n-\t  x = gen_rtx_NOT (vmode, dest);\n-\t  x = gen_rtx_AND (vmode, x, op_false);\n-\t  emit_insn (gen_rtx_SET (VOIDmode, dest, x));\n-\n-\t  x = gen_rtx_IOR (vmode, dest, scratch);\n-\t  emit_insn (gen_rtx_SET (VOIDmode, dest, x));\n-\t}\n-    }\n-}\n-\n /* Expand conditional increment or decrement using adb/sbb instructions.\n    The default case using setcc followed by the conditional move can be\n    done by generic code.  */"}, {"sha": "098e326657394af6c750262d919d71795aed5bf8", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 51, "deletions": 96, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab8efbd82444a0246d024e7b1709820ba289b2a8/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab8efbd82444a0246d024e7b1709820ba289b2a8/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=ab8efbd82444a0246d024e7b1709820ba289b2a8", "patch": "@@ -104,6 +104,8 @@\n \n    ; Generic math support\n    (UNSPEC_COPYSIGN\t\t50)\n+   (UNSPEC_IEEE_MIN\t\t51)\t; not commutative\n+   (UNSPEC_IEEE_MAX\t\t52)\t; not commutative\n \n    ; x87 Floating point\n    (UNSPEC_SIN\t\t\t60)\n@@ -12462,17 +12464,14 @@\n ;; The SSE store flag instructions saves 0 or 0xffffffff to the result.\n ;; subsequent logical operations are used to imitate conditional moves.\n ;; 0xffffffff is NaN, but not in normalized form, so we can't represent\n-;; it directly.  Further holding this value in pseudo register might bring\n-;; problem in implicit normalization in spill code.\n-;; So we don't define FLOAT_STORE_FLAG_VALUE and create these\n-;; instructions after reload by splitting the conditional move patterns.\n+;; it directly.\n \n (define_insn \"*sse_setccsf\"\n   [(set (match_operand:SF 0 \"register_operand\" \"=x\")\n \t(match_operator:SF 1 \"sse_comparison_operator\"\n \t  [(match_operand:SF 2 \"register_operand\" \"0\")\n \t   (match_operand:SF 3 \"nonimmediate_operand\" \"xm\")]))]\n-  \"TARGET_SSE && reload_completed\"\n+  \"TARGET_SSE\"\n   \"cmp%D1ss\\t{%3, %0|%0, %3}\"\n   [(set_attr \"type\" \"ssecmp\")\n    (set_attr \"mode\" \"SF\")])\n@@ -12482,7 +12481,7 @@\n \t(match_operator:DF 1 \"sse_comparison_operator\"\n \t  [(match_operand:DF 2 \"register_operand\" \"0\")\n \t   (match_operand:DF 3 \"nonimmediate_operand\" \"Ym\")]))]\n-  \"TARGET_SSE2 && reload_completed\"\n+  \"TARGET_SSE2\"\n   \"cmp%D1sd\\t{%3, %0|%0, %3}\"\n   [(set_attr \"type\" \"ssecmp\")\n    (set_attr \"mode\" \"DF\")])\n@@ -17707,51 +17706,6 @@\n   \"(TARGET_80387 && TARGET_CMOVE) || TARGET_SSE_MATH\"\n   \"if (! ix86_expand_fp_movcc (operands)) FAIL; DONE;\")\n \n-;; These versions of min/max are aware of the instruction's behavior\n-;; wrt -0.0 and NaN inputs.  If we don't care about either, then we\n-;; should have used the smin/smax expanders in the first place.\n-(define_insn \"*movsfcc_1_sse_min\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=x\")\n-\t(if_then_else:SF\n-\t  (lt:SF (match_operand:SF 1 \"register_operand\" \"0\")\n-\t\t (match_operand:SF 2 \"nonimmediate_operand\" \"xm\"))\n-\t  (match_dup 1)\n-\t  (match_dup 2)))]\n-  \"TARGET_SSE_MATH\"\n-  \"minss\\t{%2, %0|%0, %2}\"\n-  [(set_attr \"type\" \"sseadd\")\n-   (set_attr \"mode\" \"SF\")])\n-\n-(define_insn \"*movsfcc_1_sse_max\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=x\")\n-\t(if_then_else:SF\n-\t  (lt:SF (match_operand:SF 2 \"nonimmediate_operand\" \"xm\")\n-\t\t (match_operand:SF 1 \"nonimmediate_operand\" \"0\"))\n-\t  (match_dup 1)\n-\t  (match_dup 2)))]\n-  \"TARGET_SSE_MATH\"\n-  \"maxss\\t{%2, %0|%0, %2}\"\n-  [(set_attr \"type\" \"sseadd\")\n-   (set_attr \"mode\" \"SF\")])\n-\n-(define_insn_and_split \"*movsfcc_1_sse\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=x,x,x\")\n-\t(if_then_else:SF\n-\t  (match_operator:SF 4 \"sse_comparison_operator\"\n-\t    [(match_operand:SF 5 \"register_operand\" \"0,0,0\")\n-\t     (match_operand:SF 6 \"nonimmediate_operand\" \"xm,xm,xm\")])\n-\t  (match_operand:SF 2 \"reg_or_0_operand\" \"C,x,x\")\n-\t  (match_operand:SF 3 \"reg_or_0_operand\" \"x,C,x\")))\n-   (clobber (match_scratch:V4SF 1 \"=&x,&x,&x\"))]\n-  \"TARGET_SSE_MATH\"\n-  \"#\"\n-  \"&& reload_completed\"\n-  [(const_int 0)]\n-{\n-  ix86_split_sse_movcc (operands);\n-  DONE;\n-})\n-\n (define_insn \"*movsfcc_1_387\"\n   [(set (match_operand:SF 0 \"register_operand\" \"=f#r,f#r,r#f,r#f\")\n \t(if_then_else:SF (match_operator 1 \"fcmov_comparison_operator\" \n@@ -17776,51 +17730,6 @@\n   \"(TARGET_80387 && TARGET_CMOVE) || (TARGET_SSE2 && TARGET_SSE_MATH)\"\n   \"if (! ix86_expand_fp_movcc (operands)) FAIL; DONE;\")\n \n-;; These versions of min/max are aware of the instruction's behavior\n-;; wrt -0.0 and NaN inputs.  If we don't care about either, then we\n-;; should have used the smin/smax expanders in the first place.\n-(define_insn \"*movdfcc_1_sse_min\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=x\")\n-\t(if_then_else:DF\n-\t  (lt:DF (match_operand:DF 1 \"register_operand\" \"0\")\n-\t\t (match_operand:DF 2 \"nonimmediate_operand\" \"xm\"))\n-\t  (match_dup 1)\n-\t  (match_dup 2)))]\n-  \"TARGET_SSE2 && TARGET_SSE_MATH\"\n-  \"minsd\\t{%2, %0|%0, %2}\"\n-  [(set_attr \"type\" \"sseadd\")\n-   (set_attr \"mode\" \"DF\")])\n-\n-(define_insn \"*movdfcc_1_sse_max\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=x\")\n-\t(if_then_else:DF\n-\t  (lt:DF (match_operand:DF 2 \"nonimmediate_operand\" \"xm\")\n-\t\t (match_operand:DF 1 \"nonimmediate_operand\" \"0\"))\n-\t  (match_dup 1)\n-\t  (match_dup 2)))]\n-  \"TARGET_SSE2 && TARGET_SSE_MATH\"\n-  \"maxsd\\t{%2, %0|%0, %2}\"\n-  [(set_attr \"type\" \"sseadd\")\n-   (set_attr \"mode\" \"DF\")])\n-\n-(define_insn_and_split \"*movdfcc_1_sse\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=x,x,x\")\n-\t(if_then_else:DF\n-\t  (match_operator:DF 4 \"sse_comparison_operator\"\n-\t    [(match_operand:DF 5 \"register_operand\" \"0,0,0\")\n-\t     (match_operand:DF 6 \"nonimmediate_operand\" \"xm,xm,xm\")])\n-\t  (match_operand:DF 2 \"reg_or_0_operand\" \"C,x,x\")\n-\t  (match_operand:DF 3 \"reg_or_0_operand\" \"x,C,x\")))\n-   (clobber (match_scratch:V2DF 1 \"=&x,&x,&x\"))]\n-  \"TARGET_SSE2 && TARGET_SSE_MATH\"\n-  \"#\"\n-  \"&& reload_completed\"\n-  [(const_int 0)]\n-{\n-  ix86_split_sse_movcc (operands);\n-  DONE;\n-})\n-\n (define_insn \"*movdfcc_1\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=f#r,f#r,&r#f,&r#f\")\n \t(if_then_else:DF (match_operator 1 \"fcmov_comparison_operator\" \n@@ -17935,6 +17844,52 @@\n   [(set_attr \"type\" \"sseadd\")\n    (set_attr \"mode\" \"DF\")])\n \n+;; These versions of the min/max patterns implement exactly the operations\n+;;   min = (op1 < op2 ? op1 : op2)\n+;;   max = (!(op1 < op2) ? op1 : op2)\n+;; Their operands are not commutative, and thus they may be used in the\n+;; presence of -0.0 and NaN.\n+\n+(define_insn \"*ieee_sminsf3\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=x\")\n+\t(unspec:SF [(match_operand:SF 1 \"register_operand\" \"0\")\n+\t\t    (match_operand:SF 2 \"nonimmediate_operand\" \"xm\")]\n+\t\t   UNSPEC_IEEE_MIN))]\n+  \"TARGET_SSE_MATH\"\n+  \"minss\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"sseadd\")\n+   (set_attr \"mode\" \"SF\")])\n+\n+(define_insn \"*ieee_smaxsf3\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=x\")\n+\t(unspec:SF [(match_operand:SF 1 \"register_operand\" \"0\")\n+\t\t    (match_operand:SF 2 \"nonimmediate_operand\" \"xm\")]\n+\t\t   UNSPEC_IEEE_MAX))]\n+  \"TARGET_SSE_MATH\"\n+  \"maxss\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"sseadd\")\n+   (set_attr \"mode\" \"SF\")])\n+\n+(define_insn \"*ieee_smindf3\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=x\")\n+\t(unspec:DF [(match_operand:DF 1 \"register_operand\" \"0\")\n+\t\t    (match_operand:DF 2 \"nonimmediate_operand\" \"xm\")]\n+\t\t   UNSPEC_IEEE_MIN))]\n+  \"TARGET_SSE2 && TARGET_SSE_MATH\"\n+  \"minsd\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"sseadd\")\n+   (set_attr \"mode\" \"DF\")])\n+\n+(define_insn \"*ieee_smaxdf3\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=x\")\n+\t(unspec:DF [(match_operand:DF 1 \"register_operand\" \"0\")\n+\t\t    (match_operand:DF 2 \"nonimmediate_operand\" \"xm\")]\n+\t\t   UNSPEC_IEEE_MAX))]\n+  \"TARGET_SSE2 && TARGET_SSE_MATH\"\n+  \"maxsd\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"sseadd\")\n+   (set_attr \"mode\" \"DF\")])\n+\n ;; Conditional addition patterns\n (define_expand \"addqicc\"\n   [(match_operand:QI 0 \"register_operand\" \"\")"}, {"sha": "dc8f9e4dec00743c7494ed44408872096d604472", "filename": "gcc/config/i386/sse.md", "status": "modified", "additions": 83, "deletions": 1, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab8efbd82444a0246d024e7b1709820ba289b2a8/gcc%2Fconfig%2Fi386%2Fsse.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab8efbd82444a0246d024e7b1709820ba289b2a8/gcc%2Fconfig%2Fi386%2Fsse.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsse.md?ref=ab8efbd82444a0246d024e7b1709820ba289b2a8", "patch": "@@ -773,6 +773,47 @@\n   [(set_attr \"type\" \"sselog\")\n    (set_attr \"mode\" \"V4SF\")])\n \n+;; Also define scalar versions.  These are used for abs, neg, and\n+;; conditional move.  Using subregs into vector modes causes regiser\n+;; allocation lossage.  These patterns do not allow memory operands\n+;; because the native instructions read the full 128-bits.\n+\n+(define_insn \"*andsf3\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=x\")\n+\t(and:SF (match_operand:SF 1 \"register_operand\" \"0\")\n+\t\t(match_operand:SF 2 \"register_operand\" \"x\")))]\n+  \"TARGET_SSE\"\n+  \"andps\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"sselog\")\n+   (set_attr \"mode\" \"V4SF\")])\n+\n+(define_insn \"*nandsf3\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=x\")\n+\t(and:SF (not:SF (match_operand:SF 1 \"register_operand\" \"0\"))\n+\t\t(match_operand:SF 2 \"register_operand\" \"x\")))]\n+  \"TARGET_SSE\"\n+  \"andnps\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"sselog\")\n+   (set_attr \"mode\" \"V4SF\")])\n+\n+(define_insn \"*iorsf3\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=x\")\n+\t(ior:SF (match_operand:SF 1 \"register_operand\" \"0\")\n+\t\t(match_operand:SF 2 \"register_operand\" \"x\")))]\n+  \"TARGET_SSE\"\n+  \"orps\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"sselog\")\n+   (set_attr \"mode\" \"V4SF\")])\n+\n+(define_insn \"*xorsf3\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=x\")\n+\t(xor:SF (match_operand:SF 1 \"register_operand\" \"0\")\n+\t\t(match_operand:SF 2 \"register_operand\" \"x\")))]\n+  \"TARGET_SSE\"\n+  \"xorps\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"sselog\")\n+   (set_attr \"mode\" \"V4SF\")])\n+\n ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n ;;\n ;; Parallel single-precision floating point conversion operations\n@@ -1624,7 +1665,7 @@\n   [(set (match_operand:V2DF 0 \"register_operand\" \"=x\")\n \t(and:V2DF (match_operand:V2DF 1 \"nonimmediate_operand\" \"%0\")\n \t\t  (match_operand:V2DF 2 \"nonimmediate_operand\" \"xm\")))]\n-  \"TARGET_SSE2 && ix86_binary_operator_ok (AND, V4SFmode, operands)\"\n+  \"TARGET_SSE2 && ix86_binary_operator_ok (AND, V2DFmode, operands)\"\n   \"andpd\\t{%2, %0|%0, %2}\"\n   [(set_attr \"type\" \"sselog\")\n    (set_attr \"mode\" \"V2DF\")])\n@@ -1670,6 +1711,47 @@\n   [(set_attr \"type\" \"sselog\")\n    (set_attr \"mode\" \"V2DF\")])\n \n+;; Also define scalar versions.  These are used for abs, neg, and\n+;; conditional move.  Using subregs into vector modes causes regiser\n+;; allocation lossage.  These patterns do not allow memory operands\n+;; because the native instructions read the full 128-bits.\n+\n+(define_insn \"*anddf3\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=x\")\n+\t(and:DF (match_operand:DF 1 \"register_operand\" \"0\")\n+\t\t(match_operand:DF 2 \"register_operand\" \"x\")))]\n+  \"TARGET_SSE2\"\n+  \"andpd\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"sselog\")\n+   (set_attr \"mode\" \"V2DF\")])\n+\n+(define_insn \"*nanddf3\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=x\")\n+\t(and:DF (not:DF (match_operand:DF 1 \"register_operand\" \"0\"))\n+\t\t(match_operand:DF 2 \"register_operand\" \"x\")))]\n+  \"TARGET_SSE2\"\n+  \"andnpd\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"sselog\")\n+   (set_attr \"mode\" \"V2DF\")])\n+\n+(define_insn \"*iordf3\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=x\")\n+\t(ior:DF (match_operand:DF 1 \"register_operand\" \"0\")\n+\t\t(match_operand:DF 2 \"register_operand\" \"x\")))]\n+  \"TARGET_SSE2\"\n+  \"orpd\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"sselog\")\n+   (set_attr \"mode\" \"V2DF\")])\n+\n+(define_insn \"*xordf3\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=x\")\n+\t(xor:DF (match_operand:DF 1 \"register_operand\" \"0\")\n+\t\t(match_operand:DF 2 \"register_operand\" \"x\")))]\n+  \"TARGET_SSE2\"\n+  \"xorpd\\t{%2, %0|%0, %2}\"\n+  [(set_attr \"type\" \"sselog\")\n+   (set_attr \"mode\" \"V2DF\")])\n+\n ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n ;;\n ;; Parallel double-precision floating point conversion operations"}]}