{"sha": "fe8fadc146937687b2677db5f72d0fb1a52462a6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmU4ZmFkYzE0NjkzNzY4N2IyNjc3ZGI1ZjcyZDBmYjFhNTI0NjJhNg==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2000-06-07T07:59:00Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2000-06-07T07:59:00Z"}, "message": "decl.c (pushdecl): Look up functions by DECL_NAME, not DECL_ASSEMBLER_NAME.\n\n\t* decl.c (pushdecl): Look up functions by DECL_NAME, not\n\tDECL_ASSEMBLER_NAME.\n\nFrom-SVN: r34443", "tree": {"sha": "1decd2c162270910c4706afeaa67565e0ce0fd39", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1decd2c162270910c4706afeaa67565e0ce0fd39"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fe8fadc146937687b2677db5f72d0fb1a52462a6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe8fadc146937687b2677db5f72d0fb1a52462a6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fe8fadc146937687b2677db5f72d0fb1a52462a6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe8fadc146937687b2677db5f72d0fb1a52462a6/comments", "author": null, "committer": null, "parents": [{"sha": "b31f762736cb30e48466bb77f458272fb0cc2114", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b31f762736cb30e48466bb77f458272fb0cc2114", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b31f762736cb30e48466bb77f458272fb0cc2114"}], "stats": {"total": 91, "additions": 43, "deletions": 48}, "files": [{"sha": "c034337bc0efe00761a3fbc432afd1d4c8c1c525", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe8fadc146937687b2677db5f72d0fb1a52462a6/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe8fadc146937687b2677db5f72d0fb1a52462a6/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=fe8fadc146937687b2677db5f72d0fb1a52462a6", "patch": "@@ -1,3 +1,8 @@\n+2000-06-07  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* decl.c (pushdecl): Look up functions by DECL_NAME, not\n+\tDECL_ASSEMBLER_NAME.\n+\n 2000-06-06  Mark Mitchell  <mark@codesourcery.com>\n \n \t* decl2.c (c_language): Define."}, {"sha": "413ff6ce3e7876131806f644776f86322d9463f6", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 38, "deletions": 48, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe8fadc146937687b2677db5f72d0fb1a52462a6/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe8fadc146937687b2677db5f72d0fb1a52462a6/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=fe8fadc146937687b2677db5f72d0fb1a52462a6", "patch": "@@ -3800,7 +3800,6 @@ pushdecl (x)\n   my_friendly_assert (!cfun || doing_semantic_analysis_p (),\n \t\t      19990913);\n \n-  name = DECL_ASSEMBLER_NAME (x);\n   need_new_binding = 1;\n \n   if (DECL_TEMPLATE_PARM_P (x))\n@@ -3832,12 +3831,7 @@ pushdecl (x)\n \tDECL_LOCAL_FUNCTION_P (x) = 1;\n     }\n \n-  /* Type are looked up using the DECL_NAME, as that is what the rest of the\n-     compiler wants to use.  */\n-  if (TREE_CODE (x) == TYPE_DECL || TREE_CODE (x) == VAR_DECL\n-      || TREE_CODE (x) == NAMESPACE_DECL)\n-    name = DECL_NAME (x);\n-\n+  name = DECL_NAME (x);\n   if (name)\n     {\n #if 0\n@@ -3853,21 +3847,35 @@ pushdecl (x)\n \tt = namespace_binding (name, DECL_CONTEXT (x));\n       else\n \tt = lookup_name_current_level (name);\n+\n+      /* If we are declaring a function, and the result of name-lookup\n+\t was an OVERLOAD, look for an overloaded instance that is\n+\t actually the same as the function we are declaring.  (If\n+\t there is one, we have to merge our declaration with the\n+\t previous declaration.)  */\n+      if (t && TREE_CODE (t) == OVERLOAD && TREE_CODE (x) == FUNCTION_DECL)\n+\t{\n+\t  tree match;\n+\n+\t  for (match = t; match; match = OVL_NEXT (match))\n+\t    if (DECL_ASSEMBLER_NAME (OVL_CURRENT (t))\n+\t\t== DECL_ASSEMBLER_NAME (x))\n+\t      break;\n+\n+\t  if (match)\n+\t    t = OVL_CURRENT (match);\n+\t  else\n+\t    t = NULL_TREE;\n+\t}\n+\n       if (t == error_mark_node)\n \t{\n \t  /* error_mark_node is 0 for a while during initialization!  */\n \t  t = NULL_TREE;\n \t  cp_error_at (\"`%#D' used prior to declaration\", x);\n \t}\n-\n       else if (t != NULL_TREE)\n \t{\n-#if 0\n-\t  /* This is turned off until I have time to do it right (bpk).  */\n-\t  /* With the code below that uses it...  */\n-\t  file = DECL_SOURCE_FILE (t);\n-\t  line = DECL_SOURCE_LINE (t);\n-#endif\n \t  if (TREE_CODE (t) == PARM_DECL)\n \t    {\n \t      if (DECL_CONTEXT (t) == NULL_TREE)\n@@ -3896,36 +3904,6 @@ pushdecl (x)\n \t    }\n \t  else if (duplicate_decls (x, t))\n \t    {\n-#if 0\n-\t      /* This is turned off until I have time to do it right (bpk).  */\n-\n-\t      /* Also warn if they did a prototype with `static' on it, but\n-\t\t then later left the `static' off.  */\n-\t      if (! TREE_PUBLIC (name) && TREE_PUBLIC (x))\n-\t\t{\n-\t\t  if (DECL_LANG_SPECIFIC (t) && DECL_FRIEND_P (t))\n-\t\t    return t;\n-\n-\t\t  if (extra_warnings)\n-\t\t    {\n-\t\t      cp_warning (\"`static' missing from declaration of `%D'\",\n-\t\t\t\t  t);\n-\t\t      warning_with_file_and_line (file, line,\n-\t\t\t\t\t\t  \"previous declaration of `%s'\",\n-\t\t\t\t\t\t  decl_as_string (t, 0));\n-\t\t    }\n-\n-\t\t  /* Now fix things so it'll do what they expect.  */\n-\t\t  if (current_function_decl)\n-\t\t    TREE_PUBLIC (current_function_decl) = 0;\n-\t\t}\n-\t      /* Due to interference in memory reclamation (X may be\n-\t\t obstack-deallocated at this point), we must guard against\n-\t\t one really special case.  [jason: This should be handled\n-\t\t by start_function]  */\n-\t      if (current_function_decl == x)\n-\t\tcurrent_function_decl = t;\n-#endif\n \t      if (TREE_CODE (t) == TYPE_DECL)\n \t\tSET_IDENTIFIER_TYPE_VALUE (name, TREE_TYPE (t));\n \t      else if (TREE_CODE (t) == FUNCTION_DECL)\n@@ -4048,7 +4026,11 @@ pushdecl (x)\n \t     warn if we later see static one.  */\n \t  if (IDENTIFIER_GLOBAL_VALUE (name) == NULL_TREE && TREE_PUBLIC (x))\n \t    TREE_PUBLIC (name) = 1;\n-\n+\t  \n+\t  /* Bind the mangled name for the entity.  In the future, we\n+\t     should not need to do this; mangled names are an\n+\t     implementation detail of which the front-end should not\n+\t     need to be aware.  */\n \t  if (!(TREE_CODE (x) == TYPE_DECL && DECL_ARTIFICIAL (x)\n \t\t&& t != NULL_TREE)\n \t      /* For an ordinary function, we create a binding from\n@@ -4057,11 +4039,19 @@ pushdecl (x)\n \t\t ordinary name are the same so we need not do this.  */\n \t      && !DECL_EXTERN_C_FUNCTION_P (x))\n \t    {\n+\t      tree mangled_name;\n+\n+\t      if (TREE_CODE (x) == TYPE_DECL || TREE_CODE (x) == VAR_DECL\n+\t\t  || TREE_CODE (x) == NAMESPACE_DECL)\n+\t\tmangled_name = name;\n+\t      else\n+\t\tmangled_name = DECL_ASSEMBLER_NAME (x);\n+\n \t      if (TREE_CODE (x) == FUNCTION_DECL)\n \t\tmy_friendly_assert\n-\t\t  ((IDENTIFIER_GLOBAL_VALUE (name) == NULL_TREE)\n-\t\t  || (IDENTIFIER_GLOBAL_VALUE (name) == x), 378);\n-\t      SET_IDENTIFIER_NAMESPACE_VALUE (name, x);\n+\t\t  ((IDENTIFIER_GLOBAL_VALUE (mangled_name) == NULL_TREE)\n+\t\t  || (IDENTIFIER_GLOBAL_VALUE (mangled_name) == x), 378);\n+\t      SET_IDENTIFIER_NAMESPACE_VALUE (mangled_name, x);\n \t    }\n \n \t  /* Don't forget if the function was used via an implicit decl.  */"}]}