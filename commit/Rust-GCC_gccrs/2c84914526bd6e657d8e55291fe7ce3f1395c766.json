{"sha": "2c84914526bd6e657d8e55291fe7ce3f1395c766", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmM4NDkxNDUyNmJkNmU2NTdkOGU1NTI5MWZlN2NlM2YxMzk1Yzc2Ng==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@casey.cygnus.com", "date": "2000-03-23T00:29:55Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2000-03-23T00:29:55Z"}, "message": "Implement dwarf2 exception handling for the ARM.\n\n        * config/arm/arm.h (INCOMING_RETURN_ADDR_RTX): Define.\n        (DWARF_FRAME_RETURN_COLUMN): Define.\n        * config/arm/arm.c (emit_multi_reg_push): Return rtx.  Attach\n        REG_FRAME_RELATED_EXPR note.\n        (emit_sfm): Likewise.\n        (arm_expand_prologue): Set RTX_FRAME_RELATED_P on everything.\n        * dwarf2out.c (reg_save): Handle saving a register to itself.\n        (dwarf2out_frame_debug_expr): Handle an intermediate cfa reg.\n        * except.c (eh_regs): Don't use the static chain reg if it's\n        callee-saved.\n        * frame.h (frame_state): Add cfa_saved field.\n        * frame.c (execute_cfa_insn): Set it.\n        * libgcc2.c (throw_helper): Don't adjust sp if it's restored in\n        the epilogue.\n        * function.c (ARG_POINTER_CFA_OFFSET): Default to FIRST_PARM_OFFSET.\n        Now takes a parm.\n        (instantiate_virtual_regs): Adjust.\n        * tm.texi: Adjust.\n        * config/m68k/m68k.h (ARG_POINTER_CFA_OFFSET): Don't define.\n        * config/ns32k/ns32k.h (ARG_POINTER_CFA_OFFSET): Don't define.\n        * config/sparc/sparc.h (ARG_POINTER_CFA_OFFSET): Take a parm.\n\n        * dwarf2out.c (reg_number): Refer to FIRST_PSEUDO_REGISTER.\n        (initial_return_save): Use DWARF_FRAME_REGNUM, not reg_number.\n\nFrom-SVN: r32696", "tree": {"sha": "b3b34069ee82d4ab6af7bad503c9132d5330f934", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b3b34069ee82d4ab6af7bad503c9132d5330f934"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2c84914526bd6e657d8e55291fe7ce3f1395c766", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c84914526bd6e657d8e55291fe7ce3f1395c766", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2c84914526bd6e657d8e55291fe7ce3f1395c766", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c84914526bd6e657d8e55291fe7ce3f1395c766/comments", "author": null, "committer": null, "parents": [{"sha": "cb1072f45021824406e8ac504a111d6bbccb5b81", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb1072f45021824406e8ac504a111d6bbccb5b81", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cb1072f45021824406e8ac504a111d6bbccb5b81"}], "stats": {"total": 287, "additions": 211, "deletions": 76}, "files": [{"sha": "9a386b0e3bbac63ea1ec21b0e0dcaabdd5a6d26f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c84914526bd6e657d8e55291fe7ce3f1395c766/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c84914526bd6e657d8e55291fe7ce3f1395c766/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2c84914526bd6e657d8e55291fe7ce3f1395c766", "patch": "@@ -1,3 +1,36 @@\n+2000-03-22  Jason Merrill  <jason@casey.cygnus.com>\n+\n+\t* config/rs6000/rs6000.h (DWARF_FRAME_RETURN_COLUMN): Define.\n+\t* config/alpha/alpha.h (DWARF_FRAME_RETURN_COLUMN): Define.\n+\t* config/sparc/sparc.h (DWARF_FRAME_RETURN_COLUMN): Define.\n+\t* dwarf2out.c (throw_helper): Adjust.\n+\n+\tImplement dwarf2 exception handling for the ARM.\n+\t* config/arm/arm.h (INCOMING_RETURN_ADDR_RTX): Define.\n+\t(DWARF_FRAME_RETURN_COLUMN): Define.\n+\t* config/arm/arm.c (emit_multi_reg_push): Return rtx.  Attach\n+\tREG_FRAME_RELATED_EXPR note.\n+\t(emit_sfm): Likewise.\n+\t(arm_expand_prologue): Set RTX_FRAME_RELATED_P on everything.\n+\t* dwarf2out.c (reg_save): Handle saving a register to itself.\n+\t(dwarf2out_frame_debug_expr): Handle an intermediate cfa reg.\n+\t* except.c (eh_regs): Don't use the static chain reg if it's\n+\tcallee-saved.\n+\t* frame.h (frame_state): Add cfa_saved field.\n+\t* frame.c (execute_cfa_insn): Set it.\n+\t* libgcc2.c (throw_helper): Don't adjust sp if it's restored in \n+\tthe epilogue.\n+\t* function.c (ARG_POINTER_CFA_OFFSET): Default to FIRST_PARM_OFFSET.\n+\tNow takes a parm.\n+\t(instantiate_virtual_regs): Adjust.\n+\t* tm.texi: Adjust.\n+\t* config/m68k/m68k.h (ARG_POINTER_CFA_OFFSET): Don't define.\n+\t* config/ns32k/ns32k.h (ARG_POINTER_CFA_OFFSET): Don't define.\n+\t* config/sparc/sparc.h (ARG_POINTER_CFA_OFFSET): Take a parm.\n+\n+\t* dwarf2out.c (reg_number): Refer to FIRST_PSEUDO_REGISTER.\n+\t(initial_return_save): Use DWARF_FRAME_REGNUM, not reg_number.\n+\n 2000-03-22  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* builtins.def: New file."}, {"sha": "3177a64e5ea7bf7f3edac78d48bce462351f5eaf", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 112, "deletions": 35, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c84914526bd6e657d8e55291fe7ce3f1395c766/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c84914526bd6e657d8e55291fe7ce3f1395c766/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=2c84914526bd6e657d8e55291fe7ce3f1395c766", "patch": "@@ -64,8 +64,8 @@ static int eliminate_lr2ip \t\tPARAMS ((rtx *));\n static char * shift_op \t\t\tPARAMS ((rtx, HOST_WIDE_INT *));\n static int pattern_really_clobbers_lr \tPARAMS ((rtx));\n static int function_really_clobbers_lr \tPARAMS ((rtx));\n-static void emit_multi_reg_push \tPARAMS ((int));\n-static void emit_sfm \t\t\tPARAMS ((int, int));\n+static rtx emit_multi_reg_push\t \tPARAMS ((int));\n+static rtx emit_sfm \t\t\tPARAMS ((int, int));\n static enum arm_cond_code get_arm_condition_code PARAMS ((rtx));\n static int const_ok_for_op \t\tPARAMS ((HOST_WIDE_INT, enum rtx_code));\n static void arm_add_gc_roots \t\tPARAMS ((void));\n@@ -6268,13 +6268,20 @@ output_func_epilogue (frame_size)\n   after_arm_reorg = 0;\n }\n \n-static void\n+/* Generate and emit an insn that we will recognize as a push_multi.\n+   Unfortunately, since this insn does not reflect very well the actual\n+   semantics of the operation, we need to annotate the insn for the benefit\n+   of DWARF2 frame unwind information.  */\n+\n+static rtx\n emit_multi_reg_push (mask)\n      int mask;\n {\n   int num_regs = 0;\n   int i, j;\n   rtx par;\n+  rtx dwarf;\n+  rtx tmp, reg;\n \n   for (i = 0; i < 16; i++)\n     if (mask & (1 << i))\n@@ -6284,20 +6291,32 @@ emit_multi_reg_push (mask)\n     abort ();\n \n   par = gen_rtx_PARALLEL (VOIDmode, rtvec_alloc (num_regs));\n+  dwarf = gen_rtx_PARALLEL (VOIDmode, rtvec_alloc (num_regs));\n+  RTX_FRAME_RELATED_P (dwarf) = 1;\n \n   for (i = 0; i < 16; i++)\n     {\n       if (mask & (1 << i))\n \t{\n+\t  reg = gen_rtx_REG (SImode, i);\n+\n \t  XVECEXP (par, 0, 0)\n \t    = gen_rtx_SET (VOIDmode,\n \t\t\t   gen_rtx_MEM (BLKmode,\n \t\t\t\t\tgen_rtx_PRE_DEC (BLKmode,\n \t\t\t\t\t\t\t stack_pointer_rtx)),\n \t\t\t   gen_rtx_UNSPEC (BLKmode,\n-\t\t\t\t\t   gen_rtvec (1,\n-\t\t\t\t\t\t      gen_rtx_REG (SImode, i)),\n+\t\t\t\t\t   gen_rtvec (1, reg),\n \t\t\t\t\t   2));\n+\n+\t  tmp = gen_rtx_SET (VOIDmode,\n+\t\t\t     gen_rtx_MEM (SImode,\n+\t\t\t\t\t  gen_rtx_PRE_DEC (BLKmode,\n+\t\t\t\t\t\t\t   stack_pointer_rtx)),\n+\t\t\t     reg);\n+\t  RTX_FRAME_RELATED_P (tmp) = 1;\n+\t  XVECEXP (dwarf, 0, num_regs - 1) = tmp;\t  \n+\n \t  break;\n \t}\n     }\n@@ -6306,38 +6325,77 @@ emit_multi_reg_push (mask)\n     {\n       if (mask & (1 << i))\n \t{\n-\t  XVECEXP (par, 0, j)\n-\t    = gen_rtx_USE (VOIDmode, gen_rtx_REG (SImode, i));\n+\t  reg = gen_rtx_REG (SImode, i);\n+\n+\t  XVECEXP (par, 0, j) = gen_rtx_USE (VOIDmode, reg);\n+\n+\t  tmp = gen_rtx_SET (VOIDmode,\n+\t\t\t     gen_rtx_MEM (SImode,\n+\t\t\t\t\t  gen_rtx_PRE_DEC (BLKmode,\n+\t\t\t\t\t\t\t   stack_pointer_rtx)),\n+\t\t\t     reg);\n+\t  RTX_FRAME_RELATED_P (tmp) = 1;\n+\t  XVECEXP (dwarf, 0, num_regs - j - 1) = tmp;\n+\t\t\t   \n \t  j++;\n \t}\n     }\n \n-  emit_insn (par);\n+  par = emit_insn (par);\n+  REG_NOTES (par) = gen_rtx_EXPR_LIST (REG_FRAME_RELATED_EXPR, dwarf,\n+\t\t\t\t       REG_NOTES (par));\n+  return par;\n }\n \n-static void\n+static rtx\n emit_sfm (base_reg, count)\n      int base_reg;\n      int count;\n {\n   rtx par;\n+  rtx dwarf;\n+  rtx tmp, reg;\n   int i;\n \n   par = gen_rtx_PARALLEL (VOIDmode, rtvec_alloc (count));\n+  dwarf = gen_rtx_PARALLEL (VOIDmode, rtvec_alloc (count));\n+  RTX_FRAME_RELATED_P (dwarf) = 1;\n+\n+  reg = gen_rtx_REG (XFmode, base_reg++);\n \n   XVECEXP (par, 0, 0)\n     = gen_rtx_SET (VOIDmode, \n \t\t   gen_rtx_MEM (BLKmode,\n \t\t\t\tgen_rtx_PRE_DEC (BLKmode, stack_pointer_rtx)),\n \t\t   gen_rtx_UNSPEC (BLKmode,\n-\t\t\t\t   gen_rtvec (1, gen_rtx_REG (XFmode, \n-\t\t\t\t\t\t\t      base_reg++)),\n+\t\t\t\t   gen_rtvec (1, reg),\n \t\t\t\t   2));\n+  tmp\n+    = gen_rtx_SET (VOIDmode, \n+\t\t   gen_rtx_MEM (XFmode,\n+\t\t\t\tgen_rtx_PRE_DEC (BLKmode, stack_pointer_rtx)),\n+\t\t   reg);\n+  RTX_FRAME_RELATED_P (tmp) = 1;\n+  XVECEXP (dwarf, 0, count - 1) = tmp;\t  \n+  \n   for (i = 1; i < count; i++)\n-    XVECEXP (par, 0, i) = gen_rtx_USE (VOIDmode, \n-\t\t\t\t       gen_rtx_REG (XFmode, base_reg++));\n+    {\n+      reg = gen_rtx_REG (XFmode, base_reg++);\n+      XVECEXP (par, 0, i) = gen_rtx_USE (VOIDmode, reg);\n+\n+      tmp = gen_rtx_SET (VOIDmode, \n+\t\t\t gen_rtx_MEM (XFmode,\n+\t\t\t\t      gen_rtx_PRE_DEC (BLKmode,\n+\t\t\t\t\t\t       stack_pointer_rtx)),\n+\t\t\t reg);\n+      RTX_FRAME_RELATED_P (tmp) = 1;\n+      XVECEXP (dwarf, 0, count - i - 1) = tmp;\t  \n+    }\n \n-  emit_insn (par);\n+  par = emit_insn (par);\n+  REG_NOTES (par) = gen_rtx_EXPR_LIST (REG_FRAME_RELATED_EXPR, dwarf,\n+\t\t\t\t       REG_NOTES (par));\n+  return par;\n }\n \n void\n@@ -6352,6 +6410,7 @@ arm_expand_prologue ()\n      the call-saved regs.  */\n   int volatile_func = (optimize > 0\n \t\t       && TREE_THIS_VOLATILE (current_function_decl));\n+  rtx insn;\n \n   /* Naked functions don't have prologues.  */\n   if (arm_naked_function_p (current_function_decl))\n@@ -6376,42 +6435,47 @@ arm_expand_prologue ()\n   if (frame_pointer_needed)\n     {\n       live_regs_mask |= 0xD800;\n-      emit_insn (gen_movsi (gen_rtx_REG (SImode, IP_REGNUM),\n-\t\t\t    stack_pointer_rtx));\n+      insn = emit_insn (gen_movsi (gen_rtx_REG (SImode, IP_REGNUM),\n+\t\t\t\t   stack_pointer_rtx));\n+      RTX_FRAME_RELATED_P (insn) = 1;\n     }\n \n   if (current_function_pretend_args_size)\n     {\n       if (store_arg_regs)\n-\temit_multi_reg_push ((0xf0 >> (current_function_pretend_args_size / 4))\n-\t\t\t     & 0xf);\n+\tinsn = emit_multi_reg_push\n+\t  ((0xf0 >> (current_function_pretend_args_size / 4)) & 0xf);\n       else\n-\temit_insn (gen_addsi3 (stack_pointer_rtx, stack_pointer_rtx, \n-\t\t\t       GEN_INT (-current_function_pretend_args_size)));\n+\tinsn = emit_insn\n+\t  (gen_addsi3 (stack_pointer_rtx, stack_pointer_rtx, \n+\t\t       GEN_INT (-current_function_pretend_args_size)));\n+      RTX_FRAME_RELATED_P (insn) = 1;\n     }\n \n   if (live_regs_mask)\n     {\n       /* If we have to push any regs, then we must push lr as well, or\n \t we won't get a proper return.  */\n       live_regs_mask |= 1 << LR_REGNUM;\n-      emit_multi_reg_push (live_regs_mask);\n+      insn = emit_multi_reg_push (live_regs_mask);\n+      RTX_FRAME_RELATED_P (insn) = 1;\n     }\n       \n-  /* For now the integer regs are still pushed in output_func_epilogue ().  */\n+  /* And now the floating point regs.  */\n \n   if (! volatile_func)\n     {\n       if (arm_fpu_arch == FP_SOFT2)\n \t{\n \t  for (reg = 23; reg > 15; reg--)\n \t    if (regs_ever_live[reg] && ! call_used_regs[reg])\n-\t      emit_insn (gen_rtx_SET\n-\t\t\t (VOIDmode, \n-\t\t\t  gen_rtx_MEM (XFmode, \n-\t\t\t\t       gen_rtx_PRE_DEC (XFmode,\n-\t\t\t\t\t\t\tstack_pointer_rtx)),\n-\t\t\t  gen_rtx_REG (XFmode, reg)));\n+\t      {\n+\t\tinsn = gen_rtx_PRE_DEC (XFmode, stack_pointer_rtx);\n+\t\tinsn = gen_rtx_MEM (XFmode, insn);\n+\t\tinsn = emit_insn (gen_rtx_SET (VOIDmode, insn,\n+\t\t\t\t\t       gen_rtx_REG (XFmode, reg)));\n+\t\tRTX_FRAME_RELATED_P (insn) = 1;\n+\t      }\n \t}\n       else\n \t{\n@@ -6423,31 +6487,44 @@ arm_expand_prologue ()\n \t\t{\n \t\t  if (start_reg - reg == 3)\n \t\t    {\n-\t\t      emit_sfm (reg, 4);\n+\t\t      insn = emit_sfm (reg, 4);\n+\t\t      RTX_FRAME_RELATED_P (insn) = 1;\n \t\t      start_reg = reg - 1;\n \t\t    }\n \t\t}\n \t      else\n \t\t{\n \t\t  if (start_reg != reg)\n-\t\t    emit_sfm (reg + 1, start_reg - reg);\n+\t\t    {\n+\t\t      insn = emit_sfm (reg + 1, start_reg - reg);\n+\t\t      RTX_FRAME_RELATED_P (insn) = 1;\n+\t\t    }\n \t\t  start_reg = reg - 1;\n \t\t}\n \t    }\n \n \t  if (start_reg != reg)\n-\t    emit_sfm (reg + 1, start_reg - reg);\n+\t    {\n+\t      insn = emit_sfm (reg + 1, start_reg - reg);\n+\t      RTX_FRAME_RELATED_P (insn) = 1;\n+\t    }\n \t}\n     }\n \n   if (frame_pointer_needed)\n-    emit_insn (gen_addsi3 (hard_frame_pointer_rtx, gen_rtx_REG (SImode, IP_REGNUM),\n-\t\t\t   (GEN_INT\n-\t\t\t    (-(4 + current_function_pretend_args_size)))));\n+    {\n+      insn = GEN_INT (-(4 + current_function_pretend_args_size));\n+      insn = emit_insn (gen_addsi3 (hard_frame_pointer_rtx,\n+\t\t\t\t    gen_rtx_REG (SImode, IP_REGNUM),\n+\t\t\t\t    insn));\n+      RTX_FRAME_RELATED_P (insn) = 1;\n+    }\n \n   if (amount != const0_rtx)\n     {\n-      emit_insn (gen_addsi3 (stack_pointer_rtx, stack_pointer_rtx, amount));\n+      insn = emit_insn (gen_addsi3 (stack_pointer_rtx, stack_pointer_rtx,\n+\t\t\t\t    amount));\n+      RTX_FRAME_RELATED_P (insn) = 1;\n       emit_insn (gen_rtx_CLOBBER (VOIDmode, \n \t\t\t\t  gen_rtx_MEM (BLKmode, stack_pointer_rtx)));\n     }"}, {"sha": "b748b745002434e4f842926558dfb7c2275ef226", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c84914526bd6e657d8e55291fe7ce3f1395c766/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c84914526bd6e657d8e55291fe7ce3f1395c766/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=2c84914526bd6e657d8e55291fe7ce3f1395c766", "patch": "@@ -2275,6 +2275,13 @@ extern struct rtx_def * arm_compare_op1;\n    ? gen_rtx_MEM (Pmode, plus_constant (FRAME, -4)) \\\n    : NULL_RTX)\n \n+/* Pick up the return address upon entry to a procedure. Used for\n+   dwarf2 unwind information.  This also enables the table driven\n+   mechanism.  */\n+\n+#define INCOMING_RETURN_ADDR_RTX\tgen_rtx_REG (Pmode, LR_REGNUM)\n+#define DWARF_FRAME_RETURN_COLUMN\tDWARF_FRAME_REGNUM (LR_REGNUM)\n+\n /* Used to mask out junk bits from the return address, such as\n    processor state, interrupt status, condition codes and the like.  */\n #define MASK_RETURN_ADDR \\"}, {"sha": "5d170429bf0d94759f708f4fed4ed3b4cbf57ced", "filename": "gcc/config/m68k/m68k.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c84914526bd6e657d8e55291fe7ce3f1395c766/gcc%2Fconfig%2Fm68k%2Fm68k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c84914526bd6e657d8e55291fe7ce3f1395c766/gcc%2Fconfig%2Fm68k%2Fm68k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.h?ref=2c84914526bd6e657d8e55291fe7ce3f1395c766", "patch": "@@ -925,9 +925,6 @@ extern enum reg_class regno_reg_class[];\n /* Offset of first parameter from the argument pointer register value.  */\n #define FIRST_PARM_OFFSET(FNDECL) 8\n \n-/* Offset of the CFA from the argument pointer register value.  */\n-#define ARG_POINTER_CFA_OFFSET 8\n-\n /* Value is the number of byte of arguments automatically\n    popped when returning from a subroutine call.\n    FUNDECL is the declaration node of the function (as a tree),"}, {"sha": "4a0bf43d69de63437dc1b5a4c238dcf797732a76", "filename": "gcc/config/ns32k/ns32k.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c84914526bd6e657d8e55291fe7ce3f1395c766/gcc%2Fconfig%2Fns32k%2Fns32k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c84914526bd6e657d8e55291fe7ce3f1395c766/gcc%2Fconfig%2Fns32k%2Fns32k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fns32k%2Fns32k.h?ref=2c84914526bd6e657d8e55291fe7ce3f1395c766", "patch": "@@ -552,9 +552,6 @@ enum reg_class\n \n #define INCOMING_FRAME_SP_OFFSET 4\n \n-/* Offset of the CFA from the argument pointer register value.  */\n-#define ARG_POINTER_CFA_OFFSET 8\n-\n /* If we generate an insn to push BYTES bytes,\n    this says how many the stack pointer really advances by.\n    On the 32000, sp@- in a byte insn really pushes a BYTE.  */"}, {"sha": "0da6cd6a9c4de8dffeae441ad3045c2bb2237c93", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c84914526bd6e657d8e55291fe7ce3f1395c766/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c84914526bd6e657d8e55291fe7ce3f1395c766/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=2c84914526bd6e657d8e55291fe7ce3f1395c766", "patch": "@@ -1603,9 +1603,11 @@ extern char leaf_reg_remap[];\n   (TARGET_ARCH64 ? (SPARC_STACK_BIAS + 16 * UNITS_PER_WORD) \\\n    : (STRUCT_VALUE_OFFSET + UNITS_PER_WORD))\n \n-/* Offset from the argument pointer register value to the CFA.  */\n+/* Offset from the argument pointer register value to the CFA.\n+   This is different from FIRST_PARM_OFFSET because the register window\n+   comes between the CFA and the arguments.  */\n \n-#define ARG_POINTER_CFA_OFFSET  SPARC_STACK_BIAS\n+#define ARG_POINTER_CFA_OFFSET(FNDECL)  SPARC_STACK_BIAS\n \n /* When a parameter is passed in a register, stack space is still\n    allocated for it."}, {"sha": "f181f26b056f99ba30ca707010d6dac1f996cf09", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 13, "deletions": 22, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c84914526bd6e657d8e55291fe7ce3f1395c766/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c84914526bd6e657d8e55291fe7ce3f1395c766/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=2c84914526bd6e657d8e55291fe7ce3f1395c766", "patch": "@@ -559,7 +559,7 @@ reg_number (rtl)\n {\n   register unsigned regno = REGNO (rtl);\n \n-  if (regno >= DWARF_FRAME_REGISTERS)\n+  if (regno >= FIRST_PSEUDO_REGISTER)\n     {\n       warning (\"internal regno botch: regno = %d\\n\", regno);\n       regno = 0;\n@@ -882,6 +882,9 @@ reg_save (label, reg, sreg, offset)\n \t}\n       cfi->dw_cfi_oprnd2.dw_cfi_offset = offset;\n     }\n+  else if (sreg == reg)\n+    /* We could emit a DW_CFA_same_value in this case, but don't bother.  */\n+    return;\n   else\n     {\n       cfi->dw_cfi_opc = DW_CFA_register;\n@@ -975,7 +978,7 @@ initial_return_save (rtl)\n     {\n     case REG:\n       /* RA is in a register.  */\n-      reg = reg_number (rtl);\n+      reg = DWARF_FRAME_REGNUM (REGNO (rtl));\n       break;\n     case MEM:\n       /* RA is on the stack.  */\n@@ -1174,10 +1177,11 @@ dwarf2out_frame_debug_expr (expr, label)\n         case REG:\n           if (cfa_reg != (unsigned) REGNO (src))\n             abort ();\n-          if (REGNO (dest) != STACK_POINTER_REGNUM\n-\t      && !(frame_pointer_needed\n-\t\t   && REGNO (dest) == HARD_FRAME_POINTER_REGNUM))\n-            abort ();\n+\n+\t  /* We used to require that dest be either SP or FP, but the\n+\t     ARM copies SP to a temporary register, and from there to\n+\t     FP.  So we just rely on the backends to only set\n+\t     RTX_FRAME_RELATED_P on appropriate insns.  */\n           cfa_reg = REGNO (dest);\n           break;\n \n@@ -1221,32 +1225,19 @@ dwarf2out_frame_debug_expr (expr, label)\n             {\n \t      /* Either setting the FP from an offset of the SP,\n \t\t or adjusting the FP */\n-\t      if (! frame_pointer_needed\n-\t\t  || REGNO (dest) != HARD_FRAME_POINTER_REGNUM)\n+\t      if (! frame_pointer_needed)\n \t\tabort ();\n \n-\t      if (XEXP (src, 0) == stack_pointer_rtx\n+\t      if (GET_CODE (XEXP (src, 0)) == REG\n+\t\t  && (unsigned) REGNO (XEXP (src, 0)) == cfa_reg\n \t\t  && GET_CODE (XEXP (src, 1)) == CONST_INT)\n \t\t{\n-\t\t  if (cfa_reg != STACK_POINTER_REGNUM)\n-\t\t    abort ();\n \t\t  offset = INTVAL (XEXP (src, 1));\n \t\t  if (GET_CODE (src) == PLUS)\n \t\t    offset = -offset;\n \t\t  cfa_offset += offset;\n \t\t  cfa_reg = HARD_FRAME_POINTER_REGNUM;\n \t\t}\n-\t      else if (XEXP (src, 0) == hard_frame_pointer_rtx\n-\t\t       && GET_CODE (XEXP (src, 1)) == CONST_INT)\n-\t\t{\n-\t\t  if (cfa_reg != (unsigned) HARD_FRAME_POINTER_REGNUM)\n-\t\t    abort ();\n-\t\t  offset = INTVAL (XEXP (src, 1));\n-\t\t  if (GET_CODE (src) == PLUS)\n-\t\t    offset = -offset;\n-\t\t  cfa_offset += offset;\n-\t\t}\n-\n \t      else \n \t\tabort();\n             }"}, {"sha": "7cf64cccd02c88e16ccf54d593d8e8cc72aae5e5", "filename": "gcc/except.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c84914526bd6e657d8e55291fe7ce3f1395c766/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c84914526bd6e657d8e55291fe7ce3f1395c766/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=2c84914526bd6e657d8e55291fe7ce3f1395c766", "patch": "@@ -2910,9 +2910,10 @@ expand_builtin_frob_return_addr (addr_tree)\n    The first passes the exception context to the handler.  For this\n    we use the return value register for a void*.\n \n-   The second holds the stack pointer value to be restored.  For\n-   this we use the static chain register if it exists and is different\n-   from the previous, otherwise some arbitrary call-clobbered register.\n+   The second holds the stack pointer value to be restored.  For this\n+   we use the static chain register if it exists, is different from\n+   the previous, and is call-clobbered; otherwise some arbitrary\n+   call-clobbered register.\n \n    The third holds the address of the handler itself.  Here we use\n    some arbitrary call-clobbered register.  */\n@@ -2939,7 +2940,8 @@ eh_regs (pcontext, psp, pra, outgoing)\n     rsp = static_chain_incoming_rtx;\n   else\n     rsp = static_chain_rtx;\n-  if (REGNO (rsp) == REGNO (rcontext))\n+  if (REGNO (rsp) == REGNO (rcontext)\n+      || ! call_used_regs [REGNO (rsp)])\n #endif /* STATIC_CHAIN_REGNUM */\n     rsp = NULL_RTX;\n "}, {"sha": "688355a970d78d1f0ef2da95465534dffdca1790", "filename": "gcc/frame.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c84914526bd6e657d8e55291fe7ce3f1395c766/gcc%2Fframe.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c84914526bd6e657d8e55291fe7ce3f1395c766/gcc%2Fframe.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fframe.c?ref=2c84914526bd6e657d8e55291fe7ce3f1395c766", "patch": "@@ -697,6 +697,8 @@ execute_cfa_insn (void *p, struct frame_state_internal *state,\n       offset *= info->data_align;\n       state->s.saved[reg] = REG_SAVED_OFFSET;\n       state->s.reg_or_offset[reg] = offset;\n+      if (reg == state->s.cfa_reg)\n+\tstate->s.cfa_saved = 1;\n     }\n   else if (insn & DW_CFA_restore)\n     {\n@@ -728,6 +730,8 @@ execute_cfa_insn (void *p, struct frame_state_internal *state,\n       offset *= info->data_align;\n       state->s.saved[reg] = REG_SAVED_OFFSET;\n       state->s.reg_or_offset[reg] = offset;\n+      if (reg == state->s.cfa_reg)\n+\tstate->s.cfa_saved = 1;\n       break;\n     case DW_CFA_restore_extended:\n       p = decode_uleb128 (p, &reg);"}, {"sha": "ecaf6b08344ba6cd0c3b2a98b18457f28019edad", "filename": "gcc/frame.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c84914526bd6e657d8e55291fe7ce3f1395c766/gcc%2Fframe.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c84914526bd6e657d8e55291fe7ce3f1395c766/gcc%2Fframe.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fframe.h?ref=2c84914526bd6e657d8e55291fe7ce3f1395c766", "patch": "@@ -1,6 +1,6 @@\n /* Header file for unwinding stack frames for exception handling.  */\n /* Compile this one with gcc.  */\n-/* Copyright (C) 1997, 1998, 1999 Free Software Foundation, Inc.\n+/* Copyright (C) 1997, 1998, 1999, 2000 Free Software Foundation, Inc.\n    Contributed by Jason Merrill <jason@cygnus.com>.\n \n This file is part of GNU CC.\n@@ -34,6 +34,7 @@ typedef struct frame_state\n   long reg_or_offset[DWARF_FRAME_REGISTERS+1];\n   unsigned short cfa_reg;\n   unsigned short retaddr_column;\n+  char cfa_saved;\n   char saved[DWARF_FRAME_REGISTERS+1];\n } frame_state;\n "}, {"sha": "ae04a5c604467856fce23162b874e6a37a36cad5", "filename": "gcc/function.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c84914526bd6e657d8e55291fe7ce3f1395c766/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c84914526bd6e657d8e55291fe7ce3f1395c766/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=2c84914526bd6e657d8e55291fe7ce3f1395c766", "patch": "@@ -2760,10 +2760,10 @@ static int cfa_offset;\n #endif\n #endif\n \n-/* On a few machines, the CFA coincides with the arg pointer.  */\n+/* On most machines, the CFA coincides with the first incoming parm.  */\n \n #ifndef ARG_POINTER_CFA_OFFSET\n-#define ARG_POINTER_CFA_OFFSET 0\n+#define ARG_POINTER_CFA_OFFSET(FNDECL) FIRST_PARM_OFFSET (FNDECL)\n #endif\n \n \n@@ -3335,7 +3335,7 @@ instantiate_virtual_regs (fndecl, insns)\n   var_offset = STARTING_FRAME_OFFSET;\n   dynamic_offset = STACK_DYNAMIC_OFFSET (fndecl);\n   out_arg_offset = STACK_POINTER_OFFSET;\n-  cfa_offset = ARG_POINTER_CFA_OFFSET;\n+  cfa_offset = ARG_POINTER_CFA_OFFSET (fndecl);\n \n   /* Scan all variables and parameters of this function.  For each that is\n      in memory, instantiate all virtual registers if the result is a valid"}, {"sha": "aafbe753339d67851f83e63e06615d659d887a54", "filename": "gcc/libgcc2.c", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c84914526bd6e657d8e55291fe7ce3f1395c766/gcc%2Flibgcc2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c84914526bd6e657d8e55291fe7ce3f1395c766/gcc%2Flibgcc2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flibgcc2.c?ref=2c84914526bd6e657d8e55291fe7ce3f1395c766", "patch": "@@ -3679,6 +3679,7 @@ throw_helper (struct eh_context *eh, void *pc, frame_state *my_udata,\n   void *handler;\n   void *handler_p = 0;\n   void *pc_p = 0;\n+  void *restored_cfa = 0;\n   frame_state saved_ustruct;\n   int new_eh_model;\n   int cleanup = 0;\n@@ -3788,6 +3789,11 @@ throw_helper (struct eh_context *eh, void *pc, frame_state *my_udata,\n       pc = saved_pc;\n       memcpy (udata, my_udata, sizeof (*udata));\n \n+      if (udata->cfa_saved)\n+\t/* We saved the CFA register into the stack in this frame, so we\n+\t   will restore it in the __throw epilogue.  Remember the value.  */\n+\trestored_cfa = udata->cfa;\n+\n       while (pc != handler_pc)\n \t{\n \t  frame_state *p = udata;\n@@ -3808,6 +3814,9 @@ throw_helper (struct eh_context *eh, void *pc, frame_state *my_udata,\n \t\tcopy_reg (i, udata, my_udata);\n \t      }\n \n+\t  if (udata->cfa_saved)\n+\t    restored_cfa = udata->cfa;\n+\n \t  pc = get_return_addr (udata, sub_udata) - 1;\n \t}\n \n@@ -3823,6 +3832,13 @@ throw_helper (struct eh_context *eh, void *pc, frame_state *my_udata,\n     }\n   /* udata now refers to the frame called by the handler frame.  */\n \n+  if (my_udata->cfa_saved)\n+    /* If we saved the CFA register into the stack (after it became the\n+       CFA register), we'll restore that value into SP in the epilogue,\n+       as on the ARM.  So calculate the adjustment based on the value that\n+       will be restored.  */\n+    my_udata->cfa = restored_cfa;\n+\n   /* We adjust SP by the difference between __throw's CFA and the CFA for\n      the frame called by the handler frame, because those CFAs correspond\n      to the SP values at the two call sites.  We need to further adjust by"}, {"sha": "3a1b9ebebf4d6518d2e533306b82d0f729939f48", "filename": "gcc/tm.texi", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c84914526bd6e657d8e55291fe7ce3f1395c766/gcc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c84914526bd6e657d8e55291fe7ce3f1395c766/gcc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftm.texi?ref=2c84914526bd6e657d8e55291fe7ce3f1395c766", "patch": "@@ -2292,6 +2292,9 @@ the stack.\n You only need to define this macro if you want to support call frame\n debugging information like that provided by DWARF 2.\n \n+If this RTL is a @code{REG}, you should also define\n+DWARF_FRAME_RETURN_COLUMN to @code{DWARF_FRAME_REGNUM (REGNO)}.\n+\n @findex INCOMING_FRAME_SP_OFFSET\n @item INCOMING_FRAME_SP_OFFSET\n A C expression whose value is an integer giving the offset, in bytes,\n@@ -2304,15 +2307,20 @@ You only need to define this macro if you want to support call frame\n debugging information like that provided by DWARF 2.\n \n @findex ARG_POINTER_CFA_OFFSET\n-@item ARG_POINTER_CFA_OFFSET\n+@item ARG_POINTER_CFA_OFFSET (@var{fundecl})\n A C expression whose value is an integer giving the offset, in bytes,\n from the argument pointer to the canonical frame address (cfa).  The\n final value should coincide with that calculated by \n @code{INCOMING_FRAME_SP_OFFSET}.  Which is unfortunately not usable\n during virtual register instantiation.\n \n-You only need to define this macro if you want to support call frame\n-debugging information like that provided by DWARF 2.\n+The default value for this macro is @code{FIRST_PARM_OFFSET (fundecl)},\n+which is correct for most machines; in general, the arguments are found\n+immediately before the stack frame.  See @file{function.c} for details.\n+\n+You only need to define this macro if this default is incorrect, and you\n+want to support call frame debugging information like that provided by\n+DWARF 2.\n \n @findex SMALL_STACK\n @item SMALL_STACK"}]}