{"sha": "fb4d43485acbe15bc3cfeed48f0dae1d9556f9e5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmI0ZDQzNDg1YWNiZTE1YmMzY2ZlZWQ0OGYwZGFlMWQ5NTU2ZjllNQ==", "commit": {"author": {"name": "Geoff Keating", "email": "geoffk@cygnus.com", "date": "2000-07-03T20:00:44Z"}, "committer": {"name": "Geoffrey Keating", "email": "geoffk@gcc.gnu.org", "date": "2000-07-03T20:00:44Z"}, "message": "rs6000.c (rs6000_emit_move): New function.\n\n* config/rs6000/rs6000.c (rs6000_emit_move): New function.\n* config/rs6000/rs6000-proto.h: Prototype rs6000_emit_move.\n* config/rs6000/rs6000.md (movsi): Use rs6000_emit_move.\n(movhi): Likewise.\n(movqi): Likewise.\n(movdf): Likewise.\n(movsf): Likewise.\n(movdi): Likewise.\n(movti): Likewise.\n\nFrom-SVN: r34852", "tree": {"sha": "75e6dae798241201d77df3dd22054dddc824c663", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/75e6dae798241201d77df3dd22054dddc824c663"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fb4d43485acbe15bc3cfeed48f0dae1d9556f9e5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb4d43485acbe15bc3cfeed48f0dae1d9556f9e5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fb4d43485acbe15bc3cfeed48f0dae1d9556f9e5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb4d43485acbe15bc3cfeed48f0dae1d9556f9e5/comments", "author": null, "committer": null, "parents": [{"sha": "3b5286d750ae58ea5ef78bbdda5197cc4702f282", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b5286d750ae58ea5ef78bbdda5197cc4702f282", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3b5286d750ae58ea5ef78bbdda5197cc4702f282"}], "stats": {"total": 589, "additions": 287, "deletions": 302}, "files": [{"sha": "85c2e0855f1ab9bb550b53d19e6f66b873c0eb4a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb4d43485acbe15bc3cfeed48f0dae1d9556f9e5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb4d43485acbe15bc3cfeed48f0dae1d9556f9e5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fb4d43485acbe15bc3cfeed48f0dae1d9556f9e5", "patch": "@@ -1,5 +1,15 @@\n 2000-07-03  Geoff Keating  <geoffk@cygnus.com>\n \n+\t* config/rs6000/rs6000.c (rs6000_emit_move): New function.\n+\t* config/rs6000/rs6000-proto.h: Prototype rs6000_emit_move.\n+\t* config/rs6000/rs6000.md (movsi): Use rs6000_emit_move.\n+\t(movhi): Likewise.\n+\t(movqi): Likewise.\n+\t(movdf): Likewise.\n+\t(movsf): Likewise.\n+\t(movdi): Likewise.\n+\t(movti): Likewise.\n+\n \t* expmed.c (expand_mult_highpart): Use op1 instead of wide_op1 when\n \tmode instead of wider_mode is being used.\n "}, {"sha": "2237b7e1c8f24e02eb67e7a0ffa84a03b2e7164e", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb4d43485acbe15bc3cfeed48f0dae1d9556f9e5/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb4d43485acbe15bc3cfeed48f0dae1d9556f9e5/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=fb4d43485acbe15bc3cfeed48f0dae1d9556f9e5", "patch": "@@ -97,6 +97,7 @@ extern int mtcrf_operation PARAMS ((rtx, enum machine_mode));\n extern int lmw_operation PARAMS ((rtx, enum machine_mode));\n extern struct rtx_def *create_TOC_reference PARAMS ((rtx));\n extern void rs6000_emit_eh_toc_restore PARAMS ((rtx));\n+extern void rs6000_emit_move PARAMS ((rtx, rtx, enum machine_mode));\n extern rtx rs6000_legitimize_address PARAMS ((rtx, rtx, enum machine_mode));\n extern void rs6000_select_rtx_section PARAMS ((enum machine_mode, rtx));\n #endif /* RTX_CODE */"}, {"sha": "73b46df7ce07fd8f77ff73ebebbd9d6cbf0d1983", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 269, "deletions": 0, "changes": 269, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb4d43485acbe15bc3cfeed48f0dae1d9556f9e5/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb4d43485acbe15bc3cfeed48f0dae1d9556f9e5/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=fb4d43485acbe15bc3cfeed48f0dae1d9556f9e5", "patch": "@@ -1458,8 +1458,277 @@ rs6000_legitimize_address (x, oldx, mode)\n   else\n     return NULL_RTX;\n }\n+\f\n+/* Emit a move from SOURCE to DEST in mode MODE.  */\n+void\n+rs6000_emit_move (dest, source, mode)\n+     rtx dest;\n+     rtx source;\n+     enum machine_mode mode;\n+{\n+  rtx operands[2];\n+  operands[0] = dest;\n+  operands[1] = source;\n+  \n+  /* Sanity checks.  Check that we get CONST_DOUBLE only when we should.  */\n+  if (GET_CODE (operands[1]) == CONST_DOUBLE\n+      && ! FLOAT_MODE_P (mode)\n+      && GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT)\n+    {\n+      /* FIXME.  This should never happen.  */\n+      /* Since it seems that it does, do the safe thing and convert\n+\t to a CONST_INT.  */\n+      operands[1] = \n+\tGEN_INT (trunc_int_for_mode (CONST_DOUBLE_LOW (operands[1]), mode));\n+    }\n+  if (GET_CODE (operands[1]) == CONST_DOUBLE\n+      && ! FLOAT_MODE_P (mode)\n+      && ((CONST_DOUBLE_HIGH (operands[1]) == 0\n+\t   && CONST_DOUBLE_LOW (operands[1]) >= 0)\n+\t  || (CONST_DOUBLE_HIGH (operands[1]) == -1\n+\t      && CONST_DOUBLE_LOW (operands[1]) < 0)))\n+    abort ();\n+  \n+  if (! no_new_pseudos && GET_CODE (operands[0]) != REG)\n+    operands[1] = force_reg (mode, operands[1]);\n+  \n+  if (mode == SFmode && ! TARGET_POWERPC && TARGET_HARD_FLOAT)\n+    {\n+      int regnum = true_regnum (operands[1]);\n+      /* regnum may be -1 in which case the test below will fail.  */\t\n+      \n+      /* If operands[1] is a register, on POWER it may have\n+\t double-precision data in it, so truncate it to single\n+\t precision.  */\n+      if (FP_REGNO_P (regnum) || regnum >= FIRST_PSEUDO_REGISTER)\n+\t{\n+\t  rtx newreg;\n+\t  newreg = (no_new_pseudos ? operands[1] : gen_reg_rtx (mode));\n+\t  emit_insn (gen_aux_truncdfsf2 (newreg, operands[1]));\n+\t  operands[1] = newreg;\n+\t}\n+    }\n+\n+  /* Only a tiny bit of handling for CONSTANT_P_RTX is necessary.  */\n+  if (GET_CODE (operands[1]) == CONSTANT_P_RTX)\n+    {\n+      emit_insn (gen_rtx_SET (VOIDmode, operands[0], operands[1]));\n+      return;\n+    }\n+\n+  /* FIXME:  In the long term, this switch statement should go away\n+     and be replaced by a sequence of tests based on things like\n+     mode == Pmode.  */\n+  switch (mode)\n+    {\n+    case HImode:\n+    case QImode:\n+      if (CONSTANT_P (operands[1])\n+\t  && GET_CODE (operands[1]) != CONST_INT)\n+\t{\n+\t  operands[1] = force_const_mem (mode, operands[1]);\n+\t  if (! memory_address_p (mode, XEXP (operands[1], 0))\n+\t      && ! reload_in_progress)\n+\t    operands[1] = change_address (operands[1], mode,\n+\t\t\t\t\t  XEXP (operands[1], 0));\n+\t}\n+      break;\n \n+    case DFmode:\n+    case SFmode:\n+      if (CONSTANT_P (operands[1]) \n+\t  && ! easy_fp_constant (operands[1], mode))\n+\t{\n+\t  operands[1] = force_const_mem (mode, operands[1]);\n+\t  if (! memory_address_p (mode, XEXP (operands[1], 0))\n+\t      && ! reload_in_progress)\n+\t    operands[1] = change_address (operands[1], mode,\n+\t\t\t\t\t  XEXP (operands[1], 0));\n+\t}\n+      break;\n+      \n+    case SImode:\n+      /* Use default pattern for address of ELF small data */\n+      if (TARGET_ELF\n+\t  && (DEFAULT_ABI == ABI_V4 || DEFAULT_ABI == ABI_SOLARIS)\n+\t  && (GET_CODE (operands[1]) == SYMBOL_REF || GET_CODE (operands[1]) == CONST)\n+\t  && small_data_operand (operands[1], SImode))\n+\t{\n+\t  emit_insn (gen_rtx_SET (VOIDmode, operands[0], operands[1]));\n+\t  return;\n+\t}\n+\n+      if ((DEFAULT_ABI == ABI_V4 || DEFAULT_ABI == ABI_SOLARIS)\n+\t  && flag_pic == 1 && got_operand (operands[1], SImode))\n+\t{\n+\t  emit_insn (gen_movsi_got (operands[0], operands[1]));\n+\t  return;\n+\t}\n \n+      if (TARGET_ELF && TARGET_NO_TOC && ! TARGET_64BIT\n+\t  && ! flag_pic\n+\t  && CONSTANT_P (operands[1])\n+\t  && GET_CODE (operands[1]) != HIGH\n+\t  && GET_CODE (operands[1]) != CONST_INT)\n+\t{\n+\t  rtx target = (no_new_pseudos ? operands[0] : gen_reg_rtx (SImode));\n+\n+\t  /* If this is a function address on -mcall-aixdesc,\n+\t     convert it to the address of the descriptor.  */\n+\t  if (DEFAULT_ABI == ABI_AIX\n+\t      && GET_CODE (operands[1]) == SYMBOL_REF\n+\t      && XSTR (operands[1], 0)[0] == '.')\n+\t    {\n+\t      const char *name = XSTR (operands[1], 0);\n+\t      rtx new_ref;\n+\t      while (*name == '.')\n+\t\tname++;\n+\t      new_ref = gen_rtx_SYMBOL_REF (Pmode, name);\n+\t      CONSTANT_POOL_ADDRESS_P (new_ref)\n+\t\t= CONSTANT_POOL_ADDRESS_P (operands[1]);\n+\t      SYMBOL_REF_FLAG (new_ref) = SYMBOL_REF_FLAG (operands[1]);\n+\t      SYMBOL_REF_USED (new_ref) = SYMBOL_REF_USED (operands[1]);\n+\t      operands[1] = new_ref;\n+\t    }\n+\n+\t  emit_insn (gen_elf_high (target, operands[1]));\n+\t  emit_insn (gen_elf_low (operands[0], target, operands[1]));\n+\t  return;\n+\t}\n+\n+      if (CONSTANT_P (operands[1])\n+\t  && GET_CODE (operands[1]) != CONST_INT\n+\t  && GET_CODE (operands[1]) != HIGH\n+\t  && ! LEGITIMATE_CONSTANT_POOL_ADDRESS_P (operands[1])\n+\t  && ! TOC_RELATIVE_EXPR_P (operands[1]))\n+\t{\n+\t  /* Emit a USE operation so that the constant isn't deleted if\n+\t     expensive optimizations are turned on because nobody\n+\t     references it.  This should only be done for operands that\n+\t     contain SYMBOL_REFs with CONSTANT_POOL_ADDRESS_P set.\n+\t     This should not be done for operands that contain LABEL_REFs.\n+\t     For now, we just handle the obvious case.  */\n+\t  if (GET_CODE (operands[1]) != LABEL_REF)\n+\t    emit_insn (gen_rtx_USE (VOIDmode, operands[1]));\n+\n+      /* If we are to limit the number of things we put in the TOC and\n+\t this is a symbol plus a constant we can add in one insn,\n+\t just put the symbol in the TOC and add the constant.  Don't do\n+\t this if reload is in progress.  */\n+\t  if (GET_CODE (operands[1]) == CONST\n+\t      && TARGET_NO_SUM_IN_TOC && ! reload_in_progress\n+\t      && GET_CODE (XEXP (operands[1], 0)) == PLUS\n+\t      && add_operand (XEXP (XEXP (operands[1], 0), 1), SImode)\n+\t      && (GET_CODE (XEXP (XEXP (operands[1], 0), 0)) == LABEL_REF\n+\t\t  || GET_CODE (XEXP (XEXP (operands[1], 0), 0)) == SYMBOL_REF)\n+\t      && ! side_effects_p (operands[0]))\n+\t    {\n+\t      rtx sym = force_const_mem (SImode, XEXP (XEXP (operands[1], 0), 0));\n+\t      rtx other = XEXP (XEXP (operands[1], 0), 1);\n+\n+\t      emit_insn (gen_addsi3 (operands[0], force_reg (SImode, sym), other));\n+\t      return;\n+\t    }\n+\n+\t  operands[1] = force_const_mem (SImode, operands[1]);\n+\n+\t  if (TARGET_TOC \n+\t      && CONSTANT_POOL_EXPR_P (XEXP (operands[1], 0))\n+\t      && ASM_OUTPUT_SPECIAL_POOL_ENTRY_P (get_pool_constant (\n+\t\t\t\t\t\t\t\t     XEXP (operands[1], 0))))\n+\t    {\n+\t      operands[1] = gen_rtx_MEM (SImode,\n+\t\t\t\t\t create_TOC_reference (XEXP (operands[1], 0)));\n+\t      MEM_ALIAS_SET (operands[1]) = get_TOC_alias_set ();\t\n+\t      RTX_UNCHANGING_P (operands[1]) = 1;\n+\t    }\n+\n+\t  if (! memory_address_p (SImode, XEXP (operands[1], 0))\n+\t      && ! reload_in_progress)\n+\t    operands[1] = change_address (operands[1], SImode,\n+\t\t\t\t\t  XEXP (operands[1], 0));\n+\t}\n+      break;\n+\n+    case DImode:\n+      if (TARGET_64BIT\n+\t  && CONSTANT_P (operands[1])\n+#if HOST_BITS_PER_WIDE_INT == 32\n+\t  && GET_CODE (operands[1]) != CONST_INT\n+#endif\n+\t  && ! easy_fp_constant (operands[1], DImode)\n+\t  && ! LEGITIMATE_CONSTANT_POOL_ADDRESS_P (operands[1])\n+\t  && ! TOC_RELATIVE_EXPR_P (operands[1]))\n+\t{\n+\t  /* Emit a USE operation so that the constant isn't deleted if\n+\t     expensive optimizations are turned on because nobody\n+\t     references it.  This should only be done for operands that\n+\t     contain SYMBOL_REFs with CONSTANT_POOL_ADDRESS_P set.\n+\t     This should not be done for operands that contain LABEL_REFs.\n+\t     For now, we just handle the obvious case.  */\n+\t  if (GET_CODE (operands[1]) != LABEL_REF)\n+\t    emit_insn (gen_rtx_USE (VOIDmode, operands[1]));\n+\n+\t  /* If we are to limit the number of things we put in the TOC and\n+\t     this is a symbol plus a constant we can add in one insn,\n+\t     just put the symbol in the TOC and add the constant.  Don't do\n+\t     this if reload is in progress.  */\n+\t  if (GET_CODE (operands[1]) == CONST\n+\t      && TARGET_NO_SUM_IN_TOC && ! reload_in_progress\n+\t      && GET_CODE (XEXP (operands[1], 0)) == PLUS\n+\t      && add_operand (XEXP (XEXP (operands[1], 0), 1), DImode)\n+\t      && (GET_CODE (XEXP (XEXP (operands[1], 0), 0)) == LABEL_REF\n+\t\t  || GET_CODE (XEXP (XEXP (operands[1], 0), 0)) == SYMBOL_REF)\n+\t      && ! side_effects_p (operands[0]))\n+\t    {\n+\t      rtx sym = force_const_mem (DImode, XEXP (XEXP (operands[1], 0), 0));\n+\t      rtx other = XEXP (XEXP (operands[1], 0), 1);\n+\n+\t      emit_insn (gen_adddi3 (operands[0], force_reg (DImode, sym), other));\n+\t      return;\n+\t    }\n+\n+\t  operands[1] = force_const_mem (DImode, operands[1]);\n+\n+\t  if (TARGET_TOC \n+\t      && CONSTANT_POOL_EXPR_P (XEXP (operands[1], 0))\n+\t      && ASM_OUTPUT_SPECIAL_POOL_ENTRY_P (get_pool_constant (\n+\t\t\t\t\t\t\t\t     XEXP (operands[1], 0))))\n+\t    {\n+\t      operands[1] = gen_rtx_MEM (DImode,\n+\t\t\t\t\t create_TOC_reference (XEXP (operands[1], 0)));\n+\n+\t      MEM_ALIAS_SET (operands[1]) = get_TOC_alias_set ();\t\n+\t      RTX_UNCHANGING_P (operands[1]) = 1;\n+\t    }\t\n+\n+\t  if (! memory_address_p (DImode, XEXP (operands[1], 0))\n+\t      && ! reload_in_progress)\n+\t    operands[1] = change_address (operands[1], DImode,\n+\t\t\t\t\t  XEXP (operands[1], 0));\n+\t}\n+      break;\n+  \n+    case TImode:\n+      if (GET_CODE (operands[0]) == MEM\n+\t  && GET_CODE (XEXP (operands[0], 0)) != REG\n+\t  && ! reload_in_progress)\n+\toperands[0] = change_address (operands[0], TImode,\n+\t\t\t\t      copy_addr_to_reg (XEXP (operands[0], 0)));\n+\n+      if (GET_CODE (operands[1]) == MEM\n+\t  && GET_CODE (XEXP (operands[1], 0)) != REG\n+\t  && ! reload_in_progress)\n+\toperands[1] = change_address (operands[1], TImode,\n+\t\t\t\t      copy_addr_to_reg (XEXP (operands[1], 0)));\n+      break;\n+\n+    default:\n+      abort ();\n+    }\n+\n+  emit_insn (gen_rtx_SET (VOIDmode, operands[0], operands[1]));\n+}\n \f\n /* Initialize a variable CUM of type CUMULATIVE_ARGS\n    for a call to a function whose data type is FNTYPE."}, {"sha": "4dfe6ba4a23044a450204e4a778d92f7557079ef", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 7, "deletions": 302, "changes": 309, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb4d43485acbe15bc3cfeed48f0dae1d9556f9e5/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb4d43485acbe15bc3cfeed48f0dae1d9556f9e5/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=fb4d43485acbe15bc3cfeed48f0dae1d9556f9e5", "patch": "@@ -7434,123 +7434,7 @@\n   [(set (match_operand:SI 0 \"general_operand\" \"\")\n \t(match_operand:SI 1 \"any_operand\" \"\"))]\n   \"\"\n-  \"\n-{\n-  if (! no_new_pseudos && GET_CODE (operands[0]) != REG)\n-    operands[1] = force_reg (SImode, operands[1]);\n-\n-  /* Convert a move of a CONST_DOUBLE into a CONST_INT */\n-  if (GET_CODE (operands[1]) == CONST_DOUBLE)\n-    operands[1] = GEN_INT (CONST_DOUBLE_LOW (operands[1]));\n-\n-  /* Only a tiny bit of handling for CONSTANT_P_RTX is necessary.  */\n-  if (GET_CODE (operands[1]) == CONSTANT_P_RTX)\n-    {\n-      emit_insn (gen_rtx_SET (VOIDmode, operands[0], operands[1]));\n-      DONE;\n-    }\n-\n-  /* Use default pattern for address of ELF small data */\n-  if (TARGET_ELF\n-      && (DEFAULT_ABI == ABI_V4 || DEFAULT_ABI == ABI_SOLARIS)\n-      && (GET_CODE (operands[1]) == SYMBOL_REF || GET_CODE (operands[1]) == CONST)\n-      && small_data_operand (operands[1], SImode))\n-    {\n-      emit_insn (gen_rtx_SET (VOIDmode, operands[0], operands[1]));\n-      DONE;\n-    }\n-\n-  if ((DEFAULT_ABI == ABI_V4 || DEFAULT_ABI == ABI_SOLARIS)\n-      && flag_pic == 1 && got_operand (operands[1], SImode))\n-    {\n-      emit_insn (gen_movsi_got (operands[0], operands[1]));\n-      DONE;\n-    }\n-\n-  if (TARGET_ELF && TARGET_NO_TOC && ! TARGET_64BIT\n-      && ! flag_pic\n-      && CONSTANT_P (operands[1])\n-      && GET_CODE (operands[1]) != HIGH\n-      && GET_CODE (operands[1]) != CONST_INT)\n-    {\n-      rtx target = (no_new_pseudos ? operands[0] : gen_reg_rtx (SImode));\n-\n-      /* If this is a function address on -mcall-aixdesc,\n-\t convert it to the address of the descriptor.  */\n-      if (DEFAULT_ABI == ABI_AIX\n-\t  && GET_CODE (operands[1]) == SYMBOL_REF\n-\t  && XSTR (operands[1], 0)[0] == '.')\n-\t{\n-\t  const char *name = XSTR (operands[1], 0);\n-\t  rtx new_ref;\n-\t  while (*name == '.')\n-\t    name++;\n-\t  new_ref = gen_rtx_SYMBOL_REF (Pmode, name);\n-\t  CONSTANT_POOL_ADDRESS_P (new_ref)\n-\t    = CONSTANT_POOL_ADDRESS_P (operands[1]);\n-\t  SYMBOL_REF_FLAG (new_ref) = SYMBOL_REF_FLAG (operands[1]);\n-\t  SYMBOL_REF_USED (new_ref) = SYMBOL_REF_USED (operands[1]);\n-\t  operands[1] = new_ref;\n-\t}\n-\n-      emit_insn (gen_elf_high (target, operands[1]));\n-      emit_insn (gen_elf_low (operands[0], target, operands[1]));\n-      DONE;\n-    }\n-\n-  if (CONSTANT_P (operands[1])\n-      && GET_CODE (operands[1]) != CONST_INT\n-      && GET_CODE (operands[1]) != HIGH\n-      && ! LEGITIMATE_CONSTANT_POOL_ADDRESS_P (operands[1])\n-      && ! TOC_RELATIVE_EXPR_P (operands[1]))\n-    {\n-      /* Emit a USE operation so that the constant isn't deleted if\n-\t expensive optimizations are turned on because nobody\n-\t references it.  This should only be done for operands that\n-\t contain SYMBOL_REFs with CONSTANT_POOL_ADDRESS_P set.\n-\t This should not be done for operands that contain LABEL_REFs.\n-\t For now, we just handle the obvious case.  */\n-      if (GET_CODE (operands[1]) != LABEL_REF)\n-\temit_insn (gen_rtx_USE (VOIDmode, operands[1]));\n-\n-      /* If we are to limit the number of things we put in the TOC and\n-\t this is a symbol plus a constant we can add in one insn,\n-\t just put the symbol in the TOC and add the constant.  Don't do\n-\t this if reload is in progress.  */\n-      if (GET_CODE (operands[1]) == CONST\n-\t  && TARGET_NO_SUM_IN_TOC && ! reload_in_progress\n-\t  && GET_CODE (XEXP (operands[1], 0)) == PLUS\n-\t  && add_operand (XEXP (XEXP (operands[1], 0), 1), SImode)\n-\t  && (GET_CODE (XEXP (XEXP (operands[1], 0), 0)) == LABEL_REF\n-\t      || GET_CODE (XEXP (XEXP (operands[1], 0), 0)) == SYMBOL_REF)\n-\t  && ! side_effects_p (operands[0]))\n-\t{\n-\t  rtx sym = force_const_mem (SImode, XEXP (XEXP (operands[1], 0), 0));\n-\t  rtx other = XEXP (XEXP (operands[1], 0), 1);\n-\n-\t  emit_insn (gen_addsi3 (operands[0], force_reg (SImode, sym), other));\n-\t  DONE;\n-\t}\n-\n-      operands[1] = force_const_mem (SImode, operands[1]);\n-\n-      if (TARGET_TOC \n-\t  && CONSTANT_POOL_EXPR_P (XEXP (operands[1], 0))\n-\t  && ASM_OUTPUT_SPECIAL_POOL_ENTRY_P (get_pool_constant (\n-\t\tXEXP (operands[1], 0))))\n-\t{\n-\t  operands[1] = gen_rtx_MEM (SImode,\n-\t\t\t     create_TOC_reference (XEXP (operands[1], 0)));\n-\t  MEM_ALIAS_SET (operands[1]) = get_TOC_alias_set ();\t\n-\t  RTX_UNCHANGING_P (operands[1]) = 1;\n-\t}\n-\n-      if (! memory_address_p (SImode, XEXP (operands[1], 0))\n-\t  && ! reload_in_progress)\n-\toperands[1] = change_address (operands[1], SImode,\n-\t\t\t\t      XEXP (operands[1], 0));\n-    }\n-}\")\n+  \"{ rs6000_emit_move (operands[0], operands[1], SImode); DONE; }\")\n \n (define_insn \"*movsi_internal1\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r,r,r,m,r,r,r,r,r,*q,*c*l,*h\")\n@@ -7620,21 +7504,7 @@\n   [(set (match_operand:HI 0 \"general_operand\" \"\")\n \t(match_operand:HI 1 \"any_operand\" \"\"))]\n   \"\"\n-  \"\n-{\n-  if (! no_new_pseudos && GET_CODE (operands[0]) != REG)\n-    operands[1] = force_reg (HImode, operands[1]);\n-\n-  if (CONSTANT_P (operands[1])\n-      && GET_CODE (operands[1]) != CONST_INT)\n-    {\n-      operands[1] = force_const_mem (HImode, operands[1]);\n-      if (! memory_address_p (HImode, XEXP (operands[1], 0))\n-\t  && ! reload_in_progress)\n-\toperands[1] = change_address (operands[1], HImode,\n-\t\t\t\t      XEXP (operands[1], 0));\n-    }\n-}\")\n+  \"{ rs6000_emit_move (operands[0], operands[1], HImode); DONE; }\")\n \n (define_insn \"\"\n   [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=r,r,m,r,r,*q,*c*l,*h\")\n@@ -7656,21 +7526,7 @@\n   [(set (match_operand:QI 0 \"general_operand\" \"\")\n \t(match_operand:QI 1 \"any_operand\" \"\"))]\n   \"\"\n-  \"\n-{\n-  if (! no_new_pseudos && GET_CODE (operands[0]) != REG)\n-    operands[1] = force_reg (QImode, operands[1]);\n-\n-  if (CONSTANT_P (operands[1])\n-      && GET_CODE (operands[1]) != CONST_INT)\n-    {\n-      operands[1] = force_const_mem (QImode, operands[1]);\n-      if (! memory_address_p (QImode, XEXP (operands[1], 0))\n-\t  && ! reload_in_progress)\n-\toperands[1] = change_address (operands[1], QImode,\n-\t\t\t\t      XEXP (operands[1], 0));\n-    }\n-}\")\n+  \"{ rs6000_emit_move (operands[0], operands[1], QImode); DONE; }\")\n \n (define_insn \"\"\n   [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=r,r,m,r,r,*q,*c*l,*h\")\n@@ -7723,49 +7579,7 @@\n   [(set (match_operand:SF 0 \"nonimmediate_operand\" \"\")\n \t(match_operand:SF 1 \"any_operand\" \"\"))]\n   \"\"\n-  \"\n-{\n-  /* If we are called from reload, we might be getting a SUBREG of a hard\n-     reg.  So expand it.  */\n-  if (GET_CODE (operands[0]) == SUBREG\n-      && GET_CODE (SUBREG_REG (operands[0])) == REG\n-      && REGNO (SUBREG_REG (operands[0])) < FIRST_PSEUDO_REGISTER\n-      && (! REG_FUNCTION_VALUE_P (SUBREG_REG (operands[0]))\n-\t  || ! rtx_equal_function_value_matters))\n-    operands[0] = alter_subreg (operands[0]);\n-  if (GET_CODE (operands[1]) == SUBREG\n-      && GET_CODE (SUBREG_REG (operands[1])) == REG\n-      && REGNO (SUBREG_REG (operands[1])) < FIRST_PSEUDO_REGISTER)\n-    operands[1] = alter_subreg (operands[1]);\n-\n-  if (GET_CODE (operands[0]) == MEM)\n-    {\n-      /* If operands[1] is a register, it may have double-precision data\n-\t in it, so truncate it to single precision.  We need not do\n-\t this for POWERPC.  */\n-      if (! TARGET_POWERPC && TARGET_HARD_FLOAT\n-\t  && GET_CODE (operands[1]) == REG\n-\t  && (FP_REGNO_P (REGNO (operands[1]))\n-\t      || REGNO (operands[1]) >= FIRST_PSEUDO_REGISTER))\n-\t{\n-\t  rtx newreg = (no_new_pseudos ? operands[1] : gen_reg_rtx (SFmode));\n-\t  emit_insn (gen_aux_truncdfsf2 (newreg, operands[1]));\n-\t  operands[1] = newreg;\n-\t}\n-\n-      operands[1] = force_reg (SFmode, operands[1]);\n-    }\n-\n-  if (CONSTANT_P (operands[1]) && TARGET_HARD_FLOAT\n-      && ! easy_fp_constant (operands[1], SFmode))\n-    {\n-      operands[1] = force_const_mem (SFmode, operands[1]);\n-      if (! memory_address_p (SFmode, XEXP (operands[1], 0))\n-\t  && ! reload_in_progress)\n-\toperands[1] = change_address (operands[1], SFmode,\n-\t\t\t\t      XEXP (operands[1], 0));\n-    }\n-}\")\n+  \"{ rs6000_emit_move (operands[0], operands[1], SFmode); DONE; }\")\n \n (define_split\n   [(set (match_operand:SF 0 \"gpc_reg_operand\" \"\")\n@@ -7831,20 +7645,7 @@\n   [(set (match_operand:DF 0 \"nonimmediate_operand\" \"\")\n \t(match_operand:DF 1 \"any_operand\" \"\"))]\n   \"\"\n-  \"\n-{\n-  if (GET_CODE (operands[0]) != REG)\n-    operands[1] = force_reg (DFmode, operands[1]);\n-\n-  if (CONSTANT_P (operands[1]) && ! easy_fp_constant (operands[1], DFmode))\n-    {\n-      operands[1] = force_const_mem (DFmode, operands[1]);\n-      if (! memory_address_p (DFmode, XEXP (operands[1], 0))\n-\t  && ! reload_in_progress)\n-\toperands[1] = change_address (operands[1], DFmode,\n-\t\t\t\t      XEXP (operands[1], 0));\n-    }\n-}\")\n+  \"{ rs6000_emit_move (operands[0], operands[1], DFmode); DONE; }\")\n \n (define_split\n   [(set (match_operand:DF 0 \"gpc_reg_operand\" \"\")\n@@ -8100,87 +7901,7 @@\n   [(set (match_operand:DI 0 \"general_operand\" \"\")\n \t(match_operand:DI 1 \"any_operand\" \"\"))]\n   \"\"\n-  \"\n-{\n-  if (! no_new_pseudos && GET_CODE (operands[0]) != REG)\n-    operands[1] = force_reg (DImode, operands[1]);\n-\n-  /* Convert a move of a CONST_DOUBLE into a CONST_INT\n-     only if sign-extended lower-half for 32-bit host.  */\n-  if (GET_CODE (operands[1]) == CONST_DOUBLE\n-#if HOST_BITS_PER_WIDE_INT == 32\n-      && ((CONST_DOUBLE_HIGH (operands[1]) == 0\n-\t   && (CONST_DOUBLE_LOW (operands[1]) & 0x80000000) == 0)\n-\t  || (CONST_DOUBLE_HIGH (operands[1]) == (HOST_WIDE_INT) 0xffffffff\n-\t      && (CONST_DOUBLE_LOW (operands[1]) & 0x80000000) != 0))\n-#endif\n-\t )\n-    operands[1] = GEN_INT (CONST_DOUBLE_LOW (operands[1]));\n-\n-  /* Only a tiny bit of handling for CONSTANT_P_RTX is necessary.  */\n-  if (GET_CODE (operands[1]) == CONSTANT_P_RTX)\n-    {\n-      emit_insn (gen_rtx_SET (VOIDmode, operands[0], operands[1]));\n-      DONE;\n-    }\n-\n-  if (TARGET_64BIT\n-      && CONSTANT_P (operands[1])\n-#if HOST_BITS_PER_WIDE_INT == 32\n-      && GET_CODE (operands[1]) != CONST_INT\n-#endif\n-      && ! easy_fp_constant (operands[1], DImode)\n-      && ! LEGITIMATE_CONSTANT_POOL_ADDRESS_P (operands[1])\n-      && ! TOC_RELATIVE_EXPR_P (operands[1]))\n-    {\n-      /* Emit a USE operation so that the constant isn't deleted if\n-\t expensive optimizations are turned on because nobody\n-\t references it.  This should only be done for operands that\n-\t contain SYMBOL_REFs with CONSTANT_POOL_ADDRESS_P set.\n-\t This should not be done for operands that contain LABEL_REFs.\n-\t For now, we just handle the obvious case.  */\n-      if (GET_CODE (operands[1]) != LABEL_REF)\n-\temit_insn (gen_rtx_USE (VOIDmode, operands[1]));\n-\n-      /* If we are to limit the number of things we put in the TOC and\n-\t this is a symbol plus a constant we can add in one insn,\n-\t just put the symbol in the TOC and add the constant.  Don't do\n-\t this if reload is in progress.  */\n-      if (GET_CODE (operands[1]) == CONST\n-\t  && TARGET_NO_SUM_IN_TOC && ! reload_in_progress\n-\t  && GET_CODE (XEXP (operands[1], 0)) == PLUS\n-\t  && add_operand (XEXP (XEXP (operands[1], 0), 1), DImode)\n-\t  && (GET_CODE (XEXP (XEXP (operands[1], 0), 0)) == LABEL_REF\n-\t      || GET_CODE (XEXP (XEXP (operands[1], 0), 0)) == SYMBOL_REF)\n-\t  && ! side_effects_p (operands[0]))\n-\t{\n-\t  rtx sym = force_const_mem (DImode, XEXP (XEXP (operands[1], 0), 0));\n-\t  rtx other = XEXP (XEXP (operands[1], 0), 1);\n-\n-\t  emit_insn (gen_adddi3 (operands[0], force_reg (DImode, sym), other));\n-\t  DONE;\n-\t}\n-\n-      operands[1] = force_const_mem (DImode, operands[1]);\n-\n-      if (TARGET_TOC \n-\t  && CONSTANT_POOL_EXPR_P (XEXP (operands[1], 0))\n-\t  && ASM_OUTPUT_SPECIAL_POOL_ENTRY_P (get_pool_constant (\n-\t\tXEXP (operands[1], 0))))\n-\t{\n-\t  operands[1] = gen_rtx_MEM (DImode,\n-\t\t\t     create_TOC_reference (XEXP (operands[1], 0)));\n-\n-\t  MEM_ALIAS_SET (operands[1]) = get_TOC_alias_set ();\t\n-\t  RTX_UNCHANGING_P (operands[1]) = 1;\n-\t}\t\n-\n-      if (! memory_address_p (DImode, XEXP (operands[1], 0))\n-\t  && ! reload_in_progress)\n-\toperands[1] = change_address (operands[1], DImode,\n-\t\t\t\t      XEXP (operands[1], 0));\n-    }\n-}\")\n+  \"{ rs6000_emit_move (operands[0], operands[1], DImode); DONE; }\")\n \n (define_insn \"*movdi_internal32\"\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,r,m,f,f,m,r,r,r,r,r\")\n@@ -8526,23 +8247,7 @@ operands[2] = GEN_INT (INTVAL (operands[1]) >> 32);\n \t\t   (match_operand:TI 1 \"general_operand\" \"\"))\n \t      (clobber (scratch:SI))])]\n   \"TARGET_STRING || TARGET_POWERPC64\"\n-  \"\n-{\n-  if (GET_CODE (operands[0]) == MEM)\n-    operands[1] = force_reg (TImode, operands[1]);\n-\n-  if (GET_CODE (operands[0]) == MEM\n-      && GET_CODE (XEXP (operands[0], 0)) != REG\n-      && ! reload_in_progress)\n-    operands[0] = change_address (operands[0], TImode,\n-\t\t\t\t  copy_addr_to_reg (XEXP (operands[0], 0)));\n-\n-  if (GET_CODE (operands[1]) == MEM\n-      && GET_CODE (XEXP (operands[1], 0)) != REG\n-      && ! reload_in_progress)\n-    operands[1] = change_address (operands[1], TImode,\n-\t\t\t\t  copy_addr_to_reg (XEXP (operands[1], 0)));\n-}\")\n+  \"{ rs6000_emit_move (operands[0], operands[1], TImode); DONE; }\")\n \n ;; We say that MQ is clobbered in the last alternative because the first\n ;; alternative would never get used otherwise since it would need a reload"}]}