{"sha": "46e43d2b55f6d0e54c564b38e73f306f63a66f9e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDZlNDNkMmI1NWY2ZDBlNTRjNTY0YjM4ZTczZjMwNmY2M2E2NmY5ZQ==", "commit": {"author": {"name": "Anatoly Sokolov", "email": "aesok@post.ru", "date": "2011-04-30T11:17:56Z"}, "committer": {"name": "Anatoly Sokolov", "email": "aesok@gcc.gnu.org", "date": "2011-04-30T11:17:56Z"}, "message": "sparc.h (PRINT_OPERAND, [...]): Remove.\n\n\t* config/sparc/sparc.h (PRINT_OPERAND, PRINT_OPERAND_ADDRESS,\n\tPRINT_OPERAND_PUNCT_VALID_P): Remove.\n\t* config/sparc/sparc-protos.h (print_operand): Remove declaration.\n\t* config/sparc/sparc.c (TARGET_PRINT_OPERAND_PUNCT_VALID_P,\n\tTARGET_PRINT_OPERAND, TARGET_PRINT_OPERAND_ADDRESS): Define.\n\t(print_operand): Rename to...\n\t(sparc_print_operand): ...this. Make static. Adjust\n\tsparc_print_operand function call.\n\t(sparc_print_operand_punct_valid_p, sparc_print_operand_address): New\n\tfunctions.\n\nFrom-SVN: r173212", "tree": {"sha": "0abcd2da3fcd3da3bc568d5ec9018de78efd2bdd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0abcd2da3fcd3da3bc568d5ec9018de78efd2bdd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/46e43d2b55f6d0e54c564b38e73f306f63a66f9e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46e43d2b55f6d0e54c564b38e73f306f63a66f9e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/46e43d2b55f6d0e54c564b38e73f306f63a66f9e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46e43d2b55f6d0e54c564b38e73f306f63a66f9e/comments", "author": null, "committer": null, "parents": [{"sha": "ecb62563676df6c02822c878077f64a552a64df8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ecb62563676df6c02822c878077f64a552a64df8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ecb62563676df6c02822c878077f64a552a64df8"}], "stats": {"total": 221, "additions": 127, "deletions": 94}, "files": [{"sha": "8581cc11c78a9fa45d5f67cc9ee1ffb19d6da0e9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46e43d2b55f6d0e54c564b38e73f306f63a66f9e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46e43d2b55f6d0e54c564b38e73f306f63a66f9e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=46e43d2b55f6d0e54c564b38e73f306f63a66f9e", "patch": "@@ -1,3 +1,16 @@\n+2011-04-30  Anatoly Sokolov  <aesok@post.ru>\n+\n+\t* config/sparc/sparc.h (PRINT_OPERAND, PRINT_OPERAND_ADDRESS,\n+\tPRINT_OPERAND_PUNCT_VALID_P): Remove.\n+\t* config/sparc/sparc-protos.h (print_operand): Remove declaration.\n+\t* config/sparc/sparc.c (TARGET_PRINT_OPERAND_PUNCT_VALID_P,\n+\tTARGET_PRINT_OPERAND, TARGET_PRINT_OPERAND_ADDRESS): Define.\n+\t(print_operand): Rename to...\n+\t(sparc_print_operand): ...this. Make static. Adjust\n+\tsparc_print_operand function call.\n+\t(sparc_print_operand_punct_valid_p, sparc_print_operand_address): New\n+\tfunctions.\n+\n 2011-04-30  Jan Hubicka  <jh@suse.cz>\n \n \tPR middle-end/48752 "}, {"sha": "c1bbab7e5b6623bc537ded41f6e8c96b0b9c0c4f", "filename": "gcc/config/sparc/sparc-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46e43d2b55f6d0e54c564b38e73f306f63a66f9e/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46e43d2b55f6d0e54c564b38e73f306f63a66f9e/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc-protos.h?ref=46e43d2b55f6d0e54c564b38e73f306f63a66f9e", "patch": "@@ -75,7 +75,6 @@ extern const char *output_v9branch (rtx, rtx, int, int, int, int, rtx);\n extern const char *output_probe_stack_range (rtx, rtx);\n extern bool emit_scc_insn (rtx []);\n extern void emit_conditional_branch_insn (rtx []);\n-extern void print_operand (FILE *, rtx, int);\n extern int mems_ok_for_ldd_peep (rtx, rtx, rtx);\n extern int arith_double_4096_operand (rtx, enum machine_mode);\n extern int arith_4096_operand (rtx, enum machine_mode);"}, {"sha": "2abfdf4a6bdbfd3ee83c7bd16ed98f943600d778", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 114, "deletions": 4, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46e43d2b55f6d0e54c564b38e73f306f63a66f9e/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46e43d2b55f6d0e54c564b38e73f306f63a66f9e/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=46e43d2b55f6d0e54c564b38e73f306f63a66f9e", "patch": "@@ -469,6 +469,9 @@ static const char *sparc_mangle_type (const_tree);\n static void sparc_trampoline_init (rtx, tree, rtx);\n static enum machine_mode sparc_preferred_simd_mode (enum machine_mode);\n static reg_class_t sparc_preferred_reload_class (rtx x, reg_class_t rclass);\n+static bool sparc_print_operand_punct_valid_p (unsigned char);\n+static void sparc_print_operand (FILE *, rtx, int);\n+static void sparc_print_operand_address (FILE *, rtx);\n \f\n #ifdef SUBTARGET_ATTRIBUTE_TABLE\n /* Table of valid machine attributes.  */\n@@ -667,6 +670,13 @@ static const struct default_options sparc_option_optimization_table[] =\n #undef TARGET_TRAMPOLINE_INIT\n #define TARGET_TRAMPOLINE_INIT sparc_trampoline_init\n \n+#undef TARGET_PRINT_OPERAND_PUNCT_VALID_P\n+#define TARGET_PRINT_OPERAND_PUNCT_VALID_P sparc_print_operand_punct_valid_p\n+#undef TARGET_PRINT_OPERAND\n+#define TARGET_PRINT_OPERAND sparc_print_operand\n+#undef TARGET_PRINT_OPERAND_ADDRESS\n+#define TARGET_PRINT_OPERAND_ADDRESS sparc_print_operand_address\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \n /* Validate and override various options, and do some machine dependent\n@@ -7330,12 +7340,29 @@ memory_ok_for_ldd (rtx op)\n   return 1;\n }\n \f\n-/* Print operand X (an rtx) in assembler syntax to file FILE.\n+/* Implement TARGET_PRINT_OPERAND_PUNCT_VALID_P.  */\n+\n+static bool\n+sparc_print_operand_punct_valid_p (unsigned char code)\n+{\n+  if (code == '#'\n+      || code == '*'\n+      || code == '('\n+      || code == ')'\n+      || code == '_'\n+      || code == '&')\n+    return true;\n+\n+  return false;\n+}\n+\n+/* Implement TARGET_PRINT_OPERAND.\n+   Print operand X (an rtx) in assembler syntax to file FILE.\n    CODE is a letter or dot (`z' in `%z0') or 0 if no letter was specified.\n    For `%' followed by punctuation, CODE is the punctuation and X is null.  */\n \n-void\n-print_operand (FILE *file, rtx x, int code)\n+static void\n+sparc_print_operand (FILE *file, rtx x, int code)\n {\n   switch (code)\n     {\n@@ -7613,7 +7640,7 @@ print_operand (FILE *file, rtx x, int code)\n     }\n   else if (GET_CODE (x) == LO_SUM)\n     {\n-      print_operand (file, XEXP (x, 0), 0);\n+      sparc_print_operand (file, XEXP (x, 0), 0);\n       if (TARGET_CM_MEDMID)\n \tfputs (\"+%l44(\", file);\n       else\n@@ -7637,6 +7664,89 @@ print_operand (FILE *file, rtx x, int code)\n     output_operand_lossage (\"floating point constant not a valid immediate operand\");\n   else { output_addr_const (file, x); }\n }\n+\n+/* Implement TARGET_PRINT_OPERAND_ADDRESS.  */\n+\n+static void\n+sparc_print_operand_address (FILE *file, rtx x)\n+{\n+  register rtx base, index = 0;\n+  int offset = 0;\n+  register rtx addr = x;\n+\n+  if (REG_P (addr))\n+    fputs (reg_names[REGNO (addr)], file);\n+  else if (GET_CODE (addr) == PLUS)\n+    {\n+      if (CONST_INT_P (XEXP (addr, 0)))\n+\toffset = INTVAL (XEXP (addr, 0)), base = XEXP (addr, 1);\n+      else if (CONST_INT_P (XEXP (addr, 1)))\n+\toffset = INTVAL (XEXP (addr, 1)), base = XEXP (addr, 0);\n+      else\n+\tbase = XEXP (addr, 0), index = XEXP (addr, 1);\n+      if (GET_CODE (base) == LO_SUM)\n+\t{\n+\t  gcc_assert (USE_AS_OFFSETABLE_LO10\n+\t\t      && TARGET_ARCH64\n+\t\t      && ! TARGET_CM_MEDMID);\n+\t  output_operand (XEXP (base, 0), 0);\n+\t  fputs (\"+%lo(\", file);\n+\t  output_address (XEXP (base, 1));\n+\t  fprintf (file, \")+%d\", offset);\n+\t}\n+      else\n+\t{\n+\t  fputs (reg_names[REGNO (base)], file);\n+\t  if (index == 0)\n+\t    fprintf (file, \"%+d\", offset);\n+\t  else if (REG_P (index))\n+\t    fprintf (file, \"+%s\", reg_names[REGNO (index)]);\n+\t  else if (GET_CODE (index) == SYMBOL_REF\n+\t\t   || GET_CODE (index) == LABEL_REF\n+\t\t   || GET_CODE (index) == CONST)\n+\t    fputc ('+', file), output_addr_const (file, index);\n+\t  else gcc_unreachable ();\n+\t}\n+    }\n+  else if (GET_CODE (addr) == MINUS\n+\t   && GET_CODE (XEXP (addr, 1)) == LABEL_REF)\n+    {\n+      output_addr_const (file, XEXP (addr, 0));\n+      fputs (\"-(\", file);\n+      output_addr_const (file, XEXP (addr, 1));\n+      fputs (\"-.)\", file);\n+    }\n+  else if (GET_CODE (addr) == LO_SUM)\n+    {\n+      output_operand (XEXP (addr, 0), 0);\n+      if (TARGET_CM_MEDMID)\n+        fputs (\"+%l44(\", file);\n+      else\n+        fputs (\"+%lo(\", file);\n+      output_address (XEXP (addr, 1));\n+      fputc (')', file);\n+    }\n+  else if (flag_pic\n+\t   && GET_CODE (addr) == CONST\n+\t   && GET_CODE (XEXP (addr, 0)) == MINUS\n+\t   && GET_CODE (XEXP (XEXP (addr, 0), 1)) == CONST\n+\t   && GET_CODE (XEXP (XEXP (XEXP (addr, 0), 1), 0)) == MINUS\n+\t   && XEXP (XEXP (XEXP (XEXP (addr, 0), 1), 0), 1) == pc_rtx)\n+    {\n+      addr = XEXP (addr, 0);\n+      output_addr_const (file, XEXP (addr, 0));\n+      /* Group the args of the second CONST in parenthesis.  */\n+      fputs (\"-(\", file);\n+      /* Skip past the second CONST--it does nothing for us.  */\n+      output_addr_const (file, XEXP (XEXP (addr, 1), 0));\n+      /* Close the parenthesis.  */\n+      fputc (')', file);\n+    }\n+  else\n+    {\n+      output_addr_const (file, addr);\n+    }\n+}\n \f\n /* Target hook for assembling integer objects.  The sparc version has\n    special handling for aligned DI-mode objects.  */"}, {"sha": "7039fb048b082faadcd0867f4f8294b9e97596d0", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 0, "deletions": 89, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/46e43d2b55f6d0e54c564b38e73f306f63a66f9e/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/46e43d2b55f6d0e54c564b38e73f306f63a66f9e/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=46e43d2b55f6d0e54c564b38e73f306f63a66f9e", "patch": "@@ -1916,95 +1916,6 @@ extern int sparc_indent_opcode;\n       }\t\t\t\t\t\\\n   } while (0)\n \n-#define PRINT_OPERAND_PUNCT_VALID_P(CHAR) \\\n-  ((CHAR) == '#' || (CHAR) == '*' || (CHAR) == '('\t\t\\\n-   || (CHAR) == ')' || (CHAR) == '_' || (CHAR) == '&')\n-\n-/* Print operand X (an rtx) in assembler syntax to file FILE.\n-   CODE is a letter or dot (`z' in `%z0') or 0 if no letter was specified.\n-   For `%' followed by punctuation, CODE is the punctuation and X is null.  */\n-\n-#define PRINT_OPERAND(FILE, X, CODE) print_operand (FILE, X, CODE)\n-\n-/* Print a memory address as an operand to reference that memory location.  */\n-\n-#define PRINT_OPERAND_ADDRESS(FILE, ADDR)  \\\n-{ register rtx base, index = 0;\t\t\t\t\t\\\n-  int offset = 0;\t\t\t\t\t\t\\\n-  register rtx addr = ADDR;\t\t\t\t\t\\\n-  if (GET_CODE (addr) == REG)\t\t\t\t\t\\\n-    fputs (reg_names[REGNO (addr)], FILE);\t\t\t\\\n-  else if (GET_CODE (addr) == PLUS)\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      if (GET_CODE (XEXP (addr, 0)) == CONST_INT)\t\t\\\n-\toffset = INTVAL (XEXP (addr, 0)), base = XEXP (addr, 1);\\\n-      else if (GET_CODE (XEXP (addr, 1)) == CONST_INT)\t\t\\\n-\toffset = INTVAL (XEXP (addr, 1)), base = XEXP (addr, 0);\\\n-      else\t\t\t\t\t\t\t\\\n-\tbase = XEXP (addr, 0), index = XEXP (addr, 1);\t\t\\\n-      if (GET_CODE (base) == LO_SUM)\t\t\t\t\\\n-\t{\t\t\t\t\t\t\t\\\n-\t  gcc_assert (USE_AS_OFFSETABLE_LO10\t\t\t\\\n-\t      \t      && TARGET_ARCH64\t\t\t\t\\\n-\t\t      && ! TARGET_CM_MEDMID);\t\t\t\\\n-\t  output_operand (XEXP (base, 0), 0);\t\t\t\\\n-\t  fputs (\"+%lo(\", FILE);\t\t\t\t\\\n-\t  output_address (XEXP (base, 1));\t\t\t\\\n-\t  fprintf (FILE, \")+%d\", offset);\t\t\t\\\n-\t}\t\t\t\t\t\t\t\\\n-      else\t\t\t\t\t\t\t\\\n-\t{\t\t\t\t\t\t\t\\\n-\t  fputs (reg_names[REGNO (base)], FILE);\t\t\\\n-\t  if (index == 0)\t\t\t\t\t\\\n-\t    fprintf (FILE, \"%+d\", offset);\t\t\t\\\n-\t  else if (GET_CODE (index) == REG)\t\t\t\\\n-\t    fprintf (FILE, \"+%s\", reg_names[REGNO (index)]);\t\\\n-\t  else if (GET_CODE (index) == SYMBOL_REF\t\t\\\n-\t\t   || GET_CODE (index) == LABEL_REF\t\t\\\n-\t\t   || GET_CODE (index) == CONST)\t\t\\\n-\t    fputc ('+', FILE), output_addr_const (FILE, index);\t\\\n-\t  else gcc_unreachable ();\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-  else if (GET_CODE (addr) == MINUS\t\t\t\t\\\n-\t   && GET_CODE (XEXP (addr, 1)) == LABEL_REF)\t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      output_addr_const (FILE, XEXP (addr, 0));\t\t\t\\\n-      fputs (\"-(\", FILE);\t\t\t\t\t\\\n-      output_addr_const (FILE, XEXP (addr, 1));\t\t\t\\\n-      fputs (\"-.)\", FILE);\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-  else if (GET_CODE (addr) == LO_SUM)\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      output_operand (XEXP (addr, 0), 0);\t\t\t\\\n-      if (TARGET_CM_MEDMID)\t\t\t\t\t\\\n-        fputs (\"+%l44(\", FILE);\t\t\t\t\t\\\n-      else\t\t\t\t\t\t\t\\\n-        fputs (\"+%lo(\", FILE);\t\t\t\t\t\\\n-      output_address (XEXP (addr, 1));\t\t\t\t\\\n-      fputc (')', FILE);\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-  else if (flag_pic && GET_CODE (addr) == CONST\t\t\t\\\n-\t   && GET_CODE (XEXP (addr, 0)) == MINUS\t\t\\\n-\t   && GET_CODE (XEXP (XEXP (addr, 0), 1)) == CONST\t\\\n-\t   && GET_CODE (XEXP (XEXP (XEXP (addr, 0), 1), 0)) == MINUS\t\\\n-\t   && XEXP (XEXP (XEXP (XEXP (addr, 0), 1), 0), 1) == pc_rtx)\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      addr = XEXP (addr, 0);\t\t\t\t\t\\\n-      output_addr_const (FILE, XEXP (addr, 0));\t\t\t\\\n-      /* Group the args of the second CONST in parenthesis.  */\t\\\n-      fputs (\"-(\", FILE);\t\t\t\t\t\\\n-      /* Skip past the second CONST--it does nothing for us.  */\\\n-      output_addr_const (FILE, XEXP (XEXP (addr, 1), 0));\t\\\n-      /* Close the parenthesis.  */\t\t\t\t\\\n-      fputc (')', FILE);\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-  else\t\t\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      output_addr_const (FILE, addr);\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-}\n-\n /* TLS support defaulting to original Sun flavor.  GNU extensions\n    must be activated in separate configuration files.  */\n #ifdef HAVE_AS_TLS"}]}