{"sha": "3ac8781c36d6f1ce612e5233dc9254d2d8cee5ca", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2FjODc4MWMzNmQ2ZjFjZTYxMmU1MjMzZGM5MjU0ZDJkOGNlZTVjYQ==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2012-05-10T07:58:27Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2012-05-10T07:58:27Z"}, "message": "cuintp.c (UI_From_gnu): Remove TYPE_IS_SIZETYPE use.\n\n2012-05-10  Richard Guenther  <rguenther@suse.de>\n\n\tada/\n\t* gcc-interface/cuintp.c (UI_From_gnu): Remove TYPE_IS_SIZETYPE use.\n\n\tc-family/\n\t* c-common.c (c_sizeof_or_alignof_type): Remove assert and\n\tadjust commentary about TYPE_IS_SIZETYPE types.\n\n\t* tree.h (TYPE_IS_SIZETYPE): Remove.\n\t* fold-const.c (int_const_binop_1): Remove TYPE_IS_SIZETYPE use.\n\t(extract_muldiv_1): Likewise.\n\t* gimple.c (gtc_visit): Likewise.\n\t(gimple_types_compatible_p): Likewise.\n\t(iterative_hash_canonical_type): Likewise.\n\t(gimple_canonical_types_compatible_p): Likewise.\n\t* gimplify.c (gimplify_one_sizepos): Likewise.\n\t* print-tree.c (print_node): Likewise.\n\t* stor-layout.c (initialize_sizetypes): Do not set TYPE_IS_SIZETYPE.\n\nFrom-SVN: r187363", "tree": {"sha": "1b55fc7996845f84a927496e5f0f6f7aa9d75d19", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1b55fc7996845f84a927496e5f0f6f7aa9d75d19"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3ac8781c36d6f1ce612e5233dc9254d2d8cee5ca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ac8781c36d6f1ce612e5233dc9254d2d8cee5ca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3ac8781c36d6f1ce612e5233dc9254d2d8cee5ca", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ac8781c36d6f1ce612e5233dc9254d2d8cee5ca/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "26c7244823b6d5c3c0cdc86cf411e6e6860ddb16", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/26c7244823b6d5c3c0cdc86cf411e6e6860ddb16", "html_url": "https://github.com/Rust-GCC/gccrs/commit/26c7244823b6d5c3c0cdc86cf411e6e6860ddb16"}], "stats": {"total": 115, "additions": 36, "deletions": 79}, "files": [{"sha": "afe2c63f6d931d62f6afcb086f5a5ebe61b07bb5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ac8781c36d6f1ce612e5233dc9254d2d8cee5ca/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ac8781c36d6f1ce612e5233dc9254d2d8cee5ca/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3ac8781c36d6f1ce612e5233dc9254d2d8cee5ca", "patch": "@@ -1,3 +1,16 @@\n+2012-05-10  Richard Guenther  <rguenther@suse.de>\n+\n+\t* tree.h (TYPE_IS_SIZETYPE): Remove.\n+\t* fold-const.c (int_const_binop_1): Remove TYPE_IS_SIZETYPE use.\n+\t(extract_muldiv_1): Likewise.\n+\t* gimple.c (gtc_visit): Likewise.\n+\t(gimple_types_compatible_p): Likewise.\n+\t(iterative_hash_canonical_type): Likewise.\n+\t(gimple_canonical_types_compatible_p): Likewise.\n+\t* gimplify.c (gimplify_one_sizepos): Likewise.\n+\t* print-tree.c (print_node): Likewise.\n+\t* stor-layout.c (initialize_sizetypes): Do not set TYPE_IS_SIZETYPE.\n+\n 2012-05-09  Uros Bizjak  <ubizjak@gmail.com>\n \n \tPR target/52908"}, {"sha": "d24810fed89235ed81b4c0fea17aa32ea35948da", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ac8781c36d6f1ce612e5233dc9254d2d8cee5ca/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ac8781c36d6f1ce612e5233dc9254d2d8cee5ca/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=3ac8781c36d6f1ce612e5233dc9254d2d8cee5ca", "patch": "@@ -1,3 +1,7 @@\n+2012-05-10  Richard Guenther  <rguenther@suse.de>\n+\n+\t* gcc-interface/cuintp.c (UI_From_gnu): Remove TYPE_IS_SIZETYPE use.\n+\n 2012-05-06  Tristan Gingold  <gingold@adacore.com>\n \n \t* gcc-interface/trans.c (gigi): Decorate reraise_zcx_decl."}, {"sha": "60cb26f65e7e6905a26f5241e9084a377e5dbd89", "filename": "gcc/ada/gcc-interface/cuintp.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ac8781c36d6f1ce612e5233dc9254d2d8cee5ca/gcc%2Fada%2Fgcc-interface%2Fcuintp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ac8781c36d6f1ce612e5233dc9254d2d8cee5ca/gcc%2Fada%2Fgcc-interface%2Fcuintp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fcuintp.c?ref=3ac8781c36d6f1ce612e5233dc9254d2d8cee5ca", "patch": "@@ -177,10 +177,7 @@ UI_From_gnu (tree Input)\n      in a signed 64-bit integer.  */\n   if (host_integerp (Input, 0))\n     return UI_From_Int (TREE_INT_CST_LOW (Input));\n-  else if (TREE_INT_CST_HIGH (Input) < 0\n-\t   && TYPE_UNSIGNED (gnu_type)\n-\t   && !(TREE_CODE (gnu_type) == INTEGER_TYPE\n-\t\t&& TYPE_IS_SIZETYPE (gnu_type)))\n+  else if (TREE_INT_CST_HIGH (Input) < 0 && TYPE_UNSIGNED (gnu_type))\n     return No_Uint;\n #endif\n "}, {"sha": "f0e6147e3c5c18e361839a3b33845f04cad1b502", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ac8781c36d6f1ce612e5233dc9254d2d8cee5ca/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ac8781c36d6f1ce612e5233dc9254d2d8cee5ca/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=3ac8781c36d6f1ce612e5233dc9254d2d8cee5ca", "patch": "@@ -1,3 +1,8 @@\n+2012-05-10  Richard Guenther  <rguenther@suse.de>\n+\n+\t* c-common.c (c_sizeof_or_alignof_type): Remove assert and\n+\tadjust commentary about TYPE_IS_SIZETYPE types.\n+\n 2012-05-09  Manuel L\u00f3pez-Ib\u00e1\u00f1ez  <manu@gcc.gnu.org>\n \n \tPR c++/53261"}, {"sha": "a5ddbee63c896fa2fe29e478e37eb45667216478", "filename": "gcc/c-family/c-common.c", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ac8781c36d6f1ce612e5233dc9254d2d8cee5ca/gcc%2Fc-family%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ac8781c36d6f1ce612e5233dc9254d2d8cee5ca/gcc%2Fc-family%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.c?ref=3ac8781c36d6f1ce612e5233dc9254d2d8cee5ca", "patch": "@@ -4539,12 +4539,10 @@ c_sizeof_or_alignof_type (location_t loc,\n \tvalue = size_int (TYPE_ALIGN_UNIT (type));\n     }\n \n-  /* VALUE will have an integer type with TYPE_IS_SIZETYPE set.\n-     TYPE_IS_SIZETYPE means that certain things (like overflow) will\n-     never happen.  However, this node should really have type\n-     `size_t', which is just a typedef for an ordinary integer type.  */\n+  /* VALUE will have the middle-end integer type sizetype.\n+     However, we should really return a value of type `size_t',\n+     which is just a typedef for an ordinary integer type.  */\n   value = fold_convert_loc (loc, size_type_node, value);\n-  gcc_assert (!TYPE_IS_SIZETYPE (TREE_TYPE (value)));\n \n   return value;\n }"}, {"sha": "c68db739ae9dba28841558cdc4e1900ad4eb2368", "filename": "gcc/fold-const.c", "status": "modified", "additions": 5, "deletions": 21, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ac8781c36d6f1ce612e5233dc9254d2d8cee5ca/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ac8781c36d6f1ce612e5233dc9254d2d8cee5ca/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=3ac8781c36d6f1ce612e5233dc9254d2d8cee5ca", "patch": "@@ -940,8 +940,6 @@ int_const_binop_1 (enum tree_code code, const_tree arg1, const_tree arg2,\n   tree t;\n   tree type = TREE_TYPE (arg1);\n   bool uns = TYPE_UNSIGNED (type);\n-  bool is_sizetype\n-    = (TREE_CODE (type) == INTEGER_TYPE && TYPE_IS_SIZETYPE (type));\n   bool overflow = false;\n \n   op1 = tree_to_double_int (arg1);\n@@ -1077,7 +1075,7 @@ int_const_binop_1 (enum tree_code code, const_tree arg1, const_tree arg2,\n     }\n \n   t = force_fit_type_double (TREE_TYPE (arg1), res, overflowable,\n-\t\t\t     ((!uns || is_sizetype) && overflow)\n+\t\t\t     (!uns && overflow)\n \t\t\t     | TREE_OVERFLOW (arg1) | TREE_OVERFLOW (arg2));\n \n   return t;\n@@ -5639,8 +5637,6 @@ extract_muldiv_1 (tree t, tree c, enum tree_code code, tree wide_type,\n \t  /* ... and has wrapping overflow, and its type is smaller\n \t     than ctype, then we cannot pass through as widening.  */\n \t  && ((TYPE_OVERFLOW_WRAPS (TREE_TYPE (op0))\n-\t       && ! (TREE_CODE (TREE_TYPE (op0)) == INTEGER_TYPE\n-\t\t     && TYPE_IS_SIZETYPE (TREE_TYPE (op0)))\n \t       && (TYPE_PRECISION (ctype)\n \t           > TYPE_PRECISION (TREE_TYPE (op0))))\n \t      /* ... or this is a truncation (t is narrower than op0),\n@@ -5818,7 +5814,6 @@ extract_muldiv_1 (tree t, tree c, enum tree_code code, tree wide_type,\n \t the operation since it will change the result if the original\n \t computation overflowed.  */\n       if (TYPE_UNSIGNED (ctype)\n-\t  && ! (TREE_CODE (ctype) == INTEGER_TYPE && TYPE_IS_SIZETYPE (ctype))\n \t  && ctype != type)\n \tbreak;\n \n@@ -5844,14 +5839,8 @@ extract_muldiv_1 (tree t, tree c, enum tree_code code, tree wide_type,\n \t (C * 8) % 4 since we know that's zero.  */\n       if ((code == TRUNC_MOD_EXPR || code == CEIL_MOD_EXPR\n \t   || code == FLOOR_MOD_EXPR || code == ROUND_MOD_EXPR)\n-\t  /* If the multiplication can overflow we cannot optimize this.\n-\t     ???  Until we can properly mark individual operations as\n-\t     not overflowing we need to treat sizetype special here as\n-\t     stor-layout relies on this opimization to make\n-\t     DECL_FIELD_BIT_OFFSET always a constant.  */\n-\t  && (TYPE_OVERFLOW_UNDEFINED (TREE_TYPE (t))\n-\t      || (TREE_CODE (TREE_TYPE (t)) == INTEGER_TYPE\n-\t\t  && TYPE_IS_SIZETYPE (TREE_TYPE (t))))\n+\t  /* If the multiplication can overflow we cannot optimize this.  */\n+\t  && TYPE_OVERFLOW_UNDEFINED (TREE_TYPE (t))\n \t  && TREE_CODE (TREE_OPERAND (t, 1)) == INTEGER_CST\n \t  && integer_zerop (const_binop (TRUNC_MOD_EXPR, op1, c)))\n \t{\n@@ -5893,16 +5882,11 @@ extract_muldiv_1 (tree t, tree c, enum tree_code code, tree wide_type,\n \t\t     (tree_to_double_int (c),\n \t\t      TYPE_PRECISION (ctype), TYPE_UNSIGNED (ctype)),\n \t\t   false, &overflow_p);\n-\t  overflow_p = (((!TYPE_UNSIGNED (ctype)\n-\t\t\t  || (TREE_CODE (ctype) == INTEGER_TYPE\n-\t\t\t      && TYPE_IS_SIZETYPE (ctype)))\n-\t\t\t && overflow_p)\n+\t  overflow_p = ((!TYPE_UNSIGNED (ctype) && overflow_p)\n \t\t\t| TREE_OVERFLOW (c) | TREE_OVERFLOW (op1));\n \t  if (!double_int_fits_to_tree_p (ctype, mul)\n \t      && ((TYPE_UNSIGNED (ctype) && tcode != MULT_EXPR)\n-\t\t  || !TYPE_UNSIGNED (ctype)\n-\t\t  || (TREE_CODE (ctype) == INTEGER_TYPE\n-\t\t      && TYPE_IS_SIZETYPE (ctype))))\n+\t\t  || !TYPE_UNSIGNED (ctype)))\n \t    overflow_p = 1;\n \t  if (!overflow_p)\n \t    return fold_build2 (tcode, ctype, fold_convert (ctype, op0),"}, {"sha": "79da12cde515dfcf27b5efdd6acb3856c8f95a50", "filename": "gcc/gimple.c", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ac8781c36d6f1ce612e5233dc9254d2d8cee5ca/gcc%2Fgimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ac8781c36d6f1ce612e5233dc9254d2d8cee5ca/gcc%2Fgimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.c?ref=3ac8781c36d6f1ce612e5233dc9254d2d8cee5ca", "patch": "@@ -3326,8 +3326,7 @@ gtc_visit (tree t1, tree t2,\n \treturn false;\n \n       if (TREE_CODE (t1) == INTEGER_TYPE\n-\t  && (TYPE_IS_SIZETYPE (t1) != TYPE_IS_SIZETYPE (t2)\n-\t      || TYPE_STRING_FLAG (t1) != TYPE_STRING_FLAG (t2)))\n+\t  && TYPE_STRING_FLAG (t1) != TYPE_STRING_FLAG (t2))\n \treturn false;\n \n       /* That's all we need to check for float and fixed-point types.  */\n@@ -3756,8 +3755,7 @@ gimple_types_compatible_p (tree t1, tree t2)\n \treturn false;\n \n       if (TREE_CODE (t1) == INTEGER_TYPE\n-\t  && (TYPE_IS_SIZETYPE (t1) != TYPE_IS_SIZETYPE (t2)\n-\t      || TYPE_STRING_FLAG (t1) != TYPE_STRING_FLAG (t2)))\n+\t  && TYPE_STRING_FLAG (t1) != TYPE_STRING_FLAG (t2))\n \treturn false;\n \n       /* That's all we need to check for float and fixed-point types.  */\n@@ -4206,10 +4204,7 @@ iterative_hash_canonical_type (tree type, hashval_t val)\n \n   /* For integer types hash the types min/max values and the string flag.  */\n   if (TREE_CODE (type) == INTEGER_TYPE)\n-    {\n-      v = iterative_hash_hashval_t (TYPE_STRING_FLAG (type), v);\n-      v = iterative_hash_hashval_t (TYPE_IS_SIZETYPE (type), v);\n-    }\n+    v = iterative_hash_hashval_t (TYPE_STRING_FLAG (type), v);\n \n   /* For array types hash their domain and the string flag.  */\n   if (TREE_CODE (type) == ARRAY_TYPE\n@@ -4425,8 +4420,7 @@ gimple_canonical_types_compatible_p (tree t1, tree t2)\n \treturn false;\n \n       if (TREE_CODE (t1) == INTEGER_TYPE\n-\t  && (TYPE_IS_SIZETYPE (t1) != TYPE_IS_SIZETYPE (t2)\n-\t      || TYPE_STRING_FLAG (t1) != TYPE_STRING_FLAG (t2)))\n+\t  && TYPE_STRING_FLAG (t1) != TYPE_STRING_FLAG (t2))\n \treturn false;\n \n       /* For canonical type comparisons we do not want to build SCCs"}, {"sha": "811fa221fec36a0c911468b6ea9f33e0d2977489", "filename": "gcc/gimplify.c", "status": "modified", "additions": 1, "deletions": 21, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ac8781c36d6f1ce612e5233dc9254d2d8cee5ca/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ac8781c36d6f1ce612e5233dc9254d2d8cee5ca/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=3ac8781c36d6f1ce612e5233dc9254d2d8cee5ca", "patch": "@@ -8098,7 +8098,7 @@ gimplify_type_sizes (tree type, gimple_seq *list_p)\n void\n gimplify_one_sizepos (tree *expr_p, gimple_seq *stmt_p)\n {\n-  tree type, expr = *expr_p;\n+  tree expr = *expr_p;\n \n   /* We don't do anything if the value isn't there, is constant, or contains\n      A PLACEHOLDER_EXPR.  We also don't want to do anything if it's already\n@@ -8110,30 +8110,10 @@ gimplify_one_sizepos (tree *expr_p, gimple_seq *stmt_p)\n       || CONTAINS_PLACEHOLDER_P (expr))\n     return;\n \n-  type = TREE_TYPE (expr);\n   *expr_p = unshare_expr (expr);\n \n   gimplify_expr (expr_p, stmt_p, NULL, is_gimple_val, fb_rvalue);\n   expr = *expr_p;\n-\n-  /* Verify that we've an exact type match with the original expression.\n-     In particular, we do not wish to drop a \"sizetype\" in favour of a\n-     type of similar dimensions.  We don't want to pollute the generic\n-     type-stripping code with this knowledge because it doesn't matter\n-     for the bulk of GENERIC/GIMPLE.  It only matters that TYPE_SIZE_UNIT\n-     and friends retain their \"sizetype-ness\".  */\n-  if (TREE_TYPE (expr) != type\n-      && TREE_CODE (type) == INTEGER_TYPE\n-      && TYPE_IS_SIZETYPE (type))\n-    {\n-      tree tmp;\n-      gimple stmt;\n-\n-      *expr_p = create_tmp_var (type, NULL);\n-      tmp = build1 (NOP_EXPR, type, expr);\n-      stmt = gimplify_assign (*expr_p, tmp, stmt_p);\n-      gimple_set_location (stmt, EXPR_LOC_OR_HERE (expr));\n-    }\n }\n \n /* Gimplify the body of statements of FNDECL and return a GIMPLE_BIND node"}, {"sha": "28f51b0635293fb4d71b9a7cfb7c42fce7ea615f", "filename": "gcc/print-tree.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ac8781c36d6f1ce612e5233dc9254d2d8cee5ca/gcc%2Fprint-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ac8781c36d6f1ce612e5233dc9254d2d8cee5ca/gcc%2Fprint-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-tree.c?ref=3ac8781c36d6f1ce612e5233dc9254d2d8cee5ca", "patch": "@@ -611,9 +611,6 @@ print_node (FILE *file, const char *prefix, tree node, int indent)\n \t   || code == QUAL_UNION_TYPE)\n \t  && TYPE_NO_FORCE_BLK (node))\n \tfputs (\" no-force-blk\", file);\n-      else if (code == INTEGER_TYPE\n-\t       && TYPE_IS_SIZETYPE (node))\n-\tfputs (\" sizetype\", file);\n \n       if (TYPE_STRING_FLAG (node))\n \tfputs (\" string-flag\", file);"}, {"sha": "842b506ab25180c7c2beeec8f8a3a8b2010931ae", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ac8781c36d6f1ce612e5233dc9254d2d8cee5ca/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ac8781c36d6f1ce612e5233dc9254d2d8cee5ca/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=3ac8781c36d6f1ce612e5233dc9254d2d8cee5ca", "patch": "@@ -2479,12 +2479,10 @@ initialize_sizetypes (void)\n   TYPE_NAME (sizetype) = get_identifier (\"sizetype\");\n   TYPE_PRECISION (sizetype) = precision;\n   TYPE_UNSIGNED (sizetype) = 1;\n-  TYPE_IS_SIZETYPE (sizetype) = 1;\n   bitsizetype = make_node (INTEGER_TYPE);\n   TYPE_NAME (bitsizetype) = get_identifier (\"bitsizetype\");\n   TYPE_PRECISION (bitsizetype) = bprecision;\n   TYPE_UNSIGNED (bitsizetype) = 1;\n-  TYPE_IS_SIZETYPE (bitsizetype) = 1;\n \n   /* Now layout both types manually.  */\n   SET_TYPE_MODE (sizetype, smallest_mode_for_size (precision, MODE_INT));\n@@ -2505,10 +2503,8 @@ initialize_sizetypes (void)\n   /* Create the signed variants of *sizetype.  */\n   ssizetype = make_signed_type (TYPE_PRECISION (sizetype));\n   TYPE_NAME (ssizetype) = get_identifier (\"ssizetype\");\n-  TYPE_IS_SIZETYPE (ssizetype) = 1;\n   sbitsizetype = make_signed_type (TYPE_PRECISION (bitsizetype));\n   TYPE_NAME (sbitsizetype) = get_identifier (\"sbitsizetype\");\n-  TYPE_IS_SIZETYPE (sbitsizetype) = 1;\n }\n \f\n /* TYPE is an integral type, i.e., an INTEGRAL_TYPE, ENUMERAL_TYPE"}, {"sha": "419d8f4e6389fc0f04165a7a8460c05ade30992f", "filename": "gcc/tree.h", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ac8781c36d6f1ce612e5233dc9254d2d8cee5ca/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ac8781c36d6f1ce612e5233dc9254d2d8cee5ca/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=3ac8781c36d6f1ce612e5233dc9254d2d8cee5ca", "patch": "@@ -2251,17 +2251,6 @@ extern enum machine_mode vector_type_mode (const_tree);\n #define TYPE_NO_FORCE_BLK(NODE) \\\n   (TYPE_CHECK (NODE)->type_common.no_force_blk_flag)\n \n-/* In an INTEGER_TYPE, it means the type represents a size.  We use\n-   this both for validity checking and to permit optimizations that\n-   are unsafe for other types.  Note that the C `size_t' type should\n-   *not* have this flag set.  The `size_t' type is simply a typedef\n-   for an ordinary integer type that happens to be the type of an\n-   expression returned by `sizeof'; `size_t' has no special\n-   properties.  Expressions whose type have TYPE_IS_SIZETYPE set are\n-   always actual sizes.  */\n-#define TYPE_IS_SIZETYPE(NODE) \\\n-  (INTEGER_TYPE_CHECK (NODE)->type_common.no_force_blk_flag)\n-\n /* Nonzero in a type considered volatile as a whole.  */\n #define TYPE_VOLATILE(NODE) (TYPE_CHECK (NODE)->base.volatile_flag)\n "}]}