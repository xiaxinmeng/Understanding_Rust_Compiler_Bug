{"sha": "3e4d04a1bad107f85a9e48e2f9df9ed672b0ab16", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2U0ZDA0YTFiYWQxMDdmODVhOWU0OGUyZjlkZjllZDY3MmIwYWIxNg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2000-12-20T18:16:47Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2000-12-20T18:16:47Z"}, "message": "cp-tree.h: Update declarations.\n\n        * cp-tree.h: Update declarations.\n        * decl.c (finish_case_label): Return the new stmt node.\n        * semantics.c (finish_goto_stmt): Likewise.\n        (finish_expr_stmt, finish_return_stmt): Likewise.\n        (finish_break_stmt, finish_continue_stmt): Likewise.\n        (finish_asm_stmt): Likewise.\n        * parse.y (already_scoped_stmt): Set STMT_LINENO.\n        (compstmt, implicitly_scoped_stmt, stmt): Likewise.\n        (simple_if, simple_stmt): Return the new stmt node.\n        (save_lineno): New.\n\nFrom-SVN: r38401", "tree": {"sha": "a5fdec6cc19e15989fad37d4eb8abfb04dcf9da7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a5fdec6cc19e15989fad37d4eb8abfb04dcf9da7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3e4d04a1bad107f85a9e48e2f9df9ed672b0ab16", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e4d04a1bad107f85a9e48e2f9df9ed672b0ab16", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3e4d04a1bad107f85a9e48e2f9df9ed672b0ab16", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e4d04a1bad107f85a9e48e2f9df9ed672b0ab16/comments", "author": null, "committer": null, "parents": [{"sha": "18e720b324e90c02d4631174885b66f67d8014f2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18e720b324e90c02d4631174885b66f67d8014f2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/18e720b324e90c02d4631174885b66f67d8014f2"}], "stats": {"total": 212, "additions": 129, "deletions": 83}, "files": [{"sha": "fc473fb09fbf82d62e53b31ee9f19b9667f387c2", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e4d04a1bad107f85a9e48e2f9df9ed672b0ab16/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e4d04a1bad107f85a9e48e2f9df9ed672b0ab16/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=3e4d04a1bad107f85a9e48e2f9df9ed672b0ab16", "patch": "@@ -1,3 +1,16 @@\n+2000-12-20  Richard Henderson  <rth@redhat.com>\n+\n+\t* cp-tree.h: Update declarations.\n+\t* decl.c (finish_case_label): Return the new stmt node.\n+\t* semantics.c (finish_goto_stmt): Likewise.\n+\t(finish_expr_stmt, finish_return_stmt): Likewise.\n+\t(finish_break_stmt, finish_continue_stmt): Likewise.\n+\t(finish_asm_stmt): Likewise.\n+\t* parse.y (already_scoped_stmt): Set STMT_LINENO.\n+\t(compstmt, implicitly_scoped_stmt, stmt): Likewise.\n+\t(simple_if, simple_stmt): Return the new stmt node.\n+\t(save_lineno): New.\n+\n 2000-12-18  Joseph S. Myers  <jsm28@cam.ac.uk>\n \n \t* cp-tree.h: Don't declare warn_long_long."}, {"sha": "f6d0b826abda059ef755897edfa11f5f1397d476", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e4d04a1bad107f85a9e48e2f9df9ed672b0ab16/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e4d04a1bad107f85a9e48e2f9df9ed672b0ab16/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=3e4d04a1bad107f85a9e48e2f9df9ed672b0ab16", "patch": "@@ -3200,7 +3200,6 @@ extern void check_function_format\t\tPARAMS ((int *, tree, tree, tree));\n    NOP_EXPR is used as a special case (see truthvalue_conversion).  */\n extern void binary_op_error                     PARAMS ((enum tree_code));\n extern tree canonical_type_variant              PARAMS ((tree));\n-extern void c_expand_expr_stmt                  PARAMS ((tree));\n /* Validate the expression after `case' and apply default promotions.  */\n extern tree check_case_value                    PARAMS ((tree));\n /* Concatenate a list of STRING_CST nodes into one STRING_CST.  */\n@@ -4291,7 +4290,7 @@ extern void fixup_all_virtual_upcast_offsets    PARAMS ((tree));\n \n /* in semantics.c */\n extern void init_cp_semantics                   PARAMS ((void));\n-extern void finish_expr_stmt                    PARAMS ((tree));\n+extern tree finish_expr_stmt                    PARAMS ((tree));\n extern tree begin_if_stmt                       PARAMS ((void));\n extern void finish_if_stmt_cond                 PARAMS ((tree, tree));\n extern tree finish_then_clause                  PARAMS ((tree));\n@@ -4304,19 +4303,19 @@ extern void finish_while_stmt                   PARAMS ((tree));\n extern tree begin_do_stmt                       PARAMS ((void));\n extern void finish_do_body                      PARAMS ((tree));\n extern void finish_do_stmt                      PARAMS ((tree, tree));\n-extern void finish_return_stmt                  PARAMS ((tree));\n+extern tree finish_return_stmt                  PARAMS ((tree));\n extern tree begin_for_stmt                      PARAMS ((void));\n extern void finish_for_init_stmt                PARAMS ((tree));\n extern void finish_for_cond                     PARAMS ((tree, tree));\n extern void finish_for_expr                     PARAMS ((tree, tree));\n extern void finish_for_stmt                     PARAMS ((tree));\n-extern void finish_break_stmt                   PARAMS ((void));\n-extern void finish_continue_stmt                PARAMS ((void));\n+extern tree finish_break_stmt                   PARAMS ((void));\n+extern tree finish_continue_stmt                PARAMS ((void));\n extern tree begin_switch_stmt                   PARAMS ((void));\n extern void finish_switch_cond                  PARAMS ((tree, tree));\n extern void finish_switch_stmt                  PARAMS ((tree));\n-extern void finish_case_label                   PARAMS ((tree, tree));\n-extern void finish_goto_stmt                    PARAMS ((tree));\n+extern tree finish_case_label                   PARAMS ((tree, tree));\n+extern tree finish_goto_stmt                    PARAMS ((tree));\n extern tree begin_try_block                     PARAMS ((void));\n extern void finish_try_block                    PARAMS ((tree));\n extern void finish_handler_sequence             PARAMS ((tree));\n@@ -4331,7 +4330,7 @@ extern void finish_handler                      PARAMS ((tree, tree));\n extern void finish_cleanup                      PARAMS ((tree, tree));\n extern tree begin_compound_stmt                 PARAMS ((int));\n extern tree finish_compound_stmt                PARAMS ((int, tree));\n-extern void finish_asm_stmt                     PARAMS ((tree, tree, tree, tree, tree));\n+extern tree finish_asm_stmt                     PARAMS ((tree, tree, tree, tree, tree));\n extern void finish_label_stmt                   PARAMS ((tree));\n extern void finish_label_decl                   PARAMS ((tree));\n extern void finish_subobject                    PARAMS ((tree));"}, {"sha": "ab058426bd79058f15e2c744ccff8a4580383289", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e4d04a1bad107f85a9e48e2f9df9ed672b0ab16/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e4d04a1bad107f85a9e48e2f9df9ed672b0ab16/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=3e4d04a1bad107f85a9e48e2f9df9ed672b0ab16", "patch": "@@ -5158,12 +5158,12 @@ pop_switch ()\n /* Note that we've seen a definition of a case label, and complain if this\n    is a bad place for one.  */\n \n-void\n+tree\n finish_case_label (low_value, high_value)\n      tree low_value;\n      tree high_value;\n {\n-  tree cond;\n+  tree cond, r;\n   register struct binding_level *p;\n \n   if (! switch_stack)\n@@ -5175,7 +5175,7 @@ finish_case_label (low_value, high_value)\n \t\t  low_value);\n       else\n \terror (\"`default' label not within a switch statement\");\n-      return;\n+      return NULL_TREE;\n     }\n \n   if (processing_template_decl)\n@@ -5185,16 +5185,17 @@ finish_case_label (low_value, high_value)\n       /* For templates, just add the case label; we'll do semantic\n \t analysis at instantiation-time.  */\n       label = build_decl (LABEL_DECL, NULL_TREE, NULL_TREE);\n-      add_stmt (build_case_label (low_value, high_value, label));\n-      return;\n+      return add_stmt (build_case_label (low_value, high_value, label));\n     }\n \n   /* Find the condition on which this switch statement depends.  */\n   cond = SWITCH_COND (switch_stack->switch_stmt);\n   if (cond && TREE_CODE (cond) == TREE_LIST)\n     cond = TREE_VALUE (cond);\n \n-  c_add_case_label (switch_stack->cases, cond, low_value, high_value);\n+  r = c_add_case_label (switch_stack->cases, cond, low_value, high_value);\n+  if (r == error_mark_node)\n+    r = NULL_TREE;\n \n   check_switch_goto (switch_stack->level);\n \n@@ -5203,6 +5204,8 @@ finish_case_label (low_value, high_value)\n   for (p = current_binding_level; !(p->parm_flag); p = p->level_chain)\n     p->more_cleanups_ok = 0;\n   current_function_return_value = NULL_TREE;\n+\n+  return r;\n }\n \f\n /* Return the list of declarations of the current level."}, {"sha": "15cf72544753b960841aa8263227ea1f0e9745a2", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 78, "deletions": 53, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e4d04a1bad107f85a9e48e2f9df9ed672b0ab16/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e4d04a1bad107f85a9e48e2f9df9ed672b0ab16/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=3e4d04a1bad107f85a9e48e2f9df9ed672b0ab16", "patch": "@@ -338,7 +338,8 @@ cp_parse_init ()\n %type <ttype> maybe_attribute attributes attribute attribute_list attrib\n %type <ttype> any_word\n \n-%type <ttype> compstmt implicitly_scoped_stmt\n+%type <itype> save_lineno\n+%type <ttype> simple_stmt simple_if\n \n %type <ttype> declarator notype_declarator after_type_declarator\n %type <ttype> notype_declarator_intern absdcl_intern\n@@ -1151,14 +1152,15 @@ compstmtend:\n \t;\n \n already_scoped_stmt:\n-\t  '{'\n-                { $<ttype>$ = begin_compound_stmt (1); }\n+\t  save_lineno '{'\n+\t\t{ $<ttype>$ =  begin_compound_stmt (1); }\n \t  compstmtend\n-                { finish_compound_stmt (1, $<ttype>2); }\n-\t| simple_stmt\n+\t\t{ STMT_LINENO ($<ttype>3) = $1;\n+\t\t  finish_compound_stmt (1, $<ttype>3); }\n+\t| save_lineno simple_stmt\n+\t\t{ if ($2) STMT_LINENO ($2) = $1; }\n \t;\n \n-\n nontrivial_exprlist:\n \t  expr_no_commas ',' expr_no_commas\n \t\t{ $$ = tree_cons (NULL_TREE, $$, \n@@ -3277,56 +3279,61 @@ label_decl:\n    It causes syntax errors to ignore to the next openbrace.  */\n compstmt_or_error:\n \t  compstmt\n-\t\t{}\n \t| error compstmt\n \t;\n \n compstmt:\n-\t  '{'\n+\t  save_lineno '{'\n                 { $<ttype>$ = begin_compound_stmt (0); }\n \t  compstmtend \n-                { $$ = finish_compound_stmt (0, $<ttype>2); }\n+                { STMT_LINENO ($<ttype>3) = $1;\n+\t\t  finish_compound_stmt (0, $<ttype>3); }\n \t;\n \n simple_if:\n \t  IF\n-\t\t{\n-\t\t  $<ttype>$ = begin_if_stmt ();\n-\t\t  cond_stmt_keyword = \"if\";\n-\t\t}\n+\t\t{ $<ttype>$ = begin_if_stmt ();\n+\t\t  cond_stmt_keyword = \"if\"; }\n             paren_cond_or_null\n                 { finish_if_stmt_cond ($3, $<ttype>2); }\n \t    implicitly_scoped_stmt\n-                { $<ttype>$ = finish_then_clause ($<ttype>2); }\n+                { $$ = $<ttype>2;\n+\t\t  finish_then_clause ($<ttype>2); }\n \t;\n \n implicitly_scoped_stmt:\n \t  compstmt\n-\t|       { $<ttype>$ = begin_compound_stmt (0); }\n-\t  simple_stmt \n-                { $$ = finish_compound_stmt (0, $<ttype>1); }\n+\t| \n+\t\t{ $<ttype>$ = begin_compound_stmt (0); }\n+\t  save_lineno simple_stmt \n+\t\t{ STMT_LINENO ($<ttype>1) = $2;\n+\t\t  if ($3) STMT_LINENO ($3) = $2;\n+\t\t  finish_compound_stmt (0, $<ttype>1); }\n \t;\n \n stmt:\n \t  compstmt\n-                {}\n-\t| simple_stmt\n+\t| save_lineno simple_stmt\n+\t\t{ if ($2) STMT_LINENO ($2) = $1; }\n \t;\n \n simple_stmt:\n \t  decl\n-\t\t{ finish_stmt (); }\n+\t\t{ finish_stmt ();\n+\t\t  $$ = NULL_TREE; }\n \t| expr ';'\n-                { finish_expr_stmt ($1); }\n+                { $$ = finish_expr_stmt ($1); }\n \t| simple_if ELSE\n                 { begin_else_clause (); }\n \t  implicitly_scoped_stmt\n                 { \n-\t\t  finish_else_clause ($<ttype>1); \n+\t\t  $$ = $1;\n+\t\t  finish_else_clause ($1); \n \t\t  finish_if_stmt ();\n \t\t}\n \t| simple_if  %prec IF\n-                { finish_if_stmt (); }\n+                { $$ = $1;\n+\t\t  finish_if_stmt (); }\n \t| WHILE\n \t\t{\n \t\t  $<ttype>$ = begin_while_stmt ();\n@@ -3335,7 +3342,8 @@ simple_stmt:\n \t  paren_cond_or_null\n                 { finish_while_stmt_cond ($3, $<ttype>2); }\n \t  already_scoped_stmt\n-                { finish_while_stmt ($<ttype>2); }\n+                { $$ = $<ttype>2;\n+\t\t  finish_while_stmt ($<ttype>2); }\n \t| DO\n                 { $<ttype>$ = begin_do_stmt (); }\n \t  implicitly_scoped_stmt WHILE\n@@ -3344,7 +3352,8 @@ simple_stmt:\n \t\t  cond_stmt_keyword = \"do\";\n \t\t}\n \t  paren_expr_or_null ';'\n-                { finish_do_stmt ($6, $<ttype>2); }\n+                { $$ = $<ttype>2;\n+\t\t  finish_do_stmt ($6, $<ttype>2); }\n \t| FOR\n                 { $<ttype>$ = begin_for_stmt (); }\n \t  '(' for.init.statement\n@@ -3354,75 +3363,83 @@ simple_stmt:\n \t  xexpr ')'\n                 { finish_for_expr ($9, $<ttype>2); }\n \t  already_scoped_stmt\n-                { finish_for_stmt ($<ttype>2); }\n+                { $$ = $<ttype>2;\n+\t\t  finish_for_stmt ($<ttype>2); }\n \t| SWITCH \n                 { $<ttype>$ = begin_switch_stmt (); }\n \t    '(' condition ')'\n                 { finish_switch_cond ($4, $<ttype>2); }\n \t  implicitly_scoped_stmt\n-                { finish_switch_stmt ($<ttype>2); }\n+                { $$ = $<ttype>2;\n+\t\t  finish_switch_stmt ($<ttype>2); }\n \t| CASE expr_no_commas ':'\n-                { finish_case_label ($2, NULL_TREE); }\n+                { $<ttype>$ = finish_case_label ($2, NULL_TREE); }\n \t  stmt\n+\t\t{ $$ = $<ttype>4; }\n \t| CASE expr_no_commas ELLIPSIS expr_no_commas ':'\n-                { finish_case_label ($2, $4); }\n+                { $<ttype>$ = finish_case_label ($2, $4); }\n \t  stmt\n+\t\t{ $$ = $<ttype>6; }\n \t| DEFAULT ':'\n-\t\t{ finish_case_label (NULL_TREE, NULL_TREE); }\n+\t\t{ $<ttype>$ = finish_case_label (NULL_TREE, NULL_TREE); }\n \t  stmt\n+\t\t{ $$ = $<ttype>3; }\n \t| BREAK ';'\n-                { finish_break_stmt (); }\n+                { $$ = finish_break_stmt (); }\n \t| CONTINUE ';'\n-                { finish_continue_stmt (); }\n+                { $$ = finish_continue_stmt (); }\n \t| RETURN_KEYWORD ';'\n-                { finish_return_stmt (NULL_TREE); }\n+                { $$ = finish_return_stmt (NULL_TREE); }\n \t| RETURN_KEYWORD expr ';'\n-                { finish_return_stmt ($2); }\n+                { $$ = finish_return_stmt ($2); }\n \t| asm_keyword maybe_cv_qualifier '(' string ')' ';'\n-\t\t{ \n-\t\t  finish_asm_stmt ($2, $4, NULL_TREE, NULL_TREE,\n-\t\t\t\t   NULL_TREE); \n-\t\t}\n+\t\t{ $$ = finish_asm_stmt ($2, $4, NULL_TREE, NULL_TREE,\n+\t\t\t\t\tNULL_TREE); }\n \t/* This is the case with just output operands.  */\n \t| asm_keyword maybe_cv_qualifier '(' string ':' asm_operands ')' ';'\n-\t\t{ \n-\t\t  finish_asm_stmt ($2, $4, $6, NULL_TREE,\n-\t\t\t\t   NULL_TREE); \n-\t\t}\n+\t\t{ $$ = finish_asm_stmt ($2, $4, $6, NULL_TREE, NULL_TREE); }\n \t/* This is the case with input operands as well.  */\n-\t| asm_keyword maybe_cv_qualifier '(' string ':' asm_operands ':' asm_operands ')' ';'\n-\t\t{ finish_asm_stmt ($2, $4, $6, $8, NULL_TREE); }\n+\t| asm_keyword maybe_cv_qualifier '(' string ':' asm_operands ':'\n+\t  asm_operands ')' ';'\n+\t\t{ $$ = finish_asm_stmt ($2, $4, $6, $8, NULL_TREE); }\n \t| asm_keyword maybe_cv_qualifier '(' string SCOPE asm_operands ')' ';'\n-\t\t{ finish_asm_stmt ($2, $4, NULL_TREE, $6, NULL_TREE); }\n+\t\t{ $$ = finish_asm_stmt ($2, $4, NULL_TREE, $6, NULL_TREE); }\n \t/* This is the case with clobbered registers as well.  */\n \t| asm_keyword maybe_cv_qualifier '(' string ':' asm_operands ':'\n \t  asm_operands ':' asm_clobbers ')' ';'\n-\t\t{ finish_asm_stmt ($2, $4, $6, $8, $10); }\n+\t\t{ $$ = finish_asm_stmt ($2, $4, $6, $8, $10); }\n \t| asm_keyword maybe_cv_qualifier '(' string SCOPE asm_operands ':'\n \t  asm_clobbers ')' ';'\n-\t\t{ finish_asm_stmt ($2, $4, NULL_TREE, $6, $8); }\n+\t\t{ $$ = finish_asm_stmt ($2, $4, NULL_TREE, $6, $8); }\n \t| asm_keyword maybe_cv_qualifier '(' string ':' asm_operands SCOPE\n \t  asm_clobbers ')' ';'\n-\t\t{ finish_asm_stmt ($2, $4, $6, NULL_TREE, $8); }\n+\t\t{ $$ = finish_asm_stmt ($2, $4, $6, NULL_TREE, $8); }\n \t| GOTO '*' expr ';'\n                 { \n \t\t  if (pedantic)\n \t\t    pedwarn (\"ISO C++ forbids computed gotos\");\n-\t\t  finish_goto_stmt ($3);\n+\t\t  $$ = finish_goto_stmt ($3);\n \t\t}\n \t| GOTO identifier ';'\n-                { finish_goto_stmt ($2); }\n+                { $$ = finish_goto_stmt ($2); }\n \t| label_colon stmt\n+\t\t{ $$ = NULL_TREE; }\n \t| label_colon '}'\n \t\t{ error (\"label must be followed by statement\");\n-\t\t  yyungetc ('}', 0); }\n+\t\t  yyungetc ('}', 0);\n+\t\t  $$ = NULL_TREE; }\n \t| ';'\n-\t\t{ finish_stmt (); }\n+\t\t{ finish_stmt ();\n+\t\t  $$ = NULL_TREE; }\n \t| try_block\n+\t\t{ $$ = NULL_TREE; }\n \t| using_directive\n+\t\t{ $$ = NULL_TREE; }\n \t| namespace_using_decl\n-\t        { do_local_using_decl ($1); }\n+\t        { do_local_using_decl ($1);\n+\t\t  $$ = NULL_TREE; }\n \t| namespace_alias\n+\t\t{ $$ = NULL_TREE; }\n \t;\n \n function_try_block:\n@@ -3842,6 +3859,14 @@ operator_name:\n \t\t{ $$ = frob_opname (ansi_opname (ERROR_MARK)); }\n \t;\n \n+/* The forced readahead in here is because we might be at the end of a\n+   line, and lineno won't be bumped until yylex absorbs the first token\n+   on the next line.  */\n+save_lineno:\n+\t\t{ if (yychar == YYEMPTY)\n+\t\t    yychar = YYLEX;\n+\t\t  $$ = lineno; }\n+\t;\n %%\n \n #ifdef SPEW_DEBUG"}, {"sha": "856f4ae0aec1cba78ffe93418a5edd17bc238f71", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 22, "deletions": 16, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e4d04a1bad107f85a9e48e2f9df9ed672b0ab16/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e4d04a1bad107f85a9e48e2f9df9ed672b0ab16/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=3e4d04a1bad107f85a9e48e2f9df9ed672b0ab16", "patch": "@@ -150,7 +150,7 @@ do_pushlevel ()\n \n /* Finish a goto-statement.  */\n \n-void\n+tree\n finish_goto_stmt (destination)\n      tree destination;\n {\n@@ -171,7 +171,7 @@ finish_goto_stmt (destination)\n   \n   check_goto (destination);\n \n-  add_stmt (build_stmt (GOTO_STMT, destination));\n+  return add_stmt (build_stmt (GOTO_STMT, destination));\n }\n \n /* COND is the condition-expression for an if, while, etc.,\n@@ -196,10 +196,12 @@ maybe_convert_cond (cond)\n \n /* Finish an expression-statement, whose EXPRESSION is as indicated.  */\n \n-void \n+tree\n finish_expr_stmt (expr)\n      tree expr;\n {\n+  tree r = NULL_TREE;\n+\n   if (expr != NULL_TREE)\n     {\n       if (!processing_template_decl\n@@ -215,14 +217,16 @@ finish_expr_stmt (expr)\n       if (!processing_template_decl)\n \texpr = break_out_cleanups (expr);\n       \n-      add_stmt (build_stmt (EXPR_STMT, expr));\n+      r = add_stmt (build_stmt (EXPR_STMT, expr));\n     }\n \n   finish_stmt ();\n \n   /* This was an expression-statement, so we save the type of the\n      expression.  */\n   last_expr_type = expr ? TREE_TYPE (expr) : NULL_TREE;\n+\n+  return r;\n }\n \n \n@@ -375,10 +379,12 @@ finish_do_stmt (cond, do_stmt)\n /* Finish a return-statement.  The EXPRESSION returned, if any, is as\n    indicated.  */\n \n-void\n+tree\n finish_return_stmt (expr)\n      tree expr;\n {\n+  tree r;\n+\n   if (!processing_template_decl)\n     expr = check_return_expr (expr);\n   if (!processing_template_decl)\n@@ -391,21 +397,21 @@ finish_return_stmt (expr)\n \t     return a value there.  When we finally generate the real\n \t     return statement, CTOR_LABEL is no longer set, and we fall\n \t     through into the normal return-processing code below.  */\n-\t  finish_goto_stmt (ctor_label);\n-\t  return;\n+\t  return finish_goto_stmt (ctor_label);\n \t}\n       else if (DECL_DESTRUCTOR_P (current_function_decl))\n \t{\n \t  /* Similarly, all destructors must run destructors for\n \t     base-classes before returning.  So, all returns in a\n \t     destructor get sent to the DTOR_LABEL; finsh_function emits\n \t     code to return a value there.  */\n-\t  finish_goto_stmt (dtor_label);\n-\t  return;\n+\t  return finish_goto_stmt (dtor_label);\n \t}\n     }\n-  add_stmt (build_stmt (RETURN_STMT, expr));\n+  r = add_stmt (build_stmt (RETURN_STMT, expr));\n   finish_stmt ();\n+\n+  return r;\n }\n \n /* Begin a for-statement.  Returns a new FOR_STMT if appropriate.  */\n@@ -482,18 +488,18 @@ finish_for_stmt (for_stmt)\n \n /* Finish a break-statement.  */\n \n-void\n+tree\n finish_break_stmt ()\n {\n-  add_stmt (build_break_stmt ());\n+  return add_stmt (build_break_stmt ());\n }\n \n /* Finish a continue-statement.  */\n \n-void\n+tree\n finish_continue_stmt ()\n {\n-  add_stmt (build_continue_stmt ());\n+  return add_stmt (build_continue_stmt ());\n }\n \n /* Begin a switch-statement.  Returns a new SWITCH_STMT if\n@@ -884,7 +890,7 @@ finish_compound_stmt (has_no_scope, compound_stmt)\n    STRING, some OUTPUT_OPERANDS, some INPUT_OPERANDS, and some\n    CLOBBERS.  */\n \n-void\n+tree\n finish_asm_stmt (cv_qualifier, string, output_operands,\n \t\t input_operands, clobbers)\n      tree cv_qualifier;\n@@ -914,7 +920,7 @@ finish_asm_stmt (cv_qualifier, string, output_operands,\n   r = build_stmt (ASM_STMT, cv_qualifier, string,\n \t\t  output_operands, input_operands,\n \t\t  clobbers);\n-  add_stmt (r);\n+  return add_stmt (r);\n }\n \n /* Finish a label with the indicated NAME.  */"}]}