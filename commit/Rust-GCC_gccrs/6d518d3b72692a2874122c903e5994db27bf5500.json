{"sha": "6d518d3b72692a2874122c903e5994db27bf5500", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmQ1MThkM2I3MjY5MmEyODc0MTIyYzkwM2U1OTk0ZGIyN2JmNTUwMA==", "commit": {"author": {"name": "David Edelsohn", "email": "edelsohn@gnu.org", "date": "2009-12-02T04:21:08Z"}, "committer": {"name": "David Edelsohn", "email": "dje@gcc.gnu.org", "date": "2009-12-02T04:21:08Z"}, "message": "aix.S (ffi_call_AIX): Convert to more standard register usage.\n\n        * src/powerpc/aix.S (ffi_call_AIX): Convert to more standard\n        register usage.  Call ffi_prep_args directly.  Add long double\n        return value support.\n        * src/powerpc/ffi_darwin.c (ffi_prep_args): Double arg increment\n        applies to FFI_TYPE_DOUBLE.  Correct fpr_base increment typo.\n        Separate FFI_TYPE_SINT32 and FFI_TYPE_UINT32 cases.\n        (ffi_prep_cif_machdep): Only 16 byte stack alignment in 64 bit\n        mode.\n        (ffi_closure_helper_DARWIN): Remove nf and ng counters.  Move temp\n        into case.\n        * src/powerpc/aix_closure.S: Maintain 16 byte stack alignment.\n        Allocate result area between params and FPRs.\n\nFrom-SVN: r154892", "tree": {"sha": "b9991c60f54fd4d9bfdf966f8f61502208b440ce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b9991c60f54fd4d9bfdf966f8f61502208b440ce"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6d518d3b72692a2874122c903e5994db27bf5500", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d518d3b72692a2874122c903e5994db27bf5500", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6d518d3b72692a2874122c903e5994db27bf5500", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d518d3b72692a2874122c903e5994db27bf5500/comments", "author": null, "committer": null, "parents": [{"sha": "5e87bf4a142f66750f05b6319bf07b2dbf2c9f24", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e87bf4a142f66750f05b6319bf07b2dbf2c9f24", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5e87bf4a142f66750f05b6319bf07b2dbf2c9f24"}], "stats": {"total": 215, "additions": 100, "deletions": 115}, "files": [{"sha": "c0adaa9226b07915f947b4751240a6bb5328b6e8", "filename": "libffi/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d518d3b72692a2874122c903e5994db27bf5500/libffi%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d518d3b72692a2874122c903e5994db27bf5500/libffi%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2FChangeLog?ref=6d518d3b72692a2874122c903e5994db27bf5500", "patch": "@@ -1,3 +1,18 @@\n+2009-11-30  David Edelsohn  <edelsohn@gnu.org>\n+\n+\t* src/powerpc/aix.S (ffi_call_AIX): Convert to more standard\n+\tregister usage.  Call ffi_prep_args directly.  Add long double\n+\treturn value support.\n+\t* src/powerpc/ffi_darwin.c (ffi_prep_args): Double arg increment\n+\tapplies to FFI_TYPE_DOUBLE.  Correct fpr_base increment typo.\n+\tSeparate FFI_TYPE_SINT32 and FFI_TYPE_UINT32 cases.\n+\t(ffi_prep_cif_machdep): Only 16 byte stack alignment in 64 bit\n+\tmode.\n+\t(ffi_closure_helper_DARWIN): Remove nf and ng counters.  Move temp\n+\tinto case.\n+\t* src/powerpc/aix_closure.S: Maintain 16 byte stack alignment.\n+\tAllocate result area between params and FPRs.\n+\n 2009-11-30  David Edelsohn  <edelsohn@gnu.org>\n \n \tPR target/35484"}, {"sha": "5b477cad5e86570a2300236ca2d2b4bd837e114d", "filename": "libffi/src/powerpc/aix.S", "status": "modified", "additions": 32, "deletions": 45, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d518d3b72692a2874122c903e5994db27bf5500/libffi%2Fsrc%2Fpowerpc%2Faix.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d518d3b72692a2874122c903e5994db27bf5500/libffi%2Fsrc%2Fpowerpc%2Faix.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fpowerpc%2Faix.S?ref=6d518d3b72692a2874122c903e5994db27bf5500", "patch": "@@ -104,47 +104,34 @@ ffi_call_AIX:\n \t.llong .ffi_call_AIX, TOC[tc0], 0\n \t.csect .text[PR]\n .ffi_call_AIX:\n-\tmr\tr12,r8 // We only need r12 until the call, so it doesn't have to be saved...\n-\t/* Save the old stack pointer as AP.  */\n-\tmr\tr8,r1\n-\n-\t/* Allocate the stack space we need.  */\n-\tstdux\tr1,r1,r4\n-\n \t/* Save registers we use.  */\n-\tmflr\tr9\n+\tmflr\tr0\n \n-\tstd\tr28,-32(r8)\n-\tstd\tr29,-24(r8)\n-\tstd\tr30,-16(r8)\n-\tstd\tr31, -8(r8)\n+\tstd\tr28,-32(r1)\n+\tstd\tr29,-24(r1)\n+\tstd\tr30,-16(r1)\n+\tstd\tr31, -8(r1)\n \n-\tstd\tr9, 16(r8)\n-\tstd\tr2, 40(r1)\n+\tstd\tr0, 16(r1)\n+\tmr\tr28, r1\t\t/* our AP.  */\n+\tstdux\tr1, r1, r4\n \n \t/* Save arguments over call...  */\n-\tmr\tr31,r5\t/* flags, */\n-\tmr\tr30,r6\t/* rvalue, */\n-\tmr\tr29,r7\t/* function address, */\n-\tmr\tr28,r8\t/* our AP. */\n+\tmr\tr31, r5\t/* flags, */\n+\tmr\tr30, r6\t/* rvalue, */\n+\tmr\tr29, r7\t/* function address.  */\n+\tstd\tr2, 40(r1)\n \n \t/* Call ffi_prep_args.  */\n-\tmr\tr4,r1\n-\tli\tr9,0\n-\n-\tld\tr2,8(r12)\n-\tld\tr12,0(r12)\n-\tmtctr\tr12 // r12 holds address of _ffi_prep_args\n-\tbctrl\n-\tld\tr2,40(r1)\n+\tmr\tr4, r1\n+\tbl .ffi_prep_args\n \n \t/* Now do the call.  */\n-\tld\tr12,0(r29)\n+\tld\tr0, 0(r29)\n+\tld\tr2, 8(r29)\n \t/* Set up cr1 with bits 4-7 of the flags.  */\n-\tmtcrf\t0x40,r31\n-\tstd\tr2,40(r1)\n-\tmtctr\tr12\n-\tld\tr2,8(r29)\n+\tmtcrf\t0x40, r31\n+\tmtctr\tr0\n \t/* Load all those argument registers.  */\n \t// We have set up a nice stack frame, just load it into registers.\n \tld\tr3, 40+(1*8)(r1)\n@@ -180,33 +167,33 @@ L1:\n L2:\n \t/* Make the call.  */\n \tbctrl\n-\tld\tr2,40(r1)\n+\tld\tr2, 40(r1)\n \n \t/* Now, deal with the return value.  */\n-\tmtcrf\t0x01,r31\n+\tmtcrf\t0x01, r31\n \n-\tbt\t30,L(done_return_value)\n-\tbt\t29,L(fp_return_value)\n-\tstd\tr3,0(r30)\n-\tbf\t28,L(done_return_value)\n-\tstd\tr4,4(r30)\n+\tbt\t30, L(done_return_value)\n+\tbt\t29, L(fp_return_value)\n+\tstd\tr3, 0(r30)\n \n \t/* Fall through...  */\n \n L(done_return_value):\n \t/* Restore the registers we used and return.  */\n-\tld\tr9,16(r28)\n-\tld\tr31,-8(r28)\n-\tmtlr\tr9\n-\tld\tr30,-16(r28)\n-\tld\tr29,-24(r28)\n-\tld\tr28,-32(r28)\n-\tld\tr1,0(r1)\n+\tmr\tr1, r28\n+\tld\tr0, 16(r28)\n+\tld\tr28,-32(r1)\n+\tmtlr\tr0\n+\tld\tr29,-24(r1)\n+\tld\tr30,-16(r1)\n+\tld\tr31,-8(r1)\n \tblr\n \n L(fp_return_value):\n \tbf\t28,L(float_return_value)\n \tstfd\tf1,0(r30)\n+\tbf\t31,L(done_return_value)\n+\tstfd\tf2,8(r30)\n \tb\tL(done_return_value)\n L(float_return_value):\n \tstfs\tf1,0(r30)"}, {"sha": "70456188092b79564979196a1de610f017a0860c", "filename": "libffi/src/powerpc/aix_closure.S", "status": "modified", "additions": 30, "deletions": 29, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d518d3b72692a2874122c903e5994db27bf5500/libffi%2Fsrc%2Fpowerpc%2Faix_closure.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d518d3b72692a2874122c903e5994db27bf5500/libffi%2Fsrc%2Fpowerpc%2Faix_closure.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fpowerpc%2Faix_closure.S?ref=6d518d3b72692a2874122c903e5994db27bf5500", "patch": "@@ -105,54 +105,55 @@ ffi_closure_ASM:\n \n \t/* 48  Bytes (Linkage Area) */\n \t/* 64  Bytes (params) */\n+\t/* 16  Bytes (result) */\n \t/* 104 Bytes (13*8 from FPR) */\n-\t/* 32  Bytes (result) */\n-\t/* 248 Bytes */\n+\t/* 8   Bytes (alignment) */\n+\t/* 240 Bytes */\n \n-\tstdu r1,-248(r1)\t/* skip over caller save area\n+\tstdu r1,-240(r1)\t/* skip over caller save area\n \t\t\t\t   keep stack aligned to 16  */\n \n /* we want to build up an area for the parameters passed */\n /* in registers (both floating point and integer) */\n \n \t/* we store gpr 3 to gpr 10 (aligned to 4)\n \tin the parents outgoing area  */\n-\tstd   r3, (304+0*8)(r1)\n-\tstd   r4, (304+1*8)(r1)\n-\tstd   r5, (304+2*8)(r1)\n-\tstd   r6, (304+3*8)(r1)\n-\tstd   r7, (304+4*8)(r1)\n-\tstd   r8, (304+5*8)(r1)\n-\tstd   r9, (304+6*8)(r1)\n-\tstd   r10, (304+7*8)(r1)\n+\tstd   r3, 288+(0*8)(r1)\n+\tstd   r4, 288+(1*8)(r1)\n+\tstd   r5, 288+(2*8)(r1)\n+\tstd   r6, 288+(3*8)(r1)\n+\tstd   r7, 288+(4*8)(r1)\n+\tstd   r8, 288+(5*8)(r1)\n+\tstd   r9, 288+(6*8)(r1)\n+\tstd   r10, 288+(7*8)(r1)\n \n \t/* next save fpr 1 to fpr 13 (aligned to 8) */\n-\tstfd  f1, (112+0*8)(r1)\n-\tstfd  f2, (112+1*8)(r1)\n-\tstfd  f3, (112+2*8)(r1)\n-\tstfd  f4, (112+3*8)(r1)\n-\tstfd  f5, (112+4*8)(r1)\n-\tstfd  f6, (112+5*8)(r1)\n-\tstfd  f7, (112+6*8)(r1)\n-\tstfd  f8, (112+7*8)(r1)\n-\tstfd  f9, (112+8*8)(r1)\n-\tstfd  f10, (112+9*8)(r1)\n-\tstfd  f11, (112+10*8)(r1)\n-\tstfd  f12, (112+11*8)(r1)\n-\tstfd  f13, (112+12*8)(r1)\n+\tstfd  f1, 128+(0*8)(r1)\n+\tstfd  f2, 128+(1*8)(r1)\n+\tstfd  f3, 128+(2*8)(r1)\n+\tstfd  f4, 128+(3*8)(r1)\n+\tstfd  f5, 128+(4*8)(r1)\n+\tstfd  f6, 128+(5*8)(r1)\n+\tstfd  f7, 128+(6*8)(r1)\n+\tstfd  f8, 128+(7*8)(r1)\n+\tstfd  f9, 128+(8*8)(r1)\n+\tstfd  f10, 128+(9*8)(r1)\n+\tstfd  f11, 128+(10*8)(r1)\n+\tstfd  f12, 128+(11*8)(r1)\n+\tstfd  f13, 128+(12*8)(r1)\n \n \t/* set up registers for the routine that actually does the work */\n \t/* get the context pointer from the trampoline */\n \tmr r3,r11\n \n \t/* now load up the pointer to the result storage */\n-\taddi r4,r1,216\n+\taddi r4,r1,112\n \n \t/* now load up the pointer to the saved gpr registers */\n-\taddi r5,r1,304\n+\taddi r5,r1,288\n \n \t/* now load up the pointer to the saved fpr registers */\n-\taddi r6,r1,112\n+\taddi r6,r1,128\n \n \t/* make the call */\n \tbl .ffi_closure_helper_DARWIN\n@@ -164,7 +165,7 @@ ffi_closure_ASM:\n \n \t/* look up the proper starting point in table  */\n \t/* by using return type as offset */\n-\taddi r5,r1,216\t\t/* get pointer to results area */\n+\taddi r5,r1,112\t\t/* get pointer to results area */\n \tld r4,LC..60(2)\t\t/* get address of jump table */\n \tsldi r3,r3,2\t\t/* now multiply return type by 4 */\n \tlwzx r3,r4,r3\t\t/* get the contents of that table value */\n@@ -243,7 +244,7 @@ L..58:\n \n /* case void / done\t */\n L..44:\n-\taddi r1,r1,248\t\t/* restore stack pointer */\n+\taddi r1,r1,240\t\t/* restore stack pointer */\n \tld r0,16(r1)\t\t/* get return address */\n \tmtlr r0\t\t\t/* reset link register */\n \tblr"}, {"sha": "53dbdb2b2444ab1a00de17486deb98241d666e54", "filename": "libffi/src/powerpc/ffi_darwin.c", "status": "modified", "additions": 23, "deletions": 41, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d518d3b72692a2874122c903e5994db27bf5500/libffi%2Fsrc%2Fpowerpc%2Fffi_darwin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d518d3b72692a2874122c903e5994db27bf5500/libffi%2Fsrc%2Fpowerpc%2Fffi_darwin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fpowerpc%2Fffi_darwin.c?ref=6d518d3b72692a2874122c903e5994db27bf5500", "patch": "@@ -132,11 +132,7 @@ void ffi_prep_args(extended_cif *ecif, unsigned long *const stack)\n \t    *(double *)next_arg = double_tmp;\n \t  else\n \t    *fpr_base++ = double_tmp;\n-#ifdef POWERPC64\n \t  next_arg++;\n-#else\n-\t  next_arg += 2;\n-#endif\n \t  fparg_count++;\n \t  FFI_ASSERT(flags & FLAG_FP_ARGUMENTS);\n \t  break;\n@@ -147,7 +143,11 @@ void ffi_prep_args(extended_cif *ecif, unsigned long *const stack)\n \t    *(double *)next_arg = double_tmp;\n \t  else\n \t    *fpr_base++ = double_tmp;\n+#ifdef POWERPC64\n+\t  next_arg++;\n+#else\n \t  next_arg += 2;\n+#endif\n \t  fparg_count++;\n \t  FFI_ASSERT(flags & FLAG_FP_ARGUMENTS);\n \t  break;\n@@ -157,7 +157,7 @@ void ffi_prep_args(extended_cif *ecif, unsigned long *const stack)\n \tcase FFI_TYPE_LONGDOUBLE:\n #ifdef POWERPC64\n \t  if (fparg_count < NUM_FPR_ARG_REGISTERS)\n-\t    *((long double *) fpr_base)++ = *(long double *) *p_argv;\n+\t    *(long double *) fpr_base++ = *(long double *) *p_argv;\n \t  else\n \t    *(long double *) next_arg = *(long double *) *p_argv;\n \t  next_arg += 2;\n@@ -238,9 +238,12 @@ void ffi_prep_args(extended_cif *ecif, unsigned long *const stack)\n \t  break;\n \n \tcase FFI_TYPE_INT:\n-\tcase FFI_TYPE_UINT32:\n \tcase FFI_TYPE_SINT32:\n-\t  gprvalue = *(unsigned *)*p_argv;\n+\t  gprvalue = *(signed int *) *p_argv;\n+\t  goto putgpr;\n+\n+\tcase FFI_TYPE_UINT32:\n+\t  gprvalue = *(unsigned int *) *p_argv;\n \tputgpr:\n \t  *next_arg++ = gprvalue;\n \t  break;\n@@ -457,11 +460,7 @@ ffi_status ffi_prep_cif_machdep(ffi_cif *cif)\n     bytes += NUM_GPR_ARG_REGISTERS * sizeof(long);\n \n   /* The stack space allocated needs to be a multiple of 16 bytes.  */\n-#ifdef POWERPC64\n-  bytes = (bytes + 31) & -0x1F;\n-#else\n   bytes = (bytes + 15) & ~0xF;\n-#endif\n \n   cif->flags = flags;\n   cif->bytes = bytes;\n@@ -690,25 +689,19 @@ int ffi_closure_helper_DARWIN (ffi_closure* closure, void * rvalue,\n   void **          avalue;\n   ffi_type **      arg_types;\n   long             i, avn;\n-  long             nf;   /* number of floating registers already used.  */\n-  long             ng;   /* number of general registers already used.  */\n   ffi_cif *        cif;\n-  double           temp;\n+  ffi_dblfl *end_pfr = pfr + NUM_FPR_ARG_REGISTERS;\n   unsigned         size_al;\n \n   cif = closure->cif;\n   avalue = alloca(cif->nargs * sizeof(void *));\n \n-  nf = 0;\n-  ng = 0;\n-\n   /* Copy the caller's structure return value address so that the closure\n      returns the data directly to the caller.  */\n   if (cif->rtype->type == FFI_TYPE_STRUCT)\n     {\n       rvalue = (void *) *pgr;\n       pgr++;\n-      ng++;\n     }\n \n   i = 0;\n@@ -727,7 +720,6 @@ int ffi_closure_helper_DARWIN (ffi_closure* closure, void * rvalue,\n #else\n \t  avalue[i] = (char *) pgr + 3;\n #endif\n-\t  ng++;\n \t  pgr++;\n \t  break;\n \n@@ -738,7 +730,6 @@ int ffi_closure_helper_DARWIN (ffi_closure* closure, void * rvalue,\n #else\n \t  avalue[i] = (char *) pgr + 2;\n #endif\n-\t  ng++;\n \t  pgr++;\n \t  break;\n \n@@ -750,7 +741,6 @@ int ffi_closure_helper_DARWIN (ffi_closure* closure, void * rvalue,\n \tcase FFI_TYPE_POINTER:\n \t  avalue[i] = pgr;\n #endif\n-\t  ng++;\n \t  pgr++;\n \t  break;\n \n@@ -763,7 +753,6 @@ int ffi_closure_helper_DARWIN (ffi_closure* closure, void * rvalue,\n \t    avalue[i] = (void *) pgr + 8 - size_al;\n \t  else\n \t    avalue[i] = (void *) pgr;\n-\t  ng += (size_al + 7) / 8;\n \t  pgr += (size_al + 7) / 8;\n #else\n \t  /* Structures that match the basic modes (QI 1 byte, HI 2 bytes,\n@@ -777,7 +766,6 @@ int ffi_closure_helper_DARWIN (ffi_closure* closure, void * rvalue,\n \t    avalue[i] = (void*) pgr + 4 - size_al;\n \t  else\n \t    avalue[i] = (void*) pgr;\n-\t  ng += (size_al + 3) / 4;\n \t  pgr += (size_al + 3) / 4;\n #endif\n \t  break;\n@@ -787,40 +775,36 @@ int ffi_closure_helper_DARWIN (ffi_closure* closure, void * rvalue,\n #ifdef POWERPC64\n \tcase FFI_TYPE_POINTER:\n \t  avalue[i] = pgr;\n-\t  ng++;\n \t  pgr++;\n \t  break;\n #else\n \t  /* Long long ints are passed in two gpr's.  */\n \t  avalue[i] = pgr;\n-\t  ng += 2;\n \t  pgr += 2;\n \t  break;\n #endif\n \n \tcase FFI_TYPE_FLOAT:\n \t  /* A float value consumes a GPR.\n \t     There are 13 64bit floating point registers.  */\n-\t  if (nf < NUM_FPR_ARG_REGISTERS)\n+\t  if (pfr < end_pfr)\n \t    {\n-\t      temp = pfr->d;\n-\t      pfr->f = (float)temp;\n+\t      double temp = pfr->d;\n+\t      pfr->f = (float) temp;\n \t      avalue[i] = pfr;\n \t      pfr++;\n \t    }\n \t  else\n \t    {\n \t      avalue[i] = pgr;\n \t    }\n-\t  nf++;\n-\t  ng++;\n \t  pgr++;\n \t  break;\n \n \tcase FFI_TYPE_DOUBLE:\n \t  /* A double value consumes two GPRs.\n \t     There are 13 64bit floating point registers.  */\n-\t  if (nf < NUM_FPR_ARG_REGISTERS)\n+\t  if (pfr < end_pfr)\n \t    {\n \t      avalue[i] = pfr;\n \t      pfr++;\n@@ -829,12 +813,9 @@ int ffi_closure_helper_DARWIN (ffi_closure* closure, void * rvalue,\n \t    {\n \t      avalue[i] = pgr;\n \t    }\n-\t  nf++;\n #ifdef POWERPC64\n-\t  ng++;\n \t  pgr++;\n #else\n-\t  ng += 2;\n \t  pgr += 2;\n #endif\n \t  break;\n@@ -843,30 +824,33 @@ int ffi_closure_helper_DARWIN (ffi_closure* closure, void * rvalue,\n \n \tcase FFI_TYPE_LONGDOUBLE:\n #ifdef POWERPC64\n-\t  if (nf < NUM_FPR_ARG_REGISTERS)\n+\t  if (pfr + 1 < end_pfr)\n \t    {\n \t      avalue[i] = pfr;\n \t      pfr += 2;\n \t    }\n \t  else\n \t    {\n+\t      if (pfr < end_pfr)\n+\t\t{\n+\t\t  *pgr = *(unsigned long *) pfr;\n+\t\t  pfr++;\n+\t\t}\n \t      avalue[i] = pgr;\n \t    }\n-\t  nf += 2;\n-\t  ng += 2;\n \t  pgr += 2;\n #else  /* POWERPC64 */\n \t  /* A long double value consumes four GPRs and two FPRs.\n \t     There are 13 64bit floating point registers.  */\n-\t  if (nf < NUM_FPR_ARG_REGISTERS - 1)\n+\t  if (pfr + 1 < end_pfr)\n \t    {\n \t      avalue[i] = pfr;\n \t      pfr += 2;\n \t    }\n \t  /* Here we have the situation where one part of the long double\n \t     is stored in fpr13 and the other part is already on the stack.\n \t     We use a union to pass the long double to avalue[i].  */\n-\t  else if (nf == NUM_FPR_ARG_REGISTERS - 1)\n+\t  else if (pfr + 1 == end_pfr)\n \t    {\n \t      union ldu temp_ld;\n \t      memcpy (&temp_ld.lb[0], pfr, sizeof(ldbits));\n@@ -877,8 +861,6 @@ int ffi_closure_helper_DARWIN (ffi_closure* closure, void * rvalue,\n \t    {\n \t      avalue[i] = pgr;\n \t    }\n-\t  nf += 2;\n-\t  ng += 4;\n \t  pgr += 4;\n #endif  /* POWERPC64 */\n \t  break;"}]}