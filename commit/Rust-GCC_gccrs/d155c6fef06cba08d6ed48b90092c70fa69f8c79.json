{"sha": "d155c6fef06cba08d6ed48b90092c70fa69f8c79", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDE1NWM2ZmVmMDZjYmEwOGQ2ZWQ0OGI5MDA5MmM3MGZhNjlmOGM3OQ==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2017-01-13T15:42:08Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2017-01-13T15:42:08Z"}, "message": "re PR tree-optimization/33562 (aggregate DSE disabled)\n\n        PR tree-optimization/33562\n        PR tree-optimization/61912\n        PR tree-optimization/77485\n\t* doc/invoke.texi: Document new dse-max-object-size param.\n\t* params.def (PARM_DSE_MAX_OBJECT_SIZE): New PARAM.\n\t* tree-ssa-dse.c: Include params.h.\n\t(dse_store_status): New enum.\n\t(initialize_ao_ref_for_dse): New, partially extracted from\n\tdse_optimize_stmt.\n\t(valid_ao_ref_for_dse, normalize_ref): New.\n\t(setup_live_bytes_from_ref, compute_trims): Likewise.\n\t(clear_bytes_written_by, maybe_trim_complex_store): Likewise.\n\t(maybe_trim_partially_dead_store): Likewise.\n\t(maybe_trim_complex_store): Likewise.\n\t(dse_classify_store): Renamed from dse_possibly_dead_store_p.\n\tTrack what bytes live from the original store.  Return tri-state\n\tfor dead, partially dead or live.\n\t(dse_dom_walker): Add constructor, destructor and new private members.\n\t(delete_dead_call, delete_dead_assignment): New extracted from\n\tdse_optimize_stmt.\n\t(dse_optimize_stmt): Make a member of dse_dom_walker.\n\tUse initialize_ao_ref_for_dse.\n\n        PR tree-optimization/33562\n        PR tree-optimization/61912\n        PR tree-optimization/77485\n\t* gcc.dg/tree-ssa/complex-4.c: Remove xfail.\n\t* gcc.dg/tree-ssa/complex-5.c: Likewise.\n\t* gcc.dg/tree-ssa/ssa-dse-9.c: Likewise.\n\t* gcc.dg/tree-ssa/ssa-dse-18.c: New test.\n\t* gcc.dg/tree-ssa/ssa-dse-19.c: Likewise.\n\t* gcc.dg/tree-ssa/ssa-dse-20.c: Likewise.\n\t* gcc.dg/tree-ssa/ssa-dse-21.c: Likewise.\n\nFrom-SVN: r244442", "tree": {"sha": "4f6529aeda7d903802356f90c11593f8123fef1d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4f6529aeda7d903802356f90c11593f8123fef1d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d155c6fef06cba08d6ed48b90092c70fa69f8c79", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d155c6fef06cba08d6ed48b90092c70fa69f8c79", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d155c6fef06cba08d6ed48b90092c70fa69f8c79", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d155c6fef06cba08d6ed48b90092c70fa69f8c79/comments", "author": null, "committer": null, "parents": [{"sha": "68b36e5903ea260f430e515211a8b169e247f77c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68b36e5903ea260f430e515211a8b169e247f77c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/68b36e5903ea260f430e515211a8b169e247f77c"}], "stats": {"total": 536, "additions": 462, "deletions": 74}, "files": [{"sha": "3cb1a600c42ff4f365f6109c3fe99878c1369540", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d155c6fef06cba08d6ed48b90092c70fa69f8c79/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d155c6fef06cba08d6ed48b90092c70fa69f8c79/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d155c6fef06cba08d6ed48b90092c70fa69f8c79", "patch": "@@ -1,5 +1,28 @@\n 2017-01-13  Jeff Law  <law@redhat.com>\n \n+        PR tree-optimization/33562\n+        PR tree-optimization/61912\n+        PR tree-optimization/77485\n+\t* doc/invoke.texi: Document new dse-max-object-size param.\n+\t* params.def (PARM_DSE_MAX_OBJECT_SIZE): New PARAM.\n+\t* tree-ssa-dse.c: Include params.h.\n+\t(dse_store_status): New enum.\n+\t(initialize_ao_ref_for_dse): New, partially extracted from\n+\tdse_optimize_stmt.\n+\t(valid_ao_ref_for_dse, normalize_ref): New.\n+\t(setup_live_bytes_from_ref, compute_trims): Likewise.\n+\t(clear_bytes_written_by, maybe_trim_complex_store): Likewise.\n+\t(maybe_trim_partially_dead_store): Likewise.\n+\t(maybe_trim_complex_store): Likewise.\n+\t(dse_classify_store): Renamed from dse_possibly_dead_store_p.\n+\tTrack what bytes live from the original store.  Return tri-state\n+\tfor dead, partially dead or live.\n+\t(dse_dom_walker): Add constructor, destructor and new private members.\n+\t(delete_dead_call, delete_dead_assignment): New extracted from\n+\tdse_optimize_stmt.\n+\t(dse_optimize_stmt): Make a member of dse_dom_walker.\n+\tUse initialize_ao_ref_for_dse.\n+\n \tPR tree-optimization/33562\n \tPR tree-optimization/61912\n \tPR tree-optimization/77485"}, {"sha": "99f193e7b2dee17c53b0ae8c6009f975ccd5d20f", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d155c6fef06cba08d6ed48b90092c70fa69f8c79/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d155c6fef06cba08d6ed48b90092c70fa69f8c79/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=d155c6fef06cba08d6ed48b90092c70fa69f8c79", "patch": "@@ -9880,6 +9880,10 @@ when adding a new one.\n @item avg-loop-niter\n Average number of iterations of a loop.\n \n+@item dse-max-object-size\n+Maximum size (in bytes) of objects tracked bytewise by dead store elimination.\n+Larger values may result in larger compilation times.\n+\n @item scev-max-expr-size\n Bound on size of expressions used in the scalar evolutions analyzer.\n Large expressions slow the analyzer."}, {"sha": "e598d3479f930c90d4d0f3e5a39165394bb4ea07", "filename": "gcc/params.def", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d155c6fef06cba08d6ed48b90092c70fa69f8c79/gcc%2Fparams.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d155c6fef06cba08d6ed48b90092c70fa69f8c79/gcc%2Fparams.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.def?ref=d155c6fef06cba08d6ed48b90092c70fa69f8c79", "patch": "@@ -532,6 +532,11 @@ DEFPARAM(PARAM_AVG_LOOP_NITER,\n \t \"Average number of iterations of a loop.\",\n \t 10, 1, 0)\n \n+DEFPARAM(PARAM_DSE_MAX_OBJECT_SIZE,\n+\t \"dse-max-object-size\",\n+\t \"Maximum size (in bytes) of objects tracked bytewise by dead store elimination.\",\n+\t 256, 0, 0)\n+\n DEFPARAM(PARAM_SCEV_MAX_EXPR_SIZE,\n  \t \"scev-max-expr-size\",\n \t \"Bound on size of expressions used in the scalar evolutions analyzer.\","}, {"sha": "edee5a4a6332927cfa6fa05f74ec0ef7ee2c7f0d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d155c6fef06cba08d6ed48b90092c70fa69f8c79/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d155c6fef06cba08d6ed48b90092c70fa69f8c79/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d155c6fef06cba08d6ed48b90092c70fa69f8c79", "patch": "@@ -1,3 +1,16 @@\n+2017-01-13  Jeff Law  <law@redhat.com>\n+\n+        PR tree-optimization/33562\n+        PR tree-optimization/61912\n+        PR tree-optimization/77485\n+\t* gcc.dg/tree-ssa/complex-4.c: Remove xfail.\n+\t* gcc.dg/tree-ssa/complex-5.c: Likewise.\n+\t* gcc.dg/tree-ssa/ssa-dse-9.c: Likewise.\n+\t* gcc.dg/tree-ssa/ssa-dse-18.c: New test.\n+\t* gcc.dg/tree-ssa/ssa-dse-19.c: Likewise.\n+\t* gcc.dg/tree-ssa/ssa-dse-20.c: Likewise.\n+\t* gcc.dg/tree-ssa/ssa-dse-21.c: Likewise.\n+\n 2017-01-13  Martin Liska  <mliska@suse.cz>\n \n \tPR ipa/79043"}, {"sha": "3155741c6302f5f1d8a495eda341e4d4f14c1d89", "filename": "gcc/testsuite/gcc.dg/tree-ssa/complex-4.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d155c6fef06cba08d6ed48b90092c70fa69f8c79/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fcomplex-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d155c6fef06cba08d6ed48b90092c70fa69f8c79/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fcomplex-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fcomplex-4.c?ref=d155c6fef06cba08d6ed48b90092c70fa69f8c79", "patch": "@@ -10,4 +10,4 @@ int f(void)\n   return g(&t);\n }\n \n-/* { dg-final { scan-tree-dump-times \"__complex__\" 0 \"optimized\" { xfail *-*-* } } } */\n+/* { dg-final { scan-tree-dump-times \"__complex__\" 0 \"optimized\" } } */"}, {"sha": "e6d027f57effa73cbfa526bda0291efa1e7c44ae", "filename": "gcc/testsuite/gcc.dg/tree-ssa/complex-5.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d155c6fef06cba08d6ed48b90092c70fa69f8c79/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fcomplex-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d155c6fef06cba08d6ed48b90092c70fa69f8c79/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fcomplex-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fcomplex-5.c?ref=d155c6fef06cba08d6ed48b90092c70fa69f8c79", "patch": "@@ -8,4 +8,4 @@ int f(void)\n  __imag__ t = 2;\n }\n \n-/* { dg-final { scan-tree-dump-times \"__complex__\" 0 \"optimized\" { xfail *-*-* } } } */\n+/* { dg-final { scan-tree-dump-times \"__complex__\" 0 \"optimized\" } } */"}, {"sha": "92b2df80ec854d36992ef64278f17f23db2f9427", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-dse-18.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d155c6fef06cba08d6ed48b90092c70fa69f8c79/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dse-18.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d155c6fef06cba08d6ed48b90092c70fa69f8c79/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dse-18.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dse-18.c?ref=d155c6fef06cba08d6ed48b90092c70fa69f8c79", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-optimized\" } */\n+int g(_Complex int*);\n+int f(void)\n+{\n+  _Complex int t = 0;\n+  int i, j;\n+ __imag__ t += 2;\n+  return g(&t);\n+}\n+\n+\n+/* { dg-final { scan-tree-dump-times \"__complex__\" 0 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"REALPART_EXPR\" 1 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"IMAGPART_EXPR\" 1 \"optimized\" } } */"}, {"sha": "718b7466e509fa8ecfc2493992cede61eca04c80", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-dse-19.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d155c6fef06cba08d6ed48b90092c70fa69f8c79/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dse-19.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d155c6fef06cba08d6ed48b90092c70fa69f8c79/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dse-19.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dse-19.c?ref=d155c6fef06cba08d6ed48b90092c70fa69f8c79", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-optimized\" } */\n+int g(_Complex int*);\n+int f(void)\n+{\n+  _Complex int t = 0;\n+  int i, j;\n+ __real__ t += 2;\n+  return g(&t);\n+}\n+\n+\n+/* { dg-final { scan-tree-dump-times \"__complex__\" 0 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"REALPART_EXPR\" 1 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"IMAGPART_EXPR\" 1 \"optimized\" } } */"}, {"sha": "4e14d9b154334f17b7fdb871f41bec426a948bc5", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-dse-20.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d155c6fef06cba08d6ed48b90092c70fa69f8c79/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dse-20.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d155c6fef06cba08d6ed48b90092c70fa69f8c79/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dse-20.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dse-20.c?ref=d155c6fef06cba08d6ed48b90092c70fa69f8c79", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O1 -fno-tree-dce -fdump-tree-optimized\" } */\n+_Complex int t = 0;\n+int f(void)\n+{\n+  t = 0;\n+ __imag__ t = 2;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"__complex__\" 0 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"REALPART_EXPR\" 1 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"IMAGPART_EXPR\" 1 \"optimized\" } } */\n+"}, {"sha": "d1e0b85bc0150ac72ef87eda6919430bead0e0aa", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-dse-21.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d155c6fef06cba08d6ed48b90092c70fa69f8c79/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dse-21.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d155c6fef06cba08d6ed48b90092c70fa69f8c79/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dse-21.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dse-21.c?ref=d155c6fef06cba08d6ed48b90092c70fa69f8c79", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O1 -fno-tree-dce -fdump-tree-optimized\" } */\n+_Complex int t = 0;\n+int f(void)\n+{\n+  t = 0;\n+ __real__ t = 2;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"__complex__\" 0 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"REALPART_EXPR\" 1 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"IMAGPART_EXPR\" 1 \"optimized\" } } */"}, {"sha": "ae48ddd51520c1e21a412a1481fd074586e480da", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-dse-9.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d155c6fef06cba08d6ed48b90092c70fa69f8c79/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dse-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d155c6fef06cba08d6ed48b90092c70fa69f8c79/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dse-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dse-9.c?ref=d155c6fef06cba08d6ed48b90092c70fa69f8c79", "patch": "@@ -11,4 +11,4 @@ foo ()\n }\n \n /* We should eliminate the first assignment.  */\n-/* { dg-final { scan-tree-dump-times \"VDEF\" 2 \"dse1\" { xfail *-*-* } } } */\n+/* { dg-final { scan-tree-dump-times \"VDEF\" 2 \"dse1\" } } */"}, {"sha": "daaa99c4dd8e343c9e7d512e3dd772fcb0c64a01", "filename": "gcc/tree-ssa-dse.c", "status": "modified", "additions": 359, "deletions": 71, "changes": 430, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d155c6fef06cba08d6ed48b90092c70fa69f8c79/gcc%2Ftree-ssa-dse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d155c6fef06cba08d6ed48b90092c70fa69f8c79/gcc%2Ftree-ssa-dse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dse.c?ref=d155c6fef06cba08d6ed48b90092c70fa69f8c79", "patch": "@@ -33,6 +33,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-dfa.h\"\n #include \"domwalk.h\"\n #include \"tree-cfgcleanup.h\"\n+#include \"params.h\"\n \n /* This file implements dead store elimination.\n \n@@ -68,14 +69,241 @@ along with GCC; see the file COPYING3.  If not see\n    remove their dead edges eventually.  */\n static bitmap need_eh_cleanup;\n \n+/* Return value from dse_classify_store */\n+enum dse_store_status\n+{\n+  DSE_STORE_LIVE,\n+  DSE_STORE_MAYBE_PARTIAL_DEAD,\n+  DSE_STORE_DEAD\n+};\n+\n+/* STMT is a statement that may write into memory.  Analyze it and\n+   initialize WRITE to describe how STMT affects memory.\n+\n+   Return TRUE if the the statement was analyzed, FALSE otherwise.\n+\n+   It is always safe to return FALSE.  But typically better optimziation\n+   can be achieved by analyzing more statements.  */\n+\n+static bool\n+initialize_ao_ref_for_dse (gimple *stmt, ao_ref *write)\n+{\n+  /* It's advantageous to handle certain mem* functions.  */\n+  if (gimple_call_builtin_p (stmt, BUILT_IN_NORMAL))\n+    {\n+      switch (DECL_FUNCTION_CODE (gimple_call_fndecl (stmt)))\n+\t{\n+\t  case BUILT_IN_MEMCPY:\n+\t  case BUILT_IN_MEMMOVE:\n+\t  case BUILT_IN_MEMSET:\n+\t    {\n+\t      tree size = NULL_TREE;\n+\t      if (gimple_call_num_args (stmt) == 3)\n+\t\tsize = gimple_call_arg (stmt, 2);\n+\t      tree ptr = gimple_call_arg (stmt, 0);\n+\t      ao_ref_init_from_ptr_and_size (write, ptr, size);\n+\t      return true;\n+\t    }\n+\t  default:\n+\t    break;\n+\t}\n+    }\n+  else if (is_gimple_assign (stmt))\n+    {\n+      ao_ref_init (write, gimple_assign_lhs (stmt));\n+      return true;\n+    }\n+  return false;\n+}\n+\n+/* Given REF from the the alias oracle, return TRUE if it is a valid\n+   memory reference for dead store elimination, false otherwise.\n+\n+   In particular, the reference must have a known base, known maximum\n+   size, start at a byte offset and have a size that is one or more\n+   bytes.  */\n+\n+static bool\n+valid_ao_ref_for_dse (ao_ref *ref)\n+{\n+  return (ao_ref_base (ref)\n+\t  && ref->max_size != -1\n+\t  && (ref->offset % BITS_PER_UNIT) == 0\n+\t  && (ref->size % BITS_PER_UNIT) == 0\n+\t  && (ref->size != -1));\n+}\n+\n+/* Normalize COPY (an ao_ref) relative to REF.  Essentially when we are\n+   done COPY will only refer bytes found within REF.\n+\n+   We have already verified that COPY intersects at least one\n+   byte with REF.  */\n+\n+static void\n+normalize_ref (ao_ref *copy, ao_ref *ref)\n+{\n+  /* If COPY starts before REF, then reset the beginning of\n+     COPY to match REF and decrease the size of COPY by the\n+     number of bytes removed from COPY.  */\n+  if (copy->offset < ref->offset)\n+    {\n+      copy->size -= (ref->offset - copy->offset);\n+      copy->offset = ref->offset;\n+    }\n+\n+  /* If COPY extends beyond REF, chop off its size appropriately.  */\n+  if (copy->offset + copy->size > ref->offset + ref->size)\n+    copy->size -= (copy->offset + copy->size - (ref->offset + ref->size));\n+}\n+\n+/* Clear any bytes written by STMT from the bitmap LIVE_BYTES.  The base\n+   address written by STMT must match the one found in REF, which must\n+   have its base address previously initialized.\n+\n+   This routine must be conservative.  If we don't know the offset or\n+   actual size written, assume nothing was written.  */\n+\n+static void\n+clear_bytes_written_by (sbitmap live_bytes, gimple *stmt, ao_ref *ref)\n+{\n+  ao_ref write;\n+  if (!initialize_ao_ref_for_dse (stmt, &write))\n+    return;\n+\n+  /* Verify we have the same base memory address, the write\n+     has a known size and overlaps with REF.  */\n+  if (valid_ao_ref_for_dse (&write)\n+      && write.base == ref->base\n+      && write.size == write.max_size\n+      && ((write.offset < ref->offset\n+\t   && write.offset + write.size > ref->offset)\n+\t  || (write.offset >= ref->offset\n+\t      && write.offset < ref->offset + ref->size)))\n+    {\n+      normalize_ref (&write, ref);\n+      bitmap_clear_range (live_bytes,\n+\t\t\t  (write.offset - ref->offset) / BITS_PER_UNIT,\n+\t\t\t  write.size / BITS_PER_UNIT);\n+    }\n+}\n+\n+/* REF is a memory write.  Extract relevant information from it and\n+   initialize the LIVE_BYTES bitmap.  If successful, return TRUE.\n+   Otherwise return FALSE.  */\n+\n+static bool\n+setup_live_bytes_from_ref (ao_ref *ref, sbitmap live_bytes)\n+{\n+  if (valid_ao_ref_for_dse (ref)\n+      && (ref->size / BITS_PER_UNIT\n+\t  <= PARAM_VALUE (PARAM_DSE_MAX_OBJECT_SIZE)))\n+    {\n+      bitmap_clear (live_bytes);\n+      bitmap_set_range (live_bytes, 0, ref->size / BITS_PER_UNIT);\n+      return true;\n+    }\n+  return false;\n+}\n+\n+/* Compute the number of elements that we can trim from the head and\n+   tail of ORIG resulting in a bitmap that is a superset of LIVE.\n+\n+   Store the number of elements trimmed from the head and tail in\n+   TRIM_HEAD and TRIM_TAIL.  */\n+\n+static void\n+compute_trims (ao_ref *ref, sbitmap live, int *trim_head, int *trim_tail)\n+{\n+  /* We use sbitmaps biased such that ref->offset is bit zero and the bitmap\n+     extends through ref->size.  So we know that in the original bitmap\n+     bits 0..ref->size were true.  We don't actually need the bitmap, just\n+     the REF to compute the trims.  */\n+\n+  /* Now identify how much, if any of the tail we can chop off.  */\n+  *trim_tail = 0;\n+  int last_orig = (ref->size / BITS_PER_UNIT) - 1;\n+  int last_live = bitmap_last_set_bit (live);\n+  *trim_tail = (last_orig - last_live) & ~0x1;\n+\n+  /* Identify how much, if any of the head we can chop off.  */\n+  int first_orig = 0;\n+  int first_live = bitmap_first_set_bit (live);\n+  *trim_head = (first_live - first_orig) & ~0x1;\n+}\n+\n+/* STMT initializes an object from COMPLEX_CST where one or more of the\n+   bytes written may be dead stores.  REF is a representation of the\n+   memory written.  LIVE is the bitmap of stores that are actually live.\n+\n+   Attempt to rewrite STMT so that only the real or imaginary part of\n+   the object is actually stored.  */\n+\n+static void\n+maybe_trim_complex_store (ao_ref *ref, sbitmap live, gimple *stmt)\n+{\n+  int trim_head, trim_tail;\n+  compute_trims (ref, live, &trim_head, &trim_tail);\n+\n+  /* The amount of data trimmed from the head or tail must be at\n+     least half the size of the object to ensure we're trimming\n+     the entire real or imaginary half.  By writing things this\n+     way we avoid more O(n) bitmap operations.  */\n+  if (trim_tail * 2 >= ref->size / BITS_PER_UNIT)\n+    {\n+      /* TREE_REALPART is live */\n+      tree x = TREE_REALPART (gimple_assign_rhs1 (stmt));\n+      tree y = gimple_assign_lhs (stmt);\n+      y = build1 (REALPART_EXPR, TREE_TYPE (x), y);\n+      gimple_assign_set_lhs (stmt, y);\n+      gimple_assign_set_rhs1 (stmt, x);\n+    }\n+  else if (trim_head * 2 >= ref->size / BITS_PER_UNIT)\n+    {\n+      /* TREE_IMAGPART is live */\n+      tree x = TREE_IMAGPART (gimple_assign_rhs1 (stmt));\n+      tree y = gimple_assign_lhs (stmt);\n+      y = build1 (IMAGPART_EXPR, TREE_TYPE (x), y);\n+      gimple_assign_set_lhs (stmt, y);\n+      gimple_assign_set_rhs1 (stmt, x);\n+    }\n+\n+  /* Other cases indicate parts of both the real and imag subobjects\n+     are live.  We do not try to optimize those cases.  */\n+}\n+\n+/* STMT is a memory write where one or more bytes written are dead\n+   stores.  ORIG is the bitmap of bytes stored by STMT.  LIVE is the\n+   bitmap of stores that are actually live.\n+\n+   Attempt to rewrite STMT so that it writes fewer memory locations.  Right\n+   now we only support trimming at the start or end of the memory region.\n+   It's not clear how much there is to be gained by trimming from the middle\n+   of the region.  */\n+\n+static void\n+maybe_trim_partially_dead_store (ao_ref *ref, sbitmap live, gimple *stmt)\n+{\n+  if (is_gimple_assign (stmt))\n+    {\n+      switch (gimple_assign_rhs_code (stmt))\n+\t{\n+\tcase COMPLEX_CST:\n+\t  maybe_trim_complex_store (ref, live, stmt);\n+\t  break;\n+\tdefault:\n+\t  break;\n+\t}\n+    }\n+}\n \n /* A helper of dse_optimize_stmt.\n    Given a GIMPLE_ASSIGN in STMT that writes to REF, find a candidate\n    statement *USE_STMT that may prove STMT to be dead.\n    Return TRUE if the above conditions are met, otherwise FALSE.  */\n \n-static bool\n-dse_possible_dead_store_p (ao_ref *ref, gimple *stmt, gimple **use_stmt)\n+static dse_store_status\n+dse_classify_store (ao_ref *ref, gimple *stmt, gimple **use_stmt,\n+\t\t    bool byte_tracking_enabled, sbitmap live_bytes)\n {\n   gimple *temp;\n   unsigned cnt = 0;\n@@ -97,7 +325,7 @@ dse_possible_dead_store_p (ao_ref *ref, gimple *stmt, gimple **use_stmt)\n       /* Limit stmt walking to be linear in the number of possibly\n          dead stores.  */\n       if (++cnt > 256)\n-\treturn false;\n+\treturn DSE_STORE_LIVE;\n \n       if (gimple_code (temp) == GIMPLE_PHI)\n \tdefvar = PHI_RESULT (temp);\n@@ -135,7 +363,7 @@ dse_possible_dead_store_p (ao_ref *ref, gimple *stmt, gimple **use_stmt)\n \t\t  fail = true;\n \t\t  BREAK_FROM_IMM_USE_STMT (ui);\n \t\t}\n-\t      /* Do not consider the PHI as use if it dominates the \n+\t      /* Do not consider the PHI as use if it dominates the\n \t         stmt defining the virtual operand we are processing,\n \t\t we have processed it already in this case.  */\n \t      if (gimple_bb (defvar_def) != gimple_bb (use_stmt)\n@@ -164,28 +392,115 @@ dse_possible_dead_store_p (ao_ref *ref, gimple *stmt, gimple **use_stmt)\n \t}\n \n       if (fail)\n-\treturn false;\n+\t{\n+\t  /* STMT might be partially dead and we may be able to reduce\n+\t     how many memory locations it stores into.  */\n+\t  if (byte_tracking_enabled && !gimple_clobber_p (stmt))\n+\t    return DSE_STORE_MAYBE_PARTIAL_DEAD;\n+\t  return DSE_STORE_LIVE;\n+\t}\n \n       /* If we didn't find any definition this means the store is dead\n          if it isn't a store to global reachable memory.  In this case\n \t just pretend the stmt makes itself dead.  Otherwise fail.  */\n       if (!temp)\n \t{\n \t  if (ref_may_alias_global_p (ref))\n-\t    return false;\n+\t    return DSE_STORE_LIVE;\n \n \t  temp = stmt;\n \t  break;\n \t}\n+\n+      if (byte_tracking_enabled && temp)\n+\tclear_bytes_written_by (live_bytes, temp, ref);\n     }\n-  /* Continue walking until we reach a kill.  */\n-  while (!stmt_kills_ref_p (temp, ref));\n+  /* Continue walking until we reach a full kill as a single statement\n+     or there are no more live bytes.  */\n+  while (!stmt_kills_ref_p (temp, ref)\n+\t && !(byte_tracking_enabled && bitmap_empty_p (live_bytes)));\n \n   *use_stmt = temp;\n+  return DSE_STORE_DEAD;\n+}\n+\n+\n+class dse_dom_walker : public dom_walker\n+{\n+public:\n+  dse_dom_walker (cdi_direction direction)\n+    : dom_walker (direction), m_byte_tracking_enabled (false)\n+\n+  { m_live_bytes = sbitmap_alloc (PARAM_VALUE (PARAM_DSE_MAX_OBJECT_SIZE)); }\n \n-  return true;\n+  ~dse_dom_walker () { sbitmap_free (m_live_bytes); }\n+\n+  virtual edge before_dom_children (basic_block);\n+\n+private:\n+  sbitmap m_live_bytes;\n+  bool m_byte_tracking_enabled;\n+  void dse_optimize_stmt (gimple_stmt_iterator *);\n+};\n+\n+/* Delete a dead call STMT, which is mem* call of some kind.  */\n+static void\n+delete_dead_call (gimple *stmt)\n+{\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"  Deleted dead call: \");\n+      print_gimple_stmt (dump_file, stmt, dump_flags, 0);\n+      fprintf (dump_file, \"\\n\");\n+    }\n+\n+  tree lhs = gimple_call_lhs (stmt);\n+  gimple_stmt_iterator gsi = gsi_for_stmt (stmt);\n+  if (lhs)\n+    {\n+      tree ptr = gimple_call_arg (stmt, 0);\n+      gimple *new_stmt = gimple_build_assign (lhs, ptr);\n+      unlink_stmt_vdef (stmt);\n+      if (gsi_replace (&gsi, new_stmt, true))\n+        bitmap_set_bit (need_eh_cleanup, gimple_bb (stmt)->index);\n+    }\n+  else\n+    {\n+      /* Then we need to fix the operand of the consuming stmt.  */\n+      unlink_stmt_vdef (stmt);\n+\n+      /* Remove the dead store.  */\n+      if (gsi_remove (&gsi, true))\n+\tbitmap_set_bit (need_eh_cleanup, gimple_bb (stmt)->index);\n+      release_defs (stmt);\n+    }\n }\n \n+/* Delete a dead store STMT, which is a gimple assignment. */\n+\n+static void\n+delete_dead_assignment (gimple *stmt)\n+{\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"  Deleted dead store: \");\n+      print_gimple_stmt (dump_file, stmt, dump_flags, 0);\n+      fprintf (dump_file, \"\\n\");\n+    }\n+\n+  /* Then we need to fix the operand of the consuming stmt.  */\n+  unlink_stmt_vdef (stmt);\n+\n+  /* Remove the dead store.  */\n+  gimple_stmt_iterator gsi = gsi_for_stmt (stmt);\n+  basic_block bb = gimple_bb (stmt);\n+  if (gsi_remove (&gsi, true))\n+    bitmap_set_bit (need_eh_cleanup, bb->index);\n+\n+  /* And release any SSA_NAMEs set in this statement back to the\n+     SSA_NAME manager.  */\n+  release_defs (stmt);\n+}\n \n /* Attempt to eliminate dead stores in the statement referenced by BSI.\n \n@@ -198,8 +513,8 @@ dse_possible_dead_store_p (ao_ref *ref, gimple *stmt, gimple **use_stmt)\n    is used precisely once by a later store to the same location which\n    post dominates the first store, then the first store is dead.  */\n \n-static void\n-dse_optimize_stmt (gimple_stmt_iterator *gsi)\n+void\n+dse_dom_walker::dse_optimize_stmt (gimple_stmt_iterator *gsi)\n {\n   gimple *stmt = gsi_stmt (*gsi);\n \n@@ -214,6 +529,10 @@ dse_optimize_stmt (gimple_stmt_iterator *gsi)\n \t  || TREE_CODE (gimple_assign_lhs (stmt)) != MEM_REF))\n     return;\n \n+  ao_ref ref;\n+  if (!initialize_ao_ref_for_dse (stmt, &ref))\n+    return;\n+\n   /* We know we have virtual definitions.  We can handle assignments and\n      some builtin calls.  */\n   if (gimple_call_builtin_p (stmt, BUILT_IN_NORMAL))\n@@ -225,42 +544,26 @@ dse_optimize_stmt (gimple_stmt_iterator *gsi)\n \t  case BUILT_IN_MEMSET:\n \t    {\n \t      gimple *use_stmt;\n-\t      ao_ref ref;\n-\t      tree size = NULL_TREE;\n-\t      if (gimple_call_num_args (stmt) == 3)\n-\t\tsize = gimple_call_arg (stmt, 2);\n-\t      tree ptr = gimple_call_arg (stmt, 0);\n-\t      ao_ref_init_from_ptr_and_size (&ref, ptr, size);\n-\t      if (!dse_possible_dead_store_p (&ref, stmt, &use_stmt))\n+\t      enum dse_store_status store_status;\n+\t      m_byte_tracking_enabled\n+\t\t= setup_live_bytes_from_ref (&ref, m_live_bytes);\n+\t      store_status = dse_classify_store (&ref, stmt, &use_stmt,\n+\t\t\t\t\t\t m_byte_tracking_enabled,\n+\t\t\t\t\t\t m_live_bytes);\n+\t      if (store_status == DSE_STORE_LIVE)\n \t\treturn;\n \n-\t      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t\t{\n-\t\t  fprintf (dump_file, \"  Deleted dead call: \");\n-\t\t  print_gimple_stmt (dump_file, gsi_stmt (*gsi), dump_flags, 0);\n-\t\t  fprintf (dump_file, \"\\n\");\n-\t\t}\n-\n-\t      tree lhs = gimple_call_lhs (stmt);\n-\t      if (lhs)\n+\t      if (store_status == DSE_STORE_MAYBE_PARTIAL_DEAD)\n \t\t{\n-\t\t  gimple *new_stmt = gimple_build_assign (lhs, ptr);\n-\t\t  unlink_stmt_vdef (stmt);\n-\t\t  if (gsi_replace (gsi, new_stmt, true))\n-\t\t    bitmap_set_bit (need_eh_cleanup, gimple_bb (stmt)->index);\n+\t\t  maybe_trim_partially_dead_store (&ref, m_live_bytes, stmt);\n+\t\t  return;\n \t\t}\n-\t      else\n-\t\t{\n-\t\t  /* Then we need to fix the operand of the consuming stmt.  */\n-\t\t  unlink_stmt_vdef (stmt);\n \n-\t\t  /* Remove the dead store.  */\n-\t\t  if (gsi_remove (gsi, true))\n-\t\t    bitmap_set_bit (need_eh_cleanup, gimple_bb (stmt)->index);\n-\t\t  release_defs (stmt);\n-\t\t}\n-\t      break;\n+\t      if (store_status == DSE_STORE_DEAD)\n+\t\tdelete_dead_call (stmt);\n+\t      return;\n \t    }\n+\n \t  default:\n \t    return;\n \t}\n@@ -276,10 +579,20 @@ dse_optimize_stmt (gimple_stmt_iterator *gsi)\n \tuse_stmt = stmt;\n       else\n \t{\n-\t  ao_ref ref;\n-\t  ao_ref_init (&ref, gimple_assign_lhs (stmt));\n-  \t  if (!dse_possible_dead_store_p (&ref, stmt, &use_stmt))\n+\t  m_byte_tracking_enabled\n+\t    = setup_live_bytes_from_ref (&ref, m_live_bytes);\n+\t  enum dse_store_status store_status;\n+\t  store_status = dse_classify_store (&ref, stmt, &use_stmt,\n+\t\t\t\t\t     m_byte_tracking_enabled,\n+\t\t\t\t\t     m_live_bytes);\n+\t  if (store_status == DSE_STORE_LIVE)\n \t    return;\n+\n+\t  if (store_status == DSE_STORE_MAYBE_PARTIAL_DEAD)\n+\t    {\n+\t      maybe_trim_partially_dead_store (&ref, m_live_bytes, stmt);\n+\t      return;\n+\t    }\n \t}\n \n       /* Now we know that use_stmt kills the LHS of stmt.  */\n@@ -290,35 +603,10 @@ dse_optimize_stmt (gimple_stmt_iterator *gsi)\n \t  && !gimple_clobber_p (use_stmt))\n \treturn;\n \n-      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t{\n-\t  fprintf (dump_file, \"  Deleted dead store: \");\n-\t  print_gimple_stmt (dump_file, gsi_stmt (*gsi), dump_flags, 0);\n-\t  fprintf (dump_file, \"\\n\");\n-\t}\n-\n-      /* Then we need to fix the operand of the consuming stmt.  */\n-      unlink_stmt_vdef (stmt);\n-\n-      /* Remove the dead store.  */\n-      basic_block bb = gimple_bb (stmt);\n-      if (gsi_remove (gsi, true))\n-\tbitmap_set_bit (need_eh_cleanup, bb->index);\n-\n-      /* And release any SSA_NAMEs set in this statement back to the\n-\t SSA_NAME manager.  */\n-      release_defs (stmt);\n+      delete_dead_assignment (stmt);\n     }\n }\n \n-class dse_dom_walker : public dom_walker\n-{\n-public:\n-  dse_dom_walker (cdi_direction direction) : dom_walker (direction) {}\n-\n-  virtual edge before_dom_children (basic_block);\n-};\n-\n edge\n dse_dom_walker::before_dom_children (basic_block bb)\n {\n@@ -391,7 +679,7 @@ pass_dse::execute (function *fun)\n     }\n \n   BITMAP_FREE (need_eh_cleanup);\n-    \n+\n   /* For now, just wipe the post-dominator information.  */\n   free_dominance_info (CDI_POST_DOMINATORS);\n   return 0;"}]}