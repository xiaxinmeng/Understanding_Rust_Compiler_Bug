{"sha": "2c58f7dde2bdb003105479ffe316cb7935b711c3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmM1OGY3ZGRlMmJkYjAwMzEwNTQ3OWZmZTMxNmNiNzkzNWI3MTFjMw==", "commit": {"author": {"name": "Richard Sandiford", "email": "rsandifo@redhat.com", "date": "2005-02-06T15:39:07Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2005-02-06T15:39:07Z"}, "message": "expmed.c (store_bit_field): Make the SUBREG code adjust bitnum.\n\n\t* expmed.c (store_bit_field): Make the SUBREG code adjust bitnum.\n\tSet bitpos and offset later in the function.  Do nothing if the\n\ttarget is a register and if the bitfield lies completely outside\n\tthat register.\n\t(extract_bit_field): Make the same SUBREG, bitpos and offset changes\n\there.  Return an uninitialised register if the source value is stored\n\tin a register and the bitfield lies completely outside that register.\n\nFrom-SVN: r94677", "tree": {"sha": "35c1f52210b03c333c66629497b389e5fbd9aefc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/35c1f52210b03c333c66629497b389e5fbd9aefc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2c58f7dde2bdb003105479ffe316cb7935b711c3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c58f7dde2bdb003105479ffe316cb7935b711c3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2c58f7dde2bdb003105479ffe316cb7935b711c3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c58f7dde2bdb003105479ffe316cb7935b711c3/comments", "author": null, "committer": null, "parents": [{"sha": "55c4ae3f3a80eda3855ccc64fa3064347a1dda01", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/55c4ae3f3a80eda3855ccc64fa3064347a1dda01", "html_url": "https://github.com/Rust-GCC/gccrs/commit/55c4ae3f3a80eda3855ccc64fa3064347a1dda01"}], "stats": {"total": 55, "additions": 42, "deletions": 13}, "files": [{"sha": "e02434e999df063381702a1a6fa559e5f31b3151", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c58f7dde2bdb003105479ffe316cb7935b711c3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c58f7dde2bdb003105479ffe316cb7935b711c3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2c58f7dde2bdb003105479ffe316cb7935b711c3", "patch": "@@ -1,3 +1,13 @@\n+2005-02-06  Richard Sandiford  <rsandifo@redhat.com>\n+\n+\t* expmed.c (store_bit_field): Make the SUBREG code adjust bitnum.\n+\tSet bitpos and offset later in the function.  Do nothing if the\n+\ttarget is a register and if the bitfield lies completely outside\n+\tthat register.\n+\t(extract_bit_field): Make the same SUBREG, bitpos and offset changes\n+\there.  Return an uninitialised register if the source value is stored\n+\tin a register and the bitfield lies completely outside that register.\n+\n 2005-02-06  Steven Bosscher  <stevenb@suse.de>\n \n \t* df.c (df_insn_refs_record): Use XEXP to get the operand of a USE,"}, {"sha": "1a1bdf74b048836756dbd6399fecee9734e2a494", "filename": "gcc/expmed.c", "status": "modified", "additions": 20, "deletions": 13, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c58f7dde2bdb003105479ffe316cb7935b711c3/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c58f7dde2bdb003105479ffe316cb7935b711c3/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=2c58f7dde2bdb003105479ffe316cb7935b711c3", "patch": "@@ -337,8 +337,7 @@ store_bit_field (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n {\n   unsigned int unit\n     = (MEM_P (str_rtx)) ? BITS_PER_UNIT : BITS_PER_WORD;\n-  unsigned HOST_WIDE_INT offset = bitnum / unit;\n-  unsigned HOST_WIDE_INT bitpos = bitnum % unit;\n+  unsigned HOST_WIDE_INT offset, bitpos;\n   rtx op0 = str_rtx;\n   int byte_offset;\n   rtx orig_value;\n@@ -352,12 +351,16 @@ store_bit_field (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \t meaningful at a much higher level; when structures are copied\n \t between memory and regs, the higher-numbered regs\n \t always get higher addresses.  */\n-      offset += (SUBREG_BYTE (op0) / UNITS_PER_WORD);\n-      /* We used to adjust BITPOS here, but now we do the whole adjustment\n-\t right after the loop.  */\n+      bitnum += SUBREG_BYTE (op0) * BITS_PER_UNIT;\n       op0 = SUBREG_REG (op0);\n     }\n \n+  /* No action is needed if the target is a register and if the field\n+     lies completely outside that register.  This can occur if the source\n+     code contains an out-of-bounds access to a small array.  */\n+  if (REG_P (op0) && bitnum >= GET_MODE_BITSIZE (GET_MODE (op0)))\n+    return value;\n+\n   /* Use vec_set patterns for inserting parts of vectors whenever\n      available.  */\n   if (VECTOR_MODE_P (GET_MODE (op0))\n@@ -419,6 +422,8 @@ store_bit_field (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n      done with a simple store.  For targets that support fast unaligned\n      memory, any naturally sized, unit aligned field can be done directly.  */\n \n+  offset = bitnum / unit;\n+  bitpos = bitnum % unit;\n   byte_offset = (bitnum % BITS_PER_WORD) / BITS_PER_UNIT\n                 + (offset * UNITS_PER_WORD);\n \n@@ -1064,8 +1069,7 @@ extract_bit_field (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n {\n   unsigned int unit\n     = (MEM_P (str_rtx)) ? BITS_PER_UNIT : BITS_PER_WORD;\n-  unsigned HOST_WIDE_INT offset = bitnum / unit;\n-  unsigned HOST_WIDE_INT bitpos = bitnum % unit;\n+  unsigned HOST_WIDE_INT offset, bitpos;\n   rtx op0 = str_rtx;\n   rtx spec_target = target;\n   rtx spec_target_subreg = 0;\n@@ -1080,15 +1084,16 @@ extract_bit_field (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \n   while (GET_CODE (op0) == SUBREG)\n     {\n-      bitpos += SUBREG_BYTE (op0) * BITS_PER_UNIT;\n-      if (bitpos > unit)\n-\t{\n-\t  offset += (bitpos / unit);\n-\t  bitpos %= unit;\n-\t}\n+      bitnum += SUBREG_BYTE (op0) * BITS_PER_UNIT;\n       op0 = SUBREG_REG (op0);\n     }\n \n+  /* If we have an out-of-bounds access to a register, just return an\n+     uninitialised register of the required mode.  This can occur if the\n+     source code contains an out-of-bounds access to a small array.  */\n+  if (REG_P (op0) && bitnum >= GET_MODE_BITSIZE (GET_MODE (op0)))\n+    return gen_reg_rtx (tmode);\n+\n   if (REG_P (op0)\n       && mode == GET_MODE (op0)\n       && bitnum == 0\n@@ -1188,6 +1193,8 @@ extract_bit_field (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n      can also be extracted with a SUBREG.  For this, we need the\n      byte offset of the value in op0.  */\n \n+  bitpos = bitnum % unit;\n+  offset = bitnum / unit;\n   byte_offset = bitpos / BITS_PER_UNIT + offset * UNITS_PER_WORD;\n \n   /* If OP0 is a register, BITPOS must count within a word."}, {"sha": "2dfc38fff8c2f5fc1c9cb24c821d76eb3b0526b5", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c58f7dde2bdb003105479ffe316cb7935b711c3/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c58f7dde2bdb003105479ffe316cb7935b711c3/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=2c58f7dde2bdb003105479ffe316cb7935b711c3", "patch": "@@ -1,3 +1,7 @@\n+2005-02-06  Richard Sandiford  <rsandifo@redhat.com>\n+\n+\t* gcc.c-torture/compile/20050206-1.c: New test.\n+\n 2005-02-03  Andrew Pinski  <pinskia@physics.uc.edu>\n \n \tPR tree-opt/19768"}, {"sha": "5ea49a6b2389ff43dcb57541d9031ce46cc74273", "filename": "gcc/testsuite/gcc.c-torture/compile/20050206-1.c", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c58f7dde2bdb003105479ffe316cb7935b711c3/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20050206-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c58f7dde2bdb003105479ffe316cb7935b711c3/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20050206-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20050206-1.c?ref=2c58f7dde2bdb003105479ffe316cb7935b711c3", "patch": "@@ -0,0 +1,8 @@\n+unsigned short foo (void)\n+{\n+  unsigned short u[1] = { 1 };\n+  u[0] = 0;\n+  u[1] = 1;\n+  u[2] = 2;\n+  return u[0] + u[1] + u[2];\n+}"}]}