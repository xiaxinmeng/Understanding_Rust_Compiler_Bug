{"sha": "d1b9a5724b8a05d2d2d51b3e5d13cc785326c74f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDFiOWE1NzI0YjhhMDVkMmQyZDUxYjNlNWQxM2NjNzg1MzI2Yzc0Zg==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2018-01-19T12:03:24Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2018-01-19T12:03:24Z"}, "message": "Fix usage of analyze_brprob.py script.\n\n2018-01-19  Martin Liska  <mliska@suse.cz>\n\n\t* analyze_brprob.py: Support new format that can be easily\n\tparsed. Add new column to report.\n2018-01-19  Martin Liska  <mliska@suse.cz>\n\n\t* predict.c (dump_prediction): Add new format for\n\tanalyze_brprob.py script which is enabled with -details\n\tsuboption.\n\t* profile-count.h (precise_p): New function.\n\nFrom-SVN: r256886", "tree": {"sha": "d863029ec8847f8c570a3e805a923100689efd40", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d863029ec8847f8c570a3e805a923100689efd40"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d1b9a5724b8a05d2d2d51b3e5d13cc785326c74f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d1b9a5724b8a05d2d2d51b3e5d13cc785326c74f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d1b9a5724b8a05d2d2d51b3e5d13cc785326c74f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d1b9a5724b8a05d2d2d51b3e5d13cc785326c74f/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "09a7858b2c53eccf28f780f5f3e4f2764f440eb1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/09a7858b2c53eccf28f780f5f3e4f2764f440eb1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/09a7858b2c53eccf28f780f5f3e4f2764f440eb1"}], "stats": {"total": 133, "additions": 102, "deletions": 31}, "files": [{"sha": "a88e2f06b508bee48c062c848c69911d823ad25b", "filename": "contrib/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1b9a5724b8a05d2d2d51b3e5d13cc785326c74f/contrib%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1b9a5724b8a05d2d2d51b3e5d13cc785326c74f/contrib%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2FChangeLog?ref=d1b9a5724b8a05d2d2d51b3e5d13cc785326c74f", "patch": "@@ -1,3 +1,8 @@\n+2018-01-19  Martin Liska  <mliska@suse.cz>\n+\n+\t* analyze_brprob.py: Support new format that can be easily\n+\tparsed. Add new column to report.\n+\n 2018-01-03  Jakub Jelinek  <jakub@redhat.com>\n \n \t* update-copyright.py: Skip pdt-5.f03 in gfortran.dg subdir."}, {"sha": "de5f474d6298c224cbd6000b601e5b18fb39650e", "filename": "contrib/analyze_brprob.py", "status": "modified", "additions": 72, "deletions": 31, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1b9a5724b8a05d2d2d51b3e5d13cc785326c74f/contrib%2Fanalyze_brprob.py", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1b9a5724b8a05d2d2d51b3e5d13cc785326c74f/contrib%2Fanalyze_brprob.py", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2Fanalyze_brprob.py?ref=d1b9a5724b8a05d2d2d51b3e5d13cc785326c74f", "patch": "@@ -71,6 +71,7 @@\n \n counter_aggregates = set(['combined', 'first match', 'DS theory',\n     'no prediction'])\n+hot_threshold = 10\n \n def percentage(a, b):\n     return 100.0 * a / b\n@@ -131,47 +132,87 @@ def parse_and_modify(self, heuristics, write_def_file):\n             with open(self.path, 'w+') as f:\n                 for l in modified_lines:\n                     f.write(l + '\\n')\n+class Heuristics:\n+    def __init__(self, count, hits, fits):\n+        self.count = count\n+        self.hits = hits\n+        self.fits = fits\n \n class Summary:\n     def __init__(self, name):\n         self.name = name\n-        self.branches = 0\n-        self.successfull_branches = 0\n-        self.count = 0\n-        self.hits = 0\n-        self.fits = 0\n+        self.edges= []\n+\n+    def branches(self):\n+        return len(self.edges)\n+\n+    def hits(self):\n+        return sum([x.hits for x in self.edges])\n+\n+    def fits(self):\n+        return sum([x.fits for x in self.edges])\n+\n+    def count(self):\n+        return sum([x.count for x in self.edges])\n+\n+    def successfull_branches(self):\n+        return len([x for x in self.edges if 2 * x.hits >= x.count])\n \n     def get_hitrate(self):\n-        return 100.0 * self.hits / self.count\n+        return 100.0 * self.hits() / self.count()\n \n     def get_branch_hitrate(self):\n-        return 100.0 * self.successfull_branches / self.branches\n+        return 100.0 * self.successfull_branches() / self.branches()\n \n     def count_formatted(self):\n-        v = self.count\n+        v = self.count()\n         for unit in ['', 'k', 'M', 'G', 'T', 'P', 'E', 'Z', 'Y']:\n             if v < 1000:\n                 return \"%3.2f%s\" % (v, unit)\n             v /= 1000.0\n         return \"%.1f%s\" % (v, 'Y')\n \n+    def count(self):\n+        return sum([x.count for x in self.edges])\n+\n     def print(self, branches_max, count_max, predict_def):\n+        # filter out most hot edges (if requested)\n+        self.edges = sorted(self.edges, reverse = True, key = lambda x: x.count)\n+        if args.coverage_threshold != None:\n+            threshold = args.coverage_threshold * self.count() / 100\n+            edges = [x for x in self.edges if x.count < threshold]\n+            if len(edges) != 0:\n+                self.edges = edges\n+\n         predicted_as = None\n         if predict_def != None and self.name in predict_def.predictors:\n             predicted_as = predict_def.predictors[self.name]\n \n         print('%-40s %8i %5.1f%% %11.2f%% %7.2f%% / %6.2f%% %14i %8s %5.1f%%' %\n-            (self.name, self.branches,\n-                percentage(self.branches, branches_max),\n+            (self.name, self.branches(),\n+                percentage(self.branches(), branches_max),\n                 self.get_branch_hitrate(),\n                 self.get_hitrate(),\n-                percentage(self.fits, self.count),\n-                self.count, self.count_formatted(),\n-                percentage(self.count, count_max)), end = '')\n+                percentage(self.fits(), self.count()),\n+                self.count(), self.count_formatted(),\n+                percentage(self.count(), count_max)), end = '')\n \n         if predicted_as != None:\n             print('%12i%% %5.1f%%' % (predicted_as,\n                 self.get_hitrate() - predicted_as), end = '')\n+        else:\n+            print(' ' * 20, end = '')\n+\n+        # print details about the most important edges\n+        if args.coverage_threshold == None:\n+            edges = [x for x in self.edges[:100] if x.count * hot_threshold > self.count()]\n+            if args.verbose:\n+                for c in edges:\n+                    r = 100.0 * c.count / self.count()\n+                    print(' %.0f%%:%d' % (r, c.count), end = '')\n+            elif len(edges) > 0:\n+                print(' %0.0f%%:%d' % (100.0 * sum([x.count for x in edges]) / self.count(), len(edges)), end = '')\n+\n         print()\n \n class Profile:\n@@ -185,33 +226,29 @@ def add(self, name, prediction, count, hits):\n             self.heuristics[name] = Summary(name)\n \n         s = self.heuristics[name]\n-        s.branches += 1\n \n-        s.count += count\n         if prediction < 50:\n             hits = count - hits\n         remaining = count - hits\n-        if hits >= remaining:\n-            s.successfull_branches += 1\n+        fits = max(hits, remaining)\n \n-        s.hits += hits\n-        s.fits += max(hits, remaining)\n+        s.edges.append(Heuristics(count, hits, fits))\n \n     def add_loop_niter(self, niter):\n         if niter > 0:\n             self.niter_vector.append(niter)\n \n     def branches_max(self):\n-        return max([v.branches for k, v in self.heuristics.items()])\n+        return max([v.branches() for k, v in self.heuristics.items()])\n \n     def count_max(self):\n-        return max([v.count for k, v in self.heuristics.items()])\n+        return max([v.count() for k, v in self.heuristics.items()])\n \n     def print_group(self, sorting, group_name, heuristics, predict_def):\n         count_max = self.count_max()\n         branches_max = self.branches_max()\n \n-        sorter = lambda x: x.branches\n+        sorter = lambda x: x.branches()\n         if sorting == 'branch-hitrate':\n             sorter = lambda x: x.get_branch_hitrate()\n         elif sorting == 'hitrate':\n@@ -221,10 +258,10 @@ def print_group(self, sorting, group_name, heuristics, predict_def):\n         elif sorting == 'name':\n             sorter = lambda x: x.name.lower()\n \n-        print('%-40s %8s %6s %12s %18s %14s %8s %6s %12s %6s' %\n+        print('%-40s %8s %6s %12s %18s %14s %8s %6s %12s %6s %s' %\n             ('HEURISTICS', 'BRANCHES', '(REL)',\n             'BR. HITRATE', 'HITRATE', 'COVERAGE', 'COVERAGE', '(REL)',\n-            'predict.def', '(REL)'))\n+            'predict.def', '(REL)', 'HOT branches (>%d%%)' % hot_threshold))\n         for h in sorted(heuristics, key = sorter):\n             h.print(branches_max, count_max, predict_def)\n \n@@ -266,19 +303,23 @@ def dump(self, sorting):\n parser.add_argument('-d', '--def-file', help = 'path to predict.def')\n parser.add_argument('-w', '--write-def-file', action = 'store_true',\n     help = 'Modify predict.def file in order to set new numbers')\n+parser.add_argument('-c', '--coverage-threshold', type = int,\n+    help = 'Ignore edges that have percentage coverage >= coverage-threshold')\n+parser.add_argument('-v', '--verbose', action = 'store_true', help = 'Print verbose informations')\n \n args = parser.parse_args()\n \n profile = Profile(args.dump_file)\n-r = re.compile('  (.*) heuristics( of edge [0-9]*->[0-9]*)?( \\\\(.*\\\\))?: (.*)%.*exec ([0-9]*) hit ([0-9]*)')\n loop_niter_str = ';;  profile-based iteration count: '\n+\n for l in open(args.dump_file):\n-    m = r.match(l)\n-    if m != None and m.group(3) == None:\n-        name = m.group(1)\n-        prediction = float(m.group(4))\n-        count = int(m.group(5))\n-        hits = int(m.group(6))\n+    if l.startswith(';;heuristics;'):\n+        parts = l.strip().split(';')\n+        assert len(parts) == 8\n+        name = parts[3]\n+        prediction = float(parts[6])\n+        count = int(parts[4])\n+        hits = int(parts[5])\n \n         profile.add(name, prediction, count, hits)\n     elif l.startswith(loop_niter_str):"}, {"sha": "5ea286f46e6bf44aedce3f10533af37eebe07e1c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1b9a5724b8a05d2d2d51b3e5d13cc785326c74f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1b9a5724b8a05d2d2d51b3e5d13cc785326c74f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d1b9a5724b8a05d2d2d51b3e5d13cc785326c74f", "patch": "@@ -1,3 +1,10 @@\n+2018-01-19  Martin Liska  <mliska@suse.cz>\n+\n+\t* predict.c (dump_prediction): Add new format for\n+\tanalyze_brprob.py script which is enabled with -details\n+\tsuboption.\n+\t* profile-count.h (precise_p): New function.\n+\n 2018-01-19  Richard Sandiford  <richard.sandiford@linaro.org>\n \n \tPR tree-optimization/83922"}, {"sha": "fdf5d824459c85f414d3bd9c5bbcbbd3e4db3136", "filename": "gcc/predict.c", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1b9a5724b8a05d2d2d51b3e5d13cc785326c74f/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1b9a5724b8a05d2d2d51b3e5d13cc785326c74f/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=d1b9a5724b8a05d2d2d51b3e5d13cc785326c74f", "patch": "@@ -747,6 +747,19 @@ dump_prediction (FILE *file, enum br_predictor predictor, int probability,\n     }\n \n   fprintf (file, \"\\n\");\n+\n+  /* Print output that be easily read by analyze_brprob.py script. We are\n+     interested only in counts that are read from GCDA files.  */\n+  if (dump_file && (dump_flags & TDF_DETAILS)\n+      && bb->count.precise_p ()\n+      && reason == REASON_NONE)\n+    {\n+      gcc_assert (e->count ().precise_p ());\n+      fprintf (file, \";;heuristics;%s;%\" PRId64 \";%\" PRId64 \";%.1f;\\n\",\n+\t       predictor_info[predictor].name,\n+\t       bb->count.to_gcov_type (), e->count ().to_gcov_type (),\n+\t       probability * 100.0 / REG_BR_PROB_BASE);\n+    }\n }\n \n /* Return true if STMT is known to be unlikely executed.  */"}, {"sha": "03e6635f0da12df7eb4db92b0ac3d8134cb2499b", "filename": "gcc/profile-count.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1b9a5724b8a05d2d2d51b3e5d13cc785326c74f/gcc%2Fprofile-count.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1b9a5724b8a05d2d2d51b3e5d13cc785326c74f/gcc%2Fprofile-count.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile-count.h?ref=d1b9a5724b8a05d2d2d51b3e5d13cc785326c74f", "patch": "@@ -691,6 +691,11 @@ class GTY(()) profile_count\n     {\n       return !initialized_p () || m_quality >= profile_guessed_global0;\n     }\n+  /* Return true if quality of profile is precise.  */\n+  bool precise_p () const\n+    {\n+      return m_quality == profile_precise;\n+    }\n \n   /* When merging basic blocks, the two different profile counts are unified.\n      Return true if this can be done without losing info about profile."}]}