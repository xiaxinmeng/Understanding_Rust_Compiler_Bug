{"sha": "d8fcab689435a29dba2862693689c624b257d1bf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDhmY2FiNjg5NDM1YTI5ZGJhMjg2MjY5MzY4OWM2MjRiMjU3ZDFiZg==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2019-01-07T08:49:08Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2019-01-07T08:49:08Z"}, "message": "re PR c++/85052 (Implement support for clang's __builtin_convertvector)\n\n\tPR c++/85052\n\t* tree-vect-generic.c: Include insn-config.h and recog.h.\n\t(expand_vector_piecewise): Add defaulted ret_type argument,\n\tif non-NULL, use that in preference to type for the result type.\n\t(expand_vector_parallel): Formatting fix.\n\t(do_vec_conversion, do_vec_narrowing_conversion,\n\texpand_vector_conversion): New functions.\n\t(expand_vector_operations_1): Call expand_vector_conversion\n\tfor VEC_CONVERT ifn calls.\n\t* internal-fn.def (VEC_CONVERT): New internal function.\n\t* internal-fn.c (expand_VEC_CONVERT): New function.\n\t* fold-const-call.c (fold_const_vec_convert): New function.\n\t(fold_const_call): Use it for CFN_VEC_CONVERT.\n\t* doc/extend.texi (__builtin_convertvector): Document.\nc-family/\n\t* c-common.h (enum rid): Add RID_BUILTIN_CONVERTVECTOR.\n\t(c_build_vec_convert): Declare.\n\t* c-common.c (c_build_vec_convert): New function.\nc/\n\t* c-parser.c (c_parser_postfix_expression): Parse\n\t__builtin_convertvector.\ncp/\n\t* cp-tree.h (cp_build_vec_convert): Declare.\n\t* parser.c (cp_parser_postfix_expression): Parse\n\t__builtin_convertvector.\n\t* constexpr.c: Include fold-const-call.h.\n\t(cxx_eval_internal_function): Handle IFN_VEC_CONVERT.\n\t(potential_constant_expression_1): Likewise.\n\t* semantics.c (cp_build_vec_convert): New function.\n\t* pt.c (tsubst_copy_and_build): Handle CALL_EXPR to\n\tIFN_VEC_CONVERT.\ntestsuite/\n\t* c-c++-common/builtin-convertvector-1.c: New test.\n\t* c-c++-common/torture/builtin-convertvector-1.c: New test.\n\t* g++.dg/ext/builtin-convertvector-1.C: New test.\n\t* g++.dg/cpp0x/constexpr-builtin4.C: New test.\n\nFrom-SVN: r267632", "tree": {"sha": "3ebde208f2b05c57fa2ce4a941e6c4e7811e82c3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3ebde208f2b05c57fa2ce4a941e6c4e7811e82c3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d8fcab689435a29dba2862693689c624b257d1bf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d8fcab689435a29dba2862693689c624b257d1bf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d8fcab689435a29dba2862693689c624b257d1bf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d8fcab689435a29dba2862693689c624b257d1bf/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f881693c53374c743d3b5d1561708a64dcfe7eb6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f881693c53374c743d3b5d1561708a64dcfe7eb6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f881693c53374c743d3b5d1561708a64dcfe7eb6"}], "stats": {"total": 950, "additions": 933, "deletions": 17}, "files": [{"sha": "25660bd1c8aa92ec124789344443388b166409f2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8fcab689435a29dba2862693689c624b257d1bf/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8fcab689435a29dba2862693689c624b257d1bf/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d8fcab689435a29dba2862693689c624b257d1bf", "patch": "@@ -1,3 +1,20 @@\n+2019-01-07  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR c++/85052\n+\t* tree-vect-generic.c: Include insn-config.h and recog.h.\n+\t(expand_vector_piecewise): Add defaulted ret_type argument,\n+\tif non-NULL, use that in preference to type for the result type.\n+\t(expand_vector_parallel): Formatting fix.\n+\t(do_vec_conversion, do_vec_narrowing_conversion,\n+\texpand_vector_conversion): New functions.\n+\t(expand_vector_operations_1): Call expand_vector_conversion\n+\tfor VEC_CONVERT ifn calls.\n+\t* internal-fn.def (VEC_CONVERT): New internal function.\n+\t* internal-fn.c (expand_VEC_CONVERT): New function.\n+\t* fold-const-call.c (fold_const_vec_convert): New function.\n+\t(fold_const_call): Use it for CFN_VEC_CONVERT.\n+\t* doc/extend.texi (__builtin_convertvector): Document.\n+\n 2019-01-07  Tom de Vries  <tdevries@suse.de>\n \n \t* config/nvptx/nvptx-protos.h (nvptx_output_red_partition): Declare."}, {"sha": "a7b56ff18e9fd89c81b67e148191e31a533ad15e", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8fcab689435a29dba2862693689c624b257d1bf/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8fcab689435a29dba2862693689c624b257d1bf/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=d8fcab689435a29dba2862693689c624b257d1bf", "patch": "@@ -1,3 +1,10 @@\n+2019-01-07  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR c++/85052\n+\t* c-common.h (enum rid): Add RID_BUILTIN_CONVERTVECTOR.\n+\t(c_build_vec_convert): Declare.\n+\t* c-common.c (c_build_vec_convert): New function.\n+\n 2019-01-04  Martin Sebor  <msebor@redhat.com>\n \n \tPR c/88546"}, {"sha": "d2ea384d65328b27c59e7e55659b8936127a8a0e", "filename": "gcc/c-family/c-common.c", "status": "modified", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8fcab689435a29dba2862693689c624b257d1bf/gcc%2Fc-family%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8fcab689435a29dba2862693689c624b257d1bf/gcc%2Fc-family%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.c?ref=d8fcab689435a29dba2862693689c624b257d1bf", "patch": "@@ -376,6 +376,7 @@ const struct c_common_resword c_common_reswords[] =\n     RID_BUILTIN_CALL_WITH_STATIC_CHAIN, D_CONLY },\n   { \"__builtin_choose_expr\", RID_CHOOSE_EXPR, D_CONLY },\n   { \"__builtin_complex\", RID_BUILTIN_COMPLEX, D_CONLY },\n+  { \"__builtin_convertvector\", RID_BUILTIN_CONVERTVECTOR, 0 },\n   { \"__builtin_has_attribute\", RID_BUILTIN_HAS_ATTRIBUTE, 0 },\n   { \"__builtin_launder\", RID_BUILTIN_LAUNDER, D_CXXONLY },\n   { \"__builtin_shuffle\", RID_BUILTIN_SHUFFLE, 0 },\n@@ -1072,6 +1073,70 @@ c_build_vec_perm_expr (location_t loc, tree v0, tree v1, tree mask,\n   return ret;\n }\n \n+/* Build a VEC_CONVERT ifn for __builtin_convertvector builtin.  */\n+\n+tree\n+c_build_vec_convert (location_t loc1, tree expr, location_t loc2, tree type,\n+\t\t     bool complain)\n+{\n+  if (error_operand_p (type))\n+    return error_mark_node;\n+  if (error_operand_p (expr))\n+    return error_mark_node;\n+\n+  if (!VECTOR_INTEGER_TYPE_P (TREE_TYPE (expr))\n+      && !VECTOR_FLOAT_TYPE_P (TREE_TYPE (expr)))\n+    {\n+      if (complain)\n+\terror_at (loc1, \"%<__builtin_convertvector%> first argument must \"\n+\t\t\t\"be an integer or floating vector\");\n+      return error_mark_node;\n+    }\n+\n+  if (!VECTOR_INTEGER_TYPE_P (type) && !VECTOR_FLOAT_TYPE_P (type))\n+    {\n+      if (complain)\n+\terror_at (loc2, \"%<__builtin_convertvector%> second argument must \"\n+\t\t\t\"be an integer or floating vector type\");\n+      return error_mark_node;\n+    }\n+\n+  if (maybe_ne (TYPE_VECTOR_SUBPARTS (TREE_TYPE (expr)),\n+\t\tTYPE_VECTOR_SUBPARTS (type)))\n+    {\n+      if (complain)\n+\terror_at (loc1, \"%<__builtin_convertvector%> number of elements \"\n+\t\t\t\"of the first argument vector and the second argument \"\n+\t\t\t\"vector type should be the same\");\n+      return error_mark_node;\n+    }\n+\n+  if ((TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (expr)))\n+       == TYPE_MAIN_VARIANT (TREE_TYPE (type)))\n+      || (VECTOR_INTEGER_TYPE_P (TREE_TYPE (expr))\n+\t  && VECTOR_INTEGER_TYPE_P (type)\n+\t  && (TYPE_PRECISION (TREE_TYPE (TREE_TYPE (expr)))\n+\t      == TYPE_PRECISION (TREE_TYPE (type)))))\n+    return build1_loc (loc1, VIEW_CONVERT_EXPR, type, expr);\n+\n+  bool wrap = true;\n+  bool maybe_const = false;\n+  tree ret;\n+  if (!c_dialect_cxx ())\n+    {\n+      /* Avoid C_MAYBE_CONST_EXPRs inside of VEC_CONVERT argument.  */\n+      expr = c_fully_fold (expr, false, &maybe_const);\n+      wrap &= maybe_const;\n+    }\n+\n+  ret = build_call_expr_internal_loc (loc1, IFN_VEC_CONVERT, type, 1, expr);\n+\n+  if (!wrap)\n+    ret = c_wrap_maybe_const (ret, true);\n+\n+  return ret;\n+}\n+\n /* Like tree.c:get_narrower, but retain conversion from C++0x scoped enum\n    to integral type.  */\n "}, {"sha": "db16ae94b64c97fdceef1087f03c4e96b749d473", "filename": "gcc/c-family/c-common.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8fcab689435a29dba2862693689c624b257d1bf/gcc%2Fc-family%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8fcab689435a29dba2862693689c624b257d1bf/gcc%2Fc-family%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.h?ref=d8fcab689435a29dba2862693689c624b257d1bf", "patch": "@@ -102,7 +102,7 @@ enum rid\n   RID_ASM,       RID_TYPEOF,   RID_ALIGNOF,  RID_ATTRIBUTE,  RID_VA_ARG,\n   RID_EXTENSION, RID_IMAGPART, RID_REALPART, RID_LABEL,      RID_CHOOSE_EXPR,\n   RID_TYPES_COMPATIBLE_P,      RID_BUILTIN_COMPLEX,\t     RID_BUILTIN_SHUFFLE,\n-  RID_BUILTIN_TGMATH,\n+  RID_BUILTIN_CONVERTVECTOR,   RID_BUILTIN_TGMATH,\n   RID_BUILTIN_HAS_ATTRIBUTE,\n   RID_DFLOAT32, RID_DFLOAT64, RID_DFLOAT128,\n \n@@ -1001,6 +1001,7 @@ extern bool lvalue_p (const_tree);\n extern bool vector_targets_convertible_p (const_tree t1, const_tree t2);\n extern bool vector_types_convertible_p (const_tree t1, const_tree t2, bool emit_lax_note);\n extern tree c_build_vec_perm_expr (location_t, tree, tree, tree, bool = true);\n+extern tree c_build_vec_convert (location_t, tree, location_t, tree, bool = true);\n \n extern void init_c_lex (void);\n "}, {"sha": "fbd94f5607c9d30db099a569c61eedfc529106d8", "filename": "gcc/c/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8fcab689435a29dba2862693689c624b257d1bf/gcc%2Fc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8fcab689435a29dba2862693689c624b257d1bf/gcc%2Fc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FChangeLog?ref=d8fcab689435a29dba2862693689c624b257d1bf", "patch": "@@ -1,3 +1,9 @@\n+2019-01-07  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR c++/85052\n+\t* c-parser.c (c_parser_postfix_expression): Parse\n+\t__builtin_convertvector.\n+\n 2019-01-01  Jakub Jelinek  <jakub@redhat.com>\n \n \tUpdate copyright years."}, {"sha": "76f314e119056544ac365d740459e443f5c6c715", "filename": "gcc/c/c-parser.c", "status": "modified", "additions": 42, "deletions": 9, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8fcab689435a29dba2862693689c624b257d1bf/gcc%2Fc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8fcab689435a29dba2862693689c624b257d1bf/gcc%2Fc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-parser.c?ref=d8fcab689435a29dba2862693689c624b257d1bf", "patch": "@@ -8038,6 +8038,7 @@ enum tgmath_parm_kind\n      __builtin_shuffle ( assignment-expression ,\n \t\t\t assignment-expression ,\n \t\t\t assignment-expression, )\n+     __builtin_convertvector ( assignment-expression , type-name )\n \n    offsetof-member-designator:\n      identifier\n@@ -9113,17 +9114,14 @@ c_parser_postfix_expression (c_parser *parser)\n \t      *p = convert_lvalue_to_rvalue (loc, *p, true, true);\n \n \t    if (vec_safe_length (cexpr_list) == 2)\n-\t      expr.value =\n-\t\tc_build_vec_perm_expr\n-\t\t  (loc, (*cexpr_list)[0].value,\n-\t\t   NULL_TREE, (*cexpr_list)[1].value);\n+\t      expr.value = c_build_vec_perm_expr (loc, (*cexpr_list)[0].value,\n+\t\t\t\t\t\t  NULL_TREE,\n+\t\t\t\t\t\t  (*cexpr_list)[1].value);\n \n \t    else if (vec_safe_length (cexpr_list) == 3)\n-\t      expr.value =\n-\t\tc_build_vec_perm_expr\n-\t\t  (loc, (*cexpr_list)[0].value,\n-\t\t   (*cexpr_list)[1].value,\n-\t\t   (*cexpr_list)[2].value);\n+\t      expr.value = c_build_vec_perm_expr (loc, (*cexpr_list)[0].value,\n+\t\t\t\t\t\t  (*cexpr_list)[1].value,\n+\t\t\t\t\t\t  (*cexpr_list)[2].value);\n \t    else\n \t      {\n \t\terror_at (loc, \"wrong number of arguments to \"\n@@ -9133,6 +9131,41 @@ c_parser_postfix_expression (c_parser *parser)\n \t    set_c_expr_source_range (&expr, loc, close_paren_loc);\n \t    break;\n \t  }\n+\tcase RID_BUILTIN_CONVERTVECTOR:\n+\t  {\n+\t    location_t start_loc = loc;\n+\t    c_parser_consume_token (parser);\n+\t    matching_parens parens;\n+\t    if (!parens.require_open (parser))\n+\t      {\n+\t\texpr.set_error ();\n+\t\tbreak;\n+\t      }\n+\t    e1 = c_parser_expr_no_commas (parser, NULL);\n+\t    mark_exp_read (e1.value);\n+\t    if (!c_parser_require (parser, CPP_COMMA, \"expected %<,%>\"))\n+\t      {\n+\t\tc_parser_skip_until_found (parser, CPP_CLOSE_PAREN, NULL);\n+\t\texpr.set_error ();\n+\t\tbreak;\n+\t      }\n+\t    loc = c_parser_peek_token (parser)->location;\n+\t    t1 = c_parser_type_name (parser);\n+\t    location_t end_loc = c_parser_peek_token (parser)->get_finish ();\n+\t    c_parser_skip_until_found (parser, CPP_CLOSE_PAREN,\n+\t\t\t\t       \"expected %<)%>\");\n+\t    if (t1 == NULL)\n+\t      expr.set_error ();\n+\t    else\n+\t      {\n+\t\ttree type_expr = NULL_TREE;\n+\t\texpr.value = c_build_vec_convert (start_loc, e1.value, loc,\n+\t\t\t\t\t\t  groktypename (t1, &type_expr,\n+\t\t\t\t\t\t\t\tNULL));\n+\t\tset_c_expr_source_range (&expr, start_loc, end_loc);\n+\t      }\n+\t  }\n+\t  break;\n \tcase RID_AT_SELECTOR:\n \t  {\n \t    gcc_assert (c_dialect_objc ());"}, {"sha": "cbb70140c6999efd76cd1a32b4813c9f878fb8be", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8fcab689435a29dba2862693689c624b257d1bf/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8fcab689435a29dba2862693689c624b257d1bf/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=d8fcab689435a29dba2862693689c624b257d1bf", "patch": "@@ -1,3 +1,16 @@\n+2019-01-07  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR c++/85052\n+\t* cp-tree.h (cp_build_vec_convert): Declare.\n+\t* parser.c (cp_parser_postfix_expression): Parse\n+\t__builtin_convertvector.\n+\t* constexpr.c: Include fold-const-call.h.\n+\t(cxx_eval_internal_function): Handle IFN_VEC_CONVERT.\n+\t(potential_constant_expression_1): Likewise.\n+\t* semantics.c (cp_build_vec_convert): New function.\n+\t* pt.c (tsubst_copy_and_build): Handle CALL_EXPR to\n+\tIFN_VEC_CONVERT.\n+\n 2019-01-03  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c++/88636"}, {"sha": "ed4bbeeb157878bd08721820fc46444dc80dca8b", "filename": "gcc/cp/constexpr.c", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8fcab689435a29dba2862693689c624b257d1bf/gcc%2Fcp%2Fconstexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8fcab689435a29dba2862693689c624b257d1bf/gcc%2Fcp%2Fconstexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstexpr.c?ref=d8fcab689435a29dba2862693689c624b257d1bf", "patch": "@@ -33,6 +33,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"ubsan.h\"\n #include \"gimple-fold.h\"\n #include \"timevar.h\"\n+#include \"fold-const-call.h\"\n \n static bool verify_constant (tree, bool, bool *, bool *);\n #define VERIFY_CONSTANT(X)\t\t\t\t\t\t\\\n@@ -1449,6 +1450,20 @@ cxx_eval_internal_function (const constexpr_ctx *ctx, tree t,\n       return cxx_eval_constant_expression (ctx, CALL_EXPR_ARG (t, 0),\n \t\t\t\t\t   false, non_constant_p, overflow_p);\n \n+    case IFN_VEC_CONVERT:\n+      {\n+\ttree arg = cxx_eval_constant_expression (ctx, CALL_EXPR_ARG (t, 0),\n+\t\t\t\t\t\t false, non_constant_p,\n+\t\t\t\t\t\t overflow_p);\n+\tif (TREE_CODE (arg) == VECTOR_CST)\n+\t  return fold_const_call (CFN_VEC_CONVERT, TREE_TYPE (t), arg);\n+\telse\n+\t  {\n+\t    *non_constant_p = true;\n+\t    return t;\n+\t  }\n+      }\n+\n     default:\n       if (!ctx->quiet)\n \terror_at (cp_expr_loc_or_loc (t, input_location),\n@@ -5623,7 +5638,9 @@ potential_constant_expression_1 (tree t, bool want_rval, bool strict, bool now,\n \t\tcase IFN_SUB_OVERFLOW:\n \t\tcase IFN_MUL_OVERFLOW:\n \t\tcase IFN_LAUNDER:\n+\t\tcase IFN_VEC_CONVERT:\n \t\t  bail = false;\n+\t\t  break;\n \n \t\tdefault:\n \t\t  break;"}, {"sha": "794849b50662ccb2fa1dab19fc1f0eac28181e39", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8fcab689435a29dba2862693689c624b257d1bf/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8fcab689435a29dba2862693689c624b257d1bf/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=d8fcab689435a29dba2862693689c624b257d1bf", "patch": "@@ -7142,6 +7142,8 @@ extern bool is_lambda_ignored_entity            (tree);\n extern bool lambda_static_thunk_p\t\t(tree);\n extern tree finish_builtin_launder\t\t(location_t, tree,\n \t\t\t\t\t\t tsubst_flags_t);\n+extern tree cp_build_vec_convert\t\t(tree, location_t, tree,\n+\t\t\t\t\t\t tsubst_flags_t);\n extern void start_lambda_scope\t\t\t(tree);\n extern void record_lambda_scope\t\t\t(tree);\n extern void record_null_lambda_scope\t\t(tree);"}, {"sha": "bca1739ace39cc769e29372e6be8ef97cc1d3a0f", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8fcab689435a29dba2862693689c624b257d1bf/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8fcab689435a29dba2862693689c624b257d1bf/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=d8fcab689435a29dba2862693689c624b257d1bf", "patch": "@@ -7031,6 +7031,32 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p, bool cast_p,\n \tbreak;\n       }\n \n+    case RID_BUILTIN_CONVERTVECTOR:\n+      {\n+\ttree expression;\n+\ttree type;\n+\t/* Consume the `__builtin_convertvector' token.  */\n+\tcp_lexer_consume_token (parser->lexer);\n+\t/* Look for the opening `('.  */\n+\tmatching_parens parens;\n+\tparens.require_open (parser);\n+\t/* Now, parse the assignment-expression.  */\n+\texpression = cp_parser_assignment_expression (parser);\n+\t/* Look for the `,'.  */\n+\tcp_parser_require (parser, CPP_COMMA, RT_COMMA);\n+\tlocation_t type_location\n+\t  = cp_lexer_peek_token (parser->lexer)->location;\n+\t/* Parse the type-id.  */\n+\t{\n+\t  type_id_in_expr_sentinel s (parser);\n+\t  type = cp_parser_type_id (parser);\n+\t}\n+\t/* Look for the closing `)'.  */\n+\tparens.require_close (parser);\n+\treturn cp_build_vec_convert (expression, type_location, type,\n+\t\t\t\t     tf_warning_or_error);\n+      }\n+\n     default:\n       {\n \ttree type;"}, {"sha": "e216ef5037810fc46b3ed54bcc9e7dfe5aefb79d", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8fcab689435a29dba2862693689c624b257d1bf/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8fcab689435a29dba2862693689c624b257d1bf/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=d8fcab689435a29dba2862693689c624b257d1bf", "patch": "@@ -18813,6 +18813,27 @@ tsubst_copy_and_build (tree t,\n \t\t\t\t\t      (*call_args)[0], complain);\n \t      break;\n \n+\t    case IFN_VEC_CONVERT:\n+\t      gcc_assert (nargs == 1);\n+\t      if (vec_safe_length (call_args) != 1)\n+\t\t{\n+\t\t  error_at (cp_expr_loc_or_loc (t, input_location),\n+\t\t\t    \"wrong number of arguments to \"\n+\t\t\t    \"%<__builtin_convertvector%>\");\n+\t\t  ret = error_mark_node;\n+\t\t  break;\n+\t\t}\n+\t      ret = cp_build_vec_convert ((*call_args)[0], input_location,\n+\t\t\t\t\t  tsubst (TREE_TYPE (t), args,\n+\t\t\t\t\t\t  complain, in_decl),\n+\t\t\t\t\t  complain);\n+\t      if (TREE_CODE (ret) == VIEW_CONVERT_EXPR)\n+\t\t{\n+\t\t  release_tree_vector (call_args);\n+\t\t  RETURN (ret);\n+\t\t}\n+\t      break;\n+\n \t    default:\n \t      /* Unsupported internal function with arguments.  */\n \t      gcc_unreachable ();"}, {"sha": "bc9d53800f7cd2e76c483262455ce3ed094177be", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8fcab689435a29dba2862693689c624b257d1bf/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8fcab689435a29dba2862693689c624b257d1bf/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=d8fcab689435a29dba2862693689c624b257d1bf", "patch": "@@ -9933,4 +9933,26 @@ finish_builtin_launder (location_t loc, tree arg, tsubst_flags_t complain)\n \t\t\t\t       TREE_TYPE (arg), 1, arg);\n }\n \n+/* Finish __builtin_convertvector (arg, type).  */\n+\n+tree\n+cp_build_vec_convert (tree arg, location_t loc, tree type,\n+\t\t      tsubst_flags_t complain)\n+{\n+  if (error_operand_p (type))\n+    return error_mark_node;\n+  if (error_operand_p (arg))\n+    return error_mark_node;\n+\n+  tree ret = NULL_TREE;\n+  if (!type_dependent_expression_p (arg) && !dependent_type_p (type))\n+    ret = c_build_vec_convert (cp_expr_loc_or_loc (arg, input_location), arg,\n+\t\t\t       loc, type, (complain & tf_error) != 0);\n+\n+  if (!processing_template_decl)\n+    return ret;\n+\n+  return build_call_expr_internal_loc (loc, IFN_VEC_CONVERT, type, 1, arg);\n+}\n+\n #include \"gt-cp-semantics.h\""}, {"sha": "7f33be4f29c118fd856051f3e7235b5ad7eb85b7", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8fcab689435a29dba2862693689c624b257d1bf/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8fcab689435a29dba2862693689c624b257d1bf/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=d8fcab689435a29dba2862693689c624b257d1bf", "patch": "@@ -10596,6 +10596,33 @@ to and from other datatypes of the same size).\n You cannot operate between vectors of different lengths or different\n signedness without a cast.\n \n+@findex __builtin_convertvector\n+Vector conversion is available using the\n+@code{__builtin_convertvector (vec, vectype)}\n+function.  @var{vec} must be an expression with integral or floating\n+vector type and @var{vectype} an integral or floating vector type with the\n+same number of elements.  The result has @var{vectype} type and value of\n+a C cast of every element of @var{vec} to the element type of @var{vectype}.\n+\n+Consider the following example,\n+@smallexample\n+typedef int v4si __attribute__ ((vector_size (16)));\n+typedef float v4sf __attribute__ ((vector_size (16)));\n+typedef double v4df __attribute__ ((vector_size (32)));\n+typedef unsigned long long v4di __attribute__ ((vector_size (32)));\n+\n+v4si a = @{1,-2,3,-4@};\n+v4sf b = @{1.5f,-2.5f,3.f,7.f@};\n+v4di c = @{1ULL,5ULL,0ULL,10ULL@};\n+v4sf d = __builtin_convertvector (a, v4sf); /* d is @{1.f,-2.f,3.f,-4.f@} */\n+/* Equivalent of:\n+   v4sf d = @{ (float)a[0], (float)a[1], (float)a[2], (float)a[3] @}; */\n+v4df e = __builtin_convertvector (a, v4df); /* e is @{1.,-2.,3.,-4.@} */\n+v4df f = __builtin_convertvector (b, v4df); /* f is @{1.5,-2.5,3.,7.@} */\n+v4si g = __builtin_convertvector (f, v4si); /* g is @{1,-2,3,7@} */\n+v4si h = __builtin_convertvector (c, v4si); /* h is @{1,5,0,10@} */\n+@end smallexample\n+\n @node Offsetof\n @section Support for @code{offsetof}\n @findex __builtin_offsetof"}, {"sha": "439043a85a0a483da421f1e03bc30b85ca44d10d", "filename": "gcc/fold-const-call.c", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8fcab689435a29dba2862693689c624b257d1bf/gcc%2Ffold-const-call.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8fcab689435a29dba2862693689c624b257d1bf/gcc%2Ffold-const-call.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const-call.c?ref=d8fcab689435a29dba2862693689c624b257d1bf", "patch": "@@ -30,6 +30,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tm.h\" /* For C[LT]Z_DEFINED_AT_ZERO.  */\n #include \"builtins.h\"\n #include \"gimple-expr.h\"\n+#include \"tree-vector-builder.h\"\n \n /* Functions that test for certain constant types, abstracting away the\n    decision about whether to check for overflow.  */\n@@ -645,6 +646,40 @@ fold_const_reduction (tree type, tree arg, tree_code code)\n   return res;\n }\n \n+/* Fold a call to IFN_VEC_CONVERT (ARG) returning TYPE.  */\n+\n+static tree\n+fold_const_vec_convert (tree ret_type, tree arg)\n+{\n+  enum tree_code code = NOP_EXPR;\n+  tree arg_type = TREE_TYPE (arg);\n+  if (TREE_CODE (arg) != VECTOR_CST)\n+    return NULL_TREE;\n+\n+  gcc_checking_assert (VECTOR_TYPE_P (ret_type) && VECTOR_TYPE_P (arg_type));\n+\n+  if (INTEGRAL_TYPE_P (TREE_TYPE (ret_type))\n+      && SCALAR_FLOAT_TYPE_P (TREE_TYPE (arg_type)))\n+    code = FIX_TRUNC_EXPR;\n+  else if (INTEGRAL_TYPE_P (TREE_TYPE (arg_type))\n+\t   && SCALAR_FLOAT_TYPE_P (TREE_TYPE (ret_type)))\n+    code = FLOAT_EXPR;\n+\n+  tree_vector_builder elts;\n+  elts.new_unary_operation (ret_type, arg, true);\n+  unsigned int count = elts.encoded_nelts ();\n+  for (unsigned int i = 0; i < count; ++i)\n+    {\n+      tree elt = fold_unary (code, TREE_TYPE (ret_type),\n+\t\t\t     VECTOR_CST_ELT (arg, i));\n+      if (elt == NULL_TREE || !CONSTANT_CLASS_P (elt))\n+\treturn NULL_TREE;\n+      elts.quick_push (elt);\n+    }\n+\n+  return elts.build ();\n+}\n+\n /* Try to evaluate:\n \n       *RESULT = FN (*ARG)\n@@ -1232,6 +1267,9 @@ fold_const_call (combined_fn fn, tree type, tree arg)\n     case CFN_REDUC_XOR:\n       return fold_const_reduction (type, arg, BIT_XOR_EXPR);\n \n+    case CFN_VEC_CONVERT:\n+      return fold_const_vec_convert (type, arg);\n+\n     default:\n       return fold_const_call_1 (fn, type, arg);\n     }"}, {"sha": "4f2ef45a0ff45ebbb8518e0f3e6e897b63d78001", "filename": "gcc/internal-fn.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8fcab689435a29dba2862693689c624b257d1bf/gcc%2Finternal-fn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8fcab689435a29dba2862693689c624b257d1bf/gcc%2Finternal-fn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.c?ref=d8fcab689435a29dba2862693689c624b257d1bf", "patch": "@@ -2581,6 +2581,15 @@ expand_VA_ARG (internal_fn, gcall *)\n   gcc_unreachable ();\n }\n \n+/* IFN_VEC_CONVERT is supposed to be expanded at pass_lower_vector.  So this\n+   dummy function should never be called.  */\n+\n+static void\n+expand_VEC_CONVERT (internal_fn, gcall *)\n+{\n+  gcc_unreachable ();\n+}\n+\n /* Expand the IFN_UNIQUE function according to its first argument.  */\n \n static void"}, {"sha": "e370eaa84767839c827b6ebd0c86303bcc36fa54", "filename": "gcc/internal-fn.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8fcab689435a29dba2862693689c624b257d1bf/gcc%2Finternal-fn.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8fcab689435a29dba2862693689c624b257d1bf/gcc%2Finternal-fn.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.def?ref=d8fcab689435a29dba2862693689c624b257d1bf", "patch": "@@ -296,6 +296,7 @@ DEF_INTERNAL_FN (SUB_OVERFLOW, ECF_CONST | ECF_LEAF | ECF_NOTHROW, NULL)\n DEF_INTERNAL_FN (MUL_OVERFLOW, ECF_CONST | ECF_LEAF | ECF_NOTHROW, NULL)\n DEF_INTERNAL_FN (TSAN_FUNC_EXIT, ECF_NOVOPS | ECF_LEAF | ECF_NOTHROW, NULL)\n DEF_INTERNAL_FN (VA_ARG, ECF_NOTHROW | ECF_LEAF, NULL)\n+DEF_INTERNAL_FN (VEC_CONVERT, ECF_CONST | ECF_LEAF | ECF_NOTHROW, NULL)\n \n /* An unduplicable, uncombinable function.  Generally used to preserve\n    a CFG property in the face of jump threading, tail merging or"}, {"sha": "a0d74152badf1003a72ce9591565550e5bc98379", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8fcab689435a29dba2862693689c624b257d1bf/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8fcab689435a29dba2862693689c624b257d1bf/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d8fcab689435a29dba2862693689c624b257d1bf", "patch": "@@ -1,3 +1,11 @@\n+2019-01-07  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR c++/85052\n+\t* c-c++-common/builtin-convertvector-1.c: New test.\n+\t* c-c++-common/torture/builtin-convertvector-1.c: New test.\n+\t* g++.dg/ext/builtin-convertvector-1.C: New test.\n+\t* g++.dg/cpp0x/constexpr-builtin4.C: New test.\n+\n 2018-12-26  Mateusz B  <mateuszb@poczta.onet.pl>\n \n \tPR target/88521"}, {"sha": "4bd0e4c5df5db0697232528fed17afbbc40eae83", "filename": "gcc/testsuite/c-c++-common/builtin-convertvector-1.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8fcab689435a29dba2862693689c624b257d1bf/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fbuiltin-convertvector-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8fcab689435a29dba2862693689c624b257d1bf/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fbuiltin-convertvector-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fbuiltin-convertvector-1.c?ref=d8fcab689435a29dba2862693689c624b257d1bf", "patch": "@@ -0,0 +1,15 @@\n+typedef int v8si __attribute__((vector_size (8 * sizeof (int))));\n+typedef long long v4di __attribute__((vector_size (4 * sizeof (long long))));\n+\n+void\n+foo (v8si *x, v4di *y, int z)\n+{\n+  __builtin_convertvector (*y, v8si);\t/* { dg-error \"number of elements of the first argument vector and the second argument vector type should be the same\" } */\n+  __builtin_convertvector (*x, v4di);\t/* { dg-error \"number of elements of the first argument vector and the second argument vector type should be the same\" } */\n+  __builtin_convertvector (*x, int);\t/* { dg-error \"second argument must be an integer or floating vector type\" } */\n+  __builtin_convertvector (z, v4di);\t/* { dg-error \"first argument must be an integer or floating vector\" } */\n+  __builtin_convertvector ();\t\t/* { dg-error \"expected\" } */\n+  __builtin_convertvector (*x);\t\t/* { dg-error \"expected\" } */\n+  __builtin_convertvector (*x, *y);\t/* { dg-error \"expected\" } */\n+  __builtin_convertvector (*x, v8si, 1);/* { dg-error \"expected\" } */\n+}"}, {"sha": "347dda7692dcc57a64e29cbabafd05093599ec68", "filename": "gcc/testsuite/c-c++-common/torture/builtin-convertvector-1.c", "status": "added", "additions": 131, "deletions": 0, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8fcab689435a29dba2862693689c624b257d1bf/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fbuiltin-convertvector-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8fcab689435a29dba2862693689c624b257d1bf/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fbuiltin-convertvector-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftorture%2Fbuiltin-convertvector-1.c?ref=d8fcab689435a29dba2862693689c624b257d1bf", "patch": "@@ -0,0 +1,131 @@\n+extern\n+#ifdef __cplusplus\n+\"C\"\n+#endif\n+void abort (void);\n+typedef int v4si __attribute__((vector_size (4 * sizeof (int))));\n+typedef unsigned int v4usi __attribute__((vector_size (4 * sizeof (unsigned int))));\n+typedef float v4sf __attribute__((vector_size (4 * sizeof (float))));\n+typedef double v4df __attribute__((vector_size (4 * sizeof (double))));\n+typedef long long v256di __attribute__((vector_size (256 * sizeof (long long))));\n+typedef double v256df __attribute__((vector_size (256 * sizeof (double))));\n+\n+void\n+f1 (v4usi *x, v4si *y)\n+{\n+  *y = __builtin_convertvector (*x, v4si);\n+}\n+\n+void\n+f2 (v4sf *x, v4si *y)\n+{\n+  *y = __builtin_convertvector (*x, v4si);\n+}\n+\n+void\n+f3 (v4si *x, v4sf *y)\n+{\n+  *y = __builtin_convertvector (*x, v4sf);\n+}\n+\n+void\n+f4 (v4df *x, v4si *y)\n+{\n+  *y = __builtin_convertvector (*x, v4si);\n+}\n+\n+void\n+f5 (v4si *x, v4df *y)\n+{\n+  *y = __builtin_convertvector (*x, v4df);\n+}\n+\n+void\n+f6 (v256df *x, v256di *y)\n+{\n+  *y = __builtin_convertvector (*x, v256di);\n+}\n+\n+void\n+f7 (v256di *x, v256df *y)\n+{\n+  *y = __builtin_convertvector (*x, v256df);\n+}\n+\n+void\n+f8 (v4df *x)\n+{\n+  v4si a = { 1, 2, -3, -4 };\n+  *x = __builtin_convertvector (a, v4df);\n+}\n+\n+int\n+main ()\n+{\n+  union U1 { v4si v; int a[4]; } u1;\n+  union U2 { v4usi v; unsigned int a[4]; } u2;\n+  union U3 { v4sf v; float a[4]; } u3;\n+  union U4 { v4df v; double a[4]; } u4;\n+  union U5 { v256di v; long long a[256]; } u5;\n+  union U6 { v256df v; double a[256]; } u6;\n+  int i;\n+  for (i = 0; i < 4; i++)\n+    u2.a[i] = i * 2;\n+  f1 (&u2.v, &u1.v);\n+  for (i = 0; i < 4; i++)\n+    if (u1.a[i] != i * 2)\n+      abort ();\n+    else\n+      u3.a[i] = i - 2.25f;\n+  f2 (&u3.v, &u1.v);\n+  for (i = 0; i < 4; i++)\n+    if (u1.a[i] != (i == 3 ? 0 : i - 2))\n+      abort ();\n+    else\n+      u3.a[i] = i + 0.75f;\n+  f2 (&u3.v, &u1.v);\n+  for (i = 0; i < 4; i++)\n+    if (u1.a[i] != i)\n+      abort ();\n+    else\n+      u1.a[i] = 7 * i - 5;\n+  f3 (&u1.v, &u3.v);\n+  for (i = 0; i < 4; i++)\n+    if (u3.a[i] != 7 * i - 5)\n+      abort ();\n+    else\n+      u4.a[i] = i - 2.25;\n+  f4 (&u4.v, &u1.v);\n+  for (i = 0; i < 4; i++)\n+    if (u1.a[i] != (i == 3 ? 0 : i - 2))\n+      abort ();\n+    else\n+      u4.a[i] = i + 0.75;\n+  f4 (&u4.v, &u1.v);\n+  for (i = 0; i < 4; i++)\n+    if (u1.a[i] != i)\n+      abort ();\n+    else\n+      u1.a[i] = 7 * i - 5;\n+  f5 (&u1.v, &u4.v);\n+  for (i = 0; i < 4; i++)\n+    if (u4.a[i] != 7 * i - 5)\n+      abort ();\n+  for (i = 0; i < 256; i++)\n+    u6.a[i] = i - 128.25;\n+  f6 (&u6.v, &u5.v);\n+  for (i = 0; i < 256; i++)\n+    if (u5.a[i] != i - 128 - (i > 128))\n+      abort ();\n+    else\n+      u5.a[i] = i - 128;\n+  f7 (&u5.v, &u6.v);\n+  for (i = 0; i < 256; i++)\n+    if (u6.a[i] != i - 128)\n+      abort ();\n+  f8 (&u4.v);\n+  for (i = 0; i < 4; i++)\n+    if (u4.a[i] != (i >= 2 ? -1 - i : i + 1))\n+      abort ();\n+  return 0;\n+}"}, {"sha": "7f6bf3c21bc910ddf75d6a8fed56d7848591fce3", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-builtin4.C", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8fcab689435a29dba2862693689c624b257d1bf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-builtin4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8fcab689435a29dba2862693689c624b257d1bf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-builtin4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-builtin4.C?ref=d8fcab689435a29dba2862693689c624b257d1bf", "patch": "@@ -0,0 +1,17 @@\n+// { dg-do compile { target c++11 } }\n+// { dg-additional-options \"-Wno-psabi\" }\n+\n+typedef int v4si __attribute__((vector_size (4 * sizeof (int))));\n+typedef float v4sf __attribute__((vector_size (4 * sizeof (float))));\n+constexpr v4sf a = __builtin_convertvector (v4si { 1, 2, -3, -4 }, v4sf);\n+\n+constexpr v4sf\n+foo (v4si x)\n+{\n+  return __builtin_convertvector (x, v4sf);\n+}\n+\n+constexpr v4sf b = foo (v4si { 3, 4, -1, -2 });\n+\n+static_assert (a[0] == 1.0f && a[1] == 2.0f && a[2] == -3.0f && a[3] == -4.0f, \"\");\n+static_assert (b[0] == 3.0f && b[1] == 4.0f && b[2] == -1.0f && b[3] == -2.0f, \"\");"}, {"sha": "c803c065ff2ee77740386e2ee9fd7fee86528736", "filename": "gcc/testsuite/g++.dg/ext/builtin-convertvector-1.C", "status": "added", "additions": 137, "deletions": 0, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8fcab689435a29dba2862693689c624b257d1bf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fbuiltin-convertvector-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8fcab689435a29dba2862693689c624b257d1bf/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fbuiltin-convertvector-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fbuiltin-convertvector-1.C?ref=d8fcab689435a29dba2862693689c624b257d1bf", "patch": "@@ -0,0 +1,137 @@\n+// { dg-do run }\n+\n+extern \"C\" void abort ();\n+typedef int v4si __attribute__((vector_size (4 * sizeof (int))));\n+typedef unsigned int v4usi __attribute__((vector_size (4 * sizeof (unsigned int))));\n+typedef float v4sf __attribute__((vector_size (4 * sizeof (float))));\n+typedef double v4df __attribute__((vector_size (4 * sizeof (double))));\n+typedef long long v256di __attribute__((vector_size (256 * sizeof (long long))));\n+typedef double v256df __attribute__((vector_size (256 * sizeof (double))));\n+\n+template <int N>\n+void\n+f1 (v4usi *x, v4si *y)\n+{\n+  *y = __builtin_convertvector (*x, v4si);\n+}\n+\n+template <typename T>\n+void\n+f2 (T *x, v4si *y)\n+{\n+  *y = __builtin_convertvector (*x, v4si);\n+}\n+\n+template <typename T>\n+void\n+f3 (v4si *x, T *y)\n+{\n+  *y = __builtin_convertvector (*x, T);\n+}\n+\n+template <int N>\n+void\n+f4 (v4df *x, v4si *y)\n+{\n+  *y = __builtin_convertvector (*x, v4si);\n+}\n+\n+template <typename T, typename U>\n+void\n+f5 (T *x, U *y)\n+{\n+  *y = __builtin_convertvector (*x, U);\n+}\n+\n+template <typename T>\n+void\n+f6 (v256df *x, T *y)\n+{\n+  *y = __builtin_convertvector (*x, T);\n+}\n+\n+template <int N>\n+void\n+f7 (v256di *x, v256df *y)\n+{\n+  *y = __builtin_convertvector (*x, v256df);\n+}\n+\n+template <int N>\n+void\n+f8 (v4df *x)\n+{\n+  v4si a = { 1, 2, -3, -4 };\n+  *x = __builtin_convertvector (a, v4df);\n+}\n+\n+int\n+main ()\n+{\n+  union U1 { v4si v; int a[4]; } u1;\n+  union U2 { v4usi v; unsigned int a[4]; } u2;\n+  union U3 { v4sf v; float a[4]; } u3;\n+  union U4 { v4df v; double a[4]; } u4;\n+  union U5 { v256di v; long long a[256]; } u5;\n+  union U6 { v256df v; double a[256]; } u6;\n+  int i;\n+  for (i = 0; i < 4; i++)\n+    u2.a[i] = i * 2;\n+  f1<0> (&u2.v, &u1.v);\n+  for (i = 0; i < 4; i++)\n+    if (u1.a[i] != i * 2)\n+      abort ();\n+    else\n+      u3.a[i] = i - 2.25f;\n+  f2 (&u3.v, &u1.v);\n+  for (i = 0; i < 4; i++)\n+    if (u1.a[i] != (i == 3 ? 0 : i - 2))\n+      abort ();\n+    else\n+      u3.a[i] = i + 0.75f;\n+  f2 (&u3.v, &u1.v);\n+  for (i = 0; i < 4; i++)\n+    if (u1.a[i] != i)\n+      abort ();\n+    else\n+      u1.a[i] = 7 * i - 5;\n+  f3 (&u1.v, &u3.v);\n+  for (i = 0; i < 4; i++)\n+    if (u3.a[i] != 7 * i - 5)\n+      abort ();\n+    else\n+      u4.a[i] = i - 2.25;\n+  f4<12> (&u4.v, &u1.v);\n+  for (i = 0; i < 4; i++)\n+    if (u1.a[i] != (i == 3 ? 0 : i - 2))\n+      abort ();\n+    else\n+      u4.a[i] = i + 0.75;\n+  f4<13> (&u4.v, &u1.v);\n+  for (i = 0; i < 4; i++)\n+    if (u1.a[i] != i)\n+      abort ();\n+    else\n+      u1.a[i] = 7 * i - 5;\n+  f5 (&u1.v, &u4.v);\n+  for (i = 0; i < 4; i++)\n+    if (u4.a[i] != 7 * i - 5)\n+      abort ();\n+  for (i = 0; i < 256; i++)\n+    u6.a[i] = i - 128.25;\n+  f6 (&u6.v, &u5.v);\n+  for (i = 0; i < 256; i++)\n+    if (u5.a[i] != i - 128 - (i > 128))\n+      abort ();\n+    else\n+      u5.a[i] = i - 128;\n+  f7<-1> (&u5.v, &u6.v);\n+  for (i = 0; i < 256; i++)\n+    if (u6.a[i] != i - 128)\n+      abort ();\n+  f8<5> (&u4.v);\n+  for (i = 0; i < 4; i++)\n+    if (u4.a[i] != (i >= 2 ? -1 - i : i + 1))\n+      abort ();\n+  return 0;\n+}"}, {"sha": "e9f5505acb39ec1fdc7c75ef60a11ce28f8553fd", "filename": "gcc/tree-vect-generic.c", "status": "modified", "additions": 310, "deletions": 7, "changes": 317, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d8fcab689435a29dba2862693689c624b257d1bf/gcc%2Ftree-vect-generic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d8fcab689435a29dba2862693689c624b257d1bf/gcc%2Ftree-vect-generic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-generic.c?ref=d8fcab689435a29dba2862693689c624b257d1bf", "patch": "@@ -39,6 +39,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-cfg.h\"\n #include \"tree-vector-builder.h\"\n #include \"vec-perm-indices.h\"\n+#include \"insn-config.h\"\n+#include \"recog.h\"\t\t/* FIXME: for insn_data */\n \n \n static void expand_vector_operations_1 (gimple_stmt_iterator *);\n@@ -267,7 +269,8 @@ do_negate (gimple_stmt_iterator *gsi, tree word_type, tree b,\n static tree\n expand_vector_piecewise (gimple_stmt_iterator *gsi, elem_op_func f,\n \t\t\t tree type, tree inner_type,\n-\t\t\t tree a, tree b, enum tree_code code)\n+\t\t\t tree a, tree b, enum tree_code code,\n+\t\t\t tree ret_type = NULL_TREE)\n {\n   vec<constructor_elt, va_gc> *v;\n   tree part_width = TYPE_SIZE (inner_type);\n@@ -278,32 +281,35 @@ expand_vector_piecewise (gimple_stmt_iterator *gsi, elem_op_func f,\n   int i;\n   location_t loc = gimple_location (gsi_stmt (*gsi));\n \n-  if (types_compatible_p (gimple_expr_type (gsi_stmt (*gsi)), type))\n+  if (ret_type\n+      || types_compatible_p (gimple_expr_type (gsi_stmt (*gsi)), type))\n     warning_at (loc, OPT_Wvector_operation_performance,\n \t\t\"vector operation will be expanded piecewise\");\n   else\n     warning_at (loc, OPT_Wvector_operation_performance,\n \t\t\"vector operation will be expanded in parallel\");\n \n+  if (!ret_type)\n+    ret_type = type;\n   vec_alloc (v, (nunits + delta - 1) / delta);\n   for (i = 0; i < nunits;\n        i += delta, index = int_const_binop (PLUS_EXPR, index, part_width))\n     {\n-      tree result = f (gsi, inner_type, a, b, index, part_width, code, type);\n+      tree result = f (gsi, inner_type, a, b, index, part_width, code,\n+\t\t       ret_type);\n       constructor_elt ce = {NULL_TREE, result};\n       v->quick_push (ce);\n     }\n \n-  return build_constructor (type, v);\n+  return build_constructor (ret_type, v);\n }\n \n /* Expand a vector operation to scalars with the freedom to use\n    a scalar integer type, or to use a different size for the items\n    in the vector type.  */\n static tree\n expand_vector_parallel (gimple_stmt_iterator *gsi, elem_op_func f, tree type,\n-\t\t\ttree a, tree b,\n-\t\t\tenum tree_code code)\n+\t\t\ttree a, tree b, enum tree_code code)\n {\n   tree result, compute_type;\n   int n_words = tree_to_uhwi (TYPE_SIZE_UNIT (type)) / UNITS_PER_WORD;\n@@ -1547,6 +1553,299 @@ expand_vector_scalar_condition (gimple_stmt_iterator *gsi)\n   update_stmt (gsi_stmt (*gsi));\n }\n \n+/* Callback for expand_vector_piecewise to do VEC_CONVERT ifn call\n+   lowering.  If INNER_TYPE is not a vector type, this is a scalar\n+   fallback.  */\n+\n+static tree\n+do_vec_conversion (gimple_stmt_iterator *gsi, tree inner_type, tree a,\n+\t\t   tree decl, tree bitpos, tree bitsize,\n+\t\t   enum tree_code code, tree type)\n+{\n+  a = tree_vec_extract (gsi, inner_type, a, bitsize, bitpos);\n+  if (!VECTOR_TYPE_P (inner_type))\n+    return gimplify_build1 (gsi, code, TREE_TYPE (type), a);\n+  if (code == CALL_EXPR)\n+    {\n+      gimple *g = gimple_build_call (decl, 1, a);\n+      tree lhs = make_ssa_name (TREE_TYPE (TREE_TYPE (decl)));\n+      gimple_call_set_lhs (g, lhs);\n+      gsi_insert_before (gsi, g, GSI_SAME_STMT);\n+      return lhs;\n+    }\n+  else\n+    {\n+      tree outer_type = build_vector_type (TREE_TYPE (type),\n+\t\t\t\t\t   TYPE_VECTOR_SUBPARTS (inner_type));\n+      return gimplify_build1 (gsi, code, outer_type, a);\n+    }\n+}\n+\n+/* Similarly, but for narrowing conversion.  */\n+\n+static tree\n+do_vec_narrow_conversion (gimple_stmt_iterator *gsi, tree inner_type, tree a,\n+\t\t\t  tree, tree bitpos, tree, enum tree_code code,\n+\t\t\t  tree type)\n+{\n+  tree itype = build_vector_type (TREE_TYPE (inner_type),\n+\t\t\t\t  exact_div (TYPE_VECTOR_SUBPARTS (inner_type),\n+\t\t\t\t\t     2));\n+  tree b = tree_vec_extract (gsi, itype, a, TYPE_SIZE (itype), bitpos);\n+  tree c = tree_vec_extract (gsi, itype, a, TYPE_SIZE (itype),\n+\t\t\t     int_const_binop (PLUS_EXPR, bitpos,\n+\t\t\t\t\t      TYPE_SIZE (itype)));\n+  tree outer_type = build_vector_type (TREE_TYPE (type),\n+\t\t\t\t       TYPE_VECTOR_SUBPARTS (inner_type));\n+  return gimplify_build2 (gsi, code, outer_type, b, c);\n+}\n+\n+/* Expand VEC_CONVERT ifn call.  */\n+\n+static void\n+expand_vector_conversion (gimple_stmt_iterator *gsi)\n+{\n+  gimple *stmt = gsi_stmt (*gsi);\n+  gimple *g;\n+  tree lhs = gimple_call_lhs (stmt);\n+  tree arg = gimple_call_arg (stmt, 0);\n+  tree decl = NULL_TREE;\n+  tree ret_type = TREE_TYPE (lhs);\n+  tree arg_type = TREE_TYPE (arg);\n+  tree new_rhs, compute_type = TREE_TYPE (arg_type);\n+  enum tree_code code = NOP_EXPR;\n+  enum tree_code code1 = ERROR_MARK;\n+  enum { NARROW, NONE, WIDEN } modifier = NONE;\n+  optab optab1 = unknown_optab;\n+\n+  gcc_checking_assert (VECTOR_TYPE_P (ret_type) && VECTOR_TYPE_P (arg_type));\n+  gcc_checking_assert (tree_fits_uhwi_p (TYPE_SIZE (TREE_TYPE (ret_type))));\n+  gcc_checking_assert (tree_fits_uhwi_p (TYPE_SIZE (TREE_TYPE (arg_type))));\n+  if (INTEGRAL_TYPE_P (TREE_TYPE (ret_type))\n+      && SCALAR_FLOAT_TYPE_P (TREE_TYPE (arg_type)))\n+    code = FIX_TRUNC_EXPR;\n+  else if (INTEGRAL_TYPE_P (TREE_TYPE (arg_type))\n+\t   && SCALAR_FLOAT_TYPE_P (TREE_TYPE (ret_type)))\n+    code = FLOAT_EXPR;\n+  if (tree_to_uhwi (TYPE_SIZE (TREE_TYPE (ret_type)))\n+      < tree_to_uhwi (TYPE_SIZE (TREE_TYPE (arg_type))))\n+    modifier = NARROW;\n+  else if (tree_to_uhwi (TYPE_SIZE (TREE_TYPE (ret_type)))\n+\t   > tree_to_uhwi (TYPE_SIZE (TREE_TYPE (arg_type))))\n+    modifier = WIDEN;\n+\n+  if (modifier == NONE && (code == FIX_TRUNC_EXPR || code == FLOAT_EXPR))\n+    {\n+      if (supportable_convert_operation (code, ret_type, arg_type, &decl,\n+\t\t\t\t\t &code1))\n+\t{\n+\t  if (code1 == CALL_EXPR)\n+\t    {\n+\t      g = gimple_build_call (decl, 1, arg);\n+\t      gimple_call_set_lhs (g, lhs);\n+\t    }\n+\t  else\n+\t    g = gimple_build_assign (lhs, code1, arg);\n+\t  gsi_replace (gsi, g, false);\n+\t  return;\n+\t}\n+      /* Can't use get_compute_type here, as supportable_convert_operation\n+\t doesn't necessarily use an optab and needs two arguments.  */\n+      tree vec_compute_type\n+\t= type_for_widest_vector_mode (TREE_TYPE (arg_type), mov_optab);\n+      if (vec_compute_type\n+\t  && VECTOR_MODE_P (TYPE_MODE (vec_compute_type))\n+\t  && subparts_gt (arg_type, vec_compute_type))\n+\t{\n+\t  unsigned HOST_WIDE_INT nelts\n+\t    = constant_lower_bound (TYPE_VECTOR_SUBPARTS (vec_compute_type));\n+\t  while (nelts > 1)\n+\t    {\n+\t      tree ret1_type = build_vector_type (TREE_TYPE (ret_type), nelts);\n+\t      tree arg1_type = build_vector_type (TREE_TYPE (arg_type), nelts);\n+\t      if (supportable_convert_operation (code, ret1_type, arg1_type,\n+\t\t\t\t\t\t &decl, &code1))\n+\t\t{\n+\t\t  new_rhs = expand_vector_piecewise (gsi, do_vec_conversion,\n+\t\t\t\t\t\t     ret_type, arg1_type, arg,\n+\t\t\t\t\t\t     decl, code1);\n+\t\t  g = gimple_build_assign (lhs, new_rhs);\n+\t\t  gsi_replace (gsi, g, false);\n+\t\t  return;\n+\t\t}\n+\t      nelts = nelts / 2;\n+\t    }\n+\t}\n+    }\n+  else if (modifier == NARROW)\n+    {\n+      switch (code)\n+\t{\n+\tCASE_CONVERT:\n+\t  code1 = VEC_PACK_TRUNC_EXPR;\n+\t  optab1 = optab_for_tree_code (code1, arg_type, optab_default);\n+\t  break;\n+\tcase FIX_TRUNC_EXPR:\n+\t  code1 = VEC_PACK_FIX_TRUNC_EXPR;\n+\t  /* The signedness is determined from output operand.  */\n+\t  optab1 = optab_for_tree_code (code1, ret_type, optab_default);\n+\t  break;\n+\tcase FLOAT_EXPR:\n+\t  code1 = VEC_PACK_FLOAT_EXPR;\n+\t  optab1 = optab_for_tree_code (code1, arg_type, optab_default);\n+\t  break;\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+\n+      if (optab1)\n+\tcompute_type = get_compute_type (code1, optab1, arg_type);\n+      enum insn_code icode1;\n+      if (VECTOR_TYPE_P (compute_type)\n+\t  && ((icode1 = optab_handler (optab1, TYPE_MODE (compute_type)))\n+\t      != CODE_FOR_nothing)\n+\t  && VECTOR_MODE_P (insn_data[icode1].operand[0].mode))\n+\t{\n+\t  tree cretd_type\n+\t    = build_vector_type (TREE_TYPE (ret_type),\n+\t\t\t\t TYPE_VECTOR_SUBPARTS (compute_type) * 2);\n+\t  if (insn_data[icode1].operand[0].mode == TYPE_MODE (cretd_type))\n+\t    {\n+\t      if (compute_type == arg_type)\n+\t\t{\n+\t\t  new_rhs = gimplify_build2 (gsi, code1, cretd_type,\n+\t\t\t\t\t     arg, build_zero_cst (arg_type));\n+\t\t  new_rhs = tree_vec_extract (gsi, ret_type, new_rhs,\n+\t\t\t\t\t      TYPE_SIZE (ret_type),\n+\t\t\t\t\t      bitsize_int (0));\n+\t\t  g = gimple_build_assign (lhs, new_rhs);\n+\t\t  gsi_replace (gsi, g, false);\n+\t\t  return;\n+\t\t}\n+\t      tree dcompute_type\n+\t\t= build_vector_type (TREE_TYPE (compute_type),\n+\t\t\t\t     TYPE_VECTOR_SUBPARTS (compute_type) * 2);\n+\t      if (TYPE_MAIN_VARIANT (dcompute_type)\n+\t\t  == TYPE_MAIN_VARIANT (arg_type))\n+\t\tnew_rhs = do_vec_narrow_conversion (gsi, dcompute_type, arg,\n+\t\t\t\t\t\t    NULL_TREE, bitsize_int (0),\n+\t\t\t\t\t\t    NULL_TREE, code1,\n+\t\t\t\t\t\t    ret_type);\n+\t      else\n+\t\tnew_rhs = expand_vector_piecewise (gsi,\n+\t\t\t\t\t\t   do_vec_narrow_conversion,\n+\t\t\t\t\t\t   arg_type, dcompute_type,\n+\t\t\t\t\t\t   arg, NULL_TREE, code1,\n+\t\t\t\t\t\t   ret_type);\n+\t      g = gimple_build_assign (lhs, new_rhs);\n+\t      gsi_replace (gsi, g, false);\n+\t      return;\n+\t    }\n+\t}\n+    }\n+  else if (modifier == WIDEN)\n+    {\n+      enum tree_code code2 = ERROR_MARK;\n+      optab optab2 = unknown_optab;\n+      switch (code)\n+\t{\n+\tCASE_CONVERT:\n+\t  code1 = VEC_UNPACK_LO_EXPR;\n+          code2 = VEC_UNPACK_HI_EXPR;\n+\t  break;\n+\tcase FIX_TRUNC_EXPR:\n+\t  code1 = VEC_UNPACK_FIX_TRUNC_LO_EXPR;\n+\t  code2 = VEC_UNPACK_FIX_TRUNC_HI_EXPR;\n+\t  break;\n+\tcase FLOAT_EXPR:\n+\t  code1 = VEC_UNPACK_FLOAT_LO_EXPR;\n+\t  code2 = VEC_UNPACK_FLOAT_HI_EXPR;\n+\t  break;\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+      if (BYTES_BIG_ENDIAN)\n+\tstd::swap (code1, code2);\n+\n+      if (code == FIX_TRUNC_EXPR)\n+\t{\n+\t  /* The signedness is determined from output operand.  */\n+\t  optab1 = optab_for_tree_code (code1, ret_type, optab_default);\n+\t  optab2 = optab_for_tree_code (code2, ret_type, optab_default);\n+\t}\n+      else\n+\t{\n+\t  optab1 = optab_for_tree_code (code1, arg_type, optab_default);\n+\t  optab2 = optab_for_tree_code (code2, arg_type, optab_default);\n+\t}\n+\n+      if (optab1 && optab2)\n+\tcompute_type = get_compute_type (code1, optab1, arg_type);\n+\n+      enum insn_code icode1, icode2;\n+      if (VECTOR_TYPE_P (compute_type)\n+\t  && ((icode1 = optab_handler (optab1, TYPE_MODE (compute_type)))\n+\t      != CODE_FOR_nothing)\n+\t  && ((icode2 = optab_handler (optab2, TYPE_MODE (compute_type)))\n+\t      != CODE_FOR_nothing)\n+\t  && VECTOR_MODE_P (insn_data[icode1].operand[0].mode)\n+\t  && (insn_data[icode1].operand[0].mode\n+\t      == insn_data[icode2].operand[0].mode))\n+\t{\n+\t  poly_uint64 nunits\n+\t    = exact_div (TYPE_VECTOR_SUBPARTS (compute_type), 2);\n+\t  tree cretd_type = build_vector_type (TREE_TYPE (ret_type), nunits);\n+\t  if (insn_data[icode1].operand[0].mode == TYPE_MODE (cretd_type))\n+\t    {\n+\t      vec<constructor_elt, va_gc> *v;\n+\t      tree part_width = TYPE_SIZE (compute_type);\n+\t      tree index = bitsize_int (0);\n+\t      int nunits = nunits_for_known_piecewise_op (arg_type);\n+\t      int delta = tree_to_uhwi (part_width)\n+\t\t\t  / tree_to_uhwi (TYPE_SIZE (TREE_TYPE (arg_type)));\n+\t      int i;\n+\t      location_t loc = gimple_location (gsi_stmt (*gsi));\n+\n+\t      if (compute_type != arg_type)\n+\t\twarning_at (loc, OPT_Wvector_operation_performance,\n+\t\t\t    \"vector operation will be expanded piecewise\");\n+\t      else\n+\t\t{\n+\t\t  nunits = 1;\n+\t\t  delta = 1;\n+\t\t}\n+\n+\t      vec_alloc (v, (nunits + delta - 1) / delta * 2);\n+\t      for (i = 0; i < nunits;\n+\t\t   i += delta, index = int_const_binop (PLUS_EXPR, index,\n+\t\t\t\t\t\t\tpart_width))\n+\t\t{\n+\t\t  tree a = arg;\n+\t\t  if (compute_type != arg_type)\n+\t\t    a = tree_vec_extract (gsi, compute_type, a, part_width,\n+\t\t\t\t\t  index);\n+\t\t  tree result = gimplify_build1 (gsi, code1, cretd_type, a);\n+\t\t  constructor_elt ce = { NULL_TREE, result };\n+\t\t  v->quick_push (ce);\n+\t\t  ce.value = gimplify_build1 (gsi, code2, cretd_type, a);\n+\t\t  v->quick_push (ce);\n+\t\t}\n+\n+\t      new_rhs = build_constructor (ret_type, v);\n+\t      g = gimple_build_assign (lhs, new_rhs);\n+\t      gsi_replace (gsi, g, false);\n+\t      return;\n+\t    }\n+\t}\n+    }\n+\n+  new_rhs = expand_vector_piecewise (gsi, do_vec_conversion, arg_type,\n+\t\t\t\t     TREE_TYPE (arg_type), arg,\n+\t\t\t\t     NULL_TREE, code, ret_type);\n+  g = gimple_build_assign (lhs, new_rhs);\n+  gsi_replace (gsi, g, false);\n+}\n+\n /* Process one statement.  If we identify a vector operation, expand it.  */\n \n static void\n@@ -1561,7 +1860,11 @@ expand_vector_operations_1 (gimple_stmt_iterator *gsi)\n   /* Only consider code == GIMPLE_ASSIGN. */\n   gassign *stmt = dyn_cast <gassign *> (gsi_stmt (*gsi));\n   if (!stmt)\n-    return;\n+    {\n+      if (gimple_call_internal_p (gsi_stmt (*gsi), IFN_VEC_CONVERT))\n+\texpand_vector_conversion (gsi);\n+      return;\n+    }\n \n   code = gimple_assign_rhs_code (stmt);\n   rhs_class = get_gimple_rhs_class (code);"}]}