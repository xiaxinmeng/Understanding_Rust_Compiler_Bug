{"sha": "b80b0fd9c7f6206708bc423d131b0365a7296736", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjgwYjBmZDljN2Y2MjA2NzA4YmM0MjNkMTMxYjAzNjVhNzI5NjczNg==", "commit": {"author": {"name": "Sriraman Tallam", "email": "tmsriram@google.com", "date": "2009-09-28T23:15:35Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2009-09-28T23:15:35Z"}, "message": "tree-pass.h (register_pass_info): New structure.\n\n\t* tree-pass.h (register_pass_info): New structure.\t\n\t(pass_positioning_ops): Move enum from gcc-plugin.h.\n\t(register_pass): New function.\n\t* gcc-plugin.h (plugin_pass): Delete structure.\n\t(pass_positioning_ops): Delete enum.\n\t* plugin.c (regsiter_pass): Delete function.\n\t(position_pass): Delete function.\n\t(added_pass_nodes): Delete variable.\n\t(prev_added_pass_nodes): Delete variable.\n\t(pass_list_node): Delete structure.\n\t* passes.c (make_pass_instance): New function.\n\t(next_pass_1): Change to call make_pass_instance.\n\t(pass_list_node): Move structure from gcc-plugin.h.\n\t(added_pass_nodes): Move variable from plugin.c.\n\t(prev_added_pass_nodes): Move variable from plugin.c.\n\t(position_pass): New function.\n\t(register_pass): New function.\n\nFrom-SVN: r152257", "tree": {"sha": "35f1885df6f021b7379543790ddaa2f2def2a72f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/35f1885df6f021b7379543790ddaa2f2def2a72f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b80b0fd9c7f6206708bc423d131b0365a7296736", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b80b0fd9c7f6206708bc423d131b0365a7296736", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b80b0fd9c7f6206708bc423d131b0365a7296736", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b80b0fd9c7f6206708bc423d131b0365a7296736/comments", "author": {"login": "tmsri", "id": 38991943, "node_id": "MDQ6VXNlcjM4OTkxOTQz", "avatar_url": "https://avatars.githubusercontent.com/u/38991943?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmsri", "html_url": "https://github.com/tmsri", "followers_url": "https://api.github.com/users/tmsri/followers", "following_url": "https://api.github.com/users/tmsri/following{/other_user}", "gists_url": "https://api.github.com/users/tmsri/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmsri/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmsri/subscriptions", "organizations_url": "https://api.github.com/users/tmsri/orgs", "repos_url": "https://api.github.com/users/tmsri/repos", "events_url": "https://api.github.com/users/tmsri/events{/privacy}", "received_events_url": "https://api.github.com/users/tmsri/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ef6ed66d16e433f5d77e8eda02768a691a42bfd7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef6ed66d16e433f5d77e8eda02768a691a42bfd7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ef6ed66d16e433f5d77e8eda02768a691a42bfd7"}], "stats": {"total": 437, "additions": 221, "deletions": 216}, "files": [{"sha": "9826735864ccf26ae74283f3aa8847d59de89a38", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b80b0fd9c7f6206708bc423d131b0365a7296736/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b80b0fd9c7f6206708bc423d131b0365a7296736/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b80b0fd9c7f6206708bc423d131b0365a7296736", "patch": "@@ -1,3 +1,23 @@\n+2009-09-28  Sriraman Tallam  <tmsriram@google.com>\n+\n+\t* tree-pass.h (register_pass_info): New structure.\t\n+\t(pass_positioning_ops): Move enum from gcc-plugin.h.\n+\t(register_pass): New function.\n+\t* gcc-plugin.h (plugin_pass): Delete structure.\n+\t(pass_positioning_ops): Delete enum.\n+\t* plugin.c (regsiter_pass): Delete function.\n+\t(position_pass): Delete function.\n+\t(added_pass_nodes): Delete variable.\n+\t(prev_added_pass_nodes): Delete variable.\n+\t(pass_list_node): Delete structure.\n+\t* passes.c (make_pass_instance): New function.\n+\t(next_pass_1): Change to call make_pass_instance.\n+\t(pass_list_node): Move structure from gcc-plugin.h.\n+\t(added_pass_nodes): Move variable from plugin.c.\n+\t(prev_added_pass_nodes): Move variable from plugin.c.\n+\t(position_pass): New function.\n+\t(register_pass): New function.\n+\n 2009-09-28  Easwaran Raman  <eraman@google.com>\n \n \t* ifcvt.c (noce_try_abs): Recognize pattern and call"}, {"sha": "1792c0393a2d2eaeba34c3b036195daf4d735d33", "filename": "gcc/gcc-plugin.h", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b80b0fd9c7f6206708bc423d131b0365a7296736/gcc%2Fgcc-plugin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b80b0fd9c7f6206708bc423d131b0365a7296736/gcc%2Fgcc-plugin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc-plugin.h?ref=b80b0fd9c7f6206708bc423d131b0365a7296736", "patch": "@@ -55,24 +55,6 @@ struct plugin_argument\n   char *value;  /* value is optional and can be NULL.  */\n };\n \n-enum pass_positioning_ops\n-{\n-  PASS_POS_INSERT_AFTER,  /* Insert after the reference pass.  */\n-  PASS_POS_INSERT_BEFORE, /* Insert before the reference pass.  */\n-  PASS_POS_REPLACE        /* Replace the reference pass.  */\n-};\n-\n-struct plugin_pass\n-{\n-  struct opt_pass *pass;            /* New pass provided by the plugin.  */\n-  const char *reference_pass_name;  /* Name of the reference pass for hooking\n-                                       up the new pass.  */\n-  int ref_pass_instance_number;     /* Insert the pass at the specified\n-                                       instance number of the reference pass.\n-                                       Do it for every instance if it is 0.  */\n-  enum pass_positioning_ops pos_op; /* how to insert the new pass.  */\n-};\n-\n /* Additional information about the plugin. Used by --help and --version. */\n \n struct plugin_info"}, {"sha": "5b91698e179337bc546d3bb14e97e7bb39787443", "filename": "gcc/passes.c", "status": "modified", "additions": 178, "deletions": 10, "changes": 188, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b80b0fd9c7f6206708bc423d131b0365a7296736/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b80b0fd9c7f6206708bc423d131b0365a7296736/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=b80b0fd9c7f6206708bc423d131b0365a7296736", "patch": "@@ -437,11 +437,11 @@ register_dump_files (struct opt_pass *pass,int properties)\n   register_dump_files_1 (pass, properties);\n }\n \n-/* Add a pass to the pass list. Duplicate the pass if it's already\n-   in the list.  */\n+/* Look at the static_pass_number and duplicate the pass\n+   if it is already added to a list. */\n \n-static struct opt_pass **\n-next_pass_1 (struct opt_pass **list, struct opt_pass *pass)\n+static struct opt_pass *\n+make_pass_instance (struct opt_pass *pass, bool track_duplicates)\n {\n   /* A nonzero static_pass_number indicates that the\n      pass is already in the list.  */\n@@ -459,25 +459,193 @@ next_pass_1 (struct opt_pass **list, struct opt_pass *pass)\n          and so it should rename the dump file.  The first instance will\n          be -1, and be number of duplicates = -static_pass_number - 1.\n          Subsequent instances will be > 0 and just the duplicate number.  */\n-      if (pass->name)\n+      if (pass->name || track_duplicates)\n         {\n           pass->static_pass_number -= 1;\n           new_pass->static_pass_number = -pass->static_pass_number;\n \t}\n-      \n-      *list = new_pass;\n+      return new_pass;\n     }\n   else\n     {\n       pass->todo_flags_start |= TODO_mark_first_instance;\n       pass->static_pass_number = -1;\n-      *list = pass;\n-    }  \n+    } \n+  return pass; \n+}\n+\n+/* Add a pass to the pass list. Duplicate the pass if it's already\n+   in the list.  */\n+\n+static struct opt_pass **\n+next_pass_1 (struct opt_pass **list, struct opt_pass *pass)\n+{\n+  *list = make_pass_instance (pass, false);\n   \n   return &(*list)->next;\n-          \n }\n \n+/* List node for an inserted pass instance. We need to keep track of all\n+   the newly-added pass instances (with 'added_pass_nodes' defined below)\n+   so that we can register their dump files after pass-positioning is finished.\n+   Registering dumping files needs to be post-processed or the\n+   static_pass_number of the opt_pass object would be modified and mess up\n+   the dump file names of future pass instances to be added.  */\n+\n+struct pass_list_node\n+{\n+  struct opt_pass *pass;\n+  struct pass_list_node *next;\n+};\n+\n+static struct pass_list_node *added_pass_nodes = NULL;\n+static struct pass_list_node *prev_added_pass_node;\n+\n+/* Insert the pass at the proper position. Return true if the pass \n+   is successfully added.\n+\n+   NEW_PASS_INFO - new pass to be inserted\n+   PASS_LIST - root of the pass list to insert the new pass to  */\n+\n+static bool\n+position_pass (struct register_pass_info *new_pass_info,\n+               struct opt_pass **pass_list)\n+{\n+  struct opt_pass *pass = *pass_list, *prev_pass = NULL;\n+  bool success = false;\n+\n+  for ( ; pass; prev_pass = pass, pass = pass->next)\n+    {\n+      /* Check if the current pass is of the same type as the new pass and\n+         matches the name and the instance number of the reference pass.  */\n+      if (pass->type == new_pass_info->pass->type\n+          && pass->name\n+          && !strcmp (pass->name, new_pass_info->reference_pass_name)\n+          && ((new_pass_info->ref_pass_instance_number == 0)\n+              || (new_pass_info->ref_pass_instance_number ==\n+                  pass->static_pass_number)\n+              || (new_pass_info->ref_pass_instance_number == 1\n+                  && pass->todo_flags_start & TODO_mark_first_instance)))\n+        {\n+          struct opt_pass *new_pass;\n+          struct pass_list_node *new_pass_node;\n+\n+\t  new_pass = make_pass_instance (new_pass_info->pass, true);\n+  \n+          /* Insert the new pass instance based on the positioning op.  */\n+          switch (new_pass_info->pos_op)\n+            {\n+              case PASS_POS_INSERT_AFTER:\n+                new_pass->next = pass->next;\n+                pass->next = new_pass;\n+\n+\t\t/* Skip newly inserted pass to avoid repeated\n+\t\t   insertions in the case where the new pass and the\n+\t\t   existing one have the same name.  */\n+                pass = new_pass; \n+                break;\n+              case PASS_POS_INSERT_BEFORE:\n+                new_pass->next = pass;\n+                if (prev_pass)\n+                  prev_pass->next = new_pass;\n+                else\n+                  *pass_list = new_pass;\n+                break;\n+              case PASS_POS_REPLACE:\n+                new_pass->next = pass->next;\n+                if (prev_pass)\n+                  prev_pass->next = new_pass;\n+                else\n+                  *pass_list = new_pass;\n+                new_pass->sub = pass->sub;\n+                new_pass->tv_id = pass->tv_id;\n+                pass = new_pass;\n+                break;\n+              default:\n+                error (\"Invalid pass positioning operation\");\n+                return false;\n+            }\n+\n+          /* Save the newly added pass (instance) in the added_pass_nodes\n+             list so that we can register its dump file later. Note that\n+             we cannot register the dump file now because doing so will modify\n+             the static_pass_number of the opt_pass object and therefore\n+             mess up the dump file name of future instances.  */\n+          new_pass_node = XCNEW (struct pass_list_node);\n+          new_pass_node->pass = new_pass;\n+          if (!added_pass_nodes)\n+            added_pass_nodes = new_pass_node;\n+          else\n+            prev_added_pass_node->next = new_pass_node;\n+          prev_added_pass_node = new_pass_node;\n+\n+          success = true;\n+        }\n+\n+      if (pass->sub && position_pass (new_pass_info, &pass->sub))\n+        success = true;\n+    }\n+\n+  return success;\n+}\n+\n+/* Hooks a new pass into the pass lists.\n+\n+   PASS_INFO   - pass information that specifies the opt_pass object,\n+                 reference pass, instance number, and how to position\n+                 the pass  */\n+\n+void\n+register_pass (struct register_pass_info *pass_info)\n+{\n+  if (!pass_info->pass)\n+    {\n+      gcc_unreachable ();\n+    } \n+\n+  if (!pass_info->reference_pass_name)\n+    {\n+      gcc_unreachable ();\n+    }\n+\n+  /* Try to insert the new pass to the pass lists. We need to check all\n+     three lists as the reference pass could be in one (or all) of them.  */\n+  if (!position_pass (pass_info, &all_lowering_passes)\n+      && !position_pass (pass_info, &all_ipa_passes)\n+      && !position_pass (pass_info, &all_passes))\n+    gcc_unreachable ();\n+  else\n+    {\n+      /* OK, we have successfully inserted the new pass. We need to register\n+         the dump files for the newly added pass and its duplicates (if any).\n+         Because the registration of plugin/backend passes happens after the\n+         command-line options are parsed, the options that specify single\n+         pass dumping (e.g. -fdump-tree-PASSNAME) cannot be used for new\n+         passes. Therefore we currently can only enable dumping of\n+         new passes when the 'dump-all' flags (e.g. -fdump-tree-all)\n+         are specified. While doing so, we also delete the pass_list_node\n+         objects created during pass positioning.  */\n+      while (added_pass_nodes)\n+        {\n+          struct pass_list_node *next_node = added_pass_nodes->next;\n+          enum tree_dump_index tdi;\n+          register_one_dump_file (added_pass_nodes->pass);\n+          if (added_pass_nodes->pass->type == SIMPLE_IPA_PASS\n+              || added_pass_nodes->pass->type == IPA_PASS)\n+            tdi = TDI_ipa_all;\n+          else if (added_pass_nodes->pass->type == GIMPLE_PASS)\n+            tdi = TDI_tree_all;\n+          else\n+            tdi = TDI_rtl_all;\n+          /* Check if dump-all flag is specified.  */\n+          if (get_dump_file_info (tdi)->state)\n+            get_dump_file_info (added_pass_nodes->pass->static_pass_number)\n+                ->state = get_dump_file_info (tdi)->state;\n+          XDELETE (added_pass_nodes);\n+          added_pass_nodes = next_node;\n+        }\n+    }\n+}\n \n /* Construct the pass tree.  The sequencing of passes is driven by\n    the cgraph routines:"}, {"sha": "414d5783fa592ed8c7b384303e9b3757f2c1ee69", "filename": "gcc/plugin.c", "status": "modified", "additions": 1, "deletions": 188, "changes": 189, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b80b0fd9c7f6206708bc423d131b0365a7296736/gcc%2Fplugin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b80b0fd9c7f6206708bc423d131b0365a7296736/gcc%2Fplugin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fplugin.c?ref=b80b0fd9c7f6206708bc423d131b0365a7296736", "patch": "@@ -78,20 +78,6 @@ struct callback_info\n /* An array of lists of 'callback_info' objects indexed by the event id.  */\n static struct callback_info *plugin_callbacks[PLUGIN_EVENT_LAST] = { NULL };\n \n-/* List node for an inserted pass instance. We need to keep track of all\n-   the newly-added pass instances (with 'added_pass_nodes' defined below)\n-   so that we can register their dump files after pass-positioning is finished.\n-   Registering dumping files needs to be post-processed or the\n-   static_pass_number of the opt_pass object would be modified and mess up\n-   the dump file names of future pass instances to be added.  */\n-struct pass_list_node\n-{\n-  struct opt_pass *pass;\n-  struct pass_list_node *next;\n-};\n-\n-static struct pass_list_node *added_pass_nodes = NULL;\n-static struct pass_list_node *prev_added_pass_node;\n \n #ifdef ENABLE_PLUGIN\n /* Each plugin should define an initialization function with exactly\n@@ -287,179 +273,6 @@ parse_plugin_arg_opt (const char *arg)\n   XDELETEVEC (name);\n }\n \n-\n-/* Insert the plugin pass at the proper position. Return true if the pass \n-   is successfully added.\n-\n-   PLUGIN_PASS_INFO - new pass to be inserted\n-   PASS_LIST        - root of the pass list to insert the new pass to  */\n-\n-static bool\n-position_pass (struct plugin_pass *plugin_pass_info,\n-               struct opt_pass **pass_list)\n-{\n-  struct opt_pass *pass = *pass_list, *prev_pass = NULL;\n-  bool success = false;\n-\n-  for ( ; pass; prev_pass = pass, pass = pass->next)\n-    {\n-      /* Check if the current pass is of the same type as the new pass and\n-         matches the name and the instance number of the reference pass.  */\n-      if (pass->type == plugin_pass_info->pass->type\n-          && pass->name\n-          && !strcmp (pass->name, plugin_pass_info->reference_pass_name)\n-          && ((plugin_pass_info->ref_pass_instance_number == 0)\n-              || (plugin_pass_info->ref_pass_instance_number ==\n-                  pass->static_pass_number)\n-              || (plugin_pass_info->ref_pass_instance_number == 1\n-                  && pass->todo_flags_start & TODO_mark_first_instance)))\n-        {\n-          struct opt_pass *new_pass = plugin_pass_info->pass;\n-          struct pass_list_node *new_pass_node;\n-\n-          /* The following code (if-statement) is adopted from next_pass_1.  */\n-          if (new_pass->static_pass_number)\n-            {\n-              new_pass = XNEW (struct opt_pass);\n-              memcpy (new_pass, plugin_pass_info->pass, sizeof (*new_pass));\n-              new_pass->next = NULL;\n-\n-              new_pass->todo_flags_start &= ~TODO_mark_first_instance;\n-\n-              plugin_pass_info->pass->static_pass_number -= 1;\n-              new_pass->static_pass_number =\n-                  -plugin_pass_info->pass->static_pass_number;\n-            }\n-          else\n-            {\n-              new_pass->todo_flags_start |= TODO_mark_first_instance;\n-              new_pass->static_pass_number = -1;\n-            }\n-\n-          /* Insert the new pass instance based on the positioning op.  */\n-          switch (plugin_pass_info->pos_op)\n-            {\n-              case PASS_POS_INSERT_AFTER:\n-                new_pass->next = pass->next;\n-                pass->next = new_pass;\n-\n-\t\t/* Skip newly inserted pass to avoid repeated\n-\t\t   insertions in the case where the new pass and the\n-\t\t   existing one have the same name.  */\n-                pass = new_pass; \n-                break;\n-              case PASS_POS_INSERT_BEFORE:\n-                new_pass->next = pass;\n-                if (prev_pass)\n-                  prev_pass->next = new_pass;\n-                else\n-                  *pass_list = new_pass;\n-                break;\n-              case PASS_POS_REPLACE:\n-                new_pass->next = pass->next;\n-                if (prev_pass)\n-                  prev_pass->next = new_pass;\n-                else\n-                  *pass_list = new_pass;\n-                new_pass->sub = pass->sub;\n-                new_pass->tv_id = pass->tv_id;\n-                pass = new_pass;\n-                break;\n-              default:\n-                error (\"Invalid pass positioning operation\");\n-                return false;\n-            }\n-\n-          /* Save the newly added pass (instance) in the added_pass_nodes\n-             list so that we can register its dump file later. Note that\n-             we cannot register the dump file now because doing so will modify\n-             the static_pass_number of the opt_pass object and therefore\n-             mess up the dump file name of future instances.  */\n-          new_pass_node = XCNEW (struct pass_list_node);\n-          new_pass_node->pass = new_pass;\n-          if (!added_pass_nodes)\n-            added_pass_nodes = new_pass_node;\n-          else\n-            prev_added_pass_node->next = new_pass_node;\n-          prev_added_pass_node = new_pass_node;\n-\n-          success = true;\n-        }\n-\n-      if (pass->sub && position_pass (plugin_pass_info, &pass->sub))\n-        success = true;\n-    }\n-\n-  return success;\n-}\n-\n-\n-/* Hook into the pass lists (trees) a new pass registered by a plugin.\n-\n-   PLUGIN_NAME - display name for the plugin\n-   PASS_INFO   - plugin pass information that specifies the opt_pass object,\n-                 reference pass, instance number, and how to position\n-                 the pass  */\n-\n-static void\n-register_pass (const char *plugin_name, struct plugin_pass *pass_info)\n-{\n-  if (!pass_info->pass)\n-    {\n-      error (\"No pass specified when registering a new pass in plugin %s\",\n-             plugin_name);\n-      return;\n-    }\n-\n-  if (!pass_info->reference_pass_name)\n-    {\n-      error (\"No reference pass specified for positioning the pass \"\n-             \" from plugin %s\", plugin_name);\n-      return;\n-    }\n-\n-  /* Try to insert the new pass to the pass lists. We need to check all\n-     three lists as the reference pass could be in one (or all) of them.  */\n-  if (!position_pass (pass_info, &all_lowering_passes)\n-      && !position_pass (pass_info, &all_ipa_passes)\n-      && !position_pass (pass_info, &all_passes))\n-    error (\"Failed to position pass %s registered by plugin %s. \"\n-           \"Cannot find the (specified instance of) reference pass %s\",\n-           pass_info->pass->name, plugin_name, pass_info->reference_pass_name);\n-  else\n-    {\n-      /* OK, we have successfully inserted the new pass. We need to register\n-         the dump files for the newly added pass and its duplicates (if any).\n-         Because the registration of plugin passes happens after the\n-         command-line options are parsed, the options that specify single\n-         pass dumping (e.g. -fdump-tree-PASSNAME) cannot be used for new\n-         plugin passes. Therefore we currently can only enable dumping of\n-         new plugin passes when the 'dump-all' flags (e.g. -fdump-tree-all)\n-         are specified. While doing so, we also delete the pass_list_node\n-         objects created during pass positioning.  */\n-      while (added_pass_nodes)\n-        {\n-          struct pass_list_node *next_node = added_pass_nodes->next;\n-          enum tree_dump_index tdi;\n-          register_one_dump_file (added_pass_nodes->pass);\n-          if (added_pass_nodes->pass->type == SIMPLE_IPA_PASS\n-              || added_pass_nodes->pass->type == IPA_PASS)\n-            tdi = TDI_ipa_all;\n-          else if (added_pass_nodes->pass->type == GIMPLE_PASS)\n-            tdi = TDI_tree_all;\n-          else\n-            tdi = TDI_rtl_all;\n-          /* Check if dump-all flag is specified.  */\n-          if (get_dump_file_info (tdi)->state)\n-            get_dump_file_info (added_pass_nodes->pass->static_pass_number)\n-                ->state = get_dump_file_info (tdi)->state;\n-          XDELETE (added_pass_nodes);\n-          added_pass_nodes = next_node;\n-        }\n-    }\n-}\n-\n-\n /* Register additional plugin information. NAME is the name passed to\n    plugin_init. INFO is the information that should be registered. */\n \n@@ -490,7 +303,7 @@ register_callback (const char *plugin_name,\n     {\n       case PLUGIN_PASS_MANAGER_SETUP:\n \tgcc_assert (!callback);\n-        register_pass (plugin_name, (struct plugin_pass *) user_data);\n+        register_pass ((struct register_pass_info *) user_data);\n         break;\n       case PLUGIN_INFO:\n \tgcc_assert (!callback);"}, {"sha": "3241ee1482c46236fdff000b8e22973bf7a35c3d", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b80b0fd9c7f6206708bc423d131b0365a7296736/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b80b0fd9c7f6206708bc423d131b0365a7296736/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=b80b0fd9c7f6206708bc423d131b0365a7296736", "patch": "@@ -308,6 +308,27 @@ struct dump_file_info\n #define TODO_verify_all \\\n   (TODO_verify_ssa | TODO_verify_flow | TODO_verify_stmts)\n \n+\n+/* Register pass info. */\n+\n+enum pass_positioning_ops\n+{\n+  PASS_POS_INSERT_AFTER,  /* Insert after the reference pass.  */\n+  PASS_POS_INSERT_BEFORE, /* Insert before the reference pass.  */\n+  PASS_POS_REPLACE        /* Replace the reference pass.  */\n+};\n+\n+struct register_pass_info\n+{\n+  struct opt_pass *pass;            /* New pass to register.  */\n+  const char *reference_pass_name;  /* Name of the reference pass for hooking\n+                                       up the new pass.  */\n+  int ref_pass_instance_number;     /* Insert the pass at the specified\n+                                       instance number of the reference pass.\n+                                       Do it for every instance if it is 0.  */\n+  enum pass_positioning_ops pos_op; /* how to insert the new pass.  */\n+};\n+\n extern void tree_lowering_passes (tree decl);\n \n extern struct gimple_opt_pass pass_mudflap_1;\n@@ -545,6 +566,7 @@ extern void print_current_pass (FILE *);\n extern void debug_pass (void);\n extern void register_one_dump_file (struct opt_pass *);\n extern bool function_called_by_processed_nodes_p (void);\n+extern void register_pass (struct register_pass_info *);\n \n /* Set to true if the pass is called the first time during compilation of the\n    current function.  Note that using this information in the optimization"}]}