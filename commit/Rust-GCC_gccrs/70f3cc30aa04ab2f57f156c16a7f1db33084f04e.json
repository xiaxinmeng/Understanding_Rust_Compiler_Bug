{"sha": "70f3cc30aa04ab2f57f156c16a7f1db33084f04e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzBmM2NjMzBhYTA0YWIyZjU3ZjE1NmMxNmE3ZjFkYjMzMDg0ZjA0ZQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2004-09-25T10:05:09Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2004-09-25T10:05:09Z"}, "message": "passes.c (rest_of_handle_cfg): Disable const/pure function detection when doing tree based profiling.\n\n\t* passes.c (rest_of_handle_cfg): Disable const/pure function\n\tdetection when doing tree based profiling.\n\n\t* tree-inline.c (expand_call_inline): Fix incorrectly reversed\n\tconditional.\n\nFrom-SVN: r88092", "tree": {"sha": "7e0fabeafbba7b2dbafffbeed8cf36595efdeef3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7e0fabeafbba7b2dbafffbeed8cf36595efdeef3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/70f3cc30aa04ab2f57f156c16a7f1db33084f04e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/70f3cc30aa04ab2f57f156c16a7f1db33084f04e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/70f3cc30aa04ab2f57f156c16a7f1db33084f04e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/70f3cc30aa04ab2f57f156c16a7f1db33084f04e/comments", "author": null, "committer": null, "parents": [{"sha": "20319d321a0add192498083daefc7d0cc7cb90a2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/20319d321a0add192498083daefc7d0cc7cb90a2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/20319d321a0add192498083daefc7d0cc7cb90a2"}], "stats": {"total": 21, "additions": 18, "deletions": 3}, "files": [{"sha": "db7034463da2b9c7b5aa53adf883a4065c88b762", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f3cc30aa04ab2f57f156c16a7f1db33084f04e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f3cc30aa04ab2f57f156c16a7f1db33084f04e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=70f3cc30aa04ab2f57f156c16a7f1db33084f04e", "patch": "@@ -1,3 +1,11 @@\n+2004-09-25  Jan Hubicka  <jh@suse.cz>\n+\n+\t* passes.c (rest_of_handle_cfg): Disable const/pure function\n+\tdetection when doing tree based profiling.\n+\n+\t* tree-inline.c (expand_call_inline): Fix incorrectly reversed\n+\tconditional.\n+\n 2004-09-25  Richard Sandiford  <rsandifo@redhat.com>\n \n \t* config/mips/mips.h (struct mips_args): Clarify comments."}, {"sha": "5488981c013a96142046c5a1fcb80b6323d2006b", "filename": "gcc/passes.c", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f3cc30aa04ab2f57f156c16a7f1db33084f04e/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f3cc30aa04ab2f57f156c16a7f1db33084f04e/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=70f3cc30aa04ab2f57f156c16a7f1db33084f04e", "patch": "@@ -880,8 +880,15 @@ rest_of_handle_cfg (void)\n      it as constant, otherwise -fbranch-probabilities will not read data back.\n \n      life_analysis rarely eliminates modification of external memory.\n-   */\n-  if (optimize)\n+\n+     FIXME: now with tree based profiling we are in the trap described above\n+     again.  It seems to be easiest to disable the optimization for time\n+     being before the problem is either solved by moving the transformation\n+     to the IPA level (we need the CFG for this) or the very early optimization\n+     passes are made to ignore the const/pure flags so code does not change.  */\n+  if (optimize\n+      && (!flag_tree_based_profiling\n+\t  || (!profile_arc_flag && !flag_branch_probabilities)))\n     {\n       /* Alias analysis depends on this information and mark_constant_function\n        depends on alias analysis.  */"}, {"sha": "38fa455aa10eaabaf1d133dd8eda9faaeb2882e8", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/70f3cc30aa04ab2f57f156c16a7f1db33084f04e/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/70f3cc30aa04ab2f57f156c16a7f1db33084f04e/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=70f3cc30aa04ab2f57f156c16a7f1db33084f04e", "patch": "@@ -1458,7 +1458,7 @@ expand_call_inline (tree *tp, int *walk_subtrees, void *data)\n          where previous inlining turned indirect call into direct call by\n          constant propagating arguments.  In all other cases we hit a bug\n          (incorrect node sharing is most common reason for missing edges.  */\n-      gcc_assert (dest->needed || flag_unit_at_a_time);\n+      gcc_assert (dest->needed || !flag_unit_at_a_time);\n       cgraph_create_edge (id->node, dest, t)->inline_failed\n \t= N_(\"originally indirect function call not considered for inlining\");\n       goto egress;"}]}