{"sha": "a458ad1df8ca8a09c89a8fe3cf175d61075a3404", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTQ1OGFkMWRmOGNhOGEwOWM4OWE4ZmUzY2YxNzVkNjEwNzVhMzQwNA==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "1999-04-06T18:11:08Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "1999-04-06T18:11:08Z"}, "message": "YA spurious-uninitialized-variable-warning test\n\nFrom-SVN: r26223", "tree": {"sha": "59bb48cb932d658951d128f4236b59faed69d2c2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/59bb48cb932d658951d128f4236b59faed69d2c2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a458ad1df8ca8a09c89a8fe3cf175d61075a3404", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a458ad1df8ca8a09c89a8fe3cf175d61075a3404", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a458ad1df8ca8a09c89a8fe3cf175d61075a3404", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a458ad1df8ca8a09c89a8fe3cf175d61075a3404/comments", "author": null, "committer": null, "parents": [{"sha": "1e7d57a3b1f7bcd100a632033a148995261b1b9c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e7d57a3b1f7bcd100a632033a148995261b1b9c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1e7d57a3b1f7bcd100a632033a148995261b1b9c"}], "stats": {"total": 115, "additions": 115, "deletions": 0}, "files": [{"sha": "119ed6902aa401d6c09f494515d3aac51c2369d4", "filename": "gcc/testsuite/gcc.dg/uninit-A.c", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a458ad1df8ca8a09c89a8fe3cf175d61075a3404/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-A.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a458ad1df8ca8a09c89a8fe3cf175d61075a3404/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-A.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Funinit-A.c?ref=a458ad1df8ca8a09c89a8fe3cf175d61075a3404", "patch": "@@ -0,0 +1,115 @@\n+/* Inspired by part of java/parse.y.\n+   May be a real bug in CSE. */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -Wall\" } */\n+\n+struct tree\n+{\n+    struct tree *car, *cdr, *wfl;\n+    int code;\n+    struct { int renp:1; int rtnp:1; int rpnp:1; } flags;\n+};\n+typedef struct tree *tree;\n+#define NULL_TREE ((tree)0)\n+\n+/* Codes */\n+enum\n+{\n+    CALL_EXPR, NEW_ARRAY_EXPR, NEW_CLASS_EXPR, CONVERT_EXPR,\n+    ARRAY_REF, CONDITIONAL_EXPR, STRING_CST, EXPR_WITH_FILE_LOCATION\n+};\n+\n+/* Flags */\n+#define RESOLVE_EXPRESSION_NAME_P(t) ((t)->flags.renp)\n+#define RESOLVE_TYPE_NAME_P(t) ((t)->flags.rtnp)\n+#define RESOLVE_PACKAGE_NAME_P(t) ((t)->flags.rpnp)\n+\n+/* Macros */\n+#define EXPR_WFL_QUALIFICATION(t) ((t)->wfl)\n+#define QUAL_WFL(t) ((t)->wfl)\n+#define EXPR_WFL_NODE(t) ((t)->wfl)\n+#define TREE_CODE(t) ((t)->code)\n+#define TREE_OPERAND(t,x) ((t)->car)\n+#define CLASSTYPE_SUPER(t) ((t)->car)\n+#define IDENTIFIER_LOCAL_VALUE(t) ((t)->car)\n+#define TREE_CHAIN(t) ((t)->cdr)\n+#define QUAL_RESOLUTION(t) ((t)->cdr)\n+\n+extern tree current_class, this_identifier_node;\n+extern tree super_identifier_node, length_identifier_node;\n+\n+tree resolve_and_layout (tree, tree);\n+tree lookup_field_wrapper (tree, tree);\n+\n+void\n+qualify_ambiguous_name (id)\n+     tree id;\n+{\n+  tree qual, qual_wfl, decl;\n+  tree name;\t /* { dg-bogus \"name\" \"uninitialized variable warning\" { xfail *-*-* } } */\n+  tree ptr_type; /* { dg-bogus \"ptr_type\" \"uninitialized variable warning\" { xfail *-*-* } } */\n+  int again, new_array_found = 0;\n+  int super_found = 0, this_found = 0;\n+\n+  qual = EXPR_WFL_QUALIFICATION (id);\n+  do {\n+    qual_wfl = QUAL_WFL (qual);\n+    switch (TREE_CODE (qual_wfl))\n+      {\n+      case CALL_EXPR:\n+\tqual_wfl = TREE_OPERAND (qual_wfl, 0);\n+\tif (TREE_CODE (qual_wfl) != EXPR_WITH_FILE_LOCATION)\n+\t  {\n+\t    qual = EXPR_WFL_QUALIFICATION (qual_wfl);\n+\t    qual_wfl = QUAL_WFL (qual);\n+\t  }\n+\tbreak;\n+      case NEW_ARRAY_EXPR:\n+\tqual = TREE_CHAIN (qual);\n+\tnew_array_found = again = 1;\n+\tcontinue;\n+      case NEW_CLASS_EXPR:\n+      case CONVERT_EXPR:\n+\tqual_wfl = TREE_OPERAND (qual_wfl, 0);\n+\tbreak;\n+      case ARRAY_REF:\n+\twhile (TREE_CODE (qual_wfl) == ARRAY_REF)\n+\t  qual_wfl = TREE_OPERAND (qual_wfl, 0);\n+\tbreak;\n+      default:\n+\tbreak;\n+      }\n+\n+    name = EXPR_WFL_NODE (qual_wfl);\n+    ptr_type = current_class;\n+    again = 0;\n+\n+  } while (again);\n+\n+  /* If you put straightforward uses of name and ptr_type here\n+     instead of the if-else sequence below, the warnings go away.\n+     Therefore I suspect a real bug. */\n+  \n+  if (!this_found && !super_found && (decl = IDENTIFIER_LOCAL_VALUE (name)))\n+    {\n+      RESOLVE_EXPRESSION_NAME_P (qual_wfl) = 1;\n+      QUAL_RESOLUTION (qual) = decl;\n+    }\n+  else if ((decl = lookup_field_wrapper (ptr_type, name))\n+\t   || (new_array_found && name == length_identifier_node))\n+    {\n+      RESOLVE_EXPRESSION_NAME_P (qual_wfl) = 1;\n+      QUAL_RESOLUTION (qual) = (new_array_found ? NULL_TREE : decl);\n+    }\n+  else if ((decl = resolve_and_layout (name, NULL_TREE)))\n+    {\n+      RESOLVE_TYPE_NAME_P (qual_wfl) = 1;\n+      QUAL_RESOLUTION (qual) = decl;\n+    }\n+  else if (TREE_CODE (QUAL_WFL (qual)) == CALL_EXPR\n+\t   || TREE_CODE (QUAL_WFL (qual)) == ARRAY_REF)\n+    RESOLVE_EXPRESSION_NAME_P (qual_wfl) = 1;\n+  else \n+    RESOLVE_PACKAGE_NAME_P (qual_wfl) = 1;\n+}"}]}