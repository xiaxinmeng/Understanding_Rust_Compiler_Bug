{"sha": "c3f829c1a6d54e6d2e26dbd09fe8a66e4b9185a9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzNmODI5YzFhNmQ1NGU2ZDJlMjZkYmQwOWZlOGE2NmU0YjkxODVhOQ==", "commit": {"author": {"name": "Gabriel Dos Reis", "email": "gdr@integrable-solutions.net", "date": "2005-05-28T15:52:48Z"}, "committer": {"name": "Gabriel Dos Reis", "email": "gdr@gcc.gnu.org", "date": "2005-05-28T15:52:48Z"}, "message": "configure.ac: Check declarations for asprintf and vasprintf.\n\n\t* configure.ac: Check declarations for asprintf and vasprintf.\n\t* config.in: Regenerate.\n\t* configure: Likewise.\n\n\t* charset.c (conversion_loop): Use XRESIZEVEC.\n\t(convert_no_conversion): Likewise.\n\t(convert_using_iconv): Likewise.\n\t(init_iconv_desc): Cast return value of alloca.\n\t(cpp_host_to_exec_charset): Use XNEWVEC.\n\t(emit_numeric_escape): Use XRESIZEVEC.\n\t(cpp_interpret_string): Use XNEWVEC.\n\t(cpp_interpret_string): Use XRESIZEVEC.\n\t(_cpp_interpret_identifier): Cast return value of alloca.\n\t(_cpp_convert_input): Use XNEWVEC and XRESIZEVEC.\n\t* directives.c (glue_header_name): Use XNEWVEC and XRESIZEVEC.\n\t(parse_include): Use XNEWVEC.\n\t(insert_pragma_entry): Rename local variable \"new\" to\n\t\"new_entry\".\n\t(save_registered_pragmas): Cast return value of xmemdup.\n\t(destringize_and_run): Same for alloca.\n\t(parse_assertion): Likewise.\n\t(do_assert): Cast allocated storage to proper type.\n\t(cpp_define): Likewise.\n\t(_cpp_define_builtin): Likewise.\n\t(cpp_undef): Likewise.\n\t(handle_assertion): Likewise.\n\t(cpp_push_buffer): Rename local variable \"new\" to \"new_buffer\".\n\t* expr.c (CPP_UPLUS): Cast value to type cpp_ttype.\n\t(CPP_UMINUS): Likewise.\n\t(struct cpp_operator): Rename from struct operator.\n\t(_cpp_expand_op_stack): Use XRESIZEVEC.\n\t* files.c (pch_open_file): Use XNEWVEC.\n\t(pch_open_file): Use XRESIZEVEC.\n\t(read_file_guts): Use XNEWVEC and XRESIZEVEC.\n\t(dir_name_of_file): Use XNEWVEC.\n\t(make_cpp_file): Use XCNEW.\n\t(make_cpp_dir): Likewise.\n\t(allocate_file_hash_entries): USE XNEWVEC.\n\t(cpp_included): Cast return value of htab_find_with_hash.\n\t(append_file_to_dir): Use XNEWVEC.\n\t(read_filename_string): Likewise. Use XRESIZEVEC too.\n\t(read_name_map): Cast return value of alloca.  Use XRESIZEVEC.\n\t(remap_filename): Use XNEWVEC.\n\t(struct pchf_entry): Move definition out of struct pchf_data.\n\t(_cpp_save_file_entries): Use XCNEWVAR.\n\t(_cpp_read_file_entries): Use XNEWVAR.\n\t* identifiers.c (alloc_node): Use XOBNEW.\n\t* init.c (cpp_create_reader): Use XCNEW.\n\t(cpp_init_builtins): Cast of b->value to enum builtin_type.\n\t(read_original_directory): Cast return value of alloca.\n\t* lex.c (add_line_note): Use XRESIZEVEC.\n\t(warn_about_normalization): Use XNEWVEC.\n\t(_cpp_lex_direct): Cast node->directive_index to (enum cpp_ttype).\n\t(new_buff): Use XNEWVEC.\n\t* line-map.c (linemap_add): Use XRESIZEVEC.\n\t* macro.c (builtin_macro): Cast return value of alloca.\n\t(paste_tokens): Likewise.\n\t(expand_arg): Use XNEWVEC and XRESIZEVEC.\n\t(_cpp_save_parameter): Use XRESIZEVEC.\n\t(create_iso_definition): Cast allocated storage to proper type.\n\t(_cpp_create_definition): Likewise.\n\t(cpp_macro_definition): Use XRESIZEVEC.\n\t* makedepend.c (add_clm): Use XNEW.\n\t(add_dir): Likewise.\n\t* mkdeps.c (munge): Use XNEWVEC.\n\t(deps_init): Use XCNEW.\n\t(deps_add_target): Use XRESIZEVEC.\n\t(deps_add_default_target): Cast return value of alloca.\n\t(deps_add_dep): Use XRESIZEVEC.\n\t(deps_add_vpath): Likewise.  Use XNEWVEC too.\n\t(deps_restore): Likewise.\n\t* pch.c (save_idents): Use XNEW and XNEWVEC.\n\t(cpp_save_state): Use XNEW.\n\t(count_defs): Cast return value of htab_find.\n\t(write_defs): Likewise.\n\t(cpp_write_pch_deps): Use XNEWVEC.\n\t(collect_ht_nodes): Use XRESIZEVEC.\n\t(cpp_valid_state): Use XNEWVEC.\n\t(save_macros): Use XRESIZEVEC.  Cast return value of xmemdup.\n\t* symtab.c (ht_create): Use XCNEW.\n\t(ht_lookup_with_hash): Cast return value of obstack_copy0.\n\t(ht_expand): Use XCNEWVEC.\n\t* system.h (HAVE_DESIGNATED_INITIALIZERS): False if __cplusplus.\n\t(bool): Do not define if __cplusplus.\n\nFrom-SVN: r100295", "tree": {"sha": "37f58a36e96cbf32993eff9e16ef6ca793365675", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/37f58a36e96cbf32993eff9e16ef6ca793365675"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c3f829c1a6d54e6d2e26dbd09fe8a66e4b9185a9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c3f829c1a6d54e6d2e26dbd09fe8a66e4b9185a9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c3f829c1a6d54e6d2e26dbd09fe8a66e4b9185a9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c3f829c1a6d54e6d2e26dbd09fe8a66e4b9185a9/comments", "author": {"login": "cxx-undef", "id": 5528103, "node_id": "MDQ6VXNlcjU1MjgxMDM=", "avatar_url": "https://avatars.githubusercontent.com/u/5528103?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cxx-undef", "html_url": "https://github.com/cxx-undef", "followers_url": "https://api.github.com/users/cxx-undef/followers", "following_url": "https://api.github.com/users/cxx-undef/following{/other_user}", "gists_url": "https://api.github.com/users/cxx-undef/gists{/gist_id}", "starred_url": "https://api.github.com/users/cxx-undef/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cxx-undef/subscriptions", "organizations_url": "https://api.github.com/users/cxx-undef/orgs", "repos_url": "https://api.github.com/users/cxx-undef/repos", "events_url": "https://api.github.com/users/cxx-undef/events{/privacy}", "received_events_url": "https://api.github.com/users/cxx-undef/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "426357eaccd7e80b91170d8f92f71697e633707c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/426357eaccd7e80b91170d8f92f71697e633707c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/426357eaccd7e80b91170d8f92f71697e633707c"}], "stats": {"total": 557, "additions": 405, "deletions": 152}, "files": [{"sha": "f4e8a5e83cc67bcef46e650611e2d5a1c6dcc775", "filename": "libcpp/ChangeLog", "status": "modified", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3f829c1a6d54e6d2e26dbd09fe8a66e4b9185a9/libcpp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3f829c1a6d54e6d2e26dbd09fe8a66e4b9185a9/libcpp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2FChangeLog?ref=c3f829c1a6d54e6d2e26dbd09fe8a66e4b9185a9", "patch": "@@ -1,3 +1,90 @@\n+2005-05-28  Gabriel Dos Reis  <gdr@integrable-solutions.net>\n+\n+\t* configure.ac: Check declarations for asprintf and vasprintf.\n+\t* config.in: Regenerate.\n+\t* configure: Likewise.\n+\n+\t* charset.c (conversion_loop): Use XRESIZEVEC.\n+\t(convert_no_conversion): Likewise.\n+\t(convert_using_iconv): Likewise.\n+\t(init_iconv_desc): Cast return value of alloca.\n+\t(cpp_host_to_exec_charset): Use XNEWVEC.\n+\t(emit_numeric_escape): Use XRESIZEVEC.\n+\t(cpp_interpret_string): Use XNEWVEC.\n+\t(cpp_interpret_string): Use XRESIZEVEC.\n+\t(_cpp_interpret_identifier): Cast return value of alloca.\n+\t(_cpp_convert_input): Use XNEWVEC and XRESIZEVEC.\n+\t* directives.c (glue_header_name): Use XNEWVEC and XRESIZEVEC.\n+\t(parse_include): Use XNEWVEC.\n+\t(insert_pragma_entry): Rename local variable \"new\" to\n+\t\"new_entry\". \n+\t(save_registered_pragmas): Cast return value of xmemdup.\n+\t(destringize_and_run): Same for alloca.\n+\t(parse_assertion): Likewise.\n+\t(do_assert): Cast allocated storage to proper type.\n+\t(cpp_define): Likewise.\n+\t(_cpp_define_builtin): Likewise.\n+\t(cpp_undef): Likewise.\n+\t(handle_assertion): Likewise.\n+\t(cpp_push_buffer): Rename local variable \"new\" to \"new_buffer\".\n+\t* expr.c (CPP_UPLUS): Cast value to type cpp_ttype.\n+\t(CPP_UMINUS): Likewise.\n+\t(struct cpp_operator): Rename from struct operator.\n+\t(_cpp_expand_op_stack): Use XRESIZEVEC.\n+\t* files.c (pch_open_file): Use XNEWVEC.\n+\t(pch_open_file): Use XRESIZEVEC.\n+\t(read_file_guts): Use XNEWVEC and XRESIZEVEC.\n+\t(dir_name_of_file): Use XNEWVEC.\n+\t(make_cpp_file): Use XCNEW.\n+\t(make_cpp_dir): Likewise.\n+\t(allocate_file_hash_entries): USE XNEWVEC.\n+\t(cpp_included): Cast return value of htab_find_with_hash.\n+\t(append_file_to_dir): Use XNEWVEC.\n+\t(read_filename_string): Likewise. Use XRESIZEVEC too.\n+\t(read_name_map): Cast return value of alloca.  Use XRESIZEVEC.\n+\t(remap_filename): Use XNEWVEC.\n+\t(struct pchf_entry): Move definition out of struct pchf_data.\n+\t(_cpp_save_file_entries): Use XCNEWVAR.\n+\t(_cpp_read_file_entries): Use XNEWVAR.\n+\t* identifiers.c (alloc_node): Use XOBNEW.\n+\t* init.c (cpp_create_reader): Use XCNEW.\n+\t(cpp_init_builtins): Cast of b->value to enum builtin_type.\n+\t(read_original_directory): Cast return value of alloca.\n+\t* lex.c (add_line_note): Use XRESIZEVEC.\n+\t(warn_about_normalization): Use XNEWVEC.\n+\t(_cpp_lex_direct): Cast node->directive_index to (enum cpp_ttype).\n+\t(new_buff): Use XNEWVEC.\n+\t* line-map.c (linemap_add): Use XRESIZEVEC.\n+\t* macro.c (builtin_macro): Cast return value of alloca.\n+\t(paste_tokens): Likewise.\n+\t(expand_arg): Use XNEWVEC and XRESIZEVEC.\n+\t(_cpp_save_parameter): Use XRESIZEVEC.\n+\t(create_iso_definition): Cast allocated storage to proper type.\n+\t(_cpp_create_definition): Likewise.\n+\t(cpp_macro_definition): Use XRESIZEVEC.\n+\t* makedepend.c (add_clm): Use XNEW.\n+\t(add_dir): Likewise.\n+\t* mkdeps.c (munge): Use XNEWVEC.\n+\t(deps_init): Use XCNEW.\n+\t(deps_add_target): Use XRESIZEVEC.\n+\t(deps_add_default_target): Cast return value of alloca.\n+\t(deps_add_dep): Use XRESIZEVEC.\n+\t(deps_add_vpath): Likewise.  Use XNEWVEC too.\n+\t(deps_restore): Likewise.\n+\t* pch.c (save_idents): Use XNEW and XNEWVEC.\n+\t(cpp_save_state): Use XNEW.\n+\t(count_defs): Cast return value of htab_find.\n+\t(write_defs): Likewise.\n+\t(cpp_write_pch_deps): Use XNEWVEC.\n+\t(collect_ht_nodes): Use XRESIZEVEC.\n+\t(cpp_valid_state): Use XNEWVEC.\n+\t(save_macros): Use XRESIZEVEC.  Cast return value of xmemdup.\n+\t* symtab.c (ht_create): Use XCNEW.\n+\t(ht_lookup_with_hash): Cast return value of obstack_copy0.\n+\t(ht_expand): Use XCNEWVEC.\n+\t* system.h (HAVE_DESIGNATED_INITIALIZERS): False if __cplusplus.\n+\t(bool): Do not define if __cplusplus.\n+\n 2005-05-12  Zack Weinberg  <zack@codesourcery.com>\n \n \t* directives.c (#sccs table entry): Mark IN_I, consistent with #ident."}, {"sha": "f382d7f57fcad445e6872a79f5a25b8195c4031b", "filename": "libcpp/charset.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3f829c1a6d54e6d2e26dbd09fe8a66e4b9185a9/libcpp%2Fcharset.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3f829c1a6d54e6d2e26dbd09fe8a66e4b9185a9/libcpp%2Fcharset.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fcharset.c?ref=c3f829c1a6d54e6d2e26dbd09fe8a66e4b9185a9", "patch": "@@ -486,7 +486,7 @@ conversion_loop (int (*const one_conversion)(iconv_t, const uchar **, size_t *,\n \n       outbytesleft += OUTBUF_BLOCK_SIZE;\n       to->asize += OUTBUF_BLOCK_SIZE;\n-      to->text = xrealloc (to->text, to->asize);\n+      to->text = XRESIZEVEC (uchar, to->text, to->asize);\n       outbuf = to->text + to->asize - outbytesleft;\n     }\n }\n@@ -538,7 +538,7 @@ convert_no_conversion (iconv_t cd ATTRIBUTE_UNUSED,\n   if (to->len + flen > to->asize)\n     {\n       to->asize = to->len + flen;\n-      to->text = xrealloc (to->text, to->asize);\n+      to->text = XRESIZEVEC (uchar, to->text, to->asize);\n     }\n   memcpy (to->text + to->len, from, flen);\n   to->len += flen;\n@@ -578,7 +578,7 @@ convert_using_iconv (iconv_t cd, const uchar *from, size_t flen,\n \n       outbytesleft += OUTBUF_BLOCK_SIZE;\n       to->asize += OUTBUF_BLOCK_SIZE;\n-      to->text = xrealloc (to->text, to->asize);\n+      to->text = XRESIZEVEC (uchar, to->text, to->asize);\n       outbuf = (char *)to->text + to->asize - outbytesleft;\n     }\n }\n@@ -628,7 +628,7 @@ init_iconv_desc (cpp_reader *pfile, const char *to, const char *from)\n       return ret;\n     }\n \n-  pair = alloca(strlen(to) + strlen(from) + 2);\n+  pair = (char *) alloca(strlen(to) + strlen(from) + 2);\n \n   strcpy(pair, from);\n   strcat(pair, \"/\");\n@@ -751,7 +751,7 @@ cpp_host_to_exec_charset (cpp_reader *pfile, cppchar_t c)\n \n   /* This should never need to reallocate, but just in case... */\n   tbuf.asize = 1;\n-  tbuf.text = xmalloc (tbuf.asize);\n+  tbuf.text = XNEWVEC (uchar, tbuf.asize);\n   tbuf.len = 0;\n \n   if (!APPLY_CONVERSION (pfile->narrow_cset_desc, sbuf, 1, &tbuf))\n@@ -1087,7 +1087,7 @@ emit_numeric_escape (cpp_reader *pfile, cppchar_t n,\n       if (tbuf->len + nbwc > tbuf->asize)\n \t{\n \t  tbuf->asize += OUTBUF_BLOCK_SIZE;\n-\t  tbuf->text = xrealloc (tbuf->text, tbuf->asize);\n+\t  tbuf->text = XRESIZEVEC (uchar, tbuf->text, tbuf->asize);\n \t}\n \n       for (i = 0; i < nbwc; i++)\n@@ -1105,7 +1105,7 @@ emit_numeric_escape (cpp_reader *pfile, cppchar_t n,\n       if (tbuf->len + 1 > tbuf->asize)\n \t{\n \t  tbuf->asize += OUTBUF_BLOCK_SIZE;\n-\t  tbuf->text = xrealloc (tbuf->text, tbuf->asize);\n+\t  tbuf->text = XRESIZEVEC (uchar, tbuf->text, tbuf->asize);\n \t}\n       tbuf->text[tbuf->len++] = n;\n     }\n@@ -1306,7 +1306,7 @@ cpp_interpret_string (cpp_reader *pfile, const cpp_string *from, size_t count,\n     = wide ? pfile->wide_cset_desc : pfile->narrow_cset_desc;\n \n   tbuf.asize = MAX (OUTBUF_BLOCK_SIZE, from->len);\n-  tbuf.text = xmalloc (tbuf.asize);\n+  tbuf.text = XNEWVEC (uchar, tbuf.asize);\n   tbuf.len = 0;\n \n   for (i = 0; i < count; i++)\n@@ -1337,7 +1337,7 @@ cpp_interpret_string (cpp_reader *pfile, const cpp_string *from, size_t count,\n   /* NUL-terminate the 'to' buffer and translate it to a cpp_string\n      structure.  */\n   emit_numeric_escape (pfile, 0, &tbuf, wide);\n-  tbuf.text = xrealloc (tbuf.text, tbuf.len);\n+  tbuf.text = XRESIZEVEC (uchar, tbuf.text, tbuf.len);\n   to->text = tbuf.text;\n   to->len = tbuf.len;\n   return true;\n@@ -1526,7 +1526,7 @@ _cpp_interpret_identifier (cpp_reader *pfile, const uchar *id, size_t len)\n {\n   /* It turns out that a UCN escape always turns into fewer characters\n      than the escape itself, so we can allocate a temporary in advance.  */\n-  uchar * buf = alloca (len + 1);\n+  uchar * buf = (uchar *) alloca (len + 1);\n   uchar * bufp = buf;\n   size_t idp;\n   \n@@ -1598,7 +1598,7 @@ _cpp_convert_input (cpp_reader *pfile, const char *input_charset,\n   else\n     {\n       to.asize = MAX (65536, len);\n-      to.text = xmalloc (to.asize);\n+      to.text = XNEWVEC (uchar, to.asize);\n       to.len = 0;\n \n       if (!APPLY_CONVERSION (input_cset, input, len, &to))\n@@ -1616,7 +1616,7 @@ _cpp_convert_input (cpp_reader *pfile, const char *input_charset,\n   /* Resize buffer if we allocated substantially too much, or if we\n      haven't enough space for the \\n-terminator.  */\n   if (to.len + 4096 < to.asize || to.len >= to.asize)\n-    to.text = xrealloc (to.text, to.len + 1);\n+    to.text = XRESIZEVEC (uchar, to.text, to.len + 1);\n \n   /* If the file is using old-school Mac line endings (\\r only),\n      terminate with another \\r, not an \\n, so that we do not mistake"}, {"sha": "2b05ba0c401fd8a6e48a2c622031470e13c34a8a", "filename": "libcpp/config.in", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3f829c1a6d54e6d2e26dbd09fe8a66e4b9185a9/libcpp%2Fconfig.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3f829c1a6d54e6d2e26dbd09fe8a66e4b9185a9/libcpp%2Fconfig.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fconfig.in?ref=c3f829c1a6d54e6d2e26dbd09fe8a66e4b9185a9", "patch": "@@ -29,6 +29,10 @@\n    */\n #undef HAVE_DECL_ABORT\n \n+/* Define to 1 if you have the declaration of `asprintf', and to 0 if you\n+   don't. */\n+#undef HAVE_DECL_ASPRINTF\n+\n /* Define to 1 if you have the declaration of `basename', and to 0 if you\n    don't. */\n #undef HAVE_DECL_BASENAME\n@@ -105,6 +109,10 @@\n    don't. */\n #undef HAVE_DECL_PUTC_UNLOCKED\n \n+/* Define to 1 if you have the declaration of `vasprintf', and to 0 if you\n+   don't. */\n+#undef HAVE_DECL_VASPRINTF\n+\n /* Define to 1 if you have the <fcntl.h> header file. */\n #undef HAVE_FCNTL_H\n "}, {"sha": "d0c04d959a1df01ba38dbfb117fb5f6859c9c293", "filename": "libcpp/configure", "status": "modified", "additions": 140, "deletions": 0, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3f829c1a6d54e6d2e26dbd09fe8a66e4b9185a9/libcpp%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3f829c1a6d54e6d2e26dbd09fe8a66e4b9185a9/libcpp%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fconfigure?ref=c3f829c1a6d54e6d2e26dbd09fe8a66e4b9185a9", "patch": "@@ -5076,6 +5076,76 @@ else\n _ACEOF\n \n \n+fi\n+echo \"$as_me:$LINENO: checking whether asprintf is declared\" >&5\n+echo $ECHO_N \"checking whether asprintf is declared... $ECHO_C\" >&6\n+if test \"${ac_cv_have_decl_asprintf+set}\" = set; then\n+  echo $ECHO_N \"(cached) $ECHO_C\" >&6\n+else\n+  cat >conftest.$ac_ext <<_ACEOF\n+/* confdefs.h.  */\n+_ACEOF\n+cat confdefs.h >>conftest.$ac_ext\n+cat >>conftest.$ac_ext <<_ACEOF\n+/* end confdefs.h.  */\n+$ac_includes_default\n+int\n+main ()\n+{\n+#ifndef asprintf\n+  char *p = (char *) asprintf;\n+#endif\n+\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+rm -f conftest.$ac_objext\n+if { (eval echo \"$as_me:$LINENO: \\\"$ac_compile\\\"\") >&5\n+  (eval $ac_compile) 2>conftest.er1\n+  ac_status=$?\n+  grep -v '^ *+' conftest.er1 >conftest.err\n+  rm -f conftest.er1\n+  cat conftest.err >&5\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); } &&\n+\t { ac_try='test -z \"$ac_c_werror_flag\"\n+\t\t\t || test ! -s conftest.err'\n+  { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); }; } &&\n+\t { ac_try='test -s conftest.$ac_objext'\n+  { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); }; }; then\n+  ac_cv_have_decl_asprintf=yes\n+else\n+  echo \"$as_me: failed program was:\" >&5\n+sed 's/^/| /' conftest.$ac_ext >&5\n+\n+ac_cv_have_decl_asprintf=no\n+fi\n+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext\n+fi\n+echo \"$as_me:$LINENO: result: $ac_cv_have_decl_asprintf\" >&5\n+echo \"${ECHO_T}$ac_cv_have_decl_asprintf\" >&6\n+if test $ac_cv_have_decl_asprintf = yes; then\n+\n+cat >>confdefs.h <<_ACEOF\n+#define HAVE_DECL_ASPRINTF 1\n+_ACEOF\n+\n+\n+else\n+  cat >>confdefs.h <<_ACEOF\n+#define HAVE_DECL_ASPRINTF 0\n+_ACEOF\n+\n+\n fi\n echo \"$as_me:$LINENO: checking whether basename is declared\" >&5\n echo $ECHO_N \"checking whether basename is declared... $ECHO_C\" >&6\n@@ -6406,6 +6476,76 @@ else\n _ACEOF\n \n \n+fi\n+echo \"$as_me:$LINENO: checking whether vasprintf is declared\" >&5\n+echo $ECHO_N \"checking whether vasprintf is declared... $ECHO_C\" >&6\n+if test \"${ac_cv_have_decl_vasprintf+set}\" = set; then\n+  echo $ECHO_N \"(cached) $ECHO_C\" >&6\n+else\n+  cat >conftest.$ac_ext <<_ACEOF\n+/* confdefs.h.  */\n+_ACEOF\n+cat confdefs.h >>conftest.$ac_ext\n+cat >>conftest.$ac_ext <<_ACEOF\n+/* end confdefs.h.  */\n+$ac_includes_default\n+int\n+main ()\n+{\n+#ifndef vasprintf\n+  char *p = (char *) vasprintf;\n+#endif\n+\n+  ;\n+  return 0;\n+}\n+_ACEOF\n+rm -f conftest.$ac_objext\n+if { (eval echo \"$as_me:$LINENO: \\\"$ac_compile\\\"\") >&5\n+  (eval $ac_compile) 2>conftest.er1\n+  ac_status=$?\n+  grep -v '^ *+' conftest.er1 >conftest.err\n+  rm -f conftest.er1\n+  cat conftest.err >&5\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); } &&\n+\t { ac_try='test -z \"$ac_c_werror_flag\"\n+\t\t\t || test ! -s conftest.err'\n+  { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); }; } &&\n+\t { ac_try='test -s conftest.$ac_objext'\n+  { (eval echo \"$as_me:$LINENO: \\\"$ac_try\\\"\") >&5\n+  (eval $ac_try) 2>&5\n+  ac_status=$?\n+  echo \"$as_me:$LINENO: \\$? = $ac_status\" >&5\n+  (exit $ac_status); }; }; then\n+  ac_cv_have_decl_vasprintf=yes\n+else\n+  echo \"$as_me: failed program was:\" >&5\n+sed 's/^/| /' conftest.$ac_ext >&5\n+\n+ac_cv_have_decl_vasprintf=no\n+fi\n+rm -f conftest.err conftest.$ac_objext conftest.$ac_ext\n+fi\n+echo \"$as_me:$LINENO: result: $ac_cv_have_decl_vasprintf\" >&5\n+echo \"${ECHO_T}$ac_cv_have_decl_vasprintf\" >&6\n+if test $ac_cv_have_decl_vasprintf = yes; then\n+\n+cat >>confdefs.h <<_ACEOF\n+#define HAVE_DECL_VASPRINTF 1\n+_ACEOF\n+\n+\n+else\n+  cat >>confdefs.h <<_ACEOF\n+#define HAVE_DECL_VASPRINTF 0\n+_ACEOF\n+\n+\n fi\n \n "}, {"sha": "fe52964aae990ef763ca2e032cc0a2461ed4f4d6", "filename": "libcpp/configure.ac", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3f829c1a6d54e6d2e26dbd09fe8a66e4b9185a9/libcpp%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3f829c1a6d54e6d2e26dbd09fe8a66e4b9185a9/libcpp%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fconfigure.ac?ref=c3f829c1a6d54e6d2e26dbd09fe8a66e4b9185a9", "patch": "@@ -50,7 +50,8 @@ define(libcpp_UNLOCKED_FUNCS, clearerr_unlocked feof_unlocked dnl\n   fread_unlocked fwrite_unlocked getchar_unlocked getc_unlocked dnl\n   putchar_unlocked putc_unlocked)\n AC_CHECK_FUNCS(libcpp_UNLOCKED_FUNCS)\n-AC_CHECK_DECLS(m4_split(m4_normalize(abort basename errno getopt libcpp_UNLOCKED_FUNCS)))\n+AC_CHECK_DECLS(m4_split(m4_normalize(abort asprintf basename errno getopt \\\n+  libcpp_UNLOCKED_FUNCS vasprintf)))\n \n # Checks for library functions.\n AC_FUNC_ALLOCA"}, {"sha": "a768ea1440828fd929c92236926105a15136a296", "filename": "libcpp/directives.c", "status": "modified", "additions": 35, "deletions": 34, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3f829c1a6d54e6d2e26dbd09fe8a66e4b9185a9/libcpp%2Fdirectives.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3f829c1a6d54e6d2e26dbd09fe8a66e4b9185a9/libcpp%2Fdirectives.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fdirectives.c?ref=c3f829c1a6d54e6d2e26dbd09fe8a66e4b9185a9", "patch": "@@ -588,7 +588,7 @@ glue_header_name (cpp_reader *pfile)\n \n   /* To avoid lexed tokens overwriting our glued name, we can only\n      allocate from the string pool once we've lexed everything.  */\n-  buffer = xmalloc (capacity);\n+  buffer = XNEWVEC (char, capacity);\n   for (;;)\n     {\n       token = get_token_no_padding (pfile);\n@@ -605,7 +605,7 @@ glue_header_name (cpp_reader *pfile)\n       if (total_len + len > capacity)\n \t{\n \t  capacity = (capacity + len) * 2;\n-\t  buffer = xrealloc (buffer, capacity);\n+\t  buffer = XRESIZEVEC (char, buffer, capacity);\n \t}\n \n       if (token->flags & PREV_WHITE)\n@@ -633,7 +633,7 @@ parse_include (cpp_reader *pfile, int *pangle_brackets)\n   header = get_token_no_padding (pfile);\n   if (header->type == CPP_STRING || header->type == CPP_HEADER_NAME)\n     {\n-      fname = xmalloc (header->val.str.len - 1);\n+      fname = XNEWVEC (char, header->val.str.len - 1);\n       memcpy (fname, header->val.str.text + 1, header->val.str.len - 2);\n       fname[header->val.str.len - 2] = '\\0';\n       *pangle_brackets = header->type == CPP_HEADER_NAME;\n@@ -985,27 +985,27 @@ insert_pragma_entry (cpp_reader *pfile, struct pragma_entry **chain,\n \t\t     const cpp_hashnode *pragma, pragma_cb handler,\n \t\t     bool allow_expansion, bool internal)\n {\n-  struct pragma_entry *new;\n+  struct pragma_entry *new_entry;\n \n-  new = (struct pragma_entry *)\n+  new_entry = (struct pragma_entry *)\n     _cpp_aligned_alloc (pfile, sizeof (struct pragma_entry));\n-  new->pragma = pragma;\n+  new_entry->pragma = pragma;\n   if (handler)\n     {\n-      new->is_nspace = 0;\n-      new->u.handler = handler;\n+      new_entry->is_nspace = 0;\n+      new_entry->u.handler = handler;\n     }\n   else\n     {\n-      new->is_nspace = 1;\n-      new->u.space = NULL;\n+      new_entry->is_nspace = 1;\n+      new_entry->u.space = NULL;\n     }\n \n-  new->allow_expansion = allow_expansion;\n-  new->is_internal = internal;\n-  new->next = *chain;\n-  *chain = new;\n-  return new;\n+  new_entry->allow_expansion = allow_expansion;\n+  new_entry->is_internal = internal;\n+  new_entry->next = *chain;\n+  *chain = new_entry;\n+  return new_entry;\n }\n \n /* Register a pragma NAME in namespace SPACE.  If SPACE is null, it\n@@ -1110,9 +1110,9 @@ save_registered_pragmas (struct pragma_entry *pe, char **sd)\n     {\n       if (pe->is_nspace)\n \tsd = save_registered_pragmas (pe->u.space, sd);\n-      *sd++ = xmemdup (HT_STR (&pe->pragma->ident),\n-\t\t       HT_LEN (&pe->pragma->ident),\n-\t\t       HT_LEN (&pe->pragma->ident) + 1);\n+      *sd++ = (char *) xmemdup (HT_STR (&pe->pragma->ident),\n+                                HT_LEN (&pe->pragma->ident),\n+                                HT_LEN (&pe->pragma->ident) + 1);\n     }\n   return sd;\n }\n@@ -1383,7 +1383,7 @@ destringize_and_run (cpp_reader *pfile, const cpp_string *in)\n   const unsigned char *src, *limit;\n   char *dest, *result;\n \n-  dest = result = alloca (in->len - 1);\n+  dest = result = (char *) alloca (in->len - 1);\n   src = in->text + 1 + (in->text[0] == 'L');\n   limit = in->text + in->len - 1;\n   while (src < limit)\n@@ -1760,7 +1760,7 @@ parse_assertion (cpp_reader *pfile, struct answer **answerp, int type)\n   else if (parse_answer (pfile, answerp, type) == 0)\n     {\n       unsigned int len = NODE_LEN (predicate->val.node);\n-      unsigned char *sym = alloca (len + 1);\n+      unsigned char *sym = (unsigned char *) alloca (len + 1);\n \n       /* Prefix '#' to get it out of macro namespace.  */\n       sym[0] = '#';\n@@ -1855,7 +1855,8 @@ do_assert (cpp_reader *pfile)\n       if (pfile->hash_table->alloc_subobject)\n \t{\n \t  struct answer *temp_answer = new_answer;\n-\t  new_answer = pfile->hash_table->alloc_subobject (answer_size);\n+\t  new_answer = (struct answer *) pfile->hash_table->alloc_subobject\n+            (answer_size);\n \t  memcpy (new_answer, temp_answer, answer_size);\n \t}\n       else\n@@ -1917,7 +1918,7 @@ cpp_define (cpp_reader *pfile, const char *str)\n      tack \" 1\" on the end.  */\n \n   count = strlen (str);\n-  buf = alloca (count + 3);\n+  buf = (char *) alloca (count + 3);\n   memcpy (buf, str, count);\n \n   p = strchr (str, '=');\n@@ -1938,7 +1939,7 @@ void\n _cpp_define_builtin (cpp_reader *pfile, const char *str)\n {\n   size_t len = strlen (str);\n-  char *buf = alloca (len + 1);\n+  char *buf = (char *) alloca (len + 1);\n   memcpy (buf, str, len);\n   buf[len] = '\\n';\n   run_directive (pfile, T_DEFINE, buf, len);\n@@ -1949,7 +1950,7 @@ void\n cpp_undef (cpp_reader *pfile, const char *macro)\n {\n   size_t len = strlen (macro);\n-  char *buf = alloca (len + 1);\n+  char *buf = (char *) alloca (len + 1);\n   memcpy (buf, macro, len);\n   buf[len] = '\\n';\n   run_directive (pfile, T_UNDEF, buf, len);\n@@ -1978,7 +1979,7 @@ handle_assertion (cpp_reader *pfile, const char *str, int type)\n \n   /* Copy the entire option so we can modify it.  Change the first\n      \"=\" in the string to a '(', and tack a ')' on the end.  */\n-  char *buf = alloca (count + 2);\n+  char *buf = (char *) alloca (count + 2);\n \n   memcpy (buf, str, count);\n   if (p)\n@@ -2036,20 +2037,20 @@ cpp_buffer *\n cpp_push_buffer (cpp_reader *pfile, const uchar *buffer, size_t len,\n \t\t int from_stage3)\n {\n-  cpp_buffer *new = XOBNEW (&pfile->buffer_ob, cpp_buffer);\n+  cpp_buffer *new_buffer = XOBNEW (&pfile->buffer_ob, cpp_buffer);\n \n   /* Clears, amongst other things, if_stack and mi_cmacro.  */\n-  memset (new, 0, sizeof (cpp_buffer));\n+  memset (new_buffer, 0, sizeof (cpp_buffer));\n \n-  new->next_line = new->buf = buffer;\n-  new->rlimit = buffer + len;\n-  new->from_stage3 = from_stage3;\n-  new->prev = pfile->buffer;\n-  new->need_line = true;\n+  new_buffer->next_line = new_buffer->buf = buffer;\n+  new_buffer->rlimit = buffer + len;\n+  new_buffer->from_stage3 = from_stage3;\n+  new_buffer->prev = pfile->buffer;\n+  new_buffer->need_line = true;\n \n-  pfile->buffer = new;\n+  pfile->buffer = new_buffer;\n \n-  return new;\n+  return new_buffer;\n }\n \n /* Pops a single buffer, with a file change call-back if appropriate."}, {"sha": "73356a966a077fd64a72889abf7af2bd3932a06f", "filename": "libcpp/expr.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3f829c1a6d54e6d2e26dbd09fe8a66e4b9185a9/libcpp%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3f829c1a6d54e6d2e26dbd09fe8a66e4b9185a9/libcpp%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fexpr.c?ref=c3f829c1a6d54e6d2e26dbd09fe8a66e4b9185a9", "patch": "@@ -65,8 +65,8 @@ static unsigned int interpret_int_suffix (const uchar *, size_t);\n static void check_promotion (cpp_reader *, const struct op *);\n \n /* Token type abuse to create unary plus and minus operators.  */\n-#define CPP_UPLUS (CPP_LAST_CPP_OP + 1)\n-#define CPP_UMINUS (CPP_LAST_CPP_OP + 2)\n+#define CPP_UPLUS ((enum cpp_ttype) (CPP_LAST_CPP_OP + 1))\n+#define CPP_UMINUS ((enum cpp_ttype) (CPP_LAST_CPP_OP + 2))\n \n /* With -O2, gcc appears to produce nice code, moving the error\n    message load and subsequent jump completely out of the main path.  */\n@@ -627,7 +627,7 @@ extra semantics need to be handled with operator-specific code.  */\n \n /* Operator to priority map.  Must be in the same order as the first\n    N entries of enum cpp_ttype.  */\n-static const struct operator\n+static const struct cpp_operator\n {\n   uchar prio;\n   uchar flags;\n@@ -975,7 +975,7 @@ _cpp_expand_op_stack (cpp_reader *pfile)\n   size_t old_size = (size_t) (pfile->op_limit - pfile->op_stack);\n   size_t new_size = old_size * 2 + 20;\n \n-  pfile->op_stack = xrealloc (pfile->op_stack, new_size * sizeof (struct op));\n+  pfile->op_stack = XRESIZEVEC (struct op, pfile->op_stack, new_size);\n   pfile->op_limit = pfile->op_stack + new_size;\n \n   return pfile->op_stack + old_size;"}, {"sha": "6cab34f8b83bf813608aefa759fe5af47065ad48", "filename": "libcpp/files.c", "status": "modified", "additions": 31, "deletions": 29, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3f829c1a6d54e6d2e26dbd09fe8a66e4b9185a9/libcpp%2Ffiles.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3f829c1a6d54e6d2e26dbd09fe8a66e4b9185a9/libcpp%2Ffiles.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Ffiles.c?ref=c3f829c1a6d54e6d2e26dbd09fe8a66e4b9185a9", "patch": "@@ -255,7 +255,7 @@ pch_open_file (cpp_reader *pfile, _cpp_file *file, bool *invalid_pch)\n \n   flen = strlen (path);\n   len = flen + sizeof (extension);\n-  pchname = xmalloc (len);\n+  pchname = XNEWVEC (char, len);\n   memcpy (pchname, path, flen);\n   memcpy (pchname + flen, extension, sizeof (extension));\n \n@@ -279,7 +279,7 @@ pch_open_file (cpp_reader *pfile, _cpp_file *file, bool *invalid_pch)\n \t      if (dlen + plen > len)\n \t\t{\n \t\t  len += dlen + 64;\n-\t\t  pchname = xrealloc (pchname, len);\n+\t\t  pchname = XRESIZEVEC (char, pchname, len);\n \t\t}\n \t      memcpy (pchname + plen, d->d_name, dlen);\n \t      valid = validate_pch (pfile, file, pchname);\n@@ -549,7 +549,7 @@ read_file_guts (cpp_reader *pfile, _cpp_file *file)\n        the majority of C source files.  */\n     size = 8 * 1024;\n \n-  buf = xmalloc (size + 1);\n+  buf = XNEWVEC (uchar, size + 1);\n   total = 0;\n   while ((count = read (file->fd, buf + total, size - total)) > 0)\n     {\n@@ -560,7 +560,7 @@ read_file_guts (cpp_reader *pfile, _cpp_file *file)\n \t  if (regular)\n \t    break;\n \t  size *= 2;\n-\t  buf = xrealloc (buf, size + 1);\n+\t  buf = XRESIZEVEC (uchar, buf, size + 1);\n \t}\n     }\n \n@@ -815,7 +815,7 @@ dir_name_of_file (_cpp_file *file)\n   if (!file->dir_name)\n     {\n       size_t len = lbasename (file->path) - file->path;\n-      char *dir_name = xmalloc (len + 1);\n+      char *dir_name = XNEWVEC (char, len + 1);\n \n       memcpy (dir_name, file->path, len);\n       dir_name[len] = '\\0';\n@@ -896,7 +896,7 @@ make_cpp_file (cpp_reader *pfile, cpp_dir *dir, const char *fname)\n {\n   _cpp_file *file;\n \n-  file = xcalloc (1, sizeof (_cpp_file));\n+  file = XCNEW (_cpp_file);\n   file->main_file = !pfile->buffer;\n   file->fd = -1;\n   file->dir = dir;\n@@ -938,7 +938,7 @@ make_cpp_dir (cpp_reader *pfile, const char *dir_name, int sysp)\n     if (entry->start_dir == NULL)\n       return entry->u.dir;\n \n-  dir = xcalloc (1, sizeof (cpp_dir));\n+  dir = XCNEW (cpp_dir);\n   dir->next = pfile->quote_include;\n   dir->name = (char *) dir_name;\n   dir->len = strlen (dir_name);\n@@ -961,8 +961,8 @@ allocate_file_hash_entries (cpp_reader *pfile)\n {\n   pfile->file_hash_entries_used = 0;\n   pfile->file_hash_entries_allocated = 127;\n-  pfile->file_hash_entries = xmalloc\n-    (pfile->file_hash_entries_allocated * sizeof (struct file_hash_entry));\n+  pfile->file_hash_entries = XNEWVEC (struct file_hash_entry,\n+                                      pfile->file_hash_entries_allocated);\n }\n \n /* Return a new file hash entry.  */\n@@ -983,8 +983,8 @@ cpp_included (cpp_reader *pfile, const char *fname)\n {\n   struct file_hash_entry *entry;\n \n-  entry = htab_find_with_hash (pfile->file_hash, fname,\n-\t\t\t       htab_hash_string (fname));\n+  entry = (struct file_hash_entry *)\n+     htab_find_with_hash (pfile->file_hash, fname, htab_hash_string (fname));\n \n   while (entry && (entry->start_dir == NULL || entry->u.file->err_no))\n     entry = entry->next;\n@@ -1204,7 +1204,7 @@ append_file_to_dir (const char *fname, cpp_dir *dir)\n \n   dlen = dir->len;\n   flen = strlen (fname);\n-  path = xmalloc (dlen + 1 + flen + 1);\n+  path = XNEWVEC (char, dlen + 1 + flen + 1);\n   memcpy (path, dir->name, dlen);\n   if (dlen && path[dlen - 1] != '/')\n     path[dlen++] = '/';\n@@ -1222,7 +1222,7 @@ read_filename_string (int ch, FILE *f)\n   int len;\n \n   len = 20;\n-  set = alloc = xmalloc (len + 1);\n+  set = alloc = XNEWVEC (char, len + 1);\n   if (! is_space (ch))\n     {\n       *set++ = ch;\n@@ -1231,7 +1231,7 @@ read_filename_string (int ch, FILE *f)\n \t  if (set - alloc == len)\n \t    {\n \t      len *= 2;\n-\t      alloc = xrealloc (alloc, len + 1);\n+\t      alloc = XRESIZEVEC (char, alloc, len + 1);\n \t      set = alloc + len / 2;\n \t    }\n \t  *set++ = ch;\n@@ -1252,14 +1252,14 @@ read_name_map (cpp_dir *dir)\n   size_t len, count = 0, room = 9;\n \n   len = dir->len;\n-  name = alloca (len + sizeof (FILE_NAME_MAP_FILE) + 1);\n+  name = (char *) alloca (len + sizeof (FILE_NAME_MAP_FILE) + 1);\n   memcpy (name, dir->name, len);\n   if (len && name[len - 1] != '/')\n     name[len++] = '/';\n   strcpy (name + len, FILE_NAME_MAP_FILE);\n   f = fopen (name, \"r\");\n \n-  dir->name_map = xmalloc (room * sizeof (char *));\n+  dir->name_map = XNEWVEC (const char *, room);\n \n   /* Silently return NULL if we cannot open.  */\n   if (f)\n@@ -1276,7 +1276,7 @@ read_name_map (cpp_dir *dir)\n \t  if (count + 2 > room)\n \t    {\n \t      room += 8;\n-\t      dir->name_map = xrealloc (dir->name_map, room * sizeof (char *));\n+\t      dir->name_map = XRESIZEVEC (const char *, dir->name_map, room);\n \t    }\n \n \t  dir->name_map[count] = read_filename_string (ch, f);\n@@ -1333,7 +1333,7 @@ remap_filename (cpp_reader *pfile, _cpp_file *file)\n \treturn NULL;\n \n       len = dir->len + (p - fname + 1);\n-      new_dir = xmalloc (len + 1);\n+      new_dir = XNEWVEC (char, len + 1);\n       memcpy (new_dir, dir->name, dir->len);\n       memcpy (new_dir + dir->len, fname, p - fname + 1);\n       new_dir[len] = '\\0';\n@@ -1426,6 +1426,16 @@ cpp_get_prev (cpp_buffer *b)\n    that's OK.  The code does rely on having entries with the same size\n    next to each other.  */\n \n+struct pchf_entry {\n+  /* The size of this file.  This is used to save running a MD5 checksum\n+     if the sizes don't match.  */\n+  off_t size;\n+  /* The MD5 checksum of this file.  */\n+  unsigned char sum[16];\n+  /* Is this file to be included only once?  */\n+  bool once_only;\n+};\n+\n struct pchf_data {\n   /* Number of pchf_entry structures.  */\n   size_t count;\n@@ -1435,15 +1445,7 @@ struct pchf_data {\n      the structure if we're processing a regular #include.  */\n   bool have_once_only;\n \n-  struct pchf_entry {\n-    /* The size of this file.  This is used to save running a MD5 checksum\n-       if the sizes don't match.  */\n-    off_t size;\n-    /* The MD5 checksum of this file.  */\n-    unsigned char sum[16];\n-    /* Is this file to be included only once?  */\n-    bool once_only;\n-  } entries[1];\n+  struct pchf_entry entries[1];\n };\n \n static struct pchf_data *pchf;\n@@ -1471,7 +1473,7 @@ _cpp_save_file_entries (cpp_reader *pfile, FILE *fp)\n \n   result_size = (sizeof (struct pchf_data)\n \t\t + sizeof (struct pchf_entry) * (count - 1));\n-  result = xcalloc (result_size, 1);\n+  result = XCNEWVAR (struct pchf_data, result_size);\n \n   result->count = 0;\n   result->have_once_only = false;\n@@ -1534,7 +1536,7 @@ _cpp_read_file_entries (cpp_reader *pfile ATTRIBUTE_UNUSED, FILE *f)\n        != 1)\n     return false;\n \n-  pchf = xmalloc (sizeof (struct pchf_data)\n+  pchf = XNEWVAR (struct pchf_data, sizeof (struct pchf_data)\n \t\t  + sizeof (struct pchf_entry) * (d.count - 1));\n   memcpy (pchf, &d, sizeof (struct pchf_data) - sizeof (struct pchf_entry));\n   if (fread (pchf->entries, sizeof (struct pchf_entry), d.count, f)"}, {"sha": "8ab3ce9c9774bfc34983d4992504e10675e30b29", "filename": "libcpp/identifiers.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3f829c1a6d54e6d2e26dbd09fe8a66e4b9185a9/libcpp%2Fidentifiers.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3f829c1a6d54e6d2e26dbd09fe8a66e4b9185a9/libcpp%2Fidentifiers.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fidentifiers.c?ref=c3f829c1a6d54e6d2e26dbd09fe8a66e4b9185a9", "patch": "@@ -37,7 +37,7 @@ alloc_node (hash_table *table)\n {\n   cpp_hashnode *node;\n \n-  node = obstack_alloc (&table->pfile->hash_ob, sizeof (cpp_hashnode));\n+  node = XOBNEW (&table->pfile->hash_ob, cpp_hashnode);\n   memset (node, 0, sizeof (cpp_hashnode));\n   return node;\n }"}, {"sha": "3ec4c4664361611952ccc7b8a801ce5af50fbb91", "filename": "libcpp/include/cpplib.h", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3f829c1a6d54e6d2e26dbd09fe8a66e4b9185a9/libcpp%2Finclude%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3f829c1a6d54e6d2e26dbd09fe8a66e4b9185a9/libcpp%2Finclude%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Finclude%2Fcpplib.h?ref=c3f829c1a6d54e6d2e26dbd09fe8a66e4b9185a9", "patch": "@@ -569,6 +569,19 @@ enum {\n /* The common part of an identifier node shared amongst all 3 C front\n    ends.  Also used to store CPP identifiers, which are a superset of\n    identifiers in the grammatical sense.  */\n+\n+union _cpp_hashnode_value GTY(())\n+{\n+  /* If a macro.  */\n+  cpp_macro * GTY((tag (\"NTV_MACRO\"))) macro;\n+  /* Answers to an assertion.  */\n+  struct answer * GTY ((tag (\"NTV_ANSWER\"))) answers;\n+  /* Code for a builtin macro.  */\n+  enum builtin_type GTY ((tag (\"NTV_BUILTIN\"))) builtin;\n+  /* Macro argument index.  */\n+  unsigned short GTY ((tag (\"NTV_ARGUMENT\"))) arg_index;\n+};\n+\n struct cpp_hashnode GTY(())\n {\n   struct ht_identifier ident;\n@@ -580,17 +593,7 @@ struct cpp_hashnode GTY(())\n   ENUM_BITFIELD(node_type) type : 8;\t/* CPP node type.  */\n   unsigned char flags;\t\t\t/* CPP flags.  */\n \n-  union _cpp_hashnode_value\n-  {\n-    /* If a macro.  */\n-    cpp_macro * GTY((tag (\"NTV_MACRO\"))) macro;\n-    /* Answers to an assertion.  */\n-    struct answer * GTY ((tag (\"NTV_ANSWER\"))) answers;\n-    /* Code for a builtin macro.  */\n-    enum builtin_type GTY ((tag (\"NTV_BUILTIN\"))) builtin;\n-    /* Macro argument index.  */\n-    unsigned short GTY ((tag (\"NTV_ARGUMENT\"))) arg_index;\n-  } GTY ((desc (\"CPP_HASHNODE_VALUE_IDX (%1)\"))) value;\n+  union _cpp_hashnode_value GTY ((desc (\"CPP_HASHNODE_VALUE_IDX (%1)\"))) value;\n };\n \n /* Call this first to get a handle to pass to other functions."}, {"sha": "56acd7ac24cbaa7eccd9b3691833073d3c654dbb", "filename": "libcpp/init.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3f829c1a6d54e6d2e26dbd09fe8a66e4b9185a9/libcpp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3f829c1a6d54e6d2e26dbd09fe8a66e4b9185a9/libcpp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Finit.c?ref=c3f829c1a6d54e6d2e26dbd09fe8a66e4b9185a9", "patch": "@@ -137,7 +137,7 @@ cpp_create_reader (enum c_lang lang, hash_table *table,\n   /* Initialize this instance of the library if it hasn't been already.  */\n   init_library ();\n \n-  pfile = xcalloc (1, sizeof (cpp_reader));\n+  pfile = XCNEW (cpp_reader);\n \n   cpp_set_lang (pfile, lang);\n   CPP_OPTION (pfile, warn_multichar) = 1;\n@@ -357,7 +357,7 @@ cpp_init_builtins (cpp_reader *pfile, int hosted)\n       cpp_hashnode *hp = cpp_lookup (pfile, b->name, b->len);\n       hp->type = NT_MACRO;\n       hp->flags |= NODE_BUILTIN | NODE_WARN;\n-      hp->value.builtin = b->value;\n+      hp->value.builtin = (enum builtin_type) b->value;\n     }\n \n   if (CPP_OPTION (pfile, cplusplus))\n@@ -545,7 +545,7 @@ read_original_directory (cpp_reader *pfile)\n \n   if (pfile->cb.dir_change)\n     {\n-      char *debugdir = alloca (token->val.str.len - 3);\n+      char *debugdir = (char *) alloca (token->val.str.len - 3);\n \n       memcpy (debugdir, (const char *) token->val.str.text + 1,\n \t      token->val.str.len - 4);"}, {"sha": "b38047e087974965ebbd510a0c4a886401cdd0a3", "filename": "libcpp/lex.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3f829c1a6d54e6d2e26dbd09fe8a66e4b9185a9/libcpp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3f829c1a6d54e6d2e26dbd09fe8a66e4b9185a9/libcpp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Flex.c?ref=c3f829c1a6d54e6d2e26dbd09fe8a66e4b9185a9", "patch": "@@ -85,8 +85,8 @@ add_line_note (cpp_buffer *buffer, const uchar *pos, unsigned int type)\n   if (buffer->notes_used == buffer->notes_cap)\n     {\n       buffer->notes_cap = buffer->notes_cap * 2 + 200;\n-      buffer->notes = xrealloc (buffer->notes,\n-\t\t\t\tbuffer->notes_cap * sizeof (_cpp_line_note));\n+      buffer->notes = XRESIZEVEC (_cpp_line_note, buffer->notes,\n+                                  buffer->notes_cap);\n     }\n \n   buffer->notes[buffer->notes_used].pos = pos;\n@@ -439,7 +439,7 @@ warn_about_normalization (cpp_reader *pfile,\n     {\n       /* Make sure that the token is printed using UCNs, even\n \t if we'd otherwise happily print UTF-8.  */\n-      unsigned char *buf = xmalloc (cpp_token_len (token));\n+      unsigned char *buf = XNEWVEC (unsigned char, cpp_token_len (token));\n       size_t sz;\n \n       sz = cpp_spell_token (pfile, token, buf, false) - buf;\n@@ -970,7 +970,7 @@ _cpp_lex_direct (cpp_reader *pfile)\n       if (result->val.node->flags & NODE_OPERATOR)\n \t{\n \t  result->flags |= NAMED_OP;\n-\t  result->type = result->val.node->directive_index;\n+\t  result->type = (enum cpp_ttype) result->val.node->directive_index;\n \t}\n       break;\n \n@@ -1541,7 +1541,7 @@ new_buff (size_t len)\n     len = MIN_BUFF_SIZE;\n   len = CPP_ALIGN (len);\n \n-  base = xmalloc (len + sizeof (_cpp_buff));\n+  base = XNEWVEC (unsigned char, len + sizeof (_cpp_buff));\n   result = (_cpp_buff *) (base + len);\n   result->base = base;\n   result->cur = base;"}, {"sha": "59a80ac92f8762409f0b906cfc70122e94aa0939", "filename": "libcpp/line-map.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3f829c1a6d54e6d2e26dbd09fe8a66e4b9185a9/libcpp%2Fline-map.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3f829c1a6d54e6d2e26dbd09fe8a66e4b9185a9/libcpp%2Fline-map.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fline-map.c?ref=c3f829c1a6d54e6d2e26dbd09fe8a66e4b9185a9", "patch": "@@ -97,7 +97,7 @@ linemap_add (struct line_maps *set, enum lc_reason reason,\n   if (set->used == set->allocated)\n     {\n       set->allocated = 2 * set->allocated + 256;\n-      set->maps = xrealloc (set->maps, set->allocated * sizeof (struct line_map));\n+      set->maps = XRESIZEVEC (struct line_map, set->maps, set->allocated);\n     }\n \n   map = &set->maps[set->used];"}, {"sha": "05a87702aa6f02691b11613203b9982df2d7a1db", "filename": "libcpp/macro.c", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3f829c1a6d54e6d2e26dbd09fe8a66e4b9185a9/libcpp%2Fmacro.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3f829c1a6d54e6d2e26dbd09fe8a66e4b9185a9/libcpp%2Fmacro.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fmacro.c?ref=c3f829c1a6d54e6d2e26dbd09fe8a66e4b9185a9", "patch": "@@ -273,7 +273,7 @@ builtin_macro (cpp_reader *pfile, cpp_hashnode *node)\n \n   buf = _cpp_builtin_macro_text (pfile, node);\n   len = ustrlen (buf);\n-  nbuf = alloca (len + 1);\n+  nbuf = (char *) alloca (len + 1);\n   memcpy (nbuf, buf, len);\n   nbuf[len]='\\n';\n \n@@ -421,7 +421,7 @@ paste_tokens (cpp_reader *pfile, const cpp_token **plhs, const cpp_token *rhs)\n \n   lhs = *plhs;\n   len = cpp_token_len (lhs) + cpp_token_len (rhs) + 1;\n-  buf = alloca (len);\n+  buf = (unsigned char *) alloca (len);\n   end = cpp_spell_token (pfile, lhs, buf, false);\n \n   /* Avoid comment headers, since they are still processed in stage 3.\n@@ -1001,7 +1001,7 @@ expand_arg (cpp_reader *pfile, macro_arg *arg)\n \n   /* Loop, reading in the arguments.  */\n   capacity = 256;\n-  arg->expanded = xmalloc (capacity * sizeof (cpp_token *));\n+  arg->expanded = XNEWVEC (const cpp_token *, capacity);\n \n   push_ptoken_context (pfile, NULL, NULL, arg->first, arg->count + 1);\n   for (;;)\n@@ -1011,8 +1011,8 @@ expand_arg (cpp_reader *pfile, macro_arg *arg)\n       if (arg->expanded_count + 1 >= capacity)\n \t{\n \t  capacity *= 2;\n-\t  arg->expanded = xrealloc (arg->expanded,\n-\t\t\t\t    capacity * sizeof (cpp_token *));\n+\t  arg->expanded = XRESIZEVEC (const cpp_token *, arg->expanded,\n+                                      capacity);\n \t}\n \n       token = cpp_get_token (pfile);\n@@ -1272,7 +1272,8 @@ _cpp_save_parameter (cpp_reader *pfile, cpp_macro *macro, cpp_hashnode *node)\n   len = macro->paramc * sizeof (union _cpp_hashnode_value);\n   if (len > pfile->macro_buffer_len)\n     {\n-      pfile->macro_buffer = xrealloc (pfile->macro_buffer, len);\n+      pfile->macro_buffer = XRESIZEVEC (unsigned char, pfile->macro_buffer,\n+                                        len);\n       pfile->macro_buffer_len = len;\n     }\n   ((union _cpp_hashnode_value *) pfile->macro_buffer)[macro->paramc - 1]\n@@ -1419,8 +1420,9 @@ create_iso_definition (cpp_reader *pfile, cpp_macro *macro)\n       /* Success.  Commit or allocate the parameter array.  */\n       if (pfile->hash_table->alloc_subobject)\n \t{\n-\t  cpp_hashnode **params = pfile->hash_table->alloc_subobject\n-\t    (sizeof (cpp_hashnode *) * macro->paramc);\n+\t  cpp_hashnode **params =\n+            (cpp_hashnode **) pfile->hash_table->alloc_subobject\n+            (sizeof (cpp_hashnode *) * macro->paramc);\n \t  memcpy (params, macro->params,\n \t\t  sizeof (cpp_hashnode *) * macro->paramc);\n \t  macro->params = params;\n@@ -1532,8 +1534,9 @@ create_iso_definition (cpp_reader *pfile, cpp_macro *macro)\n   /* Commit or allocate the memory.  */\n   if (pfile->hash_table->alloc_subobject)\n     {\n-      cpp_token *tokns = pfile->hash_table->alloc_subobject (sizeof (cpp_token)\n-\t\t\t\t\t\t\t     * macro->count);\n+      cpp_token *tokns =\n+        (cpp_token *) pfile->hash_table->alloc_subobject (sizeof (cpp_token)\n+                                                          * macro->count);\n       memcpy (tokns, macro->exp.tokens, sizeof (cpp_token) * macro->count);\n       macro->exp.tokens = tokns;\n     }\n@@ -1552,7 +1555,8 @@ _cpp_create_definition (cpp_reader *pfile, cpp_hashnode *node)\n   bool ok;\n \n   if (pfile->hash_table->alloc_subobject)\n-    macro = pfile->hash_table->alloc_subobject (sizeof (cpp_macro));\n+    macro = (cpp_macro *) pfile->hash_table->alloc_subobject\n+      (sizeof (cpp_macro));\n   else\n     macro = (cpp_macro *) _cpp_aligned_alloc (pfile, sizeof (cpp_macro));\n   macro->line = pfile->directive_line;\n@@ -1722,7 +1726,8 @@ cpp_macro_definition (cpp_reader *pfile, const cpp_hashnode *node)\n \n   if (len > pfile->macro_buffer_len)\n     {\n-      pfile->macro_buffer = xrealloc (pfile->macro_buffer, len);\n+      pfile->macro_buffer = XRESIZEVEC (unsigned char,\n+                                        pfile->macro_buffer, len);\n       pfile->macro_buffer_len = len;\n     }\n "}, {"sha": "7581c97551514a5670127e46b2a7b9b97dea4f13", "filename": "libcpp/makedepend.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3f829c1a6d54e6d2e26dbd09fe8a66e4b9185a9/libcpp%2Fmakedepend.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3f829c1a6d54e6d2e26dbd09fe8a66e4b9185a9/libcpp%2Fmakedepend.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fmakedepend.c?ref=c3f829c1a6d54e6d2e26dbd09fe8a66e4b9185a9", "patch": "@@ -47,7 +47,7 @@ static cpp_dir *cmd_line_searchpath;\n static void\n add_clm (const char *macro, bool is_undef)\n {\n-  struct cmd_line_macro *clm = xmalloc (sizeof (struct cmd_line_macro));\n+  struct cmd_line_macro *clm = XNEW (struct cmd_line_macro);\n   clm->next = cmd_line_macros;\n   clm->is_undef = is_undef;\n   clm->macro = macro;\n@@ -57,7 +57,7 @@ add_clm (const char *macro, bool is_undef)\n static void\n add_dir (char *name, bool sysp)\n {\n-  cpp_dir *dir = xmalloc (sizeof (cpp_dir));\n+  cpp_dir *dir = XNEW (cpp_dir);\n   dir->next = cmd_line_searchpath;\n   dir->name = name;\n   dir->sysp = sysp;"}, {"sha": "9042316a1ead69c9ba4eb4eeab771caa01ac4190", "filename": "libcpp/mkdeps.c", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3f829c1a6d54e6d2e26dbd09fe8a66e4b9185a9/libcpp%2Fmkdeps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3f829c1a6d54e6d2e26dbd09fe8a66e4b9185a9/libcpp%2Fmkdeps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fmkdeps.c?ref=c3f829c1a6d54e6d2e26dbd09fe8a66e4b9185a9", "patch": "@@ -83,7 +83,7 @@ munge (const char *filename)\n     }\n \n   /* Now we know how big to make the buffer.  */\n-  buffer = xmalloc (len + 1);\n+  buffer = XNEWVEC (char, len + 1);\n \n   for (p = filename, dst = buffer; *p; p++, dst++)\n     {\n@@ -151,7 +151,7 @@ apply_vpath (struct deps *d, const char *t)\n struct deps *\n deps_init (void)\n {\n-  return xcalloc (sizeof (struct deps), 1);\n+  return XCNEW (struct deps);\n }\n \n void\n@@ -192,8 +192,7 @@ deps_add_target (struct deps *d, const char *t, int quote)\n   if (d->ntargets == d->targets_size)\n     {\n       d->targets_size = d->targets_size * 2 + 4;\n-      d->targetv = xrealloc (d->targetv,\n-\t\t\t     d->targets_size * sizeof (const char *));\n+      d->targetv = XRESIZEVEC (const char *, d->targetv, d->targets_size);\n     }\n \n   t = apply_vpath (d, t);\n@@ -223,7 +222,8 @@ deps_add_default_target (struct deps *d, const char *tgt)\n # define TARGET_OBJECT_SUFFIX \".o\"\n #endif\n       const char *start = lbasename (tgt);\n-      char *o = alloca (strlen (start) + strlen (TARGET_OBJECT_SUFFIX) + 1);\n+      char *o = (char *) alloca (strlen (start)\n+                                 + strlen (TARGET_OBJECT_SUFFIX) + 1);\n       char *suffix;\n \n       strcpy (o, start);\n@@ -245,7 +245,7 @@ deps_add_dep (struct deps *d, const char *t)\n   if (d->ndeps == d->deps_size)\n     {\n       d->deps_size = d->deps_size * 2 + 8;\n-      d->depv = xrealloc (d->depv, d->deps_size * sizeof (const char *));\n+      d->depv = XRESIZEVEC (const char *, d->depv, d->deps_size);\n     }\n   d->depv[d->ndeps++] = t;\n }\n@@ -261,7 +261,7 @@ deps_add_vpath (struct deps *d, const char *vpath)\n     {\n       for (p = elem; *p && *p != ':'; p++);\n       len = p - elem;\n-      copy = xmalloc (len + 1);\n+      copy = XNEWVEC (char, len + 1);\n       memcpy (copy, elem, len);\n       copy[len] = '\\0';\n       if (*p == ':')\n@@ -270,9 +270,8 @@ deps_add_vpath (struct deps *d, const char *vpath)\n       if (d->nvpaths == d->vpaths_size)\n \t{\n \t  d->vpaths_size = d->vpaths_size * 2 + 8;\n-\t  d->vpathv = xrealloc (d->vpathv,\n-\t\t\t\td->vpaths_size * sizeof (const char *));\n-\t  d->vpathlv = xrealloc (d->vpathlv, d->vpaths_size * sizeof (size_t));\n+\t  d->vpathv = XRESIZEVEC (const char *, d->vpathv, d->vpaths_size);\n+\t  d->vpathlv = XRESIZEVEC (size_t, d->vpathlv, d->vpaths_size);\n \t}\n       d->vpathv[d->nvpaths] = copy;\n       d->vpathlv[d->nvpaths] = len;\n@@ -382,7 +381,7 @@ deps_restore (struct deps *deps, FILE *fd, const char *self)\n   unsigned int i, count;\n   size_t num_to_read;\n   size_t buf_size = 512;\n-  char *buf = xmalloc (buf_size);\n+  char *buf = XNEWVEC (char, buf_size);\n \n   /* Number of dependences.  */\n   if (fread (&count, 1, sizeof (count), fd) != sizeof (count))\n@@ -397,7 +396,7 @@ deps_restore (struct deps *deps, FILE *fd, const char *self)\n       if (buf_size < num_to_read + 1)\n \t{\n \t  buf_size = num_to_read + 1 + 127;\n-\t  buf = xrealloc (buf, buf_size);\n+\t  buf = XRESIZEVEC (char, buf, buf_size);\n \t}\n       if (fread (buf, 1, num_to_read, fd) != num_to_read)\n \treturn -1;"}, {"sha": "28cafbc9199015342987bf025429f25a6023fe0c", "filename": "libcpp/pch.c", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3f829c1a6d54e6d2e26dbd09fe8a66e4b9185a9/libcpp%2Fpch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3f829c1a6d54e6d2e26dbd09fe8a66e4b9185a9/libcpp%2Fpch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fpch.c?ref=c3f829c1a6d54e6d2e26dbd09fe8a66e4b9185a9", "patch": "@@ -137,11 +137,11 @@ save_idents (cpp_reader *pfile ATTRIBUTE_UNUSED, cpp_hashnode *hn, void *ss_p)\n \t  struct cpp_string *sp;\n \t  unsigned char *text;\n \t  \n-\t  sp = xmalloc (sizeof (struct cpp_string));\n+\t  sp = XNEW (struct cpp_string);\n \t  *slot = sp;\n \n \t  sp->len = NODE_LEN (hn);\n-\t  sp->text = text = xmalloc (NODE_LEN (hn));\n+\t  sp->text = text = XNEWVEC (unsigned char, NODE_LEN (hn));\n \t  memcpy (text, NODE_NAME (hn), NODE_LEN (hn));\n \t}\n     }\n@@ -193,7 +193,7 @@ int\n cpp_save_state (cpp_reader *r, FILE *f)\n {\n   /* Save the list of non-void identifiers for the dependency checking.  */\n-  r->savedstate = xmalloc (sizeof (struct cpp_savedstate));\n+  r->savedstate = XNEW (struct cpp_savedstate);\n   r->savedstate->definedhash = htab_create (100, cpp_string_hash, \n \t\t\t\t\t    cpp_string_eq, NULL);\n   cpp_forall_identifiers (r, save_idents, r->savedstate);\n@@ -226,7 +226,7 @@ count_defs (cpp_reader *pfile ATTRIBUTE_UNUSED, cpp_hashnode *hn, void *ss_p)\n \t\n \tnews.len = NODE_LEN (hn);\n \tnews.text = NODE_NAME (hn);\n-\tslot = htab_find (ss->definedhash, &news);\n+\tslot = (void **) htab_find (ss->definedhash, &news);\n \tif (slot == NULL)\n \t  {\n \t    ss->hashsize += NODE_LEN (hn) + 1;\n@@ -265,7 +265,7 @@ write_defs (cpp_reader *pfile ATTRIBUTE_UNUSED, cpp_hashnode *hn, void *ss_p)\n \t\n \tnews.len = NODE_LEN (hn);\n \tnews.text = NODE_NAME (hn);\n-\tslot = htab_find (ss->definedhash, &news);\n+\tslot = (void **) htab_find (ss->definedhash, &news);\n \tif (slot == NULL)\n \t  {\n \t    ss->defs[ss->n_defs] = hn;\n@@ -310,13 +310,13 @@ cpp_write_pch_deps (cpp_reader *r, FILE *f)\n   ss->n_defs = 0;\n   cpp_forall_identifiers (r, count_defs, ss);\n \n-  ss->defs = xmalloc (ss->n_defs * sizeof (cpp_hashnode *));\n+  ss->defs = XNEWVEC (cpp_hashnode *, ss->n_defs);\n   ss->n_defs = 0;\n   cpp_forall_identifiers (r, write_defs, ss);\n \n   /* Sort the list, copy it into a buffer, and write it out.  */\n   qsort (ss->defs, ss->n_defs, sizeof (cpp_hashnode *), &comp_hashnodes);\n-  definedstrs = ss->definedstrs = xmalloc (ss->hashsize);\n+  definedstrs = ss->definedstrs = XNEWVEC (unsigned char, ss->hashsize);\n   for (i = 0; i < ss->n_defs; ++i)\n     {\n       size_t len = NODE_LEN (ss->defs[i]);\n@@ -390,7 +390,7 @@ collect_ht_nodes (cpp_reader *pfile ATTRIBUTE_UNUSED, cpp_hashnode *hn,\n       if (nl->n_defs == nl->asize)\n         {\n           nl->asize *= 2;\n-          nl->defs = xrealloc (nl->defs, nl->asize * sizeof (cpp_hashnode *));\n+          nl->defs = XRESIZEVEC (cpp_hashnode *, nl->defs, nl->asize);\n         }\n \n       nl->defs[nl->n_defs] = hn;\n@@ -418,7 +418,7 @@ cpp_valid_state (cpp_reader *r, const char *name, int fd)\n {\n   struct macrodef_struct m;\n   size_t namebufsz = 256;\n-  unsigned char *namebuf = xmalloc (namebufsz);\n+  unsigned char *namebuf = XNEWVEC (unsigned char, namebufsz);\n   unsigned char *undeftab = NULL;\n   struct ht_node_list nl = { 0, 0, 0 };\n   unsigned char *first, *last;\n@@ -450,7 +450,7 @@ cpp_valid_state (cpp_reader *r, const char *name, int fd)\n \t{\n \t  free (namebuf);\n \t  namebufsz = m.definition_length + 256;\n-\t  namebuf = xmalloc (namebufsz);\n+\t  namebuf = XNEWVEC (unsigned char, namebufsz);\n \t}\n \n       if ((size_t)read (fd, namebuf, m.definition_length) \n@@ -488,14 +488,14 @@ cpp_valid_state (cpp_reader *r, const char *name, int fd)\n \n   /* Read in the list of identifiers that must not be defined.\n      Check that they really aren't.  */\n-  undeftab = xmalloc (m.definition_length);\n+  undeftab = XNEWVEC (unsigned char, m.definition_length);\n   if ((size_t) read (fd, undeftab, m.definition_length) != m.definition_length)\n     goto error;\n \n   /* Collect identifiers from the current hash table.  */\n   nl.n_defs = 0;\n   nl.asize = 10;\n-  nl.defs = xmalloc (nl.asize * sizeof (cpp_hashnode *));\n+  nl.defs = XNEWVEC (cpp_hashnode *, nl.asize);\n   cpp_forall_identifiers (r, &collect_ht_nodes, &nl);\n   qsort (nl.defs, nl.n_defs, sizeof (cpp_hashnode *), &comp_hashnodes);\n  \n@@ -577,8 +577,7 @@ save_macros (cpp_reader *r, cpp_hashnode *h, void *data_p)\n       if (data->count == data->array_size)\n \t{\n \t  data->array_size *= 2;\n-\t  data->defns = xrealloc (data->defns, (data->array_size \n-\t\t\t\t\t\t* sizeof (uchar *)));\n+\t  data->defns = XRESIZEVEC (uchar *, data->defns, (data->array_size)); \n \t}\n       \n       switch (h->type)\n@@ -592,7 +591,8 @@ save_macros (cpp_reader *r, cpp_hashnode *h, void *data_p)\n \t    const uchar * defn = cpp_macro_definition (r, h);\n \t    size_t defnlen = ustrlen (defn);\n \n-\t    data->defns[data->count] = xmemdup (defn, defnlen, defnlen + 2);\n+\t    data->defns[data->count] = (uchar *) xmemdup (defn, defnlen,\n+                                                          defnlen + 2);\n \t    data->defns[data->count][defnlen] = '\\n';\n \t  }\n \t  break;\n@@ -611,10 +611,10 @@ save_macros (cpp_reader *r, cpp_hashnode *h, void *data_p)\n void\n cpp_prepare_state (cpp_reader *r, struct save_macro_data **data)\n {\n-  struct save_macro_data *d = xmalloc (sizeof (struct save_macro_data));\n+  struct save_macro_data *d = XNEW (struct save_macro_data);\n   \n   d->array_size = 512;\n-  d->defns = xmalloc (d->array_size * sizeof (d->defns[0]));\n+  d->defns = XNEWVEC (uchar *, d->array_size);\n   d->count = 0;\n   cpp_forall_identifiers (r, save_macros, d);\n   d->saved_pragmas = _cpp_save_pragma_names (r);"}, {"sha": "85450101b800fd1b716f0ebe74635ecdc66f1fa7", "filename": "libcpp/symtab.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3f829c1a6d54e6d2e26dbd09fe8a66e4b9185a9/libcpp%2Fsymtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3f829c1a6d54e6d2e26dbd09fe8a66e4b9185a9/libcpp%2Fsymtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fsymtab.c?ref=c3f829c1a6d54e6d2e26dbd09fe8a66e4b9185a9", "patch": "@@ -56,7 +56,7 @@ ht_create (unsigned int order)\n   unsigned int nslots = 1 << order;\n   hash_table *table;\n \n-  table = xcalloc (1, sizeof (hash_table));\n+  table = XCNEW (hash_table);\n \n   /* Strings need no alignment.  */\n   _obstack_begin (&table->stack, 0, 0,\n@@ -65,7 +65,7 @@ ht_create (unsigned int order)\n \n   obstack_alignment_mask (&table->stack) = 0;\n \n-  table->entries = xcalloc (nslots, sizeof (hashnode));\n+  table->entries = XCNEWVEC (hashnode, nslots);\n   table->entries_owned = true;\n   table->nslots = nslots;\n   return table;\n@@ -161,7 +161,8 @@ ht_lookup_with_hash (hash_table *table, const unsigned char *str,\n   HT_LEN (node) = (unsigned int) len;\n   node->hash_value = hash;\n   if (insert == HT_ALLOC)\n-    HT_STR (node) = obstack_copy0 (&table->stack, str, len);\n+    HT_STR (node) = (const unsigned char *) obstack_copy0 (&table->stack,\n+                                                           str, len);\n   else\n     HT_STR (node) = str;\n \n@@ -181,7 +182,7 @@ ht_expand (hash_table *table)\n   unsigned int size, sizemask;\n \n   size = table->nslots * 2;\n-  nentries = xcalloc (size, sizeof (hashnode));\n+  nentries = XCNEWVEC (hashnode, size);\n   sizemask = size - 1;\n \n   p = table->entries;"}, {"sha": "b27995b400b1c62866c85c3074c72f58e235287a", "filename": "libcpp/system.h", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3f829c1a6d54e6d2e26dbd09fe8a66e4b9185a9/libcpp%2Fsystem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3f829c1a6d54e6d2e26dbd09fe8a66e4b9185a9/libcpp%2Fsystem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fsystem.h?ref=c3f829c1a6d54e6d2e26dbd09fe8a66e4b9185a9", "patch": "@@ -342,10 +342,14 @@ extern void abort (void);\n #include \"libiberty.h\"\n #include \"safe-ctype.h\"\n \n-/* 1 if we have C99 designated initializers.  */\n+/* 1 if we have C99 designated initializers.\n+\n+   ??? C99 designated initializers are not supported by most C++\n+   compilers, including G++.  -- gdr, 2005-05-18  */\n #if !defined(HAVE_DESIGNATED_INITIALIZERS)\n #define HAVE_DESIGNATED_INITIALIZERS \\\n-  ((GCC_VERSION >= 2007) || (__STDC_VERSION__ >= 199901L))\n+  ((!defined(__cplusplus) && (GCC_VERSION >= 2007)) \\\n+   || (__STDC_VERSION__ >= 199901L))\n #endif\n \n /* Be conservative and only use enum bitfields with GCC.\n@@ -379,7 +383,9 @@ extern void abort (void);\n #undef TRUE\n #undef FALSE\n \n+#ifndef __cplusplus\n #define bool unsigned char\n+#endif\n #define true 1\n #define false 0\n "}, {"sha": "a20facb063ef458fde04ff29b925ea5abd7ff9ba", "filename": "libcpp/traditional.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c3f829c1a6d54e6d2e26dbd09fe8a66e4b9185a9/libcpp%2Ftraditional.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c3f829c1a6d54e6d2e26dbd09fe8a66e4b9185a9/libcpp%2Ftraditional.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Ftraditional.c?ref=c3f829c1a6d54e6d2e26dbd09fe8a66e4b9185a9", "patch": "@@ -107,7 +107,7 @@ check_output_buffer (cpp_reader *pfile, size_t n)\n       size_t size = pfile->out.cur - pfile->out.base;\n       size_t new_size = (size + n) * 3 / 2;\n \n-      pfile->out.base = xrealloc (pfile->out.base, new_size);\n+      pfile->out.base = XRESIZEVEC (unsigned char, pfile->out.base, new_size);\n       pfile->out.limit = pfile->out.base + new_size;\n       pfile->out.cur = pfile->out.base + size;\n     }\n@@ -1069,7 +1069,7 @@ bool\n _cpp_expansions_different_trad (const cpp_macro *macro1,\n \t\t\t\tconst cpp_macro *macro2)\n {\n-  uchar *p1 = xmalloc (macro1->count + macro2->count);\n+  uchar *p1 = XNEWVEC (uchar, macro1->count + macro2->count);\n   uchar *p2 = p1 + macro1->count;\n   uchar quote1 = 0, quote2 = 0;\n   bool mismatch;"}]}