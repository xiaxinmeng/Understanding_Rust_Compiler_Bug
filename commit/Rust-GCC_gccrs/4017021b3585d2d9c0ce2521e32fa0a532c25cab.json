{"sha": "4017021b3585d2d9c0ce2521e32fa0a532c25cab", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDAxNzAyMWIzNTg1ZDJkOWMwY2UyNTIxZTMyZmEwYTUzMmMyNWNhYg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-04-10T10:21:44Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-04-10T10:21:44Z"}, "message": "[multiple changes]\n\n2009-04-10  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_prag.adb (Analyze_Pragma, case Task_Name): Do not expand argument\n\tof pragma. It will be recopied and analyzed when used in call to\n\tCreate_Task.\n\n\t* sem_res.adb (Resolve_Call): Clarify use of secondary stack within\n\tinitialization operations and recognize use of it in procedure calls\n\twithin init_procs.\n\n\t* exp_ch9.adb (Make_Task_Create_Call): Copy full tree of Task_Name\n\targument, because it may have side-effects.\n\n\t* exp_ch2.adb: Remove obsolete comments on default functions\n\n2009-04-10  Jose Ruiz  <ruiz@adacore.com>\n\n\t* adaint.c (RTX section): Do for RTX the same thing as we do for\n\tWindows (include ctype.h and define a fallback ISALPHA if IN_RTS).\n\nFrom-SVN: r145882", "tree": {"sha": "bf94e39042c5b3d4750165692d29ac1028365b68", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bf94e39042c5b3d4750165692d29ac1028365b68"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4017021b3585d2d9c0ce2521e32fa0a532c25cab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4017021b3585d2d9c0ce2521e32fa0a532c25cab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4017021b3585d2d9c0ce2521e32fa0a532c25cab", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4017021b3585d2d9c0ce2521e32fa0a532c25cab/comments", "author": null, "committer": null, "parents": [{"sha": "24357840f1d9fbeb5f604b33b541479786d9910a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/24357840f1d9fbeb5f604b33b541479786d9910a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/24357840f1d9fbeb5f604b33b541479786d9910a"}], "stats": {"total": 111, "additions": 77, "deletions": 34}, "files": [{"sha": "71291641b7445407bf7b744e00bdfe614d2b90d0", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4017021b3585d2d9c0ce2521e32fa0a532c25cab/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4017021b3585d2d9c0ce2521e32fa0a532c25cab/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=4017021b3585d2d9c0ce2521e32fa0a532c25cab", "patch": "@@ -1,3 +1,23 @@\n+2009-04-10  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_prag.adb (Analyze_Pragma, case Task_Name): Do not expand argument\n+\tof pragma. It will be recopied and analyzed when used in call to\n+\tCreate_Task.\n+\n+\t* sem_res.adb (Resolve_Call): Clarify use of secondary stack within\n+\tinitialization operations and recognize use of it in procedure calls\n+\twithin init_procs.\n+\n+\t* exp_ch9.adb (Make_Task_Create_Call): Copy full tree of Task_Name\n+\targument, because it may have side-effects.\n+\n+\t* exp_ch2.adb: Remove obsolete comments on default functions\n+\n+2009-04-10  Jose Ruiz  <ruiz@adacore.com>\n+\n+\t* adaint.c (RTX section): Do for RTX the same thing as we do for\n+\tWindows (include ctype.h and define a fallback ISALPHA if IN_RTS).\n+\n 2009-04-10  Robert Dewar  <dewar@adacore.com>\n \n \t* sem_aux.ads, sem_aux.adb (Nearest_Current_Scope): New function."}, {"sha": "7d35f11b3e140014cb57932fe2e641a3277a8c1a", "filename": "gcc/ada/adaint.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4017021b3585d2d9c0ce2521e32fa0a532c25cab/gcc%2Fada%2Fadaint.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4017021b3585d2d9c0ce2521e32fa0a532c25cab/gcc%2Fada%2Fadaint.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fadaint.c?ref=4017021b3585d2d9c0ce2521e32fa0a532c25cab", "patch": "@@ -75,14 +75,15 @@\n #include \"version.h\"\n #endif\n \n+#if defined (__MINGW32__)\n+\n #if defined (RTX)\n #include <windows.h>\n #include <Rtapi.h>\n-#include <sys/utime.h>\n-\n-#elif defined (__MINGW32__)\n-\n+#else\n #include \"mingw32.h\"\n+#endif\n+\n #include <sys/utime.h>\n \n /* For isalpha-like tests in the compiler, we're expected to resort to"}, {"sha": "2963ae872461f669fd3d0cf3133222386988e84c", "filename": "gcc/ada/exp_ch2.adb", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4017021b3585d2d9c0ce2521e32fa0a532c25cab/gcc%2Fada%2Fexp_ch2.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4017021b3585d2d9c0ce2521e32fa0a532c25cab/gcc%2Fada%2Fexp_ch2.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch2.adb?ref=4017021b3585d2d9c0ce2521e32fa0a532c25cab", "patch": "@@ -267,11 +267,9 @@ package body Exp_Ch2 is\n          end loop;\n \n          --  If the discriminant occurs within the default expression for a\n-         --  formal of an entry or protected operation, create a default\n-         --  function for it, and replace the discriminant with a reference to\n-         --  the discriminant of the formal of the default function. The\n-         --  discriminant entity is the one defined in the corresponding\n-         --  record.\n+         --  formal of an entry or protected operation, replace it with a\n+         --  reference to the discriminant of the formal of the enclosing\n+         --  operation.\n \n          if Present (Parent_P)\n            and then Present (Corresponding_Spec (Parent_P))\n@@ -284,8 +282,9 @@ package body Exp_Ch2 is\n                Disc   : Entity_Id;\n \n             begin\n-               --  Verify that we are within a default function: the type of\n-               --  its formal parameter is the same task or protected type.\n+               --  Verify that we are within the body of an entry or protected\n+               --  operation. Its first formal parameter is the synchronized\n+               --  type itself.\n \n                if Present (Formal)\n                  and then Etype (Formal) = Scope (Entity (N))"}, {"sha": "a95835da3cf3541518ce92a54c585c4216b995a2", "filename": "gcc/ada/exp_ch9.adb", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4017021b3585d2d9c0ce2521e32fa0a532c25cab/gcc%2Fada%2Fexp_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4017021b3585d2d9c0ce2521e32fa0a532c25cab/gcc%2Fada%2Fexp_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch9.adb?ref=4017021b3585d2d9c0ce2521e32fa0a532c25cab", "patch": "@@ -11990,8 +11990,11 @@ package body Exp_Ch9 is\n       if Present (Tdef)\n         and then Has_Task_Name_Pragma (Tdef)\n       then\n+         --  Copy expression in full, because it may be dynamic and have\n+         --  side effects.\n+\n          Append_To (Args,\n-           New_Copy (\n+           New_Copy_Tree (\n              Expression (First (\n                Pragma_Argument_Associations (\n                  Find_Task_Or_Protected_Pragma"}, {"sha": "544c6090922a58bd2cb8976a4afbbc9652a796c4", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4017021b3585d2d9c0ce2521e32fa0a532c25cab/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4017021b3585d2d9c0ce2521e32fa0a532c25cab/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=4017021b3585d2d9c0ce2521e32fa0a532c25cab", "patch": "@@ -11168,7 +11168,11 @@ package body Sem_Prag is\n             Check_Arg_Count (1);\n \n             Arg := Expression (Arg1);\n-            Analyze_And_Resolve (Arg, Standard_String);\n+\n+            --  The expression is used in the call to create_task, and must\n+            --  be expanded there, not in the context of the current spec.\n+\n+            Preanalyze_And_Resolve (New_Copy_Tree (Arg), Standard_String);\n \n             if Nkind (P) /= N_Task_Definition then\n                Pragma_Misplaced;"}, {"sha": "0d40e5afcffe4b94d9683cc46e86593075bd96dc", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 37, "deletions": 21, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4017021b3585d2d9c0ce2521e32fa0a532c25cab/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4017021b3585d2d9c0ce2521e32fa0a532c25cab/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=4017021b3585d2d9c0ce2521e32fa0a532c25cab", "patch": "@@ -5043,42 +5043,58 @@ package body Sem_Res is\n \n       --  Create a transient scope if the resulting type requires it\n \n-      --  There are 4 notable exceptions: in init procs, the transient scope\n-      --  overhead is not needed and even incorrect due to the actual expansion\n-      --  of adjust calls; the second case is enumeration literal pseudo calls;\n-      --  the third case is intrinsic subprograms (Unchecked_Conversion and\n-      --  source information functions) that do not use the secondary stack\n-      --  even though the return type is unconstrained; the fourth case is a\n-      --  call to a build-in-place function, since such functions may allocate\n-      --  their result directly in a target object, and cases where the result\n-      --  does get allocated in the secondary stack are checked for within the\n-      --  specialized Exp_Ch6 procedures for expanding build-in-place calls.\n-\n-      --  If this is an initialization call for a type whose initialization\n-      --  uses the secondary stack, we also need to create a transient scope\n-      --  for it, precisely because we will not do it within the init proc\n-      --  itself.\n-\n-      --  If the subprogram is marked Inline_Always, then even if it returns\n+      --  There are several notable exceptions:\n+\n+      --  a) in init procs, the transient scope overhead is not needed, and is\n+      --  even incorrect when the call is a nested initialization call for a\n+      --  component whose expansion may generate adjust calls. However, if the\n+      --  call is some other procedure call within an initialization procedure\n+      --  (for example a call to Create_Task in the init_proc of the task\n+      --  run-time record) a transient scope must be created around this call.\n+\n+      --  b) enumeration literal pseudo-calls need no transient scope.\n+\n+      --  c) intrinsic subprograms (Unchecked_Conversion and source info\n+      --  functions) do not use the secondary stack even though the return\n+      --  type may be unconstrained;\n+\n+      --  d) calls to a build-in-place function, since such functions may\n+      --  allocate their result directly in a target object, and cases where\n+      --  the result does get allocated in the secondary stack are checked for\n+      --  within the specialized Exp_Ch6 procedures for expanding those\n+      --  build-in-place calls.\n+\n+      --  e) If the subprogram is marked Inline_Always, then even if it returns\n       --  an unconstrained type the call does not require use of the secondary\n       --  stack. However, inlining will only take place if the body to inline\n       --  is already present. It may not be available if e.g. the subprogram is\n       --  declared in a child instance.\n \n+      --  If this is an initialization call for a type whose construction\n+      --  uses the secondary stack, and it is not a nested call to initialize\n+      --  a component, we do need to create a transient scope for it. We\n+      --  check for this by traversing the type in Check_Initialization_Call.\n+\n       if Is_Inlined (Nam)\n         and then Has_Pragma_Inline_Always (Nam)\n         and then Nkind (Unit_Declaration_Node (Nam)) = N_Subprogram_Declaration\n         and then Present (Body_To_Inline (Unit_Declaration_Node (Nam)))\n       then\n          null;\n \n+      elsif Ekind (Nam) = E_Enumeration_Literal\n+        or else Is_Build_In_Place_Function (Nam)\n+        or else Is_Intrinsic_Subprogram (Nam)\n+      then\n+         null;\n+\n       elsif Expander_Active\n         and then Is_Type (Etype (Nam))\n         and then Requires_Transient_Scope (Etype (Nam))\n-        and then not Is_Build_In_Place_Function (Nam)\n-        and then Ekind (Nam) /= E_Enumeration_Literal\n-        and then not Within_Init_Proc\n-        and then not Is_Intrinsic_Subprogram (Nam)\n+        and then\n+          (not Within_Init_Proc\n+            or else\n+              (not Is_Init_Proc (Nam) and then Ekind (Nam) /= E_Function))\n       then\n          Establish_Transient_Scope (N, Sec_Stack => True);\n "}]}