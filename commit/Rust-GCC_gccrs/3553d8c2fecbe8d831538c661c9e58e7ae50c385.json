{"sha": "3553d8c2fecbe8d831538c661c9e58e7ae50c385", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzU1M2Q4YzJmZWNiZThkODMxNTM4YzY2MWM5ZTU4ZTdhZTUwYzM4NQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2021-05-21T09:19:32Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2021-05-21T09:19:32Z"}, "message": "Consistently generate debug info for elaboration variables\n\nThis makes sure that debug info is generated for elaboration variables,\neven if the variables are not generated exclusively for this purpose.\n\ngcc/ada/\n\t* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Named_Integer>: Do\n\tnot pass default value in call to create_var_decl.\n\t<E_Variable>: Likewise.\n\t<E_Record_Subtype>: Both pass true for const_flag and false for\n\tconst_decl_allowed_p in call to create_var_decl.\n\tSmall tweaks in the generic record type case.\n\t(elaborate_expression): Rename need_debug into need_for_debug and\n\tadjust throughout.\n\t(elaborate_expression_1): Likewise.  Pass Needs_Debug_Info instead\n\tof need_for_debug in call to create_var_decl.\n\t(elaborate_expression_2): Likewise.\n\t* gcc-interface/utils.c (maybe_pad_type): Pass false for\n\tconst_decl_allowed_p in call to create_var_decl.", "tree": {"sha": "e300ee094019d4bd238780856d54f50c2fd2d955", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e300ee094019d4bd238780856d54f50c2fd2d955"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3553d8c2fecbe8d831538c661c9e58e7ae50c385", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3553d8c2fecbe8d831538c661c9e58e7ae50c385", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3553d8c2fecbe8d831538c661c9e58e7ae50c385", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3553d8c2fecbe8d831538c661c9e58e7ae50c385/comments", "author": null, "committer": null, "parents": [{"sha": "4a29b8d62726d100e1c5ea1e3401309a1437c6be", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a29b8d62726d100e1c5ea1e3401309a1437c6be", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4a29b8d62726d100e1c5ea1e3401309a1437c6be"}], "stats": {"total": 76, "additions": 40, "deletions": 36}, "files": [{"sha": "bc7046accb508067e2de6c695b0cfefc23c2f4bc", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 39, "deletions": 35, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3553d8c2fecbe8d831538c661c9e58e7ae50c385/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3553d8c2fecbe8d831538c661c9e58e7ae50c385/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=3553d8c2fecbe8d831538c661c9e58e7ae50c385", "patch": "@@ -622,7 +622,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t  = create_var_decl (gnu_entity_name, gnu_ext_name, gnu_type,\n \t\t\t     gnu_expr, true, Is_Public (gnat_entity),\n \t\t\t     false, false, false, artificial_p,\n-\t\t\t     debug_info_p, NULL, gnat_entity, true);\n+\t\t\t     debug_info_p, NULL, gnat_entity);\n       }\n       break;\n \n@@ -1527,7 +1527,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t\t\t     imported_p || !definition, static_flag,\n \t\t\t     volatile_flag, artificial_p,\n \t\t\t     debug_info_p && definition, attr_list,\n-\t\t\t     gnat_entity, true);\n+\t\t\t     gnat_entity);\n \tDECL_BY_REF_P (gnu_decl) = used_by_ref;\n \tDECL_POINTS_TO_READONLY_P (gnu_decl) = used_by_ref && inner_const_flag;\n \tDECL_CAN_NEVER_BE_NULL_P (gnu_decl) = Can_Never_Be_Null (gnat_entity);\n@@ -3526,9 +3526,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t\t      = create_var_decl (create_concat_name (gnat_entity,\n \t\t\t\t\t\t\t     \"XVZ\"),\n \t\t\t\t\t NULL_TREE, sizetype, gnu_size_unit,\n-\t\t\t\t\t false, false, false, false, false,\n-\t\t\t\t\t true, debug_info_p,\n-\t\t\t\t\t NULL, gnat_entity);\n+\t\t\t\t\t true, false, false, false, false,\n+\t\t\t\t\t true, true, NULL, gnat_entity, false);\n \t\t}\n \n \t      /* Or else, if the subtype is artificial and encodings are not\n@@ -4455,21 +4454,20 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n       if (Unknown_RM_Size (gnat_entity) && TYPE_SIZE (gnu_type))\n \tSet_RM_Size (gnat_entity, annotate_value (rm_size (gnu_type)));\n \n-      /* If we are at global level, GCC will have applied variable_size to\n-\t the type, but that won't have done anything.  So, if it's not\n-\t a constant or self-referential, call elaborate_expression_1 to\n-\t make a variable for the size rather than calculating it each time.\n-\t Handle both the RM size and the actual size.  */\n+      /* If we are at global level, GCC applied variable_size to the size but\n+\t this has done nothing.  So, if it's not constant or self-referential,\n+\t call elaborate_expression_1 to make a variable for it rather than\n+\t calculating it each time.  */\n       if (TYPE_SIZE (gnu_type)\n \t  && !TREE_CONSTANT (TYPE_SIZE (gnu_type))\n \t  && !CONTAINS_PLACEHOLDER_P (TYPE_SIZE (gnu_type))\n \t  && global_bindings_p ())\n \t{\n-\t  tree size = TYPE_SIZE (gnu_type);\n+\t  tree orig_size = TYPE_SIZE (gnu_type);\n \n \t  TYPE_SIZE (gnu_type)\n-\t    = elaborate_expression_1 (size, gnat_entity, \"SIZE\", definition,\n-\t\t\t\t      false);\n+\t    = elaborate_expression_1 (TYPE_SIZE (gnu_type), gnat_entity,\n+\t\t\t\t      \"SIZE\", definition, false);\n \n \t  /* ??? For now, store the size as a multiple of the alignment in\n \t     bytes so that we can see the alignment from the tree.  */\n@@ -4482,7 +4480,9 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t     may not be marked by the call to create_type_decl below.  */\n \t  MARK_VISITED (TYPE_SIZE_UNIT (gnu_type));\n \n-\t  if (TREE_CODE (gnu_type) == RECORD_TYPE)\n+\t  /* For a record type, deal with the variant part, if any, and handle\n+\t     the Ada size as well.  */\n+\t  if (RECORD_OR_UNION_TYPE_P (gnu_type))\n \t    {\n \t      tree variant_part = get_variant_part (gnu_type);\n \t      tree ada_size = TYPE_ADA_SIZE (gnu_type);\n@@ -4535,7 +4535,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t\t  DECL_SIZE_UNIT (variant_part) = TYPE_SIZE_UNIT (union_type);\n \t\t}\n \n-\t      if (operand_equal_p (ada_size, size, 0))\n+\t      if (operand_equal_p (ada_size, orig_size, 0))\n \t\tada_size = TYPE_SIZE (gnu_type);\n \t      else\n \t\tada_size\n@@ -6724,12 +6724,12 @@ prepend_attributes (struct attrib **attr_list, Entity_Id gnat_entity)\n    if a variable needs to be created and DEFINITION is true if this is done\n    for a definition of GNAT_ENTITY.  If NEED_VALUE is true, we need a result;\n    otherwise, we are just elaborating the expression for side-effects.  If\n-   NEED_DEBUG is true, we need a variable for debugging purposes even if it\n-   isn't needed for code generation.  */\n+   NEED_FOR_DEBUG is true, we need a variable for debugging purposes even\n+   if it isn't needed for code generation.  */\n \n static tree\n elaborate_expression (Node_Id gnat_expr, Entity_Id gnat_entity, const char *s,\n-\t\t      bool definition, bool need_value, bool need_debug)\n+\t\t      bool definition, bool need_value, bool need_for_debug)\n {\n   tree gnu_expr;\n \n@@ -6747,12 +6747,12 @@ elaborate_expression (Node_Id gnat_expr, Entity_Id gnat_entity, const char *s,\n     return NULL_TREE;\n \n   /* If it's a static expression, we don't need a variable for debugging.  */\n-  if (need_debug && Compile_Time_Known_Value (gnat_expr))\n-    need_debug = false;\n+  if (need_for_debug && Compile_Time_Known_Value (gnat_expr))\n+    need_for_debug = false;\n \n   /* Otherwise, convert this tree to its GCC equivalent and elaborate it.  */\n   gnu_expr = elaborate_expression_1 (gnat_to_gnu (gnat_expr), gnat_entity, s,\n-\t\t\t\t     definition, need_debug);\n+\t\t\t\t     definition, need_for_debug);\n \n   /* Save the expression in case we try to elaborate this entity again.  Since\n      it's not a DECL, don't check it.  Don't save if it's a discriminant.  */\n@@ -6766,7 +6766,7 @@ elaborate_expression (Node_Id gnat_expr, Entity_Id gnat_entity, const char *s,\n \n static tree\n elaborate_expression_1 (tree gnu_expr, Entity_Id gnat_entity, const char *s,\n-\t\t\tbool definition, bool need_debug)\n+\t\t\tbool definition, bool need_for_debug)\n {\n   const bool expr_public_p = Is_Public (gnat_entity);\n   const bool expr_global_p = expr_public_p || global_bindings_p ();\n@@ -6814,38 +6814,42 @@ elaborate_expression_1 (tree gnu_expr, Entity_Id gnat_entity, const char *s,\n \n   /* If the GNAT encodings are not used, we don't need a variable for debug\n      info purposes if the expression is a constant or another variable, but\n-     we need to be careful because we do not generate debug info for external\n+     we must be careful because we do not generate debug info for external\n      variables so DECL_IGNORED_P is not stable across units.  */\n-  if (need_debug\n+  if (need_for_debug\n       && gnat_encodings == DWARF_GNAT_ENCODINGS_MINIMAL\n       && (TREE_CONSTANT (gnu_expr)\n \t  || (!expr_public_p\n \t      && DECL_P (gnu_expr)\n \t      && !DECL_IGNORED_P (gnu_expr))))\n-    need_debug = false;\n+    need_for_debug = false;\n \n   /* Now create it, possibly only for debugging purposes.  */\n-  if (use_variable || need_debug)\n+  if (use_variable || need_for_debug)\n     {\n       /* The following variable creation can happen when processing the body\n-\t of subprograms that are defined out of the extended main unit and\n+\t of subprograms that are defined outside of the extended main unit and\n \t inlined.  In this case, we are not at the global scope, and thus the\n \t new variable must not be tagged \"external\", as we used to do here as\n-\t soon as DEFINITION was false.  */\n+\t soon as DEFINITION was false.  And note that we test Needs_Debug_Info\n+\t here instead of NEED_FOR_DEBUG because, once the variable is created,\n+\t whether or not debug information is generated for it is orthogonal to\n+\t the reason why it was created in the first place.  */\n       tree gnu_decl\n \t= create_var_decl (create_concat_name (gnat_entity, s), NULL_TREE,\n \t\t\t   TREE_TYPE (gnu_expr), gnu_expr, true,\n \t\t\t   expr_public_p, !definition && expr_global_p,\n-\t\t\t   expr_global_p, false, true, need_debug,\n-\t\t\t   NULL, gnat_entity);\n+\t\t\t   expr_global_p, false, true,\n+\t\t\t   Needs_Debug_Info (gnat_entity),\n+\t\t\t   NULL, gnat_entity, false);\n \n-      /* Using this variable at debug time (if need_debug is true) requires a\n-\t proper location.  The back-end will compute a location for this\n+      /* Using this variable for debug (if need_for_debug is true) requires\n+\t a proper location.  The back-end will compute a location for this\n \t variable only if the variable is used by the generated code.\n \t Returning the variable ensures the caller will use it in generated\n \t code.  Note that there is no need for a location if the debug info\n \t contains an integer constant.  */\n-      if (use_variable || (need_debug && !TREE_CONSTANT (gnu_expr)))\n+      if (use_variable || (need_for_debug && !TREE_CONSTANT (gnu_expr)))\n \treturn gnu_decl;\n     }\n \n@@ -6856,7 +6860,7 @@ elaborate_expression_1 (tree gnu_expr, Entity_Id gnat_entity, const char *s,\n \n static tree\n elaborate_expression_2 (tree gnu_expr, Entity_Id gnat_entity, const char *s,\n-\t\t\tbool definition, bool need_debug, unsigned int align)\n+\t\t\tbool definition, bool need_for_debug, unsigned int align)\n {\n   tree unit_align = size_int (align / BITS_PER_UNIT);\n   return\n@@ -6865,7 +6869,7 @@ elaborate_expression_2 (tree gnu_expr, Entity_Id gnat_entity, const char *s,\n \t\t\t\t\t\t    gnu_expr,\n \t\t\t\t\t\t    unit_align),\n \t\t\t\t\tgnat_entity, s, definition,\n-\t\t\t\t\tneed_debug),\n+\t\t\t\t\tneed_for_debug),\n \t\tunit_align);\n }\n "}, {"sha": "8d1040b2ae7182f9aab190b559c19a140baf65c4", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3553d8c2fecbe8d831538c661c9e58e7ae50c385/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3553d8c2fecbe8d831538c661c9e58e7ae50c385/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=3553d8c2fecbe8d831538c661c9e58e7ae50c385", "patch": "@@ -1637,7 +1637,7 @@ maybe_pad_type (tree type, tree size, unsigned int align,\n \t    = create_var_decl (concat_name (name, \"XVZ\"), NULL_TREE, sizetype,\n \t\t\t      size_unit, true, global_bindings_p (),\n \t\t\t      !definition && global_bindings_p (), false,\n-\t\t\t      false, true, true, NULL, gnat_entity);\n+\t\t\t      false, true, true, NULL, gnat_entity, false);\n \t  TYPE_SIZE_UNIT (record) = size_unit;\n \t}\n "}]}