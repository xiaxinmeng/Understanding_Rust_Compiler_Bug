{"sha": "1792349b0bd2702c642bb4f57686ecf32810810f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTc5MjM0OWIwYmQyNzAyYzY0MmJiNGY1NzY4NmVjZjMyODEwODEwZg==", "commit": {"author": {"name": "Andre Vehreschild", "email": "vehre@gmx.de", "date": "2015-06-15T10:08:04Z"}, "committer": {"name": "Andre Vehreschild", "email": "vehre@gcc.gnu.org", "date": "2015-06-15T10:08:04Z"}, "message": "re PR fortran/44672 ([F08] ALLOCATE with SOURCE and no array-spec)\n\ngcc/testsuite/ChangeLog:\n\n2015-06-15  Andre Vehreschild  <vehre@gmx.de>\n\n\tPR fortran/44672\n\tPR fortran/45440\n\tPR fortran/57307\n\t* gfortran.dg/allocate_with_source_3.f90: Removed check for\n\tunimplemented error.\n\t* gfortran.dg/allocate_with_source_7.f08: New test.\n\t* gfortran.dg/allocate_with_source_8.f08: New test.\n\ngcc/fortran/ChangeLog:\n\n2015-06-15  Andre Vehreschild  <vehre@gmx.de>\n\n\tPR fortran/44672\n\tPR fortran/45440\n\tPR fortran/57307\n\t* gfortran.h: Extend gfc_code.ext.alloc to carry a\n\tflag indicating that the array specification has to be\n\ttaken from expr3.\n\t* resolve.c (resolve_allocate_expr): Add F2008 notify\n\tand flag indicating source driven array spec.\n\t(resolve_allocate_deallocate): Check for source driven\n\tarray spec, when array to allocate has no explicit\n\tarray spec.\n\t* trans-array.c (gfc_array_init_size): Get lower and\n\tupper bound from a tree array descriptor, except when\n\tthe source expression is an array-constructor which is\n\tfixed to be one-based.\n\t(retrieve_last_ref): Extracted from gfc_array_allocate().\n\t(gfc_array_allocate): Enable allocate(array, source= \n\tarray_expression) as specified by F2008:C633.\n\t(gfc_conv_expr_descriptor): Add class tree expression\n\tinto the saved descriptor for class arrays.\n\t* trans-array.h: Add temporary array descriptor to\n\tgfc_array_allocate ().\n\t* trans-expr.c (gfc_conv_procedure_call): Special handling\n\tfor _copy() routine translation, that comes without an\n\tinterface. Third and fourth argument are now passed by value.\n\t* trans-stmt.c (gfc_trans_allocate): Get expr3 array\n\tdescriptor for temporary arrays to allow allocate(array,\n\tsource = array_expression) for array without array\n\tspecification.\n\nFrom-SVN: r224477", "tree": {"sha": "39ffb46865f07b55c93fbff285b2a7d35f5c0998", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/39ffb46865f07b55c93fbff285b2a7d35f5c0998"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1792349b0bd2702c642bb4f57686ecf32810810f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1792349b0bd2702c642bb4f57686ecf32810810f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1792349b0bd2702c642bb4f57686ecf32810810f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1792349b0bd2702c642bb4f57686ecf32810810f/comments", "author": {"login": "vehre", "id": 4761547, "node_id": "MDQ6VXNlcjQ3NjE1NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4761547?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vehre", "html_url": "https://github.com/vehre", "followers_url": "https://api.github.com/users/vehre/followers", "following_url": "https://api.github.com/users/vehre/following{/other_user}", "gists_url": "https://api.github.com/users/vehre/gists{/gist_id}", "starred_url": "https://api.github.com/users/vehre/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vehre/subscriptions", "organizations_url": "https://api.github.com/users/vehre/orgs", "repos_url": "https://api.github.com/users/vehre/repos", "events_url": "https://api.github.com/users/vehre/events{/privacy}", "received_events_url": "https://api.github.com/users/vehre/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "cf0c27ef2b2b06a17af2a2626fdc98f19d48dda6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf0c27ef2b2b06a17af2a2626fdc98f19d48dda6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cf0c27ef2b2b06a17af2a2626fdc98f19d48dda6"}], "stats": {"total": 594, "additions": 472, "deletions": 122}, "files": [{"sha": "5ede14dbc34c3ac69089526e3d6591b5e4c728aa", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1792349b0bd2702c642bb4f57686ecf32810810f/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1792349b0bd2702c642bb4f57686ecf32810810f/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=1792349b0bd2702c642bb4f57686ecf32810810f", "patch": "@@ -1,3 +1,35 @@\n+2015-06-15  Andre Vehreschild  <vehre@gmx.de>\n+\n+\tPR fortran/44672\n+\tPR fortran/45440\n+\tPR fortran/57307\n+\t* gfortran.h: Extend gfc_code.ext.alloc to carry a\n+\tflag indicating that the array specification has to be\n+\ttaken from expr3.\n+\t* resolve.c (resolve_allocate_expr): Add F2008 notify\n+\tand flag indicating source driven array spec.\n+\t(resolve_allocate_deallocate): Check for source driven\n+\tarray spec, when array to allocate has no explicit\n+\tarray spec.\n+\t* trans-array.c (gfc_array_init_size): Get lower and\n+\tupper bound from a tree array descriptor, except when\n+\tthe source expression is an array-constructor which is\n+\tfixed to be one-based.\n+\t(retrieve_last_ref): Extracted from gfc_array_allocate().\n+\t(gfc_array_allocate): Enable allocate(array, source= \n+\tarray_expression) as specified by F2008:C633.\n+\t(gfc_conv_expr_descriptor): Add class tree expression\n+\tinto the saved descriptor for class arrays.\n+\t* trans-array.h: Add temporary array descriptor to\n+\tgfc_array_allocate ().\n+\t* trans-expr.c (gfc_conv_procedure_call): Special handling\n+\tfor _copy() routine translation, that comes without an\n+\tinterface. Third and fourth argument are now passed by value.\n+\t* trans-stmt.c (gfc_trans_allocate): Get expr3 array\n+\tdescriptor for temporary arrays to allow allocate(array,\n+\tsource = array_expression) for array without array\n+\tspecification.\n+\n 2015-06-14  Thomas Koenig  <tkoenig@gcc.gnu.org>\n \n \t* intrinsic.texi:  Change \\leq to < in descrition of imaginary"}, {"sha": "4b07ddb13f404240e7f1f1481a9b0ae1cf426039", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1792349b0bd2702c642bb4f57686ecf32810810f/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1792349b0bd2702c642bb4f57686ecf32810810f/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=1792349b0bd2702c642bb4f57686ecf32810810f", "patch": "@@ -2395,6 +2395,9 @@ typedef struct gfc_code\n     {\n       gfc_typespec ts;\n       gfc_alloc *list;\n+      /* Take the array specification from expr3 to allocate arrays\n+\t without an explicit array specification.  */\n+      unsigned arr_spec_from_expr3:1;\n     }\n     alloc;\n "}, {"sha": "f365e8ff75c40a4152e77351d891cda8245294fd", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 27, "deletions": 7, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1792349b0bd2702c642bb4f57686ecf32810810f/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1792349b0bd2702c642bb4f57686ecf32810810f/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=1792349b0bd2702c642bb4f57686ecf32810810f", "patch": "@@ -6805,7 +6805,7 @@ conformable_arrays (gfc_expr *e1, gfc_expr *e2)\n    have a trailing array reference that gives the size of the array.  */\n \n static bool\n-resolve_allocate_expr (gfc_expr *e, gfc_code *code)\n+resolve_allocate_expr (gfc_expr *e, gfc_code *code, bool *array_alloc_wo_spec)\n {\n   int i, pointer, allocatable, dimension, is_abstract;\n   int codimension;\n@@ -7104,13 +7104,24 @@ resolve_allocate_expr (gfc_expr *e, gfc_code *code)\n   if (!ref2 || ref2->type != REF_ARRAY || ref2->u.ar.type == AR_FULL\n       || (dimension && ref2->u.ar.dimen == 0))\n     {\n-      gfc_error (\"Array specification required in ALLOCATE statement \"\n-\t\t \"at %L\", &e->where);\n-      goto failure;\n+      /* F08:C633.  */\n+      if (code->expr3)\n+\t{\n+\t  if (!gfc_notify_std (GFC_STD_F2008, \"Array specification required \"\n+\t\t\t       \"in ALLOCATE statement at %L\", &e->where))\n+\t    goto failure;\n+\t  *array_alloc_wo_spec = true;\n+\t}\n+      else\n+\t{\n+\t  gfc_error (\"Array specification required in ALLOCATE statement \"\n+\t\t     \"at %L\", &e->where);\n+\t  goto failure;\n+\t}\n     }\n \n   /* Make sure that the array section reference makes sense in the\n-    context of an ALLOCATE specification.  */\n+     context of an ALLOCATE specification.  */\n \n   ar = &ref2->u.ar;\n \n@@ -7125,7 +7136,7 @@ resolve_allocate_expr (gfc_expr *e, gfc_code *code)\n \n   for (i = 0; i < ar->dimen; i++)\n     {\n-      if (ref2->u.ar.type == AR_ELEMENT)\n+      if (ar->type == AR_ELEMENT || ar->type == AR_FULL)\n \tgoto check_symbols;\n \n       switch (ar->dimen_type[i])\n@@ -7202,6 +7213,7 @@ resolve_allocate_expr (gfc_expr *e, gfc_code *code)\n   return false;\n }\n \n+\n static void\n resolve_allocate_deallocate (gfc_code *code, const char *fcn)\n {\n@@ -7376,8 +7388,16 @@ resolve_allocate_deallocate (gfc_code *code, const char *fcn)\n \n   if (strcmp (fcn, \"ALLOCATE\") == 0)\n     {\n+      bool arr_alloc_wo_spec = false;\n       for (a = code->ext.alloc.list; a; a = a->next)\n-\tresolve_allocate_expr (a->expr, code);\n+\tresolve_allocate_expr (a->expr, code, &arr_alloc_wo_spec);\n+\n+      if (arr_alloc_wo_spec && code->expr3)\n+\t{\n+\t  /* Mark the allocate to have to take the array specification\n+\t     from the expr3.  */\n+\t  code->ext.alloc.arr_spec_from_expr3 = 1;\n+\t}\n     }\n   else\n     {"}, {"sha": "e9174aebd1e123c7cbb6cc746284b714a7288e97", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 100, "deletions": 19, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1792349b0bd2702c642bb4f57686ecf32810810f/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1792349b0bd2702c642bb4f57686ecf32810810f/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=1792349b0bd2702c642bb4f57686ecf32810810f", "patch": "@@ -4998,7 +4998,8 @@ static tree\n gfc_array_init_size (tree descriptor, int rank, int corank, tree * poffset,\n \t\t     gfc_expr ** lower, gfc_expr ** upper, stmtblock_t * pblock,\n \t\t     stmtblock_t * descriptor_block, tree * overflow,\n-\t\t     tree expr3_elem_size, tree *nelems, gfc_expr *expr3)\n+\t\t     tree expr3_elem_size, tree *nelems, gfc_expr *expr3,\n+\t\t     tree expr3_desc, bool e3_is_array_constr)\n {\n   tree type;\n   tree tmp;\n@@ -5041,7 +5042,18 @@ gfc_array_init_size (tree descriptor, int rank, int corank, tree * poffset,\n \n       /* Set lower bound.  */\n       gfc_init_se (&se, NULL);\n-      if (lower == NULL)\n+      if (expr3_desc != NULL_TREE)\n+\t{\n+\t  if (e3_is_array_constr)\n+\t    /* The lbound of a constant array [] starts at zero, but when\n+\t       allocating it, the standard expects the array to start at\n+\t       one.  */\n+\t    se.expr = gfc_index_one_node;\n+\t  else\n+\t    se.expr = gfc_conv_descriptor_lbound_get (expr3_desc,\n+\t\t\t\t\t\t      gfc_rank_cst[n]);\n+\t}\n+      else if (lower == NULL)\n \tse.expr = gfc_index_one_node;\n       else\n \t{\n@@ -5069,10 +5081,35 @@ gfc_array_init_size (tree descriptor, int rank, int corank, tree * poffset,\n \n       /* Set upper bound.  */\n       gfc_init_se (&se, NULL);\n-      gcc_assert (ubound);\n-      gfc_conv_expr_type (&se, ubound, gfc_array_index_type);\n-      gfc_add_block_to_block (pblock, &se.pre);\n-\n+      if (expr3_desc != NULL_TREE)\n+\t{\n+\t  if (e3_is_array_constr)\n+\t    {\n+\t      /* The lbound of a constant array [] starts at zero, but when\n+\t       allocating it, the standard expects the array to start at\n+\t       one.  Therefore fix the upper bound to be\n+\t       (desc.ubound - desc.lbound)+ 1.  */\n+\t      tmp = fold_build2_loc (input_location, MINUS_EXPR,\n+\t\t\t\t     gfc_array_index_type,\n+\t\t\t\t     gfc_conv_descriptor_ubound_get (\n+\t\t\t\t       expr3_desc, gfc_rank_cst[n]),\n+\t\t\t\t     gfc_conv_descriptor_lbound_get (\n+\t\t\t\t       expr3_desc, gfc_rank_cst[n]));\n+\t      tmp = fold_build2_loc (input_location, PLUS_EXPR,\n+\t\t\t\t     gfc_array_index_type, tmp,\n+\t\t\t\t     gfc_index_one_node);\n+\t      se.expr = gfc_evaluate_now (tmp, pblock);\n+\t    }\n+\t  else\n+\t    se.expr = gfc_conv_descriptor_ubound_get (expr3_desc,\n+\t\t\t\t\t\t      gfc_rank_cst[n]);\n+\t}\n+      else\n+\t{\n+\t  gcc_assert (ubound);\n+\t  gfc_conv_expr_type (&se, ubound, gfc_array_index_type);\n+\t  gfc_add_block_to_block (pblock, &se.pre);\n+\t}\n       gfc_conv_descriptor_ubound_set (descriptor_block, descriptor,\n \t\t\t\t      gfc_rank_cst[n], se.expr);\n       conv_ubound = se.expr;\n@@ -5242,14 +5279,42 @@ gfc_array_init_size (tree descriptor, int rank, int corank, tree * poffset,\n }\n \n \n+/* Retrieve the last ref from the chain.  This routine is specific to\n+   gfc_array_allocate ()'s needs.  */\n+\n+bool\n+retrieve_last_ref (gfc_ref **ref_in, gfc_ref **prev_ref_in)\n+{\n+  gfc_ref *ref, *prev_ref;\n+\n+  ref = *ref_in;\n+  /* Prevent warnings for uninitialized variables.  */\n+  prev_ref = *prev_ref_in;\n+  while (ref && ref->next != NULL)\n+    {\n+      gcc_assert (ref->type != REF_ARRAY || ref->u.ar.type == AR_ELEMENT\n+\t\t  || (ref->u.ar.dimen == 0 && ref->u.ar.codimen > 0));\n+      prev_ref = ref;\n+      ref = ref->next;\n+    }\n+\n+  if (ref == NULL || ref->type != REF_ARRAY)\n+    return false;\n+\n+  *ref_in = ref;\n+  *prev_ref_in = prev_ref;\n+  return true;\n+}\n+\n /* Initializes the descriptor and generates a call to _gfor_allocate.  Does\n    the work for an ALLOCATE statement.  */\n /*GCC ARRAYS*/\n \n bool\n gfc_array_allocate (gfc_se * se, gfc_expr * expr, tree status, tree errmsg,\n \t\t    tree errlen, tree label_finish, tree expr3_elem_size,\n-\t\t    tree *nelems, gfc_expr *expr3)\n+\t\t    tree *nelems, gfc_expr *expr3, tree e3_arr_desc,\n+\t\t    bool e3_is_array_constr)\n {\n   tree tmp;\n   tree pointer;\n@@ -5267,21 +5332,24 @@ gfc_array_allocate (gfc_se * se, gfc_expr * expr, tree status, tree errmsg,\n   gfc_expr **lower;\n   gfc_expr **upper;\n   gfc_ref *ref, *prev_ref = NULL;\n-  bool allocatable, coarray, dimension;\n+  bool allocatable, coarray, dimension, alloc_w_e3_arr_spec = false;\n \n   ref = expr->ref;\n \n   /* Find the last reference in the chain.  */\n-  while (ref && ref->next != NULL)\n+  if (!retrieve_last_ref (&ref, &prev_ref))\n+    return false;\n+\n+  if (ref->u.ar.type == AR_FULL && expr3 != NULL)\n     {\n-      gcc_assert (ref->type != REF_ARRAY || ref->u.ar.type == AR_ELEMENT\n-\t\t  || (ref->u.ar.dimen == 0 && ref->u.ar.codimen > 0));\n-      prev_ref = ref;\n-      ref = ref->next;\n-    }\n+      /* F08:C633: Array shape from expr3.  */\n+      ref = expr3->ref;\n \n-  if (ref == NULL || ref->type != REF_ARRAY)\n-    return false;\n+      /* Find the last reference in the chain.  */\n+      if (!retrieve_last_ref (&ref, &prev_ref))\n+\treturn false;\n+      alloc_w_e3_arr_spec = true;\n+    }\n \n   if (!prev_ref)\n     {\n@@ -5317,7 +5385,8 @@ gfc_array_allocate (gfc_se * se, gfc_expr * expr, tree status, tree errmsg,\n       break;\n \n     case AR_FULL:\n-      gcc_assert (ref->u.ar.as->type == AS_EXPLICIT);\n+      gcc_assert (ref->u.ar.as->type == AS_EXPLICIT\n+\t\t  || alloc_w_e3_arr_spec);\n \n       lower = ref->u.ar.as->lower;\n       upper = ref->u.ar.as->upper;\n@@ -5331,10 +5400,12 @@ gfc_array_allocate (gfc_se * se, gfc_expr * expr, tree status, tree errmsg,\n   overflow = integer_zero_node;\n \n   gfc_init_block (&set_descriptor_block);\n-  size = gfc_array_init_size (se->expr, ref->u.ar.as->rank,\n+  size = gfc_array_init_size (se->expr, alloc_w_e3_arr_spec ? expr->rank\n+\t\t\t\t\t\t\t   : ref->u.ar.as->rank,\n \t\t\t      ref->u.ar.as->corank, &offset, lower, upper,\n \t\t\t      &se->pre, &set_descriptor_block, &overflow,\n-\t\t\t      expr3_elem_size, nelems, expr3);\n+\t\t\t      expr3_elem_size, nelems, expr3, e3_arr_desc,\n+\t\t\t      e3_is_array_constr);\n \n   if (dimension)\n     {\n@@ -7073,6 +7144,16 @@ gfc_conv_expr_descriptor (gfc_se *se, gfc_expr *expr)\n       desc = parm;\n     }\n \n+  /* For class arrays add the class tree into the saved descriptor to\n+     enable getting of _vptr and the like.  */\n+  if (expr->expr_type == EXPR_VARIABLE && VAR_P (desc)\n+      && IS_CLASS_ARRAY (expr->symtree->n.sym)\n+      && DECL_LANG_SPECIFIC (expr->symtree->n.sym->backend_decl))\n+    {\n+      gfc_allocate_lang_decl (desc);\n+      GFC_DECL_SAVED_DESCRIPTOR (desc) =\n+\t  GFC_DECL_SAVED_DESCRIPTOR (expr->symtree->n.sym->backend_decl);\n+    }\n   if (!se->direct_byref || se->byref_noassign)\n     {\n       /* Get a pointer to the new descriptor.  */"}, {"sha": "52f1c9aef890c0ad56b4929544a664e8a99a9158", "filename": "gcc/fortran/trans-array.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1792349b0bd2702c642bb4f57686ecf32810810f/gcc%2Ffortran%2Ftrans-array.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1792349b0bd2702c642bb4f57686ecf32810810f/gcc%2Ffortran%2Ftrans-array.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.h?ref=1792349b0bd2702c642bb4f57686ecf32810810f", "patch": "@@ -24,7 +24,7 @@ tree gfc_array_deallocate (tree, tree, tree, tree, tree, gfc_expr*);\n /* Generate code to initialize and allocate an array.  Statements are added to\n    se, which should contain an expression for the array descriptor.  */\n bool gfc_array_allocate (gfc_se *, gfc_expr *, tree, tree, tree, tree,\n-\t\t\t tree, tree *, gfc_expr *);\n+\t\t\t tree, tree *, gfc_expr *, tree, bool);\n \n /* Allow the bounds of a loop to be set from a callee's array spec.  */\n void gfc_set_loop_bounds_from_array_spec (gfc_interface_mapping *,"}, {"sha": "77d2cda028814bb31b477ceaed851ad9f40b2d7e", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 19, "deletions": 4, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1792349b0bd2702c642bb4f57686ecf32810810f/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1792349b0bd2702c642bb4f57686ecf32810810f/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=1792349b0bd2702c642bb4f57686ecf32810810f", "patch": "@@ -4561,6 +4561,7 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n   int has_alternate_specifier = 0;\n   bool need_interface_mapping;\n   bool callee_alloc;\n+  bool ulim_copy;\n   gfc_typespec ts;\n   gfc_charlen cl;\n   gfc_expr *e;\n@@ -4569,6 +4570,7 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n   enum {MISSING = 0, ELEMENTAL, SCALAR, SCALAR_POINTER, ARRAY};\n   gfc_component *comp = NULL;\n   int arglen;\n+  unsigned int argc;\n \n   arglist = NULL;\n   retargs = NULL;\n@@ -4624,10 +4626,16 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n     }\n \n   base_object = NULL_TREE;\n+  /* For _vprt->_copy () routines no formal symbol is present.  Nevertheless\n+     is the third and fourth argument to such a function call a value\n+     denoting the number of elements to copy (i.e., most of the time the\n+     length of a deferred length string).  */\n+  ulim_copy = formal == NULL && UNLIMITED_POLY (sym)\n+      && strcmp (\"_copy\", comp->name) == 0;\n \n   /* Evaluate the arguments.  */\n-  for (arg = args; arg != NULL;\n-       arg = arg->next, formal = formal ? formal->next : NULL)\n+  for (arg = args, argc = 0; arg != NULL;\n+       arg = arg->next, formal = formal ? formal->next : NULL, ++argc)\n     {\n       e = arg->expr;\n       fsym = formal ? formal->sym : NULL;\n@@ -4729,7 +4737,14 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t  gfc_init_se (&parmse, se);\n \t  parm_kind = ELEMENTAL;\n \n-\t  if (fsym && fsym->attr.value)\n+\t  /* When no fsym is present, ulim_copy is set and this is a third or\n+\t     fourth argument, use call-by-value instead of by reference to\n+\t     hand the length properties to the copy routine (i.e., most of the\n+\t     time this will be a call to a __copy_character_* routine where the\n+\t     third and fourth arguments are the lengths of a deferred length\n+\t     char array).  */\n+\t  if ((fsym && fsym->attr.value)\n+\t      || (ulim_copy && (argc == 2 || argc == 3)))\n \t    gfc_conv_expr (&parmse, e);\n \t  else\n \t    gfc_conv_expr_reference (&parmse, e);\n@@ -5322,7 +5337,7 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n       if (e && (e->ts.type == BT_DERIVED || e->ts.type == BT_CLASS)\n \t    && e->ts.u.derived->attr.alloc_comp\n \t    && !(e->symtree && e->symtree->n.sym->attr.pointer)\n-\t    && (e->expr_type != EXPR_VARIABLE && !e->rank))\n+\t    && e->expr_type != EXPR_VARIABLE && !e->rank)\n         {\n \t  int parm_rank;\n \t  tmp = build_fold_indirect_ref_loc (input_location,"}, {"sha": "6772a3cf8093a48778eb8e06f888030f22810999", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 90, "deletions": 90, "changes": 180, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1792349b0bd2702c642bb4f57686ecf32810810f/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1792349b0bd2702c642bb4f57686ecf32810810f/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=1792349b0bd2702c642bb4f57686ecf32810810f", "patch": "@@ -5098,6 +5098,8 @@ gfc_trans_allocate (gfc_code * code)\n      the trees may be the NULL_TREE indicating that this is not\n      available for expr3's type.  */\n   tree expr3, expr3_vptr, expr3_len, expr3_esize;\n+  /* Classify what expr3 stores.  */\n+  enum { E3_UNSET = 0, E3_SOURCE, E3_MOLD, E3_DESC } e3_is;\n   stmtblock_t block;\n   stmtblock_t post;\n   tree nelems;\n@@ -5110,6 +5112,7 @@ gfc_trans_allocate (gfc_code * code)\n   stat = tmp = memsz = al_vptr = al_len = NULL_TREE;\n   expr3 = expr3_vptr = expr3_len = expr3_esize = NULL_TREE;\n   label_errmsg = label_finish = errmsg = errlen = NULL_TREE;\n+  e3_is = E3_UNSET;\n \n   gfc_init_block (&block);\n   gfc_init_block (&post);\n@@ -5149,16 +5152,14 @@ gfc_trans_allocate (gfc_code * code)\n      expression.  */\n   if (code->expr3)\n     {\n-      bool vtab_needed = false;\n-      /* expr3_tmp gets the tree when code->expr3.mold is set, i.e.,\n-\t the expression is only needed to get the _vptr, _len a.s.o.  */\n-      tree expr3_tmp = NULL_TREE;\n+      bool vtab_needed = false, temp_var_needed = false;\n \n       /* Figure whether we need the vtab from expr3.  */\n       for (al = code->ext.alloc.list; !vtab_needed && al != NULL;\n \t   al = al->next)\n \tvtab_needed = (al->expr->ts.type == BT_CLASS);\n \n+      gfc_init_se (&se, NULL);\n       /* When expr3 is a variable, i.e., a very simple expression,\n \t     then convert it once here.  */\n       if (code->expr3->expr_type == EXPR_VARIABLE\n@@ -5167,31 +5168,25 @@ gfc_trans_allocate (gfc_code * code)\n \t{\n \t  if (!code->expr3->mold\n \t      || code->expr3->ts.type == BT_CHARACTER\n-\t      || vtab_needed)\n+\t      || vtab_needed\n+\t      || code->ext.alloc.arr_spec_from_expr3)\n \t    {\n-\t      /* Convert expr3 to a tree.  */\n-\t      gfc_init_se (&se, NULL);\n-\t      /* For all \"simple\" expression just get the descriptor or the\n-\t\t reference, respectively, depending on the rank of the expr.  */\n-\t      if (code->expr3->rank != 0)\n+\t      /* Convert expr3 to a tree.  For all \"simple\" expression just\n+\t\t get the descriptor or the reference, respectively, depending\n+\t\t on the rank of the expr.  */\n+\t      if (code->ext.alloc.arr_spec_from_expr3 || code->expr3->rank != 0)\n \t\tgfc_conv_expr_descriptor (&se, code->expr3);\n \t      else\n \t\tgfc_conv_expr_reference (&se, code->expr3);\n-\t      if (!code->expr3->mold)\n-\t\texpr3 = se.expr;\n-\t      else\n-\t\texpr3_tmp = se.expr;\n-\t      expr3_len = se.string_length;\n-\t      gfc_add_block_to_block (&block, &se.pre);\n-\t      gfc_add_block_to_block (&post, &se.post);\n+\t      /* Create a temp variable only for component refs to prevent\n+\t\t having to go through the full deref-chain each time and to\n+\t\t simplfy computation of array properties.  */\n+\t      temp_var_needed = TREE_CODE (se.expr) == COMPONENT_REF;\n \t    }\n-\t  /* else expr3 = NULL_TREE set above.  */\n \t}\n       else\n \t{\n-\t  /* In all other cases evaluate the expr3 and create a\n-\t\t temporary.  */\n-\t  gfc_init_se (&se, NULL);\n+\t  /* In all other cases evaluate the expr3.  */\n \t  symbol_attribute attr;\n \t  /* Get the descriptor for all arrays, that are not allocatable or\n \t     pointer, because the latter are descriptors already.  */\n@@ -5205,45 +5200,55 @@ gfc_trans_allocate (gfc_code * code)\n \t\t\t\t     code->expr3->ts,\n \t\t\t\t     false, true,\n \t\t\t\t     false, false);\n-\t  gfc_add_block_to_block (&block, &se.pre);\n-\t  gfc_add_block_to_block (&post, &se.post);\n-\n-\t  /* Prevent aliasing, i.e., se.expr may be already a\n-\t\t variable declaration.  */\n-\t  if (!VAR_P (se.expr))\n+\t  temp_var_needed = !VAR_P (se.expr);\n+\t}\n+      gfc_add_block_to_block (&block, &se.pre);\n+      gfc_add_block_to_block (&post, &se.post);\n+      /* Prevent aliasing, i.e., se.expr may be already a\n+\t     variable declaration.  */\n+      if (se.expr != NULL_TREE && temp_var_needed)\n+\t{\n+\t  tree var;\n+\t  tmp = GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (se.expr)) ?\n+\t\tse.expr\n+\t      : build_fold_indirect_ref_loc (input_location, se.expr);\n+\t  /* We need a regular (non-UID) symbol here, therefore give a\n+\t     prefix.  */\n+\t  var = gfc_create_var (TREE_TYPE (tmp), \"source\");\n+\t  if (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (se.expr)))\n \t    {\n-\t      tree var;\n-\t      tmp = build_fold_indirect_ref_loc (input_location,\n-\t\t\t\t\t\t se.expr);\n-\t      /* We need a regular (non-UID) symbol here, therefore give a\n-\t\t prefix.  */\n-\t      var = gfc_create_var (TREE_TYPE (tmp), \"source\");\n-\t      gfc_add_modify_loc (input_location, &block, var, tmp);\n-\n-\t      /* Deallocate any allocatable components after all the allocations\n-\t\t and assignments of expr3 have been completed.  */\n-\t      if (code->expr3->ts.type == BT_DERIVED\n-\t\t  && code->expr3->rank == 0\n-\t\t  && code->expr3->ts.u.derived->attr.alloc_comp)\n-\t\t{\n-\t\t  tmp = gfc_deallocate_alloc_comp (code->expr3->ts.u.derived,\n-\t\t\t\t\t\t   var, 0);\n-\t\t  gfc_add_expr_to_block (&post, tmp);\n-\t\t}\n+\t      gfc_allocate_lang_decl (var);\n+\t      GFC_DECL_SAVED_DESCRIPTOR (var) = se.expr;\n+\t    }\n+\t  gfc_add_modify_loc (input_location, &block, var, tmp);\n \n-\t      tmp = var;\n+\t  /* Deallocate any allocatable components after all the allocations\n+\t     and assignments of expr3 have been completed.  */\n+\t  if (code->expr3->ts.type == BT_DERIVED\n+\t      && code->expr3->rank == 0\n+\t      && code->expr3->ts.u.derived->attr.alloc_comp)\n+\t    {\n+\t      tmp = gfc_deallocate_alloc_comp (code->expr3->ts.u.derived,\n+\t\t\t\t\t       var, 0);\n+\t      gfc_add_expr_to_block (&post, tmp);\n \t    }\n-\t  else\n-\t    tmp = se.expr;\n-\t  if (!code->expr3->mold)\n-\t    expr3 = tmp;\n-\t  else\n-\t    expr3_tmp = tmp;\n-\t  /* When he length of a char array is easily available\n-\t\t here, fix it for future use.  */\n+\n+\t  expr3 = var;\n \t  if (se.string_length)\n+\t    /* Evaluate it assuming that it also is complicated like expr3.  */\n \t    expr3_len = gfc_evaluate_now (se.string_length, &block);\n \t}\n+      else\n+\t{\n+\t  expr3 = se.expr;\n+\t  expr3_len = se.string_length;\n+\t}\n+      /* Store what the expr3 is to be used for.  */\n+      e3_is = expr3 != NULL_TREE ?\n+\t    (code->ext.alloc.arr_spec_from_expr3 ?\n+\t       E3_DESC\n+\t     : (code->expr3->mold ? E3_MOLD : E3_SOURCE))\n+\t  : E3_UNSET;\n \n       /* Figure how to get the _vtab entry.  This also obtains the tree\n \t expression for accessing the _len component, because only\n@@ -5258,10 +5263,6 @@ gfc_trans_allocate (gfc_code * code)\n \t  if (expr3 != NULL_TREE && GFC_CLASS_TYPE_P (TREE_TYPE (expr3))\n \t      && (VAR_P (expr3) || !code->expr3->ref))\n \t    tmp = gfc_class_vptr_get (expr3);\n-\t  else if (expr3_tmp != NULL_TREE\n-\t\t   && GFC_CLASS_TYPE_P (TREE_TYPE (expr3_tmp))\n-\t\t   && (VAR_P (expr3_tmp) || !code->expr3->ref))\n-\t    tmp = gfc_class_vptr_get (expr3_tmp);\n \t  else\n \t    {\n \t      rhs = gfc_find_and_cut_at_last_class_ref (code->expr3);\n@@ -5281,9 +5282,7 @@ gfc_trans_allocate (gfc_code * code)\n \t    {\n \t      /* Same like for retrieving the _vptr.  */\n \t      if (expr3 != NULL_TREE && !code->expr3->ref)\n-\t\texpr3_len  = gfc_class_len_get (expr3);\n-\t      else if (expr3_tmp != NULL_TREE && !code->expr3->ref)\n-\t\texpr3_len  = gfc_class_len_get (expr3_tmp);\n+\t\texpr3_len = gfc_class_len_get (expr3);\n \t      else\n \t\t{\n \t\t  rhs = gfc_find_and_cut_at_last_class_ref (code->expr3);\n@@ -5344,8 +5343,11 @@ gfc_trans_allocate (gfc_code * code)\n \t     advantage is, that we get scalarizer support for free,\n \t     don't have to take care about scalar to array treatment and\n \t     will benefit of every enhancements gfc_trans_assignment ()\n-\t     gets.  */\n-\t  if (expr3 != NULL_TREE && DECL_P (expr3) && DECL_ARTIFICIAL (expr3))\n+\t     gets.\n+\t     No need to check whether e3_is is E3_UNSET, because that is\n+\t     done by expr3 != NULL_TREE.  */\n+\t  if (e3_is != E3_MOLD && expr3 != NULL_TREE\n+\t      && DECL_P (expr3) && DECL_ARTIFICIAL (expr3))\n \t    {\n \t      /* Build a temporary symtree and symbol.  Do not add it to\n \t\t the current namespace to prevent accidently modifying\n@@ -5397,6 +5399,12 @@ gfc_trans_allocate (gfc_code * code)\n \t}\n       gcc_assert (expr3_esize);\n       expr3_esize = fold_convert (sizetype, expr3_esize);\n+      if (e3_is == E3_MOLD)\n+\t{\n+\t  /* The expr3 is no longer valid after this point.  */\n+\t  expr3 = NULL_TREE;\n+\t  e3_is = E3_UNSET;\n+\t}\n     }\n   else if (code->ext.alloc.ts.type != BT_UNKNOWN)\n     {\n@@ -5496,7 +5504,11 @@ gfc_trans_allocate (gfc_code * code)\n       else\n \ttmp = expr3_esize;\n       if (!gfc_array_allocate (&se, expr, stat, errmsg, errlen,\n-\t\t\t       label_finish, tmp, &nelems, code->expr3))\n+\t\t\t       label_finish, tmp, &nelems,\n+\t\t\t       e3rhs ? e3rhs : code->expr3,\n+\t\t\t       e3_is == E3_DESC ? expr3 : NULL_TREE,\n+\t\t\t       code->expr3 != NULL && e3_is == E3_DESC\n+\t\t\t       && code->expr3->expr_type == EXPR_ARRAY))\n \t{\n \t  /* A scalar or derived type.  First compute the size to\n \t     allocate.\n@@ -5702,11 +5714,15 @@ gfc_trans_allocate (gfc_code * code)\n \t  if (expr3 != NULL_TREE\n \t      && ((POINTER_TYPE_P (TREE_TYPE (expr3))\n \t\t   && TREE_CODE (expr3) != POINTER_PLUS_EXPR)\n-\t\t  || (VAR_P (expr3) && GFC_CLASS_TYPE_P (TREE_TYPE (expr3))))\n+\t\t  || (VAR_P (expr3) && GFC_CLASS_TYPE_P (\n+\t\t\tTREE_TYPE (expr3))))\n \t      && code->expr3->ts.type == BT_CLASS\n \t      && (expr->ts.type == BT_CLASS\n \t\t  || expr->ts.type == BT_DERIVED))\n \t    {\n+\t      /* copy_class_to_class can be used for class arrays, too.\n+\t\t It just needs to be ensured, that the decl_saved_descriptor\n+\t\t has a way to get to the vptr.  */\n \t      tree to;\n \t      to = VAR_P (se.expr) ? se.expr : TREE_OPERAND (se.expr, 0);\n \t      tmp = gfc_copy_class_to_class (expr3, to,\n@@ -5740,30 +5756,14 @@ gfc_trans_allocate (gfc_code * code)\n \n \t      if (dataref && dataref->u.c.component->as)\n \t\t{\n-\t\t  int dim;\n-\t\t  gfc_expr *temp;\n-\t\t  gfc_ref *ref = dataref->next;\n-\t\t  ref->u.ar.type = AR_SECTION;\n-\t\t  /* We have to set up the array reference to give ranges\n-\t\t     in all dimensions and ensure that the end and stride\n-\t\t     are set so that the copy can be scalarized.  */\n-\t\t  dim = 0;\n-\t\t  for (; dim < dataref->u.c.component->as->rank; dim++)\n-\t\t    {\n-\t\t      ref->u.ar.dimen_type[dim] = DIMEN_RANGE;\n-\t\t      if (ref->u.ar.end[dim] == NULL)\n-\t\t\t{\n-\t\t\t  ref->u.ar.end[dim] = ref->u.ar.start[dim];\n-\t\t\t  temp = gfc_get_int_expr (gfc_default_integer_kind,\n-\t\t\t\t\t\t   &al->expr->where, 1);\n-\t\t\t  ref->u.ar.start[dim] = temp;\n-\t\t\t}\n-\t\t      temp = gfc_subtract (gfc_copy_expr (ref->u.ar.end[dim]),\n-\t\t\t\t\t   gfc_copy_expr (ref->u.ar.start[dim]));\n-\t\t      temp = gfc_add (gfc_get_int_expr (gfc_default_integer_kind,\n-\t\t\t\t\t\t\t&al->expr->where, 1),\n-\t\t\t\t      temp);\n-\t\t    }\n+\t\t  gfc_array_spec *as = dataref->u.c.component->as;\n+\t\t  gfc_free_ref_list (dataref->next);\n+\t\t  dataref->next = NULL;\n+\t\t  gfc_add_full_array_ref (last_arg->expr, as);\n+\t\t  gfc_resolve_expr (last_arg->expr);\n+\t\t  gcc_assert (last_arg->expr->ts.type == BT_CLASS\n+\t\t\t      || last_arg->expr->ts.type == BT_DERIVED);\n+\t\t  last_arg->expr->ts.type = BT_CLASS;\n \t\t}\n \t      if (rhs->ts.type == BT_CLASS)\n \t\t{\n@@ -5845,7 +5845,7 @@ gfc_trans_allocate (gfc_code * code)\n \t  gfc_add_expr_to_block (&block, tmp);\n \t}\n      else if (code->expr3 && code->expr3->mold\n-\t    && code->expr3->ts.type == BT_CLASS)\n+\t      && code->expr3->ts.type == BT_CLASS)\n \t{\n \t  /* Since the _vptr has already been assigned to the allocate\n \t     object, we can use gfc_copy_class_to_class in its"}, {"sha": "0d574821068a0f12a9cb764fa715aba25f1d9fce", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1792349b0bd2702c642bb4f57686ecf32810810f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1792349b0bd2702c642bb4f57686ecf32810810f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=1792349b0bd2702c642bb4f57686ecf32810810f", "patch": "@@ -1,3 +1,13 @@\n+2015-06-15  Andre Vehreschild  <vehre@gmx.de>\n+\n+\tPR fortran/44672\n+\tPR fortran/45440\n+\tPR fortran/57307\n+\t* gfortran.dg/allocate_with_source_3.f90: Removed check for\n+\tunimplemented error.\n+\t* gfortran.dg/allocate_with_source_7.f08: New test.\n+\t* gfortran.dg/allocate_with_source_8.f08: New test.\n+\n 2015-06-13  Patrick Palka  <ppalka@gcc.gnu.org>\n \n \tPR c++/65168"}, {"sha": "93f6edb06d1b463aae5ab9f8ed0415882a7c10d2", "filename": "gcc/testsuite/gfortran.dg/allocate_with_source_3.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1792349b0bd2702c642bb4f57686ecf32810810f/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocate_with_source_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1792349b0bd2702c642bb4f57686ecf32810810f/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocate_with_source_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocate_with_source_3.f90?ref=1792349b0bd2702c642bb4f57686ecf32810810f", "patch": "@@ -21,7 +21,7 @@ end subroutine psub\n   type(cstruct), pointer :: u(:)\n \n ! The following is VALID Fortran 2008 but NOT YET supported \n-  allocate(u, source=[cstruct( 4, [1.1,2.2] ) ]) ! { dg-error \"Array specification required in ALLOCATE statement\" }\n+  allocate(u, source=[cstruct( 4, [1.1,2.2] ) ]) \n   call psub(t, u)\n   deallocate (u)\n "}, {"sha": "86df5319f256de1749f3bedbc95a550a086a5a56", "filename": "gcc/testsuite/gfortran.dg/allocate_with_source_7.f08", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1792349b0bd2702c642bb4f57686ecf32810810f/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocate_with_source_7.f08", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1792349b0bd2702c642bb4f57686ecf32810810f/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocate_with_source_7.f08", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocate_with_source_7.f08?ref=1792349b0bd2702c642bb4f57686ecf32810810f", "patch": "@@ -0,0 +1,79 @@\n+! { dg-do run }\n+!\n+! Check that allocate with source for arrays without array-spec\n+! works.\n+! PR fortran/44672\n+! Contributed by Tobias Burnus  <burnus@gcc.gnu.org>\n+!                Antony Lewis  <antony@cosmologist.info>\n+!                Andre Vehreschild  <vehre@gcc.gnu.org>\n+!\n+\n+program allocate_with_source_6\n+\n+  type P\n+    class(*), allocatable :: X(:,:)\n+  end type\n+\n+  type t\n+  end type t\n+\n+  type(t), allocatable :: a(:), b, c(:)\n+  integer :: num_params_used = 6\n+  integer, allocatable :: m(:)\n+\n+  allocate(b,c(5))\n+  allocate(a(5), source=b)\n+  deallocate(a)\n+  allocate(a, source=c)\n+  allocate(m, source=[(I, I=1, num_params_used)])\n+  if (any(m /= [(I, I=1, num_params_used)])) call abort()\n+  deallocate(a,b,m)\n+  call testArrays()\n+\n+contains\n+  subroutine testArrays()\n+    type L\n+      class(*), allocatable :: v(:)\n+    end type\n+    Type(P) Y\n+    type(L) o\n+    real arr(3,5)\n+    real, allocatable :: v(:)\n+\n+    arr = 5\n+    allocate(Y%X, source=arr)\n+    select type (R => Y%X)\n+      type is (real)\n+        if (any(reshape(R, [15]) /= [5,5,5,5,5, 5,5,5,5,5, 5,5,5,5,5])) &\n+          call abort()\n+      class default\n+        call abort()\n+    end select\n+    deallocate(Y%X)\n+\n+    allocate(Y%X, source=arr(2:3,3:4))\n+    select type (R => Y%X)\n+      type is (real)\n+        if (any(reshape(R, [4]) /= [5,5,5,5])) &\n+          call abort()\n+      class default\n+        call abort()\n+    end select\n+    deallocate(Y%X)\n+\n+    allocate(o%v, source=arr(2,3:4))\n+    select type (R => o%v)\n+      type is (real)\n+        if (any(R /= [5,5])) &\n+          call abort()\n+      class default\n+        call abort()\n+    end select\n+    deallocate(o%v)\n+\n+    allocate(v, source=arr(2,1:5))\n+    if (any(v /= [5,5,5,5,5])) call abort()\n+    deallocate(v)\n+  end subroutine testArrays\n+end\n+"}, {"sha": "b3318669ddfe4e995019e3c194bfcadd09277bdd", "filename": "gcc/testsuite/gfortran.dg/allocate_with_source_8.f08", "status": "added", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1792349b0bd2702c642bb4f57686ecf32810810f/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocate_with_source_8.f08", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1792349b0bd2702c642bb4f57686ecf32810810f/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocate_with_source_8.f08", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocate_with_source_8.f08?ref=1792349b0bd2702c642bb4f57686ecf32810810f", "patch": "@@ -0,0 +1,110 @@\n+! { dg-do run }\n+!\n+! Contributed by Reinhold Bader\n+!\n+program assumed_shape_01\n+  implicit none\n+  type :: cstruct\n+     integer :: i\n+     real :: r(2)\n+  end type cstruct\n+\n+  type(cstruct), pointer :: u(:)\n+  integer, allocatable :: iv(:), iv2(:)\n+  integer, allocatable :: im(:,:)\n+  integer, parameter :: cim(2,3) = reshape([1,2,3, 2,3,4], [2,3])\n+  integer :: i\n+  integer, parameter :: lcim(2,10) = reshape([(i, i=1,10),(i,i=1,10)], [2,10])\n+\n+  allocate(iv, source= [ 1, 2, 3, 4])\n+  if (any(iv /= [ 1, 2, 3, 4])) call abort()\n+  deallocate(iv)\n+\n+  allocate(iv, source=(/(i, i=1,10)/))\n+  if (any(iv /= (/(i, i=1,10)/))) call abort()\n+\n+  ! Now 2D\n+  allocate(im, source= cim)\n+  if (any(im /= cim)) call abort()\n+  deallocate(im)\n+\n+  allocate(im, source= reshape([iv, iv], [2, size(iv, 1)]))\n+  if (any(im /= lcim)) call abort()\n+  deallocate(im)\n+  deallocate(iv)\n+\n+  allocate(u, source=[cstruct( 4, [1.1,2.2] )] )\n+  if (any(u(:)%i /= 4) .or. any(abs(u(1)%r(:) - [1.1,2.2]) > 1E-6)) call abort()\n+  deallocate (u)\n+\n+  allocate(iv, source= arrval())\n+  if (any(iv /= [ 1, 2, 4, 5, 6])) call abort()\n+  ! Check simple array assign\n+  allocate(iv2, source=iv)\n+  if (any(iv2 /= [ 1, 2, 4, 5, 6])) call abort()\n+  deallocate(iv, iv2)\n+\n+  ! Now check for mold=\n+  allocate(iv, mold= [ 1, 2, 3, 4])\n+  if (any(shape(iv) /= [4])) call abort()\n+  deallocate(iv)\n+\n+  allocate(iv, mold=(/(i, i=1,10)/))\n+  if (any(shape(iv) /= [10])) call abort()\n+\n+  ! Now 2D\n+  allocate(im, mold= cim)\n+  if (any(shape(im) /= shape(cim))) call abort()\n+  deallocate(im)\n+\n+  allocate(im, mold= reshape([iv, iv], [2, size(iv, 1)]))\n+  if (any(shape(im) /= shape(lcim))) call abort()\n+  deallocate(im)\n+  deallocate(iv)\n+\n+  allocate(u, mold=[cstruct( 4, [1.1,2.2] )] )\n+  if (any(shape(u(1)%r(:)) /= 2)) call abort()\n+  deallocate (u)\n+\n+  allocate(iv, mold= arrval())\n+  if (any(shape(iv) /= [5])) call abort()\n+  ! Check simple array assign\n+  allocate(iv2, mold=iv)\n+  if (any(shape(iv2) /= [5])) call abort()\n+  deallocate(iv, iv2)\n+\n+  call addData([4, 5])\n+  call addData([\"foo\", \"bar\"])\n+contains\n+  function arrval()\n+    integer, dimension(5) :: arrval\n+    arrval = [ 1, 2, 4, 5, 6]\n+  end function\n+\n+  subroutine addData(P)\n+    class(*), intent(in) :: P(:)\n+    class(*), allocatable :: cP(:)\n+    allocate (cP, source= P)\n+    select type (cP)\n+      type is (integer)\n+        if (any(cP /= [4,5])) call abort()\n+      type is (character(*))\n+        if (len(cP) /= 3) call abort()\n+        if (any(cP /= [\"foo\", \"bar\"])) call abort()\n+      class default\n+        call abort()\n+    end select\n+    deallocate (cP)\n+    allocate (cP, mold= P)\n+    select type (cP)\n+      type is (integer)\n+        if (any(size(cP) /= [2])) call abort()\n+      type is (character(*))\n+        if (len(cP) /= 3) call abort()\n+        if (any(size(cP) /= [2])) call abort()\n+      class default\n+        call abort()\n+    end select\n+    deallocate (cP)\n+  end subroutine\n+end program assumed_shape_01"}]}