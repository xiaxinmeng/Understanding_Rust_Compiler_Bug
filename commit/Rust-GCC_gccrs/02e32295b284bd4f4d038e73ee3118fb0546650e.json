{"sha": "02e32295b284bd4f4d038e73ee3118fb0546650e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDJlMzIyOTViMjg0YmQ0ZjRkMDM4ZTczZWUzMTE4ZmIwNTQ2NjUwZQ==", "commit": {"author": {"name": "Matthias Kretz", "email": "kretz@kde.org", "date": "2021-01-21T11:50:32Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2021-01-27T16:37:26Z"}, "message": "libstdc++: Add simd testsuite\n\nAdd a new check-simd target to the testsuite. The new target creates a\nsubdirectory, generates the necessary Makefiles, and spawns submakes to\nbuild and run the tests. Running this testsuite with defaults on my\nmachine takes half of the time the dejagnu testsuite required to only\ndetermine whether to run tests. Since the simd testsuite integrated in\ndejagnu increased the time of the whole libstdc++ testsuite by ~100%\nthis approach is a compromise for speed while not sacrificing coverage\ntoo much. Since the test driver is invoked individually per test\nexecutable from a Makefile, make's jobserver (-j) trivially parallelizes\ntesting.\n\nTesting different flags and with simulator (or remote execution) is\npossible. E.g. `make check-simd DRIVEROPTS=-q\ntarget_list=\"unix{-m64,-m32}{-march=sandybridge,-march=skylake-avx512}{,-\nffast-math}\"`\nruns the testsuite 8 times in different subdirectories, using 8\ndifferent combinations of compiler flags, only outputs failing tests\n(-q), and prints all summaries at the end. It skips most ABI tags by\ndefault unless --run-expensive is passed to DRIVEROPTS or\nGCC_TEST_RUN_EXPENSIVE is not empty.\n\nTo use a simulator, the CHECK_SIMD_CONFIG variable needs to point to a\nshell script which calls `define_target <name> <flags> <simulator>` and\nset target_list as needed. E.g.:\ncase \"$target_triplet\" in\nx86_64-*)\n  target_list=\"unix{-march=sandybridge,-march=skylake-avx512}\n  ;;\npowerpc64le-*)\n  define_target power8 \"-static -mcpu=power8\" \"/usr/bin/qemu-ppc64le -cpu\npower8\"\n  define_target power9 -mcpu=power9 \"$HOME/bin/run_on_gcc135\"\n  target_list=\"power8 power9{,-ffast-math}\"\n  ;;\nesac\n\nlibstdc++-v3/ChangeLog:\n\n\t* scripts/check_simd: New file. This script is called from the\n\tthe check-simd target. It determines a set of compiler flags and\n\tsimulator setups for calling generate_makefile.sh and passes the\n\tinformation back to the check-simd target, which recurses to the\n\tgenerated Makefiles.\n\t* scripts/create_testsuite_files: Remove files below simd/tests/\n\tfrom testsuite_files and place them in testsuite_files_simd.\n\t* testsuite/Makefile.am: Add testsuite_files_simd. Add\n\tcheck-simd target.\n\t* testsuite/Makefile.in: Regenerate.\n\t* testsuite/experimental/simd/driver.sh: New file. This script\n\tcompiles and runs a given simd test, logging its output and\n\tstatus. It uses the timeout command to implement compile and\n\ttest timeouts.\n\t* testsuite/experimental/simd/generate_makefile.sh: New file.\n\tThis script generates a Makefile which uses driver.sh to compile\n\tand run the tests and collect the logs into a single log file.\n\t* testsuite/experimental/simd/tests/abs.cc: New file. Tests\n\tabs(simd).\n\t* testsuite/experimental/simd/tests/algorithms.cc: New file.\n\tTests min/max(simd, simd).\n\t* testsuite/experimental/simd/tests/bits/conversions.h: New\n\tfile. Contains functions to support tests involving conversions.\n\t* testsuite/experimental/simd/tests/bits/make_vec.h: New file.\n\tSupport functions make_mask and make_vec.\n\t* testsuite/experimental/simd/tests/bits/mathreference.h: New\n\tfile. Support functions to supply precomputed math function\n\treference data.\n\t* testsuite/experimental/simd/tests/bits/metahelpers.h: New\n\tfile. Support code for SFINAE testing.\n\t* testsuite/experimental/simd/tests/bits/simd_view.h: New file.\n\t* testsuite/experimental/simd/tests/bits/test_values.h: New\n\tfile. Test functions to easily drive a test with simd objects\n\tinitialized from a given list of values and a range of random\n\tvalues.\n\t* testsuite/experimental/simd/tests/bits/ulp.h: New file.\n\tSupport code to determine the ULP distance of simd objects.\n\t* testsuite/experimental/simd/tests/bits/verify.h: New file.\n\tTest framework for COMPARE'ing simd objects and instantiating\n\tthe test templates with value_type and ABI tag.\n\t* testsuite/experimental/simd/tests/broadcast.cc: New file. Test\n\tsimd broadcasts.\n\t* testsuite/experimental/simd/tests/casts.cc: New file. Test\n\tsimd casts.\n\t* testsuite/experimental/simd/tests/fpclassify.cc: New file.\n\tTest floating-point classification functions.\n\t* testsuite/experimental/simd/tests/frexp.cc: New file. Test\n\tfrexp(simd).\n\t* testsuite/experimental/simd/tests/generator.cc: New file. Test\n\tsimd generator constructor.\n\t* testsuite/experimental/simd/tests/hypot3_fma.cc: New file.\n\tTest 3-arg hypot(simd,simd,simd) and fma(simd,simd,sim).\n\t* testsuite/experimental/simd/tests/integer_operators.cc: New\n\tfile. Test integer operators.\n\t* testsuite/experimental/simd/tests/ldexp_scalbn_scalbln_modf.cc:\n\tNew file. Test ldexp(simd), scalbn(simd), scalbln(simd), and\n\tmodf(simd).\n\t* testsuite/experimental/simd/tests/loadstore.cc: New file. Test\n\t(converting) simd loads and stores.\n\t* testsuite/experimental/simd/tests/logarithm.cc: New file. Test\n\tlog*(simd).\n\t* testsuite/experimental/simd/tests/mask_broadcast.cc: New file.\n\tTest simd_mask broadcasts.\n\t* testsuite/experimental/simd/tests/mask_conversions.cc: New\n\tfile. Test simd_mask conversions.\n\t* testsuite/experimental/simd/tests/mask_implicit_cvt.cc: New\n\tfile. Test simd_mask implicit conversions.\n\t* testsuite/experimental/simd/tests/mask_loadstore.cc: New file.\n\tTest simd_mask loads and stores.\n\t* testsuite/experimental/simd/tests/mask_operator_cvt.cc: New\n\tfile. Test simd_mask operators convert as specified.\n\t* testsuite/experimental/simd/tests/mask_operators.cc: New file.\n\tTest simd_mask compares, subscripts, and negation.\n\t* testsuite/experimental/simd/tests/mask_reductions.cc: New\n\tfile. Test simd_mask reductions.\n\t* testsuite/experimental/simd/tests/math_1arg.cc: New file. Test\n\t1-arg math functions on simd.\n\t* testsuite/experimental/simd/tests/math_2arg.cc: New file. Test\n\t2-arg math functions on simd.\n\t* testsuite/experimental/simd/tests/operator_cvt.cc: New file.\n\tTest implicit conversions on simd binary operators behave as\n\tspecified.\n\t* testsuite/experimental/simd/tests/operators.cc: New file. Test\n\tsimd compares, subscripts, not, unary minus, plus, minus,\n\tmultiplies, divides, increment, and decrement.\n\t* testsuite/experimental/simd/tests/reductions.cc: New file.\n\tTest reduce(simd).\n\t* testsuite/experimental/simd/tests/remqo.cc: New file. Test\n\tremqo(simd).\n\t* testsuite/experimental/simd/tests/simd.cc: New file. Basic\n\tsanity checks of simd types.\n\t* testsuite/experimental/simd/tests/sincos.cc: New file. Test\n\tsin(simd) and cos(simd).\n\t* testsuite/experimental/simd/tests/split_concat.cc: New file.\n\tTest split(simd) and concat(simd, simd).\n\t* testsuite/experimental/simd/tests/splits.cc: New file. Test\n\tsplit(simd_mask).\n\t* testsuite/experimental/simd/tests/trigonometric.cc: New file.\n\tTest remaining trigonometric functions on simd.\n\t* testsuite/experimental/simd/tests/trunc_ceil_floor.cc: New\n\tfile. Test trunc(simd), ceil(simd), and floor(simd).\n\t* testsuite/experimental/simd/tests/where.cc: New file. Test\n\tmasked operations using where.", "tree": {"sha": "80f839a9a0e588147cc0da774345a44b4890f25a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/80f839a9a0e588147cc0da774345a44b4890f25a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/02e32295b284bd4f4d038e73ee3118fb0546650e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02e32295b284bd4f4d038e73ee3118fb0546650e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/02e32295b284bd4f4d038e73ee3118fb0546650e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02e32295b284bd4f4d038e73ee3118fb0546650e/comments", "author": {"login": "mattkretz", "id": 3306474, "node_id": "MDQ6VXNlcjMzMDY0NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3306474?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mattkretz", "html_url": "https://github.com/mattkretz", "followers_url": "https://api.github.com/users/mattkretz/followers", "following_url": "https://api.github.com/users/mattkretz/following{/other_user}", "gists_url": "https://api.github.com/users/mattkretz/gists{/gist_id}", "starred_url": "https://api.github.com/users/mattkretz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mattkretz/subscriptions", "organizations_url": "https://api.github.com/users/mattkretz/orgs", "repos_url": "https://api.github.com/users/mattkretz/repos", "events_url": "https://api.github.com/users/mattkretz/events{/privacy}", "received_events_url": "https://api.github.com/users/mattkretz/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2bcceb6fc59fcdaf51006d4fcfc71c2d26761396", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2bcceb6fc59fcdaf51006d4fcfc71c2d26761396", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2bcceb6fc59fcdaf51006d4fcfc71c2d26761396"}], "stats": {"total": 6751, "additions": 6746, "deletions": 5}, "files": [{"sha": "25acf64c841718df87848f8d74f2f55b4f50aba6", "filename": "libstdc++-v3/scripts/check_simd", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02e32295b284bd4f4d038e73ee3118fb0546650e/libstdc%2B%2B-v3%2Fscripts%2Fcheck_simd", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02e32295b284bd4f4d038e73ee3118fb0546650e/libstdc%2B%2B-v3%2Fscripts%2Fcheck_simd", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fscripts%2Fcheck_simd?ref=02e32295b284bd4f4d038e73ee3118fb0546650e", "patch": "@@ -0,0 +1,75 @@\n+#!/bin/sh\n+\n+# check_simd <srcdir> <builddir> <CXXFLAGS>\n+# Read config from $CHECK_SIMD_CONFIG file or $target_list\n+\n+scriptdir=\"$(cd \"${0%/*}\" && pwd)\"\n+srcdir=\"$1\"\n+builddir=\"$2\"\n+shift 2\n+testdir=\"$builddir/testsuite\"\n+\n+CXX=\"$(\"$builddir/scripts/testsuite_flags\" --build-cxx)\"\n+CXXFLAGS=\"$(\"$builddir/scripts/testsuite_flags\" --cxxflags) $1 -Wno-psabi\"\n+shift\n+INCLUDES=\"$(\"$builddir/scripts/testsuite_flags\" --build-includes)\"\n+\n+target_triplet=$($CXX -dumpmachine)\n+\n+define_target() {\n+  name=\"$1\"\n+  flags=\"$2\"\n+  sim=\"$3\"\n+  eval \"$name=\\\"flags=\\\\\\\"$flags\\\\\\\"\n+sim=\\\\\\\"$sim\\\\\\\"\\\"\"\n+}\n+\n+if [ -f \"$CHECK_SIMD_CONFIG\" ]; then\n+  . \"$CHECK_SIMD_CONFIG\"\n+elif [ -z \"$CHECK_SIMD_CONFIG\" ]; then\n+  if [ -z \"$target_list\" ]; then\n+    target_list=\"unix\"\n+    case \"$target_triplet\" in\n+      x86_64-*)      target_list=\"unix/-march=native\" ;;\n+      i?86-*)        target_list=\"unix/-march=native\" ;;\n+      powerpc64le-*) target_list=\"unix/-mcpu=power8\" ;;\n+      aarch64-*)     target_list=\"unix/-mcpu=cortex-a53\" ;;\n+      arm-*)         target_list=\"unix/-mcpu=cortex-a7\" ;;\n+    esac\n+  fi\n+else\n+  echo \"Error: File not found: \\$CHECK_SIMD_CONFIG='$CHECK_SIMD_CONFIG'\" 1>&2\n+  exit 1\n+fi\n+\n+# define unix with no flags and no simulator:\n+define_target unix\n+\n+list=\"$target_list\"\n+\n+# expand a{b,c} to a/b a/c\n+while [ \"${list#*\\{}\" != \"${list}\" ]; do\n+  list=\"$(echo \"$list\" | \\\n+    sed -e 's#\\([^ ]\\+\\){\\([^{},]*\\),\\([^{}]*\\)}\\(/[^ ]*\\)\\?#\\1/\\2\\4 \\1{\\3}\\4#g' \\\n+        -e 's#{\\([^{},]*\\)}#/\\1#g' \\\n+        -e 's#/ # #g' -e 's#/$##')\"\n+done\n+\n+# per a/b/c block extract flags and simulator, then make check-simd\n+while [ ${#list} -gt 0 ]; do\n+  a=\"${list%% *}\"\n+  if [ \"$a\" = \"$list\" ]; then\n+    list=\"\"\n+  else\n+    list=\"${list#${a} }\"\n+  fi\n+  b=\"${a%%/*}\"\n+  eval \"eval \\\"\\$$b\\\"\"\n+  flags=\"${flags}$(echo \"${a#${b}}\"|sed 's#/# #g')\"\n+  subdir=\"simd/$(echo \"$flags\" | sed 's#[= /-]##g')\"\n+  rm -f \"${subdir}/Makefile\"\n+  $srcdir/testsuite/experimental/simd/generate_makefile.sh \\\n+    --destination=\"$testdir/$subdir\" --sim=\"$sim\" --testflags=\"$flags\" \\\n+    $CXX $INCLUDES $CXXFLAGS -static-libgcc -static-libstdc++\n+  echo \"$subdir\"\n+done"}, {"sha": "174c24ec05a4deda6c5adf177b0487a9dcd56875", "filename": "libstdc++-v3/scripts/create_testsuite_files", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02e32295b284bd4f4d038e73ee3118fb0546650e/libstdc%2B%2B-v3%2Fscripts%2Fcreate_testsuite_files", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02e32295b284bd4f4d038e73ee3118fb0546650e/libstdc%2B%2B-v3%2Fscripts%2Fcreate_testsuite_files", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fscripts%2Fcreate_testsuite_files?ref=02e32295b284bd4f4d038e73ee3118fb0546650e", "patch": "@@ -27,6 +27,7 @@ tmp=\"${TMPDIR:-/tmp}/ctt$$\"\n tests_file_normal=\"$outdir/testsuite_files\"\n tests_file_inter=\"$outdir/testsuite_files_interactive\"\n tests_file_perf=\"$outdir/testsuite_files_performance\"\n+tests_file_simd=\"$outdir/testsuite_files_simd\"\n \n cd $srcdir\n # This is the ugly version of \"everything but the current directory\".  It's\n@@ -49,8 +50,11 @@ grep -v _xin $tmp.1 > $tmp.4\n grep performance $tmp.4 > $tests_file_perf\n grep -v performance $tmp.4 > $tmp.5\n \n+grep simd/tests/ $tmp.5 > $tests_file_simd\n+grep -v simd/tests/ $tmp.5 > $tmp.6\n+\n # ...more filters go here.\n-cp $tmp.5 $tests_file_normal\n+cp $tmp.6 $tests_file_normal\n \n rm $tmp*\n exit 0"}, {"sha": "5dd109b40c9d76806d7113f3d24c5ce578a8068c", "filename": "libstdc++-v3/testsuite/Makefile.am", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02e32295b284bd4f4d038e73ee3118fb0546650e/libstdc%2B%2B-v3%2Ftestsuite%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02e32295b284bd4f4d038e73ee3118fb0546650e/libstdc%2B%2B-v3%2Ftestsuite%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2FMakefile.am?ref=02e32295b284bd4f4d038e73ee3118fb0546650e", "patch": "@@ -31,7 +31,8 @@ include $(top_srcdir)/fragment.am\n lists_of_files = \\\n    testsuite_files \\\n    testsuite_files_interactive \\\n-   testsuite_files_performance\n+   testsuite_files_performance \\\n+   testsuite_files_simd\n \n # This rule generates all of the testsuite_files* lists at once.\n ${lists_of_files}:\n@@ -185,6 +186,19 @@ check-performance: testsuite_files_performance ${performance_script}\n \t  CXXFLAGS='$(CXXFLAGS)'; export CXXFLAGS; \\\n \t  ${check_performance_script} ${glibcxx_srcdir} ${glibcxx_builddir})\n \n+# Runs the simd tests.\n+check-simd: $(srcdir)/experimental/simd/generate_makefile.sh \\\n+\t    ${glibcxx_srcdir}/scripts/check_simd \\\n+\t    testsuite_files_simd \\\n+\t    ${glibcxx_builddir}/scripts/testsuite_flags\n+\t${glibcxx_srcdir}/scripts/check_simd \"${glibcxx_srcdir}\" \"${glibcxx_builddir}\" \"$(CXXFLAGS)\" | \\\n+\t  while read subdir; do \\\n+\t    $(MAKE) -C \"$${subdir}\"; \\\n+\t    tail -n20 $${subdir}/simd_testsuite.sum | \\\n+\t      grep -A20 -B1 'Summary ===' >> .simd.summary; \\\n+\t  done; \\\n+\t  cat .simd.summary && rm .simd.summary\n+\n # Runs the testsuite in debug mode.\n debug_flags = \"unix/-D_GLIBCXX_DEBUG\"\n \n@@ -234,4 +248,4 @@ CLEANFILES = *.txt *.tst *.exe core* filebuf_* tmp* ostream_* *.log *.sum \\\n \n # To remove directories.\n clean-local:\n-\trm -rf de fr debug parallel binaries normal*\n+\trm -rf de fr debug parallel binaries normal* simd"}, {"sha": "3900d6d87b4f8bd331fdb4355fc1ae75c9e3282c", "filename": "libstdc++-v3/testsuite/Makefile.in", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02e32295b284bd4f4d038e73ee3118fb0546650e/libstdc%2B%2B-v3%2Ftestsuite%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02e32295b284bd4f4d038e73ee3118fb0546650e/libstdc%2B%2B-v3%2Ftestsuite%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2FMakefile.in?ref=02e32295b284bd4f4d038e73ee3118fb0546650e", "patch": "@@ -380,7 +380,8 @@ AM_CPPFLAGS = $(GLIBCXX_INCLUDES) $(CPPFLAGS)\n lists_of_files = \\\n    testsuite_files \\\n    testsuite_files_interactive \\\n-   testsuite_files_performance\n+   testsuite_files_performance \\\n+   testsuite_files_simd\n \n extract_symvers = $(glibcxx_builddir)/scripts/extract_symvers\n baseline_subdir := $(shell $(CXX) $(baseline_subdir_switch))\n@@ -710,6 +711,19 @@ check-performance: testsuite_files_performance ${performance_script}\n \t  CXXFLAGS='$(CXXFLAGS)'; export CXXFLAGS; \\\n \t  ${check_performance_script} ${glibcxx_srcdir} ${glibcxx_builddir})\n \n+# Runs the simd tests.\n+check-simd: $(srcdir)/experimental/simd/generate_makefile.sh \\\n+\t    ${glibcxx_srcdir}/scripts/check_simd \\\n+\t    testsuite_files_simd \\\n+\t    ${glibcxx_builddir}/scripts/testsuite_flags\n+\t${glibcxx_srcdir}/scripts/check_simd \"${glibcxx_srcdir}\" \"${glibcxx_builddir}\" \"$(CXXFLAGS)\" | \\\n+\t  while read subdir; do \\\n+\t    $(MAKE) -C \"$${subdir}\"; \\\n+\t    tail -n20 $${subdir}/simd_testsuite.sum | \\\n+\t      grep -A20 -B1 'Summary ===' >> .simd.summary; \\\n+\t  done; \\\n+\t  cat .simd.summary && rm .simd.summary\n+\n check-debug: site.exp\n \toutputdir=debug; export outputdir; \\\n \tif test ! -d $${outputdir}; then \\\n@@ -742,7 +756,7 @@ check-performance-parallel: testsuite_files_performance ${performance_script}\n \n # To remove directories.\n clean-local:\n-\trm -rf de fr debug parallel binaries normal*\n+\trm -rf de fr debug parallel binaries normal* simd\n \n # Tell versions [3.59,3.63) of GNU make to not export all variables.\n # Otherwise a system limit (for SysV at least) may be exceeded."}, {"sha": "aabef316f476576e32b0d42f31b7571230fe1cc6", "filename": "libstdc++-v3/testsuite/experimental/simd/driver.sh", "status": "added", "additions": 249, "deletions": 0, "changes": 249, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02e32295b284bd4f4d038e73ee3118fb0546650e/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fsimd%2Fdriver.sh", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02e32295b284bd4f4d038e73ee3118fb0546650e/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fsimd%2Fdriver.sh", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fsimd%2Fdriver.sh?ref=02e32295b284bd4f4d038e73ee3118fb0546650e", "patch": "@@ -0,0 +1,249 @@\n+#!/bin/sh\n+\n+type=float\n+abi=0\n+name=\n+srcdir=\"$(cd \"${0%/*}\" && pwd)/tests\"\n+sim=\"$GCC_TEST_SIMULATOR\"\n+quiet=false\n+verbose=false\n+timeout=180\n+run_expensive=false\n+if [ -n \"$GCC_TEST_RUN_EXPENSIVE\" ]; then\n+  run_expensive=true\n+fi\n+keep_failed=false\n+only=\n+\n+usage() {\n+  cat <<EOF\n+Usage: $0 [Options] <g++ invocation>\n+\n+Options:\n+  -h, --help          Print this message and exit.\n+  -q, --quiet         Only print failures.\n+  -v, --verbose       Print compiler and test output on failure.\n+  -t <type>, --type <type>\n+                      The value_type to test (default: $type).\n+  -a [0-9], --abi [0-9]\n+                      The ABI tag subset to test (default: $abi).\n+  -n <name>, --name <name>\n+                      The name of the test (required).\n+  -k, --keep-failed   Keep executables of failed tests.\n+  --srcdir <path>     The source directory of the tests (default: $srcdir).\n+  --sim <executable>  Path to an executable that is prepended to the test\n+                      execution binary (default: the value of\n+                      GCC_TEST_SIMULATOR).\n+  --timeout-factor <x>\n+                      Multiply the default timeout with x.\n+  --run-expensive     Compile and run tests marked as expensive (default:\n+                      true if GCC_TEST_RUN_EXPENSIVE is set, false otherwise).\n+  --only <pattern>    Compile and run only tests matching the given pattern.\n+EOF\n+}\n+\n+while [ $# -gt 0 ]; do\n+  case \"$1\" in\n+  -h|--help)\n+    usage\n+    exit\n+    ;;\n+  -q|--quiet)\n+    quiet=true\n+    ;;\n+  -v|--verbose)\n+    verbose=true\n+    ;;\n+  --run-expensive)\n+    run_expensive=true\n+    ;;\n+  -k|--keep-failed)\n+    keep_failed=true\n+    ;;\n+  --only)\n+    only=\"$2\"\n+    shift\n+    ;;\n+  --only=*)\n+    only=\"${1#--only=}\"\n+    ;;\n+  -t|--type)\n+    type=\"$2\"\n+    shift\n+    ;;\n+  --type=*)\n+    type=\"${1#--type=}\"\n+    ;;\n+  -a|--abi)\n+    abi=\"$2\"\n+    shift\n+    ;;\n+  --abi=*)\n+    abi=\"${1#--abi=}\"\n+    ;;\n+  -n|--name)\n+    name=\"$2\"\n+    shift\n+    ;;\n+  --name=*)\n+    name=\"${1#--name=}\"\n+    ;;\n+  --srcdir)\n+    srcdir=\"$2\"\n+    shift\n+    ;;\n+  --srcdir=*)\n+    srcdir=\"${1#--srcdir=}\"\n+    ;;\n+  --sim)\n+    sim=\"$2\"\n+    shift\n+    ;;\n+  --sim=*)\n+    sim=\"${1#--sim=}\"\n+    ;;\n+  --timeout-factor)\n+    timeout=$(awk \"BEGIN { print int($timeout * $2) }\")\n+    shift\n+    ;;\n+  --timeout-factor=*)\n+    x=${1#--timeout-factor=}\n+    timeout=$(awk \"BEGIN { print int($timeout * $x) }\")\n+    ;;\n+  --)\n+    shift\n+    break\n+    ;;\n+  *)\n+    break\n+    ;;\n+  esac\n+  shift\n+done\n+\n+CXX=\"$1\"\n+shift\n+CXXFLAGS=\"$@\"\n+src=\"${srcdir}/${name}.cc\"\n+shorttype=$(echo $type|sed -e 's/long /l/' -e 's/unsigned /u/' -e 's/signed /s/')\n+testname=\"${name}-${shorttype}-${abi}\"\n+exe=\"${testname}.exe\"\n+log=\"${testname}.log\"\n+sum=\"${testname}.sum\"\n+if [ -n \"$only\" ]; then\n+  if echo \"$testname\"|awk \"{ exit /$only/ }\"; then\n+    touch \"$log\" \"$sum\"\n+    exit 0\n+  fi\n+fi\n+\n+if [ $abi -eq 0 ]; then\n+  abi=\"\"\n+elif [ $abi -gt 0 -a $abi -lt 10 ]; then\n+  abi=\"-DEXTENDEDTESTS=$((abi-1))\"\n+else\n+  echo \"Error: The -a argument must be a value between 0 and 9 (inclusive).\" >&2\n+  exit 1\n+fi\n+\n+fail() {\n+  echo \"FAIL: $src $type $abi ($*)\" | tee -a \"$sum\" \"$log\"\n+}\n+\n+pass() {\n+  $quiet || echo \"PASS: $src $type $abi ($*)\"\n+  echo \"PASS: $src $type $abi ($*)\" >> \"$sum\"\n+  echo \"PASS: $src $type $abi ($*)\" >> \"$log\"\n+}\n+\n+unsupported() {\n+  $quiet || echo \"UNSUPPORTED: $src $type $abi ($*)\"\n+  echo \"UNSUPPORTED: $src $type $abi ($*)\" >> \"$sum\"\n+  echo \"UNSUPPORTED: $src $type $abi ($*)\" >> \"$log\"\n+}\n+\n+verify_compilation() {\n+  failed=$1\n+  if [ $failed -eq 0 ]; then\n+    warnings=$(grep -ic 'warning:' \"$log\")\n+    if [ $warnings -gt 0 ]; then\n+      fail \"excess warnings:\" $warnings\n+      if $verbose; then\n+        cat \"$log\"\n+      elif ! $quiet; then\n+        grep -i 'warning:' \"$log\" | head -n5\n+      fi\n+    else\n+      pass \"test for excess errors\"\n+    fi\n+  else\n+    if [ $failed -eq 124 ]; then\n+      fail \"timeout: test for excess errors\"\n+    else\n+      errors=$(grep -ic 'error:' \"$log\")\n+      fail \"excess errors:\" $errors\n+    fi\n+    if $verbose; then\n+      cat \"$log\"\n+    elif ! $quiet; then\n+      grep -i 'error:' \"$log\" | head -n5\n+    fi\n+    exit 0\n+  fi\n+}\n+\n+verify_test() {\n+  failed=$1\n+  if [ $failed -eq 0 ]; then\n+    rm \"$exe\"\n+    pass \"execution test\"\n+  else\n+    $keep_failed || rm \"$exe\"\n+    if [ $failed -eq 124 ]; then\n+      fail \"timeout: execution test\"\n+    else\n+      fail \"execution test\"\n+    fi\n+    if $verbose; then\n+      if [ $(cat \"$log\"|wc -l) -gt 1000 ]; then\n+        echo \"[...]\"\n+        tail -n1000 \"$log\"\n+      else\n+        cat \"$log\"\n+      fi\n+    elif ! $quiet; then\n+      grep -i fail \"$log\" | head -n5\n+    fi\n+    exit 0\n+  fi\n+}\n+\n+write_log_and_verbose() {\n+  echo \"$*\" >> \"$log\"\n+  if $verbose; then\n+    echo \"$*\"\n+  fi\n+}\n+\n+rm -f \"$log\" \"$sum\"\n+touch \"$log\" \"$sum\"\n+\n+if ! $run_expensive && [ -n \"$abi\" ]; then\n+  unsupported \"skip expensive tests\"\n+  exit 0\n+fi\n+\n+write_log_and_verbose \"$CXX $src $@ -D_GLIBCXX_SIMD_TESTTYPE=$type $abi -o $exe\"\n+timeout $timeout \"$CXX\" \"$src\" \"$@\" \"-D_GLIBCXX_SIMD_TESTTYPE=$type\" $abi -o \"$exe\" >> \"$log\" 2>&1\n+verify_compilation $?\n+if [ -n \"$sim\" ]; then\n+  write_log_and_verbose \"$sim ./$exe\"\n+  timeout $timeout $sim \"./$exe\" >> \"$log\" 2>&1 <&-\n+else\n+  write_log_and_verbose \"./$exe\"\n+  timeout=$(awk \"BEGIN { print int($timeout / 2) }\")\n+  timeout $timeout \"./$exe\" >> \"$log\" 2>&1 <&-\n+fi\n+verify_test $?\n+\n+# vim: sw=2 et cc=81 si"}, {"sha": "85a7f87271e0655765612f7c34eeb058ec71f03a", "filename": "libstdc++-v3/testsuite/experimental/simd/generate_makefile.sh", "status": "added", "additions": 261, "deletions": 0, "changes": 261, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02e32295b284bd4f4d038e73ee3118fb0546650e/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fsimd%2Fgenerate_makefile.sh", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02e32295b284bd4f4d038e73ee3118fb0546650e/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fsimd%2Fgenerate_makefile.sh", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fsimd%2Fgenerate_makefile.sh?ref=02e32295b284bd4f4d038e73ee3118fb0546650e", "patch": "@@ -0,0 +1,261 @@\n+#!/bin/sh\n+\n+srcdir=\"$(cd \"${0%/*}\" && pwd)\"\n+driver=\"$srcdir/driver.sh\"\n+srcdir=\"$srcdir/tests\"\n+sim=\n+rm_logs=true\n+dst=.\n+testflags=\n+\n+usage() {\n+  cat <<EOF\n+Usage: $0 [Options] <g++ invocation>\n+\n+Options:\n+  -h, --help          Print this message and exit.\n+  --srcdir <path>     The source directory of the tests (default: $srcdir).\n+  --sim <executable>  Path to an executable that is prepended to the test\n+                      execution binary (default: none).\n+  --keep-intermediate-logs\n+                      Keep intermediate logs.\n+  --testflags <flags> Force initial TESTFLAGS contents.\n+  -d <path>, --destination <path>\n+                      Destination for the generated Makefile. If the directory\n+                      does not exist it is created (default: $dst).\n+EOF\n+}\n+\n+while [ $# -gt 0 ]; do\n+  case \"$1\" in\n+  -h|--help)\n+    usage\n+    exit\n+    ;;\n+  --testflags)\n+    testflags=\"$2\"\n+    shift\n+    ;;\n+  --testflags=*)\n+    testflags=\"${1#--testflags=}\"\n+    ;;\n+  -d|--destination)\n+    dst=\"$2\"\n+    shift\n+    ;;\n+  --destination=*)\n+    dst=\"${1#--destination=}\"\n+    ;;\n+  --keep-intermediate-logs)\n+    rm_logs=false\n+    ;;\n+  --srcdir)\n+    srcdir=\"$2\"\n+    shift\n+    ;;\n+  --srcdir=*)\n+    srcdir=\"${1#--srcdir=}\"\n+    ;;\n+  --sim)\n+    sim=\"$2\"\n+    shift\n+    ;;\n+  --sim=*)\n+    sim=\"${1#--sim=}\"\n+    ;;\n+  --)\n+    shift\n+    break\n+    ;;\n+  *)\n+    break\n+    ;;\n+  esac\n+  shift\n+done\n+\n+mkdir -p \"$dst\"\n+dst=\"$dst/Makefile\"\n+if [ -f \"$dst\" ]; then\n+  echo \"Error: $dst already exists. Aborting.\" 1>&2\n+  exit 1\n+fi\n+\n+CXX=\"$1\"\n+shift\n+\n+echo \"TESTFLAGS ?=\" > \"$dst\"\n+[ -n \"$testflags\" ] && echo \"TESTFLAGS := $testflags \\$(TESTFLAGS)\" >> \"$dst\"\n+echo CXXFLAGS = \"$@\" \"\\$(TESTFLAGS)\" >> \"$dst\"\n+[ -n \"$sim\" ] && echo \"export GCC_TEST_SIMULATOR = $sim\" >> \"$dst\"\n+cat >> \"$dst\" <<EOF\n+srcdir = ${srcdir}\n+CXX = ${CXX}\n+DRIVER = ${driver}\n+DRIVEROPTS ?=\n+\n+all: simd_testsuite.sum\n+\n+simd_testsuite.sum: simd_testsuite.log\n+\t@echo \"\\n\\t\\t=== simd_testsuite \\$(TESTFLAGS) Summary ===\\n\\n\"\\\\\n+\t\"# of expected passes:\\t\\t\\$(shell grep -c '^PASS:' \\$@)\\n\"\\\\\n+\t\"# of unexpected failures:\\t\\$(shell grep -c '^FAIL:' \\$@)\\n\"\\\\\n+\t\"# of unsupported tests:\\t\\t\\$(shell grep -c '^UNSUPPORTED:' \\$@)\"\\\\\n+\t  | tee -a \\$@\n+\n+EOF\n+\n+all_types() {\n+  src=\"$1\"\n+  cat <<EOF\n+long double\n+ldouble\n+double\n+double\n+float\n+float\n+EOF\n+  ([ -n \"$src\" ] && grep -q \"test only floattypes\" \"$src\") || \\\n+  cat <<EOF\n+long long\n+llong\n+unsigned long long\n+ullong\n+unsigned long\n+ulong\n+long\n+long\n+int\n+int\n+unsigned int\n+uint\n+short\n+short\n+unsigned short\n+ushort\n+char\n+char\n+signed char\n+schar\n+unsigned char\n+uchar\n+char32_t\n+char32_t\n+char16_t\n+char16_t\n+wchar_t\n+wchar_t\n+EOF\n+}\n+\n+all_tests() {\n+  if [ -f testsuite_files_simd ]; then\n+    sed 's,^experimental/simd/tests/,,' testsuite_files_simd | while read file; do\n+      echo \"$srcdir/$file\"\n+      echo \"${file%.cc}\"\n+    done\n+  else\n+    for file in ${srcdir}/*.cc; do\n+      echo \"$file\"\n+      name=\"${file%.cc}\"\n+      echo \"${name##*/}\"\n+    done\n+  fi\n+}\n+\n+{\n+  rmline=\"\"\n+  if $rm_logs; then\n+    rmline=\"\n+\t@rm \\$^ \\$(^:log=sum)\"\n+  fi\n+  echo -n \"simd_testsuite.log:\"\n+  all_tests | while read file && read name; do\n+    echo -n \" $name.log\"\n+  done\n+  cat <<EOF\n+\n+\t@cat $^ > \\$@\n+\t@cat \\$(^:log=sum) > \\$(@:log=sum)${rmline}\n+\n+EOF\n+  all_tests | while read file && read name; do\n+    echo -n \"$name.log:\"\n+    all_types \"$file\" | while read t && read type; do\n+      echo -n \" $name-$type.log\"\n+    done\n+    cat <<EOF\n+\n+\t@cat $^ > \\$@\n+\t@cat \\$(^:log=sum) > \\$(@:log=sum)${rmline}\n+\n+EOF\n+  done\n+  all_types | while read t && read type; do\n+    cat <<EOF\n+%-$type.log: %-$type-0.log %-$type-1.log %-$type-2.log %-$type-3.log \\\n+%-$type-4.log %-$type-5.log %-$type-6.log %-$type-7.log \\\n+%-$type-8.log %-$type-9.log\n+\t@cat $^ > \\$@\n+\t@cat \\$(^:log=sum) > \\$(@:log=sum)${rmline}\n+\n+EOF\n+    for i in $(seq 0 9); do\n+      cat <<EOF\n+%-$type-$i.log: \\$(srcdir)/%.cc\n+\t@\\$(DRIVER) \\$(DRIVEROPTS) -t \"$t\" -a $i -n \\$* \\$(CXX) \\$(CXXFLAGS)\n+\n+EOF\n+    done\n+  done\n+  echo 'run-%: export GCC_TEST_RUN_EXPENSIVE=yes\\n'\n+  all_tests | while read file && read name; do\n+    echo \"run-$name: $name.log\"\n+    all_types \"$file\" | while read t && read type; do\n+      echo \"run-$name-$type: $name-$type.log\"\n+      for i in $(seq 0 9); do\n+        echo \"run-$name-$type-$i: $name-$type-$i.log\"\n+      done\n+    done\n+    echo\n+  done\n+  cat <<EOF\n+help:\n+\t@echo \"use DRIVEROPTS=<options> to pass the following options:\\n\"\\\\\n+\t\"-q, --quiet         Only print failures.\\n\"\\\\\n+\t\"-v, --verbose       Print compiler and test output on failure.\\n\"\\\\\n+\t\"-k, --keep-failed   Keep executables of failed tests.\\n\"\\\\\n+\t\"--sim <executable>  Path to an executable that is prepended to the test\\n\"\\\\\n+\t\"                    execution binary (default: the value of\\n\"\\\\\n+\t\"                    GCC_TEST_SIMULATOR).\\n\"\\\\\n+\t\"--timeout-factor <x>\\n\"\\\\\n+\t\"                    Multiply the default timeout with x.\\n\"\\\\\n+\t\"--run-expensive     Compile and run tests marked as expensive (default:\\n\"\\\\\n+\t\"                    true if GCC_TEST_RUN_EXPENSIVE is set, false otherwise).\\n\"\\\\\n+\t\"--only <pattern>    Compile and run only tests matching the given pattern.\\n\"\n+\t@echo \"use TESTFLAGS=<flags> to pass additional compiler flags\\n\"\n+\t@echo \"The following are some of the valid targets for this Makefile:\"\n+\t@echo \"... all\"\n+\t@echo \"... clean\"\n+\t@echo \"... help\"\n+EOF\n+  all_tests | while read file && read name; do\n+    echo \"\\t@echo '... run-${name}'\"\n+    all_types | while read t && read type; do\n+      echo \"\\t@echo '... run-${name}-${type}'\"\n+      for i in $(seq 0 9); do\n+        echo \"\\t@echo '... run-${name}-${type}-$i'\"\n+      done\n+    done\n+  done\n+  cat <<EOF\n+\n+clean:\n+\trm -f -- *.sum *.log *.exe\n+\n+.PHONY: clean help\n+\n+.PRECIOUS: %.log %.sum\n+EOF\n+} >> \"$dst\"\n+"}, {"sha": "7d94cf47e1c41d891f544169378cdd2aac7d9719", "filename": "libstdc++-v3/testsuite/experimental/simd/tests/abs.cc", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02e32295b284bd4f4d038e73ee3118fb0546650e/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fsimd%2Ftests%2Fabs.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02e32295b284bd4f4d038e73ee3118fb0546650e/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fsimd%2Ftests%2Fabs.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fsimd%2Ftests%2Fabs.cc?ref=02e32295b284bd4f4d038e73ee3118fb0546650e", "patch": "@@ -0,0 +1,41 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"bits/verify.h\"\n+#include \"bits/metahelpers.h\"\n+#include <cmath>    // abs & sqrt\n+#include <cstdlib>  // integer abs\n+#include \"bits/test_values.h\"\n+\n+template <typename V>\n+  void\n+  test()\n+  {\n+    if constexpr (std::is_signed_v<typename V::value_type>)\n+      {\n+\tusing std::abs;\n+\tusing T = typename V::value_type;\n+\ttest_values<V>({std::__finite_max_v<T>, std::__norm_min_v<T>,\n+\t\t\t-std::__norm_min_v<T>, std::__finite_min_v<T>,\n+\t\t\tstd::__finite_min_v<T> / 2, T(), -T(), T(-1), T(-2)},\n+\t\t       {1000}, [](V input) {\n+\t\t\t const V expected(\n+\t\t\t   [&](auto i) { return T(std::abs(T(input[i]))); });\n+\t\t\t COMPARE(abs(input), expected) << \"input: \" << input;\n+\t\t       });\n+      }\n+  }"}, {"sha": "78bce35f59c128748cd9116f993d94e365546020", "filename": "libstdc++-v3/testsuite/experimental/simd/tests/algorithms.cc", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02e32295b284bd4f4d038e73ee3118fb0546650e/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fsimd%2Ftests%2Falgorithms.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02e32295b284bd4f4d038e73ee3118fb0546650e/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fsimd%2Ftests%2Falgorithms.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fsimd%2Ftests%2Falgorithms.cc?ref=02e32295b284bd4f4d038e73ee3118fb0546650e", "patch": "@@ -0,0 +1,30 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"bits/verify.h\"\n+#include \"bits/metahelpers.h\"\n+\n+template <typename V>\n+  void\n+  test()\n+  {\n+    using T = typename V::value_type;\n+    V a{[](auto i) -> T { return i & 1u; }};\n+    V b{[](auto i) -> T { return (i + 1u) & 1u; }};\n+    COMPARE(min(a, b), V{0});\n+    COMPARE(max(a, b), V{1});\n+  }"}, {"sha": "e89221e1edee65ee3daaf5874b17f98b2e1d4849", "filename": "libstdc++-v3/testsuite/experimental/simd/tests/bits/conversions.h", "status": "added", "additions": 184, "deletions": 0, "changes": 184, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02e32295b284bd4f4d038e73ee3118fb0546650e/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fsimd%2Ftests%2Fbits%2Fconversions.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02e32295b284bd4f4d038e73ee3118fb0546650e/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fsimd%2Ftests%2Fbits%2Fconversions.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fsimd%2Ftests%2Fbits%2Fconversions.h?ref=02e32295b284bd4f4d038e73ee3118fb0546650e", "patch": "@@ -0,0 +1,184 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <array>\n+\n+// is_conversion_undefined\n+/* implementation-defined\n+ * ======================\n+ * \u00a74.7 p3 (integral conversions)\n+ *  If the destination type is signed, the value is unchanged if it can be\n+ *  represented in the destination type (and bit-field width); otherwise, the\n+ *  value is implementation-defined.\n+ *\n+ * undefined\n+ * =========\n+ * \u00a74.9/1  (floating-point conversions)\n+ *  If the source value is neither exactly represented in the destination type\n+ *  nor between two adjacent destination values the result is undefined.\n+ *\n+ * \u00a74.10/1 (floating-integral conversions)\n+ *  floating point type can be converted to integer type.\n+ *  The behavior is undefined if the truncated value cannot be\n+ *  represented in the destination type.\n+ *\n+ * \u00a74.10/2\n+ *  integer can be converted to floating point type.\n+ *  If the value being converted is outside the range of values that can be\n+ *  represented, the behavior is undefined.\n+ */\n+template <typename To, typename From>\n+  constexpr bool\n+  is_conversion_undefined_impl(From x, std::true_type)\n+  {\n+    return x > static_cast<long double>(std::__finite_max_v<To>)\n+\t     || x < static_cast<long double>(std::__finite_min_v<To>);\n+  }\n+\n+template <typename To, typename From>\n+  constexpr bool\n+  is_conversion_undefined_impl(From, std::false_type)\n+  { return false; }\n+\n+template <typename To, typename From>\n+  constexpr bool\n+  is_conversion_undefined(From x)\n+  {\n+    static_assert(std::is_arithmetic<From>::value,\n+\t\t  \"this overload is only meant for builtin arithmetic types\");\n+    return is_conversion_undefined_impl<To, From>(\n+\t     x, std::integral_constant<\n+\t\t  bool, std::is_floating_point<From>::value\n+\t\t\t  && (std::is_integral<To>::value\n+\t\t\t\t|| (std::is_floating_point<To>::value\n+\t\t\t\t      && sizeof(From) > sizeof(To)))>());\n+  }\n+\n+static_assert(is_conversion_undefined<uint>(float(0x100000000LL)),\n+\t      \"testing my expectations of is_conversion_undefined\");\n+static_assert(!is_conversion_undefined<float>(0x100000000LL),\n+\t      \"testing my expectations of is_conversion_undefined\");\n+\n+template <typename To, typename T, typename A>\n+  inline std::experimental::simd_mask<T, A>\n+  is_conversion_undefined(const std::experimental::simd<T, A>& x)\n+  {\n+    std::experimental::simd_mask<T, A> k = false;\n+    for (std::size_t i = 0; i < x.size(); ++i)\n+      k[i] = is_conversion_undefined(x[i]);\n+    return k;\n+  }\n+\n+template <class T>\n+  constexpr T\n+  genHalfBits()\n+  { return std::__finite_max_v<T> >> (std::__digits_v<T> / 2); }\n+\n+template <>\n+  constexpr long double\n+  genHalfBits<long double>()\n+  { return 0; }\n+\n+template <>\n+  constexpr double\n+  genHalfBits<double>()\n+  { return 0; }\n+\n+template <>\n+  constexpr float\n+  genHalfBits<float>()\n+  { return 0; }\n+\n+template <class U, class T, class UU>\n+  constexpr U\n+  avoid_ub(UU x)\n+  { return is_conversion_undefined<T>(U(x)) ? U(0) : U(x); }\n+\n+template <class U, class T, class UU>\n+  constexpr U\n+  avoid_ub2(UU x)\n+  { return is_conversion_undefined<U>(x) ? U(0) : avoid_ub<U, T>(x); }\n+\n+// conversion test input data\n+template <class U, class T>\n+  static const std::array<U, 53> cvt_input_data = {{\n+    avoid_ub<U, T>(0xc0000080U),\n+    avoid_ub<U, T>(0xc0000081U),\n+    avoid_ub<U, T>(0xc0000082U),\n+    avoid_ub<U, T>(0xc0000084U),\n+    avoid_ub<U, T>(0xc0000088U),\n+    avoid_ub<U, T>(0xc0000090U),\n+    avoid_ub<U, T>(0xc00000A0U),\n+    avoid_ub<U, T>(0xc00000C0U),\n+    avoid_ub<U, T>(0xc000017fU),\n+    avoid_ub<U, T>(0xc0000180U),\n+    avoid_ub<U, T>(0x100000001LL),\n+    avoid_ub<U, T>(0x100000011LL),\n+    avoid_ub<U, T>(0x100000111LL),\n+    avoid_ub<U, T>(0x100001111LL),\n+    avoid_ub<U, T>(0x100011111LL),\n+    avoid_ub<U, T>(0x100111111LL),\n+    avoid_ub<U, T>(0x101111111LL),\n+    avoid_ub<U, T>(-0x100000001LL),\n+    avoid_ub<U, T>(-0x100000011LL),\n+    avoid_ub<U, T>(-0x100000111LL),\n+    avoid_ub<U, T>(-0x100001111LL),\n+    avoid_ub<U, T>(-0x100011111LL),\n+    avoid_ub<U, T>(-0x100111111LL),\n+    avoid_ub<U, T>(-0x101111111LL),\n+    avoid_ub<U, T>(std::__norm_min_v<U>),\n+    avoid_ub<U, T>(std::__norm_min_v<U> + 1),\n+    avoid_ub<U, T>(std::__finite_min_v<U>),\n+    avoid_ub<U, T>(std::__finite_min_v<U> + 1),\n+    avoid_ub<U, T>(-1),\n+    avoid_ub<U, T>(-10),\n+    avoid_ub<U, T>(-100),\n+    avoid_ub<U, T>(-1000),\n+    avoid_ub<U, T>(-10000),\n+    avoid_ub<U, T>(0),\n+    avoid_ub<U, T>(1),\n+    avoid_ub<U, T>(genHalfBits<U>() - 1),\n+    avoid_ub<U, T>(genHalfBits<U>()),\n+    avoid_ub<U, T>(genHalfBits<U>() + 1),\n+    avoid_ub<U, T>(std::__finite_max_v<U> - 1),\n+    avoid_ub<U, T>(std::__finite_max_v<U>),\n+    avoid_ub<U, T>(std::__finite_max_v<U> - 0xff),\n+    avoid_ub<U, T>(std::__finite_max_v<U> - 0xff),\n+    avoid_ub<U, T>(std::__finite_max_v<U> - 0x55),\n+    avoid_ub<U, T>(-(std::__finite_min_v<U> + 1)),\n+    avoid_ub<U, T>(-std::__finite_max_v<U>),\n+    avoid_ub<U, T>(std::__finite_max_v<U> / std::pow(2., sizeof(T) * 6 - 1)),\n+    avoid_ub2<U, T>(-std::__finite_max_v<U> / std::pow(2., sizeof(T) * 6 - 1)),\n+    avoid_ub<U, T>(std::__finite_max_v<U> / std::pow(2., sizeof(T) * 4 - 1)),\n+    avoid_ub2<U, T>(-std::__finite_max_v<U> / std::pow(2., sizeof(T) * 4 - 1)),\n+    avoid_ub<U, T>(std::__finite_max_v<U> / std::pow(2., sizeof(T) * 2 - 1)),\n+    avoid_ub2<U, T>(-std::__finite_max_v<U> / std::pow(2., sizeof(T) * 2 - 1)),\n+    avoid_ub<U, T>(std::__finite_max_v<T> - 1),\n+    avoid_ub<U, T>(std::__finite_max_v<T> * 0.75),\n+  }};\n+\n+template <class T, class U>\n+  struct cvt_inputs\n+  {\n+    static constexpr size_t\n+    size()\n+    { return cvt_input_data<U, T>.size(); }\n+\n+    U\n+    operator[](size_t i) const\n+    { return cvt_input_data<U, T>[i]; }\n+  };"}, {"sha": "ee0d436f9ae01b1c4591c0a1cffee539cd37072c", "filename": "libstdc++-v3/testsuite/experimental/simd/tests/bits/make_vec.h", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02e32295b284bd4f4d038e73ee3118fb0546650e/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fsimd%2Ftests%2Fbits%2Fmake_vec.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02e32295b284bd4f4d038e73ee3118fb0546650e/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fsimd%2Ftests%2Fbits%2Fmake_vec.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fsimd%2Ftests%2Fbits%2Fmake_vec.h?ref=02e32295b284bd4f4d038e73ee3118fb0546650e", "patch": "@@ -0,0 +1,59 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <experimental/simd>\n+\n+template <class M>\n+  inline M\n+  make_mask(const std::initializer_list<bool> &init)\n+  {\n+    std::size_t i = 0;\n+    M r = {};\n+    for (;;)\n+      {\n+\tfor (bool x : init)\n+\t  {\n+\t    r[i] = x;\n+\t    if (++i == M::size())\n+\t      {\n+\t\treturn r;\n+\t      }\n+\t  }\n+      }\n+  }\n+\n+template <class V>\n+  inline V\n+  make_vec(const std::initializer_list<typename V::value_type> &init,\n+\t   typename V::value_type inc = 0)\n+  {\n+    std::size_t i = 0;\n+    V r = {};\n+    typename V::value_type base = 0;\n+    for (;;)\n+      {\n+\tfor (auto x : init)\n+\t  {\n+\t    r[i] = base + x;\n+\t    if (++i == V::size())\n+\t      {\n+\t\treturn r;\n+\t      }\n+\t  }\n+\tbase += inc;\n+      }\n+  }"}, {"sha": "2ed2bb35e3cd68d0d6199cf25048fb6e1fd03a64", "filename": "libstdc++-v3/testsuite/experimental/simd/tests/bits/mathreference.h", "status": "added", "additions": 160, "deletions": 0, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02e32295b284bd4f4d038e73ee3118fb0546650e/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fsimd%2Ftests%2Fbits%2Fmathreference.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02e32295b284bd4f4d038e73ee3118fb0546650e/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fsimd%2Ftests%2Fbits%2Fmathreference.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fsimd%2Ftests%2Fbits%2Fmathreference.h?ref=02e32295b284bd4f4d038e73ee3118fb0546650e", "patch": "@@ -0,0 +1,160 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <tuple>\n+#include <utility>\n+#include <cstdio>\n+\n+template <typename T>\n+  struct SincosReference\n+  {\n+    T x, s, c;\n+\n+    std::tuple<const T &, const T &, const T &>\n+    as_tuple() const\n+    { return std::tie(x, s, c); }\n+  };\n+\n+template <typename T>\n+  struct Reference {\n+    T x, ref;\n+\n+    std::tuple<const T &, const T &>\n+    as_tuple() const\n+    { return std::tie(x, ref); }\n+  };\n+\n+template <typename T>\n+  struct Array\n+  {\n+    std::size_t size_;\n+    const T *data_;\n+\n+    Array()\n+    : size_(0), data_(nullptr) {}\n+\n+    Array(size_t s, const T *p)\n+    : size_(s), data_(p) {}\n+\n+    const T*\n+    begin() const\n+    { return data_; }\n+\n+    const T*\n+    end() const\n+    { return data_ + size_; }\n+\n+    std::size_t\n+    size() const\n+    { return size_; }\n+  };\n+\n+namespace function {\n+  struct sincos{ static constexpr const char *const str = \"sincos\"; };\n+  struct atan  { static constexpr const char *const str = \"atan\"; };\n+  struct asin  { static constexpr const char *const str = \"asin\"; };\n+  struct acos  { static constexpr const char *const str = \"acos\"; };\n+  struct log   { static constexpr const char *const str = \"ln\"; };\n+  struct log2  { static constexpr const char *const str = \"log2\"; };\n+  struct log10 { static constexpr const char *const str = \"log10\"; };\n+}\n+\n+template <class F>\n+  struct testdatatype_for_function\n+  {\n+    template <class T>\n+      using type = Reference<T>;\n+  };\n+\n+template <>\n+  struct testdatatype_for_function<function::sincos>\n+  {\n+    template <class T>\n+      using type = SincosReference<T>;\n+  };\n+\n+template <class F, class T>\n+  using testdatatype_for_function_t\n+    = typename testdatatype_for_function<F>::template type<T>;\n+\n+template<typename T>\n+  struct StaticDeleter\n+  {\n+    const T *ptr;\n+\n+    StaticDeleter(const T *p)\n+    : ptr(p) {}\n+\n+    ~StaticDeleter()\n+    { delete[] ptr; }\n+  };\n+\n+template <class F, class T>\n+  inline std::string filename()\n+  {\n+    static_assert(std::is_floating_point<T>::value, \"\");\n+    static const auto cache\n+      = std::string(\"reference-\") + F::str\n+      + (sizeof(T) == 4 && std::__digits_v<T> == 24\n+\t && std::__max_exponent_v<T> == 128\n+\t ? \"-sp\"\n+\t : (sizeof(T) == 8\n+\t    && std::__digits_v<T> == 53\n+\t    && std::__max_exponent_v<T> == 1024\n+\t    ? \"-dp\"\n+\t    : (sizeof(T) == 16 && std::__digits_v<T> == 64\n+\t       && std::__max_exponent_v<T> == 16384\n+\t       ? \"-ep\"\n+\t       : (sizeof(T) == 16 && std::__digits_v<T> == 113\n+\t\t  && std::__max_exponent_v<T> == 16384\n+\t\t  ? \"-qp\"\n+\t\t  : \"-unknown\"))))\n+      + \".dat\";\n+    return cache;\n+  }\n+\n+template <class Fun, class T, class Ref = testdatatype_for_function_t<Fun, T>>\n+  Array<Ref>\n+  referenceData()\n+  {\n+    static Array<Ref> data;\n+    if (data.data_ == nullptr)\n+      {\n+\tFILE* file = std::fopen(filename<Fun, T>().c_str(), \"rb\");\n+\tif (file)\n+\t  {\n+\t    std::fseek(file, 0, SEEK_END);\n+\t    const size_t size = std::ftell(file) / sizeof(Ref);\n+\t    std::rewind(file);\n+\t    auto                      mem = new Ref[size];\n+\t    static StaticDeleter<Ref> _cleanup(data.data_);\n+\t    data.size_ = std::fread(mem, sizeof(Ref), size, file);\n+\t    data.data_ = mem;\n+\t    std::fclose(file);\n+\t  }\n+\telse\n+\t  {\n+\t    __builtin_fprintf(\n+\t\tstderr,\n+\t\t\"%s:%d: the reference data %s does not exist in the current \"\n+\t\t\"working directory.\\n\",\n+\t\t__FILE__, __LINE__, filename<Fun, T>().c_str());\n+\t    __builtin_abort();\n+\t  }\n+      }\n+    return data;\n+  }"}, {"sha": "e9516537e602b6a212d32882f3a2b91db4eefedf", "filename": "libstdc++-v3/testsuite/experimental/simd/tests/bits/metahelpers.h", "status": "added", "additions": 164, "deletions": 0, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02e32295b284bd4f4d038e73ee3118fb0546650e/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fsimd%2Ftests%2Fbits%2Fmetahelpers.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02e32295b284bd4f4d038e73ee3118fb0546650e/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fsimd%2Ftests%2Fbits%2Fmetahelpers.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fsimd%2Ftests%2Fbits%2Fmetahelpers.h?ref=02e32295b284bd4f4d038e73ee3118fb0546650e", "patch": "@@ -0,0 +1,164 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef VC_TESTS_METAHELPERS_H_\n+#define VC_TESTS_METAHELPERS_H_\n+\n+#include <functional>\n+#include <type_traits>\n+#include <utility>\n+\n+namespace vir\n+{\n+  namespace test\n+  {\n+    template <class A, class B, class Op>\n+      constexpr bool\n+      operator_is_substitution_failure_impl(float)\n+      { return true; }\n+\n+    template <class A, class B, class Op>\n+      constexpr typename std::conditional<true, bool, decltype(\n+\t  Op()(std::declval<A>(), std::declval<B>()))>::type\n+      operator_is_substitution_failure_impl(int)\n+      { return false; }\n+\n+    template <class... Ts>\n+      constexpr bool\n+      operator_is_substitution_failure()\n+      { return operator_is_substitution_failure_impl<Ts...>(int()); }\n+\n+    template <class... Args, class F>\n+      constexpr auto\n+      sfinae_is_callable_impl(int, F &&f) -> typename std::conditional<\n+\ttrue, std::true_type,\n+\tdecltype(std::forward<F>(f)(std::declval<Args>()...))>::type;\n+\n+    template <class... Args, class F>\n+      constexpr std::false_type\n+      sfinae_is_callable_impl(float, const F &);\n+\n+    template <class... Args, class F>\n+      constexpr bool\n+      sfinae_is_callable(F &&)\n+      {\n+\treturn decltype(\n+\t    sfinae_is_callable_impl<Args...>(int(), std::declval<F>()))::value;\n+      }\n+\n+    template <class... Args, class F>\n+      constexpr auto sfinae_is_callable_t(F &&f)\n+\t-> decltype(sfinae_is_callable_impl<Args...>(int(), std::declval<F>()));\n+\n+    template <class A, class B>\n+      constexpr bool\n+      has_less_bits()\n+      { return std::__digits_v<A> < std::__digits_v<B>; }\n+\n+  }  // namespace test\n+}  // namespace vir\n+\n+struct assignment\n+{\n+  template <class A, class B>\n+    constexpr decltype(std::declval<A>() = std::declval<B>())\n+    operator()(A &&a, B &&b) const noexcept(noexcept(\n+\tstd::forward<A>(a) = std::forward<B>(b)))\n+    { return std::forward<A>(a) = std::forward<B>(b); }\n+};\n+\n+struct bit_shift_left\n+{\n+  template <class A, class B>\n+    constexpr decltype(std::declval<A>() << std::declval<B>())\n+    operator()(A &&a, B &&b) const noexcept(noexcept(\n+\tstd::forward<A>(a) << std::forward<B>(b)))\n+    { return std::forward<A>(a) << std::forward<B>(b); }\n+};\n+\n+struct bit_shift_right\n+{\n+  template <class A, class B>\n+    constexpr decltype(std::declval<A>() >> std::declval<B>())\n+    operator()(A &&a, B &&b) const noexcept(noexcept(\n+\tstd::forward<A>(a) >> std::forward<B>(b)))\n+    { return std::forward<A>(a) >> std::forward<B>(b); }\n+};\n+\n+struct assign_modulus\n+{\n+  template <class A, class B>\n+    constexpr decltype(std::declval<A>() %= std::declval<B>())\n+    operator()(A &&a, B &&b) const noexcept(noexcept(\n+\tstd::forward<A>(a) %= std::forward<B>(b)))\n+    { return std::forward<A>(a) %= std::forward<B>(b); }\n+};\n+\n+struct assign_bit_and\n+{\n+  template <class A, class B>\n+    constexpr decltype(std::declval<A>() &= std::declval<B>())\n+    operator()(A &&a, B &&b) const noexcept(noexcept(\n+\tstd::forward<A>(a) &= std::forward<B>(b)))\n+    { return std::forward<A>(a) &= std::forward<B>(b); }\n+};\n+\n+struct assign_bit_or\n+{\n+  template <class A, class B>\n+    constexpr decltype(std::declval<A>() |= std::declval<B>())\n+    operator()(A &&a, B &&b) const noexcept(noexcept(\n+\tstd::forward<A>(a) |= std::forward<B>(b)))\n+    { return std::forward<A>(a) |= std::forward<B>(b); }\n+};\n+\n+struct assign_bit_xor\n+{\n+  template <class A, class B>\n+    constexpr decltype(std::declval<A>() ^= std::declval<B>())\n+    operator()(A &&a, B &&b) const noexcept(noexcept(\n+\tstd::forward<A>(a) ^= std::forward<B>(b)))\n+    { return std::forward<A>(a) ^= std::forward<B>(b); }\n+};\n+\n+struct assign_bit_shift_left\n+{\n+  template <class A, class B>\n+    constexpr decltype(std::declval<A>() <<= std::declval<B>())\n+    operator()(A &&a, B &&b) const noexcept(noexcept(\n+\tstd::forward<A>(a) <<= std::forward<B>(b)))\n+    { return std::forward<A>(a) <<= std::forward<B>(b); }\n+};\n+\n+struct assign_bit_shift_right\n+{\n+  template <class A, class B>\n+    constexpr decltype(std::declval<A>() >>= std::declval<B>())\n+    operator()(A &&a, B &&b) const noexcept(noexcept(\n+\tstd::forward<A>(a) >>= std::forward<B>(b)))\n+    { return std::forward<A>(a) >>= std::forward<B>(b); }\n+};\n+\n+template <class A, class B, class Op = std::plus<>>\n+  constexpr bool is_substitution_failure\n+    = vir::test::operator_is_substitution_failure<A, B, Op>();\n+\n+using vir::test::sfinae_is_callable;\n+\n+using vir::test::has_less_bits;\n+\n+#endif  // VC_TESTS_METAHELPERS_H_"}, {"sha": "a221708df395b5b6ca65c9689b3f31ac5f1a559e", "filename": "libstdc++-v3/testsuite/experimental/simd/tests/bits/simd_view.h", "status": "added", "additions": 121, "deletions": 0, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02e32295b284bd4f4d038e73ee3118fb0546650e/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fsimd%2Ftests%2Fbits%2Fsimd_view.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02e32295b284bd4f4d038e73ee3118fb0546650e/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fsimd%2Ftests%2Fbits%2Fsimd_view.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fsimd%2Ftests%2Fbits%2Fsimd_view.h?ref=02e32295b284bd4f4d038e73ee3118fb0546650e", "patch": "@@ -0,0 +1,121 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef VC_TESTS_SIMD_VIEW_H_\n+#define VC_TESTS_SIMD_VIEW_H_\n+\n+#include <experimental/simd>\n+\n+_GLIBCXX_SIMD_BEGIN_NAMESPACE\n+\n+namespace experimental\n+{\n+  namespace imported_begin_end\n+  {\n+    using std::begin;\n+    using std::end;\n+\n+    template <class T>\n+      using begin_type = decltype(begin(std::declval<T>()));\n+\n+    template <class T>\n+      using end_type = decltype(end(std::declval<T>()));\n+  }  // namespace imported_begin_end\n+\n+  template <class V, class It, class End>\n+    class viewer\n+    {\n+      It it;\n+      const End end;\n+\n+      template <class F>\n+\tvoid\n+\tfor_each_impl(F &&fun, std::index_sequence<0, 1, 2>)\n+\t{\n+\t  for (; it + V::size() <= end; it += V::size())\n+\t    {\n+\t      fun(V([&](auto i) { return std::get<0>(it[i].as_tuple()); }),\n+\t\t  V([&](auto i) { return std::get<1>(it[i].as_tuple()); }),\n+\t\t  V([&](auto i) { return std::get<2>(it[i].as_tuple()); }));\n+\t    }\n+\t  if (it != end)\n+\t    {\n+\t      fun(V([&](auto i)\n+\t      {\n+\t\tauto ii = it + i < end ? i + 0 : 0;\n+\t\treturn std::get<0>(it[ii].as_tuple());\n+\t      }),\n+\t\t  V([&](auto i) {\n+\t\t    auto ii = it + i < end ? i + 0 : 0;\n+\t\t    return std::get<1>(it[ii].as_tuple());\n+\t\t  }),\n+\t\t  V([&](auto i) {\n+\t\t    auto ii = it + i < end ? i + 0 : 0;\n+\t\t    return std::get<2>(it[ii].as_tuple());\n+\t\t  }));\n+\t    }\n+\t}\n+\n+      template <class F>\n+\tvoid\n+\tfor_each_impl(F &&fun, std::index_sequence<0, 1>)\n+\t{\n+\t  for (; it + V::size() <= end; it += V::size())\n+\t    {\n+\t      fun(V([&](auto i) { return std::get<0>(it[i].as_tuple()); }),\n+\t\t  V([&](auto i) { return std::get<1>(it[i].as_tuple()); }));\n+\t    }\n+\t  if (it != end)\n+\t    {\n+\t      fun(V([&](auto i) {\n+\t\tauto ii = it + i < end ? i + 0 : 0;\n+\t\treturn std::get<0>(it[ii].as_tuple());\n+\t      }),\n+\t\t  V([&](auto i) {\n+\t\t    auto ii = it + i < end ? i + 0 : 0;\n+\t\t    return std::get<1>(it[ii].as_tuple());\n+\t\t  }));\n+\t    }\n+\t}\n+\n+    public:\n+      viewer(It _it, End _end)\n+      : it(_it), end(_end) {}\n+\n+      template <class F>\n+\tvoid\n+\tfor_each(F &&fun)\n+\t{\n+\t  constexpr size_t N\n+\t    = std::tuple_size<std::decay_t<decltype(it->as_tuple())>>::value;\n+\t  for_each_impl(std::forward<F>(fun), std::make_index_sequence<N>());\n+\t}\n+    };\n+\n+  template <class V, class Cont>\n+    viewer<V, imported_begin_end::begin_type<const Cont &>,\n+\t   imported_begin_end::end_type<const Cont &>>\n+    simd_view(const Cont &data)\n+    {\n+      using std::begin;\n+      using std::end;\n+      return {begin(data), end(data)};\n+    }\n+}  // namespace experimental\n+_GLIBCXX_SIMD_END_NAMESPACE\n+\n+#endif  // VC_TESTS_SIMD_VIEW_H_"}, {"sha": "01988aef327dad0f7d68baa208ed68aa21ee58d1", "filename": "libstdc++-v3/testsuite/experimental/simd/tests/bits/test_values.h", "status": "added", "additions": 383, "deletions": 0, "changes": 383, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02e32295b284bd4f4d038e73ee3118fb0546650e/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fsimd%2Ftests%2Fbits%2Ftest_values.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02e32295b284bd4f4d038e73ee3118fb0546650e/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fsimd%2Ftests%2Fbits%2Ftest_values.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fsimd%2Ftests%2Fbits%2Ftest_values.h?ref=02e32295b284bd4f4d038e73ee3118fb0546650e", "patch": "@@ -0,0 +1,383 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <experimental/simd>\n+#include <initializer_list>\n+#include <random>\n+#include <cfenv>\n+\n+template <class T, class A>\n+  std::experimental::simd<T, A>\n+  iif(std::experimental::simd_mask<T, A> k,\n+      const typename std::experimental::simd_mask<T, A>::simd_type& t,\n+      const std::experimental::simd<T, A>& f)\n+  {\n+    auto r = f;\n+    where(k, r) = t;\n+    return r;\n+  }\n+\n+template <class V>\n+  V\n+  epilogue_load(const typename V::value_type* mem, const std::size_t size)\n+  {\n+    const int rem = size % V::size();\n+    return where(V([](int i) { return i; }) < rem, V(0))\n+\t     .copy_from(mem + size / V::size() * V::size(),\n+\t\t\tstd::experimental::element_aligned);\n+  }\n+\n+template <class V, class... F>\n+  void\n+  test_values(const std::initializer_list<typename V::value_type>& inputs,\n+\t      F&&... fun_pack)\n+  {\n+    for (auto it = inputs.begin(); it + V::size() <= inputs.end();\n+\t it += V::size())\n+      {\n+\t[](auto...) {\n+\t}((fun_pack(V(&it[0], std::experimental::element_aligned)), 0)...);\n+      }\n+    [](auto...) {\n+    }((fun_pack(epilogue_load<V>(inputs.begin(), inputs.size())), 0)...);\n+  }\n+\n+template <class V>\n+  struct RandomValues\n+  {\n+    using T = typename V::value_type;\n+    static constexpr bool isfp = std::is_floating_point_v<T>;\n+    const std::size_t count;\n+\n+    std::conditional_t<std::is_floating_point_v<T>,\n+\t\t       std::uniform_real_distribution<T>,\n+\t\t       std::uniform_int_distribution<T>>\n+      dist;\n+\n+    const bool uniform;\n+\n+    const T abs_max = std::__finite_max_v<T>;\n+\n+    RandomValues(std::size_t count_, T min, T max)\n+    : count(count_), dist(min, max), uniform(true)\n+    {\n+      if constexpr (std::is_floating_point_v<T>)\n+\tVERIFY(max - min <= std::__finite_max_v<T>);\n+    }\n+\n+    RandomValues(std::size_t count_)\n+    : count(count_), dist(isfp ? 1 : std::__finite_min_v<T>,\n+\t\t\t  isfp ? 2 : std::__finite_max_v<T>),\n+      uniform(!isfp)\n+    {}\n+\n+    RandomValues(std::size_t count_, T abs_max_)\n+    : count(count_), dist(isfp ? 1 : -abs_max_, isfp ? 2 : abs_max_),\n+      uniform(!isfp), abs_max(abs_max_)\n+    {}\n+\n+    template <typename URBG>\n+      V\n+      operator()(URBG& gen)\n+      {\n+\tif constexpr (!isfp)\n+\t  return V([&](int) { return dist(gen); });\n+\telse if (uniform)\n+\t  return V([&](int) { return dist(gen); });\n+\telse\n+\t  {\n+\t    auto exp_dist\n+\t      = std::normal_distribution<float>(0.f,\n+\t\t\t\t\t\tstd::__max_exponent_v<T> * .5f);\n+\t    return V([&](int) {\n+\t\t     const T mant = dist(gen);\n+\t\t     T fp = 0;\n+\t\t     do {\n+\t\t       const int exp = exp_dist(gen);\n+\t\t       fp = std::ldexp(mant, exp);\n+\t\t     } while (fp >= abs_max || fp <= std::__denorm_min_v<T>);\n+\t\t     fp = gen() & 0x4 ? fp : -fp;\n+\t\t     return fp;\n+\t\t   });\n+\t  }\n+      }\n+  };\n+\n+static std::mt19937 g_mt_gen{0};\n+\n+template <class V, class... F>\n+  void\n+  test_values(const std::initializer_list<typename V::value_type>& inputs,\n+\t      RandomValues<V> random, F&&... fun_pack)\n+  {\n+    test_values<V>(inputs, fun_pack...);\n+    for (size_t i = 0; i < (random.count + V::size() - 1) / V::size(); ++i)\n+      {\n+\t[](auto...) {}((fun_pack(random(g_mt_gen)), 0)...);\n+      }\n+  }\n+\n+template <class V, class... F>\n+  void\n+  test_values_2arg(const std::initializer_list<typename V::value_type>& inputs,\n+\t\t   F&&... fun_pack)\n+  {\n+    for (auto scalar_it = inputs.begin(); scalar_it != inputs.end();\n+\t ++scalar_it)\n+      {\n+\tfor (auto it = inputs.begin(); it + V::size() <= inputs.end();\n+\t     it += V::size())\n+\t  {\n+\t    [](auto...) {\n+\t    }((fun_pack(V(&it[0], std::experimental::element_aligned),\n+\t\t\tV(*scalar_it)),\n+\t       0)...);\n+\t  }\n+\t[](auto...) {\n+\t}((fun_pack(epilogue_load<V>(inputs.begin(), inputs.size()),\n+\t\t    V(*scalar_it)),\n+\t   0)...);\n+      }\n+  }\n+\n+template <class V, class... F>\n+  void\n+  test_values_2arg(const std::initializer_list<typename V::value_type>& inputs,\n+\t\t   RandomValues<V> random, F&&... fun_pack)\n+  {\n+    test_values_2arg<V>(inputs, fun_pack...);\n+    for (size_t i = 0; i < (random.count + V::size() - 1) / V::size(); ++i)\n+      {\n+\t[](auto...) {}((fun_pack(random(g_mt_gen), random(g_mt_gen)), 0)...);\n+      }\n+  }\n+\n+template <class V, class... F>\n+  void\n+  test_values_3arg(const std::initializer_list<typename V::value_type>& inputs,\n+\t\t   F&&... fun_pack)\n+  {\n+    for (auto scalar_it1 = inputs.begin(); scalar_it1 != inputs.end();\n+\t ++scalar_it1)\n+      {\n+\tfor (auto scalar_it2 = inputs.begin(); scalar_it2 != inputs.end();\n+\t     ++scalar_it2)\n+\t  {\n+\t    for (auto it = inputs.begin(); it + V::size() <= inputs.end();\n+\t\t it += V::size())\n+\t      {\n+\t\t[](auto...) {\n+\t\t}((fun_pack(V(&it[0], std::experimental::element_aligned),\n+\t\t\t    V(*scalar_it1), V(*scalar_it2)),\n+\t\t   0)...);\n+\t      }\n+\t    [](auto...) {\n+\t    }((fun_pack(epilogue_load<V>(inputs.begin(), inputs.size()),\n+\t\t\tV(*scalar_it1), V(*scalar_it2)),\n+\t       0)...);\n+\t  }\n+      }\n+  }\n+\n+template <class V, class... F>\n+  void\n+  test_values_3arg(const std::initializer_list<typename V::value_type>& inputs,\n+\t\t   RandomValues<V> random, F&&... fun_pack)\n+  {\n+    test_values_3arg<V>(inputs, fun_pack...);\n+    for (size_t i = 0; i < (random.count + V::size() - 1) / V::size(); ++i)\n+      {\n+\t[](auto...) {\n+\t}((fun_pack(random(g_mt_gen), random(g_mt_gen), random(g_mt_gen)),\n+\t   0)...);\n+      }\n+  }\n+\n+#if __GCC_IEC_559 < 2\n+// Without IEC559 we consider -0, subnormals, +/-inf, and all NaNs to be\n+// invalid (potential UB when used or \"produced\"). This can't use isnormal (or\n+// any other classification function), since they know about the UB.\n+template <class V>\n+  typename V::mask_type\n+  isvalid(V x)\n+  {\n+    using namespace std::experimental::parallelism_v2;\n+    using namespace std::experimental::parallelism_v2::__proposed;\n+    using T = typename V::value_type;\n+    if constexpr (sizeof(T) <= sizeof(double))\n+      {\n+\tusing I = rebind_simd_t<__int_for_sizeof_t<T>, V>;\n+\tconst I abs_x = __bit_cast<I>(abs(x));\n+\tconst I min = __bit_cast<I>(V(std::__norm_min_v<T>));\n+\tconst I max = __bit_cast<I>(V(std::__finite_max_v<T>));\n+\treturn static_simd_cast<typename V::mask_type>(\n+\t\t __bit_cast<I>(x) == 0 || (abs_x >= min && abs_x <= max));\n+      }\n+    else\n+      {\n+\tconst V abs_x = abs(x);\n+\tconst V min = std::__norm_min_v<T>;\n+\t// Make max non-const static to inhibit constprop. Otherwise the\n+\t// compiler might decide `abs_x <= max` is constexpr true, by definition\n+\t// (-ffinite-math-only)\n+\tstatic V max = std::__finite_max_v<T>;\n+\treturn (x == 0 && copysign(V(1), x) == V(1))\n+\t\t || (abs_x >= min && abs_x <= max);\n+      }\n+  }\n+\n+#define MAKE_TESTER_2(name_, reference_)                                       \\\n+  [&](auto... inputs) {                                                        \\\n+    ((where(!isvalid(inputs), inputs) = 1), ...);                              \\\n+    const auto totest = name_(inputs...);                                      \\\n+    using R = std::remove_const_t<decltype(totest)>;                           \\\n+    auto&& expected = [&](const auto&... vs) -> const R {                      \\\n+      R tmp = {};                                                              \\\n+      for (std::size_t i = 0; i < R::size(); ++i)                              \\\n+\ttmp[i] = reference_(vs[i]...);                                         \\\n+      return tmp;                                                              \\\n+    };                                                                         \\\n+    const R expect1 = expected(inputs...);                                     \\\n+    if constexpr (std::is_floating_point_v<typename R::value_type>)            \\\n+      {                                                                        \\\n+\t((where(!isvalid(expect1), inputs) = 1), ...);                         \\\n+\tconst R expect2 = expected(inputs...);                                 \\\n+\t((FUZZY_COMPARE(name_(inputs...), expect2) << \"\\ninputs = \")           \\\n+\t << ... << inputs);                                                    \\\n+      }                                                                        \\\n+    else                                                                       \\\n+      ((COMPARE(name_(inputs...), expect1) << \"\\n\" #name_ \"(\")                 \\\n+       << ... << inputs)                                                       \\\n+\t<< \")\";                                                                \\\n+  }\n+\n+#define MAKE_TESTER_NOFPEXCEPT(name_)                                          \\\n+  [&](auto... inputs) {                                                        \\\n+    ((where(!isvalid(inputs), inputs) = 1), ...);                              \\\n+    using R = std::remove_const_t<decltype(name_(inputs...))>;                 \\\n+    auto&& expected = [&](const auto&... vs) -> const R {                      \\\n+      R tmp = {};                                                              \\\n+      for (std::size_t i = 0; i < R::size(); ++i)                              \\\n+\ttmp[i] = std::name_(vs[i]...);                                         \\\n+      return tmp;                                                              \\\n+    };                                                                         \\\n+    const R expect1 = expected(inputs...);                                     \\\n+    if constexpr (std::is_floating_point_v<typename R::value_type>)            \\\n+      {                                                                        \\\n+\t((where(!isvalid(expect1), inputs) = 1), ...);                         \\\n+\tstd::feclearexcept(FE_ALL_EXCEPT);                                     \\\n+\tasm volatile(\"\");                                                      \\\n+\tauto totest = name_(inputs...);                                        \\\n+\tasm volatile(\"\");                                                      \\\n+\t((COMPARE(std::fetestexcept(FE_ALL_EXCEPT), 0) << \"\\n\" #name_ \"(\")     \\\n+\t << ... << inputs)                                                     \\\n+\t  << \")\";                                                              \\\n+\tconst R expect2 = expected(inputs...);                                 \\\n+\tstd::feclearexcept(FE_ALL_EXCEPT);                                     \\\n+\tasm volatile(\"\");                                                      \\\n+\ttotest = name_(inputs...);                                             \\\n+\tasm volatile(\"\");                                                      \\\n+\t((COMPARE(std::fetestexcept(FE_ALL_EXCEPT), 0) << \"\\n\" #name_ \"(\")     \\\n+\t << ... << inputs)                                                     \\\n+\t  << \")\";                                                              \\\n+\t((FUZZY_COMPARE(totest, expect2) << \"\\n\" #name_ \"(\") << ... << inputs) \\\n+\t  << \")\";                                                              \\\n+      }                                                                        \\\n+    else                                                                       \\\n+      {                                                                        \\\n+\tstd::feclearexcept(FE_ALL_EXCEPT);                                     \\\n+\tasm volatile(\"\");                                                      \\\n+\tauto totest = name_(inputs...);                                        \\\n+\tasm volatile(\"\");                                                      \\\n+\t((COMPARE(std::fetestexcept(FE_ALL_EXCEPT), 0) << \"\\n\" #name_ \"(\")     \\\n+\t << ... << inputs)                                                     \\\n+\t  << \")\";                                                              \\\n+\t((COMPARE(totest, expect1) << \"\\n\" #name_ \"(\") << ... << inputs)       \\\n+\t  << \")\";                                                              \\\n+      }                                                                        \\\n+  }\n+\n+#else\n+\n+#define MAKE_TESTER_2(name_, reference_)                                       \\\n+  [&](auto... inputs) {                                                        \\\n+    const auto totest = name_(inputs...);                                      \\\n+    using R = std::remove_const_t<decltype(totest)>;                           \\\n+    auto&& expected = [&](const auto&... vs) -> const R {                      \\\n+      R tmp = {};                                                              \\\n+      for (std::size_t i = 0; i < R::size(); ++i)                              \\\n+\ttmp[i] = reference_(vs[i]...);                                         \\\n+      return tmp;                                                              \\\n+    };                                                                         \\\n+    const R expect1 = expected(inputs...);                                     \\\n+    if constexpr (std::is_floating_point_v<typename R::value_type>)            \\\n+      {                                                                        \\\n+\t((COMPARE(isnan(totest), isnan(expect1)) << #name_ \"(\")                \\\n+\t << ... << inputs)                                                     \\\n+\t  << \") = \" << totest << \" != \" << expect1;                            \\\n+\t((where(isnan(expect1), inputs) = 0), ...);                            \\\n+\t((FUZZY_COMPARE(name_(inputs...), expected(inputs...))                 \\\n+\t  << \"\\nclean = \")                                                     \\\n+\t << ... << inputs);                                                    \\\n+      }                                                                        \\\n+    else                                                                       \\\n+      ((COMPARE(name_(inputs...), expect1) << \"\\n\" #name_ \"(\")                 \\\n+       << ... << inputs)                                                       \\\n+\t<< \")\";                                                                \\\n+  }\n+\n+#define MAKE_TESTER_NOFPEXCEPT(name_)                                          \\\n+  [&](auto... inputs) {                                                        \\\n+    std::feclearexcept(FE_ALL_EXCEPT);                                         \\\n+    auto totest = name_(inputs...);                                            \\\n+    ((COMPARE(std::fetestexcept(FE_ALL_EXCEPT), 0) << \"\\n\" #name_ \"(\")         \\\n+     << ... << inputs)                                                         \\\n+      << \")\";                                                                  \\\n+    using R = std::remove_const_t<decltype(totest)>;                           \\\n+    auto&& expected = [&](const auto&... vs) -> const R {                      \\\n+      R tmp = {};                                                              \\\n+      for (std::size_t i = 0; i < R::size(); ++i)                              \\\n+\ttmp[i] = std::name_(vs[i]...);                                         \\\n+      return tmp;                                                              \\\n+    };                                                                         \\\n+    const R expect1 = expected(inputs...);                                     \\\n+    if constexpr (std::is_floating_point_v<typename R::value_type>)            \\\n+      {                                                                        \\\n+\t((COMPARE(isnan(totest), isnan(expect1)) << #name_ \"(\")                \\\n+\t << ... << inputs)                                                     \\\n+\t  << \") = \" << totest << \" != \" << expect1;                            \\\n+\t((where(isnan(expect1), inputs) = 0), ...);                            \\\n+\tconst R expect2 = expected(inputs...);                                 \\\n+\tstd::feclearexcept(FE_ALL_EXCEPT);                                     \\\n+\tasm volatile(\"\");                                                      \\\n+\ttotest = name_(inputs...);                                             \\\n+\tasm volatile(\"\");                                                      \\\n+\t((COMPARE(std::fetestexcept(FE_ALL_EXCEPT), 0) << \"\\n\" #name_ \"(\")     \\\n+\t << ... << inputs)                                                     \\\n+\t  << \")\";                                                              \\\n+\tFUZZY_COMPARE(totest, expect2);                                        \\\n+      }                                                                        \\\n+    else                                                                       \\\n+      {                                                                        \\\n+\t((COMPARE(totest, expect1) << \"\\n\" #name_ \"(\") << ... << inputs)       \\\n+\t  << \")\";                                                              \\\n+      }                                                                        \\\n+  }\n+\n+#endif\n+\n+#define MAKE_TESTER(name_) MAKE_TESTER_2(name_, std::name_)"}, {"sha": "3b6966dd85d3ecd559e541c1d998edc5c09ef9e6", "filename": "libstdc++-v3/testsuite/experimental/simd/tests/bits/ulp.h", "status": "added", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02e32295b284bd4f4d038e73ee3118fb0546650e/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fsimd%2Ftests%2Fbits%2Fulp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02e32295b284bd4f4d038e73ee3118fb0546650e/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fsimd%2Ftests%2Fbits%2Fulp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fsimd%2Ftests%2Fbits%2Fulp.h?ref=02e32295b284bd4f4d038e73ee3118fb0546650e", "patch": "@@ -0,0 +1,101 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef ULP_H\n+#define ULP_H\n+\n+#include <cmath>\n+#include <experimental/simd>\n+#include <type_traits>\n+#include <cfenv>\n+\n+namespace vir {\n+  namespace test {\n+    template <typename T, typename R = typename T::value_type>\n+      R\n+      value_type_impl(int);\n+\n+    template <typename T>\n+      T\n+      value_type_impl(float);\n+\n+    template <typename T>\n+      using value_type_t = decltype(value_type_impl<T>(int()));\n+\n+    template <typename T>\n+      inline T\n+      ulp_distance(const T& val_, const T& ref_)\n+      {\n+        if constexpr (std::is_floating_point_v<value_type_t<T>>)\n+          {\n+            const int fp_exceptions = std::fetestexcept(FE_ALL_EXCEPT);\n+            T val = val_;\n+            T ref = ref_;\n+\n+            T diff = T();\n+\n+            using std::abs;\n+            using std::fpclassify;\n+            using std::frexp;\n+            using std::isnan;\n+            using std::isinf;\n+            using std::ldexp;\n+            using std::max;\n+            using std::experimental::where;\n+            using TT = value_type_t<T>;\n+\n+            where(ref == 0, val) = abs(val);\n+            where(ref == 0, diff) = 1;\n+            where(ref == 0, ref) = std::__norm_min_v<TT>;\n+            where(isinf(ref) && ref == val, ref)\n+              = 0; // where(val_ == ref_) = 0 below will fix it up\n+\n+            where(val == 0, ref) = abs(ref);\n+            where(val == 0, diff) += 1;\n+            where(val == 0, val) = std::__norm_min_v<TT>;\n+\n+            using I = decltype(fpclassify(std::declval<T>()));\n+            I exp = {};\n+            frexp(ref, &exp);\n+            // lower bound for exp must be min_exponent to scale the resulting\n+            // difference from a denormal correctly\n+            exp = max(exp, I(std::__min_exponent_v<TT>));\n+            diff += ldexp(abs(ref - val), std::__digits_v<TT> - exp);\n+            where(val_ == ref_ || (isnan(val_) && isnan(ref_)), diff) = T();\n+            std::feclearexcept(FE_ALL_EXCEPT ^ fp_exceptions);\n+            return diff;\n+          }\n+        else\n+          {\n+            if (val_ > ref_)\n+              return val_ - ref_;\n+            else\n+              return ref_ - val_;\n+          }\n+      }\n+\n+    template <typename T>\n+      inline T\n+      ulp_distance_signed(const T& _val, const T& _ref)\n+      {\n+        using std::copysign;\n+        return copysign(ulp_distance(_val, _ref), _val - _ref);\n+      }\n+  } // namespace test\n+} // namespace vir\n+\n+#endif // ULP_H"}, {"sha": "5da47b35536d4f1185c67882b3858e8aecb0fedb", "filename": "libstdc++-v3/testsuite/experimental/simd/tests/bits/verify.h", "status": "added", "additions": 353, "deletions": 0, "changes": 353, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02e32295b284bd4f4d038e73ee3118fb0546650e/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fsimd%2Ftests%2Fbits%2Fverify.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02e32295b284bd4f4d038e73ee3118fb0546650e/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fsimd%2Ftests%2Fbits%2Fverify.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fsimd%2Ftests%2Fbits%2Fverify.h?ref=02e32295b284bd4f4d038e73ee3118fb0546650e", "patch": "@@ -0,0 +1,353 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef TESTS_BITS_VERIFY_H_\n+#define TESTS_BITS_VERIFY_H_\n+\n+#include <experimental/simd>\n+#include <sstream>\n+#include <iomanip>\n+#include \"ulp.h\"\n+\n+#ifdef _GLIBCXX_SIMD_HAVE_NEON\n+// work around PR89357:\n+#define alignas(...) __attribute__((aligned(__VA_ARGS__)))\n+#endif\n+\n+using schar = signed char;\n+using uchar = unsigned char;\n+using ushort = unsigned short;\n+using uint = unsigned int;\n+using ulong = unsigned long;\n+using llong = long long;\n+using ullong = unsigned long long;\n+using ldouble = long double;\n+using wchar = wchar_t;\n+using char16 = char16_t;\n+using char32 = char32_t;\n+\n+template <class T>\n+  T\n+  make_value_unknown(const T& x)\n+  {\n+    if constexpr (std::is_constructible_v<T, const volatile T&>)\n+      {\n+\tconst volatile T& y = x;\n+\treturn y;\n+      }\n+    else\n+      {\n+\tT y = x;\n+\tasm(\"\" : \"+m\"(y));\n+\treturn y;\n+      }\n+  }\n+\n+class verify\n+{\n+  const bool m_failed = false;\n+\n+  template <typename T,\n+\t    typename = decltype(std::declval<std::stringstream&>()\n+\t\t\t\t<< std::declval<const T&>())>\n+    void\n+    print(const T& x, int) const\n+    {\n+      std::stringstream ss;\n+      ss << x;\n+      __builtin_fprintf(stderr, \"%s\", ss.str().c_str());\n+    }\n+\n+  template <typename T>\n+    void\n+    print(const T& x, ...) const\n+    {\n+      if constexpr (std::experimental::is_simd_v<T>)\n+\t{\n+\t  std::stringstream ss;\n+\t  if constexpr (std::is_floating_point_v<typename T::value_type>)\n+\t    {\n+\t      ss << '(' << x[0] << \" == \" << std::hexfloat << x[0]\n+\t\t<< std::defaultfloat << ')';\n+\t      for (unsigned i = 1; i < x.size(); ++i)\n+\t\t{\n+\t\t  ss << (i % 4 == 0 ? \",\\n(\" : \", (\") << x[i]\n+\t\t    << \" == \" << std::hexfloat << x[i] << std::defaultfloat\n+\t\t    << ')';\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      ss << +x[0];\n+\t      for (unsigned i = 1; i < x.size(); ++i)\n+\t\t{\n+\t\t  ss << \", \" << +x[i];\n+\t\t}\n+\t    }\n+\t  __builtin_fprintf(stderr, \"%s\", ss.str().c_str());\n+\t}\n+      else if constexpr (std::experimental::is_simd_mask_v<T>)\n+\t{\n+\t  __builtin_fprintf(stderr, (x[0] ? \"[1\" : \"[0\"));\n+\t  for (unsigned i = 1; i < x.size(); ++i)\n+\t    {\n+\t      __builtin_fprintf(stderr, (x[i] ? \"1\" : \"0\"));\n+\t    }\n+\t  __builtin_fprintf(stderr, \"]\");\n+\t}\n+      else\n+\t{\n+\t  print_hex(&x, sizeof(T));\n+\t}\n+    }\n+\n+  void\n+  print_hex(const void* x, std::size_t n) const\n+  {\n+    __builtin_fprintf(stderr, \"0x\");\n+    const auto* bytes = static_cast<const unsigned char*>(x);\n+    for (std::size_t i = 0; i < n; ++i)\n+      {\n+\t__builtin_fprintf(stderr, (i && i % 4 == 0) ? \"'%02x\" : \"%02x\",\n+\t\t\t  bytes[i]);\n+      }\n+  }\n+\n+public:\n+  template <typename... Ts>\n+    verify(bool ok, size_t ip, const char* file, const int line,\n+\t   const char* func, const char* cond, const Ts&... extra_info)\n+    : m_failed(!ok)\n+    {\n+      if (m_failed)\n+\t{\n+\t  __builtin_fprintf(stderr, \"%s:%d: (%s):\\nInstruction Pointer: %x\\n\"\n+\t\t\t\t    \"Assertion '%s' failed.\\n\",\n+\t\t\t    file, line, func, ip, cond);\n+\t  (print(extra_info, int()), ...);\n+\t}\n+    }\n+\n+  ~verify()\n+  {\n+    if (m_failed)\n+      {\n+\t__builtin_fprintf(stderr, \"\\n\");\n+\t__builtin_abort();\n+      }\n+  }\n+\n+  template <typename T>\n+    const verify&\n+    operator<<(const T& x) const\n+    {\n+      if (m_failed)\n+\t{\n+\t  print(x, int());\n+\t}\n+      return *this;\n+    }\n+\n+  template <typename... Ts>\n+    const verify&\n+    on_failure(const Ts&... xs) const\n+    {\n+      if (m_failed)\n+\t(print(xs, int()), ...);\n+      return *this;\n+    }\n+\n+  [[gnu::always_inline]] static inline size_t\n+  get_ip()\n+  {\n+    size_t _ip = 0;\n+#ifdef __x86_64__\n+    asm volatile(\"lea 0(%%rip),%0\" : \"=r\"(_ip));\n+#elif defined __i386__\n+    asm volatile(\"1: movl $1b,%0\" : \"=r\"(_ip));\n+#elif defined __arm__\n+    asm volatile(\"mov %0,pc\" : \"=r\"(_ip));\n+#elif defined __aarch64__\n+    asm volatile(\"adr %0,.\" : \"=r\"(_ip));\n+#endif\n+    return _ip;\n+  }\n+};\n+\n+#if __FLT_EVAL_METHOD__ != 0\n+template <typename T>\n+  [[gnu::always_inline]] inline decltype(auto)\n+  force_fp_truncation(const T& x)\n+  {\n+    namespace stdx = std::experimental;\n+    if constexpr (stdx::is_simd_v<T>)\n+      {\n+\tusing U = typename T::value_type;\n+\tif constexpr (std::is_floating_point_v<typename T::value_type>\n+\t\t      && sizeof(U) <= 8 && (sizeof(T) < 16 || std::is_same_v<\n+\t\t  T, stdx::fixed_size_simd<U, T::size()>>))\n+\t  {\n+\t    T y = x;\n+\t    asm(\"\" : \"+m\"(y));\n+\t    return y;\n+\t  }\n+\telse\n+\t  return x;\n+      }\n+    else if constexpr (std::is_floating_point_v<T> && sizeof(T) <= 8)\n+      {\n+\tT y = x;\n+\tasm(\"\" : \"+m\"(y));\n+\treturn y;\n+      }\n+    else\n+      return x;\n+  }\n+\n+#define COMPARE(_a, _b)                                                        \\\n+  [&](auto&& _aa, auto&& _bb) {                                                \\\n+    return verify(std::experimental::all_of(_aa == _bb), verify::get_ip(),     \\\n+\t\t  __FILE__, __LINE__, __PRETTY_FUNCTION__,                     \\\n+\t\t  \"all_of(\" #_a \" == \" #_b \")\", #_a \" = \", _aa,                \\\n+\t\t  \"\\n\" #_b \" = \", _bb);                                        \\\n+  }(force_fp_truncation(_a), force_fp_truncation(_b))\n+#else\n+#define COMPARE(_a, _b)                                                        \\\n+  [&](auto&& _aa, auto&& _bb) {                                                \\\n+    return verify(std::experimental::all_of(_aa == _bb), verify::get_ip(),     \\\n+\t\t  __FILE__, __LINE__, __PRETTY_FUNCTION__,                     \\\n+\t\t  \"all_of(\" #_a \" == \" #_b \")\", #_a \" = \", _aa,                \\\n+\t\t  \"\\n\" #_b \" = \", _bb);                                        \\\n+  }((_a), (_b))\n+#endif\n+\n+#define VERIFY(_test)                                                          \\\n+  verify(_test, verify::get_ip(), __FILE__, __LINE__, __PRETTY_FUNCTION__,     \\\n+\t #_test)\n+\n+  // ulp_distance_signed can raise FP exceptions and thus must be conditionally\n+  // executed\n+#define ULP_COMPARE(_a, _b, _allowed_distance)                                 \\\n+  [&](auto&& _aa, auto&& _bb) {                                                \\\n+    const bool success = std::experimental::all_of(                            \\\n+      vir::test::ulp_distance(_aa, _bb) <= (_allowed_distance));               \\\n+    return verify(success, verify::get_ip(), __FILE__, __LINE__,               \\\n+\t\t  __PRETTY_FUNCTION__, \"all_of(\" #_a \" ~~ \" #_b \")\",           \\\n+\t\t  #_a \" = \", _aa, \"\\n\" #_b \" = \", _bb, \"\\ndistance = \",        \\\n+\t\t  success ? 0 : vir::test::ulp_distance_signed(_aa, _bb));     \\\n+  }((_a), (_b))\n+\n+namespace vir {\n+  namespace test\n+  {\n+    template <typename T>\n+      inline T _S_fuzzyness = 0;\n+\n+    template <typename T>\n+      void\n+      setFuzzyness(T x)\n+      { _S_fuzzyness<T> = x; }\n+  } // namespace test\n+} // namespace vir\n+\n+#define FUZZY_COMPARE(_a, _b)                                                  \\\n+  ULP_COMPARE(                                                                 \\\n+    _a, _b,                                                                    \\\n+    vir::test::_S_fuzzyness<vir::test::value_type_t<decltype((_a) + (_b))>>)\n+\n+template <typename V>\n+  void\n+  test();\n+\n+template <typename V>\n+  void\n+  invoke_test(...)\n+  {}\n+\n+template <typename V, typename = decltype(V())>\n+  void\n+  invoke_test(int)\n+  {\n+    test<V>();\n+    __builtin_fprintf(stderr, \"PASS: %s\\n\", __PRETTY_FUNCTION__);\n+  }\n+\n+template <class T>\n+  void\n+  iterate_abis()\n+  {\n+    using namespace std::experimental::parallelism_v2;\n+#ifndef EXTENDEDTESTS\n+    invoke_test<simd<T, simd_abi::scalar>>(int());\n+    invoke_test<simd<T, simd_abi::_VecBuiltin<16>>>(int());\n+    invoke_test<simd<T, simd_abi::_VecBltnBtmsk<64>>>(int());\n+#elif EXTENDEDTESTS == 0\n+    invoke_test<simd<T, simd_abi::_VecBuiltin<8>>>(int());\n+    invoke_test<simd<T, simd_abi::_VecBuiltin<12>>>(int());\n+    invoke_test<simd<T, simd_abi::_VecBuiltin<24>>>(int());\n+    invoke_test<simd<T, simd_abi::_VecBuiltin<32>>>(int());\n+    invoke_test<simd<T, simd_abi::_VecBltnBtmsk<56>>>(int());\n+#elif EXTENDEDTESTS == 1\n+    invoke_test<simd<T, simd_abi::fixed_size<8>>>(int());\n+    invoke_test<simd<T, simd_abi::fixed_size<16>>>(int());\n+    invoke_test<simd<T, simd_abi::fixed_size<24>>>(int());\n+    invoke_test<simd<T, simd_abi::fixed_size<32>>>(int());\n+#elif EXTENDEDTESTS == 2\n+    invoke_test<simd<T, simd_abi::fixed_size<1>>>(int());\n+    invoke_test<simd<T, simd_abi::fixed_size<9>>>(int());\n+    invoke_test<simd<T, simd_abi::fixed_size<17>>>(int());\n+    invoke_test<simd<T, simd_abi::fixed_size<25>>>(int());\n+#elif EXTENDEDTESTS == 3\n+    invoke_test<simd<T, simd_abi::fixed_size<2>>>(int());\n+    invoke_test<simd<T, simd_abi::fixed_size<10>>>(int());\n+    invoke_test<simd<T, simd_abi::fixed_size<18>>>(int());\n+    invoke_test<simd<T, simd_abi::fixed_size<26>>>(int());\n+#elif EXTENDEDTESTS == 4\n+    invoke_test<simd<T, simd_abi::fixed_size<3>>>(int());\n+    invoke_test<simd<T, simd_abi::fixed_size<19>>>(int());\n+    invoke_test<simd<T, simd_abi::fixed_size<11>>>(int());\n+    invoke_test<simd<T, simd_abi::fixed_size<27>>>(int());\n+#elif EXTENDEDTESTS == 5\n+    invoke_test<simd<T, simd_abi::fixed_size<4>>>(int());\n+    invoke_test<simd<T, simd_abi::fixed_size<12>>>(int());\n+    invoke_test<simd<T, simd_abi::fixed_size<20>>>(int());\n+    invoke_test<simd<T, simd_abi::fixed_size<28>>>(int());\n+#elif EXTENDEDTESTS == 6\n+    invoke_test<simd<T, simd_abi::fixed_size<5>>>(int());\n+    invoke_test<simd<T, simd_abi::fixed_size<13>>>(int());\n+    invoke_test<simd<T, simd_abi::fixed_size<21>>>(int());\n+    invoke_test<simd<T, simd_abi::fixed_size<29>>>(int());\n+#elif EXTENDEDTESTS == 7\n+    invoke_test<simd<T, simd_abi::fixed_size<6>>>(int());\n+    invoke_test<simd<T, simd_abi::fixed_size<14>>>(int());\n+    invoke_test<simd<T, simd_abi::fixed_size<22>>>(int());\n+    invoke_test<simd<T, simd_abi::fixed_size<30>>>(int());\n+#elif EXTENDEDTESTS == 8\n+    invoke_test<simd<T, simd_abi::fixed_size<7>>>(int());\n+    invoke_test<simd<T, simd_abi::fixed_size<15>>>(int());\n+    invoke_test<simd<T, simd_abi::fixed_size<23>>>(int());\n+    invoke_test<simd<T, simd_abi::fixed_size<31>>>(int());\n+#endif\n+  }\n+\n+int main()\n+{\n+  iterate_abis<_GLIBCXX_SIMD_TESTTYPE>();\n+  return 0;\n+}\n+\n+#endif  // TESTS_BITS_VERIFY_H_"}, {"sha": "c107de3380bbc210ebed3bde2cf7c0a6db21d219", "filename": "libstdc++-v3/testsuite/experimental/simd/tests/broadcast.cc", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02e32295b284bd4f4d038e73ee3118fb0546650e/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fsimd%2Ftests%2Fbroadcast.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02e32295b284bd4f4d038e73ee3118fb0546650e/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fsimd%2Ftests%2Fbroadcast.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fsimd%2Ftests%2Fbroadcast.cc?ref=02e32295b284bd4f4d038e73ee3118fb0546650e", "patch": "@@ -0,0 +1,104 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"bits/verify.h\"\n+#include \"bits/metahelpers.h\"\n+\n+enum unscoped_enum\n+{ foo };\n+\n+enum class scoped_enum\n+{ bar };\n+\n+struct convertible\n+{\n+  operator int();\n+  operator float();\n+};\n+\n+template <typename V>\n+  void\n+  test()\n+  {\n+    using T = typename V::value_type;\n+    VERIFY(std::experimental::is_simd_v<V>);\n+    VERIFY(std::experimental::is_abi_tag_v<typename V::abi_type>);\n+\n+    {\n+      V x;     // not initialized\n+      x = V{}; // default broadcasts 0\n+      COMPARE(x, V(0));\n+      COMPARE(x, V());\n+      COMPARE(x, V{});\n+      x = V(); // default broadcasts 0\n+      COMPARE(x, V(0));\n+      COMPARE(x, V());\n+      COMPARE(x, V{});\n+      x = 0;\n+      COMPARE(x, V(0));\n+      COMPARE(x, V());\n+      COMPARE(x, V{});\n+\n+      for (std::size_t i = 0; i < V::size(); ++i)\n+\t{\n+\t  COMPARE(T(x[i]), T(0)) << \"i = \" << i;\n+\t  COMPARE(x[i], T(0)) << \"i = \" << i;\n+\t}\n+    }\n+\n+    V x = 3;\n+    V y = T(0);\n+    for (std::size_t i = 0; i < V::size(); ++i)\n+      {\n+\tCOMPARE(x[i], T(3)) << \"i = \" << i;\n+\tCOMPARE(y[i], T(0)) << \"i = \" << i;\n+      }\n+    y = 3;\n+    COMPARE(x, y);\n+\n+    VERIFY(!(is_substitution_failure<V&, unscoped_enum, assignment>) );\n+    VERIFY((is_substitution_failure<V&, scoped_enum, assignment>) );\n+    COMPARE((is_substitution_failure<V&, convertible, assignment>),\n+\t    (!std::is_convertible<convertible, T>::value));\n+    COMPARE((is_substitution_failure<V&, long double, assignment>),\n+\t    (sizeof(long double) > sizeof(T) || std::is_integral<T>::value));\n+    COMPARE((is_substitution_failure<V&, double, assignment>),\n+\t    (sizeof(double) > sizeof(T) || std::is_integral<T>::value));\n+    COMPARE((is_substitution_failure<V&, float, assignment>),\n+\t    (sizeof(float) > sizeof(T) || std::is_integral<T>::value));\n+    COMPARE((is_substitution_failure<V&, long long, assignment>),\n+\t    (has_less_bits<T, long long>() || std::is_unsigned<T>::value));\n+    COMPARE((is_substitution_failure<V&, unsigned long long, assignment>),\n+\t    (has_less_bits<T, unsigned long long>()));\n+    COMPARE((is_substitution_failure<V&, long, assignment>),\n+\t    (has_less_bits<T, long>() || std::is_unsigned<T>::value));\n+    COMPARE((is_substitution_failure<V&, unsigned long, assignment>),\n+\t    (has_less_bits<T, unsigned long>()));\n+    // int broadcast *always* works:\n+    VERIFY(!(is_substitution_failure<V&, int, assignment>) );\n+    // uint broadcast works for any unsigned T:\n+    COMPARE((is_substitution_failure<V&, unsigned int, assignment>),\n+\t    (!std::is_unsigned<T>::value && has_less_bits<T, unsigned int>()));\n+    COMPARE((is_substitution_failure<V&, short, assignment>),\n+\t    (has_less_bits<T, short>() || std::is_unsigned<T>::value));\n+    COMPARE((is_substitution_failure<V&, unsigned short, assignment>),\n+\t    (has_less_bits<T, unsigned short>()));\n+    COMPARE((is_substitution_failure<V&, signed char, assignment>),\n+\t    (has_less_bits<T, signed char>() || std::is_unsigned<T>::value));\n+    COMPARE((is_substitution_failure<V&, unsigned char, assignment>),\n+\t    (has_less_bits<T, unsigned char>()));\n+  }"}, {"sha": "df169e100de754f517acccbcc705b3a58eb65c97", "filename": "libstdc++-v3/testsuite/experimental/simd/tests/casts.cc", "status": "added", "additions": 169, "deletions": 0, "changes": 169, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02e32295b284bd4f4d038e73ee3118fb0546650e/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fsimd%2Ftests%2Fcasts.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02e32295b284bd4f4d038e73ee3118fb0546650e/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fsimd%2Ftests%2Fcasts.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fsimd%2Ftests%2Fcasts.cc?ref=02e32295b284bd4f4d038e73ee3118fb0546650e", "patch": "@@ -0,0 +1,169 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"bits/verify.h\"\n+#include \"bits/metahelpers.h\"\n+#include \"bits/conversions.h\"\n+\n+using std::experimental::simd_cast;\n+using std::experimental::static_simd_cast;\n+\n+template <class T, size_t N>\n+  struct gen_cast\n+  {\n+    std::array<T, N> data;\n+\n+    template <class V>\n+      gen_cast(const V& v)\n+      {\n+\tfor (size_t i = 0; i < V::size(); ++i)\n+\t  {\n+\t    data[i] = static_cast<T>(v[i]);\n+\t  }\n+      }\n+\n+    template <class I>\n+      constexpr T\n+      operator()(I)\n+      { return data[I::value]; }\n+  };\n+\n+template <class V, class To>\n+  struct gen_seq_t\n+  {\n+    using From = typename V::value_type;\n+    const size_t N = cvt_input_data<From, To>.size();\n+    size_t offset = 0;\n+\n+    constexpr void\n+    operator++()\n+    { offset += V::size(); }\n+\n+    explicit constexpr operator bool() const\n+    { return offset < N; }\n+\n+    template <class I>\n+      constexpr From\n+      operator()(I) const\n+      {\n+\tsize_t i = I::value + offset;\n+\treturn i < N ? cvt_input_data<From, To>[i] : From(i);\n+      }\n+  };\n+\n+template <class To>\n+  struct foo\n+  {\n+    template <class T>\n+      auto\n+      operator()(const T& v) -> decltype(simd_cast<To>(v));\n+  };\n+\n+template <typename V, typename To>\n+  void\n+  casts()\n+  {\n+    using From = typename V::value_type;\n+    constexpr auto N = V::size();\n+    if constexpr (N <= std::experimental::simd_abi::max_fixed_size<To>)\n+      {\n+\tusing W = std::experimental::fixed_size_simd<To, N>;\n+\n+\tif constexpr (std::is_integral_v<From>)\n+\t  {\n+\t    using A = typename V::abi_type;\n+\t    using TU = std::make_unsigned_t<From>;\n+\t    using TS = std::make_signed_t<From>;\n+\t    COMPARE(typeid(static_simd_cast<TU>(V())),\n+\t\t    typeid(std::experimental::simd<TU, A>));\n+\t    COMPARE(typeid(static_simd_cast<TS>(V())),\n+\t\t    typeid(std::experimental::simd<TS, A>));\n+\t  }\n+\n+\tusing is_simd_cast_allowed\n+\t  = decltype(vir::test::sfinae_is_callable_t<const V&>(foo<To>()));\n+\n+\tCOMPARE(is_simd_cast_allowed::value,\n+\t\tstd::__digits<From>::value <= std::__digits<To>::value\n+\t\t  && std::__finite_max<From>::value\n+\t\t  <= std::__finite_max<To>::value\n+\t\t  && !(std::is_signed<From>::value\n+\t\t       && std::is_unsigned<To>::value));\n+\n+\tif constexpr (is_simd_cast_allowed::value)\n+\t  {\n+\t    for (gen_seq_t<V, To> gen_seq; gen_seq; ++gen_seq)\n+\t      {\n+\t\tconst V seq(gen_seq);\n+\t\tCOMPARE(simd_cast<V>(seq), seq);\n+\t\tCOMPARE(simd_cast<W>(seq), W(gen_cast<To, N>(seq)))\n+\t\t  << \"seq = \" << seq;\n+\t\tauto test = simd_cast<To>(seq);\n+\t\t// decltype(test) is not W if\n+\t\t// a) V::abi_type is not fixed_size and\n+\t\t// b.1) V::value_type and To are integral and of equal rank or\n+\t\t// b.2) V::value_type and To are equal\n+\t\tCOMPARE(test, decltype(test)(gen_cast<To, N>(seq)));\n+\t\tif (std::is_same<To, From>::value)\n+\t\t  {\n+\t\t    COMPARE(typeid(decltype(test)), typeid(V));\n+\t\t  }\n+\t      }\n+\t  }\n+\n+\tfor (gen_seq_t<V, To> gen_seq; gen_seq; ++gen_seq)\n+\t  {\n+\t    const V seq(gen_seq);\n+\t    COMPARE(static_simd_cast<V>(seq), seq);\n+\t    COMPARE(static_simd_cast<W>(seq), W(gen_cast<To, N>(seq))) << '\\n'\n+\t      << seq;\n+\t    auto test = static_simd_cast<To>(seq);\n+\t    // decltype(test) is not W if\n+\t    // a) V::abi_type is not fixed_size and\n+\t    // b.1) V::value_type and To are integral and of equal rank or\n+\t    // b.2) V::value_type and To are equal\n+\t    COMPARE(test, decltype(test)(gen_cast<To, N>(seq)));\n+\t    if (std::is_same<To, From>::value)\n+\t      {\n+\t\tCOMPARE(typeid(decltype(test)), typeid(V));\n+\t      }\n+\t  }\n+      }\n+  }\n+\n+template <typename V>\n+  void\n+  test()\n+  {\n+    casts<V, long double>();\n+    casts<V, double>();\n+    casts<V, float>();\n+    casts<V, long long>();\n+    casts<V, unsigned long long>();\n+    casts<V, unsigned long>();\n+    casts<V, long>();\n+    casts<V, int>();\n+    casts<V, unsigned int>();\n+    casts<V, short>();\n+    casts<V, unsigned short>();\n+    casts<V, char>();\n+    casts<V, signed char>();\n+    casts<V, unsigned char>();\n+    casts<V, char32_t>();\n+    casts<V, char16_t>();\n+    casts<V, wchar_t>();\n+  }"}, {"sha": "eef26108f5f33a1747ff2b87b9213559ff6b407d", "filename": "libstdc++-v3/testsuite/experimental/simd/tests/fpclassify.cc", "status": "added", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02e32295b284bd4f4d038e73ee3118fb0546650e/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fsimd%2Ftests%2Ffpclassify.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02e32295b284bd4f4d038e73ee3118fb0546650e/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fsimd%2Ftests%2Ffpclassify.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fsimd%2Ftests%2Ffpclassify.cc?ref=02e32295b284bd4f4d038e73ee3118fb0546650e", "patch": "@@ -0,0 +1,106 @@\n+// test only floattypes\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"bits/verify.h\"\n+#include \"bits/metahelpers.h\"\n+#include \"bits/test_values.h\"\n+#include <cfenv>\n+\n+template <typename F>\n+  auto\n+  verify_no_fp_exceptions(F&& fun)\n+  {\n+    std::feclearexcept(FE_ALL_EXCEPT);\n+    auto r = fun();\n+    COMPARE(std::fetestexcept(FE_ALL_EXCEPT), 0);\n+    return r;\n+  }\n+\n+#define NOFPEXCEPT(...) verify_no_fp_exceptions([&]() { return __VA_ARGS__; })\n+\n+template <typename V>\n+  void\n+  test()\n+  {\n+    using T = typename V::value_type;\n+    using intv = std::experimental::fixed_size_simd<int, V::size()>;\n+    constexpr T inf = std::__infinity_v<T>;\n+    constexpr T denorm_min = std::__infinity_v<T>;\n+    constexpr T nan = std::__quiet_NaN_v<T>;\n+    constexpr T max = std::__finite_max_v<T>;\n+    constexpr T norm_min = std::__norm_min_v<T>;\n+    test_values<V>(\n+      {0., 1., -1.,\n+#if __GCC_IEC_559 >= 2\n+       -0., inf, -inf, denorm_min, -denorm_min, nan,\n+       norm_min * 0.9, -norm_min * 0.9,\n+#endif\n+       max, -max, norm_min, -norm_min\n+      },\n+      [](const V input) {\n+\tCOMPARE(NOFPEXCEPT(isfinite(input)),\n+\t\t!V([&](auto i) { return std::isfinite(input[i]) ? 0 : 1; }))\n+\t  << input;\n+\tCOMPARE(NOFPEXCEPT(isinf(input)),\n+\t\t!V([&](auto i) { return std::isinf(input[i]) ? 0 : 1; }))\n+\t  << input;\n+\tCOMPARE(NOFPEXCEPT(isnan(input)),\n+\t\t!V([&](auto i) { return std::isnan(input[i]) ? 0 : 1; }))\n+\t  << input;\n+\tCOMPARE(NOFPEXCEPT(isnormal(input)),\n+\t\t!V([&](auto i) { return std::isnormal(input[i]) ? 0 : 1; }))\n+\t  << input;\n+\tCOMPARE(NOFPEXCEPT(signbit(input)),\n+\t\t!V([&](auto i) { return std::signbit(input[i]) ? 0 : 1; }))\n+\t  << input;\n+\tCOMPARE(NOFPEXCEPT(isunordered(input, V())),\n+\t\t!V([&](auto i) { return std::isunordered(input[i], 0) ? 0 : 1; }))\n+\t  << input;\n+\tCOMPARE(NOFPEXCEPT(isunordered(V(), input)),\n+\t\t!V([&](auto i) { return std::isunordered(0, input[i]) ? 0 : 1; }))\n+\t  << input;\n+\tCOMPARE(NOFPEXCEPT(fpclassify(input)),\n+\t\tintv([&](auto i) { return std::fpclassify(input[i]); }))\n+\t  << input;\n+      });\n+#ifdef __SUPPORT_SNAN__\n+    const V snan = std::__signaling_NaN_v<T>;\n+    COMPARE(isfinite(snan),\n+\t    !V([&](auto i) { return std::isfinite(snan[i]) ? 0 : 1; }))\n+      << snan;\n+    COMPARE(isinf(snan), !V([&](auto i) { return std::isinf(snan[i]) ? 0 : 1; }))\n+      << snan;\n+    COMPARE(isnan(snan), !V([&](auto i) { return std::isnan(snan[i]) ? 0 : 1; }))\n+      << snan;\n+    COMPARE(isnormal(snan),\n+\t    !V([&](auto i) { return std::isnormal(snan[i]) ? 0 : 1; }))\n+      << snan;\n+    COMPARE(signbit(snan),\n+\t    !V([&](auto i) { return std::signbit(snan[i]) ? 0 : 1; }))\n+      << snan;\n+    COMPARE(isunordered(snan, V()),\n+\t    !V([&](auto i) { return std::isunordered(snan[i], 0) ? 0 : 1; }))\n+      << snan;\n+    COMPARE(isunordered(V(), snan),\n+\t    !V([&](auto i) { return std::isunordered(0, snan[i]) ? 0 : 1; }))\n+      << snan;\n+    COMPARE(fpclassify(snan),\n+\t    intv([&](auto i) { return std::fpclassify(snan[i]); }))\n+      << snan;\n+#endif\n+  }"}, {"sha": "e2d90dd1e3fccf8197d35ee7699d1c3a2daa613c", "filename": "libstdc++-v3/testsuite/experimental/simd/tests/frexp.cc", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02e32295b284bd4f4d038e73ee3118fb0546650e/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fsimd%2Ftests%2Ffrexp.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02e32295b284bd4f4d038e73ee3118fb0546650e/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fsimd%2Ftests%2Ffrexp.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fsimd%2Ftests%2Ffrexp.cc?ref=02e32295b284bd4f4d038e73ee3118fb0546650e", "patch": "@@ -0,0 +1,85 @@\n+// test only floattypes\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"bits/verify.h\"\n+#include \"bits/metahelpers.h\"\n+#include \"bits/test_values.h\"\n+\n+template <typename V>\n+  void\n+  test()\n+  {\n+    using int_v = std::experimental::fixed_size_simd<int, V::size()>;\n+    using T = typename V::value_type;\n+    constexpr auto denorm_min = std::__denorm_min_v<T>;\n+    constexpr auto norm_min = std::__norm_min_v<T>;\n+    constexpr auto max = std::__finite_max_v<T>;\n+    constexpr auto nan = std::__quiet_NaN_v<T>;\n+    constexpr auto inf = std::__infinity_v<T>;\n+    test_values<V>(\n+      {0, 0.25, 0.5, 1, 3, 4, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n+       20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 32, 31, -0., -0.25, -0.5, -1,\n+       -3, -4, -6, -7, -8, -9, -10, -11, -12, -13, -14, -15, -16, -17, -18,\n+       -19, -20, -21, -22, -23, -24, -25, -26, -27, -28, -29, -32, -31,\n+#if __GCC_IEC_559 >= 2\n+       denorm_min, -denorm_min, norm_min / 2, -norm_min / 2,\n+#endif\n+       max, -max, max * 0.123f, -max * 0.123f},\n+      [](const V input) {\n+\tV expectedFraction;\n+\tconst int_v expectedExponent([&](auto i) {\n+\t  int exp;\n+\t  expectedFraction[i] = std::frexp(input[i], &exp);\n+\t  return exp;\n+\t});\n+\tint_v exponent = {};\n+\tconst V fraction = frexp(input, &exponent);\n+\tCOMPARE(fraction, expectedFraction) << \", input = \" << input\n+\t  << \", delta: \" << fraction - expectedFraction;\n+\tCOMPARE(exponent, expectedExponent)\n+\t  << \"\\ninput: \" << input << \", fraction: \" << fraction;\n+      });\n+#ifdef __STDC_IEC_559__\n+    test_values<V>(\n+      // If x is a NaN, a NaN is returned, and the value of *exp is unspecified.\n+      //\n+      // If x is positive  infinity  (negative  infinity),  positive  infinity\n+      // (negative infinity) is returned, and the value of *exp is unspecified.\n+      // This behavior is only guaranteed with C's Annex F when __STDC_IEC_559__\n+      // is defined.\n+      {nan, inf, -inf, denorm_min, denorm_min * 1.72, -denorm_min,\n+       -denorm_min * 1.72, 0., -0., 1, -1},\n+      [](const V input) {\n+\tconst V expectedFraction([&](auto i) {\n+\t  int exp;\n+\t  return std::frexp(input[i], &exp);\n+\t});\n+\tint_v exponent = {};\n+\tconst V fraction = frexp(input, &exponent);\n+\tCOMPARE(isnan(fraction), isnan(expectedFraction))\n+\t  << fraction << \", input = \" << input\n+\t  << \", delta: \" << fraction - expectedFraction;\n+\tCOMPARE(isinf(fraction), isinf(expectedFraction))\n+\t  << fraction << \", input = \" << input\n+\t  << \", delta: \" << fraction - expectedFraction;\n+\tCOMPARE(signbit(fraction), signbit(expectedFraction))\n+\t  << fraction << \", input = \" << input\n+\t  << \", delta: \" << fraction - expectedFraction;\n+      });\n+#endif\n+  }"}, {"sha": "221064dc476fb962cb3c7d315c8602db61ff7841", "filename": "libstdc++-v3/testsuite/experimental/simd/tests/generator.cc", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02e32295b284bd4f4d038e73ee3118fb0546650e/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fsimd%2Ftests%2Fgenerator.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02e32295b284bd4f4d038e73ee3118fb0546650e/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fsimd%2Ftests%2Fgenerator.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fsimd%2Ftests%2Fgenerator.cc?ref=02e32295b284bd4f4d038e73ee3118fb0546650e", "patch": "@@ -0,0 +1,58 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"bits/verify.h\"\n+#include \"bits/metahelpers.h\"\n+\n+template <class V>\n+  struct call_generator\n+  {\n+    template <class F>\n+      auto\n+      operator()(const F& f) -> decltype(V(f));\n+  };\n+\n+using schar = signed char;\n+using uchar = unsigned char;\n+using ullong = unsigned long long;\n+\n+template <typename V>\n+  void\n+  test()\n+  {\n+    using T = typename V::value_type;\n+    V x([](int) { return T(1); });\n+    COMPARE(x, V(1));\n+    // unconditionally returns int from generator lambda\n+    x = V([](int) { return 1; });\n+    COMPARE(x, V(1));\n+    x = V([](auto i) { return T(i); });\n+    COMPARE(x, V([](T i) { return i; }));\n+\n+    VERIFY((// that int always works\n+\tsfinae_is_callable<int (&)(int)>(call_generator<V>())));\n+    COMPARE(sfinae_is_callable<schar (&)(int)>(call_generator<V>()),\n+\t    std::is_signed<T>::value);\n+    COMPARE(sfinae_is_callable<uchar (&)(int)>(call_generator<V>()),\n+\t    !(std::is_signed_v<T> && sizeof(T) <= sizeof(uchar)));\n+    COMPARE(sfinae_is_callable<float (&)(int)>(call_generator<V>()),\n+\t    (std::is_floating_point<T>::value));\n+\n+    COMPARE(sfinae_is_callable<ullong (&)(int)>(call_generator<V>()),\n+      std::__finite_max_v<T> >= std::__finite_max_v<ullong>\n+      && std::__digits_v<T> >= std::__digits_v<ullong>);\n+  }"}, {"sha": "0c8e55983a2a4ddf4c5ec0064823dee968b09411", "filename": "libstdc++-v3/testsuite/experimental/simd/tests/hypot3_fma.cc", "status": "added", "additions": 151, "deletions": 0, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02e32295b284bd4f4d038e73ee3118fb0546650e/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fsimd%2Ftests%2Fhypot3_fma.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02e32295b284bd4f4d038e73ee3118fb0546650e/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fsimd%2Ftests%2Fhypot3_fma.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fsimd%2Ftests%2Fhypot3_fma.cc?ref=02e32295b284bd4f4d038e73ee3118fb0546650e", "patch": "@@ -0,0 +1,151 @@\n+// test only floattypes\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"bits/verify.h\"\n+#include \"bits/metahelpers.h\"\n+#include \"bits/test_values.h\"\n+\n+// 3-arg std::hypot needs to be fixed, this is a better reference:\n+template <typename T>\n+  [[gnu::optimize(\"-fno-unsafe-math-optimizations\")]]\n+  T\n+  hypot3(T x, T y, T z)\n+  {\n+    x = std::abs(x);\n+    y = std::abs(y);\n+    z = std::abs(z);\n+    if (std::isinf(x) || std::isinf(y) || std::isinf(z))\n+      return std::__infinity_v<T>;\n+    else if (std::isnan(x) || std::isnan(y) || std::isnan(z))\n+      return std::__quiet_NaN_v<T>;\n+    else if (x == y && y == z)\n+      return x * std::sqrt(T(3));\n+    else if (z == 0 && y == 0)\n+      return x;\n+    else if (x == 0 && z == 0)\n+      return y;\n+    else if (x == 0 && y == 0)\n+      return z;\n+    else\n+      {\n+\tT hi = std::max(std::max(x, y), z);\n+\tT lo0 = std::min(std::max(x, y), z);\n+\tT lo1 = std::min(x, y);\n+\tint e = 0;\n+\thi = std::frexp(hi, &e);\n+\tlo0 = std::ldexp(lo0, -e);\n+\tlo1 = std::ldexp(lo1, -e);\n+\tT lo = lo0 * lo0 + lo1 * lo1;\n+\treturn std::ldexp(std::sqrt(hi * hi + lo), e);\n+      }\n+  }\n+\n+template <typename V>\n+  void\n+  test()\n+  {\n+    vir::test::setFuzzyness<float>(1);\n+    vir::test::setFuzzyness<double>(1);\n+    vir::test::setFuzzyness<long double>(2); // because of the bad reference\n+\n+    using T = typename V::value_type;\n+    test_values_3arg<V>(\n+      {\n+#ifdef __STDC_IEC_559__\n+\tstd::__quiet_NaN_v<T>,\n+\tstd::__infinity_v<T>,\n+\t-std::__infinity_v<T>,\n+\tstd::__norm_min_v<T> / 3,\n+\t-0.,\n+\tstd::__denorm_min_v<T>,\n+#endif\n+\t0.,\n+\t1.,\n+\t-1.,\n+\tstd::__norm_min_v<T>,\n+\t-std::__norm_min_v<T>,\n+\t2.,\n+\t-2.,\n+\tstd::__finite_max_v<T> / 5,\n+\tstd::__finite_max_v<T> / 3,\n+\tstd::__finite_max_v<T> / 2,\n+\t-std::__finite_max_v<T> / 5,\n+\t-std::__finite_max_v<T> / 3,\n+\t-std::__finite_max_v<T> / 2,\n+#ifdef __FAST_MATH__\n+\t// fast-math hypot is imprecise for the max exponent\n+      },\n+      {100000, std::__finite_max_v<T> / 2},\n+#else\n+\tstd::__finite_max_v<T>, -std::__finite_max_v<T>},\n+      {100000},\n+#endif\n+      MAKE_TESTER_2(hypot, hypot3));\n+#if !__FINITE_MATH_ONLY__\n+    COMPARE(hypot(V(std::__finite_max_v<T>), V(std::__finite_max_v<T>), V()),\n+\t    V(std::__infinity_v<T>));\n+    COMPARE(hypot(V(std::__finite_max_v<T>), V(), V(std::__finite_max_v<T>)),\n+\t    V(std::__infinity_v<T>));\n+    COMPARE(hypot(V(), V(std::__finite_max_v<T>), V(std::__finite_max_v<T>)),\n+\t    V(std::__infinity_v<T>));\n+#endif\n+    COMPARE(hypot(V(std::__norm_min_v<T>), V(std::__norm_min_v<T>),\n+\t\t  V(std::__norm_min_v<T>)),\n+\t    V(std::__norm_min_v<T> * std::sqrt(T(3))));\n+    auto&& hypot3_test\n+      = [](auto a, auto b, auto c) -> decltype(hypot(a, b, c)) { return {}; };\n+    VERIFY((sfinae_is_callable<V, V, V>(hypot3_test)));\n+    VERIFY((sfinae_is_callable<T, T, V>(hypot3_test)));\n+    VERIFY((sfinae_is_callable<V, T, T>(hypot3_test)));\n+    VERIFY((sfinae_is_callable<T, V, T>(hypot3_test)));\n+    VERIFY((sfinae_is_callable<T, V, V>(hypot3_test)));\n+    VERIFY((sfinae_is_callable<V, T, V>(hypot3_test)));\n+    VERIFY((sfinae_is_callable<V, V, T>(hypot3_test)));\n+    VERIFY((sfinae_is_callable<int, int, V>(hypot3_test)));\n+    VERIFY((sfinae_is_callable<int, V, int>(hypot3_test)));\n+    VERIFY((sfinae_is_callable<V, T, int>(hypot3_test)));\n+    VERIFY(!(sfinae_is_callable<bool, V, V>(hypot3_test)));\n+    VERIFY(!(sfinae_is_callable<V, bool, V>(hypot3_test)));\n+    VERIFY(!(sfinae_is_callable<V, V, bool>(hypot3_test)));\n+\n+    vir::test::setFuzzyness<float>(0);\n+    vir::test::setFuzzyness<double>(0);\n+    test_values_3arg<V>(\n+      {\n+#ifdef __STDC_IEC_559__\n+\tstd::__quiet_NaN_v<T>, std::__infinity_v<T>, -std::__infinity_v<T>, -0.,\n+\tstd::__norm_min_v<T> / 3, std::__denorm_min_v<T>,\n+#endif\n+\t0., std::__norm_min_v<T>, std::__finite_max_v<T>},\n+      {10000, -std::__finite_max_v<T> / 2, std::__finite_max_v<T> / 2},\n+      MAKE_TESTER(fma));\n+    auto&& fma_test\n+      = [](auto a, auto b, auto c) -> decltype(fma(a, b, c)) { return {}; };\n+    VERIFY((sfinae_is_callable<V, V, V>(fma_test)));\n+    VERIFY((sfinae_is_callable<T, T, V>(fma_test)));\n+    VERIFY((sfinae_is_callable<V, T, T>(fma_test)));\n+    VERIFY((sfinae_is_callable<T, V, T>(fma_test)));\n+    VERIFY((sfinae_is_callable<T, V, V>(fma_test)));\n+    VERIFY((sfinae_is_callable<V, T, V>(fma_test)));\n+    VERIFY((sfinae_is_callable<V, V, T>(fma_test)));\n+    VERIFY((sfinae_is_callable<int, int, V>(fma_test)));\n+    VERIFY((sfinae_is_callable<int, V, int>(fma_test)));\n+    VERIFY((sfinae_is_callable<V, T, int>(fma_test)));\n+    VERIFY((!sfinae_is_callable<V, T, bool>(fma_test)));\n+    VERIFY((!sfinae_is_callable<bool, V, V>(fma_test)));\n+  }"}, {"sha": "975e69a9e356cf3aec5207e52a851a1f265b2254", "filename": "libstdc++-v3/testsuite/experimental/simd/tests/integer_operators.cc", "status": "added", "additions": 218, "deletions": 0, "changes": 218, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02e32295b284bd4f4d038e73ee3118fb0546650e/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fsimd%2Ftests%2Finteger_operators.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02e32295b284bd4f4d038e73ee3118fb0546650e/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fsimd%2Ftests%2Finteger_operators.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fsimd%2Ftests%2Finteger_operators.cc?ref=02e32295b284bd4f4d038e73ee3118fb0546650e", "patch": "@@ -0,0 +1,218 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"bits/verify.h\"\n+#include \"bits/make_vec.h\"\n+#include \"bits/metahelpers.h\"\n+\n+template <typename T, T Begin, T End, T Stride = 1, typename F>\n+  void\n+  for_constexpr(F&& fun)\n+  {\n+    if constexpr (Begin <= End)\n+      {\n+\tfun(std::integral_constant<T, Begin>());\n+\tif constexpr (Begin < End)\n+\t  {\n+\t    for_constexpr<T, Begin + Stride, End, Stride>(static_cast<F&&>(fun));\n+\t  }\n+      }\n+  }\n+\n+template <typename V>\n+  void\n+  test()\n+  {\n+    using T = typename V::value_type;\n+    if constexpr (std::is_integral_v<T>)\n+      {\n+\tconstexpr int nbits(sizeof(T) * __CHAR_BIT__);\n+\tconstexpr int n_promo_bits\n+\t  = std::max(nbits, int(sizeof(int) * __CHAR_BIT__));\n+\n+\t// complement\n+\tCOMPARE(~V(), V(~T()));\n+\tCOMPARE(~V(~T()), V());\n+\n+\t{ // modulus\n+\t  V x = make_vec<V>({3, 4}, 2);\n+\t  COMPARE(x % x, V(0));\n+\t  V y = x - 1;\n+\t  COMPARE(x % y, V(1));\n+\t  y = x + 1;\n+\t  COMPARE(x % y, x);\n+\t  if (std::is_signed<T>::value)\n+\t    {\n+\t      x = -x;\n+\t      COMPARE(x % y, x);\n+\t      x = -y;\n+\t      COMPARE(x % y, V(0));\n+\t      x = x - 1;\n+\t      COMPARE(x % y, V(-1));\n+\t      x %= y;\n+\t      COMPARE(x, V(-1));\n+\t    }\n+\t}\n+\n+\t{ // bit_and\n+\t  V x = make_vec<V>({3, 4, 5}, 8);\n+\t  COMPARE(x & x, x);\n+\t  COMPARE(x & ~x, V());\n+\t  COMPARE(x & V(), V());\n+\t  COMPARE(V() & x, V());\n+\t  V y = make_vec<V>({1, 5, 3}, 8);\n+\t  COMPARE(x & y, make_vec<V>({1, 4, 1}, 8));\n+\t  x &= y;\n+\t  COMPARE(x, make_vec<V>({1, 4, 1}, 8));\n+\t}\n+\n+\t{ // bit_or\n+\t  V x = make_vec<V>({3, 4, 5}, 8);\n+\t  COMPARE(x | x, x);\n+\t  COMPARE(x | ~x, ~V());\n+\t  COMPARE(x | V(), x);\n+\t  COMPARE(V() | x, x);\n+\t  V y = make_vec<V>({1, 5, 3}, 8);\n+\t  COMPARE(x | y, make_vec<V>({3, 5, 7}, 8));\n+\t  x |= y;\n+\t  COMPARE(x, make_vec<V>({3, 5, 7}, 8));\n+\t}\n+\n+\t{ // bit_xor\n+\t  V x = make_vec<V>({3, 4, 5}, 8);\n+\t  COMPARE(x ^ x, V());\n+\t  COMPARE(x ^ ~x, ~V());\n+\t  COMPARE(x ^ V(), x);\n+\t  COMPARE(V() ^ x, x);\n+\t  V y = make_vec<V>({1, 5, 3}, 8);\n+\t  COMPARE(x ^ y, make_vec<V>({2, 1, 6}, 0));\n+\t  x ^= y;\n+\t  COMPARE(x, make_vec<V>({2, 1, 6}, 0));\n+\t}\n+\n+\t{ // bit_shift_left\n+\t  // Note:\n+\t  // - negative RHS or RHS >= max(#bits(T), #bits(int)) is UB\n+\t  // - negative LHS is UB\n+\t  // - shifting into (or over) the sign bit is UB\n+\t  // - unsigned LHS overflow is modulo arithmetic\n+\t  COMPARE(V() << 1, V());\n+\t  for (int i = 0; i < nbits - 1; ++i)\n+\t    {\n+\t      COMPARE(V(1) << i, V(T(1) << i)) << \"i: \" << i;\n+\t    }\n+\t  for_constexpr<int, 0, n_promo_bits - 1>(\n+\t    [](auto shift_ic) {\n+\t      constexpr int shift = shift_ic;\n+\t      const V seq = make_value_unknown(V([&](T i) {\n+\t\tif constexpr (std::is_signed_v<T>)\n+\t\t  {\n+\t\t    const T max = std::__finite_max_v<T> >> shift;\n+\t\t    return max == 0 ? 1 : (std::abs(max - i) % max) + 1;\n+\t\t  }\n+\t\telse\n+\t\t  {\n+\t\t    return ~T() - i;\n+\t\t  }\n+\t      }));\n+\t      const V ref([&](T i) { return T(seq[i] << shift); });\n+\t      COMPARE(seq << shift, ref) << \"seq: \" << seq\n+\t       \t<< \", shift: \" << shift;\n+\t      COMPARE(seq << make_value_unknown(shift), ref)\n+\t\t<< \"seq: \" << seq << \", shift: \" << shift;\n+\t    });\n+\t  {\n+\t    V seq = make_vec<V>({0, 1}, nbits - 2);\n+\t    seq %= nbits - 1;\n+\t    COMPARE(make_vec<V>({0, 1}, 0) << seq,\n+\t\t    V([&](auto i) { return T(T(i & 1) << seq[i]); }))\n+\t      << \"seq = \" << seq;\n+\t    COMPARE(make_vec<V>({1, 0}, 0) << seq,\n+\t\t    V([&](auto i) { return T(T(~i & 1) << seq[i]); }));\n+\t    COMPARE(V(1) << seq, V([&](auto i) { return T(T(1) << seq[i]); }));\n+\t  }\n+\t  if (std::is_unsigned<T>::value)\n+\t    {\n+\t      constexpr int shift_count = nbits - 1;\n+\t      COMPARE(V(1) << shift_count, V(T(1) << shift_count));\n+\t      constexpr T max = // avoid overflow warning in the last COMPARE\n+\t\tstd::is_unsigned<T>::value ? std::__finite_max_v<T> : T(1);\n+\t      COMPARE(V(max) << shift_count, V(max << shift_count))\n+\t\t<< \"shift_count: \" << shift_count;\n+\t    }\n+\t}\n+\n+\t{ // bit_shift_right\n+\t  // Note:\n+\t  // - negative LHS is implementation defined\n+\t  // - negative RHS or RHS >= #bits is UB\n+\t  // - no other UB\n+\t  COMPARE(V(~T()) >> V(0), V(~T()));\n+\t  COMPARE(V(~T()) >> V(make_value_unknown(0)), V(~T()));\n+\t  for (int s = 1; s < nbits; ++s)\n+\t    {\n+\t      COMPARE(V(~T()) >> V(s), V(T(~T()) >> s)) << \"s: \" << s;\n+\t    }\n+\t  for (int s = 1; s < nbits; ++s)\n+\t    {\n+\t      COMPARE(V(~T(1)) >> V(s), V(T(~T(1)) >> s)) << \"s: \" << s;\n+\t    }\n+\t  COMPARE(V(0) >> V(1), V(0));\n+\t  COMPARE(V(1) >> V(1), V(0));\n+\t  COMPARE(V(2) >> V(1), V(1));\n+\t  COMPARE(V(3) >> V(1), V(1));\n+\t  COMPARE(V(7) >> V(2), V(1));\n+\t  for (int j = 0; j < 100; ++j)\n+\t    {\n+\t      const V seq([&](auto i) -> T { return (j + i) % n_promo_bits; });\n+\t      COMPARE(V(1) >> seq, V([&](auto i) { return T(T(1) >> seq[i]); }))\n+\t\t<< \"seq = \" << seq;\n+\t      COMPARE(make_value_unknown(V(1)) >> make_value_unknown(seq),\n+\t\tV([&](auto i) { return T(T(1) >> seq[i]); }))\n+\t\t<< \"seq = \" << seq;\n+\t    }\n+\t  for_constexpr<int, 0, n_promo_bits - 1>([](auto shift_ic) {\n+\t    constexpr int shift = shift_ic;\n+\t    const V seq = make_value_unknown(V([&](int i) {\n+\t      using U = std::make_unsigned_t<T>;\n+\t      return T(~U() >> (i % 32));\n+\t    }));\n+\t    const V ref([&](T i) { return T(seq[i] >> shift); });\n+\t    COMPARE(seq >> shift, ref)\n+\t      << \"seq: \" << seq << \", shift: \" << shift;\n+\t    COMPARE(seq >> make_value_unknown(shift), ref)\n+\t      << \"seq: \" << seq << \", shift: \" << shift;\n+\t  });\n+\t}\n+      }\n+    else\n+      {\n+\tVERIFY((is_substitution_failure<V, V, std::modulus<>>));\n+\tVERIFY((is_substitution_failure<V, V, std::bit_and<>>));\n+\tVERIFY((is_substitution_failure<V, V, std::bit_or<>>));\n+\tVERIFY((is_substitution_failure<V, V, std::bit_xor<>>));\n+\tVERIFY((is_substitution_failure<V, V, bit_shift_left>));\n+\tVERIFY((is_substitution_failure<V, V, bit_shift_right>));\n+\n+\tVERIFY((is_substitution_failure<V&, V, assign_modulus>));\n+\tVERIFY((is_substitution_failure<V&, V, assign_bit_and>));\n+\tVERIFY((is_substitution_failure<V&, V, assign_bit_or>));\n+\tVERIFY((is_substitution_failure<V&, V, assign_bit_xor>));\n+\tVERIFY((is_substitution_failure<V&, V, assign_bit_shift_left>));\n+\tVERIFY((is_substitution_failure<V&, V, assign_bit_shift_right>));\n+      }\n+  }"}, {"sha": "6d994572bf83e38011b03452cc069e2fb33bb9d2", "filename": "libstdc++-v3/testsuite/experimental/simd/tests/ldexp_scalbn_scalbln_modf.cc", "status": "added", "additions": 169, "deletions": 0, "changes": 169, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02e32295b284bd4f4d038e73ee3118fb0546650e/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fsimd%2Ftests%2Fldexp_scalbn_scalbln_modf.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02e32295b284bd4f4d038e73ee3118fb0546650e/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fsimd%2Ftests%2Fldexp_scalbn_scalbln_modf.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fsimd%2Ftests%2Fldexp_scalbn_scalbln_modf.cc?ref=02e32295b284bd4f4d038e73ee3118fb0546650e", "patch": "@@ -0,0 +1,169 @@\n+// test only floattypes\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"bits/verify.h\"\n+#include \"bits/metahelpers.h\"\n+#include \"bits/test_values.h\"\n+\n+template <typename V>\n+  void\n+  test()\n+  {\n+    vir::test::setFuzzyness<float>(0);\n+    vir::test::setFuzzyness<double>(0);\n+\n+    using T = typename V::value_type;\n+\n+    // See https://sourceware.org/bugzilla/show_bug.cgi?id=18031\n+    const bool modf_is_broken = [] {\n+      volatile T x = T(5e20) / 7;\n+      T tmp;\n+      return std::fabs(std::modf(x, &tmp)) >= 1;\n+    }();\n+    if (modf_is_broken)\n+      __builtin_fprintf(stderr,\n+\t\t\t\"NOTE: Skipping modf because std::modf is broken.\\n\");\n+\n+    test_values<V>(\n+      {\n+#ifdef __STDC_IEC_559__\n+\tstd::__quiet_NaN_v<T>,\n+\tstd::__infinity_v<T>,\n+\t-std::__infinity_v<T>,\n+\t-0.,\n+\tstd::__denorm_min_v<T>,\n+\tstd::__norm_min_v<T> / 3,\n+\t-std::__denorm_min_v<T>,\n+\t-std::__norm_min_v<T> / 3,\n+#endif\n+\t+0.,\n+\t+1.3,\n+\t-1.3,\n+\t2.1,\n+\t-2.1,\n+\t0.99,\n+\t0.9,\n+\t-0.9,\n+\t-0.99,\n+\tstd::__norm_min_v<T>,\n+\tstd::__finite_max_v<T>,\n+\t-std::__norm_min_v<T>,\n+\t-std::__finite_max_v<T>},\n+      {10000},\n+      [](const V input) {\n+\tfor (int exp : {-10000, -100, -10, -1, 0, 1, 10, 100, 10000})\n+\t  {\n+\t    const auto totest = ldexp(input, exp);\n+\t    using R = std::remove_const_t<decltype(totest)>;\n+\t    auto&& expected = [&](const auto& v) -> const R {\n+\t      R tmp = {};\n+\t      using std::ldexp;\n+\t      for (std::size_t i = 0; i < R::size(); ++i)\n+\t\t{\n+\t\t  tmp[i] = ldexp(v[i], exp);\n+\t\t}\n+\t      return tmp;\n+\t    };\n+\t    const R expect1 = expected(input);\n+\t    COMPARE(isnan(totest), isnan(expect1))\n+\t      << \"ldexp(\" << input << \", \" << exp << \") = \" << totest\n+\t      << \" != \" << expect1;\n+\t    FUZZY_COMPARE(ldexp(iif(isnan(expect1), 0, input), exp),\n+\t\t\t  expected(iif(isnan(expect1), 0, input)))\n+\t      << \"\\nclean = \" << iif(isnan(expect1), 0, input);\n+\t  }\n+      },\n+      [](const V input) {\n+\tfor (int exp : {-10000, -100, -10, -1, 0, 1, 10, 100, 10000})\n+\t  {\n+\t    const auto totest = scalbn(input, exp);\n+\t    using R = std::remove_const_t<decltype(totest)>;\n+\t    auto&& expected = [&](const auto& v) -> const R {\n+\t      R tmp = {};\n+\t      using std::scalbn;\n+\t      for (std::size_t i = 0; i < R::size(); ++i)\n+\t\t{\n+\t\t  tmp[i] = scalbn(v[i], exp);\n+\t\t}\n+\t      return tmp;\n+\t    };\n+\t    const R expect1 = expected(input);\n+\t    COMPARE(isnan(totest), isnan(expect1))\n+\t      << \"scalbn(\" << input << \", \" << exp << \") = \" << totest\n+\t      << \" != \" << expect1;\n+\t    FUZZY_COMPARE(scalbn(iif(isnan(expect1), 0, input), exp),\n+\t\t\t  expected(iif(isnan(expect1), 0, input)))\n+\t      << \"\\nclean = \" << iif(isnan(expect1), 0, input);\n+\t  }\n+      },\n+      [](const V input) {\n+\tfor (long exp : {-10000, -100, -10, -1, 0, 1, 10, 100, 10000})\n+\t  {\n+\t    const auto totest = scalbln(input, exp);\n+\t    using R = std::remove_const_t<decltype(totest)>;\n+\t    auto&& expected = [&](const auto& v) -> const R {\n+\t      R tmp = {};\n+\t      using std::scalbln;\n+\t      for (std::size_t i = 0; i < R::size(); ++i)\n+\t\t{\n+\t\t  tmp[i] = scalbln(v[i], exp);\n+\t\t}\n+\t      return tmp;\n+\t    };\n+\t    const R expect1 = expected(input);\n+\t    COMPARE(isnan(totest), isnan(expect1))\n+\t      << \"scalbln(\" << input << \", \" << exp << \") = \" << totest\n+\t      << \" != \" << expect1;\n+\t    FUZZY_COMPARE(scalbln(iif(isnan(expect1), 0, input), exp),\n+\t\t\t  expected(iif(isnan(expect1), 0, input)))\n+\t      << \"\\nclean = \" << iif(isnan(expect1), 0, input);\n+\t  }\n+      },\n+      [modf_is_broken](const V input) {\n+\tif (modf_is_broken)\n+\t  return;\n+\tV integral = {};\n+\tconst V totest = modf(input, &integral);\n+\tauto&& expected = [&](const auto& v) -> std::pair<const V, const V> {\n+\t  std::pair<V, V> tmp = {};\n+\t  using std::modf;\n+\t  for (std::size_t i = 0; i < V::size(); ++i)\n+\t    {\n+\t      typename V::value_type tmp2;\n+\t      tmp.first[i] = modf(v[i], &tmp2);\n+\t      tmp.second[i] = tmp2;\n+\t    }\n+\t  return tmp;\n+\t};\n+\tconst auto expect1 = expected(input);\n+#ifdef __STDC_IEC_559__\n+\tCOMPARE(isnan(totest), isnan(expect1.first))\n+\t  << \"modf(\" << input << \", iptr) = \" << totest << \" != \" << expect1;\n+\tCOMPARE(isnan(integral), isnan(expect1.second))\n+\t  << \"modf(\" << input << \", iptr) = \" << totest << \" != \" << expect1;\n+\tCOMPARE(isnan(totest), isnan(integral))\n+\t  << \"modf(\" << input << \", iptr) = \" << totest << \" != \" << expect1;\n+\tconst V clean = iif(isnan(totest), V(), input);\n+#else\n+\tconst V clean = iif(isnormal(input), input, V());\n+#endif\n+\tconst auto expect2 = expected(clean);\n+\tCOMPARE(modf(clean, &integral), expect2.first) << \"\\nclean = \" << clean;\n+\tCOMPARE(integral, expect2.second);\n+      });\n+  }"}, {"sha": "994227c7d5ab24756e79832e6a2d8ca8ac1d719a", "filename": "libstdc++-v3/testsuite/experimental/simd/tests/loadstore.cc", "status": "added", "additions": 229, "deletions": 0, "changes": 229, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02e32295b284bd4f4d038e73ee3118fb0546650e/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fsimd%2Ftests%2Floadstore.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02e32295b284bd4f4d038e73ee3118fb0546650e/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fsimd%2Ftests%2Floadstore.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fsimd%2Ftests%2Floadstore.cc?ref=02e32295b284bd4f4d038e73ee3118fb0546650e", "patch": "@@ -0,0 +1,229 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"bits/verify.h\"\n+#include \"bits/make_vec.h\"\n+#include \"bits/conversions.h\"\n+\n+template <typename V, typename U>\n+  void\n+  load_store()\n+  {\n+    // types, tags, and constants\n+    using T = typename V::value_type;\n+    auto&& gen = make_vec<V>;\n+    using std::experimental::element_aligned;\n+    using std::experimental::vector_aligned;\n+\n+    // stride_alignment: consider V::size() == 6. The only reliable alignment is\n+    // 2 * sizeof(U). I.e. if the first address is aligned to 8 * sizeof(U),\n+    // then the next address is 6 * sizeof(U) larger, thus only aligned to 2 *\n+    // sizeof(U).\n+    // => the LSB determines the stride alignment\n+    constexpr size_t stride_alignment = size_t(1) << __builtin_ctz(V::size());\n+    using stride_aligned_t = std::conditional_t<\n+      V::size() == stride_alignment, decltype(vector_aligned),\n+      std::experimental::overaligned_tag<stride_alignment * sizeof(U)>>;\n+    constexpr stride_aligned_t stride_aligned = {};\n+    constexpr size_t alignment\n+      = 2 * std::experimental::memory_alignment_v<V, U>;\n+    constexpr auto overaligned = std::experimental::overaligned<alignment>;\n+    const V indexes_from_0([](auto i) { return i; });\n+    for (std::size_t i = 0; i < V::size(); ++i)\n+      {\n+\tCOMPARE(indexes_from_0[i], T(i));\n+      }\n+\n+    // loads\n+    cvt_inputs<T, U> test_values;\n+\n+    constexpr auto mem_size\n+      = test_values.size() > 3 * V::size() ? test_values.size() : 3 * V::size();\n+    alignas(std::experimental::memory_alignment_v<V, U> * 2) U mem[mem_size]\n+      = {};\n+    alignas(std::experimental::memory_alignment_v<V, T> * 2)\n+      T reference[mem_size]\n+      = {};\n+    for (std::size_t i = 0; i < test_values.size(); ++i)\n+      {\n+\tconst U value = test_values[i];\n+\tmem[i] = value;\n+\treference[i] = static_cast<T>(value);\n+      }\n+    for (std::size_t i = test_values.size(); i < mem_size; ++i)\n+      {\n+\tmem[i] = U(i);\n+\treference[i] = mem[i];\n+      }\n+\n+    V x(&mem[V::size()], stride_aligned);\n+    auto&& compare = [&](const std::size_t offset) {\n+      static int n = 0;\n+      const V ref(&reference[offset], element_aligned);\n+      for (auto i = 0ul; i < V::size(); ++i)\n+\t{\n+\t  if (is_conversion_undefined<T>(mem[i + offset]))\n+\t    {\n+\t      continue;\n+\t    }\n+\t  COMPARE(x[i], reference[i + offset])\n+\t    << \"\\nbefore conversion: \" << mem[i + offset]\n+\t    << \"\\n   offset = \" << offset << \"\\n        x = \" << x\n+\t    << \"\\nreference = \" << ref << \"\\nx == ref  = \" << (x == ref)\n+\t    << \"\\ncall no. \" << n;\n+\t}\n+      ++n;\n+    };\n+    compare(V::size());\n+    x = V{mem, overaligned};\n+    compare(0);\n+    x = {&mem[1], element_aligned};\n+    compare(1);\n+\n+    x.copy_from(&mem[V::size()], stride_aligned);\n+    compare(V::size());\n+    x.copy_from(&mem[1], element_aligned);\n+    compare(1);\n+    x.copy_from(mem, vector_aligned);\n+    compare(0);\n+\n+    for (std::size_t i = 0; i < mem_size - V::size(); ++i)\n+      {\n+\tx.copy_from(&mem[i], element_aligned);\n+\tcompare(i);\n+      }\n+\n+    for (std::size_t i = 0; i < test_values.size(); ++i)\n+      {\n+\tmem[i] = U(i);\n+      }\n+    x = indexes_from_0;\n+    using M = typename V::mask_type;\n+    const M alternating_mask = make_mask<M>({0, 1});\n+    where(alternating_mask, x).copy_from(&mem[V::size()], stride_aligned);\n+\n+    const V indexes_from_size = gen({T(V::size())}, 1);\n+    COMPARE(x == indexes_from_size, alternating_mask)\n+      << \"x: \" << x << \"\\nindexes_from_size: \" << indexes_from_size;\n+    COMPARE(x == indexes_from_0, !alternating_mask);\n+    where(alternating_mask, x).copy_from(&mem[1], element_aligned);\n+\n+    const V indexes_from_1 = gen({1, 2, 3, 4}, 4);\n+    COMPARE(x == indexes_from_1, alternating_mask);\n+    COMPARE(x == indexes_from_0, !alternating_mask);\n+    where(!alternating_mask, x).copy_from(mem, overaligned);\n+    COMPARE(x == indexes_from_0, !alternating_mask);\n+    COMPARE(x == indexes_from_1, alternating_mask);\n+\n+    x = where(alternating_mask, V()).copy_from(&mem[V::size()], stride_aligned);\n+    COMPARE(x == indexes_from_size, alternating_mask);\n+    COMPARE(x == 0, !alternating_mask);\n+\n+    x = where(!alternating_mask, V()).copy_from(&mem[1], element_aligned);\n+    COMPARE(x == indexes_from_1, !alternating_mask);\n+    COMPARE(x == 0, alternating_mask);\n+\n+    // stores\n+    auto&& init_mem = [&mem](U init) {\n+      for (auto i = mem_size; i; --i)\n+\t{\n+\t  mem[i - 1] = init;\n+\t}\n+    };\n+    init_mem(-1);\n+    x = indexes_from_1;\n+    x.copy_to(&mem[V::size()], stride_aligned);\n+    std::size_t i = 0;\n+    for (; i < V::size(); ++i)\n+      {\n+\tCOMPARE(mem[i], U(-1)) << \"i: \" << i;\n+      }\n+    for (; i < 2 * V::size(); ++i)\n+      {\n+\tCOMPARE(mem[i], U(i - V::size() + 1)) << \"i: \" << i;\n+      }\n+    for (; i < 3 * V::size(); ++i)\n+      {\n+\tCOMPARE(mem[i], U(-1)) << \"i: \" << i;\n+      }\n+\n+    init_mem(-1);\n+    x.copy_to(&mem[1], element_aligned);\n+    COMPARE(mem[0], U(-1));\n+    for (i = 1; i <= V::size(); ++i)\n+      {\n+\tCOMPARE(mem[i], U(i));\n+      }\n+    for (; i < 3 * V::size(); ++i)\n+      {\n+\tCOMPARE(mem[i], U(-1));\n+      }\n+\n+    init_mem(-1);\n+    x.copy_to(mem, vector_aligned);\n+    for (i = 0; i < V::size(); ++i)\n+      {\n+\tCOMPARE(mem[i], U(i + 1));\n+      }\n+    for (; i < 3 * V::size(); ++i)\n+      {\n+\tCOMPARE(mem[i], U(-1));\n+      }\n+\n+    init_mem(-1);\n+    where(alternating_mask, indexes_from_0)\n+      .copy_to(&mem[V::size()], stride_aligned);\n+    for (i = 0; i < V::size() + 1; ++i)\n+      {\n+\tCOMPARE(mem[i], U(-1));\n+      }\n+    for (; i < 2 * V::size(); i += 2)\n+      {\n+\tCOMPARE(mem[i], U(i - V::size()));\n+      }\n+    for (i = V::size() + 2; i < 2 * V::size(); i += 2)\n+      {\n+\tCOMPARE(mem[i], U(-1));\n+      }\n+    for (; i < 3 * V::size(); ++i)\n+      {\n+\tCOMPARE(mem[i], U(-1));\n+      }\n+  }\n+\n+template <typename V>\n+  void\n+  test()\n+  {\n+    load_store<V, long double>();\n+    load_store<V, double>();\n+    load_store<V, float>();\n+    load_store<V, long long>();\n+    load_store<V, unsigned long long>();\n+    load_store<V, unsigned long>();\n+    load_store<V, long>();\n+    load_store<V, int>();\n+    load_store<V, unsigned int>();\n+    load_store<V, short>();\n+    load_store<V, unsigned short>();\n+    load_store<V, char>();\n+    load_store<V, signed char>();\n+    load_store<V, unsigned char>();\n+    load_store<V, char32_t>();\n+    load_store<V, char16_t>();\n+    load_store<V, wchar_t>();\n+  }"}, {"sha": "29c686db697b2edab68fbf890b912831d06f14ca", "filename": "libstdc++-v3/testsuite/experimental/simd/tests/logarithm.cc", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02e32295b284bd4f4d038e73ee3118fb0546650e/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fsimd%2Ftests%2Flogarithm.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02e32295b284bd4f4d038e73ee3118fb0546650e/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fsimd%2Ftests%2Flogarithm.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fsimd%2Ftests%2Flogarithm.cc?ref=02e32295b284bd4f4d038e73ee3118fb0546650e", "patch": "@@ -0,0 +1,83 @@\n+// test only floattypes\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"bits/verify.h\"\n+#include \"bits/metahelpers.h\"\n+#include \"bits/mathreference.h\"\n+#include \"bits/test_values.h\"\n+\n+template <typename V>\n+  void\n+  test()\n+  {\n+    vir::test::setFuzzyness<float>(1);\n+    vir::test::setFuzzyness<double>(1);\n+\n+    using T = typename V::value_type;\n+    constexpr T nan = std::__quiet_NaN_v<T>;\n+    constexpr T inf = std::__infinity_v<T>;\n+    constexpr T denorm_min = std::__denorm_min_v<T>;\n+    constexpr T norm_min = std::__norm_min_v<T>;\n+    constexpr T min = std::__finite_min_v<T>;\n+    constexpr T max = std::__finite_max_v<T>;\n+    test_values<V>({1,\n+\t\t    2,\n+\t\t    4,\n+\t\t    8,\n+\t\t    16,\n+\t\t    32,\n+\t\t    64,\n+\t\t    128,\n+\t\t    256,\n+\t\t    512,\n+\t\t    1024,\n+\t\t    2048,\n+\t\t    3,\n+\t\t    5,\n+\t\t    7,\n+\t\t    15,\n+\t\t    17,\n+\t\t    31,\n+\t\t    33,\n+\t\t    63,\n+\t\t    65,\n+#ifdef __STDC_IEC_559__\n+\t\t    nan,\n+\t\t    inf,\n+\t\t    -inf,\n+\t\t    denorm_min,\n+\t\t    -denorm_min,\n+\t\t    norm_min / 3,\n+\t\t    -norm_min / 3,\n+\t\t    -T(),\n+\t\t    -norm_min,\n+\t\t    min,\n+\t\t    T(),\n+#endif\n+\t\t    norm_min,\n+\t\t    max},\n+\t\t   {10000,\n+#ifdef __STDC_IEC_559__\n+\t\t    min / 2,\n+#else\n+\t\t    norm_min,\n+#endif\n+\t\t    max / 2},\n+\t\t   MAKE_TESTER(log), MAKE_TESTER(log10), MAKE_TESTER(log1p),\n+\t\t   MAKE_TESTER(log2), MAKE_TESTER(logb));\n+  }"}, {"sha": "7fc8201caf6d4cb9227d9d8878afe791c9585a3c", "filename": "libstdc++-v3/testsuite/experimental/simd/tests/mask_broadcast.cc", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02e32295b284bd4f4d038e73ee3118fb0546650e/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fsimd%2Ftests%2Fmask_broadcast.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02e32295b284bd4f4d038e73ee3118fb0546650e/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fsimd%2Ftests%2Fmask_broadcast.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fsimd%2Ftests%2Fmask_broadcast.cc?ref=02e32295b284bd4f4d038e73ee3118fb0546650e", "patch": "@@ -0,0 +1,67 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"bits/verify.h\"\n+#include \"bits/metahelpers.h\"\n+\n+template <typename V>\n+  void\n+  test()\n+  {\n+    using M = typename V::mask_type;\n+    static_assert(std::is_convertible<typename M::reference, bool>::value,\n+\t\t  \"A smart_reference<simd_mask> must be convertible to bool.\");\n+    static_assert(\n+      std::is_same<bool, decltype(std::declval<const typename M::reference&>()\n+\t\t\t\t  == true)>::value,\n+      \"A smart_reference<simd_mask> must be comparable against bool.\");\n+    static_assert(\n+      vir::test::sfinae_is_callable<typename M::reference&&, bool>(\n+\t[](auto&& a, auto&& b) -> decltype(std::declval<decltype(a)>()\n+\t\t\t\t\t   == std::declval<decltype(b)>()) {\n+\t  return {};\n+\t}),\n+      \"A smart_reference<simd_mask> must be comparable against bool.\");\n+    VERIFY(std::experimental::is_simd_mask_v<M>);\n+\n+    {\n+      M x;     // uninitialized\n+      x = M{}; // default broadcasts 0\n+      COMPARE(x, M(false));\n+      COMPARE(x, M());\n+      COMPARE(x, M{});\n+      x = M(); // default broadcasts 0\n+      COMPARE(x, M(false));\n+      COMPARE(x, M());\n+      COMPARE(x, M{});\n+      x = x;\n+      for (std::size_t i = 0; i < M::size(); ++i)\n+\t{\n+\t  COMPARE(x[i], false);\n+\t}\n+    }\n+\n+    M x(true);\n+    M y(false);\n+    for (std::size_t i = 0; i < M::size(); ++i)\n+      {\n+\tCOMPARE(x[i], true);\n+\tCOMPARE(y[i], false);\n+      }\n+    y = M(true);\n+    COMPARE(x, y);\n+  }"}, {"sha": "8cec912250aa3133f506b026934b56483bdb1128", "filename": "libstdc++-v3/testsuite/experimental/simd/tests/mask_conversions.cc", "status": "added", "additions": 113, "deletions": 0, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02e32295b284bd4f4d038e73ee3118fb0546650e/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fsimd%2Ftests%2Fmask_conversions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02e32295b284bd4f4d038e73ee3118fb0546650e/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fsimd%2Ftests%2Fmask_conversions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fsimd%2Ftests%2Fmask_conversions.cc?ref=02e32295b284bd4f4d038e73ee3118fb0546650e", "patch": "@@ -0,0 +1,113 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"bits/verify.h\"\n+\n+namespace stdx = std::experimental;\n+\n+template <typename From, typename To>\n+  void\n+  conversions()\n+  {\n+    using ToV = typename To::simd_type;\n+\n+    using stdx::simd_cast;\n+    using stdx::static_simd_cast;\n+    using stdx::__proposed::resizing_simd_cast;\n+\n+    auto x = resizing_simd_cast<To>(From());\n+    COMPARE(typeid(x), typeid(To));\n+    COMPARE(x, To());\n+\n+    x = resizing_simd_cast<To>(From(true));\n+    const To ref = ToV([](auto i) { return i; }) < int(From::size());\n+    COMPARE(x, ref) << \"converted from: \" << From(true);\n+\n+    const ullong all_bits = ~ullong() >> (64 - From::size());\n+    for (ullong bit_pos = 1; bit_pos /*until overflow*/; bit_pos *= 2)\n+      {\n+\tfor (ullong bits : {bit_pos & all_bits, ~bit_pos & all_bits})\n+\t  {\n+\t    const auto from = From::__from_bitset(bits);\n+\t    const auto to = resizing_simd_cast<To>(from);\n+\t    COMPARE(to, To::__from_bitset(bits))\n+\t      << \"\\nfrom: \" << from << \"\\nbits: \" << std::hex << bits << std::dec;\n+\t    for (std::size_t i = 0; i < To::size(); ++i)\n+\t      {\n+\t\tCOMPARE(to[i], (bits >> i) & 1)\n+\t\t  << \"\\nfrom: \" << from << \"\\nto: \" << to\n+\t\t  << \"\\nbits: \" << std::hex << bits << std::dec << \"\\ni: \" << i;\n+\t      }\n+\t  }\n+      }\n+  }\n+\n+template <typename T, typename V, typename = void>\n+  struct rebind_or_max_fixed\n+  {\n+    using type = stdx::rebind_simd_t<\n+      T, stdx::resize_simd_t<stdx::simd_abi::max_fixed_size<T>, V>>;\n+  };\n+\n+template <typename T, typename V>\n+  struct rebind_or_max_fixed<T, V, std::void_t<stdx::rebind_simd_t<T, V>>>\n+  {\n+    using type = stdx::rebind_simd_t<T, V>;\n+  };\n+\n+template <typename From, typename To>\n+  void\n+  apply_abis()\n+  {\n+    using M0 = typename rebind_or_max_fixed<To, From>::type;\n+    using M1 = stdx::native_simd_mask<To>;\n+    using M2 = stdx::simd_mask<To>;\n+    using M3 = stdx::simd_mask<To, stdx::simd_abi::scalar>;\n+\n+    using std::is_same_v;\n+    conversions<From, M0>();\n+    if constexpr (!is_same_v<M1, M0>)\n+      conversions<From, M1>();\n+    if constexpr (!is_same_v<M2, M0> && !is_same_v<M2, M1>)\n+      conversions<From, M2>();\n+    if constexpr (!is_same_v<M3, M0> && !is_same_v<M3, M1> && !is_same_v<M3, M2>)\n+      conversions<From, M3>();\n+  }\n+\n+template <typename V>\n+  void\n+  test()\n+  {\n+    using M = typename V::mask_type;\n+    apply_abis<M, ldouble>();\n+    apply_abis<M, double>();\n+    apply_abis<M, float>();\n+    apply_abis<M, ullong>();\n+    apply_abis<M, llong>();\n+    apply_abis<M, ulong>();\n+    apply_abis<M, long>();\n+    apply_abis<M, uint>();\n+    apply_abis<M, int>();\n+    apply_abis<M, ushort>();\n+    apply_abis<M, short>();\n+    apply_abis<M, uchar>();\n+    apply_abis<M, schar>();\n+    apply_abis<M, char>();\n+    apply_abis<M, wchar_t>();\n+    apply_abis<M, char16_t>();\n+    apply_abis<M, char32_t>();\n+  }"}, {"sha": "e1760e3f37f583ae2ed1af688b880815eeda1d74", "filename": "libstdc++-v3/testsuite/experimental/simd/tests/mask_implicit_cvt.cc", "status": "added", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02e32295b284bd4f4d038e73ee3118fb0546650e/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fsimd%2Ftests%2Fmask_implicit_cvt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02e32295b284bd4f4d038e73ee3118fb0546650e/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fsimd%2Ftests%2Fmask_implicit_cvt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fsimd%2Ftests%2Fmask_implicit_cvt.cc?ref=02e32295b284bd4f4d038e73ee3118fb0546650e", "patch": "@@ -0,0 +1,102 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"bits/verify.h\"\n+#include \"bits/metahelpers.h\"\n+\n+template <class M, class M2>\n+  constexpr bool assign_should_work\n+    = std::is_same<M, M2>::value\n+\t|| (std::is_same<typename M::abi_type,\n+\t\t\t std::experimental::simd_abi::fixed_size<M::size()>>::value\n+\t      && std::is_same<typename M::abi_type, typename M2::abi_type>::value);\n+\n+template <class M, class M2>\n+  constexpr bool assign_should_not_work = !assign_should_work<M, M2>;\n+\n+template <class L, class R>\n+  std::enable_if_t<assign_should_work<L, R>>\n+  implicit_conversions_test()\n+  {\n+    L x = R(true);\n+    COMPARE(x, L(true));\n+    x = R(false);\n+    COMPARE(x, L(false));\n+    R y(false);\n+    y[0] = true;\n+    x = y;\n+    L ref(false);\n+    ref[0] = true;\n+    COMPARE(x, ref);\n+  }\n+\n+template <class L, class R>\n+  std::enable_if_t<assign_should_not_work<L, R>>\n+  implicit_conversions_test()\n+  {\n+    VERIFY((is_substitution_failure<L&, R, assignment>) );\n+  }\n+\n+template <typename V>\n+  void\n+  test()\n+  {\n+    using M = typename V::mask_type;\n+    using std::experimental::fixed_size_simd_mask;\n+    using std::experimental::native_simd_mask;\n+    using std::experimental::simd_mask;\n+\n+    implicit_conversions_test<M, simd_mask<ldouble>>();\n+    implicit_conversions_test<M, simd_mask<double>>();\n+    implicit_conversions_test<M, simd_mask<float>>();\n+    implicit_conversions_test<M, simd_mask<ullong>>();\n+    implicit_conversions_test<M, simd_mask<llong>>();\n+    implicit_conversions_test<M, simd_mask<ulong>>();\n+    implicit_conversions_test<M, simd_mask<long>>();\n+    implicit_conversions_test<M, simd_mask<uint>>();\n+    implicit_conversions_test<M, simd_mask<int>>();\n+    implicit_conversions_test<M, simd_mask<ushort>>();\n+    implicit_conversions_test<M, simd_mask<short>>();\n+    implicit_conversions_test<M, simd_mask<uchar>>();\n+    implicit_conversions_test<M, simd_mask<schar>>();\n+    implicit_conversions_test<M, native_simd_mask<ldouble>>();\n+    implicit_conversions_test<M, native_simd_mask<double>>();\n+    implicit_conversions_test<M, native_simd_mask<float>>();\n+    implicit_conversions_test<M, native_simd_mask<ullong>>();\n+    implicit_conversions_test<M, native_simd_mask<llong>>();\n+    implicit_conversions_test<M, native_simd_mask<ulong>>();\n+    implicit_conversions_test<M, native_simd_mask<long>>();\n+    implicit_conversions_test<M, native_simd_mask<uint>>();\n+    implicit_conversions_test<M, native_simd_mask<int>>();\n+    implicit_conversions_test<M, native_simd_mask<ushort>>();\n+    implicit_conversions_test<M, native_simd_mask<short>>();\n+    implicit_conversions_test<M, native_simd_mask<uchar>>();\n+    implicit_conversions_test<M, native_simd_mask<schar>>();\n+    implicit_conversions_test<M, fixed_size_simd_mask<ldouble, M::size()>>();\n+    implicit_conversions_test<M, fixed_size_simd_mask<double, M::size()>>();\n+    implicit_conversions_test<M, fixed_size_simd_mask<float, M::size()>>();\n+    implicit_conversions_test<M, fixed_size_simd_mask<ullong, M::size()>>();\n+    implicit_conversions_test<M, fixed_size_simd_mask<llong, M::size()>>();\n+    implicit_conversions_test<M, fixed_size_simd_mask<ulong, M::size()>>();\n+    implicit_conversions_test<M, fixed_size_simd_mask<long, M::size()>>();\n+    implicit_conversions_test<M, fixed_size_simd_mask<uint, M::size()>>();\n+    implicit_conversions_test<M, fixed_size_simd_mask<int, M::size()>>();\n+    implicit_conversions_test<M, fixed_size_simd_mask<ushort, M::size()>>();\n+    implicit_conversions_test<M, fixed_size_simd_mask<short, M::size()>>();\n+    implicit_conversions_test<M, fixed_size_simd_mask<uchar, M::size()>>();\n+    implicit_conversions_test<M, fixed_size_simd_mask<schar, M::size()>>();\n+  }"}, {"sha": "0f43428b7c60a633c41deda4c6304b36b4b647d6", "filename": "libstdc++-v3/testsuite/experimental/simd/tests/mask_loadstore.cc", "status": "added", "additions": 161, "deletions": 0, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02e32295b284bd4f4d038e73ee3118fb0546650e/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fsimd%2Ftests%2Fmask_loadstore.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02e32295b284bd4f4d038e73ee3118fb0546650e/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fsimd%2Ftests%2Fmask_loadstore.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fsimd%2Ftests%2Fmask_loadstore.cc?ref=02e32295b284bd4f4d038e73ee3118fb0546650e", "patch": "@@ -0,0 +1,161 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"bits/verify.h\"\n+\n+// simd_mask generator functions\n+template <class M>\n+  M\n+  make_mask(const std::initializer_list<bool>& init)\n+  {\n+    std::size_t i = 0;\n+    M r = {};\n+    for (;;)\n+      {\n+\tfor (bool x : init)\n+\t  {\n+\t    r[i] = x;\n+\t    if (++i == M::size())\n+\t      {\n+\t\treturn r;\n+\t      }\n+\t  }\n+      }\n+  }\n+\n+template <class M>\n+  M\n+  make_alternating_mask()\n+  {\n+    return make_mask<M>({false, true});\n+  }\n+\n+template <typename V>\n+  void\n+  test()\n+  {\n+    using M = typename V::mask_type;\n+    // loads\n+    constexpr size_t alignment = 2 * std::experimental::memory_alignment_v<M>;\n+    alignas(alignment) bool mem[3 * M::size()];\n+    std::memset(mem, 0, sizeof(mem));\n+    for (std::size_t i = 1; i < sizeof(mem) / sizeof(*mem); i += 2)\n+      {\n+\tCOMPARE(mem[i - 1], false);\n+\tmem[i] = true;\n+      }\n+    using std::experimental::element_aligned;\n+    using std::experimental::vector_aligned;\n+    constexpr size_t stride_alignment\n+      = M::size() & 1\n+\t  ? 1\n+\t  : M::size() & 2\n+\t  ? 2\n+\t  : M::size() & 4\n+\t  ? 4\n+\t  : M::size() & 8\n+\t  ? 8\n+\t  : M::size() & 16\n+\t  ? 16\n+\t  : M::size() & 32\n+\t  ? 32\n+\t  : M::size() & 64\n+\t  ? 64\n+\t  : M::size() & 128 ? 128\n+\t\t\t    : M::size() & 256 ? 256 : 512;\n+    using stride_aligned_t = std::conditional_t<\n+      M::size() == stride_alignment, decltype(vector_aligned),\n+      std::experimental::overaligned_tag<stride_alignment * sizeof(bool)>>;\n+    constexpr stride_aligned_t stride_aligned = {};\n+    constexpr auto overaligned = std::experimental::overaligned<alignment>;\n+\n+    const M alternating_mask = make_alternating_mask<M>();\n+\n+    M x(&mem[M::size()], stride_aligned);\n+    COMPARE(x, M::size() % 2 == 1 ? !alternating_mask : alternating_mask)\n+      << x.__to_bitset()\n+      << \", alternating_mask: \" << alternating_mask.__to_bitset();\n+    x = {&mem[1], element_aligned};\n+    COMPARE(x, !alternating_mask);\n+    x = M{mem, overaligned};\n+    COMPARE(x, alternating_mask);\n+\n+    x.copy_from(&mem[M::size()], stride_aligned);\n+    COMPARE(x, M::size() % 2 == 1 ? !alternating_mask : alternating_mask);\n+    x.copy_from(&mem[1], element_aligned);\n+    COMPARE(x, !alternating_mask);\n+    x.copy_from(mem, vector_aligned);\n+    COMPARE(x, alternating_mask);\n+\n+    x = !alternating_mask;\n+    where(alternating_mask, x).copy_from(&mem[M::size()], stride_aligned);\n+    COMPARE(x, M::size() % 2 == 1 ? !alternating_mask : M{true});\n+    x = M(true);                                                    // 1111\n+    where(alternating_mask, x).copy_from(&mem[1], element_aligned); // load .0.0\n+    COMPARE(x, !alternating_mask);                                  // 1010\n+    where(alternating_mask, x).copy_from(mem, overaligned);         // load .1.1\n+    COMPARE(x, M{true});                                            // 1111\n+\n+    // stores\n+    memset(mem, 0, sizeof(mem));\n+    x = M(true);\n+    x.copy_to(&mem[M::size()], stride_aligned);\n+    std::size_t i = 0;\n+    for (; i < M::size(); ++i)\n+      {\n+\tCOMPARE(mem[i], false);\n+      }\n+    for (; i < 2 * M::size(); ++i)\n+      {\n+\tCOMPARE(mem[i], true) << \"i: \" << i << \", x: \" << x;\n+      }\n+    for (; i < 3 * M::size(); ++i)\n+      {\n+\tCOMPARE(mem[i], false);\n+      }\n+    memset(mem, 0, sizeof(mem));\n+    x.copy_to(&mem[1], element_aligned);\n+    COMPARE(mem[0], false);\n+    for (i = 1; i <= M::size(); ++i)\n+      {\n+\tCOMPARE(mem[i], true);\n+      }\n+    for (; i < 3 * M::size(); ++i)\n+      {\n+\tCOMPARE(mem[i], false);\n+      }\n+    memset(mem, 0, sizeof(mem));\n+    alternating_mask.copy_to(mem, overaligned);\n+    for (i = 0; i < M::size(); ++i)\n+      {\n+\tCOMPARE(mem[i], (i & 1) == 1);\n+      }\n+    for (; i < 3 * M::size(); ++i)\n+      {\n+\tCOMPARE(mem[i], false);\n+      }\n+    x.copy_to(mem, vector_aligned);\n+    where(alternating_mask, !x).copy_to(mem, overaligned);\n+    for (i = 0; i < M::size(); ++i)\n+      {\n+\tCOMPARE(mem[i], i % 2 == 0);\n+      }\n+    for (; i < 3 * M::size(); ++i)\n+      {\n+\tCOMPARE(mem[i], false);\n+      }\n+  }"}, {"sha": "738b97c3dca8aec72d65d3adbc3cc3487297c3ce", "filename": "libstdc++-v3/testsuite/experimental/simd/tests/mask_operator_cvt.cc", "status": "added", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02e32295b284bd4f4d038e73ee3118fb0546650e/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fsimd%2Ftests%2Fmask_operator_cvt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02e32295b284bd4f4d038e73ee3118fb0546650e/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fsimd%2Ftests%2Fmask_operator_cvt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fsimd%2Ftests%2Fmask_operator_cvt.cc?ref=02e32295b284bd4f4d038e73ee3118fb0546650e", "patch": "@@ -0,0 +1,111 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"bits/verify.h\"\n+#include \"bits/metahelpers.h\"\n+\n+using schar = signed char;\n+using uchar = unsigned char;\n+using ushort = unsigned short;\n+using uint = unsigned int;\n+using ulong = unsigned long;\n+using llong = long long;\n+using ullong = unsigned long long;\n+using ldouble = long double;\n+using wchar = wchar_t;\n+using char16 = char16_t;\n+using char32 = char32_t;\n+\n+template <typename M0, typename M1>\n+  constexpr bool\n+  bit_and_is_illformed()\n+  {\n+    return is_substitution_failure<M0, M1, std::bit_and<>>;\n+  }\n+\n+template <typename M0, typename M1>\n+  void\n+  test_binary_op_cvt()\n+  {\n+    COMPARE((bit_and_is_illformed<M0, M1>()), !(std::is_same_v<M0, M1>) );\n+  }\n+\n+template <typename V>\n+  void\n+  test()\n+  {\n+    using M = typename V::mask_type;\n+    // binary ops without conversions work\n+    COMPARE(typeid(M() & M()), typeid(M));\n+\n+    // nothing else works: no implicit conv. or ambiguous\n+    using std::experimental::fixed_size_simd_mask;\n+    using std::experimental::native_simd_mask;\n+    using std::experimental::simd_mask;\n+    test_binary_op_cvt<M, bool>();\n+\n+    test_binary_op_cvt<M, simd_mask<ldouble>>();\n+    test_binary_op_cvt<M, simd_mask<double>>();\n+    test_binary_op_cvt<M, simd_mask<float>>();\n+    test_binary_op_cvt<M, simd_mask<ullong>>();\n+    test_binary_op_cvt<M, simd_mask<llong>>();\n+    test_binary_op_cvt<M, simd_mask<ulong>>();\n+    test_binary_op_cvt<M, simd_mask<long>>();\n+    test_binary_op_cvt<M, simd_mask<uint>>();\n+    test_binary_op_cvt<M, simd_mask<int>>();\n+    test_binary_op_cvt<M, simd_mask<ushort>>();\n+    test_binary_op_cvt<M, simd_mask<short>>();\n+    test_binary_op_cvt<M, simd_mask<uchar>>();\n+    test_binary_op_cvt<M, simd_mask<schar>>();\n+    test_binary_op_cvt<M, simd_mask<wchar>>();\n+    test_binary_op_cvt<M, simd_mask<char16>>();\n+    test_binary_op_cvt<M, simd_mask<char32>>();\n+\n+    test_binary_op_cvt<M, native_simd_mask<ldouble>>();\n+    test_binary_op_cvt<M, native_simd_mask<double>>();\n+    test_binary_op_cvt<M, native_simd_mask<float>>();\n+    test_binary_op_cvt<M, native_simd_mask<ullong>>();\n+    test_binary_op_cvt<M, native_simd_mask<llong>>();\n+    test_binary_op_cvt<M, native_simd_mask<ulong>>();\n+    test_binary_op_cvt<M, native_simd_mask<long>>();\n+    test_binary_op_cvt<M, native_simd_mask<uint>>();\n+    test_binary_op_cvt<M, native_simd_mask<int>>();\n+    test_binary_op_cvt<M, native_simd_mask<ushort>>();\n+    test_binary_op_cvt<M, native_simd_mask<short>>();\n+    test_binary_op_cvt<M, native_simd_mask<uchar>>();\n+    test_binary_op_cvt<M, native_simd_mask<schar>>();\n+    test_binary_op_cvt<M, native_simd_mask<wchar>>();\n+    test_binary_op_cvt<M, native_simd_mask<char16>>();\n+    test_binary_op_cvt<M, native_simd_mask<char32>>();\n+\n+    test_binary_op_cvt<M, fixed_size_simd_mask<ldouble, 2>>();\n+    test_binary_op_cvt<M, fixed_size_simd_mask<double, 2>>();\n+    test_binary_op_cvt<M, fixed_size_simd_mask<float, 2>>();\n+    test_binary_op_cvt<M, fixed_size_simd_mask<ullong, 2>>();\n+    test_binary_op_cvt<M, fixed_size_simd_mask<llong, 2>>();\n+    test_binary_op_cvt<M, fixed_size_simd_mask<ulong, 2>>();\n+    test_binary_op_cvt<M, fixed_size_simd_mask<long, 2>>();\n+    test_binary_op_cvt<M, fixed_size_simd_mask<uint, 2>>();\n+    test_binary_op_cvt<M, fixed_size_simd_mask<int, 2>>();\n+    test_binary_op_cvt<M, fixed_size_simd_mask<ushort, 2>>();\n+    test_binary_op_cvt<M, fixed_size_simd_mask<short, 2>>();\n+    test_binary_op_cvt<M, fixed_size_simd_mask<uchar, 2>>();\n+    test_binary_op_cvt<M, fixed_size_simd_mask<schar, 2>>();\n+    test_binary_op_cvt<M, fixed_size_simd_mask<wchar, 2>>();\n+    test_binary_op_cvt<M, fixed_size_simd_mask<char16, 2>>();\n+    test_binary_op_cvt<M, fixed_size_simd_mask<char32, 2>>();\n+  }"}, {"sha": "58255cf1e1bad91dfa6ec0161c3d60bebc84b0bf", "filename": "libstdc++-v3/testsuite/experimental/simd/tests/mask_operators.cc", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02e32295b284bd4f4d038e73ee3118fb0546650e/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fsimd%2Ftests%2Fmask_operators.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02e32295b284bd4f4d038e73ee3118fb0546650e/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fsimd%2Ftests%2Fmask_operators.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fsimd%2Ftests%2Fmask_operators.cc?ref=02e32295b284bd4f4d038e73ee3118fb0546650e", "patch": "@@ -0,0 +1,57 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"bits/verify.h\"\n+#include \"bits/metahelpers.h\"\n+\n+template <typename V>\n+  void\n+  test()\n+  {\n+    using M = typename V::mask_type;\n+    { // compares\n+      M x(true), y(false);\n+      VERIFY(all_of(x == x));\n+      VERIFY(all_of(x != y));\n+      VERIFY(all_of(y != x));\n+      VERIFY(!all_of(x != x));\n+      VERIFY(!all_of(x == y));\n+      VERIFY(!all_of(y == x));\n+    }\n+    { // subscripting\n+      M x(true);\n+      for (std::size_t i = 0; i < M::size(); ++i)\n+\t{\n+\t  COMPARE(x[i], true) << \"\\nx: \" << x << \", i: \" << i;\n+\t  x[i] = !x[i];\n+\t}\n+      COMPARE(x, M{false});\n+      for (std::size_t i = 0; i < M::size(); ++i)\n+\t{\n+\t  COMPARE(x[i], false) << \"\\nx: \" << x << \", i: \" << i;\n+\t  x[i] = !x[i];\n+\t}\n+      COMPARE(x, M{true});\n+    }\n+    { // negation\n+      M x(false);\n+      M y = !x;\n+      COMPARE(y, M{true});\n+      COMPARE(!y, x);\n+    }\n+  }\n+"}, {"sha": "1190eaf54573d1cd90db4759936d8a5514cb7e71", "filename": "libstdc++-v3/testsuite/experimental/simd/tests/mask_reductions.cc", "status": "added", "additions": 226, "deletions": 0, "changes": 226, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02e32295b284bd4f4d038e73ee3118fb0546650e/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fsimd%2Ftests%2Fmask_reductions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02e32295b284bd4f4d038e73ee3118fb0546650e/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fsimd%2Ftests%2Fmask_reductions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fsimd%2Ftests%2Fmask_reductions.cc?ref=02e32295b284bd4f4d038e73ee3118fb0546650e", "patch": "@@ -0,0 +1,226 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"bits/verify.h\"\n+#include \"bits/metahelpers.h\"\n+\n+// simd_mask generator functions\n+template <class M>\n+  M\n+  make_mask(const std::initializer_list<bool>& init)\n+  {\n+    std::size_t i = 0;\n+    M r = {};\n+    for (;;)\n+      {\n+\tfor (bool x : init)\n+\t  {\n+\t    r[i] = x;\n+\t    if (++i == M::size())\n+\t      {\n+\t\treturn r;\n+\t      }\n+\t  }\n+      }\n+  }\n+\n+template <class M>\n+  M\n+  make_alternating_mask()\n+  {\n+    return make_mask<M>({false, true});\n+  }\n+\n+template <typename V>\n+  void\n+  test()\n+  {\n+    using M = typename V::mask_type;\n+    const M alternating_mask = make_alternating_mask<M>();\n+    COMPARE(alternating_mask[0], false); // assumption below\n+    auto&& gen = make_mask<M>;\n+\n+    // all_of\n+    VERIFY(all_of(M{true}));\n+    VERIFY(!all_of(alternating_mask));\n+    VERIFY(!all_of(M{false}));\n+    using std::experimental::all_of;\n+    VERIFY(all_of(true));\n+    VERIFY(!all_of(false));\n+    VERIFY(sfinae_is_callable<bool>(\n+\t[](auto x) -> decltype(std::experimental::all_of(x)) { return {}; }));\n+    VERIFY(!sfinae_is_callable<int>(\n+\t[](auto x) -> decltype(std::experimental::all_of(x)) { return {}; }));\n+    VERIFY(!sfinae_is_callable<float>(\n+\t[](auto x) -> decltype(std::experimental::all_of(x)) { return {}; }));\n+    VERIFY(!sfinae_is_callable<char>(\n+\t[](auto x) -> decltype(std::experimental::all_of(x)) { return {}; }));\n+\n+    // any_of\n+    VERIFY(any_of(M{true}));\n+    COMPARE(any_of(alternating_mask), M::size() > 1);\n+    VERIFY(!any_of(M{false}));\n+    using std::experimental::any_of;\n+    VERIFY(any_of(true));\n+    VERIFY(!any_of(false));\n+    VERIFY(sfinae_is_callable<bool>(\n+\t[](auto x) -> decltype(std::experimental::any_of(x)) { return {}; }));\n+    VERIFY(!sfinae_is_callable<int>(\n+\t[](auto x) -> decltype(std::experimental::any_of(x)) { return {}; }));\n+    VERIFY(!sfinae_is_callable<float>(\n+\t[](auto x) -> decltype(std::experimental::any_of(x)) { return {}; }));\n+    VERIFY(!sfinae_is_callable<char>(\n+\t[](auto x) -> decltype(std::experimental::any_of(x)) { return {}; }));\n+\n+    // none_of\n+    VERIFY(!none_of(M{true}));\n+    COMPARE(none_of(alternating_mask), M::size() == 1);\n+    VERIFY(none_of(M{false}));\n+    using std::experimental::none_of;\n+    VERIFY(!none_of(true));\n+    VERIFY(none_of(false));\n+    VERIFY(sfinae_is_callable<bool>(\n+\t[](auto x) -> decltype(std::experimental::none_of(x)) { return {}; }));\n+    VERIFY(!sfinae_is_callable<int>(\n+\t[](auto x) -> decltype(std::experimental::none_of(x)) { return {}; }));\n+    VERIFY(!sfinae_is_callable<float>(\n+\t[](auto x) -> decltype(std::experimental::none_of(x)) { return {}; }));\n+    VERIFY(!sfinae_is_callable<char>(\n+\t[](auto x) -> decltype(std::experimental::none_of(x)) { return {}; }));\n+\n+    // some_of\n+    VERIFY(!some_of(M{true}));\n+    VERIFY(!some_of(M{false}));\n+    if (M::size() > 1)\n+      {\n+\tVERIFY(some_of(gen({true, false})));\n+\tVERIFY(some_of(gen({false, true})));\n+\tif (M::size() > 3)\n+\t  {\n+\t    VERIFY(some_of(gen({0, 0, 0, 1})));\n+\t  }\n+      }\n+    using std::experimental::some_of;\n+    VERIFY(!some_of(true));\n+    VERIFY(!some_of(false));\n+    VERIFY(sfinae_is_callable<bool>(\n+\t[](auto x) -> decltype(std::experimental::some_of(x)) { return {}; }));\n+    VERIFY(!sfinae_is_callable<int>(\n+\t[](auto x) -> decltype(std::experimental::some_of(x)) { return {}; }));\n+    VERIFY(!sfinae_is_callable<float>(\n+\t[](auto x) -> decltype(std::experimental::some_of(x)) { return {}; }));\n+    VERIFY(!sfinae_is_callable<char>(\n+\t[](auto x) -> decltype(std::experimental::some_of(x)) { return {}; }));\n+\n+    // popcount\n+    COMPARE(popcount(M{true}), int(M::size()));\n+    COMPARE(popcount(alternating_mask), int(M::size()) / 2);\n+    COMPARE(popcount(M{false}), 0);\n+    COMPARE(popcount(gen({0, 0, 1})), int(M::size()) / 3);\n+    COMPARE(popcount(gen({0, 0, 0, 1})), int(M::size()) / 4);\n+    COMPARE(popcount(gen({0, 0, 0, 0, 1})), int(M::size()) / 5);\n+    COMPARE(std::experimental::popcount(true), 1);\n+    COMPARE(std::experimental::popcount(false), 0);\n+    VERIFY(sfinae_is_callable<bool>(\n+\t[](auto x) -> decltype(std::experimental::popcount(x)) { return {}; }));\n+    VERIFY(!sfinae_is_callable<int>(\n+\t[](auto x) -> decltype(std::experimental::popcount(x)) { return {}; }));\n+    VERIFY(!sfinae_is_callable<float>(\n+\t[](auto x) -> decltype(std::experimental::popcount(x)) { return {}; }));\n+    VERIFY(!sfinae_is_callable<char>(\n+\t[](auto x) -> decltype(std::experimental::popcount(x)) { return {}; }));\n+\n+    // find_first_set\n+    {\n+      M x(false);\n+      for (int i = int(M::size() / 2 - 1); i >= 0; --i)\n+\t{\n+\t  x[i] = true;\n+\t  COMPARE(find_first_set(x), i) << x;\n+\t}\n+      x = M(false);\n+      for (int i = int(M::size() - 1); i >= 0; --i)\n+\t{\n+\t  x[i] = true;\n+\t  COMPARE(find_first_set(x), i) << x;\n+\t}\n+    }\n+    COMPARE(find_first_set(M{true}), 0);\n+    if (M::size() > 1)\n+      {\n+\tCOMPARE(find_first_set(gen({0, 1})), 1);\n+      }\n+    if (M::size() > 2)\n+      {\n+\tCOMPARE(find_first_set(gen({0, 0, 1})), 2);\n+      }\n+    COMPARE(std::experimental::find_first_set(true), 0);\n+    VERIFY(sfinae_is_callable<bool>(\n+\t[](auto x) -> decltype(std::experimental::find_first_set(x)) {\n+\t  return {};\n+\t}));\n+    VERIFY(!sfinae_is_callable<int>(\n+\t[](auto x) -> decltype(std::experimental::find_first_set(x)) {\n+\t  return {};\n+\t}));\n+    VERIFY(!sfinae_is_callable<float>(\n+\t[](auto x) -> decltype(std::experimental::find_first_set(x)) {\n+\t  return {};\n+\t}));\n+    VERIFY(!sfinae_is_callable<char>(\n+\t[](auto x) -> decltype(std::experimental::find_first_set(x)) {\n+\t  return {};\n+\t}));\n+\n+    // find_last_set\n+    {\n+      M x(false);\n+      for (int i = 0; i < int(M::size()); ++i)\n+\t{\n+\t  x[i] = true;\n+\t  COMPARE(find_last_set(x), i) << x;\n+\t}\n+    }\n+    COMPARE(find_last_set(M{true}), int(M::size()) - 1);\n+    if (M::size() > 1)\n+      {\n+\tCOMPARE(find_last_set(gen({1, 0})),\n+\t\tint(M::size()) - 2 + int(M::size() & 1));\n+      }\n+    if (M::size() > 3 && (M::size() & 3) == 0)\n+      {\n+\tCOMPARE(find_last_set(gen({1, 0, 0, 0})),\n+\t\tint(M::size()) - 4 - int(M::size() & 3));\n+      }\n+    COMPARE(std::experimental::find_last_set(true), 0);\n+    VERIFY(sfinae_is_callable<bool>(\n+\t[](auto x) -> decltype(std::experimental::find_last_set(x)) {\n+\t  return {};\n+\t}));\n+    VERIFY(!sfinae_is_callable<int>(\n+\t[](auto x) -> decltype(std::experimental::find_last_set(x)) {\n+\t  return {};\n+\t}));\n+    VERIFY(!sfinae_is_callable<float>(\n+\t[](auto x) -> decltype(std::experimental::find_last_set(x)) {\n+\t  return {};\n+\t}));\n+    VERIFY(!sfinae_is_callable<char>(\n+\t[](auto x) -> decltype(std::experimental::find_last_set(x)) {\n+\t  return {};\n+\t}));\n+  }"}, {"sha": "bce01264f3ce8669b859b1bb570887b12a128da2", "filename": "libstdc++-v3/testsuite/experimental/simd/tests/math_1arg.cc", "status": "added", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02e32295b284bd4f4d038e73ee3118fb0546650e/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fsimd%2Ftests%2Fmath_1arg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02e32295b284bd4f4d038e73ee3118fb0546650e/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fsimd%2Ftests%2Fmath_1arg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fsimd%2Ftests%2Fmath_1arg.cc?ref=02e32295b284bd4f4d038e73ee3118fb0546650e", "patch": "@@ -0,0 +1,107 @@\n+// test only floattypes\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"bits/verify.h\"\n+#include \"bits/test_values.h\"\n+\n+template <typename V>\n+  void\n+  test()\n+  {\n+    vir::test::setFuzzyness<float>(0);\n+    vir::test::setFuzzyness<double>(0);\n+\n+    using T = typename V::value_type;\n+    constexpr T inf = std::__infinity_v<T>;\n+    constexpr T nan = std::__quiet_NaN_v<T>;\n+    constexpr T denorm_min = std::__denorm_min_v<T>;\n+    constexpr T norm_min = std::__norm_min_v<T>;\n+    constexpr T max = std::__finite_max_v<T>;\n+#if defined __LONG_DOUBLE_IBM128__\n+    // On POWER with IBM128 long double, 1+eps and 2-eps is not a constant\n+    // expression. Until this is fixed, just use const instead of constexpr.\n+    // (error: '(1.0e+0l + 4.94065645841246544176568792868221e-324l)' is not a\n+    // constant expression)\n+    const T after_one = 1 + std::__epsilon_v<T>;\n+    const T before_one = (2 - std::__epsilon_v<T>) / 2;\n+#else\n+    constexpr T after_one = 1 + std::__epsilon_v<T>;\n+    constexpr T before_one = (2 - std::__epsilon_v<T>) / 2;\n+#endif\n+    const std::initializer_list<T>\n+      input_values = {+0.,\n+\t\t      0.5,\n+\t\t      -0.5,\n+\t\t      before_one,\n+\t\t      -before_one,\n+\t\t      after_one,\n+\t\t      -after_one,\n+\t\t      1.5,\n+\t\t      -1.5,\n+\t\t      2 * before_one,\n+\t\t      -2 * before_one,\n+\t\t      2 * after_one,\n+\t\t      -2 * after_one,\n+\t\t      2.5,\n+\t\t      -2.5,\n+\t\t      0x1.fffffffffffffp52,\n+\t\t      -0x1.fffffffffffffp52,\n+\t\t      0x1.ffffffffffffep52,\n+\t\t      -0x1.ffffffffffffep52,\n+\t\t      0x1.ffffffffffffdp52,\n+\t\t      -0x1.ffffffffffffdp52,\n+\t\t      0x1.fffffep21,\n+\t\t      -0x1.fffffep21,\n+\t\t      0x1.fffffcp21,\n+\t\t      -0x1.fffffcp21,\n+\t\t      0x1.fffffep22,\n+\t\t      -0x1.fffffep22,\n+\t\t      0x1.fffffcp22,\n+\t\t      -0x1.fffffcp22,\n+\t\t      0x1.fffffep23,\n+\t\t      -0x1.fffffep23,\n+\t\t      0x1.fffffcp23,\n+\t\t      -0x1.fffffcp23,\n+\t\t      0x1.8p23,\n+\t\t      -0x1.8p23,\n+\t\t      inf,\n+\t\t      -inf,\n+\t\t      -0.,\n+\t\t      nan,\n+\t\t      denorm_min,\n+\t\t      norm_min / 3,\n+\t\t      norm_min,\n+\t\t      max};\n+    test_values<V>(input_values, {10000}, MAKE_TESTER(erf), MAKE_TESTER(erfc),\n+\t\t   MAKE_TESTER(tgamma), MAKE_TESTER(lgamma), MAKE_TESTER(ceil),\n+\t\t   MAKE_TESTER(floor), MAKE_TESTER(trunc), MAKE_TESTER(round),\n+\t\t   MAKE_TESTER(lround), MAKE_TESTER(llround),\n+\t\t   MAKE_TESTER(nearbyint), MAKE_TESTER(rint), MAKE_TESTER(lrint),\n+\t\t   MAKE_TESTER(llrint), MAKE_TESTER(ilogb));\n+\n+    // sqrt(x) on x87 is precise in 80 bits, but the subsequent rounding can be\n+    // wrong (up to 1 ULP)\n+#if __FLT_EVAL_METHOD__ == 1\n+    vir::test::setFuzzyness<float>(1);\n+    vir::test::setFuzzyness<double>(0);\n+#elif __FLT_EVAL_METHOD__ == 2\n+    vir::test::setFuzzyness<float>(1);\n+    vir::test::setFuzzyness<double>(1);\n+#endif\n+    test_values<V>(input_values, {10000}, MAKE_TESTER(sqrt));\n+  }"}, {"sha": "57b7b3aeb5c29a6cb1fd92105d311081274bbaab", "filename": "libstdc++-v3/testsuite/experimental/simd/tests/math_2arg.cc", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02e32295b284bd4f4d038e73ee3118fb0546650e/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fsimd%2Ftests%2Fmath_2arg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02e32295b284bd4f4d038e73ee3118fb0546650e/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fsimd%2Ftests%2Fmath_2arg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fsimd%2Ftests%2Fmath_2arg.cc?ref=02e32295b284bd4f4d038e73ee3118fb0546650e", "patch": "@@ -0,0 +1,79 @@\n+// test only floattypes\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"bits/verify.h\"\n+#include \"bits/metahelpers.h\"\n+#include \"bits/test_values.h\"\n+\n+template <typename V>\n+  void\n+  test()\n+  {\n+    using T = typename V::value_type;\n+\n+    vir::test::setFuzzyness<float>(1);\n+    vir::test::setFuzzyness<double>(1);\n+    vir::test::setFuzzyness<long double>(1);\n+    test_values_2arg<V>(\n+      {\n+#ifdef __STDC_IEC_559__\n+\tstd::__quiet_NaN_v<T>, std::__infinity_v<T>, -std::__infinity_v<T>, -0.,\n+\tstd::__denorm_min_v<T>, std::__norm_min_v<T> / 3,\n+#endif\n+\t+0., std::__norm_min_v<T>, 1., 2., std::__finite_max_v<T> / 5,\n+\tstd::__finite_max_v<T> / 3, std::__finite_max_v<T> / 2,\n+#ifdef __FAST_MATH__\n+\t// fast-math hypot is imprecise for the max exponent\n+      },\n+      {100000, std::__finite_max_v<T> / 2},\n+#else\n+\tstd::__finite_max_v<T>},\n+      {100000},\n+#endif\n+      MAKE_TESTER(hypot));\n+#if !__FINITE_MATH_ONLY__\n+    COMPARE(hypot(V(std::__finite_max_v<T>), V(std::__finite_max_v<T>)),\n+\t    V(std::__infinity_v<T>));\n+#endif\n+    COMPARE(hypot(V(std::__norm_min_v<T>), V(std::__norm_min_v<T>)),\n+\t    V(std::__norm_min_v<T> * std::sqrt(T(2))));\n+    VERIFY((sfinae_is_callable<V, V>(\n+\t  [](auto a, auto b) -> decltype(hypot(a, b)) { return {}; })));\n+    VERIFY((sfinae_is_callable<typename V::value_type, V>(\n+\t  [](auto a, auto b) -> decltype(hypot(a, b)) { return {}; })));\n+    VERIFY((sfinae_is_callable<V, typename V::value_type>(\n+\t  [](auto a, auto b) -> decltype(hypot(a, b)) { return {}; })));\n+\n+    vir::test::setFuzzyness<float>(0);\n+    vir::test::setFuzzyness<double>(0);\n+    vir::test::setFuzzyness<long double>(0);\n+    test_values_2arg<V>(\n+      {\n+#ifdef __STDC_IEC_559__\n+\tstd::__quiet_NaN_v<T>, std::__infinity_v<T>, -std::__infinity_v<T>,\n+\tstd::__denorm_min_v<T>, std::__norm_min_v<T> / 3, -0.,\n+#endif\n+\t+0., std::__norm_min_v<T>, std::__finite_max_v<T>},\n+      {10000}, MAKE_TESTER(pow), MAKE_TESTER(fmod), MAKE_TESTER(remainder),\n+      MAKE_TESTER_NOFPEXCEPT(copysign),\n+      MAKE_TESTER(nextafter), // MAKE_TESTER(nexttoward),\n+      MAKE_TESTER(fdim), MAKE_TESTER(fmax), MAKE_TESTER(fmin),\n+      MAKE_TESTER_NOFPEXCEPT(isgreater), MAKE_TESTER_NOFPEXCEPT(isgreaterequal),\n+      MAKE_TESTER_NOFPEXCEPT(isless), MAKE_TESTER_NOFPEXCEPT(islessequal),\n+      MAKE_TESTER_NOFPEXCEPT(islessgreater), MAKE_TESTER_NOFPEXCEPT(isunordered));\n+  }"}, {"sha": "a04cd34e3d47e0ce1f82a0b0e1446e8d358cb840", "filename": "libstdc++-v3/testsuite/experimental/simd/tests/operator_cvt.cc", "status": "added", "additions": 1072, "deletions": 0, "changes": 1072, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02e32295b284bd4f4d038e73ee3118fb0546650e/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fsimd%2Ftests%2Foperator_cvt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02e32295b284bd4f4d038e73ee3118fb0546650e/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fsimd%2Ftests%2Foperator_cvt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fsimd%2Ftests%2Foperator_cvt.cc?ref=02e32295b284bd4f4d038e73ee3118fb0546650e", "patch": "@@ -0,0 +1,1072 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"bits/verify.h\"\n+#include \"bits/metahelpers.h\"\n+\n+// type with sizeof(char) but different signedness\n+using xchar = std::conditional_t<std::is_unsigned_v<char>, schar, uchar>;\n+\n+using vschar = std::experimental::native_simd<schar>;\n+using vuchar = std::experimental::native_simd<uchar>;\n+using vshort = std::experimental::native_simd<short>;\n+using vushort = std::experimental::native_simd<ushort>;\n+using vint = std::experimental::native_simd<int>;\n+using vuint = std::experimental::native_simd<uint>;\n+using vlong = std::experimental::native_simd<long>;\n+using vulong = std::experimental::native_simd<ulong>;\n+using vllong = std::experimental::native_simd<llong>;\n+using vullong = std::experimental::native_simd<ullong>;\n+using vfloat = std::experimental::native_simd<float>;\n+using vdouble = std::experimental::native_simd<double>;\n+using vldouble = std::experimental::native_simd<long double>;\n+using vchar = std::experimental::native_simd<char>;\n+using vxchar = std::experimental::native_simd<xchar>;\n+\n+template <typename T>\n+  using vi8 = std::experimental::fixed_size_simd<T, vschar::size()>;\n+template <typename T>\n+  using vi16 = std::experimental::fixed_size_simd<T, vshort::size()>;\n+template <typename T>\n+  using vf32 = std::experimental::fixed_size_simd<T, vfloat::size()>;\n+template <typename T>\n+  using vi32 = std::experimental::fixed_size_simd<T, vint::size()>;\n+template <typename T>\n+  using vf64 = std::experimental::fixed_size_simd<T, vdouble::size()>;\n+template <typename T>\n+  using vi64 = std::experimental::fixed_size_simd<T, vllong::size()>;\n+template <typename T>\n+  using vl = typename std::conditional<sizeof(long) == sizeof(llong), vi64<T>,\n+\t\t\t\t       vi32<T>>::type;\n+\n+template <class A, class B, class Expected = A>\n+  void\n+  binary_op_return_type()\n+  {\n+    using namespace vir::test;\n+    static_assert(std::is_same<A, Expected>::value, \"\");\n+    using AC = std::add_const_t<A>;\n+    using BC = std::add_const_t<B>;\n+    COMPARE(typeid(A() + B()), typeid(Expected));\n+    COMPARE(typeid(B() + A()), typeid(Expected));\n+    COMPARE(typeid(AC() + BC()), typeid(Expected));\n+    COMPARE(typeid(BC() + AC()), typeid(Expected));\n+  }\n+\n+template <typename V>\n+  void\n+  test()\n+  {\n+    using T = typename V::value_type;\n+    namespace simd_abi = std::experimental::simd_abi;\n+    binary_op_return_type<V, V, V>();\n+    binary_op_return_type<V, T, V>();\n+    binary_op_return_type<V, int, V>();\n+\n+    if constexpr (std::is_same_v<V, vfloat>)\n+      {\n+\tbinary_op_return_type<vfloat, schar>();\n+\tbinary_op_return_type<vfloat, uchar>();\n+\tbinary_op_return_type<vfloat, short>();\n+\tbinary_op_return_type<vfloat, ushort>();\n+\n+\tbinary_op_return_type<vf32<float>, schar>();\n+\tbinary_op_return_type<vf32<float>, uchar>();\n+\tbinary_op_return_type<vf32<float>, short>();\n+\tbinary_op_return_type<vf32<float>, ushort>();\n+\tbinary_op_return_type<vf32<float>, int>();\n+\tbinary_op_return_type<vf32<float>, float>();\n+\n+\tbinary_op_return_type<vf32<float>, vf32<schar>>();\n+\tbinary_op_return_type<vf32<float>, vf32<uchar>>();\n+\tbinary_op_return_type<vf32<float>, vf32<short>>();\n+\tbinary_op_return_type<vf32<float>, vf32<ushort>>();\n+\tbinary_op_return_type<vf32<float>, vf32<float>>();\n+\n+\tVERIFY((is_substitution_failure<vfloat, uint>));\n+\tVERIFY((is_substitution_failure<vfloat, long>));\n+\tVERIFY((is_substitution_failure<vfloat, ulong>));\n+\tVERIFY((is_substitution_failure<vfloat, llong>));\n+\tVERIFY((is_substitution_failure<vfloat, ullong>));\n+\tVERIFY((is_substitution_failure<vfloat, double>));\n+\tVERIFY((is_substitution_failure<vfloat, vf32<schar>>));\n+\tVERIFY((is_substitution_failure<vfloat, vf32<uchar>>));\n+\tVERIFY((is_substitution_failure<vfloat, vf32<short>>));\n+\tVERIFY((is_substitution_failure<vfloat, vf32<ushort>>));\n+\tVERIFY((is_substitution_failure<vfloat, vf32<int>>));\n+\tVERIFY((is_substitution_failure<vfloat, vf32<uint>>));\n+\tVERIFY((is_substitution_failure<vfloat, vf32<long>>));\n+\tVERIFY((is_substitution_failure<vfloat, vf32<ulong>>));\n+\tVERIFY((is_substitution_failure<vfloat, vf32<llong>>));\n+\tVERIFY((is_substitution_failure<vfloat, vf32<ullong>>));\n+\tVERIFY((is_substitution_failure<vfloat, vf32<float>>));\n+\n+\tVERIFY((is_substitution_failure<vf32<float>, vfloat>));\n+\tVERIFY((is_substitution_failure<vf32<float>, uint>));\n+\tVERIFY((is_substitution_failure<vf32<float>, long>));\n+\tVERIFY((is_substitution_failure<vf32<float>, ulong>));\n+\tVERIFY((is_substitution_failure<vf32<float>, llong>));\n+\tVERIFY((is_substitution_failure<vf32<float>, ullong>));\n+\tVERIFY((is_substitution_failure<vf32<float>, double>));\n+\tVERIFY((is_substitution_failure<vf32<float>, vf32<int>>));\n+\tVERIFY((is_substitution_failure<vf32<float>, vf32<uint>>));\n+\tVERIFY((is_substitution_failure<vf32<float>, vf32<long>>));\n+\tVERIFY((is_substitution_failure<vf32<float>, vf32<ulong>>));\n+\tVERIFY((is_substitution_failure<vf32<float>, vf32<llong>>));\n+\tVERIFY((is_substitution_failure<vf32<float>, vf32<ullong>>));\n+\n+\tVERIFY((is_substitution_failure<vfloat, vf32<double>>));\n+      }\n+    else if constexpr (std::is_same_v<V, vdouble>)\n+      {\n+\tbinary_op_return_type<vdouble, float, vdouble>();\n+\tbinary_op_return_type<vdouble, schar>();\n+\tbinary_op_return_type<vdouble, uchar>();\n+\tbinary_op_return_type<vdouble, short>();\n+\tbinary_op_return_type<vdouble, ushort>();\n+\tbinary_op_return_type<vdouble, uint>();\n+\n+\tbinary_op_return_type<vf64<double>, schar>();\n+\tbinary_op_return_type<vf64<double>, uchar>();\n+\tbinary_op_return_type<vf64<double>, short>();\n+\tbinary_op_return_type<vf64<double>, ushort>();\n+\tbinary_op_return_type<vf64<double>, uint>();\n+\tbinary_op_return_type<vf64<double>, int, vf64<double>>();\n+\tbinary_op_return_type<vf64<double>, float, vf64<double>>();\n+\tbinary_op_return_type<vf64<double>, double, vf64<double>>();\n+\tbinary_op_return_type<vf64<double>, vf64<double>, vf64<double>>();\n+\tbinary_op_return_type<vf32<double>, schar>();\n+\tbinary_op_return_type<vf32<double>, uchar>();\n+\tbinary_op_return_type<vf32<double>, short>();\n+\tbinary_op_return_type<vf32<double>, ushort>();\n+\tbinary_op_return_type<vf32<double>, uint>();\n+\tbinary_op_return_type<vf32<double>, int, vf32<double>>();\n+\tbinary_op_return_type<vf32<double>, float, vf32<double>>();\n+\tbinary_op_return_type<vf32<double>, double, vf32<double>>();\n+\tbinary_op_return_type<vf64<double>, vf64<schar>>();\n+\tbinary_op_return_type<vf64<double>, vf64<uchar>>();\n+\tbinary_op_return_type<vf64<double>, vf64<short>>();\n+\tbinary_op_return_type<vf64<double>, vf64<ushort>>();\n+\tbinary_op_return_type<vf64<double>, vf64<int>>();\n+\tbinary_op_return_type<vf64<double>, vf64<uint>>();\n+\tbinary_op_return_type<vf64<double>, vf64<float>>();\n+\n+\tVERIFY((is_substitution_failure<vdouble, llong>));\n+\tVERIFY((is_substitution_failure<vdouble, ullong>));\n+\tVERIFY((is_substitution_failure<vdouble, vf64<schar>>));\n+\tVERIFY((is_substitution_failure<vdouble, vf64<uchar>>));\n+\tVERIFY((is_substitution_failure<vdouble, vf64<short>>));\n+\tVERIFY((is_substitution_failure<vdouble, vf64<ushort>>));\n+\tVERIFY((is_substitution_failure<vdouble, vf64<int>>));\n+\tVERIFY((is_substitution_failure<vdouble, vf64<uint>>));\n+\tVERIFY((is_substitution_failure<vdouble, vf64<long>>));\n+\tVERIFY((is_substitution_failure<vdouble, vf64<ulong>>));\n+\tVERIFY((is_substitution_failure<vdouble, vf64<llong>>));\n+\tVERIFY((is_substitution_failure<vdouble, vf64<ullong>>));\n+\tVERIFY((is_substitution_failure<vdouble, vf64<float>>));\n+\tVERIFY((is_substitution_failure<vdouble, vf64<double>>));\n+\n+\tVERIFY((is_substitution_failure<vf64<double>, vdouble>));\n+\tVERIFY((is_substitution_failure<vf64<double>, llong>));\n+\tVERIFY((is_substitution_failure<vf64<double>, ullong>));\n+\tVERIFY((is_substitution_failure<vf64<double>, vf64<llong>>));\n+\tVERIFY((is_substitution_failure<vf64<double>, vf64<ullong>>));\n+\n+\tVERIFY((is_substitution_failure<vf32<double>, llong>));\n+\tVERIFY((is_substitution_failure<vf32<double>, ullong>));\n+\n+\tif constexpr (sizeof(long) == sizeof(llong))\n+\t  {\n+\t    VERIFY((is_substitution_failure<vdouble, long>));\n+\t    VERIFY((is_substitution_failure<vdouble, ulong>));\n+\t    VERIFY((is_substitution_failure<vf64<double>, long>));\n+\t    VERIFY((is_substitution_failure<vf64<double>, ulong>));\n+\t    VERIFY((is_substitution_failure<vf64<double>, vf64<long>>));\n+\t    VERIFY((is_substitution_failure<vf64<double>, vf64<ulong>>));\n+\t    VERIFY((is_substitution_failure<vf32<double>, long>));\n+\t    VERIFY((is_substitution_failure<vf32<double>, ulong>));\n+\t  }\n+\telse\n+\t  {\n+\t    binary_op_return_type<vdouble, long>();\n+\t    binary_op_return_type<vdouble, ulong>();\n+\t    binary_op_return_type<vf64<double>, long>();\n+\t    binary_op_return_type<vf64<double>, ulong>();\n+\t    binary_op_return_type<vf64<double>, vf64<long>>();\n+\t    binary_op_return_type<vf64<double>, vf64<ulong>>();\n+\t    binary_op_return_type<vf32<double>, long>();\n+\t    binary_op_return_type<vf32<double>, ulong>();\n+\t  }\n+      }\n+    else if constexpr (std::is_same_v<V, vldouble>)\n+      {\n+\tbinary_op_return_type<vldouble, schar>();\n+\tbinary_op_return_type<vldouble, uchar>();\n+\tbinary_op_return_type<vldouble, short>();\n+\tbinary_op_return_type<vldouble, ushort>();\n+\tbinary_op_return_type<vldouble, uint>();\n+\tbinary_op_return_type<vldouble, long>();\n+\tbinary_op_return_type<vldouble, ulong>();\n+\tbinary_op_return_type<vldouble, float>();\n+\tbinary_op_return_type<vldouble, double>();\n+\n+\tbinary_op_return_type<vf64<long double>, schar>();\n+\tbinary_op_return_type<vf64<long double>, uchar>();\n+\tbinary_op_return_type<vf64<long double>, short>();\n+\tbinary_op_return_type<vf64<long double>, ushort>();\n+\tbinary_op_return_type<vf64<long double>, int>();\n+\tbinary_op_return_type<vf64<long double>, uint>();\n+\tbinary_op_return_type<vf64<long double>, long>();\n+\tbinary_op_return_type<vf64<long double>, ulong>();\n+\tbinary_op_return_type<vf64<long double>, float>();\n+\tbinary_op_return_type<vf64<long double>, double>();\n+\tbinary_op_return_type<vf64<long double>, vf64<long double>>();\n+\n+\tusing std::experimental::simd;\n+\tusing A = simd_abi::fixed_size<vldouble::size()>;\n+\tbinary_op_return_type<simd<long double, A>, schar>();\n+\tbinary_op_return_type<simd<long double, A>, uchar>();\n+\tbinary_op_return_type<simd<long double, A>, short>();\n+\tbinary_op_return_type<simd<long double, A>, ushort>();\n+\tbinary_op_return_type<simd<long double, A>, int>();\n+\tbinary_op_return_type<simd<long double, A>, uint>();\n+\tbinary_op_return_type<simd<long double, A>, long>();\n+\tbinary_op_return_type<simd<long double, A>, ulong>();\n+\tbinary_op_return_type<simd<long double, A>, float>();\n+\tbinary_op_return_type<simd<long double, A>, double>();\n+\n+\tif constexpr (sizeof(ldouble) == sizeof(double))\n+\t  {\n+\t    VERIFY((is_substitution_failure<vldouble, llong>));\n+\t    VERIFY((is_substitution_failure<vldouble, ullong>));\n+\t    VERIFY((is_substitution_failure<vf64<ldouble>, llong>));\n+\t    VERIFY((is_substitution_failure<vf64<ldouble>, ullong>));\n+\t    VERIFY((is_substitution_failure<simd<ldouble, A>, llong>));\n+\t    VERIFY((is_substitution_failure<simd<ldouble, A>, ullong>));\n+\t  }\n+\telse\n+\t  {\n+\t    binary_op_return_type<vldouble, llong>();\n+\t    binary_op_return_type<vldouble, ullong>();\n+\t    binary_op_return_type<vf64<long double>, llong>();\n+\t    binary_op_return_type<vf64<long double>, ullong>();\n+\t    binary_op_return_type<simd<long double, A>, llong>();\n+\t    binary_op_return_type<simd<long double, A>, ullong>();\n+\t  }\n+\n+\tVERIFY((is_substitution_failure<vf64<long double>, vldouble>));\n+\tCOMPARE((is_substitution_failure<simd<long double, A>, vldouble>),\n+\t\t(!std::is_same<A, vldouble::abi_type>::value));\n+      }\n+    else if constexpr (std::is_same_v<V, vlong>)\n+      {\n+\tVERIFY((is_substitution_failure<vi32<long>, double>));\n+\tVERIFY((is_substitution_failure<vi32<long>, float>));\n+\tVERIFY((is_substitution_failure<vi32<long>, vi32<float>>));\n+\tif constexpr (sizeof(long) == sizeof(llong))\n+\t  {\n+\t    binary_op_return_type<vlong, uint>();\n+\t    binary_op_return_type<vlong, llong>();\n+\t    binary_op_return_type<vi32<long>, uint>();\n+\t    binary_op_return_type<vi32<long>, llong>();\n+\t    binary_op_return_type<vi64<long>, uint>();\n+\t    binary_op_return_type<vi64<long>, llong>();\n+\t    binary_op_return_type<vi32<long>, vi32<uint>>();\n+\t    binary_op_return_type<vi64<long>, vi64<uint>>();\n+\t    VERIFY((is_substitution_failure<vi32<long>, vi32<double>>));\n+\t    VERIFY((is_substitution_failure<vi64<long>, vi64<double>>));\n+\t  }\n+\telse\n+\t  {\n+\t    VERIFY((is_substitution_failure<vlong, uint>));\n+\t    VERIFY((is_substitution_failure<vlong, llong>));\n+\t    VERIFY((is_substitution_failure<vi32<long>, uint>));\n+\t    VERIFY((is_substitution_failure<vi32<long>, llong>));\n+\t    VERIFY((is_substitution_failure<vi64<long>, uint>));\n+\t    VERIFY((is_substitution_failure<vi64<long>, llong>));\n+\t    VERIFY((is_substitution_failure<vi32<long>, vi32<uint>>));\n+\t    VERIFY((is_substitution_failure<vi64<long>, vi64<uint>>));\n+\t    binary_op_return_type<vi32<double>, vi32<long>>();\n+\t    binary_op_return_type<vi64<double>, vi64<long>>();\n+\t  }\n+\n+\tbinary_op_return_type<vlong, schar, vlong>();\n+\tbinary_op_return_type<vlong, uchar, vlong>();\n+\tbinary_op_return_type<vlong, short, vlong>();\n+\tbinary_op_return_type<vlong, ushort, vlong>();\n+\n+\tbinary_op_return_type<vi32<long>, schar, vi32<long>>();\n+\tbinary_op_return_type<vi32<long>, uchar, vi32<long>>();\n+\tbinary_op_return_type<vi32<long>, short, vi32<long>>();\n+\tbinary_op_return_type<vi32<long>, ushort, vi32<long>>();\n+\tbinary_op_return_type<vi32<long>, int, vi32<long>>();\n+\tbinary_op_return_type<vi32<long>, long, vi32<long>>();\n+\tbinary_op_return_type<vi32<long>, vi32<long>, vi32<long>>();\n+\tbinary_op_return_type<vi64<long>, schar, vi64<long>>();\n+\tbinary_op_return_type<vi64<long>, uchar, vi64<long>>();\n+\tbinary_op_return_type<vi64<long>, short, vi64<long>>();\n+\tbinary_op_return_type<vi64<long>, ushort, vi64<long>>();\n+\tbinary_op_return_type<vi64<long>, int, vi64<long>>();\n+\tbinary_op_return_type<vi64<long>, long, vi64<long>>();\n+\tbinary_op_return_type<vi64<long>, vi64<long>, vi64<long>>();\n+\n+\tVERIFY((is_substitution_failure<vlong, vulong>));\n+\tVERIFY((is_substitution_failure<vlong, ulong>));\n+\tVERIFY((is_substitution_failure<vlong, ullong>));\n+\tVERIFY((is_substitution_failure<vlong, float>));\n+\tVERIFY((is_substitution_failure<vlong, double>));\n+\tVERIFY((is_substitution_failure<vlong, vl<schar>>));\n+\tVERIFY((is_substitution_failure<vlong, vl<uchar>>));\n+\tVERIFY((is_substitution_failure<vlong, vl<short>>));\n+\tVERIFY((is_substitution_failure<vlong, vl<ushort>>));\n+\tVERIFY((is_substitution_failure<vlong, vl<int>>));\n+\tVERIFY((is_substitution_failure<vlong, vl<uint>>));\n+\tVERIFY((is_substitution_failure<vlong, vl<long>>));\n+\tVERIFY((is_substitution_failure<vlong, vl<ulong>>));\n+\tVERIFY((is_substitution_failure<vlong, vl<llong>>));\n+\tVERIFY((is_substitution_failure<vlong, vl<ullong>>));\n+\tVERIFY((is_substitution_failure<vlong, vl<float>>));\n+\tVERIFY((is_substitution_failure<vlong, vl<double>>));\n+\tVERIFY((is_substitution_failure<vl<long>, vlong>));\n+\tVERIFY((is_substitution_failure<vl<long>, vulong>));\n+\tVERIFY((is_substitution_failure<vi32<long>, ulong>));\n+\tVERIFY((is_substitution_failure<vi32<long>, ullong>));\n+\tbinary_op_return_type<vi32<long>, vi32<schar>>();\n+\tbinary_op_return_type<vi32<long>, vi32<uchar>>();\n+\tbinary_op_return_type<vi32<long>, vi32<short>>();\n+\tbinary_op_return_type<vi32<long>, vi32<ushort>>();\n+\tbinary_op_return_type<vi32<long>, vi32<int>>();\n+\tVERIFY((is_substitution_failure<vi32<long>, vi32<ulong>>));\n+\tVERIFY((is_substitution_failure<vi32<long>, vi32<ullong>>));\n+\tVERIFY((is_substitution_failure<vi64<long>, ulong>));\n+\tVERIFY((is_substitution_failure<vi64<long>, ullong>));\n+\tVERIFY((is_substitution_failure<vi64<long>, float>));\n+\tVERIFY((is_substitution_failure<vi64<long>, double>));\n+\tbinary_op_return_type<vi64<long>, vi64<schar>>();\n+\tbinary_op_return_type<vi64<long>, vi64<uchar>>();\n+\tbinary_op_return_type<vi64<long>, vi64<short>>();\n+\tbinary_op_return_type<vi64<long>, vi64<ushort>>();\n+\tbinary_op_return_type<vi64<long>, vi64<int>>();\n+\tVERIFY((is_substitution_failure<vi64<long>, vi64<ulong>>));\n+\tVERIFY((is_substitution_failure<vi64<long>, vi64<ullong>>));\n+\tVERIFY((is_substitution_failure<vi64<long>, vi64<float>>));\n+\n+\tbinary_op_return_type<vi32<llong>, vi32<long>>();\n+\tbinary_op_return_type<vi64<llong>, vi64<long>>();\n+      }\n+    else if constexpr (std::is_same_v<V, vulong>)\n+      {\n+\tif constexpr (sizeof(long) == sizeof(llong))\n+\t  {\n+\t    binary_op_return_type<vulong, ullong, vulong>();\n+\t    binary_op_return_type<vi32<ulong>, ullong, vi32<ulong>>();\n+\t    binary_op_return_type<vi64<ulong>, ullong, vi64<ulong>>();\n+\t    VERIFY((is_substitution_failure<vi32<ulong>, vi32<llong>>));\n+\t    VERIFY((is_substitution_failure<vi32<ulong>, vi32<double>>));\n+\t    VERIFY((is_substitution_failure<vi64<ulong>, vi64<llong>>));\n+\t    VERIFY((is_substitution_failure<vi64<ulong>, vi64<double>>));\n+\t  }\n+\telse\n+\t  {\n+\t    VERIFY((is_substitution_failure<vulong, ullong>));\n+\t    VERIFY((is_substitution_failure<vi32<ulong>, ullong>));\n+\t    VERIFY((is_substitution_failure<vi64<ulong>, ullong>));\n+\t    binary_op_return_type<vi32<llong>, vi32<ulong>>();\n+\t    binary_op_return_type<vi32<double>, vi32<ulong>>();\n+\t    binary_op_return_type<vi64<llong>, vi64<ulong>>();\n+\t    binary_op_return_type<vi64<double>, vi64<ulong>>();\n+\t  }\n+\n+\tbinary_op_return_type<vulong, uchar, vulong>();\n+\tbinary_op_return_type<vulong, ushort, vulong>();\n+\tbinary_op_return_type<vulong, uint, vulong>();\n+\tbinary_op_return_type<vi32<ulong>, uchar, vi32<ulong>>();\n+\tbinary_op_return_type<vi32<ulong>, ushort, vi32<ulong>>();\n+\tbinary_op_return_type<vi32<ulong>, int, vi32<ulong>>();\n+\tbinary_op_return_type<vi32<ulong>, uint, vi32<ulong>>();\n+\tbinary_op_return_type<vi32<ulong>, ulong, vi32<ulong>>();\n+\tbinary_op_return_type<vi32<ulong>, vi32<ulong>, vi32<ulong>>();\n+\tbinary_op_return_type<vi64<ulong>, uchar, vi64<ulong>>();\n+\tbinary_op_return_type<vi64<ulong>, ushort, vi64<ulong>>();\n+\tbinary_op_return_type<vi64<ulong>, int, vi64<ulong>>();\n+\tbinary_op_return_type<vi64<ulong>, uint, vi64<ulong>>();\n+\tbinary_op_return_type<vi64<ulong>, ulong, vi64<ulong>>();\n+\tbinary_op_return_type<vi64<ulong>, vi64<ulong>, vi64<ulong>>();\n+\n+\tVERIFY((is_substitution_failure<vi32<ulong>, llong>));\n+\tVERIFY((is_substitution_failure<vi32<ulong>, float>));\n+\tVERIFY((is_substitution_failure<vi32<ulong>, double>));\n+\tVERIFY((is_substitution_failure<vi32<ulong>, vi32<float>>));\n+\tVERIFY((is_substitution_failure<vi64<ulong>, vi64<float>>));\n+\tVERIFY((is_substitution_failure<vulong, schar>));\n+\tVERIFY((is_substitution_failure<vulong, short>));\n+\tVERIFY((is_substitution_failure<vulong, vlong>));\n+\tVERIFY((is_substitution_failure<vulong, long>));\n+\tVERIFY((is_substitution_failure<vulong, llong>));\n+\tVERIFY((is_substitution_failure<vulong, float>));\n+\tVERIFY((is_substitution_failure<vulong, double>));\n+\tVERIFY((is_substitution_failure<vulong, vl<schar>>));\n+\tVERIFY((is_substitution_failure<vulong, vl<uchar>>));\n+\tVERIFY((is_substitution_failure<vulong, vl<short>>));\n+\tVERIFY((is_substitution_failure<vulong, vl<ushort>>));\n+\tVERIFY((is_substitution_failure<vulong, vl<int>>));\n+\tVERIFY((is_substitution_failure<vulong, vl<uint>>));\n+\tVERIFY((is_substitution_failure<vulong, vl<long>>));\n+\tVERIFY((is_substitution_failure<vulong, vl<ulong>>));\n+\tVERIFY((is_substitution_failure<vulong, vl<llong>>));\n+\tVERIFY((is_substitution_failure<vulong, vl<ullong>>));\n+\tVERIFY((is_substitution_failure<vulong, vl<float>>));\n+\tVERIFY((is_substitution_failure<vulong, vl<double>>));\n+\tVERIFY((is_substitution_failure<vl<ulong>, vlong>));\n+\tVERIFY((is_substitution_failure<vl<ulong>, vulong>));\n+\tVERIFY((is_substitution_failure<vi32<ulong>, schar>));\n+\tVERIFY((is_substitution_failure<vi32<ulong>, short>));\n+\tVERIFY((is_substitution_failure<vi32<ulong>, long>));\n+\tVERIFY((is_substitution_failure<vi32<ulong>, vi32<schar>>));\n+\tbinary_op_return_type<vi32<ulong>, vi32<uchar>>();\n+\tVERIFY((is_substitution_failure<vi32<ulong>, vi32<short>>));\n+\tbinary_op_return_type<vi32<ulong>, vi32<ushort>>();\n+\tVERIFY((is_substitution_failure<vi32<ulong>, vi32<int>>));\n+\tbinary_op_return_type<vi32<ulong>, vi32<uint>>();\n+\tVERIFY((is_substitution_failure<vi32<ulong>, vi32<long>>));\n+\tbinary_op_return_type<vi32<ullong>, vi32<ulong>>();\n+\tVERIFY((is_substitution_failure<vi64<ulong>, schar>));\n+\tVERIFY((is_substitution_failure<vi64<ulong>, short>));\n+\tVERIFY((is_substitution_failure<vi64<ulong>, long>));\n+\tVERIFY((is_substitution_failure<vi64<ulong>, llong>));\n+\tVERIFY((is_substitution_failure<vi64<ulong>, float>));\n+\tVERIFY((is_substitution_failure<vi64<ulong>, double>));\n+\tVERIFY((is_substitution_failure<vi64<ulong>, vi64<schar>>));\n+\tbinary_op_return_type<vi64<ulong>, vi64<uchar>>();\n+\tVERIFY((is_substitution_failure<vi64<ulong>, vi64<short>>));\n+\tbinary_op_return_type<vi64<ulong>, vi64<ushort>>();\n+\tVERIFY((is_substitution_failure<vi64<ulong>, vi64<int>>));\n+\tbinary_op_return_type<vi64<ulong>, vi64<uint>>();\n+\tVERIFY((is_substitution_failure<vi64<ulong>, vi64<long>>));\n+\tbinary_op_return_type<vi64<ullong>, vi64<ulong>>();\n+      }\n+    else if constexpr (std::is_same_v<V, vllong>)\n+      {\n+\tbinary_op_return_type<vllong, schar, vllong>();\n+\tbinary_op_return_type<vllong, uchar, vllong>();\n+\tbinary_op_return_type<vllong, short, vllong>();\n+\tbinary_op_return_type<vllong, ushort, vllong>();\n+\tbinary_op_return_type<vllong, uint, vllong>();\n+\tbinary_op_return_type<vllong, long, vllong>();\n+\tbinary_op_return_type<vi32<llong>, schar, vi32<llong>>();\n+\tbinary_op_return_type<vi32<llong>, uchar, vi32<llong>>();\n+\tbinary_op_return_type<vi32<llong>, short, vi32<llong>>();\n+\tbinary_op_return_type<vi32<llong>, ushort, vi32<llong>>();\n+\tbinary_op_return_type<vi32<llong>, int, vi32<llong>>();\n+\tbinary_op_return_type<vi32<llong>, uint, vi32<llong>>();\n+\tbinary_op_return_type<vi32<llong>, long, vi32<llong>>();\n+\tbinary_op_return_type<vi32<llong>, llong, vi32<llong>>();\n+\tbinary_op_return_type<vi32<llong>, vi32<llong>, vi32<llong>>();\n+\tbinary_op_return_type<vi64<llong>, schar, vi64<llong>>();\n+\tbinary_op_return_type<vi64<llong>, uchar, vi64<llong>>();\n+\tbinary_op_return_type<vi64<llong>, short, vi64<llong>>();\n+\tbinary_op_return_type<vi64<llong>, ushort, vi64<llong>>();\n+\tbinary_op_return_type<vi64<llong>, int, vi64<llong>>();\n+\tbinary_op_return_type<vi64<llong>, uint, vi64<llong>>();\n+\tbinary_op_return_type<vi64<llong>, long, vi64<llong>>();\n+\tbinary_op_return_type<vi64<llong>, llong, vi64<llong>>();\n+\tbinary_op_return_type<vi64<llong>, vi64<llong>>();\n+\tbinary_op_return_type<vi32<llong>, vi32<schar>>();\n+\tbinary_op_return_type<vi32<llong>, vi32<uchar>>();\n+\tbinary_op_return_type<vi32<llong>, vi32<short>>();\n+\tbinary_op_return_type<vi32<llong>, vi32<ushort>>();\n+\tbinary_op_return_type<vi32<llong>, vi32<int>>();\n+\tbinary_op_return_type<vi32<llong>, vi32<uint>>();\n+\tbinary_op_return_type<vi32<llong>, vi32<long>>();\n+\tif constexpr (sizeof(long) == sizeof(llong))\n+\t  {\n+\t    VERIFY((is_substitution_failure<vi32<llong>, vi32<ulong>>));\n+\t    VERIFY((is_substitution_failure<vi32<llong>, ulong>));\n+\t    VERIFY((is_substitution_failure<vi64<llong>, ulong>));\n+\t    VERIFY((is_substitution_failure<vllong, ulong>));\n+\t  }\n+\telse\n+\t  {\n+\t    binary_op_return_type<vi32<llong>, vi32<ulong>>();\n+\t    binary_op_return_type<vi32<llong>, ulong>();\n+\t    binary_op_return_type<vi64<llong>, ulong>();\n+\t    binary_op_return_type<vllong, ulong>();\n+\t  }\n+\n+\tVERIFY((is_substitution_failure<vllong, vullong>));\n+\tVERIFY((is_substitution_failure<vllong, ullong>));\n+\tVERIFY((is_substitution_failure<vllong, float>));\n+\tVERIFY((is_substitution_failure<vllong, double>));\n+\tVERIFY((is_substitution_failure<vllong, vi64<schar>>));\n+\tVERIFY((is_substitution_failure<vllong, vi64<uchar>>));\n+\tVERIFY((is_substitution_failure<vllong, vi64<short>>));\n+\tVERIFY((is_substitution_failure<vllong, vi64<ushort>>));\n+\tVERIFY((is_substitution_failure<vllong, vi64<int>>));\n+\tVERIFY((is_substitution_failure<vllong, vi64<uint>>));\n+\tVERIFY((is_substitution_failure<vllong, vi64<long>>));\n+\tVERIFY((is_substitution_failure<vllong, vi64<ulong>>));\n+\tVERIFY((is_substitution_failure<vllong, vi64<llong>>));\n+\tVERIFY((is_substitution_failure<vllong, vi64<ullong>>));\n+\tVERIFY((is_substitution_failure<vllong, vi64<float>>));\n+\tVERIFY((is_substitution_failure<vllong, vi64<double>>));\n+\tVERIFY((is_substitution_failure<vi32<llong>, ullong>));\n+\tVERIFY((is_substitution_failure<vi32<llong>, float>));\n+\tVERIFY((is_substitution_failure<vi32<llong>, double>));\n+\tVERIFY((is_substitution_failure<vi32<llong>, vi32<ullong>>));\n+\tVERIFY((is_substitution_failure<vi32<llong>, vi32<float>>));\n+\tVERIFY((is_substitution_failure<vi32<llong>, vi32<double>>));\n+\tVERIFY((is_substitution_failure<vi64<llong>, vllong>));\n+\tVERIFY((is_substitution_failure<vi64<llong>, vullong>));\n+\tVERIFY((is_substitution_failure<vi64<llong>, ullong>));\n+\tVERIFY((is_substitution_failure<vi64<llong>, float>));\n+\tVERIFY((is_substitution_failure<vi64<llong>, double>));\n+\tbinary_op_return_type<vi64<llong>, vi64<schar>>();\n+\tbinary_op_return_type<vi64<llong>, vi64<uchar>>();\n+\tbinary_op_return_type<vi64<llong>, vi64<short>>();\n+\tbinary_op_return_type<vi64<llong>, vi64<ushort>>();\n+\tbinary_op_return_type<vi64<llong>, vi64<int>>();\n+\tbinary_op_return_type<vi64<llong>, vi64<uint>>();\n+\tbinary_op_return_type<vi64<llong>, vi64<long>>();\n+\tif constexpr (sizeof(long) == sizeof(llong))\n+\t  {\n+\t    VERIFY((is_substitution_failure<vi64<llong>, vi64<ulong>>));\n+\t  }\n+\telse\n+\t  {\n+\t    binary_op_return_type<vi64<llong>, vi64<ulong>>();\n+\t  }\n+\tVERIFY((is_substitution_failure<vi64<llong>, vi64<ullong>>));\n+\tVERIFY((is_substitution_failure<vi64<llong>, vi64<float>>));\n+\tVERIFY((is_substitution_failure<vi64<llong>, vi64<double>>));\n+      }\n+    else if constexpr (std::is_same_v<V, vullong>)\n+      {\n+\tbinary_op_return_type<vullong, uchar, vullong>();\n+\tbinary_op_return_type<vullong, ushort, vullong>();\n+\tbinary_op_return_type<vullong, uint, vullong>();\n+\tbinary_op_return_type<vullong, ulong, vullong>();\n+\tbinary_op_return_type<vi32<ullong>, uchar, vi32<ullong>>();\n+\tbinary_op_return_type<vi32<ullong>, ushort, vi32<ullong>>();\n+\tbinary_op_return_type<vi32<ullong>, int, vi32<ullong>>();\n+\tbinary_op_return_type<vi32<ullong>, uint, vi32<ullong>>();\n+\tbinary_op_return_type<vi32<ullong>, ulong, vi32<ullong>>();\n+\tbinary_op_return_type<vi32<ullong>, ullong, vi32<ullong>>();\n+\tbinary_op_return_type<vi32<ullong>, vi32<ullong>, vi32<ullong>>();\n+\tbinary_op_return_type<vi64<ullong>, uchar, vi64<ullong>>();\n+\tbinary_op_return_type<vi64<ullong>, ushort, vi64<ullong>>();\n+\tbinary_op_return_type<vi64<ullong>, int, vi64<ullong>>();\n+\tbinary_op_return_type<vi64<ullong>, uint, vi64<ullong>>();\n+\tbinary_op_return_type<vi64<ullong>, ulong, vi64<ullong>>();\n+\tbinary_op_return_type<vi64<ullong>, ullong, vi64<ullong>>();\n+\tbinary_op_return_type<vi64<ullong>, vi64<ullong>, vi64<ullong>>();\n+\n+\tVERIFY((is_substitution_failure<vullong, schar>));\n+\tVERIFY((is_substitution_failure<vullong, short>));\n+\tVERIFY((is_substitution_failure<vullong, long>));\n+\tVERIFY((is_substitution_failure<vullong, llong>));\n+\tVERIFY((is_substitution_failure<vullong, vllong>));\n+\tVERIFY((is_substitution_failure<vullong, float>));\n+\tVERIFY((is_substitution_failure<vullong, double>));\n+\tVERIFY((is_substitution_failure<vullong, vi64<schar>>));\n+\tVERIFY((is_substitution_failure<vullong, vi64<uchar>>));\n+\tVERIFY((is_substitution_failure<vullong, vi64<short>>));\n+\tVERIFY((is_substitution_failure<vullong, vi64<ushort>>));\n+\tVERIFY((is_substitution_failure<vullong, vi64<int>>));\n+\tVERIFY((is_substitution_failure<vullong, vi64<uint>>));\n+\tVERIFY((is_substitution_failure<vullong, vi64<long>>));\n+\tVERIFY((is_substitution_failure<vullong, vi64<ulong>>));\n+\tVERIFY((is_substitution_failure<vullong, vi64<llong>>));\n+\tVERIFY((is_substitution_failure<vullong, vi64<ullong>>));\n+\tVERIFY((is_substitution_failure<vullong, vi64<float>>));\n+\tVERIFY((is_substitution_failure<vullong, vi64<double>>));\n+\tVERIFY((is_substitution_failure<vi32<ullong>, schar>));\n+\tVERIFY((is_substitution_failure<vi32<ullong>, short>));\n+\tVERIFY((is_substitution_failure<vi32<ullong>, long>));\n+\tVERIFY((is_substitution_failure<vi32<ullong>, llong>));\n+\tVERIFY((is_substitution_failure<vi32<ullong>, float>));\n+\tVERIFY((is_substitution_failure<vi32<ullong>, double>));\n+\tVERIFY((is_substitution_failure<vi32<ullong>, vi32<schar>>));\n+\tbinary_op_return_type<vi32<ullong>, vi32<uchar>>();\n+\tVERIFY((is_substitution_failure<vi32<ullong>, vi32<short>>));\n+\tbinary_op_return_type<vi32<ullong>, vi32<ushort>>();\n+\tVERIFY((is_substitution_failure<vi32<ullong>, vi32<int>>));\n+\tbinary_op_return_type<vi32<ullong>, vi32<uint>>();\n+\tVERIFY((is_substitution_failure<vi32<ullong>, vi32<long>>));\n+\tbinary_op_return_type<vi32<ullong>, vi32<ulong>>();\n+\tVERIFY((is_substitution_failure<vi32<ullong>, vi32<llong>>));\n+\tVERIFY((is_substitution_failure<vi32<ullong>, vi32<float>>));\n+\tVERIFY((is_substitution_failure<vi32<ullong>, vi32<double>>));\n+\tVERIFY((is_substitution_failure<vi64<ullong>, schar>));\n+\tVERIFY((is_substitution_failure<vi64<ullong>, short>));\n+\tVERIFY((is_substitution_failure<vi64<ullong>, long>));\n+\tVERIFY((is_substitution_failure<vi64<ullong>, llong>));\n+\tVERIFY((is_substitution_failure<vi64<ullong>, vllong>));\n+\tVERIFY((is_substitution_failure<vi64<ullong>, vullong>));\n+\tVERIFY((is_substitution_failure<vi64<ullong>, float>));\n+\tVERIFY((is_substitution_failure<vi64<ullong>, double>));\n+\tVERIFY((is_substitution_failure<vi64<ullong>, vi64<schar>>));\n+\tbinary_op_return_type<vi64<ullong>, vi64<uchar>>();\n+\tVERIFY((is_substitution_failure<vi64<ullong>, vi64<short>>));\n+\tbinary_op_return_type<vi64<ullong>, vi64<ushort>>();\n+\tVERIFY((is_substitution_failure<vi64<ullong>, vi64<int>>));\n+\tbinary_op_return_type<vi64<ullong>, vi64<uint>>();\n+\tVERIFY((is_substitution_failure<vi64<ullong>, vi64<long>>));\n+\tbinary_op_return_type<vi64<ullong>, vi64<ulong>>();\n+\tVERIFY((is_substitution_failure<vi64<ullong>, vi64<llong>>));\n+\tVERIFY((is_substitution_failure<vi64<ullong>, vi64<float>>));\n+\tVERIFY((is_substitution_failure<vi64<ullong>, vi64<double>>));\n+      }\n+    else if constexpr (std::is_same_v<V, vint>)\n+      {\n+\tbinary_op_return_type<vint, schar, vint>();\n+\tbinary_op_return_type<vint, uchar, vint>();\n+\tbinary_op_return_type<vint, short, vint>();\n+\tbinary_op_return_type<vint, ushort, vint>();\n+\tbinary_op_return_type<vi32<int>, schar, vi32<int>>();\n+\tbinary_op_return_type<vi32<int>, uchar, vi32<int>>();\n+\tbinary_op_return_type<vi32<int>, short, vi32<int>>();\n+\tbinary_op_return_type<vi32<int>, ushort, vi32<int>>();\n+\tbinary_op_return_type<vi32<int>, int, vi32<int>>();\n+\tbinary_op_return_type<vi32<int>, vi32<int>, vi32<int>>();\n+\tbinary_op_return_type<vi32<int>, vi32<schar>>();\n+\tbinary_op_return_type<vi32<int>, vi32<uchar>>();\n+\tbinary_op_return_type<vi32<int>, vi32<short>>();\n+\tbinary_op_return_type<vi32<int>, vi32<ushort>>();\n+\n+\tbinary_op_return_type<vi32<llong>, vi32<int>>();\n+\tbinary_op_return_type<vi32<double>, vi32<int>>();\n+\n+\t// order is important for MSVC. This compiler is just crazy: It considers\n+\t// operators from unrelated simd template instantiations as candidates -\n+\t// but only after they have been tested. So e.g. vi32<int> + llong will\n+\t// produce a vi32<llong> if a vi32<llong> operator test is done before the\n+\t// vi32<int> + llong test.\n+\tVERIFY((is_substitution_failure<vi32<int>, double>));\n+\tVERIFY((is_substitution_failure<vi32<int>, float>));\n+\tVERIFY((is_substitution_failure<vi32<int>, llong>));\n+\tVERIFY((is_substitution_failure<vi32<int>, vi32<float>>));\n+\tVERIFY((is_substitution_failure<vint, vuint>));\n+\tVERIFY((is_substitution_failure<vint, uint>));\n+\tVERIFY((is_substitution_failure<vint, ulong>));\n+\tVERIFY((is_substitution_failure<vint, llong>));\n+\tVERIFY((is_substitution_failure<vint, ullong>));\n+\tVERIFY((is_substitution_failure<vint, float>));\n+\tVERIFY((is_substitution_failure<vint, double>));\n+\tVERIFY((is_substitution_failure<vint, vi32<schar>>));\n+\tVERIFY((is_substitution_failure<vint, vi32<uchar>>));\n+\tVERIFY((is_substitution_failure<vint, vi32<short>>));\n+\tVERIFY((is_substitution_failure<vint, vi32<ushort>>));\n+\tVERIFY((is_substitution_failure<vint, vi32<int>>));\n+\tVERIFY((is_substitution_failure<vint, vi32<uint>>));\n+\tVERIFY((is_substitution_failure<vint, vi32<long>>));\n+\tVERIFY((is_substitution_failure<vint, vi32<ulong>>));\n+\tVERIFY((is_substitution_failure<vint, vi32<llong>>));\n+\tVERIFY((is_substitution_failure<vint, vi32<ullong>>));\n+\tVERIFY((is_substitution_failure<vint, vi32<float>>));\n+\tVERIFY((is_substitution_failure<vint, vi32<double>>));\n+\tVERIFY((is_substitution_failure<vi32<int>, vint>));\n+\tVERIFY((is_substitution_failure<vi32<int>, vuint>));\n+\tVERIFY((is_substitution_failure<vi32<int>, uint>));\n+\tVERIFY((is_substitution_failure<vi32<int>, ulong>));\n+\tVERIFY((is_substitution_failure<vi32<int>, ullong>));\n+\tVERIFY((is_substitution_failure<vi32<int>, vi32<uint>>));\n+\tVERIFY((is_substitution_failure<vi32<int>, vi32<ulong>>));\n+\tVERIFY((is_substitution_failure<vi32<int>, vi32<ullong>>));\n+\n+\tbinary_op_return_type<vi32<long>, vi32<int>>();\n+\tif constexpr (sizeof(long) == sizeof(llong))\n+\t  {\n+\t    VERIFY((is_substitution_failure<vint, long>));\n+\t    VERIFY((is_substitution_failure<vi32<int>, long>));\n+\t  }\n+\telse\n+\t  {\n+\t    binary_op_return_type<vint, long>();\n+\t    binary_op_return_type<vi32<int>, long>();\n+\t  }\n+      }\n+    else if constexpr (std::is_same_v<V, vuint>)\n+      {\n+\tVERIFY((is_substitution_failure<vi32<uint>, llong>));\n+\tVERIFY((is_substitution_failure<vi32<uint>, ullong>));\n+\tVERIFY((is_substitution_failure<vi32<uint>, float>));\n+\tVERIFY((is_substitution_failure<vi32<uint>, double>));\n+\tVERIFY((is_substitution_failure<vi32<uint>, vi32<float>>));\n+\n+\tbinary_op_return_type<vuint, uchar, vuint>();\n+\tbinary_op_return_type<vuint, ushort, vuint>();\n+\tbinary_op_return_type<vi32<uint>, uchar, vi32<uint>>();\n+\tbinary_op_return_type<vi32<uint>, ushort, vi32<uint>>();\n+\tbinary_op_return_type<vi32<uint>, int, vi32<uint>>();\n+\tbinary_op_return_type<vi32<uint>, uint, vi32<uint>>();\n+\tbinary_op_return_type<vi32<uint>, vi32<uint>, vi32<uint>>();\n+\tbinary_op_return_type<vi32<uint>, vi32<uchar>>();\n+\tbinary_op_return_type<vi32<uint>, vi32<ushort>>();\n+\n+\tbinary_op_return_type<vi32<llong>, vi32<uint>>();\n+\tbinary_op_return_type<vi32<ullong>, vi32<uint>>();\n+\tbinary_op_return_type<vi32<double>, vi32<uint>>();\n+\n+\tVERIFY((is_substitution_failure<vuint, schar>));\n+\tVERIFY((is_substitution_failure<vuint, short>));\n+\tVERIFY((is_substitution_failure<vuint, vint>));\n+\tVERIFY((is_substitution_failure<vuint, long>));\n+\tVERIFY((is_substitution_failure<vuint, llong>));\n+\tVERIFY((is_substitution_failure<vuint, ullong>));\n+\tVERIFY((is_substitution_failure<vuint, float>));\n+\tVERIFY((is_substitution_failure<vuint, double>));\n+\tVERIFY((is_substitution_failure<vuint, vi32<schar>>));\n+\tVERIFY((is_substitution_failure<vuint, vi32<uchar>>));\n+\tVERIFY((is_substitution_failure<vuint, vi32<short>>));\n+\tVERIFY((is_substitution_failure<vuint, vi32<ushort>>));\n+\tVERIFY((is_substitution_failure<vuint, vi32<int>>));\n+\tVERIFY((is_substitution_failure<vuint, vi32<uint>>));\n+\tVERIFY((is_substitution_failure<vuint, vi32<long>>));\n+\tVERIFY((is_substitution_failure<vuint, vi32<ulong>>));\n+\tVERIFY((is_substitution_failure<vuint, vi32<llong>>));\n+\tVERIFY((is_substitution_failure<vuint, vi32<ullong>>));\n+\tVERIFY((is_substitution_failure<vuint, vi32<float>>));\n+\tVERIFY((is_substitution_failure<vuint, vi32<double>>));\n+\tVERIFY((is_substitution_failure<vi32<uint>, schar>));\n+\tVERIFY((is_substitution_failure<vi32<uint>, short>));\n+\tVERIFY((is_substitution_failure<vi32<uint>, vint>));\n+\tVERIFY((is_substitution_failure<vi32<uint>, vuint>));\n+\tVERIFY((is_substitution_failure<vi32<uint>, long>));\n+\tVERIFY((is_substitution_failure<vi32<uint>, vi32<schar>>));\n+\tVERIFY((is_substitution_failure<vi32<uint>, vi32<short>>));\n+\tVERIFY((is_substitution_failure<vi32<uint>, vi32<int>>));\n+\n+\tbinary_op_return_type<vi32<ulong>, vi32<uint>>();\n+\tif constexpr (sizeof(long) == sizeof(llong))\n+\t  {\n+\t    VERIFY((is_substitution_failure<vuint, ulong>));\n+\t    VERIFY((is_substitution_failure<vi32<uint>, ulong>));\n+\t    binary_op_return_type<vi32<long>, vi32<uint>>();\n+\t  }\n+\telse\n+\t  {\n+\t    binary_op_return_type<vuint, ulong>();\n+\t    binary_op_return_type<vi32<uint>, ulong>();\n+\t    VERIFY((is_substitution_failure<vi32<uint>, vi32<long>>));\n+\t  }\n+      }\n+    else if constexpr (std::is_same_v<V, vshort>)\n+      {\n+\tbinary_op_return_type<vshort, schar, vshort>();\n+\tbinary_op_return_type<vshort, uchar, vshort>();\n+\tbinary_op_return_type<vi16<short>, schar, vi16<short>>();\n+\tbinary_op_return_type<vi16<short>, uchar, vi16<short>>();\n+\tbinary_op_return_type<vi16<short>, short, vi16<short>>();\n+\tbinary_op_return_type<vi16<short>, int, vi16<short>>();\n+\tbinary_op_return_type<vi16<short>, vi16<schar>>();\n+\tbinary_op_return_type<vi16<short>, vi16<uchar>>();\n+\tbinary_op_return_type<vi16<short>, vi16<short>>();\n+\n+\tbinary_op_return_type<vi16<int>, vi16<short>>();\n+\tbinary_op_return_type<vi16<long>, vi16<short>>();\n+\tbinary_op_return_type<vi16<llong>, vi16<short>>();\n+\tbinary_op_return_type<vi16<float>, vi16<short>>();\n+\tbinary_op_return_type<vi16<double>, vi16<short>>();\n+\n+\tVERIFY((is_substitution_failure<vi16<short>, double>));\n+\tVERIFY((is_substitution_failure<vi16<short>, llong>));\n+\tVERIFY((is_substitution_failure<vshort, vushort>));\n+\tVERIFY((is_substitution_failure<vshort, ushort>));\n+\tVERIFY((is_substitution_failure<vshort, uint>));\n+\tVERIFY((is_substitution_failure<vshort, long>));\n+\tVERIFY((is_substitution_failure<vshort, ulong>));\n+\tVERIFY((is_substitution_failure<vshort, llong>));\n+\tVERIFY((is_substitution_failure<vshort, ullong>));\n+\tVERIFY((is_substitution_failure<vshort, float>));\n+\tVERIFY((is_substitution_failure<vshort, double>));\n+\tVERIFY((is_substitution_failure<vshort, vi16<schar>>));\n+\tVERIFY((is_substitution_failure<vshort, vi16<uchar>>));\n+\tVERIFY((is_substitution_failure<vshort, vi16<short>>));\n+\tVERIFY((is_substitution_failure<vshort, vi16<ushort>>));\n+\tVERIFY((is_substitution_failure<vshort, vi16<int>>));\n+\tVERIFY((is_substitution_failure<vshort, vi16<uint>>));\n+\tVERIFY((is_substitution_failure<vshort, vi16<long>>));\n+\tVERIFY((is_substitution_failure<vshort, vi16<ulong>>));\n+\tVERIFY((is_substitution_failure<vshort, vi16<llong>>));\n+\tVERIFY((is_substitution_failure<vshort, vi16<ullong>>));\n+\tVERIFY((is_substitution_failure<vshort, vi16<float>>));\n+\tVERIFY((is_substitution_failure<vshort, vi16<double>>));\n+\tVERIFY((is_substitution_failure<vi16<short>, vshort>));\n+\tVERIFY((is_substitution_failure<vi16<short>, vushort>));\n+\tVERIFY((is_substitution_failure<vi16<short>, ushort>));\n+\tVERIFY((is_substitution_failure<vi16<short>, uint>));\n+\tVERIFY((is_substitution_failure<vi16<short>, long>));\n+\tVERIFY((is_substitution_failure<vi16<short>, ulong>));\n+\tVERIFY((is_substitution_failure<vi16<short>, ullong>));\n+\tVERIFY((is_substitution_failure<vi16<short>, float>));\n+\tVERIFY((is_substitution_failure<vi16<short>, vi16<ushort>>));\n+\tVERIFY((is_substitution_failure<vi16<short>, vi16<uint>>));\n+\tVERIFY((is_substitution_failure<vi16<short>, vi16<ulong>>));\n+\tVERIFY((is_substitution_failure<vi16<short>, vi16<ullong>>));\n+      }\n+    else if constexpr (std::is_same_v<V, vushort>)\n+      {\n+\tbinary_op_return_type<vushort, uchar, vushort>();\n+\tbinary_op_return_type<vushort, uint, vushort>();\n+\tbinary_op_return_type<vi16<ushort>, uchar, vi16<ushort>>();\n+\tbinary_op_return_type<vi16<ushort>, ushort, vi16<ushort>>();\n+\tbinary_op_return_type<vi16<ushort>, int, vi16<ushort>>();\n+\tbinary_op_return_type<vi16<ushort>, uint, vi16<ushort>>();\n+\tbinary_op_return_type<vi16<ushort>, vi16<uchar>>();\n+\tbinary_op_return_type<vi16<ushort>, vi16<ushort>>();\n+\n+\tbinary_op_return_type<vi16<int>, vi16<ushort>>();\n+\tbinary_op_return_type<vi16<long>, vi16<ushort>>();\n+\tbinary_op_return_type<vi16<llong>, vi16<ushort>>();\n+\tbinary_op_return_type<vi16<uint>, vi16<ushort>>();\n+\tbinary_op_return_type<vi16<ulong>, vi16<ushort>>();\n+\tbinary_op_return_type<vi16<ullong>, vi16<ushort>>();\n+\tbinary_op_return_type<vi16<float>, vi16<ushort>>();\n+\tbinary_op_return_type<vi16<double>, vi16<ushort>>();\n+\n+\tVERIFY((is_substitution_failure<vi16<ushort>, llong>));\n+\tVERIFY((is_substitution_failure<vi16<ushort>, ullong>));\n+\tVERIFY((is_substitution_failure<vi16<ushort>, double>));\n+\tVERIFY((is_substitution_failure<vushort, schar>));\n+\tVERIFY((is_substitution_failure<vushort, short>));\n+\tVERIFY((is_substitution_failure<vushort, vshort>));\n+\tVERIFY((is_substitution_failure<vushort, long>));\n+\tVERIFY((is_substitution_failure<vushort, ulong>));\n+\tVERIFY((is_substitution_failure<vushort, llong>));\n+\tVERIFY((is_substitution_failure<vushort, ullong>));\n+\tVERIFY((is_substitution_failure<vushort, float>));\n+\tVERIFY((is_substitution_failure<vushort, double>));\n+\tVERIFY((is_substitution_failure<vushort, vi16<schar>>));\n+\tVERIFY((is_substitution_failure<vushort, vi16<uchar>>));\n+\tVERIFY((is_substitution_failure<vushort, vi16<short>>));\n+\tVERIFY((is_substitution_failure<vushort, vi16<ushort>>));\n+\tVERIFY((is_substitution_failure<vushort, vi16<int>>));\n+\tVERIFY((is_substitution_failure<vushort, vi16<uint>>));\n+\tVERIFY((is_substitution_failure<vushort, vi16<long>>));\n+\tVERIFY((is_substitution_failure<vushort, vi16<ulong>>));\n+\tVERIFY((is_substitution_failure<vushort, vi16<llong>>));\n+\tVERIFY((is_substitution_failure<vushort, vi16<ullong>>));\n+\tVERIFY((is_substitution_failure<vushort, vi16<float>>));\n+\tVERIFY((is_substitution_failure<vushort, vi16<double>>));\n+\tVERIFY((is_substitution_failure<vi16<ushort>, schar>));\n+\tVERIFY((is_substitution_failure<vi16<ushort>, short>));\n+\tVERIFY((is_substitution_failure<vi16<ushort>, vshort>));\n+\tVERIFY((is_substitution_failure<vi16<ushort>, vushort>));\n+\tVERIFY((is_substitution_failure<vi16<ushort>, long>));\n+\tVERIFY((is_substitution_failure<vi16<ushort>, ulong>));\n+\tVERIFY((is_substitution_failure<vi16<ushort>, float>));\n+\tVERIFY((is_substitution_failure<vi16<ushort>, vi16<schar>>));\n+\tVERIFY((is_substitution_failure<vi16<ushort>, vi16<short>>));\n+      }\n+    else if constexpr (std::is_same_v<V, vchar>)\n+      {\n+\tbinary_op_return_type<vi8<char>, char, vi8<char>>();\n+\tbinary_op_return_type<vi8<char>, int, vi8<char>>();\n+\tbinary_op_return_type<vi8<char>, vi8<char>, vi8<char>>();\n+\n+\tif constexpr (vi8<schar>::size() <= simd_abi::max_fixed_size<short>)\n+\t  {\n+\t    VERIFY(!(is_substitution_failure<vi8<char>, vi8<short>>));\n+\t    VERIFY(!(is_substitution_failure<vi8<char>, vi8<int>>));\n+\t    VERIFY(!(is_substitution_failure<vi8<char>, vi8<long>>));\n+\t    VERIFY(!(is_substitution_failure<vi8<char>, vi8<llong>>));\n+\t    COMPARE((is_substitution_failure<vi8<char>, vi8<ushort>>),\n+\t\t    std::is_signed_v<char>);\n+\t    COMPARE((is_substitution_failure<vi8<char>, vi8<uint>>),\n+\t\t    std::is_signed_v<char>);\n+\t    COMPARE((is_substitution_failure<vi8<char>, vi8<ulong>>),\n+\t\t    std::is_signed_v<char>);\n+\t    COMPARE((is_substitution_failure<vi8<char>, vi8<ullong>>),\n+\t\t    std::is_signed_v<char>);\n+\t    if constexpr (std::is_signed_v<char>)\n+\t      {\n+\t\tbinary_op_return_type<vi8<short>, vi8<char>>();\n+\t\tbinary_op_return_type<vi8<int>, vi8<char>>();\n+\t\tbinary_op_return_type<vi8<long>, vi8<char>>();\n+\t\tbinary_op_return_type<vi8<llong>, vi8<char>>();\n+\t      }\n+\t    else\n+\t      {\n+\t\tbinary_op_return_type<vi8<ushort>, vi8<char>>();\n+\t\tbinary_op_return_type<vi8<uint>, vi8<char>>();\n+\t\tbinary_op_return_type<vi8<ulong>, vi8<char>>();\n+\t\tbinary_op_return_type<vi8<ullong>, vi8<char>>();\n+\t      }\n+\t    binary_op_return_type<vi8<float>, vi8<char>>();\n+\t    binary_op_return_type<vi8<double>, vi8<char>>();\n+\t  }\n+\n+\tVERIFY((is_substitution_failure<vi8<char>, llong>));\n+\tVERIFY((is_substitution_failure<vi8<char>, double>));\n+\tVERIFY((is_substitution_failure<vchar, vxchar>));\n+\tVERIFY((is_substitution_failure<vchar, xchar>));\n+\tVERIFY((is_substitution_failure<vchar, short>));\n+\tVERIFY((is_substitution_failure<vchar, ushort>));\n+\tCOMPARE((is_substitution_failure<vchar, uint>), std::is_signed_v<char>);\n+\tVERIFY((is_substitution_failure<vchar, long>));\n+\tVERIFY((is_substitution_failure<vchar, ulong>));\n+\tVERIFY((is_substitution_failure<vchar, llong>));\n+\tVERIFY((is_substitution_failure<vchar, ullong>));\n+\tVERIFY((is_substitution_failure<vchar, float>));\n+\tVERIFY((is_substitution_failure<vchar, double>));\n+\tVERIFY((is_substitution_failure<vchar, vi8<char>>));\n+\tVERIFY((is_substitution_failure<vchar, vi8<uchar>>));\n+\tVERIFY((is_substitution_failure<vchar, vi8<schar>>));\n+\tVERIFY((is_substitution_failure<vchar, vi8<short>>));\n+\tVERIFY((is_substitution_failure<vchar, vi8<ushort>>));\n+\tVERIFY((is_substitution_failure<vchar, vi8<int>>));\n+\tVERIFY((is_substitution_failure<vchar, vi8<uint>>));\n+\tVERIFY((is_substitution_failure<vchar, vi8<long>>));\n+\tVERIFY((is_substitution_failure<vchar, vi8<ulong>>));\n+\tVERIFY((is_substitution_failure<vchar, vi8<llong>>));\n+\tVERIFY((is_substitution_failure<vchar, vi8<ullong>>));\n+\tVERIFY((is_substitution_failure<vchar, vi8<float>>));\n+\tVERIFY((is_substitution_failure<vchar, vi8<double>>));\n+\tVERIFY((is_substitution_failure<vi8<char>, vchar>));\n+\tVERIFY((is_substitution_failure<vi8<char>, vuchar>));\n+\tVERIFY((is_substitution_failure<vi8<char>, vschar>));\n+\tVERIFY((is_substitution_failure<vi8<char>, xchar>));\n+\tVERIFY((is_substitution_failure<vi8<char>, short>));\n+\tVERIFY((is_substitution_failure<vi8<char>, ushort>));\n+\tCOMPARE((is_substitution_failure<vi8<char>, uint>),\n+\t\tstd::is_signed_v<char>);\n+\tVERIFY((is_substitution_failure<vi8<char>, long>));\n+\tVERIFY((is_substitution_failure<vi8<char>, ulong>));\n+\tVERIFY((is_substitution_failure<vi8<char>, ullong>));\n+\tVERIFY((is_substitution_failure<vi8<char>, float>));\n+\n+\t// conversion between any char types must fail because the dst type's\n+\t// integer conversion rank isn't greater (as required by 9.6.4p4.3)\n+\tVERIFY((is_substitution_failure<vi8<char>, vi8<schar>>));\n+\tVERIFY((is_substitution_failure<vi8<char>, vi8<uchar>>));\n+      }\n+    else if constexpr (std::is_same_v<V, vschar>)\n+      {\n+\tbinary_op_return_type<vi8<schar>, schar, vi8<schar>>();\n+\tbinary_op_return_type<vi8<schar>, int, vi8<schar>>();\n+\tbinary_op_return_type<vi8<schar>, vi8<schar>, vi8<schar>>();\n+\n+\tif constexpr (vi8<schar>::size() <= simd_abi::max_fixed_size<short>)\n+\t  {\n+\t    binary_op_return_type<vi8<short>, vi8<schar>>();\n+\t    binary_op_return_type<vi8<int>, vi8<schar>>();\n+\t    binary_op_return_type<vi8<long>, vi8<schar>>();\n+\t    binary_op_return_type<vi8<llong>, vi8<schar>>();\n+\t    binary_op_return_type<vi8<float>, vi8<schar>>();\n+\t    binary_op_return_type<vi8<double>, vi8<schar>>();\n+\t  }\n+\n+\tVERIFY((is_substitution_failure<vi8<schar>, llong>));\n+\tVERIFY((is_substitution_failure<vi8<schar>, double>));\n+\tVERIFY((is_substitution_failure<vschar, vuchar>));\n+\tVERIFY((is_substitution_failure<vschar, uchar>));\n+\tVERIFY((is_substitution_failure<vschar, short>));\n+\tVERIFY((is_substitution_failure<vschar, ushort>));\n+\tVERIFY((is_substitution_failure<vschar, uint>));\n+\tVERIFY((is_substitution_failure<vschar, long>));\n+\tVERIFY((is_substitution_failure<vschar, ulong>));\n+\tVERIFY((is_substitution_failure<vschar, llong>));\n+\tVERIFY((is_substitution_failure<vschar, ullong>));\n+\tVERIFY((is_substitution_failure<vschar, float>));\n+\tVERIFY((is_substitution_failure<vschar, double>));\n+\tVERIFY((is_substitution_failure<vschar, vi8<schar>>));\n+\tVERIFY((is_substitution_failure<vschar, vi8<uchar>>));\n+\tVERIFY((is_substitution_failure<vschar, vi8<short>>));\n+\tVERIFY((is_substitution_failure<vschar, vi8<ushort>>));\n+\tVERIFY((is_substitution_failure<vschar, vi8<int>>));\n+\tVERIFY((is_substitution_failure<vschar, vi8<uint>>));\n+\tVERIFY((is_substitution_failure<vschar, vi8<long>>));\n+\tVERIFY((is_substitution_failure<vschar, vi8<ulong>>));\n+\tVERIFY((is_substitution_failure<vschar, vi8<llong>>));\n+\tVERIFY((is_substitution_failure<vschar, vi8<ullong>>));\n+\tVERIFY((is_substitution_failure<vschar, vi8<float>>));\n+\tVERIFY((is_substitution_failure<vschar, vi8<double>>));\n+\tVERIFY((is_substitution_failure<vi8<schar>, vschar>));\n+\tVERIFY((is_substitution_failure<vi8<schar>, vuchar>));\n+\tVERIFY((is_substitution_failure<vi8<schar>, uchar>));\n+\tVERIFY((is_substitution_failure<vi8<schar>, short>));\n+\tVERIFY((is_substitution_failure<vi8<schar>, ushort>));\n+\tVERIFY((is_substitution_failure<vi8<schar>, uint>));\n+\tVERIFY((is_substitution_failure<vi8<schar>, long>));\n+\tVERIFY((is_substitution_failure<vi8<schar>, ulong>));\n+\tVERIFY((is_substitution_failure<vi8<schar>, ullong>));\n+\tVERIFY((is_substitution_failure<vi8<schar>, float>));\n+\tVERIFY((is_substitution_failure<vi8<schar>, vi8<uchar>>));\n+\tVERIFY((is_substitution_failure<vi8<schar>, vi8<ushort>>));\n+\tVERIFY((is_substitution_failure<vi8<schar>, vi8<uint>>));\n+\tVERIFY((is_substitution_failure<vi8<schar>, vi8<ulong>>));\n+\tVERIFY((is_substitution_failure<vi8<schar>, vi8<ullong>>));\n+      }\n+    else if constexpr (std::is_same_v<V, vuchar>)\n+      {\n+\tVERIFY((is_substitution_failure<vi8<uchar>, llong>));\n+\n+\tbinary_op_return_type<vuchar, uint, vuchar>();\n+\tbinary_op_return_type<vi8<uchar>, uchar, vi8<uchar>>();\n+\tbinary_op_return_type<vi8<uchar>, int, vi8<uchar>>();\n+\tbinary_op_return_type<vi8<uchar>, uint, vi8<uchar>>();\n+\tbinary_op_return_type<vi8<uchar>, vi8<uchar>, vi8<uchar>>();\n+\n+\tif constexpr (vi8<schar>::size() <= simd_abi::max_fixed_size<short>)\n+\t  {\n+\t    binary_op_return_type<vi8<short>, vi8<uchar>>();\n+\t    binary_op_return_type<vi8<ushort>, vi8<uchar>>();\n+\t    binary_op_return_type<vi8<int>, vi8<uchar>>();\n+\t    binary_op_return_type<vi8<uint>, vi8<uchar>>();\n+\t    binary_op_return_type<vi8<long>, vi8<uchar>>();\n+\t    binary_op_return_type<vi8<ulong>, vi8<uchar>>();\n+\t    binary_op_return_type<vi8<llong>, vi8<uchar>>();\n+\t    binary_op_return_type<vi8<ullong>, vi8<uchar>>();\n+\t    binary_op_return_type<vi8<float>, vi8<uchar>>();\n+\t    binary_op_return_type<vi8<double>, vi8<uchar>>();\n+\t  }\n+\n+\tVERIFY((is_substitution_failure<vi8<uchar>, ullong>));\n+\tVERIFY((is_substitution_failure<vi8<uchar>, double>));\n+\tVERIFY((is_substitution_failure<vuchar, schar>));\n+\tVERIFY((is_substitution_failure<vuchar, vschar>));\n+\tVERIFY((is_substitution_failure<vuchar, short>));\n+\tVERIFY((is_substitution_failure<vuchar, ushort>));\n+\tVERIFY((is_substitution_failure<vuchar, long>));\n+\tVERIFY((is_substitution_failure<vuchar, ulong>));\n+\tVERIFY((is_substitution_failure<vuchar, llong>));\n+\tVERIFY((is_substitution_failure<vuchar, ullong>));\n+\tVERIFY((is_substitution_failure<vuchar, float>));\n+\tVERIFY((is_substitution_failure<vuchar, double>));\n+\tVERIFY((is_substitution_failure<vuchar, vi8<schar>>));\n+\tVERIFY((is_substitution_failure<vuchar, vi8<uchar>>));\n+\tVERIFY((is_substitution_failure<vuchar, vi8<short>>));\n+\tVERIFY((is_substitution_failure<vuchar, vi8<ushort>>));\n+\tVERIFY((is_substitution_failure<vuchar, vi8<int>>));\n+\tVERIFY((is_substitution_failure<vuchar, vi8<uint>>));\n+\tVERIFY((is_substitution_failure<vuchar, vi8<long>>));\n+\tVERIFY((is_substitution_failure<vuchar, vi8<ulong>>));\n+\tVERIFY((is_substitution_failure<vuchar, vi8<llong>>));\n+\tVERIFY((is_substitution_failure<vuchar, vi8<ullong>>));\n+\tVERIFY((is_substitution_failure<vuchar, vi8<float>>));\n+\tVERIFY((is_substitution_failure<vuchar, vi8<double>>));\n+\tVERIFY((is_substitution_failure<vi8<uchar>, schar>));\n+\tVERIFY((is_substitution_failure<vi8<uchar>, vschar>));\n+\tVERIFY((is_substitution_failure<vi8<uchar>, vuchar>));\n+\tVERIFY((is_substitution_failure<vi8<uchar>, short>));\n+\tVERIFY((is_substitution_failure<vi8<uchar>, ushort>));\n+\tVERIFY((is_substitution_failure<vi8<uchar>, long>));\n+\tVERIFY((is_substitution_failure<vi8<uchar>, ulong>));\n+\tVERIFY((is_substitution_failure<vi8<uchar>, float>));\n+\tVERIFY((is_substitution_failure<vi8<uchar>, vi8<schar>>));\n+      }\n+  }"}, {"sha": "cee696cc69bf4d4815df81ac48c546aabc73525f", "filename": "libstdc++-v3/testsuite/experimental/simd/tests/operators.cc", "status": "added", "additions": 297, "deletions": 0, "changes": 297, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02e32295b284bd4f4d038e73ee3118fb0546650e/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fsimd%2Ftests%2Foperators.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02e32295b284bd4f4d038e73ee3118fb0546650e/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fsimd%2Ftests%2Foperators.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fsimd%2Ftests%2Foperators.cc?ref=02e32295b284bd4f4d038e73ee3118fb0546650e", "patch": "@@ -0,0 +1,297 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"bits/verify.h\"\n+#include \"bits/make_vec.h\"\n+#include \"bits/test_values.h\"\n+\n+template <class T>\n+  constexpr T\n+  genHalfBits()\n+  {\n+    if constexpr (std::is_floating_point_v<T>)\n+      return 0;\n+    else\n+      return std::__finite_max_v<T> >> (std::__digits_v<T> / 2);\n+  }\n+\n+template <typename V>\n+  void\n+  test()\n+  {\n+    using M = typename V::mask_type;\n+    using T = typename V::value_type;\n+    constexpr auto min = std::__finite_min_v<T>;\n+    constexpr auto norm_min = std::__norm_min_v<T>;\n+    constexpr auto max = std::__finite_max_v<T>;\n+    { // compares\n+      COMPARE(V(0) == make_vec<V>({0, 1}, 0), make_mask<M>({1, 0}));\n+      COMPARE(V(0) == make_vec<V>({0, 1, 2}, 0), make_mask<M>({1, 0, 0}));\n+      COMPARE(V(1) == make_vec<V>({0, 1, 2}, 0), make_mask<M>({0, 1, 0}));\n+      COMPARE(V(2) == make_vec<V>({0, 1, 2}, 0), make_mask<M>({0, 0, 1}));\n+      COMPARE(V(0) < make_vec<V>({0, 1, 2}, 0), make_mask<M>({0, 1, 1}));\n+\n+      constexpr T half = genHalfBits<T>();\n+      for (T lo_ : {min, T(min + 1), T(-1), T(0), norm_min, T(1), T(half - 1),\n+\t\t    half, T(half + 1), T(max - 1)})\n+\t{\n+\t  for (T hi_ : {T(min + 1), T(-1), T(0), norm_min, T(1), T(half - 1),\n+\t\t\thalf, T(half + 1), T(max - 1), max})\n+\t    {\n+\t      if (hi_ <= lo_)\n+\t\tcontinue;\n+\n+\t      for (std::size_t pos = 0; pos < V::size(); ++pos)\n+\t\t{\n+\t\t  V lo = lo_;\n+\t\t  V hi = hi_;\n+\t\t  lo[pos] = 0; // have a different value in the vector in case\n+\t\t  hi[pos] = 1; // this affects neighbors\n+\t\t  COMPARE(hi, hi);\n+\t\t  VERIFY(all_of(hi != lo)) << \"hi: \" << hi << \", lo: \" << lo;\n+\t\t  VERIFY(all_of(lo != hi)) << \"hi: \" << hi << \", lo: \" << lo;\n+\t\t  VERIFY(none_of(hi != hi)) << \"hi: \" << hi << \", lo: \" << lo;\n+\t\t  VERIFY(none_of(hi == lo)) << \"hi: \" << hi << \", lo: \" << lo;\n+\t\t  VERIFY(none_of(lo == hi)) << \"hi: \" << hi << \", lo: \" << lo;\n+\t\t  VERIFY(all_of(lo < hi)) << \"hi: \" << hi << \", lo: \" << lo\n+\t\t\t\t\t  << \", lo < hi: \" << (lo < hi);\n+\t\t  VERIFY(none_of(hi < lo)) << \"hi: \" << hi << \", lo: \" << lo;\n+\t\t  VERIFY(none_of(hi <= lo)) << \"hi: \" << hi << \", lo: \" << lo;\n+\t\t  VERIFY(all_of(hi <= hi)) << \"hi: \" << hi << \", lo: \" << lo;\n+\t\t  VERIFY(all_of(hi > lo)) << \"hi: \" << hi << \", lo: \" << lo;\n+\t\t  VERIFY(none_of(lo > hi)) << \"hi: \" << hi << \", lo: \" << lo;\n+\t\t  VERIFY(all_of(hi >= lo)) << \"hi: \" << hi << \", lo: \" << lo;\n+\t\t  VERIFY(all_of(hi >= hi)) << \"hi: \" << hi << \", lo: \" << lo;\n+\t\t}\n+\t    }\n+\t}\n+    }\n+    { // subscripting\n+      V x = max;\n+      for (std::size_t i = 0; i < V::size(); ++i)\n+\t{\n+\t  COMPARE(x[i], max);\n+\t  x[i] = 0;\n+\t}\n+      COMPARE(x, V{0});\n+      for (std::size_t i = 0; i < V::size(); ++i)\n+\t{\n+\t  COMPARE(x[i], T(0));\n+\t  x[i] = max;\n+\t}\n+      COMPARE(x, V{max});\n+      COMPARE(typeid(x[0] * x[0]), typeid(T() * T()));\n+      COMPARE(typeid(x[0] * T()), typeid(T() * T()));\n+      COMPARE(typeid(T() * x[0]), typeid(T() * T()));\n+      COMPARE(typeid(x * x[0]), typeid(x));\n+      COMPARE(typeid(x[0] * x), typeid(x));\n+\n+      x = V([](auto i) -> T { return i; });\n+      for (std::size_t i = 0; i < V::size(); ++i)\n+\t{\n+\t  COMPARE(x[i], T(i));\n+\t}\n+      for (std::size_t i = 0; i + 1 < V::size(); i += 2)\n+\t{\n+\t  using std::swap;\n+\t  swap(x[i], x[i + 1]);\n+\t}\n+      for (std::size_t i = 0; i + 1 < V::size(); i += 2)\n+\t{\n+\t  COMPARE(x[i], T(i + 1)) << x;\n+\t  COMPARE(x[i + 1], T(i)) << x;\n+\t}\n+      x = 1;\n+      V y = 0;\n+      COMPARE(x[0], T(1));\n+      x[0] = y[0]; // make sure non-const smart_reference assignment works\n+      COMPARE(x[0], T(0));\n+      x = 1;\n+      x[0] = x[0]; // self-assignment on smart_reference\n+      COMPARE(x[0], T(1));\n+\n+      std::experimental::simd<typename V::value_type,\n+\t\t\t      std::experimental::simd_abi::scalar>\n+      z = 2;\n+      x[0] = z[0];\n+      COMPARE(x[0], T(2));\n+      x = 3;\n+      z[0] = x[0];\n+      COMPARE(z[0], T(3));\n+\n+      // TODO: check that only value-preserving conversions happen on subscript\n+      // assignment\n+    }\n+    { // not\n+      V x = 0;\n+      COMPARE(!x, M{true});\n+      V y = 1;\n+      COMPARE(!y, M{false});\n+    }\n+\n+    { // unary minus\n+      V x = 0;\n+      COMPARE(-x, V(T(-T(0))));\n+      V y = 1;\n+      COMPARE(-y, V(T(-T(1))));\n+    }\n+\n+    { // plus\n+      V x = 0;\n+      V y = 0;\n+      COMPARE(x + y, x);\n+      COMPARE(x = x + T(1), V(1));\n+      COMPARE(x + x, V(2));\n+      y = make_vec<V>({1, 2, 3, 4, 5, 6, 7});\n+      COMPARE(x = x + y, make_vec<V>({2, 3, 4, 5, 6, 7, 8}));\n+      COMPARE(x = x + -y, V(1));\n+      COMPARE(x += y, make_vec<V>({2, 3, 4, 5, 6, 7, 8}));\n+      COMPARE(x, make_vec<V>({2, 3, 4, 5, 6, 7, 8}));\n+      COMPARE(x += -y, V(1));\n+      COMPARE(x, V(1));\n+    }\n+\n+    { // minus\n+      V x = 1;\n+      V y = 0;\n+      COMPARE(x - y, x);\n+      COMPARE(x - T(1), y);\n+      COMPARE(y, x - T(1));\n+      COMPARE(x - x, y);\n+      y = make_vec<V>({1, 2, 3, 4, 5, 6, 7});\n+      COMPARE(x = y - x, make_vec<V>({0, 1, 2, 3, 4, 5, 6}));\n+      COMPARE(x = y - x, V(1));\n+      COMPARE(y -= x, make_vec<V>({0, 1, 2, 3, 4, 5, 6}));\n+      COMPARE(y, make_vec<V>({0, 1, 2, 3, 4, 5, 6}));\n+      COMPARE(y -= y, V(0));\n+      COMPARE(y, V(0));\n+    }\n+\n+    { // multiplies\n+      V x = 1;\n+      V y = 0;\n+      COMPARE(x * y, y);\n+      COMPARE(x = x * T(2), V(2));\n+      COMPARE(x * x, V(4));\n+      y = make_vec<V>({1, 2, 3, 4, 5, 6, 7});\n+      COMPARE(x = x * y, make_vec<V>({2, 4, 6, 8, 10, 12, 14}));\n+      y = 2;\n+      // don't test norm_min/2*2 in the following. There's no guarantee, in\n+      // general, that the result isn't flushed to zero (e.g. NEON without\n+      // subnormals)\n+      for (T n :\n+      {T(max - 1), std::is_floating_point_v<T> ? T(norm_min * 3) : min})\n+\t{\n+\t  x = n / 2;\n+\t  COMPARE(x * y, V(n));\n+\t}\n+      if (std::is_integral<T>::value && std::is_unsigned<T>::value)\n+\t{\n+\t  // test modulo arithmetics\n+\t  T n = max;\n+\t  x = n;\n+\t  for (T m : {T(2), T(7), T(max / 127), max})\n+\t    {\n+\t      y = m;\n+\t      // if T is of lower rank than int, `n * m` will promote to int\n+\t      // before executing the multiplication. In this case an overflow\n+\t      // will be UB (and ubsan will warn about it). The solution is to\n+\t      // cast to uint in that case.\n+\t      using U\n+\t\t= std::conditional_t<(sizeof(T) < sizeof(int)), unsigned, T>;\n+\t      COMPARE(x * y, V(T(U(n) * U(m))));\n+\t    }\n+\t}\n+      x = 2;\n+      COMPARE(x *= make_vec<V>({1, 2, 3}), make_vec<V>({2, 4, 6}));\n+      COMPARE(x, make_vec<V>({2, 4, 6}));\n+    }\n+\n+    // divides\n+    constexpr bool is_iec559 = __GCC_IEC_559 >= 2;\n+    if constexpr (std::is_floating_point_v<T> && !is_iec559)\n+      { // avoid testing subnormals and expect minor deltas for non-IEC559 float\n+\tV x = 2;\n+\tULP_COMPARE(x / x, V(1), 1);\n+\tULP_COMPARE(T(3) / x, V(T(3) / T(2)), 1);\n+\tULP_COMPARE(x / T(3), V(T(2) / T(3)), 1);\n+\tV y = make_vec<V>({1, 2, 3, 4, 5, 6, 7});\n+\tULP_COMPARE(y / x,\n+\t\t    make_vec<V>(\n+\t\t      {T(.5), T(1), T(1.5), T(2), T(2.5), T(3), T(3.5)}),\n+\t\t    1);\n+\n+\ttest_values<V>({norm_min * 1024, T(1), T(), T(-1), max / 1024,\n+\t\t\tmax / 4.1, max, min},\n+\t\t       [&](V a) {\n+\t\t\t V b = 2;\n+\t\t\t V ref([&](auto i) { return a[i] / 2; });\n+\t\t\t ULP_COMPARE(a / b, ref, 1);\n+\t\t\t where(a == 0, a) = 1;\n+\t\t\t // -freciprocal-math together with flush-to-zero makes\n+\t\t\t // the following range restriction necessary (i.e.\n+\t\t\t // 1/|a| must be >= min). Intel vrcpps and vrcp14ps\n+\t\t\t // need some extra slack (use 1.1 instead of 1).\n+\t\t\t where(abs(a) >= T(1.1) / norm_min, a) = 1;\n+\t\t\t ULP_COMPARE(a / a, V(1), 1) << \"\\na = \" << a;\n+\t\t\t ref = V([&](auto i) { return 2 / a[i]; });\n+\t\t\t ULP_COMPARE(b / a, ref, 1) << \"\\na = \" << a;\n+\t\t\t ULP_COMPARE(b /= a, ref, 1);\n+\t\t\t ULP_COMPARE(b, ref, 1);\n+\t\t       });\n+      }\n+    else\n+      {\n+\tV x = 2;\n+\tCOMPARE(x / x, V(1));\n+\tCOMPARE(T(3) / x, V(T(3) / T(2)));\n+\tCOMPARE(x / T(3), V(T(2) / T(3)));\n+\tV y = make_vec<V>({1, 2, 3, 4, 5, 6, 7});\n+\tCOMPARE(y / x,\n+\t\tmake_vec<V>({T(.5), T(1), T(1.5), T(2), T(2.5), T(3), T(3.5)}));\n+\n+\ty = make_vec<V>({max, norm_min});\n+\tV ref = make_vec<V>({T(max / 2), T(norm_min / 2)});\n+\tCOMPARE(y / x, ref);\n+\n+\ty = make_vec<V>({norm_min, max});\n+\tref = make_vec<V>({T(norm_min / 2), T(max / 2)});\n+\tCOMPARE(y / x, ref);\n+\n+\ty = make_vec<V>({max, T(norm_min + 1)});\n+\tCOMPARE(y / y, V(1));\n+\n+\tref = make_vec<V>({T(2 / max), T(2 / (norm_min + 1))});\n+\tCOMPARE(x / y, ref);\n+\tCOMPARE(x /= y, ref);\n+\tCOMPARE(x, ref);\n+      }\n+\n+    { // increment & decrement\n+      const V from0 = make_vec<V>({0, 1, 2, 3}, 4);\n+      V x = from0;\n+      COMPARE(x++, from0);\n+      COMPARE(x, from0 + 1);\n+      COMPARE(++x, from0 + 2);\n+      COMPARE(x, from0 + 2);\n+\n+      COMPARE(x--, from0 + 2);\n+      COMPARE(x, from0 + 1);\n+      COMPARE(--x, from0);\n+      COMPARE(x, from0);\n+    }\n+  }"}, {"sha": "6f4ba40133f43b074821e61b3760e2a2ba15a1db", "filename": "libstdc++-v3/testsuite/experimental/simd/tests/reductions.cc", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02e32295b284bd4f4d038e73ee3118fb0546650e/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fsimd%2Ftests%2Freductions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02e32295b284bd4f4d038e73ee3118fb0546650e/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fsimd%2Ftests%2Freductions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fsimd%2Ftests%2Freductions.cc?ref=02e32295b284bd4f4d038e73ee3118fb0546650e", "patch": "@@ -0,0 +1,97 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"bits/verify.h\"\n+#include \"bits/metahelpers.h\"\n+#include \"bits/test_values.h\"\n+#include <random>\n+\n+template <typename V>\n+  void\n+  test()\n+  {\n+    using T = typename V::value_type;\n+    COMPARE(reduce(V(1)), T(V::size()));\n+    {\n+      V x = 1;\n+      COMPARE(reduce(x, std::multiplies<>()), T(1));\n+      x[0] = 2;\n+      COMPARE(reduce(x, std::multiplies<>()), T(2));\n+      if constexpr (V::size() > 1)\n+\t{\n+\t  x[V::size() - 1] = 3;\n+\t  COMPARE(reduce(x, std::multiplies<>()), T(6));\n+\t}\n+    }\n+    COMPARE(reduce(V([](int i) { return i & 1; })), T(V::size() / 2));\n+    COMPARE(reduce(V([](int i) { return i % 3; })),\n+\t    T(3 * (V::size() / 3)   // 0+1+2 for every complete 3 elements in V\n+\t\t+ (V::size() % 3) / 2 // 0->0, 1->0, 2->1 adjustment\n+\t     ));\n+    if ((1 + V::size()) * V::size() / 2 <= std::__finite_max_v<T>)\n+      {\n+\tCOMPARE(reduce(V([](int i) { return i + 1; })),\n+\t\tT((1 + V::size()) * V::size() / 2));\n+      }\n+\n+    {\n+      const V y = 2;\n+      COMPARE(reduce(y), T(2 * V::size()));\n+      COMPARE(reduce(where(y > 2, y)), T(0));\n+      COMPARE(reduce(where(y == 2, y)), T(2 * V::size()));\n+    }\n+\n+    {\n+      const V z([](T i) { return i + 1; });\n+      COMPARE(std::experimental::reduce(z,\n+\t\t\t\t\t[](auto a, auto b) {\n+\t\t\t\t\t  using std::min;\n+\t\t\t\t\t  return min(a, b);\n+\t\t\t\t\t}),\n+\t      T(1))\n+\t<< \"z: \" << z;\n+      COMPARE(std::experimental::reduce(z,\n+\t\t\t\t\t[](auto a, auto b) {\n+\t\t\t\t\t  using std::max;\n+\t\t\t\t\t  return max(a, b);\n+\t\t\t\t\t}),\n+\t      T(V::size()))\n+\t<< \"z: \" << z;\n+      COMPARE(std::experimental::reduce(where(z > 1, z), 117,\n+\t\t\t\t\t[](auto a, auto b) {\n+\t\t\t\t\t  using std::min;\n+\t\t\t\t\t  return min(a, b);\n+\t\t\t\t\t}),\n+\t      T(V::size() == 1 ? 117 : 2))\n+\t<< \"z: \" << z;\n+    }\n+\n+    test_values<V>({}, {1000}, [](V x) {\n+      // avoid over-/underflow on signed integers:\n+      if constexpr (std::is_signed_v<T> && std::is_integral_v<T>)\n+\tx /= int(V::size());\n+      // The error in the following could be huge if catastrophic\n+      // cancellation occurs. (e.g. `a-a+b+b` vs. `a+b+b-a`).\n+      // Avoid catastrophic cancellation for floating point:\n+      if constexpr (std::is_floating_point_v<T>)\n+\tx = abs(x);\n+      T acc = x[0];\n+      for (size_t i = 1; i < V::size(); ++i)\n+\tacc += x[i];\n+      ULP_COMPARE(reduce(x), acc, V::size() / 2).on_failure(\"x = \", x);\n+    });\n+  }"}, {"sha": "bdbacc6ef8e7d3e03f71a214669e3a1279a19a92", "filename": "libstdc++-v3/testsuite/experimental/simd/tests/remqo.cc", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02e32295b284bd4f4d038e73ee3118fb0546650e/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fsimd%2Ftests%2Fremqo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02e32295b284bd4f4d038e73ee3118fb0546650e/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fsimd%2Ftests%2Fremqo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fsimd%2Ftests%2Fremqo.cc?ref=02e32295b284bd4f4d038e73ee3118fb0546650e", "patch": "@@ -0,0 +1,70 @@\n+// test only floattypes\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"bits/verify.h\"\n+#include \"bits/metahelpers.h\"\n+#include \"bits/test_values.h\"\n+\n+template <typename V>\n+  void\n+  test()\n+  {\n+    vir::test::setFuzzyness<float>(0);\n+    vir::test::setFuzzyness<double>(0);\n+\n+    using T = typename V::value_type;\n+    test_values_2arg<V>(\n+      {\n+#ifdef __STDC_IEC_559__\n+\tstd::__quiet_NaN_v<T>, std::__infinity_v<T>, -std::__infinity_v<T>,\n+\tstd::__denorm_min_v<T>, std::__norm_min_v<T> / 3, -0.,\n+#endif\n+\t+0., std::__norm_min_v<T>, std::__finite_max_v<T>},\n+      {10000}, [](V a, V b) {\n+\n+#ifndef __STDC_IEC_559__\n+\t// without __STDC_IEC_559__, remquo(a, 0) is unspecified\n+\twhere(b == 0, b) = 1;\n+#endif\n+\tusing IV = std::experimental::fixed_size_simd<int, V::size()>;\n+\tIV quo = {};\n+\tconst V totest = remquo(a, b, &quo);\n+\tauto&& expected\n+\t  = [&](const auto& v, const auto& w) -> std::pair<const V, const IV> {\n+\t    std::pair<V, IV> tmp = {};\n+\t    using std::remquo;\n+\t    for (std::size_t i = 0; i < V::size(); ++i)\n+\t      {\n+\t\tint tmp2;\n+\t\ttmp.first[i] = remquo(v[i], w[i], &tmp2);\n+\t\ttmp.second[i] = tmp2;\n+\t      }\n+\t    return tmp;\n+\t  };\n+\tconst auto expect1 = expected(a, b);\n+\tCOMPARE(isnan(totest), isnan(expect1.first))\n+\t  << \"remquo(\" << a << \", \" << b << \", quo) = \" << totest\n+\t  << \" != \" << expect1.first;\n+\tconst V clean_a = iif(isnan(totest), 0, a);\n+\tconst V clean_b = iif(isnan(totest), 1, b);\n+\tconst auto expect2 = expected(clean_a, clean_b);\n+\tCOMPARE(remquo(clean_a, clean_b, &quo), expect2.first)\n+\t  << \"\\nclean_a/b = \" << clean_a << \", \" << clean_b;\n+\tCOMPARE(quo, expect2.second);\n+      });\n+  }"}, {"sha": "657646c0ac5f8dda0cb77d03591754ec1ab0eb05", "filename": "libstdc++-v3/testsuite/experimental/simd/tests/simd.cc", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02e32295b284bd4f4d038e73ee3118fb0546650e/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fsimd%2Ftests%2Fsimd.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02e32295b284bd4f4d038e73ee3118fb0546650e/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fsimd%2Ftests%2Fsimd.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fsimd%2Ftests%2Fsimd.cc?ref=02e32295b284bd4f4d038e73ee3118fb0546650e", "patch": "@@ -0,0 +1,46 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"bits/verify.h\"\n+\n+template <typename V>\n+  void\n+  test()\n+  {\n+    using T = typename V::value_type;\n+\n+    // V must store V::size() values of type T giving us the lower bound on the\n+    // sizeof\n+    VERIFY(sizeof(V) >= sizeof(T) * V::size());\n+\n+    // For fixed_size, V should not pad more than to the next-power-of-2 of\n+    // sizeof(T) * V::size() (for ABI stability of V), giving us the upper bound\n+    // on the sizeof. For non-fixed_size we give the implementation a bit more\n+    // slack to trade space vs. efficiency.\n+    auto n = sizeof(T) * V::size();\n+    if (n & (n - 1))\n+      {\n+\tn = ((n << 1) & ~n) & ~((n >> 1) | (n >> 3));\n+\twhile (n & (n - 1))\n+\t  n &= n - 1;\n+      }\n+    if constexpr (\n+      !std::is_same_v<typename V::abi_type,\n+\t\t      std::experimental::simd_abi::fixed_size<V::size()>>)\n+      n *= 2;\n+    VERIFY(sizeof(V) <= n) << \"\\nsizeof(V): \" << sizeof(V) << \"\\nn: \" << n;\n+  }"}, {"sha": "acef488e2143c5e7fcf45f9a4844155e9a49ffa1", "filename": "libstdc++-v3/testsuite/experimental/simd/tests/sincos.cc", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02e32295b284bd4f4d038e73ee3118fb0546650e/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fsimd%2Ftests%2Fsincos.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02e32295b284bd4f4d038e73ee3118fb0546650e/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fsimd%2Ftests%2Fsincos.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fsimd%2Ftests%2Fsincos.cc?ref=02e32295b284bd4f4d038e73ee3118fb0546650e", "patch": "@@ -0,0 +1,44 @@\n+// test only floattypes\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"bits/verify.h\"\n+#include \"bits/metahelpers.h\"\n+#include \"bits/mathreference.h\"\n+#include \"bits/simd_view.h\"\n+#include \"bits/test_values.h\"\n+\n+template <typename V>\n+  void\n+  test()\n+  {\n+    using std::cos;\n+    using std::sin;\n+    using T = typename V::value_type;\n+\n+    vir::test::setFuzzyness<float>(2);\n+    vir::test::setFuzzyness<double>(1);\n+\n+    const auto& testdata = referenceData<function::sincos, T>();\n+    std::experimental::experimental::simd_view<V>(testdata).for_each(\n+      [&](const V input, const V expected_sin, const V expected_cos) {\n+\tFUZZY_COMPARE(sin(input), expected_sin) << \" input = \" << input;\n+\tFUZZY_COMPARE(sin(-input), -expected_sin) << \" input = \" << input;\n+\tFUZZY_COMPARE(cos(input), expected_cos) << \" input = \" << input;\n+\tFUZZY_COMPARE(cos(-input), expected_cos) << \" input = \" << input;\n+      });\n+  }"}, {"sha": "3a79a1f8e3d300b12f24b728abec3d930f0674cb", "filename": "libstdc++-v3/testsuite/experimental/simd/tests/split_concat.cc", "status": "added", "additions": 183, "deletions": 0, "changes": 183, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02e32295b284bd4f4d038e73ee3118fb0546650e/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fsimd%2Ftests%2Fsplit_concat.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02e32295b284bd4f4d038e73ee3118fb0546650e/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fsimd%2Ftests%2Fsplit_concat.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fsimd%2Ftests%2Fsplit_concat.cc?ref=02e32295b284bd4f4d038e73ee3118fb0546650e", "patch": "@@ -0,0 +1,183 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"bits/verify.h\"\n+#include \"bits/metahelpers.h\"\n+#include \"bits/conversions.h\"\n+\n+using std::experimental::simd_cast;\n+\n+template <typename V, bool ConstProp, typename F>\n+  auto\n+  gen(const F& fun)\n+  {\n+    if constexpr (ConstProp)\n+      return V(fun);\n+    else\n+      return make_value_unknown(V(fun));\n+  }\n+\n+template <typename V, bool ConstProp>\n+  void\n+  split_concat()\n+  {\n+    using T = typename V::value_type;\n+    if constexpr (V::size() * 3\n+\t\t    <= std::experimental::simd_abi::max_fixed_size<T>)\n+      {\n+\tV a(0), b(1), c(2);\n+\tauto x = concat(a, b, c);\n+\tCOMPARE(x.size(), a.size() * 3);\n+\tstd::size_t i = 0;\n+\tfor (; i < a.size(); ++i)\n+\t  {\n+\t    COMPARE(x[i], T(0));\n+\t  }\n+\tfor (; i < 2 * a.size(); ++i)\n+\t  {\n+\t    COMPARE(x[i], T(1));\n+\t  }\n+\tfor (; i < 3 * a.size(); ++i)\n+\t  {\n+\t    COMPARE(x[i], T(2));\n+\t  }\n+      }\n+\n+    if constexpr (V::size() >= 4)\n+      {\n+\tconst V a = gen<V, ConstProp>([](auto i) -> T { return i; });\n+\tconstexpr auto N0 = V::size() / 4u;\n+\tconstexpr auto N1 = V::size() - 2 * N0;\n+\tusing V0 = std::experimental::simd<\n+\t\t     T, std::experimental::simd_abi::deduce_t<T, N0>>;\n+\tusing V1 = std::experimental::simd<\n+\t\t     T, std::experimental::simd_abi::deduce_t<T, N1>>;\n+\t{\n+\t  auto x = std::experimental::split<N0, N0, N1>(a);\n+\t  COMPARE(std::tuple_size<decltype(x)>::value, 3u);\n+\t  COMPARE(std::get<0>(x), V0([](auto i) -> T { return i; }));\n+\t  COMPARE(std::get<1>(x), V0([](auto i) -> T { return i + N0; }));\n+\t  COMPARE(std::get<2>(x), V1([](auto i) -> T { return i + 2 * N0; }));\n+\t  auto b = concat(std::get<1>(x), std::get<2>(x), std::get<0>(x));\n+\t  // a and b may have different types if a was fixed_size<N> such that\n+\t  // another ABI tag exists with equal N, then b will have the\n+\t  // non-fixed-size ABI tag.\n+\t  COMPARE(a.size(), b.size());\n+\t  COMPARE(\n+\t    b, decltype(b)([](auto i) -> T { return (N0 + i) % V::size(); }));\n+\t}\n+\t{\n+\t  auto x = std::experimental::split<N0, N1, N0>(a);\n+\t  COMPARE(std::tuple_size<decltype(x)>::value, 3u);\n+\t  COMPARE(std::get<0>(x), V0([](auto i) -> T { return i; }));\n+\t  COMPARE(std::get<1>(x), V1([](auto i) -> T { return i + N0; }));\n+\t  COMPARE(std::get<2>(x), V0([](auto i) -> T { return i + N0 + N1; }));\n+\t  auto b = concat(std::get<1>(x), std::get<2>(x), std::get<0>(x));\n+\t  // a and b may have different types if a was fixed_size<N> such that\n+\t  // another ABI tag exists with equal N, then b will have the\n+\t  // non-fixed-size ABI tag.\n+\t  COMPARE(a.size(), b.size());\n+\t  COMPARE(\n+\t    b, decltype(b)([](auto i) -> T { return (N0 + i) % V::size(); }));\n+\t}\n+\t{\n+\t  auto x = std::experimental::split<N1, N0, N0>(a);\n+\t  COMPARE(std::tuple_size<decltype(x)>::value, 3u);\n+\t  COMPARE(std::get<0>(x), V1([](auto i) -> T { return i; }));\n+\t  COMPARE(std::get<1>(x), V0([](auto i) -> T { return i + N1; }));\n+\t  COMPARE(std::get<2>(x), V0([](auto i) -> T { return i + N0 + N1; }));\n+\t  auto b = concat(std::get<1>(x), std::get<2>(x), std::get<0>(x));\n+\t  // a and b may have different types if a was fixed_size<N> such that\n+\t  // another ABI tag exists with equal N, then b will have the\n+\t  // non-fixed-size ABI tag.\n+\t  COMPARE(a.size(), b.size());\n+\t  COMPARE(\n+\t    b, decltype(b)([](auto i) -> T { return (N1 + i) % V::size(); }));\n+\t}\n+      }\n+\n+    if constexpr (V::size() % 3 == 0)\n+      {\n+\tconst V a = gen<V, ConstProp>([](auto i) -> T { return i; });\n+\tconstexpr auto N0 = V::size() / 3;\n+\tusing V0 = std::experimental::simd<\n+\t\t     T, std::experimental::simd_abi::deduce_t<T, N0>>;\n+\tusing V1 = std::experimental::simd<\n+\t  T, std::experimental::simd_abi::deduce_t<T, 2 * N0>>;\n+\t{\n+\t  auto [x, y, z] = std::experimental::split<N0, N0, N0>(a);\n+\t  COMPARE(x, V0([](auto i) -> T { return i; }));\n+\t  COMPARE(y, V0([](auto i) -> T { return i + N0; }));\n+\t  COMPARE(z, V0([](auto i) -> T { return i + N0 * 2; }));\n+\t  auto b = concat(x, y, z);\n+\t  COMPARE(a.size(), b.size());\n+\t  COMPARE(b, simd_cast<decltype(b)>(a));\n+\t  COMPARE(simd_cast<V>(b), a);\n+\t}\n+\t{\n+\t  auto [x, y] = std::experimental::split<N0, 2 * N0>(a);\n+\t  COMPARE(x, V0([](auto i) -> T { return i; }));\n+\t  COMPARE(y, V1([](auto i) -> T { return i + N0; }));\n+\t  auto b = concat(x, y);\n+\t  COMPARE(a.size(), b.size());\n+\t  COMPARE(b, simd_cast<decltype(b)>(a));\n+\t  COMPARE(simd_cast<V>(b), a);\n+\t}\n+\t{\n+\t  auto [x, y] = std::experimental::split<2 * N0, N0>(a);\n+\t  COMPARE(x, V1([](auto i) -> T { return i; }));\n+\t  COMPARE(y, V0([](auto i) -> T { return i + 2 * N0; }));\n+\t  auto b = concat(x, y);\n+\t  COMPARE(a.size(), b.size());\n+\t  COMPARE(b, simd_cast<decltype(b)>(a));\n+\t  COMPARE(simd_cast<V>(b), a);\n+\t}\n+      }\n+\n+    if constexpr ((V::size() & 1) == 0)\n+      {\n+\tusing std::experimental::simd;\n+\tusing std::experimental::simd_abi::deduce_t;\n+\tusing V0 = simd<T, deduce_t<T, V::size()>>;\n+\tusing V2 = simd<T, deduce_t<T, 2>>;\n+\tusing V3 = simd<T, deduce_t<T, V::size() / 2>>;\n+\n+\tconst V a = gen<V, ConstProp>([](auto i) -> T { return i; });\n+\n+\tstd::array<V2, V::size() / 2> v2s = std::experimental::split<V2>(a);\n+\tint offset = 0;\n+\tfor (V2 test : v2s)\n+\t  {\n+\t    COMPARE(test, V2([&](auto i) -> T { return i + offset; }));\n+\t    offset += 2;\n+\t  }\n+\tCOMPARE(concat(v2s), simd_cast<V0>(a));\n+\n+\tstd::array<V3, 2> v3s = std::experimental::split<V3>(a);\n+\tCOMPARE(v3s[0], V3([](auto i) -> T { return i; }));\n+\tCOMPARE(v3s[1], V3([](auto i) -> T { return i + V3::size(); }));\n+\tCOMPARE(concat(v3s), simd_cast<V0>(a));\n+      }\n+  }\n+\n+template <typename V>\n+  void\n+  test()\n+  {\n+    split_concat<V, true>();\n+    split_concat<V, false>();\n+  }"}, {"sha": "8b61635c2a63fe6f4ef27f00a16551fc92a71280", "filename": "libstdc++-v3/testsuite/experimental/simd/tests/splits.cc", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02e32295b284bd4f4d038e73ee3118fb0546650e/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fsimd%2Ftests%2Fsplits.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02e32295b284bd4f4d038e73ee3118fb0546650e/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fsimd%2Ftests%2Fsplits.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fsimd%2Ftests%2Fsplits.cc?ref=02e32295b284bd4f4d038e73ee3118fb0546650e", "patch": "@@ -0,0 +1,38 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"bits/verify.h\"\n+\n+template <typename V>\n+  void\n+  test()\n+  {\n+    using M = typename V::mask_type;\n+    using namespace std::experimental::parallelism_v2;\n+    using T = typename V::value_type;\n+    if constexpr (V::size() / simd_size_v<T> * simd_size_v<T> == V::size())\n+      {\n+\tM k(true);\n+\tVERIFY(all_of(k)) << k;\n+\tconst auto parts = split<simd_mask<T>>(k);\n+\tfor (auto k2 : parts)\n+\t  {\n+\t    VERIFY(all_of(k2)) << k2;\n+\t    COMPARE(typeid(k2), typeid(simd_mask<T>));\n+\t  }\n+      }\n+  }"}, {"sha": "24730f1856c8c82f46de65fc67f46d0fca31d47e", "filename": "libstdc++-v3/testsuite/experimental/simd/tests/trigonometric.cc", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02e32295b284bd4f4d038e73ee3118fb0546650e/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fsimd%2Ftests%2Ftrigonometric.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02e32295b284bd4f4d038e73ee3118fb0546650e/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fsimd%2Ftests%2Ftrigonometric.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fsimd%2Ftests%2Ftrigonometric.cc?ref=02e32295b284bd4f4d038e73ee3118fb0546650e", "patch": "@@ -0,0 +1,41 @@\n+// test only floattypes\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"bits/verify.h\"\n+#include \"bits/metahelpers.h\"\n+#include \"bits/test_values.h\"\n+\n+template <typename V>\n+  void\n+  test()\n+  {\n+    vir::test::setFuzzyness<float>(1);\n+    vir::test::setFuzzyness<double>(1);\n+\n+    using T = typename V::value_type;\n+    test_values<V>(\n+      {\n+#ifdef __STDC_IEC_559__\n+\tstd::__quiet_NaN_v<T>, std::__infinity_v<T>, -std::__infinity_v<T>, -0.,\n+\tstd::__denorm_min_v<T>, std::__norm_min_v<T> / 3,\n+#endif\n+\t+0., std::__norm_min_v<T>, std::__finite_max_v<T>},\n+      {10000}, MAKE_TESTER(acos), MAKE_TESTER(tan), MAKE_TESTER(acosh),\n+      MAKE_TESTER(asinh), MAKE_TESTER(atanh), MAKE_TESTER(cosh),\n+      MAKE_TESTER(sinh), MAKE_TESTER(tanh));\n+  }"}, {"sha": "e516926ae1d62fce79cef57d2c91ade0d0a40707", "filename": "libstdc++-v3/testsuite/experimental/simd/tests/trunc_ceil_floor.cc", "status": "added", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02e32295b284bd4f4d038e73ee3118fb0546650e/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fsimd%2Ftests%2Ftrunc_ceil_floor.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02e32295b284bd4f4d038e73ee3118fb0546650e/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fsimd%2Ftests%2Ftrunc_ceil_floor.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fsimd%2Ftests%2Ftrunc_ceil_floor.cc?ref=02e32295b284bd4f4d038e73ee3118fb0546650e", "patch": "@@ -0,0 +1,109 @@\n+// test only floattypes\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"bits/test_values.h\"\n+#include \"bits/verify.h\"\n+\n+template <typename V>\n+  void\n+  test()\n+  {\n+    using T = typename V::value_type;\n+    constexpr T inf = std::__infinity_v<T>;\n+    constexpr T denorm_min = std::__denorm_min_v<T>;\n+    constexpr T norm_min = std::__norm_min_v<T>;\n+    constexpr T max = std::__finite_max_v<T>;\n+    constexpr T min = std::__finite_min_v<T>;\n+    test_values<V>(\n+      {2.1,\n+       2.0,\n+       2.9,\n+       2.5,\n+       2.499,\n+       1.5,\n+       1.499,\n+       1.99,\n+       0.99,\n+       0.5,\n+       0.499,\n+       0.,\n+       -2.1,\n+       -2.0,\n+       -2.9,\n+       -2.5,\n+       -2.499,\n+       -1.5,\n+       -1.499,\n+       -1.99,\n+       -0.99,\n+       -0.5,\n+       -0.499,\n+       3 << 21,\n+       3 << 22,\n+       3 << 23,\n+       -(3 << 21),\n+       -(3 << 22),\n+       -(3 << 23),\n+#ifdef __STDC_IEC_559__\n+       -0.,\n+       inf,\n+       -inf,\n+       denorm_min,\n+       norm_min * 0.9,\n+       -denorm_min,\n+       -norm_min * 0.9,\n+#endif\n+       max,\n+       norm_min,\n+       min,\n+       -norm_min\n+      },\n+      [](const V input) {\n+\tconst V expected([&](auto i) { return std::trunc(input[i]); });\n+\tCOMPARE(trunc(input), expected) << input;\n+      },\n+      [](const V input) {\n+\tconst V expected([&](auto i) { return std::ceil(input[i]); });\n+\tCOMPARE(ceil(input), expected) << input;\n+      },\n+      [](const V input) {\n+\tconst V expected([&](auto i) { return std::floor(input[i]); });\n+\tCOMPARE(floor(input), expected) << input;\n+      });\n+\n+#ifdef __STDC_IEC_559__\n+    test_values<V>(\n+      {\n+#ifdef __SUPPORT_SNAN__\n+\tstd::__signaling_NaN_v<T>,\n+#endif\n+\tstd::__quiet_NaN_v<T>},\n+      [](const V input) {\n+\tconst V expected([&](auto i) { return std::trunc(input[i]); });\n+\tCOMPARE(isnan(trunc(input)), isnan(expected)) << input;\n+      },\n+      [](const V input) {\n+\tconst V expected([&](auto i) { return std::ceil(input[i]); });\n+\tCOMPARE(isnan(ceil(input)), isnan(expected)) << input;\n+      },\n+      [](const V input) {\n+\tconst V expected([&](auto i) { return std::floor(input[i]); });\n+\tCOMPARE(isnan(floor(input)), isnan(expected)) << input;\n+      });\n+#endif\n+  }"}, {"sha": "5e73a3b198929ee122ad51416a4b7e9b406129f1", "filename": "libstdc++-v3/testsuite/experimental/simd/tests/where.cc", "status": "added", "additions": 136, "deletions": 0, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02e32295b284bd4f4d038e73ee3118fb0546650e/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fsimd%2Ftests%2Fwhere.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02e32295b284bd4f4d038e73ee3118fb0546650e/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fsimd%2Ftests%2Fwhere.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fexperimental%2Fsimd%2Ftests%2Fwhere.cc?ref=02e32295b284bd4f4d038e73ee3118fb0546650e", "patch": "@@ -0,0 +1,136 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"bits/verify.h\"\n+#include \"bits/make_vec.h\"\n+#include \"bits/metahelpers.h\"\n+\n+template <class V>\n+  struct Convertible\n+  {\n+    operator V() const { return V(4); }\n+  };\n+\n+template <class M, class T>\n+  constexpr bool\n+  where_is_ill_formed_impl(M, const T&, float)\n+  {\n+    return true;\n+  }\n+\n+template <class M, class T>\n+  constexpr auto\n+  where_is_ill_formed_impl(M m, const T& v, int)\n+    -> std::conditional_t<true, bool, decltype(std::experimental::where(m, v))>\n+  {\n+    return false;\n+  }\n+\n+template <class M, class T>\n+  constexpr bool\n+  where_is_ill_formed(M m, const T& v)\n+  {\n+    return where_is_ill_formed_impl(m, v, int());\n+  }\n+\n+template <typename T>\n+  void\n+  where_fundamental()\n+  {\n+    using std::experimental::where;\n+    T x = T();\n+    where(true, x) = x + 1;\n+    COMPARE(x, T(1));\n+    where(false, x) = x - 1;\n+    COMPARE(x, T(1));\n+    where(true, x) += T(1);\n+    COMPARE(x, T(2));\n+  }\n+\n+template <typename V>\n+  void\n+  test()\n+  {\n+    using M = typename V::mask_type;\n+    using T = typename V::value_type;\n+    where_fundamental<T>();\n+    VERIFY(!(sfinae_is_callable<V>(\n+\t       [](auto x) -> decltype(where(true, x))* { return nullptr; })));\n+\n+    const V indexes([](int i) { return i + 1; });\n+    const M alternating_mask = make_mask<M>({true, false});\n+    V x = 0;\n+    where(alternating_mask, x) = indexes;\n+    COMPARE(alternating_mask, x == indexes);\n+\n+    where(!alternating_mask, x) = T(2);\n+    COMPARE(!alternating_mask, x == T(2)) << x;\n+\n+    where(!alternating_mask, x) = Convertible<V>();\n+    COMPARE(!alternating_mask, x == T(4));\n+\n+    x = 0;\n+    COMPARE(x, T(0));\n+    where(alternating_mask, x) += indexes;\n+    COMPARE(alternating_mask, x == indexes);\n+\n+    x = 10;\n+    COMPARE(x, T(10));\n+    where(!alternating_mask, x) += T(1);\n+    COMPARE(!alternating_mask, x == T(11));\n+    where(alternating_mask, x) -= Convertible<V>();\n+    COMPARE(alternating_mask, x == T(6));\n+    constexpr bool fast_math =\n+#ifdef __FAST_MATH__\n+      true;\n+#else\n+      false;\n+#endif\n+    if constexpr (fast_math && std::is_floating_point_v<T>)\n+      where(alternating_mask, x) *= T(.5);\n+    else\n+    where(alternating_mask, x) /= T(2);\n+    COMPARE(alternating_mask, x == T(3)) << \"\\nx = \" << x;\n+    where(alternating_mask, x) *= T(3);\n+    COMPARE(alternating_mask, x == T(9));\n+    COMPARE(!alternating_mask, x == T(11));\n+\n+    x = 10;\n+    where(alternating_mask, x)++;\n+    COMPARE(alternating_mask, x == T(11));\n+    ++where(alternating_mask, x);\n+    COMPARE(alternating_mask, x == T(12));\n+    where(alternating_mask, x)--;\n+    COMPARE(alternating_mask, x == T(11));\n+    --where(alternating_mask, x);\n+    --where(alternating_mask, x);\n+    COMPARE(alternating_mask, x == T(9));\n+    COMPARE(alternating_mask, -where(alternating_mask, x) == T(-T(9)));\n+\n+    const auto y = x;\n+    VERIFY(where_is_ill_formed(true, y));\n+    VERIFY(where_is_ill_formed(true, x));\n+    VERIFY(where_is_ill_formed(true, V(x)));\n+\n+    M test = alternating_mask;\n+    where(alternating_mask, test) = M(true);\n+    COMPARE(test, alternating_mask);\n+    where(alternating_mask, test) = M(false);\n+    COMPARE(test, M(false));\n+    where(alternating_mask, test) = M(true);\n+    COMPARE(test, alternating_mask);\n+  }"}]}