{"sha": "edc429ff61275ef7df40999418e6b6e365a22131", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWRjNDI5ZmY2MTI3NWVmN2RmNDA5OTk0MThlNmI2ZTM2NWEyMjEzMQ==", "commit": {"author": {"name": "Revital Eres", "email": "revital.eres@linaro.org", "date": "2011-08-03T07:59:23Z"}, "committer": {"name": "Revital Eres", "email": "revitale@gcc.gnu.org", "date": "2011-08-03T07:59:23Z"}, "message": "Optimize stage count\n\nFrom-SVN: r177235", "tree": {"sha": "c4f836d44c70da07b802965eaf0ed9739970f979", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c4f836d44c70da07b802965eaf0ed9739970f979"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/edc429ff61275ef7df40999418e6b6e365a22131", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/edc429ff61275ef7df40999418e6b6e365a22131", "html_url": "https://github.com/Rust-GCC/gccrs/commit/edc429ff61275ef7df40999418e6b6e365a22131", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/edc429ff61275ef7df40999418e6b6e365a22131/comments", "author": null, "committer": null, "parents": [{"sha": "5c34e9cd0723c1505b4f8fb4ce685df082d6d286", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c34e9cd0723c1505b4f8fb4ce685df082d6d286", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5c34e9cd0723c1505b4f8fb4ce685df082d6d286"}], "stats": {"total": 359, "additions": 302, "deletions": 57}, "files": [{"sha": "8f865c6ccf7e5d9b96e9872b62f3356e818bc8fe", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edc429ff61275ef7df40999418e6b6e365a22131/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edc429ff61275ef7df40999418e6b6e365a22131/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=edc429ff61275ef7df40999418e6b6e365a22131", "patch": "@@ -1,3 +1,18 @@\n+2011-08-03  Revital Eres  <revital.eres@linaro.org>\n+\n+\t* modulo-sched.c (calculate_stage_count,\n+\tcalculate_must_precede_follow, get_sched_window,\n+\ttry_scheduling_node_in_cycle, remove_node_from_ps): Add\n+\tdeclaration.\n+\t(update_node_sched_params, set_must_precede_follow, optimize_sc):\n+\tNew functions.\n+\t(reset_sched_times): Call update_node_sched_params.\n+\t(sms_schedule): Call optimize_sc.\n+\t(get_sched_window): Change function arguments.\n+\t(sms_schedule_by_order): Update call to get_sched_window.\n+\tCall set_must_precede_follow.\n+\t(calculate_stage_count): Add function argument.\n+\n 2011-08-02  Richard Henderson  <rth@redhat.com>\n \n \tPR target/49864"}, {"sha": "a6d941019fbf92d3808789799f1742cc05d54070", "filename": "gcc/modulo-sched.c", "status": "modified", "additions": 287, "deletions": 57, "changes": 344, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edc429ff61275ef7df40999418e6b6e365a22131/gcc%2Fmodulo-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edc429ff61275ef7df40999418e6b6e365a22131/gcc%2Fmodulo-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmodulo-sched.c?ref=edc429ff61275ef7df40999418e6b6e365a22131", "patch": "@@ -203,7 +203,16 @@ static void generate_prolog_epilog (partial_schedule_ptr, struct loop *,\n                                     rtx, rtx);\n static void duplicate_insns_of_cycles (partial_schedule_ptr,\n \t\t\t\t       int, int, int, rtx);\n-static int calculate_stage_count (partial_schedule_ptr ps);\n+static int calculate_stage_count (partial_schedule_ptr, int);\n+static void calculate_must_precede_follow (ddg_node_ptr, int, int,\n+\t\t\t\t\t   int, int, sbitmap, sbitmap, sbitmap);\n+static int get_sched_window (partial_schedule_ptr, ddg_node_ptr, \n+\t\t\t     sbitmap, int, int *, int *, int *);\n+static bool try_scheduling_node_in_cycle (partial_schedule_ptr, ddg_node_ptr,\n+\t\t\t\t\t  int, int, sbitmap, int *, sbitmap,\n+\t\t\t\t\t  sbitmap);\n+static bool remove_node_from_ps (partial_schedule_ptr, ps_insn_ptr);\n+\n #define SCHED_ASAP(x) (((node_sched_params_ptr)(x)->aux.info)->asap)\n #define SCHED_TIME(x) (((node_sched_params_ptr)(x)->aux.info)->time)\n #define SCHED_FIRST_REG_MOVE(x) \\\n@@ -576,6 +585,36 @@ free_undo_replace_buff (struct undo_replace_buff_elem *reg_move_replaces)\n     }\n }\n \n+/* Update the sched_params (time, row and stage) for node U using the II,\n+   the CYCLE of U and MIN_CYCLE.  \n+   We're not simply taking the following\n+   SCHED_STAGE (u) = CALC_STAGE_COUNT (SCHED_TIME (u), min_cycle, ii);\n+   because the stages may not be aligned on cycle 0.  */\n+static void\n+update_node_sched_params (ddg_node_ptr u, int ii, int cycle, int min_cycle)\n+{\n+  int sc_until_cycle_zero;\n+  int stage;\n+\n+  SCHED_TIME (u) = cycle;\n+  SCHED_ROW (u) = SMODULO (cycle, ii);\n+\n+  /* The calculation of stage count is done adding the number\n+     of stages before cycle zero and after cycle zero.  */\n+  sc_until_cycle_zero = CALC_STAGE_COUNT (-1, min_cycle, ii);\n+\n+  if (SCHED_TIME (u) < 0)\n+    {\n+      stage = CALC_STAGE_COUNT (-1, SCHED_TIME (u), ii);\n+      SCHED_STAGE (u) = sc_until_cycle_zero - stage;\n+    }\n+  else\n+    {\n+      stage = CALC_STAGE_COUNT (SCHED_TIME (u), 0, ii);\n+      SCHED_STAGE (u) = sc_until_cycle_zero + stage - 1;\n+    }\n+}\n+\n /* Bump the SCHED_TIMEs of all nodes by AMOUNT.  Set the values of\n    SCHED_ROW and SCHED_STAGE.  Instruction scheduled on cycle AMOUNT\n    will move to cycle zero.  */\n@@ -592,7 +631,6 @@ reset_sched_times (partial_schedule_ptr ps, int amount)\n \tddg_node_ptr u = crr_insn->node;\n \tint normalized_time = SCHED_TIME (u) - amount;\n \tint new_min_cycle = PS_MIN_CYCLE (ps) - amount;\n-        int sc_until_cycle_zero, stage;\n \n         if (dump_file)\n           {\n@@ -608,23 +646,9 @@ reset_sched_times (partial_schedule_ptr ps, int amount)\n \t\n \tgcc_assert (SCHED_TIME (u) >= ps->min_cycle);\n \tgcc_assert (SCHED_TIME (u) <= ps->max_cycle);\n-\tSCHED_TIME (u) = normalized_time;\n-\tSCHED_ROW (u) = SMODULO (normalized_time, ii);\n-      \n-        /* The calculation of stage count is done adding the number\n-           of stages before cycle zero and after cycle zero.  */\n-\tsc_until_cycle_zero = CALC_STAGE_COUNT (-1, new_min_cycle, ii);\n-\t\n-\tif (SCHED_TIME (u) < 0)\n-\t  {\n-\t    stage = CALC_STAGE_COUNT (-1, SCHED_TIME (u), ii);\n-\t    SCHED_STAGE (u) = sc_until_cycle_zero - stage;\n-\t  }\n-\telse\n-\t  {\n-\t    stage = CALC_STAGE_COUNT (SCHED_TIME (u), 0, ii);\n-\t    SCHED_STAGE (u) = sc_until_cycle_zero + stage - 1;\n-\t  }\n+\n+\tcrr_insn->cycle = normalized_time;\n+\tupdate_node_sched_params (u, ii, normalized_time, new_min_cycle);\n       }\n }\n  \n@@ -661,6 +685,206 @@ permute_partial_schedule (partial_schedule_ptr ps, rtx last)\n \t\t\t    PREV_INSN (last));\n }\n \n+/* Set bitmaps TMP_FOLLOW and TMP_PRECEDE to MUST_FOLLOW and MUST_PRECEDE\n+   respectively only if cycle C falls on the border of the scheduling\n+   window boundaries marked by START and END cycles.  STEP is the\n+   direction of the window.  */\n+static inline void\n+set_must_precede_follow (sbitmap *tmp_follow, sbitmap must_follow,\n+\t\t\t sbitmap *tmp_precede, sbitmap must_precede, int c,\n+\t\t\t int start, int end, int step)\n+{\n+  *tmp_precede = NULL;\n+  *tmp_follow = NULL;\n+\n+  if (c == start)\n+    {\n+      if (step == 1)\n+\t*tmp_precede = must_precede;\n+      else\t\t\t/* step == -1.  */\n+\t*tmp_follow = must_follow;\n+    }\n+  if (c == end - step)\n+    {\n+      if (step == 1)\n+\t*tmp_follow = must_follow;\n+      else\t\t\t/* step == -1.  */\n+\t*tmp_precede = must_precede;\n+    }\n+\n+}\n+\n+/* Return True if the branch can be moved to row ii-1 while\n+   normalizing the partial schedule PS to start from cycle zero and thus\n+   optimize the SC.  Otherwise return False.  */\n+static bool\n+optimize_sc (partial_schedule_ptr ps, ddg_ptr g)\n+{\n+  int amount = PS_MIN_CYCLE (ps);\n+  sbitmap sched_nodes = sbitmap_alloc (g->num_nodes);\n+  int start, end, step;\n+  int ii = ps->ii;\n+  bool ok = false;\n+  int stage_count, stage_count_curr;\n+\n+  /* Compare the SC after normalization and SC after bringing the branch\n+     to row ii-1.  If they are equal just bail out.  */\n+  stage_count = calculate_stage_count (ps, amount);\n+  stage_count_curr =\n+    calculate_stage_count (ps, SCHED_TIME (g->closing_branch) - (ii - 1));\n+\n+  if (stage_count == stage_count_curr)\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file, \"SMS SC already optimized.\\n\");\n+\n+      ok = false;\n+      goto clear;\n+    }\n+\n+  if (dump_file)\n+    {\n+      fprintf (dump_file, \"SMS Trying to optimize branch location\\n\");\n+      fprintf (dump_file, \"SMS partial schedule before trial:\\n\");\n+      print_partial_schedule (ps, dump_file);\n+    }\n+\n+  /* First, normalize the partial scheduling.  */\n+  reset_sched_times (ps, amount);\n+  rotate_partial_schedule (ps, amount);\n+  if (dump_file)\n+    {\n+      fprintf (dump_file,\n+\t       \"SMS partial schedule after normalization (ii, %d, SC %d):\\n\",\n+\t       ii, stage_count);\n+      print_partial_schedule (ps, dump_file);\n+    }\n+\n+  if (SMODULO (SCHED_TIME (g->closing_branch), ii) == ii - 1)\n+    {\n+      ok = true;\n+      goto clear;\n+    }\n+\n+  sbitmap_ones (sched_nodes);\n+\n+  /* Calculate the new placement of the branch.  It should be in row\n+     ii-1 and fall into it's scheduling window.  */\n+  if (get_sched_window (ps, g->closing_branch, sched_nodes, ii, &start,\n+\t\t\t&step, &end) == 0)\n+    {\n+      bool success;\n+      ps_insn_ptr next_ps_i;\n+      int branch_cycle = SCHED_TIME (g->closing_branch);\n+      int row = SMODULO (branch_cycle, ps->ii);\n+      int num_splits = 0;\n+      sbitmap must_precede, must_follow, tmp_precede, tmp_follow;\n+      int c;\n+\n+      if (dump_file)\n+\tfprintf (dump_file, \"\\nTrying to schedule node %d \"\n+\t\t \"INSN = %d  in (%d .. %d) step %d\\n\",\n+\t\t g->closing_branch->cuid,\n+\t\t (INSN_UID (g->closing_branch->insn)), start, end, step);\n+\n+      gcc_assert ((step > 0 && start < end) || (step < 0 && start > end));\n+      if (step == 1)\n+\t{\n+\t  c = start + ii - SMODULO (start, ii) - 1;\n+\t  gcc_assert (c >= start);\n+\t  if (c >= end)\n+\t    {\n+\t      ok = false;\n+\t      if (dump_file)\n+\t\tfprintf (dump_file,\n+\t\t\t \"SMS failed to schedule branch at cycle: %d\\n\", c);\n+\t      goto clear;\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  c = start - SMODULO (start, ii) - 1;\n+\t  gcc_assert (c <= start);\n+\n+\t  if (c <= end)\n+\t    {\n+\t      if (dump_file)\n+\t\tfprintf (dump_file,\n+\t\t\t \"SMS failed to schedule branch at cycle: %d\\n\", c);\n+\t      ok = false;\n+\t      goto clear;\n+\t    }\n+\t}\n+\n+      must_precede = sbitmap_alloc (g->num_nodes);\n+      must_follow = sbitmap_alloc (g->num_nodes);\n+\n+      /* Try to schedule the branch is it's new cycle.  */\n+      calculate_must_precede_follow (g->closing_branch, start, end,\n+\t\t\t\t     step, ii, sched_nodes,\n+\t\t\t\t     must_precede, must_follow);\n+\n+      set_must_precede_follow (&tmp_follow, must_follow, &tmp_precede,\n+\t\t\t       must_precede, c, start, end, step);\n+\n+      /* Find the element in the partial schedule related to the closing\n+         branch so we can remove it from it's current cycle.  */\n+      for (next_ps_i = ps->rows[row];\n+\t   next_ps_i; next_ps_i = next_ps_i->next_in_row)\n+\tif (next_ps_i->node->cuid == g->closing_branch->cuid)\n+\t  break;\n+\n+      gcc_assert (next_ps_i);\n+      gcc_assert (remove_node_from_ps (ps, next_ps_i));\n+      success =\n+\ttry_scheduling_node_in_cycle (ps, g->closing_branch,\n+\t\t\t\t      g->closing_branch->cuid, c,\n+\t\t\t\t      sched_nodes, &num_splits,\n+\t\t\t\t      tmp_precede, tmp_follow);\n+      gcc_assert (num_splits == 0);\n+      if (!success)\n+\t{\n+\t  if (dump_file)\n+\t    fprintf (dump_file,\n+\t\t     \"SMS failed to schedule branch at cycle: %d, \"\n+\t\t     \"bringing it back to cycle %d\\n\", c, branch_cycle);\n+\n+\t  /* The branch was failed to be placed in row ii - 1.\n+\t     Put it back in it's original place in the partial\n+\t     schedualing.  */\n+\t  set_must_precede_follow (&tmp_follow, must_follow, &tmp_precede,\n+\t\t\t\t   must_precede, branch_cycle, start, end,\n+\t\t\t\t   step);\n+\t  success =\n+\t    try_scheduling_node_in_cycle (ps, g->closing_branch,\n+\t\t\t\t\t  g->closing_branch->cuid,\n+\t\t\t\t\t  branch_cycle, sched_nodes,\n+\t\t\t\t\t  &num_splits, tmp_precede,\n+\t\t\t\t\t  tmp_follow);\n+\t  gcc_assert (success && (num_splits == 0));\n+\t  ok = false;\n+\t}\n+      else\n+\t{\n+\t  /* The branch is placed in row ii - 1.  */\n+\t  if (dump_file)\n+\t    fprintf (dump_file,\n+\t\t     \"SMS success in moving branch to cycle %d\\n\", c);\n+\n+\t  update_node_sched_params (g->closing_branch, ii, c,\n+\t\t\t\t    PS_MIN_CYCLE (ps));\n+\t  ok = true;\n+\t}\n+\n+      free (must_precede);\n+      free (must_follow);\n+    }\n+\n+clear:\n+  free (sched_nodes);\n+  return ok;\n+}\n+\n static void\n duplicate_insns_of_cycles (partial_schedule_ptr ps, int from_stage,\n \t\t\t   int to_stage, int for_prolog, rtx count_reg)\n@@ -1116,6 +1340,7 @@ sms_schedule (void)\n       int mii, rec_mii;\n       unsigned stage_count = 0;\n       HOST_WIDEST_INT loop_count = 0;\n+      bool opt_sc_p = false;\n \n       if (! (g = g_arr[loop->num]))\n         continue;\n@@ -1197,14 +1422,32 @@ sms_schedule (void)\n       set_node_sched_params (g);\n \n       ps = sms_schedule_by_order (g, mii, maxii, node_order);\n-\n-       if (ps)\n-       {\n-         stage_count = calculate_stage_count (ps);\n-         gcc_assert(stage_count >= 1);\n-         PS_STAGE_COUNT(ps) = stage_count;\n-       }\n-\n+      \n+      if (ps)\n+\t{\n+\t  /* Try to achieve optimized SC by normalizing the partial\n+\t     schedule (having the cycles start from cycle zero).\n+\t     The branch location must be placed in row ii-1 in the\n+\t     final scheduling.\tIf failed, shift all instructions to\n+\t     position the branch in row ii-1.  */\n+\t  opt_sc_p = optimize_sc (ps, g);\n+\t  if (opt_sc_p)\n+\t    stage_count = calculate_stage_count (ps, 0);\n+\t  else\n+\t    {\n+\t      /* Bring the branch to cycle ii-1.  */\n+\t      int amount = SCHED_TIME (g->closing_branch) - (ps->ii - 1);\n+\t      \n+\t      if (dump_file)\n+\t\tfprintf (dump_file, \"SMS schedule branch at cycle ii-1\\n\");\n+\t      \n+\t      stage_count = calculate_stage_count (ps, amount);\n+\t    }\n+\t  \n+\t  gcc_assert (stage_count >= 1);\n+\t  PS_STAGE_COUNT (ps) = stage_count;\n+\t}\n+      \n       /* The default value of PARAM_SMS_MIN_SC is 2 as stage count of\n \t 1 means that there is no interleaving between iterations thus\n \t we let the scheduling passes do the job in this case.  */\n@@ -1225,12 +1468,16 @@ sms_schedule (void)\n       else\n \t{\n \t  struct undo_replace_buff_elem *reg_move_replaces;\n-          int amount = SCHED_TIME (g->closing_branch) + 1;\n+\n+          if (!opt_sc_p)\n+            {\n+\t      /* Rotate the partial schedule to have the branch in row ii-1.  */\n+              int amount = SCHED_TIME (g->closing_branch) - (ps->ii - 1);\n+\t      \n+              reset_sched_times (ps, amount);\n+              rotate_partial_schedule (ps, amount);\n+            }\n \t  \n-\t  /* Set the stage boundaries.\tThe closing_branch was scheduled\n-\t     and should appear in the last (ii-1) row.  */\n-\t  reset_sched_times (ps, amount);\n-\t  rotate_partial_schedule (ps, amount);\n \t  set_columns_for_ps (ps);\n \n \t  canon_loop (loop);\n@@ -1382,13 +1629,11 @@ sms_schedule (void)\n    scheduling window is empty and zero otherwise.  */\n \n static int\n-get_sched_window (partial_schedule_ptr ps, int *nodes_order, int i,\n+get_sched_window (partial_schedule_ptr ps, ddg_node_ptr u_node,\n \t\t  sbitmap sched_nodes, int ii, int *start_p, int *step_p, int *end_p)\n {\n   int start, step, end;\n   ddg_edge_ptr e;\n-  int u = nodes_order [i];\n-  ddg_node_ptr u_node = &ps->g->nodes[u];\n   sbitmap psp = sbitmap_alloc (ps->g->num_nodes);\n   sbitmap pss = sbitmap_alloc (ps->g->num_nodes);\n   sbitmap u_node_preds = NODE_PREDECESSORS (u_node);\n@@ -1800,7 +2045,7 @@ sms_schedule_by_order (ddg_ptr g, int mii, int maxii, int *nodes_order)\n \n \t  /* Try to get non-empty scheduling window.  */\n \t success = 0;\n-         if (get_sched_window (ps, nodes_order, i, sched_nodes, ii, &start,\n+         if (get_sched_window (ps, u_node, sched_nodes, ii, &start,\n                                 &step, &end) == 0)\n             {\n               if (dump_file)\n@@ -1817,24 +2062,11 @@ sms_schedule_by_order (ddg_ptr g, int mii, int maxii, int *nodes_order)\n \n               for (c = start; c != end; c += step)\n                 {\n-                  sbitmap tmp_precede = NULL;\n-                  sbitmap tmp_follow = NULL;\n-\n-                  if (c == start)\n-                    {\n-                      if (step == 1)\n-                        tmp_precede = must_precede;\n-                      else      /* step == -1.  */\n-                        tmp_follow = must_follow;\n-                    }\n-                  if (c == end - step)\n-                    {\n-                      if (step == 1)\n-                        tmp_follow = must_follow;\n-                      else      /* step == -1.  */\n-                        tmp_precede = must_precede;\n-                    }\n+\t\t  sbitmap tmp_precede, tmp_follow;\n \n+                  set_must_precede_follow (&tmp_follow, must_follow, \n+\t\t                           &tmp_precede, must_precede, \n+                                           c, start, end, step);\n                   success =\n                     try_scheduling_node_in_cycle (ps, u_node, u, c,\n                                                   sched_nodes,\n@@ -2899,12 +3131,10 @@ ps_add_node_check_conflicts (partial_schedule_ptr ps, ddg_node_ptr n,\n }\n \n /* Calculate the stage count of the partial schedule PS.  The calculation\n-   takes into account the rotation to bring the closing branch to row\n-   ii-1.  */\n+   takes into account the rotation amount passed in ROTATION_AMOUNT.  */\n int\n-calculate_stage_count (partial_schedule_ptr ps)\n+calculate_stage_count (partial_schedule_ptr ps, int rotation_amount)\n {\n-  int rotation_amount = (SCHED_TIME (ps->g->closing_branch)) + 1;\n   int new_min_cycle = PS_MIN_CYCLE (ps) - rotation_amount;\n   int new_max_cycle = PS_MAX_CYCLE (ps) - rotation_amount;\n   int stage_count = CALC_STAGE_COUNT (-1, new_min_cycle, ps->ii);"}]}