{"sha": "fcf3be37e2200181983c150fa36c2fd2ba249b8e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmNmM2JlMzdlMjIwMDE4MTk4M2MxNTBmYTM2YzJmZDJiYTI0OWI4ZQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2005-07-11T07:34:33Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2005-07-11T07:34:33Z"}, "message": "trans-stmt.c (gfc_trans_forall_loop): Clear maskindex before the outermost loop.\n\n\t* trans-stmt.c (gfc_trans_forall_loop): Clear maskindex before\n\tthe outermost loop.\n\t(gfc_trans_assign_need_temp, gfc_trans_pointer_assign_need_temp,\n\tgfc_trans_forall_1, gfc_evaluate_where_mask, gfc_trans_where_2):\n\tDon't clear maskindexes here.\n\n\t* gfortran.fortran-torture/execute/forall_7.f90: New test.\n\nFrom-SVN: r101865", "tree": {"sha": "304263e35f8e8851ead0d4913524902184a6ab73", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/304263e35f8e8851ead0d4913524902184a6ab73"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fcf3be37e2200181983c150fa36c2fd2ba249b8e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fcf3be37e2200181983c150fa36c2fd2ba249b8e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fcf3be37e2200181983c150fa36c2fd2ba249b8e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fcf3be37e2200181983c150fa36c2fd2ba249b8e/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "15362b89f0016748c7c060b46280d5373e43e4f7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15362b89f0016748c7c060b46280d5373e43e4f7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/15362b89f0016748c7c060b46280d5373e43e4f7"}], "stats": {"total": 234, "additions": 116, "deletions": 118}, "files": [{"sha": "2ccc249e1171fda8e310288a647c5088f4e8acb7", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fcf3be37e2200181983c150fa36c2fd2ba249b8e/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fcf3be37e2200181983c150fa36c2fd2ba249b8e/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=fcf3be37e2200181983c150fa36c2fd2ba249b8e", "patch": "@@ -1,3 +1,11 @@\n+2005-07-11  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* trans-stmt.c (gfc_trans_forall_loop): Clear maskindex before\n+\tthe outermost loop.\n+\t(gfc_trans_assign_need_temp, gfc_trans_pointer_assign_need_temp,\n+\tgfc_trans_forall_1, gfc_evaluate_where_mask, gfc_trans_where_2):\n+\tDon't clear maskindexes here.\n+\n 2005-07-08  Daniel Berlin  <dberlin@dberlin.org>\n \t\n \t* trans-decl.c (create_function_arglist): DECL_ARG_TYPE_AS_WRITTEN"}, {"sha": "0ec029fa5ddcacdb15ade0ae24e7c5d694f9e70b", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 16, "deletions": 118, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fcf3be37e2200181983c150fa36c2fd2ba249b8e/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fcf3be37e2200181983c150fa36c2fd2ba249b8e/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=fcf3be37e2200181983c150fa36c2fd2ba249b8e", "patch": "@@ -1331,7 +1331,7 @@ gfc_trans_forall_loop (forall_info *forall_tmp, int nvar, tree body, int mask_fl\n   stmtblock_t block;\n   tree exit_label;\n   tree count;\n-  tree var, start, end, step, mask, maskindex;\n+  tree var, start, end, step;\n   iter_info *iter;\n \n   iter = forall_tmp->this_loop;\n@@ -1366,17 +1366,14 @@ gfc_trans_forall_loop (forall_info *forall_tmp, int nvar, tree body, int mask_fl\n \n       /* Advance to the next mask element.  Only do this for the\n \t innermost loop.  */\n-      if (n == 0 && mask_flag)\n-        {\n-          mask = forall_tmp->mask;\n-          maskindex = forall_tmp->maskindex;\n-          if (mask)\n-            {\n-              tmp = build2 (PLUS_EXPR, gfc_array_index_type,\n-\t\t\t    maskindex, gfc_index_one_node);\n-              gfc_add_modify_expr (&block, maskindex, tmp);\n-            }\n-        }\n+      if (n == 0 && mask_flag && forall_tmp->mask)\n+\t{\n+\t  tree maskindex = forall_tmp->maskindex;\n+\t  tmp = build2 (PLUS_EXPR, gfc_array_index_type,\n+\t\t\tmaskindex, gfc_index_one_node);\n+\t  gfc_add_modify_expr (&block, maskindex, tmp);\n+\t}\n+\n       /* Decrement the loop counter.  */\n       tmp = build2 (MINUS_EXPR, TREE_TYPE (var), count, gfc_index_one_node);\n       gfc_add_modify_expr (&block, count, tmp);\n@@ -1387,6 +1384,12 @@ gfc_trans_forall_loop (forall_info *forall_tmp, int nvar, tree body, int mask_fl\n       gfc_init_block (&block);\n       gfc_add_modify_expr (&block, var, start);\n \n+      /* Initialize maskindex counter.  Only do this before the\n+\t outermost loop.  */\n+      if (n == nvar - 1 && mask_flag && forall_tmp->mask)\n+\tgfc_add_modify_expr (&block, forall_tmp->maskindex,\n+\t\t\t     gfc_index_zero_node);\n+\n       /* Initialize the loop counter.  */\n       tmp = fold_build2 (MINUS_EXPR, TREE_TYPE (var), step, start);\n       tmp = fold_build2 (PLUS_EXPR, TREE_TYPE (var), end, tmp);\n@@ -1930,8 +1933,6 @@ gfc_trans_assign_need_temp (gfc_expr * expr1, gfc_expr * expr2, tree wheremask,\n   tree count, count1;\n   tree tmp, tmp1;\n   tree ptemp1;\n-  tree mask, maskindex;\n-  forall_info *forall_tmp;\n   stmtblock_t inner_size_body;\n \n   /* Create vars. count1 is the current iterator number of the nested\n@@ -1964,17 +1965,6 @@ gfc_trans_assign_need_temp (gfc_expr * expr1, gfc_expr * expr2, tree wheremask,\n   tmp1 = allocate_temp_for_forall_nest (nested_forall_info, type, inner_size,\n \t\t\t\t\t&inner_size_body, block, &ptemp1);\n \n-  /* Initialize the maskindexes.  */\n-  forall_tmp = nested_forall_info;\n-  while (forall_tmp != NULL)\n-    {\n-      mask = forall_tmp->mask;\n-      maskindex = forall_tmp->maskindex;\n-      if (mask)\n-        gfc_add_modify_expr (block, maskindex, gfc_index_zero_node);\n-      forall_tmp = forall_tmp->next_nest;\n-    }\n-\n   /* Generate codes to copy rhs to the temporary .  */\n   tmp = generate_loop_for_rhs_to_temp (expr2, tmp1, count, count1, lss, rss,\n \t\t\t\t       wheremask);\n@@ -1987,17 +1977,6 @@ gfc_trans_assign_need_temp (gfc_expr * expr1, gfc_expr * expr2, tree wheremask,\n   /* Reset count1.  */\n   gfc_add_modify_expr (block, count1, gfc_index_zero_node);\n \n-  /* Reset maskindexed.  */\n-  forall_tmp = nested_forall_info;\n-  while (forall_tmp != NULL)\n-    {\n-      mask = forall_tmp->mask;\n-      maskindex = forall_tmp->maskindex;\n-      if (mask)\n-        gfc_add_modify_expr (block, maskindex, gfc_index_zero_node);\n-      forall_tmp = forall_tmp->next_nest;\n-    }\n-\n   /* Reset count.  */\n   if (wheremask)\n     gfc_add_modify_expr (block, count, gfc_index_zero_node);\n@@ -2040,8 +2019,6 @@ gfc_trans_pointer_assign_need_temp (gfc_expr * expr1, gfc_expr * expr2,\n   stmtblock_t body;\n   tree count;\n   tree tmp, tmp1, ptemp1;\n-  tree mask, maskindex;\n-  forall_info *forall_tmp;\n \n   count = gfc_create_var (gfc_array_index_type, \"count\");\n   gfc_add_modify_expr (block, count, gfc_index_zero_node);\n@@ -2075,17 +2052,6 @@ gfc_trans_pointer_assign_need_temp (gfc_expr * expr1, gfc_expr * expr2,\n \n       tmp = gfc_finish_block (&body);\n \n-      /* Initialize the maskindexes.  */\n-      forall_tmp = nested_forall_info;\n-      while (forall_tmp != NULL)\n-        {\n-          mask = forall_tmp->mask;\n-          maskindex = forall_tmp->maskindex;\n-          if (mask)\n-            gfc_add_modify_expr (block, maskindex, gfc_index_zero_node);\n-          forall_tmp = forall_tmp->next_nest;\n-        }\n-\n       /* Generate body and loops according to the information in\n          nested_forall_info.  */\n       tmp = gfc_trans_nested_forall_loop (nested_forall_info, tmp, 1, 1);\n@@ -2094,16 +2060,6 @@ gfc_trans_pointer_assign_need_temp (gfc_expr * expr1, gfc_expr * expr2,\n       /* Reset count.  */\n       gfc_add_modify_expr (block, count, gfc_index_zero_node);\n \n-      /* Reset maskindexes.  */\n-      forall_tmp = nested_forall_info;\n-      while (forall_tmp != NULL)\n-        {\n-          mask = forall_tmp->mask;\n-          maskindex = forall_tmp->maskindex;\n-          if (mask)\n-            gfc_add_modify_expr (block, maskindex, gfc_index_zero_node);\n-          forall_tmp = forall_tmp->next_nest;\n-        }\n       gfc_start_block (&body);\n       gfc_init_se (&lse, NULL);\n       gfc_init_se (&rse, NULL);\n@@ -2164,17 +2120,6 @@ gfc_trans_pointer_assign_need_temp (gfc_expr * expr1, gfc_expr * expr2,\n \n       tmp = gfc_finish_block (&body);\n \n-      /* Initialize the maskindexes.  */\n-      forall_tmp = nested_forall_info;\n-      while (forall_tmp != NULL)\n-        {\n-          mask = forall_tmp->mask;\n-          maskindex = forall_tmp->maskindex;\n-          if (mask)\n-            gfc_add_modify_expr (block, maskindex, gfc_index_zero_node);\n-          forall_tmp = forall_tmp->next_nest;\n-        }\n-\n       /* Generate body and loops according to the information in\n          nested_forall_info.  */\n       tmp = gfc_trans_nested_forall_loop (nested_forall_info, tmp, 1, 1);\n@@ -2183,16 +2128,6 @@ gfc_trans_pointer_assign_need_temp (gfc_expr * expr1, gfc_expr * expr2,\n       /* Reset count.  */\n       gfc_add_modify_expr (block, count, gfc_index_zero_node);\n \n-      /* Reset maskindexes.  */\n-      forall_tmp = nested_forall_info;\n-      while (forall_tmp != NULL)\n-        {\n-          mask = forall_tmp->mask;\n-          maskindex = forall_tmp->maskindex;\n-          if (mask)\n-            gfc_add_modify_expr (block, maskindex, gfc_index_zero_node);\n-          forall_tmp = forall_tmp->next_nest;\n-        }\n       parm = gfc_build_array_ref (tmp1, count);\n       lss = gfc_walk_expr (expr1);\n       gfc_init_se (&lse, NULL);\n@@ -2487,10 +2422,6 @@ gfc_trans_forall_1 (gfc_code * code, forall_info * nested_forall_info)\n               /* Use the normal assignment copying routines.  */\n               assign = gfc_trans_assignment (c->expr, c->expr2);\n \n-              /* Reset the mask index.  */\n-              if (mask)\n-                gfc_add_modify_expr (&block, maskindex, gfc_index_zero_node);\n-\n               /* Generate body and loops.  */\n               tmp = gfc_trans_nested_forall_loop (nested_forall_info, assign, 1, 1);\n               gfc_add_expr_to_block (&block, tmp);\n@@ -2532,10 +2463,6 @@ gfc_trans_forall_1 (gfc_code * code, forall_info * nested_forall_info)\n               /* Use the normal assignment copying routines.  */\n               assign = gfc_trans_pointer_assignment (c->expr, c->expr2);\n \n-              /* Reset the mask index.  */\n-              if (mask)\n-                gfc_add_modify_expr (&block, maskindex, gfc_index_zero_node);\n-\n               /* Generate body and loops.  */\n               tmp = gfc_trans_nested_forall_loop (nested_forall_info, assign,\n                                                   1, 1);\n@@ -2723,22 +2650,7 @@ gfc_evaluate_where_mask (gfc_expr * me, forall_info * nested_forall_info,\n   tmp1 = gfc_finish_block (&body);\n   /* If the WHERE construct is inside FORALL, fill the full temporary.  */\n   if (nested_forall_info != NULL)\n-    {\n-      forall_info *forall_tmp;\n-      tree maskindex;\n-\n-      /* Initialize the maskindexes.  */\n-      forall_tmp = nested_forall_info;\n-      while (forall_tmp != NULL)\n-\t{\n-\t  maskindex = forall_tmp->maskindex;\n-\t  if (forall_tmp->mask)\n-\t    gfc_add_modify_expr (block, maskindex, gfc_index_zero_node);\n-\t  forall_tmp = forall_tmp->next_nest;\n-\t}\n-\n-      tmp1 = gfc_trans_nested_forall_loop (nested_forall_info, tmp1, 1, 1);\n-    }\n+    tmp1 = gfc_trans_nested_forall_loop (nested_forall_info, tmp1, 1, 1);\n \n   gfc_add_expr_to_block (block, tmp1);\n \n@@ -3059,9 +2971,6 @@ gfc_trans_where_2 (gfc_code * code, tree mask, tree pmask,\n                                                 nested_forall_info, block);\n                   else\n                     {\n-\t\t      forall_info *forall_tmp;\n-\t\t      tree maskindex;\n-\n                       /* Variables to control maskexpr.  */\n                       count1 = gfc_create_var (gfc_array_index_type, \"count1\");\n                       count2 = gfc_create_var (gfc_array_index_type, \"count2\");\n@@ -3071,17 +2980,6 @@ gfc_trans_where_2 (gfc_code * code, tree mask, tree pmask,\n                       tmp = gfc_trans_where_assign (expr1, expr2, mask, count1,\n                                                     count2);\n \n-\t\t      /* Initialize the maskindexes.  */\n-\t\t      forall_tmp = nested_forall_info;\n-\t\t      while (forall_tmp != NULL)\n-\t\t\t{\n-\t\t\t  maskindex = forall_tmp->maskindex;\n-\t\t\t  if (forall_tmp->mask)\n-\t\t\t    gfc_add_modify_expr (block, maskindex,\n-\t\t\t\t\t\t gfc_index_zero_node);\n-\t\t\t  forall_tmp = forall_tmp->next_nest;\n-\t\t\t}\n-\n                       tmp = gfc_trans_nested_forall_loop (nested_forall_info,\n                                                           tmp, 1, 1);\n                       gfc_add_expr_to_block (block, tmp);"}, {"sha": "6dd712708f3204590acca2d17edc81dfdebaab7f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fcf3be37e2200181983c150fa36c2fd2ba249b8e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fcf3be37e2200181983c150fa36c2fd2ba249b8e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=fcf3be37e2200181983c150fa36c2fd2ba249b8e", "patch": "@@ -1,3 +1,7 @@\n+2005-07-11  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* gfortran.fortran-torture/execute/forall_7.f90: New test.\n+\n 2005-07-10  Richard Sandiford  <richard@codesourcery.com>\n \n \t* gcc.target/mips/mips.exp (is_gp32_flag): New procedure."}, {"sha": "4a28928109ce236bd3c3b37e929e61ffbbf8b076", "filename": "gcc/testsuite/gfortran.fortran-torture/execute/forall_7.f90", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fcf3be37e2200181983c150fa36c2fd2ba249b8e/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fforall_7.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fcf3be37e2200181983c150fa36c2fd2ba249b8e/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fforall_7.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fforall_7.f90?ref=fcf3be37e2200181983c150fa36c2fd2ba249b8e", "patch": "@@ -0,0 +1,88 @@\n+! tests FORALL statements with a mask\n+program forall_7\n+  real, dimension (5, 5, 5, 5) :: a, b, c, d\n+\n+  a (:, :, :, :) = 4\n+  forall (i = 1:5)\n+    a (i, i, 6 - i, i) = 7\n+  end forall\n+  forall (i = 1:5)\n+    a (i, 6 - i, i, i) = 7\n+  end forall\n+  forall (i = 1:5)\n+    a (6 - i, i, i, i) = 7\n+  end forall\n+  forall (i = 1:5:2)\n+    a (1, 2, 3, i) = 0\n+  end forall\n+\n+  b = a\n+  c = a\n+  d = a\n+\n+  forall (i = 1:5, j = 1:5, k = 1:5, ((a (i, j, k, i) .gt. 6) .or. (a (i, j, k, j) .gt. 6)))\n+    forall (l = 1:5, a (1, 2, 3, l) .lt. 2)\n+      a (i, j, k, l) = i - j + k - l + 0.5\n+    end forall\n+  end forall\n+\n+  forall (l = 1:5, b (1, 2, 3, l) .lt. 2)\n+    forall (i = 1:5, j = 1:5, k = 1:5, ((b (i, j, k, i) .gt. 6) .or. (b (i, j, k, j) .gt. 6)))\n+      b (i, j, k, l) = i - j + k - l + 0.5\n+    end forall\n+  end forall\n+\n+  forall (i = 1:5, j = 1:5, k = 1:5, ((c (i, j, k, i) .gt. 6) .or. (c (i, j, k, j) .gt. 6)))\n+    forall (l = 1:5, c (1, 2, 3, l) .lt. 2)\n+      c (i, j, k, l) = i - j + k - l + 0.5 + c (l, k, j, i)\n+    end forall\n+  end forall\n+\n+  forall (l = 1:5, d (1, 2, 3, l) .lt. 2)\n+    forall (i = 1:5, j = 1:5, k = 1:5, ((d (i, j, k, i) .gt. 6) .or. (d (i, j, k, j) .gt. 6)))\n+      d (i, j, k, l) = i - j + k - l + 0.5 + d (l, k, j, i)\n+    end forall\n+  end forall\n+\n+  do i = 1, 5\n+    do j = 1, 5\n+      do k = 1, 5\n+\tdo l = 1, 5\n+\t  r = 4\n+\t  if ((i == j .and. k == 6 - i) .or. (i == k .and. j == 6 - i)) then\n+\t    if (l /= 2 .and. l /= 4) then\n+\t      r = 1\n+\t    elseif (l == i) then\n+\t      r = 7\n+\t    end if\n+\t  elseif (j == k .and. i == 6 - j) then\n+\t    if (l /= 2 .and. l /= 4) then\n+\t      r = 1\n+\t    elseif (l == j) then\n+\t      r = 7\n+\t    end if\n+\t  elseif (i == 1 .and. j == 2 .and. k == 3 .and. l /= 2 .and. l /= 4) then\n+\t    r = 0\n+\t  end if\n+\t  s = r\n+\t  if (r == 1) then\n+\t    r = i - j + k - l + 0.5\n+\t    if (((l == k .and. j == 6 - l) .or. (l == j .and. k == 6 - l)) .and. (i == l)) then\n+\t      s = r + 7\n+\t    elseif (k == j .and. l == 6 - k .and. i == k) then\n+\t      s = r + 7\n+\t    elseif (l /= 1 .or. k /= 2 .or. j /= 3 .or. i == 2 .or. i == 4) then\n+\t      s = r + 4\n+\t    else\n+\t      s = r\n+\t    end if\n+\t  end if\n+\t  if (a (i, j, k, l) /= r) call abort ()\n+\t  if (c (i, j, k, l) /= s) call abort ()\n+\tend do\n+      end do\n+    end do\n+  end do\n+\n+  if (any (a /= b .or. c /= d)) call abort ()\n+end"}]}