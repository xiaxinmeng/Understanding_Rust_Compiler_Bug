{"sha": "31e924c52f430d81f030a2fa9f60b73a5a0d2126", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzFlOTI0YzUyZjQzMGQ4MWYwMzBhMmZhOWY2MGI3M2E1YTBkMjEyNg==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2021-09-17T16:36:54Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2021-09-17T16:36:54Z"}, "message": "Better handle MIN/MAX_EXPR of unrelated objects [PR102200].\n\nResolves:\nPR middle-end/102200 - ICE on a min of a decl and pointer in a loop\n\ngcc/ChangeLog:\n\n\tPR middle-end/102200\n\t* pointer-query.cc (access_ref::inform_access): Handle MIN/MAX_EXPR.\n\t(handle_min_max_size): Change argument.  Store original SSA_NAME for\n\toperands to potentially distinct (sub)objects.\n\t(compute_objsize_r): Adjust call to the above.\n\ngcc/testsuite/ChangeLog:\n\n\tPR middle-end/102200\n\t* gcc.dg/Wstringop-overflow-62.c: Adjust text of an expected note.\n\t* gcc.dg/Warray-bounds-89.c: New test.\n\t* gcc.dg/Wstringop-overflow-74.c: New test.\n\t* gcc.dg/Wstringop-overflow-75.c: New test.\n\t* gcc.dg/Wstringop-overflow-76.c: New test.", "tree": {"sha": "be076ca2c9b45615a2ae1f6a9faf17165e4b23f8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/be076ca2c9b45615a2ae1f6a9faf17165e4b23f8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/31e924c52f430d81f030a2fa9f60b73a5a0d2126", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31e924c52f430d81f030a2fa9f60b73a5a0d2126", "html_url": "https://github.com/Rust-GCC/gccrs/commit/31e924c52f430d81f030a2fa9f60b73a5a0d2126", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31e924c52f430d81f030a2fa9f60b73a5a0d2126/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "47e5052b5e15b3018eb56d353cb6330cd2d614a9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47e5052b5e15b3018eb56d353cb6330cd2d614a9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/47e5052b5e15b3018eb56d353cb6330cd2d614a9"}], "stats": {"total": 506, "additions": 496, "deletions": 10}, "files": [{"sha": "83b1f0fc8664cdf8efc529cafedcc4bbfc349d3b", "filename": "gcc/pointer-query.cc", "status": "modified", "additions": 53, "deletions": 9, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31e924c52f430d81f030a2fa9f60b73a5a0d2126/gcc%2Fpointer-query.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31e924c52f430d81f030a2fa9f60b73a5a0d2126/gcc%2Fpointer-query.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpointer-query.cc?ref=31e924c52f430d81f030a2fa9f60b73a5a0d2126", "patch": "@@ -1087,6 +1087,34 @@ access_ref::inform_access (access_mode mode) const\n       else if (gimple_nop_p (stmt))\n \t/* Handle DECL_PARM below.  */\n \tref = SSA_NAME_VAR (ref);\n+      else if (is_gimple_assign (stmt)\n+\t       && (gimple_assign_rhs_code (stmt) == MIN_EXPR\n+\t\t   || gimple_assign_rhs_code (stmt) == MAX_EXPR))\n+\t{\n+\t  /* MIN or MAX_EXPR here implies a reference to a known object\n+\t     and either an unknown or distinct one (the latter being\n+\t     the result of an invalid relational expression).  Determine\n+\t     the identity of the former and point to it in the note.\n+\t     TODO: Consider merging with PHI handling.  */\n+\t  access_ref arg_ref[2];\n+\t  tree arg = gimple_assign_rhs1 (stmt);\n+\t  compute_objsize (arg, /* ostype = */ 1 , &arg_ref[0]);\n+\t  arg = gimple_assign_rhs2 (stmt);\n+\t  compute_objsize (arg, /* ostype = */ 1 , &arg_ref[1]);\n+\n+\t  /* Use the argument that references a known object with more\n+\t     space remaining.  */\n+\t  const bool idx\n+\t    = (!arg_ref[0].ref || !arg_ref[0].base0\n+\t       || (arg_ref[0].base0 && arg_ref[1].base0\n+\t\t   && (arg_ref[0].size_remaining ()\n+\t\t       < arg_ref[1].size_remaining ())));\n+\n+\t  arg_ref[idx].offrng[0] = offrng[0];\n+\t  arg_ref[idx].offrng[1] = offrng[1];\n+\t  arg_ref[idx].inform_access (mode);\n+\t  return;\n+\t}\n     }\n \n   if (DECL_P (ref))\n@@ -1463,32 +1491,36 @@ pointer_query::dump (FILE *dump_file, bool contents /* = false */)\n }\n \n /* A helper of compute_objsize_r() to determine the size from an assignment\n-   statement STMT with the RHS of either MIN_EXPR or MAX_EXPR.  */\n+   statement STMT with the RHS of either MIN_EXPR or MAX_EXPR.  On success\n+   set PREF->REF to the operand with more or less space remaining,\n+   respectively, if both refer to the same (sub)object, or to PTR if they\n+   might not, and return true.  Otherwise, if the identity of neither\n+   operand can be determined, return false.  */\n \n static bool\n-handle_min_max_size (gimple *stmt, int ostype, access_ref *pref,\n+handle_min_max_size (tree ptr, int ostype, access_ref *pref,\n \t\t     ssa_name_limit_t &snlim, pointer_query *qry)\n {\n-  tree_code code = gimple_assign_rhs_code (stmt);\n-\n-  tree ptr = gimple_assign_rhs1 (stmt);\n+  const gimple *stmt = SSA_NAME_DEF_STMT (ptr);\n+  const tree_code code = gimple_assign_rhs_code (stmt);\n \n   /* In a valid MAX_/MIN_EXPR both operands must refer to the same array.\n      Determine the size/offset of each and use the one with more or less\n      space remaining, respectively.  If either fails, use the information\n      determined from the other instead, adjusted up or down as appropriate\n      for the expression.  */\n   access_ref aref[2] = { *pref, *pref };\n-  if (!compute_objsize_r (ptr, ostype, &aref[0], snlim, qry))\n+  tree arg1 = gimple_assign_rhs1 (stmt);\n+  if (!compute_objsize_r (arg1, ostype, &aref[0], snlim, qry))\n     {\n       aref[0].base0 = false;\n       aref[0].offrng[0] = aref[0].offrng[1] = 0;\n       aref[0].add_max_offset ();\n       aref[0].set_max_size_range ();\n     }\n \n-  ptr = gimple_assign_rhs2 (stmt);\n-  if (!compute_objsize_r (ptr, ostype, &aref[1], snlim, qry))\n+  tree arg2 = gimple_assign_rhs2 (stmt);\n+  if (!compute_objsize_r (arg2, ostype, &aref[1], snlim, qry))\n     {\n       aref[1].base0 = false;\n       aref[1].offrng[0] = aref[1].offrng[1] = 0;\n@@ -1517,6 +1549,13 @@ handle_min_max_size (gimple *stmt, int ostype, access_ref *pref,\n \t    *pref = aref[i1];\n \t  else\n \t    *pref = aref[i0];\n+\n+\t  if (aref[i0].ref != aref[i1].ref)\n+\t    /* If the operands don't refer to the same (sub)object set\n+\t       PREF->REF to the SSA_NAME from which STMT was obtained\n+\t       so that both can be identified in a diagnostic.  */\n+\t    pref->ref = ptr;\n+\n \t  return true;\n \t}\n \n@@ -1537,6 +1576,10 @@ handle_min_max_size (gimple *stmt, int ostype, access_ref *pref,\n       pref->offrng[0] = aref[i0].offrng[0];\n       pref->offrng[1] = aref[i0].offrng[1];\n     }\n+\n+  /* Replace PTR->REF with the SSA_NAME to indicate the expression\n+     might not refer to the same (sub)object.  */\n+  pref->ref = ptr;\n   return true;\n }\n \n@@ -2009,8 +2052,9 @@ compute_objsize_r (tree ptr, int ostype, access_ref *pref,\n \n       if (code == MAX_EXPR || code == MIN_EXPR)\n \t{\n-\t  if (!handle_min_max_size (stmt, ostype, pref, snlim, qry))\n+\t  if (!handle_min_max_size (ptr, ostype, pref, snlim, qry))\n \t    return false;\n+\n \t  qry->put_ref (ptr, *pref);\n \t  return true;\n \t}"}, {"sha": "2604f65e6d5e303246df69f9fbf881236594249e", "filename": "gcc/testsuite/gcc.dg/Warray-bounds-89.c", "status": "added", "additions": 139, "deletions": 0, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31e924c52f430d81f030a2fa9f60b73a5a0d2126/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-89.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31e924c52f430d81f030a2fa9f60b73a5a0d2126/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-89.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-89.c?ref=31e924c52f430d81f030a2fa9f60b73a5a0d2126", "patch": "@@ -0,0 +1,139 @@\n+/* Verify warnings and notes for MIN_EXPRs involving either pointers\n+   to distinct objects or one to a known object and the other to\n+   an unknown one.  The relational expressions are strictly invalid\n+   but that should be diagnosed by a separate warning.\n+   { dg-do compile }\n+   { dg-options \"-O2 -Warray-bounds -Wno-stringop-overflow\" } */\n+\n+/* Verify the note points to the larger of the two objects and mentions\n+   the offset into it (alhough the offset would ideally be a part of\n+   the warning).  */\n+extern char a3[3];\n+extern char a5[5];  // { dg-message \"at offset 5 into object 'a5' of size 5\" \"note\" }\n+\n+void min_a3_a5 (int i)\n+{\n+  char *p = a3 + i;\n+  char *q = a5 + i;\n+\n+  /* The relational expression below is invalid and should be diagnosed\n+     by its own warning independently of -Warray-bounds.  */\n+  char *d = p < q ? p : q;\n+\n+  d[4] = 0;\n+\n+  /* Verify the type in the warning corresponds to the larger of the two\n+     objects.  */\n+  d[5] = 0;         // { dg-warning \"subscript 5 is outside array bounds of 'char\\\\\\[5]'\" }\n+}\n+\n+\n+// Same as above but with the larger array as the first MIN_EXPR operand.\n+extern char b4[4];\n+extern char b6[6];  // { dg-message \"at offset 6 into object 'b6' of size 6\" \"note\" }\n+\n+void min_b6_b4 (int i)\n+{\n+  char *p = b6 + i;\n+  char *q = b4 + i;\n+  char *d = p < q ? p : q;\n+\n+  d[5] = 0;\n+  d[6] = 0;         // { dg-warning \"subscript 6 is outside array bounds of 'char\\\\\\[6]'\" }\n+}\n+\n+\n+/* Same as above but with the first MIN_EXPR operand pointing to an unknown\n+   object.  */\n+extern char c7[7];  // { dg-message \"at offset 7 into object 'c7' of size 7\" \"note\" }\n+\n+void min_p_c7 (char *p, int i)\n+{\n+  char *q = c7 + i;\n+  char *d = p < q ? p : q;\n+\n+  d[6] = 0;\n+  d[7] = 0;         // { dg-warning \"subscript 7 is outside array bounds of 'char\\\\\\[7]'\" }\n+}\n+\n+\n+/* Same as above but with the second MIN_EXPR operand pointing to an unknown\n+   object.  */\n+extern char d8[8];  // { dg-message \"at offset 8 into object 'd8' of size 8\" \"note\" }\n+\n+void min_d8_p (char *q, int i)\n+{\n+  char *p = d8 + i;\n+  char *d = p < q ? p : q;\n+\n+  d[7] = 0;\n+  d[8] = 0;         // { dg-warning \"subscript 8 is outside array bounds of 'char\\\\\\[8]'\" }\n+}\n+\n+\n+/* The following are diagnosed by -Wstringop-overflow but, as a result\n+   of PR 101374, not by -Warray-bounds.  */\n+\n+struct A3_5\n+{\n+  char a3[3];\n+  char a5[5];  // { dg-message \"at offset 5 into object 'a5' of size 5\" \"note\" { xfail *-*-* } }\n+};\n+\n+void min_A3_A5 (int i, struct A3_5 *pa3_5)\n+{\n+  char *p = pa3_5->a3 + i;\n+  char *q = pa3_5->a5 + i;\n+\n+  char *d = p < q ? p : q;\n+\n+  // d[4] = 0;\n+  d[5] = 0;         // { dg-warning \"subscript 5 is outside array bounds of 'char\\\\\\[5]'\" \"pr??????\" { xfail *-*-* } }\n+}\n+\n+\n+struct B4_B6\n+{\n+  char b4[4];\n+  char b6[6];       // { dg-message \"at offset 6 into object 'b6' of size 6\" \"note\" { xfail *-*-* } }\n+};\n+\n+void min_B6_B4 (int i, struct B4_B6 *pb4_b6)\n+{\n+  char *p = pb4_b6->b6 + i;\n+  char *q = pb4_b6->b4 + i;\n+  char *d = p < q ? p : q;\n+\n+  d[5] = 0;\n+  d[6] = 0;         // { dg-warning \"subscript 6 is outside array bounds of 'char\\\\\\[6]'\" \"pr??????\" { xfail *-*-* } }\n+}\n+\n+\n+struct C7\n+{\n+  char c7[7];       // { dg-message \"at offset 7 into object 'c7' of size 7\" \"note\" { xfail *-*-* } }\n+};\n+\n+void min_p_C7 (char *p, int i, struct C7 *pc7)\n+{\n+  char *q = pc7->c7 + i;\n+  char *d = p < q ? p : q;\n+\n+  d[6] = 0;\n+  d[7] = 0;         // { dg-warning \"subscript 7 is outside array bounds of 'char\\\\\\[7]'\" \"pr??????\" { xfail *-*-* } }\n+}\n+\n+\n+struct D8\n+{\n+  char d8[8];       // { dg-message \"at offset 8 into object 'd8' of size 8\" \"note\" { xfail *-*-* } }\n+};\n+\n+void min_D8_p (char *q, int i, struct D8 *pd8)\n+{\n+  char *p = pd8->d8 + i;\n+  char *d = p < q ? p : q;\n+\n+  d[7] = 0;\n+  d[8] = 0;         // { dg-warning \"subscript 8 is outside array bounds of 'char\\\\\\[8]'\" \"pr??????\" { xfail *-*-* } }\n+}"}, {"sha": "4b6d1ab83c5d7e8e28492b5d02244312669a6274", "filename": "gcc/testsuite/gcc.dg/Wstringop-overflow-62.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31e924c52f430d81f030a2fa9f60b73a5a0d2126/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-62.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31e924c52f430d81f030a2fa9f60b73a5a0d2126/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-62.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-62.c?ref=31e924c52f430d81f030a2fa9f60b73a5a0d2126", "patch": "@@ -117,7 +117,7 @@ void test_min (void)\n   {\n     /* Exercise a pointer pointing to a known object plus constant offset\n        with one pointing to an unknown object.  */\n-    char a6[6];               // { dg-message \": destination object 'a6'\" \"note\" }\n+    char a6[6];               // { dg-message \"(at offset 1 into )?destination object 'a6'\" \"note\" }\n     char *p1 = ptr;\n     char *p2 = a6 + 1;\n     char *q = MIN (p1, p2);"}, {"sha": "bacec964d36bbde8d271e5a7c7226cc71aab218d", "filename": "gcc/testsuite/gcc.dg/Wstringop-overflow-74.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31e924c52f430d81f030a2fa9f60b73a5a0d2126/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-74.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31e924c52f430d81f030a2fa9f60b73a5a0d2126/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-74.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-74.c?ref=31e924c52f430d81f030a2fa9f60b73a5a0d2126", "patch": "@@ -0,0 +1,22 @@\n+/* PR middle-end/102200 - ICE on a min of a decl and pointer in a loop\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall\" } */\n+\n+typedef __SIZE_TYPE__ size_t;\n+\n+extern char a[], n;\n+\n+void f (void)\n+{\n+  char *p = a;\n+  size_t end = 1;\n+\n+  while (n)\n+    {\n+      if (p < (char*)end)\n+        *p = ';';\n+\n+      if (p > (char*)&end)\n+        p = (char*)&end;\n+    }\n+}"}, {"sha": "0b242e8562d31f3e5bf8bd44121fc9c109aab71b", "filename": "gcc/testsuite/gcc.dg/Wstringop-overflow-75.c", "status": "added", "additions": 133, "deletions": 0, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31e924c52f430d81f030a2fa9f60b73a5a0d2126/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-75.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31e924c52f430d81f030a2fa9f60b73a5a0d2126/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-75.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-75.c?ref=31e924c52f430d81f030a2fa9f60b73a5a0d2126", "patch": "@@ -0,0 +1,133 @@\n+/* Verify warnings and notes for MIN_EXPRs involving either pointers\n+   to distinct objects or one to a known object and the other to\n+   an unknown one.  The relational expressions are strictly invalid\n+   but that should be diagnosed by a separate warning.\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wno-array-bounds\" } */\n+\n+/* Verify the note points to the larger of the two objects and mentions\n+   the offset into it (although the offset might be better included in\n+   the warning).  */\n+extern char a3[3];\n+extern char a5[5];  // { dg-message \"at offset 5 into destination object 'a5' of size 5\" \"note\" }\n+\n+void min_a3_a5 (int i)\n+{\n+  char *p = a3 + i;\n+  char *q = a5 + i;\n+\n+  /* The relational expression below is invalid and should be diagnosed\n+     by its own warning independently of -Wstringop-overflow.  */\n+  char *d = p < q ? p : q;\n+\n+  d[4] = 0;\n+  d[5] = 0;         // { dg-warning \"writing 1 byte into a region of size 0\" }\n+}\n+\n+\n+// Same as above but with the larger array as the first MIN_EXPR operand.\n+extern char b4[4];\n+extern char b6[6];  // { dg-message \"at offset 6 into destination object 'b6' of size 6\" \"note\" }\n+\n+void min_b6_b4 (int i)\n+{\n+  char *p = b6 + i;\n+  char *q = b4 + i;\n+  char *d = p < q ? p : q;\n+\n+  d[5] = 0;\n+  d[6] = 0;         // { dg-warning \"writing 1 byte into a region of size 0\" }\n+}\n+\n+\n+/* Same as above but with the first MIN_EXPR operand pointing to an unknown\n+   object.  */\n+extern char c7[7];  // { dg-message \"at offset 7 into destination object 'c7' of size 7\" \"note\" }\n+\n+void min_p_c7 (char *p, int i)\n+{\n+  char *q = c7 + i;\n+  char *d = p < q ? p : q;\n+\n+  d[6] = 0;\n+  d[7] = 0;         // { dg-warning \"writing 1 byte into a region of size 0\" }\n+}\n+\n+\n+/* Same as above but with the second MIN_EXPR operand pointing to an unknown\n+   object.  */\n+extern char d8[8];  // { dg-message \"at offset 8 into destination object 'd8' of size 8\" \"note\" }\n+\n+void min_d8_p (char *q, int i)\n+{\n+  char *p = d8 + i;\n+  char *d = p < q ? p : q;\n+\n+  d[7] = 0;\n+  d[8] = 0;         // { dg-warning \"writing 1 byte into a region of size 0\" }\n+}\n+\n+\n+struct A3_5\n+{\n+  char a3[3];\n+  char a5[5];  // { dg-message \"at offset 5 into destination object 'a5' of size 5\" \"note\" }\n+};\n+\n+void min_A3_A5 (int i, struct A3_5 *pa3_5)\n+{\n+  char *p = pa3_5->a3 + i;\n+  char *q = pa3_5->a5 + i;\n+\n+  char *d = p < q ? p : q;\n+\n+  // d[4] = 0;\n+  d[5] = 0;         // { dg-warning \"writing 1 byte into a region of size 0\" }\n+}\n+\n+\n+struct B4_B6\n+{\n+  char b4[4];\n+  char b6[6];       // { dg-message \"at offset 6 into destination object 'b6' of size 6\" \"note\" }\n+};\n+\n+void min_B6_B4 (int i, struct B4_B6 *pb4_b6)\n+{\n+  char *p = pb4_b6->b6 + i;\n+  char *q = pb4_b6->b4 + i;\n+  char *d = p < q ? p : q;\n+\n+  d[5] = 0;\n+  d[6] = 0;         // { dg-warning \"writing 1 byte into a region of size 0\" }\n+}\n+\n+\n+struct C7\n+{\n+  char c7[7];       // { dg-message \"at offset 7 into destination object 'c7' of size 7\" \"note\" }\n+};\n+\n+void min_p_C7 (char *p, int i, struct C7 *pc7)\n+{\n+  char *q = pc7->c7 + i;\n+  char *d = p < q ? p : q;\n+\n+  d[6] = 0;\n+  d[7] = 0;         // { dg-warning \"writing 1 byte into a region of size 0\" }\n+}\n+\n+\n+struct D8\n+{\n+  char d8[8];       // { dg-message \"at offset 8 into destination object 'd8' of size 8\" \"note\" }\n+};\n+\n+void min_D8_p (char *q, int i, struct D8 *pd8)\n+{\n+  char *p = pd8->d8 + i;\n+  char *d = p < q ? p : q;\n+\n+  d[7] = 0;\n+  d[8] = 0;         // { dg-warning \"writing 1 byte into a region of size 0\" }\n+}"}, {"sha": "18191a1aa5ea5da4eb13d0c4b5a02ba7e71cc7b6", "filename": "gcc/testsuite/gcc.dg/Wstringop-overflow-76.c", "status": "added", "additions": 148, "deletions": 0, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31e924c52f430d81f030a2fa9f60b73a5a0d2126/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-76.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31e924c52f430d81f030a2fa9f60b73a5a0d2126/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-76.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstringop-overflow-76.c?ref=31e924c52f430d81f030a2fa9f60b73a5a0d2126", "patch": "@@ -0,0 +1,148 @@\n+/* Verify warnings and notes for MAX_EXPRs involving either pointers\n+   to distinct objects or one to a known object and the other to\n+   an unknown one.  Unlike for the same object, for unrelated objects\n+   the expected warnings and notes are the same as for MIN_EXPR: when\n+   the order of the objects in the address space cannot be determined\n+   the larger of them is assumed to be used.  (This is different for\n+   distinct struct members where the order is given.)\n+   The relational expressions are strictly invalid but that should be\n+   diagnosed by a separate warning.\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wno-array-bounds\" } */\n+\n+#define MAX(p, q) ((p) > (q) ? (p) : (q))\n+\n+/* Verify that even for MAX_EXPR and like for MIN_EXPR, the note points\n+   to the larger of the two objects and mentions the offset into it\n+   (although the offset might be better included in the warning).  */\n+extern char a3[3];\n+extern char a5[5];  // { dg-message \"at offset 5 into destination object 'a5' of size 5\" \"note\" }\n+\n+void max_a3_a5 (int i)\n+{\n+  char *p = a3 + i;\n+  char *q = a5 + i;\n+\n+  /* The relational expression below is invalid and should be diagnosed\n+     by its own warning independently of -Wstringop-overflow.  */\n+  char *d = MAX (p, q);\n+\n+  d[2] = 0;\n+  d[3] = 0;\n+  d[4] = 0;\n+  d[5] = 0;         // { dg-warning \"writing 1 byte into a region of size 0\" }\n+}\n+\n+\n+// Same as above but with the larger array as the first MAX_EXPR operand.\n+extern char b4[4];\n+extern char b6[6];  // { dg-message \"at offset 6 into destination object 'b6' of size 6\" \"note\" }\n+\n+void max_b6_b4 (int i)\n+{\n+  char *p = b6 + i;\n+  char *q = b4 + i;\n+  char *d = MAX (p, q);\n+\n+  d[3] = 0;\n+  d[4] = 0;\n+  d[5] = 0;\n+  d[6] = 0;         // { dg-warning \"writing 1 byte into a region of size 0\" }\n+}\n+\n+\n+/* Same as above but with the first MAX_EXPR operand pointing to an unknown\n+   object.  */\n+extern char c7[7];  // { dg-message \"at offset 7 into destination object 'c7' of size 7\" \"note\" }\n+\n+void max_p_c7 (char *p, int i)\n+{\n+  char *q = c7 + i;\n+  char *d = MAX (p, q);\n+\n+  d[6] = 0;\n+  d[7] = 0;         // { dg-warning \"writing 1 byte into a region of size 0\" }\n+}\n+\n+\n+/* Same as above but with the second MIN_EXPR operand pointing to an unknown\n+   object.  */\n+extern char d8[8];  // { dg-message \"at offset 8 into destination object 'd8' of size 8\" \"note\" }\n+\n+void max_d8_p (char *q, int i)\n+{\n+  char *p = d8 + i;\n+  char *d = MAX (p, q);\n+\n+  d[7] = 0;\n+  d[8] = 0;         // { dg-warning \"writing 1 byte into a region of size 0\" }\n+}\n+\n+\n+struct A3_5\n+{\n+  char a3[3];  // { dg-message \"at offset 3 into destination object 'a3' of size 3\" \"pr??????\" { xfail *-*-* } }\n+  char a5[5];  // { dg-message \"at offset 5 into destination object 'a5' of size 5\" \"note\" }\n+};\n+\n+void max_A3_A5 (int i, struct A3_5 *pa3_5)\n+{\n+  char *p = pa3_5->a3 + i;\n+  char *q = pa3_5->a5 + i;\n+\n+  char *d = MAX (p, q);\n+\n+  d[2] = 0;\n+  d[3] = 0;         // { dg-warning \"writing 1 byte into a region of size 0\" \"pr??????\" { xfail *-*-* } }\n+  d[4] = 0;\n+  d[5] = 0;         // { dg-warning \"writing 1 byte into a region of size 0\" }\n+}\n+\n+\n+struct B4_B6\n+{\n+  char b4[4];\n+  char b6[6];       // { dg-message \"at offset 6 into destination object 'b6' of size 6\" \"note\" }\n+};\n+\n+void max_B6_B4 (int i, struct B4_B6 *pb4_b6)\n+{\n+  char *p = pb4_b6->b6 + i;\n+  char *q = pb4_b6->b4 + i;\n+  char *d = MAX (p, q);\n+\n+  d[3] = 0;\n+  d[4] = 0;\n+  d[5] = 0;\n+  d[6] = 0;         // { dg-warning \"writing 1 byte into a region of size 0\" }\n+}\n+\n+\n+struct C7\n+{\n+  char c7[7];       // { dg-message \"at offset 7 into destination object 'c7' of size 7\" \"note\" }\n+};\n+\n+void max_p_C7 (char *p, int i, struct C7 *pc7)\n+{\n+  char *q = pc7->c7 + i;\n+  char *d = MAX (p, q);\n+\n+  d[6] = 0;\n+  d[7] = 0;         // { dg-warning \"writing 1 byte into a region of size 0\" }\n+}\n+\n+\n+struct D8\n+{\n+  char d8[8];       // { dg-message \"at offset 8 into destination object 'd8' of size 8\" \"note\" }\n+};\n+\n+void max_D8_p (char *q, int i, struct D8 *pd8)\n+{\n+  char *p = pd8->d8 + i;\n+  char *d = MAX (p, q);\n+\n+  d[7] = 0;\n+  d[8] = 0;         // { dg-warning \"writing 1 byte into a region of size 0\" }\n+}"}]}