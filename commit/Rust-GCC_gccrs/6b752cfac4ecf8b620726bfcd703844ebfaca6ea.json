{"sha": "6b752cfac4ecf8b620726bfcd703844ebfaca6ea", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmI3NTJjZmFjNGVjZjhiNjIwNzI2YmZjZDcwMzg0NGViZmFjYTZlYQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2016-10-20T18:51:35Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2016-10-20T18:51:35Z"}, "message": "runtime: rewrite interface code into Go\n    \n    I started to copy the Go 1.7 interface code, but the gc and gccgo\n    representations of interfaces are too different.  So instead I rewrote\n    the gccgo interface code from C to Go.  The code is largely the same as\n    it was, but the names are more like those used in the gc runtime.\n    \n    I also copied over the string comparison functions, and tweaked the\n    compiler to use eqstring when comparing strings for equality.\n    \n    Reviewed-on: https://go-review.googlesource.com/31591\n\nFrom-SVN: r241384", "tree": {"sha": "458f96322bb64b331d71a3304f09cd7c032efa9c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/458f96322bb64b331d71a3304f09cd7c032efa9c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6b752cfac4ecf8b620726bfcd703844ebfaca6ea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b752cfac4ecf8b620726bfcd703844ebfaca6ea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6b752cfac4ecf8b620726bfcd703844ebfaca6ea", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b752cfac4ecf8b620726bfcd703844ebfaca6ea/comments", "author": null, "committer": null, "parents": [{"sha": "fceabe505cf0dc7030602e582fadadcce73dd6de", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fceabe505cf0dc7030602e582fadadcce73dd6de", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fceabe505cf0dc7030602e582fadadcce73dd6de"}], "stats": {"total": 1852, "additions": 717, "deletions": 1135}, "files": [{"sha": "a331db61b3d836f689bdee1ea755a33c6de1f637", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b752cfac4ecf8b620726bfcd703844ebfaca6ea/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b752cfac4ecf8b620726bfcd703844ebfaca6ea/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=6b752cfac4ecf8b620726bfcd703844ebfaca6ea", "patch": "@@ -1,4 +1,4 @@\n-5346c7d15362a16efa0defaaeca63b1fce1c1523\n+14dc8052a09ad0a2226e64ab6b5af69c6923b830\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "ba55ea314c3458176b347c11bc46a63a308ce920", "filename": "gcc/go/gofrontend/escape.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b752cfac4ecf8b620726bfcd703844ebfaca6ea/gcc%2Fgo%2Fgofrontend%2Fescape.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b752cfac4ecf8b620726bfcd703844ebfaca6ea/gcc%2Fgo%2Fgofrontend%2Fescape.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fescape.cc?ref=6b752cfac4ecf8b620726bfcd703844ebfaca6ea", "patch": "@@ -1874,7 +1874,7 @@ Escape_analysis_assign::assign(Node* dst, Node* src)\n \t\t  case Runtime::IFACEI2T2P:\n \t\t  case Runtime::IFACEE2T2:\n \t\t  case Runtime::IFACEI2T2:\n-\t\t  case Runtime::CONVERT_INTERFACE:\n+\t\t  case Runtime::REQUIREITAB:\n \t\t    // All versions of interface conversion that might result\n \t\t    // from a type assertion.  Some of these are the result of\n \t\t    // a tuple type assertion statement and may not be covered\n@@ -2633,7 +2633,7 @@ Escape_analysis_flood::flood(Level level, Node* dst, Node* src,\n \t\t    case Runtime::CONCATSTRING5:\n \t\t    case Runtime::CONSTRUCT_MAP:\n \t\t    case Runtime::INTSTRING:\n-\t\t    case Runtime::CONVERT_INTERFACE:\n+\t\t    case Runtime::REQUIREITAB:\n \t\t      // All runtime calls that involve allocation of memory\n \t\t      // except new.  Runtime::NEW gets lowered into an\n \t\t      // allocation expression."}, {"sha": "241dc36e5e1350578ce7173bf1e46a7e279c871a", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 30, "deletions": 19, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b752cfac4ecf8b620726bfcd703844ebfaca6ea/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b752cfac4ecf8b620726bfcd703844ebfaca6ea/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=6b752cfac4ecf8b620726bfcd703844ebfaca6ea", "patch": "@@ -323,9 +323,8 @@ Expression::convert_interface_to_interface(Type *lhs_type, Expression* rhs,\n   if (for_type_guard)\n     {\n       // A type assertion fails when converting a nil interface.\n-      first_field =\n-          Runtime::make_call(Runtime::ASSERT_INTERFACE, location, 2,\n-                             lhs_type_expr, rhs_type_expr);\n+      first_field = Runtime::make_call(Runtime::ASSERTITAB, location, 2,\n+\t\t\t\t       lhs_type_expr, rhs_type_expr);\n     }\n   else if (lhs_is_empty)\n     {\n@@ -337,9 +336,8 @@ Expression::convert_interface_to_interface(Type *lhs_type, Expression* rhs,\n     {\n       // A conversion to a non-empty interface may fail, but unlike a\n       // type assertion converting nil will always succeed.\n-      first_field =\n-          Runtime::make_call(Runtime::CONVERT_INTERFACE, location, 2,\n-                             lhs_type_expr, rhs_type_expr);\n+      first_field = Runtime::make_call(Runtime::REQUIREITAB, location, 2,\n+\t\t\t\t       lhs_type_expr, rhs_type_expr);\n     }\n \n   // The second field is simply the object pointer.\n@@ -370,7 +368,7 @@ Expression::convert_interface_to_type(Type *lhs_type, Expression* rhs,\n   Expression* rhs_inter_expr = Expression::make_type_descriptor(rhs_type,\n                                                                 location);\n \n-  Expression* check_iface = Runtime::make_call(Runtime::CHECK_INTERFACE_TYPE,\n+  Expression* check_iface = Runtime::make_call(Runtime::ASSERTI2T,\n                                                location, 3, lhs_type_expr,\n                                                rhs_descriptor, rhs_inter_expr);\n \n@@ -1290,7 +1288,10 @@ Func_descriptor_expression::do_get_backend(Translate_context* context)\n       && !no->func_declaration_value()->asm_name().empty()\n       && Linemap::is_predeclared_location(no->location()))\n     {\n-      var_name = no->func_declaration_value()->asm_name() + \"_descriptor\";\n+      if (no->func_declaration_value()->asm_name().substr(0, 8) != \"runtime.\")\n+\tvar_name = no->func_declaration_value()->asm_name() + \"_descriptor\";\n+      else\n+\tvar_name = no->func_declaration_value()->asm_name() + \"$descriptor\";\n       is_descriptor = true;\n     }\n   else\n@@ -6196,9 +6197,18 @@ Expression::comparison(Translate_context* context, Type* result_type,\n \n   if (left_type->is_string_type() && right_type->is_string_type())\n     {\n-      left = Runtime::make_call(Runtime::STRCMP, location, 2,\n-                                left, right);\n-      right = zexpr;\n+      if (op == OPERATOR_EQEQ || op == OPERATOR_NOTEQ)\n+\t{\n+\t  left = Runtime::make_call(Runtime::EQSTRING, location, 2,\n+\t\t\t\t    left, right);\n+\t  right = Expression::make_boolean(true, location);\n+\t}\n+      else\n+\t{\n+\t  left = Runtime::make_call(Runtime::CMPSTRING, location, 2,\n+\t\t\t\t    left, right);\n+\t  right = zexpr;\n+\t}\n     }\n   else if ((left_type->interface_type() != NULL\n \t    && right_type->interface_type() == NULL\n@@ -6230,37 +6240,38 @@ Expression::comparison(Translate_context* context, Type* result_type,\n           Expression::make_type_descriptor(right_type, location);\n       left =\n           Runtime::make_call((left_type->interface_type()->is_empty()\n-                              ? Runtime::EMPTY_INTERFACE_VALUE_COMPARE\n-                              : Runtime::INTERFACE_VALUE_COMPARE),\n+                              ? Runtime::EFACEVALEQ\n+                              : Runtime::IFACEVALEQ),\n                              location, 3, left, descriptor,\n                              pointer_arg);\n-      right = zexpr;\n+      go_assert(op == OPERATOR_EQEQ || op == OPERATOR_NOTEQ);\n+      right = Expression::make_boolean(true, location);\n     }\n   else if (left_type->interface_type() != NULL\n \t   && right_type->interface_type() != NULL)\n     {\n       Runtime::Function compare_function;\n       if (left_type->interface_type()->is_empty()\n \t  && right_type->interface_type()->is_empty())\n-\tcompare_function = Runtime::EMPTY_INTERFACE_COMPARE;\n+\tcompare_function = Runtime::EFACEEQ;\n       else if (!left_type->interface_type()->is_empty()\n \t       && !right_type->interface_type()->is_empty())\n-\tcompare_function = Runtime::INTERFACE_COMPARE;\n+\tcompare_function = Runtime::IFACEEQ;\n       else\n \t{\n \t  if (left_type->interface_type()->is_empty())\n \t    {\n-\t      go_assert(op == OPERATOR_EQEQ || op == OPERATOR_NOTEQ);\n \t      std::swap(left_type, right_type);\n \t      std::swap(left, right);\n \t    }\n \t  go_assert(!left_type->interface_type()->is_empty());\n \t  go_assert(right_type->interface_type()->is_empty());\n-\t  compare_function = Runtime::INTERFACE_EMPTY_COMPARE;\n+\t  compare_function = Runtime::IFACEEFACEEQ;\n \t}\n \n       left = Runtime::make_call(compare_function, location, 2, left, right);\n-      right = zexpr;\n+      go_assert(op == OPERATOR_EQEQ || op == OPERATOR_NOTEQ);\n+      right = Expression::make_boolean(true, location);\n     }\n \n   if (left_type->is_nil_type()"}, {"sha": "3051624b66c32d8c15af7dd4d32b9d21705a076d", "filename": "gcc/go/gofrontend/runtime.def", "status": "modified", "additions": 28, "deletions": 23, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b752cfac4ecf8b620726bfcd703844ebfaca6ea/gcc%2Fgo%2Fgofrontend%2Fruntime.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b752cfac4ecf8b620726bfcd703844ebfaca6ea/gcc%2Fgo%2Fgofrontend%2Fruntime.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fruntime.def?ref=6b752cfac4ecf8b620726bfcd703844ebfaca6ea", "patch": "@@ -50,8 +50,11 @@ DEF_GO_RUNTIME(CONCATSTRING4, \"runtime.concatstring4\",\n DEF_GO_RUNTIME(CONCATSTRING5, \"runtime.concatstring5\",\n \t       P2(POINTER, ARRAY5STRING), R1(STRING))\n \n+// Compare two strings for equality.\n+DEF_GO_RUNTIME(EQSTRING, \"runtime.eqstring\", P2(STRING, STRING), R1(BOOL))\n+\n // Compare two strings.\n-DEF_GO_RUNTIME(STRCMP, \"__go_strcmp\", P2(STRING, STRING), R1(INT))\n+DEF_GO_RUNTIME(CMPSTRING, \"runtime.cmpstring\", P2(STRING, STRING), R1(INT))\n \n // Take a slice of a string.\n DEF_GO_RUNTIME(STRING_SLICE, \"__go_string_slice\", P3(STRING, INT, INT),\n@@ -259,22 +262,27 @@ DEF_GO_RUNTIME(IFACEE2T2, \"runtime.ifaceE2T2\", P3(TYPE, EFACE, POINTER),\n DEF_GO_RUNTIME(IFACEI2T2, \"runtime.ifaceI2T2\", P3(TYPE, IFACE, POINTER),\n \t       R1(BOOL))\n \n-// A type assertion from one interface type to another.  This is\n-// used for a type assertion.\n-DEF_GO_RUNTIME(ASSERT_INTERFACE, \"__go_assert_interface\", P2(TYPE, TYPE), R1(POINTER))\n-\n-// Convert one interface type to another.  This is used for an\n-// assignment.\n-DEF_GO_RUNTIME(CONVERT_INTERFACE, \"__go_convert_interface\", P2(TYPE, TYPE),\n+// Return the interface method table for the second type converted to\n+// the first type which is a (possibly empty) interface type.  Panics\n+// if the second type is nil (indicating a nil interface value) or if\n+// the conversion is not possible.  Used for type assertions.  This is\n+// like REQUIREITAB, but for type assertions.\n+DEF_GO_RUNTIME(ASSERTITAB, \"runtime.assertitab\", P2(TYPE, TYPE), R1(POINTER))\n+\n+// Return the interface method table for the second type converted to\n+// the first type, which is a non-empty interface type.  Return nil if\n+// the second type is nil, indicating a nil interface value.  Panics\n+// if the conversion is not possible.  Used for assignments.  This is\n+// like ASSERTITAB, but for assignments.\n+DEF_GO_RUNTIME(REQUIREITAB, \"runtime.requireitab\", P2(TYPE, TYPE),\n \t       R1(POINTER))\n \n // Check whether an interface type may be converted to a\n // non-interface type.\n-DEF_GO_RUNTIME(CHECK_INTERFACE_TYPE, \"__go_check_interface_type\",\n-\t       P3(TYPE, TYPE, TYPE), R0())\n+DEF_GO_RUNTIME(ASSERTI2T, \"runtime.assertI2T\", P3(TYPE, TYPE, TYPE), R0())\n \n-// Return whether we can convert an interface type to a type.\n-DEF_GO_RUNTIME(IFACEI2TP, \"runtime.ifaceI2Tp\", P2(TYPE, TYPE), R1(BOOL))\n+// Return whether we can convert a type to an interface type.\n+DEF_GO_RUNTIME(IFACET2IP, \"runtime.ifaceT2Ip\", P2(TYPE, TYPE), R1(BOOL))\n \n // Get the type descriptor of an empty interface.\n DEF_GO_RUNTIME(EFACETYPE, \"runtime.efacetype\", P1(EFACE), R1(TYPE))\n@@ -287,25 +295,22 @@ DEF_GO_RUNTIME(IFACETYPE, \"runtime.ifacetype\", P1(IFACE), R1(TYPE))\n DEF_GO_RUNTIME(IFACETYPEEQ, \"runtime.ifacetypeeq\", P2(TYPE, TYPE), R1(BOOL))\n \n // Compare two empty interface values.\n-DEF_GO_RUNTIME(EMPTY_INTERFACE_COMPARE, \"__go_empty_interface_compare\",\n-\t       P2(EFACE, EFACE), R1(INT))\n+DEF_GO_RUNTIME(EFACEEQ, \"runtime.efaceeq\", P2(EFACE, EFACE), R1(BOOL))\n \n // Compare an empty interface value to a non-interface value.\n-DEF_GO_RUNTIME(EMPTY_INTERFACE_VALUE_COMPARE,\n-\t       \"__go_empty_interface_value_compare\",\n-\t       P3(EFACE, TYPE, POINTER), R1(INT))\n+DEF_GO_RUNTIME(EFACEVALEQ, \"runtime.efacevaleq\", P3(EFACE, TYPE, POINTER),\n+\t       R1(BOOL))\n \n // Compare two non-empty interface values.\n-DEF_GO_RUNTIME(INTERFACE_COMPARE, \"__go_interface_compare\",\n-\t       P2(IFACE, IFACE), R1(INT))\n+DEF_GO_RUNTIME(IFACEEQ, \"runtime.ifaceeq\", P2(IFACE, IFACE), R1(BOOL))\n \n // Compare a non-empty interface value to a non-interface value.\n-DEF_GO_RUNTIME(INTERFACE_VALUE_COMPARE, \"__go_interface_value_compare\",\n-\t       P3(IFACE, TYPE, POINTER), R1(INT))\n+DEF_GO_RUNTIME(IFACEVALEQ, \"runtime.ifacevaleq\", P3(IFACE, TYPE, POINTER),\n+\t       R1(BOOL))\n \n // Compare a non-empty interface value to an interface value.\n-DEF_GO_RUNTIME(INTERFACE_EMPTY_COMPARE, \"__go_interface_empty_compare\",\n-\t       P2(IFACE, EFACE), R1(INT))\n+DEF_GO_RUNTIME(IFACEEFACEEQ, \"runtime.ifaceefaceeq\", P2(IFACE, EFACE),\n+\t       R1(BOOL))\n \n \n // Lock the printer (for print/println)."}, {"sha": "e36262d86b8dfd18c1e849c7c336b5548ff1eb85", "filename": "gcc/go/gofrontend/statements.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b752cfac4ecf8b620726bfcd703844ebfaca6ea/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b752cfac4ecf8b620726bfcd703844ebfaca6ea/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fstatements.cc?ref=6b752cfac4ecf8b620726bfcd703844ebfaca6ea", "patch": "@@ -3894,7 +3894,7 @@ Type_case_clauses::Type_case_clause::lower(Type* switch_val_type,\n       else\n \tcond = Runtime::make_call((type->interface_type() == NULL\n \t\t\t\t   ? Runtime::IFACETYPEEQ\n-\t\t\t\t   : Runtime::IFACEI2TP),\n+\t\t\t\t   : Runtime::IFACET2IP),\n \t\t\t\t  loc, 2,\n \t\t\t\t  Expression::make_type_descriptor(type, loc),\n \t\t\t\t  ref);"}, {"sha": "1635709be2ce0f8937b8308fa52a9d65ab8ddb5b", "filename": "gcc/go/gofrontend/types.cc", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b752cfac4ecf8b620726bfcd703844ebfaca6ea/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b752cfac4ecf8b620726bfcd703844ebfaca6ea/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.cc?ref=6b752cfac4ecf8b620726bfcd703844ebfaca6ea", "patch": "@@ -1710,13 +1710,13 @@ Type::type_functions(Gogo* gogo, Named_type* name, Function_type* hash_fntype,\n \tcase Type::TYPE_INTERFACE:\n \t  if (this->interface_type()->is_empty())\n \t    {\n-\t      hash_fnname = \"__go_type_hash_empty_interface\";\n-\t      equal_fnname = \"__go_type_equal_empty_interface\";\n+\t      hash_fnname = \"runtime.nilinterhash\";\n+\t      equal_fnname = \"runtime.nilinterequal\";\n \t    }\n \t  else\n \t    {\n-\t      hash_fnname = \"__go_type_hash_interface\";\n-\t      equal_fnname = \"__go_type_equal_interface\";\n+\t      hash_fnname = \"runtime.interhash\";\n+\t      equal_fnname = \"runtime.interequal\";\n \t    }\n \t  break;\n "}, {"sha": "08947c06b04cabcb7b69e04b1574feedb4413bb7", "filename": "libgo/Makefile.am", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b752cfac4ecf8b620726bfcd703844ebfaca6ea/libgo%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b752cfac4ecf8b620726bfcd703844ebfaca6ea/libgo%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.am?ref=6b752cfac4ecf8b620726bfcd703844ebfaca6ea", "patch": "@@ -430,26 +430,17 @@ endif\n runtime_files = \\\n \truntime/go-append.c \\\n \truntime/go-assert.c \\\n-\truntime/go-assert-interface.c \\\n \truntime/go-breakpoint.c \\\n \truntime/go-caller.c \\\n \truntime/go-callers.c \\\n-\truntime/go-can-convert-interface.c \\\n \truntime/go-cdiv.c \\\n \truntime/go-cgo.c \\\n-\truntime/go-check-interface.c \\\n \truntime/go-construct-map.c \\\n-\truntime/go-convert-interface.c \\\n \truntime/go-copy.c \\\n \truntime/go-defer.c \\\n \truntime/go-deferred-recover.c \\\n-\truntime/go-eface-compare.c \\\n-\truntime/go-eface-val-compare.c \\\n \truntime/go-ffi.c \\\n \truntime/go-fieldtrack.c \\\n-\truntime/go-interface-compare.c \\\n-\truntime/go-interface-eface-compare.c \\\n-\truntime/go-interface-val-compare.c \\\n \truntime/go-make-slice.c \\\n \truntime/go-matherr.c \\\n \truntime/go-memclr.c \\\n@@ -466,13 +457,10 @@ runtime_files = \\\n \truntime/go-runtime-error.c \\\n \truntime/go-setenv.c \\\n \truntime/go-signal.c \\\n-\truntime/go-strcmp.c \\\n \truntime/go-strslice.c \\\n \truntime/go-type-complex.c \\\n-\truntime/go-type-eface.c \\\n \truntime/go-type-float.c \\\n \truntime/go-type-identity.c \\\n-\truntime/go-type-interface.c \\\n \truntime/go-type-string.c \\\n \truntime/go-typedesc-equal.c \\\n \truntime/go-unsafe-new.c \\\n@@ -500,10 +488,8 @@ runtime_files = \\\n \t$(runtime_thread_files) \\\n \truntime/yield.c \\\n \t$(rtems_task_variable_add_file) \\\n-\tgo-iface.c \\\n \tlfstack.c \\\n \tmalloc.c \\\n-\treflect.c \\\n \truntime1.c \\\n \tsigqueue.c \\\n \t$(runtime_getncpu_file)\n@@ -518,10 +504,6 @@ malloc.c: $(srcdir)/runtime/malloc.goc goc2c\n \t./goc2c $< > $@.tmp\n \tmv -f $@.tmp $@\n \n-reflect.c: $(srcdir)/runtime/reflect.goc goc2c\n-\t./goc2c $< > $@.tmp\n-\tmv -f $@.tmp $@\n-\n runtime1.c: $(srcdir)/runtime/runtime1.goc goc2c\n \t./goc2c $< > $@.tmp\n \tmv -f $@.tmp $@"}, {"sha": "6cbac4278ffd85276b4d7e88b862e01f6e01ceb5", "filename": "libgo/Makefile.in", "status": "modified", "additions": 11, "deletions": 133, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b752cfac4ecf8b620726bfcd703844ebfaca6ea/libgo%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b752cfac4ecf8b620726bfcd703844ebfaca6ea/libgo%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.in?ref=6b752cfac4ecf8b620726bfcd703844ebfaca6ea", "patch": "@@ -237,29 +237,23 @@ libgo_llgo_la_DEPENDENCIES = $(am__DEPENDENCIES_4)\n @LIBGO_IS_DARWIN_TRUE@@LIBGO_IS_LINUX_FALSE@am__objects_4 =  \\\n @LIBGO_IS_DARWIN_TRUE@@LIBGO_IS_LINUX_FALSE@\tgetncpu-bsd.lo\n @LIBGO_IS_LINUX_TRUE@am__objects_4 = getncpu-linux.lo\n-am__objects_5 = go-append.lo go-assert.lo go-assert-interface.lo \\\n-\tgo-breakpoint.lo go-caller.lo go-callers.lo \\\n-\tgo-can-convert-interface.lo go-cdiv.lo go-cgo.lo \\\n-\tgo-check-interface.lo go-construct-map.lo \\\n-\tgo-convert-interface.lo go-copy.lo go-defer.lo \\\n-\tgo-deferred-recover.lo go-eface-compare.lo \\\n-\tgo-eface-val-compare.lo go-ffi.lo go-fieldtrack.lo \\\n-\tgo-interface-compare.lo go-interface-eface-compare.lo \\\n-\tgo-interface-val-compare.lo go-make-slice.lo go-matherr.lo \\\n-\tgo-memclr.lo go-memcmp.lo go-memequal.lo go-memmove.lo \\\n-\tgo-nanotime.lo go-now.lo go-new.lo go-nosys.lo go-panic.lo \\\n-\tgo-recover.lo go-reflect-call.lo go-runtime-error.lo \\\n-\tgo-setenv.lo go-signal.lo go-strcmp.lo go-strslice.lo \\\n-\tgo-type-complex.lo go-type-eface.lo go-type-float.lo \\\n-\tgo-type-identity.lo go-type-interface.lo go-type-string.lo \\\n+am__objects_5 = go-append.lo go-assert.lo go-breakpoint.lo \\\n+\tgo-caller.lo go-callers.lo go-cdiv.lo go-cgo.lo \\\n+\tgo-construct-map.lo go-copy.lo go-defer.lo \\\n+\tgo-deferred-recover.lo go-ffi.lo go-fieldtrack.lo \\\n+\tgo-make-slice.lo go-matherr.lo go-memclr.lo go-memcmp.lo \\\n+\tgo-memequal.lo go-memmove.lo go-nanotime.lo go-now.lo \\\n+\tgo-new.lo go-nosys.lo go-panic.lo go-recover.lo \\\n+\tgo-reflect-call.lo go-runtime-error.lo go-setenv.lo \\\n+\tgo-signal.lo go-strslice.lo go-type-complex.lo \\\n+\tgo-type-float.lo go-type-identity.lo go-type-string.lo \\\n \tgo-typedesc-equal.lo go-unsafe-new.lo go-unsafe-newarray.lo \\\n \tgo-unsafe-pointer.lo go-unsetenv.lo go-unwind.lo go-varargs.lo \\\n \tenv_posix.lo heapdump.lo mcache.lo mcentral.lo \\\n \t$(am__objects_1) mfixalloc.lo mgc0.lo mheap.lo msize.lo \\\n \tpanic.lo parfor.lo print.lo proc.lo runtime.lo signal_unix.lo \\\n \tthread.lo $(am__objects_2) yield.lo $(am__objects_3) \\\n-\tgo-iface.lo lfstack.lo malloc.lo reflect.lo runtime1.lo \\\n-\tsigqueue.lo $(am__objects_4)\n+\tlfstack.lo malloc.lo runtime1.lo sigqueue.lo $(am__objects_4)\n am_libgo_llgo_la_OBJECTS = $(am__objects_5)\n libgo_llgo_la_OBJECTS = $(am_libgo_llgo_la_OBJECTS)\n libgo_llgo_la_LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) \\\n@@ -832,26 +826,17 @@ toolexeclibgounicode_DATA = \\\n runtime_files = \\\n \truntime/go-append.c \\\n \truntime/go-assert.c \\\n-\truntime/go-assert-interface.c \\\n \truntime/go-breakpoint.c \\\n \truntime/go-caller.c \\\n \truntime/go-callers.c \\\n-\truntime/go-can-convert-interface.c \\\n \truntime/go-cdiv.c \\\n \truntime/go-cgo.c \\\n-\truntime/go-check-interface.c \\\n \truntime/go-construct-map.c \\\n-\truntime/go-convert-interface.c \\\n \truntime/go-copy.c \\\n \truntime/go-defer.c \\\n \truntime/go-deferred-recover.c \\\n-\truntime/go-eface-compare.c \\\n-\truntime/go-eface-val-compare.c \\\n \truntime/go-ffi.c \\\n \truntime/go-fieldtrack.c \\\n-\truntime/go-interface-compare.c \\\n-\truntime/go-interface-eface-compare.c \\\n-\truntime/go-interface-val-compare.c \\\n \truntime/go-make-slice.c \\\n \truntime/go-matherr.c \\\n \truntime/go-memclr.c \\\n@@ -868,13 +853,10 @@ runtime_files = \\\n \truntime/go-runtime-error.c \\\n \truntime/go-setenv.c \\\n \truntime/go-signal.c \\\n-\truntime/go-strcmp.c \\\n \truntime/go-strslice.c \\\n \truntime/go-type-complex.c \\\n-\truntime/go-type-eface.c \\\n \truntime/go-type-float.c \\\n \truntime/go-type-identity.c \\\n-\truntime/go-type-interface.c \\\n \truntime/go-type-string.c \\\n \truntime/go-typedesc-equal.c \\\n \truntime/go-unsafe-new.c \\\n@@ -902,10 +884,8 @@ runtime_files = \\\n \t$(runtime_thread_files) \\\n \truntime/yield.c \\\n \t$(rtems_task_variable_add_file) \\\n-\tgo-iface.c \\\n \tlfstack.c \\\n \tmalloc.c \\\n-\treflect.c \\\n \truntime1.c \\\n \tsigqueue.c \\\n \t$(runtime_getncpu_file)\n@@ -1541,28 +1521,18 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/getncpu-none.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/getncpu-solaris.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-append.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-assert-interface.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-assert.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-breakpoint.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-caller.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-callers.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-can-convert-interface.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-cdiv.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-cgo.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-check-interface.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-construct-map.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-convert-interface.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-copy.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-defer.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-deferred-recover.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-eface-compare.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-eface-val-compare.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-ffi.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-fieldtrack.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-iface.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-interface-compare.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-interface-eface-compare.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-interface-val-compare.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-make-slice.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-matherr.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-memclr.Plo@am__quote@\n@@ -1579,13 +1549,10 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-runtime-error.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-setenv.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-signal.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-strcmp.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-strslice.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-type-complex.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-type-eface.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-type-float.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-type-identity.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-type-interface.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-type-string.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-typedesc-equal.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-unsafe-new.Plo@am__quote@\n@@ -1612,7 +1579,6 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/parfor.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/print.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/proc.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/reflect.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/rtems-task-variable-add.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/runtime.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/runtime1.Plo@am__quote@\n@@ -1700,13 +1666,6 @@ go-assert.lo: runtime/go-assert.c\n @AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n @am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o go-assert.lo `test -f 'runtime/go-assert.c' || echo '$(srcdir)/'`runtime/go-assert.c\n \n-go-assert-interface.lo: runtime/go-assert-interface.c\n-@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT go-assert-interface.lo -MD -MP -MF $(DEPDIR)/go-assert-interface.Tpo -c -o go-assert-interface.lo `test -f 'runtime/go-assert-interface.c' || echo '$(srcdir)/'`runtime/go-assert-interface.c\n-@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/go-assert-interface.Tpo $(DEPDIR)/go-assert-interface.Plo\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='runtime/go-assert-interface.c' object='go-assert-interface.lo' libtool=yes @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o go-assert-interface.lo `test -f 'runtime/go-assert-interface.c' || echo '$(srcdir)/'`runtime/go-assert-interface.c\n-\n go-breakpoint.lo: runtime/go-breakpoint.c\n @am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT go-breakpoint.lo -MD -MP -MF $(DEPDIR)/go-breakpoint.Tpo -c -o go-breakpoint.lo `test -f 'runtime/go-breakpoint.c' || echo '$(srcdir)/'`runtime/go-breakpoint.c\n @am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/go-breakpoint.Tpo $(DEPDIR)/go-breakpoint.Plo\n@@ -1728,13 +1687,6 @@ go-callers.lo: runtime/go-callers.c\n @AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n @am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o go-callers.lo `test -f 'runtime/go-callers.c' || echo '$(srcdir)/'`runtime/go-callers.c\n \n-go-can-convert-interface.lo: runtime/go-can-convert-interface.c\n-@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT go-can-convert-interface.lo -MD -MP -MF $(DEPDIR)/go-can-convert-interface.Tpo -c -o go-can-convert-interface.lo `test -f 'runtime/go-can-convert-interface.c' || echo '$(srcdir)/'`runtime/go-can-convert-interface.c\n-@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/go-can-convert-interface.Tpo $(DEPDIR)/go-can-convert-interface.Plo\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='runtime/go-can-convert-interface.c' object='go-can-convert-interface.lo' libtool=yes @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o go-can-convert-interface.lo `test -f 'runtime/go-can-convert-interface.c' || echo '$(srcdir)/'`runtime/go-can-convert-interface.c\n-\n go-cdiv.lo: runtime/go-cdiv.c\n @am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT go-cdiv.lo -MD -MP -MF $(DEPDIR)/go-cdiv.Tpo -c -o go-cdiv.lo `test -f 'runtime/go-cdiv.c' || echo '$(srcdir)/'`runtime/go-cdiv.c\n @am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/go-cdiv.Tpo $(DEPDIR)/go-cdiv.Plo\n@@ -1749,27 +1701,13 @@ go-cgo.lo: runtime/go-cgo.c\n @AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n @am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o go-cgo.lo `test -f 'runtime/go-cgo.c' || echo '$(srcdir)/'`runtime/go-cgo.c\n \n-go-check-interface.lo: runtime/go-check-interface.c\n-@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT go-check-interface.lo -MD -MP -MF $(DEPDIR)/go-check-interface.Tpo -c -o go-check-interface.lo `test -f 'runtime/go-check-interface.c' || echo '$(srcdir)/'`runtime/go-check-interface.c\n-@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/go-check-interface.Tpo $(DEPDIR)/go-check-interface.Plo\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='runtime/go-check-interface.c' object='go-check-interface.lo' libtool=yes @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o go-check-interface.lo `test -f 'runtime/go-check-interface.c' || echo '$(srcdir)/'`runtime/go-check-interface.c\n-\n go-construct-map.lo: runtime/go-construct-map.c\n @am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT go-construct-map.lo -MD -MP -MF $(DEPDIR)/go-construct-map.Tpo -c -o go-construct-map.lo `test -f 'runtime/go-construct-map.c' || echo '$(srcdir)/'`runtime/go-construct-map.c\n @am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/go-construct-map.Tpo $(DEPDIR)/go-construct-map.Plo\n @AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='runtime/go-construct-map.c' object='go-construct-map.lo' libtool=yes @AMDEPBACKSLASH@\n @AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n @am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o go-construct-map.lo `test -f 'runtime/go-construct-map.c' || echo '$(srcdir)/'`runtime/go-construct-map.c\n \n-go-convert-interface.lo: runtime/go-convert-interface.c\n-@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT go-convert-interface.lo -MD -MP -MF $(DEPDIR)/go-convert-interface.Tpo -c -o go-convert-interface.lo `test -f 'runtime/go-convert-interface.c' || echo '$(srcdir)/'`runtime/go-convert-interface.c\n-@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/go-convert-interface.Tpo $(DEPDIR)/go-convert-interface.Plo\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='runtime/go-convert-interface.c' object='go-convert-interface.lo' libtool=yes @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o go-convert-interface.lo `test -f 'runtime/go-convert-interface.c' || echo '$(srcdir)/'`runtime/go-convert-interface.c\n-\n go-copy.lo: runtime/go-copy.c\n @am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT go-copy.lo -MD -MP -MF $(DEPDIR)/go-copy.Tpo -c -o go-copy.lo `test -f 'runtime/go-copy.c' || echo '$(srcdir)/'`runtime/go-copy.c\n @am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/go-copy.Tpo $(DEPDIR)/go-copy.Plo\n@@ -1791,20 +1729,6 @@ go-deferred-recover.lo: runtime/go-deferred-recover.c\n @AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n @am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o go-deferred-recover.lo `test -f 'runtime/go-deferred-recover.c' || echo '$(srcdir)/'`runtime/go-deferred-recover.c\n \n-go-eface-compare.lo: runtime/go-eface-compare.c\n-@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT go-eface-compare.lo -MD -MP -MF $(DEPDIR)/go-eface-compare.Tpo -c -o go-eface-compare.lo `test -f 'runtime/go-eface-compare.c' || echo '$(srcdir)/'`runtime/go-eface-compare.c\n-@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/go-eface-compare.Tpo $(DEPDIR)/go-eface-compare.Plo\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='runtime/go-eface-compare.c' object='go-eface-compare.lo' libtool=yes @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o go-eface-compare.lo `test -f 'runtime/go-eface-compare.c' || echo '$(srcdir)/'`runtime/go-eface-compare.c\n-\n-go-eface-val-compare.lo: runtime/go-eface-val-compare.c\n-@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT go-eface-val-compare.lo -MD -MP -MF $(DEPDIR)/go-eface-val-compare.Tpo -c -o go-eface-val-compare.lo `test -f 'runtime/go-eface-val-compare.c' || echo '$(srcdir)/'`runtime/go-eface-val-compare.c\n-@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/go-eface-val-compare.Tpo $(DEPDIR)/go-eface-val-compare.Plo\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='runtime/go-eface-val-compare.c' object='go-eface-val-compare.lo' libtool=yes @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o go-eface-val-compare.lo `test -f 'runtime/go-eface-val-compare.c' || echo '$(srcdir)/'`runtime/go-eface-val-compare.c\n-\n go-ffi.lo: runtime/go-ffi.c\n @am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT go-ffi.lo -MD -MP -MF $(DEPDIR)/go-ffi.Tpo -c -o go-ffi.lo `test -f 'runtime/go-ffi.c' || echo '$(srcdir)/'`runtime/go-ffi.c\n @am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/go-ffi.Tpo $(DEPDIR)/go-ffi.Plo\n@@ -1819,27 +1743,6 @@ go-fieldtrack.lo: runtime/go-fieldtrack.c\n @AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n @am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o go-fieldtrack.lo `test -f 'runtime/go-fieldtrack.c' || echo '$(srcdir)/'`runtime/go-fieldtrack.c\n \n-go-interface-compare.lo: runtime/go-interface-compare.c\n-@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT go-interface-compare.lo -MD -MP -MF $(DEPDIR)/go-interface-compare.Tpo -c -o go-interface-compare.lo `test -f 'runtime/go-interface-compare.c' || echo '$(srcdir)/'`runtime/go-interface-compare.c\n-@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/go-interface-compare.Tpo $(DEPDIR)/go-interface-compare.Plo\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='runtime/go-interface-compare.c' object='go-interface-compare.lo' libtool=yes @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o go-interface-compare.lo `test -f 'runtime/go-interface-compare.c' || echo '$(srcdir)/'`runtime/go-interface-compare.c\n-\n-go-interface-eface-compare.lo: runtime/go-interface-eface-compare.c\n-@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT go-interface-eface-compare.lo -MD -MP -MF $(DEPDIR)/go-interface-eface-compare.Tpo -c -o go-interface-eface-compare.lo `test -f 'runtime/go-interface-eface-compare.c' || echo '$(srcdir)/'`runtime/go-interface-eface-compare.c\n-@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/go-interface-eface-compare.Tpo $(DEPDIR)/go-interface-eface-compare.Plo\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='runtime/go-interface-eface-compare.c' object='go-interface-eface-compare.lo' libtool=yes @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o go-interface-eface-compare.lo `test -f 'runtime/go-interface-eface-compare.c' || echo '$(srcdir)/'`runtime/go-interface-eface-compare.c\n-\n-go-interface-val-compare.lo: runtime/go-interface-val-compare.c\n-@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT go-interface-val-compare.lo -MD -MP -MF $(DEPDIR)/go-interface-val-compare.Tpo -c -o go-interface-val-compare.lo `test -f 'runtime/go-interface-val-compare.c' || echo '$(srcdir)/'`runtime/go-interface-val-compare.c\n-@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/go-interface-val-compare.Tpo $(DEPDIR)/go-interface-val-compare.Plo\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='runtime/go-interface-val-compare.c' object='go-interface-val-compare.lo' libtool=yes @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o go-interface-val-compare.lo `test -f 'runtime/go-interface-val-compare.c' || echo '$(srcdir)/'`runtime/go-interface-val-compare.c\n-\n go-make-slice.lo: runtime/go-make-slice.c\n @am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT go-make-slice.lo -MD -MP -MF $(DEPDIR)/go-make-slice.Tpo -c -o go-make-slice.lo `test -f 'runtime/go-make-slice.c' || echo '$(srcdir)/'`runtime/go-make-slice.c\n @am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/go-make-slice.Tpo $(DEPDIR)/go-make-slice.Plo\n@@ -1952,13 +1855,6 @@ go-signal.lo: runtime/go-signal.c\n @AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n @am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o go-signal.lo `test -f 'runtime/go-signal.c' || echo '$(srcdir)/'`runtime/go-signal.c\n \n-go-strcmp.lo: runtime/go-strcmp.c\n-@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT go-strcmp.lo -MD -MP -MF $(DEPDIR)/go-strcmp.Tpo -c -o go-strcmp.lo `test -f 'runtime/go-strcmp.c' || echo '$(srcdir)/'`runtime/go-strcmp.c\n-@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/go-strcmp.Tpo $(DEPDIR)/go-strcmp.Plo\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='runtime/go-strcmp.c' object='go-strcmp.lo' libtool=yes @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o go-strcmp.lo `test -f 'runtime/go-strcmp.c' || echo '$(srcdir)/'`runtime/go-strcmp.c\n-\n go-strslice.lo: runtime/go-strslice.c\n @am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT go-strslice.lo -MD -MP -MF $(DEPDIR)/go-strslice.Tpo -c -o go-strslice.lo `test -f 'runtime/go-strslice.c' || echo '$(srcdir)/'`runtime/go-strslice.c\n @am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/go-strslice.Tpo $(DEPDIR)/go-strslice.Plo\n@@ -1973,13 +1869,6 @@ go-type-complex.lo: runtime/go-type-complex.c\n @AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n @am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o go-type-complex.lo `test -f 'runtime/go-type-complex.c' || echo '$(srcdir)/'`runtime/go-type-complex.c\n \n-go-type-eface.lo: runtime/go-type-eface.c\n-@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT go-type-eface.lo -MD -MP -MF $(DEPDIR)/go-type-eface.Tpo -c -o go-type-eface.lo `test -f 'runtime/go-type-eface.c' || echo '$(srcdir)/'`runtime/go-type-eface.c\n-@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/go-type-eface.Tpo $(DEPDIR)/go-type-eface.Plo\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='runtime/go-type-eface.c' object='go-type-eface.lo' libtool=yes @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o go-type-eface.lo `test -f 'runtime/go-type-eface.c' || echo '$(srcdir)/'`runtime/go-type-eface.c\n-\n go-type-float.lo: runtime/go-type-float.c\n @am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT go-type-float.lo -MD -MP -MF $(DEPDIR)/go-type-float.Tpo -c -o go-type-float.lo `test -f 'runtime/go-type-float.c' || echo '$(srcdir)/'`runtime/go-type-float.c\n @am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/go-type-float.Tpo $(DEPDIR)/go-type-float.Plo\n@@ -1994,13 +1883,6 @@ go-type-identity.lo: runtime/go-type-identity.c\n @AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n @am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o go-type-identity.lo `test -f 'runtime/go-type-identity.c' || echo '$(srcdir)/'`runtime/go-type-identity.c\n \n-go-type-interface.lo: runtime/go-type-interface.c\n-@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT go-type-interface.lo -MD -MP -MF $(DEPDIR)/go-type-interface.Tpo -c -o go-type-interface.lo `test -f 'runtime/go-type-interface.c' || echo '$(srcdir)/'`runtime/go-type-interface.c\n-@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/go-type-interface.Tpo $(DEPDIR)/go-type-interface.Plo\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='runtime/go-type-interface.c' object='go-type-interface.lo' libtool=yes @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o go-type-interface.lo `test -f 'runtime/go-type-interface.c' || echo '$(srcdir)/'`runtime/go-type-interface.c\n-\n go-type-string.lo: runtime/go-type-string.c\n @am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT go-type-string.lo -MD -MP -MF $(DEPDIR)/go-type-string.Tpo -c -o go-type-string.lo `test -f 'runtime/go-type-string.c' || echo '$(srcdir)/'`runtime/go-type-string.c\n @am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/go-type-string.Tpo $(DEPDIR)/go-type-string.Plo\n@@ -3369,10 +3251,6 @@ malloc.c: $(srcdir)/runtime/malloc.goc goc2c\n \t./goc2c $< > $@.tmp\n \tmv -f $@.tmp $@\n \n-reflect.c: $(srcdir)/runtime/reflect.goc goc2c\n-\t./goc2c $< > $@.tmp\n-\tmv -f $@.tmp $@\n-\n runtime1.c: $(srcdir)/runtime/runtime1.goc goc2c\n \t./goc2c $< > $@.tmp\n \tmv -f $@.tmp $@"}, {"sha": "8f7c3c0531c200cb4a4e2c3c801a1d0ae50925f2", "filename": "libgo/go/runtime/alg.go", "status": "added", "additions": 204, "deletions": 0, "changes": 204, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b752cfac4ecf8b620726bfcd703844ebfaca6ea/libgo%2Fgo%2Fruntime%2Falg.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b752cfac4ecf8b620726bfcd703844ebfaca6ea/libgo%2Fgo%2Fruntime%2Falg.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Falg.go?ref=6b752cfac4ecf8b620726bfcd703844ebfaca6ea", "patch": "@@ -0,0 +1,204 @@\n+// Copyright 2014 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package runtime\n+\n+import (\n+\t\"runtime/internal/sys\"\n+\t\"unsafe\"\n+)\n+\n+// For gccgo, use go:linkname to rename compiler-called functions to\n+// themselves, so that the compiler will export them.\n+//\n+//go:linkname interhash runtime.interhash\n+//go:linkname nilinterhash runtime.nilinterhash\n+//go:linkname interequal runtime.interequal\n+//go:linkname nilinterequal runtime.nilinterequal\n+//go:linkname efaceeq runtime.efaceeq\n+//go:linkname ifaceeq runtime.ifaceeq\n+//go:linkname ifacevaleq runtime.ifacevaleq\n+//go:linkname ifaceefaceeq runtime.ifaceefaceeq\n+//go:linkname efacevaleq runtime.efacevaleq\n+//go:linkname eqstring runtime.eqstring\n+//go:linkname cmpstring runtime.cmpstring\n+\n+const (\n+\tc0 = uintptr((8-sys.PtrSize)/4*2860486313 + (sys.PtrSize-4)/4*33054211828000289)\n+\tc1 = uintptr((8-sys.PtrSize)/4*3267000013 + (sys.PtrSize-4)/4*23344194077549503)\n+)\n+\n+func interhash(p unsafe.Pointer, h uintptr, size uintptr) uintptr {\n+\ta := (*iface)(p)\n+\ttab := a.tab\n+\tif tab == nil {\n+\t\treturn h\n+\t}\n+\tt := *(**_type)(tab)\n+\tfn := t.hashfn\n+\tif fn == nil {\n+\t\tpanic(errorString(\"hash of unhashable type \" + *t.string))\n+\t}\n+\tif isDirectIface(t) {\n+\t\treturn c1 * fn(unsafe.Pointer(&a.data), h^c0, t.size)\n+\t} else {\n+\t\treturn c1 * fn(a.data, h^c0, t.size)\n+\t}\n+}\n+\n+func nilinterhash(p unsafe.Pointer, h uintptr, size uintptr) uintptr {\n+\ta := (*eface)(p)\n+\tt := a._type\n+\tif t == nil {\n+\t\treturn h\n+\t}\n+\tfn := t.hashfn\n+\tif fn == nil {\n+\t\tpanic(errorString(\"hash of unhashable type \" + *t.string))\n+\t}\n+\tif isDirectIface(t) {\n+\t\treturn c1 * fn(unsafe.Pointer(&a.data), h^c0, t.size)\n+\t} else {\n+\t\treturn c1 * fn(a.data, h^c0, t.size)\n+\t}\n+}\n+\n+func interequal(p, q unsafe.Pointer, size uintptr) bool {\n+\treturn ifaceeq(*(*iface)(p), *(*iface)(q))\n+}\n+\n+func nilinterequal(p, q unsafe.Pointer, size uintptr) bool {\n+\treturn efaceeq(*(*eface)(p), *(*eface)(q))\n+}\n+\n+func efaceeq(x, y eface) bool {\n+\tt := x._type\n+\tif !eqtype(t, y._type) {\n+\t\treturn false\n+\t}\n+\tif t == nil {\n+\t\treturn true\n+\t}\n+\teq := t.equalfn\n+\tif eq == nil {\n+\t\tpanic(errorString(\"comparing uncomparable type \" + *t.string))\n+\t}\n+\tif isDirectIface(t) {\n+\t\treturn x.data == y.data\n+\t}\n+\treturn eq(x.data, y.data, t.size)\n+}\n+\n+func ifaceeq(x, y iface) bool {\n+\txtab := x.tab\n+\tif xtab == nil && y.tab == nil {\n+\t\treturn true\n+\t}\n+\tif xtab == nil || y.tab == nil {\n+\t\treturn false\n+\t}\n+\tt := *(**_type)(xtab)\n+\tif !eqtype(t, *(**_type)(y.tab)) {\n+\t\treturn false\n+\t}\n+\teq := t.equalfn\n+\tif eq == nil {\n+\t\tpanic(errorString(\"comparing uncomparable type \" + *t.string))\n+\t}\n+\tif isDirectIface(t) {\n+\t\treturn x.data == y.data\n+\t}\n+\treturn eq(x.data, y.data, t.size)\n+}\n+\n+func ifacevaleq(x iface, t *_type, p unsafe.Pointer) bool {\n+\tif x.tab == nil {\n+\t\treturn false\n+\t}\n+\txt := *(**_type)(x.tab)\n+\tif !eqtype(xt, t) {\n+\t\treturn false\n+\t}\n+\teq := t.equalfn\n+\tif eq == nil {\n+\t\tpanic(errorString(\"comparing uncomparable type \" + *t.string))\n+\t}\n+\tif isDirectIface(t) {\n+\t\treturn x.data == p\n+\t}\n+\treturn eq(x.data, p, t.size)\n+}\n+\n+func ifaceefaceeq(x iface, y eface) bool {\n+\tif x.tab == nil && y._type == nil {\n+\t\treturn true\n+\t}\n+\tif x.tab == nil || y._type == nil {\n+\t\treturn false\n+\t}\n+\txt := *(**_type)(x.tab)\n+\tif !eqtype(xt, y._type) {\n+\t\treturn false\n+\t}\n+\teq := xt.equalfn\n+\tif eq == nil {\n+\t\tpanic(errorString(\"comparing uncomparable type \" + *xt.string))\n+\t}\n+\tif isDirectIface(xt) {\n+\t\treturn x.data == y.data\n+\t}\n+\treturn eq(x.data, y.data, xt.size)\n+}\n+\n+func efacevaleq(x eface, t *_type, p unsafe.Pointer) bool {\n+\tif x._type == nil {\n+\t\treturn false\n+\t}\n+\tif !eqtype(x._type, t) {\n+\t\treturn false\n+\t}\n+\teq := t.equalfn\n+\tif eq == nil {\n+\t\tpanic(errorString(\"comparing uncomparable type \" + *t.string))\n+\t}\n+\tif isDirectIface(t) {\n+\t\treturn x.data == p\n+\t}\n+\treturn eq(x.data, p, t.size)\n+}\n+\n+func eqstring(x, y string) bool {\n+\ta := stringStructOf(&x)\n+\tb := stringStructOf(&y)\n+\tif a.len != b.len {\n+\t\treturn false\n+\t}\n+\treturn memcmp(unsafe.Pointer(a.str), unsafe.Pointer(b.str), uintptr(a.len)) == 0\n+}\n+\n+func cmpstring(x, y string) int {\n+\ta := stringStructOf(&x)\n+\tb := stringStructOf(&y)\n+\tl := a.len\n+\tif l > b.len {\n+\t\tl = b.len\n+\t}\n+\ti := memcmp(unsafe.Pointer(a.str), unsafe.Pointer(b.str), uintptr(l))\n+\tif i != 0 {\n+\t\treturn int(i)\n+\t}\n+\tif a.len < b.len {\n+\t\treturn -1\n+\t} else if a.len > b.len {\n+\t\treturn 1\n+\t}\n+\treturn 0\n+}\n+\n+// Force the creation of function descriptors for equality and hash\n+// functions.  These will be referenced directly by the compiler.\n+var _ = interhash\n+var _ = interequal\n+var _ = nilinterhash\n+var _ = nilinterequal"}, {"sha": "5274734ba8f49a4a7ee562e7eec18b954cbf704e", "filename": "libgo/go/runtime/iface.go", "status": "added", "additions": 334, "deletions": 0, "changes": 334, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b752cfac4ecf8b620726bfcd703844ebfaca6ea/libgo%2Fgo%2Fruntime%2Fiface.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b752cfac4ecf8b620726bfcd703844ebfaca6ea/libgo%2Fgo%2Fruntime%2Fiface.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fiface.go?ref=6b752cfac4ecf8b620726bfcd703844ebfaca6ea", "patch": "@@ -0,0 +1,334 @@\n+// Copyright 2014 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package runtime\n+\n+import (\n+\t\"unsafe\"\n+)\n+\n+// For gccgo, use go:linkname to rename compiler-called functions to\n+// themselves, so that the compiler will export them.\n+//\n+//go:linkname requireitab runtime.requireitab\n+//go:linkname assertitab runtime.assertitab\n+//go:linkname assertI2T runtime.assertI2T\n+//go:linkname ifacetypeeq runtime.ifacetypeeq\n+//go:linkname efacetype runtime.efacetype\n+//go:linkname ifacetype runtime.ifacetype\n+//go:linkname ifaceE2E2 runtime.ifaceE2E2\n+//go:linkname ifaceI2E2 runtime.ifaceI2E2\n+//go:linkname ifaceE2I2 runtime.ifaceE2I2\n+//go:linkname ifaceI2I2 runtime.ifaceI2I2\n+//go:linkname ifaceE2T2P runtime.ifaceE2T2P\n+//go:linkname ifaceI2T2P runtime.ifaceI2T2P\n+//go:linkname ifaceE2T2 runtime.ifaceE2T2\n+//go:linkname ifaceI2T2 runtime.ifaceI2T2\n+//go:linkname ifaceT2Ip runtime.ifaceT2Ip\n+// Temporary for C code to call:\n+//go:linkname getitab runtime.getitab\n+\n+// The gccgo itab structure is different than the gc one.\n+//\n+// Both gccgo and gc represent empty interfaces the same way:\n+// a two field struct, where the first field points to a type descriptor\n+// (a *_type) and the second field is the data pointer.\n+//\n+// Non-empty interfaces are also two-field structs, and the second\n+// field is the data pointer. However, for gccgo, the first field, the\n+// itab field, is different. The itab field points to the interface\n+// method table, which is the implemention of a specific interface\n+// type for a specific dynamic non-interface type.  An interface\n+// method table is a list of pointer values. The first pointer is the\n+// type descriptor (a *_type) for the dynamic type. The subsequent\n+// pointers are pointers to function code, which implement the methods\n+// required by the interface. The pointers are sorted by name.\n+//\n+// The method pointers in the itab are C function pointers, not Go\n+// function pointers; they may be called directly, and they have no\n+// closures. The receiver is always passed as a pointer, and it is\n+// always the same pointer stored in the interface value. A value\n+// method starts by copying the receiver value out of the pointer into\n+// a local variable.\n+//\n+// A method call on an interface value is by definition calling a\n+// method at a known index m in the list of methods. Given a non-empty\n+// interface value i, the call i.m(args) looks like\n+//     i.itab[m+1](i.iface, args)\n+\n+// Both an empty interface and a non-empty interface have a data\n+// pointer field. The meaning of this field is determined by the\n+// kindDirectIface bit in the `kind` field of the type descriptor of\n+// the value stored in the interface. If kindDirectIface is set, then\n+// the data pointer field in the interface value is exactly the value\n+// stored in the interface. Otherwise, the data pointer field is a\n+// pointer to memory that holds the value. It follows from this that\n+// kindDirectIface can only be set for a type whose representation is\n+// simply a pointer. In the current gccgo implementation, this is set\n+// only for pointer types (including unsafe.Pointer). In the future it\n+// could also be set for other types: channels, maps, functions,\n+// single-field structs and single-element arrays whose single field\n+// is simply a pointer.\n+\n+// For a nil interface value both fields in the interface struct are nil.\n+\n+// Return the interface method table for a value of type rhs converted\n+// to an interface of type lhs.\n+func getitab(lhs, rhs *_type, canfail bool) unsafe.Pointer {\n+\tif rhs == nil {\n+\t\treturn nil\n+\t}\n+\n+\tif lhs.kind&kindMask != kindInterface {\n+\t\tthrow(\"getitab called for non-interface type\")\n+\t}\n+\n+\tlhsi := (*interfacetype)(unsafe.Pointer(lhs))\n+\n+\tif len(lhsi.methods) == 0 {\n+\t\tthrow(\"getitab called for empty interface type\")\n+\t}\n+\n+\tif rhs.uncommontype == nil || len(rhs.methods) == 0 {\n+\t\tif canfail {\n+\t\t\treturn nil\n+\t\t}\n+\t\tpanic(&TypeAssertionError{\"\", *rhs.string, *lhs.string, *lhsi.methods[0].name})\n+\t}\n+\n+\tmethods := make([]unsafe.Pointer, len(lhsi.methods)+1)\n+\tmethods[0] = unsafe.Pointer(rhs)\n+\n+\tri := 0\n+\tfor li := range lhsi.methods {\n+\t\tlhsMethod := &lhsi.methods[li]\n+\t\tvar rhsMethod *method\n+\n+\t\tfor {\n+\t\t\tif ri >= len(rhs.methods) {\n+\t\t\t\tif canfail {\n+\t\t\t\t\treturn nil\n+\t\t\t\t}\n+\t\t\t\tpanic(&TypeAssertionError{\"\", *rhs.string, *lhs.string, *lhsMethod.name})\n+\t\t\t}\n+\n+\t\t\trhsMethod = &rhs.methods[ri]\n+\t\t\tif (lhsMethod.name == rhsMethod.name || *lhsMethod.name == *rhsMethod.name) &&\n+\t\t\t\t(lhsMethod.pkgPath == rhsMethod.pkgPath || *lhsMethod.pkgPath == *rhsMethod.pkgPath) {\n+\t\t\t\tbreak\n+\t\t\t}\n+\n+\t\t\tri++\n+\t\t}\n+\n+\t\tif !eqtype(lhsMethod.typ, rhsMethod.mtyp) {\n+\t\t\tif canfail {\n+\t\t\t\treturn nil\n+\t\t\t}\n+\t\t\tpanic(&TypeAssertionError{\"\", *rhs.string, *lhs.string, *lhsMethod.name})\n+\t\t}\n+\n+\t\tmethods[li+1] = unsafe.Pointer(rhsMethod.tfn)\n+\t\tri++\n+\t}\n+\n+\treturn unsafe.Pointer(&methods[0])\n+}\n+\n+// Return the interface method table for a value of type rhs converted\n+// to an interface of type lhs.  Panics if the conversion is impossible.\n+func requireitab(lhs, rhs *_type) unsafe.Pointer {\n+\treturn getitab(lhs, rhs, false)\n+}\n+\n+// Return the interface method table for a value of type rhs converted\n+// to an interface of type lhs.  Panics if the conversion is\n+// impossible or if the rhs type is nil.\n+func assertitab(lhs, rhs *_type) unsafe.Pointer {\n+\tif rhs == nil {\n+\t\tpanic(&TypeAssertionError{\"\", \"\", *lhs.string, \"\"})\n+\t}\n+\n+\tif lhs.kind&kindMask != kindInterface {\n+\t\tthrow(\"assertitab called for non-interface type\")\n+\t}\n+\n+\tlhsi := (*interfacetype)(unsafe.Pointer(lhs))\n+\n+\tif len(lhsi.methods) == 0 {\n+\t\treturn unsafe.Pointer(rhs)\n+\t}\n+\n+\treturn getitab(lhs, rhs, false)\n+}\n+\n+// Check whether an interface type may be converted to a non-interface\n+// type, panicing if not.\n+func assertI2T(lhs, rhs, inter *_type) {\n+\tif rhs == nil {\n+\t\tpanic(&TypeAssertionError{\"\", \"\", *lhs.string, \"\"})\n+\t}\n+\tif !eqtype(lhs, rhs) {\n+\t\tpanic(&TypeAssertionError{*inter.string, *rhs.string, *lhs.string, \"\"})\n+\t}\n+}\n+\n+// Compare two type descriptors for equality.\n+func ifacetypeeq(a, b *_type) bool {\n+\treturn eqtype(a, b)\n+}\n+\n+// Return the type descriptor of an empty interface.\n+// FIXME: This should be inlined by the compiler.\n+func efacetype(e eface) *_type {\n+\treturn e._type\n+}\n+\n+// Return the type descriptor of a non-empty interface.\n+// FIXME: This should be inlined by the compiler.\n+func ifacetype(i iface) *_type {\n+\tif i.tab == nil {\n+\t\treturn nil\n+\t}\n+\treturn *(**_type)(i.tab)\n+}\n+\n+// Convert an empty interface to an empty interface, for a comma-ok\n+// type assertion.\n+func ifaceE2E2(e eface) (eface, bool) {\n+\treturn e, e._type != nil\n+}\n+\n+// Convert a non-empty interface to an empty interface, for a comma-ok\n+// type assertion.\n+func ifaceI2E2(i iface) (eface, bool) {\n+\tif i.tab == nil {\n+\t\treturn eface{nil, nil}, false\n+\t} else {\n+\t\treturn eface{*(**_type)(i.tab), i.data}, true\n+\t}\n+}\n+\n+// Convert an empty interface to a non-empty interface, for a comma-ok\n+// type assertion.\n+func ifaceE2I2(inter *_type, e eface) (iface, bool) {\n+\tif e._type == nil {\n+\t\treturn iface{nil, nil}, false\n+\t} else {\n+\t\titab := getitab(inter, e._type, true)\n+\t\tif itab == nil {\n+\t\t\treturn iface{nil, nil}, false\n+\t\t} else {\n+\t\t\treturn iface{itab, e.data}, true\n+\t\t}\n+\t}\n+}\n+\n+// Convert a non-empty interface to a non-empty interface, for a\n+// comma-ok type assertion.\n+func ifaceI2I2(inter *_type, i iface) (iface, bool) {\n+\tif i.tab == nil {\n+\t\treturn iface{nil, nil}, false\n+\t} else {\n+\t\titab := getitab(inter, *(**_type)(i.tab), true)\n+\t\tif itab == nil {\n+\t\t\treturn iface{nil, nil}, false\n+\t\t} else {\n+\t\t\treturn iface{itab, i.data}, true\n+\t\t}\n+\t}\n+}\n+\n+// Convert an empty interface to a pointer non-interface type.\n+func ifaceE2T2P(t *_type, e eface) (unsafe.Pointer, bool) {\n+\tif !eqtype(t, e._type) {\n+\t\treturn nil, false\n+\t} else {\n+\t\treturn e.data, true\n+\t}\n+}\n+\n+// Convert a non-empty interface to a pointer non-interface type.\n+func ifaceI2T2P(t *_type, i iface) (unsafe.Pointer, bool) {\n+\tif i.tab == nil || !eqtype(t, *(**_type)(i.tab)) {\n+\t\treturn nil, false\n+\t} else {\n+\t\treturn i.data, true\n+\t}\n+}\n+\n+// Convert an empty interface to a non-pointer non-interface type.\n+func ifaceE2T2(t *_type, e eface, ret unsafe.Pointer) bool {\n+\tif !eqtype(t, e._type) {\n+\t\tmemclr(ret, t.size)\n+\t\treturn false\n+\t} else {\n+\t\ttypedmemmove(t, ret, e.data)\n+\t\treturn true\n+\t}\n+}\n+\n+// Convert a non-empty interface to a non-pointer non-interface type.\n+func ifaceI2T2(t *_type, i iface, ret unsafe.Pointer) bool {\n+\tif i.tab == nil || !eqtype(t, *(**_type)(i.tab)) {\n+\t\tmemclr(ret, t.size)\n+\t\treturn false\n+\t} else {\n+\t\ttypedmemmove(t, ret, i.data)\n+\t\treturn true\n+\t}\n+}\n+\n+// Return whether we can convert a type to an interface type.\n+func ifaceT2Ip(to, from *_type) bool {\n+\tif from == nil {\n+\t\treturn false\n+\t}\n+\n+\tif to.kind&kindMask != kindInterface {\n+\t\tthrow(\"ifaceT2Ip called with non-interface type\")\n+\t}\n+\ttoi := (*interfacetype)(unsafe.Pointer(to))\n+\n+\tif from.uncommontype == nil || len(from.methods) == 0 {\n+\t\treturn len(toi.methods) == 0\n+\t}\n+\n+\tri := 0\n+\tfor li := range toi.methods {\n+\t\ttoMethod := &toi.methods[li]\n+\t\tvar fromMethod *method\n+\t\tfor {\n+\t\t\tif ri >= len(from.methods) {\n+\t\t\t\treturn false\n+\t\t\t}\n+\n+\t\t\tfromMethod = &from.methods[ri]\n+\t\t\tif (toMethod.name == fromMethod.name || *toMethod.name == *fromMethod.name) &&\n+\t\t\t\t(toMethod.pkgPath == fromMethod.pkgPath || *toMethod.pkgPath == *fromMethod.pkgPath) {\n+\t\t\t\tbreak\n+\t\t\t}\n+\n+\t\t\tri++\n+\t\t}\n+\n+\t\tif !eqtype(fromMethod.mtyp, toMethod.typ) {\n+\t\t\treturn false\n+\t\t}\n+\n+\t\tri++\n+\t}\n+\n+\treturn true\n+}\n+\n+//go:linkname reflect_ifaceE2I reflect.ifaceE2I\n+func reflect_ifaceE2I(inter *interfacetype, e eface, dst *iface) {\n+\tt := e._type\n+\tif t == nil {\n+\t\tpanic(TypeAssertionError{\"\", \"\", *inter.typ.string, \"\"})\n+\t}\n+\tdst.tab = requireitab((*_type)(unsafe.Pointer(inter)), t)\n+\tdst.data = e.data\n+}"}, {"sha": "37ade7d45b38e106af32f444281edf4f07ffe0c0", "filename": "libgo/go/runtime/runtime2.go", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b752cfac4ecf8b620726bfcd703844ebfaca6ea/libgo%2Fgo%2Fruntime%2Fruntime2.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b752cfac4ecf8b620726bfcd703844ebfaca6ea/libgo%2Fgo%2Fruntime%2Fruntime2.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fruntime2.go?ref=6b752cfac4ecf8b620726bfcd703844ebfaca6ea", "patch": "@@ -138,11 +138,15 @@ type funcval struct {\n \t// variable-size, fn-specific data here\n }\n \n+// The representation of a non-empty interface.\n+// See comment in iface.go for more details on this struct.\n type iface struct {\n \ttab  unsafe.Pointer\n \tdata unsafe.Pointer\n }\n \n+// The representation of an empty interface.\n+// See comment in iface.go for more details on this struct.\n type eface struct {\n \t_type *_type\n \tdata  unsafe.Pointer"}, {"sha": "5924ee63dc7c680331851a576abca967556e15c7", "filename": "libgo/go/runtime/stubs.go", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b752cfac4ecf8b620726bfcd703844ebfaca6ea/libgo%2Fgo%2Fruntime%2Fstubs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b752cfac4ecf8b620726bfcd703844ebfaca6ea/libgo%2Fgo%2Fruntime%2Fstubs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fstubs.go?ref=6b752cfac4ecf8b620726bfcd703844ebfaca6ea", "patch": "@@ -73,7 +73,6 @@ func reflect_memclr(ptr unsafe.Pointer, n uintptr) {\n }\n \n // memmove copies n bytes from \"from\" to \"to\".\n-// in memmove_*.s\n //go:noescape\n func memmove(to, from unsafe.Pointer, n uintptr)\n \n@@ -82,6 +81,10 @@ func reflect_memmove(to, from unsafe.Pointer, n uintptr) {\n \tmemmove(to, from, n)\n }\n \n+//go:noescape\n+//extern __builtin_memcmp\n+func memcmp(a, b unsafe.Pointer, size uintptr) int32\n+\n // exported value for testing\n var hashLoad = loadFactor\n \n@@ -466,3 +469,8 @@ func setMaxThreads(in int) (out int) {\n func atomicstorep(ptr unsafe.Pointer, new unsafe.Pointer) {\n \tatomic.StorepNoWB(noescape(ptr), new)\n }\n+\n+// Temporary for gccgo until we port mbarrier.go\n+func writebarrierptr(dst *uintptr, src uintptr) {\n+\t*dst = src\n+}"}, {"sha": "4751a594a59aa5aa58693da583a2e8688fab909c", "filename": "libgo/go/runtime/type.go", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b752cfac4ecf8b620726bfcd703844ebfaca6ea/libgo%2Fgo%2Fruntime%2Ftype.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b752cfac4ecf8b620726bfcd703844ebfaca6ea/libgo%2Fgo%2Fruntime%2Ftype.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Ftype.go?ref=6b752cfac4ecf8b620726bfcd703844ebfaca6ea", "patch": "@@ -25,6 +25,22 @@ type _type struct {\n \tptrToThis *_type\n }\n \n+// Return whether two type descriptors are equal.\n+// This is gccgo-specific, as gccgo, unlike gc, permits multiple\n+// independent descriptors for a single type.\n+func eqtype(t1, t2 *_type) bool {\n+\tswitch {\n+\tcase t1 == t2:\n+\t\treturn true\n+\tcase t1 == nil || t2 == nil:\n+\t\treturn false\n+\tcase t1.kind != t2.kind || t1.hash != t2.hash:\n+\t\treturn false\n+\tdefault:\n+\t\treturn *t1.string == *t2.string\n+\t}\n+}\n+\n type method struct {\n \tname    *string\n \tpkgPath *string"}, {"sha": "427916f8c420527675127e7b637e7f662ffa88c2", "filename": "libgo/runtime/go-assert-interface.c", "status": "removed", "additions": 0, "deletions": 45, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fceabe505cf0dc7030602e582fadadcce73dd6de/libgo%2Fruntime%2Fgo-assert-interface.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fceabe505cf0dc7030602e582fadadcce73dd6de/libgo%2Fruntime%2Fgo-assert-interface.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-assert-interface.c?ref=fceabe505cf0dc7030602e582fadadcce73dd6de", "patch": "@@ -1,45 +0,0 @@\n-/* go-assert-interface.c -- interface type assertion for Go.\n-\n-   Copyright 2010 The Go Authors. All rights reserved.\n-   Use of this source code is governed by a BSD-style\n-   license that can be found in the LICENSE file.  */\n-\n-#include \"runtime.h\"\n-#include \"go-alloc.h\"\n-#include \"go-assert.h\"\n-#include \"go-panic.h\"\n-#include \"go-type.h\"\n-#include \"interface.h\"\n-\n-/* This is called by the compiler to implement a type assertion from\n-   one interface type to another.  This returns the value that should\n-   go in the first field of the result tuple.  The result may be an\n-   empty or a non-empty interface.  */\n-\n-const void *\n-__go_assert_interface (const struct __go_type_descriptor *lhs_descriptor,\n-\t\t       const struct __go_type_descriptor *rhs_descriptor)\n-{\n-  const struct __go_interface_type *lhs_interface;\n-\n-  if (rhs_descriptor == NULL)\n-    {\n-      struct __go_empty_interface panic_arg;\n-\n-      /* A type assertion is not permitted with a nil interface.  */\n-\n-      runtime_newTypeAssertionError (NULL, NULL, lhs_descriptor->__reflection,\n-\t\t\t\t     NULL, &panic_arg);\n-      __go_panic (panic_arg);\n-    }\n-\n-  /* A type assertion to an empty interface just returns the object\n-     descriptor.  */\n-\n-  __go_assert ((lhs_descriptor->__code & GO_CODE_MASK) == GO_INTERFACE);\n-  lhs_interface = (const struct __go_interface_type *) lhs_descriptor;\n-  if (lhs_interface->__methods.__count == 0)\n-    return rhs_descriptor;\n-\n-  return __go_convert_interface_2 (lhs_descriptor, rhs_descriptor, 0);\n-}"}, {"sha": "aac889d346d457684c15afb591a2bd379818cf1d", "filename": "libgo/runtime/go-can-convert-interface.c", "status": "removed", "additions": 0, "deletions": 78, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fceabe505cf0dc7030602e582fadadcce73dd6de/libgo%2Fruntime%2Fgo-can-convert-interface.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fceabe505cf0dc7030602e582fadadcce73dd6de/libgo%2Fruntime%2Fgo-can-convert-interface.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-can-convert-interface.c?ref=fceabe505cf0dc7030602e582fadadcce73dd6de", "patch": "@@ -1,78 +0,0 @@\n-/* go-can-convert-interface.c -- can we convert to an interface?\n-\n-   Copyright 2009 The Go Authors. All rights reserved.\n-   Use of this source code is governed by a BSD-style\n-   license that can be found in the LICENSE file.  */\n-\n-#include \"runtime.h\"\n-#include \"go-assert.h\"\n-#include \"go-string.h\"\n-#include \"go-type.h\"\n-#include \"interface.h\"\n-\n-/* Return whether we can convert from the type in FROM_DESCRIPTOR to\n-   the interface in TO_DESCRIPTOR.  This is used for type\n-   switches.  */\n-\n-_Bool\n-__go_can_convert_to_interface (\n-    const struct __go_type_descriptor *to_descriptor,\n-    const struct __go_type_descriptor *from_descriptor)\n-{\n-  const struct __go_interface_type *to_interface;\n-  int to_method_count;\n-  const struct __go_interface_method *to_method;\n-  const struct __go_uncommon_type *from_uncommon;\n-  int from_method_count;\n-  const struct __go_method *from_method;\n-  int i;\n-\n-  /* In a type switch FROM_DESCRIPTOR can be NULL.  */\n-  if (from_descriptor == NULL)\n-    return 0;\n-\n-  __go_assert ((to_descriptor->__code & GO_CODE_MASK) == GO_INTERFACE);\n-  to_interface = (const struct __go_interface_type *) to_descriptor;\n-  to_method_count = to_interface->__methods.__count;\n-  to_method = ((const struct __go_interface_method *)\n-\t       to_interface->__methods.__values);\n-\n-  from_uncommon = from_descriptor->__uncommon;\n-  if (from_uncommon == NULL)\n-    {\n-      from_method_count = 0;\n-      from_method = NULL;\n-    }\n-  else\n-    {\n-      from_method_count = from_uncommon->__methods.__count;\n-      from_method = ((const struct __go_method *)\n-\t\t     from_uncommon->__methods.__values);\n-    }\n-\n-  for (i = 0; i < to_method_count; ++i)\n-    {\n-      while (from_method_count > 0\n-\t     && (!__go_ptr_strings_equal (from_method->__name,\n-\t\t\t\t\t  to_method->__name)\n-\t\t || !__go_ptr_strings_equal (from_method->__pkg_path,\n-\t\t\t\t\t     to_method->__pkg_path)))\n-\t{\n-\t  ++from_method;\n-\t  --from_method_count;\n-\t}\n-\n-      if (from_method_count == 0)\n-\treturn 0;\n-\n-      if (!__go_type_descriptors_equal (from_method->__mtype,\n-\t\t\t\t\tto_method->__type))\n-\treturn 0;\n-\n-      ++to_method;\n-      ++from_method;\n-      --from_method_count;\n-    }\n-\n-  return 1;\n-}"}, {"sha": "88b3f1e83e1f413bd6ba01058284002ac92b10d1", "filename": "libgo/runtime/go-cgo.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b752cfac4ecf8b620726bfcd703844ebfaca6ea/libgo%2Fruntime%2Fgo-cgo.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b752cfac4ecf8b620726bfcd703844ebfaca6ea/libgo%2Fruntime%2Fgo-cgo.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-cgo.c?ref=6b752cfac4ecf8b620726bfcd703844ebfaca6ea", "patch": "@@ -6,7 +6,6 @@\n \n #include \"runtime.h\"\n #include \"go-alloc.h\"\n-#include \"interface.h\"\n #include \"go-panic.h\"\n #include \"go-type.h\"\n \n@@ -170,7 +169,8 @@ _cgo_panic (const char *p)\n   intgo len;\n   unsigned char *data;\n   String *ps;\n-  struct __go_empty_interface e;\n+  Eface e;\n+  const struct __go_type_descriptor *td;\n \n   runtime_exitsyscall (0);\n   len = __builtin_strlen (p);\n@@ -179,8 +179,9 @@ _cgo_panic (const char *p)\n   ps = alloc_saved (sizeof *ps);\n   ps->str = data;\n   ps->len = len;\n-  e.__type_descriptor = &string_type_descriptor;\n-  e.__object = ps;\n+  td = &string_type_descriptor;\n+  memcpy(&e._type, &td, sizeof td); /* This is a const_cast.  */\n+  e.data = ps;\n \n   /* We don't call runtime_entersyscall here, because normally what\n      will happen is that we will walk up the stack to a Go deferred"}, {"sha": "722a4219ab2c4fd9ee9680ef3de42d8e78e0251a", "filename": "libgo/runtime/go-check-interface.c", "status": "removed", "additions": 0, "deletions": 46, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fceabe505cf0dc7030602e582fadadcce73dd6de/libgo%2Fruntime%2Fgo-check-interface.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fceabe505cf0dc7030602e582fadadcce73dd6de/libgo%2Fruntime%2Fgo-check-interface.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-check-interface.c?ref=fceabe505cf0dc7030602e582fadadcce73dd6de", "patch": "@@ -1,46 +0,0 @@\n-/* go-check-interface.c -- check an interface type for a conversion\n-\n-   Copyright 2010 The Go Authors. All rights reserved.\n-   Use of this source code is governed by a BSD-style\n-   license that can be found in the LICENSE file.  */\n-\n-#include \"runtime.h\"\n-#include \"go-panic.h\"\n-#include \"go-type.h\"\n-#include \"interface.h\"\n-\n-/* Check that an interface type matches for a conversion to a\n-   non-interface type.  This panics if the types are bad.  The actual\n-   extraction of the object is inlined.  */\n-\n-void\n-__go_check_interface_type (\n-    const struct __go_type_descriptor *lhs_descriptor,\n-    const struct __go_type_descriptor *rhs_descriptor,\n-    const struct __go_type_descriptor *rhs_inter_descriptor)\n-{\n-  if (rhs_descriptor == NULL)\n-    {\n-      struct __go_empty_interface panic_arg;\n-\n-      runtime_newTypeAssertionError(NULL, NULL, lhs_descriptor->__reflection,\n-\t\t\t\t    NULL, &panic_arg);\n-      __go_panic(panic_arg);\n-    }\n-\n-  if (lhs_descriptor != rhs_descriptor\n-      && !__go_type_descriptors_equal (lhs_descriptor, rhs_descriptor)\n-      && ((lhs_descriptor->__code & GO_CODE_MASK) != GO_UNSAFE_POINTER\n-\t  || !__go_is_pointer_type (rhs_descriptor))\n-      && ((rhs_descriptor->__code & GO_CODE_MASK) != GO_UNSAFE_POINTER\n-\t  || !__go_is_pointer_type (lhs_descriptor)))\n-    {\n-      struct __go_empty_interface panic_arg;\n-\n-      runtime_newTypeAssertionError(rhs_inter_descriptor->__reflection,\n-\t\t\t\t    rhs_descriptor->__reflection,\n-\t\t\t\t    lhs_descriptor->__reflection,\n-\t\t\t\t    NULL, &panic_arg);\n-      __go_panic(panic_arg);\n-    }\n-}"}, {"sha": "0e8a30624350853fb46097582cee124c3a7bcb76", "filename": "libgo/runtime/go-convert-interface.c", "status": "removed", "additions": 0, "deletions": 132, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fceabe505cf0dc7030602e582fadadcce73dd6de/libgo%2Fruntime%2Fgo-convert-interface.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fceabe505cf0dc7030602e582fadadcce73dd6de/libgo%2Fruntime%2Fgo-convert-interface.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-convert-interface.c?ref=fceabe505cf0dc7030602e582fadadcce73dd6de", "patch": "@@ -1,132 +0,0 @@\n-/* go-convert-interface.c -- convert interfaces for Go.\n-\n-   Copyright 2009 The Go Authors. All rights reserved.\n-   Use of this source code is governed by a BSD-style\n-   license that can be found in the LICENSE file.  */\n-\n-#include \"runtime.h\"\n-#include \"go-alloc.h\"\n-#include \"go-assert.h\"\n-#include \"go-panic.h\"\n-#include \"go-string.h\"\n-#include \"go-type.h\"\n-#include \"interface.h\"\n-\n-/* This is called when converting one interface type into another\n-   interface type.  LHS_DESCRIPTOR is the type descriptor of the\n-   resulting interface.  RHS_DESCRIPTOR is the type descriptor of the\n-   object being converted.  This builds and returns a new interface\n-   method table.  If any method in the LHS_DESCRIPTOR interface is not\n-   implemented by the object, the conversion fails.  If the conversion\n-   fails, then if MAY_FAIL is true this returns NULL; otherwise, it\n-   panics.  */\n-\n-void *\n-__go_convert_interface_2 (const struct __go_type_descriptor *lhs_descriptor,\n-\t\t\t  const struct __go_type_descriptor *rhs_descriptor,\n-\t\t\t  _Bool may_fail)\n-{\n-  const struct __go_interface_type *lhs_interface;\n-  int lhs_method_count;\n-  const struct __go_interface_method* lhs_methods;\n-  const void **methods;\n-  const struct __go_uncommon_type *rhs_uncommon;\n-  int rhs_method_count;\n-  const struct __go_method *p_rhs_method;\n-  int i;\n-\n-  if (rhs_descriptor == NULL)\n-    {\n-      /* A nil value always converts to nil.  */\n-      return NULL;\n-    }\n-\n-  __go_assert ((lhs_descriptor->__code & GO_CODE_MASK) == GO_INTERFACE);\n-  lhs_interface = (const struct __go_interface_type *) lhs_descriptor;\n-  lhs_method_count = lhs_interface->__methods.__count;\n-  lhs_methods = ((const struct __go_interface_method *)\n-\t\t lhs_interface->__methods.__values);\n-\n-  /* This should not be called for an empty interface.  */\n-  __go_assert (lhs_method_count > 0);\n-\n-  rhs_uncommon = rhs_descriptor->__uncommon;\n-  if (rhs_uncommon == NULL || rhs_uncommon->__methods.__count == 0)\n-    {\n-      struct __go_empty_interface panic_arg;\n-\n-      if (may_fail)\n-\treturn NULL;\n-\n-      runtime_newTypeAssertionError (NULL, rhs_descriptor->__reflection,\n-\t\t\t\t     lhs_descriptor->__reflection,\n-\t\t\t\t     lhs_methods[0].__name,\n-\t\t\t\t     &panic_arg);\n-      __go_panic (panic_arg);\n-    }\n-\n-  rhs_method_count = rhs_uncommon->__methods.__count;\n-  p_rhs_method = ((const struct __go_method *)\n-\t\t  rhs_uncommon->__methods.__values);\n-\n-  methods = NULL;\n-\n-  for (i = 0; i < lhs_method_count; ++i)\n-    {\n-      const struct __go_interface_method *p_lhs_method;\n-\n-      p_lhs_method = &lhs_methods[i];\n-\n-      while (rhs_method_count > 0\n-\t     && (!__go_ptr_strings_equal (p_lhs_method->__name,\n-\t\t\t\t\t  p_rhs_method->__name)\n-\t\t || !__go_ptr_strings_equal (p_lhs_method->__pkg_path,\n-\t\t\t\t\t     p_rhs_method->__pkg_path)))\n-\t{\n-\t  ++p_rhs_method;\n-\t  --rhs_method_count;\n-\t}\n-\n-      if (rhs_method_count == 0\n-\t  || !__go_type_descriptors_equal (p_lhs_method->__type,\n-\t\t\t\t\t   p_rhs_method->__mtype))\n-\t{\n-\t  struct __go_empty_interface panic_arg;\n-\n-\t  if (methods != NULL)\n-\t    __go_free (methods);\n-\n-\t  if (may_fail)\n-\t    return NULL;\n-\n-\t  runtime_newTypeAssertionError (NULL, rhs_descriptor->__reflection,\n-\t\t\t\t\t lhs_descriptor->__reflection,\n-\t\t\t\t\t p_lhs_method->__name, &panic_arg);\n-\t  __go_panic (panic_arg);\n-\t}\n-\n-      if (methods == NULL)\n-\t{\n-\t  methods = (const void **) __go_alloc ((lhs_method_count + 1)\n-\t\t\t\t\t\t* sizeof (void *));\n-\n-\t  /* The first field in the method table is always the type of\n-\t     the object.  */\n-\t  methods[0] = rhs_descriptor;\n-\t}\n-\n-      methods[i + 1] = p_rhs_method->__function;\n-    }\n-\n-  return methods;\n-}\n-\n-/* This is called by the compiler to convert a value from one\n-   interface type to another.  */\n-\n-void *\n-__go_convert_interface (const struct __go_type_descriptor *lhs_descriptor,\n-\t\t\tconst struct __go_type_descriptor *rhs_descriptor)\n-{\n-  return __go_convert_interface_2 (lhs_descriptor, rhs_descriptor, 0);\n-}"}, {"sha": "c89c1fb7652df39ddfa6fa9b415bfd5d2d80ae6d", "filename": "libgo/runtime/go-deferred-recover.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b752cfac4ecf8b620726bfcd703844ebfaca6ea/libgo%2Fruntime%2Fgo-deferred-recover.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b752cfac4ecf8b620726bfcd703844ebfaca6ea/libgo%2Fruntime%2Fgo-deferred-recover.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-deferred-recover.c?ref=6b752cfac4ecf8b620726bfcd703844ebfaca6ea", "patch": "@@ -75,18 +75,18 @@\n    because you are not permitted to take the address of a predeclared\n    function like recover.  */\n \n-struct __go_empty_interface\n+Eface\n __go_deferred_recover ()\n {\n   G *g;\n \n   g = runtime_g ();\n   if (g->_defer == NULL || g->_defer->_panic != g->_panic)\n     {\n-      struct __go_empty_interface ret;\n+      Eface ret;\n \n-      ret.__type_descriptor = NULL;\n-      ret.__object = NULL;\n+      ret._type = NULL;\n+      ret.data = NULL;\n       return ret;\n     }\n   return __go_recover ();"}, {"sha": "62302b5ebe2c45400e0da6dfe28976dabf9e047e", "filename": "libgo/runtime/go-eface-compare.c", "status": "removed", "additions": 0, "deletions": 37, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fceabe505cf0dc7030602e582fadadcce73dd6de/libgo%2Fruntime%2Fgo-eface-compare.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fceabe505cf0dc7030602e582fadadcce73dd6de/libgo%2Fruntime%2Fgo-eface-compare.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-eface-compare.c?ref=fceabe505cf0dc7030602e582fadadcce73dd6de", "patch": "@@ -1,37 +0,0 @@\n-/* go-eface-compare.c -- compare two empty values.\n-\n-   Copyright 2010 The Go Authors. All rights reserved.\n-   Use of this source code is governed by a BSD-style\n-   license that can be found in the LICENSE file.  */\n-\n-#include \"runtime.h\"\n-#include \"go-type.h\"\n-#include \"interface.h\"\n-\n-/* Compare two interface values.  Return 0 for equal, not zero for not\n-   equal (return value is like strcmp).  */\n-\n-intgo\n-__go_empty_interface_compare (struct __go_empty_interface left,\n-\t\t\t      struct __go_empty_interface right)\n-{\n-  const struct __go_type_descriptor *left_descriptor;\n-\n-  left_descriptor = left.__type_descriptor;\n-\n-  if (left_descriptor == NULL && right.__type_descriptor == NULL)\n-    return 0;\n-  if (left_descriptor == NULL || right.__type_descriptor == NULL)\n-    return 1;\n-  if (!__go_type_descriptors_equal (left_descriptor,\n-\t\t\t\t    right.__type_descriptor))\n-    return 1;\n-  if (left_descriptor->__equalfn == NULL)\n-    runtime_panicstring (\"comparing uncomparable types\");\n-  if (__go_is_pointer_type (left_descriptor))\n-    return left.__object == right.__object ? 0 : 1;\n-  if (!__go_call_equalfn (left_descriptor->__equalfn, left.__object,\n-\t\t\t  right.__object, left_descriptor->__size))\n-    return 1;\n-  return 0;\n-}"}, {"sha": "839d18916231441baddafb8dddb956d60d2a995a", "filename": "libgo/runtime/go-eface-val-compare.c", "status": "removed", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fceabe505cf0dc7030602e582fadadcce73dd6de/libgo%2Fruntime%2Fgo-eface-val-compare.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fceabe505cf0dc7030602e582fadadcce73dd6de/libgo%2Fruntime%2Fgo-eface-val-compare.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-eface-val-compare.c?ref=fceabe505cf0dc7030602e582fadadcce73dd6de", "patch": "@@ -1,35 +0,0 @@\n-/* go-eface-val-compare.c -- compare an empty interface with a value.\n-\n-   Copyright 2010 The Go Authors. All rights reserved.\n-   Use of this source code is governed by a BSD-style\n-   license that can be found in the LICENSE file.  */\n-\n-#include \"runtime.h\"\n-#include \"go-type.h\"\n-#include \"interface.h\"\n-\n-/* Compare an empty interface with a value.  Return 0 for equal, not\n-   zero for not equal (return value is like strcmp).  */\n-\n-intgo\n-__go_empty_interface_value_compare (\n-    struct __go_empty_interface left,\n-    const struct __go_type_descriptor *right_descriptor,\n-    const void *val)\n-{\n-  const struct __go_type_descriptor *left_descriptor;\n-\n-  left_descriptor = left.__type_descriptor;\n-  if (left_descriptor == NULL)\n-    return 1;\n-  if (!__go_type_descriptors_equal (left_descriptor, right_descriptor))\n-    return 1;\n-  if (left_descriptor->__equalfn == NULL)\n-    runtime_panicstring (\"comparing uncomparable types\");\n-  if (__go_is_pointer_type (left_descriptor))\n-    return left.__object == val ? 0 : 1;\n-  if (!__go_call_equalfn (left_descriptor->__equalfn, left.__object, val,\n-\t\t\t  left_descriptor->__size))\n-    return 1;\n-  return 0;\n-}"}, {"sha": "0d5cb5e97aa01fbf72136fb9d9f8febb85a84770", "filename": "libgo/runtime/go-iface.goc", "status": "removed", "additions": 0, "deletions": 130, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fceabe505cf0dc7030602e582fadadcce73dd6de/libgo%2Fruntime%2Fgo-iface.goc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fceabe505cf0dc7030602e582fadadcce73dd6de/libgo%2Fruntime%2Fgo-iface.goc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-iface.goc?ref=fceabe505cf0dc7030602e582fadadcce73dd6de", "patch": "@@ -1,130 +0,0 @@\n-// Copyright 2010 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package runtime\n-#include \"runtime.h\"\n-#include \"go-type.h\"\n-#include \"interface.h\"\n-\n-typedef struct __go_type_descriptor descriptor;\n-typedef const struct __go_type_descriptor const_descriptor;\n-typedef struct __go_interface interface;\n-typedef struct __go_empty_interface empty_interface;\n-\n-// Compare two type descriptors.\n-func ifacetypeeq(a *descriptor, b *descriptor) (eq bool) {\n-\teq = __go_type_descriptors_equal(a, b);\n-}\n-\n-// Return the descriptor for an empty interface type.n\n-func efacetype(e empty_interface) (d *const_descriptor) {\n-\treturn e.__type_descriptor;\n-}\n-\n-// Return the descriptor for a non-empty interface type.\n-func ifacetype(i interface) (d *const_descriptor) {\n-\tif (i.__methods == nil) {\n-\t\treturn nil;\n-\t}\n-\td = i.__methods[0];\n-}\n-\n-// Convert an empty interface to an empty interface.\n-func ifaceE2E2(e empty_interface) (ret empty_interface, ok bool) {\n-\tret = e;\n-\tok = ret.__type_descriptor != nil;\n-}\n-\n-// Convert a non-empty interface to an empty interface.\n-func ifaceI2E2(i interface) (ret empty_interface, ok bool) {\n-\tif (i.__methods == nil) {\n-\t\tret.__type_descriptor = nil;\n-\t\tret.__object = nil;\n-\t\tok = 0;\n-\t} else {\n-\t\tret.__type_descriptor = i.__methods[0];\n-\t\tret.__object = i.__object;\n-\t\tok = 1;\n-\t}\n-}\n-\n-// Convert an empty interface to a non-empty interface.\n-func ifaceE2I2(inter *descriptor, e empty_interface) (ret interface, ok bool) {\n-\tif (e.__type_descriptor == nil) {\n-\t\tret.__methods = nil;\n-\t\tret.__object = nil;\n-\t\tok = 0;\n-\t} else {\n-\t\tret.__methods = __go_convert_interface_2(inter,\n-\t\t\t\t\t\t\t e.__type_descriptor,\n-\t\t\t\t\t\t\t 1);\n-\t\tret.__object = e.__object;\n-\t\tok = ret.__methods != nil;\n-\t}\n-}\n-\n-// Convert a non-empty interface to a non-empty interface.\n-func ifaceI2I2(inter *descriptor, i interface) (ret interface, ok bool) {\n-\tif (i.__methods == nil) {\n-\t\tret.__methods = nil;\n-\t\tret.__object = nil;\n-\t\tok = 0;\n-\t} else {\n-\t\tret.__methods = __go_convert_interface_2(inter,\n-\t\t\t\t\t\t\t i.__methods[0], 1);\n-\t\tret.__object = i.__object;\n-\t\tok = ret.__methods != nil;\n-\t}\n-}\n-\n-// Convert an empty interface to a pointer type.\n-func ifaceE2T2P(inter *descriptor, e empty_interface) (ret *void, ok bool) {\n-\tif (!__go_type_descriptors_equal(inter, e.__type_descriptor)) {\n-\t\tret = nil;\n-\t\tok = 0;\n-\t} else {\n-\t\tret = e.__object;\n-\t\tok = 1;\n-\t}\n-}\n-\n-// Convert a non-empty interface to a pointer type.\n-func ifaceI2T2P(inter *descriptor, i interface) (ret *void, ok bool) {\n-\tif (i.__methods == nil\n-\t    || !__go_type_descriptors_equal(inter, i.__methods[0])) {\n-\t\tret = nil;\n-\t\tok = 0;\n-\t} else {\n-\t\tret = i.__object;\n-\t\tok = 1;\n-\t}\n-}\n-\n-// Convert an empty interface to a non-pointer type.\n-func ifaceE2T2(inter *descriptor, e empty_interface, ret *void) (ok bool) {\n-\tif (!__go_type_descriptors_equal(inter, e.__type_descriptor)) {\n-\t\t__builtin_memset(ret, 0, inter->__size);\n-\t\tok = 0;\n-\t} else {\n-\t\t__builtin_memcpy(ret, e.__object, inter->__size);\n-\t\tok = 1;\n-\t}\n-}\n-\n-// Convert a non-empty interface to a non-pointer type.\n-func ifaceI2T2(inter *descriptor, i interface, ret *void) (ok bool) {\n-\tif (i.__methods == nil\n-\t    || !__go_type_descriptors_equal(inter, i.__methods[0])) {\n-\t\t__builtin_memset(ret, 0, inter->__size);\n-\t\tok = 0;\n-\t} else {\n-\t\t__builtin_memcpy(ret, i.__object, inter->__size);\n-\t\tok = 1;\n-\t}\n-}\n-\n-// Return whether we can convert an interface to a type.\n-func ifaceI2Tp(to *descriptor, from *descriptor) (ok bool) {\n-\tok = __go_can_convert_to_interface(to, from);\n-}"}, {"sha": "14999df1dd1d097ecf4493c155f3c26e29d848d4", "filename": "libgo/runtime/go-interface-compare.c", "status": "removed", "additions": 0, "deletions": 37, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fceabe505cf0dc7030602e582fadadcce73dd6de/libgo%2Fruntime%2Fgo-interface-compare.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fceabe505cf0dc7030602e582fadadcce73dd6de/libgo%2Fruntime%2Fgo-interface-compare.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-interface-compare.c?ref=fceabe505cf0dc7030602e582fadadcce73dd6de", "patch": "@@ -1,37 +0,0 @@\n-/* go-interface-compare.c -- compare two interface values.\n-\n-   Copyright 2009 The Go Authors. All rights reserved.\n-   Use of this source code is governed by a BSD-style\n-   license that can be found in the LICENSE file.  */\n-\n-#include <stddef.h>\n-\n-#include \"runtime.h\"\n-#include \"go-type.h\"\n-#include \"interface.h\"\n-\n-/* Compare two interface values.  Return 0 for equal, not zero for not\n-   equal (return value is like strcmp).  */\n-\n-int\n-__go_interface_compare (struct __go_interface left,\n-\t\t\tstruct __go_interface right)\n-{\n-  const struct __go_type_descriptor *left_descriptor;\n-\n-  if (left.__methods == NULL && right.__methods == NULL)\n-    return 0;\n-  if (left.__methods == NULL || right.__methods == NULL)\n-    return 1;\n-  left_descriptor = left.__methods[0];\n-  if (!__go_type_descriptors_equal (left_descriptor, right.__methods[0]))\n-    return 1;\n-  if (left_descriptor->__equalfn == NULL)\n-    runtime_panicstring (\"comparing uncomparable types\");\n-  if (__go_is_pointer_type (left_descriptor))\n-    return left.__object == right.__object ? 0 : 1;\n-  if (!__go_call_equalfn (left_descriptor->__equalfn, left.__object,\n-\t\t\t  right.__object, left_descriptor->__size))\n-    return 1;\n-  return 0;\n-}"}, {"sha": "4c47b7cf04d5789e1b6792fb0406efab1e7f2971", "filename": "libgo/runtime/go-interface-eface-compare.c", "status": "removed", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fceabe505cf0dc7030602e582fadadcce73dd6de/libgo%2Fruntime%2Fgo-interface-eface-compare.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fceabe505cf0dc7030602e582fadadcce73dd6de/libgo%2Fruntime%2Fgo-interface-eface-compare.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-interface-eface-compare.c?ref=fceabe505cf0dc7030602e582fadadcce73dd6de", "patch": "@@ -1,36 +0,0 @@\n-/* go-interface-eface-compare.c -- compare non-empty and empty interface.\n-\n-   Copyright 2011 The Go Authors. All rights reserved.\n-   Use of this source code is governed by a BSD-style\n-   license that can be found in the LICENSE file.  */\n-\n-#include \"runtime.h\"\n-#include \"go-type.h\"\n-#include \"interface.h\"\n-\n-/* Compare a non-empty interface value with an empty interface value.\n-   Return 0 for equal, not zero for not equal (return value is like\n-   strcmp).  */\n-\n-intgo\n-__go_interface_empty_compare (struct __go_interface left,\n-\t\t\t      struct __go_empty_interface right)\n-{\n-  const struct __go_type_descriptor *left_descriptor;\n-\n-  if (left.__methods == NULL && right.__type_descriptor == NULL)\n-    return 0;\n-  if (left.__methods == NULL || right.__type_descriptor == NULL)\n-    return 1;\n-  left_descriptor = left.__methods[0];\n-  if (!__go_type_descriptors_equal (left_descriptor, right.__type_descriptor))\n-    return 1;\n-  if (left_descriptor->__equalfn == NULL)\n-    runtime_panicstring (\"comparing uncomparable types\");\n-  if (__go_is_pointer_type (left_descriptor))\n-    return left.__object == right.__object ? 0 : 1;\n-  if (!__go_call_equalfn (left_descriptor->__equalfn, left.__object,\n-\t\t\t  right.__object, left_descriptor->__size))\n-    return 1;\n-  return 0;\n-}"}, {"sha": "5dc91d0330f1cfa278c5d963784b49253650ea75", "filename": "libgo/runtime/go-interface-val-compare.c", "status": "removed", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fceabe505cf0dc7030602e582fadadcce73dd6de/libgo%2Fruntime%2Fgo-interface-val-compare.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fceabe505cf0dc7030602e582fadadcce73dd6de/libgo%2Fruntime%2Fgo-interface-val-compare.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-interface-val-compare.c?ref=fceabe505cf0dc7030602e582fadadcce73dd6de", "patch": "@@ -1,35 +0,0 @@\n-/* go-interface-val-compare.c -- compare an interface to a value.\n-\n-   Copyright 2009 The Go Authors. All rights reserved.\n-   Use of this source code is governed by a BSD-style\n-   license that can be found in the LICENSE file.  */\n-\n-#include \"runtime.h\"\n-#include \"go-type.h\"\n-#include \"interface.h\"\n-\n-/* Compare two interface values.  Return 0 for equal, not zero for not\n-   equal (return value is like strcmp).  */\n-\n-intgo\n-__go_interface_value_compare (\n-    struct __go_interface left,\n-    const struct __go_type_descriptor *right_descriptor,\n-    const void *val)\n-{\n-  const struct __go_type_descriptor *left_descriptor;\n-\n-  if (left.__methods == NULL)\n-    return 1;\n-  left_descriptor = left.__methods[0];\n-  if (!__go_type_descriptors_equal (left_descriptor, right_descriptor))\n-    return 1;\n-  if (left_descriptor->__equalfn == NULL)\n-    runtime_panicstring (\"comparing uncomparable types\");\n-  if (__go_is_pointer_type (left_descriptor))\n-    return left.__object == val ? 0 : 1;\n-  if (!__go_call_equalfn (left_descriptor->__equalfn, left.__object, val,\n-\t\t\t  left_descriptor->__size))\n-    return 1;\n-  return 0;\n-}"}, {"sha": "2fb65aa5782bffec304026dc87f6695031a8f285", "filename": "libgo/runtime/go-panic.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b752cfac4ecf8b620726bfcd703844ebfaca6ea/libgo%2Fruntime%2Fgo-panic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b752cfac4ecf8b620726bfcd703844ebfaca6ea/libgo%2Fruntime%2Fgo-panic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-panic.c?ref=6b752cfac4ecf8b620726bfcd703844ebfaca6ea", "patch": "@@ -12,7 +12,6 @@\n #include \"malloc.h\"\n #include \"go-alloc.h\"\n #include \"go-panic.h\"\n-#include \"interface.h\"\n \n /* Print the panic stack.  This is used when there is no recover.  */\n \n@@ -35,7 +34,7 @@ __printpanics (Panic *p)\n    function.  */\n \n void\n-__go_panic (struct __go_empty_interface arg)\n+__go_panic (Eface arg)\n {\n   G *g;\n   Panic *n;"}, {"sha": "83b529286949f1b48ad7648d9a09ffa1f76c5c7c", "filename": "libgo/runtime/go-panic.h", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b752cfac4ecf8b620726bfcd703844ebfaca6ea/libgo%2Fruntime%2Fgo-panic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b752cfac4ecf8b620726bfcd703844ebfaca6ea/libgo%2Fruntime%2Fgo-panic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-panic.h?ref=6b752cfac4ecf8b620726bfcd703844ebfaca6ea", "patch": "@@ -7,24 +7,18 @@\n #ifndef LIBGO_GO_PANIC_H\n #define LIBGO_GO_PANIC_H\n \n-#include \"interface.h\"\n-\n-struct String;\n-struct __go_type_descriptor;\n-\n-extern void __go_panic (struct __go_empty_interface)\n+extern void __go_panic (Eface)\n   __attribute__ ((noreturn));\n \n-extern void __go_print_string (struct String);\n+extern void __go_print_string (String);\n \n-extern struct __go_empty_interface __go_recover (void);\n+extern Eface __go_recover (void);\n \n extern _Bool __go_can_recover (void *);\n \n extern void __go_makefunc_can_recover (void *retaddr);\n \n-struct location;\n-extern void __go_makefunc_ffi_can_recover (struct location *, int);\n+extern void __go_makefunc_ffi_can_recover (Location*, int);\n \n extern void __go_makefunc_returning (void);\n "}, {"sha": "97efdcdf8ac7d9055cc655d03ef6d966ee2cc7ec", "filename": "libgo/runtime/go-recover.c", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b752cfac4ecf8b620726bfcd703844ebfaca6ea/libgo%2Fruntime%2Fgo-recover.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b752cfac4ecf8b620726bfcd703844ebfaca6ea/libgo%2Fruntime%2Fgo-recover.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-recover.c?ref=6b752cfac4ecf8b620726bfcd703844ebfaca6ea", "patch": "@@ -5,7 +5,6 @@\n    license that can be found in the LICENSE file.  */\n \n #include \"runtime.h\"\n-#include \"interface.h\"\n #include \"go-panic.h\"\n \n /* If the top of the defer stack can be recovered, then return it.\n@@ -200,7 +199,7 @@ __go_makefunc_can_recover (void *retaddr)\n    make the same decision.  */\n \n void\n-__go_makefunc_ffi_can_recover (struct location *loc, int n)\n+__go_makefunc_ffi_can_recover (Location *loc, int n)\n {\n   Defer *d;\n   const byte *name;\n@@ -252,7 +251,7 @@ __go_makefunc_returning (void)\n /* This is only called when it is valid for the caller to recover the\n    value on top of the panic stack, if there is one.  */\n \n-struct __go_empty_interface\n+Eface\n __go_recover ()\n {\n   G *g;\n@@ -262,10 +261,10 @@ __go_recover ()\n \n   if (g->_panic == NULL || g->_panic->recovered)\n     {\n-      struct __go_empty_interface ret;\n+      Eface ret;\n \n-      ret.__type_descriptor = NULL;\n-      ret.__object = NULL;\n+      ret._type = NULL;\n+      ret.data = NULL;\n       return ret;\n     }\n   p = g->_panic;"}, {"sha": "bcc270bf8a57b0b56f9ba0f4549bde80a705e6c5", "filename": "libgo/runtime/go-strcmp.c", "status": "removed", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fceabe505cf0dc7030602e582fadadcce73dd6de/libgo%2Fruntime%2Fgo-strcmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fceabe505cf0dc7030602e582fadadcce73dd6de/libgo%2Fruntime%2Fgo-strcmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-strcmp.c?ref=fceabe505cf0dc7030602e582fadadcce73dd6de", "patch": "@@ -1,25 +0,0 @@\n-/* go-strcmp.c -- the go string comparison function.\n-\n-   Copyright 2009 The Go Authors. All rights reserved.\n-   Use of this source code is governed by a BSD-style\n-   license that can be found in the LICENSE file.  */\n-\n-#include \"runtime.h\"\n-\n-intgo\n-__go_strcmp(String s1, String s2)\n-{\n-  int i;\n-\n-  i = __builtin_memcmp(s1.str, s2.str,\n-\t\t       (s1.len < s2.len ? s1.len : s2.len));\n-  if (i != 0)\n-    return i;\n-\n-  if (s1.len < s2.len)\n-    return -1;\n-  else if (s1.len > s2.len)\n-    return 1;\n-  else\n-    return 0;\n-}"}, {"sha": "ce20f29ba203c9abd7d4122634c721a3381647f8", "filename": "libgo/runtime/go-strslice.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b752cfac4ecf8b620726bfcd703844ebfaca6ea/libgo%2Fruntime%2Fgo-strslice.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b752cfac4ecf8b620726bfcd703844ebfaca6ea/libgo%2Fruntime%2Fgo-strslice.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-strslice.c?ref=6b752cfac4ecf8b620726bfcd703844ebfaca6ea", "patch": "@@ -4,8 +4,8 @@\n    Use of this source code is governed by a BSD-style\n    license that can be found in the LICENSE file.  */\n \n-#include \"go-panic.h\"\n #include \"runtime.h\"\n+#include \"go-panic.h\"\n #include \"arch.h\"\n #include \"malloc.h\"\n "}, {"sha": "a98bceaac84686f6537aa76f3579d64f267b3d08", "filename": "libgo/runtime/go-type-eface.c", "status": "removed", "additions": 0, "deletions": 66, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fceabe505cf0dc7030602e582fadadcce73dd6de/libgo%2Fruntime%2Fgo-type-eface.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fceabe505cf0dc7030602e582fadadcce73dd6de/libgo%2Fruntime%2Fgo-type-eface.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-type-eface.c?ref=fceabe505cf0dc7030602e582fadadcce73dd6de", "patch": "@@ -1,66 +0,0 @@\n-/* go-type-eface.c -- hash and equality empty interface functions.\n-\n-   Copyright 2010 The Go Authors. All rights reserved.\n-   Use of this source code is governed by a BSD-style\n-   license that can be found in the LICENSE file.  */\n-\n-#include \"runtime.h\"\n-#include \"interface.h\"\n-#include \"go-type.h\"\n-\n-/* A hash function for an empty interface.  */\n-\n-uintptr_t\n-__go_type_hash_empty_interface (const void *vval, uintptr_t seed,\n-\t\t\t\tuintptr_t key_size __attribute__ ((unused)))\n-{\n-  const struct __go_empty_interface *val;\n-  const struct __go_type_descriptor *descriptor;\n-  uintptr_t size;\n-\n-  val = (const struct __go_empty_interface *) vval;\n-  descriptor = val->__type_descriptor;\n-  if (descriptor == NULL)\n-    return 0;\n-  if (descriptor->__hashfn == NULL)\n-    runtime_panicstring (\"hash of unhashable type\");\n-  size = descriptor->__size;\n-  if (__go_is_pointer_type (descriptor))\n-    return __go_call_hashfn (descriptor->__hashfn, &val->__object, seed, size);\n-  else\n-    return __go_call_hashfn (descriptor->__hashfn, val->__object, seed, size);\n-}\n-\n-const FuncVal __go_type_hash_empty_interface_descriptor =\n-  { (void *) __go_type_hash_empty_interface };\n-\n-/* An equality function for an empty interface.  */\n-\n-_Bool\n-__go_type_equal_empty_interface (const void *vv1, const void *vv2,\n-\t\t\t\t uintptr_t key_size __attribute__ ((unused)))\n-{\n-  const struct __go_empty_interface *v1;\n-  const struct __go_empty_interface *v2;\n-  const struct __go_type_descriptor* v1_descriptor;\n-  const struct __go_type_descriptor* v2_descriptor;\n-\n-  v1 = (const struct __go_empty_interface *) vv1;\n-  v2 = (const struct __go_empty_interface *) vv2;\n-  v1_descriptor = v1->__type_descriptor;\n-  v2_descriptor = v2->__type_descriptor;\n-  if (v1_descriptor == NULL || v2_descriptor == NULL)\n-    return v1_descriptor == v2_descriptor;\n-  if (!__go_type_descriptors_equal (v1_descriptor, v2_descriptor))\n-    return 0;\n-  if (v1_descriptor->__equalfn == NULL)\n-    runtime_panicstring (\"comparing uncomparable types\");\n-  if (__go_is_pointer_type (v1_descriptor))\n-    return v1->__object == v2->__object;\n-  else\n-    return __go_call_equalfn (v1_descriptor->__equalfn, v1->__object,\n-\t\t\t      v2->__object, v1_descriptor->__size);\n-}\n-\n-const FuncVal __go_type_equal_empty_interface_descriptor =\n-  { (void *) __go_type_equal_empty_interface };"}, {"sha": "ffba7b28a3566c76e5e19d9a566e34f11174c46d", "filename": "libgo/runtime/go-type-interface.c", "status": "removed", "additions": 0, "deletions": 66, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fceabe505cf0dc7030602e582fadadcce73dd6de/libgo%2Fruntime%2Fgo-type-interface.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fceabe505cf0dc7030602e582fadadcce73dd6de/libgo%2Fruntime%2Fgo-type-interface.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-type-interface.c?ref=fceabe505cf0dc7030602e582fadadcce73dd6de", "patch": "@@ -1,66 +0,0 @@\n-/* go-type-interface.c -- hash and equality interface functions.\n-\n-   Copyright 2009 The Go Authors. All rights reserved.\n-   Use of this source code is governed by a BSD-style\n-   license that can be found in the LICENSE file.  */\n-\n-#include \"runtime.h\"\n-#include \"interface.h\"\n-#include \"go-type.h\"\n-\n-/* A hash function for an interface.  */\n-\n-uintptr_t\n-__go_type_hash_interface (const void *vval, uintptr_t seed,\n-\t\t\t  uintptr_t key_size __attribute__ ((unused)))\n-{\n-  const struct __go_interface *val;\n-  const struct __go_type_descriptor *descriptor;\n-  uintptr_t size;\n-\n-  val = (const struct __go_interface *) vval;\n-  if (val->__methods == NULL)\n-    return 0;\n-  descriptor = (const struct __go_type_descriptor *) val->__methods[0];\n-  if (descriptor->__hashfn == NULL)\n-    runtime_panicstring (\"hash of unhashable type\");\n-  size = descriptor->__size;\n-  if (__go_is_pointer_type (descriptor))\n-    return __go_call_hashfn (descriptor->__hashfn, &val->__object, seed, size);\n-  else\n-    return __go_call_hashfn (descriptor->__hashfn, val->__object, seed, size);\n-}\n-\n-const FuncVal __go_type_hash_interface_descriptor =\n-  { (void *) __go_type_hash_interface };\n-\n-/* An equality function for an interface.  */\n-\n-_Bool\n-__go_type_equal_interface (const void *vv1, const void *vv2,\n-\t\t\t   uintptr_t key_size __attribute__ ((unused)))\n-{\n-  const struct __go_interface *v1;\n-  const struct __go_interface *v2;\n-  const struct __go_type_descriptor* v1_descriptor;\n-  const struct __go_type_descriptor* v2_descriptor;\n-\n-  v1 = (const struct __go_interface *) vv1;\n-  v2 = (const struct __go_interface *) vv2;\n-  if (v1->__methods == NULL || v2->__methods == NULL)\n-    return v1->__methods == v2->__methods;\n-  v1_descriptor = (const struct __go_type_descriptor *) v1->__methods[0];\n-  v2_descriptor = (const struct __go_type_descriptor *) v2->__methods[0];\n-  if (!__go_type_descriptors_equal (v1_descriptor, v2_descriptor))\n-    return 0;\n-  if (v1_descriptor->__equalfn == NULL)\n-    runtime_panicstring (\"comparing uncomparable types\");\n-  if (__go_is_pointer_type (v1_descriptor))\n-    return v1->__object == v2->__object;\n-  else\n-    return __go_call_equalfn (v1_descriptor->__equalfn, v1->__object,\n-\t\t\t      v2->__object, v1_descriptor->__size);\n-}\n-\n-const FuncVal __go_type_equal_interface_descriptor =\n-  { (void *) __go_type_equal_interface };"}, {"sha": "07f274f99a6d1e5c5a7c2013d04c12328b874ed5", "filename": "libgo/runtime/go-unsafe-new.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b752cfac4ecf8b620726bfcd703844ebfaca6ea/libgo%2Fruntime%2Fgo-unsafe-new.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b752cfac4ecf8b620726bfcd703844ebfaca6ea/libgo%2Fruntime%2Fgo-unsafe-new.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-unsafe-new.c?ref=6b752cfac4ecf8b620726bfcd703844ebfaca6ea", "patch": "@@ -8,7 +8,6 @@\n #include \"arch.h\"\n #include \"malloc.h\"\n #include \"go-type.h\"\n-#include \"interface.h\"\n \n /* Implement unsafe_New, called from the reflect package.  */\n "}, {"sha": "409ddd95dc345015a0ede6ffd25d07fb1737630c", "filename": "libgo/runtime/go-unsafe-newarray.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b752cfac4ecf8b620726bfcd703844ebfaca6ea/libgo%2Fruntime%2Fgo-unsafe-newarray.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b752cfac4ecf8b620726bfcd703844ebfaca6ea/libgo%2Fruntime%2Fgo-unsafe-newarray.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-unsafe-newarray.c?ref=6b752cfac4ecf8b620726bfcd703844ebfaca6ea", "patch": "@@ -8,7 +8,6 @@\n #include \"arch.h\"\n #include \"malloc.h\"\n #include \"go-type.h\"\n-#include \"interface.h\"\n \n /* Implement unsafe_NewArray, called from the reflect package.  */\n "}, {"sha": "fb59115b9229458d272f43d656a6c618aff37d2b", "filename": "libgo/runtime/go-unwind.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b752cfac4ecf8b620726bfcd703844ebfaca6ea/libgo%2Fruntime%2Fgo-unwind.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b752cfac4ecf8b620726bfcd703844ebfaca6ea/libgo%2Fruntime%2Fgo-unwind.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-unwind.c?ref=6b752cfac4ecf8b620726bfcd703844ebfaca6ea", "patch": "@@ -67,8 +67,8 @@ __go_check_defer (_Bool *frame)\n \n       n = (Panic *) __go_alloc (sizeof (Panic));\n \n-      n->arg.__type_descriptor = NULL;\n-      n->arg.__object = NULL;\n+      n->arg._type = NULL;\n+      n->arg.data = NULL;\n       n->recovered = 0;\n       n->isforeign = 1;\n       n->next = g->_panic;"}, {"sha": "3a5bc1bf59d9076a284949e1cb079fafefef74f0", "filename": "libgo/runtime/heapdump.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b752cfac4ecf8b620726bfcd703844ebfaca6ea/libgo%2Fruntime%2Fheapdump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b752cfac4ecf8b620726bfcd703844ebfaca6ea/libgo%2Fruntime%2Fheapdump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fheapdump.c?ref=6b752cfac4ecf8b620726bfcd703844ebfaca6ea", "patch": "@@ -298,8 +298,8 @@ dumpgoroutine(G *gp)\n \t\tdumpint(TagPanic);\n \t\tdumpint((uintptr)p);\n \t\tdumpint((uintptr)gp);\n-\t\tdumpint((uintptr)p->arg.__type_descriptor);\n-\t\tdumpint((uintptr)p->arg.__object);\n+\t\tdumpint((uintptr)p->arg._type);\n+\t\tdumpint((uintptr)p->arg.data);\n \t\tdumpint((uintptr)0);\n \t\tdumpint((uintptr)p->next);\n \t}"}, {"sha": "f3068a656fab84674e02c352ba2fa1f6320c1274", "filename": "libgo/runtime/interface.h", "status": "removed", "additions": 0, "deletions": 57, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fceabe505cf0dc7030602e582fadadcce73dd6de/libgo%2Fruntime%2Finterface.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fceabe505cf0dc7030602e582fadadcce73dd6de/libgo%2Fruntime%2Finterface.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Finterface.h?ref=fceabe505cf0dc7030602e582fadadcce73dd6de", "patch": "@@ -1,57 +0,0 @@\n-/* interface.h -- the interface type for Go.\n-\n-   Copyright 2009 The Go Authors. All rights reserved.\n-   Use of this source code is governed by a BSD-style\n-   license that can be found in the LICENSE file.  */\n-\n-#ifndef LIBGO_INTERFACE_H\n-#define LIBGO_INTERFACE_H\n-\n-struct __go_type_descriptor;\n-\n-/* A variable of interface type is an instance of this struct, if the\n-   interface has any methods.  */\n-\n-struct __go_interface\n-{\n-  /* A pointer to the interface method table.  The first pointer is\n-     the type descriptor of the object.  Subsequent pointers are\n-     pointers to functions.  This is effectively the vtable for this\n-     interface.  The function pointers are in the same order as the\n-     list in the internal representation of the interface, which sorts\n-     them by name.  */\n-  const void **__methods;\n-\n-  /* The object.  If the object is a pointer--if the type descriptor\n-     code is GO_PTR or GO_UNSAFE_POINTER--then this field is the value\n-     of the object itself.  Otherwise this is a pointer to memory\n-     which holds the value.  */\n-  void *__object;\n-};\n-\n-/* A variable of an empty interface type is an instance of this\n-   struct.  */\n-\n-struct __go_empty_interface\n-{\n-  /* The type descriptor of the object.  */\n-  const struct __go_type_descriptor *__type_descriptor;\n-\n-  /* The object.  This is the same as __go_interface above.  */\n-  void *__object;\n-};\n-\n-extern void *\n-__go_convert_interface (const struct __go_type_descriptor *,\n-\t\t\tconst struct __go_type_descriptor *);\n-\n-extern void *\n-__go_convert_interface_2 (const struct __go_type_descriptor *,\n-\t\t\t  const struct __go_type_descriptor *,\n-\t\t\t  _Bool may_fail);\n-\n-extern _Bool\n-__go_can_convert_to_interface(const struct __go_type_descriptor *,\n-\t\t\t      const struct __go_type_descriptor *);\n-\n-#endif /* !defined(LIBGO_INTERFACE_H) */"}, {"sha": "1fd44614227fdccd054a324368d95a351f05fa9d", "filename": "libgo/runtime/malloc.goc", "status": "modified", "additions": 17, "deletions": 20, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b752cfac4ecf8b620726bfcd703844ebfaca6ea/libgo%2Fruntime%2Fmalloc.goc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b752cfac4ecf8b620726bfcd703844ebfaca6ea/libgo%2Fruntime%2Fmalloc.goc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fmalloc.goc?ref=6b752cfac4ecf8b620726bfcd703844ebfaca6ea", "patch": "@@ -14,12 +14,9 @@ package runtime\n #include \"runtime.h\"\n #include \"arch.h\"\n #include \"malloc.h\"\n-#include \"interface.h\"\n #include \"go-type.h\"\n \n // Map gccgo field names to gc field names.\n-// Eface aka __go_empty_interface.\n-#define type __type_descriptor\n // Type aka __go_type_descriptor\n #define kind __code\n #define string __reflection\n@@ -917,15 +914,15 @@ func SetFinalizer(obj Eface, finalizer Eface) {\n \tconst Type *fint;\n \tconst PtrType *ot;\n \n-\tif(obj.__type_descriptor == nil) {\n+\tif((Type*)obj._type == nil) {\n \t\truntime_printf(\"runtime.SetFinalizer: first argument is nil interface\\n\");\n \t\tgoto throw;\n \t}\n-\tif((obj.__type_descriptor->kind&kindMask) != GO_PTR) {\n-\t\truntime_printf(\"runtime.SetFinalizer: first argument is %S, not pointer\\n\", *obj.__type_descriptor->__reflection);\n+\tif((((Type*)obj._type)->kind&kindMask) != GO_PTR) {\n+\t\truntime_printf(\"runtime.SetFinalizer: first argument is %S, not pointer\\n\", *((Type*)obj._type)->__reflection);\n \t\tgoto throw;\n \t}\n-\tot = (const PtrType*)obj.type;\n+\tot = (const PtrType*)obj._type;\n \t// As an implementation detail we do not run finalizers for zero-sized objects,\n \t// because we use &runtime_zerobase for all such allocations.\n \tif(ot->__element_type != nil && ot->__element_type->__size == 0)\n@@ -937,49 +934,49 @@ func SetFinalizer(obj Eface, finalizer Eface) {\n \t//\t\truntime.SetFinalizer(Foo, nil)\n \t//\t}\n \t// See issue 7656.\n-\tif((byte*)obj.__object < runtime_mheap.arena_start || runtime_mheap.arena_used <= (byte*)obj.__object)\n+\tif((byte*)obj.data < runtime_mheap.arena_start || runtime_mheap.arena_used <= (byte*)obj.data)\n \t\treturn;\n-\tif(!runtime_mlookup(obj.__object, &base, &size, nil) || obj.__object != base) {\n+\tif(!runtime_mlookup(obj.data, &base, &size, nil) || obj.data != base) {\n \t\t// As an implementation detail we allow to set finalizers for an inner byte\n \t\t// of an object if it could come from tiny alloc (see mallocgc for details).\n \t\tif(ot->__element_type == nil || (ot->__element_type->kind&kindNoPointers) == 0 || ot->__element_type->__size >= TinySize) {\n-\t\t\truntime_printf(\"runtime.SetFinalizer: pointer not at beginning of allocated block (%p)\\n\", obj.__object);\n+\t\t\truntime_printf(\"runtime.SetFinalizer: pointer not at beginning of allocated block (%p)\\n\", obj.data);\n \t\t\tgoto throw;\n \t\t}\n \t}\n-\tif(finalizer.__type_descriptor != nil) {\n+\tif((Type*)finalizer._type != nil) {\n \t\truntime_createfing();\n-\t\tif((finalizer.__type_descriptor->kind&kindMask) != GO_FUNC)\n+\t\tif((((Type*)finalizer._type)->kind&kindMask) != GO_FUNC)\n \t\t\tgoto badfunc;\n-\t\tft = (const FuncType*)finalizer.__type_descriptor;\n+\t\tft = (const FuncType*)finalizer._type;\n \t\tif(ft->__dotdotdot || ft->__in.__count != 1)\n \t\t\tgoto badfunc;\n \t\tfint = *(Type**)ft->__in.__values;\n-\t\tif(__go_type_descriptors_equal(fint, obj.__type_descriptor)) {\n+\t\tif(__go_type_descriptors_equal(fint, (Type*)obj._type)) {\n \t\t\t// ok - same type\n-\t\t} else if((fint->kind&kindMask) == GO_PTR && (fint->__uncommon == nil || fint->__uncommon->__name == nil || obj.type->__uncommon == nil || obj.type->__uncommon->__name == nil) && __go_type_descriptors_equal(((const PtrType*)fint)->__element_type, ((const PtrType*)obj.type)->__element_type)) {\n+\t\t} else if((fint->kind&kindMask) == GO_PTR && (fint->__uncommon == nil || fint->__uncommon->__name == nil || ((Type*)obj._type)->__uncommon == nil || ((Type*)obj._type)->__uncommon->__name == nil) && __go_type_descriptors_equal(((const PtrType*)fint)->__element_type, ((const PtrType*)obj._type)->__element_type)) {\n \t\t\t// ok - not same type, but both pointers,\n \t\t\t// one or the other is unnamed, and same element type, so assignable.\n \t\t} else if((fint->kind&kindMask) == GO_INTERFACE && ((const InterfaceType*)fint)->__methods.__count == 0) {\n \t\t\t// ok - satisfies empty interface\n-\t\t} else if((fint->kind&kindMask) == GO_INTERFACE && __go_convert_interface_2(fint, obj.__type_descriptor, 1) != nil) {\n+\t\t} else if((fint->kind&kindMask) == GO_INTERFACE && getitab(fint, (Type*)obj._type, true) != nil) {\n \t\t\t// ok - satisfies non-empty interface\n \t\t} else\n \t\t\tgoto badfunc;\n \n-\t\tot = (const PtrType*)obj.__type_descriptor;\n-\t\tif(!runtime_addfinalizer(obj.__object, *(FuncVal**)finalizer.__object, ft, ot)) {\n+\t\tot = (const PtrType*)obj._type;\n+\t\tif(!runtime_addfinalizer(obj.data, *(FuncVal**)finalizer.data, ft, ot)) {\n \t\t\truntime_printf(\"runtime.SetFinalizer: finalizer already set\\n\");\n \t\t\tgoto throw;\n \t\t}\n \t} else {\n \t\t// NOTE: asking to remove a finalizer when there currently isn't one set is OK.\n-\t\truntime_removefinalizer(obj.__object);\n+\t\truntime_removefinalizer(obj.data);\n \t}\n \treturn;\n \n badfunc:\n-\truntime_printf(\"runtime.SetFinalizer: cannot pass %S to finalizer %S\\n\", *obj.__type_descriptor->__reflection, *finalizer.__type_descriptor->__reflection);\n+\truntime_printf(\"runtime.SetFinalizer: cannot pass %S to finalizer %S\\n\", *((Type*)obj._type)->__reflection, *((Type*)finalizer._type)->__reflection);\n throw:\n \truntime_throw(\"runtime.SetFinalizer\");\n }"}, {"sha": "e5a9dfb07fe04983b15a06d42f2cc5a5f1a07d01", "filename": "libgo/runtime/mgc0.c", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b752cfac4ecf8b620726bfcd703844ebfaca6ea/libgo%2Fruntime%2Fmgc0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b752cfac4ecf8b620726bfcd703844ebfaca6ea/libgo%2Fruntime%2Fmgc0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fmgc0.c?ref=6b752cfac4ecf8b620726bfcd703844ebfaca6ea", "patch": "@@ -62,8 +62,6 @@\n // Slice aka __go_open_array.\n #define array __values\n #define cap __capacity\n-// Iface aka __go_interface\n-#define tab __methods\n // Hmap aka __go_map\n typedef struct __go_map Hmap;\n // Type aka __go_type_descriptor\n@@ -907,12 +905,12 @@ scanblock(Workbuf *wbuf, bool keepworking)\n \t\t\teface = (Eface*)(stack_top.b + pc[1]);\n \t\t\tpc += 2;\n \t\t\tif(Debug > 2)\n-\t\t\t\truntime_printf(\"gc_eface @%p: %p %p\\n\", stack_top.b+pc[1], eface->__type_descriptor, eface->__object);\n-\t\t\tif(eface->__type_descriptor == nil)\n+\t\t\t\truntime_printf(\"gc_eface @%p: %p %p\\n\", stack_top.b+pc[1], eface->_type, eface->data);\n+\t\t\tif(eface->_type == nil)\n \t\t\t\tcontinue;\n \n \t\t\t// eface->type\n-\t\t\tt = eface->__type_descriptor;\n+\t\t\tt = eface->_type;\n \t\t\tif((const byte*)t >= arena_start && (const byte*)t < arena_used) {\n \t\t\t\tunion { const Type *tc; Type *tr; } u;\n \t\t\t\tu.tc = t;\n@@ -921,13 +919,13 @@ scanblock(Workbuf *wbuf, bool keepworking)\n \t\t\t\t\tflushptrbuf(&sbuf);\n \t\t\t}\n \n-\t\t\t// eface->__object\n-\t\t\tif((byte*)eface->__object >= arena_start && (byte*)eface->__object < arena_used) {\n+\t\t\t// eface->data\n+\t\t\tif((byte*)eface->data >= arena_start && (byte*)eface->data < arena_used) {\n \t\t\t\tif(__go_is_pointer_type(t)) {\n \t\t\t\t\tif((t->__code & kindNoPointers))\n \t\t\t\t\t\tcontinue;\n \n-\t\t\t\t\tobj = eface->__object;\n+\t\t\t\t\tobj = eface->data;\n \t\t\t\t\tif((t->__code & kindMask) == kindPtr) {\n \t\t\t\t\t\t// Only use type information if it is a pointer-containing type.\n \t\t\t\t\t\t// This matches the GC programs written by cmd/gc/reflect.c's\n@@ -937,7 +935,7 @@ scanblock(Workbuf *wbuf, bool keepworking)\n \t\t\t\t\t\t\tobjti = (uintptr)((const PtrType*)t)->elem->__gc;\n \t\t\t\t\t}\n \t\t\t\t} else {\n-\t\t\t\t\tobj = eface->__object;\n+\t\t\t\t\tobj = eface->data;\n \t\t\t\t\tobjti = (uintptr)t->__gc;\n \t\t\t\t}\n \t\t\t}\n@@ -947,7 +945,7 @@ scanblock(Workbuf *wbuf, bool keepworking)\n \t\t\tiface = (Iface*)(stack_top.b + pc[1]);\n \t\t\tpc += 2;\n \t\t\tif(Debug > 2)\n-\t\t\t\truntime_printf(\"gc_iface @%p: %p/%p %p\\n\", stack_top.b+pc[1], iface->__methods[0], nil, iface->__object);\n+\t\t\t\truntime_printf(\"gc_iface @%p: %p/%p %p\\n\", stack_top.b+pc[1], *(Type**)iface->tab, nil, iface->data);\n \t\t\tif(iface->tab == nil)\n \t\t\t\tcontinue;\n \t\t\t\n@@ -959,13 +957,13 @@ scanblock(Workbuf *wbuf, bool keepworking)\n \t\t\t}\n \n \t\t\t// iface->data\n-\t\t\tif((byte*)iface->__object >= arena_start && (byte*)iface->__object < arena_used) {\n-\t\t\t\tt = (const Type*)iface->tab[0];\n+\t\t\tif((byte*)iface->data >= arena_start && (byte*)iface->data < arena_used) {\n+\t\t\t\tt = *(Type**)iface->tab;\n \t\t\t\tif(__go_is_pointer_type(t)) {\n \t\t\t\t\tif((t->__code & kindNoPointers))\n \t\t\t\t\t\tcontinue;\n \n-\t\t\t\t\tobj = iface->__object;\n+\t\t\t\t\tobj = iface->data;\n \t\t\t\t\tif((t->__code & kindMask) == kindPtr) {\n \t\t\t\t\t\t// Only use type information if it is a pointer-containing type.\n \t\t\t\t\t\t// This matches the GC programs written by cmd/gc/reflect.c's\n@@ -975,7 +973,7 @@ scanblock(Workbuf *wbuf, bool keepworking)\n \t\t\t\t\t\t\tobjti = (uintptr)((const PtrType*)t)->elem->__gc;\n \t\t\t\t\t}\n \t\t\t\t} else {\n-\t\t\t\t\tobj = iface->__object;\n+\t\t\t\t\tobj = iface->data;\n \t\t\t\t\tobjti = (uintptr)t->__gc;\n \t\t\t\t}\n \t\t\t}\n@@ -2448,8 +2446,8 @@ runfinq(void* dummy __attribute__ ((unused)))\n \tfb = nil;\n \tnext = nil;\n \ti = 0;\n-\tef.__type_descriptor = nil;\n-\tef.__object = nil;\n+\tef._type = nil;\n+\tef.data = nil;\n \t\n \t// force flush to memory\n \tUSED(&f);\n@@ -2483,16 +2481,18 @@ runfinq(void* dummy __attribute__ ((unused)))\n \t\t\t\t\tparam = &f->arg;\n \t\t\t\t} else if(((const InterfaceType*)fint)->__methods.__count == 0) {\n \t\t\t\t\t// convert to empty interface\n-\t\t\t\t\tef.__type_descriptor = (const Type*)f->ot;\n-\t\t\t\t\tef.__object = f->arg;\n+\t\t\t\t\t// using memcpy as const_cast.\n+\t\t\t\t\tmemcpy(&ef._type, &f->ot,\n+\t\t\t\t\t       sizeof ef._type);\n+\t\t\t\t\tef.data = f->arg;\n \t\t\t\t\tparam = &ef;\n \t\t\t\t} else {\n \t\t\t\t\t// convert to interface with methods\n-\t\t\t\t\tiface.__methods = __go_convert_interface_2((const Type*)fint,\n-\t\t\t\t\t\t\t\t\t\t   (const Type*)f->ot,\n-\t\t\t\t\t\t\t\t\t\t   1);\n-\t\t\t\t\tiface.__object = f->arg;\n-\t\t\t\t\tif(iface.__methods == nil)\n+\t\t\t\t\tiface.tab = getitab(fint,\n+\t\t\t\t\t\t\t    (const Type*)f->ot,\n+\t\t\t\t\t\t\t    true);\n+\t\t\t\t\tiface.data = f->arg;\n+\t\t\t\t\tif(iface.data == nil)\n \t\t\t\t\t\truntime_throw(\"invalid type conversion in runfinq\");\n \t\t\t\t\tparam = &iface;\n \t\t\t\t}\n@@ -2514,8 +2514,8 @@ runfinq(void* dummy __attribute__ ((unused)))\n \t\tfb = nil;\n \t\tnext = nil;\n \t\ti = 0;\n-\t\tef.__type_descriptor = nil;\n-\t\tef.__object = nil;\n+\t\tef._type = nil;\n+\t\tef.data = nil;\n \t\truntime_gc(1);\t// trigger another gc to clean up the finalized objects, if possible\n \t}\n }"}, {"sha": "4e493ee810a1ebced4023b58bd9bf67155a8910e", "filename": "libgo/runtime/reflect.goc", "status": "removed", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fceabe505cf0dc7030602e582fadadcce73dd6de/libgo%2Fruntime%2Freflect.goc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fceabe505cf0dc7030602e582fadadcce73dd6de/libgo%2Fruntime%2Freflect.goc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Freflect.goc?ref=fceabe505cf0dc7030602e582fadadcce73dd6de", "patch": "@@ -1,25 +0,0 @@\n-// Copyright 2010 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package reflect\n-#include \"runtime.h\"\n-#include \"go-type.h\"\n-#include \"interface.h\"\n-#include \"go-panic.h\"\n-\n-func ifaceE2I(inter *Type, e Eface, ret *Iface) {\n-\tconst Type *t;\n-\tEface err;\n-\n-\tt = e.__type_descriptor;\n-\tif(t == nil) {\n-\t\t// explicit conversions require non-nil interface value.\n-\t\truntime_newTypeAssertionError(\n-\t\t\tnil, nil, inter->__reflection,\n-\t\t\tnil, &err);\n-\t\truntime_panic(err);\n-\t}\n-\tret->__object = e.__object;\n-\tret->__methods = __go_convert_interface(inter, t);\n-}"}, {"sha": "8a91429e94ad96d9a98dfb4597f778bc19dafe4d", "filename": "libgo/runtime/runtime.h", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b752cfac4ecf8b620726bfcd703844ebfaca6ea/libgo%2Fruntime%2Fruntime.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b752cfac4ecf8b620726bfcd703844ebfaca6ea/libgo%2Fruntime%2Fruntime.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fruntime.h?ref=6b752cfac4ecf8b620726bfcd703844ebfaca6ea", "patch": "@@ -22,7 +22,6 @@\n #include <sys/mman.h>\n #endif\n \n-#include \"interface.h\"\n #include \"go-alloc.h\"\n \n #define _STRINGIFY2_(x) #x\n@@ -76,8 +75,8 @@ typedef\tstruct\tPollDesc\tPollDesc;\n typedef\tstruct\tsudog\t\tSudoG;\n \n typedef\tstruct\t__go_open_array\t\tSlice;\n-typedef struct\t__go_interface\t\tIface;\n-typedef\tstruct\t__go_empty_interface\tEface;\n+typedef\tstruct\tiface\t\t\tIface;\n+typedef\tstruct\teface\t\t\tEface;\n typedef\tstruct\t__go_type_descriptor\tType;\n typedef\tstruct\t_defer\t\t\tDefer;\n typedef\tstruct\t_panic\t\t\tPanic;\n@@ -105,7 +104,6 @@ struct FuncVal\n };\n \n #include \"array.h\"\n-#include \"interface.h\"\n \n // Rename Go types generated by mkrsysinfo.sh from C types, to avoid\n // the name conflict.\n@@ -587,3 +585,7 @@ extern _Bool runtime_iscgo;\n extern _Bool runtime_cgoHasExtraM;\n extern Hchan *runtime_main_init_done;\n extern uintptr __go_end __attribute__ ((weak));\n+extern void *getitab(const struct __go_type_descriptor *,\n+\t\t     const struct __go_type_descriptor *,\n+\t\t     _Bool)\n+  __asm__ (GOSYM_PREFIX \"runtime.getitab\");"}, {"sha": "a83b93ebdb82ba6684f701060911049383017c38", "filename": "libgo/runtime/runtime1.goc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b752cfac4ecf8b620726bfcd703844ebfaca6ea/libgo%2Fruntime%2Fruntime1.goc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b752cfac4ecf8b620726bfcd703844ebfaca6ea/libgo%2Fruntime%2Fruntime1.goc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fruntime1.goc?ref=6b752cfac4ecf8b620726bfcd703844ebfaca6ea", "patch": "@@ -40,7 +40,7 @@ func parForIters(desc *ParFor, tid uintptr) (start uintptr, end uintptr) {\n }\n \n func typestring(e Eface) (s String) {\n-\ts = *e.__type_descriptor->__reflection;\n+\ts = *((Type*)e._type)->__reflection;\n }\n \n func golockedOSThread() (ret bool) {"}]}