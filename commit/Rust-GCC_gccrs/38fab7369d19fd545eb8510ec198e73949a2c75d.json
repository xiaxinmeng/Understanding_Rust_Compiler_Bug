{"sha": "38fab7369d19fd545eb8510ec198e73949a2c75d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzhmYWI3MzY5ZDE5ZmQ1NDVlYjg1MTBlYzE5OGU3Mzk0OWEyYzc1ZA==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2018-09-13T22:06:16Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2018-09-13T22:06:16Z"}, "message": "runtime: correct counters in sweep\n    \n    In the sweep code we can sometimes see incorrect counts when\n    conservative stack scanning causes us to grey an object that we\n    earlier decided could be freed.  We already ignored this check, but\n    adjust this case to maintain correct span counts when it happens.\n    This gives us slightly more correct numbers in MemStats, and helps\n    avoid a rare failure in TestReadMemStats.\n    \n    Also fix the free index, and cope with finding a full span when\n    allocating a new one.\n    \n    Reviewed-on: https://go-review.googlesource.com/134216\n\nFrom-SVN: r264294", "tree": {"sha": "39d19743a7f211c9c8b196184a333a57a9b2d6ba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/39d19743a7f211c9c8b196184a333a57a9b2d6ba"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/38fab7369d19fd545eb8510ec198e73949a2c75d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38fab7369d19fd545eb8510ec198e73949a2c75d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/38fab7369d19fd545eb8510ec198e73949a2c75d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38fab7369d19fd545eb8510ec198e73949a2c75d/comments", "author": null, "committer": null, "parents": [{"sha": "84b5706abb8f5dff634e588071ab4fef080cd05e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84b5706abb8f5dff634e588071ab4fef080cd05e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/84b5706abb8f5dff634e588071ab4fef080cd05e"}], "stats": {"total": 37, "additions": 28, "deletions": 9}, "files": [{"sha": "9a789b970e054e3be3350e71f52330828fc03e1a", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38fab7369d19fd545eb8510ec198e73949a2c75d/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38fab7369d19fd545eb8510ec198e73949a2c75d/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=38fab7369d19fd545eb8510ec198e73949a2c75d", "patch": "@@ -1,4 +1,4 @@\n-f2cd046a4e0d681c3d21ee547b437d3eab8af268\n+82d7205ba9e5c1fe38fd24f89a45caf2e974975b\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "150f4fd8ae3a9d178f8b30499489e0ca4ba3e698", "filename": "libgo/go/runtime/mcentral.go", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38fab7369d19fd545eb8510ec198e73949a2c75d/libgo%2Fgo%2Fruntime%2Fmcentral.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38fab7369d19fd545eb8510ec198e73949a2c75d/libgo%2Fgo%2Fruntime%2Fmcentral.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fmcentral.go?ref=38fab7369d19fd545eb8510ec198e73949a2c75d", "patch": "@@ -56,6 +56,15 @@ retry:\n \t\t\tc.empty.insertBack(s)\n \t\t\tunlock(&c.lock)\n \t\t\ts.sweep(true)\n+\n+\t\t\t// With gccgo's conservative GC, the returned span may\n+\t\t\t// now be full. See the comments in mspan.sweep.\n+\t\t\tif uintptr(s.allocCount) == s.nelems {\n+\t\t\t\ts.freeindex = s.nelems\n+\t\t\t\tlock(&c.lock)\n+\t\t\t\tgoto retry\n+\t\t\t}\n+\n \t\t\tgoto havespan\n \t\t}\n \t\tif s.sweepgen == sg-1 {"}, {"sha": "d6be349a959391802fc995b92d5298fd523550db", "filename": "libgo/go/runtime/mgcsweep.go", "status": "modified", "additions": 18, "deletions": 8, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38fab7369d19fd545eb8510ec198e73949a2c75d/libgo%2Fgo%2Fruntime%2Fmgcsweep.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38fab7369d19fd545eb8510ec198e73949a2c75d/libgo%2Fgo%2Fruntime%2Fmgcsweep.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fmgcsweep.go?ref=38fab7369d19fd545eb8510ec198e73949a2c75d", "patch": "@@ -296,7 +296,7 @@ func (s *mspan) sweep(preserve bool) bool {\n \t}\n \tnfreed := s.allocCount - nalloc\n \n-\t// This test is not reliable with gccgo, because of\n+\t// This check is not reliable with gccgo, because of\n \t// conservative stack scanning. The test boils down to\n \t// checking that no new bits have been set in gcmarkBits since\n \t// the span was added to the sweep count. New bits are set by\n@@ -309,16 +309,23 @@ func (s *mspan) sweep(preserve bool) bool {\n \t// check to be inaccurate, and it will keep an object live\n \t// unnecessarily, but provided the pointer is not really live\n \t// it is not otherwise a problem. So we disable the test for gccgo.\n-\tif false && nalloc > s.allocCount {\n-\t\tprint(\"runtime: nelems=\", s.nelems, \" nalloc=\", nalloc, \" previous allocCount=\", s.allocCount, \" nfreed=\", nfreed, \"\\n\")\n-\t\tthrow(\"sweep increased allocation count\")\n+\tnfreedSigned := int(nfreed)\n+\tif nalloc > s.allocCount {\n+\t\t// print(\"runtime: nelems=\", s.nelems, \" nalloc=\", nalloc, \" previous allocCount=\", s.allocCount, \" nfreed=\", nfreed, \"\\n\")\n+\t\t// throw(\"sweep increased allocation count\")\n+\n+\t\t// For gccgo, adjust the freed count as a signed number.\n+\t\tnfreedSigned = int(s.allocCount) - int(nalloc)\n+\t\tif uintptr(nalloc) == s.nelems {\n+\t\t\ts.freeindex = s.nelems\n+\t\t}\n \t}\n \n \ts.allocCount = nalloc\n \twasempty := s.nextFreeIndex() == s.nelems\n \ts.freeindex = 0 // reset allocation index to start of span.\n \tif trace.enabled {\n-\t\tgetg().m.p.ptr().traceReclaimed += uintptr(nfreed) * s.elemsize\n+\t\tgetg().m.p.ptr().traceReclaimed += uintptr(nfreedSigned) * s.elemsize\n \t}\n \n \t// gcmarkBits becomes the allocBits.\n@@ -334,7 +341,7 @@ func (s *mspan) sweep(preserve bool) bool {\n \t// But we need to set it before we make the span available for allocation\n \t// (return it to heap or mcentral), because allocation code assumes that a\n \t// span is already swept if available for allocation.\n-\tif freeToHeap || nfreed == 0 {\n+\tif freeToHeap || nfreedSigned <= 0 {\n \t\t// The span must be in our exclusive ownership until we update sweepgen,\n \t\t// check for potential races.\n \t\tif s.state != mSpanInUse || s.sweepgen != sweepgen-1 {\n@@ -347,8 +354,11 @@ func (s *mspan) sweep(preserve bool) bool {\n \t\tatomic.Store(&s.sweepgen, sweepgen)\n \t}\n \n-\tif nfreed > 0 && spc.sizeclass() != 0 {\n-\t\tc.local_nsmallfree[spc.sizeclass()] += uintptr(nfreed)\n+\tif spc.sizeclass() != 0 {\n+\t\tc.local_nsmallfree[spc.sizeclass()] += uintptr(nfreedSigned)\n+\t}\n+\n+\tif nfreedSigned > 0 && spc.sizeclass() != 0 {\n \t\tres = mheap_.central[spc].mcentral.freeSpan(s, preserve, wasempty)\n \t\t// MCentral_FreeSpan updates sweepgen\n \t} else if freeToHeap {"}]}