{"sha": "ffb0e73a97aacc285d5cb176af65359b3329739b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmZiMGU3M2E5N2FhY2MyODVkNWNiMTc2YWY2NTM1OWIzMzI5NzM5Yg==", "commit": {"author": {"name": "Mark Wielaard", "email": "mark@klomp.org", "date": "2001-10-05T00:16:03Z"}, "committer": {"name": "Mark Wielaard", "email": "mark@gcc.gnu.org", "date": "2001-10-05T00:16:03Z"}, "message": "* java/lang/reflect/Modifier.java: Merge with Classpath\n\nFrom-SVN: r46019", "tree": {"sha": "a218d47721857a3781cd6f84a51fe89890c5b6ca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a218d47721857a3781cd6f84a51fe89890c5b6ca"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ffb0e73a97aacc285d5cb176af65359b3329739b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ffb0e73a97aacc285d5cb176af65359b3329739b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ffb0e73a97aacc285d5cb176af65359b3329739b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ffb0e73a97aacc285d5cb176af65359b3329739b/comments", "author": null, "committer": null, "parents": [{"sha": "d6c0ca38c0a02f041dca3ffa40634fdd7b649cb7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6c0ca38c0a02f041dca3ffa40634fdd7b649cb7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d6c0ca38c0a02f041dca3ffa40634fdd7b649cb7"}], "stats": {"total": 204, "additions": 176, "deletions": 28}, "files": [{"sha": "1e2405c0f4510c97219502e486377af25c6f7b72", "filename": "libjava/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffb0e73a97aacc285d5cb176af65359b3329739b/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffb0e73a97aacc285d5cb176af65359b3329739b/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=ffb0e73a97aacc285d5cb176af65359b3329739b", "patch": "@@ -1,3 +1,7 @@\n+2001-10-04  Mark Wielaard  <mark@klomp.org>\n+\n+\t* java/lang/reflect/Modifier.java: Merge with Classpath\n+\n 2001-10-03  Mark Wielaard  <mark@klomp.org>\n \n \t* java/io/SequenceInputStream.java: Merge with Classpath"}, {"sha": "2724057474b1023278ceec9f9b9aad3f868e9bf7", "filename": "libjava/java/lang/reflect/Modifier.java", "status": "modified", "additions": 172, "deletions": 28, "changes": 200, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffb0e73a97aacc285d5cb176af65359b3329739b/libjava%2Fjava%2Flang%2Freflect%2FModifier.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffb0e73a97aacc285d5cb176af65359b3329739b/libjava%2Fjava%2Flang%2Freflect%2FModifier.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Freflect%2FModifier.java?ref=ffb0e73a97aacc285d5cb176af65359b3329739b", "patch": "@@ -1,111 +1,255 @@\n-// Modifier.java - Process modifier values.\n+/* java.lang.reflect.Modifier\n+   Copyright (C) 1998, 1999, 2001 Free Software Foundation, Inc.\n \n-/* Copyright (C) 1998, 1999  Free Software Foundation\n+This file is part of GNU Classpath.\n \n-   This file is part of libgcj.\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n \n-This software is copyrighted work licensed under the terms of the\n-Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n-details.  */\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n \n-/**\n- * @author Tom Tromey <tromey@cygnus.com>\n- * @date October 1, 1998\n- */\n+\n+package java.lang.reflect;\n \n /* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3\n  * \"The Java Language Specification\", ISBN 0-201-63451-1\n  * plus online API docs for JDK 1.2 beta from http://www.javasoft.com.\n  * Status: Believed complete and correct to version 1.2.\n  */\n \n-package java.lang.reflect;\n-\n+/**\n+ * Modifier is a helper class with static methods to determine whether an\n+ * int returned from getModifiers() represents static, public, protected,\n+ * native, final, etc... and provides an additional method to print\n+ * out all of the modifiers in an int in order.\n+ * <p>\n+ * The methods in this class use the bitmask values in the VM spec to\n+ * determine the modifiers of an int. This means that a VM must return a\n+ * standard mask, conformant with the VM spec.  I don't know if this is how\n+ * Sun does it, but I'm willing to bet money that it is.\n+ *\n+ * @author John Keiser\n+ * @author Tom Tromey <tromey@cygnus.com>\n+ *\n+ * @see Member#getModifiers()\n+ * @see Method#getModifiers()\n+ * @see Field#getModifiers()\n+ * @see Constructor#getModifiers()\n+ * @see Class#getModifiers()\n+ */\n public class Modifier\n {\n-  public static final int PUBLIC    = 0x001;\n-  public static final int PRIVATE   = 0x002;\n-  public static final int PROTECTED = 0x004;\n-  public static final int STATIC    = 0x008;\n-  public static final int FINAL     = 0x010;\n-  public static final int SYNCHRONIZED = 0x020;\n-  public static final int VOLATILE  = 0x040;\n-  public static final int TRANSIENT = 0x080;\n-  public static final int NATIVE    = 0x100;\n-  public static final int INTERFACE = 0x200;\n-  public static final int ABSTRACT  = 0x400;\n-  public static final int STRICT    = 0x800;\n-\n-  // This is only used by the C++ code, so it is not public.\n+  /** <STRONG>This constructor really shouldn't be here ... there are no\n+   * instance methods or variables of this class, so instantiation is\n+   * worthless.  However, this function is in the 1.1 spec, so it is added\n+   * for completeness.</STRONG>\n+   */\n+  public Modifier() {}\n+\n+  /** Public: accessible from any other class. **/\n+  public static final int PUBLIC = 0x0001;\n+\n+  /** Private: accessible only from the declaring class. **/\n+  public static final int PRIVATE = 0x0002;\n+\n+  /** Protected: accessible only to subclasses. **/\n+  public static final int PROTECTED = 0x0004;\n+\n+  /** Static: field or method - can be accessed or invoked without an\n+      instance of the declaring class. **/\n+  public static final int STATIC = 0x0008;\n+\n+  /** Final:<BR>\n+   * <UL>\n+   * <LI> Class: no subclasses allowed. </LI>\n+   * <LI> Field: cannot be changed. </LI>\n+   * <LI> Method: cannot be overriden. </LI>\n+   * </UL>\n+   */\n+  public static final int FINAL = 0x0010;\n+\n+  /** Synchronized: lock the class while calling this method. **/\n+  public static final int SYNCHRONIZED = 0x0020;\n+\n+  /** Volatile: cannot be cached.<P> **/\n+  public static final int VOLATILE = 0x0040;\n+\n+  /** Transient: not serialized or deserialized. **/\n+  public static final int TRANSIENT = 0x0080;\n+\n+  /** Native: use JNI to call this method. **/\n+  public static final int NATIVE = 0x0100;\n+\n+  /** Interface: is an interface. **/\n+  public static final int INTERFACE = 0x0200;\n+\n+  /** Abstract: class - may not be instantiated;\n+      method - may not be called. **/\n+  public static final int ABSTRACT = 0x0400;\n+\n+  /** Class or method - expressions are FP-strict. **/\n+  public static final int STRICT = 0x0800;\n+\n+\n+  /* NOTE: THIS IS HERE BECAUSE IT IS IN THE VM SPEC.\n+     I INCLUDE IT FOR COMPLETENESS.  IT ATTACHES TO A CLASS AND MEANS\n+     \"Treat superclasses specially in invokespecial\". Note that it is the\n+     same as synchronized.  Reuse of the constant.  *shudder* */\n+  private static final int SUPER = 0x0020;\n+\n+  // This can only used by other code in this package, so it is not public.\n   static final int ALL_FLAGS = 0xfff;\n \n+  /** Check whether the given modifier is abstract.\n+   * @param mod the modifier.\n+   * @return <code>true</code> if abstract, <code>false</code> otherwise.\n+   */\n   public static boolean isAbstract (int mod)\n   {\n     return (mod & ABSTRACT) != 0;\n   }\n \n+  /** Check whether the given modifier is final.\n+   * @param mod the modifier.\n+   * @return <code>true</code> if final, <code>false</code> otherwise.\n+   */\n   public static boolean isFinal (int mod)\n   {\n     return (mod & FINAL) != 0;\n   }\n \n+  /** Check whether the given modifier is an interface.\n+   * @param mod the modifier.\n+   * @return <code>true</code> if an interface, <code>false</code> otherwise.\n+   */\n   public static boolean isInterface (int mod)\n   {\n     return (mod & INTERFACE) != 0;\n   }\n \n+  /** Check whether the given modifier is native.\n+   * @param mod the modifier.\n+   * @return <code>true</code> if native, <code>false</code> otherwise.\n+   */\n   public static boolean isNative (int mod)\n   {\n     return (mod & NATIVE) != 0;\n   }\n \n+  /** Check whether the given modifier is private.\n+   * @param mod the modifier.\n+   * @return <code>true</code> if private, <code>false</code> otherwise.\n+   */\n   public static boolean isPrivate (int mod)\n   {\n     return (mod & PRIVATE) != 0;\n   }\n \n+  /** Check whether the given modifier is protected.\n+   * @param mod the modifier.\n+   * @return <code>true</code> if protected, <code>false</code> otherwise.\n+   */\n   public static boolean isProtected (int mod)\n   {\n     return (mod & PROTECTED) != 0;\n   }\n \n+  /** Check whether the given modifier is public.\n+   * @param mod the modifier.\n+   * @return <code>true</code> if public, <code>false</code> otherwise.\n+   */\n   public static boolean isPublic (int mod)\n   {\n     return (mod & PUBLIC) != 0;\n   }\n \n+  /** Check whether the given modifier is static.\n+   * @param mod the modifier.\n+   * @return <code>true</code> if static, <code>false</code> otherwise.\n+   */\n   public static boolean isStatic (int mod)\n   {\n     return (mod & STATIC) != 0;\n   }\n \n+  /** Check whether the given modifier is strictfp.\n+   * @param mod the modifier.\n+   * @return <code>true</code> if strictfp, <code>false</code> otherwise.\n+   */\n   public static boolean isStrict (int mod)\n   {\n     return (mod & STRICT) != 0;\n   }\n \n+  /** Check whether the given modifier is synchronized.\n+   * @param mod the modifier.\n+   * @return <code>true</code> if synchronized, <code>false</code> otherwise.\n+   */\n   public static boolean isSynchronized (int mod)\n   {\n     return (mod & SYNCHRONIZED) != 0;\n   }\n \n+  /** Check whether the given modifier is transient.\n+   * @param mod the modifier.\n+   * @return <code>true</code> if transient, <code>false</code> otherwise.\n+   */\n   public static boolean isTransient (int mod)\n   {\n     return (mod & TRANSIENT) != 0;\n   }\n \n+  /** Check whether the given modifier is volatile.\n+   * @param mod the modifier.\n+   * @return <code>true</code> if volatile, <code>false</code> otherwise.\n+   */\n   public static boolean isVolatile (int mod)\n   {\n     return (mod & VOLATILE) != 0;\n   }\n \n+  /** Get a string representation of all the modifiers represented by the\n+   * given int.\n+   * The keywords are printed in this order:\n+   * <code>&lt;public|private|protected&gt; abstract static final transient\n+   * volatile native synchronized interface strictfp</code><P>\n+   *\n+   * <STRONG>This is, near as I can tell, the \"canonical order\" of modifiers\n+   * mentioned by Sun in the reference implementation.  I have inferred this\n+   * from the order of printing in the Field, Method and Constructor\n+   * classes.</STRONG>\n+   *\n+   * @param mod the modifier.\n+   * @return the String representing the modifiers.\n+   */\n   public static String toString (int mod)\n   {\n     StringBuffer r = new StringBuffer ();\n     toString(mod, r);\n     return r.toString();\n   }\n \n+  /**\n+   * Package private helper toString() method that can take a StringBuffer.\n+   * @param mod the modifier\n+   * @param r the StringBuffer to which the String representation is appended\n+   */\n   static void toString (int mod, StringBuffer r)\n   {\n     if (isPublic (mod))\n@@ -131,8 +275,8 @@ static void toString (int mod, StringBuffer r)\n     if (isInterface (mod))\n       r.append(\"interface \");\n     if (isStrict (mod))\n-      r.append(\"strict \");\n-\n+      r.append(\"strictfp \");\n+    \n     // Trim trailing space.\n     int l = r.length();\n     if (l > 0)"}]}