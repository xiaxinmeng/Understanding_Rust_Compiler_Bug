{"sha": "2ce6dc2f6aa48acf42384a35e3ccc565c0677699", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmNlNmRjMmY2YWE0OGFjZjQyMzg0YTM1ZTNjY2M1NjVjMDY3NzY5OQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2000-04-17T13:00:44Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2000-04-17T13:00:44Z"}, "message": "cse.c (struct check_depdendence_data): New.\n\n\t* cse.c (struct check_depdendence_data): New.\n\t(check_dependence): New function.\n\t(invalidate): Use check_depdenence.\n\nFrom-SVN: r33207", "tree": {"sha": "5c29618c8a861a4968c8e9f96ee5398418ce8dfc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5c29618c8a861a4968c8e9f96ee5398418ce8dfc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2ce6dc2f6aa48acf42384a35e3ccc565c0677699", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ce6dc2f6aa48acf42384a35e3ccc565c0677699", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2ce6dc2f6aa48acf42384a35e3ccc565c0677699", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ce6dc2f6aa48acf42384a35e3ccc565c0677699/comments", "author": null, "committer": null, "parents": [{"sha": "44ee20072859dc8c64da9934b69476fe3d49b0d3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44ee20072859dc8c64da9934b69476fe3d49b0d3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/44ee20072859dc8c64da9934b69476fe3d49b0d3"}], "stats": {"total": 49, "additions": 36, "deletions": 13}, "files": [{"sha": "afe17c6537f50c47571063a3be0d47b7266008b4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ce6dc2f6aa48acf42384a35e3ccc565c0677699/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ce6dc2f6aa48acf42384a35e3ccc565c0677699/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2ce6dc2f6aa48acf42384a35e3ccc565c0677699", "patch": "@@ -1,3 +1,9 @@\n+Mon Apr 17 14:59:36 MET DST 2000  Jan Hubicka  <jh@suse.cz>\n+\n+\t* cse.c (struct check_depdendence_data): New.\n+\t(check_dependence): New function.\n+\t(invalidate): Use check_depdenence.\n+\n 2000-04-16  Mark Mitchell  <mark@codesourcery.com>\n \n \t* dwarf2out.c (DWARF_CIE_DATA_ALIGNMENT): Adjust, now that"}, {"sha": "89b812d9951417ed0c724a048250869ba5a8d28f", "filename": "gcc/cse.c", "status": "modified", "additions": 30, "deletions": 13, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ce6dc2f6aa48acf42384a35e3ccc565c0677699/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ce6dc2f6aa48acf42384a35e3ccc565c0677699/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=2ce6dc2f6aa48acf42384a35e3ccc565c0677699", "patch": "@@ -705,6 +705,7 @@ static rtx cse_basic_block\tPARAMS ((rtx, rtx, struct branch_path *, int));\n static void count_reg_usage\tPARAMS ((rtx, int *, rtx, int));\n extern void dump_class          PARAMS ((struct table_elt*));\n static struct cse_reg_info * get_cse_reg_info PARAMS ((unsigned int));\n+static int check_dependence\tPARAMS ((rtx *, void *));\n \n static void flush_hash_table\tPARAMS ((void));\n \f\n@@ -1721,6 +1722,24 @@ flush_hash_table ()\n       }\n }\n \f\n+/* Function called for each rtx to check whether true dependence exist.  */\n+struct check_dependence_data\n+{\n+  enum machine_mode mode;\n+  rtx exp;\n+};\n+static int\n+check_dependence (x, data)\n+     rtx *x;\n+     void *data;\n+{\n+  struct check_dependence_data *d = (struct check_dependence_data *) data;\n+  if (*x && GET_CODE (*x) == MEM)\n+    return true_dependence (d->exp, d->mode, *x, cse_rtx_varies_p);\n+  else\n+    return 0;\n+}\n+\f\n /* Remove from the hash table, or mark as invalid, all expressions whose\n    values could be altered by storing in X.  X is a register, a subreg, or\n    a memory reference with nonvarying address (because, when a memory\n@@ -1846,20 +1865,18 @@ invalidate (x, full_mode)\n \t      next = p->next_same_hash;\n \t      if (p->in_memory)\n \t\t{\n-\t\t  if (GET_CODE (p->exp) != MEM)\n+\t\t  struct check_dependence_data d;\n+\n+\t\t  /* Just canonicalize the expression once;\n+\t\t     otherwise each time we call invalidate\n+\t\t     true_dependence will canonicalize the\n+\t\t     expression again.  */\n+\t\t  if (!p->canon_exp)\n+\t\t    p->canon_exp = canon_rtx (p->exp);\n+\t\t  d.exp = x;\n+\t\t  d.mode = full_mode;\n+\t\t  if (for_each_rtx (&p->canon_exp, check_dependence, &d))\n \t\t    remove_from_table (p, i);\n-\t\t  else \n-\t\t    {\n-\t\t      /* Just canonicalize the expression once;\n-\t\t\t otherwise each time we call invalidate\n-\t\t\t true_dependence will canonicalize the\n-\t\t\t expression again.  */\n-\t\t      if (!p->canon_exp)\n-\t\t\tp->canon_exp = canon_rtx (p->exp);\n-\t\t      if (true_dependence (x, full_mode, p->canon_exp,\n-\t\t\t\t\t   cse_rtx_varies_p))\n-\t\t\tremove_from_table (p, i);\n-\t\t    }\n \t\t}\n \t    }\n \t}"}]}