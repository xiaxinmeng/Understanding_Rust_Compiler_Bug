{"sha": "01b5038718056b024b370b74a874fbd92c5bbab3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDFiNTAzODcxODA1NmIwMjRiMzcwYjc0YTg3NGZiZDkyYzViYmFiMw==", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2021-09-09T18:30:28Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2021-09-10T16:41:51Z"}, "message": "Disable threading through latches until after loop optimizations.\n\nThe motivation for this patch was enabling the use of global ranges in\nthe path solver, but this caused certain properties of loops being\ndestroyed which made subsequent loop optimizations to fail.\nConsequently, this patch's mail goal is to disable jump threading\ninvolving the latch until after loop optimizations have run.\n\nAs can be seen in the test adjustments, we mostly shift the threading\nfrom the early threaders (ethread, thread[12] to the late threaders\nthread[34]).  I have nuked some of the early notes in the testcases\nthat came as part of the jump threader rewrite.  They're mostly noise\nnow.\n\nNote that we could probably relax some other restrictions in\nprofitable_path_p when loop optimizations have completed, but it would\nrequire more testing, and I'm hesitant to touch more things than needed\nat this point.  I have added a reminder to the function to keep this\nin mind.\n\nFinally, perhaps as a follow-up, we should apply the same restrictions to\nthe forward threader.  At some point I'd like to combine the cost models.\n\nTested on x86-64 Linux.\n\np.s. There is a thorough discussion involving the limitations of jump\nthreading involving loops here:\n\n\thttps://gcc.gnu.org/pipermail/gcc/2021-September/237247.html\n\ngcc/ChangeLog:\n\n\t* tree-pass.h (PROP_loop_opts_done): New.\n\t* gimple-range-path.cc (path_range_query::internal_range_of_expr):\n\tIntersect with global range.\n\t* tree-ssa-loop.c (tree_ssa_loop_done): Set PROP_loop_opts_done.\n\t* tree-ssa-threadbackward.c\n\t(back_threader_profitability::profitable_path_p): Disable\n\tthreading through latches until after loop optimizations have run.\n\ngcc/testsuite/ChangeLog:\n\n\t* gcc.dg/tree-ssa/ssa-dom-thread-2b.c: Adjust for disabling of\n\tthreading through latches.\n\t* gcc.dg/tree-ssa/ssa-dom-thread-6.c: Same.\n\t* gcc.dg/tree-ssa/ssa-dom-thread-7.c: Same.\n\nCo-authored-by: Michael Matz <matz@suse.de>", "tree": {"sha": "327cf6de3914007cedd4483b4b248c25a448fc79", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/327cf6de3914007cedd4483b4b248c25a448fc79"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/01b5038718056b024b370b74a874fbd92c5bbab3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01b5038718056b024b370b74a874fbd92c5bbab3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/01b5038718056b024b370b74a874fbd92c5bbab3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01b5038718056b024b370b74a874fbd92c5bbab3/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fb88bf9931f17d137eb50c001e1c924aa1e34e83", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb88bf9931f17d137eb50c001e1c924aa1e34e83", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fb88bf9931f17d137eb50c001e1c924aa1e34e83"}], "stats": {"total": 93, "additions": 37, "deletions": 56}, "files": [{"sha": "c616b65756fcc82ad5a111b0300d6f481478f0de", "filename": "gcc/gimple-range-path.cc", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01b5038718056b024b370b74a874fbd92c5bbab3/gcc%2Fgimple-range-path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01b5038718056b024b370b74a874fbd92c5bbab3/gcc%2Fgimple-range-path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-path.cc?ref=01b5038718056b024b370b74a874fbd92c5bbab3", "patch": "@@ -127,6 +127,9 @@ path_range_query::internal_range_of_expr (irange &r, tree name, gimple *stmt)\n   basic_block bb = stmt ? gimple_bb (stmt) : exit_bb ();\n   if (stmt && range_defined_in_block (r, name, bb))\n     {\n+      if (TREE_CODE (name) == SSA_NAME)\n+\tr.intersect (gimple_range_global (name));\n+\n       set_cache (r, name);\n       return true;\n     }"}, {"sha": "823ada982ff6a4be4cea54011843445afe81f9fb", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-dom-thread-2b.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01b5038718056b024b370b74a874fbd92c5bbab3/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-thread-2b.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01b5038718056b024b370b74a874fbd92c5bbab3/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-thread-2b.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-thread-2b.c?ref=01b5038718056b024b370b74a874fbd92c5bbab3", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */ \n-/* { dg-options \"-O2 -fdump-tree-thread1-stats -fdump-tree-dom2-stats -fdisable-tree-ethread\" } */\n+/* { dg-options \"-O2 -fdump-tree-thread3-stats -fdump-tree-dom2-stats -fdisable-tree-ethread\" } */\n \n void foo();\n void bla();\n@@ -26,4 +26,4 @@ void thread_latch_through_header (void)\n    case.  And we want to thread through the header as well.  These\n    are both caught by threading in DOM.  */\n /* { dg-final { scan-tree-dump-not \"Jumps threaded\" \"dom2\"} } */\n-/* { dg-final { scan-tree-dump-times \"Jumps threaded: 1\" 1 \"thread1\"} } */\n+/* { dg-final { scan-tree-dump-times \"Jumps threaded: 1\" 1 \"thread3\"} } */"}, {"sha": "ee46759bacc1c1a123cca006defd3bd04d388658", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-dom-thread-6.c", "status": "modified", "additions": 2, "deletions": 35, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01b5038718056b024b370b74a874fbd92c5bbab3/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-thread-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01b5038718056b024b370b74a874fbd92c5bbab3/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-thread-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-thread-6.c?ref=01b5038718056b024b370b74a874fbd92c5bbab3", "patch": "@@ -1,41 +1,8 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fdump-tree-thread1-details -fdump-tree-thread2-details\" } */\n+/* { dg-options \"-O2 -fdump-tree-thread1-details -fdump-tree-thread3-details\" } */\n \n-/* All the threads in the thread1 dump start on a X->BB12 edge, as can\n-   be seen in the dump:\n-\n-     Registering FSM jump thread: (x, 12) incoming edge; ...\n-     etc\n-     etc\n-\n-   Before the new evrp, we were threading paths that started at the\n-   following edges:\n-\n-      Registering FSM jump thread: (10, 12) incoming edge\n-      Registering FSM jump thread:  (6, 12) incoming edge\n-      Registering FSM jump thread:  (9, 12) incoming edge\n-\n-   This was because the PHI at BB12 had constant values coming in from\n-   BB10, BB6, and BB9:\n-\n-   # state_10 = PHI <state_11(7), 0(10), state_11(5), 1(6), state_11(8), 2(9), state_11(11)>\n-\n-   Now with the new evrp, we get:\n-\n-   # state_10 = PHI <0(7), 0(10), state_11(5), 1(6), 0(8), 2(9), 1(11)>\n-\n-   Thus, we have 3 more paths that are known to be constant and can be\n-   threaded.  Which means that by the second threading pass, we can\n-   only find one profitable path.\n-\n-   For the record, all these extra constants are better paths coming\n-   out of switches.  For example:\n-\n-     SWITCH_BB -> BBx -> BBy -> BBz -> PHI\n-\n-   We now know the value of the switch index at PHI.  */\n /* { dg-final { scan-tree-dump-times \"Registering FSM jump\" 6 \"thread1\" } } */\n-/* { dg-final { scan-tree-dump-times \"Registering FSM jump\" 1 \"thread2\" } } */\n+/* { dg-final { scan-tree-dump-times \"Registering FSM jump\" 1 \"thread3\" } } */\n \n int sum0, sum1, sum2, sum3;\n int foo (char *s, char **ret)"}, {"sha": "ba07942f9dd7e22aeca35cefce6d766d9423a969", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-dom-thread-7.c", "status": "modified", "additions": 1, "deletions": 16, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01b5038718056b024b370b74a874fbd92c5bbab3/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-thread-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01b5038718056b024b370b74a874fbd92c5bbab3/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-thread-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dom-thread-7.c?ref=01b5038718056b024b370b74a874fbd92c5bbab3", "patch": "@@ -1,23 +1,8 @@\n /* { dg-do compile } */\n /* { dg-options \"-O2 -fdump-tree-thread1-stats -fdump-tree-thread2-stats -fdump-tree-dom2-stats -fdump-tree-thread3-stats -fdump-tree-dom3-stats -fdump-tree-vrp2-stats -fno-guess-branch-probability\" } */\n \n-/* Here we have the same issue as was commented in ssa-dom-thread-6.c.\n-   The PHI coming into the threader has a lot more constants, so the\n-   threader can thread more paths.\n-\n-$ diff clean/a.c.105t.mergephi2 a.c.105t.mergephi2 \n-252c252\n-<   # s_50 = PHI <s_49(10), 5(14), s_51(18), s_51(22), 1(26), 1(29), 1(31), s_51(5), 4(12), 1(15), 5(17), 1(19), 3(21), 1(23), 6(25), 7(28), s_51(30)>\n----\n->   # s_50 = PHI <s_49(10), 5(14), 4(18), 5(22), 1(26), 1(29), 1(31), s_51(5), 4(12), 1(15), 5(17), 1(19), 3(21), 1(23), 6(25), 7(28), 7(30)>\n-272a273\n-\n-  I spot checked a few and they all have the same pattern.  We are\n-  basically tracking the switch index better through multiple\n-  paths.  */\n-\n /* { dg-final { scan-tree-dump \"Jumps threaded: 18\"  \"thread1\" } } */\n-/* { dg-final { scan-tree-dump \"Jumps threaded: 8\" \"thread2\" } } */\n+/* { dg-final { scan-tree-dump \"Jumps threaded: 8\" \"thread3\" } } */\n /* { dg-final { scan-tree-dump-not \"Jumps threaded\"  \"dom2\" } } */\n \n /* aarch64 has the highest CASE_VALUES_THRESHOLD in GCC.  It's high enough"}, {"sha": "eb75eb179516dce212b308b683c3b71a472f885e", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01b5038718056b024b370b74a874fbd92c5bbab3/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01b5038718056b024b370b74a874fbd92c5bbab3/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=01b5038718056b024b370b74a874fbd92c5bbab3", "patch": "@@ -225,6 +225,8 @@ class simple_ipa_opt_pass : public opt_pass\n \t\t\t\t\t\t   been optimized.  */\n #define PROP_gimple_lomp_dev\t(1 << 16)\t/* done omp_device_lower */\n #define PROP_rtl_split_insns\t(1 << 17)\t/* RTL has insns split.  */\n+#define PROP_loop_opts_done\t(1 << 18)\t/* SSA loop optimizations\n+\t\t\t\t\t\t   have completed.  */\n \n #define PROP_gimple \\\n   (PROP_gimple_any | PROP_gimple_lcf | PROP_gimple_leh | PROP_gimple_lomp)"}, {"sha": "1bbf2f1fb2c8dde790906813a7908bd7deb13b3f", "filename": "gcc/tree-ssa-loop.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01b5038718056b024b370b74a874fbd92c5bbab3/gcc%2Ftree-ssa-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01b5038718056b024b370b74a874fbd92c5bbab3/gcc%2Ftree-ssa-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop.c?ref=01b5038718056b024b370b74a874fbd92c5bbab3", "patch": "@@ -540,7 +540,7 @@ const pass_data pass_data_tree_loop_done =\n   OPTGROUP_LOOP, /* optinfo_flags */\n   TV_NONE, /* tv_id */\n   PROP_cfg, /* properties_required */\n-  0, /* properties_provided */\n+  PROP_loop_opts_done, /* properties_provided */\n   0, /* properties_destroyed */\n   0, /* todo_flags_start */\n   TODO_cleanup_cfg, /* todo_flags_finish */"}, {"sha": "e72992328de6ab20a864b6b17cfb4a32b6d4c3ec", "filename": "gcc/tree-ssa-threadbackward.c", "status": "modified", "additions": 26, "deletions": 2, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01b5038718056b024b370b74a874fbd92c5bbab3/gcc%2Ftree-ssa-threadbackward.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01b5038718056b024b370b74a874fbd92c5bbab3/gcc%2Ftree-ssa-threadbackward.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadbackward.c?ref=01b5038718056b024b370b74a874fbd92c5bbab3", "patch": "@@ -43,6 +43,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"ssa.h\"\n #include \"tree-cfgcleanup.h\"\n #include \"tree-pretty-print.h\"\n+#include \"cfghooks.h\"\n \n // Path registry for the backwards threader.  After all paths have been\n // registered with register_path(), thread_through_all_blocks() is called\n@@ -564,7 +565,10 @@ back_threader_registry::thread_through_all_blocks (bool may_peel_loop_headers)\n    TAKEN_EDGE, otherwise it is NULL.\n \n    CREATES_IRREDUCIBLE_LOOP, if non-null is set to TRUE if threading this path\n-   would create an irreducible loop.  */\n+   would create an irreducible loop.\n+\n+   ?? It seems we should be able to loosen some of the restrictions in\n+   this function after loop optimizations have run.  */\n \n bool\n back_threader_profitability::profitable_path_p (const vec<basic_block> &m_path,\n@@ -725,7 +729,11 @@ back_threader_profitability::profitable_path_p (const vec<basic_block> &m_path,\n \t the last entry in the array when determining if we thread\n \t through the loop latch.  */\n       if (loop->latch == bb)\n-\tthreaded_through_latch = true;\n+\t{\n+\t  threaded_through_latch = true;\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    fprintf (dump_file, \" (latch)\");\n+\t}\n     }\n \n   gimple *stmt = get_gimple_control_stmt (m_path[0]);\n@@ -845,6 +853,22 @@ back_threader_profitability::profitable_path_p (const vec<basic_block> &m_path,\n \t\t \"a multiway branch.\\n\");\n       return false;\n     }\n+\n+  /* Threading through an empty latch would cause code to be added to\n+     the latch.  This could alter the loop form sufficiently to cause\n+     loop optimizations to fail.  Disable these threads until after\n+     loop optimizations have run.  */\n+  if ((threaded_through_latch\n+       || (taken_edge && taken_edge->dest == loop->latch))\n+      && !(cfun->curr_properties & PROP_loop_opts_done)\n+      && empty_block_p (loop->latch))\n+    {\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file,\n+\t\t \"  FAIL: FSM Thread through latch before loop opts would create non-empty latch\\n\");\n+      return false;\n+\n+    }\n   return true;\n }\n "}]}