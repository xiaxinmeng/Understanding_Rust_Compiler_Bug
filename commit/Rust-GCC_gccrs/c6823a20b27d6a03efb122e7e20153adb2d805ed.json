{"sha": "c6823a20b27d6a03efb122e7e20153adb2d805ed", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzY4MjNhMjBiMjdkNmEwM2VmYjEyMmU3ZTIwMTUzYWRiMmQ4MDVlZA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2005-03-15T15:59:54Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2005-03-15T15:59:54Z"}, "message": "re PR ada/19900 (ACATS c391002 c432002 ICE categorize_ctor_elements_1)\n\n2005-03-08  Eric Botcazou  <ebotcazou@adacore.com>\n\t    Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n\t    Nicolas Setton  <setton@adacore.com>\n\t    Ed Schonberg  <schonberg@adacore.com>\n\n\tPR ada/19900\n\tPR ada/19408\n\tPR ada/19140\n\tPR ada/20255\n\n\t* decl.c (gnat_to_gnu_field): Reject aliased components with a\n\trepresentation clause that prescribes a size not equal to the rounded\n\tsize of their types.\n\t(gnat_to_gnu_entity, case E_Component): Always look at\n\tOriginal_Record_Component if Present and not the entity.\n\t(gnat_to_gnu_entity, case E_Record_Subtype): Rework handling of subtypes\n\tof tagged extension types by not making field for components that are\n\tinside the parent.\n\t(gnat_to_gnu_entity) <E_Record_Type>: Fix typo in the alignment formula\n\t(gnat_to_gnu_entity) <E_Variable>: Do not convert again the\n\texpression to the type of the object when the object is constant.\n\tReverse defer_debug_incomplete_list before traversing it, so that trees\n\tare processed in the order at which they were added to the list. This\n\torder is important when using the stabs debug format.\n\tIf we are deferring the output of debug information, also defer this\n\toutput for a function return type.\n\tWhen adding fields to a record, prevent emitting debug information\n\tfor incomplete records, emit the information only when the record is\n\tcomplete.\n\t(components_to_record): New parameter defer_debug.\n\t(gnat_to_gnu_entity, case E_Array_Subtype): Call copy_alias_set.\n\t(gnat_to_gnu_field_decl): New function.\n\t(substitution_list, annotate_rep): Call it.\n\t(gnat_to_gnu_entity, case E_Record_Subtype): Likewise.\n\t(gnat_to_gnu_entity, case E_Record_Type): Likewise.\n\tNo longer update discriminants to not be a COMPONENT_REF.\n\t(copy_alias_set): Strip padding from input type; also handle\n\tunconstrained arrays properly.\n\n\t* gigi.h (write_record_type_debug_info): New function.\n\tConvert to use ANSI-style prototypes. Remove unused\n\tdeclarations for emit_stack_check, elab_all_gnat and\n\tset_second_error_entity.\n\t(gnat_to_gnu_field_decl): New decl.\n\n\t* utils.c (write_record_type_debug_info): New function.\n\t(finish_record_type): Delegate generation of debug information to\n\twrite_record_type_debug_info.\n\t(update_pointer_to): Remove unneeded calls to rest_of_decl_compilation.\n\t(update_pointer_to): Fix pasto.\n\t(convert) <UNION_TYPE>: Accept slight type variations when\n\tconverting to an unchecked union type.\n\n\t* exp_ch13.adb (Expand_N_Freeze_Entity): If Freeze_Type returns True,\n\treplace the N_Freeze_Entity with a null statement.\n\n\t* freeze.adb (Freeze_Expression): If the freeze nodes are generated\n\twithin a constrained subcomponent of an enclosing record, place the\n\tfreeze nodes in the scope stack entry for the enclosing record.\n\t(Undelay_Type): New Subprogram.\n\t(Set_Small_Size): Pass T, the type to modify; all callers changed.\n\t(Freeze_Entity, Freeze_Record_Type): Change the way we handle types\n\twithin records; allow them to have freeze nodes if their base types\n\taren't frozen yet.\n\n\t* sem_ch3.adb (Derived_Type_Declaration): New predicate\n\tComes_From_Generic, to recognize accurately that the parent type in a\n\tderived type declaration can be traced back to a formal type, because\n\tit is one or is derived from one, or because its completion is derived\n\tfrom one.\n\t(Constrain_Component_Type): If component comes from source and has no\n\texplicit constraint, no need to constrain in in a subtype of the\n\tenclosing record.\n\t(Constrain_Access, Constrain_Array): Allow itypes to be delayed.\n\tMinor change to propagate Is_Ada_2005 flag\n\n\t* trans.c (gnat_to_gnu, case N_Aggregate): Verify that\n\tExpansion_Delayed is False.\n\t(assoc_to_constructor): Ignore fields that have a\n\tCorresponding_Discriminant.\n\t(gnat_to_gnu) <N_Return_Statement>: Restructure. If the\n\tfunction returns \"by target\", dereference the target pointer using the\n\ttype of the actual return value.\n\t<all>: Be prepared for a null gnu_result.\n\t(processed_inline_subprograms): Check flag_really_no_inline\n\tinstead of flag_no_inline.\n\t(set_second_error_entity): Remove unused function.\n\t(gnat_to_gnu, case N_Selected_Component): Call\n\tgnat_to_gnu_field_decl.\n\t(assoc_to_constructor): Likewise.\n\nFrom-SVN: r96492", "tree": {"sha": "6de133fd341d163b8dba67b5ce64baf3ae84e2c8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6de133fd341d163b8dba67b5ce64baf3ae84e2c8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c6823a20b27d6a03efb122e7e20153adb2d805ed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c6823a20b27d6a03efb122e7e20153adb2d805ed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c6823a20b27d6a03efb122e7e20153adb2d805ed", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c6823a20b27d6a03efb122e7e20153adb2d805ed/comments", "author": null, "committer": null, "parents": [{"sha": "3a8b9f38bfc03d50be0e81ede68f9fc00cc9451d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a8b9f38bfc03d50be0e81ede68f9fc00cc9451d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3a8b9f38bfc03d50be0e81ede68f9fc00cc9451d"}], "stats": {"total": 1466, "additions": 858, "deletions": 608}, "files": [{"sha": "098d485af83428307559a1d46268d9a2daeed3b1", "filename": "gcc/ada/decl.c", "status": "modified", "additions": 154, "deletions": 109, "changes": 263, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6823a20b27d6a03efb122e7e20153adb2d805ed/gcc%2Fada%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6823a20b27d6a03efb122e7e20153adb2d805ed/gcc%2Fada%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdecl.c?ref=c6823a20b27d6a03efb122e7e20153adb2d805ed", "patch": "@@ -80,6 +80,12 @@ static struct incomplete\n   Entity_Id full_type;\n } *defer_incomplete_list = 0;\n \n+/* These two variables are used to defer emission of debug information for\n+   nested incomplete record types  */\n+\n+static int defer_debug_level = 0;\n+static tree defer_debug_incomplete_list;\n+\n static void copy_alias_set (tree, tree);\n static tree substitution_list (Entity_Id, Entity_Id, tree, bool);\n static bool allocatable_size_p (tree, bool);\n@@ -91,7 +97,7 @@ static tree elaborate_expression_1 (Node_Id, Entity_Id, tree, tree,\n static tree make_packable_type (tree);\n static tree gnat_to_gnu_field (Entity_Id, tree, int, bool);\n static void components_to_record (tree, Node_Id, tree, int, bool, tree *,\n-                                  bool, bool);\n+                                  bool, bool, bool);\n static int compare_field_bitpos (const PTR, const PTR);\n static Uint annotate_value (tree);\n static void annotate_rep (Entity_Id, tree);\n@@ -151,6 +157,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n   bool saved = false;\n   /* Nonzero if we incremented defer_incomplete_level.  */\n   bool this_deferred = false;\n+  /* Nonzero if we incremented defer_debug_level.  */\n+  bool debug_deferred = false;\n   /* Nonzero if we incremented force_global.  */\n   bool this_global = false;\n   /* Nonzero if we should check to see if elaborated during processing.  */\n@@ -390,11 +398,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t   stored discriminant.  Also use Original_Record_Component\n \t   if the record has a private extension.  */\n \n-\tif ((Base_Type (gnat_record) == gnat_record\n-             || Ekind (Scope (gnat_entity)) == E_Private_Subtype\n-\t     || Ekind (Scope (gnat_entity)) == E_Record_Subtype_With_Private\n-\t     || Ekind (Scope (gnat_entity)) == E_Record_Type_With_Private)\n-\t    && Present (Original_Record_Component (gnat_entity))\n+\tif (Present (Original_Record_Component (gnat_entity))\n \t    && Original_Record_Component (gnat_entity) != gnat_entity)\n \t  {\n \t    gnu_decl\n@@ -1011,6 +1015,10 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t    const_flag = true;\n \t  }\n \n+\tif (const_flag)\n+\t  gnu_type = build_qualified_type (gnu_type, (TYPE_QUALS (gnu_type)\n+\t\t\t\t\t\t      | TYPE_QUAL_CONST));\n+\n \t/* Convert the expression to the type of the object except in the\n \t   case where the object's type is unconstrained or the object's type\n \t   is a padded record whose field is of self-referential size.  In\n@@ -1038,14 +1046,6 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t\t|| Is_Exported (gnat_entity)))))\n \t  gnu_ext_name = create_concat_name (gnat_entity, 0);\n \n-\tif (const_flag)\n-\t  {\n-\t    gnu_type = build_qualified_type (gnu_type, (TYPE_QUALS (gnu_type)\n-\t\t\t\t\t\t\t| TYPE_QUAL_CONST));\n-\t    if (gnu_expr)\n-\t      gnu_expr = convert (gnu_type, gnu_expr);\n-\t  }\n-\n \t/* If this is constant initialized to a static constant and the\n \t   object has an aggregrate type, force it to be statically\n \t   allocated. */\n@@ -1113,7 +1113,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t/* Back-annotate the Alignment of the object if not already in the\n \t   tree.  Likewise for Esize if the object is of a constant size.\n \t   But if the \"object\" is actually a pointer to an object, the\n-\t   alignment and size are the same as teh type, so don't back-annotate\n+\t   alignment and size are the same as the type, so don't back-annotate\n \t   the values for the pointer.  */\n \tif (!used_by_ref && Unknown_Alignment (gnat_entity))\n \t  Set_Alignment (gnat_entity,\n@@ -2221,6 +2221,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \tgnu_type\n \t  = build_array_type (gnat_to_gnu_type (Component_Type (gnat_entity)),\n \t\t\t      gnu_index_type);\n+\tcopy_alias_set (gnu_type,  gnu_string_type);\n       }\n       break;\n \n@@ -2355,7 +2356,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \telse if (Is_Atomic (gnat_entity))\n \t  TYPE_ALIGN (gnu_type)\n \t    = (esize >= BITS_PER_WORD ? BITS_PER_WORD\n-\t       : 1 << ((floor_log2 (esize) - 1) + 1));\n+\t       : 1 << (floor_log2 (esize - 1) + 1));\n \n \t/* If we have a Parent_Subtype, make a field for the parent.  If\n \t   this record has rep clauses, force the position to zero.  */\n@@ -2387,9 +2388,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t     build3 (COMPONENT_REF,\n \t\t\t     get_unpadded_type (Etype (gnat_field)),\n \t\t\t     gnu_get_parent,\n-\t\t\t     gnat_to_gnu_entity (Corresponding_Discriminant\n-\t\t\t\t\t\t (gnat_field),\n-\t\t\t\t\t\tNULL_TREE, 0),\n+\t\t\t     gnat_to_gnu_field_decl (Corresponding_Discriminant\n+\t\t\t\t\t\t     (gnat_field)),\n \t\t\t     NULL_TREE),\n \t\t     true);\n \n@@ -2447,32 +2447,25 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t/* Add the listed fields into the record and finish up.  */\n \tcomponents_to_record (gnu_type, Component_List (record_definition),\n \t\t\t      gnu_field_list, packed, definition, NULL,\n-\t\t\t      false, all_rep);\n+\t\t\t      false, all_rep, this_deferred);\n+\n+        if (this_deferred)\n+\t  {\n+\t    debug_deferred = true;\n+\t    defer_debug_level++;\n+\n+\t    defer_debug_incomplete_list\n+\t      = tree_cons (NULL_TREE, gnu_type,\n+\t\t\t   defer_debug_incomplete_list);\n+\t  }\n+\n+\t/* We used to remove the associations of the discriminants and\n+\t   _Parent for validity checking, but we may need them if there's\n+\t   Freeze_Node for a subtype used in this record.  */\n \n \tTYPE_VOLATILE (gnu_type) = Treat_As_Volatile (gnat_entity);\n \tTYPE_BY_REFERENCE_P (gnu_type) = Is_By_Reference_Type (gnat_entity);\n \n-\t/* If this is an extension type, reset the tree for any\n-\t   inherited discriminants.  Also remove the PLACEHOLDER_EXPR\n-\t   for non-inherited discriminants.  */\n-\tif (!Is_Unchecked_Union (gnat_entity)\n-\t    && Has_Discriminants (gnat_entity))\n-\t  for (gnat_field = First_Stored_Discriminant (gnat_entity);\n-\t       Present (gnat_field);\n-\t       gnat_field = Next_Stored_Discriminant (gnat_field))\n-\t    {\n-\t      if (Present (Parent_Subtype (gnat_entity))\n-\t\t  && Present (Corresponding_Discriminant (gnat_field)))\n-\t\tsave_gnu_tree (gnat_field, NULL_TREE, false);\n-\t      else\n-\t\t{\n-\t\t  gnu_field = get_gnu_tree (gnat_field);\n-\t\t  save_gnu_tree (gnat_field, NULL_TREE, false);\n-\t\t  save_gnu_tree (gnat_field, TREE_OPERAND (gnu_field, 1),\n-\t\t\t\t false);\n-\t\t}\n-\t    }\n-\n \t/* If it is a tagged record force the type to BLKmode to insure\n \t   that these objects will always be placed in memory. Do the\n \t   same thing for limited record types. */\n@@ -2581,7 +2574,6 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t      && Present (Discriminant_Constraint (gnat_entity)))\n \t    {\n \t      Entity_Id gnat_field;\n-\t      Entity_Id gnat_root_type;\n \t      tree gnu_field_list = 0;\n \t      tree gnu_pos_list\n \t\t= compute_field_positions (gnu_orig_type, NULL_TREE,\n@@ -2590,41 +2582,9 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t      tree gnu_subst_list\n \t\t= substitution_list (gnat_entity, gnat_base_type, NULL_TREE,\n \t\t\t\t     definition);\n-\t      bool possibly_overlapping_fields = false;\n \t      tree gnu_temp;\n \n-\t      /* If this is a derived type, we may be seeing fields from any\n-\t\t original records, so add those positions and discriminant\n-\t\t substitutions to our lists.  */\n-\t      for (gnat_root_type = gnat_base_type;\n-\t\t   Underlying_Type (Etype (gnat_root_type)) != gnat_root_type;\n-\t\t   gnat_root_type = Underlying_Type (Etype (gnat_root_type)))\n-\t\t{\n-\t\t  gnu_pos_list\n-\t\t    = compute_field_positions\n-\t\t      (gnat_to_gnu_type (Etype (gnat_root_type)),\n-\t\t       gnu_pos_list, size_zero_node, bitsize_zero_node,\n-\t\t       BIGGEST_ALIGNMENT);\n-\n-\t\t  if (Present (Parent_Subtype (gnat_root_type)))\n-\t\t    {\n-\t\t      gnu_subst_list\n-\t\t\t= substitution_list (Parent_Subtype (gnat_root_type),\n-\t\t\t\t\t     Empty, gnu_subst_list,\n-\t\t\t\t\t     definition);\n-\n-\t\t      /* If there's a _Parent field, it may overlap the\n-\t\t\t fields we have that appear to be in this record but\n-\t\t\t actually are from the parent.  So make note of that\n-\t\t\t fact and later we'll make a UNION_TYPE instead of\n-\t\t\t a RECORD_TYPE, since the latter may not have\n-\t\t\t overlapping fields.  */\n-\t\t      possibly_overlapping_fields = true;\n-\t\t    }\n-\t\t}\n-\n-\t      gnu_type = make_node (possibly_overlapping_fields\n-\t\t\t\t    ? UNION_TYPE : RECORD_TYPE);\n+\t      gnu_type = make_node (RECORD_TYPE);\n \t      TYPE_NAME (gnu_type) = gnu_entity_id;\n \t      TYPE_STUB_DECL (gnu_type)\n \t\t= create_type_decl (NULL_TREE, gnu_type, NULL, false, false,\n@@ -2633,12 +2593,17 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \n \t      for (gnat_field = First_Entity (gnat_entity);\n \t\t   Present (gnat_field); gnat_field = Next_Entity (gnat_field))\n-\t\tif (Ekind (gnat_field) == E_Component\n-\t\t    || Ekind (gnat_field) == E_Discriminant)\n+\t\tif ((Ekind (gnat_field) == E_Component\n+\t\t     || Ekind (gnat_field) == E_Discriminant)\n+\t\t    && (Underlying_Type (Scope (Original_Record_Component\n+\t\t\t\t\t\t(gnat_field)))\n+\t\t\t== gnat_base_type)\n+\t\t    && (No (Corresponding_Discriminant (gnat_field))\n+\t\t\t|| !Is_Tagged_Type (gnat_base_type)))\n \t\t  {\n \t\t    tree gnu_old_field\n-\t\t      = gnat_to_gnu_entity\n-\t\t\t(Original_Record_Component (gnat_field), NULL_TREE, 0);\n+\t\t      = gnat_to_gnu_field_decl (Original_Record_Component\n+\t\t\t\t\t\t(gnat_field));\n \t\t    tree gnu_offset\n \t\t      = TREE_VALUE (purpose_member (gnu_old_field,\n \t\t\t\t\t\t    gnu_pos_list));\n@@ -2728,6 +2693,16 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t    save_gnu_tree (gnat_field, gnu_field, false);\n \t\t  }\n \n+\t      /* Now go through the entities again looking for Itypes that\n+\t\t we have not elaborated but should (e.g., Etypes of fields\n+\t\t that have Original_Components).  */\n+\t      for (gnat_field = First_Entity (gnat_entity);\n+\t\t   Present (gnat_field); gnat_field = Next_Entity (gnat_field))\n+\t\tif ((Ekind (gnat_field) == E_Discriminant\n+\t\t     || Ekind (gnat_field) == E_Component)\n+\t\t    && !present_gnu_tree (Etype (gnat_field)))\n+\t\t  gnat_to_gnu_entity (Etype (gnat_field), NULL_TREE, 0);\n+\n \t      finish_record_type (gnu_type, nreverse (gnu_field_list),\n \t\t\t\t  true, false);\n \n@@ -2812,7 +2787,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t   && !Is_Unchecked_Union (gnat_base_type))\n \t\t  || Ekind (gnat_temp) == E_Component)\n \t\tsave_gnu_tree (gnat_temp,\n-\t\t\t       get_gnu_tree\n+\t\t\t       gnat_to_gnu_field_decl\n \t\t\t       (Original_Record_Component (gnat_temp)), false);\n \t}\n       break;\n@@ -3633,8 +3608,24 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t   stubbed since structures are incomplete for the back-end.  */\n \tif (gnu_field_list\n \t    && Convention (gnat_entity) != Convention_Stubbed)\n-\t  finish_record_type (gnu_return_type, nreverse (gnu_field_list),\n-\t\t\t      false, false);\n+           {\n+ \t    /* If all types are not complete, defer emission of debug\n+ \t       information for this record types. Otherwise, we risk emitting\n+ \t       debug information for a dummy type contained in the fields\n+\t       for that record.  */\n+ \t    finish_record_type (gnu_return_type, nreverse (gnu_field_list),\n+ \t\t\t        false, defer_incomplete_level);\n+\n+ \t    if (defer_incomplete_level)\n+ \t      {\n+ \t        debug_deferred = true;\n+ \t        defer_debug_level++;\n+\n+\t        defer_debug_incomplete_list\n+\t\t  = tree_cons (NULL_TREE, gnu_return_type,\n+\t\t\t       defer_debug_incomplete_list);\n+ \t      }\n+ \t  }\n \n \t/* If we have a CICO list but it has only one entry, we convert\n \t   this function into a function that simply returns that one\n@@ -3739,7 +3730,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \telse if (kind == E_Subprogram_Type)\n \t  gnu_decl = create_type_decl (gnu_entity_id, gnu_type, attr_list,\n \t\t\t\t       !Comes_From_Source (gnat_entity),\n-\t\t\t\t       debug_info_p, gnat_entity);\n+\t\t\t\t       debug_info_p && !defer_incomplete_level,\n+\t\t\t\t       gnat_entity);\n \telse\n \t  {\n \t    gnu_decl = create_subprog_decl (gnu_entity_id, gnu_ext_name,\n@@ -4165,6 +4157,31 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t  }\n     }\n \n+   /* If there are no incomplete types and we have deferred emission\n+      of debug information, check whether we have finished defining\n+      all nested records.\n+      If so, handle the list now.  */\n+\n+   if (debug_deferred)\n+     defer_debug_level--;\n+\n+   if (defer_debug_incomplete_list\n+       && !defer_incomplete_level\n+       && !defer_debug_level)\n+    {\n+      tree c, n;\n+\n+      defer_debug_incomplete_list = nreverse (defer_debug_incomplete_list);\n+\n+      for (c = defer_debug_incomplete_list; c; c = n)\n+\t{\n+\t  n = TREE_CHAIN (c);\n+\t  write_record_type_debug_info (TREE_VALUE (c));\n+\t}\n+\n+      defer_debug_incomplete_list = 0;\n+    }\n+\n   if (this_global)\n     force_global--;\n \n@@ -4176,6 +4193,20 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \n   return gnu_decl;\n }\n+\n+/* Similar, but if the returned value is a COMPONENT_REF, return the\n+   FIELD_DECL.  */\n+\n+tree\n+gnat_to_gnu_field_decl (Entity_Id gnat_entity)\n+{\n+  tree gnu_field = gnat_to_gnu_entity (gnat_entity, NULL_TREE, 0);\n+\n+  if (TREE_CODE (gnu_field) == COMPONENT_REF)\n+    gnu_field = TREE_OPERAND (gnu_field, 1);\n+\n+  return gnu_field;\n+}\n \f\n /* Given GNAT_ENTITY, elaborate all expressions that are required to\n    be elaborated at the point of its definition, but do nothing else.  */\n@@ -4292,19 +4323,26 @@ mark_out_of_scope (Entity_Id gnat_entity)\n static void\n copy_alias_set (tree gnu_new_type, tree gnu_old_type)\n {\n+  /* Remove any padding from GNU_OLD_TYPE.  It doesn't matter in the case\n+     of a one-dimensional array, since the padding has the same alias set\n+     as the field type, but if it's a multi-dimensional array, we need to\n+     see the inner types.  */\n+  while (TREE_CODE (gnu_old_type) == RECORD_TYPE\n+\t && (TYPE_JUSTIFIED_MODULAR_P (gnu_old_type)\n+\t     || TYPE_IS_PADDING_P (gnu_old_type)))\n+    gnu_old_type = TREE_TYPE (TYPE_FIELDS (gnu_old_type));\n+\n+  /* We need to be careful here in case GNU_OLD_TYPE is an unconstrained\n+     array.  In that case, it doesn't have the same shape as GNU_NEW_TYPE,\n+     so we need to go down to what does.  */\n+  if (TREE_CODE (gnu_old_type) == UNCONSTRAINED_ARRAY_TYPE)\n+    gnu_old_type\n+      = TREE_TYPE (TREE_TYPE (TYPE_FIELDS (TREE_TYPE (gnu_old_type))));\n+\n   if (TREE_CODE (gnu_new_type) == ARRAY_TYPE\n       && TREE_CODE (TREE_TYPE (gnu_new_type)) == ARRAY_TYPE\n       && TYPE_MULTI_ARRAY_P (TREE_TYPE (gnu_new_type)))\n-    {\n-      /* We need to be careful here in case GNU_OLD_TYPE is an unconstrained\n-\t array.  In that case, it doesn't have the same shape as GNU_NEW_TYPE,\n-\t so we need to go down to what does.  */\n-      if (TREE_CODE (gnu_old_type) == UNCONSTRAINED_ARRAY_TYPE)\n-\tgnu_old_type\n-\t  = TREE_TYPE (TREE_TYPE (TYPE_FIELDS (TREE_TYPE (gnu_old_type))));\n-\n-      copy_alias_set (TREE_TYPE (gnu_new_type), TREE_TYPE (gnu_old_type));\n-    }\n+    copy_alias_set (TREE_TYPE (gnu_new_type), TREE_TYPE (gnu_old_type));\n \n   TYPE_ALIAS_SET (gnu_new_type) = get_alias_set (gnu_old_type);\n   record_component_aliases (gnu_new_type);\n@@ -4336,8 +4374,8 @@ substitution_list (Entity_Id gnat_subtype, Entity_Id gnat_type,\n \t gnat_value = Next_Elmt (gnat_value))\n       /* Ignore access discriminants.  */\n       if (!Is_Access_Type (Etype (Node (gnat_value))))\n-\tgnu_list = tree_cons (gnat_to_gnu_entity (gnat_discrim, NULL_TREE, 0),\n-\t\t\t    elaborate_expression\n+\tgnu_list = tree_cons (gnat_to_gnu_field_decl (gnat_discrim),\n+\t\t\t      elaborate_expression\n \t\t\t      (Node (gnat_value), gnat_subtype,\n \t\t\t       get_entity_name (gnat_discrim), definition,\n \t\t\t       1, 0),\n@@ -5168,14 +5206,13 @@ gnat_to_gnu_field (Entity_Id gnat_field, tree gnu_record_type, int packed,\n \t consistent with the alignment.  */\n       if (needs_strict_alignment)\n \t{\n-\t  tree gnu_min_size = round_up (rm_size (gnu_field_type),\n-\t\t\t\t\tTYPE_ALIGN (gnu_field_type));\n+\t  tree gnu_rounded_size = round_up (rm_size (gnu_field_type),\n+\t\t\t\t\t    TYPE_ALIGN (gnu_field_type));\n \n \t  TYPE_ALIGN (gnu_record_type)\n \t    = MAX (TYPE_ALIGN (gnu_record_type), TYPE_ALIGN (gnu_field_type));\n \n-\t  /* If Atomic, the size must match exactly and if aliased, the size\n-\t     must not be less than the rounded size.  */\n+\t  /* If Atomic, the size must match exactly that of the field.  */\n \t  if ((Is_Atomic (gnat_field) || Is_Atomic (Etype (gnat_field)))\n \t      && !operand_equal_p (gnu_size, TYPE_SIZE (gnu_field_type), 0))\n \t    {\n@@ -5187,13 +5224,18 @@ gnat_to_gnu_field (Entity_Id gnat_field, tree gnu_record_type, int packed,\n \t      gnu_size = NULL_TREE;\n \t    }\n \n+\t  /* If Aliased, the size must match exactly the rounded size.  We\n+\t     used to be more accomodating here and accept greater sizes, but\n+\t     fully supporting this case on big-endian platforms would require\n+\t     switching to a more involved layout for the field.  */\n \t  else if (Is_Aliased (gnat_field)\n-\t\t   && gnu_size && tree_int_cst_lt (gnu_size, gnu_min_size))\n+\t\t   && gnu_size\n+\t\t   && ! operand_equal_p (gnu_size, gnu_rounded_size, 0))\n \t    {\n \t      post_error_ne_tree\n-\t\t(\"size of aliased field& too small{, minimum required is ^}\",\n+\t\t(\"size of aliased field& must be ^ bits\",\n \t\t Last_Bit (Component_Clause (gnat_field)), gnat_field,\n-\t\t gnu_min_size);\n+\t\t gnu_rounded_size);\n \t      gnu_size = NULL_TREE;\n   \t    }\n \n@@ -5345,14 +5387,17 @@ is_variable_size (tree type)\n    ALL_REP, if true, means a rep clause was found for all the fields.  This\n    simplifies the logic since we know we're not in the mixed case.\n \n+   DEFER_DEBUG, if true, means that the debugging routines should not be\n+   called when finishing constructing the record type.\n+\n    The processing of the component list fills in the chain with all of the\n    fields of the record and then the record type is finished.  */\n \n static void\n components_to_record (tree gnu_record_type, Node_Id component_list,\n                       tree gnu_field_list, int packed, bool definition,\n                       tree *p_gnu_rep_list, bool cancel_alignment,\n-\t\t      bool all_rep)\n+\t\t      bool all_rep, bool defer_debug)\n {\n   Node_Id component_decl;\n   Entity_Id gnat_field;\n@@ -5474,7 +5519,8 @@ components_to_record (tree gnu_record_type, Node_Id component_list,\n \n \t  components_to_record (gnu_variant_type, Component_List (variant),\n \t\t\t\tNULL_TREE, packed, definition,\n-\t\t\t\t&gnu_our_rep_list, !all_rep_and_size, all_rep);\n+\t\t\t\t&gnu_our_rep_list, !all_rep_and_size, all_rep,\n+\t\t\t\tfalse);\n \n \t  gnu_qual = choices_to_gnu (gnu_discriminant,\n \t\t\t\t     Discrete_Choices (variant));\n@@ -5611,7 +5657,7 @@ components_to_record (tree gnu_record_type, Node_Id component_list,\n     TYPE_ALIGN (gnu_record_type) = 0;\n \n   finish_record_type (gnu_record_type, nreverse (gnu_field_list),\n-\t\t      layout_with_rep, false);\n+\t\t      layout_with_rep, defer_debug);\n }\n \f\n /* Called via qsort from the above.  Returns -1, 1, depending on the\n@@ -5781,7 +5827,7 @@ annotate_rep (Entity_Id gnat_entity, tree gnu_type)\n   tree gnu_entry;\n   Entity_Id gnat_field;\n \n-  /* We operate by first making a list of all field and their positions\n+  /* We operate by first making a list of all fields and their positions\n      (we can get the sizes easily at any time) by a recursive call\n      and then update all the sizes into the tree.  */\n   gnu_list = compute_field_positions (gnu_type, NULL_TREE,\n@@ -5796,9 +5842,8 @@ annotate_rep (Entity_Id gnat_entity, tree gnu_type)\n       {\n \ttree parent_offset = bitsize_zero_node;\n \n-\tgnu_entry\n-\t  = purpose_member (gnat_to_gnu_entity (gnat_field, NULL_TREE, 0),\n-\t\t\t    gnu_list);\n+\tgnu_entry = purpose_member (gnat_to_gnu_field_decl (gnat_field),\n+\t\t\t\t    gnu_list);\n \n         if (gnu_entry)\n \t  {"}, {"sha": "9cf9bb0505adc95c117e825140b3e50824060502", "filename": "gcc/ada/exp_ch13.adb", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6823a20b27d6a03efb122e7e20153adb2d805ed/gcc%2Fada%2Fexp_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6823a20b27d6a03efb122e7e20153adb2d805ed/gcc%2Fada%2Fexp_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch13.adb?ref=c6823a20b27d6a03efb122e7e20153adb2d805ed", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2004, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -243,6 +243,7 @@ package body Exp_Ch13 is\n       In_Other_Scope : Boolean;\n       In_Outer_Scope : Boolean;\n       Decl           : Node_Id;\n+      Delete         : Boolean := False;\n \n    begin\n       --  For object, with address clause, check alignment is OK\n@@ -317,7 +318,7 @@ package body Exp_Ch13 is\n       --  If type, freeze the type\n \n       if Is_Type (E) then\n-         Freeze_Type (N);\n+         Delete := Freeze_Type (N);\n \n          --  And for enumeration type, build the enumeration tables\n \n@@ -388,6 +389,13 @@ package body Exp_Ch13 is\n          end loop;\n       end if;\n \n+      --  If we are to delete this N_Freeze_Entity, do so by rewriting so that\n+      --  a loop on all nodes being inserted will work propertly.\n+\n+      if Delete then\n+         Rewrite (N, Make_Null_Statement (Sloc (N)));\n+      end if;\n+\n       if In_Other_Scope then\n          if Ekind (Current_Scope) = E_Package then\n             End_Package_Scope (E_Scope);"}, {"sha": "0fe2173a0931ea130c7c6de062b6b448a728958e", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 250, "deletions": 153, "changes": 403, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6823a20b27d6a03efb122e7e20153adb2d805ed/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6823a20b27d6a03efb122e7e20153adb2d805ed/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=c6823a20b27d6a03efb122e7e20153adb2d805ed", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2004, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2005, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -164,6 +164,11 @@ package body Freeze is\n    --  needed -- see body for details). Never has any effect on T if the\n    --  Debug_Info_Off flag is set.\n \n+   procedure Undelay_Type (T : Entity_Id);\n+   --  T is a type of a component that we know to be an Itype.\n+   --  We don't want this to have a Freeze_Node, so ensure it doesn't.\n+   --  Do the same for any Full_View or Corresponding_Record_Type.\n+\n    procedure Warn_Overlay\n      (Expr : Node_Id;\n       Typ  : Entity_Id;\n@@ -506,9 +511,9 @@ package body Freeze is\n \n    procedure Check_Compile_Time_Size (T : Entity_Id) is\n \n-      procedure Set_Small_Size (S : Uint);\n+      procedure Set_Small_Size (T : Entity_Id; S : Uint);\n       --  Sets the compile time known size (32 bits or less) in the Esize\n-      --  field, checking for a size clause that was given which attempts\n+      --  field, of T checking for a size clause that was given which attempts\n       --  to give a smaller size.\n \n       function Size_Known (T : Entity_Id) return Boolean;\n@@ -525,7 +530,7 @@ package body Freeze is\n       -- Set_Small_Size --\n       --------------------\n \n-      procedure Set_Small_Size (S : Uint) is\n+      procedure Set_Small_Size (T : Entity_Id; S : Uint) is\n       begin\n          if S > 32 then\n             return;\n@@ -576,7 +581,8 @@ package body Freeze is\n \n          elsif Is_Array_Type (T) then\n             if Ekind (T) = E_String_Literal_Subtype then\n-               Set_Small_Size (Component_Size (T) * String_Literal_Length (T));\n+               Set_Small_Size (T, Component_Size (T)\n+                               * String_Literal_Length (T));\n                return True;\n \n             elsif not Is_Constrained (T) then\n@@ -632,7 +638,7 @@ package body Freeze is\n                   Next_Index (Index);\n                end loop;\n \n-               Set_Small_Size (Esiz);\n+               Set_Small_Size (T, Esiz);\n                return True;\n             end;\n \n@@ -864,7 +870,7 @@ package body Freeze is\n                end loop;\n \n                if Packed_Size_Known then\n-                  Set_Small_Size (Packed_Size);\n+                  Set_Small_Size (T, Packed_Size);\n                end if;\n \n                return True;\n@@ -1365,6 +1371,7 @@ package body Freeze is\n    -------------------\n \n    function Freeze_Entity (E : Entity_Id; Loc : Source_Ptr) return List_Id is\n+      Test_E : Entity_Id := E;\n       Comp   : Entity_Id;\n       F_Node : Node_Id;\n       Result : List_Id;\n@@ -1460,6 +1467,7 @@ package body Freeze is\n          IR   : Node_Id;\n          Junk : Boolean;\n          ADC  : Node_Id;\n+         Prev : Entity_Id;\n \n          Unplaced_Component : Boolean := False;\n          --  Set True if we find at least one component with no component\n@@ -1537,80 +1545,14 @@ package body Freeze is\n             end if;\n          end if;\n \n-         --  Freeze components and embedded subtypes\n+         --  Freeze components and embedded subtypes.\n \n          Comp := First_Entity (Rec);\n-         while Present (Comp) loop\n-            if not Is_Type (Comp) then\n-               Freeze_And_Append (Etype (Comp), Loc, Result);\n-            end if;\n-\n-            --  If the component is an access type with an allocator\n-            --  as default value, the designated type will be frozen\n-            --  by the corresponding expression in init_proc. In  order\n-            --  to place the freeze node for the designated type before\n-            --  that for the current record type, freeze it now.\n-\n-            --  Same process if the component is an array of access types,\n-            --  initialized with an aggregate. If the designated type is\n-            --  private, it cannot contain allocators, and it is premature\n-            --  to freeze the type, so we check for this as well.\n-\n-            if Is_Access_Type (Etype (Comp))\n-              and then Present (Parent (Comp))\n-              and then Present (Expression (Parent (Comp)))\n-              and then Nkind (Expression (Parent (Comp))) = N_Allocator\n-            then\n-               declare\n-                  Alloc : constant Node_Id := Expression (Parent (Comp));\n-\n-               begin\n-                  --  If component is pointer to a classwide type, freeze\n-                  --  the specific type in the expression being allocated.\n-                  --  The expression may be a subtype indication, in which\n-                  --  case freeze the subtype mark.\n+         Prev := Empty;\n \n-                  if Is_Class_Wide_Type (Designated_Type (Etype (Comp))) then\n-                     if Is_Entity_Name (Expression (Alloc)) then\n-                        Freeze_And_Append\n-                          (Entity (Expression (Alloc)), Loc, Result);\n-                     elsif\n-                       Nkind (Expression (Alloc)) = N_Subtype_Indication\n-                     then\n-                        Freeze_And_Append\n-                         (Entity (Subtype_Mark (Expression (Alloc))),\n-                           Loc, Result);\n-                     end if;\n-\n-                  elsif Is_Itype (Designated_Type (Etype (Comp))) then\n-                     Check_Itype (Designated_Type (Etype (Comp)));\n-\n-                  else\n-                     Freeze_And_Append\n-                       (Designated_Type (Etype (Comp)), Loc, Result);\n-                  end if;\n-               end;\n-\n-            elsif Is_Access_Type (Etype (Comp))\n-              and then Is_Itype (Designated_Type (Etype (Comp)))\n-            then\n-               Check_Itype (Designated_Type (Etype (Comp)));\n-\n-            elsif Is_Array_Type (Etype (Comp))\n-              and then Is_Access_Type (Component_Type (Etype (Comp)))\n-              and then Present (Parent (Comp))\n-              and then Nkind (Parent (Comp)) = N_Component_Declaration\n-              and then Present (Expression (Parent (Comp)))\n-              and then Nkind (Expression (Parent (Comp))) = N_Aggregate\n-              and then Is_Fully_Defined\n-                 (Designated_Type (Component_Type (Etype (Comp))))\n-            then\n-               Freeze_And_Append\n-                 (Designated_Type\n-                   (Component_Type (Etype (Comp))), Loc, Result);\n-            end if;\n+         while Present (Comp) loop\n \n-            --  Processing for real components (exclude anonymous subtypes)\n+            --  First handle the (real) component case.\n \n             if Ekind (Comp) = E_Component\n               or else Ekind (Comp) = E_Discriminant\n@@ -1619,6 +1561,23 @@ package body Freeze is\n                   CC : constant Node_Id := Component_Clause (Comp);\n \n                begin\n+                  --  Freezing a record type freezes the type of each of its\n+                  --  components. However, if the type of the component is\n+                  --  part of this record, we do not want or need a separate\n+                  --  Freeze_Node. Note that Is_Itype is wrong because that's\n+                  --  also set in private type cases. We also can't check for\n+                  --  the Scope being exactly Rec because of private types and\n+                  --  record extensions.\n+\n+                  if Is_Itype (Etype (Comp))\n+                    and then Is_Record_Type (Underlying_Type\n+                                             (Scope (Etype (Comp))))\n+                  then\n+                     Undelay_Type (Etype (Comp));\n+                  end if;\n+\n+                  Freeze_And_Append (Etype (Comp), Loc, Result);\n+\n                   --  Check for error of component clause given for variable\n                   --  sized type. We have to delay this test till this point,\n                   --  since the component type has to be frozen for us to know\n@@ -1779,6 +1738,135 @@ package body Freeze is\n                end;\n             end if;\n \n+            --  If the component is an Itype with Delayed_Freeze and is either\n+            --  a record or array subtype and its base type has not yet been\n+            --  frozen, we must remove this from the entity list of this\n+            --  record and put it on the entity list of the scope of its base\n+            --  type. Note that we know that this is not the type of a\n+            --  component since we cleared Has_Delayed_Freeze for it in the\n+            --  previous loop. Thus this must be the Designated_Type of an\n+            --  access type, which is the type of a component.\n+\n+            if Is_Itype (Comp)\n+              and then Is_Type (Scope (Comp))\n+              and then Is_Composite_Type (Comp)\n+              and then Base_Type (Comp) /= Comp\n+              and then Has_Delayed_Freeze (Comp)\n+              and then not Is_Frozen (Base_Type (Comp))\n+            then\n+               declare\n+                  Will_Be_Frozen : Boolean := False;\n+                  S : Entity_Id := Scope (Rec);\n+\n+               begin\n+                  --  We have a pretty bad kludge here. Suppose Rec is a\n+                  --  subtype being defined in a subprogram that's created\n+                  --  as part of the freezing of Rec'Base. In that case,\n+                  --  we know that Comp'Base must have already been frozen by\n+                  --  the time we get to elaborate this because Gigi doesn't\n+                  --  elaborate any bodies until it has elaborated all of the\n+                  --  declarative part. But Is_Frozen will not be  set at this\n+                  --  point because we are processing code in lexical order.\n+\n+                  --  We detect this case by going up the Scope chain of\n+                  --  Rec and seeing if we have a subprogram scope before\n+                  --  reaching the top of the scope chain or that of Comp'Base.\n+                  --  If we do, then mark that Comp'Base will actually be\n+                  --  frozen. If so, we merely undelay it.\n+\n+                  while Present (S) loop\n+                     if Is_Subprogram (S) then\n+                        Will_Be_Frozen := True;\n+                        exit;\n+                     elsif S = Scope (Base_Type (Comp)) then\n+                        exit;\n+                     end if;\n+\n+                     S := Scope (S);\n+                  end loop;\n+\n+                  if Will_Be_Frozen then\n+                     Undelay_Type (Comp);\n+                  else\n+                     if Present (Prev) then\n+                        Set_Next_Entity (Prev, Next_Entity (Comp));\n+                     else\n+                        Set_First_Entity (Rec, Next_Entity (Comp));\n+                     end if;\n+\n+                     --  Insert in entity list of scope of base type (which\n+                     --  must be an enclosing scope, because still unfrozen).\n+\n+                     Append_Entity (Comp, Scope (Base_Type (Comp)));\n+                  end if;\n+               end;\n+\n+            --  If the component is an access type with an allocator as\n+            --  default value, the designated type will be frozen by the\n+            --  corresponding expression in init_proc. In order to place the\n+            --  freeze node for the designated type before that for the\n+            --  current record type, freeze it now.\n+\n+            --  Same process if the component is an array of access types,\n+            --  initialized with an aggregate. If the designated type is\n+            --  private, it cannot contain allocators, and it is premature to\n+            --  freeze the type, so we check for this as well.\n+\n+            elsif Is_Access_Type (Etype (Comp))\n+              and then Present (Parent (Comp))\n+              and then Present (Expression (Parent (Comp)))\n+              and then Nkind (Expression (Parent (Comp))) = N_Allocator\n+            then\n+               declare\n+                  Alloc : constant Node_Id := Expression (Parent (Comp));\n+\n+               begin\n+                  --  If component is pointer to a classwide type, freeze\n+                  --  the specific type in the expression being allocated.\n+                  --  The expression may be a subtype indication, in which\n+                  --  case freeze the subtype mark.\n+\n+                  if Is_Class_Wide_Type (Designated_Type (Etype (Comp))) then\n+                     if Is_Entity_Name (Expression (Alloc)) then\n+                        Freeze_And_Append\n+                          (Entity (Expression (Alloc)), Loc, Result);\n+                     elsif\n+                       Nkind (Expression (Alloc)) = N_Subtype_Indication\n+                     then\n+                        Freeze_And_Append\n+                         (Entity (Subtype_Mark (Expression (Alloc))),\n+                           Loc, Result);\n+                     end if;\n+\n+                  elsif Is_Itype (Designated_Type (Etype (Comp))) then\n+                     Check_Itype (Designated_Type (Etype (Comp)));\n+\n+                  else\n+                     Freeze_And_Append\n+                       (Designated_Type (Etype (Comp)), Loc, Result);\n+                  end if;\n+               end;\n+\n+            elsif Is_Access_Type (Etype (Comp))\n+              and then Is_Itype (Designated_Type (Etype (Comp)))\n+            then\n+               Check_Itype (Designated_Type (Etype (Comp)));\n+\n+            elsif Is_Array_Type (Etype (Comp))\n+              and then Is_Access_Type (Component_Type (Etype (Comp)))\n+              and then Present (Parent (Comp))\n+              and then Nkind (Parent (Comp)) = N_Component_Declaration\n+              and then Present (Expression (Parent (Comp)))\n+              and then Nkind (Expression (Parent (Comp))) = N_Aggregate\n+              and then Is_Fully_Defined\n+                 (Designated_Type (Component_Type (Etype (Comp))))\n+            then\n+               Freeze_And_Append\n+                 (Designated_Type\n+                   (Component_Type (Etype (Comp))), Loc, Result);\n+            end if;\n+\n+            Prev := Comp;\n             Next_Entity (Comp);\n          end loop;\n \n@@ -1882,17 +1970,28 @@ package body Freeze is\n    --  Start of processing for Freeze_Entity\n \n    begin\n+      --  We are going to test for various reasons why this entity need not be\n+      --  frozen here, but in the case of an Itype that's defined within a\n+      --  record, that test actually applies to the record.\n+\n+      if Is_Itype (E) and then Is_Record_Type (Scope (E)) then\n+         Test_E := Scope (E);\n+      elsif Is_Itype (E) and then Present (Underlying_Type (Scope (E)))\n+        and then Is_Record_Type (Underlying_Type (Scope (E)))\n+      then\n+         Test_E := Underlying_Type (Scope (E));\n+      end if;\n+\n       --  Do not freeze if already frozen since we only need one freeze node\n \n       if Is_Frozen (E) then\n          return No_List;\n \n-      --  It is improper to freeze an external entity within a generic\n-      --  because its freeze node will appear in a non-valid context.\n-      --  The entity will be frozen in the proper scope after the current\n-      --  generic is analyzed.\n+      --  It is improper to freeze an external entity within a generic because\n+      --  its freeze node will appear in a non-valid context. The entity will\n+      --  be frozen in the proper scope after the current generic is analyzed.\n \n-      elsif Inside_A_Generic and then External_Ref_In_Generic (E) then\n+      elsif Inside_A_Generic and then External_Ref_In_Generic (Test_E) then\n          return No_List;\n \n       --  Do not freeze a global entity within an inner scope created during\n@@ -1906,9 +2005,9 @@ package body Freeze is\n       --  comes from source, or is a generic instance, then the freeze point\n       --  is the one mandated by the language. and we freze the entity.\n \n-      elsif In_Open_Scopes (Scope (E))\n-        and then Scope (E) /= Current_Scope\n-        and then Ekind (E) /= E_Constant\n+      elsif In_Open_Scopes (Scope (Test_E))\n+        and then Scope (Test_E) /= Current_Scope\n+        and then Ekind (Test_E) /= E_Constant\n       then\n          declare\n             S : Entity_Id := Current_Scope;\n@@ -1940,10 +2039,11 @@ package body Freeze is\n \n       elsif Front_End_Inlining\n         and then  In_Instance_Body\n-        and then Present (Scope (E))\n+        and then Present (Scope (Test_E))\n       then\n          declare\n-            S : Entity_Id := Scope (E);\n+            S : Entity_Id := Scope (Test_E);\n+\n          begin\n             while Present (S) loop\n                if Is_Generic_Instance (S) then\n@@ -2694,6 +2794,12 @@ package body Freeze is\n                   Freeze_And_Append (Comp, Loc, Result);\n \n                elsif (Ekind (Comp)) /= E_Function then\n+                  if Is_Itype (Etype (Comp))\n+                    and then Underlying_Type (Scope (Etype (Comp))) = E\n+                  then\n+                     Undelay_Type (Etype (Comp));\n+                  end if;\n+\n                   Freeze_And_Append (Etype (Comp), Loc, Result);\n                end if;\n \n@@ -2904,66 +3010,8 @@ package body Freeze is\n             Check_Restriction (No_Standard_Storage_Pools, E);\n          end if;\n \n-         --  If the current entity is an array or record subtype and has\n-         --  discriminants used to constrain it, it must not freeze, because\n-         --  Freeze_Entity nodes force Gigi to process the frozen type.\n-\n          if Is_Composite_Type (E) then\n \n-            if Is_Array_Type (E) then\n-               declare\n-                  Index : Node_Id := First_Index (E);\n-                  Expr1 : Node_Id;\n-                  Expr2 : Node_Id;\n-\n-               begin\n-                  while Present (Index) loop\n-                     if Etype (Index) /= Any_Type then\n-                        Get_Index_Bounds (Index, Expr1, Expr2);\n-\n-                        for J in 1 .. 2 loop\n-                           if Nkind (Expr1) = N_Identifier\n-                             and then Ekind (Entity (Expr1)) = E_Discriminant\n-                           then\n-                              Set_Has_Delayed_Freeze (E, False);\n-                              Set_Freeze_Node (E, Empty);\n-                              Check_Debug_Info_Needed (E);\n-                              return Result;\n-                           end if;\n-\n-                           Expr1 := Expr2;\n-                        end loop;\n-                     end if;\n-\n-                     Next_Index (Index);\n-                  end loop;\n-               end;\n-\n-            elsif Has_Discriminants (E)\n-              and Is_Constrained (E)\n-            then\n-               declare\n-                  Constraint : Elmt_Id;\n-                  Expr       : Node_Id;\n-\n-               begin\n-                  Constraint := First_Elmt (Discriminant_Constraint (E));\n-                  while Present (Constraint) loop\n-                     Expr := Node (Constraint);\n-                     if Nkind (Expr) = N_Identifier\n-                       and then Ekind (Entity (Expr)) = E_Discriminant\n-                     then\n-                        Set_Has_Delayed_Freeze (E, False);\n-                        Set_Freeze_Node (E, Empty);\n-                        Check_Debug_Info_Needed (E);\n-                        return Result;\n-                     end if;\n-\n-                     Next_Elmt (Constraint);\n-                  end loop;\n-               end;\n-            end if;\n-\n             --  AI-117 requires that all new primitives of a tagged type\n             --  must inherit the convention of the full view of the type.\n             --  Inherited and overriding operations are defined to inherit\n@@ -3065,7 +3113,7 @@ package body Freeze is\n          --  in particular the size and alignment values. This processing is\n          --  not required for generic types, since generic types do not play\n          --  any part in code generation, and so the size and alignment values\n-         --  for suhc types are irrelevant.\n+         --  for such types are irrelevant.\n \n          if Is_Generic_Type (E) then\n             return Result;\n@@ -3242,7 +3290,7 @@ package body Freeze is\n \n       function In_Exp_Body (N : Node_Id) return Boolean;\n       --  Given an N_Handled_Sequence_Of_Statements node N, determines whether\n-      --  it is the handled statement sequence of an expander generated\n+      --  it is the handled statement sequence of an expander-generated\n       --  subprogram (init proc, or stream subprogram). If so, it returns\n       --  True, otherwise False.\n \n@@ -3607,6 +3655,11 @@ package body Freeze is\n       --  specification, the scope is still void. The expression can also\n       --  appear in the discriminant part of a private or concurrent type.\n \n+      --  If the expression appears in a constrained subcomponent of an\n+      --  enclosing record declaration, the freeze nodes must be attached\n+      --  to the outer record type so they can eventually be placed in the\n+      --  enclosing declaration list.\n+\n       --  The other case requiring this special handling is if we are in\n       --  a default expression, since in that case we are about to freeze\n       --  a static type, and the freeze scope needs to be the outer scope,\n@@ -3626,6 +3679,7 @@ package body Freeze is\n          declare\n             Loc          : constant Source_Ptr := Sloc (Current_Scope);\n             Freeze_Nodes : List_Id := No_List;\n+            Pos          : Int := Scope_Stack.Last;\n \n          begin\n             if Present (Desig_Typ) then\n@@ -3640,16 +3694,21 @@ package body Freeze is\n                Freeze_And_Append (Nam, Loc, Freeze_Nodes);\n             end if;\n \n+            --  The current scope may be that of a constrained component of\n+            --  an enclosing record declaration, which is above the current\n+            --  scope in the scope stack.\n+\n+            if Is_Record_Type (Scope (Current_Scope)) then\n+               Pos := Pos - 1;\n+            end if;\n+\n             if Is_Non_Empty_List (Freeze_Nodes) then\n-               if No (Scope_Stack.Table\n-                 (Scope_Stack.Last).Pending_Freeze_Actions)\n-               then\n-                  Scope_Stack.Table\n-                    (Scope_Stack.Last).Pending_Freeze_Actions :=\n+               if No (Scope_Stack.Table (Pos).Pending_Freeze_Actions) then\n+                  Scope_Stack.Table (Pos).Pending_Freeze_Actions :=\n                       Freeze_Nodes;\n                else\n                   Append_List (Freeze_Nodes, Scope_Stack.Table\n-                                   (Scope_Stack.Last).Pending_Freeze_Actions);\n+                                   (Pos).Pending_Freeze_Actions);\n                end if;\n             end if;\n          end;\n@@ -4727,6 +4786,44 @@ package body Freeze is\n       end if;\n    end Set_Debug_Info_Needed;\n \n+   ------------------\n+   -- Undelay_Type --\n+   ------------------\n+\n+   procedure Undelay_Type (T : Entity_Id) is\n+   begin\n+      Set_Has_Delayed_Freeze (T, False);\n+      Set_Freeze_Node (T, Empty);\n+\n+      --  Since we don't want T to have a Freeze_Node, we don't want its\n+      --  Full_View or Corresponding_Record_Type to have one either.\n+\n+      --  ??? Fundamentally, this whole handling is a kludge. What we really\n+      --  want is to be sure that for an Itype that's part of record R and is\n+      --  a subtype of type T, that it's frozen after the later of the freeze\n+      --  points of R and T. We have no way of doing that directly, so what we\n+      --  do is force most such Itypes to be frozen as part of freezing R via\n+      --  this procedure and only delay the ones that need to be delayed\n+      --  (mostly the designated types of access types that are defined as\n+      --  part of the record).\n+\n+      if Is_Private_Type (T)\n+        and then Present (Full_View (T))\n+        and then Is_Itype (Full_View (T))\n+        and then Is_Record_Type (Scope (Full_View (T)))\n+      then\n+         Undelay_Type (Full_View (T));\n+      end if;\n+\n+      if Is_Concurrent_Type (T)\n+        and then Present (Corresponding_Record_Type (T))\n+        and then Is_Itype (Corresponding_Record_Type (T))\n+        and then Is_Record_Type (Scope (Corresponding_Record_Type (T)))\n+      then\n+         Undelay_Type (Corresponding_Record_Type (T));\n+      end if;\n+   end Undelay_Type;\n+\n    ------------------\n    -- Warn_Overlay --\n    ------------------"}, {"sha": "cdf2c225bcfd1f96758e2c793143a55b3b33aee9", "filename": "gcc/ada/gigi.h", "status": "modified", "additions": 159, "deletions": 118, "changes": 277, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6823a20b27d6a03efb122e7e20153adb2d805ed/gcc%2Fada%2Fgigi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6823a20b27d6a03efb122e7e20153adb2d805ed/gcc%2Fada%2Fgigi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgigi.h?ref=c6823a20b27d6a03efb122e7e20153adb2d805ed", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                              C Header File                               *\n  *                                                                          *\n- *          Copyright (C) 1992-2004 Free Software Foundation, Inc.          *\n+ *          Copyright (C) 1992-2005 Free Software Foundation, Inc.          *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *\n@@ -30,30 +30,23 @@\n  *                                                                          *\n  ****************************************************************************/\n \n+/* Declare all functions and types used by gigi.  */\n+\n /* The largest alignment, in bits, that is needed for using the widest\n    move instruction.  */\n extern unsigned int largest_move_alignment;\n \n-/* Declare all functions and types used by gigi.  */\n-\n /* Compute the alignment of the largest mode that can be used for copying\n    objects.  */\n extern void gnat_compute_largest_alignment (void);\n \n-/* Routine called by gcc for emitting a stack check. GNU_EXPR is the\n-   expression that contains the last address on the stack to check. */\n-extern tree emit_stack_check (tree);\n-\n /* GNU_TYPE is a type. Determine if it should be passed by reference by\n    default.  */\n-extern bool default_pass_by_ref (tree);\n+extern bool default_pass_by_ref (tree gnu_type);\n \n /* GNU_TYPE is the type of a subprogram parameter.  Determine from the type\n    if it should be passed by reference.  */\n-extern bool must_pass_by_ref (tree);\n-\n-/* Elaboration routines for the front end.  */\n-extern void elab_all_gnat (void);\n+extern bool must_pass_by_ref (tree gnu_type);\n \n /* Initialize DUMMY_NODE_TABLE.  */\n extern void init_dummy_type (void);\n@@ -73,46 +66,51 @@ extern void init_dummy_type (void);\n    was not created previously.  The value of 1 is normally used for a non-zero\n    DEFINITION, but a value of 2 is used in special circumstances, defined in\n    the code.  */\n-extern tree gnat_to_gnu_entity (Entity_Id, tree, int);\n+extern tree gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr,\n+                                int definition);\n+\n+/* Similar, but if the returned value is a COMPONENT_REF, return the\n+   FIELD_DECL.  */\n+extern tree gnat_to_gnu_field_decl (Entity_Id gnat_entity);\n \n /* Given GNAT_ENTITY, an entity in the incoming GNAT tree, return a\n    GCC type corresponding to that entity.  GNAT_ENTITY is assumed to\n    refer to an Ada type.  */\n-extern tree gnat_to_gnu_type (Entity_Id);\n+extern tree gnat_to_gnu_type (Entity_Id gnat_entity);\n \n /* Add GNU_STMT to the current BLOCK_STMT node.  */\n-extern void add_stmt (tree);\n+extern void add_stmt (tree gnu_stmt);\n \n /* Similar, but set the location of GNU_STMT to that of GNAT_NODE.  */\n-extern void add_stmt_with_node (tree, Node_Id);\n+extern void add_stmt_with_node (tree gnu_stmt, Node_Id gnat_node);\n \n /* Set the BLOCK node corresponding to the current code group to GNU_BLOCK.  */\n extern void set_block_for_group (tree);\n \n /* Add a declaration statement for GNU_DECL to the current BLOCK_STMT node.\n-   Get SLOC from Entity_Id.  */\n-extern void add_decl_expr (tree, Entity_Id);\n+   Get SLOC from GNAT_ENTITY.  */\n+extern void add_decl_expr (tree gnu_decl, Entity_Id gnat_entity);\n \n /* Given GNAT_ENTITY, elaborate all expressions that are required to\n    be elaborated at the point of its definition, but do nothing else.  */\n-extern void elaborate_entity (Entity_Id);\n+extern void elaborate_entity (Entity_Id gnat_entity);\n \n /* Mark GNAT_ENTITY as going out of scope at this point.  Recursively mark\n    any entities on its entity chain similarly.  */\n-extern void mark_out_of_scope (Entity_Id);\n+extern void mark_out_of_scope (Entity_Id gnat_entity);\n \n /* Make a dummy type corresponding to GNAT_TYPE.  */\n-extern tree make_dummy_type (Entity_Id);\n+extern tree make_dummy_type (Entity_Id gnat_type);\n \n /* Get the unpadded version of a GNAT type.  */\n-extern tree get_unpadded_type (Entity_Id);\n+extern tree get_unpadded_type (Entity_Id gnat_entity);\n \n /* Called when we need to protect a variable object using a save_expr.  */\n-extern tree maybe_variable (tree);\n+extern tree maybe_variable (tree gnu_operand);\n \n /* Create a record type that contains a field of TYPE with a starting bit\n    position so that it is aligned to ALIGN bits and is SIZE bytes long.  */\n-extern tree make_aligning_type (tree, int, tree);\n+extern tree make_aligning_type (tree type, int align, tree size);\n \n /* Ensure that TYPE has SIZE and ALIGN.  Make and return a new padded type\n    if needed.  We have already verified that SIZE and TYPE are large enough.\n@@ -127,36 +125,38 @@ extern tree make_aligning_type (tree, int, tree);\n    SAME_RM_SIZE is true if the RM_Size of the resulting type is to be\n    set to its TYPE_SIZE; otherwise, it's set to the RM_Size of the original\n    type.  */\n-extern tree maybe_pad_type (tree, tree, unsigned int, Entity_Id,\n-\t\t\t    const char *, bool, bool, bool);\n+extern tree maybe_pad_type (tree type, tree size, unsigned int align,\n+                            Entity_Id gnat_entity, const char *name_trailer,\n+\t\t\t    bool is_user_type, bool definition,\n+                            bool same_rm_size);\n \n /* Given a GNU tree and a GNAT list of choices, generate an expression to test\n    the value passed against the list of choices.  */\n-extern tree choices_to_gnu (tree, Node_Id);\n+extern tree choices_to_gnu (tree operand, Node_Id choices);\n \n /* Given a type T, a FIELD_DECL F, and a replacement value R,\n    return a new type with all size expressions that contain F\n    updated by replacing F with R.  This is identical to GCC's\n    substitute_in_type except that it knows about TYPE_INDEX_TYPE.  */\n-extern tree gnat_substitute_in_type (tree, tree, tree);\n+extern tree gnat_substitute_in_type (tree t, tree f, tree r);\n \n /* Return the \"RM size\" of GNU_TYPE.  This is the actual number of bits\n    needed to represent the object.  */\n-extern tree rm_size (tree);\n+extern tree rm_size (tree gnu_type);\n \n-/* Given GNU_ID, an IDENTIFIER_NODE containing a name and SUFFIX, a\n+/* Given GNU_ID, an IDENTIFIER_NODE containing a name, and SUFFIX, a\n    string, return a new IDENTIFIER_NODE that is the concatenation of\n    the name in GNU_ID and SUFFIX.  */\n-extern tree concat_id_with_name (tree, const char *);\n+extern tree concat_id_with_name (tree gnu_id, const char *suffix);\n \n /* Return the name to be used for GNAT_ENTITY.  If a type, create a\n    fully-qualified name, possibly with type information encoding.\n    Otherwise, return the name.  */\n-extern tree get_entity_name (Entity_Id);\n+extern tree get_entity_name (Entity_Id gnat_entity);\n \n /* Return a name for GNAT_ENTITY concatenated with two underscores and\n    SUFFIX.  */\n-extern tree create_concat_name (Entity_Id, const char *);\n+extern tree create_concat_name (Entity_Id gnat_entity, const char *suffix);\n \n /* If true, then gigi is being called on an analyzed but unexpanded tree, and\n    the only purpose of the call is to properly annotate types with\n@@ -167,36 +167,48 @@ extern bool type_annotate_only;\n extern const char *ref_filename;\n \n /* This is the main program of the back-end.  It sets up all the table\n-   structures and then generates code.  */\n-\n-extern void gigi (Node_Id, int, int, struct Node *, Node_Id *, Node_Id *,\n-\t\t  struct Elist_Header *, struct Elmt_Item *,\n-\t\t  struct String_Entry *, Char_Code *, struct List_Header *,\n-\t\t  Int, char *, Entity_Id, Entity_Id, Entity_Id, Int);\n+   structures and then generates code.\n+\n+   ??? Needs parameter descriptions  */\n+\n+extern void gigi (Node_Id gnat_root, int max_gnat_node, int number_name,\n+                  struct Node *nodes_ptr, Node_Id *next_node_ptr,\n+                  Node_Id *prev_node_ptr, struct Elist_Header *elists_ptr,\n+                  struct Elmt_Item *elmts_ptr,\n+                  struct String_Entry *strings_ptr,\n+                  Char_Code *strings_chars_ptr,\n+                  struct List_Header *list_headers_ptr,\n+\t\t  Int number_units ATTRIBUTE_UNUSED,\n+                  char *file_info_ptr ATTRIBUTE_UNUSED,\n+                  Entity_Id standard_integer,\n+                  Entity_Id standard_long_long_float,\n+                  Entity_Id standard_exception_type,\n+                  Int gigi_operating_mode);\n \n /* GNAT_NODE is the root of some GNAT tree.  Return the root of the\n    GCC tree corresponding to that GNAT tree.  Normally, no code is generated;\n    we just return an equivalent tree which is used elsewhere to generate\n    code.  */\n-extern tree gnat_to_gnu (Node_Id);\n+extern tree gnat_to_gnu (Node_Id gnat_node);\n \n /* GNU_STMT is a statement.  We generate code for that statement.  */\n-extern void gnat_expand_stmt (tree);\n+extern void gnat_expand_stmt (tree gnu_stmt);\n \n-extern int gnat_gimplify_expr (tree *, tree *, tree *);\n+/* ??? missing documentation */\n+extern int gnat_gimplify_expr (tree *expr_p, tree *pre_p,\n+                               tree *post_p ATTRIBUTE_UNUSED);\n \n /* Do the processing for the declaration of a GNAT_ENTITY, a type.  If\n    a separate Freeze node exists, delay the bulk of the processing.  Otherwise\n    make a GCC type for GNAT_ENTITY and set up the correspondance.  */\n-\n-extern void process_type (Entity_Id);\n+extern void process_type (Entity_Id gnat_entity);\n \n /* Convert Sloc into *LOCUS (a location_t).  Return true if this Sloc\n    corresponds to a source code location and false if it doesn't.  In the\n    latter case, we don't update *LOCUS.  We also set the Gigi global variable\n    REF_FILENAME to the reference file name as given by sinput (i.e no\n    directory).  */\n-extern bool Sloc_to_locus (Source_Ptr, location_t *);\n+extern bool Sloc_to_locus (Source_Ptr Sloc, location_t *locus);\n \n /* Post an error message.  MSG is the error message, properly annotated.\n    NODE is the node at which to post the error and the node to use for the\n@@ -205,28 +217,28 @@ extern void post_error (const char *, Node_Id);\n \n /* Similar, but NODE is the node at which to post the error and ENT\n    is the node to use for the \"&\" substitution.  */\n-extern void post_error_ne (const char *, Node_Id, Entity_Id);\n+extern void post_error_ne (const char *msg, Node_Id node, Entity_Id ent);\n \n /* Similar, but NODE is the node at which to post the error, ENT is the node\n    to use for the \"&\" substitution, and N is the number to use for the ^.  */\n-extern void post_error_ne_num (const char *, Node_Id, Entity_Id, int);\n+extern void post_error_ne_num (const char *msg, Node_Id node, Entity_Id ent,\n+                               int n);\n \n /* Similar to post_error_ne_num, but T is a GCC tree representing the number\n    to write.  If the tree represents a constant that fits within a\n    host integer, the text inside curly brackets in MSG will be output\n    (presumably including a '^').  Otherwise that text will not be output\n    and the text inside square brackets will be output instead.  */\n-extern void post_error_ne_tree (const char *, Node_Id, Entity_Id, tree);\n+extern void post_error_ne_tree (const char *msg, Node_Id node, Entity_Id ent,\n+                                tree t);\n \n /* Similar to post_error_ne_tree, except that NUM is a second\n    integer to write in the message.  */\n-extern void post_error_ne_tree_2 (const char *, Node_Id, Entity_Id, tree, int);\n-\n-/* Set the node for a second '&' in the error message.  */\n-extern void set_second_error_entity (Entity_Id);\n+extern void post_error_ne_tree_2 (const char *msg, Node_Id node, Entity_Id ent,\n+                                  tree t, int num);\n \n /* Protect EXP from multiple evaluation.  This may make a SAVE_EXPR.  */\n-extern tree protect_multiple_eval (tree);\n+extern tree protect_multiple_eval (tree exp);\n \n /* Initialize the table that maps GNAT codes to GCC codes for simple\n    binary and unary operations.  */\n@@ -239,7 +251,7 @@ extern Node_Id error_gnat_node;\n /* This is equivalent to stabilize_reference in GCC's tree.c, but we know\n    how to handle our new nodes and we take an extra argument that says\n    whether to force evaluation of everything.  */\n-extern tree gnat_stabilize_reference (tree, bool);\n+extern tree gnat_stabilize_reference (tree ref, bool force);\n \n /* Highest number in the front-end node table.  */\n extern int max_gnat_nodes;\n@@ -381,53 +393,53 @@ extern void gnat_poplevel (void);\n \n /* Set SUPERCONTEXT of the BLOCK for the current binding level to FNDECL\n    and point FNDECL to this BLOCK.  */\n-extern void set_current_block_context (tree);\n+extern void set_current_block_context (tree fndecl);\n \n /* Set the jmpbuf_decl for the current binding level to DECL.  */\n-extern void set_block_jmpbuf_decl (tree);\n+extern void set_block_jmpbuf_decl (tree decl);\n \n /* Get the setjmp_decl, if any, for the current binding level.  */\n extern tree get_block_jmpbuf_decl (void);\n \n /* Insert BLOCK at the end of the list of subblocks of the\n    current binding level.  This is used when a BIND_EXPR is expanded,\n    to handle the BLOCK node inside the BIND_EXPR.  */\n-extern void insert_block (tree);\n+extern void insert_block (tree block);\n \n /* Records a ..._DECL node DECL as belonging to the current lexical scope\n-   and uses GNAT_ENTITY for location information.  */\n-extern void gnat_pushdecl (tree, Entity_Id);\n+   and uses GNAT_NODE for location information.  */\n+extern void gnat_pushdecl (tree decl, Node_Id gnat_node);\n \n extern void gnat_init_stmt_group (void);\n extern void gnat_init_decl_processing (void);\n-extern void init_gigi_decls (tree, tree);\n+extern void init_gigi_decls (tree long_long_float_type, tree exception_type);\n extern void gnat_init_gcc_eh (void);\n \n /* Return an integer type with the number of bits of precision given by\n    PRECISION.  UNSIGNEDP is nonzero if the type is unsigned; otherwise\n    it is a signed type.  */\n-extern tree gnat_type_for_size (unsigned, int);\n+extern tree gnat_type_for_size (unsigned precision, int unsignedp);\n \n /* Return a data type that has machine mode MODE.  UNSIGNEDP selects\n    an unsigned type; otherwise a signed type is returned.  */\n-extern tree gnat_type_for_mode (enum machine_mode, int);\n+extern tree gnat_type_for_mode (enum machine_mode mode, int unsignedp);\n \n /* Return the unsigned version of a TYPE_NODE, a scalar type.  */\n-extern tree gnat_unsigned_type (tree);\n+extern tree gnat_unsigned_type (tree type_node);\n \n /* Return the signed version of a TYPE_NODE, a scalar type.  */\n-extern tree gnat_signed_type (tree);\n+extern tree gnat_signed_type (tree type_node);\n \n /* Return a type the same as TYPE except unsigned or signed according to\n    UNSIGNEDP.  */\n-extern tree gnat_signed_or_unsigned_type (int, tree);\n+extern tree gnat_signed_or_unsigned_type (int unsignedp, tree type);\n \n /* Create an expression whose value is that of EXPR,\n    converted to type TYPE.  The TREE_TYPE of the value\n    is always TYPE.  This function implements all reasonable\n    conversions; callers should filter out those that are\n    not permitted by the language being compiled.  */\n-extern tree convert (tree, tree);\n+extern tree convert (tree type, tree expr);\n \n /* Routines created solely for the tree translator's sake. Their prototypes\n    can be changed as desired.  */\n@@ -437,15 +449,16 @@ extern tree convert (tree, tree);\n    GNAT_ENTITY. Such gnu tree node is always an ..._DECL node.\n    If NO_CHECK is nonzero, the latter check is suppressed.\n    If GNU_DECL is zero, a previous association is to be reset.  */\n-extern void save_gnu_tree (Entity_Id, tree, bool);\n+extern void save_gnu_tree (Entity_Id gnat_entity, tree gnu_decl,\n+                           bool no_check);\n \n /* GNAT_ENTITY is a GNAT tree node for a defining identifier.\n    Return the ..._DECL node that was associated with it.  If there is no tree\n    node associated with GNAT_ENTITY, abort.  */\n-extern tree get_gnu_tree (Entity_Id);\n+extern tree get_gnu_tree (Entity_Id gnat_entity);\n \n /* Return nonzero if a GCC tree has been associated with GNAT_ENTITY.  */\n-extern bool present_gnu_tree (Entity_Id);\n+extern bool present_gnu_tree (Entity_Id gnat_entity);\n \n /* Initialize tables for above routines.  */\n extern void init_gnat_to_gnu (void);\n@@ -456,7 +469,11 @@ extern void init_gnat_to_gnu (void);\n    layout_type but merely set the size and alignment ourselves.\n    If DEFER_DEBUG is true, do not call the debugging routines\n    on this type; it will be done later. */\n-extern void finish_record_type (tree, tree, bool, bool);\n+extern void finish_record_type (tree record_type, tree fieldlist,\n+                                bool has_rep, bool defer_debug);\n+\n+/*  Output the debug information associated to a record type.  */\n+extern void write_record_type_debug_info (tree);\n \n /* Returns a FUNCTION_TYPE node. RETURN_TYPE is the type returned by the\n    subprogram. If it is void_type_node, then we are dealing with a procedure,\n@@ -469,23 +486,28 @@ extern void finish_record_type (tree, tree, bool, bool);\n    depressed stack pointer.  RETURNS_BY_TARGET_PTR is true if the function\n    is to be passed (as its first parameter) the address of the place to copy\n    its result.  */\n-extern tree create_subprog_type (tree, tree, tree, bool, bool, bool, bool);\n+extern tree create_subprog_type (tree return_type, tree param_decl_list,\n+                                 tree cico_list, bool returns_unconstrained,\n+                                 bool returns_by_ref, bool returns_with_dsp,\n+                                 bool returns_by_target_ptr);\n \n /* Return a copy of TYPE, but safe to modify in any way.  */\n-extern tree copy_type (tree);\n+extern tree copy_type (tree type);\n \n /* Return an INTEGER_TYPE of SIZETYPE with range MIN to MAX and whose\n    TYPE_INDEX_TYPE is INDEX.  */\n-extern tree create_index_type (tree, tree, tree);\n+extern tree create_index_type (tree min, tree max, tree index);\n \n /* Return a TYPE_DECL node. TYPE_NAME gives the name of the type (a character\n    string) and TYPE is a ..._TYPE node giving its data type.\n    ARTIFICIAL_P is true if this is a declaration that was generated\n    by the compiler.  DEBUG_INFO_P is true if we need to write debugging\n    information about this type.  GNAT_NODE is used for the position of\n    the decl.  */\n-extern tree create_type_decl (tree, tree, struct attrib *, bool, bool,\n-\t\t\t      Node_Id);\n+extern tree create_type_decl (tree type_name, tree type,\n+                              struct attrib *attr_list,\n+                              bool artificial_p, bool debug_info_p,\n+\t\t\t      Node_Id gnat_node);\n \n /* Returns a GCC VAR_DECL node. VAR_NAME gives the name of the variable.\n    ASM_NAME is its assembler name (if provided).  TYPE is\n@@ -504,25 +526,31 @@ extern tree create_type_decl (tree, tree, struct attrib *, bool, bool,\n    it indicates whether to always allocate storage to the variable.\n \n    GNAT_NODE is used for the position of the decl.  */\n-extern tree create_var_decl (tree, tree, tree, tree, bool, bool, bool, bool,\n-\t\t\t     struct attrib *, Node_Id);\n+extern tree create_var_decl (tree var_name, tree asm_name, tree type,\n+                             tree var_init, bool const_flag,\n+                             bool public_flag, bool extern_flag,\n+                             bool static_flag,\n+\t\t\t     struct attrib *attr_list, Node_Id gnat_node);\n \n /* Given a DECL and ATTR_LIST, apply the listed attributes.  */\n-extern void process_attributes (tree, struct attrib *);\n+extern void process_attributes (tree decl, struct attrib *attr_list);\n \n /* Returns a FIELD_DECL node. FIELD_NAME the field name, FIELD_TYPE is its\n    type, and RECORD_TYPE is the type of the parent.  PACKED is nonzero if\n    this field is in a record type with a \"pragma pack\".  If SIZE is nonzero\n    it is the specified size for this field.  If POS is nonzero, it is the bit\n    position.  If ADDRESSABLE is nonzero, it means we are allowed to take\n    the address of this field for aliasing purposes.  */\n-extern tree create_field_decl (tree, tree, tree, int, tree, tree, int);\n+extern tree create_field_decl (tree field_name, tree field_type,\n+                               tree record_type, int packed, tree size,\n+                               tree pos, int addressable);\n \n /* Returns a PARM_DECL node. PARAM_NAME is the name of the parameter,\n    PARAM_TYPE is its type.  READONLY is true if the parameter is\n    readonly (either an IN parameter or an address of a pass-by-ref\n    parameter). */\n-extern tree create_param_decl (tree, tree, bool);\n+extern tree create_param_decl (tree param_name, tree param_type,\n+                               bool readonly);\n \n /* Returns a FUNCTION_DECL node.  SUBPROG_NAME is the name of the subprogram,\n    ASM_NAME is its assembler name, SUBPROG_TYPE is its type (a FUNCTION_TYPE\n@@ -531,26 +559,29 @@ extern tree create_param_decl (tree, tree, bool);\n \n    INLINE_FLAG, PUBLIC_FLAG, EXTERN_FLAG, and ATTR_LIST are used to set the\n    appropriate fields in the FUNCTION_DECL.  GNAT_NODE gives the location.  */\n-extern tree create_subprog_decl (tree, tree, tree, tree, bool, bool, bool,\n-\t\t\t\t struct attrib *, Node_Id);\n+extern tree create_subprog_decl (tree subprog_name, tree asm_name,\n+                                 tree subprog_type, tree param_decl_list,\n+                                 bool inlinee_flag, bool public_flag,\n+                                 bool extern_flag,\n+\t\t\t\t struct attrib *attr_list, Node_Id gnat_node);\n \n /* Returns a LABEL_DECL node for LABEL_NAME.  */\n-extern tree create_label_decl (tree);\n+extern tree create_label_decl (tree label_name);\n \n /* Set up the framework for generating code for SUBPROG_DECL, a subprogram\n    body. This routine needs to be invoked before processing the declarations\n    appearing in the subprogram.  */\n-extern void begin_subprog_body (tree);\n+extern void begin_subprog_body (tree subprog_decl);\n \n /* Finish the definition of the current subprogram and compile it all the way\n    to assembler language output.  BODY is the tree corresponding to\n    the subprogram.  */\n-extern void end_subprog_body (tree);\n+extern void end_subprog_body (tree body);\n \n /* Build a template of type TEMPLATE_TYPE from the array bounds of ARRAY_TYPE.\n    EXPR is an expression that we can use to locate any PLACEHOLDER_EXPRs.\n    Return a constructor for the template.  */\n-extern tree build_template (tree, tree, tree);\n+extern tree build_template (tree template_type, tree array_type, tree expr);\n \n /* Build a VMS descriptor from a Mechanism_Type, which must specify\n    a descriptor type, and the GCC type of an object.  Each FIELD_DECL\n@@ -559,102 +590,108 @@ extern tree build_template (tree, tree, tree);\n    to print out an error message if the mechanism cannot be applied to\n    an object of that type and also for the name.  */\n \n-extern tree build_vms_descriptor (tree, Mechanism_Type, Entity_Id);\n+extern tree build_vms_descriptor (tree type, Mechanism_Type mech,\n+                                  Entity_Id gnat_entity);\n \n /* Build a type to be used to represent an aliased object whose nominal\n    type is an unconstrained array.  This consists of a RECORD_TYPE containing\n    a field of TEMPLATE_TYPE and a field of OBJECT_TYPE, which is an\n    ARRAY_TYPE.  If ARRAY_TYPE is that of the unconstrained array, this\n    is used to represent an arbitrary unconstrained object.  Use NAME\n    as the name of the record.  */\n-extern tree build_unc_object_type (tree, tree, tree);\n+extern tree build_unc_object_type (tree template_type, tree object_type,\n+                                   tree name);\n \n /* Update anything previously pointing to OLD_TYPE to point to NEW_TYPE.  In\n    the normal case this is just two adjustments, but we have more to do\n    if NEW is an UNCONSTRAINED_ARRAY_TYPE.  */\n-extern void update_pointer_to (tree, tree);\n+extern void update_pointer_to (tree old_type, tree new_type);\n \n /* EXP is an expression for the size of an object.  If this size contains\n    discriminant references, replace them with the maximum (if MAX_P) or\n    minimum (if !MAX_P) possible value of the discriminant.  */\n-extern tree max_size (tree, bool);\n+extern tree max_size (tree exp, bool max_p);\n \n /* Remove all conversions that are done in EXP.  This includes converting\n    from a padded type or to a left-justified modular type.  If TRUE_ADDRESS\n    is true, always return the address of the containing object even if\n    the address is not bit-aligned.  */\n-extern tree remove_conversions (tree, bool);\n+extern tree remove_conversions (tree exp, bool true_address);\n \n /* If EXP's type is an UNCONSTRAINED_ARRAY_TYPE, return an expression that\n    refers to the underlying array.  If its type has TYPE_CONTAINS_TEMPLATE_P,\n    likewise return an expression pointing to the underlying array.  */\n-extern tree maybe_unconstrained_array (tree);\n+extern tree maybe_unconstrained_array (tree exp);\n \n /* Return an expression that does an unchecked converstion of EXPR to TYPE.\n    If NOTRUNC_P is true, truncation operations should be suppressed.  */\n-extern tree unchecked_convert (tree, tree, bool);\n+extern tree unchecked_convert (tree type, tree expr, bool notrunc_p);\n \n /* Prepare expr to be an argument of a TRUTH_NOT_EXPR or other logical\n    operation.\n \n    This preparation consists of taking the ordinary\n-   representation of an expression expr and producing a valid tree\n-   boolean expression describing whether expr is nonzero.  We could\n+   representation of an expression EXPR and producing a valid tree\n+   boolean expression describing whether EXPR is nonzero.  We could\n    simply always do build_binary_op (NE_EXPR, expr, integer_zero_node, 1),\n    but we optimize comparisons, &&, ||, and !.\n \n    The resulting type should always be the same as the input type.\n    This function is simpler than the corresponding C version since\n    the only possible operands will be things of Boolean type.  */\n-extern tree gnat_truthvalue_conversion (tree);\n+extern tree gnat_truthvalue_conversion (tree expr);\n \n /* Return the base type of TYPE.  */\n-extern tree get_base_type (tree);\n+extern tree get_base_type (tree type);\n \n /* Likewise, but only return types known at Ada source.  */\n-extern tree get_ada_base_type (tree);\n+extern tree get_ada_base_type (tree type);\n \n /* EXP is a GCC tree representing an address.  See if we can find how\n    strictly the object at that address is aligned.   Return that alignment\n    strictly the object at that address is aligned.   Return that alignment\n    in bits.  If we don't know anything about the alignment, return 0.  */\n-extern unsigned int known_alignment (tree);\n+extern unsigned int known_alignment (tree exp);\n \n /* Make a binary operation of kind OP_CODE.  RESULT_TYPE is the type\n    desired for the result.  Usually the operation is to be performed\n    in that type.  For MODIFY_EXPR and ARRAY_REF, RESULT_TYPE may be 0\n    in which case the type to be used will be derived from the operands.  */\n-extern tree build_binary_op (enum tree_code, tree, tree, tree);\n+extern tree build_binary_op (enum tree_code op_code, tree retult_type,\n+                             tree left_operand, tree right_operand);\n \n /* Similar, but make unary operation.   */\n-extern tree build_unary_op (enum tree_code, tree, tree);\n+extern tree build_unary_op (enum tree_code op_code, tree result_type,\n+                            tree operand);\n \n /* Similar, but for COND_EXPR.  */\n-extern tree build_cond_expr (tree, tree, tree, tree);\n+extern tree build_cond_expr (tree result_type, tree condition_operand,\n+                             tree true_operand, tree false_operand);\n \n /* Build a CALL_EXPR to call FUNDECL with one argument, ARG.  Return\n    the CALL_EXPR.  */\n-extern tree build_call_1_expr (tree, tree);\n+extern tree build_call_1_expr (tree fundecl, tree arg);\n \n /* Build a CALL_EXPR to call FUNDECL with two argument, ARG1 & ARG2.  Return\n    the CALL_EXPR.  */\n-extern tree build_call_2_expr (tree, tree, tree);\n+extern tree build_call_2_expr (tree fundecl, tree arg1, tree arg2);\n \n /* Likewise to call FUNDECL with no arguments.  */\n-extern tree build_call_0_expr (tree);\n+extern tree build_call_0_expr (tree fundecl);\n \n /* Call a function that raises an exception and pass the line number and file\n    name, if requested.  MSG says which exception function to call.  */\n-extern tree build_call_raise (int);\n+extern tree build_call_raise (int msg);\n \n /* Return a CONSTRUCTOR of TYPE whose list is LIST.  This is not the\n    same as build_constructor in the language-independent tree.c.  */\n-extern tree gnat_build_constructor (tree, tree);\n+extern tree gnat_build_constructor (tree type, tree list);\n \n /* Return a COMPONENT_REF to access a field that is given by COMPONENT,\n    an IDENTIFIER_NODE giving the name of the field, FIELD, a FIELD_DECL,\n    for the field, or both.  Don't fold the result if NO_FOLD_P.  */\n-extern tree build_component_ref (tree, tree, tree, bool);\n+extern tree build_component_ref (tree record_variable, tree component,\n+                                 tree field, bool no_fold_p);\n \n /* Build a GCC tree to call an allocation or deallocation function.\n    If GNU_OBJ is nonzero, it is an object to deallocate.  Otherwise,\n@@ -663,34 +700,38 @@ extern tree build_component_ref (tree, tree, tree, bool);\n    GNU_SIZE is the size of the object and ALIGN is the alignment.\n    GNAT_PROC, if present is a procedure to call and GNAT_POOL is the\n    storage pool to use.  If not preset, malloc and free will be used.  */\n-extern tree build_call_alloc_dealloc (tree, tree, unsigned int, Entity_Id,\n-\t\t\t\t      Entity_Id, Node_Id);\n+extern tree build_call_alloc_dealloc (tree gnu_obj, tree gnu_size,\n+                                      unsigned align, Entity_Id gnat_proc,\n+\t\t\t\t      Entity_Id gnat_pool, Node_Id gnat_node);\n \n /* Build a GCC tree to correspond to allocating an object of TYPE whose\n    initial value if INIT, if INIT is nonzero.  Convert the expression to\n    RESULT_TYPE, which must be some type of pointer.  Return the tree.\n    GNAT_PROC and GNAT_POOL optionally give the procedure to call and\n    the storage pool to use.  GNAT_NODE is used to provide an error\n    location for restriction violations messages.  */\n-extern tree build_allocator (tree, tree, tree, Entity_Id, Entity_Id, Node_Id);\n+extern tree build_allocator (tree type, tree init, tree result_type,\n+                             Entity_Id gnat_proc, Entity_Id gnat_pool,\n+                             Node_Id gnat_node);\n \n /* Fill in a VMS descriptor for EXPR and return a constructor for it.\n    GNAT_FORMAL is how we find the descriptor record.  */\n \n-extern tree fill_vms_descriptor (tree, Entity_Id);\n+extern tree fill_vms_descriptor (tree expr, Entity_Id gnat_formal);\n \n /* Indicate that we need to make the address of EXPR_NODE and it therefore\n    should not be allocated in a register.  Return true if successful.  */\n-extern bool gnat_mark_addressable (tree);\n+extern bool gnat_mark_addressable (tree expr_node);\n \n /* Implementation of the builtin_function langhook.  */\n-extern tree builtin_function (const char *, tree, int, enum built_in_class,\n-\t\t\t      const char *, tree);\n+extern tree builtin_function (const char *name, tree type, int function_code,\n+                              enum built_in_class class,\n+\t\t\t      const char *library_name, tree attrs);\n \n /* Search the chain of currently reachable declarations for a builtin\n    FUNCTION_DECL node corresponding to function NAME (an IDENTIFIER_NODE).\n    Return the first node found, if any, or NULL_TREE otherwise.  */\n-extern tree builtin_decl_for (tree);\n+extern tree builtin_decl_for (tree name ATTRIBUTE_UNUSED);\n \n /* This function is called by the front end to enumerate all the supported\n    modes for the machine.  We pass a function which is called back with\n@@ -708,8 +749,8 @@ extern void enumerate_modes (void (*f) (int, int, int, int, int, int,\n \n /* These are temporary function to deal with recent GCC changes related to\n    FP type sizes and precisions.  */\n-extern int fp_prec_to_size (int);\n-extern int fp_size_to_prec (int);\n+extern int fp_prec_to_size (int prec);\n+extern int fp_size_to_prec (int size);\n \n /* These functions return the basic data type sizes and related parameters\n    about the target machine.  */"}, {"sha": "e1bd1e8bd9689369193af8f64f3b6b669233c726", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 62, "deletions": 29, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6823a20b27d6a03efb122e7e20153adb2d805ed/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6823a20b27d6a03efb122e7e20153adb2d805ed/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=c6823a20b27d6a03efb122e7e20153adb2d805ed", "patch": "@@ -350,13 +350,13 @@ package body Sem_Ch3 is\n    --  discriminant constraints for Typ.\n \n    function Constrain_Component_Type\n-     (Compon_Type     : Entity_Id;\n+     (Comp            : Entity_Id;\n       Constrained_Typ : Entity_Id;\n       Related_Node    : Node_Id;\n       Typ             : Entity_Id;\n       Constraints     : Elist_Id) return Entity_Id;\n    --  Given a discriminated base type Typ, a list of discriminant constraint\n-   --  Constraints for Typ and the type of a component of Typ, Compon_Type,\n+   --  Constraints for Typ and a component of Typ, with type Compon_Type,\n    --  create and return the type corresponding to Compon_type where all\n    --  discriminant references are replaced with the corresponding\n    --  constraint. If no discriminant references occur in Compon_Typ then\n@@ -2378,6 +2378,7 @@ package body Sem_Ch3 is\n       Set_Is_Volatile       (Id, Is_Volatile       (T));\n       Set_Treat_As_Volatile (Id, Treat_As_Volatile (T));\n       Set_Is_Atomic         (Id, Is_Atomic         (T));\n+      Set_Is_Ada_2005       (Id, Is_Ada_2005       (T));\n \n       --  In the case where there is no constraint given in the subtype\n       --  indication, Process_Subtype just returns the Subtype_Mark,\n@@ -7374,12 +7375,7 @@ package body Sem_Ch3 is\n       Set_Depends_On_Private       (Def_Id, Has_Private_Component (Def_Id));\n       Set_Is_Access_Constant       (Def_Id, Is_Access_Constant (T));\n \n-      --  Itypes created for constrained record components do not receive\n-      --  a freeze node, they are elaborated when first seen.\n-\n-      if not Is_Record_Type (Current_Scope) then\n-         Conditional_Delay (Def_Id, T);\n-      end if;\n+      Conditional_Delay (Def_Id, T);\n    end Constrain_Access;\n \n    ---------------------\n@@ -7474,17 +7470,12 @@ package body Sem_Ch3 is\n       Set_Is_Private_Composite (Def_Id, Is_Private_Composite (T));\n       Set_Is_Limited_Composite (Def_Id, Is_Limited_Composite (T));\n \n-      --  If the subtype is not that of a record component, build a freeze\n-      --  node if parent still needs one.\n-\n-      --  If the subtype is not that of a record component, make sure\n+      --  Build a freeze node if parent still needs one.  Also, make sure\n       --  that the Depends_On_Private status is set (explanation ???)\n       --  and also that a conditional delay is set.\n \n-      if not Is_Type (Scope (Def_Id)) then\n-         Set_Depends_On_Private (Def_Id, Depends_On_Private (T));\n-         Conditional_Delay (Def_Id, T);\n-      end if;\n+      Set_Depends_On_Private (Def_Id, Depends_On_Private (T));\n+      Conditional_Delay (Def_Id, T);\n \n    end Constrain_Array;\n \n@@ -7493,13 +7484,14 @@ package body Sem_Ch3 is\n    ------------------------------\n \n    function Constrain_Component_Type\n-     (Compon_Type     : Entity_Id;\n+     (Comp            : Entity_Id;\n       Constrained_Typ : Entity_Id;\n       Related_Node    : Node_Id;\n       Typ             : Entity_Id;\n       Constraints     : Elist_Id) return Entity_Id\n    is\n-      Loc : constant Source_Ptr := Sloc (Constrained_Typ);\n+      Loc         : constant Source_Ptr := Sloc (Constrained_Typ);\n+      Compon_Type : constant Entity_Id := Etype (Comp);\n \n       function Build_Constrained_Array_Type\n         (Old_Type : Entity_Id) return Entity_Id;\n@@ -7876,17 +7868,28 @@ package body Sem_Ch3 is\n    --  Start of processing for Constrain_Component_Type\n \n    begin\n-      if Is_Array_Type (Compon_Type) then\n+      if Nkind (Parent (Comp)) = N_Component_Declaration\n+        and then Comes_From_Source (Parent (Comp))\n+        and then Comes_From_Source\n+          (Subtype_Indication (Component_Definition (Parent (Comp))))\n+        and then\n+          Is_Entity_Name\n+            (Subtype_Indication (Component_Definition (Parent (Comp))))\n+      then\n+         return Compon_Type;\n+\n+      elsif Is_Array_Type (Compon_Type) then\n          return Build_Constrained_Array_Type (Compon_Type);\n \n       elsif Has_Discriminants (Compon_Type) then\n          return Build_Constrained_Discriminated_Type (Compon_Type);\n \n       elsif Is_Access_Type (Compon_Type) then\n          return Build_Constrained_Access_Type (Compon_Type);\n-      end if;\n \n-      return Compon_Type;\n+      else\n+         return Compon_Type;\n+      end if;\n    end Constrain_Component_Type;\n \n    --------------------------\n@@ -8723,7 +8726,7 @@ package body Sem_Ch3 is\n             Set_Etype\n               (New_C,\n                Constrain_Component_Type\n-                 (Etype (Old_C), Subt, Decl_Node, Typ, Constraints));\n+                 (Old_C, Subt, Decl_Node, Typ, Constraints));\n             Set_Is_Public (New_C, Is_Public (Subt));\n \n             Next_Elmt (Comp);\n@@ -8875,7 +8878,7 @@ package body Sem_Ch3 is\n             Set_Etype\n               (New_C,\n                Constrain_Component_Type\n-                 (Etype (Old_C), Subt, Decl_Node, Typ, Constraints));\n+                 (Old_C, Subt, Decl_Node, Typ, Constraints));\n             Set_Is_Public (New_C, Is_Public (Subt));\n \n             Next_Component (Old_C);\n@@ -9570,6 +9573,36 @@ package body Sem_Ch3 is\n       Parent_Scope : Entity_Id;\n       Taggd        : Boolean;\n \n+      function Comes_From_Generic (Typ : Entity_Id) return Boolean;\n+      --  Check whether the parent type is a generic formal, or derives\n+      --  directly or indirectly from one.\n+\n+      ------------------------\n+      -- Comes_From_Generic --\n+      ------------------------\n+\n+      function Comes_From_Generic (Typ : Entity_Id) return Boolean is\n+      begin\n+         if Is_Generic_Type (Typ) then\n+            return True;\n+\n+         elsif Is_Generic_Type (Root_Type (Parent_Type)) then\n+            return True;\n+\n+         elsif Is_Private_Type (Typ)\n+           and then Present (Full_View (Typ))\n+           and then Is_Generic_Type (Root_Type (Full_View (Typ)))\n+         then\n+            return True;\n+\n+         elsif Is_Generic_Actual_Type (Typ) then\n+            return True;\n+\n+         else\n+            return False;\n+         end if;\n+      end Comes_From_Generic;\n+\n    begin\n       Parent_Type := Find_Type_Of_Subtype_Indic (Indic);\n \n@@ -9645,9 +9678,7 @@ package body Sem_Ch3 is\n          return;\n \n       elsif (Is_Incomplete_Or_Private_Type (Parent_Type)\n-              and then not Is_Generic_Type (Parent_Type)\n-              and then not Is_Generic_Type (Root_Type (Parent_Type))\n-              and then not Is_Generic_Actual_Type (Parent_Type))\n+              and then not Comes_From_Generic (Parent_Type))\n         or else Has_Private_Component (Parent_Type)\n       then\n          --  The ancestor type of a formal type can be incomplete, in which\n@@ -9666,7 +9697,7 @@ package body Sem_Ch3 is\n               (\"premature derivation of derived or private type\", Indic);\n \n             --  Flag the type itself as being in error, this prevents some\n-            --  nasty problems with people looking at the malformed type.\n+            --  nasty problems with subsequent uses of the malformed type.\n \n             Set_Error_Posted (T);\n \n@@ -10685,8 +10716,10 @@ package body Sem_Ch3 is\n             then\n                Set_Etype (New_C, Etype (Old_C));\n             else\n-               Set_Etype (New_C, Constrain_Component_Type (Etype (Old_C),\n-                 Derived_Base, N, Parent_Base, Discs));\n+               Set_Etype\n+                 (New_C,\n+                  Constrain_Component_Type\n+                    (Old_C, Derived_Base, N, Parent_Base, Discs));\n             end if;\n          end if;\n "}, {"sha": "9bcc45e5e6368ce6e32113750b4dda404df387ac", "filename": "gcc/ada/trans.c", "status": "modified", "additions": 45, "deletions": 31, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6823a20b27d6a03efb122e7e20153adb2d805ed/gcc%2Fada%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6823a20b27d6a03efb122e7e20153adb2d805ed/gcc%2Fada%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftrans.c?ref=c6823a20b27d6a03efb122e7e20153adb2d805ed", "patch": "@@ -2956,7 +2956,7 @@ gnat_to_gnu (Node_Id gnat_node)\n \t\t\t\t       NULL_TREE, gnu_prefix);\n \telse\n \t  {\n-\t    gnu_field = gnat_to_gnu_entity (gnat_field, NULL_TREE, 0);\n+\t    gnu_field = gnat_to_gnu_field_decl (gnat_field);\n \n \t    /* If there are discriminants, the prefix might be\n                evaluated more than once, which is a problem if it has\n@@ -3013,6 +3013,8 @@ gnat_to_gnu (Node_Id gnat_node)\n \t/* ??? It is wrong to evaluate the type now, but there doesn't\n \t   seem to be any other practical way of doing it.  */\n \n+\tgcc_assert (!Expansion_Delayed (gnat_node));\n+\n \tgnu_aggr_type = gnu_result_type\n \t  = get_unpadded_type (Etype (gnat_node));\n \n@@ -3497,11 +3499,7 @@ gnat_to_gnu (Node_Id gnat_node)\n \t/* The return value from the subprogram.  */\n \ttree gnu_ret_val = NULL_TREE;\n \t/* The place to put the return value.  */\n-\ttree gnu_lhs\n-\t  = (TYPE_RETURNS_BY_TARGET_PTR_P (gnu_subprog_type)\n-\t     ? build_unary_op (INDIRECT_REF, NULL_TREE,\n-\t\t\t       DECL_ARGUMENTS (current_function_decl))\n-\t     : DECL_RESULT (current_function_decl));\n+\ttree gnu_lhs;\n \n \t/* If we are dealing with a \"return;\" from an Ada procedure with\n \t   parameters passed by copy in copy out, we need to return a record\n@@ -3524,6 +3522,7 @@ gnat_to_gnu (Node_Id gnat_node)\n \n \telse if (TYPE_CI_CO_LIST (gnu_subprog_type))\n \t  {\n+\t    gnu_lhs = DECL_RESULT (current_function_decl);\n \t    if (list_length (TYPE_CI_CO_LIST (gnu_subprog_type)) == 1)\n \t      gnu_ret_val = TREE_VALUE (TYPE_CI_CO_LIST (gnu_subprog_type));\n \t    else\n@@ -3543,12 +3542,26 @@ gnat_to_gnu (Node_Id gnat_node)\n \t       are doing a call, pass that target to the call.  */\n \t    if (TYPE_RETURNS_BY_TARGET_PTR_P (gnu_subprog_type)\n \t\t&& Nkind (Expression (gnat_node)) == N_Function_Call)\n-\t      gnu_ret_val = call_to_gnu (Expression (gnat_node),\n-\t\t\t\t\t &gnu_result_type, gnu_lhs);\n+\t      {\n+\t        gnu_lhs\n+\t\t  = build_unary_op (INDIRECT_REF, NULL_TREE,\n+\t\t\t\t    DECL_ARGUMENTS (current_function_decl));\n+\t\tgnu_result = call_to_gnu (Expression (gnat_node),\n+\t\t\t\t\t  &gnu_result_type, gnu_lhs);\n+\t      }\n \t    else\n \t      {\n \t\tgnu_ret_val = gnat_to_gnu (Expression (gnat_node));\n \n+\t\tif (TYPE_RETURNS_BY_TARGET_PTR_P (gnu_subprog_type))\n+\t\t  /* The original return type was unconstrained so dereference\n+\t\t     the TARGET pointer in the actual return value's type. */\n+\t\t  gnu_lhs\n+\t\t    = build_unary_op (INDIRECT_REF, TREE_TYPE (gnu_ret_val),\n+\t\t\t\t      DECL_ARGUMENTS (current_function_decl));\n+\t\telse\n+\t\t  gnu_lhs = DECL_RESULT (current_function_decl);\n+\n \t\t/* Do not remove the padding from GNU_RET_VAL if the inner\n \t\t   type is self-referential since we want to allocate the fixed\n \t\t   size in that case.  */\n@@ -3591,18 +3604,19 @@ gnat_to_gnu (Node_Id gnat_node)\n \t\t\t\t\t   gnat_node);\n \t\t  }\n \t      }\n+\t  }\n \n-\t    gnu_result = build2 (MODIFY_EXPR, TREE_TYPE (gnu_ret_val),\n-\t\t\t\t gnu_lhs, gnu_ret_val);\n-\t    if (TYPE_RETURNS_BY_TARGET_PTR_P (gnu_subprog_type))\n-\t      {\n-\t\tadd_stmt_with_node (gnu_result, gnat_node);\n-\t\tgnu_ret_val = NULL_TREE;\n-\t      }\n+\tif (gnu_ret_val)\n+\t  gnu_result = build2 (MODIFY_EXPR, TREE_TYPE (gnu_ret_val),\n+\t\t\t       gnu_lhs, gnu_ret_val);\n+\n+\tif (TYPE_RETURNS_BY_TARGET_PTR_P (gnu_subprog_type))\n+\t  {\n+\t    add_stmt_with_node (gnu_result, gnat_node);\n+\t    gnu_result = NULL_TREE;\n \t  }\n \n-\tgnu_result =  build1 (RETURN_EXPR, void_type_node,\n-\t\t\t      gnu_ret_val ? gnu_result : gnu_ret_val);\n+\tgnu_result = build1 (RETURN_EXPR, void_type_node, gnu_result);\n       }\n       break;\n \n@@ -4021,12 +4035,14 @@ gnat_to_gnu (Node_Id gnat_node)\n       current_function_decl = NULL_TREE;\n     }\n \n-  /* Set the location information into the result.  If we're supposed to\n-     return something of void_type, it means we have something we're\n-     elaborating for effect, so just return.  */\n-  if (EXPR_P (gnu_result))\n+  /* Set the location information into the result.  Note that we may have\n+     no result if we tried to build a CALL_EXPR node to a procedure with\n+     no side-effects and optimization is enabled.  */\n+  if (gnu_result && EXPR_P (gnu_result))\n     annotate_with_node (gnu_result, gnat_node);\n \n+  /* If we're supposed to return something of void_type, it means we have\n+     something we're elaborating for effect, so just return.  */\n   if (TREE_CODE (gnu_result_type) == VOID_TYPE)\n     return gnu_result;\n \n@@ -4807,7 +4823,7 @@ process_inlined_subprograms (Node_Id gnat_node)\n \n   /* If we can inline, generate RTL for all the inlined subprograms.\n      Define the entity first so we set DECL_EXTERNAL.  */\n-  if (optimize > 0 && !flag_no_inline)\n+  if (optimize > 0 && !flag_really_no_inline)\n     for (gnat_entity = First_Inlined_Subprogram (gnat_node);\n \t Present (gnat_entity);\n \t gnat_entity = Next_Inlined_Subprogram (gnat_entity))\n@@ -5439,13 +5455,19 @@ assoc_to_constructor (Node_Id gnat_assoc, tree gnu_type)\n        gnat_assoc = Next (gnat_assoc))\n     {\n       Node_Id gnat_field = First (Choices (gnat_assoc));\n-      tree gnu_field = gnat_to_gnu_entity (Entity (gnat_field), NULL_TREE, 0);\n+      tree gnu_field = gnat_to_gnu_field_decl (Entity (gnat_field));\n       tree gnu_expr = gnat_to_gnu (Expression (gnat_assoc));\n \n       /* The expander is supposed to put a single component selector name\n \t in every record component association */\n       gcc_assert (No (Next (gnat_field)));\n \n+      /* Ignore fields that have Corresponding_Discriminants since we'll\n+\t be setting that field in the parent.  */\n+      if (Present (Corresponding_Discriminant (Entity (gnat_field)))\n+\t  && Is_Tagged_Type (Scope (Entity (gnat_field))))\n+\tcontinue;\n+\n       /* Before assigning a value in an aggregate make sure range checks\n \t are done if required.  Then convert to the type of the field.  */\n       if (Do_Range_Check (Expression (gnat_assoc)))\n@@ -5956,14 +5978,6 @@ post_error_ne_tree_2 (const char *msg,\n   Error_Msg_Uint_2 = UI_From_Int (num);\n   post_error_ne_tree (msg, node, ent, t);\n }\n-\n-/* Set the node for a second '&' in the error message.  */\n-\n-void\n-set_second_error_entity (Entity_Id e)\n-{\n-  Error_Msg_Node_2 = e;\n-}\n \f\n /* Initialize the table that maps GNAT codes to GCC codes for simple\n    binary and unary operations.  */"}, {"sha": "762ec307ff69471f201efba520c348595806f494", "filename": "gcc/ada/utils.c", "status": "modified", "additions": 178, "deletions": 166, "changes": 344, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6823a20b27d6a03efb122e7e20153adb2d805ed/gcc%2Fada%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6823a20b27d6a03efb122e7e20153adb2d805ed/gcc%2Fada%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Futils.c?ref=c6823a20b27d6a03efb122e7e20153adb2d805ed", "patch": "@@ -359,8 +359,8 @@ gnat_pushdecl (tree decl, Node_Id gnat_node)\n \t      && !DECL_ARTIFICIAL (decl))))\n     TYPE_NAME (TREE_TYPE (decl)) = decl;\n \n-  if (TREE_CODE (decl) != CONST_DECL)\n-    rest_of_decl_compilation (decl, global_bindings_p (), 0);\n+  /*  if (TREE_CODE (decl) != CONST_DECL)\n+      rest_of_decl_compilation (decl, global_bindings_p (), 0); */\n }\n \f\n /* Do little here.  Set up the standard declarations later after the\n@@ -804,156 +804,181 @@ finish_record_type (tree record_type, tree fieldlist, bool has_rep,\n     }\n \n   if (!defer_debug)\n+    write_record_type_debug_info (record_type);\n+}\n+\n+/* Output the debug information associated to a record type.  */\n+\n+void\n+write_record_type_debug_info (tree record_type)\n+{\n+  tree fieldlist = TYPE_FIELDS (record_type);\n+  tree field;\n+  bool var_size = false;\n+\n+  for (field = fieldlist; field; field = TREE_CHAIN (field))\n+    {\n+      /* We need to make an XVE/XVU record if any field has variable size,\n+\t whether or not the record does.  For example, if we have an union,\n+\t it may be that all fields, rounded up to the alignment, have the\n+\t same size, in which case we'll use that size.  But the debug\n+\t output routines (except Dwarf2) won't be able to output the fields,\n+\t so we need to make the special record.  */\n+      if (TREE_CODE (DECL_SIZE (field)) != INTEGER_CST)\n+\t{\n+\t  var_size = true;\n+\t  break;\n+\t}\n+    }\n+\n+  /* If this record is of variable size, rename it so that the\n+     debugger knows it is and make a new, parallel, record\n+     that tells the debugger how the record is laid out.  See\n+     exp_dbug.ads.  But don't do this for records that are padding\n+     since they confuse GDB.  */\n+  if (var_size\n+      && !(TREE_CODE (record_type) == RECORD_TYPE\n+\t   && TYPE_IS_PADDING_P (record_type)))\n     {\n-      /* If this record is of variable size, rename it so that the\n-\t debugger knows it is and make a new, parallel, record\n-\t that tells the debugger how the record is laid out.  See\n-\t exp_dbug.ads.  But don't do this for records that are padding\n-\t since they confuse GDB.  */\n-      if (var_size\n-\t  && !(TREE_CODE (record_type) == RECORD_TYPE\n-\t       && TYPE_IS_PADDING_P (record_type)))\n+      tree new_record_type\n+\t= make_node (TREE_CODE (record_type) == QUAL_UNION_TYPE\n+\t\t     ? UNION_TYPE : TREE_CODE (record_type));\n+      tree orig_name = TYPE_NAME (record_type);\n+      tree orig_id\n+\t= (TREE_CODE (orig_name) == TYPE_DECL ? DECL_NAME (orig_name)\n+\t   : orig_name);\n+      tree new_id\n+\t= concat_id_with_name (orig_id,\n+\t\t\t       TREE_CODE (record_type) == QUAL_UNION_TYPE\n+\t\t\t       ? \"XVU\" : \"XVE\");\n+      tree last_pos = bitsize_zero_node;\n+      tree old_field;\n+      tree prev_old_field = 0;\n+\n+      TYPE_NAME (new_record_type) = new_id;\n+      TYPE_ALIGN (new_record_type) = BIGGEST_ALIGNMENT;\n+      TYPE_STUB_DECL (new_record_type)\n+\t= build_decl (TYPE_DECL, NULL_TREE, new_record_type);\n+      DECL_ARTIFICIAL (TYPE_STUB_DECL (new_record_type)) = 1;\n+      DECL_IGNORED_P (TYPE_STUB_DECL (new_record_type))\n+\t= DECL_IGNORED_P (TYPE_STUB_DECL (record_type));\n+      TYPE_SIZE (new_record_type) = size_int (TYPE_ALIGN (record_type));\n+      TYPE_SIZE_UNIT (new_record_type)\n+\t= size_int (TYPE_ALIGN (record_type) / BITS_PER_UNIT);\n+\n+      /* Now scan all the fields, replacing each field with a new\n+\t field corresponding to the new encoding.  */\n+      for (old_field = TYPE_FIELDS (record_type); old_field;\n+\t   old_field = TREE_CHAIN (old_field))\n \t{\n-\t  tree new_record_type\n-\t    = make_node (TREE_CODE (record_type) == QUAL_UNION_TYPE\n-\t\t\t ? UNION_TYPE : TREE_CODE (record_type));\n-\t  tree orig_name = TYPE_NAME (record_type);\n-\t  tree orig_id\n-\t    = (TREE_CODE (orig_name) == TYPE_DECL ? DECL_NAME (orig_name)\n-\t       : orig_name);\n-\t  tree new_id\n-\t    = concat_id_with_name (orig_id,\n-\t\t\t\t   TREE_CODE (record_type) == QUAL_UNION_TYPE\n-\t\t\t\t   ? \"XVU\" : \"XVE\");\n-\t  tree last_pos = bitsize_zero_node;\n-\t  tree old_field;\n-\t  tree prev_old_field = 0;\n-\n-\t  TYPE_NAME (new_record_type) = new_id;\n-\t  TYPE_ALIGN (new_record_type) = BIGGEST_ALIGNMENT;\n-\t  TYPE_STUB_DECL (new_record_type)\n-\t    = build_decl (TYPE_DECL, NULL_TREE, new_record_type);\n-\t  DECL_ARTIFICIAL (TYPE_STUB_DECL (new_record_type)) = 1;\n-\t  DECL_IGNORED_P (TYPE_STUB_DECL (new_record_type))\n-\t    = DECL_IGNORED_P (TYPE_STUB_DECL (record_type));\n-\t  TYPE_SIZE (new_record_type) = size_int (TYPE_ALIGN (record_type));\n-\t  TYPE_SIZE_UNIT (new_record_type)\n-  \t    = size_int (TYPE_ALIGN (record_type) / BITS_PER_UNIT);\n-\n-\t  /* Now scan all the fields, replacing each field with a new\n-\t     field corresponding to the new encoding.  */\n-\t  for (old_field = TYPE_FIELDS (record_type); old_field;\n-\t       old_field = TREE_CHAIN (old_field))\n+\t  tree field_type = TREE_TYPE (old_field);\n+\t  tree field_name = DECL_NAME (old_field);\n+\t  tree new_field;\n+\t  tree curpos = bit_position (old_field);\n+\t  bool var = false;\n+\t  unsigned int align = 0;\n+\t  tree pos;\n+\n+\t  /* See how the position was modified from the last position.\n+\n+\t  There are two basic cases we support: a value was added\n+\t  to the last position or the last position was rounded to\n+\t  a boundary and they something was added.  Check for the\n+\t  first case first.  If not, see if there is any evidence\n+\t  of rounding.  If so, round the last position and try\n+\t  again.\n+\n+\t  If this is a union, the position can be taken as zero. */\n+\n+\t  if (TREE_CODE (new_record_type) == UNION_TYPE)\n+\t    pos = bitsize_zero_node, align = 0;\n+\t  else\n+\t    pos = compute_related_constant (curpos, last_pos);\n+\n+\t  if (!pos && TREE_CODE (curpos) == MULT_EXPR\n+\t      && TREE_CODE (TREE_OPERAND (curpos, 1)) == INTEGER_CST)\n \t    {\n-\t      tree field_type = TREE_TYPE (old_field);\n-\t      tree field_name = DECL_NAME (old_field);\n-\t      tree new_field;\n-\t      tree curpos = bit_position (old_field);\n-\t      bool var = false;\n-\t      unsigned int align = 0;\n-\t      tree pos;\n-\n-\t      /* See how the position was modified from the last position.\n-\n-\t\t There are two basic cases we support: a value was added\n-\t\t to the last position or the last position was rounded to\n-\t\t a boundary and they something was added.  Check for the\n-\t\t first case first.  If not, see if there is any evidence\n-\t\t of rounding.  If so, round the last position and try\n-\t\t again.\n-\n-\t\t If this is a union, the position can be taken as zero. */\n-\n-\t      if (TREE_CODE (new_record_type) == UNION_TYPE)\n-\t\tpos = bitsize_zero_node, align = 0;\n-\t      else\n-\t\tpos = compute_related_constant (curpos, last_pos);\n-\n-\t      if (!pos && TREE_CODE (curpos) == MULT_EXPR\n-\t\t  && TREE_CODE (TREE_OPERAND (curpos, 1)) == INTEGER_CST)\n-\t\t{\n-\t\t  align = TREE_INT_CST_LOW (TREE_OPERAND (curpos, 1));\n-\t\t  pos = compute_related_constant (curpos,\n-\t\t\t\t\t\t  round_up (last_pos, align));\n-\t\t}\n-\t      else if (!pos && TREE_CODE (curpos) == PLUS_EXPR\n-\t\t       && TREE_CODE (TREE_OPERAND (curpos, 1)) == INTEGER_CST\n-\t\t       && TREE_CODE (TREE_OPERAND (curpos, 0)) == MULT_EXPR\n-\t\t       && host_integerp (TREE_OPERAND\n-\t\t\t\t\t (TREE_OPERAND (curpos, 0), 1),\n-\t\t\t\t\t 1))\n-\t\t{\n-\t\t  align\n-\t\t    = tree_low_cst\n-\t\t      (TREE_OPERAND (TREE_OPERAND (curpos, 0), 1), 1);\n-\t\t  pos = compute_related_constant (curpos,\n-\t\t\t\t\t\t  round_up (last_pos, align));\n-\t\t}\n- \t      else if (potential_alignment_gap (prev_old_field, old_field,\n-\t\t\t\t\t\tpos))\n- \t\t{\n- \t\t  align = TYPE_ALIGN (field_type);\n- \t\t  pos = compute_related_constant (curpos,\n- \t\t\t\t\t\t  round_up (last_pos, align));\n- \t\t}\n-\n-\t      /* If we can't compute a position, set it to zero.\n-\n-\t\t ??? We really should abort here, but it's too much work\n-\t\t to get this correct for all cases.  */\n-\n-\t      if (!pos)\n-\t\tpos = bitsize_zero_node;\n-\n-\t      /* See if this type is variable-size and make a new type\n-\t\t and indicate the indirection if so.  */\n-\t      if (TREE_CODE (DECL_SIZE (old_field)) != INTEGER_CST)\n-\t\t{\n-\t\t  field_type = build_pointer_type (field_type);\n-\t\t  var = true;\n-\t\t}\n-\n-\t      /* Make a new field name, if necessary.  */\n-\t      if (var || align != 0)\n-\t\t{\n-\t\t  char suffix[6];\n-\n-\t\t  if (align != 0)\n-\t\t    sprintf (suffix, \"XV%c%u\", var ? 'L' : 'A',\n-\t\t\t     align / BITS_PER_UNIT);\n-\t\t  else\n-\t\t    strcpy (suffix, \"XVL\");\n-\n-\t\t  field_name = concat_id_with_name (field_name, suffix);\n-\t\t}\n-\n-\t      new_field = create_field_decl (field_name, field_type,\n-\t\t\t\t\t     new_record_type, 0,\n-\t\t\t\t\t     DECL_SIZE (old_field), pos, 0);\n-\t      TREE_CHAIN (new_field) = TYPE_FIELDS (new_record_type);\n-\t      TYPE_FIELDS (new_record_type) = new_field;\n-\n-\t      /* If old_field is a QUAL_UNION_TYPE, take its size as being\n-\t\t zero.  The only time it's not the last field of the record\n-\t\t is when there are other components at fixed positions after\n-\t\t it (meaning there was a rep clause for every field) and we\n-\t\t want to be able to encode them.  */\n-\t      last_pos = size_binop (PLUS_EXPR, bit_position (old_field),\n-\t\t\t\t     (TREE_CODE (TREE_TYPE (old_field))\n-\t\t\t\t      == QUAL_UNION_TYPE)\n-\t\t\t\t     ? bitsize_zero_node\n-\t\t\t\t     : DECL_SIZE (old_field));\n- \t      prev_old_field = old_field;\n+\t      align = TREE_INT_CST_LOW (TREE_OPERAND (curpos, 1));\n+\t      pos = compute_related_constant (curpos,\n+\t\t\t\t\t      round_up (last_pos, align));\n \t    }\n+\t  else if (!pos && TREE_CODE (curpos) == PLUS_EXPR\n+\t\t   && TREE_CODE (TREE_OPERAND (curpos, 1)) == INTEGER_CST\n+\t\t   && TREE_CODE (TREE_OPERAND (curpos, 0)) == MULT_EXPR\n+\t\t   && host_integerp (TREE_OPERAND\n+\t\t\t\t     (TREE_OPERAND (curpos, 0), 1),\n+\t\t\t\t     1))\n+\t    {\n+\t      align\n+\t\t= tree_low_cst\n+\t\t(TREE_OPERAND (TREE_OPERAND (curpos, 0), 1), 1);\n+\t      pos = compute_related_constant (curpos,\n+\t\t\t\t\t      round_up (last_pos, align));\n+\t    }\n+\t  else if (potential_alignment_gap (prev_old_field, old_field,\n+\t\t\t\t\t    pos))\n+\t    {\n+\t      align = TYPE_ALIGN (field_type);\n+\t      pos = compute_related_constant (curpos,\n+\t\t\t\t\t      round_up (last_pos, align));\n+\t    }\n+\n+\t  /* If we can't compute a position, set it to zero.\n+\n+\t  ??? We really should abort here, but it's too much work\n+\t  to get this correct for all cases.  */\n+\n+\t  if (!pos)\n+\t    pos = bitsize_zero_node;\n+\n+\t  /* See if this type is variable-size and make a new type\n+\t     and indicate the indirection if so.  */\n+\t  if (TREE_CODE (DECL_SIZE (old_field)) != INTEGER_CST)\n+\t    {\n+\t      field_type = build_pointer_type (field_type);\n+\t      var = true;\n+\t    }\n+\n+\t  /* Make a new field name, if necessary.  */\n+\t  if (var || align != 0)\n+\t    {\n+\t      char suffix[6];\n \n-\t  TYPE_FIELDS (new_record_type)\n-\t    = nreverse (TYPE_FIELDS (new_record_type));\n+\t      if (align != 0)\n+\t\tsprintf (suffix, \"XV%c%u\", var ? 'L' : 'A',\n+\t\t\t align / BITS_PER_UNIT);\n+\t      else\n+\t\tstrcpy (suffix, \"XVL\");\n+\n+\t      field_name = concat_id_with_name (field_name, suffix);\n+\t    }\n \n-\t  rest_of_type_compilation (new_record_type, global_bindings_p ());\n+\t  new_field = create_field_decl (field_name, field_type,\n+\t\t\t\t\t new_record_type, 0,\n+\t\t\t\t\t DECL_SIZE (old_field), pos, 0);\n+\t  TREE_CHAIN (new_field) = TYPE_FIELDS (new_record_type);\n+\t  TYPE_FIELDS (new_record_type) = new_field;\n+\n+\t  /* If old_field is a QUAL_UNION_TYPE, take its size as being\n+\t     zero.  The only time it's not the last field of the record\n+\t     is when there are other components at fixed positions after\n+\t     it (meaning there was a rep clause for every field) and we\n+\t     want to be able to encode them.  */\n+\t  last_pos = size_binop (PLUS_EXPR, bit_position (old_field),\n+\t\t\t\t (TREE_CODE (TREE_TYPE (old_field))\n+\t\t\t\t  == QUAL_UNION_TYPE)\n+\t\t\t\t ? bitsize_zero_node\n+\t\t\t\t : DECL_SIZE (old_field));\n+\t  prev_old_field = old_field;\n \t}\n \n-      rest_of_type_compilation (record_type, global_bindings_p ());\n+      TYPE_FIELDS (new_record_type)\n+\t= nreverse (TYPE_FIELDS (new_record_type));\n+\n+      rest_of_type_compilation (new_record_type, global_bindings_p ());\n     }\n+\n+  rest_of_type_compilation (record_type, global_bindings_p ());\n }\n \n /* Utility function of above to merge LAST_SIZE, the previous size of a record\n@@ -2451,28 +2476,12 @@ update_pointer_to (tree old_type, tree new_type)\n       for (; ptr; ptr = TYPE_NEXT_PTR_TO (ptr))\n \tfor (ptr1 = TYPE_MAIN_VARIANT (ptr); ptr1;\n \t     ptr1 = TYPE_NEXT_VARIANT (ptr1))\n-\t  {\n-\t    TREE_TYPE (ptr1) = new_type;\n+\t  TREE_TYPE (ptr1) = new_type;\n \n-\t    if (TYPE_NAME (ptr1)\n-\t\t&& TREE_CODE (TYPE_NAME (ptr1)) == TYPE_DECL\n-\t\t&& TREE_CODE (new_type) != ENUMERAL_TYPE)\n-\t      rest_of_decl_compilation (TYPE_NAME (ptr1),\n-\t\t\t\t\tglobal_bindings_p (), 0);\n-\t  }\n-\n-      for (; ref; ref = TYPE_NEXT_PTR_TO (ref))\n+      for (; ref; ref = TYPE_NEXT_REF_TO (ref))\n \tfor (ref1 = TYPE_MAIN_VARIANT (ref); ref1;\n \t     ref1 = TYPE_NEXT_VARIANT (ref1))\n-\t  {\n-\t    TREE_TYPE (ref1) = new_type;\n-\n-\t    if (TYPE_NAME (ref1)\n-\t\t&& TREE_CODE (TYPE_NAME (ref1)) == TYPE_DECL\n-\t\t&& TREE_CODE (new_type) != ENUMERAL_TYPE)\n-\t      rest_of_decl_compilation (TYPE_NAME (ref1),\n-\t\t\t\t\tglobal_bindings_p (), 0);\n-\t  }\n+\t  TREE_TYPE (ref1) = new_type;\n     }\n \n   /* Now deal with the unconstrained array case. In this case the \"pointer\"\n@@ -2919,10 +2928,13 @@ convert (tree type, tree expr)\n \t    {\n \t      if (TREE_TYPE (tem) == etype)\n \t\treturn build1 (CONVERT_EXPR, type, expr);\n-\t      else if (TREE_CODE (TREE_TYPE (tem)) == RECORD_TYPE\n-\t\t       && (TYPE_JUSTIFIED_MODULAR_P (TREE_TYPE (tem))\n-\t\t\t   || TYPE_IS_PADDING_P (TREE_TYPE (tem)))\n-\t\t       && TREE_TYPE (TYPE_FIELDS (TREE_TYPE (tem))) == etype)\n+\n+\t      /* Accept slight type variations.  */\n+\t      if (TREE_TYPE (tem) == TYPE_MAIN_VARIANT (etype)\n+\t\t  || (TREE_CODE (TREE_TYPE (tem)) == RECORD_TYPE\n+\t\t      && (TYPE_JUSTIFIED_MODULAR_P (TREE_TYPE (tem))\n+\t\t\t  || TYPE_IS_PADDING_P (TREE_TYPE (tem)))\n+\t\t      && TREE_TYPE (TYPE_FIELDS (TREE_TYPE (tem))) == etype))\n \t\treturn build1 (CONVERT_EXPR, type,\n \t\t\t       convert (TREE_TYPE (tem), expr));\n \t    }"}]}