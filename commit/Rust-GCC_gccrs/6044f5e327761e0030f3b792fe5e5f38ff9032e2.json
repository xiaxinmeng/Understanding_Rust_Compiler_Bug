{"sha": "6044f5e327761e0030f3b792fe5e5f38ff9032e2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjA0NGY1ZTMyNzc2MWUwMDMwZjNiNzkyZmU1ZTVmMzhmZjkwMzJlMg==", "commit": {"author": {"name": "Sylvestre Ledru", "email": "sylvestre@debian.org", "date": "2017-06-29T17:35:03Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2017-06-29T17:35:03Z"}, "message": "bid2dpd_dpd2bid.c (_bid_to_dpd32): Fix whitespace.\n\n\t* bid/bid2dpd_dpd2bid.c (_bid_to_dpd32): Fix whitespace.\n\t(_dpd_to_bid32): Simplify identical code on multiple branches.\n\tFix whitespace.\n\t(_bid_to_dpd64, _dpd_to_bid64): Likewise.\n\t(_bid_to_dpd128, _dpd_to_bid128): Likewise.\n\nFrom-SVN: r249803", "tree": {"sha": "2c351746c235b8dfd453d8af60f53ed5a1071454", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2c351746c235b8dfd453d8af60f53ed5a1071454"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6044f5e327761e0030f3b792fe5e5f38ff9032e2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6044f5e327761e0030f3b792fe5e5f38ff9032e2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6044f5e327761e0030f3b792fe5e5f38ff9032e2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6044f5e327761e0030f3b792fe5e5f38ff9032e2/comments", "author": {"login": "sylvestre", "id": 733326, "node_id": "MDQ6VXNlcjczMzMyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/733326?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sylvestre", "html_url": "https://github.com/sylvestre", "followers_url": "https://api.github.com/users/sylvestre/followers", "following_url": "https://api.github.com/users/sylvestre/following{/other_user}", "gists_url": "https://api.github.com/users/sylvestre/gists{/gist_id}", "starred_url": "https://api.github.com/users/sylvestre/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sylvestre/subscriptions", "organizations_url": "https://api.github.com/users/sylvestre/orgs", "repos_url": "https://api.github.com/users/sylvestre/repos", "events_url": "https://api.github.com/users/sylvestre/events{/privacy}", "received_events_url": "https://api.github.com/users/sylvestre/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e9d22c8ab3c3b73a9ed5892e120c869b12eeb85c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9d22c8ab3c3b73a9ed5892e120c869b12eeb85c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e9d22c8ab3c3b73a9ed5892e120c869b12eeb85c"}], "stats": {"total": 281, "additions": 132, "deletions": 149}, "files": [{"sha": "9886dd4442000df9d24e4aaa04f25ae044147fad", "filename": "libdecnumber/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6044f5e327761e0030f3b792fe5e5f38ff9032e2/libdecnumber%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6044f5e327761e0030f3b792fe5e5f38ff9032e2/libdecnumber%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libdecnumber%2FChangeLog?ref=6044f5e327761e0030f3b792fe5e5f38ff9032e2", "patch": "@@ -1,3 +1,11 @@\n+2017-05-29  Sylvestre Ledru  <sylvestre@debian.org>\n+\n+\t* bid/bid2dpd_dpd2bid.c (_bid_to_dpd32): Fix whitespace.\n+\t(_dpd_to_bid32): Simplify identical code on multiple branches.\n+\tFix whitespace.\n+\t(_bid_to_dpd64, _dpd_to_bid64): Likewise.\n+\t(_bid_to_dpd128, _dpd_to_bid128): Likewise.\n+\n 2017-04-03  Jonathan Wakely  <jwakely@redhat.com>\n \n \t* decCommon.c (decFloatFromPackedChecked): Fix typo in comment."}, {"sha": "331500480ad961b0710750ca6740888840220a74", "filename": "libdecnumber/bid/bid2dpd_dpd2bid.c", "status": "modified", "additions": 124, "deletions": 149, "changes": 273, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6044f5e327761e0030f3b792fe5e5f38ff9032e2/libdecnumber%2Fbid%2Fbid2dpd_dpd2bid.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6044f5e327761e0030f3b792fe5e5f38ff9032e2/libdecnumber%2Fbid%2Fbid2dpd_dpd2bid.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libdecnumber%2Fbid%2Fbid2dpd_dpd2bid.c?ref=6044f5e327761e0030f3b792fe5e5f38ff9032e2", "patch": "@@ -114,10 +114,10 @@ _bid_to_dpd32 (_Decimal32 *pres, _Decimal32 *px) {\n   b1 = b01 - 1000 * b0;\n   dcoeff = b2d[b2] | b2d2[b1];\n   if (b0 >= 8) { /* is b0 8 or 9? */\n-    res = sign | ((0x600 | ((exp >> 6) << 7) | \n+    res = sign | ((0x600 | ((exp >> 6) << 7) |\n         ((b0 & 1) << 6) | (exp & 0x3f)) << 20) | dcoeff;\n   } else { /* else b0 is 0..7 */\n-    res = sign | ((((exp >> 6) << 9) | (b0 << 6) | \n+    res = sign | ((((exp >> 6) << 9) | (b0 << 6) |\n         (exp & 0x3f)) << 20) | dcoeff;\n   }\n   *pres = res;\n@@ -138,29 +138,29 @@ _dpd_to_bid32 (_Decimal32 *pres, _Decimal32 *px) {\n   if ((x & 0x78000000) == 0x78000000) {\n     *pres = x;\n     return;\n-  } else { /* normal number */\n-    if ((x & 0x60000000) == 0x60000000) { /* G0..G1 = 11 -> d0 = 8 + G4 */\n-      d0 = d2b3[((x >> 26) & 1) | 8]; /* d0 = (comb & 0x0100 ? 9 : 8); */\n-      exp = (x >> 27) & 3; /* exp leading bits are G2..G3 */\n-    } else {\n-      d0 = d2b3[(x >> 26) & 0x7];\n-      exp = (x >> 29) & 3; /* exp loading bits are G0..G1 */\n-    }\n-    d1 = d2b2[(trailing >> 10) & 0x3ff];\n-    d2 = d2b[(trailing) & 0x3ff];\n-    bcoeff = d2 + d1 + d0;\n-    exp = (exp << 6) + ((x >> 20) & 0x3f);\n-    if (bcoeff < (1 << 23)) {\n-      r = exp;\n-      r <<= 23;\n-      r |= (bcoeff | sign);\n-    } else {\n-      r = exp;\n-      r <<= 21;\n-      r |= (sign | 0x60000000ul);\n-      /* add coeff, without leading bits */\n-      r |= (((unsigned int) bcoeff) & 0x1fffff);\n-    }\n+  }\n+  /* normal number */\n+  if ((x & 0x60000000) == 0x60000000) { /* G0..G1 = 11 -> d0 = 8 + G4 */\n+    d0 = d2b3[((x >> 26) & 1) | 8]; /* d0 = (comb & 0x0100 ? 9 : 8); */\n+    exp = (x >> 27) & 3; /* exp leading bits are G2..G3 */\n+  } else {\n+    d0 = d2b3[(x >> 26) & 0x7];\n+    exp = (x >> 29) & 3; /* exp loading bits are G0..G1 */\n+  }\n+  d1 = d2b2[(trailing >> 10) & 0x3ff];\n+  d2 = d2b[(trailing) & 0x3ff];\n+  bcoeff = d2 + d1 + d0;\n+  exp = (exp << 6) + ((x >> 20) & 0x3f);\n+  if (bcoeff < (1 << 23)) {\n+    r = exp;\n+    r <<= 23;\n+    r |= (bcoeff | sign);\n+  } else {\n+    r = exp;\n+    r <<= 21;\n+    r |= (sign | 0x60000000ul);\n+    /* add coeff, without leading bits */\n+    r |= (((unsigned int) bcoeff) & 0x1fffff);\n   }\n   *pres = r;\n }\n@@ -184,40 +184,40 @@ _bid_to_dpd64 (_Decimal64 *pres, _Decimal64 *px) {\n   if ((comb & 0xf00) == 0xf00) {\n     *pres = x;\n     return;\n-  } else { /* Normal number */\n-    if ((comb & 0xc00) == 0xc00) { /* G0..G1 = 11 -> exp is G2..G11 */\n-      exp = (comb) & 0x3ff;\n-      bcoeff = (x & 0x0007ffffffffffffull) | 0x0020000000000000ull;\n-    } else {\n-      exp = (comb >> 2) & 0x3ff;\n-      bcoeff = (x & 0x001fffffffffffffull);\n-    }\n-    D61 = 2305843009ull; /* Floor(2^61 / 10^9) */\n-    /* Multiply the binary coefficient by ceil(2^64 / 1000), and take the upper\n-       64-bits in order to compute a division by 1000. */\n-    yhi = (D61 * (UINT64)(bcoeff >> (UINT64)27)) >> (UINT64)34;\n-    ylo = bcoeff - 1000000000ull * yhi;\n-    if (ylo >= 1000000000) {\n-      ylo = ylo - 1000000000;\n-      yhi = yhi + 1;\n-    }\n-    d103 = 0x4189374c;\n-    B34 = ((UINT64) ylo * d103) >> (32 + 8);\n-    B01 = ((UINT64) yhi * d103) >> (32 + 8);\n-    b5 = ylo - B34 * 1000;\n-    b2 = yhi - B01 * 1000;\n-    b3 = ((UINT64) B34 * d103) >> (32 + 8);\n-    b0 = ((UINT64) B01 * d103) >> (32 + 8);\n-    b4 = (unsigned int) B34 - (unsigned int) b3 *1000;\n-    b1 = (unsigned int) B01 - (unsigned int) dm103[b0];\n-    dcoeff = b2d[b5] | b2d2[b4] | b2d3[b3] | b2d4[b2] | b2d5[b1];\n-    if (b0 >= 8) /* is b0 8 or 9? */\n-      res = sign | ((0x1800 | ((exp >> 8) << 9) | ((b0 & 1) << 8) | \n-          (exp & 0xff)) << 50) | dcoeff;\n-    else /* else b0 is 0..7 */\n-      res = sign | ((((exp >> 8) << 11) | (b0 << 8) | \n-          (exp & 0xff)) << 50) | dcoeff;\n   }\n+  /* Normal number */\n+  if ((comb & 0xc00) == 0xc00) { /* G0..G1 = 11 -> exp is G2..G11 */\n+    exp = (comb) & 0x3ff;\n+    bcoeff = (x & 0x0007ffffffffffffull) | 0x0020000000000000ull;\n+  } else {\n+    exp = (comb >> 2) & 0x3ff;\n+    bcoeff = (x & 0x001fffffffffffffull);\n+  }\n+  D61 = 2305843009ull; /* Floor(2^61 / 10^9) */\n+  /* Multiply the binary coefficient by ceil(2^64 / 1000), and take the upper\n+     64-bits in order to compute a division by 1000. */\n+  yhi = (D61 * (UINT64)(bcoeff >> (UINT64)27)) >> (UINT64)34;\n+  ylo = bcoeff - 1000000000ull * yhi;\n+  if (ylo >= 1000000000) {\n+    ylo = ylo - 1000000000;\n+    yhi = yhi + 1;\n+  }\n+  d103 = 0x4189374c;\n+  B34 = ((UINT64) ylo * d103) >> (32 + 8);\n+  B01 = ((UINT64) yhi * d103) >> (32 + 8);\n+  b5 = ylo - B34 * 1000;\n+  b2 = yhi - B01 * 1000;\n+  b3 = ((UINT64) B34 * d103) >> (32 + 8);\n+  b0 = ((UINT64) B01 * d103) >> (32 + 8);\n+  b4 = (unsigned int) B34 - (unsigned int) b3 *1000;\n+  b1 = (unsigned int) B01 - (unsigned int) dm103[b0];\n+  dcoeff = b2d[b5] | b2d2[b4] | b2d3[b3] | b2d4[b2] | b2d5[b1];\n+  if (b0 >= 8) /* is b0 8 or 9? */\n+    res = sign | ((0x1800 | ((exp >> 8) << 9) | ((b0 & 1) << 8) |\n+                   (exp & 0xff)) << 50) | dcoeff;\n+  else /* else b0 is 0..7 */\n+    res = sign | ((((exp >> 8) << 11) | (b0 << 8) |\n+                     (exp & 0xff)) << 50) | dcoeff;\n   *pres = res;\n }\n \n@@ -237,49 +237,41 @@ _dpd_to_bid64 (_Decimal64 *pres, _Decimal64 *px) {\n   comb = (x & 0x7ffc000000000000ull) >> 50;\n   trailing = (x & 0x0003ffffffffffffull);\n   if ((comb & 0x1e00) == 0x1e00) {\n-    if ((comb & 0x1f00) == 0x1f00) { /* G0..G4 = 11111 -> NaN */\n-      if (comb & 0x0100) { /* G5 = 1 -> sNaN */\n-        *pres = x;\n-      } else { /* G5 = 0 -> qNaN */\n-        *pres = x;\n-      }\n-    } else { /*if ((comb & 0x1e00) == 0x1e00); G0..G4 = 11110 -> INF */\n-      *pres = x;\n-    }\n+    *pres = x;\n     return;\n-  } else { /* normal number */\n-    if ((comb & 0x1800) == 0x1800) { /* G0..G1 = 11 -> d0 = 8 + G4 */\n-      d0 = d2b6[((comb >> 8) & 1) | 8]; /* d0 = (comb & 0x0100 ? 9 : 8); */\n-      exp = (comb & 0x600) >> 1; /* exp = (comb & 0x0400 ? 1 : 0) * 0x200 + \n-          (comb & 0x0200 ? 1 : 0) * 0x100; exp leading bits are G2..G3 */\n-    } else {\n-      d0 = d2b6[(comb >> 8) & 0x7];\n-      exp = (comb & 0x1800) >> 3; /* exp = (comb & 0x1000 ? 1 : 0) * 0x200 + \n-          (comb & 0x0800 ? 1 : 0) * 0x100; exp loading bits are G0..G1 */\n-    }\n-    d1 = d2b5[(trailing >> 40) & 0x3ff];\n-    d2 = d2b4[(trailing >> 30) & 0x3ff];\n-    d3 = d2b3[(trailing >> 20) & 0x3ff];\n-    d4 = d2b2[(trailing >> 10) & 0x3ff];\n-    d5 = d2b[(trailing) & 0x3ff];\n-    bcoeff = (d5 + d4 + d3) + d2 + d1 + d0;\n-    exp += (comb & 0xff);\n-    mask = 1;\n-    mask <<= 53;\n-    if (bcoeff < mask) { /* check whether coefficient fits in 10*5+3 bits */\n-      res = exp;\n-      res <<= 53;\n-      res |= (bcoeff | sign);\n-      *pres = res;\n-      return;\n-    }\n-    /* special format */\n-    res = (exp << 51) | (sign | 0x6000000000000000ull);\n-    /* add coeff, without leading bits */\n-    mask = (mask >> 2) - 1;\n-    bcoeff &= mask;\n-    res |= bcoeff;\n   }\n+  /* normal number */\n+  if ((comb & 0x1800) == 0x1800) { /* G0..G1 = 11 -> d0 = 8 + G4 */\n+    d0 = d2b6[((comb >> 8) & 1) | 8]; /* d0 = (comb & 0x0100 ? 9 : 8); */\n+    exp = (comb & 0x600) >> 1; /* exp = (comb & 0x0400 ? 1 : 0) * 0x200 +\n+        (comb & 0x0200 ? 1 : 0) * 0x100; exp leading bits are G2..G3 */\n+  } else {\n+    d0 = d2b6[(comb >> 8) & 0x7];\n+    exp = (comb & 0x1800) >> 3; /* exp = (comb & 0x1000 ? 1 : 0) * 0x200 +\n+        (comb & 0x0800 ? 1 : 0) * 0x100; exp loading bits are G0..G1 */\n+  }\n+  d1 = d2b5[(trailing >> 40) & 0x3ff];\n+  d2 = d2b4[(trailing >> 30) & 0x3ff];\n+  d3 = d2b3[(trailing >> 20) & 0x3ff];\n+  d4 = d2b2[(trailing >> 10) & 0x3ff];\n+  d5 = d2b[(trailing) & 0x3ff];\n+  bcoeff = (d5 + d4 + d3) + d2 + d1 + d0;\n+  exp += (comb & 0xff);\n+  mask = 1;\n+  mask <<= 53;\n+  if (bcoeff < mask) { /* check whether coefficient fits in 10*5+3 bits */\n+    res = exp;\n+    res <<= 53;\n+    res |= (bcoeff | sign);\n+    *pres = res;\n+    return;\n+  }\n+  /* special format */\n+  res = (exp << 51) | (sign | 0x6000000000000000ull);\n+  /* add coeff, without leading bits */\n+  mask = (mask >> 2) - 1;\n+  bcoeff &= mask;\n+  res |= bcoeff;\n   *pres = res;\n }\n \n@@ -304,15 +296,7 @@ _bid_to_dpd128 (_Decimal128 *pres, _Decimal128 *px) {\n   comb = (x.w[1] /*& 0x7fffc00000000000ull */ ) >> 46;\n   exp = 0;\n   if ((comb & 0x1e000) == 0x1e000) {\n-    if ((comb & 0x1f000) == 0x1f000) { /* G0..G4 = 11111 -> NaN */\n-      if (comb & 0x01000) { /* G5 = 1 -> sNaN */\n-        res = x;\n-      } else { /* G5 = 0 -> qNaN */\n-        res = x;\n-      }\n-    } else { /* G0..G4 = 11110 -> INF */\n-      res = x;\n-    }\n+    res = x;\n   } else { /* normal number */\n     exp = ((x.w[1] & 0x7fff000000000000ull) >> 49) & 0x3fff;\n     bcoeff.w[1] = (x.w[1] & 0x0001ffffffffffffull);\n@@ -347,16 +331,16 @@ _bid_to_dpd128 (_Decimal128 *pres, _Decimal128 *px) {\n     BLL32 -= (unsigned int) k9 *1000000;\n     k10 = ((UINT64) BLL32 * d103) >> (32 + 8);\n     k11 = BLL32 - (unsigned int) k10 *1000;\n-    dcoeff.w[1] = (b2d[k5] >> 4) | (b2d[k4] << 6) | (b2d[k3] << 16) | \n-        (b2d[k2] << 26) | (b2d[k1] << 36);\n-    dcoeff.w[0] = b2d[k11] | (b2d[k10] << 10) | (b2d[k9] << 20) | \n-        (b2d[k8] << 30) | (b2d[k7] << 40) | (b2d[k6] << 50) | (b2d[k5] << 60);\n+    dcoeff.w[1] = (b2d[k5] >> 4) | (b2d[k4] << 6) | (b2d[k3] << 16) |\n+      (b2d[k2] << 26) | (b2d[k1] << 36);\n+    dcoeff.w[0] = b2d[k11] | (b2d[k10] << 10) | (b2d[k9] << 20) |\n+      (b2d[k8] << 30) | (b2d[k7] << 40) | (b2d[k6] << 50) | (b2d[k5] << 60);\n     res.w[0] = dcoeff.w[0];\n     if (k0 >= 8) {\n-      res.w[1] = sign.w[1] | ((0x18000 | ((exp >> 12) << 13) | \n+      res.w[1] = sign.w[1] | ((0x18000 | ((exp >> 12) << 13) |\n           ((k0 & 1) << 12) | (exp & 0xfff)) << 46) | dcoeff.w[1];\n     } else {\n-      res.w[1] = sign.w[1] | ((((exp >> 12) << 15) | (k0 << 12) | \n+      res.w[1] = sign.w[1] | ((((exp >> 12) << 15) | (k0 << 12) |\n           (exp & 0xfff)) << 46) | dcoeff.w[1];\n     }\n   }\n@@ -382,42 +366,33 @@ _dpd_to_bid128 (_Decimal128 *pres, _Decimal128 *px) {\n   trailing.w[1] = x.w[1];\n   trailing.w[0] = x.w[0];\n   if ((comb & 0x1e000) == 0x1e000) {\n-    if ((comb & 0x1f000) == 0x1f000) { /* G0..G4 = 11111 -> NaN */\n-      if (comb & 0x01000) { /* G5 = 1 -> sNaN */\n-        *pres = x;\n-      } else { /* G5 = 0 -> qNaN */\n-        *pres = x;\n-      }\n-    } else { /* G0..G4 = 11110 -> INF */\n       *pres = x;\n-    }\n-    return;\n-  } else { /* Normal number */\n-    if ((comb & 0x18000) == 0x18000) { /* G0..G1 = 11 -> d0 = 8 + G4 */\n-      d0 = d2b6[8 + ((comb & 0x01000) >> 12)];\n-      exp = (comb & 0x06000) >> 1;  /* exp leading bits are G2..G3 */\n-    } else {\n-      d0 = d2b6[((comb & 0x07000) >> 12)];\n-      exp = (comb & 0x18000) >> 3;  /* exp loading bits are G0..G1 */\n-    }\n-    d11 = d2b[(trailing.w[0]) & 0x3ff];\n-    d10 = d2b2[(trailing.w[0] >> 10) & 0x3ff];\n-    d9 = d2b3[(trailing.w[0] >> 20) & 0x3ff];\n-    d8 = d2b4[(trailing.w[0] >> 30) & 0x3ff];\n-    d7 = d2b5[(trailing.w[0] >> 40) & 0x3ff];\n-    d6 = d2b6[(trailing.w[0] >> 50) & 0x3ff];\n-    d5 = d2b[(trailing.w[0] >> 60) | ((trailing.w[1] & 0x3f) << 4)];\n-    d4 = d2b2[(trailing.w[1] >> 6) & 0x3ff];\n-    d3 = d2b3[(trailing.w[1] >> 16) & 0x3ff];\n-    d2 = d2b4[(trailing.w[1] >> 26) & 0x3ff];\n-    d1 = d2b5[(trailing.w[1] >> 36) & 0x3ff];\n-    tl = d11 + d10 + d9 + d8 + d7 + d6;\n-    th = d5 + d4 + d3 + d2 + d1 + d0;\n-    __mul_64x64_to_128 (bcoeff, th, 1000000000000000000ull);\n-    __add_128_64 (bcoeff, bcoeff, tl);\n-    exp += (comb & 0xfff);\n-    res.w[0] = bcoeff.w[0];\n-    res.w[1] = (exp << 49) | sign.w[1] | bcoeff.w[1];\n+      return;\n+  }\n+  if ((comb & 0x18000) == 0x18000) { /* G0..G1 = 11 -> d0 = 8 + G4 */\n+    d0 = d2b6[8 + ((comb & 0x01000) >> 12)];\n+    exp = (comb & 0x06000) >> 1;  /* exp leading bits are G2..G3 */\n+  } else {\n+    d0 = d2b6[((comb & 0x07000) >> 12)];\n+    exp = (comb & 0x18000) >> 3;  /* exp loading bits are G0..G1 */\n   }\n+  d11 = d2b[(trailing.w[0]) & 0x3ff];\n+  d10 = d2b2[(trailing.w[0] >> 10) & 0x3ff];\n+  d9 = d2b3[(trailing.w[0] >> 20) & 0x3ff];\n+  d8 = d2b4[(trailing.w[0] >> 30) & 0x3ff];\n+  d7 = d2b5[(trailing.w[0] >> 40) & 0x3ff];\n+  d6 = d2b6[(trailing.w[0] >> 50) & 0x3ff];\n+  d5 = d2b[(trailing.w[0] >> 60) | ((trailing.w[1] & 0x3f) << 4)];\n+  d4 = d2b2[(trailing.w[1] >> 6) & 0x3ff];\n+  d3 = d2b3[(trailing.w[1] >> 16) & 0x3ff];\n+  d2 = d2b4[(trailing.w[1] >> 26) & 0x3ff];\n+  d1 = d2b5[(trailing.w[1] >> 36) & 0x3ff];\n+  tl = d11 + d10 + d9 + d8 + d7 + d6;\n+  th = d5 + d4 + d3 + d2 + d1 + d0;\n+  __mul_64x64_to_128 (bcoeff, th, 1000000000000000000ull);\n+  __add_128_64 (bcoeff, bcoeff, tl);\n+  exp += (comb & 0xfff);\n+  res.w[0] = bcoeff.w[0];\n+  res.w[1] = (exp << 49) | sign.w[1] | bcoeff.w[1];\n   *pres = res;\n }"}]}