{"sha": "bf6f2cc7be78a36b1648cdc9619b8fe98475825d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmY2ZjJjYzdiZTc4YTM2YjE2NDhjZGM5NjE5YjhmZTk4NDc1ODI1ZA==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2018-01-11T12:12:39Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2018-01-11T12:12:39Z"}, "message": "re PR lto/81968 (early lto debug objects make Solaris ld SEGV)\n\n2018-01-11  Richard Biener  <rguenther@suse.de>\n\tRainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n\n\tPR lto/81968\n\tlibiberty/\n\t* simple-object-common.h (struct simple_object_functions):\n\tChange copy_lto_debug_sections callback signature.\n\t* simple-object-elf.c (SHN_HIRESERVE, SHT_SYMTAB_SHNDX,\n\tSHF_INFO_LINK): Add defines.\n\t(simple_object_elf_copy_lto_debug_sections): Instead of\n\tleaving not to be copied sections empty unnamed SHT_NULL\n\tremove them from the target section headers and adjust section\n\treference everywhere.  Handle SHN_XINDEX in the symbol table\n\tprocessing properly.\n\t* simple-object.c (handle_lto_debug_sections): Change\n\tinterface to return a modified string and handle renaming\n\tof relocation sections.\n\nCo-Authored-By: Rainer Orth <ro@CeBiTec.Uni-Bielefeld.DE>\n\nFrom-SVN: r256528", "tree": {"sha": "d2f8fb5d40dada424665515fdd18680f7e9087d6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d2f8fb5d40dada424665515fdd18680f7e9087d6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bf6f2cc7be78a36b1648cdc9619b8fe98475825d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf6f2cc7be78a36b1648cdc9619b8fe98475825d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bf6f2cc7be78a36b1648cdc9619b8fe98475825d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf6f2cc7be78a36b1648cdc9619b8fe98475825d/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ec538483a14f61226e3f89b46f098cfb98be8f12", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec538483a14f61226e3f89b46f098cfb98be8f12", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec538483a14f61226e3f89b46f098cfb98be8f12"}], "stats": {"total": 439, "additions": 279, "deletions": 160}, "files": [{"sha": "2b834372c9a74a3f2fd61bce9f6159a8bce6accf", "filename": "libiberty/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf6f2cc7be78a36b1648cdc9619b8fe98475825d/libiberty%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf6f2cc7be78a36b1648cdc9619b8fe98475825d/libiberty%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FChangeLog?ref=bf6f2cc7be78a36b1648cdc9619b8fe98475825d", "patch": "@@ -1,3 +1,20 @@\n+2018-01-11  Richard Biener  <rguenther@suse.de>\n+\tRainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n+\n+\tPR lto/81968\n+\t* simple-object-common.h (struct simple_object_functions):\n+\tChange copy_lto_debug_sections callback signature.\n+\t* simple-object-elf.c (SHN_HIRESERVE, SHT_SYMTAB_SHNDX,\n+\tSHF_INFO_LINK): Add defines.\n+\t(simple_object_elf_copy_lto_debug_sections): Instead of\n+\tleaving not to be copied sections empty unnamed SHT_NULL\n+\tremove them from the target section headers and adjust section\n+\treference everywhere.  Handle SHN_XINDEX in the symbol table\n+\tprocessing properly.\n+\t* simple-object.c (handle_lto_debug_sections): Change\n+\tinterface to return a modified string and handle renaming\n+\tof relocation sections.\n+\n 2018-01-10  Daniel van Gerpen  <daniel@vangerpen.de>\n \n \t* argv.c (expandargv): Correct check for dynamically"}, {"sha": "858209f9b059156c2d806538e5715c7b9b7b2635", "filename": "libiberty/simple-object-common.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf6f2cc7be78a36b1648cdc9619b8fe98475825d/libiberty%2Fsimple-object-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf6f2cc7be78a36b1648cdc9619b8fe98475825d/libiberty%2Fsimple-object-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fsimple-object-common.h?ref=bf6f2cc7be78a36b1648cdc9619b8fe98475825d", "patch": "@@ -145,7 +145,7 @@ struct simple_object_functions\n   /* Copy LTO debug sections.  */\n   const char *(*copy_lto_debug_sections) (simple_object_read *sobj,\n \t\t\t\t\t  simple_object_write *dobj,\n-\t\t\t\t\t  int (*pfn) (const char **),\n+\t\t\t\t\t  char *(*pfn) (const char *),\n \t\t\t\t\t  int *err);\n };\n "}, {"sha": "7468a1adc3dd1da2584d7324d98b9314a18f91ce", "filename": "libiberty/simple-object-elf.c", "status": "modified", "additions": 239, "deletions": 145, "changes": 384, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf6f2cc7be78a36b1648cdc9619b8fe98475825d/libiberty%2Fsimple-object-elf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf6f2cc7be78a36b1648cdc9619b8fe98475825d/libiberty%2Fsimple-object-elf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fsimple-object-elf.c?ref=bf6f2cc7be78a36b1648cdc9619b8fe98475825d", "patch": "@@ -126,6 +126,7 @@ typedef struct {\n #define SHN_LORESERVE\t0xFF00\t\t/* Begin range of reserved indices */\n #define SHN_COMMON\t0xFFF2\t/* Associated symbol is in common */\n #define SHN_XINDEX\t0xFFFF\t\t/* Section index is held elsewhere */\n+#define SHN_HIRESERVE\t0xffff\t\t/* End of reserved indices */\n \n \n /* 32-bit ELF program header.  */\n@@ -193,9 +194,11 @@ typedef struct {\n #define SHT_RELA\t4\t\t/* Relocation entries with addends */\n #define SHT_REL\t\t9\t\t/* Relocation entries, no addends */\n #define SHT_GROUP\t17\t\t/* Section contains a section group */\n+#define SHT_SYMTAB_SHNDX 18\t\t/* Extended section indeces */\n \n /* Values for sh_flags field.  */\n \n+#define SHF_INFO_LINK\t0x00000040\t/* `sh_info' contains SHT index */\n #define SHF_EXECINSTR\t0x00000004\t/* Executable section.  */\n #define SHF_EXCLUDE\t0x80000000\t/* Link editor is to exclude this\n \t\t\t\t\t   section from executable and\n@@ -1070,7 +1073,7 @@ simple_object_elf_release_write (void *data)\n static const char *\n simple_object_elf_copy_lto_debug_sections (simple_object_read *sobj,\n \t\t\t\t\t   simple_object_write *dobj,\n-\t\t\t\t\t   int (*pfn) (const char **),\n+\t\t\t\t\t   char *(*pfn) (const char *),\n \t\t\t\t\t   int *err)\n {\n   struct simple_object_elf_read *eor =\n@@ -1091,7 +1094,10 @@ simple_object_elf_copy_lto_debug_sections (simple_object_read *sobj,\n   int changed;\n   int *pfnret;\n   const char **pfnname;\n+  unsigned new_i;\n+  unsigned *sh_map;\n   unsigned first_shndx = 0;\n+  unsigned int *symtab_indices_shndx;\n \n   shdr_size = (ei_class == ELFCLASS32\n \t       ? sizeof (Elf32_External_Shdr)\n@@ -1130,18 +1136,20 @@ simple_object_elf_copy_lto_debug_sections (simple_object_read *sobj,\n       return errmsg;\n     }\n \n-  eow->shdrs = XNEWVEC (unsigned char, shdr_size * (shnum - 1));\n   pfnret = XNEWVEC (int, shnum);\n   pfnname = XNEWVEC (const char *, shnum);\n \n+  /* Map of symtab to index section.  */\n+  symtab_indices_shndx = XCNEWVEC (unsigned int, shnum - 1);\n+\n   /* First perform the callbacks to know which sections to preserve and\n      what name to use for those.  */\n   for (i = 1; i < shnum; ++i)\n     {\n       unsigned char *shdr;\n-      unsigned int sh_name;\n+      unsigned int sh_name, sh_type;\n       const char *name;\n-      int ret;\n+      char *ret;\n \n       shdr = shdrs + (i - 1) * shdr_size;\n       sh_name = ELF_FETCH_FIELD (type_functions, ei_class, Shdr,\n@@ -1156,12 +1164,28 @@ simple_object_elf_copy_lto_debug_sections (simple_object_read *sobj,\n \n       name = (const char *) names + sh_name;\n \n-      ret = (*pfn) (&name);\n-      pfnret[i - 1] = ret == 1 ? 0 : -1;\n-      pfnname[i - 1] = name;\n+      ret = (*pfn) (name);\n+      pfnret[i - 1] = ret == NULL ? -1 : 0;\n+      pfnname[i - 1] = ret == NULL ? name : ret;\n       if (first_shndx == 0\n \t  && pfnret[i - 1] == 0)\n \tfirst_shndx = i;\n+\n+      /* Remember the indexes of existing SHT_SYMTAB_SHNDX sections.  */\n+      sh_type = ELF_FETCH_FIELD (type_functions, ei_class, Shdr,\n+\t\t\t\t shdr, sh_type, Elf_Word);\n+      if (sh_type == SHT_SYMTAB_SHNDX)\n+\t{\n+\t  unsigned int sh_link;\n+\t  sh_link = ELF_FETCH_FIELD (type_functions, ei_class, Shdr,\n+\t\t\t\t     shdr, sh_link, Elf_Word);\n+\t  symtab_indices_shndx[sh_link - 1] = i;\n+\t  /* Always discard the extended index sections, after\n+\t     copying it will not be needed.  This way we don't need to\n+\t     update it and deal with the ordering constraints of\n+\t     processing the existing symtab and changing the index.  */\n+\t  pfnret[i - 1] = -1;\n+\t}\n     }\n \n   /* Mark sections as preserved that are required by to be preserved\n@@ -1244,19 +1268,41 @@ simple_object_elf_copy_lto_debug_sections (simple_object_read *sobj,\n     }\n   while (changed);\n \n+  /* Compute a mapping of old -> new section numbers.  */\n+  sh_map = XNEWVEC (unsigned, shnum);\n+  sh_map[0] = 0;\n+  new_i = 1;\n+  for (i = 1; i < shnum; ++i)\n+    {\n+      if (pfnret[i - 1] == -1)\n+\tsh_map[i] = 0;\n+      else\n+\tsh_map[i] = new_i++;\n+    }\n+  if (new_i - 1 >= SHN_LORESERVE)\n+    {\n+      *err = ENOTSUP;\n+      return \"Too many copied sections\";\n+    }\n+  eow->shdrs = XNEWVEC (unsigned char, shdr_size * (new_i - 1));\n+\n   /* Then perform the actual copying.  */\n+  new_i = 0;\n   for (i = 1; i < shnum; ++i)\n     {\n       unsigned char *shdr;\n       unsigned int sh_name, sh_type;\n       const char *name;\n       off_t offset;\n       off_t length;\n-      int ret;\n       simple_object_write_section *dest;\n       off_t flags;\n       unsigned char *buf;\n \n+      if (pfnret[i - 1])\n+\tcontinue;\n+\n+      new_i++;\n       shdr = shdrs + (i - 1) * shdr_size;\n       sh_name = ELF_FETCH_FIELD (type_functions, ei_class, Shdr,\n \t\t\t\t shdr, sh_name, Elf_Word);\n@@ -1265,189 +1311,235 @@ simple_object_elf_copy_lto_debug_sections (simple_object_read *sobj,\n \t  *err = 0;\n \t  XDELETEVEC (names);\n \t  XDELETEVEC (shdrs);\n+\t  XDELETEVEC (symtab_indices_shndx);\n \t  return \"ELF section name out of range\";\n \t}\n \n-      name = (const char *) names + sh_name;\n+      name = pfnname[i - 1];\n       offset = ELF_FETCH_FIELD (type_functions, ei_class, Shdr,\n \t\t\t\tshdr, sh_offset, Elf_Addr);\n       length = ELF_FETCH_FIELD (type_functions, ei_class, Shdr,\n \t\t\t\tshdr, sh_size, Elf_Addr);\n       sh_type = ELF_FETCH_FIELD (type_functions, ei_class, Shdr,\n \t\t\t\t shdr, sh_type, Elf_Word);\n \n-      ret = pfnret[i - 1];\n-      name = ret == 0 ? pfnname[i - 1] : \"\";\n-\n-      dest = simple_object_write_create_section (dobj, name, 0, &errmsg, err);\n+      dest = simple_object_write_create_section (dobj, pfnname[i - 1],\n+\t\t\t\t\t\t 0, &errmsg, err);\n       if (dest == NULL)\n \t{\n \t  XDELETEVEC (names);\n \t  XDELETEVEC (shdrs);\n+\t  XDELETEVEC (symtab_indices_shndx);\n \t  return errmsg;\n \t}\n \n       /* Record the SHDR of the source.  */\n-      memcpy (eow->shdrs + (i - 1) * shdr_size, shdr, shdr_size);\n-      shdr = eow->shdrs + (i - 1) * shdr_size;\n+      memcpy (eow->shdrs + (new_i - 1) * shdr_size, shdr, shdr_size);\n+      shdr = eow->shdrs + (new_i - 1) * shdr_size;\n \n       /* Copy the data.\n \t ???  This is quite wasteful and ideally would be delayed until\n \t write_to_file ().  Thus it questions the interfacing\n \t which eventually should contain destination creation plus\n \t writing.  */\n-      /* Keep empty sections for sections we should discard.  This avoids\n-         the need to rewrite section indices in symtab and relocation\n+      buf = XNEWVEC (unsigned char, length);\n+      if (!simple_object_internal_read (sobj->descriptor,\n+\t\t\t\t\tsobj->offset + offset, buf,\n+\t\t\t\t\t(size_t) length, &errmsg, err))\n+\t{\n+\t  XDELETEVEC (buf);\n+\t  XDELETEVEC (names);\n+\t  XDELETEVEC (shdrs);\n+\t  XDELETEVEC (symtab_indices_shndx);\n+\t  return errmsg;\n+\t}\n+\n+      /* If we are processing .symtab purge __gnu_lto_v1 and\n+\t __gnu_lto_slim symbols from it and any symbols in discarded\n \t sections.  */\n-      if (ret == 0)\n+      if (sh_type == SHT_SYMTAB)\n \t{\n-\t  buf = XNEWVEC (unsigned char, length);\n-\t  if (!simple_object_internal_read (sobj->descriptor,\n-\t\t\t\t\t    sobj->offset + offset, buf,\n-\t\t\t\t\t    (size_t) length, &errmsg, err))\n+\t  unsigned entsize = ELF_FETCH_FIELD (type_functions, ei_class, Shdr,\n+\t\t\t\t\t      shdr, sh_entsize, Elf_Addr);\n+\t  unsigned strtab = ELF_FETCH_FIELD (type_functions, ei_class, Shdr,\n+\t\t\t\t\t     shdr, sh_link, Elf_Word);\n+\t  unsigned char *strshdr = shdrs + (strtab - 1) * shdr_size;\n+\t  off_t stroff = ELF_FETCH_FIELD (type_functions, ei_class, Shdr,\n+\t\t\t\t\t  strshdr, sh_offset, Elf_Addr);\n+\t  size_t strsz = ELF_FETCH_FIELD (type_functions, ei_class, Shdr,\n+\t\t\t\t\t  strshdr, sh_size, Elf_Addr);\n+\t  char *strings = XNEWVEC (char, strsz);\n+\t  char *gnu_lto = strings;\n+\t  unsigned char *ent;\n+\t  unsigned *shndx_table = NULL;\n+\t  simple_object_internal_read (sobj->descriptor,\n+\t\t\t\t       sobj->offset + stroff,\n+\t\t\t\t       (unsigned char *)strings,\n+\t\t\t\t       strsz, &errmsg, err);\n+\t  /* Find gnu_lto_ in strings.  */\n+\t  while ((gnu_lto = (char *) memchr (gnu_lto, 'g',\n+\t\t\t\t\t     strings + strsz - gnu_lto)))\n+\t    if (strncmp (gnu_lto, \"gnu_lto_v1\",\n+\t\t\t strings + strsz - gnu_lto) == 0)\n+\t      break;\n+\t    else\n+\t      gnu_lto++;\n+\t  /* Read the section index table if present.  */\n+\t  if (symtab_indices_shndx[i - 1] != 0)\n \t    {\n-\t      XDELETEVEC (buf);\n-\t      XDELETEVEC (names);\n-\t      XDELETEVEC (shdrs);\n-\t      return errmsg;\n+\t      unsigned char *sidxhdr = shdrs + (strtab - 1) * shdr_size;\n+\t      off_t sidxoff = ELF_FETCH_FIELD (type_functions, ei_class, Shdr,\n+\t\t\t\t\t       sidxhdr, sh_offset, Elf_Addr);\n+\t      size_t sidxsz = ELF_FETCH_FIELD (type_functions, ei_class, Shdr,\n+\t\t\t\t\t       sidxhdr, sh_size, Elf_Addr);\n+\t      shndx_table = (unsigned *)XNEWVEC (char, sidxsz);\n+\t      simple_object_internal_read (sobj->descriptor,\n+\t\t\t\t\t   sobj->offset + sidxoff,\n+\t\t\t\t\t   (unsigned char *)shndx_table,\n+\t\t\t\t\t   sidxsz, &errmsg, err);\n \t    }\n-\n-\t  /* If we are processing .symtab purge __gnu_lto_v1 and\n-\t     __gnu_lto_slim symbols from it.  */\n-\t  if (sh_type == SHT_SYMTAB)\n+\t  for (ent = buf; ent < buf + length; ent += entsize)\n \t    {\n-\t      unsigned entsize = ELF_FETCH_FIELD (type_functions, ei_class, Shdr,\n-\t\t\t\t\t\t  shdr, sh_entsize, Elf_Addr);\n-\t      unsigned strtab = ELF_FETCH_FIELD (type_functions, ei_class, Shdr,\n-\t\t\t\t\t\t shdr, sh_link, Elf_Word);\n-\t      unsigned char *strshdr = shdrs + (strtab - 1) * shdr_size;\n-\t      off_t stroff = ELF_FETCH_FIELD (type_functions, ei_class, Shdr,\n-\t\t\t\t\t      strshdr, sh_offset, Elf_Addr);\n-\t      size_t strsz = ELF_FETCH_FIELD (type_functions, ei_class, Shdr,\n-\t\t\t\t\t      strshdr, sh_size, Elf_Addr);\n-\t      char *strings = XNEWVEC (char, strsz);\n-\t      unsigned char *ent;\n-\t      simple_object_internal_read (sobj->descriptor,\n-\t\t\t\t\t   sobj->offset + stroff,\n-\t\t\t\t\t   (unsigned char *)strings,\n-\t\t\t\t\t   strsz, &errmsg, err);\n-\t      /* Find gnu_lto_ in strings.  */\n-\t      char *gnu_lto = strings;\n-\t      while ((gnu_lto = memchr (gnu_lto, 'g',\n-\t\t\t\t\tstrings + strsz - gnu_lto)))\n-\t\tif (strncmp (gnu_lto, \"gnu_lto_v1\",\n-\t\t\t     strings + strsz - gnu_lto) == 0)\n-\t\t  break;\n-\t\telse\n-\t\t  gnu_lto++;\n-\t      for (ent = buf; ent < buf + length; ent += entsize)\n+\t      unsigned st_shndx = ELF_FETCH_FIELD (type_functions, ei_class,\n+\t\t\t\t\t\t   Sym, ent,\n+\t\t\t\t\t\t   st_shndx, Elf_Half);\n+\t      unsigned raw_st_shndx = st_shndx;\n+\t      unsigned char *st_info;\n+\t      unsigned char *st_other;\n+\t      int discard = 0;\n+\t      if (ei_class == ELFCLASS32)\n \t\t{\n-\t\t  unsigned st_shndx = ELF_FETCH_FIELD (type_functions, ei_class,\n-\t\t\t\t\t\t       Sym, ent,\n-\t\t\t\t\t\t       st_shndx, Elf_Half);\n-\t\t  unsigned char *st_info;\n-\t\t  unsigned char *st_other;\n-\t\t  int discard = 0;\n-\t\t  if (ei_class == ELFCLASS32)\n+\t\t  st_info = &((Elf32_External_Sym *)ent)->st_info;\n+\t\t  st_other = &((Elf32_External_Sym *)ent)->st_other;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  st_info = &((Elf64_External_Sym *)ent)->st_info;\n+\t\t  st_other = &((Elf64_External_Sym *)ent)->st_other;\n+\t\t}\n+\t      if (st_shndx == SHN_XINDEX)\n+\t\tst_shndx = type_functions->fetch_Elf_Word\n+\t\t    ((unsigned char *)(shndx_table + (ent - buf) / entsize));\n+\t      /* Eliminate all COMMONs - this includes __gnu_lto_v1\n+\t\t and __gnu_lto_slim which otherwise cause endless\n+\t\t LTO plugin invocation.  */\n+\t      if (st_shndx == SHN_COMMON)\n+\t\tdiscard = 1;\n+\t      /* We also need to remove symbols refering to sections\n+\t\t we'll eventually remove as with fat LTO objects\n+\t\t we otherwise get duplicate symbols at final link\n+\t\t (with GNU ld, gold is fine and ignores symbols in\n+\t\t sections marked as EXCLUDE).  ld/20513  */\n+\t      else if (st_shndx != SHN_UNDEF\n+\t\t       && st_shndx < shnum\n+\t\t       && pfnret[st_shndx - 1] == -1)\n+\t\tdiscard = 1;\n+\n+\t      if (discard)\n+\t\t{\n+\t\t  /* Make discarded symbols undefined and unnamed\n+\t\t     in case it is local.  */\n+\t\t  int bind = ELF_ST_BIND (*st_info);\n+\t\t  int other = STV_DEFAULT;\n+\t\t  if (bind == STB_LOCAL)\n \t\t    {\n-\t\t      st_info = &((Elf32_External_Sym *)ent)->st_info;\n-\t\t      st_other = &((Elf32_External_Sym *)ent)->st_other;\n+\t\t      /* Make discarded local symbols unnamed and\n+\t\t\t defined in the first prevailing section.  */\n+\t\t      ELF_SET_FIELD (type_functions, ei_class, Sym,\n+\t\t\t\t     ent, st_name, Elf_Word, 0);\n+\t\t      ELF_SET_FIELD (type_functions, ei_class, Sym,\n+\t\t\t\t     ent, st_shndx, Elf_Half,\n+\t\t\t\t     sh_map[first_shndx]);\n \t\t    }\n \t\t  else\n \t\t    {\n-\t\t      st_info = &((Elf64_External_Sym *)ent)->st_info;\n-\t\t      st_other = &((Elf64_External_Sym *)ent)->st_other;\n-\t\t    }\n-\t\t  /* Eliminate all COMMONs - this includes __gnu_lto_v1\n-\t\t     and __gnu_lto_slim which otherwise cause endless\n-\t\t     LTO plugin invocation.  */\n-\t\t  if (st_shndx == SHN_COMMON)\n-\t\t    discard = 1;\n-\t\t  /* We also need to remove symbols refering to sections\n-\t\t     we'll eventually remove as with fat LTO objects\n-\t\t     we otherwise get duplicate symbols at final link\n-\t\t     (with GNU ld, gold is fine and ignores symbols in\n-\t\t     sections marked as EXCLUDE).  ld/20513  */\n-\t\t  else if (st_shndx != SHN_UNDEF\n-\t\t\t   && st_shndx < shnum\n-\t\t\t   && pfnret[st_shndx - 1] == -1)\n-\t\t    discard = 1;\n-\n-\t\t  if (discard)\n-\t\t    {\n-\t\t      /* Make discarded symbols undefined and unnamed\n-\t\t         in case it is local.  */\n-\t\t      int bind = ELF_ST_BIND (*st_info);\n-\t\t      int other = STV_DEFAULT;\n-\t\t      if (bind == STB_LOCAL)\n-\t\t\t{\n-\t\t\t  /* Make discarded local symbols unnamed and\n-\t\t\t     defined in the first prevailing section.  */\n-\t\t\t  ELF_SET_FIELD (type_functions, ei_class, Sym,\n-\t\t\t\t\t ent, st_name, Elf_Word, 0);\n-\t\t\t  ELF_SET_FIELD (type_functions, ei_class, Sym,\n-\t\t\t\t\t ent, st_shndx, Elf_Half, first_shndx);\n-\t\t\t}\n-\t\t      else\n-\t\t\t{\n-\t\t\t  /* Make discarded global symbols hidden weak\n-\t\t\t     undefined and sharing the gnu_lto_ name.  */\n-\t\t\t  bind = STB_WEAK;\n-\t\t\t  other = STV_HIDDEN;\n-\t\t\t  if (gnu_lto)\n-\t\t\t    ELF_SET_FIELD (type_functions, ei_class, Sym,\n-\t\t\t\t\t   ent, st_name, Elf_Word,\n-\t\t\t\t\t   gnu_lto - strings);\n-\t\t\t  ELF_SET_FIELD (type_functions, ei_class, Sym,\n-\t\t\t\t\t ent, st_shndx, Elf_Half, SHN_UNDEF);\n-\t\t\t}\n-\t\t      *st_other = other;\n-\t\t      *st_info = ELF_ST_INFO (bind, STT_NOTYPE);\n-\t\t      ELF_SET_FIELD (type_functions, ei_class, Sym,\n-\t\t\t\t     ent, st_value, Elf_Addr, 0);\n+\t\t      /* Make discarded global symbols hidden weak\n+\t\t\t undefined and sharing the gnu_lto_ name.  */\n+\t\t      bind = STB_WEAK;\n+\t\t      other = STV_HIDDEN;\n+\t\t      if (gnu_lto)\n+\t\t\tELF_SET_FIELD (type_functions, ei_class, Sym,\n+\t\t\t\t       ent, st_name, Elf_Word,\n+\t\t\t\t       gnu_lto - strings);\n \t\t      ELF_SET_FIELD (type_functions, ei_class, Sym,\n-\t\t\t\t     ent, st_size, Elf_Word, 0);\n+\t\t\t\t     ent, st_shndx, Elf_Half, SHN_UNDEF);\n \t\t    }\n+\t\t  *st_other = other;\n+\t\t  *st_info = ELF_ST_INFO (bind, STT_NOTYPE);\n+\t\t  ELF_SET_FIELD (type_functions, ei_class, Sym,\n+\t\t\t\t ent, st_value, Elf_Addr, 0);\n+\t\t  ELF_SET_FIELD (type_functions, ei_class, Sym,\n+\t\t\t\t ent, st_size, Elf_Word, 0);\n \t\t}\n-\t      XDELETEVEC (strings);\n+\t      else if (raw_st_shndx < SHN_LORESERVE\n+\t\t       || raw_st_shndx == SHN_XINDEX)\n+\t\t/* Remap the section reference.  */\n+\t\tELF_SET_FIELD (type_functions, ei_class, Sym,\n+\t\t\t       ent, st_shndx, Elf_Half, sh_map[st_shndx]);\n \t    }\n-\n-\t  errmsg = simple_object_write_add_data (dobj, dest,\n-\t\t\t\t\t\t buf, length, 1, err);\n-\t  XDELETEVEC (buf);\n-\t  if (errmsg)\n+\t  XDELETEVEC (strings);\n+\t  XDELETEVEC (shndx_table);\n+\t}\n+      else if (sh_type == SHT_GROUP)\n+\t{\n+\t  /* Remap section indices in groups and remove removed members.  */\n+\t  unsigned char *ent, *dst;\n+\t  for (dst = ent = buf + 4; ent < buf + length; ent += 4)\n \t    {\n-\t      XDELETEVEC (names);\n-\t      XDELETEVEC (shdrs);\n-\t      return errmsg;\n+\t      unsigned shndx = type_functions->fetch_Elf_Word (ent);\n+\t      if (pfnret[shndx - 1] == -1)\n+\t\t;\n+\t      else\n+\t\t{\n+\t\t  type_functions->set_Elf_Word (dst, sh_map[shndx]);\n+\t\t  dst += 4;\n+\t\t}\n \t    }\n+\t  /* Adjust the length.  */\n+\t  length = dst - buf;\n \t}\n-      else\n+\n+      errmsg = simple_object_write_add_data (dobj, dest,\n+\t\t\t\t\t     buf, length, 1, err);\n+      XDELETEVEC (buf);\n+      if (errmsg)\n \t{\n-\t  /* For deleted sections mark the section header table entry as\n-\t     unused.  That allows the link editor to remove it in a partial\n-\t     link.  */\n-\t  ELF_SET_FIELD (type_functions, ei_class, Shdr,\n-\t\t\t shdr, sh_type, Elf_Word, SHT_NULL);\n-\t  ELF_SET_FIELD (type_functions, ei_class, Shdr,\n-\t\t\t shdr, sh_info, Elf_Word, 0);\n-\t  ELF_SET_FIELD (type_functions, ei_class, Shdr,\n-\t\t\t shdr, sh_link, Elf_Word, 0);\n+\t  XDELETEVEC (names);\n+\t  XDELETEVEC (shdrs);\n+\t  XDELETEVEC (symtab_indices_shndx);\n+\t  return errmsg;\n \t}\n \n       flags = ELF_FETCH_FIELD (type_functions, ei_class, Shdr,\n \t\t\t       shdr, sh_flags, Elf_Addr);\n-      if (ret == 0)\n-\t{\n-\t  /* The debugobj doesn't contain any code, thus no trampolines.\n-\t     Even when the original object needs trampolines, debugobj\n-\t     doesn't.  */\n-\t  if (strcmp (name, \".note.GNU-stack\") == 0)\n-\t    flags &= ~SHF_EXECINSTR;\n-\t  flags &= ~SHF_EXCLUDE;\n-\t}\n-      else if (ret == -1)\n-\tflags = SHF_EXCLUDE;\n+      /* Remap the section references.  */\n+      {\n+\tunsigned int sh_info, sh_link;\n+\tif (flags & SHF_INFO_LINK || sh_type == SHT_REL || sh_type == SHT_RELA)\n+\t  {\n+\t    sh_info = ELF_FETCH_FIELD (type_functions, ei_class, Shdr,\n+\t\t\t\t       shdr, sh_info, Elf_Word);\n+\t    if (sh_info < SHN_LORESERVE\n+\t\t|| sh_info > SHN_HIRESERVE)\n+\t      sh_info = sh_map[sh_info];\n+\t    ELF_SET_FIELD (type_functions, ei_class, Shdr,\n+\t\t\t   shdr, sh_info, Elf_Word, sh_info);\n+\t  }\n+\tsh_link = ELF_FETCH_FIELD (type_functions, ei_class, Shdr,\n+\t\t\t\t   shdr, sh_link, Elf_Word);\n+\tif (sh_link < SHN_LORESERVE\n+\t    || sh_link > SHN_HIRESERVE)\n+\t  sh_link = sh_map[sh_link];\n+\tELF_SET_FIELD (type_functions, ei_class, Shdr,\n+\t\t       shdr, sh_link, Elf_Word, sh_link);\n+      }\n+      /* The debugobj doesn't contain any code, thus no trampolines.\n+\t Even when the original object needs trampolines, debugobj\n+\t doesn't.  */\n+      if (strcmp (name, \".note.GNU-stack\") == 0)\n+\tflags &= ~SHF_EXECINSTR;\n+      /* Clear SHF_EXCLUDE on to be preserved sections.  */\n+      flags &= ~SHF_EXCLUDE;\n       ELF_SET_FIELD (type_functions, ei_class, Shdr,\n \t\t     shdr, sh_flags, Elf_Addr, flags);\n     }\n@@ -1456,6 +1548,8 @@ simple_object_elf_copy_lto_debug_sections (simple_object_read *sobj,\n   XDELETEVEC (shdrs);\n   XDELETEVEC (pfnret);\n   XDELETEVEC (pfnname);\n+  XDELETEVEC (symtab_indices_shndx);\n+  XDELETEVEC (sh_map);\n \n   return NULL;\n }"}, {"sha": "56dc9566167f46546006b72200f84f9ef02b6aca", "filename": "libiberty/simple-object.c", "status": "modified", "additions": 22, "deletions": 14, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf6f2cc7be78a36b1648cdc9619b8fe98475825d/libiberty%2Fsimple-object.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf6f2cc7be78a36b1648cdc9619b8fe98475825d/libiberty%2Fsimple-object.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fsimple-object.c?ref=bf6f2cc7be78a36b1648cdc9619b8fe98475825d", "patch": "@@ -253,30 +253,38 @@ simple_object_find_section (simple_object_read *sobj, const char *name,\n /* Callback to identify and rename LTO debug sections by name.\n    Returns 1 if NAME is a LTO debug section, 0 if not.  */\n \n-static int\n-handle_lto_debug_sections (const char **name)\n+static char *\n+handle_lto_debug_sections (const char *name)\n {\n+  char *newname = XCNEWVEC (char, strlen (name) + 1);\n+\n   /* ???  So we can't use .gnu.lto_ prefixed sections as the assembler\n      complains about bogus section flags.  Which means we need to arrange\n      for that to be fixed or .gnu.debuglto_ marked as SHF_EXCLUDE (to make\n      fat lto object tooling work for the fat part).  */\n-  /* ???  For now this handles both .gnu.lto_ and .gnu.debuglto_ prefixed\n-     sections.  */\n-  /* Copy LTO debug sections and rename them to their non-LTO name.  */\n-  if (strncmp (*name, \".gnu.debuglto_\", sizeof (\".gnu.debuglto_\") - 1) == 0)\n+  /* Also include corresponding reloc sections.  */\n+  if (strncmp (name, \".rela\", sizeof (\".rela\") - 1) == 0)\n     {\n-      *name = *name + sizeof (\".gnu.debuglto_\") - 1;\n-      return 1;\n+      strncpy (newname, name, sizeof (\".rela\") - 1);\n+      name += sizeof (\".rela\") - 1;\n     }\n-  else if (strncmp (*name, \".gnu.lto_.debug_\", sizeof (\".gnu.lto_.debug_\") -1) == 0)\n+  else if (strncmp (name, \".rel\", sizeof (\".rel\") - 1) == 0)\n     {\n-      *name = *name + sizeof (\".gnu.lto_\") - 1;\n-      return 1;\n+      strncpy (newname, name, sizeof (\".rel\") - 1);\n+      name += sizeof (\".rel\") - 1;\n     }\n+  /* ???  For now this handles both .gnu.lto_ and .gnu.debuglto_ prefixed\n+     sections.  */\n+  /* Copy LTO debug sections and rename them to their non-LTO name.  */\n+  if (strncmp (name, \".gnu.debuglto_\", sizeof (\".gnu.debuglto_\") - 1) == 0)\n+    return strcat (newname, name + sizeof (\".gnu.debuglto_\") - 1);\n+  else if (strncmp (name, \".gnu.lto_.debug_\",\n+\t\t    sizeof (\".gnu.lto_.debug_\") -1) == 0)\n+    return strcat (newname, name + sizeof (\".gnu.lto_\") - 1);\n   /* Copy over .note.GNU-stack section under the same name if present.  */\n-  else if (strcmp (*name, \".note.GNU-stack\") == 0)\n-    return 1;\n-  return 0;\n+  else if (strcmp (name, \".note.GNU-stack\") == 0)\n+    return strcpy (newname, name);\n+  return NULL;\n }\n \n /* Copy LTO debug sections.  */"}]}