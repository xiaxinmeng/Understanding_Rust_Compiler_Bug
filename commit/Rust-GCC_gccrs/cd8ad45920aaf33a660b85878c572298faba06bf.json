{"sha": "cd8ad45920aaf33a660b85878c572298faba06bf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2Q4YWQ0NTkyMGFhZjMzYTY2MGI4NTg3OGM1NzIyOThmYWJhMDZiZg==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2018-06-12T09:51:26Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2018-06-12T09:51:26Z"}, "message": "decl.c (variant_desc): Add AUX field.\n\n\t* gcc-interface/decl.c (variant_desc): Add AUX field.\n\t(gnat_to_gnu_entity) <discrete_type>: Do not call compute_record_mode\n\tdirectly.\n\t(reverse_sort_field_list): New static function.\n\t(components_to_record): Place the variant part at the beginning of the\n\tfield list when there is an obvious order of increasing position.\n\t(build_variant_list): Initialize it.\n\t(create_variant_part_from): Do not call compute_record_mode directly.\n\t(copy_and_substitute_in_layout): Likewise.  Always sort the fields with\n\tfixed position in order of increasing position, in the record and all\n\tthe variants, in any.  Call reverse_sort_field_list.\n\t* gcc-interface/utils.c (make_packable_type): Compute the sizes before\n\tcalling finish_record_type.  Do not call compute_record_mode directly.\n\t(finish_record_type): Overhaul final processing depending on REP_LEVEL\n\tand call finish_bitfield_layout if it is equal to one or two.\n\nFrom-SVN: r261479", "tree": {"sha": "3c8c32322ff2d79c1acfc7387a1606252f353502", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3c8c32322ff2d79c1acfc7387a1606252f353502"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cd8ad45920aaf33a660b85878c572298faba06bf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd8ad45920aaf33a660b85878c572298faba06bf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cd8ad45920aaf33a660b85878c572298faba06bf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd8ad45920aaf33a660b85878c572298faba06bf/comments", "author": null, "committer": null, "parents": [{"sha": "835d417373cf5843051885e2cba29aea30814606", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/835d417373cf5843051885e2cba29aea30814606", "html_url": "https://github.com/Rust-GCC/gccrs/commit/835d417373cf5843051885e2cba29aea30814606"}], "stats": {"total": 246, "additions": 179, "deletions": 67}, "files": [{"sha": "091ba237370cf1d567706496e4784947cb1619ab", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd8ad45920aaf33a660b85878c572298faba06bf/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd8ad45920aaf33a660b85878c572298faba06bf/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=cd8ad45920aaf33a660b85878c572298faba06bf", "patch": "@@ -1,3 +1,21 @@\n+2018-06-12  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/decl.c (variant_desc): Add AUX field.\n+\t(gnat_to_gnu_entity) <discrete_type>: Do not call compute_record_mode\n+\tdirectly.\n+\t(reverse_sort_field_list): New static function.\n+\t(components_to_record): Place the variant part at the beginning of the\n+\tfield list when there is an obvious order of increasing position.\n+\t(build_variant_list): Initialize it.\n+\t(create_variant_part_from): Do not call compute_record_mode directly.\n+\t(copy_and_substitute_in_layout): Likewise.  Always sort the fields with\n+\tfixed position in order of increasing position, in the record and all\n+\tthe variants, in any.  Call reverse_sort_field_list.\n+\t* gcc-interface/utils.c (make_packable_type): Compute the sizes before\n+\tcalling finish_record_type.  Do not call compute_record_mode directly.\n+\t(finish_record_type): Overhaul final processing depending on REP_LEVEL\n+\tand call finish_bitfield_layout if it is equal to one or two.\n+\n 2018-06-11  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Array_Type>: Reuse the"}, {"sha": "a79cb0070246599523806ed84f516ec6e5765502", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 92, "deletions": 44, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd8ad45920aaf33a660b85878c572298faba06bf/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd8ad45920aaf33a660b85878c572298faba06bf/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=cd8ad45920aaf33a660b85878c572298faba06bf", "patch": "@@ -123,6 +123,9 @@ typedef struct variant_desc_d {\n \n   /* The type of the variant after transformation.  */\n   tree new_type;\n+\n+  /* The auxiliary data.  */\n+  tree aux;\n } variant_desc;\n \n \n@@ -1927,7 +1930,6 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \n \t  /* We will output additional debug info manually below.  */\n \t  finish_record_type (gnu_type, gnu_field, 2, false);\n-\t  compute_record_mode (gnu_type);\n \t  TYPE_JUSTIFIED_MODULAR_P (gnu_type) = 1;\n \n \t  if (debug_info_p)\n@@ -7228,6 +7230,28 @@ compare_field_bitpos (const PTR rt1, const PTR rt2)\n   return ret ? ret : (int) (DECL_UID (field1) - DECL_UID (field2));\n }\n \n+/* Sort the LIST of fields in reverse order of increasing position.  */\n+\n+static tree\n+reverse_sort_field_list (tree list)\n+{\n+  const int len = list_length (list);\n+  tree *field_arr = XALLOCAVEC (tree, len);\n+\n+  for (int i = 0; list; list = DECL_CHAIN (list), i++)\n+    field_arr[i] = list;\n+\n+  qsort (field_arr, len, sizeof (tree), compare_field_bitpos);\n+\n+  for (int i = 0; i < len; i++)\n+    {\n+      DECL_CHAIN (field_arr[i]) = list;\n+      list = field_arr[i];\n+    }\n+\n+  return list;\n+}\n+\n /* Reverse function from gnat_to_gnu_field: return the GNAT field present in\n    either GNAT_COMPONENT_LIST or the discriminants of GNAT_RECORD_TYPE, and\n    corresponding to the GNU tree GNU_FIELD.  */\n@@ -8037,7 +8061,23 @@ components_to_record (Node_Id gnat_component_list, Entity_Id gnat_record_type,\n \n   /* Chain the variant part at the end of the field list.  */\n   if (gnu_variant_part)\n-    gnu_field_list = chainon (gnu_field_list, gnu_variant_part);\n+    {\n+      /* We make an exception if the variant part is at offset 0, has a fixed\n+\t size, and there is a single rep'ed field placed after it because, in\n+\t this case, there is an obvious order of increasing position.  */\n+      if (variants_have_rep\n+\t  && TREE_CODE (DECL_SIZE_UNIT (gnu_variant_part)) == INTEGER_CST\n+\t  && gnu_rep_list\n+\t  && gnu_field_list == gnu_rep_list\n+\t  && !tree_int_cst_lt (DECL_FIELD_OFFSET (gnu_rep_list),\n+\t\t\t       DECL_SIZE_UNIT (gnu_variant_part)))\n+\t{\n+\t  DECL_CHAIN (gnu_variant_part) = gnu_field_list;\n+\t  gnu_field_list = gnu_variant_part;\n+\t}\n+      else\n+\tgnu_field_list = chainon (gnu_field_list, gnu_variant_part);\n+    }\n \n   if (cancel_alignment)\n     SET_TYPE_ALIGN (gnu_record_type, 0);\n@@ -8527,7 +8567,8 @@ build_variant_list (tree qual_union_type, vec<subst_pair> subst_list,\n       if (!integer_zerop (qual))\n \t{\n \t  tree variant_type = TREE_TYPE (gnu_field), variant_subpart;\n-\t  variant_desc v = { variant_type, gnu_field, qual, NULL_TREE };\n+\t  variant_desc v\n+\t    = { variant_type, gnu_field, qual, NULL_TREE, NULL_TREE };\n \n \t  gnu_list.safe_push (v);\n \n@@ -9301,7 +9342,6 @@ create_variant_part_from (tree old_variant_part,\n \n       /* Finish up the new variant and create the field.  */\n       finish_record_type (new_variant, nreverse (field_list), 2, debug_info_p);\n-      compute_record_mode (new_variant);\n       create_type_decl (TYPE_NAME (new_variant), new_variant, true,\n \t\t\tdebug_info_p, Empty);\n \n@@ -9319,7 +9359,6 @@ create_variant_part_from (tree old_variant_part,\n      reverse the field list because VARIANT_LIST has been traversed in reverse\n      order.  */\n   finish_record_type (new_union_type, union_field_list, 2, debug_info_p);\n-  compute_record_mode (new_union_type);\n   create_type_decl (TYPE_NAME (new_union_type), new_union_type, true,\n \t\t    debug_info_p, Empty);\n \n@@ -9417,7 +9456,8 @@ copy_and_substitute_in_layout (Entity_Id gnat_new_type,\n {\n   const bool is_subtype = (Ekind (gnat_new_type) == E_Record_Subtype);\n   tree gnu_field_list = NULL_TREE;\n-  bool selected_variant, all_constant_pos = true;\n+  tree gnu_variable_field_list = NULL_TREE;\n+  bool selected_variant;\n   vec<variant_desc> gnu_variant_list;\n \n   /* Look for REP and variant parts in the old type.  */\n@@ -9501,6 +9541,7 @@ copy_and_substitute_in_layout (Entity_Id gnat_new_type,\n         tree gnu_context = DECL_CONTEXT (gnu_old_field);\n \ttree gnu_field, gnu_field_type, gnu_size, gnu_pos;\n \ttree gnu_cont_type, gnu_last = NULL_TREE;\n+\tvariant_desc *v = NULL;\n \n \t/* If the type is the same, retrieve the GCC type from the\n \t   old field to take into account possible adjustments.  */\n@@ -9549,7 +9590,6 @@ copy_and_substitute_in_layout (Entity_Id gnat_new_type,\n \t  gnu_cont_type = gnu_new_type;\n \telse\n \t  {\n-\t    variant_desc *v;\n \t    unsigned int i;\n \t    tree rep_part;\n \n@@ -9562,7 +9602,7 @@ copy_and_substitute_in_layout (Entity_Id gnat_new_type,\n \t    if (v)\n \t      gnu_cont_type = selected_variant ? gnu_new_type : v->new_type;\n \t    else\n-\t      /* The front-end may pass us \"ghost\" components if it fails to\n+\t      /* The front-end may pass us zombie components if it fails to\n \t\t recognize that a constrain statically selects a particular\n \t\t variant.  Discard them.  */\n \t      continue;\n@@ -9578,8 +9618,16 @@ copy_and_substitute_in_layout (Entity_Id gnat_new_type,\n \t/* If the context is a variant, put it in the new variant directly.  */\n \tif (gnu_cont_type != gnu_new_type)\n \t  {\n-\t    DECL_CHAIN (gnu_field) = TYPE_FIELDS (gnu_cont_type);\n-\t    TYPE_FIELDS (gnu_cont_type) = gnu_field;\n+\t    if (TREE_CODE (gnu_pos) == INTEGER_CST)\n+\t      {\n+\t\tDECL_CHAIN (gnu_field) = TYPE_FIELDS (gnu_cont_type);\n+\t\tTYPE_FIELDS (gnu_cont_type) = gnu_field;\n+\t      }\n+\t    else\n+\t      {\n+\t\tDECL_CHAIN (gnu_field) = v->aux;\n+\t\tv->aux = gnu_field;\n+\t      }\n \t  }\n \n \t/* To match the layout crafted in components_to_record, if this is\n@@ -9598,12 +9646,18 @@ copy_and_substitute_in_layout (Entity_Id gnat_new_type,\n \t/* Otherwise, put it after the other fields.  */\n \telse\n \t  {\n-\t    DECL_CHAIN (gnu_field) = gnu_field_list;\n-\t    gnu_field_list = gnu_field;\n-\t    if (!gnu_last)\n-\t      gnu_last = gnu_field;\n-\t    if (TREE_CODE (gnu_pos) != INTEGER_CST)\n-\t      all_constant_pos = false;\n+\t    if (TREE_CODE (gnu_pos) == INTEGER_CST)\n+\t      {\n+\t\tDECL_CHAIN (gnu_field) = gnu_field_list;\n+\t\tgnu_field_list = gnu_field;\n+\t\tif (!gnu_last)\n+\t\t  gnu_last = gnu_field;\n+\t      }\n+\t    else\n+\t      {\n+\t\tDECL_CHAIN (gnu_field) = gnu_variable_field_list;\n+\t\tgnu_variable_field_list = gnu_field;\n+\t      }\n \t  }\n \n \t/* For a stored discriminant in a derived type, replace the field.  */\n@@ -9616,31 +9670,32 @@ copy_and_substitute_in_layout (Entity_Id gnat_new_type,\n \t  save_gnu_tree (gnat_field, gnu_field, false);\n       }\n \n-  /* If there is no variant list or a selected variant and the fields all have\n-     constant position, put them in order of increasing position to match that\n-     of constant CONSTRUCTORs.  */\n-  if ((!gnu_variant_list.exists () || selected_variant) && all_constant_pos)\n-    {\n-      const int len = list_length (gnu_field_list);\n-      tree *field_arr = XALLOCAVEC (tree, len), t = gnu_field_list;\n+  /* Put the fields with fixed position in order of increasing position.  */\n+  if (gnu_field_list)\n+    gnu_field_list = reverse_sort_field_list (gnu_field_list);\n \n-      for (int i = 0; t; t = DECL_CHAIN (t), i++)\n-\tfield_arr[i] = t;\n+  /* Put the fields with variable position at the end.  */\n+  if (gnu_variable_field_list)\n+    gnu_field_list = chainon (gnu_variable_field_list, gnu_field_list);\n \n-      qsort (field_arr, len, sizeof (tree), compare_field_bitpos);\n+  /* If there is a variant list and no selected variant, we need to create the\n+     nest of variant parts from the old nest.  */\n+  if (gnu_variant_list.exists () && !selected_variant)\n+    {\n+      variant_desc *v;\n+      unsigned int i;\n \n-      gnu_field_list = NULL_TREE;\n-      for (int i = 0; i < len; i++)\n+      /* Same processing as above for the fields of each variant.  */\n+      FOR_EACH_VEC_ELT (gnu_variant_list, i, v)\n \t{\n-\t  DECL_CHAIN (field_arr[i]) = gnu_field_list;\n-\t  gnu_field_list = field_arr[i];\n+\t  if (TYPE_FIELDS (v->new_type))\n+\t    TYPE_FIELDS (v->new_type)\n+\t      = reverse_sort_field_list (TYPE_FIELDS (v->new_type));\n+\t  if (v->aux)\n+\t    TYPE_FIELDS (v->new_type)\n+\t      = chainon (v->aux, TYPE_FIELDS (v->new_type));\n \t}\n-    }\n \n-  /* If there is a variant list and no selected variant, we need to create the\n-     nest of variant parts from the old nest.  */\n-  else if (gnu_variant_list.exists () && !selected_variant)\n-    {\n       tree new_variant_part\n \t= create_variant_part_from (gnu_variant_part, gnu_variant_list,\n \t\t\t\t    gnu_new_type, gnu_pos_list,\n@@ -9652,17 +9707,10 @@ copy_and_substitute_in_layout (Entity_Id gnat_new_type,\n   gnu_variant_list.release ();\n   gnu_subst_list.release ();\n \n-  gnu_field_list = nreverse (gnu_field_list);\n-\n   /* If NEW_TYPE is a subtype, it inherits all the attributes from OLD_TYPE.\n      Otherwise sizes and alignment must be computed independently.  */\n-  if (is_subtype)\n-    {\n-      finish_record_type (gnu_new_type, gnu_field_list, 2, debug_info_p);\n-      compute_record_mode (gnu_new_type);\n-    }\n-  else\n-    finish_record_type (gnu_new_type, gnu_field_list, 1, debug_info_p);\n+  finish_record_type (gnu_new_type, nreverse (gnu_field_list),\n+\t\t      is_subtype ? 2 : 1, debug_info_p);\n \n   /* Now go through the entities again looking for Itypes that we have not yet\n      elaborated (e.g. Etypes of fields that have Original_Components).  */"}, {"sha": "992d56825bf7c35d9c051b067ee3c5d51d28b421", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 28, "deletions": 23, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd8ad45920aaf33a660b85878c572298faba06bf/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd8ad45920aaf33a660b85878c572298faba06bf/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=cd8ad45920aaf33a660b85878c572298faba06bf", "patch": "@@ -1054,12 +1054,6 @@ make_packable_type (tree type, bool in_record, unsigned int max_align)\n       new_field_list = new_field;\n     }\n \n-  finish_record_type (new_type, nreverse (new_field_list), 2, false);\n-  relate_alias_sets (new_type, type, ALIAS_SET_COPY);\n-  if (TYPE_STUB_DECL (type))\n-    SET_DECL_PARALLEL_TYPE (TYPE_STUB_DECL (new_type),\n-\t\t\t    DECL_PARALLEL_TYPE (TYPE_STUB_DECL (type)));\n-\n   /* If this is a padding record, we never want to make the size smaller\n      than what was specified.  For QUAL_UNION_TYPE, also copy the size.  */\n   if (TYPE_IS_PADDING_P (type) || TREE_CODE (type) == QUAL_UNION_TYPE)\n@@ -1077,7 +1071,11 @@ make_packable_type (tree type, bool in_record, unsigned int max_align)\n   if (!TYPE_CONTAINS_TEMPLATE_P (type))\n     SET_TYPE_ADA_SIZE (new_type, TYPE_ADA_SIZE (type));\n \n-  compute_record_mode (new_type);\n+  finish_record_type (new_type, nreverse (new_field_list), 2, false);\n+  relate_alias_sets (new_type, type, ALIAS_SET_COPY);\n+  if (TYPE_STUB_DECL (type))\n+    SET_DECL_PARALLEL_TYPE (TYPE_STUB_DECL (new_type),\n+\t\t\t    DECL_PARALLEL_TYPE (TYPE_STUB_DECL (type)));\n \n   /* Try harder to get a packable type if necessary, for example\n      in case the record itself contains a BLKmode field.  */\n@@ -1951,33 +1949,40 @@ finish_record_type (tree record_type, tree field_list, int rep_level,\n   if (code == QUAL_UNION_TYPE)\n     nreverse (field_list);\n \n-  if (rep_level < 2)\n+  /* We need to set the regular sizes if REP_LEVEL is one.  */\n+  if (rep_level == 1)\n     {\n       /* If this is a padding record, we never want to make the size smaller\n \t than what was specified in it, if any.  */\n       if (TYPE_IS_PADDING_P (record_type) && TYPE_SIZE (record_type))\n \tsize = TYPE_SIZE (record_type);\n \n+      tree size_unit = had_size_unit\n+\t\t       ? TYPE_SIZE_UNIT (record_type)\n+\t\t       : convert (sizetype,\n+\t\t\t\t  size_binop (CEIL_DIV_EXPR, size,\n+\t\t\t\t\t      bitsize_unit_node));\n+      const unsigned int align = TYPE_ALIGN (record_type);\n+\n+      TYPE_SIZE (record_type) = variable_size (round_up (size, align));\n+      TYPE_SIZE_UNIT (record_type)\n+\t= variable_size (round_up (size_unit, align / BITS_PER_UNIT));\n+    }\n+\n+  /* We need to set the Ada size if REP_LEVEL is zero or one.  */\n+  if (rep_level < 2)\n+    {\n       /* Now set any of the values we've just computed that apply.  */\n       if (!TYPE_FAT_POINTER_P (record_type)\n \t  && !TYPE_CONTAINS_TEMPLATE_P (record_type))\n \tSET_TYPE_ADA_SIZE (record_type, ada_size);\n+    }\n \n-      if (rep_level > 0)\n-\t{\n-\t  tree size_unit = had_size_unit\n-\t\t\t   ? TYPE_SIZE_UNIT (record_type)\n-\t\t\t   : convert (sizetype,\n-\t\t\t\t      size_binop (CEIL_DIV_EXPR, size,\n-\t\t\t\t\t\t  bitsize_unit_node));\n-\t  unsigned int align = TYPE_ALIGN (record_type);\n-\n-\t  TYPE_SIZE (record_type) = variable_size (round_up (size, align));\n-\t  TYPE_SIZE_UNIT (record_type)\n-\t    = variable_size (round_up (size_unit, align / BITS_PER_UNIT));\n-\n-\t  compute_record_mode (record_type);\n-\t}\n+  /* We need to set the mode if REP_LEVEL is one or two.  */\n+  if (rep_level > 0)\n+    {\n+      compute_record_mode (record_type);\n+      finish_bitfield_layout (record_type);\n     }\n \n   /* Reset the TYPE_MAX_ALIGN field since it's private to gigi.  */"}, {"sha": "56b600816473654c826ce2096aaea2cacaaa59ac", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd8ad45920aaf33a660b85878c572298faba06bf/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd8ad45920aaf33a660b85878c572298faba06bf/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=cd8ad45920aaf33a660b85878c572298faba06bf", "patch": "@@ -1,3 +1,8 @@\n+2018-06-12  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gnat.dg/opt72a.ad[sb]: New test.\n+\t* gnat.dg/opt72_pkg.ads: New helper.\n+\n 2018-06-12  Tom de Vries  <tdevries@suse.de>\n \n \t* gcc.dg-selftests/dg-final.exp: New file."}, {"sha": "92255fbdb149c269e50d339ffbd5566517d6dab2", "filename": "gcc/testsuite/gnat.dg/opt72_pkg.ads", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd8ad45920aaf33a660b85878c572298faba06bf/gcc%2Ftestsuite%2Fgnat.dg%2Fopt72_pkg.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd8ad45920aaf33a660b85878c572298faba06bf/gcc%2Ftestsuite%2Fgnat.dg%2Fopt72_pkg.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fopt72_pkg.ads?ref=cd8ad45920aaf33a660b85878c572298faba06bf", "patch": "@@ -0,0 +1,12 @@\n+package Opt72_Pkg is\n+\n+   type Rec is record\n+      Flag : Boolean;\n+      Size : Positive;\n+   end record;\n+   for Rec use record\n+      Flag at 0 range 0 .. 0;\n+      Size at 0 range 1 .. 31;\n+   end record;\n+\n+end Opt72_Pkg;"}, {"sha": "db1d28c4acb5d7a4a19f4a3848b2f54ea3a079cf", "filename": "gcc/testsuite/gnat.dg/opt72a.adb", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd8ad45920aaf33a660b85878c572298faba06bf/gcc%2Ftestsuite%2Fgnat.dg%2Fopt72a.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd8ad45920aaf33a660b85878c572298faba06bf/gcc%2Ftestsuite%2Fgnat.dg%2Fopt72a.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fopt72a.adb?ref=cd8ad45920aaf33a660b85878c572298faba06bf", "patch": "@@ -0,0 +1,12 @@\n+-- { dg-do compile }\n+-- { dg-require-effective-target store_merge }\n+-- { dg-options \"-O2 -fdump-tree-store-merging\" }\n+\n+with Opt72_Pkg; use Opt72_Pkg;\n+\n+procedure Opt72a (X : not null access Rec; Size : Positive) is\n+begin\n+   X.all := (Flag => True, Size => Size);\n+end;\n+\n+-- { dg-final { scan-tree-dump \"Merging successful\" \"store-merging\" } }"}, {"sha": "e4a708beaf27e57f6237edcc800fdaf880fab625", "filename": "gcc/testsuite/gnat.dg/opt72b.adb", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd8ad45920aaf33a660b85878c572298faba06bf/gcc%2Ftestsuite%2Fgnat.dg%2Fopt72b.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd8ad45920aaf33a660b85878c572298faba06bf/gcc%2Ftestsuite%2Fgnat.dg%2Fopt72b.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fopt72b.adb?ref=cd8ad45920aaf33a660b85878c572298faba06bf", "patch": "@@ -0,0 +1,12 @@\n+-- { dg-do compile }\n+-- { dg-require-effective-target store_merge }\n+-- { dg-options \"-O2 -fdump-tree-store-merging\" }\n+\n+with Opt72_Pkg; use Opt72_Pkg;\n+\n+procedure Opt72b (X : not null access Rec; Y : not null access Rec) is\n+begin\n+   X.all := (Flag => True, Size => Y.Size);\n+end;\n+\n+-- { dg-final { scan-tree-dump \"Merging successful\" \"store-merging\" } }"}]}