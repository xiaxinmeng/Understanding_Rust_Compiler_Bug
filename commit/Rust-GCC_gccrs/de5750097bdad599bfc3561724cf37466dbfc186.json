{"sha": "de5750097bdad599bfc3561724cf37466dbfc186", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGU1NzUwMDk3YmRhZDU5OWJmYzM1NjE3MjRjZjM3NDY2ZGJmYzE4Ng==", "commit": {"author": {"name": "Kriang Lerdsuwanakij", "email": "lerdsuwa@scf.usc.edu", "date": "1998-02-19T10:17:10Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1998-02-19T10:17:10Z"}, "message": "* pt.c (coerce_template_parms) Add a new parameter, is_tmpl_parm,\n\n\tall callers changed.  Rely on the new parameter instead of arg\n\tbeing a TREE_LIST when determine whether we are working inside\n\ttemplate template parameter.  Clean up is_type test.\n\nFrom-SVN: r18120", "tree": {"sha": "2625f3d77184f1049379f0fab3d9452fd8b42799", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2625f3d77184f1049379f0fab3d9452fd8b42799"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/de5750097bdad599bfc3561724cf37466dbfc186", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de5750097bdad599bfc3561724cf37466dbfc186", "html_url": "https://github.com/Rust-GCC/gccrs/commit/de5750097bdad599bfc3561724cf37466dbfc186", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de5750097bdad599bfc3561724cf37466dbfc186/comments", "author": null, "committer": null, "parents": [{"sha": "31bcaa204ff12aad6a553a333e0a72c9b5b1111a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31bcaa204ff12aad6a553a333e0a72c9b5b1111a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/31bcaa204ff12aad6a553a333e0a72c9b5b1111a"}], "stats": {"total": 61, "additions": 36, "deletions": 25}, "files": [{"sha": "d1c12fac59d8f64994763cb167bb3bb6f403aa1f", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de5750097bdad599bfc3561724cf37466dbfc186/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de5750097bdad599bfc3561724cf37466dbfc186/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=de5750097bdad599bfc3561724cf37466dbfc186", "patch": "@@ -1,3 +1,10 @@\n+Thu Feb 19 10:15:55 1998  Kriang Lerdsuwanakij  <lerdsuwa@scf.usc.edu>\n+\n+\t* pt.c (coerce_template_parms) Add a new parameter, is_tmpl_parm,\n+\tall callers changed.  Rely on the new parameter instead of arg \n+\tbeing a TREE_LIST when determine whether we are working inside\n+\ttemplate template parameter.  Clean up is_type test.\n+\t\n Thu Feb 19 10:04:12 1998  Jason Merrill  <jason@yorick.cygnus.com>\n \n \t* cvt.c (cp_convert_to_pointer): Preserve TREE_CONSTANT."}, {"sha": "6a6571070280b10f8136e269f5b315cc2b8df1ab", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 29, "deletions": 25, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de5750097bdad599bfc3561724cf37466dbfc186/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de5750097bdad599bfc3561724cf37466dbfc186/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=de5750097bdad599bfc3561724cf37466dbfc186", "patch": "@@ -78,7 +78,7 @@ static tree tsubst_expr_values PROTO((tree, tree));\n static int comp_template_args PROTO((tree, tree));\n static int list_eq PROTO((tree, tree));\n static tree get_class_bindings PROTO((tree, tree, tree));\n-static tree coerce_template_parms PROTO((tree, tree, tree, int, int));\n+static tree coerce_template_parms PROTO((tree, tree, tree, int, int, int));\n static tree tsubst_enum\tPROTO((tree, tree, int, tree *));\n static tree add_to_template_args PROTO((tree, tree));\n static int  type_unification_real PROTO((tree, tree *, tree, tree, int*,\n@@ -1720,19 +1720,24 @@ convert_nontype_argument (type, expr)\n    If REQUIRE_ALL_ARGUMENTS is non-zero, all arguments must be\n    provided in ARGLIST, or else trailing parameters must have default\n    values.  If REQUIRE_ALL_ARGUMENTS is zero, we will attempt argument\n-   deduction for any unspecified trailing arguments.  */\n+   deduction for any unspecified trailing arguments.\n+   \n+   If IS_TMPL_PARM is non-zero,  we will coercing parameters of template \n+   template arguments.  In this case, ARGLIST is a chain of TREE_LIST\n+   nodes containing TYPE_DECL, TEMPLATE_DECL or PARM_DECL.  */\n \n static tree\n coerce_template_parms (parms, arglist, in_decl,\n \t\t       complain,\n-\t\t       require_all_arguments)\n+\t\t       require_all_arguments,\n+\t\t       is_tmpl_parm)\n      tree parms, arglist;\n      tree in_decl;\n      int complain;\n      int require_all_arguments;\n+     int is_tmpl_parm;\n {\n   int nparms, nargs, i, lost = 0;\n-  int is_tmpl_parm = 0;\n   tree vec = NULL_TREE;\n \n   if (arglist == NULL_TREE)\n@@ -1766,10 +1771,6 @@ coerce_template_parms (parms, arglist, in_decl,\n     vec = copy_node (arglist);\n   else\n     {\n-      /* We can arrive here with arglist being a TREE_VEC when a \n-\t template with some default arguments is used as template \n-\t template argument.  */\n-      is_tmpl_parm = TREE_CODE (arglist) == TREE_VEC;\n       vec = make_tree_vec (nparms);\n \n       for (i = 0; i < nparms; i++)\n@@ -1813,6 +1814,16 @@ coerce_template_parms (parms, arglist, in_decl,\n       tree val = 0;\n       int is_type, requires_type, is_tmpl_type, requires_tmpl_type;\n \n+      if (is_tmpl_parm && i < nargs)\n+\t{\n+\t  /* In case we are checking arguments inside a template template\n+\t     parameter, ARG that does not come from default argument is \n+\t     also a TREE_LIST node.  Note that ARG can also be a TREE_LIST\n+\t     in other cases such as overloaded functions.  */\n+\t  if (arg != NULL_TREE && arg != error_mark_node)\n+\t    arg = TREE_VALUE (arg);\n+\t}\n+\n       if (arg == NULL_TREE)\n \t/* We're out of arguments.  */\n \t{\n@@ -1839,14 +1850,6 @@ coerce_template_parms (parms, arglist, in_decl,\n \t  arg = TREE_VALUE (arg);\n \t  TREE_TYPE (arg) = unknown_type_node;\n \t}\n-      else if (TREE_CODE (arg) == TREE_LIST && ! is_overloaded_fn (arg))\n-\t{\n-\t  /* In case we are checking arguments inside a template template\n-\t     parameter, ARG that does not come from default argument is \n-\t     also a TREE_LIST node */\n-          is_tmpl_parm = 1;\n-\t  arg = TREE_VALUE (arg);\n-\t}\n \n       requires_tmpl_type = TREE_CODE (parm) == TEMPLATE_DECL;\n       requires_type = TREE_CODE (parm) == TYPE_DECL\n@@ -1867,10 +1870,11 @@ coerce_template_parms (parms, arglist, in_decl,\n \targ = TYPE_STUB_DECL (arg);\n       else if (is_tmpl_type && TREE_CODE (arg) == RECORD_TYPE)\n \targ = CLASSTYPE_TI_TEMPLATE (arg);\n-      \n-      is_type = TREE_CODE_CLASS (TREE_CODE (arg)) == 't'\n-\t\t|| is_tmpl_type\n-\t\t|| (is_tmpl_parm && TREE_CODE (arg) == TYPE_DECL);\n+\n+      if (is_tmpl_parm && i < nargs)\n+\tis_type = TREE_CODE (arg) == TYPE_DECL || is_tmpl_type;\n+      else\n+\tis_type = TREE_CODE_CLASS (TREE_CODE (arg)) == 't' || is_tmpl_type;\n \n       if (requires_type && ! is_type && TREE_CODE (arg) == SCOPE_REF\n \t  && TREE_CODE (TREE_OPERAND (arg, 0)) == TEMPLATE_TYPE_PARM)\n@@ -1943,7 +1947,7 @@ coerce_template_parms (parms, arglist, in_decl,\n \t\t   template <class T, class Allcator = allocator> \n \t\t   class vector.  */\n \n-\t      val = coerce_template_parms (argparm, parmparm, in_decl, 1, 1);\n+\t      val = coerce_template_parms (argparm, parmparm, in_decl, 1, 1, 1);\n \t      if (val != error_mark_node)\n \t\tval = arg;\n \t\t    \n@@ -2298,7 +2302,7 @@ lookup_template_class (d1, arglist, in_decl, context)\n       CLASSTYPE_GOT_SEMICOLON (parm) = 1;\n       parmlist = DECL_INNERMOST_TEMPLATE_PARMS (template);\n \n-      arglist2 = coerce_template_parms (parmlist, arglist, template, 1, 1);\n+      arglist2 = coerce_template_parms (parmlist, arglist, template, 1, 1, 0);\n       if (arglist2 == error_mark_node)\n \treturn error_mark_node;\n \n@@ -2315,7 +2319,7 @@ lookup_template_class (d1, arglist, in_decl, context)\n       parmlist = DECL_INNERMOST_TEMPLATE_PARMS (template);\n \n       arglist = coerce_template_parms (parmlist, arglist, template,\n-\t\t\t\t       1, 1);\n+\t\t\t\t       1, 1, 0);\n       if (arglist == error_mark_node)\n \treturn error_mark_node;\n       if (uses_template_parms (arglist))\n@@ -4726,7 +4730,7 @@ type_unification (tparms, targs, parms, args, targs_in, nsubsts,\n     {\n       tree arg_vec;\n       arg_vec = coerce_template_parms (tparms, targs_in, NULL_TREE, 0,\n-\t\t\t\t       0);\n+\t\t\t\t       0, 0);\n \n       if (arg_vec == error_mark_node)\n \treturn 1;\n@@ -5010,7 +5014,7 @@ unify (tparms, targs, ntparms, parm, arg, nsubsts, strict)\n \t\t template <class T, class Allcator = allocator> \n \t\t   class vector.  */\n \n-\t    if (coerce_template_parms (argtmplvec, parmvec, parmtmpl, 1, 1)\n+\t    if (coerce_template_parms (argtmplvec, parmvec, parmtmpl, 1, 1, 0)\n \t\t== error_mark_node)\n \t      return 1;\n \t  "}]}