{"sha": "c93aa80414eb376508a8e6dc4ef1d6cf8175535e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzkzYWE4MDQxNGViMzc2NTA4YThlNmRjNGVmMWQ2Y2Y4MTc1NTM1ZQ==", "commit": {"author": {"name": "Michael Koch", "email": "konqueror@gmx.de", "date": "2003-05-20T09:13:19Z"}, "committer": {"name": "Michael Koch", "email": "mkoch@gcc.gnu.org", "date": "2003-05-20T09:13:19Z"}, "message": "DataInputStream.java: Reformatted, Replaced < and & with html entitites in documentation.\n\n2003-05-20  Michael Koch  <konqueror@gmx.de>\n\n\t* java/io/DataInputStream.java:\n\tReformatted, Replaced < and & with html entitites in documentation.\n\t* java/io/File.java:\n\tReformatted.\n\t* java/io/PrintWriter.java:\n\tMoved class documentation.\n\nFrom-SVN: r66992", "tree": {"sha": "106050eb91d72a5bcb3faae38a265f0b655891b5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/106050eb91d72a5bcb3faae38a265f0b655891b5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c93aa80414eb376508a8e6dc4ef1d6cf8175535e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c93aa80414eb376508a8e6dc4ef1d6cf8175535e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c93aa80414eb376508a8e6dc4ef1d6cf8175535e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c93aa80414eb376508a8e6dc4ef1d6cf8175535e/comments", "author": null, "committer": null, "parents": [{"sha": "c2a40660aabcd9c19af4ddb1b0ee8698a9a954e4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c2a40660aabcd9c19af4ddb1b0ee8698a9a954e4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c2a40660aabcd9c19af4ddb1b0ee8698a9a954e4"}], "stats": {"total": 314, "additions": 167, "deletions": 147}, "files": [{"sha": "2afae0516d69b097a1e4fab26f8e44456403dd60", "filename": "libjava/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c93aa80414eb376508a8e6dc4ef1d6cf8175535e/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c93aa80414eb376508a8e6dc4ef1d6cf8175535e/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=c93aa80414eb376508a8e6dc4ef1d6cf8175535e", "patch": "@@ -1,3 +1,12 @@\n+2003-05-20  Michael Koch  <konqueror@gmx.de>\n+\n+\t* java/io/DataInputStream.java:\n+\tReformatted, Replaced < and & with html entitites in documentation.\n+\t* java/io/File.java:\n+\tReformatted.\n+\t* java/io/PrintWriter.java:\n+\tMoved class documentation.\n+\n 2003-05-20  Michael Koch  <konqueror@gmx.de>\n \n \t* gnu/java/nio/ByteBufferImpl.java,"}, {"sha": "07c3b4ce0d26ff606d1bc508548df4c2623770bf", "filename": "libjava/java/io/DataInputStream.java", "status": "modified", "additions": 108, "deletions": 98, "changes": 206, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c93aa80414eb376508a8e6dc4ef1d6cf8175535e/libjava%2Fjava%2Fio%2FDataInputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c93aa80414eb376508a8e6dc4ef1d6cf8175535e/libjava%2Fjava%2Fio%2FDataInputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FDataInputStream.java?ref=c93aa80414eb376508a8e6dc4ef1d6cf8175535e", "patch": "@@ -51,7 +51,7 @@\n  * @see DataInput\n  *\n  * @author Warren Levy <warrenl@cygnus.com>\n- * @author Aaron M. Renn (arenn@urbanophile.com)\n+ * @author Aaron M. Renn <arenn@urbanophile.com>\n  * @date October 20, 1998.  \n  */\n public class DataInputStream extends FilterInputStream implements DataInput\n@@ -62,17 +62,17 @@ public class DataInputStream extends FilterInputStream implements DataInput\n   boolean ignoreInitialNewline = false;\n \n   // Byte buffer, used to make primitive read calls more efficient.\n-  byte[] buf = new byte[8];\n+  byte[] buf = new byte [8];\n   \n   /**\n    * This constructor initializes a new <code>DataInputStream</code>\n    * to read from the specified subordinate stream.\n    *\n    * @param in The subordinate <code>InputStream</code> to read from\n    */\n-  public DataInputStream(InputStream in)\n+  public DataInputStream (InputStream in)\n   {\n-    super(in);\n+    super (in);\n   }\n \n   /**\n@@ -88,9 +88,9 @@ public DataInputStream(InputStream in)\n    *\n    * @exception IOException If an error occurs.\n    */\n-  public final int read(byte[] b) throws IOException\n+  public final int read (byte[] b) throws IOException\n   {\n-    return in.read(b, 0, b.length);\n+    return in.read (b, 0, b.length);\n   }\n \n   /**\n@@ -109,9 +109,9 @@ public final int read(byte[] b) throws IOException\n    *\n    * @exception IOException If an error occurs.\n    */\n-  public final int read(byte[] b, int off, int len) throws IOException\n+  public final int read (byte[] b, int off, int len) throws IOException\n   {\n-    return in.read(b, off, len);\n+    return in.read (b, off, len);\n   }\n \n   /**\n@@ -132,9 +132,9 @@ public final int read(byte[] b, int off, int len) throws IOException\n    *\n    * @see DataOutput#writeBoolean\n    */\n-  public final boolean readBoolean() throws IOException\n+  public final boolean readBoolean () throws IOException\n   {\n-    return convertToBoolean(in.read());\n+    return convertToBoolean (in.read ());\n   }\n \n   /**\n@@ -152,9 +152,9 @@ public final boolean readBoolean() throws IOException\n    *\n    * @see DataOutput#writeByte\n    */\n-  public final byte readByte() throws IOException\n+  public final byte readByte () throws IOException\n   {\n-    return convertToByte(in.read());\n+    return convertToByte (in.read ());\n   }\n \n   /**\n@@ -169,7 +169,7 @@ public final byte readByte() throws IOException\n    * respectively, they will be transformed to a <code>char</code> in\n    * the following manner: \n    * <p>\n-   * <code>(char)(((byte1 & 0xFF) << 8) | (byte2 & 0xFF)</code>\n+   * <code>(char)(((byte1 &amp; 0xFF) &lt;&lt; 8) | (byte2 &amp; 0xFF)</code>\n    * <p>\n    * This method can read a <code>char</code> written by an object\n    * implementing the <code>writeChar()</code> method in the\n@@ -182,10 +182,10 @@ public final byte readByte() throws IOException\n    *\n    * @see DataOutput#writeChar\n    */\n-  public final char readChar() throws IOException\n+  public final char readChar () throws IOException\n   {\n     readFully (buf, 0, 2);\n-    return convertToChar(buf);\n+    return convertToChar (buf);\n   }\n \n   /**\n@@ -209,9 +209,9 @@ public final char readChar() throws IOException\n    * @see DataOutput#writeDouble\n    * @see java.lang.Double#longBitsToDouble\n    */\n-  public final double readDouble() throws IOException\n+  public final double readDouble () throws IOException\n   {\n-    return Double.longBitsToDouble(readLong());\n+    return Double.longBitsToDouble (readLong ());\n   }\n \n   /**\n@@ -234,9 +234,9 @@ public final double readDouble() throws IOException\n    * @see DataOutput#writeFloat \n    * @see java.lang.Float#intBitsToFloat\n    */\n-  public final float readFloat() throws IOException\n+  public final float readFloat () throws IOException\n   {\n-    return Float.intBitsToFloat(readInt());\n+    return Float.intBitsToFloat (readInt ());\n   }\n \n   /**\n@@ -253,9 +253,9 @@ public final float readFloat() throws IOException\n    * buffer\n    * @exception IOException If any other error occurs\n    */\n-  public final void readFully(byte[] b) throws IOException\n+  public final void readFully (byte[] b) throws IOException\n   {\n-    readFully(b, 0, b.length);\n+    readFully (b, 0, b.length);\n   }\n \n   /**\n@@ -277,14 +277,14 @@ public final void readFully(byte[] b) throws IOException\n    * buffer\n    * @exception IOException If any other error occurs\n    */\n-  public final void readFully(byte[] b, int off, int len) throws IOException\n+  public final void readFully (byte[] b, int off, int len) throws IOException\n   {\n     while (len > 0)\n       {\n \t// in.read will block until some data is available.\n-\tint numread = in.read(b, off, len);\n+\tint numread = in.read (b, off, len);\n \tif (numread < 0)\n-\t  throw new EOFException();\n+\t  throw new EOFException ();\n \tlen -= numread;\n \toff += numread;\n       }\n@@ -301,8 +301,8 @@ public final void readFully(byte[] b, int off, int len) throws IOException\n    * the first four bytes read from the stream, they will be\n    * transformed to an <code>int</code> in the following manner:\n    * <p>\n-   * <code>(int)(((byte1 & 0xFF) << 24) + ((byte2 & 0xFF) << 16) +\n-   * ((byte3 & 0xFF)<< 8) + (byte4 & 0xFF)))</code>\n+   * <code>(int)(((byte1 &amp; 0xFF) &lt;&lt; 24) + ((byte2 &amp; 0xFF) &lt;&lt; 16) +\n+   * ((byte3 &amp; 0xFF)&lt;&lt; 8) + (byte4 &amp; 0xFF)))</code>\n    * <p>\n    * The value returned is in the range of -2147483648 to 2147483647.\n    * <p>\n@@ -317,10 +317,10 @@ public final void readFully(byte[] b, int off, int len) throws IOException\n    *\n    * @see DataOutput#writeInt\n    */\n-  public final int readInt() throws IOException\n+  public final int readInt () throws IOException\n   {\n     readFully (buf, 0, 4);\n-    return convertToInt(buf);\n+    return convertToInt (buf);\n   }\n \n   /**\n@@ -349,9 +349,9 @@ public final int readInt() throws IOException\n    *\n    * @deprecated\n    */\n-  public final String readLine() throws IOException\n+  public final String readLine () throws IOException\n   {\n-    StringBuffer strb = new StringBuffer();\n+    StringBuffer strb = new StringBuffer ();\n \n     readloop: while (true)\n       {\n@@ -363,7 +363,7 @@ public final String readLine() throws IOException\n \t    getnext = false;\n \t    c = in.read();\n \t    if (c < 0)\t// got an EOF\n-\t      return strb.length() > 0 ? strb.toString() : null;\n+\t      return strb.length () > 0 ? strb.toString () : null;\n \t    ch = (char) c;\n \t    if ((ch &= 0xFF) == '\\n')\n \t      // hack to correctly handle '\\r\\n' sequences\n@@ -447,10 +447,10 @@ else if (markSupported())\n    * the first eight bytes read from the stream, they will be\n    * transformed to an <code>long</code> in the following manner:\n    * <p>\n-   * <code>(long)(((byte1 & 0xFF) << 56) + ((byte2 & 0xFF) << 48) +\n-   * ((byte3 & 0xFF) << 40) + ((byte4 & 0xFF) << 32) +\n-   * ((byte5 & 0xFF) << 24) + ((byte6 & 0xFF) << 16) +\n-   * ((byte7 & 0xFF) << 8) + (byte8 & 0xFF)))\n+   * <code>(long)(((byte1 &amp; 0xFF) &lt;&lt; 56) + ((byte2 &amp; 0xFF) &lt;&lt; 48) +\n+   * ((byte3 &amp; 0xFF) &lt;&lt; 40) + ((byte4 &amp; 0xFF) &lt;&lt; 32) +\n+   * ((byte5 &amp; 0xFF) &lt;&lt; 24) + ((byte6 &amp; 0xFF) &lt;&lt; 16) +\n+   * ((byte7 &amp; 0xFF) &lt;&lt; 8) + (byte8 &amp; 0xFF)))\n    * </code>\n    * <p>\n    * The value returned is in the range of -9223372036854775808 to\n@@ -467,10 +467,10 @@ else if (markSupported())\n    *\n    * @see DataOutput#writeLong\n    */\n-  public final long readLong() throws IOException\n+  public final long readLong () throws IOException\n   {\n     readFully (buf, 0, 8);\n-    return convertToLong(buf);\n+    return convertToLong (buf);\n   }\n \n   /**\n@@ -485,7 +485,7 @@ public final long readLong() throws IOException\n    * respectively, they will be transformed to a <code>short</code>. in\n    * the following manner:\n    * <p>\n-   * <code>(short)(((byte1 & 0xFF) << 8) | (byte2 & 0xFF))</code>\n+   * <code>(short)(((byte1 &amp; 0xFF) &lt;&lt; 8) | (byte2 &amp; 0xFF))</code>\n    * <p>\n    * The value returned is in the range of -32768 to 32767.\n    * <p>\n@@ -500,10 +500,10 @@ public final long readLong() throws IOException\n    *\n    * @see DataOutput#writeShort\n    */\n-  public final short readShort() throws IOException\n+  public final short readShort () throws IOException\n   {\n     readFully (buf, 0, 2);\n-    return convertToShort(buf);\n+    return convertToShort (buf);\n   }\n   \n   /**\n@@ -522,9 +522,9 @@ public final short readShort() throws IOException\n    *\n    * @see DataOutput#writeByte\n    */\n-  public final int readUnsignedByte() throws IOException\n+  public final int readUnsignedByte () throws IOException\n   {\n-    return convertToUnsignedByte(in.read());\n+    return convertToUnsignedByte (in.read ());\n   }\n \n   /**\n@@ -539,7 +539,7 @@ public final int readUnsignedByte() throws IOException\n    * respectively, they will be transformed to an <code>int</code> in\n    * the following manner:\n    * <p>\n-   * <code>(int)(((byte1 & 0xFF) << 8) + (byte2 & 0xFF))</code>\n+   * <code>(int)(((byte1 &amp; 0xFF) &lt;&lt; 8) + (byte2 &amp; 0xFF))</code>\n    * <p>\n    * The value returned is in the range of 0 to 65535.\n    * <p>\n@@ -554,10 +554,10 @@ public final int readUnsignedByte() throws IOException\n    *\n    * @see DataOutput#writeShort\n    */\n-  public final int readUnsignedShort() throws IOException\n+  public final int readUnsignedShort () throws IOException\n   {\n     readFully (buf, 0, 2);\n-    return convertToUnsignedShort(buf);\n+    return convertToUnsignedShort (buf);\n   }\n \n   /**\n@@ -631,9 +631,9 @@ public final int readUnsignedShort() throws IOException\n    *\n    * @see DataOutput#writeUTF\n    */\n-  public final String readUTF() throws IOException\n+  public final String readUTF () throws IOException\n   {\n-    return readUTF(this);\n+    return readUTF (this);\n   }\n \n   /**\n@@ -648,18 +648,18 @@ public final String readUTF() throws IOException\n    *\n    * @see DataInput#readUTF\n    */\n-  public final static String readUTF(DataInput in) throws IOException\n+  public final static String readUTF (DataInput in) throws IOException\n   {\n-    final int UTFlen = in.readUnsignedShort();\n-    byte[] buf = new byte[UTFlen];\n+    final int UTFlen = in.readUnsignedShort ();\n+    byte[] buf = new byte [UTFlen];\n \n     // This blocks until the entire string is available rather than\n     // doing partial processing on the bytes that are available and then\n     // blocking.  An advantage of the latter is that Exceptions\n     // could be thrown earlier.  The former is a bit cleaner.\n-    in.readFully(buf, 0, UTFlen);\n+    in.readFully (buf, 0, UTFlen);\n \n-    return convertFromUTF(buf);\n+    return convertFromUTF (buf);\n   }\n \n   /**\n@@ -678,13 +678,13 @@ public final static String readUTF(DataInput in) throws IOException\n    *  EOFException. Neither of these appear to be true in the JDK 1.3's\n    *  implementation. This tries to implement the actual JDK behaviour.\n    */\n-  public final int skipBytes(int n) throws IOException\n+  public final int skipBytes (int n) throws IOException\n   {\n     if (n <= 0)\n       return 0;    \n     try\n       {\n-        return (int) in.skip(n);\n+        return (int) in.skip (n);\n       }\n     catch (EOFException x)\n       {\n@@ -693,94 +693,104 @@ public final int skipBytes(int n) throws IOException\n     return n;\n   }\n   \n-  static boolean convertToBoolean(int b) throws EOFException\n+  static boolean convertToBoolean (int b) throws EOFException\n   {\n     if (b < 0)\n-      throw new EOFException();    \n+      throw new EOFException ();\n+    \n     return (b != 0);\n   }\n \n-  static byte convertToByte(int i) throws EOFException\n+  static byte convertToByte (int i) throws EOFException\n   {\n     if (i < 0)\n-      throw new EOFException();\n+      throw new EOFException ();\n+    \n     return (byte) i;\n   }\n \n-  static int convertToUnsignedByte(int i) throws EOFException\n+  static int convertToUnsignedByte (int i) throws EOFException\n   {\n     if (i < 0)\n-      throw new EOFException();\n+      throw new EOFException ();\n+    \n     return (i & 0xFF);\n   }\n \n-  static char convertToChar(byte[] buf)\n+  static char convertToChar (byte[] buf)\n   {\n-    return (char) ((buf[0] << 8) | (buf[1] & 0xff));  \n+    return (char) ((buf [0] << 8)\n+\t\t    | (buf [1] & 0xff));  \n   }  \n \n-  static short convertToShort(byte[] buf)\n+  static short convertToShort (byte[] buf)\n   {\n-    return (short) ((buf[0] << 8) | (buf[1] & 0xff));  \n+    return (short) ((buf [0] << 8)\n+\t\t    | (buf [1] & 0xff));  \n   }  \n \n-  static int convertToUnsignedShort(byte[] buf)\n+  static int convertToUnsignedShort (byte[] buf)\n   {\n-    return (((buf[0] & 0xff) << 8) | (buf[1] & 0xff));  \n+    return (((buf [0] & 0xff) << 8)\n+\t    | (buf [1] & 0xff));  \n   }\n \n-  static int convertToInt(byte[] buf)\n+  static int convertToInt (byte[] buf)\n   {\n-    return (((buf[0] & 0xff) << 24) | ((buf[1] & 0xff) << 16) |\n-\t    ((buf[2] & 0xff) << 8) | (buf[3] & 0xff));  \n+    return (((buf [0] & 0xff) << 24)\n+\t    | ((buf [1] & 0xff) << 16)\n+\t    | ((buf [2] & 0xff) << 8)\n+\t    | (buf [3] & 0xff));  \n   }\n \n-  static long convertToLong(byte[] buf)\n+  static long convertToLong (byte[] buf)\n   {\n-    return (((long)(buf[0] & 0xff) << 56) |\n-\t    ((long)(buf[1] & 0xff) << 48) |\n-\t    ((long)(buf[2] & 0xff) << 40) |\n-\t    ((long)(buf[3] & 0xff) << 32) |\n-\t    ((long)(buf[4] & 0xff) << 24) |\n-\t    ((long)(buf[5] & 0xff) << 16) |\n-\t    ((long)(buf[6] & 0xff) <<  8) |\n-\t    ((long)(buf[7] & 0xff)));  \n+    return (((long)(buf [0] & 0xff) << 56) |\n+\t    ((long)(buf [1] & 0xff) << 48) |\n+\t    ((long)(buf [2] & 0xff) << 40) |\n+\t    ((long)(buf [3] & 0xff) << 32) |\n+\t    ((long)(buf [4] & 0xff) << 24) |\n+\t    ((long)(buf [5] & 0xff) << 16) |\n+\t    ((long)(buf [6] & 0xff) <<  8) |\n+\t    ((long)(buf [7] & 0xff)));  \n   }\n \n-  static String convertFromUTF(byte[] buf) \n+  static String convertFromUTF (byte[] buf) \n     throws EOFException, UTFDataFormatException\n   {\n     // Give StringBuffer an initial estimated size to avoid \n     // enlarge buffer frequently\n-    StringBuffer strbuf = new StringBuffer(buf.length/2 + 2);\n+    StringBuffer strbuf = new StringBuffer (buf.length / 2 + 2);\n \n     for (int i = 0; i < buf.length; )\n       {\n-\tif ((buf[i] & 0x80) == 0)\t\t// bit pattern 0xxxxxxx\n-\t  strbuf.append((char) (buf[i++] & 0xFF));\n-\telse if ((buf[i] & 0xE0) == 0xC0)\t// bit pattern 110xxxxx\n+\tif ((buf [i] & 0x80) == 0)\t\t// bit pattern 0xxxxxxx\n+\t  strbuf.append ((char) (buf [i++] & 0xFF));\n+\telse if ((buf [i] & 0xE0) == 0xC0)\t// bit pattern 110xxxxx\n \t  {\n-\t    if (i + 1 >= buf.length || (buf[i+1] & 0xC0) != 0x80)\n-\t      throw new UTFDataFormatException();\n+\t    if (i + 1 >= buf.length\n+\t\t|| (buf [i + 1] & 0xC0) != 0x80)\n+\t      throw new UTFDataFormatException ();\n \n-\t    strbuf.append((char) (((buf[i++] & 0x1F) << 6) |\n-\t\t\t\t  (buf[i++] & 0x3F)));\n+\t    strbuf.append((char) (((buf [i++] & 0x1F) << 6)\n+\t\t\t\t  | (buf [i++] & 0x3F)));\n \t  }\n-\telse if ((buf[i] & 0xF0) == 0xE0)\t// bit pattern 1110xxxx\n+\telse if ((buf [i] & 0xF0) == 0xE0)\t// bit pattern 1110xxxx\n \t  {\n-\t    if (i + 2 >= buf.length ||\n-\t\t(buf[i+1] & 0xC0) != 0x80 || (buf[i+2] & 0xC0) != 0x80)\n-\t      throw new UTFDataFormatException();\n-\n-\t    strbuf.append((char) (((buf[i++] & 0x0F) << 12) |\n-\t\t\t\t  ((buf[i++] & 0x3F) << 6) |\n-\t\t\t\t  (buf[i++] & 0x3F)));\n+\t    if (i + 2 >= buf.length\n+\t\t|| (buf [i + 1] & 0xC0) != 0x80\n+\t\t|| (buf [i + 2] & 0xC0) != 0x80)\n+\t      throw new UTFDataFormatException ();\n+\n+\t    strbuf.append ((char) (((buf [i++] & 0x0F) << 12)\n+\t\t\t\t   | ((buf [i++] & 0x3F) << 6)\n+\t\t\t\t   | (buf [i++] & 0x3F)));\n \t  }\n-\telse // must be ((buf[i] & 0xF0) == 0xF0 || (buf[i] & 0xC0) == 0x80)\n-\t  throw new UTFDataFormatException();\t// bit patterns 1111xxxx or\n+\telse // must be ((buf [i] & 0xF0) == 0xF0 || (buf [i] & 0xC0) == 0x80)\n+\t  throw new UTFDataFormatException ();\t// bit patterns 1111xxxx or\n \t\t\t\t\t\t// \t\t10xxxxxx\n       }\n \n-    return strbuf.toString();\n+    return strbuf.toString ();\n   }\n }"}, {"sha": "da0a9c55f110f578add3d1a59486da013bae2c45", "filename": "libjava/java/io/File.java", "status": "modified", "additions": 35, "deletions": 34, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c93aa80414eb376508a8e6dc4ef1d6cf8175535e/libjava%2Fjava%2Fio%2FFile.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c93aa80414eb376508a8e6dc4ef1d6cf8175535e/libjava%2Fjava%2Fio%2FFile.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FFile.java?ref=c93aa80414eb376508a8e6dc4ef1d6cf8175535e", "patch": "@@ -151,7 +151,7 @@ public class File implements Serializable, Comparable\n    */\n   public boolean canRead ()\n   {\n-    checkRead();\n+    checkRead ();\n     return _access (READ);\n   }\n \n@@ -171,7 +171,7 @@ public boolean canRead ()\n    */\n   public boolean canWrite ()\n   {\n-    checkWrite();\n+    checkWrite ();\n     return _access (WRITE);\n   }\n   \n@@ -196,7 +196,7 @@ public boolean canWrite ()\n    */\n   public boolean createNewFile() throws IOException\n   {\n-    checkWrite();\n+    checkWrite ();\n     return performCreate();\n   }\n  \n@@ -261,7 +261,7 @@ public boolean equals (Object obj)\n    */\n   public boolean exists ()\n   {\n-    checkRead();\n+    checkRead ();\n     return _access (EXISTS);\n   }\n \n@@ -637,7 +637,7 @@ public int hashCode ()\n    */\n   public boolean isDirectory ()\n   {\n-    checkRead();\n+    checkRead ();\n     return _stat (DIRECTORY);\n   }\n \n@@ -653,7 +653,7 @@ public boolean isDirectory ()\n    */\n   public boolean isFile ()\n   {\n-    checkRead();\n+    checkRead ();\n     return _stat (ISFILE);\n   }\n \n@@ -670,7 +670,7 @@ public boolean isFile ()\n    */\n   public boolean isHidden ()\n   {\n-    checkRead();\n+    checkRead ();\n     return _stat (ISHIDDEN);\n   }\n \n@@ -689,7 +689,7 @@ public boolean isHidden ()\n    */\n   public long lastModified ()\n   {\n-    checkRead();\n+    checkRead ();\n     return attr (MODIFIED);\n   }\n \n@@ -703,7 +703,7 @@ public long lastModified ()\n    */\n   public long length ()\n   {\n-    checkRead();\n+    checkRead ();\n     return attr (LENGTH);\n   }\n \n@@ -745,7 +745,7 @@ private final native Object[] performList (FilenameFilter filter,\n    */\n   public String[] list (FilenameFilter filter)\n   {\n-    checkRead();\n+    checkRead ();\n     return (String[]) performList (filter, null, String.class);\n   }\n \n@@ -769,7 +769,7 @@ public String[] list (FilenameFilter filter)\n    */\n   public String[] list ()\n   {\n-    checkRead();\n+    checkRead ();\n     return (String[]) performList (null, null, String.class);\n   }\n \n@@ -793,7 +793,7 @@ public String[] list ()\n    */\n   public File[] listFiles ()\n   {\n-    checkRead();\n+    checkRead ();\n     return (File[]) performList (null, null, File.class);\n   }\n   \n@@ -823,7 +823,7 @@ public File[] listFiles ()\n    */\n   public File[] listFiles (FilenameFilter filter)\n   {\n-    checkRead();\n+    checkRead ();\n     return (File[]) performList (filter, null, File.class);\n   }\n \n@@ -853,7 +853,7 @@ public File[] listFiles (FilenameFilter filter)\n    */\n   public File[] listFiles (FileFilter filter)\n   {\n-    checkRead();\n+    checkRead ();\n     return (File[]) performList (null, filter, File.class);\n   }\n \n@@ -905,7 +905,7 @@ public URL toURL () throws MalformedURLException\n    */\n   public boolean mkdir ()\n   {\n-    checkWrite();\n+    checkWrite ();\n     return performMkdir ();\n   }\n \n@@ -936,7 +936,7 @@ private static boolean mkdirs (File x)\n    */\n   public boolean mkdirs ()\n   {\n-    checkWrite();\n+    checkWrite ();\n     if (isDirectory ())\n       return false;\n     return mkdirs (new File (path));\n@@ -987,20 +987,21 @@ public static File createTempFile (String prefix, String suffix,\n \tString dirname = tmpdir;\n \tif (dirname == null)\n \t  throw \n-\t    new IOException(\"Cannot determine system temporary directory\"); \n+\t    new IOException (\"Cannot determine system temporary directory\"); \n \t\n-\tdirectory = new File(dirname);\n-\tif (!directory.exists())\n-\t  throw new IOException(\"System temporary directory \" \n-\t\t\t\t+ directory.getName() + \" does not exist.\");\n+\tdirectory = new File (dirname);\n+\tif (!directory.exists ())\n+\t  throw new IOException (\"System temporary directory \" \n+\t\t\t\t + directory.getName() + \" does not exist.\");\n \tif (!directory.isDirectory())\n-\t  throw new IOException(\"System temporary directory \" \n-\t\t\t\t+ directory.getName() \n-\t\t\t\t+ \" is not really a directory.\");\n+\t  throw new IOException (\"System temporary directory \" \n+\t\t\t\t + directory.getName() \n+\t\t\t\t + \" is not really a directory.\");\n       }\n \n     if (prefix.length () < 3)\n       throw new IllegalArgumentException (\"Prefix too short: \" + prefix);\n+\n     if (suffix == null)\n       suffix = \".tmp\";\n \n@@ -1059,7 +1060,7 @@ public static File createTempFile (String prefix, String suffix,\n    */\n   public boolean setReadOnly ()\n   {\n-    checkWrite();\n+    checkWrite ();\n     return performSetReadOnly();\n   }\n \n@@ -1089,7 +1090,7 @@ public static File[] listRoots ()\n \t  {\n \t    try\n \t      {\n-        \ts.checkRead(roots[i].path);\t\t\n+        \ts.checkRead (roots[i].path);\t\t\n \t      }\n \t    catch (SecurityException sx)\n \t      {\n@@ -1220,8 +1221,8 @@ public synchronized boolean renameTo (File dest)\n     String dname = dest.getName();\n     if (s != null)\n       {\n-\ts.checkWrite(sname);\n-\ts.checkWrite(dname);\n+\ts.checkWrite (sname);\n+\ts.checkWrite (dname);\n       }\n     return performRenameTo (dest);\n   }\n@@ -1249,7 +1250,7 @@ public synchronized boolean renameTo (File dest)\n    */\n   public boolean setLastModified (long time) \n   {\n-    checkWrite();\n+    checkWrite ();\n     return performSetLastModified(time);\n   }\n \n@@ -1272,11 +1273,11 @@ private void checkRead ()\n   }\n \n   /** \n-    * Add this File to the set of files to be deleted upon normal\n-    * termination.\n-    *\n-    * @since 1.2 \n-    */\n+   * Add this File to the set of files to be deleted upon normal\n+   * termination.\n+   *\n+   * @since 1.2 \n+   */\n   // FIXME: This should use the ShutdownHook API once we implement that.\n   public void deleteOnExit ()\n   {"}, {"sha": "9358ddaea5dba05c7f631cb5095b4bcd272da540", "filename": "libjava/java/io/PrintWriter.java", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c93aa80414eb376508a8e6dc4ef1d6cf8175535e/libjava%2Fjava%2Fio%2FPrintWriter.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c93aa80414eb376508a8e6dc4ef1d6cf8175535e/libjava%2Fjava%2Fio%2FPrintWriter.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FPrintWriter.java?ref=c93aa80414eb376508a8e6dc4ef1d6cf8175535e", "patch": "@@ -37,27 +37,27 @@\n \n package java.io;\n \n-/**\n-  * This class prints Java primitive values and objects to a stream as\n-  * text.  None of the methods in this class throw an exception.  However,\n-  * errors can be detected by calling the <code>checkError()</code> method.\n-  * Additionally, this stream can be designated as \"autoflush\" when \n-  * created so that any writes are automatically flushed to the underlying\n-  * output sink whenever one of the <code>println</code> methods is\n-  * called.  (Note that this differs from the <code>PrintStream</code>\n-  * class which also auto-flushes when it encounters a newline character\n-  * in the chars written).\n-  *\n-  * @author Per Bothner <bothner@cygnus.com>\n-  * @author Aaron M. Renn (arenn@urbanophile.com)\n-  * @date April 17, 1998.  \n-  */\n /* Written using \"Java Class Libraries\", 2nd edition, plus online\n  * API docs for JDK 1.2 beta from http://www.javasoft.com.\n  * Status:  Believed complete and correct.\n  * However, should use native methods for conversion.\n  */\n \n+/**\n+ * This class prints Java primitive values and objects to a stream as\n+ * text.  None of the methods in this class throw an exception.  However,\n+ * errors can be detected by calling the <code>checkError()</code> method.\n+ * Additionally, this stream can be designated as \"autoflush\" when \n+ * created so that any writes are automatically flushed to the underlying\n+ * output sink whenever one of the <code>println</code> methods is\n+ * called.  (Note that this differs from the <code>PrintStream</code>\n+ * class which also auto-flushes when it encounters a newline character\n+ * in the chars written).\n+ *\n+ * @author Per Bothner <bothner@cygnus.com>\n+ * @author Aaron M. Renn <arenn@urbanophile.com>\n+ * @date April 17, 1998.  \n+ */\n public class PrintWriter extends Writer\n {\n   /**"}]}