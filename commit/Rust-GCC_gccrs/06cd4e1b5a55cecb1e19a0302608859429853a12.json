{"sha": "06cd4e1b5a55cecb1e19a0302608859429853a12", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDZjZDRlMWI1YTU1Y2VjYjFlMTlhMDMwMjYwODg1OTQyOTg1M2ExMg==", "commit": {"author": {"name": "Mikael Morin", "email": "mikael@gcc.gnu.org", "date": "2011-11-03T23:37:24Z"}, "committer": {"name": "Mikael Morin", "email": "mikael@gcc.gnu.org", "date": "2011-11-03T23:37:24Z"}, "message": "trans-array.c (gfc_trans_create_temp_array): Loop over the parents.\n\n\t* trans-array.c (gfc_trans_create_temp_array): Loop over the parents.\n\nFrom-SVN: r180895", "tree": {"sha": "11fc754a73c17ef66bfc8c164ec5de63f1c22216", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/11fc754a73c17ef66bfc8c164ec5de63f1c22216"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/06cd4e1b5a55cecb1e19a0302608859429853a12", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06cd4e1b5a55cecb1e19a0302608859429853a12", "html_url": "https://github.com/Rust-GCC/gccrs/commit/06cd4e1b5a55cecb1e19a0302608859429853a12", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06cd4e1b5a55cecb1e19a0302608859429853a12/comments", "author": null, "committer": null, "parents": [{"sha": "d6b3a0d72c93b797907825d4273f80ca2a47c476", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6b3a0d72c93b797907825d4273f80ca2a47c476", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d6b3a0d72c93b797907825d4273f80ca2a47c476"}], "stats": {"total": 75, "additions": 43, "deletions": 32}, "files": [{"sha": "e973d4875538e20143dc93e3f0014b0b6e4c228e", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06cd4e1b5a55cecb1e19a0302608859429853a12/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06cd4e1b5a55cecb1e19a0302608859429853a12/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=06cd4e1b5a55cecb1e19a0302608859429853a12", "patch": "@@ -1,3 +1,7 @@\n+2011-11-03  Mikael Morin  <mikael@gcc.gnu.org>\n+\n+\t* trans-array.c (gfc_trans_create_temp_array): Loop over the parents.\n+\n 2011-11-03  Mikael Morin  <mikael@gcc.gnu.org>\n \n \t* trans-array.c (get_array_ref_dim, get_scalarizer_dim_for_array_dim): "}, {"sha": "1a86ae66c59e2814d7735d66c6418b46fa59585b", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 39, "deletions": 32, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06cd4e1b5a55cecb1e19a0302608859429853a12/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06cd4e1b5a55cecb1e19a0302608859429853a12/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=06cd4e1b5a55cecb1e19a0302608859429853a12", "patch": "@@ -943,6 +943,7 @@ gfc_trans_create_temp_array (stmtblock_t * pre, stmtblock_t * post, gfc_ss * ss,\n \t\t\t     bool dealloc, bool callee_alloc, locus * where)\n {\n   gfc_loopinfo *loop;\n+  gfc_ss *s;\n   gfc_array_info *info;\n   tree from[GFC_MAX_DIMENSIONS], to[GFC_MAX_DIMENSIONS];\n   tree type;\n@@ -966,41 +967,45 @@ gfc_trans_create_temp_array (stmtblock_t * pre, stmtblock_t * post, gfc_ss * ss,\n   if (gfc_option.warn_array_temp && where)\n     gfc_warning (\"Creating array temporary at %L\", where);\n \n-  loop = ss->loop;\n-  total_dim = loop->dimen;\n   /* Set the lower bound to zero.  */\n-  for (n = 0; n < loop->dimen; n++)\n+  for (s = ss; s; s = s->parent)\n     {\n-      dim = ss->dim[n];\n+      loop = s->loop;\n+\n+      total_dim += loop->dimen;\n+      for (n = 0; n < loop->dimen; n++)\n+\t{\n+\t  dim = s->dim[n];\n \n-      /* Callee allocated arrays may not have a known bound yet.  */\n-      if (loop->to[n])\n-\tloop->to[n] = gfc_evaluate_now (\n+\t  /* Callee allocated arrays may not have a known bound yet.  */\n+\t  if (loop->to[n])\n+\t    loop->to[n] = gfc_evaluate_now (\n \t\t\tfold_build2_loc (input_location, MINUS_EXPR,\n \t\t\t\t\t gfc_array_index_type,\n \t\t\t\t\t loop->to[n], loop->from[n]),\n \t\t\tpre);\n-      loop->from[n] = gfc_index_zero_node;\n-\n-      /* We have just changed the loop bounds, we must clear the\n-\t corresponding specloop, so that delta calculation is not skipped\n-\t later in set_delta.  */\n-      loop->specloop[n] = NULL;\n-\n-      /* We are constructing the temporary's descriptor based on the loop\n-\t dimensions. As the dimensions may be accessed in arbitrary order\n-\t (think of transpose) the size taken from the n'th loop may not map\n-\t to the n'th dimension of the array. We need to reconstruct loop infos\n-\t in the right order before using it to set the descriptor\n-\t bounds.  */\n-      tmp_dim = get_scalarizer_dim_for_array_dim (ss, dim);\n-      from[tmp_dim] = loop->from[n];\n-      to[tmp_dim] = loop->to[n];\n-\n-      info->delta[dim] = gfc_index_zero_node;\n-      info->start[dim] = gfc_index_zero_node;\n-      info->end[dim] = gfc_index_zero_node;\n-      info->stride[dim] = gfc_index_one_node;\n+\t  loop->from[n] = gfc_index_zero_node;\n+\n+\t  /* We have just changed the loop bounds, we must clear the\n+\t     corresponding specloop, so that delta calculation is not skipped\n+\t     later in set_delta.  */\n+\t  loop->specloop[n] = NULL;\n+\n+\t  /* We are constructing the temporary's descriptor based on the loop\n+\t     dimensions.  As the dimensions may be accessed in arbitrary order\n+\t     (think of transpose) the size taken from the n'th loop may not map\n+\t     to the n'th dimension of the array.  We need to reconstruct loop\n+\t     infos in the right order before using it to set the descriptor\n+\t     bounds.  */\n+\t  tmp_dim = get_scalarizer_dim_for_array_dim (ss, dim);\n+\t  from[tmp_dim] = loop->from[n];\n+\t  to[tmp_dim] = loop->to[n];\n+\n+\t  info->delta[dim] = gfc_index_zero_node;\n+\t  info->start[dim] = gfc_index_zero_node;\n+\t  info->end[dim] = gfc_index_zero_node;\n+\t  info->stride[dim] = gfc_index_one_node;\n+\t}\n     }\n \n   /* Initialize the descriptor.  */\n@@ -1042,8 +1047,8 @@ gfc_trans_create_temp_array (stmtblock_t * pre, stmtblock_t * post, gfc_ss * ss,\n       }\n \n   if (size == NULL_TREE)\n-    {\n-      for (n = 0; n < loop->dimen; n++)\n+    for (s = ss; s; s = s->parent)\n+      for (n = 0; n < s->loop->dimen; n++)\n \t{\n \t  dim = get_scalarizer_dim_for_array_dim (ss, ss->dim[n]);\n \n@@ -1053,9 +1058,8 @@ gfc_trans_create_temp_array (stmtblock_t * pre, stmtblock_t * post, gfc_ss * ss,\n \t\tMINUS_EXPR, gfc_array_index_type,\n \t\tgfc_conv_descriptor_ubound_get (desc, gfc_rank_cst[dim]),\n \t\tgfc_conv_descriptor_lbound_get (desc, gfc_rank_cst[dim]));\n-\t  loop->to[n] = tmp;\n+\t  s->loop->to[n] = tmp;\n \t}\n-    }\n   else\n     {\n       for (n = 0; n < total_dim; n++)\n@@ -1112,6 +1116,9 @@ gfc_trans_create_temp_array (stmtblock_t * pre, stmtblock_t * post, gfc_ss * ss,\n   gfc_trans_allocate_array_storage (pre, post, info, size, nelem, initial,\n \t\t\t\t    dynamic, dealloc);\n \n+  while (ss->parent)\n+    ss = ss->parent;\n+\n   if (ss->dimen > ss->loop->temp_dim)\n     ss->loop->temp_dim = ss->dimen;\n "}]}