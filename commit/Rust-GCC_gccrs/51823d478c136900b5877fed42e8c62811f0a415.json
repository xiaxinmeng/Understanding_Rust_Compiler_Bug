{"sha": "51823d478c136900b5877fed42e8c62811f0a415", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTE4MjNkNDc4YzEzNjkwMGI1ODc3ZmVkNDJlOGM2MjgxMWYwYTQxNQ==", "commit": {"author": {"name": "John David Anglin", "email": "dave.anglin@nrc-cnrc.gc.ca", "date": "2007-02-10T19:51:40Z"}, "committer": {"name": "John David Anglin", "email": "danglin@gcc.gnu.org", "date": "2007-02-10T19:51:40Z"}, "message": "re PR target/30634 (FAIL: gfortran.fortran-torture/execute/intrinsic_set_exponent.f90)\n\n\tPR target/30634\n\t* pa.md (movdf): For 64-bit target, fail if operand 1 is a non-zero\n\tCONST_DOUBLE and operand 0 is a hard register.\n\t(movdi): For 64-bit target, remove code to force CONST_DOUBLE to\n\tmemory.  Fail if operand 1 is a non-zero CONST_INT and operand 0\n\tis a hard floating-point register.\n\nFrom-SVN: r121802", "tree": {"sha": "46daa20a7c7abb9d49eeb1a699fa8aea75de6be2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/46daa20a7c7abb9d49eeb1a699fa8aea75de6be2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/51823d478c136900b5877fed42e8c62811f0a415", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51823d478c136900b5877fed42e8c62811f0a415", "html_url": "https://github.com/Rust-GCC/gccrs/commit/51823d478c136900b5877fed42e8c62811f0a415", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51823d478c136900b5877fed42e8c62811f0a415/comments", "author": null, "committer": null, "parents": [{"sha": "2ccef0dd3a0e2242f05d3726169f2d368187842f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ccef0dd3a0e2242f05d3726169f2d368187842f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2ccef0dd3a0e2242f05d3726169f2d368187842f"}], "stats": {"total": 36, "additions": 32, "deletions": 4}, "files": [{"sha": "9912fd8a0f6ab36d3a4556d5147c2608a9926588", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51823d478c136900b5877fed42e8c62811f0a415/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51823d478c136900b5877fed42e8c62811f0a415/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=51823d478c136900b5877fed42e8c62811f0a415", "patch": "@@ -1,3 +1,12 @@\n+2007-02-10  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>\n+\n+\tPR target/30634\n+\t* pa.md (movdf): For 64-bit target, fail if operand 1 is a non-zero\n+\tCONST_DOUBLE and operand 0 is a hard register.\n+\t(movdi): For 64-bit target, remove code to force CONST_DOUBLE to\n+\tmemory.  Fail if operand 1 is a non-zero CONST_INT and operand 0\n+\tis a hard floating-point register.\n+\n 2007-02-10  Richard Henderson  <rth@redhat.com>, Jakub Jelinek  <jakub@redhat.com>, Alexandre Oliva  <aoliva@redhat.com>\n \n \t* Makefile.in (libgcc-support, libgcc.mvars): Add emutls.c."}, {"sha": "61dbb46992e7f1aab09c847ecc042c041ca576ce", "filename": "gcc/config/pa/pa.md", "status": "modified", "additions": 23, "deletions": 4, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51823d478c136900b5877fed42e8c62811f0a415/gcc%2Fconfig%2Fpa%2Fpa.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51823d478c136900b5877fed42e8c62811f0a415/gcc%2Fconfig%2Fpa%2Fpa.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.md?ref=51823d478c136900b5877fed42e8c62811f0a415", "patch": "@@ -4098,8 +4098,18 @@\n   \"\"\n   \"\n {\n-  if (GET_CODE (operands[1]) == CONST_DOUBLE && TARGET_64BIT)\n-    operands[1] = force_const_mem (DFmode, operands[1]);\n+  if (TARGET_64BIT\n+      && GET_CODE (operands[1]) == CONST_DOUBLE\n+      && operands[1] != CONST0_RTX (DFmode))\n+    {\n+      /* We rely on reload to legitimize the insn generated after\n+\t we force the CONST_DOUBLE to memory.  This doesn't happen\n+\t if OPERANDS[0] is a hard register.  */\n+      if (REG_P (operands[0]) && HARD_REGISTER_P (operands[0]))\n+\tFAIL;\n+\n+      operands[1] = force_const_mem (DFmode, operands[1]);\n+    }\n \n   if (emit_move_sequence (operands, DFmode, 0))\n     DONE;\n@@ -4358,8 +4368,17 @@\n   \"\"\n   \"\n {\n-  if (GET_CODE (operands[1]) == CONST_DOUBLE && TARGET_64BIT)\n-    operands[1] = force_const_mem (DImode, operands[1]);\n+  /* Except for zero, we don't support loading a CONST_INT directly\n+     to a hard floating-point register since a scratch register is\n+     needed for the operation.  While the operation could be handled\n+     before no_new_pseudos is true, the simplest solution is to fail.  */\n+  if (TARGET_64BIT\n+      && GET_CODE (operands[1]) == CONST_INT\n+      && operands[1] != CONST0_RTX (DImode)\n+      && REG_P (operands[0])\n+      && HARD_REGISTER_P (operands[0])\n+      && REGNO (operands[0]) >= 32)\n+    FAIL;\n \n   if (emit_move_sequence (operands, DImode, 0))\n     DONE;"}]}