{"sha": "c93c502529fb81ef96ecf90dcc19568227c5b4cb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzkzYzUwMjUyOWZiODFlZjk2ZWNmOTBkY2MxOTU2ODIyN2M1YjRjYg==", "commit": {"author": {"name": "Sebastian Pop", "email": "pop@cri.ensmp.fr", "date": "2006-05-17T14:25:59Z"}, "committer": {"name": "Sebastian Pop", "email": "spop@gcc.gnu.org", "date": "2006-05-17T14:25:59Z"}, "message": "re PR tree-optimization/20256 (Perfect nest transformation not conservative enough)\n\n\tPR middle-end/20256\n\tPR middle-end/26435\n\t* tree-loop-linear.c (linear_transform_loops): Don't test perfect_nest_p.\n\tCall rewrite_into_loop_closed_ssa only when something changed.\n\t* lambda.h (gcc_loopnest_to_lambda_loopnest): Update declaration.\n\t* lambda-code.c (can_convert_to_perfect_nest): Declared.\n\t(gcc_loopnest_to_lambda_loopnest): Removed need_perfect_nest parameter.\n\tTest for perfect_nest_p here.  Fix formating.\n\t(replace_uses_equiv_to_x_with_y): Fix formating.\n\t(stmt_uses_op): Removed.\n\t(can_convert_to_perfect_nest): Removed loopivs parameter.\n\tComplete the test by checking the scalar dependences.\n\t(perfect_nestify): Remove the test for can_convert_to_perfect_nest.\n\tFix formating.\n\nFrom-SVN: r113862", "tree": {"sha": "07cae7d173df3ab165bcf789fe48c1aeddde3dda", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/07cae7d173df3ab165bcf789fe48c1aeddde3dda"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c93c502529fb81ef96ecf90dcc19568227c5b4cb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c93c502529fb81ef96ecf90dcc19568227c5b4cb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c93c502529fb81ef96ecf90dcc19568227c5b4cb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c93c502529fb81ef96ecf90dcc19568227c5b4cb/comments", "author": null, "committer": {"login": "sebpop", "id": 568397, "node_id": "MDQ6VXNlcjU2ODM5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/568397?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sebpop", "html_url": "https://github.com/sebpop", "followers_url": "https://api.github.com/users/sebpop/followers", "following_url": "https://api.github.com/users/sebpop/following{/other_user}", "gists_url": "https://api.github.com/users/sebpop/gists{/gist_id}", "starred_url": "https://api.github.com/users/sebpop/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sebpop/subscriptions", "organizations_url": "https://api.github.com/users/sebpop/orgs", "repos_url": "https://api.github.com/users/sebpop/repos", "events_url": "https://api.github.com/users/sebpop/events{/privacy}", "received_events_url": "https://api.github.com/users/sebpop/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "46343456ba95ba86b04b8a21e91095cf6b2ec8e4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46343456ba95ba86b04b8a21e91095cf6b2ec8e4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/46343456ba95ba86b04b8a21e91095cf6b2ec8e4"}], "stats": {"total": 243, "additions": 168, "deletions": 75}, "files": [{"sha": "9baecb1796a883dff76a57aa2069342546d4ac50", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c93c502529fb81ef96ecf90dcc19568227c5b4cb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c93c502529fb81ef96ecf90dcc19568227c5b4cb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c93c502529fb81ef96ecf90dcc19568227c5b4cb", "patch": "@@ -1,3 +1,20 @@\n+2006-05-17  Sebastian Pop  <pop@cri.ensmp.fr>\n+\n+\tPR middle-end/20256\n+\tPR middle-end/26435\n+\t* tree-loop-linear.c (linear_transform_loops): Don't test perfect_nest_p.\n+\tCall rewrite_into_loop_closed_ssa only when something changed.\n+\t* lambda.h (gcc_loopnest_to_lambda_loopnest): Update declaration.\n+\t* lambda-code.c (can_convert_to_perfect_nest): Declared.\n+\t(gcc_loopnest_to_lambda_loopnest): Removed need_perfect_nest parameter.\n+\tTest for perfect_nest_p here.  Fix formating.\n+\t(replace_uses_equiv_to_x_with_y): Fix formating.\n+\t(stmt_uses_op): Removed.\n+\t(can_convert_to_perfect_nest): Removed loopivs parameter.\n+\tComplete the test by checking the scalar dependences.\n+\t(perfect_nestify): Remove the test for can_convert_to_perfect_nest.\n+\tFix formating.\n+\n 2005-05-17  Bernd Schmidt  <bernd.schmidt@analog.com>\n \n \tPR bootstrap/22541"}, {"sha": "60f1be209ce946767db60b9f4e18d5129288dfba", "filename": "gcc/lambda-code.c", "status": "modified", "additions": 97, "deletions": 63, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c93c502529fb81ef96ecf90dcc19568227c5b4cb/gcc%2Flambda-code.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c93c502529fb81ef96ecf90dcc19568227c5b4cb/gcc%2Flambda-code.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flambda-code.c?ref=c93c502529fb81ef96ecf90dcc19568227c5b4cb", "patch": "@@ -147,6 +147,7 @@ static lambda_lattice lambda_lattice_new (int, int);\n static lambda_lattice lambda_lattice_compute_base (lambda_loopnest);\n \n static tree find_induction_var_from_exit_cond (struct loop *);\n+static bool can_convert_to_perfect_nest (struct loop *);\n \n /* Create a new lambda body vector.  */\n \n@@ -1457,37 +1458,40 @@ DEF_VEC_ALLOC_P(lambda_loop,heap);\n \n lambda_loopnest\n gcc_loopnest_to_lambda_loopnest (struct loops *currloops,\n-\t\t\t\t struct loop * loop_nest,\n+\t\t\t\t struct loop *loop_nest,\n \t\t\t\t VEC(tree,heap) **inductionvars,\n-\t\t\t\t VEC(tree,heap) **invariants,\n-\t\t\t\t bool need_perfect_nest)\n+\t\t\t\t VEC(tree,heap) **invariants)\n {\n   lambda_loopnest ret = NULL;\n-  struct loop *temp;\n-  int depth = 0;\n+  struct loop *temp = loop_nest;\n+  int depth = depth_of_nest (loop_nest);\n   size_t i;\n   VEC(lambda_loop,heap) *loops = NULL;\n   VEC(tree,heap) *uboundvars = NULL;\n   VEC(tree,heap) *lboundvars  = NULL;\n   VEC(int,heap) *steps = NULL;\n   lambda_loop newloop;\n   tree inductionvar = NULL;\n-  \n-  depth = depth_of_nest (loop_nest);\n-  temp = loop_nest;\n+  bool perfect_nest = perfect_nest_p (loop_nest);\n+\n+  if (!perfect_nest && !can_convert_to_perfect_nest (loop_nest))\n+    goto fail;\n+\n   while (temp)\n     {\n       newloop = gcc_loop_to_lambda_loop (temp, depth, invariants,\n \t\t\t\t\t &inductionvar, *inductionvars,\n \t\t\t\t\t &lboundvars, &uboundvars,\n \t\t\t\t\t &steps);\n       if (!newloop)\n-\treturn NULL;\n+\tgoto fail;\n+\n       VEC_safe_push (tree, heap, *inductionvars, inductionvar);\n       VEC_safe_push (lambda_loop, heap, loops, newloop);\n       temp = temp->inner;\n     }\n-  if (need_perfect_nest)\n+\n+  if (!perfect_nest)\n     {\n       if (!perfect_nestify (currloops, loop_nest, \n \t\t\t    lboundvars, uboundvars, steps, *inductionvars))\n@@ -1501,9 +1505,12 @@ gcc_loopnest_to_lambda_loopnest (struct loops *currloops,\n \tfprintf (dump_file,\n \t\t \"Successfully converted loop nest to perfect loop nest.\\n\");\n     }\n+\n   ret = lambda_loopnest_new (depth, 2 * depth);\n+\n   for (i = 0; VEC_iterate (lambda_loop, loops, i, newloop); i++)\n     LN_LOOPS (ret)[i] = newloop;\n+\n  fail:\n   VEC_free (lambda_loop, heap, loops);\n   VEC_free (tree, heap, uboundvars);\n@@ -2110,13 +2117,12 @@ replace_uses_equiv_to_x_with_y (struct loop *loop, tree stmt, tree x,\n     {\n       tree use = USE_FROM_PTR (use_p);\n       tree step = NULL_TREE;\n-      tree access_fn = NULL_TREE;\n-      \n-      \n-      access_fn = instantiate_parameters\n-\t(loop, analyze_scalar_evolution (loop, use));\n-      if (access_fn != NULL_TREE && access_fn != chrec_dont_know)\n-\tstep = evolution_part_in_loop_num (access_fn, loop->num);\n+      tree scev = instantiate_parameters (loop,\n+\t\t\t\t\t  analyze_scalar_evolution (loop, use));\n+\n+      if (scev != NULL_TREE && scev != chrec_dont_know)\n+\tstep = evolution_part_in_loop_num (scev, loop->num);\n+\n       if ((step && step != chrec_dont_know \n \t   && TREE_CODE (step) == INTEGER_CST\n \t   && int_cst_value (step) == xstep)\n@@ -2125,22 +2131,6 @@ replace_uses_equiv_to_x_with_y (struct loop *loop, tree stmt, tree x,\n     }\n }\n \n-/* Return TRUE if STMT uses tree OP in it's uses.  */\n-\n-static bool\n-stmt_uses_op (tree stmt, tree op)\n-{\n-  ssa_op_iter iter;\n-  tree use;\n-\n-  FOR_EACH_SSA_TREE_OPERAND (use, stmt, iter, SSA_OP_USE)\n-    {\n-      if (use == op)\n-\treturn true;\n-    }\n-  return false;\n-}\n-\n /* Return true if STMT is an exit PHI for LOOP */\n \n static bool\n@@ -2210,14 +2200,12 @@ can_put_after_inner_loop (struct loop *loop, tree stmt)\n \n \n \n-/* Return TRUE if LOOP is an imperfect nest that we can convert to a perfect\n-   one.  LOOPIVS is a vector of induction variables, one per loop.  \n-   ATM, we only handle imperfect nests of depth 2, where all of the statements\n-   occur after the inner loop.  */\n+/* Return TRUE if LOOP is an imperfect nest that we can convert to a\n+   perfect one.  At the moment, we only handle imperfect nests of\n+   depth 2, where all of the statements occur after the inner loop.  */\n \n static bool\n-can_convert_to_perfect_nest (struct loop *loop,\n-\t\t\t     VEC(tree,heap) *loopivs)\n+can_convert_to_perfect_nest (struct loop *loop)\n {\n   basic_block *bbs;\n   tree exit_condition, phi;\n@@ -2237,19 +2225,13 @@ can_convert_to_perfect_nest (struct loop *loop,\n \t{\n \t  for (bsi = bsi_start (bbs[i]); !bsi_end_p (bsi); bsi_next (&bsi))\n \t    { \n-\t      size_t j;\n \t      tree stmt = bsi_stmt (bsi);\n-\t      tree iv;\n-\t      \n+\n \t      if (stmt == exit_condition\n \t\t  || not_interesting_stmt (stmt)\n \t\t  || stmt_is_bumper_for_loop (loop, stmt))\n \t\tcontinue;\n-\t      /* If the statement uses inner loop ivs, we == screwed.  */\n-\t      for (j = 1; VEC_iterate (tree, loopivs, j, iv); j++)\n-\t\tif (stmt_uses_op (stmt, iv))\n-\t\t  goto fail;\n-\t      \n+\n \t      /* If this is a scalar operation that can be put back\n \t         into the inner loop, or after the inner loop, through\n \t\t copying, then do so. This works on the theory that\n@@ -2258,10 +2240,65 @@ can_convert_to_perfect_nest (struct loop *loop,\n \t\t win we get from rearranging the memory walk\n \t\t the loop is doing so that it has better\n \t\t cache behavior.  */\n-\t      if (TREE_CODE (stmt) == MODIFY_EXPR\n-\t\t  && (can_put_in_inner_loop (loop->inner, stmt)\n-\t\t      || can_put_after_inner_loop (loop, stmt)))\n-\t\tcontinue;\n+\t      if (TREE_CODE (stmt) == MODIFY_EXPR)\n+\t\t{\n+\t\t  use_operand_p use_a, use_b;\n+\t\t  imm_use_iterator imm_iter;\n+\t\t  ssa_op_iter op_iter, op_iter1;\n+\t\t  tree op0 = TREE_OPERAND (stmt, 0);\n+\t\t  tree scev = instantiate_parameters\n+\t\t    (loop, analyze_scalar_evolution (loop, op0));\n+\n+\t\t  /* If the IV is simple, it can be duplicated.  */\n+\t\t  if (!automatically_generated_chrec_p (scev))\n+\t\t    {\n+\t\t      tree step = evolution_part_in_loop_num (scev, loop->num);\n+\t\t      if (step && step != chrec_dont_know \n+\t\t\t  && TREE_CODE (step) == INTEGER_CST)\n+\t\t\tcontinue;\n+\t\t    }\n+\n+\t\t  /* The statement should not define a variable used\n+\t\t     in the inner loop.  */\n+\t\t  if (TREE_CODE (op0) == SSA_NAME)\n+\t\t    FOR_EACH_IMM_USE_FAST (use_a, imm_iter, op0)\n+\t\t      if (bb_for_stmt (USE_STMT (use_a))->loop_father\n+\t\t\t  == loop->inner)\n+\t\t\tgoto fail;\n+\n+\t\t  FOR_EACH_SSA_USE_OPERAND (use_a, stmt, op_iter, SSA_OP_USE)\n+\t\t    {\n+\t\t      tree node, op = USE_FROM_PTR (use_a);\n+\n+\t\t      /* The variables should not be used in both loops.  */\n+\t\t      FOR_EACH_IMM_USE_FAST (use_b, imm_iter, op)\n+\t\t      if (bb_for_stmt (USE_STMT (use_b))->loop_father\n+\t\t\t  == loop->inner)\n+\t\t\tgoto fail;\n+\n+\t\t      /* The statement should not use the value of a\n+\t\t\t scalar that was modified in the loop.  */\n+\t\t      node = SSA_NAME_DEF_STMT (op);\n+\t\t      if (TREE_CODE (node) == PHI_NODE)\n+\t\t\tFOR_EACH_PHI_ARG (use_b, node, op_iter1, SSA_OP_USE)\n+\t\t\t  {\n+\t\t\t    tree arg = USE_FROM_PTR (use_b);\n+\n+\t\t\t    if (TREE_CODE (arg) == SSA_NAME)\n+\t\t\t      {\n+\t\t\t\ttree arg_stmt = SSA_NAME_DEF_STMT (arg);\n+\n+\t\t\t\tif (bb_for_stmt (arg_stmt)->loop_father\n+\t\t\t\t    == loop->inner)\n+\t\t\t\t  goto fail;\n+\t\t\t      }\n+\t\t\t  }\n+\t\t    }\n+\n+\t\t  if (can_put_in_inner_loop (loop->inner, stmt)\n+\t\t      || can_put_after_inner_loop (loop, stmt))\n+\t\t    continue;\n+\t\t}\n \n \t      /* Otherwise, if the bb of a statement we care about isn't\n \t\t dominated by the header of the inner loop, then we can't\n@@ -2351,14 +2388,10 @@ perfect_nestify (struct loops *loops,\n   tree stmt;\n   tree oldivvar, ivvar, ivvarinced;\n   VEC(tree,heap) *phis = NULL;\n-\n-  if (!can_convert_to_perfect_nest (loop, loopivs))\n-    return false;\n-\n-  /* Create the new loop */\n-\n+  \n+  /* Create the new loop.  */\n   olddest = loop->single_exit->dest;\n-  preheaderbb =  loop_split_edge_with (loop->single_exit, NULL);\n+  preheaderbb = loop_split_edge_with (loop->single_exit, NULL);\n   headerbb = create_empty_bb (EXIT_BLOCK_PTR->prev_bb);\n   \n   /* Push the exit phi nodes that we are moving.  */\n@@ -2490,7 +2523,7 @@ perfect_nestify (struct loops *loops,\n \t\t    }\n \t\t  \n \t\t  /* Make copies of this statement to put it back next\n-\t\t     to its uses. */\n+\t\t     to its uses.  */\n \t\t  FOR_EACH_IMM_USE_STMT (imm_stmt, imm_iter, \n \t\t\t\t\t TREE_OPERAND (stmt, 0))\n \t\t    {\n@@ -2506,8 +2539,10 @@ perfect_nestify (struct loops *loops,\n \t\t\t  newname = SSA_NAME_VAR (newname);\n \t\t\t  newname = make_ssa_name (newname, newstmt);\n \t\t\t  TREE_OPERAND (newstmt, 0) = newname;\n+\n \t\t\t  FOR_EACH_IMM_USE_ON_STMT (use_p, imm_iter)\n \t\t\t    SET_USE (use_p, newname);\n+\n \t\t\t  bsi_insert_before (&tobsi, newstmt, BSI_SAME_STMT);\n \t\t\t  update_stmt (newstmt);\n \t\t\t  update_stmt (imm_stmt);\n@@ -2535,10 +2570,9 @@ perfect_nestify (struct loops *loops,\n \t\t      continue;\n \t\t    }\n \t\t  \n-\t\t  replace_uses_equiv_to_x_with_y (loop, stmt, \n-\t\t\t\t\t\t  oldivvar,  \n-\t\t\t\t\t\t  VEC_index (int, steps, 0),\n-\t\t\t\t\t\t  ivvar);\n+\t\t  replace_uses_equiv_to_x_with_y \n+\t\t    (loop, stmt, oldivvar, VEC_index (int, steps, 0), ivvar);\n+\n \t\t  bsi_move_before (&bsi, &tobsi);\n \t\t  \n \t\t  /* If the statement has any virtual operands, they may"}, {"sha": "5eb63997c0d8090d4927d23128f2bd0097694fa9", "filename": "gcc/lambda.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c93c502529fb81ef96ecf90dcc19568227c5b4cb/gcc%2Flambda.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c93c502529fb81ef96ecf90dcc19568227c5b4cb/gcc%2Flambda.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flambda.h?ref=c93c502529fb81ef96ecf90dcc19568227c5b4cb", "patch": "@@ -199,8 +199,7 @@ void print_lambda_body_vector (FILE *, lambda_body_vector);\n lambda_loopnest gcc_loopnest_to_lambda_loopnest (struct loops *,\n \t\t\t\t\t\t struct loop *,\n \t\t\t\t\t\t VEC(tree,heap) **,\n-\t\t\t\t\t\t VEC(tree,heap) **,\n-\t\t\t\t\t\t bool);\n+\t\t\t\t\t\t VEC(tree,heap) **);\n void lambda_loopnest_to_gcc_loopnest (struct loop *,\n \t\t\t\t      VEC(tree,heap) *, VEC(tree,heap) *,\n \t\t\t\t      lambda_loopnest, lambda_trans_matrix);"}, {"sha": "736a4d95577a6a5ac983cf8e45f0ef10aca79e18", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ltrans-1.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c93c502529fb81ef96ecf90dcc19568227c5b4cb/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fltrans-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c93c502529fb81ef96ecf90dcc19568227c5b4cb/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fltrans-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fltrans-1.c?ref=c93c502529fb81ef96ecf90dcc19568227c5b4cb", "patch": "@@ -18,7 +18,6 @@ int foo(int N, int *res)\n     }\n   *res = sum + N;\n }\n-/* { dg-final { scan-tree-dump-times \"converted loop nest to perfect\n-   loop nest\" 1 \"ltrans\"} } */ \n+/* { dg-final { scan-tree-dump-times \"converted loop nest to perfect loop nest\" 1 \"ltrans\"} } */ \n /* { dg-final { scan-tree-dump-times \"transformed loop\" 1 \"ltrans\"} } */ \n /* { dg-final { cleanup-tree-dump \"ltrans\" } } */"}, {"sha": "aa482edab636c3e3814ec1e019b3ea26bf2df19c", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr20256.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c93c502529fb81ef96ecf90dcc19568227c5b4cb/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr20256.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c93c502529fb81ef96ecf90dcc19568227c5b4cb/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr20256.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr20256.c?ref=c93c502529fb81ef96ecf90dcc19568227c5b4cb", "patch": "@@ -0,0 +1,25 @@\n+/* { dg-do compile } */ \n+/* { dg-options \"-O2 -ftree-loop-linear -fdump-tree-ltrans-all\" } */\n+/* { dg-require-effective-target size32plus } */\n+\n+int foo()\n+{\n+  int x[2][2], y[2];\n+  int i, n, s;\n+\n+  /* This is a reduction: there is a scalar dependence that cannot be\n+     removed by rewriting IVs.  This code cannot and should not be\n+     transformed into a perfect loop.  */\n+  for (n = 0; n < 2; n++)\n+    {\n+      s = 0;\n+      for (i = 0; i < 2; i++)\n+        s += x[n][i]*y[i];\n+      s += 1;\n+    }\n+\n+  return s;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"converted loop nest to perfect loop nest\" 0 \"ltrans\"} } */ \n+/* { dg-final { cleanup-tree-dump \"ltrans\" } } */"}, {"sha": "907c5d28dc45583f1a6401f8200a4017b0dc3e5c", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr26435.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c93c502529fb81ef96ecf90dcc19568227c5b4cb/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr26435.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c93c502529fb81ef96ecf90dcc19568227c5b4cb/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr26435.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr26435.c?ref=c93c502529fb81ef96ecf90dcc19568227c5b4cb", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-do compile } */ \n+/* { dg-options \"-O2 -ftree-loop-linear -fdump-tree-ltrans-all\" } */\n+/* { dg-require-effective-target size32plus } */\n+\n+int foo(int *p, int n)\n+{\n+  int i, j, k = 0;\n+\n+  /* This is a reduction: there is a scalar dependence that cannot be\n+     removed by rewriting IVs.  This code cannot and should not be\n+     transformed into a perfect loop.  */\n+  for (i = 0; i < 2; ++i, p += n)\n+    for (j = 0; j < 2; ++j)\n+      k += p[j];\n+\n+  return k;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"converted loop nest to perfect loop nest\" 0 \"ltrans\"} } */ \n+/* { dg-final { cleanup-tree-dump \"ltrans\" } } */"}, {"sha": "e0f5bd2991bdd757c72dc18ba7c6782bc25c5324", "filename": "gcc/tree-loop-linear.c", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c93c502529fb81ef96ecf90dcc19568227c5b4cb/gcc%2Ftree-loop-linear.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c93c502529fb81ef96ecf90dcc19568227c5b4cb/gcc%2Ftree-loop-linear.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-loop-linear.c?ref=c93c502529fb81ef96ecf90dcc19568227c5b4cb", "patch": "@@ -241,6 +241,7 @@ try_interchange_loops (lambda_trans_matrix trans,\n void\n linear_transform_loops (struct loops *loops)\n {\n+  bool modified = false;\n   unsigned int i;\n   VEC(tree,heap) *oldivs = NULL;\n   VEC(tree,heap) *invariants = NULL;\n@@ -255,7 +256,6 @@ linear_transform_loops (struct loops *loops)\n       lambda_loopnest before, after;\n       lambda_trans_matrix trans;\n       bool problem = false;\n-      bool need_perfect_nest = false;\n       /* If it's not a loop nest, we don't want it.\n          We also don't handle sibling loops properly, \n          which are loops of the following form:\n@@ -319,13 +319,9 @@ linear_transform_loops (struct loops *loops)\n \t  continue;\n \t}\n \n-      if (!perfect_nest_p (loop_nest))\n-\tneed_perfect_nest = true;\n+      before = gcc_loopnest_to_lambda_loopnest (loops, loop_nest, &oldivs,\n+\t\t\t\t\t\t&invariants);\n \n-      before = gcc_loopnest_to_lambda_loopnest (loops,\n-\t\t\t\t\t\tloop_nest, &oldivs, \n-\t\t\t\t\t\t&invariants,\n-\t\t\t\t\t\tneed_perfect_nest);\n       if (!before)\n \tcontinue;\n             \n@@ -345,6 +341,7 @@ linear_transform_loops (struct loops *loops)\n \n       lambda_loopnest_to_gcc_loopnest (loop_nest, oldivs, invariants,\n \t\t\t\t       after, trans);\n+      modified = true;\n \n       if (dump_file)\n \tfprintf (dump_file, \"Successfully transformed loop.\\n\");\n@@ -356,5 +353,7 @@ linear_transform_loops (struct loops *loops)\n   VEC_free (tree, heap, oldivs);\n   VEC_free (tree, heap, invariants);\n   scev_reset ();\n-  rewrite_into_loop_closed_ssa (NULL, TODO_update_ssa_full_phi);\n+\n+  if (modified)\n+    rewrite_into_loop_closed_ssa (NULL, TODO_update_ssa_full_phi);\n }"}]}