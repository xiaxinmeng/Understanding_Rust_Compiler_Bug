{"sha": "64dedd72f61a8925812675d180d274c47e6511b3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjRkZWRkNzJmNjFhODkyNTgxMjY3NWQxODBkMjc0YzQ3ZTY1MTFiMw==", "commit": {"author": {"name": "Jiong Wang", "email": "jiong.wang@arm.com", "date": "2014-07-23T16:14:20Z"}, "committer": {"name": "Marcus Shawcroft", "email": "mshawcroft@gcc.gnu.org", "date": "2014-07-23T16:14:20Z"}, "message": "[AArch64] Refactor code out into aarch64_next_callee_save\n\nFrom-SVN: r212952", "tree": {"sha": "87dac60f71e3a85a3658c872e3b57218fa7c1f95", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/87dac60f71e3a85a3658c872e3b57218fa7c1f95"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/64dedd72f61a8925812675d180d274c47e6511b3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/64dedd72f61a8925812675d180d274c47e6511b3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/64dedd72f61a8925812675d180d274c47e6511b3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/64dedd72f61a8925812675d180d274c47e6511b3/comments", "author": null, "committer": null, "parents": [{"sha": "bc5f5f369553ba7cc82a612527e0f1b2a37c4caa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc5f5f369553ba7cc82a612527e0f1b2a37c4caa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bc5f5f369553ba7cc82a612527e0f1b2a37c4caa"}], "stats": {"total": 194, "additions": 95, "deletions": 99}, "files": [{"sha": "0a3f477fd033e02b2e1010278acbbdf18997c9c2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64dedd72f61a8925812675d180d274c47e6511b3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64dedd72f61a8925812675d180d274c47e6511b3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=64dedd72f61a8925812675d180d274c47e6511b3", "patch": "@@ -1,3 +1,9 @@\n+2014-07-23  Jiong Wang  <jiong.wang@arm.com>\n+\n+\t* config/aarch64/aarch64.c (aarch64_next_callee_save): New function.\n+\t(aarch64_save_or_restore_callee_save_registers)\n+\t(aarch64_save_or_restore_fprs): Use aarch64_next_callee_save.\n+\n 2014-07-23  Jiong Wang  <jiong.wang@arm.com>\n \n \t* config/aarch64/aarch64.c"}, {"sha": "681dbe4768f41cfe64cd4c860f500c5f4e2ab714", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 89, "deletions": 99, "changes": 188, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/64dedd72f61a8925812675d180d274c47e6511b3/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/64dedd72f61a8925812675d180d274c47e6511b3/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=64dedd72f61a8925812675d180d274c47e6511b3", "patch": "@@ -1908,6 +1908,13 @@ aarch64_register_saved_on_entry (int regno)\n   return cfun->machine->frame.reg_offset[regno] >= 0;\n }\n \n+static unsigned\n+aarch64_next_callee_save (unsigned regno, unsigned limit)\n+{\n+  while (regno <= limit && !aarch64_register_saved_on_entry (regno))\n+    regno ++;\n+  return regno;\n+}\n \n static void\n aarch64_save_or_restore_fprs (HOST_WIDE_INT start_offset, bool restore)\n@@ -1918,64 +1925,56 @@ aarch64_save_or_restore_fprs (HOST_WIDE_INT start_offset, bool restore)\n   rtx (*gen_mem_ref) (enum machine_mode, rtx)\n     = frame_pointer_needed ? gen_frame_mem : gen_rtx_MEM;\n \n-  for (regno = V0_REGNUM; regno <= V31_REGNUM; regno++)\n+\n+  for (regno = aarch64_next_callee_save (V0_REGNUM, V31_REGNUM);\n+       regno <= V31_REGNUM;\n+       regno = aarch64_next_callee_save (regno + 1, V31_REGNUM))\n     {\n-      if (aarch64_register_saved_on_entry (regno))\n-\t{\n-\t  rtx reg = gen_rtx_REG (DFmode, regno);\n-\t  rtx mem;\n+      rtx reg = gen_rtx_REG (DFmode, regno);\n+      rtx mem;\n \n-\t  HOST_WIDE_INT offset = start_offset\n-\t\t\t\t + cfun->machine->frame.reg_offset[regno];\n-\t  mem = gen_mem_ref (DFmode, plus_constant (Pmode, stack_pointer_rtx,\n-\t\t\t\t\t\t    offset));\n+      HOST_WIDE_INT offset = start_offset\n+\t\t\t     + cfun->machine->frame.reg_offset[regno];\n+      mem = gen_mem_ref (DFmode, plus_constant (Pmode, stack_pointer_rtx,\n+\t\t\t\t\t\toffset));\n \n-\t  for (regno2 = regno + 1;\n-\t       regno2 <= V31_REGNUM\n-\t\t && !aarch64_register_saved_on_entry (regno2);\n-\t       regno2++)\n-\t    {\n-\t      /* Empty loop.  */\n-\t    }\n+      regno2 = aarch64_next_callee_save (regno + 1, V31_REGNUM);\n \n-\t  if (regno2 <= V31_REGNUM\n-\t      && aarch64_register_saved_on_entry (regno2))\n-\t    {\n-\t      rtx reg2 = gen_rtx_REG (DFmode, regno2);\n-\t      rtx mem2;\n-\n-\t      offset = start_offset + cfun->machine->frame.reg_offset[regno2];\n-\t      mem2 = gen_mem_ref (DFmode,\n-\t\t\t\t  plus_constant (Pmode, stack_pointer_rtx,\n-\t\t\t\t\t\t offset));\n-\t      if (restore == false)\n-\t\tinsn = emit_insn (gen_store_pairdf (mem, reg, mem2, reg2));\n-\t      else\n-\t\t{\n-\t\t  insn = emit_insn (gen_load_pairdf (reg, mem, reg2, mem2));\n-\t\t  add_reg_note (insn, REG_CFA_RESTORE, reg);\n-\t\t  add_reg_note (insn, REG_CFA_RESTORE, reg2);\n-\t\t}\n+      if (regno2 <= V31_REGNUM)\n+\t{\n+\t  rtx reg2 = gen_rtx_REG (DFmode, regno2);\n+\t  rtx mem2;\n \n-\t      /* The first part of a frame-related parallel insn is\n-\t\t always assumed to be relevant to the frame\n-\t\t calculations; subsequent parts, are only\n-\t\t frame-related if explicitly marked.  */\n-\t      RTX_FRAME_RELATED_P (XVECEXP (PATTERN (insn), 0, 1)) = 1;\n-\t      regno = regno2;\n+\t  offset = start_offset + cfun->machine->frame.reg_offset[regno2];\n+\t  mem2 = gen_mem_ref (DFmode,\n+\t\t\t      plus_constant (Pmode, stack_pointer_rtx, offset));\n+\t  if (restore == false)\n+\t    insn = emit_insn (gen_store_pairdf (mem, reg, mem2, reg2));\n+\t  else\n+\t    {\n+\t      insn = emit_insn (gen_load_pairdf (reg, mem, reg2, mem2));\n+\t      add_reg_note (insn, REG_CFA_RESTORE, reg);\n+\t      add_reg_note (insn, REG_CFA_RESTORE, reg2);\n \t    }\n+\n+\t  /* The first part of a frame-related parallel insn is\n+\t     always assumed to be relevant to the frame\n+\t     calculations; subsequent parts, are only\n+\t     frame-related if explicitly marked.  */\n+\t  RTX_FRAME_RELATED_P (XVECEXP (PATTERN (insn), 0, 1)) = 1;\n+\t  regno = regno2;\n+\t}\n+      else\n+\t{\n+\t  if (restore == false)\n+\t    insn = emit_move_insn (mem, reg);\n \t  else\n \t    {\n-\t      if (restore == false)\n-\t\tinsn = emit_move_insn (mem, reg);\n-\t      else\n-\t\t{\n-\t\t  insn = emit_move_insn (reg, mem);\n-\t\t  add_reg_note (insn, REG_CFA_RESTORE, reg);\n-\t\t}\n+\t      insn = emit_move_insn (reg, mem);\n+\t      add_reg_note (insn, REG_CFA_RESTORE, reg);\n \t    }\n-\t  RTX_FRAME_RELATED_P (insn) = 1;\n \t}\n+      RTX_FRAME_RELATED_P (insn) = 1;\n     }\n }\n \n@@ -1993,68 +1992,59 @@ aarch64_save_or_restore_callee_save_registers (HOST_WIDE_INT start_offset,\n   unsigned regno;\n   unsigned regno2;\n \n-  for (regno = R0_REGNUM; regno <= limit; regno++)\n+  for (regno = aarch64_next_callee_save (R0_REGNUM, limit);\n+       regno <= limit;\n+       regno = aarch64_next_callee_save (regno + 1, limit))\n     {\n-      if (aarch64_register_saved_on_entry (regno))\n-\t{\n-\t  rtx reg = gen_rtx_REG (DImode, regno);\n-\t  rtx mem;\n+      rtx reg = gen_rtx_REG (DImode, regno);\n+      rtx mem;\n \n-\t  HOST_WIDE_INT offset = start_offset\n-\t\t\t\t + cfun->machine->frame.reg_offset[regno];\n-\t  mem = gen_mem_ref (Pmode, plus_constant (Pmode, stack_pointer_rtx,\n-\t\t\t\t\t\t   offset));\n+      HOST_WIDE_INT offset = start_offset\n+\t\t\t     + cfun->machine->frame.reg_offset[regno];\n+      mem = gen_mem_ref (Pmode, plus_constant (Pmode, stack_pointer_rtx,\n+\t\t\t\t\t       offset));\n \n-\t  for (regno2 = regno + 1;\n-\t       regno2 <= limit\n-\t\t && !aarch64_register_saved_on_entry (regno2);\n-\t       regno2++)\n-\t    {\n-\t      /* Empty loop.  */\n-\t    }\n+      regno2 = aarch64_next_callee_save (regno + 1, limit);\n \n-\t  if (regno2 <= limit\n-\t      && aarch64_register_saved_on_entry (regno2)\n-\t      && ((cfun->machine->frame.reg_offset[regno] + UNITS_PER_WORD)\n-\t\t  == cfun->machine->frame.reg_offset[regno2]))\n-\t    {\n-\t      rtx reg2 = gen_rtx_REG (DImode, regno2);\n-\t      rtx mem2;\n-\n-\t      offset = start_offset + cfun->machine->frame.reg_offset[regno2];\n-\t      mem2 = gen_mem_ref (Pmode,\n-\t\t\t\t  plus_constant (Pmode, stack_pointer_rtx,\n-\t\t\t\t\t\t offset));\n-\t      if (restore == false)\n-\t\t  insn = emit_insn (gen_store_pairdi (mem, reg, mem2, reg2));\n-\t      else\n-\t\t{\n-\t\t  insn = emit_insn (gen_load_pairdi (reg, mem, reg2, mem2));\n-\t\t  add_reg_note (insn, REG_CFA_RESTORE, reg);\n-\t\t  add_reg_note (insn, REG_CFA_RESTORE, reg2);\n-\t\t}\n+      if (regno2 <= limit\n+\t  && ((cfun->machine->frame.reg_offset[regno] + UNITS_PER_WORD)\n+\t      == cfun->machine->frame.reg_offset[regno2]))\n+\n+\t{\n+\t  rtx reg2 = gen_rtx_REG (DImode, regno2);\n+\t  rtx mem2;\n \n-\t      /* The first part of a frame-related parallel insn is\n-\t\t always assumed to be relevant to the frame\n-\t\t calculations; subsequent parts, are only\n-\t\t frame-related if explicitly marked.  */\n-\t      RTX_FRAME_RELATED_P (XVECEXP (PATTERN (insn), 0, 1)) = 1;\n-\t      regno = regno2;\n+\t  offset = start_offset + cfun->machine->frame.reg_offset[regno2];\n+\t  mem2 = gen_mem_ref (Pmode,\n+\t\t\t      plus_constant (Pmode, stack_pointer_rtx, offset));\n+\t  if (restore == false)\n+\t    insn = emit_insn (gen_store_pairdi (mem, reg, mem2, reg2));\n+\t  else\n+\t    {\n+\t      insn = emit_insn (gen_load_pairdi (reg, mem, reg2, mem2));\n+\t      add_reg_note (insn, REG_CFA_RESTORE, reg);\n+\t      add_reg_note (insn, REG_CFA_RESTORE, reg2);\n \t    }\n+\n+\t  /* The first part of a frame-related parallel insn is\n+\t     always assumed to be relevant to the frame\n+\t     calculations; subsequent parts, are only\n+\t     frame-related if explicitly marked.  */\n+\t  RTX_FRAME_RELATED_P (XVECEXP (PATTERN (insn), 0, 1)) = 1;\n+\t  regno = regno2;\n+\t}\n+      else\n+\t{\n+\t  if (restore == false)\n+\t    insn = emit_move_insn (mem, reg);\n \t  else\n \t    {\n-\t      if (restore == false)\n-\t\tinsn = emit_move_insn (mem, reg);\n-\t      else\n-\t\t{\n-\t\t  insn = emit_move_insn (reg, mem);\n-\t\t  add_reg_note (insn, REG_CFA_RESTORE, reg);\n-\t\t}\n+\t      insn = emit_move_insn (reg, mem);\n+\t      add_reg_note (insn, REG_CFA_RESTORE, reg);\n \t    }\n-\t  RTX_FRAME_RELATED_P (insn) = 1;\n \t}\n+      RTX_FRAME_RELATED_P (insn) = 1;\n     }\n-\n   aarch64_save_or_restore_fprs (start_offset, restore);\n }\n "}]}