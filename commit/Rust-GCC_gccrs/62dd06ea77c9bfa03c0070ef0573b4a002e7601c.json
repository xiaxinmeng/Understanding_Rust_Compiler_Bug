{"sha": "62dd06ea77c9bfa03c0070ef0573b4a002e7601c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjJkZDA2ZWE3N2M5YmZhMDNjMDA3MGVmMDU3M2I0YTAwMmU3NjAxYw==", "commit": {"author": {"name": "Richard Earnshaw", "email": "erich@gnu.org", "date": "1996-05-04T16:13:28Z"}, "committer": {"name": "Richard Earnshaw", "email": "erich@gnu.org", "date": "1996-05-04T16:13:28Z"}, "message": "(ASM_OUTPUT_MI_THUNK): Moved here from aout.h.\n\n(ASM_OUTPUT_MI_THUNK): Moved here from aout.h.  Rewrite to be\nindependent of the selected assembler, and to use optimal number of\ninstructions.\n(target_cpu_name): Delete.\n(TARGET_SWITCHES): Delete \"be\" and \"le\".\n(TARGET_OPTIONS): Delete \"cpu-\", add \"tune=\".\n(struct arm_cpu_select): New struct.\n(PROCESSOR_DEFAULT, TARGET_CPU_DEFAULT): Define.\n(EXTRA_CC_MODES, EXTRA_CC_NAMES): Add CC_Cmode.\n(CANONICALIZE_COMPARISON): Define.\n\nFrom-SVN: r11919", "tree": {"sha": "f16b3dbd5cff9dba8ac9434aba645b3614c58e95", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f16b3dbd5cff9dba8ac9434aba645b3614c58e95"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/62dd06ea77c9bfa03c0070ef0573b4a002e7601c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62dd06ea77c9bfa03c0070ef0573b4a002e7601c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/62dd06ea77c9bfa03c0070ef0573b4a002e7601c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62dd06ea77c9bfa03c0070ef0573b4a002e7601c/comments", "author": null, "committer": null, "parents": [{"sha": "07d4d67db4846a081c61afa56d8ccdfda486a47e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07d4d67db4846a081c61afa56d8ccdfda486a47e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/07d4d67db4846a081c61afa56d8ccdfda486a47e"}], "stats": {"total": 79, "additions": 68, "deletions": 11}, "files": [{"sha": "68e6a15ef13d8e02ea8447cdd2a5f8382e1fe294", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 68, "deletions": 11, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62dd06ea77c9bfa03c0070ef0573b4a002e7601c/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62dd06ea77c9bfa03c0070ef0573b4a002e7601c/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=62dd06ea77c9bfa03c0070ef0573b4a002e7601c", "patch": "@@ -96,7 +96,6 @@ extern int frame_pointer_needed;\n extern int target_flags;\n \n /* These two are used by TARGET_OPTIONS, they are parsed in OVERRIDE_OPTIONS */\n-extern char *target_cpu_name;\n extern char *target_fpe_name;\n \n /* Nonzero if the function prologue (and epilogue) should obey\n@@ -204,24 +203,40 @@ extern char *target_fpe_name;\n   {\"soft-float\",\t\tARM_FLAG_SOFT_FLOAT},\t\\\n   {\"hard-float\",\t       -ARM_FLAG_SOFT_FLOAT},\t\\\n   {\"big-endian\",\t\tARM_FLAG_BIG_END},\t\\\n-  {\"be\",\t\t\tARM_FLAG_BIG_END},\t\\\n   {\"little-endian\",\t       -ARM_FLAG_BIG_END},\t\\\n-  {\"le\",\t\t       -ARM_FLAG_BIG_END},\t\\\n   {\"thumb-interwork\",\t\tARM_FLAG_THUMB},\t\\\n   {\"no-thumb-interwork\",       -ARM_FLAG_THUMB},\t\\\n   {\"words-little-endian\",       ARM_FLAG_LITTLE_WORDS},\t\\\n   SUBTARGET_SWITCHES\t\t\t\t\t\\\n   {\"\",\t\t\t\tTARGET_DEFAULT }\t\\\n }\n \n-#define TARGET_OPTIONS\t\t\t\t\\\n-{\t\t\t\t\t\t\\\n-  {\"cpu-\", &target_cpu_name},\t\t\t\\\n-  {\"cpu=\", &target_cpu_name},\t\t\t\\\n-  {\"fpe-\", &target_fpe_name},\t\t\t\\\n-  {\"fpe=\", &target_fpe_name}\t\t\t\\\n+#define TARGET_OPTIONS\t\t\t\\\n+{\t\t\t\t\t\\\n+  {\"cpu=\",  &arm_select[1].string},\t\\\n+  {\"tune=\", &arm_select[2].string},\t\\\n+  {\"fpe=\",  &target_fpe_name}\t\t\\\n }\n \n+/* arm_select[0] is reserved for the default cpu.  */\n+struct arm_cpu_select\n+{\n+  char *string;\n+  char *name;\n+  int set_tune_p;\n+  int set_arch_p;\n+};\n+\n+extern struct arm_cpu_select arm_select[];\n+\n+#ifndef PROCESSOR_DEFAULT\n+#define PROCESSOR_DEFAULT PROCESSOR_ARM2\n+#endif\n+\n+#ifndef TARGET_CPU_DEFAULT\n+#define TARGET_CPU_DEFAULT ((char *) 0)\n+#endif\n+\n /* Which processor we are running on.  */\n enum processor_type \n {\n@@ -1463,17 +1478,30 @@ do\t\t\t\t\t\t\t\t\t\\\n #define EXTRA_CC_MODES CC_NOOVmode, CC_Zmode, CC_SWPmode, \\\n   CCFPmode, CCFPEmode, CC_DNEmode, CC_DEQmode, CC_DLEmode, \\\n   CC_DLTmode, CC_DGEmode, CC_DGTmode, CC_DLEUmode, CC_DLTUmode, \\\n-  CC_DGEUmode, CC_DGTUmode\n+  CC_DGEUmode, CC_DGTUmode, CC_Cmode\n \n #define EXTRA_CC_NAMES \"CC_NOOV\", \"CC_Z\", \"CC_SWP\", \"CCFP\", \"CCFPE\", \\\n   \"CC_DNE\", \"CC_DEQ\", \"CC_DLE\", \"CC_DLT\", \"CC_DGE\", \"CC_DGT\", \"CC_DLEU\", \\\n-  \"CC_DLTU\", \"CC_DGEU\", \"CC_DGTU\"\n+  \"CC_DLTU\", \"CC_DGEU\", \"CC_DGTU\", \"CC_C\"\n \n enum machine_mode arm_select_cc_mode ();\n #define SELECT_CC_MODE(OP,X,Y)  arm_select_cc_mode ((OP), (X), (Y))\n \n #define REVERSIBLE_CC_MODE(MODE) ((MODE) != CCFPEmode)\n \n+enum rtx_code arm_canonicalize_comparison ();\n+#define CANONICALIZE_COMPARISON(CODE,OP0,OP1)\t\t\t\\\n+do\t\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\\\n+  if (GET_CODE (OP1) == CONST_INT\t\t\t\t\\\n+      && ! (const_ok_for_arm (INTVAL (OP1))\t\t\t\\\n+\t    || (const_ok_for_arm (- INTVAL (OP1)))))\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      rtx const_op = OP1;\t\t\t\t\t\\\n+      CODE = arm_canonicalize_comparison ((CODE), &const_op);\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+} while (0)\n+\n #define STORE_FLAG_VALUE 1\n \n /* Define the information needed to generate branch insns.  This is\n@@ -1658,3 +1686,32 @@ extern int arm_compare_fp;\n     }\t\t\t\t\t\t\t\t\t\\\n   else output_addr_const(STREAM, X);\t\t\t\t\t\\\n }\n+\n+/* Output code to add DELTA to the first argument, and then jump to FUNCTION.\n+   Used for C++ multiple inheritance.  */\n+#define ASM_OUTPUT_MI_THUNK(FILE, THUNK_FNDECL, DELTA, FUNCTION)\t\\\n+do {\t\t\t\t\t\t\t\t\t\\\n+  int mi_delta = (DELTA);\t\t\t\t\t\t\\\n+  char *mi_op = mi_delta < 0 ? \"sub\" : \"add\";\t\t\t\t\\\n+  int shift = 0;\t\t\t\t\t\t\t\\\n+  if (mi_delta < 0) mi_delta = -mi_delta;\t\t\t\t\\\n+  while (mi_delta != 0)\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      if (mi_delta & (3 << shift) == 0)\t\t\t\t\t\\\n+\tshift += 2;\t\t\t\t\t\t\t\\\n+      else\t\t\t\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  fprintf (FILE, \"\\t%s\\t%s%s, %s%s, #%d\\n\",\t\t\t\\\n+\t\t   mi_op, REGISTER_PREFIX, reg_names[0],\t\t\\\n+\t\t   REGISTER_PREFIX, reg_names[0],\t\t\t\\\n+\t\t   mi_delta & (0xff << shift));\t\t\t\t\\\n+\t  arm_increase_location (4);\t\t\t\t\t\\\n+\t  mi_delta &= ~(0xff << shift);\t\t\t\t\t\\\n+\t  shift += 8;\t\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  fprintf (FILE, \"\\tldr\\t%spc, [%spc, #-4]\\n\", REGISTER_PREFIX,\t\t\\\n+\t   REGISTER_PREFIX);\t\t\t\t\t\t\\\n+  arm_increase_location (4);\t\t\t\t\t\t\\\n+  ASM_OUTPUT_INT (FILE, XEXP (DECL_RTL (FUNCTION), 0));\t\t\t\\\n+} while (0)"}]}