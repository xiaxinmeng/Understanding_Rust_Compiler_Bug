{"sha": "bede2adc26d83608df2c21d82d1ff0246baf1456", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmVkZTJhZGMyNmQ4MzYwOGRmMmMyMWQ4MmQxZmYwMjQ2YmFmMTQ1Ng==", "commit": {"author": {"name": "Nicola Pero", "email": "nicola.pero@meta-innovation.com", "date": "2010-11-04T20:59:47Z"}, "committer": {"name": "Nicola Pero", "email": "nicola@gcc.gnu.org", "date": "2010-11-04T20:59:47Z"}, "message": "In gcc/: 2010-11-04 Nicola Pero <nicola.pero@meta-innovation.com>\n\nIn gcc/:\n2010-11-04  Nicola Pero  <nicola.pero@meta-innovation.com>\n\n        Fixed using the Objective-C 2.0 dot-syntax with class names.\n        * c-parser.c (c_parser_next_token_starts_declspecs): In\n        Objective-C, detect Objective-C 2.0 dot-syntax with a class name.\n        (c_parser_next_token_starts_declaration): Same.\n        (c_parser_postfix_expression): Parse the Objective-C 2.0\n        dot-syntax with a class name.\n\nIn gcc/cp/:\n2010-11-04  Nicola Pero  <nicola.pero@meta-innovation.com>\n\n        Fixed using the Objective-C 2.0 dot-syntax with class names.\n        * parser.c (cp_parser_primary_expression): Recognize Objective-C\n        2.0 dot-syntax with class names and process it.\n        (cp_parser_nonclass_name): Recognize Objective-C 2.0 dot-syntax\n        with class names.\n        (cp_parser_class_name): Same change.\n        (cp_parser_simple_type_specifier): Tidied comments.\n\nIn gcc/c-family/:\n2010-11-04  Nicola Pero  <nicola.pero@meta-innovation.com>\n\n        Fixed using the Objective-C 2.0 dot-syntax with class names.\n        * c-common.h (objc_build_class_component_ref): New.\n        * stub-objc.c (objc_build_class_component_ref): New.\n\nIn gcc/objc/:\n2010-11-04  Nicola Pero  <nicola.pero@meta-innovation.com>\n\n        Fixed using the Objective-C 2.0 dot-syntax with class names.\n        * objc-act.c (objc_build_class_component_ref): New.\n\nIn gcc/testsuite/:\n2010-11-04  Nicola Pero  <nicola.pero@meta-innovation.com>\n\n        Fixed using the Objective-C 2.0 dot-syntax with class names.\n        * objc.dg/property/dotsyntax-3.m: New.\n        * objc.dg/property/dotsyntax-4.m: New.\n        * obj-c++.dg/property/dotsyntax-3.mm: New.\n        * obj-c++.dg/property/dotsyntax-4.mm: New.\n\n        * objc.dg/fobjc-std-1.m: Added test for warnings when the\n        Objective-C 2.0 dot-syntax is used with class names.\n        * obj-c++.dg/fobjc-std-1.mm: Same change.\n\nFrom-SVN: r166333", "tree": {"sha": "2b4508d7ce478977e3fa9afe261f77ad36ad4f6d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2b4508d7ce478977e3fa9afe261f77ad36ad4f6d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bede2adc26d83608df2c21d82d1ff0246baf1456", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bede2adc26d83608df2c21d82d1ff0246baf1456", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bede2adc26d83608df2c21d82d1ff0246baf1456", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bede2adc26d83608df2c21d82d1ff0246baf1456/comments", "author": {"login": "Nico-31415", "id": 94470564, "node_id": "U_kgDOBaGBpA", "avatar_url": "https://avatars.githubusercontent.com/u/94470564?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nico-31415", "html_url": "https://github.com/Nico-31415", "followers_url": "https://api.github.com/users/Nico-31415/followers", "following_url": "https://api.github.com/users/Nico-31415/following{/other_user}", "gists_url": "https://api.github.com/users/Nico-31415/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nico-31415/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nico-31415/subscriptions", "organizations_url": "https://api.github.com/users/Nico-31415/orgs", "repos_url": "https://api.github.com/users/Nico-31415/repos", "events_url": "https://api.github.com/users/Nico-31415/events{/privacy}", "received_events_url": "https://api.github.com/users/Nico-31415/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2b78d0f15208ab3a0377d3ffac1a0325e202a95a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b78d0f15208ab3a0377d3ffac1a0325e202a95a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2b78d0f15208ab3a0377d3ffac1a0325e202a95a"}], "stats": {"total": 518, "additions": 499, "deletions": 19}, "files": [{"sha": "d89ecd1dbe2c62a039b74cab87ce1d19a0acc23a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bede2adc26d83608df2c21d82d1ff0246baf1456/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bede2adc26d83608df2c21d82d1ff0246baf1456/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bede2adc26d83608df2c21d82d1ff0246baf1456", "patch": "@@ -1,3 +1,12 @@\n+2010-11-04  Nicola Pero  <nicola.pero@meta-innovation.com>\n+\n+\tFixed using the Objective-C 2.0 dot-syntax with class names.\n+\t* c-parser.c (c_parser_next_token_starts_declspecs): In\n+\tObjective-C, detect Objective-C 2.0 dot-syntax with a class name.\n+\t(c_parser_next_token_starts_declaration): Same.\n+\t(c_parser_postfix_expression): Parse the Objective-C 2.0\n+\tdot-syntax with a class name.\n+\n 2010-11-04  Pat Haugen  <pthaugen@us.ibm.com>\n \n \t* final.c (compute_alignments): Compute/free loop info all the time."}, {"sha": "c613ab36b8b484ce9286661ef84ed1a4f2999e1b", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bede2adc26d83608df2c21d82d1ff0246baf1456/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bede2adc26d83608df2c21d82d1ff0246baf1456/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=bede2adc26d83608df2c21d82d1ff0246baf1456", "patch": "@@ -1,3 +1,9 @@\n+2010-11-04  Nicola Pero  <nicola.pero@meta-innovation.com>\n+\n+\tFixed using the Objective-C 2.0 dot-syntax with class names.\t\n+\t* c-common.h (objc_build_class_component_ref): New.\n+\t* stub-objc.c (objc_build_class_component_ref): New.\n+\n 2010-11-03  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \t* c.opt (Wproperty-assign-default): New option."}, {"sha": "13d9227ddca8580055487ece619df992b00c099a", "filename": "gcc/c-family/c-common.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bede2adc26d83608df2c21d82d1ff0246baf1456/gcc%2Fc-family%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bede2adc26d83608df2c21d82d1ff0246baf1456/gcc%2Fc-family%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.h?ref=bede2adc26d83608df2c21d82d1ff0246baf1456", "patch": "@@ -1037,6 +1037,7 @@ extern bool  objc_method_decl (enum tree_code);\n extern void objc_add_property_declaration (location_t, tree, bool, bool, bool, \n \t\t\t\t\t   bool, bool, bool, tree, tree);\n extern tree objc_maybe_build_component_ref (tree, tree);\n+extern tree objc_build_class_component_ref (tree, tree);\n extern tree objc_maybe_build_modify_expr (tree, tree);\n extern void objc_add_synthesize_declaration (location_t, tree);\n extern void objc_add_dynamic_declaration (location_t, tree);"}, {"sha": "1f3b854f0c070dd2933cb7886e17767875e6451e", "filename": "gcc/c-family/stub-objc.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bede2adc26d83608df2c21d82d1ff0246baf1456/gcc%2Fc-family%2Fstub-objc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bede2adc26d83608df2c21d82d1ff0246baf1456/gcc%2Fc-family%2Fstub-objc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fstub-objc.c?ref=bede2adc26d83608df2c21d82d1ff0246baf1456", "patch": "@@ -349,6 +349,12 @@ objc_maybe_build_component_ref (tree ARG_UNUSED (datum), tree ARG_UNUSED (compon\n   return 0;\n }\n \n+tree\n+objc_build_class_component_ref (tree ARG_UNUSED (datum), tree ARG_UNUSED (component))\n+{\n+  return 0;\n+}\n+\n tree\n objc_maybe_build_modify_expr (tree ARG_UNUSED (lhs), tree ARG_UNUSED (rhs))\n {"}, {"sha": "78ccdd4ebfc24b19ee0cf5185c77dab5fb859faa", "filename": "gcc/c-parser.c", "status": "modified", "additions": 59, "deletions": 9, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bede2adc26d83608df2c21d82d1ff0246baf1456/gcc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bede2adc26d83608df2c21d82d1ff0246baf1456/gcc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parser.c?ref=bede2adc26d83608df2c21d82d1ff0246baf1456", "patch": "@@ -598,6 +598,19 @@ static inline bool\n c_parser_next_token_starts_declspecs (c_parser *parser)\n {\n   c_token *token = c_parser_peek_token (parser);\n+\n+  /* In Objective-C, a classname normally starts a declspecs unless it\n+     is immediately followed by a dot.  In that case, it is the\n+     Objective-C 2.0 \"dot-syntax\" for class objects, ie, calls the\n+     setter/getter on the class.  c_token_starts_declspecs() can't\n+     differentiate between the two cases because it only checks the\n+     current token, so we have a special check here.  */\n+  if (c_dialect_objc () \n+      && token->type == CPP_NAME\n+      && token->id_kind == C_ID_CLASSNAME \n+      && c_parser_peek_2nd_token (parser)->type == CPP_DOT)\n+    return false;\n+\n   return c_token_starts_declspecs (token);\n }\n \n@@ -607,6 +620,14 @@ static inline bool\n c_parser_next_token_starts_declaration (c_parser *parser)\n {\n   c_token *token = c_parser_peek_token (parser);\n+\n+  /* Same as above.  */\n+  if (c_dialect_objc () \n+      && token->type == CPP_NAME\n+      && token->id_kind == C_ID_CLASSNAME \n+      && c_parser_peek_2nd_token (parser)->type == CPP_DOT)\n+    return false;\n+\n   return c_token_starts_declaration (token);\n }\n \n@@ -5821,6 +5842,7 @@ c_parser_alignof_expression (c_parser *parser)\n      @protocol ( identifier )\n      @encode ( type-name )\n      objc-string-literal\n+     Classname . identifier\n */\n \n static struct c_expr\n@@ -5867,20 +5889,48 @@ c_parser_postfix_expression (c_parser *parser)\n       c_parser_consume_token (parser);\n       break;\n     case CPP_NAME:\n-      if (c_parser_peek_token (parser)->id_kind != C_ID_ID)\n+      switch (c_parser_peek_token (parser)->id_kind)\n \t{\n+\tcase C_ID_ID:\n+\t  {\n+\t    tree id = c_parser_peek_token (parser)->value;\n+\t    c_parser_consume_token (parser);\n+\t    expr.value = build_external_ref (loc, id,\n+\t\t\t\t\t     (c_parser_peek_token (parser)->type\n+\t\t\t\t\t      == CPP_OPEN_PAREN),\n+\t\t\t\t\t     &expr.original_type);\n+\t    break;\n+\t  }\n+\tcase C_ID_CLASSNAME:\n+\t  {\n+\t    /* Here we parse the Objective-C 2.0 Class.name dot\n+\t       syntax.  */\n+\t    tree class_name = c_parser_peek_token (parser)->value;\n+\t    tree component;\n+\t    c_parser_consume_token (parser);\n+\t    gcc_assert (c_dialect_objc ());\n+\t    if (!c_parser_require (parser, CPP_DOT, \"expected %<.%>\"))\n+\t      {\n+\t\texpr.value = error_mark_node;\n+\t\tbreak;\n+\t      }\n+\t    if (c_parser_next_token_is_not (parser, CPP_NAME))\n+\t      {\n+\t\tc_parser_error (parser, \"expected identifier\");\n+\t\texpr.value = error_mark_node;\n+\t\tbreak;\n+\t      }\n+\t    component = c_parser_peek_token (parser)->value;\n+\t    c_parser_consume_token (parser);\n+\t    expr.value = objc_build_class_component_ref (class_name, \n+\t\t\t\t\t\t\t component);\n+\t    break;\n+\t  }\n+\tdefault:\n \t  c_parser_error (parser, \"expected expression\");\n \t  expr.value = error_mark_node;\n \t  break;\n \t}\n-      {\n-\ttree id = c_parser_peek_token (parser)->value;\n-\tc_parser_consume_token (parser);\n-\texpr.value = build_external_ref (loc, id,\n-\t\t\t\t\t (c_parser_peek_token (parser)->type\n-\t\t\t\t\t  == CPP_OPEN_PAREN),\n-\t\t\t\t\t &expr.original_type);\n-      }\n       break;\n     case CPP_OPEN_PAREN:\n       /* A parenthesized expression, statement expression or compound"}, {"sha": "b1c9e01e7b0b1ca965a1ad90a268f9e7967d7efb", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bede2adc26d83608df2c21d82d1ff0246baf1456/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bede2adc26d83608df2c21d82d1ff0246baf1456/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=bede2adc26d83608df2c21d82d1ff0246baf1456", "patch": "@@ -1,3 +1,13 @@\n+2010-11-04  Nicola Pero  <nicola.pero@meta-innovation.com>\n+\n+\tFixed using the Objective-C 2.0 dot-syntax with class names.\t\n+\t* parser.c (cp_parser_primary_expression): Recognize Objective-C\n+\t2.0 dot-syntax with class names and process it.\n+\t(cp_parser_nonclass_name): Recognize Objective-C 2.0 dot-syntax\n+\twith class names.\n+\t(cp_parser_class_name): Same change.\n+\t(cp_parser_simple_type_specifier): Tidied comments.\n+\t\n 2010-11-04  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/46298"}, {"sha": "6302864fd978599e553cfc2258471d463ff5e0d3", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 41, "deletions": 9, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bede2adc26d83608df2c21d82d1ff0246baf1456/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bede2adc26d83608df2c21d82d1ff0246baf1456/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=bede2adc26d83608df2c21d82d1ff0246baf1456", "patch": "@@ -3908,6 +3908,22 @@ cp_parser_primary_expression (cp_parser *parser,\n \t    if (ambiguous_decls)\n \t      return error_mark_node;\n \n+\t    /* In Objective-C++, we may have an Objective-C 2.0\n+\t       dot-syntax for classes here.  */\n+\t    if (c_dialect_objc ()\n+\t\t&& cp_lexer_peek_token (parser->lexer)->type == CPP_DOT\n+\t\t&& TREE_CODE (decl) == TYPE_DECL\n+\t\t&& objc_is_class_name (decl))\n+\t      {\n+\t\ttree component;\n+\t\tcp_lexer_consume_token (parser->lexer);\n+\t\tcomponent = cp_parser_identifier (parser);\n+\t\tif (component == error_mark_node)\n+\t\t  return error_mark_node;\n+\n+\t\treturn objc_build_class_component_ref (id_expression, component);\n+\t      }\n+\n \t    /* In Objective-C++, an instance variable (ivar) may be preferred\n \t       to whatever cp_parser_lookup_name() found.  */\n \t    decl = objc_lookup_ivar (decl, id_expression);\n@@ -12786,14 +12802,14 @@ cp_parser_simple_type_specifier (cp_parser* parser,\n       return error_mark_node;\n     }\n \n-  /* There is no valid C++ program where a non-template type is\n-     followed by a \"<\".  That usually indicates that the user thought\n-     that the type was a template.  */\n   if (type && type != error_mark_node)\n     {\n-      /* As a last-ditch effort, see if TYPE is an Objective-C type.\n-\t If it is, then the '<'...'>' enclose protocol names rather than\n-\t template arguments, and so everything is fine.  */\n+      /* See if TYPE is an Objective-C type, and if so, parse and\n+\t accept any protocol references following it.  Do this before\n+\t the cp_parser_check_for_invalid_template_id() call, because\n+\t Objective-C types can be followed by '<...>' which would\n+\t enclose protocol names rather than template arguments, and so\n+\t everything is fine.  */\n       if (c_dialect_objc () && !parser->scope\n \t  && (objc_is_id (type) || objc_is_class_name (type)))\n \t{\n@@ -12808,6 +12824,9 @@ cp_parser_simple_type_specifier (cp_parser* parser,\n \t  return qual_type;\n \t}\n \n+      /* There is no valid C++ program where a non-template type is\n+\t followed by a \"<\".  That usually indicates that the user\n+\t thought that the type was a template.  */\n       cp_parser_check_for_invalid_template_id (parser, TREE_TYPE (type),\n \t\t\t\t\t       token->location);\n     }\n@@ -12888,9 +12907,17 @@ cp_parser_nonclass_name (cp_parser* parser)\n       if (type)\n \ttype_decl = TYPE_NAME (type);\n     }\n-  \n+\n   /* Issue an error if we did not find a type-name.  */\n-  if (TREE_CODE (type_decl) != TYPE_DECL)\n+  if (TREE_CODE (type_decl) != TYPE_DECL\n+      /* In Objective-C, we have the complication that class names are\n+\t normally type names and start declarations (eg, the\n+\t \"NSObject\" in \"NSObject *object;\"), but can be used in an\n+\t Objective-C 2.0 dot-syntax (as in \"NSObject.version\") which\n+\t is an expression.  So, a classname followed by a dot is not a\n+\t valid type-name.  */\n+      || (objc_is_class_name (TREE_TYPE (type_decl))\n+\t  && cp_lexer_peek_token (parser->lexer)->type == CPP_DOT))\n     {\n       if (!cp_parser_simulate_error (parser))\n \tcp_parser_name_lookup_error (parser, identifier, type_decl,\n@@ -16714,7 +16741,12 @@ cp_parser_class_name (cp_parser *parser,\n     }\n   else if (TREE_CODE (decl) != TYPE_DECL\n \t   || TREE_TYPE (decl) == error_mark_node\n-\t   || !MAYBE_CLASS_TYPE_P (TREE_TYPE (decl)))\n+\t   || !MAYBE_CLASS_TYPE_P (TREE_TYPE (decl))\n+\t   /* In Objective-C 2.0, a classname followed by '.' starts a\n+\t      dot-syntax expression, and it's not a type-name.  */\n+\t   || (c_dialect_objc ()\n+\t       && cp_lexer_peek_token (parser->lexer)->type == CPP_DOT \n+\t       && objc_is_class_name (decl)))\n     decl = error_mark_node;\n \n   if (decl == error_mark_node)"}, {"sha": "dc4cffd1e53180ff255311530442fe7db80625a9", "filename": "gcc/objc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bede2adc26d83608df2c21d82d1ff0246baf1456/gcc%2Fobjc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bede2adc26d83608df2c21d82d1ff0246baf1456/gcc%2Fobjc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2FChangeLog?ref=bede2adc26d83608df2c21d82d1ff0246baf1456", "patch": "@@ -1,3 +1,8 @@\n+2010-11-04  Nicola Pero  <nicola.pero@meta-innovation.com>\n+\n+\tFixed using the Objective-C 2.0 dot-syntax with class names.\t\n+\t* objc-act.c (objc_build_class_component_ref): New.\n+\n 2010-11-03  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \t* objc-act.c (objc_add_dynamic_declaration): Allow @dynamic in a"}, {"sha": "aa4c2e392b8545fc8984b59e9522c627953725c5", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bede2adc26d83608df2c21d82d1ff0246baf1456/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bede2adc26d83608df2c21d82d1ff0246baf1456/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=bede2adc26d83608df2c21d82d1ff0246baf1456", "patch": "@@ -1301,6 +1301,79 @@ objc_maybe_build_component_ref (tree object, tree property_ident)\n   return NULL_TREE;\n }\n \n+/* This hook routine is invoked by the parser when an expression such\n+   as 'xxx.yyy' is parsed, and 'xxx' is a class name.  This is the\n+   Objective-C 2.0 dot-syntax applied to classes, so we need to\n+   convert it into a setter/getter call on the class.  */\n+tree\n+objc_build_class_component_ref (tree class_name, tree property_ident)\n+{\n+  tree x = NULL_TREE;\n+  tree object, rtype;\n+  \n+  if (flag_objc1_only)\n+    error_at (input_location, \"the dot syntax is not available in Objective-C 1.0\");\n+  \n+  if (class_name == NULL_TREE || class_name == error_mark_node\n+      || TREE_CODE (class_name) != IDENTIFIER_NODE)\n+    return error_mark_node;\n+  \n+  if (property_ident == NULL_TREE || property_ident == error_mark_node\n+      || TREE_CODE (property_ident) != IDENTIFIER_NODE)\n+    return NULL_TREE;\n+  \n+  object = objc_get_class_reference (class_name);\n+  if (!object)\n+    {\n+      /* We know that 'class_name' is an Objective-C class name as the\n+\t parser won't call this function if it is not.  This is only a\n+\t double-check for safety.  */\n+      error_at (input_location, \"could not find class %qE\", class_name); \n+      return error_mark_node;\n+    }\n+\n+  rtype = lookup_interface (class_name);\n+  if (!rtype)\n+    {\n+      /* Again, this should never happen, but we do check.  */\n+      error_at (input_location, \"could not find interface for class %qE\", class_name); \n+      return error_mark_node;\n+    }\n+\n+  x = maybe_make_artificial_property_decl (rtype, NULL_TREE,\n+\t\t\t\t\t   property_ident,\n+\t\t\t\t\t   true);\n+  \n+  if (x)\n+    {\n+      tree expression;\n+\n+      if (TREE_DEPRECATED (x))\n+\twarn_deprecated_use (x, NULL_TREE);\n+\n+      expression = build2 (PROPERTY_REF, TREE_TYPE(x), object, x);\n+      SET_EXPR_LOCATION (expression, input_location);\n+      TREE_SIDE_EFFECTS (expression) = 1;\n+      /* See above for why we do this.  */\n+      if (!PROPERTY_HAS_NO_GETTER (x))\n+\tobjc_finish_message_expr (object,\n+\t\t\t\t  PROPERTY_GETTER_NAME (x),\n+\t\t\t\t  NULL_TREE);\n+      \n+      return expression;\n+    }\n+  else\n+    {\n+      error_at (input_location, \"could not find setter/getter for %qE in class %qE\", \n+\t\tproperty_ident,\tclass_name); \n+      return error_mark_node;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+\n+\n /* This is used because we don't want to expose PROPERTY_REF to the\n    C/C++ frontends.  Maybe we should!  */\n bool"}, {"sha": "3b1dcab040546653fbfd81adce037e07147fc825", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bede2adc26d83608df2c21d82d1ff0246baf1456/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bede2adc26d83608df2c21d82d1ff0246baf1456/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=bede2adc26d83608df2c21d82d1ff0246baf1456", "patch": "@@ -1,3 +1,15 @@\n+2010-11-04  Nicola Pero  <nicola.pero@meta-innovation.com>\n+\n+\tFixed using the Objective-C 2.0 dot-syntax with class names.\n+\t* objc.dg/property/dotsyntax-3.m: New.\n+\t* objc.dg/property/dotsyntax-4.m: New.\n+\t* obj-c++.dg/property/dotsyntax-3.mm: New.\n+\t* obj-c++.dg/property/dotsyntax-4.mm: New.\t\n+\n+\t* objc.dg/fobjc-std-1.m: Added test for warnings when the\n+\tObjective-C 2.0 dot-syntax is used with class names.\n+\t* obj-c++.dg/fobjc-std-1.mm: Same change.\n+\t\n 2010-11-04  Pat Haugen  <pthaugen@us.ibm.com>\n \n \t* gcc.target/powerpc/loop_align.c: New."}, {"sha": "b6ae044df3d794e145847bf6c8236e30c8015b45", "filename": "gcc/testsuite/obj-c++.dg/fobjc-std-1.mm", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bede2adc26d83608df2c21d82d1ff0246baf1456/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Ffobjc-std-1.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bede2adc26d83608df2c21d82d1ff0246baf1456/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Ffobjc-std-1.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Ffobjc-std-1.mm?ref=bede2adc26d83608df2c21d82d1ff0246baf1456", "patch": "@@ -13,6 +13,7 @@ @interface MyRootClass /* { dg-error \"class attributes are not available in Obje\n   int b;\n }\n + (id) alloc __attribute__ ((deprecated)); /* { dg-error \"not available in Objective.C 1.0\" } */\n++ (id) name;\n - (id) init;\n - (id) testMe: (id) __attribute__((unused)) argument; /* { dg-error \"not available in Objective.C 1.0\" } */\n @property (nonatomic) int a; /* { dg-error \"not available in Objective.C 1.0\" } */\n@@ -21,6 +22,7 @@ - (id) testMe: (id) __attribute__((unused)) argument; /* { dg-error \"not availab\n \n @implementation MyRootClass\n + (id) alloc { return self; }\n++ (id) name { return self; }\n - (id) init  { return self; }\n - (id) testMe: (id) __attribute__((unused)) argument { return self; } /* { dg-error \"not available in Objective.C 1.0\" } */\n @synthesize a; /* { dg-error \"not available in Objective.C 1.0\" } */\n@@ -52,4 +54,9 @@ int array_length (NSArray *array)\n       \n   return i;\n }\n-#endif\n\\ No newline at end of file\n+#endif\n+\n+id test (void)\n+{\n+  return MyRootClass.name; /* { dg-error \"not available in Objective.C 1.0\" } */\n+}\n\\ No newline at end of file"}, {"sha": "5991962b921af17e1fe6359199b107d533a5f0ae", "filename": "gcc/testsuite/obj-c++.dg/property/dotsyntax-3.mm", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bede2adc26d83608df2c21d82d1ff0246baf1456/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fdotsyntax-3.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bede2adc26d83608df2c21d82d1ff0246baf1456/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fdotsyntax-3.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fdotsyntax-3.mm?ref=bede2adc26d83608df2c21d82d1ff0246baf1456", "patch": "@@ -0,0 +1,63 @@\n+/* Contributed by Nicola Pero <nicola.pero@meta-innovation.com>, November 2010.  */\n+/* { dg-do run } */\n+\n+/* Test the 'dot syntax' without a declarated property.  This tests the case where\n+   the object is a Class.  */\n+\n+\n+#include <stdlib.h>\n+#include <objc/objc.h>\n+#include <objc/runtime.h>\n+\n+static int a;\n+static id b;\n+\n+@interface MyRootClass\n+{\n+  Class isa;\n+}\n++ (id) initialize;\n++ (id) alloc;\n+- (id) init;\n++ (int) count;\n++ (void) setCount: (int)value;\n++ (id) next;\n++ (void) setNext: (id)value;\n+@end\n+\n+@implementation MyRootClass\n++ (id) initialize { return self; }\n++ (id) alloc { return class_createInstance (self, 0); }\n+- (id) init { return self; }\n++ (int) count\n+{\n+  return a;\n+}\n++ (void) setCount: (int)value\n+{\n+  a = value;\n+}\n++ (id) next\n+{\n+  return b;\n+}\n++ (void) setNext: (id)value\n+{\n+  b = value;\n+}\n+@end\n+\n+int main (void)\n+{\n+  MyRootClass *object = [[MyRootClass alloc] init];\n+\n+  MyRootClass.count = 40;\n+  if (MyRootClass.count != 40)\n+    abort ();\n+\n+  MyRootClass.next = object;\n+  if (MyRootClass.next != object)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "af410185526dca14f9be192a5475a3886f7690ee", "filename": "gcc/testsuite/obj-c++.dg/property/dotsyntax-4.mm", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bede2adc26d83608df2c21d82d1ff0246baf1456/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fdotsyntax-4.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bede2adc26d83608df2c21d82d1ff0246baf1456/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fdotsyntax-4.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fproperty%2Fdotsyntax-4.mm?ref=bede2adc26d83608df2c21d82d1ff0246baf1456", "patch": "@@ -0,0 +1,69 @@\n+/* Contributed by Nicola Pero <nicola.pero@meta-innovation.com>, November 2010.  */\n+/* { dg-do compile } */\n+\n+/* Test the 'dot syntax' without a declarated property.  This tests\n+   syntax errors in the case where the object is a Class.  */\n+\n+\n+#include <stdlib.h>\n+#include <objc/objc.h>\n+#include <objc/runtime.h>\n+\n+static int a;\n+static id b;\n+\n+@interface MyRootClass\n+{\n+  Class isa;\n+}\n++ (id) initialize;\n++ (id) alloc;\n+- (id) init;\n++ (int) count;\n++ (void) setCount: (int)value;\n++ (id) next;\n++ (void) setNext: (id)value;\n+@end\n+\n+@implementation MyRootClass\n++ (id) initialize { return self; }\n++ (id) alloc { return class_createInstance (self, 0); }\n+- (id) init { return self; }\n++ (int) count\n+{\n+  return a;\n+}\n++ (void) setCount: (int)value\n+{\n+  a = value;\n+}\n++ (id) next\n+{\n+  return b;\n+}\n++ (void) setNext: (id)value\n+{\n+  b = value;\n+}\n+@end\n+\n+int main (void)\n+{\n+  MyRootClass *object = [[MyRootClass alloc] init];\n+\n+  MyRootClass.invalid = 40;      /* { dg-error \"could not find setter.getter\" } */\n+  if (MyRootClass.invalid != 40) /* { dg-error \"could not find setter.getter\" } */\n+    abort ();\n+\n+  MyRootClass.;           /* { dg-error \"expected identifier\" } */\n+  if (MyRootClass.)       /* { dg-error \"expected identifier\" } */\n+    abort ();\n+\n+  MyRootClass.int;        /* { dg-error \"expected identifier\" } */\n+                          /* { dg-error \"expected\" \"\" { target *-*-* } 62 } */\n+  if (MyRootClass.int)    /* { dg-error \"expected identifier\" } */\n+                          /* { dg-error \"expected\" \"\" { target *-*-* } 64 } */\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "4f0a7e6e63e90c69be072c314b665a6e977dd534", "filename": "gcc/testsuite/objc.dg/fobjc-std-1.m", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bede2adc26d83608df2c21d82d1ff0246baf1456/gcc%2Ftestsuite%2Fobjc.dg%2Ffobjc-std-1.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bede2adc26d83608df2c21d82d1ff0246baf1456/gcc%2Ftestsuite%2Fobjc.dg%2Ffobjc-std-1.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Ffobjc-std-1.m?ref=bede2adc26d83608df2c21d82d1ff0246baf1456", "patch": "@@ -13,6 +13,7 @@ @interface MyRootClass\n   int b;\n }\n + (id) alloc __attribute__ ((deprecated)); /* { dg-error \"not available in Objective.C 1.0\" } */\n++ (id) name;\n - (id) init;\n - (id) testMe: (id) __attribute__((unused)) argument; /* { dg-error \"not available in Objective.C 1.0\" } */\n @property (nonatomic) int a; /* { dg-error \"not available in Objective.C 1.0\" } */\n@@ -21,6 +22,7 @@ - (id) testMe: (id) __attribute__((unused)) argument; /* { dg-error \"not availab\n \n @implementation MyRootClass\n + (id) alloc { return self; }\n++ (id) name { return self; }\n - (id) init  { return self; }\n - (id) testMe: (id) __attribute__((unused)) argument { return self; } /* { dg-error \"not available in Objective.C 1.0\" } */\n @synthesize a; /* { dg-error \"not available in Objective.C 1.0\" } */\n@@ -52,3 +54,8 @@ int array_length (NSArray *array)\n       \n   return i;\n }\n+\n+id test (void)\n+{\n+  return MyRootClass.name; /* { dg-error \"not available in Objective.C 1.0\" } */\n+}"}, {"sha": "5991962b921af17e1fe6359199b107d533a5f0ae", "filename": "gcc/testsuite/objc.dg/property/dotsyntax-3.m", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bede2adc26d83608df2c21d82d1ff0246baf1456/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fdotsyntax-3.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bede2adc26d83608df2c21d82d1ff0246baf1456/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fdotsyntax-3.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fdotsyntax-3.m?ref=bede2adc26d83608df2c21d82d1ff0246baf1456", "patch": "@@ -0,0 +1,63 @@\n+/* Contributed by Nicola Pero <nicola.pero@meta-innovation.com>, November 2010.  */\n+/* { dg-do run } */\n+\n+/* Test the 'dot syntax' without a declarated property.  This tests the case where\n+   the object is a Class.  */\n+\n+\n+#include <stdlib.h>\n+#include <objc/objc.h>\n+#include <objc/runtime.h>\n+\n+static int a;\n+static id b;\n+\n+@interface MyRootClass\n+{\n+  Class isa;\n+}\n++ (id) initialize;\n++ (id) alloc;\n+- (id) init;\n++ (int) count;\n++ (void) setCount: (int)value;\n++ (id) next;\n++ (void) setNext: (id)value;\n+@end\n+\n+@implementation MyRootClass\n++ (id) initialize { return self; }\n++ (id) alloc { return class_createInstance (self, 0); }\n+- (id) init { return self; }\n++ (int) count\n+{\n+  return a;\n+}\n++ (void) setCount: (int)value\n+{\n+  a = value;\n+}\n++ (id) next\n+{\n+  return b;\n+}\n++ (void) setNext: (id)value\n+{\n+  b = value;\n+}\n+@end\n+\n+int main (void)\n+{\n+  MyRootClass *object = [[MyRootClass alloc] init];\n+\n+  MyRootClass.count = 40;\n+  if (MyRootClass.count != 40)\n+    abort ();\n+\n+  MyRootClass.next = object;\n+  if (MyRootClass.next != object)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "d890f3bfc0d91cb993d26dacab8062f248622ebb", "filename": "gcc/testsuite/objc.dg/property/dotsyntax-4.m", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bede2adc26d83608df2c21d82d1ff0246baf1456/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fdotsyntax-4.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bede2adc26d83608df2c21d82d1ff0246baf1456/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fdotsyntax-4.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fproperty%2Fdotsyntax-4.m?ref=bede2adc26d83608df2c21d82d1ff0246baf1456", "patch": "@@ -0,0 +1,67 @@\n+/* Contributed by Nicola Pero <nicola.pero@meta-innovation.com>, November 2010.  */\n+/* { dg-do compile } */\n+\n+/* Test the 'dot syntax' without a declarated property.  This tests\n+   syntax errors in the case where the object is a Class.  */\n+\n+\n+#include <stdlib.h>\n+#include <objc/objc.h>\n+#include <objc/runtime.h>\n+\n+static int a;\n+static id b;\n+\n+@interface MyRootClass\n+{\n+  Class isa;\n+}\n++ (id) initialize;\n++ (id) alloc;\n+- (id) init;\n++ (int) count;\n++ (void) setCount: (int)value;\n++ (id) next;\n++ (void) setNext: (id)value;\n+@end\n+\n+@implementation MyRootClass\n++ (id) initialize { return self; }\n++ (id) alloc { return class_createInstance (self, 0); }\n+- (id) init { return self; }\n++ (int) count\n+{\n+  return a;\n+}\n++ (void) setCount: (int)value\n+{\n+  a = value;\n+}\n++ (id) next\n+{\n+  return b;\n+}\n++ (void) setNext: (id)value\n+{\n+  b = value;\n+}\n+@end\n+\n+int main (void)\n+{\n+  MyRootClass *object = [[MyRootClass alloc] init];\n+\n+  MyRootClass.invalid = 40;      /* { dg-error \"could not find setter.getter\" } */\n+  if (MyRootClass.invalid != 40) /* { dg-error \"could not find setter.getter\" } */\n+    abort ();\n+\n+  MyRootClass.;           /* { dg-error \"expected identifier\" } */\n+  if (MyRootClass.)       /* { dg-error \"expected identifier\" } */\n+    abort ();\n+\n+  MyRootClass.int;        /* { dg-error \"expected identifier\" } */\n+  if (MyRootClass.int)    /* { dg-error \"expected identifier\" } */\n+    abort ();\n+\n+  return 0;\n+}"}]}