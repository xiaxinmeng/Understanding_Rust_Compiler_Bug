{"sha": "5adf6da0eb8b7cf355e5db02e8266637e24a5d25", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWFkZjZkYTBlYjhiN2NmMzU1ZTVkYjAyZTgyNjY2MzdlMjRhNWQyNQ==", "commit": {"author": {"name": "J\"orn Rennecke", "email": "amylaar@cygnus.co.uk", "date": "1998-09-24T13:27:20Z"}, "committer": {"name": "Joern Rennecke", "email": "amylaar@gcc.gnu.org", "date": "1998-09-24T13:27:20Z"}, "message": "reload1.c (reload_cse_regs_1): Renamed from reload_cse_regs.\n\n\t* reload1.c (reload_cse_regs_1): Renamed from reload_cse_regs.\n\t(reload_cse_regs): New function body: call reload_cse_regs_1,\n\treload_combine, reload_cse_move2add.\n\tWhen doing expensive_optimizations, call reload_cse_regs_1 a\n\tsecond time after reload_cse_move2add.\n\t(reload_combine, reload_combine_note_store): New functions.\n\t(reload_combine_note_use): New function.\n\t(reload_cse_move2add, move2add_note_store): New functions.\n\nFrom-SVN: r22570", "tree": {"sha": "995c7f6a14ccbb7a782cf673ae7a804c5437a51b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/995c7f6a14ccbb7a782cf673ae7a804c5437a51b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5adf6da0eb8b7cf355e5db02e8266637e24a5d25", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5adf6da0eb8b7cf355e5db02e8266637e24a5d25", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5adf6da0eb8b7cf355e5db02e8266637e24a5d25", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5adf6da0eb8b7cf355e5db02e8266637e24a5d25/comments", "author": null, "committer": null, "parents": [{"sha": "f6b58262981ac267ed713abe542b5b3964baf961", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f6b58262981ac267ed713abe542b5b3964baf961", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f6b58262981ac267ed713abe542b5b3964baf961"}], "stats": {"total": 701, "additions": 699, "deletions": 2}, "files": [{"sha": "c462638335940df996a93a709d950128ec9b00d1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5adf6da0eb8b7cf355e5db02e8266637e24a5d25/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5adf6da0eb8b7cf355e5db02e8266637e24a5d25/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5adf6da0eb8b7cf355e5db02e8266637e24a5d25", "patch": "@@ -1,3 +1,14 @@\n+Thu Sep 24 21:22:39 1998  J\"orn Rennecke <amylaar@cygnus.co.uk>\n+\n+\t* reload1.c (reload_cse_regs_1): Renamed from reload_cse_regs.\n+\t(reload_cse_regs): New function body: call reload_cse_regs_1,\n+\treload_combine, reload_cse_move2add.\n+\tWhen doing expensive_optimizations, call reload_cse_regs_1 a\n+\tsecond time after reload_cse_move2add.\n+\t(reload_combine, reload_combine_note_store): New functions.\n+\t(reload_combine_note_use): New function.\n+\t(reload_cse_move2add, move2add_note_store): New functions.\n+\n Thu Sep 24 18:48:43 1998  J\"orn Rennecke <amylaar@cygnus.co.uk>\n \n \t* reload.c (find_reloads): In code to promote RELOAD_FOR_X_ADDR_ADDR"}, {"sha": "91b7294a6ff87c8c654be55a13f5526339ea3c8e", "filename": "gcc/reload1.c", "status": "modified", "additions": 688, "deletions": 2, "changes": 690, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5adf6da0eb8b7cf355e5db02e8266637e24a5d25/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5adf6da0eb8b7cf355e5db02e8266637e24a5d25/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=5adf6da0eb8b7cf355e5db02e8266637e24a5d25", "patch": "@@ -391,6 +391,7 @@ static void emit_reload_insns\t\tPROTO((rtx, int));\n static void delete_output_reload\tPROTO((rtx, int, rtx));\n static void inc_for_reload\t\tPROTO((rtx, rtx, int));\n static int constraint_accepts_reg_p\tPROTO((char *, rtx));\n+static void reload_cse_regs_1\t\tPROTO((rtx));\n static void reload_cse_invalidate_regno\tPROTO((int, enum machine_mode, int));\n static int reload_cse_mem_conflict_p\tPROTO((rtx, rtx));\n static void reload_cse_invalidate_mem\tPROTO((rtx));\n@@ -403,6 +404,11 @@ static void reload_cse_check_clobber\tPROTO((rtx, rtx));\n static void reload_cse_record_set\tPROTO((rtx, rtx));\n static void reload_cse_delete_death_notes\tPROTO((rtx));\n static void reload_cse_no_longer_dead\tPROTO((int, enum machine_mode));\n+static void reload_combine PROTO((void));\n+static void reload_combine_note_use PROTO((rtx *, rtx));\n+static void reload_combine_note_store PROTO((rtx, rtx));\n+static void reload_cse_move2add PROTO((rtx));\n+static void move2add_note_store PROTO((rtx, rtx));\n \f\n /* Initialize the reload pass once per compilation.  */\n \n@@ -8330,8 +8336,8 @@ reload_cse_no_longer_dead (regno, mode)\n    hard register.  It then replaces the operand with the hard register\n    if possible, much like an optional reload would.  */\n \n-void\n-reload_cse_regs (first)\n+static void\n+reload_cse_regs_1 (first)\n      rtx first;\n {\n   char *firstobj;\n@@ -8547,6 +8553,19 @@ reload_cse_regs (first)\n   pop_obstacks ();\n }\n \n+/* Call cse / combine like post-reload optimization phases.\n+   FIRST is the first instruction.  */\n+void\n+reload_cse_regs (first)\n+     rtx first;\n+{\n+  reload_cse_regs_1 (first);\n+  reload_combine ();\n+  reload_cse_move2add (first);\n+  if (flag_expensive_optimizations)\n+    reload_cse_regs_1 (first);\n+}\n+\n /* Return whether the values known for REGNO are equal to VAL.  MODE\n    is the mode of the object that VAL is being copied to; this matters\n    if VAL is a CONST_INT.  */\n@@ -9144,3 +9163,670 @@ reload_cse_record_set (set, body)\n       abort ();\n     }\n }\n+\f\n+/* If reload couldn't use reg+reg+offset addressing, try to use reg+reg\n+   addressing now.\n+   This code might also be useful when reload gave up on reg+reg addresssing\n+   because of clashes between the return register and INDEX_REG_CLASS.  */\n+\n+/* The maximum number of uses of a register we can keep track of to\n+   replace them with reg+reg addressing.  */\n+#define RELOAD_COMBINE_MAX_USES 6\n+\n+/* INSN is the insn where a register has ben used, and USEP points to the\n+   location of the register within the rtl.  */\n+struct reg_use { rtx insn, *usep; };\n+\n+/* If the register is used in some unknown fashion, USE_INDEX is negative.\n+   If it is dead, USE_INDEX is RELOAD_COMBINE_MAX_USES, and STORE_RUID\n+   indicates where it becomes live again.\n+   Otherwise, USE_INDEX is the index of the last encountered use of the\n+   register (which is first among these we have seen since we scan backwards),\n+   OFFSET contains the constant offset that is added to the register in\n+   all encountered uses, and USE_RUID indicates the first encountered, i.e.\n+   last, of these uses.  */\n+static struct\n+  {\n+    struct reg_use reg_use[RELOAD_COMBINE_MAX_USES];\n+    int use_index;\n+    rtx offset;\n+    int store_ruid;\n+    int use_ruid;\n+  } reg_state[FIRST_PSEUDO_REGISTER];\n+\n+/* Reverse linear uid.  This is increased in reload_combine while scanning\n+   the instructions from last to first.  It is used to set last_label_ruid\n+   and the store_ruid / use_ruid fields in reg_state.  */\n+static int reload_combine_ruid;\n+\n+static void\n+reload_combine ()\n+{\n+  rtx insn, set;\n+  int first_index_reg = 1, last_index_reg = 0;\n+  int i;\n+  int last_label_ruid;\n+\n+  /* If reg+reg can be used in offsetable memory adresses, the main chunk of\n+     reload has already used it where appropriate, so there is no use in\n+     trying to generate it now.  */\n+  if (double_reg_address_ok && reload_address_index_reg_class != NO_REGS)\n+    return;\n+\n+  /* To avoid wasting too much time later searching for an index register,\n+     determine the minimum and maximum index register numbers.  */\n+  for (i = FIRST_PSEUDO_REGISTER - 1; i >= 0; --i)\n+    {\n+      if (TEST_HARD_REG_BIT (reg_class_contents[INDEX_REG_CLASS], i))\n+\t{\n+\t  if (! last_index_reg)\n+\t    last_index_reg = i;\n+\t  first_index_reg = i;\n+\t}\n+    }\n+  /* If no index register is available, we can quit now.  */\n+  if (first_index_reg > last_index_reg)\n+    return;\n+\n+  /* Initialize last_label_ruid, reload_combine_ruid and reg_state.  */\n+  last_label_ruid = reload_combine_ruid = 0;\n+  for (i = FIRST_PSEUDO_REGISTER - 1; i >= 0; --i)\n+    {\n+      if (fixed_regs[i])\n+\treg_state[i].use_index = -1;\n+      else\n+\t{\n+\t  reg_state[i].use_index = RELOAD_COMBINE_MAX_USES;\n+\t  reg_state[i].store_ruid = reload_combine_ruid;\n+\t}\n+    }\n+\n+  for (insn = get_last_insn (); insn; insn = PREV_INSN (insn))\n+    {\n+      rtx note;\n+\n+      /* We cannot do our optimization across labels.  Invalidating all the use\n+\t information we have would be costly, so we just note where the label\n+         is and then later disable any optimization that would cross it.  */\n+      if (GET_CODE (insn) == CODE_LABEL)\n+\tlast_label_ruid = reload_combine_ruid;\n+      if (GET_RTX_CLASS (GET_CODE (insn)) != 'i')\n+\tcontinue;\n+      reload_combine_ruid++;\n+\n+      /* Look for (set (REGX) (CONST_INT))\n+\t\t  (set (REGX) (PLUS (REGX) (REGY)))\n+\t\t  ...\n+\t\t  ... (MEM (REGX)) ...\n+\t and convert it to\n+\t\t  (set (REGZ) (CONST_INT))\n+\t\t  ...\n+\t\t  ... (MEM (PLUS (REGZ) (REGY)))... .\n+\n+\t First, check that we have (set (REGX) (PLUS (REGX) (REGY)))\n+\t and that we know all uses of REGX before it dies.  */\n+      if (set\n+\t  && GET_CODE (SET_DEST (set)) == REG\n+\t  && (HARD_REGNO_NREGS (REGNO (SET_DEST (set)),\n+\t\t\t\tGET_MODE (SET_DEST (set)))\n+\t      == 1)\n+\t  && GET_CODE (SET_SRC (set)) == PLUS\n+\t  && GET_CODE (XEXP (SET_SRC (set), 1)) == REG\n+\t  && rtx_equal_p (XEXP (SET_SRC (set), 0), SET_DEST (set))\n+\t  && last_label_ruid < reg_state[REGNO (SET_DEST (set))].use_ruid)\n+\t{\n+\t  rtx reg = SET_DEST (set);\n+\t  rtx plus = SET_SRC (set);\n+\t  rtx base = XEXP (plus, 1);\n+\t  rtx prev = prev_nonnote_insn (insn);\n+\t  rtx prev_set = prev ? single_set (prev) : NULL_RTX;\n+\t  int regno = REGNO (reg);\n+\t  rtx const_reg;\n+\t  rtx reg_sum = NULL_RTX;\n+\n+\t  /* Now, we need an index register.\n+\t     We'll set index_reg to this index register, const_reg to the\n+\t     register that is to be loaded with the constant\n+\t     (denoted as REGZ in the substitution illustration above),\n+\t     and reg_sum to the register-register that we want to use to\n+\t     substitute uses of REG (typically in MEMs) with.\n+\t     First check REG and BASE for being index registers;\n+\t     we can use them even if they are not dead.  */\n+\t  if (TEST_HARD_REG_BIT (reg_class_contents[INDEX_REG_CLASS], regno)\n+\t      || TEST_HARD_REG_BIT (reg_class_contents[INDEX_REG_CLASS],\n+\t\t\t\t    REGNO (base)))\n+\t    {\n+\t      const_reg = reg;\n+\t      reg_sum = plus;\n+\t    }\n+\t  else\n+\t    {\n+\t       /* Otherwise, look for a free index register.  Since we have\n+\t\t  checked above that neiter REG nor BASE are index registers,\n+\t\t  if we find anything at all, it will be different from these\n+\t\t  two registers.  */\n+\t       for (i = first_index_reg; i <= last_index_reg; i++)\n+\t\t{\n+\t\t  if (TEST_HARD_REG_BIT (reg_class_contents[INDEX_REG_CLASS], i)\n+\t\t      && reg_state[i].use_index == RELOAD_COMBINE_MAX_USES\n+\t\t      && reg_state[i].store_ruid <= reg_state[regno].use_ruid\n+\t\t      && HARD_REGNO_NREGS (i, GET_MODE (reg)) == 1)\n+\t\t    {\n+\t\t      rtx index_reg = gen_rtx_REG (GET_MODE (reg), i);\n+\t\t      const_reg = index_reg;\n+\t\t      reg_sum = gen_rtx_PLUS (GET_MODE (reg), index_reg, base);\n+\t\t      break;\n+\t\t    }\n+\t\t}\n+\t    }\n+\t  if (prev_set\n+\t      && GET_CODE (SET_SRC (prev_set)) == CONST_INT\n+\t      && rtx_equal_p (SET_DEST (prev_set), reg)\n+\t      && reg_state[regno].use_index >= 0\n+\t      && reg_sum)\n+\t    {\n+\t      int i;\n+\n+\t      /* Change destination register and - if necessary - the\n+\t\t constant value in PREV, the constant loading instruction.  */\n+\t      validate_change (prev, &SET_DEST (prev_set), const_reg, 1);\n+\t      if (reg_state[regno].offset != const0_rtx)\n+\t\tvalidate_change (prev,\n+\t\t\t\t &SET_SRC (prev_set),\n+\t\t\t\t GEN_INT (INTVAL (SET_SRC (prev_set))\n+\t\t\t\t\t  + INTVAL (reg_state[regno].offset)),\n+\t\t\t\t 1);\n+\t      /* Now for every use of REG that we have recorded, replace REG\n+\t\t with REG_SUM.  */\n+\t      for (i = reg_state[regno].use_index;\n+\t\t   i < RELOAD_COMBINE_MAX_USES; i++)\n+\t\tvalidate_change (reg_state[regno].reg_use[i].insn,\n+\t\t\t\t reg_state[regno].reg_use[i].usep,\n+\t\t\t\t reg_sum, 1);\n+\n+\t      if (apply_change_group ())\n+\t\t{\n+\t\t  rtx *np;\n+\n+\t\t  /* Delete the reg-reg addition.  */\n+\t\t  PUT_CODE (insn, NOTE);\n+\t\t  NOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n+\t\t  NOTE_SOURCE_FILE (insn) = 0;\n+\n+\t\t  if (reg_state[regno].offset != const0_rtx)\n+\t\t    {\n+\t\t      /* Previous REG_EQUIV / REG_EQUAL notes for PREV\n+\t\t\t are now invalid.  */\n+\t\t      for (np = &REG_NOTES (prev); *np; )\n+\t\t\t{\n+\t\t\t  if (REG_NOTE_KIND (*np) == REG_EQUAL\n+\t\t\t      || REG_NOTE_KIND (*np) == REG_EQUIV)\n+\t\t\t    *np = XEXP (*np, 1);\n+\t\t\t  else\n+\t\t\t    np = &XEXP (*np, 1);\n+\t\t\t}\n+\t\t    }\n+\t\t  reg_state[regno].use_index = RELOAD_COMBINE_MAX_USES;\n+\t\t  reg_state[REGNO (const_reg)].store_ruid = reload_combine_ruid;\n+\t\t  continue;\n+\t\t}\n+\t    }\n+\t}\n+      note_stores (PATTERN (insn), reload_combine_note_store);\n+      if (GET_CODE (insn) == CALL_INSN)\n+\t{\n+\t  rtx link;\n+\n+\t  for (i = FIRST_PSEUDO_REGISTER - 1; i >= 0; --i)\n+\t    {\n+\t      if (call_used_regs[i])\n+\t\t{\n+\t\t  reg_state[i].use_index = RELOAD_COMBINE_MAX_USES;\n+\t\t  reg_state[i].store_ruid = reload_combine_ruid;\n+\t\t}\n+\t    }\n+\t  for (link = CALL_INSN_FUNCTION_USAGE (insn); link;\n+\t       link = XEXP (link, 1))\n+\t    {\n+\t      rtx use = XEXP (link, 0);\n+\t      int regno = REGNO (XEXP (use, 0));\n+\t      if (GET_CODE (use) == CLOBBER)\n+\t\t{\n+\t\t  reg_state[regno].use_index = RELOAD_COMBINE_MAX_USES;\n+\t\t  reg_state[regno].store_ruid = reload_combine_ruid;\n+\t\t}\n+\t      else\n+\t\treg_state[regno].use_index = -1;\n+\t    }\n+\t}\n+      if (GET_CODE (insn) == JUMP_INSN)\n+\t{\n+\t  /* Non-spill registers might be used at the call destination in\n+\t     some unknown fashion, so we have to mark the unknown use.  */\n+\t  for (i = FIRST_PSEUDO_REGISTER - 1; i >= 0; --i)\n+\t    {\n+\t      if (! TEST_HARD_REG_BIT (used_spill_regs, i))\n+\t\treg_state[i].use_index = -1;\n+\t    }\n+\t}\n+      reload_combine_note_use (&PATTERN (insn), insn);\n+      for (note = REG_NOTES (insn); note; note = XEXP (note, 1))\n+\t{\n+\t  if (REG_NOTE_KIND (note) == REG_INC\n+\t      && GET_CODE (XEXP (note, 0)) == REG)\n+\t    reg_state[REGNO (XEXP (note, 0))].use_index = -1;\n+\t}\n+    }\n+}\n+\n+/* Check if DST is a register or a subreg of a register; if it is,\n+   update reg_state[regno].store_ruid and reg_state[regno].use_index\n+   accordingly.  Called via note_stores from reload_combine.\n+   The second argument, SET, is ignored.  */\n+static void\n+reload_combine_note_store (dst, set)\n+     rtx dst, set;\n+{\n+  int regno = 0;\n+  int i;\n+  unsigned size = GET_MODE_SIZE (GET_MODE (dst));\n+\n+  if (GET_CODE (dst) == SUBREG)\n+    {\n+      regno = SUBREG_WORD (dst);\n+      dst = SUBREG_REG (dst);\n+    }\n+  if (GET_CODE (dst) != REG)\n+    return;\n+  regno += REGNO (dst);\n+  /* note_stores might have stripped a STRICT_LOW_PART, so we have to be\n+     careful with registers / register parts that are not full words.  */\n+  if (size < UNITS_PER_WORD)\n+    reg_state[regno].use_index = -1;\n+  else\n+    {\n+      for (i = size / UNITS_PER_WORD - 1 + regno; i >= regno; i--)\n+\t{\n+\t  reg_state[i].store_ruid = reload_combine_ruid;\n+\t  reg_state[i].use_index = RELOAD_COMBINE_MAX_USES;\n+\t}\n+    }\n+}\n+\n+/* XP points to a piece of rtl that has to be checked for any uses of\n+   registers.\n+   *XP is the pattern of INSN, or a part of it.\n+   Called from reload_combine, and recursively by itself.  */\n+static void\n+reload_combine_note_use (xp, insn)\n+     rtx *xp, insn;\n+{\n+  rtx x = *xp;\n+  enum rtx_code code = x->code;\n+  char *fmt;\n+  int i, j;\n+  rtx offset = const0_rtx; /* For the REG case below.  */\n+\n+  switch (code)\n+    {\n+    case SET:\n+      if (GET_CODE (SET_DEST (x)) == REG)\n+\t{\n+\t  reload_combine_note_use (&SET_SRC (x), insn);\n+\t  return;\n+\t}\n+      break;\n+\n+    case CLOBBER:\n+      if (GET_CODE (SET_DEST (x)) == REG)\n+\treturn;\n+      break;\n+\n+    case PLUS:\n+      /* We are interested in (plus (reg) (const_int)) .  */\n+      if (GET_CODE (XEXP (x, 0)) != REG || GET_CODE (XEXP (x, 1)) != CONST_INT)\n+\tbreak;\n+      offset = XEXP (x, 1);\n+      x = XEXP (x, 0);\n+    /* Fall through.  */\n+    case REG:\n+      {\n+\tint regno = REGNO (x);\n+\tint use_index;\n+\n+\t/* Some spurious USEs of pseudo registers might remain.\n+\t   Just ignore them.  */\n+\tif (regno >= FIRST_PSEUDO_REGISTER)\n+\t  return;\n+\n+\t/* If this register is already used in some unknown fashion, we\n+\t   can't do anything.\n+\t   If we decrement the index from zero to -1, we can't store more\n+\t   uses, so this register becomes used in an unknown fashion.  */\n+\tuse_index = --reg_state[regno].use_index;\n+\tif (use_index < 0)\n+\t  return;\n+\n+\tif (use_index != RELOAD_COMBINE_MAX_USES - 1)\n+\t  {\n+\t    /* We have found another use for a register that is already\n+\t       used later.  Check if the offsets match; if not, mark the\n+\t       register as used in an unknown fashion.  */\n+\t    if (! rtx_equal_p (offset, reg_state[regno].offset))\n+\t      {\n+\t\treg_state[regno].use_index = -1;\n+\t\treturn;\n+\t      }\n+\t  }\n+\telse\n+\t  {\n+\t    /* This is the first use of this register we have seen since we\n+\t       marked it as dead.  */\n+\t    reg_state[regno].offset = offset;\n+\t    reg_state[regno].use_ruid = reload_combine_ruid;\n+\t  }\n+\treg_state[regno].reg_use[use_index].insn = insn;\n+\treg_state[regno].reg_use[use_index].usep = xp;\n+\treturn;\n+      }\n+\n+    default:\n+      break;\n+    }\n+\n+  /* Recursively process the components of X.  */\n+  fmt = GET_RTX_FORMAT (code);\n+  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n+    {\n+      if (fmt[i] == 'e')\n+\treload_combine_note_use (&XEXP (x, i), insn);\n+      else if (fmt[i] == 'E')\n+\t{\n+\t  for (j = XVECLEN (x, i) - 1; j >= 0; j--)\n+\t    reload_combine_note_use (&XVECEXP (x, i, j), insn);\n+\t}\n+    }\n+}\n+\f\n+/* See if we can reduce the cost of a constant by replacing a move with\n+   an add.  */\n+/* We cannot do our optimization across labels.  Invalidating all the\n+   information about register contents we have would be costly, so we\n+   use last_label_luid (local variable of reload_cse_move2add) to note\n+   where the label is and then later disable any optimization that would\n+   cross it.\n+   reg_offset[n] / reg_base_reg[n] / reg_mode[n] are only valid if\n+   reg_set_luid[n] is larger than last_label_luid[n] .  */\n+static int reg_set_luid[FIRST_PSEUDO_REGISTER];\n+/* reg_offset[n] has to be CONST_INT for it and reg_base_reg[n] /\n+   reg_mode[n] to be valid.\n+   If reg_offset[n] is a CONST_INT and reg_base_reg[n] is negative, register n\n+   has been set to reg_offset[n] in mode reg_mode[n] .\n+   If reg_offset[n] is a CONST_INT and reg_base_reg[n] is non-negative,\n+   register n has been set to the sum of reg_offset[n] and register\n+   reg_base_reg[n], calculated in mode reg_mode[n] .  */\n+static rtx reg_offset[FIRST_PSEUDO_REGISTER];\n+static int reg_base_reg[FIRST_PSEUDO_REGISTER];\n+static enum machine_mode reg_mode[FIRST_PSEUDO_REGISTER];\n+/* move2add_luid is linearily increased while scanning the instructions\n+   from first to last.  It is used to set reg_set_luid in\n+   reload_cse_move2add and move2add_note_store, and to set reg_death_luid\n+   (local variable of reload_cse_move2add) .  */\n+static int move2add_luid;\n+\n+static void\n+reload_cse_move2add (first)\n+     rtx first;\n+{\n+  int i;\n+  rtx insn;\n+  int last_label_luid;\n+  /* reg_death and reg_death_luid are solely used to remove stale REG_DEAD\n+     notes.  */\n+  int reg_death_luid[FIRST_PSEUDO_REGISTER];\n+  rtx reg_death[FIRST_PSEUDO_REGISTER];\n+\n+  for (i = FIRST_PSEUDO_REGISTER-1; i >= 0; i--)\n+    {\n+      reg_set_luid[i] = 0;\n+      reg_death_luid[i] = 0;\n+    }\n+  last_label_luid = 0;\n+  move2add_luid = 1;\n+  for (insn = first; insn; insn = NEXT_INSN (insn), move2add_luid++)\n+    {\n+      rtx pat, note;\n+\n+      if (GET_CODE (insn) == CODE_LABEL)\n+\tlast_label_luid = move2add_luid;\n+      if (GET_RTX_CLASS (GET_CODE (insn)) != 'i')\n+\tcontinue;\n+      pat = PATTERN (insn);\n+      /* For simplicity, we only perform this optimization on\n+\t straightforward SETs.  */\n+      if (GET_CODE (pat) == SET\n+\t  && GET_CODE (SET_DEST (pat)) == REG)\n+\t{\n+\t  rtx reg = SET_DEST (pat);\n+\t  int regno = REGNO (reg);\n+\t  rtx src = SET_SRC (pat);\n+\n+\t  /* Check if we have valid information on the contents of this\n+\t     register in the mode of REG.  */\n+\t  /* ??? We don't know how zero / sign extension is handled, hence\n+\t     we can't go from a narrower to a wider mode.  */\n+\t  if (reg_set_luid[regno] > last_label_luid\n+\t     && (GET_MODE_SIZE (GET_MODE (reg))\n+\t\t <= GET_MODE_SIZE (reg_mode[regno]))\n+\t     && GET_CODE (reg_offset[regno]) == CONST_INT)\n+\t    {\n+\t      /* Try to transform (set (REGX) (CONST_INT A))\n+\t\t\t\t  ...\n+\t\t\t\t  (set (REGX) (CONST_INT B))\n+\t\t to\n+\t\t\t\t  (set (REGX) (CONST_INT A))\n+\t\t\t\t  ...\n+\t\t\t\t  (set (REGX) (plus (REGX) (CONST_INT B-A)))  */\n+\n+\t      if (GET_CODE (src) == CONST_INT && reg_base_reg[regno] < 0)\n+\t\t{\n+\t\t  int success = 0;\n+\t\t  rtx new_src = GEN_INT (INTVAL (src)\n+\t\t\t\t\t - INTVAL (reg_offset[regno]));\n+\t\t  /* (set (reg) (plus (reg) (const_int 0))) is not canonical;\n+\t\t     use (set (reg) (reg)) instead.\n+\t\t     We don't delete this insn, nor do we convert it into a\n+\t\t     note, to avoid losing register notes or the return\n+\t\t     value flag.  jump2 already knowns how to get rid of\n+\t\t     no-op moves.  */\n+\t\t  if (new_src == const0_rtx)\n+\t\t    success = validate_change (insn, &SET_SRC (pat), reg, 0);\n+\t\t  else if (rtx_cost (new_src, PLUS) < rtx_cost (src, SET)\n+\t\t\t   && have_add2_insn (GET_MODE (reg)))\n+\t\t    success = validate_change (insn, &PATTERN (insn),\n+\t\t\t\t\t       gen_add2_insn (reg, new_src), 0);\n+\t\t  if (success && reg_death_luid[regno] > reg_set_luid[regno])\n+\t\t    remove_death (regno, reg_death[regno]);\n+\t\t  reg_set_luid[regno] = move2add_luid;\n+\t\t  reg_mode[regno] = GET_MODE (reg);\n+\t\t  reg_offset[regno] = src;\n+\t\t  continue;\n+\t\t}\n+\n+\t      /* Try to transform (set (REGX) (REGY))\n+\t\t\t\t  (set (REGX) (PLUS (REGX) (CONST_INT A)))\n+\t\t\t\t  ...\n+\t\t\t\t  (set (REGX) (REGY))\n+\t\t\t\t  (set (REGX) (PLUS (REGX) (CONST_INT B)))\n+\t\t to\n+\t\t\t\t  (REGX) (REGY))\n+\t\t\t\t  (set (REGX) (PLUS (REGX) (CONST_INT A)))\n+\t\t\t\t  ...\n+\t\t\t\t  (set (REGX) (plus (REGX) (CONST_INT B-A)))  */\n+\t      else if (GET_CODE (src) == REG\n+\t\t       && reg_base_reg[regno] == REGNO (src)\n+\t\t       && reg_set_luid[regno] > reg_set_luid[REGNO (src)])\n+\t\t{\n+\t\t  rtx next = next_nonnote_insn (insn);\n+\t\t  rtx set;\n+\t\t  if (next)\n+\t\t    set = single_set (next);\n+\t\t  if (next\n+\t\t      && set\n+\t\t      && SET_DEST (set) == reg\n+\t\t      && GET_CODE (SET_SRC (set)) == PLUS\n+\t\t      && XEXP (SET_SRC (set), 0) == reg\n+\t\t      && GET_CODE (XEXP (SET_SRC (set), 1)) == CONST_INT)\n+\t\t    {\n+\t\t      rtx src2 = SET_SRC (set);\n+\t\t      rtx src3 = XEXP (SET_SRC (set), 1);\n+\t\t      rtx new_src = GEN_INT (INTVAL (src3)\n+\t\t\t\t\t     - INTVAL (reg_offset[regno]));\n+\t\t      int success = 0;\n+\n+\t\t      if (new_src == const0_rtx)\n+\t\t\t/* See above why we create (set (reg) (reg)) here.  */\n+\t\t\tsuccess\n+\t\t\t  = validate_change (next, &SET_SRC (set), reg, 0);\n+\t\t      else if ((rtx_cost (new_src, PLUS)\n+\t\t\t\t< 2 + rtx_cost (src3, SET))\n+\t\t\t       && have_add2_insn (GET_MODE (reg)))\n+\t\t\tsuccess\n+\t\t\t  = validate_change (next, &PATTERN (next),\n+\t\t\t\t\t     gen_add2_insn (reg, new_src), 0);\n+\t\t      if (success)\n+\t\t\t{\n+\t\t\t  if (reg_death_luid[regno] > reg_set_luid[regno])\n+\t\t\t    remove_death (regno, reg_death[regno]);\n+\t\t\t  /* INSN might be the first insn in a basic block\n+\t\t\t     if the preceding insn is a conditional jump\n+\t\t\t     or a possible-throwing call.  */\n+\t\t\t  PUT_CODE (insn, NOTE);\n+\t\t\t  NOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n+\t\t\t  NOTE_SOURCE_FILE (insn) = 0;\n+\t\t\t}\n+\t\t      insn = next;\n+\t\t      reg_set_luid[regno] = move2add_luid;\n+\t\t      reg_mode[regno] = GET_MODE (reg);\n+\t\t      reg_offset[regno] = src3;\n+\t\t      continue;\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+\n+      for (note = REG_NOTES (insn); note; note = XEXP (note, 1))\n+\t{\n+\t  if (REG_NOTE_KIND (note) == REG_INC\n+\t      && GET_CODE (XEXP (note, 0)) == REG)\n+\t    {\n+\t      /* Indicate that this register has been recently written to,\n+\t\t but the exact contents are not available.  */\n+\t      int regno = REGNO (XEXP (note, 0));\n+\t      if (regno < FIRST_PSEUDO_REGISTER)\n+\t\t{\n+\t\t  reg_set_luid[regno] = move2add_luid;\n+\t\t  reg_offset[regno] = note;\n+\t\t}\n+\t    }\n+\t  /* Remember any REG_DEAD notes so that we can remove them\n+\t     later if necessary.  */\n+\t  else if (REG_NOTE_KIND (note) == REG_DEAD\n+\t      && GET_CODE (XEXP (note, 0)) == REG)\n+\t    {\n+\t      int regno = REGNO (XEXP (note, 0));\n+\t      if (regno < FIRST_PSEUDO_REGISTER)\n+\t\t{\n+\t\t  reg_death[regno] = insn;\n+\t\t  reg_death_luid[regno] = move2add_luid;\n+\t\t}\n+\t    }\n+\t}\n+      note_stores (PATTERN (insn), move2add_note_store);\n+      /* If this is a CALL_INSN, all call used registers are stored with\n+\t unknown values.  */\n+      if (GET_CODE (insn) == CALL_INSN)\n+\t{\n+\t  for (i = FIRST_PSEUDO_REGISTER-1; i >= 0; i--)\n+\t    {\n+\t      if (call_used_regs[i])\n+\t\t{\n+\t\t  reg_set_luid[i] = move2add_luid;\n+\t\t  reg_offset[i] = insn;\t/* Invalidate contents.  */\n+\t\t}\n+\t    }\n+\t}\n+    }\n+}\n+\n+/* SET is a SET or CLOBBER that sets DST.\n+   Update reg_set_luid, reg_offset and reg_base_reg accordingly.\n+   Called from reload_cse_move2add via note_stores.  */\n+static void\n+move2add_note_store (dst, set)\n+     rtx dst, set;\n+{\n+  int regno = 0;\n+  int i;\n+\n+  enum machine_mode mode = GET_MODE (dst);\n+  if (GET_CODE (dst) == SUBREG)\n+    {\n+      regno = SUBREG_WORD (dst);\n+      dst = SUBREG_REG (dst);\n+    }\n+  if (GET_CODE (dst) != REG)\n+    return;\n+\n+  regno += REGNO (dst);\n+\n+  if (HARD_REGNO_NREGS (regno, mode) == 1 && GET_CODE (set) == SET)\n+    {\n+      rtx src = SET_SRC (set);\n+\n+      reg_mode[regno] = mode;\n+      switch (GET_CODE (src))\n+\t{\n+\tcase PLUS:\n+\t  {\n+\t    rtx src0 = XEXP (src, 0);\n+\t    if (GET_CODE (src0) == REG)\n+\t      {\n+\t\tif (REGNO (src0) != regno\n+\t\t    || reg_offset[regno] != const0_rtx)\n+\t\t  {\n+\t\t    reg_base_reg[regno] = REGNO (src0);\n+\t\t    reg_set_luid[regno] = move2add_luid;\n+\t\t  }\n+\t\treg_offset[regno] = XEXP (src, 1);\n+\t\tbreak;\n+\t      }\n+\t    reg_set_luid[regno] = move2add_luid;\n+\t    reg_offset[regno] = set;\t/* Invalidate contents.  */\n+\t    break;\n+\t  }\n+\n+\tcase REG:\n+\t  reg_base_reg[regno] = REGNO (SET_SRC (set));\n+\t  reg_offset[regno] = const0_rtx;\n+\t  reg_set_luid[regno] = move2add_luid;\n+\t  break;\n+\n+\tdefault:\n+\t  reg_base_reg[regno] = -1;\n+\t  reg_offset[regno] = SET_SRC (set);\n+\t  reg_set_luid[regno] = move2add_luid;\n+\t  break;\n+\t}\n+    }\n+  else\n+    {\n+      for (i = regno + HARD_REGNO_NREGS (regno, mode) - 1; i >= regno; i--)\n+\t{\n+\t  /* Indicate that this register has been recently written to,\n+\t     but the exact contents are not available.  */\n+\t  reg_set_luid[i] = move2add_luid;\n+\t  reg_offset[i] = dst;\n+\t}\n+    }\n+}"}]}