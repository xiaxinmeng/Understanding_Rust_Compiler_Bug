{"sha": "6feb628a706e86eb3f303aff388c74bdb29e7381", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmZlYjYyOGE3MDZlODZlYjNmMzAzYWZmMzg4Yzc0YmRiMjllNzM4MQ==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2021-07-02T22:16:31Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2021-07-02T22:19:35Z"}, "message": "Improve warning suppression for inlined functions [PR98512].\n\nResolves:\nPR middle-end/98871 - Cannot silence -Wmaybe-uninitialized at declaration site\nPR middle-end/98512 - #pragma GCC diagnostic ignored ineffective in conjunction with alias attribute\n\ngcc/ChangeLog:\n\n\tPR middle-end/98871\n\tPR middle-end/98512\n\t* diagnostic.c (get_any_inlining_info): New.\n\t(update_effective_level_from_pragmas): Handle inlining context.\n\t(diagnostic_enabled): Same.\n\t(diagnostic_report_diagnostic): Same.\n\t* diagnostic.h (struct diagnostic_info): Add ctor.\n\t(struct diagnostic_context): Add new member.\n\t* tree-diagnostic.c (set_inlining_locations): New.\n\t(tree_diagnostics_defaults): Set new callback pointer.", "tree": {"sha": "ba6a85ba22347904863dc5d156881106a9a667b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ba6a85ba22347904863dc5d156881106a9a667b8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6feb628a706e86eb3f303aff388c74bdb29e7381", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6feb628a706e86eb3f303aff388c74bdb29e7381", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6feb628a706e86eb3f303aff388c74bdb29e7381", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6feb628a706e86eb3f303aff388c74bdb29e7381/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9984f63aab93a370101966b7eb198dc61130b3c8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9984f63aab93a370101966b7eb198dc61130b3c8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9984f63aab93a370101966b7eb198dc61130b3c8"}], "stats": {"total": 213, "additions": 180, "deletions": 33}, "files": [{"sha": "8361f68aaceb5bc0f8487899197eb97dcf296c65", "filename": "gcc/diagnostic.c", "status": "modified", "additions": 89, "deletions": 33, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6feb628a706e86eb3f303aff388c74bdb29e7381/gcc%2Fdiagnostic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6feb628a706e86eb3f303aff388c74bdb29e7381/gcc%2Fdiagnostic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic.c?ref=6feb628a706e86eb3f303aff388c74bdb29e7381", "patch": "@@ -991,51 +991,88 @@ print_parseable_fixits (pretty_printer *pp, rich_location *richloc,\n   pp_set_prefix (pp, saved_prefix);\n }\n \n-/* Update the diag_class of DIAGNOSTIC based on its location\n-   relative to any\n+/* Update the inlining info in CONTEXT for a DIAGNOSTIC.  */\n+\n+static void\n+get_any_inlining_info (diagnostic_context *context,\n+\t\t       diagnostic_info *diagnostic)\n+{\n+  auto &ilocs = diagnostic->m_iinfo.m_ilocs;\n+\n+  if (context->set_locations_cb)\n+    /* Retrieve the locations into which the expression about to be\n+       diagnosed has been inlined, including those of all the callers\n+       all the way down the inlining stack.  */\n+    context->set_locations_cb (context, diagnostic);\n+  else\n+    {\n+      /* When there's no callback use just the one location provided\n+\t by the caller of the diagnostic function.  */\n+      location_t loc = diagnostic_location (diagnostic);\n+      ilocs.safe_push (loc);\n+      diagnostic->m_iinfo.m_allsyslocs = in_system_header_at (loc);\n+    }\n+}\n+\n+/* Update the kind of DIAGNOSTIC based on its location(s), including\n+   any of those in its inlining stack, relative to any\n      #pragma GCC diagnostic\n    directives recorded within CONTEXT.\n \n-   Return the new diag_class of DIAGNOSTIC if it was updated, or\n-   DK_UNSPECIFIED otherwise.  */\n+   Return the new kind of DIAGNOSTIC if it was updated, or DK_UNSPECIFIED\n+   otherwise.  */\n \n static diagnostic_t\n update_effective_level_from_pragmas (diagnostic_context *context,\n \t\t\t\t     diagnostic_info *diagnostic)\n {\n-  diagnostic_t diag_class = DK_UNSPECIFIED;\n-\n-  if (context->n_classification_history > 0)\n+  if (diagnostic->m_iinfo.m_allsyslocs && !context->dc_warn_system_headers)\n     {\n-      location_t location = diagnostic_location (diagnostic);\n+      /* Ignore the diagnostic if all the inlined locations are\n+\t in system headers and -Wno-system-headers is in effect.  */\n+      diagnostic->kind = DK_IGNORED;\n+      return DK_IGNORED;\n+    }\n+\n+  if (context->n_classification_history <= 0)\n+    return DK_UNSPECIFIED;\n \n+  /* Iterate over the locations, checking the diagnostic disposition\n+     for the diagnostic at each.  If it's explicitly set as opposed\n+     to unspecified, update the disposition for this instance of\n+     the diagnostic and return it.  */\n+  for (location_t loc: diagnostic->m_iinfo.m_ilocs)\n+    {\n       /* FIXME: Stupid search.  Optimize later. */\n       for (int i = context->n_classification_history - 1; i >= 0; i --)\n \t{\n-\t  if (linemap_location_before_p\n-\t      (line_table,\n-\t       context->classification_history[i].location,\n-\t       location))\n+\t  const diagnostic_classification_change_t &hist\n+\t    = context->classification_history[i];\n+\n+\t  location_t pragloc = hist.location;\n+\t  if (!linemap_location_before_p (line_table, pragloc, loc))\n+\t    continue;\n+\n+\t  if (hist.kind == (int) DK_POP)\n \t    {\n-\t      if (context->classification_history[i].kind == (int) DK_POP)\n-\t\t{\n-\t\t  i = context->classification_history[i].option;\n-\t\t  continue;\n-\t\t}\n-\t      int option = context->classification_history[i].option;\n-\t      /* The option 0 is for all the diagnostics.  */\n-\t      if (option == 0 || option == diagnostic->option_index)\n-\t\t{\n-\t\t  diag_class = context->classification_history[i].kind;\n-\t\t  if (diag_class != DK_UNSPECIFIED)\n-\t\t    diagnostic->kind = diag_class;\n-\t\t  break;\n-\t\t}\n+\t      /* Move on to the next region.  */\n+\t      i = hist.option;\n+\t      continue;\n+\t    }\n+\n+\t  int option = hist.option;\n+\t  /* The option 0 is for all the diagnostics.  */\n+\t  if (option == 0 || option == diagnostic->option_index)\n+\t    {\n+\t      diagnostic_t kind = hist.kind;\n+\t      if (kind != DK_UNSPECIFIED)\n+\t\tdiagnostic->kind = kind;\n+\t      return kind;\n \t    }\n \t}\n     }\n \n-  return diag_class;\n+  return DK_UNSPECIFIED;\n }\n \n /* Generate a URL string describing CWE.  The caller is responsible for\n@@ -1129,6 +1166,9 @@ static bool\n diagnostic_enabled (diagnostic_context *context,\n \t\t    diagnostic_info *diagnostic)\n {\n+  /* Update the inlining stack for this diagnostic.  */\n+  get_any_inlining_info (context, diagnostic);\n+\n   /* Diagnostics with no option or -fpermissive are always enabled.  */\n   if (!diagnostic->option_index\n       || diagnostic->option_index == permissive_error_option (context))\n@@ -1194,17 +1234,25 @@ diagnostic_report_diagnostic (diagnostic_context *context,\n \n   /* Give preference to being able to inhibit warnings, before they\n      get reclassified to something else.  */\n-  if ((diagnostic->kind == DK_WARNING || diagnostic->kind == DK_PEDWARN)\n-      && !diagnostic_report_warnings_p (context, location))\n-    return false;\n+  bool report_warning_p = true;\n+  if (diagnostic->kind == DK_WARNING || diagnostic->kind == DK_PEDWARN)\n+    {\n+      if (context->dc_inhibit_warnings)\n+\treturn false;\n+      /* Remember the result of the overall system header warning setting\n+\t but proceed to also check the inlining context.  */\n+      report_warning_p = diagnostic_report_warnings_p (context, location);\n+      if (!report_warning_p && diagnostic->kind == DK_PEDWARN)\n+\treturn false;\n+    }\n \n   if (diagnostic->kind == DK_PEDWARN)\n     {\n       diagnostic->kind = pedantic_warning_kind (context);\n       /* We do this to avoid giving the message for -pedantic-errors.  */\n       orig_diag_kind = diagnostic->kind;\n     }\n- \n+\n   if (diagnostic->kind == DK_NOTE && context->inhibit_notes_p)\n     return false;\n \n@@ -1228,9 +1276,19 @@ diagnostic_report_diagnostic (diagnostic_context *context,\n       && diagnostic->kind == DK_WARNING)\n     diagnostic->kind = DK_ERROR;\n \n+  diagnostic->message.x_data = &diagnostic->x_data;\n+\n+  /* Check to see if the diagnostic is enabled at the location and\n+     not disabled by #pragma GCC diagnostic anywhere along the inlining\n+     stack.  .  */\n   if (!diagnostic_enabled (context, diagnostic))\n     return false;\n \n+  if (!report_warning_p && diagnostic->m_iinfo.m_allsyslocs)\n+    /* Bail if the warning is not to be reported because all locations\n+       in the inlining stack (if there is one) are in system headers.  */\n+    return false;\n+\n   if (diagnostic->kind != DK_NOTE && diagnostic->kind != DK_ICE)\n     diagnostic_check_max_errors (context);\n \n@@ -1270,8 +1328,6 @@ diagnostic_report_diagnostic (diagnostic_context *context,\n     }\n   context->diagnostic_group_emission_count++;\n \n-  diagnostic->message.x_data = &diagnostic->x_data;\n-  diagnostic->x_data = NULL;\n   pp_format (context->printer, &diagnostic->message);\n   (*diagnostic_starter (context)) (context, diagnostic);\n   pp_output_formatted_text (context->printer);"}, {"sha": "7227dae1b6bef7d42ea32a3b6e858d80bda3747e", "filename": "gcc/diagnostic.h", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6feb628a706e86eb3f303aff388c74bdb29e7381/gcc%2Fdiagnostic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6feb628a706e86eb3f303aff388c74bdb29e7381/gcc%2Fdiagnostic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic.h?ref=6feb628a706e86eb3f303aff388c74bdb29e7381", "patch": "@@ -87,6 +87,11 @@ enum diagnostics_extra_output_kind\n    list in diagnostic.def.  */\n struct diagnostic_info\n {\n+  diagnostic_info ()\n+    : message (), richloc (), metadata (), x_data (), kind (), option_index (),\n+      m_iinfo ()\n+  { }\n+\n   /* Text to be formatted.  */\n   text_info message;\n \n@@ -103,6 +108,18 @@ struct diagnostic_info\n   diagnostic_t kind;\n   /* Which OPT_* directly controls this diagnostic.  */\n   int option_index;\n+\n+  /* Inlining context containing locations for each call site along\n+     the inlining stack.  */\n+  struct inlining_info\n+  {\n+    /* Locations along the inlining stack.  */\n+    auto_vec<location_t, 8> m_ilocs;\n+    /* The abstract origin of the location.  */\n+    void *m_ao;\n+    /* Set if every M_ILOCS element is in a system header.  */\n+    bool m_allsyslocs;\n+  } m_iinfo;\n };\n \n /* Each time a diagnostic's classification is changed with a pragma,\n@@ -346,6 +363,12 @@ struct diagnostic_context\n \n   /* Callback for final cleanup.  */\n   void (*final_cb) (diagnostic_context *context);\n+\n+  /* Callback to set the locations of call sites along the inlining\n+     stack corresponding to a diagnostic location.  Needed to traverse\n+     the BLOCK_SUPERCONTEXT() chain hanging off the LOCATION_BLOCK()\n+     of a diagnostic's location.  */\n+  void (*set_locations_cb)(diagnostic_context *, diagnostic_info *);\n };\n \n static inline void"}, {"sha": "1b636d72a29f86c67df69624f660830dc716628c", "filename": "gcc/tree-diagnostic.c", "status": "modified", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6feb628a706e86eb3f303aff388c74bdb29e7381/gcc%2Ftree-diagnostic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6feb628a706e86eb3f303aff388c74bdb29e7381/gcc%2Ftree-diagnostic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-diagnostic.c?ref=6feb628a706e86eb3f303aff388c74bdb29e7381", "patch": "@@ -305,6 +305,73 @@ default_tree_printer (pretty_printer *pp, text_info *text, const char *spec,\n   return true;\n }\n \n+/* Set the locations of call sites along the inlining stack corresponding\n+   to the DIAGNOSTIC location.  */\n+\n+static void\n+set_inlining_locations (diagnostic_context *,\n+\t\t\tdiagnostic_info *diagnostic)\n+{\n+  location_t loc = diagnostic_location (diagnostic);\n+  tree block = LOCATION_BLOCK (loc);\n+\n+  /* Count the number of locations in system headers.  When all are,\n+     warnings are suppressed by -Wno-system-headers.  Otherwise, they\n+     involve some user code, possibly inlined into a function in a system\n+     header, and are not treated as coming from system headers.  */\n+  unsigned nsyslocs = 0;\n+\n+  /* Use a reference to the vector of locations for convenience.  */\n+  auto &ilocs = diagnostic->m_iinfo.m_ilocs;\n+\n+  while (block && TREE_CODE (block) == BLOCK\n+\t && BLOCK_ABSTRACT_ORIGIN (block))\n+    {\n+      tree ao = BLOCK_ABSTRACT_ORIGIN (block);\n+      if (TREE_CODE (ao) == FUNCTION_DECL)\n+\t{\n+\t  if (!diagnostic->m_iinfo.m_ao)\n+\t    diagnostic->m_iinfo.m_ao = block;\n+\n+\t  location_t bsloc = BLOCK_SOURCE_LOCATION (block);\n+\t  ilocs.safe_push (bsloc);\n+\t  if (in_system_header_at (bsloc))\n+\t    ++nsyslocs;\n+\t}\n+      else if (TREE_CODE (ao) != BLOCK)\n+\tbreak;\n+\n+      block = BLOCK_SUPERCONTEXT (block);\n+    }\n+\n+  if (ilocs.length ())\n+    {\n+      /* When there is an inlining context use the macro expansion\n+\t location for the original location and bump up NSYSLOCS if\n+\t it's in a system header since it's not counted above.  */\n+      location_t sysloc = expansion_point_location_if_in_system_header (loc);\n+      if (sysloc != loc)\n+\t{\n+\t  loc = sysloc;\n+\t  ++nsyslocs;\n+\t}\n+    }\n+  else\n+    {\n+      /* When there's no inlining context use the original location\n+\t and set NSYSLOCS accordingly.  */\n+      nsyslocs = in_system_header_at (loc) != 0;\n+    }\n+\n+  ilocs.safe_push (loc);\n+\n+  /* Set if all locations are in a system header.  */\n+  diagnostic->m_iinfo.m_allsyslocs = nsyslocs == ilocs.length ();\n+\n+  if (tree *ao = pp_ti_abstract_origin (&diagnostic->message))\n+    *ao = (tree)diagnostic->m_iinfo.m_ao;\n+}\n+\n /* Sets CONTEXT to use language independent diagnostics.  */\n void\n tree_diagnostics_defaults (diagnostic_context *context)\n@@ -314,4 +381,5 @@ tree_diagnostics_defaults (diagnostic_context *context)\n   diagnostic_format_decoder (context) = default_tree_printer;\n   context->print_path = default_tree_diagnostic_path_printer;\n   context->make_json_for_path = default_tree_make_json_for_path;\n+  context->set_locations_cb = set_inlining_locations;\n }"}]}