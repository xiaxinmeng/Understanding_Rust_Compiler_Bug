{"sha": "6b3c76a98c4c49d0d1a508d61558bb197bc50585", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmIzYzc2YTk4YzRjNDlkMGQxYTUwOGQ2MTU1OGJiMTk3YmM1MDU4NQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2006-12-06T16:32:17Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2006-12-06T16:32:17Z"}, "message": "tree-vrp.c (operand_less_p): New.\n\n\t* tree-vrp.c (operand_less_p): New.\n\t(compare_values, value_inside_range): Rewrite in terms of\n\toperand_less_p.\n\nFrom-SVN: r119583", "tree": {"sha": "11378b2ae5906665bd04a924e28237f480838178", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/11378b2ae5906665bd04a924e28237f480838178"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6b3c76a98c4c49d0d1a508d61558bb197bc50585", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b3c76a98c4c49d0d1a508d61558bb197bc50585", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6b3c76a98c4c49d0d1a508d61558bb197bc50585", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b3c76a98c4c49d0d1a508d61558bb197bc50585/comments", "author": null, "committer": null, "parents": [{"sha": "90c56b45eba69690eb21bf950a14783fadb48724", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90c56b45eba69690eb21bf950a14783fadb48724", "html_url": "https://github.com/Rust-GCC/gccrs/commit/90c56b45eba69690eb21bf950a14783fadb48724"}], "stats": {"total": 62, "additions": 49, "deletions": 13}, "files": [{"sha": "b963ad6e332d8800738b8f629c13a061032c5df5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b3c76a98c4c49d0d1a508d61558bb197bc50585/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b3c76a98c4c49d0d1a508d61558bb197bc50585/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6b3c76a98c4c49d0d1a508d61558bb197bc50585", "patch": "@@ -1,3 +1,9 @@\n+2006-12-06  Jan Hubicka  <jh@suse.cz>\n+\n+\t* tree-vrp.c (operand_less_p): New.\n+\t(compare_values, value_inside_range): Rewrite in terms of\n+\toperand_less_p.\n+\n 2006-12-06 Uros Bizjak <ubizjak@gmail.com>\n \n \t* config/i386/i386.md (DIRFLAG_REG): Remove constant."}, {"sha": "908f22bbaed41b59edb0cc795bf5518cec861284", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 43, "deletions": 13, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b3c76a98c4c49d0d1a508d61558bb197bc50585/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b3c76a98c4c49d0d1a508d61558bb197bc50585/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=6b3c76a98c4c49d0d1a508d61558bb197bc50585", "patch": "@@ -442,6 +442,29 @@ valid_value_p (tree expr)\n   return is_gimple_min_invariant (expr);\n }\n \n+/* Return \n+   1 if VAL < VAL2\n+   0 if !(VAL < VAL2)\n+   -2 if those are incomparable.  */\n+static inline int\n+operand_less_p (tree val, tree val2)\n+{\n+  tree tcmp;\n+  /* LT is folded faster than GE and others.  Inline the common case.  */\n+  if (TREE_CODE (val) == INTEGER_CST && TREE_CODE (val2) == INTEGER_CST)\n+    {\n+      if (TYPE_UNSIGNED (TREE_TYPE (val)))\n+\treturn INT_CST_LT_UNSIGNED (val, val2);\n+      else\n+\treturn INT_CST_LT (val, val2);\n+    }\n+  else\n+    tcmp = fold_binary_to_constant (LT_EXPR, boolean_type_node, val, val2);\n+  if (!tcmp)\n+    return -2;\n+  return !integer_zerop (tcmp);\n+}\n+\n /* Compare two values VAL1 and VAL2.  Return\n    \n    \t-2 if VAL1 and VAL2 cannot be compared at compile-time,\n@@ -590,13 +613,11 @@ compare_values (tree val1, tree val2)\n \treturn 0;\n       \n       /* If VAL1 is a lower address than VAL2, return -1.  */\n-      t = fold_binary (LT_EXPR, boolean_type_node, val1, val2);\n-      if (t == boolean_true_node)\n+      if (operand_less_p (val1, val2) == 1)\n \treturn -1;\n \n       /* If VAL1 is a higher address than VAL2, return +1.  */\n-      t = fold_binary (GT_EXPR, boolean_type_node, val1, val2);\n-      if (t == boolean_true_node)\n+      if (operand_less_p (val2, val1) == 1)\n \treturn 1;\n \n       /* If VAL1 is different than VAL2, return +2.  */\n@@ -627,27 +648,36 @@ compare_values (tree val1, tree val2)\n \t  This also applies to value_ranges_intersect_p and\n \t  range_includes_zero_p.  The semantics of VR_RANGE and\n \t  VR_ANTI_RANGE should be encoded here, but that also means\n-\t  adapting the users of these functions to the new semantics.  */\n+\t  adapting the users of these functions to the new semantics.  \n+\n+   Benchmark compile/20001226-1.c compilation time after changing this\n+   function.  */\n \n static inline int\n-value_inside_range (tree val, value_range_t *vr)\n+value_inside_range (tree val, value_range_t * vr)\n {\n-  tree cmp1, cmp2;\n+  int cmp1, cmp2;\n \n-  cmp1 = fold_binary_to_constant (GE_EXPR, boolean_type_node, val, vr->min);\n-  if (!cmp1)\n+  cmp1 = operand_less_p (val, vr->min);\n+  if (cmp1 == -2)\n     return -2;\n+  if (cmp1 == 1)\n+    return 0;\n \n-  cmp2 = fold_binary_to_constant (LE_EXPR, boolean_type_node, val, vr->max);\n-  if (!cmp2)\n+  cmp2 = operand_less_p (vr->max, val);\n+  if (cmp2 == -2)\n     return -2;\n \n-  return cmp1 == boolean_true_node && cmp2 == boolean_true_node;\n+  return !cmp2;\n }\n \n \n /* Return true if value ranges VR0 and VR1 have a non-empty\n-   intersection.  */\n+   intersection.  \n+   \n+   Benchmark compile/20001226-1.c compilation time after changing this\n+   function.\n+   */\n \n static inline bool\n value_ranges_intersect_p (value_range_t *vr0, value_range_t *vr1)"}]}