{"sha": "5291e69adedd50438763fcaf9c2bfd05d75ca5ff", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTI5MWU2OWFkZWRkNTA0Mzg3NjNmY2FmOWMyYmZkMDVkNzVjYTVmZg==", "commit": {"author": {"name": "Paul Brook", "email": "paul@codesourcery.com", "date": "2004-05-23T15:14:36Z"}, "committer": {"name": "Paul Brook", "email": "pbrook@gcc.gnu.org", "date": "2004-05-23T15:14:36Z"}, "message": "gfortran.h (struct gfc_symbol): Add equiv_built.\n\n\t* gfortran.h (struct gfc_symbol): Add equiv_built.\n\t* trans-common.c: Change int to HOST_WIDE_INT.  Capitalize error\n\tmessages.\n\t(current_length): Remove.\n\t(add_segments): New function.\n\t(build_equiv_decl): Create initialized common blocks.\n\t(build_common_decl): Always add decl to bindings.\n\t(create_common): Create initializers.\n\t(find_segment_info): Reformat to match coding conventions.\n\t(new_condition): Use add_segments.\n\t(add_condition, find_equivalence, add_equivalences): Move iteration\n\tinside functions.  Only process each segment once.\n\t(new_segment, finish_equivalences, translate_common): Simplify.\ntestsuite/\n\t* gfortran.fortran-torture/execute/common_init_1.f90: New test.\n\t* gfortran.fortran-torture/execute/equiv_init.f90: New test.\n\nCo-Authored-By: Victor Leikehman <lei@haifasphere.co.il>\n\nFrom-SVN: r82165", "tree": {"sha": "f8205786cc8a2cd8c9046a78ba52ff069a490726", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f8205786cc8a2cd8c9046a78ba52ff069a490726"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5291e69adedd50438763fcaf9c2bfd05d75ca5ff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5291e69adedd50438763fcaf9c2bfd05d75ca5ff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5291e69adedd50438763fcaf9c2bfd05d75ca5ff", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5291e69adedd50438763fcaf9c2bfd05d75ca5ff/comments", "author": null, "committer": null, "parents": [{"sha": "68ca19239c5b844c4f9b82776d2c18d991b880bb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68ca19239c5b844c4f9b82776d2c18d991b880bb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/68ca19239c5b844c4f9b82776d2c18d991b880bb"}], "stats": {"total": 513, "additions": 372, "deletions": 141}, "files": [{"sha": "01e6f60e6530a10a4e86773d927d3719024d6ec4", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5291e69adedd50438763fcaf9c2bfd05d75ca5ff/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5291e69adedd50438763fcaf9c2bfd05d75ca5ff/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=5291e69adedd50438763fcaf9c2bfd05d75ca5ff", "patch": "@@ -1,3 +1,20 @@\n+2004-05-23  Paul Brook  <paul@codesourcery.com>\n+\tVictor Leikehman  <lei@haifasphere.co.il>\n+\n+\t* gfortran.h (struct gfc_symbol): Add equiv_built.\n+\t* trans-common.c: Change int to HOST_WIDE_INT.  Capitalize error\n+\tmessages.\n+\t(current_length): Remove.\n+\t(add_segments): New function.\n+\t(build_equiv_decl): Create initialized common blocks.\n+\t(build_common_decl): Always add decl to bindings.\n+\t(create_common): Create initializers.\n+\t(find_segment_info): Reformat to match coding conventions.\n+\t(new_condition): Use add_segments.\n+\t(add_condition, find_equivalence, add_equivalences): Move iteration\n+\tinside functions.  Only process each segment once.\n+\t(new_segment, finish_equivalences, translate_common): Simplify.\n+\n 2004-05-23  Steven G. Kargl  <kargls@comcast.net>\n \n \t* check.c (gfc_check_random_seed): Issue for too many arguments."}, {"sha": "782e1f75e976815d5e104eb8ab4ed8e573dcffde", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5291e69adedd50438763fcaf9c2bfd05d75ca5ff/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5291e69adedd50438763fcaf9c2bfd05d75ca5ff/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=5291e69adedd50438763fcaf9c2bfd05d75ca5ff", "patch": "@@ -651,6 +651,9 @@ typedef struct gfc_symbol\n \n   struct gfc_symbol *old_symbol, *tlink;\n   unsigned mark:1, new:1;\n+  /* Nonzero if all equivalences associated with this symbol have been\n+     processed.  */\n+  unsigned equiv_built:1;\n   int refs;\n   struct gfc_namespace *ns;\t/* namespace containing this symbol */\n "}, {"sha": "458dbeff3682e7bc6f1f28df30c8d7a5b12a0a0c", "filename": "gcc/fortran/trans-common.c", "status": "modified", "additions": 228, "deletions": 141, "changes": 369, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5291e69adedd50438763fcaf9c2bfd05d75ca5ff/gcc%2Ffortran%2Ftrans-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5291e69adedd50438763fcaf9c2bfd05d75ca5ff/gcc%2Ffortran%2Ftrans-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-common.c?ref=5291e69adedd50438763fcaf9c2bfd05d75ca5ff", "patch": "@@ -82,6 +82,13 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    common block is series of segments with one variable each, which is\n    a diagonal matrix in the matrix formulation.\n  \n+   Each segment is described by a chain of segment_info structures.  Each\n+   segment_info structure describes the extents of a single varible within\n+   the segment.  This list is maintained in the order the elements are\n+   positioned withing the segment.  If two elements have the same starting\n+   offset the smaller will come first.  If they also have the same size their\n+   ordering is undefined. \n+   \n    Once all common blocks have been created, the list of equivalences\n    is examined for still-unused equivalence conditions.  We create a\n    block for each merged equivalence list.  */\n@@ -96,26 +103,68 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"trans.h\"\n #include \"trans-types.h\"\n #include \"trans-const.h\"\n+#include <assert.h>\n \n \n typedef struct segment_info\n {\n   gfc_symbol *sym;\n-  int offset;\n-  int length;\n+  HOST_WIDE_INT offset;\n+  HOST_WIDE_INT length;\n   tree field; \n   struct segment_info *next;\n } segment_info;\n \n static segment_info *current_segment, *current_common;\n-static int current_length, current_offset;\n+static HOST_WIDE_INT current_offset;\n static gfc_namespace *gfc_common_ns = NULL;\n \n #define get_segment_info() gfc_getmem (sizeof (segment_info))\n \n #define BLANK_COMMON_NAME \"__BLNK__\"\n \n \n+/* Add combine segment V and segement LIST.  */\n+\n+static segment_info *\n+add_segments (segment_info *list, segment_info *v)\n+{\n+  segment_info *s;\n+  segment_info *p;\n+  segment_info *next;\n+  \n+  p = NULL;\n+  s = list;\n+\n+  while (v)\n+    {\n+      /* Find the location of the new element.  */\n+      while (s)\n+\t{\n+\t  if (v->offset < s->offset)\n+\t    break;\n+\t  if (v->offset == s->offset\n+\t      && v->length <= s->length)\n+\t    break;\n+\n+\t  p = s;\n+\t  s = s->next;\n+\t}\n+\n+      /* Insert the new element in between p and s.  */\n+      next = v->next;\n+      v->next = s;\n+      if (p == NULL)\n+\tlist = v;\n+      else\n+\tp->next = v;\n+\n+      p = v;\n+      v = next;\n+    }\n+  return list;\n+}\n+\n /* Construct mangled common block name from symbol name.  */\n \n static tree\n@@ -150,7 +199,7 @@ build_field (segment_info *h, tree union_type, record_layout_info rli)\n   tree name = get_identifier (h->sym->name);\n   tree field = build_decl (FIELD_DECL, name, type);\n   HOST_WIDE_INT offset = h->offset;\n-  unsigned int desired_align, known_align;\n+  unsigned HOST_WIDE_INT desired_align, known_align;\n \n   known_align = (offset & -offset) * BITS_PER_UNIT;\n   if (known_align == 0 || known_align > BIGGEST_ALIGNMENT)\n@@ -179,13 +228,18 @@ static tree\n build_equiv_decl (tree union_type, bool is_init)\n {\n   tree decl;\n+\n+  if (is_init)\n+    {\n+      decl = gfc_create_var (union_type, \"equiv\");\n+      TREE_STATIC (decl) = 1;\n+      return decl;\n+    }\n+\n   decl = build_decl (VAR_DECL, NULL, union_type);\n   DECL_ARTIFICIAL (decl) = 1;\n \n-  if (is_init)\n-    DECL_COMMON (decl) = 0;\n-  else\n-    DECL_COMMON (decl) = 1;\n+  DECL_COMMON (decl) = 1;\n \n   TREE_ADDRESSABLE (decl) = 1;\n   TREE_USED (decl) = 1;\n@@ -213,14 +267,14 @@ build_common_decl (gfc_symbol *sym, tree union_type, bool is_init)\n   /* Update the size of this common block as needed.  */\n   if (decl != NULL_TREE)\n     {\n-      tree size = build_int_2 (current_length, 0);\n+      tree size = TYPE_SIZE_UNIT (union_type);\n       if (tree_int_cst_lt (DECL_SIZE_UNIT (decl), size))\n         {\n           /* Named common blocks of the same name shall be of the same size\n              in all scoping units of a program in which they appear, but\n              blank common blocks may be of different sizes.  */\n           if (strcmp (sym->name, BLANK_COMMON_NAME))\n-              gfc_warning (\"named COMMON block '%s' at %L shall be of the \"\n+              gfc_warning (\"Named COMMON block '%s' at %L shall be of the \"\n                            \"same size\", sym->name, &sym->declared_at);\n           DECL_SIZE_UNIT (decl) = size;\n         }\n@@ -241,6 +295,10 @@ build_common_decl (gfc_symbol *sym, tree union_type, bool is_init)\n       TREE_STATIC (decl) = 1;\n       DECL_ALIGN (decl) = BIGGEST_ALIGNMENT;\n       DECL_USER_ALIGN (decl) = 0;\n+\n+      /* Place the back end declaration for this common block in\n+         GLOBAL_BINDING_LEVEL.  */\n+      common_sym->backend_decl = pushdecl_top_level (decl);\n     }\n \n   /* Has no initial values.  */\n@@ -250,16 +308,12 @@ build_common_decl (gfc_symbol *sym, tree union_type, bool is_init)\n       DECL_COMMON (decl) = 1;\n       DECL_DEFER_OUTPUT (decl) = 1;\n \n-      /* Place the back end declaration for this common block in\n-         GLOBAL_BINDING_LEVEL.  */\n-      common_sym->backend_decl = pushdecl_top_level (decl);\n     }\n   else\n     {\n       DECL_INITIAL (decl) = error_mark_node;\n       DECL_COMMON (decl) = 0;\n       DECL_DEFER_OUTPUT (decl) = 0;\n-      common_sym->backend_decl = decl;\n     }\n   return decl;\n }\n@@ -300,14 +354,73 @@ create_common (gfc_symbol *sym)\n     }\n   finish_record_layout (rli, true);\n \n-  if (is_init)\n-    gfc_todo_error (\"initial values for COMMON or EQUIVALENCE\");\n-  \n   if (sym)\n     decl = build_common_decl (sym, union_type, is_init);\n   else\n     decl = build_equiv_decl (union_type, is_init);\n \n+  if (is_init)\n+    {\n+      tree list, ctor, tmp;\n+      gfc_se se;\n+      HOST_WIDE_INT offset = 0;\n+\n+      list = NULL_TREE;\n+      for (h = current_common; h; h = h->next)\n+        {\n+          if (h->sym->value)\n+            {\n+              if (h->offset < offset)\n+                {\n+\t\t    /* We have overlapping initializers.  It could either be\n+\t\t       partially initilalized arrays (lagal), or the user\n+\t\t       specified multiple initial values (illegal).\n+\t\t       We don't implement this yet, so bail out.  */\n+                  gfc_todo_error (\"Initialization of overlapping variables\");\n+                }\n+              if (h->sym->attr.dimension)\n+                {\n+                  tmp = gfc_conv_array_initializer (TREE_TYPE (h->field),\n+                                                  h->sym->value);\n+                  list = tree_cons (h->field, tmp, list);\n+                }\n+              else\n+                {\n+\t\t  switch (h->sym->ts.type)\n+\t\t    {\n+\t\t    case BT_CHARACTER:\n+\t\t      se.expr = gfc_conv_string_init\n+\t\t\t(h->sym->ts.cl->backend_decl, h->sym->value);\n+\t\t      break;\n+\n+\t\t    case BT_DERIVED:\n+\t\t      gfc_init_se (&se, NULL);\n+\t\t      gfc_conv_structure (&se, sym->value, 1);\n+\t\t      break;\n+\n+\t\t    default:\n+\t\t      gfc_init_se (&se, NULL);\n+\t\t      gfc_conv_expr (&se, h->sym->value);\n+\t\t      break;\n+\t\t    }\n+                  list = tree_cons (h->field, se.expr, list);\n+                }\n+              offset = h->offset + h->length;\n+            }\n+        }\n+      assert (list);\n+      ctor = build1 (CONSTRUCTOR, union_type, nreverse(list));\n+      TREE_CONSTANT (ctor) = 1;\n+      TREE_INVARIANT (ctor) = 1;\n+      TREE_STATIC (ctor) = 1;\n+      DECL_INITIAL (decl) = ctor;\n+\n+#ifdef ENABLE_CHECKING\n+      for (tmp = CONSTRUCTOR_ELTS (ctor); tmp; tmp = TREE_CHAIN (tmp))\n+\tassert (TREE_CODE (TREE_PURPOSE (tmp)) == FIELD_DECL);\n+#endif\n+    }\n+\n   /* Build component reference for each variable.  */\n   for (h = current_common; h; h = next_s)\n     {\n@@ -329,7 +442,10 @@ find_segment_info (gfc_symbol *symbol)\n   segment_info *n;\n \n   for (n = current_segment; n; n = n->next)\n-    if (n->sym == symbol) return n;\n+    {\n+      if (n->sym == symbol)\n+\treturn n;\n+    }\n \n   return NULL;    \n } \n@@ -338,10 +454,10 @@ find_segment_info (gfc_symbol *symbol)\n /* Given a variable symbol, calculate the total length in bytes of the\n    variable.  */\n \n-static int\n+static HOST_WIDE_INT\n calculate_length (gfc_symbol *symbol)\n {        \n-  int j, element_size;        \n+  HOST_WIDE_INT j, element_size;        \n   mpz_t elements;  \n \n   if (symbol->ts.type == BT_CHARACTER)\n@@ -378,12 +494,12 @@ get_mpz (gfc_expr *g)\n    to be constants.  If something goes wrong we generate an error and\n    return zero.  */ \n  \n-static int \n+static HOST_WIDE_INT\n element_number (gfc_array_ref *ar)\n {       \n   mpz_t multiplier, offset, extent, l;\n   gfc_array_spec *as;\n-  int b, rank;\n+  HOST_WIDE_INT b, rank;\n \n   as = ar->as;\n   rank = as->rank;\n@@ -428,10 +544,10 @@ element_number (gfc_array_ref *ar)\n    element number and multiply by the element size. For a substring we\n    have to calculate the further reference.  */\n \n-static int\n+static HOST_WIDE_INT\n calculate_offset (gfc_expr *s)\n {\n-  int a, element_size, offset;\n+  HOST_WIDE_INT a, element_size, offset;\n   gfc_typespec *element_type;\n   gfc_ref *reference;\n \n@@ -457,28 +573,28 @@ calculate_offset (gfc_expr *s)\n \t    break;\n \n           default:\n-\t    gfc_error (\"bad array reference at %L\", &s->where);\n+\t    gfc_error (\"Bad array reference at %L\", &s->where);\n           }\n         break;\n       case REF_SUBSTRING:\n         if (reference->u.ss.start != NULL)\n \t  offset += mpz_get_ui (*get_mpz (reference->u.ss.start)) - 1;\n         break;\n       default:\n-        gfc_error (\"illegal reference type at %L as EQUIVALENCE object\",\n+        gfc_error (\"Illegal reference type at %L as EQUIVALENCE object\",\n                    &s->where);\n     } \n   return offset;\n }\n \n  \n-/* Add a new segment_info structure to the current eq1 is already in the\n-   list at s1, eq2 is not.  */\n+/* Add a new segment_info structure to the current segment.  eq1 is already\n+   in the list, eq2 is not.  */\n \n static void\n new_condition (segment_info *v, gfc_equiv *eq1, gfc_equiv *eq2)\n {\n-  int offset1, offset2;\n+  HOST_WIDE_INT offset1, offset2;\n   segment_info *a;\n  \n   offset1 = calculate_offset (eq1->expr);\n@@ -490,8 +606,7 @@ new_condition (segment_info *v, gfc_equiv *eq1, gfc_equiv *eq2)\n   a->offset = v->offset + offset1 - offset2;\n   a->length = calculate_length (eq2->expr->symtree->n.sym);\n  \n-  a->next = current_segment;\n-  current_segment = a;\n+  current_segment = add_segments (current_segment, a);\n }\n \n \n@@ -503,97 +618,102 @@ static void\n confirm_condition (segment_info *k, gfc_equiv *eq1, segment_info *e,\n                    gfc_equiv *eq2)\n {\n-  int offset1, offset2;\n+  HOST_WIDE_INT offset1, offset2;\n \n   offset1 = calculate_offset (eq1->expr);\n   offset2 = calculate_offset (eq2->expr);\n  \n   if (k->offset + offset1 != e->offset + offset2)          \n-    gfc_error (\"inconsistent equivalence rules involving '%s' at %L and \"\n+    gfc_error (\"Inconsistent equivalence rules involving '%s' at %L and \"\n \t       \"'%s' at %L\", k->sym->name, &k->sym->declared_at,\n \t       e->sym->name, &e->sym->declared_at);\n } \n \n  \n-/* At this point we have a new equivalence condition to process. If both\n-   variables are already present, then we are confirming that the condition\n-   holds. Otherwise we are adding a new variable to the segment list.  */\n+/* Process a new equivalence condition. eq1 is know to be in segment f.\n+   If eq2 is also present then confirm that the condition holds.\n+   Otherwise add a new variable to the segment list.  */\n \n static void\n-add_condition (gfc_equiv *eq1, gfc_equiv *eq2)\n+add_condition (segment_info *f, gfc_equiv *eq1, gfc_equiv *eq2)\n {\n-  segment_info *n, *t;\n-\n-  eq1->expr->symtree->n.sym->mark = 1;\n-  eq2->expr->symtree->n.sym->mark = 1;\n-\n-  eq2->used = 1;\n+  segment_info *n;\n \n-  n = find_segment_info (eq1->expr->symtree->n.sym);\n-  t = find_segment_info (eq2->expr->symtree->n.sym);\n+  n = find_segment_info (eq2->expr->symtree->n.sym);\n \n-  if (n == NULL && t == NULL)\n-    abort ();\n-  if (n != NULL && t == NULL)\n-    new_condition (n, eq1, eq2);\n-  if (n == NULL && t != NULL)\n-    new_condition (t, eq2, eq1);\n-  if (n != NULL && t != NULL)\n-    confirm_condition (n, eq1, t, eq2);\n+  if (n == NULL)\n+    new_condition (f, eq1, eq2);\n+  else\n+    confirm_condition (f, eq1, n, eq2);\n }\n \n \n-/* Given a symbol, search through the equivalence lists for an unused\n-   condition that involves the symbol.  If a rule is found, we return\n-   nonzero, the rule is marked as used and the eq1 and eq2 pointers point\n-   to the rule.  */\n+/* Given a segment element, search through the equivalence lists for unused\n+   conditions that involve the symbol.  Add these rules to the segment.  */\n  \n-static int \n-find_equivalence (gfc_symbol *sym, gfc_equiv **eq1, gfc_equiv **eq2)\n+static bool\n+find_equivalence (segment_info *f)\n {\n-  gfc_equiv *c, *l;\n+  gfc_equiv *c, *l, *eq, *other;\n+  bool found;\n  \n-  for (c = sym->ns->equiv; c; c = c->next)\n-    for (l = c->eq; l; l = l->eq)\n-      {\n-        if (l->used) continue;\n-\n-        if (c->expr->symtree->n.sym == sym || l->expr->symtree->n.sym == sym)\n-          {\n-\t    *eq1 = c;\n-\t    *eq2 = l;\n-\t    return 1;\n-          }\n-      }\n-  return 0;\n+  found = FALSE;\n+  for (c = f->sym->ns->equiv; c; c = c->next)\n+    {\n+      other = NULL;\n+      for (l = c->eq; l; l = l->eq)\n+\t{\n+\t  if (l->used)\n+\t    continue;\n+\n+\t  if (c->expr->symtree->n.sym ==f-> sym)\n+\t    {\n+\t      eq = c;\n+\t      other = l;\n+\t    }\n+\t  else if (l->expr->symtree->n.sym == f->sym)\n+\t    {\n+\t      eq = l;\n+\t      other = c;\n+\t    }\n+\t  else\n+\t    eq = NULL;\n+\t  \n+\t  if (eq)\n+\t    {\n+\t      add_condition (f, eq, other);\n+\t      l->used = 1;\n+\t      found = TRUE;\n+\t      break;\n+\t    }\n+\t}\n+    }\n+  return found;\n }\n \n  \n-/* Function for adding symbols to current segment. Returns zero if the\n-   segment was modified.  Equivalence rules are considered to be between\n-   the first expression in the list and each of the other expressions in\n-   the list.  Symbols are scanned  multiple times because a symbol can be\n-   equivalenced more than once.  */\n+/* Add all symbols equivalenced within a segment.  We need to scan the\n+   segment list multiple times to include indirect equivalences.  */\n \n-static int\n+static void\n add_equivalences (void)\n {\n-  int segment_modified;\n-  gfc_equiv *eq1, *eq2;\n   segment_info *f;\n+  bool more;\n \n-  segment_modified = 0;\n-\n-  for (f = current_segment; f; f = f->next)\n-    if (find_equivalence (f->sym, &eq1, &eq2)) break;\n- \n-  if (f != NULL)\n+  more = TRUE;\n+  while (more)\n     {\n-      add_condition (eq1, eq2);\n-      segment_modified = 1;\n+      more = FALSE;\n+      for (f = current_segment; f; f = f->next)\n+\t{\n+\t  if (!f->sym->equiv_built)\n+\t    {\n+\t      f->sym->equiv_built = 1;\n+\t      more = find_equivalence (f);\n+\t    }\n+\t}\n     }\n- \n-  return segment_modified;\n }\n     \n     \n@@ -603,43 +723,28 @@ add_equivalences (void)\n static void\n new_segment (gfc_symbol *common_sym, gfc_symbol *sym)\n {\n-  segment_info *v;\n-  int length;\n+  HOST_WIDE_INT length;\n \n   current_segment = get_segment_info ();\n   current_segment->sym = sym;\n   current_segment->offset = current_offset;\n   length = calculate_length (sym);\n   current_segment->length = length;\n  \n-  sym->mark = 1;\n-\n   /* Add all object directly or indirectly equivalenced with this common\n      variable.  */ \n-  while (add_equivalences ());\n+  add_equivalences ();\n \n-  /* Calculate the storage size to hold the common block.  */\n-  for (v = current_segment; v; v = v->next)\n-    {\n-      if (v->offset < 0)\n-        gfc_error (\"the equivalence set for '%s' cause an invalid extension \"\n-                   \"to COMMON '%s' at %L\",\n-                   sym->name, common_sym->name, &common_sym->declared_at);\n-      if (current_length < (v->offset + v->length))\n-        current_length = v->offset + v->length;\n-    }\n+  if (current_segment->offset < 0)\n+    gfc_error (\"The equivalence set for '%s' cause an invalid extension \"\n+\t       \"to COMMON '%s' at %L\",\n+\t       sym->name, common_sym->name, &common_sym->declared_at);\n \n   /* The offset of the next common variable.  */ \n   current_offset += length;\n \n-  /* Append the current segment to the current common.  */\n-  v = current_segment;\n-  while (v->next != NULL)\n-    v = v->next;\n-\n-  v->next = current_common;\n-  current_common = current_segment;\n-  current_segment = NULL;\n+  /* Add these to the common block.  */\n+  current_common = add_segments (current_common, current_segment);\n }\n \n \n@@ -651,36 +756,27 @@ finish_equivalences (gfc_namespace *ns)\n   gfc_equiv *z, *y;\n   gfc_symbol *sym;\n   segment_info *v;\n-  int min_offset;\n+  HOST_WIDE_INT min_offset;\n \n   for (z = ns->equiv; z; z = z->next)\n     for (y= z->eq; y; y = y->eq)\n       {\n         if (y->used) continue;\n         sym = z->expr->symtree->n.sym;\n-        current_length = 0;\n         current_segment = get_segment_info ();\n         current_segment->sym = sym;\n         current_segment->offset = 0;\n         current_segment->length = calculate_length (sym);\n-        sym->mark = 1;\n \n-        /* All object directly or indrectly equivalenced with this symbol.  */\n-        while (add_equivalences ());\n+        /* All objects directly or indrectly equivalenced with this symbol.  */\n+        add_equivalences ();\n \n         /* Calculate the minimal offset.  */\n-        min_offset = 0;\n-        for (v = current_segment; v; v = v->next)\n-          min_offset = (min_offset >= v->offset) ? v->offset : min_offset;\n+        min_offset = current_segment->offset;\n \n-        /* Adjust the offset of each equivalence object, and calculate the\n-           maximal storage size to hold them.  */\n+        /* Adjust the offset of each equivalence object.  */\n         for (v = current_segment; v; v = v->next)\n-          {\n-            v->offset -= min_offset;\n-            if (current_length < (v->offset + v->length))\n-              current_length = v->offset + v->length;\n-          }\n+\t  v->offset -= min_offset;\n \n         current_common = current_segment;\n         create_common (NULL);\n@@ -697,22 +793,13 @@ translate_common (gfc_symbol *common_sym, gfc_symbol *var_list)\n   gfc_symbol *sym;\n \n   current_common = NULL;\n-  current_length = 0;\n   current_offset = 0;\n \n-  /* Mark bits indicate which symbols have already been placed in a\n-     common area.  */\n+  /* Add symbols to the segment.  */\n   for (sym = var_list; sym; sym = sym->common_next)\n-    sym->mark = 0;\n-\n-  for (;;)\n     {\n-      for (sym = var_list; sym; sym = sym->common_next)\n-        if (!sym->mark) break;\n- \n-      /* All symbols have been placed in a common.  */\n-      if (sym == NULL) break;\n-      new_segment (common_sym, sym);\n+      if (! sym->equiv_built)\n+\tnew_segment (common_sym, sym);\n     }\n \n   create_common (common_sym);"}, {"sha": "5feef48c9272577c2a29c4c0b55bf170754b08f0", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5291e69adedd50438763fcaf9c2bfd05d75ca5ff/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5291e69adedd50438763fcaf9c2bfd05d75ca5ff/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5291e69adedd50438763fcaf9c2bfd05d75ca5ff", "patch": "@@ -1,3 +1,9 @@\n+2004-05-23  Paul Brook  <paul@codesourcery.com>\n+\tVictor Leikehman  <lei@haifasphere.co.il>\n+\n+\t* gfortran.fortran-torture/execute/common_init_1.f90: New test.\n+\t* gfortran.fortran-torture/execute/equiv_init.f90: New test.\n+\n 2004-05-22  Mark Mitchell  <mark@codesourcery.com>\n \n \tPR c++/15285"}, {"sha": "9e5aec0f72623f413fc66d49bd979b594503a7d0", "filename": "gcc/testsuite/gfortran.fortran-torture/execute/common_init_1.f90", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5291e69adedd50438763fcaf9c2bfd05d75ca5ff/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fcommon_init_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5291e69adedd50438763fcaf9c2bfd05d75ca5ff/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fcommon_init_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fcommon_init_1.f90?ref=5291e69adedd50438763fcaf9c2bfd05d75ca5ff", "patch": "@@ -0,0 +1,24 @@\n+! Program to test initialization of common blocks.\n+subroutine test()\n+  character(len=15) :: c\n+  integer d, e\n+  real f\n+  common /block2/ c\n+  common /block/ d, e, f\n+\n+  if ((d .ne. 42) .or. (e .ne. 43) .or. (f .ne. 2.0)) call abort ()\n+  if (c .ne. \"Hello World    \") call abort ()\n+end subroutine\n+\n+program prog\n+  integer a(2)\n+  real b\n+  character(len=15) :: s\n+  common /block/ a, b\n+  common /block2/ s\n+  data b, a/2.0, 42, 43/\n+  data s /\"Hello World\"/\n+\n+  call test ()\n+end program\n+"}, {"sha": "d918097c5eeb2bbb9fd8e48e6d9dd475558d26ca", "filename": "gcc/testsuite/gfortran.fortran-torture/execute/equiv_init_1.f90", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5291e69adedd50438763fcaf9c2bfd05d75ca5ff/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fequiv_init_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5291e69adedd50438763fcaf9c2bfd05d75ca5ff/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fequiv_init_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fequiv_init_1.f90?ref=5291e69adedd50438763fcaf9c2bfd05d75ca5ff", "patch": "@@ -0,0 +1,94 @@\n+! Program to test initialization of equivalence blocks.  PR13742.\n+! Some forms are not yet implemented.  These are indicated by !!$\n+\n+subroutine test0s\n+  character*10 :: x = \"abcdefghij\" \n+  character*10 :: y\n+  equivalence (x,y)\n+\n+  character*10 :: xs(10) \n+  character*10 :: ys(10)\n+  equivalence (xs,ys)\n+  data xs /10*\"abcdefghij\"/\n+\n+  if (y.ne.\"abcdefghij\") call abort\n+  if (ys(1).ne.\"abcdefghij\") call abort\n+  if (ys(10).ne.\"abcdefghij\") call abort\n+end\n+  \n+subroutine test0\n+  integer :: x = 123\n+  integer :: y\n+  equivalence (x,y)\n+  if (y.ne.123) call abort\n+end\n+\n+subroutine test1\n+  integer :: a(3)\n+  integer :: x = 1\n+  integer :: y\n+  integer :: z = 3\n+  equivalence (a(1), x)\n+  equivalence (a(3), z)\n+  if (x.ne.1) call abort\n+  if (z.ne.3) call abort\n+  if (a(1).ne.1) call abort\n+  if (a(3).ne.3) call abort\n+end\n+\n+subroutine test2\n+  integer :: x\n+  integer :: z\n+  integer :: a(3) = 123\n+  equivalence (a(1), x)\n+  equivalence (a(3), z)\n+  if (x.ne.123) call abort\n+  if (z.ne.123) call abort\n+end\n+\n+subroutine test3\n+  integer :: x\n+!!$  integer :: y = 2\n+  integer :: z\n+  integer :: a(3)\n+  equivalence (a(1),x), (a(2),y), (a(3),z)\n+  data a(1) /1/, a(3) /3/\n+  if (x.ne.1) call abort\n+!!$  if (y.ne.2) call abort\n+  if (z.ne.3) call abort\n+end\n+\n+subroutine test4\n+  integer a(2)\n+  integer b(2)\n+  integer c\n+  equivalence (a(2),b(1)), (b(2),c)\n+  data a/1,2/\n+  data c/3/\n+  if (b(1).ne.2) call abort\n+  if (b(2).ne.3) call abort\n+end\n+\n+!!$subroutine test5\n+!!$  integer a(2)\n+!!$  integer b(2)\n+!!$  integer c\n+!!$  equivalence (a(2),b(1)), (b(2),c)\n+!!$  data a(1)/1/\n+!!$  data b(1)/2/\n+!!$  data c/3/\n+!!$  if (a(2).ne.2) call abort\n+!!$  if (b(2).ne.3) call abort\n+!!$  print *, \"Passed test5\"\n+!!$end\n+  \n+program main\n+  call test0s\n+  call test0\n+  call test1\n+  call test2\n+  call test3\n+  call test4\n+!!$  call test5\n+end\n+"}]}