{"sha": "4d87bd39bafae86747944b2f8c53fdbc43b8dac3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGQ4N2JkMzliYWZhZTg2NzQ3OTQ0YjJmOGM1M2ZkYmM0M2I4ZGFjMw==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-11-30T09:55:43Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-11-30T09:55:43Z"}, "message": "expansion: Improve double-word modulo by certain constant divisors [PR97459]\n\nAs discussed in the PR, e.g. on x86_64 (both -m32 and -m64) there is no\ndouble-word modulo and so we expand it to a __{,u}mod[dt]i3 call.\nFor certain constant divisors we can do better.  E.g. consider\n32-bit word-size, 0x100000000ULL % 3 == 1, so we can use partly the Hacker's\ndelight modulo by summing digits approach and optimize\nunsigned long long foo (unsigned long long x) { return x % 3; }\nas\nunsigned long long foo (unsigned long long x) {\n  unsigned int sum, carry;\n  carry = __builtin_add_overflow ((unsigned int) x, (unsigned int) (x >> 32), &sum);\n  sum += carry;\n  return sum % 3;\n}\nSimilarly, 0x10000000ULL % 5 == 1 (note, 1 << 28), so\nunsigned long long bar (unsigned long long x) { return x % 5; }\nas\nunsigned long long bar (unsigned long long x) {\n  unsigned int sum = x & ((1 << 28) - 1);\n  sum += (x >> 28) & ((1 << 28) - 1);\n  sum += (x >> 56);\n  return sum % 5;\n}\netc.\nAnd we can do also signed modulo,\nlong long baz (long long x) { return x % 5; }\nas\nlong long baz (long long x) {\n  unsigned int sum = x & ((1 << 28) - 1);\n  sum += ((unsigned long long) x >> 28) & ((1 << 28) - 1);\n  sum += ((unsigned long long) x >> 56);\n  /* Sum adjustment for negative x.  */\n  sum += (x >> 63) & 3;\n  unsigned int rem = sum % 5;\n  /* And finally adjust it to the right interval for negative values.  */\n  return (int) (rem + ((x >> 63) & -4));\n}\n\n2020-11-30  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR rtl-optimization/97459\n\t* internal-fn.h (expand_addsub_overflow): Declare.\n\t* internal-fn.c (expand_addsub_overflow): No longer static.\n\t* optabs.c (expand_doubleword_mod): New function.\n\t(expand_binop): Optimize double-word mod with constant divisor.\n\n\t* gcc.dg/pr97459-1.c: New test.\n\t* gcc.dg/pr97459-2.c: New test.", "tree": {"sha": "26e6f9fd7b023462353752375cc2bf1f23c00f33", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/26e6f9fd7b023462353752375cc2bf1f23c00f33"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4d87bd39bafae86747944b2f8c53fdbc43b8dac3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d87bd39bafae86747944b2f8c53fdbc43b8dac3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4d87bd39bafae86747944b2f8c53fdbc43b8dac3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d87bd39bafae86747944b2f8c53fdbc43b8dac3/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fbbce1c6e98dec378955b1a591d2dff31caa01f5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fbbce1c6e98dec378955b1a591d2dff31caa01f5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fbbce1c6e98dec378955b1a591d2dff31caa01f5"}], "stats": {"total": 338, "additions": 337, "deletions": 1}, "files": [{"sha": "9c4fd1ca35af95a7d8cda78788861a5f9f380f3b", "filename": "gcc/internal-fn.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d87bd39bafae86747944b2f8c53fdbc43b8dac3/gcc%2Finternal-fn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d87bd39bafae86747944b2f8c53fdbc43b8dac3/gcc%2Finternal-fn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.c?ref=4d87bd39bafae86747944b2f8c53fdbc43b8dac3", "patch": "@@ -798,7 +798,7 @@ expand_ubsan_result_store (rtx target, rtx res)\n /* Add sub/add overflow checking to the statement STMT.\n    CODE says whether the operation is +, or -.  */\n \n-static void\n+void\n expand_addsub_overflow (location_t loc, tree_code code, tree lhs,\n \t\t\ttree arg0, tree arg1, bool unsr_p, bool uns0_p,\n \t\t\tbool uns1_p, bool is_ubsan, tree *datap)"}, {"sha": "2a96b2b921645c7271c1d26b8a85824145ab3199", "filename": "gcc/internal-fn.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d87bd39bafae86747944b2f8c53fdbc43b8dac3/gcc%2Finternal-fn.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d87bd39bafae86747944b2f8c53fdbc43b8dac3/gcc%2Finternal-fn.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.h?ref=4d87bd39bafae86747944b2f8c53fdbc43b8dac3", "patch": "@@ -224,6 +224,8 @@ extern bool internal_gather_scatter_fn_supported_p (internal_fn, tree,\n extern bool internal_check_ptrs_fn_supported_p (internal_fn, tree,\n \t\t\t\t\t\tpoly_uint64, unsigned int);\n \n+extern void expand_addsub_overflow (location_t, tree_code, tree, tree, tree,\n+\t\t\t\t    bool, bool, bool, bool, tree *);\n extern void expand_internal_call (gcall *);\n extern void expand_internal_call (internal_fn, gcall *);\n extern void expand_PHI (internal_fn, gcall *);"}, {"sha": "3d5b07d95ce27906e37331de0ad4a657bd8ae514", "filename": "gcc/optabs.c", "status": "modified", "additions": 223, "deletions": 0, "changes": 223, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d87bd39bafae86747944b2f8c53fdbc43b8dac3/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d87bd39bafae86747944b2f8c53fdbc43b8dac3/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=4d87bd39bafae86747944b2f8c53fdbc43b8dac3", "patch": "@@ -44,6 +44,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"expr.h\"\n #include \"optabs-tree.h\"\n #include \"libfuncs.h\"\n+#include \"internal-fn.h\"\n+#include \"langhooks.h\"\n \n static void prepare_float_lib_cmp (rtx, rtx, enum rtx_code, rtx *,\n \t\t\t\t   machine_mode *);\n@@ -926,6 +928,196 @@ expand_doubleword_mult (machine_mode mode, rtx op0, rtx op1, rtx target,\n   emit_move_insn (product_high, adjust);\n   return product;\n }\n+\n+/* Subroutine of expand_binop.  Optimize unsigned double-word OP0 % OP1 for\n+   constant OP1.  If for some bit in [BITS_PER_WORD / 2, BITS_PER_WORD] range\n+   (prefer higher bits) ((1w << bit) % OP1) == 1, then the modulo can be\n+   computed in word-mode as ((OP0 & (bit - 1)) + ((OP0 >> bit) & (bit - 1))\n+   + (OP0 >> (2 * bit))) % OP1.  Whether we need to sum 2, 3 or 4 values\n+   depends on the bit value, if 2, then carry from the addition needs to be\n+   added too, i.e. like:\n+   sum += __builtin_add_overflow (low, high, &sum)\n+\n+   Optimize signed double-word OP0 % OP1 similarly, just apply some correction\n+   factor to the sum before doing unsigned remainder, in the form of\n+   sum += (((signed) OP0 >> (2 * BITS_PER_WORD - 1)) & const);\n+   then perform unsigned\n+   remainder = sum % OP1;\n+   and finally\n+   remainder += ((signed) OP0 >> (2 * BITS_PER_WORD - 1)) & (1 - OP1);  */\n+\n+static rtx\n+expand_doubleword_mod (machine_mode mode, rtx op0, rtx op1, bool unsignedp)\n+{\n+  if (INTVAL (op1) <= 1)\n+    return NULL_RTX;\n+\n+  rtx_insn *last = get_last_insn ();\n+  for (int bit = BITS_PER_WORD; bit >= BITS_PER_WORD / 2; bit--)\n+    {\n+      wide_int w = wi::shifted_mask (bit, 1, false, 2 * BITS_PER_WORD);\n+      if (wi::ne_p (wi::umod_trunc (w, INTVAL (op1)), 1))\n+\tcontinue;\n+      rtx sum = NULL_RTX, mask = NULL_RTX;\n+      if (bit == BITS_PER_WORD)\n+\t{\n+\t  /* For signed modulo we need to add correction to the sum\n+\t     and that might again overflow.  */\n+\t  if (!unsignedp)\n+\t    continue;\n+\t  if (optab_handler (uaddv4_optab, word_mode) == CODE_FOR_nothing)\n+\t    continue;\n+\t  tree wtype = lang_hooks.types.type_for_mode (word_mode, 1);\n+\t  if (wtype == NULL_TREE)\n+\t    continue;\n+\t  tree ctype = build_complex_type (wtype);\n+\t  if (TYPE_MODE (ctype) != GET_MODE_COMPLEX_MODE (word_mode))\n+\t    continue;\n+\t  machine_mode cmode = TYPE_MODE (ctype);\n+\t  rtx op00 = operand_subword_force (op0, 0, mode);\n+\t  rtx op01 = operand_subword_force (op0, 1, mode);\n+\t  rtx cres = gen_rtx_CONCAT (cmode, gen_reg_rtx (word_mode),\n+\t\t\t\t     gen_reg_rtx (word_mode));\n+\t  tree lhs = make_tree (ctype, cres);\n+\t  tree arg0 = make_tree (wtype, op00);\n+\t  tree arg1 = make_tree (wtype, op01);\n+\t  expand_addsub_overflow (UNKNOWN_LOCATION, PLUS_EXPR, lhs, arg0,\n+\t\t\t\t  arg1, true, true, true, false, NULL);\n+\t  sum = expand_simple_binop (word_mode, PLUS, XEXP (cres, 0),\n+\t\t\t\t     XEXP (cres, 1), NULL_RTX, 1,\n+\t\t\t\t     OPTAB_DIRECT);\n+\t  if (sum == NULL_RTX)\n+\t    return NULL_RTX;\n+\t}\n+      else\n+\t{\n+\t  /* Code below uses GEN_INT, so we need the masks to be representable\n+\t     in HOST_WIDE_INTs.  */\n+\t  if (bit >= HOST_BITS_PER_WIDE_INT)\n+\t    continue;\n+\t  /* If op0 is e.g. -1 or -2 unsigned, then the 2 additions might\n+\t     overflow.  Consider 64-bit -1ULL for word size 32, if we add\n+\t     0x7fffffffU + 0x7fffffffU + 3U, it wraps around to 1.  */\n+\t  if (bit == BITS_PER_WORD - 1)\n+\t    continue;\n+\n+\t  int count = (2 * BITS_PER_WORD + bit - 1) / bit;\n+\t  rtx sum_corr = NULL_RTX;\n+\n+\t  if (!unsignedp)\n+\t    {\n+\t      /* For signed modulo, compute it as unsigned modulo of\n+\t\t sum with a correction added to it if OP0 is negative,\n+\t\t such that the result can be computed as unsigned\n+\t\t remainder + ((OP1 >> (2 * BITS_PER_WORD - 1)) & (1 - OP1).  */\n+\t      w = wi::min_value (2 * BITS_PER_WORD, SIGNED);\n+\t      wide_int wmod1 = wi::umod_trunc (w, INTVAL (op1));\n+\t      wide_int wmod2 = wi::smod_trunc (w, INTVAL (op1));\n+\t      /* wmod2 == -wmod1.  */\n+\t      wmod2 = wmod2 + (INTVAL (op1) - 1);\n+\t      if (wi::ne_p (wmod1, wmod2))\n+\t\t{\n+\t\t  wide_int wcorr = wmod2 - wmod1;\n+\t\t  if (wi::neg_p (w))\n+\t\t    wcorr = wcorr + INTVAL (op1);\n+\t\t  /* Now verify if the count sums can't overflow, and punt\n+\t\t     if they could.  */\n+\t\t  w = wi::mask (bit, false, 2 * BITS_PER_WORD);\n+\t\t  w = w * (count - 1);\n+\t\t  w = w + wi::mask (2 * BITS_PER_WORD - (count - 1) * bit,\n+\t\t\t\t    false, 2 * BITS_PER_WORD);\n+\t\t  w = w + wcorr;\n+\t\t  w = wi::lrshift (w, BITS_PER_WORD);\n+\t\t  if (wi::ne_p (w, 0))\n+\t\t    continue;\n+\n+\t\t  mask = operand_subword_force (op0, WORDS_BIG_ENDIAN ? 0 : 1,\n+\t\t\t\t\t\tmode);\n+\t\t  mask = expand_simple_binop (word_mode, ASHIFTRT, mask,\n+\t\t\t\t\t      GEN_INT (BITS_PER_WORD - 1),\n+\t\t\t\t\t      NULL_RTX, 0, OPTAB_DIRECT);\n+\t\t  if (mask == NULL_RTX)\n+\t\t    return NULL_RTX;\n+\t\t  sum_corr = immed_wide_int_const (wcorr, word_mode);\n+\t\t  sum_corr = expand_simple_binop (word_mode, AND, mask,\n+\t\t\t\t\t\t  sum_corr, NULL_RTX, 1,\n+\t\t\t\t\t\t  OPTAB_DIRECT);\n+\t\t  if (sum_corr == NULL_RTX)\n+\t\t    return NULL_RTX;\n+\t\t}\n+\t    }\n+\n+\t  for (int i = 0; i < count; i++)\n+\t    {\n+\t      rtx v = op0;\n+\t      if (i)\n+\t\tv = expand_simple_binop (mode, LSHIFTRT, v, GEN_INT (i * bit),\n+\t\t\t\t\t NULL_RTX, 1, OPTAB_DIRECT);\n+\t      if (v == NULL_RTX)\n+\t\treturn NULL_RTX;\n+\t      v = lowpart_subreg (word_mode, v, mode);\n+\t      if (v == NULL_RTX)\n+\t\treturn NULL_RTX;\n+\t      if (i != count - 1)\n+\t\tv = expand_simple_binop (word_mode, AND, v,\n+\t\t\t\t\t GEN_INT ((HOST_WIDE_INT_1U << bit)\n+\t\t\t\t\t\t  - 1), NULL_RTX, 1,\n+\t\t\t\t\t OPTAB_DIRECT);\n+\t      if (v == NULL_RTX)\n+\t\treturn NULL_RTX;\n+\t      if (sum == NULL_RTX)\n+\t\tsum = v;\n+\t      else\n+\t\tsum = expand_simple_binop (word_mode, PLUS, sum, v, NULL_RTX,\n+\t\t\t\t\t   1, OPTAB_DIRECT);\n+\t      if (sum == NULL_RTX)\n+\t\treturn NULL_RTX;\n+\t    }\n+\t  if (sum_corr)\n+\t    {\n+\t      sum = expand_simple_binop (word_mode, PLUS, sum, sum_corr,\n+\t\t\t\t\t NULL_RTX, 1, OPTAB_DIRECT);\n+\t      if (sum == NULL_RTX)\n+\t\treturn NULL_RTX;\n+\t    }\n+\t}\n+      rtx remainder = expand_divmod (1, TRUNC_MOD_EXPR, word_mode, sum, op1,\n+\t\t\t\t     NULL_RTX, 1);\n+      if (remainder == NULL_RTX)\n+\treturn NULL_RTX;\n+\n+      if (!unsignedp)\n+\t{\n+\t  if (mask == NULL_RTX)\n+\t    {\n+\t      mask = operand_subword_force (op0, WORDS_BIG_ENDIAN ? 0 : 1,\n+\t\t\t\t\t    mode);\n+\t      mask = expand_simple_binop (word_mode, ASHIFTRT, mask,\n+\t\t\t\t\t  GEN_INT (BITS_PER_WORD - 1),\n+\t\t\t\t\t  NULL_RTX, 0, OPTAB_DIRECT);\n+\t      if (mask == NULL_RTX)\n+\t\treturn NULL_RTX;\n+\t    }\n+\t  mask = expand_simple_binop (word_mode, AND, mask,\n+\t\t\t\t      GEN_INT (1 - INTVAL (op1)),\n+\t\t\t\t      NULL_RTX, 1, OPTAB_DIRECT);\n+\t  if (mask == NULL_RTX)\n+\t    return NULL_RTX;\n+\t  remainder = expand_simple_binop (word_mode, PLUS, remainder,\n+\t\t\t\t\t   mask, NULL_RTX, 1, OPTAB_DIRECT);\n+\t  if (remainder == NULL_RTX)\n+\t    return NULL_RTX;\n+\t}\n+\n+      remainder = convert_modes (mode, word_mode, remainder, unsignedp);\n+      /* Punt if we need any library calls.  */\n+      for (; last; last = NEXT_INSN (last))\n+\tif (CALL_P (last))\n+\t  return NULL_RTX;\n+      return remainder;\n+    }\n+  return NULL_RTX;\n+}\n \f\n /* Wrapper around expand_binop which takes an rtx code to specify\n    the operation to perform, not an optab pointer.  All other\n@@ -1806,6 +1998,37 @@ expand_binop (machine_mode mode, optab binoptab, rtx op0, rtx op1,\n \t}\n     }\n \n+  /* Attempt to synthetize double word modulo by constant divisor.  */\n+  if ((binoptab == umod_optab || binoptab == smod_optab)\n+      && optimize\n+      && CONST_INT_P (op1)\n+      && is_int_mode (mode, &int_mode)\n+      && GET_MODE_SIZE (int_mode) == 2 * UNITS_PER_WORD\n+      && optab_handler (lshr_optab, int_mode) != CODE_FOR_nothing\n+      && optab_handler (and_optab, word_mode) != CODE_FOR_nothing\n+      && optab_handler (add_optab, word_mode) != CODE_FOR_nothing\n+      && optimize_insn_for_speed_p ())\n+    {\n+      rtx remainder = expand_doubleword_mod (int_mode, op0, op1,\n+\t\t\t\t\t     binoptab == umod_optab);\n+      if (remainder != NULL_RTX)\n+\t{\n+\t  if (optab_handler (mov_optab, int_mode) != CODE_FOR_nothing)\n+\t    {\n+\t      rtx_insn *move = emit_move_insn (target ? target : remainder,\n+\t\t\t\t\t       remainder);\n+\t      set_dst_reg_note (move,\n+\t\t\t\tREG_EQUAL,\n+\t\t\t\tgen_rtx_fmt_ee (UMOD, int_mode,\n+\t\t\t\t\t\tcopy_rtx (op0), op1),\n+\t\t\t\ttarget ? target : remainder);\n+\t    }\n+\t  return remainder;\n+\t}\n+      else\n+\tdelete_insns_since (last);\n+    }\n+\n   /* It can't be open-coded in this mode.\n      Use a library call if one is available and caller says that's ok.  */\n "}, {"sha": "3dcbb1dbea2b80a26e9fd58e936794243dceae55", "filename": "gcc/testsuite/gcc.dg/pr97459-1.c", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d87bd39bafae86747944b2f8c53fdbc43b8dac3/gcc%2Ftestsuite%2Fgcc.dg%2Fpr97459-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d87bd39bafae86747944b2f8c53fdbc43b8dac3/gcc%2Ftestsuite%2Fgcc.dg%2Fpr97459-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr97459-1.c?ref=4d87bd39bafae86747944b2f8c53fdbc43b8dac3", "patch": "@@ -0,0 +1,54 @@\n+/* PR rtl-optimization/97459 */\n+/* { dg-do run } */\n+/* { dg-options \"-O2\" } */\n+/* { dg-additional-options \"-DEXPENSIVE\" { target run_expensive_tests } } */\n+\n+#ifdef __SIZEOF_INT128__\n+typedef __uint128_t T;\n+#else\n+typedef unsigned long long T;\n+#endif\n+\n+T __attribute__((noipa)) foo (T x, T n) { return x % n; }\n+#define C(n) T __attribute__((noipa)) foo##n (T x) { return x % (n - 10000); }\n+\n+#define C1(n) C(n##1) C(n##3) C(n##5) C(n##7) C(n##9)\n+#define C2(n) C1(n##0) C1(n##1) C1(n##2) C1(n##3) C1(n##4) \\\n+\t      C1(n##5) C1(n##6) C1(n##7) C1(n##8) C1(n##9)\n+#ifdef EXPENSIVE\n+#define C3(n) C2(n##0) C2(n##1) C2(n##2) C2(n##3) C2(n##4) \\\n+\t      C2(n##5) C2(n##6) C2(n##7) C2(n##8) C2(n##9)\n+#define C4(n) C3(n##0) C3(n##1) C3(n##2) C3(n##3) C3(n##4) \\\n+\t      C3(n##5) C3(n##6) C3(n##7) C3(n##8) C3(n##9)\n+#else\n+#define C3(n) C2(n##0) C2(n##4) C2(n##9)\n+#define C4(n) C3(n##0) C3(n##3) C3(n##7)\n+#endif\n+#define TESTS C4(1)\n+\n+TESTS\n+\n+struct S { T x; T (*foo) (T); };\n+\n+#undef C\n+#define C(n) { n - 10000, foo##n },\n+\n+struct S tests[] = {\n+TESTS\n+  { 0, 0 }\n+};\n+\n+int\n+main ()\n+{\n+  int i, j, k;\n+  for (k = 0; tests[k].x; k++)\n+    for (i = 0; i < sizeof (T) * __CHAR_BIT__; i++)\n+      for (j = -5; j <= 5; j++)\n+\t{\n+\t  T x = ((T) 1 << i) + j;\n+\t  if (foo (x, tests[k].x) != tests[k].foo (x))\n+\t    __builtin_abort ();\n+\t}\n+  return 0;\n+}"}, {"sha": "83e00cb1f55f84e0e070706dc40f11d7a5864578", "filename": "gcc/testsuite/gcc.dg/pr97459-2.c", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d87bd39bafae86747944b2f8c53fdbc43b8dac3/gcc%2Ftestsuite%2Fgcc.dg%2Fpr97459-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d87bd39bafae86747944b2f8c53fdbc43b8dac3/gcc%2Ftestsuite%2Fgcc.dg%2Fpr97459-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr97459-2.c?ref=4d87bd39bafae86747944b2f8c53fdbc43b8dac3", "patch": "@@ -0,0 +1,57 @@\n+/* PR rtl-optimization/97459 */\n+/* { dg-do run } */\n+/* { dg-options \"-O2\" } */\n+/* { dg-additional-options \"-DEXPENSIVE\" { target run_expensive_tests } } */\n+\n+#ifdef __SIZEOF_INT128__\n+typedef __int128_t T;\n+typedef __uint128_t U;\n+#else\n+typedef long long T;\n+typedef unsigned long long U;\n+#endif\n+\n+T __attribute__((noipa)) foo (T x, T n) { return x % n; }\n+#define C(n) T __attribute__((noipa)) foo##n (T x) { return x % (n - 10000); }\n+\n+#define C1(n) C(n##1) C(n##3) C(n##5) C(n##7) C(n##9)\n+#define C2(n) C1(n##0) C1(n##1) C1(n##2) C1(n##3) C1(n##4) \\\n+\t      C1(n##5) C1(n##6) C1(n##7) C1(n##8) C1(n##9)\n+#ifdef EXPENSIVE\n+#define C3(n) C2(n##0) C2(n##1) C2(n##2) C2(n##3) C2(n##4) \\\n+\t      C2(n##5) C2(n##6) C2(n##7) C2(n##8) C2(n##9)\n+#define C4(n) C3(n##0) C3(n##1) C3(n##2) C3(n##3) C3(n##4) \\\n+\t      C3(n##5) C3(n##6) C3(n##7) C3(n##8) C3(n##9)\n+#else\n+#define C3(n) C2(n##0) C2(n##4) C2(n##9)\n+#define C4(n) C3(n##0) C3(n##3) C3(n##7)\n+#endif\n+#define TESTS C4(1)\n+\n+TESTS\n+\n+struct S { T x; T (*foo) (T); };\n+\n+#undef C\n+#define C(n) { n - 10000, foo##n },\n+\n+struct S tests[] = {\n+TESTS\n+  { 0, 0 }\n+};\n+\n+int\n+main ()\n+{\n+  int i, j, k;\n+  for (k = 0; tests[k].x; k++)\n+    for (i = 0; i < sizeof (T) * __CHAR_BIT__; i++)\n+      for (j = -5; j <= 5; j++)\n+\t{\n+\t  U x = ((U) 1 << i) + j;\n+\t  if (foo ((T) x, tests[k].x) != tests[k].foo ((T) x)\n+\t      || foo ((T) -x, tests[k].x) != tests[k].foo ((T) -x))\n+\t    __builtin_abort ();\n+\t}\n+  return 0;\n+}"}]}