{"sha": "fc07ebe2a7a5e92f798d5e52f23ff2002efa2b97", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmMwN2ViZTJhN2E1ZTkyZjc5OGQ1ZTUyZjIzZmYyMDAyZWZhMmI5Nw==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@redhat.com", "date": "2001-06-14T15:41:57Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2001-06-14T15:41:57Z"}, "message": "re PR libgcj/3144 (java.lang.Date.compareTo() not supported)\n\n\tFix for PR libgcj/3144:\n\t* java/util/Date.java: Merged with Classpath.\n\nFrom-SVN: r43374", "tree": {"sha": "682ddf1a0a956f9fad2aa3b8ed84ba7fe760ccfa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/682ddf1a0a956f9fad2aa3b8ed84ba7fe760ccfa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fc07ebe2a7a5e92f798d5e52f23ff2002efa2b97", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc07ebe2a7a5e92f798d5e52f23ff2002efa2b97", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fc07ebe2a7a5e92f798d5e52f23ff2002efa2b97", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc07ebe2a7a5e92f798d5e52f23ff2002efa2b97/comments", "author": null, "committer": null, "parents": [{"sha": "e323735cb29fa11ab24678c7218afdd6e3e9949d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e323735cb29fa11ab24678c7218afdd6e3e9949d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e323735cb29fa11ab24678c7218afdd6e3e9949d"}], "stats": {"total": 558, "additions": 415, "deletions": 143}, "files": [{"sha": "d632ce11aa2b2324a79a0dac0d036518f6cb76ff", "filename": "libjava/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc07ebe2a7a5e92f798d5e52f23ff2002efa2b97/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc07ebe2a7a5e92f798d5e52f23ff2002efa2b97/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=fc07ebe2a7a5e92f798d5e52f23ff2002efa2b97", "patch": "@@ -1,3 +1,8 @@\n+2001-06-14  Tom Tromey  <tromey@redhat.com>\n+\n+\tFix for PR libgcj/3144:\n+\t* java/util/Date.java: Merged with Classpath.\n+\n 2001-06-12  Tom Tromey  <tromey@redhat.com>\n \n \t* aclocal.m4, configure: Rebuilt."}, {"sha": "edd45f8a929511016b02d9013a69945fa982c763", "filename": "libjava/java/util/Date.java", "status": "modified", "additions": 410, "deletions": 143, "changes": 553, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc07ebe2a7a5e92f798d5e52f23ff2002efa2b97/libjava%2Fjava%2Futil%2FDate.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc07ebe2a7a5e92f798d5e52f23ff2002efa2b97/libjava%2Fjava%2Futil%2FDate.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FDate.java?ref=fc07ebe2a7a5e92f798d5e52f23ff2002efa2b97", "patch": "@@ -1,52 +1,296 @@\n-/* Copyright (C) 1998, 1999, 2000, 2001  Free Software Foundation\n+/* java.util.Date\n+   Copyright (C) 1998, 1999, 2000, 2001 Free Software Foundation, Inc.\n \n-   This file is part of libgcj.\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+As a special exception, if you link this library with other files to\n+produce an executable, this library does not by itself cause the\n+resulting executable to be covered by the GNU General Public License.\n+This exception does not however invalidate any other reasons why the\n+executable file might be covered by the GNU General Public License. */\n \n-This software is copyrighted work licensed under the terms of the\n-Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n-details.  */\n \n package java.util;\n-import java.text.*;\n \n /**\n+ * This class represents a specific time in milliseconds since the epoch.\n+ * The epoch is 1970, January 1 00:00:00.0000 UTC.  \n+ *\n+ * Date is intended to reflect universal time coordinate (UTC), but doesn't\n+ * handle the leap seconds.\n+ *\n+ * Prior to jdk 1.1 this class was the sole Time class and had also \n+ * calendar functionality.  But this can't be localized, so a new Calendar\n+ * class was created, that you should use instead.  The functions which\n+ * get or return a year, month, day etc. are all deprecated and shouldn't be\n+ * used.  Use Calendar instead.\n+ * \n+ * @see Calendar\n+ * @see GregorianCalendar\n+ * @see java.text.DateFormat\n+ * @author Jochen Hoenicke\n  * @author Per Bothner <bothner@cygnus.com>\n- * @date October 24, 1998.\n- */\n-\n-/* Written using \"Java Class Libraries\", 2nd edition, ISBN 0-201-31002-3,\n- * \"The Java Language Specification\", ISBN 0-201-63451-1,\n- * and O'Reilly's \"Java in a Nutshell\".\n- * Status:  Need to re-write toString().\n- *   Missing:  ToGMTString.\n  */\n-public class Date implements java.io.Serializable, Cloneable\n+public class Date implements Cloneable, Comparable, java.io.Serializable\n {\n+  /**\n+   * This is the serialization UID for this class\n+   */\n   private static final long serialVersionUID = 7523967970034938905L;\n \n-  transient private long millis;\n+  /**\n+   * The time in milliseconds since the epoch.\n+   */\n+  private transient long time;\n+\n+  /**\n+   * Creates a new Date Object representing the current time.\n+   */\n+  public Date()\n+  {\n+    time = System.currentTimeMillis();\n+  }\n \n-  public Date() { millis = System.currentTimeMillis(); }\n+  /**\n+   * Creates a new Date Object representing the given time.\n+   * @param time the time in milliseconds since the epoch.\n+   */\n+  public Date(long time)\n+  {\n+    this.time = time;\n+  }\n \n-  public Date(long millis) { this.millis = millis; }\n+  /**\n+   * Creates a new Date Object representing the given time.\n+   * @deprecated use <code>new GregorianCalendar(year+1900, month,\n+   * day)</code> instead.  \n+   */\n+  public Date(int year, int month, int day)\n+  {\n+    time = new GregorianCalendar(year + 1900, month, day).getTimeInMillis();\n+  }\n+\n+  /**\n+   * Creates a new Date Object representing the given time.\n+   * @deprecated use <code>new GregorianCalendar(year+1900, month,\n+   * day, hour, min)</code> instead.  \n+   */\n+  public Date(int year, int month, int day, int hour, int min)\n+  {\n+    time =\n+      new GregorianCalendar(year + 1900, month, day, hour,\n+\t\t\t    min).getTimeInMillis();\n+  }\n+\n+  /*\n+   * Creates a new Date Object representing the given time.\n+   * @deprecated use <code>new GregorianCalendar(year+1900, month,\n+   * day)</code> instead.  \n+   */\n+  public Date(int year, int month, int day, int hour, int min, int sec)\n+  {\n+    time =\n+      new GregorianCalendar(year + 1900, month, day, hour, min,\n+\t\t\t    sec).getTimeInMillis();\n+  }\n+\n+  /**\n+   * Creates a new Date from the given string representation.  This\n+   * does the same as <code>new Date(Date.parse(s))</code>\n+   * @see #parse\n+   * @deprecated use <code>java.text.DateFormat.parse(s)</code> instead.  \n+   */\n+  public Date(String s)\n+  {\n+    time = parse(s);\n+  }\n+\n+  public Object clone()\n+  {\n+    try\n+      {\n+\treturn super.clone();\n+      }\n+    catch (CloneNotSupportedException ex)\n+      {\n+\treturn null;\n+      }\n+  }\n+\n+  /**\n+   * @deprecated Use Calendar with a UTC TimeZone instead.\n+   * @return the time in millis since the epoch.\n+   */\n+  public static long UTC(int year, int month, int date,\n+\t\t\t int hrs, int min, int sec)\n+  {\n+    GregorianCalendar cal =\n+      new GregorianCalendar(year + 1900, month, date, hrs, min, sec);\n+    cal.set(Calendar.ZONE_OFFSET, 0);\n+    cal.set(Calendar.DST_OFFSET, 0);\n+    return cal.getTimeInMillis();\n+  }\n+\n+  /**\n+   * Gets the time represented by this Object\n+   * @return the time in milliseconds since the epoch.\n+   */\n+  public long getTime()\n+  {\n+    return time;\n+  }\n+\n+  /**\n+   * @deprecated use\n+   * Calendar.get(Calendar.ZONE_OFFSET)+Calendar.get(Calendar.DST_OFFSET)\n+   * instead.\n+   * @return The time zone offset in minutes of the local time zone\n+   * relative to UTC.  The time represented by this object is used to\n+   * determine if we should use daylight savings.\n+   */\n+  public int getTimezoneOffset()\n+  {\n+    Calendar cal = Calendar.getInstance();\n+    cal.setTimeInMillis(time);\n+    return (cal.get(Calendar.ZONE_OFFSET)\n+\t    + cal.get(Calendar.DST_OFFSET)) / (60 * 1000);\n+  }\n+\n+  /**\n+   * Sets the time which this Object should represented.\n+   * @param time the time in milliseconds since the epoch.  */\n+  public void setTime(long time)\n+  {\n+    this.time = time;\n+  }\n+\n+  /**\n+   * Tests if this date is after the specified date.\n+   * @param when the other date\n+   * @return true, if the date represented by this Object is\n+   * strictly later than the time represented by when.  \n+   */\n+  public boolean after(Date when)\n+  {\n+    return time > when.time;\n+  }\n+\n+  /**\n+   * Tests if this date is before the specified date.\n+   * @param when the other date\n+   * @return true, if the date represented by when is strictly later\n+   * than the time represented by this object.\n+   */\n+  public boolean before(Date when)\n+  {\n+    return time < when.time;\n+  }\n+\n+  /**\n+   * Compares two dates for equality.\n+   * @param obj the object to compare.\n+   * @return true, if obj is a Date object and the date represented\n+   * by obj is exactly the same as the time represented by this\n+   * object.  \n+   */\n+  public boolean equals(Object obj)\n+  {\n+    return (obj instanceof Date && time == ((Date) obj).time);\n+  }\n \n-  public Date(int year, int month, int date, int hours,\n-\t      int minutes, int seconds)\n+  /**\n+   * Compares two dates.\n+   * @param when the other date.\n+   * @return 0, if the date represented\n+   * by obj is exactly the same as the time represented by this\n+   * object, a negative if this Date is before the other Date, and\n+   * a positive value otherwise.  \n+   */\n+  public int compareTo(Date when)\n   {\n-    setTime(year, month, date, hours, minutes, seconds);\n+    return (time < when.time) ? -1 : (time == when.time) ? 0 : 1;\n   }\n \n-  public Date(int year, int month, int date, int hours, int minutes)\n+  /**\n+   * Compares this Date to another.  This behaves like\n+   * <code>compareTo(Date)</code>, but it may throw a\n+   * <code>ClassCastException</code>\n+   * @param obj the other date.\n+   * @return 0, if the date represented\n+   * by obj is exactly the same as the time represented by this\n+   * object, a negative if this Date is before the other Date, and\n+   * a positive value otherwise.  \n+   * @exception ClassCastException if obj is not of type Date.\n+   */\n+  public int compareTo(Object obj)\n   {\n-    setTime(year, month, date, hours, minutes, 0);\n+    return compareTo((Date) obj);\n   }\n \n-  public Date(int year, int month, int date)\n+  public int hashCode()\n+  {\n+    return (int) time ^ (int) (time >>> 32);\n+  }\n+\n+  private String[] weekNames = { \"Sun\", \"Mon\", \"Tue\", \"Wed\",\n+\t\t\t\t \"Thu\", \"Fri\", \"Sat\" };\n+  \n+  private String[] monthNames = { \"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\",\n+\t\t\t\t  \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\" };\n+  \n+  public String toString()\n+  {\n+    Calendar cal = Calendar.getInstance();\n+    cal.setTimeInMillis(time);\n+    String day = \"0\" + cal.get(Calendar.DATE);\n+    String hour = \"0\" + cal.get(Calendar.HOUR_OF_DAY);\n+    String min = \"0\" + cal.get(Calendar.MINUTE);\n+    String sec = \"0\" + cal.get(Calendar.SECOND);\n+    String year = \"000\" + cal.get(Calendar.YEAR);\n+    return weekNames[cal.get(Calendar.DAY_OF_WEEK) - 1] + \" \"\n+      + monthNames[cal.get(Calendar.MONTH)] + \" \"\n+      + day.substring(day.length() - 2) + \" \"\n+      + hour.substring(hour.length() - 2) + \":\"\n+      + min.substring(min.length() - 2) + \":\"\n+      + sec.substring(sec.length() - 2) + \" \"\n+      +\n+      cal.getTimeZone().getDisplayName(cal.getTimeZone().inDaylightTime(this),\n+\t\t\t\t       TimeZone.SHORT) + \" \" +\n+      year.substring(year.length() - 4);\n+  }\n+\n+  /** Format this object in a locale-specific way.\n+   * @deprecated Use DateFormat.format(Date)\n+   */\n+  public String toLocaleString()\n   {\n-    setTime(year, month, date, 0, 0, 0);\n+    return java.text.DateFormat.getInstance().format(this);\n   }\n \n-  public Date (String s) { this(parse(s)); }\n+  /** Format this object in a standard format in the GMT timezone.\n+   * @deprecated Use DateFormat.format(Date) with a GMT TimeZone.\n+   */\n+  public String toGMTString()\n+  {\n+    java.text.DateFormat format = java.text.DateFormat.getInstance();\n+    format.setTimeZone(TimeZone.getTimeZone(\"GMT\"));\n+    return format.format(this);\n+  }\n \n   private static int skipParens(String string, int offset)\n   {\n@@ -134,6 +378,10 @@ private static boolean parseDayOfWeek(String tok)\n     return false;\n   }\n \n+  /** Parse a String and return the time it represents.\n+   * @param s The String to parse.\n+   * @deprecated Use DateFormat.parse(String)\n+   */\n   public static long parse(String string)\n   {\n     // Initialize date/time fields before parsing begins.\n@@ -331,164 +579,183 @@ else if (tok.charAt(1) != 'S')\n \t\t-timezone * 60 * 1000);\n   }\n \n-  public boolean after (Date when) { return this.millis > when.millis; }\n-  public boolean before (Date when) { return this.millis < when.millis; }\n-\n-  public boolean equals(Object obj)\n-  {\n-    return (obj != null && obj instanceof Date\n-\t    && ((Date)obj).millis == this.millis);\n-  }\n-\n-  public long getTime() { return millis; }\n-\n-  public int hashCode()\n-  {\n-    return (int)(millis^(millis>>>32));\n-  }\n-\n-  private void setTime(int year, int month, int date,\n-\t\t       int hours, int minutes, int seconds)\n-  {\n-    Calendar cal = new GregorianCalendar(year+1900, month, date,\n-\t\t\t\t\t hours, minutes, seconds);\n-    millis = cal.getTimeInMillis();\n-  }\n-\n-  public void setTime(long millis) { this.millis = millis; }\n-\n-  private int getField (int fld)\n-  {\n-    Calendar cal = new GregorianCalendar();\n-    cal.setTime(this);\n-    return cal.get(fld);\n-  }\n-\n-  public int getYear ()\n-  {\n-    return getField(Calendar.YEAR) - 1900;\n-  }\n-\n-  public int getMonth ()\n-  {\n-    return getField(Calendar.MONTH);\n-  }\n-\n-  public int getDate ()\n-  {\n-    return getField(Calendar.DATE);\n-  }\n-\n-  public int getDay ()\n-  {\n-    return getField(Calendar.DAY_OF_WEEK) - 1;\n-  }\n-\n-  public int getHours ()\n-  {\n-    return getField(Calendar.HOUR_OF_DAY);\n-  }\n-\n-  public int getMinutes ()\n-  {\n-    return getField(Calendar.MINUTE);\n-  }\n-\n-  public int getSeconds ()\n+  /**\n+   * @return the year minus 1900 represented by this date object.\n+   * @deprecated Use Calendar instead of Date, and use get(Calendar.YEAR)\n+   * instead.  Note about the 1900 difference in year.\n+   */\n+  public int getYear()\n   {\n-    return getField(Calendar.SECOND);\n+    Calendar cal = Calendar.getInstance();\n+    cal.setTimeInMillis(time);\n+    return cal.get(Calendar.YEAR) - 1900;\n   }\n \n-  private void setField (int fld, int value)\n+  /**\n+   * Sets the year to year minus 1900, not changing the other fields.\n+   * @param year the year minus 1900.\n+   * @deprecated Use Calendar instead of Date, and use\n+   * set(Calendar.YEAR, year) instead.  Note about the 1900\n+   * difference in year.  \n+   */\n+  public void setYear(int year)\n   {\n-    Calendar cal = new GregorianCalendar();\n-    cal.setTime(this);\n-    cal.set(fld, value);\n-    millis = cal.getTimeInMillis();\n+    Calendar cal = Calendar.getInstance();\n+    cal.setTimeInMillis(time);\n+    cal.set(Calendar.YEAR, 1900 + year);\n+    time = cal.getTimeInMillis();\n   }\n \n-  public void setYear (int year)\n+  /**\n+   * @return the month represented by this date object (zero based).\n+   * @deprecated Use Calendar instead of Date, and use get(Calendar.MONTH)\n+   * instead.\n+   */\n+  public int getMonth()\n   {\n-    setField(Calendar.YEAR, 1900 + year);\n+    Calendar cal = Calendar.getInstance();\n+    cal.setTimeInMillis(time);\n+    return cal.get(Calendar.MONTH);\n   }\n \n-  public void setMonth (int month)\n+  /**\n+   * Sets the month to the given value, not changing the other fields.\n+   * @param month the month, zero based.\n+   * @deprecated Use Calendar instead of Date, and use\n+   * set(Calendar.MONTH, month) instead. \n+   */\n+  public void setMonth(int month)\n   {\n-    setField(Calendar.MONTH, month);\n+    Calendar cal = Calendar.getInstance();\n+    cal.setTimeInMillis(time);\n+    cal.set(Calendar.MONTH, month);\n+    time = cal.getTimeInMillis();\n   }\n \n-  public void setDate (int date)\n+  /**\n+   * @return the day of month represented by this date object.\n+   * @deprecated Use Calendar instead of Date, and use get(Calendar.DATE)\n+   * instead.\n+   */\n+  public int getDate()\n   {\n-    setField(Calendar.DATE, date);\n+    Calendar cal = Calendar.getInstance();\n+    cal.setTimeInMillis(time);\n+    return cal.get(Calendar.DATE);\n   }\n \n-  public void setHours (int hours)\n+  /**\n+   * Sets the date to the given value, not changing the other fields.\n+   * @param date the date.\n+   * @deprecated Use Calendar instead of Date, and use\n+   * set(Calendar.DATE, date) instead. \n+   */\n+  public void setDate(int date)\n   {\n-    setField(Calendar.HOUR_OF_DAY, hours);\n+    Calendar cal = Calendar.getInstance();\n+    cal.setTimeInMillis(time);\n+    cal.set(Calendar.DATE, date);\n+    time = cal.getTimeInMillis();\n   }\n \n-  public void setMinutes (int minutes)\n+  /**\n+   * @return the day represented by this date object.\n+   * @deprecated Use Calendar instead of Date, and use get(Calendar.DAY_OF_WEEK)\n+   * instead.\n+   */\n+  public int getDay()\n   {\n-    setField(Calendar.MINUTE, minutes);\n+    Calendar cal = Calendar.getInstance();\n+    cal.setTimeInMillis(time);\n+    return cal.get(Calendar.DAY_OF_WEEK);\n   }\n \n-  public void setSeconds (int seconds)\n+  /**\n+   * @return the hours represented by this date object.\n+   * @deprecated Use Calendar instead of Date, and use get(Calendar.HOUR_OF_DAY)\n+   * instead.\n+   */\n+  public int getHours()\n   {\n-    setField(Calendar.SECOND, seconds);\n+    Calendar cal = Calendar.getInstance();\n+    cal.setTimeInMillis(time);\n+    return cal.get(Calendar.HOUR_OF_DAY);\n   }\n \n-  public int getTimezoneOffset ()\n+  /**\n+   * Sets the hours to the given value, not changing the other fields.\n+   * @param hours the hours.\n+   * @deprecated Use Calendar instead of Date, and use\n+   * set(Calendar.HOUR_OF_DAY, hours) instead. \n+   */\n+  public void setHours(int hours)\n   {\n-    Calendar cal = new GregorianCalendar(); \n-    cal.setTime(this);\n-    return - (cal.get(Calendar.ZONE_OFFSET)\n-\t      + cal.get(Calendar.DST_OFFSET)/(60*1000));\n+    Calendar cal = Calendar.getInstance();\n+    cal.setTimeInMillis(time);\n+    cal.set(Calendar.HOUR_OF_DAY, hours);\n+    time = cal.getTimeInMillis();\n   }\n \n-  public String toString ()\n+  /**\n+   * @return the minutes represented by this date object.\n+   * @deprecated Use Calendar instead of Date, and use get(Calendar.MINUTE)\n+   * instead.\n+   */\n+  public int getMinutes()\n   {\n-    // This is slow, but does it matter?  There is no particularly\n-    // fast way to do it, because we need the timezone offset, which\n-    // we don't store.  Unix ctime() doesn't provide this information.\n-    SimpleDateFormat fmt = new SimpleDateFormat (\"E MMM dd HH:mm:ss z yyyy\",\n-\t\t\t\t\t\t Locale.US);\n-    fmt.setTimeZone(TimeZone.getDefault());\n-    return fmt.format(this);\n+    Calendar cal = Calendar.getInstance();\n+    cal.setTimeInMillis(time);\n+    return cal.get(Calendar.MINUTE);\n   }\n \n-  public String toGMTString ()\n+  /**\n+   * Sets the minutes to the given value, not changing the other fields.\n+   * @param minutes the minutes.\n+   * @deprecated Use Calendar instead of Date, and use\n+   * set(Calendar.MINUTE, minutes) instead. \n+   */\n+  public void setMinutes(int minutes)\n   {\n-    // This method is deprecated.  We don't care if it is very slow.\n-    SimpleDateFormat fmt = new SimpleDateFormat (\"d MMM yyyy HH:mm:ss 'GMT'\",\n-\t\t\t\t\t\t Locale.US);\n-    fmt.setTimeZone(TimeZone.getTimeZone(\"GMT\"));\n-    return fmt.format(this);\n+    Calendar cal = Calendar.getInstance();\n+    cal.setTimeInMillis(time);\n+    cal.set(Calendar.MINUTE, minutes);\n+    time = cal.getTimeInMillis();\n   }\n \n-  public String toLocaleString ()\n+  /**\n+   * @return the seconds represented by this date object.\n+   * @deprecated Use Calendar instead of Date, and use get(Calendar.SECOND)\n+   * instead.\n+   */\n+  public int getSeconds()\n   {\n-    // This method is deprecated.  We don't care if it is very slow.\n-    DateFormat fmt = DateFormat.getDateTimeInstance();\n-    fmt.setTimeZone(TimeZone.getDefault());\n-    return fmt.format(this);\n+    Calendar cal = Calendar.getInstance();\n+    cal.setTimeInMillis(time);\n+    return cal.get(Calendar.SECOND);\n   }\n \n-  public static long UTC (int year, int month, int date,\n-\t\t\t  int hours, int minutes, int seconds)\n+  /**\n+   * Sets the seconds to the given value, not changing the other fields.\n+   * @param seconds the seconds.\n+   * @deprecated Use Calendar instead of Date, and use\n+   * set(Calendar.SECOND, seconds) instead. \n+   */\n+  public void setSeconds(int seconds)\n   {\n-    GregorianCalendar cal = new GregorianCalendar (TimeZone.getTimeZone(\"GMT\"));\n-    cal.set(year+1900, month, date, hours, minutes, seconds);\n-    return cal.getTimeInMillis();\n+    Calendar cal = Calendar.getInstance();\n+    cal.setTimeInMillis(time);\n+    cal.set(Calendar.SECOND, seconds);\n+    time = cal.getTimeInMillis();\n   }\n \n   /**\n    * Reads an Object from the stream.\n    */\n-  private void readObject (java.io.ObjectInputStream input)\n+  private void readObject(java.io.ObjectInputStream input)\n     throws java.io.IOException, ClassNotFoundException\n   {\n-    input.defaultReadObject ();\n-    millis = input.readLong ();\n+    input.defaultReadObject();\n+    time = input.readLong();\n   }\n \n   /**\n@@ -497,10 +764,10 @@ private void readObject (java.io.ObjectInputStream input)\n    * in milliseconds.  This is the same value that is returned by the\n    * method getTime().\n    */\n-  private void writeObject (java.io.ObjectOutputStream output)\n+  private void writeObject(java.io.ObjectOutputStream output)\n     throws java.io.IOException\n   {\n-    output.defaultWriteObject ();\n-    output.writeLong (millis);\n+    output.defaultWriteObject();\n+    output.writeLong(time);\n   }\n }"}]}