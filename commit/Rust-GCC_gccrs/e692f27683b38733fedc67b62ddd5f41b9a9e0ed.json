{"sha": "e692f27683b38733fedc67b62ddd5f41b9a9e0ed", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTY5MmYyNzY4M2IzODczM2ZlZGM2N2I2MmRkZDVmNDFiOWE5ZTBlZA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2011-01-22T19:35:10Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2011-01-22T19:35:10Z"}, "message": "New -fcompare-elim pass.\n\nVersion 3, with two rounds of comments from Paolo Bonzini.\n\nFrom-SVN: r169131", "tree": {"sha": "e448736a4d2079d8b2bb7d5d43e46d716b00478c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e448736a4d2079d8b2bb7d5d43e46d716b00478c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e692f27683b38733fedc67b62ddd5f41b9a9e0ed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e692f27683b38733fedc67b62ddd5f41b9a9e0ed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e692f27683b38733fedc67b62ddd5f41b9a9e0ed", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e692f27683b38733fedc67b62ddd5f41b9a9e0ed/comments", "author": null, "committer": null, "parents": [{"sha": "8a9adf2c8fde74d9789b01f5c35c0e652dd69a8a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a9adf2c8fde74d9789b01f5c35c0e652dd69a8a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8a9adf2c8fde74d9789b01f5c35c0e652dd69a8a"}], "stats": {"total": 702, "additions": 701, "deletions": 1}, "files": [{"sha": "562a1dcd62db3681232f4bf6adc688b93594fafc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e692f27683b38733fedc67b62ddd5f41b9a9e0ed/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e692f27683b38733fedc67b62ddd5f41b9a9e0ed/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e692f27683b38733fedc67b62ddd5f41b9a9e0ed", "patch": "@@ -1,3 +1,18 @@\n+2011-01-21  Richard Henderson  <rth@redhat.com>\n+\n+\t* compare-elim.c: New file.\n+\t* Makefile.in (OBJS-common): Add it.\n+\t(compare-elim.o): New.\n+\t* common.opt (fcompare-elim): New.\n+\t* opts.c (default_options_table): Add OPT_fcompare_elim.\n+\t* tree-pass.h (pass_compare_elim_after_reload): New.\n+\t* passes.c (init_optimization_passes): Add it.\n+\t* recog.h: Protect against re-inclusion.\n+\t* target.def (TARGET_FLAGS_REGNUM): New POD hook.\n+\t* doc/invoke.texi (-fcompare-elim): Document it.\n+\t* doc/tm.texi.in (TARGET_FLAGS_REGNUM): Document it.\n+\t* doc/tm.texi: Rebuild.\n+\n 2011-01-22  Nick Clifton  <nickc@redhat.com>\n \n \t* config/rx/rx.md (cstoresf4): Pass comparison operator to"}, {"sha": "34266f976afc1889cba97dff2829a74a4afa8df2", "filename": "gcc/Makefile.in", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e692f27683b38733fedc67b62ddd5f41b9a9e0ed/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e692f27683b38733fedc67b62ddd5f41b9a9e0ed/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=e692f27683b38733fedc67b62ddd5f41b9a9e0ed", "patch": "@@ -1205,6 +1205,7 @@ OBJS-common = \\\n \tcfgrtl.o \\\n \tcombine.o \\\n \tcombine-stack-adj.o \\\n+\tcompare-elim.o \\\n \tconvert.o \\\n \tcoverage.o \\\n \tcse.o \\\n@@ -3353,6 +3354,9 @@ combine-stack-adj.o : combine-stack-adj.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    $(TM_H) $(RTL_H) insn-config.h $(TIMEVAR_H) $(TREE_PASS_H) \\\n    $(RECOG_H) output.h $(REGS_H) hard-reg-set.h $(FLAGS_H) $(FUNCTION_H) \\\n    $(EXPR_H) $(BASIC_BLOCK_H) $(DIAGNOSTIC_CORE_H) $(TM_P_H) $(DF_H) $(EXCEPT_H) reload.h\n+compare-elim.o : compare-elim.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n+   $(TM_H) $(RTL_H) $(TM_P_H) insn-config.h $(RECOG_H) $(FLAGS_H) \\\n+   $(BASIC_BLOCK_H) $(TREE_PASS_H) $(TARGET_H) $(DF_H) domwalk.h\n ddg.o : ddg.c $(DDG_H) $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TARGET_H) \\\n    $(DIAGNOSTIC_CORE_H) $(RTL_H) $(TM_P_H) $(REGS_H) $(FUNCTION_H) \\\n    $(FLAGS_H) insn-config.h $(INSN_ATTR_H) $(EXCEPT_H) $(RECOG_H) \\"}, {"sha": "12f41b13e88e9796e91d7006870d92b8d3e471f6", "filename": "gcc/common.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e692f27683b38733fedc67b62ddd5f41b9a9e0ed/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e692f27683b38733fedc67b62ddd5f41b9a9e0ed/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=e692f27683b38733fedc67b62ddd5f41b9a9e0ed", "patch": "@@ -853,6 +853,10 @@ fcompare-debug-second\n Common Driver RejectNegative Var(flag_compare_debug)\n Run only the second compilation of -fcompare-debug\n \n+fcompare-elim\n+Common Report Var(flag_compare_elim_after_reload) Optimization\n+Perform comparison elimination after register allocation has finished\n+\n fconserve-stack\n Common Var(flag_conserve_stack) Optimization\n Do not perform optimizations increasing noticeably stack usage"}, {"sha": "0ddeb7fd48abc7601484089da719b51aff467781", "filename": "gcc/compare-elim.c", "status": "added", "additions": 641, "deletions": 0, "changes": 641, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e692f27683b38733fedc67b62ddd5f41b9a9e0ed/gcc%2Fcompare-elim.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e692f27683b38733fedc67b62ddd5f41b9a9e0ed/gcc%2Fcompare-elim.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcompare-elim.c?ref=e692f27683b38733fedc67b62ddd5f41b9a9e0ed", "patch": "@@ -0,0 +1,641 @@\n+/* Post-reload compare elimination.\n+   Copyright (C) 2010, 2011\n+   Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+/* There is a set of targets whose general-purpose move or addition\n+   instructions clobber the flags.  These targets cannot split their\n+   CBRANCH/CSTORE etc patterns before reload is complete, lest reload\n+   itself insert these instructions in between the flags setter and user.\n+   Because these targets cannot split the compare from the use, they\n+   cannot make use of the comparison elimination offered by the combine pass.\n+\n+   This is a small pass intended to provide comparison elimination similar to\n+   what is available via NOTICE_UPDATE_CC for cc0 targets.  This should help\n+   encourage cc0 targets to convert to an explicit post-reload representation\n+   of the flags.\n+\n+   This pass assumes:\n+\n+   (0) CBRANCH/CSTORE etc have been split in pass_split_after_reload.\n+\n+   (1) All comparison patterns are represented as\n+\n+\t[(set (reg:CC) (compare:CC (reg) (immediate)))]\n+\n+   (2) All insn patterns that modify the flags are represented as\n+\n+\t[(set (reg) (operation)\n+\t (clobber (reg:CC))]\n+\n+   (3) If an insn of form (2) can usefully set the flags, there is\n+       another pattern of the form\n+\n+\t[(set (reg) (operation)\n+\t (set (reg:CCM) (compare:CCM (operation) (immediate)))]\n+\n+       The mode CCM will be chosen as if by SELECT_CC_MODE.\n+\n+   Note that unlike NOTICE_UPDATE_CC, we do not handle memory operands.\n+   This could be handled as a future enhancement.\n+*/\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"rtl.h\"\n+#include \"tm_p.h\"\n+#include \"insn-config.h\"\n+#include \"recog.h\"\n+#include \"flags.h\"\n+#include \"basic-block.h\"\n+#include \"tree-pass.h\"\n+#include \"target.h\"\n+#include \"df.h\"\n+#include \"domwalk.h\"\n+\n+\f\n+/* These structures describe a comparison and how it is used.  */\n+\n+/* The choice of maximum 3 uses comes from wanting to eliminate the two\n+   duplicate compares from a three-way branch on the sign of a value.\n+   This is also sufficient to eliminate the duplicate compare against the\n+   high-part of a double-word comparison.  */\n+#define MAX_CMP_USE 3\n+\n+struct comparison_use\n+{\n+  /* The instruction in which the result of the compare is used.  */\n+  rtx insn;\n+  /* The location of the flags register within the use.  */\n+  rtx *loc;\n+  /* The comparison code applied against the flags register.  */\n+  enum rtx_code code;\n+};\n+\n+struct comparison\n+{\n+  /* The comparison instruction.  */\n+  rtx insn;\n+\n+  /* The insn prior to the comparison insn that clobbers the flags.  */\n+  rtx prev_clobber;\n+\n+  /* The two values being compared.  These will be either REGs or\n+     constants.  */\n+  rtx in_a, in_b;\n+\n+  /* Information about how this comparison is used.  */\n+  struct comparison_use uses[MAX_CMP_USE];\n+\n+  /* The original CC_MODE for this comparison.  */\n+  enum machine_mode orig_mode;\n+\n+  /* The number of uses identified for this comparison.  */\n+  unsigned short n_uses;\n+\n+  /* True if not all uses of this comparison have been identified.\n+     This can happen either for overflowing the array above, or if\n+     the flags register is used in some unusual context.  */\n+  bool missing_uses;\n+\n+  /* True if its inputs are still valid at the end of the block.  */\n+  bool inputs_valid;\n+};\n+  \n+typedef struct comparison *comparison_struct_p;\n+DEF_VEC_P(comparison_struct_p);\n+DEF_VEC_ALLOC_P(comparison_struct_p, heap);\n+\n+static VEC(comparison_struct_p, heap) *all_compares;\n+\n+/* Look for a \"conforming\" comparison, as defined above.  If valid, return\n+   the rtx for the COMPARE itself.  */\n+\n+static rtx\n+conforming_compare (rtx insn)\n+{\n+  rtx set, src, dest;\n+\n+  set = single_set (insn);\n+  if (set == NULL)\n+    return NULL;\n+\n+  src = SET_SRC (set);\n+  if (GET_CODE (src) != COMPARE)\n+    return NULL;\n+\n+  dest = SET_DEST (set);\n+  if (!REG_P (dest) || REGNO (dest) != targetm.flags_regnum)\n+    return NULL;\n+\n+  if (REG_P (XEXP (src, 0))\n+      && REG_P (XEXP (src, 0))\n+      && (REG_P (XEXP (src, 1)) || CONSTANT_P (XEXP (src, 1))))\n+    return src;\n+\n+  return NULL;\n+}\n+\n+/* Look for a pattern of the \"correct\" form for an insn with a flags clobber\n+   for which we may be able to eliminate a compare later.  We're not looking\n+   to validate any inputs at this time, merely see that the basic shape is\n+   correct.  The term \"arithmetic\" may be somewhat misleading...  */\n+\n+static bool\n+arithmetic_flags_clobber_p (rtx insn)\n+{\n+  rtx pat, x;\n+\n+  if (!NONJUMP_INSN_P (insn))\n+    return false;\n+  pat = PATTERN (insn);\n+  if (extract_asm_operands (pat))\n+    return false;\n+\n+  if (GET_CODE (pat) == PARALLEL && XVECLEN (pat, 0) == 2)\n+    {\n+      x = XVECEXP (pat, 0, 0);\n+      if (GET_CODE (x) != SET)\n+\treturn false;\n+      x = SET_DEST (x);\n+      if (!REG_P (x))\n+\treturn false;\n+\n+      x = XVECEXP (pat, 0, 1);\n+      if (GET_CODE (x) == CLOBBER)\n+\t{\n+\t  x = XEXP (x, 0);\n+\t  if (REG_P (x) && REGNO (x) == targetm.flags_regnum)\n+\t    return true;\n+\t}\n+    }\n+\n+  return false;\n+}\n+\n+/* Look for uses of FLAGS in INSN.  If we find one we can analyze, record\n+   it in CMP; otherwise indicate that we've missed a use.  */\n+\n+static void\n+find_flags_uses_in_insn (struct comparison *cmp, rtx insn)\n+{\n+  df_ref *use_rec, use;\n+\n+  /* If we've already lost track of uses, don't bother collecting more.  */\n+  if (cmp->missing_uses)\n+    return;\n+\n+  /* Find a USE of the flags register.  */\n+  for (use_rec = DF_INSN_USES (insn); (use = *use_rec) != NULL; use_rec++)\n+    if (DF_REF_REGNO (use) == targetm.flags_regnum)\n+      {\n+\trtx x, *loc;\n+\n+\t/* If this is an unusual use, quit.  */\n+\tif (DF_REF_TYPE (use) != DF_REF_REG_USE)\n+\t  goto fail;\n+\n+\t/* If we've run out of slots to record uses, quit.  */\n+\tif (cmp->n_uses == MAX_CMP_USE)\n+\t  goto fail;\n+\n+\t/* Unfortunately the location of the flags register, while present\n+\t   in the reference structure, doesn't help.  We need to find the\n+\t   comparison code that is outer to the actual flags use.  */\n+\tloc = DF_REF_LOC (use);\n+\tx = PATTERN (insn);\n+\tif (GET_CODE (x) == PARALLEL)\n+\t  x = XVECEXP (x, 0, 0);\n+\tx = SET_SRC (x);\n+\tif (GET_CODE (x) == IF_THEN_ELSE)\n+\t  x = XEXP (x, 0);\n+\tif (COMPARISON_P (x)\n+\t    && loc == &XEXP (x, 0)\n+\t    && XEXP (x, 1) == const0_rtx)\n+\t  {\n+\t    /* We've found a use of the flags that we understand.  */\n+\t    struct comparison_use *cuse = &cmp->uses[cmp->n_uses++];\n+\t    cuse->insn = insn;\n+\t    cuse->loc = loc;\n+\t    cuse->code = GET_CODE (x);\n+\t  }\n+\telse\n+\t  goto fail;\n+      }\n+  return;\n+\n+ fail:\n+  /* We failed to recognize this use of the flags register.  */\n+  cmp->missing_uses = true;\n+}\n+\n+/* Identify comparison instructions within BB.  If the flags from the last\n+   compare in the BB is live at the end of the block, install the compare\n+   in BB->AUX.  Called via walk_dominators_tree.  */\n+\n+static void\n+find_comparisons_in_bb (struct dom_walk_data *data ATTRIBUTE_UNUSED,\n+\t\t\tbasic_block bb)\n+{\n+  struct comparison *last_cmp;\n+  rtx insn, next, last_clobber;\n+  bool last_cmp_valid;\n+  bitmap killed;\n+\n+  killed = BITMAP_ALLOC (NULL);\n+\n+  /* The last comparison that was made.  Will be reset to NULL\n+     once the flags are clobbered.  */\n+  last_cmp = NULL;\n+\n+  /* True iff the last comparison has not been clobbered, nor\n+     have its inputs.  Used to eliminate duplicate compares.  */\n+  last_cmp_valid = false;\n+\n+  /* The last insn that clobbered the flags, if that insn is of\n+     a form that may be valid for eliminating a following compare.\n+     To be reset to NULL once the flags are set otherwise.  */\n+  last_clobber = NULL;\n+\n+  /* Propagate the last live comparison throughout the extended basic block. */\n+  if (single_pred_p (bb))\n+    {\n+      last_cmp = (struct comparison *) single_pred (bb)->aux;\n+      if (last_cmp)\n+\tlast_cmp_valid = last_cmp->inputs_valid;\n+    }\n+\n+  for (insn = BB_HEAD (bb); insn; insn = next)\n+    {\n+      rtx src;\n+\n+      next = (insn == BB_END (bb) ? NULL_RTX : NEXT_INSN (insn));\n+      if (!NONDEBUG_INSN_P (insn))\n+\tcontinue;\n+\n+      /* Compute the set of registers modified by this instruction.  */\n+      bitmap_clear (killed);\n+      df_simulate_find_defs (insn, killed);\n+\n+      src = conforming_compare (insn);\n+      if (src)\n+\t{\n+\t  /* Eliminate a compare that's redundant with the previous.  */\n+\t  if (last_cmp_valid\n+\t      && rtx_equal_p (last_cmp->in_a, XEXP (src, 0))\n+\t      && rtx_equal_p (last_cmp->in_b, XEXP (src, 1)))\n+\t    {\n+\t      delete_insn (insn);\n+\t      continue;\n+\t    }\n+\n+          last_cmp = XCNEW (struct comparison);\n+\t  last_cmp->insn = insn;\n+\t  last_cmp->prev_clobber = last_clobber;\n+\t  last_cmp->in_a = XEXP (src, 0);\n+\t  last_cmp->in_b = XEXP (src, 1);\n+\t  last_cmp->orig_mode = GET_MODE (SET_DEST (single_set (insn)));\n+\t  VEC_safe_push (comparison_struct_p, heap, all_compares, last_cmp);\n+\n+\t  /* It's unusual, but be prepared for comparison patterns that\n+\t     also clobber an input, or perhaps a scratch.  */\n+\t  last_clobber = NULL;\n+\t  last_cmp_valid = true;\n+\t}\n+\n+      /* Notice if this instruction kills the flags register.  */\n+      else if (bitmap_bit_p (killed, targetm.flags_regnum))\n+\t{\n+\t  /* See if this insn could be the \"clobber\" that eliminates\n+\t     a future comparison.   */\n+\t  last_clobber = (arithmetic_flags_clobber_p (insn) ? insn : NULL);\n+\n+\t  /* In either case, the previous compare is no longer valid.  */\n+\t  last_cmp = NULL;\n+\t  last_cmp_valid = false;\n+\t  continue;\n+\t}\n+\n+      /* Notice if this instruction uses the flags register.  */\n+      else if (last_cmp)\n+\tfind_flags_uses_in_insn (last_cmp, insn);\n+\n+      /* Notice if any of the inputs to the comparison have changed.  */\n+      if (last_cmp_valid\n+\t  && (bitmap_bit_p (killed, REGNO (last_cmp->in_a))\n+\t      || (REG_P (last_cmp->in_b)\n+\t\t  && bitmap_bit_p (killed, REGNO (last_cmp->in_b)))))\n+\tlast_cmp_valid = false;\n+    }\n+\n+  BITMAP_FREE (killed);\n+\n+  /* Remember the live comparison for subsequent members of\n+     the extended basic block.  */\n+  if (last_cmp)\n+    {\n+      bb->aux = last_cmp;\n+      last_cmp->inputs_valid = last_cmp_valid;\n+\n+      /* Look to see if the flags register is live outgoing here, and\n+\t incoming to any successor not part of the extended basic block.  */\n+      if (bitmap_bit_p (&DF_LIVE_BB_INFO (bb)->out, targetm.flags_regnum))\n+\t{\n+\t  edge e;\n+\t  edge_iterator ei;\n+\n+\t  FOR_EACH_EDGE (e, ei, bb->succs)\n+\t    {\n+\t      basic_block dest = e->dest;\n+\t      if (bitmap_bit_p (&DF_LIVE_BB_INFO (dest)->in,\n+\t\t\t\ttargetm.flags_regnum)\n+\t\t  && !single_pred_p (dest))\n+\t\t{\n+\t\t  last_cmp->missing_uses = true;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n+    }\n+}\n+\n+/* Find all comparisons in the function.  */\n+\n+static void\n+find_comparisons (void)\n+{\n+  struct dom_walk_data data;\n+\n+  memset (&data, 0, sizeof(data));\n+  data.dom_direction = CDI_DOMINATORS;\n+  data.before_dom_children = find_comparisons_in_bb;\n+\n+  calculate_dominance_info (CDI_DOMINATORS);\n+\n+  init_walk_dominator_tree (&data);\n+  walk_dominator_tree (&data, ENTRY_BLOCK_PTR);\n+  fini_walk_dominator_tree (&data);\n+\n+  clear_aux_for_blocks ();\n+  free_dominance_info (CDI_DOMINATORS);\n+}\n+\n+/* Select an alternate CC_MODE for a comparison insn comparing A and B.\n+   Note that inputs are almost certainly different than the IN_A and IN_B\n+   stored in CMP -- we're called while attempting to eliminate the compare\n+   after all.  Return the new FLAGS rtx if successful, else return NULL.\n+   Note that this function may start a change group.  */\n+\n+static rtx\n+maybe_select_cc_mode (struct comparison *cmp, rtx a, rtx b)\n+{\n+  enum machine_mode sel_mode;\n+  const int n = cmp->n_uses;\n+  rtx flags = NULL;\n+\n+#ifndef SELECT_CC_MODE\n+  /* Minimize code differences when this target macro is undefined.  */\n+  return NULL;\n+#define SELECT_CC_MODE(A,B,C) (gcc_unreachable (), VOIDmode)\n+#endif\n+\n+  /* If we don't have access to all of the uses, we can't validate.  */\n+  if (cmp->missing_uses || n == 0)\n+    return NULL;\n+\n+  /* Find a new mode that works for all of the uses.  Special case the\n+     common case of exactly one use.  */\n+  if (n == 1)\n+    {\n+      sel_mode = SELECT_CC_MODE (cmp->uses[0].code, a, b);\n+      if (sel_mode != cmp->orig_mode)\n+\t{\n+\t  flags = gen_rtx_REG (sel_mode, targetm.flags_regnum);\n+\t  validate_change (cmp->uses[0].insn, cmp->uses[0].loc, flags, true);\n+\t}\n+    }\n+  else\n+    {\n+      int i;\n+\n+      sel_mode = SELECT_CC_MODE (cmp->uses[0].code, a, b);\n+      for (i = 1; i < n; ++i)\n+\t{\n+\t  enum machine_mode new_mode;\n+\t  new_mode = SELECT_CC_MODE (cmp->uses[i].code, a, b);\n+\t  if (new_mode != sel_mode)\n+\t    {\n+\t      sel_mode = targetm.cc_modes_compatible (sel_mode, new_mode);\n+\t      if (sel_mode == VOIDmode)\n+\t\treturn NULL;\n+\t    }\n+\t}\n+      \n+      if (sel_mode != cmp->orig_mode)\n+\t{\n+\t  flags = gen_rtx_REG (sel_mode, targetm.flags_regnum);\n+\t  for (i = 0; i < n; ++i)\n+\t    validate_change (cmp->uses[i].insn, cmp->uses[i].loc, flags, true);\n+\t}\n+    }\n+\n+  return flags;\n+}\n+\n+/* Attempt to replace a comparison with a prior arithmetic insn that can\n+   compute the same flags value as the comparison itself.  Return true if\n+   successful, having made all rtl modifications necessary.  */\n+\n+static bool\n+try_eliminate_compare (struct comparison *cmp)\n+{\n+  rtx x, insn, bb_head, flags, in_a, cmp_src;\n+\n+  /* We must have found an interesting \"clobber\" preceeding the compare.  */\n+  if (cmp->prev_clobber == NULL)\n+    return false;\n+\n+  /* ??? For the moment we don't handle comparisons for which IN_B\n+     is a register.  We accepted these during initial comparison \n+     recognition in order to eliminate duplicate compares.\n+     An improvement here would be to handle x = a - b; if (a cmp b).  */\n+  if (!CONSTANT_P (cmp->in_b))\n+    return false;\n+\n+  /* Verify that IN_A is not clobbered in between CMP and PREV_CLOBBER.\n+     Given that this target requires this pass, we can assume that most\n+     insns do clobber the flags, and so the distance between the compare\n+     and the clobber is likely to be small.  */\n+  /* ??? This is one point at which one could argue that DF_REF_CHAIN would\n+     be useful, but it is thought to be too heavy-weight a solution here.  */\n+\n+  in_a = cmp->in_a;\n+  insn = cmp->insn;\n+  bb_head = BB_HEAD (BLOCK_FOR_INSN (insn));\n+  for (insn = PREV_INSN (insn);\n+       insn != cmp->prev_clobber;\n+       insn = PREV_INSN (insn))\n+    {\n+      const int abnormal_flags\n+\t= (DF_REF_CONDITIONAL | DF_REF_PARTIAL | DF_REF_MAY_CLOBBER\n+\t   | DF_REF_MUST_CLOBBER | DF_REF_SIGN_EXTRACT\n+\t   | DF_REF_ZERO_EXTRACT | DF_REF_STRICT_LOW_PART\n+\t   | DF_REF_PRE_POST_MODIFY);\n+      df_ref *def_rec, def;\n+\n+      /* Note that the BB_HEAD is always either a note or a label, but in\n+\t any case it means that IN_A is defined outside the block.  */\n+      if (insn == bb_head)\n+\treturn false;\n+      if (NOTE_P (insn) || DEBUG_INSN_P (insn))\n+\tcontinue;\n+\n+      /* Find a possible def of IN_A in INSN.  */\n+      for (def_rec = DF_INSN_DEFS (insn); (def = *def_rec) != NULL; def_rec++)\n+\tif (DF_REF_REGNO (def) == REGNO (in_a))\n+\t  break;\n+\n+      /* No definitions of IN_A; continue searching.  */\n+      if (def == NULL)\n+\tcontinue;\n+\n+      /* Bail if this is not a totally normal set of IN_A.  */\n+      if (DF_REF_IS_ARTIFICIAL (def))\n+\treturn false;\n+      if (DF_REF_FLAGS (def) & abnormal_flags)\n+\treturn false;\n+\n+      /* We've found an insn between the compare and the clobber that sets\n+\t IN_A.  Given that pass_cprop_hardreg has not yet run, we still find\n+\t situations in which we can usefully look through a copy insn.  */\n+      x = single_set (insn);\n+      if (x == NULL)\n+\treturn false;\n+      in_a = SET_SRC (x);\n+      if (!REG_P (in_a))\n+\treturn false;\n+    }\n+\n+  /* We've reached PREV_CLOBBER without finding a modification of IN_A.\n+     Validate that PREV_CLOBBER itself does in fact refer to IN_A.  Do\n+     recall that we've already validated the shape of PREV_CLOBBER.  */\n+  x = XVECEXP (PATTERN (insn), 0, 0);\n+  if (!rtx_equal_p (SET_DEST (x), in_a))\n+    return false;\n+  cmp_src = SET_SRC (x);\n+  \n+  /* Determine if we ought to use a different CC_MODE here.  */\n+  flags = maybe_select_cc_mode (cmp, cmp_src, cmp->in_b);\n+  if (flags == NULL)\n+    flags = gen_rtx_REG (cmp->orig_mode, targetm.flags_regnum);\n+\n+  /* Generate a new comparison for installation in the setter.  */\n+  x = copy_rtx (cmp_src);\n+  x = gen_rtx_COMPARE (GET_MODE (flags), x, cmp->in_b);\n+  x = gen_rtx_SET (VOIDmode, flags, x);\n+\n+  /* Succeed if the new instruction is valid.  Note that we may have started\n+     a change group within maybe_select_cc_mode, therefore we must continue. */\n+  validate_change (insn, &XVECEXP (PATTERN (insn), 0, 1), x, true);\n+  if (!apply_change_group ())\n+    return false;\n+ \n+  /* Success.  Delete the compare insn...  */\n+  delete_insn (cmp->insn);\n+\n+  /* ... and any notes that are now invalid due to multiple sets.  */\n+  x = find_regno_note (insn, REG_UNUSED, targetm.flags_regnum);\n+  if (x)\n+    remove_note (insn, x);\n+  x = find_reg_note (insn, REG_EQUAL, NULL);\n+  if (x)\n+    remove_note (insn, x);\n+  x = find_reg_note (insn, REG_EQUIV, NULL);\n+  if (x)\n+    remove_note (insn, x);\n+\n+  return true;\n+}\n+\n+/* Main entry point to the pass.  */\n+\n+static unsigned int\n+execute_compare_elim_after_reload (void)\n+{\n+  df_set_flags (DF_DEFER_INSN_RESCAN);\n+  df_live_add_problem ();\n+  df_analyze ();\n+\n+  gcc_checking_assert (all_compares == NULL);\n+\n+  /* Locate all comparisons and their uses, and eliminate duplicates.  */\n+  find_comparisons ();\n+  if (all_compares)\n+    {\n+      struct comparison *cmp;\n+      size_t i;\n+\n+      /* Eliminate comparisons that are redundant with flags computation.  */\n+      FOR_EACH_VEC_ELT (comparison_struct_p, all_compares, i, cmp)\n+\t{\n+\t  try_eliminate_compare (cmp);\n+\t  XDELETE (cmp);\n+\t}\n+\n+      VEC_free (comparison_struct_p, heap, all_compares);\n+      all_compares = NULL;\n+\n+      df_analyze ();\n+    }\n+\n+  return 0;\n+}\n+\n+static bool\n+gate_compare_elim_after_reload (void)\n+{\n+  /* Setting this target hook value is how a backend indicates the need.  */\n+  if (targetm.flags_regnum == INVALID_REGNUM)\n+    return false;\n+  return flag_compare_elim_after_reload;\n+}\n+\n+struct rtl_opt_pass pass_compare_elim_after_reload =\n+{\n+ {\n+  RTL_PASS,\n+  \"cmpelim\",\t\t\t\t/* name */\n+  gate_compare_elim_after_reload,\t/* gate */\n+  execute_compare_elim_after_reload,\t/* execute */\n+  NULL,\t\t\t\t\t/* sub */\n+  NULL,\t\t\t\t\t/* next */\n+  0,\t\t\t\t\t/* static_pass_number */\n+  TV_NONE,\t\t\t\t/* tv_id */\n+  0,\t\t\t\t\t/* properties_required */\n+  0,\t\t\t\t\t/* properties_provided */\n+  0,\t\t\t\t\t/* properties_destroyed */\n+  0,\t\t\t\t\t/* todo_flags_start */\n+  TODO_df_finish\n+  | TODO_df_verify\n+  | TODO_verify_rtl_sharing\n+  | TODO_dump_func\n+  | TODO_ggc_collect\t\t\t/* todo_flags_finish */\n+ }\n+};"}, {"sha": "3d64438ad401c8a84acf5f6679b0b9354c518587", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e692f27683b38733fedc67b62ddd5f41b9a9e0ed/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e692f27683b38733fedc67b62ddd5f41b9a9e0ed/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=e692f27683b38733fedc67b62ddd5f41b9a9e0ed", "patch": "@@ -337,7 +337,7 @@ Objective-C and Objective-C++ Dialects}.\n -fauto-inc-dec -fbranch-probabilities -fbranch-target-load-optimize @gol\n -fbranch-target-load-optimize2 -fbtr-bb-exclusive -fcaller-saves @gol\n -fcheck-data-deps -fcombine-stack-adjustments -fconserve-stack @gol\n--fcprop-registers -fcrossjumping @gol\n+-fcompare-elim -fcprop-registers -fcrossjumping @gol\n -fcse-follow-jumps -fcse-skip-blocks -fcx-fortran-rules @gol\n -fcx-limited-range @gol\n -fdata-sections -fdce -fdce -fdelayed-branch @gol\n@@ -5870,6 +5870,7 @@ compilation time.\n @option{-O} turns on the following optimization flags:\n @gccoptlist{\n -fauto-inc-dec @gol\n+-fcompare-elim @gol\n -fcprop-registers @gol\n -fdce @gol\n -fdefer-pop @gol\n@@ -7689,6 +7690,18 @@ use hidden visibility) is similar to @code{-fwhole-program}.  See\n Enabled by default when LTO support in GCC is enabled and GCC was compiled\n with linker supporting plugins (GNU ld or @code{gold}).\n \n+@item -fcompare-elim\n+@opindex fcompare-elim\n+After register allocation and post-register allocation instruction splitting,\n+identify arithmetic instructions that compute processor flags similar to a\n+comparison operation based on that arithmetic.  If possible, eliminate the\n+explicit comparison operation.\n+\n+This pass only applies to certain targets that cannot explicitly represent\n+the comparison operation before register allocation is complete.\n+\n+Enabled at levels @option{-O}, @option{-O2}, @option{-O3}, @option{-Os}.\n+\n @item -fcprop-registers\n @opindex fcprop-registers\n After register allocation and post-register allocation instruction splitting,"}, {"sha": "85e1d88eec91ff97c0c36f261af14cf4c7ef65e4", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e692f27683b38733fedc67b62ddd5f41b9a9e0ed/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e692f27683b38733fedc67b62ddd5f41b9a9e0ed/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=e692f27683b38733fedc67b62ddd5f41b9a9e0ed", "patch": "@@ -4351,6 +4351,10 @@ to return a nonzero value when it is required, the compiler will run out\n of spill registers and print a fatal error message.\n @end deftypefn\n \n+@deftypevr {Target Hook} {unsigned int} TARGET_FLAGS_REGNUM\n+If the target has a dedicated flags register, and it needs to use the post-reload comparison elimination pass, then this value should be set appropriately.\n+@end deftypevr\n+\n @node Scalar Return\n @subsection How Scalar Function Values Are Returned\n @cindex return values in registers"}, {"sha": "a799bc43564c8fc6a67d8cda2ecdb8d201276554", "filename": "gcc/doc/tm.texi.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e692f27683b38733fedc67b62ddd5f41b9a9e0ed/gcc%2Fdoc%2Ftm.texi.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e692f27683b38733fedc67b62ddd5f41b9a9e0ed/gcc%2Fdoc%2Ftm.texi.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi.in?ref=e692f27683b38733fedc67b62ddd5f41b9a9e0ed", "patch": "@@ -4337,6 +4337,8 @@ to return a nonzero value when it is required, the compiler will run out\n of spill registers and print a fatal error message.\n @end deftypefn\n \n+@hook TARGET_FLAGS_REGNUM\n+\n @node Scalar Return\n @subsection How Scalar Function Values Are Returned\n @cindex return values in registers"}, {"sha": "b958a091e8527d3a03f9dc2151031ec1cbdc17dc", "filename": "gcc/opts.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e692f27683b38733fedc67b62ddd5f41b9a9e0ed/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e692f27683b38733fedc67b62ddd5f41b9a9e0ed/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=e692f27683b38733fedc67b62ddd5f41b9a9e0ed", "patch": "@@ -456,6 +456,7 @@ static const struct default_options default_options_table[] =\n     { OPT_LEVELS_1_PLUS, OPT_ftree_sink, NULL, 1 },\n     { OPT_LEVELS_1_PLUS, OPT_ftree_ch, NULL, 1 },\n     { OPT_LEVELS_1_PLUS, OPT_fcombine_stack_adjustments, NULL, 1 },\n+    { OPT_LEVELS_1_PLUS, OPT_fcompare_elim, NULL, 1 },\n \n     /* -O2 optimizations.  */\n     { OPT_LEVELS_2_PLUS, OPT_finline_small_functions, NULL, 1 },"}, {"sha": "d32bccf23ec17751331e044d26eb1cd039ef32c4", "filename": "gcc/passes.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e692f27683b38733fedc67b62ddd5f41b9a9e0ed/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e692f27683b38733fedc67b62ddd5f41b9a9e0ed/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=e692f27683b38733fedc67b62ddd5f41b9a9e0ed", "patch": "@@ -1022,6 +1022,7 @@ init_optimization_passes (void)\n \t  NEXT_PASS (pass_gcse2);\n \t  NEXT_PASS (pass_split_after_reload);\n \t  NEXT_PASS (pass_implicit_zee);\n+\t  NEXT_PASS (pass_compare_elim_after_reload);\n \t  NEXT_PASS (pass_branch_target_load_optimize1);\n \t  NEXT_PASS (pass_thread_prologue_and_epilogue);\n \t  NEXT_PASS (pass_rtl_dse2);"}, {"sha": "534d2c99b183e9f472ddf1dc171bed83bc1c19ff", "filename": "gcc/recog.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e692f27683b38733fedc67b62ddd5f41b9a9e0ed/gcc%2Frecog.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e692f27683b38733fedc67b62ddd5f41b9a9e0ed/gcc%2Frecog.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.h?ref=e692f27683b38733fedc67b62ddd5f41b9a9e0ed", "patch": "@@ -18,6 +18,9 @@ You should have received a copy of the GNU General Public License\n along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n \n+#ifndef GCC_RECOG_H\n+#define GCC_RECOG_H\n+\n /* Random number that should be large enough for all purposes.  */\n #define MAX_RECOG_ALTERNATIVES 30\n \n@@ -305,3 +308,5 @@ struct insn_data_d\n \n extern const struct insn_data_d insn_data[];\n extern int peep2_current_count;\n+\n+#endif /* GCC_RECOG_H */"}, {"sha": "57134cbc61155424e454b642dfb14937cdd8fd23", "filename": "gcc/target.def", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e692f27683b38733fedc67b62ddd5f41b9a9e0ed/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e692f27683b38733fedc67b62ddd5f41b9a9e0ed/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=e692f27683b38733fedc67b62ddd5f41b9a9e0ed", "patch": "@@ -1638,6 +1638,15 @@ DEFHOOK\n  bool, (enum machine_mode mode),\n  hook_bool_mode_false)\n \n+/* Register number for a flags register.  Only needs to be defined if the\n+   target is constrainted to use post-reload comparison elimination.  */\n+DEFHOOKPOD\n+(flags_regnum,\n+ \"If the target has a dedicated flags register, and it needs to use the\\\n+ post-reload comparison elimination pass, then this value should be set\\\n+ appropriately.\",\n+ unsigned int, INVALID_REGNUM)\n+\n /* Compute a (partial) cost for rtx X.  Return true if the complete\n    cost has been computed, and false if subexpressions should be\n    scanned.  In either case, *TOTAL contains the cost result.  */"}, {"sha": "dd82288784049b2dba43af5cd867947301eb90df", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e692f27683b38733fedc67b62ddd5f41b9a9e0ed/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e692f27683b38733fedc67b62ddd5f41b9a9e0ed/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=e692f27683b38733fedc67b62ddd5f41b9a9e0ed", "patch": "@@ -551,6 +551,7 @@ extern struct rtl_opt_pass pass_reorder_blocks;\n extern struct rtl_opt_pass pass_branch_target_load_optimize2;\n extern struct rtl_opt_pass pass_leaf_regs;\n extern struct rtl_opt_pass pass_split_before_sched2;\n+extern struct rtl_opt_pass pass_compare_elim_after_reload;\n extern struct rtl_opt_pass pass_sched2;\n extern struct rtl_opt_pass pass_stack_regs;\n extern struct rtl_opt_pass pass_stack_regs_run;"}]}