{"sha": "b4b575ce7854f4a49de8de93f38b7639e01b040b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjRiNTc1Y2U3ODU0ZjRhNDlkZThkZTkzZjM4Yjc2MzllMDFiMDQwYg==", "commit": {"author": {"name": "Anthony Green", "email": "green@gcc.gnu.org", "date": "2012-12-26T16:28:02Z"}, "committer": {"name": "Anthony Green", "email": "green@gcc.gnu.org", "date": "2012-12-26T16:28:02Z"}, "message": "libffi merge\n\nFrom-SVN: r194722", "tree": {"sha": "ef354e445015ccf6c34c675cf123ef8ca5128a8c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ef354e445015ccf6c34c675cf123ef8ca5128a8c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b4b575ce7854f4a49de8de93f38b7639e01b040b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4b575ce7854f4a49de8de93f38b7639e01b040b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b4b575ce7854f4a49de8de93f38b7639e01b040b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4b575ce7854f4a49de8de93f38b7639e01b040b/comments", "author": null, "committer": null, "parents": [{"sha": "dc3a31d4767c19ab47211e29fbc3c8866df8d8a1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc3a31d4767c19ab47211e29fbc3c8866df8d8a1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dc3a31d4767c19ab47211e29fbc3c8866df8d8a1"}], "stats": {"total": 7443, "additions": 6789, "deletions": 654}, "files": [{"sha": "62332c6939a3c29116bbc2db8d732a840668d631", "filename": "libffi/ChangeLog", "status": "modified", "additions": 307, "deletions": 0, "changes": 307, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2FChangeLog?ref=b4b575ce7854f4a49de8de93f38b7639e01b040b", "patch": "@@ -3,6 +3,63 @@\n \t* src/powerpc/linux64_closure.S: Add new ABI support.\n \t* src/powerpc/linux64.S: Likewise.\n \n+2012-10-30  Magnus Granberg  <zorry@gentoo.org>\n+\t    Pavel Labushev  <pavel.labushev@runbox.ru>\n+\n+\t* configure.ac: New options pax_emutramp\n+\t* configure, fficonfig.h.in: Regenerated\n+\t* src/closures.c: New function emutramp_enabled_check() and\n+\tchecks.\n+\n+2012-10-30  Frederick Cheung  <frederick.cheung@gmail.com>\n+\n+\t* configure.ac: Enable FFI_MAP_EXEC_WRIT for Darwin 12 (mountain\n+\tlion) and future version.\n+\t* configure: Rebuild.\n+\n+2012-10-30  James Greenhalgh  <james.greenhalgh at arm.com>\n+            Marcus Shawcroft  <marcus.shawcroft at arm.com>\n+\n+        * README: Add details of aarch64 port.\n+        * src/aarch64/ffi.c: New.\n+        * src/aarch64/ffitarget.h: Likewise.\n+        * src/aarch64/sysv.S: Likewise.\n+\t* Makefile.am: Support aarch64.\n+\t* configure.ac: Support aarch64.\n+\t* Makefile.in, configure: Rebuilt.\n+\n+2012-10-30  James Greenhalgh  <james.greenhalgh at arm.com>\n+            Marcus Shawcroft  <marcus.shawcroft at arm.com>\n+\n+        * testsuite/lib/libffi.exp: Add support for aarch64.\n+        * testsuite/libffi.call/cls_struct_va1.c: New.\n+        * testsuite/libffi.call/cls_uchar_va.c: Likewise.\n+        * testsuite/libffi.call/cls_uint_va.c: Likewise.\n+        * testsuite/libffi.call/cls_ulong_va.c: Likewise.\n+        * testsuite/libffi.call/cls_ushort_va.c: Likewise.\n+        * testsuite/libffi.call/nested_struct11.c: Likewise.\n+        * testsuite/libffi.call/uninitialized.c: Likewise.\n+        * testsuite/libffi.call/va_1.c: Likewise.\n+        * testsuite/libffi.call/va_struct1.c: Likewise.\n+        * testsuite/libffi.call/va_struct2.c: Likewise.\n+        * testsuite/libffi.call/va_struct3.c: Likewise.\n+\n+2012-10-12  Walter Lee  <walt@tilera.com>\n+\n+        * Makefile.am: Add TILE-Gx/TILEPro support.\n+        * configure.ac: Likewise.\n+        * Makefile.in: Regenerate.\n+        * configure: Likewise.\n+        * src/prep_cif.c (ffi_prep_cif_core): Handle TILE-Gx/TILEPro.\n+        * src/tile: New directory.\n+        * src/tile/ffi.c: New file.\n+        * src/tile/ffitarget.h: Ditto.\n+        * src/tile/tile.S: Ditto.\n+\n+2012-10-12  Matthias Klose  <doko@ubuntu.com>\n+\n+\t* generate-osx-source-and-headers.py: Normalize whitespace.\n+\n 2012-09-14  David Edelsohn  <dje.gcc@gmail.com>\n \n \t* configure: Regenerated.\n@@ -29,6 +86,248 @@\n \n \t* configure: Regenerated.\n \n+2012-05-05  Nicolas Lelong\n+\n+\t* libffi.xcodeproj/project.pbxproj: Fixes.\n+\t* README: Update for iOS builds.\n+\n+2012-04-23  Alexandre Keunecke I. de Mendonca <alexandre.keunecke@gmail.com>\n+\n+\t* configure.ac: Add Blackfin/sysv support\n+\t* Makefile.am: Add Blackfin/sysv support\n+\t* src/bfin/ffi.c:  Add Blackfin/sysv support\n+\t* src/bfin/ffitarget.h: Add Blackfin/sysv support\n+\n+2012-04-11  Anthony Green  <green@moxielogic.com>\n+\n+\t* Makefile.am (EXTRA_DIST): Add new script.\n+\t* Makefile.in: Rebuilt.\n+\n+2012-04-11  Zachary Waldowski  <zwaldowski@gmail.com>\n+\n+\t* generate-ios-source-and-headers.py,\n+\tlibffi.xcodeproj/project.pbxproj: Support a Mac static library via\n+\tXcode. Set iOS compatibility to 4.0.  Move iOS trampoline\n+\tgeneration into an Xcode \"run script\" phase.  Include both as\n+\tXcode build scripts. Don't always regenerate config files.\n+\n+2012-04-10  Anthony Green  <green@moxielogic.com>\n+\n+\t* src/powerpc/ffi_darwin.c (ffi_prep_args): Add missing semicolon.\n+\n+2012-04-06  Anthony Green  <green@moxielogic.com>\n+\n+\t* Makefile.am (EXTRA_DIST): Add new iOS/xcode files.\n+\t* Makefile.in: Rebuilt.\n+\n+2012-04-06  Mike Lewis  <mikelikespie@gmail.com>\n+\n+\t* generate-ios-source-and-headers.py: New file.\n+\t* libffi.xcodeproj/project.pbxproj: New file.\n+\t* README: Update instructions on building iOS binary.\n+\t* build-ios.sh: Delete.\n+\n+2012-04-06  Anthony Green  <green@moxielogic.com>\n+\n+\t* src/x86/ffi64.c (UINT128): Define differently for Intel and GNU\n+\tcompilers, then use it.\n+\n+2012-04-06  H.J. Lu  <hongjiu.lu@intel.com>\n+\n+\t* m4/libtool.m4 (_LT_ENABLE_LOCK): Support x32.\n+\n+2012-04-06  Anthony Green  <green@moxielogic.com>\n+\n+\t* testsuite/Makefile.am (EXTRA_DIST): Add missing test cases.\n+\t* testsuite/Makefile.in: Rebuilt.\n+\n+2012-04-05  Zachary Waldowski  <zwaldowski@gmail.com>\n+\n+\t* include/ffi.h.in: Add missing trampoline table fields.\n+\t* src/arm/sysv.S: Fix ENTRY definition, and wrap symbol references\n+\tin CNAME.\n+\t* src/x86/ffi.c: Wrap Windows specific code in ifdefs.\n+\n+2012-03-29  Peter Rosin  <peda@lysator.liu.se>\n+\n+\t* src/x86/win32.S (ffi_closure_raw_THISCALL): Unify the frame\n+\tgeneration, fix the ENDP label and remove the surplus third arg\n+\tfrom the 'lea' insn.\n+\n+2012-03-29  Peter Rosin  <peda@lysator.liu.se>\n+\n+\t* src/x86/win32.S (ffi_closure_raw_SYSV): Make the 'stubraw' label\n+\tvisible outside the PROC, so that ffi_closure_raw_THISCALL can see\n+\tit.  Also instruct the assembler to add a frame to the function.\n+\n+2012-03-23  Peter Rosin  <peda@lysator.liu.se>\n+\n+\t* Makefile.am (AM_CPPFLAGS): Add -DFFI_BUILDING.\n+\t* Makefile.in: Rebuilt.\n+\t* include/ffi.h.in [MSVC]: Add __declspec(dllimport) decorations\n+\tto all data exports, when compiling libffi clients using MSVC.\n+\n+2012-03-29  Peter Rosin  <peda@lysator.liu.se>\n+\n+\t* src/x86/ffitarget.h (ffi_abi): Add new ABI FFI_MS_CDECL and\n+\tmake it the default for MSVC.\n+\t(FFI_TYPE_MS_STRUCT): New structure return convention.\n+\t* src/x86/ffi.c (ffi_prep_cif_machdep): Tweak the structure\n+\treturn convention for FFI_MS_CDECL to be FFI_TYPE_MS_STRUCT\n+\tinstead of an ordinary FFI_TYPE_STRUCT.\n+\t(ffi_prep_args): Treat FFI_TYPE_MS_STRUCT as FFI_TYPE_STRUCT.\n+\t(ffi_call): Likewise.\n+\t(ffi_prep_incoming_args_SYSV): Likewise.\n+\t(ffi_raw_call): Likewise.\n+\t(ffi_prep_closure_loc): Treat FFI_MS_CDECL as FFI_SYSV.\n+\t* src/x86/win32.S (ffi_closure_SYSV): For FFI_TYPE_MS_STRUCT,\n+\treturn a pointer to the result structure in eax and don't pop\n+\tthat pointer from the stack, the caller takes care of it.\n+\t(ffi_call_win32): Treat FFI_TYPE_MS_STRUCT as FFI_TYPE_STRUCT.\n+\t(ffi_closure_raw_SYSV): Likewise.\n+\n+2012-03-22  Peter Rosin  <peda@lysator.liu.se>\n+\n+\t* testsuite/libffi.call/closure_stdcall.c [MSVC]: Add inline\n+\tassembly version with Intel syntax.\n+\t* testsuite/libffi.call/closure_thiscall.c [MSVC]: Likewise.\n+\n+2012-03-23  Peter Rosin  <peda@lysator.liu.se>\n+\n+\t* testsuite/libffi.call/ffitest.h: Provide abstration of\n+\t__attribute__((fastcall)) in the form of a __FASTCALL__\n+\tdefine.  Define it to __fastcall for MSVC.\n+\t* testsuite/libffi.call/fastthis1_win32.c: Use the above.\n+\t* testsuite/libffi.call/fastthis2_win32.c: Likewise.\n+\t* testsuite/libffi.call/fastthis3_win32.c: Likewise.\n+\t* testsuite/libffi.call/strlen2_win32.c: Likewise.\n+\t* testsuite/libffi.call/struct1_win32.c: Likewise.\n+\t* testsuite/libffi.call/struct2_win32.c: Likewise.\n+\n+2012-03-22  Peter Rosin  <peda@lysator.liu.se>\n+\n+\t* src/x86/win32.S [MSVC] (ffi_closure_THISCALL): Remove the manual\n+\tframe on function entry, MASM adds one automatically.\n+\n+2012-03-22  Peter Rosin  <peda@lysator.liu.se>\n+\n+\t* testsuite/libffi.call/ffitest.h [MSVC]: Add kludge for missing\n+\tbits in the MSVC headers.\n+\n+2012-03-22  Peter Rosin  <peda@lysator.liu.se>\n+\n+\t* testsuite/libffi.call/cls_12byte.c: Adjust to the C89 style\n+\twith no declarations after statements.\n+\t* testsuite/libffi.call/cls_16byte.c: Likewise.\n+\t* testsuite/libffi.call/cls_18byte.c: Likewise.\n+\t* testsuite/libffi.call/cls_19byte.c: Likewise.\n+\t* testsuite/libffi.call/cls_1_1byte.c: Likewise.\n+\t* testsuite/libffi.call/cls_20byte.c: Likewise.\n+\t* testsuite/libffi.call/cls_20byte1.c: Likewise.\n+\t* testsuite/libffi.call/cls_24byte.c: Likewise.\n+\t* testsuite/libffi.call/cls_2byte.c: Likewise.\n+\t* testsuite/libffi.call/cls_3_1byte.c: Likewise.\n+\t* testsuite/libffi.call/cls_3byte1.c: Likewise.\n+\t* testsuite/libffi.call/cls_3byte2.c: Likewise.\n+\t* testsuite/libffi.call/cls_4_1byte.c: Likewise.\n+\t* testsuite/libffi.call/cls_4byte.c: Likewise.\n+\t* testsuite/libffi.call/cls_5_1_byte.c: Likewise.\n+\t* testsuite/libffi.call/cls_5byte.c: Likewise.\n+\t* testsuite/libffi.call/cls_64byte.c: Likewise.\n+\t* testsuite/libffi.call/cls_6_1_byte.c: Likewise.\n+\t* testsuite/libffi.call/cls_6byte.c: Likewise.\n+\t* testsuite/libffi.call/cls_7_1_byte.c: Likewise.\n+\t* testsuite/libffi.call/cls_7byte.c: Likewise.\n+\t* testsuite/libffi.call/cls_8byte.c: Likewise.\n+\t* testsuite/libffi.call/cls_9byte1.c: Likewise.\n+\t* testsuite/libffi.call/cls_9byte2.c: Likewise.\n+\t* testsuite/libffi.call/cls_align_double.c: Likewise.\n+\t* testsuite/libffi.call/cls_align_float.c: Likewise.\n+\t* testsuite/libffi.call/cls_align_longdouble.c: Likewise.\n+\t* testsuite/libffi.call/cls_align_longdouble_split.c: Likewise.\n+\t* testsuite/libffi.call/cls_align_longdouble_split2.c: Likewise.\n+\t* testsuite/libffi.call/cls_align_pointer.c: Likewise.\n+\t* testsuite/libffi.call/cls_align_sint16.c: Likewise.\n+\t* testsuite/libffi.call/cls_align_sint32.c: Likewise.\n+\t* testsuite/libffi.call/cls_align_sint64.c: Likewise.\n+\t* testsuite/libffi.call/cls_align_uint16.c: Likewise.\n+\t* testsuite/libffi.call/cls_align_uint32.c: Likewise.\n+\t* testsuite/libffi.call/cls_align_uint64.c: Likewise.\n+\t* testsuite/libffi.call/cls_dbls_struct.c: Likewise.\n+\t* testsuite/libffi.call/cls_pointer_stack.c: Likewise.\n+\t* testsuite/libffi.call/err_bad_typedef.c: Likewise.\n+\t* testsuite/libffi.call/huge_struct.c: Likewise.\n+\t* testsuite/libffi.call/nested_struct.c: Likewise.\n+\t* testsuite/libffi.call/nested_struct1.c: Likewise.\n+\t* testsuite/libffi.call/nested_struct10.c: Likewise.\n+\t* testsuite/libffi.call/nested_struct2.c: Likewise.\n+\t* testsuite/libffi.call/nested_struct3.c: Likewise.\n+\t* testsuite/libffi.call/nested_struct4.c: Likewise.\n+\t* testsuite/libffi.call/nested_struct5.c: Likewise.\n+\t* testsuite/libffi.call/nested_struct6.c: Likewise.\n+\t* testsuite/libffi.call/nested_struct7.c: Likewise.\n+\t* testsuite/libffi.call/nested_struct8.c: Likewise.\n+\t* testsuite/libffi.call/nested_struct9.c: Likewise.\n+\t* testsuite/libffi.call/stret_large.c: Likewise.\n+\t* testsuite/libffi.call/stret_large2.c: Likewise.\n+\t* testsuite/libffi.call/stret_medium.c: Likewise.\n+\t* testsuite/libffi.call/stret_medium2.c: Likewise.\n+\t* testsuite/libffi.call/struct1.c: Likewise.\n+\t* testsuite/libffi.call/struct1_win32.c: Likewise.\n+\t* testsuite/libffi.call/struct2.c: Likewise.\n+\t* testsuite/libffi.call/struct2_win32.c: Likewise.\n+\t* testsuite/libffi.call/struct3.c: Likewise.\n+\t* testsuite/libffi.call/struct4.c: Likewise.\n+\t* testsuite/libffi.call/struct5.c: Likewise.\n+\t* testsuite/libffi.call/struct6.c: Likewise.\n+\t* testsuite/libffi.call/struct7.c: Likewise.\n+\t* testsuite/libffi.call/struct8.c: Likewise.\n+\t* testsuite/libffi.call/struct9.c: Likewise.\n+\t* testsuite/libffi.call/testclosure.c: Likewise.\n+\n+2012-03-21  Peter Rosin\t <peda@lysator.liu.se>\n+\n+\t* testsuite/libffi.call/float_va.c (float_va_fn): Use %f when\n+\tprinting doubles (%lf is for long doubles).\n+\t(main): Likewise.\n+\n+2012-03-21  Peter Rosin  <peda@lysator.liu.se>\n+\n+\t* testsuite/lib/target-libpath.exp [*-*-cygwin*, *-*-mingw*]\n+\t(set_ld_library_path_env_vars): Add the library search dir to PATH\n+\t(and save PATH for later).\n+\t(restore_ld_library_path_env_vars): Restore PATH.\n+\n+2012-03-20  Peter Rosin  <peda@lysator.liu.se>\n+\n+\t* testsuite/libffi.call/strlen2_win32.c (main): Remove bug.\n+\t* src/x86/win32.S [MSVC] (ffi_closure_SYSV): Make the 'stub' label\n+\tvisible outside the PROC, so that ffi_closure_THISCALL can see it.\n+\n+2012-03-20  Peter Rosin  <peda@lysator.liu.se>\n+\n+\t* testsuite/libffi.call/strlen2_win32.c (main): Remove bug.\n+\t* src/x86/win32.S [MSVC] (ffi_closure_SYSV): Make the 'stub' label\n+\tvisible outside the PROC, so that ffi_closure_THISCALL can see it.\n+\n+2012-03-19  Alan Hourihane  <alanh@fairlite.co.uk>\n+\n+\t* src/m68k/ffi.c: Add MINT support.\n+\t* src/m68k/sysv.S: Ditto.\n+\n+2012-03-19  chennam  <csit@axway.com>\n+\n+\t* src/powerpc/ffi_darwin.c (ffi_prep_closure_loc): Fix AIX closure\n+\tsupport.\n+\n+2012-03-06  Chung-Lin Tang  <cltang@codesourcery.com>\n+\n+\t* src/arm/ffi.c (ffi_call): Add __ARM_EABI__ guard around call to\n+\tffi_call_VFP().\n+\t(ffi_prep_closure_loc): Add __ARM_EABI__ guard around use of\n+\tffi_closure_VFP.\n+\t* src/arm/sysv.S: Add __ARM_EABI__ guard around VFP code.\n+\n 2012-04-02  Peter Bergner  <bergner@vnet.ibm.com>\n \n \t* src/powerpc/ffi.c (ffi_prep_args_SYSV): Declare double_tmp.\n@@ -37,6 +336,14 @@\n \t(ffi_call): Silence possibly undefined warning.\n \t(ffi_closure_helper_SYSV): Declare variable type.\n \n+2012-04-02  Peter Rosin  <peda@lysator.liu.se>\n+\n+\t* src/x86/win32.S (ffi_call_win32): Sign/zero extend the return\n+\tvalue in the Intel version as is already done for the AT&T version.\n+\t(ffi_closure_SYSV): Likewise.\n+\t(ffi_closure_raw_SYSV): Likewise.\n+\t(ffi_closure_STDCALL): Likewise.\n+\n 2012-03-13  Kaz Kojima  <kkojima@gcc.gnu.org>\n \n \t* src/sh/ffi.c (ffi_prep_closure_loc): Don't ASSERT ABI test,"}, {"sha": "f3ee8b0040cc0f133d84ab149dc06e0c049c448b", "filename": "libffi/ChangeLog.libffi", "status": "added", "additions": 584, "deletions": 0, "changes": 584, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2FChangeLog.libffi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2FChangeLog.libffi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2FChangeLog.libffi?ref=b4b575ce7854f4a49de8de93f38b7639e01b040b", "patch": "@@ -0,0 +1,584 @@\n+2011-02-08  Andreas Tobler  <andreast@fgznet.ch>\n+\n+\t* testsuite/lib/libffi.exp: Tweak for stand-alone mode.\n+\n+2009-12-25  Samuli Suominen  <ssuominen@gentoo.org>\n+\n+\t* configure.ac: Undefine _AC_ARG_VAR_PRECIOUS for autoconf 2.64.\n+\t* configure: Rebuilt.\n+\t* fficonfig.h.in: Rebuilt.\n+\n+2009-06-16  Andrew Haley  <aph@redhat.com>\n+\n+\t* testsuite/libffi.call/cls_align_sint64.c,\n+\ttestsuite/libffi.call/cls_align_uint64.c,\n+\ttestsuite/libffi.call/cls_longdouble_va.c,\n+\ttestsuite/libffi.call/cls_ulonglong.c,\n+\ttestsuite/libffi.call/return_ll1.c,\n+\ttestsuite/libffi.call/stret_medium2.c: Fix printf format\n+\tspecifiers.\n+\t* testsuite/libffi.call/huge_struct.c: Ad x86 XFAILs.\n+\t* testsuite/libffi.call/float2.c: Fix dg-excess-errors.\n+\t* testsuite/libffi.call/ffitest.h,\n+\ttestsuite/libffi.special/ffitestcxx.h (PRIdLL, PRIuLL): Define.\n+\n+2009-06-12  Andrew Haley  <aph@redhat.com>\n+\n+\t* testsuite/libffi.call/cls_align_sint64.c,\n+\ttestsuite/libffi.call/cls_align_uint64.c,\n+\ttestsuite/libffi.call/cls_ulonglong.c,\n+\ttestsuite/libffi.call/return_ll1.c,\n+\ttestsuite/libffi.call/stret_medium2.c: Fix printf format\n+\tspecifiers.\n+\ttestsuite/libffi.special/unwindtest.cc: include stdint.h.\n+\n+2009-06-11  Timothy Wall  <twall@users.sf.net>\n+\n+\t* Makefile.am,\n+        configure.ac,\n+        include/ffi.h.in,\n+        include/ffi_common.h,\n+        src/closures.c,\n+        src/dlmalloc.c,\n+        src/x86/ffi.c,\n+        src/x86/ffitarget.h,\n+        src/x86/win64.S (new),\n+\tREADME: Added win64 support (mingw or MSVC)\n+        * Makefile.in,\n+        include/Makefile.in,\n+        man/Makefile.in,\n+        testsuite/Makefile.in,\n+        configure,\n+        aclocal.m4: Regenerated\n+        * ltcf-c.sh: properly escape cygwin/w32 path\n+        * man/ffi_call.3: Clarify size requirements for return value.\n+        * src/x86/ffi64.c: Fix filename in comment.\n+        * src/x86/win32.S: Remove unused extern.\n+\n+        * testsuite/libffi.call/closure_fn0.c,\n+        testsuite/libffi.call/closure_fn1.c,\n+        testsuite/libffi.call/closure_fn2.c,\n+        testsuite/libffi.call/closure_fn3.c,\n+        testsuite/libffi.call/closure_fn4.c,\n+        testsuite/libffi.call/closure_fn5.c,\n+        testsuite/libffi.call/closure_fn6.c,\n+\ttestsuite/libffi.call/closure_stdcall.c,\n+\ttestsuite/libffi.call/cls_12byte.c,\n+\ttestsuite/libffi.call/cls_16byte.c,\n+\ttestsuite/libffi.call/cls_18byte.c,\n+\ttestsuite/libffi.call/cls_19byte.c,\n+\ttestsuite/libffi.call/cls_1_1byte.c,\n+\ttestsuite/libffi.call/cls_20byte.c,\n+\ttestsuite/libffi.call/cls_20byte1.c,\n+\ttestsuite/libffi.call/cls_24byte.c,\n+\ttestsuite/libffi.call/cls_2byte.c,\n+\ttestsuite/libffi.call/cls_3_1byte.c,\n+\ttestsuite/libffi.call/cls_3byte1.c,\n+ \ttestsuite/libffi.call/cls_3byte2.c,\n+ \ttestsuite/libffi.call/cls_4_1byte.c,\n+ \ttestsuite/libffi.call/cls_4byte.c,\n+ \ttestsuite/libffi.call/cls_5_1_byte.c,\n+ \ttestsuite/libffi.call/cls_5byte.c,\n+ \ttestsuite/libffi.call/cls_64byte.c,\n+ \ttestsuite/libffi.call/cls_6_1_byte.c,\n+ \ttestsuite/libffi.call/cls_6byte.c,\n+ \ttestsuite/libffi.call/cls_7_1_byte.c,\n+ \ttestsuite/libffi.call/cls_7byte.c,\n+ \ttestsuite/libffi.call/cls_8byte.c,\n+ \ttestsuite/libffi.call/cls_9byte1.c,\n+ \ttestsuite/libffi.call/cls_9byte2.c,\n+ \ttestsuite/libffi.call/cls_align_double.c,\n+ \ttestsuite/libffi.call/cls_align_float.c,\n+ \ttestsuite/libffi.call/cls_align_longdouble.c,\n+ \ttestsuite/libffi.call/cls_align_longdouble_split.c,\n+ \ttestsuite/libffi.call/cls_align_longdouble_split2.c,\n+ \ttestsuite/libffi.call/cls_align_pointer.c,\n+ \ttestsuite/libffi.call/cls_align_sint16.c,\n+ \ttestsuite/libffi.call/cls_align_sint32.c,\n+ \ttestsuite/libffi.call/cls_align_sint64.c,\n+ \ttestsuite/libffi.call/cls_align_uint16.c,\n+ \ttestsuite/libffi.call/cls_align_uint32.c,\n+ \ttestsuite/libffi.call/cls_align_uint64.c,\n+ \ttestsuite/libffi.call/cls_dbls_struct.c,\n+ \ttestsuite/libffi.call/cls_double.c,\n+ \ttestsuite/libffi.call/cls_double_va.c,\n+ \ttestsuite/libffi.call/cls_float.c,\n+ \ttestsuite/libffi.call/cls_longdouble.c,\n+ \ttestsuite/libffi.call/cls_longdouble_va.c,\n+ \ttestsuite/libffi.call/cls_multi_schar.c,\n+ \ttestsuite/libffi.call/cls_multi_sshort.c,\n+ \ttestsuite/libffi.call/cls_multi_sshortchar.c,\n+ \ttestsuite/libffi.call/cls_multi_uchar.c,\n+ \ttestsuite/libffi.call/cls_multi_ushort.c,\n+ \ttestsuite/libffi.call/cls_multi_ushortchar.c,\n+ \ttestsuite/libffi.call/cls_pointer.c,\n+ \ttestsuite/libffi.call/cls_pointer_stack.c,\n+ \ttestsuite/libffi.call/cls_schar.c,\n+ \ttestsuite/libffi.call/cls_sint.c,\n+ \ttestsuite/libffi.call/cls_sshort.c,\n+ \ttestsuite/libffi.call/cls_uchar.c,\n+ \ttestsuite/libffi.call/cls_uint.c,\n+ \ttestsuite/libffi.call/cls_ulonglong.c,\n+ \ttestsuite/libffi.call/cls_ushort.c,\n+ \ttestsuite/libffi.call/err_bad_abi.c,\n+ \ttestsuite/libffi.call/err_bad_typedef.c,\n+ \ttestsuite/libffi.call/float2.c,\n+ \ttestsuite/libffi.call/huge_struct.c,\n+ \ttestsuite/libffi.call/nested_struct.c,\n+ \ttestsuite/libffi.call/nested_struct1.c,\n+ \ttestsuite/libffi.call/nested_struct10.c,\n+ \ttestsuite/libffi.call/nested_struct2.c,\n+ \ttestsuite/libffi.call/nested_struct3.c,\n+ \ttestsuite/libffi.call/nested_struct4.c,\n+ \ttestsuite/libffi.call/nested_struct5.c,\n+ \ttestsuite/libffi.call/nested_struct6.c,\n+ \ttestsuite/libffi.call/nested_struct7.c,\n+ \ttestsuite/libffi.call/nested_struct8.c,\n+ \ttestsuite/libffi.call/nested_struct9.c,\n+ \ttestsuite/libffi.call/problem1.c,\n+ \ttestsuite/libffi.call/return_ldl.c,\n+ \ttestsuite/libffi.call/return_ll1.c,\n+ \ttestsuite/libffi.call/stret_large.c,\n+ \ttestsuite/libffi.call/stret_large2.c,\n+ \ttestsuite/libffi.call/stret_medium.c,\n+ \ttestsuite/libffi.call/stret_medium2.c,\n+        testsuite/libffi.special/unwindtest.cc: use ffi_closure_alloc instead\n+        of checking for MMAP.  Use intptr_t instead of long casts.\n+\n+2009-06-04  Andrew Haley  <aph@redhat.com>\n+\n+\t* src/powerpc/ffitarget.h: Fix misapplied merge from gcc.\n+\n+2009-06-04  Andrew Haley  <aph@redhat.com>\n+\n+\t* src/mips/o32.S,\n+\tsrc/mips/n32.S: Fix licence formatting.\n+\n+2009-06-04  Andrew Haley  <aph@redhat.com>\n+\n+\t* src/x86/darwin.S: Fix licence formatting.\n+\tsrc/x86/win32.S: Likewise.\n+\tsrc/sh64/sysv.S: Likewise.\n+\tsrc/sh/sysv.S: Likewise.\n+\n+2009-06-04  Andrew Haley  <aph@redhat.com>\n+\n+\t* src/sh64/ffi.c: Remove lint directives.  Was missing from merge\n+\tof Andreas Tobler's patch from 2006-04-22.\n+\t\n+2009-06-04  Andrew Haley  <aph@redhat.com>\n+\n+\t* src/sh/ffi.c: Apply missing hunk from Alexandre Oliva's patch of\n+\t2007-03-07.\n+\n+2008-12-26  Timothy Wall  <twall@users.sf.net>\n+\n+\t* testsuite/libffi.call/cls_longdouble.c,\n+        testsuite/libffi.call/cls_longdouble_va.c,\n+        testsuite/libffi.call/cls_align_longdouble.c,\n+        testsuite/libffi.call/cls_align_longdouble_split.c,\n+        testsuite/libffi.call/cls_align_longdouble_split2.c: mark expected\n+        failures on x86_64 cygwin/mingw.\n+\n+2008-12-22  Timothy Wall  <twall@users.sf.net>\n+\n+\t* testsuite/libffi.call/closure_fn0.c,\n+        testsuite/libffi.call/closure_fn1.c,    \n+        testsuite/libffi.call/closure_fn2.c,    \n+        testsuite/libffi.call/closure_fn3.c,    \n+        testsuite/libffi.call/closure_fn4.c,    \n+        testsuite/libffi.call/closure_fn5.c,    \n+        testsuite/libffi.call/closure_fn6.c,    \n+        testsuite/libffi.call/closure_loc_fn0.c,    \n+        testsuite/libffi.call/closure_stdcall.c,    \n+        testsuite/libffi.call/cls_align_pointer.c,    \n+        testsuite/libffi.call/cls_pointer.c,    \n+        testsuite/libffi.call/cls_pointer_stack.c: use portable cast from\n+        pointer to integer (intptr_t).\n+        * testsuite/libffi.call/cls_longdouble.c: disable for win64.\n+\t\n+2008-12-19  Anthony Green  <green@redhat.com>\n+\n+\t* configure.ac: Bump version to 3.0.8.\n+\t* configure, doc/stamp-vti, doc/version.texi: Rebuilt.\n+\t* libtool-version: Increment revision.\n+\t* README: Update for new release.\n+\n+2008-11-11  Anthony Green  <green@redhat.com>\n+\n+\t* configure.ac: Bump version to 3.0.7.\n+\t* configure, doc/stamp-vti, doc/version.texi: Rebuilt.\n+\t* libtool-version: Increment revision.\n+\t* README: Update for new release.\n+\n+2008-08-25  Andreas Tobler  <a.tobler@schweiz.org>\n+\n+\t* src/powerpc/ffitarget.h (ffi_abi): Add FFI_LINUX and\n+\tFFI_LINUX_SOFT_FLOAT to the POWERPC_FREEBSD enum.\n+\tAdd note about flag bits used for FFI_SYSV_TYPE_SMALL_STRUCT.\n+\tAdjust copyright notice.\n+\t* src/powerpc/ffi.c: Add two new flags to indicate if we have one\n+\tregister or two register to use for FFI_SYSV structs.\n+\t(ffi_prep_cif_machdep): Pass the right register flag introduced above.\n+\t(ffi_closure_helper_SYSV): Fix the return type for\n+\tFFI_SYSV_TYPE_SMALL_STRUCT. Comment.\n+\tAdjust copyright notice.\n+\n+2008-07-24  Anthony Green  <green@redhat.com>\n+\n+\t* testsuite/libffi.call/cls_dbls_struct.c,\n+\ttestsuite/libffi.call/cls_double_va.c,\n+\ttestsuite/libffi.call/cls_longdouble.c,\n+\ttestsuite/libffi.call/cls_longdouble_va.c,\n+\ttestsuite/libffi.call/cls_pointer.c,\n+\ttestsuite/libffi.call/cls_pointer_stack.c,\n+\ttestsuite/libffi.call/err_bad_abi.c: Clean up failures from\n+\tcompiler warnings.\n+\n+2008-07-17  Anthony Green  <green@redhat.com>\n+\n+\t* configure.ac: Bump version to 3.0.6.\n+\t* configure, doc/stamp-vti, doc/version.texi: Rebuilt.\n+\t* libtool-version: Increment revision.  Add documentation.\n+\t* README: Update for new release.\n+\n+2008-07-16  Kaz Kojima  <kkojima@gcc.gnu.org>\n+\n+\t* src/sh/ffi.c (ffi_prep_closure_loc): Turn INSN into an unsigned\n+\tint.\n+\n+2008-07-16  Kaz Kojima  <kkojima@gcc.gnu.org>\n+\n+\t* src/sh/sysv.S: Add .note.GNU-stack on Linux.\n+\t* src/sh64/sysv.S: Likewise.\n+\n+2008-04-03  Anthony Green  <green@redhat.com>\n+\n+\t* libffi.pc.in (Libs): Add -L${libdir}.\n+\t* configure.ac: Bump version to 3.0.5.\n+\t* configure, doc/stamp-vti, doc/version.texi: Rebuilt.\n+\t* libtool-version: Increment revision.\n+\t* README: Update for new release.\n+\n+2008-04-03  Anthony Green  <green@redhat.com>\n+\t    Xerces Ranby  <xerxes@zafena.se>\n+\n+\t* include/ffi.h.in: Wrap definition of target architecture to\n+\tprotect from double definitions.\n+\n+2008-03-22  Moriyoshi Koizumi  <moriyoshi@gmail.com>\n+\n+\t* src/x86/ffi.c (ffi_prep_closure_loc): Fix for bug revealed in\n+\tclosure_loc_fn0.c.\n+\t* testsuite/libffi.call/closure_loc_fn0.c (closure_loc_test_fn0):\n+\tNew test.\n+\n+2008-03-04  Anthony Green  <green@redhat.com>\n+\t    Blake Chaffin\n+\t    hos@tamanegi.org\n+\n+\t* testsuite/libffi.call/cls_align_longdouble_split2.c\n+          testsuite/libffi.call/cls_align_longdouble_split.c\n+          testsuite/libffi.call/cls_dbls_struct.c\n+          testsuite/libffi.call/cls_double_va.c\n+          testsuite/libffi.call/cls_longdouble.c\n+          testsuite/libffi.call/cls_longdouble_va.c\n+          testsuite/libffi.call/cls_pointer.c\n+          testsuite/libffi.call/cls_pointer_stack.c\n+          testsuite/libffi.call/err_bad_abi.c\n+          testsuite/libffi.call/err_bad_typedef.c\n+          testsuite/libffi.call/huge_struct.c\n+          testsuite/libffi.call/stret_large2.c\n+          testsuite/libffi.call/stret_large.c\n+          testsuite/libffi.call/stret_medium2.c\n+          testsuite/libffi.call/stret_medium.c: New tests from Apple.\n+\n+2008-02-26  Jakub Jelinek  <jakub@redhat.com>\n+            Anthony Green  <green@redhat.com>\n+\n+\t* src/alpha/osf.S: Add .note.GNU-stack on Linux.\n+\t* src/s390/sysv.S: Likewise.\n+\t* src/powerpc/linux64.S: Likewise.\n+\t* src/powerpc/linux64_closure.S: Likewise.\n+\t* src/powerpc/ppc_closure.S: Likewise.\n+\t* src/powerpc/sysv.S: Likewise.\n+\t* src/x86/unix64.S: Likewise.\n+\t* src/x86/sysv.S: Likewise.\n+\t* src/sparc/v8.S: Likewise.\n+\t* src/sparc/v9.S: Likewise.\n+\t* src/m68k/sysv.S: Likewise.\n+\t* src/ia64/unix.S: Likewise.\n+\t* src/arm/sysv.S: Likewise.\n+\n+2008-02-26  Anthony Green  <green@redhat.com>\n+            Thomas Heller  <theller@ctypes.org>\n+\n+\t* src/x86/ffi.c (ffi_closure_SYSV_inner): Change C++ comment to C\n+\tcomment.\n+\n+2008-02-26  Anthony Green  <green@redhat.org>\n+            Thomas Heller  <theller@ctypes.org>\n+\n+\t* include/ffi.h.in: Change void (*)() to void (*)(void).\n+\n+2008-02-26  Anthony Green  <green@redhat.org>\n+            Thomas Heller  <theller@ctypes.org>\n+\n+\t* src/alpha/ffi.c: Change void (*)() to void (*)(void).\n+\tsrc/alpha/osf.S, src/arm/ffi.c, src/frv/ffi.c, src/ia64/ffi.c,\n+\tsrc/ia64/unix.S, src/java_raw_api.c, src/m32r/ffi.c,\n+\tsrc/mips/ffi.c, src/pa/ffi.c, src/pa/hpux32.S, src/pa/linux.S,\n+\tsrc/powerpc/ffi.c, src/powerpc/ffi_darwin.c, src/raw_api.c,\n+\tsrc/s390/ffi.c, src/sh/ffi.c, src/sh64/ffi.c, src/sparc/ffi.c,\n+\tsrc/x86/ffi.c, src/x86/unix64.S, src/x86/darwin64.S,\n+\tsrc/x86/ffi64.c: Ditto.\n+\n+2008-02-24  Anthony Green  <green@redhat.org>\n+\n+\t* configure.ac: Accept openbsd*, not just openbsd.\n+\tBump version to 3.0.4.\n+\t* configure, doc/stamp-vti, doc/version.texi: Rebuilt.\n+\t* libtool-version: Increment revision.\n+\t* README: Update for new release.\n+\n+2008-02-22  Anthony Green  <green@redhat.com>\n+\n+\t* README: Clean up list of tested platforms.\n+\n+2008-02-22  Anthony Green  <green@redhat.com>\n+\n+\t* configure.ac: Bump version to 3.0.3.\n+\t* configure, doc/stamp-vti, doc/version.texi: Rebuilt.\n+\t* libtool-version: Increment revision.\n+\t* README: Update for new release.  Clean up test docs.\n+\n+2008-02-22  Bjoern Koenig  <bkoenig@alpha-tierchen.de>\n+\t    Andreas Tobler  <a.tobler@schweiz.org>\n+\n+\t* configure.ac: Add amd64-*-freebsd* target.\n+\t* configure: Regenerate.\n+\n+2008-02-22  Thomas Heller <theller@ctypes.org>\n+\n+\t* configure.ac: Add x86 OpenBSD support.\n+\t* configure: Rebuilt.\n+\n+2008-02-21  Thomas Heller <theller@ctypes.org>\n+\n+\t* README: Change \"make test\" to \"make check\".\n+\n+2008-02-21  Anthony Green  <green@redhat.com>\n+\n+\t* configure.ac: Bump version to 3.0.2.\n+\t* configure, doc/stamp-vti, doc/version.texi: Rebuilt.\n+\t* libtool-version: Increment revision.\n+\t* README: Update for new release.\n+\n+2008-02-21  Bj\u00f6rn K\u00f6nig <bkoenig@alpha-tierchen.de>\n+\n+\t* src/x86/freebsd.S: New file.\n+\t* configure.ac: Add x86 FreeBSD support.\n+\t* Makefile.am: Ditto.\n+\n+2008-02-15  Anthony Green  <green@redhat.com>\n+\n+\t* configure.ac: Bump version to 3.0.1.\n+\t* configure, doc/stamp-vti, doc/version.texi: Rebuilt.\n+\t* libtool-version: Increment revision.\n+\t* README: Update for new release.\n+\n+2008-02-15  David Daney\t <ddaney@avtrex.com>\n+\n+\t* src/mips/ffi.c: Remove extra '>' from include directive.\n+\t(ffi_prep_closure_loc): Use clear_location instead of tramp.\n+\n+2008-02-15  Anthony Green  <green@redhat.com>\n+\n+\t* configure.ac: Bump version to 3.0.0.\n+\t* configure, doc/stamp-vti, doc/version.texi: Rebuilt.\n+\n+2008-02-15  David Daney\t <ddaney@avtrex.com>\n+\n+\t* src/mips/ffi.c (USE__BUILTIN___CLEAR_CACHE):\n+\tDefine (conditionally), and use it to include cachectl.h.\n+\t(ffi_prep_closure_loc): Fix cache flushing.\n+\t* src/mips/ffitarget.h (_ABIN32, _ABI64, _ABIO32): Define.\n+\n+2008-02-15  Anthony Green  <green@redhat.com>\n+\n+        * man/ffi_call.3, man/ffi_prep_cif.3, man/ffi.3:\n+\tUpdate dates and remove all references to ffi_prep_closure.\n+\t* configure.ac: Bump version to 2.99.9.\n+\t* configure, doc/stamp-vti, doc/version.texi: Rebuilt.\n+\n+2008-02-15  Anthony Green  <green@redhat.com>\n+\n+\t* man/ffi_prep_closure.3: Delete.\n+\t* man/Makefile.am (EXTRA_DIST): Remove ffi_prep_closure.3.\n+\t(man_MANS): Ditto.\n+\t* man/Makefile.in: Rebuilt.\n+\t* configure.ac: Bump version to 2.99.8.\n+\t* configure, doc/stamp-vti, doc/version.texi: Rebuilt.\n+\n+2008-02-14  Anthony Green  <green@redhat.com>\n+\n+\t* configure.ac: Bump version to 2.99.7.\n+\t* configure, doc/stamp-vti, doc/version.texi: Rebuilt.\n+\t* include/ffi.h.in LICENSE src/debug.c src/closures.c\n+          src/ffitest.c src/s390/sysv.S src/s390/ffitarget.h\n+          src/types.c src/m68k/ffitarget.h src/raw_api.c src/frv/ffi.c\n+          src/frv/ffitarget.h src/sh/ffi.c src/sh/sysv.S\n+          src/sh/ffitarget.h src/powerpc/ffitarget.h src/pa/ffi.c\n+          src/pa/ffitarget.h src/pa/linux.S src/java_raw_api.c\n+          src/cris/ffitarget.h src/x86/ffi.c src/x86/sysv.S\n+          src/x86/unix64.S src/x86/win32.S src/x86/ffitarget.h\n+          src/x86/ffi64.c src/x86/darwin.S src/ia64/ffi.c\n+          src/ia64/ffitarget.h src/ia64/ia64_flags.h src/ia64/unix.S\n+          src/sparc/ffi.c src/sparc/v9.S src/sparc/ffitarget.h\n+          src/sparc/v8.S src/alpha/ffi.c src/alpha/ffitarget.h\n+          src/alpha/osf.S src/sh64/ffi.c src/sh64/sysv.S\n+          src/sh64/ffitarget.h src/mips/ffi.c src/mips/ffitarget.h\n+          src/mips/n32.S src/mips/o32.S src/arm/ffi.c src/arm/sysv.S\n+          src/arm/ffitarget.h src/prep_cif.c: Update license text.\n+\n+2008-02-14  Anthony Green  <green@redhat.com>\n+\n+\t* README: Update tested platforms.\n+\t* configure.ac: Bump version to 2.99.6.\n+\t* configure: Rebuilt.\n+\n+2008-02-14  Anthony Green  <green@redhat.com>\n+\n+\t* configure.ac: Bump version to 2.99.5.\n+\t* configure: Rebuilt.\n+\t* Makefile.am (EXTRA_DIST): Add darwin64.S\n+\t* Makefile.in: Rebuilt.\n+\t* testsuite/lib/libffi-dg.exp: Remove libstdc++ bits from GCC tree.\n+\t* LICENSE: Update WARRANTY.\n+\n+2008-02-14  Anthony Green  <green@redhat.com>\n+\n+\t* libffi.pc.in (libdir): Fix libdir definition.\n+\t* configure.ac: Bump version to 2.99.4.\n+\t* configure: Rebuilt.\n+\n+2008-02-14  Anthony Green  <green@redhat.com>\n+\n+\t* README: Update.\n+\t* libffi.info: New file.\n+\t* doc/stamp-vti: New file.\n+\t* configure.ac: Bump version to 2.99.3.\n+\t* configure: Rebuilt.\n+\n+2008-02-14  Anthony Green  <green@redhat.com>\n+\n+\t* Makefile.am (SUBDIRS): Add man dir.\n+\t* Makefile.in: Rebuilt.\n+\t* configure.ac: Create Makefile.\n+\t* configure: Rebuilt.\n+        * man/ffi_call.3 man/ffi_prep_cif.3 man/ffi_prep_closure.3\n+          man/Makefile.am man/Makefile.in: New files.\n+\n+2008-02-14  Tom Tromey  <tromey@redhat.com>\n+\n+\t* aclocal.m4, Makefile.in, configure, fficonfig.h.in: Rebuilt.\n+\t* mdate-sh, texinfo.tex: New files.\n+\t* Makefile.am (info_TEXINFOS): New variable.\n+\t* doc/libffi.texi: New file.\n+\t* doc/version.texi: Likewise.\n+\n+2008-02-14  Anthony Green  <green@redhat.com>\n+\n+\t* Makefile.am (AM_CFLAGS): Don't compile with -D$(TARGET).\n+\t(lib_LTLIBRARIES): Define.\n+\t(toolexeclib_LIBRARIES): Undefine.\n+\t* Makefile.in: Rebuilt.\n+\t* configure.ac: Reset version to 2.99.1.\n+\t* configure.in: Rebuilt.\n+\n+2008-02-14  Anthony Green  <green@redhat.com>\n+\n+\t* libffi.pc.in: Use @PACKAGE_NAME@ and @PACKAGE_VERSION@.\n+\t* configure.ac: Reset version to 2.99.1.\n+\t* configure.in: Rebuilt.\n+\t* Makefile.am (EXTRA_DIST): Add ChangeLog.libffi.\n+\t* Makefile.in: Rebuilt.\n+\t* LICENSE: Update copyright notice.\n+\n+2008-02-14  Anthony Green  <green@redhat.com>\n+\n+\t* include/Makefile.am (nodist_includes_HEADERS): Define.  Don't\n+\tdistribute ffitarget.h or ffi.h from the build include dir.\n+\t* Makefile.in: Rebuilt.\n+\n+2008-02-14  Anthony Green  <green@redhat.com>\n+\n+\t* include/Makefile.am (includesdir): Install headers under libdir.\n+\t(pkgconfigdir): Define. Install libffi.pc.\n+\t* include/Makefile.in: Rebuilt.\n+\t* libffi.pc.in: Create.\n+\t* libtool-version: Increment CURRENT\n+\t* configure.ac: Add libffi.pc.in\n+\t* configure: Rebuilt.\n+\n+2008-02-03  Anthony Green  <green@redhat.com>\n+\n+\t* include/Makefile.am (includesdir): Fix header install with\n+\tDESTDIR.\n+\t* include/Makefile.in: Rebuilt.\n+\n+2008-02-03  Timothy Wall  <twall@users.sf.net>\n+\n+\t* src/x86/ffi.c (FFI_INIT_TRAMPOLINE_STDCALL): Calculate jump return\n+          offset based on code pointer, not data pointer.\n+\n+2008-02-01  Anthony Green  <green@redhat.com>\n+\n+\t* include/Makefile.am: Fix header installs.\n+\t* Makefile.am: Ditto.\n+\t* include/Makefile.in: Rebuilt.\n+\t* Makefile.in: Ditto.\n+\n+2008-02-01  Anthony Green  <green@redhat.com>\n+\n+\t* src/x86/ffi.c (FFI_INIT_TRAMPOLINE_STDCALL,\n+\tFFI_INIT_TRAMPOLINE): Revert my broken changes to twall's last\n+\tpatch.\n+\n+2008-01-31  Anthony Green  <green@redhat.com>\n+\n+\t* Makefile.am (EXTRA_DIST): Add missing files.\n+\t* testsuite/Makefile.am: Ditto.\n+\t* Makefile.in, testsuite/Makefile.in: Rebuilt.\n+\n+2008-01-31  Timothy Wall <twall@users.sf.net>\n+\n+\t* testsuite/libffi.call/closure_stdcall.c: Add test for stdcall\n+\tclosures.\n+\t* src/x86/ffitarget.h: Increase size of trampoline for stdcall\n+\tclosures.\n+\t* src/x86/win32.S: Add assembly for stdcall closure.\n+\t* src/x86/ffi.c: Initialize stdcall closure trampoline.\n+\n+2008-01-30  H.J. Lu <hongjiu.lu@intel.com>\n+\n+\tPR libffi/34612\n+\t* src/x86/sysv.S (ffi_closure_SYSV): Pop 4 byte from stack when\n+\treturning struct.\n+\n+\t* testsuite/libffi.call/call.exp: Add \"-O2 -fomit-frame-pointer\"\n+\ttests.\n+\n+2008-01-30  Anthony Green  <green@redhat.com>\n+\n+\t* Makefile.am, include/Makefile.am: Move headers to\n+\tlibffi_la_SOURCES for new automake.\n+\t* Makefile.in, include/Makefile.in: Rebuilt.\n+\t\n+\t* testsuite/lib/wrapper.exp: Copied from gcc tree to allow for \n+\texecution outside of gcc tree.\n+\t* testsuite/lib/target-libpath.exp: Ditto.\n+\n+\t* testsuite/lib/libffi-dg.exp: Many changes to allow for execution\n+\toutside of gcc tree.\n+"}, {"sha": "cda4670614165782de7c6f22941585c81e5c8c7c", "filename": "libffi/Makefile.am", "status": "modified", "additions": 53, "deletions": 28, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2FMakefile.am?ref=b4b575ce7854f4a49de8de93f38b7639e01b040b", "patch": "@@ -1,36 +1,45 @@\n ## Process this with automake to create Makefile.in\n \n AUTOMAKE_OPTIONS = foreign subdir-objects\n-ACLOCAL_AMFLAGS = -I .. -I ../config\n \n SUBDIRS = include testsuite man\n \n-EXTRA_DIST = LICENSE ChangeLog.v1 ChangeLog.libgcj configure.host \\\n-\tsrc/alpha/ffi.c src/alpha/osf.S src/alpha/ffitarget.h \\\n-\tsrc/arm/ffi.c src/arm/sysv.S src/arm/ffitarget.h \\\n-\tsrc/avr32/ffi.c src/avr32/sysv.S src/avr32/ffitarget.h \\\n-\tsrc/cris/ffi.c src/cris/sysv.S src/cris/ffitarget.h \\\n-\tsrc/ia64/ffi.c src/ia64/ffitarget.h src/ia64/ia64_flags.h \\\n-\tsrc/ia64/unix.S \\\n-\tsrc/mips/ffi.c src/mips/n32.S src/mips/o32.S \\\n-\tsrc/mips/ffitarget.h \\\n-\tsrc/m32r/ffi.c src/m32r/sysv.S src/m32r/ffitarget.h \\\n-\tsrc/m68k/ffi.c src/m68k/sysv.S src/m68k/ffitarget.h \\\n-\tsrc/powerpc/ffi.c src/powerpc/sysv.S \\\n-\tsrc/powerpc/linux64.S src/powerpc/linux64_closure.S \\\n-\tsrc/powerpc/ppc_closure.S src/powerpc/asm.h \\\n-\tsrc/powerpc/aix.S src/powerpc/darwin.S \\\n-\tsrc/powerpc/aix_closure.S src/powerpc/darwin_closure.S \\\n-\tsrc/powerpc/ffi_darwin.c src/powerpc/ffitarget.h \\\n-\tsrc/s390/ffi.c src/s390/sysv.S src/s390/ffitarget.h \\\n-\tsrc/sh/ffi.c src/sh/sysv.S src/sh/ffitarget.h \\\n-\tsrc/sh64/ffi.c src/sh64/sysv.S src/sh64/ffitarget.h \\\n-\tsrc/sparc/v8.S src/sparc/v9.S src/sparc/ffitarget.h \\\n-\tsrc/sparc/ffi.c src/x86/darwin64.S \\\n-\tsrc/x86/ffi.c src/x86/sysv.S src/x86/win32.S src/x86/darwin.S \\\n-\tsrc/x86/ffi64.c src/x86/unix64.S src/x86/ffitarget.h \\\n-\tsrc/pa/ffitarget.h src/pa/ffi.c src/pa/linux.S src/pa/hpux32.S \\\n-\tsrc/frv/ffi.c src/frv/eabi.S src/frv/ffitarget.h src/dlmalloc.c\n+EXTRA_DIST = LICENSE ChangeLog.v1 ChangeLog.libgcj configure.host\t\\\n+\t src/aarch64/ffi.c src/aarch64/ffitarget.h\t\t\t\\\n+\t src/alpha/ffi.c src/alpha/osf.S src/alpha/ffitarget.h\t\t\\\n+\t src/arm/ffi.c src/arm/sysv.S src/arm/ffitarget.h\t\t\\\n+\t src/avr32/ffi.c src/avr32/sysv.S src/avr32/ffitarget.h\t\t\\\n+\t src/cris/ffi.c src/cris/sysv.S src/cris/ffitarget.h\t\t\\\n+\t src/ia64/ffi.c src/ia64/ffitarget.h src/ia64/ia64_flags.h\t\\\n+\t src/ia64/unix.S src/mips/ffi.c src/mips/n32.S src/mips/o32.S\t\\\n+\t src/mips/ffitarget.h src/m32r/ffi.c src/m32r/sysv.S\t\t\\\n+\t src/m32r/ffitarget.h src/m68k/ffi.c src/m68k/sysv.S\t\t\\\n+\t src/m68k/ffitarget.h src/powerpc/ffi.c src/powerpc/sysv.S\t\\\n+\t src/powerpc/linux64.S src/powerpc/linux64_closure.S\t\t\\\n+\t src/powerpc/ppc_closure.S src/powerpc/asm.h\t\t\t\\\n+\tsrc/powerpc/aix.S src/powerpc/darwin.S\t\t\t\t\\\n+\tsrc/powerpc/aix_closure.S src/powerpc/darwin_closure.S\t\t\\\n+\tsrc/powerpc/ffi_darwin.c src/powerpc/ffitarget.h\t\t\\\n+\tsrc/s390/ffi.c src/s390/sysv.S src/s390/ffitarget.h\t\t\\\n+\tsrc/sh/ffi.c src/sh/sysv.S src/sh/ffitarget.h src/sh64/ffi.c\t\\\n+\tsrc/sh64/sysv.S src/sh64/ffitarget.h src/sparc/v8.S\t\t\\\n+\tsrc/sparc/v9.S src/sparc/ffitarget.h src/sparc/ffi.c\t\t\\\n+\tsrc/x86/darwin64.S src/x86/ffi.c src/x86/sysv.S\t\t\t\\\n+\tsrc/x86/win32.S src/x86/darwin.S src/x86/win64.S\t\t\\\n+\tsrc/x86/freebsd.S src/x86/ffi64.c src/x86/unix64.S\t\t\\\n+\tsrc/x86/ffitarget.h src/pa/ffitarget.h src/pa/ffi.c\t\t\\\n+\tsrc/pa/linux.S src/pa/hpux32.S src/frv/ffi.c src/bfin/ffi.c\t\\\n+\tsrc/bfin/ffitarget.h src/bfin/sysv.S src/frv/eabi.S\t\t\\\n+\tsrc/frv/ffitarget.h src/dlmalloc.c src/tile/ffi.c\t\t\\\n+\tsrc/tile/ffitarget.h src/tile/tile.S libtool-version\t\t\\\n+\t ChangeLog.libffi m4/libtool.m4 m4/lt~obsolete.m4\t\t\\\n+\t m4/ltoptions.m4 m4/ltsugar.m4 m4/ltversion.m4\t\t\t\\\n+\t m4/ltversion.m4 src/arm/gentramp.sh src/debug.c msvcc.sh\t\\\n+\tgenerate-ios-source-and-headers.py\t\t\t\t\\\n+\t generate-osx-source-and-headers.py\t\t\t\t\\\n+\t libffi.xcodeproj/project.pbxproj src/arm/trampoline.S\n+\n+info_TEXINFOS = doc/libffi.texi\n \n ## ################################################################\n \n@@ -84,14 +93,21 @@ MAKEOVERRIDES=\n toolexeclib_LTLIBRARIES = libffi.la\n noinst_LTLIBRARIES = libffi_convenience.la\n \n-libffi_la_SOURCES = src/debug.c src/prep_cif.c src/types.c \\\n+libffi_la_SOURCES = src/prep_cif.c src/types.c \\\n \t\tsrc/raw_api.c src/java_raw_api.c src/closures.c\n \n nodist_libffi_la_SOURCES =\n \n+if FFI_DEBUG\n+nodist_libffi_la_SOURCES += src/debug.c\n+endif\n+\n if MIPS\n nodist_libffi_la_SOURCES += src/mips/ffi.c src/mips/o32.S src/mips/n32.S\n endif\n+if BFIN\n+nodist_libffi_la_SOURCES += src/bfin/ffi.c src/bfin/sysv.S\n+endif\n if X86\n nodist_libffi_la_SOURCES += src/x86/ffi.c src/x86/sysv.S\n endif\n@@ -134,8 +150,14 @@ endif\n if POWERPC_FREEBSD\n nodist_libffi_la_SOURCES += src/powerpc/ffi.c src/powerpc/sysv.S src/powerpc/ppc_closure.S\n endif\n+if AARCH64\n+nodist_libffi_la_SOURCES += src/aarch64/sysv.S src/aarch64/ffi.c\n+endif\n if ARM\n nodist_libffi_la_SOURCES += src/arm/sysv.S src/arm/ffi.c\n+if FFI_EXEC_TRAMPOLINE_TABLE\n+nodist_libffi_la_SOURCES += src/arm/trampoline.S\n+endif\n endif\n if AVR32\n nodist_libffi_la_SOURCES += src/avr32/sysv.S src/avr32/ffi.c\n@@ -164,6 +186,9 @@ endif\n if PA_HPUX\n nodist_libffi_la_SOURCES += src/pa/hpux32.S src/pa/ffi.c\n endif\n+if TILE\n+nodist_libffi_la_SOURCES += src/tile/tile.S src/tile/ffi.c\n+endif\n \n libffi_convenience_la_SOURCES = $(libffi_la_SOURCES)\n nodist_libffi_convenience_la_SOURCES = $(nodist_libffi_la_SOURCES)"}, {"sha": "a0fb7174bbafa6ad453cde3b65b4ff3735b81718", "filename": "libffi/README", "status": "modified", "additions": 66, "deletions": 48, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2FREADME", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2FREADME", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2FREADME?ref=b4b575ce7854f4a49de8de93f38b7639e01b040b", "patch": "@@ -1,8 +1,8 @@\n Status\n ======\n \n-libffi-3.0.11 was released on *****************. Check the libffi web\n-page for updates: <URL:http://sourceware.org/libffi/>.\n+libffi-3.0.12 was released on XXXXXXX.  Check the libffi web page for\n+updates: <URL:http://sourceware.org/libffi/>.\n \n \n What is libffi?\n@@ -48,48 +48,52 @@ refer to the wiki page here:\n At the time of release, the following basic configurations have been\n tested:\n \n-|--------------+------------------|\n-| Architecture | Operating System |\n-|--------------+------------------|\n-| Alpha        | Linux            |\n-| Alpha        | Tru64            |\n-| ARM          | Linux            |\n-| ARM          | iOS              |\n-| AVR32        | Linux            |\n-| HPPA         | HPUX             |\n-| IA-64        | Linux            |\n-| M68K         | RTEMS            |\n-| MIPS         | IRIX             |\n-| MIPS         | Linux            |\n-| MIPS         | RTEMS            |\n-| MIPS64       | Linux            |\n-| PowerPC      | AMIGA            |\n-| PowerPC      | Linux            |\n-| PowerPC      | Mac OSX          |\n-| PowerPC      | FreeBSD          |\n-| PowerPC64    | Linux            |\n-| S390         | Linux            |\n-| S390X        | Linux            |\n-| SPARC        | Linux            |\n-| SPARC        | Solaris          |\n-| SPARC64      | Linux            |\n-| SPARC64      | FreeBSD          |\n-| X86          | FreeBSD          |\n-| X86          | Interix          |\n-| X86          | kFreeBSD         |\n-| X86          | Linux            |\n-| X86          | Linux/x32        |\n-| X86          | Mac OSX          |\n-| X86          | OpenBSD          |\n-| X86          | OS/2             |\n-| X86          | Solaris          |\n-| X86          | Windows/Cygwin   |\n-| X86          | Windows/MingW    |\n-| X86-64       | FreeBSD          |\n-| X86-64       | Linux            |\n-| X86-64       | OpenBSD          |\n-| X86-64       | Windows/MingW    |\n-|--------------+------------------|\n+|-----------------+------------------|\n+| Architecture    | Operating System |\n+|-----------------+------------------|\n+| AArch64         | Linux            |\n+| Alpha           | Linux            |\n+| Alpha           | Tru64            |\n+| ARM             | Linux            |\n+| ARM             | iOS              |\n+| AVR32           | Linux            |\n+| Blackfin        | uClinux          |\n+| HPPA            | HPUX             |\n+| IA-64           | Linux            |\n+| M68K            | FreeMiNT         |\n+| M68K            | RTEMS            |\n+| MIPS            | IRIX             |\n+| MIPS            | Linux            |\n+| MIPS            | RTEMS            |\n+| MIPS64          | Linux            |\n+| PowerPC         | AMIGA            |\n+| PowerPC         | Linux            |\n+| PowerPC         | Mac OSX          |\n+| PowerPC         | FreeBSD          |\n+| PowerPC64       | Linux            |\n+| S390            | Linux            |\n+| S390X           | Linux            |\n+| SPARC           | Linux            |\n+| SPARC           | Solaris          |\n+| SPARC64         | Linux            |\n+| SPARC64         | FreeBSD          |\n+| TILE-Gx/TILEPro | Linux            |\n+| X86             | FreeBSD          |\n+| X86             | Interix          |\n+| X86             | kFreeBSD         |\n+| X86             | Linux            |\n+| X86             | Mac OSX          |\n+| X86             | OpenBSD          |\n+| X86             | OS/2             |\n+| X86             | Solaris          |\n+| X86             | Windows/Cygwin   |\n+| X86             | Windows/MingW    |\n+| X86-64          | FreeBSD          |\n+| X86-64          | Linux            |\n+| X86-64          | Linux/x32        |\n+| X86-64          | OpenBSD          |\n+| X86-64          | Windows/MingW    |\n+|-----------------+------------------|\n \n Please send additional platform test results to\n libffi-discuss@sourceware.org and feel free to update the wiki page\n@@ -128,7 +132,7 @@ under a MingW environment, you may need to remove the line in configure\n that sets 'fix_srcfile_path' to a 'cygpath' command. ('cygpath' is not\n present in MingW, and is not required when using MingW-style paths.)\n \n-For iOS builds, refer to the build-ios.sh script for guidance.\n+For iOS builds, the 'libffi.xcodeproj' Xcode project is available.\n \n Configure has many other options. Use \"configure --help\" to see them all.\n \n@@ -146,13 +150,24 @@ History\n \n See the ChangeLog files for details.\n \n-3.0.11 MMM-DD-YY\n+3.0.12 XXX-XX-XX\n+\tAdd Blackfin support.\n+\tAdd TILE-Gx/TILEPro support.\n+\tAdd AArch64 support.\n+\tAdd support for PaX enabled kernels with MPROTECT.\n+\n+3.0.11 Apr-11-12\n         Lots of build fixes.\n-        Add Amiga newer MacOS support.\n+\tAdd Amiga newer MacOS support.\n+\tAdd support for variadic functions (ffi_prep_cif_var).\n \tAdd Linux/x32 support.\n-\tAdd thiscall and fastcall support on Windows.\n+\tAdd thiscall, fastcall and MSVC cdecl support on Windows.\n+\tAdd Amiga and newer MacOS support.\n+\tAdd m68k FreeMiNT support.\n+\tIntegration with iOS' xcode build tools.\n \tFix Octeon and MC68881 support.\n \tFix code pessimizations.\n+\tLots of build fixes.\n \n 3.0.10 Aug-23-11\n         Add support for Apple's iOS.\n@@ -311,8 +326,10 @@ Thorup.\n Major processor architecture ports were contributed by the following\n developers:\n \n+aarch64\t\tMarcus Shawcroft, James Greenhalgh\n alpha\t\tRichard Henderson\n arm\t\tRaffaele Sena\n+blackfin        Alexandre Keunecke I. de Mendonca\n cris\t\tSimon Posnjak, Hans-Peter Nilsson\n frv\t\tAnthony Green\n ia64\t\tHans Boehm\n@@ -328,6 +345,7 @@ s390\t\tGerhard Tonn, Ulrich Weigand\n sh\t\tKaz Kojima\n sh64\t\tKaz Kojima\n sparc\t\tAnthony Green, Gordon Irlam\n+tile-gx/tilepro Walter Lee\n x86\t\tAnthony Green, Jon Beniston\n x86-64\t\tBo Thorsen\n "}, {"sha": "706bd19163585c0b813ee1ca44c47d394ae6ffe7", "filename": "libffi/configure", "status": "modified", "additions": 157, "deletions": 44, "changes": 201, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fconfigure?ref=b4b575ce7854f4a49de8de93f38b7639e01b040b", "patch": "@@ -1,6 +1,6 @@\n #! /bin/sh\n # Guess values for system-dependent variables and create Makefiles.\n-# Generated by GNU Autoconf 2.64 for libffi 3.0.9.\n+# Generated by GNU Autoconf 2.64 for libffi 3.0.11.\n #\n # Report bugs to <http://gcc.gnu.org/bugs.html>.\n #\n@@ -559,8 +559,8 @@ MAKEFLAGS=\n # Identity of this package.\n PACKAGE_NAME='libffi'\n PACKAGE_TARNAME='libffi'\n-PACKAGE_VERSION='3.0.9'\n-PACKAGE_STRING='libffi 3.0.9'\n+PACKAGE_VERSION='3.0.11'\n+PACKAGE_STRING='libffi 3.0.11'\n PACKAGE_BUGREPORT='http://gcc.gnu.org/bugs.html'\n PACKAGE_URL=''\n \n@@ -606,10 +606,17 @@ LTLIBOBJS\n LIBOBJS\n toolexeclibdir\n toolexecdir\n+FFI_DEBUG_FALSE\n+FFI_DEBUG_TRUE\n TARGETDIR\n TARGET\n+FFI_EXEC_TRAMPOLINE_TABLE\n+FFI_EXEC_TRAMPOLINE_TABLE_FALSE\n+FFI_EXEC_TRAMPOLINE_TABLE_TRUE\n HAVE_LONG_DOUBLE\n ALLOCA\n+TILE_FALSE\n+TILE_TRUE\n PA64_HPUX_FALSE\n PA64_HPUX_TRUE\n PA_HPUX_FALSE\n@@ -632,6 +639,8 @@ AVR32_FALSE\n AVR32_TRUE\n ARM_FALSE\n ARM_TRUE\n+AARCH64_FALSE\n+AARCH64_TRUE\n POWERPC_FREEBSD_FALSE\n POWERPC_FREEBSD_TRUE\n POWERPC_DARWIN_FALSE\n@@ -660,6 +669,8 @@ X86_FALSE\n X86_TRUE\n SPARC_FALSE\n SPARC_TRUE\n+BFIN_FALSE\n+BFIN_TRUE\n MIPS_FALSE\n MIPS_TRUE\n AM_LTLDFLAGS\n@@ -795,6 +806,7 @@ enable_fast_install\n with_gnu_ld\n enable_libtool_lock\n enable_maintainer_mode\n+enable_pax_emutramp\n enable_debug\n enable_structs\n enable_raw_api\n@@ -1348,7 +1360,7 @@ if test \"$ac_init_help\" = \"long\"; then\n   # Omit some internal or obsolete options to make the list less imposing.\n   # This message is too long to be a string in the A/UX 3.1 sh.\n   cat <<_ACEOF\n-\\`configure' configures libffi 3.0.9 to adapt to many kinds of systems.\n+\\`configure' configures libffi 3.0.11 to adapt to many kinds of systems.\n \n Usage: $0 [OPTION]... [VAR=VALUE]...\n \n@@ -1419,7 +1431,7 @@ fi\n \n if test -n \"$ac_init_help\"; then\n   case $ac_init_help in\n-     short | recursive ) echo \"Configuration of libffi 3.0.9:\";;\n+     short | recursive ) echo \"Configuration of libffi 3.0.11:\";;\n    esac\n   cat <<\\_ACEOF\n \n@@ -1437,6 +1449,7 @@ Optional Features:\n   --disable-libtool-lock  avoid locking (might break parallel builds)\n   --enable-maintainer-mode  enable make rules and dependencies not useful\n \t\t\t  (and sometimes confusing) to the casual installer\n+  --enable-pax_emutramp       enable pax emulated trampolines, for we can't use PROT_EXEC\n   --enable-debug          debugging mode\n   --disable-structs       omit code for struct support\n   --disable-raw-api       make the raw api unavailable\n@@ -1527,7 +1540,7 @@ fi\n test -n \"$ac_init_help\" && exit $ac_status\n if $ac_init_version; then\n   cat <<\\_ACEOF\n-libffi configure 3.0.9\n+libffi configure 3.0.11\n generated by GNU Autoconf 2.64\n \n Copyright (C) 2009 Free Software Foundation, Inc.\n@@ -2076,7 +2089,7 @@ cat >config.log <<_ACEOF\n This file contains any messages produced by compilers while\n running configure, to aid debugging if configure makes a mistake.\n \n-It was created by libffi $as_me 3.0.9, which was\n+It was created by libffi $as_me 3.0.11, which was\n generated by GNU Autoconf 2.64.  Invocation command line was\n \n   $ $0 $@\n@@ -3043,7 +3056,7 @@ fi\n \n # Define the identity of the package.\n  PACKAGE='libffi'\n- VERSION='3.0.9'\n+ VERSION='3.0.11'\n \n \n cat >>confdefs.h <<_ACEOF\n@@ -10774,7 +10787,7 @@ else\n   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n   lt_status=$lt_dlunknown\n   cat > conftest.$ac_ext <<_LT_EOF\n-#line 10777 \"configure\"\n+#line 10790 \"configure\"\n #include \"confdefs.h\"\n \n #if HAVE_DLFCN_H\n@@ -10880,7 +10893,7 @@ else\n   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n   lt_status=$lt_dlunknown\n   cat > conftest.$ac_ext <<_LT_EOF\n-#line 10883 \"configure\"\n+#line 10896 \"configure\"\n #include \"confdefs.h\"\n \n #if HAVE_DLFCN_H\n@@ -11318,6 +11331,10 @@ fi\n \n TARGETDIR=\"unknown\"\n case \"$host\" in\n+  aarch64*-*-*)\n+\tTARGET=AARCH64; TARGETDIR=aarch64\n+\t;;\n+\n   alpha*-*-*)\n \tTARGET=ALPHA; TARGETDIR=alpha;\n \t# Support 128-bit long double, changeable via command-line switch.\n@@ -11329,13 +11346,21 @@ case \"$host\" in\n \t;;\n \n   amd64-*-freebsd* | amd64-*-openbsd*)\n+\tTARGET=X86_64; TARGETDIR=x86\n+  \t;;\n+\n+  amd64-*-freebsd*)\n \tTARGET=X86_64; TARGETDIR=x86\n \t;;\n \n   avr32*-*-*)\n \tTARGET=AVR32; TARGETDIR=avr32\n \t;;\n \n+  bfin*)\n+  \tTARGET=BFIN; TARGETDIR=bfin\n+  \t;;\n+\n   cris-*-*)\n \tTARGET=LIBFFI_CRIS; TARGETDIR=cris\n \t;;\n@@ -11344,7 +11369,7 @@ case \"$host\" in\n \tTARGET=FRV; TARGETDIR=frv\n \t;;\n \n-  hppa*-*-linux* | parisc*-*-linux*)\n+  hppa*-*-linux* | parisc*-*-linux* | hppa*-*-openbsd*)\n \tTARGET=PA_LINUX; TARGETDIR=pa\n \t;;\n   hppa*64-*-hpux*)\n@@ -11357,7 +11382,7 @@ case \"$host\" in\n   i?86-*-freebsd* | i?86-*-openbsd*)\n \tTARGET=X86_FREEBSD; TARGETDIR=x86\n \t;;\n-  i?86-win32* | i?86-*-cygwin* | i?86-*-mingw* | i?86-*-os2*)\n+  i?86-win32* | i?86-*-cygwin* | i?86-*-mingw* | i?86-*-os2* | i?86-*-interix*)\n \tTARGET=X86_WIN32; TARGETDIR=x86\n \t# All mingw/cygwin/win32 builds require -no-undefined for sharedlib.\n \t# We must also check with_cross_host to decide if this is a native\n@@ -11394,7 +11419,7 @@ case \"$host\" in\n   mips-sgi-irix5.* | mips-sgi-irix6.* | mips*-*-rtems*)\n \tTARGET=MIPS; TARGETDIR=mips\n \t;;\n-  mips*-*-linux*)\n+  mips*-*-linux* | mips*-*-openbsd*)\n \t# Support 128-bit long double for NewABI.\n \tHAVE_LONG_DOUBLE='defined(__mips64)'\n \tTARGET=MIPS; TARGETDIR=mips\n@@ -11403,19 +11428,22 @@ case \"$host\" in\n   powerpc*-*-linux* | powerpc-*-sysv*)\n \tTARGET=POWERPC; TARGETDIR=powerpc\n \t;;\n+  powerpc-*-amigaos*)\n+\tTARGET=POWERPC; TARGETDIR=powerpc\n+\t;;\n   powerpc-*-beos*)\n \tTARGET=POWERPC; TARGETDIR=powerpc\n \t;;\n-  powerpc-*-darwin*)\n+  powerpc-*-darwin* | powerpc64-*-darwin*)\n \tTARGET=POWERPC_DARWIN; TARGETDIR=powerpc\n \t;;\n   powerpc-*-aix* | rs6000-*-aix*)\n \tTARGET=POWERPC_AIX; TARGETDIR=powerpc\n \t;;\n-  powerpc-*-freebsd*)\n+  powerpc-*-freebsd* | powerpc-*-openbsd*)\n \tTARGET=POWERPC_FREEBSD; TARGETDIR=powerpc\n \t;;\n- powerpc64-*-freebsd*)\n+  powerpc64-*-freebsd*)\n \tTARGET=POWERPC; TARGETDIR=powerpc\n \t;;\n   powerpc*-*-rtems*)\n@@ -11437,6 +11465,10 @@ case \"$host\" in\n \tTARGET=SPARC; TARGETDIR=sparc\n \t;;\n \n+  tile*-*)\n+        TARGET=TILE; TARGETDIR=tile\n+        ;;\n+\n   x86_64-*-darwin*)\n \tTARGET=X86_DARWIN; TARGETDIR=x86\n \t;;\n@@ -11474,6 +11506,14 @@ else\n   MIPS_FALSE=\n fi\n \n+ if test x$TARGET = xBFIN; then\n+  BFIN_TRUE=\n+  BFIN_FALSE='#'\n+else\n+  BFIN_TRUE='#'\n+  BFIN_FALSE=\n+fi\n+\n  if test x$TARGET = xSPARC; then\n   SPARC_TRUE=\n   SPARC_FALSE='#'\n@@ -11586,6 +11626,14 @@ else\n   POWERPC_FREEBSD_FALSE=\n fi\n \n+ if test x$TARGET = xAARCH64; then\n+  AARCH64_TRUE=\n+  AARCH64_FALSE='#'\n+else\n+  AARCH64_TRUE='#'\n+  AARCH64_FALSE=\n+fi\n+\n  if test x$TARGET = xARM; then\n   ARM_TRUE=\n   ARM_FALSE='#'\n@@ -11674,6 +11722,14 @@ else\n   PA64_HPUX_FALSE=\n fi\n \n+ if test x$TARGET = xTILE; then\n+  TILE_TRUE=\n+  TILE_FALSE='#'\n+else\n+  TILE_TRUE='#'\n+  TILE_FALSE=\n+fi\n+\n \n { $as_echo \"$as_me:${as_lineno-$LINENO}: checking for ANSI C header files\" >&5\n $as_echo_n \"checking for ANSI C header files... \" >&6; }\n@@ -12501,13 +12557,40 @@ $as_echo \"#define HAVE_AS_STRING_PSEUDO_OP 1\" >>confdefs.h\n     fi\n fi\n \n+# On PaX enable kernels that have MPROTECT enable we can't use PROT_EXEC.\n+# Check whether --enable-pax_emutramp was given.\n+if test \"${enable_pax_emutramp+set}\" = set; then :\n+  enableval=$enable_pax_emutramp; if test \"$enable_pax_emutramp\" = \"yes\"; then\n+\n+$as_echo \"#define FFI_MMAP_EXEC_EMUTRAMP_PAX 1\" >>confdefs.h\n+\n+  fi\n+fi\n+\n+\n+FFI_EXEC_TRAMPOLINE_TABLE=0\n case \"$target\" in\n-     *-apple-darwin10* | *-*-freebsd* | *-*-openbsd* | *-pc-solaris*)\n+     *arm*-apple-darwin*)\n+       FFI_EXEC_TRAMPOLINE_TABLE=1\n+\n+$as_echo \"#define FFI_EXEC_TRAMPOLINE_TABLE 1\" >>confdefs.h\n+\n+     ;;\n+     *-apple-darwin1* | *-*-freebsd* | *-*-kfreebsd* | *-*-openbsd* | *-pc-solaris*)\n \n $as_echo \"#define FFI_MMAP_EXEC_WRIT 1\" >>confdefs.h\n \n      ;;\n esac\n+ if test x$FFI_EXEC_TRAMPOLINE_TABLE = x1; then\n+  FFI_EXEC_TRAMPOLINE_TABLE_TRUE=\n+  FFI_EXEC_TRAMPOLINE_TABLE_FALSE='#'\n+else\n+  FFI_EXEC_TRAMPOLINE_TABLE_TRUE='#'\n+  FFI_EXEC_TRAMPOLINE_TABLE_FALSE=\n+fi\n+\n+\n \n if test x$TARGET = xX86_64; then\n     { $as_echo \"$as_me:${as_lineno-$LINENO}: checking assembler supports unwind section type\" >&5\n@@ -12532,67 +12615,69 @@ $as_echo \"#define HAVE_AS_X86_64_UNWIND_SECTION_TYPE 1\" >>confdefs.h\n     fi\n fi\n \n-{ $as_echo \"$as_me:${as_lineno-$LINENO}: checking whether .eh_frame section should be read-only\" >&5\n+if test \"x$GCC\" = \"xyes\"; then\n+  { $as_echo \"$as_me:${as_lineno-$LINENO}: checking whether .eh_frame section should be read-only\" >&5\n $as_echo_n \"checking whether .eh_frame section should be read-only... \" >&6; }\n if test \"${libffi_cv_ro_eh_frame+set}\" = set; then :\n   $as_echo_n \"(cached) \" >&6\n else\n \n-\tlibffi_cv_ro_eh_frame=no\n-\techo 'extern void foo (void); void bar (void) { foo (); foo (); }' > conftest.c\n-\tif $CC $CFLAGS -S -fpic -fexceptions -o conftest.s conftest.c > /dev/null 2>&1; then\n-\t    if grep '.section.*eh_frame.*\"a\"' conftest.s > /dev/null; then\n-\t\tlibffi_cv_ro_eh_frame=yes\n-\t    elif grep '.section.*eh_frame.*#alloc' conftest.c \\\n-\t\t | grep -v '#write' > /dev/null; then\n-\t\tlibffi_cv_ro_eh_frame=yes\n-\t    fi\n-\tfi\n-\trm -f conftest.*\n+  \tlibffi_cv_ro_eh_frame=no\n+  \techo 'extern void foo (void); void bar (void) { foo (); foo (); }' > conftest.c\n+  \tif $CC $CFLAGS -S -fpic -fexceptions -o conftest.s conftest.c > /dev/null 2>&1; then\n+  \t    if grep '.section.*eh_frame.*\"a\"' conftest.s > /dev/null; then\n+  \t\tlibffi_cv_ro_eh_frame=yes\n+  \t    elif grep '.section.*eh_frame.*#alloc' conftest.c \\\n+  \t\t | grep -v '#write' > /dev/null; then\n+  \t\tlibffi_cv_ro_eh_frame=yes\n+  \t    fi\n+  \tfi\n+  \trm -f conftest.*\n \n fi\n { $as_echo \"$as_me:${as_lineno-$LINENO}: result: $libffi_cv_ro_eh_frame\" >&5\n $as_echo \"$libffi_cv_ro_eh_frame\" >&6; }\n-if test \"x$libffi_cv_ro_eh_frame\" = xyes; then\n+  if test \"x$libffi_cv_ro_eh_frame\" = xyes; then\n \n $as_echo \"#define HAVE_RO_EH_FRAME 1\" >>confdefs.h\n \n \n $as_echo \"#define EH_FRAME_FLAGS \\\"a\\\"\" >>confdefs.h\n \n-else\n+  else\n \n $as_echo \"#define EH_FRAME_FLAGS \\\"aw\\\"\" >>confdefs.h\n \n-fi\n+  fi\n \n-{ $as_echo \"$as_me:${as_lineno-$LINENO}: checking for __attribute__((visibility(\\\"hidden\\\")))\" >&5\n+  { $as_echo \"$as_me:${as_lineno-$LINENO}: checking for __attribute__((visibility(\\\"hidden\\\")))\" >&5\n $as_echo_n \"checking for __attribute__((visibility(\\\"hidden\\\")))... \" >&6; }\n if test \"${libffi_cv_hidden_visibility_attribute+set}\" = set; then :\n   $as_echo_n \"(cached) \" >&6\n else\n \n-\techo 'int __attribute__ ((visibility (\"hidden\"))) foo (void) { return 1; }' > conftest.c\n-\tlibffi_cv_hidden_visibility_attribute=no\n-\tif { ac_try='${CC-cc} -Werror -S conftest.c -o conftest.s 1>&5'\n+  \techo 'int __attribute__ ((visibility (\"hidden\"))) foo (void) { return 1  ; }' > conftest.c\n+  \tlibffi_cv_hidden_visibility_attribute=no\n+  \tif { ac_try='${CC-cc} -Werror -S conftest.c -o conftest.s 1>&5'\n   { { eval echo \"\\\"\\$as_me\\\":${as_lineno-$LINENO}: \\\"$ac_try\\\"\"; } >&5\n   (eval $ac_try) 2>&5\n   ac_status=$?\n   $as_echo \"$as_me:${as_lineno-$LINENO}: \\$? = $ac_status\" >&5\n   test $ac_status = 0; }; }; then\n-\t    if grep '\\.hidden.*foo' conftest.s >/dev/null; then\n-\t\tlibffi_cv_hidden_visibility_attribute=yes\n-\t    fi\n-\tfi\n-\trm -f conftest.*\n+  \t    if grep '\\.hidden.*foo' conftest.s >/dev/null; then\n+  \t\tlibffi_cv_hidden_visibility_attribute=yes\n+  \t    fi\n+  \tfi\n+  \trm -f conftest.*\n \n fi\n { $as_echo \"$as_me:${as_lineno-$LINENO}: result: $libffi_cv_hidden_visibility_attribute\" >&5\n $as_echo \"$libffi_cv_hidden_visibility_attribute\" >&6; }\n-if test $libffi_cv_hidden_visibility_attribute = yes; then\n+  if test $libffi_cv_hidden_visibility_attribute = yes; then\n \n $as_echo \"#define HAVE_HIDDEN_VISIBILITY_ATTRIBUTE 1\" >>confdefs.h\n \n+  fi\n fi\n \n \n@@ -12611,6 +12696,14 @@ $as_echo \"#define FFI_DEBUG 1\" >>confdefs.h\n   fi\n fi\n \n+ if test \"$enable_debug\" = \"yes\"; then\n+  FFI_DEBUG_TRUE=\n+  FFI_DEBUG_FALSE='#'\n+else\n+  FFI_DEBUG_TRUE='#'\n+  FFI_DEBUG_FALSE=\n+fi\n+\n \n # Check whether --enable-structs was given.\n if test \"${enable_structs+set}\" = set; then :\n@@ -12804,6 +12897,10 @@ if test -z \"${MIPS_TRUE}\" && test -z \"${MIPS_FALSE}\"; then\n   as_fn_error \"conditional \\\"MIPS\\\" was never defined.\n Usually this means the macro was only invoked conditionally.\" \"$LINENO\" 5\n fi\n+if test -z \"${BFIN_TRUE}\" && test -z \"${BFIN_FALSE}\"; then\n+  as_fn_error \"conditional \\\"BFIN\\\" was never defined.\n+Usually this means the macro was only invoked conditionally.\" \"$LINENO\" 5\n+fi\n if test -z \"${SPARC_TRUE}\" && test -z \"${SPARC_FALSE}\"; then\n   as_fn_error \"conditional \\\"SPARC\\\" was never defined.\n Usually this means the macro was only invoked conditionally.\" \"$LINENO\" 5\n@@ -12860,6 +12957,10 @@ if test -z \"${POWERPC_FREEBSD_TRUE}\" && test -z \"${POWERPC_FREEBSD_FALSE}\"; then\n   as_fn_error \"conditional \\\"POWERPC_FREEBSD\\\" was never defined.\n Usually this means the macro was only invoked conditionally.\" \"$LINENO\" 5\n fi\n+if test -z \"${AARCH64_TRUE}\" && test -z \"${AARCH64_FALSE}\"; then\n+  as_fn_error \"conditional \\\"AARCH64\\\" was never defined.\n+Usually this means the macro was only invoked conditionally.\" \"$LINENO\" 5\n+fi\n if test -z \"${ARM_TRUE}\" && test -z \"${ARM_FALSE}\"; then\n   as_fn_error \"conditional \\\"ARM\\\" was never defined.\n Usually this means the macro was only invoked conditionally.\" \"$LINENO\" 5\n@@ -12904,7 +13005,19 @@ if test -z \"${PA64_HPUX_TRUE}\" && test -z \"${PA64_HPUX_FALSE}\"; then\n   as_fn_error \"conditional \\\"PA64_HPUX\\\" was never defined.\n Usually this means the macro was only invoked conditionally.\" \"$LINENO\" 5\n fi\n+if test -z \"${TILE_TRUE}\" && test -z \"${TILE_FALSE}\"; then\n+  as_fn_error \"conditional \\\"TILE\\\" was never defined.\n+Usually this means the macro was only invoked conditionally.\" \"$LINENO\" 5\n+fi\n \n+if test -z \"${FFI_EXEC_TRAMPOLINE_TABLE_TRUE}\" && test -z \"${FFI_EXEC_TRAMPOLINE_TABLE_FALSE}\"; then\n+  as_fn_error \"conditional \\\"FFI_EXEC_TRAMPOLINE_TABLE\\\" was never defined.\n+Usually this means the macro was only invoked conditionally.\" \"$LINENO\" 5\n+fi\n+if test -z \"${FFI_DEBUG_TRUE}\" && test -z \"${FFI_DEBUG_FALSE}\"; then\n+  as_fn_error \"conditional \\\"FFI_DEBUG\\\" was never defined.\n+Usually this means the macro was only invoked conditionally.\" \"$LINENO\" 5\n+fi\n \n : ${CONFIG_STATUS=./config.status}\n ac_write_fail=0\n@@ -13313,7 +13426,7 @@ cat >>$CONFIG_STATUS <<\\_ACEOF || ac_write_fail=1\n # report actual input values of CONFIG_FILES etc. instead of their\n # values after options handling.\n ac_log=\"\n-This file was extended by libffi $as_me 3.0.9, which was\n+This file was extended by libffi $as_me 3.0.11, which was\n generated by GNU Autoconf 2.64.  Invocation command line was\n \n   CONFIG_FILES    = $CONFIG_FILES\n@@ -13381,7 +13494,7 @@ Report bugs to <http://gcc.gnu.org/bugs.html>.\"\n _ACEOF\n cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1\n ac_cs_version=\"\\\\\n-libffi config.status 3.0.9\n+libffi config.status 3.0.11\n configured by $0, generated by GNU Autoconf 2.64,\n   with options \\\\\"`$as_echo \"$ac_configure_args\" | sed 's/^ //; s/[\\\\\"\"\\`\\$]/\\\\\\\\&/g'`\\\\\"\n "}, {"sha": "d7ab0666484ad75b9cffe3acfd72ff66ed215f14", "filename": "libffi/configure.ac", "status": "modified", "additions": 87, "deletions": 45, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fconfigure.ac?ref=b4b575ce7854f4a49de8de93f38b7639e01b040b", "patch": "@@ -2,7 +2,7 @@ dnl Process this with autoconf to create configure\n \n AC_PREREQ(2.64)\n \n-AC_INIT([libffi], [3.0.9], [http://gcc.gnu.org/bugs.html])\n+AC_INIT([libffi], [3.0.11], [http://gcc.gnu.org/bugs.html])\n AC_CONFIG_HEADERS([fficonfig.h])\n \n AM_ENABLE_MULTILIB(, ..)\n@@ -41,6 +41,10 @@ AM_CONDITIONAL(TESTSUBDIR, test -d $srcdir/testsuite)\n \n TARGETDIR=\"unknown\"\n case \"$host\" in\n+  aarch64*-*-*)\n+\tTARGET=AARCH64; TARGETDIR=aarch64\n+\t;;\n+\n   alpha*-*-*)\n \tTARGET=ALPHA; TARGETDIR=alpha;\n \t# Support 128-bit long double, changeable via command-line switch.\n@@ -52,13 +56,21 @@ case \"$host\" in\n \t;;\n \n   amd64-*-freebsd* | amd64-*-openbsd*)\n+\tTARGET=X86_64; TARGETDIR=x86\n+  \t;;\n+\n+  amd64-*-freebsd*)\n \tTARGET=X86_64; TARGETDIR=x86\n \t;;\n \n   avr32*-*-*)\n \tTARGET=AVR32; TARGETDIR=avr32\n \t;;\n \n+  bfin*)\n+  \tTARGET=BFIN; TARGETDIR=bfin\n+  \t;;\n+\n   cris-*-*)\n \tTARGET=LIBFFI_CRIS; TARGETDIR=cris\n \t;;\n@@ -67,7 +79,7 @@ case \"$host\" in\n \tTARGET=FRV; TARGETDIR=frv\n \t;;\n \n-  hppa*-*-linux* | parisc*-*-linux*)\n+  hppa*-*-linux* | parisc*-*-linux* | hppa*-*-openbsd*)\n \tTARGET=PA_LINUX; TARGETDIR=pa\n \t;;\n   hppa*64-*-hpux*)\n@@ -80,7 +92,7 @@ case \"$host\" in\n   i?86-*-freebsd* | i?86-*-openbsd*)\n \tTARGET=X86_FREEBSD; TARGETDIR=x86\n \t;;\n-  i?86-win32* | i?86-*-cygwin* | i?86-*-mingw* | i?86-*-os2*)\n+  i?86-win32* | i?86-*-cygwin* | i?86-*-mingw* | i?86-*-os2* | i?86-*-interix*)\n \tTARGET=X86_WIN32; TARGETDIR=x86\n \t# All mingw/cygwin/win32 builds require -no-undefined for sharedlib.\n \t# We must also check with_cross_host to decide if this is a native\n@@ -117,7 +129,7 @@ case \"$host\" in\n   mips-sgi-irix5.* | mips-sgi-irix6.* | mips*-*-rtems*)\n \tTARGET=MIPS; TARGETDIR=mips\n \t;;\n-  mips*-*-linux*)\n+  mips*-*-linux* | mips*-*-openbsd*)\n \t# Support 128-bit long double for NewABI.\n \tHAVE_LONG_DOUBLE='defined(__mips64)'\n \tTARGET=MIPS; TARGETDIR=mips\n@@ -126,19 +138,22 @@ case \"$host\" in\n   powerpc*-*-linux* | powerpc-*-sysv*)\n \tTARGET=POWERPC; TARGETDIR=powerpc\n \t;;\n+  powerpc-*-amigaos*)\n+\tTARGET=POWERPC; TARGETDIR=powerpc\n+\t;;\n   powerpc-*-beos*)\n \tTARGET=POWERPC; TARGETDIR=powerpc\n \t;;\n-  powerpc-*-darwin*)\n+  powerpc-*-darwin* | powerpc64-*-darwin*)\n \tTARGET=POWERPC_DARWIN; TARGETDIR=powerpc\n \t;;\n   powerpc-*-aix* | rs6000-*-aix*)\n \tTARGET=POWERPC_AIX; TARGETDIR=powerpc\n \t;;\n-  powerpc-*-freebsd*)\n+  powerpc-*-freebsd* | powerpc-*-openbsd*)\n \tTARGET=POWERPC_FREEBSD; TARGETDIR=powerpc\n \t;;\n- powerpc64-*-freebsd*)\n+  powerpc64-*-freebsd*)\n \tTARGET=POWERPC; TARGETDIR=powerpc\n \t;;\n   powerpc*-*-rtems*)\n@@ -160,6 +175,10 @@ case \"$host\" in\n \tTARGET=SPARC; TARGETDIR=sparc\n \t;;\n \n+  tile*-*)\n+        TARGET=TILE; TARGETDIR=tile\n+        ;;\n+\n   x86_64-*-darwin*)\n \tTARGET=X86_DARWIN; TARGETDIR=x86\n \t;;\n@@ -190,6 +209,7 @@ if test $TARGETDIR = unknown; then\n fi\n \n AM_CONDITIONAL(MIPS, test x$TARGET = xMIPS)\n+AM_CONDITIONAL(BFIN, test x$TARGET = xBFIN)\n AM_CONDITIONAL(SPARC, test x$TARGET = xSPARC)\n AM_CONDITIONAL(X86, test x$TARGET = xX86)\n AM_CONDITIONAL(X86_FREEBSD, test x$TARGET = xX86_FREEBSD)\n@@ -204,6 +224,7 @@ AM_CONDITIONAL(POWERPC, test x$TARGET = xPOWERPC)\n AM_CONDITIONAL(POWERPC_AIX, test x$TARGET = xPOWERPC_AIX)\n AM_CONDITIONAL(POWERPC_DARWIN, test x$TARGET = xPOWERPC_DARWIN)\n AM_CONDITIONAL(POWERPC_FREEBSD, test x$TARGET = xPOWERPC_FREEBSD)\n+AM_CONDITIONAL(AARCH64, test x$TARGET = xAARCH64)\n AM_CONDITIONAL(ARM, test x$TARGET = xARM)\n AM_CONDITIONAL(AVR32, test x$TARGET = xAVR32)\n AM_CONDITIONAL(LIBFFI_CRIS, test x$TARGET = xLIBFFI_CRIS)\n@@ -215,6 +236,7 @@ AM_CONDITIONAL(SH64, test x$TARGET = xSH64)\n AM_CONDITIONAL(PA_LINUX, test x$TARGET = xPA_LINUX)\n AM_CONDITIONAL(PA_HPUX, test x$TARGET = xPA_HPUX)\n AM_CONDITIONAL(PA64_HPUX, test x$TARGET = xPA64_HPUX)\n+AM_CONDITIONAL(TILE, test x$TARGET = xTILE)\n \n AC_HEADER_STDC\n AC_CHECK_FUNCS(memcpy)\n@@ -311,13 +333,30 @@ if test x$TARGET = xX86 || test x$TARGET = xX86_WIN32 || test x$TARGET = xX86_64\n     fi\n fi\n \n+# On PaX enable kernels that have MPROTECT enable we can't use PROT_EXEC.\n+AC_ARG_ENABLE(pax_emutramp,\n+  [  --enable-pax_emutramp       enable pax emulated trampolines, for we can't use PROT_EXEC],\n+  if test \"$enable_pax_emutramp\" = \"yes\"; then\n+    AC_DEFINE(FFI_MMAP_EXEC_EMUTRAMP_PAX, 1,\n+      [Define this if you want to enable pax emulated trampolines])\n+  fi)\n+\n+FFI_EXEC_TRAMPOLINE_TABLE=0\n case \"$target\" in\n-     *-apple-darwin10* | *-*-freebsd* | *-*-openbsd* | *-pc-solaris*)\n+     *arm*-apple-darwin*)\n+       FFI_EXEC_TRAMPOLINE_TABLE=1\n+       AC_DEFINE(FFI_EXEC_TRAMPOLINE_TABLE, 1,\n+                 [Cannot use PROT_EXEC on this target, so, we revert to\n+                   alternative means])\n+     ;;\n+     *-apple-darwin1* | *-*-freebsd* | *-*-kfreebsd* | *-*-openbsd* | *-pc-solaris*)\n        AC_DEFINE(FFI_MMAP_EXEC_WRIT, 1,\n                  [Cannot use malloc on this target, so, we revert to\n                    alternative means])\n      ;;\n esac\n+AM_CONDITIONAL(FFI_EXEC_TRAMPOLINE_TABLE, test x$FFI_EXEC_TRAMPOLINE_TABLE = x1)\n+AC_SUBST(FFI_EXEC_TRAMPOLINE_TABLE)\n \n if test x$TARGET = xX86_64; then\n     AC_CACHE_CHECK([assembler supports unwind section type],\n@@ -334,44 +373,46 @@ if test x$TARGET = xX86_64; then\n     fi\n fi\n \n-AC_CACHE_CHECK([whether .eh_frame section should be read-only],\n-    libffi_cv_ro_eh_frame, [\n-\tlibffi_cv_ro_eh_frame=no\n-\techo 'extern void foo (void); void bar (void) { foo (); foo (); }' > conftest.c\n-\tif $CC $CFLAGS -S -fpic -fexceptions -o conftest.s conftest.c > /dev/null 2>&1; then\n-\t    if grep '.section.*eh_frame.*\"a\"' conftest.s > /dev/null; then\n-\t\tlibffi_cv_ro_eh_frame=yes\n-\t    elif grep '.section.*eh_frame.*#alloc' conftest.c \\\n-\t\t | grep -v '#write' > /dev/null; then\n-\t\tlibffi_cv_ro_eh_frame=yes\n-\t    fi\n-\tfi\n-\trm -f conftest.*\n-    ])\n-if test \"x$libffi_cv_ro_eh_frame\" = xyes; then\n-    AC_DEFINE(HAVE_RO_EH_FRAME, 1,\n-\t      [Define if .eh_frame sections should be read-only.])\n-    AC_DEFINE(EH_FRAME_FLAGS, \"a\",\n-\t      [Define to the flags needed for the .section .eh_frame directive.])\n-else\n-    AC_DEFINE(EH_FRAME_FLAGS, \"aw\",\n-\t      [Define to the flags needed for the .section .eh_frame directive.])\n-fi\n+if test \"x$GCC\" = \"xyes\"; then\n+  AC_CACHE_CHECK([whether .eh_frame section should be read-only],\n+      libffi_cv_ro_eh_frame, [\n+  \tlibffi_cv_ro_eh_frame=no\n+  \techo 'extern void foo (void); void bar (void) { foo (); foo (); }' > conftest.c\n+  \tif $CC $CFLAGS -S -fpic -fexceptions -o conftest.s conftest.c > /dev/null 2>&1; then\n+  \t    if grep '.section.*eh_frame.*\"a\"' conftest.s > /dev/null; then\n+  \t\tlibffi_cv_ro_eh_frame=yes\n+  \t    elif grep '.section.*eh_frame.*#alloc' conftest.c \\\n+  \t\t | grep -v '#write' > /dev/null; then\n+  \t\tlibffi_cv_ro_eh_frame=yes\n+  \t    fi\n+  \tfi\n+  \trm -f conftest.*\n+      ])\n+  if test \"x$libffi_cv_ro_eh_frame\" = xyes; then\n+      AC_DEFINE(HAVE_RO_EH_FRAME, 1,\n+  \t      [Define if .eh_frame sections should be read-only.])\n+      AC_DEFINE(EH_FRAME_FLAGS, \"a\",\n+  \t      [Define to the flags needed for the .section .eh_frame directive.  ])\n+  else\n+      AC_DEFINE(EH_FRAME_FLAGS, \"aw\",\n+  \t      [Define to the flags needed for the .section .eh_frame directive.  ])\n+  fi\n \n-AC_CACHE_CHECK([for __attribute__((visibility(\"hidden\")))],\n-    libffi_cv_hidden_visibility_attribute, [\n-\techo 'int __attribute__ ((visibility (\"hidden\"))) foo (void) { return 1; }' > conftest.c\n-\tlibffi_cv_hidden_visibility_attribute=no\n-\tif AC_TRY_COMMAND(${CC-cc} -Werror -S conftest.c -o conftest.s 1>&AS_MESSAGE_LOG_FD); then\n-\t    if grep '\\.hidden.*foo' conftest.s >/dev/null; then\n-\t\tlibffi_cv_hidden_visibility_attribute=yes\n-\t    fi\n-\tfi\n-\trm -f conftest.*\n-    ])\n-if test $libffi_cv_hidden_visibility_attribute = yes; then\n-    AC_DEFINE(HAVE_HIDDEN_VISIBILITY_ATTRIBUTE, 1,\n-\t      [Define if __attribute__((visibility(\"hidden\"))) is supported.])\n+  AC_CACHE_CHECK([for __attribute__((visibility(\"hidden\")))],\n+      libffi_cv_hidden_visibility_attribute, [\n+  \techo 'int __attribute__ ((visibility (\"hidden\"))) foo (void) { return 1  ; }' > conftest.c\n+  \tlibffi_cv_hidden_visibility_attribute=no\n+  \tif AC_TRY_COMMAND(${CC-cc} -Werror -S conftest.c -o conftest.s 1>&AS_MESSAGE_LOG_FD); then\n+  \t    if grep '\\.hidden.*foo' conftest.s >/dev/null; then\n+  \t\tlibffi_cv_hidden_visibility_attribute=yes\n+  \t    fi\n+  \tfi\n+  \trm -f conftest.*\n+      ])\n+  if test $libffi_cv_hidden_visibility_attribute = yes; then\n+      AC_DEFINE(HAVE_HIDDEN_VISIBILITY_ATTRIBUTE, 1,\n+  \t      [Define if __attribute__((visibility(\"hidden\"))) is supported.])\n+  fi\n fi\n \n AH_BOTTOM([\n@@ -400,6 +441,7 @@ AC_ARG_ENABLE(debug,\n   if test \"$enable_debug\" = \"yes\"; then\n     AC_DEFINE(FFI_DEBUG, 1, [Define this if you want extra debugging.])\n   fi)\n+AM_CONDITIONAL(FFI_DEBUG, test \"$enable_debug\" = \"yes\")\n \n AC_ARG_ENABLE(structs,\n [  --disable-structs       omit code for struct support],"}, {"sha": "c2bca734ef17e111b963e7f59a745f98d124cc22", "filename": "libffi/generate-ios-source-and-headers.py", "status": "added", "additions": 160, "deletions": 0, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Fgenerate-ios-source-and-headers.py", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Fgenerate-ios-source-and-headers.py", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fgenerate-ios-source-and-headers.py?ref=b4b575ce7854f4a49de8de93f38b7639e01b040b", "patch": "@@ -0,0 +1,160 @@\n+#!/usr/bin/env python\n+\n+import subprocess\n+import re\n+import os\n+import errno\n+import collections\n+import sys\n+\n+class Platform(object):\n+    pass\n+\n+sdk_re = re.compile(r'.*-sdk ([a-zA-Z0-9.]*)')\n+\n+def sdkinfo(sdkname):\n+    ret = {}\n+    for line in subprocess.Popen(['xcodebuild', '-sdk', sdkname, '-version'], stdout=subprocess.PIPE).stdout:\n+        kv = line.strip().split(': ', 1)\n+        if len(kv) == 2:\n+            k,v = kv\n+            ret[k] = v\n+    return ret\n+\n+sim_sdk_info = sdkinfo('iphonesimulator')\n+device_sdk_info = sdkinfo('iphoneos')\n+\n+def latest_sdks():\n+    latest_sim = None\n+    latest_device = None\n+    for line in subprocess.Popen(['xcodebuild', '-showsdks'], stdout=subprocess.PIPE).stdout:\n+        match = sdk_re.match(line)\n+        if match:\n+            if 'Simulator' in line:\n+                latest_sim = match.group(1)\n+            elif 'iOS' in line:\n+                latest_device = match.group(1)\n+\n+    return latest_sim, latest_device\n+\n+sim_sdk, device_sdk = latest_sdks()\n+\n+class simulator_platform(Platform):\n+    sdk='iphonesimulator'\n+    arch = 'i386'\n+    name = 'simulator'\n+    triple = 'i386-apple-darwin10'\n+    sdkroot = sim_sdk_info['Path']\n+\n+    prefix = \"#if !defined(__arm__) && defined(__i386__)\\n\\n\"\n+    suffix = \"\\n\\n#endif\"\n+\n+class device_platform(Platform):\n+    sdk='iphoneos'\n+    name = 'ios'\n+    arch = 'armv7'\n+    triple = 'arm-apple-darwin10'\n+    sdkroot = device_sdk_info['Path']\n+\n+    prefix = \"#ifdef __arm__\\n\\n\"\n+    suffix = \"\\n\\n#endif\"\n+\n+\n+def move_file(src_dir, dst_dir, filename, file_suffix=None, prefix='', suffix=''):\n+    if not os.path.exists(dst_dir):\n+        os.makedirs(dst_dir)\n+\n+    out_filename = filename\n+\n+    if file_suffix:\n+        split_name = os.path.splitext(filename)\n+        out_filename =  \"%s_%s%s\" % (split_name[0], file_suffix, split_name[1])\n+\n+    with open(os.path.join(src_dir, filename)) as in_file:\n+        with open(os.path.join(dst_dir, out_filename), 'w') as out_file:\n+            if prefix:\n+                out_file.write(prefix)\n+\n+            out_file.write(in_file.read())\n+\n+            if suffix:\n+                out_file.write(suffix)\n+\n+headers_seen = collections.defaultdict(set)\n+\n+def move_source_tree(src_dir, dest_dir, dest_include_dir, arch=None, prefix=None, suffix=None):\n+    for root, dirs, files in os.walk(src_dir, followlinks=True):\n+        relroot = os.path.relpath(root,src_dir)\n+\n+        def move_dir(arch, prefix='', suffix='', files=[]):\n+            for file in files:\n+                file_suffix = None\n+                if file.endswith('.h'):\n+                    if dest_include_dir:\n+                        file_suffix = arch\n+                        if arch:\n+                            headers_seen[file].add(arch)\n+                        move_file(root, dest_include_dir, file, arch, prefix=prefix, suffix=suffix)\n+\n+                elif dest_dir:\n+                    outroot = os.path.join(dest_dir, relroot)\n+                    move_file(root, outroot, file, prefix=prefix, suffix=suffix)\n+\n+        if relroot == '.':\n+            move_dir(arch=arch,\n+                     files=files,\n+                     prefix=prefix,\n+                     suffix=suffix)\n+        elif relroot == 'arm':\n+            move_dir(arch='arm',\n+                     prefix=\"#ifdef __arm__\\n\\n\",\n+                     suffix=\"\\n\\n#endif\",\n+                     files=files)\n+        elif relroot == 'x86':\n+            move_dir(arch='i386',\n+                     prefix=\"#if !defined(__arm__) && defined(__i386__)\\n\\n\",\n+                     suffix=\"\\n\\n#endif\",\n+                     files=files)\n+\n+def build_target(platform):\n+    def xcrun_cmd(cmd):\n+        return subprocess.check_output(['xcrun', '-sdk', platform.sdkroot, '-find', cmd]).strip()\n+\n+    build_dir = 'build_' + platform.name\n+    if not os.path.exists(build_dir):\n+        os.makedirs(build_dir)\n+        env = dict(CC=xcrun_cmd('clang'),\n+                   LD=xcrun_cmd('ld'),\n+                   CFLAGS='-arch %s -isysroot %s -miphoneos-version-min=4.0' % (platform.arch, platform.sdkroot))\n+        working_dir=os.getcwd()\n+        try:\n+            os.chdir(build_dir)\n+            subprocess.check_call(['../configure', '-host', platform.triple], env=env)\n+            move_source_tree('.', None, '../ios/include',\n+                             arch=platform.arch,\n+                             prefix=platform.prefix,\n+                             suffix=platform.suffix)\n+            move_source_tree('./include', None, '../ios/include',\n+                            arch=platform.arch,\n+                            prefix=platform.prefix,\n+                            suffix=platform.suffix)\n+        finally:\n+            os.chdir(working_dir)\n+\n+        for header_name, archs in headers_seen.iteritems():\n+            basename, suffix = os.path.splitext(header_name)\n+\n+def main():\n+    move_source_tree('src', 'ios/src', 'ios/include')\n+    move_source_tree('include', None, 'ios/include')\n+    build_target(simulator_platform)\n+    build_target(device_platform)\n+\n+    for header_name, archs in headers_seen.iteritems():\n+        basename, suffix = os.path.splitext(header_name)\n+        with open(os.path.join('ios/include', header_name), 'w') as header:\n+            for arch in archs:\n+                header.write('#include <%s_%s%s>\\n' % (basename, arch, suffix))\n+\n+if __name__ == '__main__':\n+    main()"}, {"sha": "64313c1a3640db66e0718f4cf0b917eb09ecd613", "filename": "libffi/generate-osx-source-and-headers.py", "status": "added", "additions": 153, "deletions": 0, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Fgenerate-osx-source-and-headers.py", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Fgenerate-osx-source-and-headers.py", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fgenerate-osx-source-and-headers.py?ref=b4b575ce7854f4a49de8de93f38b7639e01b040b", "patch": "@@ -0,0 +1,153 @@\n+#!/usr/bin/env python\n+import subprocess\n+import re\n+import os\n+import errno\n+import collections\n+import sys\n+\n+class Platform(object):\n+    pass\n+\n+sdk_re = re.compile(r'.*-sdk ([a-zA-Z0-9.]*)')\n+\n+def sdkinfo(sdkname):\n+    ret = {}\n+    for line in subprocess.Popen(['xcodebuild', '-sdk', sdkname, '-version'], stdout=subprocess.PIPE).stdout:\n+        kv = line.strip().split(': ', 1)\n+        if len(kv) == 2:\n+            k,v = kv\n+            ret[k] = v\n+    return ret\n+\n+desktop_sdk_info = sdkinfo('macosx')\n+\n+def latest_sdks():\n+    latest_desktop = None\n+    for line in subprocess.Popen(['xcodebuild', '-showsdks'], stdout=subprocess.PIPE).stdout:\n+        match = sdk_re.match(line)\n+        if match:\n+            if 'OS X' in line:\n+                latest_desktop = match.group(1)\n+\n+    return latest_desktop\n+\n+desktop_sdk = latest_sdks()\n+\n+class desktop_platform_32(Platform):\n+    sdk='macosx'\n+    arch = 'i386'\n+    name = 'mac32'\n+    triple = 'i386-apple-darwin10'\n+    sdkroot = desktop_sdk_info['Path']\n+\n+    prefix = \"#if defined(__i386__) && !defined(__x86_64__)\\n\\n\"\n+    suffix = \"\\n\\n#endif\"\n+\n+class desktop_platform_64(Platform):\n+    sdk='macosx'\n+    arch = 'x86_64'\n+    name = 'mac'\n+    triple = 'x86_64-apple-darwin10'\n+    sdkroot = desktop_sdk_info['Path']\n+\n+    prefix = \"#if !defined(__i386__) && defined(__x86_64__)\\n\\n\"\n+    suffix = \"\\n\\n#endif\"\n+\n+def move_file(src_dir, dst_dir, filename, file_suffix=None, prefix='', suffix=''):\n+    if not os.path.exists(dst_dir):\n+        os.makedirs(dst_dir)\n+\n+    out_filename = filename\n+\n+    if file_suffix:\n+        split_name = os.path.splitext(filename)\n+        out_filename =  \"%s_%s%s\" % (split_name[0], file_suffix, split_name[1])\n+\n+    with open(os.path.join(src_dir, filename)) as in_file:\n+        with open(os.path.join(dst_dir, out_filename), 'w') as out_file:\n+            if prefix:\n+                out_file.write(prefix)\n+\n+            out_file.write(in_file.read())\n+\n+            if suffix:\n+                out_file.write(suffix)\n+\n+headers_seen = collections.defaultdict(set)\n+\n+def move_source_tree(src_dir, dest_dir, dest_include_dir, arch=None, prefix=None, suffix=None):\n+    for root, dirs, files in os.walk(src_dir, followlinks=True):\n+        relroot = os.path.relpath(root,src_dir)\n+\n+        def move_dir(arch, prefix='', suffix='', files=[]):\n+            for file in files:\n+                file_suffix = None\n+                if file.endswith('.h'):\n+                    if dest_include_dir:\n+                        file_suffix = arch\n+                        if arch:\n+                            headers_seen[file].add(arch)\n+                        move_file(root, dest_include_dir, file, arch, prefix=prefix, suffix=suffix)\n+\n+                elif dest_dir:\n+                    outroot = os.path.join(dest_dir, relroot)\n+                    move_file(root, outroot, file, prefix=prefix, suffix=suffix)\n+\n+        if relroot == '.':\n+            move_dir(arch=arch,\n+                     files=files,\n+                     prefix=prefix,\n+                     suffix=suffix)\n+        elif relroot == 'x86':\n+            move_dir(arch='i386',\n+                     prefix=\"#if defined(__i386__) && !defined(__x86_64__)\\n\\n\",\n+                     suffix=\"\\n\\n#endif\",\n+                     files=files)\n+            move_dir(arch='x86_64',\n+                     prefix=\"#if !defined(__i386__) && defined(__x86_64__)\\n\\n\",\n+                     suffix=\"\\n\\n#endif\",\n+                     files=files)\n+\n+def build_target(platform):\n+    def xcrun_cmd(cmd):\n+        return subprocess.check_output(['xcrun', '-sdk', platform.sdkroot, '-find', cmd]).strip()\n+\n+    build_dir = 'build_' + platform.name\n+    if not os.path.exists(build_dir):\n+        os.makedirs(build_dir)\n+        env = dict(CC=xcrun_cmd('clang'),\n+                   LD=xcrun_cmd('ld'),\n+                   CFLAGS='-arch %s -isysroot %s -mmacosx-version-min=10.6' % (platform.arch, platform.sdkroot))\n+        working_dir=os.getcwd()\n+        try:\n+            os.chdir(build_dir)\n+            subprocess.check_call(['../configure', '-host', platform.triple], env=env)\n+            move_source_tree('.', None, '../osx/include',\n+                             arch=platform.arch,\n+                             prefix=platform.prefix,\n+                             suffix=platform.suffix)\n+            move_source_tree('./include', None, '../osx/include',\n+                             arch=platform.arch,\n+                             prefix=platform.prefix,\n+                             suffix=platform.suffix)\n+        finally:\n+            os.chdir(working_dir)\n+\n+        for header_name, archs in headers_seen.iteritems():\n+            basename, suffix = os.path.splitext(header_name)\n+\n+def main():\n+    move_source_tree('src', 'osx/src', 'osx/include')\n+    move_source_tree('include', None, 'osx/include')\n+    build_target(desktop_platform_32)\n+    build_target(desktop_platform_64)\n+\n+    for header_name, archs in headers_seen.iteritems():\n+        basename, suffix = os.path.splitext(header_name)\n+        with open(os.path.join('osx/include', header_name), 'w') as header:\n+            for arch in archs:\n+                header.write('#include <%s_%s%s>\\n' % (basename, arch, suffix))\n+\n+if __name__ == '__main__':\n+    main()"}, {"sha": "14c39a2a4e139360ea136476598ec79407cbc0c9", "filename": "libffi/libffi.xcodeproj/project.pbxproj", "status": "added", "additions": 579, "deletions": 0, "changes": 579, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Flibffi.xcodeproj%2Fproject.pbxproj", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Flibffi.xcodeproj%2Fproject.pbxproj", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Flibffi.xcodeproj%2Fproject.pbxproj?ref=b4b575ce7854f4a49de8de93f38b7639e01b040b", "patch": "@@ -0,0 +1,579 @@\n+// !$*UTF8*$!\n+{\n+\tarchiveVersion = 1;\n+\tclasses = {\n+\t};\n+\tobjectVersion = 46;\n+\tobjects = {\n+\n+/* Begin PBXBuildFile section */\n+\t\t6C43CBDC1534F76F00162364 /* ffi.c in Sources */ = {isa = PBXBuildFile; fileRef = 6C43CBBD1534F76F00162364 /* ffi.c */; };\n+\t\t6C43CBDD1534F76F00162364 /* sysv.S in Sources */ = {isa = PBXBuildFile; fileRef = 6C43CBBF1534F76F00162364 /* sysv.S */; };\n+\t\t6C43CBDE1534F76F00162364 /* trampoline.S in Sources */ = {isa = PBXBuildFile; fileRef = 6C43CBC01534F76F00162364 /* trampoline.S */; };\n+\t\t6C43CBE61534F76F00162364 /* darwin.S in Sources */ = {isa = PBXBuildFile; fileRef = 6C43CBC91534F76F00162364 /* darwin.S */; };\n+\t\t6C43CBE81534F76F00162364 /* ffi.c in Sources */ = {isa = PBXBuildFile; fileRef = 6C43CBCB1534F76F00162364 /* ffi.c */; };\n+\t\t6C43CC1F1534F77800162364 /* darwin.S in Sources */ = {isa = PBXBuildFile; fileRef = 6C43CC051534F77800162364 /* darwin.S */; };\n+\t\t6C43CC201534F77800162364 /* darwin64.S in Sources */ = {isa = PBXBuildFile; fileRef = 6C43CC061534F77800162364 /* darwin64.S */; };\n+\t\t6C43CC211534F77800162364 /* ffi.c in Sources */ = {isa = PBXBuildFile; fileRef = 6C43CC071534F77800162364 /* ffi.c */; };\n+\t\t6C43CC221534F77800162364 /* ffi64.c in Sources */ = {isa = PBXBuildFile; fileRef = 6C43CC081534F77800162364 /* ffi64.c */; };\n+\t\t6C43CC2F1534F7BE00162364 /* closures.c in Sources */ = {isa = PBXBuildFile; fileRef = 6C43CC281534F7BE00162364 /* closures.c */; };\n+\t\t6C43CC301534F7BE00162364 /* closures.c in Sources */ = {isa = PBXBuildFile; fileRef = 6C43CC281534F7BE00162364 /* closures.c */; };\n+\t\t6C43CC351534F7BE00162364 /* java_raw_api.c in Sources */ = {isa = PBXBuildFile; fileRef = 6C43CC2B1534F7BE00162364 /* java_raw_api.c */; };\n+\t\t6C43CC361534F7BE00162364 /* java_raw_api.c in Sources */ = {isa = PBXBuildFile; fileRef = 6C43CC2B1534F7BE00162364 /* java_raw_api.c */; };\n+\t\t6C43CC371534F7BE00162364 /* prep_cif.c in Sources */ = {isa = PBXBuildFile; fileRef = 6C43CC2C1534F7BE00162364 /* prep_cif.c */; };\n+\t\t6C43CC381534F7BE00162364 /* prep_cif.c in Sources */ = {isa = PBXBuildFile; fileRef = 6C43CC2C1534F7BE00162364 /* prep_cif.c */; };\n+\t\t6C43CC391534F7BE00162364 /* raw_api.c in Sources */ = {isa = PBXBuildFile; fileRef = 6C43CC2D1534F7BE00162364 /* raw_api.c */; };\n+\t\t6C43CC3A1534F7BE00162364 /* raw_api.c in Sources */ = {isa = PBXBuildFile; fileRef = 6C43CC2D1534F7BE00162364 /* raw_api.c */; };\n+\t\t6C43CC3B1534F7BE00162364 /* types.c in Sources */ = {isa = PBXBuildFile; fileRef = 6C43CC2E1534F7BE00162364 /* types.c */; };\n+\t\t6C43CC3C1534F7BE00162364 /* types.c in Sources */ = {isa = PBXBuildFile; fileRef = 6C43CC2E1534F7BE00162364 /* types.c */; };\n+\t\t6C43CC971535032600162364 /* ffi.h in Headers */ = {isa = PBXBuildFile; fileRef = 6C43CC8D1535032600162364 /* ffi.h */; settings = {ATTRIBUTES = (Public, ); }; };\n+\t\t6C43CC981535032600162364 /* ffi_common.h in Headers */ = {isa = PBXBuildFile; fileRef = 6C43CC8E1535032600162364 /* ffi_common.h */; settings = {ATTRIBUTES = (Public, ); }; };\n+\t\t6C43CC991535032600162364 /* ffi_i386.h in Headers */ = {isa = PBXBuildFile; fileRef = 6C43CC8F1535032600162364 /* ffi_i386.h */; settings = {ATTRIBUTES = (Public, ); }; };\n+\t\t6C43CC9A1535032600162364 /* ffi_x86_64.h in Headers */ = {isa = PBXBuildFile; fileRef = 6C43CC901535032600162364 /* ffi_x86_64.h */; settings = {ATTRIBUTES = (Public, ); }; };\n+\t\t6C43CC9B1535032600162364 /* fficonfig.h in Headers */ = {isa = PBXBuildFile; fileRef = 6C43CC911535032600162364 /* fficonfig.h */; };\n+\t\t6C43CC9C1535032600162364 /* fficonfig_i386.h in Headers */ = {isa = PBXBuildFile; fileRef = 6C43CC921535032600162364 /* fficonfig_i386.h */; };\n+\t\t6C43CC9D1535032600162364 /* fficonfig_x86_64.h in Headers */ = {isa = PBXBuildFile; fileRef = 6C43CC931535032600162364 /* fficonfig_x86_64.h */; };\n+\t\t6C43CC9E1535032600162364 /* ffitarget.h in Headers */ = {isa = PBXBuildFile; fileRef = 6C43CC941535032600162364 /* ffitarget.h */; settings = {ATTRIBUTES = (Public, ); }; };\n+\t\t6C43CC9F1535032600162364 /* ffitarget_i386.h in Headers */ = {isa = PBXBuildFile; fileRef = 6C43CC951535032600162364 /* ffitarget_i386.h */; settings = {ATTRIBUTES = (Public, ); }; };\n+\t\t6C43CCA01535032600162364 /* ffitarget_x86_64.h in Headers */ = {isa = PBXBuildFile; fileRef = 6C43CC961535032600162364 /* ffitarget_x86_64.h */; settings = {ATTRIBUTES = (Public, ); }; };\n+\t\t6C43CCAD1535039600162364 /* ffi.h in Headers */ = {isa = PBXBuildFile; fileRef = 6C43CCA21535039600162364 /* ffi.h */; settings = {ATTRIBUTES = (Public, ); }; };\n+\t\t6C43CCAE1535039600162364 /* ffi_armv7.h in Headers */ = {isa = PBXBuildFile; fileRef = 6C43CCA31535039600162364 /* ffi_armv7.h */; settings = {ATTRIBUTES = (Public, ); }; };\n+\t\t6C43CCAF1535039600162364 /* ffi_common.h in Headers */ = {isa = PBXBuildFile; fileRef = 6C43CCA41535039600162364 /* ffi_common.h */; settings = {ATTRIBUTES = (Public, ); }; };\n+\t\t6C43CCB01535039600162364 /* ffi_i386.h in Headers */ = {isa = PBXBuildFile; fileRef = 6C43CCA51535039600162364 /* ffi_i386.h */; settings = {ATTRIBUTES = (Public, ); }; };\n+\t\t6C43CCB11535039600162364 /* fficonfig.h in Headers */ = {isa = PBXBuildFile; fileRef = 6C43CCA61535039600162364 /* fficonfig.h */; };\n+\t\t6C43CCB21535039600162364 /* fficonfig_armv7.h in Headers */ = {isa = PBXBuildFile; fileRef = 6C43CCA71535039600162364 /* fficonfig_armv7.h */; };\n+\t\t6C43CCB31535039600162364 /* fficonfig_i386.h in Headers */ = {isa = PBXBuildFile; fileRef = 6C43CCA81535039600162364 /* fficonfig_i386.h */; };\n+\t\t6C43CCB41535039600162364 /* ffitarget.h in Headers */ = {isa = PBXBuildFile; fileRef = 6C43CCA91535039600162364 /* ffitarget.h */; settings = {ATTRIBUTES = (Public, ); }; };\n+\t\t6C43CCB51535039600162364 /* ffitarget_arm.h in Headers */ = {isa = PBXBuildFile; fileRef = 6C43CCAA1535039600162364 /* ffitarget_arm.h */; settings = {ATTRIBUTES = (Public, ); }; };\n+\t\t6C43CCB61535039600162364 /* ffitarget_armv7.h in Headers */ = {isa = PBXBuildFile; fileRef = 6C43CCAB1535039600162364 /* ffitarget_armv7.h */; settings = {ATTRIBUTES = (Public, ); }; };\n+\t\t6C43CCB71535039600162364 /* ffitarget_i386.h in Headers */ = {isa = PBXBuildFile; fileRef = 6C43CCAC1535039600162364 /* ffitarget_i386.h */; settings = {ATTRIBUTES = (Public, ); }; };\n+/* End PBXBuildFile section */\n+\n+/* Begin PBXFileReference section */\n+\t\t6C43CB3D1534E9D100162364 /* libffi.a */ = {isa = PBXFileReference; explicitFileType = archive.ar; includeInIndex = 0; path = libffi.a; sourceTree = BUILT_PRODUCTS_DIR; };\n+\t\t6C43CBBD1534F76F00162364 /* ffi.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = ffi.c; sourceTree = \"<group>\"; };\n+\t\t6C43CBBF1534F76F00162364 /* sysv.S */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.asm; path = sysv.S; sourceTree = \"<group>\"; };\n+\t\t6C43CBC01534F76F00162364 /* trampoline.S */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.asm; path = trampoline.S; sourceTree = \"<group>\"; };\n+\t\t6C43CBC91534F76F00162364 /* darwin.S */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.asm; path = darwin.S; sourceTree = \"<group>\"; };\n+\t\t6C43CBCB1534F76F00162364 /* ffi.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = ffi.c; sourceTree = \"<group>\"; };\n+\t\t6C43CC051534F77800162364 /* darwin.S */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.asm; path = darwin.S; sourceTree = \"<group>\"; };\n+\t\t6C43CC061534F77800162364 /* darwin64.S */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.asm; path = darwin64.S; sourceTree = \"<group>\"; };\n+\t\t6C43CC071534F77800162364 /* ffi.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = ffi.c; sourceTree = \"<group>\"; };\n+\t\t6C43CC081534F77800162364 /* ffi64.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; path = ffi64.c; sourceTree = \"<group>\"; };\n+\t\t6C43CC281534F7BE00162364 /* closures.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; name = closures.c; path = src/closures.c; sourceTree = SOURCE_ROOT; };\n+\t\t6C43CC2B1534F7BE00162364 /* java_raw_api.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; name = java_raw_api.c; path = src/java_raw_api.c; sourceTree = SOURCE_ROOT; };\n+\t\t6C43CC2C1534F7BE00162364 /* prep_cif.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; name = prep_cif.c; path = src/prep_cif.c; sourceTree = SOURCE_ROOT; };\n+\t\t6C43CC2D1534F7BE00162364 /* raw_api.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; name = raw_api.c; path = src/raw_api.c; sourceTree = SOURCE_ROOT; };\n+\t\t6C43CC2E1534F7BE00162364 /* types.c */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.c; name = types.c; path = src/types.c; sourceTree = SOURCE_ROOT; };\n+\t\t6C43CC8D1535032600162364 /* ffi.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ffi.h; sourceTree = \"<group>\"; };\n+\t\t6C43CC8E1535032600162364 /* ffi_common.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ffi_common.h; sourceTree = \"<group>\"; };\n+\t\t6C43CC8F1535032600162364 /* ffi_i386.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ffi_i386.h; sourceTree = \"<group>\"; };\n+\t\t6C43CC901535032600162364 /* ffi_x86_64.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ffi_x86_64.h; sourceTree = \"<group>\"; };\n+\t\t6C43CC911535032600162364 /* fficonfig.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = fficonfig.h; sourceTree = \"<group>\"; };\n+\t\t6C43CC921535032600162364 /* fficonfig_i386.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = fficonfig_i386.h; sourceTree = \"<group>\"; };\n+\t\t6C43CC931535032600162364 /* fficonfig_x86_64.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = fficonfig_x86_64.h; sourceTree = \"<group>\"; };\n+\t\t6C43CC941535032600162364 /* ffitarget.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ffitarget.h; sourceTree = \"<group>\"; };\n+\t\t6C43CC951535032600162364 /* ffitarget_i386.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ffitarget_i386.h; sourceTree = \"<group>\"; };\n+\t\t6C43CC961535032600162364 /* ffitarget_x86_64.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ffitarget_x86_64.h; sourceTree = \"<group>\"; };\n+\t\t6C43CCA21535039600162364 /* ffi.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ffi.h; sourceTree = \"<group>\"; };\n+\t\t6C43CCA31535039600162364 /* ffi_armv7.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ffi_armv7.h; sourceTree = \"<group>\"; };\n+\t\t6C43CCA41535039600162364 /* ffi_common.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ffi_common.h; sourceTree = \"<group>\"; };\n+\t\t6C43CCA51535039600162364 /* ffi_i386.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ffi_i386.h; sourceTree = \"<group>\"; };\n+\t\t6C43CCA61535039600162364 /* fficonfig.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = fficonfig.h; sourceTree = \"<group>\"; };\n+\t\t6C43CCA71535039600162364 /* fficonfig_armv7.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = fficonfig_armv7.h; sourceTree = \"<group>\"; };\n+\t\t6C43CCA81535039600162364 /* fficonfig_i386.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = fficonfig_i386.h; sourceTree = \"<group>\"; };\n+\t\t6C43CCA91535039600162364 /* ffitarget.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ffitarget.h; sourceTree = \"<group>\"; };\n+\t\t6C43CCAA1535039600162364 /* ffitarget_arm.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ffitarget_arm.h; sourceTree = \"<group>\"; };\n+\t\t6C43CCAB1535039600162364 /* ffitarget_armv7.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ffitarget_armv7.h; sourceTree = \"<group>\"; };\n+\t\t6C43CCAC1535039600162364 /* ffitarget_i386.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ffitarget_i386.h; sourceTree = \"<group>\"; };\n+\t\tF6F980BA147386130008F121 /* libffi.a */ = {isa = PBXFileReference; explicitFileType = archive.ar; includeInIndex = 0; path = libffi.a; sourceTree = BUILT_PRODUCTS_DIR; };\n+/* End PBXFileReference section */\n+\n+/* Begin PBXFrameworksBuildPhase section */\n+\t\t6C43CB3A1534E9D100162364 /* Frameworks */ = {\n+\t\t\tisa = PBXFrameworksBuildPhase;\n+\t\t\tbuildActionMask = 2147483647;\n+\t\t\tfiles = (\n+\t\t\t);\n+\t\t\trunOnlyForDeploymentPostprocessing = 0;\n+\t\t};\n+\t\tF6F980B7147386130008F121 /* Frameworks */ = {\n+\t\t\tisa = PBXFrameworksBuildPhase;\n+\t\t\tbuildActionMask = 2147483647;\n+\t\t\tfiles = (\n+\t\t\t);\n+\t\t\trunOnlyForDeploymentPostprocessing = 0;\n+\t\t};\n+/* End PBXFrameworksBuildPhase section */\n+\n+/* Begin PBXGroup section */\n+\t\t6C43CBAF1534F76F00162364 /* iOS */ = {\n+\t\t\tisa = PBXGroup;\n+\t\t\tchildren = (\n+\t\t\t\t6C43CCA11535039600162364 /* include */,\n+\t\t\t\t6C43CBBB1534F76F00162364 /* src */,\n+\t\t\t);\n+\t\t\tname = iOS;\n+\t\t\tpath = ios;\n+\t\t\tsourceTree = \"<group>\";\n+\t\t};\n+\t\t6C43CBBB1534F76F00162364 /* src */ = {\n+\t\t\tisa = PBXGroup;\n+\t\t\tchildren = (\n+\t\t\t\t6C43CBC81534F76F00162364 /* x86 */,\n+\t\t\t\t6C43CBBC1534F76F00162364 /* arm */,\n+\t\t\t);\n+\t\t\tpath = src;\n+\t\t\tsourceTree = \"<group>\";\n+\t\t};\n+\t\t6C43CBBC1534F76F00162364 /* arm */ = {\n+\t\t\tisa = PBXGroup;\n+\t\t\tchildren = (\n+\t\t\t\t6C43CBBD1534F76F00162364 /* ffi.c */,\n+\t\t\t\t6C43CBBF1534F76F00162364 /* sysv.S */,\n+\t\t\t\t6C43CBC01534F76F00162364 /* trampoline.S */,\n+\t\t\t);\n+\t\t\tpath = arm;\n+\t\t\tsourceTree = \"<group>\";\n+\t\t};\n+\t\t6C43CBC81534F76F00162364 /* x86 */ = {\n+\t\t\tisa = PBXGroup;\n+\t\t\tchildren = (\n+\t\t\t\t6C43CBC91534F76F00162364 /* darwin.S */,\n+\t\t\t\t6C43CBCB1534F76F00162364 /* ffi.c */,\n+\t\t\t);\n+\t\t\tpath = x86;\n+\t\t\tsourceTree = \"<group>\";\n+\t\t};\n+\t\t6C43CBF01534F77800162364 /* OS X */ = {\n+\t\t\tisa = PBXGroup;\n+\t\t\tchildren = (\n+\t\t\t\t6C43CC8C1535032600162364 /* include */,\n+\t\t\t\t6C43CBFC1534F77800162364 /* src */,\n+\t\t\t);\n+\t\t\tname = \"OS X\";\n+\t\t\tpath = osx;\n+\t\t\tsourceTree = \"<group>\";\n+\t\t};\n+\t\t6C43CBFC1534F77800162364 /* src */ = {\n+\t\t\tisa = PBXGroup;\n+\t\t\tchildren = (\n+\t\t\t\t6C43CC041534F77800162364 /* x86 */,\n+\t\t\t);\n+\t\t\tpath = src;\n+\t\t\tsourceTree = \"<group>\";\n+\t\t};\n+\t\t6C43CC041534F77800162364 /* x86 */ = {\n+\t\t\tisa = PBXGroup;\n+\t\t\tchildren = (\n+\t\t\t\t6C43CC051534F77800162364 /* darwin.S */,\n+\t\t\t\t6C43CC061534F77800162364 /* darwin64.S */,\n+\t\t\t\t6C43CC071534F77800162364 /* ffi.c */,\n+\t\t\t\t6C43CC081534F77800162364 /* ffi64.c */,\n+\t\t\t);\n+\t\t\tpath = x86;\n+\t\t\tsourceTree = \"<group>\";\n+\t\t};\n+\t\t6C43CC3D1534F7C400162364 /* src */ = {\n+\t\t\tisa = PBXGroup;\n+\t\t\tchildren = (\n+\t\t\t\t6C43CC281534F7BE00162364 /* closures.c */,\n+\t\t\t\t6C43CC2B1534F7BE00162364 /* java_raw_api.c */,\n+\t\t\t\t6C43CC2C1534F7BE00162364 /* prep_cif.c */,\n+\t\t\t\t6C43CC2D1534F7BE00162364 /* raw_api.c */,\n+\t\t\t\t6C43CC2E1534F7BE00162364 /* types.c */,\n+\t\t\t);\n+\t\t\tname = src;\n+\t\t\tpath = ios;\n+\t\t\tsourceTree = \"<group>\";\n+\t\t};\n+\t\t6C43CC8C1535032600162364 /* include */ = {\n+\t\t\tisa = PBXGroup;\n+\t\t\tchildren = (\n+\t\t\t\t6C43CC8D1535032600162364 /* ffi.h */,\n+\t\t\t\t6C43CC8E1535032600162364 /* ffi_common.h */,\n+\t\t\t\t6C43CC8F1535032600162364 /* ffi_i386.h */,\n+\t\t\t\t6C43CC901535032600162364 /* ffi_x86_64.h */,\n+\t\t\t\t6C43CC911535032600162364 /* fficonfig.h */,\n+\t\t\t\t6C43CC921535032600162364 /* fficonfig_i386.h */,\n+\t\t\t\t6C43CC931535032600162364 /* fficonfig_x86_64.h */,\n+\t\t\t\t6C43CC941535032600162364 /* ffitarget.h */,\n+\t\t\t\t6C43CC951535032600162364 /* ffitarget_i386.h */,\n+\t\t\t\t6C43CC961535032600162364 /* ffitarget_x86_64.h */,\n+\t\t\t);\n+\t\t\tpath = include;\n+\t\t\tsourceTree = \"<group>\";\n+\t\t};\n+\t\t6C43CCA11535039600162364 /* include */ = {\n+\t\t\tisa = PBXGroup;\n+\t\t\tchildren = (\n+\t\t\t\t6C43CCA21535039600162364 /* ffi.h */,\n+\t\t\t\t6C43CCA31535039600162364 /* ffi_armv7.h */,\n+\t\t\t\t6C43CCA41535039600162364 /* ffi_common.h */,\n+\t\t\t\t6C43CCA51535039600162364 /* ffi_i386.h */,\n+\t\t\t\t6C43CCA61535039600162364 /* fficonfig.h */,\n+\t\t\t\t6C43CCA71535039600162364 /* fficonfig_armv7.h */,\n+\t\t\t\t6C43CCA81535039600162364 /* fficonfig_i386.h */,\n+\t\t\t\t6C43CCA91535039600162364 /* ffitarget.h */,\n+\t\t\t\t6C43CCAA1535039600162364 /* ffitarget_arm.h */,\n+\t\t\t\t6C43CCAB1535039600162364 /* ffitarget_armv7.h */,\n+\t\t\t\t6C43CCAC1535039600162364 /* ffitarget_i386.h */,\n+\t\t\t);\n+\t\t\tpath = include;\n+\t\t\tsourceTree = \"<group>\";\n+\t\t};\n+\t\tF6B0839514721EE50031D8A1 = {\n+\t\t\tisa = PBXGroup;\n+\t\t\tchildren = (\n+\t\t\t\t6C43CC3D1534F7C400162364 /* src */,\n+\t\t\t\t6C43CBAF1534F76F00162364 /* iOS */,\n+\t\t\t\t6C43CBF01534F77800162364 /* OS X */,\n+\t\t\t\tF6F980C6147386260008F121 /* Products */,\n+\t\t\t);\n+\t\t\tsourceTree = \"<group>\";\n+\t\t};\n+\t\tF6F980C6147386260008F121 /* Products */ = {\n+\t\t\tisa = PBXGroup;\n+\t\t\tchildren = (\n+\t\t\t\tF6F980BA147386130008F121 /* libffi.a */,\n+\t\t\t\t6C43CB3D1534E9D100162364 /* libffi.a */,\n+\t\t\t);\n+\t\t\tname = Products;\n+\t\t\tpath = ../..;\n+\t\t\tsourceTree = BUILT_PRODUCTS_DIR;\n+\t\t};\n+/* End PBXGroup section */\n+\n+/* Begin PBXHeadersBuildPhase section */\n+\t\t6C43CB3B1534E9D100162364 /* Headers */ = {\n+\t\t\tisa = PBXHeadersBuildPhase;\n+\t\t\tbuildActionMask = 2147483647;\n+\t\t\tfiles = (\n+\t\t\t\t6C43CC971535032600162364 /* ffi.h in Headers */,\n+\t\t\t\t6C43CC981535032600162364 /* ffi_common.h in Headers */,\n+\t\t\t\t6C43CC991535032600162364 /* ffi_i386.h in Headers */,\n+\t\t\t\t6C43CC9A1535032600162364 /* ffi_x86_64.h in Headers */,\n+\t\t\t\t6C43CC9E1535032600162364 /* ffitarget.h in Headers */,\n+\t\t\t\t6C43CC9F1535032600162364 /* ffitarget_i386.h in Headers */,\n+\t\t\t\t6C43CCA01535032600162364 /* ffitarget_x86_64.h in Headers */,\n+\t\t\t\t6C43CC9B1535032600162364 /* fficonfig.h in Headers */,\n+\t\t\t\t6C43CC9C1535032600162364 /* fficonfig_i386.h in Headers */,\n+\t\t\t\t6C43CC9D1535032600162364 /* fficonfig_x86_64.h in Headers */,\n+\t\t\t);\n+\t\t\trunOnlyForDeploymentPostprocessing = 0;\n+\t\t};\n+\t\tF6F980B8147386130008F121 /* Headers */ = {\n+\t\t\tisa = PBXHeadersBuildPhase;\n+\t\t\tbuildActionMask = 2147483647;\n+\t\t\tfiles = (\n+\t\t\t\t6C43CCAD1535039600162364 /* ffi.h in Headers */,\n+\t\t\t\t6C43CCAE1535039600162364 /* ffi_armv7.h in Headers */,\n+\t\t\t\t6C43CCAF1535039600162364 /* ffi_common.h in Headers */,\n+\t\t\t\t6C43CCB01535039600162364 /* ffi_i386.h in Headers */,\n+\t\t\t\t6C43CCB41535039600162364 /* ffitarget.h in Headers */,\n+\t\t\t\t6C43CCB51535039600162364 /* ffitarget_arm.h in Headers */,\n+\t\t\t\t6C43CCB61535039600162364 /* ffitarget_armv7.h in Headers */,\n+\t\t\t\t6C43CCB71535039600162364 /* ffitarget_i386.h in Headers */,\n+\t\t\t\t6C43CCB11535039600162364 /* fficonfig.h in Headers */,\n+\t\t\t\t6C43CCB21535039600162364 /* fficonfig_armv7.h in Headers */,\n+\t\t\t\t6C43CCB31535039600162364 /* fficonfig_i386.h in Headers */,\n+\t\t\t);\n+\t\t\trunOnlyForDeploymentPostprocessing = 0;\n+\t\t};\n+/* End PBXHeadersBuildPhase section */\n+\n+/* Begin PBXNativeTarget section */\n+\t\t6C43CB3C1534E9D100162364 /* libffi OS X */ = {\n+\t\t\tisa = PBXNativeTarget;\n+\t\t\tbuildConfigurationList = 6C43CB4A1534E9D100162364 /* Build configuration list for PBXNativeTarget \"libffi OS X\" */;\n+\t\t\tbuildPhases = (\n+\t\t\t\t6C43CC401534FF3B00162364 /* Generate Source and Headers */,\n+\t\t\t\t6C43CB391534E9D100162364 /* Sources */,\n+\t\t\t\t6C43CB3A1534E9D100162364 /* Frameworks */,\n+\t\t\t\t6C43CB3B1534E9D100162364 /* Headers */,\n+\t\t\t);\n+\t\t\tbuildRules = (\n+\t\t\t);\n+\t\t\tdependencies = (\n+\t\t\t);\n+\t\t\tname = \"libffi OS X\";\n+\t\t\tproductName = \"ffi OS X\";\n+\t\t\tproductReference = 6C43CB3D1534E9D100162364 /* libffi.a */;\n+\t\t\tproductType = \"com.apple.product-type.library.static\";\n+\t\t};\n+\t\tF6F980B9147386130008F121 /* libffi iOS */ = {\n+\t\t\tisa = PBXNativeTarget;\n+\t\t\tbuildConfigurationList = F6F980C4147386130008F121 /* Build configuration list for PBXNativeTarget \"libffi iOS\" */;\n+\t\t\tbuildPhases = (\n+\t\t\t\t6C43CC3E1534F8E200162364 /* Generate Trampoline */,\n+\t\t\t\t6C43CC3F1534FF1B00162364 /* Generate Source and Headers */,\n+\t\t\t\tF6F980B6147386130008F121 /* Sources */,\n+\t\t\t\tF6F980B7147386130008F121 /* Frameworks */,\n+\t\t\t\tF6F980B8147386130008F121 /* Headers */,\n+\t\t\t);\n+\t\t\tbuildRules = (\n+\t\t\t);\n+\t\t\tdependencies = (\n+\t\t\t);\n+\t\t\tname = \"libffi iOS\";\n+\t\t\tproductName = ffi;\n+\t\t\tproductReference = F6F980BA147386130008F121 /* libffi.a */;\n+\t\t\tproductType = \"com.apple.product-type.library.static\";\n+\t\t};\n+/* End PBXNativeTarget section */\n+\n+/* Begin PBXProject section */\n+\t\tF6B0839714721EE50031D8A1 /* Project object */ = {\n+\t\t\tisa = PBXProject;\n+\t\t\tattributes = {\n+\t\t\t\tLastUpgradeCheck = 0430;\n+\t\t\t};\n+\t\t\tbuildConfigurationList = F6B0839A14721EE50031D8A1 /* Build configuration list for PBXProject \"libffi\" */;\n+\t\t\tcompatibilityVersion = \"Xcode 3.2\";\n+\t\t\tdevelopmentRegion = English;\n+\t\t\thasScannedForEncodings = 0;\n+\t\t\tknownRegions = (\n+\t\t\t\ten,\n+\t\t\t);\n+\t\t\tmainGroup = F6B0839514721EE50031D8A1;\n+\t\t\tproductRefGroup = F6B0839514721EE50031D8A1;\n+\t\t\tprojectDirPath = \"\";\n+\t\t\tprojectRoot = \"\";\n+\t\t\ttargets = (\n+\t\t\t\tF6F980B9147386130008F121 /* libffi iOS */,\n+\t\t\t\t6C43CB3C1534E9D100162364 /* libffi OS X */,\n+\t\t\t);\n+\t\t};\n+/* End PBXProject section */\n+\n+/* Begin PBXShellScriptBuildPhase section */\n+\t\t6C43CC3E1534F8E200162364 /* Generate Trampoline */ = {\n+\t\t\tisa = PBXShellScriptBuildPhase;\n+\t\t\tbuildActionMask = 2147483647;\n+\t\t\tfiles = (\n+\t\t\t);\n+\t\t\tinputPaths = (\n+\t\t\t);\n+\t\t\tname = \"Generate Trampoline\";\n+\t\t\toutputPaths = (\n+\t\t\t);\n+\t\t\trunOnlyForDeploymentPostprocessing = 0;\n+\t\t\tshellPath = /usr/bin/python;\n+\t\t\tshellScript = \"import subprocess\\nimport re\\nimport os\\nimport errno\\nimport sys\\n\\ndef main():\\n    with open('src/arm/trampoline.S', 'w') as tramp_out:\\n        p = subprocess.Popen(['bash', 'src/arm/gentramp.sh'], stdout=tramp_out)\\n        p.wait()\\n\\nif __name__ == '__main__':\\n    main()\";\n+\t\t};\n+\t\t6C43CC3F1534FF1B00162364 /* Generate Source and Headers */ = {\n+\t\t\tisa = PBXShellScriptBuildPhase;\n+\t\t\tbuildActionMask = 2147483647;\n+\t\t\tfiles = (\n+\t\t\t);\n+\t\t\tinputPaths = (\n+\t\t\t);\n+\t\t\tname = \"Generate Source and Headers\";\n+\t\t\toutputPaths = (\n+\t\t\t);\n+\t\t\trunOnlyForDeploymentPostprocessing = 0;\n+\t\t\tshellPath = /bin/sh;\n+\t\t\tshellScript = \"/usr/bin/python generate-ios-source-and-headers.py\";\n+\t\t};\n+\t\t6C43CC401534FF3B00162364 /* Generate Source and Headers */ = {\n+\t\t\tisa = PBXShellScriptBuildPhase;\n+\t\t\tbuildActionMask = 2147483647;\n+\t\t\tfiles = (\n+\t\t\t);\n+\t\t\tinputPaths = (\n+\t\t\t);\n+\t\t\tname = \"Generate Source and Headers\";\n+\t\t\toutputPaths = (\n+\t\t\t);\n+\t\t\trunOnlyForDeploymentPostprocessing = 0;\n+\t\t\tshellPath = /bin/sh;\n+\t\t\tshellScript = \"/usr/bin/python generate-osx-source-and-headers.py\";\n+\t\t};\n+/* End PBXShellScriptBuildPhase section */\n+\n+/* Begin PBXSourcesBuildPhase section */\n+\t\t6C43CB391534E9D100162364 /* Sources */ = {\n+\t\t\tisa = PBXSourcesBuildPhase;\n+\t\t\tbuildActionMask = 2147483647;\n+\t\t\tfiles = (\n+\t\t\t\t6C43CC1F1534F77800162364 /* darwin.S in Sources */,\n+\t\t\t\t6C43CC201534F77800162364 /* darwin64.S in Sources */,\n+\t\t\t\t6C43CC211534F77800162364 /* ffi.c in Sources */,\n+\t\t\t\t6C43CC221534F77800162364 /* ffi64.c in Sources */,\n+\t\t\t\t6C43CC301534F7BE00162364 /* closures.c in Sources */,\n+\t\t\t\t6C43CC361534F7BE00162364 /* java_raw_api.c in Sources */,\n+\t\t\t\t6C43CC381534F7BE00162364 /* prep_cif.c in Sources */,\n+\t\t\t\t6C43CC3A1534F7BE00162364 /* raw_api.c in Sources */,\n+\t\t\t\t6C43CC3C1534F7BE00162364 /* types.c in Sources */,\n+\t\t\t);\n+\t\t\trunOnlyForDeploymentPostprocessing = 0;\n+\t\t};\n+\t\tF6F980B6147386130008F121 /* Sources */ = {\n+\t\t\tisa = PBXSourcesBuildPhase;\n+\t\t\tbuildActionMask = 2147483647;\n+\t\t\tfiles = (\n+\t\t\t\t6C43CBDC1534F76F00162364 /* ffi.c in Sources */,\n+\t\t\t\t6C43CBDD1534F76F00162364 /* sysv.S in Sources */,\n+\t\t\t\t6C43CBDE1534F76F00162364 /* trampoline.S in Sources */,\n+\t\t\t\t6C43CBE61534F76F00162364 /* darwin.S in Sources */,\n+\t\t\t\t6C43CBE81534F76F00162364 /* ffi.c in Sources */,\n+\t\t\t\t6C43CC2F1534F7BE00162364 /* closures.c in Sources */,\n+\t\t\t\t6C43CC351534F7BE00162364 /* java_raw_api.c in Sources */,\n+\t\t\t\t6C43CC371534F7BE00162364 /* prep_cif.c in Sources */,\n+\t\t\t\t6C43CC391534F7BE00162364 /* raw_api.c in Sources */,\n+\t\t\t\t6C43CC3B1534F7BE00162364 /* types.c in Sources */,\n+\t\t\t);\n+\t\t\trunOnlyForDeploymentPostprocessing = 0;\n+\t\t};\n+/* End PBXSourcesBuildPhase section */\n+\n+/* Begin XCBuildConfiguration section */\n+\t\t6C43CB4B1534E9D100162364 /* Debug */ = {\n+\t\t\tisa = XCBuildConfiguration;\n+\t\t\tbuildSettings = {\n+\t\t\t\tARCHS = \"$(ARCHS_STANDARD_32_64_BIT)\";\n+\t\t\t\tDSTROOT = /tmp/ffi.dst;\n+\t\t\t\tFRAMEWORK_SEARCH_PATHS = (\n+\t\t\t\t\t\"$(inherited)\",\n+\t\t\t\t\t\"\\\"$(SYSTEM_APPS_DIR)/Xcode.app/Contents/Developer/Library/Frameworks\\\"\",\n+\t\t\t\t);\n+\t\t\t\tGCC_ENABLE_OBJC_EXCEPTIONS = YES;\n+\t\t\t\tGCC_VERSION = com.apple.compilers.llvm.clang.1_0;\n+\t\t\t\tGCC_WARN_64_TO_32_BIT_CONVERSION = YES;\n+\t\t\t\tGCC_WARN_UNINITIALIZED_AUTOS = YES;\n+\t\t\t\tMACOSX_DEPLOYMENT_TARGET = 10.6;\n+\t\t\t\tONLY_ACTIVE_ARCH = YES;\n+\t\t\t\tPRODUCT_NAME = ffi;\n+\t\t\t\tSDKROOT = macosx;\n+\t\t\t};\n+\t\t\tname = Debug;\n+\t\t};\n+\t\t6C43CB4C1534E9D100162364 /* Release */ = {\n+\t\t\tisa = XCBuildConfiguration;\n+\t\t\tbuildSettings = {\n+\t\t\t\tARCHS = \"$(ARCHS_STANDARD_32_64_BIT)\";\n+\t\t\t\tDEBUG_INFORMATION_FORMAT = \"dwarf-with-dsym\";\n+\t\t\t\tDSTROOT = /tmp/ffi.dst;\n+\t\t\t\tFRAMEWORK_SEARCH_PATHS = (\n+\t\t\t\t\t\"$(inherited)\",\n+\t\t\t\t\t\"\\\"$(SYSTEM_APPS_DIR)/Xcode.app/Contents/Developer/Library/Frameworks\\\"\",\n+\t\t\t\t);\n+\t\t\t\tGCC_ENABLE_OBJC_EXCEPTIONS = YES;\n+\t\t\t\tGCC_VERSION = com.apple.compilers.llvm.clang.1_0;\n+\t\t\t\tGCC_WARN_64_TO_32_BIT_CONVERSION = YES;\n+\t\t\t\tGCC_WARN_UNINITIALIZED_AUTOS = YES;\n+\t\t\t\tMACOSX_DEPLOYMENT_TARGET = 10.6;\n+\t\t\t\tPRODUCT_NAME = ffi;\n+\t\t\t\tSDKROOT = macosx;\n+\t\t\t};\n+\t\t\tname = Release;\n+\t\t};\n+\t\tF6B083AB14721EE50031D8A1 /* Debug */ = {\n+\t\t\tisa = XCBuildConfiguration;\n+\t\t\tbuildSettings = {\n+\t\t\t\tALWAYS_SEARCH_USER_PATHS = NO;\n+\t\t\t\tARCHS = \"$(ARCHS_STANDARD_32_BIT)\";\n+\t\t\t\tCOPY_PHASE_STRIP = NO;\n+\t\t\t\tGCC_C_LANGUAGE_STANDARD = gnu99;\n+\t\t\t\tGCC_DYNAMIC_NO_PIC = NO;\n+\t\t\t\tGCC_OPTIMIZATION_LEVEL = 0;\n+\t\t\t\tGCC_PREPROCESSOR_DEFINITIONS = (\n+\t\t\t\t\t\"DEBUG=1\",\n+\t\t\t\t\t\"$(inherited)\",\n+\t\t\t\t);\n+\t\t\t\tGCC_SYMBOLS_PRIVATE_EXTERN = NO;\n+\t\t\t\tGCC_WARN_ABOUT_MISSING_PROTOTYPES = NO;\n+\t\t\t\tGCC_WARN_ABOUT_RETURN_TYPE = YES;\n+\t\t\t\tGCC_WARN_UNUSED_VALUE = NO;\n+\t\t\t\tGCC_WARN_UNUSED_VARIABLE = YES;\n+\t\t\t\tHEADER_SEARCH_PATHS = ios/include;\n+\t\t\t\tSDKROOT = iphoneos;\n+\t\t\t};\n+\t\t\tname = Debug;\n+\t\t};\n+\t\tF6B083AC14721EE50031D8A1 /* Release */ = {\n+\t\t\tisa = XCBuildConfiguration;\n+\t\t\tbuildSettings = {\n+\t\t\t\tALWAYS_SEARCH_USER_PATHS = NO;\n+\t\t\t\tARCHS = \"$(ARCHS_STANDARD_32_BIT)\";\n+\t\t\t\tCOPY_PHASE_STRIP = YES;\n+\t\t\t\tGCC_C_LANGUAGE_STANDARD = gnu99;\n+\t\t\t\tGCC_PREPROCESSOR_DEFINITIONS = \"\";\n+\t\t\t\tGCC_WARN_ABOUT_MISSING_PROTOTYPES = NO;\n+\t\t\t\tGCC_WARN_ABOUT_RETURN_TYPE = YES;\n+\t\t\t\tGCC_WARN_UNUSED_VALUE = NO;\n+\t\t\t\tGCC_WARN_UNUSED_VARIABLE = YES;\n+\t\t\t\tHEADER_SEARCH_PATHS = ios/include;\n+\t\t\t\tSDKROOT = iphoneos;\n+\t\t\t\tVALIDATE_PRODUCT = YES;\n+\t\t\t};\n+\t\t\tname = Release;\n+\t\t};\n+\t\tF6F980C2147386130008F121 /* Debug */ = {\n+\t\t\tisa = XCBuildConfiguration;\n+\t\t\tbuildSettings = {\n+\t\t\t\tARCHS = (\n+\t\t\t\t\tarmv6,\n+\t\t\t\t\tarmv7,\n+\t\t\t\t);\n+\t\t\t\tDSTROOT = /tmp/ffi.dst;\n+\t\t\t\tGCC_PRECOMPILE_PREFIX_HEADER = YES;\n+\t\t\t\tGCC_THUMB_SUPPORT = NO;\n+\t\t\t\tIPHONEOS_DEPLOYMENT_TARGET = 4.0;\n+\t\t\t\tOTHER_LDFLAGS = \"-ObjC\";\n+\t\t\t\tPRODUCT_NAME = ffi;\n+\t\t\t\tSKIP_INSTALL = YES;\n+\t\t\t};\n+\t\t\tname = Debug;\n+\t\t};\n+\t\tF6F980C3147386130008F121 /* Release */ = {\n+\t\t\tisa = XCBuildConfiguration;\n+\t\t\tbuildSettings = {\n+\t\t\t\tARCHS = (\n+\t\t\t\t\tarmv6,\n+\t\t\t\t\tarmv7,\n+\t\t\t\t);\n+\t\t\t\tDSTROOT = /tmp/ffi.dst;\n+\t\t\t\tGCC_PRECOMPILE_PREFIX_HEADER = YES;\n+\t\t\t\tGCC_THUMB_SUPPORT = NO;\n+\t\t\t\tIPHONEOS_DEPLOYMENT_TARGET = 4.0;\n+\t\t\t\tOTHER_LDFLAGS = \"-ObjC\";\n+\t\t\t\tPRODUCT_NAME = ffi;\n+\t\t\t\tSKIP_INSTALL = YES;\n+\t\t\t};\n+\t\t\tname = Release;\n+\t\t};\n+/* End XCBuildConfiguration section */\n+\n+/* Begin XCConfigurationList section */\n+\t\t6C43CB4A1534E9D100162364 /* Build configuration list for PBXNativeTarget \"libffi OS X\" */ = {\n+\t\t\tisa = XCConfigurationList;\n+\t\t\tbuildConfigurations = (\n+\t\t\t\t6C43CB4B1534E9D100162364 /* Debug */,\n+\t\t\t\t6C43CB4C1534E9D100162364 /* Release */,\n+\t\t\t);\n+\t\t\tdefaultConfigurationIsVisible = 0;\n+\t\t\tdefaultConfigurationName = Release;\n+\t\t};\n+\t\tF6B0839A14721EE50031D8A1 /* Build configuration list for PBXProject \"libffi\" */ = {\n+\t\t\tisa = XCConfigurationList;\n+\t\t\tbuildConfigurations = (\n+\t\t\t\tF6B083AB14721EE50031D8A1 /* Debug */,\n+\t\t\t\tF6B083AC14721EE50031D8A1 /* Release */,\n+\t\t\t);\n+\t\t\tdefaultConfigurationIsVisible = 0;\n+\t\t\tdefaultConfigurationName = Release;\n+\t\t};\n+\t\tF6F980C4147386130008F121 /* Build configuration list for PBXNativeTarget \"libffi iOS\" */ = {\n+\t\t\tisa = XCConfigurationList;\n+\t\t\tbuildConfigurations = (\n+\t\t\t\tF6F980C2147386130008F121 /* Debug */,\n+\t\t\t\tF6F980C3147386130008F121 /* Release */,\n+\t\t\t);\n+\t\t\tdefaultConfigurationIsVisible = 0;\n+\t\t\tdefaultConfigurationName = Release;\n+\t\t};\n+/* End XCConfigurationList section */\n+\t};\n+\trootObject = F6B0839714721EE50031D8A1 /* Project object */;\n+}"}, {"sha": "afcbfb69f1d3de0cce6c171f357c5927972db76b", "filename": "libffi/man/Makefile.am", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Fman%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Fman%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fman%2FMakefile.am?ref=b4b575ce7854f4a49de8de93f38b7639e01b040b", "patch": "@@ -2,7 +2,7 @@\n \n AUTOMAKE_OPTIONS=foreign\n \n-EXTRA_DIST = ffi.3 ffi_call.3 ffi_prep_cif.3\n+EXTRA_DIST = ffi.3 ffi_call.3 ffi_prep_cif.3 ffi_prep_cif_var.3\n \n-man_MANS = ffi.3 ffi_call.3 ffi_prep_cif.3\n+man_MANS = ffi.3 ffi_call.3 ffi_prep_cif.3 ffi_prep_cif_var.3\n "}, {"sha": "199fea6f4eff51956738c4643aabf1682663bf62", "filename": "libffi/man/Makefile.in", "status": "modified", "additions": 75, "deletions": 26, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Fman%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Fman%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fman%2FMakefile.in?ref=b4b575ce7854f4a49de8de93f38b7639e01b040b", "patch": "@@ -1,9 +1,9 @@\n-# Makefile.in generated by automake 1.11.1 from Makefile.am.\n+# Makefile.in generated by automake 1.11.6 from Makefile.am.\n # @configure_input@\n \n # Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,\n-# 2003, 2004, 2005, 2006, 2007, 2008, 2009  Free Software Foundation,\n-# Inc.\n+# 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 Free Software\n+# Foundation, Inc.\n # This Makefile.in is free software; the Free Software Foundation\n # gives unlimited permission to copy and/or distribute it,\n # with or without modifications, as long as this notice is preserved.\n@@ -15,6 +15,23 @@\n \n @SET_MAKE@\n VPATH = @srcdir@\n+am__make_dryrun = \\\n+  { \\\n+    am__dry=no; \\\n+    case $$MAKEFLAGS in \\\n+      *\\\\[\\ \\\t]*) \\\n+        echo 'am--echo: ; @echo \"AM\"  OK' | $(MAKE) -f - 2>/dev/null \\\n+          | grep '^AM OK$$' >/dev/null || am__dry=yes;; \\\n+      *) \\\n+        for am__flg in $$MAKEFLAGS; do \\\n+          case $$am__flg in \\\n+            *=*|--*) ;; \\\n+            *n*) am__dry=yes; break;; \\\n+          esac; \\\n+        done;; \\\n+    esac; \\\n+    test $$am__dry = yes; \\\n+  }\n pkgdatadir = $(datadir)/@PACKAGE@\n pkgincludedir = $(includedir)/@PACKAGE@\n pkglibdir = $(libdir)/@PACKAGE@\n@@ -37,22 +54,32 @@ target_triplet = @target@\n subdir = man\n DIST_COMMON = $(srcdir)/Makefile.am $(srcdir)/Makefile.in\n ACLOCAL_M4 = $(top_srcdir)/aclocal.m4\n-am__aclocal_m4_deps = $(top_srcdir)/../config/depstand.m4 \\\n-\t$(top_srcdir)/../config/lead-dot.m4 \\\n-\t$(top_srcdir)/../config/multi.m4 \\\n-\t$(top_srcdir)/../config/override.m4 \\\n-\t$(top_srcdir)/../libtool.m4 $(top_srcdir)/../ltoptions.m4 \\\n-\t$(top_srcdir)/../ltsugar.m4 $(top_srcdir)/../ltversion.m4 \\\n-\t$(top_srcdir)/../lt~obsolete.m4 $(top_srcdir)/acinclude.m4 \\\n+am__aclocal_m4_deps = $(top_srcdir)/m4/asmcfi.m4 \\\n+\t$(top_srcdir)/m4/ax_cc_maxopt.m4 \\\n+\t$(top_srcdir)/m4/ax_cflags_warn_all.m4 \\\n+\t$(top_srcdir)/m4/ax_check_compile_flag.m4 \\\n+\t$(top_srcdir)/m4/ax_compiler_vendor.m4 \\\n+\t$(top_srcdir)/m4/ax_configure_args.m4 \\\n+\t$(top_srcdir)/m4/ax_enable_builddir.m4 \\\n+\t$(top_srcdir)/m4/ax_gcc_archflag.m4 \\\n+\t$(top_srcdir)/m4/ax_gcc_x86_cpuid.m4 \\\n+\t$(top_srcdir)/m4/libtool.m4 $(top_srcdir)/m4/ltoptions.m4 \\\n+\t$(top_srcdir)/m4/ltsugar.m4 $(top_srcdir)/m4/ltversion.m4 \\\n+\t$(top_srcdir)/m4/lt~obsolete.m4 $(top_srcdir)/acinclude.m4 \\\n \t$(top_srcdir)/configure.ac\n am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \\\n \t$(ACLOCAL_M4)\n-mkinstalldirs = $(SHELL) $(top_srcdir)/../mkinstalldirs\n+mkinstalldirs = $(install_sh) -d\n CONFIG_HEADER = $(top_builddir)/fficonfig.h\n CONFIG_CLEAN_FILES =\n CONFIG_CLEAN_VPATH_FILES =\n SOURCES =\n DIST_SOURCES =\n+am__can_run_installinfo = \\\n+  case $$AM_UPDATE_INFO_DIR in \\\n+    n|no|NO) false;; \\\n+    *) (install-info --version) >/dev/null 2>&1;; \\\n+  esac\n am__vpath_adj_setup = srcdirstrip=`echo \"$(srcdir)\" | sed 's|.|.|g'`;\n am__vpath_adj = case $$p in \\\n     $(srcdir)/*) f=`echo \"$$p\" | sed \"s|^$$srcdirstrip/||\"`;; \\\n@@ -74,6 +101,12 @@ am__nobase_list = $(am__nobase_strip_setup); \\\n am__base_list = \\\n   sed '$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;s/\\n/ /g' | \\\n   sed '$$!N;$$!N;$$!N;$$!N;s/\\n/ /g'\n+am__uninstall_files_from_dir = { \\\n+  test -z \"$$files\" \\\n+    || { test ! -d \"$$dir\" && test ! -f \"$$dir\" && test ! -r \"$$dir\"; } \\\n+    || { echo \" ( cd '$$dir' && rm -f\" $$files \")\"; \\\n+         $(am__cd) \"$$dir\" && rm -f $$files; }; \\\n+  }\n man3dir = $(mandir)/man3\n am__installdirs = \"$(DESTDIR)$(man3dir)\"\n NROFF = nroff\n@@ -100,13 +133,15 @@ CPPFLAGS = @CPPFLAGS@\n CYGPATH_W = @CYGPATH_W@\n DEFS = @DEFS@\n DEPDIR = @DEPDIR@\n+DLLTOOL = @DLLTOOL@\n DSYMUTIL = @DSYMUTIL@\n DUMPBIN = @DUMPBIN@\n ECHO_C = @ECHO_C@\n ECHO_N = @ECHO_N@\n ECHO_T = @ECHO_T@\n EGREP = @EGREP@\n EXEEXT = @EXEEXT@\n+FFI_EXEC_TRAMPOLINE_TABLE = @FFI_EXEC_TRAMPOLINE_TABLE@\n FGREP = @FGREP@\n GREP = @GREP@\n HAVE_LONG_DOUBLE = @HAVE_LONG_DOUBLE@\n@@ -125,6 +160,7 @@ LN_S = @LN_S@\n LTLIBOBJS = @LTLIBOBJS@\n MAINT = @MAINT@\n MAKEINFO = @MAKEINFO@\n+MANIFEST_TOOL = @MANIFEST_TOOL@\n MKDIR_P = @MKDIR_P@\n NM = @NM@\n NMEDIT = @NMEDIT@\n@@ -140,6 +176,7 @@ PACKAGE_TARNAME = @PACKAGE_TARNAME@\n PACKAGE_URL = @PACKAGE_URL@\n PACKAGE_VERSION = @PACKAGE_VERSION@\n PATH_SEPARATOR = @PATH_SEPARATOR@\n+PRTDIAG = @PRTDIAG@\n RANLIB = @RANLIB@\n SED = @SED@\n SET_MAKE = @SET_MAKE@\n@@ -152,13 +189,15 @@ abs_builddir = @abs_builddir@\n abs_srcdir = @abs_srcdir@\n abs_top_builddir = @abs_top_builddir@\n abs_top_srcdir = @abs_top_srcdir@\n+ac_ct_AR = @ac_ct_AR@\n ac_ct_CC = @ac_ct_CC@\n ac_ct_DUMPBIN = @ac_ct_DUMPBIN@\n am__include = @am__include@\n am__leading_dot = @am__leading_dot@\n am__quote = @am__quote@\n am__tar = @am__tar@\n am__untar = @am__untar@\n+ax_enable_builddir_sed = @ax_enable_builddir_sed@\n bindir = @bindir@\n build = @build@\n build_alias = @build_alias@\n@@ -186,7 +225,6 @@ localedir = @localedir@\n localstatedir = @localstatedir@\n mandir = @mandir@\n mkdir_p = @mkdir_p@\n-multi_basedir = @multi_basedir@\n oldincludedir = @oldincludedir@\n pdfdir = @pdfdir@\n prefix = @prefix@\n@@ -195,6 +233,7 @@ psdir = @psdir@\n sbindir = @sbindir@\n sharedstatedir = @sharedstatedir@\n srcdir = @srcdir@\n+sys_symbol_underscore = @sys_symbol_underscore@\n sysconfdir = @sysconfdir@\n target = @target@\n target_alias = @target_alias@\n@@ -207,8 +246,8 @@ top_build_prefix = @top_build_prefix@\n top_builddir = @top_builddir@\n top_srcdir = @top_srcdir@\n AUTOMAKE_OPTIONS = foreign\n-EXTRA_DIST = ffi.3 ffi_call.3 ffi_prep_cif.3\n-man_MANS = ffi.3 ffi_call.3 ffi_prep_cif.3\n+EXTRA_DIST = ffi.3 ffi_call.3 ffi_prep_cif.3 ffi_prep_cif_var.3\n+man_MANS = ffi.3 ffi_call.3 ffi_prep_cif.3 ffi_prep_cif_var.3\n all: all-am\n \n .SUFFIXES:\n@@ -250,11 +289,18 @@ clean-libtool:\n \t-rm -rf .libs _libs\n install-man3: $(man_MANS)\n \t@$(NORMAL_INSTALL)\n-\ttest -z \"$(man3dir)\" || $(MKDIR_P) \"$(DESTDIR)$(man3dir)\"\n-\t@list=''; test -n \"$(man3dir)\" || exit 0; \\\n-\t{ for i in $$list; do echo \"$$i\"; done; \\\n-\tl2='$(man_MANS)'; for i in $$l2; do echo \"$$i\"; done | \\\n-\t  sed -n '/\\.3[a-z]*$$/p'; \\\n+\t@list1=''; \\\n+\tlist2='$(man_MANS)'; \\\n+\ttest -n \"$(man3dir)\" \\\n+\t  && test -n \"`echo $$list1$$list2`\" \\\n+\t  || exit 0; \\\n+\techo \" $(MKDIR_P) '$(DESTDIR)$(man3dir)'\"; \\\n+\t$(MKDIR_P) \"$(DESTDIR)$(man3dir)\" || exit 1; \\\n+\t{ for i in $$list1; do echo \"$$i\"; done;  \\\n+\tif test -n \"$$list2\"; then \\\n+\t  for i in $$list2; do echo \"$$i\"; done \\\n+\t    | sed -n '/\\.3[a-z]*$$/p'; \\\n+\tfi; \\\n \t} | while read p; do \\\n \t  if test -f $$p; then d=; else d=\"$(srcdir)/\"; fi; \\\n \t  echo \"$$d$$p\"; echo \"$$p\"; \\\n@@ -283,9 +329,7 @@ uninstall-man3:\n \t  sed -n '/\\.3[a-z]*$$/p'; \\\n \t} | sed -e 's,.*/,,;h;s,.*\\.,,;s,^[^3][0-9a-z]*$$,3,;x' \\\n \t      -e 's,\\.[0-9a-z]*$$,,;$(transform);G;s,\\n,.,'`; \\\n-\ttest -z \"$$files\" || { \\\n-\t  echo \" ( cd '$(DESTDIR)$(man3dir)' && rm -f\" $$files \")\"; \\\n-\t  cd \"$(DESTDIR)$(man3dir)\" && rm -f $$files; }\n+\tdir='$(DESTDIR)$(man3dir)'; $(am__uninstall_files_from_dir)\n tags: TAGS\n TAGS:\n \n@@ -353,10 +397,15 @@ install-am: all-am\n \n installcheck: installcheck-am\n install-strip:\n-\t$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" \\\n-\t  install_sh_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" INSTALL_STRIP_FLAG=-s \\\n-\t  `test -z '$(STRIP)' || \\\n-\t    echo \"INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'\"` install\n+\tif test -z '$(STRIP)'; then \\\n+\t  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" \\\n+\t    install_sh_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" INSTALL_STRIP_FLAG=-s \\\n+\t      install; \\\n+\telse \\\n+\t  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" \\\n+\t    install_sh_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" INSTALL_STRIP_FLAG=-s \\\n+\t    \"INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'\" install; \\\n+\tfi\n mostlyclean-generic:\n \n clean-generic:"}, {"sha": "140566569511a05be1ff72af00000389123b0a6f", "filename": "libffi/src/aarch64/ffi.c", "status": "added", "additions": 1076, "deletions": 0, "changes": 1076, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Fsrc%2Faarch64%2Fffi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Fsrc%2Faarch64%2Fffi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Faarch64%2Fffi.c?ref=b4b575ce7854f4a49de8de93f38b7639e01b040b", "patch": "@@ -0,0 +1,1076 @@\n+/* Copyright (c) 2009, 2010, 2011, 2012 ARM Ltd.\n+\n+Permission is hereby granted, free of charge, to any person obtaining\n+a copy of this software and associated documentation files (the\n+``Software''), to deal in the Software without restriction, including\n+without limitation the rights to use, copy, modify, merge, publish,\n+distribute, sublicense, and/or sell copies of the Software, and to\n+permit persons to whom the Software is furnished to do so, subject to\n+the following conditions:\n+\n+The above copyright notice and this permission notice shall be\n+included in all copies or substantial portions of the Software.\n+\n+THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,\n+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n+IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n+CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n+TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n+SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */\n+\n+#include <stdio.h>\n+\n+#include <ffi.h>\n+#include <ffi_common.h>\n+\n+#include <stdlib.h>\n+\n+/* Stack alignment requirement in bytes */\n+#define AARCH64_STACK_ALIGN 16\n+\n+#define N_X_ARG_REG 8\n+#define N_V_ARG_REG 8\n+\n+#define AARCH64_FFI_WITH_V (1 << AARCH64_FFI_WITH_V_BIT)\n+\n+union _d\n+{\n+  UINT64 d;\n+  UINT32 s[2];\n+};\n+\n+struct call_context\n+{\n+  UINT64 x [AARCH64_N_XREG];\n+  struct\n+  {\n+    union _d d[2];\n+  } v [AARCH64_N_VREG];\n+};\n+\n+static void *\n+get_x_addr (struct call_context *context, unsigned n)\n+{\n+  return &context->x[n];\n+}\n+\n+static void *\n+get_s_addr (struct call_context *context, unsigned n)\n+{\n+#if defined __AARCH64EB__\n+  return &context->v[n].d[1].s[1];\n+#else\n+  return &context->v[n].d[0].s[0];\n+#endif\n+}\n+\n+static void *\n+get_d_addr (struct call_context *context, unsigned n)\n+{\n+#if defined __AARCH64EB__\n+  return &context->v[n].d[1];\n+#else\n+  return &context->v[n].d[0];\n+#endif\n+}\n+\n+static void *\n+get_v_addr (struct call_context *context, unsigned n)\n+{\n+  return &context->v[n];\n+}\n+\n+/* Return the memory location at which a basic type would reside\n+   were it to have been stored in register n.  */\n+\n+static void *\n+get_basic_type_addr (unsigned short type, struct call_context *context,\n+\t\t     unsigned n)\n+{\n+  switch (type)\n+    {\n+    case FFI_TYPE_FLOAT:\n+      return get_s_addr (context, n);\n+    case FFI_TYPE_DOUBLE:\n+      return get_d_addr (context, n);\n+    case FFI_TYPE_LONGDOUBLE:\n+      return get_v_addr (context, n);\n+    case FFI_TYPE_UINT8:\n+    case FFI_TYPE_SINT8:\n+    case FFI_TYPE_UINT16:\n+    case FFI_TYPE_SINT16:\n+    case FFI_TYPE_UINT32:\n+    case FFI_TYPE_SINT32:\n+    case FFI_TYPE_INT:\n+    case FFI_TYPE_POINTER:\n+    case FFI_TYPE_UINT64:\n+    case FFI_TYPE_SINT64:\n+      return get_x_addr (context, n);\n+    default:\n+      FFI_ASSERT (0);\n+      return NULL;\n+    }\n+}\n+\n+/* Return the alignment width for each of the basic types.  */\n+\n+static size_t\n+get_basic_type_alignment (unsigned short type)\n+{\n+  switch (type)\n+    {\n+    case FFI_TYPE_FLOAT:\n+    case FFI_TYPE_DOUBLE:\n+      return sizeof (UINT64);\n+    case FFI_TYPE_LONGDOUBLE:\n+      return sizeof (long double);\n+    case FFI_TYPE_UINT8:\n+    case FFI_TYPE_SINT8:\n+    case FFI_TYPE_UINT16:\n+    case FFI_TYPE_SINT16:\n+    case FFI_TYPE_UINT32:\n+    case FFI_TYPE_INT:\n+    case FFI_TYPE_SINT32:\n+    case FFI_TYPE_POINTER:\n+    case FFI_TYPE_UINT64:\n+    case FFI_TYPE_SINT64:\n+      return sizeof (UINT64);\n+\n+    default:\n+      FFI_ASSERT (0);\n+      return 0;\n+    }\n+}\n+\n+/* Return the size in bytes for each of the basic types.  */\n+\n+static size_t\n+get_basic_type_size (unsigned short type)\n+{\n+  switch (type)\n+    {\n+    case FFI_TYPE_FLOAT:\n+      return sizeof (UINT32);\n+    case FFI_TYPE_DOUBLE:\n+      return sizeof (UINT64);\n+    case FFI_TYPE_LONGDOUBLE:\n+      return sizeof (long double);\n+    case FFI_TYPE_UINT8:\n+      return sizeof (UINT8);\n+    case FFI_TYPE_SINT8:\n+      return sizeof (SINT8);\n+    case FFI_TYPE_UINT16:\n+      return sizeof (UINT16);\n+    case FFI_TYPE_SINT16:\n+      return sizeof (SINT16);\n+    case FFI_TYPE_UINT32:\n+      return sizeof (UINT32);\n+    case FFI_TYPE_INT:\n+    case FFI_TYPE_SINT32:\n+      return sizeof (SINT32);\n+    case FFI_TYPE_POINTER:\n+    case FFI_TYPE_UINT64:\n+      return sizeof (UINT64);\n+    case FFI_TYPE_SINT64:\n+      return sizeof (SINT64);\n+\n+    default:\n+      FFI_ASSERT (0);\n+      return 0;\n+    }\n+}\n+\n+extern void\n+ffi_call_SYSV (unsigned (*)(struct call_context *context, unsigned char *,\n+\t\t\t    extended_cif *),\n+               struct call_context *context,\n+               extended_cif *,\n+               unsigned,\n+               void (*fn)(void));\n+\n+extern void\n+ffi_closure_SYSV (ffi_closure *);\n+\n+/* Test for an FFI floating point representation.  */\n+\n+static unsigned\n+is_floating_type (unsigned short type)\n+{\n+  return (type == FFI_TYPE_FLOAT || type == FFI_TYPE_DOUBLE\n+\t  || type == FFI_TYPE_LONGDOUBLE);\n+}\n+\n+/* Test for a homogeneous structure.  */\n+\n+static unsigned short\n+get_homogeneous_type (ffi_type *ty)\n+{\n+  if (ty->type == FFI_TYPE_STRUCT && ty->elements)\n+    {\n+      unsigned i;\n+      unsigned short candidate_type\n+\t= get_homogeneous_type (ty->elements[0]);\n+      for (i =1; ty->elements[i]; i++)\n+\t{\n+\t  unsigned short iteration_type = 0;\n+\t  /* If we have a nested struct, we must find its homogeneous type.\n+\t     If that fits with our candidate type, we are still\n+\t     homogeneous.  */\n+\t  if (ty->elements[i]->type == FFI_TYPE_STRUCT\n+\t      && ty->elements[i]->elements)\n+\t    {\n+\t      iteration_type = get_homogeneous_type (ty->elements[i]);\n+\t    }\n+\t  else\n+\t    {\n+\t      iteration_type = ty->elements[i]->type;\n+\t    }\n+\n+\t  /* If we are not homogeneous, return FFI_TYPE_STRUCT.  */\n+\t  if (candidate_type != iteration_type)\n+\t    return FFI_TYPE_STRUCT;\n+\t}\n+      return candidate_type;\n+    }\n+\n+  /* Base case, we have no more levels of nesting, so we\n+     are a basic type, and so, trivially homogeneous in that type.  */\n+  return ty->type;\n+}\n+\n+/* Determine the number of elements within a STRUCT.\n+\n+   Note, we must handle nested structs.\n+\n+   If ty is not a STRUCT this function will return 0.  */\n+\n+static unsigned\n+element_count (ffi_type *ty)\n+{\n+  if (ty->type == FFI_TYPE_STRUCT && ty->elements)\n+    {\n+      unsigned n;\n+      unsigned elems = 0;\n+      for (n = 0; ty->elements[n]; n++)\n+\t{\n+\t  if (ty->elements[n]->type == FFI_TYPE_STRUCT\n+\t      && ty->elements[n]->elements)\n+\t    elems += element_count (ty->elements[n]);\n+\t  else\n+\t    elems++;\n+\t}\n+      return elems;\n+    }\n+  return 0;\n+}\n+\n+/* Test for a homogeneous floating point aggregate.\n+\n+   A homogeneous floating point aggregate is a homogeneous aggregate of\n+   a half- single- or double- precision floating point type with one\n+   to four elements.  Note that this includes nested structs of the\n+   basic type.  */\n+\n+static int\n+is_hfa (ffi_type *ty)\n+{\n+  if (ty->type == FFI_TYPE_STRUCT\n+      && ty->elements[0]\n+      && is_floating_type (get_homogeneous_type (ty)))\n+    {\n+      unsigned n = element_count (ty);\n+      return n >= 1 && n <= 4;\n+    }\n+  return 0;\n+}\n+\n+/* Test if an ffi_type is a candidate for passing in a register.\n+\n+   This test does not check that sufficient registers of the\n+   appropriate class are actually available, merely that IFF\n+   sufficient registers are available then the argument will be passed\n+   in register(s).\n+\n+   Note that an ffi_type that is deemed to be a register candidate\n+   will always be returned in registers.\n+\n+   Returns 1 if a register candidate else 0.  */\n+\n+static int\n+is_register_candidate (ffi_type *ty)\n+{\n+  switch (ty->type)\n+    {\n+    case FFI_TYPE_VOID:\n+    case FFI_TYPE_FLOAT:\n+    case FFI_TYPE_DOUBLE:\n+    case FFI_TYPE_LONGDOUBLE:\n+    case FFI_TYPE_UINT8:\n+    case FFI_TYPE_UINT16:\n+    case FFI_TYPE_UINT32:\n+    case FFI_TYPE_UINT64:\n+    case FFI_TYPE_POINTER:\n+    case FFI_TYPE_SINT8:\n+    case FFI_TYPE_SINT16:\n+    case FFI_TYPE_SINT32:\n+    case FFI_TYPE_INT:\n+    case FFI_TYPE_SINT64:\n+      return 1;\n+\n+    case FFI_TYPE_STRUCT:\n+      if (is_hfa (ty))\n+        {\n+          return 1;\n+        }\n+      else if (ty->size > 16)\n+        {\n+          /* Too large. Will be replaced with a pointer to memory. The\n+             pointer MAY be passed in a register, but the value will\n+             not. This test specifically fails since the argument will\n+             never be passed by value in registers. */\n+          return 0;\n+        }\n+      else\n+        {\n+          /* Might be passed in registers depending on the number of\n+             registers required. */\n+          return (ty->size + 7) / 8 < N_X_ARG_REG;\n+        }\n+      break;\n+\n+    default:\n+      FFI_ASSERT (0);\n+      break;\n+    }\n+\n+  return 0;\n+}\n+\n+/* Test if an ffi_type argument or result is a candidate for a vector\n+   register.  */\n+\n+static int\n+is_v_register_candidate (ffi_type *ty)\n+{\n+  return is_floating_type (ty->type)\n+\t   || (ty->type == FFI_TYPE_STRUCT && is_hfa (ty));\n+}\n+\n+/* Representation of the procedure call argument marshalling\n+   state.\n+\n+   The terse state variable names match the names used in the AARCH64\n+   PCS. */\n+\n+struct arg_state\n+{\n+  unsigned ngrn;                /* Next general-purpose register number. */\n+  unsigned nsrn;                /* Next vector register number. */\n+  unsigned nsaa;                /* Next stack offset. */\n+};\n+\n+/* Initialize a procedure call argument marshalling state.  */\n+static void\n+arg_init (struct arg_state *state, unsigned call_frame_size)\n+{\n+  state->ngrn = 0;\n+  state->nsrn = 0;\n+  state->nsaa = 0;\n+}\n+\n+/* Return the number of available consecutive core argument\n+   registers.  */\n+\n+static unsigned\n+available_x (struct arg_state *state)\n+{\n+  return N_X_ARG_REG - state->ngrn;\n+}\n+\n+/* Return the number of available consecutive vector argument\n+   registers.  */\n+\n+static unsigned\n+available_v (struct arg_state *state)\n+{\n+  return N_V_ARG_REG - state->nsrn;\n+}\n+\n+static void *\n+allocate_to_x (struct call_context *context, struct arg_state *state)\n+{\n+  FFI_ASSERT (state->ngrn < N_X_ARG_REG)\n+  return get_x_addr (context, (state->ngrn)++);\n+}\n+\n+static void *\n+allocate_to_s (struct call_context *context, struct arg_state *state)\n+{\n+  FFI_ASSERT (state->nsrn < N_V_ARG_REG)\n+  return get_s_addr (context, (state->nsrn)++);\n+}\n+\n+static void *\n+allocate_to_d (struct call_context *context, struct arg_state *state)\n+{\n+  FFI_ASSERT (state->nsrn < N_V_ARG_REG)\n+  return get_d_addr (context, (state->nsrn)++);\n+}\n+\n+static void *\n+allocate_to_v (struct call_context *context, struct arg_state *state)\n+{\n+  FFI_ASSERT (state->nsrn < N_V_ARG_REG)\n+  return get_v_addr (context, (state->nsrn)++);\n+}\n+\n+/* Allocate an aligned slot on the stack and return a pointer to it.  */\n+static void *\n+allocate_to_stack (struct arg_state *state, void *stack, unsigned alignment,\n+\t\t   unsigned size)\n+{\n+  void *allocation;\n+\n+  /* Round up the NSAA to the larger of 8 or the natural\n+     alignment of the argument's type.  */\n+  state->nsaa = ALIGN (state->nsaa, alignment);\n+  state->nsaa = ALIGN (state->nsaa, alignment);\n+  state->nsaa = ALIGN (state->nsaa, 8);\n+\n+  allocation = stack + state->nsaa;\n+\n+  state->nsaa += size;\n+  return allocation;\n+}\n+\n+static void\n+copy_basic_type (void *dest, void *source, unsigned short type)\n+{\n+  /* This is neccessary to ensure that basic types are copied\n+     sign extended to 64-bits as libffi expects.  */\n+  switch (type)\n+    {\n+    case FFI_TYPE_FLOAT:\n+      *(float *) dest = *(float *) source;\n+      break;\n+    case FFI_TYPE_DOUBLE:\n+      *(double *) dest = *(double *) source;\n+      break;\n+    case FFI_TYPE_LONGDOUBLE:\n+      *(long double *) dest = *(long double *) source;\n+      break;\n+    case FFI_TYPE_UINT8:\n+      *(ffi_arg *) dest = *(UINT8 *) source;\n+      break;\n+    case FFI_TYPE_SINT8:\n+      *(ffi_sarg *) dest = *(SINT8 *) source;\n+      break;\n+    case FFI_TYPE_UINT16:\n+      *(ffi_arg *) dest = *(UINT16 *) source;\n+      break;\n+    case FFI_TYPE_SINT16:\n+      *(ffi_sarg *) dest = *(SINT16 *) source;\n+      break;\n+    case FFI_TYPE_UINT32:\n+      *(ffi_arg *) dest = *(UINT32 *) source;\n+      break;\n+    case FFI_TYPE_INT:\n+    case FFI_TYPE_SINT32:\n+      *(ffi_sarg *) dest = *(SINT32 *) source;\n+      break;\n+    case FFI_TYPE_POINTER:\n+    case FFI_TYPE_UINT64:\n+      *(ffi_arg *) dest = *(UINT64 *) source;\n+      break;\n+    case FFI_TYPE_SINT64:\n+      *(ffi_sarg *) dest = *(SINT64 *) source;\n+      break;\n+\n+    default:\n+      FFI_ASSERT (0);\n+    }\n+}\n+\n+static void\n+copy_hfa_to_reg_or_stack (void *memory,\n+\t\t\t  ffi_type *ty,\n+\t\t\t  struct call_context *context,\n+\t\t\t  unsigned char *stack,\n+\t\t\t  struct arg_state *state)\n+{\n+  unsigned elems = element_count (ty);\n+  if (available_v (state) < elems)\n+    {\n+      /* There are insufficient V registers. Further V register allocations\n+\t are prevented, the NSAA is adjusted (by allocate_to_stack ())\n+\t and the argument is copied to memory at the adjusted NSAA.  */\n+      state->nsrn = N_V_ARG_REG;\n+      memcpy (allocate_to_stack (state, stack, ty->alignment, ty->size),\n+\t      memory,\n+\t      ty->size);\n+    }\n+  else\n+    {\n+      int i;\n+      unsigned short type = get_homogeneous_type (ty);\n+      unsigned elems = element_count (ty);\n+      for (i = 0; i < elems; i++)\n+\t{\n+\t  void *reg = allocate_to_v (context, state);\n+\t  copy_basic_type (reg, memory, type);\n+\t  memory += get_basic_type_size (type);\n+\t}\n+    }\n+}\n+\n+/* Either allocate an appropriate register for the argument type, or if\n+   none are available, allocate a stack slot and return a pointer\n+   to the allocated space.  */\n+\n+static void *\n+allocate_to_register_or_stack (struct call_context *context,\n+\t\t\t       unsigned char *stack,\n+\t\t\t       struct arg_state *state,\n+\t\t\t       unsigned short type)\n+{\n+  size_t alignment = get_basic_type_alignment (type);\n+  size_t size = alignment;\n+  switch (type)\n+    {\n+    case FFI_TYPE_FLOAT:\n+      /* This is the only case for which the allocated stack size\n+\t should not match the alignment of the type.  */\n+      size = sizeof (UINT32);\n+      /* Fall through.  */\n+    case FFI_TYPE_DOUBLE:\n+      if (state->nsrn < N_V_ARG_REG)\n+\treturn allocate_to_d (context, state);\n+      state->nsrn = N_V_ARG_REG;\n+      break;\n+    case FFI_TYPE_LONGDOUBLE:\n+      if (state->nsrn < N_V_ARG_REG)\n+\treturn allocate_to_v (context, state);\n+      state->nsrn = N_V_ARG_REG;\n+      break;\n+    case FFI_TYPE_UINT8:\n+    case FFI_TYPE_SINT8:\n+    case FFI_TYPE_UINT16:\n+    case FFI_TYPE_SINT16:\n+    case FFI_TYPE_UINT32:\n+    case FFI_TYPE_SINT32:\n+    case FFI_TYPE_INT:\n+    case FFI_TYPE_POINTER:\n+    case FFI_TYPE_UINT64:\n+    case FFI_TYPE_SINT64:\n+      if (state->ngrn < N_X_ARG_REG)\n+\treturn allocate_to_x (context, state);\n+      state->ngrn = N_X_ARG_REG;\n+      break;\n+    default:\n+      FFI_ASSERT (0);\n+    }\n+\n+    return allocate_to_stack (state, stack, alignment, size);\n+}\n+\n+/* Copy a value to an appropriate register, or if none are\n+   available, to the stack.  */\n+\n+static void\n+copy_to_register_or_stack (struct call_context *context,\n+\t\t\t   unsigned char *stack,\n+\t\t\t   struct arg_state *state,\n+\t\t\t   void *value,\n+\t\t\t   unsigned short type)\n+{\n+  copy_basic_type (\n+\t  allocate_to_register_or_stack (context, stack, state, type),\n+\t  value,\n+\t  type);\n+}\n+\n+/* Marshall the arguments from FFI representation to procedure call\n+   context and stack.  */\n+\n+static unsigned\n+aarch64_prep_args (struct call_context *context, unsigned char *stack,\n+\t\t   extended_cif *ecif)\n+{\n+  int i;\n+  struct arg_state state;\n+\n+  arg_init (&state, ALIGN(ecif->cif->bytes, 16));\n+\n+  for (i = 0; i < ecif->cif->nargs; i++)\n+    {\n+      ffi_type *ty = ecif->cif->arg_types[i];\n+      switch (ty->type)\n+\t{\n+\tcase FFI_TYPE_VOID:\n+\t  FFI_ASSERT (0);\n+\t  break;\n+\n+\t/* If the argument is a basic type the argument is allocated to an\n+\t   appropriate register, or if none are available, to the stack.  */\n+\tcase FFI_TYPE_FLOAT:\n+\tcase FFI_TYPE_DOUBLE:\n+\tcase FFI_TYPE_LONGDOUBLE:\n+\tcase FFI_TYPE_UINT8:\n+\tcase FFI_TYPE_SINT8:\n+\tcase FFI_TYPE_UINT16:\n+\tcase FFI_TYPE_SINT16:\n+\tcase FFI_TYPE_UINT32:\n+\tcase FFI_TYPE_INT:\n+\tcase FFI_TYPE_SINT32:\n+\tcase FFI_TYPE_POINTER:\n+\tcase FFI_TYPE_UINT64:\n+\tcase FFI_TYPE_SINT64:\n+\t  copy_to_register_or_stack (context, stack, &state,\n+\t\t\t\t     ecif->avalue[i], ty->type);\n+\t  break;\n+\n+\tcase FFI_TYPE_STRUCT:\n+\t  if (is_hfa (ty))\n+\t    {\n+\t      copy_hfa_to_reg_or_stack (ecif->avalue[i], ty, context,\n+\t\t\t\t\tstack, &state);\n+\t    }\n+\t  else if (ty->size > 16)\n+\t    {\n+\t      /* If the argument is a composite type that is larger than 16\n+\t\t bytes, then the argument has been copied to memory, and\n+\t\t the argument is replaced by a pointer to the copy.  */\n+\n+\t      copy_to_register_or_stack (context, stack, &state,\n+\t\t\t\t\t &(ecif->avalue[i]), FFI_TYPE_POINTER);\n+\t    }\n+\t  else if (available_x (&state) >= (ty->size + 7) / 8)\n+\t    {\n+\t      /* If the argument is a composite type and the size in\n+\t\t double-words is not more than the number of available\n+\t\t X registers, then the argument is copied into consecutive\n+\t\t X registers.  */\n+\t      int j;\n+\t      for (j = 0; j < (ty->size + 7) / 8; j++)\n+\t\t{\n+\t\t  memcpy (allocate_to_x (context, &state),\n+\t\t\t  &(((UINT64 *) ecif->avalue[i])[j]),\n+\t\t\t  sizeof (UINT64));\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      /* Otherwise, there are insufficient X registers. Further X\n+\t\t register allocations are prevented, the NSAA is adjusted\n+\t\t (by allocate_to_stack ()) and the argument is copied to\n+\t\t memory at the adjusted NSAA.  */\n+\t      state.ngrn = N_X_ARG_REG;\n+\n+\t      memcpy (allocate_to_stack (&state, stack, ty->alignment,\n+\t\t\t\t\t ty->size), ecif->avalue + i, ty->size);\n+\t    }\n+\t  break;\n+\n+\tdefault:\n+\t  FFI_ASSERT (0);\n+\t  break;\n+\t}\n+    }\n+\n+  return ecif->cif->aarch64_flags;\n+}\n+\n+ffi_status\n+ffi_prep_cif_machdep (ffi_cif *cif)\n+{\n+  /* Round the stack up to a multiple of the stack alignment requirement. */\n+  cif->bytes =\n+    (cif->bytes + (AARCH64_STACK_ALIGN - 1)) & ~ (AARCH64_STACK_ALIGN - 1);\n+\n+  /* Initialize our flags. We are interested if this CIF will touch a\n+     vector register, if so we will enable context save and load to\n+     those registers, otherwise not. This is intended to be friendly\n+     to lazy float context switching in the kernel.  */\n+  cif->aarch64_flags = 0;\n+\n+  if (is_v_register_candidate (cif->rtype))\n+    {\n+      cif->aarch64_flags |= AARCH64_FFI_WITH_V;\n+    }\n+  else\n+    {\n+      int i;\n+      for (i = 0; i < cif->nargs; i++)\n+        if (is_v_register_candidate (cif->arg_types[i]))\n+          {\n+            cif->aarch64_flags |= AARCH64_FFI_WITH_V;\n+            break;\n+          }\n+    }\n+\n+  return FFI_OK;\n+}\n+\n+/* Call a function with the provided arguments and capture the return\n+   value.  */\n+void\n+ffi_call (ffi_cif *cif, void (*fn)(void), void *rvalue, void **avalue)\n+{\n+  extended_cif ecif;\n+\n+  ecif.cif = cif;\n+  ecif.avalue = avalue;\n+  ecif.rvalue = rvalue;\n+\n+  switch (cif->abi)\n+    {\n+    case FFI_SYSV:\n+      {\n+        struct call_context context;\n+\tunsigned stack_bytes;\n+\n+\t/* Figure out the total amount of stack space we need, the\n+\t   above call frame space needs to be 16 bytes aligned to\n+\t   ensure correct alignment of the first object inserted in\n+\t   that space hence the ALIGN applied to cif->bytes.*/\n+\tstack_bytes = ALIGN(cif->bytes, 16);\n+\n+\tmemset (&context, 0, sizeof (context));\n+        if (is_register_candidate (cif->rtype))\n+          {\n+            ffi_call_SYSV (aarch64_prep_args, &context, &ecif, stack_bytes, fn);\n+            switch (cif->rtype->type)\n+              {\n+              case FFI_TYPE_VOID:\n+              case FFI_TYPE_FLOAT:\n+              case FFI_TYPE_DOUBLE:\n+              case FFI_TYPE_LONGDOUBLE:\n+              case FFI_TYPE_UINT8:\n+              case FFI_TYPE_SINT8:\n+              case FFI_TYPE_UINT16:\n+              case FFI_TYPE_SINT16:\n+              case FFI_TYPE_UINT32:\n+              case FFI_TYPE_SINT32:\n+              case FFI_TYPE_POINTER:\n+              case FFI_TYPE_UINT64:\n+              case FFI_TYPE_INT:\n+              case FFI_TYPE_SINT64:\n+\t\t{\n+\t\t  void *addr = get_basic_type_addr (cif->rtype->type,\n+\t\t\t\t\t\t    &context, 0);\n+\t\t  copy_basic_type (rvalue, addr, cif->rtype->type);\n+\t\t  break;\n+\t\t}\n+\n+              case FFI_TYPE_STRUCT:\n+                if (is_hfa (cif->rtype))\n+\t\t  {\n+\t\t    int j;\n+\t\t    unsigned short type = get_homogeneous_type (cif->rtype);\n+\t\t    unsigned elems = element_count (cif->rtype);\n+\t\t    for (j = 0; j < elems; j++)\n+\t\t      {\n+\t\t\tvoid *reg = get_basic_type_addr (type, &context, j);\n+\t\t\tcopy_basic_type (rvalue, reg, type);\n+\t\t\trvalue += get_basic_type_size (type);\n+\t\t      }\n+\t\t  }\n+                else if ((cif->rtype->size + 7) / 8 < N_X_ARG_REG)\n+                  {\n+                    unsigned size = ALIGN (cif->rtype->size, sizeof (UINT64));\n+                    memcpy (rvalue, get_x_addr (&context, 0), size);\n+                  }\n+                else\n+                  {\n+                    FFI_ASSERT (0);\n+                  }\n+                break;\n+\n+              default:\n+                FFI_ASSERT (0);\n+                break;\n+              }\n+          }\n+        else\n+          {\n+            memcpy (get_x_addr (&context, 8), &rvalue, sizeof (UINT64));\n+            ffi_call_SYSV (aarch64_prep_args, &context, &ecif,\n+\t\t\t   stack_bytes, fn);\n+          }\n+        break;\n+      }\n+\n+    default:\n+      FFI_ASSERT (0);\n+      break;\n+    }\n+}\n+\n+static unsigned char trampoline [] =\n+{ 0x70, 0x00, 0x00, 0x58,\t/* ldr\tx16, 1f\t*/\n+  0x91, 0x00, 0x00, 0x10,\t/* adr\tx17, 2f\t*/\n+  0x00, 0x02, 0x1f, 0xd6\t/* br\tx16\t*/\n+};\n+\n+/* Build a trampoline.  */\n+\n+#define FFI_INIT_TRAMPOLINE(TRAMP,FUN,CTX,FLAGS)\t\t\t\\\n+  ({unsigned char *__tramp = (unsigned char*)(TRAMP);\t\t\t\\\n+    UINT64  __fun = (UINT64)(FUN);\t\t\t\t\t\\\n+    UINT64  __ctx = (UINT64)(CTX);\t\t\t\t\t\\\n+    UINT64  __flags = (UINT64)(FLAGS);\t\t\t\t\t\\\n+    memcpy (__tramp, trampoline, sizeof (trampoline));\t\t\t\\\n+    memcpy (__tramp + 12, &__fun, sizeof (__fun));\t\t\t\\\n+    memcpy (__tramp + 20, &__ctx, sizeof (__ctx));\t\t\t\\\n+    memcpy (__tramp + 28, &__flags, sizeof (__flags));\t\t\t\\\n+    __clear_cache(__tramp, __tramp + FFI_TRAMPOLINE_SIZE);\t\t\\\n+  })\n+\n+ffi_status\n+ffi_prep_closure_loc (ffi_closure* closure,\n+                      ffi_cif* cif,\n+                      void (*fun)(ffi_cif*,void*,void**,void*),\n+                      void *user_data,\n+                      void *codeloc)\n+{\n+  if (cif->abi != FFI_SYSV)\n+    return FFI_BAD_ABI;\n+\n+  FFI_INIT_TRAMPOLINE (&closure->tramp[0], &ffi_closure_SYSV, codeloc,\n+\t\t       cif->aarch64_flags);\n+\n+  closure->cif  = cif;\n+  closure->user_data = user_data;\n+  closure->fun  = fun;\n+\n+  return FFI_OK;\n+}\n+\n+/* Primary handler to setup and invoke a function within a closure.\n+\n+   A closure when invoked enters via the assembler wrapper\n+   ffi_closure_SYSV(). The wrapper allocates a call context on the\n+   stack, saves the interesting registers (from the perspective of\n+   the calling convention) into the context then passes control to\n+   ffi_closure_SYSV_inner() passing the saved context and a pointer to\n+   the stack at the point ffi_closure_SYSV() was invoked.\n+\n+   On the return path the assembler wrapper will reload call context\n+   regsiters.\n+\n+   ffi_closure_SYSV_inner() marshalls the call context into ffi value\n+   desriptors, invokes the wrapped function, then marshalls the return\n+   value back into the call context.  */\n+\n+void\n+ffi_closure_SYSV_inner (ffi_closure *closure, struct call_context *context,\n+\t\t\tvoid *stack)\n+{\n+  ffi_cif *cif = closure->cif;\n+  void **avalue = (void**) alloca (cif->nargs * sizeof (void*));\n+  void *rvalue = NULL;\n+  int i;\n+  struct arg_state state;\n+\n+  arg_init (&state, ALIGN(cif->bytes, 16));\n+\n+  for (i = 0; i < cif->nargs; i++)\n+    {\n+      ffi_type *ty = cif->arg_types[i];\n+\n+      switch (ty->type)\n+\t{\n+\tcase FFI_TYPE_VOID:\n+\t  FFI_ASSERT (0);\n+\t  break;\n+\n+\tcase FFI_TYPE_UINT8:\n+\tcase FFI_TYPE_SINT8:\n+\tcase FFI_TYPE_UINT16:\n+\tcase FFI_TYPE_SINT16:\n+\tcase FFI_TYPE_UINT32:\n+\tcase FFI_TYPE_SINT32:\n+\tcase FFI_TYPE_INT:\n+\tcase FFI_TYPE_POINTER:\n+\tcase FFI_TYPE_UINT64:\n+\tcase FFI_TYPE_SINT64:\n+\tcase  FFI_TYPE_FLOAT:\n+\tcase  FFI_TYPE_DOUBLE:\n+\tcase  FFI_TYPE_LONGDOUBLE:\n+\t  avalue[i] = allocate_to_register_or_stack (context, stack,\n+\t\t\t\t\t\t     &state, ty->type);\n+\t  break;\n+\n+\tcase FFI_TYPE_STRUCT:\n+\t  if (is_hfa (ty))\n+\t    {\n+\t      unsigned n = element_count (ty);\n+\t      if (available_v (&state) < n)\n+\t\t{\n+\t\t  state.nsrn = N_V_ARG_REG;\n+\t\t  avalue[i] = allocate_to_stack (&state, stack, ty->alignment,\n+\t\t\t\t\t\t ty->size);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  switch (get_homogeneous_type (ty))\n+\t\t    {\n+\t\t    case FFI_TYPE_FLOAT:\n+\t\t      {\n+\t\t\t/* Eeek! We need a pointer to the structure,\n+\t\t\t   however the homogeneous float elements are\n+\t\t\t   being passed in individual S registers,\n+\t\t\t   therefore the structure is not represented as\n+\t\t\t   a contiguous sequence of bytes in our saved\n+\t\t\t   register context. We need to fake up a copy\n+\t\t\t   of the structure layed out in memory\n+\t\t\t   correctly. The fake can be tossed once the\n+\t\t\t   closure function has returned hence alloca()\n+\t\t\t   is sufficient. */\n+\t\t\tint j;\n+\t\t\tUINT32 *p = avalue[i] = alloca (ty->size);\n+\t\t\tfor (j = 0; j < element_count (ty); j++)\n+\t\t\t  memcpy (&p[j],\n+\t\t\t\t  allocate_to_s (context, &state),\n+\t\t\t\t  sizeof (*p));\n+\t\t\tbreak;\n+\t\t      }\n+\n+\t\t    case FFI_TYPE_DOUBLE:\n+\t\t      {\n+\t\t\t/* Eeek! We need a pointer to the structure,\n+\t\t\t   however the homogeneous float elements are\n+\t\t\t   being passed in individual S registers,\n+\t\t\t   therefore the structure is not represented as\n+\t\t\t   a contiguous sequence of bytes in our saved\n+\t\t\t   register context. We need to fake up a copy\n+\t\t\t   of the structure layed out in memory\n+\t\t\t   correctly. The fake can be tossed once the\n+\t\t\t   closure function has returned hence alloca()\n+\t\t\t   is sufficient. */\n+\t\t\tint j;\n+\t\t\tUINT64 *p = avalue[i] = alloca (ty->size);\n+\t\t\tfor (j = 0; j < element_count (ty); j++)\n+\t\t\t  memcpy (&p[j],\n+\t\t\t\t  allocate_to_d (context, &state),\n+\t\t\t\t  sizeof (*p));\n+\t\t\tbreak;\n+\t\t      }\n+\n+\t\t    case FFI_TYPE_LONGDOUBLE:\n+\t\t\t  memcpy (&avalue[i],\n+\t\t\t\t  allocate_to_v (context, &state),\n+\t\t\t\t  sizeof (*avalue));\n+\t\t      break;\n+\n+\t\t    default:\n+\t\t      FFI_ASSERT (0);\n+\t\t      break;\n+\t\t    }\n+\t\t}\n+\t    }\n+\t  else if (ty->size > 16)\n+\t    {\n+\t      /* Replace Composite type of size greater than 16 with a\n+\t\t pointer.  */\n+\t      memcpy (&avalue[i],\n+\t\t      allocate_to_register_or_stack (context, stack,\n+\t\t\t\t\t\t     &state, FFI_TYPE_POINTER),\n+\t\t      sizeof (avalue[i]));\n+\t    }\n+\t  else if (available_x (&state) >= (ty->size + 7) / 8)\n+\t    {\n+\t      avalue[i] = get_x_addr (context, state.ngrn);\n+\t      state.ngrn += (ty->size + 7) / 8;\n+\t    }\n+\t  else\n+\t    {\n+\t      state.ngrn = N_X_ARG_REG;\n+\n+\t      avalue[i] = allocate_to_stack (&state, stack, ty->alignment,\n+\t\t\t\t\t     ty->size);\n+\t    }\n+\t  break;\n+\n+\tdefault:\n+\t  FFI_ASSERT (0);\n+\t  break;\n+\t}\n+    }\n+\n+  /* Figure out where the return value will be passed, either in\n+     registers or in a memory block allocated by the caller and passed\n+     in x8.  */\n+\n+  if (is_register_candidate (cif->rtype))\n+    {\n+      /* Register candidates are *always* returned in registers. */\n+\n+      /* Allocate a scratchpad for the return value, we will let the\n+         callee scrible the result into the scratch pad then move the\n+         contents into the appropriate return value location for the\n+         call convention.  */\n+      rvalue = alloca (cif->rtype->size);\n+      (closure->fun) (cif, rvalue, avalue, closure->user_data);\n+\n+      /* Copy the return value into the call context so that it is returned\n+         as expected to our caller.  */\n+      switch (cif->rtype->type)\n+        {\n+        case FFI_TYPE_VOID:\n+          break;\n+\n+        case FFI_TYPE_UINT8:\n+        case FFI_TYPE_UINT16:\n+        case FFI_TYPE_UINT32:\n+        case FFI_TYPE_POINTER:\n+        case FFI_TYPE_UINT64:\n+        case FFI_TYPE_SINT8:\n+        case FFI_TYPE_SINT16:\n+        case FFI_TYPE_INT:\n+        case FFI_TYPE_SINT32:\n+        case FFI_TYPE_SINT64:\n+        case FFI_TYPE_FLOAT:\n+        case FFI_TYPE_DOUBLE:\n+        case FFI_TYPE_LONGDOUBLE:\n+\t  {\n+\t    void *addr = get_basic_type_addr (cif->rtype->type, context, 0);\n+\t    copy_basic_type (addr, rvalue, cif->rtype->type);\n+            break;\n+\t  }\n+        case FFI_TYPE_STRUCT:\n+          if (is_hfa (cif->rtype))\n+\t    {\n+\t      int i;\n+\t      unsigned short type = get_homogeneous_type (cif->rtype);\n+\t      unsigned elems = element_count (cif->rtype);\n+\t      for (i = 0; i < elems; i++)\n+\t\t{\n+\t\t  void *reg = get_basic_type_addr (type, context, i);\n+\t\t  copy_basic_type (reg, rvalue, type);\n+\t\t  rvalue += get_basic_type_size (type);\n+\t\t}\n+\t    }\n+          else if ((cif->rtype->size + 7) / 8 < N_X_ARG_REG)\n+            {\n+              unsigned size = ALIGN (cif->rtype->size, sizeof (UINT64)) ;\n+              memcpy (get_x_addr (context, 0), rvalue, size);\n+            }\n+          else\n+            {\n+              FFI_ASSERT (0);\n+            }\n+          break;\n+        default:\n+          FFI_ASSERT (0);\n+          break;\n+        }\n+    }\n+  else\n+    {\n+      memcpy (&rvalue, get_x_addr (context, 8), sizeof (UINT64));\n+      (closure->fun) (cif, rvalue, avalue, closure->user_data);\n+    }\n+}\n+"}, {"sha": "6f1a348f5322f50e3bbf0c390f5671c250d59e3a", "filename": "libffi/src/aarch64/ffitarget.h", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Fsrc%2Faarch64%2Fffitarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Fsrc%2Faarch64%2Fffitarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Faarch64%2Fffitarget.h?ref=b4b575ce7854f4a49de8de93f38b7639e01b040b", "patch": "@@ -0,0 +1,59 @@\n+/* Copyright (c) 2009, 2010, 2011, 2012 ARM Ltd.\n+\n+Permission is hereby granted, free of charge, to any person obtaining\n+a copy of this software and associated documentation files (the\n+``Software''), to deal in the Software without restriction, including\n+without limitation the rights to use, copy, modify, merge, publish,\n+distribute, sublicense, and/or sell copies of the Software, and to\n+permit persons to whom the Software is furnished to do so, subject to\n+the following conditions:\n+\n+The above copyright notice and this permission notice shall be\n+included in all copies or substantial portions of the Software.\n+\n+THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,\n+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n+IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n+CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n+TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n+SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */\n+\n+#ifndef LIBFFI_TARGET_H\n+#define LIBFFI_TARGET_H\n+\n+#ifndef LIBFFI_H\n+#error \"Please do not include ffitarget.h directly into your source.  Use ffi.h instead.\"\n+#endif\n+\n+#ifndef LIBFFI_ASM\n+typedef unsigned long ffi_arg;\n+typedef signed long ffi_sarg;\n+\n+typedef enum ffi_abi\n+  {\n+    FFI_FIRST_ABI = 0,\n+    FFI_SYSV,\n+    FFI_LAST_ABI,\n+    FFI_DEFAULT_ABI = FFI_SYSV\n+  } ffi_abi;\n+#endif\n+\n+/* ---- Definitions for closures ----------------------------------------- */\n+\n+#define FFI_CLOSURES 1\n+#define FFI_TRAMPOLINE_SIZE 36\n+#define FFI_NATIVE_RAW_API 0\n+\n+/* ---- Internal ---- */\n+\n+\n+#define FFI_EXTRA_CIF_FIELDS unsigned aarch64_flags\n+\n+#define AARCH64_FFI_WITH_V_BIT 0\n+\n+#define AARCH64_N_XREG 32\n+#define AARCH64_N_VREG 32\n+#define AARCH64_CALL_CONTEXT_SIZE (AARCH64_N_XREG * 8 + AARCH64_N_VREG * 16)\n+\n+#endif"}, {"sha": "b8cd421a8a5c913a00faaf10362ad1d35b9f8f2d", "filename": "libffi/src/aarch64/sysv.S", "status": "added", "additions": 307, "deletions": 0, "changes": 307, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Fsrc%2Faarch64%2Fsysv.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Fsrc%2Faarch64%2Fsysv.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Faarch64%2Fsysv.S?ref=b4b575ce7854f4a49de8de93f38b7639e01b040b", "patch": "@@ -0,0 +1,307 @@\n+/* Copyright (c) 2009, 2010, 2011, 2012 ARM Ltd.\n+\n+Permission is hereby granted, free of charge, to any person obtaining\n+a copy of this software and associated documentation files (the\n+``Software''), to deal in the Software without restriction, including\n+without limitation the rights to use, copy, modify, merge, publish,\n+distribute, sublicense, and/or sell copies of the Software, and to\n+permit persons to whom the Software is furnished to do so, subject to\n+the following conditions:\n+\n+The above copyright notice and this permission notice shall be\n+included in all copies or substantial portions of the Software.\n+\n+THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,\n+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n+IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n+CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n+TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n+SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */\n+\n+#define LIBFFI_ASM\n+#include <fficonfig.h>\n+#include <ffi.h>\n+\n+#define cfi_adjust_cfa_offset(off)\t.cfi_adjust_cfa_offset off\n+#define cfi_rel_offset(reg, off)\t.cfi_rel_offset reg, off\n+#define cfi_restore(reg)\t\t.cfi_restore reg\n+#define cfi_def_cfa_register(reg)\t.cfi_def_cfa_register reg\n+\n+        .text\n+        .globl ffi_call_SYSV\n+        .type ffi_call_SYSV, #function\n+\n+/* ffi_call_SYSV()\n+\n+   Create a stack frame, setup an argument context, call the callee\n+   and extract the result.\n+\n+   The maximum required argument stack size is provided,\n+   ffi_call_SYSV() allocates that stack space then calls the\n+   prepare_fn to populate register context and stack.  The\n+   argument passing registers are loaded from the register\n+   context and the callee called, on return the register passing\n+   register are saved back to the context.  Our caller will\n+   extract the return value from the final state of the saved\n+   register context.\n+\n+   Prototype:\n+\n+   extern unsigned\n+   ffi_call_SYSV (void (*)(struct call_context *context, unsigned char *,\n+\t\t\t   extended_cif *),\n+                  struct call_context *context,\n+                  extended_cif *,\n+                  unsigned required_stack_size,\n+                  void (*fn)(void));\n+\n+   Therefore on entry we have:\n+\n+   x0 prepare_fn\n+   x1 &context\n+   x2 &ecif\n+   x3 bytes\n+   x4 fn\n+\n+   This function uses the following stack frame layout:\n+\n+   ==\n+                saved x30(lr)\n+   x29(fp)->    saved x29(fp)\n+                saved x24\n+                saved x23\n+                saved x22\n+   sp'    ->    saved x21\n+                ...\n+   sp     ->    (constructed callee stack arguments)\n+   ==\n+\n+   Voila! */\n+\n+#define ffi_call_SYSV_FS (8 * 4)\n+\n+        .cfi_startproc\n+ffi_call_SYSV:\n+        stp     x29, x30, [sp, #-16]!\n+\tcfi_adjust_cfa_offset (16)\n+        cfi_rel_offset (x29, 0)\n+        cfi_rel_offset (x30, 8)\n+\n+        mov     x29, sp\n+\tcfi_def_cfa_register (x29)\n+        sub     sp, sp, #ffi_call_SYSV_FS\n+\n+        stp     x21, x22, [sp, 0]\n+        cfi_rel_offset (x21, 0 - ffi_call_SYSV_FS)\n+        cfi_rel_offset (x22, 8 - ffi_call_SYSV_FS)\n+\n+        stp     x23, x24, [sp, 16]\n+        cfi_rel_offset (x23, 16 - ffi_call_SYSV_FS)\n+        cfi_rel_offset (x24, 24 - ffi_call_SYSV_FS)\n+\n+        mov     x21, x1\n+        mov     x22, x2\n+        mov     x24, x4\n+\n+        /* Allocate the stack space for the actual arguments, many\n+           arguments will be passed in registers, but we assume\n+           worst case and allocate sufficient stack for ALL of\n+           the arguments.  */\n+        sub     sp, sp, x3\n+\n+        /* unsigned (*prepare_fn) (struct call_context *context,\n+\t\t\t\t   unsigned char *stack, extended_cif *ecif);\n+\t */\n+        mov     x23, x0\n+        mov     x0, x1\n+        mov     x1, sp\n+        /* x2 already in place */\n+        blr     x23\n+\n+        /* Preserve the flags returned.  */\n+        mov     x23, x0\n+\n+        /* Figure out if we should touch the vector registers.  */\n+        tbz     x23, #AARCH64_FFI_WITH_V_BIT, 1f\n+\n+        /* Load the vector argument passing registers.  */\n+        ldp     q0, q1, [x21, #8*32 +  0]\n+        ldp     q2, q3, [x21, #8*32 + 32]\n+        ldp     q4, q5, [x21, #8*32 + 64]\n+        ldp     q6, q7, [x21, #8*32 + 96]\n+1:\n+        /* Load the core argument passing registers.  */\n+        ldp     x0, x1, [x21,  #0]\n+        ldp     x2, x3, [x21, #16]\n+        ldp     x4, x5, [x21, #32]\n+        ldp     x6, x7, [x21, #48]\n+\n+        /* Don't forget x8 which may be holding the address of a return buffer.\n+\t */\n+        ldr     x8,     [x21, #8*8]\n+\n+        blr     x24\n+\n+        /* Save the core argument passing registers.  */\n+        stp     x0, x1, [x21,  #0]\n+        stp     x2, x3, [x21, #16]\n+        stp     x4, x5, [x21, #32]\n+        stp     x6, x7, [x21, #48]\n+\n+        /* Note nothing useful ever comes back in x8!  */\n+\n+        /* Figure out if we should touch the vector registers.  */\n+        tbz     x23, #AARCH64_FFI_WITH_V_BIT, 1f\n+\n+        /* Save the vector argument passing registers.  */\n+        stp     q0, q1, [x21, #8*32 + 0]\n+        stp     q2, q3, [x21, #8*32 + 32]\n+        stp     q4, q5, [x21, #8*32 + 64]\n+        stp     q6, q7, [x21, #8*32 + 96]\n+1:\n+        /* All done, unwind our stack frame.  */\n+        ldp     x21, x22, [x29,  # - ffi_call_SYSV_FS]\n+        cfi_restore (x21)\n+        cfi_restore (x22)\n+\n+        ldp     x23, x24, [x29,  # - ffi_call_SYSV_FS + 16]\n+        cfi_restore (x23)\n+        cfi_restore (x24)\n+\n+        mov     sp, x29\n+\tcfi_def_cfa_register (sp)\n+\n+        ldp     x29, x30, [sp], #16\n+\tcfi_adjust_cfa_offset (-16)\n+        cfi_restore (x29)\n+        cfi_restore (x30)\n+\n+        ret\n+\n+        .cfi_endproc\n+        .size ffi_call_SYSV, .-ffi_call_SYSV\n+\n+#define ffi_closure_SYSV_FS (8 * 2 + AARCH64_CALL_CONTEXT_SIZE)\n+\n+/* ffi_closure_SYSV\n+\n+   Closure invocation glue. This is the low level code invoked directly by\n+   the closure trampoline to setup and call a closure.\n+\n+   On entry x17 points to a struct trampoline_data, x16 has been clobbered\n+   all other registers are preserved.\n+\n+   We allocate a call context and save the argument passing registers,\n+   then invoked the generic C ffi_closure_SYSV_inner() function to do all\n+   the real work, on return we load the result passing registers back from\n+   the call context.\n+\n+   On entry\n+\n+   extern void\n+   ffi_closure_SYSV (struct trampoline_data *);\n+\n+   struct trampoline_data\n+   {\n+        UINT64 *ffi_closure;\n+        UINT64 flags;\n+   };\n+\n+   This function uses the following stack frame layout:\n+\n+   ==\n+                saved x30(lr)\n+   x29(fp)->    saved x29(fp)\n+                saved x22\n+                saved x21\n+                ...\n+   sp     ->    call_context\n+   ==\n+\n+   Voila!  */\n+\n+        .text\n+        .globl ffi_closure_SYSV\n+        .cfi_startproc\n+ffi_closure_SYSV:\n+        stp     x29, x30, [sp, #-16]!\n+\tcfi_adjust_cfa_offset (16)\n+        cfi_rel_offset (x29, 0)\n+        cfi_rel_offset (x30, 8)\n+\n+        mov     x29, sp\n+\n+        sub     sp, sp, #ffi_closure_SYSV_FS\n+\tcfi_adjust_cfa_offset (ffi_closure_SYSV_FS)\n+\n+        stp     x21, x22, [x29, #-16]\n+        cfi_rel_offset (x21, 0)\n+        cfi_rel_offset (x22, 8)\n+\n+        /* Load x21 with &call_context.  */\n+        mov     x21, sp\n+        /* Preserve our struct trampoline_data *  */\n+        mov     x22, x17\n+\n+        /* Save the rest of the argument passing registers.  */\n+        stp     x0, x1, [x21, #0]\n+        stp     x2, x3, [x21, #16]\n+        stp     x4, x5, [x21, #32]\n+        stp     x6, x7, [x21, #48]\n+        /* Don't forget we may have been given a result scratch pad address.\n+\t */\n+        str     x8,     [x21, #64]\n+\n+        /* Figure out if we should touch the vector registers.  */\n+        ldr     x0, [x22, #8]\n+        tbz     x0, #AARCH64_FFI_WITH_V_BIT, 1f\n+\n+        /* Save the argument passing vector registers.  */\n+        stp     q0, q1, [x21, #8*32 + 0]\n+        stp     q2, q3, [x21, #8*32 + 32]\n+        stp     q4, q5, [x21, #8*32 + 64]\n+        stp     q6, q7, [x21, #8*32 + 96]\n+1:\n+        /* Load &ffi_closure..  */\n+        ldr     x0, [x22, #0]\n+        mov     x1, x21\n+        /* Compute the location of the stack at the point that the\n+           trampoline was called.  */\n+        add     x2, x29, #16\n+\n+        bl      ffi_closure_SYSV_inner\n+\n+        /* Figure out if we should touch the vector registers.  */\n+        ldr     x0, [x22, #8]\n+        tbz     x0, #AARCH64_FFI_WITH_V_BIT, 1f\n+\n+        /* Load the result passing vector registers.  */\n+        ldp     q0, q1, [x21, #8*32 + 0]\n+        ldp     q2, q3, [x21, #8*32 + 32]\n+        ldp     q4, q5, [x21, #8*32 + 64]\n+        ldp     q6, q7, [x21, #8*32 + 96]\n+1:\n+        /* Load the result passing core registers.  */\n+        ldp     x0, x1, [x21,  #0]\n+        ldp     x2, x3, [x21, #16]\n+        ldp     x4, x5, [x21, #32]\n+        ldp     x6, x7, [x21, #48]\n+        /* Note nothing usefull is returned in x8.  */\n+\n+        /* We are done, unwind our frame.  */\n+        ldp     x21, x22, [x29,  #-16]\n+        cfi_restore (x21)\n+        cfi_restore (x22)\n+\n+        mov     sp, x29\n+\tcfi_adjust_cfa_offset (-ffi_closure_SYSV_FS)\n+\n+        ldp     x29, x30, [sp], #16\n+\tcfi_adjust_cfa_offset (-16)\n+        cfi_restore (x29)\n+        cfi_restore (x30)\n+\n+        ret\n+        .cfi_endproc\n+        .size ffi_closure_SYSV, .-ffi_closure_SYSV"}, {"sha": "3ccceb9a50811b5b8337cd16f55971043098dd66", "filename": "libffi/src/arm/ffi.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Fsrc%2Farm%2Fffi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Fsrc%2Farm%2Fffi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Farm%2Fffi.c?ref=b4b575ce7854f4a49de8de93f38b7639e01b040b", "patch": "@@ -251,8 +251,10 @@ void ffi_call(ffi_cif *cif, void (*fn)(void), void *rvalue, void **avalue)\n       break;\n \n     case FFI_VFP:\n+#ifdef __ARM_EABI__\n       ffi_call_VFP (fn, &ecif, cif->bytes, cif->flags, ecif.rvalue);\n       break;\n+#endif\n \n     default:\n       FFI_ASSERT(0);\n@@ -609,8 +611,10 @@ ffi_prep_closure_loc (ffi_closure* closure,\n \n   if (cif->abi == FFI_SYSV)\n     closure_func = &ffi_closure_SYSV;\n+#ifdef __ARM_EABI__\n   else if (cif->abi == FFI_VFP)\n     closure_func = &ffi_closure_VFP;\n+#endif\n   else\n     return FFI_BAD_ABI;\n     "}, {"sha": "fb38cd6406ad0713614f4eaed5bb84fb0cf3e37d", "filename": "libffi/src/arm/sysv.S", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Fsrc%2Farm%2Fsysv.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Fsrc%2Farm%2Fsysv.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Farm%2Fsysv.S?ref=b4b575ce7854f4a49de8de93f38b7639e01b040b", "patch": "@@ -41,7 +41,7 @@\n #define CNAME(x) x\n #endif\n #ifdef __APPLE__\n-#define ENTRY(x) .globl CNAME(x); CNAME(x):\n+#define ENTRY(x) .globl _##x; _##x:\n #else\n #define ENTRY(x) .globl CNAME(x); .type CNAME(x),%function; CNAME(x):\n #endif /* __APPLE__ */\n@@ -187,7 +187,7 @@ ARM_FUNC_START ffi_call_SYSV\n \t@     r1 already set\n \n \t@ Call ffi_prep_args(stack, &ecif)\n-\tbl\tffi_prep_args\n+\tbl\tCNAME(ffi_prep_args)\n \n \t@ move first 4 parameters in registers\n \tldmia\tsp, {r0-r3}\n@@ -334,7 +334,9 @@ ARM_FUNC_START ffi_closure_SYSV\n \n \n /* Below are VFP hard-float ABI call and closure implementations.\n-   Add VFP FPU directive here. */\n+   Add VFP FPU directive here. This is only compiled into the library\n+   under EABI.  */\n+#ifdef __ARM_EABI__\n \t.fpu\tvfp\n \n \t@ r0:   fn\n@@ -362,7 +364,7 @@ ARM_FUNC_START ffi_call_VFP\n \tsub\tr2, fp, #64   @ VFP scratch space\n \n \t@ Call ffi_prep_args(stack, &ecif, vfp_space)\n-\tbl\tffi_prep_args\n+\tbl\tCNAME(ffi_prep_args)\n \n \t@ Load VFP register args if needed\n \tcmp\tr0, #0\n@@ -444,7 +446,7 @@ ARM_FUNC_START ffi_closure_VFP\n \tsub\tsp, sp, #72\n \tstr\tsp, [sp, #64]\n \tadd\tr1, sp, #64\n-\tbl\tffi_closure_SYSV_inner\n+\tbl\tCNAME(ffi_closure_SYSV_inner)\n \n \tcmp\tr0, #FFI_TYPE_INT\n \tbeq\t.Lretint_vfp\n@@ -491,6 +493,7 @@ ARM_FUNC_START ffi_closure_VFP\n .ffi_closure_VFP_end:\n \tUNWIND .fnend\n         .size    CNAME(ffi_closure_VFP),.ffi_closure_VFP_end-CNAME(ffi_closure_VFP)\n+#endif\n \n ENTRY(ffi_arm_trampoline)\n \tstmfd sp!, {r0-r3}"}, {"sha": "935e8de179547ec64263237692aec2d6824f4b6f", "filename": "libffi/src/arm/trampoline.S", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Fsrc%2Farm%2Ftrampoline.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Fsrc%2Farm%2Ftrampoline.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Farm%2Ftrampoline.S?ref=b4b575ce7854f4a49de8de93f38b7639e01b040b", "patch": "@@ -1,5 +1,5 @@\n # GENERATED CODE - DO NOT EDIT\n-# This file was generated by ./gentramp.sh\n+# This file was generated by src/arm/gentramp.sh\n \n #  Copyright (c) 2010, Plausible Labs Cooperative, Inc.\n #  "}, {"sha": "0beccc14c93272be21ac05eae26e6a62fcbae3c4", "filename": "libffi/src/bfin/ffi.c", "status": "added", "additions": 195, "deletions": 0, "changes": 195, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Fsrc%2Fbfin%2Fffi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Fsrc%2Fbfin%2Fffi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fbfin%2Fffi.c?ref=b4b575ce7854f4a49de8de93f38b7639e01b040b", "patch": "@@ -0,0 +1,195 @@\n+/* -----------------------------------------------------------------------\n+   ffi.c - Copyright (c) 2012  Alexandre K. I. de Mendonca <alexandre.keunecke@gmail.com>\n+\n+   Blackfin Foreign Function Interface\n+\n+   Permission is hereby granted, free of charge, to any person obtaining\n+   a copy of this software and associated documentation files (the\n+   ``Software''), to deal in the Software without restriction, including\n+   without limitation the rights to use, copy, modify, merge, publish,\n+   distribute, sublicense, and/or sell copies of the Software, and to\n+   permit persons to whom the Software is furnished to do so, subject to\n+   the following conditions:\n+\n+   The above copyright notice and this permission notice shall be included\n+   in all copies or substantial portions of the Software.\n+\n+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,\n+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n+   DEALINGS IN THE SOFTWARE.\n+   ----------------------------------------------------------------------- */\n+#include <ffi.h>\n+#include <ffi_common.h>\n+\n+#include <stdlib.h>\n+#include <stdio.h>\n+\n+/* Maximum number of GPRs available for argument passing.  */\n+#define MAX_GPRARGS 3\n+\n+/*\n+ * Return types\n+ */\n+#define FFIBFIN_RET_VOID 0\n+#define FFIBFIN_RET_BYTE 1\n+#define FFIBFIN_RET_HALFWORD 2\n+#define FFIBFIN_RET_INT64 3\n+#define FFIBFIN_RET_INT32 4\n+\n+/*====================================================================*/\n+/*                          PROTOTYPE          *\n+ /*====================================================================*/\n+void ffi_prep_args(unsigned char *, extended_cif *);\n+\n+/*====================================================================*/\n+/*                          Externals                                 */\n+/*                          (Assembly)                                */\n+/*====================================================================*/\n+\n+extern void ffi_call_SYSV(unsigned, extended_cif *, void(*)(unsigned char *, extended_cif *), unsigned, void *, void(*fn)(void));\n+\n+/*====================================================================*/\n+/*                          Implementation                            */\n+/*                                                            */\n+/*====================================================================*/\n+\n+\n+/*\n+ * This function calculates the return type (size) based on type.\n+ */\n+\n+ffi_status ffi_prep_cif_machdep(ffi_cif *cif)\n+{\n+   /* --------------------------------------*\n+    *   Return handling                *\n+    * --------------------------------------*/\n+   switch (cif->rtype->type) {\n+      case FFI_TYPE_VOID:\n+         cif->flags = FFIBFIN_RET_VOID;\n+         break;\n+      case FFI_TYPE_UINT16:\n+      case FFI_TYPE_SINT16:\n+         cif->flags = FFIBFIN_RET_HALFWORD;\n+         break;\n+      case FFI_TYPE_UINT8:\n+         cif->flags = FFIBFIN_RET_BYTE;\n+         break;\n+      case FFI_TYPE_INT:\n+      case FFI_TYPE_UINT32:\n+      case FFI_TYPE_SINT32:\n+      case FFI_TYPE_FLOAT:\n+      case FFI_TYPE_POINTER:\n+      case FFI_TYPE_SINT8:\n+         cif->flags = FFIBFIN_RET_INT32;\n+         break;\n+      case FFI_TYPE_SINT64:\n+      case FFI_TYPE_UINT64:\n+      case FFI_TYPE_DOUBLE:\n+          cif->flags = FFIBFIN_RET_INT64;\n+          break;\n+      case FFI_TYPE_STRUCT:\n+         if (cif->rtype->size <= 4){\n+        \t cif->flags = FFIBFIN_RET_INT32;\n+         }else if (cif->rtype->size == 8){\n+        \t cif->flags = FFIBFIN_RET_INT64;\n+         }else{\n+        \t //it will return via a hidden pointer in P0\n+        \t cif->flags = FFIBFIN_RET_VOID;\n+         }\n+         break;\n+      default:\n+         FFI_ASSERT(0);\n+         break;\n+   }\n+   return FFI_OK;\n+}\n+\n+/*\n+ * This will prepare the arguments and will call the assembly routine\n+ * cif = the call interface\n+ * fn = the function to be called\n+ * rvalue = the return value\n+ * avalue = the arguments\n+ */\n+void ffi_call(ffi_cif *cif, void(*fn)(void), void *rvalue, void **avalue)\n+{\n+   int ret_type = cif->flags;\n+   extended_cif ecif;\n+   ecif.cif = cif;\n+   ecif.avalue = avalue;\n+   ecif.rvalue = rvalue;\n+\n+   switch (cif->abi) {\n+      case FFI_SYSV:\n+         ffi_call_SYSV(cif->bytes, &ecif, ffi_prep_args, ret_type, ecif.rvalue, fn);\n+         break;\n+      default:\n+         FFI_ASSERT(0);\n+         break;\n+   }\n+}\n+\n+\n+/*\n+* This function prepares the parameters (copies them from the ecif to the stack)\n+*  to call the function (ffi_prep_args is called by the assembly routine in file\n+*  sysv.S, which also calls the actual function)\n+*/\n+void ffi_prep_args(unsigned char *stack, extended_cif *ecif)\n+{\n+   register unsigned int i = 0;\n+   void **p_argv;\n+   unsigned char *argp;\n+   ffi_type **p_arg;\n+   argp = stack;\n+   p_argv = ecif->avalue;\n+   for (i = ecif->cif->nargs, p_arg = ecif->cif->arg_types;\n+        (i != 0);\n+        i--, p_arg++) {\n+      size_t z;\n+      z = (*p_arg)->size;\n+      if (z < sizeof(int)) {\n+         z = sizeof(int);\n+         switch ((*p_arg)->type) {\n+            case FFI_TYPE_SINT8: {\n+                  signed char v = *(SINT8 *)(* p_argv);\n+                  signed int t = v;\n+                  *(signed int *) argp = t;\n+               }\n+               break;\n+            case FFI_TYPE_UINT8: {\n+                  unsigned char v = *(UINT8 *)(* p_argv);\n+                  unsigned int t = v;\n+                  *(unsigned int *) argp = t;\n+               }\n+               break;\n+            case FFI_TYPE_SINT16:\n+               *(signed int *) argp = (signed int) * (SINT16 *)(* p_argv);\n+               break;\n+            case FFI_TYPE_UINT16:\n+               *(unsigned int *) argp = (unsigned int) * (UINT16 *)(* p_argv);\n+               break;\n+            case FFI_TYPE_STRUCT:\n+               memcpy(argp, *p_argv, (*p_arg)->size);\n+               break;\n+            default:\n+               FFI_ASSERT(0);\n+               break;\n+         }\n+      } else if (z == sizeof(int)) {\n+         *(unsigned int *) argp = (unsigned int) * (UINT32 *)(* p_argv);\n+      } else {\n+         memcpy(argp, *p_argv, z);\n+      }\n+      p_argv++;\n+      argp += z;\n+   }\n+}\n+\n+\n+"}, {"sha": "2175c010162f6ec6dab831ffb3848257a9242d41", "filename": "libffi/src/bfin/ffitarget.h", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Fsrc%2Fbfin%2Fffitarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Fsrc%2Fbfin%2Fffitarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fbfin%2Fffitarget.h?ref=b4b575ce7854f4a49de8de93f38b7639e01b040b", "patch": "@@ -0,0 +1,43 @@\n+/* -----------------------------------------------------------------------\n+   ffitarget.h - Copyright (c) 2012  Alexandre K. I. de Mendonca <alexandre.keunecke@gmail.com>\n+\n+   Blackfin Foreign Function Interface\n+\n+   Permission is hereby granted, free of charge, to any person obtaining\n+   a copy of this software and associated documentation files (the\n+   ``Software''), to deal in the Software without restriction, including\n+   without limitation the rights to use, copy, modify, merge, publish,\n+   distribute, sublicense, and/or sell copies of the Software, and to\n+   permit persons to whom the Software is furnished to do so, subject to\n+   the following conditions:\n+\n+   The above copyright notice and this permission notice shall be included\n+   in all copies or substantial portions of the Software.\n+\n+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,\n+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n+   DEALINGS IN THE SOFTWARE.\n+   ----------------------------------------------------------------------- */\n+\n+#ifndef LIBFFI_TARGET_H\n+#define LIBFFI_TARGET_H\n+\n+#ifndef LIBFFI_ASM\n+typedef unsigned long          ffi_arg;\n+typedef signed \t long          ffi_sarg;\n+\n+typedef enum ffi_abi {\n+  FFI_FIRST_ABI = 0,\n+  FFI_SYSV,\n+  FFI_LAST_ABI,\n+  FFI_DEFAULT_ABI = FFI_SYSV\n+} ffi_abi;\n+#endif\n+\n+#endif\n+"}, {"sha": "ae7a1529b123425cd4319959b1fe1b463b17212b", "filename": "libffi/src/bfin/sysv.S", "status": "added", "additions": 177, "deletions": 0, "changes": 177, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Fsrc%2Fbfin%2Fsysv.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Fsrc%2Fbfin%2Fsysv.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fbfin%2Fsysv.S?ref=b4b575ce7854f4a49de8de93f38b7639e01b040b", "patch": "@@ -0,0 +1,177 @@\n+/* -----------------------------------------------------------------------\n+   sysv.S - Copyright (c) 2012  Alexandre K. I. de Mendonca <alexandre.keunecke@gmail.com>\n+\n+   Blackfin Foreign Function Interface\n+\n+   Permission is hereby granted, free of charge, to any person obtaining\n+   a copy of this software and associated documentation files (the\n+   ``Software''), to deal in the Software without restriction, including\n+   without limitation the rights to use, copy, modify, merge, publish,\n+   distribute, sublicense, and/or sell copies of the Software, and to\n+   permit persons to whom the Software is furnished to do so, subject to\n+   the following conditions:\n+\n+   The above copyright notice and this permission notice shall be included\n+   in all copies or substantial portions of the Software.\n+\n+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,\n+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n+   DEALINGS IN THE SOFTWARE.\n+   ----------------------------------------------------------------------- */\n+\n+#define LIBFFI_ASM\n+#include <fficonfig.h>\n+#include <ffi.h>\n+\n+.text\n+.align 4\n+\n+\t/*\n+\t There is a \"feature\" in the bfin toolchain that it puts a _ before funcion names\n+\t that's why the function here it's called _ffi_call_SYSV and not ffi_call_SYSV\n+\t */\n+\t.global _ffi_call_SYSV;\n+\t.type _ffi_call_SYSV, STT_FUNC;\n+\t.func ffi_call_SYSV\n+\n+\t/*\n+\tcif->bytes  \t= R0\t(fp+8)\n+\t&ecif\t\t\t= R1\t(fp+12)\n+\tffi_prep_args\t= R2\t(fp+16)\n+\tret_type\t\t= stack (fp+20)\n+\tecif.rvalue\t\t= stack (fp+24)\n+\tfn\t\t\t\t= stack\t(fp+28)\n+\t\t\t\t\t  got\t(fp+32)\n+    There is room for improvement here (we can use temporary registers\n+        instead of saving the values in the memory)\n+\tREGS:\n+\t\tP5 => Stack pointer (function arguments)\n+\t\tR5 => cif->bytes\n+\t\tR4 => ret->type\n+\n+\t\tFP-20 = P3\n+\t\tFP-16 = SP (parameters area)\n+\t\tFP-12 = SP (temp)\n+\t\tFP-08 = function return part 1 [R0]\n+\t\tFP-04 = function return part 2 [R1]\n+\t*/\n+\n+_ffi_call_SYSV:\n+.prologue:\n+\tLINK 20;\n+\t[FP-20] = P3;\n+\t[FP+8] = R0;\n+\t[FP+12] = R1;\n+\t[FP+16] = R2;\n+\n+.allocate_stack:\n+\t//alocate cif->bytes into the stack\n+\tR1 = [FP+8];\n+\tR0 = SP;\n+\tR0 = R0 - R1;\n+\tR1 = 4;\n+\tR0 = R0 - R1;\n+\t[FP-12] = SP;\n+\tSP = R0;\n+\t[FP-16] = SP;\n+\n+.call_prep_args:\n+\t//get the addr of prep_args\n+\tP0 = [P3 + _ffi_prep_args@FUNCDESC_GOT17M4];\n+\tP1 = [P0];\n+\tP3 = [P0+4];\n+\tR0 = [FP-16];//SP (parameter area)\n+\tR1 = [FP+12];//ecif\n+\tcall (P1);\n+\n+.call_user_function:\n+\t//ajust SP so as to allow the user function access the parameters on the stack\n+\tSP = [FP-16]; //point to function parameters\n+\tR0 = [SP];\n+\tR1 = [SP+4];\n+\tR2 = [SP+8];\n+\t//load user function address\n+\tP0 = FP;\n+\tP0 +=28;\n+\tP1 = [P0];\n+\tP1 = [P1];\n+\tP3 = [P0+4];\n+\t/*\n+\t\tFor functions returning aggregate values (struct) occupying more than 8 bytes,\n+\t\tthe caller allocates the return value object on the stack and the address\n+\t\tof this object is passed to the callee as a hidden argument in register P0.\n+\t*/\n+\tP0 = [FP+24];\n+\n+\tcall (P1);\n+\tSP = [FP-12];\n+.compute_return:\n+\tP2 = [FP-20];\n+\t[FP-8] = R0;\n+\t[FP-4] = R1;\n+\n+\tR0 = [FP+20];\n+\tR1 = R0 << 2;\n+\n+\tR0 = [P2+.rettable@GOT17M4];\n+\tR0 = R1 + R0;\n+\tP2 = R0;\n+\tR1 = [P2];\n+\n+\tP2 = [FP+-20];\n+\tR0 = [P2+.rettable@GOT17M4];\n+\tR0 = R1 + R0;\n+\tP2 = R0;\n+\tR0 = [FP-8];\n+\tR1 = [FP-4];\n+\tjump (P2);\n+\n+/*\n+#define FFIBFIN_RET_VOID 0\n+#define FFIBFIN_RET_BYTE 1\n+#define FFIBFIN_RET_HALFWORD 2\n+#define FFIBFIN_RET_INT64 3\n+#define FFIBFIN_RET_INT32 4\n+*/\n+.align 4\n+.align 4\n+.rettable:\n+\t.dd .epilogue - .rettable\n+\t.dd\t.rbyte - .rettable;\n+\t.dd\t.rhalfword - .rettable;\n+\t.dd\t.rint64 - .rettable;\n+\t.dd\t.rint32 - .rettable;\n+\n+.rbyte:\n+\tP0 = [FP+24];\n+\tR0 = R0.B (Z);\n+\t[P0] = R0;\n+\tJUMP .epilogue\n+.rhalfword:\n+\tP0 = [FP+24];\n+\tR0 = R0.L;\n+\t[P0] = R0;\n+\tJUMP .epilogue\n+.rint64:\n+\tP0 = [FP+24];// &rvalue\n+\t[P0] = R0;\n+\t[P0+4] = R1;\n+\tJUMP .epilogue\n+.rint32:\n+\tP0 = [FP+24];\n+\t[P0] = R0;\n+.epilogue:\n+\tR0 = [FP+8];\n+\tR1 = [FP+12];\n+\tR2 = [FP+16];\n+\tP3 = [FP-20];\n+\tUNLINK;\n+\tRTS;\n+\n+.size _ffi_call_SYSV,.-_ffi_call_SYSV;\n+.endfunc"}, {"sha": "fecbc4ae2c9e7056e84c2561f6537e453ea7efc7", "filename": "libffi/src/closures.c", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Fsrc%2Fclosures.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Fsrc%2Fclosures.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fclosures.c?ref=b4b575ce7854f4a49de8de93f38b7639e01b040b", "patch": "@@ -172,6 +172,27 @@ selinux_enabled_check (void)\n \n #endif /* !FFI_MMAP_EXEC_SELINUX */\n \n+/* On PaX enable kernels that have MPROTECT enable we can't use PROT_EXEC. */\n+#ifdef FFI_MMAP_EXEC_EMUTRAMP_PAX\n+#include <stdlib.h>\n+\n+static int emutramp_enabled = -1;\n+\n+static int\n+emutramp_enabled_check (void)\n+{\n+  if (getenv (\"FFI_DISABLE_EMUTRAMP\") == NULL)\n+    return 1;\n+  else\n+    return 0;\n+}\n+\n+#define is_emutramp_enabled() (emutramp_enabled >= 0 ? emutramp_enabled \\\n+                               : (emutramp_enabled = emutramp_enabled_check ()))\n+#else\n+#define is_emutramp_enabled() 0\n+#endif /* FFI_MMAP_EXEC_EMUTRAMP_PAX */\n+\n #elif defined (__CYGWIN__) || defined(__INTERIX)\n \n #include <sys/mman.h>\n@@ -458,6 +479,12 @@ dlmmap (void *start, size_t length, int prot,\n   printf (\"mapping in %zi\\n\", length);\n #endif\n \n+  if (execfd == -1 && is_emutramp_enabled ())\n+    {\n+      ptr = mmap (start, length, prot & ~PROT_EXEC, flags, fd, offset);\n+      return ptr;\n+    }\n+\n   if (execfd == -1 && !is_selinux_enabled ())\n     {\n       ptr = mmap (start, length, prot | PROT_EXEC, flags, fd, offset);"}, {"sha": "37a078437eac518b0c31e29cbfbeaeb75443b30e", "filename": "libffi/src/m68k/ffi.c", "status": "modified", "additions": 73, "deletions": 10, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Fsrc%2Fm68k%2Fffi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Fsrc%2Fm68k%2Fffi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fm68k%2Fffi.c?ref=b4b575ce7854f4a49de8de93f38b7639e01b040b", "patch": "@@ -1,7 +1,7 @@\n /* -----------------------------------------------------------------------\n    ffi.c\n-   \n-   m68k Foreign Function Interface \n+\n+   m68k Foreign Function Interface\n    ----------------------------------------------------------------------- */\n \n #include <ffi.h>\n@@ -13,8 +13,13 @@\n void rtems_cache_flush_multiple_data_lines( const void *, size_t );\n #else\n #include <sys/syscall.h>\n+#ifdef __MINT__\n+#include <mint/mintbind.h>\n+#include <mint/ssystem.h>\n+#else\n #include <asm/cachectl.h>\n #endif\n+#endif\n \n void ffi_call_SYSV (extended_cif *,\n \t\t    unsigned, unsigned,\n@@ -39,8 +44,12 @@ ffi_prep_args (void *stack, extended_cif *ecif)\n \n   argp = stack;\n \n-  if (ecif->cif->rtype->type == FFI_TYPE_STRUCT\n-      && !ecif->cif->flags)\n+  if (\n+#ifdef __MINT__\n+      (ecif->cif->rtype->type == FFI_TYPE_LONGDOUBLE) ||\n+#endif\n+      (((ecif->cif->rtype->type == FFI_TYPE_STRUCT)\n+        && !ecif->cif->flags)))\n     struct_value_ptr = ecif->rvalue;\n   else\n     struct_value_ptr = NULL;\n@@ -51,12 +60,12 @@ ffi_prep_args (void *stack, extended_cif *ecif)\n        i != 0;\n        i--, p_arg++)\n     {\n-      size_t z;\n+      size_t z = (*p_arg)->size;\n+      int type = (*p_arg)->type;\n \n-      z = (*p_arg)->size;\n       if (z < sizeof (int))\n \t{\n-\t  switch ((*p_arg)->type)\n+\t  switch (type)\n \t    {\n \t    case FFI_TYPE_SINT8:\n \t      *(signed int *) argp = (signed int) *(SINT8 *) *p_argv;\n@@ -75,7 +84,14 @@ ffi_prep_args (void *stack, extended_cif *ecif)\n \t      break;\n \n \t    case FFI_TYPE_STRUCT:\n+#ifdef __MINT__\n+\t      if (z == 1 || z == 2)\n+\t\tmemcpy (argp + 2, *p_argv, z);\n+              else\n+\t\tmemcpy (argp, *p_argv, z);\n+#else\n \t      memcpy (argp + sizeof (int) - z, *p_argv, z);\n+#endif\n \t      break;\n \n \t    default:\n@@ -120,17 +136,34 @@ ffi_prep_cif_machdep (ffi_cif *cif)\n       break;\n \n     case FFI_TYPE_STRUCT:\n+      if (cif->rtype->elements[0]->type == FFI_TYPE_STRUCT &&\n+          cif->rtype->elements[1])\n+        {\n+          cif->flags = 0;\n+          break;\n+        }\n+\n       switch (cif->rtype->size)\n \t{\n \tcase 1:\n+#ifdef __MINT__\n+\t  cif->flags = CIF_FLAGS_STRUCT2;\n+#else\n \t  cif->flags = CIF_FLAGS_STRUCT1;\n+#endif\n \t  break;\n \tcase 2:\n \t  cif->flags = CIF_FLAGS_STRUCT2;\n \t  break;\n+#ifdef __MINT__\n+\tcase 3:\n+#endif\n \tcase 4:\n \t  cif->flags = CIF_FLAGS_INT;\n \t  break;\n+#ifdef __MINT__\n+\tcase 7:\n+#endif\n \tcase 8:\n \t  cif->flags = CIF_FLAGS_DINT;\n \t  break;\n@@ -150,7 +183,11 @@ ffi_prep_cif_machdep (ffi_cif *cif)\n \n #if (FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE)\n     case FFI_TYPE_LONGDOUBLE:\n+#ifdef __MINT__\n+      cif->flags = 0;\n+#else\n       cif->flags = CIF_FLAGS_LDOUBLE;\n+#endif\n       break;\n #endif\n \n@@ -218,6 +255,26 @@ ffi_prep_incoming_args_SYSV (char *stack, void **avalue, ffi_cif *cif)\n       size_t z;\n \n       z = (*p_arg)->size;\n+#ifdef __MINT__\n+      if (cif->flags &&\n+          cif->rtype->type == FFI_TYPE_STRUCT &&\n+          (z == 1 || z == 2))\n+ \t{\n+\t  *p_argv = (void *) (argp + 2);\n+\n+\t  z = 4;\n+\t}\n+      else\n+      if (cif->flags &&\n+          cif->rtype->type == FFI_TYPE_STRUCT &&\n+          (z == 3 || z == 4))\n+ \t{\n+\t  *p_argv = (void *) (argp);\n+\n+\t  z = 4;\n+\t}\n+      else\n+#endif\n       if (z <= 4)\n \t{\n \t  *p_argv = (void *) (argp + 4 - z);\n@@ -267,14 +324,21 @@ ffi_prep_closure_loc (ffi_closure* closure,\n   *(unsigned short *)closure->tramp = 0x207c;\n   *(void **)(closure->tramp + 2) = codeloc;\n   *(unsigned short *)(closure->tramp + 6) = 0x4ef9;\n-  if (cif->rtype->type == FFI_TYPE_STRUCT\n-      && !cif->flags)\n+\n+  if (\n+#ifdef __MINT__\n+      (cif->rtype->type == FFI_TYPE_LONGDOUBLE) ||\n+#endif\n+      (((cif->rtype->type == FFI_TYPE_STRUCT)\n+         && !cif->flags)))\n     *(void **)(closure->tramp + 8) = ffi_closure_struct_SYSV;\n   else\n     *(void **)(closure->tramp + 8) = ffi_closure_SYSV;\n \n #ifdef __rtems__\n   rtems_cache_flush_multiple_data_lines( codeloc, FFI_TRAMPOLINE_SIZE );\n+#elif defined(__MINT__)\n+  Ssystem(S_FLUSHCACHE, codeloc, FFI_TRAMPOLINE_SIZE);\n #else\n   syscall(SYS_cacheflush, codeloc, FLUSH_SCOPE_LINE,\n \t  FLUSH_CACHE_BOTH, FFI_TRAMPOLINE_SIZE);\n@@ -286,4 +350,3 @@ ffi_prep_closure_loc (ffi_closure* closure,\n \n   return FFI_OK;\n }\n-"}, {"sha": "f6f4ef97eaf879f4e647fe221cb39889570c10c5", "filename": "libffi/src/m68k/sysv.S", "status": "modified", "additions": 34, "deletions": 19, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Fsrc%2Fm68k%2Fsysv.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Fsrc%2Fm68k%2Fsysv.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fm68k%2Fsysv.S?ref=b4b575ce7854f4a49de8de93f38b7639e01b040b", "patch": "@@ -1,6 +1,7 @@\n /* -----------------------------------------------------------------------\n \t\n-   sysv.S - Copyright (c) 1998, 2012 Andreas Schwab\n+   sysv.S - Copyright (c) 2012 Alan Hourihane\n+\t    Copyright (c) 1998, 2012 Andreas Schwab\n \t    Copyright (c) 2008 Red Hat, Inc. \n    \n    m68k Foreign Function Interface \n@@ -40,15 +41,21 @@\n #define CFI_OFFSET(reg,off)\n #define CFI_DEF_CFA(reg,off)\n #define CFI_ENDPROC()\n+#endif\n+\n+#ifdef __MINT__\n+#define CALLFUNC(funcname) _ ## funcname\n+#else\n+#define CALLFUNC(funcname) funcname\n #endif\n \n \t.text\n \n-\t.globl\tffi_call_SYSV\n-\t.type\tffi_call_SYSV,@function\n+\t.globl\tCALLFUNC(ffi_call_SYSV)\n+\t.type\tCALLFUNC(ffi_call_SYSV),@function\n \t.align\t4\n \n-ffi_call_SYSV:\n+CALLFUNC(ffi_call_SYSV):\n \tCFI_STARTPROC()\n \tlink\t%fp,#0\n \tCFI_OFFSET(14,-8)\n@@ -63,14 +70,18 @@ ffi_call_SYSV:\n \tmove.l\t8(%fp),-(%sp)\n \tpea\t4(%sp)\n #if !defined __PIC__\n-\tjsr\tffi_prep_args\n+\tjsr\tCALLFUNC(ffi_prep_args)\n #else\n-\tbsr.l\tffi_prep_args@PLTPC\n+\tbsr.l\tCALLFUNC(ffi_prep_args@PLTPC)\n #endif\n \taddq.l\t#8,%sp\t\n \n \t| Pass pointer to struct value, if any\n+#ifdef __MINT__\n+\tmove.l\t%d0,%a1\n+#else\n \tmove.l\t%a0,%a1\n+#endif\n \n \t| Call the function\n \tmove.l\t24(%fp),%a0\n@@ -142,7 +153,11 @@ retlongdouble:\n retpointer:\n \tbtst\t#5,%d2\n \tjbeq\tretstruct1\n+#ifdef __MINT__\n+\tmove.l\t%d0,(%a1)\n+#else\n \tmove.l\t%a0,(%a1)\n+#endif\n \tjbra\tepilogue\n \n retstruct1:\n@@ -162,13 +177,13 @@ epilogue:\n \tunlk\t%fp\n \trts\n \tCFI_ENDPROC()\n-\t.size\tffi_call_SYSV,.-ffi_call_SYSV\n+\t.size\tCALLFUNC(ffi_call_SYSV),.-CALLFUNC(ffi_call_SYSV)\n \n-\t.globl\tffi_closure_SYSV\n-\t.type\tffi_closure_SYSV, @function\n+\t.globl\tCALLFUNC(ffi_closure_SYSV)\n+\t.type\tCALLFUNC(ffi_closure_SYSV), @function\n \t.align\t4\n \n-ffi_closure_SYSV:\n+CALLFUNC(ffi_closure_SYSV):\n \tCFI_STARTPROC()\n \tlink\t%fp,#-12\n \tCFI_OFFSET(14,-8)\n@@ -178,9 +193,9 @@ ffi_closure_SYSV:\n \tpea\t-12(%fp)\n \tmove.l\t%a0,-(%sp)\n #if !defined __PIC__\n-\tjsr\tffi_closure_SYSV_inner\n+\tjsr\tCALLFUNC(ffi_closure_SYSV_inner)\n #else\n-\tbsr.l\tffi_closure_SYSV_inner@PLTPC\n+\tbsr.l\tCALLFUNC(ffi_closure_SYSV_inner@PLTPC)\n #endif\n \n \tlsr.l\t#1,%d0\n@@ -240,13 +255,13 @@ ffi_closure_SYSV:\n \tjra\t.Lcls_epilogue\n \tCFI_ENDPROC()\n \n-\t.size\tffi_closure_SYSV,.-ffi_closure_SYSV\n+\t.size\tCALLFUNC(ffi_closure_SYSV),.-CALLFUNC(ffi_closure_SYSV)\n \n-\t.globl\tffi_closure_struct_SYSV\n-\t.type\tffi_closure_struct_SYSV, @function\n+\t.globl\tCALLFUNC(ffi_closure_struct_SYSV)\n+\t.type\tCALLFUNC(ffi_closure_struct_SYSV), @function\n \t.align\t4\n \n-ffi_closure_struct_SYSV:\n+CALLFUNC(ffi_closure_struct_SYSV):\n \tCFI_STARTPROC()\n \tlink\t%fp,#0\n \tCFI_OFFSET(14,-8)\n@@ -256,14 +271,14 @@ ffi_closure_struct_SYSV:\n \tmove.l\t%a1,-(%sp)\n \tmove.l\t%a0,-(%sp)\n #if !defined __PIC__\n-\tjsr\tffi_closure_SYSV_inner\n+\tjsr\tCALLFUNC(ffi_closure_SYSV_inner)\n #else\n-\tbsr.l\tffi_closure_SYSV_inner@PLTPC\n+\tbsr.l\tCALLFUNC(ffi_closure_SYSV_inner@PLTPC)\n #endif\n \tunlk\t%fp\n \trts\n \tCFI_ENDPROC()\n-\t.size\tffi_closure_struct_SYSV,.-ffi_closure_struct_SYSV\n+\t.size\tCALLFUNC(ffi_closure_struct_SYSV),.-CALLFUNC(ffi_closure_struct_SYSV)\n \n #if defined __ELF__ && defined __linux__\n \t.section\t.note.GNU-stack,\"\",@progbits"}, {"sha": "dd897f4c631c4f3f0d7f6490d1ad5a096eeebf23", "filename": "libffi/src/powerpc/ffi_darwin.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Fsrc%2Fpowerpc%2Fffi_darwin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Fsrc%2Fpowerpc%2Fffi_darwin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fpowerpc%2Fffi_darwin.c?ref=b4b575ce7854f4a49de8de93f38b7639e01b040b", "patch": "@@ -1065,10 +1065,10 @@ ffi_prep_closure_loc (ffi_closure* closure,\n       closure->cif = cif;\n       closure->fun = fun;\n       closure->user_data = user_data;\n+      break;\n \n     default:\n-\n-      FFI_ASSERT(0);\n+      return FFI_BAD_ABI;\n       break;\n     }\n   return FFI_OK;\n@@ -1235,7 +1235,7 @@ ffi_closure_helper_DARWIN (ffi_closure *closure, void *rvalue,\n \t  if (arg_types[i]->elements[0]->type == FFI_TYPE_DOUBLE)\n \t    size_al = ALIGN(arg_types[i]->size, 8);\n #  if defined(POWERPC64)\n-\t  FFI_ASSERT (cif->abi != FFI_DARWIN)\n+\t  FFI_ASSERT (cif->abi != FFI_DARWIN);\n \t  avalue[i] = pgr;\n \t  pgr += (size_al + 7) / 8;\n #  else"}, {"sha": "5d1924bbe584cfd1fe1e6d5ed83101023b7a4d4f", "filename": "libffi/src/prep_cif.c", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Fsrc%2Fprep_cif.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Fsrc%2Fprep_cif.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fprep_cif.c?ref=b4b575ce7854f4a49de8de93f38b7639e01b040b", "patch": "@@ -139,6 +139,9 @@ ffi_status FFI_HIDDEN ffi_prep_cif_core(ffi_cif *cif, ffi_abi abi,\n   if (cif->rtype->type == FFI_TYPE_STRUCT\n #ifdef SPARC\n       && (cif->abi != FFI_V9 || cif->rtype->size > 32)\n+#endif\n+#ifdef TILE\n+      && (cif->rtype->size > 10 * FFI_SIZEOF_ARG)\n #endif\n      )\n     bytes = STACK_ARG_SIZE(sizeof(void*));\n@@ -169,6 +172,16 @@ ffi_status FFI_HIDDEN ffi_prep_cif_core(ffi_cif *cif, ffi_abi abi,\n \t  if (((*ptr)->alignment - 1) & bytes)\n \t    bytes = ALIGN(bytes, (*ptr)->alignment);\n \n+#ifdef TILE\n+\t  if (bytes < 10 * FFI_SIZEOF_ARG &&\n+\t      bytes + STACK_ARG_SIZE((*ptr)->size) > 10 * FFI_SIZEOF_ARG)\n+\t    {\n+\t      /* An argument is never split between the 10 parameter\n+\t\t registers and the stack.  */\n+\t      bytes = 10 * FFI_SIZEOF_ARG;\n+\t    }\n+#endif\n+\n \t  bytes += STACK_ARG_SIZE((*ptr)->size);\n \t}\n #endif"}, {"sha": "3a94469c7fafd921b4aef87e7dae6d02a013bab4", "filename": "libffi/src/tile/ffi.c", "status": "added", "additions": 355, "deletions": 0, "changes": 355, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Fsrc%2Ftile%2Fffi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Fsrc%2Ftile%2Fffi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Ftile%2Fffi.c?ref=b4b575ce7854f4a49de8de93f38b7639e01b040b", "patch": "@@ -0,0 +1,355 @@\n+/* -----------------------------------------------------------------------\n+   ffi.c - Copyright (c) 2012 Tilera Corp.\n+\n+   TILE Foreign Function Interface\n+\n+   Permission is hereby granted, free of charge, to any person obtaining\n+   a copy of this software and associated documentation files (the\n+   ``Software''), to deal in the Software without restriction, including\n+   without limitation the rights to use, copy, modify, merge, publish,\n+   distribute, sublicense, and/or sell copies of the Software, and to\n+   permit persons to whom the Software is furnished to do so, subject to\n+   the following conditions:\n+\n+   The above copyright notice and this permission notice shall be included\n+   in all copies or substantial portions of the Software.\n+\n+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,\n+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n+   DEALINGS IN THE SOFTWARE.\n+   ----------------------------------------------------------------------- */\n+\n+#include <ffi.h>\n+#include <ffi_common.h>\n+#include <stdlib.h>\n+#include <stdint.h>\n+#include <unistd.h>\n+#include <arch/abi.h>\n+#include <arch/icache.h>\n+#include <arch/opcode.h>\n+\n+\n+/* The first 10 registers are used to pass arguments and return values. */\n+#define NUM_ARG_REGS 10\n+\n+/* Performs a raw function call with the given NUM_ARG_REGS register arguments\n+   and the specified additional stack arguments (if any). */\n+extern void ffi_call_tile(ffi_sarg reg_args[NUM_ARG_REGS],\n+                          const ffi_sarg *stack_args,\n+                          size_t stack_args_bytes,\n+                          void (*fnaddr)(void))\n+  FFI_HIDDEN;\n+\n+/* This handles the raw call from the closure stub, cleaning up the\n+   parameters and delegating to ffi_closure_tile_inner. */\n+extern void ffi_closure_tile(void) FFI_HIDDEN;\n+\n+\n+ffi_status\n+ffi_prep_cif_machdep(ffi_cif *cif)\n+{\n+  /* We always allocate room for all registers. Even if we don't\n+     use them as parameters, they get returned in the same array\n+     as struct return values so we need to make room. */\n+  if (cif->bytes < NUM_ARG_REGS * FFI_SIZEOF_ARG)\n+    cif->bytes = NUM_ARG_REGS * FFI_SIZEOF_ARG;\n+\n+  if (cif->rtype->size > NUM_ARG_REGS * FFI_SIZEOF_ARG)\n+    cif->flags = FFI_TYPE_STRUCT;\n+  else\n+    cif->flags = FFI_TYPE_INT;\n+\n+  /* Nothing to do. */\n+  return FFI_OK;\n+}\n+\n+\n+static long\n+assign_to_ffi_arg(ffi_sarg *out, void *in, const ffi_type *type,\n+                  int write_to_reg)\n+{\n+  switch (type->type)\n+    {\n+    case FFI_TYPE_SINT8:\n+      *out = *(SINT8 *)in;\n+      return 1;\n+\n+    case FFI_TYPE_UINT8:\n+      *out = *(UINT8 *)in;\n+      return 1;\n+\n+    case FFI_TYPE_SINT16:\n+      *out = *(SINT16 *)in;\n+      return 1;\n+\n+    case FFI_TYPE_UINT16:\n+      *out = *(UINT16 *)in;\n+      return 1;\n+\n+    case FFI_TYPE_SINT32:\n+    case FFI_TYPE_UINT32:\n+#ifndef __LP64__\n+    case FFI_TYPE_POINTER:\n+#endif\n+      /* Note that even unsigned 32-bit quantities are sign extended\n+         on tilegx when stored in a register.  */\n+      *out = *(SINT32 *)in;\n+      return 1;\n+\n+    case FFI_TYPE_FLOAT:\n+#ifdef __tilegx__\n+      if (write_to_reg)\n+        {\n+          /* Properly sign extend the value.  */\n+          union { float f; SINT32 s32; } val;\n+          val.f = *(float *)in;\n+          *out = val.s32;\n+        }\n+      else\n+#endif\n+        {\n+          *(float *)out = *(float *)in;\n+        }\n+      return 1;\n+\n+    case FFI_TYPE_SINT64:\n+    case FFI_TYPE_UINT64:\n+    case FFI_TYPE_DOUBLE:\n+#ifdef __LP64__\n+    case FFI_TYPE_POINTER:\n+#endif\n+      *(UINT64 *)out = *(UINT64 *)in;\n+      return sizeof(UINT64) / FFI_SIZEOF_ARG;\n+\n+    case FFI_TYPE_STRUCT:\n+      memcpy(out, in, type->size);\n+      return (type->size + FFI_SIZEOF_ARG - 1) / FFI_SIZEOF_ARG;\n+\n+    case FFI_TYPE_VOID:\n+      /* Must be a return type. Nothing to do. */\n+      return 0;\n+\n+    default:\n+      FFI_ASSERT(0);\n+      return -1;\n+    }\n+}\n+\n+\n+void\n+ffi_call(ffi_cif *cif, void (*fn)(void), void *rvalue, void **avalue)\n+{\n+  ffi_sarg * const arg_mem = alloca(cif->bytes);\n+  ffi_sarg * const reg_args = arg_mem;\n+  ffi_sarg * const stack_args = &reg_args[NUM_ARG_REGS];\n+  ffi_sarg *argp = arg_mem;\n+  ffi_type ** const arg_types = cif->arg_types;\n+  const long num_args = cif->nargs;\n+  long i;\n+\n+  if (cif->flags == FFI_TYPE_STRUCT)\n+    {\n+      /* Pass a hidden pointer to the return value. We make sure there\n+         is scratch space for the callee to store the return value even if\n+         our caller doesn't care about it. */\n+      *argp++ = (intptr_t)(rvalue ? rvalue : alloca(cif->rtype->size));\n+\n+      /* No more work needed to return anything. */\n+      rvalue = NULL;\n+    }\n+\n+  for (i = 0; i < num_args; i++)\n+    {\n+      ffi_type *type = arg_types[i];\n+      void * const arg_in = avalue[i];\n+      ptrdiff_t arg_word = argp - arg_mem;\n+\n+#ifndef __tilegx__\n+      /* Doubleword-aligned values are always in an even-number register\n+         pair, or doubleword-aligned stack slot if out of registers. */\n+      long align = arg_word & (type->alignment > FFI_SIZEOF_ARG);\n+      argp += align;\n+      arg_word += align;\n+#endif\n+\n+      if (type->type == FFI_TYPE_STRUCT)\n+        {\n+          const size_t arg_size_in_words =\n+            (type->size + FFI_SIZEOF_ARG - 1) / FFI_SIZEOF_ARG;\n+\n+          if (arg_word < NUM_ARG_REGS &&\n+              arg_word + arg_size_in_words > NUM_ARG_REGS)\n+            {\n+              /* Args are not allowed to span registers and the stack. */\n+              argp = stack_args;\n+            }\n+\n+          memcpy(argp, arg_in, type->size);\n+          argp += arg_size_in_words;\n+        }\n+      else\n+        {\n+          argp += assign_to_ffi_arg(argp, arg_in, arg_types[i], 1);\n+        }\n+    }\n+\n+  /* Actually do the call. */\n+  ffi_call_tile(reg_args, stack_args,\n+                cif->bytes - (NUM_ARG_REGS * FFI_SIZEOF_ARG), fn);\n+\n+  if (rvalue != NULL)\n+    assign_to_ffi_arg(rvalue, reg_args, cif->rtype, 0);\n+}\n+\n+\n+/* Template code for closure. */\n+extern const UINT64 ffi_template_tramp_tile[] FFI_HIDDEN;\n+\n+\n+ffi_status\n+ffi_prep_closure_loc (ffi_closure *closure,\n+                      ffi_cif *cif,\n+                      void (*fun)(ffi_cif*, void*, void**, void*),\n+                      void *user_data,\n+                      void *codeloc)\n+{\n+#ifdef __tilegx__\n+  /* TILE-Gx */\n+  SINT64 c;\n+  SINT64 h;\n+  int s;\n+  UINT64 *out;\n+\n+  if (cif->abi != FFI_UNIX)\n+    return FFI_BAD_ABI;\n+\n+  out = (UINT64 *)closure->tramp;\n+\n+  c = (intptr_t)closure;\n+  h = (intptr_t)ffi_closure_tile;\n+  s = 0;\n+\n+  /* Find the smallest shift count that doesn't lose information\n+     (i.e. no need to explicitly insert high bits of the address that\n+     are just the sign extension of the low bits). */\n+  while ((c >> s) != (SINT16)(c >> s) || (h >> s) != (SINT16)(h >> s))\n+    s += 16;\n+\n+#define OPS(a, b, shift) \\\n+  (create_Imm16_X0((a) >> (shift)) | create_Imm16_X1((b) >> (shift)))\n+\n+  /* Emit the moveli. */\n+  *out++ = ffi_template_tramp_tile[0] | OPS(c, h, s);\n+  for (s -= 16; s >= 0; s -= 16)\n+    *out++ = ffi_template_tramp_tile[1] | OPS(c, h, s);\n+\n+#undef OPS\n+\n+  *out++ = ffi_template_tramp_tile[2];\n+\n+#else\n+  /* TILEPro */\n+  UINT64 *out;\n+  intptr_t delta;\n+\n+  if (cif->abi != FFI_UNIX)\n+    return FFI_BAD_ABI;\n+\n+  out = (UINT64 *)closure->tramp;\n+  delta = (intptr_t)ffi_closure_tile - (intptr_t)codeloc;\n+\n+  *out++ = ffi_template_tramp_tile[0] | create_JOffLong_X1(delta >> 3);\n+#endif\n+\n+  closure->cif = cif;\n+  closure->fun = fun;\n+  closure->user_data = user_data;\n+\n+  invalidate_icache(closure->tramp, (char *)out - closure->tramp,\n+                    getpagesize());\n+\n+  return FFI_OK;\n+}\n+\n+\n+/* This is called by the assembly wrapper for closures. This does\n+   all of the work. On entry reg_args[0] holds the values the registers\n+   had when the closure was invoked. On return reg_args[1] holds the register\n+   values to be returned to the caller (many of which may be garbage). */\n+void FFI_HIDDEN\n+ffi_closure_tile_inner(ffi_closure *closure,\n+                       ffi_sarg reg_args[2][NUM_ARG_REGS],\n+                       ffi_sarg *stack_args)\n+{\n+  ffi_cif * const cif = closure->cif;\n+  void ** const avalue = alloca(cif->nargs * sizeof(void *));\n+  void *rvalue;\n+  ffi_type ** const arg_types = cif->arg_types;\n+  ffi_sarg * const reg_args_in = reg_args[0];\n+  ffi_sarg * const reg_args_out = reg_args[1];\n+  ffi_sarg * argp;\n+  long i, arg_word, nargs = cif->nargs;\n+  /* Use a union to guarantee proper alignment for double. */\n+  union { ffi_sarg arg[NUM_ARG_REGS]; double d; UINT64 u64; } closure_ret;\n+\n+  /* Start out reading register arguments. */\n+  argp = reg_args_in;\n+\n+  /* Copy the caller's structure return address to that the closure\n+     returns the data directly to the caller.  */\n+  if (cif->flags == FFI_TYPE_STRUCT)\n+    {\n+      /* Return by reference via hidden pointer. */\n+      rvalue = (void *)(intptr_t)*argp++;\n+      arg_word = 1;\n+    }\n+  else\n+    {\n+      /* Return the value in registers. */\n+      rvalue = &closure_ret;\n+      arg_word = 0;\n+    }\n+\n+  /* Grab the addresses of the arguments. */\n+  for (i = 0; i < nargs; i++)\n+    {\n+      ffi_type * const type = arg_types[i];\n+      const size_t arg_size_in_words =\n+        (type->size + FFI_SIZEOF_ARG - 1) / FFI_SIZEOF_ARG;\n+\n+#ifndef __tilegx__\n+      /* Doubleword-aligned values are always in an even-number register\n+         pair, or doubleword-aligned stack slot if out of registers. */\n+      long align = arg_word & (type->alignment > FFI_SIZEOF_ARG);\n+      argp += align;\n+      arg_word += align;\n+#endif\n+\n+      if (arg_word == NUM_ARG_REGS ||\n+          (arg_word < NUM_ARG_REGS &&\n+           arg_word + arg_size_in_words > NUM_ARG_REGS))\n+        {\n+          /* Switch to reading arguments from the stack. */\n+          argp = stack_args;\n+          arg_word = NUM_ARG_REGS;\n+        }\n+\n+      avalue[i] = argp;\n+      argp += arg_size_in_words;\n+      arg_word += arg_size_in_words;\n+    }\n+\n+  /* Invoke the closure.  */\n+  closure->fun(cif, rvalue, avalue, closure->user_data);\n+\n+  if (cif->flags != FFI_TYPE_STRUCT)\n+    {\n+      /* Canonicalize for register representation. */\n+      assign_to_ffi_arg(reg_args_out, &closure_ret, cif->rtype, 1);\n+    }\n+}"}, {"sha": "679fb5d904b4a13e0fc06fb388803b4d94b71913", "filename": "libffi/src/tile/ffitarget.h", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Fsrc%2Ftile%2Fffitarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Fsrc%2Ftile%2Fffitarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Ftile%2Fffitarget.h?ref=b4b575ce7854f4a49de8de93f38b7639e01b040b", "patch": "@@ -0,0 +1,65 @@\n+/* -----------------------------------------------------------------*-C-*-\n+   ffitarget.h - Copyright (c) 2012 Tilera Corp.\n+   Target configuration macros for TILE.\n+\n+   Permission is hereby granted, free of charge, to any person obtaining\n+   a copy of this software and associated documentation files (the\n+   ``Software''), to deal in the Software without restriction, including\n+   without limitation the rights to use, copy, modify, merge, publish,\n+   distribute, sublicense, and/or sell copies of the Software, and to\n+   permit persons to whom the Software is furnished to do so, subject to\n+   the following conditions:\n+\n+   The above copyright notice and this permission notice shall be included\n+   in all copies or substantial portions of the Software.\n+\n+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,\n+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n+   DEALINGS IN THE SOFTWARE.\n+   ----------------------------------------------------------------------- */\n+\n+#ifndef LIBFFI_TARGET_H\n+#define LIBFFI_TARGET_H\n+\n+#ifndef LIBFFI_H\n+#error \"Please do not include ffitarget.h directly into your source.  Use ffi.h instead.\"\n+#endif\n+\n+#ifndef LIBFFI_ASM\n+\n+#include <arch/abi.h>\n+\n+typedef uint_reg_t ffi_arg;\n+typedef int_reg_t  ffi_sarg;\n+\n+typedef enum ffi_abi {\n+  FFI_FIRST_ABI = 0,\n+  FFI_UNIX,\n+  FFI_LAST_ABI,\n+  FFI_DEFAULT_ABI = FFI_UNIX\n+} ffi_abi;\n+#endif\n+\n+/* ---- Definitions for closures ----------------------------------------- */\n+#define FFI_CLOSURES 1\n+\n+#ifdef __tilegx__\n+/* We always pass 8-byte values, even in -m32 mode. */\n+# define FFI_SIZEOF_ARG 8\n+# ifdef __LP64__\n+#  define FFI_TRAMPOLINE_SIZE (8 * 5)  /* 5 bundles */\n+# else\n+#  define FFI_TRAMPOLINE_SIZE (8 * 3)  /* 3 bundles */\n+# endif\n+#else\n+# define FFI_SIZEOF_ARG 4\n+# define FFI_TRAMPOLINE_SIZE 8 /* 1 bundle */\n+#endif\n+#define FFI_NATIVE_RAW_API 0\n+\n+#endif"}, {"sha": "a186e1f8f0084f135fc20e275c86f532cbdd7894", "filename": "libffi/src/tile/tile.S", "status": "added", "additions": 360, "deletions": 0, "changes": 360, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Fsrc%2Ftile%2Ftile.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Fsrc%2Ftile%2Ftile.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Ftile%2Ftile.S?ref=b4b575ce7854f4a49de8de93f38b7639e01b040b", "patch": "@@ -0,0 +1,360 @@\n+/* -----------------------------------------------------------------------\n+   tile.S - Copyright (c) 2011 Tilera Corp.\n+\n+   Tilera TILEPro and TILE-Gx Foreign Function Interface\n+\n+   Permission is hereby granted, free of charge, to any person obtaining\n+   a copy of this software and associated documentation files (the\n+   ``Software''), to deal in the Software without restriction, including\n+   without limitation the rights to use, copy, modify, merge, publish,\n+   distribute, sublicense, and/or sell copies of the Software, and to\n+   permit persons to whom the Software is furnished to do so, subject to\n+   the following conditions:\n+\n+   The above copyright notice and this permission notice shall be included\n+   in all copies or substantial portions of the Software.\n+\n+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,\n+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n+   DEALINGS IN THE SOFTWARE.\n+   ----------------------------------------------------------------------- */\n+\n+#define LIBFFI_ASM\n+#include <fficonfig.h>\n+#include <ffi.h>\n+\n+/* Number of bytes in a register. */\n+#define REG_SIZE FFI_SIZEOF_ARG\n+\n+/* Number of bytes in stack linkage area for backtracing.\n+\n+   A note about the ABI: on entry to a procedure, sp points to a stack\n+   slot where it must spill the return address if it's not a leaf.\n+   REG_SIZE bytes beyond that is a slot owned by the caller which\n+   contains the sp value that the caller had when it was originally\n+   entered (i.e. the caller's frame pointer). */\n+#define LINKAGE_SIZE (2 * REG_SIZE)\n+\n+/* The first 10 registers are used to pass arguments and return values. */\n+#define NUM_ARG_REGS 10\n+\n+#ifdef __tilegx__\n+#define SW st\n+#define LW ld\n+#define BGZT bgtzt\n+#else\n+#define SW sw\n+#define LW lw\n+#define BGZT bgzt\n+#endif\n+\n+\n+/* void ffi_call_tile (int_reg_t reg_args[NUM_ARG_REGS],\n+                       const int_reg_t *stack_args,\n+                       unsigned long stack_args_bytes,\n+                       void (*fnaddr)(void));\n+\n+        On entry, REG_ARGS contain the outgoing register values,\n+        and STACK_ARGS containts STACK_ARG_BYTES of additional values\n+        to be passed on the stack. If STACK_ARG_BYTES is zero, then\n+        STACK_ARGS is ignored.\n+\n+        When the invoked function returns, the values of r0-r9 are\n+        blindly stored back into REG_ARGS for the caller to examine. */\n+\n+        .section .text.ffi_call_tile, \"ax\", @progbits\n+        .align  8\n+        .globl  ffi_call_tile\n+        FFI_HIDDEN(ffi_call_tile)\n+ffi_call_tile:\n+\n+/* Incoming arguments. */\n+#define REG_ARGS                r0\n+#define INCOMING_STACK_ARGS     r1\n+#define STACK_ARG_BYTES         r2\n+#define ORIG_FNADDR             r3\n+\n+/* Temporary values. */\n+#define FRAME_SIZE              r10\n+#define TMP                     r11\n+#define TMP2                    r12\n+#define OUTGOING_STACK_ARGS     r13\n+#define REG_ADDR_PTR            r14\n+#define RETURN_REG_ADDR         r15\n+#define FNADDR                  r16\n+\n+        .cfi_startproc\n+        {\n+         /* Save return address. */\n+         SW     sp, lr\n+         .cfi_offset lr, 0\n+         /* Prepare to spill incoming r52. */\n+         addi   TMP, sp, -REG_SIZE\n+         /* Increase frame size to have room to spill r52 and REG_ARGS.\n+            The +7 is to round up mod 8. */\n+         addi   FRAME_SIZE, STACK_ARG_BYTES, \\\n+                REG_SIZE + REG_SIZE + LINKAGE_SIZE + 7\n+        }\n+        {\n+         /* Round stack frame size to a multiple of 8 to satisfy ABI. */\n+         andi   FRAME_SIZE, FRAME_SIZE, -8\n+         /* Compute where to spill REG_ARGS value. */\n+         addi   TMP2, sp, -(REG_SIZE * 2)\n+        }\n+        {\n+         /* Spill incoming r52. */\n+         SW     TMP, r52\n+         .cfi_offset r52, -REG_SIZE\n+         /* Set up our frame pointer. */\n+         move   r52, sp\n+         .cfi_def_cfa_register r52\n+         /* Push stack frame. */\n+         sub    sp, sp, FRAME_SIZE\n+        }\n+        {\n+         /* Prepare to set up stack linkage. */\n+         addi   TMP, sp, REG_SIZE\n+         /* Prepare to memcpy stack args. */\n+         addi   OUTGOING_STACK_ARGS, sp, LINKAGE_SIZE\n+         /* Save REG_ARGS which we will need after we call the subroutine. */\n+         SW     TMP2, REG_ARGS\n+        }\n+        {\n+         /* Set up linkage info to hold incoming stack pointer. */\n+         SW     TMP, r52\n+        }\n+        {\n+         /* Skip stack args memcpy if we don't have any stack args (common). */\n+         blezt  STACK_ARG_BYTES, .Ldone_stack_args_memcpy\n+        }\n+\n+.Lmemcpy_stack_args:\n+        {\n+         /* Load incoming argument from stack_args. */\n+         LW     TMP, INCOMING_STACK_ARGS\n+         addi   INCOMING_STACK_ARGS, INCOMING_STACK_ARGS, REG_SIZE\n+        }\n+        {\n+         /* Store stack argument into outgoing stack argument area. */\n+         SW     OUTGOING_STACK_ARGS, TMP\n+         addi   OUTGOING_STACK_ARGS, OUTGOING_STACK_ARGS, REG_SIZE\n+         addi   STACK_ARG_BYTES, STACK_ARG_BYTES, -REG_SIZE\n+        }\n+        {\n+         BGZT   STACK_ARG_BYTES, .Lmemcpy_stack_args\n+        }\n+.Ldone_stack_args_memcpy:\n+\n+        {\n+         /* Copy aside ORIG_FNADDR so we can overwrite its register. */\n+         move   FNADDR, ORIG_FNADDR\n+         /* Prepare to load argument registers. */\n+         addi   REG_ADDR_PTR, r0, REG_SIZE\n+         /* Load outgoing r0. */\n+         LW     r0, r0\n+        }\n+\n+        /* Load up argument registers from the REG_ARGS array. */\n+#define LOAD_REG(REG, PTR) \\\n+        { \\\n+         LW     REG, PTR ; \\\n+         addi   PTR, PTR, REG_SIZE \\\n+        }\n+\n+        LOAD_REG(r1, REG_ADDR_PTR)\n+        LOAD_REG(r2, REG_ADDR_PTR)\n+        LOAD_REG(r3, REG_ADDR_PTR)\n+        LOAD_REG(r4, REG_ADDR_PTR)\n+        LOAD_REG(r5, REG_ADDR_PTR)\n+        LOAD_REG(r6, REG_ADDR_PTR)\n+        LOAD_REG(r7, REG_ADDR_PTR)\n+        LOAD_REG(r8, REG_ADDR_PTR)\n+        LOAD_REG(r9, REG_ADDR_PTR)\n+\n+        {\n+         /* Call the subroutine. */\n+         jalr   FNADDR\n+        }\n+\n+        {\n+         /* Restore original lr. */\n+         LW     lr, r52\n+         /* Prepare to recover ARGS, which we spilled earlier. */\n+         addi   TMP, r52, -(2 * REG_SIZE)\n+        }\n+        {\n+         /* Restore ARGS, so we can fill it in with the return regs r0-r9. */\n+         LW     RETURN_REG_ADDR, TMP\n+         /* Prepare to restore original r52. */\n+         addi   TMP, r52, -REG_SIZE\n+        }\n+\n+        {\n+         /* Pop stack frame. */\n+         move   sp, r52\n+         /* Restore original r52. */\n+         LW     r52, TMP\n+        }\n+\n+#define STORE_REG(REG, PTR) \\\n+        { \\\n+         SW     PTR, REG ; \\\n+         addi   PTR, PTR, REG_SIZE \\\n+        }\n+\n+        /* Return all register values by reference. */\n+        STORE_REG(r0, RETURN_REG_ADDR)\n+        STORE_REG(r1, RETURN_REG_ADDR)\n+        STORE_REG(r2, RETURN_REG_ADDR)\n+        STORE_REG(r3, RETURN_REG_ADDR)\n+        STORE_REG(r4, RETURN_REG_ADDR)\n+        STORE_REG(r5, RETURN_REG_ADDR)\n+        STORE_REG(r6, RETURN_REG_ADDR)\n+        STORE_REG(r7, RETURN_REG_ADDR)\n+        STORE_REG(r8, RETURN_REG_ADDR)\n+        STORE_REG(r9, RETURN_REG_ADDR)\n+\n+        {\n+         jrp    lr\n+        }\n+\n+        .cfi_endproc\n+        .size ffi_call_tile, .-ffi_call_tile\n+\n+/* ffi_closure_tile(...)\n+\n+   On entry, lr points to the closure plus 8 bytes, and r10\n+   contains the actual return address.\n+\n+   This function simply dumps all register parameters into a stack array\n+   and passes the closure, the registers array, and the stack arguments\n+   to C code that does all of the actual closure processing. */\n+\n+        .section .text.ffi_closure_tile, \"ax\", @progbits\n+        .align  8\n+        .globl  ffi_closure_tile\n+        FFI_HIDDEN(ffi_closure_tile)\n+\n+        .cfi_startproc\n+/* Room to spill all NUM_ARG_REGS incoming registers, plus frame linkage. */\n+#define CLOSURE_FRAME_SIZE (((NUM_ARG_REGS * REG_SIZE * 2 + LINKAGE_SIZE) + 7) & -8)\n+ffi_closure_tile:\n+        {\n+#ifdef __tilegx__\n+         st     sp, lr\n+         .cfi_offset lr, 0\n+#else\n+         /* Save return address (in r10 due to closure stub wrapper). */\n+         SW     sp, r10\n+         .cfi_return_column r10\n+         .cfi_offset r10, 0\n+#endif\n+         /* Compute address for stack frame linkage. */\n+         addli   r10, sp, -(CLOSURE_FRAME_SIZE - REG_SIZE)\n+        }\n+        {\n+         /* Save incoming stack pointer in linkage area. */\n+         SW     r10, sp\n+         .cfi_offset sp, -(CLOSURE_FRAME_SIZE - REG_SIZE)\n+         /* Push a new stack frame. */\n+         addli   sp, sp, -CLOSURE_FRAME_SIZE\n+         .cfi_adjust_cfa_offset CLOSURE_FRAME_SIZE\n+        }\n+\n+        {\n+         /* Create pointer to where to start spilling registers. */\n+         addi   r10, sp, LINKAGE_SIZE\n+        }\n+\n+        /* Spill all the incoming registers. */\n+        STORE_REG(r0, r10)\n+        STORE_REG(r1, r10)\n+        STORE_REG(r2, r10)\n+        STORE_REG(r3, r10)\n+        STORE_REG(r4, r10)\n+        STORE_REG(r5, r10)\n+        STORE_REG(r6, r10)\n+        STORE_REG(r7, r10)\n+        STORE_REG(r8, r10)\n+        {\n+         /* Save r9. */\n+         SW     r10, r9\n+#ifdef __tilegx__\n+         /* Pointer to closure is passed in r11. */\n+         move  r0, r11\n+#else\n+         /* Compute pointer to the closure object. Because the closure\n+            starts with a \"jal ffi_closure_tile\", we can just take the\n+            value of lr (a phony return address pointing into the closure)\n+            and subtract 8. */\n+         addi   r0, lr, -8\n+#endif\n+         /* Compute a pointer to the register arguments we just spilled. */\n+         addi   r1, sp, LINKAGE_SIZE\n+        }\n+        {\n+         /* Compute a pointer to the extra stack arguments (if any). */\n+         addli   r2, sp, CLOSURE_FRAME_SIZE + LINKAGE_SIZE\n+         /* Call C code to deal with all of the grotty details. */\n+         jal    ffi_closure_tile_inner\n+        }\n+        {\n+         addli   r10, sp, CLOSURE_FRAME_SIZE\n+        }\n+        {\n+         /* Restore the return address. */\n+         LW     lr, r10\n+         /* Compute pointer to registers array. */\n+         addli   r10, sp, LINKAGE_SIZE + (NUM_ARG_REGS * REG_SIZE)\n+        }\n+        /* Return all the register values, which C code may have set. */\n+        LOAD_REG(r0, r10)\n+        LOAD_REG(r1, r10)\n+        LOAD_REG(r2, r10)\n+        LOAD_REG(r3, r10)\n+        LOAD_REG(r4, r10)\n+        LOAD_REG(r5, r10)\n+        LOAD_REG(r6, r10)\n+        LOAD_REG(r7, r10)\n+        LOAD_REG(r8, r10)\n+        LOAD_REG(r9, r10)\n+        {\n+         /* Pop the frame. */\n+         addli   sp, sp, CLOSURE_FRAME_SIZE\n+         jrp    lr\n+        }\n+\n+        .cfi_endproc\n+        .size   ffi_closure_tile, . - ffi_closure_tile\n+\n+\n+/* What follows are code template instructions that get copied to the\n+   closure trampoline by ffi_prep_closure_loc.  The zeroed operands\n+   get replaced by their proper values at runtime. */\n+\n+        .section .text.ffi_template_tramp_tile, \"ax\", @progbits\n+        .align  8\n+        .globl  ffi_template_tramp_tile\n+        FFI_HIDDEN(ffi_template_tramp_tile)\n+ffi_template_tramp_tile:\n+#ifdef __tilegx__\n+        {\n+          moveli r11, 0 /* backpatched to address of containing closure. */\n+          moveli r10, 0 /* backpatched to ffi_closure_tile. */\n+        }\n+        /* Note: the following bundle gets generated multiple times\n+           depending on the pointer value (esp. useful for -m32 mode). */\n+        { shl16insli r11, r11, 0 ; shl16insli r10, r10, 0 }\n+        { info 2+8 /* for backtracer: -> pc in lr, frame size 0 */ ; jr r10 }\n+#else\n+        /* 'jal .' yields a PC-relative offset of zero so we can OR in the\n+           right offset at runtime. */\n+        { move r10, lr ; jal . /* ffi_closure_tile */ }\n+#endif\n+\n+        .size   ffi_template_tramp_tile, . - ffi_template_tramp_tile"}, {"sha": "611e22197169a65b90f8eae1556fe83c04499be1", "filename": "libffi/src/x86/ffi.c", "status": "modified", "additions": 23, "deletions": 6, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Fsrc%2Fx86%2Fffi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Fsrc%2Fx86%2Fffi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fx86%2Fffi.c?ref=b4b575ce7854f4a49de8de93f38b7639e01b040b", "patch": "@@ -58,7 +58,8 @@ void ffi_prep_args(char *stack, extended_cif *ecif)\n \n   argp = stack;\n \n-  if (ecif->cif->flags == FFI_TYPE_STRUCT\n+  if ((ecif->cif->flags == FFI_TYPE_STRUCT\n+       || ecif->cif->flags == FFI_TYPE_MS_STRUCT)\n #ifdef X86_WIN64\n       && (ecif->cif->rtype->size != 1 && ecif->cif->rtype->size != 2\n           && ecif->cif->rtype->size != 4 && ecif->cif->rtype->size != 8)\n@@ -279,7 +280,12 @@ ffi_status ffi_prep_cif_machdep(ffi_cif *cif)\n       else\n #endif\n         {\n-          cif->flags = FFI_TYPE_STRUCT;\n+#ifdef X86_WIN32\n+          if (cif->abi == FFI_MS_CDECL)\n+            cif->flags = FFI_TYPE_MS_STRUCT;\n+          else\n+#endif\n+            cif->flags = FFI_TYPE_STRUCT;\n           /* allocate space for return value pointer */\n           cif->bytes += ALIGN(sizeof(void*), FFI_SIZEOF_ARG);\n         }\n@@ -349,7 +355,8 @@ void ffi_call(ffi_cif *cif, void (*fn)(void), void *rvalue, void **avalue)\n     }\n #else\n   if (rvalue == NULL\n-      && cif->flags == FFI_TYPE_STRUCT)\n+      && (cif->flags == FFI_TYPE_STRUCT\n+          || cif->flags == FFI_TYPE_MS_STRUCT))\n     {\n       ecif.rvalue = alloca(cif->rtype->size);\n     }\n@@ -368,6 +375,7 @@ void ffi_call(ffi_cif *cif, void (*fn)(void), void *rvalue, void **avalue)\n #elif defined(X86_WIN32)\n     case FFI_SYSV:\n     case FFI_STDCALL:\n+    case FFI_MS_CDECL:\n       ffi_call_win32(ffi_prep_args, &ecif, cif->abi, cif->bytes, cif->flags,\n \t\t     ecif.rvalue, fn);\n       break;\n@@ -513,7 +521,8 @@ ffi_prep_incoming_args_SYSV(char *stack, void **rvalue, void **avalue,\n     argp += sizeof(void *);\n   }\n #else\n-  if ( cif->flags == FFI_TYPE_STRUCT ) {\n+  if ( cif->flags == FFI_TYPE_STRUCT\n+       || cif->flags == FFI_TYPE_MS_STRUCT ) {\n     *rvalue = *(void **) argp;\n     argp += sizeof(void *);\n   }\n@@ -673,6 +682,12 @@ ffi_prep_closure_loc (ffi_closure* closure,\n                                    &ffi_closure_STDCALL,\n                                    (void*)codeloc, cif->bytes);\n     }\n+  else if (cif->abi == FFI_MS_CDECL)\n+    {\n+      FFI_INIT_TRAMPOLINE (&closure->tramp[0],\n+                           &ffi_closure_SYSV,\n+                           (void*)codeloc);\n+    }\n #endif /* X86_WIN32 */\n #endif /* !X86_WIN64 */\n   else\n@@ -762,8 +777,9 @@ ffi_raw_call(ffi_cif *cif, void (*fn)(void), void *rvalue, ffi_raw *fake_avalue)\n   /* If the return value is a struct and we don't have a return */\n   /* value address then we need to make one                     */\n \n-  if ((rvalue == NULL) && \n-      (cif->rtype->type == FFI_TYPE_STRUCT))\n+  if (rvalue == NULL\n+      && (cif->flags == FFI_TYPE_STRUCT\n+          || cif->flags == FFI_TYPE_MS_STRUCT))\n     {\n       ecif.rvalue = alloca(cif->rtype->size);\n     }\n@@ -776,6 +792,7 @@ ffi_raw_call(ffi_cif *cif, void (*fn)(void), void *rvalue, ffi_raw *fake_avalue)\n #ifdef X86_WIN32\n     case FFI_SYSV:\n     case FFI_STDCALL:\n+    case FFI_MS_CDECL:\n       ffi_call_win32(ffi_prep_args_raw, &ecif, cif->abi, cif->bytes, cif->flags,\n \t\t     ecif.rvalue, fn);\n       break;"}, {"sha": "1daa1c0b6fd84ea47acd27a1d16047265ee980eb", "filename": "libffi/src/x86/ffi64.c", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Fsrc%2Fx86%2Fffi64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Fsrc%2Fx86%2Fffi64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fx86%2Fffi64.c?ref=b4b575ce7854f4a49de8de93f38b7639e01b040b", "patch": "@@ -37,11 +37,17 @@\n #define MAX_GPR_REGS 6\n #define MAX_SSE_REGS 8\n \n+#ifdef __INTEL_COMPILER\n+#define UINT128 __m128\n+#else\n+#define UINT128 __int128_t\n+#endif\n+\n struct register_args\n {\n   /* Registers for argument passing.  */\n   UINT64 gpr[MAX_GPR_REGS];\n-  __int128_t sse[MAX_SSE_REGS];\n+  UINT128 sse[MAX_SSE_REGS];\n };\n \n extern void ffi_call_unix64 (void *args, unsigned long bytes, unsigned flags,"}, {"sha": "46f294cea723d2560ad7b848bce74ab751e1c919", "filename": "libffi/src/x86/ffitarget.h", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Fsrc%2Fx86%2Fffitarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Fsrc%2Fx86%2Fffitarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fx86%2Fffitarget.h?ref=b4b575ce7854f4a49de8de93f38b7639e01b040b", "patch": "@@ -81,9 +81,13 @@ typedef enum ffi_abi {\n   FFI_STDCALL,\n   FFI_THISCALL,\n   FFI_FASTCALL,\n+  FFI_MS_CDECL,\n   FFI_LAST_ABI,\n-  /* TODO: Add fastcall support for the sake of completeness */\n+#ifdef _MSC_VER\n+  FFI_DEFAULT_ABI = FFI_MS_CDECL\n+#else\n   FFI_DEFAULT_ABI = FFI_SYSV\n+#endif\n \n #elif defined(X86_WIN64)\n   FFI_WIN64,\n@@ -110,6 +114,7 @@ typedef enum ffi_abi {\n #define FFI_TYPE_SMALL_STRUCT_1B (FFI_TYPE_LAST + 1)\n #define FFI_TYPE_SMALL_STRUCT_2B (FFI_TYPE_LAST + 2)\n #define FFI_TYPE_SMALL_STRUCT_4B (FFI_TYPE_LAST + 3)\n+#define FFI_TYPE_MS_STRUCT       (FFI_TYPE_LAST + 4)\n \n #if defined (X86_64) || (defined (__x86_64__) && defined (X86_DARWIN))\n #define FFI_TRAMPOLINE_SIZE 24"}, {"sha": "24b7bbd04235b6aa6c79848343aa8b21ad1a9078", "filename": "libffi/src/x86/win32.S", "status": "modified", "additions": 111, "deletions": 57, "changes": 168, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Fsrc%2Fx86%2Fwin32.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Fsrc%2Fx86%2Fwin32.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fx86%2Fwin32.S?ref=b4b575ce7854f4a49de8de93f38b7639e01b040b", "patch": "@@ -108,31 +108,37 @@ ca_jumpdata:\n         dd offset ca_retfloat       ;; FFI_TYPE_FLOAT\n         dd offset ca_retdouble      ;; FFI_TYPE_DOUBLE\n         dd offset ca_retlongdouble  ;; FFI_TYPE_LONGDOUBLE\n-        dd offset ca_retint8        ;; FFI_TYPE_UINT8\n-        dd offset ca_retint8        ;; FFI_TYPE_SINT8\n-        dd offset ca_retint16       ;; FFI_TYPE_UINT16\n-        dd offset ca_retint16       ;; FFI_TYPE_SINT16\n+        dd offset ca_retuint8       ;; FFI_TYPE_UINT8\n+        dd offset ca_retsint8       ;; FFI_TYPE_SINT8\n+        dd offset ca_retuint16      ;; FFI_TYPE_UINT16\n+        dd offset ca_retsint16      ;; FFI_TYPE_SINT16\n         dd offset ca_retint         ;; FFI_TYPE_UINT32\n         dd offset ca_retint         ;; FFI_TYPE_SINT32\n         dd offset ca_retint64       ;; FFI_TYPE_UINT64\n         dd offset ca_retint64       ;; FFI_TYPE_SINT64\n         dd offset ca_epilogue       ;; FFI_TYPE_STRUCT\n         dd offset ca_retint         ;; FFI_TYPE_POINTER\n-        dd offset ca_retint8        ;; FFI_TYPE_SMALL_STRUCT_1B\n-        dd offset ca_retint16       ;; FFI_TYPE_SMALL_STRUCT_2B\n+        dd offset ca_retstruct1b    ;; FFI_TYPE_SMALL_STRUCT_1B\n+        dd offset ca_retstruct2b    ;; FFI_TYPE_SMALL_STRUCT_2B\n         dd offset ca_retint         ;; FFI_TYPE_SMALL_STRUCT_4B\n+        dd offset ca_epilogue       ;; FFI_TYPE_MS_STRUCT\n \n-ca_retint8:\n-        ;; Load %ecx with the pointer to storage for the return value\n-        mov   ecx, rvalue\n-        mov   [ecx + 0], al\n-        jmp   ca_epilogue\n+        /* Sign/zero extend as appropriate.  */\n+ca_retuint8:\n+        movzx eax, al\n+        jmp   ca_retint\n \n-ca_retint16:\n-        ;; Load %ecx with the pointer to storage for the return value\n-        mov   ecx, rvalue\n-        mov   [ecx + 0], ax\n-        jmp   ca_epilogue\n+ca_retsint8:\n+        movsx eax, al\n+        jmp   ca_retint\n+\n+ca_retuint16:\n+        movzx eax, ax\n+        jmp   ca_retint\n+\n+ca_retsint16:\n+        movsx eax, ax\n+        jmp   ca_retint\n \n ca_retint:\n         ;; Load %ecx with the pointer to storage for the return value\n@@ -165,14 +171,24 @@ ca_retlongdouble:\n         fstp  TBYTE PTR [ecx]\n         jmp   ca_epilogue\n \n+ca_retstruct1b:\n+        ;; Load %ecx with the pointer to storage for the return value\n+        mov   ecx, rvalue\n+        mov   [ecx + 0], al\n+        jmp   ca_epilogue\n+\n+ca_retstruct2b:\n+        ;; Load %ecx with the pointer to storage for the return value\n+        mov   ecx, rvalue\n+        mov   [ecx + 0], ax\n+        jmp   ca_epilogue\n+\n ca_epilogue:\n         ;; Epilogue code is autogenerated.\n         ret\n ffi_call_win32 ENDP\n \n ffi_closure_THISCALL PROC NEAR FORCEFRAME\n-\tpush\tebp\n-\tmov\tebp, esp\n \tsub\tesp, 40\n \tlea\tedx, [ebp -24]\n \tmov\t[ebp - 12], edx\t/* resp */\n@@ -187,7 +203,7 @@ ffi_closure_SYSV PROC NEAR FORCEFRAME\n         lea  edx, [ebp - 24]\n         mov  [ebp - 12], edx         ;; resp\n         lea  edx, [ebp + 8]\n-stub:\n+stub::\n         mov  [esp + 8], edx          ;; args\n         lea  edx, [ebp - 12]\n         mov  [esp + 4], edx          ;; &resp\n@@ -204,26 +220,35 @@ cs_jumpdata:\n         dd offset cs_retfloat       ;; FFI_TYPE_FLOAT\n         dd offset cs_retdouble      ;; FFI_TYPE_DOUBLE\n         dd offset cs_retlongdouble  ;; FFI_TYPE_LONGDOUBLE\n-        dd offset cs_retint8        ;; FFI_TYPE_UINT8\n-        dd offset cs_retint8        ;; FFI_TYPE_SINT8\n-        dd offset cs_retint16       ;; FFI_TYPE_UINT16\n-        dd offset cs_retint16       ;; FFI_TYPE_SINT16\n+        dd offset cs_retuint8       ;; FFI_TYPE_UINT8\n+        dd offset cs_retsint8       ;; FFI_TYPE_SINT8\n+        dd offset cs_retuint16      ;; FFI_TYPE_UINT16\n+        dd offset cs_retsint16      ;; FFI_TYPE_SINT16\n         dd offset cs_retint         ;; FFI_TYPE_UINT32\n         dd offset cs_retint         ;; FFI_TYPE_SINT32\n         dd offset cs_retint64       ;; FFI_TYPE_UINT64\n         dd offset cs_retint64       ;; FFI_TYPE_SINT64\n         dd offset cs_retstruct      ;; FFI_TYPE_STRUCT\n         dd offset cs_retint         ;; FFI_TYPE_POINTER\n-        dd offset cs_retint8        ;; FFI_TYPE_SMALL_STRUCT_1B\n-        dd offset cs_retint16       ;; FFI_TYPE_SMALL_STRUCT_2B\n+        dd offset cs_retsint8       ;; FFI_TYPE_SMALL_STRUCT_1B\n+        dd offset cs_retsint16      ;; FFI_TYPE_SMALL_STRUCT_2B\n         dd offset cs_retint         ;; FFI_TYPE_SMALL_STRUCT_4B\n+        dd offset cs_retmsstruct    ;; FFI_TYPE_MS_STRUCT\n+\n+cs_retuint8:\n+        movzx eax, BYTE PTR [ecx]\n+        jmp   cs_epilogue\n+\n+cs_retsint8:\n+        movsx eax, BYTE PTR [ecx]\n+        jmp   cs_epilogue\n \n-cs_retint8:\n-        mov   al, [ecx]\n+cs_retuint16:\n+        movzx eax, WORD PTR [ecx]\n         jmp   cs_epilogue\n \n-cs_retint16:\n-        mov   ax, [ecx]\n+cs_retsint16:\n+        movsx eax, WORD PTR [ecx]\n         jmp   cs_epilogue\n \n cs_retint:\n@@ -252,6 +277,12 @@ cs_retstruct:\n         ;; Epilogue code is autogenerated.\n         ret\t4\n \n+cs_retmsstruct:\n+        ;; Caller expects us to return a pointer to the real return value.\n+        mov   eax, ecx\n+        ;; Caller doesn't expects us to pop struct return value pointer hidden arg.\n+        jmp   cs_epilogue\n+\n cs_epilogue:\n         ;; Epilogue code is autogenerated.\n         ret\n@@ -264,27 +295,24 @@ ffi_closure_SYSV ENDP\n #define RAW_CLOSURE_USER_DATA_OFFSET (RAW_CLOSURE_FUN_OFFSET + 4)\n #define CIF_FLAGS_OFFSET 20\n \n-ffi_closure_raw_THISCALL PROC NEAR\n-\tpush ebp\n-\tmov  ebp, esp\n-\tpush esi\n+ffi_closure_raw_THISCALL PROC NEAR USES esi FORCEFRAME\n \tsub esp, 36\n \tmov  esi, [eax + RAW_CLOSURE_CIF_OFFSET]        ;; closure->cif\n \tmov  edx, [eax + RAW_CLOSURE_USER_DATA_OFFSET]  ;; closure->user_data\n \tmov [esp + 12], edx\n-\tlea edx, [ebp + 12], edx\n+\tlea edx, [ebp + 12]\n \tjmp stubraw\n-ffi_closure_raw_SYSV ENDP\n+ffi_closure_raw_THISCALL ENDP\n \n-ffi_closure_raw_SYSV PROC NEAR USES esi\n+ffi_closure_raw_SYSV PROC NEAR USES esi FORCEFRAME\n     ;; the ffi_closure ctx is passed in eax by the trampoline.\n \n         sub  esp, 40\n         mov  esi, [eax + RAW_CLOSURE_CIF_OFFSET]        ;; closure->cif\n         mov  edx, [eax + RAW_CLOSURE_USER_DATA_OFFSET]  ;; closure->user_data\n         mov  [esp + 12], edx                            ;; user_data\n         lea  edx, [ebp + 8]\n-stubraw:\n+stubraw::\n         mov  [esp + 8], edx                             ;; raw_args\n         lea  edx, [ebp - 24]\n         mov  [esp + 4], edx                             ;; &res\n@@ -302,26 +330,35 @@ cr_jumpdata:\n         dd offset cr_retfloat       ;; FFI_TYPE_FLOAT\n         dd offset cr_retdouble      ;; FFI_TYPE_DOUBLE\n         dd offset cr_retlongdouble  ;; FFI_TYPE_LONGDOUBLE\n-        dd offset cr_retint8        ;; FFI_TYPE_UINT8\n-        dd offset cr_retint8        ;; FFI_TYPE_SINT8\n-        dd offset cr_retint16       ;; FFI_TYPE_UINT16\n-        dd offset cr_retint16       ;; FFI_TYPE_SINT16\n+        dd offset cr_retuint8       ;; FFI_TYPE_UINT8\n+        dd offset cr_retsint8       ;; FFI_TYPE_SINT8\n+        dd offset cr_retuint16      ;; FFI_TYPE_UINT16\n+        dd offset cr_retsint16      ;; FFI_TYPE_SINT16\n         dd offset cr_retint         ;; FFI_TYPE_UINT32\n         dd offset cr_retint         ;; FFI_TYPE_SINT32\n         dd offset cr_retint64       ;; FFI_TYPE_UINT64\n         dd offset cr_retint64       ;; FFI_TYPE_SINT64\n         dd offset cr_epilogue       ;; FFI_TYPE_STRUCT\n         dd offset cr_retint         ;; FFI_TYPE_POINTER\n-        dd offset cr_retint8        ;; FFI_TYPE_SMALL_STRUCT_1B\n-        dd offset cr_retint16       ;; FFI_TYPE_SMALL_STRUCT_2B\n+        dd offset cr_retsint8       ;; FFI_TYPE_SMALL_STRUCT_1B\n+        dd offset cr_retsint16      ;; FFI_TYPE_SMALL_STRUCT_2B\n         dd offset cr_retint         ;; FFI_TYPE_SMALL_STRUCT_4B\n+        dd offset cr_epilogue       ;; FFI_TYPE_MS_STRUCT\n+\n+cr_retuint8:\n+        movzx eax, BYTE PTR [ecx]\n+        jmp   cr_epilogue\n+\n+cr_retsint8:\n+        movsx eax, BYTE PTR [ecx]\n+        jmp   cr_epilogue\n \n-cr_retint8:\n-        mov   al, [ecx]\n+cr_retuint16:\n+        movzx eax, WORD PTR [ecx]\n         jmp   cr_epilogue\n \n-cr_retint16:\n-        mov   ax, [ecx]\n+cr_retsint16:\n+        movsx eax, WORD PTR [ecx]\n         jmp   cr_epilogue\n \n cr_retint:\n@@ -375,26 +412,34 @@ cd_jumpdata:\n         dd offset cd_retfloat       ;; FFI_TYPE_FLOAT\n         dd offset cd_retdouble      ;; FFI_TYPE_DOUBLE\n         dd offset cd_retlongdouble  ;; FFI_TYPE_LONGDOUBLE\n-        dd offset cd_retint8        ;; FFI_TYPE_UINT8\n-        dd offset cd_retint8        ;; FFI_TYPE_SINT8\n-        dd offset cd_retint16       ;; FFI_TYPE_UINT16\n-        dd offset cd_retint16       ;; FFI_TYPE_SINT16\n+        dd offset cd_retuint8       ;; FFI_TYPE_UINT8\n+        dd offset cd_retsint8       ;; FFI_TYPE_SINT8\n+        dd offset cd_retuint16      ;; FFI_TYPE_UINT16\n+        dd offset cd_retsint16      ;; FFI_TYPE_SINT16\n         dd offset cd_retint         ;; FFI_TYPE_UINT32\n         dd offset cd_retint         ;; FFI_TYPE_SINT32\n         dd offset cd_retint64       ;; FFI_TYPE_UINT64\n         dd offset cd_retint64       ;; FFI_TYPE_SINT64\n         dd offset cd_epilogue       ;; FFI_TYPE_STRUCT\n         dd offset cd_retint         ;; FFI_TYPE_POINTER\n-        dd offset cd_retint8        ;; FFI_TYPE_SMALL_STRUCT_1B\n-        dd offset cd_retint16       ;; FFI_TYPE_SMALL_STRUCT_2B\n+        dd offset cd_retsint8       ;; FFI_TYPE_SMALL_STRUCT_1B\n+        dd offset cd_retsint16      ;; FFI_TYPE_SMALL_STRUCT_2B\n         dd offset cd_retint         ;; FFI_TYPE_SMALL_STRUCT_4B\n \n-cd_retint8:\n-        mov   al, [ecx]\n+cd_retuint8:\n+        movzx eax, BYTE PTR [ecx]\n+        jmp   cd_epilogue\n+\n+cd_retsint8:\n+        movsx eax, BYTE PTR [ecx]\n         jmp   cd_epilogue\n \n-cd_retint16:\n-        mov   ax, [ecx]\n+cd_retuint16:\n+        movzx eax, WORD PTR [ecx]\n+        jmp   cd_epilogue\n+\n+cd_retsint16:\n+        movsx eax, WORD PTR [ecx]\n         jmp   cd_epilogue\n \n cd_retint:\n@@ -515,6 +560,7 @@ _ffi_call_win32:\n \t.long\t.Lretstruct1b\t\t/* FFI_TYPE_SMALL_STRUCT_1B */\n \t.long\t.Lretstruct2b\t\t/* FFI_TYPE_SMALL_STRUCT_2B */\n \t.long\t.Lretstruct4b\t\t/* FFI_TYPE_SMALL_STRUCT_4B */\n+\t.long\t.Lretstruct\t\t/* FFI_TYPE_MS_STRUCT */\n 1:\n \tadd\t%ecx, %ecx\n \tadd\t%ecx, %ecx\n@@ -657,6 +703,7 @@ _ffi_closure_SYSV:\n \t.long\t.Lcls_retstruct1\t/* FFI_TYPE_SMALL_STRUCT_1B */\n \t.long\t.Lcls_retstruct2\t/* FFI_TYPE_SMALL_STRUCT_2B */\n \t.long\t.Lcls_retstruct4\t/* FFI_TYPE_SMALL_STRUCT_4B */\n+\t.long\t.Lcls_retmsstruct\t/* FFI_TYPE_MS_STRUCT */\n \n 1:\n \tadd\t%eax, %eax\n@@ -721,6 +768,12 @@ _ffi_closure_SYSV:\n \tpopl\t%ebp\n \tret\t$0x4\n \n+.Lcls_retmsstruct:\n+\t# Caller expects us to return a pointer to the real return value.\n+\tmov\t%ecx, %eax\n+\t# Caller doesn't expects us to pop struct return value pointer hidden arg.\n+\tjmp\t.Lcls_epilogue\n+\n .Lcls_noretval:\n .Lcls_epilogue:\n \tmovl\t%ebp, %esp\n@@ -798,6 +851,7 @@ _ffi_closure_raw_SYSV:\n \t.long\t.Lrcls_retstruct1\t/* FFI_TYPE_SMALL_STRUCT_1B */\n \t.long\t.Lrcls_retstruct2\t/* FFI_TYPE_SMALL_STRUCT_2B */\n \t.long\t.Lrcls_retstruct4\t/* FFI_TYPE_SMALL_STRUCT_4B */\n+\t.long\t.Lrcls_retstruct\t/* FFI_TYPE_MS_STRUCT */\n 1:\n \tadd\t%eax, %eax\n \tadd\t%eax, %eax"}, {"sha": "146fdf9ed4a8a3eae6cb8c993b6c3eaf0ccf540f", "filename": "libffi/testsuite/Makefile.am", "status": "modified", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2FMakefile.am?ref=b4b575ce7854f4a49de8de93f38b7639e01b040b", "patch": "@@ -14,3 +14,72 @@ RUNTEST = `if [ -f $(top_srcdir)/../dejagnu/runtest ] ; then \\\n AM_RUNTESTFLAGS =\n \n CLEANFILES = *.exe core* *.log *.sum\n+\n+EXTRA_DIST = config/default.exp libffi.call/cls_19byte.c \\\n+libffi.call/cls_align_longdouble_split.c libffi.call/closure_loc_fn0.c \\\n+libffi.call/cls_schar.c libffi.call/closure_fn1.c \\\n+libffi.call/many2_win32.c libffi.call/return_ul.c \\\n+libffi.call/cls_align_double.c libffi.call/return_fl2.c \\\n+libffi.call/cls_1_1byte.c libffi.call/cls_64byte.c \\\n+libffi.call/nested_struct7.c libffi.call/cls_align_sint32.c \\\n+libffi.call/nested_struct2.c libffi.call/ffitest.h \\\n+libffi.call/nested_struct4.c libffi.call/cls_multi_ushort.c \\\n+libffi.call/struct3.c libffi.call/cls_3byte1.c \\\n+libffi.call/cls_16byte.c libffi.call/struct8.c \\\n+libffi.call/nested_struct8.c libffi.call/cls_multi_sshort.c \\\n+libffi.call/cls_3byte2.c libffi.call/fastthis2_win32.c \\\n+libffi.call/cls_pointer.c libffi.call/err_bad_typedef.c \\\n+libffi.call/cls_4_1byte.c libffi.call/cls_9byte2.c \\\n+libffi.call/cls_multi_schar.c libffi.call/stret_medium2.c \\\n+libffi.call/cls_5_1_byte.c libffi.call/call.exp \\\n+libffi.call/cls_double.c libffi.call/cls_align_sint16.c \\\n+libffi.call/cls_uint.c libffi.call/return_ll1.c \\\n+libffi.call/nested_struct3.c libffi.call/cls_20byte1.c \\\n+libffi.call/closure_fn4.c libffi.call/cls_uchar.c \\\n+libffi.call/struct2.c libffi.call/cls_7byte.c libffi.call/strlen.c \\\n+libffi.call/many.c libffi.call/testclosure.c libffi.call/return_fl.c \\\n+libffi.call/struct5.c libffi.call/cls_12byte.c \\\n+libffi.call/cls_multi_sshortchar.c \\\n+libffi.call/cls_align_longdouble_split2.c libffi.call/return_dbl2.c \\\n+libffi.call/return_fl3.c libffi.call/stret_medium.c \\\n+libffi.call/nested_struct6.c libffi.call/a.out \\\n+libffi.call/closure_fn3.c libffi.call/float3.c libffi.call/many2.c \\\n+libffi.call/closure_stdcall.c libffi.call/cls_align_uint16.c \\\n+libffi.call/cls_9byte1.c libffi.call/closure_fn6.c \\\n+libffi.call/cls_double_va.c libffi.call/cls_align_pointer.c \\\n+libffi.call/cls_align_longdouble.c libffi.call/closure_fn2.c \\\n+libffi.call/cls_sshort.c libffi.call/many_win32.c \\\n+libffi.call/nested_struct.c libffi.call/cls_20byte.c \\\n+libffi.call/cls_longdouble.c libffi.call/cls_multi_uchar.c \\\n+libffi.call/return_uc.c libffi.call/closure_thiscall.c \\\n+libffi.call/cls_18byte.c libffi.call/cls_8byte.c \\\n+libffi.call/promotion.c libffi.call/struct1_win32.c \\\n+libffi.call/return_dbl.c libffi.call/cls_24byte.c \\\n+libffi.call/struct4.c libffi.call/cls_6byte.c \\\n+libffi.call/cls_align_uint32.c libffi.call/float.c \\\n+libffi.call/float1.c libffi.call/float_va.c libffi.call/negint.c \\\n+libffi.call/return_dbl1.c libffi.call/cls_3_1byte.c \\\n+libffi.call/cls_align_float.c libffi.call/return_fl1.c \\\n+libffi.call/nested_struct10.c libffi.call/nested_struct5.c \\\n+libffi.call/fastthis1_win32.c libffi.call/cls_align_sint64.c \\\n+libffi.call/stret_large2.c libffi.call/return_sl.c \\\n+libffi.call/closure_fn0.c libffi.call/cls_5byte.c \\\n+libffi.call/cls_2byte.c libffi.call/float2.c \\\n+libffi.call/cls_dbls_struct.c libffi.call/cls_sint.c \\\n+libffi.call/stret_large.c libffi.call/cls_ulonglong.c \\\n+libffi.call/cls_ushort.c libffi.call/nested_struct1.c \\\n+libffi.call/err_bad_abi.c libffi.call/cls_longdouble_va.c \\\n+libffi.call/cls_float.c libffi.call/cls_pointer_stack.c \\\n+libffi.call/pyobjc-tc.c libffi.call/cls_multi_ushortchar.c \\\n+libffi.call/struct1.c libffi.call/nested_struct9.c \\\n+libffi.call/huge_struct.c libffi.call/problem1.c libffi.call/float4.c \\\n+libffi.call/fastthis3_win32.c libffi.call/return_ldl.c \\\n+libffi.call/strlen2_win32.c libffi.call/closure_fn5.c \\\n+libffi.call/struct2_win32.c libffi.call/struct6.c \\\n+libffi.call/return_ll.c libffi.call/struct9.c libffi.call/return_sc.c \\\n+libffi.call/struct7.c libffi.call/cls_align_uint64.c \\\n+libffi.call/cls_4byte.c libffi.call/strlen_win32.c \\\n+libffi.call/cls_6_1_byte.c libffi.call/cls_7_1_byte.c \\\n+libffi.special/unwindtest.cc libffi.special/special.exp \\\n+libffi.special/unwindtest_ffi_call.cc libffi.special/ffitestcxx.h \\\n+lib/wrapper.exp lib/target-libpath.exp lib/libffi.exp"}, {"sha": "44ca9c23c1162111106c6498559949c26e5e7396", "filename": "libffi/testsuite/Makefile.in", "status": "modified", "additions": 136, "deletions": 22, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2FMakefile.in?ref=b4b575ce7854f4a49de8de93f38b7639e01b040b", "patch": "@@ -1,9 +1,9 @@\n-# Makefile.in generated by automake 1.11.1 from Makefile.am.\n+# Makefile.in generated by automake 1.11.6 from Makefile.am.\n # @configure_input@\n \n # Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,\n-# 2003, 2004, 2005, 2006, 2007, 2008, 2009  Free Software Foundation,\n-# Inc.\n+# 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 Free Software\n+# Foundation, Inc.\n # This Makefile.in is free software; the Free Software Foundation\n # gives unlimited permission to copy and/or distribute it,\n # with or without modifications, as long as this notice is preserved.\n@@ -15,6 +15,23 @@\n \n @SET_MAKE@\n VPATH = @srcdir@\n+am__make_dryrun = \\\n+  { \\\n+    am__dry=no; \\\n+    case $$MAKEFLAGS in \\\n+      *\\\\[\\ \\\t]*) \\\n+        echo 'am--echo: ; @echo \"AM\"  OK' | $(MAKE) -f - 2>/dev/null \\\n+          | grep '^AM OK$$' >/dev/null || am__dry=yes;; \\\n+      *) \\\n+        for am__flg in $$MAKEFLAGS; do \\\n+          case $$am__flg in \\\n+            *=*|--*) ;; \\\n+            *n*) am__dry=yes; break;; \\\n+          esac; \\\n+        done;; \\\n+    esac; \\\n+    test $$am__dry = yes; \\\n+  }\n pkgdatadir = $(datadir)/@PACKAGE@\n pkgincludedir = $(includedir)/@PACKAGE@\n pkglibdir = $(libdir)/@PACKAGE@\n@@ -37,22 +54,32 @@ target_triplet = @target@\n subdir = testsuite\n DIST_COMMON = $(srcdir)/Makefile.am $(srcdir)/Makefile.in\n ACLOCAL_M4 = $(top_srcdir)/aclocal.m4\n-am__aclocal_m4_deps = $(top_srcdir)/../config/depstand.m4 \\\n-\t$(top_srcdir)/../config/lead-dot.m4 \\\n-\t$(top_srcdir)/../config/multi.m4 \\\n-\t$(top_srcdir)/../config/override.m4 \\\n-\t$(top_srcdir)/../libtool.m4 $(top_srcdir)/../ltoptions.m4 \\\n-\t$(top_srcdir)/../ltsugar.m4 $(top_srcdir)/../ltversion.m4 \\\n-\t$(top_srcdir)/../lt~obsolete.m4 $(top_srcdir)/acinclude.m4 \\\n+am__aclocal_m4_deps = $(top_srcdir)/m4/asmcfi.m4 \\\n+\t$(top_srcdir)/m4/ax_cc_maxopt.m4 \\\n+\t$(top_srcdir)/m4/ax_cflags_warn_all.m4 \\\n+\t$(top_srcdir)/m4/ax_check_compile_flag.m4 \\\n+\t$(top_srcdir)/m4/ax_compiler_vendor.m4 \\\n+\t$(top_srcdir)/m4/ax_configure_args.m4 \\\n+\t$(top_srcdir)/m4/ax_enable_builddir.m4 \\\n+\t$(top_srcdir)/m4/ax_gcc_archflag.m4 \\\n+\t$(top_srcdir)/m4/ax_gcc_x86_cpuid.m4 \\\n+\t$(top_srcdir)/m4/libtool.m4 $(top_srcdir)/m4/ltoptions.m4 \\\n+\t$(top_srcdir)/m4/ltsugar.m4 $(top_srcdir)/m4/ltversion.m4 \\\n+\t$(top_srcdir)/m4/lt~obsolete.m4 $(top_srcdir)/acinclude.m4 \\\n \t$(top_srcdir)/configure.ac\n am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \\\n \t$(ACLOCAL_M4)\n-mkinstalldirs = $(SHELL) $(top_srcdir)/../mkinstalldirs\n+mkinstalldirs = $(install_sh) -d\n CONFIG_HEADER = $(top_builddir)/fficonfig.h\n CONFIG_CLEAN_FILES =\n CONFIG_CLEAN_VPATH_FILES =\n SOURCES =\n DIST_SOURCES =\n+am__can_run_installinfo = \\\n+  case $$AM_UPDATE_INFO_DIR in \\\n+    n|no|NO) false;; \\\n+    *) (install-info --version) >/dev/null 2>&1;; \\\n+  esac\n DEJATOOL = $(PACKAGE)\n RUNTESTDEFAULTFLAGS = --tool $$tool --srcdir $$srcdir\n DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)\n@@ -77,13 +104,15 @@ CPPFLAGS = @CPPFLAGS@\n CYGPATH_W = @CYGPATH_W@\n DEFS = @DEFS@\n DEPDIR = @DEPDIR@\n+DLLTOOL = @DLLTOOL@\n DSYMUTIL = @DSYMUTIL@\n DUMPBIN = @DUMPBIN@\n ECHO_C = @ECHO_C@\n ECHO_N = @ECHO_N@\n ECHO_T = @ECHO_T@\n EGREP = @EGREP@\n EXEEXT = @EXEEXT@\n+FFI_EXEC_TRAMPOLINE_TABLE = @FFI_EXEC_TRAMPOLINE_TABLE@\n FGREP = @FGREP@\n GREP = @GREP@\n HAVE_LONG_DOUBLE = @HAVE_LONG_DOUBLE@\n@@ -102,6 +131,7 @@ LN_S = @LN_S@\n LTLIBOBJS = @LTLIBOBJS@\n MAINT = @MAINT@\n MAKEINFO = @MAKEINFO@\n+MANIFEST_TOOL = @MANIFEST_TOOL@\n MKDIR_P = @MKDIR_P@\n NM = @NM@\n NMEDIT = @NMEDIT@\n@@ -117,6 +147,7 @@ PACKAGE_TARNAME = @PACKAGE_TARNAME@\n PACKAGE_URL = @PACKAGE_URL@\n PACKAGE_VERSION = @PACKAGE_VERSION@\n PATH_SEPARATOR = @PATH_SEPARATOR@\n+PRTDIAG = @PRTDIAG@\n RANLIB = @RANLIB@\n SED = @SED@\n SET_MAKE = @SET_MAKE@\n@@ -129,13 +160,15 @@ abs_builddir = @abs_builddir@\n abs_srcdir = @abs_srcdir@\n abs_top_builddir = @abs_top_builddir@\n abs_top_srcdir = @abs_top_srcdir@\n+ac_ct_AR = @ac_ct_AR@\n ac_ct_CC = @ac_ct_CC@\n ac_ct_DUMPBIN = @ac_ct_DUMPBIN@\n am__include = @am__include@\n am__leading_dot = @am__leading_dot@\n am__quote = @am__quote@\n am__tar = @am__tar@\n am__untar = @am__untar@\n+ax_enable_builddir_sed = @ax_enable_builddir_sed@\n bindir = @bindir@\n build = @build@\n build_alias = @build_alias@\n@@ -163,7 +196,6 @@ localedir = @localedir@\n localstatedir = @localstatedir@\n mandir = @mandir@\n mkdir_p = @mkdir_p@\n-multi_basedir = @multi_basedir@\n oldincludedir = @oldincludedir@\n pdfdir = @pdfdir@\n prefix = @prefix@\n@@ -172,6 +204,7 @@ psdir = @psdir@\n sbindir = @sbindir@\n sharedstatedir = @sharedstatedir@\n srcdir = @srcdir@\n+sys_symbol_underscore = @sys_symbol_underscore@\n sysconfdir = @sysconfdir@\n target = @target@\n target_alias = @target_alias@\n@@ -195,6 +228,75 @@ RUNTEST = `if [ -f $(top_srcdir)/../dejagnu/runtest ] ; then \\\n \t    else echo runtest; fi`\n \n CLEANFILES = *.exe core* *.log *.sum\n+EXTRA_DIST = config/default.exp libffi.call/cls_19byte.c \\\n+libffi.call/cls_align_longdouble_split.c libffi.call/closure_loc_fn0.c \\\n+libffi.call/cls_schar.c libffi.call/closure_fn1.c \\\n+libffi.call/many2_win32.c libffi.call/return_ul.c \\\n+libffi.call/cls_align_double.c libffi.call/return_fl2.c \\\n+libffi.call/cls_1_1byte.c libffi.call/cls_64byte.c \\\n+libffi.call/nested_struct7.c libffi.call/cls_align_sint32.c \\\n+libffi.call/nested_struct2.c libffi.call/ffitest.h \\\n+libffi.call/nested_struct4.c libffi.call/cls_multi_ushort.c \\\n+libffi.call/struct3.c libffi.call/cls_3byte1.c \\\n+libffi.call/cls_16byte.c libffi.call/struct8.c \\\n+libffi.call/nested_struct8.c libffi.call/cls_multi_sshort.c \\\n+libffi.call/cls_3byte2.c libffi.call/fastthis2_win32.c \\\n+libffi.call/cls_pointer.c libffi.call/err_bad_typedef.c \\\n+libffi.call/cls_4_1byte.c libffi.call/cls_9byte2.c \\\n+libffi.call/cls_multi_schar.c libffi.call/stret_medium2.c \\\n+libffi.call/cls_5_1_byte.c libffi.call/call.exp \\\n+libffi.call/cls_double.c libffi.call/cls_align_sint16.c \\\n+libffi.call/cls_uint.c libffi.call/return_ll1.c \\\n+libffi.call/nested_struct3.c libffi.call/cls_20byte1.c \\\n+libffi.call/closure_fn4.c libffi.call/cls_uchar.c \\\n+libffi.call/struct2.c libffi.call/cls_7byte.c libffi.call/strlen.c \\\n+libffi.call/many.c libffi.call/testclosure.c libffi.call/return_fl.c \\\n+libffi.call/struct5.c libffi.call/cls_12byte.c \\\n+libffi.call/cls_multi_sshortchar.c \\\n+libffi.call/cls_align_longdouble_split2.c libffi.call/return_dbl2.c \\\n+libffi.call/return_fl3.c libffi.call/stret_medium.c \\\n+libffi.call/nested_struct6.c libffi.call/a.out \\\n+libffi.call/closure_fn3.c libffi.call/float3.c libffi.call/many2.c \\\n+libffi.call/closure_stdcall.c libffi.call/cls_align_uint16.c \\\n+libffi.call/cls_9byte1.c libffi.call/closure_fn6.c \\\n+libffi.call/cls_double_va.c libffi.call/cls_align_pointer.c \\\n+libffi.call/cls_align_longdouble.c libffi.call/closure_fn2.c \\\n+libffi.call/cls_sshort.c libffi.call/many_win32.c \\\n+libffi.call/nested_struct.c libffi.call/cls_20byte.c \\\n+libffi.call/cls_longdouble.c libffi.call/cls_multi_uchar.c \\\n+libffi.call/return_uc.c libffi.call/closure_thiscall.c \\\n+libffi.call/cls_18byte.c libffi.call/cls_8byte.c \\\n+libffi.call/promotion.c libffi.call/struct1_win32.c \\\n+libffi.call/return_dbl.c libffi.call/cls_24byte.c \\\n+libffi.call/struct4.c libffi.call/cls_6byte.c \\\n+libffi.call/cls_align_uint32.c libffi.call/float.c \\\n+libffi.call/float1.c libffi.call/float_va.c libffi.call/negint.c \\\n+libffi.call/return_dbl1.c libffi.call/cls_3_1byte.c \\\n+libffi.call/cls_align_float.c libffi.call/return_fl1.c \\\n+libffi.call/nested_struct10.c libffi.call/nested_struct5.c \\\n+libffi.call/fastthis1_win32.c libffi.call/cls_align_sint64.c \\\n+libffi.call/stret_large2.c libffi.call/return_sl.c \\\n+libffi.call/closure_fn0.c libffi.call/cls_5byte.c \\\n+libffi.call/cls_2byte.c libffi.call/float2.c \\\n+libffi.call/cls_dbls_struct.c libffi.call/cls_sint.c \\\n+libffi.call/stret_large.c libffi.call/cls_ulonglong.c \\\n+libffi.call/cls_ushort.c libffi.call/nested_struct1.c \\\n+libffi.call/err_bad_abi.c libffi.call/cls_longdouble_va.c \\\n+libffi.call/cls_float.c libffi.call/cls_pointer_stack.c \\\n+libffi.call/pyobjc-tc.c libffi.call/cls_multi_ushortchar.c \\\n+libffi.call/struct1.c libffi.call/nested_struct9.c \\\n+libffi.call/huge_struct.c libffi.call/problem1.c libffi.call/float4.c \\\n+libffi.call/fastthis3_win32.c libffi.call/return_ldl.c \\\n+libffi.call/strlen2_win32.c libffi.call/closure_fn5.c \\\n+libffi.call/struct2_win32.c libffi.call/struct6.c \\\n+libffi.call/return_ll.c libffi.call/struct9.c libffi.call/return_sc.c \\\n+libffi.call/struct7.c libffi.call/cls_align_uint64.c \\\n+libffi.call/cls_4byte.c libffi.call/strlen_win32.c \\\n+libffi.call/cls_6_1_byte.c libffi.call/cls_7_1_byte.c \\\n+libffi.special/unwindtest.cc libffi.special/special.exp \\\n+libffi.special/unwindtest_ffi_call.cc libffi.special/ffitestcxx.h \\\n+lib/wrapper.exp lib/target-libpath.exp lib/libffi.exp\n+\n all: all-am\n \n .SUFFIXES:\n@@ -242,7 +344,7 @@ CTAGS:\n \n \n check-DEJAGNU: site.exp\n-\tsrcdir=`$(am__cd) $(srcdir) && pwd`; export srcdir; \\\n+\tsrcdir='$(srcdir)'; export srcdir; \\\n \tEXPECT=$(EXPECT); export EXPECT; \\\n \truntest=$(RUNTEST); \\\n \tif $(SHELL) -c \"$$runtest --version\" > /dev/null 2>&1; then \\\n@@ -253,22 +355,29 @@ check-DEJAGNU: site.exp\n \telse echo \"WARNING: could not find \\`runtest'\" 1>&2; :;\\\n \tfi; \\\n \texit $$exit_status\n-site.exp: Makefile\n+site.exp: Makefile $(EXTRA_DEJAGNU_SITE_CONFIG)\n \t@echo 'Making a new site.exp file...'\n \t@echo '## these variables are automatically generated by make ##' >site.tmp\n \t@echo '# Do not edit here.  If you wish to override these values' >>site.tmp\n \t@echo '# edit the last section' >>site.tmp\n-\t@echo 'set srcdir $(srcdir)' >>site.tmp\n+\t@echo 'set srcdir \"$(srcdir)\"' >>site.tmp\n \t@echo \"set objdir `pwd`\" >>site.tmp\n \t@echo 'set build_alias \"$(build_alias)\"' >>site.tmp\n \t@echo 'set build_triplet $(build_triplet)' >>site.tmp\n \t@echo 'set host_alias \"$(host_alias)\"' >>site.tmp\n \t@echo 'set host_triplet $(host_triplet)' >>site.tmp\n \t@echo 'set target_alias \"$(target_alias)\"' >>site.tmp\n \t@echo 'set target_triplet $(target_triplet)' >>site.tmp\n-\t@echo '## All variables above are generated by configure. Do Not Edit ##' >>site.tmp\n-\t@test ! -f site.exp || \\\n-\t  sed '1,/^## All variables above are.*##/ d' site.exp >> site.tmp\n+\t@list='$(EXTRA_DEJAGNU_SITE_CONFIG)'; for f in $$list; do \\\n+\t  echo \"## Begin content included from file $$f.  Do not modify. ##\" \\\n+\t   && cat `test -f \"$$f\" || echo '$(srcdir)/'`$$f \\\n+\t   && echo \"## End content included from file $$f. ##\" \\\n+\t   || exit 1; \\\n+\t done >> site.tmp\n+\t@echo \"## End of auto-generated content; you can edit from here. ##\" >> site.tmp\n+\t@if test -f site.exp; then \\\n+\t   sed -e '1,/^## End of auto-generated content.*##/d' site.exp >> site.tmp; \\\n+\t fi\n \t@-rm -f site.bak\n \t@test ! -f site.exp || mv site.exp site.bak\n \t@mv site.tmp site.exp\n@@ -324,10 +433,15 @@ install-am: all-am\n \n installcheck: installcheck-am\n install-strip:\n-\t$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" \\\n-\t  install_sh_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" INSTALL_STRIP_FLAG=-s \\\n-\t  `test -z '$(STRIP)' || \\\n-\t    echo \"INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'\"` install\n+\tif test -z '$(STRIP)'; then \\\n+\t  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" \\\n+\t    install_sh_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" INSTALL_STRIP_FLAG=-s \\\n+\t      install; \\\n+\telse \\\n+\t  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" \\\n+\t    install_sh_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" INSTALL_STRIP_FLAG=-s \\\n+\t    \"INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'\" install; \\\n+\tfi\n mostlyclean-generic:\n \n clean-generic:"}, {"sha": "8ee3f1509fcb80e1ef97bd4e82e950fc9bacf10f", "filename": "libffi/testsuite/lib/libffi.exp", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flib%2Flibffi.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flib%2Flibffi.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flib%2Flibffi.exp?ref=b4b575ce7854f4a49de8de93f38b7639e01b040b", "patch": "@@ -1,4 +1,4 @@\n-#   Copyright (C) 2003, 2005, 2008, 2009, 2010 Free Software Foundation, Inc.\n+#   Copyright (C) 2003, 2005, 2008, 2009, 2010, 2011 Free Software Foundation, Inc.\n \n # This program is free software; you can redistribute it and/or modify\n # it under the terms of the GNU General Public License as published by\n@@ -16,7 +16,7 @@\n \n proc load_gcc_lib { filename } {\n     global srcdir\n-    load_file $srcdir/../../gcc/testsuite/lib/$filename\n+    load_file $srcdir/lib/$filename\n }\n \n load_lib dg.exp\n@@ -94,18 +94,15 @@ proc libffi-init { args } {\n     global srcdir\n     global blddirffi\n     global objdir\n-    global blddircxx\n     global TOOL_OPTIONS\n     global tool\n     global libffi_include\n     global libffi_link_flags\n     global tool_root_dir\n     global ld_library_path\n \n-    set blddirffi [lookfor_file [get_multilibs] libffi]\n+    set blddirffi [pwd]/.. \n     verbose \"libffi $blddirffi\"\n-    set blddircxx [lookfor_file [get_multilibs] libstdc++-v3]\n-    verbose \"libstdc++ $blddircxx\"\n \n     set gccdir [lookfor_file $tool_root_dir gcc/libgcc.a]\n     if {$gccdir != \"\"} {\n@@ -132,8 +129,6 @@ proc libffi-init { args } {\n     }\n     # add the library path for libffi.\n     append ld_library_path \":${blddirffi}/.libs\"\n-    # add the library path for libstdc++ as well.\n-    append ld_library_path \":${blddircxx}/src/.libs\"\n \n     verbose \"ld_library_path: $ld_library_path\"\n \n@@ -146,7 +141,6 @@ proc libffi-init { args } {\n     if { $libffi_dir != \"\" } {\n \tset libffi_dir [file dirname ${libffi_dir}]\n \tset libffi_link_flags \"-L${libffi_dir}/.libs\"\n-\tlappend libffi_link_flags \"-L${blddircxx}/src/.libs\"\n     }\n \n     set_ld_library_path_env_vars\n@@ -209,6 +203,10 @@ proc libffi_target_compile { source dest type options } {\n \n     lappend options \"libs= -lffi\"\n \n+    if { [string match \"aarch64*-*-linux*\" $target_triplet] } {\n+\tlappend options \"libs= -lpthread\"\n+    }\n+\n     verbose \"options: $options\"\n     return [target_compile $source $dest $type $options]\n }"}, {"sha": "1407f024c1704f158529e80236e0727ba740f11f", "filename": "libffi/testsuite/libffi.call/closure_stdcall.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fclosure_stdcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fclosure_stdcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fclosure_stdcall.c?ref=b4b575ce7854f4a49de8de93f38b7639e01b040b", "patch": "@@ -49,9 +49,17 @@ int main (void)\n   CHECK(ffi_prep_closure_loc(pcl, &cif, closure_test_stdcall,\n                              (void *) 3 /* userdata */, code) == FFI_OK);\n \n+#ifdef _MSC_VER\n+  __asm { mov sp_pre, esp }\n+#else\n   asm volatile (\" movl %%esp,%0\" : \"=g\" (sp_pre));\n+#endif\n   res = (*(closure_test_type0)code)(0, 1, 2, 3);\n+#ifdef _MSC_VER\n+  __asm { mov sp_post, esp }\n+#else\n   asm volatile (\" movl %%esp,%0\" : \"=g\" (sp_post));\n+#endif\n   /* { dg-output \"0 1 2 3: 9\" } */\n \n   printf(\"res: %d\\n\",res);"}, {"sha": "0f93649ff752de1e97ba30e8c46ed282f12753e9", "filename": "libffi/testsuite/libffi.call/closure_thiscall.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fclosure_thiscall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fclosure_thiscall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fclosure_thiscall.c?ref=b4b575ce7854f4a49de8de93f38b7639e01b040b", "patch": "@@ -49,9 +49,17 @@ int main (void)\n   CHECK(ffi_prep_closure_loc(pcl, &cif, closure_test_thiscall,\n                              (void *) 3 /* userdata */, code) == FFI_OK);\n \n+#ifdef _MSC_VER\n+  __asm { mov sp_pre, esp }\n+#else\n   asm volatile (\" movl %%esp,%0\" : \"=g\" (sp_pre));\n+#endif\n   res = (*(closure_test_type0)code)(0, 1, 2, 3);\n+#ifdef _MSC_VER\n+  __asm { mov sp_post, esp }\n+#else\n   asm volatile (\" movl %%esp,%0\" : \"=g\" (sp_post));\n+#endif\n   /* { dg-output \"0 1 2 3: 9\" } */\n \n   printf(\"res: %d\\n\",res);"}, {"sha": "ea0825d175a6571e5706505010971bc1ea86bf6a", "filename": "libffi/testsuite/libffi.call/cls_12byte.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fcls_12byte.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fcls_12byte.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_12byte.c?ref=b4b575ce7854f4a49de8de93f38b7639e01b040b", "patch": "@@ -49,15 +49,15 @@ int main (void)\n   ffi_type cls_struct_type;\n   ffi_type* dbl_arg_types[5];\n \n+  struct cls_struct_12byte h_dbl = { 7, 4, 9 };\n+  struct cls_struct_12byte j_dbl = { 1, 5, 3 };\n+  struct cls_struct_12byte res_dbl;\n+\n   cls_struct_type.size = 0;\n   cls_struct_type.alignment = 0;\n   cls_struct_type.type = FFI_TYPE_STRUCT;\n   cls_struct_type.elements = cls_struct_fields;\n \n-  struct cls_struct_12byte h_dbl = { 7, 4, 9 };\n-  struct cls_struct_12byte j_dbl = { 1, 5, 3 };\n-  struct cls_struct_12byte res_dbl;\n-\n   cls_struct_fields[0] = &ffi_type_sint;\n   cls_struct_fields[1] = &ffi_type_sint;\n   cls_struct_fields[2] = &ffi_type_sint;"}, {"sha": "89a08a2d97bb1a45a41dede9fab9559ed20bab54", "filename": "libffi/testsuite/libffi.call/cls_16byte.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fcls_16byte.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fcls_16byte.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_16byte.c?ref=b4b575ce7854f4a49de8de93f38b7639e01b040b", "patch": "@@ -50,15 +50,15 @@ int main (void)\n   ffi_type cls_struct_type;\n   ffi_type* dbl_arg_types[5];\n \n+  struct cls_struct_16byte h_dbl = { 7, 8.0, 9 };\n+  struct cls_struct_16byte j_dbl = { 1, 9.0, 3 };\n+  struct cls_struct_16byte res_dbl;\n+\n   cls_struct_type.size = 0;\n   cls_struct_type.alignment = 0;\n   cls_struct_type.type = FFI_TYPE_STRUCT;\n   cls_struct_type.elements = cls_struct_fields;\n \n-  struct cls_struct_16byte h_dbl = { 7, 8.0, 9 };\n-  struct cls_struct_16byte j_dbl = { 1, 9.0, 3 };\n-  struct cls_struct_16byte res_dbl;\n-\n   cls_struct_fields[0] = &ffi_type_sint;\n   cls_struct_fields[1] = &ffi_type_double;\n   cls_struct_fields[2] = &ffi_type_sint;"}, {"sha": "9f75da80aa05faa5aea74f237ac5c20e6fda0b09", "filename": "libffi/testsuite/libffi.call/cls_18byte.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fcls_18byte.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fcls_18byte.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_18byte.c?ref=b4b575ce7854f4a49de8de93f38b7639e01b040b", "patch": "@@ -54,15 +54,15 @@ int main (void)\n   ffi_type cls_struct_type;\n   ffi_type* dbl_arg_types[3];\n \n+  struct cls_struct_18byte g_dbl = { 1.0, 127, 126, 3.0 };\n+  struct cls_struct_18byte f_dbl = { 4.0, 125, 124, 5.0 };\n+  struct cls_struct_18byte res_dbl;\n+\n   cls_struct_type.size = 0;\n   cls_struct_type.alignment = 0;\n   cls_struct_type.type = FFI_TYPE_STRUCT;\n   cls_struct_type.elements = cls_struct_fields;\n \n-  struct cls_struct_18byte g_dbl = { 1.0, 127, 126, 3.0 };\n-  struct cls_struct_18byte f_dbl = { 4.0, 125, 124, 5.0 };\n-  struct cls_struct_18byte res_dbl;\n-\n   cls_struct_fields[0] = &ffi_type_double;\n   cls_struct_fields[1] = &ffi_type_uchar;\n   cls_struct_fields[2] = &ffi_type_uchar;"}, {"sha": "278794b5b8773039a5b1d7a9c9ddcc378f98bc27", "filename": "libffi/testsuite/libffi.call/cls_19byte.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fcls_19byte.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fcls_19byte.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_19byte.c?ref=b4b575ce7854f4a49de8de93f38b7639e01b040b", "patch": "@@ -57,15 +57,15 @@ int main (void)\n   ffi_type cls_struct_type;\n   ffi_type* dbl_arg_types[3];\n \n+  struct cls_struct_19byte g_dbl = { 1.0, 127, 126, 3.0, 120 };\n+  struct cls_struct_19byte f_dbl = { 4.0, 125, 124, 5.0, 119 };\n+  struct cls_struct_19byte res_dbl;\n+\n   cls_struct_type.size = 0;\n   cls_struct_type.alignment = 0;\n   cls_struct_type.type = FFI_TYPE_STRUCT;\n   cls_struct_type.elements = cls_struct_fields;\n \n-  struct cls_struct_19byte g_dbl = { 1.0, 127, 126, 3.0, 120 };\n-  struct cls_struct_19byte f_dbl = { 4.0, 125, 124, 5.0, 119 };\n-  struct cls_struct_19byte res_dbl;\n-\n   cls_struct_fields[0] = &ffi_type_double;\n   cls_struct_fields[1] = &ffi_type_uchar;\n   cls_struct_fields[2] = &ffi_type_uchar;"}, {"sha": "82492c020e2bc8452b6064d5e64a88cfca910609", "filename": "libffi/testsuite/libffi.call/cls_1_1byte.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fcls_1_1byte.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fcls_1_1byte.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_1_1byte.c?ref=b4b575ce7854f4a49de8de93f38b7639e01b040b", "patch": "@@ -50,15 +50,15 @@ int main (void)\n   ffi_type cls_struct_type;\n   ffi_type* dbl_arg_types[5];\n \n+  struct cls_struct_1_1byte g_dbl = { 12 };\n+  struct cls_struct_1_1byte f_dbl = { 178 };\n+  struct cls_struct_1_1byte res_dbl;\n+\n   cls_struct_type.size = 0;\n   cls_struct_type.alignment = 0;\n   cls_struct_type.type = FFI_TYPE_STRUCT;\n   cls_struct_type.elements = cls_struct_fields;\n \n-  struct cls_struct_1_1byte g_dbl = { 12 };\n-  struct cls_struct_1_1byte f_dbl = { 178 };\n-  struct cls_struct_1_1byte res_dbl;\n-\n   cls_struct_fields[0] = &ffi_type_uchar;\n   cls_struct_fields[1] = NULL;\n "}, {"sha": "3f8bb28ad297cd77709923c824610128cef3fa06", "filename": "libffi/testsuite/libffi.call/cls_20byte.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fcls_20byte.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fcls_20byte.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_20byte.c?ref=b4b575ce7854f4a49de8de93f38b7639e01b040b", "patch": "@@ -50,15 +50,15 @@ int main (void)\n   ffi_type cls_struct_type;\n   ffi_type* dbl_arg_types[5];\n \n+  struct cls_struct_20byte g_dbl = { 1.0, 2.0, 3 };\n+  struct cls_struct_20byte f_dbl = { 4.0, 5.0, 7 };\n+  struct cls_struct_20byte res_dbl;\n+\n   cls_struct_type.size = 0;\n   cls_struct_type.alignment = 0;\n   cls_struct_type.type = FFI_TYPE_STRUCT;\n   cls_struct_type.elements = cls_struct_fields;\n \n-  struct cls_struct_20byte g_dbl = { 1.0, 2.0, 3 };\n-  struct cls_struct_20byte f_dbl = { 4.0, 5.0, 7 };\n-  struct cls_struct_20byte res_dbl;\n-\n   cls_struct_fields[0] = &ffi_type_double;\n   cls_struct_fields[1] = &ffi_type_double;\n   cls_struct_fields[2] = &ffi_type_sint;"}, {"sha": "65627273c84b693415f4a6d43dcbf5cffdf1f513", "filename": "libffi/testsuite/libffi.call/cls_20byte1.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fcls_20byte1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fcls_20byte1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_20byte1.c?ref=b4b575ce7854f4a49de8de93f38b7639e01b040b", "patch": "@@ -52,15 +52,15 @@ int main (void)\n   ffi_type cls_struct_type;\n   ffi_type* dbl_arg_types[3];\n \n+  struct cls_struct_20byte g_dbl = { 1, 2.0, 3.0 };\n+  struct cls_struct_20byte f_dbl = { 4, 5.0, 7.0 };\n+  struct cls_struct_20byte res_dbl;\n+\n   cls_struct_type.size = 0;\n   cls_struct_type.alignment = 0;\n   cls_struct_type.type = FFI_TYPE_STRUCT;\n   cls_struct_type.elements = cls_struct_fields;\n \n-  struct cls_struct_20byte g_dbl = { 1, 2.0, 3.0 };\n-  struct cls_struct_20byte f_dbl = { 4, 5.0, 7.0 };\n-  struct cls_struct_20byte res_dbl;\n-\n   cls_struct_fields[0] = &ffi_type_sint;\n   cls_struct_fields[1] = &ffi_type_double;\n   cls_struct_fields[2] = &ffi_type_double;"}, {"sha": "1d82f6e4a45bbc8878fb9eec6a63f91c429fb55c", "filename": "libffi/testsuite/libffi.call/cls_24byte.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fcls_24byte.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fcls_24byte.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_24byte.c?ref=b4b575ce7854f4a49de8de93f38b7639e01b040b", "patch": "@@ -61,17 +61,17 @@ int main (void)\n   ffi_type cls_struct_type;\n   ffi_type* dbl_arg_types[5];\n \n-  cls_struct_type.size = 0;\n-  cls_struct_type.alignment = 0;\n-  cls_struct_type.type = FFI_TYPE_STRUCT;\n-  cls_struct_type.elements = cls_struct_fields;\n-\n   struct cls_struct_24byte e_dbl = { 9.0, 2.0, 6, 5.0 };\n   struct cls_struct_24byte f_dbl = { 1.0, 2.0, 3, 7.0 };\n   struct cls_struct_24byte g_dbl = { 4.0, 5.0, 7, 9.0 };\n   struct cls_struct_24byte h_dbl = { 8.0, 6.0, 1, 4.0 };\n   struct cls_struct_24byte res_dbl;\n \n+  cls_struct_type.size = 0;\n+  cls_struct_type.alignment = 0;\n+  cls_struct_type.type = FFI_TYPE_STRUCT;\n+  cls_struct_type.elements = cls_struct_fields;\n+\n   cls_struct_fields[0] = &ffi_type_double;\n   cls_struct_fields[1] = &ffi_type_double;\n   cls_struct_fields[2] = &ffi_type_sint;"}, {"sha": "81bb0a64a3ee50eeedfcb373b531f7e563a48913", "filename": "libffi/testsuite/libffi.call/cls_2byte.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fcls_2byte.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fcls_2byte.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_2byte.c?ref=b4b575ce7854f4a49de8de93f38b7639e01b040b", "patch": "@@ -50,15 +50,15 @@ int main (void)\n   ffi_type cls_struct_type;\n   ffi_type* dbl_arg_types[5];\n \n+  struct cls_struct_2byte g_dbl = { 12, 127 };\n+  struct cls_struct_2byte f_dbl = { 1, 13 };\n+  struct cls_struct_2byte res_dbl;\n+\n   cls_struct_type.size = 0;\n   cls_struct_type.alignment = 0;\n   cls_struct_type.type = FFI_TYPE_STRUCT;\n   cls_struct_type.elements = cls_struct_fields;\n \n-  struct cls_struct_2byte g_dbl = { 12, 127 };\n-  struct cls_struct_2byte f_dbl = { 1, 13 };\n-  struct cls_struct_2byte res_dbl;\n-\n   cls_struct_fields[0] = &ffi_type_uchar;\n   cls_struct_fields[1] = &ffi_type_uchar;\n   cls_struct_fields[2] = NULL;"}, {"sha": "b7827466f6ef43b17176c4abd0976f96d3491768", "filename": "libffi/testsuite/libffi.call/cls_3_1byte.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fcls_3_1byte.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fcls_3_1byte.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_3_1byte.c?ref=b4b575ce7854f4a49de8de93f38b7639e01b040b", "patch": "@@ -54,15 +54,15 @@ int main (void)\n   ffi_type cls_struct_type;\n   ffi_type* dbl_arg_types[5];\n \n+  struct cls_struct_3_1byte g_dbl = { 12, 13, 14 };\n+  struct cls_struct_3_1byte f_dbl = { 178, 179, 180 };\n+  struct cls_struct_3_1byte res_dbl;\n+\n   cls_struct_type.size = 0;\n   cls_struct_type.alignment = 0;\n   cls_struct_type.type = FFI_TYPE_STRUCT;\n   cls_struct_type.elements = cls_struct_fields;\n \n-  struct cls_struct_3_1byte g_dbl = { 12, 13, 14 };\n-  struct cls_struct_3_1byte f_dbl = { 178, 179, 180 };\n-  struct cls_struct_3_1byte res_dbl;\n-\n   cls_struct_fields[0] = &ffi_type_uchar;\n   cls_struct_fields[1] = &ffi_type_uchar;\n   cls_struct_fields[2] = &ffi_type_uchar;"}, {"sha": "a02c463af9f0f36cd81a768bb1c6d05cf3f22460", "filename": "libffi/testsuite/libffi.call/cls_3byte1.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fcls_3byte1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fcls_3byte1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_3byte1.c?ref=b4b575ce7854f4a49de8de93f38b7639e01b040b", "patch": "@@ -50,15 +50,15 @@ int main (void)\n   ffi_type cls_struct_type;\n   ffi_type* dbl_arg_types[5];\n \n+  struct cls_struct_3byte g_dbl = { 12, 119 };\n+  struct cls_struct_3byte f_dbl = { 1, 15 };\n+  struct cls_struct_3byte res_dbl;\n+\n   cls_struct_type.size = 0;\n   cls_struct_type.alignment = 0;\n   cls_struct_type.type = FFI_TYPE_STRUCT;\n   cls_struct_type.elements = cls_struct_fields;\n \n-  struct cls_struct_3byte g_dbl = { 12, 119 };\n-  struct cls_struct_3byte f_dbl = { 1, 15 };\n-  struct cls_struct_3byte res_dbl;\n-\n   cls_struct_fields[0] = &ffi_type_ushort;\n   cls_struct_fields[1] = &ffi_type_uchar;\n   cls_struct_fields[2] = NULL;"}, {"sha": "c7251cead60308e21e2f889f92ba603bdee30fe8", "filename": "libffi/testsuite/libffi.call/cls_3byte2.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fcls_3byte2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fcls_3byte2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_3byte2.c?ref=b4b575ce7854f4a49de8de93f38b7639e01b040b", "patch": "@@ -50,15 +50,15 @@ int main (void)\n   ffi_type cls_struct_type;\n   ffi_type* dbl_arg_types[5];\n \n+  struct cls_struct_3byte_1 g_dbl = { 15, 125 };\n+  struct cls_struct_3byte_1 f_dbl = { 9, 19 };\n+  struct cls_struct_3byte_1 res_dbl;\n+\n   cls_struct_type.size = 0;\n   cls_struct_type.alignment = 0;\n   cls_struct_type.type = FFI_TYPE_STRUCT;\n   cls_struct_type.elements = cls_struct_fields;\n \n-  struct cls_struct_3byte_1 g_dbl = { 15, 125 };\n-  struct cls_struct_3byte_1 f_dbl = { 9, 19 };\n-  struct cls_struct_3byte_1 res_dbl;\n-\n   cls_struct_fields[0] = &ffi_type_uchar;\n   cls_struct_fields[1] = &ffi_type_ushort;\n   cls_struct_fields[2] = NULL;"}, {"sha": "2d6d8b622c3734c3b68c2a89294c1f5020294fae", "filename": "libffi/testsuite/libffi.call/cls_4_1byte.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fcls_4_1byte.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fcls_4_1byte.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_4_1byte.c?ref=b4b575ce7854f4a49de8de93f38b7639e01b040b", "patch": "@@ -56,15 +56,15 @@ int main (void)\n   ffi_type cls_struct_type;\n   ffi_type* dbl_arg_types[5];\n \n+  struct cls_struct_4_1byte g_dbl = { 12, 13, 14, 15 };\n+  struct cls_struct_4_1byte f_dbl = { 178, 179, 180, 181 };\n+  struct cls_struct_4_1byte res_dbl;\n+\n   cls_struct_type.size = 0;\n   cls_struct_type.alignment = 0;\n   cls_struct_type.type = FFI_TYPE_STRUCT;\n   cls_struct_type.elements = cls_struct_fields;\n \n-  struct cls_struct_4_1byte g_dbl = { 12, 13, 14, 15 };\n-  struct cls_struct_4_1byte f_dbl = { 178, 179, 180, 181 };\n-  struct cls_struct_4_1byte res_dbl;\n-\n   cls_struct_fields[0] = &ffi_type_uchar;\n   cls_struct_fields[1] = &ffi_type_uchar;\n   cls_struct_fields[2] = &ffi_type_uchar;"}, {"sha": "4ac378776b5cd1ea6792b2ffdda31fb0549a0430", "filename": "libffi/testsuite/libffi.call/cls_4byte.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fcls_4byte.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fcls_4byte.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_4byte.c?ref=b4b575ce7854f4a49de8de93f38b7639e01b040b", "patch": "@@ -50,15 +50,15 @@ int main (void)\n   ffi_type cls_struct_type;\n   ffi_type* dbl_arg_types[5];\n \n+  struct cls_struct_4byte g_dbl = { 127, 120 };\n+  struct cls_struct_4byte f_dbl = { 12, 128 };\n+  struct cls_struct_4byte res_dbl;\n+\n   cls_struct_type.size = 0;\n   cls_struct_type.alignment = 0;\n   cls_struct_type.type = FFI_TYPE_STRUCT;\n   cls_struct_type.elements = cls_struct_fields;\n \n-  struct cls_struct_4byte g_dbl = { 127, 120 };\n-  struct cls_struct_4byte f_dbl = { 12, 128 };\n-  struct cls_struct_4byte res_dbl;\n-\n   cls_struct_fields[0] = &ffi_type_ushort;\n   cls_struct_fields[1] = &ffi_type_ushort;\n   cls_struct_fields[2] = NULL;"}, {"sha": "ad9d51c248c2da4f3ee010b8e5df770e38f91dfb", "filename": "libffi/testsuite/libffi.call/cls_5_1_byte.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fcls_5_1_byte.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fcls_5_1_byte.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_5_1_byte.c?ref=b4b575ce7854f4a49de8de93f38b7639e01b040b", "patch": "@@ -58,15 +58,15 @@ int main (void)\n   ffi_type cls_struct_type;\n   ffi_type* dbl_arg_types[5];\n \n+  struct cls_struct_5byte g_dbl = { 127, 120, 1, 3, 4 };\n+  struct cls_struct_5byte f_dbl = { 12, 128, 9, 3, 4 };\n+  struct cls_struct_5byte res_dbl = { 0, 0, 0, 0, 0 };\n+\n   cls_struct_type.size = 0;\n   cls_struct_type.alignment = 0;\n   cls_struct_type.type = FFI_TYPE_STRUCT;\n   cls_struct_type.elements = cls_struct_fields;\n \n-  struct cls_struct_5byte g_dbl = { 127, 120, 1, 3, 4 };\n-  struct cls_struct_5byte f_dbl = { 12, 128, 9, 3, 4 };\n-  struct cls_struct_5byte res_dbl = { 0, 0, 0, 0, 0 };\n-\n   cls_struct_fields[0] = &ffi_type_uchar;\n   cls_struct_fields[1] = &ffi_type_uchar;\n   cls_struct_fields[2] = &ffi_type_uchar;"}, {"sha": "4e0c0003c0aa5878c0bc327544bb279d7b5b94ed", "filename": "libffi/testsuite/libffi.call/cls_5byte.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fcls_5byte.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fcls_5byte.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_5byte.c?ref=b4b575ce7854f4a49de8de93f38b7639e01b040b", "patch": "@@ -53,15 +53,15 @@ int main (void)\n   ffi_type cls_struct_type;\n   ffi_type* dbl_arg_types[5];\n \n+  struct cls_struct_5byte g_dbl = { 127, 120, 1 };\n+  struct cls_struct_5byte f_dbl = { 12, 128, 9 };\n+  struct cls_struct_5byte res_dbl = { 0, 0, 0 };\n+\n   cls_struct_type.size = 0;\n   cls_struct_type.alignment = 0;\n   cls_struct_type.type = FFI_TYPE_STRUCT;\n   cls_struct_type.elements = cls_struct_fields;\n \n-  struct cls_struct_5byte g_dbl = { 127, 120, 1 };\n-  struct cls_struct_5byte f_dbl = { 12, 128, 9 };\n-  struct cls_struct_5byte res_dbl = { 0, 0, 0 };\n-\n   cls_struct_fields[0] = &ffi_type_ushort;\n   cls_struct_fields[1] = &ffi_type_ushort;\n   cls_struct_fields[2] = &ffi_type_uchar;"}, {"sha": "a55edc2c7b9df3e70689730920fab6dc03400074", "filename": "libffi/testsuite/libffi.call/cls_64byte.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fcls_64byte.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fcls_64byte.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_64byte.c?ref=b4b575ce7854f4a49de8de93f38b7639e01b040b", "patch": "@@ -66,17 +66,17 @@ int main (void)\n   ffi_type cls_struct_type;\n   ffi_type* dbl_arg_types[5];\n \n-  cls_struct_type.size = 0;\n-  cls_struct_type.alignment = 0;\n-  cls_struct_type.type = FFI_TYPE_STRUCT;\n-  cls_struct_type.elements = cls_struct_fields;\n-\n   struct cls_struct_64byte e_dbl = { 9.0, 2.0, 6.0, 5.0, 3.0, 4.0, 8.0, 1.0 };\n   struct cls_struct_64byte f_dbl = { 1.0, 2.0, 3.0, 7.0, 2.0, 5.0, 6.0, 7.0 };\n   struct cls_struct_64byte g_dbl = { 4.0, 5.0, 7.0, 9.0, 1.0, 1.0, 2.0, 9.0 };\n   struct cls_struct_64byte h_dbl = { 8.0, 6.0, 1.0, 4.0, 0.0, 3.0, 3.0, 1.0 };\n   struct cls_struct_64byte res_dbl;\n \n+  cls_struct_type.size = 0;\n+  cls_struct_type.alignment = 0;\n+  cls_struct_type.type = FFI_TYPE_STRUCT;\n+  cls_struct_type.elements = cls_struct_fields;\n+\n   cls_struct_fields[0] = &ffi_type_double;\n   cls_struct_fields[1] = &ffi_type_double;\n   cls_struct_fields[2] = &ffi_type_double;"}, {"sha": "b4dcdba47283f770454bf10f806980e7bb6b9fef", "filename": "libffi/testsuite/libffi.call/cls_6_1_byte.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fcls_6_1_byte.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fcls_6_1_byte.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_6_1_byte.c?ref=b4b575ce7854f4a49de8de93f38b7639e01b040b", "patch": "@@ -60,15 +60,15 @@ int main (void)\n   ffi_type cls_struct_type;\n   ffi_type* dbl_arg_types[5];\n \n+  struct cls_struct_6byte g_dbl = { 127, 120, 1, 3, 4, 5 };\n+  struct cls_struct_6byte f_dbl = { 12, 128, 9, 3, 4, 5 };\n+  struct cls_struct_6byte res_dbl = { 0, 0, 0, 0, 0, 0 };\n+\n   cls_struct_type.size = 0;\n   cls_struct_type.alignment = 0;\n   cls_struct_type.type = FFI_TYPE_STRUCT;\n   cls_struct_type.elements = cls_struct_fields;\n \n-  struct cls_struct_6byte g_dbl = { 127, 120, 1, 3, 4, 5 };\n-  struct cls_struct_6byte f_dbl = { 12, 128, 9, 3, 4, 5 };\n-  struct cls_struct_6byte res_dbl = { 0, 0, 0, 0, 0, 0 };\n-\n   cls_struct_fields[0] = &ffi_type_uchar;\n   cls_struct_fields[1] = &ffi_type_uchar;\n   cls_struct_fields[2] = &ffi_type_uchar;"}, {"sha": "740678017b3a021fd11a330eb7adc0e491d8209b", "filename": "libffi/testsuite/libffi.call/cls_6byte.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fcls_6byte.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fcls_6byte.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_6byte.c?ref=b4b575ce7854f4a49de8de93f38b7639e01b040b", "patch": "@@ -56,15 +56,15 @@ int main (void)\n   ffi_type cls_struct_type;\n   ffi_type* dbl_arg_types[5];\n \n+  struct cls_struct_6byte g_dbl = { 127, 120, 1, 128 };\n+  struct cls_struct_6byte f_dbl = { 12, 128, 9, 127 };\n+  struct cls_struct_6byte res_dbl;\n+\n   cls_struct_type.size = 0;\n   cls_struct_type.alignment = 0;\n   cls_struct_type.type = FFI_TYPE_STRUCT;\n   cls_struct_type.elements = cls_struct_fields;\n \n-  struct cls_struct_6byte g_dbl = { 127, 120, 1, 128 };\n-  struct cls_struct_6byte f_dbl = { 12, 128, 9, 127 };\n-  struct cls_struct_6byte res_dbl;\n-\n   cls_struct_fields[0] = &ffi_type_ushort;\n   cls_struct_fields[1] = &ffi_type_ushort;\n   cls_struct_fields[2] = &ffi_type_uchar;"}, {"sha": "14a7e96f9d6569b4f94247297ab58ba6e6a1a6da", "filename": "libffi/testsuite/libffi.call/cls_7_1_byte.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fcls_7_1_byte.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fcls_7_1_byte.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_7_1_byte.c?ref=b4b575ce7854f4a49de8de93f38b7639e01b040b", "patch": "@@ -62,15 +62,15 @@ int main (void)\n   ffi_type cls_struct_type;\n   ffi_type* dbl_arg_types[5];\n \n+  struct cls_struct_7byte g_dbl = { 127, 120, 1, 3, 4, 5, 6 };\n+  struct cls_struct_7byte f_dbl = { 12, 128, 9, 3, 4, 5, 6 };\n+  struct cls_struct_7byte res_dbl = { 0, 0, 0, 0, 0, 0, 0 };\n+\n   cls_struct_type.size = 0;\n   cls_struct_type.alignment = 0;\n   cls_struct_type.type = FFI_TYPE_STRUCT;\n   cls_struct_type.elements = cls_struct_fields;\n \n-  struct cls_struct_7byte g_dbl = { 127, 120, 1, 3, 4, 5, 6 };\n-  struct cls_struct_7byte f_dbl = { 12, 128, 9, 3, 4, 5, 6 };\n-  struct cls_struct_7byte res_dbl = { 0, 0, 0, 0, 0, 0, 0 };\n-\n   cls_struct_fields[0] = &ffi_type_uchar;\n   cls_struct_fields[1] = &ffi_type_uchar;\n   cls_struct_fields[2] = &ffi_type_uchar;"}, {"sha": "1645cc635f9afb6410c650bb68f2a066e7cee391", "filename": "libffi/testsuite/libffi.call/cls_7byte.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fcls_7byte.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fcls_7byte.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_7byte.c?ref=b4b575ce7854f4a49de8de93f38b7639e01b040b", "patch": "@@ -55,15 +55,15 @@ int main (void)\n   ffi_type cls_struct_type;\n   ffi_type* dbl_arg_types[5];\n \n+  struct cls_struct_7byte g_dbl = { 127, 120, 1, 254 };\n+  struct cls_struct_7byte f_dbl = { 12, 128, 9, 255 };\n+  struct cls_struct_7byte res_dbl;\n+\n   cls_struct_type.size = 0;\n   cls_struct_type.alignment = 0;\n   cls_struct_type.type = FFI_TYPE_STRUCT;\n   cls_struct_type.elements = cls_struct_fields;\n \n-  struct cls_struct_7byte g_dbl = { 127, 120, 1, 254 };\n-  struct cls_struct_7byte f_dbl = { 12, 128, 9, 255 };\n-  struct cls_struct_7byte res_dbl;\n-\n   cls_struct_fields[0] = &ffi_type_ushort;\n   cls_struct_fields[1] = &ffi_type_ushort;\n   cls_struct_fields[2] = &ffi_type_uchar;"}, {"sha": "f6c1ea570ac8638227b2e8541bc42f7f8ef71506", "filename": "libffi/testsuite/libffi.call/cls_8byte.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fcls_8byte.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fcls_8byte.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_8byte.c?ref=b4b575ce7854f4a49de8de93f38b7639e01b040b", "patch": "@@ -49,15 +49,15 @@ int main (void)\n   ffi_type cls_struct_type;\n   ffi_type* dbl_arg_types[5];\n \n+  struct cls_struct_8byte g_dbl = { 1, 2.0 };\n+  struct cls_struct_8byte f_dbl = { 4, 5.0 };\n+  struct cls_struct_8byte res_dbl;\n+\n   cls_struct_type.size = 0;\n   cls_struct_type.alignment = 0;\n   cls_struct_type.type = FFI_TYPE_STRUCT;\n   cls_struct_type.elements = cls_struct_fields;\n \n-  struct cls_struct_8byte g_dbl = { 1, 2.0 };\n-  struct cls_struct_8byte f_dbl = { 4, 5.0 };\n-  struct cls_struct_8byte res_dbl;\n-\n   cls_struct_fields[0] = &ffi_type_sint;\n   cls_struct_fields[1] = &ffi_type_float;\n   cls_struct_fields[2] = NULL;"}, {"sha": "0b8572223c9c5e5f6d8e2179535647c52916a28e", "filename": "libffi/testsuite/libffi.call/cls_9byte1.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fcls_9byte1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fcls_9byte1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_9byte1.c?ref=b4b575ce7854f4a49de8de93f38b7639e01b040b", "patch": "@@ -50,15 +50,15 @@ int main (void)\n   ffi_type cls_struct_type;\n   ffi_type* dbl_arg_types[3];\n \n+  struct cls_struct_9byte h_dbl = { 7, 8.0};\n+  struct cls_struct_9byte j_dbl = { 1, 9.0};\n+  struct cls_struct_9byte res_dbl;\n+\n   cls_struct_type.size = 0;\n   cls_struct_type.alignment = 0;\n   cls_struct_type.type = FFI_TYPE_STRUCT;\n   cls_struct_type.elements = cls_struct_fields;\n \n-  struct cls_struct_9byte h_dbl = { 7, 8.0};\n-  struct cls_struct_9byte j_dbl = { 1, 9.0};\n-  struct cls_struct_9byte res_dbl;\n-\n   cls_struct_fields[0] = &ffi_type_sint;\n   cls_struct_fields[1] = &ffi_type_double;\n   cls_struct_fields[2] = NULL;"}, {"sha": "edf991de73eefcbf379294528ecb8727ff19b0f9", "filename": "libffi/testsuite/libffi.call/cls_9byte2.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fcls_9byte2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fcls_9byte2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_9byte2.c?ref=b4b575ce7854f4a49de8de93f38b7639e01b040b", "patch": "@@ -50,15 +50,15 @@ int main (void)\n   ffi_type cls_struct_type;\n   ffi_type* dbl_arg_types[3];\n \n+  struct cls_struct_9byte h_dbl = { 7.0, 8};\n+  struct cls_struct_9byte j_dbl = { 1.0, 9};\n+  struct cls_struct_9byte res_dbl;\n+\n   cls_struct_type.size = 0;\n   cls_struct_type.alignment = 0;\n   cls_struct_type.type = FFI_TYPE_STRUCT;\n   cls_struct_type.elements = cls_struct_fields;\n \n-  struct cls_struct_9byte h_dbl = { 7.0, 8};\n-  struct cls_struct_9byte j_dbl = { 1.0, 9};\n-  struct cls_struct_9byte res_dbl;\n-\n   cls_struct_fields[0] = &ffi_type_double;\n   cls_struct_fields[1] = &ffi_type_sint;\n   cls_struct_fields[2] = NULL;"}, {"sha": "aad5f3ced6a038aa1b8e93b8f27f0dea350b534f", "filename": "libffi/testsuite/libffi.call/cls_align_double.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fcls_align_double.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fcls_align_double.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_align_double.c?ref=b4b575ce7854f4a49de8de93f38b7639e01b040b", "patch": "@@ -52,15 +52,15 @@ int main (void)\n   ffi_type cls_struct_type;\n   ffi_type* dbl_arg_types[5];\n \n+  struct cls_struct_align g_dbl = { 12, 4951, 127 };\n+  struct cls_struct_align f_dbl = { 1, 9320, 13 };\n+  struct cls_struct_align res_dbl;\n+\n   cls_struct_type.size = 0;\n   cls_struct_type.alignment = 0;\n   cls_struct_type.type = FFI_TYPE_STRUCT;\n   cls_struct_type.elements = cls_struct_fields;\n \n-  struct cls_struct_align g_dbl = { 12, 4951, 127 };\n-  struct cls_struct_align f_dbl = { 1, 9320, 13 };\n-  struct cls_struct_align res_dbl;\n-\n   cls_struct_fields[0] = &ffi_type_uchar;\n   cls_struct_fields[1] = &ffi_type_double;\n   cls_struct_fields[2] = &ffi_type_uchar;"}, {"sha": "37e085529e7a08314effe15244faf38b8ddfac78", "filename": "libffi/testsuite/libffi.call/cls_align_float.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fcls_align_float.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fcls_align_float.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_align_float.c?ref=b4b575ce7854f4a49de8de93f38b7639e01b040b", "patch": "@@ -50,15 +50,15 @@ int main (void)\n   ffi_type cls_struct_type;\n   ffi_type* dbl_arg_types[5];\n \n+  struct cls_struct_align g_dbl = { 12, 4951, 127 };\n+  struct cls_struct_align f_dbl = { 1, 9320, 13 };\n+  struct cls_struct_align res_dbl;\n+\n   cls_struct_type.size = 0;\n   cls_struct_type.alignment = 0;\n   cls_struct_type.type = FFI_TYPE_STRUCT;\n   cls_struct_type.elements = cls_struct_fields;\n \n-  struct cls_struct_align g_dbl = { 12, 4951, 127 };\n-  struct cls_struct_align f_dbl = { 1, 9320, 13 };\n-  struct cls_struct_align res_dbl;\n-\n   cls_struct_fields[0] = &ffi_type_uchar;\n   cls_struct_fields[1] = &ffi_type_float;\n   cls_struct_fields[2] = &ffi_type_uchar;"}, {"sha": "b3322d8615136813f541c3f051fbfc4c3803c328", "filename": "libffi/testsuite/libffi.call/cls_align_longdouble.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fcls_align_longdouble.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fcls_align_longdouble.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_align_longdouble.c?ref=b4b575ce7854f4a49de8de93f38b7639e01b040b", "patch": "@@ -51,15 +51,15 @@ int main (void)\n   ffi_type cls_struct_type;\n   ffi_type* dbl_arg_types[5];\n \n+  struct cls_struct_align g_dbl = { 12, 4951, 127 };\n+  struct cls_struct_align f_dbl = { 1, 9320, 13 };\n+  struct cls_struct_align res_dbl;\n+\n   cls_struct_type.size = 0;\n   cls_struct_type.alignment = 0;\n   cls_struct_type.type = FFI_TYPE_STRUCT;\n   cls_struct_type.elements = cls_struct_fields;\n \n-  struct cls_struct_align g_dbl = { 12, 4951, 127 };\n-  struct cls_struct_align f_dbl = { 1, 9320, 13 };\n-  struct cls_struct_align res_dbl;\n-\n   cls_struct_fields[0] = &ffi_type_uchar;\n   cls_struct_fields[1] = &ffi_type_longdouble;\n   cls_struct_fields[2] = &ffi_type_uchar;"}, {"sha": "15f936546528f5c64463b941a3d9a94470e11f98", "filename": "libffi/testsuite/libffi.call/cls_align_longdouble_split.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fcls_align_longdouble_split.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fcls_align_longdouble_split.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_align_longdouble_split.c?ref=b4b575ce7854f4a49de8de93f38b7639e01b040b", "patch": "@@ -87,15 +87,15 @@ int main (void)\n \tffi_type cls_struct_type;\n \tffi_type* dbl_arg_types[3];\n \n+\tstruct cls_struct_align g_dbl = { 1, 2, 3, 4, 5, 6, 7 };\n+\tstruct cls_struct_align f_dbl = { 8, 9, 10, 11, 12, 13, 14 };\n+\tstruct cls_struct_align res_dbl;\n+\n \tcls_struct_type.size = 0;\n \tcls_struct_type.alignment = 0;\n \tcls_struct_type.type = FFI_TYPE_STRUCT;\n \tcls_struct_type.elements = cls_struct_fields;\n \n-\tstruct cls_struct_align g_dbl = { 1, 2, 3, 4, 5, 6, 7 };\n-\tstruct cls_struct_align f_dbl = { 8, 9, 10, 11, 12, 13, 14 };\n-\tstruct cls_struct_align res_dbl;\n-\n \tcls_struct_fields[0] = &ffi_type_longdouble;\n \tcls_struct_fields[1] = &ffi_type_longdouble;\n \tcls_struct_fields[2] = &ffi_type_longdouble;"}, {"sha": "ca1c356cbe76b5fb0ff86f2480d878c91d2d4dae", "filename": "libffi/testsuite/libffi.call/cls_align_longdouble_split2.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fcls_align_longdouble_split2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fcls_align_longdouble_split2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_align_longdouble_split2.c?ref=b4b575ce7854f4a49de8de93f38b7639e01b040b", "patch": "@@ -67,15 +67,15 @@ int main (void)\n \tffi_type cls_struct_type;\n \tffi_type* dbl_arg_types[3];\n \n+\tstruct cls_struct_align g_dbl = { 1, 2, 3, 4, 5, 6, 7 };\n+\tstruct cls_struct_align f_dbl = { 8, 9, 10, 11, 12, 13, 14 };\n+\tstruct cls_struct_align res_dbl;\n+\n \tcls_struct_type.size = 0;\n \tcls_struct_type.alignment = 0;\n \tcls_struct_type.type = FFI_TYPE_STRUCT;\n \tcls_struct_type.elements = cls_struct_fields;\n \n-\tstruct cls_struct_align g_dbl = { 1, 2, 3, 4, 5, 6, 7 };\n-\tstruct cls_struct_align f_dbl = { 8, 9, 10, 11, 12, 13, 14 };\n-\tstruct cls_struct_align res_dbl;\n-\n \tcls_struct_fields[0] = &ffi_type_longdouble;\n \tcls_struct_fields[1] = &ffi_type_longdouble;\n \tcls_struct_fields[2] = &ffi_type_longdouble;"}, {"sha": "8fbf36a5c1151513c0eb6faa0d71da6b2d32692c", "filename": "libffi/testsuite/libffi.call/cls_align_pointer.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fcls_align_pointer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fcls_align_pointer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_align_pointer.c?ref=b4b575ce7854f4a49de8de93f38b7639e01b040b", "patch": "@@ -54,15 +54,15 @@ int main (void)\n   ffi_type cls_struct_type;\n   ffi_type* dbl_arg_types[5];\n \n+  struct cls_struct_align g_dbl = { 12, (void *)4951, 127 };\n+  struct cls_struct_align f_dbl = { 1, (void *)9320, 13 };\n+  struct cls_struct_align res_dbl;\n+\n   cls_struct_type.size = 0;\n   cls_struct_type.alignment = 0;\n   cls_struct_type.type = FFI_TYPE_STRUCT;\n   cls_struct_type.elements = cls_struct_fields;\n \n-  struct cls_struct_align g_dbl = { 12, (void *)4951, 127 };\n-  struct cls_struct_align f_dbl = { 1, (void *)9320, 13 };\n-  struct cls_struct_align res_dbl;\n-\n   cls_struct_fields[0] = &ffi_type_uchar;\n   cls_struct_fields[1] = &ffi_type_pointer;\n   cls_struct_fields[2] = &ffi_type_uchar;"}, {"sha": "039b874732005140eea0cb02f941b04f9972cfc6", "filename": "libffi/testsuite/libffi.call/cls_align_sint16.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fcls_align_sint16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fcls_align_sint16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_align_sint16.c?ref=b4b575ce7854f4a49de8de93f38b7639e01b040b", "patch": "@@ -50,15 +50,15 @@ int main (void)\n   ffi_type cls_struct_type;\n   ffi_type* dbl_arg_types[5];\n \n+  struct cls_struct_align g_dbl = { 12, 4951, 127 };\n+  struct cls_struct_align f_dbl = { 1, 9320, 13 };\n+  struct cls_struct_align res_dbl;\n+\n   cls_struct_type.size = 0;\n   cls_struct_type.alignment = 0;\n   cls_struct_type.type = FFI_TYPE_STRUCT;\n   cls_struct_type.elements = cls_struct_fields;\n \n-  struct cls_struct_align g_dbl = { 12, 4951, 127 };\n-  struct cls_struct_align f_dbl = { 1, 9320, 13 };\n-  struct cls_struct_align res_dbl;\n-\n   cls_struct_fields[0] = &ffi_type_uchar;\n   cls_struct_fields[1] = &ffi_type_sshort;\n   cls_struct_fields[2] = &ffi_type_uchar;"}, {"sha": "c96c6d136df1bba986759d2804edba9d1ccd698a", "filename": "libffi/testsuite/libffi.call/cls_align_sint32.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fcls_align_sint32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fcls_align_sint32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_align_sint32.c?ref=b4b575ce7854f4a49de8de93f38b7639e01b040b", "patch": "@@ -50,15 +50,15 @@ int main (void)\n   ffi_type cls_struct_type;\n   ffi_type* dbl_arg_types[5];\n \n+  struct cls_struct_align g_dbl = { 12, 4951, 127 };\n+  struct cls_struct_align f_dbl = { 1, 9320, 13 };\n+  struct cls_struct_align res_dbl;\n+\n   cls_struct_type.size = 0;\n   cls_struct_type.alignment = 0;\n   cls_struct_type.type = FFI_TYPE_STRUCT;\n   cls_struct_type.elements = cls_struct_fields;\n \n-  struct cls_struct_align g_dbl = { 12, 4951, 127 };\n-  struct cls_struct_align f_dbl = { 1, 9320, 13 };\n-  struct cls_struct_align res_dbl;\n-\n   cls_struct_fields[0] = &ffi_type_uchar;\n   cls_struct_fields[1] = &ffi_type_sint;\n   cls_struct_fields[2] = &ffi_type_uchar;"}, {"sha": "9aa7bdddff7a5fee1e98917c6629143cdb0b3def", "filename": "libffi/testsuite/libffi.call/cls_align_sint64.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fcls_align_sint64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fcls_align_sint64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_align_sint64.c?ref=b4b575ce7854f4a49de8de93f38b7639e01b040b", "patch": "@@ -51,15 +51,15 @@ int main (void)\n   ffi_type cls_struct_type;\n   ffi_type* dbl_arg_types[5];\n \n+  struct cls_struct_align g_dbl = { 12, 4951, 127 };\n+  struct cls_struct_align f_dbl = { 1, 9320, 13 };\n+  struct cls_struct_align res_dbl;\n+\n   cls_struct_type.size = 0;\n   cls_struct_type.alignment = 0;\n   cls_struct_type.type = FFI_TYPE_STRUCT;\n   cls_struct_type.elements = cls_struct_fields;\n \n-  struct cls_struct_align g_dbl = { 12, 4951, 127 };\n-  struct cls_struct_align f_dbl = { 1, 9320, 13 };\n-  struct cls_struct_align res_dbl;\n-\n   cls_struct_fields[0] = &ffi_type_uchar;\n   cls_struct_fields[1] = &ffi_type_sint64;\n   cls_struct_fields[2] = &ffi_type_uchar;"}, {"sha": "97620b79d1fbec68d434a018453ab8db62aa723f", "filename": "libffi/testsuite/libffi.call/cls_align_uint16.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fcls_align_uint16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fcls_align_uint16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_align_uint16.c?ref=b4b575ce7854f4a49de8de93f38b7639e01b040b", "patch": "@@ -50,15 +50,15 @@ int main (void)\n   ffi_type cls_struct_type;\n   ffi_type* dbl_arg_types[5];\n \n+  struct cls_struct_align g_dbl = { 12, 4951, 127 };\n+  struct cls_struct_align f_dbl = { 1, 9320, 13 };\n+  struct cls_struct_align res_dbl;\n+\n   cls_struct_type.size = 0;\n   cls_struct_type.alignment = 0;\n   cls_struct_type.type = FFI_TYPE_STRUCT;\n   cls_struct_type.elements = cls_struct_fields;\n \n-  struct cls_struct_align g_dbl = { 12, 4951, 127 };\n-  struct cls_struct_align f_dbl = { 1, 9320, 13 };\n-  struct cls_struct_align res_dbl;\n-\n   cls_struct_fields[0] = &ffi_type_uchar;\n   cls_struct_fields[1] = &ffi_type_ushort;\n   cls_struct_fields[2] = &ffi_type_uchar;"}, {"sha": "5766fadf0dc9b53934194558b7d7559830482693", "filename": "libffi/testsuite/libffi.call/cls_align_uint32.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fcls_align_uint32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fcls_align_uint32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_align_uint32.c?ref=b4b575ce7854f4a49de8de93f38b7639e01b040b", "patch": "@@ -50,15 +50,15 @@ int main (void)\n   ffi_type cls_struct_type;\n   ffi_type* dbl_arg_types[5];\n \n+  struct cls_struct_align g_dbl = { 12, 4951, 127 };\n+  struct cls_struct_align f_dbl = { 1, 9320, 13 };\n+  struct cls_struct_align res_dbl;\n+\n   cls_struct_type.size = 0;\n   cls_struct_type.alignment = 0;\n   cls_struct_type.type = FFI_TYPE_STRUCT;\n   cls_struct_type.elements = cls_struct_fields;\n \n-  struct cls_struct_align g_dbl = { 12, 4951, 127 };\n-  struct cls_struct_align f_dbl = { 1, 9320, 13 };\n-  struct cls_struct_align res_dbl;\n-\n   cls_struct_fields[0] = &ffi_type_uchar;\n   cls_struct_fields[1] = &ffi_type_uint;\n   cls_struct_fields[2] = &ffi_type_uchar;"}, {"sha": "a52cb8939c4fa161b383628a8d72e6b8fdd6a64e", "filename": "libffi/testsuite/libffi.call/cls_align_uint64.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fcls_align_uint64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fcls_align_uint64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_align_uint64.c?ref=b4b575ce7854f4a49de8de93f38b7639e01b040b", "patch": "@@ -52,15 +52,15 @@ int main (void)\n   ffi_type cls_struct_type;\n   ffi_type* dbl_arg_types[5];\n \n+  struct cls_struct_align g_dbl = { 12, 4951, 127 };\n+  struct cls_struct_align f_dbl = { 1, 9320, 13 };\n+  struct cls_struct_align res_dbl;\n+\n   cls_struct_type.size = 0;\n   cls_struct_type.alignment = 0;\n   cls_struct_type.type = FFI_TYPE_STRUCT;\n   cls_struct_type.elements = cls_struct_fields;\n \n-  struct cls_struct_align g_dbl = { 12, 4951, 127 };\n-  struct cls_struct_align f_dbl = { 1, 9320, 13 };\n-  struct cls_struct_align res_dbl;\n-\n   cls_struct_fields[0] = &ffi_type_uchar;\n   cls_struct_fields[1] = &ffi_type_uint64;\n   cls_struct_fields[2] = &ffi_type_uchar;"}, {"sha": "d6637911e584f9c11dce73d69e7d3da0811d800e", "filename": "libffi/testsuite/libffi.call/cls_dbls_struct.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fcls_dbls_struct.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fcls_dbls_struct.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_dbls_struct.c?ref=b4b575ce7854f4a49de8de93f38b7639e01b040b", "patch": "@@ -37,6 +37,8 @@ int main(int argc __UNUSED__, char** argv __UNUSED__)\n \tffi_type\tts1_type;\n \tffi_type*\tts1_type_elements[4];\n \n+\tDbls arg = { 1.0, 2.0 };\n+\n \tts1_type.size = 0;\n \tts1_type.alignment = 0;\n \tts1_type.type = FFI_TYPE_STRUCT;\n@@ -48,8 +50,6 @@ int main(int argc __UNUSED__, char** argv __UNUSED__)\n \n \tcl_arg_types[0] = &ts1_type;\n \n-\tDbls arg = { 1.0, 2.0 };\n-\n \t/* Initialize the cif */\n \tCHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1,\n \t\t\t\t &ffi_type_void, cl_arg_types) == FFI_OK);"}, {"sha": "dbf20002dfc9c584446c463d727b0262d1812fd8", "filename": "libffi/testsuite/libffi.call/cls_double_va.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fcls_double_va.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fcls_double_va.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_double_va.c?ref=b4b575ce7854f4a49de8de93f38b7639e01b040b", "patch": "@@ -7,7 +7,6 @@\n /* { dg-do run { xfail strongarm*-*-* xscale*-*-* } } */\n /* { dg-output \"\" { xfail avr32*-*-* } } */\n /* { dg-output \"\" { xfail mips-sgi-irix6* } } PR libffi/46660 */\n-/* { dg-skip-if \"\" arm*-*-* { \"-mfloat-abi=hard\" } { \"\" } } */\n \n #include \"ffitest.h\"\n "}, {"sha": "4fa1ea28ace870fd70fd8102591e9114d6e000e1", "filename": "libffi/testsuite/libffi.call/cls_longdouble_va.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fcls_longdouble_va.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fcls_longdouble_va.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_longdouble_va.c?ref=b4b575ce7854f4a49de8de93f38b7639e01b040b", "patch": "@@ -7,7 +7,6 @@\n /* { dg-do run { xfail strongarm*-*-* xscale*-*-* } } */\n /* { dg-output \"\" { xfail avr32*-*-* x86_64-*-mingw* } } */\n /* { dg-output \"\" { xfail mips-sgi-irix6* } } PR libffi/46660 */\n-/* { dg-skip-if \"\" arm*-*-* { \"-mfloat-abi=hard\" } { \"\" } } */\n \n #include \"ffitest.h\"\n "}, {"sha": "e31139e428f66f3e89dc0b9230b0c305113d8217", "filename": "libffi/testsuite/libffi.call/cls_pointer_stack.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fcls_pointer_stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fcls_pointer_stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_pointer_stack.c?ref=b4b575ce7854f4a49de8de93f38b7639e01b040b", "patch": "@@ -28,11 +28,12 @@ void* cls_pointer_fn2(void* a1, void* a2)\n \tchar\t\ttrample6\t= trample4 + ((char*)&a2)[1];\n \tlong double\ttrample7\t= (intptr_t)trample5 + (intptr_t)trample1;\n \tchar\t\ttrample8\t= trample6 + trample2;\n+\tvoid*\t\tresult;\n \n \tdummyVar\t= dummy_func(trample1, trample2, trample3, trample4,\n \t\ttrample5, trample6, trample7, trample8);\n \n-\tvoid*\tresult\t= (void*)((intptr_t)a1 + (intptr_t)a2);\n+\tresult\t= (void*)((intptr_t)a1 + (intptr_t)a2);\n \n \tprintf(\"0x%08x 0x%08x: 0x%08x\\n\", \n \t       (unsigned int)(uintptr_t) a1,\n@@ -52,11 +53,12 @@ void* cls_pointer_fn1(void* a1, void* a2)\n \tchar\t\ttrample6\t= trample4 + ((char*)&a2)[1];\n \tlong double\ttrample7\t= (intptr_t)trample5 + (intptr_t)trample1;\n \tchar\t\ttrample8\t= trample6 + trample2;\n+\tvoid*\t\tresult;\n \n \tdummyVar\t= dummy_func(trample1, trample2, trample3, trample4,\n \t\ttrample5, trample6, trample7, trample8);\n \n-\tvoid*\tresult\t= (void*)((intptr_t)a1 + (intptr_t)a2);\n+\tresult\t= (void*)((intptr_t)a1 + (intptr_t)a2);\n \n \tprintf(\"0x%08x 0x%08x: 0x%08x\\n\",\n                (unsigned int)(intptr_t) a1,"}, {"sha": "91772bd406823b0108c16ec1b6ad333e4655acb5", "filename": "libffi/testsuite/libffi.call/cls_struct_va1.c", "status": "added", "additions": 114, "deletions": 0, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fcls_struct_va1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fcls_struct_va1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_struct_va1.c?ref=b4b575ce7854f4a49de8de93f38b7639e01b040b", "patch": "@@ -0,0 +1,114 @@\n+/* Area:\t\tffi_call, closure_call\n+   Purpose:\t\tTest doubles passed in variable argument lists.\n+   Limitations:\tnone.\n+   PR:\t\t\tnone.\n+   Originator:\tBlake Chaffin 6/6/2007\t */\n+\n+/* { dg-do run } */\n+/* { dg-output \"\" { xfail avr32*-*-* } } */\n+#include \"ffitest.h\"\n+\n+struct small_tag\n+{\n+  unsigned char a;\n+  unsigned char b;\n+};\n+\n+struct large_tag\n+{\n+  unsigned a;\n+  unsigned b;\n+  unsigned c;\n+  unsigned d;\n+  unsigned e;\n+};\n+\n+static void\n+test_fn (ffi_cif* cif __UNUSED__, void* resp,\n+\t void** args, void* userdata __UNUSED__)\n+{\n+  int n = *(int*)args[0];\n+  struct small_tag s1 = * (struct small_tag *) args[1];\n+  struct large_tag l1 = * (struct large_tag *) args[2];\n+  struct small_tag s2 = * (struct small_tag *) args[3];\n+\n+  printf (\"%d %d %d %d %d %d %d %d %d %d\\n\", n, s1.a, s1.b,\n+\t  l1.a, l1.b, l1.c, l1.d, l1.e,\n+\t  s2.a, s2.b);\n+  * (int*) resp = 42;\n+}\n+\n+int\n+main (void)\n+{\n+  ffi_cif cif;\n+  void *code;\n+  ffi_closure *pcl = ffi_closure_alloc (sizeof (ffi_closure), &code);\n+  ffi_type* arg_types[5];\n+\n+  ffi_arg res = 0;\n+\n+  ffi_type s_type;\n+  ffi_type *s_type_elements[3];\n+\n+  ffi_type l_type;\n+  ffi_type *l_type_elements[6];\n+\n+  struct small_tag s1;\n+  struct small_tag s2;\n+  struct large_tag l1;\n+\n+  int si;\n+\n+  s_type.size = 0;\n+  s_type.alignment = 0;\n+  s_type.type = FFI_TYPE_STRUCT;\n+  s_type.elements = s_type_elements;\n+\n+  s_type_elements[0] = &ffi_type_uchar;\n+  s_type_elements[1] = &ffi_type_uchar;\n+  s_type_elements[2] = NULL;\n+\n+  l_type.size = 0;\n+  l_type.alignment = 0;\n+  l_type.type = FFI_TYPE_STRUCT;\n+  l_type.elements = l_type_elements;\n+\n+  l_type_elements[0] = &ffi_type_uint;\n+  l_type_elements[1] = &ffi_type_uint;\n+  l_type_elements[2] = &ffi_type_uint;\n+  l_type_elements[3] = &ffi_type_uint;\n+  l_type_elements[4] = &ffi_type_uint;\n+  l_type_elements[5] = NULL;\n+\n+  arg_types[0] = &ffi_type_sint;\n+  arg_types[1] = &s_type;\n+  arg_types[2] = &l_type;\n+  arg_types[3] = &s_type;\n+  arg_types[4] = NULL;\n+\n+  CHECK(ffi_prep_cif_var(&cif, FFI_DEFAULT_ABI, 1, 4, &ffi_type_sint,\n+\t\t\t arg_types) == FFI_OK);\n+\n+  si = 4;\n+  s1.a = 5;\n+  s1.b = 6;\n+\n+  s2.a = 20;\n+  s2.b = 21;\n+\n+  l1.a = 10;\n+  l1.b = 11;\n+  l1.c = 12;\n+  l1.d = 13;\n+  l1.e = 14;\n+\n+  CHECK(ffi_prep_closure_loc(pcl, &cif, test_fn, NULL, code) == FFI_OK);\n+\n+  res = ((int (*)(int, ...))(code))(si, s1, l1, s2);\n+  // { dg-output \"4 5 6 10 11 12 13 14 20 21\" }\n+  printf(\"res: %d\\n\", (int) res);\n+  // { dg-output \"\\nres: 42\" }\n+\n+  exit(0);\n+}"}, {"sha": "19cd4f375e6a2dcfe41066dde1fc020fb343885d", "filename": "libffi/testsuite/libffi.call/cls_uchar_va.c", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fcls_uchar_va.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fcls_uchar_va.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_uchar_va.c?ref=b4b575ce7854f4a49de8de93f38b7639e01b040b", "patch": "@@ -0,0 +1,44 @@\n+/* Area:\tclosure_call\n+   Purpose:\tTest anonymous unsigned char argument.\n+   Limitations:\tnone.\n+   PR:\t\tnone.\n+   Originator:\tARM Ltd. */\n+\n+/* { dg-do run } */\n+#include \"ffitest.h\"\n+\n+typedef unsigned char T;\n+\n+static void cls_ret_T_fn(ffi_cif* cif __UNUSED__, void* resp, void** args,\n+\t\t\t void* userdata __UNUSED__)\n+ {\n+   *(T *)resp = *(T *)args[0];\n+\n+   printf(\"%d: %d %d\\n\", *(T *)resp, *(T *)args[0], *(T *)args[1]);\n+ }\n+\n+typedef T (*cls_ret_T)(T, ...);\n+\n+int main (void)\n+{\n+  ffi_cif cif;\n+  void *code;\n+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);\n+  ffi_type * cl_arg_types[3];\n+  T res;\n+\n+  cl_arg_types[0] = &ffi_type_uchar;\n+  cl_arg_types[1] = &ffi_type_uchar;\n+  cl_arg_types[2] = NULL;\n+\n+  /* Initialize the cif */\n+  CHECK(ffi_prep_cif_var(&cif, FFI_DEFAULT_ABI, 1, 2,\n+\t\t\t &ffi_type_uchar, cl_arg_types) == FFI_OK);\n+\n+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_ret_T_fn, NULL, code)  == FFI_OK);\n+  res = ((((cls_ret_T)code)(67, 4)));\n+  /* { dg-output \"67: 67 4\" } */\n+  printf(\"res: %d\\n\", res);\n+  /* { dg-output \"\\nres: 67\" } */\n+  exit(0);\n+}"}, {"sha": "150fddd515db36346203ab35c8136b14eccc4074", "filename": "libffi/testsuite/libffi.call/cls_uint_va.c", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fcls_uint_va.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fcls_uint_va.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_uint_va.c?ref=b4b575ce7854f4a49de8de93f38b7639e01b040b", "patch": "@@ -0,0 +1,45 @@\n+/* Area:\tclosure_call\n+   Purpose:\tTest anonymous unsigned int argument.\n+   Limitations:\tnone.\n+   PR:\t\tnone.\n+   Originator:\tARM Ltd. */\n+\n+/* { dg-do run } */\n+\n+#include \"ffitest.h\"\n+\n+typedef unsigned int T;\n+\n+static void cls_ret_T_fn(ffi_cif* cif __UNUSED__, void* resp, void** args,\n+\t\t\t void* userdata __UNUSED__)\n+ {\n+   *(T *)resp = *(T *)args[0];\n+\n+   printf(\"%d: %d %d\\n\", *(T *)resp, *(T *)args[0], *(T *)args[1]);\n+ }\n+\n+typedef T (*cls_ret_T)(T, ...);\n+\n+int main (void)\n+{\n+  ffi_cif cif;\n+  void *code;\n+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);\n+  ffi_type * cl_arg_types[3];\n+  T res;\n+\n+  cl_arg_types[0] = &ffi_type_uint;\n+  cl_arg_types[1] = &ffi_type_uint;\n+  cl_arg_types[2] = NULL;\n+\n+  /* Initialize the cif */\n+  CHECK(ffi_prep_cif_var(&cif, FFI_DEFAULT_ABI, 1, 2,\n+\t\t\t &ffi_type_uint, cl_arg_types) == FFI_OK);\n+\n+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_ret_T_fn, NULL, code)  == FFI_OK);\n+  res = ((((cls_ret_T)code)(67, 4)));\n+  /* { dg-output \"67: 67 4\" } */\n+  printf(\"res: %d\\n\", res);\n+  /* { dg-output \"\\nres: 67\" } */\n+  exit(0);\n+}"}, {"sha": "0315082e093ba0154e0429ec1b7c67575b619091", "filename": "libffi/testsuite/libffi.call/cls_ulong_va.c", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fcls_ulong_va.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fcls_ulong_va.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_ulong_va.c?ref=b4b575ce7854f4a49de8de93f38b7639e01b040b", "patch": "@@ -0,0 +1,45 @@\n+/* Area:\tclosure_call\n+   Purpose:\tTest anonymous unsigned long argument.\n+   Limitations:\tnone.\n+   PR:\t\tnone.\n+   Originator:\tARM Ltd. */\n+\n+/* { dg-do run } */\n+\n+#include \"ffitest.h\"\n+\n+typedef unsigned long T;\n+\n+static void cls_ret_T_fn(ffi_cif* cif __UNUSED__, void* resp, void** args,\n+\t\t\t void* userdata __UNUSED__)\n+ {\n+   *(T *)resp = *(T *)args[0];\n+\n+   printf(\"%ld: %ld %ld\\n\", *(T *)resp, *(T *)args[0], *(T *)args[1]);\n+ }\n+\n+typedef T (*cls_ret_T)(T, ...);\n+\n+int main (void)\n+{\n+  ffi_cif cif;\n+  void *code;\n+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);\n+  ffi_type * cl_arg_types[3];\n+  T res;\n+\n+  cl_arg_types[0] = &ffi_type_ulong;\n+  cl_arg_types[1] = &ffi_type_ulong;\n+  cl_arg_types[2] = NULL;\n+\n+  /* Initialize the cif */\n+  CHECK(ffi_prep_cif_var(&cif, FFI_DEFAULT_ABI, 1, 2,\n+\t\t\t &ffi_type_ulong, cl_arg_types) == FFI_OK);\n+\n+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_ret_T_fn, NULL, code)  == FFI_OK);\n+  res = ((((cls_ret_T)code)(67, 4)));\n+  /* { dg-output \"67: 67 4\" } */\n+  printf(\"res: %ld\\n\", res);\n+  /* { dg-output \"\\nres: 67\" } */\n+  exit(0);\n+}"}, {"sha": "b2b5a3b4627e769bb46b96dbfbe19be044e53b8f", "filename": "libffi/testsuite/libffi.call/cls_ushort_va.c", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fcls_ushort_va.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fcls_ushort_va.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_ushort_va.c?ref=b4b575ce7854f4a49de8de93f38b7639e01b040b", "patch": "@@ -0,0 +1,44 @@\n+/* Area:\tclosure_call\n+   Purpose:\tTest anonymous unsigned short argument.\n+   Limitations:\tnone.\n+   PR:\t\tnone.\n+   Originator:\tARM Ltd. */\n+\n+/* { dg-do run } */\n+#include \"ffitest.h\"\n+\n+typedef unsigned short T;\n+\n+static void cls_ret_T_fn(ffi_cif* cif __UNUSED__, void* resp, void** args,\n+\t\t\t void* userdata __UNUSED__)\n+ {\n+   *(T *)resp = *(T *)args[0];\n+\n+   printf(\"%d: %d %d\\n\", *(T *)resp, *(T *)args[0], *(T *)args[1]);\n+ }\n+\n+typedef T (*cls_ret_T)(T, ...);\n+\n+int main (void)\n+{\n+  ffi_cif cif;\n+  void *code;\n+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);\n+  ffi_type * cl_arg_types[3];\n+  T res;\n+\n+  cl_arg_types[0] = &ffi_type_ushort;\n+  cl_arg_types[1] = &ffi_type_ushort;\n+  cl_arg_types[2] = NULL;\n+\n+  /* Initialize the cif */\n+  CHECK(ffi_prep_cif_var(&cif, FFI_DEFAULT_ABI, 1, 2,\n+\t\t\t &ffi_type_ushort, cl_arg_types) == FFI_OK);\n+\n+  CHECK(ffi_prep_closure_loc(pcl, &cif, cls_ret_T_fn, NULL, code)  == FFI_OK);\n+  res = ((((cls_ret_T)code)(67, 4)));\n+  /* { dg-output \"67: 67 4\" } */\n+  printf(\"res: %d\\n\", res);\n+  /* { dg-output \"\\nres: 67\" } */\n+  exit(0);\n+}"}, {"sha": "bf6016186170d4f892ee26c5b21ef48242f4dda6", "filename": "libffi/testsuite/libffi.call/err_bad_typedef.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Ferr_bad_typedef.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Ferr_bad_typedef.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Ferr_bad_typedef.c?ref=b4b575ce7854f4a49de8de93f38b7639e01b040b", "patch": "@@ -13,10 +13,10 @@ int main (void)\n \tffi_cif cif;\n \tffi_type* arg_types[1];\n \n-\targ_types[0] = NULL;\n-\n \tffi_type\tbadType\t= ffi_type_void;\n \n+\targ_types[0] = NULL;\n+\n \tbadType.size = 0;\n \n \tCHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 0, &badType,"}, {"sha": "cbc4724ef8c1c816a1ca23b4fa72f17f35e4255c", "filename": "libffi/testsuite/libffi.call/fastthis1_win32.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Ffastthis1_win32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Ffastthis1_win32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Ffastthis1_win32.c?ref=b4b575ce7854f4a49de8de93f38b7639e01b040b", "patch": "@@ -8,7 +8,7 @@\n \n #include \"ffitest.h\"\n \n-static size_t __attribute__((fastcall)) my_fastcall_f(char *s, float a)\n+static size_t __FASTCALL__ my_fastcall_f(char *s, float a)\n {\n   return (size_t) ((int) strlen(s) + (int) a);\n }"}, {"sha": "7bdd0e17584c389f6deb69409c6726a71eac1abb", "filename": "libffi/testsuite/libffi.call/fastthis2_win32.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Ffastthis2_win32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Ffastthis2_win32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Ffastthis2_win32.c?ref=b4b575ce7854f4a49de8de93f38b7639e01b040b", "patch": "@@ -8,7 +8,7 @@\n \n #include \"ffitest.h\"\n \n-static size_t __attribute__((fastcall)) my_fastcall_f(float a, char *s)\n+static size_t __FASTCALL__ my_fastcall_f(float a, char *s)\n {\n   return (size_t) ((int) strlen(s) + (int) a);\n }"}, {"sha": "b5d606d9a15ecb6ad8c4b7accc7df7543f45aebc", "filename": "libffi/testsuite/libffi.call/fastthis3_win32.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Ffastthis3_win32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Ffastthis3_win32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Ffastthis3_win32.c?ref=b4b575ce7854f4a49de8de93f38b7639e01b040b", "patch": "@@ -8,7 +8,7 @@\n \n #include \"ffitest.h\"\n \n-static size_t __attribute__((fastcall)) my_fastcall_f(float a, char *s, int i)\n+static size_t __FASTCALL__ my_fastcall_f(float a, char *s, int i)\n {\n   return (size_t) ((int) strlen(s) + (int) a + i);\n }"}, {"sha": "d81d4dabade890effbd93027c69b1f2231be2a54", "filename": "libffi/testsuite/libffi.call/ffitest.h", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fffitest.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fffitest.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fffitest.h?ref=b4b575ce7854f4a49de8de93f38b7639e01b040b", "patch": "@@ -25,6 +25,14 @@\n #define __UNUSED__\n #endif\n \n+/* Define __FASTCALL__ so that other compilers than gcc can run the tests.  */\n+#undef __FASTCALL__\n+#if defined _MSC_VER\n+#define __FASTCALL__ __fastcall\n+#else\n+#define __FASTCALL__ __attribute__((fastcall))\n+#endif\n+\n /* Prefer MAP_ANON(YMOUS) to /dev/zero, since we don't need to keep a\n    file open.  */\n #ifdef HAVE_MMAP_ANON\n@@ -110,6 +118,15 @@\n #endif\n #endif\n \n+/* MSVC kludge.  */\n+#if defined _MSC_VER\n+#define PRIuPTR \"lu\"\n+#define PRIu8 \"u\"\n+#define PRId8 \"d\"\n+#define PRIu64 \"I64u\"\n+#define PRId64 \"I64d\"\n+#endif\n+\n #ifdef USING_MMAP\n static inline void *\n allocate_mmap (size_t size)"}, {"sha": "aae158edcc1db4618280063f26fe6407533fe802", "filename": "libffi/testsuite/libffi.call/float_va.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Ffloat_va.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Ffloat_va.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Ffloat_va.c?ref=b4b575ce7854f4a49de8de93f38b7639e01b040b", "patch": "@@ -25,18 +25,18 @@ double float_va_fn(unsigned int x, double y,...)\n   total+=(double)x;\n   total+=y;\n \n-  printf(\"%u: %.1lf :\", x, y);\n+  printf(\"%u: %.1f :\", x, y);\n \n   va_start(ap, y);\n   for(i=0;i<x;i++)\n   {\n     double arg=va_arg(ap, double);\n     total+=arg;\n-    printf(\" %d:%.1lf \", i, arg);\n+    printf(\" %d:%.1f \", i, arg);\n   }\n   va_end(ap);\n \n-  printf(\" total: %.1lf\\n\", total);\n+  printf(\" total: %.1f\\n\", total);\n \n   return total;\n }\n@@ -57,7 +57,7 @@ int main (void)\n   /* Call it statically and then via ffi */\n   resfp=float_va_fn(0,2.0);\n   // { dg-output \"0: 2.0 : total: 2.0\" }\n-  printf(\"compiled: %.1lf\\n\", resfp);\n+  printf(\"compiled: %.1f\\n\", resfp);\n   // { dg-output \"\\ncompiled: 2.0\" }\n \n   arg_types[0] = &ffi_type_uint;\n@@ -72,14 +72,14 @@ int main (void)\n   values[1] = &doubles[0];\n   ffi_call(&cif, FFI_FN(float_va_fn), &resfp, values);\n   // { dg-output \"\\n0: 2.0 : total: 2.0\" }\n-  printf(\"ffi: %.1lf\\n\", resfp);\n+  printf(\"ffi: %.1f\\n\", resfp);\n   // { dg-output \"\\nffi: 2.0\" }\n \n   /* Second test, float_va_fn(2,2.0,3.0,4.0), now with variadic params */\n   /* Call it statically and then via ffi */\n   resfp=float_va_fn(2,2.0,3.0,4.0);\n   // { dg-output \"\\n2: 2.0 : 0:3.0  1:4.0  total: 11.0\" }\n-  printf(\"compiled: %.1lf\\n\", resfp);\n+  printf(\"compiled: %.1f\\n\", resfp);\n   // { dg-output \"\\ncompiled: 11.0\" }\n \n   arg_types[0] = &ffi_type_uint;\n@@ -100,7 +100,7 @@ int main (void)\n   values[3] = &doubles[2];\n   ffi_call(&cif, FFI_FN(float_va_fn), &resfp, values);\n   // { dg-output \"\\n2: 2.0 : 0:3.0  1:4.0  total: 11.0\" }\n-  printf(\"ffi: %.1lf\\n\", resfp);\n+  printf(\"ffi: %.1f\\n\", resfp);\n   // { dg-output \"\\nffi: 11.0\" }\n \n   exit(0);"}, {"sha": "380fedf485850e5c9bd3b3e33e16e451e5e0c557", "filename": "libffi/testsuite/libffi.call/huge_struct.c", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fhuge_struct.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fhuge_struct.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fhuge_struct.c?ref=b4b575ce7854f4a49de8de93f38b7639e01b040b", "patch": "@@ -229,6 +229,19 @@ main(int argc __UNUSED__, const char** argv __UNUSED__)\n \tffi_type*\tst_fields[51];\n \tBigStruct\tretVal;\n \n+\tuint8_t\t\tui8\t\t= 1;\n+\tint8_t\t\tsi8\t\t= 2;\n+\tuint16_t\tui16\t= 3;\n+\tint16_t\t\tsi16\t= 4;\n+\tuint32_t\tui32\t= 5;\n+\tint32_t\t\tsi32\t= 6;\n+\tuint64_t\tui64\t= 7;\n+\tint64_t\t\tsi64\t= 8;\n+\tfloat\t\tf\t\t= 9;\n+\tdouble\t\td\t\t= 10;\n+\tlong double\tld\t\t= 11;\n+\tchar*\t\tp\t\t= (char*)0x12345678;\n+\n \tmemset (&retVal, 0, sizeof(retVal));\n \n \tret_struct_type.size = 0;\n@@ -251,19 +264,6 @@ main(int argc __UNUSED__, const char** argv __UNUSED__)\n \n \tst_fields[50] = NULL;\n \n-\tuint8_t\t\tui8\t\t= 1;\n-\tint8_t\t\tsi8\t\t= 2;\n-\tuint16_t\tui16\t= 3;\n-\tint16_t\t\tsi16\t= 4;\n-\tuint32_t\tui32\t= 5;\n-\tint32_t\t\tsi32\t= 6;\n-\tuint64_t\tui64\t= 7;\n-\tint64_t\t\tsi64\t= 8;\n-\tfloat\t\tf\t\t= 9;\n-\tdouble\t\td\t\t= 10;\n-\tlong double\tld\t\t= 11;\n-\tchar*\t\tp\t\t= (char*)0x12345678;\n-\n \targTypes[0]\t\t= argTypes[12]\t= argTypes[24]\t= argTypes[36]\t= argTypes[48]\t= &ffi_type_uint8;\n \targValues[0]\t= argValues[12]\t= argValues[24]\t= argValues[36]\t= argValues[48]\t= &ui8;\n \targTypes[1]\t\t= argTypes[13]\t= argTypes[25]\t= argTypes[37]\t= argTypes[49]\t= &ffi_type_sint8;"}, {"sha": "c15e3a0338294bfea5de2bf1652f2b01875c9253", "filename": "libffi/testsuite/libffi.call/nested_struct.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fnested_struct.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fnested_struct.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fnested_struct.c?ref=b4b575ce7854f4a49de8de93f38b7639e01b040b", "patch": "@@ -77,6 +77,12 @@ int main (void)\n   ffi_type cls_struct_type, cls_struct_type1, cls_struct_type2;\n   ffi_type* dbl_arg_types[5];\n \n+  struct cls_struct_16byte1 e_dbl = { 9.0, 2.0, 6};\n+  struct cls_struct_16byte2 f_dbl = { 1, 2.0, 3.0};\n+  struct cls_struct_combined g_dbl = {{4.0, 5.0, 6},\n+\t\t\t\t      {3, 1.0, 8.0}};\n+  struct cls_struct_combined res_dbl;\n+\n   cls_struct_type.size = 0;\n   cls_struct_type.alignment = 0;\n   cls_struct_type.type = FFI_TYPE_STRUCT;\n@@ -92,12 +98,6 @@ int main (void)\n   cls_struct_type2.type = FFI_TYPE_STRUCT;\n   cls_struct_type2.elements = cls_struct_fields2;\n \n-  struct cls_struct_16byte1 e_dbl = { 9.0, 2.0, 6};\n-  struct cls_struct_16byte2 f_dbl = { 1, 2.0, 3.0};\n-  struct cls_struct_combined g_dbl = {{4.0, 5.0, 6},\n-\t\t\t\t      {3, 1.0, 8.0}};\n-  struct cls_struct_combined res_dbl;\n-\n   cls_struct_fields[0] = &ffi_type_double;\n   cls_struct_fields[1] = &ffi_type_float;\n   cls_struct_fields[2] = &ffi_type_sint;"}, {"sha": "1087f7b1cfd6f8ef61e6fa51da288de281731dca", "filename": "libffi/testsuite/libffi.call/nested_struct1.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fnested_struct1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fnested_struct1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fnested_struct1.c?ref=b4b575ce7854f4a49de8de93f38b7639e01b040b", "patch": "@@ -81,6 +81,13 @@ int main (void)\n   ffi_type cls_struct_type, cls_struct_type1, cls_struct_type2;\n   ffi_type* dbl_arg_types[5];\n \n+  struct cls_struct_16byte1 e_dbl = { 9.0, 2.0, 6};\n+  struct cls_struct_16byte2 f_dbl = { 1, 2.0, 3.0};\n+  struct cls_struct_combined g_dbl = {{4.0, 5.0, 6},\n+\t\t\t\t      {3, 1.0, 8.0}};\n+  struct cls_struct_16byte1 h_dbl = { 3.0, 2.0, 4};\n+  struct cls_struct_combined res_dbl;\n+\n   cls_struct_type.size = 0;\n   cls_struct_type.alignment = 0;\n   cls_struct_type.type = FFI_TYPE_STRUCT;\n@@ -96,13 +103,6 @@ int main (void)\n   cls_struct_type2.type = FFI_TYPE_STRUCT;\n   cls_struct_type2.elements = cls_struct_fields2;\n \n-  struct cls_struct_16byte1 e_dbl = { 9.0, 2.0, 6};\n-  struct cls_struct_16byte2 f_dbl = { 1, 2.0, 3.0};\n-  struct cls_struct_combined g_dbl = {{4.0, 5.0, 6},\n-\t\t\t\t      {3, 1.0, 8.0}};\n-  struct cls_struct_16byte1 h_dbl = { 3.0, 2.0, 4};\n-  struct cls_struct_combined res_dbl;\n-\n   cls_struct_fields[0] = &ffi_type_double;\n   cls_struct_fields[1] = &ffi_type_float;\n   cls_struct_fields[2] = &ffi_type_sint;"}, {"sha": "34a74e71874ddf129571c4e236226afabb2045df", "filename": "libffi/testsuite/libffi.call/nested_struct10.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fnested_struct10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fnested_struct10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fnested_struct10.c?ref=b4b575ce7854f4a49de8de93f38b7639e01b040b", "patch": "@@ -67,6 +67,12 @@ int main (void)\n   ffi_type cls_struct_type, cls_struct_type1, cls_struct_type2;\n   ffi_type* dbl_arg_types[4];\n \n+  struct A e_dbl = { 1LL, 7};\n+  struct B f_dbl = { 99, {12LL , 127}, 255};\n+  struct C g_dbl = { 2LL, 9};\n+\n+  struct B res_dbl;\n+\n   cls_struct_type.size = 0;\n   cls_struct_type.alignment = 0;\n   cls_struct_type.type = FFI_TYPE_STRUCT;\n@@ -82,12 +88,6 @@ int main (void)\n   cls_struct_type2.type = FFI_TYPE_STRUCT;\n   cls_struct_type2.elements = cls_struct_fields2;\n \n-  struct A e_dbl = { 1LL, 7};\n-  struct B f_dbl = { 99, {12LL , 127}, 255};\n-  struct C g_dbl = { 2LL, 9};\n-\n-  struct B res_dbl;\n-\n   cls_struct_fields[0] = &ffi_type_uint64;\n   cls_struct_fields[1] = &ffi_type_uchar;\n   cls_struct_fields[2] = NULL;"}, {"sha": "fce69481888f18be23c6218936f989fedb78361b", "filename": "libffi/testsuite/libffi.call/nested_struct11.c", "status": "added", "additions": 121, "deletions": 0, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fnested_struct11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fnested_struct11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fnested_struct11.c?ref=b4b575ce7854f4a49de8de93f38b7639e01b040b", "patch": "@@ -0,0 +1,121 @@\n+/* Area:\tffi_call, closure_call\n+   Purpose:\tCheck parameter passing with nested structs\n+\t\tof a single type.  This tests the special cases\n+\t\tfor homogenous floating-point aggregates in the\n+\t\tAArch64 PCS.\n+   Limitations:\tnone.\n+   PR:\t\tnone.\n+   Originator:  ARM Ltd.  */\n+\n+/* { dg-do run } */\n+#include \"ffitest.h\"\n+\n+typedef struct A {\n+  float a_x;\n+  float a_y;\n+} A;\n+\n+typedef struct B {\n+  float b_x;\n+  float b_y;\n+} B;\n+\n+typedef struct C {\n+  A a;\n+  B b;\n+} C;\n+\n+static C C_fn (int x, int y, int z, C source, int i, int j, int k)\n+{\n+  C result;\n+  result.a.a_x = source.a.a_x;\n+  result.a.a_y = source.a.a_y;\n+  result.b.b_x = source.b.b_x;\n+  result.b.b_y = source.b.b_y;\n+\n+  printf (\"%d, %d, %d, %d, %d, %d\\n\", x, y, z, i, j, k);\n+\n+  printf (\"%.1f, %.1f, %.1f, %.1f, \"\n+\t  \"%.1f, %.1f, %.1f, %.1f\\n\",\n+\t  source.a.a_x, source.a.a_y,\n+\t  source.b.b_x, source.b.b_y,\n+\t  result.a.a_x, result.a.a_y,\n+\t  result.b.b_x, result.b.b_y);\n+\n+  return result;\n+}\n+\n+int main (void)\n+{\n+  ffi_cif cif;\n+\n+  ffi_type* struct_fields_source_a[3];\n+  ffi_type* struct_fields_source_b[3];\n+  ffi_type* struct_fields_source_c[3];\n+  ffi_type* arg_types[8];\n+\n+  ffi_type struct_type_a, struct_type_b, struct_type_c;\n+\n+  struct A source_fld_a = {1.0, 2.0};\n+  struct B source_fld_b = {4.0, 8.0};\n+  int k = 1;\n+\n+  struct C result;\n+  struct C source = {source_fld_a, source_fld_b};\n+\n+  struct_type_a.size = 0;\n+  struct_type_a.alignment = 0;\n+  struct_type_a.type = FFI_TYPE_STRUCT;\n+  struct_type_a.elements = struct_fields_source_a;\n+\n+  struct_type_b.size = 0;\n+  struct_type_b.alignment = 0;\n+  struct_type_b.type = FFI_TYPE_STRUCT;\n+  struct_type_b.elements = struct_fields_source_b;\n+\n+  struct_type_c.size = 0;\n+  struct_type_c.alignment = 0;\n+  struct_type_c.type = FFI_TYPE_STRUCT;\n+  struct_type_c.elements = struct_fields_source_c;\n+\n+  struct_fields_source_a[0] = &ffi_type_float;\n+  struct_fields_source_a[1] = &ffi_type_float;\n+  struct_fields_source_a[2] = NULL;\n+\n+  struct_fields_source_b[0] = &ffi_type_float;\n+  struct_fields_source_b[1] = &ffi_type_float;\n+  struct_fields_source_b[2] = NULL;\n+\n+  struct_fields_source_c[0] = &struct_type_a;\n+  struct_fields_source_c[1] = &struct_type_b;\n+  struct_fields_source_c[2] = NULL;\n+\n+  arg_types[0] = &ffi_type_sint32;\n+  arg_types[1] = &ffi_type_sint32;\n+  arg_types[2] = &ffi_type_sint32;\n+  arg_types[3] = &struct_type_c;\n+  arg_types[4] = &ffi_type_sint32;\n+  arg_types[5] = &ffi_type_sint32;\n+  arg_types[6] = &ffi_type_sint32;\n+  arg_types[7] = NULL;\n+\n+  void *args[7];\n+  args[0] = &k;\n+  args[1] = &k;\n+  args[2] = &k;\n+  args[3] = &source;\n+  args[4] = &k;\n+  args[5] = &k;\n+  args[6] = &k;\n+  CHECK (ffi_prep_cif (&cif, FFI_DEFAULT_ABI, 7, &struct_type_c,\n+\t\t       arg_types) == FFI_OK);\n+\n+  ffi_call (&cif, FFI_FN (C_fn), &result, args);\n+  /* { dg-output \"1, 1, 1, 1, 1, 1\\n\" } */\n+  /* { dg-output \"1.0, 2.0, 4.0, 8.0, 1.0, 2.0, 4.0, 8.0\" } */\n+  CHECK (result.a.a_x == source.a.a_x);\n+  CHECK (result.a.a_y == source.a.a_y);\n+  CHECK (result.b.b_x == source.b.b_x);\n+  CHECK (result.b.b_y == source.b.b_y);\n+  exit (0);\n+}"}, {"sha": "69268cdb8af34d690e24970564c67315f4de66d0", "filename": "libffi/testsuite/libffi.call/nested_struct2.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fnested_struct2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fnested_struct2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fnested_struct2.c?ref=b4b575ce7854f4a49de8de93f38b7639e01b040b", "patch": "@@ -57,6 +57,11 @@ int main (void)\n   ffi_type cls_struct_type, cls_struct_type1;\n   ffi_type* dbl_arg_types[3];\n \n+  struct A e_dbl = { 1, 7};\n+  struct B f_dbl = {{12 , 127}, 99};\n+\n+  struct B res_dbl;\n+\n   cls_struct_type.size = 0;\n   cls_struct_type.alignment = 0;\n   cls_struct_type.type = FFI_TYPE_STRUCT;\n@@ -67,11 +72,6 @@ int main (void)\n   cls_struct_type1.type = FFI_TYPE_STRUCT;\n   cls_struct_type1.elements = cls_struct_fields1;\n \n-  struct A e_dbl = { 1, 7};\n-  struct B f_dbl = {{12 , 127}, 99};\n-\n-  struct B res_dbl;\n-\n   cls_struct_fields[0] = &ffi_type_ulong;\n   cls_struct_fields[1] = &ffi_type_uchar;\n   cls_struct_fields[2] = NULL;"}, {"sha": "ab18cad733521046f936b8c7c672bfb0153064dd", "filename": "libffi/testsuite/libffi.call/nested_struct3.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fnested_struct3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fnested_struct3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fnested_struct3.c?ref=b4b575ce7854f4a49de8de93f38b7639e01b040b", "patch": "@@ -58,6 +58,11 @@ int main (void)\n   ffi_type cls_struct_type, cls_struct_type1;\n   ffi_type* dbl_arg_types[3];\n \n+  struct A e_dbl = { 1LL, 7};\n+  struct B f_dbl = {{12LL , 127}, 99};\n+\n+  struct B res_dbl;\n+\n   cls_struct_type.size = 0;\n   cls_struct_type.alignment = 0;\n   cls_struct_type.type = FFI_TYPE_STRUCT;\n@@ -68,11 +73,6 @@ int main (void)\n   cls_struct_type1.type = FFI_TYPE_STRUCT;\n   cls_struct_type1.elements = cls_struct_fields1;\n \n-  struct A e_dbl = { 1LL, 7};\n-  struct B f_dbl = {{12LL , 127}, 99};\n-\n-  struct B res_dbl;\n-\n   cls_struct_fields[0] = &ffi_type_uint64;\n   cls_struct_fields[1] = &ffi_type_uchar;\n   cls_struct_fields[2] = NULL;"}, {"sha": "2ffb4d65a0635cafa530d0f2f35f597f12c50142", "filename": "libffi/testsuite/libffi.call/nested_struct4.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fnested_struct4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fnested_struct4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fnested_struct4.c?ref=b4b575ce7854f4a49de8de93f38b7639e01b040b", "patch": "@@ -58,6 +58,11 @@ int main (void)\n   ffi_type cls_struct_type, cls_struct_type1;\n   ffi_type* dbl_arg_types[3];\n \n+  struct A e_dbl = { 1.0, 7};\n+  struct B f_dbl = {{12.0 , 127}, 99};\n+\n+  struct B res_dbl;\n+\n   cls_struct_type.size = 0;\n   cls_struct_type.alignment = 0;\n   cls_struct_type.type = FFI_TYPE_STRUCT;\n@@ -68,11 +73,6 @@ int main (void)\n   cls_struct_type1.type = FFI_TYPE_STRUCT;\n   cls_struct_type1.elements = cls_struct_fields1;\n \n-  struct A e_dbl = { 1.0, 7};\n-  struct B f_dbl = {{12.0 , 127}, 99};\n-\n-  struct B res_dbl;\n-\n   cls_struct_fields[0] = &ffi_type_double;\n   cls_struct_fields[1] = &ffi_type_uchar;\n   cls_struct_fields[2] = NULL;"}, {"sha": "6c79845d984a68693c4a21087ebb99b9afd52e8d", "filename": "libffi/testsuite/libffi.call/nested_struct5.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fnested_struct5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fnested_struct5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fnested_struct5.c?ref=b4b575ce7854f4a49de8de93f38b7639e01b040b", "patch": "@@ -58,6 +58,11 @@ int main (void)\n   ffi_type cls_struct_type, cls_struct_type1;\n   ffi_type* dbl_arg_types[3];\n \n+  struct A e_dbl = { 1.0, 7};\n+  struct B f_dbl = {{12.0 , 127}, 99};\n+\n+  struct B res_dbl;\n+\n   cls_struct_type.size = 0;\n   cls_struct_type.alignment = 0;\n   cls_struct_type.type = FFI_TYPE_STRUCT;\n@@ -68,11 +73,6 @@ int main (void)\n   cls_struct_type1.type = FFI_TYPE_STRUCT;\n   cls_struct_type1.elements = cls_struct_fields1;\n \n-  struct A e_dbl = { 1.0, 7};\n-  struct B f_dbl = {{12.0 , 127}, 99};\n-\n-  struct B res_dbl;\n-\n   cls_struct_fields[0] = &ffi_type_longdouble;\n   cls_struct_fields[1] = &ffi_type_uchar;\n   cls_struct_fields[2] = NULL;"}, {"sha": "59d35796f8def3db59580e42343f203d5c7de194", "filename": "libffi/testsuite/libffi.call/nested_struct6.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fnested_struct6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fnested_struct6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fnested_struct6.c?ref=b4b575ce7854f4a49de8de93f38b7639e01b040b", "patch": "@@ -66,6 +66,12 @@ int main (void)\n   ffi_type cls_struct_type, cls_struct_type1, cls_struct_type2;\n   ffi_type* dbl_arg_types[4];\n \n+  struct A e_dbl = { 1.0, 7};\n+  struct B f_dbl = {{12.0 , 127}, 99};\n+  struct C g_dbl = { 2, 9};\n+\n+  struct B res_dbl;\n+\n   cls_struct_type.size = 0;\n   cls_struct_type.alignment = 0;\n   cls_struct_type.type = FFI_TYPE_STRUCT;\n@@ -81,12 +87,6 @@ int main (void)\n   cls_struct_type2.type = FFI_TYPE_STRUCT;\n   cls_struct_type2.elements = cls_struct_fields2;\n \n-  struct A e_dbl = { 1.0, 7};\n-  struct B f_dbl = {{12.0 , 127}, 99};\n-  struct C g_dbl = { 2, 9};\n-\n-  struct B res_dbl;\n-\n   cls_struct_fields[0] = &ffi_type_double;\n   cls_struct_fields[1] = &ffi_type_uchar;\n   cls_struct_fields[2] = NULL;"}, {"sha": "27595e6f5c301c151cf192d4da680f863aefca90", "filename": "libffi/testsuite/libffi.call/nested_struct7.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fnested_struct7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fnested_struct7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fnested_struct7.c?ref=b4b575ce7854f4a49de8de93f38b7639e01b040b", "patch": "@@ -58,6 +58,11 @@ int main (void)\n   ffi_type cls_struct_type, cls_struct_type1;\n   ffi_type* dbl_arg_types[3];\n \n+  struct A e_dbl = { 1LL, 7};\n+  struct B f_dbl = {{12.0 , 127}, 99};\n+\n+  struct B res_dbl;\n+\n   cls_struct_type.size = 0;\n   cls_struct_type.alignment = 0;\n   cls_struct_type.type = FFI_TYPE_STRUCT;\n@@ -68,11 +73,6 @@ int main (void)\n   cls_struct_type1.type = FFI_TYPE_STRUCT;\n   cls_struct_type1.elements = cls_struct_fields1;\n \n-  struct A e_dbl = { 1LL, 7};\n-  struct B f_dbl = {{12.0 , 127}, 99};\n-\n-  struct B res_dbl;\n-\n   cls_struct_fields[0] = &ffi_type_uint64;\n   cls_struct_fields[1] = &ffi_type_uchar;\n   cls_struct_fields[2] = NULL;"}, {"sha": "0e6c68281e1a0ff66d8afc5e93b9466dd7e6d93e", "filename": "libffi/testsuite/libffi.call/nested_struct8.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fnested_struct8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fnested_struct8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fnested_struct8.c?ref=b4b575ce7854f4a49de8de93f38b7639e01b040b", "patch": "@@ -66,6 +66,12 @@ int main (void)\n   ffi_type cls_struct_type, cls_struct_type1, cls_struct_type2;\n   ffi_type* dbl_arg_types[4];\n \n+  struct A e_dbl = { 1LL, 7};\n+  struct B f_dbl = {{12LL , 127}, 99};\n+  struct C g_dbl = { 2LL, 9};\n+\n+  struct B res_dbl;\n+\n   cls_struct_type.size = 0;\n   cls_struct_type.alignment = 0;\n   cls_struct_type.type = FFI_TYPE_STRUCT;\n@@ -81,12 +87,6 @@ int main (void)\n   cls_struct_type2.type = FFI_TYPE_STRUCT;\n   cls_struct_type2.elements = cls_struct_fields2;\n \n-  struct A e_dbl = { 1LL, 7};\n-  struct B f_dbl = {{12LL , 127}, 99};\n-  struct C g_dbl = { 2LL, 9};\n-\n-  struct B res_dbl;\n-\n   cls_struct_fields[0] = &ffi_type_uint64;\n   cls_struct_fields[1] = &ffi_type_uchar;\n   cls_struct_fields[2] = NULL;"}, {"sha": "5f7ac67752caa154ed93eaeeff46b706795f8f95", "filename": "libffi/testsuite/libffi.call/nested_struct9.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fnested_struct9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fnested_struct9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fnested_struct9.c?ref=b4b575ce7854f4a49de8de93f38b7639e01b040b", "patch": "@@ -66,6 +66,12 @@ int main (void)\n   ffi_type cls_struct_type, cls_struct_type1, cls_struct_type2;\n   ffi_type* dbl_arg_types[4];\n \n+  struct A e_dbl = { 1, 7LL};\n+  struct B f_dbl = {{12.0 , 127}, 99};\n+  struct C g_dbl = { 2, 9};\n+\n+  struct B res_dbl;\n+\n   cls_struct_type.size = 0;\n   cls_struct_type.alignment = 0;\n   cls_struct_type.type = FFI_TYPE_STRUCT;\n@@ -81,12 +87,6 @@ int main (void)\n   cls_struct_type2.type = FFI_TYPE_STRUCT;\n   cls_struct_type2.elements = cls_struct_fields2;\n \n-  struct A e_dbl = { 1, 7LL};\n-  struct B f_dbl = {{12.0 , 127}, 99};\n-  struct C g_dbl = { 2, 9};\n-\n-  struct B res_dbl;\n-\n   cls_struct_fields[0] = &ffi_type_uchar;\n   cls_struct_fields[1] = &ffi_type_uint64;\n   cls_struct_fields[2] = NULL;"}, {"sha": "f32938c009ca06d6f680ba4f21961cb3b399c9ee", "filename": "libffi/testsuite/libffi.call/stret_large.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fstret_large.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fstret_large.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fstret_large.c?ref=b4b575ce7854f4a49de8de93f38b7639e01b040b", "patch": "@@ -82,17 +82,17 @@ int main (void)\n \tffi_type cls_struct_type;\n \tffi_type* dbl_arg_types[5];\n \n-\tcls_struct_type.size = 0;\n-\tcls_struct_type.alignment = 0;\n-\tcls_struct_type.type = FFI_TYPE_STRUCT;\n-\tcls_struct_type.elements = cls_struct_fields;\n-\n \tstruct_108byte e_dbl = { 9.0, 2.0, 6.0, 5.0, 3.0, 4.0, 8.0, 1.0, 1.0, 2.0, 3.0, 7.0, 2.0, 7 };\n \tstruct_108byte f_dbl = { 1.0, 2.0, 3.0, 7.0, 2.0, 5.0, 6.0, 7.0, 4.0, 5.0, 7.0, 9.0, 1.0, 4 };\n \tstruct_108byte g_dbl = { 4.0, 5.0, 7.0, 9.0, 1.0, 1.0, 2.0, 9.0, 8.0, 6.0, 1.0, 4.0, 0.0, 3 };\n \tstruct_108byte h_dbl = { 8.0, 6.0, 1.0, 4.0, 0.0, 3.0, 3.0, 1.0, 9.0, 2.0, 6.0, 5.0, 3.0, 2 };\n \tstruct_108byte res_dbl;\n \n+\tcls_struct_type.size = 0;\n+\tcls_struct_type.alignment = 0;\n+\tcls_struct_type.type = FFI_TYPE_STRUCT;\n+\tcls_struct_type.elements = cls_struct_fields;\n+\n \tcls_struct_fields[0] = &ffi_type_double;\n \tcls_struct_fields[1] = &ffi_type_double;\n \tcls_struct_fields[2] = &ffi_type_double;"}, {"sha": "3b0ef9ac4a009d0d651aaa05e01d9d18828ec745", "filename": "libffi/testsuite/libffi.call/stret_large2.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fstret_large2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fstret_large2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fstret_large2.c?ref=b4b575ce7854f4a49de8de93f38b7639e01b040b", "patch": "@@ -84,17 +84,17 @@ int main (void)\n \tffi_type cls_struct_type;\n \tffi_type* dbl_arg_types[5];\n \n-\tcls_struct_type.size = 0;\n-\tcls_struct_type.alignment = 0;\n-\tcls_struct_type.type = FFI_TYPE_STRUCT;\n-\tcls_struct_type.elements = cls_struct_fields;\n-\n \tstruct_116byte e_dbl = { 9.0, 2.0, 6.0, 5.0, 3.0, 4.0, 8.0, 1.0, 1.0, 2.0, 3.0, 7.0, 2.0, 5.0, 7 };\n \tstruct_116byte f_dbl = { 1.0, 2.0, 3.0, 7.0, 2.0, 5.0, 6.0, 7.0, 4.0, 5.0, 7.0, 9.0, 1.0, 6.0, 4 };\n \tstruct_116byte g_dbl = { 4.0, 5.0, 7.0, 9.0, 1.0, 1.0, 2.0, 9.0, 8.0, 6.0, 1.0, 4.0, 0.0, 7.0, 3 };\n \tstruct_116byte h_dbl = { 8.0, 6.0, 1.0, 4.0, 0.0, 3.0, 3.0, 1.0, 9.0, 2.0, 6.0, 5.0, 3.0, 8.0, 2 };\n \tstruct_116byte res_dbl;\n \n+\tcls_struct_type.size = 0;\n+\tcls_struct_type.alignment = 0;\n+\tcls_struct_type.type = FFI_TYPE_STRUCT;\n+\tcls_struct_type.elements = cls_struct_fields;\n+\n \tcls_struct_fields[0] = &ffi_type_double;\n \tcls_struct_fields[1] = &ffi_type_double;\n \tcls_struct_fields[2] = &ffi_type_double;"}, {"sha": "973ee02ede887cc20e3e76a4f4b279337e1be679", "filename": "libffi/testsuite/libffi.call/stret_medium.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fstret_medium.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fstret_medium.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fstret_medium.c?ref=b4b575ce7854f4a49de8de93f38b7639e01b040b", "patch": "@@ -68,17 +68,17 @@ int main (void)\n \tffi_type cls_struct_type;\n \tffi_type* dbl_arg_types[5];\n \n-\tcls_struct_type.size = 0;\n-\tcls_struct_type.alignment = 0;\n-\tcls_struct_type.type = FFI_TYPE_STRUCT;\n-\tcls_struct_type.elements = cls_struct_fields;\n-\n \tstruct_72byte e_dbl = { 9.0, 2.0, 6.0, 5.0, 3.0, 4.0, 8.0, 1.0, 7.0 };\n \tstruct_72byte f_dbl = { 1.0, 2.0, 3.0, 7.0, 2.0, 5.0, 6.0, 7.0, 4.0 };\n \tstruct_72byte g_dbl = { 4.0, 5.0, 7.0, 9.0, 1.0, 1.0, 2.0, 9.0, 3.0 };\n \tstruct_72byte h_dbl = { 8.0, 6.0, 1.0, 4.0, 0.0, 3.0, 3.0, 1.0, 2.0 };\n \tstruct_72byte res_dbl;\n \n+\tcls_struct_type.size = 0;\n+\tcls_struct_type.alignment = 0;\n+\tcls_struct_type.type = FFI_TYPE_STRUCT;\n+\tcls_struct_type.elements = cls_struct_fields;\n+\n \tcls_struct_fields[0] = &ffi_type_double;\n \tcls_struct_fields[1] = &ffi_type_double;\n \tcls_struct_fields[2] = &ffi_type_double;"}, {"sha": "84323d16a918c87084c443a8dbefed8afbdfc696", "filename": "libffi/testsuite/libffi.call/stret_medium2.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fstret_medium2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fstret_medium2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fstret_medium2.c?ref=b4b575ce7854f4a49de8de93f38b7639e01b040b", "patch": "@@ -69,17 +69,17 @@ int main (void)\n \tffi_type cls_struct_type;\n \tffi_type* dbl_arg_types[5];\n \n-\tcls_struct_type.size = 0;\n-\tcls_struct_type.alignment = 0;\n-\tcls_struct_type.type = FFI_TYPE_STRUCT;\n-\tcls_struct_type.elements = cls_struct_fields;\n-\n \tstruct_72byte e_dbl = { 9.0, 2.0, 6.0, 5.0, 3.0, 4.0, 8.0, 1.0, 7 };\n \tstruct_72byte f_dbl = { 1.0, 2.0, 3.0, 7.0, 2.0, 5.0, 6.0, 7.0, 4 };\n \tstruct_72byte g_dbl = { 4.0, 5.0, 7.0, 9.0, 1.0, 1.0, 2.0, 9.0, 3 };\n \tstruct_72byte h_dbl = { 8.0, 6.0, 1.0, 4.0, 0.0, 3.0, 3.0, 1.0, 2 };\n \tstruct_72byte res_dbl;\n \n+\tcls_struct_type.size = 0;\n+\tcls_struct_type.alignment = 0;\n+\tcls_struct_type.type = FFI_TYPE_STRUCT;\n+\tcls_struct_type.elements = cls_struct_fields;\n+\n \tcls_struct_fields[0] = &ffi_type_double;\n \tcls_struct_fields[1] = &ffi_type_double;\n \tcls_struct_fields[2] = &ffi_type_double;"}, {"sha": "0d81061e75852ceb11c2c88eaf45f254b9a8c35a", "filename": "libffi/testsuite/libffi.call/strlen2_win32.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fstrlen2_win32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fstrlen2_win32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fstrlen2_win32.c?ref=b4b575ce7854f4a49de8de93f38b7639e01b040b", "patch": "@@ -8,12 +8,11 @@\n \n #include \"ffitest.h\"\n \n-static size_t __attribute__((fastcall)) my_fastcall_strlen(char *s)\n+static size_t __FASTCALL__ my_fastcall_strlen(char *s)\n {\n   return (strlen(s));\n }\n \n-int d\n int main (void)\n {\n   ffi_cif cif;"}, {"sha": "bfc23f642cc870ab19a48bc1d7fdc46109833df4", "filename": "libffi/testsuite/libffi.call/struct1.c", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fstruct1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fstruct1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fstruct1.c?ref=b4b575ce7854f4a49de8de93f38b7639e01b040b", "patch": "@@ -30,6 +30,13 @@ int main (void)\n   void *values[MAX_ARGS];\n   ffi_type ts1_type;\n   ffi_type *ts1_type_elements[4];\n+\n+  test_structure_1 ts1_arg;\n+\n+  /* This is a hack to get a properly aligned result buffer */\n+  test_structure_1 *ts1_result =\n+    (test_structure_1 *) malloc (sizeof(test_structure_1));\n+\n   ts1_type.size = 0;\n   ts1_type.alignment = 0;\n   ts1_type.type = FFI_TYPE_STRUCT;\n@@ -39,11 +46,6 @@ int main (void)\n   ts1_type_elements[2] = &ffi_type_uint;\n   ts1_type_elements[3] = NULL;\n   \n-  test_structure_1 ts1_arg;\n-  /* This is a hack to get a properly aligned result buffer */\n-  test_structure_1 *ts1_result = \n-    (test_structure_1 *) malloc (sizeof(test_structure_1));\n-  \n   args[0] = &ts1_type;\n   values[0] = &ts1_arg;\n   "}, {"sha": "b756f5ad8b52f8d2e0e9596fc12a7b494926c323", "filename": "libffi/testsuite/libffi.call/struct1_win32.c", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fstruct1_win32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fstruct1_win32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fstruct1_win32.c?ref=b4b575ce7854f4a49de8de93f38b7639e01b040b", "patch": "@@ -14,7 +14,7 @@ typedef struct\n   unsigned int ui;\n } test_structure_1;\n \n-static __attribute__ ((fastcall)) test_structure_1 struct1(test_structure_1 ts)\n+static test_structure_1 __FASTCALL__ struct1(test_structure_1 ts)\n {\n   ts.uc++;\n   ts.d--;\n@@ -30,6 +30,13 @@ int main (void)\n   void *values[MAX_ARGS];\n   ffi_type ts1_type;\n   ffi_type *ts1_type_elements[4];\n+\n+  test_structure_1 ts1_arg;\n+\n+  /* This is a hack to get a properly aligned result buffer */\n+  test_structure_1 *ts1_result =\n+    (test_structure_1 *) malloc (sizeof(test_structure_1));\n+\n   ts1_type.size = 0;\n   ts1_type.alignment = 0;\n   ts1_type.type = FFI_TYPE_STRUCT;\n@@ -39,11 +46,6 @@ int main (void)\n   ts1_type_elements[2] = &ffi_type_uint;\n   ts1_type_elements[3] = NULL;\n   \n-  test_structure_1 ts1_arg;\n-  /* This is a hack to get a properly aligned result buffer */\n-  test_structure_1 *ts1_result = \n-    (test_structure_1 *) malloc (sizeof(test_structure_1));\n-  \n   args[0] = &ts1_type;\n   values[0] = &ts1_arg;\n   "}, {"sha": "d85385e7d3f235c09dd2d6809c25bc22e0be4531", "filename": "libffi/testsuite/libffi.call/struct2.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fstruct2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fstruct2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fstruct2.c?ref=b4b575ce7854f4a49de8de93f38b7639e01b040b", "patch": "@@ -29,6 +29,11 @@ int main (void)\n   test_structure_2 ts2_arg;\n   ffi_type ts2_type;\n   ffi_type *ts2_type_elements[3];\n+\n+  /* This is a hack to get a properly aligned result buffer */\n+  test_structure_2 *ts2_result =\n+    (test_structure_2 *) malloc (sizeof(test_structure_2));\n+\n   ts2_type.size = 0;\n   ts2_type.alignment = 0;\n   ts2_type.type = FFI_TYPE_STRUCT;\n@@ -37,11 +42,6 @@ int main (void)\n   ts2_type_elements[1] = &ffi_type_double;\n   ts2_type_elements[2] = NULL;\n \n-  \n-  /* This is a hack to get a properly aligned result buffer */\n-  test_structure_2 *ts2_result = \n-    (test_structure_2 *) malloc (sizeof(test_structure_2));\n-  \n   args[0] = &ts2_type;\n   values[0] = &ts2_arg;\n   "}, {"sha": "5d022855c574ac62916de93b4a733b4e7094dd87", "filename": "libffi/testsuite/libffi.call/struct2_win32.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fstruct2_win32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fstruct2_win32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fstruct2_win32.c?ref=b4b575ce7854f4a49de8de93f38b7639e01b040b", "patch": "@@ -13,7 +13,7 @@ typedef struct\n   double d2;\n } test_structure_2;\n \n-static test_structure_2 __attribute__ ((fastcall)) struct2(test_structure_2 ts)\n+static test_structure_2 __FASTCALL__ struct2(test_structure_2 ts)\n {\n   ts.d1--;\n   ts.d2--;\n@@ -29,6 +29,11 @@ int main (void)\n   test_structure_2 ts2_arg;\n   ffi_type ts2_type;\n   ffi_type *ts2_type_elements[3];\n+\n+  /* This is a hack to get a properly aligned result buffer */\n+  test_structure_2 *ts2_result =\n+    (test_structure_2 *) malloc (sizeof(test_structure_2));\n+\n   ts2_type.size = 0;\n   ts2_type.alignment = 0;\n   ts2_type.type = FFI_TYPE_STRUCT;\n@@ -37,11 +42,6 @@ int main (void)\n   ts2_type_elements[1] = &ffi_type_double;\n   ts2_type_elements[2] = NULL;\n \n-  \n-  /* This is a hack to get a properly aligned result buffer */\n-  test_structure_2 *ts2_result = \n-    (test_structure_2 *) malloc (sizeof(test_structure_2));\n-  \n   args[0] = &ts2_type;\n   values[0] = &ts2_arg;\n   "}, {"sha": "de883c2638e0b952c24f59c18589773ef74f1aee", "filename": "libffi/testsuite/libffi.call/struct3.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fstruct3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fstruct3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fstruct3.c?ref=b4b575ce7854f4a49de8de93f38b7639e01b040b", "patch": "@@ -27,17 +27,18 @@ int main (void)\n   int compare_value;\n   ffi_type ts3_type;\n   ffi_type *ts3_type_elements[2];\n+\n+  test_structure_3 ts3_arg;\n+  test_structure_3 *ts3_result =\n+    (test_structure_3 *) malloc (sizeof(test_structure_3));\n+\n   ts3_type.size = 0;\n   ts3_type.alignment = 0;\n   ts3_type.type = FFI_TYPE_STRUCT;\n   ts3_type.elements = ts3_type_elements;\n   ts3_type_elements[0] = &ffi_type_sint;\n   ts3_type_elements[1] = NULL;\n \n-  test_structure_3 ts3_arg;\n-  test_structure_3 *ts3_result = \n-    (test_structure_3 *) malloc (sizeof(test_structure_3));\n-  \n   args[0] = &ts3_type;\n   values[0] = &ts3_arg;\n   "}, {"sha": "48e03495441c0dcb6d0aae7b1c45f7028a5a4ce0", "filename": "libffi/testsuite/libffi.call/struct4.c", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fstruct4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fstruct4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fstruct4.c?ref=b4b575ce7854f4a49de8de93f38b7639e01b040b", "patch": "@@ -28,21 +28,22 @@ int main (void)\n   void *values[MAX_ARGS];\n   ffi_type ts4_type;\n   ffi_type *ts4_type_elements[4];  \n+\n+  test_structure_4 ts4_arg;\n+\n+  /* This is a hack to get a properly aligned result buffer */\n+  test_structure_4 *ts4_result =\n+    (test_structure_4 *) malloc (sizeof(test_structure_4));\n+\n   ts4_type.size = 0;\n   ts4_type.alignment = 0;\n   ts4_type.type = FFI_TYPE_STRUCT;\n-  test_structure_4 ts4_arg;\n   ts4_type.elements = ts4_type_elements;\n   ts4_type_elements[0] = &ffi_type_uint;\n   ts4_type_elements[1] = &ffi_type_uint;\n   ts4_type_elements[2] = &ffi_type_uint;\n   ts4_type_elements[3] = NULL;\n \n-  \n-  /* This is a hack to get a properly aligned result buffer */\n-  test_structure_4 *ts4_result = \n-    (test_structure_4 *) malloc (sizeof(test_structure_4));\n-  \n   args[0] = &ts4_type;\n   values[0] = &ts4_arg;\n   "}, {"sha": "28b1f0c4265e42b25a8806ad1f23a02b5df0e5d7", "filename": "libffi/testsuite/libffi.call/struct5.c", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fstruct5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fstruct5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fstruct5.c?ref=b4b575ce7854f4a49de8de93f38b7639e01b040b", "patch": "@@ -27,6 +27,13 @@ int main (void)\n   void *values[MAX_ARGS];\n   ffi_type ts5_type;\n   ffi_type *ts5_type_elements[3];\n+\n+  test_structure_5 ts5_arg1, ts5_arg2;\n+\n+  /* This is a hack to get a properly aligned result buffer */\n+  test_structure_5 *ts5_result =\n+    (test_structure_5 *) malloc (sizeof(test_structure_5));\n+\n   ts5_type.size = 0;\n   ts5_type.alignment = 0;\n   ts5_type.type = FFI_TYPE_STRUCT;\n@@ -35,12 +42,6 @@ int main (void)\n   ts5_type_elements[1] = &ffi_type_schar;\n   ts5_type_elements[2] = NULL;\n \n-  test_structure_5 ts5_arg1, ts5_arg2;\n-  \n-  /* This is a hack to get a properly aligned result buffer */\n-  test_structure_5 *ts5_result = \n-    (test_structure_5 *) malloc (sizeof(test_structure_5));\n-  \n   args[0] = &ts5_type;\n   args[1] = &ts5_type;\n   values[0] = &ts5_arg1;"}, {"sha": "0e267467a7b08dc44c7f4ef8072c7f7272a430e3", "filename": "libffi/testsuite/libffi.call/struct6.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fstruct6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fstruct6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fstruct6.c?ref=b4b575ce7854f4a49de8de93f38b7639e01b040b", "patch": "@@ -27,6 +27,13 @@ int main (void)\n   void *values[MAX_ARGS];\n   ffi_type ts6_type;\n   ffi_type *ts6_type_elements[3];\n+\n+  test_structure_6 ts6_arg;\n+\n+  /* This is a hack to get a properly aligned result buffer */\n+  test_structure_6 *ts6_result =\n+    (test_structure_6 *) malloc (sizeof(test_structure_6));\n+\n   ts6_type.size = 0;\n   ts6_type.alignment = 0;\n   ts6_type.type = FFI_TYPE_STRUCT;\n@@ -35,13 +42,6 @@ int main (void)\n   ts6_type_elements[1] = &ffi_type_double;\n   ts6_type_elements[2] = NULL;\n \n-\n-  test_structure_6 ts6_arg;\n-\n-  /* This is a hack to get a properly aligned result buffer */\n-  test_structure_6 *ts6_result = \n-    (test_structure_6 *) malloc (sizeof(test_structure_6));\n-  \n   args[0] = &ts6_type;\n   values[0] = &ts6_arg;\n "}, {"sha": "8f2bbfd949c52240a8f8f2b8fbc9665c222f7cf4", "filename": "libffi/testsuite/libffi.call/struct7.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fstruct7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fstruct7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fstruct7.c?ref=b4b575ce7854f4a49de8de93f38b7639e01b040b", "patch": "@@ -29,6 +29,13 @@ int main (void)\n   void *values[MAX_ARGS];\n   ffi_type ts7_type;\n   ffi_type *ts7_type_elements[4];\n+\n+  test_structure_7 ts7_arg;\n+\n+  /* This is a hack to get a properly aligned result buffer */\n+  test_structure_7 *ts7_result =\n+    (test_structure_7 *) malloc (sizeof(test_structure_7));\n+\n   ts7_type.size = 0;\n   ts7_type.alignment = 0;\n   ts7_type.type = FFI_TYPE_STRUCT;\n@@ -38,13 +45,6 @@ int main (void)\n   ts7_type_elements[2] = &ffi_type_double;\n   ts7_type_elements[3] = NULL;\n \n-\n-  test_structure_7 ts7_arg;\n-  \n-  /* This is a hack to get a properly aligned result buffer */\n-  test_structure_7 *ts7_result = \n-    (test_structure_7 *) malloc (sizeof(test_structure_7));\n-  \n   args[0] = &ts7_type;\n   values[0] = &ts7_arg;\n   "}, {"sha": "266e1f0ad606e7b85fb589bd74f2057816acb2dd", "filename": "libffi/testsuite/libffi.call/struct8.c", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fstruct8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fstruct8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fstruct8.c?ref=b4b575ce7854f4a49de8de93f38b7639e01b040b", "patch": "@@ -31,6 +31,13 @@ int main (void)\n   void *values[MAX_ARGS];\n   ffi_type ts8_type;\n   ffi_type *ts8_type_elements[5];\n+\n+  test_structure_8 ts8_arg;\n+\n+  /* This is a hack to get a properly aligned result buffer */\n+  test_structure_8 *ts8_result =\n+    (test_structure_8 *) malloc (sizeof(test_structure_8));\n+\n   ts8_type.size = 0;\n   ts8_type.alignment = 0;\n   ts8_type.type = FFI_TYPE_STRUCT;\n@@ -41,12 +48,6 @@ int main (void)\n   ts8_type_elements[3] = &ffi_type_float;\n   ts8_type_elements[4] = NULL;\n \n-  test_structure_8 ts8_arg;\n-  \n-  /* This is a hack to get a properly aligned result buffer */\n-  test_structure_8 *ts8_result = \n-    (test_structure_8 *) malloc (sizeof(test_structure_8));\n-  \n   args[0] = &ts8_type;\n   values[0] = &ts8_arg;\n   "}, {"sha": "efeb7161b845f29e0da17c482c891e5377708871", "filename": "libffi/testsuite/libffi.call/struct9.c", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fstruct9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fstruct9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fstruct9.c?ref=b4b575ce7854f4a49de8de93f38b7639e01b040b", "patch": "@@ -28,6 +28,13 @@ int main (void)\n   void *values[MAX_ARGS];\n   ffi_type ts9_type;\n   ffi_type *ts9_type_elements[3];\n+\n+  test_structure_9 ts9_arg;\n+\n+  /* This is a hack to get a properly aligned result buffer */\n+  test_structure_9 *ts9_result =\n+    (test_structure_9 *) malloc (sizeof(test_structure_9));\n+\n   ts9_type.size = 0;\n   ts9_type.alignment = 0;\n   ts9_type.type = FFI_TYPE_STRUCT;\n@@ -36,12 +43,6 @@ int main (void)\n   ts9_type_elements[1] = &ffi_type_sint;\n   ts9_type_elements[2] = NULL;\n \n-  test_structure_9 ts9_arg;\n-  \n-  /* This is a hack to get a properly aligned result buffer */\n-  test_structure_9 *ts9_result = \n-    (test_structure_9 *) malloc (sizeof(test_structure_9));\n-  \n   args[0] = &ts9_type;\n   values[0] = &ts9_arg;\n   "}, {"sha": "ca31056d8c834059a936ab625cd96f967bfc6235", "filename": "libffi/testsuite/libffi.call/testclosure.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Ftestclosure.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Ftestclosure.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Ftestclosure.c?ref=b4b575ce7854f4a49de8de93f38b7639e01b040b", "patch": "@@ -43,13 +43,13 @@ int main (void)\n   ffi_type cls_struct_type0;\n   ffi_type* dbl_arg_types[5];\n \n+  struct cls_struct_combined g_dbl = {4.0, 5.0, 1.0, 8.0};\n+\n   cls_struct_type0.size = 0;\n   cls_struct_type0.alignment = 0;\n   cls_struct_type0.type = FFI_TYPE_STRUCT;\n   cls_struct_type0.elements = cls_struct_fields0;\n \n-  struct cls_struct_combined g_dbl = {4.0, 5.0, 1.0, 8.0};\n-\n   cls_struct_fields0[0] = &ffi_type_float;\n   cls_struct_fields0[1] = &ffi_type_float;\n   cls_struct_fields0[2] = &ffi_type_float;"}, {"sha": "f00d8302349dfc1e2de3b2f01a33b18763ee884d", "filename": "libffi/testsuite/libffi.call/uninitialized.c", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Funinitialized.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Funinitialized.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Funinitialized.c?ref=b4b575ce7854f4a49de8de93f38b7639e01b040b", "patch": "@@ -0,0 +1,61 @@\n+/* { dg-do run } */\n+#include \"ffitest.h\"\n+\n+typedef struct\n+{\n+  unsigned char uc;\n+  double d;\n+  unsigned int ui;\n+} test_structure_1;\n+\n+static test_structure_1 struct1(test_structure_1 ts)\n+{\n+  ts.uc++;\n+  ts.d--;\n+  ts.ui++;\n+\n+  return ts;\n+}\n+\n+int main (void)\n+{\n+  ffi_cif cif;\n+  ffi_type *args[MAX_ARGS];\n+  void *values[MAX_ARGS];\n+  ffi_type ts1_type;\n+  ffi_type *ts1_type_elements[4];\n+\n+  memset(&cif, 1, sizeof(cif));\n+  ts1_type.size = 0;\n+  ts1_type.alignment = 0;\n+  ts1_type.type = FFI_TYPE_STRUCT;\n+  ts1_type.elements = ts1_type_elements;\n+  ts1_type_elements[0] = &ffi_type_uchar;\n+  ts1_type_elements[1] = &ffi_type_double;\n+  ts1_type_elements[2] = &ffi_type_uint;\n+  ts1_type_elements[3] = NULL;\n+\n+  test_structure_1 ts1_arg;\n+  /* This is a hack to get a properly aligned result buffer */\n+  test_structure_1 *ts1_result =\n+    (test_structure_1 *) malloc (sizeof(test_structure_1));\n+\n+  args[0] = &ts1_type;\n+  values[0] = &ts1_arg;\n+\n+  /* Initialize the cif */\n+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1,\n+\t\t     &ts1_type, args) == FFI_OK);\n+\n+  ts1_arg.uc = '\\x01';\n+  ts1_arg.d = 3.14159;\n+  ts1_arg.ui = 555;\n+\n+  ffi_call(&cif, FFI_FN(struct1), ts1_result, values);\n+\n+  CHECK(ts1_result->ui == 556);\n+  CHECK(ts1_result->d == 3.14159 - 1);\n+\n+  free (ts1_result);\n+  exit(0);\n+}"}, {"sha": "5c7cce9f7f149ba0f2ba56ac43d7e17b828c19c9", "filename": "libffi/testsuite/libffi.call/va_1.c", "status": "added", "additions": 196, "deletions": 0, "changes": 196, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fva_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fva_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fva_1.c?ref=b4b575ce7854f4a49de8de93f38b7639e01b040b", "patch": "@@ -0,0 +1,196 @@\n+/* Area:\t\tffi_call\n+   Purpose:\t\tTest passing struct in variable argument lists.\n+   Limitations:\tnone.\n+   PR:\t\t\tnone.\n+   Originator:\t        ARM Ltd. */\n+\n+/* { dg-do run } */\n+/* { dg-output \"\" { xfail avr32*-*-* x86_64-*-*-* } } */\n+\n+#include \"ffitest.h\"\n+#include <stdarg.h>\n+\n+struct small_tag\n+{\n+  unsigned char a;\n+  unsigned char b;\n+};\n+\n+struct large_tag\n+{\n+  unsigned a;\n+  unsigned b;\n+  unsigned c;\n+  unsigned d;\n+  unsigned e;\n+};\n+\n+static int\n+test_fn (int n, ...)\n+{\n+  va_list ap;\n+  struct small_tag s1;\n+  struct small_tag s2;\n+  struct large_tag l;\n+  unsigned char uc;\n+  signed char sc;\n+  unsigned short us;\n+  signed short ss;\n+  unsigned int ui;\n+  signed int si;\n+  unsigned long ul;\n+  signed long sl;\n+  float f;\n+  double d;\n+\n+  va_start (ap, n);\n+  s1 = va_arg (ap, struct small_tag);\n+  l = va_arg (ap, struct large_tag);\n+  s2 = va_arg (ap, struct small_tag);\n+\n+  uc = va_arg (ap, unsigned);\n+  sc = va_arg (ap, signed);\n+\n+  us = va_arg (ap, unsigned);\n+  ss = va_arg (ap, signed);\n+\n+  ui = va_arg (ap, unsigned int);\n+  si = va_arg (ap, signed int);\n+\n+  ul = va_arg (ap, unsigned long);\n+  sl = va_arg (ap, signed long);\n+\n+  f = va_arg (ap, double);\t/* C standard promotes float->double\n+\t\t\t\t   when anonymous */\n+  d = va_arg (ap, double);\n+\n+  printf (\"%u %u %u %u %u %u %u %u %u uc=%u sc=%d %u %d %u %d %lu %ld %f %f\\n\",\n+\t  s1.a, s1.b, l.a, l.b, l.c, l.d, l.e,\n+\t  s2.a, s2.b,\n+\t  uc, sc,\n+\t  us, ss,\n+\t  ui, si,\n+\t  ul, sl,\n+\t  f, d);\n+  va_end (ap);\n+  return n + 1;\n+}\n+\n+int\n+main (void)\n+{\n+  ffi_cif cif;\n+  void* args[15];\n+  ffi_type* arg_types[15];\n+\n+  ffi_type s_type;\n+  ffi_type *s_type_elements[3];\n+\n+  ffi_type l_type;\n+  ffi_type *l_type_elements[6];\n+\n+  struct small_tag s1;\n+  struct small_tag s2;\n+  struct large_tag l1;\n+\n+  int n;\n+  int res;\n+\n+  unsigned char uc;\n+  signed char sc;\n+  unsigned short us;\n+  signed short ss;\n+  unsigned int ui;\n+  signed int si;\n+  unsigned long ul;\n+  signed long sl;\n+  double d1;\n+  double f1;\n+\n+  s_type.size = 0;\n+  s_type.alignment = 0;\n+  s_type.type = FFI_TYPE_STRUCT;\n+  s_type.elements = s_type_elements;\n+\n+  s_type_elements[0] = &ffi_type_uchar;\n+  s_type_elements[1] = &ffi_type_uchar;\n+  s_type_elements[2] = NULL;\n+\n+  l_type.size = 0;\n+  l_type.alignment = 0;\n+  l_type.type = FFI_TYPE_STRUCT;\n+  l_type.elements = l_type_elements;\n+\n+  l_type_elements[0] = &ffi_type_uint;\n+  l_type_elements[1] = &ffi_type_uint;\n+  l_type_elements[2] = &ffi_type_uint;\n+  l_type_elements[3] = &ffi_type_uint;\n+  l_type_elements[4] = &ffi_type_uint;\n+  l_type_elements[5] = NULL;\n+\n+  arg_types[0] = &ffi_type_sint;\n+  arg_types[1] = &s_type;\n+  arg_types[2] = &l_type;\n+  arg_types[3] = &s_type;\n+  arg_types[4] = &ffi_type_uint;\n+  arg_types[5] = &ffi_type_sint;\n+  arg_types[6] = &ffi_type_uint;\n+  arg_types[7] = &ffi_type_sint;\n+  arg_types[8] = &ffi_type_uint;\n+  arg_types[9] = &ffi_type_sint;\n+  arg_types[10] = &ffi_type_ulong;\n+  arg_types[11] = &ffi_type_slong;\n+  arg_types[12] = &ffi_type_double;\n+  arg_types[13] = &ffi_type_double;\n+  arg_types[14] = NULL;\n+\n+  CHECK(ffi_prep_cif_var(&cif, FFI_DEFAULT_ABI, 1, 14, &ffi_type_sint, arg_types) == FFI_OK);\n+\n+  s1.a = 5;\n+  s1.b = 6;\n+\n+  l1.a = 10;\n+  l1.b = 11;\n+  l1.c = 12;\n+  l1.d = 13;\n+  l1.e = 14;\n+\n+  s2.a = 7;\n+  s2.b = 8;\n+\n+  n = 41;\n+\n+  uc = 9;\n+  sc = 10;\n+  us = 11;\n+  ss = 12;\n+  ui = 13;\n+  si = 14;\n+  ul = 15;\n+  sl = 16;\n+  f1 = 2.12;\n+  d1 = 3.13;\n+\n+  args[0] = &n;\n+  args[1] = &s1;\n+  args[2] = &l1;\n+  args[3] = &s2;\n+  args[4] = &uc;\n+  args[5] = &sc;\n+  args[6] = &us;\n+  args[7] = &ss;\n+  args[8] = &ui;\n+  args[9] = &si;\n+  args[10] = &ul;\n+  args[11] = &sl;\n+  args[12] = &f1;\n+  args[13] = &d1;\n+  args[14] = NULL;\n+\n+  ffi_call(&cif, FFI_FN(test_fn), &res, args);\n+  /* { dg-output \"5 6 10 11 12 13 14 7 8 uc=9 sc=10 11 12 13 14 15 16 2.120000 3.130000\" } */\n+  printf(\"res: %d\\n\", (int) res);\n+  /* { dg-output \"\\nres: 42\" } */\n+\n+  return 0;\n+}"}, {"sha": "11d1f10e5c69e695ee6a1acd2dfc17dbfa2298fe", "filename": "libffi/testsuite/libffi.call/va_struct1.c", "status": "added", "additions": 121, "deletions": 0, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fva_struct1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fva_struct1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fva_struct1.c?ref=b4b575ce7854f4a49de8de93f38b7639e01b040b", "patch": "@@ -0,0 +1,121 @@\n+/* Area:\t\tffi_call\n+   Purpose:\t\tTest passing struct in variable argument lists.\n+   Limitations:\tnone.\n+   PR:\t\t\tnone.\n+   Originator: ARM Ltd. */\n+\n+/* { dg-do run } */\n+/* { dg-output \"\" { xfail avr32*-*-* } } */\n+\n+#include \"ffitest.h\"\n+#include <stdarg.h>\n+\n+struct small_tag\n+{\n+  unsigned char a;\n+  unsigned char b;\n+};\n+\n+struct large_tag\n+{\n+  unsigned a;\n+  unsigned b;\n+  unsigned c;\n+  unsigned d;\n+  unsigned e;\n+};\n+\n+static int\n+test_fn (int n, ...)\n+{\n+  va_list ap;\n+  struct small_tag s1;\n+  struct small_tag s2;\n+  struct large_tag l;\n+\n+  va_start (ap, n);\n+  s1 = va_arg (ap, struct small_tag);\n+  l = va_arg (ap, struct large_tag);\n+  s2 = va_arg (ap, struct small_tag);\n+  printf (\"%u %u %u %u %u %u %u %u %u\\n\", s1.a, s1.b, l.a, l.b, l.c, l.d, l.e,\n+\t  s2.a, s2.b);\n+  va_end (ap);\n+  return n + 1;\n+}\n+\n+int\n+main (void)\n+{\n+  ffi_cif cif;\n+  void* args[5];\n+  ffi_type* arg_types[5];\n+\n+  ffi_type s_type;\n+  ffi_type *s_type_elements[3];\n+\n+  ffi_type l_type;\n+  ffi_type *l_type_elements[6];\n+\n+  struct small_tag s1;\n+  struct small_tag s2;\n+  struct large_tag l1;\n+\n+  int n;\n+  int res;\n+\n+  s_type.size = 0;\n+  s_type.alignment = 0;\n+  s_type.type = FFI_TYPE_STRUCT;\n+  s_type.elements = s_type_elements;\n+\n+  s_type_elements[0] = &ffi_type_uchar;\n+  s_type_elements[1] = &ffi_type_uchar;\n+  s_type_elements[2] = NULL;\n+\n+  l_type.size = 0;\n+  l_type.alignment = 0;\n+  l_type.type = FFI_TYPE_STRUCT;\n+  l_type.elements = l_type_elements;\n+\n+  l_type_elements[0] = &ffi_type_uint;\n+  l_type_elements[1] = &ffi_type_uint;\n+  l_type_elements[2] = &ffi_type_uint;\n+  l_type_elements[3] = &ffi_type_uint;\n+  l_type_elements[4] = &ffi_type_uint;\n+  l_type_elements[5] = NULL;\n+\n+  arg_types[0] = &ffi_type_sint;\n+  arg_types[1] = &s_type;\n+  arg_types[2] = &l_type;\n+  arg_types[3] = &s_type;\n+  arg_types[4] = NULL;\n+\n+  CHECK(ffi_prep_cif_var(&cif, FFI_DEFAULT_ABI, 1, 4, &ffi_type_sint, arg_types) == FFI_OK);\n+\n+  s1.a = 5;\n+  s1.b = 6;\n+\n+  l1.a = 10;\n+  l1.b = 11;\n+  l1.c = 12;\n+  l1.d = 13;\n+  l1.e = 14;\n+\n+  s2.a = 7;\n+  s2.b = 8;\n+\n+  n = 41;\n+\n+  args[0] = &n;\n+  args[1] = &s1;\n+  args[2] = &l1;\n+  args[3] = &s2;\n+  args[4] = NULL;\n+\n+  ffi_call(&cif, FFI_FN(test_fn), &res, args);\n+  /* { dg-output \"5 6 10 11 12 13 14 7 8\" } */\n+  printf(\"res: %d\\n\", (int) res);\n+  /* { dg-output \"\\nres: 42\" } */\n+\n+  return 0;\n+}"}, {"sha": "56f5b9c75fa387c953420c7caa36feca089d65a6", "filename": "libffi/testsuite/libffi.call/va_struct2.c", "status": "added", "additions": 123, "deletions": 0, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fva_struct2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fva_struct2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fva_struct2.c?ref=b4b575ce7854f4a49de8de93f38b7639e01b040b", "patch": "@@ -0,0 +1,123 @@\n+/* Area:\t\tffi_call\n+   Purpose:\t\tTest passing struct in variable argument lists.\n+   Limitations:\tnone.\n+   PR:\t\t\tnone.\n+   Originator: ARM Ltd. */\n+\n+/* { dg-do run } */\n+/* { dg-output \"\" { xfail avr32*-*-* } } */\n+\n+#include \"ffitest.h\"\n+#include <stdarg.h>\n+\n+struct small_tag\n+{\n+  unsigned char a;\n+  unsigned char b;\n+};\n+\n+struct large_tag\n+{\n+  unsigned a;\n+  unsigned b;\n+  unsigned c;\n+  unsigned d;\n+  unsigned e;\n+};\n+\n+static struct small_tag\n+test_fn (int n, ...)\n+{\n+  va_list ap;\n+  struct small_tag s1;\n+  struct small_tag s2;\n+  struct large_tag l;\n+\n+  va_start (ap, n);\n+  s1 = va_arg (ap, struct small_tag);\n+  l = va_arg (ap, struct large_tag);\n+  s2 = va_arg (ap, struct small_tag);\n+  printf (\"%u %u %u %u %u %u %u %u %u\\n\", s1.a, s1.b, l.a, l.b, l.c, l.d, l.e,\n+\t  s2.a, s2.b);\n+  va_end (ap);\n+  s1.a += s2.a;\n+  s1.b += s2.b;\n+  return s1;\n+}\n+\n+int\n+main (void)\n+{\n+  ffi_cif cif;\n+  void* args[5];\n+  ffi_type* arg_types[5];\n+\n+  ffi_type s_type;\n+  ffi_type *s_type_elements[3];\n+\n+  ffi_type l_type;\n+  ffi_type *l_type_elements[6];\n+\n+  struct small_tag s1;\n+  struct small_tag s2;\n+  struct large_tag l1;\n+\n+  int n;\n+  struct small_tag res;\n+\n+  s_type.size = 0;\n+  s_type.alignment = 0;\n+  s_type.type = FFI_TYPE_STRUCT;\n+  s_type.elements = s_type_elements;\n+\n+  s_type_elements[0] = &ffi_type_uchar;\n+  s_type_elements[1] = &ffi_type_uchar;\n+  s_type_elements[2] = NULL;\n+\n+  l_type.size = 0;\n+  l_type.alignment = 0;\n+  l_type.type = FFI_TYPE_STRUCT;\n+  l_type.elements = l_type_elements;\n+\n+  l_type_elements[0] = &ffi_type_uint;\n+  l_type_elements[1] = &ffi_type_uint;\n+  l_type_elements[2] = &ffi_type_uint;\n+  l_type_elements[3] = &ffi_type_uint;\n+  l_type_elements[4] = &ffi_type_uint;\n+  l_type_elements[5] = NULL;\n+\n+  arg_types[0] = &ffi_type_sint;\n+  arg_types[1] = &s_type;\n+  arg_types[2] = &l_type;\n+  arg_types[3] = &s_type;\n+  arg_types[4] = NULL;\n+\n+  CHECK(ffi_prep_cif_var(&cif, FFI_DEFAULT_ABI, 1, 4, &s_type, arg_types) == FFI_OK);\n+\n+  s1.a = 5;\n+  s1.b = 6;\n+\n+  l1.a = 10;\n+  l1.b = 11;\n+  l1.c = 12;\n+  l1.d = 13;\n+  l1.e = 14;\n+\n+  s2.a = 7;\n+  s2.b = 8;\n+\n+  n = 41;\n+\n+  args[0] = &n;\n+  args[1] = &s1;\n+  args[2] = &l1;\n+  args[3] = &s2;\n+  args[4] = NULL;\n+\n+  ffi_call(&cif, FFI_FN(test_fn), &res, args);\n+  /* { dg-output \"5 6 10 11 12 13 14 7 8\" } */\n+  printf(\"res: %d %d\\n\", res.a, res.b);\n+  /* { dg-output \"\\nres: 12 14\" } */\n+\n+  return 0;\n+}"}, {"sha": "9a27e7fd4a34e32a856c0ab984999b78b70044f7", "filename": "libffi/testsuite/libffi.call/va_struct3.c", "status": "added", "additions": 125, "deletions": 0, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fva_struct3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4b575ce7854f4a49de8de93f38b7639e01b040b/libffi%2Ftestsuite%2Flibffi.call%2Fva_struct3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fva_struct3.c?ref=b4b575ce7854f4a49de8de93f38b7639e01b040b", "patch": "@@ -0,0 +1,125 @@\n+/* Area:\t\tffi_call\n+   Purpose:\t\tTest passing struct in variable argument lists.\n+   Limitations:\tnone.\n+   PR:\t\t\tnone.\n+   Originator:\tARM Ltd. */\n+\n+/* { dg-do run } */\n+/* { dg-output \"\" { xfail avr32*-*-* } } */\n+\n+#include \"ffitest.h\"\n+#include <stdarg.h>\n+\n+struct small_tag\n+{\n+  unsigned char a;\n+  unsigned char b;\n+};\n+\n+struct large_tag\n+{\n+  unsigned a;\n+  unsigned b;\n+  unsigned c;\n+  unsigned d;\n+  unsigned e;\n+};\n+\n+static struct large_tag\n+test_fn (int n, ...)\n+{\n+  va_list ap;\n+  struct small_tag s1;\n+  struct small_tag s2;\n+  struct large_tag l;\n+\n+  va_start (ap, n);\n+  s1 = va_arg (ap, struct small_tag);\n+  l = va_arg (ap, struct large_tag);\n+  s2 = va_arg (ap, struct small_tag);\n+  printf (\"%u %u %u %u %u %u %u %u %u\\n\", s1.a, s1.b, l.a, l.b, l.c, l.d, l.e,\n+\t  s2.a, s2.b);\n+  va_end (ap);\n+  l.a += s1.a;\n+  l.b += s1.b;\n+  l.c += s2.a;\n+  l.d += s2.b;\n+  return l;\n+}\n+\n+int\n+main (void)\n+{\n+  ffi_cif cif;\n+  void* args[5];\n+  ffi_type* arg_types[5];\n+\n+  ffi_type s_type;\n+  ffi_type *s_type_elements[3];\n+\n+  ffi_type l_type;\n+  ffi_type *l_type_elements[6];\n+\n+  struct small_tag s1;\n+  struct small_tag s2;\n+  struct large_tag l1;\n+\n+  int n;\n+  struct large_tag res;\n+\n+  s_type.size = 0;\n+  s_type.alignment = 0;\n+  s_type.type = FFI_TYPE_STRUCT;\n+  s_type.elements = s_type_elements;\n+\n+  s_type_elements[0] = &ffi_type_uchar;\n+  s_type_elements[1] = &ffi_type_uchar;\n+  s_type_elements[2] = NULL;\n+\n+  l_type.size = 0;\n+  l_type.alignment = 0;\n+  l_type.type = FFI_TYPE_STRUCT;\n+  l_type.elements = l_type_elements;\n+\n+  l_type_elements[0] = &ffi_type_uint;\n+  l_type_elements[1] = &ffi_type_uint;\n+  l_type_elements[2] = &ffi_type_uint;\n+  l_type_elements[3] = &ffi_type_uint;\n+  l_type_elements[4] = &ffi_type_uint;\n+  l_type_elements[5] = NULL;\n+\n+  arg_types[0] = &ffi_type_sint;\n+  arg_types[1] = &s_type;\n+  arg_types[2] = &l_type;\n+  arg_types[3] = &s_type;\n+  arg_types[4] = NULL;\n+\n+  CHECK(ffi_prep_cif_var(&cif, FFI_DEFAULT_ABI, 1, 4, &l_type, arg_types) == FFI_OK);\n+\n+  s1.a = 5;\n+  s1.b = 6;\n+\n+  l1.a = 10;\n+  l1.b = 11;\n+  l1.c = 12;\n+  l1.d = 13;\n+  l1.e = 14;\n+\n+  s2.a = 7;\n+  s2.b = 8;\n+\n+  n = 41;\n+\n+  args[0] = &n;\n+  args[1] = &s1;\n+  args[2] = &l1;\n+  args[3] = &s2;\n+  args[4] = NULL;\n+\n+  ffi_call(&cif, FFI_FN(test_fn), &res, args);\n+  /* { dg-output \"5 6 10 11 12 13 14 7 8\" } */\n+  printf(\"res: %d %d %d %d %d\\n\", res.a, res.b, res.c, res.d, res.e);\n+  /* { dg-output \"\\nres: 15 17 19 21 14\" } */\n+\n+  return 0;\n+}"}]}