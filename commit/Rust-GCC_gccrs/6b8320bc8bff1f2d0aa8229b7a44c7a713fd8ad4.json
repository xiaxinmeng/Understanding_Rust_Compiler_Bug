{"sha": "6b8320bc8bff1f2d0aa8229b7a44c7a713fd8ad4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmI4MzIwYmM4YmZmMWYyZDBhYTgyMjliN2E0NGM3YTcxM2ZkOGFkNA==", "commit": {"author": {"name": "Venkataramanan Kumar", "email": "venkataramanan.kumar@amd.com", "date": "2015-11-30T07:59:54Z"}, "committer": {"name": "Venkataramanan Kumar", "email": "vekumar@gcc.gnu.org", "date": "2015-11-30T07:59:54Z"}, "message": "tree-if-conv.c (struct ifc_dr): Add new tree base_predicate field.\n\n2015-11-30  Venkataramanan Kumar  <Venkataramanan.Kumar@amd.com>\n\n\t* tree-if-conv.c (struct ifc_dr): Add new tree\n\tbase_predicate field.\n\t(hash_memrefs_baserefs_and_store_DRs_read_written_info): Hash\n\tbase ref, DR pairs and store base_predicate for write type DRs.\n\t(ifcvt_memrefs_wont_trap): Guard checks with\n\t-ftree-loop-if-convert-stores flag.\n\nFrom-SVN: r231057", "tree": {"sha": "3d17c686535f117d27a1986d7e13c4264c9b9456", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3d17c686535f117d27a1986d7e13c4264c9b9456"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6b8320bc8bff1f2d0aa8229b7a44c7a713fd8ad4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b8320bc8bff1f2d0aa8229b7a44c7a713fd8ad4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6b8320bc8bff1f2d0aa8229b7a44c7a713fd8ad4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b8320bc8bff1f2d0aa8229b7a44c7a713fd8ad4/comments", "author": null, "committer": null, "parents": [{"sha": "efb72c29ea063a4987325c694b38367f600b84c8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/efb72c29ea063a4987325c694b38367f600b84c8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/efb72c29ea063a4987325c694b38367f600b84c8"}], "stats": {"total": 47, "additions": 31, "deletions": 16}, "files": [{"sha": "3b93648f7867de7b7f4306269c482bbf98ce3757", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b8320bc8bff1f2d0aa8229b7a44c7a713fd8ad4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b8320bc8bff1f2d0aa8229b7a44c7a713fd8ad4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6b8320bc8bff1f2d0aa8229b7a44c7a713fd8ad4", "patch": "@@ -1,3 +1,12 @@\n+2015-11-30  Venkataramanan Kumar  <Venkataramanan.Kumar@amd.com>\n+\n+\t* tree-if-conv.c (struct ifc_dr): Add new tree\n+\tbase_predicate field.\n+\t(hash_memrefs_baserefs_and_store_DRs_read_written_info): Hash\n+\tbase ref, DR pairs and store base_predicate for write type DRs.\n+\t(ifcvt_memrefs_wont_trap): Guard checks with\n+\t-ftree-loop-if-convert-stores flag.\n+\n 2015-11-29  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* cgraph.c (cgraph_node::make_local): No name is unique during"}, {"sha": "f43942ddff0a842e520587e01c2e0e50e6649bd9", "filename": "gcc/tree-if-conv.c", "status": "modified", "additions": 22, "deletions": 16, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b8320bc8bff1f2d0aa8229b7a44c7a713fd8ad4/gcc%2Ftree-if-conv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b8320bc8bff1f2d0aa8229b7a44c7a713fd8ad4/gcc%2Ftree-if-conv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-if-conv.c?ref=6b8320bc8bff1f2d0aa8229b7a44c7a713fd8ad4", "patch": "@@ -589,6 +589,8 @@ struct ifc_dr {\n   int rw_unconditionally;\n \n   tree predicate;\n+\n+  tree base_predicate;\n };\n \n #define IFC_DR(DR) ((struct ifc_dr *) (DR)->aux)\n@@ -636,22 +638,24 @@ hash_memrefs_baserefs_and_store_DRs_read_written_info (data_reference_p a)\n   if (is_true_predicate (IFC_DR (*master_dr)->predicate))\n     DR_RW_UNCONDITIONALLY (*master_dr) = 1;\n \n-  base_master_dr = &baseref_DR_map->get_or_insert (base_ref,&exist2);\n-\n-  if (!exist2)\n+  if (DR_IS_WRITE (a))\n     {\n-      IFC_DR (a)->predicate = ca;\n-      *base_master_dr = a;\n-    }\n-  else\n-    IFC_DR (*base_master_dr)->predicate\n-\t= fold_or_predicates\n-\t\t(EXPR_LOCATION (IFC_DR (*base_master_dr)->predicate),\n-\t\t ca, IFC_DR (*base_master_dr)->predicate);\n+      base_master_dr = &baseref_DR_map->get_or_insert (base_ref, &exist2);\n \n-  if (DR_IS_WRITE (a)\n-      && (is_true_predicate (IFC_DR (*base_master_dr)->predicate)))\n-    DR_WRITTEN_AT_LEAST_ONCE (*base_master_dr) = 1;\n+      if (!exist2)\n+\t{\n+\t  IFC_DR (a)->base_predicate = ca;\n+\t  *base_master_dr = a;\n+\t}\n+      else\n+\tIFC_DR (*base_master_dr)->base_predicate\n+\t  = fold_or_predicates\n+\t      (EXPR_LOCATION (IFC_DR (*base_master_dr)->base_predicate),\n+\t       ca, IFC_DR (*base_master_dr)->base_predicate);\n+\n+      if (is_true_predicate (IFC_DR (*base_master_dr)->base_predicate))\n+\tDR_WRITTEN_AT_LEAST_ONCE (*base_master_dr) = 1;\n+    }\n }\n \n /* Return true when the memory references of STMT won't trap in the\n@@ -698,17 +702,19 @@ ifcvt_memrefs_wont_trap (gimple *stmt, vec<data_reference_p> drs)\n   master_dr = ref_DR_map->get (ref_base_a);\n   base_master_dr = baseref_DR_map->get (base);\n \n-  gcc_assert (master_dr != NULL && base_master_dr != NULL);\n+  gcc_assert (master_dr != NULL);\n \n   if (DR_RW_UNCONDITIONALLY (*master_dr) == 1)\n     {\n-      if (DR_WRITTEN_AT_LEAST_ONCE (*base_master_dr) == 1)\n+      if (base_master_dr\n+\t  && DR_WRITTEN_AT_LEAST_ONCE (*base_master_dr) == 1)\n \treturn true;\n       else\n \t{\n \t  tree base_tree = get_base_address (DR_REF (a));\n \t  if (DECL_P (base_tree)\n \t      && decl_binds_to_current_def_p (base_tree)\n+\t      && flag_tree_loop_if_convert_stores\n \t      && !TREE_READONLY (base_tree))\n \t  return true;\n \t}"}]}