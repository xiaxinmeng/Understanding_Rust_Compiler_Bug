{"sha": "fbbf66e77a385fc1901fdc33c1d977681cab39bf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmJiZjY2ZTc3YTM4NWZjMTkwMWZkYzMzYzFkOTc3NjgxY2FiMzliZg==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2011-04-21T09:37:44Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2011-04-21T09:37:44Z"}, "message": "target.def (cannot_force_const_mem): Add a mode argument.\n\ngcc/\n\t* target.def (cannot_force_const_mem): Add a mode argument.\n\t* doc/tm.texi.in (TARGET_CANNOT_FORCE_CONST_MEM): Update accordingly.\n\t* doc/tm.texi: Regenerate.\n\t* hooks.h (hook_bool_mode_rtx_false): Declare.\n\t* hooks.c (hook_bool_mode_const_rtx_false): Fix commentary.\n\t(hook_bool_mode_const_rtx_true): Likewise.\n\t(hook_bool_mode_rtx_false): New function.\n\t* reload.c (CONST_POOL_OK_P): Take a mode argument and require it\n\tto be non-VOID.  Update call to cannot_force_const_mem.\n\t(find_reloads): Update accordingly.\n\t* varasm.c (force_const_mem): Update call to cannot_force_const_mem.\n\t* config/alpha/alpha.c (alpha_cannot_force_const_mem): Add a mode\n\targument.\n\t* config/arm/arm-protos.h (arm_cannot_force_const_mem): Likewise.\n\t* config/arm/arm.h (LEGITIMATE_CONSTANT_P): Update call.\n\t* config/arm/arm.c (arm_cannot_force_const_mem): Add a mode argument.\n\t* config/bfin/bfin.c (bfin_cannot_force_const_mem): Likewise.\n\t* config/frv/frv.c (frv_cannot_force_const_mem): Likewise.\n\t* config/i386/i386.c (ix86_cannot_force_const_mem): Likewise.\n\t* config/ia64/ia64.c (ia64_cannot_force_const_mem): Likewise.\n\t* config/m68k/m68k.c (TARGET_CANNOT_FORCE_CONST_MEM): Redefine to...\n\t(m68k_cannot_force_const_mem): ...this new function.\n\t* config/mips/mips.c (mips_cannot_force_const_mem): Add a mode\n\targument.\n\t(mips_const_insns, mips_legitimize_const_move): Update calls.\n\t(mips_secondary_reload_class): Likewise.\n\t* config/pa/pa.c (TARGET_CANNOT_FORCE_CONST_MEM): Redefine to...\n\t(pa_cannot_force_const_mem): ...this new function.\n\t* config/rs6000/rs6000.c (TARGET_CANNOT_FORCE_CONST_MEM): Reefine\n\tto...\n\t(rs6000_cannot_force_const_mem): ...this new function.\n\t* config/s390/s390.c (s390_cannot_force_const_mem): Add a mode\n\targument.\n\t* config/sparc/sparc.c (sparc_cannot_force_const_mem): Likewise.\n\t* config/xtensa/xtensa.c (TARGET_CANNOT_FORCE_CONST_MEM): Redefine\n\tto...\n\t(xtensa_cannot_force_const_mem): ...this new function.\n\nFrom-SVN: r172813", "tree": {"sha": "eaf6c68a5f7e3822c501346ded206279f68c7bec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eaf6c68a5f7e3822c501346ded206279f68c7bec"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fbbf66e77a385fc1901fdc33c1d977681cab39bf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fbbf66e77a385fc1901fdc33c1d977681cab39bf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fbbf66e77a385fc1901fdc33c1d977681cab39bf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fbbf66e77a385fc1901fdc33c1d977681cab39bf/comments", "author": null, "committer": null, "parents": [{"sha": "e85df92e7d3da03b3f893d378c5c64ceee1de7e1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e85df92e7d3da03b3f893d378c5c64ceee1de7e1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e85df92e7d3da03b3f893d378c5c64ceee1de7e1"}], "stats": {"total": 194, "additions": 143, "deletions": 51}, "files": [{"sha": "3f346fc8dd8ae5fc4fcd02f43267b0bdfe5482c0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbbf66e77a385fc1901fdc33c1d977681cab39bf/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbbf66e77a385fc1901fdc33c1d977681cab39bf/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fbbf66e77a385fc1901fdc33c1d977681cab39bf", "patch": "@@ -1,3 +1,43 @@\n+2011-04-21  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* target.def (cannot_force_const_mem): Add a mode argument.\n+\t* doc/tm.texi.in (TARGET_CANNOT_FORCE_CONST_MEM): Update accordingly.\n+\t* doc/tm.texi: Regenerate.\n+\t* hooks.h (hook_bool_mode_rtx_false): Declare.\n+\t* hooks.c (hook_bool_mode_const_rtx_false): Fix commentary.\n+\t(hook_bool_mode_const_rtx_true): Likewise.\n+\t(hook_bool_mode_rtx_false): New function.\n+\t* reload.c (CONST_POOL_OK_P): Take a mode argument and require it\n+\tto be non-VOID.  Update call to cannot_force_const_mem.\n+\t(find_reloads): Update accordingly.\n+\t* varasm.c (force_const_mem): Update call to cannot_force_const_mem.\n+\t* config/alpha/alpha.c (alpha_cannot_force_const_mem): Add a mode\n+\targument.\n+\t* config/arm/arm-protos.h (arm_cannot_force_const_mem): Likewise.\n+\t* config/arm/arm.h (LEGITIMATE_CONSTANT_P): Update call.\n+\t* config/arm/arm.c (arm_cannot_force_const_mem): Add a mode argument.\n+\t* config/bfin/bfin.c (bfin_cannot_force_const_mem): Likewise.\n+\t* config/frv/frv.c (frv_cannot_force_const_mem): Likewise.\n+\t* config/i386/i386.c (ix86_cannot_force_const_mem): Likewise.\n+\t* config/ia64/ia64.c (ia64_cannot_force_const_mem): Likewise.\n+\t* config/m68k/m68k.c (TARGET_CANNOT_FORCE_CONST_MEM): Redefine to...\n+\t(m68k_cannot_force_const_mem): ...this new function.\n+\t* config/mips/mips.c (mips_cannot_force_const_mem): Add a mode\n+\targument.\n+\t(mips_const_insns, mips_legitimize_const_move): Update calls.\n+\t(mips_secondary_reload_class): Likewise.\n+\t* config/pa/pa.c (TARGET_CANNOT_FORCE_CONST_MEM): Redefine to...\n+\t(pa_cannot_force_const_mem): ...this new function.\n+\t* config/rs6000/rs6000.c (TARGET_CANNOT_FORCE_CONST_MEM): Reefine\n+\tto...\n+\t(rs6000_cannot_force_const_mem): ...this new function.\n+\t* config/s390/s390.c (s390_cannot_force_const_mem): Add a mode\n+\targument.\n+\t* config/sparc/sparc.c (sparc_cannot_force_const_mem): Likewise.\n+\t* config/xtensa/xtensa.c (TARGET_CANNOT_FORCE_CONST_MEM): Redefine\n+\tto...\n+\t(xtensa_cannot_force_const_mem): ...this new function.\n+\n 2011-04-20  Nathan Froyd  <froydnj@codesourcery.com>\n \n \t* config/mips/mips.c (mips16_build_function_stub): Call"}, {"sha": "ba0dfe633cca1f1ea80aba058fcad23f470f2e77", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbbf66e77a385fc1901fdc33c1d977681cab39bf/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbbf66e77a385fc1901fdc33c1d977681cab39bf/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=fbbf66e77a385fc1901fdc33c1d977681cab39bf", "patch": "@@ -1095,7 +1095,7 @@ alpha_legitimize_address (rtx x, rtx oldx ATTRIBUTE_UNUSED,\n    should never be spilling symbolic operands to the constant pool, ever.  */\n \n static bool\n-alpha_cannot_force_const_mem (rtx x)\n+alpha_cannot_force_const_mem (enum machine_mode mode ATTRIBUTE_UNUSED, rtx x)\n {\n   enum rtx_code code = GET_CODE (x);\n   return code == SYMBOL_REF || code == LABEL_REF || code == CONST;"}, {"sha": "da3241d2bf32fb6be92ee1bb5356bda3aca376d9", "filename": "gcc/config/arm/arm-protos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbbf66e77a385fc1901fdc33c1d977681cab39bf/gcc%2Fconfig%2Farm%2Farm-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbbf66e77a385fc1901fdc33c1d977681cab39bf/gcc%2Fconfig%2Farm%2Farm-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-protos.h?ref=fbbf66e77a385fc1901fdc33c1d977681cab39bf", "patch": "@@ -82,7 +82,7 @@ extern void neon_disambiguate_copy (rtx *, rtx *, rtx *, unsigned int);\n extern enum reg_class coproc_secondary_reload_class (enum machine_mode, rtx,\n \t\t\t\t\t\t     bool);\n extern bool arm_tls_referenced_p (rtx);\n-extern bool arm_cannot_force_const_mem (rtx);\n+extern bool arm_cannot_force_const_mem (enum machine_mode, rtx);\n \n extern int cirrus_memory_offset (rtx);\n extern int arm_coproc_mem_operand (rtx, bool);"}, {"sha": "0f944fd869d9d9ebba686f11fbefbc1c2706739c", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbbf66e77a385fc1901fdc33c1d977681cab39bf/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbbf66e77a385fc1901fdc33c1d977681cab39bf/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=fbbf66e77a385fc1901fdc33c1d977681cab39bf", "patch": "@@ -6500,7 +6500,7 @@ arm_tls_referenced_p (rtx x)\n /* Implement TARGET_CANNOT_FORCE_CONST_MEM.  */\n \n bool\n-arm_cannot_force_const_mem (rtx x)\n+arm_cannot_force_const_mem (enum machine_mode mode ATTRIBUTE_UNUSED, rtx x)\n {\n   rtx base, offset;\n "}, {"sha": "76efdec8e50860c281c68284feec809000e5ec22", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbbf66e77a385fc1901fdc33c1d977681cab39bf/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbbf66e77a385fc1901fdc33c1d977681cab39bf/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=fbbf66e77a385fc1901fdc33c1d977681cab39bf", "patch": "@@ -1763,7 +1763,7 @@ typedef struct\n   || flag_pic)\n \n #define LEGITIMATE_CONSTANT_P(X)\t\t\t\\\n-  (!arm_cannot_force_const_mem (X)\t\t\t\\\n+  (!arm_cannot_force_const_mem (VOIDmode, X)\t\t\\\n    && (TARGET_32BIT ? ARM_LEGITIMATE_CONSTANT_P (X)\t\\\n \t\t    : THUMB_LEGITIMATE_CONSTANT_P (X)))\n "}, {"sha": "2a9730fa902080e8f112a846bef4dce8b4a6003c", "filename": "gcc/config/bfin/bfin.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbbf66e77a385fc1901fdc33c1d977681cab39bf/gcc%2Fconfig%2Fbfin%2Fbfin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbbf66e77a385fc1901fdc33c1d977681cab39bf/gcc%2Fconfig%2Fbfin%2Fbfin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fbfin%2Fbfin.c?ref=fbbf66e77a385fc1901fdc33c1d977681cab39bf", "patch": "@@ -3055,7 +3055,8 @@ bfin_legitimate_address_p (enum machine_mode mode, rtx x, bool strict)\n    another way.  */\n \n static bool\n-bfin_cannot_force_const_mem (rtx x ATTRIBUTE_UNUSED)\n+bfin_cannot_force_const_mem (enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t\t     rtx x ATTRIBUTE_UNUSED)\n {\n   /* We have only one class of non-legitimate constants, and our movsi\n      expander knows how to handle them.  Dropping these constants into the"}, {"sha": "5b0c0847e1594e096a351260d0df27353410ecdf", "filename": "gcc/config/frv/frv.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbbf66e77a385fc1901fdc33c1d977681cab39bf/gcc%2Fconfig%2Ffrv%2Ffrv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbbf66e77a385fc1901fdc33c1d977681cab39bf/gcc%2Fconfig%2Ffrv%2Ffrv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.c?ref=fbbf66e77a385fc1901fdc33c1d977681cab39bf", "patch": "@@ -372,7 +372,7 @@ static int frv_memory_move_cost\t\t\t(enum machine_mode,\n static void frv_asm_out_constructor\t\t(rtx, int);\n static void frv_asm_out_destructor\t\t(rtx, int);\n static bool frv_function_symbol_referenced_p\t(rtx);\n-static bool frv_cannot_force_const_mem\t\t(rtx);\n+static bool frv_cannot_force_const_mem\t\t(enum machine_mode, rtx);\n static const char *unspec_got_name\t\t(int);\n static void frv_output_const_unspec\t\t(FILE *,\n \t\t\t\t\t\t const struct frv_unspec *);\n@@ -616,7 +616,8 @@ frv_const_unspec_p (rtx x, struct frv_unspec *unspec)\n    4. In many cases, it's more efficient to calculate the constant in-line.  */\n \n static bool\n-frv_cannot_force_const_mem (rtx x ATTRIBUTE_UNUSED)\n+frv_cannot_force_const_mem (enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t\t    rtx x ATTRIBUTE_UNUSED)\n {\n   return TARGET_FDPIC;\n }"}, {"sha": "c4b18ef56ad2fa77c916dfb93793fe0c03246f9a", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbbf66e77a385fc1901fdc33c1d977681cab39bf/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbbf66e77a385fc1901fdc33c1d977681cab39bf/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=fbbf66e77a385fc1901fdc33c1d977681cab39bf", "patch": "@@ -12005,7 +12005,7 @@ legitimate_constant_p (rtx x)\n    is checked above.  */\n \n static bool\n-ix86_cannot_force_const_mem (rtx x)\n+ix86_cannot_force_const_mem (enum machine_mode mode ATTRIBUTE_UNUSED, rtx x)\n {\n   /* We can always put integral constants and vectors in memory.  */\n   switch (GET_CODE (x))"}, {"sha": "608327930177231e903065d1a370e3ba655cb8e4", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbbf66e77a385fc1901fdc33c1d977681cab39bf/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbbf66e77a385fc1901fdc33c1d977681cab39bf/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=fbbf66e77a385fc1901fdc33c1d977681cab39bf", "patch": "@@ -316,7 +316,7 @@ static rtx ia64_struct_value_rtx (tree, int);\n static tree ia64_gimplify_va_arg (tree, tree, gimple_seq *, gimple_seq *);\n static bool ia64_scalar_mode_supported_p (enum machine_mode mode);\n static bool ia64_vector_mode_supported_p (enum machine_mode mode);\n-static bool ia64_cannot_force_const_mem (rtx);\n+static bool ia64_cannot_force_const_mem (enum machine_mode, rtx);\n static const char *ia64_mangle_type (const_tree);\n static const char *ia64_invalid_conversion (const_tree, const_tree);\n static const char *ia64_invalid_unary_op (int, const_tree);\n@@ -1014,9 +1014,9 @@ ia64_legitimate_constant_p (rtx x)\n /* Don't allow TLS addresses to get spilled to memory.  */\n \n static bool\n-ia64_cannot_force_const_mem (rtx x)\n+ia64_cannot_force_const_mem (enum machine_mode mode, rtx x)\n {\n-  if (GET_MODE (x) == RFmode)\n+  if (mode == RFmode)\n     return true;\n   return tls_symbolic_operand_type (x) != 0;\n }"}, {"sha": "7553183d541662225340bffe961dd3e8f350be9a", "filename": "gcc/config/m68k/m68k.c", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbbf66e77a385fc1901fdc33c1d977681cab39bf/gcc%2Fconfig%2Fm68k%2Fm68k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbbf66e77a385fc1901fdc33c1d977681cab39bf/gcc%2Fconfig%2Fm68k%2Fm68k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.c?ref=fbbf66e77a385fc1901fdc33c1d977681cab39bf", "patch": "@@ -163,6 +163,7 @@ static void m68k_function_arg_advance (CUMULATIVE_ARGS *, enum machine_mode,\n \t\t\t\t       const_tree, bool);\n static rtx m68k_function_arg (CUMULATIVE_ARGS *, enum machine_mode,\n \t\t\t      const_tree, bool);\n+static bool m68k_cannot_force_const_mem (enum machine_mode mode, rtx x);\n \f\n \n /* Specify the identification number of the library being built */\n@@ -256,7 +257,7 @@ const char *m68k_library_id_string = \"_current_shared_library_a5_offset_\";\n #define TARGET_STRUCT_VALUE_RTX m68k_struct_value_rtx\n \n #undef TARGET_CANNOT_FORCE_CONST_MEM\n-#define TARGET_CANNOT_FORCE_CONST_MEM m68k_illegitimate_symbolic_constant_p\n+#define TARGET_CANNOT_FORCE_CONST_MEM m68k_cannot_force_const_mem\n \n #undef TARGET_FUNCTION_OK_FOR_SIBCALL\n #define TARGET_FUNCTION_OK_FOR_SIBCALL m68k_ok_for_sibcall_p\n@@ -1937,6 +1938,14 @@ m68k_illegitimate_symbolic_constant_p (rtx x)\n   return m68k_tls_reference_p (x, false);\n }\n \n+/* Implement TARGET_CANNOT_FORCE_CONST_MEM.  */\n+\n+static bool\n+m68k_cannot_force_const_mem (enum machine_mode mode ATTRIBUTE_UNUSED, rtx x)\n+{\n+  return m68k_illegitimate_symbolic_constant_p (x);\n+}\n+\n /* Return true if X is a legitimate constant address that can reach\n    bytes in the range [X, X + REACH).  STRICT_P says whether we need\n    strict checking.  */"}, {"sha": "f6a4ec98cbe984ce9d146372ed10412ecc3b9f22", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbbf66e77a385fc1901fdc33c1d977681cab39bf/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbbf66e77a385fc1901fdc33c1d977681cab39bf/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=fbbf66e77a385fc1901fdc33c1d977681cab39bf", "patch": "@@ -1997,7 +1997,7 @@ mips_tls_symbol_ref_1 (rtx *x, void *data ATTRIBUTE_UNUSED)\n /* Implement TARGET_CANNOT_FORCE_CONST_MEM.  */\n \n static bool\n-mips_cannot_force_const_mem (rtx x)\n+mips_cannot_force_const_mem (enum machine_mode mode ATTRIBUTE_UNUSED, rtx x)\n {\n   enum mips_symbol_type type;\n   rtx base, offset;\n@@ -2387,7 +2387,7 @@ mips_const_insns (rtx x)\n \t    {\n \t      if (SMALL_INT (offset))\n \t\treturn n + 1;\n-\t      else if (!targetm.cannot_force_const_mem (x))\n+\t      else if (!targetm.cannot_force_const_mem (GET_MODE (x), x))\n \t\treturn n + 1 + mips_build_integer (codes, INTVAL (offset));\n \t    }\n \t}\n@@ -3090,7 +3090,7 @@ mips_legitimize_const_move (enum machine_mode mode, rtx dest, rtx src)\n      forced into memory, as it usually produces better code.  */\n   split_const (src, &base, &offset);\n   if (offset != const0_rtx\n-      && (targetm.cannot_force_const_mem (src)\n+      && (targetm.cannot_force_const_mem (mode, src)\n \t  || (!TARGET_MIPS16 && can_create_pseudo_p ())))\n     {\n       base = mips_force_temporary (dest, base);\n@@ -11087,7 +11087,7 @@ mips_secondary_reload_class (enum reg_class rclass,\n \t/* In this case we can use mtc1, mfc1, dmtc1 or dmfc1.  */\n \treturn NO_REGS;\n \n-      if (CONSTANT_P (x) && !targetm.cannot_force_const_mem (x))\n+      if (CONSTANT_P (x) && !targetm.cannot_force_const_mem (mode, x))\n \t/* We can force the constant to memory and use lwc1\n \t   and ldc1.  As above, we will use pairs of lwc1s if\n \t   ldc1 is not supported.  */"}, {"sha": "ab0fe6a8a097992a69656f618392fc8fcc2dfd79", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbbf66e77a385fc1901fdc33c1d977681cab39bf/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbbf66e77a385fc1901fdc33c1d977681cab39bf/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=fbbf66e77a385fc1901fdc33c1d977681cab39bf", "patch": "@@ -187,6 +187,7 @@ static bool pa_can_eliminate (const int, const int);\n static void pa_conditional_register_usage (void);\n static enum machine_mode pa_c_mode_for_suffix (char);\n static section *pa_function_section (tree, enum node_frequency, bool, bool);\n+static bool pa_cannot_force_const_mem (enum machine_mode, rtx);\n \n /* The following extra sections are only used for SOM.  */\n static GTY(()) section *som_readonly_data_section;\n@@ -369,7 +370,7 @@ static const struct default_options pa_option_optimization_table[] =\n #define TARGET_SCALAR_MODE_SUPPORTED_P pa_scalar_mode_supported_p\n \n #undef TARGET_CANNOT_FORCE_CONST_MEM\n-#define TARGET_CANNOT_FORCE_CONST_MEM pa_tls_referenced_p\n+#define TARGET_CANNOT_FORCE_CONST_MEM pa_cannot_force_const_mem\n \n #undef TARGET_SECONDARY_RELOAD\n #define TARGET_SECONDARY_RELOAD pa_secondary_reload\n@@ -1563,6 +1564,14 @@ pa_tls_referenced_p (rtx x)\n   return for_each_rtx (&x, &pa_tls_symbol_ref_1, 0);\n }\n \n+/* Implement TARGET_CANNOT_FORCE_CONST_MEM.  */\n+\n+static bool\n+pa_cannot_force_const_mem (enum machine_mode mode ATTRIBUTE_UNUSED, rtx x)\n+{\n+  return pa_tls_referenced_p (x);\n+}\n+\n /* Emit insns to move operands[1] into operands[0].\n \n    Return 1 if we have written out everything that needs to be done to"}, {"sha": "201c2fb5cdac1c627be1bc588e820a208a6e7e6d", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbbf66e77a385fc1901fdc33c1d977681cab39bf/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbbf66e77a385fc1901fdc33c1d977681cab39bf/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=fbbf66e77a385fc1901fdc33c1d977681cab39bf", "patch": "@@ -1212,6 +1212,7 @@ static enum machine_mode rs6000_eh_return_filter_mode (void);\n static bool rs6000_can_eliminate (const int, const int);\n static void rs6000_conditional_register_usage (void);\n static void rs6000_trampoline_init (rtx, tree, rtx);\n+static bool rs6000_cannot_force_const_mem (enum machine_mode, rtx);\n \n /* Hash table stuff for keeping track of TOC entries.  */\n \n@@ -1388,7 +1389,7 @@ static const struct default_options rs6000_option_optimization_table[] =\n #define TARGET_HAVE_TLS HAVE_AS_TLS\n \n #undef TARGET_CANNOT_FORCE_CONST_MEM\n-#define TARGET_CANNOT_FORCE_CONST_MEM rs6000_tls_referenced_p\n+#define TARGET_CANNOT_FORCE_CONST_MEM rs6000_cannot_force_const_mem\n \n #undef TARGET_DELEGITIMIZE_ADDRESS\n #define TARGET_DELEGITIMIZE_ADDRESS rs6000_delegitimize_address\n@@ -6619,6 +6620,14 @@ rs6000_tls_referenced_p (rtx x)\n   return for_each_rtx (&x, &rs6000_tls_symbol_ref_1, 0);\n }\n \n+/* Implement TARGET_CANNOT_FORCE_CONST_MEM.  */\n+\n+static bool\n+rs6000_cannot_force_const_mem (enum machine_mode mode ATTRIBUTE_UNUSED, rtx x)\n+{\n+  return rs6000_tls_referenced_p (x);\n+}\n+\n /* Return 1 if *X is a thread-local symbol.  This is the same as\n    rs6000_tls_symbol_ref except for the type of the unused argument.  */\n "}, {"sha": "8454333f2edeb2ff646874311a7f67fc5ad8dda2", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbbf66e77a385fc1901fdc33c1d977681cab39bf/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbbf66e77a385fc1901fdc33c1d977681cab39bf/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=fbbf66e77a385fc1901fdc33c1d977681cab39bf", "patch": "@@ -2810,7 +2810,7 @@ legitimate_constant_p (rtx op)\n    not constant (TLS) or not known at final link time (PIC).  */\n \n static bool\n-s390_cannot_force_const_mem (rtx x)\n+s390_cannot_force_const_mem (enum machine_mode mode, rtx x)\n {\n   switch (GET_CODE (x))\n     {\n@@ -2832,11 +2832,11 @@ s390_cannot_force_const_mem (rtx x)\n \treturn flag_pic != 0;\n \n     case CONST:\n-      return s390_cannot_force_const_mem (XEXP (x, 0));\n+      return s390_cannot_force_const_mem (mode, XEXP (x, 0));\n     case PLUS:\n     case MINUS:\n-      return s390_cannot_force_const_mem (XEXP (x, 0))\n-\t     || s390_cannot_force_const_mem (XEXP (x, 1));\n+      return s390_cannot_force_const_mem (mode, XEXP (x, 0))\n+\t     || s390_cannot_force_const_mem (mode, XEXP (x, 1));\n \n     case UNSPEC:\n       switch (XINT (x, 1))"}, {"sha": "b112f7e3d47ff958d4ae3438df628a55abb7d5b8", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbbf66e77a385fc1901fdc33c1d977681cab39bf/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbbf66e77a385fc1901fdc33c1d977681cab39bf/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=fbbf66e77a385fc1901fdc33c1d977681cab39bf", "patch": "@@ -417,7 +417,7 @@ static void sparc_output_mi_thunk (FILE *, tree, HOST_WIDE_INT,\n static bool sparc_can_output_mi_thunk (const_tree, HOST_WIDE_INT,\n \t\t\t\t       HOST_WIDE_INT, const_tree);\n static struct machine_function * sparc_init_machine_status (void);\n-static bool sparc_cannot_force_const_mem (rtx);\n+static bool sparc_cannot_force_const_mem (enum machine_mode, rtx);\n static rtx sparc_tls_get_addr (void);\n static rtx sparc_tls_got (void);\n static const char *get_some_local_dynamic_name (void);\n@@ -2924,7 +2924,7 @@ reg_unused_after (rtx reg, rtx insn)\n    not constant (TLS) or not known at final link time (PIC).  */\n \n static bool\n-sparc_cannot_force_const_mem (rtx x)\n+sparc_cannot_force_const_mem (enum machine_mode mode, rtx x)\n {\n   switch (GET_CODE (x))\n     {\n@@ -2947,11 +2947,11 @@ sparc_cannot_force_const_mem (rtx x)\n \treturn flag_pic != 0;\n \n     case CONST:\n-      return sparc_cannot_force_const_mem (XEXP (x, 0));\n+      return sparc_cannot_force_const_mem (mode, XEXP (x, 0));\n     case PLUS:\n     case MINUS:\n-      return sparc_cannot_force_const_mem (XEXP (x, 0))\n-         || sparc_cannot_force_const_mem (XEXP (x, 1));\n+      return sparc_cannot_force_const_mem (mode, XEXP (x, 0))\n+         || sparc_cannot_force_const_mem (mode, XEXP (x, 1));\n     case UNSPEC:\n       return true;\n     default:"}, {"sha": "2ffc39f7fd141b39fe318a33c2a1066a692ca1f2", "filename": "gcc/config/xtensa/xtensa.c", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbbf66e77a385fc1901fdc33c1d977681cab39bf/gcc%2Fconfig%2Fxtensa%2Fxtensa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbbf66e77a385fc1901fdc33c1d977681cab39bf/gcc%2Fconfig%2Fxtensa%2Fxtensa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa.c?ref=fbbf66e77a385fc1901fdc33c1d977681cab39bf", "patch": "@@ -164,6 +164,7 @@ static rtx xtensa_static_chain (const_tree, bool);\n static void xtensa_asm_trampoline_template (FILE *);\n static void xtensa_trampoline_init (rtx, tree, rtx);\n static bool xtensa_output_addr_const_extra (FILE *, rtx);\n+static bool xtensa_cannot_force_const_mem (enum machine_mode, rtx);\n \n static reg_class_t xtensa_preferred_reload_class (rtx, reg_class_t);\n static reg_class_t xtensa_preferred_output_reload_class (rtx, reg_class_t);\n@@ -285,7 +286,7 @@ static const struct default_options xtensa_option_optimization_table[] =\n #define TARGET_HAVE_TLS (TARGET_THREADPTR && HAVE_AS_TLS)\n \n #undef TARGET_CANNOT_FORCE_CONST_MEM\n-#define TARGET_CANNOT_FORCE_CONST_MEM xtensa_tls_referenced_p\n+#define TARGET_CANNOT_FORCE_CONST_MEM xtensa_cannot_force_const_mem\n \n #undef TARGET_LEGITIMATE_ADDRESS_P\n #define TARGET_LEGITIMATE_ADDRESS_P\txtensa_legitimate_address_p\n@@ -2014,6 +2015,15 @@ xtensa_tls_referenced_p (rtx x)\n }\n \n \n+/* Implement TARGET_CANNOT_FORCE_CONST_MEM.  */\n+\n+static bool\n+xtensa_cannot_force_const_mem (enum machine_mode mode ATTRIBUTE_UNUSED, rtx x)\n+{\n+  return xtensa_tls_referenced_p (x);\n+}\n+\n+\n /* Return the debugger register number to use for 'regno'.  */\n \n int"}, {"sha": "ec555517537d60cea59df0d11cb0401352308916", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbbf66e77a385fc1901fdc33c1d977681cab39bf/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbbf66e77a385fc1901fdc33c1d977681cab39bf/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=fbbf66e77a385fc1901fdc33c1d977681cab39bf", "patch": "@@ -5553,10 +5553,12 @@ the semantics of these opaque @code{UNSPEC}s by converting them back\n into their original form.\n @end deftypefn\n \n-@deftypefn {Target Hook} bool TARGET_CANNOT_FORCE_CONST_MEM (rtx @var{x})\n+@deftypefn {Target Hook} bool TARGET_CANNOT_FORCE_CONST_MEM (enum machine_mode @var{mode}, rtx @var{x})\n This hook should return true if @var{x} is of a form that cannot (or\n-should not) be spilled to the constant pool.  The default version of\n-this hook returns false.\n+should not) be spilled to the constant pool.  @var{mode} is the mode\n+of @var{x}.\n+\n+The default version of this hook returns false.\n \n The primary reason to define this hook is to prevent reload from\n deciding that a non-legitimate constant would be better reloaded"}, {"sha": "1c96941f643e3a350a15cbb658a8141b1d1a6b88", "filename": "gcc/doc/tm.texi.in", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbbf66e77a385fc1901fdc33c1d977681cab39bf/gcc%2Fdoc%2Ftm.texi.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbbf66e77a385fc1901fdc33c1d977681cab39bf/gcc%2Fdoc%2Ftm.texi.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi.in?ref=fbbf66e77a385fc1901fdc33c1d977681cab39bf", "patch": "@@ -5533,8 +5533,10 @@ into their original form.\n \n @hook TARGET_CANNOT_FORCE_CONST_MEM\n This hook should return true if @var{x} is of a form that cannot (or\n-should not) be spilled to the constant pool.  The default version of\n-this hook returns false.\n+should not) be spilled to the constant pool.  @var{mode} is the mode\n+of @var{x}.\n+\n+The default version of this hook returns false.\n \n The primary reason to define this hook is to prevent reload from\n deciding that a non-legitimate constant would be better reloaded"}, {"sha": "a991980a9870b1bf5cbda7645b2037954c57d648", "filename": "gcc/hooks.c", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbbf66e77a385fc1901fdc33c1d977681cab39bf/gcc%2Fhooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbbf66e77a385fc1901fdc33c1d977681cab39bf/gcc%2Fhooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhooks.c?ref=fbbf66e77a385fc1901fdc33c1d977681cab39bf", "patch": "@@ -85,22 +85,30 @@ hook_bool_mode_true (enum machine_mode mode ATTRIBUTE_UNUSED)\n   return true;\n }\n \n-/* Generic hook that takes (enum machine_mode, rtx) and returns false.  */\n+/* Generic hook that takes (enum machine_mode, const_rtx) and returns false.  */\n bool\n hook_bool_mode_const_rtx_false (enum machine_mode mode ATTRIBUTE_UNUSED,\n \t\t\t\tconst_rtx value ATTRIBUTE_UNUSED)\n {\n   return false;\n }\n \n-/* Generic hook that takes (enum machine_mode, rtx) and returns true.  */\n+/* Generic hook that takes (enum machine_mode, const_rtx) and returns true.  */\n bool\n hook_bool_mode_const_rtx_true (enum machine_mode mode ATTRIBUTE_UNUSED,\n \t\t\t       const_rtx value ATTRIBUTE_UNUSED)\n {\n   return true;\n }\n \n+/* Generic hook that takes (enum machine_mode, rtx) and returns false.  */\n+bool\n+hook_bool_mode_rtx_false (enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t\t  rtx value ATTRIBUTE_UNUSED)\n+{\n+  return false;\n+}\n+\n /* Generic hook that takes (FILE *, const char *) and does nothing.  */\n void\n hook_void_FILEptr_constcharptr (FILE *a ATTRIBUTE_UNUSED, const char *b ATTRIBUTE_UNUSED)"}, {"sha": "548dad34751fa7e0686bbd319ef1ef0b1298ef2d", "filename": "gcc/hooks.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbbf66e77a385fc1901fdc33c1d977681cab39bf/gcc%2Fhooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbbf66e77a385fc1901fdc33c1d977681cab39bf/gcc%2Fhooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhooks.h?ref=fbbf66e77a385fc1901fdc33c1d977681cab39bf", "patch": "@@ -34,6 +34,7 @@ extern bool hook_bool_mode_false (enum machine_mode);\n extern bool hook_bool_mode_true (enum machine_mode);\n extern bool hook_bool_mode_const_rtx_false (enum machine_mode, const_rtx);\n extern bool hook_bool_mode_const_rtx_true (enum machine_mode, const_rtx);\n+extern bool hook_bool_mode_rtx_false (enum machine_mode, rtx);\n extern bool hook_bool_tree_false (tree);\n extern bool hook_bool_const_tree_false (const_tree);\n extern bool hook_bool_tree_true (tree);"}, {"sha": "372eccc0fb9f16dbe6d7086c3e02b5777674d7a0", "filename": "gcc/reload.c", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbbf66e77a385fc1901fdc33c1d977681cab39bf/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbbf66e77a385fc1901fdc33c1d977681cab39bf/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=fbbf66e77a385fc1901fdc33c1d977681cab39bf", "patch": "@@ -112,11 +112,13 @@ a register with any other reload.  */\n #include \"target.h\"\n #include \"ira.h\"\n \n-/* True if X is a constant that can be forced into the constant pool.  */\n-#define CONST_POOL_OK_P(X)\t\t\t\\\n-  (CONSTANT_P (X)\t\t\t\t\\\n+/* True if X is a constant that can be forced into the constant pool.\n+   MODE is the mode of the operand, or VOIDmode if not known.  */\n+#define CONST_POOL_OK_P(MODE, X)\t\t\\\n+  ((MODE) != VOIDmode\t\t\t\t\\\n+   && CONSTANT_P (X)\t\t\t\t\\\n    && GET_CODE (X) != HIGH\t\t\t\\\n-   && !targetm.cannot_force_const_mem (X))\n+   && !targetm.cannot_force_const_mem (MODE, X))\n \n /* True if C is a non-empty register class that has too few registers\n    to be safely used as a reload target class.  */\n@@ -3246,7 +3248,7 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,\n \t\t\t&& REGNO (operand) >= FIRST_PSEUDO_REGISTER\n \t\t\t&& reg_renumber[REGNO (operand)] < 0))\n \t\t  win = 1;\n-\t\tif (CONST_POOL_OK_P (operand))\n+\t\tif (CONST_POOL_OK_P (operand_mode[i], operand))\n \t\t  badop = 0;\n \t\tconstmemok = 1;\n \t\tbreak;\n@@ -3308,7 +3310,7 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,\n \t\t\t     && offsettable_memref_p (reg_equiv_mem (REGNO (operand))))\n \t\t\t    || (reg_equiv_address (REGNO (operand)) != 0))))\n \t\t  win = 1;\n-\t\tif (CONST_POOL_OK_P (operand)\n+\t\tif (CONST_POOL_OK_P (operand_mode[i], operand)\n \t\t    || MEM_P (operand))\n \t\t  badop = 0;\n \t\tconstmemok = 1;\n@@ -3424,7 +3426,7 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,\n \t\t\t/* If we didn't already win, we can reload\n \t\t\t   constants via force_const_mem, and other\n \t\t\t   MEMs by reloading the address like for 'o'.  */\n-\t\t\tif (CONST_POOL_OK_P (operand)\n+\t\t\tif (CONST_POOL_OK_P (operand_mode[i], operand)\n \t\t\t    || MEM_P (operand))\n \t\t\t  badop = 0;\n \t\t\tconstmemok = 1;\n@@ -3503,12 +3505,11 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,\n \t\t an early reload pass.  Note that the test here is\n \t\t precisely the same as in the code below that calls\n \t\t force_const_mem.  */\n-\t      if (CONST_POOL_OK_P (operand)\n+\t      if (CONST_POOL_OK_P (operand_mode[i], operand)\n \t\t  && ((targetm.preferred_reload_class (operand,\n \t\t\t\t\t\t       this_alternative[i])\n \t\t       == NO_REGS)\n-\t\t      || no_input_reloads)\n-\t\t  && operand_mode[i] != VOIDmode)\n+\t\t      || no_input_reloads))\n \t\t{\n \t\t  const_to_mem = 1;\n \t\t  if (this_alternative[i] != NO_REGS)\n@@ -3911,11 +3912,10 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,\n \t    op = XEXP (op, 1);\n \t  }\n \n-\tif (CONST_POOL_OK_P (op)\n+\tif (CONST_POOL_OK_P (mode, op)\n \t    && ((targetm.preferred_reload_class (op, goal_alternative[i])\n \t\t == NO_REGS)\n-\t\t|| no_input_reloads)\n-\t    && mode != VOIDmode)\n+\t\t|| no_input_reloads))\n \t  {\n \t    int this_address_reloaded;\n \t    rtx tem = force_const_mem (mode, op);"}, {"sha": "ce01faa92d5f47bba41f887013152847763fa9bb", "filename": "gcc/target.def", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbbf66e77a385fc1901fdc33c1d977681cab39bf/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbbf66e77a385fc1901fdc33c1d977681cab39bf/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=fbbf66e77a385fc1901fdc33c1d977681cab39bf", "patch": "@@ -1295,8 +1295,8 @@ DEFHOOK\n DEFHOOK\n (cannot_force_const_mem,\n  \"\",\n- bool, (rtx x),\n- hook_bool_rtx_false)\n+ bool, (enum machine_mode mode, rtx x),\n+ hook_bool_mode_rtx_false)\n \n DEFHOOK_UNDOC\n (cannot_copy_insn_p,"}, {"sha": "8755dded36e4398f1a4a4283a04a89f592e346e2", "filename": "gcc/varasm.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fbbf66e77a385fc1901fdc33c1d977681cab39bf/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fbbf66e77a385fc1901fdc33c1d977681cab39bf/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=fbbf66e77a385fc1901fdc33c1d977681cab39bf", "patch": "@@ -3476,7 +3476,7 @@ force_const_mem (enum machine_mode mode, rtx x)\n   void **slot;\n \n   /* If we're not allowed to drop X into the constant pool, don't.  */\n-  if (targetm.cannot_force_const_mem (x))\n+  if (targetm.cannot_force_const_mem (mode, x))\n     return NULL_RTX;\n \n   /* Record that this function has used a constant pool entry.  */"}]}