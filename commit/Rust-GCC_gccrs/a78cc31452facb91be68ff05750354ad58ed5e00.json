{"sha": "a78cc31452facb91be68ff05750354ad58ed5e00", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTc4Y2MzMTQ1MmZhY2I5MWJlNjhmZjA1NzUwMzU0YWQ1OGVkNWUwMA==", "commit": {"author": {"name": "Robert Suchanek", "email": "robert.suchanek@imgtec.com", "date": "2014-06-18T20:40:34Z"}, "committer": {"name": "Matthew Fortune", "email": "mpf@gcc.gnu.org", "date": "2014-06-18T20:40:34Z"}, "message": "Enable LRA for MIPS\n\ngcc/\n\n\t* config/mips/constraints.md (\"d\"): BASE_REG_CLASS replaced by\n\t\"TARGET_MIPS16 ? M16_REGS : GR_REGS\".\n\t* config/mips/mips.c (mips_regno_to_class): Update for M16_SP_REGS.\n\t(mips_regno_mode_ok_for_base_p): Remove use of !strict_p for MIPS16.\n\t(mips_register_priority): New function that implements the target\n\thook TARGET_REGISTER_PRIORITY.\n\t(mips_spill_class): Likewise for TARGET_SPILL_CLASS.\n\t(mips_lra_p): Likewise for TARGET_LRA_P.\n\t(TARGET_REGISTER_PRIORITY): Define macro.\n\t(TARGET_SPILL_CLASS): Likewise.\n\t(TARGET_LRA_P): Likewise.\n\t* config/mips/mips.h (reg_class): Add M16_SP_REGS and SPILL_REGS\n\tclasses.\n\t(REG_CLASS_NAMES): Likewise.\n\t(REG_CLASS_CONTENTS): Likewise.\n\t(BASE_REG_CLASS): Use M16_SP_REGS.\n\t* config/mips/mips.md (*mul_acc_si): Add alternative tuned for LRA.\n\tNew set attribute to enable alternatives depending on the register\n\tallocator used.\n\t(*mul_acc_si_r3900, *mul_sub_si): Likewise.\n\t(*lea64): Disable pattern for MIPS16.\n\t* config/mips/mips.opt (mlra): New option.\n\nFrom-SVN: r211805", "tree": {"sha": "e7d67181f5ba9b00489ae4d9406c02a1a047eb29", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e7d67181f5ba9b00489ae4d9406c02a1a047eb29"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a78cc31452facb91be68ff05750354ad58ed5e00", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a78cc31452facb91be68ff05750354ad58ed5e00", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a78cc31452facb91be68ff05750354ad58ed5e00", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a78cc31452facb91be68ff05750354ad58ed5e00/comments", "author": null, "committer": null, "parents": [{"sha": "30256befe1624e056ced732037b85249e9f5badc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30256befe1624e056ced732037b85249e9f5badc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/30256befe1624e056ced732037b85249e9f5badc"}], "stats": {"total": 184, "additions": 142, "deletions": 42}, "files": [{"sha": "9f790251cdcb20d04cf792d92033985e2efa925a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 27, "deletions": 2, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a78cc31452facb91be68ff05750354ad58ed5e00/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a78cc31452facb91be68ff05750354ad58ed5e00/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a78cc31452facb91be68ff05750354ad58ed5e00", "patch": "@@ -1,7 +1,32 @@\n 2014-06-18  Robert Suchanek  <robert.suchanek@imgtec.com>\n \n-\t* lra-constraints.c (base_to_reg): New function.\n-\t(process_address): Use new function.\n+\t* config/mips/constraints.md (\"d\"): BASE_REG_CLASS replaced by\n+\t\"TARGET_MIPS16 ? M16_REGS : GR_REGS\".\n+\t* config/mips/mips.c (mips_regno_to_class): Update for M16_SP_REGS.\n+\t(mips_regno_mode_ok_for_base_p): Remove use of !strict_p for MIPS16.\n+\t(mips_register_priority): New function that implements the target\n+\thook TARGET_REGISTER_PRIORITY.\n+\t(mips_spill_class): Likewise for TARGET_SPILL_CLASS.\n+\t(mips_lra_p): Likewise for TARGET_LRA_P.\n+\t(TARGET_REGISTER_PRIORITY): Define macro.\n+\t(TARGET_SPILL_CLASS): Likewise.\n+\t(TARGET_LRA_P): Likewise.\n+\t* config/mips/mips.h (reg_class): Add M16_SP_REGS and SPILL_REGS\n+\tclasses.\n+\t(REG_CLASS_NAMES): Likewise.\n+\t(REG_CLASS_CONTENTS): Likewise.\n+\t(BASE_REG_CLASS): Use M16_SP_REGS.\n+\t* config/mips/mips.md (*mul_acc_si): Add alternative tuned for LRA.\n+\tNew set attribute to enable alternatives depending on the register\n+\tallocator used.\n+\t(*mul_acc_si_r3900, *mul_sub_si): Likewise.\n+\t(*lea64): Disable pattern for MIPS16.\n+\t* config/mips/mips.opt (mlra): New option.\n+\n+2014-06-18  Robert Suchanek  <robert.suchanek@imgtec.com>\n+\n+\t* lra-constraints.c (base_to_reg): New function.       \n+\t(process_address): Use new function.                   \n \n 2014-06-18  Tom de Vries  <tom@codesourcery.com>\n "}, {"sha": "fa33c305f8a869cd7f5884236517704763641a74", "filename": "gcc/config/mips/constraints.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a78cc31452facb91be68ff05750354ad58ed5e00/gcc%2Fconfig%2Fmips%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a78cc31452facb91be68ff05750354ad58ed5e00/gcc%2Fconfig%2Fmips%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fconstraints.md?ref=a78cc31452facb91be68ff05750354ad58ed5e00", "patch": "@@ -19,7 +19,7 @@\n \n ;; Register constraints\n \n-(define_register_constraint \"d\" \"BASE_REG_CLASS\"\n+(define_register_constraint \"d\" \"TARGET_MIPS16 ? M16_REGS : GR_REGS\"\n   \"An address register.  This is equivalent to @code{r} unless\n    generating MIPS16 code.\")\n "}, {"sha": "1b1633ce046be51d049f743f90514a783a4bc583", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 41, "deletions": 16, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a78cc31452facb91be68ff05750354ad58ed5e00/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a78cc31452facb91be68ff05750354ad58ed5e00/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=a78cc31452facb91be68ff05750354ad58ed5e00", "patch": "@@ -661,7 +661,7 @@ const enum reg_class mips_regno_to_class[FIRST_PSEUDO_REGISTER] = {\n   M16_REGS,        M16_STORE_REGS,  LEA_REGS,        LEA_REGS,\n   LEA_REGS,        LEA_REGS,        LEA_REGS,        LEA_REGS,\n   T_REG,           PIC_FN_ADDR_REG, LEA_REGS,        LEA_REGS,\n-  LEA_REGS,        LEA_REGS,        LEA_REGS,        LEA_REGS,\n+  LEA_REGS,        M16_SP_REGS,     LEA_REGS,        LEA_REGS,\n \n   FP_REGS,\tFP_REGS,\tFP_REGS,\tFP_REGS,\n   FP_REGS,\tFP_REGS,\tFP_REGS,\tFP_REGS,\n@@ -2260,22 +2260,9 @@ mips_regno_mode_ok_for_base_p (int regno, enum machine_mode mode,\n     return true;\n \n   /* In MIPS16 mode, the stack pointer can only address word and doubleword\n-     values, nothing smaller.  There are two problems here:\n-\n-       (a) Instantiating virtual registers can introduce new uses of the\n-\t   stack pointer.  If these virtual registers are valid addresses,\n-\t   the stack pointer should be too.\n-\n-       (b) Most uses of the stack pointer are not made explicit until\n-\t   FRAME_POINTER_REGNUM and ARG_POINTER_REGNUM have been eliminated.\n-\t   We don't know until that stage whether we'll be eliminating to the\n-\t   stack pointer (which needs the restriction) or the hard frame\n-\t   pointer (which doesn't).\n-\n-     All in all, it seems more consistent to only enforce this restriction\n-     during and after reload.  */\n+     values, nothing smaller.  */\n   if (TARGET_MIPS16 && regno == STACK_POINTER_REGNUM)\n-    return !strict_p || GET_MODE_SIZE (mode) == 4 || GET_MODE_SIZE (mode) == 8;\n+    return GET_MODE_SIZE (mode) == 4 || GET_MODE_SIZE (mode) == 8;\n \n   return TARGET_MIPS16 ? M16_REG_P (regno) : GP_REG_P (regno);\n }\n@@ -12100,6 +12087,18 @@ mips_register_move_cost (enum machine_mode mode,\n   return 0;\n }\n \n+/* Implement TARGET_REGISTER_PRIORITY.  */\n+\n+static int\n+mips_register_priority (int hard_regno)\n+{\n+  /* Treat MIPS16 registers with higher priority than other regs.  */\n+  if (TARGET_MIPS16\n+      && TEST_HARD_REG_BIT (reg_class_contents[M16_REGS], hard_regno))\n+    return 1;\n+  return 0;\n+}\n+\n /* Implement TARGET_MEMORY_MOVE_COST.  */\n \n static int\n@@ -18898,6 +18897,25 @@ mips_atomic_assign_expand_fenv (tree *hold, tree *clear, tree *update)\n   *update = build2 (COMPOUND_EXPR, void_type_node, *update,\n \t\t    atomic_feraiseexcept_call);\n }\n+\n+/* Implement TARGET_SPILL_CLASS.  */\n+\n+static reg_class_t\n+mips_spill_class (reg_class_t rclass ATTRIBUTE_UNUSED,\n+\t\t  enum machine_mode mode ATTRIBUTE_UNUSED)\n+{\n+  if (TARGET_MIPS16)\n+    return SPILL_REGS;\n+  return NO_REGS;\n+}\n+\n+/* Implement TARGET_LRA_P.  */\n+\n+static bool\n+mips_lra_p (void)\n+{\n+  return mips_lra_flag;\n+}\n \f\n /* Initialize the GCC target structure.  */\n #undef TARGET_ASM_ALIGNED_HI_OP\n@@ -18961,6 +18979,8 @@ mips_atomic_assign_expand_fenv (tree *hold, tree *clear, tree *update)\n #define TARGET_VALID_POINTER_MODE mips_valid_pointer_mode\n #undef TARGET_REGISTER_MOVE_COST\n #define TARGET_REGISTER_MOVE_COST mips_register_move_cost\n+#undef TARGET_REGISTER_PRIORITY\n+#define TARGET_REGISTER_PRIORITY mips_register_priority\n #undef TARGET_MEMORY_MOVE_COST\n #define TARGET_MEMORY_MOVE_COST mips_memory_move_cost\n #undef TARGET_RTX_COSTS\n@@ -19138,6 +19158,11 @@ mips_atomic_assign_expand_fenv (tree *hold, tree *clear, tree *update)\n #undef TARGET_CALL_FUSAGE_CONTAINS_NON_CALLEE_CLOBBERS\n #define TARGET_CALL_FUSAGE_CONTAINS_NON_CALLEE_CLOBBERS true\n \n+#undef TARGET_SPILL_CLASS\n+#define TARGET_SPILL_CLASS mips_spill_class\n+#undef TARGET_LRA_P\n+#define TARGET_LRA_P mips_lra_p\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n #include \"gt-mips.h\""}, {"sha": "7029e046f9a248a3b18bf15e99a9ddfe3dcc263d", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a78cc31452facb91be68ff05750354ad58ed5e00/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a78cc31452facb91be68ff05750354ad58ed5e00/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=a78cc31452facb91be68ff05750354ad58ed5e00", "patch": "@@ -1869,10 +1869,12 @@ enum reg_class\n   NO_REGS,\t\t\t/* no registers in set */\n   M16_STORE_REGS,\t\t/* microMIPS store registers  */\n   M16_REGS,\t\t\t/* mips16 directly accessible registers */\n+  M16_SP_REGS,\t\t\t/* mips16 + $sp */\n   T_REG,\t\t\t/* mips16 T register ($24) */\n   M16_T_REGS,\t\t\t/* mips16 registers plus T register */\n   PIC_FN_ADDR_REG,\t\t/* SVR4 PIC function address register */\n   V1_REG,\t\t\t/* Register $v1 ($3) used for TLS access.  */\n+  SPILL_REGS,\t\t\t/* All but $sp and call preserved regs are in here */\n   LEA_REGS,\t\t\t/* Every GPR except $25 */\n   GR_REGS,\t\t\t/* integer registers */\n   FP_REGS,\t\t\t/* floating point registers */\n@@ -1907,10 +1909,12 @@ enum reg_class\n   \"NO_REGS\",\t\t\t\t\t\t\t\t\\\n   \"M16_STORE_REGS\",\t\t\t\t\t\t\t\\\n   \"M16_REGS\",\t\t\t\t\t\t\t\t\\\n+  \"M16_SP_REGS\",\t\t\t\t\t\t\t\t\\\n   \"T_REG\",\t\t\t\t\t\t\t\t\\\n   \"M16_T_REGS\",\t\t\t\t\t\t\t\t\\\n   \"PIC_FN_ADDR_REG\",\t\t\t\t\t\t\t\\\n   \"V1_REG\",\t\t\t\t\t\t\t\t\\\n+  \"SPILL_REGS\",\t\t\t\t\t\t\t\t\\\n   \"LEA_REGS\",\t\t\t\t\t\t\t\t\\\n   \"GR_REGS\",\t\t\t\t\t\t\t\t\\\n   \"FP_REGS\",\t\t\t\t\t\t\t\t\\\n@@ -1948,10 +1952,12 @@ enum reg_class\n   { 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000 },\t/* NO_REGS */\t\t\\\n   { 0x000200fc, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000 },\t/* M16_STORE_REGS */\t\\\n   { 0x000300fc, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000 },\t/* M16_REGS */\t\t\\\n+  { 0x200300fc, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000 },\t/* M16_SP_REGS */\t\t\\\n   { 0x01000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000 },\t/* T_REG */\t\t\\\n   { 0x010300fc, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000 },\t/* M16_T_REGS */\t\\\n   { 0x02000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000 },\t/* PIC_FN_ADDR_REG */\t\\\n   { 0x00000008, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000 },\t/* V1_REG */\t\t\\\n+  { 0x0303fffc, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000 },\t/* SPILL_REGS */      \t\\\n   { 0xfdffffff, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000 },\t/* LEA_REGS */\t\t\\\n   { 0xffffffff, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000 },\t/* GR_REGS */\t\t\\\n   { 0x00000000, 0xffffffff, 0x00000000, 0x00000000, 0x00000000, 0x00000000 },\t/* FP_REGS */\t\t\\\n@@ -1984,7 +1990,7 @@ enum reg_class\n    valid base register must belong.  A base register is one used in\n    an address which is the register value plus a displacement.  */\n \n-#define BASE_REG_CLASS  (TARGET_MIPS16 ? M16_REGS : GR_REGS)\n+#define BASE_REG_CLASS  (TARGET_MIPS16 ? M16_SP_REGS : GR_REGS)\n \n /* A macro whose definition is the name of the class to which a\n    valid index register must belong.  An index register is one used"}, {"sha": "7e23bd210660dc3e23f0d1bf71dac23956f7ae8f", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 62, "deletions": 22, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a78cc31452facb91be68ff05750354ad58ed5e00/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a78cc31452facb91be68ff05750354ad58ed5e00/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=a78cc31452facb91be68ff05750354ad58ed5e00", "patch": "@@ -1624,40 +1624,66 @@\n ;; copy instructions.  Reload therefore thinks that the second alternative\n ;; is two reloads more costly than the first.  We add \"*?*?\" to the first\n ;; alternative as a counterweight.\n+;;\n+;; LRA simulates reload but the cost of reloading scratches is lower\n+;; than of the classic reload. For the time being, removing the counterweight\n+;; for LRA is more profitable.\n (define_insn \"*mul_acc_si\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=l*?*?,d?\")\n-\t(plus:SI (mult:SI (match_operand:SI 1 \"register_operand\" \"d,d\")\n-\t\t\t  (match_operand:SI 2 \"register_operand\" \"d,d\"))\n-\t\t (match_operand:SI 3 \"register_operand\" \"0,d\")))\n-   (clobber (match_scratch:SI 4 \"=X,l\"))\n-   (clobber (match_scratch:SI 5 \"=X,&d\"))]\n+  [(set (match_operand:SI 0 \"register_operand\" \"=l*?*?,l,d?\")\n+\t(plus:SI (mult:SI (match_operand:SI 1 \"register_operand\" \"d,d,d\")\n+\t\t\t  (match_operand:SI 2 \"register_operand\" \"d,d,d\"))\n+\t\t (match_operand:SI 3 \"register_operand\" \"0,0,d\")))\n+   (clobber (match_scratch:SI 4 \"=X,X,l\"))\n+   (clobber (match_scratch:SI 5 \"=X,X,&d\"))]\n   \"GENERATE_MADD_MSUB && !TARGET_MIPS16\"\n   \"@\n+    madd\\t%1,%2\n     madd\\t%1,%2\n     #\"\n   [(set_attr \"type\"\t\"imadd\")\n    (set_attr \"accum_in\"\t\"3\")\n    (set_attr \"mode\"\t\"SI\")\n-   (set_attr \"insn_count\" \"1,2\")])\n+   (set_attr \"insn_count\" \"1,1,2\")\n+   (set (attr \"enabled\")\n+        (cond [(and (eq_attr \"alternative\" \"0\")\n+                    (match_test \"!mips_lra_flag\"))\n+                  (const_string \"yes\")\n+               (and (eq_attr \"alternative\" \"1\")\n+                    (match_test \"mips_lra_flag\"))\n+                  (const_string \"yes\")\n+               (eq_attr \"alternative\" \"2\")\n+                  (const_string \"yes\")]\n+              (const_string \"no\")))])\n \n ;; The same idea applies here.  The middle alternative needs one less\n ;; clobber than the final alternative, so we add \"*?\" as a counterweight.\n (define_insn \"*mul_acc_si_r3900\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=l*?*?,d*?,d?\")\n-\t(plus:SI (mult:SI (match_operand:SI 1 \"register_operand\" \"d,d,d\")\n-\t\t\t  (match_operand:SI 2 \"register_operand\" \"d,d,d\"))\n-\t\t (match_operand:SI 3 \"register_operand\" \"0,l,d\")))\n-   (clobber (match_scratch:SI 4 \"=X,3,l\"))\n-   (clobber (match_scratch:SI 5 \"=X,X,&d\"))]\n+  [(set (match_operand:SI 0 \"register_operand\" \"=l*?*?,l,d*?,d?\")\n+\t(plus:SI (mult:SI (match_operand:SI 1 \"register_operand\" \"d,d,d,d\")\n+\t\t\t  (match_operand:SI 2 \"register_operand\" \"d,d,d,d\"))\n+\t\t (match_operand:SI 3 \"register_operand\" \"0,0,l,d\")))\n+   (clobber (match_scratch:SI 4 \"=X,X,3,l\"))\n+   (clobber (match_scratch:SI 5 \"=X,X,X,&d\"))]\n   \"TARGET_MIPS3900 && !TARGET_MIPS16\"\n   \"@\n+    madd\\t%1,%2\n     madd\\t%1,%2\n     madd\\t%0,%1,%2\n     #\"\n   [(set_attr \"type\"\t\"imadd\")\n    (set_attr \"accum_in\"\t\"3\")\n    (set_attr \"mode\"\t\"SI\")\n-   (set_attr \"insn_count\" \"1,1,2\")])\n+   (set_attr \"insn_count\" \"1,1,1,2\")\n+   (set (attr \"enabled\")\n+        (cond [(and (eq_attr \"alternative\" \"0\")\n+                    (match_test \"!mips_lra_flag\"))\n+                  (const_string \"yes\")\n+               (and (eq_attr \"alternative\" \"1\")\n+                    (match_test \"mips_lra_flag\"))\n+                  (const_string \"yes\")\n+               (eq_attr \"alternative\" \"2,3\")\n+                  (const_string \"yes\")]\n+              (const_string \"no\")))])\n \n ;; Split *mul_acc_si if both the source and destination accumulator\n ;; values are GPRs.\n@@ -1861,20 +1887,31 @@\n \n ;; See the comment above *mul_add_si for details.\n (define_insn \"*mul_sub_si\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=l*?*?,d?\")\n-        (minus:SI (match_operand:SI 1 \"register_operand\" \"0,d\")\n-                  (mult:SI (match_operand:SI 2 \"register_operand\" \"d,d\")\n-                           (match_operand:SI 3 \"register_operand\" \"d,d\"))))\n-   (clobber (match_scratch:SI 4 \"=X,l\"))\n-   (clobber (match_scratch:SI 5 \"=X,&d\"))]\n+  [(set (match_operand:SI 0 \"register_operand\" \"=l*?*?,l,d?\")\n+        (minus:SI (match_operand:SI 1 \"register_operand\" \"0,0,d\")\n+                  (mult:SI (match_operand:SI 2 \"register_operand\" \"d,d,d\")\n+                           (match_operand:SI 3 \"register_operand\" \"d,d,d\"))))\n+   (clobber (match_scratch:SI 4 \"=X,X,l\"))\n+   (clobber (match_scratch:SI 5 \"=X,X,&d\"))]\n   \"GENERATE_MADD_MSUB\"\n   \"@\n+   msub\\t%2,%3\n    msub\\t%2,%3\n    #\"\n   [(set_attr \"type\"     \"imadd\")\n    (set_attr \"accum_in\"\t\"1\")\n    (set_attr \"mode\"     \"SI\")\n-   (set_attr \"insn_count\" \"1,2\")])\n+   (set_attr \"insn_count\" \"1,1,2\")\n+   (set (attr \"enabled\")\n+        (cond [(and (eq_attr \"alternative\" \"0\")\n+                    (match_test \"!mips_lra_flag\"))\n+                  (const_string \"yes\")\n+               (and (eq_attr \"alternative\" \"1\")\n+                    (match_test \"mips_lra_flag\"))\n+                  (const_string \"yes\")\n+               (eq_attr \"alternative\" \"2\")\n+                  (const_string \"yes\")]\n+              (const_string \"no\")))])\n \n ;; Split *mul_sub_si if both the source and destination accumulator\n ;; values are GPRs.\n@@ -4141,7 +4178,10 @@\n   [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n \t(match_operand:DI 1 \"absolute_symbolic_operand\" \"\"))\n    (clobber (match_scratch:DI 2 \"=&d\"))]\n-  \"TARGET_EXPLICIT_RELOCS && ABI_HAS_64BIT_SYMBOLS && cse_not_expected\"\n+  \"!TARGET_MIPS16\n+   && TARGET_EXPLICIT_RELOCS\n+   && ABI_HAS_64BIT_SYMBOLS\n+   && cse_not_expected\"\n   \"#\"\n   \"&& reload_completed\"\n   [(set (match_dup 0) (high:DI (match_dup 3)))"}, {"sha": "dca4f8089452a77bef39a5d6944b39dca4dd045b", "filename": "gcc/config/mips/mips.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a78cc31452facb91be68ff05750354ad58ed5e00/gcc%2Fconfig%2Fmips%2Fmips.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a78cc31452facb91be68ff05750354ad58ed5e00/gcc%2Fconfig%2Fmips%2Fmips.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.opt?ref=a78cc31452facb91be68ff05750354ad58ed5e00", "patch": "@@ -380,6 +380,10 @@ msynci\n Target Report Mask(SYNCI)\n Use synci instruction to invalidate i-cache\n \n+mlra\n+Target Report Var(mips_lra_flag) Init(1) Save\n+Use LRA instead of reload\n+\n mtune=\n Target RejectNegative Joined Var(mips_tune_option) ToLower Enum(mips_arch_opt_value)\n -mtune=PROCESSOR\tOptimize the output for PROCESSOR"}]}