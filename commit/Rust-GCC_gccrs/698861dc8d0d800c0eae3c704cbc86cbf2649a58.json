{"sha": "698861dc8d0d800c0eae3c704cbc86cbf2649a58", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Njk4ODYxZGM4ZDBkODAwYzBlYWUzYzcwNGNiYzg2Y2JmMjY0OWE1OA==", "commit": {"author": {"name": "Doug Evans", "email": "dje@google.com", "date": "2009-12-08T07:05:35Z"}, "committer": {"name": "Doug Evans", "email": "devans@gcc.gnu.org", "date": "2009-12-08T07:05:35Z"}, "message": "* pex-unix.c (pex_unix_exec_child): Save/restore environ.\n\nFrom-SVN: r155079", "tree": {"sha": "818366a7b979a3e001dd55453648c8702ad52408", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/818366a7b979a3e001dd55453648c8702ad52408"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/698861dc8d0d800c0eae3c704cbc86cbf2649a58", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/698861dc8d0d800c0eae3c704cbc86cbf2649a58", "html_url": "https://github.com/Rust-GCC/gccrs/commit/698861dc8d0d800c0eae3c704cbc86cbf2649a58", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/698861dc8d0d800c0eae3c704cbc86cbf2649a58/comments", "author": null, "committer": null, "parents": [{"sha": "d16a31da5330efb127280454be7857c3a0c71c8f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d16a31da5330efb127280454be7857c3a0c71c8f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d16a31da5330efb127280454be7857c3a0c71c8f"}], "stats": {"total": 25, "additions": 24, "deletions": 1}, "files": [{"sha": "f8ba8f7909d5ffdfe074b76f8fcf3845fdbe316c", "filename": "libiberty/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/698861dc8d0d800c0eae3c704cbc86cbf2649a58/libiberty%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/698861dc8d0d800c0eae3c704cbc86cbf2649a58/libiberty%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FChangeLog?ref=698861dc8d0d800c0eae3c704cbc86cbf2649a58", "patch": "@@ -1,3 +1,7 @@\n+2009-12-07  Doug Evans  <dje@google.com>\n+\n+\t* pex-unix.c (pex_unix_exec_child): Save/restore environ.\n+\n 2009-11-26  Ben Elliston  <bje@au.ibm.com>\n \n \t* configure.ac (AC_CHECK_FUNCS): Sort into alphabetic order."}, {"sha": "85733a669232975b4e333a27044da0eb64add0f8", "filename": "libiberty/pex-unix.c", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/698861dc8d0d800c0eae3c704cbc86cbf2649a58/libiberty%2Fpex-unix.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/698861dc8d0d800c0eae3c704cbc86cbf2649a58/libiberty%2Fpex-unix.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fpex-unix.c?ref=698861dc8d0d800c0eae3c704cbc86cbf2649a58", "patch": "@@ -400,6 +400,12 @@ pex_unix_exec_child (struct pex_obj *obj, int flags, const char *executable,\n   volatile int sleep_interval;\n   volatile int retries;\n \n+  /* We vfork and then set environ in the child before calling execvp.\n+     This clobbers the parent's environ so we need to restore it.\n+     It would be nice to use one of the exec* functions that takes an\n+     environment as a parameter, but that may have portability issues.  */\n+  char **save_environ = environ;\n+\n   sleep_interval = 1;\n   pid = -1;\n   for (retries = 0; retries < 4; ++retries)\n@@ -453,7 +459,12 @@ pex_unix_exec_child (struct pex_obj *obj, int flags, const char *executable,\n \t}\n \n       if (env)\n-        environ = (char**) env;\n+\t{\n+\t  /* NOTE: In a standard vfork implementation this clobbers the\n+\t     parent's copy of environ \"too\" (in reality there's only one copy).\n+\t     This is ok as we restore it below.  */\n+\t  environ = (char**) env;\n+\t}\n \n       if ((flags & PEX_SEARCH) != 0)\n \t{\n@@ -471,6 +482,14 @@ pex_unix_exec_child (struct pex_obj *obj, int flags, const char *executable,\n \n     default:\n       /* Parent process.  */\n+\n+      /* Restore environ.\n+\t Note that the parent either doesn't run until the child execs/exits\n+\t (standard vfork behaviour), or if it does run then vfork is behaving\n+\t more like fork.  In either case we needn't worry about clobbering\n+\t the child's copy of environ.  */\n+      environ = save_environ;\n+\n       if (in != STDIN_FILE_NO)\n \t{\n \t  if (close (in) < 0)"}]}