{"sha": "3ff688aa8531a38139dc51f9fe87fa6468c8d622", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2ZmNjg4YWE4NTMxYTM4MTM5ZGM1MWY5ZmU4N2ZhNjQ2OGM4ZDYyMg==", "commit": {"author": {"name": "P.J. Darcy", "email": "darcypj@us.ibm.com", "date": "2004-10-02T00:47:06Z"}, "committer": {"name": "Ulrich Weigand", "email": "uweigand@gcc.gnu.org", "date": "2004-10-02T00:47:06Z"}, "message": "t-tpf (LIB2ADDEH): Remove tpf-eh.c.\n\n2004-10-02  P.J. Darcy  <darcypj@us.ibm.com>\n\n\t* config/s390/t-tpf (LIB2ADDEH): Remove tpf-eh.c.\n\t* config/s390/tpf-eh.c: Remove file.\n\t* config/s390/tpf-unwind.h: New file.\n\t* config/s390/tpf.h (MD_FALLBACK_FRAME_STATE_FOR): Remove.\n\t(MD_UNWIND_SUPPORT): Define.\n\nFrom-SVN: r88417", "tree": {"sha": "0528edfb76bd5d66aa36a09cd75155677817feb3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0528edfb76bd5d66aa36a09cd75155677817feb3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3ff688aa8531a38139dc51f9fe87fa6468c8d622", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ff688aa8531a38139dc51f9fe87fa6468c8d622", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3ff688aa8531a38139dc51f9fe87fa6468c8d622", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ff688aa8531a38139dc51f9fe87fa6468c8d622/comments", "author": null, "committer": null, "parents": [{"sha": "62bea9efc89efb00ca123b95c3be61cb8ee37de4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62bea9efc89efb00ca123b95c3be61cb8ee37de4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/62bea9efc89efb00ca123b95c3be61cb8ee37de4"}], "stats": {"total": 236, "additions": 124, "deletions": 112}, "files": [{"sha": "8e4f0fc128f69ec7c75e6b9ee8f11fb9e80d798e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ff688aa8531a38139dc51f9fe87fa6468c8d622/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ff688aa8531a38139dc51f9fe87fa6468c8d622/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3ff688aa8531a38139dc51f9fe87fa6468c8d622", "patch": "@@ -1,3 +1,11 @@\n+2004-10-02  P.J. Darcy  <darcypj@us.ibm.com>\n+\n+\t* config/s390/t-tpf (LIB2ADDEH): Remove tpf-eh.c.\n+\t* config/s390/tpf-eh.c: Remove file.\n+\t* config/s390/tpf-unwind.h: New file.\n+\t* config/s390/tpf.h (MD_FALLBACK_FRAME_STATE_FOR): Remove.\n+\t(MD_UNWIND_SUPPORT): Define.\n+\n 2004-10-02  Joseph S. Myers  <jsm@polyomino.org.uk>\n \n \t* c-typeck.c (warn_for_assignment): Don't permit argnum == 0."}, {"sha": "3cf0146c84aff4f94e11f02416a63bb5c36057ff", "filename": "gcc/config/s390/t-tpf", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ff688aa8531a38139dc51f9fe87fa6468c8d622/gcc%2Fconfig%2Fs390%2Ft-tpf", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ff688aa8531a38139dc51f9fe87fa6468c8d622/gcc%2Fconfig%2Fs390%2Ft-tpf", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Ft-tpf?ref=3ff688aa8531a38139dc51f9fe87fa6468c8d622", "patch": "@@ -7,8 +7,7 @@ TARGET_LIBGCC2_CFLAGS = -fPIC\n # the symbol versions that glibc used.\n SHLIB_MAPFILES += $(srcdir)/config/s390/libgcc-glibc.ver\n \n-# Use unwind-dw2-fde and extra tpf-eh support routines.\n+# Use unwind-dw2-fde.\n LIB2ADDEH = $(srcdir)/unwind-dw2.c $(srcdir)/unwind-dw2-fde.c \\\n-  $(srcdir)/unwind-sjlj.c $(srcdir)/gthr-gnat.c $(srcdir)/unwind-c.c \\\n-  $(srcdir)/config/s390/tpf-eh.c\n+  $(srcdir)/unwind-sjlj.c $(srcdir)/gthr-gnat.c $(srcdir)/unwind-c.c\n LIB2ADDEHDEP = unwind.inc unwind-dw2-fde.h"}, {"sha": "6f2ccd9ec603dd88efc6c109b5a2bb21a4ae17fb", "filename": "gcc/config/s390/tpf-unwind.h", "status": "renamed", "additions": 113, "deletions": 39, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ff688aa8531a38139dc51f9fe87fa6468c8d622/gcc%2Fconfig%2Fs390%2Ftpf-unwind.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ff688aa8531a38139dc51f9fe87fa6468c8d622/gcc%2Fconfig%2Fs390%2Ftpf-unwind.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Ftpf-unwind.h?ref=3ff688aa8531a38139dc51f9fe87fa6468c8d622", "patch": "@@ -1,77 +1,150 @@\n-/* Exception handling routines for TPF.\n+/* DWARF2 EH unwinding support for TPF OS.\n    Copyright (C) 2004 Free Software Foundation, Inc.\n    Contributed by P.J. Darcy (darcypj@us.ibm.com).\n \n-   This file is part of GCC.\n+This file is part of GCC.\n \n-   GCC is free software; you can redistribute it and/or modify it\n-   under the terms of the GNU General Public License as published by\n-   the Free Software Foundation; either version 2, or (at your option)\n-   any later version.\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n \n-   In addition to the permissions in the GNU General Public License, the\n-   Free Software Foundation gives you unlimited permission to link the\n-   compiled version of this file into combinations with other programs,\n-   and to distribute those combinations without any restriction coming\n-   from the use of this file.  (The General Public License restrictions\n-   do apply in other respects; for example, they cover modification of\n-   the file, and distribution when not linked into a combined\n-   executable.)\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combined\n+executable.)\n \n-   GCC is distributed in the hope that it will be useful, but WITHOUT\n-   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n-   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n-   License for more details.\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n \n-   You should have received a copy of the GNU General Public License\n-   along with GCC; see the file COPYING.  If not, write to the Free\n-   Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n-   02111-1307, USA.  */\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+02111-1307, USA.  */\n \n #define __USE_GNU 1\n #define _GNU_SOURCE\n #include <dlfcn.h>\n #undef __USE_GNU\n #undef _GNU_SOURCE\n \n-#define CURRENT_STACK_PTR() \\\n-  ({ register unsigned long int *stack_ptr asm (\"%r15\"); stack_ptr; })\n-\n-#define PREVIOUS_STACK_PTR() \\\n-  ((unsigned long int *)(*(CURRENT_STACK_PTR())))\n-\n-#define RA_OFFSET_FROM_START_OF_STACK_FRAME 112\n-#define CURRENT_STACK_PTR_OFFSET 120\n-#define TPFRA_OFFSET_FROM_START_OF_STACK_FRAME 168\n-#define MIN_PATRANGE 0x10000\n-#define MAX_PATRANGE 0x800000\n-#define INVALID_RETURN 0\n-\n /* Function Name: __isPATrange\n    Parameters passed into it:  address to check\n    Return Value: A 1 if address is in pat code \"range\", 0 if not\n    Description: This function simply checks to see if the address\n    passed to it is in the CP pat code range.  */\n \n-unsigned int __isPATrange(void *addr) \n+#define MIN_PATRANGE 0x10000\n+#define MAX_PATRANGE 0x800000\n+\n+static inline unsigned int\n+__isPATrange (void *addr)\n {\n   if (addr > (void *)MIN_PATRANGE && addr < (void *)MAX_PATRANGE)\n     return 1;\n   else\n     return 0;\n }\n \n+/* TPF stack placeholder offset.  */\n+#define TPF_LOC_DIFF_OFFSET 168\n+\n+/* Exceptions macro defined for TPF so that functions without \n+   dwarf frame information can be used with exceptions.  */\n+#define MD_FALLBACK_FRAME_STATE_FOR s390_fallback_frame_state\n+\n+static _Unwind_Reason_Code\n+s390_fallback_frame_state (struct _Unwind_Context *context,\n+\t\t\t   _Unwind_FrameState *fs)\n+{\n+  unsigned long int regs;\n+  unsigned long int new_cfa;\n+  int i;\n+\n+  if (context->cfa == NULL)\n+    return _URC_END_OF_STACK;\n+\n+  /* Are we going through special linkage code?  */\n+  if (__isPATrange (context->ra))\n+    {\n+      /* No stack frame.  */\n+      fs->cfa_how = CFA_REG_OFFSET;\n+      fs->cfa_reg = 15;\n+      fs->cfa_offset = STACK_POINTER_OFFSET;\n+\n+      /* All registers remain unchanged ...  */\n+      for (i = 0; i < 32; i++)\n+\t{\n+\t  fs->regs.reg[i].how = REG_SAVED_REG;\n+\t  fs->regs.reg[i].loc.reg = i;\n+\t}\n+\n+      /* ... except for %r14, which is stored at CFA-112\n+\t and used as return address.  */\n+      fs->regs.reg[14].how = REG_SAVED_OFFSET;\n+      fs->regs.reg[14].loc.offset = TPF_LOC_DIFF_OFFSET - STACK_POINTER_OFFSET;\n+      fs->retaddr_column = 14;\n+\n+      return _URC_NO_REASON;\n+    }\n+\n+  regs = *((unsigned long int *)\n+        (((unsigned long int) context->cfa) - STACK_POINTER_OFFSET));\n+  new_cfa = regs + STACK_POINTER_OFFSET;\n+\n+  fs->cfa_how = CFA_REG_OFFSET;\n+  fs->cfa_reg = 15;\n+  fs->cfa_offset = new_cfa -\n+        (unsigned long int) context->cfa + STACK_POINTER_OFFSET;\n+\n+  for (i = 0; i < 16; i++)\n+    {\n+      fs->regs.reg[i].how = REG_SAVED_OFFSET;\n+      fs->regs.reg[i].loc.offset = regs + i*8 - new_cfa;\n+    }\n+\n+  for (i = 0; i < 4; i++)\n+    {\n+      fs->regs.reg[16 + i].how = REG_SAVED_OFFSET;\n+      fs->regs.reg[16 + i].loc.offset = regs + 16*8 + i*8 - new_cfa;\n+    }\n+\n+  fs->retaddr_column = 14;\n+\n+  return _URC_NO_REASON;\n+}\n+\n /* Function Name: __tpf_eh_return\n    Parameters passed into it: Destination address to jump to.\n    Return Value: Converted Destination address if a Pat Stub exists.\n-   Description: This function swaps the unwinding return address\n+   Description: This function swaps the uwinding return address\n       with the cp stub code.  The original target return address is\n       then stored into the tpf return address field.  The cp stub\n       code is searched for by climbing back up the stack and\n       comparing the tpf stored return address object address to\n       that of the targets object address.  */\n \n-void *__tpf_eh_return (void *target) \n+#define CURRENT_STACK_PTR() \\\n+  ({ register unsigned long int *stack_ptr asm (\"%r15\"); stack_ptr; })\n+\n+#define PREVIOUS_STACK_PTR() \\\n+  ((unsigned long int *)(*(CURRENT_STACK_PTR())))\n+\n+#define RA_OFFSET_FROM_START_OF_STACK_FRAME 112\n+#define CURRENT_STACK_PTR_OFFSET 120\n+#define TPFRA_OFFSET_FROM_START_OF_STACK_FRAME 168\n+#define INVALID_RETURN 0\n+\n+void * __tpf_eh_return (void *target);\n+\n+void *\n+__tpf_eh_return (void *target)\n {\n   Dl_info targetcodeInfo, currentcodeInfo;\n   int retval;\n@@ -158,7 +231,7 @@ void *__tpf_eh_return (void *target)\n                      the exception handling unwinder so that it can \n                      actually do the \"leap\" shift out the low order \n                      bit designated to determine if we are in 64BIT mode.\n-                     This is necessary for CTOA stubs.\n+                     This is nececcary for CTOA stubs.\n                      Otherwise we leap one byte past where we want to \n                      go to in the TPF pat stub linkage code.  */\n                   shifter = *((unsigned long int *) \n@@ -181,3 +254,4 @@ void *__tpf_eh_return (void *target)\n   return target;\n }\n \n+", "previous_filename": "gcc/config/s390/tpf-eh.c"}, {"sha": "8ba13e2541239e6c4ed2de3992390fe94ba94708", "filename": "gcc/config/s390/tpf.h", "status": "modified", "additions": 1, "deletions": 70, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ff688aa8531a38139dc51f9fe87fa6468c8d622/gcc%2Fconfig%2Fs390%2Ftpf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ff688aa8531a38139dc51f9fe87fa6468c8d622/gcc%2Fconfig%2Fs390%2Ftpf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Ftpf.h?ref=3ff688aa8531a38139dc51f9fe87fa6468c8d622", "patch": "@@ -53,9 +53,6 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n /* TPF OS specific stack-pointer offset.  */\n #undef STACK_POINTER_OFFSET\n #define STACK_POINTER_OFFSET \t\t448\n-/* TPF stack placeholder offset.  */\n-#undef TPF_LOC_DIFF_OFFSET\n-#define TPF_LOC_DIFF_OFFSET             168\n \n /* When building for TPF, set a generic default target that is 64 bits.  */\n #undef TARGET_DEFAULT\n@@ -119,73 +116,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n         %{rdynamic:-export-dynamic} \\\n         %{!dynamic-linker:-dynamic-linker /lib/ld64.so}}}\"\n \n-extern unsigned int __isPATrange (void *);\n-\n-/* Exceptions macro defined for TPF so that functions without \n-   dwarf frame information can be used with exceptions.  */\n-#define MD_FALLBACK_FRAME_STATE_FOR(CONTEXT, FS, SUCCESS)               \\\n-  do                                                                    \\\n-    {                                                                   \\\n-      unsigned long int regs_;                                          \\\n-      unsigned long int new_cfa_;                                       \\\n-      int i_;                                                           \\\n-                                                                        \\\n-      if ((CONTEXT)->cfa == NULL)                                       \\\n-        goto SUCCESS;                                                   \\\n-                                                                        \\\n-      /* Are we going through special linkage code?  */                 \\\n-      if (__isPATrange((CONTEXT)->ra))                                  \\\n-        {                                                               \\\n-          /* No stack frame.   */                                       \\\n-          (FS)->cfa_how = CFA_REG_OFFSET;                               \\\n-          (FS)->cfa_reg = 15;                                           \\\n-          (FS)->cfa_offset = STACK_POINTER_OFFSET;                      \\\n-                                                                        \\\n-          /* All registers remain unchanged ...  */                     \\\n-          for (i_ = 0; i_ < 32; i_++)                                   \\\n-            {                                                           \\\n-              (FS)->regs.reg[i_].how = REG_SAVED_REG;                   \\\n-              (FS)->regs.reg[i_].loc.reg = i_;                          \\\n-            }                                                           \\\n-                                                                        \\\n-          /* ... except for %r14, which is stored at CFA-112            \\\n-             and used as return address.  */                            \\\n-          (FS)->regs.reg[14].how = REG_SAVED_OFFSET;                    \\\n-          (FS)->regs.reg[14].loc.offset =                               \\\n-            TPF_LOC_DIFF_OFFSET - STACK_POINTER_OFFSET;                 \\\n-          (FS)->retaddr_column = 14;                                    \\\n-                                                                        \\\n-          goto SUCCESS;                                                 \\\n-                                                                        \\\n-        }                                                               \\\n-                                                                        \\\n-      regs_ = *((unsigned long int *)                                   \\\n-        (((unsigned long int) (CONTEXT)->cfa) - STACK_POINTER_OFFSET)); \\\n-      new_cfa_ = regs_ + STACK_POINTER_OFFSET;                          \\\n-      (FS)->cfa_how = CFA_REG_OFFSET;                                   \\\n-      (FS)->cfa_reg = 15;                                               \\\n-      (FS)->cfa_offset = new_cfa_ -                                     \\\n-        (unsigned long int) (CONTEXT)->cfa + STACK_POINTER_OFFSET;      \\\n-                                                                        \\\n-      for (i_ = 0; i_ < 16; i_++)                                       \\\n-        {                                                               \\\n-          (FS)->regs.reg[i_].how = REG_SAVED_OFFSET;                    \\\n-          (FS)->regs.reg[i_].loc.offset =                               \\\n-            (regs_+(i_*8)) - new_cfa_;                                  \\\n-        }                                                               \\\n-                                                                        \\\n-      for (i_ = 0; i_ < 4; i_++)                                        \\\n-        {                                                               \\\n-          (FS)->regs.reg[16+i_].how = REG_SAVED_OFFSET;                 \\\n-          (FS)->regs.reg[16+i_].loc.offset =                            \\\n-            (regs_+(16*8)+(i_*8)) - new_cfa_;                           \\\n-        }                                                               \\\n-                                                                        \\\n-      (FS)->retaddr_column = 14;                                        \\\n-                                                                        \\\n-      goto SUCCESS;                                                     \\\n-                                                                        \\\n-    } while (0)\n+#define MD_UNWIND_SUPPORT \"config/s390/tpf-unwind.h\"\n \n #endif /* ! _TPF_H */\n "}]}