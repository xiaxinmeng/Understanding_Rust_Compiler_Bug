{"sha": "4797a61cc5024fc9adf5918e9bb2b78988f9e4d4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDc5N2E2MWNjNTAyNGZjOWFkZjU5MThlOWJiMmI3ODk4OGY5ZTRkNA==", "commit": {"author": {"name": "Fran\u00e7ois Dumont", "email": "fdumont@gcc.gnu.org", "date": "2020-01-20T07:21:10Z"}, "committer": {"name": "Fran\u00e7ois Dumont", "email": "fdumont@gcc.gnu.org", "date": "2020-08-26T05:58:46Z"}, "message": "libstdc++: Rename _Hashtable _H1, _H2 and _Hash template parameters\n\nLimit our _Hashtable implementation to ranged hash. _H1 is now rename\nto _Hash matching the _Hash functor used for unordered containers. _H2\nis now renamed to _RangeHash. Former _Hash simply becomes _Unused. Remove\n_ExtractKey storage.\n\nlibstdc++-v3/ChangeLog:\n\n\t* include/bits/hashtable_policy.h (_Hashtable<>): Rename _H1 into _Hash\n\t_H2 into _RangeHash and _Hash into _Unused.\n\t(_Hastable_base<>): Likewise.\n\t(_Map_base<>): Likewise.\n\t(_Insert_base<>): Likewise.\n\t(_Insert<>): Likewise.\n\t(_Rehash_base<>): Likewise.\n\t(_Local_iterator_base<>): Likewise.\n\t(_Hash_code_base<>): Likewise.\n\t(_Hash_code_base<_Key, _Value, _ExtractKey, _H1, _H2, _Hash, false>):\n\tRemove.\n\t(_Hash_code_base<_Key, _Value, _ExtractKey, _H1, _H2, _Hash, true>):\n\tRemove.\n\t(_Hash_code_base<_Key, _Value, _ExtractKey, _Hash, _RangeHas, _Unused,\n\tbool>): Remove _Hashtable_ebo_helper<2, _RangeHash> base type..\n\t(_Hash_code_base<>::_M_bucket_index(const _Key&, __hash_code, size_t)):\n\tReplace by...\n\t(_Hash_code_base<>::_M_bucket_index(__hash_code, size_t)): ...this.\n\t(_Local_iterator<>): Remove _H1 and _H2 template parameters.\n\t(_Local_const_iterator<>): Likewise.\n\t(_Equality<>): Likewise.\n\t(_Map_base<>::operator[](const key_type&): Adapt.\n\t(_Map_base<>::operator[](key_type&&): Adapt.\n\t(_Identity::operator()): Add noexcept.\n\t(_Select1st::operator()): Likewise.\n\t(_Hash_code_base<>): Remove _Hashtable_ebo_helper<0, _ExtractKey> base\n\ttype.\n\t(_Hash_code_base::_M_extract): Remove.\n\t* include/bits/hashtable.h (_Hashtable<>): Remove _H1 and _H2 template\n\tparameters. Remove _ExtractKey from constructors.\n\t(_Hashtable<>::_M_insert_unique_node(const key_type&, size_t,\n\t__hash_code, __node_type*, size_t)): Replace by...\n\t(_Hashtable<>::_M_insert_unique_node(size_t, __hash_code,\n\t __node_type*, size_t)): ...this.\n\t(_Hashtable<>::_M_insert_muti_node(__node_type*, const key_type&,\n\t__hash_code, __node_type*)): Replace by...\n\t(_Hashtable<>::_M_insert_multi_node(__node_type*, __hash_code,\n\t__node_type*)): ...this.\n\t(_Hashtable<>::__key_extract): Remove.\n\t* include/bits/node_handle.h: Adapt.", "tree": {"sha": "fa2619258ebc5abd290e97f6683aecfe5a58d2ac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fa2619258ebc5abd290e97f6683aecfe5a58d2ac"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4797a61cc5024fc9adf5918e9bb2b78988f9e4d4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4797a61cc5024fc9adf5918e9bb2b78988f9e4d4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4797a61cc5024fc9adf5918e9bb2b78988f9e4d4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4797a61cc5024fc9adf5918e9bb2b78988f9e4d4/comments", "author": null, "committer": null, "parents": [{"sha": "55290635d10ea3d18b0a45aa2e6f59405b8c1f54", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/55290635d10ea3d18b0a45aa2e6f59405b8c1f54", "html_url": "https://github.com/Rust-GCC/gccrs/commit/55290635d10ea3d18b0a45aa2e6f59405b8c1f54"}], "stats": {"total": 1164, "additions": 510, "deletions": 654}, "files": [{"sha": "07a4abe5c334064155fe68caac9150e6c9620c89", "filename": "libstdc++-v3/include/bits/hashtable.h", "status": "modified", "additions": 330, "deletions": 362, "changes": 692, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4797a61cc5024fc9adf5918e9bb2b78988f9e4d4/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4797a61cc5024fc9adf5918e9bb2b78988f9e4d4/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h?ref=4797a61cc5024fc9adf5918e9bb2b78988f9e4d4", "patch": "@@ -69,31 +69,26 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n    *  and returns a bool-like value that is true if the two objects\n    *  are considered equal.\n    *\n-   *  @tparam _H1  The hash function. A unary function object with\n+   *  @tparam _Hash  The hash function. A unary function object with\n    *  argument type _Key and result type size_t. Return values should\n    *  be distributed over the entire range [0, numeric_limits<size_t>:::max()].\n    *\n-   *  @tparam _H2  The range-hashing function (in the terminology of\n+   *  @tparam _RangeHash  The range-hashing function (in the terminology of\n    *  Tavori and Dreizin).  A binary function object whose argument\n    *  types and result type are all size_t.  Given arguments r and N,\n    *  the return value is in the range [0, N).\n    *\n-   *  @tparam _Hash  The ranged hash function (Tavori and Dreizin). A\n-   *  binary function whose argument types are _Key and size_t and\n-   *  whose result type is size_t.  Given arguments k and N, the\n-   *  return value is in the range [0, N).  Default: hash(k, N) =\n-   *  h2(h1(k), N).  If _Hash is anything other than the default, _H1\n-   *  and _H2 are ignored.\n+   *  @tparam _Unused  Not used.\n    *\n    *  @tparam _RehashPolicy  Policy class with three members, all of\n    *  which govern the bucket count. _M_next_bkt(n) returns a bucket\n    *  count no smaller than n.  _M_bkt_for_elements(n) returns a\n    *  bucket count appropriate for an element count of n.\n    *  _M_need_rehash(n_bkt, n_elt, n_ins) determines whether, if the\n    *  current bucket count is n_bkt and the current element count is\n-   *  n_elt, we need to increase the bucket count.  If so, returns\n-   *  make_pair(true, n), where n is the new bucket count.  If not,\n-   *  returns make_pair(false, <anything>)\n+   *  n_elt, we need to increase the bucket count for n_ins insertions.\n+   *  If so, returns make_pair(true, n), where n is the new bucket count. If\n+   *  not, returns make_pair(false, <anything>)\n    *\n    *  @tparam _Traits  Compile-time class with three boolean\n    *  std::integral_constant members:  __cache_hash_code, __constant_iterators,\n@@ -168,19 +163,23 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n    */\n   template<typename _Key, typename _Value, typename _Alloc,\n \t   typename _ExtractKey, typename _Equal,\n-\t   typename _H1, typename _H2, typename _Hash,\n+\t   typename _Hash, typename _RangeHash, typename _Unused,\n \t   typename _RehashPolicy, typename _Traits>\n     class _Hashtable\n     : public __detail::_Hashtable_base<_Key, _Value, _ExtractKey, _Equal,\n-\t\t\t\t       _H1, _H2, _Hash, _Traits>,\n+\t\t\t\t       _Hash, _RangeHash, _Unused, _Traits>,\n       public __detail::_Map_base<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n-\t\t\t\t _H1, _H2, _Hash, _RehashPolicy, _Traits>,\n+\t\t\t\t _Hash, _RangeHash, _Unused,\n+\t\t\t\t _RehashPolicy, _Traits>,\n       public __detail::_Insert<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n-\t\t\t       _H1, _H2, _Hash, _RehashPolicy, _Traits>,\n+\t\t\t       _Hash, _RangeHash, _Unused,\n+\t\t\t       _RehashPolicy, _Traits>,\n       public __detail::_Rehash_base<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n-\t\t\t\t    _H1, _H2, _Hash, _RehashPolicy, _Traits>,\n+\t\t\t\t    _Hash, _RangeHash, _Unused,\n+\t\t\t\t    _RehashPolicy, _Traits>,\n       public __detail::_Equality<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n-\t\t\t\t _H1, _H2, _Hash, _RehashPolicy, _Traits>,\n+\t\t\t\t _Hash, _RangeHash, _Unused,\n+\t\t\t\t _RehashPolicy, _Traits>,\n       private __detail::_Hashtable_alloc<\n \t__alloc_rebind<_Alloc,\n \t\t       __detail::_Hash_node<_Value,\n@@ -227,30 +226,25 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       using __constant_iterators = typename __traits_type::__constant_iterators;\n       using __unique_keys = typename __traits_type::__unique_keys;\n \n-      using __key_extract = typename std::conditional<\n-\t\t\t\t\t     __constant_iterators::value,\n-\t\t\t\t       \t     __detail::_Identity,\n-\t\t\t\t\t     __detail::_Select1st>::type;\n-\n       using __hashtable_base = __detail::\n-\t\t\t       _Hashtable_base<_Key, _Value, _ExtractKey,\n-\t\t\t\t\t      _Equal, _H1, _H2, _Hash, _Traits>;\n+\t_Hashtable_base<_Key, _Value, _ExtractKey,\n+\t\t\t_Equal, _Hash, _RangeHash, _Unused, _Traits>;\n \n       using __hash_code_base =  typename __hashtable_base::__hash_code_base;\n       using __hash_code =  typename __hashtable_base::__hash_code;\n       using __ireturn_type = typename __hashtable_base::__ireturn_type;\n \n       using __map_base = __detail::_Map_base<_Key, _Value, _Alloc, _ExtractKey,\n-\t\t\t\t\t     _Equal, _H1, _H2, _Hash,\n+\t\t\t\t\t     _Equal, _Hash, _RangeHash, _Unused,\n \t\t\t\t\t     _RehashPolicy, _Traits>;\n \n       using __rehash_base = __detail::_Rehash_base<_Key, _Value, _Alloc,\n \t\t\t\t\t\t   _ExtractKey, _Equal,\n-\t\t\t\t\t\t   _H1, _H2, _Hash,\n+\t\t\t\t\t\t   _Hash, _RangeHash, _Unused,\n \t\t\t\t\t\t   _RehashPolicy, _Traits>;\n \n       using __eq_base = __detail::_Equality<_Key, _Value, _Alloc, _ExtractKey,\n-\t\t\t\t\t    _Equal, _H1, _H2, _Hash,\n+\t\t\t\t\t    _Equal, _Hash, _RangeHash, _Unused,\n \t\t\t\t\t    _RehashPolicy, _Traits>;\n \n       using __reuse_or_alloc_node_gen_t =\n@@ -289,13 +283,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t__fwd_value_for(value_type& __val) noexcept\n \t{ return std::move(__val); }\n \n-      // Metaprogramming for picking apart hash caching.\n-      template<typename _Cond>\n-\tusing __if_hash_cached = __or_<__not_<__hash_cached>, _Cond>;\n-\n-      template<typename _Cond>\n-\tusing __if_hash_not_cached = __or_<__hash_cached, _Cond>;\n-\n       // Compile-time diagnostics.\n \n       // _Hash_code_base has everything protected, so use this derived type to\n@@ -311,35 +298,45 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\t    \"Cache the hash code or qualify your functors involved\"\n \t\t    \" in hash code and bucket index computation with noexcept\");\n \n-      // When hash codes are cached local iterator inherits from H2 functor\n-      // which must then be default constructible.\n-      static_assert(__if_hash_cached<is_default_constructible<_H2>>::value,\n+      // To get bucket index we need _RangeHash not to throw.\n+      static_assert(is_nothrow_default_constructible<_RangeHash>::value,\n \t\t    \"Functor used to map hash code to bucket index\"\n-\t\t    \" must be default constructible\");\n+\t\t    \" must be nothrow default constructible\");\n+      static_assert(noexcept(\n+\tstd::declval<const _RangeHash&>()((std::size_t)0, (std::size_t)0)),\n+\t\t    \"Functor used to map hash code to bucket index must be\"\n+\t\t    \" noexcept\");\n+\n+      // To compute bucket index we also need _ExtratKey not to throw.\n+      static_assert(is_nothrow_default_constructible<_ExtractKey>::value,\n+\t\t    \"_ExtractKey must be nothrow default constructible\");\n+      static_assert(noexcept(\n+\tstd::declval<const _ExtractKey&>()(std::declval<_Value>())),\n+\t\t    \"_ExtractKey functor must be noexcept invocable\");\n \n       template<typename _Keya, typename _Valuea, typename _Alloca,\n \t       typename _ExtractKeya, typename _Equala,\n-\t       typename _H1a, typename _H2a, typename _Hasha,\n+\t       typename _Hasha, typename _RangeHasha, typename _Unuseda,\n \t       typename _RehashPolicya, typename _Traitsa,\n \t       bool _Unique_keysa>\n \tfriend struct __detail::_Map_base;\n \n       template<typename _Keya, typename _Valuea, typename _Alloca,\n \t       typename _ExtractKeya, typename _Equala,\n-\t       typename _H1a, typename _H2a, typename _Hasha,\n+\t       typename _Hasha, typename _RangeHasha, typename _Unuseda,\n \t       typename _RehashPolicya, typename _Traitsa>\n \tfriend struct __detail::_Insert_base;\n \n       template<typename _Keya, typename _Valuea, typename _Alloca,\n \t       typename _ExtractKeya, typename _Equala,\n-\t       typename _H1a, typename _H2a, typename _Hasha,\n+\t       typename _Hasha, typename _RangeHasha, typename _Unuseda,\n \t       typename _RehashPolicya, typename _Traitsa,\n \t       bool _Constant_iteratorsa>\n \tfriend struct __detail::_Insert;\n \n       template<typename _Keya, typename _Valuea, typename _Alloca,\n \t       typename _ExtractKeya, typename _Equala,\n-\t       typename _H1a, typename _H2a, typename _Hasha,\n+\t       typename _Hasha, typename _RangeHasha, typename _Unuseda,\n \t       typename _RehashPolicya, typename _Traitsa,\n \t       bool _Unique_keysa>\n \tfriend struct __detail::_Equality;\n@@ -453,16 +450,15 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       void\n       _M_reset() noexcept;\n \n-      _Hashtable(const _H1& __h1, const _H2& __h2, const _Hash& __h,\n-\t\t const _Equal& __eq, const _ExtractKey& __exk,\n+      _Hashtable(const _Hash& __h, const _Equal& __eq,\n \t\t const allocator_type& __a)\n-      : __hashtable_base(__exk, __h1, __h2, __h, __eq),\n+      : __hashtable_base(__h, __eq),\n \t__hashtable_alloc(__node_alloc_type(__a))\n       { }\n \n       _Hashtable(_Hashtable&& __ht, __node_alloc_type&& __a,\n \t\t true_type /* alloc always equal */)\n-\tnoexcept(std::is_nothrow_copy_constructible<_H1>::value &&\n+\tnoexcept(std::is_nothrow_copy_constructible<_Hash>::value &&\n \t\t std::is_nothrow_copy_constructible<_Equal>::value);\n \n       _Hashtable(_Hashtable&&, __node_alloc_type&&,\n@@ -471,29 +467,30 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       template<typename _InputIterator>\n \t_Hashtable(_InputIterator __first, _InputIterator __last,\n \t\t   size_type __bkt_count_hint,\n-\t\t   const _H1&, const _H2&, const _Hash&,\n-\t\t   const _Equal&, const _ExtractKey&,\n-\t\t   const allocator_type&,\n+\t\t   const _Hash&, const _Equal&, const allocator_type&,\n \t\t   true_type __uks);\n \n       template<typename _InputIterator>\n \t_Hashtable(_InputIterator __first, _InputIterator __last,\n \t\t   size_type __bkt_count_hint,\n-\t\t   const _H1&, const _H2&, const _Hash&,\n-\t\t   const _Equal&, const _ExtractKey&,\n-\t\t   const allocator_type&,\n+\t\t   const _Hash&, const _Equal&, const allocator_type&,\n \t\t   false_type __uks);\n \n     public:\n       // Constructor, destructor, assignment, swap\n       _Hashtable() = default;\n-      _Hashtable(size_type __bkt_count_hint,\n-\t\t const _H1&, const _H2&, const _Hash&,\n-\t\t const _Equal&, const _ExtractKey&,\n-\t\t const allocator_type&);\n \n       _Hashtable(const _Hashtable&);\n \n+      _Hashtable(const _Hashtable&, const allocator_type&);\n+\n+      explicit\n+      _Hashtable(size_type __bkt_count_hint,\n+\t\t const _Hash& __hf = _Hash(),\n+\t\t const key_equal& __eql = key_equal(),\n+\t\t const allocator_type& __a = allocator_type());\n+\n+      // Use delegating constructors.\n       _Hashtable(_Hashtable&& __ht)\n \tnoexcept( noexcept(\n \t  _Hashtable(std::declval<_Hashtable>(),\n@@ -503,8 +500,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\t   true_type{})\n       { }\n \n-      _Hashtable(const _Hashtable&, const allocator_type&);\n-\n       _Hashtable(_Hashtable&& __ht, const allocator_type& __a)\n \tnoexcept( noexcept(\n \t  _Hashtable(std::declval<_Hashtable>(),\n@@ -514,49 +509,28 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\t   typename __node_alloc_traits::is_always_equal{})\n       { }\n \n-      // Use delegating constructors.\n-      template<typename _InputIterator>\n-\t_Hashtable(_InputIterator __first, _InputIterator __last,\n-\t\t   size_type __bkt_count_hint,\n-\t\t   const _H1& __h1, const _H2& __h2, const _Hash& __h,\n-\t\t   const _Equal& __eq, const _ExtractKey& __exk,\n-\t\t   const allocator_type& __a)\n-\t: _Hashtable(__first, __last, __bkt_count_hint,\n-\t\t     __h1, __h2, __h, __eq, __exk, __a, __unique_keys{})\n-\t{ }\n-\n       explicit\n       _Hashtable(const allocator_type& __a)\n       : __hashtable_alloc(__node_alloc_type(__a))\n       { }\n \n-      explicit\n-      _Hashtable(size_type __bkt_count_hint,\n-\t\t const _H1& __hf = _H1(),\n-\t\t const key_equal& __eql = key_equal(),\n-\t\t const allocator_type& __a = allocator_type())\n-      : _Hashtable(__bkt_count_hint, __hf, _H2(), _Hash(), __eql,\n-\t\t   __key_extract(), __a)\n-      { }\n-\n       template<typename _InputIterator>\n \t_Hashtable(_InputIterator __f, _InputIterator __l,\n \t\t   size_type __bkt_count_hint = 0,\n-\t\t   const _H1& __hf = _H1(),\n+\t\t   const _Hash& __hf = _Hash(),\n \t\t   const key_equal& __eql = key_equal(),\n \t\t   const allocator_type& __a = allocator_type())\n-\t: _Hashtable(__f, __l, __bkt_count_hint, __hf, _H2(), _Hash(), __eql,\n-\t\t     __key_extract(), __a)\n+\t: _Hashtable(__f, __l, __bkt_count_hint, __hf, __eql, __a,\n+\t\t     __unique_keys{})\n \t{ }\n \n       _Hashtable(initializer_list<value_type> __l,\n \t\t size_type __bkt_count_hint = 0,\n-\t\t const _H1& __hf = _H1(),\n+\t\t const _Hash& __hf = _Hash(),\n \t\t const key_equal& __eql = key_equal(),\n \t\t const allocator_type& __a = allocator_type())\n       : _Hashtable(__l.begin(), __l.end(), __bkt_count_hint,\n-\t\t   __hf, _H2(), _Hash(), __eql,\n-\t\t   __key_extract(), __a)\n+\t\t   __hf, __eql, __a, __unique_keys{})\n       { }\n \n       _Hashtable&\n@@ -565,10 +539,10 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       _Hashtable&\n       operator=(_Hashtable&& __ht)\n       noexcept(__node_alloc_traits::_S_nothrow_move()\n-\t       && is_nothrow_move_assignable<_H1>::value\n+\t       && is_nothrow_move_assignable<_Hash>::value\n \t       && is_nothrow_move_assignable<_Equal>::value)\n       {\n-        constexpr bool __move_storage =\n+\tconstexpr bool __move_storage =\n \t  __node_alloc_traits::_S_propagate_on_move_assign()\n \t  || __node_alloc_traits::_S_always_equal();\n \t_M_move_assign(std::move(__ht), __bool_constant<__move_storage>());\n@@ -597,8 +571,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n       void\n       swap(_Hashtable&)\n-      noexcept(__and_<__is_nothrow_swappable<_H1>,\n-\t                  __is_nothrow_swappable<_Equal>>::value);\n+      noexcept(__and_<__is_nothrow_swappable<_Hash>,\n+\t\t      __is_nothrow_swappable<_Equal>>::value);\n \n       // Basic container operations\n       iterator\n@@ -663,7 +637,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n       size_type\n       bucket(const key_type& __k) const\n-      { return _M_bucket_index(__k, this->_M_hash_code(__k)); }\n+      { return _M_bucket_index(this->_M_hash_code(__k)); }\n \n       local_iterator\n       begin(size_type __bkt)\n@@ -741,8 +715,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       { return __hash_code_base::_M_bucket_index(__n, _M_bucket_count); }\n \n       size_type\n-      _M_bucket_index(const key_type& __k, __hash_code __c) const\n-      { return __hash_code_base::_M_bucket_index(__k, __c, _M_bucket_count); }\n+      _M_bucket_index(__hash_code __c) const\n+      { return __hash_code_base::_M_bucket_index(__c, _M_bucket_count); }\n \n       // Find and insert helper functions and types\n       // Find the node before the one matching the criteria.\n@@ -772,28 +746,27 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       __node_base*\n       _M_get_previous_node(size_type __bkt, __node_base* __n);\n \n-      // Insert node __n with key __k and hash code __code, in bucket __bkt\n-      // if no rehash (assumes no element with same key already present).\n+      // Insert node __n with hash code __code, in bucket __bkt if no\n+      // rehash (assumes no element with same key already present).\n       // Takes ownership of __n if insertion succeeds, throws otherwise.\n       iterator\n-      _M_insert_unique_node(const key_type& __k, size_type __bkt,\n-\t\t\t    __hash_code __code, __node_type* __n,\n-\t\t\t    size_type __n_elt = 1);\n+      _M_insert_unique_node(size_type __bkt, __hash_code,\n+\t\t\t    __node_type* __n, size_type __n_elt = 1);\n \n       // Insert node __n with key __k and hash code __code.\n       // Takes ownership of __n if insertion succeeds, throws otherwise.\n       iterator\n-      _M_insert_multi_node(__node_type* __hint, const key_type& __k,\n+      _M_insert_multi_node(__node_type* __hint,\n \t\t\t   __hash_code __code, __node_type* __n);\n \n       template<typename... _Args>\n \tstd::pair<iterator, bool>\n-\t_M_emplace(true_type, _Args&&... __args);\n+\t_M_emplace(true_type __uks, _Args&&... __args);\n \n       template<typename... _Args>\n \titerator\n-\t_M_emplace(false_type __uk, _Args&&... __args)\n-\t{ return _M_emplace(cend(), __uk, std::forward<_Args>(__args)...); }\n+\t_M_emplace(false_type __uks, _Args&&... __args)\n+\t{ return _M_emplace(cend(), __uks, std::forward<_Args>(__args)...); }\n \n       // Emplace with hint, useless when keys are unique.\n       template<typename... _Args>\n@@ -835,10 +808,10 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\t  const _NodeGenerator&, false_type __uks);\n \n       size_type\n-      _M_erase(true_type, const key_type&);\n+      _M_erase(true_type __uks, const key_type&);\n \n       size_type\n-      _M_erase(false_type, const key_type&);\n+      _M_erase(false_type __uks, const key_type&);\n \n       iterator\n       _M_erase(size_type __bkt, __node_base* __prev_n, __node_type* __n);\n@@ -848,13 +821,13 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       template<typename... _Args>\n \t__ireturn_type\n \templace(_Args&&... __args)\n-\t{ return _M_emplace(__unique_keys(), std::forward<_Args>(__args)...); }\n+\t{ return _M_emplace(__unique_keys{}, std::forward<_Args>(__args)...); }\n \n       template<typename... _Args>\n \titerator\n \templace_hint(const_iterator __hint, _Args&&... __args)\n \t{\n-\t  return _M_emplace(__hint, __unique_keys(),\n+\t  return _M_emplace(__hint, __unique_keys{},\n \t\t\t    std::forward<_Args>(__args)...);\n \t}\n \n@@ -871,7 +844,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n       size_type\n       erase(const key_type& __k)\n-      { return _M_erase(__unique_keys(), __k); }\n+      { return _M_erase(__unique_keys{}, __k); }\n \n       iterator\n       erase(const_iterator, const_iterator);\n@@ -900,7 +873,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n \t    const key_type& __k = __nh._M_key();\n \t    __hash_code __code = this->_M_hash_code(__k);\n-\t    size_type __bkt = _M_bucket_index(__k, __code);\n+\t    size_type __bkt = _M_bucket_index(__code);\n \t    if (__node_type* __n = _M_find_node(__bkt, __k, __code))\n \t      {\n \t\t__ret.node = std::move(__nh);\n@@ -910,7 +883,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t    else\n \t      {\n \t\t__ret.position\n-\t\t  = _M_insert_unique_node(__k, __bkt, __code, __nh._M_ptr);\n+\t\t  = _M_insert_unique_node(__bkt, __code, __nh._M_ptr);\n \t\t__nh._M_ptr = nullptr;\n \t\t__ret.inserted = true;\n \t      }\n@@ -930,7 +903,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \tconst key_type& __k = __nh._M_key();\n \tauto __code = this->_M_hash_code(__k);\n \tauto __ret\n-\t  = _M_insert_multi_node(__hint._M_cur, __k, __code, __nh._M_ptr);\n+\t  = _M_insert_multi_node(__hint._M_cur, __code, __nh._M_ptr);\n \t__nh._M_ptr = nullptr;\n \treturn __ret;\n       }\n@@ -972,7 +945,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       {\n \tnode_type __nh;\n \t__hash_code __code = this->_M_hash_code(__k);\n-\tstd::size_t __bkt = _M_bucket_index(__k, __code);\n+\tstd::size_t __bkt = _M_bucket_index(__code);\n \tif (__node_base* __prev_node = _M_find_before_node(__bkt, __k, __code))\n \t  __nh = _M_extract_node(__bkt, __prev_node);\n \treturn __nh;\n@@ -991,14 +964,13 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  for (auto __i = __src.begin(), __end = __src.end(); __i != __end;)\n \t    {\n \t      auto __pos = __i++;\n-\t      const key_type& __k = this->_M_extract()(*__pos);\n+\t      const key_type& __k = _ExtractKey{}(*__pos);\n \t      __hash_code __code = this->_M_hash_code(__k);\n-\t      size_type __bkt = _M_bucket_index(__k, __code);\n+\t      size_type __bkt = _M_bucket_index(__code);\n \t      if (_M_find_node(__bkt, __k, __code) == nullptr)\n \t\t{\n \t\t  auto __nh = __src.extract(__pos);\n-\t\t  _M_insert_unique_node(__k, __bkt, __code, __nh._M_ptr,\n-\t\t\t\t\t__n_elt);\n+\t\t  _M_insert_unique_node(__bkt, __code, __nh._M_ptr, __n_elt);\n \t\t  __nh._M_ptr = nullptr;\n \t\t  __n_elt = 1;\n \t\t}\n@@ -1024,10 +996,10 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n     private:\n       // Helper rehash method used when keys are unique.\n-      void _M_rehash_aux(size_type __bkt_count, true_type);\n+      void _M_rehash_aux(size_type __bkt_count, true_type __uks);\n \n       // Helper rehash method used when keys can be non-unique.\n-      void _M_rehash_aux(size_type __bkt_count, false_type);\n+      void _M_rehash_aux(size_type __bkt_count, false_type __uks);\n \n       // Unconditionally change size of bucket array to n, restore\n       // hash policy state to __state on exception.\n@@ -1036,31 +1008,29 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n \n   // Definitions of class template _Hashtable's out-of-line member functions.\n-  template<typename _Key, typename _Value,\n-\t   typename _Alloc, typename _ExtractKey, typename _Equal,\n-\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n-\t   typename _Traits>\n+  template<typename _Key, typename _Value, typename _Alloc,\n+\t   typename _ExtractKey, typename _Equal,\n+\t   typename _Hash, typename _RangeHash, typename _Unused,\n+\t   typename _RehashPolicy, typename _Traits>\n     auto\n     _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n-\t       _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n+\t       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::\n     _M_bucket_begin(size_type __bkt) const\n     -> __node_type*\n     {\n       __node_base* __n = _M_buckets[__bkt];\n       return __n ? static_cast<__node_type*>(__n->_M_nxt) : nullptr;\n     }\n \n-  template<typename _Key, typename _Value,\n-\t   typename _Alloc, typename _ExtractKey, typename _Equal,\n-\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n-\t   typename _Traits>\n+  template<typename _Key, typename _Value, typename _Alloc,\n+\t   typename _ExtractKey, typename _Equal,\n+\t   typename _Hash, typename _RangeHash, typename _Unused,\n+\t   typename _RehashPolicy, typename _Traits>\n     _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n-\t       _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n+\t       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::\n     _Hashtable(size_type __bkt_count_hint,\n-\t       const _H1& __h1, const _H2& __h2, const _Hash& __h,\n-\t       const _Equal& __eq, const _ExtractKey& __exk,\n-\t       const allocator_type& __a)\n-    : _Hashtable(__h1, __h2, __h, __eq, __exk, __a)\n+\t       const _Hash& __h, const _Equal& __eq, const allocator_type& __a)\n+    : _Hashtable(__h, __eq, __a)\n     {\n       auto __bkt_count = _M_rehash_policy._M_next_bkt(__bkt_count_hint);\n       if (__bkt_count > _M_bucket_count)\n@@ -1070,37 +1040,35 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t}\n     }\n \n-  template<typename _Key, typename _Value,\n-\t   typename _Alloc, typename _ExtractKey, typename _Equal,\n-\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n-\t   typename _Traits>\n+  template<typename _Key, typename _Value, typename _Alloc,\n+\t   typename _ExtractKey, typename _Equal,\n+\t   typename _Hash, typename _RangeHash, typename _Unused,\n+\t   typename _RehashPolicy, typename _Traits>\n     template<typename _InputIterator>\n       _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n-\t\t _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n+\t\t _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::\n       _Hashtable(_InputIterator __f, _InputIterator __l,\n \t\t size_type __bkt_count_hint,\n-\t\t const _H1& __h1, const _H2& __h2, const _Hash& __h,\n-\t\t const _Equal& __eq, const _ExtractKey& __exk,\n+\t\t const _Hash& __h, const _Equal& __eq,\n \t\t const allocator_type& __a, true_type /* __uks */)\n-      : _Hashtable(__bkt_count_hint, __h1, __h2, __h, __eq, __exk, __a)\n+      : _Hashtable(__bkt_count_hint, __h, __eq, __a)\n       {\n \tfor (; __f != __l; ++__f)\n \t  this->insert(*__f);\n       }\n \n-  template<typename _Key, typename _Value,\n-\t   typename _Alloc, typename _ExtractKey, typename _Equal,\n-\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n-\t   typename _Traits>\n+  template<typename _Key, typename _Value, typename _Alloc,\n+\t   typename _ExtractKey, typename _Equal,\n+\t   typename _Hash, typename _RangeHash, typename _Unused,\n+\t   typename _RehashPolicy, typename _Traits>\n     template<typename _InputIterator>\n       _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n-\t\t _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n+\t\t _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::\n       _Hashtable(_InputIterator __f, _InputIterator __l,\n \t\t size_type __bkt_count_hint,\n-\t\t const _H1& __h1, const _H2& __h2, const _Hash& __h,\n-\t\t const _Equal& __eq, const _ExtractKey& __exk,\n+\t\t const _Hash& __h, const _Equal& __eq,\n \t\t const allocator_type& __a, false_type /* __uks */)\n-      : _Hashtable(__h1, __h2, __h, __eq, __exk, __a)\n+      : _Hashtable(__h, __eq, __a)\n       {\n \tauto __nb_elems = __detail::__distance_fw(__f, __l);\n \tauto __bkt_count =\n@@ -1118,13 +1086,13 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  this->insert(*__f);\n       }\n \n-  template<typename _Key, typename _Value,\n-\t   typename _Alloc, typename _ExtractKey, typename _Equal,\n-\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n-\t   typename _Traits>\n+  template<typename _Key, typename _Value, typename _Alloc,\n+\t   typename _ExtractKey, typename _Equal,\n+\t   typename _Hash, typename _RangeHash, typename _Unused,\n+\t   typename _RehashPolicy, typename _Traits>\n     auto\n     _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n-\t       _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n+\t       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::\n     operator=(const _Hashtable& __ht)\n     -> _Hashtable&\n     {\n@@ -1170,14 +1138,14 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       return *this;\n     }\n \n-  template<typename _Key, typename _Value,\n-\t   typename _Alloc, typename _ExtractKey, typename _Equal,\n-\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n-\t   typename _Traits>\n+  template<typename _Key, typename _Value, typename _Alloc,\n+\t   typename _ExtractKey, typename _Equal,\n+\t   typename _Hash, typename _RangeHash, typename _Unused,\n+\t   typename _RehashPolicy, typename _Traits>\n     template<typename _Ht>\n       void\n       _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n-\t\t _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n+\t\t _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::\n       _M_assign_elements(_Ht&& __ht)\n       {\n \t__bucket_type* __former_buckets = nullptr;\n@@ -1221,14 +1189,14 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  }\n       }\n \n-  template<typename _Key, typename _Value,\n-\t   typename _Alloc, typename _ExtractKey, typename _Equal,\n-\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n-\t   typename _Traits>\n+  template<typename _Key, typename _Value, typename _Alloc,\n+\t   typename _ExtractKey, typename _Equal,\n+\t   typename _Hash, typename _RangeHash, typename _Unused,\n+\t   typename _RehashPolicy, typename _Traits>\n     template<typename _Ht, typename _NodeGenerator>\n       void\n       _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n-\t\t _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n+\t\t _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::\n       _M_assign(_Ht&& __ht, const _NodeGenerator& __node_gen)\n       {\n \t__bucket_type* __buckets = nullptr;\n@@ -1270,13 +1238,13 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  }\n       }\n \n-  template<typename _Key, typename _Value,\n-\t   typename _Alloc, typename _ExtractKey, typename _Equal,\n-\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n-\t   typename _Traits>\n+  template<typename _Key, typename _Value, typename _Alloc,\n+\t   typename _ExtractKey, typename _Equal,\n+\t   typename _Hash, typename _RangeHash, typename _Unused,\n+\t   typename _RehashPolicy, typename _Traits>\n     void\n     _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n-\t       _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n+\t       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::\n     _M_reset() noexcept\n     {\n       _M_rehash_policy._M_reset();\n@@ -1287,13 +1255,13 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       _M_element_count = 0;\n     }\n \n-  template<typename _Key, typename _Value,\n-\t   typename _Alloc, typename _ExtractKey, typename _Equal,\n-\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n-\t   typename _Traits>\n+  template<typename _Key, typename _Value, typename _Alloc,\n+\t   typename _ExtractKey, typename _Equal,\n+\t   typename _Hash, typename _RangeHash, typename _Unused,\n+\t   typename _RehashPolicy, typename _Traits>\n     void\n     _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n-\t       _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n+\t       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::\n     _M_move_assign(_Hashtable&& __ht, true_type)\n     {\n       if (__builtin_expect(std::__addressof(__ht) == this, false))\n@@ -1321,17 +1289,17 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       __ht._M_reset();\n     }\n \n-  template<typename _Key, typename _Value,\n-\t   typename _Alloc, typename _ExtractKey, typename _Equal,\n-\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n-\t   typename _Traits>\n+  template<typename _Key, typename _Value, typename _Alloc,\n+\t   typename _ExtractKey, typename _Equal,\n+\t   typename _Hash, typename _RangeHash, typename _Unused,\n+\t   typename _RehashPolicy, typename _Traits>\n     void\n     _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n-\t       _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n+\t       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::\n     _M_move_assign(_Hashtable&& __ht, false_type)\n     {\n       if (__ht._M_node_allocator() == this->_M_node_allocator())\n-\t_M_move_assign(std::move(__ht), true_type());\n+\t_M_move_assign(std::move(__ht), true_type{});\n       else\n \t{\n \t  // Can't move memory, move elements then.\n@@ -1340,12 +1308,12 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t}\n     }\n \n-  template<typename _Key, typename _Value,\n-\t   typename _Alloc, typename _ExtractKey, typename _Equal,\n-\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n-\t   typename _Traits>\n+  template<typename _Key, typename _Value, typename _Alloc,\n+\t   typename _ExtractKey, typename _Equal,\n+\t   typename _Hash, typename _RangeHash, typename _Unused,\n+\t   typename _RehashPolicy, typename _Traits>\n     _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n-\t       _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n+\t       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::\n     _Hashtable(const _Hashtable& __ht)\n     : __hashtable_base(__ht),\n       __map_base(__ht),\n@@ -1361,15 +1329,15 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       _M_assign(__ht, __alloc_node_gen);\n     }\n \n-  template<typename _Key, typename _Value,\n-\t   typename _Alloc, typename _ExtractKey, typename _Equal,\n-\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n-\t   typename _Traits>\n+  template<typename _Key, typename _Value, typename _Alloc,\n+\t   typename _ExtractKey, typename _Equal,\n+\t   typename _Hash, typename _RangeHash, typename _Unused,\n+\t   typename _RehashPolicy, typename _Traits>\n     _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n-\t       _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n+\t       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::\n     _Hashtable(_Hashtable&& __ht, __node_alloc_type&& __a,\n \t       true_type /* alloc always equal */)\n-    noexcept(std::is_nothrow_copy_constructible<_H1>::value &&\n+    noexcept(std::is_nothrow_copy_constructible<_Hash>::value &&\n \t     std::is_nothrow_copy_constructible<_Equal>::value)\n     : __hashtable_base(__ht),\n       __map_base(__ht),\n@@ -1394,12 +1362,12 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       __ht._M_reset();\n     }\n \n-  template<typename _Key, typename _Value,\n-\t   typename _Alloc, typename _ExtractKey, typename _Equal,\n-\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n-\t   typename _Traits>\n+  template<typename _Key, typename _Value, typename _Alloc,\n+\t   typename _ExtractKey, typename _Equal,\n+\t   typename _Hash, typename _RangeHash, typename _Unused,\n+\t   typename _RehashPolicy, typename _Traits>\n     _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n-\t       _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n+\t       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::\n     _Hashtable(const _Hashtable& __ht, const allocator_type& __a)\n     : __hashtable_base(__ht),\n       __map_base(__ht),\n@@ -1414,12 +1382,12 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       _M_assign(__ht, __alloc_node_gen);\n     }\n \n-  template<typename _Key, typename _Value,\n-\t   typename _Alloc, typename _ExtractKey, typename _Equal,\n-\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n-\t   typename _Traits>\n+  template<typename _Key, typename _Value, typename _Alloc,\n+\t   typename _ExtractKey, typename _Equal,\n+\t   typename _Hash, typename _RangeHash, typename _Unused,\n+\t   typename _RehashPolicy, typename _Traits>\n     _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n-\t       _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n+\t       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::\n     _Hashtable(_Hashtable&& __ht, __node_alloc_type&& __a,\n \t       false_type /* alloc always equal */)\n     : __hashtable_base(__ht),\n@@ -1459,28 +1427,28 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t}\n     }\n \n-  template<typename _Key, typename _Value,\n-\t   typename _Alloc, typename _ExtractKey, typename _Equal,\n-\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n-\t   typename _Traits>\n+  template<typename _Key, typename _Value, typename _Alloc,\n+\t   typename _ExtractKey, typename _Equal,\n+\t   typename _Hash, typename _RangeHash, typename _Unused,\n+\t   typename _RehashPolicy, typename _Traits>\n     _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n-\t       _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n+\t       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::\n     ~_Hashtable() noexcept\n     {\n       clear();\n       _M_deallocate_buckets();\n     }\n \n-  template<typename _Key, typename _Value,\n-\t   typename _Alloc, typename _ExtractKey, typename _Equal,\n-\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n-\t   typename _Traits>\n+  template<typename _Key, typename _Value, typename _Alloc,\n+\t   typename _ExtractKey, typename _Equal,\n+\t   typename _Hash, typename _RangeHash, typename _Unused,\n+\t   typename _RehashPolicy, typename _Traits>\n     void\n     _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n-\t       _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n+\t       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::\n     swap(_Hashtable& __x)\n-    noexcept(__and_<__is_nothrow_swappable<_H1>,\n-\t                __is_nothrow_swappable<_Equal>>::value)\n+    noexcept(__and_<__is_nothrow_swappable<_Hash>,\n+\t\t\t__is_nothrow_swappable<_Equal>>::value)\n     {\n       // The only base class with member variables is hash_code_base.\n       // We define _Hash_code_base::_M_swap because different\n@@ -1518,43 +1486,43 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       __x._M_update_bbegin();\n     }\n \n-  template<typename _Key, typename _Value,\n-\t   typename _Alloc, typename _ExtractKey, typename _Equal,\n-\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n-\t   typename _Traits>\n+  template<typename _Key, typename _Value, typename _Alloc,\n+\t   typename _ExtractKey, typename _Equal,\n+\t   typename _Hash, typename _RangeHash, typename _Unused,\n+\t   typename _RehashPolicy, typename _Traits>\n     auto\n     _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n-\t       _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n+\t       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::\n     find(const key_type& __k)\n     -> iterator\n     {\n       __hash_code __code = this->_M_hash_code(__k);\n-      std::size_t __bkt = _M_bucket_index(__k, __code);\n+      std::size_t __bkt = _M_bucket_index(__code);\n       return iterator(_M_find_node(__bkt, __k, __code));\n     }\n \n-  template<typename _Key, typename _Value,\n-\t   typename _Alloc, typename _ExtractKey, typename _Equal,\n-\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n-\t   typename _Traits>\n+  template<typename _Key, typename _Value, typename _Alloc,\n+\t   typename _ExtractKey, typename _Equal,\n+\t   typename _Hash, typename _RangeHash, typename _Unused,\n+\t   typename _RehashPolicy, typename _Traits>\n     auto\n     _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n-\t       _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n+\t       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::\n     find(const key_type& __k) const\n     -> const_iterator\n     {\n       __hash_code __code = this->_M_hash_code(__k);\n-      std::size_t __bkt = _M_bucket_index(__k, __code);\n+      std::size_t __bkt = _M_bucket_index(__code);\n       return const_iterator(_M_find_node(__bkt, __k, __code));\n     }\n \n-  template<typename _Key, typename _Value,\n-\t   typename _Alloc, typename _ExtractKey, typename _Equal,\n-\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n-\t   typename _Traits>\n+  template<typename _Key, typename _Value, typename _Alloc,\n+\t   typename _ExtractKey, typename _Equal,\n+\t   typename _Hash, typename _RangeHash, typename _Unused,\n+\t   typename _RehashPolicy, typename _Traits>\n     auto\n     _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n-\t       _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n+\t       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::\n     count(const key_type& __k) const\n     -> size_type\n     {\n@@ -1577,13 +1545,13 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       return __result;\n     }\n \n-  template<typename _Key, typename _Value,\n-\t   typename _Alloc, typename _ExtractKey, typename _Equal,\n-\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n-\t   typename _Traits>\n+  template<typename _Key, typename _Value, typename _Alloc,\n+\t   typename _ExtractKey, typename _Equal,\n+\t   typename _Hash, typename _RangeHash, typename _Unused,\n+\t   typename _RehashPolicy, typename _Traits>\n     auto\n     _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n-\t       _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n+\t       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::\n     equal_range(const key_type& __k)\n     -> pair<iterator, iterator>\n     {\n@@ -1604,13 +1572,13 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       return { __beg, __ite };\n     }\n \n-  template<typename _Key, typename _Value,\n-\t   typename _Alloc, typename _ExtractKey, typename _Equal,\n-\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n-\t   typename _Traits>\n+  template<typename _Key, typename _Value, typename _Alloc,\n+\t   typename _ExtractKey, typename _Equal,\n+\t   typename _Hash, typename _RangeHash, typename _Unused,\n+\t   typename _RehashPolicy, typename _Traits>\n     auto\n     _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n-\t       _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n+\t       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::\n     equal_range(const key_type& __k) const\n     -> pair<const_iterator, const_iterator>\n     {\n@@ -1633,13 +1601,13 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n   // Find the node before the one whose key compares equal to k in the bucket\n   // bkt. Return nullptr if no node is found.\n-  template<typename _Key, typename _Value,\n-\t   typename _Alloc, typename _ExtractKey, typename _Equal,\n-\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n-\t   typename _Traits>\n+  template<typename _Key, typename _Value, typename _Alloc,\n+\t   typename _ExtractKey, typename _Equal,\n+\t   typename _Hash, typename _RangeHash, typename _Unused,\n+\t   typename _RehashPolicy, typename _Traits>\n     auto\n     _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n-\t       _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n+\t       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::\n     _M_find_before_node(size_type __bkt, const key_type& __k,\n \t\t\t__hash_code __code) const\n     -> __node_base*\n@@ -1662,13 +1630,13 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       return nullptr;\n     }\n \n-  template<typename _Key, typename _Value,\n-\t   typename _Alloc, typename _ExtractKey, typename _Equal,\n-\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n-\t   typename _Traits>\n+  template<typename _Key, typename _Value, typename _Alloc,\n+\t   typename _ExtractKey, typename _Equal,\n+\t   typename _Hash, typename _RangeHash, typename _Unused,\n+\t   typename _RehashPolicy, typename _Traits>\n     void\n     _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n-\t       _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n+\t       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::\n     _M_insert_bucket_begin(size_type __bkt, __node_type* __node)\n     {\n       if (_M_buckets[__bkt])\n@@ -1695,13 +1663,13 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t}\n     }\n \n-  template<typename _Key, typename _Value,\n-\t   typename _Alloc, typename _ExtractKey, typename _Equal,\n-\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n-\t   typename _Traits>\n+  template<typename _Key, typename _Value, typename _Alloc,\n+\t   typename _ExtractKey, typename _Equal,\n+\t   typename _Hash, typename _RangeHash, typename _Unused,\n+\t   typename _RehashPolicy, typename _Traits>\n     void\n     _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n-\t       _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n+\t       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::\n     _M_remove_bucket_begin(size_type __bkt, __node_type* __next,\n \t\t\t   size_type __next_bkt)\n     {\n@@ -1719,13 +1687,13 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t}\n     }\n \n-  template<typename _Key, typename _Value,\n-\t   typename _Alloc, typename _ExtractKey, typename _Equal,\n-\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n-\t   typename _Traits>\n+  template<typename _Key, typename _Value, typename _Alloc,\n+\t   typename _ExtractKey, typename _Equal,\n+\t   typename _Hash, typename _RangeHash, typename _Unused,\n+\t   typename _RehashPolicy, typename _Traits>\n     auto\n     _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n-\t       _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n+\t       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::\n     _M_get_previous_node(size_type __bkt, __node_base* __n)\n     -> __node_base*\n     {\n@@ -1735,64 +1703,64 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       return __prev_n;\n     }\n \n-  template<typename _Key, typename _Value,\n-\t   typename _Alloc, typename _ExtractKey, typename _Equal,\n-\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n-\t   typename _Traits>\n+  template<typename _Key, typename _Value, typename _Alloc,\n+\t   typename _ExtractKey, typename _Equal,\n+\t   typename _Hash, typename _RangeHash, typename _Unused,\n+\t   typename _RehashPolicy, typename _Traits>\n     template<typename... _Args>\n       auto\n       _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n-\t\t _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n-      _M_emplace(true_type, _Args&&... __args)\n+\t\t _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::\n+      _M_emplace(true_type /* __uks */, _Args&&... __args)\n       -> pair<iterator, bool>\n       {\n \t// First build the node to get access to the hash code\n \t_Scoped_node __node { this, std::forward<_Args>(__args)...  };\n-\tconst key_type& __k = this->_M_extract()(__node._M_node->_M_v());\n+\tconst key_type& __k = _ExtractKey{}(__node._M_node->_M_v());\n \t__hash_code __code = this->_M_hash_code(__k);\n-\tsize_type __bkt = _M_bucket_index(__k, __code);\n+\tsize_type __bkt = _M_bucket_index(__code);\n \tif (__node_type* __p = _M_find_node(__bkt, __k, __code))\n \t  // There is already an equivalent node, no insertion\n \t  return std::make_pair(iterator(__p), false);\n \n \t// Insert the node\n-\tauto __pos = _M_insert_unique_node(__k, __bkt, __code, __node._M_node);\n+\tauto __pos = _M_insert_unique_node(__bkt, __code, __node._M_node);\n \t__node._M_node = nullptr;\n \treturn { __pos, true };\n       }\n \n-  template<typename _Key, typename _Value,\n-\t   typename _Alloc, typename _ExtractKey, typename _Equal,\n-\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n-\t   typename _Traits>\n+  template<typename _Key, typename _Value, typename _Alloc,\n+\t   typename _ExtractKey, typename _Equal,\n+\t   typename _Hash, typename _RangeHash, typename _Unused,\n+\t   typename _RehashPolicy, typename _Traits>\n     template<typename... _Args>\n       auto\n       _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n-\t\t _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n-      _M_emplace(const_iterator __hint, false_type, _Args&&... __args)\n+\t\t _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::\n+      _M_emplace(const_iterator __hint, false_type /* __uks */,\n+\t\t _Args&&... __args)\n       -> iterator\n       {\n \t// First build the node to get its hash code.\n \t_Scoped_node __node { this, std::forward<_Args>(__args)...  };\n-\tconst key_type& __k = this->_M_extract()(__node._M_node->_M_v());\n+\tconst key_type& __k = _ExtractKey{}(__node._M_node->_M_v());\n \n \t__hash_code __code = this->_M_hash_code(__k);\n \tauto __pos\n-\t  = _M_insert_multi_node(__hint._M_cur, __k, __code, __node._M_node);\n+\t  = _M_insert_multi_node(__hint._M_cur, __code, __node._M_node);\n \t__node._M_node = nullptr;\n \treturn __pos;\n       }\n \n-  template<typename _Key, typename _Value,\n-\t   typename _Alloc, typename _ExtractKey, typename _Equal,\n-\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n-\t   typename _Traits>\n+  template<typename _Key, typename _Value, typename _Alloc,\n+\t   typename _ExtractKey, typename _Equal,\n+\t   typename _Hash, typename _RangeHash, typename _Unused,\n+\t   typename _RehashPolicy, typename _Traits>\n     auto\n     _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n-\t       _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n-    _M_insert_unique_node(const key_type& __k, size_type __bkt,\n-\t\t\t  __hash_code __code, __node_type* __node,\n-\t\t\t  size_type __n_elt)\n+\t       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::\n+    _M_insert_unique_node(size_type __bkt, __hash_code __code,\n+\t\t\t  __node_type* __node, size_type __n_elt)\n     -> iterator\n     {\n       const __rehash_state& __saved_state = _M_rehash_policy._M_state();\n@@ -1803,7 +1771,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       if (__do_rehash.first)\n \t{\n \t  _M_rehash(__do_rehash.second, __saved_state);\n-\t  __bkt = _M_bucket_index(__k, __code);\n+\t  __bkt = _M_bucket_index(__code);\n \t}\n \n       this->_M_store_code(__node, __code);\n@@ -1814,14 +1782,14 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       return iterator(__node);\n     }\n \n-  template<typename _Key, typename _Value,\n-\t   typename _Alloc, typename _ExtractKey, typename _Equal,\n-\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n-\t   typename _Traits>\n+  template<typename _Key, typename _Value, typename _Alloc,\n+\t   typename _ExtractKey, typename _Equal,\n+\t   typename _Hash, typename _RangeHash, typename _Unused,\n+\t   typename _RehashPolicy, typename _Traits>\n     auto\n     _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n-\t       _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n-    _M_insert_multi_node(__node_type* __hint, const key_type& __k,\n+\t       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::\n+    _M_insert_multi_node(__node_type* __hint,\n \t\t\t __hash_code __code, __node_type* __node)\n     -> iterator\n     {\n@@ -1833,7 +1801,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t_M_rehash(__do_rehash.second, __saved_state);\n \n       this->_M_store_code(__node, __code);\n-      size_type __bkt = _M_bucket_index(__k, __code);\n+      const key_type& __k = _ExtractKey{}(__node->_M_v());\n+      size_type __bkt = _M_bucket_index(__code);\n \n       // Find the node before an equivalent one or use hint if it exists and\n       // if it is equivalent.\n@@ -1868,66 +1837,65 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     }\n \n   // Insert v if no element with its key is already present.\n-  template<typename _Key, typename _Value,\n-\t   typename _Alloc, typename _ExtractKey, typename _Equal,\n-\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n-\t   typename _Traits>\n+  template<typename _Key, typename _Value, typename _Alloc,\n+\t   typename _ExtractKey, typename _Equal,\n+\t   typename _Hash, typename _RangeHash, typename _Unused,\n+\t   typename _RehashPolicy, typename _Traits>\n     template<typename _Arg, typename _NodeGenerator>\n       auto\n       _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n-\t\t _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n+\t\t _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::\n       _M_insert(_Arg&& __v, const _NodeGenerator& __node_gen,\n \t\ttrue_type /* __uks */)\n       -> pair<iterator, bool>\n       {\n-\tconst key_type& __k = this->_M_extract()(__v);\n+\tconst key_type& __k = _ExtractKey{}(__v);\n \t__hash_code __code = this->_M_hash_code(__k);\n-\tsize_type __bkt = _M_bucket_index(__k, __code);\n+\tsize_type __bkt = _M_bucket_index(__code);\n \n \tif (__node_type* __node = _M_find_node(__bkt, __k, __code))\n \t  return { iterator(__node), false };\n \n \t_Scoped_node __node{ __node_gen(std::forward<_Arg>(__v)), this };\n \tauto __pos\n-\t  = _M_insert_unique_node(__k, __bkt, __code, __node._M_node);\n+\t  = _M_insert_unique_node(__bkt, __code, __node._M_node);\n \t__node._M_node = nullptr;\n \treturn { __pos, true };\n       }\n \n   // Insert v unconditionally.\n-  template<typename _Key, typename _Value,\n-\t   typename _Alloc, typename _ExtractKey, typename _Equal,\n-\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n-\t   typename _Traits>\n+  template<typename _Key, typename _Value, typename _Alloc,\n+\t   typename _ExtractKey, typename _Equal,\n+\t   typename _Hash, typename _RangeHash, typename _Unused,\n+\t   typename _RehashPolicy, typename _Traits>\n     template<typename _Arg, typename _NodeGenerator>\n       auto\n       _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n-\t\t _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n+\t\t _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::\n       _M_insert(const_iterator __hint, _Arg&& __v,\n \t\tconst _NodeGenerator& __node_gen,\n \t\tfalse_type /* __uks */)\n       -> iterator\n       {\n \t// First compute the hash code so that we don't do anything if it\n \t// throws.\n-\t__hash_code __code = this->_M_hash_code(this->_M_extract()(__v));\n+\t__hash_code __code = this->_M_hash_code(_ExtractKey{}(__v));\n \n \t// Second allocate new node so that we don't rehash if it throws.\n \t_Scoped_node __node{ __node_gen(std::forward<_Arg>(__v)), this };\n-\tconst key_type& __k = this->_M_extract()(__node._M_node->_M_v());\n \tauto __pos\n-\t  = _M_insert_multi_node(__hint._M_cur, __k, __code, __node._M_node);\n+\t  = _M_insert_multi_node(__hint._M_cur, __code, __node._M_node);\n \t__node._M_node = nullptr;\n \treturn __pos;\n       }\n \n-  template<typename _Key, typename _Value,\n-\t   typename _Alloc, typename _ExtractKey, typename _Equal,\n-\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n-\t   typename _Traits>\n+  template<typename _Key, typename _Value, typename _Alloc,\n+\t   typename _ExtractKey, typename _Equal,\n+\t   typename _Hash, typename _RangeHash, typename _Unused,\n+\t   typename _RehashPolicy, typename _Traits>\n     auto\n     _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n-\t       _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n+\t       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::\n     erase(const_iterator __it)\n     -> iterator\n     {\n@@ -1941,13 +1909,13 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       return _M_erase(__bkt, __prev_n, __n);\n     }\n \n-  template<typename _Key, typename _Value,\n-\t   typename _Alloc, typename _ExtractKey, typename _Equal,\n-\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n-\t   typename _Traits>\n+  template<typename _Key, typename _Value, typename _Alloc,\n+\t   typename _ExtractKey, typename _Equal,\n+\t   typename _Hash, typename _RangeHash, typename _Unused,\n+\t   typename _RehashPolicy, typename _Traits>\n     auto\n     _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n-\t       _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n+\t       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::\n     _M_erase(size_type __bkt, __node_base* __prev_n, __node_type* __n)\n     -> iterator\n     {\n@@ -1969,18 +1937,18 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       return __result;\n     }\n \n-  template<typename _Key, typename _Value,\n-\t   typename _Alloc, typename _ExtractKey, typename _Equal,\n-\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n-\t   typename _Traits>\n+  template<typename _Key, typename _Value, typename _Alloc,\n+\t   typename _ExtractKey, typename _Equal,\n+\t   typename _Hash, typename _RangeHash, typename _Unused,\n+\t   typename _RehashPolicy, typename _Traits>\n     auto\n     _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n-\t       _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n-    _M_erase(true_type, const key_type& __k)\n+\t       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::\n+    _M_erase(true_type /* __uks */, const key_type& __k)\n     -> size_type\n     {\n       __hash_code __code = this->_M_hash_code(__k);\n-      std::size_t __bkt = _M_bucket_index(__k, __code);\n+      std::size_t __bkt = _M_bucket_index(__code);\n \n       // Look for the node before the first matching node.\n       __node_base* __prev_n = _M_find_before_node(__bkt, __k, __code);\n@@ -1993,18 +1961,18 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       return 1;\n     }\n \n-  template<typename _Key, typename _Value,\n-\t   typename _Alloc, typename _ExtractKey, typename _Equal,\n-\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n-\t   typename _Traits>\n+  template<typename _Key, typename _Value, typename _Alloc,\n+\t   typename _ExtractKey, typename _Equal,\n+\t   typename _Hash, typename _RangeHash, typename _Unused,\n+\t   typename _RehashPolicy, typename _Traits>\n     auto\n     _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n-\t       _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n-    _M_erase(false_type, const key_type& __k)\n+\t       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::\n+    _M_erase(false_type /* __uks */, const key_type& __k)\n     -> size_type\n     {\n       __hash_code __code = this->_M_hash_code(__k);\n-      std::size_t __bkt = _M_bucket_index(__k, __code);\n+      std::size_t __bkt = _M_bucket_index(__code);\n \n       // Look for the node before the first matching node.\n       __node_base* __prev_n = _M_find_before_node(__bkt, __k, __code);\n@@ -2044,13 +2012,13 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       return __result;\n     }\n \n-  template<typename _Key, typename _Value,\n-\t   typename _Alloc, typename _ExtractKey, typename _Equal,\n-\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n-\t   typename _Traits>\n+  template<typename _Key, typename _Value, typename _Alloc,\n+\t   typename _ExtractKey, typename _Equal,\n+\t   typename _Hash, typename _RangeHash, typename _Unused,\n+\t   typename _RehashPolicy, typename _Traits>\n     auto\n     _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n-\t       _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n+\t       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::\n     erase(const_iterator __first, const_iterator __last)\n     -> iterator\n     {\n@@ -2091,13 +2059,13 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       return iterator(__n);\n     }\n \n-  template<typename _Key, typename _Value,\n-\t   typename _Alloc, typename _ExtractKey, typename _Equal,\n-\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n-\t   typename _Traits>\n+  template<typename _Key, typename _Value, typename _Alloc,\n+\t   typename _ExtractKey, typename _Equal,\n+\t   typename _Hash, typename _RangeHash, typename _Unused,\n+\t   typename _RehashPolicy, typename _Traits>\n     void\n     _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n-\t       _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n+\t       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::\n     clear() noexcept\n     {\n       this->_M_deallocate_nodes(_M_begin());\n@@ -2106,13 +2074,13 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       _M_before_begin._M_nxt = nullptr;\n     }\n \n-  template<typename _Key, typename _Value,\n-\t   typename _Alloc, typename _ExtractKey, typename _Equal,\n-\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n-\t   typename _Traits>\n+  template<typename _Key, typename _Value, typename _Alloc,\n+\t   typename _ExtractKey, typename _Equal,\n+\t   typename _Hash, typename _RangeHash, typename _Unused,\n+\t   typename _RehashPolicy, typename _Traits>\n     void\n     _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n-\t       _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n+\t       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::\n     rehash(size_type __bkt_count)\n     {\n       const __rehash_state& __saved_state = _M_rehash_policy._M_state();\n@@ -2129,18 +2097,18 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t_M_rehash_policy._M_reset(__saved_state);\n     }\n \n-  template<typename _Key, typename _Value,\n-\t   typename _Alloc, typename _ExtractKey, typename _Equal,\n-\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n-\t   typename _Traits>\n+  template<typename _Key, typename _Value, typename _Alloc,\n+\t   typename _ExtractKey, typename _Equal,\n+\t   typename _Hash, typename _RangeHash, typename _Unused,\n+\t   typename _RehashPolicy, typename _Traits>\n     void\n     _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n-\t       _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n+\t       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::\n     _M_rehash(size_type __bkt_count, const __rehash_state& __state)\n     {\n       __try\n \t{\n-\t  _M_rehash_aux(__bkt_count, __unique_keys());\n+\t  _M_rehash_aux(__bkt_count, __unique_keys{});\n \t}\n       __catch(...)\n \t{\n@@ -2152,14 +2120,14 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     }\n \n   // Rehash when there is no equivalent elements.\n-  template<typename _Key, typename _Value,\n-\t   typename _Alloc, typename _ExtractKey, typename _Equal,\n-\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n-\t   typename _Traits>\n+  template<typename _Key, typename _Value, typename _Alloc,\n+\t   typename _ExtractKey, typename _Equal,\n+\t   typename _Hash, typename _RangeHash, typename _Unused,\n+\t   typename _RehashPolicy, typename _Traits>\n     void\n     _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n-\t       _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n-    _M_rehash_aux(size_type __bkt_count, true_type)\n+\t       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::\n+    _M_rehash_aux(size_type __bkt_count, true_type /* __uks */)\n     {\n       __bucket_type* __new_buckets = _M_allocate_buckets(__bkt_count);\n       __node_type* __p = _M_begin();\n@@ -2195,14 +2163,14 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n   // Rehash when there can be equivalent elements, preserve their relative\n   // order.\n-  template<typename _Key, typename _Value,\n-\t   typename _Alloc, typename _ExtractKey, typename _Equal,\n-\t   typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,\n-\t   typename _Traits>\n+  template<typename _Key, typename _Value, typename _Alloc,\n+\t   typename _ExtractKey, typename _Equal,\n+\t   typename _Hash, typename _RangeHash, typename _Unused,\n+\t   typename _RehashPolicy, typename _Traits>\n     void\n     _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n-\t       _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n-    _M_rehash_aux(size_type __bkt_count, false_type)\n+\t       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::\n+    _M_rehash_aux(size_type __bkt_count, false_type /* __uks */)\n     {\n       __bucket_type* __new_buckets = _M_allocate_buckets(__bkt_count);\n "}, {"sha": "38bd5ae4e8180ab92d835b3201f00d4cad425fb6", "filename": "libstdc++-v3/include/bits/hashtable_policy.h", "status": "modified", "additions": 178, "deletions": 290, "changes": 468, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4797a61cc5024fc9adf5918e9bb2b78988f9e4d4/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable_policy.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4797a61cc5024fc9adf5918e9bb2b78988f9e4d4/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable_policy.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable_policy.h?ref=4797a61cc5024fc9adf5918e9bb2b78988f9e4d4", "patch": "@@ -41,7 +41,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n   template<typename _Key, typename _Value, typename _Alloc,\n \t   typename _ExtractKey, typename _Equal,\n-\t   typename _H1, typename _H2, typename _Hash,\n+\t   typename _Hash, typename _RangeHash, typename _Unused,\n \t   typename _RehashPolicy, typename _Traits>\n     class _Hashtable;\n \n@@ -52,9 +52,9 @@ namespace __detail\n    *  @ingroup unordered_associative_containers\n    *  @{\n    */\n-  template<typename _Key, typename _Value,\n-\t   typename _ExtractKey, typename _Equal,\n-\t   typename _H1, typename _H2, typename _Hash, typename _Traits>\n+  template<typename _Key, typename _Value, typename _ExtractKey,\n+\t   typename _Equal, typename _Hash, typename _RangeHash,\n+\t   typename _Unused, typename _Traits>\n     struct _Hashtable_base;\n \n   // Helper function: return distance(first, last) for forward\n@@ -81,15 +81,15 @@ namespace __detail\n   {\n     template<typename _Tp>\n       _Tp&&\n-      operator()(_Tp&& __x) const\n+      operator()(_Tp&& __x) const noexcept\n       { return std::forward<_Tp>(__x); }\n   };\n \n   struct _Select1st\n   {\n     template<typename _Tp>\n       auto\n-      operator()(_Tp&& __x) const\n+      operator()(_Tp&& __x) const noexcept\n       -> decltype(std::get<0>(std::forward<_Tp>(__x)))\n       { return std::get<0>(std::forward<_Tp>(__x)); }\n   };\n@@ -638,37 +638,36 @@ namespace __detail\n    */\n   template<typename _Key, typename _Value, typename _Alloc,\n \t   typename _ExtractKey, typename _Equal,\n-\t   typename _H1, typename _H2, typename _Hash,\n+\t   typename _Hash, typename _RangeHash, typename _Unused,\n \t   typename _RehashPolicy, typename _Traits,\n \t   bool _Unique_keys = _Traits::__unique_keys::value>\n     struct _Map_base { };\n \n   /// Partial specialization, __unique_keys set to false.\n   template<typename _Key, typename _Pair, typename _Alloc, typename _Equal,\n-\t   typename _H1, typename _H2, typename _Hash,\n+\t   typename _Hash, typename _RangeHash, typename _Unused,\n \t   typename _RehashPolicy, typename _Traits>\n     struct _Map_base<_Key, _Pair, _Alloc, _Select1st, _Equal,\n-\t\t     _H1, _H2, _Hash, _RehashPolicy, _Traits, false>\n+\t\t     _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits, false>\n     {\n       using mapped_type = typename std::tuple_element<1, _Pair>::type;\n     };\n \n   /// Partial specialization, __unique_keys set to true.\n   template<typename _Key, typename _Pair, typename _Alloc, typename _Equal,\n-\t   typename _H1, typename _H2, typename _Hash,\n+\t   typename _Hash, typename _RangeHash, typename _Unused,\n \t   typename _RehashPolicy, typename _Traits>\n     struct _Map_base<_Key, _Pair, _Alloc, _Select1st, _Equal,\n-\t\t     _H1, _H2, _Hash, _RehashPolicy, _Traits, true>\n+\t\t     _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits, true>\n     {\n     private:\n-      using __hashtable_base = __detail::_Hashtable_base<_Key, _Pair,\n-\t\t\t\t\t\t\t _Select1st,\n-\t\t\t\t\t\t\t_Equal, _H1, _H2, _Hash,\n-\t\t\t\t\t\t\t  _Traits>;\n+      using __hashtable_base = _Hashtable_base<_Key, _Pair, _Select1st, _Equal,\n+\t\t\t\t\t       _Hash, _RangeHash, _Unused,\n+\t\t\t\t\t       _Traits>;\n \n-      using __hashtable = _Hashtable<_Key, _Pair, _Alloc,\n-\t\t\t\t     _Select1st, _Equal,\n-\t\t\t\t     _H1, _H2, _Hash, _RehashPolicy, _Traits>;\n+      using __hashtable = _Hashtable<_Key, _Pair, _Alloc, _Select1st, _Equal,\n+\t\t\t\t     _Hash, _RangeHash,\n+\t\t\t\t     _Unused, _RehashPolicy, _Traits>;\n \n       using __hash_code = typename __hashtable_base::__hash_code;\n       using __node_type = typename __hashtable_base::__node_type;\n@@ -694,17 +693,17 @@ namespace __detail\n     };\n \n   template<typename _Key, typename _Pair, typename _Alloc, typename _Equal,\n-\t   typename _H1, typename _H2, typename _Hash,\n+\t   typename _Hash, typename _RangeHash, typename _Unused,\n \t   typename _RehashPolicy, typename _Traits>\n     auto\n     _Map_base<_Key, _Pair, _Alloc, _Select1st, _Equal,\n-\t      _H1, _H2, _Hash, _RehashPolicy, _Traits, true>::\n+\t      _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits, true>::\n     operator[](const key_type& __k)\n     -> mapped_type&\n     {\n       __hashtable* __h = static_cast<__hashtable*>(this);\n       __hash_code __code = __h->_M_hash_code(__k);\n-      std::size_t __bkt = __h->_M_bucket_index(__k, __code);\n+      std::size_t __bkt = __h->_M_bucket_index(__code);\n       if (__node_type* __node = __h->_M_find_node(__bkt, __k, __code))\n \treturn __node->_M_v().second;\n \n@@ -715,23 +714,23 @@ namespace __detail\n \tstd::tuple<>()\n       };\n       auto __pos\n-\t= __h->_M_insert_unique_node(__k, __bkt, __code, __node._M_node);\n+\t= __h->_M_insert_unique_node(__bkt, __code, __node._M_node);\n       __node._M_node = nullptr;\n       return __pos->second;\n     }\n \n   template<typename _Key, typename _Pair, typename _Alloc, typename _Equal,\n-\t   typename _H1, typename _H2, typename _Hash,\n+\t   typename _Hash, typename _RangeHash, typename _Unused,\n \t   typename _RehashPolicy, typename _Traits>\n     auto\n     _Map_base<_Key, _Pair, _Alloc, _Select1st, _Equal,\n-\t      _H1, _H2, _Hash, _RehashPolicy, _Traits, true>::\n+\t      _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits, true>::\n     operator[](key_type&& __k)\n     -> mapped_type&\n     {\n       __hashtable* __h = static_cast<__hashtable*>(this);\n       __hash_code __code = __h->_M_hash_code(__k);\n-      std::size_t __bkt = __h->_M_bucket_index(__k, __code);\n+      std::size_t __bkt = __h->_M_bucket_index(__code);\n       if (__node_type* __node = __h->_M_find_node(__bkt, __k, __code))\n \treturn __node->_M_v().second;\n \n@@ -742,17 +741,17 @@ namespace __detail\n \tstd::tuple<>()\n       };\n       auto __pos\n-\t= __h->_M_insert_unique_node(__k, __bkt, __code, __node._M_node);\n+\t= __h->_M_insert_unique_node(__bkt, __code, __node._M_node);\n       __node._M_node = nullptr;\n       return __pos->second;\n     }\n \n   template<typename _Key, typename _Pair, typename _Alloc, typename _Equal,\n-\t   typename _H1, typename _H2, typename _Hash,\n+\t   typename _Hash, typename _RangeHash, typename _Unused,\n \t   typename _RehashPolicy, typename _Traits>\n     auto\n     _Map_base<_Key, _Pair, _Alloc, _Select1st, _Equal,\n-\t      _H1, _H2, _Hash, _RehashPolicy, _Traits, true>::\n+\t      _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits, true>::\n     at(const key_type& __k)\n     -> mapped_type&\n     {\n@@ -765,11 +764,11 @@ namespace __detail\n     }\n \n   template<typename _Key, typename _Pair, typename _Alloc, typename _Equal,\n-\t   typename _H1, typename _H2, typename _Hash,\n+\t   typename _Hash, typename _RangeHash, typename _Unused,\n \t   typename _RehashPolicy, typename _Traits>\n     auto\n     _Map_base<_Key, _Pair, _Alloc, _Select1st, _Equal,\n-\t      _H1, _H2, _Hash, _RehashPolicy, _Traits, true>::\n+\t      _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits, true>::\n     at(const key_type& __k) const\n     -> const mapped_type&\n     {\n@@ -788,18 +787,18 @@ namespace __detail\n    */\n   template<typename _Key, typename _Value, typename _Alloc,\n \t   typename _ExtractKey, typename _Equal,\n-\t   typename _H1, typename _H2, typename _Hash,\n+\t   typename _Hash, typename _RangeHash, typename _Unused,\n \t   typename _RehashPolicy, typename _Traits>\n     struct _Insert_base\n     {\n     protected:\n-      using __hashtable = _Hashtable<_Key, _Value, _Alloc, _ExtractKey,\n-\t\t\t\t     _Equal, _H1, _H2, _Hash,\n-\t\t\t\t     _RehashPolicy, _Traits>;\n-\n       using __hashtable_base = _Hashtable_base<_Key, _Value, _ExtractKey,\n-\t\t\t\t\t       _Equal, _H1, _H2, _Hash,\n-\t\t\t\t\t       _Traits>;\n+\t\t\t\t\t       _Equal, _Hash, _RangeHash,\n+\t\t\t\t\t       _Unused, _Traits>;\n+\n+      using __hashtable = _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n+\t\t\t\t     _Hash, _RangeHash,\n+\t\t\t\t     _Unused, _RehashPolicy, _Traits>;\n \n       using value_type = typename __hashtable_base::value_type;\n       using iterator = typename __hashtable_base::iterator;\n@@ -849,7 +848,7 @@ namespace __detail\n \t{\n \t  __hashtable& __h = _M_conjure_hashtable();\n \t  auto __code = __h._M_hash_code(__k);\n-\t  std::size_t __bkt = __h._M_bucket_index(__k, __code);\n+\t  std::size_t __bkt = __h._M_bucket_index(__code);\n \t  if (__node_type* __node = __h._M_find_node(__bkt, __k, __code))\n \t    return { iterator(__node), false };\n \n@@ -860,7 +859,7 @@ namespace __detail\n \t    std::forward_as_tuple(std::forward<_Args>(__args)...)\n \t    };\n \t  auto __it\n-\t    = __h._M_insert_unique_node(__k, __bkt, __code, __node._M_node);\n+\t    = __h._M_insert_unique_node(__bkt, __code, __node._M_node);\n \t  __node._M_node = nullptr;\n \t  return { __it, true };\n \t}\n@@ -881,12 +880,13 @@ namespace __detail\n \n   template<typename _Key, typename _Value, typename _Alloc,\n \t   typename _ExtractKey, typename _Equal,\n-\t   typename _H1, typename _H2, typename _Hash,\n+\t   typename _Hash, typename _RangeHash, typename _Unused,\n \t   typename _RehashPolicy, typename _Traits>\n     template<typename _InputIterator, typename _NodeGetter>\n       void\n-      _Insert_base<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash,\n-\t\t    _RehashPolicy, _Traits>::\n+      _Insert_base<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n+\t\t   _Hash, _RangeHash, _Unused,\n+\t\t   _RehashPolicy, _Traits>::\n       _M_insert_range(_InputIterator __first, _InputIterator __last,\n \t\t      const _NodeGetter& __node_gen, true_type __uks)\n       {\n@@ -897,12 +897,13 @@ namespace __detail\n \n   template<typename _Key, typename _Value, typename _Alloc,\n \t   typename _ExtractKey, typename _Equal,\n-\t   typename _H1, typename _H2, typename _Hash,\n+\t   typename _Hash, typename _RangeHash, typename _Unused,\n \t   typename _RehashPolicy, typename _Traits>\n     template<typename _InputIterator, typename _NodeGetter>\n       void\n-      _Insert_base<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash,\n-\t\t    _RehashPolicy, _Traits>::\n+      _Insert_base<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n+\t\t   _Hash, _RangeHash, _Unused,\n+\t\t   _RehashPolicy, _Traits>::\n       _M_insert_range(_InputIterator __first, _InputIterator __last,\n \t\t      const _NodeGetter& __node_gen, false_type __uks)\n       {\n@@ -936,28 +937,29 @@ namespace __detail\n    */\n   template<typename _Key, typename _Value, typename _Alloc,\n \t   typename _ExtractKey, typename _Equal,\n-\t   typename _H1, typename _H2, typename _Hash,\n+\t   typename _Hash, typename _RangeHash, typename _Unused,\n \t   typename _RehashPolicy, typename _Traits,\n \t   bool _Constant_iterators = _Traits::__constant_iterators::value>\n     struct _Insert;\n \n   /// Specialization.\n   template<typename _Key, typename _Value, typename _Alloc,\n \t   typename _ExtractKey, typename _Equal,\n-\t   typename _H1, typename _H2, typename _Hash,\n+\t   typename _Hash, typename _RangeHash, typename _Unused,\n \t   typename _RehashPolicy, typename _Traits>\n-    struct _Insert<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash,\n+    struct _Insert<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n+\t\t   _Hash, _RangeHash, _Unused,\n \t\t   _RehashPolicy, _Traits, true>\n     : public _Insert_base<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n-\t\t\t   _H1, _H2, _Hash, _RehashPolicy, _Traits>\n+\t\t\t  _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>\n     {\n       using __base_type = _Insert_base<_Key, _Value, _Alloc, _ExtractKey,\n-\t\t\t\t\t_Equal, _H1, _H2, _Hash,\n-\t\t\t\t\t_RehashPolicy, _Traits>;\n+\t\t\t\t       _Equal, _Hash, _RangeHash, _Unused,\n+\t\t\t\t       _RehashPolicy, _Traits>;\n \n       using __hashtable_base = _Hashtable_base<_Key, _Value, _ExtractKey,\n-\t\t\t\t\t       _Equal, _H1, _H2, _Hash,\n-\t\t\t\t\t       _Traits>;\n+\t\t\t\t\t       _Equal, _Hash, _RangeHash,\n+\t\t\t\t\t       _Unused, _Traits>;\n \n       using value_type = typename __base_type::value_type;\n       using iterator = typename __base_type::iterator;\n@@ -991,15 +993,15 @@ namespace __detail\n   /// Specialization.\n   template<typename _Key, typename _Value, typename _Alloc,\n \t   typename _ExtractKey, typename _Equal,\n-\t   typename _H1, typename _H2, typename _Hash,\n+\t   typename _Hash, typename _RangeHash, typename _Unused,\n \t   typename _RehashPolicy, typename _Traits>\n-    struct _Insert<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash,\n-\t\t   _RehashPolicy, _Traits, false>\n+    struct _Insert<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n+\t\t   _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits, false>\n     : public _Insert_base<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n-\t\t\t   _H1, _H2, _Hash, _RehashPolicy, _Traits>\n+\t\t\t  _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>\n     {\n       using __base_type = _Insert_base<_Key, _Value, _Alloc, _ExtractKey,\n-\t\t\t\t       _Equal, _H1, _H2, _Hash,\n+\t\t\t\t       _Equal, _Hash, _RangeHash, _Unused,\n \t\t\t\t       _RehashPolicy, _Traits>;\n       using value_type = typename __base_type::value_type;\n       using iterator = typename __base_type::iterator;\n@@ -1049,7 +1051,7 @@ namespace __detail\n   */\n   template<typename _Key, typename _Value, typename _Alloc,\n \t   typename _ExtractKey, typename _Equal,\n-\t   typename _H1, typename _H2, typename _Hash,\n+\t   typename _Hash, typename _RangeHash, typename _Unused,\n \t   typename _RehashPolicy, typename _Traits,\n \t   typename =\n \t     __detected_or_t<false_type, __has_load_factor, _RehashPolicy>>\n@@ -1058,25 +1060,25 @@ namespace __detail\n   /// Specialization when rehash policy doesn't provide load factor management.\n   template<typename _Key, typename _Value, typename _Alloc,\n \t   typename _ExtractKey, typename _Equal,\n-\t   typename _H1, typename _H2, typename _Hash,\n+\t   typename _Hash, typename _RangeHash, typename _Unused,\n \t   typename _RehashPolicy, typename _Traits>\n     struct _Rehash_base<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n-\t\t      _H1, _H2, _Hash, _RehashPolicy, _Traits,\n-\t\t      false_type>\n+\t\t\t_Hash, _RangeHash, _Unused, _RehashPolicy, _Traits,\n+\t\t\tfalse_type /* Has load factor */>\n     {\n     };\n \n   /// Specialization when rehash policy provide load factor management.\n   template<typename _Key, typename _Value, typename _Alloc,\n \t   typename _ExtractKey, typename _Equal,\n-\t   typename _H1, typename _H2, typename _Hash,\n+\t   typename _Hash, typename _RangeHash, typename _Unused,\n \t   typename _RehashPolicy, typename _Traits>\n     struct _Rehash_base<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n-\t\t\t_H1, _H2, _Hash, _RehashPolicy, _Traits,\n-\t\t\ttrue_type>\n+\t\t\t_Hash, _RangeHash, _Unused, _RehashPolicy, _Traits,\n+\t\t\ttrue_type /* Has load factor */>\n     {\n       using __hashtable = _Hashtable<_Key, _Value, _Alloc, _ExtractKey,\n-\t\t\t\t     _Equal, _H1, _H2, _Hash,\n+\t\t\t\t     _Equal, _Hash, _RangeHash, _Unused,\n \t\t\t\t     _RehashPolicy, _Traits>;\n \n       float\n@@ -1152,7 +1154,7 @@ namespace __detail\n    *  but not between buckets.\n    */\n   template<typename _Key, typename _Value, typename _ExtractKey,\n-\t   typename _H1, typename _H2, typename _Hash,\n+\t   typename _Hash, typename _RangeHash, typename _Unused,\n \t   bool __cache_hash_code>\n     struct _Local_iterator_base;\n \n@@ -1177,108 +1179,32 @@ namespace __detail\n    *  Primary template is unused except as a hook for specializations.\n    */\n   template<typename _Key, typename _Value, typename _ExtractKey,\n-\t   typename _H1, typename _H2, typename _Hash,\n+\t   typename _Hash, typename _RangeHash, typename _Unused,\n \t   bool __cache_hash_code>\n     struct _Hash_code_base;\n \n-  /// Specialization: ranged hash function, no caching hash codes.  H1\n-  /// and H2 are provided but ignored.  We define a dummy hash code type.\n-  template<typename _Key, typename _Value, typename _ExtractKey,\n-\t   typename _H1, typename _H2, typename _Hash>\n-    struct _Hash_code_base<_Key, _Value, _ExtractKey, _H1, _H2, _Hash, false>\n-    : private _Hashtable_ebo_helper<0, _ExtractKey>,\n-      private _Hashtable_ebo_helper<1, _Hash>\n-    {\n-    private:\n-      using __ebo_extract_key = _Hashtable_ebo_helper<0, _ExtractKey>;\n-      using __ebo_hash = _Hashtable_ebo_helper<1, _Hash>;\n-\n-    protected:\n-      typedef void* \t\t\t\t\t__hash_code;\n-      typedef _Hash_node<_Value, false>\t\t\t__node_type;\n-\n-      // We need the default constructor for the local iterators and _Hashtable\n-      // default constructor.\n-      _Hash_code_base() = default;\n-\n-      _Hash_code_base(const _ExtractKey& __ex, const _H1&, const _H2&,\n-\t\t      const _Hash& __h)\n-      : __ebo_extract_key(__ex), __ebo_hash(__h) { }\n-\n-      __hash_code\n-      _M_hash_code(const _Key& __key) const\n-      { return 0; }\n-\n-      std::size_t\n-      _M_bucket_index(const _Key& __k, __hash_code,\n-\t\t      std::size_t __bkt_count) const\n-      { return _M_ranged_hash()(__k, __bkt_count); }\n-\n-      std::size_t\n-      _M_bucket_index(const __node_type* __p, std::size_t __bkt_count) const\n-\tnoexcept( noexcept(declval<const _Hash&>()(declval<const _Key&>(),\n-\t\t\t\t\t\t   (std::size_t)0)) )\n-      { return _M_ranged_hash()(_M_extract()(__p->_M_v()), __bkt_count); }\n-\n-      void\n-      _M_store_code(__node_type*, __hash_code) const\n-      { }\n-\n-      void\n-      _M_copy_code(__node_type*, const __node_type*) const\n-      { }\n-\n-      void\n-      _M_swap(_Hash_code_base& __x)\n-      {\n-\tstd::swap(__ebo_extract_key::_M_get(),\n-\t\t  __x.__ebo_extract_key::_M_get());\n-\tstd::swap(__ebo_hash::_M_get(), __x.__ebo_hash::_M_get());\n-      }\n-\n-      const _ExtractKey&\n-      _M_extract() const { return __ebo_extract_key::_M_cget(); }\n-\n-      const _Hash&\n-      _M_ranged_hash() const { return __ebo_hash::_M_cget(); }\n-    };\n-\n-  // No specialization for ranged hash function while caching hash codes.\n-  // That combination is meaningless, and trying to do it is an error.\n-\n-  /// Specialization: ranged hash function, cache hash codes.  This\n-  /// combination is meaningless, so we provide only a declaration\n-  /// and no definition.\n-  template<typename _Key, typename _Value, typename _ExtractKey,\n-\t   typename _H1, typename _H2, typename _Hash>\n-    struct _Hash_code_base<_Key, _Value, _ExtractKey, _H1, _H2, _Hash, true>;\n-\n   /// Specialization: hash function and range-hashing function, no\n   /// caching of hash codes.\n   /// Provides typedef and accessor required by C++ 11.\n   template<typename _Key, typename _Value, typename _ExtractKey,\n-\t   typename _H1, typename _H2>\n-    struct _Hash_code_base<_Key, _Value, _ExtractKey, _H1, _H2,\n-\t\t\t   _Default_ranged_hash, false>\n-    : private _Hashtable_ebo_helper<0, _ExtractKey>,\n-      private _Hashtable_ebo_helper<1, _H1>,\n-      private _Hashtable_ebo_helper<2, _H2>\n+\t   typename _Hash, typename _RangeHash, typename _Unused>\n+    struct _Hash_code_base<_Key, _Value, _ExtractKey, _Hash, _RangeHash,\n+\t\t\t   _Unused, false>\n+    : private _Hashtable_ebo_helper<0, _Hash>\n     {\n     private:\n-      using __ebo_extract_key = _Hashtable_ebo_helper<0, _ExtractKey>;\n-      using __ebo_h1 = _Hashtable_ebo_helper<1, _H1>;\n-      using __ebo_h2 = _Hashtable_ebo_helper<2, _H2>;\n+      using __ebo_hash = _Hashtable_ebo_helper<0, _Hash>;\n \n       // Gives the local iterator implementation access to _M_bucket_index().\n-      friend struct _Local_iterator_base<_Key, _Value, _ExtractKey, _H1, _H2,\n-\t\t\t\t\t _Default_ranged_hash, false>;\n+      friend struct _Local_iterator_base<_Key, _Value, _ExtractKey,\n+\t\t\t\t\t _Hash, _RangeHash, _Unused, false>;\n \n     public:\n-      typedef _H1 \t\t\t\t\thasher;\n+      typedef _Hash\t\t\t\t\thasher;\n \n       hasher\n       hash_function() const\n-      { return _M_h1(); }\n+      { return _M_hash(); }\n \n     protected:\n       typedef std::size_t \t\t\t\t__hash_code;\n@@ -1287,31 +1213,29 @@ namespace __detail\n       // We need the default constructor for the local iterators and _Hashtable\n       // default constructor.\n       _Hash_code_base() = default;\n-\n-      _Hash_code_base(const _ExtractKey& __ex,\n-\t\t      const _H1& __h1, const _H2& __h2,\n-\t\t      const _Default_ranged_hash&)\n-      : __ebo_extract_key(__ex), __ebo_h1(__h1), __ebo_h2(__h2) { }\n+      _Hash_code_base(const _Hash& __hash) : __ebo_hash(__hash) { }\n \n       __hash_code\n       _M_hash_code(const _Key& __k) const\n       {\n-\tstatic_assert(__is_invocable<const _H1&, const _Key&>{},\n+\tstatic_assert(__is_invocable<const _Hash&, const _Key&>{},\n \t    \"hash function must be invocable with an argument of key type\");\n-\treturn _M_h1()(__k);\n+\treturn _M_hash()(__k);\n       }\n \n       std::size_t\n-      _M_bucket_index(const _Key&, __hash_code __c,\n-\t\t      std::size_t __bkt_count) const\n-      { return _M_h2()(__c, __bkt_count); }\n+      _M_bucket_index(__hash_code __c, std::size_t __bkt_count) const\n+      { return _RangeHash{}(__c, __bkt_count); }\n \n       std::size_t\n       _M_bucket_index(const __node_type* __p, std::size_t __bkt_count) const\n-\tnoexcept( noexcept(declval<const _H1&>()(declval<const _Key&>()))\n-\t\t  && noexcept(declval<const _H2&>()((__hash_code)0,\n-\t\t\t\t\t\t    (std::size_t)0)) )\n-      { return _M_h2()(_M_h1()(_M_extract()(__p->_M_v())), __bkt_count); }\n+\tnoexcept( noexcept(declval<const _Hash&>()(declval<const _Key&>()))\n+\t\t  && noexcept(declval<const _RangeHash&>()((__hash_code)0,\n+\t\t\t\t\t\t\t   (std::size_t)0)) )\n+      {\n+\treturn _RangeHash{}(_M_hash()(_ExtractKey{}(__p->_M_v())),\n+\t\t\t    __bkt_count);\n+      }\n \n       void\n       _M_store_code(__node_type*, __hash_code) const\n@@ -1323,79 +1247,56 @@ namespace __detail\n \n       void\n       _M_swap(_Hash_code_base& __x)\n-      {\n-\tstd::swap(__ebo_extract_key::_M_get(),\n-\t\t  __x.__ebo_extract_key::_M_get());\n-\tstd::swap(__ebo_h1::_M_get(), __x.__ebo_h1::_M_get());\n-\tstd::swap(__ebo_h2::_M_get(), __x.__ebo_h2::_M_get());\n-      }\n-\n-      const _ExtractKey&\n-      _M_extract() const { return __ebo_extract_key::_M_cget(); }\n+      { std::swap(__ebo_hash::_M_get(), __x.__ebo_hash::_M_get()); }\n \n-      const _H1&\n-      _M_h1() const { return __ebo_h1::_M_cget(); }\n-\n-      const _H2&\n-      _M_h2() const { return __ebo_h2::_M_cget(); }\n+      const _Hash&\n+      _M_hash() const { return __ebo_hash::_M_cget(); }\n     };\n \n   /// Specialization: hash function and range-hashing function,\n   /// caching hash codes.  H is provided but ignored.  Provides\n   /// typedef and accessor required by C++ 11.\n   template<typename _Key, typename _Value, typename _ExtractKey,\n-\t   typename _H1, typename _H2>\n-    struct _Hash_code_base<_Key, _Value, _ExtractKey, _H1, _H2,\n-\t\t\t   _Default_ranged_hash, true>\n-    : private _Hashtable_ebo_helper<0, _ExtractKey>,\n-      private _Hashtable_ebo_helper<1, _H1>,\n-      private _Hashtable_ebo_helper<2, _H2>\n+\t   typename _Hash, typename _RangeHash, typename _Unused>\n+    struct _Hash_code_base<_Key, _Value, _ExtractKey, _Hash, _RangeHash,\n+\t\t\t   _Unused, true>\n+    : private _Hashtable_ebo_helper<0, _Hash>\n     {\n     private:\n-      // Gives the local iterator implementation access to _M_h2().\n-      friend struct _Local_iterator_base<_Key, _Value, _ExtractKey, _H1, _H2,\n-\t\t\t\t\t _Default_ranged_hash, true>;\n-\n-      using __ebo_extract_key = _Hashtable_ebo_helper<0, _ExtractKey>;\n-      using __ebo_h1 = _Hashtable_ebo_helper<1, _H1>;\n-      using __ebo_h2 = _Hashtable_ebo_helper<2, _H2>;\n+      using __ebo_hash = _Hashtable_ebo_helper<0, _Hash>;\n \n     public:\n-      typedef _H1 \t\t\t\t\thasher;\n+      typedef _Hash\t\t\t\t\thasher;\n \n       hasher\n       hash_function() const\n-      { return _M_h1(); }\n+      { return _M_hash(); }\n \n     protected:\n       typedef std::size_t \t\t\t\t__hash_code;\n       typedef _Hash_node<_Value, true>\t\t\t__node_type;\n \n       // We need the default constructor for _Hashtable default constructor.\n       _Hash_code_base() = default;\n-      _Hash_code_base(const _ExtractKey& __ex,\n-\t\t      const _H1& __h1, const _H2& __h2,\n-\t\t      const _Default_ranged_hash&)\n-      : __ebo_extract_key(__ex), __ebo_h1(__h1), __ebo_h2(__h2) { }\n+      _Hash_code_base(const _Hash& __hash) : __ebo_hash(__hash) { }\n \n       __hash_code\n       _M_hash_code(const _Key& __k) const\n       {\n-\tstatic_assert(__is_invocable<const _H1&, const _Key&>{},\n+\tstatic_assert(__is_invocable<const _Hash&, const _Key&>{},\n \t    \"hash function must be invocable with an argument of key type\");\n-\treturn _M_h1()(__k);\n+\treturn _M_hash()(__k);\n       }\n \n       std::size_t\n-      _M_bucket_index(const _Key&, __hash_code __c,\n-\t\t      std::size_t __bkt_count) const\n-      { return _M_h2()(__c, __bkt_count); }\n+      _M_bucket_index(__hash_code __c, std::size_t __bkt_count) const\n+      { return _RangeHash{}(__c, __bkt_count); }\n \n       std::size_t\n       _M_bucket_index(const __node_type* __p, std::size_t __bkt_count) const\n-\tnoexcept( noexcept(declval<const _H2&>()((__hash_code)0,\n-\t\t\t\t\t\t (std::size_t)0)) )\n-      { return _M_h2()(__p->_M_hash_code, __bkt_count); }\n+\tnoexcept( noexcept(declval<const _RangeHash&>()((__hash_code)0,\n+\t\t\t\t\t\t\t(std::size_t)0)) )\n+      { return _RangeHash{}(__p->_M_hash_code, __bkt_count); }\n \n       void\n       _M_store_code(__node_type* __n, __hash_code __c) const\n@@ -1407,43 +1308,30 @@ namespace __detail\n \n       void\n       _M_swap(_Hash_code_base& __x)\n-      {\n-\tstd::swap(__ebo_extract_key::_M_get(),\n-\t\t  __x.__ebo_extract_key::_M_get());\n-\tstd::swap(__ebo_h1::_M_get(), __x.__ebo_h1::_M_get());\n-\tstd::swap(__ebo_h2::_M_get(), __x.__ebo_h2::_M_get());\n-      }\n-\n-      const _ExtractKey&\n-      _M_extract() const { return __ebo_extract_key::_M_cget(); }\n+      { std::swap(__ebo_hash::_M_get(), __x.__ebo_hash::_M_get()); }\n \n-      const _H1&\n-      _M_h1() const { return __ebo_h1::_M_cget(); }\n-\n-      const _H2&\n-      _M_h2() const { return __ebo_h2::_M_cget(); }\n+      const _Hash&\n+      _M_hash() const { return __ebo_hash::_M_cget(); }\n     };\n \n   /// Partial specialization used when nodes contain a cached hash code.\n   template<typename _Key, typename _Value, typename _ExtractKey,\n-\t   typename _H1, typename _H2, typename _Hash>\n+\t   typename _Hash, typename _RangeHash, typename _Unused>\n     struct _Local_iterator_base<_Key, _Value, _ExtractKey,\n-\t\t\t\t_H1, _H2, _Hash, true>\n-    : private _Hashtable_ebo_helper<0, _H2>\n-    , _Node_iterator_base<_Value, true>\n+\t\t\t\t_Hash, _RangeHash, _Unused, true>\n+    : public _Node_iterator_base<_Value, true>\n     {\n     protected:\n-      using __base_type = _Hashtable_ebo_helper<0, _H2>;\n       using __base_node_iter = _Node_iterator_base<_Value, true>;\n       using __hash_code_base = _Hash_code_base<_Key, _Value, _ExtractKey,\n-\t\t\t\t\t       _H1, _H2, _Hash, true>;\n+\t\t\t\t\t      _Hash, _RangeHash, _Unused, true>;\n \n       _Local_iterator_base() = default;\n-      _Local_iterator_base(const __hash_code_base& __base,\n+      _Local_iterator_base(const __hash_code_base&,\n \t\t\t   _Hash_node<_Value, true>* __p,\n \t\t\t   std::size_t __bkt, std::size_t __bkt_count)\n-      : __base_type(__base._M_h2()), __base_node_iter(__p)\n-      , _M_bucket(__bkt), _M_bucket_count(__bkt_count) { }\n+      : __base_node_iter(__p), _M_bucket(__bkt), _M_bucket_count(__bkt_count)\n+      { }\n \n       void\n       _M_incr()\n@@ -1452,8 +1340,7 @@ namespace __detail\n \tif (this->_M_cur)\n \t  {\n \t    std::size_t __bkt\n-\t      = __base_type::_M_get()(this->_M_cur->_M_hash_code,\n-\t\t\t\t      _M_bucket_count);\n+\t      = _RangeHash{}(this->_M_cur->_M_hash_code, _M_bucket_count);\n \t    if (__bkt != _M_bucket)\n \t      this->_M_cur = nullptr;\n \t  }\n@@ -1499,22 +1386,23 @@ namespace __detail\n     };\n \n   template<typename _Key, typename _Value, typename _ExtractKey,\n-\t   typename _H1, typename _H2, typename _Hash>\n+\t   typename _Hash, typename _RangeHash, typename _Unused>\n     using __hash_code_for_local_iter\n       = _Hash_code_storage<_Hash_code_base<_Key, _Value, _ExtractKey,\n-\t\t\t\t\t   _H1, _H2, _Hash, false>>;\n+\t\t\t\t\t   _Hash, _RangeHash, _Unused, false>>;\n \n   // Partial specialization used when hash codes are not cached\n   template<typename _Key, typename _Value, typename _ExtractKey,\n-\t   typename _H1, typename _H2, typename _Hash>\n+\t   typename _Hash, typename _RangeHash, typename _Unused>\n     struct _Local_iterator_base<_Key, _Value, _ExtractKey,\n-\t\t\t\t_H1, _H2, _Hash, false>\n-    : __hash_code_for_local_iter<_Key, _Value, _ExtractKey, _H1, _H2, _Hash>\n+\t\t\t\t_Hash, _RangeHash, _Unused, false>\n+    : __hash_code_for_local_iter<_Key, _Value, _ExtractKey, _Hash, _RangeHash,\n+\t\t\t\t _Unused>\n     , _Node_iterator_base<_Value, false>\n     {\n     protected:\n       using __hash_code_base = _Hash_code_base<_Key, _Value, _ExtractKey,\n-\t\t\t\t\t       _H1, _H2, _Hash, false>;\n+\t\t\t\t\t     _Hash, _RangeHash, _Unused, false>;\n       using __node_iter_base = _Node_iterator_base<_Value, false>;\n \n       _Local_iterator_base() : _M_bucket_count(-1) { }\n@@ -1582,25 +1470,25 @@ namespace __detail\n \n   /// local iterators\n   template<typename _Key, typename _Value, typename _ExtractKey,\n-\t   typename _H1, typename _H2, typename _Hash,\n+\t   typename _Hash, typename _RangeHash, typename _Unused,\n \t   bool __constant_iterators, bool __cache>\n     struct _Local_iterator\n     : public _Local_iterator_base<_Key, _Value, _ExtractKey,\n-\t\t\t\t  _H1, _H2, _Hash, __cache>\n+\t\t\t\t  _Hash, _RangeHash, _Unused, __cache>\n     {\n     private:\n       using __base_type = _Local_iterator_base<_Key, _Value, _ExtractKey,\n-\t\t\t\t\t       _H1, _H2, _Hash, __cache>;\n+\t\t\t\t\t   _Hash, _RangeHash, _Unused, __cache>;\n       using __hash_code_base = typename __base_type::__hash_code_base;\n \n     public:\n       typedef _Value\t\t\t\t\tvalue_type;\n       typedef typename std::conditional<__constant_iterators,\n \t\t\t\t\tconst _Value*, _Value*>::type\n-\t\t\t\t\t\t       pointer;\n+\t\t\t\t\t\t\tpointer;\n       typedef typename std::conditional<__constant_iterators,\n \t\t\t\t\tconst _Value&, _Value&>::type\n-\t\t\t\t\t\t       reference;\n+\t\t\t\t\t\t\treference;\n       typedef std::ptrdiff_t\t\t\t\tdifference_type;\n       typedef std::forward_iterator_tag\t\t\titerator_category;\n \n@@ -1638,15 +1526,15 @@ namespace __detail\n \n   /// local const_iterators\n   template<typename _Key, typename _Value, typename _ExtractKey,\n-\t   typename _H1, typename _H2, typename _Hash,\n+\t   typename _Hash, typename _RangeHash, typename _Unused,\n \t   bool __constant_iterators, bool __cache>\n     struct _Local_const_iterator\n     : public _Local_iterator_base<_Key, _Value, _ExtractKey,\n-\t\t\t\t  _H1, _H2, _Hash, __cache>\n+\t\t\t\t  _Hash, _RangeHash, _Unused, __cache>\n     {\n     private:\n       using __base_type = _Local_iterator_base<_Key, _Value, _ExtractKey,\n-\t\t\t\t\t       _H1, _H2, _Hash, __cache>;\n+\t\t\t\t\t   _Hash, _RangeHash, _Unused, __cache>;\n       using __hash_code_base = typename __base_type::__hash_code_base;\n \n     public:\n@@ -1665,7 +1553,7 @@ namespace __detail\n       { }\n \n       _Local_const_iterator(const _Local_iterator<_Key, _Value, _ExtractKey,\n-\t\t\t\t\t\t  _H1, _H2, _Hash,\n+\t\t\t\t\t\t  _Hash, _RangeHash, _Unused,\n \t\t\t\t\t\t  __constant_iterators,\n \t\t\t\t\t\t  __cache>& __x)\n       : __base_type(__x)\n@@ -1705,12 +1593,12 @@ namespace __detail\n    *    - __detail::_Hash_code_base\n    *    - __detail::_Hashtable_ebo_helper\n    */\n-  template<typename _Key, typename _Value,\n-\t   typename _ExtractKey, typename _Equal,\n-\t   typename _H1, typename _H2, typename _Hash, typename _Traits>\n-  struct _Hashtable_base\n-  : public _Hash_code_base<_Key, _Value, _ExtractKey, _H1, _H2, _Hash,\n-\t\t\t   _Traits::__hash_cached::value>,\n+  template<typename _Key, typename _Value, typename _ExtractKey,\n+\t   typename _Equal, typename _Hash, typename _RangeHash,\n+\t   typename _Unused, typename _Traits>\n+    struct _Hashtable_base\n+    : public _Hash_code_base<_Key, _Value, _ExtractKey, _Hash, _RangeHash,\n+\t\t\t     _Unused, _Traits::__hash_cached::value>,\n     private _Hashtable_ebo_helper<0, _Equal>\n   {\n   public:\n@@ -1726,30 +1614,29 @@ namespace __detail\n     using __unique_keys = typename __traits_type::__unique_keys;\n \n     using __hash_code_base = _Hash_code_base<_Key, _Value, _ExtractKey,\n-\t\t\t\t\t     _H1, _H2, _Hash,\n+\t\t\t\t\t     _Hash, _RangeHash, _Unused,\n \t\t\t\t\t     __hash_cached::value>;\n \n     using __hash_code = typename __hash_code_base::__hash_code;\n     using __node_type = typename __hash_code_base::__node_type;\n \n-    using iterator = __detail::_Node_iterator<value_type,\n-\t\t\t\t\t      __constant_iterators::value,\n-\t\t\t\t\t      __hash_cached::value>;\n+    using iterator = _Node_iterator<value_type,\n+\t\t\t\t    __constant_iterators::value,\n+\t\t\t\t    __hash_cached::value>;\n \n-    using const_iterator = __detail::_Node_const_iterator<value_type,\n-\t\t\t\t\t\t   __constant_iterators::value,\n-\t\t\t\t\t\t   __hash_cached::value>;\n+    using const_iterator = _Node_const_iterator<value_type,\n+\t\t\t\t\t\t__constant_iterators::value,\n+\t\t\t\t\t\t__hash_cached::value>;\n \n-    using local_iterator = __detail::_Local_iterator<key_type, value_type,\n-\t\t\t\t\t\t  _ExtractKey, _H1, _H2, _Hash,\n-\t\t\t\t\t\t  __constant_iterators::value,\n-\t\t\t\t\t\t     __hash_cached::value>;\n+    using local_iterator = _Local_iterator<key_type, value_type,\n+\t\t\t\t\t_ExtractKey, _Hash, _RangeHash, _Unused,\n+\t\t\t\t\t   __constant_iterators::value,\n+\t\t\t\t\t   __hash_cached::value>;\n \n-    using const_local_iterator = __detail::_Local_const_iterator<key_type,\n-\t\t\t\t\t\t\t\t value_type,\n-\t\t\t\t\t_ExtractKey, _H1, _H2, _Hash,\n+    using const_local_iterator = _Local_const_iterator<key_type, value_type,\n+\t\t\t\t\t_ExtractKey, _Hash, _RangeHash, _Unused,\n \t\t\t\t\t__constant_iterators::value,\n-\t\t\t\t\t__hash_cached::value>;\n+\t\t\t\t\t\t       __hash_cached::value>;\n \n     using __ireturn_type = typename std::conditional<__unique_keys::value,\n \t\t\t\t\t\t     std::pair<iterator, bool>,\n@@ -1784,9 +1671,8 @@ namespace __detail\n \n   protected:\n     _Hashtable_base() = default;\n-    _Hashtable_base(const _ExtractKey& __ex, const _H1& __h1, const _H2& __h2,\n-\t\t    const _Hash& __hash, const _Equal& __eq)\n-    : __hash_code_base(__ex, __h1, __h2, __hash), _EqualEBO(__eq)\n+    _Hashtable_base(const _Hash& __hash, const _Equal& __eq)\n+    : __hash_code_base(__hash), _EqualEBO(__eq)\n     { }\n \n     bool\n@@ -1796,15 +1682,15 @@ namespace __detail\n \t  \"key equality predicate must be invocable with two arguments of \"\n \t  \"key type\");\n       return _Equal_hash_code<__node_type>::_S_equals(__c, *__n)\n-\t&& _M_eq()(__k, this->_M_extract()(__n->_M_v()));\n+\t&& _M_eq()(__k, _ExtractKey{}(__n->_M_v()));\n     }\n \n     bool\n     _M_node_equals(const __node_type* __lhn, const __node_type* __rhn) const\n     {\n       return _Equal_hash_code<__node_type>::_S_node_equals(*__lhn, *__rhn)\n-\t&& _M_eq()(this->_M_extract()(__lhn->_M_v()),\n-\t\t   this->_M_extract()(__rhn->_M_v()));\n+\t&& _M_eq()(_ExtractKey{}(__lhn->_M_v()),\n+\t\t   _ExtractKey{}(__rhn->_M_v()));\n     }\n \n     void\n@@ -1828,33 +1714,34 @@ namespace __detail\n    */\n   template<typename _Key, typename _Value, typename _Alloc,\n \t   typename _ExtractKey, typename _Equal,\n-\t   typename _H1, typename _H2, typename _Hash,\n+\t   typename _Hash, typename _RangeHash, typename _Unused,\n \t   typename _RehashPolicy, typename _Traits,\n \t   bool _Unique_keys = _Traits::__unique_keys::value>\n     struct _Equality;\n \n   /// unordered_map and unordered_set specializations.\n   template<typename _Key, typename _Value, typename _Alloc,\n \t   typename _ExtractKey, typename _Equal,\n-\t   typename _H1, typename _H2, typename _Hash,\n+\t   typename _Hash, typename _RangeHash, typename _Unused,\n \t   typename _RehashPolicy, typename _Traits>\n     struct _Equality<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n-\t\t     _H1, _H2, _Hash, _RehashPolicy, _Traits, true>\n+\t\t     _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits, true>\n     {\n       using __hashtable = _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n-\t\t\t\t     _H1, _H2, _Hash, _RehashPolicy, _Traits>;\n+\t\t\t\t     _Hash, _RangeHash, _Unused,\n+\t\t\t\t     _RehashPolicy, _Traits>;\n \n       bool\n       _M_equal(const __hashtable&) const;\n     };\n \n   template<typename _Key, typename _Value, typename _Alloc,\n \t   typename _ExtractKey, typename _Equal,\n-\t   typename _H1, typename _H2, typename _Hash,\n+\t   typename _Hash, typename _RangeHash, typename _Unused,\n \t   typename _RehashPolicy, typename _Traits>\n     bool\n     _Equality<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n-\t      _H1, _H2, _Hash, _RehashPolicy, _Traits, true>::\n+\t      _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits, true>::\n     _M_equal(const __hashtable& __other) const\n     {\n       using __node_base = typename __hashtable::__node_base;\n@@ -1888,25 +1775,26 @@ namespace __detail\n   /// unordered_multiset and unordered_multimap specializations.\n   template<typename _Key, typename _Value, typename _Alloc,\n \t   typename _ExtractKey, typename _Equal,\n-\t   typename _H1, typename _H2, typename _Hash,\n+\t   typename _Hash, typename _RangeHash, typename _Unused,\n \t   typename _RehashPolicy, typename _Traits>\n     struct _Equality<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n-\t\t     _H1, _H2, _Hash, _RehashPolicy, _Traits, false>\n+\t\t     _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits, false>\n     {\n       using __hashtable = _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n-\t\t\t\t     _H1, _H2, _Hash, _RehashPolicy, _Traits>;\n+\t\t\t\t     _Hash, _RangeHash, _Unused,\n+\t\t\t\t     _RehashPolicy, _Traits>;\n \n       bool\n       _M_equal(const __hashtable&) const;\n     };\n \n   template<typename _Key, typename _Value, typename _Alloc,\n \t   typename _ExtractKey, typename _Equal,\n-\t   typename _H1, typename _H2, typename _Hash,\n+\t   typename _Hash, typename _RangeHash, typename _Unused,\n \t   typename _RehashPolicy, typename _Traits>\n     bool\n     _Equality<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n-\t      _H1, _H2, _Hash, _RehashPolicy, _Traits, false>::\n+\t      _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits, false>::\n     _M_equal(const __hashtable& __other) const\n     {\n       using __node_base = typename __hashtable::__node_base;\n@@ -1920,8 +1808,8 @@ namespace __detail\n \t  std::size_t __x_count = 1;\n \t  auto __itx_end = __itx;\n \t  for (++__itx_end; __itx_end != __this->end()\n-\t\t && __this->key_eq()(_ExtractKey()(*__itx),\n-\t\t\t\t     _ExtractKey()(*__itx_end));\n+\t\t && __this->key_eq()(_ExtractKey{}(*__itx),\n+\t\t\t\t     _ExtractKey{}(*__itx_end));\n \t       ++__itx_end)\n \t    ++__x_count;\n \n@@ -1933,8 +1821,8 @@ namespace __detail\n \t  __node_type* __y_n = static_cast<__node_type*>(__y_prev_n->_M_nxt);\n \t  for (;;)\n \t    {\n-\t      if (__this->key_eq()(_ExtractKey()(__y_n->_M_v()),\n-\t\t\t\t   _ExtractKey()(*__itx)))\n+\t      if (__this->key_eq()(_ExtractKey{}(__y_n->_M_v()),\n+\t\t\t\t   _ExtractKey{}(*__itx)))\n \t\tbreak;\n \n \t      __node_type* __y_ref_n = __y_n;"}, {"sha": "fc96937665a7697eb6621472a4e4d237db87bfb3", "filename": "libstdc++-v3/include/bits/node_handle.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4797a61cc5024fc9adf5918e9bb2b78988f9e4d4/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fnode_handle.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4797a61cc5024fc9adf5918e9bb2b78988f9e4d4/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fnode_handle.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fnode_handle.h?ref=4797a61cc5024fc9adf5918e9bb2b78988f9e4d4", "patch": "@@ -226,7 +226,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n       template<typename _Key2, typename _Value2, typename _ValueAlloc,\n \t       typename _ExtractKey, typename _Equal,\n-\t       typename _H1, typename _H2, typename _Hash,\n+\t       typename _Hash, typename _RangeHash, typename _Unused,\n \t       typename _RehashPolicy, typename _Traits>\n \tfriend class _Hashtable;\n     };\n@@ -278,7 +278,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n       template<typename _Key2, typename _Value2, typename _ValueAlloc,\n \t       typename _ExtractKey, typename _Equal,\n-\t       typename _H1, typename _H2, typename _Hash,\n+\t       typename _Hash, typename _RangeHash, typename _Unused,\n \t       typename _RehashPolicy, typename _Traits>\n \tfriend class _Hashtable;\n     };"}]}