{"sha": "cabc336a5ef33546fa4330972415152e59174ef8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2FiYzMzNmE1ZWYzMzU0NmZhNDMzMDk3MjQxNTE1MmU1OTE3NGVmOA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@markmitchell.com", "date": "1998-09-04T11:31:30Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1998-09-04T11:31:30Z"}, "message": "cp-tree.h (hash_tree_cons_simple): New macro.\n\n\t* cp-tree.h (hash_tree_cons_simple): New macro.\n\t* pt.c (tsubst_arg_types): New function.  Use hash_tree_cons.\n\t(coerce_template_parms): Use make_temp_vec, instead of\n\tmake_tree_vec.  Document this behavior.\n\t(lookup_template_class): Likewise.\n\t(tsubst, cases METHOD_TYPE, FUNCTION_TYPE): Use tsubst_arg_types.\n\tRemove dead code (and add ssertion to check its deadness).  Fix\n\tbug w.r.t. exception specifications.\n\nFrom-SVN: r22233", "tree": {"sha": "ef867aa9935c51a5dcaa6ea21926721ed24b1b81", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ef867aa9935c51a5dcaa6ea21926721ed24b1b81"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cabc336a5ef33546fa4330972415152e59174ef8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cabc336a5ef33546fa4330972415152e59174ef8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cabc336a5ef33546fa4330972415152e59174ef8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cabc336a5ef33546fa4330972415152e59174ef8/comments", "author": null, "committer": null, "parents": [{"sha": "7940acc401ef788bf2e287bd77250a3a125c9e80", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7940acc401ef788bf2e287bd77250a3a125c9e80", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7940acc401ef788bf2e287bd77250a3a125c9e80"}], "stats": {"total": 158, "additions": 85, "deletions": 73}, "files": [{"sha": "1138e872fb7da7a67ee28dc10edb5223c7e5e4ec", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cabc336a5ef33546fa4330972415152e59174ef8/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cabc336a5ef33546fa4330972415152e59174ef8/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=cabc336a5ef33546fa4330972415152e59174ef8", "patch": "@@ -1,3 +1,14 @@\n+1998-09-04  Mark Mitchell  <mark@markmitchell.com>\n+\n+\t* cp-tree.h (hash_tree_cons_simple): New macro.\n+\t* pt.c (tsubst_arg_types): New function.  Use hash_tree_cons.\n+\t(coerce_template_parms): Use make_temp_vec, instead of\n+\tmake_tree_vec.  Document this behavior.\n+\t(lookup_template_class): Likewise.\n+\t(tsubst, cases METHOD_TYPE, FUNCTION_TYPE): Use tsubst_arg_types.  \n+\tRemove dead code (and add ssertion to check its deadness).  Fix\n+\tbug w.r.t. exception specifications.\n+\n 1998-09-03  Jason Merrill  <jason@yorick.cygnus.com>\n \n \t* decl2.c (import_export_vtable): Always make artificials comdat."}, {"sha": "8bf6c5c86216ff2d3f3ee36ef9bebb9a1411ca6d", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cabc336a5ef33546fa4330972415152e59174ef8/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cabc336a5ef33546fa4330972415152e59174ef8/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=cabc336a5ef33546fa4330972415152e59174ef8", "patch": "@@ -3040,6 +3040,8 @@ extern void push_expression_obstack\t\tPROTO((void));\n #define build_scratch_list build_expr_list\n #define make_scratch_vec make_temp_vec\n #define push_scratch_obstack push_expression_obstack\n+#define hash_tree_cons_simple(PURPOSE, VALUE, CHAIN) \\\n+  hash_tree_cons (0, 0, 0, (PURPOSE), (VALUE), (CHAIN))\n \n /* in typeck.c */\n extern tree condition_conversion\t\tPROTO((tree));"}, {"sha": "b27621b89d0206a34f993a84834b6e39edfe1f4b", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 57, "deletions": 73, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cabc336a5ef33546fa4330972415152e59174ef8/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cabc336a5ef33546fa4330972415152e59174ef8/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=cabc336a5ef33546fa4330972415152e59174ef8", "patch": "@@ -126,6 +126,7 @@ static void set_mangled_name_for_template_decl PROTO((tree));\n static int template_class_depth_real PROTO((tree, int));\n static tree tsubst_aggr_type PROTO((tree, tree, tree, int));\n static tree tsubst_decl PROTO((tree, tree, tree, tree));\n+static tree tsubst_arg_types PROTO((tree, tree, tree));\n \n /* We use TREE_VECs to hold template arguments.  If there is only one\n    level of template arguments, then the TREE_VEC contains the\n@@ -2802,7 +2803,10 @@ convert_template_argument (parm, arg, args, complain, i, in_decl)\n    If REQUIRE_ALL_ARGUMENTS is non-zero, all arguments must be\n    provided in ARGLIST, or else trailing parameters must have default\n    values.  If REQUIRE_ALL_ARGUMENTS is zero, we will attempt argument\n-   deduction for any unspecified trailing arguments.  */\n+   deduction for any unspecified trailing arguments.  \n+\n+   The resulting TREE_VEC is allocated on a temporary obstack, and\n+   must be explicitly copied if it will be permanent.  */\n    \n static tree\n coerce_template_parms (parms, args, in_decl,\n@@ -2839,7 +2843,7 @@ coerce_template_parms (parms, args, in_decl,\n       return error_mark_node;\n     }\n \n-  new_inner_args = make_tree_vec (nparms);\n+  new_inner_args = make_temp_vec (nparms);\n   new_args = add_outermost_template_args (args, new_inner_args);\n   for (i = 0; i < nparms; i++)\n     {\n@@ -3300,7 +3304,7 @@ lookup_template_class (d1, arglist, in_decl, context, entering_scope)\n \t  int i;\n \t  int saved_depth = TMPL_ARGS_DEPTH (arglist);\n \n-\t  tree bound_args = make_tree_vec (parm_depth);\n+\t  tree bound_args = make_temp_vec (parm_depth);\n \t  \n \t  for (i = saved_depth,\n \t\t t = DECL_TEMPLATE_PARMS (template); \n@@ -5191,6 +5195,38 @@ tsubst_decl (t, args, type, in_decl)\n }\n \n \n+/* Substitue into the ARG_TYPES of a function type.  */\n+\n+tree\n+tsubst_arg_types (arg_types, args, in_decl)\n+     tree arg_types;\n+     tree args;\n+     tree in_decl;\n+{\n+  tree remaining_arg_types;\n+  tree result;\n+  tree type;\n+\n+  if (!arg_types || arg_types == void_list_node)\n+    return arg_types;\n+  \n+  remaining_arg_types = tsubst_arg_types (TREE_CHAIN (arg_types),\n+\t\t\t\t\t  args, in_decl);\n+\n+  /* We use TYPE_MAIN_VARIANT is because top-level qualifiers don't\n+     matter on function types.  */\n+  type = TYPE_MAIN_VARIANT (type_decays_to \n+\t\t\t    (tsubst (TREE_VALUE (arg_types),\n+\t\t\t\t     args, in_decl)));\n+\n+  /* Note that we do not substitute into default arguments here.  The\n+     standard mandates that they be instantiated only when needed,\n+     which is done in build_over_call.  */\n+  return hash_tree_cons_simple (TREE_PURPOSE (arg_types), type,\n+\t\t\t\tremaining_arg_types);\n+\t\t\t \n+}\n+\n /* Take the tree structure T and replace template parameters used therein\n    with the argument vector ARGS.  IN_DECL is an associated decl for\n    diagnostics.\n@@ -5495,83 +5531,31 @@ tsubst (t, args, in_decl)\n     case FUNCTION_TYPE:\n     case METHOD_TYPE:\n       {\n-\ttree values = TYPE_ARG_TYPES (t);\n-\ttree context = TYPE_CONTEXT (t);\n-\ttree raises = TYPE_RAISES_EXCEPTIONS (t);\n+\ttree arg_types;\n+\ttree raises;\n \ttree fntype;\n \n-\t/* Don't bother recursing if we know it won't change anything.\t*/\n-\tif (values != void_list_node)\n-\t  {\n-\t    /* This should probably be rewritten to use hash_tree_cons for\n-               the memory savings.  */\n-\t    tree first = NULL_TREE;\n-\t    tree last = NULL_TREE;\n-\n-\t    for (; values && values != void_list_node;\n-\t\t values = TREE_CHAIN (values))\n-\t      {\n-\t\ttree value = TYPE_MAIN_VARIANT (type_decays_to\n-\t\t  (tsubst (TREE_VALUE (values), args, in_decl)));\n-\t\t/* Don't instantiate default args unless they are used.\n-\t\t   Handle it in build_over_call instead.  */\n-\t\ttree purpose = TREE_PURPOSE (values);\n-\t\ttree x = build_tree_list (purpose, value);\n-\n-\t\tif (first)\n-\t\t  TREE_CHAIN (last) = x;\n-\t\telse\n-\t\t  first = x;\n-\t\tlast = x;\n-\t      }\n-\n-\t    if (values == void_list_node)\n-\t      TREE_CHAIN (last) = void_list_node;\n-\n-\t    values = first;\n-\t  }\n-\tif (context)\n-\t  context = tsubst (context, args, in_decl);\n-\t/* Could also optimize cases where return value and\n-\t   values have common elements (e.g., T min(const &T, const T&).  */\n-\n-\t/* If the above parameters haven't changed, just return the type.  */\n-\tif (type == TREE_TYPE (t)\n-\t    && values == TYPE_VALUES (t)\n-\t    && context == TYPE_CONTEXT (t))\n-\t  return t;\n+\t/* The TYPE_CONTEXT is not used for function/method types.  */\n+\tmy_friendly_assert (TYPE_CONTEXT (t) == NULL_TREE, 0);\n+\t\n+\t/* Substitue the argument types.  */\n+\targ_types = tsubst_arg_types (TYPE_ARG_TYPES (t), args, in_decl);\n \n \t/* Construct a new type node and return it.  */\n-\tif (TREE_CODE (t) == FUNCTION_TYPE\n-\t    && context == NULL_TREE)\n-\t  {\n-\t    fntype = build_function_type (type, values);\n-\t  }\n-\telse if (context == NULL_TREE)\n-\t  {\n-\t    tree base = tsubst (TREE_TYPE (TREE_VALUE (TYPE_ARG_TYPES (t))),\n-\t\t\t\targs, in_decl);\n-\t    fntype = build_cplus_method_type (base, type,\n-\t\t\t\t\t      TREE_CHAIN (values));\n-\t  }\n-\telse\n-\t  {\n-\t    fntype = make_node (TREE_CODE (t));\n-\t    TREE_TYPE (fntype) = type;\n-\t    TYPE_CONTEXT (fntype) = FROB_CONTEXT (context);\n-\t    TYPE_VALUES (fntype) = values;\n-\t    TYPE_SIZE (fntype) = TYPE_SIZE (t);\n-\t    TYPE_ALIGN (fntype) = TYPE_ALIGN (t);\n-\t    TYPE_MODE (fntype) = TYPE_MODE (t);\n-\t    if (TYPE_METHOD_BASETYPE (t))\n-\t      TYPE_METHOD_BASETYPE (fntype) = tsubst (TYPE_METHOD_BASETYPE (t),\n-\t\t\t\t\t\t      args, in_decl);\n-\t    /* Need to generate hash value.  */\n-\t    my_friendly_abort (84);\n-\t  }\n+\tif (TREE_CODE (t) == FUNCTION_TYPE)\n+\t  fntype = build_function_type (type, arg_types);\n+\telse \n+\t  fntype \n+\t    = build_cplus_method_type (TREE_TYPE (TREE_VALUE (arg_types)),\n+\t\t\t\t       type,\n+\t\t\t\t       TREE_CHAIN (arg_types));\n+\n \tfntype = build_type_variant (fntype,\n \t\t\t\t     TYPE_READONLY (t),\n \t\t\t\t     TYPE_VOLATILE (t));\n+\n+\t/* Substitue the exception specification. */\n+\traises = TYPE_RAISES_EXCEPTIONS (t);\n \tif (raises)\n \t  {\n \t    raises = tsubst (raises, args, in_decl);"}, {"sha": "cdbd6e1feeb8e70a8755167f162704f737bb322b", "filename": "gcc/testsuite/g++.old-deja/g++.eh/tmpl1.C", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cabc336a5ef33546fa4330972415152e59174ef8/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.eh%2Ftmpl1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cabc336a5ef33546fa4330972415152e59174ef8/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.eh%2Ftmpl1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.eh%2Ftmpl1.C?ref=cabc336a5ef33546fa4330972415152e59174ef8", "patch": "@@ -0,0 +1,15 @@\n+template <class T>\n+void f() throw (T)\n+{\n+  throw 7;\n+}\n+\n+\n+int main()\n+{\n+  try {\n+    f<int>();\n+  } catch (...) {\n+    return 0;\n+  }\n+}"}]}