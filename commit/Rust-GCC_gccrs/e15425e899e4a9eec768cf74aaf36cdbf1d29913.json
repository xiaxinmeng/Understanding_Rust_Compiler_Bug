{"sha": "e15425e899e4a9eec768cf74aaf36cdbf1d29913", "node_id": "C_kwDOANBUbNoAKGUxNTQyNWU4OTllNGE5ZWVjNzY4Y2Y3NGFhZjM2Y2RiZjFkMjk5MTM", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2022-02-15T00:43:40Z"}, "committer": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2022-02-15T22:03:27Z"}, "message": "Use GORI to evaluate arguments of a COND_EXPR.\n\nProvide an API into gori to perform a basic evaluation of the arguments of a\nCOND_EXPR if they are in the dependency chain of the condition.\n\n\tPR tree-optimization/104526\n\tgcc/\n\t* gimple-range-fold.cc (fold_using_range::range_of_cond_expr): Call\n\tnew routine.\n\t* gimple-range-gori.cc (range_def_chain::get_def_chain): Force a build\n\tof dependency chain if there isn't one.\n\t(gori_compute::condexpr_adjust): New.\n\t* gimple-range-gori.h (class gori_compute): New prototype.\n\n\tgcc/testsuite/\n\t* gcc.dg/pr104526.c: New.", "tree": {"sha": "19d92086586f3e8f60f478030c89710f2a6f41e9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/19d92086586f3e8f60f478030c89710f2a6f41e9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e15425e899e4a9eec768cf74aaf36cdbf1d29913", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e15425e899e4a9eec768cf74aaf36cdbf1d29913", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e15425e899e4a9eec768cf74aaf36cdbf1d29913", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e15425e899e4a9eec768cf74aaf36cdbf1d29913/comments", "author": null, "committer": null, "parents": [{"sha": "84832cab6e43db7fa10ec53d15f8f8457aa31080", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84832cab6e43db7fa10ec53d15f8f8457aa31080", "html_url": "https://github.com/Rust-GCC/gccrs/commit/84832cab6e43db7fa10ec53d15f8f8457aa31080"}], "stats": {"total": 125, "additions": 124, "deletions": 1}, "files": [{"sha": "2fc8376f52e81103ae7674a57da663d4414e6741", "filename": "gcc/gimple-range-fold.cc", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e15425e899e4a9eec768cf74aaf36cdbf1d29913/gcc%2Fgimple-range-fold.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e15425e899e4a9eec768cf74aaf36cdbf1d29913/gcc%2Fgimple-range-fold.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-fold.cc?ref=e15425e899e4a9eec768cf74aaf36cdbf1d29913", "patch": "@@ -1270,6 +1270,18 @@ fold_using_range::range_of_cond_expr  (irange &r, gassign *s, fur_source &src)\n   src.get_operand (range1, op1);\n   src.get_operand (range2, op2);\n \n+  // Try to see if there is a dependence between the COND and either operand\n+  if (src.gori ())\n+    if (src.gori ()->condexpr_adjust (range1, range2, s, cond, op1, op2, src))\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t{\n+\t  fprintf (dump_file, \"Possible COND_EXPR adjustment. Range op1 : \");\n+\t  range1.dump(dump_file);\n+\t  fprintf (dump_file, \" and Range op2: \");\n+\t  range2.dump(dump_file);\n+\t  fprintf (dump_file, \"\\n\");\n+\t}\n+\n   // If the condition is known, choose the appropriate expression.\n   if (cond_range.singleton_p ())\n     {"}, {"sha": "258da6e72354d38260fdfc1b0b28e1d77f98795b", "filename": "gcc/gimple-range-gori.cc", "status": "modified", "additions": 95, "deletions": 1, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e15425e899e4a9eec768cf74aaf36cdbf1d29913/gcc%2Fgimple-range-gori.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e15425e899e4a9eec768cf74aaf36cdbf1d29913/gcc%2Fgimple-range-gori.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-gori.cc?ref=e15425e899e4a9eec768cf74aaf36cdbf1d29913", "patch": "@@ -334,7 +334,7 @@ range_def_chain::get_def_chain (tree name)\n   unsigned v = SSA_NAME_VERSION (name);\n \n   // If it has already been processed, just return the cached value.\n-  if (has_def_chain (name))\n+  if (has_def_chain (name) && m_def_chain[v].bm)\n     return m_def_chain[v].bm;\n \n   // No definition chain for default defs.\n@@ -1303,6 +1303,100 @@ gori_compute::outgoing_edge_range_p (irange &r, edge e, tree name,\n   return false;\n }\n \n+// Given COND ? OP1 : OP2 with ranges R1 for OP1 and R2 for OP2, Use gori\n+// to further resolve R1 and R2 if there are any dependencies between\n+// OP1 and COND or OP2 and COND.  All values can are to be calculated using SRC\n+// as the origination source location for operands..\n+// Effectively, use COND an the edge condition and solve for OP1 on the true\n+// edge and OP2 on the false edge.\n+\n+bool\n+gori_compute::condexpr_adjust (irange &r1, irange &r2, gimple *, tree cond,\n+\t\t\t       tree op1, tree op2, fur_source &src)\n+{\n+  int_range_max tmp, cond_true, cond_false;\n+  tree ssa1 = gimple_range_ssa_p (op1);\n+  tree ssa2 = gimple_range_ssa_p (op2);\n+  if (!ssa1 && !ssa2)\n+    return false;\n+  if (!COMPARISON_CLASS_P (cond))\n+    return false;\n+  tree type = TREE_TYPE (TREE_OPERAND (cond, 0));\n+  if (type != TREE_TYPE (TREE_OPERAND (cond, 1)))\n+    return false;\n+  range_operator *hand = range_op_handler (TREE_CODE (cond), type);\n+  if (!hand)\n+    return false;\n+\n+  tree c1 = gimple_range_ssa_p (TREE_OPERAND (cond, 0));\n+  tree c2 = gimple_range_ssa_p (TREE_OPERAND (cond, 1));\n+\n+  // Only solve if there is one SSA name in the condition.\n+  if ((!c1 && !c2) || (c1 && c2))\n+    return false;\n+\n+  // Pick up the current values of each part of the condition.\n+  int_range_max cl, cr;\n+  src.get_operand (cl, TREE_OPERAND (cond, 0));\n+  src.get_operand (cr, TREE_OPERAND (cond, 1));\n+\n+  tree cond_name = c1 ? c1 : c2;\n+  gimple *def_stmt = SSA_NAME_DEF_STMT (cond_name);\n+\n+  // Evaluate the value of COND_NAME on the true and false edges, using either\n+  // the op1 or op2 routines based on its location.\n+  if (c1)\n+    {\n+      if (!hand->op1_range (cond_false, type, m_bool_zero, cr))\n+\treturn false;\n+      if (!hand->op1_range (cond_true, type, m_bool_one, cr))\n+\treturn false;\n+      cond_false.intersect (cl);\n+      cond_true.intersect (cl);\n+    }\n+  else\n+    {\n+      if (!hand->op2_range (cond_false, type, m_bool_zero, cl))\n+\treturn false;\n+      if (!hand->op2_range (cond_true, type, m_bool_one, cl))\n+\treturn false;\n+      cond_false.intersect (cr);\n+      cond_true.intersect (cr);\n+    }\n+\n+  unsigned idx;\n+  if ((idx = tracer.header (\"cond_expr evaluation : \")))\n+    {\n+      fprintf (dump_file, \" range1 = \");\n+      r1.dump (dump_file);\n+      fprintf (dump_file, \", range2 = \");\n+      r1.dump (dump_file);\n+      fprintf (dump_file, \"\\n\");\n+    }\n+\n+   // Now solve for SSA1 or SSA2 if they are in the dependency chain.\n+   if (ssa1 && in_chain_p (ssa1, cond_name))\n+    {\n+      if (compute_operand_range (tmp, def_stmt, cond_true, ssa1, src))\n+\tr1.intersect (tmp);\n+    }\n+  if (ssa2 && in_chain_p (ssa2, cond_name))\n+    {\n+      if (compute_operand_range (tmp, def_stmt, cond_false, ssa2, src))\n+\tr2.intersect (tmp);\n+    }\n+  if (idx)\n+    {\n+      tracer.print (idx, \"outgoing: range1 = \");\n+      r1.dump (dump_file);\n+      fprintf (dump_file, \", range2 = \");\n+      r1.dump (dump_file);\n+      fprintf (dump_file, \"\\n\");\n+      tracer.trailer (idx, \"cond_expr\", true, cond_name, cond_true);\n+    }\n+  return true;\n+}\n+\n // Dump what is known to GORI computes to listing file F.\n \n void"}, {"sha": "605884e2e530585792aca83573077ca03256b960", "filename": "gcc/gimple-range-gori.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e15425e899e4a9eec768cf74aaf36cdbf1d29913/gcc%2Fgimple-range-gori.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e15425e899e4a9eec768cf74aaf36cdbf1d29913/gcc%2Fgimple-range-gori.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-gori.h?ref=e15425e899e4a9eec768cf74aaf36cdbf1d29913", "patch": "@@ -158,6 +158,8 @@ class gori_compute : public gori_map\n public:\n   gori_compute (int not_executable_flag = 0);\n   bool outgoing_edge_range_p (irange &r, edge e, tree name, range_query &q);\n+  bool condexpr_adjust (irange &r1, irange &r2, gimple *s, tree cond, tree op1,\n+\t\t\ttree op2, fur_source &src);\n   bool has_edge_range_p (tree name, basic_block bb = NULL);\n   bool has_edge_range_p (tree name, edge e);\n   void dump (FILE *f);"}, {"sha": "a29530829010fb93aed0609aa9e2b34cc596217a", "filename": "gcc/testsuite/gcc.dg/pr104526.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e15425e899e4a9eec768cf74aaf36cdbf1d29913/gcc%2Ftestsuite%2Fgcc.dg%2Fpr104526.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e15425e899e4a9eec768cf74aaf36cdbf1d29913/gcc%2Ftestsuite%2Fgcc.dg%2Fpr104526.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr104526.c?ref=e15425e899e4a9eec768cf74aaf36cdbf1d29913", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-evrp\" } */\n+\n+void foo(void);\n+\n+static int a, b = 1, *c = &b;\n+int main() {\n+  for (; a; a--) {\n+    int d = 2 >> (1 / *c);\n+    if (!d)\n+      foo();\n+  }\n+}\n+\n+/* { dg-final { scan-tree-dump-not \"foo\" \"evrp\" } } */"}]}