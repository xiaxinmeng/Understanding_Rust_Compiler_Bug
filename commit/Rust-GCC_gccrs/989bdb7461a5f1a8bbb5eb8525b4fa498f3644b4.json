{"sha": "989bdb7461a5f1a8bbb5eb8525b4fa498f3644b4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTg5YmRiNzQ2MWE1ZjFhOGJiYjVlYjg1MjViNGZhNDk4ZjM2NDRiNA==", "commit": {"author": {"name": "Georg-Johann Lay", "email": "avr@gjlay.de", "date": "2011-11-21T08:56:44Z"}, "committer": {"name": "Georg-Johann Lay", "email": "gjl@gcc.gnu.org", "date": "2011-11-21T08:56:44Z"}, "message": "re PR target/49313 (Inefficient libgcc implementations for avr)\n\n\tPR target/49313\n\t* config/avr/t-avr (LIB2FUNCS_EXCLUDE): Add _moddi3, _umoddi3.\n\t(LIB1ASMFUNCS): Add _divdi3, _udivdi3, _udivmod64, _negdi2.\n\t* config/avr/lib1funcs.S (wmov): New assembler macro.\n\t(__umoddi3, __udivdi3, __udivdi3_umoddi3): New functions.\n\t(__moddi3, __divdi3, __divdi3_moddi3): New functions.\n\t(__udivmod64): New function.\n\t(__negdi2): New function.\n\nFrom-SVN: r181551", "tree": {"sha": "6006b3c6d6abfcab51a4c6064c9c392632c164bf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6006b3c6d6abfcab51a4c6064c9c392632c164bf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/989bdb7461a5f1a8bbb5eb8525b4fa498f3644b4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/989bdb7461a5f1a8bbb5eb8525b4fa498f3644b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/989bdb7461a5f1a8bbb5eb8525b4fa498f3644b4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/989bdb7461a5f1a8bbb5eb8525b4fa498f3644b4/comments", "author": null, "committer": {"login": "sprintersb", "id": 8905355, "node_id": "MDQ6VXNlcjg5MDUzNTU=", "avatar_url": "https://avatars.githubusercontent.com/u/8905355?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sprintersb", "html_url": "https://github.com/sprintersb", "followers_url": "https://api.github.com/users/sprintersb/followers", "following_url": "https://api.github.com/users/sprintersb/following{/other_user}", "gists_url": "https://api.github.com/users/sprintersb/gists{/gist_id}", "starred_url": "https://api.github.com/users/sprintersb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sprintersb/subscriptions", "organizations_url": "https://api.github.com/users/sprintersb/orgs", "repos_url": "https://api.github.com/users/sprintersb/repos", "events_url": "https://api.github.com/users/sprintersb/events{/privacy}", "received_events_url": "https://api.github.com/users/sprintersb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "515a0cfc80164c69fe9240d0002411fe32dbf241", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/515a0cfc80164c69fe9240d0002411fe32dbf241", "html_url": "https://github.com/Rust-GCC/gccrs/commit/515a0cfc80164c69fe9240d0002411fe32dbf241"}], "stats": {"total": 371, "additions": 371, "deletions": 0}, "files": [{"sha": "b3c8d66b072a4c67de6a8775f9ebac40f0ff1a48", "filename": "libgcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/989bdb7461a5f1a8bbb5eb8525b4fa498f3644b4/libgcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/989bdb7461a5f1a8bbb5eb8525b4fa498f3644b4/libgcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FChangeLog?ref=989bdb7461a5f1a8bbb5eb8525b4fa498f3644b4", "patch": "@@ -1,3 +1,14 @@\n+2011-11-21  Georg-Johann Lay  <avr@gjlay.de>\n+\n+\tPR target/49313\n+\t* config/avr/t-avr (LIB2FUNCS_EXCLUDE): Add _moddi3, _umoddi3.\n+\t(LIB1ASMFUNCS): Add _divdi3, _udivdi3, _udivmod64, _negdi2.\n+\t* config/avr/lib1funcs.S (wmov): New assembler macro.\n+\t(__umoddi3, __udivdi3, __udivdi3_umoddi3): New functions.\n+\t(__moddi3, __divdi3, __divdi3_moddi3): New functions.\n+\t(__udivmod64): New function.\n+\t(__negdi2): New function.\n+\n 2011-11-21  Gerald Pfeifer  <gerald@pfeifer.com>\n \n \t* config.host (*-*-freebsd[12], *-*-freebsd[12].*,"}, {"sha": "c592c4caa5de350d2f664f349092641d8f1ab91e", "filename": "libgcc/config/avr/lib1funcs.S", "status": "modified", "additions": 356, "deletions": 0, "changes": 356, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/989bdb7461a5f1a8bbb5eb8525b4fa498f3644b4/libgcc%2Fconfig%2Favr%2Flib1funcs.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/989bdb7461a5f1a8bbb5eb8525b4fa498f3644b4/libgcc%2Fconfig%2Favr%2Flib1funcs.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Favr%2Flib1funcs.S?ref=989bdb7461a5f1a8bbb5eb8525b4fa498f3644b4", "patch": "@@ -61,6 +61,15 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #endif\n \t.endm\n \n+.macro\twmov  r_dest, r_src\n+#if defined (__AVR_HAVE_MOVW__)\n+    movw \\r_dest,   \\r_src\n+#else\n+    mov \\r_dest,    \\r_src\n+    mov \\r_dest+1,  \\r_src+1\n+#endif\n+.endm\n+\n #if defined (__AVR_HAVE_JMP_CALL__)\n #define XCALL call\n #define XJMP  jmp\n@@ -846,6 +855,352 @@ __divmodsi4_exit:\n ENDF __divmodsi4\n #endif /* defined (L_divmodsi4) */\n \n+\n+/*******************************************************\n+       Division 64 / 64\n+       Modulo   64 % 64\n+*******************************************************/\n+\n+;; Use Speed-optimized Version on \"big\" Devices, i.e. Devices with\n+;; at least 16k of Program Memory.  For smaller Devices, depend\n+;; on MOVW.\n+\n+#if defined (__AVR_HAVE_JMP_CALL__)\n+#   define SPEED_DIV 8\n+#elif defined (__AVR_HAVE_MOVW__)\n+#   define SPEED_DIV 16\n+#else\n+#   define SPEED_DIV 0\n+#endif\n+\n+;; A[0..7]: In: Dividend;\n+;; Out: Quotient  (T = 0)\n+;; Out: Remainder (T = 1)\n+#define A0  18\n+#define A1  A0+1\n+#define A2  A0+2\n+#define A3  A0+3\n+#define A4  A0+4\n+#define A5  A0+5\n+#define A6  A0+6\n+#define A7  A0+7\n+\n+;; B[0..7]: In: Divisor;   Out: Clobber\n+#define B0  10\n+#define B1  B0+1\n+#define B2  B0+2\n+#define B3  B0+3\n+#define B4  B0+4\n+#define B5  B0+5\n+#define B6  B0+6\n+#define B7  B0+7\n+\n+;; C[0..7]: Expand remainder;  Out: Remainder (unused)\n+#define C0  8\n+#define C1  C0+1\n+#define C2  30\n+#define C3  C2+1\n+#define C4  28\n+#define C5  C4+1\n+#define C6  26\n+#define C7  C6+1\n+\n+;; Holds Signs during Division Routine\n+#define SS      __tmp_reg__\n+\n+;; Bit-Counter in Division Routine\n+#define R_cnt   __zero_reg__\n+\n+;; Scratch Register for Negation\n+#define NN      r31\n+\n+#if defined (L_udivdi3)\n+\n+;; R25:R18 = R24:R18  umod  R17:R10\n+;; Ordinary ABI-Function\n+\n+DEFUN __umoddi3\n+    set\n+    rjmp __udivdi3_umoddi3\n+ENDF __umoddi3\n+\n+;; R25:R18 = R24:R18  udiv  R17:R10\n+;; Ordinary ABI-Function\n+\n+DEFUN __udivdi3\n+    clt\n+ENDF __udivdi3\n+\n+DEFUN __udivdi3_umoddi3\n+    push    C0\n+    push    C1\n+    push    C4\n+    push    C5\n+    XCALL   __udivmod64\n+    pop     C5\n+    pop     C4\n+    pop     C1\n+    pop     C0\n+    ret\n+ENDF __udivdi3_umoddi3\n+#endif /* L_udivdi3 */\n+\n+#if defined (L_udivmod64)\n+\n+;; Worker Routine for 64-Bit unsigned Quotient and Remainder Computation\n+;; No Registers saved/restored; the Callers will take Care.\n+;; Preserves B[] and T-flag\n+;; T = 0: Compute Quotient  in A[]\n+;; T = 1: Compute Remainder in A[] and shift SS one Bit left\n+\n+DEFUN __udivmod64\n+\n+    ;; Clear Remainder (C6, C7 will follow)\n+    clr     C0\n+    clr     C1\n+    wmov    C2, C0\n+    wmov    C4, C0\n+    ldi     C7, 64\n+\n+#if SPEED_DIV == 0 || SPEED_DIV == 16\n+    ;; Initialize Loop-Counter\n+    mov     R_cnt, C7\n+    wmov    C6, C0\n+#endif /* SPEED_DIV */\n+\n+#if SPEED_DIV == 8\n+\n+    push    A7\n+    clr     C6\n+\n+1:  ;; Compare shifted Devidend against Divisor\n+    ;; If -- even after Shifting -- it is smaller...\n+    CP  A7,B0  $  cpc C0,B1  $  cpc C1,B2  $  cpc C2,B3  \n+    cpc C3,B4  $  cpc C4,B5  $  cpc C5,B6  $  cpc C6,B7  \n+    brcc    2f\n+\n+    ;; ...then we can subtract it.  Thus, it is legal to shift left\n+               $  mov C6,C5  $  mov C5,C4  $  mov C4,C3\n+    mov C3,C2  $  mov C2,C1  $  mov C1,C0  $  mov C0,A7\n+    mov A7,A6  $  mov A6,A5  $  mov A5,A4  $  mov A4,A3\n+    mov A3,A2  $  mov A2,A1  $  mov A1,A0  $  clr A0\n+\n+    ;; 8 Bits are done\n+    subi    C7, 8\n+    brne    1b\n+\n+    ;; Shifted 64 Bits:  A7 has traveled to C7\n+    pop     C7\n+    ;; Divisor is greater than Dividend. We have:\n+    ;; A[] % B[] = A[]\n+    ;; A[] / B[] = 0\n+    ;; Thus, we can return immediately\n+    rjmp    5f\n+\n+2:  ;; Initialze Bit-Counter with Number of Bits still to be performed\n+    mov     R_cnt, C7\n+\n+    ;; Push of A7 is not needed because C7 is still 0\n+    pop     C7\n+    clr     C7\n+\n+#elif  SPEED_DIV == 16\n+\n+    ;; Compare shifted Dividend against Divisor\n+    cp      A7, B3\n+    cpc     C0, B4\n+    cpc     C1, B5\n+    cpc     C2, B6\n+    cpc     C3, B7\n+    brcc    2f\n+\n+    ;; Divisor is greater than shifted Dividen: We can shift the Dividend\n+    ;; and it is still smaller than the Divisor --> Shift one 32-Bit Chunk\n+    wmov  C2,A6  $  wmov C0,A4\n+    wmov  A6,A2  $  wmov A4,A0\n+    wmov  A2,C6  $  wmov A0,C4\n+\n+    ;; Set Bit Counter to 32\n+    lsr     R_cnt\n+2:\n+#elif SPEED_DIV\n+#error SPEED_DIV = ?\n+#endif /* SPEED_DIV */\n+\n+;; The very Division + Remainder Routine\n+\n+3:  ;; Left-shift Dividend...\n+    lsl A0     $  rol A1     $  rol A2     $  rol A3\n+    rol A4     $  rol A5     $  rol A6     $  rol A7\n+\n+    ;; ...into Remainder\n+    rol C0     $  rol C1     $  rol C2     $  rol C3\n+    rol C4     $  rol C5     $  rol C6     $  rol C7\n+\n+    ;; Compare Remainder and Divisor\n+    CP  C0,B0  $  cpc C1,B1  $  cpc C2,B2  $  cpc C3,B3\n+    cpc C4,B4  $  cpc C5,B5  $  cpc C6,B6  $  cpc C7,B7\n+\n+    brcs 4f\n+\n+    ;; Divisor fits into Remainder:  Subtract it from Remainder...\n+    SUB C0,B0  $  sbc C1,B1  $  sbc C2,B2  $  sbc C3,B3\n+    sbc C4,B4  $  sbc C5,B5  $  sbc C6,B6  $  sbc C7,B7\n+\n+    ;; ...and set according Bit in the upcoming Quotient\n+    ;; The Bit will travel to its final Position\n+    ori A0, 1\n+\n+4:  ;; This Bit is done\n+    dec     R_cnt\n+    brne    3b\n+    ;; __zero_reg__ is 0 again\n+\n+    ;; T = 0: We are fine with the Quotient in A[]\n+    ;; T = 1: Copy Remainder to A[]\n+5:  brtc    6f\n+    wmov    A0, C0\n+    wmov    A2, C2\n+    wmov    A4, C4\n+    wmov    A6, C6\n+    ;; Move the Sign of the Result to SS.7\n+    lsl     SS\n+\n+6:  ret\n+\n+ENDF __udivmod64\n+#endif /* L_udivmod64 */\n+    \n+\n+#if defined (L_divdi3)\n+\n+;; R25:R18 = R24:R18  mod  R17:R10\n+;; Ordinary ABI-Function\n+\n+DEFUN __moddi3\n+    set\n+    rjmp    __divdi3_moddi3\n+ENDF __moddi3\n+\n+;; R25:R18 = R24:R18  div  R17:R10\n+;; Ordinary ABI-Function\n+\n+DEFUN __divdi3\n+    clt\n+ENDF __divdi3\n+\n+DEFUN  __divdi3_moddi3\n+#if SPEED_DIV\n+    mov     r31, A7\n+    or      r31, B7\n+    brmi    0f\n+    ;; Both Signs are 0:  the following Complexitiy is not needed\n+    XJMP    __udivdi3_umoddi3\n+#endif /* SPEED_DIV */    \n+\n+0:  ;; The Prologue\n+    ;; Save Z = 12 Registers:  Y, 17...8\n+    ;; No Frame needed (X = 0)\n+    clr r26\n+    clr r27\n+    ldi r30, lo8(gs(1f))\n+    ldi r31, hi8(gs(1f))\n+    XJMP __prologue_saves__ + ((18 - 12) * 2)\n+\n+1:  ;; SS.7 will contain the Sign of the Quotient  (A.sign * B.sign)\n+    ;; SS.6 will contain the Sign of the Remainder (A.sign)\n+    mov     SS, A7\n+    asr     SS\n+    ;; Adjust Dividend's Sign as needed\n+#if SPEED_DIV\n+    ;; Compiling for Speed we know that at least one Sign must be < 0\n+    ;; Thus, if A[] >= 0 then we know B[] < 0\n+    brpl    22f\n+#else\n+    brpl    21f\n+#endif /* SPEED_DIV */\n+   \n+    XCALL   __negdi2\n+\n+    ;; Adjust Divisor's Sign and SS.7 as needed\n+21: tst     B7\n+    brpl    3f\n+22: ldi     NN, 1 << 7\n+    eor     SS, NN\n+\n+    ldi NN, -1\n+    com B4     $  com B5     $  com B6     $  com B7\n+               $  com B1     $  com B2     $  com B3\n+    NEG B0\n+               $  sbc B1,NN  $  sbc B2,NN  $  sbc B3,NN\n+    sbc B4,NN  $  sbc B5,NN  $  sbc B6,NN  $  sbc B7,NN\n+\n+3:  ;; Do the unsigned 64-Bit Division/Modulo (depending on T-flag)\n+    XCALL   __udivmod64\n+\n+    ;; Adjust Result's Sign\n+#ifdef __AVR_ERRATA_SKIP_JMP_CALL__\n+    tst     SS\n+    brpl    4f\n+#else\n+    sbrc    SS, 7\n+#endif /* __AVR_HAVE_JMP_CALL__ */\n+    XCALL   __negdi2\n+\n+4:  ;; Epilogue: Restore the Z = 12 Registers and return\n+    in r28, __SP_L__\n+    in r29, __SP_H__\n+    ldi r30, 12\n+    XJMP __epilogue_restores__ + ((18 - 12) * 2)\n+\n+ENDF __divdi3_moddi3\n+\n+#undef R_cnt\n+#undef SS\n+#undef NN\n+\n+#endif /* L_divdi3 */\n+\n+#if defined (L_negdi2)\n+DEFUN __negdi2\n+\n+    com  A4    $  com  A5    $  com  A6    $  com  A7\n+               $  com  A1    $  com  A2    $  com  A3\n+    NEG  A0\n+               $  sbci A1,-1 $  sbci A2,-1 $  sbci A3,-1\n+    sbci A4,-1 $  sbci A5,-1 $  sbci A6,-1 $  sbci A7,-1\n+    ret\n+\n+ENDF __negdi2\n+#endif /* L_negdi2 */\n+\n+#undef C7\n+#undef C6\n+#undef C5\n+#undef C4\n+#undef C3\n+#undef C2\n+#undef C1\n+#undef C0\n+\n+#undef B7\n+#undef B6\n+#undef B5\n+#undef B4\n+#undef B3\n+#undef B2\n+#undef B1\n+#undef B0\n+\n+#undef A7\n+#undef A6\n+#undef A5\n+#undef A4\n+#undef A3\n+#undef A2\n+#undef A1\n+#undef A0\n+\n \f\n .section .text.libgcc.prologue, \"ax\", @progbits\n     \n@@ -854,6 +1209,7 @@ ENDF __divmodsi4\n  **********************************/\n #if defined (L_prologue)\n \n+;; This function does not clobber T-flag; 64-bit division relies on it\n DEFUN __prologue_saves__\n \tpush r2\n \tpush r3"}, {"sha": "b5c8d05186a14dd6f651a215724f0d013c41bab3", "filename": "libgcc/config/avr/t-avr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/989bdb7461a5f1a8bbb5eb8525b4fa498f3644b4/libgcc%2Fconfig%2Favr%2Ft-avr", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/989bdb7461a5f1a8bbb5eb8525b4fa498f3644b4/libgcc%2Fconfig%2Favr%2Ft-avr", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Favr%2Ft-avr?ref=989bdb7461a5f1a8bbb5eb8525b4fa498f3644b4", "patch": "@@ -15,6 +15,9 @@ LIB1ASMFUNCS = \\\n \t_divmodpsi4 _udivmodpsi4 \\\n \t_udivmodsi4 \\\n \t_divmodsi4 \\\n+\t_divdi3 _udivdi3 \\\n+\t_udivmod64 \\\n+\t_negdi2 \\\n \t_prologue \\\n \t_epilogue \\\n \t_exit \\\n@@ -50,6 +53,7 @@ LIB1ASMFUNCS = \\\n \t_fmul _fmuls _fmulsu\n \n LIB2FUNCS_EXCLUDE = \\\n+\t_moddi3 _umoddi3 \\\n \t_clz\n \n # We do not have the DF type."}]}