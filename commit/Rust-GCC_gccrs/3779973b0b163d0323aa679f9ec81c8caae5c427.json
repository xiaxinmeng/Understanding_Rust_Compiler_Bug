{"sha": "3779973b0b163d0323aa679f9ec81c8caae5c427", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mzc3OTk3M2IwYjE2M2QwMzIzYWE2NzlmOWVjODFjOGNhYWU1YzQyNw==", "commit": {"author": {"name": "John David Anglin", "email": "dave.anglin@nrc-cnrc.gc.ca", "date": "2005-12-28T17:13:56Z"}, "committer": {"name": "John David Anglin", "email": "danglin@gcc.gnu.org", "date": "2005-12-28T17:13:56Z"}, "message": "locks.h (compare_and_swap): Add ldcw semaphore to make operation atomic.\n\n\t* sysdep/pa/locks.h (compare_and_swap): Add ldcw semaphore to make\n\toperation atomic.\n\nFrom-SVN: r109110", "tree": {"sha": "43fb807f36566e859f3fd6271273ce6af4baa761", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/43fb807f36566e859f3fd6271273ce6af4baa761"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3779973b0b163d0323aa679f9ec81c8caae5c427", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3779973b0b163d0323aa679f9ec81c8caae5c427", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3779973b0b163d0323aa679f9ec81c8caae5c427", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3779973b0b163d0323aa679f9ec81c8caae5c427/comments", "author": null, "committer": null, "parents": [{"sha": "3eb046081bda6816fa9a59efa63cb2a1db7f4595", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3eb046081bda6816fa9a59efa63cb2a1db7f4595", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3eb046081bda6816fa9a59efa63cb2a1db7f4595"}], "stats": {"total": 67, "additions": 52, "deletions": 15}, "files": [{"sha": "cff2e26f6fa19ce4eaa723ab73ed8cefafeff17a", "filename": "libjava/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3779973b0b163d0323aa679f9ec81c8caae5c427/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3779973b0b163d0323aa679f9ec81c8caae5c427/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=3779973b0b163d0323aa679f9ec81c8caae5c427", "patch": "@@ -1,3 +1,8 @@\n+2005-12-28  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>\n+\n+\t* sysdep/pa/locks.h (compare_and_swap): Add ldcw semaphore to make\n+\toperation atomic.\n+\n 2005-12-22  Andrew Haley  <aph@redhat.com>\n \n \tPR java/25535"}, {"sha": "4edc2d71626f1ceba3a11e590ff1badc94caf426", "filename": "libjava/sysdep/pa/locks.h", "status": "modified", "additions": 47, "deletions": 15, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3779973b0b163d0323aa679f9ec81c8caae5c427/libjava%2Fsysdep%2Fpa%2Flocks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3779973b0b163d0323aa679f9ec81c8caae5c427/libjava%2Fsysdep%2Fpa%2Flocks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fsysdep%2Fpa%2Flocks.h?ref=3779973b0b163d0323aa679f9ec81c8caae5c427", "patch": "@@ -1,6 +1,6 @@\n-// locks.h - Thread synchronization primitives. PARISC implementation.\n+// locks.h - Thread synchronization primitives. PA-RISC implementation.\n \n-/* Copyright (C) 2002  Free Software Foundation\n+/* Copyright (C) 2002, 2005  Free Software Foundation\n \n    This file is part of libgcj.\n \n@@ -11,30 +11,62 @@ details.  */\n #ifndef __SYSDEP_LOCKS_H__\n #define __SYSDEP_LOCKS_H__\n \n-typedef size_t obj_addr_t;\t/* Integer type big enough for object\t*/\n-\t\t\t\t/* address.\t\t\t\t*/\n+// Integer type big enough for object address.\n+typedef size_t obj_addr_t;\n \n-// Atomically replace *addr by new_val if it was initially equal to old.\n-// Return true if the comparison succeeded.\n+template<int _Inst>\n+  struct _pa_jv_cas_lock\n+  {\n+    static volatile int _S_pa_jv_cas_lock;\n+  };\n+\n+template<int _Inst>\n+volatile int\n+_pa_jv_cas_lock<_Inst>::_S_pa_jv_cas_lock __attribute__ ((aligned (16))) = 1;\n+\n+// Because of the lack of weak support when using the hpux som\n+// linker, we explicitly instantiate the atomicity lock.\n+template volatile int _pa_jv_cas_lock<0>::_S_pa_jv_cas_lock;\n+\n+// Atomically replace *addr by new_val if it was initially equal to old_val.\n+// Return true if the comparison is successful.\n // Assumed to have acquire semantics, i.e. later memory operations\n // cannot execute before the compare_and_swap finishes.\n+// The following implementation is atomic but it can deadlock\n+// (e.g., if a thread dies holding the lock).\n inline static bool\n+__attribute__ ((__unused__))\n compare_and_swap(volatile obj_addr_t *addr,\n-\t \t obj_addr_t old,\n+\t \t obj_addr_t old_val,\n \t\t obj_addr_t new_val) \n {\n-  /* FIXME: not atomic */\n-  obj_addr_t prev;\n+  bool result;\n+  int tmp;\n+  volatile int& lock = _pa_jv_cas_lock<0>::_S_pa_jv_cas_lock;\n \n-  if ((prev = *addr) == old)\n-    {\n-      *addr = new_val;\n-      return true;\n-    }\n+  __asm__ __volatile__ (\"ldcw 0(%1),%0\\n\\t\"\n+\t\t\t\"cmpib,<>,n 0,%0,.+20\\n\\t\"\n+\t\t\t\"ldw 0(%1),%0\\n\\t\"\n+\t\t\t\"cmpib,= 0,%0,.-4\\n\\t\"\n+\t\t\t\"nop\\n\\t\"\n+\t\t\t\"b,n .-20\"\n+\t\t\t: \"=&r\" (tmp)\n+\t\t\t: \"r\" (&lock)\n+\t\t\t: \"memory\");\n+\n+  if (*addr != old_val)\n+    result = false;\n   else\n     {\n-      return false;\n+      *addr = new_val;\n+      result = true;\n     }\n+\n+  /* Reset lock with PA 2.0 \"ordered\" store.  */\n+  __asm__ __volatile__ (\"stw,ma %1,0(%0)\"\n+\t\t\t: : \"r\" (&lock), \"r\" (tmp) : \"memory\");\n+\n+  return result;\n }\n \n // Set *addr to new_val with release semantics, i.e. making sure"}]}