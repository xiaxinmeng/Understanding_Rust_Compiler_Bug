{"sha": "7f78718b7958f603d50d5c30fd8735d73900bd1f", "node_id": "C_kwDOANBUbNoAKDdmNzg3MThiNzk1OGY2MDNkNTBkNWMzMGZkODczNWQ3MzkwMGJkMWY", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2021-10-07T13:51:18Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2021-10-07T20:12:32Z"}, "message": "libstdc++: Move C++14 <chrono> components to new <bits/chrono.h> header\n\nThis moves the \"classic\" contents of <chrono> to a new header, so that\n<future>, <thread> etc. can get use durations and clocks without\ncalendar types, time zones, and chrono I/O.\n\nlibstdc++-v3/ChangeLog:\n\n\t* include/Makefile.am: Add new header.\n\t* include/Makefile.in: Regenerate.\n\t* include/std/chrono (duration, time_point, system_clock)\n\t(steady_clock, high_resolution_clock, chrono_literals, sys_time)\n\t(file_clock, file_time): Move to ...\n\t* include/bits/chrono.h: New file.\n\t* include/bits/atomic_futex.h: Include new header instead of\n\t<chrono>.\n\t* include/bits/atomic_timed_wait.h: Likewise.\n\t* include/bits/fs_fwd.h: Likewise.\n\t* include/bits/semaphore_base.h: Likewise.\n\t* include/bits/this_thread_sleep.h: Likewise.\n\t* include/bits/unique_lock.h: Likewise.\n\t* include/experimental/bits/fs_fwd.h: Likewise.\n\t* include/experimental/chrono: Likewise.\n\t* include/experimental/io_context: Likewise.\n\t* include/experimental/netfwd: Likewise.\n\t* include/experimental/timer: Likewise.\n\t* include/std/condition_variable: Likewise.\n\t* include/std/mutex: Likewise.\n\t* include/std/shared_mutex: Likewise.", "tree": {"sha": "2f0b4779e0a91a3010c85a0e59d37bb510528e08", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2f0b4779e0a91a3010c85a0e59d37bb510528e08"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7f78718b7958f603d50d5c30fd8735d73900bd1f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f78718b7958f603d50d5c30fd8735d73900bd1f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7f78718b7958f603d50d5c30fd8735d73900bd1f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f78718b7958f603d50d5c30fd8735d73900bd1f/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1848fbf0546abe2a7443e25a418eff7895a2ebb5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1848fbf0546abe2a7443e25a418eff7895a2ebb5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1848fbf0546abe2a7443e25a418eff7895a2ebb5"}], "stats": {"total": 2809, "additions": 1434, "deletions": 1375}, "files": [{"sha": "0e43f147591d7ee1e8a6ed4929d0faeeabfbe431", "filename": "libstdc++-v3/include/Makefile.am", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f78718b7958f603d50d5c30fd8735d73900bd1f/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f78718b7958f603d50d5c30fd8735d73900bd1f/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.am?ref=7f78718b7958f603d50d5c30fd8735d73900bd1f", "patch": "@@ -117,6 +117,7 @@ bits_headers = \\\n \t${bits_srcdir}/c++0x_warning.h \\\n \t${bits_srcdir}/char_traits.h \\\n \t${bits_srcdir}/charconv.h \\\n+\t${bits_srcdir}/chrono.h \\\n \t${bits_srcdir}/codecvt.h \\\n \t${bits_srcdir}/concept_check.h \\\n \t${bits_srcdir}/cow_string.h \\"}, {"sha": "0571a631bc9f084d33a9cc758fdb9d774363f15d", "filename": "libstdc++-v3/include/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f78718b7958f603d50d5c30fd8735d73900bd1f/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f78718b7958f603d50d5c30fd8735d73900bd1f/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.in?ref=7f78718b7958f603d50d5c30fd8735d73900bd1f", "patch": "@@ -467,6 +467,7 @@ bits_headers = \\\n \t${bits_srcdir}/c++0x_warning.h \\\n \t${bits_srcdir}/char_traits.h \\\n \t${bits_srcdir}/charconv.h \\\n+\t${bits_srcdir}/chrono.h \\\n \t${bits_srcdir}/codecvt.h \\\n \t${bits_srcdir}/concept_check.h \\\n \t${bits_srcdir}/cow_string.h \\"}, {"sha": "41c59c4c64df40a10db4a17b5356eeeab780b363", "filename": "libstdc++-v3/include/bits/atomic_futex.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f78718b7958f603d50d5c30fd8735d73900bd1f/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fatomic_futex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f78718b7958f603d50d5c30fd8735d73900bd1f/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fatomic_futex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fatomic_futex.h?ref=7f78718b7958f603d50d5c30fd8735d73900bd1f", "patch": "@@ -32,13 +32,12 @@\n \n #pragma GCC system_header\n \n-#include <bits/c++config.h>\n #include <atomic>\n-#include <chrono>\n #if ! (defined(_GLIBCXX_HAVE_LINUX_FUTEX) && ATOMIC_INT_LOCK_FREE > 1)\n #include <mutex>\n #include <condition_variable>\n #endif\n+#include <bits/chrono.h>\n \n #ifndef _GLIBCXX_ALWAYS_INLINE\n #define _GLIBCXX_ALWAYS_INLINE inline __attribute__((__always_inline__))"}, {"sha": "64c1ba62a3efd9cdb1d72c6fa7dc2583fb3d1967", "filename": "libstdc++-v3/include/bits/atomic_timed_wait.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f78718b7958f603d50d5c30fd8735d73900bd1f/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fatomic_timed_wait.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f78718b7958f603d50d5c30fd8735d73900bd1f/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fatomic_timed_wait.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fatomic_timed_wait.h?ref=7f78718b7958f603d50d5c30fd8735d73900bd1f", "patch": "@@ -37,8 +37,7 @@\n #if __cpp_lib_atomic_wait\n #include <bits/functional_hash.h>\n #include <bits/this_thread_sleep.h>\n-\n-#include <chrono>\n+#include <bits/chrono.h>\n \n #ifdef _GLIBCXX_HAVE_LINUX_FUTEX\n #include <exception> // std::terminate"}, {"sha": "956af059ad38fd828b5d831810c70665db2173b9", "filename": "libstdc++-v3/include/bits/chrono.h", "status": "added", "additions": 1392, "deletions": 0, "changes": 1392, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f78718b7958f603d50d5c30fd8735d73900bd1f/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fchrono.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f78718b7958f603d50d5c30fd8735d73900bd1f/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fchrono.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fchrono.h?ref=7f78718b7958f603d50d5c30fd8735d73900bd1f", "patch": "@@ -0,0 +1,1392 @@\n+// chrono::duration and chrono::time_point -*- C++ -*-\n+\n+// Copyright (C) 2008-2021 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+/** @file include/bits/chrono.h\n+ *  This is an internal header file, included by other library headers.\n+ *  Do not attempt to use it directly. @headername{chrono}\n+ */\n+\n+#ifndef _GLIBCXX_CHRONO_H\n+#define _GLIBCXX_CHRONO_H 1\n+\n+#pragma GCC system_header\n+\n+#if __cplusplus >= 201103L\n+\n+#include <ratio>\n+#include <type_traits>\n+#include <limits>\n+#include <ctime>\n+#include <bits/parse_numbers.h> // for literals support.\n+#if __cplusplus >= 202002L\n+# include <concepts>\n+# include <compare>\n+#endif\n+\n+namespace std _GLIBCXX_VISIBILITY(default)\n+{\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+\n+#if __cplusplus >= 201703L\n+  namespace filesystem { struct __file_clock; };\n+#endif\n+\n+  namespace chrono\n+  {\n+    /// @addtogroup chrono\n+    /// @{\n+\n+    /// `chrono::duration` represents a distance between two points in time\n+    template<typename _Rep, typename _Period = ratio<1>>\n+      struct duration;\n+\n+    /// `chrono::time_point` represents a point in time as measured by a clock\n+    template<typename _Clock, typename _Dur = typename _Clock::duration>\n+      struct time_point;\n+    /// @}\n+  }\n+\n+  /// @addtogroup chrono\n+  /// @{\n+\n+  // 20.11.4.3 specialization of common_type (for duration, sfinae-friendly)\n+\n+  /// @cond undocumented\n+\n+  template<typename _CT, typename _Period1, typename _Period2, typename = void>\n+    struct __duration_common_type\n+    { };\n+\n+  template<typename _CT, typename _Period1, typename _Period2>\n+    struct __duration_common_type<_CT, _Period1, _Period2,\n+\t\t\t\t  __void_t<typename _CT::type>>\n+    {\n+    private:\n+      using __gcd_num = __static_gcd<_Period1::num, _Period2::num>;\n+      using __gcd_den = __static_gcd<_Period1::den, _Period2::den>;\n+      using __cr = typename _CT::type;\n+      using __r = ratio<__gcd_num::value,\n+\t\t\t(_Period1::den / __gcd_den::value) * _Period2::den>;\n+\n+    public:\n+      using type = chrono::duration<__cr, typename __r::type>;\n+    };\n+\n+  /// @endcond\n+\n+  /// @{\n+  /// @relates chrono::duration\n+\n+  /// Specialization of common_type for chrono::duration types.\n+  template<typename _Rep1, typename _Period1, typename _Rep2, typename _Period2>\n+    struct common_type<chrono::duration<_Rep1, _Period1>,\n+\t\t       chrono::duration<_Rep2, _Period2>>\n+    : __duration_common_type<common_type<_Rep1, _Rep2>,\n+\t\t\t     typename _Period1::type,\n+\t\t\t     typename _Period2::type>\n+    { };\n+\n+  /// Specialization of common_type for two identical chrono::duration types.\n+  template<typename _Rep, typename _Period>\n+    struct common_type<chrono::duration<_Rep, _Period>,\n+\t\t       chrono::duration<_Rep, _Period>>\n+    {\n+      using type = chrono::duration<typename common_type<_Rep>::type,\n+\t\t\t\t    typename _Period::type>;\n+    };\n+\n+  /// Specialization of common_type for one chrono::duration type.\n+  template<typename _Rep, typename _Period>\n+    struct common_type<chrono::duration<_Rep, _Period>>\n+    {\n+      using type = chrono::duration<typename common_type<_Rep>::type,\n+\t\t\t\t    typename _Period::type>;\n+    };\n+  /// @}\n+\n+  // 20.11.4.3 specialization of common_type (for time_point, sfinae-friendly)\n+\n+  /// @cond undocumented\n+\n+  template<typename _CT, typename _Clock, typename = void>\n+    struct __timepoint_common_type\n+    { };\n+\n+  template<typename _CT, typename _Clock>\n+    struct __timepoint_common_type<_CT, _Clock, __void_t<typename _CT::type>>\n+    {\n+      using type = chrono::time_point<_Clock, typename _CT::type>;\n+    };\n+\n+  /// @endcond\n+\n+  /// @{\n+  /// @relates chrono::time_point\n+\n+  /// Specialization of common_type for chrono::time_point types.\n+  template<typename _Clock, typename _Duration1, typename _Duration2>\n+    struct common_type<chrono::time_point<_Clock, _Duration1>,\n+\t\t       chrono::time_point<_Clock, _Duration2>>\n+    : __timepoint_common_type<common_type<_Duration1, _Duration2>, _Clock>\n+    { };\n+\n+  /// Specialization of common_type for two identical chrono::time_point types.\n+  template<typename _Clock, typename _Duration>\n+    struct common_type<chrono::time_point<_Clock, _Duration>,\n+\t\t       chrono::time_point<_Clock, _Duration>>\n+    { using type = chrono::time_point<_Clock, _Duration>; };\n+\n+  /// Specialization of common_type for one chrono::time_point type.\n+  template<typename _Clock, typename _Duration>\n+    struct common_type<chrono::time_point<_Clock, _Duration>>\n+    { using type = chrono::time_point<_Clock, _Duration>; };\n+  /// @}\n+\n+  /// @} group chrono\n+\n+  namespace chrono\n+  {\n+    /// @addtogroup chrono\n+    /// @{\n+\n+    /// @cond undocumented\n+\n+    // Primary template for duration_cast impl.\n+    template<typename _ToDur, typename _CF, typename _CR,\n+\t     bool _NumIsOne = false, bool _DenIsOne = false>\n+      struct __duration_cast_impl\n+      {\n+\ttemplate<typename _Rep, typename _Period>\n+\t  static constexpr _ToDur\n+\t  __cast(const duration<_Rep, _Period>& __d)\n+\t  {\n+\t    typedef typename _ToDur::rep\t\t\t__to_rep;\n+\t    return _ToDur(static_cast<__to_rep>(static_cast<_CR>(__d.count())\n+\t      * static_cast<_CR>(_CF::num)\n+\t      / static_cast<_CR>(_CF::den)));\n+\t  }\n+      };\n+\n+    template<typename _ToDur, typename _CF, typename _CR>\n+      struct __duration_cast_impl<_ToDur, _CF, _CR, true, true>\n+      {\n+\ttemplate<typename _Rep, typename _Period>\n+\t  static constexpr _ToDur\n+\t  __cast(const duration<_Rep, _Period>& __d)\n+\t  {\n+\t    typedef typename _ToDur::rep\t\t\t__to_rep;\n+\t    return _ToDur(static_cast<__to_rep>(__d.count()));\n+\t  }\n+      };\n+\n+    template<typename _ToDur, typename _CF, typename _CR>\n+      struct __duration_cast_impl<_ToDur, _CF, _CR, true, false>\n+      {\n+\ttemplate<typename _Rep, typename _Period>\n+\t  static constexpr _ToDur\n+\t  __cast(const duration<_Rep, _Period>& __d)\n+\t  {\n+\t    typedef typename _ToDur::rep\t\t\t__to_rep;\n+\t    return _ToDur(static_cast<__to_rep>(\n+\t      static_cast<_CR>(__d.count()) / static_cast<_CR>(_CF::den)));\n+\t  }\n+      };\n+\n+    template<typename _ToDur, typename _CF, typename _CR>\n+      struct __duration_cast_impl<_ToDur, _CF, _CR, false, true>\n+      {\n+\ttemplate<typename _Rep, typename _Period>\n+\t  static constexpr _ToDur\n+\t  __cast(const duration<_Rep, _Period>& __d)\n+\t  {\n+\t    typedef typename _ToDur::rep\t\t\t__to_rep;\n+\t    return _ToDur(static_cast<__to_rep>(\n+\t      static_cast<_CR>(__d.count()) * static_cast<_CR>(_CF::num)));\n+\t  }\n+      };\n+\n+    template<typename _Tp>\n+      struct __is_duration\n+      : std::false_type\n+      { };\n+\n+    template<typename _Rep, typename _Period>\n+      struct __is_duration<duration<_Rep, _Period>>\n+      : std::true_type\n+      { };\n+\n+    template<typename _Tp>\n+      using __enable_if_is_duration\n+\t= typename enable_if<__is_duration<_Tp>::value, _Tp>::type;\n+\n+    template<typename _Tp>\n+      using __disable_if_is_duration\n+\t= typename enable_if<!__is_duration<_Tp>::value, _Tp>::type;\n+\n+    /// @endcond\n+\n+    /// duration_cast\n+    template<typename _ToDur, typename _Rep, typename _Period>\n+      constexpr __enable_if_is_duration<_ToDur>\n+      duration_cast(const duration<_Rep, _Period>& __d)\n+      {\n+\ttypedef typename _ToDur::period\t\t\t\t__to_period;\n+\ttypedef typename _ToDur::rep\t\t\t\t__to_rep;\n+\ttypedef ratio_divide<_Period, __to_period> \t\t__cf;\n+\ttypedef typename common_type<__to_rep, _Rep, intmax_t>::type __cr;\n+\ttypedef  __duration_cast_impl<_ToDur, __cf, __cr,\n+\t\t\t\t      __cf::num == 1, __cf::den == 1> __dc;\n+\treturn __dc::__cast(__d);\n+      }\n+\n+    /// treat_as_floating_point\n+    template<typename _Rep>\n+      struct treat_as_floating_point\n+      : is_floating_point<_Rep>\n+      { };\n+\n+#if __cplusplus > 201402L\n+    template <typename _Rep>\n+      inline constexpr bool treat_as_floating_point_v =\n+\ttreat_as_floating_point<_Rep>::value;\n+#endif // C++17\n+\n+#if __cplusplus > 201703L\n+    template<typename _Tp>\n+      struct is_clock;\n+\n+    template<typename _Tp>\n+      inline constexpr bool is_clock_v = is_clock<_Tp>::value;\n+\n+#if __cpp_lib_concepts\n+    template<typename _Tp>\n+      struct is_clock : false_type\n+      { };\n+\n+    template<typename _Tp>\n+      requires requires {\n+\ttypename _Tp::rep;\n+\ttypename _Tp::period;\n+\ttypename _Tp::duration;\n+\ttypename _Tp::time_point::clock;\n+\ttypename _Tp::time_point::duration;\n+\t{ &_Tp::is_steady } -> same_as<const bool*>;\n+\t{ _Tp::now() } -> same_as<typename _Tp::time_point>;\n+\trequires same_as<typename _Tp::duration,\n+\t\t\t duration<typename _Tp::rep, typename _Tp::period>>;\n+\trequires same_as<typename _Tp::time_point::duration,\n+\t\t\t typename _Tp::duration>;\n+      }\n+      struct is_clock<_Tp> : true_type\n+      { };\n+#else\n+    template<typename _Tp, typename = void>\n+      struct __is_clock_impl : false_type\n+      { };\n+\n+    template<typename _Tp>\n+      struct __is_clock_impl<_Tp,\n+\t\t\t     void_t<typename _Tp::rep, typename _Tp::period,\n+\t\t\t\t    typename _Tp::duration,\n+\t\t\t\t    typename _Tp::time_point::duration,\n+\t\t\t\t    decltype(_Tp::is_steady),\n+\t\t\t\t    decltype(_Tp::now())>>\n+      : __and_<is_same<typename _Tp::duration,\n+\t\t       duration<typename _Tp::rep, typename _Tp::period>>,\n+\t       is_same<typename _Tp::time_point::duration,\n+\t\t       typename _Tp::duration>,\n+\t       is_same<decltype(&_Tp::is_steady), const bool*>,\n+\t       is_same<decltype(_Tp::now()), typename _Tp::time_point>>::type\n+      { };\n+\n+    template<typename _Tp>\n+      struct is_clock : __is_clock_impl<_Tp>::type\n+      { };\n+#endif\n+#endif // C++20\n+\n+#if __cplusplus >= 201703L\n+# define __cpp_lib_chrono 201611\n+\n+    template<typename _ToDur, typename _Rep, typename _Period>\n+      constexpr __enable_if_is_duration<_ToDur>\n+      floor(const duration<_Rep, _Period>& __d)\n+      {\n+\tauto __to = chrono::duration_cast<_ToDur>(__d);\n+\tif (__to > __d)\n+\t  return __to - _ToDur{1};\n+\treturn __to;\n+      }\n+\n+    template<typename _ToDur, typename _Rep, typename _Period>\n+      constexpr __enable_if_is_duration<_ToDur>\n+      ceil(const duration<_Rep, _Period>& __d)\n+      {\n+\tauto __to = chrono::duration_cast<_ToDur>(__d);\n+\tif (__to < __d)\n+\t  return __to + _ToDur{1};\n+\treturn __to;\n+      }\n+\n+    template <typename _ToDur, typename _Rep, typename _Period>\n+      constexpr enable_if_t<\n+\t__and_<__is_duration<_ToDur>,\n+\t       __not_<treat_as_floating_point<typename _ToDur::rep>>>::value,\n+\t_ToDur>\n+      round(const duration<_Rep, _Period>& __d)\n+      {\n+\t_ToDur __t0 = chrono::floor<_ToDur>(__d);\n+\t_ToDur __t1 = __t0 + _ToDur{1};\n+\tauto __diff0 = __d - __t0;\n+\tauto __diff1 = __t1 - __d;\n+\tif (__diff0 == __diff1)\n+\t{\n+\t    if (__t0.count() & 1)\n+\t\treturn __t1;\n+\t    return __t0;\n+\t}\n+\telse if (__diff0 < __diff1)\n+\t    return __t0;\n+\treturn __t1;\n+      }\n+\n+    template<typename _Rep, typename _Period>\n+      constexpr\n+      enable_if_t<numeric_limits<_Rep>::is_signed, duration<_Rep, _Period>>\n+      abs(duration<_Rep, _Period> __d)\n+      {\n+\tif (__d >= __d.zero())\n+\t  return __d;\n+\treturn -__d;\n+      }\n+\n+    // Make chrono::ceil<D> also usable as chrono::__detail::ceil<D>.\n+    namespace __detail { using chrono::ceil; }\n+\n+#else // ! C++17\n+\n+    // We want to use ceil even when compiling for earlier standards versions.\n+    // C++11 only allows a single statement in a constexpr function, so we\n+    // need to move the comparison into a separate function, __ceil_impl.\n+    namespace __detail\n+    {\n+      template<typename _Tp, typename _Up>\n+\tconstexpr _Tp\n+\t__ceil_impl(const _Tp& __t, const _Up& __u)\n+\t{\n+\t  return (__t < __u) ? (__t + _Tp{1}) : __t;\n+\t}\n+\n+      // C++11-friendly version of std::chrono::ceil<D> for internal use.\n+      template<typename _ToDur, typename _Rep, typename _Period>\n+\tconstexpr _ToDur\n+\tceil(const duration<_Rep, _Period>& __d)\n+\t{\n+\t  return __detail::__ceil_impl(chrono::duration_cast<_ToDur>(__d), __d);\n+\t}\n+    }\n+#endif // C++17\n+\n+    /// duration_values\n+    template<typename _Rep>\n+      struct duration_values\n+      {\n+\tstatic constexpr _Rep\n+\tzero() noexcept\n+\t{ return _Rep(0); }\n+\n+\tstatic constexpr _Rep\n+\tmax() noexcept\n+\t{ return numeric_limits<_Rep>::max(); }\n+\n+\tstatic constexpr _Rep\n+\tmin() noexcept\n+\t{ return numeric_limits<_Rep>::lowest(); }\n+      };\n+\n+    /// @cond undocumented\n+\n+    template<typename _Tp>\n+      struct __is_ratio\n+      : std::false_type\n+      { };\n+\n+    template<intmax_t _Num, intmax_t _Den>\n+      struct __is_ratio<ratio<_Num, _Den>>\n+      : std::true_type\n+      { };\n+\n+    /// @endcond\n+\n+    template<typename _Rep, typename _Period>\n+      struct duration\n+      {\n+      private:\n+\ttemplate<typename _Rep2>\n+\t  using __is_float = treat_as_floating_point<_Rep2>;\n+\n+\tstatic constexpr intmax_t\n+\t_S_gcd(intmax_t __m, intmax_t __n) noexcept\n+\t{\n+\t  // Duration only allows positive periods so we don't need to\n+\t  // handle negative values here (unlike __static_gcd and std::gcd).\n+#if __cplusplus >= 201402L\n+\t  do\n+\t    {\n+\t      intmax_t __rem = __m % __n;\n+\t      __m = __n;\n+\t      __n = __rem;\n+\t    }\n+\t  while (__n != 0);\n+\t  return __m;\n+#else\n+\t  // C++11 doesn't allow loops in constexpr functions, but this\n+\t  // recursive version can be more expensive to evaluate.\n+\t  return (__n == 0) ? __m : _S_gcd(__n, __m % __n);\n+#endif\n+\t}\n+\n+\t// _GLIBCXX_RESOLVE_LIB_DEFECTS\n+\t// 2094. overflow shouldn't participate in overload resolution\n+\t// 3090. What is [2094] intended to mean?\n+\t// This only produces a valid type if no overflow occurs.\n+\ttemplate<typename _R1, typename _R2,\n+\t\t intmax_t __gcd1 = _S_gcd(_R1::num, _R2::num),\n+\t\t intmax_t __gcd2 = _S_gcd(_R1::den, _R2::den)>\n+\t  using __divide = ratio<(_R1::num / __gcd1) * (_R2::den / __gcd2),\n+\t\t\t\t (_R1::den / __gcd2) * (_R2::num / __gcd1)>;\n+\n+\t// _Period2 is an exact multiple of _Period\n+\ttemplate<typename _Period2>\n+\t  using __is_harmonic\n+\t    = __bool_constant<__divide<_Period2, _Period>::den == 1>;\n+\n+      public:\n+\n+\tusing rep = _Rep;\n+\tusing period = typename _Period::type;\n+\n+\tstatic_assert(!__is_duration<_Rep>::value, \"rep cannot be a duration\");\n+\tstatic_assert(__is_ratio<_Period>::value,\n+\t\t      \"period must be a specialization of ratio\");\n+\tstatic_assert(_Period::num > 0, \"period must be positive\");\n+\n+\t// 20.11.5.1 construction / copy / destroy\n+\tconstexpr duration() = default;\n+\n+\tduration(const duration&) = default;\n+\n+\t// _GLIBCXX_RESOLVE_LIB_DEFECTS\n+\t// 3050. Conversion specification problem in chrono::duration\n+\ttemplate<typename _Rep2, typename = _Require<\n+\t\t is_convertible<const _Rep2&, rep>,\n+\t\t __or_<__is_float<rep>, __not_<__is_float<_Rep2>>>>>\n+\t  constexpr explicit duration(const _Rep2& __rep)\n+\t  : __r(static_cast<rep>(__rep)) { }\n+\n+\ttemplate<typename _Rep2, typename _Period2, typename = _Require<\n+\t\t is_convertible<const _Rep2&, rep>,\n+\t\t __or_<__is_float<rep>,\n+\t\t       __and_<__is_harmonic<_Period2>,\n+\t\t\t      __not_<__is_float<_Rep2>>>>>>\n+\t  constexpr duration(const duration<_Rep2, _Period2>& __d)\n+\t  : __r(duration_cast<duration>(__d).count()) { }\n+\n+\t~duration() = default;\n+\tduration& operator=(const duration&) = default;\n+\n+\t// 20.11.5.2 observer\n+\tconstexpr rep\n+\tcount() const\n+\t{ return __r; }\n+\n+\t// 20.11.5.3 arithmetic\n+\n+\tconstexpr duration<typename common_type<rep>::type, period>\n+\toperator+() const\n+\t{ return duration<typename common_type<rep>::type, period>(__r); }\n+\n+\tconstexpr duration<typename common_type<rep>::type, period>\n+\toperator-() const\n+\t{ return duration<typename common_type<rep>::type, period>(-__r); }\n+\n+\t_GLIBCXX17_CONSTEXPR duration&\n+\toperator++()\n+\t{\n+\t  ++__r;\n+\t  return *this;\n+\t}\n+\n+\t_GLIBCXX17_CONSTEXPR duration\n+\toperator++(int)\n+\t{ return duration(__r++); }\n+\n+\t_GLIBCXX17_CONSTEXPR duration&\n+\toperator--()\n+\t{\n+\t  --__r;\n+\t  return *this;\n+\t}\n+\n+\t_GLIBCXX17_CONSTEXPR duration\n+\toperator--(int)\n+\t{ return duration(__r--); }\n+\n+\t_GLIBCXX17_CONSTEXPR duration&\n+\toperator+=(const duration& __d)\n+\t{\n+\t  __r += __d.count();\n+\t  return *this;\n+\t}\n+\n+\t_GLIBCXX17_CONSTEXPR duration&\n+\toperator-=(const duration& __d)\n+\t{\n+\t  __r -= __d.count();\n+\t  return *this;\n+\t}\n+\n+\t_GLIBCXX17_CONSTEXPR duration&\n+\toperator*=(const rep& __rhs)\n+\t{\n+\t  __r *= __rhs;\n+\t  return *this;\n+\t}\n+\n+\t_GLIBCXX17_CONSTEXPR duration&\n+\toperator/=(const rep& __rhs)\n+\t{\n+\t  __r /= __rhs;\n+\t  return *this;\n+\t}\n+\n+\t// DR 934.\n+\ttemplate<typename _Rep2 = rep>\n+\t  _GLIBCXX17_CONSTEXPR\n+\t  typename enable_if<!treat_as_floating_point<_Rep2>::value,\n+\t\t\t     duration&>::type\n+\t  operator%=(const rep& __rhs)\n+\t  {\n+\t    __r %= __rhs;\n+\t    return *this;\n+\t  }\n+\n+\ttemplate<typename _Rep2 = rep>\n+\t  _GLIBCXX17_CONSTEXPR\n+\t  typename enable_if<!treat_as_floating_point<_Rep2>::value,\n+\t\t\t     duration&>::type\n+\t  operator%=(const duration& __d)\n+\t  {\n+\t    __r %= __d.count();\n+\t    return *this;\n+\t  }\n+\n+\t// 20.11.5.4 special values\n+\tstatic constexpr duration\n+\tzero() noexcept\n+\t{ return duration(duration_values<rep>::zero()); }\n+\n+\tstatic constexpr duration\n+\tmin() noexcept\n+\t{ return duration(duration_values<rep>::min()); }\n+\n+\tstatic constexpr duration\n+\tmax() noexcept\n+\t{ return duration(duration_values<rep>::max()); }\n+\n+      private:\n+\trep __r;\n+      };\n+\n+    /// @{\n+    /// @relates std::chrono::duration\n+\n+    /// The sum of two durations.\n+    template<typename _Rep1, typename _Period1,\n+\t     typename _Rep2, typename _Period2>\n+      constexpr typename common_type<duration<_Rep1, _Period1>,\n+\t\t\t\t     duration<_Rep2, _Period2>>::type\n+      operator+(const duration<_Rep1, _Period1>& __lhs,\n+\t\tconst duration<_Rep2, _Period2>& __rhs)\n+      {\n+\ttypedef duration<_Rep1, _Period1>\t\t\t__dur1;\n+\ttypedef duration<_Rep2, _Period2>\t\t\t__dur2;\n+\ttypedef typename common_type<__dur1,__dur2>::type\t__cd;\n+\treturn __cd(__cd(__lhs).count() + __cd(__rhs).count());\n+      }\n+\n+    /// The difference between two durations.\n+    template<typename _Rep1, typename _Period1,\n+\t     typename _Rep2, typename _Period2>\n+      constexpr typename common_type<duration<_Rep1, _Period1>,\n+\t\t\t\t     duration<_Rep2, _Period2>>::type\n+      operator-(const duration<_Rep1, _Period1>& __lhs,\n+\t\tconst duration<_Rep2, _Period2>& __rhs)\n+      {\n+\ttypedef duration<_Rep1, _Period1>\t\t\t__dur1;\n+\ttypedef duration<_Rep2, _Period2>\t\t\t__dur2;\n+\ttypedef typename common_type<__dur1,__dur2>::type\t__cd;\n+\treturn __cd(__cd(__lhs).count() - __cd(__rhs).count());\n+      }\n+\n+    /// @}\n+\n+    /// @cond undocumented\n+\n+    // SFINAE helper to obtain common_type<_Rep1, _Rep2> only if _Rep2\n+    // is implicitly convertible to it.\n+    // _GLIBCXX_RESOLVE_LIB_DEFECTS\n+    // 3050. Conversion specification problem in chrono::duration constructor\n+    template<typename _Rep1, typename _Rep2,\n+\t     typename _CRep = typename common_type<_Rep1, _Rep2>::type>\n+      using __common_rep_t = typename\n+\tenable_if<is_convertible<const _Rep2&, _CRep>::value, _CRep>::type;\n+\n+    /// @endcond\n+\n+    /** @{\n+     * Arithmetic operators for chrono::duration\n+     * @relates std::chrono::duration\n+     */\n+\n+    template<typename _Rep1, typename _Period, typename _Rep2>\n+      constexpr duration<__common_rep_t<_Rep1, _Rep2>, _Period>\n+      operator*(const duration<_Rep1, _Period>& __d, const _Rep2& __s)\n+      {\n+\ttypedef duration<typename common_type<_Rep1, _Rep2>::type, _Period>\n+\t  __cd;\n+\treturn __cd(__cd(__d).count() * __s);\n+      }\n+\n+    template<typename _Rep1, typename _Rep2, typename _Period>\n+      constexpr duration<__common_rep_t<_Rep2, _Rep1>, _Period>\n+      operator*(const _Rep1& __s, const duration<_Rep2, _Period>& __d)\n+      { return __d * __s; }\n+\n+    template<typename _Rep1, typename _Period, typename _Rep2>\n+      constexpr\n+      duration<__common_rep_t<_Rep1, __disable_if_is_duration<_Rep2>>, _Period>\n+      operator/(const duration<_Rep1, _Period>& __d, const _Rep2& __s)\n+      {\n+\ttypedef duration<typename common_type<_Rep1, _Rep2>::type, _Period>\n+\t  __cd;\n+\treturn __cd(__cd(__d).count() / __s);\n+      }\n+\n+    template<typename _Rep1, typename _Period1,\n+\t     typename _Rep2, typename _Period2>\n+      constexpr typename common_type<_Rep1, _Rep2>::type\n+      operator/(const duration<_Rep1, _Period1>& __lhs,\n+\t\tconst duration<_Rep2, _Period2>& __rhs)\n+      {\n+\ttypedef duration<_Rep1, _Period1>\t\t\t__dur1;\n+\ttypedef duration<_Rep2, _Period2>\t\t\t__dur2;\n+\ttypedef typename common_type<__dur1,__dur2>::type\t__cd;\n+\treturn __cd(__lhs).count() / __cd(__rhs).count();\n+      }\n+\n+    // DR 934.\n+    template<typename _Rep1, typename _Period, typename _Rep2>\n+      constexpr\n+      duration<__common_rep_t<_Rep1, __disable_if_is_duration<_Rep2>>, _Period>\n+      operator%(const duration<_Rep1, _Period>& __d, const _Rep2& __s)\n+      {\n+\ttypedef duration<typename common_type<_Rep1, _Rep2>::type, _Period>\n+\t  __cd;\n+\treturn __cd(__cd(__d).count() % __s);\n+      }\n+\n+    template<typename _Rep1, typename _Period1,\n+\t     typename _Rep2, typename _Period2>\n+      constexpr typename common_type<duration<_Rep1, _Period1>,\n+\t\t\t\t     duration<_Rep2, _Period2>>::type\n+      operator%(const duration<_Rep1, _Period1>& __lhs,\n+\t\tconst duration<_Rep2, _Period2>& __rhs)\n+      {\n+\ttypedef duration<_Rep1, _Period1>\t\t\t__dur1;\n+\ttypedef duration<_Rep2, _Period2>\t\t\t__dur2;\n+\ttypedef typename common_type<__dur1,__dur2>::type\t__cd;\n+\treturn __cd(__cd(__lhs).count() % __cd(__rhs).count());\n+      }\n+    /// @}\n+\n+    // comparisons\n+\n+    /** @{\n+     * Comparisons for chrono::duration\n+     * @relates std::chrono::duration\n+     */\n+\n+    template<typename _Rep1, typename _Period1,\n+\t     typename _Rep2, typename _Period2>\n+      constexpr bool\n+      operator==(const duration<_Rep1, _Period1>& __lhs,\n+\t\t const duration<_Rep2, _Period2>& __rhs)\n+      {\n+\ttypedef duration<_Rep1, _Period1>\t\t\t__dur1;\n+\ttypedef duration<_Rep2, _Period2>\t\t\t__dur2;\n+\ttypedef typename common_type<__dur1,__dur2>::type\t__ct;\n+\treturn __ct(__lhs).count() == __ct(__rhs).count();\n+      }\n+\n+    template<typename _Rep1, typename _Period1,\n+\t     typename _Rep2, typename _Period2>\n+      constexpr bool\n+      operator<(const duration<_Rep1, _Period1>& __lhs,\n+\t\tconst duration<_Rep2, _Period2>& __rhs)\n+      {\n+\ttypedef duration<_Rep1, _Period1>\t\t\t__dur1;\n+\ttypedef duration<_Rep2, _Period2>\t\t\t__dur2;\n+\ttypedef typename common_type<__dur1,__dur2>::type\t__ct;\n+\treturn __ct(__lhs).count() < __ct(__rhs).count();\n+      }\n+\n+#if __cpp_lib_three_way_comparison\n+    template<typename _Rep1, typename _Period1,\n+\t     typename _Rep2, typename _Period2>\n+      requires three_way_comparable<common_type_t<_Rep1, _Rep2>>\n+      constexpr auto\n+      operator<=>(const duration<_Rep1, _Period1>& __lhs,\n+\t\t  const duration<_Rep2, _Period2>& __rhs)\n+      {\n+\tusing __ct = common_type_t<duration<_Rep1, _Period1>,\n+\t\t\t\t   duration<_Rep2, _Period2>>;\n+\treturn __ct(__lhs).count() <=> __ct(__rhs).count();\n+      }\n+#else\n+    template<typename _Rep1, typename _Period1,\n+\t     typename _Rep2, typename _Period2>\n+      constexpr bool\n+      operator!=(const duration<_Rep1, _Period1>& __lhs,\n+\t\t const duration<_Rep2, _Period2>& __rhs)\n+      { return !(__lhs == __rhs); }\n+#endif\n+\n+    template<typename _Rep1, typename _Period1,\n+\t     typename _Rep2, typename _Period2>\n+      constexpr bool\n+      operator<=(const duration<_Rep1, _Period1>& __lhs,\n+\t\t const duration<_Rep2, _Period2>& __rhs)\n+      { return !(__rhs < __lhs); }\n+\n+    template<typename _Rep1, typename _Period1,\n+\t     typename _Rep2, typename _Period2>\n+      constexpr bool\n+      operator>(const duration<_Rep1, _Period1>& __lhs,\n+\t\tconst duration<_Rep2, _Period2>& __rhs)\n+      { return __rhs < __lhs; }\n+\n+    template<typename _Rep1, typename _Period1,\n+\t     typename _Rep2, typename _Period2>\n+      constexpr bool\n+      operator>=(const duration<_Rep1, _Period1>& __lhs,\n+\t\t const duration<_Rep2, _Period2>& __rhs)\n+      { return !(__lhs < __rhs); }\n+\n+    /// @}\n+\n+    /// @cond undocumented\n+#ifdef _GLIBCXX_USE_C99_STDINT_TR1\n+# define _GLIBCXX_CHRONO_INT64_T int64_t\n+#elif defined __INT64_TYPE__\n+# define _GLIBCXX_CHRONO_INT64_T __INT64_TYPE__\n+#else\n+    static_assert(std::numeric_limits<unsigned long long>::digits >= 64,\n+\t\"Representation type for nanoseconds must have at least 64 bits\");\n+# define _GLIBCXX_CHRONO_INT64_T long long\n+#endif\n+    /// @endcond\n+\n+    /// nanoseconds\n+    using nanoseconds\t= duration<_GLIBCXX_CHRONO_INT64_T, nano>;\n+\n+    /// microseconds\n+    using microseconds\t= duration<_GLIBCXX_CHRONO_INT64_T, micro>;\n+\n+    /// milliseconds\n+    using milliseconds\t= duration<_GLIBCXX_CHRONO_INT64_T, milli>;\n+\n+    /// seconds\n+    using seconds\t= duration<_GLIBCXX_CHRONO_INT64_T>;\n+\n+    /// minutes\n+    using minutes\t= duration<_GLIBCXX_CHRONO_INT64_T, ratio< 60>>;\n+\n+    /// hours\n+    using hours\t\t= duration<_GLIBCXX_CHRONO_INT64_T, ratio<3600>>;\n+\n+#if __cplusplus > 201703L\n+    /// days\n+    using days\t\t= duration<_GLIBCXX_CHRONO_INT64_T, ratio<86400>>;\n+\n+    /// weeks\n+    using weeks\t\t= duration<_GLIBCXX_CHRONO_INT64_T, ratio<604800>>;\n+\n+    /// years\n+    using years\t\t= duration<_GLIBCXX_CHRONO_INT64_T, ratio<31556952>>;\n+\n+    /// months\n+    using months\t= duration<_GLIBCXX_CHRONO_INT64_T, ratio<2629746>>;\n+#endif // C++20\n+\n+#undef _GLIBCXX_CHRONO_INT64_T\n+\n+    template<typename _Clock, typename _Dur>\n+      struct time_point\n+      {\n+\tstatic_assert(__is_duration<_Dur>::value,\n+\t    \"duration must be a specialization of std::chrono::duration\");\n+\n+\ttypedef _Clock\t\t\t\t\t\tclock;\n+\ttypedef _Dur\t\t\t\t\t\tduration;\n+\ttypedef typename duration::rep\t\t\t\trep;\n+\ttypedef typename duration::period\t\t\tperiod;\n+\n+\tconstexpr time_point() : __d(duration::zero())\n+\t{ }\n+\n+\tconstexpr explicit time_point(const duration& __dur)\n+\t: __d(__dur)\n+\t{ }\n+\n+\t// conversions\n+\ttemplate<typename _Dur2,\n+\t\t typename = _Require<is_convertible<_Dur2, _Dur>>>\n+\t  constexpr time_point(const time_point<clock, _Dur2>& __t)\n+\t  : __d(__t.time_since_epoch())\n+\t  { }\n+\n+\t// observer\n+\tconstexpr duration\n+\ttime_since_epoch() const\n+\t{ return __d; }\n+\n+#if __cplusplus > 201703L\n+\tconstexpr time_point&\n+\toperator++()\n+\t{\n+\t  ++__d;\n+\t  return *this;\n+\t}\n+\n+\tconstexpr time_point\n+\toperator++(int)\n+\t{ return time_point{__d++}; }\n+\n+\tconstexpr time_point&\n+\toperator--()\n+\t{\n+\t  --__d;\n+\t  return *this;\n+\t}\n+\n+\tconstexpr time_point\n+\toperator--(int)\n+\t{ return time_point{__d--}; }\n+#endif\n+\n+\t// arithmetic\n+\t_GLIBCXX17_CONSTEXPR time_point&\n+\toperator+=(const duration& __dur)\n+\t{\n+\t  __d += __dur;\n+\t  return *this;\n+\t}\n+\n+\t_GLIBCXX17_CONSTEXPR time_point&\n+\toperator-=(const duration& __dur)\n+\t{\n+\t  __d -= __dur;\n+\t  return *this;\n+\t}\n+\n+\t// special values\n+\tstatic constexpr time_point\n+\tmin() noexcept\n+\t{ return time_point(duration::min()); }\n+\n+\tstatic constexpr time_point\n+\tmax() noexcept\n+\t{ return time_point(duration::max()); }\n+\n+      private:\n+\tduration __d;\n+      };\n+\n+    /// time_point_cast\n+    template<typename _ToDur, typename _Clock, typename _Dur>\n+      constexpr typename enable_if<__is_duration<_ToDur>::value,\n+\t\t\t\t   time_point<_Clock, _ToDur>>::type\n+      time_point_cast(const time_point<_Clock, _Dur>& __t)\n+      {\n+\ttypedef time_point<_Clock, _ToDur>\t\t\t__time_point;\n+\treturn __time_point(duration_cast<_ToDur>(__t.time_since_epoch()));\n+      }\n+\n+#if __cplusplus > 201402L\n+    template<typename _ToDur, typename _Clock, typename _Dur>\n+      constexpr\n+      enable_if_t<__is_duration<_ToDur>::value, time_point<_Clock, _ToDur>>\n+      floor(const time_point<_Clock, _Dur>& __tp)\n+      {\n+\treturn time_point<_Clock, _ToDur>{\n+\t    chrono::floor<_ToDur>(__tp.time_since_epoch())};\n+      }\n+\n+    template<typename _ToDur, typename _Clock, typename _Dur>\n+      constexpr\n+      enable_if_t<__is_duration<_ToDur>::value, time_point<_Clock, _ToDur>>\n+      ceil(const time_point<_Clock, _Dur>& __tp)\n+      {\n+\treturn time_point<_Clock, _ToDur>{\n+\t    chrono::ceil<_ToDur>(__tp.time_since_epoch())};\n+      }\n+\n+    template<typename _ToDur, typename _Clock, typename _Dur>\n+      constexpr enable_if_t<\n+\t__and_<__is_duration<_ToDur>,\n+\t       __not_<treat_as_floating_point<typename _ToDur::rep>>>::value,\n+\ttime_point<_Clock, _ToDur>>\n+      round(const time_point<_Clock, _Dur>& __tp)\n+      {\n+\treturn time_point<_Clock, _ToDur>{\n+\t    chrono::round<_ToDur>(__tp.time_since_epoch())};\n+      }\n+#endif // C++17\n+\n+    /// @{\n+    /// @relates time_point\n+\n+    /// Adjust a time point forwards by the given duration.\n+    template<typename _Clock, typename _Dur1,\n+\t     typename _Rep2, typename _Period2>\n+      constexpr time_point<_Clock,\n+\ttypename common_type<_Dur1, duration<_Rep2, _Period2>>::type>\n+      operator+(const time_point<_Clock, _Dur1>& __lhs,\n+\t\tconst duration<_Rep2, _Period2>& __rhs)\n+      {\n+\ttypedef duration<_Rep2, _Period2>\t\t\t__dur2;\n+\ttypedef typename common_type<_Dur1,__dur2>::type\t__ct;\n+\ttypedef time_point<_Clock, __ct>\t\t\t__time_point;\n+\treturn __time_point(__lhs.time_since_epoch() + __rhs);\n+      }\n+\n+    /// Adjust a time point forwards by the given duration.\n+    template<typename _Rep1, typename _Period1,\n+\t     typename _Clock, typename _Dur2>\n+      constexpr time_point<_Clock,\n+\ttypename common_type<duration<_Rep1, _Period1>, _Dur2>::type>\n+      operator+(const duration<_Rep1, _Period1>& __lhs,\n+\t\tconst time_point<_Clock, _Dur2>& __rhs)\n+      {\n+\ttypedef duration<_Rep1, _Period1>\t\t\t__dur1;\n+\ttypedef typename common_type<__dur1,_Dur2>::type\t__ct;\n+\ttypedef time_point<_Clock, __ct>\t\t\t__time_point;\n+\treturn __time_point(__rhs.time_since_epoch() + __lhs);\n+      }\n+\n+    /// Adjust a time point backwards by the given duration.\n+    template<typename _Clock, typename _Dur1,\n+\t     typename _Rep2, typename _Period2>\n+      constexpr time_point<_Clock,\n+\ttypename common_type<_Dur1, duration<_Rep2, _Period2>>::type>\n+      operator-(const time_point<_Clock, _Dur1>& __lhs,\n+\t\tconst duration<_Rep2, _Period2>& __rhs)\n+      {\n+\ttypedef duration<_Rep2, _Period2>\t\t\t__dur2;\n+\ttypedef typename common_type<_Dur1,__dur2>::type\t__ct;\n+\ttypedef time_point<_Clock, __ct>\t\t\t__time_point;\n+\treturn __time_point(__lhs.time_since_epoch() -__rhs);\n+      }\n+\n+    /// The difference between two time points (as a duration)\n+    template<typename _Clock, typename _Dur1, typename _Dur2>\n+      constexpr typename common_type<_Dur1, _Dur2>::type\n+      operator-(const time_point<_Clock, _Dur1>& __lhs,\n+\t\tconst time_point<_Clock, _Dur2>& __rhs)\n+      { return __lhs.time_since_epoch() - __rhs.time_since_epoch(); }\n+    /// @}\n+\n+    /** @{\n+     * Comparisons for time_point\n+     * @relates chrono::time_point\n+     */\n+\n+    template<typename _Clock, typename _Dur1, typename _Dur2>\n+      constexpr bool\n+      operator==(const time_point<_Clock, _Dur1>& __lhs,\n+\t\t const time_point<_Clock, _Dur2>& __rhs)\n+      { return __lhs.time_since_epoch() == __rhs.time_since_epoch(); }\n+\n+#if __cpp_lib_three_way_comparison\n+    template<typename _Clock, typename _Dur1,\n+\t     three_way_comparable_with<_Dur1> _Dur2>\n+      constexpr auto\n+      operator<=>(const time_point<_Clock, _Dur1>& __lhs,\n+\t\t  const time_point<_Clock, _Dur2>& __rhs)\n+      { return __lhs.time_since_epoch() <=> __rhs.time_since_epoch(); }\n+#else\n+    template<typename _Clock, typename _Dur1, typename _Dur2>\n+      constexpr bool\n+      operator!=(const time_point<_Clock, _Dur1>& __lhs,\n+\t\t const time_point<_Clock, _Dur2>& __rhs)\n+      { return !(__lhs == __rhs); }\n+#endif\n+\n+    template<typename _Clock, typename _Dur1, typename _Dur2>\n+      constexpr bool\n+      operator<(const time_point<_Clock, _Dur1>& __lhs,\n+\t\tconst time_point<_Clock, _Dur2>& __rhs)\n+      { return  __lhs.time_since_epoch() < __rhs.time_since_epoch(); }\n+\n+    template<typename _Clock, typename _Dur1, typename _Dur2>\n+      constexpr bool\n+      operator<=(const time_point<_Clock, _Dur1>& __lhs,\n+\t\t const time_point<_Clock, _Dur2>& __rhs)\n+      { return !(__rhs < __lhs); }\n+\n+    template<typename _Clock, typename _Dur1, typename _Dur2>\n+      constexpr bool\n+      operator>(const time_point<_Clock, _Dur1>& __lhs,\n+\t\tconst time_point<_Clock, _Dur2>& __rhs)\n+      { return __rhs < __lhs; }\n+\n+    template<typename _Clock, typename _Dur1, typename _Dur2>\n+      constexpr bool\n+      operator>=(const time_point<_Clock, _Dur1>& __lhs,\n+\t\t const time_point<_Clock, _Dur2>& __rhs)\n+      { return !(__lhs < __rhs); }\n+\n+    /// @}\n+    /// @} group chrono\n+\n+    // Clocks.\n+\n+    // Why nanosecond resolution as the default?\n+    // Why have std::system_clock always count in the highest\n+    // resolution (ie nanoseconds), even if on some OSes the low 3\n+    // or 9 decimal digits will be always zero? This allows later\n+    // implementations to change the system_clock::now()\n+    // implementation any time to provide better resolution without\n+    // changing function signature or units.\n+\n+    // To support the (forward) evolution of the library's defined\n+    // clocks, wrap inside inline namespace so that the current\n+    // defintions of system_clock, steady_clock, and\n+    // high_resolution_clock types are uniquely mangled. This way, new\n+    // code can use the latests clocks, while the library can contain\n+    // compatibility definitions for previous versions.  At some\n+    // point, when these clocks settle down, the inlined namespaces\n+    // can be removed.  XXX GLIBCXX_ABI Deprecated\n+    inline namespace _V2 {\n+\n+    /**\n+     *  @brief System clock.\n+     *\n+     *  Time returned represents wall time from the system-wide clock.\n+     *  @ingroup chrono\n+    */\n+    struct system_clock\n+    {\n+      typedef chrono::nanoseconds\t\t\t\tduration;\n+      typedef duration::rep\t\t\t\t\trep;\n+      typedef duration::period\t\t\t\t\tperiod;\n+      typedef chrono::time_point<system_clock, duration> \ttime_point;\n+\n+      static_assert(system_clock::duration::min()\n+\t\t    < system_clock::duration::zero(),\n+\t\t    \"a clock's minimum duration cannot be less than its epoch\");\n+\n+      static constexpr bool is_steady = false;\n+\n+      static time_point\n+      now() noexcept;\n+\n+      // Map to C API\n+      static std::time_t\n+      to_time_t(const time_point& __t) noexcept\n+      {\n+\treturn std::time_t(duration_cast<chrono::seconds>\n+\t\t\t   (__t.time_since_epoch()).count());\n+      }\n+\n+      static time_point\n+      from_time_t(std::time_t __t) noexcept\n+      {\n+\ttypedef chrono::time_point<system_clock, seconds>\t__from;\n+\treturn time_point_cast<system_clock::duration>\n+\t       (__from(chrono::seconds(__t)));\n+      }\n+    };\n+\n+\n+    /**\n+     *  @brief Monotonic clock\n+     *\n+     *  Time returned has the property of only increasing at a uniform rate.\n+     *  @ingroup chrono\n+    */\n+    struct steady_clock\n+    {\n+      typedef chrono::nanoseconds\t\t\t\tduration;\n+      typedef duration::rep\t\t\t\t\trep;\n+      typedef duration::period\t\t\t\t\tperiod;\n+      typedef chrono::time_point<steady_clock, duration>\ttime_point;\n+\n+      static constexpr bool is_steady = true;\n+\n+      static time_point\n+      now() noexcept;\n+    };\n+\n+\n+    /**\n+     *  @brief Highest-resolution clock\n+     *\n+     *  This is the clock \"with the shortest tick period.\" Alias to\n+     *  std::system_clock until higher-than-nanosecond definitions\n+     *  become feasible.\n+     *  @ingroup chrono\n+    */\n+    using high_resolution_clock = system_clock;\n+\n+    } // end inline namespace _V2\n+\n+#if __cplusplus >= 202002L\n+    /// @addtogroup chrono\n+    /// @{\n+    template<typename _Duration>\n+      using sys_time = time_point<system_clock, _Duration>;\n+    using sys_seconds = sys_time<seconds>;\n+    using sys_days = sys_time<days>;\n+\n+    using file_clock = ::std::filesystem::__file_clock;\n+\n+    template<typename _Duration>\n+      using file_time = time_point<file_clock, _Duration>;\n+\n+    template<> struct is_clock<system_clock> : true_type { };\n+    template<> struct is_clock<steady_clock> : true_type { };\n+    template<> struct is_clock<file_clock> : true_type { };\n+\n+    template<> inline constexpr bool is_clock_v<system_clock> = true;\n+    template<> inline constexpr bool is_clock_v<steady_clock> = true;\n+    template<> inline constexpr bool is_clock_v<file_clock> = true;\n+    /// @}\n+#endif // C++20\n+  } // namespace chrono\n+\n+#if __cplusplus >= 201402L\n+    #define __cpp_lib_chrono_udls 201304\n+\n+  inline namespace literals\n+  {\n+  /** ISO C++ 2014  namespace for suffixes for duration literals.\n+   *\n+   * These suffixes can be used to create `chrono::duration` values with\n+   * tick periods of hours, minutes, seconds, milliseconds, microseconds\n+   * or nanoseconds. For example, `std::chrono::seconds(5)` can be written\n+   * as `5s` after making the suffix visible in the current scope.\n+   * The suffixes can be made visible by a using-directive or\n+   * using-declaration such as:\n+   *  - `using namespace std::chrono_literals;`\n+   *  - `using namespace std::literals;`\n+   *  - `using namespace std::chrono;`\n+   *  - `using namespace std;`\n+   *  - `using std::chrono_literals::operator\"\"s;`\n+   *\n+   * The result of these suffixes on an integer literal is one of the\n+   * standard typedefs such as `std::chrono::hours`.\n+   * The result on a floating-point literal is a duration type with the\n+   * specified tick period and an unspecified floating-point representation,\n+   * for example `1.5e2ms` might be equivalent to\n+   * `chrono::duration<long double, chrono::milli>(1.5e2)`.\n+   *\n+   * @since C+14\n+   * @ingroup chrono\n+   */\n+  inline namespace chrono_literals\n+  {\n+    /// @addtogroup chrono\n+    /// @{\n+\n+#pragma GCC diagnostic push\n+#pragma GCC diagnostic ignored \"-Wliteral-suffix\"\n+    /// @cond undocumented\n+    template<typename _Dur, char... _Digits>\n+      constexpr _Dur __check_overflow()\n+      {\n+\tusing _Val = __parse_int::_Parse_int<_Digits...>;\n+\tconstexpr typename _Dur::rep __repval = _Val::value;\n+\tstatic_assert(__repval >= 0 && __repval == _Val::value,\n+\t\t      \"literal value cannot be represented by duration type\");\n+\treturn _Dur(__repval);\n+      }\n+    /// @endcond\n+\n+    /// Literal suffix for durations representing non-integer hours\n+    constexpr chrono::duration<long double, ratio<3600,1>>\n+    operator\"\"h(long double __hours)\n+    { return chrono::duration<long double, ratio<3600,1>>{__hours}; }\n+\n+    /// Literal suffix for durations of type `std::chrono::hours`\n+    template <char... _Digits>\n+      constexpr chrono::hours\n+      operator\"\"h()\n+      { return __check_overflow<chrono::hours, _Digits...>(); }\n+\n+    /// Literal suffix for durations representing non-integer minutes\n+    constexpr chrono::duration<long double, ratio<60,1>>\n+    operator\"\"min(long double __mins)\n+    { return chrono::duration<long double, ratio<60,1>>{__mins}; }\n+\n+    /// Literal suffix for durations of type `std::chrono::minutes`\n+    template <char... _Digits>\n+      constexpr chrono::minutes\n+      operator\"\"min()\n+      { return __check_overflow<chrono::minutes, _Digits...>(); }\n+\n+    /// Literal suffix for durations representing non-integer seconds\n+    constexpr chrono::duration<long double>\n+    operator\"\"s(long double __secs)\n+    { return chrono::duration<long double>{__secs}; }\n+\n+    /// Literal suffix for durations of type `std::chrono::seconds`\n+    template <char... _Digits>\n+      constexpr chrono::seconds\n+      operator\"\"s()\n+      { return __check_overflow<chrono::seconds, _Digits...>(); }\n+\n+    /// Literal suffix for durations representing non-integer milliseconds\n+    constexpr chrono::duration<long double, milli>\n+    operator\"\"ms(long double __msecs)\n+    { return chrono::duration<long double, milli>{__msecs}; }\n+\n+    /// Literal suffix for durations of type `std::chrono::milliseconds`\n+    template <char... _Digits>\n+      constexpr chrono::milliseconds\n+      operator\"\"ms()\n+      { return __check_overflow<chrono::milliseconds, _Digits...>(); }\n+\n+    /// Literal suffix for durations representing non-integer microseconds\n+    constexpr chrono::duration<long double, micro>\n+    operator\"\"us(long double __usecs)\n+    { return chrono::duration<long double, micro>{__usecs}; }\n+\n+    /// Literal suffix for durations of type `std::chrono::microseconds`\n+    template <char... _Digits>\n+      constexpr chrono::microseconds\n+      operator\"\"us()\n+      { return __check_overflow<chrono::microseconds, _Digits...>(); }\n+\n+    /// Literal suffix for durations representing non-integer nanoseconds\n+    constexpr chrono::duration<long double, nano>\n+    operator\"\"ns(long double __nsecs)\n+    { return chrono::duration<long double, nano>{__nsecs}; }\n+\n+    /// Literal suffix for durations of type `std::chrono::nanoseconds`\n+    template <char... _Digits>\n+      constexpr chrono::nanoseconds\n+      operator\"\"ns()\n+      { return __check_overflow<chrono::nanoseconds, _Digits...>(); }\n+\n+#pragma GCC diagnostic pop\n+    /// @}\n+  } // inline namespace chrono_literals\n+  } // inline namespace literals\n+\n+  namespace chrono\n+  {\n+    using namespace literals::chrono_literals;\n+  } // namespace chrono\n+#endif // C++14\n+\n+#if __cplusplus >= 201703L\n+  namespace filesystem\n+  {\n+    struct __file_clock\n+    {\n+      using duration                  = chrono::nanoseconds;\n+      using rep                       = duration::rep;\n+      using period                    = duration::period;\n+      using time_point                = chrono::time_point<__file_clock>;\n+      static constexpr bool is_steady = false;\n+\n+      static time_point\n+      now() noexcept\n+      { return _S_from_sys(chrono::system_clock::now()); }\n+\n+#if __cplusplus > 201703L\n+      template<typename _Dur>\n+\tstatic\n+\tchrono::file_time<_Dur>\n+\tfrom_sys(const chrono::sys_time<_Dur>& __t) noexcept\n+\t{ return _S_from_sys(__t); }\n+\n+      // For internal use only\n+      template<typename _Dur>\n+\tstatic\n+\tchrono::sys_time<_Dur>\n+\tto_sys(const chrono::file_time<_Dur>& __t) noexcept\n+\t{ return _S_to_sys(__t); }\n+#endif // C++20\n+\n+    private:\n+      using __sys_clock = chrono::system_clock;\n+\n+      // This clock's (unspecified) epoch is 2174-01-01 00:00:00 UTC.\n+      // A signed 64-bit duration with nanosecond resolution gives roughly\n+      // +/- 292 years, which covers the 1901-2446 date range for ext4.\n+      static constexpr chrono::seconds _S_epoch_diff{6437664000};\n+\n+    protected:\n+      // For internal use only\n+      template<typename _Dur>\n+\tstatic\n+\tchrono::time_point<__file_clock, _Dur>\n+\t_S_from_sys(const chrono::time_point<__sys_clock, _Dur>& __t) noexcept\n+\t{\n+\t  using __file_time = chrono::time_point<__file_clock, _Dur>;\n+\t  return __file_time{__t.time_since_epoch()} - _S_epoch_diff;\n+\t}\n+\n+      // For internal use only\n+      template<typename _Dur>\n+\tstatic\n+\tchrono::time_point<__sys_clock, _Dur>\n+\t_S_to_sys(const chrono::time_point<__file_clock, _Dur>& __t) noexcept\n+\t{\n+\t  using __sys_time = chrono::time_point<__sys_clock, _Dur>;\n+\t  return __sys_time{__t.time_since_epoch()} + _S_epoch_diff;\n+\t}\n+    };\n+  } // namespace filesystem\n+#endif // C++17\n+\n+_GLIBCXX_END_NAMESPACE_VERSION\n+} // namespace std\n+\n+#endif // C++11\n+\n+#endif //_GLIBCXX_CHRONO_H"}, {"sha": "51f351e94d4babb9e2def9e7e79592f991e5240e", "filename": "libstdc++-v3/include/bits/fs_fwd.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f78718b7958f603d50d5c30fd8735d73900bd1f/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ffs_fwd.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f78718b7958f603d50d5c30fd8735d73900bd1f/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ffs_fwd.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ffs_fwd.h?ref=7f78718b7958f603d50d5c30fd8735d73900bd1f", "patch": "@@ -34,7 +34,7 @@\n \n #include <system_error>\n #include <cstdint>\n-#include <chrono>\n+#include <bits/chrono.h>\n \n namespace std _GLIBCXX_VISIBILITY(default)\n {"}, {"sha": "2c8d75768941d9fdc3d86a7bf825c5ec1d936022", "filename": "libstdc++-v3/include/bits/semaphore_base.h", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f78718b7958f603d50d5c30fd8735d73900bd1f/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fsemaphore_base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f78718b7958f603d50d5c30fd8735d73900bd1f/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fsemaphore_base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fsemaphore_base.h?ref=7f78718b7958f603d50d5c30fd8735d73900bd1f", "patch": "@@ -33,6 +33,7 @@\n #pragma GCC system_header\n \n #include <bits/atomic_base.h>\n+#include <bits/chrono.h>\n #if __cpp_lib_atomic_wait\n #include <bits/atomic_timed_wait.h>\n #include <ext/numeric_traits.h>\n@@ -45,9 +46,6 @@\n # include <semaphore.h>\t// sem_t, sem_init, sem_wait, sem_post etc.\n #endif\n \n-#include <chrono>\n-#include <type_traits>\n-\n namespace std _GLIBCXX_VISIBILITY(default)\n {\n _GLIBCXX_BEGIN_NAMESPACE_VERSION"}, {"sha": "0b95f51a109233ebfdc068a009b7e3933725083f", "filename": "libstdc++-v3/include/bits/this_thread_sleep.h", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f78718b7958f603d50d5c30fd8735d73900bd1f/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fthis_thread_sleep.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f78718b7958f603d50d5c30fd8735d73900bd1f/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fthis_thread_sleep.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fthis_thread_sleep.h?ref=7f78718b7958f603d50d5c30fd8735d73900bd1f", "patch": "@@ -33,9 +33,7 @@\n #pragma GCC system_header\n \n #if __cplusplus >= 201103L\n-#include <bits/c++config.h>\n-\n-#include <chrono> // std::chrono::*\n+#include <bits/chrono.h> // std::chrono::*\n \n #ifdef _GLIBCXX_USE_NANOSLEEP\n # include <cerrno>  // errno, EINTR"}, {"sha": "048bc273d980ff95b1cf0d8d4ce45a384f54c7c3", "filename": "libstdc++-v3/include/bits/unique_lock.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f78718b7958f603d50d5c30fd8735d73900bd1f/libstdc%2B%2B-v3%2Finclude%2Fbits%2Funique_lock.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f78718b7958f603d50d5c30fd8735d73900bd1f/libstdc%2B%2B-v3%2Finclude%2Fbits%2Funique_lock.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Funique_lock.h?ref=7f78718b7958f603d50d5c30fd8735d73900bd1f", "patch": "@@ -36,7 +36,7 @@\n # include <bits/c++0x_warning.h>\n #else\n \n-#include <chrono>\n+#include <bits/chrono.h>\n #include <bits/move.h> // for std::swap\n #include <bits/std_mutex.h> // for std::defer_lock_t\n "}, {"sha": "243e571a52a116ab6a2da1e9b81e7a88513f6124", "filename": "libstdc++-v3/include/experimental/bits/fs_fwd.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f78718b7958f603d50d5c30fd8735d73900bd1f/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fbits%2Ffs_fwd.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f78718b7958f603d50d5c30fd8735d73900bd1f/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fbits%2Ffs_fwd.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fbits%2Ffs_fwd.h?ref=7f78718b7958f603d50d5c30fd8735d73900bd1f", "patch": "@@ -36,7 +36,7 @@\n \n #include <system_error>\n #include <cstdint>\n-#include <chrono>\n+#include <bits/chrono.h>\n \n namespace std _GLIBCXX_VISIBILITY(default)\n {"}, {"sha": "8d66174bf6dd49cd0d04c012c3710b77fd7369a1", "filename": "libstdc++-v3/include/experimental/chrono", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f78718b7958f603d50d5c30fd8735d73900bd1f/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fchrono", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f78718b7958f603d50d5c30fd8735d73900bd1f/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fchrono", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fchrono?ref=7f78718b7958f603d50d5c30fd8735d73900bd1f", "patch": "@@ -38,7 +38,7 @@\n \n #if __cplusplus >= 201402L\n \n-#include <chrono>\n+#include <bits/chrono.h> // Only the C++14 parts of <chrono>\n #include <experimental/bits/lfts_config.h>\n \n namespace std _GLIBCXX_VISIBILITY(default)"}, {"sha": "f0e2e326885bba069ca8a3b25a645528ec18e0e8", "filename": "libstdc++-v3/include/experimental/io_context", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f78718b7958f603d50d5c30fd8735d73900bd1f/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fio_context", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f78718b7958f603d50d5c30fd8735d73900bd1f/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fio_context", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fio_context?ref=7f78718b7958f603d50d5c30fd8735d73900bd1f", "patch": "@@ -35,14 +35,14 @@\n #if __cplusplus >= 201402L\n \n #include <atomic>\n-#include <chrono>\n #include <forward_list>\n #include <functional>\n #include <system_error>\n #include <thread>\n #include <vector>\n #include <experimental/netfwd>\n #include <experimental/executor>\n+#include <bits/chrono.h>\n #if _GLIBCXX_HAVE_UNISTD_H\n # include <unistd.h>\n #endif"}, {"sha": "31b938c2118e07868a29d0fc88d51ce3dc32a260", "filename": "libstdc++-v3/include/experimental/netfwd", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f78718b7958f603d50d5c30fd8735d73900bd1f/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fnetfwd", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f78718b7958f603d50d5c30fd8735d73900bd1f/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fnetfwd", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Fnetfwd?ref=7f78718b7958f603d50d5c30fd8735d73900bd1f", "patch": "@@ -37,7 +37,7 @@\n // #define __cpp_lib_experimental_net 201803\n // #define __cpp_lib_experimental_net_extensible 201803\n \n-#include <chrono>\n+#include <bits/chrono.h>\n \n namespace std _GLIBCXX_VISIBILITY(default)\n {"}, {"sha": "d947a586a0af307a345a9f9ba2cf21fcf78248cb", "filename": "libstdc++-v3/include/experimental/timer", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f78718b7958f603d50d5c30fd8735d73900bd1f/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Ftimer", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f78718b7958f603d50d5c30fd8735d73900bd1f/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Ftimer", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fexperimental%2Ftimer?ref=7f78718b7958f603d50d5c30fd8735d73900bd1f", "patch": "@@ -34,7 +34,7 @@\n \n #if __cplusplus >= 201402L\n \n-#include <chrono>\n+#include <bits/chrono.h>\n #include <system_error>\n #include <thread>\n #include <experimental/netfwd>"}, {"sha": "c8060d7a67e8a8cdcd83a7f0ec287f748fef667c", "filename": "libstdc++-v3/include/std/chrono", "status": "modified", "additions": 26, "deletions": 1354, "changes": 1380, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f78718b7958f603d50d5c30fd8735d73900bd1f/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fchrono", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f78718b7958f603d50d5c30fd8735d73900bd1f/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fchrono", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fchrono?ref=7f78718b7958f603d50d5c30fd8735d73900bd1f", "patch": "@@ -36,24 +36,12 @@\n # include <bits/c++0x_warning.h>\n #else\n \n-#include <ratio>\n-#include <type_traits>\n-#include <limits>\n-#include <ctime>\n-#include <bits/parse_numbers.h> // for literals support.\n-#if __cplusplus > 201703L\n-# include <concepts>\n-# include <compare>\n-#endif\n+#include <bits/chrono.h>\n \n namespace std _GLIBCXX_VISIBILITY(default)\n {\n _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n-#if __cplusplus >= 201703L\n-  namespace filesystem { struct __file_clock; };\n-#endif\n-\n   /**\n    * @defgroup chrono Time\n    * @ingroup utilities\n@@ -69,1144 +57,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n    */\n   namespace chrono\n   {\n+#if __cplusplus >= 202002L\n     /// @addtogroup chrono\n     /// @{\n-\n-    /// `chrono::duration` represents a distance between two points in time\n-    template<typename _Rep, typename _Period = ratio<1>>\n-      struct duration;\n-\n-    /// `chrono::time_point` represents a point in time as measured by a clock\n-    template<typename _Clock, typename _Dur = typename _Clock::duration>\n-      struct time_point;\n-    /// @}\n-  }\n-\n-  /// @addtogroup chrono\n-  /// @{\n-\n-  // 20.11.4.3 specialization of common_type (for duration, sfinae-friendly)\n-\n-  /// @cond undocumented\n-\n-  template<typename _CT, typename _Period1, typename _Period2, typename = void>\n-    struct __duration_common_type\n-    { };\n-\n-  template<typename _CT, typename _Period1, typename _Period2>\n-    struct __duration_common_type<_CT, _Period1, _Period2,\n-\t\t\t\t  __void_t<typename _CT::type>>\n-    {\n-    private:\n-      using __gcd_num = __static_gcd<_Period1::num, _Period2::num>;\n-      using __gcd_den = __static_gcd<_Period1::den, _Period2::den>;\n-      using __cr = typename _CT::type;\n-      using __r = ratio<__gcd_num::value,\n-\t\t\t(_Period1::den / __gcd_den::value) * _Period2::den>;\n-\n-    public:\n-      using type = chrono::duration<__cr, typename __r::type>;\n-    };\n-\n-  /// @endcond\n-\n-  /// @{\n-  /// @relates chrono::duration\n-\n-  /// Specialization of common_type for chrono::duration types.\n-  template<typename _Rep1, typename _Period1, typename _Rep2, typename _Period2>\n-    struct common_type<chrono::duration<_Rep1, _Period1>,\n-\t\t       chrono::duration<_Rep2, _Period2>>\n-    : __duration_common_type<common_type<_Rep1, _Rep2>,\n-\t\t\t     typename _Period1::type,\n-\t\t\t     typename _Period2::type>\n-    { };\n-\n-  /// Specialization of common_type for two identical chrono::duration types.\n-  template<typename _Rep, typename _Period>\n-    struct common_type<chrono::duration<_Rep, _Period>,\n-\t\t       chrono::duration<_Rep, _Period>>\n-    {\n-      using type = chrono::duration<typename common_type<_Rep>::type,\n-\t\t\t\t    typename _Period::type>;\n-    };\n-\n-  /// Specialization of common_type for one chrono::duration type.\n-  template<typename _Rep, typename _Period>\n-    struct common_type<chrono::duration<_Rep, _Period>>\n-    {\n-      using type = chrono::duration<typename common_type<_Rep>::type,\n-\t\t\t\t    typename _Period::type>;\n-    };\n-  /// @}\n-\n-  // 20.11.4.3 specialization of common_type (for time_point, sfinae-friendly)\n-\n-  /// @cond undocumented\n-\n-  template<typename _CT, typename _Clock, typename = void>\n-    struct __timepoint_common_type\n-    { };\n-\n-  template<typename _CT, typename _Clock>\n-    struct __timepoint_common_type<_CT, _Clock, __void_t<typename _CT::type>>\n-    {\n-      using type = chrono::time_point<_Clock, typename _CT::type>;\n-    };\n-\n-  /// @endcond\n-\n-  /// @{\n-  /// @relates chrono::time_point\n-\n-  /// Specialization of common_type for chrono::time_point types.\n-  template<typename _Clock, typename _Duration1, typename _Duration2>\n-    struct common_type<chrono::time_point<_Clock, _Duration1>,\n-\t\t       chrono::time_point<_Clock, _Duration2>>\n-    : __timepoint_common_type<common_type<_Duration1, _Duration2>, _Clock>\n-    { };\n-\n-  /// Specialization of common_type for two identical chrono::time_point types.\n-  template<typename _Clock, typename _Duration>\n-    struct common_type<chrono::time_point<_Clock, _Duration>,\n-\t\t       chrono::time_point<_Clock, _Duration>>\n-    { using type = chrono::time_point<_Clock, _Duration>; };\n-\n-  /// Specialization of common_type for one chrono::time_point type.\n-  template<typename _Clock, typename _Duration>\n-    struct common_type<chrono::time_point<_Clock, _Duration>>\n-    { using type = chrono::time_point<_Clock, _Duration>; };\n-  /// @}\n-\n-  /// @} group chrono\n-\n-  namespace chrono\n-  {\n-    /// @addtogroup chrono\n-    /// @{\n-\n-    /// @cond undocumented\n-\n-    // Primary template for duration_cast impl.\n-    template<typename _ToDur, typename _CF, typename _CR,\n-\t     bool _NumIsOne = false, bool _DenIsOne = false>\n-      struct __duration_cast_impl\n-      {\n-\ttemplate<typename _Rep, typename _Period>\n-\t  static constexpr _ToDur\n-\t  __cast(const duration<_Rep, _Period>& __d)\n-\t  {\n-\t    typedef typename _ToDur::rep\t\t\t__to_rep;\n-\t    return _ToDur(static_cast<__to_rep>(static_cast<_CR>(__d.count())\n-\t      * static_cast<_CR>(_CF::num)\n-\t      / static_cast<_CR>(_CF::den)));\n-\t  }\n-      };\n-\n-    template<typename _ToDur, typename _CF, typename _CR>\n-      struct __duration_cast_impl<_ToDur, _CF, _CR, true, true>\n-      {\n-\ttemplate<typename _Rep, typename _Period>\n-\t  static constexpr _ToDur\n-\t  __cast(const duration<_Rep, _Period>& __d)\n-\t  {\n-\t    typedef typename _ToDur::rep\t\t\t__to_rep;\n-\t    return _ToDur(static_cast<__to_rep>(__d.count()));\n-\t  }\n-      };\n-\n-    template<typename _ToDur, typename _CF, typename _CR>\n-      struct __duration_cast_impl<_ToDur, _CF, _CR, true, false>\n-      {\n-\ttemplate<typename _Rep, typename _Period>\n-\t  static constexpr _ToDur\n-\t  __cast(const duration<_Rep, _Period>& __d)\n-\t  {\n-\t    typedef typename _ToDur::rep\t\t\t__to_rep;\n-\t    return _ToDur(static_cast<__to_rep>(\n-\t      static_cast<_CR>(__d.count()) / static_cast<_CR>(_CF::den)));\n-\t  }\n-      };\n-\n-    template<typename _ToDur, typename _CF, typename _CR>\n-      struct __duration_cast_impl<_ToDur, _CF, _CR, false, true>\n-      {\n-\ttemplate<typename _Rep, typename _Period>\n-\t  static constexpr _ToDur\n-\t  __cast(const duration<_Rep, _Period>& __d)\n-\t  {\n-\t    typedef typename _ToDur::rep\t\t\t__to_rep;\n-\t    return _ToDur(static_cast<__to_rep>(\n-\t      static_cast<_CR>(__d.count()) * static_cast<_CR>(_CF::num)));\n-\t  }\n-      };\n-\n-    template<typename _Tp>\n-      struct __is_duration\n-      : std::false_type\n-      { };\n-\n-    template<typename _Rep, typename _Period>\n-      struct __is_duration<duration<_Rep, _Period>>\n-      : std::true_type\n-      { };\n-\n-    template<typename _Tp>\n-      using __enable_if_is_duration\n-\t= typename enable_if<__is_duration<_Tp>::value, _Tp>::type;\n-\n-    template<typename _Tp>\n-      using __disable_if_is_duration\n-\t= typename enable_if<!__is_duration<_Tp>::value, _Tp>::type;\n-\n-    /// @endcond\n-\n-    /// duration_cast\n-    template<typename _ToDur, typename _Rep, typename _Period>\n-      constexpr __enable_if_is_duration<_ToDur>\n-      duration_cast(const duration<_Rep, _Period>& __d)\n-      {\n-\ttypedef typename _ToDur::period\t\t\t\t__to_period;\n-\ttypedef typename _ToDur::rep\t\t\t\t__to_rep;\n-\ttypedef ratio_divide<_Period, __to_period> \t\t__cf;\n-\ttypedef typename common_type<__to_rep, _Rep, intmax_t>::type\n-\t  \t\t\t\t\t\t\t__cr;\n-\ttypedef  __duration_cast_impl<_ToDur, __cf, __cr,\n-\t\t\t\t      __cf::num == 1, __cf::den == 1> __dc;\n-\treturn __dc::__cast(__d);\n-      }\n-\n-    /// treat_as_floating_point\n-    template<typename _Rep>\n-      struct treat_as_floating_point\n-      : is_floating_point<_Rep>\n-      { };\n-\n-#if __cplusplus > 201402L\n-    template <typename _Rep>\n-      inline constexpr bool treat_as_floating_point_v =\n-        treat_as_floating_point<_Rep>::value;\n-#endif // C++17\n-\n-#if __cplusplus > 201703L\n-    template<typename _Tp>\n-      struct is_clock;\n-\n-    template<typename _Tp>\n-      inline constexpr bool is_clock_v = is_clock<_Tp>::value;\n-\n-#if __cpp_lib_concepts\n-    template<typename _Tp>\n-      struct is_clock : false_type\n-      { };\n-\n-    template<typename _Tp>\n-      requires requires {\n-\ttypename _Tp::rep;\n-\ttypename _Tp::period;\n-\ttypename _Tp::duration;\n-\ttypename _Tp::time_point::clock;\n-\ttypename _Tp::time_point::duration;\n-\t{ &_Tp::is_steady } -> same_as<const bool*>;\n-\t{ _Tp::now() } -> same_as<typename _Tp::time_point>;\n-\trequires same_as<typename _Tp::duration,\n-\t\t\t duration<typename _Tp::rep, typename _Tp::period>>;\n-\trequires same_as<typename _Tp::time_point::duration,\n-\t\t\t typename _Tp::duration>;\n-      }\n-      struct is_clock<_Tp> : true_type\n-      { };\n-#else\n-    template<typename _Tp, typename = void>\n-      struct __is_clock_impl : false_type\n-      { };\n-\n-    template<typename _Tp>\n-      struct __is_clock_impl<_Tp,\n-\t\t\t     void_t<typename _Tp::rep, typename _Tp::period,\n-\t\t\t\t    typename _Tp::duration,\n-\t\t\t\t    typename _Tp::time_point::duration,\n-\t\t\t\t    decltype(_Tp::is_steady),\n-\t\t\t\t    decltype(_Tp::now())>>\n-      : __and_<is_same<typename _Tp::duration,\n-\t\t       duration<typename _Tp::rep, typename _Tp::period>>,\n-\t       is_same<typename _Tp::time_point::duration,\n-\t\t       typename _Tp::duration>,\n-\t       is_same<decltype(&_Tp::is_steady), const bool*>,\n-\t       is_same<decltype(_Tp::now()), typename _Tp::time_point>>::type\n-      { };\n-\n-    template<typename _Tp>\n-      struct is_clock : __is_clock_impl<_Tp>::type\n-      { };\n-#endif\n-#endif // C++20\n-\n-#if __cplusplus >= 201703L\n-# define __cpp_lib_chrono 201611\n-\n-    template<typename _ToDur, typename _Rep, typename _Period>\n-      constexpr __enable_if_is_duration<_ToDur>\n-      floor(const duration<_Rep, _Period>& __d)\n-      {\n-\tauto __to = chrono::duration_cast<_ToDur>(__d);\n-\tif (__to > __d)\n-\t  return __to - _ToDur{1};\n-\treturn __to;\n-      }\n-\n-    template<typename _ToDur, typename _Rep, typename _Period>\n-      constexpr __enable_if_is_duration<_ToDur>\n-      ceil(const duration<_Rep, _Period>& __d)\n-      {\n-\tauto __to = chrono::duration_cast<_ToDur>(__d);\n-\tif (__to < __d)\n-\t  return __to + _ToDur{1};\n-\treturn __to;\n-      }\n-\n-    template <typename _ToDur, typename _Rep, typename _Period>\n-      constexpr enable_if_t<\n-\t__and_<__is_duration<_ToDur>,\n-\t       __not_<treat_as_floating_point<typename _ToDur::rep>>>::value,\n-\t_ToDur>\n-      round(const duration<_Rep, _Period>& __d)\n-      {\n-\t_ToDur __t0 = chrono::floor<_ToDur>(__d);\n-\t_ToDur __t1 = __t0 + _ToDur{1};\n-\tauto __diff0 = __d - __t0;\n-\tauto __diff1 = __t1 - __d;\n-\tif (__diff0 == __diff1)\n-\t{\n-\t    if (__t0.count() & 1)\n-\t\treturn __t1;\n-\t    return __t0;\n-\t}\n-\telse if (__diff0 < __diff1)\n-\t    return __t0;\n-\treturn __t1;\n-      }\n-\n-    template<typename _Rep, typename _Period>\n-      constexpr\n-      enable_if_t<numeric_limits<_Rep>::is_signed, duration<_Rep, _Period>>\n-      abs(duration<_Rep, _Period> __d)\n-      {\n-\tif (__d >= __d.zero())\n-\t  return __d;\n-\treturn -__d;\n-      }\n-\n-    // Make chrono::ceil<D> also usable as chrono::__detail::ceil<D>.\n-    namespace __detail { using chrono::ceil; }\n-\n-#else // ! C++17\n-\n-    // We want to use ceil even when compiling for earlier standards versions.\n-    // C++11 only allows a single statement in a constexpr function, so we\n-    // need to move the comparison into a separate function, __ceil_impl.\n-    namespace __detail\n-    {\n-      template<typename _Tp, typename _Up>\n-\tconstexpr _Tp\n-\t__ceil_impl(const _Tp& __t, const _Up& __u)\n-\t{\n-\t  return (__t < __u) ? (__t + _Tp{1}) : __t;\n-\t}\n-\n-      // C++11-friendly version of std::chrono::ceil<D> for internal use.\n-      template<typename _ToDur, typename _Rep, typename _Period>\n-\tconstexpr _ToDur\n-\tceil(const duration<_Rep, _Period>& __d)\n-\t{\n-\t  return __detail::__ceil_impl(chrono::duration_cast<_ToDur>(__d), __d);\n-\t}\n-    }\n-#endif // C++17\n-\n-    /// duration_values\n-    template<typename _Rep>\n-      struct duration_values\n-      {\n-\tstatic constexpr _Rep\n-\tzero() noexcept\n-\t{ return _Rep(0); }\n-\n-\tstatic constexpr _Rep\n-\tmax() noexcept\n-\t{ return numeric_limits<_Rep>::max(); }\n-\n-\tstatic constexpr _Rep\n-\tmin() noexcept\n-\t{ return numeric_limits<_Rep>::lowest(); }\n-      };\n-\n-    /// @cond undocumented\n-\n-    template<typename _Tp>\n-      struct __is_ratio\n-      : std::false_type\n-      { };\n-\n-    template<intmax_t _Num, intmax_t _Den>\n-      struct __is_ratio<ratio<_Num, _Den>>\n-      : std::true_type\n-      { };\n-\n-    /// @endcond\n-\n-    template<typename _Rep, typename _Period>\n-      struct duration\n-      {\n-      private:\n-\ttemplate<typename _Rep2>\n-\t  using __is_float = treat_as_floating_point<_Rep2>;\n-\n-\tstatic constexpr intmax_t\n-\t_S_gcd(intmax_t __m, intmax_t __n) noexcept\n-\t{\n-\t  // Duration only allows positive periods so we don't need to\n-\t  // handle negative values here (unlike __static_gcd and std::gcd).\n-#if __cplusplus >= 201402L\n-\t  do\n-\t    {\n-\t      intmax_t __rem = __m % __n;\n-\t      __m = __n;\n-\t      __n = __rem;\n-\t    }\n-\t  while (__n != 0);\n-\t  return __m;\n-#else\n-\t  // C++11 doesn't allow loops in constexpr functions, but this\n-\t  // recursive version can be more expensive to evaluate.\n-\t  return (__n == 0) ? __m : _S_gcd(__n, __m % __n);\n-#endif\n-\t}\n-\n-\t// _GLIBCXX_RESOLVE_LIB_DEFECTS\n-\t// 2094. overflow shouldn't participate in overload resolution\n-\t// 3090. What is [2094] intended to mean?\n-\t// This only produces a valid type if no overflow occurs.\n-\ttemplate<typename _R1, typename _R2,\n-\t\t intmax_t __gcd1 = _S_gcd(_R1::num, _R2::num),\n-\t\t intmax_t __gcd2 = _S_gcd(_R1::den, _R2::den)>\n-\t  using __divide = ratio<(_R1::num / __gcd1) * (_R2::den / __gcd2),\n-\t\t\t\t (_R1::den / __gcd2) * (_R2::num / __gcd1)>;\n-\n-\t// _Period2 is an exact multiple of _Period\n-\ttemplate<typename _Period2>\n-\t  using __is_harmonic\n-\t    = __bool_constant<__divide<_Period2, _Period>::den == 1>;\n-\n-      public:\n-\n-\tusing rep = _Rep;\n-\tusing period = typename _Period::type;\n-\n-\tstatic_assert(!__is_duration<_Rep>::value, \"rep cannot be a duration\");\n-\tstatic_assert(__is_ratio<_Period>::value,\n-\t\t      \"period must be a specialization of ratio\");\n-\tstatic_assert(_Period::num > 0, \"period must be positive\");\n-\n-\t// 20.11.5.1 construction / copy / destroy\n-\tconstexpr duration() = default;\n-\n-\tduration(const duration&) = default;\n-\n-\t// _GLIBCXX_RESOLVE_LIB_DEFECTS\n-\t// 3050. Conversion specification problem in chrono::duration\n-\ttemplate<typename _Rep2, typename = _Require<\n-\t\t is_convertible<const _Rep2&, rep>,\n-\t\t __or_<__is_float<rep>, __not_<__is_float<_Rep2>>>>>\n-\t  constexpr explicit duration(const _Rep2& __rep)\n-\t  : __r(static_cast<rep>(__rep)) { }\n-\n-\ttemplate<typename _Rep2, typename _Period2, typename = _Require<\n-\t\t is_convertible<const _Rep2&, rep>,\n-\t\t __or_<__is_float<rep>,\n-\t\t       __and_<__is_harmonic<_Period2>,\n-\t\t\t      __not_<__is_float<_Rep2>>>>>>\n-\t  constexpr duration(const duration<_Rep2, _Period2>& __d)\n-\t  : __r(duration_cast<duration>(__d).count()) { }\n-\n-\t~duration() = default;\n-\tduration& operator=(const duration&) = default;\n-\n-\t// 20.11.5.2 observer\n-\tconstexpr rep\n-\tcount() const\n-\t{ return __r; }\n-\n-\t// 20.11.5.3 arithmetic\n-\n-\tconstexpr duration<typename common_type<rep>::type, period>\n-\toperator+() const\n-\t{ return duration<typename common_type<rep>::type, period>(__r); }\n-\n-\tconstexpr duration<typename common_type<rep>::type, period>\n-\toperator-() const\n-\t{ return duration<typename common_type<rep>::type, period>(-__r); }\n-\n-\t_GLIBCXX17_CONSTEXPR duration&\n-\toperator++()\n-\t{\n-\t  ++__r;\n-\t  return *this;\n-\t}\n-\n-\t_GLIBCXX17_CONSTEXPR duration\n-\toperator++(int)\n-\t{ return duration(__r++); }\n-\n-\t_GLIBCXX17_CONSTEXPR duration&\n-\toperator--()\n-\t{\n-\t  --__r;\n-\t  return *this;\n-\t}\n-\n-\t_GLIBCXX17_CONSTEXPR duration\n-\toperator--(int)\n-\t{ return duration(__r--); }\n-\n-\t_GLIBCXX17_CONSTEXPR duration&\n-\toperator+=(const duration& __d)\n-\t{\n-\t  __r += __d.count();\n-\t  return *this;\n-\t}\n-\n-\t_GLIBCXX17_CONSTEXPR duration&\n-\toperator-=(const duration& __d)\n-\t{\n-\t  __r -= __d.count();\n-\t  return *this;\n-\t}\n-\n-\t_GLIBCXX17_CONSTEXPR duration&\n-\toperator*=(const rep& __rhs)\n-\t{\n-\t  __r *= __rhs;\n-\t  return *this;\n-\t}\n-\n-\t_GLIBCXX17_CONSTEXPR duration&\n-\toperator/=(const rep& __rhs)\n-\t{\n-\t  __r /= __rhs;\n-\t  return *this;\n-\t}\n-\n-\t// DR 934.\n-\ttemplate<typename _Rep2 = rep>\n-\t  _GLIBCXX17_CONSTEXPR\n-\t  typename enable_if<!treat_as_floating_point<_Rep2>::value,\n-\t\t\t     duration&>::type\n-\t  operator%=(const rep& __rhs)\n-\t  {\n-\t    __r %= __rhs;\n-\t    return *this;\n-\t  }\n-\n-\ttemplate<typename _Rep2 = rep>\n-\t  _GLIBCXX17_CONSTEXPR\n-\t  typename enable_if<!treat_as_floating_point<_Rep2>::value,\n-\t\t\t     duration&>::type\n-\t  operator%=(const duration& __d)\n-\t  {\n-\t    __r %= __d.count();\n-\t    return *this;\n-\t  }\n-\n-\t// 20.11.5.4 special values\n-\tstatic constexpr duration\n-\tzero() noexcept\n-\t{ return duration(duration_values<rep>::zero()); }\n-\n-\tstatic constexpr duration\n-\tmin() noexcept\n-\t{ return duration(duration_values<rep>::min()); }\n-\n-\tstatic constexpr duration\n-\tmax() noexcept\n-\t{ return duration(duration_values<rep>::max()); }\n-\n-      private:\n-\trep __r;\n-      };\n-\n-    /// @{\n-    /// @relates std::chrono::duration\n-\n-    /// The sum of two durations.\n-    template<typename _Rep1, typename _Period1,\n-\t     typename _Rep2, typename _Period2>\n-      constexpr typename common_type<duration<_Rep1, _Period1>,\n-\t\t\t\t     duration<_Rep2, _Period2>>::type\n-      operator+(const duration<_Rep1, _Period1>& __lhs,\n-\t\tconst duration<_Rep2, _Period2>& __rhs)\n-      {\n-\ttypedef duration<_Rep1, _Period1>\t\t\t__dur1;\n-\ttypedef duration<_Rep2, _Period2>\t\t\t__dur2;\n-\ttypedef typename common_type<__dur1,__dur2>::type\t__cd;\n-\treturn __cd(__cd(__lhs).count() + __cd(__rhs).count());\n-      }\n-\n-    /// The difference between two durations.\n-    template<typename _Rep1, typename _Period1,\n-\t     typename _Rep2, typename _Period2>\n-      constexpr typename common_type<duration<_Rep1, _Period1>,\n-\t\t\t\t     duration<_Rep2, _Period2>>::type\n-      operator-(const duration<_Rep1, _Period1>& __lhs,\n-\t\tconst duration<_Rep2, _Period2>& __rhs)\n-      {\n-\ttypedef duration<_Rep1, _Period1>\t\t\t__dur1;\n-\ttypedef duration<_Rep2, _Period2>\t\t\t__dur2;\n-\ttypedef typename common_type<__dur1,__dur2>::type\t__cd;\n-\treturn __cd(__cd(__lhs).count() - __cd(__rhs).count());\n-      }\n-\n-    /// @}\n-\n-    /// @cond undocumented\n-\n-    // SFINAE helper to obtain common_type<_Rep1, _Rep2> only if _Rep2\n-    // is implicitly convertible to it.\n-    // _GLIBCXX_RESOLVE_LIB_DEFECTS\n-    // 3050. Conversion specification problem in chrono::duration constructor\n-    template<typename _Rep1, typename _Rep2,\n-\t     typename _CRep = typename common_type<_Rep1, _Rep2>::type>\n-      using __common_rep_t = typename\n-\tenable_if<is_convertible<const _Rep2&, _CRep>::value, _CRep>::type;\n-\n-    /// @endcond\n-\n-    /** @{\n-     * Arithmetic operators for chrono::duration\n-     * @relates std::chrono::duration\n-     */\n-\n-    template<typename _Rep1, typename _Period, typename _Rep2>\n-      constexpr duration<__common_rep_t<_Rep1, _Rep2>, _Period>\n-      operator*(const duration<_Rep1, _Period>& __d, const _Rep2& __s)\n-      {\n-\ttypedef duration<typename common_type<_Rep1, _Rep2>::type, _Period>\n-\t  __cd;\n-\treturn __cd(__cd(__d).count() * __s);\n-      }\n-\n-    template<typename _Rep1, typename _Rep2, typename _Period>\n-      constexpr duration<__common_rep_t<_Rep2, _Rep1>, _Period>\n-      operator*(const _Rep1& __s, const duration<_Rep2, _Period>& __d)\n-      { return __d * __s; }\n-\n-    template<typename _Rep1, typename _Period, typename _Rep2>\n-      constexpr\n-      duration<__common_rep_t<_Rep1, __disable_if_is_duration<_Rep2>>, _Period>\n-      operator/(const duration<_Rep1, _Period>& __d, const _Rep2& __s)\n-      {\n-\ttypedef duration<typename common_type<_Rep1, _Rep2>::type, _Period>\n-\t  __cd;\n-\treturn __cd(__cd(__d).count() / __s);\n-      }\n-\n-    template<typename _Rep1, typename _Period1,\n-\t     typename _Rep2, typename _Period2>\n-      constexpr typename common_type<_Rep1, _Rep2>::type\n-      operator/(const duration<_Rep1, _Period1>& __lhs,\n-\t\tconst duration<_Rep2, _Period2>& __rhs)\n-      {\n-\ttypedef duration<_Rep1, _Period1>\t\t\t__dur1;\n-\ttypedef duration<_Rep2, _Period2>\t\t\t__dur2;\n-\ttypedef typename common_type<__dur1,__dur2>::type\t__cd;\n-\treturn __cd(__lhs).count() / __cd(__rhs).count();\n-      }\n-\n-    // DR 934.\n-    template<typename _Rep1, typename _Period, typename _Rep2>\n-      constexpr\n-      duration<__common_rep_t<_Rep1, __disable_if_is_duration<_Rep2>>, _Period>\n-      operator%(const duration<_Rep1, _Period>& __d, const _Rep2& __s)\n-      {\n-\ttypedef duration<typename common_type<_Rep1, _Rep2>::type, _Period>\n-\t  __cd;\n-\treturn __cd(__cd(__d).count() % __s);\n-      }\n-\n-    template<typename _Rep1, typename _Period1,\n-\t     typename _Rep2, typename _Period2>\n-      constexpr typename common_type<duration<_Rep1, _Period1>,\n-\t\t\t\t     duration<_Rep2, _Period2>>::type\n-      operator%(const duration<_Rep1, _Period1>& __lhs,\n-\t\tconst duration<_Rep2, _Period2>& __rhs)\n-      {\n-\ttypedef duration<_Rep1, _Period1>\t\t\t__dur1;\n-\ttypedef duration<_Rep2, _Period2>\t\t\t__dur2;\n-\ttypedef typename common_type<__dur1,__dur2>::type\t__cd;\n-\treturn __cd(__cd(__lhs).count() % __cd(__rhs).count());\n-      }\n-    /// @}\n-\n-    // comparisons\n-\n-    /** @{\n-     * Comparisons for chrono::duration\n-     * @relates std::chrono::duration\n-     */\n-\n-    template<typename _Rep1, typename _Period1,\n-\t     typename _Rep2, typename _Period2>\n-      constexpr bool\n-      operator==(const duration<_Rep1, _Period1>& __lhs,\n-\t\t const duration<_Rep2, _Period2>& __rhs)\n-      {\n-\ttypedef duration<_Rep1, _Period1>\t\t\t__dur1;\n-\ttypedef duration<_Rep2, _Period2>\t\t\t__dur2;\n-\ttypedef typename common_type<__dur1,__dur2>::type\t__ct;\n-\treturn __ct(__lhs).count() == __ct(__rhs).count();\n-      }\n-\n-    template<typename _Rep1, typename _Period1,\n-\t     typename _Rep2, typename _Period2>\n-      constexpr bool\n-      operator<(const duration<_Rep1, _Period1>& __lhs,\n-\t\tconst duration<_Rep2, _Period2>& __rhs)\n-      {\n-\ttypedef duration<_Rep1, _Period1>\t\t\t__dur1;\n-\ttypedef duration<_Rep2, _Period2>\t\t\t__dur2;\n-\ttypedef typename common_type<__dur1,__dur2>::type\t__ct;\n-\treturn __ct(__lhs).count() < __ct(__rhs).count();\n-      }\n-\n-#if __cpp_lib_three_way_comparison\n-    template<typename _Rep1, typename _Period1,\n-\t     typename _Rep2, typename _Period2>\n-      requires three_way_comparable<common_type_t<_Rep1, _Rep2>>\n-      constexpr auto\n-      operator<=>(const duration<_Rep1, _Period1>& __lhs,\n-\t\t  const duration<_Rep2, _Period2>& __rhs)\n-      {\n-\tusing __ct = common_type_t<duration<_Rep1, _Period1>,\n-\t\t\t\t   duration<_Rep2, _Period2>>;\n-\treturn __ct(__lhs).count() <=> __ct(__rhs).count();\n-      }\n-#else\n-    template<typename _Rep1, typename _Period1,\n-\t     typename _Rep2, typename _Period2>\n-      constexpr bool\n-      operator!=(const duration<_Rep1, _Period1>& __lhs,\n-\t\t const duration<_Rep2, _Period2>& __rhs)\n-      { return !(__lhs == __rhs); }\n-#endif\n-\n-    template<typename _Rep1, typename _Period1,\n-\t     typename _Rep2, typename _Period2>\n-      constexpr bool\n-      operator<=(const duration<_Rep1, _Period1>& __lhs,\n-\t\t const duration<_Rep2, _Period2>& __rhs)\n-      { return !(__rhs < __lhs); }\n-\n-    template<typename _Rep1, typename _Period1,\n-\t     typename _Rep2, typename _Period2>\n-      constexpr bool\n-      operator>(const duration<_Rep1, _Period1>& __lhs,\n-\t\tconst duration<_Rep2, _Period2>& __rhs)\n-      { return __rhs < __lhs; }\n-\n-    template<typename _Rep1, typename _Period1,\n-\t     typename _Rep2, typename _Period2>\n-      constexpr bool\n-      operator>=(const duration<_Rep1, _Period1>& __lhs,\n-\t\t const duration<_Rep2, _Period2>& __rhs)\n-      { return !(__lhs < __rhs); }\n-\n-    /// @}\n-\n-    /// @cond undocumented\n-#ifdef _GLIBCXX_USE_C99_STDINT_TR1\n-# define _GLIBCXX_CHRONO_INT64_T int64_t\n-#elif defined __INT64_TYPE__\n-# define _GLIBCXX_CHRONO_INT64_T __INT64_TYPE__\n-#else\n-    static_assert(std::numeric_limits<unsigned long long>::digits >= 64,\n-\t\"Representation type for nanoseconds must have at least 64 bits\");\n-# define _GLIBCXX_CHRONO_INT64_T long long\n-#endif\n-    /// @endcond\n-\n-    /// nanoseconds\n-    using nanoseconds\t= duration<_GLIBCXX_CHRONO_INT64_T, nano>;\n-\n-    /// microseconds\n-    using microseconds\t= duration<_GLIBCXX_CHRONO_INT64_T, micro>;\n-\n-    /// milliseconds\n-    using milliseconds\t= duration<_GLIBCXX_CHRONO_INT64_T, milli>;\n-\n-    /// seconds\n-    using seconds\t= duration<_GLIBCXX_CHRONO_INT64_T>;\n-\n-    /// minutes\n-    using minutes\t= duration<_GLIBCXX_CHRONO_INT64_T, ratio< 60>>;\n-\n-    /// hours\n-    using hours\t\t= duration<_GLIBCXX_CHRONO_INT64_T, ratio<3600>>;\n-\n-#if __cplusplus > 201703L\n-    /// days\n-    using days\t\t= duration<_GLIBCXX_CHRONO_INT64_T, ratio<86400>>;\n-\n-    /// weeks\n-    using weeks\t\t= duration<_GLIBCXX_CHRONO_INT64_T, ratio<604800>>;\n-\n-    /// years\n-    using years\t\t= duration<_GLIBCXX_CHRONO_INT64_T, ratio<31556952>>;\n-\n-    /// months\n-    using months\t= duration<_GLIBCXX_CHRONO_INT64_T, ratio<2629746>>;\n-#endif // C++20\n-\n-#undef _GLIBCXX_CHRONO_INT64_T\n-\n-    template<typename _Clock, typename _Dur>\n-      struct time_point\n-      {\n-\tstatic_assert(__is_duration<_Dur>::value,\n-\t    \"duration must be a specialization of std::chrono::duration\");\n-\n-\ttypedef _Clock\t\t\t\t\t\tclock;\n-\ttypedef _Dur\t\t\t\t\t\tduration;\n-\ttypedef typename duration::rep\t\t\t\trep;\n-\ttypedef typename duration::period\t\t\tperiod;\n-\n-\tconstexpr time_point() : __d(duration::zero())\n-\t{ }\n-\n-\tconstexpr explicit time_point(const duration& __dur)\n-\t: __d(__dur)\n-\t{ }\n-\n-\t// conversions\n-\ttemplate<typename _Dur2,\n-\t\t typename = _Require<is_convertible<_Dur2, _Dur>>>\n-\t  constexpr time_point(const time_point<clock, _Dur2>& __t)\n-\t  : __d(__t.time_since_epoch())\n-\t  { }\n-\n-\t// observer\n-\tconstexpr duration\n-\ttime_since_epoch() const\n-\t{ return __d; }\n-\n-#if __cplusplus > 201703L\n-\tconstexpr time_point&\n-\toperator++()\n-\t{\n-\t  ++__d;\n-\t  return *this;\n-\t}\n-\n-\tconstexpr time_point\n-\toperator++(int)\n-\t{ return time_point{__d++}; }\n-\n-\tconstexpr time_point&\n-\toperator--()\n-\t{\n-\t  --__d;\n-\t  return *this;\n-\t}\n-\n-\tconstexpr time_point\n-\toperator--(int)\n-\t{ return time_point{__d--}; }\n-#endif\n-\n-\t// arithmetic\n-\t_GLIBCXX17_CONSTEXPR time_point&\n-\toperator+=(const duration& __dur)\n-\t{\n-\t  __d += __dur;\n-\t  return *this;\n-\t}\n-\n-\t_GLIBCXX17_CONSTEXPR time_point&\n-\toperator-=(const duration& __dur)\n-\t{\n-\t  __d -= __dur;\n-\t  return *this;\n-\t}\n-\n-\t// special values\n-\tstatic constexpr time_point\n-\tmin() noexcept\n-\t{ return time_point(duration::min()); }\n-\n-\tstatic constexpr time_point\n-\tmax() noexcept\n-\t{ return time_point(duration::max()); }\n-\n-      private:\n-\tduration __d;\n-      };\n-\n-    /// time_point_cast\n-    template<typename _ToDur, typename _Clock, typename _Dur>\n-      constexpr typename enable_if<__is_duration<_ToDur>::value,\n-\t\t\t\t   time_point<_Clock, _ToDur>>::type\n-      time_point_cast(const time_point<_Clock, _Dur>& __t)\n-      {\n-\ttypedef time_point<_Clock, _ToDur>\t\t\t__time_point;\n-\treturn __time_point(duration_cast<_ToDur>(__t.time_since_epoch()));\n-      }\n-\n-#if __cplusplus > 201402L\n-    template<typename _ToDur, typename _Clock, typename _Dur>\n-      constexpr\n-      enable_if_t<__is_duration<_ToDur>::value, time_point<_Clock, _ToDur>>\n-      floor(const time_point<_Clock, _Dur>& __tp)\n-      {\n-\treturn time_point<_Clock, _ToDur>{\n-\t    chrono::floor<_ToDur>(__tp.time_since_epoch())};\n-      }\n-\n-    template<typename _ToDur, typename _Clock, typename _Dur>\n-      constexpr\n-      enable_if_t<__is_duration<_ToDur>::value, time_point<_Clock, _ToDur>>\n-      ceil(const time_point<_Clock, _Dur>& __tp)\n-      {\n-\treturn time_point<_Clock, _ToDur>{\n-\t    chrono::ceil<_ToDur>(__tp.time_since_epoch())};\n-      }\n-\n-    template<typename _ToDur, typename _Clock, typename _Dur>\n-      constexpr enable_if_t<\n-\t__and_<__is_duration<_ToDur>,\n-\t       __not_<treat_as_floating_point<typename _ToDur::rep>>>::value,\n-\ttime_point<_Clock, _ToDur>>\n-      round(const time_point<_Clock, _Dur>& __tp)\n-      {\n-\treturn time_point<_Clock, _ToDur>{\n-\t    chrono::round<_ToDur>(__tp.time_since_epoch())};\n-      }\n-#endif // C++17\n-\n-    /// @{\n-    /// @relates time_point\n-\n-    /// Adjust a time point forwards by the given duration.\n-    template<typename _Clock, typename _Dur1,\n-\t     typename _Rep2, typename _Period2>\n-      constexpr time_point<_Clock,\n-\ttypename common_type<_Dur1, duration<_Rep2, _Period2>>::type>\n-      operator+(const time_point<_Clock, _Dur1>& __lhs,\n-\t\tconst duration<_Rep2, _Period2>& __rhs)\n-      {\n-\ttypedef duration<_Rep2, _Period2>\t\t\t__dur2;\n-\ttypedef typename common_type<_Dur1,__dur2>::type\t__ct;\n-\ttypedef time_point<_Clock, __ct>\t\t\t__time_point;\n-\treturn __time_point(__lhs.time_since_epoch() + __rhs);\n-      }\n-\n-    /// Adjust a time point forwards by the given duration.\n-    template<typename _Rep1, typename _Period1,\n-\t     typename _Clock, typename _Dur2>\n-      constexpr time_point<_Clock,\n-\ttypename common_type<duration<_Rep1, _Period1>, _Dur2>::type>\n-      operator+(const duration<_Rep1, _Period1>& __lhs,\n-\t\tconst time_point<_Clock, _Dur2>& __rhs)\n-      {\n-\ttypedef duration<_Rep1, _Period1>\t\t\t__dur1;\n-\ttypedef typename common_type<__dur1,_Dur2>::type\t__ct;\n-\ttypedef time_point<_Clock, __ct>\t\t\t__time_point;\n-\treturn __time_point(__rhs.time_since_epoch() + __lhs);\n-      }\n-\n-    /// Adjust a time point backwards by the given duration.\n-    template<typename _Clock, typename _Dur1,\n-\t     typename _Rep2, typename _Period2>\n-      constexpr time_point<_Clock,\n-\ttypename common_type<_Dur1, duration<_Rep2, _Period2>>::type>\n-      operator-(const time_point<_Clock, _Dur1>& __lhs,\n-\t\tconst duration<_Rep2, _Period2>& __rhs)\n-      {\n-\ttypedef duration<_Rep2, _Period2>\t\t\t__dur2;\n-\ttypedef typename common_type<_Dur1,__dur2>::type\t__ct;\n-\ttypedef time_point<_Clock, __ct>\t\t\t__time_point;\n-\treturn __time_point(__lhs.time_since_epoch() -__rhs);\n-      }\n-\n-    /// The difference between two time points (as a duration)\n-    template<typename _Clock, typename _Dur1, typename _Dur2>\n-      constexpr typename common_type<_Dur1, _Dur2>::type\n-      operator-(const time_point<_Clock, _Dur1>& __lhs,\n-\t\tconst time_point<_Clock, _Dur2>& __rhs)\n-      { return __lhs.time_since_epoch() - __rhs.time_since_epoch(); }\n-    /// @}\n-\n-    /** @{\n-     * Comparisons for time_point\n-     * @relates chrono::time_point\n-     */\n-\n-    template<typename _Clock, typename _Dur1, typename _Dur2>\n-      constexpr bool\n-      operator==(const time_point<_Clock, _Dur1>& __lhs,\n-\t\t const time_point<_Clock, _Dur2>& __rhs)\n-      { return __lhs.time_since_epoch() == __rhs.time_since_epoch(); }\n-\n-#if __cpp_lib_three_way_comparison\n-    template<typename _Clock, typename _Dur1,\n-\t     three_way_comparable_with<_Dur1> _Dur2>\n-      constexpr auto\n-      operator<=>(const time_point<_Clock, _Dur1>& __lhs,\n-\t\t  const time_point<_Clock, _Dur2>& __rhs)\n-      { return __lhs.time_since_epoch() <=> __rhs.time_since_epoch(); }\n-#else\n-    template<typename _Clock, typename _Dur1, typename _Dur2>\n-      constexpr bool\n-      operator!=(const time_point<_Clock, _Dur1>& __lhs,\n-\t\t const time_point<_Clock, _Dur2>& __rhs)\n-      { return !(__lhs == __rhs); }\n-#endif\n-\n-    template<typename _Clock, typename _Dur1, typename _Dur2>\n-      constexpr bool\n-      operator<(const time_point<_Clock, _Dur1>& __lhs,\n-\t\tconst time_point<_Clock, _Dur2>& __rhs)\n-      { return  __lhs.time_since_epoch() < __rhs.time_since_epoch(); }\n-\n-    template<typename _Clock, typename _Dur1, typename _Dur2>\n-      constexpr bool\n-      operator<=(const time_point<_Clock, _Dur1>& __lhs,\n-\t\t const time_point<_Clock, _Dur2>& __rhs)\n-      { return !(__rhs < __lhs); }\n-\n-    template<typename _Clock, typename _Dur1, typename _Dur2>\n-      constexpr bool\n-      operator>(const time_point<_Clock, _Dur1>& __lhs,\n-\t\tconst time_point<_Clock, _Dur2>& __rhs)\n-      { return __rhs < __lhs; }\n-\n-    template<typename _Clock, typename _Dur1, typename _Dur2>\n-      constexpr bool\n-      operator>=(const time_point<_Clock, _Dur1>& __lhs,\n-\t\t const time_point<_Clock, _Dur2>& __rhs)\n-      { return !(__lhs < __rhs); }\n-\n-    /// @}\n-\n-    // Clocks.\n-\n-    // Why nanosecond resolution as the default?\n-    // Why have std::system_clock always count in the highest\n-    // resolution (ie nanoseconds), even if on some OSes the low 3\n-    // or 9 decimal digits will be always zero? This allows later\n-    // implementations to change the system_clock::now()\n-    // implementation any time to provide better resolution without\n-    // changing function signature or units.\n-\n-    // To support the (forward) evolution of the library's defined\n-    // clocks, wrap inside inline namespace so that the current\n-    // defintions of system_clock, steady_clock, and\n-    // high_resolution_clock types are uniquely mangled. This way, new\n-    // code can use the latests clocks, while the library can contain\n-    // compatibility definitions for previous versions.  At some\n-    // point, when these clocks settle down, the inlined namespaces\n-    // can be removed.  XXX GLIBCXX_ABI Deprecated\n-    inline namespace _V2 {\n-\n-    /**\n-     *  @brief System clock.\n-     *\n-     *  Time returned represents wall time from the system-wide clock.\n-     *  @ingroup chrono\n-    */\n-    struct system_clock\n-    {\n-      typedef chrono::nanoseconds\t\t\t\tduration;\n-      typedef duration::rep\t\t\t\t\trep;\n-      typedef duration::period\t\t\t\t\tperiod;\n-      typedef chrono::time_point<system_clock, duration> \ttime_point;\n-\n-      static_assert(system_clock::duration::min()\n-\t\t    < system_clock::duration::zero(),\n-\t\t    \"a clock's minimum duration cannot be less than its epoch\");\n-\n-      static constexpr bool is_steady = false;\n-\n-      static time_point\n-      now() noexcept;\n-\n-      // Map to C API\n-      static std::time_t\n-      to_time_t(const time_point& __t) noexcept\n-      {\n-\treturn std::time_t(duration_cast<chrono::seconds>\n-\t\t\t   (__t.time_since_epoch()).count());\n-      }\n-\n-      static time_point\n-      from_time_t(std::time_t __t) noexcept\n-      {\n-\ttypedef chrono::time_point<system_clock, seconds>\t__from;\n-\treturn time_point_cast<system_clock::duration>\n-\t       (__from(chrono::seconds(__t)));\n-      }\n-    };\n-\n-\n-    /**\n-     *  @brief Monotonic clock\n-     *\n-     *  Time returned has the property of only increasing at a uniform rate.\n-     *  @ingroup chrono\n-    */\n-    struct steady_clock\n-    {\n-      typedef chrono::nanoseconds\t\t\t\tduration;\n-      typedef duration::rep\t\t\t\t\trep;\n-      typedef duration::period\t\t\t\t\tperiod;\n-      typedef chrono::time_point<steady_clock, duration>\ttime_point;\n-\n-      static constexpr bool is_steady = true;\n-\n-      static time_point\n-      now() noexcept;\n-    };\n-\n-\n-    /**\n-     *  @brief Highest-resolution clock\n-     *\n-     *  This is the clock \"with the shortest tick period.\" Alias to\n-     *  std::system_clock until higher-than-nanosecond definitions\n-     *  become feasible.\n-     *  @ingroup chrono\n-    */\n-    using high_resolution_clock = system_clock;\n-\n-    } // end inline namespace _V2\n-\n-#if __cplusplus > 201703L\n-    template<typename _Duration>\n-      using sys_time = time_point<system_clock, _Duration>;\n-    using sys_seconds = sys_time<seconds>;\n-    using sys_days = sys_time<days>;\n-\n-    using file_clock = ::std::filesystem::__file_clock;\n-\n-    template<typename _Duration>\n-      using file_time = time_point<file_clock, _Duration>;\n-\n-    template<> struct is_clock<system_clock> : true_type { };\n-    template<> struct is_clock<steady_clock> : true_type { };\n-    template<> struct is_clock<file_clock> : true_type { };\n-\n-    template<> inline constexpr bool is_clock_v<system_clock> = true;\n-    template<> inline constexpr bool is_clock_v<steady_clock> = true;\n-    template<> inline constexpr bool is_clock_v<file_clock> = true;\n-\n     struct local_t { };\n     template<typename _Duration>\n       using local_time = time_point<local_t, _Duration>;\n@@ -3157,150 +2010,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \tchrono::seconds _M_s;\n \tprecision _M_ss;\n       };\n-#endif // C++20\n-\n-    /// @} group chrono\n-  } // namespace chrono\n-\n-#if __cplusplus > 201103L\n-\n-#define __cpp_lib_chrono_udls 201304\n-\n-  inline namespace literals\n-  {\n-  /** ISO C++ 2014  namespace for suffixes for duration literals.\n-   *\n-   * These suffixes can be used to create `chrono::duration` values with\n-   * tick periods of hours, minutes, seconds, milliseconds, microseconds\n-   * or nanoseconds. For example, `std::chrono::seconds(5)` can be written\n-   * as `5s` after making the suffix visible in the current scope.\n-   * The suffixes can be made visible by a using-directive or\n-   * using-declaration such as:\n-   *  - `using namespace std::chrono_literals;`\n-   *  - `using namespace std::literals;`\n-   *  - `using namespace std::chrono;`\n-   *  - `using namespace std;`\n-   *  - `using std::chrono_literals::operator\"\"s;`\n-   *\n-   * The result of these suffixes on an integer literal is one of the\n-   * standard typedefs such as `std::chrono::hours`.\n-   * The result on a floating-point literal is a duration type with the\n-   * specified tick period and an unspecified floating-point representation,\n-   * for example `1.5e2ms` might be equivalent to\n-   * `chrono::duration<long double, chrono::milli>(1.5e2)`.\n-   *\n-   * @ingroup chrono\n-   */\n-  inline namespace chrono_literals\n-  {\n-    /// @addtogroup chrono\n-    /// @{\n-\n-#pragma GCC diagnostic push\n-#pragma GCC diagnostic ignored \"-Wliteral-suffix\"\n-    /// @cond undocumented\n-    template<typename _Dur, char... _Digits>\n-      constexpr _Dur __check_overflow()\n-      {\n-\tusing _Val = __parse_int::_Parse_int<_Digits...>;\n-\tconstexpr typename _Dur::rep __repval = _Val::value;\n-\tstatic_assert(__repval >= 0 && __repval == _Val::value,\n-\t\t      \"literal value cannot be represented by duration type\");\n-\treturn _Dur(__repval);\n-      }\n-    /// @endcond\n-\n-    /// Literal suffix for durations representing non-integer hours\n-    constexpr chrono::duration<long double, ratio<3600,1>>\n-    operator\"\"h(long double __hours)\n-    { return chrono::duration<long double, ratio<3600,1>>{__hours}; }\n-\n-    /// Literal suffix for durations of type `std::chrono::hours`\n-    template <char... _Digits>\n-      constexpr chrono::hours\n-      operator\"\"h()\n-      { return __check_overflow<chrono::hours, _Digits...>(); }\n-\n-    /// Literal suffix for durations representing non-integer minutes\n-    constexpr chrono::duration<long double, ratio<60,1>>\n-    operator\"\"min(long double __mins)\n-    { return chrono::duration<long double, ratio<60,1>>{__mins}; }\n-\n-    /// Literal suffix for durations of type `std::chrono::minutes`\n-    template <char... _Digits>\n-      constexpr chrono::minutes\n-      operator\"\"min()\n-      { return __check_overflow<chrono::minutes, _Digits...>(); }\n-\n-    /// Literal suffix for durations representing non-integer seconds\n-    constexpr chrono::duration<long double>\n-    operator\"\"s(long double __secs)\n-    { return chrono::duration<long double>{__secs}; }\n-\n-    /// Literal suffix for durations of type `std::chrono::seconds`\n-    template <char... _Digits>\n-      constexpr chrono::seconds\n-      operator\"\"s()\n-      { return __check_overflow<chrono::seconds, _Digits...>(); }\n-\n-    /// Literal suffix for durations representing non-integer milliseconds\n-    constexpr chrono::duration<long double, milli>\n-    operator\"\"ms(long double __msecs)\n-    { return chrono::duration<long double, milli>{__msecs}; }\n-\n-    /// Literal suffix for durations of type `std::chrono::milliseconds`\n-    template <char... _Digits>\n-      constexpr chrono::milliseconds\n-      operator\"\"ms()\n-      { return __check_overflow<chrono::milliseconds, _Digits...>(); }\n-\n-    /// Literal suffix for durations representing non-integer microseconds\n-    constexpr chrono::duration<long double, micro>\n-    operator\"\"us(long double __usecs)\n-    { return chrono::duration<long double, micro>{__usecs}; }\n-\n-    /// Literal suffix for durations of type `std::chrono::microseconds`\n-    template <char... _Digits>\n-      constexpr chrono::microseconds\n-      operator\"\"us()\n-      { return __check_overflow<chrono::microseconds, _Digits...>(); }\n-\n-    /// Literal suffix for durations representing non-integer nanoseconds\n-    constexpr chrono::duration<long double, nano>\n-    operator\"\"ns(long double __nsecs)\n-    { return chrono::duration<long double, nano>{__nsecs}; }\n-\n-    /// Literal suffix for durations of type `std::chrono::nanoseconds`\n-    template <char... _Digits>\n-      constexpr chrono::nanoseconds\n-      operator\"\"ns()\n-      { return __check_overflow<chrono::nanoseconds, _Digits...>(); }\n-\n-#if __cplusplus > 201703L\n-    constexpr chrono::day\n-    operator\"\"d(unsigned long long __d) noexcept\n-    { return chrono::day{static_cast<unsigned>(__d)}; }\n-\n-    constexpr chrono::year\n-    operator\"\"y(unsigned long long __y) noexcept\n-    { return chrono::year{static_cast<int>(__y)}; }\n-#endif // C++20\n-\n-#pragma GCC diagnostic pop\n-    /// @}\n-  } // inline namespace chrono_literals\n-  } // inline namespace literals\n-\n-  namespace chrono\n-  {\n-    using namespace literals::chrono_literals;\n-  } // namespace chrono\n-\n-#if __cplusplus > 201703L\n-  namespace chrono\n-  {\n-    /// @addtogroup chrono\n-    /// @{\n \n     // 12/24 HOURS FUNCTIONS\n \n@@ -3341,71 +2050,34 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t}\n     }\n     /// @} group chrono\n+#endif // C++20\n   } // namespace chrono\n-#endif\n \n-#if __cplusplus >= 201703L\n-  namespace filesystem\n+#if __cplusplus >= 202002L\n+  inline namespace literals\n   {\n-    struct __file_clock\n-    {\n-      using duration                  = chrono::nanoseconds;\n-      using rep                       = duration::rep;\n-      using period                    = duration::period;\n-      using time_point                = chrono::time_point<__file_clock>;\n-      static constexpr bool is_steady = false;\n-\n-      static time_point\n-      now() noexcept\n-      { return _S_from_sys(chrono::system_clock::now()); }\n-\n-#if __cplusplus > 201703L\n-      template<typename _Dur>\n-\tstatic\n-\tchrono::file_time<_Dur>\n-\tfrom_sys(const chrono::sys_time<_Dur>& __t) noexcept\n-\t{ return _S_from_sys(__t); }\n-\n-      // For internal use only\n-      template<typename _Dur>\n-\tstatic\n-\tchrono::sys_time<_Dur>\n-\tto_sys(const chrono::file_time<_Dur>& __t) noexcept\n-\t{ return _S_to_sys(__t); }\n-#endif // C++20\n-\n-    private:\n-      using __sys_clock = chrono::system_clock;\n-\n-      // This clock's (unspecified) epoch is 2174-01-01 00:00:00 UTC.\n-      // A signed 64-bit duration with nanosecond resolution gives roughly\n-      // +/- 292 years, which covers the 1901-2446 date range for ext4.\n-      static constexpr chrono::seconds _S_epoch_diff{6437664000};\n-\n-    protected:\n-      // For internal use only\n-      template<typename _Dur>\n-\tstatic\n-\tchrono::time_point<__file_clock, _Dur>\n-\t_S_from_sys(const chrono::time_point<__sys_clock, _Dur>& __t) noexcept\n-\t{\n-\t  using __file_time = chrono::time_point<__file_clock, _Dur>;\n-\t  return __file_time{__t.time_since_epoch()} - _S_epoch_diff;\n-\t}\n+  inline namespace chrono_literals\n+  {\n+    /// @addtogroup chrono\n+    /// @{\n+#pragma GCC diagnostic push\n+#pragma GCC diagnostic ignored \"-Wliteral-suffix\"\n+    /// Literal suffix for creating chrono::day objects.\n+    /// @since C++20\n+    constexpr chrono::day\n+    operator\"\"d(unsigned long long __d) noexcept\n+    { return chrono::day{static_cast<unsigned>(__d)}; }\n \n-      // For internal use only\n-      template<typename _Dur>\n-\tstatic\n-\tchrono::time_point<__sys_clock, _Dur>\n-\t_S_to_sys(const chrono::time_point<__file_clock, _Dur>& __t) noexcept\n-\t{\n-\t  using __sys_time = chrono::time_point<__sys_clock, _Dur>;\n-\t  return __sys_time{__t.time_since_epoch()} + _S_epoch_diff;\n-\t}\n-    };\n-  } // namespace filesystem\n-#endif // C++17\n-#endif // C++14\n+    /// Literal suffix for creating chrono::year objects.\n+    /// @since C++20\n+    constexpr chrono::year\n+    operator\"\"y(unsigned long long __y) noexcept\n+    { return chrono::year{static_cast<int>(__y)}; }\n+#pragma GCC diagnostic pop\n+    /// @}\n+  } // inline namespace chrono_literals\n+  } // inline namespace literals\n+#endif // C++20\n \n _GLIBCXX_END_NAMESPACE_VERSION\n } // namespace std"}, {"sha": "4fcec6aa73d2363152707d6eb0a85a8c8b1e3377", "filename": "libstdc++-v3/include/std/condition_variable", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f78718b7958f603d50d5c30fd8735d73900bd1f/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcondition_variable", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f78718b7958f603d50d5c30fd8735d73900bd1f/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcondition_variable", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fcondition_variable?ref=7f78718b7958f603d50d5c30fd8735d73900bd1f", "patch": "@@ -35,8 +35,7 @@\n # include <bits/c++0x_warning.h>\n #else\n \n-#include <chrono>\n-\n+#include <bits/chrono.h>\n #include <bits/std_mutex.h>\n #include <bits/unique_lock.h>\n #include <bits/alloc_traits.h>"}, {"sha": "12918fd19e76a8c85f302922a3e22adc11f73621", "filename": "libstdc++-v3/include/std/mutex", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f78718b7958f603d50d5c30fd8735d73900bd1f/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fmutex", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f78718b7958f603d50d5c30fd8735d73900bd1f/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fmutex", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fmutex?ref=7f78718b7958f603d50d5c30fd8735d73900bd1f", "patch": "@@ -36,10 +36,10 @@\n #else\n \n #include <tuple>\n-#include <chrono>\n #include <exception>\n #include <type_traits>\n #include <system_error>\n+#include <bits/chrono.h>\n #include <bits/std_mutex.h>\n #include <bits/unique_lock.h>\n #if ! _GTHREAD_USE_MUTEX_TIMEDLOCK"}, {"sha": "4611a108203f48d9f183cf51fa807c7ebb9d23c3", "filename": "libstdc++-v3/include/std/shared_mutex", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f78718b7958f603d50d5c30fd8735d73900bd1f/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fshared_mutex", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f78718b7958f603d50d5c30fd8735d73900bd1f/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fshared_mutex", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fshared_mutex?ref=7f78718b7958f603d50d5c30fd8735d73900bd1f", "patch": "@@ -33,7 +33,7 @@\n \n #if __cplusplus >= 201402L\n \n-#include <chrono>\n+#include <bits/chrono.h>\n #include <bits/functexcept.h>\n #include <bits/move.h>        // move, __exchange\n #include <bits/std_mutex.h>   // defer_lock_t"}]}