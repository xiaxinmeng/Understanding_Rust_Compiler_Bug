{"sha": "1d5565cdf26d8af5d3b722f4058ebe13b601c4d5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWQ1NTY1Y2RmMjZkOGFmNWQzYjcyMmY0MDU4ZWJlMTNiNjAxYzRkNQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "rsandifo@redhat.com", "date": "2003-08-10T08:34:32Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2003-08-10T08:34:32Z"}, "message": "mips-protos.h (coprocessor_operand): Remove declaration.\n\n\t* config/mips/mips-protos.h (coprocessor_operand): Remove declaration.\n\t(coprocessor2_operand): Likewise.\n\t* config/mips/mips.c (STAB_CODE_TYPE): Remove.\n\t(lookup_name): Remove declaration.\n\t(abort_with_insn): Remove.  Replace all uses with fatal_insn.\n\t(mips16, mips_abicalls): Remove.\n\t(mips_char_to_class): Remove initialiser: all entries are NO_REGS.\n\t(arith32_operand, large_int, true_reg_or_0_operand): Remove.\n\t(coprocessor_operand, coprocessor2_operand): Remove.\n\t(override_options): Don't set mips16 or mips_abicalls.\n\t(print_operand): Don't expect SIGN_EXTEND operands.\n\t(mips_secondary_reload_class): Likewise.\n\t(mips_output_conditional_branch): Remove disabled long-branch code.\n\t* config/mips/mips.h (call_used_regs): Remove declaration.\n\t(may_call_alloca): Likewise.\n\t(mips_cpu_attr, mips_abicalls_type, mips_abicalls_attr): Remove.\n\t(mips_abicalls, mips16): Remove declarations.\n\t(ASM_FINAL_SPEC, LIB_SPEC): Remove.\n\t(CC1_SPEC): Remove outdated comment.\n\t(MIPS_VERSION, MACHINE_TYPE): Remove.\n\t(TARGET_VERSION_INTERNAL, TARGET_VERSION): Remove.\n\t(PC_REGNUM, STACK_POINTER_OFFSET): Remove disabled definitions.\n\t(STRUCT_VALUE_RETURN_REGNUM, STACK_DYNAMIC_OFFSET): Likewise.\n\t(PUSH_ROUNDING): Likewise.\n\t(ASSEMBLER_SCRATCH_REGNUM): Remove.\n\t* config/mips/mips.md: Replace mips_cpu_attr with mips_tune\n\tand mips16 with TARGET_MIPS16.\n\nFrom-SVN: r70286", "tree": {"sha": "9957888bd7f39cb55be005a1d8e2b87f343e8457", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9957888bd7f39cb55be005a1d8e2b87f343e8457"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1d5565cdf26d8af5d3b722f4058ebe13b601c4d5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d5565cdf26d8af5d3b722f4058ebe13b601c4d5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1d5565cdf26d8af5d3b722f4058ebe13b601c4d5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d5565cdf26d8af5d3b722f4058ebe13b601c4d5/comments", "author": null, "committer": null, "parents": [{"sha": "b63853f9fd9cc94ebcfcfd908f82384a83641638", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b63853f9fd9cc94ebcfcfd908f82384a83641638", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b63853f9fd9cc94ebcfcfd908f82384a83641638"}], "stats": {"total": 520, "additions": 43, "deletions": 477}, "files": [{"sha": "0c340370c4aa3623dc12689e0977571ccaccdeb1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d5565cdf26d8af5d3b722f4058ebe13b601c4d5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d5565cdf26d8af5d3b722f4058ebe13b601c4d5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1d5565cdf26d8af5d3b722f4058ebe13b601c4d5", "patch": "@@ -1,3 +1,33 @@\n+2003-08-10  Richard Sandiford  <rsandifo@redhat.com>\n+\n+\t* config/mips/mips-protos.h (coprocessor_operand): Remove declaration.\n+\t(coprocessor2_operand): Likewise.\n+\t* config/mips/mips.c (STAB_CODE_TYPE): Remove.\n+\t(lookup_name): Remove declaration.\n+\t(abort_with_insn): Remove.  Replace all uses with fatal_insn.\n+\t(mips16, mips_abicalls): Remove.\n+\t(mips_char_to_class): Remove initialiser: all entries are NO_REGS.\n+\t(arith32_operand, large_int, true_reg_or_0_operand): Remove.\n+\t(coprocessor_operand, coprocessor2_operand): Remove.\n+\t(override_options): Don't set mips16 or mips_abicalls.\n+\t(print_operand): Don't expect SIGN_EXTEND operands.\n+\t(mips_secondary_reload_class): Likewise.\n+\t(mips_output_conditional_branch): Remove disabled long-branch code.\n+\t* config/mips/mips.h (call_used_regs): Remove declaration.\n+\t(may_call_alloca): Likewise.\n+\t(mips_cpu_attr, mips_abicalls_type, mips_abicalls_attr): Remove.\n+\t(mips_abicalls, mips16): Remove declarations.\n+\t(ASM_FINAL_SPEC, LIB_SPEC): Remove.\n+\t(CC1_SPEC): Remove outdated comment.\n+\t(MIPS_VERSION, MACHINE_TYPE): Remove.\n+\t(TARGET_VERSION_INTERNAL, TARGET_VERSION): Remove.\n+\t(PC_REGNUM, STACK_POINTER_OFFSET): Remove disabled definitions.\n+\t(STRUCT_VALUE_RETURN_REGNUM, STACK_DYNAMIC_OFFSET): Likewise.\n+\t(PUSH_ROUNDING): Likewise.\n+\t(ASSEMBLER_SCRATCH_REGNUM): Remove.\n+\t* config/mips/mips.md: Replace mips_cpu_attr with mips_tune\n+\tand mips16 with TARGET_MIPS16.\n+\n 2003-08-09  Per Bothner  <pbothner@apple.com>\n \n         * cppinit.c (cpp_read_main_file):  Split out source-independent"}, {"sha": "02fb475a6e6b022ccba016b8b0deadb73bfce84a", "filename": "gcc/config/mips/mips-protos.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d5565cdf26d8af5d3b722f4058ebe13b601c4d5/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d5565cdf26d8af5d3b722f4058ebe13b601c4d5/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips-protos.h?ref=1d5565cdf26d8af5d3b722f4058ebe13b601c4d5", "patch": "@@ -128,8 +128,6 @@ extern int              mips_register_move_cost PARAMS ((enum machine_mode,\n \t\t\t\t\t\t\t enum reg_class));\n \n extern int\t\tse_arith_operand PARAMS ((rtx, enum machine_mode));\n-extern int\t\tcoprocessor_operand PARAMS ((rtx, enum machine_mode));\n-extern int\t\tcoprocessor2_operand PARAMS ((rtx, enum machine_mode));\n extern int\t\tmips_address_insns PARAMS ((rtx, enum machine_mode));\n extern int\t\tmips_fetch_insns PARAMS ((rtx));\n extern int\t\tmips_const_insns PARAMS ((rtx));"}, {"sha": "0d0e2a4ff62ace9ea688323c74855556cdf2c73d", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 10, "deletions": 336, "changes": 346, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d5565cdf26d8af5d3b722f4058ebe13b601c4d5/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d5565cdf26d8af5d3b722f4058ebe13b601c4d5/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=1d5565cdf26d8af5d3b722f4058ebe13b601c4d5", "patch": "@@ -23,10 +23,6 @@ along with GNU CC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n-/* ??? The TARGET_FP_CALL_32 macros are intended to simulate a 32 bit\n-   calling convention in 64 bit mode.  It doesn't work though, and should\n-   be replaced with something better designed.  */\n-\n #include \"config.h\"\n #include \"system.h\"\n #include \"coretypes.h\"\n@@ -56,14 +52,6 @@ Boston, MA 02111-1307, USA.  */\n #include \"target-def.h\"\n #include \"integrate.h\"\n \n-#ifdef __GNU_STAB__\n-#define STAB_CODE_TYPE enum __stab_debug_code\n-#else\n-#define STAB_CODE_TYPE int\n-#endif\n-\n-extern tree   lookup_name PARAMS ((tree));\n-\n /* Enumeration for all of the relational tests, so that we can build\n    arrays indexed by the test type, and not worry about the order\n    of EQ, NE, etc.  */\n@@ -255,8 +243,6 @@ static void mips_avoid_hazard\t\t\tPARAMS ((rtx, rtx, int *,\n \t\t\t\t\t\t\t rtx *, rtx));\n static void mips_avoid_hazards\t\t\tPARAMS ((void));\n static void mips_reorg\t\t\t\tPARAMS ((void));\n-static void abort_with_insn\t\t\tPARAMS ((rtx, const char *))\n-  ATTRIBUTE_NORETURN;\n static int symbolic_expression_p                PARAMS ((rtx));\n static bool mips_assemble_integer\t  PARAMS ((rtx, unsigned int, int));\n static void mips_output_function_epilogue PARAMS ((FILE *, HOST_WIDE_INT));\n@@ -517,10 +503,6 @@ const char *mips_tune_string;   /* for -mtune=<xxx> */\n const char *mips_isa_string;\t/* for -mips{1,2,3,4} */\n const char *mips_abi_string;\t/* for -mabi={32,n32,64,eabi} */\n \n-/* Whether we are generating mips16 code.  This is a synonym for\n-   TARGET_MIPS16, and exists for use as an attribute.  */\n-int mips16;\n-\n /* This variable is set by -mno-mips16.  We only care whether\n    -mno-mips16 appears or not, and using a string in this fashion is\n    just a way to avoid using up another bit in target_flags.  */\n@@ -545,9 +527,6 @@ int mips_entry;\n /* If TRUE, we split addresses into their high and low parts in the RTL.  */\n int mips_split_addresses;\n \n-/* Generating calls to position independent functions?  */\n-enum mips_abicalls_type mips_abicalls;\n-\n /* Mode used for saving/restoring general purpose registers.  */\n static enum machine_mode gpr_mode;\n \n@@ -699,73 +678,7 @@ const enum reg_class mips_regno_to_class[] =\n };\n \n /* Map register constraint character to register class.  */\n-enum reg_class mips_char_to_class[256] =\n-{\n-  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n-  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n-  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n-  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n-  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n-  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n-  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n-  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n-  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n-  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n-  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n-  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n-  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n-  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n-  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n-  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n-  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n-  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n-  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n-  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n-  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n-  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n-  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n-  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n-  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n-  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n-  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n-  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n-  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n-  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n-  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n-  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n-  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n-  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n-  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n-  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n-  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n-  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n-  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n-  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n-  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n-  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n-  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n-  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n-  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n-  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n-  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n-  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n-  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n-  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n-  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n-  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n-  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n-  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n-  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n-  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n-  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n-  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n-  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n-  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n-  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n-  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n-  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n-  NO_REGS,\tNO_REGS,\tNO_REGS,\tNO_REGS,\n-};\n+enum reg_class mips_char_to_class[256];\n \f\n /* A table describing all the processors gcc knows about.  Names are\n    matched in the order listed.  The first mention of an ISA level is\n@@ -1423,20 +1336,6 @@ arith_operand (op, mode)\n   return const_arith_operand (op, mode) || register_operand (op, mode);\n }\n \n-/* Return truth value of whether OP can be used as an operand in a two\n-   address arithmetic insn (such as set 123456,%o4) of mode MODE.  */\n-\n-int\n-arith32_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n-{\n-  if (GET_CODE (op) == CONST_INT)\n-    return 1;\n-\n-  return register_operand (op, mode);\n-}\n-\n /* Return truth value of whether OP is an integer which fits in 16 bits.  */\n \n int\n@@ -1447,36 +1346,6 @@ small_int (op, mode)\n   return (GET_CODE (op) == CONST_INT && SMALL_INT (op));\n }\n \n-/* Return truth value of whether OP is a 32 bit integer which is too big to\n-   be loaded with one instruction.  */\n-\n-int\n-large_int (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n-{\n-  HOST_WIDE_INT value;\n-\n-  if (GET_CODE (op) != CONST_INT)\n-    return 0;\n-\n-  value = INTVAL (op);\n-\n-  /* ior reg,$r0,value */\n-  if ((value & ~ ((HOST_WIDE_INT) 0x0000ffff)) == 0)\n-    return 0;\n-\n-  /* subu reg,$r0,value */\n-  if (((unsigned HOST_WIDE_INT) (value + 32768)) <= 32767)\n-    return 0;\n-\n-  /* lui reg,value>>16 */\n-  if ((value & 0x0000ffff) == 0)\n-    return 0;\n-\n-  return 1;\n-}\n-\n /* Return truth value of whether OP is a register or the constant 0.\n    In mips16 mode, we only accept a register, since the mips16 does\n    not have $0.  */\n@@ -1503,27 +1372,6 @@ reg_or_0_operand (op, mode)\n     }\n }\n \n-/* Return truth value of whether OP is a register or the constant 0,\n-   even in mips16 mode.  */\n-\n-int\n-true_reg_or_0_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode;\n-{\n-  switch (GET_CODE (op))\n-    {\n-    case CONST_INT:\n-      return INTVAL (op) == 0;\n-\n-    case CONST_DOUBLE:\n-      return op == CONST0_RTX (mode);\n-\n-    default:\n-      return register_operand (op, mode);\n-    }\n-}\n-\n /* Accept the floating point constant 1 in the appropriate mode.  */\n \n int\n@@ -1699,29 +1547,6 @@ consttable_operand (op, mode)\n   return CONSTANT_P (op);\n }\n \n-/* Coprocessor operand; return true if rtx is a REG and refers to a\n-   coprocessor.  */\n-\n-int\n-coprocessor_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n-{\n-  return (GET_CODE (op) == REG\n-\t  && COP0_REG_FIRST <= REGNO (op)\n-\t  && REGNO (op) <= COP3_REG_LAST);\n-}\n-\n-int\n-coprocessor2_operand (op, mode)\n-     rtx op;\n-     enum machine_mode mode ATTRIBUTE_UNUSED;\n-{\n-  return (GET_CODE (op) == REG\n-\t  && COP2_REG_FIRST <= REGNO (op)\n-\t  && REGNO (op) <= COP2_REG_LAST);\n-}\n-\n /* Returns 1 if OP is a symbolic operand, i.e. a symbol_ref or a label_ref,\n    possibly with an offset.  */\n \n@@ -3406,7 +3231,7 @@ gen_conditional_branch (operands, test_code)\n       break;\n \n     default:\n-      abort_with_insn (gen_rtx (test_code, VOIDmode, cmp0, cmp1), \"bad test\");\n+      fatal_insn (\"bad test\", gen_rtx (test_code, VOIDmode, cmp0, cmp1));\n     }\n \n   /* Generate the branch.  */\n@@ -4804,18 +4629,6 @@ mips_va_arg (valist, type)\n     }\n }\n \f\n-/* Abort after printing out a specific insn.  */\n-\n-static void\n-abort_with_insn (insn, reason)\n-     rtx insn;\n-     const char *reason;\n-{\n-  error (reason);\n-  debug_rtx (insn);\n-  abort ();\n-}\n-\f\n /* Set up globals to generate code for the ISA or processor\n    described by INFO.  */\n \n@@ -5050,14 +4863,11 @@ override_options ()\n      implemented.  */\n   if (TARGET_ABICALLS)\n     {\n-      mips_abicalls = MIPS_ABICALLS_YES;\n       if (flag_pic == 0)\n \tflag_pic = 1;\n       if (mips_section_threshold > 0)\n \twarning (\"-G is incompatible with PIC code which is the default\");\n     }\n-  else\n-    mips_abicalls = MIPS_ABICALLS_NO;\n \n   /* The MIPS and SGI o32 assemblers expect small-data variables to\n      be declared before they are used.  Although we once had code to\n@@ -5172,13 +4982,6 @@ override_options ()\n \tmips_entry = 1;\n     }\n \n-  /* We copy TARGET_MIPS16 into the mips16 global variable, so that\n-     attributes can access it.  */\n-  if (TARGET_MIPS16)\n-    mips16 = 1;\n-  else\n-    mips16 = 0;\n-\n   /* When using explicit relocs, we call dbr_schedule from within\n      mips_reorg.  */\n   if (TARGET_EXPLICIT_RELOCS)\n@@ -5454,7 +5257,8 @@ mips_debugger_offset (addr, offset)\n   /* sdbout_parms does not want this to crash for unrecognized cases.  */\n #if 0\n   else if (reg != arg_pointer_rtx)\n-    abort_with_insn (addr, \"mips_debugger_offset called with non stack/frame/arg pointer\");\n+    fatal_insn (\"mips_debugger_offset called with non stack/frame/arg pointer\",\n+\t\taddr);\n #endif\n \n   return offset;\n@@ -5671,9 +5475,6 @@ print_operand (file, op, letter)\n \n   code = GET_CODE (op);\n \n-  if (code == SIGN_EXTEND)\n-    op = XEXP (op, 0), code = GET_CODE (op);\n-\n   if (letter == 'R')\n     {\n       if (TARGET_ABICALLS && TARGET_NEWABI)\n@@ -5707,7 +5508,7 @@ print_operand (file, op, letter)\n       case LTU: fputs (\"ltu\", file); break;\n       case LEU: fputs (\"leu\", file); break;\n       default:\n-\tabort_with_insn (op, \"PRINT_OPERAND, invalid insn for %%C\");\n+\tfatal_insn (\"PRINT_OPERAND, invalid insn for %%C\", op);\n       }\n \n   else if (letter == 'N')\n@@ -5724,7 +5525,7 @@ print_operand (file, op, letter)\n       case LTU: fputs (\"geu\", file); break;\n       case LEU: fputs (\"gtu\", file); break;\n       default:\n-\tabort_with_insn (op, \"PRINT_OPERAND, invalid insn for %%N\");\n+\tfatal_insn (\"PRINT_OPERAND, invalid insn for %%N\", op);\n       }\n \n   else if (letter == 'F')\n@@ -5733,7 +5534,7 @@ print_operand (file, op, letter)\n       case EQ: fputs (\"c1f\", file); break;\n       case NE: fputs (\"c1t\", file); break;\n       default:\n-\tabort_with_insn (op, \"PRINT_OPERAND, invalid insn for %%F\");\n+\tfatal_insn (\"PRINT_OPERAND, invalid insn for %%F\", op);\n       }\n \n   else if (letter == 'W')\n@@ -5742,7 +5543,7 @@ print_operand (file, op, letter)\n       case EQ: fputs (\"c1t\", file); break;\n       case NE: fputs (\"c1f\", file); break;\n       default:\n-\tabort_with_insn (op, \"PRINT_OPERAND, invalid insn for %%W\");\n+\tfatal_insn (\"PRINT_OPERAND, invalid insn for %%W\", op);\n       }\n \n   else if (letter == 'S')\n@@ -7325,7 +7126,7 @@ mips_expand_prologue ()\n \t  pattern = RTVEC_ELT (adjust, i);\n \t  if (GET_CODE (pattern) != SET\n \t      || GET_CODE (SET_SRC (pattern)) != ASHIFT)\n-\t    abort_with_insn (pattern, \"insn is not a shift\");\n+\t    fatal_insn (\"insn is not a shift\", pattern);\n \t  PUT_CODE (SET_SRC (pattern), ASHIFTRT);\n \n \t  insn = emit_insn (pattern);\n@@ -8260,45 +8061,7 @@ mips_secondary_reload_class (class, mode, x, in_p)\n   int regno = -1;\n   int gp_reg_p;\n \n-  if (GET_CODE (x) == SIGN_EXTEND)\n-    {\n-      int off = 0;\n-\n-      x = XEXP (x, 0);\n-\n-      /* We may be called with reg_renumber NULL from regclass.\n-\t ??? This is probably a bug.  */\n-      if (reg_renumber)\n-\tregno = true_regnum (x);\n-      else\n-\t{\n-\t  while (GET_CODE (x) == SUBREG)\n-\t    {\n-\t      off += subreg_regno_offset (REGNO (SUBREG_REG (x)),\n-\t\t\t\t\t  GET_MODE (SUBREG_REG (x)),\n-\t\t\t\t\t  SUBREG_BYTE (x),\n-\t\t\t\t\t  GET_MODE (x));\n-\t      x = SUBREG_REG (x);\n-\t    }\n-\n-\t  if (GET_CODE (x) == REG)\n-\t    regno = REGNO (x) + off;\n-\t}\n-\n-      /* 64-bit floating-point registers don't store 32-bit values\n-\t in sign-extended form.  The only way we can reload\n-\t (sign_extend:DI (reg:SI $f0)) is by moving $f0 into\n-\t an integer register using a 32-bit move.  */\n-      if (FP_REG_P (regno))\n-\treturn (class == GR_REGS ? NO_REGS : GR_REGS);\n-\n-      /* For the same reason, we can only reload (sign_extend:DI FOO) into\n-\t a floating-point register when FOO is an integer register. */\n-      if (class == FP_REGS)\n-\treturn (GP_REG_P (regno) ? NO_REGS : GR_REGS);\n-    }\n-\n-  else if (GET_CODE (x) == REG || GET_CODE (x) == SUBREG)\n+  if (GET_CODE (x) == REG || GET_CODE (x) == SUBREG)\n     regno = true_regnum (x);\n \n   gp_reg_p = TARGET_MIPS16 ? M16_REG_P (regno) : GP_REG_P (regno);\n@@ -10000,95 +9763,6 @@ mips_output_conditional_branch (insn,\n         return \"\";\n       }\n \n-    /* We do not currently use this code.  It handles jumps to\n-       arbitrary locations, using `jr', even across a 256MB boundary.\n-       We could add a -mhuge switch, and then use this code instead of\n-       the `j' alternative above when -mhuge was used.  */\n-#if 0\n-    case 16:\n-    case 20:\n-      {\n-\t/* Generate a reversed conditional branch around a `jr'\n-\t   instruction:\n-\n-\t\t .set noreorder\n-\t\t .set nomacro\n-\t\t .set noat\n-\t\t bc    l\n-\t\t la    $at, target\n-\t\t jr    $at\n-\t\t .set at\n-\t\t .set macro\n-\t\t .set reorder\n-\t      l:\n-\n-\t   Not pretty, but allows a conditional branch anywhere in the\n-\t   32-bit address space.  If the original branch is annulled,\n-\t   then the instruction in the delay slot should be executed\n-\t   only if the branch is taken.  The la instruction is really\n-\t   a macro which will usually take eight bytes, but sometimes\n-\t   takes only four, if the instruction to which we're jumping\n-\t   gets its own entry in the global pointer table, which will\n-\t   happen if its a case label.  The assembler will then\n-\t   generate only a four-byte sequence, rather than eight, and\n-\t   there seems to be no way to tell it not to.  Thus, we can't\n-\t   just use a `.+x' addressing form; we don't know what value\n-\t   to give for `x'.\n-\n-\t   So, we resort to using the explicit relocation syntax\n-\t   available in the assembler and do:\n-\n-\t      lw $at,%got_page(target)($gp)\n-\t      daddiu $at,$at,%got_ofst(target)\n-\n-\t   That way, this always takes up eight bytes, and we can use\n-\t   the `.+x' form.  Of course, these explicit machinations\n-\t   with relocation will not work with old assemblers.  Then\n-\t   again, neither do out-of-range branches, so we haven't lost\n-\t   anything.  */\n-\n-\t/* The target of the reversed branch.  */\n-\tconst char *const target\n-\t  = ((mips_branch_likely || length == 20) ? \".+20\" : \".+16\");\n-\tconst char *at_register = mips_reg_names[ASSEMBLER_SCRATCH_REGNUM];\n-\tconst char *gp_register = mips_reg_names[PIC_OFFSET_TABLE_REGNUM];\n-\tchar *c;\n-\n-\tstrcpy (buffer, \"%(%<%[\");\n-\tc = strchr (buffer, '\\0');\n-\t/* Generate the reversed comparison.  This takes four\n-\t   bytes.  */\n-\tif (float_p)\n-\t  sprintf (c, \"%%*b%s\\t%%Z2%s\",\n-\t\t   inverted_p ? comp : inverted_comp,\n-\t\t   target);\n-\telse\n-\t  sprintf (c, \"%%*b%s%s\\t%s%s,%s\",\n-\t\t   inverted_p ? comp : inverted_comp,\n-\t\t   need_z_p ? \"z\" : \"\",\n-\t\t   op1,\n-\t\t   op2,\n-\t\t   target);\n-\tc = strchr (buffer, '\\0');\n-\t/* Generate the load-address, and jump.  This takes twelve\n-\t   bytes, for a total of 16.  */\n-\tsprintf (c,\n-\t\t \"\\n\\tlw\\t%s,%%%%got_page(%%1)(%s)\\n\\tdaddiu\\t%s,%s,%%%%got_ofst(%%1)\\n\\tjr\\t%s\",\n-\t\t at_register,\n-\t\t gp_register,\n-\t\t at_register,\n-\t\t at_register,\n-\t\t at_register);\n-\tif (length == 20)\n-\t  /* The delay slot was unfilled.  Since we're inside\n-\t     .noreorder, the assembler will not fill in the NOP for\n-\t     us, so we must do it ourselves.  */\n-\t  strcat (buffer, \"\\n\\tnop\");\n-\tstrcat (buffer, \"%]%>%)\");\n-\treturn buffer;\n-      }\n-#endif\n-\n     default:\n       abort ();\n     }"}, {"sha": "f1159e54675e6b0b2e7c4b0800e9919a87b4d67f", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 0, "deletions": 136, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d5565cdf26d8af5d3b722f4058ebe13b601c4d5/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d5565cdf26d8af5d3b722f4058ebe13b601c4d5/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=1d5565cdf26d8af5d3b722f4058ebe13b601c4d5", "patch": "@@ -26,8 +26,6 @@ Boston, MA 02111-1307, USA.  */\n \n /* Standard GCC variables that we reference.  */\n \n-extern char\tcall_used_regs[];\n-extern int\tmay_call_alloca;\n extern int\ttarget_flags;\n \n /* MIPS external variables defined in mips.c.  */\n@@ -72,9 +70,6 @@ enum processor_type {\n   PROCESSOR_SR71000\n };\n \n-/* Recast the cpu class to be the cpu attribute.  */\n-#define mips_cpu_attr ((enum attr_cpu)mips_tune)\n-\n /* Which ABI to use.  ABI_32 (original 32, or o32), ABI_N32 (n32),\n    ABI_64 (n64) are all defined by SGI.  ABI_O64 is o32 extended\n    to work on a 64 bit machine.  */\n@@ -85,16 +80,6 @@ enum processor_type {\n #define ABI_EABI 3\n #define ABI_O64  4\n \n-/* Whether to emit abicalls code sequences or not.  */\n-\n-enum mips_abicalls_type {\n-  MIPS_ABICALLS_NO,\n-  MIPS_ABICALLS_YES\n-};\n-\n-/* Recast the abicalls class to be the abicalls attribute.  */\n-#define mips_abicalls_attr ((enum attr_abicalls)mips_abicalls)\n-\n /* Information about one recognized processor.  Defined here for the\n    benefit of TARGET_CPU_CPP_BUILTINS.  */\n struct mips_cpu_info {\n@@ -128,9 +113,7 @@ extern GTY(()) rtx branch_cmp[2];\t/* operands for compare */\n extern enum cmp_type branch_type;\t/* what type of branch to use */\n extern enum processor_type mips_arch;   /* which cpu to codegen for */\n extern enum processor_type mips_tune;   /* which cpu to schedule for */\n-extern enum mips_abicalls_type mips_abicalls;/* for svr4 abi pic calls */\n extern int mips_isa;\t\t\t/* architectural level */\n-extern int mips16;\t\t\t/* whether generating mips16 code */\n extern int mips16_hard_float;\t\t/* mips16 without -msoft-float */\n extern int mips_entry;\t\t\t/* generate entry/exit for mips16 */\n extern const char *mips_arch_string;    /* for -march=<xxx> */\n@@ -939,19 +922,6 @@ extern const struct mips_cpu_info *mips_tune_info;\n    which write to the HI and LO registers.  Most targets require a\n    two-instruction gap.  */\n #define ISA_HAS_HILO_INTERLOCKS\t(TARGET_MIPS5500 || TARGET_SB1)\n-\n-/* CC1_SPEC causes -mips3 and -mips4 to set -mfp64 and -mgp64; -mips1 or\n-   -mips2 sets -mfp32 and -mgp32.  This can be overridden by an explicit\n-   -mfp32, -mfp64, -mgp32 or -mgp64.  -mfp64 sets MASK_FLOAT64 in\n-   target_flags, and -mgp64 sets MASK_64BIT.\n-\n-   Setting MASK_64BIT in target_flags will cause gcc to assume that\n-   registers are 64 bits wide.  int, long and void * will be 32 bit;\n-   this may be changed with -mint64 or -mlong64.\n-\n-   The gen* programs link code that refers to MASK_64BIT.  They don't\n-   actually use the information in target_flags; they just refer to\n-   it.  */\n \f\n /* Switch  Recognition by gcc.c.  Add -G xx support */\n \n@@ -1119,45 +1089,6 @@ extern int mips_abi;\n %(target_asm_spec) \\\n %(subtarget_asm_spec)\"\n \n-/* Specify to run a post-processor, mips-tfile after the assembler\n-   has run to stuff the mips debug information into the object file.\n-   This is needed because the $#!%^ MIPS assembler provides no way\n-   of specifying such information in the assembly file.  If we are\n-   cross compiling, disable mips-tfile unless the user specifies\n-   -mmips-tfile.  */\n-\n-#ifndef ASM_FINAL_SPEC\n-#if ((TARGET_CPU_DEFAULT | TARGET_DEFAULT) & MASK_GAS) != 0\n-/* GAS */\n-#define ASM_FINAL_SPEC \"\\\n-%{mmips-as: %{!mno-mips-tfile: \\\n-\t\\n mips-tfile %{v*: -v} \\\n-\t\t%{K: -I %b.o~} \\\n-\t\t%{!K: %{save-temps: -I %b.o~}} \\\n-\t\t%{c:%W{o*}%{!o*:-o %b.o}}%{!c:-o %U.o} \\\n-\t\t%{.s:%i} %{!.s:%g.s}}}\"\n-\n-#else\n-/* not GAS */\n-#define ASM_FINAL_SPEC \"\\\n-%{!mgas: %{!mno-mips-tfile: \\\n-\t\\n mips-tfile %{v*: -v} \\\n-\t\t%{K: -I %b.o~} \\\n-\t\t%{!K: %{save-temps: -I %b.o~}} \\\n-\t\t%{c:%W{o*}%{!o*:-o %b.o}}%{!c:-o %U.o} \\\n-\t\t%{.s:%i} %{!.s:%g.s}}}\"\n-\n-#endif\n-#endif\t/* ASM_FINAL_SPEC */\n-\n-/* Redefinition of libraries used.  Mips doesn't support normal\n-   UNIX style profiling via calling _mcount.  It does offer\n-   profiling that samples the PC, so do what we can...  */\n-\n-#ifndef LIB_SPEC\n-#define LIB_SPEC \"%{pg:-lprof1} %{p:-lprof1} -lc\"\n-#endif\n-\n /* Extra switches sometimes passed to the linker.  */\n /* ??? The bestGnum will never be passed to the linker, because the gcc driver\n   will interpret it as a -b option.  */\n@@ -1179,9 +1110,6 @@ extern int mips_abi;\n #endif\n \n /* CC1_SPEC is the set of arguments to pass to the compiler proper.  */\n-/* Note, we will need to adjust the following if we ever find a MIPS variant\n-   that has 32-bit GPRs and 64-bit FPRs as well as fix all of the reload bugs\n-   that show up in this case.  */\n \n #ifndef CC1_SPEC\n #define CC1_SPEC \"\\\n@@ -1241,24 +1169,6 @@ extern int mips_abi;\n #define MD_STARTFILE_PREFIX \"/usr/lib/cmplrs/cc/\"\n #endif\n \n-\f\n-/* Print subsidiary information on the compiler version in use.  */\n-\n-#define MIPS_VERSION \"[AL 1.1, MM 40]\"\n-\n-#ifndef MACHINE_TYPE\n-#define MACHINE_TYPE \"BSD Mips\"\n-#endif\n-\n-#ifndef TARGET_VERSION_INTERNAL\n-#define TARGET_VERSION_INTERNAL(STREAM)\t\t\t\t\t\\\n-  fprintf (STREAM, \" %s %s\", MIPS_VERSION, MACHINE_TYPE)\n-#endif\n-\n-#ifndef TARGET_VERSION\n-#define TARGET_VERSION TARGET_VERSION_INTERNAL (stderr)\n-#endif\n-\n \f\n #define DBX_DEBUGGING_INFO 1\t\t/* generate stabs (OSF/rose) */\n #define MIPS_DEBUGGING_INFO 1\t\t/* MIPS specific debugging info */\n@@ -1793,25 +1703,15 @@ extern char mips_hard_regno_mode_ok[][FIRST_PSEUDO_REGISTER];\n    == (GET_MODE_CLASS (MODE2) == MODE_FLOAT ||\t\t\t\t\\\n        GET_MODE_CLASS (MODE2) == MODE_COMPLEX_FLOAT))\n \n-/* MIPS pc is not overloaded on a register.\t*/\n-/* #define PC_REGNUM xx\t\t\t\t*/\n-\n /* Register to use for pushing function arguments.  */\n #define STACK_POINTER_REGNUM (GP_REG_FIRST + 29)\n \n-/* Offset from the stack pointer to the first available location.  Use\n-   the default value zero.  */\n-/* #define STACK_POINTER_OFFSET 0 */\n-\n /* Base register for access to local variables of the function.  We\n    pretend that the frame pointer is $1, and then eliminate it to\n    HARD_FRAME_POINTER_REGNUM.  We can get away with this because $1 is\n    a fixed register, and will not be used for anything else.  */\n #define FRAME_POINTER_REGNUM (GP_REG_FIRST + 1)\n \n-/* Temporary scratch register for use by the assembler.  */\n-#define ASSEMBLER_SCRATCH_REGNUM (GP_REG_FIRST + 1)\n-\n /* $30 is not available on the mips16, so we use $17 as the frame\n    pointer.  */\n #define HARD_FRAME_POINTER_REGNUM \\\n@@ -1829,10 +1729,6 @@ extern char mips_hard_regno_mode_ok[][FIRST_PSEUDO_REGISTER];\n /* Register in which static-chain is passed to a function.  */\n #define STATIC_CHAIN_REGNUM (GP_REG_FIRST + 2)\n \n-/* If the structure value address is passed in a register, then\n-   `STRUCT_VALUE_REGNUM' should be the number of that register.  */\n-/* #define STRUCT_VALUE_REGNUM (GP_REG_FIRST + 4) */\n-\n /* If the structure value address is not passed in a register, define\n    `STRUCT_VALUE' as an expression returning an RTX for the place\n    where the address is passed.  If it returns 0, the address is\n@@ -2281,29 +2177,6 @@ extern enum reg_class mips_char_to_class[256];\n    + (TARGET_ABICALLS && !TARGET_NEWABI\t\t\t\t\t\\\n       ? MIPS_STACK_ALIGN (UNITS_PER_WORD) : 0))\n \n-/* Offset from the stack pointer register to an item dynamically\n-   allocated on the stack, e.g., by `alloca'.\n-\n-   The default value for this macro is `STACK_POINTER_OFFSET' plus the\n-   length of the outgoing arguments.  The default is correct for most\n-   machines.  See `function.c' for details.\n-\n-   The MIPS ABI states that functions which dynamically allocate the\n-   stack must not have 0 for STACK_DYNAMIC_OFFSET, since it looks like\n-   we are trying to create a second frame pointer to the function, so\n-   allocate some stack space to make it happy.\n-\n-   However, the linker currently complains about linking any code that\n-   dynamically allocates stack space, and there seems to be a bug in\n-   STACK_DYNAMIC_OFFSET, so don't define this right now.  */\n-\n-#if 0\n-#define STACK_DYNAMIC_OFFSET(FUNDECL)\t\t\t\t\t\\\n-  ((current_function_outgoing_args_size == 0 && current_function_calls_alloca) \\\n-\t? 4*UNITS_PER_WORD\t\t\t\t\t\t\\\n-\t: current_function_outgoing_args_size)\n-#endif\n-\n /* The return address for the current frame is in r31 if this is a leaf\n    function.  Otherwise, it is on the stack.  It is at a variable offset\n    from sp/fp/ap, so we define a fake hard register rap which is a\n@@ -2392,12 +2265,6 @@ extern enum reg_class mips_char_to_class[256];\n #define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET) \\\n \t(OFFSET) = mips_initial_elimination_offset ((FROM), (TO))\n \n-/* If we generate an insn to push BYTES bytes,\n-   this says how many the stack pointer really advances by.\n-   On the VAX, sp@- in a byte insn really pushes a word.  */\n-\n-/* #define PUSH_ROUNDING(BYTES) 0 */\n-\n /* If defined, the maximum amount of space required for outgoing\n    arguments will be computed and placed into the variable\n    `current_function_outgoing_args_size'.  No space will be pushed\n@@ -3160,11 +3027,8 @@ typedef struct mips_args {\n   {\"symbolic_operand\",\t\t{ CONST, SYMBOL_REF, LABEL_REF }},\t\\\n   {\"const_arith_operand\",\t{ CONST, CONST_INT }},\t\t\t\\\n   {\"arith_operand\",\t\t{ REG, CONST_INT, CONST, SUBREG, ADDRESSOF }},\t\\\n-  {\"arith32_operand\",\t\t{ REG, CONST_INT, SUBREG, ADDRESSOF }},\t\t\\\n   {\"reg_or_0_operand\",\t\t{ REG, CONST_INT, CONST_DOUBLE, SUBREG, ADDRESSOF }}, \\\n-  {\"true_reg_or_0_operand\",\t{ REG, CONST_INT, CONST_DOUBLE, SUBREG, ADDRESSOF }}, \\\n   {\"small_int\",\t\t\t{ CONST_INT }},\t\t\t\t\\\n-  {\"large_int\",\t\t\t{ CONST_INT }},\t\t\t\t\\\n   {\"mips_const_double_ok\",\t{ CONST_DOUBLE }},\t\t\t\\\n   {\"const_float_1_operand\",\t{ CONST_DOUBLE }},\t\t\t\\\n   {\"simple_memory_operand\",\t{ MEM, SUBREG }},\t\t\t\\"}, {"sha": "6df4084b2aeea0c47268f990ee0df45df520ec19", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d5565cdf26d8af5d3b722f4058ebe13b601c4d5/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d5565cdf26d8af5d3b722f4058ebe13b601c4d5/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=1d5565cdf26d8af5d3b722f4058ebe13b601c4d5", "patch": "@@ -196,7 +196,7 @@\n ;; ??? Fix everything that tests this attribute.\n (define_attr \"cpu\"\n   \"default,4kc,5kc,20kc,m4k,r3000,r3900,r6000,r4000,r4100,r4111,r4120,r4300,r4600,r4650,r5000,r5400,r5500,r7000,r8000,r9000,sb1,sr71000\"\n-  (const (symbol_ref \"mips_cpu_attr\")))\n+  (const (symbol_ref \"mips_tune\")))\n \n ;; The type of hardware hazard associated with this instruction.\n ;; DELAY means that the next instruction cannot read the result\n@@ -260,7 +260,7 @@\n ;; .........................\n \n (define_delay (and (eq_attr \"type\" \"branch\")\n-\t\t   (eq (symbol_ref \"mips16\") (const_int 0)))\n+\t\t   (eq (symbol_ref \"TARGET_MIPS16\") (const_int 0)))\n   [(eq_attr \"can_delay\" \"yes\")\n    (nil)\n    (and (eq_attr \"branch_likely\" \"yes\")\n@@ -320,7 +320,7 @@\n ;; selecting instructions to between the two instructions.\n \n (define_function_unit \"imuldiv\" 1 0\n-  (and (eq_attr \"type\" \"hilo\") (ne (symbol_ref \"mips16\") (const_int 0)))\n+  (and (eq_attr \"type\" \"hilo\") (ne (symbol_ref \"TARGET_MIPS16\") (const_int 0)))\n   1 5)\n \n (define_function_unit \"imuldiv\"  1 0"}]}