{"sha": "c47d00347d7e74193dda2e9a3f55f52485e7eeeb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzQ3ZDAwMzQ3ZDdlNzQxOTNkZGEyZTlhM2Y1NWY1MjQ4NWU3ZWVlYg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2011-05-06T23:00:49Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2011-05-06T23:00:49Z"}, "message": "cgraph.c (cgraph_add_thunk): Create real function node instead of alias node...\n\n\n\t* cgraph.c (cgraph_add_thunk): Create real function node instead\n\tof alias node; finalize it and mark needed/reachale; arrange visibility\n\tto be right and add it into the corresponding same comdat group list.\n\t(dump_cgraph_node): Dump thunks.\n\t* cgraph.h (cgraph_first_defined_function, cgraph_next_defined_function,\n\tcgraph_function_with_gimple_body_p, cgraph_first_function_with_gimple_body,\n\tcgraph_next_function_with_gimple_body): New functions.\n\t(FOR_EACH_FUNCTION_WITH_GIMPLE_BODY, FOR_EACH_DEFINED_FUNCTION):\n\tNew macros.\n\t* ipa-cp.c (ipcp_need_redirect_p): Thunks can't be redirected.\n\t(ipcp_generate_summary): Use FOR_EACH_FUNCTION_WITH_GIMPLE_BODY.\n\t* cgraphunit.c (cgraph_finalize_function): Only look into possible\n\tdevirtualization when optimizing.\n\t(verify_cgraph_node): Verify thunks.\n\t(cgraph_analyze_function): Analyze thunks.\n\t(cgraph_mark_functions_to_output): Output thunks only in combination\n\twith function they are assigned to.\n\t(assemble_thunk): Turn thunk into non-thunk; don't try to turn\n\talias into normal node.\n\t(assemble_thunks): New functoin.\n\t(cgraph_expand_function): Use it.\n\t* lto-cgraph.c (lto_output_node): Stream thunks.\n\t(input_overwrite_node): Stream in thunks.\n\t* ipa-pure-const.c (analyze_function): Thunks do nothing interesting.\n\t* lto-streamer-out.c (lto_output): Do not try to output thunk's body.\n\t* ipa-inline.c (inline_small_functions): Use FOR_EACH_DEFINED_FUNCTION.\n\t* ipa-inline-analysis.c (compute_inline_parameters): \"Analyze\" thunks.\n\t(inline_analyze_function): Do not care about thunk jump functions.\n\t(inline_generate_summary):Use FOR_EACH_DEFINED_FUNCTION.\n\t* ipa-prop.c (ipa_prop_write_jump_functions): Use cgraph_function_with_gimple_body_p.\n\t* passes.c (do_per_function_toporder): Use cgraph_function_with_gimple_body_p.\n\t(execute_one_pass);Use FOR_EACH_FUNCTION_WITH_GIMPLE_BODY.\n\t(ipa_write_summaries): Use cgraph_function_with_gimple_body_p.\n\t(function_called_by_processed_nodes_p): Likewise.\n\t* lto.c (lto_materialize_function): Use cgraph_function_with_gimple_body_p.\n\t(add_cgraph_node_to_partition): Do not re-add items to partition; handle thunks.\n\t(add_varpool_node_to_partition): Do not re-add items to partition.\n\nFrom-SVN: r173517", "tree": {"sha": "00b435c7373736adc2b2930493aa86fc6e9c0b31", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/00b435c7373736adc2b2930493aa86fc6e9c0b31"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c47d00347d7e74193dda2e9a3f55f52485e7eeeb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c47d00347d7e74193dda2e9a3f55f52485e7eeeb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c47d00347d7e74193dda2e9a3f55f52485e7eeeb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c47d00347d7e74193dda2e9a3f55f52485e7eeeb/comments", "author": null, "committer": null, "parents": [{"sha": "e68dde1f40536d6bb7e9d65de04bacd759bb1ee9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e68dde1f40536d6bb7e9d65de04bacd759bb1ee9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e68dde1f40536d6bb7e9d65de04bacd759bb1ee9"}], "stats": {"total": 506, "additions": 384, "deletions": 122}, "files": [{"sha": "a94e41f153f1dfb8e92576f682c113577351ed6e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c47d00347d7e74193dda2e9a3f55f52485e7eeeb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c47d00347d7e74193dda2e9a3f55f52485e7eeeb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c47d00347d7e74193dda2e9a3f55f52485e7eeeb", "patch": "@@ -1,3 +1,40 @@\n+2011-05-06  Jan Hubicka  <jh@suse.cz>\n+\n+\t* cgraph.c (cgraph_add_thunk): Create real function node instead\n+\tof alias node; finalize it and mark needed/reachale; arrange visibility\n+\tto be right and add it into the corresponding same comdat group list.\n+\t(dump_cgraph_node): Dump thunks.\n+\t* cgraph.h (cgraph_first_defined_function, cgraph_next_defined_function,\n+\tcgraph_function_with_gimple_body_p, cgraph_first_function_with_gimple_body,\n+\tcgraph_next_function_with_gimple_body): New functions.\n+\t(FOR_EACH_FUNCTION_WITH_GIMPLE_BODY, FOR_EACH_DEFINED_FUNCTION):\n+\tNew macros.\n+\t* ipa-cp.c (ipcp_need_redirect_p): Thunks can't be redirected.\n+\t(ipcp_generate_summary): Use FOR_EACH_FUNCTION_WITH_GIMPLE_BODY.\n+\t* cgraphunit.c (cgraph_finalize_function): Only look into possible\n+\tdevirtualization when optimizing.\n+\t(verify_cgraph_node): Verify thunks.\n+\t(cgraph_analyze_function): Analyze thunks.\n+\t(cgraph_mark_functions_to_output): Output thunks only in combination\n+\twith function they are assigned to.\n+\t(assemble_thunk): Turn thunk into non-thunk; don't try to turn\n+\talias into normal node.\n+\t(assemble_thunks): New functoin.\n+\t(cgraph_expand_function): Use it.\n+\t* lto-cgraph.c (lto_output_node): Stream thunks.\n+\t(input_overwrite_node): Stream in thunks.\n+\t* ipa-pure-const.c (analyze_function): Thunks do nothing interesting.\n+\t* lto-streamer-out.c (lto_output): Do not try to output thunk's body.\n+\t* ipa-inline.c (inline_small_functions): Use FOR_EACH_DEFINED_FUNCTION.\n+\t* ipa-inline-analysis.c (compute_inline_parameters): \"Analyze\" thunks.\n+\t(inline_analyze_function): Do not care about thunk jump functions.\n+\t(inline_generate_summary):Use FOR_EACH_DEFINED_FUNCTION.\n+\t* ipa-prop.c (ipa_prop_write_jump_functions): Use cgraph_function_with_gimple_body_p.\n+\t* passes.c (do_per_function_toporder): Use cgraph_function_with_gimple_body_p.\n+\t(execute_one_pass);Use FOR_EACH_FUNCTION_WITH_GIMPLE_BODY.\n+\t(ipa_write_summaries): Use cgraph_function_with_gimple_body_p.\n+\t(function_called_by_processed_nodes_p): Likewise.\n+\n 2011-05-06  Joseph Myers  <joseph@codesourcery.com>\n \n \t* config/rs6000/rs6000.opt (rs6000_ieeequad, rs6000_altivec_abi,"}, {"sha": "1f6f89f508f7f88cc83043a08d80291350f415d8", "filename": "gcc/cgraph.c", "status": "modified", "additions": 30, "deletions": 16, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c47d00347d7e74193dda2e9a3f55f52485e7eeeb/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c47d00347d7e74193dda2e9a3f55f52485e7eeeb/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=c47d00347d7e74193dda2e9a3f55f52485e7eeeb", "patch": "@@ -595,23 +595,24 @@ cgraph_same_body_alias (struct cgraph_node *decl_node, tree alias, tree decl)\n    See comments in thunk_adjust for detail on the parameters.  */\n \n struct cgraph_node *\n-cgraph_add_thunk (struct cgraph_node *decl_node, tree alias, tree decl,\n+cgraph_add_thunk (struct cgraph_node *decl_node ATTRIBUTE_UNUSED,\n+\t\t  tree alias, tree decl,\n \t\t  bool this_adjusting,\n \t\t  HOST_WIDE_INT fixed_offset, HOST_WIDE_INT virtual_value,\n \t\t  tree virtual_offset,\n \t\t  tree real_alias)\n {\n-  struct cgraph_node *node = cgraph_get_node (alias);\n+  struct cgraph_node *node;\n \n+  node = cgraph_get_node (alias);\n   if (node)\n     {\n       gcc_assert (node->local.finalized);\n       gcc_assert (!node->same_body);\n       cgraph_remove_node (node);\n     }\n   \n-  node = cgraph_same_body_alias_1 (decl_node, alias, decl);\n-  gcc_assert (node);\n+  node = cgraph_create_node (alias);\n   gcc_checking_assert (!virtual_offset\n \t\t       || double_int_equal_p\n \t\t            (tree_to_double_int (virtual_offset),\n@@ -622,6 +623,15 @@ cgraph_add_thunk (struct cgraph_node *decl_node, tree alias, tree decl,\n   node->thunk.virtual_offset_p = virtual_offset != NULL;\n   node->thunk.alias = real_alias;\n   node->thunk.thunk_p = true;\n+  node->local.finalized = true;\n+\n+  if (cgraph_decide_is_function_needed (node, decl))\n+    cgraph_mark_needed_node (node);\n+\n+  if ((TREE_PUBLIC (decl) && !DECL_COMDAT (decl) && !DECL_EXTERNAL (decl))\n+      || (DECL_VIRTUAL_P (decl)\n+\t  && (DECL_COMDAT (decl) || DECL_EXTERNAL (decl))))\n+    cgraph_mark_reachable_node (node);\n   return node;\n }\n \n@@ -1875,7 +1885,21 @@ dump_cgraph_node (FILE *f, struct cgraph_node *node)\n   if (node->only_called_at_exit)\n     fprintf (f, \" only_called_at_exit\");\n \n-  fprintf (f, \"\\n  called by: \");\n+  fprintf (f, \"\\n\");\n+\n+  if (node->thunk.thunk_p)\n+    {\n+      fprintf (f, \"  thunk of %s (asm: %s) fixed offset %i virtual value %i has \"\n+\t       \"virtual offset %i)\\n\",\n+\t       lang_hooks.decl_printable_name (node->thunk.alias, 2),\n+\t       IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (node->thunk.alias)),\n+\t       (int)node->thunk.fixed_offset,\n+\t       (int)node->thunk.virtual_value,\n+\t       (int)node->thunk.virtual_offset_p);\n+    }\n+  \n+  fprintf (f, \"  called by: \");\n+\n   for (edge = node->callers; edge; edge = edge->next_caller)\n     {\n       fprintf (f, \"%s/%i \", cgraph_node_name (edge->caller),\n@@ -1927,20 +1951,10 @@ dump_cgraph_node (FILE *f, struct cgraph_node *node)\n   if (node->same_body)\n     {\n       struct cgraph_node *n;\n-      fprintf (f, \"  aliases & thunks:\");\n+      fprintf (f, \"  aliases:\");\n       for (n = node->same_body; n; n = n->next)\n         {\n           fprintf (f, \" %s/%i\", cgraph_node_name (n), n->uid);\n-\t  if (n->thunk.thunk_p)\n-\t    {\n-\t      fprintf (f, \" (thunk of %s fixed offset %i virtual value %i has \"\n-\t\t       \"virtual offset %i\",\n-\t      \t       lang_hooks.decl_printable_name (n->thunk.alias, 2),\n-\t\t       (int)n->thunk.fixed_offset,\n-\t\t       (int)n->thunk.virtual_value,\n-\t\t       (int)n->thunk.virtual_offset_p);\n-\t      fprintf (f, \")\");\n-\t    }\n \t  if (DECL_ASSEMBLER_NAME_SET_P (n->decl))\n \t    fprintf (f, \" (asm: %s)\", IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (n->decl)));\n \t}"}, {"sha": "e250ecd40e746b7c1afddabcf4768378f14e2d08", "filename": "gcc/cgraph.h", "status": "modified", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c47d00347d7e74193dda2e9a3f55f52485e7eeeb/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c47d00347d7e74193dda2e9a3f55f52485e7eeeb/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=c47d00347d7e74193dda2e9a3f55f52485e7eeeb", "patch": "@@ -695,6 +695,79 @@ varpool_next_static_initializer (struct varpool_node *node)\n    for ((node) = varpool_first_static_initializer (); (node); \\\n         (node) = varpool_next_static_initializer (node))\n \n+/* Return first function with body defined.  */\n+static inline struct cgraph_node *\n+cgraph_first_defined_function (void)\n+{\n+  struct cgraph_node *node;\n+  for (node = cgraph_nodes; node; node = node->next)\n+    {\n+      if (node->analyzed)\n+\treturn node;\n+    }\n+  return NULL;\n+}\n+\n+/* Return next reachable static variable with initializer after NODE.  */\n+static inline struct cgraph_node *\n+cgraph_next_defined_function (struct cgraph_node *node)\n+{\n+  for (node = node->next; node; node = node->next)\n+    {\n+      if (node->analyzed)\n+\treturn node;\n+    }\n+  return NULL;\n+}\n+\n+/* Walk all functions with body defined.  */\n+#define FOR_EACH_DEFINED_FUNCTION(node) \\\n+   for ((node) = cgraph_first_defined_function (); (node); \\\n+        (node) = cgraph_next_defined_function (node))\n+\n+\n+/* Return true when NODE is a function with Gimple body defined\n+   in current unit.  Functions can also be define externally or they\n+   can be thunks with no Gimple representation.\n+\n+   Note that at WPA stage, the function body may not be present in memory.  */\n+\n+static inline bool\n+cgraph_function_with_gimple_body_p (struct cgraph_node *node)\n+{\n+  return node->analyzed && !node->thunk.thunk_p;\n+}\n+\n+/* Return first function with body defined.  */\n+static inline struct cgraph_node *\n+cgraph_first_function_with_gimple_body (void)\n+{\n+  struct cgraph_node *node;\n+  for (node = cgraph_nodes; node; node = node->next)\n+    {\n+      if (cgraph_function_with_gimple_body_p (node))\n+\treturn node;\n+    }\n+  return NULL;\n+}\n+\n+/* Return next reachable static variable with initializer after NODE.  */\n+static inline struct cgraph_node *\n+cgraph_next_function_with_gimple_body (struct cgraph_node *node)\n+{\n+  for (node = node->next; node; node = node->next)\n+    {\n+      if (cgraph_function_with_gimple_body_p (node))\n+\treturn node;\n+    }\n+  return NULL;\n+}\n+\n+/* Walk all functions with body defined.  */\n+#define FOR_EACH_FUNCTION_WITH_GIMPLE_BODY(node) \\\n+   for ((node) = cgraph_first_function_with_gimple_body (); (node); \\\n+        (node) = cgraph_next_function_with_gimple_body (node))\n+\n /* Create a new static variable of type TYPE.  */\n tree add_new_static_var (tree type);\n "}, {"sha": "68eb91d35e81ba9379dc7221fbcc42d3bf631bd4", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 84, "deletions": 38, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c47d00347d7e74193dda2e9a3f55f52485e7eeeb/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c47d00347d7e74193dda2e9a3f55f52485e7eeeb/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=c47d00347d7e74193dda2e9a3f55f52485e7eeeb", "patch": "@@ -370,7 +370,8 @@ cgraph_finalize_function (tree decl, bool nested)\n \t to those so we need to analyze them.\n \t FIXME: We should introduce may edges for this purpose and update\n \t their handling in unreachable function removal and inliner too.  */\n-      || (DECL_VIRTUAL_P (decl) && (DECL_COMDAT (decl) || DECL_EXTERNAL (decl))))\n+      || (DECL_VIRTUAL_P (decl)\n+\t  && optimize && (DECL_COMDAT (decl) || DECL_EXTERNAL (decl))))\n     cgraph_mark_reachable_node (node);\n \n   /* If we've not yet emitted decl, tell the debug info about it.  */\n@@ -624,10 +625,28 @@ verify_cgraph_node (struct cgraph_node *node)\n       while (n != node);\n     }\n \n-  if (node->analyzed && gimple_has_body_p (node->decl)\n-      && !TREE_ASM_WRITTEN (node->decl)\n-      && (!DECL_EXTERNAL (node->decl) || node->global.inlined_to)\n-      && !flag_wpa)\n+  if (node->analyzed && node->thunk.thunk_p)\n+    {\n+      if (!node->callees)\n+\t{\n+\t  error (\"No edge out of thunk node\");\n+          error_found = true;\n+\t}\n+      else if (node->callees->next_callee)\n+\t{\n+\t  error (\"More than one edge out of thunk node\");\n+          error_found = true;\n+\t}\n+      if (gimple_has_body_p (node->decl))\n+        {\n+\t  error (\"Thunk is not supposed to have body\");\n+          error_found = true;\n+        }\n+    }\n+  else if (node->analyzed && gimple_has_body_p (node->decl)\n+           && !TREE_ASM_WRITTEN (node->decl)\n+           && (!DECL_EXTERNAL (node->decl) || node->global.inlined_to)\n+           && !flag_wpa)\n     {\n       if (this_cfun->cfg)\n \t{\n@@ -656,8 +675,6 @@ verify_cgraph_node (struct cgraph_node *node)\n \t\t\t  }\n \t\t\tif (!e->indirect_unknown_callee)\n \t\t\t  {\n-\t\t\t    struct cgraph_node *n;\n-\n \t\t\t    if (e->callee->same_body_alias)\n \t\t\t      {\n \t\t\t\terror (\"edge points to same body alias:\");\n@@ -678,16 +695,6 @@ verify_cgraph_node (struct cgraph_node *node)\n \t\t\t\tdebug_tree (decl);\n \t\t\t\terror_found = true;\n \t\t\t      }\n-\t\t\t    else if (decl\n-\t\t\t\t     && (n = cgraph_get_node_or_alias (decl))\n-\t\t\t\t     && (n->same_body_alias\n-\t\t\t\t\t && n->thunk.thunk_p))\n-\t\t\t      {\n-\t\t\t\terror (\"a call to thunk improperly represented \"\n-\t\t\t\t       \"in the call graph:\");\n-\t\t\t\tcgraph_debug_gimple_stmt (this_cfun, stmt);\n-\t\t\t\terror_found = true;\n-\t\t\t      }\n \t\t\t  }\n \t\t\telse if (decl)\n \t\t\t  {\n@@ -780,23 +787,31 @@ cgraph_analyze_function (struct cgraph_node *node)\n   tree save = current_function_decl;\n   tree decl = node->decl;\n \n-  current_function_decl = decl;\n-  push_cfun (DECL_STRUCT_FUNCTION (decl));\n+  if (node->thunk.thunk_p)\n+    {\n+      cgraph_create_edge (node, cgraph_get_node (node->thunk.alias),\n+\t\t\t  NULL, 0, CGRAPH_FREQ_BASE);\n+    }\n+  else\n+    {\n+      current_function_decl = decl;\n+      push_cfun (DECL_STRUCT_FUNCTION (decl));\n \n-  assign_assembler_name_if_neeeded (node->decl);\n+      assign_assembler_name_if_neeeded (node->decl);\n \n-  /* Make sure to gimplify bodies only once.  During analyzing a\n-     function we lower it, which will require gimplified nested\n-     functions, so we can end up here with an already gimplified\n-     body.  */\n-  if (!gimple_body (decl))\n-    gimplify_function_tree (decl);\n-  dump_function (TDI_generic, decl);\n+      /* Make sure to gimplify bodies only once.  During analyzing a\n+\t function we lower it, which will require gimplified nested\n+\t functions, so we can end up here with an already gimplified\n+\t body.  */\n+      if (!gimple_body (decl))\n+\tgimplify_function_tree (decl);\n+      dump_function (TDI_generic, decl);\n \n-  cgraph_lower_function (node);\n+      cgraph_lower_function (node);\n+      pop_cfun ();\n+    }\n   node->analyzed = true;\n \n-  pop_cfun ();\n   current_function_decl = save;\n }\n \n@@ -969,7 +984,8 @@ cgraph_analyze_functions (void)\n       /* ??? It is possible to create extern inline function and later using\n \t weak alias attribute to kill its body. See\n \t gcc.c-torture/compile/20011119-1.c  */\n-      if (!DECL_STRUCT_FUNCTION (decl))\n+      if (!DECL_STRUCT_FUNCTION (decl)\n+\t  && !node->thunk.thunk_p)\n \t{\n \t  cgraph_reset_node (node);\n \t  continue;\n@@ -981,6 +997,9 @@ cgraph_analyze_functions (void)\n       for (edge = node->callees; edge; edge = edge->next_callee)\n \tif (!edge->callee->reachable)\n \t  cgraph_mark_reachable_node (edge->callee);\n+      for (edge = node->callers; edge; edge = edge->next_caller)\n+\tif (!edge->caller->reachable && edge->caller->thunk.thunk_p)\n+\t  cgraph_mark_reachable_node (edge->caller);\n \n       if (node->same_comdat_group)\n \t{\n@@ -1031,10 +1050,12 @@ cgraph_analyze_functions (void)\n       tree decl = node->decl;\n       next = node->next;\n \n-      if (node->local.finalized && !gimple_has_body_p (decl))\n+      if (node->local.finalized && !gimple_has_body_p (decl)\n+\t  && !node->thunk.thunk_p)\n \tcgraph_reset_node (node);\n \n-      if (!node->reachable && gimple_has_body_p (decl))\n+      if (!node->reachable\n+\t  && (gimple_has_body_p (decl) || node->thunk.thunk_p))\n \t{\n \t  if (cgraph_dump_file)\n \t    fprintf (cgraph_dump_file, \" %s\", cgraph_node_name (node));\n@@ -1043,7 +1064,8 @@ cgraph_analyze_functions (void)\n \t}\n       else\n \tnode->next_needed = NULL;\n-      gcc_assert (!node->local.finalized || gimple_has_body_p (decl));\n+      gcc_assert (!node->local.finalized || node->thunk.thunk_p\n+\t\t  || gimple_has_body_p (decl));\n       gcc_assert (node->analyzed == node->local.finalized);\n     }\n   if (cgraph_dump_file)\n@@ -1132,6 +1154,7 @@ cgraph_mark_functions_to_output (void)\n \t always inlined, as well as those that are reachable from\n \t outside the current compilation unit.  */\n       if (node->analyzed\n+\t  && !node->thunk.thunk_p\n \t  && !node->global.inlined_to\n \t  && (!cgraph_only_called_directly_p (node)\n \t      || (e && node->reachable))\n@@ -1145,7 +1168,8 @@ cgraph_mark_functions_to_output (void)\n \t      for (next = node->same_comdat_group;\n \t\t   next != node;\n \t\t   next = next->same_comdat_group)\n-\t\tnext->process = 1;\n+\t\tif (!next->thunk.thunk_p)\n+\t\t  next->process = 1;\n \t    }\n \t}\n       else if (node->same_comdat_group)\n@@ -1406,6 +1430,8 @@ assemble_thunk (struct cgraph_node *node)\n       free_after_compilation (cfun);\n       set_cfun (NULL);\n       TREE_ASM_WRITTEN (thunk_fndecl) = 1;\n+      node->thunk.thunk_p = false;\n+      node->analyzed = false;\n     }\n   else\n     {\n@@ -1530,15 +1556,36 @@ assemble_thunk (struct cgraph_node *node)\n       delete_unreachable_blocks ();\n       update_ssa (TODO_update_ssa);\n \n-      cgraph_remove_same_body_alias (node);\n       /* Since we want to emit the thunk, we explicitly mark its name as\n \t referenced.  */\n+      node->thunk.thunk_p = false;\n+      cgraph_node_remove_callees (node);\n       cgraph_add_new_function (thunk_fndecl, true);\n       bitmap_obstack_release (NULL);\n     }\n   current_function_decl = NULL;\n }\n \n+\n+/* Assemble thunks asociated to NODE.  */\n+\n+static void\n+assemble_thunks (struct cgraph_node *node)\n+{\n+  struct cgraph_edge *e;\n+  for (e = node->callers; e;)\n+    if (e->caller->thunk.thunk_p)\n+      {\n+\tstruct cgraph_node *thunk = e->caller;\n+\n+\te = e->next_caller;\n+\tassemble_thunks (thunk);\n+        assemble_thunk (thunk);\n+      }\n+    else\n+      e = e->next_caller;\n+}\n+\n /* Expand function specified by NODE.  */\n \n static void\n@@ -1566,13 +1613,12 @@ cgraph_expand_function (struct cgraph_node *node)\n \t  if (!alias->thunk.thunk_p)\n \t    assemble_alias (alias->decl,\n \t\t\t    DECL_ASSEMBLER_NAME (alias->thunk.alias));\n-\t  else\n-\t    assemble_thunk (alias);\n \t}\n       node->alias = saved_alias;\n       cgraph_process_new_functions ();\n     }\n \n+  assemble_thunks (node);\n   gcc_assert (node->lowered);\n \n   /* Generate RTL for the body of DECL.  */\n@@ -1688,7 +1734,7 @@ cgraph_output_in_order (void)\n \n   for (pf = cgraph_nodes; pf; pf = pf->next)\n     {\n-      if (pf->process)\n+      if (pf->process && !pf->thunk.thunk_p)\n \t{\n \t  i = pf->order;\n \t  gcc_assert (nodes[i].kind == ORDER_UNDEFINED);"}, {"sha": "d22e709e8710f86b38765783ba2d272a7f8c2894", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c47d00347d7e74193dda2e9a3f55f52485e7eeeb/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c47d00347d7e74193dda2e9a3f55f52485e7eeeb/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=c47d00347d7e74193dda2e9a3f55f52485e7eeeb", "patch": "@@ -951,6 +951,10 @@ ipcp_need_redirect_p (struct cgraph_edge *cs)\n   if (!n_cloning_candidates)\n     return false;\n \n+  /* We can't redirect anything in thunks, yet.  */\n+  if (cs->caller->thunk.thunk_p)\n+    return true;\n+\n   if ((orig = ipcp_get_orig_node (node)) != NULL)\n     node = orig;\n   if (ipcp_get_orig_node (cs->caller))\n@@ -1508,8 +1512,9 @@ ipcp_generate_summary (void)\n     fprintf (dump_file, \"\\nIPA constant propagation start:\\n\");\n   ipa_register_cgraph_hooks ();\n \n-  for (node = cgraph_nodes; node; node = node->next)\n-    if (node->analyzed)\n+  /* FIXME: We could propagate through thunks happily and we could be\n+     even able to clone them, if needed.  Do that later.  */\n+  FOR_EACH_FUNCTION_WITH_GIMPLE_BODY (node)\n       {\n \t/* Unreachable nodes should have been eliminated before ipcp.  */\n \tgcc_assert (node->needed || node->reachable);"}, {"sha": "9021fa2b9290a327b08d9d5f11d0595518002fc9", "filename": "gcc/ipa-inline-analysis.c", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c47d00347d7e74193dda2e9a3f55f52485e7eeeb/gcc%2Fipa-inline-analysis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c47d00347d7e74193dda2e9a3f55f52485e7eeeb/gcc%2Fipa-inline-analysis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-analysis.c?ref=c47d00347d7e74193dda2e9a3f55f52485e7eeeb", "patch": "@@ -1443,6 +1443,23 @@ compute_inline_parameters (struct cgraph_node *node, bool early)\n \n   info = inline_summary (node);\n \n+  /* FIXME: Thunks are inlinable, but tree-inline don't know how to do that.\n+     Once this happen, we will need to more curefully predict call\n+     statement size.  */\n+  if (node->thunk.thunk_p)\n+    {\n+      struct inline_edge_summary *es = inline_edge_summary (node->callees);\n+      struct predicate t = true_predicate ();\n+\n+      info->inlinable = info->versionable = 0;\n+      node->callees->call_stmt_cannot_inline_p = true;\n+      node->local.can_change_signature = false;\n+      es->call_stmt_time = 1;\n+      es->call_stmt_size = 1;\n+      account_size_time (info, 0, 0, &t);\n+      return;\n+    }\n+\n   /* Estimate the stack size for the function if we're optimizing.  */\n   self_stack_size = optimize ? estimated_stack_frame_size (node) : 0;\n   info->estimated_self_stack_size = self_stack_size;\n@@ -2027,7 +2044,7 @@ inline_analyze_function (struct cgraph_node *node)\n \t     cgraph_node_name (node), node->uid);\n   /* FIXME: We should remove the optimize check after we ensure we never run\n      IPA passes when not optimizing.  */\n-  if (flag_indirect_inlining && optimize)\n+  if (flag_indirect_inlining && optimize && !node->thunk.thunk_p)\n     inline_indirect_intraprocedural_analysis (node);\n   compute_inline_parameters (node, false);\n \n@@ -2058,8 +2075,7 @@ inline_generate_summary (void)\n   if (flag_indirect_inlining)\n     ipa_register_cgraph_hooks ();\n \n-  for (node = cgraph_nodes; node; node = node->next)\n-    if (node->analyzed)\n+  FOR_EACH_DEFINED_FUNCTION (node)\n       inline_analyze_function (node);\n }\n "}, {"sha": "f74759ce4fc80d87d384c5d4b4a4e6b47aacdbae", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c47d00347d7e74193dda2e9a3f55f52485e7eeeb/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c47d00347d7e74193dda2e9a3f55f52485e7eeeb/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=c47d00347d7e74193dda2e9a3f55f52485e7eeeb", "patch": "@@ -1235,9 +1235,8 @@ inline_small_functions (void)\n   max_count = 0;\n   initialize_growth_caches ();\n \n-  for (node = cgraph_nodes; node; node = node->next)\n-    if (node->analyzed\n-\t&& !node->global.inlined_to)\n+  FOR_EACH_DEFINED_FUNCTION (node)\n+    if (!node->global.inlined_to)\n       {\n \tstruct inline_summary *info = inline_summary (node);\n \n@@ -1255,9 +1254,8 @@ inline_small_functions (void)\n \n   /* Populate the heeap with all edges we might inline.  */\n \n-  for (node = cgraph_nodes; node; node = node->next)\n-    if (node->analyzed\n-\t&& !node->global.inlined_to)\n+  FOR_EACH_DEFINED_FUNCTION (node)\n+    if (!node->global.inlined_to)\n       {\n \tif (dump_file)\n \t  fprintf (dump_file, \"Enqueueing calls of %s/%i.\\n\","}, {"sha": "7147369e4f7bc21a799478305d71b8920030e6d9", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c47d00347d7e74193dda2e9a3f55f52485e7eeeb/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c47d00347d7e74193dda2e9a3f55f52485e7eeeb/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=c47d00347d7e74193dda2e9a3f55f52485e7eeeb", "patch": "@@ -2888,7 +2888,8 @@ ipa_prop_write_jump_functions (cgraph_node_set set)\n   for (csi = csi_start (set); !csi_end_p (csi); csi_next (&csi))\n     {\n       node = csi_node (csi);\n-      if (node->analyzed && IPA_NODE_REF (node) != NULL)\n+      if (cgraph_function_with_gimple_body_p (node)\n+\t  && IPA_NODE_REF (node) != NULL)\n \tcount++;\n     }\n \n@@ -2898,7 +2899,8 @@ ipa_prop_write_jump_functions (cgraph_node_set set)\n   for (csi = csi_start (set); !csi_end_p (csi); csi_next (&csi))\n     {\n       node = csi_node (csi);\n-      if (node->analyzed && IPA_NODE_REF (node) != NULL)\n+      if (cgraph_function_with_gimple_body_p (node)\n+\t  && IPA_NODE_REF (node) != NULL)\n         ipa_write_node_info (ob, node);\n     }\n   lto_output_1_stream (ob->main_stream, 0);"}, {"sha": "4034d57621d32e6f9e499f5770e6b8a57c225e06", "filename": "gcc/ipa-pure-const.c", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c47d00347d7e74193dda2e9a3f55f52485e7eeeb/gcc%2Fipa-pure-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c47d00347d7e74193dda2e9a3f55f52485e7eeeb/gcc%2Fipa-pure-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-pure-const.c?ref=c47d00347d7e74193dda2e9a3f55f52485e7eeeb", "patch": "@@ -731,6 +731,16 @@ analyze_function (struct cgraph_node *fn, bool ipa)\n   l->looping_previously_known = true;\n   l->looping = false;\n   l->can_throw = false;\n+  state_from_flags (&l->state_previously_known, &l->looping_previously_known,\n+\t\t    flags_from_decl_or_type (fn->decl),\n+\t\t    cgraph_node_cannot_return (fn));\n+\n+  if (fn->thunk.thunk_p)\n+    {\n+      /* Thunk gets propagated through, so nothing interesting happens.  */\n+      gcc_assert (ipa);\n+      return l;\n+    }\n \n   if (dump_file)\n     {\n@@ -799,9 +809,6 @@ analyze_function (struct cgraph_node *fn, bool ipa)\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     fprintf (dump_file, \"    checking previously known:\");\n-  state_from_flags (&l->state_previously_known, &l->looping_previously_known,\n-\t\t    flags_from_decl_or_type (fn->decl),\n-\t\t    cgraph_node_cannot_return (fn));\n \n   better_state (&l->pure_const_state, &l->looping,\n \t\tl->state_previously_known,"}, {"sha": "9228f70edb3c99adb7449b482bb5f0142d4dcdfd", "filename": "gcc/ipa.c", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c47d00347d7e74193dda2e9a3f55f52485e7eeeb/gcc%2Fipa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c47d00347d7e74193dda2e9a3f55f52485e7eeeb/gcc%2Fipa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa.c?ref=c47d00347d7e74193dda2e9a3f55f52485e7eeeb", "patch": "@@ -877,7 +877,47 @@ function_and_variable_visibility (bool whole_program)\n \t       segfault though. */\n \t    dissolve_same_comdat_group_list (node);\n \t}\n+\n+      if (node->thunk.thunk_p\n+\t  && TREE_PUBLIC (node->decl))\n+\t{\n+\t  struct cgraph_node *decl_node = node;\n+\n+\t  while (decl_node->thunk.thunk_p)\n+\t    decl_node = decl_node->callees->callee;\n+\n+\t  /* Thunks have the same visibility as function they are attached to.\n+\t     For some reason C++ frontend don't seem to care. I.e. in \n+\t     g++.dg/torture/pr41257-2.C the thunk is not comdat while function\n+\t     it is attached to is.\n+\n+\t     We also need to arrange the thunk into the same comdat group as\n+\t     the function it reffers to.  */\n+\t  if (DECL_COMDAT (decl_node->decl))\n+\t    {\n+\t      DECL_COMDAT (node->decl) = 1;\n+\t      DECL_COMDAT_GROUP (node->decl) = DECL_COMDAT_GROUP (decl_node->decl);\n+\t      if (!node->same_comdat_group)\n+\t\t{\n+\t\t  node->same_comdat_group = decl_node;\n+\t\t  if (!decl_node->same_comdat_group)\n+\t\t    decl_node->same_comdat_group = node;\n+\t\t  else\n+\t\t    {\n+\t\t      struct cgraph_node *n;\n+\t\t      for (n = decl_node->same_comdat_group;\n+\t\t\t   n->same_comdat_group != decl_node;\n+\t\t\t   n = n->same_comdat_group)\n+\t\t\t;\n+\t\t      n->same_comdat_group = node;\n+\t\t    }\n+\t\t}\n+\t    }\n+\t  if (DECL_EXTERNAL (decl_node->decl))\n+\t    DECL_EXTERNAL (node->decl) = 1;\n+\t}\n       node->local.local = cgraph_local_node_p (node);\n+\n     }\n   for (vnode = varpool_nodes; vnode; vnode = vnode->next)\n     {"}, {"sha": "f4fd2a3b7c485df5e7b0c910030e32670e102282", "filename": "gcc/lto-cgraph.c", "status": "modified", "additions": 39, "deletions": 41, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c47d00347d7e74193dda2e9a3f55f52485e7eeeb/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c47d00347d7e74193dda2e9a3f55f52485e7eeeb/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=c47d00347d7e74193dda2e9a3f55f52485e7eeeb", "patch": "@@ -502,9 +502,24 @@ lto_output_node (struct lto_simple_output_block *ob, struct cgraph_node *node,\n   bp_pack_value (&bp, node->frequency, 2);\n   bp_pack_value (&bp, node->only_called_at_startup, 1);\n   bp_pack_value (&bp, node->only_called_at_exit, 1);\n+  bp_pack_value (&bp, node->thunk.thunk_p && !boundary_p, 1);\n   lto_output_bitpack (&bp);\n   lto_output_uleb128_stream (ob->main_stream, node->resolution);\n \n+  if (node->thunk.thunk_p && !boundary_p)\n+    {\n+      lto_output_uleb128_stream\n+\t (ob->main_stream,\n+\t  1 + (node->thunk.this_adjusting != 0) * 2\n+\t  + (node->thunk.virtual_offset_p != 0) * 4);\n+      lto_output_uleb128_stream (ob->main_stream,\n+\t\t\t\t node->thunk.fixed_offset);\n+      lto_output_uleb128_stream (ob->main_stream,\n+\t\t\t\t node->thunk.virtual_value);\n+      lto_output_fn_decl_index (ob->decl_state, ob->main_stream,\n+\t\t\t\tnode->thunk.alias);\n+    }\n+\n   if (node->same_body)\n     {\n       struct cgraph_node *alias;\n@@ -516,25 +531,8 @@ lto_output_node (struct lto_simple_output_block *ob, struct cgraph_node *node,\n \t{\n \t  lto_output_fn_decl_index (ob->decl_state, ob->main_stream,\n \t\t\t\t    alias->decl);\n-\t  if (alias->thunk.thunk_p)\n-\t    {\n-              lto_output_uleb128_stream\n-\t         (ob->main_stream,\n-\t      \t  1 + (alias->thunk.this_adjusting != 0) * 2\n-\t\t  + (alias->thunk.virtual_offset_p != 0) * 4);\n-\t      lto_output_uleb128_stream (ob->main_stream,\n-\t      \t\t\t\t alias->thunk.fixed_offset);\n-\t      lto_output_uleb128_stream (ob->main_stream,\n-\t      \t\t\t\t alias->thunk.virtual_value);\n-\t      lto_output_fn_decl_index (ob->decl_state, ob->main_stream,\n-\t\t\t\t\talias->thunk.alias);\n-\t    }\n-\t  else\n-\t    {\n-\t      lto_output_uleb128_stream (ob->main_stream, 0);\n-\t      lto_output_fn_decl_index (ob->decl_state, ob->main_stream,\n-\t\t\t\t\talias->thunk.alias);\n-\t    }\n+\t  lto_output_fn_decl_index (ob->decl_state, ob->main_stream,\n+\t\t\t\t    alias->thunk.alias);\n \t  gcc_assert (cgraph_get_node (alias->thunk.alias) == node);\n \t  lto_output_uleb128_stream (ob->main_stream, alias->resolution);\n \t  alias = alias->previous;\n@@ -947,6 +945,7 @@ input_overwrite_node (struct lto_file_decl_data *file_data,\n   node->frequency = (enum node_frequency)bp_unpack_value (bp, 2);\n   node->only_called_at_startup = bp_unpack_value (bp, 1);\n   node->only_called_at_exit = bp_unpack_value (bp, 1);\n+  node->thunk.thunk_p = bp_unpack_value (bp, 1);\n   node->resolution = resolution;\n }\n \n@@ -1031,34 +1030,33 @@ input_node (struct lto_file_decl_data *file_data,\n   /* Store a reference for now, and fix up later to be a pointer.  */\n   node->same_comdat_group = (cgraph_node_ptr) (intptr_t) ref2;\n \n+  if (node->thunk.thunk_p)\n+    {\n+      int type = lto_input_uleb128 (ib);\n+      HOST_WIDE_INT fixed_offset = lto_input_uleb128 (ib);\n+      HOST_WIDE_INT virtual_value = lto_input_uleb128 (ib);\n+      tree real_alias;\n+\n+      decl_index = lto_input_uleb128 (ib);\n+      real_alias = lto_file_decl_data_get_fn_decl (file_data, decl_index);\n+      node->thunk.fixed_offset = fixed_offset;\n+      node->thunk.this_adjusting = (type & 2);\n+      node->thunk.virtual_value = virtual_value;\n+      node->thunk.virtual_offset_p = (type & 4);\n+      node->thunk.alias = real_alias;\n+    }\n+\n   same_body_count = lto_input_uleb128 (ib);\n   while (same_body_count-- > 0)\n     {\n-      tree alias_decl;\n-      int type;\n+      tree alias_decl, real_alias;\n       struct cgraph_node *alias;\n+\n       decl_index = lto_input_uleb128 (ib);\n       alias_decl = lto_file_decl_data_get_fn_decl (file_data, decl_index);\n-      type = lto_input_uleb128 (ib);\n-      if (!type)\n-\t{\n-\t  tree real_alias;\n-\t  decl_index = lto_input_uleb128 (ib);\n-\t  real_alias = lto_file_decl_data_get_fn_decl (file_data, decl_index);\n-\t  alias = cgraph_same_body_alias (node, alias_decl, real_alias);\n-\t}\n-      else\n-        {\n-\t  HOST_WIDE_INT fixed_offset = lto_input_uleb128 (ib);\n-\t  HOST_WIDE_INT virtual_value = lto_input_uleb128 (ib);\n-\t  tree real_alias;\n-\t  decl_index = lto_input_uleb128 (ib);\n-\t  real_alias = lto_file_decl_data_get_fn_decl (file_data, decl_index);\n-\t  alias = cgraph_add_thunk (node, alias_decl, fn_decl, type & 2, fixed_offset,\n-\t\t\t\t    virtual_value,\n-\t\t\t\t    (type & 4) ? size_int (virtual_value) : NULL_TREE,\n-\t\t\t\t    real_alias);\n-\t}\n+      decl_index = lto_input_uleb128 (ib);\n+      real_alias = lto_file_decl_data_get_fn_decl (file_data, decl_index);\n+      alias = cgraph_same_body_alias (node, alias_decl, real_alias);\n       gcc_assert (alias);\n       alias->resolution = (enum ld_plugin_symbol_resolution)lto_input_uleb128 (ib);\n     }"}, {"sha": "48ab36d486f74a9c8723cd8b8df6876dce0625cf", "filename": "gcc/lto-streamer-out.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c47d00347d7e74193dda2e9a3f55f52485e7eeeb/gcc%2Flto-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c47d00347d7e74193dda2e9a3f55f52485e7eeeb/gcc%2Flto-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-out.c?ref=c47d00347d7e74193dda2e9a3f55f52485e7eeeb", "patch": "@@ -2196,7 +2196,8 @@ lto_output (cgraph_node_set set, varpool_node_set vset)\n   for (i = 0; i < n_nodes; i++)\n     {\n       node = lto_cgraph_encoder_deref (encoder, i);\n-      if (lto_cgraph_encoder_encode_body_p (encoder, node))\n+      if (lto_cgraph_encoder_encode_body_p (encoder, node)\n+\t  && !node->thunk.thunk_p)\n \t{\n #ifdef ENABLE_CHECKING\n \t  gcc_assert (!bitmap_bit_p (output, DECL_UID (node->decl)));"}, {"sha": "61558e3fc4a879c62fa1ec2743709e171f254e69", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c47d00347d7e74193dda2e9a3f55f52485e7eeeb/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c47d00347d7e74193dda2e9a3f55f52485e7eeeb/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=c47d00347d7e74193dda2e9a3f55f52485e7eeeb", "patch": "@@ -1,3 +1,9 @@\n+2011-05-07  Jan Hubicka  <jh@suse.cz>\n+\n+\t* lto.c (lto_materialize_function): Use cgraph_function_with_gimple_body_p.\n+\t(add_cgraph_node_to_partition): Do not re-add items to partition; handle thunks.\n+\t(add_varpool_node_to_partition): Do not re-add items to partition.\n+\n 2011-05-03  Jan Hubicka  <jh@suse.cz>\n \n \t* lto.c (free_ltrans_partitions): Fix accidental commit."}, {"sha": "83440224eea17bd14cce574c8733d057015b30cd", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 22, "deletions": 2, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c47d00347d7e74193dda2e9a3f55f52485e7eeeb/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c47d00347d7e74193dda2e9a3f55f52485e7eeeb/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=c47d00347d7e74193dda2e9a3f55f52485e7eeeb", "patch": "@@ -147,9 +147,9 @@ lto_materialize_function (struct cgraph_node *node)\n   decl = node->decl;\n   /* Read in functions with body (analyzed nodes)\n      and also functions that are needed to produce virtual clones.  */\n-  if (node->analyzed || has_analyzed_clone_p (node))\n+  if (cgraph_function_with_gimple_body_p (node) || has_analyzed_clone_p (node))\n     {\n-      /* Clones don't need to be read.  */\n+      /* Clones and thunks don't need to be read.  */\n       if (node->clone_of)\n \treturn;\n \n@@ -1197,6 +1197,12 @@ static void\n add_cgraph_node_to_partition (ltrans_partition part, struct cgraph_node *node)\n {\n   struct cgraph_edge *e;\n+  cgraph_node_set_iterator csi;\n+\n+  /* If NODE is already there, we have nothing to do.  */\n+  csi = cgraph_node_set_find (part->cgraph_set, node);\n+  if (!csi_end_p (csi))\n+    return;\n \n   part->insns += inline_summary (node)->self_size;\n \n@@ -1211,6 +1217,13 @@ add_cgraph_node_to_partition (ltrans_partition part, struct cgraph_node *node)\n \n   cgraph_node_set_add (part->cgraph_set, node);\n \n+  /* Thunks always must go along with function they reffer to.  */\n+  if (node->thunk.thunk_p)\n+    add_cgraph_node_to_partition (part, node->callees->callee);\n+  for (e = node->callers; e; e = e->next_caller)\n+    if (e->caller->thunk.thunk_p)\n+      add_cgraph_node_to_partition (part, e->caller);\n+\n   for (e = node->callees; e; e = e->next_callee)\n     if ((!e->inline_failed || DECL_COMDAT (e->callee->decl))\n \t&& !cgraph_node_in_set_p (e->callee, part->cgraph_set))\n@@ -1228,6 +1241,13 @@ add_cgraph_node_to_partition (ltrans_partition part, struct cgraph_node *node)\n static void\n add_varpool_node_to_partition (ltrans_partition part, struct varpool_node *vnode)\n {\n+  varpool_node_set_iterator vsi;\n+\n+  /* If NODE is already there, we have nothing to do.  */\n+  vsi = varpool_node_set_find (part->varpool_set, vnode);\n+  if (!vsi_end_p (vsi))\n+    return;\n+\n   varpool_node_set_add (part->varpool_set, vnode);\n \n   if (vnode->aux)"}, {"sha": "e176d1c05babb2166242faf39a0c967674f7ed98", "filename": "gcc/passes.c", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c47d00347d7e74193dda2e9a3f55f52485e7eeeb/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c47d00347d7e74193dda2e9a3f55f52485e7eeeb/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=c47d00347d7e74193dda2e9a3f55f52485e7eeeb", "patch": "@@ -1135,7 +1135,7 @@ do_per_function_toporder (void (*callback) (void *data), void *data)\n \t  /* Allow possibly removed nodes to be garbage collected.  */\n \t  order[i] = NULL;\n \t  node->process = 0;\n-\t  if (node->analyzed)\n+\t  if (cgraph_function_with_gimple_body_p (node))\n \t    {\n \t      push_cfun (DECL_STRUCT_FUNCTION (node->decl));\n \t      current_function_decl = node->decl;\n@@ -1581,10 +1581,9 @@ execute_one_pass (struct opt_pass *pass)\n   if (pass->type == IPA_PASS)\n     {\n       struct cgraph_node *node;\n-      for (node = cgraph_nodes; node; node = node->next)\n-        if (node->analyzed)\n-          VEC_safe_push (ipa_opt_pass, heap, node->ipa_transforms_to_apply,\n-\t\t\t (struct ipa_opt_pass_d *)pass);\n+      FOR_EACH_FUNCTION_WITH_GIMPLE_BODY (node)\n+\tVEC_safe_push (ipa_opt_pass, heap, node->ipa_transforms_to_apply,\n+\t\t       (struct ipa_opt_pass_d *)pass);\n     }\n \n   if (!current_function_decl)\n@@ -1705,7 +1704,7 @@ ipa_write_summaries (void)\n     {\n       struct cgraph_node *node = order[i];\n \n-      if (node->analyzed)\n+      if (cgraph_function_with_gimple_body_p (node))\n \t{\n \t  /* When streaming out references to statements as part of some IPA\n \t     pass summary, the statements need to have uids assigned and the\n@@ -1718,7 +1717,7 @@ ipa_write_summaries (void)\n \t  pop_cfun ();\n \t}\n       if (node->analyzed)\n-\tcgraph_node_set_add (set, node);\n+        cgraph_node_set_add (set, node);\n     }\n   vset = varpool_node_set_new ();\n \n@@ -2036,7 +2035,7 @@ function_called_by_processed_nodes_p (void)\n     {\n       if (e->caller->decl == current_function_decl)\n         continue;\n-      if (!e->caller->analyzed)\n+      if (!cgraph_function_with_gimple_body_p (e->caller))\n         continue;\n       if (TREE_ASM_WRITTEN (e->caller->decl))\n         continue;"}]}