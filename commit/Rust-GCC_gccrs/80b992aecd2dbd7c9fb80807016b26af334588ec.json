{"sha": "80b992aecd2dbd7c9fb80807016b26af334588ec", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODBiOTkyYWVjZDJkYmQ3YzlmYjgwODA3MDE2YjI2YWYzMzQ1ODhlYw==", "commit": {"author": {"name": "Hristian Kirtchev", "email": "kirtchev@adacore.com", "date": "2007-12-13T10:26:10Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-12-13T10:26:10Z"}, "message": "exp_disp.ads, [...] (Default_Prim_Op_Position): Primitive _Disp_Requeue occupies dispatch table slot number 15.\n\n2007-12-06  Hristian Kirtchev  <kirtchev@adacore.com>\n\t    Javier Miranda  <miranda@adacore.com>\n\n\t* exp_disp.ads, exp_disp.adb (Default_Prim_Op_Position): Primitive\n\t_Disp_Requeue occupies dispatch table slot number 15. Move\n\t_Disp_Timed_Select to slot 16.\n\t(Make_Disp_Requeue_Body, Make_Disp_Requeue_Spec): New routines which\n\tgenerate the spec and body of _Disp_Reqeueue.\n\t(Make_DT): Build and initialize the second dispatch table.\n\tHandle initialization of RC_Offset when the parent\n\tis a private type with variable size components.\n\t(Make_Secondary_DT): Complete documentation. Add support to\n\tinitialize the second dispatch table.\n\t(Make_Tags): Generate the tag of the second dispatch table.\n\t(Register_Primitive): Add support to register primitives in the\n\tsecond dispatch table.\n\nFrom-SVN: r130835", "tree": {"sha": "cf94041983da12af1b94e4372cefd1f4e01b503f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cf94041983da12af1b94e4372cefd1f4e01b503f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/80b992aecd2dbd7c9fb80807016b26af334588ec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/80b992aecd2dbd7c9fb80807016b26af334588ec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/80b992aecd2dbd7c9fb80807016b26af334588ec", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/80b992aecd2dbd7c9fb80807016b26af334588ec/comments", "author": {"login": "kirtchev-adacore", "id": 60669983, "node_id": "MDQ6VXNlcjYwNjY5OTgz", "avatar_url": "https://avatars.githubusercontent.com/u/60669983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kirtchev-adacore", "html_url": "https://github.com/kirtchev-adacore", "followers_url": "https://api.github.com/users/kirtchev-adacore/followers", "following_url": "https://api.github.com/users/kirtchev-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/kirtchev-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/kirtchev-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kirtchev-adacore/subscriptions", "organizations_url": "https://api.github.com/users/kirtchev-adacore/orgs", "repos_url": "https://api.github.com/users/kirtchev-adacore/repos", "events_url": "https://api.github.com/users/kirtchev-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/kirtchev-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "867aba4e8d623fd9817881052b4c10c92ed64cb5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/867aba4e8d623fd9817881052b4c10c92ed64cb5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/867aba4e8d623fd9817881052b4c10c92ed64cb5"}], "stats": {"total": 1055, "additions": 868, "deletions": 187}, "files": [{"sha": "adb67b2fac04e2bb1dc10a4660d3044f0ddc4027", "filename": "gcc/ada/exp_disp.adb", "status": "modified", "additions": 849, "deletions": 185, "changes": 1034, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80b992aecd2dbd7c9fb80807016b26af334588ec/gcc%2Fada%2Fexp_disp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80b992aecd2dbd7c9fb80807016b26af334588ec/gcc%2Fada%2Fexp_disp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_disp.adb?ref=80b992aecd2dbd7c9fb80807016b26af334588ec", "patch": "@@ -307,8 +307,11 @@ package body Exp_Disp is\n          elsif Chars (E) = Name_uDisp_Get_Task_Id then\n             return Uint_14;\n \n-         elsif Chars (E) = Name_uDisp_Timed_Select then\n+         elsif Chars (E) = Name_uDisp_Requeue then\n             return Uint_15;\n+\n+         elsif Chars (E) = Name_uDisp_Timed_Select then\n+            return Uint_16;\n          end if;\n       end if;\n \n@@ -1464,6 +1467,62 @@ package body Exp_Disp is\n    -- Make_Disp_Asynchronous_Select_Body --\n    ----------------------------------------\n \n+   --  For interface types, generate:\n+\n+   --     procedure _Disp_Asynchronous_Select\n+   --       (T : in out <Typ>;\n+   --        S : Integer;\n+   --        P : System.Address;\n+   --        B : out System.Storage_Elements.Dummy_Communication_Block;\n+   --        F : out Boolean)\n+   --     is\n+   --     begin\n+   --        null;\n+   --     end _Disp_Asynchronous_Select;\n+\n+   --  For protected types, generate:\n+\n+   --     procedure _Disp_Asynchronous_Select\n+   --       (T : in out <Typ>;\n+   --        S : Integer;\n+   --        P : System.Address;\n+   --        B : out System.Storage_Elements.Dummy_Communication_Block;\n+   --        F : out Boolean)\n+   --     is\n+   --        I   : Integer :=\n+   --                Ada.Tags.Get_Entry_Index (Ada.Tags.Tag (<Typ>VP, S));\n+   --        Bnn : System.Tasking.Protected_Objects.Operations.\n+   --                Communication_Block;\n+   --     begin\n+   --        System.Tasking.Protected_Objects.Operations.Protected_Entry_Call\n+   --          (T._object'Access,\n+   --           System.Tasking.Protected_Objects.Protected_Entry_Index (I),\n+   --           P,\n+   --           System.Tasking.Asynchronous_Call,\n+   --           Bnn);\n+   --        B := System.Storage_Elements.Dummy_Communication_Block (Bnn);\n+   --     end _Disp_Asynchronous_Select;\n+\n+   --  For task types, generate:\n+\n+   --     procedure _Disp_Asynchronous_Select\n+   --       (T : in out <Typ>;\n+   --        S : Integer;\n+   --        P : System.Address;\n+   --        B : out System.Storage_Elements.Dummy_Communication_Block;\n+   --        F : out Boolean)\n+   --     is\n+   --        I   : Integer :=\n+   --                Ada.Tags.Get_Entry_Index (Ada.Tags.Tag (<Typ>VP, S));\n+   --     begin\n+   --        System.Tasking.Rendezvous.Task_Entry_Call\n+   --          (T._task_id,\n+   --           System.Tasking.Task_Entry_Index (I),\n+   --           P,\n+   --           System.Tasking.Asynchronous_Call,\n+   --           F);\n+   --     end _Disp_Asynchronous_Select;\n+\n    function Make_Disp_Asynchronous_Select_Body\n      (Typ : Entity_Id) return Node_Id\n    is\n@@ -1497,7 +1556,8 @@ package body Exp_Disp is\n          Conc_Typ := Corresponding_Concurrent_Type (Typ);\n \n          --  Generate:\n-         --    I : Integer := Get_Entry_Index (tag! (<type>VP), S);\n+         --    I : Integer :=\n+         --          Ada.Tags.Get_Entry_Index (Ada.Tags.Tag! (<type>VP), S);\n \n          --  where I will be used to capture the entry index of the primitive\n          --  wrapper at position S.\n@@ -1510,16 +1570,18 @@ package body Exp_Disp is\n                New_Reference_To (Standard_Integer, Loc),\n              Expression =>\n                Make_Function_Call (Loc,\n-                 Name => New_Reference_To (RTE (RE_Get_Entry_Index), Loc),\n-                 Parameter_Associations => New_List (\n-                   Unchecked_Convert_To (RTE (RE_Tag),\n-                     New_Reference_To (DT_Ptr, Loc)),\n-                   Make_Identifier (Loc, Name_uS)))));\n+                 Name =>\n+                   New_Reference_To (RTE (RE_Get_Entry_Index), Loc),\n+                 Parameter_Associations =>\n+                   New_List (\n+                     Unchecked_Convert_To (RTE (RE_Tag),\n+                       New_Reference_To (DT_Ptr, Loc)),\n+                     Make_Identifier (Loc, Name_uS)))));\n \n          if Ekind (Conc_Typ) = E_Protected_Type then\n \n             --  Generate:\n-            --    Com_Block : Communication_Block;\n+            --    Bnn : Communication_Block;\n \n             Com_Block :=\n               Make_Defining_Identifier (Loc, New_Internal_Name ('B'));\n@@ -1532,12 +1594,12 @@ package body Exp_Disp is\n                   New_Reference_To (RTE (RE_Communication_Block), Loc)));\n \n             --  Generate:\n-            --    Protected_Entry_Call (\n-            --      T._object'access,\n-            --      protected_entry_index! (I),\n-            --      P,\n-            --      Asynchronous_Call,\n-            --      Com_Block);\n+            --    Protected_Entry_Call\n+            --      (T._object'Access,            --  Object\n+            --       Protected_Entry_Index! (I),  --  E\n+            --       P,                           --  Uninterpreted_Data\n+            --       Asynchronous_Call,           --  Mode\n+            --       Bnn);                        --  Communication_Block\n \n             --  where T is the protected object, I is the entry index, P are\n             --  the wrapped parameters and B is the name of the communication\n@@ -1550,7 +1612,7 @@ package body Exp_Disp is\n                 Parameter_Associations =>\n                   New_List (\n \n-                    Make_Attribute_Reference (Loc,        -- T._object'access\n+                    Make_Attribute_Reference (Loc,        -- T._object'Access\n                       Attribute_Name =>\n                         Name_Unchecked_Access,\n                       Prefix =>\n@@ -1573,7 +1635,7 @@ package body Exp_Disp is\n                     New_Reference_To (Com_Block, Loc)))); -- comm block\n \n             --  Generate:\n-            --    B := Dummy_Communication_Bloc (Com_Block);\n+            --    B := Dummy_Communication_Block (Bnn);\n \n             Append_To (Stmts,\n               Make_Assignment_Statement (Loc,\n@@ -1591,12 +1653,12 @@ package body Exp_Disp is\n             pragma Assert (Ekind (Conc_Typ) = E_Task_Type);\n \n             --  Generate:\n-            --    Protected_Entry_Call (\n-            --      T._task_id,\n-            --      task_entry_index! (I),\n-            --      P,\n-            --      Conditional_Call,\n-            --      F);\n+            --    Task_Entry_Call\n+            --      (T._task_id,             --  Acceptor\n+            --       Task_Entry_Index! (I),  --  E\n+            --       P,                      --  Uninterpreted_Data\n+            --       Asynchronous_Call,      --  Mode\n+            --       F);                     --  Rendezvous_Successful\n \n             --  where T is the task object, I is the entry index, P are the\n             --  wrapped parameters and F is the status flag.\n@@ -1705,6 +1767,74 @@ package body Exp_Disp is\n    -- Make_Disp_Conditional_Select_Body --\n    ---------------------------------------\n \n+   --  For interface types, generate:\n+\n+   --     procedure _Disp_Conditional_Select\n+   --       (T : in out <Typ>;\n+   --        S : Integer;\n+   --        P : System.Address;\n+   --        C : out Ada.Tags.Prim_Op_Kind;\n+   --        F : out Boolean)\n+   --     is\n+   --     begin\n+   --        null;\n+   --     end _Disp_Conditional_Select;\n+\n+   --  For protected types, generate:\n+\n+   --     procedure _Disp_Conditional_Select\n+   --       (T : in out <Typ>;\n+   --        S : Integer;\n+   --        P : System.Address;\n+   --        C : out Ada.Tags.Prim_Op_Kind;\n+   --        F : out Boolean)\n+   --     is\n+   --        I   : Integer;\n+   --        Bnn : System.Tasking.Protected_Objects.Operations.\n+   --                Communication_Block;\n+\n+   --     begin\n+   --        C := Ada.Tags.Get_Prim_Op_Kind (Ada.Tags.Tag (<Typ>VP, S));\n+\n+   --        if C = Ada.Tags.POK_Procedure\n+   --          or else C = Ada.Tags.POK_Protected_Procedure\n+   --          or else C = Ada.Tags.POK_Task_Procedure\n+   --        then\n+   --           F := True;\n+   --           return;\n+   --        end if;\n+\n+   --        I := Ada.Tags.Get_Entry_Index (Ada.Tags.Tag (<Typ>VP, S));\n+   --        System.Tasking.Protected_Objects.Operations.Protected_Entry_Call\n+   --          (T.object'Access,\n+   --           System.Tasking.Protected_Objects.Protected_Entry_Index (I),\n+   --           P,\n+   --           System.Tasking.Conditional_Call,\n+   --           Bnn);\n+   --        F := not Cancelled (Bnn);\n+   --     end _Disp_Conditional_Select;\n+\n+   --  For task types, generate:\n+\n+   --     procedure _Disp_Conditional_Select\n+   --       (T : in out <Typ>;\n+   --        S : Integer;\n+   --        P : System.Address;\n+   --        C : out Ada.Tags.Prim_Op_Kind;\n+   --        F : out Boolean)\n+   --     is\n+   --        I : Integer;\n+\n+   --     begin\n+   --        I := Ada.Tags.Get_Entry_Index (Ada.Tags.Tag (<Typ>VP, S));\n+   --        System.Tasking.Rendezvous.Task_Entry_Call\n+   --          (T._task_id,\n+   --           System.Tasking.Task_Entry_Index (I),\n+   --           P,\n+   --           System.Tasking.Conditional_Call,\n+   --           F);\n+   --     end _Disp_Conditional_Select;\n+\n    function Make_Disp_Conditional_Select_Body\n      (Typ : Entity_Id) return Node_Id\n    is\n@@ -1751,7 +1881,7 @@ package body Exp_Disp is\n                New_Reference_To (Standard_Integer, Loc)));\n \n          --  Generate:\n-         --    C := Get_Prim_Op_Kind (tag! (<type>VP), S);\n+         --    C := Ada.Tags.Get_Prim_Op_Kind (Ada.Tags.Tag! (<type>VP), S);\n \n          --    if C = POK_Procedure\n          --      or else C = POK_Protected_Procedure\n@@ -1766,8 +1896,8 @@ package body Exp_Disp is\n          --  Generate:\n          --    Bnn : Communication_Block;\n \n-         --  where Bnn is the name of the communication block used in\n-         --  the call to Protected_Entry_Call.\n+         --  where Bnn is the name of the communication block used in the\n+         --  call to Protected_Entry_Call.\n \n          Blk_Nam := Make_Defining_Identifier (Loc, New_Internal_Name ('B'));\n \n@@ -1779,7 +1909,7 @@ package body Exp_Disp is\n                New_Reference_To (RTE (RE_Communication_Block), Loc)));\n \n          --  Generate:\n-         --    I := Get_Entry_Index (tag! (<type>VP), S);\n+         --    I := Ada.Tags.Get_Entry_Index (Ada.Tags.Tag! (<type>VP), S);\n \n          --  I is the entry index and S is the dispatch table slot\n \n@@ -1789,21 +1919,23 @@ package body Exp_Disp is\n                Make_Identifier (Loc, Name_uI),\n              Expression =>\n                Make_Function_Call (Loc,\n-                 Name => New_Reference_To (RTE (RE_Get_Entry_Index), Loc),\n-                 Parameter_Associations => New_List (\n-                   Unchecked_Convert_To (RTE (RE_Tag),\n-                     New_Reference_To (DT_Ptr, Loc)),\n-                   Make_Identifier (Loc, Name_uS)))));\n+                 Name =>\n+                   New_Reference_To (RTE (RE_Get_Entry_Index), Loc),\n+                 Parameter_Associations =>\n+                   New_List (\n+                     Unchecked_Convert_To (RTE (RE_Tag),\n+                       New_Reference_To (DT_Ptr, Loc)),\n+                     Make_Identifier (Loc, Name_uS)))));\n \n          if Ekind (Conc_Typ) = E_Protected_Type then\n \n             --  Generate:\n-            --    Protected_Entry_Call (\n-            --      T._object'access,\n-            --      protected_entry_index! (I),\n-            --      P,\n-            --      Conditional_Call,\n-            --      Bnn);\n+            --    Protected_Entry_Call\n+            --      (T._object'Access,            --  Object\n+            --       Protected_Entry_Index! (I),  --  E\n+            --       P,                           --  Uninterpreted_Data\n+            --       Conditional_Call,            --  Mode\n+            --       Bnn);                        --  Block\n \n             --  where T is the protected object, I is the entry index, P are\n             --  the wrapped parameters and Bnn is the name of the communication\n@@ -1816,7 +1948,7 @@ package body Exp_Disp is\n                 Parameter_Associations =>\n                   New_List (\n \n-                    Make_Attribute_Reference (Loc,        -- T._object'access\n+                    Make_Attribute_Reference (Loc,        -- T._object'Access\n                       Attribute_Name =>\n                         Name_Unchecked_Access,\n                       Prefix =>\n@@ -1861,12 +1993,12 @@ package body Exp_Disp is\n             pragma Assert (Ekind (Conc_Typ) = E_Task_Type);\n \n             --  Generate:\n-            --    Protected_Entry_Call (\n-            --      T._task_id,\n-            --      task_entry_index! (I),\n-            --      P,\n-            --      Conditional_Call,\n-            --      F);\n+            --    Task_Entry_Call\n+            --      (T._task_id,             --  Acceptor\n+            --       Task_Entry_Index! (I),  --  E\n+            --       P,                      --  Uninterpreted_Data\n+            --       Conditional_Call,       --  Mode\n+            --       F);                     --  Rendezvous_Successful\n \n             --  where T is the task object, I is the entry index, P are the\n             --  wrapped parameters and F is the status flag.\n@@ -2156,10 +2288,369 @@ package body Exp_Disp is\n             New_Reference_To (RTE (RE_Address), Loc));\n    end Make_Disp_Get_Task_Id_Spec;\n \n+   ----------------------------\n+   -- Make_Disp_Requeue_Body --\n+   ----------------------------\n+\n+   function Make_Disp_Requeue_Body\n+     (Typ : Entity_Id) return Node_Id\n+   is\n+      Loc      : constant Source_Ptr := Sloc (Typ);\n+      Conc_Typ : Entity_Id           := Empty;\n+      Stmts    : constant List_Id    := New_List;\n+\n+   begin\n+      pragma Assert (not Restriction_Active (No_Dispatching_Calls));\n+\n+      --  Null body is generated for interface types and non-concurrent\n+      --  tagged types.\n+\n+      if Is_Interface (Typ)\n+        or else not Is_Concurrent_Record_Type (Typ)\n+      then\n+         return\n+           Make_Subprogram_Body (Loc,\n+             Specification =>\n+               Make_Disp_Requeue_Spec (Typ),\n+             Declarations =>\n+               No_List,\n+             Handled_Statement_Sequence =>\n+               Make_Handled_Sequence_Of_Statements (Loc,\n+                 New_List (Make_Null_Statement (Loc))));\n+      end if;\n+\n+      Conc_Typ := Corresponding_Concurrent_Type (Typ);\n+\n+      if Ekind (Conc_Typ) = E_Protected_Type then\n+\n+         --  Generate statements:\n+         --    if F then\n+         --       System.Tasking.Protected_Objects.Operations.\n+         --         Requeue_Protected_Entry\n+         --           (Protection_Entries_Access (P),\n+         --            O._object'Unchecked_Access,\n+         --            Protected_Entry_Index (I),\n+         --            A);\n+         --    else\n+         --       System.Tasking.Protected_Objects.Operations.\n+         --         Requeue_Task_To_Protected_Entry\n+         --           (O._object'Unchecked_Access,\n+         --            Protected_Entry_Index (I),\n+         --            A);\n+         --    end if;\n+\n+         Append_To (Stmts,\n+           Make_If_Statement (Loc,\n+             Condition =>\n+               Make_Identifier (Loc, Name_uF),\n+\n+             Then_Statements =>\n+               New_List (\n+\n+                  --  Call to Requeue_Protected_Entry\n+\n+                 Make_Procedure_Call_Statement (Loc,\n+                   Name =>\n+                     New_Reference_To (\n+                       RTE (RE_Requeue_Protected_Entry), Loc),\n+                   Parameter_Associations =>\n+                     New_List (\n+\n+                       Make_Unchecked_Type_Conversion (Loc,  -- PEA (P)\n+                         Subtype_Mark =>\n+                           New_Reference_To (\n+                             RTE (RE_Protection_Entries_Access), Loc),\n+                         Expression =>\n+                           Make_Identifier (Loc, Name_uP)),\n+\n+                       Make_Attribute_Reference (Loc,        -- O._object'Acc\n+                         Attribute_Name =>\n+                           Name_Unchecked_Access,\n+                         Prefix =>\n+                           Make_Selected_Component (Loc,\n+                             Prefix =>\n+                               Make_Identifier (Loc, Name_uO),\n+                             Selector_Name =>\n+                               Make_Identifier (Loc, Name_uObject))),\n+\n+                       Make_Unchecked_Type_Conversion (Loc,  -- entry index\n+                         Subtype_Mark =>\n+                           New_Reference_To (\n+                             RTE (RE_Protected_Entry_Index), Loc),\n+                         Expression =>\n+                           Make_Identifier (Loc, Name_uI)),\n+\n+                       Make_Identifier (Loc, Name_uA)))),    -- abort status\n+\n+             Else_Statements =>\n+               New_List (\n+\n+                  --  Call to Requeue_Task_To_Protected_Entry\n+\n+                 Make_Procedure_Call_Statement (Loc,\n+                   Name =>\n+                     New_Reference_To (\n+                       RTE (RE_Requeue_Task_To_Protected_Entry), Loc),\n+                   Parameter_Associations =>\n+                     New_List (\n+\n+                       Make_Attribute_Reference (Loc,        -- O._object'Acc\n+                         Attribute_Name =>\n+                           Name_Unchecked_Access,\n+                         Prefix =>\n+                           Make_Selected_Component (Loc,\n+                             Prefix =>\n+                               Make_Identifier (Loc, Name_uO),\n+                             Selector_Name =>\n+                               Make_Identifier (Loc, Name_uObject))),\n+\n+                       Make_Unchecked_Type_Conversion (Loc,  -- entry index\n+                         Subtype_Mark =>\n+                           New_Reference_To (\n+                             RTE (RE_Protected_Entry_Index), Loc),\n+                         Expression =>\n+                           Make_Identifier (Loc, Name_uI)),\n+\n+                       Make_Identifier (Loc, Name_uA))))));  -- abort status\n+      else\n+         pragma Assert (Is_Task_Type (Conc_Typ));\n+\n+         --  Generate:\n+         --    if F then\n+         --       System.Tasking.Rendezvous.Requeue_Protected_To_Task_Entry\n+         --         (Protection_Entries_Access (P),\n+         --          O._task_id,\n+         --          Task_Entry_Index (I),\n+         --          A);\n+         --    else\n+         --       System.Tasking.Rendezvous.Requeue_Task_Entry\n+         --         (O._task_id,\n+         --          Task_Entry_Index (I),\n+         --          A);\n+         --    end if;\n+\n+         Append_To (Stmts,\n+           Make_If_Statement (Loc,\n+             Condition =>\n+               Make_Identifier (Loc, Name_uF),\n+\n+             Then_Statements =>\n+               New_List (\n+\n+                  --  Call to Requeue_Protected_To_Task_Entry\n+\n+                 Make_Procedure_Call_Statement (Loc,\n+                   Name =>\n+                     New_Reference_To (\n+                       RTE (RE_Requeue_Protected_To_Task_Entry), Loc),\n+\n+                   Parameter_Associations =>\n+                     New_List (\n+\n+                       Make_Unchecked_Type_Conversion (Loc,  -- PEA (P)\n+                         Subtype_Mark =>\n+                           New_Reference_To (\n+                             RTE (RE_Protection_Entries_Access), Loc),\n+                         Expression =>\n+                           Make_Identifier (Loc, Name_uP)),\n+\n+                       Make_Selected_Component (Loc,         -- O._task_id\n+                         Prefix =>\n+                           Make_Identifier (Loc, Name_uO),\n+                         Selector_Name =>\n+                           Make_Identifier (Loc, Name_uTask_Id)),\n+\n+                       Make_Unchecked_Type_Conversion (Loc,  -- entry index\n+                         Subtype_Mark =>\n+                           New_Reference_To (\n+                             RTE (RE_Task_Entry_Index), Loc),\n+                         Expression =>\n+                           Make_Identifier (Loc, Name_uI)),\n+\n+                       Make_Identifier (Loc, Name_uA)))),    -- abort status\n+\n+             Else_Statements =>\n+               New_List (\n+\n+                  --  Call to Requeue_Task_Entry\n+\n+                 Make_Procedure_Call_Statement (Loc,\n+                   Name =>\n+                     New_Reference_To (RTE (RE_Requeue_Task_Entry), Loc),\n+\n+                   Parameter_Associations =>\n+                     New_List (\n+\n+                       Make_Selected_Component (Loc,         -- O._task_id\n+                         Prefix =>\n+                           Make_Identifier (Loc, Name_uO),\n+                         Selector_Name =>\n+                           Make_Identifier (Loc, Name_uTask_Id)),\n+\n+                       Make_Unchecked_Type_Conversion (Loc,  -- entry index\n+                         Subtype_Mark =>\n+                           New_Reference_To (\n+                             RTE (RE_Task_Entry_Index), Loc),\n+                         Expression =>\n+                           Make_Identifier (Loc, Name_uI)),\n+\n+                       Make_Identifier (Loc, Name_uA))))));  -- abort status\n+      end if;\n+\n+      --  Even though no declarations are needed in both cases, we allocate\n+      --  a list for entities added by Freeze.\n+\n+      return\n+        Make_Subprogram_Body (Loc,\n+          Specification =>\n+            Make_Disp_Requeue_Spec (Typ),\n+          Declarations =>\n+            New_List,\n+          Handled_Statement_Sequence =>\n+            Make_Handled_Sequence_Of_Statements (Loc, Stmts));\n+   end Make_Disp_Requeue_Body;\n+\n+   ----------------------------\n+   -- Make_Disp_Requeue_Spec --\n+   ----------------------------\n+\n+   function Make_Disp_Requeue_Spec\n+     (Typ : Entity_Id) return Node_Id\n+   is\n+      Loc : constant Source_Ptr := Sloc (Typ);\n+\n+   begin\n+      pragma Assert (not Restriction_Active (No_Dispatching_Calls));\n+\n+      --  O : in out Typ;   -  Object parameter\n+      --  F : Boolean;      -  Protected (True) / task (False) flag\n+      --  P : Address;      -  Protection_Entries_Access value\n+      --  I : Entry_Index   -  Index of entry call\n+      --  A : Boolean       -  Abort flag\n+\n+      --  Note that the Protection_Entries_Access value is represented as a\n+      --  System.Address in order to avoid dragging in the tasking runtime\n+      --  when compiling sources without tasking constructs.\n+\n+      return\n+        Make_Procedure_Specification (Loc,\n+          Defining_Unit_Name =>\n+            Make_Defining_Identifier (Loc, Name_uDisp_Requeue),\n+\n+          Parameter_Specifications =>\n+            New_List (\n+\n+              Make_Parameter_Specification (Loc,             --  O\n+                Defining_Identifier =>\n+                  Make_Defining_Identifier (Loc, Name_uO),\n+                Parameter_Type =>\n+                  New_Reference_To (Typ, Loc),\n+                In_Present  => True,\n+                Out_Present => True),\n+\n+              Make_Parameter_Specification (Loc,             --  F\n+                Defining_Identifier =>\n+                  Make_Defining_Identifier (Loc, Name_uF),\n+                Parameter_Type =>\n+                  New_Reference_To (Standard_Boolean, Loc)),\n+\n+              Make_Parameter_Specification (Loc,             --  P\n+                Defining_Identifier =>\n+                  Make_Defining_Identifier (Loc, Name_uP),\n+                Parameter_Type =>\n+                  New_Reference_To (RTE (RE_Address), Loc)),\n+\n+              Make_Parameter_Specification (Loc,             --  I\n+                Defining_Identifier =>\n+                  Make_Defining_Identifier (Loc, Name_uI),\n+                Parameter_Type =>\n+                  New_Reference_To (Standard_Integer, Loc)),\n+\n+              Make_Parameter_Specification (Loc,             --  A\n+                Defining_Identifier =>\n+                  Make_Defining_Identifier (Loc, Name_uA),\n+                Parameter_Type =>\n+                  New_Reference_To (Standard_Boolean, Loc))));\n+   end Make_Disp_Requeue_Spec;\n+\n    ---------------------------------\n    -- Make_Disp_Timed_Select_Body --\n    ---------------------------------\n \n+   --  For interface types, generate:\n+\n+   --     procedure _Disp_Timed_Select\n+   --       (T : in out <Typ>;\n+   --        S : Integer;\n+   --        P : System.Address;\n+   --        D : Duration;\n+   --        M : Integer;\n+   --        C : out Ada.Tags.Prim_Op_Kind;\n+   --        F : out Boolean)\n+   --     is\n+   --     begin\n+   --        null;\n+   --     end _Disp_Timed_Select;\n+\n+   --  For protected types, generate:\n+\n+   --     procedure _Disp_Timed_Select\n+   --       (T : in out <Typ>;\n+   --        S : Integer;\n+   --        P : System.Address;\n+   --        D : Duration;\n+   --        M : Integer;\n+   --        C : out Ada.Tags.Prim_Op_Kind;\n+   --        F : out Boolean)\n+   --     is\n+   --        I : Integer;\n+\n+   --     begin\n+   --        C := Ada.Tags.Get_Prim_Op_Kind (Ada.Tags.Tag (<Typ>VP), S);\n+\n+   --        if C = Ada.Tags.POK_Procedure\n+   --          or else C = Ada.Tags.POK_Protected_Procedure\n+   --          or else C = Ada.Tags.POK_Task_Procedure\n+   --        then\n+   --           F := True;\n+   --           return;\n+   --        end if;\n+\n+   --        I := Ada.Tags.Get_Entry_Index (Ada.Tags.Tag (<Typ>VP), S);\n+   --        System.Tasking.Protected_Objects.Operations.\n+   --          Timed_Protected_Entry_Call\n+   --            (T._object'Access,\n+   --             System.Tasking.Protected_Objects.Protected_Entry_Index (I),\n+   --             P,\n+   --             D,\n+   --             M,\n+   --             F);\n+   --     end _Disp_Timed_Select;\n+\n+   --  For task types, generate:\n+\n+   --     procedure _Disp_Timed_Select\n+   --       (T : in out <Typ>;\n+   --        S : Integer;\n+   --        P : System.Address;\n+   --        D : Duration;\n+   --        M : Integer;\n+   --        C : out Ada.Tags.Prim_Op_Kind;\n+   --        F : out Boolean)\n+   --     is\n+   --        I : Integer;\n+\n+   --     begin\n+   --        I := Ada.Tags.Get_Entry_Index (Ada.Tags.Tag (<Typ>VP), S);\n+   --        System.Tasking.Rendezvous.Timed_Task_Entry_Call\n+   --          (T._task_id,\n+   --           System.Tasking.Task_Entry_Index (I),\n+   --           P,\n+   --           D,\n+   --           M,\n+   --           D);\n+   --     end _Disp_Time_Select;\n+\n    function Make_Disp_Timed_Select_Body\n      (Typ : Entity_Id) return Node_Id\n    is\n@@ -2228,18 +2719,20 @@ package body Exp_Disp is\n                Make_Identifier (Loc, Name_uI),\n              Expression =>\n                Make_Function_Call (Loc,\n-                 Name => New_Reference_To (RTE (RE_Get_Entry_Index), Loc),\n-                 Parameter_Associations => New_List (\n-                   Unchecked_Convert_To (RTE (RE_Tag),\n-                     New_Reference_To (DT_Ptr, Loc)),\n-                   Make_Identifier (Loc, Name_uS)))));\n+                 Name =>\n+                   New_Reference_To (RTE (RE_Get_Entry_Index), Loc),\n+                 Parameter_Associations =>\n+                   New_List (\n+                     Unchecked_Convert_To (RTE (RE_Tag),\n+                       New_Reference_To (DT_Ptr, Loc)),\n+                     Make_Identifier (Loc, Name_uS)))));\n \n          if Ekind (Conc_Typ) = E_Protected_Type then\n \n             --  Generate:\n             --    Timed_Protected_Entry_Call (\n             --      T._object'access,\n-            --      protected_entry_index! (I),\n+            --      Protected_Entry_Index! (I),\n             --      P,\n             --      D,\n             --      M,\n@@ -2283,7 +2776,7 @@ package body Exp_Disp is\n             --  Generate:\n             --    Timed_Task_Entry_Call (\n             --      T._task_id,\n-            --      task_entry_index! (I),\n+            --      Task_Entry_Index! (I),\n             --      P,\n             --      D,\n             --      M,\n@@ -2464,17 +2957,22 @@ package body Exp_Disp is\n       --  generate forward references and statically allocate the table.\n \n       procedure Make_Secondary_DT\n-        (Typ          : Entity_Id;\n-         Iface        : Entity_Id;\n-         AI_Tag       : Entity_Id;\n-         Iface_DT_Ptr : Entity_Id;\n-         Result       : List_Id);\n-      --  Ada 2005 (AI-251): Expand the declarations for the Secondary Dispatch\n-      --  Table of Typ associated with Iface (each abstract interface of Typ\n-      --  has a secondary dispatch table). The arguments Typ, Ancestor_Typ\n-      --  and Suffix_Index are used to generate an unique external name which\n-      --  is added at the end of Acc_Disp_Tables; this external name will be\n-      --  used later by the subprogram Exp_Ch3.Build_Init_Procedure.\n+        (Typ             : Entity_Id;\n+         Iface           : Entity_Id;\n+         Num_Iface_Prims : Nat;\n+         Iface_DT_Ptr    : Entity_Id;\n+         Build_Thunks    : Boolean;\n+         Result          : List_Id);\n+      --  Ada 2005 (AI-251): Expand the declarations for a Secondary Dispatch\n+      --  Table of Typ associated with Iface. Each abstract interface of Typ\n+      --  has two secondary dispatch tables: one containing pointers to thunks\n+      --  and another containing pointers to the primitives covering the\n+      --  interface primitives. The former secondary table is generated when\n+      --  Build_Thunks is True, and provides common support for dispatching\n+      --  calls through interface types; the latter secondary table is\n+      --  generated when Build_Thunks is False, and provides support for\n+      --  Generic Dispatching Constructors that dispatch calls through\n+      --  interface types.\n \n       ------------------------------\n       -- Check_Premature_Freezing --\n@@ -2526,11 +3024,12 @@ package body Exp_Disp is\n       -----------------------\n \n       procedure Make_Secondary_DT\n-        (Typ          : Entity_Id;\n-         Iface        : Entity_Id;\n-         AI_Tag       : Entity_Id;\n-         Iface_DT_Ptr : Entity_Id;\n-         Result       : List_Id)\n+        (Typ             : Entity_Id;\n+         Iface           : Entity_Id;\n+         Num_Iface_Prims : Nat;\n+         Iface_DT_Ptr    : Entity_Id;\n+         Build_Thunks    : Boolean;\n+         Result          : List_Id)\n       is\n          Loc                : constant Source_Ptr := Sloc (Typ);\n          Name_DT            : constant Name_Id := New_Internal_Name ('T');\n@@ -2582,11 +3081,11 @@ package body Exp_Disp is\n          --  entry for its DT because at run-time the pointer to this dummy\n          --  entry will be used as the tag.\n \n-         Nb_Prim := UI_To_Int (DT_Entry_Count (AI_Tag));\n-\n-         if Nb_Prim = 0 then\n+         if Num_Iface_Prims = 0 then\n             Empty_DT := True;\n             Nb_Prim  := 1;\n+         else\n+            Nb_Prim  := Num_Iface_Prims;\n          end if;\n \n          --  Generate:\n@@ -2633,29 +3132,38 @@ package body Exp_Disp is\n             Prim_Ops_Aggr_List := New_List;\n             Prim_Table := (others => Empty);\n \n-            Prim_Elmt := First_Elmt (Primitive_Operations (Typ));\n-            while Present (Prim_Elmt) loop\n-               Prim := Node (Prim_Elmt);\n+            if Building_Static_DT (Typ) then\n+               Prim_Elmt := First_Elmt (Primitive_Operations (Typ));\n+               while Present (Prim_Elmt) loop\n+                  Prim := Node (Prim_Elmt);\n \n-               if Is_Predefined_Dispatching_Operation (Prim)\n-                 and then not Is_Abstract_Subprogram (Prim)\n-                 and then not Present (Prim_Table\n-                                        (UI_To_Int (DT_Position (Prim))))\n-               then\n-                  while Present (Alias (Prim)) loop\n-                     Prim := Alias (Prim);\n-                  end loop;\n+                  if Is_Predefined_Dispatching_Operation (Prim)\n+                    and then not Is_Abstract_Subprogram (Prim)\n+                    and then not Present (Prim_Table\n+                                           (UI_To_Int (DT_Position (Prim))))\n+                  then\n+                     if not Build_Thunks then\n+                        Prim_Table (UI_To_Int (DT_Position (Prim))) :=\n+                          Alias (Prim);\n \n-                  Expand_Interface_Thunk (Prim, Thunk_Id, Thunk_Code);\n+                     else\n+                        while Present (Alias (Prim)) loop\n+                           Prim := Alias (Prim);\n+                        end loop;\n+\n+                        Expand_Interface_Thunk (Prim, Thunk_Id, Thunk_Code);\n \n-                  if Present (Thunk_Id) then\n-                     Append_To (Result, Thunk_Code);\n-                     Prim_Table (UI_To_Int (DT_Position (Prim))) := Thunk_Id;\n+                        if Present (Thunk_Id) then\n+                           Append_To (Result, Thunk_Code);\n+                           Prim_Table (UI_To_Int (DT_Position (Prim)))\n+                             := Thunk_Id;\n+                        end if;\n+                     end if;\n                   end if;\n-               end if;\n \n-               Next_Elmt (Prim_Elmt);\n-            end loop;\n+                  Next_Elmt (Prim_Elmt);\n+               end loop;\n+            end if;\n \n             for J in Prim_Table'Range loop\n                if Present (Prim_Table (J)) then\n@@ -2761,6 +3269,7 @@ package body Exp_Disp is\n            or else Restriction_Active (No_Dispatching_Calls)\n            or else not Is_Limited_Type (Typ)\n            or else not Has_Abstract_Interfaces (Typ)\n+           or else not Build_Thunks\n          then\n             --  No OSD table required\n \n@@ -2917,15 +3426,22 @@ package body Exp_Disp is\n \n                     and then not Is_Parent (Iface, Typ)\n                   then\n-                     Expand_Interface_Thunk (Prim, Thunk_Id, Thunk_Code);\n-\n-                     if Present (Thunk_Id) then\n+                     if not Build_Thunks then\n                         Pos :=\n                           UI_To_Int\n                             (DT_Position (Abstract_Interface_Alias (Prim)));\n+                        Prim_Table (Pos) := Alias (Prim);\n+                     else\n+                        Expand_Interface_Thunk (Prim, Thunk_Id, Thunk_Code);\n \n-                        Prim_Table (Pos) := Thunk_Id;\n-                        Append_To (Result, Thunk_Code);\n+                        if Present (Thunk_Id) then\n+                           Pos :=\n+                             UI_To_Int\n+                               (DT_Position (Abstract_Interface_Alias (Prim)));\n+\n+                           Prim_Table (Pos) := Thunk_Id;\n+                           Append_To (Result, Thunk_Code);\n+                        end if;\n                      end if;\n                   end if;\n \n@@ -3005,7 +3521,7 @@ package body Exp_Disp is\n       Result             : constant List_Id   := New_List;\n       Tname              : constant Name_Id   := Chars (Typ);\n       AI                 : Elmt_Id;\n-      AI_Ptr_Elmt        : Elmt_Id;\n+      AI_Tag_Elmt        : Elmt_Id;\n       AI_Tag_Comp        : Elmt_Id;\n       DT_Aggr_List       : List_Id;\n       DT_Constr_List     : List_Id;\n@@ -3102,11 +3618,11 @@ package body Exp_Disp is\n       end if;\n \n       --  Ensure that the value of Max_Predef_Prims defined in a-tags is\n-      --  correct. Valid values are 10 under configurable runtime or 15\n+      --  correct. Valid values are 10 under configurable runtime or 16\n       --  with full runtime.\n \n       if RTE_Available (RE_Interface_Data) then\n-         if Max_Predef_Prims /= 15 then\n+         if Max_Predef_Prims /= 16 then\n             Error_Msg_N (\"run-time library configuration error\", Typ);\n             return Result;\n          end if;\n@@ -3170,20 +3686,37 @@ package body Exp_Disp is\n          Collect_Interface_Components (Typ, Typ_Comps);\n \n          Suffix_Index := 0;\n-         AI_Ptr_Elmt  := Next_Elmt (First_Elmt (Access_Disp_Table (Typ)));\n+         AI_Tag_Elmt  := Next_Elmt (First_Elmt (Access_Disp_Table (Typ)));\n \n          AI_Tag_Comp := First_Elmt (Typ_Comps);\n          while Present (AI_Tag_Comp) loop\n+\n+            --  Build the secondary table containing pointers to thunks\n+\n             Make_Secondary_DT\n-              (Typ          => Typ,\n-               Iface        => Base_Type\n-                                 (Related_Interface (Node (AI_Tag_Comp))),\n-               AI_Tag       => Node (AI_Tag_Comp),\n-               Iface_DT_Ptr => Node (AI_Ptr_Elmt),\n-               Result       => Result);\n+             (Typ             => Typ,\n+              Iface           => Base_Type (Related_Type (Node (AI_Tag_Comp))),\n+              Num_Iface_Prims => UI_To_Int\n+                                   (DT_Entry_Count (Node (AI_Tag_Comp))),\n+              Iface_DT_Ptr    => Node (AI_Tag_Elmt),\n+              Build_Thunks    => True,\n+              Result          => Result);\n+            Next_Elmt (AI_Tag_Elmt);\n+\n+            --  Build the secondary table contaning pointers to primitives\n+            --  (used to give support to Generic Dispatching Constructors).\n+\n+            Make_Secondary_DT\n+             (Typ             => Typ,\n+              Iface           => Base_Type (Related_Type (Node (AI_Tag_Comp))),\n+              Num_Iface_Prims =>  UI_To_Int\n+                                   (DT_Entry_Count (Node (AI_Tag_Comp))),\n+              Iface_DT_Ptr    => Node (AI_Tag_Elmt),\n+              Build_Thunks    => False,\n+              Result          => Result);\n+            Next_Elmt (AI_Tag_Elmt);\n \n             Suffix_Index := Suffix_Index + 1;\n-            Next_Elmt (AI_Ptr_Elmt);\n             Next_Elmt (AI_Tag_Comp);\n          end loop;\n       end if;\n@@ -3203,19 +3736,17 @@ package body Exp_Disp is\n       --  order to avoid multiple registrations for tagged types defined in\n       --  multiple-called scopes.\n \n-      if not Is_Interface (Typ) then\n-         Name_No_Reg := New_External_Name (Tname, 'F', Suffix_Index => -1);\n-         No_Reg      := Make_Defining_Identifier (Loc, Name_No_Reg);\n+      Name_No_Reg := New_External_Name (Tname, 'F', Suffix_Index => -1);\n+      No_Reg      := Make_Defining_Identifier (Loc, Name_No_Reg);\n \n-         Set_Ekind (No_Reg, E_Variable);\n-         Set_Is_Statically_Allocated (No_Reg);\n+      Set_Ekind (No_Reg, E_Variable);\n+      Set_Is_Statically_Allocated (No_Reg);\n \n-         Append_To (Result,\n-           Make_Object_Declaration (Loc,\n-             Defining_Identifier => No_Reg,\n-             Object_Definition   => New_Reference_To (Standard_Boolean, Loc),\n-             Expression          => New_Reference_To (Standard_True, Loc)));\n-      end if;\n+      Append_To (Result,\n+         Make_Object_Declaration (Loc,\n+           Defining_Identifier => No_Reg,\n+           Object_Definition   => New_Reference_To (Standard_Boolean, Loc),\n+           Expression          => New_Reference_To (Standard_True, Loc)));\n \n       --  In case of locally defined tagged type we declare the object\n       --  contanining the dispatch table by means of a variable. Its\n@@ -3634,13 +4165,20 @@ package body Exp_Disp is\n \n       declare\n          RC_Offset_Node : Node_Id;\n+         Parent_Typ     : Entity_Id;\n \n       begin\n+         if Present (Full_View (Etype (Typ))) then\n+            Parent_Typ := Full_View (Etype (Typ));\n+         else\n+            Parent_Typ := Etype (Typ);\n+         end if;\n+\n          if not Has_Controlled_Component (Typ) then\n             RC_Offset_Node := Make_Integer_Literal (Loc, 0);\n \n          elsif Etype (Typ) /= Typ\n-           and then Has_Discriminants (Etype (Typ))\n+           and then Has_Discriminants (Parent_Typ)\n          then\n             if Has_New_Controlled_Component (Typ) then\n                RC_Offset_Node := Make_Integer_Literal (Loc, -1);\n@@ -3697,10 +4235,35 @@ package body Exp_Disp is\n          else\n             declare\n                TSD_Ifaces_List : constant List_Id := New_List;\n+               Elmt       : Elmt_Id;\n+               Sec_DT_Tag : Node_Id;\n \n             begin\n                AI := First_Elmt (Typ_Ifaces);\n                while Present (AI) loop\n+                  if Is_Parent (Node (AI), Typ) then\n+                     Sec_DT_Tag :=\n+                       New_Reference_To (DT_Ptr, Loc);\n+                  else\n+                     Elmt := Next_Elmt (First_Elmt (Access_Disp_Table (Typ)));\n+                     pragma Assert (Has_Thunks (Node (Elmt)));\n+\n+                     while Ekind (Node (Elmt)) = E_Constant\n+                        and then not\n+                          Is_Parent (Node (AI), Related_Type (Node (Elmt)))\n+                     loop\n+                        pragma Assert (Has_Thunks (Node (Elmt)));\n+                        Next_Elmt (Elmt);\n+                        pragma Assert (not Has_Thunks (Node (Elmt)));\n+                        Next_Elmt (Elmt);\n+                     end loop;\n+\n+                     pragma Assert (Ekind (Node (Elmt)) = E_Constant\n+                       and then not Has_Thunks (Node (Next_Elmt (Elmt))));\n+                     Sec_DT_Tag :=\n+                       New_Reference_To (Node (Next_Elmt (Elmt)), Loc);\n+                  end if;\n+\n                   Append_To (TSD_Ifaces_List,\n                      Make_Aggregate (Loc,\n                        Expressions => New_List (\n@@ -3722,7 +4285,13 @@ package body Exp_Disp is\n \n                         --  Offset_To_Top_Func\n \n-                        Make_Null (Loc))));\n+                        Make_Null (Loc),\n+\n+                        --  Secondary_DT\n+\n+                        Unchecked_Convert_To (RTE (RE_Tag), Sec_DT_Tag)\n+\n+                        )));\n \n                   Next_Elmt (AI);\n                end loop;\n@@ -3848,7 +4417,7 @@ package body Exp_Disp is\n               Unchecked_Convert_To (RTE (RE_Tag),\n                 New_Reference_To (RTE (RE_Null_Address), Loc)));\n \n-         --  Otherwise we can safely reference the tag.\n+         --  Otherwise we can safely reference the tag\n \n          else\n             Append_To (TSD_Tags_List,\n@@ -4050,27 +4619,28 @@ package body Exp_Disp is\n \n                Prim_Table := (others => Empty);\n \n-               Prim_Elmt  := First_Elmt (Primitive_Operations (Typ));\n-               while Present (Prim_Elmt) loop\n-                  Prim := Node (Prim_Elmt);\n+               if Building_Static_DT (Typ) then\n+                  Prim_Elmt  := First_Elmt (Primitive_Operations (Typ));\n+                  while Present (Prim_Elmt) loop\n+                     Prim := Node (Prim_Elmt);\n \n-                  if Building_Static_DT (Typ)\n-                    and then Is_Predefined_Dispatching_Operation (Prim)\n-                    and then not Is_Abstract_Subprogram (Prim)\n-                    and then not Present (Prim_Table\n-                                           (UI_To_Int (DT_Position (Prim))))\n-                  then\n-                     E := Prim;\n-                     while Present (Alias (E)) loop\n-                        E := Alias (E);\n-                     end loop;\n+                     if Is_Predefined_Dispatching_Operation (Prim)\n+                       and then not Is_Abstract_Subprogram (Prim)\n+                       and then not Present (Prim_Table\n+                                              (UI_To_Int (DT_Position (Prim))))\n+                     then\n+                        E := Prim;\n+                        while Present (Alias (E)) loop\n+                           E := Alias (E);\n+                        end loop;\n \n-                     pragma Assert (not Is_Abstract_Subprogram (E));\n-                     Prim_Table (UI_To_Int (DT_Position (Prim))) := E;\n-                  end if;\n+                        pragma Assert (not Is_Abstract_Subprogram (E));\n+                        Prim_Table (UI_To_Int (DT_Position (Prim))) := E;\n+                     end if;\n \n-                  Next_Elmt (Prim_Elmt);\n-               end loop;\n+                     Next_Elmt (Prim_Elmt);\n+                  end loop;\n+               end if;\n \n                for J in Prim_Table'Range loop\n                   if Present (Prim_Table (J)) then\n@@ -4180,7 +4750,8 @@ package body Exp_Disp is\n \n             begin\n                Prim_Table := (others => Empty);\n-               Prim_Elmt  := First_Elmt (Primitive_Operations (Typ));\n+\n+               Prim_Elmt := First_Elmt (Primitive_Operations (Typ));\n                while Present (Prim_Elmt) loop\n                   Prim := Node (Prim_Elmt);\n \n@@ -4414,14 +4985,52 @@ package body Exp_Disp is\n                           and then Ekind (Node (Sec_DT_Ancestor)) = E_Constant\n                         loop\n                            if Is_Tag (E) and then Chars (E) /= Name_uTag then\n-                              if not Is_Interface (Etype (Typ)) then\n+                              declare\n+                                 Num_Prims : constant Int :=\n+                                               UI_To_Int (DT_Entry_Count (E));\n+\n+                              begin\n+                                 if not Is_Interface (Etype (Typ)) then\n+\n+                                    --  Inherit first secondary dispatch table\n+\n+                                    Append_To (Elab_Code,\n+                                      Build_Inherit_Predefined_Prims (Loc,\n+                                        Old_Tag_Node =>\n+                                          Unchecked_Convert_To (RTE (RE_Tag),\n+                                             New_Reference_To\n+                                               (Node (Sec_DT_Ancestor), Loc)),\n+                                        New_Tag_Node =>\n+                                          Unchecked_Convert_To (RTE (RE_Tag),\n+                                            New_Reference_To\n+                                              (Node (Sec_DT_Typ), Loc))));\n+\n+                                    if Num_Prims /= 0 then\n+                                       Append_To (Elab_Code,\n+                                         Build_Inherit_Prims (Loc,\n+                                           Typ          => Node (Iface),\n+                                           Old_Tag_Node =>\n+                                             Unchecked_Convert_To\n+                                               (RTE (RE_Tag),\n+                                                New_Reference_To\n+                                                  (Node (Sec_DT_Ancestor),\n+                                                   Loc)),\n+                                           New_Tag_Node =>\n+                                             Unchecked_Convert_To\n+                                              (RTE (RE_Tag),\n+                                               New_Reference_To\n+                                                 (Node (Sec_DT_Typ), Loc)),\n+                                           Num_Prims    => Num_Prims));\n+                                    end if;\n+                                 end if;\n+\n+                                 Next_Elmt (Sec_DT_Ancestor);\n+                                 Next_Elmt (Sec_DT_Typ);\n \n-                                 --  Inherit the dispatch table\n+                                 if not Is_Interface (Etype (Typ)) then\n+\n+                                    --  Inherit second secondary dispatch table\n \n-                                 declare\n-                                    Num_Prims : constant Int :=\n-                                                UI_To_Int (DT_Entry_Count (E));\n-                                 begin\n                                     Append_To (Elab_Code,\n                                       Build_Inherit_Predefined_Prims (Loc,\n                                         Old_Tag_Node =>\n@@ -4450,8 +5059,8 @@ package body Exp_Disp is\n                                                  (Node (Sec_DT_Typ), Loc)),\n                                            Num_Prims    => Num_Prims));\n                                     end if;\n-                                 end;\n-                              end if;\n+                                 end if;\n+                              end;\n \n                               Next_Elmt (Sec_DT_Ancestor);\n                               Next_Elmt (Sec_DT_Typ);\n@@ -4501,29 +5110,27 @@ package body Exp_Disp is\n       --        No_Reg := False;\n       --     end if;\n \n-      if not Is_Interface (Typ) then\n-         if not No_Run_Time_Mode\n-           and then Is_Library_Level_Entity (Typ)\n-           and then RTE_Available (RE_Register_Tag)\n-         then\n-            Append_To (Elab_Code,\n-              Make_Procedure_Call_Statement (Loc,\n-                Name => New_Reference_To (RTE (RE_Register_Tag), Loc),\n-                Parameter_Associations =>\n-                  New_List (New_Reference_To (DT_Ptr, Loc))));\n-         end if;\n-\n+      if not No_Run_Time_Mode\n+        and then Is_Library_Level_Entity (Typ)\n+        and then RTE_Available (RE_Register_Tag)\n+      then\n          Append_To (Elab_Code,\n-           Make_Assignment_Statement (Loc,\n-             Name       => New_Reference_To (No_Reg, Loc),\n-             Expression => New_Reference_To (Standard_False, Loc)));\n-\n-         Append_To (Result,\n-           Make_Implicit_If_Statement (Typ,\n-             Condition       => New_Reference_To (No_Reg, Loc),\n-             Then_Statements => Elab_Code));\n+           Make_Procedure_Call_Statement (Loc,\n+             Name => New_Reference_To (RTE (RE_Register_Tag), Loc),\n+             Parameter_Associations =>\n+               New_List (New_Reference_To (DT_Ptr, Loc))));\n       end if;\n \n+      Append_To (Elab_Code,\n+        Make_Assignment_Statement (Loc,\n+          Name       => New_Reference_To (No_Reg, Loc),\n+          Expression => New_Reference_To (Standard_False, Loc)));\n+\n+      Append_To (Result,\n+        Make_Implicit_If_Statement (Typ,\n+          Condition       => New_Reference_To (No_Reg, Loc),\n+          Then_Statements => Elab_Code));\n+\n       --  Populate the two auxiliary tables used for dispatching\n       --  asynchronous, conditional and timed selects for synchronized\n       --  types that implement a limited interface.\n@@ -4860,18 +5467,33 @@ package body Exp_Disp is\n          AI_Tag_Comp := First_Elmt (Typ_Comps);\n          while Present (AI_Tag_Comp) loop\n             Get_Secondary_DT_External_Name\n-              (Typ, Related_Interface (Node (AI_Tag_Comp)), Suffix_Index);\n+              (Typ, Related_Type (Node (AI_Tag_Comp)), Suffix_Index);\n+\n+            Typ_Name := Name_Find;\n \n-            Typ_Name     := Name_Find;\n             Iface_DT_Ptr :=\n               Make_Defining_Identifier (Loc,\n                 Chars => New_External_Name (Typ_Name, 'P'));\n             Set_Etype (Iface_DT_Ptr, RTE (RE_Interface_Tag));\n             Set_Ekind (Iface_DT_Ptr, E_Constant);\n+            Set_Is_Tag (Iface_DT_Ptr);\n+            Set_Has_Thunks (Iface_DT_Ptr);\n             Set_Is_Statically_Allocated (Iface_DT_Ptr);\n             Set_Is_True_Constant (Iface_DT_Ptr);\n-            Set_Related_Interface\n-              (Iface_DT_Ptr, Related_Interface (Node (AI_Tag_Comp)));\n+            Set_Related_Type\n+              (Iface_DT_Ptr, Related_Type (Node (AI_Tag_Comp)));\n+            Append_Elmt (Iface_DT_Ptr, Access_Disp_Table (Typ));\n+\n+            Iface_DT_Ptr :=\n+              Make_Defining_Identifier (Loc,\n+                Chars => New_External_Name (Typ_Name, 'D'));\n+            Set_Etype (Iface_DT_Ptr, RTE (RE_Interface_Tag));\n+            Set_Ekind (Iface_DT_Ptr, E_Constant);\n+            Set_Is_Tag (Iface_DT_Ptr);\n+            Set_Is_Statically_Allocated (Iface_DT_Ptr);\n+            Set_Is_True_Constant (Iface_DT_Ptr);\n+            Set_Related_Type\n+              (Iface_DT_Ptr, Related_Type (Node (AI_Tag_Comp)));\n             Append_Elmt (Iface_DT_Ptr, Access_Disp_Table (Typ));\n \n             Next_Elmt (AI_Tag_Comp);\n@@ -4932,6 +5554,10 @@ package body Exp_Disp is\n          Set_Suppress_Init_Proc (Base_Type (DT_Prims));\n       end;\n \n+      Set_Ekind        (DT_Ptr, E_Constant);\n+      Set_Is_Tag       (DT_Ptr);\n+      Set_Related_Type (DT_Ptr, Typ);\n+\n       return Result;\n    end Make_Tags;\n \n@@ -5057,15 +5683,17 @@ package body Exp_Disp is\n       Prim    : Entity_Id;\n       Ins_Nod : Node_Id)\n    is\n-      DT_Ptr       : Entity_Id;\n-      Iface_Prim   : Entity_Id;\n-      Iface_Typ    : Entity_Id;\n-      Iface_DT_Ptr : Entity_Id;\n-      Pos          : Uint;\n-      Tag          : Entity_Id;\n-      Thunk_Id     : Entity_Id;\n-      Thunk_Code   : Node_Id;\n-      Typ          : Entity_Id;\n+      DT_Ptr        : Entity_Id;\n+      Iface_Prim    : Entity_Id;\n+      Iface_Typ     : Entity_Id;\n+      Iface_DT_Ptr  : Entity_Id;\n+      Iface_DT_Elmt : Elmt_Id;\n+      L             : List_Id;\n+      Pos           : Uint;\n+      Tag           : Entity_Id;\n+      Thunk_Id      : Entity_Id;\n+      Thunk_Code    : Node_Id;\n+      Typ           : Entity_Id;\n \n    begin\n       pragma Assert (not Restriction_Active (No_Dispatching_Calls));\n@@ -5131,35 +5759,71 @@ package body Exp_Disp is\n             --  the secondary dispatch table of Prim's controlling type with\n             --  Thunk_Id's address.\n \n-            Iface_DT_Ptr := Find_Interface_ADT (Typ, Iface_Typ);\n-            Iface_Prim   := Abstract_Interface_Alias (Prim);\n-            Pos          := DT_Position (Iface_Prim);\n-            Tag          := First_Tag_Component (Iface_Typ);\n+            Iface_DT_Elmt := Find_Interface_ADT (Typ, Iface_Typ);\n+            Iface_DT_Ptr  := Node (Iface_DT_Elmt);\n+            pragma Assert (Has_Thunks (Iface_DT_Ptr));\n+\n+            Iface_Prim    := Abstract_Interface_Alias (Prim);\n+            Pos           := DT_Position (Iface_Prim);\n+            Tag           := First_Tag_Component (Iface_Typ);\n+            L             := New_List;\n \n             if Is_Predefined_Dispatching_Operation (Prim)\n               or else Is_Predefined_Dispatching_Alias (Prim)\n             then\n-               Insert_Action (Ins_Nod,\n+               Append_To (L,\n                  Build_Set_Predefined_Prim_Op_Address (Loc,\n                    Tag_Node => New_Reference_To (Iface_DT_Ptr, Loc),\n                    Position => Pos,\n                    Address_Node =>\n                      Make_Attribute_Reference (Loc,\n                        Prefix          => New_Reference_To (Thunk_Id, Loc),\n                        Attribute_Name  => Name_Address)));\n+\n+               Next_Elmt (Iface_DT_Elmt);\n+               Iface_DT_Ptr := Node (Iface_DT_Elmt);\n+               pragma Assert (not Has_Thunks (Iface_DT_Ptr));\n+\n+               Append_To (L,\n+                 Build_Set_Predefined_Prim_Op_Address (Loc,\n+                   Tag_Node => New_Reference_To (Iface_DT_Ptr, Loc),\n+                   Position => Pos,\n+                   Address_Node =>\n+                     Make_Attribute_Reference (Loc,\n+                       Prefix          => New_Reference_To (Alias (Prim), Loc),\n+                       Attribute_Name  => Name_Address)));\n+\n+               Insert_Actions_After (Ins_Nod, L);\n+\n             else\n                pragma Assert (Pos /= Uint_0\n                  and then Pos <= DT_Entry_Count (Tag));\n \n-               Insert_Action (Ins_Nod,\n+               Append_To (L,\n+                 Build_Set_Prim_Op_Address (Loc,\n+                   Typ          => Iface_Typ,\n+                   Tag_Node     => New_Reference_To (Iface_DT_Ptr, Loc),\n+                   Position     => Pos,\n+                   Address_Node => Make_Attribute_Reference (Loc,\n+                                     Prefix =>\n+                                       New_Reference_To (Thunk_Id, Loc),\n+                                     Attribute_Name => Name_Address)));\n+\n+               Next_Elmt (Iface_DT_Elmt);\n+               Iface_DT_Ptr := Node (Iface_DT_Elmt);\n+               pragma Assert (not Has_Thunks (Iface_DT_Ptr));\n+\n+               Append_To (L,\n                  Build_Set_Prim_Op_Address (Loc,\n                    Typ          => Iface_Typ,\n                    Tag_Node     => New_Reference_To (Iface_DT_Ptr, Loc),\n                    Position     => Pos,\n                    Address_Node => Make_Attribute_Reference (Loc,\n                                      Prefix =>\n-                                        New_Reference_To (Thunk_Id, Loc),\n+                                       New_Reference_To (Alias (Prim), Loc),\n                                      Attribute_Name => Name_Address)));\n+\n+               Insert_Actions_After (Ins_Nod, L);\n             end if;\n          end if;\n       end if;"}, {"sha": "5bf2b6c30a497f7dbb91a09cd805cffebefe558e", "filename": "gcc/ada/exp_disp.ads", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80b992aecd2dbd7c9fb80807016b26af334588ec/gcc%2Fada%2Fexp_disp.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80b992aecd2dbd7c9fb80807016b26af334588ec/gcc%2Fada%2Fexp_disp.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_disp.ads?ref=80b992aecd2dbd7c9fb80807016b26af334588ec", "patch": "@@ -104,7 +104,13 @@ package Exp_Disp is\n    --      of the cases. See Expand_N_Attribute_Reference in Exp_Attr and\n    --      Expand_N_Abort_Statement in Exp_Ch9 for more information.\n \n-   --      _Disp_Timed_Select (15) - used in the expansion of timed selects\n+   --      _Disp_Requeue (15) - used in the expansion of dispatching requeue\n+   --      statements. Null implementation is provided for protected, task\n+   --      and synchronized interfaces. Protected and task types implementing\n+   --      concurrent interfaces receive full bodies. See Expand_N_Requeue_\n+   --      Statement in Exp_Ch9 for more information.\n+\n+   --      _Disp_Timed_Select (16) - used in the expansion of timed selects\n    --      with dispatching triggers. Null implementation for limited\n    --      interfaces, full body generation for types that implement limited\n    --      interfaces, not generated for the rest of the cases. See Expand_N_\n@@ -258,10 +264,21 @@ package Exp_Disp is\n    --  of type Typ used for retrieving the _task_id field of a task interface\n    --  class-wide type.\n \n+   function Make_Disp_Requeue_Body\n+     (Typ : Entity_Id) return Node_Id;\n+   --  Ada 2005 (AI05-0030): Generate the body of the primitive operation of\n+   --  type Typ used for dispatching on requeue statements. Generate a body\n+   --  containing a single null-statement if Typ is an interface type.\n+\n+   function Make_Disp_Requeue_Spec\n+     (Typ : Entity_Id) return Node_Id;\n+   --  Ada 2005 (AI05-0030): Generate the specification of the primitive\n+   --  operation of type Typ used for dispatching requeue statements.\n+\n    function Make_Disp_Timed_Select_Body\n      (Typ : Entity_Id) return Node_Id;\n    --  Ada 2005 (AI-345): Generate the body of the primitive operation of type\n-   --  Typ used for dispatching in timed selects. Generates a body containing\n+   --  Typ used for dispatching in timed selects. Generate a body containing\n    --  a single null-statement if Typ is an interface type.\n \n    function Make_Disp_Timed_Select_Spec"}]}