{"sha": "f395cd861ea86fd426bc1df24cdbe676afebf416", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjM5NWNkODYxZWE4NmZkNDI2YmMxZGYyNGNkYmU2NzZhZmViZjQxNg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1996-01-14T22:57:47Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1996-01-14T22:57:47Z"}, "message": "(stupid_find_reg): Don't try to allocate reg if live over more than\n5,000 insns.\n\nFrom-SVN: r10974", "tree": {"sha": "037cc299a266ede119f93aaf51d95adeb7cb31fa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/037cc299a266ede119f93aaf51d95adeb7cb31fa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f395cd861ea86fd426bc1df24cdbe676afebf416", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f395cd861ea86fd426bc1df24cdbe676afebf416", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f395cd861ea86fd426bc1df24cdbe676afebf416", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f395cd861ea86fd426bc1df24cdbe676afebf416/comments", "author": null, "committer": null, "parents": [{"sha": "981e5cd9408eb6e1335def717fe5b270c1fa034f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/981e5cd9408eb6e1335def717fe5b270c1fa034f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/981e5cd9408eb6e1335def717fe5b270c1fa034f"}], "stats": {"total": 13, "additions": 10, "deletions": 3}, "files": [{"sha": "6034b818fba7a7eb6011c1ba7bd7870a76933071", "filename": "gcc/stupid.c", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f395cd861ea86fd426bc1df24cdbe676afebf416/gcc%2Fstupid.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f395cd861ea86fd426bc1df24cdbe676afebf416/gcc%2Fstupid.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstupid.c?ref=f395cd861ea86fd426bc1df24cdbe676afebf416", "patch": "@@ -1,5 +1,5 @@\n /* Dummy data flow analysis for GNU compiler in nonoptimizing mode.\n-   Copyright (C) 1987, 1991, 1994, 1995 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 1991, 1994, 1995, 1996 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -308,8 +308,8 @@ stupid_reg_compare (r1p, r2p)\n /* Find a block of SIZE words of hard registers in reg_class CLASS\n    that can hold a value of machine-mode MODE\n      (but actually we test only the first of the block for holding MODE)\n-   currently free from after insn whose suid is BIRTH\n-   through the insn whose suid is DEATH,\n+   currently free from after insn whose suid is BORN_INSN\n+   through the insn whose suid is DEAD_INSN,\n    and return the number of the first of them.\n    Return -1 if such a block cannot be found.\n \n@@ -337,6 +337,13 @@ stupid_find_reg (call_preserved, class, mode,\n   static struct {int from, to; } eliminables[] = ELIMINABLE_REGS;\n #endif\n \n+  /* If this register's life is more than 5,000 insns, we probably\n+     can't allocate it, so don't waste the time trying.  This avoid\n+     quadratic behavior on programs that have regularly-occurring\n+     SAVE_EXPRs.  */\n+  if (dead_insn > born_insn + 5000)\n+    return -1;\n+\n   COPY_HARD_REG_SET (used,\n \t\t     call_preserved ? call_used_reg_set : fixed_reg_set);\n "}]}