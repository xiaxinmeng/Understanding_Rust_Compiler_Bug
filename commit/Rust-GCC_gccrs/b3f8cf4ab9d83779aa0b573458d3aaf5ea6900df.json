{"sha": "b3f8cf4ab9d83779aa0b573458d3aaf5ea6900df", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjNmOGNmNGFiOWQ4Mzc3OWFhMGI1NzM0NThkM2FhZjVlYTY5MDBkZg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-05-06T21:47:35Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-05-06T21:47:35Z"}, "message": "(use_regs, expand_builtin_apply): Change from USE and CLOBBER insns to\nusing CALL_INSN_FUNCTION_USAGE.\n\nFrom-SVN: r7240", "tree": {"sha": "e13b0a161d9e44ccdddb87d70ebcc9da4a0e3e81", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e13b0a161d9e44ccdddb87d70ebcc9da4a0e3e81"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b3f8cf4ab9d83779aa0b573458d3aaf5ea6900df", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3f8cf4ab9d83779aa0b573458d3aaf5ea6900df", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b3f8cf4ab9d83779aa0b573458d3aaf5ea6900df", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3f8cf4ab9d83779aa0b573458d3aaf5ea6900df/comments", "author": null, "committer": null, "parents": [{"sha": "77cac2f260a945339303f8e439c1c545b2d22f24", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/77cac2f260a945339303f8e439c1c545b2d22f24", "html_url": "https://github.com/Rust-GCC/gccrs/commit/77cac2f260a945339303f8e439c1c545b2d22f24"}], "stats": {"total": 63, "additions": 39, "deletions": 24}, "files": [{"sha": "2d31f9eeb800083e719d5b796b3cca7e474734ba", "filename": "gcc/expr.c", "status": "modified", "additions": 39, "deletions": 24, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3f8cf4ab9d83779aa0b573458d3aaf5ea6900df/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3f8cf4ab9d83779aa0b573458d3aaf5ea6900df/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=b3f8cf4ab9d83779aa0b573458d3aaf5ea6900df", "patch": "@@ -1662,17 +1662,40 @@ move_block_from_reg (regno, x, nregs, size)\n     }\n }\n \n-/* Mark NREGS consecutive regs, starting at REGNO, as being live now.  */\n+/* Mark REG as holding parameter for the CALL_INSN.  */\n \n void\n-use_regs (regno, nregs)\n+use_reg (call_fusage, reg)\n+     rtx *call_fusage, reg;\n+{\n+  if (GET_CODE (reg) == REG\n+      && REGNO (reg) >= FIRST_PSEUDO_REGISTER)\n+    abort();\n+\n+  *call_fusage\n+    = gen_rtx (EXPR_LIST, VOIDmode,\n+               gen_rtx (USE, reg_raw_mode[REGNO (reg)], reg), *call_fusage);\n+\n+}\n+\n+/* Mark NREGS consecutive regs, starting at REGNO, as holding parameters\n+   for the CALL_INSN.  */\n+\n+void\n+use_regs (call_fusage, reg, regno, nregs)\n+     rtx *call_fusage, reg;\n      int regno;\n      int nregs;\n {\n-  int i;\n+  if (nregs <= 1 && reg)\n+    use_reg (call_fusage, reg);\n+  else\n+   {\n+     int i;\n \n-  for (i = 0; i < nregs; i++)\n-    emit_insn (gen_rtx (USE, VOIDmode, gen_rtx (REG, reg_raw_mode[regno + i], regno + i)));\n+     for (i = 0; i < nregs; i++)\n+        use_reg (call_fusage, gen_rtx (REG, word_mode, regno + i));\n+   }\n }\n \f\n /* Write zeros through the storage of OBJECT.\n@@ -7663,7 +7686,7 @@ expand_builtin_apply (function, arguments, argsize)\n   enum machine_mode mode;\n   rtx incoming_args, result, reg, dest, call_insn;\n   rtx old_stack_level = 0;\n-  rtx use_insns = 0;\n+  rtx call_fusage = 0;\n \n   /* Create a block where the return registers can be saved.  */\n   result = assign_stack_local (BLKmode, apply_result_size (), -1);\n@@ -7720,10 +7743,7 @@ expand_builtin_apply (function, arguments, argsize)\n \t\t\t\t\tplus_constant (XEXP (arguments, 0),\n \t\t\t\t\t\t       size)));\n \n-\tpush_to_sequence (use_insns);\n-\temit_insn (gen_rtx (USE, VOIDmode, reg));\n-\tuse_insns = get_insns ();\n-\tend_sequence ();\n+\tuse_reg (&call_fusage, reg);\n \tsize += GET_MODE_SIZE (mode);\n       }\n \n@@ -7739,17 +7759,12 @@ expand_builtin_apply (function, arguments, argsize)\n \t\t\t\t\t\t     size)));\n       emit_move_insn (struct_value_rtx, value);\n       if (GET_CODE (struct_value_rtx) == REG)\n-\t{\n-\t  push_to_sequence (use_insns);\n-\t  emit_insn (gen_rtx (USE, VOIDmode, struct_value_rtx));\n-\t  use_insns = get_insns ();\n-\t  end_sequence ();\n-\t}\n+\t  use_reg (&call_fusage, struct_value_rtx);\n       size += GET_MODE_SIZE (Pmode);\n     }\n \n   /* All arguments and registers used for the call are set up by now!  */\n-  function = prepare_call_address (function, NULL_TREE, &use_insns, 0);\n+  function = prepare_call_address (function, NULL_TREE, &call_fusage, 0);\n \n   /* Ensure address is valid.  SYMBOL_REF is already valid, so no need,\n      and we don't want to load it into a register as an optimization,\n@@ -7793,7 +7808,7 @@ expand_builtin_apply (function, arguments, argsize)\n #endif\n     abort ();\n \n-  /* Find the CALL insn we just emitted and write the USE insns before it.  */\n+  /* Find the CALL insn we just emitted.  */\n   for (call_insn = get_last_insn ();\n        call_insn && GET_CODE (call_insn) != CALL_INSN;\n        call_insn = PREV_INSN (call_insn))\n@@ -7802,8 +7817,8 @@ expand_builtin_apply (function, arguments, argsize)\n   if (! call_insn)\n     abort ();\n \n-  /* Put the USE insns before the CALL.  */\n-  emit_insns_before (use_insns, call_insn);\n+  /* Put the register usage information on the CALL.  */\n+  CALL_INSN_FUNCTION_USAGE (call_insn) = call_fusage;\n \n   /* Restore the stack.  */\n   emit_stack_restore (SAVE_BLOCK, old_stack_level, NULL_RTX);\n@@ -7821,7 +7836,7 @@ expand_builtin_return (result)\n   int size, align, regno;\n   enum machine_mode mode;\n   rtx reg;\n-  rtx use_insns = 0;\n+  rtx call_fusage = 0;\n \n   apply_result_size ();\n   result = gen_rtx (MEM, BLKmode, result);\n@@ -7849,15 +7864,15 @@ expand_builtin_return (result)\n \t\t\t\t\tplus_constant (XEXP (result, 0),\n \t\t\t\t\t\t       size)));\n \n-\tpush_to_sequence (use_insns);\n+\tpush_to_sequence (call_fusage);\n \temit_insn (gen_rtx (USE, VOIDmode, reg));\n-\tuse_insns = get_insns ();\n+\tcall_fusage = get_insns ();\n \tend_sequence ();\n \tsize += GET_MODE_SIZE (mode);\n       }\n \n   /* Put the USE insns before the return.  */\n-  emit_insns (use_insns);\n+  emit_insns (call_fusage);\n \n   /* Return whatever values was restored by jumping directly to the end\n      of the function.  */"}]}