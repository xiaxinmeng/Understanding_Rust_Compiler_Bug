{"sha": "10169a8b991800c73cbe6dbfdcf7761aac3e542c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTAxNjlhOGI5OTE4MDBjNzNjYmU2ZGJmZGNmNzc2MWFhYzNlNTQyYw==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2015-07-05T07:58:30Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2015-07-05T07:58:30Z"}, "message": "gcc/\n\t* target-insns.def (allocate_stack, check_stack, probe_stack)\n\t(probe_stack_address, split_stack_prologue, split_stack_space_check):\n\tNew targetm instruction patterns.\n\t* explow.c (allocate_dynamic_stack_space): Use them instead of\n\tHAVE_*/gen_* interface.\n\t(emit_stack_probe): Likewise.\n\t(probe_stack_range): Likewise.\n\t* function.c (thread_prologue_and_epilogue_insns): Likewise.\n\nFrom-SVN: r225429", "tree": {"sha": "91da425debea07ccf8622f69ae68e2e211042c83", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/91da425debea07ccf8622f69ae68e2e211042c83"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/10169a8b991800c73cbe6dbfdcf7761aac3e542c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10169a8b991800c73cbe6dbfdcf7761aac3e542c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/10169a8b991800c73cbe6dbfdcf7761aac3e542c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10169a8b991800c73cbe6dbfdcf7761aac3e542c/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c65aa0429d688103b446a7cb2985c351b52071f3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c65aa0429d688103b446a7cb2985c351b52071f3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c65aa0429d688103b446a7cb2985c351b52071f3"}], "stats": {"total": 56, "additions": 29, "deletions": 27}, "files": [{"sha": "eca124b6b314a7b3918207d553aa735e6c1127ff", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10169a8b991800c73cbe6dbfdcf7761aac3e542c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10169a8b991800c73cbe6dbfdcf7761aac3e542c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=10169a8b991800c73cbe6dbfdcf7761aac3e542c", "patch": "@@ -1,3 +1,14 @@\n+2015-07-05  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* target-insns.def (allocate_stack, check_stack, probe_stack)\n+\t(probe_stack_address, split_stack_prologue, split_stack_space_check):\n+\tNew targetm instruction patterns.\n+\t* explow.c (allocate_dynamic_stack_space): Use them instead of\n+\tHAVE_*/gen_* interface.\n+\t(emit_stack_probe): Likewise.\n+\t(probe_stack_range): Likewise.\n+\t* function.c (thread_prologue_and_epilogue_insns): Likewise.\n+\n 2015-07-05  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* target-insns.def (stack_protect_set, stack_protect_test): New"}, {"sha": "cfd8dc579cb4a440c9ead96ed461c6793106b25a", "filename": "gcc/explow.c", "status": "modified", "additions": 11, "deletions": 20, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10169a8b991800c73cbe6dbfdcf7761aac3e542c/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10169a8b991800c73cbe6dbfdcf7761aac3e542c/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=10169a8b991800c73cbe6dbfdcf7761aac3e542c", "patch": "@@ -1308,16 +1308,15 @@ allocate_dynamic_stack_space (rtx size, unsigned size_align,\n \n       available_label = NULL;\n \n-#ifdef HAVE_split_stack_space_check\n-      if (HAVE_split_stack_space_check)\n+      if (targetm.have_split_stack_space_check ())\n \t{\n \t  available_label = gen_label_rtx ();\n \n \t  /* This instruction will branch to AVAILABLE_LABEL if there\n \t     are SIZE bytes available on the stack.  */\n-\t  emit_insn (gen_split_stack_space_check (size, available_label));\n+\t  emit_insn (targetm.gen_split_stack_space_check\n+\t\t     (size, available_label));\n \t}\n-#endif\n \n       /* The __morestack_allocate_stack_space function will allocate\n \t memory using malloc.  If the alignment of the memory returned\n@@ -1375,19 +1374,17 @@ allocate_dynamic_stack_space (rtx size, unsigned size_align,\n   /* Perform the required allocation from the stack.  Some systems do\n      this differently than simply incrementing/decrementing from the\n      stack pointer, such as acquiring the space by calling malloc().  */\n-#ifdef HAVE_allocate_stack\n-  if (HAVE_allocate_stack)\n+  if (targetm.have_allocate_stack ())\n     {\n       struct expand_operand ops[2];\n       /* We don't have to check against the predicate for operand 0 since\n \t TARGET is known to be a pseudo of the proper mode, which must\n \t be valid for the operand.  */\n       create_fixed_operand (&ops[0], target);\n       create_convert_operand_to (&ops[1], size, STACK_SIZE_MODE, true);\n-      expand_insn (CODE_FOR_allocate_stack, 2, ops);\n+      expand_insn (targetm.code_for_allocate_stack, 2, ops);\n     }\n   else\n-#endif\n     {\n       int saved_stack_pointer_delta;\n \n@@ -1491,22 +1488,18 @@ set_stack_check_libfunc (const char *libfunc_name)\n void\n emit_stack_probe (rtx address)\n {\n-#ifdef HAVE_probe_stack_address\n-  if (HAVE_probe_stack_address)\n-    emit_insn (gen_probe_stack_address (address));\n+  if (targetm.have_probe_stack_address ())\n+    emit_insn (targetm.gen_probe_stack_address (address));\n   else\n-#endif\n     {\n       rtx memref = gen_rtx_MEM (word_mode, address);\n \n       MEM_VOLATILE_P (memref) = 1;\n \n       /* See if we have an insn to probe the stack.  */\n-#ifdef HAVE_probe_stack\n-      if (HAVE_probe_stack)\n-        emit_insn (gen_probe_stack (memref));\n+      if (targetm.have_probe_stack ())\n+        emit_insn (targetm.gen_probe_stack (memref));\n       else\n-#endif\n         emit_move_insn (memref, const0_rtx);\n     }\n }\n@@ -1548,8 +1541,7 @@ probe_stack_range (HOST_WIDE_INT first, rtx size)\n     }\n \n   /* Next see if we have an insn to check the stack.  */\n-#ifdef HAVE_check_stack\n-  else if (HAVE_check_stack)\n+  else if (targetm.have_check_stack ())\n     {\n       struct expand_operand ops[1];\n       rtx addr = memory_address (Pmode,\n@@ -1559,10 +1551,9 @@ probe_stack_range (HOST_WIDE_INT first, rtx size)\n \t\t\t\t\t\t\t\tsize, first)));\n       bool success;\n       create_input_operand (&ops[0], addr, Pmode);\n-      success = maybe_expand_insn (CODE_FOR_check_stack, 1, ops);\n+      success = maybe_expand_insn (targetm.code_for_check_stack, 1, ops);\n       gcc_assert (success);\n     }\n-#endif\n \n   /* Otherwise we have to generate explicit probes.  If we have a constant\n      small number of them to generate, that's the easy case.  */"}, {"sha": "8ee79d30a1487fa98dfd850fe5c0d05b67b4fdb3", "filename": "gcc/function.c", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10169a8b991800c73cbe6dbfdcf7761aac3e542c/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10169a8b991800c73cbe6dbfdcf7761aac3e542c/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=10169a8b991800c73cbe6dbfdcf7761aac3e542c", "patch": "@@ -5842,19 +5842,13 @@ thread_prologue_and_epilogue_insns (void)\n       && (lookup_attribute (\"no_split_stack\", DECL_ATTRIBUTES (cfun->decl))\n \t  == NULL))\n     {\n-#ifndef HAVE_split_stack_prologue\n-      gcc_unreachable ();\n-#else\n-      gcc_assert (HAVE_split_stack_prologue);\n-\n       start_sequence ();\n-      emit_insn (gen_split_stack_prologue ());\n+      emit_insn (targetm.gen_split_stack_prologue ());\n       split_prologue_seq = get_insns ();\n       end_sequence ();\n \n       record_insns (split_prologue_seq, NULL, &prologue_insn_hash);\n       set_insn_locations (split_prologue_seq, prologue_location);\n-#endif\n     }\n \n   prologue_seq = NULL;"}, {"sha": "28d3151b3fc5eee4287c87cf2be1985ee546bf36", "filename": "gcc/target-insns.def", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10169a8b991800c73cbe6dbfdcf7761aac3e542c/gcc%2Ftarget-insns.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10169a8b991800c73cbe6dbfdcf7761aac3e542c/gcc%2Ftarget-insns.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget-insns.def?ref=10169a8b991800c73cbe6dbfdcf7761aac3e542c", "patch": "@@ -30,11 +30,13 @@\n    Patterns that take no operands should have a prototype \"(void)\".\n \n    Instructions should be documented in md.texi rather than here.  */\n+DEF_TARGET_INSN (allocate_stack, (rtx x0, rtx x1))\n DEF_TARGET_INSN (builtin_longjmp, (rtx x0))\n DEF_TARGET_INSN (builtin_setjmp_receiver, (rtx x0))\n DEF_TARGET_INSN (builtin_setjmp_setup, (rtx x0))\n DEF_TARGET_INSN (canonicalize_funcptr_for_compare, (rtx x0, rtx x1))\n DEF_TARGET_INSN (casesi, (rtx x0, rtx x1, rtx x2, rtx x3, rtx x4))\n+DEF_TARGET_INSN (check_stack, (rtx x0))\n DEF_TARGET_INSN (epilogue, (void))\n DEF_TARGET_INSN (exception_receiver, (void))\n DEF_TARGET_INSN (jump, (rtx x0))\n@@ -45,6 +47,8 @@ DEF_TARGET_INSN (memory_barrier, (void))\n DEF_TARGET_INSN (nonlocal_goto, (rtx x0, rtx x1, rtx x2, rtx x3))\n DEF_TARGET_INSN (nonlocal_goto_receiver, (void))\n DEF_TARGET_INSN (prefetch, (rtx x0, rtx x1, rtx x2))\n+DEF_TARGET_INSN (probe_stack, (rtx x0))\n+DEF_TARGET_INSN (probe_stack_address, (rtx x0))\n DEF_TARGET_INSN (prologue, (void))\n DEF_TARGET_INSN (restore_stack_block, (rtx x0, rtx x1))\n DEF_TARGET_INSN (restore_stack_function, (rtx x0, rtx x1))\n@@ -55,6 +59,8 @@ DEF_TARGET_INSN (save_stack_function, (rtx x0, rtx x1))\n DEF_TARGET_INSN (save_stack_nonlocal, (rtx x0, rtx x1))\n DEF_TARGET_INSN (sibcall_epilogue, (void))\n DEF_TARGET_INSN (simple_return, (void))\n+DEF_TARGET_INSN (split_stack_prologue, (void))\n+DEF_TARGET_INSN (split_stack_space_check, (rtx x0, rtx x1))\n DEF_TARGET_INSN (stack_protect_set, (rtx x0, rtx x1))\n DEF_TARGET_INSN (stack_protect_test, (rtx x0, rtx x1, rtx x2))\n DEF_TARGET_INSN (store_multiple, (rtx x0, rtx x1, rtx x2))"}]}