{"sha": "94dc8b56700585cf60b0e31c9f6c8d7ef3521b49", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTRkYzhiNTY3MDA1ODVjZjYwYjBlMzFjOWY2YzhkN2VmMzUyMWI0OQ==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1992-08-11T19:55:01Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1992-08-11T19:55:01Z"}, "message": "(loop_number_first_block, loop_number_last_block,\n\nloop_number_block_level): Delete.\n(find_loop_tree_blocks): Completely rewritten to use\nidentify_blocks.\n(unroll_block_trees): Completely rewritten to use reorder blocks.\n\nFrom-SVN: r1801", "tree": {"sha": "ec27b97a84467b8779956ff9aca11cbea64a240a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ec27b97a84467b8779956ff9aca11cbea64a240a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/94dc8b56700585cf60b0e31c9f6c8d7ef3521b49", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/94dc8b56700585cf60b0e31c9f6c8d7ef3521b49", "html_url": "https://github.com/Rust-GCC/gccrs/commit/94dc8b56700585cf60b0e31c9f6c8d7ef3521b49", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/94dc8b56700585cf60b0e31c9f6c8d7ef3521b49/comments", "author": null, "committer": null, "parents": [{"sha": "a6b83e54f57508545256eefc88c924cc00d1eae0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6b83e54f57508545256eefc88c924cc00d1eae0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a6b83e54f57508545256eefc88c924cc00d1eae0"}], "stats": {"total": 165, "additions": 12, "deletions": 153}, "files": [{"sha": "7ee59b2a4079d9db6baa8314d25d674396d39d6e", "filename": "gcc/stmt.c", "status": "modified", "additions": 12, "deletions": 153, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94dc8b56700585cf60b0e31c9f6c8d7ef3521b49/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94dc8b56700585cf60b0e31c9f6c8d7ef3521b49/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=94dc8b56700585cf60b0e31c9f6c8d7ef3521b49", "patch": "@@ -4579,168 +4579,27 @@ emit_case_nodes (index, node, default_label, index_type)\n /* These routines are used by the loop unrolling code.  They copy BLOCK trees\n    so that the debugging info will be correct for the unrolled loop.  */\n \n-/* Indexed by loop number, contains pointer to the first block in the loop,\n-   or zero if none.  Only valid if doing loop unrolling and outputting debugger\n-   info.  */\n+/* Indexed by block number, contains a pointer to the N'th block node.  */\n \n-tree *loop_number_first_block;\n-\n-/* Indexed by loop number, contains pointer to the last block in the loop,\n-   only valid if loop_number_first_block is nonzero.  */\n-\n-tree *loop_number_last_block;\n-\n-/* Indexed by loop number, contains nesting level of first block in the\n-   loop, if any.  Only valid if doing loop unrolling and outputting debugger\n-   info.  */\n-\n-int *loop_number_block_level;\n-\n-/* Scan the function looking for loops, and walk the BLOCK tree at the\n-   same time.  Record the first and last BLOCK tree corresponding to each\n-   loop.  This function is similar to find_and_verify_loops in loop.c.  */\n+static tree *block_vector;\n \n void\n-find_loop_tree_blocks (f)\n-     rtx f;\n+find_loop_tree_blocks ()\n {\n-  rtx insn;\n-  int current_loop = -1;\n-  int next_loop = -1;\n-  int loop;\n-  int block_level, tree_level;\n-  tree tree_block, parent_tree_block;\n-\n-  tree_block = DECL_INITIAL (current_function_decl);\n-  parent_tree_block = 0;\n-  block_level = 0;\n-  tree_level = -1;\n-\n-  /* Find boundaries of loops, and save the first and last BLOCK tree\n-     corresponding to each loop.  */\n-\n-  for (insn = f; insn; insn = NEXT_INSN (insn))\n-    {\n-      if (GET_CODE (insn) == NOTE)\n-\tswitch (NOTE_LINE_NUMBER (insn))\n-\t  {\n-\t  case NOTE_INSN_LOOP_BEG:\n-\t    loop_number_block_level[++next_loop] = block_level;\n-\t    loop_number_first_block[next_loop] = 0;\n-\t    current_loop = next_loop;\n-\t    break;\n-\n-\t  case NOTE_INSN_LOOP_END:\n-\t    if (current_loop == -1)\n-\t      abort ();\n-\n-\t    current_loop = loop_outer_loop[current_loop];\n-\t    break;\n-\n-\t  case NOTE_INSN_BLOCK_BEG:\n-\t    if (tree_level < block_level)\n-\t      {\n-\t\t/* We have seen two NOTE_INSN_BLOCK_BEG notes in a row, so\n-\t\t   we must now visit the subtree of the current block.  */\n-\t\tparent_tree_block = tree_block;\n-\t\ttree_block = BLOCK_SUBBLOCKS (tree_block);\n-\t\ttree_level++;\n-\t      }\n-\t    else if (tree_level > block_level)\n-\t      abort ();\n-\n-\t    /* Save this block tree here for all nested loops for which\n-\t       this is the topmost block.  */\n-\t    for (loop = current_loop;\n-\t\t loop != -1 && block_level == loop_number_block_level[loop];\n-\t\t loop = loop_outer_loop[loop])\n-\t      {\n-\t\tif (loop_number_first_block[loop] == 0)\n-\t\t  loop_number_first_block[loop] = tree_block;\n-\t\tloop_number_last_block[loop] = tree_block;\n-\t      }\n+  tree block = DECL_INITIAL (current_function_decl);\n \n-\t    block_level++;\n-\t    break;\n+  /* There first block is for the function body, and does not have\n+     corresponding block notes.  Don't include it in the block vector.  */\n+  block = BLOCK_SUBBLOCKS (block);\n \n-\t  case NOTE_INSN_BLOCK_END:\n-\t    block_level--;\n-\t    if (tree_level > block_level)\n-\t      {\n-\t\t/* We have seen two NOTE_INSN_BLOCK_END notes in a row, so\n-\t\t   we must now visit the parent of the current tree.  */\n-\t\tif (tree_block != 0 || parent_tree_block == 0)\n-\t\t  abort ();\n-\t\ttree_block = parent_tree_block;\n-\t\tparent_tree_block = BLOCK_SUPERCONTEXT (parent_tree_block);\n-\t\ttree_level--;\n-\t      }\n-\t    tree_block = BLOCK_CHAIN (tree_block);\n-\t    break;\n-\t  }\n-    }\n+  block_vector = identify_blocks (block, get_insns ());\n }\n \n-/* This routine will make COPIES-1 copies of all BLOCK trees that correspond\n-   to BLOCK_BEG notes inside the loop LOOP_NUMBER.\n-\n-   Note that we only copy the topmost level of tree nodes; they will share\n-   pointers to the same subblocks.  */\n-\n void\n-unroll_block_trees (loop_number, copies)\n-     int loop_number;\n-     int copies;\n+unroll_block_trees ()\n {\n-  int i;\n-\n-  /* First check whether there are any blocks that need to be copied.  */\n-  if (loop_number_first_block[loop_number])\n-    {\n-      tree first_block = loop_number_first_block[loop_number];\n-      tree last_block = loop_number_last_block[loop_number];\n-      tree last_block_created = 0;\n-\n-      for (i = 0; i < copies - 1; i++)\n-\t{\n-\t  tree block = first_block;\n-\t  tree insert_after = last_block;\n-\t  tree copied_block;\n-\n-\t  /* Copy every block between first_block and last_block inclusive,\n-\t     inserting the new blocks after last_block.  */\n-\t  do\n-\t    {\n-\t      tree new_block = make_node (BLOCK);\n-\t      BLOCK_VARS (new_block) = BLOCK_VARS (block);\n-\t      BLOCK_TYPE_TAGS (new_block) = BLOCK_TYPE_TAGS (block);\n-\t      BLOCK_SUBBLOCKS (new_block) = BLOCK_SUBBLOCKS (block);\n-\t      BLOCK_SUPERCONTEXT (new_block) = BLOCK_SUPERCONTEXT (block);\n-\t      TREE_USED (new_block) = TREE_USED (block);\n-\n-\t      /* Insert the new block after the insertion point, and move\n-\t\t the insertion point to the new block.  This ensures that\n-\t\t the copies are inserted in the right order.  */\n-\t      BLOCK_CHAIN (new_block) = BLOCK_CHAIN (insert_after);\n-\t      BLOCK_CHAIN (insert_after) = new_block;\n-\t      insert_after = new_block;\n-\n-\t      copied_block = block;\n-\t      block = BLOCK_CHAIN (block);\n-\t    }\n-\t  while (copied_block != last_block);\n-\n-\t  /* Remember the last block created, so that we can update the\n-\t     info in the tables.  */\n-\t  if (last_block_created == 0)\n-\t    last_block_created = insert_after;\n-\t}\n+  tree block = DECL_INITIAL (current_function_decl);\n \n-      /* For all nested loops for which LAST_BLOCK was originally the last\n-\t block, update the tables to indicate that LAST_BLOCK_CREATED is\n-\t now the last block in the loop.  */\n-      for (i = loop_number; last_block == loop_number_last_block[i];\n-\t   i = loop_outer_loop[i])\n-\tloop_number_last_block[i] = last_block_created;\n-    }\n+  reorder_blocks (block_vector, block, get_insns ());\n }\n+"}]}