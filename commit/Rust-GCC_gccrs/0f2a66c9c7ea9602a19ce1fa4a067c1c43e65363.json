{"sha": "0f2a66c9c7ea9602a19ce1fa4a067c1c43e65363", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGYyYTY2YzljN2VhOTYwMmExOWNlMWZhNGEwNjdjMWM0M2U2NTM2Mw==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2004-06-28T10:41:19Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2004-06-28T10:41:19Z"}, "message": "friend.c (add_friend): Only perform access checks when context is a class.\n\n\t* friend.c (add_friend): Only perform access checks when context\n\tis a class.\n\t* lex.c (cxx_make_type): Only create a binfo for aggregate types.\n\t* parser.c (cp_parser_class_specifier): Disable access checks here\n\twhen parsing the body of a templated class.\n\t* semantics.c (perform_or_defer_access_checks): Reorder to allow\n\tNULL binfos when not checking access.\n\nFrom-SVN: r83771", "tree": {"sha": "cf4f78ec248da873e1e177db29f5cbdcd3a378fd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cf4f78ec248da873e1e177db29f5cbdcd3a378fd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0f2a66c9c7ea9602a19ce1fa4a067c1c43e65363", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f2a66c9c7ea9602a19ce1fa4a067c1c43e65363", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0f2a66c9c7ea9602a19ce1fa4a067c1c43e65363", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f2a66c9c7ea9602a19ce1fa4a067c1c43e65363/comments", "author": null, "committer": null, "parents": [{"sha": "58c42dc28354d5857a5d905d505127eb5624111f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/58c42dc28354d5857a5d905d505127eb5624111f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/58c42dc28354d5857a5d905d505127eb5624111f"}], "stats": {"total": 52, "additions": 32, "deletions": 20}, "files": [{"sha": "500567b88967c1886cf72d57cd852e133cbca617", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f2a66c9c7ea9602a19ce1fa4a067c1c43e65363/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f2a66c9c7ea9602a19ce1fa4a067c1c43e65363/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=0f2a66c9c7ea9602a19ce1fa4a067c1c43e65363", "patch": "@@ -1,3 +1,13 @@\n+2004-06-28  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* friend.c (add_friend): Only perform access checks when context\n+\tis a class.\n+\t* lex.c (cxx_make_type): Only create a binfo for aggregate types.\n+\t* parser.c (cp_parser_class_specifier): Disable access checks here\n+\twhen parsing the body of a templated class.\n+\t* semantics.c (perform_or_defer_access_checks): Reorder to allow\n+\tNULL binfos when not checking access.\n+\n 2004-06-28  Nathan Sidwell  <nathan@codesourcery.com>\n \n \tUse vector API for vbase list."}, {"sha": "75551a9678e1430bb4b6d4f1fb653d76237f1149", "filename": "gcc/cp/friend.c", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f2a66c9c7ea9602a19ce1fa4a067c1c43e65363/gcc%2Fcp%2Ffriend.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f2a66c9c7ea9602a19ce1fa4a067c1c43e65363/gcc%2Fcp%2Ffriend.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ffriend.c?ref=0f2a66c9c7ea9602a19ce1fa4a067c1c43e65363", "patch": "@@ -129,6 +129,7 @@ add_friend (tree type, tree decl, bool complain)\n   tree typedecl;\n   tree list;\n   tree name;\n+  tree ctx;\n \n   if (decl == error_mark_node)\n     return;\n@@ -163,12 +164,9 @@ add_friend (tree type, tree decl, bool complain)\n       list = TREE_CHAIN (list);\n     }\n \n-  if (DECL_CLASS_SCOPE_P (decl))\n-    {\n-      tree class_binfo = TYPE_BINFO (DECL_CONTEXT (decl));\n-      if (!uses_template_parms (BINFO_TYPE (class_binfo)))\n-\tperform_or_defer_access_check (class_binfo, decl);\n-    }\n+  ctx = DECL_CONTEXT (decl);\n+  if (ctx && CLASS_TYPE_P (ctx) && !uses_template_parms (ctx))\n+    perform_or_defer_access_check (TYPE_BINFO (ctx), decl);\n \n   maybe_add_class_template_decl_list (type, decl, /*friend_p=*/1);\n "}, {"sha": "1daa1fc6ec9c100dd87955c571f6176a1789af4d", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f2a66c9c7ea9602a19ce1fa4a067c1c43e65363/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f2a66c9c7ea9602a19ce1fa4a067c1c43e65363/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=0f2a66c9c7ea9602a19ce1fa4a067c1c43e65363", "patch": "@@ -779,22 +779,15 @@ cxx_make_type (enum tree_code code)\n \t presence of parse errors, the normal was of assuring this\n \t might not ever get executed, so we lay it out *immediately*.  */\n       build_pointer_type (t);\n+\n+      TYPE_BINFO (t) = make_binfo (size_zero_node, t, NULL_TREE, NULL_TREE);\n     }\n   else\n     /* We use TYPE_ALIAS_SET for the CLASSTYPE_MARKED bits.  But,\n        TYPE_ALIAS_SET is initialized to -1 by default, so we must\n        clear it here.  */\n     TYPE_ALIAS_SET (t) = 0;\n \n-  /* We need to allocate a TYPE_BINFO even for TEMPLATE_TYPE_PARMs\n-     since they can be virtual base types, and we then need a\n-     canonical binfo for them.  Ideally, this would be done lazily for\n-     all types.  */\n-  if (IS_AGGR_TYPE_CODE (code) || code == TEMPLATE_TYPE_PARM\n-      || code == BOUND_TEMPLATE_TEMPLATE_PARM\n-      || code == TYPENAME_TYPE)\n-    TYPE_BINFO (t) = make_binfo (size_zero_node, t, NULL_TREE, NULL_TREE);\n-\n   return t;\n }\n "}, {"sha": "10238c4a2f1d91a67c60d937fb415964cf994028", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f2a66c9c7ea9602a19ce1fa4a067c1c43e65363/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f2a66c9c7ea9602a19ce1fa4a067c1c43e65363/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=0f2a66c9c7ea9602a19ce1fa4a067c1c43e65363", "patch": "@@ -12342,12 +12342,22 @@ cp_parser_class_specifier (cp_parser* parser)\n   if (nested_name_specifier_p)\n     pop_p = push_scope (CP_DECL_CONTEXT (TYPE_MAIN_DECL (type)));\n   type = begin_class_definition (type);\n+  \n+  if (processing_template_decl)\n+    /* There are no access checks when parsing a template, as we do no\n+       know if a specialization will be a friend.  */\n+    push_deferring_access_checks (dk_no_check);\n+  \n   if (type == error_mark_node)\n     /* If the type is erroneous, skip the entire body of the class.  */\n     cp_parser_skip_to_closing_brace (parser);\n   else\n     /* Parse the member-specification.  */\n     cp_parser_member_specification_opt (parser);\n+  \n+  if (processing_template_decl)\n+    pop_deferring_access_checks ();\n+  \n   /* Look for the trailing `}'.  */\n   cp_parser_require (parser, CPP_CLOSE_BRACE, \"`}'\");\n   /* We get better error messages by noticing a common problem: a"}, {"sha": "66c892b7d094f2b670a0094b165a3e73d9cd84cd", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f2a66c9c7ea9602a19ce1fa4a067c1c43e65363/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f2a66c9c7ea9602a19ce1fa4a067c1c43e65363/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=0f2a66c9c7ea9602a19ce1fa4a067c1c43e65363", "patch": "@@ -257,18 +257,19 @@ perform_or_defer_access_check (tree binfo, tree decl)\n {\n   tree check;\n \n-  my_friendly_assert (TREE_CODE (binfo) == TREE_VEC, 20030623);\n+  /* Exit if we are in a context that no access checking is performed.  */\n+  if (deferred_access_stack->deferring_access_checks_kind == dk_no_check)\n+    return;\n   \n+  my_friendly_assert (TREE_CODE (binfo) == TREE_VEC, 20030623);\n+\n   /* If we are not supposed to defer access checks, just check now.  */\n   if (deferred_access_stack->deferring_access_checks_kind == dk_no_deferred)\n     {\n       enforce_access (binfo, decl);\n       return;\n     }\n-  /* Exit if we are in a context that no access checking is performed.  */\n-  else if (deferred_access_stack->deferring_access_checks_kind == dk_no_check)\n-    return;\n-\n+  \n   /* See if we are already going to perform this check.  */\n   for (check = deferred_access_stack->deferred_access_checks;\n        check;"}]}