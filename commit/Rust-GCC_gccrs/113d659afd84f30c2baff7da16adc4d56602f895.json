{"sha": "113d659afd84f30c2baff7da16adc4d56602f895", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTEzZDY1OWFmZDg0ZjMwYzJiYWZmN2RhMTZhZGM0ZDU2NjAyZjg5NQ==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "rakdver@atrey.karlin.mff.cuni.cz", "date": "2004-09-14T08:05:46Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2004-09-14T08:05:46Z"}, "message": "Makefile.in (loop-unroll.o): Add HASHTAB_H and RECOG_H dependency.\n\n\t* Makefile.in (loop-unroll.o): Add HASHTAB_H and RECOG_H dependency.\n\t* basic-block.h (struct reorder_block_def): Add copy_number field.\n\t* cfgloop.h (biv_p): Declare.\n\t* cfgloopmanip.c (duplicate_loop_to_header_edge): Set copy_number.\n\t* common.opt (fsplit-ivs-in-unroller): New flag.\n\t* loop-iv.c (biv_p): New function.\n\t* loop-unroll.c: Include hashtab.h and recog.h.\n\t(struct iv_to_split, struct split_ivs_info): New types.\n\t(analyze_ivs_to_split, si_info_start_duplication, split_ivs_in_copies,\n\tfree_si_info, si_info_hash, si_info_eq, analyze_iv_to_split_insn,\n\tdetermine_split_iv_delta, get_ivts_expr, allocate_basic_variable,\n\tinsert_base_initialization, split_iv): New functions.\n\t(peel_loop_completely, unroll_loop_constant_iterations,\n\tunroll_loop_runtime_iterations, peel_loop_simple, unroll_loop_stupid):\n\tUse them.\n\t* doc/invoke.texi (-fsplit-ivs-in-unroller): Document.\n\nCo-Authored-By: Steven Bosscher <stevenb@suse.de>\n\nFrom-SVN: r87487", "tree": {"sha": "5c0e5b9524b1674de9c53a236c486fe4455d642b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5c0e5b9524b1674de9c53a236c486fe4455d642b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/113d659afd84f30c2baff7da16adc4d56602f895", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/113d659afd84f30c2baff7da16adc4d56602f895", "html_url": "https://github.com/Rust-GCC/gccrs/commit/113d659afd84f30c2baff7da16adc4d56602f895", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/113d659afd84f30c2baff7da16adc4d56602f895/comments", "author": null, "committer": null, "parents": [{"sha": "d840495b15862ef5d62af317e76be37d71948540", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d840495b15862ef5d62af317e76be37d71948540", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d840495b15862ef5d62af317e76be37d71948540"}], "stats": {"total": 541, "additions": 533, "deletions": 8}, "files": [{"sha": "74fa6ae4f672e3fd33f066d3afd5b82bf4bc0aae", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/113d659afd84f30c2baff7da16adc4d56602f895/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/113d659afd84f30c2baff7da16adc4d56602f895/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=113d659afd84f30c2baff7da16adc4d56602f895", "patch": "@@ -1,3 +1,23 @@\n+2004-09-14  Zdenek Dvorak  <rakdver@atrey.karlin.mff.cuni.cz>\n+\t    Steven Bosscher  <stevenb@suse.de>\n+\n+\t* Makefile.in (loop-unroll.o): Add HASHTAB_H and RECOG_H dependency.\n+\t* basic-block.h (struct reorder_block_def): Add copy_number field.\n+\t* cfgloop.h (biv_p): Declare.\n+\t* cfgloopmanip.c (duplicate_loop_to_header_edge): Set copy_number.\n+\t* common.opt (fsplit-ivs-in-unroller): New flag.\n+\t* loop-iv.c (biv_p): New function.\n+\t* loop-unroll.c: Include hashtab.h and recog.h.\n+\t(struct iv_to_split, struct split_ivs_info): New types.\n+\t(analyze_ivs_to_split, si_info_start_duplication, split_ivs_in_copies,\n+\tfree_si_info, si_info_hash, si_info_eq, analyze_iv_to_split_insn,\n+\tdetermine_split_iv_delta, get_ivts_expr, allocate_basic_variable,\n+\tinsert_base_initialization, split_iv): New functions.\n+\t(peel_loop_completely, unroll_loop_constant_iterations,\n+\tunroll_loop_runtime_iterations, peel_loop_simple, unroll_loop_stupid):\n+\tUse them.\n+\t* doc/invoke.texi (-fsplit-ivs-in-unroller): Document.\n+\n 2004-09-14  Zdenek Dvorak  <rakdver@atrey.karlin.mff.cuni.cz>\n \n \t* tree-cfg.c (thread_jumps): Update dominators correctly in"}, {"sha": "68ed49246bb4f31aa4a13086d25d0d4039705cb6", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/113d659afd84f30c2baff7da16adc4d56602f895/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/113d659afd84f30c2baff7da16adc4d56602f895/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=113d659afd84f30c2baff7da16adc4d56602f895", "patch": "@@ -2028,7 +2028,7 @@ loop-unswitch.o : loop-unswitch.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(TM_H) \\\n    output.h $(EXPR_H) coretypes.h $(TM_H)\n loop-unroll.o: loop-unroll.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(TM_H) \\\n    $(BASIC_BLOCK_H) hard-reg-set.h $(CFGLOOP_H) $(CFGLAYOUT_H) $(PARAMS_H) \\\n-   output.h $(EXPR_H) coretypes.h $(TM_H)\n+   output.h $(EXPR_H) coretypes.h $(TM_H) $(HASHTAB_H) $(RECOG_H)\n dominance.o : dominance.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    hard-reg-set.h $(BASIC_BLOCK_H) et-forest.h\n et-forest.o : et-forest.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) et-forest.h alloc-pool.h"}, {"sha": "eed7638573817aee23b7371d254a21d0a54a0380", "filename": "gcc/basic-block.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/113d659afd84f30c2baff7da16adc4d56602f895/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/113d659afd84f30c2baff7da16adc4d56602f895/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=113d659afd84f30c2baff7da16adc4d56602f895", "patch": "@@ -295,6 +295,7 @@ typedef struct reorder_block_def\n   /* Used by loop copying.  */\n   basic_block copy;\n   int duplicated;\n+  int copy_number;\n \n   /* These fields are used by bb-reorder pass.  */\n   int visited;"}, {"sha": "210d7b5d62e5ad909e0a1efacd188f78ab0fb837", "filename": "gcc/cfgloop.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/113d659afd84f30c2baff7da16adc4d56602f895/gcc%2Fcfgloop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/113d659afd84f30c2baff7da16adc4d56602f895/gcc%2Fcfgloop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.h?ref=113d659afd84f30c2baff7da16adc4d56602f895", "patch": "@@ -410,6 +410,7 @@ extern void iv_analysis_loop_init (struct loop *);\n extern rtx iv_get_reaching_def (rtx, rtx);\n extern bool iv_analyze (rtx, rtx, struct rtx_iv *);\n extern rtx get_iv_value (struct rtx_iv *, rtx);\n+extern bool biv_p (rtx, rtx);\n extern void find_simple_exit (struct loop *, struct niter_desc *);\n extern void iv_number_of_iterations (struct loop *, rtx, rtx,\n \t\t\t\t     struct niter_desc *);"}, {"sha": "e20433bcb4b6b7c519eb60df3e27402be5928fdb", "filename": "gcc/cfgloopmanip.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/113d659afd84f30c2baff7da16adc4d56602f895/gcc%2Fcfgloopmanip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/113d659afd84f30c2baff7da16adc4d56602f895/gcc%2Fcfgloopmanip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopmanip.c?ref=113d659afd84f30c2baff7da16adc4d56602f895", "patch": "@@ -991,6 +991,9 @@ duplicate_loop_to_header_edge (struct loop *loop, edge e, struct loops *loops,\n       /* Copy bbs.  */\n       copy_bbs (bbs, n, new_bbs, spec_edges, 2, new_spec_edges, loop);\n \n+      for (i = 0; i < n; i++)\n+\tnew_bbs[i]->rbi->copy_number = j + 1;\n+\n       /* Note whether the blocks and edges belong to an irreducible loop.  */\n       if (add_irreducible_flag)\n \t{\n@@ -1069,6 +1072,8 @@ duplicate_loop_to_header_edge (struct loop *loop, edge e, struct loops *loops,\n       int n_dom_bbs,j;\n \n       bb = bbs[i];\n+      bb->rbi->copy_number = 0;\n+\n       n_dom_bbs = get_dominated_by (CDI_DOMINATORS, bb, &dom_bbs);\n       for (j = 0; j < n_dom_bbs; j++)\n \t{"}, {"sha": "5739c1b8c2a06c51f3c64d584a8c2116f5dfd932", "filename": "gcc/common.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/113d659afd84f30c2baff7da16adc4d56602f895/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/113d659afd84f30c2baff7da16adc4d56602f895/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=113d659afd84f30c2baff7da16adc4d56602f895", "patch": "@@ -744,6 +744,10 @@ fspeculative-prefetching\n Common Report Var(flag_speculative_prefetching)\n Use value profiling for speculative prefetching\n \n+fsplit-ivs-in-unroller\n+Common Report Var(flag_split_ivs_in_unroller) Init(1)\n+Split lifetimes of induction variables when loops are unrolled.\n+\n ; Emit code to probe the stack, to help detect stack overflow; also\n ; may cause large objects to be allocated dynamically.\n fstack-check"}, {"sha": "3b258fe24566d24bda03439db93f662d2b1e26d7", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/113d659afd84f30c2baff7da16adc4d56602f895/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/113d659afd84f30c2baff7da16adc4d56602f895/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=113d659afd84f30c2baff7da16adc4d56602f895", "patch": "@@ -315,7 +315,7 @@ Objective-C and Objective-C++ Dialects}.\n -fsignaling-nans -fsingle-precision-constant  -fspeculative-prefetching @gol\n -fstrength-reduce  -fstrict-aliasing  -ftracer  -fthread-jumps @gol\n -funroll-all-loops  -funroll-loops  -fpeel-loops @gol\n--funswitch-loops @gol\n+-fsplit-ivs-in-unroller -funswitch-loops @gol\n -ftree-pre  -ftree-ccp  -ftree-dce -ftree-loop-optimize @gol\n -ftree-loop-linear -ftree-loop-im -ftree-loop-ivcanon -fivopts @gol\n -ftree-dominator-opts -ftree-dse -ftree-copyrename @gol\n@@ -4696,6 +4696,20 @@ the loop is entered.  This usually makes programs run more slowly.\n @option{-funroll-all-loops} implies the same options as\n @option{-funroll-loops},\n \n+@item -fsplit-ivs-in-unroller\n+@opindex -fsplit-ivs-in-unroller\n+Enables expressing of values of induction variables in later iterations\n+of the unrolled loop using the value in the first iteration.  This breaks\n+long dependency chains, thus improving efficiency of the scheduling passes\n+(for best results, @option{-fweb} should be used as well).\n+\n+Combination of @option{-fweb} and CSE is often sufficient to obtain the\n+same effect. However in cases the loop body is more complicated than\n+a single basic block, this is not reliable.  It also does not work at all\n+on some of the architectures due to restrictions in the CSE pass.\n+\n+This optimization is enabled by default.\n+\n @item -fprefetch-loop-arrays\n @opindex fprefetch-loop-arrays\n If supported by the target machine, generate instructions to prefetch"}, {"sha": "ed06d1dbb1e6d0e727631b8e1c53e55f8a8dedc6", "filename": "gcc/loop-iv.c", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/113d659afd84f30c2baff7da16adc4d56602f895/gcc%2Floop-iv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/113d659afd84f30c2baff7da16adc4d56602f895/gcc%2Floop-iv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-iv.c?ref=113d659afd84f30c2baff7da16adc4d56602f895", "patch": "@@ -1183,6 +1183,24 @@ iv_analyze (rtx insn, rtx def, struct rtx_iv *iv)\n   return iv->base != NULL_RTX;\n }\n \n+/* Checks whether definition of register REG in INSN a basic induction\n+   variable.  IV analysis must have been initialized (via a call to\n+   iv_analysis_loop_init) for this function to produce a result.  */\n+\n+bool\n+biv_p (rtx insn, rtx reg)\n+{\n+  struct rtx_iv iv;\n+\n+  if (!REG_P (reg))\n+    return false;\n+\n+  if (last_def[REGNO (reg)] != insn)\n+    return false;\n+\n+  return iv_analyze_biv (reg, &iv);\n+}\n+\n /* Calculates value of IV at ITERATION-th iteration.  */\n \n rtx"}, {"sha": "f0e95dc76222a0298244931bc2b5cdebd6879509", "filename": "gcc/loop-unroll.c", "status": "modified", "additions": 468, "deletions": 6, "changes": 474, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/113d659afd84f30c2baff7da16adc4d56602f895/gcc%2Floop-unroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/113d659afd84f30c2baff7da16adc4d56602f895/gcc%2Floop-unroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-unroll.c?ref=113d659afd84f30c2baff7da16adc4d56602f895", "patch": "@@ -30,6 +30,8 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"params.h\"\n #include \"output.h\"\n #include \"expr.h\"\n+#include \"hashtab.h\"\n+#include \"recog.h\"\n \n /* This pass performs loop unrolling and peeling.  We only perform these\n    optimizations on innermost loops (with single exception) because\n@@ -66,6 +68,28 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    showed that this choice may affect performance in order of several %.\n    */\n \n+/* Information about induction variables to split.  */\n+\n+struct iv_to_split\n+{\n+  rtx insn;\t\t/* The insn in that the induction variable occurs.  */\n+  rtx base_var;\t\t/* The variable on that the values in the further\n+\t\t\t   iterations are based.  */\n+  rtx step;\t\t/* Step of the induction variable.  */\n+  unsigned n_loc;\n+  unsigned loc[3];\t/* Location where the definition of the induction\n+\t\t\t   variable occurs in the insn.  For example if\n+\t\t\t   N_LOC is 2, the expression is located at\n+\t\t\t   XEXP (XEXP (single_set, loc[0]), loc[1]).  */ \n+};\n+\n+struct split_ivs_info\n+{\n+  htab_t insns_to_split;\t/* A hashtable of insns to split.  */\n+  unsigned first_new_block;\t/* The first basic block that was\n+\t\t\t\t   duplicated.  */\n+};\n+\n static void decide_unrolling_and_peeling (struct loops *, int);\n static void peel_loops_completely (struct loops *, int);\n static void decide_peel_simple (struct loop *, int);\n@@ -79,6 +103,10 @@ static void peel_loop_completely (struct loops *, struct loop *);\n static void unroll_loop_stupid (struct loops *, struct loop *);\n static void unroll_loop_constant_iterations (struct loops *, struct loop *);\n static void unroll_loop_runtime_iterations (struct loops *, struct loop *);\n+static struct split_ivs_info *analyze_ivs_to_split (struct loop *);\n+static void si_info_start_duplication (struct split_ivs_info *);\n+static void split_ivs_in_copies (struct split_ivs_info *, unsigned, bool, bool);\n+static void free_si_info (struct split_ivs_info *);\n \n /* Unroll and/or peel (depending on FLAGS) LOOPS.  */\n void\n@@ -116,7 +144,7 @@ unroll_and_peel_loops (struct loops *loops, int flags)\n \t{\n \tcase LPT_PEEL_COMPLETELY:\n \t  /* Already done.  */\n-\t  abort ();\n+\t  gcc_unreachable ();\n \tcase LPT_PEEL_SIMPLE:\n \t  peel_loop_simple (loops, loop);\n \t  break;\n@@ -133,7 +161,7 @@ unroll_and_peel_loops (struct loops *loops, int flags)\n \t  check = false;\n \t  break;\n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n       if (check)\n \t{\n@@ -428,6 +456,7 @@ peel_loop_completely (struct loops *loops, struct loop *loop)\n   unsigned n_remove_edges, i;\n   edge *remove_edges, ei;\n   struct niter_desc *desc = get_simple_loop_desc (loop);\n+  struct split_ivs_info *si_info = NULL;\n \n   npeel = desc->niter;\n \n@@ -442,6 +471,10 @@ peel_loop_completely (struct loops *loops, struct loop *loop)\n       remove_edges = xcalloc (npeel, sizeof (edge));\n       n_remove_edges = 0;\n \n+      if (flag_split_ivs_in_unroller)\n+\tsi_info = analyze_ivs_to_split (loop);\n+\n+      si_info_start_duplication (si_info);\n       if (!duplicate_loop_to_header_edge (loop, loop_preheader_edge (loop),\n \t\tloops, npeel,\n \t\twont_exit, desc->out_edge, remove_edges, &n_remove_edges,\n@@ -450,6 +483,12 @@ peel_loop_completely (struct loops *loops, struct loop *loop)\n \n       free (wont_exit);\n \n+      if (si_info)\n+\t{\n+\t  split_ivs_in_copies (si_info, npeel, false, true);\n+\t  free_si_info (si_info);\n+\t}\n+\n       /* Remove the exit edges.  */\n       for (i = 0; i < n_remove_edges; i++)\n \tremove_path (loops, remove_edges[i]);\n@@ -597,11 +636,12 @@ unroll_loop_constant_iterations (struct loops *loops, struct loop *loop)\n   unsigned max_unroll = loop->lpt_decision.times;\n   struct niter_desc *desc = get_simple_loop_desc (loop);\n   bool exit_at_end = loop_exit_at_end_p (loop);\n+  struct split_ivs_info *si_info = NULL;\n \n   niter = desc->niter;\n \n-  if (niter <= max_unroll + 1)\n-    abort ();  /* Should not get here (such loop should be peeled instead).  */\n+  /* Should not get here (such loop should be peeled instead).  */\n+  gcc_assert (niter > max_unroll + 1);\n \n   exit_mod = niter % (max_unroll + 1);\n \n@@ -611,6 +651,9 @@ unroll_loop_constant_iterations (struct loops *loops, struct loop *loop)\n   remove_edges = xcalloc (max_unroll + exit_mod + 1, sizeof (edge));\n   n_remove_edges = 0;\n \n+  if (flag_split_ivs_in_unroller)\n+    si_info = analyze_ivs_to_split (loop);\n+\n   if (!exit_at_end)\n     {\n       /* The exit is not at the end of the loop; leave exit test\n@@ -627,13 +670,17 @@ unroll_loop_constant_iterations (struct loops *loops, struct loop *loop)\n \n       if (exit_mod)\n \t{\n+\t  si_info_start_duplication (si_info);\n \t  if (!duplicate_loop_to_header_edge (loop, loop_preheader_edge (loop),\n \t\t\t\t\t      loops, exit_mod,\n \t\t\t\t\t      wont_exit, desc->out_edge,\n \t\t\t\t\t      remove_edges, &n_remove_edges,\n \t\t\t\t\t      DLTHE_FLAG_UPDATE_FREQ))\n \t    abort ();\n \n+\t  if (si_info && exit_mod > 1)\n+\t    split_ivs_in_copies (si_info, exit_mod, false, false);\n+\n \t  desc->noloop_assumptions = NULL_RTX;\n \t  desc->niter -= exit_mod;\n \t  desc->niter_max -= exit_mod;\n@@ -659,12 +706,16 @@ unroll_loop_constant_iterations (struct loops *loops, struct loop *loop)\n \t  if (desc->noloop_assumptions)\n \t    RESET_BIT (wont_exit, 1);\n \n+\t  si_info_start_duplication (si_info);\n \t  if (!duplicate_loop_to_header_edge (loop, loop_preheader_edge (loop),\n \t\tloops, exit_mod + 1,\n \t\twont_exit, desc->out_edge, remove_edges, &n_remove_edges,\n \t\tDLTHE_FLAG_UPDATE_FREQ))\n \t    abort ();\n \n+\t  if (si_info && exit_mod > 0)\n+\t    split_ivs_in_copies (si_info, exit_mod + 1, false, false);\n+\n \t  desc->niter -= exit_mod + 1;\n \t  desc->niter_max -= exit_mod + 1;\n \t  desc->noloop_assumptions = NULL_RTX;\n@@ -677,12 +728,19 @@ unroll_loop_constant_iterations (struct loops *loops, struct loop *loop)\n     }\n \n   /* Now unroll the loop.  */\n+  si_info_start_duplication (si_info);\n   if (!duplicate_loop_to_header_edge (loop, loop_latch_edge (loop),\n \t\tloops, max_unroll,\n \t\twont_exit, desc->out_edge, remove_edges, &n_remove_edges,\n \t\tDLTHE_FLAG_UPDATE_FREQ))\n     abort ();\n \n+  if (si_info)\n+    {\n+      split_ivs_in_copies (si_info, max_unroll, true, true);\n+      free_si_info (si_info);\n+    }\n+\n   free (wont_exit);\n \n   if (exit_at_end)\n@@ -842,6 +900,10 @@ unroll_loop_runtime_iterations (struct loops *loops, struct loop *loop)\n   unsigned max_unroll = loop->lpt_decision.times;\n   struct niter_desc *desc = get_simple_loop_desc (loop);\n   bool exit_at_end = loop_exit_at_end_p (loop);\n+  struct split_ivs_info *si_info = NULL;\n+\n+  if (flag_split_ivs_in_unroller)\n+    si_info = analyze_ivs_to_split (loop);\n \n   /* Remember blocks whose dominators will have to be updated.  */\n   dom_bbs = xcalloc (n_basic_blocks, sizeof (basic_block));\n@@ -979,12 +1041,19 @@ unroll_loop_runtime_iterations (struct loops *loops, struct loop *loop)\n   sbitmap_ones (wont_exit);\n   RESET_BIT (wont_exit, may_exit_copy);\n \n+  si_info_start_duplication (si_info);\n   if (!duplicate_loop_to_header_edge (loop, loop_latch_edge (loop),\n \t\tloops, max_unroll,\n \t\twont_exit, desc->out_edge, remove_edges, &n_remove_edges,\n \t\tDLTHE_FLAG_UPDATE_FREQ))\n     abort ();\n \n+  if (si_info)\n+    {\n+      split_ivs_in_copies (si_info, max_unroll, true, true);\n+      free_si_info (si_info);\n+    }\n+\n   free (wont_exit);\n \n   if (exit_at_end)\n@@ -1013,8 +1082,7 @@ unroll_loop_runtime_iterations (struct loops *loops, struct loop *loop)\n      preconditioning and the fact that the value must be valid at entry\n      of the loop.  After passing through the above code, we see that\n      the correct new number of iterations is this:  */\n-  if (desc->const_iter)\n-    abort ();\n+  gcc_assert (!desc->const_iter);\n   desc->niter_expr =\n     simplify_gen_binary (UDIV, desc->mode, old_niter, GEN_INT (max_unroll + 1));\n   desc->niter_max /= max_unroll + 1;\n@@ -1138,17 +1206,28 @@ peel_loop_simple (struct loops *loops, struct loop *loop)\n   sbitmap wont_exit;\n   unsigned npeel = loop->lpt_decision.times;\n   struct niter_desc *desc = get_simple_loop_desc (loop);\n+  struct split_ivs_info *si_info = NULL;\n+\n+  if (flag_split_ivs_in_unroller && npeel > 1)\n+    si_info = analyze_ivs_to_split (loop);\n \n   wont_exit = sbitmap_alloc (npeel + 1);\n   sbitmap_zero (wont_exit);\n \n+  si_info_start_duplication (si_info);\n   if (!duplicate_loop_to_header_edge (loop, loop_preheader_edge (loop),\n \t\tloops, npeel, wont_exit, NULL, NULL, NULL,\n \t\tDLTHE_FLAG_UPDATE_FREQ))\n     abort ();\n \n   free (wont_exit);\n \n+  if (si_info)\n+    {\n+      split_ivs_in_copies (si_info, npeel, false, false);\n+      free_si_info (si_info);\n+    }\n+\n   if (desc->simple_p)\n     {\n       if (desc->const_iter)\n@@ -1271,15 +1350,26 @@ unroll_loop_stupid (struct loops *loops, struct loop *loop)\n   sbitmap wont_exit;\n   unsigned nunroll = loop->lpt_decision.times;\n   struct niter_desc *desc = get_simple_loop_desc (loop);\n+  struct split_ivs_info *si_info = NULL;\n+\n+  if (flag_split_ivs_in_unroller)\n+    si_info = analyze_ivs_to_split (loop);\n \n   wont_exit = sbitmap_alloc (nunroll + 1);\n   sbitmap_zero (wont_exit);\n \n+  si_info_start_duplication (si_info);\n   if (!duplicate_loop_to_header_edge (loop, loop_latch_edge (loop),\n \t\tloops, nunroll, wont_exit, NULL, NULL, NULL,\n \t\tDLTHE_FLAG_UPDATE_FREQ))\n     abort ();\n \n+  if (si_info)\n+    {\n+      split_ivs_in_copies (si_info, nunroll, true, true);\n+      free_si_info (si_info);\n+    }\n+\n   free (wont_exit);\n \n   if (desc->simple_p)\n@@ -1297,3 +1387,375 @@ unroll_loop_stupid (struct loops *loops, struct loop *loop)\n     fprintf (dump_file, \";; Unrolled loop %d times, %i insns\\n\",\n \t     nunroll, num_loop_insns (loop));\n }\n+\n+/* A hash function for information about insns to split.  */\n+\n+static hashval_t\n+si_info_hash (const void *ivts)\n+{\n+  return htab_hash_pointer (((struct iv_to_split *) ivts)->insn);\n+}\n+\n+/* An equality functions for information about insns to split.  */\n+\n+static int\n+si_info_eq (const void *ivts1, const void *ivts2)\n+{\n+  const struct iv_to_split *i1 = ivts1;\n+  const struct iv_to_split *i2 = ivts2;\n+\n+  return i1->insn == i2->insn;\n+}\n+\n+/* Determine whether there is an induction variable in INSN that\n+   we would like to split during unrolling.  Return NULL if INSN\n+   contains no interesting IVs.  Otherwise, allocate an IV_TO_SPLIT\n+   structure, fill it with the relevant information and return a\n+   pointer to it.  */\n+\n+static struct iv_to_split *\n+analyze_iv_to_split_insn (rtx insn)\n+{\n+  rtx set, dest;\n+  struct rtx_iv iv;\n+  struct iv_to_split *ivts;\n+\n+  /* For now we just split the basic induction variables.  Later this may be\n+     extended for example by selecting also addresses of memory references.  */\n+  set = single_set (insn);\n+  if (!set)\n+    return NULL;\n+\n+  dest = SET_DEST (set);\n+  if (!REG_P (dest))\n+    return NULL;\n+\n+  if (!biv_p (insn, dest))\n+    return NULL;\n+\n+  if (!iv_analyze (insn, dest, &iv))\n+    abort ();\n+\n+  if (iv.step == const0_rtx\n+      || iv.mode != iv.extend_mode)\n+    return NULL;\n+\n+  /* Record the insn to split.  */\n+  ivts = xmalloc (sizeof (struct iv_to_split));\n+  ivts->insn = insn;\n+  ivts->base_var = NULL_RTX;\n+  ivts->step = iv.step;\n+  ivts->n_loc = 1;\n+  ivts->loc[0] = 1;\n+  \n+  return ivts;\n+}\n+\n+/* Determines which of induction variables in LOOP to split.\n+   Return a SPLIT_IVS_INFO struct with the hash table filled\n+   with all insns to split IVs in.  The FIRST_NEW_BLOCK field\n+   is undefined for the return value.  */\n+\n+static struct split_ivs_info *\n+analyze_ivs_to_split (struct loop *loop)\n+{\n+  basic_block *body, bb;\n+  unsigned i;\n+  struct split_ivs_info *si_info = xcalloc (1, sizeof (struct split_ivs_info));\n+  rtx insn;\n+  struct iv_to_split *ivts;\n+  PTR *slot;\n+\n+  si_info->insns_to_split = htab_create (5 * loop->num_nodes,\n+\t\t\t\t\t si_info_hash, si_info_eq, free);\n+\n+  iv_analysis_loop_init (loop);\n+\n+  body = get_loop_body (loop);\n+  for (i = 0; i < loop->num_nodes; i++)\n+    {\n+      bb = body[i];\n+      if (!dominated_by_p (CDI_DOMINATORS, loop->latch, bb))\n+\tcontinue;\n+\n+      FOR_BB_INSNS (bb, insn)\n+\t{\n+\t  if (!INSN_P (insn))\n+\t    continue;\n+\n+\t  ivts = analyze_iv_to_split_insn (insn);\n+\n+\t  if (!ivts)\n+\t    continue;\n+\n+\t  slot = htab_find_slot (si_info->insns_to_split, ivts, INSERT);\n+\t  *slot = ivts;\n+\t}\n+    }\n+\n+  free (body);\n+\n+  return si_info;\n+}\n+\n+/* Called just before loop duplication.  Records start of duplicated area\n+   to SI_INFO.  */\n+\n+static void \n+si_info_start_duplication (struct split_ivs_info *si_info)\n+{\n+  if (si_info)\n+    si_info->first_new_block = last_basic_block;\n+}\n+\n+/* Determine the number of iterations between initialization of the base\n+   variable and the current copy (N_COPY).  N_COPIES is the total number\n+   of newly created copies.  UNROLLING is true if we are unrolling\n+   (not peeling) the loop.  */\n+\n+static unsigned\n+determine_split_iv_delta (unsigned n_copy, unsigned n_copies, bool unrolling)\n+{\n+  if (unrolling)\n+    {\n+      /* If we are unrolling, initialization is done in the original loop\n+\t body (number 0).  */\n+      return n_copy;\n+    }\n+  else\n+    {\n+      /* If we are peeling, the copy in that the initialization occurs has\n+\t number 1.  The original loop (number 0) is the last.  */\n+      if (n_copy)\n+\treturn n_copy - 1;\n+      else\n+\treturn n_copies;\n+    }\n+}\n+\n+/* Locate in EXPR the expression corresponding to the location recorded\n+   in IVTS, and return a pointer to the RTX for this location.  */\n+\n+static rtx *\n+get_ivts_expr (rtx expr, struct iv_to_split *ivts)\n+{\n+  unsigned i;\n+  rtx *ret = &expr;\n+\n+  for (i = 0; i < ivts->n_loc; i++)\n+    ret = &XEXP (*ret, ivts->loc[i]);\n+\n+  return ret;\n+}\n+\n+/* Allocate basic variable for the induction variable chain.  Callback for\n+   htab_traverse.  */\n+\n+static int\n+allocate_basic_variable (void **slot, void *data ATTRIBUTE_UNUSED)\n+{\n+  struct iv_to_split *ivts = *slot;\n+  rtx expr = *get_ivts_expr (single_set (ivts->insn), ivts);\n+\n+  ivts->base_var = gen_reg_rtx (GET_MODE (expr));\n+\n+  return 1;\n+}\n+\n+/* Insert initialization of basic variable of IVTS before INSN, taking\n+   the initial value from INSN.  */\n+\n+static void\n+insert_base_initialization (struct iv_to_split *ivts, rtx insn)\n+{\n+  rtx expr = copy_rtx (*get_ivts_expr (single_set (insn), ivts));\n+  rtx seq;\n+\n+  start_sequence ();\n+  expr = force_operand (expr, ivts->base_var);\n+  if (expr != ivts->base_var)\n+    emit_move_insn (ivts->base_var, expr);\n+  seq = get_insns ();\n+  end_sequence ();\n+\n+  emit_insn_before (seq, insn);\n+}\n+\n+/* Replace the use of induction variable described in IVTS in INSN\n+   by base variable + DELTA * step.  */\n+\n+static void\n+split_iv (struct iv_to_split *ivts, rtx insn, unsigned delta)\n+{\n+  rtx expr, *loc, seq, incr, var;\n+  enum machine_mode mode = GET_MODE (ivts->base_var);\n+  rtx src, dest, set;\n+\n+  /* Construct base + DELTA * step.  */\n+  if (!delta)\n+    expr = ivts->base_var;\n+  else\n+    {\n+      incr = simplify_gen_binary (MULT, mode,\n+\t\t\t\t  ivts->step, gen_int_mode (delta, mode));\n+      expr = simplify_gen_binary (PLUS, GET_MODE (ivts->base_var),\n+\t\t\t\t  ivts->base_var, incr);\n+    }\n+\n+  /* Figure out where to do the replacement.  */\n+  loc = get_ivts_expr (single_set (insn), ivts);\n+\n+  /* If we can make the replacement right away, we're done.  */\n+  if (validate_change (insn, loc, expr, 0))\n+    return;\n+\n+  /* Otherwise, force EXPR into a register and try again.  */\n+  start_sequence ();\n+  var = gen_reg_rtx (mode);\n+  expr = force_operand (expr, var);\n+  if (expr != var)\n+    emit_move_insn (var, expr);\n+  seq = get_insns ();\n+  end_sequence ();\n+  emit_insn_before (seq, insn);\n+      \n+  if (validate_change (insn, loc, var, 0))\n+    return;\n+\n+  /* The last chance.  Try recreating the assignment in insn\n+     completely from scratch.  */\n+  set = single_set (insn);\n+  gcc_assert (set);\n+\n+  start_sequence ();\n+  *loc = var;\n+  src = copy_rtx (SET_SRC (set));\n+  dest = copy_rtx (SET_DEST (set));\n+  src = force_operand (src, dest);\n+  if (src != dest)\n+    emit_move_insn (dest, src);\n+  seq = get_insns ();\n+  end_sequence ();\n+     \n+  emit_insn_before (seq, insn);\n+  delete_insn (insn);\n+}\n+\n+/* Splits induction variables (that are marked in SI_INFO) in copies of loop.\n+   I.e. replace\n+\n+   i = i + 1;\n+   ...\n+   i = i + 1;\n+   ...\n+   i = i + 1;\n+   ...\n+\n+   type chains by\n+\n+   i0 = i + 1\n+   ...\n+   i = i0 + 1\n+   ...\n+   i = i0 + 2\n+   ...\n+\n+   UNROLLING is true if we unrolled (not peeled) the loop.\n+   REWRITE_ORIGINAL_BODY is true if we should also rewrite the original body of\n+   the loop (as it should happen in complete unrolling, but not in ordinary\n+   peeling of the loop).  */\n+\n+static void\n+split_ivs_in_copies (struct split_ivs_info *si_info, unsigned n_copies,\n+\t\t     bool unrolling, bool rewrite_original_loop)\n+{\n+  unsigned i, delta;\n+  basic_block bb, orig_bb;\n+  rtx insn, orig_insn, next;\n+  struct iv_to_split ivts_templ, *ivts;\n+\n+  /* Sanity check -- we need to put initialization in the original loop\n+     body.  */\n+  gcc_assert (!unrolling || rewrite_original_loop);\n+\n+  /* Allocate the basic variables (i0).  */\n+  htab_traverse (si_info->insns_to_split, allocate_basic_variable, NULL);\n+\n+  for (i = si_info->first_new_block; i < (unsigned) last_basic_block; i++)\n+    {\n+      bb = BASIC_BLOCK (i);\n+      orig_bb = bb->rbi->original;\n+\n+      delta = determine_split_iv_delta (bb->rbi->copy_number, n_copies,\n+\t\t\t\t\tunrolling);\n+      orig_insn = BB_HEAD (orig_bb);\n+      for (insn = BB_HEAD (bb); insn != NEXT_INSN (BB_END (bb)); insn = next)\n+\t{\n+\t  next = NEXT_INSN (insn);\n+\t  if (!INSN_P (insn))\n+\t    continue;\n+\n+\t  while (!INSN_P (orig_insn))\n+\t    orig_insn = NEXT_INSN (orig_insn);\n+\n+\t  ivts_templ.insn = orig_insn;\n+\t  ivts = htab_find (si_info->insns_to_split, &ivts_templ);\n+\t  if (ivts)\n+\t    {\n+\n+#ifdef ENABLE_CHECKING\n+\t      if (!rtx_equal_p (PATTERN (insn), PATTERN (orig_insn)))\n+\t\tabort ();\n+#endif\n+\n+\t      if (!delta)\n+\t\tinsert_base_initialization (ivts, insn);\n+\t      split_iv (ivts, insn, delta);\n+\t    }\n+\t  orig_insn = NEXT_INSN (orig_insn);\n+\t}\n+    }\n+\n+  if (!rewrite_original_loop)\n+    return;\n+\n+  /* Rewrite also the original loop body.  Find them as originals of the blocks\n+     in the last copied iteration, i.e. those that have\n+     bb->rbi->original->copy == bb.  */\n+  for (i = si_info->first_new_block; i < (unsigned) last_basic_block; i++)\n+    {\n+      bb = BASIC_BLOCK (i);\n+      orig_bb = bb->rbi->original;\n+      if (orig_bb->rbi->copy != bb)\n+\tcontinue;\n+\n+      delta = determine_split_iv_delta (0, n_copies, unrolling);\n+      for (orig_insn = BB_HEAD (orig_bb);\n+\t   orig_insn != NEXT_INSN (BB_END (bb));\n+\t   orig_insn = next)\n+\t{\n+\t  next = NEXT_INSN (orig_insn);\n+\n+\t  if (!INSN_P (orig_insn))\n+\t    continue;\n+\n+\t  ivts_templ.insn = orig_insn;\n+\t  ivts = htab_find (si_info->insns_to_split, &ivts_templ);\n+\t  if (!ivts)\n+\t    continue;\n+\n+\t  if (!delta)\n+\t    insert_base_initialization (ivts, orig_insn);\n+\t  split_iv (ivts, orig_insn, delta);\n+\t}\n+    }\n+}\n+\n+/* Release SI_INFO.  */\n+\n+static void\n+free_si_info (struct split_ivs_info *si_info)\n+{\n+  htab_delete (si_info->insns_to_split);\n+  free (si_info);\n+}"}]}