{"sha": "8627cc158dc97db6469d7ca0099da712c1a37189", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODYyN2NjMTU4ZGM5N2RiNjQ2OWQ3Y2EwMDk5ZGE3MTJjMWEzNzE4OQ==", "commit": {"author": {"name": "Adam Megacz", "email": "adam@xwt.org", "date": "2002-02-02T04:27:34Z"}, "committer": {"name": "Adam Megacz", "email": "megacz@gcc.gnu.org", "date": "2002-02-02T04:27:34Z"}, "message": "win32-threads.h (_Jv_ConditionVariable_t): Now a struct, to enable safer wait() algorithm.\n\n2002-02-01  Adam Megacz <adam@xwt.org>\n\n        * include/win32-threads.h (_Jv_ConditionVariable_t): Now a struct, to\n\tenable safer wait() algorithm.\n\t(_Jv_CondWait, _Jv_CondInit, _Jv_CondDestroy, _Jv_CondNotify,\n\t_Jv_CondNotifyAll): Implementations moved to win32-threads.cc.\n\t(_Jv_MutexInit, _Jv_HaveMutexDestroy, _Jv_MutexUnlock,\n\t_Jv_MutexLock, _Jv_ThreadYield): Reimplement using CRITICAL_SECTIONs\n\tinstead of mutex.\n\t(_Jv_ThreadYield): Don't call Sleep(), because it crashes win98.\n\nFrom-SVN: r49427", "tree": {"sha": "b45c54ba65df5ae1f0bd56edb59f62779c6eaeb3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b45c54ba65df5ae1f0bd56edb59f62779c6eaeb3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8627cc158dc97db6469d7ca0099da712c1a37189", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8627cc158dc97db6469d7ca0099da712c1a37189", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8627cc158dc97db6469d7ca0099da712c1a37189", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8627cc158dc97db6469d7ca0099da712c1a37189/comments", "author": null, "committer": null, "parents": [{"sha": "7e57448e82dc78b2dde1684f4f33e06b77dc7dde", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e57448e82dc78b2dde1684f4f33e06b77dc7dde", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7e57448e82dc78b2dde1684f4f33e06b77dc7dde"}], "stats": {"total": 93, "additions": 42, "deletions": 51}, "files": [{"sha": "5303f4377c567bec852588fa52af53374d50adfc", "filename": "libjava/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8627cc158dc97db6469d7ca0099da712c1a37189/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8627cc158dc97db6469d7ca0099da712c1a37189/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=8627cc158dc97db6469d7ca0099da712c1a37189", "patch": "@@ -1,3 +1,14 @@\n+2002-02-01  Adam Megacz <adam@xwt.org>\n+\n+        * include/win32-threads.h (_Jv_ConditionVariable_t): Now a struct, to\n+\tenable safer wait() algorithm.\n+\t(_Jv_CondWait, _Jv_CondInit, _Jv_CondDestroy, _Jv_CondNotify,\n+\t_Jv_CondNotifyAll): Implementations moved to win32-threads.cc.\n+\t(_Jv_MutexInit, _Jv_HaveMutexDestroy, _Jv_MutexUnlock,\n+\t_Jv_MutexLock, _Jv_ThreadYield): Reimplement using CRITICAL_SECTIONs\n+\tinstead of mutex.\n+\t(_Jv_ThreadYield): Don't call Sleep(), because it crashes win98.\n+\n 2002-02-01  Adam Megacz <adam@xwt.org>\n \n \t* configure.in: Added support for mingw."}, {"sha": "21fdd0e7aa137d0367d8a7b6254267149100f23b", "filename": "libjava/include/win32-threads.h", "status": "modified", "additions": 31, "deletions": 51, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8627cc158dc97db6469d7ca0099da712c1a37189/libjava%2Finclude%2Fwin32-threads.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8627cc158dc97db6469d7ca0099da712c1a37189/libjava%2Finclude%2Fwin32-threads.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fwin32-threads.h?ref=8627cc158dc97db6469d7ca0099da712c1a37189", "patch": "@@ -18,8 +18,13 @@ details.  */\n // Typedefs.\n //\n \n-typedef HANDLE _Jv_ConditionVariable_t;\n-typedef HANDLE _Jv_Mutex_t;\n+typedef struct _Jv_ConditionVariable_t {\n+  HANDLE ev[2];\n+  CRITICAL_SECTION count_mutex;\n+  int blocked_count;\n+};\n+\n+typedef CRITICAL_SECTION _Jv_Mutex_t;\n \n typedef struct\n {\n@@ -34,63 +39,39 @@ typedef void _Jv_ThreadStartFunc (java::lang::Thread *);\n // Condition variables.\n //\n \n-inline void\n-_Jv_CondInit (_Jv_ConditionVariable_t *cv)\n-{\n-  *cv = CreateEvent (NULL, 0, 0, NULL);\n-}\n-\n-#define _Jv_HaveCondDestroy\n-\n-inline void\n-_Jv_CondDestroy (_Jv_ConditionVariable_t *cv)\n-{\n-  CloseHandle (*cv);\n-  cv = NULL;\n-}\n-\n-int _Jv_CondWait (_Jv_ConditionVariable_t *cv, _Jv_Mutex_t *mu,\n-\t\t  jlong millis, jint nanos);\n-\n-inline int\n-_Jv_CondNotify (_Jv_ConditionVariable_t *cv, _Jv_Mutex_t *)\n-{\n-  // FIXME: check for mutex ownership?\n-  return PulseEvent (*cv) ? 0 : _JV_NOT_OWNER;        // FIXME?\n-}\n-\n-inline int\n-_Jv_CondNotifyAll (_Jv_ConditionVariable_t *cv, _Jv_Mutex_t *)\n-{\n-  // FIXME: check for mutex ownership?\n-  return PulseEvent (*cv) ? 0 : _JV_NOT_OWNER;        // FIXME?\n-}\n+int _Jv_CondWait (_Jv_ConditionVariable_t *cv, _Jv_Mutex_t *mu, jlong millis, jint nanos);\n+void _Jv_CondInit (_Jv_ConditionVariable_t *cv);\n+void _Jv_CondDestroy (_Jv_ConditionVariable_t *cv);\n+int _Jv_CondNotify (_Jv_ConditionVariable_t *cv, _Jv_Mutex_t *);\n+int _Jv_CondNotifyAll (_Jv_ConditionVariable_t *cv, _Jv_Mutex_t *);\n \n //\n // Mutexes.\n+// We use CRITICAL_SECTIONs instead of CreateMutex() for better performance\n //\n \n-inline void\n-_Jv_MutexInit (_Jv_Mutex_t *mu)\n+inline void _Jv_MutexInit (_Jv_Mutex_t *mu)\n {\n-  *mu = CreateMutex (NULL, 0, NULL);\n+  InitializeCriticalSection(mu);\n }\n \n #define _Jv_HaveMutexDestroy\n-\n-inline void\n-_Jv_MutexDestroy (_Jv_Mutex_t *mu)\n+inline void _Jv_MutexDestroy (_Jv_Mutex_t *mu)\n {\n-  CloseHandle (*mu);\n+  DeleteCriticalSection(mu);\n   mu = NULL;\n }\n \n-int _Jv_MutexLock (_Jv_Mutex_t *mu);\n+inline int _Jv_MutexUnlock (_Jv_Mutex_t *mu)\n+{\n+  LeaveCriticalSection(mu);\n+  return 0;\n+}\n \n-inline int\n-_Jv_MutexUnlock (_Jv_Mutex_t *mu)\n+inline int _Jv_MutexLock (_Jv_Mutex_t *mu)\n {\n-  return ReleaseMutex(*mu) ? 0 : GetLastError();        // FIXME: Map error code?\n+  EnterCriticalSection(mu);\n+  return 0;\n }\n \n //\n@@ -101,24 +82,23 @@ void _Jv_InitThreads (void);\n _Jv_Thread_t *_Jv_ThreadInitData (java::lang::Thread *thread);\n void _Jv_ThreadDestroyData (_Jv_Thread_t *data);\n \n-inline java::lang::Thread *\n-_Jv_ThreadCurrent (void)\n+inline java::lang::Thread* _Jv_ThreadCurrent (void)\n {\n   extern DWORD _Jv_ThreadKey;\n   return (java::lang::Thread *) TlsGetValue(_Jv_ThreadKey);\n }\n \n-inline _Jv_Thread_t *\n-_Jv_ThreadCurrentData (void)\n+inline _Jv_Thread_t *_Jv_ThreadCurrentData(void)\n {\n   extern DWORD _Jv_ThreadDataKey;\n   return (_Jv_Thread_t *) TlsGetValue(_Jv_ThreadDataKey);\n }\n \n-inline void\n-_Jv_ThreadYield (void)\n+inline void _Jv_ThreadYield (void)\n {\n-  Sleep (0);\n+  // FIXME: win98 freezes hard (OS hang) when we use this --\n+  //        for now, we simply don't yield\n+  // Sleep (0);\n }\n \n void _Jv_ThreadRegister (_Jv_Thread_t *data);"}]}