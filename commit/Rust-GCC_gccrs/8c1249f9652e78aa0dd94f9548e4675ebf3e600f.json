{"sha": "8c1249f9652e78aa0dd94f9548e4675ebf3e600f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGMxMjQ5Zjk2NTJlNzhhYTBkZDk0Zjk1NDhlNDY3NWViZjNlNjAwZg==", "commit": {"author": {"name": "Peter Bergner", "email": "bergner@vnet.ibm.com", "date": "2006-12-13T19:19:03Z"}, "committer": {"name": "Peter Bergner", "email": "bergner@gcc.gnu.org", "date": "2006-12-13T19:19:03Z"}, "message": "re PR middle-end/30191 (GCC error: in eliminate_regs_in_insn, at reload1.c:3126)\n\n        PR middle-end/30191\n        Revert:\n        * reload1.c (eliminate_regs_in_insn): Merge the plus_src \"else\" and\n        the offset == 0 \"then\" clauses.\n        * config/rs6000/predicates.md (gpc_reg_operand): Check for\n        reload_in_progress.\n\nFrom-SVN: r119844", "tree": {"sha": "a3f908a3433ea8a7b7170937c4987b77ea227176", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a3f908a3433ea8a7b7170937c4987b77ea227176"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8c1249f9652e78aa0dd94f9548e4675ebf3e600f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c1249f9652e78aa0dd94f9548e4675ebf3e600f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8c1249f9652e78aa0dd94f9548e4675ebf3e600f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c1249f9652e78aa0dd94f9548e4675ebf3e600f/comments", "author": {"login": "peter-bergner", "id": 17504345, "node_id": "MDQ6VXNlcjE3NTA0MzQ1", "avatar_url": "https://avatars.githubusercontent.com/u/17504345?v=4", "gravatar_id": "", "url": "https://api.github.com/users/peter-bergner", "html_url": "https://github.com/peter-bergner", "followers_url": "https://api.github.com/users/peter-bergner/followers", "following_url": "https://api.github.com/users/peter-bergner/following{/other_user}", "gists_url": "https://api.github.com/users/peter-bergner/gists{/gist_id}", "starred_url": "https://api.github.com/users/peter-bergner/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/peter-bergner/subscriptions", "organizations_url": "https://api.github.com/users/peter-bergner/orgs", "repos_url": "https://api.github.com/users/peter-bergner/repos", "events_url": "https://api.github.com/users/peter-bergner/events{/privacy}", "received_events_url": "https://api.github.com/users/peter-bergner/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c53fa1740ae95a29c87a0cff19641657d85eb894", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c53fa1740ae95a29c87a0cff19641657d85eb894", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c53fa1740ae95a29c87a0cff19641657d85eb894"}], "stats": {"total": 45, "additions": 33, "deletions": 12}, "files": [{"sha": "daf8eb7a516adfd4001e00f68dcd1578d4c7649b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c1249f9652e78aa0dd94f9548e4675ebf3e600f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c1249f9652e78aa0dd94f9548e4675ebf3e600f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8c1249f9652e78aa0dd94f9548e4675ebf3e600f", "patch": "@@ -1,3 +1,12 @@\n+2006-12-13  Peter Bergner  <bergner@vnet.ibm.com>\n+\n+\tPR middle-end/30191\n+\tRevert:\n+\t* reload1.c (eliminate_regs_in_insn): Merge the plus_src \"else\" and\n+\tthe offset == 0 \"then\" clauses.\n+\t* config/rs6000/predicates.md (gpc_reg_operand): Check for\n+\treload_in_progress.\n+\n 2006-12-13  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* config/i386/i386.h (FIRST_PSEUDO_REGISTER): Define to 53."}, {"sha": "6aefe2dd0c989835466d6a58bc2e46a6ecf732ed", "filename": "gcc/config/rs6000/predicates.md", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c1249f9652e78aa0dd94f9548e4675ebf3e600f/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c1249f9652e78aa0dd94f9548e4675ebf3e600f/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fpredicates.md?ref=8c1249f9652e78aa0dd94f9548e4675ebf3e600f", "patch": "@@ -81,13 +81,10 @@\n   (and (match_code \"const_int\")\n        (match_test \"INTVAL (op) > 0 && exact_log2 (INTVAL (op)) >= 0\")))\n \n-;; Return 1 if op is a register that is not special.  We accept anything\n-;; during reload_in_progress since eliminate_regs_in_insn() sometimes\n-;; creates invalid insns which will be fixed up later in reload.\n+;; Return 1 if op is a register that is not special.\n (define_predicate \"gpc_reg_operand\"\n    (and (match_operand 0 \"register_operand\")\n-\t(match_test \"(reload_in_progress\n-\t\t      || GET_CODE (op) != REG\n+\t(match_test \"(GET_CODE (op) != REG\n \t\t      || (REGNO (op) >= ARG_POINTER_REGNUM\n \t\t\t  && !XER_REGNO_P (REGNO (op)))\n \t\t      || REGNO (op) < MQ_REGNO)"}, {"sha": "454383581e8b6ece28253276a9ca6dbeebcd608f", "filename": "gcc/reload1.c", "status": "modified", "additions": 22, "deletions": 7, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c1249f9652e78aa0dd94f9548e4675ebf3e600f/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c1249f9652e78aa0dd94f9548e4675ebf3e600f/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=8c1249f9652e78aa0dd94f9548e4675ebf3e600f", "patch": "@@ -3098,12 +3098,7 @@ eliminate_regs_in_insn (rtx insn, int replace)\n \t    if (GET_CODE (XEXP (plus_cst_src, 0)) == SUBREG)\n \t      to_rtx = gen_lowpart (GET_MODE (XEXP (plus_cst_src, 0)),\n \t\t\t\t    to_rtx);\n-\t    /* If we have a nonzero offset, and the source is already\n-\t       a simple REG, the following transformation would\n-\t       increase the cost of the insn by replacing a simple REG\n-\t       with (plus (reg sp) CST).  So try only when we already\n-\t       had a PLUS before.  */\n-\t    if (offset == 0 || plus_src)\n+\t    if (offset == 0)\n \t      {\n \t\tint num_clobbers;\n \t\t/* We assume here that if we need a PARALLEL with\n@@ -3112,7 +3107,7 @@ eliminate_regs_in_insn (rtx insn, int replace)\n \t\t   There's not much we can do if that doesn't work.  */\n \t\tPATTERN (insn) = gen_rtx_SET (VOIDmode,\n \t\t\t\t\t      SET_DEST (old_set),\n-\t\t\t\t\t      plus_constant (to_rtx, offset));\n+\t\t\t\t\t      to_rtx);\n \t\tnum_clobbers = 0;\n \t\tINSN_CODE (insn) = recog (PATTERN (insn), insn, &num_clobbers);\n \t\tif (num_clobbers)\n@@ -3125,6 +3120,26 @@ eliminate_regs_in_insn (rtx insn, int replace)\n \t\t  }\n \t\tgcc_assert (INSN_CODE (insn) >= 0);\n \t      }\n+\t    /* If we have a nonzero offset, and the source is already\n+\t       a simple REG, the following transformation would\n+\t       increase the cost of the insn by replacing a simple REG\n+\t       with (plus (reg sp) CST).  So try only when we already\n+\t       had a PLUS before.  */\n+\t    else if (plus_src)\n+\t      {\n+\t\tnew_body = old_body;\n+\t\tif (! replace)\n+\t\t  {\n+\t\t    new_body = copy_insn (old_body);\n+\t\t    if (REG_NOTES (insn))\n+\t\t      REG_NOTES (insn) = copy_insn_1 (REG_NOTES (insn));\n+\t\t  }\n+\t\tPATTERN (insn) = new_body;\n+\t\told_set = single_set (insn);\n+\n+\t\tXEXP (SET_SRC (old_set), 0) = to_rtx;\n+\t\tXEXP (SET_SRC (old_set), 1) = GEN_INT (offset);\n+\t      }\n \t    else\n \t      break;\n "}]}