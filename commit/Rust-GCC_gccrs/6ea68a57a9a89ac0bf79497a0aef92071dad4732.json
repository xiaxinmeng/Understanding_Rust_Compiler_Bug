{"sha": "6ea68a57a9a89ac0bf79497a0aef92071dad4732", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmVhNjhhNTdhOWE4OWFjMGJmNzk0OTdhMGFlZjkyMDcxZGFkNDczMg==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1991-12-10T21:28:11Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1991-12-10T21:28:11Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r112", "tree": {"sha": "2d475fcb6a0c438e99cda01fc1f7b38dd63e68b3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2d475fcb6a0c438e99cda01fc1f7b38dd63e68b3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6ea68a57a9a89ac0bf79497a0aef92071dad4732", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ea68a57a9a89ac0bf79497a0aef92071dad4732", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6ea68a57a9a89ac0bf79497a0aef92071dad4732", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ea68a57a9a89ac0bf79497a0aef92071dad4732/comments", "author": null, "committer": null, "parents": [{"sha": "eedb4710a6c82c65caf53ee110fb2e53b29607c7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eedb4710a6c82c65caf53ee110fb2e53b29607c7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eedb4710a6c82c65caf53ee110fb2e53b29607c7"}], "stats": {"total": 994, "additions": 807, "deletions": 187}, "files": [{"sha": "85990d38231b30b01c48c99de95886de717ea1f8", "filename": "gcc/mips-tfile.c", "status": "modified", "additions": 807, "deletions": 187, "changes": 994, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ea68a57a9a89ac0bf79497a0aef92071dad4732/gcc%2Fmips-tfile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ea68a57a9a89ac0bf79497a0aef92071dad4732/gcc%2Fmips-tfile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmips-tfile.c?ref=6ea68a57a9a89ac0bf79497a0aef92071dad4732", "patch": "@@ -640,6 +640,11 @@ typedef char *CPTR_T;\n #define Size_t\t\tunsigned int\n #define Ptrdiff_t\tint\n \n+#define CODE_MASK 0x8F300\n+#define MIPS_IS_STAB(sym) (((sym)->index & 0xFFF00) == CODE_MASK)\n+#define MIPS_MARK_STAB(code) ((code)+CODE_MASK)\n+#define MIPS_UNMARK_STAB(code) ((code)-CODE_MASK)\n+\n /* The following might be called from obstack or malloc,\n    so they can't be static.  */\n \n@@ -652,11 +657,6 @@ extern PTR_T\txcalloc\t\t__proto((Size_t, Size_t));\n extern PTR_T\txrealloc\t__proto((PTR_T, Size_t));\n extern void\txfree\t\t__proto((PTR_T));\n \n-extern PTR_T\tmalloc\t\t__proto((Size_t));\n-extern PTR_T\tcalloc\t\t__proto((Size_t, Size_t));\n-extern PTR_T\trealloc\t\t__proto((PTR_T, Size_t));\n-extern void\tfree\t\t__proto((PTR_T));\n-\n extern void\tfatal();\t/* can't use prototypes here */\n extern void\terror();\n \n@@ -689,6 +689,31 @@ main ()\n #include <signal.h>\n #include <sys/stat.h>\n \n+#ifdef USG\n+#include \"stab.h\"  /* If doing DBX on sysV, use our own stab.h.  */\n+#else\n+#include <stab.h>  /* On BSD, use the system's stab.h.  */\n+#endif /* not USG */\n+\n+#ifdef __GNU_STAB__\n+#define STAB_CODE_TYPE enum __stab_debug_code\n+#else\n+#define STAB_CODE_TYPE int\n+#endif\n+\n+#ifdef _OSF_SOURCE\n+#define HAS_STDLIB_H\n+#define HAS_UNISTD_H\n+#endif\n+\n+#ifdef HAS_STDLIB_H\n+#include <stdlib.h>\n+#endif\n+\n+#ifdef HAS_UNISTD_H\n+#include <unistd.h>\n+#endif\n+\n #ifndef errno\n extern int errno;\t\t\t/* MIPS errno.h doesn't declare this */\n #endif\n@@ -887,6 +912,21 @@ typedef enum hash_state {\n   hash_record\t= 2\t\t/* ok to record hash, but don't use prev. */\n } hash_state_t;\n \n+\n+/* Types of different sized allocation requests.  */\n+enum alloc_type {\n+  alloc_type_none,\t\t/* dummy value */\n+  alloc_type_scope,\t\t/* nested scopes linked list */\n+  alloc_type_vlinks,\t\t/* glue linking pages in varray */\n+  alloc_type_shash,\t\t/* string hash element */\n+  alloc_type_thash,\t\t/* type hash element */\n+  alloc_type_tag,\t\t/* struct/union/tag element */\n+  alloc_type_forward,\t\t/* element to hold unknown tag */\n+  alloc_type_thead,\t\t/* head of type hash list */\n+  alloc_type_varray,\t\t/* general varray allocation */\n+  alloc_type_last\t\t/* last+1 element for array bounds */\n+};\n+\n \f\n #define WORD_ALIGN(x)  (((x) + 3) & ~3)\n #define DWORD_ALIGN(x) (((x) + 7) & ~7)\n@@ -959,6 +999,7 @@ typedef unsigned long symint_t;\n /* Linked list support for nested scopes (file, block, structure, etc.).  */\n typedef struct scope {\n   struct scope\t*prev;\t\t/* previous scope level */\n+  struct scope\t*free;\t\t/* free list pointer */\n   SYMR\t\t*lsym;\t\t/* pointer to local symbol node */\n   symint_t\t lnumber;\t/* lsym index */\n   st_t\t\t type;\t\t/* type of the node */\n@@ -968,6 +1009,7 @@ typedef struct scope {\n /* Forward reference list for tags referenced, but not yet defined.  */\n typedef struct forward {\n   struct forward *next;\t\t/* next forward reference */\n+  struct forward *free;\t\t/* free list pointer */\n   AUXU\t\t *ifd_ptr;\t/* pointer to store file index */\n   AUXU\t\t *index_ptr;\t/* pointer to store symbol index */\n   AUXU\t\t *type_ptr;\t/* pointer to munge type info */\n@@ -977,6 +1019,7 @@ typedef struct forward {\n /* Linked list support for tags.  The first tag in the list is always\n    the current tag for that block.  */\n typedef struct tag {\n+  struct tag\t *free;\t\t/* free list pointer */\n   struct shash\t *hash_ptr;\t/* pointer to the hash table head */\n   struct tag\t *same_name;\t/* tag with same name in outer scope */\n   struct tag\t *same_block;\t/* next tag defined in the same block.  */\n@@ -986,17 +1029,27 @@ typedef struct tag {\n   symint_t\t  index;\t/* index within file's local symbols */\n } tag_t;\n \n+\n /* Head of a block's linked list of tags.  */\n typedef struct thead {\n   struct thead\t*prev;\t\t/* previous block */\n+  struct thead\t*free;\t\t/* free list pointer */\n   struct tag\t*first_tag;\t/* first tag in block defined */\n } thead_t;\n \n \n+/* Union containing pointers to each the small structures which are freed up.  */\n+typedef union small_free {\n+  scope_t\t*f_scope;\t/* scope structure */\n+  thead_t\t*f_thead;\t/* tag head structure */\n+  tag_t\t\t*f_tag;\t\t/* tag element structure */\n+  forward_t\t*f_forward;\t/* forward tag reference */\n+} small_free_t;\n+\n+\n /* String hash table support.  The size of the hash table must fit\n    within a page.  */\n \n-\n #ifndef SHASH_SIZE\n #define SHASH_SIZE 1009\n #endif\n@@ -1010,6 +1063,7 @@ typedef struct shash {\n   symint_t\t index;\t\t/* index within string table */\n   EXTR\t\t*esym_ptr;\t/* global symbol pointer */\n   SYMR\t\t*sym_ptr;\t/* local symbol pointer */\n+  SYMR\t\t*end_ptr;\t/* symbol pointer to end block */\n   tag_t\t\t*tag_ptr;\t/* tag pointer */\n   PDR\t\t*proc_ptr;\t/* procedure descriptor pointer */\n } shash_t;\n@@ -1031,44 +1085,26 @@ typedef struct thash {\n } thash_t;\n \n \n-/* Union of various small structures that are allocated and freed\n-   from the same heap.  */\n-\n-typedef union word8 {\n-  union word8  *prev;\t\t/* previous word8 structure */\n-  scope_t\ts;\t\t/* scope structure */\n-  vlinks_t\tv;\t\t/* varray linked list */\n-  shash_t\tsh;\t\t/* string hash linked list */\n-  thash_t\tth;\t\t/* type hash linked list */\n-  tag_t\t\tt;\t\t/* tag structure */\n-  forward_t\tf;\t\t/* forward tag references */\n-  thead_t\tthead;\t\t/* thead strcture */\n-  long\t\twords[8];\t/* words to zero out when allocating */\n-} word8_t;\n-\n-\n /* Extended file descriptor that contains all of the support necessary\n    to add things to each file separately.  */\n typedef struct efdr {\n-  FDR\t   fdr;\t\t\t/* File header to be written out */\n-  FDR\t  *orig_fdr;\t\t/* original file header */\n-  char\t  *name;\t\t/* filename */\n-  int\t   name_len;\t\t/* length of the filename */\n-  symint_t void_type;\t\t/* aux. pointer to 'void' type */\n-  symint_t int_type;\t\t/* aux. pointer to 'int' type */\n-  scope_t *cur_scope;\t\t/* current nested scopes */\n-  symint_t file_index;\t\t/* current file number */\n-  int\t   nested_scopes;\t/* # nested scopes */\n-  varray_t strings;\t\t/* local strings */\n-  varray_t symbols;\t\t/* local symbols */\n-  varray_t procs;\t\t/* procedures */\n-  varray_t aux_syms;\t\t/* auxiliary symbols */\n-\n-  struct efdr *next_file;\t/* next file descriptor */\n-\n+  FDR\t\t fdr;\t\t/* File header to be written out */\n+  FDR\t\t*orig_fdr;\t/* original file header */\n+  char\t\t*name;\t\t/* filename */\n+  int\t\t name_len;\t/* length of the filename */\n+  symint_t\t void_type;\t/* aux. pointer to 'void' type */\n+  symint_t\t int_type;\t/* aux. pointer to 'int' type */\n+  scope_t\t*cur_scope;\t/* current nested scopes */\n+  symint_t\t file_index;\t/* current file number */\n+  int\t\t nested_scopes;\t/* # nested scopes */\n+  varray_t\t strings;\t/* local strings */\n+  varray_t\t symbols;\t/* local symbols */\n+  varray_t\t procs;\t\t/* procedures */\n+  varray_t\t aux_syms;\t/* auxiliary symbols */\n+  struct efdr\t*next_file;\t/* next file descriptor */\n \t\t\t\t/* string/type hash tables */\n-  shash_t **shash_head;\t\t/* string hash table */\n-  thash_t *thash_head[THASH_SIZE];\n+  shash_t      **shash_head;\t/* string hash table */\n+  thash_t\t*thash_head[THASH_SIZE];\n } efdr_t;\n \n /* Pre-initialized extended file structure.  */\n@@ -1094,7 +1130,7 @@ static efdr_t init_file =\n     langC,\t\t/* lang:\tlanguage for this file */\n     1,\t\t\t/* fMerge:\twhether this file can be merged */\n     0,\t\t\t/* fReadin:\ttrue if read in (not just created) */\n-#ifdef BYTES_BIG_ENDIAN\n+#if BYTES_BIG_ENDIAN\n     1,\t\t\t/* fBigendian:\tif 1, compiled on big endian machine */\n #else\n     0,\t\t\t/* fBigendian:\tif 1, compiled on big endian machine */\n@@ -1125,25 +1161,42 @@ static efdr_t init_file =\n };\n \n \n-static efdr_t *first_file;\t/* first file descriptor */\n-static efdr_t *last_file;\t/* last  file descriptor */\n+static efdr_t *first_file;\t\t\t/* first file descriptor */\n+static efdr_t **last_file_ptr = &first_file;\t/* file descriptor tail */\n \n \n /* Union of various things that are held in pages.  */\n typedef union page {\n-  char\t\tbyte [ PAGE_SIZE ];\n-  unsigned char\tubyte[ PAGE_SIZE ];\n-  efdr_t\tfile [ PAGE_SIZE / sizeof (efdr_t)  ];\n-  FDR\t\tofile[ PAGE_SIZE / sizeof (FDR)     ];\n-  PDR\t\tproc [ PAGE_SIZE / sizeof (PDR)     ];\n-  SYMR\t\tsym  [ PAGE_SIZE / sizeof (SYMR)    ];\n-  EXTR\t\tesym [ PAGE_SIZE / sizeof (EXTR)    ];\n-  AUXU\t\taux  [ PAGE_SIZE / sizeof (AUXU)    ];\n-  DNR\t\tdense[ PAGE_SIZE / sizeof (DNR)     ];\n-  word8_t\tword8[ PAGE_SIZE / sizeof (word8_t) ];\n+  char\t\tbyte\t[ PAGE_SIZE ];\n+  unsigned char\tubyte\t[ PAGE_SIZE ];\n+  efdr_t\tfile\t[ PAGE_SIZE / sizeof (efdr_t)\t ];\n+  FDR\t\tofile\t[ PAGE_SIZE / sizeof (FDR)\t ];\n+  PDR\t\tproc\t[ PAGE_SIZE / sizeof (PDR)\t ];\n+  SYMR\t\tsym\t[ PAGE_SIZE / sizeof (SYMR)\t ];\n+  EXTR\t\tesym\t[ PAGE_SIZE / sizeof (EXTR)\t ];\n+  AUXU\t\taux\t[ PAGE_SIZE / sizeof (AUXU)\t ];\n+  DNR\t\tdense\t[ PAGE_SIZE / sizeof (DNR)\t ];\n+  scope_t\tscope\t[ PAGE_SIZE / sizeof (scope_t)\t ];\n+  vlinks_t\tvlinks\t[ PAGE_SIZE / sizeof (vlinks_t)\t ];\n+  shash_t\tshash\t[ PAGE_SIZE / sizeof (shash_t)\t ];\n+  thash_t\tthash\t[ PAGE_SIZE / sizeof (thash_t)\t ];\n+  tag_t\t\ttag\t[ PAGE_SIZE / sizeof (tag_t)\t ];\n+  forward_t\tforward\t[ PAGE_SIZE / sizeof (forward_t) ];\n+  thead_t\tthead\t[ PAGE_SIZE / sizeof (thead_t)\t ];\n } page_t;\n \n \n+/* Structure holding allocation information for small sized structures.  */\n+typedef struct alloc_info {\n+  char\t\t*alloc_name;\t/* name of this allocation type (must be first) */\n+  page_t\t*cur_page;\t/* current page being allocated from */\n+  small_free_t\t free_list;\t/* current free list if any */\n+  int\t\t unallocated;\t/* number of elements unallocated on page */\n+  int\t\t total_alloc;\t/* total number of allocations */\n+  int\t\t total_free;\t/* total number of frees */\n+  int\t\t total_pages;\t/* total number of pages allocated */\n+} alloc_info_t;\n+\n /* Type information collected together.  */\n typedef struct type_info {\n   bt_t\t      basic_type;\t\t/* basic type */\n@@ -1482,7 +1535,10 @@ static tq_t map_coff_derived_type[ (int)DT_MAX ] = {\n };\n \n \n+/* Keep track of different sized allocation requests.  */\n+static alloc_info_t alloc_counts[ (int)alloc_type_last ];\n \n+\f\n /* Pointers and such to the original symbol table that is read in.  */\n static struct filehdr orig_file_header;\t\t/* global object file header */\n \n@@ -1520,6 +1576,8 @@ static EXTR\t*orig_ext_syms;\t\t\t/* external symbols */\n static HDRR\tsymbolic_header;\t\t/* symbolic header */\n static efdr_t  *cur_file_ptr\t= (efdr_t *) 0;\t/* current file desc. header */\n static PDR     *cur_proc_ptr\t= (PDR *) 0;\t/* current procedure header */\n+static SYMR    *cur_oproc_begin\t= (SYMR *) 0;\t/* original proc. sym begin info */\n+static SYMR    *cur_oproc_end\t= (SYMR *) 0;\t/* original proc. sym end info */\n static PDR     *cur_oproc_ptr\t= (PDR *) 0;\t/* current original procedure*/\n static thead_t *cur_tag_head\t= (thead_t *)0;\t/* current tag head */\n static long\tfile_offset\t= 0;\t\t/* current file offset */\n@@ -1541,6 +1599,14 @@ static int\thad_errors\t= 0;\t\t/* != 0 if errors were found */\n static int\trename_output\t= 0;\t\t/* != 0 if rename output file*/\n static int\tdelete_input\t= 0;\t\t/* != 0 if delete input after done */\n \n+\n+/* Pseudo symbol to use when putting stabs into the symbol table.  */\n+#ifndef STABS_SYMBOL\n+#define STABS_SYMBOL \"@stabs\"\n+#endif\n+\n+static char stabs_symbol[] = STABS_SYMBOL;\n+\n \f\n /* Forward reference for functions.  See the definition for more details.  */\n \n@@ -1620,6 +1686,10 @@ STATIC void\tparse_def\t__proto((const char *));\n STATIC void\tparse_end\t__proto((const char *));\n STATIC void\tparse_ent\t__proto((const char *));\n STATIC void\tparse_file\t__proto((const char *));\n+STATIC void\tparse_stabs_common\n+\t\t\t\t__proto((const char *, const char *, const char *));\n+STATIC void\tparse_stabs\t__proto((const char *));\n+STATIC void\tparse_stabn\t__proto((const char *));\n STATIC page_t  *read_seek\t__proto((Size_t, off_t, const char *));\n STATIC void\tcopy_object\t__proto((void));\n \n@@ -1637,9 +1707,18 @@ STATIC page_t  *allocate_cluster\n \t\t\t\t__proto((Size_t));\n #endif\n \n-STATIC word8_t *allocate_word8\t__proto((void));\n-STATIC void\tfree_word8\t__proto((word8_t *));\n+STATIC forward_t *allocate_forward\t__proto((void));\n+STATIC scope_t\t *allocate_scope\t__proto((void));\n+STATIC shash_t\t *allocate_shash\t__proto((void));\n+STATIC tag_t\t *allocate_tag\t\t__proto((void));\n+STATIC thash_t\t *allocate_thash\t__proto((void));\n+STATIC thead_t\t *allocate_thead\t__proto((void));\n+STATIC vlinks_t\t *allocate_vlinks\t__proto((void));\n \n+STATIC void\t  free_forward\t\t__proto((forward_t *));\n+STATIC void\t  free_scope\t\t__proto((scope_t *));\n+STATIC void\t  free_tag\t\t__proto((tag_t *));\n+STATIC void\t  free_thead\t\t__proto((thead_t *));\n \n /* Prototypes for library functions used.  */\n #if !defined(NO_LIB_PROTOTYPE) && !defined(_OSF_SOURCE) && !defined(_STDIO_H_)\n@@ -1668,25 +1747,27 @@ extern int    rename\t\t__proto((const char *, const char *));\n extern int    setvbuf\t\t__proto((FILE *, char *, int, int));\n extern int    fputs\t\t__proto((char *, FILE *));\n #endif\n-\n-#ifndef NO_LIB_INTERNALS\n-extern int    _filbuf\t\t__proto((FILE *));\n-extern int    _flsbuf\t\t__proto((int, FILE *));\n-#endif\n #endif\n \n extern char  *sbrk\t\t__proto((int));\n+\n+#ifndef HAS_STDLIB_H\n extern PTR_T  malloc\t\t__proto((Size_t));\n extern PTR_T  calloc\t\t__proto((Size_t, Size_t));\n extern PTR_T  realloc\t\t__proto((PTR_T, Size_t));\n extern void   free\t\t__proto((PTR_T));\n+extern int    getopt\t\t__proto((int, char **, const char *));\n+#endif\n+\n+#ifndef HAS_UNISTD_H\n extern int    close\t\t__proto((int));\n extern int    write\t\t__proto((int, CPTR_T, Size_t));\n extern int    read\t\t__proto((int, PTR_T, Size_t));\n extern long   lseek\t\t__proto((int, long, int));\n extern int    ftruncate\t\t__proto((int, long));\n-extern int    getopt\t\t__proto((int, char **, const char *));\n extern int    fstat\t\t__proto((int, struct stat *));\n+#endif\n+\n extern char  *mktemp\t\t__proto((char *));\n \n extern char *optarg;\n@@ -1718,6 +1799,10 @@ static pseudo_ops_t pseudo_ops[] = {\n   { \".end\",\tsizeof(\".end\")-1,\tparse_end },\n   { \".ent\",\tsizeof(\".ent\")-1,\tparse_ent },\n   { \".file\",\tsizeof(\".file\")-1,\tparse_file },\n+  { \"#.stabs\",\tsizeof(\"#.stabs\")-1,\tparse_stabs },\n+  { \"#.stabn\",\tsizeof(\"#.stabn\")-1,\tparse_stabn },\n+  { \".stabs\",\tsizeof(\".stabs\")-1,\tparse_stabs },\n+  { \".stabn\",\tsizeof(\".stabn\")-1,\tparse_stabn },\n };\n \n \f\n@@ -1727,7 +1812,7 @@ STATIC void\n add_varray_page (vp)\n      varray_t *vp;\t\t\t\t/* varray to add page to */\n {\n-  vlinks_t *new_links = (vlinks_t *) allocate_word8 ();\n+  vlinks_t *new_links = allocate_vlinks ();\n \n #ifdef MALLOC_CHECK\n   if (vp->object_size > 1)\n@@ -1736,6 +1821,9 @@ add_varray_page (vp)\n #endif\n     new_links->datum = allocate_page ();\n \n+  alloc_counts[ (int)alloc_type_varray ].total_alloc++;\n+  alloc_counts[ (int)alloc_type_varray ].total_pages++;\n+\n   new_links->start_index = vp->num_allocated;\n   vp->objects_last_page = 0;\n \n@@ -1817,7 +1905,7 @@ add_string (vp, hash_tbl, start, end_p1, ret_hash)\n \t  add_varray_page (vp);\n \t}\n \n-      hash_ptr = (shash_t *) allocate_word8 ();\n+      hash_ptr = allocate_shash ();\n       hash_ptr->next = hash_tbl[hi];\n       hash_tbl[hi] = hash_ptr;\n \n@@ -1882,10 +1970,14 @@ add_local_symbol (str_start, str_end_p1, type, storage, value, indx)\n \n   ret = vp->num_allocated++;\n \n+  if (MIPS_IS_STAB(psym))\n+    return ret;\n+\n   /* Save the symbol within the hash table if this is a static\n-     item.  */\n-  if (type == st_Global || type == st_Static || type == st_Label\n-      || type == st_Proc || type == st_StaticProc)\n+     item, and it has a name.  */\n+  if (hash_ptr != (shash_t *)0\n+      && (type == st_Global || type == st_Static || type == st_Label\n+\t  || type == st_Proc || type == st_StaticProc))\n     hash_ptr->sym_ptr = psym;\n \n   /* push or pop a scope if appropriate.  */\n@@ -1898,7 +1990,7 @@ add_local_symbol (str_start, str_end_p1, type, storage, value, indx)\n     case st_Proc:\t\t\t/* procedure */\n     case st_StaticProc:\t\t\t/* static procedure */\n     case st_Block:\t\t\t/* begin scope */\n-      pscope = (scope_t *) allocate_word8 ();\n+      pscope = allocate_scope ();\n       pscope->prev = cur_file_ptr->cur_scope;\n       pscope->lsym = psym;\n       pscope->lnumber = ret;\n@@ -1913,7 +2005,7 @@ add_local_symbol (str_start, str_end_p1, type, storage, value, indx)\n \t file types, so that tags can span file boundaries.  */\n       if (type != st_File && storage != sc_Info)\n \t{\n-\t  ptag_head = (thead_t *) allocate_word8 ();\n+\t  ptag_head = allocate_thead ();\n \t  ptag_head->first_tag = 0;\n \t  ptag_head->prev = cur_tag_head;\n \t  cur_tag_head = ptag_head;\n@@ -1948,10 +2040,10 @@ add_local_symbol (str_start, str_end_p1, type, storage, value, indx)\n \n \t\t  ptag_next = ptag->same_block;\n \t\t  ptag->hash_ptr->tag_ptr = ptag->same_name;\n-\t\t  free_word8 ((word8_t *) ptag);\n+\t\t  free_tag (ptag);\n \t\t}\n \n-\t      free_word8 ((word8_t *) ptag_head);\n+\t      free_thead (ptag_head);\n \t    }\n \n \t  cur_file_ptr->cur_scope = pscope->prev;\n@@ -1981,7 +2073,7 @@ add_local_symbol (str_start, str_end_p1, type, storage, value, indx)\n \t\t}\n \t    }\n \n-\t  free_word8 ((word8_t *) pscope);\n+\t  free_scope (pscope);\n \t}\n     }\n \n@@ -2181,7 +2273,7 @@ add_aux_sym_tir (t, state, hash_tbl)\n \n       if (hash_ptr == (thash_t *)0)\n \t{\n-\t  hash_ptr = (thash_t *) allocate_word8 ();\n+\t  hash_ptr = allocate_thash ();\n \t  hash_ptr->next = hash_tbl[hi];\n \t  hash_ptr->type = aux;\n \t  hash_ptr->index = vp->num_allocated;\n@@ -2198,6 +2290,19 @@ add_aux_sym_tir (t, state, hash_tbl)\n \n   ret = vp->num_allocated++;\n \n+  /* Add bitfield length if it exists.\n+     \n+     NOTE:  Mips documentation claims bitfield goes at the end of the\n+     AUX record, but the DECstation compiler emits it here.\n+     (This would only make a difference for enum bitfields.)\n+\n+     Also note:  We use the last size given since gcc may emit 2\n+     for an enum bitfield.  */\n+\n+  if (t->bitfield)\n+    (void) add_aux_sym_symint ((symint_t)t->sizes[t->num_sizes-1]);\n+\n+\n   /* Add tag information if needed.  Structure, union, and enum\n      references add 2 aux symbols: a [file index, symbol index]\n      pointer to the structure type, and the current file index.  */\n@@ -2221,7 +2326,7 @@ add_aux_sym_tir (t, state, hash_tbl)\n \t}\n       else\n \t{\n-\t  register forward_t *forward_ref = (forward_t *) allocate_word8 ();\n+\t  register forward_t *forward_ref = allocate_forward ();\n \n \t  forward_ref->type_ptr = aux_ptr;\n \t  forward_ref->next = t->tag_ptr->forward_ref;\n@@ -2237,11 +2342,6 @@ add_aux_sym_tir (t, state, hash_tbl)\n \t}\n     }\n \n-  /* Add bitfield length if it exists.  */\n-  if (t->bitfield)\n-    (void) add_aux_sym_symint ((symint_t)t->sizes[0]);\n-\n-\n   /* Add information about array bounds if they exist.  */\n   for (i = 0; i < t->num_dims; i++)\n     {\n@@ -2256,6 +2356,9 @@ add_aux_sym_tir (t, state, hash_tbl)\n \t\t\t      : (t->sizes[i] * 8) / t->dimensions[i]);\n     };\n \n+  /* NOTE:  Mips documentation claism that the bitfield width goes here.\n+     But it needs to be emitted earlier. */\n+\n   return ret;\n }\n \n@@ -2295,7 +2398,7 @@ get_tag (tag_start, tag_end_p1, index, basic_type)\n \t\t     tag_end_p1,\n \t\t     &hash_ptr);\n \n-  tag_ptr = (tag_t *) allocate_word8 ();\n+  tag_ptr = allocate_tag ();\n   tag_ptr->forward_ref\t= (forward_t *) 0;\n   tag_ptr->hash_ptr\t= hash_ptr;\n   tag_ptr->same_name\t= hash_ptr->tag_ptr;\n@@ -2362,7 +2465,7 @@ add_unknown_tag (ptag)\n       f_cur->ifd_ptr->isym = file_index;\n       f_cur->index_ptr->rndx.index = sym_index;\n \n-      free_word8 ((word8_t *) f_cur);\n+      free_forward (f_cur);\n     }\n \n   return;\n@@ -2405,13 +2508,17 @@ add_procedure (func_start, func_end_p1)\n     {\n       register PDR *old_proc_ptr = shash_ptr->proc_ptr;\n       register SYMR *sym_ptr = shash_ptr->sym_ptr;\n+      register FDR *orig_fdr = file_ptr->orig_fdr;\n \n       if (old_proc_ptr != (PDR *)0\n \t  && sym_ptr != (SYMR *)0\n \t  && ((st_t)sym_ptr->st == st_Proc || (st_t)sym_ptr->st == st_StaticProc))\n \t{\n-\t  cur_oproc_ptr = old_proc_ptr;\n+\t  cur_oproc_begin = sym_ptr;\n+\t  cur_oproc_end = shash_ptr->end_ptr;\n \t  value = sym_ptr->value;\n+\n+\t  cur_oproc_ptr = old_proc_ptr;\n \t  proc_type = (st_t)sym_ptr->st;\n \t  *new_proc_ptr = *old_proc_ptr;\t/* initialize */\n \t}\n@@ -2424,10 +2531,8 @@ add_procedure (func_start, func_end_p1)\n   new_proc_ptr->isym = file_ptr->symbols.num_allocated;\n \n   /* Push the start of the function.  */\n-  (void) add_local_symbol (func_start,\n-\t\t\t   func_end_p1,\n-\t\t\t   proc_type,\n-\t\t\t   sc_Text,\n+  (void) add_local_symbol (func_start, func_end_p1,\n+\t\t\t   proc_type, sc_Text,\n \t\t\t   value,\n \t\t\t   (symint_t)0);\n }\n@@ -2499,12 +2604,8 @@ add_file (file_start, file_end_p1)\n       file_ptr->name_len = file_end_p1 - file_start;\n \n       /* Update the linked list of file descriptors.  */\n-      if (first_file == (efdr_t *)0)\n-\tfirst_file = file_ptr;\n-      else\n-\tlast_file->next_file = file_ptr;\n-\n-      last_file = file_ptr;\n+      *last_file_ptr = file_ptr;\n+      last_file_ptr = &file_ptr->next_file;\n \n       /* Add void & int types to the file (void should be first to catch\n \t errant 0's within the index fields).  */\n@@ -2717,11 +2818,15 @@ parse_begin (start)\n       return;\n     }\n \n-  (void) add_local_symbol ((const char *)0,\n-\t\t\t   (const char *)0,\n-\t\t\t   st_Block,\n-\t\t\t   sc_Text,\n-\t\t\t   (symint_t)hash_ptr->sym_ptr->value,\n+  if (cur_oproc_begin == (SYMR *)0)\n+    {\n+      error (\"Procedure table %.*s not found for #.begin\", end_p1 - start, start);\n+      return;\n+    }\n+\n+  (void) add_local_symbol ((const char *)0, (const char *)0,\n+\t\t\t   st_Block, sc_Text,\n+\t\t\t   (symint_t)hash_ptr->sym_ptr->value - cur_oproc_begin->value,\n \t\t\t   (symint_t)0);\n }\n \n@@ -2745,7 +2850,7 @@ parse_bend (start)\n \n   if (cur_proc_ptr == (PDR *)0)\n     {\n-      error (\"#.begin directive without a preceeding .ent directive\");\n+      error (\"#.bend directive without a preceeding .ent directive\");\n       return;\n     }\n \n@@ -2759,15 +2864,19 @@ parse_bend (start)\n \n   if (hash_ptr == (shash_t *)0)\n     {\n-      error (\"Label %.*s not found for #.begin\", end_p1 - start, start);\n+      error (\"Label %.*s not found for #.bend\", end_p1 - start, start);\n       return;\n     }\n \n-  (void) add_local_symbol ((const char *)0,\n-\t\t\t   (const char *)0,\n-\t\t\t   st_End,\n-\t\t\t   sc_Text,\n-\t\t\t   (symint_t)hash_ptr->sym_ptr->value,\n+  if (cur_oproc_begin == (SYMR *)0)\n+    {\n+      error (\"Procedure table %.*s not found for #.bend\", end_p1 - start, start);\n+      return;\n+    }\n+\n+  (void) add_local_symbol ((const char *)0, (const char *)0,\n+\t\t\t   st_End, sc_Text,\n+\t\t\t   (symint_t)hash_ptr->sym_ptr->value - cur_oproc_begin->value,\n \t\t\t   (symint_t)0);\n }\n \n@@ -3115,9 +3224,12 @@ parse_def (name_start)\n \t\t  if ((orig_hash_ptr == (shash_t *)0\n \t\t       || orig_hash_ptr->sym_ptr == (SYMR *)0)\n \t\t      && eptr == (EXTR *)0)\n-\t\t    error (\"internal error, %.*s not found in original or external symbol tables\",\n-\t\t\t   arg_end_p1 - arg_start,\n-\t\t\t   arg_start);\n+\t\t    {\n+\t\t      fprintf (stderr, \"warning, %.*s not found in original or external symbol tables, value defaults to 0\\n\",\n+\t\t\t       arg_end_p1 - arg_start,\n+\t\t\t       arg_start);\n+\t\t      value = 0;\n+\t\t    }\n \t\t  else\n \t\t    {\n \t\t      SYMR *ptr = (orig_hash_ptr != (shash_t *)0\n@@ -3290,10 +3402,8 @@ parse_def (name_start)\n       || eptr->asym.st == (int)st_Nil\n       || cur_proc_ptr != (PDR *)0)\n     {\n-      symint_t isym = add_local_symbol (name_start,\n-\t\t\t\t\tname_end_p1,\n-\t\t\t\t\tsymbol_type,\n-\t\t\t\t\tstorage_class,\n+      symint_t isym = add_local_symbol (name_start, name_end_p1,\n+\t\t\t\t\tsymbol_type, storage_class,\n \t\t\t\t\tvalue,\n \t\t\t\t\tindex);\n \n@@ -3321,7 +3431,7 @@ parse_def (name_start)\n \t      f_cur->ifd_ptr->isym = file_index;\n \t      f_cur->index_ptr->rndx.index = isym;\n \n-\t      free_word8 ((word8_t *) f_cur);\n+\t      free_forward (f_cur);\n \t    }\n \n \t  tag_ptr->forward_ref = (forward_t *)0;\n@@ -3389,23 +3499,14 @@ parse_end (start)\n \n   orig_fdr = cur_file_ptr->orig_fdr;\n   value = 0;\n-  if (orig_fdr != (FDR *)0 && cur_oproc_ptr != (PDR *)0)\n-    {\n-      register SYMR *sym_ptr = ORIG_LSYMS (orig_fdr->isymBase + cur_oproc_ptr->isym);\n+  if (orig_fdr != (FDR *)0 && cur_oproc_end != (SYMR *)0)\n+    value = cur_oproc_end->value;\n \n-      if ((st_t)sym_ptr->st == st_Proc\n-\t  || (st_t)sym_ptr->st == st_StaticProc)\n-\t{\n-\t  AUXU *aptr = ORIG_AUX (orig_fdr->iauxBase + sym_ptr->index);\n-\t  symint_t end_index = aptr->isym;\n-\t  value = (ORIG_LSYMS (orig_fdr->isymBase + end_index - 1))->value;\n-\t}\n-    }\n+  else\n+    error (\"Cannot find .end block for %.*s\", end_func_p1 - start_func, start_func);\n \n-  (void) add_local_symbol (start_func,\n-\t\t\t   end_func_p1,\n-\t\t\t   st_End,\n-\t\t\t   sc_Text,\n+  (void) add_local_symbol (start_func, end_func_p1,\n+\t\t\t   st_End, sc_Text,\n \t\t\t   value,\n \t\t\t   (symint_t)0);\n \n@@ -3478,6 +3579,201 @@ parse_file (start)\n   add_file (start_name, end_name_p1);\n }\n \n+\f\n+/* Parse .stabs directives.\n+\n+   .stabs directives have five fields:\n+\t\"string\"\ta string, encoding the type information.\n+\tcode\t\ta numeric code, defined in <stab.h>\n+\t0\t\ta zero\n+\t0\t\ta zero or line number\n+\tvalue\t\ta numeric value or an address.\n+\n+    If the value is relocatable, we transform this into:\n+\tiss\t\tpoints as an index into string space\n+\tvalue\t\tvalue from lookup of the name\n+\tst\t\tst from lookup of the name\n+\tsc\t\tsc from lookup of the name\n+\tindex\t\tcode|CODE_MASK\n+\n+    If the value is not relocatable, we transform this into:\n+\tiss\t\tpoints as an index into string space\n+\tvalue\t\tvalue\n+\tst\t\tst_Nil\n+\tsc\t\tsc_Nil\n+\tindex\t\tcode|CODE_MASK\n+\n+    .stabn directives have four fields (string is null):\n+\tcode\t\ta numeric code, defined in <stab.h>\n+\t0\t\ta zero\n+\t0\t\ta zero or a line number\n+\tvalue\t\ta numeric value or an address.  */\n+\n+STATIC void\n+parse_stabs_common (string_start, string_end, rest)\n+     const char *string_start;\t\t/* start of string or NULL */\n+     const char *string_end;\t\t/* end+1 of string or NULL */\n+     const char *rest;\t\t\t/* rest of the directive. */\n+{\n+  efdr_t *save_file_ptr = cur_file_ptr;\n+  symint_t code;\n+  symint_t value;\n+  char *p;\n+  st_t st;\n+  sc_t sc;\n+  int ch;\n+  static int stabs_seen = 0;\n+\n+  if (stabs_seen++ == 0)\n+    {\n+      /* Add a dummy @stabs dymbol. */\n+      (void) add_local_symbol (stabs_symbol,\n+\t\t\t       stabs_symbol + sizeof (stabs_symbol),\n+\t\t\t       stNil, scInfo, -1, MIPS_MARK_STAB(0));\n+    }\n+\n+  /* Read code from stabs.  */\n+  if (!isdigit (*rest))\n+    {\n+      error (\"Illegal .stabs/.stabn directive, code is non-numeric\");\n+      return;\n+    }\n+\n+  code = strtol (rest, &p, 0);\n+\n+  /* Line number stabs are handled differently, since they have two values,\n+     the line number and the address of the label.  We use the index field\n+     (aka code) to hold the line number, and the value field to hold the\n+     address.  The symbol type is st_Label, which should be different from\n+     the other stabs, so that gdb can recognize it.  */\n+\n+  if (code == (int)N_SLINE)\n+    {\n+      SYMR *sym_ptr;\n+      shash_t *shash_ptr;\n+\n+      /* Skip ,0, */\n+      if (p[0] != ',' || p[1] != '0' || p[2] != ',' || !isdigit (p[3]))\n+\t{\n+\t  error (\"Illegal line number .stabs/.stabn directive\");\n+\t  return;\n+\t}\n+\n+      code = strtol (p+3, &p, 0);\n+      ch = *++p;\n+      if (code <= 0 || p[-1] != ',' || isdigit (ch) || !IS_ASM_IDENT (ch))\n+\t{\n+\t  error (\"Illegal line number .stabs/.stabn directive\");\n+\t  return;\n+\t}\n+\n+      shash_ptr = hash_string (p,\n+\t\t\t       strlen (p) - 1,\n+\t\t\t       &orig_str_hash[0],\n+\t\t\t       (symint_t *)0);\n+\n+      if (shash_ptr == (shash_t *)0\n+\t  || (sym_ptr = shash_ptr->sym_ptr) == (SYMR *)0)\n+\t{\n+\t  error (\"Illegal .stabs/.stabn directive, value not found\");\n+\t  return;\n+\t}\n+\n+      if ((st_t) sym_ptr->st != st_Label)\n+\t{\n+\t  error (\"Illegal line number .stabs/.stabn directive\");\n+\t  return;\n+\t}\n+\n+      st = st_Label;\n+      sc = (sc_t) sym_ptr->sc;\n+      value = sym_ptr->value;\n+    }\n+  else\n+    {\n+      code = MIPS_MARK_STAB(code);\n+\n+      /* Skip ,0,0, */\n+      if (p[0] != ',' || p[1] != '0' || p[2] != ',' || p[3] != '0' || p[4] != ',')\n+\t{\n+\t  error (\"Illegal .stabs/.stabn directive, manditory 0 isn't\");\n+\t  return;\n+\t}\n+\n+      p += 5;\n+      ch = *p;\n+      if (!IS_ASM_IDENT (ch) && ch != '-')\n+\t{\n+\t  error (\"Illegal .stabs/.stabn directive, bad character\");\n+\t  return;\n+\t}\n+\n+      if (isdigit (ch) || ch == '-')\n+\t{\n+\t  st = st_Nil;\n+\t  sc = sc_Nil;\n+\t  value = strtol (p, &p, 0);\n+\t  if (*p != '\\n')\n+\t    {\n+\t      error (\"Illegal .stabs/.stabn directive, stuff after numeric value\");\n+\t      return;\n+\t    }\n+\t}\n+      else if (!IS_ASM_IDENT (ch))\n+\t{\n+\t  error (\"Illegal .stabs/.stabn directive, bad character\");\n+\t  return;\n+\t}\n+      else\n+\t{\n+\t  SYMR *sym_ptr;\n+\t  shash_t *shash_ptr = hash_string (p,\n+\t\t\t\t\t    strlen (p) - 1,\n+\t\t\t\t\t    &orig_str_hash[0],\n+\t\t\t\t\t    (symint_t *)0);\n+\n+\t  if (shash_ptr == (shash_t *)0\n+\t      || (sym_ptr = shash_ptr->sym_ptr) == (SYMR *)0)\n+\t    {\n+\t      error (\"Illegal .stabs/.stabn directive, value not found\");\n+\t      return;\n+\t    }\n+\n+\t  st = (st_t) sym_ptr->st;\n+\t  sc = (sc_t) sym_ptr->sc;\n+\t  value = sym_ptr->value;\n+\t}\n+    }\n+\n+  (void) add_local_symbol (string_start, string_end, st, sc, value, code);\n+  /* Restore normal file type.  */\n+  cur_file_ptr = save_file_ptr;\n+}\n+\n+\n+STATIC void\n+parse_stabs (start)\n+     const char *start;\t\t\t/* start of directive */\n+{\n+  const char *end = strchr (start+1, '\"');\n+\n+  if (*start != '\"' || end == (const char *)0 || end[1] != ',')\n+    {\n+      error (\"Illegal .stabs directive, no string\");\n+      return;\n+    }\n+\n+  parse_stabs_common (start+1, end, end+2);\n+}\n+\n+\n+STATIC void\n+parse_stabn (start)\n+     const char *start;\t\t\t/* start of directive */\n+{\n+  parse_stabs_common ((const char *)0, (const char *)0, start);\n+}\n+\n \f\n /* Parse the input file, and write the lines to the output file\n    if needed.  */\n@@ -3496,7 +3792,7 @@ parse_input __proto((void))\n \n   /* Add a dummy scope block around the entire compilation unit for\n      structures defined outside of blocks.  */\n-  ptag_head = (thead_t *) allocate_word8 ();\n+  ptag_head = allocate_thead ();\n   ptag_head->first_tag = 0;\n   ptag_head->prev = cur_tag_head;\n   cur_tag_head = ptag_head;\n@@ -3534,10 +3830,10 @@ parse_input __proto((void))\n \n       ptag_next = ptag->same_block;\n       ptag->hash_ptr->tag_ptr = ptag->same_name;\n-      free_word8 ((word8_t *) ptag);\n+      free_tag (ptag);\n     }\n \n-  free_word8 ((word8_t *) ptag_head);\n+  free_thead (ptag_head);\n \n }\n \n@@ -3576,10 +3872,8 @@ update_headers __proto((void))\n        file_ptr = file_ptr->next_file)\n     {\n       cur_file_ptr = file_ptr;\n-      (void) add_local_symbol ((const char *)0,\n-\t\t\t       (const char *)0,\n-\t\t\t       st_End,\n-\t\t\t       sc_Text,\n+      (void) add_local_symbol ((const char *)0, (const char *)0,\n+\t\t\t       st_End, sc_Text,\n \t\t\t       (symint_t)0,\n \t\t\t       (symint_t)0);\n \n@@ -4023,6 +4317,7 @@ copy_object __proto((void))\n   register int sys_write;\n   register int fd, es;\n   register int delete_ifd = 0;\n+  register int *remap_file_number;\n   struct stat stat_buf;\n \n   if (debug)\n@@ -4168,12 +4463,33 @@ copy_object __proto((void))\n     }\n \n \n+  /* Create array to map original file numbers to the new file numbers\n+     (in case there are duplicate filenames, we collapse them into one\n+     file section, the MIPS assembler may or may not collapse them).  */\n+\n+  remap_file_number = (int *) alloca (sizeof (int) * orig_sym_hdr.ifdMax);\n+\n+  for (fd = delete_ifd; fd < orig_sym_hdr.ifdMax; fd++)\n+    {\n+      register FDR *fd_ptr = ORIG_FILES (fd);\n+      register char *filename = ORIG_LSTRS (fd_ptr->issBase + fd_ptr->rss);\n+\n+      /* file support itself.  */\n+      add_file (filename, filename + strlen (filename));\n+      remap_file_number[fd] = cur_file_ptr->file_index;\n+    }\n+\n+  if (delete_ifd > 0)\t\t/* just in case */\n+    remap_file_number[0] = remap_file_number[1];\n+\n+\n   /* Loop, adding each of the external symbols.  These must be in\n      order or otherwise we would have to change the relocation\n      entries.  We don't just call add_bytes, because we need to have\n      the names put into the external hash table.  We set the type to\n      'void' for now, and parse_def will fill in the correct type if it\n-     is in the symbol table.  */\n+     is in the symbol table.  We must add the external symbols before\n+     the locals, since the locals do lookups against the externals.  */\n \n   if (debug)\n     fprintf (stderr, \"\\tehash\\n\");\n@@ -4182,14 +4498,15 @@ copy_object __proto((void))\n     {\n       register EXTR *eptr = orig_ext_syms + es;\n       register char *ename = ORIG_ESTRS (eptr->asym.iss);\n+      register unsigned ifd = eptr->ifd;\n \n       (void) add_ext_symbol (ename,\n \t\t\t     ename + strlen (ename),\n \t\t\t     (st_t) eptr->asym.st,\n \t\t\t     (sc_t) eptr->asym.sc,\n \t\t\t     eptr->asym.value,\n \t\t\t     (symint_t)((eptr->asym.index == indexNil) ? indexNil : 0),\n-\t\t\t     eptr->ifd - delete_ifd);\n+\t\t\t     (ifd < orig_sym_hdr.ifdMax) ? remap_file_number[ ifd ] : ifd);\n     }\n \n \n@@ -4258,7 +4575,7 @@ copy_object __proto((void))\n \n \t\telse\n \t\t  {\n-\t\t    shash_ptr = (shash_t *) allocate_word8 ();\n+\t\t    shash_ptr = allocate_shash ();\n \t\t    shash_ptr->next = orig_str_hash[hash_index];\n \t\t    orig_str_hash[hash_index] = shash_ptr;\n \n@@ -4268,6 +4585,27 @@ copy_object __proto((void))\n \t\t    shash_ptr->sym_ptr = sym;\n \t\t  }\n \t      }\n+\t      break;\n+\n+\t    case st_End:\n+\t      if ((sc_t) sym->sc == sc_Text)\n+\t\t{\n+\t\t  register char *str = ORIG_LSTRS (fd_ptr->issBase + sym->iss);\n+\n+\t\t  if (*str != '\\0')\n+\t\t    {\n+\t\t      register Size_t len = strlen (str);\n+\t\t      register shash_t *shash_ptr = hash_string (str,\n+\t\t\t\t\t\t\t\t (Ptrdiff_t)len,\n+\t\t\t\t\t\t\t\t &orig_str_hash[0],\n+\t\t\t\t\t\t\t\t (symint_t *)0);\n+\n+\t\t      if (shash_ptr != (shash_t *)0)\n+\t\t\tshash_ptr->end_ptr = sym;\n+\t\t    }\n+\t\t}\n+\t      break;\n+\n \t    }\n \t}\n \n@@ -4355,6 +4693,7 @@ main (argc, argv)\n   char *p = strrchr (argv[0], '/');\n   char *num_end;\n   int option;\n+  int i;\n \n   progname = (p != 0) ? p+1 : argv[0];\n \n@@ -4373,12 +4712,18 @@ main (argc, argv)\n \t   sizeof (page_t),\n \t   PAGE_USIZE);\n \n-  if (sizeof (word8_t) != 8 * sizeof (symint_t))\n-    fatal (\"Word8_t has a sizeof %d bytes, when it should be %d\",\n-\t   sizeof (word8_t),\n-\t   8 * sizeof (symint_t));\n #endif\n \n+  alloc_counts[ alloc_type_none    ].alloc_name = \"none\";\n+  alloc_counts[ alloc_type_scope   ].alloc_name = \"scope\";\n+  alloc_counts[ alloc_type_vlinks  ].alloc_name = \"vlinks\";\n+  alloc_counts[ alloc_type_shash   ].alloc_name = \"shash\";\n+  alloc_counts[ alloc_type_thash   ].alloc_name = \"thash\";\n+  alloc_counts[ alloc_type_tag     ].alloc_name = \"tag\";\n+  alloc_counts[ alloc_type_forward ].alloc_name = \"forward\";\n+  alloc_counts[ alloc_type_thead   ].alloc_name = \"thead\";\n+  alloc_counts[ alloc_type_varray  ].alloc_name = \"varray\";\n+\n   int_type_info  = type_info_init;\n   int_type_info.basic_type = bt_Int;\n \n@@ -4500,7 +4845,7 @@ main (argc, argv)\n \t    fatal (\"wrote %d bytes to %s, expected to write %d\", len2, obj_in_name, len);\n \t}\n \n-      free_multiple_pages (buffer, 4);\n+      free_multiple_pages ((page_t *)buffer, 4);\n \n       if (len < 0)\n \tpfatal_with_name (object_name);\n@@ -4532,24 +4877,27 @@ main (argc, argv)\n \tpfatal_with_name (argv[optind]);\n     }\n \n-\n-#ifdef _IOFBF\n-  /* Try to prevent stdio from malloc'ing memory for the buffers.  At the\n-     same time, increase the size of mips' stdio buffers.  */\n-\n-  setvbuf (object_stream, (char *) allocate_multiple_pages (2), _IOFBF, 2*PAGE_SIZE);\n-  setvbuf (obj_in_stream, (char *) allocate_multiple_pages (2), _IOFBF, 2*PAGE_SIZE);\n-  setvbuf (stdin,\t  (char *) allocate_multiple_pages (2), _IOFBF, 2*PAGE_SIZE);\n-  setvbuf (stdout,\t  (char *) allocate_multiple_pages (2), _IOFBF, 2*PAGE_SIZE);\n-  setvbuf (stderr,\t  (char *) allocate_multiple_pages (2), _IOLBF, 2*PAGE_SIZE);\n-#endif\n-\n   copy_object ();\t\t\t/* scan & copy object file */\n   parse_input ();\t\t\t/* scan all of input */\n \n   update_headers ();\t\t\t/* write out tfile */\n   write_object ();\n \n+  if (debug)\n+    {\n+      fprintf (stderr, \"\\n\\tAllocation summary:\\n\\n\");\n+      for (i = (int)alloc_type_none; i < (int)alloc_type_last; i++)\n+\tif (alloc_counts[i].total_alloc)\n+\t  {\n+\t    fprintf (stderr,\n+\t\t     \"\\t%s\\t%5d allocation(s), %5d free(s), %2d page(s)\\n\",\n+\t\t     alloc_counts[i].alloc_name,\n+\t\t     alloc_counts[i].total_alloc,\n+\t\t     alloc_counts[i].total_free,\n+\t\t     alloc_counts[i].total_pages);\n+\t  }\n+    }\n+\n   return (had_errors) ? 1 : 0;\n }\n \n@@ -4751,65 +5099,337 @@ allocate_page __proto((void))\n }\n \n \f\n-/* Allocate and release 4 word quanities.  */\n+/* Allocate scoping information.  */\n+\n+STATIC scope_t *\n+allocate_scope __proto((void))\n+{\n+  register scope_t *ptr;\n+  static scope_t initial_scope;\n+\n+#ifndef MALLOC_CHECK\n+  ptr = alloc_counts[ (int)alloc_type_scope ].free_list.f_scope;\n+  if (ptr != (scope_t *)0)\n+    alloc_counts[ (int)alloc_type_scope ].free_list.f_scope = ptr->free;\n+\n+  else\n+    {\n+      register int unallocated\t= alloc_counts[ (int)alloc_type_scope ].unallocated;\n+      register page_t *cur_page\t= alloc_counts[ (int)alloc_type_scope ].cur_page;\n+\n+      if (unallocated == 0)\n+\t{\n+\t  unallocated = PAGE_SIZE / sizeof (scope_t);\n+\t  alloc_counts[ (int)alloc_type_scope ].cur_page = cur_page = allocate_page ();\n+\t  alloc_counts[ (int)alloc_type_scope ].total_pages++;\n+\t}\n+\n+      ptr = &cur_page->scope[ --unallocated ];\n+      alloc_counts[ (int)alloc_type_scope ].unallocated = unallocated;\n+    }\n+\n+#else\n+  ptr = (scope_t *) xmalloc (sizeof (scope_t));\n+\n+#endif\n+\n+  alloc_counts[ (int)alloc_type_scope ].total_alloc++;\n+  *ptr = initial_scope;\n+  return ptr;\n+}\n+\n+/* Free scoping information.  */\n+\n+STATIC void\n+free_scope (ptr)\n+     scope_t *ptr;\n+{\n+  alloc_counts[ (int)alloc_type_scope ].total_free++;\n+\n+#ifndef MALLOC_CHECK\n+  ptr->free = alloc_counts[ (int)alloc_type_scope ].free_list.f_scope;\n+  alloc_counts[ (int)alloc_type_scope ].free_list.f_scope = ptr;\n+\n+#else\n+  xfree ((PTR_T) ptr);\n+#endif\n+\n+}\n+\n+\f\n+/* Allocate links for pages in a virtual array.  */\n+\n+STATIC vlinks_t *\n+allocate_vlinks __proto((void))\n+{\n+  register vlinks_t *ptr;\n+  static vlinks_t initial_vlinks;\n+\n+#ifndef MALLOC_CHECK\n+  register int unallocated\t= alloc_counts[ (int)alloc_type_vlinks ].unallocated;\n+  register page_t *cur_page\t= alloc_counts[ (int)alloc_type_vlinks ].cur_page;\n+\n+  if (unallocated == 0)\n+    {\n+      unallocated = PAGE_SIZE / sizeof (vlinks_t);\n+      alloc_counts[ (int)alloc_type_vlinks ].cur_page = cur_page = allocate_page ();\n+      alloc_counts[ (int)alloc_type_vlinks ].total_pages++;\n+    }\n+\n+  ptr = &cur_page->vlinks[ --unallocated ];\n+  alloc_counts[ (int)alloc_type_vlinks ].unallocated = unallocated;\n+\n+#else\n+  ptr = (vlinks_t *) xmalloc (sizeof (vlinks_t));\n+\n+#endif\n+\n+  alloc_counts[ (int)alloc_type_vlinks ].total_alloc++;\n+  *ptr = initial_vlinks;\n+  return ptr;\n+}\n+\n+\f\n+/* Allocate string hash buckets.  */\n+\n+STATIC shash_t *\n+allocate_shash __proto((void))\n+{\n+  register shash_t *ptr;\n+  static shash_t initial_shash;\n+\n+#ifndef MALLOC_CHECK\n+  register int unallocated\t= alloc_counts[ (int)alloc_type_shash ].unallocated;\n+  register page_t *cur_page\t= alloc_counts[ (int)alloc_type_shash ].cur_page;\n+\n+  if (unallocated == 0)\n+    {\n+      unallocated = PAGE_SIZE / sizeof (shash_t);\n+      alloc_counts[ (int)alloc_type_shash ].cur_page = cur_page = allocate_page ();\n+      alloc_counts[ (int)alloc_type_shash ].total_pages++;\n+    }\n+\n+  ptr = &cur_page->shash[ --unallocated ];\n+  alloc_counts[ (int)alloc_type_shash ].unallocated = unallocated;\n+\n+#else\n+  ptr = (shash_t *) xmalloc (sizeof (shash_t));\n+\n+#endif\n+\n+  alloc_counts[ (int)alloc_type_shash ].total_alloc++;\n+  *ptr = initial_shash;\n+  return ptr;\n+}\n+\n+\f\n+/* Allocate type hash buckets.  */\n+\n+STATIC thash_t *\n+allocate_thash __proto((void))\n+{\n+  register thash_t *ptr;\n+  static thash_t initial_thash;\n+\n+#ifndef MALLOC_CHECK\n+  register int unallocated\t= alloc_counts[ (int)alloc_type_thash ].unallocated;\n+  register page_t *cur_page\t= alloc_counts[ (int)alloc_type_thash ].cur_page;\n+\n+  if (unallocated == 0)\n+    {\n+      unallocated = PAGE_SIZE / sizeof (thash_t);\n+      alloc_counts[ (int)alloc_type_thash ].cur_page = cur_page = allocate_page ();\n+      alloc_counts[ (int)alloc_type_thash ].total_pages++;\n+    }\n+\n+  ptr = &cur_page->thash[ --unallocated ];\n+  alloc_counts[ (int)alloc_type_thash ].unallocated = unallocated;\n+\n+#else\n+  ptr = (thash_t *) xmalloc (sizeof (thash_t));\n+\n+#endif\n+\n+  alloc_counts[ (int)alloc_type_thash ].total_alloc++;\n+  *ptr = initial_thash;\n+  return ptr;\n+}\n+\n+\f\n+/* Allocate structure, union, or enum tag information.  */\n+\n+STATIC tag_t *\n+allocate_tag __proto((void))\n+{\n+  register tag_t *ptr;\n+  static tag_t initial_tag;\n \n #ifndef MALLOC_CHECK\n-static word8_t *word8_free_list = (word8_t *)0;\n+  ptr = alloc_counts[ (int)alloc_type_tag ].free_list.f_tag;\n+  if (ptr != (tag_t *)0)\n+    alloc_counts[ (int)alloc_type_tag ].free_list.f_tag = ptr->free;\n+\n+  else\n+    {\n+      register int unallocated\t= alloc_counts[ (int)alloc_type_tag ].unallocated;\n+      register page_t *cur_page\t= alloc_counts[ (int)alloc_type_tag ].cur_page;\n+\n+      if (unallocated == 0)\n+\t{\n+\t  unallocated = PAGE_SIZE / sizeof (tag_t);\n+\t  alloc_counts[ (int)alloc_type_tag ].cur_page = cur_page = allocate_page ();\n+\t  alloc_counts[ (int)alloc_type_tag ].total_pages++;\n+\t}\n+\n+      ptr = &cur_page->tag[ --unallocated ];\n+      alloc_counts[ (int)alloc_type_tag ].unallocated = unallocated;\n+    }\n+\n+#else\n+  ptr = (tag_t *) xmalloc (sizeof (tag_t));\n+\n+#endif\n+\n+  alloc_counts[ (int)alloc_type_tag ].total_alloc++;\n+  *ptr = initial_tag;\n+  return ptr;\n+}\n+\n+/* Free scoping information.  */\n+\n+STATIC void\n+free_tag (ptr)\n+     tag_t *ptr;\n+{\n+  alloc_counts[ (int)alloc_type_tag ].total_free++;\n+\n+#ifndef MALLOC_CHECK\n+  ptr->free = alloc_counts[ (int)alloc_type_tag ].free_list.f_tag;\n+  alloc_counts[ (int)alloc_type_tag ].free_list.f_tag = ptr;\n+\n+#else\n+  xfree ((PTR_T) ptr);\n #endif\n \n-STATIC word8_t *\n-allocate_word8 __proto((void))\n+}\n+\n+\f\n+/* Allocate forward reference to a yet unknown tag.  */\n+\n+STATIC forward_t *\n+allocate_forward __proto((void))\n {\n+  register forward_t *ptr;\n+  static forward_t initial_forward;\n+\n #ifndef MALLOC_CHECK\n-  register word8_t *ptr = word8_free_list;\n-  if (ptr != (word8_t *)0)\n-    word8_free_list = ptr->prev;\n+  ptr = alloc_counts[ (int)alloc_type_forward ].free_list.f_forward;\n+  if (ptr != (forward_t *)0)\n+    alloc_counts[ (int)alloc_type_forward ].free_list.f_forward = ptr->free;\n+\n   else\n     {\n-      register int i;\n-      register page_t *page_ptr;\n+      register int unallocated\t= alloc_counts[ (int)alloc_type_forward ].unallocated;\n+      register page_t *cur_page\t= alloc_counts[ (int)alloc_type_forward ].cur_page;\n \n-      page_ptr = allocate_page ();\n-      ptr = &page_ptr->word8[0];\n-      for (i = 0; i < (PAGE_SIZE / sizeof (word8_t)) - 1; i++)\n+      if (unallocated == 0)\n \t{\n-\t  ptr->prev = word8_free_list;\n-\t  word8_free_list = ptr;\n-\t  ptr++;\n+\t  unallocated = PAGE_SIZE / sizeof (forward_t);\n+\t  alloc_counts[ (int)alloc_type_forward ].cur_page = cur_page = allocate_page ();\n+\t  alloc_counts[ (int)alloc_type_forward ].total_pages++;\n \t}\n+\n+      ptr = &cur_page->forward[ --unallocated ];\n+      alloc_counts[ (int)alloc_type_forward ].unallocated = unallocated;\n     }\n \n-  ptr->words[0] = 0;\n-  ptr->words[1] = 0;\n-  ptr->words[2] = 0;\n-  ptr->words[3] = 0;\n-  ptr->words[4] = 0;\n-  ptr->words[5] = 0;\n-  ptr->words[6] = 0;\n-  ptr->words[7] = 0;\n+#else\n+  ptr = (forward_t *) xmalloc (sizeof (forward_t));\n+\n+#endif\n+\n+  alloc_counts[ (int)alloc_type_forward ].total_alloc++;\n+  *ptr = initial_forward;\n   return ptr;\n+}\n \n-#else\t/* MALLOC_CHECK */\n-  return (word8_t *) xcalloc (1, sizeof (word8_t));\n+/* Free scoping information.  */\n \n-#endif\t/* MALLOC_CHECK */\n+STATIC void\n+free_forward (ptr)\n+     forward_t *ptr;\n+{\n+  alloc_counts[ (int)alloc_type_forward ].total_free++;\n+\n+#ifndef MALLOC_CHECK\n+  ptr->free = alloc_counts[ (int)alloc_type_forward ].free_list.f_forward;\n+  alloc_counts[ (int)alloc_type_forward ].free_list.f_forward = ptr;\n+\n+#else\n+  xfree ((PTR_T) ptr);\n+#endif\n+\n+}\n+\n+\f\n+/* Allocate head of type hash list.  */\n+\n+STATIC thead_t *\n+allocate_thead __proto((void))\n+{\n+  register thead_t *ptr;\n+  static thead_t initial_thead;\n+\n+#ifndef MALLOC_CHECK\n+  ptr = alloc_counts[ (int)alloc_type_thead ].free_list.f_thead;\n+  if (ptr != (thead_t *)0)\n+    alloc_counts[ (int)alloc_type_thead ].free_list.f_thead = ptr->free;\n+\n+  else\n+    {\n+      register int unallocated\t= alloc_counts[ (int)alloc_type_thead ].unallocated;\n+      register page_t *cur_page\t= alloc_counts[ (int)alloc_type_thead ].cur_page;\n+\n+      if (unallocated == 0)\n+\t{\n+\t  unallocated = PAGE_SIZE / sizeof (thead_t);\n+\t  alloc_counts[ (int)alloc_type_thead ].cur_page = cur_page = allocate_page ();\n+\t  alloc_counts[ (int)alloc_type_thead ].total_pages++;\n+\t}\n+\n+      ptr = &cur_page->thead[ --unallocated ];\n+      alloc_counts[ (int)alloc_type_thead ].unallocated = unallocated;\n+    }\n+\n+#else\n+  ptr = (thead_t *) xmalloc (sizeof (thead_t));\n+\n+#endif\n+\n+  alloc_counts[ (int)alloc_type_thead ].total_alloc++;\n+  *ptr = initial_thead;\n+  return ptr;\n }\n \n+/* Free scoping information.  */\n+\n STATIC void\n-free_word8 (ptr)\n-     word8_t *ptr;\n+free_thead (ptr)\n+     thead_t *ptr;\n {\n+  alloc_counts[ (int)alloc_type_thead ].total_free++;\n+\n #ifndef MALLOC_CHECK\n-  ptr->prev = word8_free_list;\n-  word8_free_list = ptr;\n+  ptr->free = (thead_t *) alloc_counts[ (int)alloc_type_thead ].free_list.f_thead;\n+  alloc_counts[ (int)alloc_type_thead ].free_list.f_thead = ptr;\n \n-#else\t/* MALLOC_CHECK */\n-  xfree ((PTR_T)ptr);\n+#else\n+  xfree ((PTR_T) ptr);\n+#endif\n \n-#endif\t/* MALLOC_CHECK */\n }\n \n-#endif\t\t\t\t/* MIPS_DEBUGGING defined */\n+#endif /* MIPS_DEBUGGING_INFO *?\n \n \f\n /* Output an error message and exit */"}]}