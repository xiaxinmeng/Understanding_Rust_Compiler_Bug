{"sha": "8ef5fa4c56c82dfbd6e8fc5e4e08c4be843abc3e", "node_id": "C_kwDOANBUbNoAKDhlZjVmYTRjNTZjODJkZmJkNmU4ZmM1ZTRlMDhjNGJlODQzYWJjM2U", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2022-06-30T16:53:26Z"}, "committer": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2022-09-12T16:09:44Z"}, "message": "c++: Refer to internal linkage for -Wsubobject-linkage [PR86491]\n\nSince C++11 relaxed the requirement for template arguments to have\nexternal linkage, it's possible to get -Wsubobject-linkage warnings\nwithout using any anonymous namespaces. This confuses users when they\nget diagnostics that refer to an anonymous namespace that doesn't exist\nin their code.\n\nThis changes the diagnostic to say \"has internal linkage\" for C++11 and\nlater, if the type isn't actually a member of the anonymous namespace.\nMaking that distinction involved renaming the current decl_anon_ns_mem_p to\nsomething that better expresses its semantics.\n\nFor C++98 template arguments declared with 'static' are ill-formed\nanyway, so the only way this warning can arise is via anonymous\nnamespaces. That means the existing wording is accurate for C++98 and so\nwe can keep it.\n\n\tPR c++/86491\n\ngcc/cp/ChangeLog:\n\n\t* decl2.cc (constrain_class_visibility): Adjust wording of\n\t-Wsubobject-linkage for cases where anonymous\n\tnamespaces aren't used.\n\t* tree.cc (decl_anon_ns_mem_p): Now only true for actual anonymous\n\tnamespace members, rename old semantics to...\n\t(decl_internal_context_p): ...this.\n\t* cp-tree.h, name-lookup.cc, pt.cc: Adjust.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/warn/anonymous-namespace-3.C: Use separate dg-warning\n\tdirectives for C++98 and everything else.\n\t* g++.dg/warn/Wsubobject-linkage-5.C: New test.", "tree": {"sha": "c1b43b01f3079e3a6f0667338a1152cfc80b0d4d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c1b43b01f3079e3a6f0667338a1152cfc80b0d4d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8ef5fa4c56c82dfbd6e8fc5e4e08c4be843abc3e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ef5fa4c56c82dfbd6e8fc5e4e08c4be843abc3e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8ef5fa4c56c82dfbd6e8fc5e4e08c4be843abc3e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ef5fa4c56c82dfbd6e8fc5e4e08c4be843abc3e/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2e7bc76d84f0aa2f08bc01407ffcdca43c15f2ff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e7bc76d84f0aa2f08bc01407ffcdca43c15f2ff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2e7bc76d84f0aa2f08bc01407ffcdca43c15f2ff"}], "stats": {"total": 68, "additions": 48, "deletions": 20}, "files": [{"sha": "e73d04f21d8fa4ccc68111803fb9342c9443843b", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ef5fa4c56c82dfbd6e8fc5e4e08c4be843abc3e/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ef5fa4c56c82dfbd6e8fc5e4e08c4be843abc3e/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=8ef5fa4c56c82dfbd6e8fc5e4e08c4be843abc3e", "patch": "@@ -7874,7 +7874,8 @@ extern tree replace_placeholders\t\t(tree, tree, bool * = NULL);\n extern bool find_placeholders\t\t\t(tree);\n extern tree get_type_decl\t\t\t(tree);\n extern tree decl_namespace_context\t\t(tree);\n-extern bool decl_anon_ns_mem_p\t\t\t(const_tree);\n+extern bool decl_anon_ns_mem_p\t\t\t(tree);\n+extern bool decl_internal_context_p\t\t(const_tree);\n extern tree lvalue_type\t\t\t\t(tree);\n extern tree error_type\t\t\t\t(tree);\n extern int varargs_function_p\t\t\t(const_tree);"}, {"sha": "684a2d06ddecb51fe942dbac9303c4e8c22ccb9e", "filename": "gcc/cp/decl2.cc", "status": "modified", "additions": 25, "deletions": 14, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ef5fa4c56c82dfbd6e8fc5e4e08c4be843abc3e/gcc%2Fcp%2Fdecl2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ef5fa4c56c82dfbd6e8fc5e4e08c4be843abc3e/gcc%2Fcp%2Fdecl2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.cc?ref=8ef5fa4c56c82dfbd6e8fc5e4e08c4be843abc3e", "patch": "@@ -2851,7 +2851,7 @@ determine_visibility (tree decl)\n   if (class_type)\n     determine_visibility_from_class (decl, class_type);\n \n-  if (decl_anon_ns_mem_p (decl))\n+  if (decl_internal_context_p (decl))\n     /* Names in an anonymous namespace get internal linkage.  */\n     constrain_visibility (decl, VISIBILITY_ANON, false);\n   else if (TREE_CODE (decl) != TYPE_DECL)\n@@ -2965,16 +2965,21 @@ constrain_class_visibility (tree type)\n \t\t  {\n \t\t    if (same_type_p (TREE_TYPE (t), nlt))\n \t\t      warning (OPT_Wsubobject_linkage, \"\\\n-%qT has a field %qD whose type has no linkage\",\n+%qT has a field %q#D whose type has no linkage\",\n \t\t\t       type, t);\n \t\t    else\n \t\t      warning (OPT_Wsubobject_linkage, \"\\\n %qT has a field %qD whose type depends on the type %qT which has no linkage\",\n \t\t\t       type, t, nlt);\n \t\t  }\n-\t\telse\n+\t\telse if (cxx_dialect > cxx98\n+\t\t\t && !decl_anon_ns_mem_p (ftype))\n \t\t  warning (OPT_Wsubobject_linkage, \"\\\n-%qT has a field %qD whose type uses the anonymous namespace\",\n+%qT has a field %q#D whose type has internal linkage\",\n+\t\t\t   type, t);\n+\t\telse // In C++98 this can only happen with unnamed namespaces.\n+\t\t  warning (OPT_Wsubobject_linkage, \"\\\n+%qT has a field %q#D whose type uses the anonymous namespace\",\n \t\t\t   type, t);\n \t      }\n \t  }\n@@ -2989,28 +2994,34 @@ constrain_class_visibility (tree type)\n   binfo = TYPE_BINFO (type);\n   for (i = 0; BINFO_BASE_ITERATE (binfo, i, t); ++i)\n     {\n-      int subvis = type_visibility (TREE_TYPE (t));\n+      tree btype = BINFO_TYPE (t);\n+      int subvis = type_visibility (btype);\n \n       if (subvis == VISIBILITY_ANON)\n         {\n \t  if (!in_main_input_context())\n \t    {\n-\t      tree nlt = no_linkage_check (TREE_TYPE (t), /*relaxed_p=*/false);\n+\t      tree nlt = no_linkage_check (btype, /*relaxed_p=*/false);\n \t      if (nlt)\n \t\t{\n-\t\t  if (same_type_p (TREE_TYPE (t), nlt))\n+\t\t  if (same_type_p (btype, nlt))\n \t\t    warning (OPT_Wsubobject_linkage, \"\\\n-%qT has a base %qT whose type has no linkage\",\n-\t\t\t     type, TREE_TYPE (t));\n+%qT has a base %qT which has no linkage\",\n+\t\t\t     type, btype);\n \t\t  else\n \t\t    warning (OPT_Wsubobject_linkage, \"\\\n-%qT has a base %qT whose type depends on the type %qT which has no linkage\",\n-\t\t\t     type, TREE_TYPE (t), nlt);\n+%qT has a base %qT which depends on the type %qT which has no linkage\",\n+\t\t\t     type, btype, nlt);\n \t\t}\n-\t      else\n+\t      else if (cxx_dialect > cxx98\n+\t\t       && !decl_anon_ns_mem_p (btype))\n+\t\twarning (OPT_Wsubobject_linkage, \"\\\n+%qT has a base %qT which has internal linkage\",\n+\t\t\t type, btype);\n+\t      else // In C++98 this can only happen with unnamed namespaces.\n \t\twarning (OPT_Wsubobject_linkage, \"\\\n-%qT has a base %qT whose type uses the anonymous namespace\",\n-\t\t\t type, TREE_TYPE (t));\n+%qT has a base %qT which uses the anonymous namespace\",\n+\t\t\t type, btype);\n \t    }\n \t}\n       else if (vis < VISIBILITY_HIDDEN"}, {"sha": "69d555ddf1f31b28ead988fb0662757539942d67", "filename": "gcc/cp/name-lookup.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ef5fa4c56c82dfbd6e8fc5e4e08c4be843abc3e/gcc%2Fcp%2Fname-lookup.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ef5fa4c56c82dfbd6e8fc5e4e08c4be843abc3e/gcc%2Fcp%2Fname-lookup.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.cc?ref=8ef5fa4c56c82dfbd6e8fc5e4e08c4be843abc3e", "patch": "@@ -402,7 +402,7 @@ add_decl_to_level (cp_binding_level *b, tree decl)\n       && ((VAR_P (decl) && (TREE_STATIC (decl) || DECL_EXTERNAL (decl)))\n \t  || (TREE_CODE (decl) == FUNCTION_DECL\n \t      && (!TREE_PUBLIC (decl)\n-\t\t  || decl_anon_ns_mem_p (decl)\n+\t\t  || decl_internal_context_p (decl)\n \t\t  || DECL_DECLARED_INLINE_P (decl)))))\n     vec_safe_push (static_decls, decl);\n }"}, {"sha": "ad9c2f9b18082eed0e46afac464722a73387bfaf", "filename": "gcc/cp/pt.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ef5fa4c56c82dfbd6e8fc5e4e08c4be843abc3e/gcc%2Fcp%2Fpt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ef5fa4c56c82dfbd6e8fc5e4e08c4be843abc3e/gcc%2Fcp%2Fpt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.cc?ref=8ef5fa4c56c82dfbd6e8fc5e4e08c4be843abc3e", "patch": "@@ -25025,7 +25025,7 @@ mark_decl_instantiated (tree result, int extern_p)\n     return;\n \n   /* For anonymous namespace we don't need to do anything.  */\n-  if (decl_anon_ns_mem_p (result))\n+  if (decl_internal_context_p (result))\n     {\n       gcc_assert (!TREE_PUBLIC (result));\n       return;"}, {"sha": "6de208a909b15df8579725db8bf2744308c17959", "filename": "gcc/cp/tree.cc", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ef5fa4c56c82dfbd6e8fc5e4e08c4be843abc3e/gcc%2Fcp%2Ftree.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ef5fa4c56c82dfbd6e8fc5e4e08c4be843abc3e/gcc%2Fcp%2Ftree.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.cc?ref=8ef5fa4c56c82dfbd6e8fc5e4e08c4be843abc3e", "patch": "@@ -2968,7 +2968,7 @@ verify_stmt_tree (tree t)\n /* Check if the type T depends on a type with no linkage and if so,\n    return it.  If RELAXED_P then do not consider a class type declared\n    within a vague-linkage function to have no linkage.  Remember:\n-   no-linkage is not the same as internal-linkage*/\n+   no-linkage is not the same as internal-linkage.  */\n \n tree\n no_linkage_check (tree t, bool relaxed_p)\n@@ -3817,7 +3817,15 @@ decl_namespace_context (tree decl)\n    nested, or false otherwise.  */\n \n bool\n-decl_anon_ns_mem_p (const_tree decl)\n+decl_anon_ns_mem_p (tree decl)\n+{\n+  return !TREE_PUBLIC (decl_namespace_context (decl));\n+}\n+\n+/* Returns true if the enclosing scope of DECL has internal or no linkage.  */\n+\n+bool\n+decl_internal_context_p (const_tree decl)\n {\n   while (TREE_CODE (decl) != NAMESPACE_DECL)\n     {"}, {"sha": "e2c2fd9168888d925af002612236cafd48d3b80e", "filename": "gcc/testsuite/g++.dg/warn/Wsubobject-linkage-5.C", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ef5fa4c56c82dfbd6e8fc5e4e08c4be843abc3e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWsubobject-linkage-5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ef5fa4c56c82dfbd6e8fc5e4e08c4be843abc3e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWsubobject-linkage-5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWsubobject-linkage-5.C?ref=8ef5fa4c56c82dfbd6e8fc5e4e08c4be843abc3e", "patch": "@@ -0,0 +1,7 @@\n+// PR c++/86491\n+// { dg-do compile { target c++11 } }\n+\n+template <int *> struct NT{};\n+#line 6 \"tM.C\"\n+static int d;\n+struct D : NT<&d> {};\t\t// { dg-warning \"internal linkage\" }"}, {"sha": "ce5745b25f0ccf1579feca16ae663ae503fe741a", "filename": "gcc/testsuite/g++.dg/warn/anonymous-namespace-3.C", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ef5fa4c56c82dfbd6e8fc5e4e08c4be843abc3e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Fanonymous-namespace-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ef5fa4c56c82dfbd6e8fc5e4e08c4be843abc3e/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Fanonymous-namespace-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2Fanonymous-namespace-3.C?ref=8ef5fa4c56c82dfbd6e8fc5e4e08c4be843abc3e", "patch": "@@ -7,7 +7,8 @@\n struct B { std::auto_ptr<A> p; };\n \n #line 10 \"foo.C\"\n-struct C\t\t   // { dg-warning \"uses the anonymous namespace\" }\n+struct C // { dg-warning \"has internal linkage\" \"\" { target c++11 } }\n+// { dg-warning \"uses the anonymous namespace\" \"\" { target c++98_only } .-1 }\n {\n   std::auto_ptr<A> p;\n };"}]}