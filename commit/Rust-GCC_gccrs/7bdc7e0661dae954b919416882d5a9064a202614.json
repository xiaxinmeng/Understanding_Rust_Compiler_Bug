{"sha": "7bdc7e0661dae954b919416882d5a9064a202614", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2JkYzdlMDY2MWRhZTk1NGI5MTk0MTY4ODJkNWE5MDY0YTIwMjYxNA==", "commit": {"author": {"name": "Paolo Carlini", "email": "paolo.carlini@oracle.com", "date": "2019-05-10T17:57:27Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2019-05-10T17:57:27Z"}, "message": "call.c (build_call_a): Use FUNC_OR_METHOD_TYPE_P.\n\n2019-05-10  Paolo Carlini  <paolo.carlini@oracle.com>\n\n\t* call.c (build_call_a): Use FUNC_OR_METHOD_TYPE_P.\n\t* cp-gimplify.c (cp_fold): Likewise.\n\t* cp-objcp-common.c (cp_type_dwarf_attribute): Likewise.\n\t* cp-tree.h (TYPE_OBJ_P, TYPE_PTROBV_P): Likewise.\n\t* cvt.c (perform_qualification_conversions): Likewise.\n\t* decl.c (grokdeclarator): Likewise.\n\t* decl2.c (build_memfn_type): Likewise.\n\t* mangle.c (canonicalize_for_substitution, write_type): Likewise.\n\t* parser.c (cp_parser_omp_declare_reduction): Likewise.\n\t* pt.c (check_explicit_specialization, uses_deducible_template_parms,\n\tcheck_cv_quals_for_unify, dependent_type_p_r): Likewise.\n\t* rtti.c (ptr_initializer): Likewise.\n\t* semantics.c (finish_asm_stmt, finish_offsetof,\n\tcp_check_omp_declare_reduction): Likewise.\n\t* tree.c (cp_build_qualified_type_real,\n\tcp_build_type_attribute_variant, cxx_type_hash_eq,\n\tcxx_copy_lang_qualifiers, cp_free_lang_data): Likewise.\n\t* typeck.c (structural_comptypes, convert_arguments,\n\tcp_build_addr_expr_1, unary_complex_lvalue, cp_build_c_cast,\n\tcp_build_modify_expr, comp_ptr_ttypes_real, type_memfn_rqual):\n\tLikewise.\n\nFrom-SVN: r271069", "tree": {"sha": "3a06d6d9bfa747fe4fc497781f9907543c9a38f8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3a06d6d9bfa747fe4fc497781f9907543c9a38f8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7bdc7e0661dae954b919416882d5a9064a202614", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7bdc7e0661dae954b919416882d5a9064a202614", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7bdc7e0661dae954b919416882d5a9064a202614", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7bdc7e0661dae954b919416882d5a9064a202614/comments", "author": null, "committer": null, "parents": [{"sha": "d49b251f6d08fda3db606ac0e50cd28daac9eb33", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d49b251f6d08fda3db606ac0e50cd28daac9eb33", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d49b251f6d08fda3db606ac0e50cd28daac9eb33"}], "stats": {"total": 130, "additions": 60, "deletions": 70}, "files": [{"sha": "4b245a2f6044b1be68dfa9fb8f9179634125b845", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7bdc7e0661dae954b919416882d5a9064a202614/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7bdc7e0661dae954b919416882d5a9064a202614/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=7bdc7e0661dae954b919416882d5a9064a202614", "patch": "@@ -1,3 +1,27 @@\n+2019-05-10  Paolo Carlini  <paolo.carlini@oracle.com>\n+\n+\t* call.c (build_call_a): Use FUNC_OR_METHOD_TYPE_P.\n+\t* cp-gimplify.c (cp_fold): Likewise.\n+\t* cp-objcp-common.c (cp_type_dwarf_attribute): Likewise.\n+\t* cp-tree.h (TYPE_OBJ_P, TYPE_PTROBV_P): Likewise.\n+\t* cvt.c (perform_qualification_conversions): Likewise.\n+\t* decl.c (grokdeclarator): Likewise.\n+\t* decl2.c (build_memfn_type): Likewise.\n+\t* mangle.c (canonicalize_for_substitution, write_type): Likewise.\n+\t* parser.c (cp_parser_omp_declare_reduction): Likewise.\n+\t* pt.c (check_explicit_specialization, uses_deducible_template_parms,\n+\tcheck_cv_quals_for_unify, dependent_type_p_r): Likewise.\n+\t* rtti.c (ptr_initializer): Likewise.\n+\t* semantics.c (finish_asm_stmt, finish_offsetof,\n+\tcp_check_omp_declare_reduction): Likewise.\n+\t* tree.c (cp_build_qualified_type_real,\n+\tcp_build_type_attribute_variant, cxx_type_hash_eq,\n+\tcxx_copy_lang_qualifiers, cp_free_lang_data): Likewise.\n+\t* typeck.c (structural_comptypes, convert_arguments,\n+\tcp_build_addr_expr_1, unary_complex_lvalue, cp_build_c_cast,\n+\tcp_build_modify_expr, comp_ptr_ttypes_real, type_memfn_rqual):\n+\tLikewise.\n+\n 2019-05-10  Marek Polacek  <polacek@redhat.com>\n \n \tPR c++/78010 - bogus -Wsuggest-override warning on final function."}, {"sha": "2329c4cb43e74620a1724a42aec787a787282d2a", "filename": "gcc/cp/call.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7bdc7e0661dae954b919416882d5a9064a202614/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7bdc7e0661dae954b919416882d5a9064a202614/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=7bdc7e0661dae954b919416882d5a9064a202614", "patch": "@@ -357,8 +357,7 @@ build_call_a (tree function, int n, tree *argarray)\n \n   gcc_assert (TYPE_PTR_P (TREE_TYPE (function)));\n   fntype = TREE_TYPE (TREE_TYPE (function));\n-  gcc_assert (TREE_CODE (fntype) == FUNCTION_TYPE\n-\t      || TREE_CODE (fntype) == METHOD_TYPE);\n+  gcc_assert (FUNC_OR_METHOD_TYPE_P (fntype));\n   result_type = TREE_TYPE (fntype);\n   /* An rvalue has no cv-qualifiers.  */\n   if (SCALAR_TYPE_P (result_type) || VOID_TYPE_P (result_type))"}, {"sha": "7a243addb9282c4e598eb8c67c904d42a3010ff3", "filename": "gcc/cp/cp-gimplify.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7bdc7e0661dae954b919416882d5a9064a202614/gcc%2Fcp%2Fcp-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7bdc7e0661dae954b919416882d5a9064a202614/gcc%2Fcp%2Fcp-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-gimplify.c?ref=7bdc7e0661dae954b919416882d5a9064a202614", "patch": "@@ -2324,8 +2324,7 @@ cp_fold (tree x)\n \n       /* Cope with user tricks that amount to offsetof.  */\n       if (op0 != error_mark_node\n-\t  && TREE_CODE (TREE_TYPE (op0)) != FUNCTION_TYPE\n-\t  && TREE_CODE (TREE_TYPE (op0)) != METHOD_TYPE)\n+\t  && !FUNC_OR_METHOD_TYPE_P (TREE_TYPE (op0)))\n \t{\n \t  tree val = get_base_address (op0);\n \t  if (val"}, {"sha": "a8f7db0854a94e8993e91c076e30a524e5aac677", "filename": "gcc/cp/cp-objcp-common.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7bdc7e0661dae954b919416882d5a9064a202614/gcc%2Fcp%2Fcp-objcp-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7bdc7e0661dae954b919416882d5a9064a202614/gcc%2Fcp%2Fcp-objcp-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-objcp-common.c?ref=7bdc7e0661dae954b919416882d5a9064a202614", "patch": "@@ -248,16 +248,14 @@ cp_type_dwarf_attribute (const_tree type, int attr)\n   switch (attr)\n     {\n     case DW_AT_reference:\n-      if ((TREE_CODE (type) == FUNCTION_TYPE\n-\t   || TREE_CODE (type) == METHOD_TYPE)\n+      if (FUNC_OR_METHOD_TYPE_P (type)\n \t  && FUNCTION_REF_QUALIFIED (type)\n \t  && !FUNCTION_RVALUE_QUALIFIED (type))\n \treturn 1;\n       break;\n \n     case DW_AT_rvalue_reference:\n-      if ((TREE_CODE (type) == FUNCTION_TYPE\n-\t   || TREE_CODE (type) == METHOD_TYPE)\n+      if (FUNC_OR_METHOD_TYPE_P (type)\n \t  && FUNCTION_REF_QUALIFIED (type)\n \t  && FUNCTION_RVALUE_QUALIFIED (type))\n \treturn 1;"}, {"sha": "7fb25a93e441567f197197ec8e2f938caf91463e", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7bdc7e0661dae954b919416882d5a9064a202614/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7bdc7e0661dae954b919416882d5a9064a202614/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=7bdc7e0661dae954b919416882d5a9064a202614", "patch": "@@ -4342,8 +4342,7 @@ more_aggr_init_expr_args_p (const aggr_init_expr_arg_iterator *iter)\n #define TYPE_OBJ_P(NODE)\t\t\t\\\n   (!TYPE_REF_P (NODE)\t\t\t\t\\\n    && !VOID_TYPE_P (NODE)  \t\t        \\\n-   && TREE_CODE (NODE) != FUNCTION_TYPE\t\t\\\n-   && TREE_CODE (NODE) != METHOD_TYPE)\n+   && !FUNC_OR_METHOD_TYPE_P (NODE))\n \n /* Returns true if NODE is a pointer to an object.  Keep these checks\n    in ascending tree code order.  */\n@@ -4359,8 +4358,7 @@ more_aggr_init_expr_args_p (const aggr_init_expr_arg_iterator *iter)\n    void.  Keep these checks in ascending tree code order.  */\n #define TYPE_PTROBV_P(NODE)\t\t\t\t\t\\\n   (TYPE_PTR_P (NODE)\t\t\t\t\t\t\\\n-   && !(TREE_CODE (TREE_TYPE (NODE)) == FUNCTION_TYPE\t\t\\\n-\t|| TREE_CODE (TREE_TYPE (NODE)) == METHOD_TYPE))\n+   && !FUNC_OR_METHOD_TYPE_P (TREE_TYPE (NODE)))\n \n /* Returns true if NODE is a pointer to function type.  */\n #define TYPE_PTRFN_P(NODE)\t\t\t\t\\"}, {"sha": "b63a9ff6e982db7d4c2cdb97c7f27fb2229e77ed", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7bdc7e0661dae954b919416882d5a9064a202614/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7bdc7e0661dae954b919416882d5a9064a202614/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=7bdc7e0661dae954b919416882d5a9064a202614", "patch": "@@ -1996,8 +1996,7 @@ perform_qualification_conversions (tree type, tree expr)\n bool\n tx_safe_fn_type_p (tree t)\n {\n-  if (TREE_CODE (t) != FUNCTION_TYPE\n-      && TREE_CODE (t) != METHOD_TYPE)\n+  if (!FUNC_OR_METHOD_TYPE_P (t))\n     return false;\n   return !!lookup_attribute (\"transaction_safe\", TYPE_ATTRIBUTES (t));\n }"}, {"sha": "300c2dbbbb1610266e76f38b171a50743922fb34", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7bdc7e0661dae954b919416882d5a9064a202614/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7bdc7e0661dae954b919416882d5a9064a202614/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=7bdc7e0661dae954b919416882d5a9064a202614", "patch": "@@ -11840,8 +11840,7 @@ grokdeclarator (const cp_declarator *declarator,\n     }\n \n   if (unqualified_id && TREE_CODE (unqualified_id) == TEMPLATE_ID_EXPR\n-      && TREE_CODE (type) != FUNCTION_TYPE\n-      && TREE_CODE (type) != METHOD_TYPE\n+      && !FUNC_OR_METHOD_TYPE_P (type)\n       && !variable_template_p (TREE_OPERAND (unqualified_id, 0)))\n     {\n       error (\"template-id %qD used as a declarator\",\n@@ -12003,8 +12002,7 @@ grokdeclarator (const cp_declarator *declarator,\n \t\t    name);\n \t  storage_class = sc_none;\n \t}\n-      else if (TREE_CODE (type) == FUNCTION_TYPE\n-\t       || TREE_CODE (type) == METHOD_TYPE)\n+      else if (FUNC_OR_METHOD_TYPE_P (type))\n \t{\n \t  error_at (sloc, \"function %qs cannot be declared %<mutable%>\",\n \t\t    name);\n@@ -12694,8 +12692,7 @@ grokdeclarator (const cp_declarator *declarator,\n \t\t\t    declspecs->locations);\n \t  }\n       }\n-    else if (TREE_CODE (type) == FUNCTION_TYPE\n-\t     || TREE_CODE (type) == METHOD_TYPE)\n+    else if (FUNC_OR_METHOD_TYPE_P (type))\n       {\n \ttree original_name;\n \tint publicp = 0;"}, {"sha": "fb3b911fdd5fd03109220c05aa76302a5232bb10", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7bdc7e0661dae954b919416882d5a9064a202614/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7bdc7e0661dae954b919416882d5a9064a202614/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=7bdc7e0661dae954b919416882d5a9064a202614", "patch": "@@ -158,8 +158,7 @@ build_memfn_type (tree fntype, tree ctype, cp_cv_quals quals,\n   if (fntype == error_mark_node || ctype == error_mark_node)\n     return error_mark_node;\n \n-  gcc_assert (TREE_CODE (fntype) == FUNCTION_TYPE\n-\t      || TREE_CODE (fntype) == METHOD_TYPE);\n+  gcc_assert (FUNC_OR_METHOD_TYPE_P (fntype));\n \n   cp_cv_quals type_quals = quals & ~TYPE_QUAL_RESTRICT;\n   ctype = cp_build_qualified_type (ctype, type_quals);"}, {"sha": "c13dacbd05e622739ce213a5453088bb66d05821", "filename": "gcc/cp/mangle.c", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7bdc7e0661dae954b919416882d5a9064a202614/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7bdc7e0661dae954b919416882d5a9064a202614/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=7bdc7e0661dae954b919416882d5a9064a202614", "patch": "@@ -414,8 +414,7 @@ canonicalize_for_substitution (tree node)\n       else\n \tnode = cp_build_qualified_type (TYPE_MAIN_VARIANT (node),\n \t\t\t\t\tcp_type_quals (node));\n-      if (TREE_CODE (node) == FUNCTION_TYPE\n-\t  || TREE_CODE (node) == METHOD_TYPE)\n+      if (FUNC_OR_METHOD_TYPE_P (node))\n \t{\n \t  node = build_ref_qualified_type (node, type_memfn_rqual (orig));\n \t  tree r = canonical_eh_spec (TYPE_RAISES_EXCEPTIONS (orig));\n@@ -2070,8 +2069,7 @@ write_type (tree type)\n \t  t = cp_build_type_attribute_variant (t, attrs);\n \t}\n       gcc_assert (t != type);\n-      if (TREE_CODE (t) == FUNCTION_TYPE\n-\t  || TREE_CODE (t) == METHOD_TYPE)\n+      if (FUNC_OR_METHOD_TYPE_P (t))\n \t{\n \t  t = build_ref_qualified_type (t, type_memfn_rqual (type));\n \t  if (flag_noexcept_type)\n@@ -2102,8 +2100,7 @@ write_type (tree type)\n \n       /* See through any typedefs.  */\n       type = TYPE_MAIN_VARIANT (type);\n-      if (TREE_CODE (type) == FUNCTION_TYPE\n-\t  || TREE_CODE (type) == METHOD_TYPE)\n+      if (FUNC_OR_METHOD_TYPE_P (type))\n \ttype = cxx_copy_lang_qualifiers (type, type_orig);\n \n       /* According to the C++ ABI, some library classes are passed the"}, {"sha": "5881d932fba1cdec8737f0a5e340d65d716e5c25", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7bdc7e0661dae954b919416882d5a9064a202614/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7bdc7e0661dae954b919416882d5a9064a202614/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=7bdc7e0661dae954b919416882d5a9064a202614", "patch": "@@ -39646,8 +39646,7 @@ cp_parser_omp_declare_reduction (cp_parser *parser, cp_token *pragma_tok,\n \t\t\t   || id_equal (orig_reduc_id, \"max\")))))\n \terror_at (loc, \"predeclared arithmetic type %qT in \"\n \t\t       \"%<#pragma omp declare reduction%>\", type);\n-      else if (TREE_CODE (type) == FUNCTION_TYPE\n-\t       || TREE_CODE (type) == METHOD_TYPE\n+      else if (FUNC_OR_METHOD_TYPE_P (type)\n \t       || TREE_CODE (type) == ARRAY_TYPE)\n \terror_at (loc, \"function or array type %qT in \"\n \t\t       \"%<#pragma omp declare reduction%>\", type);"}, {"sha": "08da94ae0c9cd5ebb716a804e8b0a632d66a9dc0", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7bdc7e0661dae954b919416882d5a9064a202614/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7bdc7e0661dae954b919416882d5a9064a202614/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=7bdc7e0661dae954b919416882d5a9064a202614", "patch": "@@ -2906,8 +2906,7 @@ check_explicit_specialization (tree declarator,\n \n   if ((specialization || member_specialization)\n       /* This doesn't apply to variable templates.  */\n-      && (TREE_CODE (TREE_TYPE (decl)) == FUNCTION_TYPE\n-          || TREE_CODE (TREE_TYPE (decl)) == METHOD_TYPE))\n+      && FUNC_OR_METHOD_TYPE_P (TREE_TYPE (decl)))\n     {\n       tree t = TYPE_ARG_TYPES (TREE_TYPE (decl));\n       for (; t; t = TREE_CHAIN (t))\n@@ -20667,8 +20666,7 @@ uses_deducible_template_parms (tree type)\n   /* type (T)\n      T()\n      T(T)  */\n-  if (TREE_CODE (type) == FUNCTION_TYPE\n-      || TREE_CODE (type) == METHOD_TYPE)\n+  if (FUNC_OR_METHOD_TYPE_P (type))\n     {\n       if (uses_deducible_template_parms (TREE_TYPE (type)))\n \treturn true;\n@@ -21646,8 +21644,7 @@ check_cv_quals_for_unify (int strict, tree arg, tree parm)\n \t  It is ok when we're allowing additional CV qualifiers\n \t  at the outer level [14.8.2.1]/3,1st bullet.  */\n       if ((TYPE_REF_P (arg)\n-\t   || TREE_CODE (arg) == FUNCTION_TYPE\n-\t   || TREE_CODE (arg) == METHOD_TYPE)\n+\t   || FUNC_OR_METHOD_TYPE_P (arg))\n \t  && (parm_quals & (TYPE_QUAL_CONST | TYPE_QUAL_VOLATILE)))\n \treturn 0;\n \n@@ -25290,8 +25287,7 @@ dependent_type_p_r (tree type)\n \t\t\t\t\t   (type)));\n   else if (INDIRECT_TYPE_P (type))\n     return dependent_type_p (TREE_TYPE (type));\n-  else if (TREE_CODE (type) == FUNCTION_TYPE\n-\t   || TREE_CODE (type) == METHOD_TYPE)\n+  else if (FUNC_OR_METHOD_TYPE_P (type))\n     {\n       tree arg_type;\n "}, {"sha": "26dae3c3c1a18b73c02d0125a602758a07d2c655", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7bdc7e0661dae954b919416882d5a9064a202614/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7bdc7e0661dae954b919416882d5a9064a202614/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=7bdc7e0661dae954b919416882d5a9064a202614", "patch": "@@ -1015,8 +1015,7 @@ ptr_initializer (tinfo_s *ti, tree target)\n       to = tx_unsafe_fn_variant (to);\n     }\n   if (flag_noexcept_type\n-      && (TREE_CODE (to) == FUNCTION_TYPE\n-\t  || TREE_CODE (to) == METHOD_TYPE)\n+      && FUNC_OR_METHOD_TYPE_P (to)\n       && TYPE_NOTHROW_P (to))\n     {\n       flags |= 0x40;"}, {"sha": "1093cbef1346d63d6284e2412dede9ad93d7b2b4", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7bdc7e0661dae954b919416882d5a9064a202614/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7bdc7e0661dae954b919416882d5a9064a202614/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=7bdc7e0661dae954b919416882d5a9064a202614", "patch": "@@ -1527,8 +1527,7 @@ finish_asm_stmt (int volatile_p, tree string, tree output_operands,\n \t\t  || CP_TYPE_CONST_P (TREE_TYPE (operand))\n \t\t  /* Functions are not modifiable, even though they are\n \t\t     lvalues.  */\n-\t\t  || TREE_CODE (TREE_TYPE (operand)) == FUNCTION_TYPE\n-\t\t  || TREE_CODE (TREE_TYPE (operand)) == METHOD_TYPE\n+\t\t  || FUNC_OR_METHOD_TYPE_P (TREE_TYPE (operand))\n \t\t  /* If it's an aggregate and any field is const, then it is\n \t\t     effectively const.  */\n \t\t  || (CLASS_TYPE_P (TREE_TYPE (operand))\n@@ -4141,8 +4140,7 @@ finish_offsetof (tree object_ptr, tree expr, location_t loc)\n \t      TREE_OPERAND (expr, 2));\n       return error_mark_node;\n     }\n-  if (TREE_CODE (TREE_TYPE (expr)) == FUNCTION_TYPE\n-      || TREE_CODE (TREE_TYPE (expr)) == METHOD_TYPE\n+  if (FUNC_OR_METHOD_TYPE_P (TREE_TYPE (expr))\n       || TREE_TYPE (expr) == unknown_type_node)\n     {\n       while (TREE_CODE (expr) == COMPONENT_REF\n@@ -5538,8 +5536,7 @@ cp_check_omp_declare_reduction (tree udr)\n \t  return;\n \t}\n     }\n-  else if (TREE_CODE (type) == FUNCTION_TYPE\n-\t   || TREE_CODE (type) == METHOD_TYPE\n+  else if (FUNC_OR_METHOD_TYPE_P (type)\n \t   || TREE_CODE (type) == ARRAY_TYPE)\n     {\n       error_at (loc, \"function or array type %qT in \""}, {"sha": "ebc6cb6278dc485bf32ed2d6c8645e2c86f3600f", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7bdc7e0661dae954b919416882d5a9064a202614/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7bdc7e0661dae954b919416882d5a9064a202614/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=7bdc7e0661dae954b919416882d5a9064a202614", "patch": "@@ -1308,8 +1308,7 @@ cp_build_qualified_type_real (tree type,\n      (in CD1) we always ignore extra cv-quals on functions.  */\n   if (type_quals & (TYPE_QUAL_CONST | TYPE_QUAL_VOLATILE)\n       && (TYPE_REF_P (type)\n-\t  || TREE_CODE (type) == FUNCTION_TYPE\n-\t  || TREE_CODE (type) == METHOD_TYPE))\n+\t  || FUNC_OR_METHOD_TYPE_P (type)))\n     {\n       if (TYPE_REF_P (type))\n \tbad_quals |= type_quals & (TYPE_QUAL_CONST | TYPE_QUAL_VOLATILE);\n@@ -4725,8 +4724,7 @@ cp_build_type_attribute_variant (tree type, tree attributes)\n   tree new_type;\n \n   new_type = build_type_attribute_variant (type, attributes);\n-  if (TREE_CODE (new_type) == FUNCTION_TYPE\n-      || TREE_CODE (new_type) == METHOD_TYPE)\n+  if (FUNC_OR_METHOD_TYPE_P (new_type))\n     gcc_checking_assert (cxx_type_hash_eq (type, new_type));\n \n   /* Making a new main variant of a class type is broken.  */\n@@ -4741,8 +4739,7 @@ cp_build_type_attribute_variant (tree type, tree attributes)\n bool\n cxx_type_hash_eq (const_tree typea, const_tree typeb)\n {\n-  gcc_assert (TREE_CODE (typea) == FUNCTION_TYPE\n-\t      || TREE_CODE (typea) == METHOD_TYPE);\n+  gcc_assert (FUNC_OR_METHOD_TYPE_P (typea));\n \n   if (type_memfn_rqual (typea) != type_memfn_rqual (typeb))\n     return false;\n@@ -4759,7 +4756,7 @@ tree\n cxx_copy_lang_qualifiers (const_tree typea, const_tree typeb)\n {\n   tree type = CONST_CAST_TREE (typea);\n-  if (TREE_CODE (type) == FUNCTION_TYPE || TREE_CODE (type) == METHOD_TYPE)\n+  if (FUNC_OR_METHOD_TYPE_P (type))\n     type = build_cp_fntype_variant (type, type_memfn_rqual (typeb),\n \t\t\t\t    TYPE_RAISES_EXCEPTIONS (typeb),\n \t\t\t\t    TYPE_HAS_LATE_RETURN_TYPE (typeb));\n@@ -5371,8 +5368,7 @@ cp_fix_function_decl_p (tree decl)\n void\n cp_free_lang_data (tree t)\n {\n-  if (TREE_CODE (t) == METHOD_TYPE\n-      || TREE_CODE (t) == FUNCTION_TYPE)\n+  if (FUNC_OR_METHOD_TYPE_P (t))\n     {\n       /* Default args are not interesting anymore.  */\n       tree argtypes = TYPE_ARG_TYPES (t);"}, {"sha": "fff45cc7d804d471a02b0486ea661e4b9def3be1", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 8, "deletions": 15, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7bdc7e0661dae954b919416882d5a9064a202614/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7bdc7e0661dae954b919416882d5a9064a202614/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=7bdc7e0661dae954b919416882d5a9064a202614", "patch": "@@ -1262,8 +1262,7 @@ structural_comptypes (tree t1, tree t2, int strict)\n     return false;\n   /* Need to check this before TYPE_MAIN_VARIANT.\n      FIXME function qualifiers should really change the main variant.  */\n-  if (TREE_CODE (t1) == FUNCTION_TYPE\n-      || TREE_CODE (t1) == METHOD_TYPE)\n+  if (FUNC_OR_METHOD_TYPE_P (t1))\n     {\n       if (type_memfn_rqual (t1) != type_memfn_rqual (t2))\n \treturn false;\n@@ -4037,8 +4036,7 @@ convert_arguments (tree typelist, vec<tree, va_gc> **values, tree fndecl,\n       if (type == 0 || !TYPE_REF_P (type))\n \t{\n \t  if (TREE_CODE (TREE_TYPE (val)) == ARRAY_TYPE\n-\t      || TREE_CODE (TREE_TYPE (val)) == FUNCTION_TYPE\n-\t      || TREE_CODE (TREE_TYPE (val)) == METHOD_TYPE)\n+\t      || FUNC_OR_METHOD_TYPE_P (TREE_TYPE (val)))\n \t    val = decay_conversion (val, complain);\n \t}\n \n@@ -6022,8 +6020,7 @@ cp_build_addr_expr_1 (tree arg, bool strict_lvalue, tsubst_flags_t complain)\n \n   /* Anything not already handled and not a true memory reference\n      is an error.  */\n-  if (TREE_CODE (argtype) != FUNCTION_TYPE\n-      && TREE_CODE (argtype) != METHOD_TYPE)\n+  if (!FUNC_OR_METHOD_TYPE_P (argtype))\n     {\n       cp_lvalue_kind kind = lvalue_kind (arg);\n       if (kind == clk_none)\n@@ -6600,8 +6597,7 @@ unary_complex_lvalue (enum tree_code code, tree arg)\n       return arg;\n     }\n \n-  if (TREE_CODE (TREE_TYPE (arg)) == FUNCTION_TYPE\n-      || TREE_CODE (TREE_TYPE (arg)) == METHOD_TYPE\n+  if (FUNC_OR_METHOD_TYPE_P (TREE_TYPE (arg))\n       || TREE_CODE (arg) == OFFSET_REF)\n     return NULL_TREE;\n \n@@ -7974,8 +7970,7 @@ cp_build_c_cast (tree type, tree expr, tsubst_flags_t complain)\n \t}\n     }\n \n-  if (TREE_CODE (type) == FUNCTION_TYPE\n-      || TREE_CODE (type) == METHOD_TYPE)\n+  if (FUNC_OR_METHOD_TYPE_P (type))\n     {\n       if (complain & tf_error)\n         error (\"invalid cast to function type %qT\", type);\n@@ -8328,8 +8323,7 @@ cp_build_modify_expr (location_t loc, tree lhs, enum tree_code modifycode,\n       && (TREE_READONLY (lhs) || CP_TYPE_CONST_P (lhstype)\n \t  /* Functions are not modifiable, even though they are\n \t     lvalues.  */\n-\t  || TREE_CODE (TREE_TYPE (lhs)) == FUNCTION_TYPE\n-\t  || TREE_CODE (TREE_TYPE (lhs)) == METHOD_TYPE\n+\t  || FUNC_OR_METHOD_TYPE_P (TREE_TYPE (lhs))\n \t  /* If it's an aggregate and any field is const, then it is\n \t     effectively const.  */\n \t  || (CLASS_TYPE_P (lhstype)\n@@ -9852,7 +9846,7 @@ comp_ptr_ttypes_real (tree to, tree from, int constp)\n \n       /* Const and volatile mean something different for function types,\n \t so the usual checks are not appropriate.  */\n-      if (TREE_CODE (to) != FUNCTION_TYPE && TREE_CODE (to) != METHOD_TYPE)\n+      if (!FUNC_OR_METHOD_TYPE_P (to))\n \t{\n \t  if (!at_least_as_qualified_p (to, from))\n \t    return 0;\n@@ -10028,8 +10022,7 @@ cp_type_quals (const_tree type)\n cp_ref_qualifier\n type_memfn_rqual (const_tree type)\n {\n-  gcc_assert (TREE_CODE (type) == FUNCTION_TYPE\n-              || TREE_CODE (type) == METHOD_TYPE);\n+  gcc_assert (FUNC_OR_METHOD_TYPE_P (type));\n \n   if (!FUNCTION_REF_QUALIFIED (type))\n     return REF_QUAL_NONE;"}]}