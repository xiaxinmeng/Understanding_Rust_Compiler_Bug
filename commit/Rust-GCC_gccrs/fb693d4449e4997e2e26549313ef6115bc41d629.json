{"sha": "fb693d4449e4997e2e26549313ef6115bc41d629", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmI2OTNkNDQ0OWU0OTk3ZTJlMjY1NDkzMTNlZjYxMTViYzQxZDYyOQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "1999-04-13T23:19:26Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1999-04-13T23:19:26Z"}, "message": "i386.c (memory_address_length): New function.\n\n        * i386.c (memory_address_length): New function.\n        * i386.h (memory_address_length): Declare it.\n\nFrom-SVN: r26432", "tree": {"sha": "7b18d5275c0d4fdd99ef657513638bbaef61e3ef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7b18d5275c0d4fdd99ef657513638bbaef61e3ef"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fb693d4449e4997e2e26549313ef6115bc41d629", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb693d4449e4997e2e26549313ef6115bc41d629", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fb693d4449e4997e2e26549313ef6115bc41d629", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb693d4449e4997e2e26549313ef6115bc41d629/comments", "author": null, "committer": null, "parents": [{"sha": "a8b7e1861e18c1234e6ae99c250e244492ab7a1a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8b7e1861e18c1234e6ae99c250e244492ab7a1a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a8b7e1861e18c1234e6ae99c250e244492ab7a1a"}], "stats": {"total": 123, "additions": 123, "deletions": 0}, "files": [{"sha": "f1c5773e50a72e78d5b418164cde0f5680bd20db", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb693d4449e4997e2e26549313ef6115bc41d629/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb693d4449e4997e2e26549313ef6115bc41d629/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fb693d4449e4997e2e26549313ef6115bc41d629", "patch": "@@ -1,3 +1,8 @@\n+Wed Apr 14 00:08:46 1999  Richard Henderson  <rth@cygnus.com>\n+\n+\t* i386.c (memory_address_length): New function.\n+\t* i386.h (memory_address_length): Declare it.\n+\n Tue Apr 13 22:52:04 1999  Donn Terry (donn@interix.com)\n                           Martin Heller (Ing.-Buero_Heller@t-online.de)\n "}, {"sha": "671d529a9194ba95de35854f6e94da53c42447ab", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb693d4449e4997e2e26549313ef6115bc41d629/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb693d4449e4997e2e26549313ef6115bc41d629/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=fb693d4449e4997e2e26549313ef6115bc41d629", "patch": "@@ -5545,3 +5545,120 @@ output_ashlsi3 (operands)\n   /* Otherwise use a shift instruction.  */\n   return AS2 (sal%L0,%2,%0);\n }\n+\n+/* Calculate the length of the memory address in the instruction\n+   encoding.  Does not include the one-byte modrm, opcode, or prefix.  */\n+\n+int\n+memory_address_length (addr)\n+     rtx addr;\n+{\n+  rtx base, index, disp, scale;\n+  rtx op0, op1;\n+  int len;\n+\n+  if (GET_CODE (addr) == PRE_DEC\n+      || GET_CODE (addr) == POST_INC)\n+    return 0;\n+\n+  /* Register Indirect.  */\n+  if (register_operand (addr, Pmode))\n+    {\n+      /* Special cases: ebp and esp need the two-byte modrm form. \n+\n+\t We change [ESI] to [ESI+0] on the K6 when not optimizing\n+\t for size.  */\n+      if (addr == stack_pointer_rtx\n+\t  || addr == arg_pointer_rtx\n+\t  || addr == frame_pointer_rtx\n+\t  || (REGNO_REG_CLASS (REGNO (addr)) == SIREG\n+\t      && ix86_cpu == PROCESSOR_K6 && !optimize_size)\n+\treturn 1;\n+      else\n+\treturn 0;\n+    }\n+\n+  /* Direct Addressing.  */\n+  if (CONSTANT_P (addr))\n+    return 4;\n+\n+  index = base = disp = scale = NULL_RTX;\n+  op0 = XEXP (addr, 0);\n+  op1 = XEXP (addr, 1);\n+\n+  if (GET_CODE (addr) == PLUS)\n+    {\n+      if (register_operand (op0, Pmode))\n+\t{\n+\t  if (register_operand (op1, Pmode))\n+\t    index = op0, base = op1;\n+\t  else\n+\t    base = op0, disp = op1;\n+\t}\n+      else if (GET_CODE (op0) == MULT)\n+\t{\n+\t  index = XEXP (op0, 0);\n+\t  scale = XEXP (op0, 1);\n+\t  if (register_operand (op1, Pmode))\n+\t    base = op1;\n+\t  else\n+\t    disp = op1;\n+\t}\n+      else if (GET_CODE (op0) == PLUS && GET_CODE (XEXP (op0, 0)) == MULT)\n+\t{\n+\t  index = XEXP (XEXP (op0, 0), 0);\n+\t  scale = XEXP (XEXP (op0, 0), 1);\n+\t  base = XEXP (op0, 1);\n+\t  disp = op1;\n+\t}\n+      else if (GET_CODE (op0) == PLUS)\n+\t{\n+\t  index = XEXP (op0, 0);\n+\t  base = XEXP (op0, 1);\n+\t  disp = op1;\n+\t}\n+      else\n+\tabort ();\n+    }\n+  else if (GET_CODE (addr) == MULT\n+\t   /* We're called for lea too, which implements ashift on occasion.  */\n+\t   || GET_CODE (addr) == ASHIFT)\n+    {\n+      index = XEXP (addr, 0);\n+      scale = XEXP (addr, 1);\n+    }\n+  else\n+    abort ();\n+      \n+  /* Allow arg pointer and stack pointer as index if there is not scaling */\n+  if (base && index && !scale\n+      && (index == stack_pointer_rtx\n+\t  || index == arg_pointer_rtx\n+\t  || index == frame_pointer_rtx))\n+    {\n+      rtx tmp = base;\n+      base = index;\n+      index = tmp;\n+    }\n+\n+  /* Special case: ebp cannot be encoded as a base without a displacement.  */\n+  if (base == frame_pointer_rtx && !disp)\n+    disp = const0_rtx;\n+\n+  /* Find the length of the displacement constant.  */\n+  len = 0;\n+  if (disp)\n+    {\n+      if (GET_CODE (disp) == CONST_INT\n+\t  && CONST_OK_FOR_LETTER_P (INTVAL (disp), 'K'))\n+\tlen = 1;\n+      else\n+\tlen = 4;\n+    }\n+\n+  /* An index requires the two-byte modrm form.  */\n+  if (index)\n+    len += 1;\n+\n+  return len;\n+}"}, {"sha": "de4da2cb6fe7d28293c8d375094cab6157ca7645", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb693d4449e4997e2e26549313ef6115bc41d629/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb693d4449e4997e2e26549313ef6115bc41d629/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=fb693d4449e4997e2e26549313ef6115bc41d629", "patch": "@@ -2765,6 +2765,7 @@ extern char *output_fp_conditional_move ();\n extern int ix86_can_use_return_insn_p ();\n extern int small_shift_operand ();\n extern char *output_ashlsi3 ();\n+extern int memory_address_length ();\n \n #ifdef NOTYET\n extern struct rtx_def *copy_all_rtx ();"}]}