{"sha": "b36948478c22c58018d0a888ee8ca393dea60dc9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjM2OTQ4NDc4YzIyYzU4MDE4ZDBhODg4ZWU4Y2EzOTNkZWE2MGRjOQ==", "commit": {"author": {"name": "Stan Shebs", "email": "shebs@apple.com", "date": "2001-10-11T03:16:15Z"}, "committer": {"name": "Stan Shebs", "email": "shebs@gcc.gnu.org", "date": "2001-10-11T03:16:15Z"}, "message": "alias.c: Remove uses of \"register\" specifier in declarations of arguments and local...\n\n2001-10-10  Stan Shebs  <shebs@apple.com>\n\n        * alias.c: Remove uses of \"register\" specifier in declarations\n        of arguments and local variables.\n        * c-common.c: Ditto.\n        * c-convert.c: Ditto.\n        * c-decl.c: Ditto.\n        * c-format.c: Ditto.\n        * c-semantics.c: Ditto.\n        * c-typeck.c: Ditto.\n        * caller-save.c: Ditto.\n        * calls.c: Ditto.\n        * cfg.c: Ditto.\n        * cfgbuild.c: Ditto.\n        * cfgrtl.c: Ditto.\n        * collect2.c: Ditto.\n        * combine.c: Ditto.\n        * convert.c: Ditto.\n        * cppexp.c: Ditto.\n        * cppfiles.c: Ditto.\n        * cse.c: Ditto.\n        * dbxout.c: Ditto.\n        * defaults.h: Ditto.\n        * df.c: Ditto.\n        * dwarf2out.c: Ditto.\n        * dwarfout.c: Ditto.\n        * emit-rtl.c: Ditto.\n        * explow.c: Ditto.\n        * expmed.c: Ditto.\n        * expr.c: Ditto.\n        * final.c: Ditto.\n        * fix-header.c: Ditto.\n        * floatlib.c: Ditto.\n        * flow.c: Ditto.\n        * fold-const.c: Ditto.\n        * function.c: Ditto.\n        * gcc.c: Ditto.\n        * gcse.c: Ditto.\n        * gen-protos.c: Ditto.\n        * genattrtab.c: Ditto.\n        * gencheck.c: Ditto.\n        * genconfig.c: Ditto.\n        * genemit.c: Ditto.\n        * genextract.c: Ditto.\n        * genflags.c: Ditto.\n        * gengenrtl.c: Ditto.\n        * genoutput.c: Ditto.\n        * genpeep.c: Ditto.\n        * genrecog.c: Ditto.\n        * gensupport.c: Ditto.\n        * global.c: Ditto.\n        * gmon.c: Ditto.\n        * graph.c: Ditto.\n        * haifa-sched.c: Ditto.\n        * hard-reg-set.h: Ditto.\n        * hash.c: Ditto.\n        * integrate.c: Ditto.\n        * jump.c: Ditto.\n        * lists.c: Ditto.\n        * local-alloc.c: Ditto.\n        * loop.c: Ditto.\n        * mips-tdump.c: Ditto.\n        * mips-tfile.c: Ditto.\n        * optabs.c: Ditto.\n        * prefix.c: Ditto.\n        * print-rtl.c: Ditto.\n        * read-rtl.c: Ditto.\n        * real.c: Ditto.\n        * recog.c: Ditto.\n        * reg-stack.c: Ditto.\n        * regclass.c: Ditto.\n        * regmove.c: Ditto.\n        * reload.c: Ditto.\n        * reload1.c: Ditto.\n        * reorg.c: Ditto.\n        * resource.c: Ditto.\n        * rtl.c: Ditto.\n        * rtlanal.c: Ditto.\n        * scan.c: Ditto.\n        * sched-deps.c: Ditto.\n        * sched-rgn.c: Ditto.\n        * sdbout.c: Ditto.\n        * simplify-rtx.c: Ditto.\n        * stmt.c: Ditto.\n        * stor-layout.c: Ditto.\n        * toplev.c: Ditto.\n        * tradcif.y: Ditto.\n        * tradcpp.c: Ditto.\n        * tree.c: Ditto.\n        * unroll.c: Ditto.\n        * varasm.c: Ditto.\n        * xcoffout.c: Ditto.\n\nFrom-SVN: r46173", "tree": {"sha": "2c6aa7c24a8c3a2367f6f050b8747583f29cf4ad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2c6aa7c24a8c3a2367f6f050b8747583f29cf4ad"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b36948478c22c58018d0a888ee8ca393dea60dc9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b36948478c22c58018d0a888ee8ca393dea60dc9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b36948478c22c58018d0a888ee8ca393dea60dc9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b36948478c22c58018d0a888ee8ca393dea60dc9/comments", "author": null, "committer": null, "parents": [{"sha": "b83018cacae33cffd27b111cfc38e389497d1ae3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b83018cacae33cffd27b111cfc38e389497d1ae3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b83018cacae33cffd27b111cfc38e389497d1ae3"}], "stats": {"total": 5286, "additions": 2695, "deletions": 2591}, "files": [{"sha": "536a3517e86fb4487ba952160d8284391150e902", "filename": "gcc/ChangeLog", "status": "modified", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b36948478c22c58018d0a888ee8ca393dea60dc9", "patch": "@@ -1,3 +1,96 @@\n+2001-10-10  Stan Shebs  <shebs@apple.com>\n+\n+\t* alias.c: Remove uses of \"register\" specifier in declarations\n+\tof arguments and local variables.\n+\t* c-common.c: Ditto.\n+\t* c-convert.c: Ditto.\n+\t* c-decl.c: Ditto.\n+\t* c-format.c: Ditto.\n+\t* c-semantics.c: Ditto.\n+\t* c-typeck.c: Ditto.\n+\t* caller-save.c: Ditto.\n+\t* calls.c: Ditto.\n+\t* cfg.c: Ditto.\n+\t* cfgbuild.c: Ditto.\n+\t* cfgrtl.c: Ditto.\n+\t* collect2.c: Ditto.\n+\t* combine.c: Ditto.\n+\t* convert.c: Ditto.\n+\t* cppexp.c: Ditto.\n+\t* cppfiles.c: Ditto.\n+\t* cse.c: Ditto.\n+\t* dbxout.c: Ditto.\n+\t* defaults.h: Ditto.\n+\t* df.c: Ditto.\n+\t* dwarf2out.c: Ditto.\n+\t* dwarfout.c: Ditto.\n+\t* emit-rtl.c: Ditto.\n+\t* explow.c: Ditto.\n+\t* expmed.c: Ditto.\n+\t* expr.c: Ditto.\n+\t* final.c: Ditto.\n+\t* fix-header.c: Ditto.\n+\t* floatlib.c: Ditto.\n+\t* flow.c: Ditto.\n+\t* fold-const.c: Ditto.\n+\t* function.c: Ditto.\n+\t* gcc.c: Ditto.\n+\t* gcse.c: Ditto.\n+\t* gen-protos.c: Ditto.\n+\t* genattrtab.c: Ditto.\n+\t* gencheck.c: Ditto.\n+\t* genconfig.c: Ditto.\n+\t* genemit.c: Ditto.\n+\t* genextract.c: Ditto.\n+\t* genflags.c: Ditto.\n+\t* gengenrtl.c: Ditto.\n+\t* genoutput.c: Ditto.\n+\t* genpeep.c: Ditto.\n+\t* genrecog.c: Ditto.\n+\t* gensupport.c: Ditto.\n+\t* global.c: Ditto.\n+\t* gmon.c: Ditto.\n+\t* graph.c: Ditto.\n+\t* haifa-sched.c: Ditto.\n+\t* hard-reg-set.h: Ditto.\n+\t* hash.c: Ditto.\n+\t* integrate.c: Ditto.\n+\t* jump.c: Ditto.\n+\t* lists.c: Ditto.\n+\t* local-alloc.c: Ditto.\n+\t* loop.c: Ditto.\n+\t* mips-tdump.c: Ditto.\n+\t* mips-tfile.c: Ditto.\n+\t* optabs.c: Ditto.\n+\t* prefix.c: Ditto.\n+\t* print-rtl.c: Ditto.\n+\t* read-rtl.c: Ditto.\n+\t* real.c: Ditto.\n+\t* recog.c: Ditto.\n+\t* reg-stack.c: Ditto.\n+\t* regclass.c: Ditto.\n+\t* regmove.c: Ditto.\n+\t* reload.c: Ditto.\n+\t* reload1.c: Ditto.\n+\t* reorg.c: Ditto.\n+\t* resource.c: Ditto.\n+\t* rtl.c: Ditto.\n+\t* rtlanal.c: Ditto.\n+\t* scan.c: Ditto.\n+\t* sched-deps.c: Ditto.\n+\t* sched-rgn.c: Ditto.\n+\t* sdbout.c: Ditto.\n+\t* simplify-rtx.c: Ditto.\n+\t* stmt.c: Ditto.\n+\t* stor-layout.c: Ditto.\n+\t* toplev.c: Ditto.\n+\t* tradcif.y: Ditto.\n+\t* tradcpp.c: Ditto.\n+\t* tree.c: Ditto.\n+\t* unroll.c: Ditto.\n+\t* varasm.c: Ditto.\n+\t* xcoffout.c: Ditto.\n+\n 2001-10-10  Richard Henderson  <rth@redhat.com>\n \n \t* rtl.h (can_reverse_comparison_p): Remove."}, {"sha": "53de65fab0c7c29180ced488056826a3b5ac33d0", "filename": "gcc/alias.c", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=b36948478c22c58018d0a888ee8ca393dea60dc9", "patch": "@@ -714,7 +714,7 @@ get_frame_alias_set ()\n \n static rtx\n find_base_value (src)\n-     register rtx src;\n+     rtx src;\n {\n   unsigned int regno;\n   switch (GET_CODE (src))\n@@ -846,7 +846,7 @@ record_set (dest, set, data)\n      rtx dest, set;\n      void *data ATTRIBUTE_UNUSED;\n {\n-  register unsigned regno;\n+  unsigned regno;\n   rtx src;\n \n   if (GET_CODE (dest) != REG)\n@@ -1020,10 +1020,10 @@ static int\n rtx_equal_for_memref_p (x, y)\n      rtx x, y;\n {\n-  register int i;\n-  register int j;\n-  register enum rtx_code code;\n-  register const char *fmt;\n+  int i;\n+  int j;\n+  enum rtx_code code;\n+  const char *fmt;\n \n   if (x == 0 && y == 0)\n     return 1;\n@@ -1149,9 +1149,9 @@ static rtx\n find_symbolic_term (x)\n      rtx x;\n {\n-  register int i;\n-  register enum rtx_code code;\n-  register const char *fmt;\n+  int i;\n+  enum rtx_code code;\n+  const char *fmt;\n \n   code = GET_CODE (x);\n   if (code == SYMBOL_REF || code == LABEL_REF)\n@@ -1178,7 +1178,7 @@ find_symbolic_term (x)\n \n static rtx\n find_base_term (x)\n-     register rtx x;\n+     rtx x;\n {\n   cselib_val *val;\n   struct elt_loc_list *l;\n@@ -1452,7 +1452,7 @@ addr_side_effect_eval (addr, size, n_refs)\n \n static int\n memrefs_conflict_p (xsize, x, ysize, y, c)\n-     register rtx x, y;\n+     rtx x, y;\n      int xsize, ysize;\n      HOST_WIDE_INT c;\n {\n@@ -1737,7 +1737,7 @@ true_dependence (mem, mem_mode, x, varies)\n      rtx x;\n      int (*varies) PARAMS ((rtx, int));\n {\n-  register rtx x_addr, mem_addr;\n+  rtx x_addr, mem_addr;\n   rtx base;\n \n   if (MEM_VOLATILE_P (x) && MEM_VOLATILE_P (mem))\n@@ -1810,7 +1810,7 @@ canon_true_dependence (mem, mem_mode, mem_addr, x, varies)\n      enum machine_mode mem_mode;\n      int (*varies) PARAMS ((rtx, int));\n {\n-  register rtx x_addr;\n+  rtx x_addr;\n \n   if (MEM_VOLATILE_P (x) && MEM_VOLATILE_P (mem))\n     return 1;\n@@ -1929,8 +1929,8 @@ anti_dependence (mem, x)\n \n int\n output_dependence (mem, x)\n-     register rtx mem;\n-     register rtx x;\n+     rtx mem;\n+     rtx x;\n {\n   return write_dependence_p (mem, x, /*writep=*/1);\n }\n@@ -1943,7 +1943,7 @@ nonlocal_mentioned_p (x)\n      rtx x;\n {\n   rtx base;\n-  register RTX_CODE code;\n+  RTX_CODE code;\n   int regno;\n \n   code = GET_CODE (x);\n@@ -2047,8 +2047,8 @@ nonlocal_mentioned_p (x)\n   /* Recursively scan the operands of this expression.  */\n \n   {\n-    register const char *fmt = GET_RTX_FORMAT (code);\n-    register int i;\n+    const char *fmt = GET_RTX_FORMAT (code);\n+    int i;\n     \n     for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n       {\n@@ -2059,7 +2059,7 @@ nonlocal_mentioned_p (x)\n \t  }\n \telse if (fmt[i] == 'E')\n \t  {\n-\t    register int j;\n+\t    int j;\n \t    for (j = 0; j < XVECLEN (x, i); j++)\n \t      if (nonlocal_mentioned_p (XVECEXP (x, i, j)))\n \t\treturn 1;\n@@ -2116,7 +2116,7 @@ static HARD_REG_SET argument_registers;\n void\n init_alias_once ()\n {\n-  register int i;\n+  int i;\n \n #ifndef OUTGOING_REGNO\n #define OUTGOING_REGNO(N) N\n@@ -2140,9 +2140,9 @@ init_alias_analysis ()\n {\n   int maxreg = max_reg_num ();\n   int changed, pass;\n-  register int i;\n-  register unsigned int ui;\n-  register rtx insn;\n+  int i;\n+  unsigned int ui;\n+  rtx insn;\n \n   reg_known_value_size = maxreg;\n "}, {"sha": "67b6e1e6c16041e98f9593c0d979a813ad71f688", "filename": "gcc/c-common.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=b36948478c22c58018d0a888ee8ca393dea60dc9", "patch": "@@ -510,8 +510,8 @@ tree\n combine_strings (strings)\n      tree strings;\n {\n-  register tree value, t;\n-  register int length = 1;\n+  tree value, t;\n+  int length = 1;\n   int wide_length = 0;\n   int wide_flag = 0;\n   int wchar_bytes = TYPE_PRECISION (wchar_type_node) / BITS_PER_UNIT;\n@@ -521,7 +521,7 @@ combine_strings (strings)\n   if (TREE_CHAIN (strings))\n     {\n       /* More than one in the chain, so concatenate.  */\n-      register char *p, *q;\n+      char *p, *q;\n \n       /* Don't include the \\0 at the end of each substring,\n \t except for the last one.\n@@ -1502,7 +1502,7 @@ void\n binary_op_error (code)\n      enum tree_code code;\n {\n-  register const char *opname;\n+  const char *opname;\n \n   switch (code)\n     {\n@@ -1581,7 +1581,7 @@ shorten_compare (op0_ptr, op1_ptr, restype_ptr, rescode_ptr)\n      tree *restype_ptr;\n      enum tree_code *rescode_ptr;\n {\n-  register tree type;\n+  tree type;\n   tree op0 = *op0_ptr;\n   tree op1 = *op1_ptr;\n   int unsignedp0, unsignedp1;\n@@ -1614,8 +1614,8 @@ shorten_compare (op0_ptr, op1_ptr, restype_ptr, rescode_ptr)\n   if (TREE_CONSTANT (primop0)\n       && ! integer_zerop (primop1) && ! real_zerop (primop1))\n     {\n-      register tree tem = primop0;\n-      register int temi = unsignedp0;\n+      tree tem = primop0;\n+      int temi = unsignedp0;\n       primop0 = primop1;\n       primop1 = tem;\n       tem = op0;\n@@ -2836,10 +2836,10 @@ int\n self_promoting_args_p (parms)\n      tree parms;\n {\n-  register tree t;\n+  tree t;\n   for (t = parms; t; t = TREE_CHAIN (t))\n     {\n-      register tree type = TREE_VALUE (t);\n+      tree type = TREE_VALUE (t);\n \n       if (TREE_CHAIN (t) == 0 && type != void_type_node)\n \treturn 0;"}, {"sha": "947c79bcadb3e9ce891a8715b30b1ecec481028e", "filename": "gcc/c-convert.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Fc-convert.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Fc-convert.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-convert.c?ref=b36948478c22c58018d0a888ee8ca393dea60dc9", "patch": "@@ -61,8 +61,8 @@ tree\n convert (type, expr)\n      tree type, expr;\n {\n-  register tree e = expr;\n-  register enum tree_code code = TREE_CODE (type);\n+  tree e = expr;\n+  enum tree_code code = TREE_CODE (type);\n \n   if (type == TREE_TYPE (expr)\n       || TREE_CODE (expr) == ERROR_MARK"}, {"sha": "ee45b8ff72a837981d6de100fe11cafb612aca53", "filename": "gcc/c-decl.c", "status": "modified", "additions": 61, "deletions": 61, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=b36948478c22c58018d0a888ee8ca393dea60dc9", "patch": "@@ -912,7 +912,7 @@ void\n pushlevel (tag_transparent)\n      int tag_transparent;\n {\n-  register struct binding_level *newlevel = NULL_BINDING_LEVEL;\n+  struct binding_level *newlevel = NULL_BINDING_LEVEL;\n \n   /* If this is the top level of a function,\n      just make sure that NAMED_LABELS is 0.  */\n@@ -988,7 +988,7 @@ poplevel (keep, reverse, functionbody)\n      int reverse;\n      int functionbody;\n {\n-  register tree link;\n+  tree link;\n   /* The chain of decls was accumulated in reverse order.\n      Put it into forward order, just for cleanliness.  */\n   tree decls;\n@@ -1131,7 +1131,7 @@ poplevel (keep, reverse, functionbody)\n \n       for (link = named_labels; link; link = TREE_CHAIN (link))\n \t{\n-\t  register tree label = TREE_VALUE (link);\n+\t  tree label = TREE_VALUE (link);\n \n \t  if (DECL_INITIAL (label) == 0)\n \t    {\n@@ -1154,7 +1154,7 @@ poplevel (keep, reverse, functionbody)\n   /* Pop the current level, and free the structure for reuse.  */\n \n   {\n-    register struct binding_level *level = current_binding_level;\n+    struct binding_level *level = current_binding_level;\n     current_binding_level = current_binding_level->level_chain;\n \n     level->level_chain = free_binding_level;\n@@ -1248,7 +1248,7 @@ insert_block (block)\n \n void\n set_block (block)\n-     register tree block;\n+     tree block;\n {\n   current_binding_level->this_block = block;\n   current_binding_level->names = chainon (current_binding_level->names,\n@@ -1260,7 +1260,7 @@ set_block (block)\n void\n push_label_level ()\n {\n-  register struct binding_level *newlevel;\n+  struct binding_level *newlevel;\n \n   /* Reuse or create a struct for this binding level.  */\n \n@@ -1288,7 +1288,7 @@ push_label_level ()\n void\n pop_label_level ()\n {\n-  register struct binding_level *level = label_level_chain;\n+  struct binding_level *level = label_level_chain;\n   tree link, prev;\n \n   /* Clear out the definitions of the declared labels in this level.\n@@ -1350,7 +1350,7 @@ void\n pushtag (name, type)\n      tree name, type;\n {\n-  register struct binding_level *b;\n+  struct binding_level *b;\n \n   /* Find the proper binding level for this type tag.  */\n \n@@ -1394,7 +1394,7 @@ pushtag (name, type)\n \n static int\n duplicate_decls (newdecl, olddecl, different_binding_level)\n-     register tree newdecl, olddecl;\n+     tree newdecl, olddecl;\n      int different_binding_level;\n {\n   int types_match = comptypes (TREE_TYPE (newdecl), TREE_TYPE (olddecl));\n@@ -1610,12 +1610,12 @@ duplicate_decls (newdecl, olddecl, different_binding_level)\n \t       && DECL_INITIAL (newdecl) == 0)))\n \t{\n \t  /* Classify the problem further.  */\n-\t  register tree t = TYPE_ARG_TYPES (oldtype);\n+\t  tree t = TYPE_ARG_TYPES (oldtype);\n \t  if (t == 0)\n \t    t = TYPE_ARG_TYPES (newtype);\n \t  for (; t; t = TREE_CHAIN (t))\n \t    {\n-\t      register tree type = TREE_VALUE (t);\n+\t      tree type = TREE_VALUE (t);\n \n \t      if (TREE_CHAIN (t) == 0\n \t\t  && TYPE_MAIN_VARIANT (type) != void_type_node)\n@@ -1677,8 +1677,8 @@ duplicate_decls (newdecl, olddecl, different_binding_level)\n \t       && TYPE_ARG_TYPES (newtype) != 0\n \t       && TYPE_ACTUAL_ARG_TYPES (oldtype) != 0)\n \t{\n-\t  register tree type, parm;\n-\t  register int nargs;\n+\t  tree type, parm;\n+\t  int nargs;\n \t  /* Prototype decl follows defn w/o prototype.  */\n \n \t  for (parm = TYPE_ACTUAL_ARG_TYPES (oldtype),\n@@ -2028,7 +2028,7 @@ duplicate_decls (newdecl, olddecl, different_binding_level)\n   /* Copy most of the decl-specific fields of NEWDECL into OLDDECL.\n      But preserve OLDDECL's DECL_UID.  */\n   {\n-    register unsigned olddecl_uid = DECL_UID (olddecl);\n+    unsigned olddecl_uid = DECL_UID (olddecl);\n \n     memcpy ((char *) olddecl + sizeof (struct tree_common),\n \t    (char *) newdecl + sizeof (struct tree_common),\n@@ -2055,9 +2055,9 @@ tree\n pushdecl (x)\n      tree x;\n {\n-  register tree t;\n-  register tree name = DECL_NAME (x);\n-  register struct binding_level *b = current_binding_level;\n+  tree t;\n+  tree name = DECL_NAME (x);\n+  struct binding_level *b = current_binding_level;\n \n   /* Functions need the lang_decl data.  */\n   if (TREE_CODE (x) == FUNCTION_DECL && ! DECL_LANG_SPECIFIC (x))\n@@ -2505,8 +2505,8 @@ tree\n pushdecl_top_level (x)\n      tree x;\n {\n-  register tree t;\n-  register struct binding_level *b = current_binding_level;\n+  tree t;\n+  struct binding_level *b = current_binding_level;\n \n   current_binding_level = global_binding_level;\n   t = pushdecl (x);\n@@ -2669,7 +2669,7 @@ tree\n lookup_label (id)\n      tree id;\n {\n-  register tree decl = IDENTIFIER_LABEL_VALUE (id);\n+  tree decl = IDENTIFIER_LABEL_VALUE (id);\n \n   if (current_function_decl == 0)\n     {\n@@ -2719,11 +2719,11 @@ tree\n shadow_label (name)\n      tree name;\n {\n-  register tree decl = IDENTIFIER_LABEL_VALUE (name);\n+  tree decl = IDENTIFIER_LABEL_VALUE (name);\n \n   if (decl != 0)\n     {\n-      register tree dup;\n+      tree dup;\n \n       /* Check to make sure that the label hasn't already been declared\n \t at this label scope */\n@@ -2843,12 +2843,12 @@ lookup_tag (code, name, binding_level, thislevel_only)\n      tree name;\n      int thislevel_only;\n {\n-  register struct binding_level *level;\n+  struct binding_level *level;\n   int thislevel = 1;\n \n   for (level = binding_level; level; level = level->level_chain)\n     {\n-      register tree tail;\n+      tree tail;\n       for (tail = level->tags; tail; tail = TREE_CHAIN (tail))\n \t{\n \t  if (TREE_PURPOSE (tail) == name)\n@@ -2902,11 +2902,11 @@ static tree\n lookup_tag_reverse (type)\n      tree type;\n {\n-  register struct binding_level *level;\n+  struct binding_level *level;\n \n   for (level = current_binding_level; level; level = level->level_chain)\n     {\n-      register tree tail;\n+      tree tail;\n       for (tail = level->tags; tail; tail = TREE_CHAIN (tail))\n \t{\n \t  if (TREE_VALUE (tail) == type)\n@@ -2925,7 +2925,7 @@ tree\n lookup_name (name)\n      tree name;\n {\n-  register tree val;\n+  tree val;\n \n   if (current_binding_level != global_binding_level\n       && IDENTIFIER_LOCAL_VALUE (name))\n@@ -2941,7 +2941,7 @@ tree\n lookup_name_current_level (name)\n      tree name;\n {\n-  register tree t;\n+  tree t;\n \n   if (current_binding_level == global_binding_level)\n     return IDENTIFIER_GLOBAL_VALUE (name);\n@@ -2983,7 +2983,7 @@ mark_binding_level (arg)\n void\n init_decl_processing ()\n {\n-  register tree endlink;\n+  tree endlink;\n   tree ptr_ftype_void, ptr_ftype_ptr;\n \n   current_function_decl = NULL;\n@@ -3210,7 +3210,7 @@ shadow_tag_warned (declspecs, warned)\n \tno pedwarn.  */\n {\n   int found_tag = 0;\n-  register tree link;\n+  tree link;\n   tree specs, attrs;\n \n   pending_invalid_xref = 0;\n@@ -3221,15 +3221,15 @@ shadow_tag_warned (declspecs, warned)\n \n   for (link = specs; link; link = TREE_CHAIN (link))\n     {\n-      register tree value = TREE_VALUE (link);\n-      register enum tree_code code = TREE_CODE (value);\n+      tree value = TREE_VALUE (link);\n+      enum tree_code code = TREE_CODE (value);\n \n       if (code == RECORD_TYPE || code == UNION_TYPE || code == ENUMERAL_TYPE)\n \t/* Used to test also that TYPE_SIZE (value) != 0.\n \t   That caused warning for `struct foo;' at top level in the file.  */\n \t{\n-\t  register tree name = lookup_tag_reverse (value);\n-\t  register tree t;\n+\t  tree name = lookup_tag_reverse (value);\n+\t  tree t;\n \n \t  found_tag++;\n \n@@ -3376,7 +3376,7 @@ start_decl (declarator, declspecs, initialized, attributes)\n {\n   tree decl = grokdeclarator (declarator, declspecs,\n \t\t\t      NORMAL, initialized);\n-  register tree tem;\n+  tree tem;\n \n   if (warn_main > 0 && TREE_CODE (decl) != FUNCTION_DECL\n       && MAIN_NAME_P (DECL_NAME (decl)))\n@@ -3516,7 +3516,7 @@ finish_decl (decl, init, asmspec_tree)\n      tree decl, init;\n      tree asmspec_tree;\n {\n-  register tree type = TREE_TYPE (decl);\n+  tree type = TREE_TYPE (decl);\n   int was_incomplete = (DECL_SIZE (decl) == 0);\n   const char *asmspec = 0;\n \n@@ -3789,7 +3789,7 @@ complete_array_type (type, initial_value, do_default)\n      tree initial_value;\n      int do_default;\n {\n-  register tree maxindex = NULL_TREE;\n+  tree maxindex = NULL_TREE;\n   int value = 0;\n \n   if (initial_value)\n@@ -3918,7 +3918,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized)\n   /* Look inside a declarator for the name being declared\n      and get it as a string, for an error message.  */\n   {\n-    register tree decl = declarator;\n+    tree decl = declarator;\n     name = 0;\n \n     while (decl)\n@@ -3980,7 +3980,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized)\n \n   for (spec = declspecs; spec; spec = TREE_CHAIN (spec))\n     {\n-      register tree id = TREE_VALUE (spec);\n+      tree id = TREE_VALUE (spec);\n \n       if (id == ridpointers[(int) RID_INT])\n \texplicit_int = 1;\n@@ -4022,7 +4022,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized)\n       /* Built-in types come as identifiers.  */\n       else if (TREE_CODE (id) == IDENTIFIER_NODE)\n \t{\n-\t  register tree t = lookup_name (id);\n+\t  tree t = lookup_name (id);\n \t  if (TREE_TYPE (t) == error_mark_node)\n \t    ;\n \t  else if (!t || TREE_CODE (t) != TYPE_DECL)\n@@ -4376,8 +4376,8 @@ grokdeclarator (declarator, declspecs, decl_context, initialized)\n \t}\n       else if (TREE_CODE (declarator) == ARRAY_REF)\n \t{\n-\t  register tree itype = NULL_TREE;\n-\t  register tree size = TREE_OPERAND (declarator, 1);\n+\t  tree itype = NULL_TREE;\n+\t  tree size = TREE_OPERAND (declarator, 1);\n \t  /* The index is a signed object `sizetype' bits wide.  */\n \t  tree index_type = signed_type (sizetype);\n \n@@ -4613,7 +4613,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized)\n \t     the FUNCTION_TYPE node itself.  */\n \n \t  {\n-\t    register tree link;\n+\t    tree link;\n \n \t    for (link = last_function_parm_tags;\n \t\t link;\n@@ -4641,7 +4641,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized)\n \n \t  if (TREE_TYPE (declarator))\n \t    {\n-\t      register tree typemodlist;\n+\t      tree typemodlist;\n \t      int erred = 0;\n \n \t      constp = 0;\n@@ -5155,8 +5155,8 @@ tree\n get_parm_info (void_at_end)\n      int void_at_end;\n {\n-  register tree decl, t;\n-  register tree types = 0;\n+  tree decl, t;\n+  tree types = 0;\n   int erred = 0;\n   tree tags = gettags ();\n   tree parms = getdecls ();\n@@ -5300,7 +5300,7 @@ xref_tag (code, name)\n   /* If a cross reference is requested, look up the type\n      already defined for this tag and return it.  */\n \n-  register tree ref = lookup_tag (code, name, current_binding_level, 0);\n+  tree ref = lookup_tag (code, name, current_binding_level, 0);\n   /* If this is the right type of tag, return what we found.\n      (This reference will be shadowed by shadow_tag later if appropriate.)\n      If this is the wrong type of tag, do not return it.  If it was the\n@@ -5351,7 +5351,7 @@ start_struct (code, name)\n   /* If there is already a tag defined at this binding level\n      (as a forward reference), just return it.  */\n \n-  register tree ref = 0;\n+  tree ref = 0;\n \n   if (name != 0)\n     ref = lookup_tag (code, name, current_binding_level, 1);\n@@ -5423,7 +5423,7 @@ finish_struct (t, fieldlist, attributes)\n      tree fieldlist;\n      tree attributes;\n {\n-  register tree x;\n+  tree x;\n   int toplevel = global_binding_level == current_binding_level;\n   int saw_named_field;\n \n@@ -5623,7 +5623,7 @@ finish_struct (t, fieldlist, attributes)\n       x = TREE_CHAIN (x);\n     else\n       {\n-\tregister tree y = fieldlist;\n+\ttree y = fieldlist;\n \n \twhile (1)\n \t  {\n@@ -5740,7 +5740,7 @@ tree\n start_enum (name)\n      tree name;\n {\n-  register tree enumtype = 0;\n+  tree enumtype = 0;\n \n   /* If this is the real definition for a previous forward reference,\n      fill in the contents in the same object that used to be the\n@@ -5788,7 +5788,7 @@ finish_enum (enumtype, values, attributes)\n      tree values;\n      tree attributes;\n {\n-  register tree pair, tem;\n+  tree pair, tem;\n   tree minnode = 0, maxnode = 0, enum_value_type;\n   int precision, unsign;\n   int toplevel = (global_binding_level == current_binding_level);\n@@ -5919,7 +5919,7 @@ tree\n build_enumerator (name, value)\n      tree name, value;\n {\n-  register tree decl, type;\n+  tree decl, type;\n \n   /* Validate and default VALUE.  */\n \n@@ -6235,8 +6235,8 @@ c_mark_varargs ()\n void\n store_parm_decls ()\n {\n-  register tree fndecl = current_function_decl;\n-  register tree parm;\n+  tree fndecl = current_function_decl;\n+  tree parm;\n \n   /* This is either a chain of PARM_DECLs (if a prototype was used)\n      or a list of IDENTIFIER_NODEs (for an old-fashioned C definition).  */\n@@ -6246,7 +6246,7 @@ store_parm_decls ()\n   tree parmtags = current_function_parm_tags;\n \n   /* This is a chain of PARM_DECLs from old-style parm declarations.  */\n-  register tree parmdecls = getdecls ();\n+  tree parmdecls = getdecls ();\n \n   /* This is a chain of any other decls that came in among the parm\n      declarations.  If a parm is declared with  enum {foo, bar} x;\n@@ -6266,7 +6266,7 @@ store_parm_decls ()\n \t except record them as in effect\n \t and complain if any redundant old-style parm decls were written.  */\n \n-      register tree next;\n+      tree next;\n       tree others = 0;\n \n       prototype = 1;\n@@ -6372,7 +6372,7 @@ store_parm_decls ()\n \n       for (parm = specparms; parm; parm = TREE_CHAIN (parm))\n \t{\n-\t  register tree tail, found = NULL;\n+\t  tree tail, found = NULL;\n \n \t  if (TREE_VALUE (parm) == 0)\n \t    {\n@@ -6484,7 +6484,7 @@ store_parm_decls ()\n       parm = specparms;\n       DECL_ARGUMENTS (fndecl) = 0;\n       {\n-\tregister tree last;\n+\ttree last;\n \tfor (last = 0; parm; parm = TREE_CHAIN (parm))\n \t  if (TREE_PURPOSE (parm))\n \t    {\n@@ -6503,7 +6503,7 @@ store_parm_decls ()\n \n       if (TYPE_ARG_TYPES (TREE_TYPE (fndecl)))\n \t{\n-\t  register tree type;\n+\t  tree type;\n \t  for (parm = DECL_ARGUMENTS (fndecl),\n \t       type = TYPE_ARG_TYPES (TREE_TYPE (fndecl));\n \t       parm || (type && (TYPE_MAIN_VARIANT (TREE_VALUE (type))\n@@ -6671,7 +6671,7 @@ void\n finish_function (nested)\n      int nested;\n {\n-  register tree fndecl = current_function_decl;\n+  tree fndecl = current_function_decl;\n \n /*  TREE_READONLY (fndecl) = 1;\n     This caused &foo to be of type ptr-to-const-function"}, {"sha": "061ddb9cb46be6f729c3b96aa9e8a2d4d17e960b", "filename": "gcc/c-format.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Fc-format.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Fc-format.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-format.c?ref=b36948478c22c58018d0a888ee8ca393dea60dc9", "patch": "@@ -2362,8 +2362,8 @@ check_format_types (status, types)\n \tcontinue;\n       /* Now we have a type mismatch.  */\n       {\n-\tregister const char *this;\n-\tregister const char *that;\n+\tconst char *this;\n+\tconst char *that;\n \n \tthis = IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (wanted_type)));\n \tthat = 0;"}, {"sha": "86e2e8999bb76ca860edb396e7593b075d170df3", "filename": "gcc/c-semantics.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Fc-semantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Fc-semantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-semantics.c?ref=b36948478c22c58018d0a888ee8ca393dea60dc9", "patch": "@@ -170,9 +170,9 @@ finish_stmt_tree (t)\n tree\n build_stmt VPARAMS ((enum tree_code code, ...))\n {\n-  register tree t;\n-  register int length;\n-  register int i;\n+  tree t;\n+  int length;\n+  int i;\n \n   VA_OPEN (p, code);\n   VA_FIXEDARG (p, enum tree_code, code);"}, {"sha": "d2a7a8ccd9e15df690ffb859d04c1aec615d7858", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 68, "deletions": 69, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=b36948478c22c58018d0a888ee8ca393dea60dc9", "patch": "@@ -191,8 +191,8 @@ tree\n common_type (t1, t2)\n      tree t1, t2;\n {\n-  register enum tree_code code1;\n-  register enum tree_code code2;\n+  enum tree_code code1;\n+  enum tree_code code2;\n   tree attributes;\n \n   /* Save time if the two types are the same.  */\n@@ -436,8 +436,8 @@ int\n comptypes (type1, type2)\n      tree type1, type2;\n {\n-  register tree t1 = type1;\n-  register tree t2 = type2;\n+  tree t1 = type1;\n+  tree t2 = type2;\n   int attrval, val;\n \n   /* Suppress errors caused by previously reported errors.  */\n@@ -847,8 +847,8 @@ tree\n default_conversion (exp)\n      tree exp;\n {\n-  register tree type = TREE_TYPE (exp);\n-  register enum tree_code code = TREE_CODE (type);\n+  tree type = TREE_TYPE (exp);\n+  enum tree_code code = TREE_CODE (type);\n \n   /* Constants can be used directly unless they're not loadable.  */\n   if (TREE_CODE (exp) == CONST_DECL)\n@@ -924,7 +924,7 @@ default_conversion (exp)\n     }\n   if (code == ARRAY_TYPE)\n     {\n-      register tree adr;\n+      tree adr;\n       tree restype = TREE_TYPE (type);\n       tree ptrtype;\n       int constp = 0;\n@@ -1091,10 +1091,10 @@ tree\n build_component_ref (datum, component)\n      tree datum, component;\n {\n-  register tree type = TREE_TYPE (datum);\n-  register enum tree_code code = TREE_CODE (type);\n-  register tree field = NULL;\n-  register tree ref;\n+  tree type = TREE_TYPE (datum);\n+  enum tree_code code = TREE_CODE (type);\n+  tree field = NULL;\n+  tree ref;\n \n   /* If DATUM is a COMPOUND_EXPR or COND_EXPR, move our reference inside it\n      unless we are not to support things not strictly ANSI.  */\n@@ -1178,8 +1178,8 @@ build_indirect_ref (ptr, errorstring)\n      tree ptr;\n      const char *errorstring;\n {\n-  register tree pointer = default_conversion (ptr);\n-  register tree type = TREE_TYPE (pointer);\n+  tree pointer = default_conversion (ptr);\n+  tree type = TREE_TYPE (pointer);\n \n   if (TREE_CODE (type) == POINTER_TYPE)\n     {\n@@ -1191,8 +1191,7 @@ build_indirect_ref (ptr, errorstring)\n       else\n \t{\n \t  tree t = TREE_TYPE (type);\n-\t  register tree ref = build1 (INDIRECT_REF,\n-\t\t\t\t      TYPE_MAIN_VARIANT (t), pointer);\n+\t  tree ref = build1 (INDIRECT_REF, TYPE_MAIN_VARIANT (t), pointer);\n \n \t  if (!COMPLETE_OR_VOID_TYPE_P (t) && TREE_CODE (t) != ARRAY_TYPE)\n \t    {\n@@ -1462,8 +1461,8 @@ tree\n build_function_call (function, params)\n      tree function, params;\n {\n-  register tree fntype, fundecl = 0;\n-  register tree coerced_params;\n+  tree fntype, fundecl = 0;\n+  tree coerced_params;\n   tree name = NULL_TREE, assembler_name = NULL_TREE, result;\n \n   /* Strip NON_LVALUE_EXPRs, etc., since we aren't using as an lvalue.  */\n@@ -1559,8 +1558,8 @@ static tree\n convert_arguments (typelist, values, name, fundecl)\n      tree typelist, values, name, fundecl;\n {\n-  register tree typetail, valtail;\n-  register tree result = NULL;\n+  tree typetail, valtail;\n+  tree result = NULL;\n   int parmnum;\n \n   /* Scan the given expressions and types, producing individual\n@@ -1570,8 +1569,8 @@ convert_arguments (typelist, values, name, fundecl)\n        valtail;\n        valtail = TREE_CHAIN (valtail), parmnum++)\n     {\n-      register tree type = typetail ? TREE_VALUE (typetail) : 0;\n-      register tree val = TREE_VALUE (valtail);\n+      tree type = typetail ? TREE_VALUE (typetail) : 0;\n+      tree val = TREE_VALUE (valtail);\n \n       if (type == void_type_node)\n \t{\n@@ -1866,17 +1865,17 @@ build_binary_op (code, orig_op0, orig_op1, convert_p)\n      int convert_p;\n {\n   tree type0, type1;\n-  register enum tree_code code0, code1;\n+  enum tree_code code0, code1;\n   tree op0, op1;\n \n   /* Expression code to give to the expression when it is built.\n      Normally this is CODE, which is what the caller asked for,\n      but in some special cases we change it.  */\n-  register enum tree_code resultcode = code;\n+  enum tree_code resultcode = code;\n \n   /* Data type in which the computation is to be performed.\n      In the simplest cases this is the common type of the arguments.  */\n-  register tree result_type = NULL;\n+  tree result_type = NULL;\n \n   /* Nonzero means operands have already been type-converted\n      in whatever way is necessary.\n@@ -2164,8 +2163,8 @@ build_binary_op (code, orig_op0, orig_op1, convert_p)\n \tshort_compare = 1;\n       else if (code0 == POINTER_TYPE && code1 == POINTER_TYPE)\n \t{\n-\t  register tree tt0 = TREE_TYPE (type0);\n-\t  register tree tt1 = TREE_TYPE (type1);\n+\t  tree tt0 = TREE_TYPE (type0);\n+\t  tree tt1 = TREE_TYPE (type1);\n \t  /* Anything compares with void *.  void * compares with anything.\n \t     Otherwise, the targets must be compatible\n \t     and both must be object or both incomplete.  */\n@@ -2585,8 +2584,8 @@ build_binary_op (code, orig_op0, orig_op1, convert_p)\n     build_type = result_type;\n \n   {\n-    register tree result = build (resultcode, build_type, op0, op1);\n-    register tree folded;\n+    tree result = build (resultcode, build_type, op0, op1);\n+    tree folded;\n \n     folded = fold (result);\n     if (folded == result)\n@@ -2603,16 +2602,16 @@ build_binary_op (code, orig_op0, orig_op1, convert_p)\n static tree\n pointer_int_sum (resultcode, ptrop, intop)\n      enum tree_code resultcode;\n-     register tree ptrop, intop;\n+     tree ptrop, intop;\n {\n   tree size_exp;\n \n-  register tree result;\n-  register tree folded;\n+  tree result;\n+  tree folded;\n \n   /* The result is a pointer of the same type that is being added.  */\n \n-  register tree result_type = TREE_TYPE (ptrop);\n+  tree result_type = TREE_TYPE (ptrop);\n \n   if (TREE_CODE (TREE_TYPE (result_type)) == VOID_TYPE)\n     {\n@@ -2691,9 +2690,9 @@ pointer_int_sum (resultcode, ptrop, intop)\n \n static tree\n pointer_diff (op0, op1)\n-     register tree op0, op1;\n+     tree op0, op1;\n {\n-  register tree result, folded;\n+  tree result, folded;\n   tree restype = ptrdiff_type_node;\n \n   tree target_type = TREE_TYPE (TREE_TYPE (op0));\n@@ -2778,9 +2777,9 @@ build_unary_op (code, xarg, noconvert)\n      int noconvert;\n {\n   /* No default_conversion here.  It causes trouble for ADDR_EXPR.  */\n-  register tree arg = xarg;\n-  register tree argtype = 0;\n-  register enum tree_code typecode = TREE_CODE (TREE_TYPE (arg));\n+  tree arg = xarg;\n+  tree argtype = 0;\n+  enum tree_code typecode = TREE_CODE (TREE_TYPE (arg));\n   tree val;\n \n   if (typecode == ERROR_MARK)\n@@ -2927,7 +2926,7 @@ build_unary_op (code, xarg, noconvert)\n \t}\n \n       {\n-\tregister tree inc;\n+\ttree inc;\n \ttree result_type = TREE_TYPE (arg);\n \n \targ = get_unwidened (arg, 0);\n@@ -3188,7 +3187,7 @@ int\n lvalue_p (ref)\n      tree ref;\n {\n-  register enum tree_code code = TREE_CODE (ref);\n+  enum tree_code code = TREE_CODE (ref);\n \n   switch (code)\n     {\n@@ -3327,7 +3326,7 @@ int\n mark_addressable (exp)\n      tree exp;\n {\n-  register tree x = exp;\n+  tree x = exp;\n   while (1)\n     switch (TREE_CODE (x))\n       {\n@@ -3412,11 +3411,11 @@ tree\n build_conditional_expr (ifexp, op1, op2)\n      tree ifexp, op1, op2;\n {\n-  register tree type1;\n-  register tree type2;\n-  register enum tree_code code1;\n-  register enum tree_code code2;\n-  register tree result_type = NULL;\n+  tree type1;\n+  tree type2;\n+  enum tree_code code1;\n+  enum tree_code code2;\n+  tree result_type = NULL;\n   tree orig_op1 = op1, orig_op2 = op2;\n \n   ifexp = truthvalue_conversion (default_conversion (ifexp));\n@@ -3600,7 +3599,7 @@ internal_build_compound_expr (list, first_p)\n      tree list;\n      int first_p;\n {\n-  register tree rest;\n+  tree rest;\n \n   if (TREE_CHAIN (list) == 0)\n     {\n@@ -3654,10 +3653,10 @@ internal_build_compound_expr (list, first_p)\n \n tree\n build_c_cast (type, expr)\n-     register tree type;\n+     tree type;\n      tree expr;\n {\n-  register tree value = expr;\n+  tree value = expr;\n   \n   if (type == error_mark_node || expr == error_mark_node)\n     return error_mark_node;\n@@ -3856,7 +3855,7 @@ build_modify_expr (lhs, modifycode, rhs)\n      tree lhs, rhs;\n      enum tree_code modifycode;\n {\n-  register tree result;\n+  tree result;\n   tree newrhs;\n   tree lhstype = TREE_TYPE (lhs);\n   tree olhstype = lhstype;\n@@ -4037,9 +4036,9 @@ convert_for_assignment (type, rhs, errtype, fundecl, funname, parmnum)\n      tree fundecl, funname;\n      int parmnum;\n {\n-  register enum tree_code codel = TREE_CODE (type);\n-  register tree rhstype;\n-  register enum tree_code coder;\n+  enum tree_code codel = TREE_CODE (type);\n+  tree rhstype;\n+  enum tree_code coder;\n \n   /* Strip NON_LVALUE_EXPRs since we aren't using as an lvalue.  */\n   /* Do not use STRIP_NOPS here.  We do not want an enumerator\n@@ -4124,8 +4123,8 @@ convert_for_assignment (type, rhs, errtype, fundecl, funname, parmnum)\n \n \t  if (coder == POINTER_TYPE)\n \t    {\n-\t      register tree ttl = TREE_TYPE (memb_type);\n-\t      register tree ttr = TREE_TYPE (rhstype);\n+\t      tree ttl = TREE_TYPE (memb_type);\n+\t      tree ttr = TREE_TYPE (rhstype);\n \n \t      /* Any non-function converts to a [const][volatile] void *\n \t\t and vice versa; otherwise, targets must be the same.\n@@ -4166,8 +4165,8 @@ convert_for_assignment (type, rhs, errtype, fundecl, funname, parmnum)\n \t    {\n \t      /* We have only a marginally acceptable member type;\n \t\t it needs a warning.  */\n-\t      register tree ttl = TREE_TYPE (marginal_memb_type);\n-\t      register tree ttr = TREE_TYPE (rhstype);\n+\t      tree ttl = TREE_TYPE (marginal_memb_type);\n+\t      tree ttr = TREE_TYPE (rhstype);\n \n \t      /* Const and volatile mean something different for function\n \t\t types, so the usual warnings are not appropriate.  */\n@@ -4200,8 +4199,8 @@ convert_for_assignment (type, rhs, errtype, fundecl, funname, parmnum)\n   else if ((codel == POINTER_TYPE || codel == REFERENCE_TYPE)\n \t   && (coder == POINTER_TYPE || coder == REFERENCE_TYPE))\n     {\n-      register tree ttl = TREE_TYPE (type);\n-      register tree ttr = TREE_TYPE (rhstype);\n+      tree ttl = TREE_TYPE (type);\n+      tree ttr = TREE_TYPE (rhstype);\n \n       /* Any non-function converts to a [const][volatile] void *\n \t and vice versa; otherwise, targets must be the same.\n@@ -4386,7 +4385,7 @@ void\n store_init_value (decl, init)\n      tree decl, init;\n {\n-  register tree value, type;\n+  tree value, type;\n \n   /* If variable's type was invalidly declared, just ignore it.  */\n \n@@ -4539,8 +4538,8 @@ push_array_bounds (bounds)\n static int\n spelling_length ()\n {\n-  register int size = 0;\n-  register struct spelling *p;\n+  int size = 0;\n+  struct spelling *p;\n \n   for (p = spelling_base; p < spelling; p++)\n     {\n@@ -4557,10 +4556,10 @@ spelling_length ()\n \n static char *\n print_spelling (buffer)\n-     register char *buffer;\n+     char *buffer;\n {\n-  register char *d = buffer;\n-  register struct spelling *p;\n+  char *d = buffer;\n+  struct spelling *p;\n \n   for (p = spelling_base; p < spelling; p++)\n     if (p->kind == SPELLING_BOUNDS)\n@@ -4570,7 +4569,7 @@ print_spelling (buffer)\n       }\n     else\n       {\n-\tregister const char *s;\n+\tconst char *s;\n \tif (p->kind == SPELLING_MEMBER)\n \t  *d++ = '.';\n \tfor (s = p->u.s; (*d = *s++); d++)\n@@ -6854,10 +6853,10 @@ c_expand_asm_operands (string, outputs, inputs, clobbers, vol, filename, line)\n      int line;\n {\n   int noutputs = list_length (outputs);\n-  register int i;\n+  int i;\n   /* o[I] is the place that output number I should be written.  */\n-  register tree *o = (tree *) alloca (noutputs * sizeof (tree));\n-  register tree tail;\n+  tree *o = (tree *) alloca (noutputs * sizeof (tree));\n+  tree tail;\n \n   /* Record the contents of OUTPUTS before it is modified.  */\n   for (i = 0, tail = outputs; tail; tail = TREE_CHAIN (tail), i++)\n@@ -7022,7 +7021,7 @@ tree\n c_start_case (exp)\n      tree exp;\n {\n-  register enum tree_code code;\n+  enum tree_code code;\n   tree type;\n   struct c_switch *cs;\n "}, {"sha": "c5baa1321b4dc131a73ff45c5e5c6a736e4bc596", "filename": "gcc/caller-save.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Fcaller-save.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Fcaller-save.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcaller-save.c?ref=b36948478c22c58018d0a888ee8ca393dea60dc9", "patch": "@@ -482,7 +482,7 @@ mark_set_regs (reg, setter, data)\n      rtx setter ATTRIBUTE_UNUSED;\n      void *data ATTRIBUTE_UNUSED;\n {\n-  register int regno, endregno, i;\n+  int regno, endregno, i;\n   enum machine_mode mode = GET_MODE (reg);\n \n   if (GET_CODE (reg) == SUBREG)\n@@ -515,7 +515,7 @@ add_stored_regs (reg, setter, data)\n      rtx setter;\n      void *data;\n {\n-  register int regno, endregno, i;\n+  int regno, endregno, i;\n   enum machine_mode mode = GET_MODE (reg);\n   int offset = 0;\n "}, {"sha": "5b5657fc1b957eb837af3b6b2bf101e417291eef", "filename": "gcc/calls.c", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=b36948478c22c58018d0a888ee8ca393dea60dc9", "patch": "@@ -256,7 +256,7 @@ calls_function_1 (exp, which)\n      tree exp;\n      int which;\n {\n-  register int i;\n+  int i;\n   enum tree_code code = TREE_CODE (exp);\n   int class = TREE_CODE_CLASS (code);\n   int length = first_rtl_op (code);\n@@ -308,8 +308,8 @@ calls_function_1 (exp, which)\n \n     case BLOCK:\n       {\n-\tregister tree local;\n-\tregister tree subblock;\n+\ttree local;\n+\ttree subblock;\n \n \tfor (local = BLOCK_VARS (exp); local; local = TREE_CHAIN (local))\n \t  if (DECL_INITIAL (local) != 0\n@@ -2156,8 +2156,8 @@ expand_call (exp, target, ignore)\n   int old_inhibit_defer_pop = inhibit_defer_pop;\n   int old_stack_allocated;\n   rtx call_fusage;\n-  register tree p = TREE_OPERAND (exp, 0);\n-  register int i;\n+  tree p = TREE_OPERAND (exp, 0);\n+  int i;\n   /* The alignment of the stack, in bits.  */\n   HOST_WIDE_INT preferred_stack_boundary;\n   /* The alignment of the stack, in bytes.  */\n@@ -3461,7 +3461,7 @@ emit_library_call_value_1 (retval, orgfun, value, fn_type, outmode, nargs, p)\n   struct args_size args_size;\n   /* Size of arguments before any adjustments (such as rounding).  */\n   struct args_size original_args_size;\n-  register int argnum;\n+  int argnum;\n   rtx fun;\n   int inc;\n   int count;\n@@ -3912,8 +3912,8 @@ emit_library_call_value_1 (retval, orgfun, value, fn_type, outmode, nargs, p)\n      are to be pushed.  */\n   for (count = 0; count < nargs; count++, argnum += inc)\n     {\n-      register enum machine_mode mode = argvec[argnum].mode;\n-      register rtx val = argvec[argnum].value;\n+      enum machine_mode mode = argvec[argnum].mode;\n+      rtx val = argvec[argnum].value;\n       rtx reg = argvec[argnum].reg;\n       int partial = argvec[argnum].partial;\n       int lower_bound = 0, upper_bound = 0, i;\n@@ -3995,7 +3995,7 @@ emit_library_call_value_1 (retval, orgfun, value, fn_type, outmode, nargs, p)\n      are to be pushed.  */\n   for (count = 0; count < nargs; count++, argnum += inc)\n     {\n-      register rtx val = argvec[argnum].value;\n+      rtx val = argvec[argnum].value;\n       rtx reg = argvec[argnum].reg;\n       int partial = argvec[argnum].partial;\n \n@@ -4200,9 +4200,9 @@ emit_library_call_value_1 (retval, orgfun, value, fn_type, outmode, nargs, p)\n    and machine_modes to convert them to.\n    The rtx values should have been passed through protect_from_queue already.\n \n-   FN_TYPE will is zero for `normal' calls, one for `const' calls, wich\n-   which will be enclosed in REG_LIBCALL/REG_RETVAL notes and two for `pure'\n-   calls, that are handled like `const' calls with extra\n+   FN_TYPE will be zero for `normal' calls, one for `const' calls,\n+   which will be enclosed in REG_LIBCALL/REG_RETVAL notes, and two for\n+   `pure' calls, that are handled like `const' calls with extra\n    (use (memory (scratch)).  */\n \n void\n@@ -4315,7 +4315,7 @@ store_one_arg (arg, argblock, flags, variable_size, reg_parm_stack_space)\n      int variable_size ATTRIBUTE_UNUSED;\n      int reg_parm_stack_space;\n {\n-  register tree pval = arg->tree_value;\n+  tree pval = arg->tree_value;\n   rtx reg = 0;\n   int partial = 0;\n   int used = 0;\n@@ -4475,7 +4475,7 @@ store_one_arg (arg, argblock, flags, variable_size, reg_parm_stack_space)\n     }\n   else if (arg->mode != BLKmode)\n     {\n-      register int size;\n+      int size;\n \n       /* Argument is a scalar, not entirely passed in registers.\n \t (If part is passed in registers, arg->partial says how much\n@@ -4514,7 +4514,7 @@ store_one_arg (arg, argblock, flags, variable_size, reg_parm_stack_space)\n     {\n       /* BLKmode, at least partly to be pushed.  */\n \n-      register int excess;\n+      int excess;\n       rtx size_rtx;\n \n       /* Pushing a nonscalar."}, {"sha": "d8d8c992b7d678c645cbdda1746a5c12b1bcd90a", "filename": "gcc/cfg.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Fcfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Fcfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfg.c?ref=b36948478c22c58018d0a888ee8ca393dea60dc9", "patch": "@@ -410,7 +410,7 @@ void\n dump_flow_info (file)\n      FILE *file;\n {\n-  register int i;\n+  int i;\n   static const char * const reg_class_names[] = REG_CLASS_NAMES;\n \n   fprintf (file, \"%d registers.\\n\", max_regno);\n@@ -456,8 +456,8 @@ dump_flow_info (file)\n   fprintf (file, \"\\n%d basic blocks, %d edges.\\n\", n_basic_blocks, n_edges);\n   for (i = 0; i < n_basic_blocks; i++)\n     {\n-      register basic_block bb = BASIC_BLOCK (i);\n-      register edge e;\n+      basic_block bb = BASIC_BLOCK (i);\n+      edge e;\n \n       fprintf (file, \"\\nBasic block %d: first insn %d, last %d, loop_depth %d, count \",\n \t       i, INSN_UID (bb->head), INSN_UID (bb->end), bb->loop_depth);"}, {"sha": "b27c23966edb79de6b394d78945a84560acfcda9", "filename": "gcc/cfgbuild.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Fcfgbuild.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Fcfgbuild.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgbuild.c?ref=b36948478c22c58018d0a888ee8ca393dea60dc9", "patch": "@@ -62,9 +62,9 @@ static int\n count_basic_blocks (f)\n      rtx f;\n {\n-  register rtx insn;\n-  register RTX_CODE prev_code;\n-  register int count = 0;\n+  rtx insn;\n+  RTX_CODE prev_code;\n+  int count = 0;\n   int saw_abnormal_edge = 0;\n \n   prev_code = JUMP_INSN;\n@@ -407,7 +407,7 @@ static void\n find_basic_blocks_1 (f)\n      rtx f;\n {\n-  register rtx insn, next;\n+  rtx insn, next;\n   int i = 0;\n   rtx bb_note = NULL_RTX;\n   rtx lvl = NULL_RTX;"}, {"sha": "edd88bd9a0f189c4dbaeed7928d876c12137e9fe", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=b36948478c22c58018d0a888ee8ca393dea60dc9", "patch": "@@ -1410,7 +1410,7 @@ print_rtl_with_bb (outf, rtx_first)\n      FILE *outf;\n      rtx rtx_first;\n {\n-  register rtx tmp_rtx;\n+  rtx tmp_rtx;\n \n   if (rtx_first == 0)\n     fprintf (outf, \"(nil)\\n\");"}, {"sha": "c8fafc3e2c1355a3683bd4b5e277d058c62e2e49", "filename": "gcc/collect2.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Fcollect2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Fcollect2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcollect2.c?ref=b36948478c22c58018d0a888ee8ca393dea60dc9", "patch": "@@ -560,9 +560,9 @@ is_ctor_dtor (s)\n   struct names { const char *const name; const int len; const int ret;\n     const int two_underscores; };\n \n-  register struct names *p;\n-  register int ch;\n-  register const char *orig_s = s;\n+  struct names *p;\n+  int ch;\n+  const char *orig_s = s;\n \n   static struct names special[] = {\n     { \"GLOBAL__I_\", sizeof (\"GLOBAL__I_\")-1, 1, 0 },"}, {"sha": "43b1b9e9a1913830ae559e790cebb5e2b619e063", "filename": "gcc/combine.c", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=b36948478c22c58018d0a888ee8ca393dea60dc9", "patch": "@@ -478,12 +478,12 @@ combine_instructions (f, nregs)\n      rtx f;\n      unsigned int nregs;\n {\n-  register rtx insn, next;\n+  rtx insn, next;\n #ifdef HAVE_cc0\n-  register rtx prev;\n+  rtx prev;\n #endif\n-  register int i;\n-  register rtx links, nextlinks;\n+  int i;\n+  rtx links, nextlinks;\n \n   int new_direct_jump_p = 0;\n \n@@ -1473,8 +1473,8 @@ cant_combine_insn_p (insn)\n \n static rtx\n try_combine (i3, i2, i1, new_direct_jump_p)\n-     register rtx i3, i2, i1;\n-     register int *new_direct_jump_p;\n+     rtx i3, i2, i1;\n+     int *new_direct_jump_p;\n {\n   /* New patterns for I3 and I2, respectively.  */\n   rtx newpat, newi2pat = 0;\n@@ -1506,7 +1506,7 @@ try_combine (i3, i2, i1, new_direct_jump_p)\n \n   int maxreg;\n   rtx temp;\n-  register rtx link;\n+  rtx link;\n   int i;\n \n   /* Exit early if one of the insns involved can't be used for\n@@ -3261,14 +3261,14 @@ find_split_point (loc, insn)\n \n static rtx\n subst (x, from, to, in_dest, unique_copy)\n-     register rtx x, from, to;\n+     rtx x, from, to;\n      int in_dest;\n      int unique_copy;\n {\n-  register enum rtx_code code = GET_CODE (x);\n+  enum rtx_code code = GET_CODE (x);\n   enum machine_mode op0_mode = VOIDmode;\n-  register const char *fmt;\n-  register int len, i;\n+  const char *fmt;\n+  int len, i;\n   rtx new;\n \n /* Two expressions are equal if they are identical copies of a shared\n@@ -3376,7 +3376,7 @@ subst (x, from, to, in_dest, unique_copy)\n \t{\n \t  if (fmt[i] == 'E')\n \t    {\n-\t      register int j;\n+\t      int j;\n \t      for (j = XVECLEN (x, i) - 1; j >= 0; j--)\n \t\t{\n \t\t  if (COMBINE_RTX_EQUAL_P (XVECEXP (x, i, j), from))\n@@ -9550,7 +9550,7 @@ recog_for_combine (pnewpat, insn, pnotes)\n      rtx insn;\n      rtx *pnotes;\n {\n-  register rtx pat = *pnewpat;\n+  rtx pat = *pnewpat;\n   int insn_code_number;\n   int num_clobbers_to_add = 0;\n   int i;\n@@ -9654,7 +9654,7 @@ recog_for_combine (pnewpat, insn, pnotes)\n static rtx\n gen_lowpart_for_combine (mode, x)\n      enum machine_mode mode;\n-     register rtx x;\n+     rtx x;\n {\n   rtx result;\n \n@@ -9697,7 +9697,7 @@ gen_lowpart_for_combine (mode, x)\n \n   if (GET_CODE (x) == MEM)\n     {\n-      register int offset = 0;\n+      int offset = 0;\n \n       /* Refuse to work on a volatile memory ref or one with a mode-dependent\n \t address.  */\n@@ -10964,9 +10964,9 @@ static void\n update_table_tick (x)\n      rtx x;\n {\n-  register enum rtx_code code = GET_CODE (x);\n-  register const char *fmt = GET_RTX_FORMAT (code);\n-  register int i;\n+  enum rtx_code code = GET_CODE (x);\n+  const char *fmt = GET_RTX_FORMAT (code);\n+  int i;\n \n   if (code == REG)\n     {\n@@ -11148,7 +11148,7 @@ static void\n record_dead_and_set_regs (insn)\n      rtx insn;\n {\n-  register rtx link;\n+  rtx link;\n   unsigned int i;\n \n   for (link = REG_NOTES (insn); link; link = XEXP (link, 1))\n@@ -11409,12 +11409,12 @@ get_last_value (x)\n \n static int\n use_crosses_set_p (x, from_cuid)\n-     register rtx x;\n+     rtx x;\n      int from_cuid;\n {\n-  register const char *fmt;\n-  register int i;\n-  register enum rtx_code code = GET_CODE (x);\n+  const char *fmt;\n+  int i;\n+  enum rtx_code code = GET_CODE (x);\n \n   if (code == REG)\n     {\n@@ -11444,7 +11444,7 @@ use_crosses_set_p (x, from_cuid)\n     {\n       if (fmt[i] == 'E')\n \t{\n-\t  register int j;\n+\t  int j;\n \t  for (j = XVECLEN (x, i) - 1; j >= 0; j--)\n \t    if (use_crosses_set_p (XVECEXP (x, i, j), from_cuid))\n \t      return 1;\n@@ -11617,7 +11617,7 @@ mark_used_regs_combine (x)\n       {\n \t/* If setting a MEM, or a SUBREG of a MEM, then note any hard regs in\n \t   the address.  */\n-\tregister rtx testreg = SET_DEST (x);\n+\trtx testreg = SET_DEST (x);\n \n \twhile (GET_CODE (testreg) == SUBREG\n \t       || GET_CODE (testreg) == ZERO_EXTRACT\n@@ -11639,15 +11639,15 @@ mark_used_regs_combine (x)\n   /* Recursively scan the operands of this expression.  */\n \n   {\n-    register const char *fmt = GET_RTX_FORMAT (code);\n+    const char *fmt = GET_RTX_FORMAT (code);\n \n     for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n       {\n \tif (fmt[i] == 'e')\n \t  mark_used_regs_combine (XEXP (x, i));\n \telse if (fmt[i] == 'E')\n \t  {\n-\t    register int j;\n+\t    int j;\n \n \t    for (j = 0; j < XVECLEN (x, i); j++)\n \t      mark_used_regs_combine (XVECEXP (x, i, j));\n@@ -11665,7 +11665,7 @@ remove_death (regno, insn)\n      unsigned int regno;\n      rtx insn;\n {\n-  register rtx note = find_regno_note (insn, REG_DEAD, regno);\n+  rtx note = find_regno_note (insn, REG_DEAD, regno);\n \n   if (note)\n     {\n@@ -11694,15 +11694,15 @@ move_deaths (x, maybe_kill_insn, from_cuid, to_insn, pnotes)\n      rtx to_insn;\n      rtx *pnotes;\n {\n-  register const char *fmt;\n-  register int len, i;\n-  register enum rtx_code code = GET_CODE (x);\n+  const char *fmt;\n+  int len, i;\n+  enum rtx_code code = GET_CODE (x);\n \n   if (code == REG)\n     {\n       unsigned int regno = REGNO (x);\n-      register rtx where_dead = reg_last_death[regno];\n-      register rtx before_dead, after_dead;\n+      rtx where_dead = reg_last_death[regno];\n+      rtx before_dead, after_dead;\n \n       /* Don't move the register if it gets killed in between from and to */\n       if (maybe_kill_insn && reg_set_p (x, maybe_kill_insn)\n@@ -11846,7 +11846,7 @@ move_deaths (x, maybe_kill_insn, from_cuid, to_insn, pnotes)\n     {\n       if (fmt[i] == 'E')\n \t{\n-\t  register int j;\n+\t  int j;\n \t  for (j = XVECLEN (x, i) - 1; j >= 0; j--)\n \t    move_deaths (XVECEXP (x, i, j), maybe_kill_insn, from_cuid,\n \t\t\t to_insn, pnotes);"}, {"sha": "127b22b7eef5747356e67cc0ab9bb7c6fa1c3994", "filename": "gcc/convert.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Fconvert.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Fconvert.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconvert.c?ref=b36948478c22c58018d0a888ee8ca393dea60dc9", "patch": "@@ -295,7 +295,7 @@ convert_to_integer (type, expr)\n \t      {\n \t\t/* Do the arithmetic in type TYPEX,\n \t\t   then convert result to TYPE.  */\n-\t\tregister tree typex = type;\n+\t\ttree typex = type;\n \n \t\t/* Can't do arithmetic in enumeral types\n \t\t   so use an integer type that will hold the values.  */\n@@ -333,7 +333,7 @@ convert_to_integer (type, expr)\n \t  /* This is not correct for ABS_EXPR,\n \t     since we must test the sign before truncation.  */\n \t  {\n-\t    register tree typex = type;\n+\t    tree typex = type;\n \n \t    /* Can't do arithmetic in enumeral types\n \t       so use an integer type that will hold the values.  */"}, {"sha": "040bf86f48c365fcadb26d8bb6b9511a813f42fd", "filename": "gcc/cppexp.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Fcppexp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Fcppexp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppexp.c?ref=b36948478c22c58018d0a888ee8ca393dea60dc9", "patch": "@@ -572,7 +572,7 @@ _cpp_parse_expr (pfile)\n   struct op init_stack[INIT_STACK_SIZE];\n   struct op *stack = init_stack;\n   struct op *limit = stack + INIT_STACK_SIZE;\n-  register struct op *top = stack + 1;\n+  struct op *top = stack + 1;\n   int skip_evaluation = 0;\n   int result;\n   unsigned int lex_count, saw_leading_not;"}, {"sha": "bacb8e18ef97d06087b897bcf9fc13440b2ca547", "filename": "gcc/cppfiles.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Fcppfiles.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Fcppfiles.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppfiles.c?ref=b36948478c22c58018d0a888ee8ca393dea60dc9", "patch": "@@ -859,7 +859,7 @@ read_name_map (pfile, dirname)\n      cpp_reader *pfile;\n      const char *dirname;\n {\n-  register struct file_name_map_list *map_list_ptr;\n+  struct file_name_map_list *map_list_ptr;\n   char *name;\n   FILE *f;\n "}, {"sha": "efe1fadab48a6b707dd790d29eee8a53913dcf62", "filename": "gcc/cse.c", "status": "modified", "additions": 90, "deletions": 90, "changes": 180, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=b36948478c22c58018d0a888ee8ca393dea60dc9", "patch": "@@ -826,10 +826,10 @@ rtx_cost (x, outer_code)\n      rtx x;\n      enum rtx_code outer_code ATTRIBUTE_UNUSED;\n {\n-  register int i, j;\n-  register enum rtx_code code;\n-  register const char *fmt;\n-  register int total;\n+  int i, j;\n+  enum rtx_code code;\n+  const char *fmt;\n+  int total;\n \n   if (x == 0)\n     return 0;\n@@ -985,7 +985,7 @@ get_cse_reg_info (regno)\n static void\n new_basic_block ()\n {\n-  register int i;\n+  int i;\n \n   next_qty = max_reg;\n \n@@ -1043,9 +1043,9 @@ make_new_qty (reg, mode)\n      unsigned int reg;\n      enum machine_mode mode;\n {\n-  register int q;\n-  register struct qty_table_elem *ent;\n-  register struct reg_eqv_elem *eqv;\n+  int q;\n+  struct qty_table_elem *ent;\n+  struct reg_eqv_elem *eqv;\n \n   if (next_qty >= max_qty)\n     abort ();\n@@ -1133,9 +1133,9 @@ static void\n delete_reg_equiv (reg)\n      unsigned int reg;\n {\n-  register struct qty_table_elem *ent;\n-  register int q = REG_QTY (reg);\n-  register int p, n;\n+  struct qty_table_elem *ent;\n+  int q = REG_QTY (reg);\n+  int p, n;\n \n   /* If invalid, do nothing.  */\n   if (q == (int) reg)\n@@ -1174,10 +1174,10 @@ static int\n mention_regs (x)\n      rtx x;\n {\n-  register enum rtx_code code;\n-  register int i, j;\n-  register const char *fmt;\n-  register int changed = 0;\n+  enum rtx_code code;\n+  int i, j;\n+  const char *fmt;\n+  int changed = 0;\n \n   if (x == 0)\n     return 0;\n@@ -1358,7 +1358,7 @@ insert_regs (x, classp, modified)\n \n static void\n remove_from_table (elt, hash)\n-     register struct table_elt *elt;\n+     struct table_elt *elt;\n      unsigned hash;\n {\n   if (elt == 0)\n@@ -1370,8 +1370,8 @@ remove_from_table (elt, hash)\n   /* Remove the table element from its equivalence class.  */\n \n   {\n-    register struct table_elt *prev = elt->prev_same_value;\n-    register struct table_elt *next = elt->next_same_value;\n+    struct table_elt *prev = elt->prev_same_value;\n+    struct table_elt *next = elt->next_same_value;\n \n     if (next)\n       next->prev_same_value = prev;\n@@ -1380,7 +1380,7 @@ remove_from_table (elt, hash)\n       prev->next_same_value = next;\n     else\n       {\n-\tregister struct table_elt *newfirst = next;\n+\tstruct table_elt *newfirst = next;\n \twhile (next)\n \t  {\n \t    next->first_same_value = newfirst;\n@@ -1392,8 +1392,8 @@ remove_from_table (elt, hash)\n   /* Remove the table element from its hash bucket.  */\n \n   {\n-    register struct table_elt *prev = elt->prev_same_hash;\n-    register struct table_elt *next = elt->next_same_hash;\n+    struct table_elt *prev = elt->prev_same_hash;\n+    struct table_elt *next = elt->next_same_hash;\n \n     if (next)\n       next->prev_same_hash = prev;\n@@ -1418,7 +1418,7 @@ remove_from_table (elt, hash)\n \n   if (elt->related_value != 0 && elt->related_value != elt)\n     {\n-      register struct table_elt *p = elt->related_value;\n+      struct table_elt *p = elt->related_value;\n \n       while (p->related_value != elt)\n \tp = p->related_value;\n@@ -1447,7 +1447,7 @@ lookup (x, hash, mode)\n      unsigned hash;\n      enum machine_mode mode;\n {\n-  register struct table_elt *p;\n+  struct table_elt *p;\n \n   for (p = table[hash]; p; p = p->next_same_hash)\n     if (mode == p->mode && ((x == p->exp && GET_CODE (x) == REG)\n@@ -1466,7 +1466,7 @@ lookup_for_remove (x, hash, mode)\n      unsigned hash;\n      enum machine_mode mode;\n {\n-  register struct table_elt *p;\n+  struct table_elt *p;\n \n   if (GET_CODE (x) == REG)\n     {\n@@ -1497,7 +1497,7 @@ lookup_as_function (x, code)\n      rtx x;\n      enum rtx_code code;\n {\n-  register struct table_elt *p\n+  struct table_elt *p\n     = lookup (x, safe_hash (x, VOIDmode) & HASH_MASK, GET_MODE (x));\n \n   /* If we are looking for a CONST_INT, the mode doesn't really matter, as\n@@ -1552,12 +1552,12 @@ lookup_as_function (x, code)\n \n static struct table_elt *\n insert (x, classp, hash, mode)\n-     register rtx x;\n-     register struct table_elt *classp;\n+     rtx x;\n+     struct table_elt *classp;\n      unsigned hash;\n      enum machine_mode mode;\n {\n-  register struct table_elt *elt;\n+  struct table_elt *elt;\n \n   /* If X is a register and we haven't made a quantity for it,\n      something is wrong.  */\n@@ -1616,7 +1616,7 @@ insert (x, classp, hash, mode)\n       if (CHEAPER (elt, classp))\n \t/* Insert at the head of the class */\n \t{\n-\t  register struct table_elt *p;\n+\t  struct table_elt *p;\n \t  elt->next_same_value = classp;\n \t  classp->prev_same_value = elt;\n \t  elt->first_same_value = elt;\n@@ -1628,7 +1628,7 @@ insert (x, classp, hash, mode)\n \t{\n \t  /* Insert not at head of the class.  */\n \t  /* Put it after the last element cheaper than X.  */\n-\t  register struct table_elt *p, *next;\n+\t  struct table_elt *p, *next;\n \n \t  for (p = classp; (next = p->next_same_value) && CHEAPER (next, elt);\n \t       p = next);\n@@ -1676,7 +1676,7 @@ insert (x, classp, hash, mode)\n \t   && ! qty_table[REG_QTY (REGNO (x))].const_rtx\n \t   && ! elt->is_const)\n     {\n-      register struct table_elt *p;\n+      struct table_elt *p;\n \n       for (p = classp; p != 0; p = p->next_same_value)\n \t{\n@@ -1842,8 +1842,8 @@ invalidate (x, full_mode)\n      rtx x;\n      enum machine_mode full_mode;\n {\n-  register int i;\n-  register struct table_elt *p;\n+  int i;\n+  struct table_elt *p;\n \n   switch (GET_CODE (x))\n     {\n@@ -1884,7 +1884,7 @@ invalidate (x, full_mode)\n \t    unsigned int endregno\n \t      = regno + HARD_REGNO_NREGS (regno, GET_MODE (x));\n \t    unsigned int tregno, tendregno, rn;\n-\t    register struct table_elt *p, *next;\n+\t    struct table_elt *p, *next;\n \n \t    CLEAR_HARD_REG_BIT (hard_regs_in_table, regno);\n \n@@ -1943,7 +1943,7 @@ invalidate (x, full_mode)\n \n       for (i = 0; i < HASH_SIZE; i++)\n \t{\n-\t  register struct table_elt *next;\n+\t  struct table_elt *next;\n \n \t  for (p = table[i]; p; p = next)\n \t    {\n@@ -2141,8 +2141,8 @@ use_related_value (x, elt)\n      rtx x;\n      struct table_elt *elt;\n {\n-  register struct table_elt *relt = 0;\n-  register struct table_elt *p, *q;\n+  struct table_elt *relt = 0;\n+  struct table_elt *p, *q;\n   HOST_WIDE_INT offset;\n \n   /* First, is there anything related known?\n@@ -2238,10 +2238,10 @@ canon_hash (x, mode)\n      rtx x;\n      enum machine_mode mode;\n {\n-  register int i, j;\n-  register unsigned hash = 0;\n-  register enum rtx_code code;\n-  register const char *fmt;\n+  int i, j;\n+  unsigned hash = 0;\n+  enum rtx_code code;\n+  const char *fmt;\n \n   /* repeat is used to turn tail-recursion into iteration.  */\n  repeat:\n@@ -2449,7 +2449,7 @@ canon_hash (x, mode)\n \thash += canon_hash_string (XSTR (x, i));\n       else if (fmt[i] == 'i')\n \t{\n-\t  register unsigned tem = XINT (x, i);\n+\t  unsigned tem = XINT (x, i);\n \t  hash += tem;\n \t}\n       else if (fmt[i] == '0' || fmt[i] == 't')\n@@ -2497,9 +2497,9 @@ exp_equiv_p (x, y, validate, equal_values)\n      int validate;\n      int equal_values;\n {\n-  register int i, j;\n-  register enum rtx_code code;\n-  register const char *fmt;\n+  int i, j;\n+  enum rtx_code code;\n+  const char *fmt;\n \n   /* Note: it is incorrect to assume an expression is equivalent to itself\n      if VALIDATE is nonzero.  */\n@@ -2688,7 +2688,7 @@ exp_equiv_p (x, y, validate, equal_values)\n \n static int\n cse_rtx_varies_p (x, from_alias)\n-     register rtx x;\n+     rtx x;\n      int from_alias;\n {\n   /* We need not check for X and the equivalence class being of the same\n@@ -2761,9 +2761,9 @@ canon_reg (x, insn)\n      rtx x;\n      rtx insn;\n {\n-  register int i;\n-  register enum rtx_code code;\n-  register const char *fmt;\n+  int i;\n+  enum rtx_code code;\n+  const char *fmt;\n \n   if (x == 0)\n     return x;\n@@ -2784,9 +2784,9 @@ canon_reg (x, insn)\n \n     case REG:\n       {\n-\tregister int first;\n-\tregister int q;\n-\tregister struct qty_table_elem *ent;\n+\tint first;\n+\tint q;\n+\tstruct qty_table_elem *ent;\n \n \t/* Never replace a hard reg, because hard regs can appear\n \t   in more than one machine mode, and we must preserve the mode\n@@ -2812,7 +2812,7 @@ canon_reg (x, insn)\n   fmt = GET_RTX_FORMAT (code);\n   for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n     {\n-      register int j;\n+      int j;\n \n       if (fmt[i] == 'e')\n \t{\n@@ -3285,10 +3285,10 @@ fold_rtx (x, insn)\n      rtx x;\n      rtx insn;\n {\n-  register enum rtx_code code;\n-  register enum machine_mode mode;\n-  register const char *fmt;\n-  register int i;\n+  enum rtx_code code;\n+  enum machine_mode mode;\n+  const char *fmt;\n+  int i;\n   rtx new = 0;\n   int copied = 0;\n   int must_swap = 0;\n@@ -3845,7 +3845,7 @@ fold_rtx (x, insn)\n \t      \t\t    || (GET_CODE (const_arg0) == CONST_INT\n \t\t\t        && GET_CODE (const_arg1) != CONST_INT))))\n \t{\n-\t  register rtx tem = XEXP (x, 0);\n+\t  rtx tem = XEXP (x, 0);\n \n \t  if (insn == 0 && ! copied)\n \t    {\n@@ -4363,7 +4363,7 @@ equiv_constant (x)\n rtx\n gen_lowpart_if_possible (mode, x)\n      enum machine_mode mode;\n-     register rtx x;\n+     rtx x;\n {\n   rtx result = gen_lowpart_common (mode, x);\n \n@@ -4372,7 +4372,7 @@ gen_lowpart_if_possible (mode, x)\n   else if (GET_CODE (x) == MEM)\n     {\n       /* This is the only other case we handle.  */\n-      register int offset = 0;\n+      int offset = 0;\n       rtx new;\n \n       if (WORDS_BIG_ENDIAN)\n@@ -4716,10 +4716,10 @@ cse_insn (insn, libcall_insn)\n      rtx insn;\n      rtx libcall_insn;\n {\n-  register rtx x = PATTERN (insn);\n-  register int i;\n+  rtx x = PATTERN (insn);\n+  int i;\n   rtx tem;\n-  register int n_sets = 0;\n+  int n_sets = 0;\n \n #ifdef HAVE_cc0\n   /* Records what this insn does to set CC0.  */\n@@ -4787,7 +4787,7 @@ cse_insn (insn, libcall_insn)\n     }\n   else if (GET_CODE (x) == PARALLEL)\n     {\n-      register int lim = XVECLEN (x, 0);\n+      int lim = XVECLEN (x, 0);\n \n       sets = (struct set *) alloca (lim * sizeof (struct set));\n \n@@ -4804,7 +4804,7 @@ cse_insn (insn, libcall_insn)\n \t anything in that case.  */\n       for (i = 0; i < lim; i++)\n \t{\n-\t  register rtx y = XVECEXP (x, 0, i);\n+\t  rtx y = XVECEXP (x, 0, i);\n \t  if (GET_CODE (y) == CLOBBER)\n \t    {\n \t      rtx clobbered = XEXP (y, 0);\n@@ -4820,7 +4820,7 @@ cse_insn (insn, libcall_insn)\n \n       for (i = 0; i < lim; i++)\n \t{\n-\t  register rtx y = XVECEXP (x, 0, i);\n+\t  rtx y = XVECEXP (x, 0, i);\n \t  if (GET_CODE (y) == SET)\n \t    {\n \t      /* As above, we ignore unconditional jumps and call-insns and\n@@ -4952,9 +4952,9 @@ cse_insn (insn, libcall_insn)\n \n   for (i = 0; i < n_sets; i++)\n     {\n-      register rtx src, dest;\n-      register rtx src_folded;\n-      register struct table_elt *elt = 0, *p;\n+      rtx src, dest;\n+      rtx src_folded;\n+      struct table_elt *elt = 0, *p;\n       enum machine_mode mode;\n       rtx src_eqv_here;\n       rtx src_const = 0;\n@@ -5853,8 +5853,8 @@ cse_insn (insn, libcall_insn)\n   if (src_eqv && src_eqv_elt == 0 && sets[0].rtl != 0 && ! src_eqv_volatile\n       && ! rtx_equal_p (src_eqv, SET_DEST (sets[0].rtl)))\n     {\n-      register struct table_elt *elt;\n-      register struct table_elt *classp = sets[0].src_elt;\n+      struct table_elt *elt;\n+      struct table_elt *classp = sets[0].src_elt;\n       rtx dest = SET_DEST (sets[0].rtl);\n       enum machine_mode eqvmode = GET_MODE (dest);\n \n@@ -5899,9 +5899,9 @@ cse_insn (insn, libcall_insn)\n \t  {\n \t    /* Insert source and constant equivalent into hash table, if not\n \t       already present.  */\n-\t    register struct table_elt *classp = src_eqv_elt;\n-\t    register rtx src = sets[i].src;\n-\t    register rtx dest = SET_DEST (sets[i].rtl);\n+\t    struct table_elt *classp = src_eqv_elt;\n+\t    rtx src = sets[i].src;\n+\t    rtx dest = SET_DEST (sets[i].rtl);\n \t    enum machine_mode mode\n \t      = GET_MODE (src) == VOIDmode ? GET_MODE (dest) : GET_MODE (src);\n \n@@ -5914,7 +5914,7 @@ cse_insn (insn, libcall_insn)\n \t\t    || REGNO (src) >= FIRST_PSEUDO_REGISTER\n \t\t    || ! find_reg_note (insn, REG_RETVAL, NULL_RTX))\n \t\t  {\n-\t\t    register struct table_elt *elt;\n+\t\t    struct table_elt *elt;\n \n \t\t    /* Note that these insert_regs calls cannot remove\n \t\t       any of the src_elt's, because they would have failed to\n@@ -5966,7 +5966,7 @@ cse_insn (insn, libcall_insn)\n       {\n \t/* We can't use the inner dest, because the mode associated with\n \t   a ZERO_EXTRACT is significant.  */\n-\tregister rtx dest = SET_DEST (sets[i].rtl);\n+\trtx dest = SET_DEST (sets[i].rtl);\n \n \t/* Needed for registers to remove the register from its\n \t   previous quantity's chain.\n@@ -6050,7 +6050,7 @@ cse_insn (insn, libcall_insn)\n \t  /* If elt was removed, find current head of same class,\n \t     or 0 if nothing remains of that class.  */\n \t  {\n-\t    register struct table_elt *elt = sets[i].src_elt;\n+\t    struct table_elt *elt = sets[i].src_elt;\n \n \t    while (elt && elt->prev_same_value)\n \t      elt = elt->prev_same_value;\n@@ -6066,9 +6066,9 @@ cse_insn (insn, libcall_insn)\n   for (i = 0; i < n_sets; i++)\n     if (sets[i].rtl)\n       {\n-\tregister rtx dest = SET_DEST (sets[i].rtl);\n+\trtx dest = SET_DEST (sets[i].rtl);\n \trtx inner_dest = sets[i].inner_dest;\n-\tregister struct table_elt *elt;\n+\tstruct table_elt *elt;\n \n \t/* Don't record value if we are not supposed to risk allocating\n \t   floating-point values in registers that might be wider than\n@@ -6320,8 +6320,8 @@ cse_insn (insn, libcall_insn)\n static void\n invalidate_memory ()\n {\n-  register int i;\n-  register struct table_elt *p, *next;\n+  int i;\n+  struct table_elt *p, *next;\n \n   for (i = 0; i < HASH_SIZE; i++)\n     for (p = table[i]; p; p = next)\n@@ -6337,7 +6337,7 @@ invalidate_memory ()\n \n static int\n addr_affects_sp_p (addr)\n-     register rtx addr;\n+     rtx addr;\n {\n   if (GET_RTX_CLASS (GET_CODE (addr)) == 'a'\n       && GET_CODE (XEXP (addr, 0)) == REG\n@@ -6382,10 +6382,10 @@ invalidate_from_clobbers (x)\n     }\n   else if (GET_CODE (x) == PARALLEL)\n     {\n-      register int i;\n+      int i;\n       for (i = XVECLEN (x, 0) - 1; i >= 0; i--)\n \t{\n-\t  register rtx y = XVECEXP (x, 0, i);\n+\t  rtx y = XVECEXP (x, 0, i);\n \t  if (GET_CODE (y) == CLOBBER)\n \t    {\n \t      rtx ref = XEXP (y, 0);\n@@ -6938,7 +6938,7 @@ cse_end_of_basic_block (insn, data, follow_jumps, after_loop, skip_blocks)\n \t  /* Detect a branch around a block of code.  */\n \t  else if (skip_blocks && q != 0 && GET_CODE (q) != CODE_LABEL)\n \t    {\n-\t      register rtx tmp;\n+\t      rtx tmp;\n \n \t      if (next_real_insn (q) == next)\n \t\t{\n@@ -7013,8 +7013,8 @@ cse_main (f, nregs, after_loop, file)\n      FILE *file;\n {\n   struct cse_basic_block_data val;\n-  register rtx insn = f;\n-  register int i;\n+  rtx insn = f;\n+  int i;\n \n   cse_jumps_altered = 0;\n   recorded_label_ref = 0;\n@@ -7153,11 +7153,11 @@ cse_main (f, nregs, after_loop, file)\n \n static rtx\n cse_basic_block (from, to, next_branch, around_loop)\n-     register rtx from, to;\n+     rtx from, to;\n      struct branch_path *next_branch;\n      int around_loop;\n {\n-  register rtx insn;\n+  rtx insn;\n   int to_usage = 0;\n   rtx libcall_insn = NULL_RTX;\n   int num_insns = 0;\n@@ -7178,7 +7178,7 @@ cse_basic_block (from, to, next_branch, around_loop)\n \n   for (insn = from; insn != to; insn = NEXT_INSN (insn))\n     {\n-      register enum rtx_code code = GET_CODE (insn);\n+      enum rtx_code code = GET_CODE (insn);\n \n       /* If we have processed 1,000 insns, flush the hash table to\n \t avoid extreme quadratic behavior.  We must not include NOTEs"}, {"sha": "f280bc834970e7a2dbf1c47eda9ecb88bc69b64a", "filename": "gcc/dbxout.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Fdbxout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Fdbxout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbxout.c?ref=b36948478c22c58018d0a888ee8ca393dea60dc9", "patch": "@@ -855,15 +855,15 @@ dbxout_type_method_1 (decl, debug_name)\n \n static void\n dbxout_type_methods (type)\n-     register tree type;\n+     tree type;\n {\n   /* C++: put out the method names and their parameter lists */\n   tree methods = TYPE_METHODS (type);\n   tree type_encoding;\n-  register tree fndecl;\n-  register tree last;\n+  tree fndecl;\n+  tree last;\n   char formatted_type_identifier_length[16];\n-  register int type_identifier_length;\n+  int type_identifier_length;\n \n   if (methods == NULL_TREE)\n     return;\n@@ -1032,7 +1032,7 @@ dbxout_type (type, full)\n      tree type;\n      int full;\n {\n-  register tree tem;\n+  tree tem;\n   static int anonymous_type_number = 0;\n \n   if (TREE_CODE (type) == VECTOR_TYPE)\n@@ -1759,7 +1759,7 @@ print_wide_int (c)\n \n static void\n dbxout_type_name (type)\n-     register tree type;\n+     tree type;\n {\n   tree t;\n   if (TYPE_NAME (type) == 0)\n@@ -2712,7 +2712,7 @@ dbxout_args (args)\n \n static void\n dbxout_block (block, depth, args)\n-     register tree block;\n+     tree block;\n      int depth;\n      tree args;\n {"}, {"sha": "bda763fe1b1b5ebd79c33853da88d0e8b16a2990", "filename": "gcc/defaults.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Fdefaults.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Fdefaults.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdefaults.h?ref=b36948478c22c58018d0a888ee8ca393dea60dc9", "patch": "@@ -91,7 +91,7 @@ do { ASM_OUTPUT_LABEL(FILE,LABEL_ALTERNATE_NAME (INSN)); } while (0)\n \t\t\t\t\t\t\t\t\t      \\\n       for (i = 0; i < thissize; i++)\t\t\t\t\t      \\\n \t{\t\t\t\t\t\t\t\t      \\\n-\t  register int c = p[i];\t\t\t\t\t      \\\n+\t  int c = p[i];\t\t\t   \t\t\t\t      \\\n \t  if (c == '\\\"' || c == '\\\\')\t\t\t\t\t      \\\n \t    putc ('\\\\', asm_out_file);\t\t\t\t\t      \\\n \t  if (ISPRINT(c))\t\t\t\t\t\t      \\"}, {"sha": "75148733e599204d8e9652a2780117cf2a449070", "filename": "gcc/df.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Fdf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Fdf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf.c?ref=b36948478c22c58018d0a888ee8ca393dea60dc9", "patch": "@@ -1186,7 +1186,7 @@ df_uses_record (df, loc, ref_type, bb, insn)\n \n   /* Recursively scan the operands of this expression.  */\n   {\n-    register const char *fmt = GET_RTX_FORMAT (code);\n+    const char *fmt = GET_RTX_FORMAT (code);\n     int i;\n     \n     for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)"}, {"sha": "e8a5f18f0d0d8d91023ec10ca337b258eedae60a", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 494, "deletions": 495, "changes": 989, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=b36948478c22c58018d0a888ee8ca393dea60dc9", "patch": "@@ -397,7 +397,7 @@ expand_builtin_init_dwarf_reg_sizes (address)\n \n static const char *\n dwarf_cfi_name (cfi_opc)\n-     register unsigned cfi_opc;\n+     unsigned cfi_opc;\n {\n   switch (cfi_opc)\n     {\n@@ -462,7 +462,7 @@ dwarf_cfi_name (cfi_opc)\n static inline dw_cfi_ref\n new_cfi ()\n {\n-  register dw_cfi_ref cfi = (dw_cfi_ref) xmalloc (sizeof (dw_cfi_node));\n+  dw_cfi_ref cfi = (dw_cfi_ref) xmalloc (sizeof (dw_cfi_node));\n \n   cfi->dw_cfi_next = NULL;\n   cfi->dw_cfi_oprnd1.dw_cfi_reg_num = 0;\n@@ -475,10 +475,10 @@ new_cfi ()\n \n static inline void\n add_cfi (list_head, cfi)\n-     register dw_cfi_ref *list_head;\n-     register dw_cfi_ref cfi;\n+     dw_cfi_ref *list_head;\n+     dw_cfi_ref cfi;\n {\n-  register dw_cfi_ref *p;\n+  dw_cfi_ref *p;\n \n   /* Find the end of the chain.  */\n   for (p = list_head; (*p) != NULL; p = &(*p)->dw_cfi_next)\n@@ -506,20 +506,20 @@ dwarf2out_cfi_label ()\n \n static void\n add_fde_cfi (label, cfi)\n-     register const char *label;\n-     register dw_cfi_ref cfi;\n+     const char *label;\n+     dw_cfi_ref cfi;\n {\n   if (label)\n     {\n-      register dw_fde_ref fde = &fde_table[fde_table_in_use - 1];\n+      dw_fde_ref fde = &fde_table[fde_table_in_use - 1];\n \n       if (*label == 0)\n \tlabel = dwarf2out_cfi_label ();\n \n       if (fde->dw_fde_current_label == NULL\n \t  || strcmp (label, fde->dw_fde_current_label) != 0)\n \t{\n-\t  register dw_cfi_ref xcfi;\n+\t  dw_cfi_ref xcfi;\n \n \t  fde->dw_fde_current_label = label = xstrdup (label);\n \n@@ -541,8 +541,8 @@ add_fde_cfi (label, cfi)\n \n static inline void\n lookup_cfa_1 (cfi, loc)\n-     register dw_cfi_ref cfi;\n-     register dw_cfa_location *loc;\n+     dw_cfi_ref cfi;\n+     dw_cfa_location *loc;\n {\n   switch (cfi->dw_cfi_opc)\n     {\n@@ -568,9 +568,9 @@ lookup_cfa_1 (cfi, loc)\n \n static void\n lookup_cfa (loc)\n-     register dw_cfa_location *loc;\n+     dw_cfa_location *loc;\n {\n-  register dw_cfi_ref cfi;\n+  dw_cfi_ref cfi;\n \n   loc->reg = (unsigned long) -1;\n   loc->offset = 0;\n@@ -582,7 +582,7 @@ lookup_cfa (loc)\n \n   if (fde_table_in_use)\n     {\n-      register dw_fde_ref fde = &fde_table[fde_table_in_use - 1];\n+      dw_fde_ref fde = &fde_table[fde_table_in_use - 1];\n       for (cfi = fde->dw_fde_cfi; cfi; cfi = cfi->dw_cfi_next)\n \tlookup_cfa_1 (cfi, loc);\n     }\n@@ -607,7 +607,7 @@ static long old_args_size;\n \n void\n dwarf2out_def_cfa (label, reg, offset)\n-     register const char *label;\n+     const char *label;\n      unsigned reg;\n      long offset;\n {\n@@ -623,10 +623,10 @@ dwarf2out_def_cfa (label, reg, offset)\n    the dw_cfa_location structure.  */\n static void\n def_cfa_1 (label, loc_p)\n-     register const char *label;\n+     const char *label;\n      dw_cfa_location *loc_p;\n {\n-  register dw_cfi_ref cfi;\n+  dw_cfi_ref cfi;\n   dw_cfa_location old_cfa, loc;\n \n   cfa = *loc_p;\n@@ -701,12 +701,12 @@ def_cfa_1 (label, loc_p)\n \n static void\n reg_save (label, reg, sreg, offset)\n-     register const char *label;\n-     register unsigned reg;\n-     register unsigned sreg;\n-     register long offset;\n+     const char *label;\n+     unsigned reg;\n+     unsigned sreg;\n+     long offset;\n {\n-  register dw_cfi_ref cfi = new_cfi ();\n+  dw_cfi_ref cfi = new_cfi ();\n \n   cfi->dw_cfi_oprnd1.dw_cfi_reg_num = reg;\n \n@@ -762,9 +762,9 @@ reg_save (label, reg, sreg, offset)\n \n void\n dwarf2out_window_save (label)\n-     register const char *label;\n+     const char *label;\n {\n-  register dw_cfi_ref cfi = new_cfi ();\n+  dw_cfi_ref cfi = new_cfi ();\n   cfi->dw_cfi_opc = DW_CFA_GNU_window_save;\n   add_fde_cfi (label, cfi);\n }\n@@ -777,7 +777,7 @@ dwarf2out_args_size (label, size)\n      const char *label;\n      long size;\n {\n-  register dw_cfi_ref cfi;\n+  dw_cfi_ref cfi;\n \n   if (size == old_args_size)\n     return;\n@@ -794,9 +794,9 @@ dwarf2out_args_size (label, size)\n \n void\n dwarf2out_reg_save (label, reg, offset)\n-     register const char *label;\n-     register unsigned reg;\n-     register long offset;\n+     const char *label;\n+     unsigned reg;\n+     long offset;\n {\n   reg_save (label, DWARF_FRAME_REGNUM (reg), -1, offset);\n }\n@@ -806,8 +806,8 @@ dwarf2out_reg_save (label, reg, offset)\n \n void\n dwarf2out_return_save (label, offset)\n-     register const char *label;\n-     register long offset;\n+     const char *label;\n+     long offset;\n {\n   reg_save (label, DWARF_FRAME_RETURN_COLUMN, -1, offset);\n }\n@@ -817,8 +817,8 @@ dwarf2out_return_save (label, offset)\n \n void\n dwarf2out_return_reg (label, sreg)\n-     register const char *label;\n-     register unsigned sreg;\n+     const char *label;\n+     unsigned sreg;\n {\n   reg_save (label, DWARF_FRAME_RETURN_COLUMN, sreg, 0);\n }\n@@ -828,7 +828,7 @@ dwarf2out_return_reg (label, sreg)\n \n static void\n initial_return_save (rtl)\n-     register rtx rtl;\n+     rtx rtl;\n {\n   unsigned int reg = (unsigned int) -1;\n   long offset = 0;\n@@ -1604,8 +1604,8 @@ dwarf2out_frame_debug (insn)\n \n static void\n output_cfi (cfi, fde, for_eh)\n-     register dw_cfi_ref cfi;\n-     register dw_fde_ref fde;\n+     dw_cfi_ref cfi;\n+     dw_fde_ref fde;\n      int for_eh;\n {\n   if (cfi->dw_cfi_opc == DW_CFA_advance_loc)\n@@ -1706,9 +1706,9 @@ static void\n output_call_frame_info (for_eh)\n      int for_eh;\n {\n-  register unsigned int i;\n-  register dw_fde_ref fde;\n-  register dw_cfi_ref cfi;\n+  unsigned int i;\n+  dw_fde_ref fde;\n+  dw_cfi_ref cfi;\n   char l1[20], l2[20], section_start_label[20];\n   int any_lsda_needed = 0;\n   char augmentation[6];\n@@ -1986,7 +1986,7 @@ dwarf2out_begin_prologue (line, file)\n      const char *file ATTRIBUTE_UNUSED;\n {\n   char label[MAX_ARTIFICIAL_LABEL_BYTES];\n-  register dw_fde_ref fde;\n+  dw_fde_ref fde;\n \n   current_function_func_begin_label = 0;\n \n@@ -2215,7 +2215,7 @@ static void output_loc_sequence\t\tPARAMS ((dw_loc_descr_ref));\n \n static const char *\n dwarf_stack_op_name (op)\n-     register unsigned op;\n+     unsigned op;\n {\n   switch (op)\n     {\n@@ -2520,13 +2520,13 @@ dwarf_stack_op_name (op)\n \n static inline dw_loc_descr_ref\n new_loc_descr (op, oprnd1, oprnd2)\n-     register enum dwarf_location_atom op;\n-     register unsigned long oprnd1;\n-     register unsigned long oprnd2;\n+     enum dwarf_location_atom op;\n+     unsigned long oprnd1;\n+     unsigned long oprnd2;\n {\n   /* Use xcalloc here so we clear out all of the long_long constant in\n      the union.  */\n-  register dw_loc_descr_ref descr\n+  dw_loc_descr_ref descr\n     = (dw_loc_descr_ref) xcalloc (1, sizeof (dw_loc_descr_node));\n \n   descr->dw_loc_opc = op;\n@@ -2543,10 +2543,10 @@ new_loc_descr (op, oprnd1, oprnd2)\n \n static inline void\n add_loc_descr (list_head, descr)\n-     register dw_loc_descr_ref *list_head;\n-     register dw_loc_descr_ref descr;\n+     dw_loc_descr_ref *list_head;\n+     dw_loc_descr_ref descr;\n {\n-  register dw_loc_descr_ref *d;\n+  dw_loc_descr_ref *d;\n \n   /* Find the end of the chain.  */\n   for (d = list_head; (*d) != NULL; d = &(*d)->dw_loc_next)\n@@ -2559,9 +2559,9 @@ add_loc_descr (list_head, descr)\n \n static unsigned long\n size_of_loc_descr (loc)\n-     register dw_loc_descr_ref loc;\n+     dw_loc_descr_ref loc;\n {\n-  register unsigned long size = 1;\n+  unsigned long size = 1;\n \n   switch (loc->dw_loc_opc)\n     {\n@@ -2662,9 +2662,9 @@ size_of_loc_descr (loc)\n \n static unsigned long\n size_of_locs (loc)\n-     register dw_loc_descr_ref loc;\n+     dw_loc_descr_ref loc;\n {\n-  register unsigned long size = 0;\n+  unsigned long size = 0;\n \n   for (; loc != NULL; loc = loc->dw_loc_next)\n     {\n@@ -2679,10 +2679,10 @@ size_of_locs (loc)\n \n static void\n output_loc_operands (loc)\n-     register dw_loc_descr_ref loc;\n+     dw_loc_descr_ref loc;\n {\n-  register dw_val_ref val1 = &loc->dw_loc_oprnd1;\n-  register dw_val_ref val2 = &loc->dw_loc_oprnd2;\n+  dw_val_ref val1 = &loc->dw_loc_oprnd1;\n+  dw_val_ref val2 = &loc->dw_loc_oprnd2;\n \n   switch (loc->dw_loc_opc)\n     {\n@@ -3700,7 +3700,7 @@ dwarf2out_set_demangle_name_func (func)\n \n static rtx\n save_rtx (orig)\n-     register rtx orig;\n+     rtx orig;\n {\n   VARRAY_PUSH_RTX (used_rtx_varray, orig);\n \n@@ -3711,7 +3711,7 @@ save_rtx (orig)\n \n static inline int\n is_pseudo_reg (rtl)\n-     register rtx rtl;\n+     rtx rtl;\n {\n   return ((GET_CODE (rtl) == REG && REGNO (rtl) >= FIRST_PSEUDO_REGISTER)\n \t  || (GET_CODE (rtl) == SUBREG\n@@ -3723,7 +3723,7 @@ is_pseudo_reg (rtl)\n \n static inline tree\n type_main_variant (type)\n-     register tree type;\n+     tree type;\n {\n   type = TYPE_MAIN_VARIANT (type);\n \n@@ -3743,9 +3743,9 @@ type_main_variant (type)\n \n static inline int\n is_tagged_type (type)\n-     register tree type;\n+     tree type;\n {\n-  register enum tree_code code = TREE_CODE (type);\n+  enum tree_code code = TREE_CODE (type);\n \n   return (code == RECORD_TYPE || code == UNION_TYPE\n \t  || code == QUAL_UNION_TYPE || code == ENUMERAL_TYPE);\n@@ -3755,7 +3755,7 @@ is_tagged_type (type)\n \n static const char *\n dwarf_tag_name (tag)\n-     register unsigned tag;\n+     unsigned tag;\n {\n   switch (tag)\n     {\n@@ -3876,7 +3876,7 @@ dwarf_tag_name (tag)\n \n static const char *\n dwarf_attr_name (attr)\n-     register unsigned attr;\n+     unsigned attr;\n {\n   switch (attr)\n     {\n@@ -4074,7 +4074,7 @@ dwarf_attr_name (attr)\n \n static const char *\n dwarf_form_name (form)\n-     register unsigned form;\n+     unsigned form;\n {\n   switch (form)\n     {\n@@ -4130,7 +4130,7 @@ dwarf_form_name (form)\n #if 0\n static const char *\n dwarf_type_encoding_name (enc)\n-     register unsigned enc;\n+     unsigned enc;\n {\n   switch (enc)\n     {\n@@ -4164,7 +4164,7 @@ dwarf_type_encoding_name (enc)\n \n static tree\n decl_ultimate_origin (decl)\n-     register tree decl;\n+     tree decl;\n {\n   /* output_inline_function sets DECL_ABSTRACT_ORIGIN for all the\n      nodes in the function to point to themselves; ignore that if\n@@ -4190,9 +4190,9 @@ decl_ultimate_origin (decl)\n \n static tree\n block_ultimate_origin (block)\n-     register tree block;\n+     tree block;\n {\n-  register tree immediate_origin = BLOCK_ABSTRACT_ORIGIN (block);\n+  tree immediate_origin = BLOCK_ABSTRACT_ORIGIN (block);\n \n   /* output_inline_function sets BLOCK_ABSTRACT_ORIGIN for all the\n      nodes in the function to point to themselves; ignore that if\n@@ -4204,8 +4204,8 @@ block_ultimate_origin (block)\n     return NULL_TREE;\n   else\n     {\n-      register tree ret_val;\n-      register tree lookahead = immediate_origin;\n+      tree ret_val;\n+      tree lookahead = immediate_origin;\n \n       do\n \t{\n@@ -4247,8 +4247,8 @@ decl_class_context (decl)\n \n static inline void\n add_dwarf_attr (die, attr)\n-     register dw_die_ref die;\n-     register dw_attr_ref attr;\n+     dw_die_ref die;\n+     dw_attr_ref attr;\n {\n   if (die != NULL && attr != NULL)\n     {\n@@ -4269,11 +4269,11 @@ AT_class (a)\n \n static inline void\n add_AT_flag (die, attr_kind, flag)\n-     register dw_die_ref die;\n-     register enum dwarf_attribute attr_kind;\n-     register unsigned flag;\n+     dw_die_ref die;\n+     enum dwarf_attribute attr_kind;\n+     unsigned flag;\n {\n-  register dw_attr_ref attr = (dw_attr_ref) xmalloc (sizeof (dw_attr_node));\n+  dw_attr_ref attr = (dw_attr_ref) xmalloc (sizeof (dw_attr_node));\n \n   attr->dw_attr_next = NULL;\n   attr->dw_attr = attr_kind;\n@@ -4285,7 +4285,7 @@ add_AT_flag (die, attr_kind, flag)\n static inline unsigned AT_flag PARAMS ((dw_attr_ref));\n static inline unsigned\n AT_flag (a)\n-     register dw_attr_ref a;\n+     dw_attr_ref a;\n {\n   if (a && AT_class (a) == dw_val_class_flag)\n     return a->dw_attr_val.v.val_flag;\n@@ -4297,11 +4297,11 @@ AT_flag (a)\n \n static inline void\n add_AT_int (die, attr_kind, int_val)\n-     register dw_die_ref die;\n-     register enum dwarf_attribute attr_kind;\n-     register long int int_val;\n+     dw_die_ref die;\n+     enum dwarf_attribute attr_kind;\n+     long int int_val;\n {\n-  register dw_attr_ref attr = (dw_attr_ref) xmalloc (sizeof (dw_attr_node));\n+  dw_attr_ref attr = (dw_attr_ref) xmalloc (sizeof (dw_attr_node));\n \n   attr->dw_attr_next = NULL;\n   attr->dw_attr = attr_kind;\n@@ -4313,7 +4313,7 @@ add_AT_int (die, attr_kind, int_val)\n static inline long int AT_int PARAMS ((dw_attr_ref));\n static inline long int\n AT_int (a)\n-     register dw_attr_ref a;\n+     dw_attr_ref a;\n {\n   if (a && AT_class (a) == dw_val_class_const)\n     return a->dw_attr_val.v.val_int;\n@@ -4325,11 +4325,11 @@ AT_int (a)\n \n static inline void\n add_AT_unsigned (die, attr_kind, unsigned_val)\n-     register dw_die_ref die;\n-     register enum dwarf_attribute attr_kind;\n-     register unsigned long unsigned_val;\n+     dw_die_ref die;\n+     enum dwarf_attribute attr_kind;\n+     unsigned long unsigned_val;\n {\n-  register dw_attr_ref attr = (dw_attr_ref) xmalloc (sizeof (dw_attr_node));\n+  dw_attr_ref attr = (dw_attr_ref) xmalloc (sizeof (dw_attr_node));\n \n   attr->dw_attr_next = NULL;\n   attr->dw_attr = attr_kind;\n@@ -4341,7 +4341,7 @@ add_AT_unsigned (die, attr_kind, unsigned_val)\n static inline unsigned long AT_unsigned PARAMS ((dw_attr_ref));\n static inline unsigned long\n AT_unsigned (a)\n-     register dw_attr_ref a;\n+     dw_attr_ref a;\n {\n   if (a && AT_class (a) == dw_val_class_unsigned_const)\n     return a->dw_attr_val.v.val_unsigned;\n@@ -4353,12 +4353,12 @@ AT_unsigned (a)\n \n static inline void\n add_AT_long_long (die, attr_kind, val_hi, val_low)\n-     register dw_die_ref die;\n-     register enum dwarf_attribute attr_kind;\n-     register unsigned long val_hi;\n-     register unsigned long val_low;\n+     dw_die_ref die;\n+     enum dwarf_attribute attr_kind;\n+     unsigned long val_hi;\n+     unsigned long val_low;\n {\n-  register dw_attr_ref attr = (dw_attr_ref) xmalloc (sizeof (dw_attr_node));\n+  dw_attr_ref attr = (dw_attr_ref) xmalloc (sizeof (dw_attr_node));\n \n   attr->dw_attr_next = NULL;\n   attr->dw_attr = attr_kind;\n@@ -4372,12 +4372,12 @@ add_AT_long_long (die, attr_kind, val_hi, val_low)\n \n static inline void\n add_AT_float (die, attr_kind, length, array)\n-     register dw_die_ref die;\n-     register enum dwarf_attribute attr_kind;\n-     register unsigned length;\n-     register long *array;\n+     dw_die_ref die;\n+     enum dwarf_attribute attr_kind;\n+     unsigned length;\n+     long *array;\n {\n-  register dw_attr_ref attr = (dw_attr_ref) xmalloc (sizeof (dw_attr_node));\n+  dw_attr_ref attr = (dw_attr_ref) xmalloc (sizeof (dw_attr_node));\n \n   attr->dw_attr_next = NULL;\n   attr->dw_attr = attr_kind;\n@@ -4391,11 +4391,11 @@ add_AT_float (die, attr_kind, length, array)\n \n static inline void\n add_AT_string (die, attr_kind, str)\n-     register dw_die_ref die;\n-     register enum dwarf_attribute attr_kind;\n-     register const char *str;\n+     dw_die_ref die;\n+     enum dwarf_attribute attr_kind;\n+     const char *str;\n {\n-  register dw_attr_ref attr = (dw_attr_ref) xmalloc (sizeof (dw_attr_node));\n+  dw_attr_ref attr = (dw_attr_ref) xmalloc (sizeof (dw_attr_node));\n \n   attr->dw_attr_next = NULL;\n   attr->dw_attr = attr_kind;\n@@ -4407,7 +4407,7 @@ add_AT_string (die, attr_kind, str)\n static inline const char *AT_string PARAMS ((dw_attr_ref));\n static inline const char *\n AT_string (a)\n-     register dw_attr_ref a;\n+     dw_attr_ref a;\n {\n   if (a && AT_class (a) == dw_val_class_str)\n     return a->dw_attr_val.v.val_str;\n@@ -4419,11 +4419,11 @@ AT_string (a)\n \n static inline void\n add_AT_die_ref (die, attr_kind, targ_die)\n-     register dw_die_ref die;\n-     register enum dwarf_attribute attr_kind;\n-     register dw_die_ref targ_die;\n+     dw_die_ref die;\n+     enum dwarf_attribute attr_kind;\n+     dw_die_ref targ_die;\n {\n-  register dw_attr_ref attr = (dw_attr_ref) xmalloc (sizeof (dw_attr_node));\n+  dw_attr_ref attr = (dw_attr_ref) xmalloc (sizeof (dw_attr_node));\n \n   attr->dw_attr_next = NULL;\n   attr->dw_attr = attr_kind;\n@@ -4436,7 +4436,7 @@ add_AT_die_ref (die, attr_kind, targ_die)\n static inline dw_die_ref AT_ref PARAMS ((dw_attr_ref));\n static inline dw_die_ref\n AT_ref (a)\n-     register dw_attr_ref a;\n+     dw_attr_ref a;\n {\n   if (a && AT_class (a) == dw_val_class_die_ref)\n     return a->dw_attr_val.v.val_die_ref.die;\n@@ -4447,7 +4447,7 @@ AT_ref (a)\n static inline int AT_ref_external PARAMS ((dw_attr_ref));\n static inline int\n AT_ref_external (a)\n-     register dw_attr_ref a;\n+     dw_attr_ref a;\n {\n   if (a && AT_class (a) == dw_val_class_die_ref)\n     return a->dw_attr_val.v.val_die_ref.external;\n@@ -4458,7 +4458,7 @@ AT_ref_external (a)\n static inline void set_AT_ref_external PARAMS ((dw_attr_ref, int));\n static inline void\n set_AT_ref_external (a, i)\n-     register dw_attr_ref a;\n+     dw_attr_ref a;\n      int i;\n {\n   if (a && AT_class (a) == dw_val_class_die_ref)\n@@ -4471,11 +4471,11 @@ set_AT_ref_external (a, i)\n \n static inline void\n add_AT_fde_ref (die, attr_kind, targ_fde)\n-     register dw_die_ref die;\n-     register enum dwarf_attribute attr_kind;\n-     register unsigned targ_fde;\n+     dw_die_ref die;\n+     enum dwarf_attribute attr_kind;\n+     unsigned targ_fde;\n {\n-  register dw_attr_ref attr = (dw_attr_ref) xmalloc (sizeof (dw_attr_node));\n+  dw_attr_ref attr = (dw_attr_ref) xmalloc (sizeof (dw_attr_node));\n \n   attr->dw_attr_next = NULL;\n   attr->dw_attr = attr_kind;\n@@ -4488,11 +4488,11 @@ add_AT_fde_ref (die, attr_kind, targ_fde)\n \n static inline void\n add_AT_loc (die, attr_kind, loc)\n-     register dw_die_ref die;\n-     register enum dwarf_attribute attr_kind;\n-     register dw_loc_descr_ref loc;\n+     dw_die_ref die;\n+     enum dwarf_attribute attr_kind;\n+     dw_loc_descr_ref loc;\n {\n-  register dw_attr_ref attr = (dw_attr_ref) xmalloc (sizeof (dw_attr_node));\n+  dw_attr_ref attr = (dw_attr_ref) xmalloc (sizeof (dw_attr_node));\n \n   attr->dw_attr_next = NULL;\n   attr->dw_attr = attr_kind;\n@@ -4504,7 +4504,7 @@ add_AT_loc (die, attr_kind, loc)\n static inline dw_loc_descr_ref AT_loc PARAMS ((dw_attr_ref));\n static inline dw_loc_descr_ref\n AT_loc (a)\n-     register dw_attr_ref a;\n+     dw_attr_ref a;\n {\n   if (a && AT_class (a) == dw_val_class_loc)\n     return a->dw_attr_val.v.val_loc;\n@@ -4514,11 +4514,11 @@ AT_loc (a)\n \n static inline void\n add_AT_loc_list (die, attr_kind, loc_list)\n-     register dw_die_ref die;\n-     register enum dwarf_attribute attr_kind;\n-     register dw_loc_list_ref loc_list;\n+     dw_die_ref die;\n+     enum dwarf_attribute attr_kind;\n+     dw_loc_list_ref loc_list;\n {\n-  register dw_attr_ref attr = (dw_attr_ref) xmalloc (sizeof (dw_attr_node));\n+  dw_attr_ref attr = (dw_attr_ref) xmalloc (sizeof (dw_attr_node));\n \n   attr->dw_attr_next = NULL;\n   attr->dw_attr = attr_kind;\n@@ -4532,7 +4532,7 @@ static inline dw_loc_list_ref AT_loc_list PARAMS ((dw_attr_ref));\n \n static inline dw_loc_list_ref\n AT_loc_list (a)\n-     register dw_attr_ref a;\n+     dw_attr_ref a;\n {\n   if (a && AT_class (a) == dw_val_class_loc_list)\n     return a->dw_attr_val.v.val_loc_list;\n@@ -4544,11 +4544,11 @@ AT_loc_list (a)\n \n static inline void\n add_AT_addr (die, attr_kind, addr)\n-     register dw_die_ref die;\n-     register enum dwarf_attribute attr_kind;\n+     dw_die_ref die;\n+     enum dwarf_attribute attr_kind;\n      rtx addr;\n {\n-  register dw_attr_ref attr = (dw_attr_ref) xmalloc (sizeof (dw_attr_node));\n+  dw_attr_ref attr = (dw_attr_ref) xmalloc (sizeof (dw_attr_node));\n \n   attr->dw_attr_next = NULL;\n   attr->dw_attr = attr_kind;\n@@ -4560,7 +4560,7 @@ add_AT_addr (die, attr_kind, addr)\n static inline rtx AT_addr PARAMS ((dw_attr_ref));\n static inline rtx\n AT_addr (a)\n-     register dw_attr_ref a;\n+     dw_attr_ref a;\n {\n   if (a && AT_class (a) == dw_val_class_addr)\n     return a->dw_attr_val.v.val_addr;\n@@ -4572,11 +4572,11 @@ AT_addr (a)\n \n static inline void\n add_AT_lbl_id (die, attr_kind, lbl_id)\n-     register dw_die_ref die;\n-     register enum dwarf_attribute attr_kind;\n-     register const char *lbl_id;\n+     dw_die_ref die;\n+     enum dwarf_attribute attr_kind;\n+     const char *lbl_id;\n {\n-  register dw_attr_ref attr = (dw_attr_ref) xmalloc (sizeof (dw_attr_node));\n+  dw_attr_ref attr = (dw_attr_ref) xmalloc (sizeof (dw_attr_node));\n \n   attr->dw_attr_next = NULL;\n   attr->dw_attr = attr_kind;\n@@ -4589,11 +4589,11 @@ add_AT_lbl_id (die, attr_kind, lbl_id)\n \n static inline void\n add_AT_lbl_offset (die, attr_kind, label)\n-     register dw_die_ref die;\n-     register enum dwarf_attribute attr_kind;\n-     register const char *label;\n+     dw_die_ref die;\n+     enum dwarf_attribute attr_kind;\n+     const char *label;\n {\n-  register dw_attr_ref attr = (dw_attr_ref) xmalloc (sizeof (dw_attr_node));\n+  dw_attr_ref attr = (dw_attr_ref) xmalloc (sizeof (dw_attr_node));\n \n   attr->dw_attr_next = NULL;\n   attr->dw_attr = attr_kind;\n@@ -4606,11 +4606,11 @@ add_AT_lbl_offset (die, attr_kind, label)\n \n static void\n add_AT_offset (die, attr_kind, offset)\n-     register dw_die_ref die;\n-     register enum dwarf_attribute attr_kind;\n-     register unsigned long offset;\n+     dw_die_ref die;\n+     enum dwarf_attribute attr_kind;\n+     unsigned long offset;\n {\n-  register dw_attr_ref attr = (dw_attr_ref) xmalloc (sizeof (dw_attr_node));\n+  dw_attr_ref attr = (dw_attr_ref) xmalloc (sizeof (dw_attr_node));\n \n   attr->dw_attr_next = NULL;\n   attr->dw_attr = attr_kind;\n@@ -4622,7 +4622,7 @@ add_AT_offset (die, attr_kind, offset)\n static inline const char *AT_lbl PARAMS ((dw_attr_ref));\n static inline const char *\n AT_lbl (a)\n-     register dw_attr_ref a;\n+     dw_attr_ref a;\n {\n   if (a && (AT_class (a) == dw_val_class_lbl_id\n \t    || AT_class (a) == dw_val_class_lbl_offset))\n@@ -4635,11 +4635,11 @@ AT_lbl (a)\n \n static inline dw_attr_ref\n get_AT (die, attr_kind)\n-     register dw_die_ref die;\n-     register enum dwarf_attribute attr_kind;\n+     dw_die_ref die;\n+     enum dwarf_attribute attr_kind;\n {\n-  register dw_attr_ref a;\n-  register dw_die_ref spec = NULL;\n+  dw_attr_ref a;\n+  dw_die_ref spec = NULL;\n \n   if (die != NULL)\n     {\n@@ -4667,9 +4667,9 @@ get_AT (die, attr_kind)\n \n static inline const char *\n get_AT_low_pc (die)\n-     register dw_die_ref die;\n+     dw_die_ref die;\n {\n-  register dw_attr_ref a = get_AT (die, DW_AT_low_pc);\n+  dw_attr_ref a = get_AT (die, DW_AT_low_pc);\n   return a ? AT_lbl (a) : NULL;\n }\n \n@@ -4680,9 +4680,9 @@ get_AT_low_pc (die)\n \n static inline const char *\n get_AT_hi_pc (die)\n-     register dw_die_ref die;\n+     dw_die_ref die;\n {\n-  register dw_attr_ref a = get_AT (die, DW_AT_high_pc);\n+  dw_attr_ref a = get_AT (die, DW_AT_high_pc);\n   return a ? AT_lbl (a) : NULL;\n }\n \n@@ -4691,10 +4691,10 @@ get_AT_hi_pc (die)\n \n static inline const char *\n get_AT_string (die, attr_kind)\n-     register dw_die_ref die;\n-     register enum dwarf_attribute attr_kind;\n+     dw_die_ref die;\n+     enum dwarf_attribute attr_kind;\n {\n-  register dw_attr_ref a = get_AT (die, attr_kind);\n+  dw_attr_ref a = get_AT (die, attr_kind);\n   return a ? AT_string (a) : NULL;\n }\n \n@@ -4703,10 +4703,10 @@ get_AT_string (die, attr_kind)\n \n static inline int\n get_AT_flag (die, attr_kind)\n-     register dw_die_ref die;\n-     register enum dwarf_attribute attr_kind;\n+     dw_die_ref die;\n+     enum dwarf_attribute attr_kind;\n {\n-  register dw_attr_ref a = get_AT (die, attr_kind);\n+  dw_attr_ref a = get_AT (die, attr_kind);\n   return a ? AT_flag (a) : 0;\n }\n \n@@ -4715,26 +4715,26 @@ get_AT_flag (die, attr_kind)\n \n static inline unsigned\n get_AT_unsigned (die, attr_kind)\n-     register dw_die_ref die;\n-     register enum dwarf_attribute attr_kind;\n+     dw_die_ref die;\n+     enum dwarf_attribute attr_kind;\n {\n-  register dw_attr_ref a = get_AT (die, attr_kind);\n+  dw_attr_ref a = get_AT (die, attr_kind);\n   return a ? AT_unsigned (a) : 0;\n }\n \n static inline dw_die_ref\n get_AT_ref (die, attr_kind)\n      dw_die_ref die;\n-     register enum dwarf_attribute attr_kind;\n+     enum dwarf_attribute attr_kind;\n {\n-  register dw_attr_ref a = get_AT (die, attr_kind);\n+  dw_attr_ref a = get_AT (die, attr_kind);\n   return a ? AT_ref (a) : NULL;\n }\n \n static inline int\n is_c_family ()\n {\n-  register unsigned lang = get_AT_unsigned (comp_unit_die, DW_AT_language);\n+  unsigned lang = get_AT_unsigned (comp_unit_die, DW_AT_language);\n \n   return (lang == DW_LANG_C || lang == DW_LANG_C89\n \t  || lang == DW_LANG_C_plus_plus);\n@@ -4743,15 +4743,15 @@ is_c_family ()\n static inline int\n is_fortran ()\n {\n-  register unsigned lang = get_AT_unsigned (comp_unit_die, DW_AT_language);\n+  unsigned lang = get_AT_unsigned (comp_unit_die, DW_AT_language);\n \n   return (lang == DW_LANG_Fortran77 || lang == DW_LANG_Fortran90);\n }\n \n static inline int\n is_java ()\n {\n-  register unsigned lang = get_AT_unsigned (comp_unit_die, DW_AT_language);\n+  unsigned lang = get_AT_unsigned (comp_unit_die, DW_AT_language);\n \n   return (lang == DW_LANG_Java);\n }\n@@ -4786,11 +4786,11 @@ free_AT (a)\n \n static void\n remove_AT (die, attr_kind)\n-     register dw_die_ref die;\n-     register enum dwarf_attribute attr_kind;\n+     dw_die_ref die;\n+     enum dwarf_attribute attr_kind;\n {\n-  register dw_attr_ref *p;\n-  register dw_attr_ref removed = NULL;\n+  dw_attr_ref *p;\n+  dw_attr_ref removed = NULL;\n \n   if (die != NULL)\n     {\n@@ -4822,22 +4822,22 @@ free_die (die)\n \n static void\n remove_children (die)\n-     register dw_die_ref die;\n+     dw_die_ref die;\n {\n-  register dw_die_ref child_die = die->die_child;\n+  dw_die_ref child_die = die->die_child;\n \n   die->die_child = NULL;\n \n   while (child_die != NULL)\n     {\n-      register dw_die_ref tmp_die = child_die;\n-      register dw_attr_ref a;\n+      dw_die_ref tmp_die = child_die;\n+      dw_attr_ref a;\n \n       child_die = child_die->die_sib;\n \n       for (a = tmp_die->die_attr; a != NULL;)\n \t{\n-\t  register dw_attr_ref tmp_a = a;\n+\t  dw_attr_ref tmp_a = a;\n \n \t  a = a->dw_attr_next;\n \t  free_AT (tmp_a);\n@@ -4852,8 +4852,8 @@ remove_children (die)\n \n static inline void\n add_child_die (die, child_die)\n-     register dw_die_ref die;\n-     register dw_die_ref child_die;\n+     dw_die_ref die;\n+     dw_die_ref child_die;\n {\n   if (die != NULL && child_die != NULL)\n     {\n@@ -4902,10 +4902,10 @@ splice_child_die (parent, child)\n \n static inline dw_die_ref\n new_die (tag_value, parent_die)\n-     register enum dwarf_tag tag_value;\n-     register dw_die_ref parent_die;\n+     enum dwarf_tag tag_value;\n+     dw_die_ref parent_die;\n {\n-  register dw_die_ref die = (dw_die_ref) xcalloc (1, sizeof (die_node));\n+  dw_die_ref die = (dw_die_ref) xcalloc (1, sizeof (die_node));\n \n   die->die_tag = tag_value;\n \n@@ -4928,7 +4928,7 @@ new_die (tag_value, parent_die)\n \n static inline dw_die_ref\n lookup_type_die (type)\n-     register tree type;\n+     tree type;\n {\n   if (TREE_CODE (type) == VECTOR_TYPE)\n     type = TYPE_DEBUG_REPRESENTATION_TYPE (type);\n@@ -4939,8 +4939,8 @@ lookup_type_die (type)\n \n static inline void\n equate_type_number_to_die (type, type_die)\n-     register tree type;\n-     register dw_die_ref type_die;\n+     tree type;\n+     dw_die_ref type_die;\n {\n   TYPE_SYMTAB_POINTER (type) = (char *) type_die;\n }\n@@ -4949,9 +4949,9 @@ equate_type_number_to_die (type, type_die)\n \n static inline dw_die_ref\n lookup_decl_die (decl)\n-     register tree decl;\n+     tree decl;\n {\n-  register unsigned decl_id = DECL_UID (decl);\n+  unsigned decl_id = DECL_UID (decl);\n \n   return (decl_id < decl_die_table_in_use\n \t  ? decl_die_table[decl_id] : NULL);\n@@ -4961,11 +4961,11 @@ lookup_decl_die (decl)\n \n static void\n equate_decl_number_to_die (decl, decl_die)\n-     register tree decl;\n-     register dw_die_ref decl_die;\n+     tree decl;\n+     dw_die_ref decl_die;\n {\n-  register unsigned decl_id = DECL_UID (decl);\n-  register unsigned num_allocated;\n+  unsigned decl_id = DECL_UID (decl);\n+  unsigned num_allocated;\n \n   if (decl_id >= decl_die_table_allocated)\n     {\n@@ -5011,8 +5011,8 @@ print_die (die, outfile)\n      dw_die_ref die;\n      FILE *outfile;\n {\n-  register dw_attr_ref a;\n-  register dw_die_ref c;\n+  dw_attr_ref a;\n+  dw_die_ref c;\n \n   print_spaces (outfile);\n   fprintf (outfile, \"DIE %4lu: %s\\n\",\n@@ -5105,8 +5105,8 @@ static void\n print_dwarf_line_table (outfile)\n      FILE *outfile;\n {\n-  register unsigned i;\n-  register dw_line_info_ref line_info;\n+  unsigned i;\n+  dw_line_info_ref line_info;\n \n   fprintf (outfile, \"\\n\\nDWARF source line information\\n\");\n   for (i = 1; i < line_info_table_in_use; ++i)\n@@ -5148,10 +5148,10 @@ debug_dwarf ()\n \n static void\n reverse_die_lists (die)\n-     register dw_die_ref die;\n+     dw_die_ref die;\n {\n-  register dw_die_ref c, cp, cn;\n-  register dw_attr_ref a, ap, an;\n+  dw_die_ref c, cp, cn;\n+  dw_attr_ref a, ap, an;\n \n   for (a = die->die_attr, ap = 0; a; a = an)\n     {\n@@ -5179,9 +5179,9 @@ reverse_die_lists (die)\n \n static void\n reverse_all_dies (die)\n-     register dw_die_ref die;\n+     dw_die_ref die;\n {\n-  register dw_die_ref c;\n+  dw_die_ref c;\n \n   reverse_die_lists (die);\n \n@@ -5465,9 +5465,9 @@ gen_internal_sym (prefix)\n \n static void\n assign_symbol_names (die)\n-     register dw_die_ref die;\n+     dw_die_ref die;\n {\n-  register dw_die_ref c;\n+  dw_die_ref c;\n \n   if (is_symbol_die (die))\n     {\n@@ -5492,15 +5492,15 @@ assign_symbol_names (die)\n \n static void\n break_out_includes (die)\n-     register dw_die_ref die;\n+     dw_die_ref die;\n {\n   dw_die_ref *ptr;\n-  register dw_die_ref unit = NULL;\n+  dw_die_ref unit = NULL;\n   limbo_die_node *node;\n \n   for (ptr = &(die->die_child); *ptr; )\n     {\n-      register dw_die_ref c = *ptr;\n+      dw_die_ref c = *ptr;\n \n       if (c->die_tag == DW_TAG_GNU_BINCL\n \t  || c->die_tag == DW_TAG_GNU_EINCL\n@@ -5551,9 +5551,9 @@ break_out_includes (die)\n \n static void\n add_sibling_attributes (die)\n-     register dw_die_ref die;\n+     dw_die_ref die;\n {\n-  register dw_die_ref c;\n+  dw_die_ref c;\n \n   if (die->die_tag != DW_TAG_compile_unit\n       && die->die_sib && die->die_child != NULL)\n@@ -5567,7 +5567,7 @@ add_sibling_attributes (die)\n /* Output all location lists for the DIE and it's children */\n static void\n output_location_lists (die)\n-     register dw_die_ref die;\n+     dw_die_ref die;\n {\n   dw_die_ref c;\n   dw_attr_ref d_attr;\n@@ -5590,12 +5590,12 @@ output_location_lists (die)\n \n static void\n build_abbrev_table (die)\n-     register dw_die_ref die;\n+     dw_die_ref die;\n {\n-  register unsigned long abbrev_id;\n-  register unsigned int n_alloc;\n-  register dw_die_ref c;\n-  register dw_attr_ref d_attr, a_attr;\n+  unsigned long abbrev_id;\n+  unsigned int n_alloc;\n+  dw_die_ref c;\n+  dw_attr_ref d_attr, a_attr;\n \n   /* Scan the DIE references, and mark as external any that refer to\n      DIEs from other CUs (i.e. those which are not marked).  */\n@@ -5612,7 +5612,7 @@ build_abbrev_table (die)\n \n   for (abbrev_id = 1; abbrev_id < abbrev_die_table_in_use; ++abbrev_id)\n     {\n-      register dw_die_ref abbrev = abbrev_die_table[abbrev_id];\n+      dw_die_ref abbrev = abbrev_die_table[abbrev_id];\n \n       if (abbrev->die_tag == die->die_tag)\n \t{\n@@ -5669,7 +5669,7 @@ build_abbrev_table (die)\n \n static unsigned long\n size_of_string (str)\n-     register const char *str;\n+     const char *str;\n {\n   return strlen (str) + 1;\n }\n@@ -5698,10 +5698,10 @@ constant_size (value)\n \n static unsigned long\n size_of_die (die)\n-     register dw_die_ref die;\n+     dw_die_ref die;\n {\n-  register unsigned long size = 0;\n-  register dw_attr_ref a;\n+  unsigned long size = 0;\n+  dw_attr_ref a;\n \n   size += size_of_uleb128 (die->die_abbrev);\n   for (a = die->die_attr; a != NULL; a = a->dw_attr_next)\n@@ -5716,7 +5716,7 @@ size_of_die (die)\n \t  break;\n \tcase dw_val_class_loc:\n \t  {\n-\t    register unsigned long lsize = size_of_locs (AT_loc (a));\n+\t    unsigned long lsize = size_of_locs (AT_loc (a));\n \n \t    /* Block length.  */\n \t    size += constant_size (lsize);\n@@ -5774,7 +5774,7 @@ static void\n calc_die_sizes (die)\n      dw_die_ref die;\n {\n-  register dw_die_ref c;\n+  dw_die_ref c;\n   die->die_offset = next_die_offset;\n   next_die_offset += size_of_die (die);\n \n@@ -5795,7 +5795,7 @@ static void\n mark_dies (die)\n      dw_die_ref die;\n {\n-  register dw_die_ref c;\n+  dw_die_ref c;\n   die->die_mark = 1;\n   for (c = die->die_child; c; c = c->die_sib)\n     mark_dies (c);\n@@ -5807,7 +5807,7 @@ static void\n unmark_dies (die)\n      dw_die_ref die;\n {\n-  register dw_die_ref c;\n+  dw_die_ref c;\n   die->die_mark = 0;\n   for (c = die->die_child; c; c = c->die_sib)\n     unmark_dies (c);\n@@ -5819,13 +5819,13 @@ unmark_dies (die)\n static unsigned long\n size_of_pubnames ()\n {\n-  register unsigned long size;\n-  register unsigned i;\n+  unsigned long size;\n+  unsigned i;\n \n   size = DWARF_PUBNAMES_HEADER_SIZE;\n   for (i = 0; i < pubname_table_in_use; ++i)\n     {\n-      register pubname_ref p = &pubname_table[i];\n+      pubname_ref p = &pubname_table[i];\n       size += DWARF_OFFSET_SIZE + size_of_string (p->name);\n     }\n \n@@ -5838,7 +5838,7 @@ size_of_pubnames ()\n static unsigned long\n size_of_aranges ()\n {\n-  register unsigned long size;\n+  unsigned long size;\n \n   size = DWARF_ARANGES_HEADER_SIZE;\n \n@@ -5943,7 +5943,7 @@ output_abbrev_section ()\n   dw_attr_ref a_attr;\n   for (abbrev_id = 1; abbrev_id < abbrev_die_table_in_use; ++abbrev_id)\n     {\n-      register dw_die_ref abbrev = abbrev_die_table[abbrev_id];\n+      dw_die_ref abbrev = abbrev_die_table[abbrev_id];\n \n       dw2_asm_output_data_uleb128 (abbrev_id, \"(abbrev code)\");\n \n@@ -5975,7 +5975,7 @@ output_abbrev_section ()\n \n static inline void\n output_die_symbol (die)\n-     register dw_die_ref die;\n+     dw_die_ref die;\n {\n   char *sym = die->die_symbol;\n \n@@ -5996,13 +5996,13 @@ output_die_symbol (die)\n    the list only.  */ \n static inline dw_loc_list_ref\n new_loc_list (expr, begin, end, section, gensym)\n-     register dw_loc_descr_ref expr;\n-     register const char *begin;\n-     register const char *end;\n-     register const char *section;\n-     register unsigned gensym;\n+     dw_loc_descr_ref expr;\n+     const char *begin;\n+     const char *end;\n+     const char *section;\n+     unsigned gensym;\n {\n-  register dw_loc_list_ref retlist\n+  dw_loc_list_ref retlist\n     = (dw_loc_list_ref) xcalloc (1, sizeof (dw_loc_list_node));\n   retlist->begin = begin;\n   retlist->end = end;\n@@ -6016,13 +6016,13 @@ new_loc_list (expr, begin, end, section, gensym)\n /* Add a location description expression to a location list */\n static inline void\n add_loc_descr_to_loc_list (list_head, descr, begin, end, section)\n-     register dw_loc_list_ref *list_head;\n-     register dw_loc_descr_ref descr;\n-     register const char *begin;\n-     register const char *end;\n-     register const char *section;\n+     dw_loc_list_ref *list_head;\n+     dw_loc_descr_ref descr;\n+     const char *begin;\n+     const char *end;\n+     const char *section;\n {\n-  register dw_loc_list_ref *d;\n+  dw_loc_list_ref *d;\n   \n   /* Find the end of the chain.  */\n   for (d = list_head; (*d) != NULL; d = &(*d)->dw_loc_next)\n@@ -6034,9 +6034,9 @@ add_loc_descr_to_loc_list (list_head, descr, begin, end, section)\n /* Output the location list given to us */\n static void\n output_loc_list (list_head)\n-     register dw_loc_list_ref list_head;\n+     dw_loc_list_ref list_head;\n {\n-  register dw_loc_list_ref curr=list_head;\n+  dw_loc_list_ref curr=list_head;\n   ASM_OUTPUT_LABEL (asm_out_file, list_head->ll_symbol);\n \n   /* ??? This shouldn't be needed now that we've forced the\n@@ -6079,11 +6079,11 @@ output_loc_list (list_head)\n \n static void\n output_die (die)\n-     register dw_die_ref die;\n+     dw_die_ref die;\n {\n-  register dw_attr_ref a;\n-  register dw_die_ref c;\n-  register unsigned long size;\n+  dw_attr_ref a;\n+  dw_die_ref c;\n+  unsigned long size;\n \n   /* If someone in another CU might refer to us, set up a symbol for\n      them to point to.  */\n@@ -6155,7 +6155,7 @@ output_die (die)\n \n \tcase dw_val_class_float:\n \t  {\n-\t    register unsigned int i;\n+\t    unsigned int i;\n \n \t    dw2_asm_output_data (1, a->dw_attr_val.v.val_float.length * 4,\n \t\t\t         \"%s\", name);\n@@ -6337,8 +6337,8 @@ add_pubname (decl, die)\n static void\n output_pubnames ()\n {\n-  register unsigned i;\n-  register unsigned long pubnames_length = size_of_pubnames ();\n+  unsigned i;\n+  unsigned long pubnames_length = size_of_pubnames ();\n \n   dw2_asm_output_data (DWARF_OFFSET_SIZE, pubnames_length,\n \t\t       \"Length of Public Names Info\");\n@@ -6353,7 +6353,7 @@ output_pubnames ()\n \n   for (i = 0; i < pubname_table_in_use; ++i)\n     {\n-      register pubname_ref pub = &pubname_table[i];\n+      pubname_ref pub = &pubname_table[i];\n \n       /* We shouldn't see pubnames for DIEs outside of the main CU.  */\n       if (pub->die->die_mark == 0)\n@@ -6395,8 +6395,8 @@ add_arange (decl, die)\n static void\n output_aranges ()\n {\n-  register unsigned i;\n-  register unsigned long aranges_length = size_of_aranges ();\n+  unsigned i;\n+  unsigned long aranges_length = size_of_aranges ();\n \n   dw2_asm_output_data (DWARF_OFFSET_SIZE, aranges_length,\n \t\t       \"Length of Address Ranges Info\");\n@@ -6494,7 +6494,7 @@ add_ranges (block)\n static void\n output_ranges ()\n {\n-  register unsigned i;\n+  unsigned i;\n   static const char *const start_fmt = \"Offset 0x%x\";\n   const char *fmt = start_fmt;\n \n@@ -6821,14 +6821,14 @@ output_line_info ()\n   char l1[20], l2[20], p1[20], p2[20];\n   char line_label[MAX_ARTIFICIAL_LABEL_BYTES];\n   char prev_line_label[MAX_ARTIFICIAL_LABEL_BYTES];\n-  register unsigned opc;\n-  register unsigned n_op_args;\n-  register unsigned long lt_index;\n-  register unsigned long current_line;\n-  register long line_offset;\n-  register long line_delta;\n-  register unsigned long current_file;\n-  register unsigned long function;\n+  unsigned opc;\n+  unsigned n_op_args;\n+  unsigned long lt_index;\n+  unsigned long current_line;\n+  long line_offset;\n+  long line_delta;\n+  unsigned long current_file;\n+  unsigned long function;\n \n   ASM_GENERATE_INTERNAL_LABEL (l1, LINE_NUMBER_BEGIN_LABEL, 0);\n   ASM_GENERATE_INTERNAL_LABEL (l2, LINE_NUMBER_END_LABEL, 0);\n@@ -6894,7 +6894,7 @@ output_line_info ()\n   strcpy (prev_line_label, text_section_label);\n   for (lt_index = 1; lt_index < line_info_table_in_use; ++lt_index)\n     {\n-      register dw_line_info_ref line_info = &line_info_table[lt_index];\n+      dw_line_info_ref line_info = &line_info_table[lt_index];\n \n #if 0\n       /* Disable this optimization for now; GDB wants to see two line notes\n@@ -7003,7 +7003,7 @@ output_line_info ()\n   current_line = 1;\n   for (lt_index = 0; lt_index < separate_line_info_table_in_use;)\n     {\n-      register dw_separate_line_info_ref line_info\n+      dw_separate_line_info_ref line_info\n \t= &separate_line_info_table[lt_index];\n \n #if 0\n@@ -7126,12 +7126,12 @@ output_line_info ()\n \n static dw_die_ref\n base_type_die (type)\n-     register tree type;\n+     tree type;\n {\n-  register dw_die_ref base_type_result;\n-  register const char *type_name;\n-  register enum dwarf_type encoding;\n-  register tree name = TYPE_NAME (type);\n+  dw_die_ref base_type_result;\n+  const char *type_name;\n+  enum dwarf_type encoding;\n+  tree name = TYPE_NAME (type);\n \n   if (TREE_CODE (type) == ERROR_MARK\n       || TREE_CODE (type) == VOID_TYPE)\n@@ -7220,7 +7220,7 @@ base_type_die (type)\n \n static tree\n root_type (type)\n-     register tree type;\n+     tree type;\n {\n   if (TREE_CODE (type) == ERROR_MARK)\n     return error_mark_node;\n@@ -7244,7 +7244,7 @@ root_type (type)\n \n static inline int\n is_base_type (type)\n-     register tree type;\n+     tree type;\n {\n   switch (TREE_CODE (type))\n     {\n@@ -7285,15 +7285,15 @@ is_base_type (type)\n \n static dw_die_ref\n modified_type_die (type, is_const_type, is_volatile_type, context_die)\n-     register tree type;\n-     register int is_const_type;\n-     register int is_volatile_type;\n-     register dw_die_ref context_die;\n+     tree type;\n+     int is_const_type;\n+     int is_volatile_type;\n+     dw_die_ref context_die;\n {\n-  register enum tree_code code = TREE_CODE (type);\n-  register dw_die_ref mod_type_die = NULL;\n-  register dw_die_ref sub_die = NULL;\n-  register tree item_type = NULL;\n+  enum tree_code code = TREE_CODE (type);\n+  dw_die_ref mod_type_die = NULL;\n+  dw_die_ref sub_die = NULL;\n+  tree item_type = NULL;\n \n   if (code != ERROR_MARK)\n     {\n@@ -7414,7 +7414,7 @@ modified_type_die (type, is_const_type, is_volatile_type, context_die)\n \n static inline int\n type_is_enum (type)\n-     register tree type;\n+     tree type;\n {\n   return TREE_CODE (type) == ENUMERAL_TYPE;\n }\n@@ -7423,9 +7423,9 @@ type_is_enum (type)\n \n static unsigned int\n reg_number (rtl)\n-     register rtx rtl;\n+     rtx rtl;\n {\n-  register unsigned regno = REGNO (rtl);\n+  unsigned regno = REGNO (rtl);\n \n   if (regno >= FIRST_PSEUDO_REGISTER)\n     {\n@@ -7441,10 +7441,10 @@ reg_number (rtl)\n \n static dw_loc_descr_ref\n reg_loc_descriptor (rtl)\n-     register rtx rtl;\n+     rtx rtl;\n {\n-  register dw_loc_descr_ref loc_result = NULL;\n-  register unsigned reg = reg_number (rtl);\n+  dw_loc_descr_ref loc_result = NULL;\n+  unsigned reg = reg_number (rtl);\n \n   if (reg <= 31)\n     loc_result = new_loc_descr (DW_OP_reg0 + reg, 0, 0);\n@@ -7501,13 +7501,13 @@ based_loc_descr (reg, offset)\n      unsigned reg;\n      long int offset;\n {\n-  register dw_loc_descr_ref loc_result;\n+  dw_loc_descr_ref loc_result;\n   /* For the \"frame base\", we use the frame pointer or stack pointer\n      registers, since the RTL for local variables is relative to one of\n      them.  */\n-  register unsigned fp_reg = DBX_REGISTER_NUMBER (frame_pointer_needed\n-\t\t\t\t\t\t  ? HARD_FRAME_POINTER_REGNUM\n-\t\t\t\t\t\t  : STACK_POINTER_REGNUM);\n+  unsigned fp_reg = DBX_REGISTER_NUMBER (frame_pointer_needed\n+\t\t\t\t\t ? HARD_FRAME_POINTER_REGNUM\n+\t\t\t\t\t : STACK_POINTER_REGNUM);\n \n   if (reg == fp_reg)\n     loc_result = new_loc_descr (DW_OP_fbreg, offset, 0);\n@@ -7523,7 +7523,7 @@ based_loc_descr (reg, offset)\n \n static inline int\n is_based_loc (rtl)\n-     register rtx rtl;\n+     rtx rtl;\n {\n     return (GET_CODE (rtl) == PLUS\n \t    && ((GET_CODE (XEXP (rtl, 0)) == REG\n@@ -7545,7 +7545,7 @@ is_based_loc (rtl)\n \n static dw_loc_descr_ref\n mem_loc_descriptor (rtl, mode)\n-     register rtx rtl;\n+     rtx rtl;\n      enum machine_mode mode;\n {\n   dw_loc_descr_ref mem_loc_result = NULL;\n@@ -7690,7 +7690,7 @@ mem_loc_descriptor (rtl, mode)\n \n static dw_loc_descr_ref\n concat_loc_descriptor (x0, x1)\n-     register rtx x0, x1;\n+     rtx x0, x1;\n {\n   dw_loc_descr_ref cc_loc_result = NULL;\n \n@@ -7717,7 +7717,7 @@ concat_loc_descriptor (x0, x1)\n \n static dw_loc_descr_ref\n loc_descriptor (rtl)\n-     register rtx rtl;\n+     rtx rtl;\n {\n   dw_loc_descr_ref loc_result = NULL;\n   switch (GET_CODE (rtl))\n@@ -8038,9 +8038,9 @@ ceiling (value, boundary)\n \n static inline tree\n field_type (decl)\n-     register tree decl;\n+     tree decl;\n {\n-  register tree type;\n+  tree type;\n \n   if (TREE_CODE (decl) == ERROR_MARK)\n     return integer_type_node;\n@@ -8058,14 +8058,14 @@ field_type (decl)\n \n static inline unsigned\n simple_type_align_in_bits (type)\n-     register tree type;\n+     tree type;\n {\n   return (TREE_CODE (type) != ERROR_MARK) ? TYPE_ALIGN (type) : BITS_PER_WORD;\n }\n \n static inline unsigned\n simple_decl_align_in_bits (decl)\n-     register tree decl;\n+     tree decl;\n {\n   return (TREE_CODE (decl) != ERROR_MARK) ? DECL_ALIGN (decl) : BITS_PER_WORD;\n }\n@@ -8078,7 +8078,7 @@ simple_decl_align_in_bits (decl)\n \n static inline unsigned HOST_WIDE_INT\n simple_type_size_in_bits (type)\n-     register tree type;\n+     tree type;\n {\n   tree type_size_tree;\n \n@@ -8102,7 +8102,7 @@ simple_type_size_in_bits (type)\n \n static HOST_WIDE_INT\n field_byte_offset (decl)\n-     register tree decl;\n+     tree decl;\n {\n   unsigned int type_align_in_bits;\n   unsigned int decl_align_in_bits;\n@@ -8228,7 +8228,7 @@ static void\n add_AT_location_description (die, attr_kind, rtl)\n      dw_die_ref die;\n      enum dwarf_attribute attr_kind;\n-     register rtx rtl;\n+     rtx rtl;\n {\n   /* Handle a special case.  If we are about to output a location descriptor\n      for a variable or parameter which has been optimized out of existence,\n@@ -8278,12 +8278,12 @@ add_AT_location_description (die, attr_kind, rtl)\n \n static void\n add_data_member_location_attribute (die, decl)\n-     register dw_die_ref die;\n-     register tree decl;\n+     dw_die_ref die;\n+     tree decl;\n {\n-  register unsigned long offset;\n-  register dw_loc_descr_ref loc_descr;\n-  register enum dwarf_location_atom op;\n+  unsigned long offset;\n+  dw_loc_descr_ref loc_descr;\n+  enum dwarf_location_atom op;\n \n   if (TREE_CODE (decl) == TREE_VEC)\n     offset = tree_low_cst (BINFO_OFFSET (decl), 0);\n@@ -8314,8 +8314,8 @@ add_data_member_location_attribute (die, decl)\n \n static void\n add_const_value_attribute (die, rtl)\n-     register dw_die_ref die;\n-     register rtx rtl;\n+     dw_die_ref die;\n+     rtx rtl;\n {\n   switch (GET_CODE (rtl))\n     {\n@@ -8350,11 +8350,11 @@ add_const_value_attribute (die, rtl)\n          constant requires more than one word in order to be adequately\n          represented.  We output CONST_DOUBLEs as blocks.  */\n       {\n-\tregister enum machine_mode mode = GET_MODE (rtl);\n+\tenum machine_mode mode = GET_MODE (rtl);\n \n \tif (GET_MODE_CLASS (mode) == MODE_FLOAT)\n \t  {\n-\t    register unsigned length = GET_MODE_SIZE (mode) / 4;\n+\t    unsigned length = GET_MODE_SIZE (mode) / 4;\n  \t    long *array = (long *) xmalloc (sizeof (long) * length);\n \t    REAL_VALUE_TYPE rv;\n \n@@ -8426,7 +8426,7 @@ static rtx\n rtl_for_decl_location (decl)\n      tree decl;\n {\n-  register rtx rtl;\n+  rtx rtl;\n \n   /* Here we have to decide where we are going to say the parameter \"lives\"\n      (as far as the debugger is concerned).  We only have a couple of\n@@ -8583,10 +8583,10 @@ rtl_for_decl_location (decl)\n \n static void\n add_location_or_const_value_attribute (die, decl)\n-     register dw_die_ref die;\n-     register tree decl;\n+     dw_die_ref die;\n+     tree decl;\n {\n-  register rtx rtl;\n+  rtx rtl;\n \n   if (TREE_CODE (decl) == ERROR_MARK)\n     return;\n@@ -8672,8 +8672,8 @@ tree_add_const_value_attribute (var_die, decl)\n \n static inline void\n add_name_attribute (die, name_string)\n-     register dw_die_ref die;\n-     register const char *name_string;\n+     dw_die_ref die;\n+     const char *name_string;\n {\n   if (name_string != NULL && *name_string != 0)\n     {\n@@ -8689,9 +8689,9 @@ add_name_attribute (die, name_string)\n \n static void\n add_bound_info (subrange_die, bound_attr, bound)\n-     register dw_die_ref subrange_die;\n-     register enum dwarf_attribute bound_attr;\n-     register tree bound;\n+     dw_die_ref subrange_die;\n+     enum dwarf_attribute bound_attr;\n+     tree bound;\n {\n   /* If this is an Ada unconstrained array type, then don't emit any debug\n      info because the array bounds are unknown.  They are parameterized when\n@@ -8748,9 +8748,9 @@ add_bound_info (subrange_die, bound_attr, bound)\n       if (SAVE_EXPR_RTL (bound)\n \t  && (! optimize || GET_CODE (SAVE_EXPR_RTL (bound)) == MEM))\n \t{\n-\t  register dw_die_ref ctx = lookup_decl_die (current_function_decl);\n-\t  register dw_die_ref decl_die = new_die (DW_TAG_variable, ctx);\n-\t  register rtx loc = SAVE_EXPR_RTL (bound);\n+\t  dw_die_ref ctx = lookup_decl_die (current_function_decl);\n+\t  dw_die_ref decl_die = new_die (DW_TAG_variable, ctx);\n+\t  rtx loc = SAVE_EXPR_RTL (bound);\n \n \t  /* If the RTL for the SAVE_EXPR is memory, handle the case where\n \t     it references an outer function's frame.  */\n@@ -8817,14 +8817,14 @@ add_bound_info (subrange_die, bound_attr, bound)\n \n static void\n add_subscript_info (type_die, type)\n-     register dw_die_ref type_die;\n-     register tree type;\n+     dw_die_ref type_die;\n+     tree type;\n {\n #ifndef MIPS_DEBUGGING_INFO\n-  register unsigned dimension_number;\n+  unsigned dimension_number;\n #endif\n-  register tree lower, upper;\n-  register dw_die_ref subrange_die;\n+  tree lower, upper;\n+  dw_die_ref subrange_die;\n \n   /* The GNU compilers represent multidimensional array types as sequences of\n      one dimensional array types whose element types are themselves array\n@@ -8845,7 +8845,7 @@ add_subscript_info (type_die, type)\n        type = TREE_TYPE (type), dimension_number++)\n     {\n #endif\n-      register tree domain = TYPE_DOMAIN (type);\n+      tree domain = TYPE_DOMAIN (type);\n \n       /* Arrays come in three flavors: Unspecified bounds, fixed bounds,\n \t and (in GNU C only) variable bounds.  Handle all three forms\n@@ -8898,9 +8898,9 @@ add_subscript_info (type_die, type)\n static void\n add_byte_size_attribute (die, tree_node)\n      dw_die_ref die;\n-     register tree tree_node;\n+     tree tree_node;\n {\n-  register unsigned size;\n+  unsigned size;\n \n   switch (TREE_CODE (tree_node))\n     {\n@@ -8951,8 +8951,8 @@ add_byte_size_attribute (die, tree_node)\n \n static inline void\n add_bit_offset_attribute (die, decl)\n-     register dw_die_ref die;\n-     register tree decl;\n+     dw_die_ref die;\n+     tree decl;\n {\n   HOST_WIDE_INT object_offset_in_bytes = field_byte_offset (decl);\n   tree type = DECL_BIT_FIELD_TYPE (decl);\n@@ -9002,8 +9002,8 @@ add_bit_offset_attribute (die, decl)\n \n static inline void\n add_bit_size_attribute (die, decl)\n-     register dw_die_ref die;\n-     register tree decl;\n+     dw_die_ref die;\n+     tree decl;\n {\n   /* Must be a field and a bit field.  */\n   if (TREE_CODE (decl) != FIELD_DECL\n@@ -9019,8 +9019,8 @@ add_bit_size_attribute (die, decl)\n \n static inline void\n add_prototyped_attribute (die, func_type)\n-     register dw_die_ref die;\n-     register tree func_type;\n+     dw_die_ref die;\n+     tree func_type;\n {\n   if (get_AT_unsigned (comp_unit_die, DW_AT_language) == DW_LANG_C89\n       && TYPE_ARG_TYPES (func_type) != NULL)\n@@ -9033,8 +9033,8 @@ add_prototyped_attribute (die, func_type)\n \n static inline void\n add_abstract_origin_attribute (die, origin)\n-     register dw_die_ref die;\n-     register tree origin;\n+     dw_die_ref die;\n+     tree origin;\n {\n   dw_die_ref origin_die = NULL;\n \n@@ -9069,8 +9069,8 @@ add_abstract_origin_attribute (die, origin)\n \n static inline void\n add_pure_or_virtual_attribute (die, func_decl)\n-     register dw_die_ref die;\n-     register tree func_decl;\n+     dw_die_ref die;\n+     tree func_decl;\n {\n   if (DECL_VINDEX (func_decl))\n     {\n@@ -9093,10 +9093,10 @@ add_pure_or_virtual_attribute (die, func_decl)\n \n static void\n add_src_coords_attributes (die, decl)\n-     register dw_die_ref die;\n-     register tree decl;\n+     dw_die_ref die;\n+     tree decl;\n {\n-  register unsigned file_index = lookup_filename (DECL_SOURCE_FILE (decl));\n+  unsigned file_index = lookup_filename (DECL_SOURCE_FILE (decl));\n \n   add_AT_unsigned (die, DW_AT_decl_file, file_index);\n   add_AT_unsigned (die, DW_AT_decl_line, DECL_SOURCE_LINE (decl));\n@@ -9107,10 +9107,10 @@ add_src_coords_attributes (die, decl)\n \n static void\n add_name_and_src_coords_attributes (die, decl)\n-     register dw_die_ref die;\n-     register tree decl;\n+     dw_die_ref die;\n+     tree decl;\n {\n-  register tree decl_name;\n+  tree decl_name;\n \n   decl_name = DECL_NAME (decl);\n   if (decl_name != NULL && IDENTIFIER_POINTER (decl_name) != NULL)\n@@ -9154,12 +9154,12 @@ pop_decl_scope ()\n \n static dw_die_ref\n scope_die_for (t, context_die)\n-     register tree t;\n-     register dw_die_ref context_die;\n+     tree t;\n+     dw_die_ref context_die;\n {\n-  register dw_die_ref scope_die = NULL;\n-  register tree containing_scope;\n-  register int i;\n+  dw_die_ref scope_die = NULL;\n+  tree containing_scope;\n+  int i;\n \n   /* Non-types always go in the current scope.  */\n   if (! TYPE_P (t))\n@@ -9239,14 +9239,14 @@ class_scope_p (context_die)\n \n static void\n add_type_attribute (object_die, type, decl_const, decl_volatile, context_die)\n-     register dw_die_ref object_die;\n-     register tree type;\n-     register int decl_const;\n-     register int decl_volatile;\n-     register dw_die_ref context_die;\n+     dw_die_ref object_die;\n+     tree type;\n+     int decl_const;\n+     int decl_volatile;\n+     dw_die_ref context_die;\n {\n-  register enum tree_code code  = TREE_CODE (type);\n-  register dw_die_ref type_die  = NULL;\n+  enum tree_code code  = TREE_CODE (type);\n+  dw_die_ref type_die  = NULL;\n \n   /* ??? If this type is an unnamed subrange type of an integral or\n      floating-point type, use the inner type.  This is because we have no\n@@ -9279,13 +9279,13 @@ add_type_attribute (object_die, type, decl_const, decl_volatile, context_die)\n \n static const char *\n type_tag (type)\n-     register tree type;\n+     tree type;\n {\n-  register const char *name = 0;\n+  const char *name = 0;\n \n   if (TYPE_NAME (type) != 0)\n     {\n-      register tree t = 0;\n+      tree t = 0;\n \n       /* Find the IDENTIFIER_NODE for the type name.  */\n       if (TREE_CODE (TYPE_NAME (type)) == IDENTIFIER_NODE)\n@@ -9311,7 +9311,7 @@ type_tag (type)\n \n static inline tree\n member_declared_type (member)\n-     register tree member;\n+     tree member;\n {\n   return (DECL_BIT_FIELD_TYPE (member)\n \t  ? DECL_BIT_FIELD_TYPE (member)\n@@ -9324,7 +9324,7 @@ member_declared_type (member)\n #if 0\n static const char *\n decl_start_label (decl)\n-     register tree decl;\n+     tree decl;\n {\n   rtx x;\n   const char *fnname;\n@@ -9347,12 +9347,12 @@ decl_start_label (decl)\n \n static void\n gen_array_type_die (type, context_die)\n-     register tree type;\n-     register dw_die_ref context_die;\n+     tree type;\n+     dw_die_ref context_die;\n {\n-  register dw_die_ref scope_die = scope_die_for (type, context_die);\n-  register dw_die_ref array_die;\n-  register tree element_type;\n+  dw_die_ref scope_die = scope_die_for (type, context_die);\n+  dw_die_ref array_die;\n+  tree element_type;\n \n   /* ??? The SGI dwarf reader fails for array of array of enum types unless\n      the inner array type comes before the outer array type.  Thus we must\n@@ -9405,10 +9405,10 @@ gen_array_type_die (type, context_die)\n \n static void\n gen_set_type_die (type, context_die)\n-     register tree type;\n-     register dw_die_ref context_die;\n+     tree type;\n+     dw_die_ref context_die;\n {\n-  register dw_die_ref type_die\n+  dw_die_ref type_die\n     = new_die (DW_TAG_set_type, scope_die_for (type, context_die));\n \n   equate_type_number_to_die (type, type_die);\n@@ -9418,11 +9418,11 @@ gen_set_type_die (type, context_die)\n #if 0\n static void\n gen_entry_point_die (decl, context_die)\n-     register tree decl;\n-     register dw_die_ref context_die;\n+     tree decl;\n+     dw_die_ref context_die;\n {\n-  register tree origin = decl_ultimate_origin (decl);\n-  register dw_die_ref decl_die = new_die (DW_TAG_entry_point, context_die);\n+  tree origin = decl_ultimate_origin (decl);\n+  dw_die_ref decl_die = new_die (DW_TAG_entry_point, context_die);\n   if (origin != NULL)\n     add_abstract_origin_attribute (decl_die, origin);\n   else\n@@ -9464,11 +9464,10 @@ retry_incomplete_types ()\n \n static void\n gen_inlined_enumeration_type_die (type, context_die)\n-     register tree type;\n-     register dw_die_ref context_die;\n+     tree type;\n+     dw_die_ref context_die;\n {\n-  register dw_die_ref type_die = new_die (DW_TAG_enumeration_type,\n-\t\t\t\t\t  context_die);\n+  dw_die_ref type_die = new_die (DW_TAG_enumeration_type, context_die);\n   /* We do not check for TREE_ASM_WRITTEN (type) being set, as the type may\n      be incomplete and such types are not marked.  */\n   add_abstract_origin_attribute (type_die, type);\n@@ -9478,10 +9477,10 @@ gen_inlined_enumeration_type_die (type, context_die)\n \n static void\n gen_inlined_structure_type_die (type, context_die)\n-     register tree type;\n-     register dw_die_ref context_die;\n+     tree type;\n+     dw_die_ref context_die;\n {\n-  register dw_die_ref type_die = new_die (DW_TAG_structure_type, context_die);\n+  dw_die_ref type_die = new_die (DW_TAG_structure_type, context_die);\n \n   /* We do not check for TREE_ASM_WRITTEN (type) being set, as the type may\n      be incomplete and such types are not marked.  */\n@@ -9492,10 +9491,10 @@ gen_inlined_structure_type_die (type, context_die)\n \n static void\n gen_inlined_union_type_die (type, context_die)\n-     register tree type;\n-     register dw_die_ref context_die;\n+     tree type;\n+     dw_die_ref context_die;\n {\n-  register dw_die_ref type_die = new_die (DW_TAG_union_type, context_die);\n+  dw_die_ref type_die = new_die (DW_TAG_union_type, context_die);\n \n   /* We do not check for TREE_ASM_WRITTEN (type) being set, as the type may\n      be incomplete and such types are not marked.  */\n@@ -9509,10 +9508,10 @@ gen_inlined_union_type_die (type, context_die)\n \n static void\n gen_enumeration_type_die (type, context_die)\n-     register tree type;\n-     register dw_die_ref context_die;\n+     tree type;\n+     dw_die_ref context_die;\n {\n-  register dw_die_ref type_die = lookup_type_die (type);\n+  dw_die_ref type_die = lookup_type_die (type);\n \n   if (type_die == NULL)\n     {\n@@ -9531,7 +9530,7 @@ gen_enumeration_type_die (type, context_die)\n      attribute or the DW_AT_element_list attribute.  */\n   if (TYPE_SIZE (type))\n     {\n-      register tree link;\n+      tree link;\n \n       TREE_ASM_WRITTEN (type) = 1;\n       add_byte_size_attribute (type_die, type);\n@@ -9546,7 +9545,7 @@ gen_enumeration_type_die (type, context_die)\n       for (link = TYPE_FIELDS (type);\n \t   link != NULL; link = TREE_CHAIN (link))\n \t{\n-\t  register dw_die_ref enum_die = new_die (DW_TAG_enumerator, type_die);\n+\t  dw_die_ref enum_die = new_die (DW_TAG_enumerator, type_die);\n \n \t  add_name_attribute (enum_die,\n \t\t\t      IDENTIFIER_POINTER (TREE_PURPOSE (link)));\n@@ -9581,12 +9580,12 @@ gen_enumeration_type_die (type, context_die)\n \n static dw_die_ref\n gen_formal_parameter_die (node, context_die)\n-     register tree node;\n-     register dw_die_ref context_die;\n+     tree node;\n+     dw_die_ref context_die;\n {\n-  register dw_die_ref parm_die\n+  dw_die_ref parm_die\n     = new_die (DW_TAG_formal_parameter, context_die);\n-  register tree origin;\n+  tree origin;\n \n   switch (TREE_CODE_CLASS (TREE_CODE (node)))\n     {\n@@ -9628,8 +9627,8 @@ gen_formal_parameter_die (node, context_die)\n \n static void\n gen_unspecified_parameters_die (decl_or_type, context_die)\n-     register tree decl_or_type ATTRIBUTE_UNUSED;\n-     register dw_die_ref context_die;\n+     tree decl_or_type ATTRIBUTE_UNUSED;\n+     dw_die_ref context_die;\n {\n   new_die (DW_TAG_unspecified_parameters, context_die);\n }\n@@ -9641,12 +9640,12 @@ gen_unspecified_parameters_die (decl_or_type, context_die)\n \n static void\n gen_formal_types_die (function_or_method_type, context_die)\n-     register tree function_or_method_type;\n-     register dw_die_ref context_die;\n+     tree function_or_method_type;\n+     dw_die_ref context_die;\n {\n-  register tree link;\n-  register tree formal_type = NULL;\n-  register tree first_parm_type;\n+  tree link;\n+  tree formal_type = NULL;\n+  tree first_parm_type;\n   tree arg;\n \n   if (TREE_CODE (function_or_method_type) == FUNCTION_DECL)\n@@ -9663,7 +9662,7 @@ gen_formal_types_die (function_or_method_type, context_die)\n      DW_TAG_formal_parameter DIE for each one.  */\n   for (link = first_parm_type; link; )\n     {\n-      register dw_die_ref parm_die;\n+      dw_die_ref parm_die;\n \n       formal_type = TREE_VALUE (link);\n       if (formal_type == void_type_node)\n@@ -9738,7 +9737,7 @@ static void\n dwarf2out_abstract_function (decl)\n      tree decl;\n {\n-  register dw_die_ref old_die;\n+  dw_die_ref old_die;\n   tree save_fn;\n   tree context;\n   int was_abstract = DECL_ABSTRACT (decl);\n@@ -9778,18 +9777,18 @@ dwarf2out_abstract_function (decl)\n \n static void\n gen_subprogram_die (decl, context_die)\n-     register tree decl;\n-     register dw_die_ref context_die;\n+     tree decl;\n+     dw_die_ref context_die;\n {\n   char label_id[MAX_ARTIFICIAL_LABEL_BYTES];\n-  register tree origin = decl_ultimate_origin (decl);\n-  register dw_die_ref subr_die;\n-  register rtx fp_reg;\n-  register tree fn_arg_types;\n-  register tree outer_scope;\n-  register dw_die_ref old_die = lookup_decl_die (decl);\n-  register int declaration = (current_function_decl != decl\n-\t\t\t      || class_scope_p (context_die));\n+  tree origin = decl_ultimate_origin (decl);\n+  dw_die_ref subr_die;\n+  rtx fp_reg;\n+  tree fn_arg_types;\n+  tree outer_scope;\n+  dw_die_ref old_die = lookup_decl_die (decl);\n+  int declaration = (current_function_decl != decl\n+\t\t     || class_scope_p (context_die));\n \n   /* Note that it is possible to have both DECL_ABSTRACT and `declaration'\n      be true, if we started to generate the abstract instance of an inline,\n@@ -9880,7 +9879,7 @@ gen_subprogram_die (decl, context_die)\n       add_name_and_src_coords_attributes (subr_die, decl);\n       if (debug_info_level > DINFO_LEVEL_TERSE)\n \t{\n-\t  register tree type = TREE_TYPE (decl);\n+\t  tree type = TREE_TYPE (decl);\n \n \t  add_prototyped_attribute (subr_die, type);\n \t  add_type_attribute (subr_die, TREE_TYPE (type), 0, 0, context_die);\n@@ -9984,8 +9983,8 @@ gen_subprogram_die (decl, context_die)\n   else\n     {\n       /* Generate DIEs to represent all known formal parameters */\n-      register tree arg_decls = DECL_ARGUMENTS (decl);\n-      register tree parm;\n+      tree arg_decls = DECL_ARGUMENTS (decl);\n+      tree parm;\n \n       /* When generating DIEs, generate the unspecified_parameters DIE\n          instead if we come across the arg \"__builtin_va_alist\" */\n@@ -10058,11 +10057,11 @@ gen_subprogram_die (decl, context_die)\n \n static void\n gen_variable_die (decl, context_die)\n-     register tree decl;\n-     register dw_die_ref context_die;\n+     tree decl;\n+     dw_die_ref context_die;\n {\n-  register tree origin = decl_ultimate_origin (decl);\n-  register dw_die_ref var_die = new_die (DW_TAG_variable, context_die);\n+  tree origin = decl_ultimate_origin (decl);\n+  dw_die_ref var_die = new_die (DW_TAG_variable, context_die);\n \n   dw_die_ref old_die = lookup_decl_die (decl);\n   int declaration = (DECL_EXTERNAL (decl)\n@@ -10134,12 +10133,12 @@ gen_variable_die (decl, context_die)\n \n static void\n gen_label_die (decl, context_die)\n-     register tree decl;\n-     register dw_die_ref context_die;\n+     tree decl;\n+     dw_die_ref context_die;\n {\n-  register tree origin = decl_ultimate_origin (decl);\n-  register dw_die_ref lbl_die = new_die (DW_TAG_label, context_die);\n-  register rtx insn;\n+  tree origin = decl_ultimate_origin (decl);\n+  dw_die_ref lbl_die = new_die (DW_TAG_label, context_die);\n+  rtx insn;\n   char label[MAX_ARTIFICIAL_LABEL_BYTES];\n \n   if (origin != NULL)\n@@ -10178,11 +10177,11 @@ gen_label_die (decl, context_die)\n \n static void\n gen_lexical_block_die (stmt, context_die, depth)\n-     register tree stmt;\n-     register dw_die_ref context_die;\n+     tree stmt;\n+     dw_die_ref context_die;\n      int depth;\n {\n-  register dw_die_ref stmt_die = new_die (DW_TAG_lexical_block, context_die);\n+  dw_die_ref stmt_die = new_die (DW_TAG_lexical_block, context_die);\n   char label[MAX_ARTIFICIAL_LABEL_BYTES];\n \n   if (! BLOCK_ABSTRACT (stmt))\n@@ -10220,15 +10219,15 @@ gen_lexical_block_die (stmt, context_die, depth)\n \n static void\n gen_inlined_subroutine_die (stmt, context_die, depth)\n-     register tree stmt;\n-     register dw_die_ref context_die;\n+     tree stmt;\n+     dw_die_ref context_die;\n      int depth;\n {\n   if (! BLOCK_ABSTRACT (stmt))\n     {\n-      register dw_die_ref subr_die\n+      dw_die_ref subr_die\n \t= new_die (DW_TAG_inlined_subroutine, context_die);\n-      register tree decl = block_ultimate_origin (stmt);\n+      tree decl = block_ultimate_origin (stmt);\n       char label[MAX_ARTIFICIAL_LABEL_BYTES];\n \n       /* Emit info for the abstract instance first, if we haven't yet.  */\n@@ -10250,10 +10249,10 @@ gen_inlined_subroutine_die (stmt, context_die, depth)\n \n static void\n gen_field_die (decl, context_die)\n-     register tree decl;\n-     register dw_die_ref context_die;\n+     tree decl;\n+     dw_die_ref context_die;\n {\n-  register dw_die_ref decl_die = new_die (DW_TAG_member, context_die);\n+  dw_die_ref decl_die = new_die (DW_TAG_member, context_die);\n \n   add_name_and_src_coords_attributes (decl_die, decl);\n   add_type_attribute (decl_die, member_declared_type (decl),\n@@ -10288,10 +10287,10 @@ gen_field_die (decl, context_die)\n    represent certain things in other languages (e.g. Pascal) someday.  */\n static void\n gen_pointer_type_die (type, context_die)\n-     register tree type;\n-     register dw_die_ref context_die;\n+     tree type;\n+     dw_die_ref context_die;\n {\n-  register dw_die_ref ptr_die\n+  dw_die_ref ptr_die\n     = new_die (DW_TAG_pointer_type, scope_die_for (type, context_die));\n \n   equate_type_number_to_die (type, ptr_die);\n@@ -10305,10 +10304,10 @@ gen_pointer_type_die (type, context_die)\n    represent certain things in other languages (e.g. Pascal) someday.  */\n static void\n gen_reference_type_die (type, context_die)\n-     register tree type;\n-     register dw_die_ref context_die;\n+     tree type;\n+     dw_die_ref context_die;\n {\n-  register dw_die_ref ref_die\n+  dw_die_ref ref_die\n     = new_die (DW_TAG_reference_type, scope_die_for (type, context_die));\n \n   equate_type_number_to_die (type, ref_die);\n@@ -10320,10 +10319,10 @@ gen_reference_type_die (type, context_die)\n /* Generate a DIE for a pointer to a member type.  */\n static void\n gen_ptr_to_mbr_type_die (type, context_die)\n-     register tree type;\n-     register dw_die_ref context_die;\n+     tree type;\n+     dw_die_ref context_die;\n {\n-  register dw_die_ref ptr_die\n+  dw_die_ref ptr_die\n     = new_die (DW_TAG_ptr_to_member_type, scope_die_for (type, context_die));\n \n   equate_type_number_to_die (type, ptr_die);\n@@ -10336,9 +10335,9 @@ gen_ptr_to_mbr_type_die (type, context_die)\n \n static dw_die_ref\n gen_compile_unit_die (filename)\n-     register const char *filename;\n+     const char *filename;\n {\n-  register dw_die_ref die;\n+  dw_die_ref die;\n   char producer[250];\n   const char *wd = getpwd ();\n   int language;\n@@ -10388,10 +10387,10 @@ gen_compile_unit_die (filename)\n \n static void\n gen_string_type_die (type, context_die)\n-     register tree type;\n-     register dw_die_ref context_die;\n+     tree type;\n+     dw_die_ref context_die;\n {\n-  register dw_die_ref type_die\n+  dw_die_ref type_die\n     = new_die (DW_TAG_string_type, scope_die_for (type, context_die));\n \n   equate_type_number_to_die (type, type_die);\n@@ -10407,8 +10406,8 @@ gen_string_type_die (type, context_die)\n \n static void\n gen_inheritance_die (binfo, context_die)\n-     register tree binfo;\n-     register dw_die_ref context_die;\n+     tree binfo;\n+     dw_die_ref context_die;\n {\n   dw_die_ref die = new_die (DW_TAG_inheritance, context_die);\n \n@@ -10427,10 +10426,10 @@ gen_inheritance_die (binfo, context_die)\n \n static void\n gen_member_die (type, context_die)\n-     register tree type;\n-     register dw_die_ref context_die;\n+     tree type;\n+     dw_die_ref context_die;\n {\n-  register tree member;\n+  tree member;\n   dw_die_ref child;\n \n   /* If this is not an incomplete type, output descriptions of each of its\n@@ -10449,9 +10448,9 @@ gen_member_die (type, context_die)\n   /* First output info about the base classes.  */\n   if (TYPE_BINFO (type) && TYPE_BINFO_BASETYPES (type))\n     {\n-      register tree bases = TYPE_BINFO_BASETYPES (type);\n-      register int n_bases = TREE_VEC_LENGTH (bases);\n-      register int i;\n+      tree bases = TYPE_BINFO_BASETYPES (type);\n+      int n_bases = TREE_VEC_LENGTH (bases);\n+      int i;\n \n       for (i = 0; i < n_bases; i++)\n \tgen_inheritance_die (TREE_VEC_ELT (bases, i), context_die);\n@@ -10493,12 +10492,12 @@ gen_member_die (type, context_die)\n \n static void\n gen_struct_or_union_type_die (type, context_die)\n-     register tree type;\n-     register dw_die_ref context_die;\n+     tree type;\n+     dw_die_ref context_die;\n {\n-  register dw_die_ref type_die = lookup_type_die (type);\n-  register dw_die_ref scope_die = 0;\n-  register int nested = 0;\n+  dw_die_ref type_die = lookup_type_die (type);\n+  dw_die_ref scope_die = 0;\n+  int nested = 0;\n   int complete = (TYPE_SIZE (type)\n \t\t  && (! TYPE_STUB_DECL (type)\n \t\t      || ! TYPE_DECL_SUPPRESS_DEBUG (TYPE_STUB_DECL (type))));\n@@ -10515,7 +10514,7 @@ gen_struct_or_union_type_die (type, context_die)\n   if (! type_die || (nested && scope_die == comp_unit_die))\n     /* First occurrence of type or toplevel definition of nested class.  */\n     {\n-      register dw_die_ref old_die = type_die;\n+      dw_die_ref old_die = type_die;\n \n       type_die = new_die (TREE_CODE (type) == RECORD_TYPE\n \t\t\t  ? DW_TAG_structure_type : DW_TAG_union_type,\n@@ -10573,11 +10572,11 @@ gen_struct_or_union_type_die (type, context_die)\n \n static void\n gen_subroutine_type_die (type, context_die)\n-     register tree type;\n-     register dw_die_ref context_die;\n+     tree type;\n+     dw_die_ref context_die;\n {\n-  register tree return_type = TREE_TYPE (type);\n-  register dw_die_ref subr_die\n+  tree return_type = TREE_TYPE (type);\n+  dw_die_ref subr_die\n     = new_die (DW_TAG_subroutine_type, scope_die_for (type, context_die));\n \n   equate_type_number_to_die (type, subr_die);\n@@ -10590,11 +10589,11 @@ gen_subroutine_type_die (type, context_die)\n \n static void\n gen_typedef_die (decl, context_die)\n-     register tree decl;\n-     register dw_die_ref context_die;\n+     tree decl;\n+     dw_die_ref context_die;\n {\n-  register dw_die_ref type_die;\n-  register tree origin;\n+  dw_die_ref type_die;\n+  tree origin;\n \n   if (TREE_ASM_WRITTEN (decl))\n     return;\n@@ -10606,7 +10605,7 @@ gen_typedef_die (decl, context_die)\n     add_abstract_origin_attribute (type_die, origin);\n   else\n     {\n-      register tree type;\n+      tree type;\n       add_name_and_src_coords_attributes (type_die, decl);\n       if (DECL_ORIGINAL_TYPE (decl))\n \t{\n@@ -10631,8 +10630,8 @@ gen_typedef_die (decl, context_die)\n \n static void\n gen_type_die (type, context_die)\n-     register tree type;\n-     register dw_die_ref context_die;\n+     tree type;\n+     dw_die_ref context_die;\n {\n   int need_pop;\n \n@@ -10788,8 +10787,8 @@ gen_type_die (type, context_die)\n \n static void\n gen_tagged_type_instantiation_die (type, context_die)\n-     register tree type;\n-     register dw_die_ref context_die;\n+     tree type;\n+     dw_die_ref context_die;\n {\n   if (type == NULL_TREE || type == error_mark_node)\n     return;\n@@ -10832,14 +10831,14 @@ gen_tagged_type_instantiation_die (type, context_die)\n \n static void\n gen_block_die (stmt, context_die, depth)\n-     register tree stmt;\n-     register dw_die_ref context_die;\n+     tree stmt;\n+     dw_die_ref context_die;\n      int depth;\n {\n-  register int must_output_die = 0;\n-  register tree origin;\n-  register tree decl;\n-  register enum tree_code origin_code;\n+  int must_output_die = 0;\n+  tree origin;\n+  tree decl;\n+  enum tree_code origin_code;\n \n   /* Ignore blocks never really used to make RTL.  */\n   if (stmt == NULL_TREE || !TREE_USED (stmt)\n@@ -10927,12 +10926,12 @@ gen_block_die (stmt, context_die, depth)\n \n static void\n decls_for_scope (stmt, context_die, depth)\n-     register tree stmt;\n-     register dw_die_ref context_die;\n+     tree stmt;\n+     dw_die_ref context_die;\n      int depth;\n {\n-  register tree decl;\n-  register tree subblocks;\n+  tree decl;\n+  tree subblocks;\n \n   /* Ignore blocks never really used to make RTL.  */\n   if (stmt == NULL_TREE || ! TREE_USED (stmt))\n@@ -10945,7 +10944,7 @@ decls_for_scope (stmt, context_die, depth)\n   for (decl = BLOCK_VARS (stmt);\n        decl != NULL; decl = TREE_CHAIN (decl))\n     {\n-      register dw_die_ref die;\n+      dw_die_ref die;\n \n       if (TREE_CODE (decl) == FUNCTION_DECL)\n \tdie = lookup_decl_die (decl);\n@@ -10972,7 +10971,7 @@ decls_for_scope (stmt, context_die, depth)\n \n static inline int\n is_redundant_typedef (decl)\n-     register tree decl;\n+     tree decl;\n {\n   if (TYPE_DECL_IS_STUB (decl))\n     return 1;\n@@ -10992,10 +10991,10 @@ is_redundant_typedef (decl)\n \n static void\n gen_decl_die (decl, context_die)\n-     register tree decl;\n-     register dw_die_ref context_die;\n+     tree decl;\n+     dw_die_ref context_die;\n {\n-  register tree origin;\n+  tree origin;\n \n   if (TREE_CODE (decl) == ERROR_MARK)\n     return;\n@@ -11179,9 +11178,9 @@ dwarf2out_global_decl (decl)\n \n void\n dwarf2out_decl (decl)\n-     register tree decl;\n+     tree decl;\n {\n-  register dw_die_ref context_die = comp_unit_die;\n+  dw_die_ref context_die = comp_unit_die;\n \n   if (TREE_CODE (decl) == ERROR_MARK)\n     return;\n@@ -11348,7 +11347,7 @@ static unsigned\n lookup_filename (file_name)\n      const char *file_name;\n {\n-  register unsigned i;\n+  unsigned i;\n \n   /* ??? Why isn't DECL_SOURCE_FILE left null instead.  */\n   if (strcmp (file_name, \"<internal>\") == 0\n@@ -11408,7 +11407,7 @@ init_file_table ()\n static void\n dwarf2out_source_line (line, filename)\n      unsigned int line;\n-     register const char *filename;\n+     const char *filename;\n {\n   if (debug_info_level >= DINFO_LEVEL_NORMAL)\n     {\n@@ -11435,7 +11434,7 @@ dwarf2out_source_line (line, filename)\n \t}\n       else if (DECL_SECTION_NAME (current_function_decl))\n \t{\n-\t  register dw_separate_line_info_ref line_info;\n+\t  dw_separate_line_info_ref line_info;\n \t  ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, SEPARATE_LINE_CODE_LABEL,\n \t\t\t\t     separate_line_info_table_in_use);\n \n@@ -11460,7 +11459,7 @@ dwarf2out_source_line (line, filename)\n \t}\n       else\n \t{\n-\t  register dw_line_info_ref line_info;\n+\t  dw_line_info_ref line_info;\n \n \t  ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, LINE_CODE_LABEL,\n \t\t\t\t     line_info_table_in_use);\n@@ -11488,8 +11487,8 @@ dwarf2out_source_line (line, filename)\n \n static void\n dwarf2out_start_source_file (lineno, filename)\n-     register unsigned int lineno;\n-     register const char *filename;\n+     unsigned int lineno;\n+     const char *filename;\n {\n   if (flag_eliminate_dwarf2_dups)\n     {\n@@ -11532,8 +11531,8 @@ dwarf2out_end_source_file (lineno)\n \n static void\n dwarf2out_define (lineno, buffer)\n-     register unsigned lineno ATTRIBUTE_UNUSED;\n-     register const char *buffer ATTRIBUTE_UNUSED;\n+     unsigned lineno ATTRIBUTE_UNUSED;\n+     const char *buffer ATTRIBUTE_UNUSED;\n {\n   static int initialized = 0;\n   if (!initialized)\n@@ -11556,8 +11555,8 @@ dwarf2out_define (lineno, buffer)\n \n static void\n dwarf2out_undef (lineno, buffer)\n-     register unsigned lineno ATTRIBUTE_UNUSED;\n-     register const char *buffer ATTRIBUTE_UNUSED;\n+     unsigned lineno ATTRIBUTE_UNUSED;\n+     const char *buffer ATTRIBUTE_UNUSED;\n {\n   if (debug_info_level >= DINFO_LEVEL_VERBOSE)\n     {\n@@ -11572,7 +11571,7 @@ dwarf2out_undef (lineno, buffer)\n \n static void\n dwarf2out_init (main_input_filename)\n-     register const char *main_input_filename;\n+     const char *main_input_filename;\n {\n   init_file_table ();\n \n@@ -11660,7 +11659,7 @@ dwarf2out_init (main_input_filename)\n \n static void\n dwarf2out_finish (input_filename)\n-     register const char *input_filename ATTRIBUTE_UNUSED;\n+     const char *input_filename ATTRIBUTE_UNUSED;\n {\n   limbo_die_node *node, *next_node;\n   dw_die_ref die = 0;"}, {"sha": "f5f2e3d6d6c608ee4fd95bdce2687c92311f5ca2", "filename": "gcc/dwarfout.c", "status": "modified", "additions": 239, "deletions": 239, "changes": 478, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Fdwarfout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Fdwarfout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarfout.c?ref=b36948478c22c58018d0a888ee8ca393dea60dc9", "patch": "@@ -1393,7 +1393,7 @@ struct gcc_debug_hooks dwarf_debug_hooks =\n \n static inline int\n is_pseudo_reg (rtl)\n-     register rtx rtl;\n+     rtx rtl;\n {\n   return (((GET_CODE (rtl) == REG) && (REGNO (rtl) >= FIRST_PSEUDO_REGISTER))\n           || ((GET_CODE (rtl) == SUBREG)\n@@ -1402,7 +1402,7 @@ is_pseudo_reg (rtl)\n \n static inline tree\n type_main_variant (type)\n-     register tree type;\n+     tree type;\n {\n   type = TYPE_MAIN_VARIANT (type);\n \n@@ -1424,17 +1424,17 @@ type_main_variant (type)\n \n static inline int\n is_tagged_type (type)\n-     register tree type;\n+     tree type;\n {\n-  register enum tree_code code = TREE_CODE (type);\n+  enum tree_code code = TREE_CODE (type);\n \n   return (code == RECORD_TYPE || code == UNION_TYPE\n \t  || code == QUAL_UNION_TYPE || code == ENUMERAL_TYPE);\n }\n \n static const char *\n dwarf_tag_name (tag)\n-     register unsigned tag;\n+     unsigned tag;\n {\n   switch (tag)\n     {\n@@ -1484,7 +1484,7 @@ dwarf_tag_name (tag)\n \n static const char *\n dwarf_attr_name (attr)\n-     register unsigned attr;\n+     unsigned attr;\n {\n   switch (attr)\n     {\n@@ -1562,7 +1562,7 @@ dwarf_attr_name (attr)\n \n static const char *\n dwarf_stack_op_name (op)\n-     register unsigned op;\n+     unsigned op;\n {\n   switch (op)\n     {\n@@ -1579,7 +1579,7 @@ dwarf_stack_op_name (op)\n \n static const char *\n dwarf_typemod_name (mod)\n-     register unsigned mod;\n+     unsigned mod;\n {\n   switch (mod)\n     {\n@@ -1593,7 +1593,7 @@ dwarf_typemod_name (mod)\n \n static const char *\n dwarf_fmt_byte_name (fmt)\n-     register unsigned fmt;\n+     unsigned fmt;\n {\n   switch (fmt)\n     {\n@@ -1612,7 +1612,7 @@ dwarf_fmt_byte_name (fmt)\n \n static const char *\n dwarf_fund_type_name (ft)\n-     register unsigned ft;\n+     unsigned ft;\n {\n   switch (ft)\n     {\n@@ -1678,7 +1678,7 @@ dwarf_fund_type_name (ft)\n \n static tree\n decl_ultimate_origin (decl)\n-     register tree decl;\n+     tree decl;\n {\n #ifdef ENABLE_CHECKING \n   if (DECL_FROM_INLINE (DECL_ORIGIN (decl)))\n@@ -1698,16 +1698,16 @@ decl_ultimate_origin (decl)\n \n static tree\n block_ultimate_origin (block)\n-     register tree block;\n+     tree block;\n {\n-  register tree immediate_origin = BLOCK_ABSTRACT_ORIGIN (block);\n+  tree immediate_origin = BLOCK_ABSTRACT_ORIGIN (block);\n \n   if (immediate_origin == NULL)\n     return NULL;\n   else\n     {\n-      register tree ret_val;\n-      register tree lookahead = immediate_origin;\n+      tree ret_val;\n+      tree lookahead = immediate_origin;\n \n       do\n \t{\n@@ -1745,13 +1745,13 @@ decl_class_context (decl)\n #if 0\n static void\n output_unsigned_leb128 (value)\n-     register unsigned long value;\n+     unsigned long value;\n {\n-  register unsigned long orig_value = value;\n+  unsigned long orig_value = value;\n \n   do\n     {\n-      register unsigned byte = (value & 0x7f);\n+      unsigned byte = (value & 0x7f);\n \n       value >>= 7;\n       if (value != 0)\t/* more bytes to follow */\n@@ -1767,15 +1767,15 @@ output_unsigned_leb128 (value)\n \n static void\n output_signed_leb128 (value)\n-     register long value;\n+     long value;\n {\n-  register long orig_value = value;\n-  register int negative = (value < 0);\n-  register int more;\n+  long orig_value = value;\n+  int negative = (value < 0);\n+  int more;\n \n   do\n     {\n-      register unsigned byte = (value & 0x7f);\n+      unsigned byte = (value & 0x7f);\n \n       value >>= 7;\n       if (negative)\n@@ -1826,7 +1826,7 @@ output_signed_leb128 (value)\n \n static int\n fundamental_type_code (type)\n-     register tree type;\n+     tree type;\n {\n   if (TREE_CODE (type) == ERROR_MARK)\n     return 0;\n@@ -1968,8 +1968,8 @@ fundamental_type_code (type)\n \n static tree\n root_type_1 (type, count)\n-     register tree type;\n-     register int count;\n+     tree type;\n+     int count;\n {\n   /* Give up after searching 1000 levels, in case this is a recursive\n      pointer type.  Such types are possible in Ada, but it is not possible\n@@ -1993,7 +1993,7 @@ root_type_1 (type, count)\n \n static tree\n root_type (type)\n-     register tree type;\n+     tree type;\n {\n   type = root_type_1 (type, 0);\n   if (type != error_mark_node)\n@@ -2006,10 +2006,10 @@ root_type (type)\n \n static void\n write_modifier_bytes_1 (type, decl_const, decl_volatile, count)\n-     register tree type;\n-     register int decl_const;\n-     register int decl_volatile;\n-     register int count;\n+     tree type;\n+     int decl_const;\n+     int decl_volatile;\n+     int count;\n {\n   if (TREE_CODE (type) == ERROR_MARK)\n     return;\n@@ -2044,9 +2044,9 @@ write_modifier_bytes_1 (type, decl_const, decl_volatile, count)\n \n static void\n write_modifier_bytes (type, decl_const, decl_volatile)\n-     register tree type;\n-     register int decl_const;\n-     register int decl_volatile;\n+     tree type;\n+     int decl_const;\n+     int decl_volatile;\n {\n   write_modifier_bytes_1 (type, decl_const, decl_volatile, 0);\n }\n@@ -2056,7 +2056,7 @@ write_modifier_bytes (type, decl_const, decl_volatile)\n \n static inline int\n type_is_fundamental (type)\n-     register tree type;\n+     tree type;\n {\n   switch (TREE_CODE (type))\n     {\n@@ -2106,7 +2106,7 @@ type_is_fundamental (type)\n \n static void\n equate_decl_number_to_die_number (decl)\n-     register tree decl;\n+     tree decl;\n {\n   /* In the case where we are generating a DIE for some ..._DECL node\n      which represents either some inline function declaration or some\n@@ -2138,7 +2138,7 @@ equate_decl_number_to_die_number (decl)\n \n static inline void\n equate_type_number_to_die_number (type)\n-     register tree type;\n+     tree type;\n {\n   char type_label[MAX_ARTIFICIAL_LABEL_BYTES];\n   char die_label[MAX_ARTIFICIAL_LABEL_BYTES];\n@@ -2157,9 +2157,9 @@ equate_type_number_to_die_number (type)\n \n static void\n output_reg_number (rtl)\n-     register rtx rtl;\n+     rtx rtl;\n {\n-  register unsigned regno = REGNO (rtl);\n+  unsigned regno = REGNO (rtl);\n \n   if (regno >= DWARF_FRAME_REGISTERS)\n     {\n@@ -2189,7 +2189,7 @@ output_reg_number (rtl)\n \n static void\n output_mem_loc_descriptor (rtl)\n-      register rtx rtl;\n+     rtx rtl;\n {\n   /* Note that for a dynamically sized array, the location we will\n      generate a description of here will be the lowest numbered location\n@@ -2282,7 +2282,7 @@ output_mem_loc_descriptor (rtl)\n \n static void\n output_loc_descriptor (rtl)\n-     register rtx rtl;\n+     rtx rtl;\n {\n   switch (GET_CODE (rtl))\n     {\n@@ -2316,9 +2316,9 @@ output_loc_descriptor (rtl)\n \n static void\n output_bound_representation (bound, dim_num, u_or_l)\n-     register tree bound;\n-     register unsigned dim_num; /* For multi-dimensional arrays.  */\n-     register char u_or_l;\t/* Designates upper or lower bound.  */\n+     tree bound;\n+     unsigned dim_num; /* For multi-dimensional arrays.  */\n+     char u_or_l;\t/* Designates upper or lower bound.  */\n {\n   switch (TREE_CODE (bound))\n     {\n@@ -2399,7 +2399,7 @@ output_bound_representation (bound, dim_num, u_or_l)\n \n static void\n output_enumeral_list (link)\n-     register tree link;\n+     tree link;\n {\n   if (link)\n     {\n@@ -2419,8 +2419,8 @@ output_enumeral_list (link)\n \n static inline HOST_WIDE_INT\n ceiling (value, boundary)\n-     register HOST_WIDE_INT value;\n-     register unsigned int boundary;\n+     HOST_WIDE_INT value;\n+     unsigned int boundary;\n {\n   return (((value + boundary - 1) / boundary) * boundary);\n }\n@@ -2431,9 +2431,9 @@ ceiling (value, boundary)\n \n static inline tree\n field_type (decl)\n-     register tree decl;\n+     tree decl;\n {\n-  register tree type;\n+  tree type;\n \n   if (TREE_CODE (decl) == ERROR_MARK)\n     return integer_type_node;\n@@ -2450,7 +2450,7 @@ field_type (decl)\n \n static inline unsigned int\n simple_type_align_in_bits (type)\n-     register tree type;\n+     tree type;\n {\n   return (TREE_CODE (type) != ERROR_MARK) ? TYPE_ALIGN (type) : BITS_PER_WORD;\n }\n@@ -2463,7 +2463,7 @@ simple_type_align_in_bits (type)\n \n static inline unsigned HOST_WIDE_INT\n simple_type_size_in_bits (type)\n-     register tree type;\n+     tree type;\n {\n   tree type_size_tree;\n \n@@ -2487,7 +2487,7 @@ simple_type_size_in_bits (type)\n \n static HOST_WIDE_INT\n field_byte_offset (decl)\n-     register tree decl;\n+     tree decl;\n {\n   unsigned int type_align_in_bytes;\n   unsigned int type_align_in_bits;\n@@ -2647,7 +2647,7 @@ sibling_attribute ()\n \n static void\n location_attribute (rtl)\n-     register rtx rtl;\n+     rtx rtl;\n {\n   char begin_label[MAX_ARTIFICIAL_LABEL_BYTES];\n   char end_label[MAX_ARTIFICIAL_LABEL_BYTES];\n@@ -2710,9 +2710,9 @@ location_attribute (rtl)\n \n static void\n data_member_location_attribute (t)\n-     register tree t;\n+     tree t;\n {\n-  register unsigned object_offset_in_bytes;\n+  unsigned object_offset_in_bytes;\n   char begin_label[MAX_ARTIFICIAL_LABEL_BYTES];\n   char end_label[MAX_ARTIFICIAL_LABEL_BYTES];\n \n@@ -2740,7 +2740,7 @@ data_member_location_attribute (t)\n \n static void\n const_value_attribute (rtl)\n-     register rtx rtl;\n+     rtx rtl;\n {\n   char begin_label[MAX_ARTIFICIAL_LABEL_BYTES];\n   char end_label[MAX_ARTIFICIAL_LABEL_BYTES];\n@@ -2825,9 +2825,9 @@ const_value_attribute (rtl)\n \n static void\n location_or_const_value_attribute (decl)\n-     register tree decl;\n+     tree decl;\n {\n-  register rtx rtl;\n+  rtx rtl;\n \n   if (TREE_CODE (decl) == ERROR_MARK)\n     return;\n@@ -2919,8 +2919,8 @@ location_or_const_value_attribute (decl)\n     if (rtl == NULL_RTX || is_pseudo_reg (rtl))\n       {\n \t/* This decl represents a formal parameter which was optimized out.  */\n-        register tree declared_type = type_main_variant (TREE_TYPE (decl));\n-        register tree passed_type = type_main_variant (DECL_ARG_TYPE (decl));\n+        tree declared_type = type_main_variant (TREE_TYPE (decl));\n+        tree passed_type = type_main_variant (DECL_ARG_TYPE (decl));\n \n \t/* Note that DECL_INCOMING_RTL may be NULL in here, but we handle\n \t   *all* cases where (rtl == NULL_RTX) just below.  */\n@@ -2985,7 +2985,7 @@ location_or_const_value_attribute (decl)\n \n static inline void\n name_attribute (name_string)\n-     register const char *name_string;\n+     const char *name_string;\n {\n   if (name_string && *name_string)\n     {\n@@ -2996,17 +2996,17 @@ name_attribute (name_string)\n \n static inline void\n fund_type_attribute (ft_code)\n-     register unsigned ft_code;\n+     unsigned ft_code;\n {\n   ASM_OUTPUT_DWARF_ATTRIBUTE (asm_out_file, AT_fund_type);\n   ASM_OUTPUT_DWARF_FUND_TYPE (asm_out_file, ft_code);\n }\n \n static void\n mod_fund_type_attribute (type, decl_const, decl_volatile)\n-     register tree type;\n-     register int decl_const;\n-     register int decl_volatile;\n+     tree type;\n+     int decl_const;\n+     int decl_volatile;\n {\n   char begin_label[MAX_ARTIFICIAL_LABEL_BYTES];\n   char end_label[MAX_ARTIFICIAL_LABEL_BYTES];\n@@ -3024,7 +3024,7 @@ mod_fund_type_attribute (type, decl_const, decl_volatile)\n \n static inline void\n user_def_type_attribute (type)\n-     register tree type;\n+     tree type;\n {\n   char ud_type_name[MAX_ARTIFICIAL_LABEL_BYTES];\n \n@@ -3035,9 +3035,9 @@ user_def_type_attribute (type)\n \n static void\n mod_u_d_type_attribute (type, decl_const, decl_volatile)\n-     register tree type;\n-     register int decl_const;\n-     register int decl_volatile;\n+     tree type;\n+     int decl_const;\n+     int decl_volatile;\n {\n   char begin_label[MAX_ARTIFICIAL_LABEL_BYTES];\n   char end_label[MAX_ARTIFICIAL_LABEL_BYTES];\n@@ -3057,7 +3057,7 @@ mod_u_d_type_attribute (type, decl_const, decl_volatile)\n #ifdef USE_ORDERING_ATTRIBUTE\n static inline void\n ordering_attribute (ordering)\n-     register unsigned ordering;\n+     unsigned ordering;\n {\n   ASM_OUTPUT_DWARF_ATTRIBUTE (asm_out_file, AT_ordering);\n   ASM_OUTPUT_DWARF_DATA2 (asm_out_file, ordering);\n@@ -3069,9 +3069,9 @@ ordering_attribute (ordering)\n \n static void\n subscript_data_attribute (type)\n-     register tree type;\n+     tree type;\n {\n-  register unsigned dimension_number;\n+  unsigned dimension_number;\n   char begin_label[MAX_ARTIFICIAL_LABEL_BYTES];\n   char end_label[MAX_ARTIFICIAL_LABEL_BYTES];\n \n@@ -3094,7 +3094,7 @@ subscript_data_attribute (type)\n \tTREE_CODE (type) == ARRAY_TYPE;\n \ttype = TREE_TYPE (type), dimension_number++)\n     {\n-      register tree domain = TYPE_DOMAIN (type);\n+      tree domain = TYPE_DOMAIN (type);\n \n       /* Arrays come in three flavors.\tUnspecified bounds, fixed\n \t bounds, and (in GNU C only) variable bounds.  Handle all\n@@ -3104,8 +3104,8 @@ subscript_data_attribute (type)\n \t{\n \t  /* We have an array type with specified bounds.  */\n \n-\t  register tree lower = TYPE_MIN_VALUE (domain);\n-\t  register tree upper = TYPE_MAX_VALUE (domain);\n+\t  tree lower = TYPE_MIN_VALUE (domain);\n+\t  tree upper = TYPE_MAX_VALUE (domain);\n \n \t  /* Handle only fundamental types as index types for now.  */\n \t  if (! type_is_fundamental (domain))\n@@ -3168,9 +3168,9 @@ subscript_data_attribute (type)\n \n static void\n byte_size_attribute (tree_node)\n-     register tree tree_node;\n+     tree tree_node;\n {\n-  register unsigned size;\n+  unsigned size;\n \n   ASM_OUTPUT_DWARF_ATTRIBUTE (asm_out_file, AT_byte_size);\n   switch (TREE_CODE (tree_node))\n@@ -3228,7 +3228,7 @@ byte_size_attribute (tree_node)\n \n static inline void\n bit_offset_attribute (decl)\n-    register tree decl;\n+     tree decl;\n {\n   HOST_WIDE_INT object_offset_in_bytes = field_byte_offset (decl);\n   tree type = DECL_BIT_FIELD_TYPE (decl);\n@@ -3281,7 +3281,7 @@ bit_offset_attribute (decl)\n \n static inline void\n bit_size_attribute (decl)\n-    register tree decl;\n+    tree decl;\n {\n   /* Must be a field and a bit field.  */\n   if (TREE_CODE (decl) != FIELD_DECL\n@@ -3303,7 +3303,7 @@ bit_size_attribute (decl)\n \n static inline void\n element_list_attribute (element)\n-     register tree element;\n+     tree element;\n {\n   char begin_label[MAX_ARTIFICIAL_LABEL_BYTES];\n   char end_label[MAX_ARTIFICIAL_LABEL_BYTES];\n@@ -3329,7 +3329,7 @@ element_list_attribute (element)\n \n static inline void\n stmt_list_attribute (label)\n-    register const char *label;\n+    const char *label;\n {\n   ASM_OUTPUT_DWARF_ATTRIBUTE (asm_out_file, AT_stmt_list);\n   /* Don't use ASM_OUTPUT_DWARF_DATA4 here.  */\n@@ -3341,7 +3341,7 @@ stmt_list_attribute (label)\n \n static inline void\n low_pc_attribute (asm_low_label)\n-     register const char *asm_low_label;\n+     const char *asm_low_label;\n {\n   ASM_OUTPUT_DWARF_ATTRIBUTE (asm_out_file, AT_low_pc);\n   ASM_OUTPUT_DWARF_ADDR (asm_out_file, asm_low_label);\n@@ -3352,7 +3352,7 @@ low_pc_attribute (asm_low_label)\n \n static inline void\n high_pc_attribute (asm_high_label)\n-    register const char *asm_high_label;\n+     const char *asm_high_label;\n {\n   ASM_OUTPUT_DWARF_ATTRIBUTE (asm_out_file, AT_high_pc);\n   ASM_OUTPUT_DWARF_ADDR (asm_out_file, asm_high_label);\n@@ -3362,7 +3362,7 @@ high_pc_attribute (asm_high_label)\n \n static inline void\n body_begin_attribute (asm_begin_label)\n-     register const char *asm_begin_label;\n+     const char *asm_begin_label;\n {\n   ASM_OUTPUT_DWARF_ATTRIBUTE (asm_out_file, AT_body_begin);\n   ASM_OUTPUT_DWARF_ADDR (asm_out_file, asm_begin_label);\n@@ -3372,7 +3372,7 @@ body_begin_attribute (asm_begin_label)\n \n static inline void\n body_end_attribute (asm_end_label)\n-     register const char *asm_end_label;\n+     const char *asm_end_label;\n {\n   ASM_OUTPUT_DWARF_ATTRIBUTE (asm_out_file, AT_body_end);\n   ASM_OUTPUT_DWARF_ADDR (asm_out_file, asm_end_label);\n@@ -3383,15 +3383,15 @@ body_end_attribute (asm_end_label)\n \n static inline void\n language_attribute (language_code)\n-     register unsigned language_code;\n+     unsigned language_code;\n {\n   ASM_OUTPUT_DWARF_ATTRIBUTE (asm_out_file, AT_language);\n   ASM_OUTPUT_DWARF_DATA4 (asm_out_file, language_code);\n }\n \n static inline void\n member_attribute (context)\n-    register tree context;\n+     tree context;\n {\n   char label[MAX_ARTIFICIAL_LABEL_BYTES];\n \n@@ -3408,7 +3408,7 @@ member_attribute (context)\n #if 0\n static inline void\n string_length_attribute (upper_bound)\n-     register tree upper_bound;\n+     tree upper_bound;\n {\n   char begin_label[MAX_ARTIFICIAL_LABEL_BYTES];\n   char end_label[MAX_ARTIFICIAL_LABEL_BYTES];\n@@ -3425,15 +3425,15 @@ string_length_attribute (upper_bound)\n \n static inline void\n comp_dir_attribute (dirname)\n-     register const char *dirname;\n+     const char *dirname;\n {\n   ASM_OUTPUT_DWARF_ATTRIBUTE (asm_out_file, AT_comp_dir);\n   ASM_OUTPUT_DWARF_STRING_NEWLINE (asm_out_file, dirname);\n }\n \n static inline void\n sf_names_attribute (sf_names_start_label)\n-     register const char *sf_names_start_label;\n+     const char *sf_names_start_label;\n {\n   ASM_OUTPUT_DWARF_ATTRIBUTE (asm_out_file, AT_sf_names);\n   /* Don't use ASM_OUTPUT_DWARF_DATA4 here.  */\n@@ -3442,7 +3442,7 @@ sf_names_attribute (sf_names_start_label)\n \n static inline void\n src_info_attribute (src_info_start_label)\n-     register const char *src_info_start_label;\n+     const char *src_info_start_label;\n {\n   ASM_OUTPUT_DWARF_ATTRIBUTE (asm_out_file, AT_src_info);\n   /* Don't use ASM_OUTPUT_DWARF_DATA4 here.  */\n@@ -3451,7 +3451,7 @@ src_info_attribute (src_info_start_label)\n \n static inline void\n mac_info_attribute (mac_info_start_label)\n-     register const char *mac_info_start_label;\n+     const char *mac_info_start_label;\n {\n   ASM_OUTPUT_DWARF_ATTRIBUTE (asm_out_file, AT_mac_info);\n   /* Don't use ASM_OUTPUT_DWARF_DATA4 here.  */\n@@ -3460,7 +3460,7 @@ mac_info_attribute (mac_info_start_label)\n \n static inline void\n prototyped_attribute (func_type)\n-     register tree func_type;\n+     tree func_type;\n {\n   if ((strcmp (language_string, \"GNU C\") == 0)\n       && (TYPE_ARG_TYPES (func_type) != NULL))\n@@ -3472,15 +3472,15 @@ prototyped_attribute (func_type)\n \n static inline void\n producer_attribute (producer)\n-     register const char *producer;\n+     const char *producer;\n {\n   ASM_OUTPUT_DWARF_ATTRIBUTE (asm_out_file, AT_producer);\n   ASM_OUTPUT_DWARF_STRING_NEWLINE (asm_out_file, producer);\n }\n \n static inline void\n inline_attribute (decl)\n-     register tree decl;\n+     tree decl;\n {\n   if (DECL_INLINE (decl))\n     {\n@@ -3491,7 +3491,7 @@ inline_attribute (decl)\n \n static inline void\n containing_type_attribute (containing_type)\n-     register tree containing_type;\n+     tree containing_type;\n {\n   char label[MAX_ARTIFICIAL_LABEL_BYTES];\n \n@@ -3502,7 +3502,7 @@ containing_type_attribute (containing_type)\n \n static inline void\n abstract_origin_attribute (origin)\n-     register tree origin;\n+     tree origin;\n {\n   char label[MAX_ARTIFICIAL_LABEL_BYTES];\n \n@@ -3527,8 +3527,8 @@ abstract_origin_attribute (origin)\n #ifdef DWARF_DECL_COORDINATES\n static inline void\n src_coords_attribute (src_fileno, src_lineno)\n-     register unsigned src_fileno;\n-     register unsigned src_lineno;\n+     unsigned src_fileno;\n+     unsigned src_lineno;\n {\n   ASM_OUTPUT_DWARF_ATTRIBUTE (asm_out_file, AT_src_coords);\n   ASM_OUTPUT_DWARF_DATA2 (asm_out_file, src_fileno);\n@@ -3538,7 +3538,7 @@ src_coords_attribute (src_fileno, src_lineno)\n \n static inline void\n pure_or_virtual_attribute (func_decl)\n-     register tree func_decl;\n+     tree func_decl;\n {\n   if (DECL_VIRTUAL_P (func_decl))\n     {\n@@ -3561,9 +3561,9 @@ pure_or_virtual_attribute (func_decl)\n \n static void\n name_and_src_coords_attributes (decl)\n-    register tree decl;\n+    tree decl;\n {\n-  register tree decl_name = DECL_NAME (decl);\n+  tree decl_name = DECL_NAME (decl);\n \n   if (decl_name && IDENTIFIER_POINTER (decl_name))\n     {\n@@ -3597,12 +3597,12 @@ name_and_src_coords_attributes (decl)\n \n static void\n type_attribute (type, decl_const, decl_volatile)\n-     register tree type;\n-     register int decl_const;\n-     register int decl_volatile;\n+     tree type;\n+     int decl_const;\n+     int decl_volatile;\n {\n-  register enum tree_code code = TREE_CODE (type);\n-  register int root_type_modified;\n+  enum tree_code code = TREE_CODE (type);\n+  int root_type_modified;\n \n   if (code == ERROR_MARK)\n     return;\n@@ -3655,13 +3655,13 @@ type_attribute (type, decl_const, decl_volatile)\n \n static const char *\n type_tag (type)\n-     register tree type;\n+     tree type;\n {\n-  register const char *name = 0;\n+  const char *name = 0;\n \n   if (TYPE_NAME (type) != 0)\n     {\n-      register tree t = 0;\n+      tree t = 0;\n \n       /* Find the IDENTIFIER_NODE for the type name.  */\n       if (TREE_CODE (TYPE_NAME (type)) == IDENTIFIER_NODE)\n@@ -3711,7 +3711,7 @@ dienum_pop ()\n \n static inline tree\n member_declared_type (member)\n-     register tree member;\n+     tree member;\n {\n   return (DECL_BIT_FIELD_TYPE (member))\n \t   ? DECL_BIT_FIELD_TYPE (member)\n@@ -3724,7 +3724,7 @@ member_declared_type (member)\n \n static const char *\n function_start_label (decl)\n-    register tree decl;\n+    tree decl;\n {\n   rtx x;\n   const char *fnname;\n@@ -3748,9 +3748,9 @@ function_start_label (decl)\n \n static void\n output_array_type_die (arg)\n-     register void *arg;\n+     void *arg;\n {\n-  register tree type = arg;\n+  tree type = arg;\n \n   ASM_OUTPUT_DWARF_TAG (asm_out_file, TAG_array_type);\n   sibling_attribute ();\n@@ -3775,9 +3775,9 @@ output_array_type_die (arg)\n \n static void\n output_set_type_die (arg)\n-     register void *arg;\n+     void *arg;\n {\n-  register tree type = arg;\n+  tree type = arg;\n \n   ASM_OUTPUT_DWARF_TAG (asm_out_file, TAG_set_type);\n   sibling_attribute ();\n@@ -3791,10 +3791,10 @@ output_set_type_die (arg)\n \n static void\n output_entry_point_die (arg)\n-     register void *arg;\n+     void *arg;\n {\n-  register tree decl = arg;\n-  register tree origin = decl_ultimate_origin (decl);\n+  tree decl = arg;\n+  tree origin = decl_ultimate_origin (decl);\n \n   ASM_OUTPUT_DWARF_TAG (asm_out_file, TAG_entry_point);\n   sibling_attribute ();\n@@ -3818,9 +3818,9 @@ output_entry_point_die (arg)\n \n static void\n output_inlined_enumeration_type_die (arg)\n-     register void *arg;\n+     void *arg;\n {\n-  register tree type = arg;\n+  tree type = arg;\n \n   ASM_OUTPUT_DWARF_TAG (asm_out_file, TAG_enumeration_type);\n   sibling_attribute ();\n@@ -3833,9 +3833,9 @@ output_inlined_enumeration_type_die (arg)\n \n static void\n output_inlined_structure_type_die (arg)\n-     register void *arg;\n+     void *arg;\n {\n-  register tree type = arg;\n+  tree type = arg;\n \n   ASM_OUTPUT_DWARF_TAG (asm_out_file, TAG_structure_type);\n   sibling_attribute ();\n@@ -3848,9 +3848,9 @@ output_inlined_structure_type_die (arg)\n \n static void\n output_inlined_union_type_die (arg)\n-     register void *arg;\n+     void *arg;\n {\n-  register tree type = arg;\n+  tree type = arg;\n \n   ASM_OUTPUT_DWARF_TAG (asm_out_file, TAG_union_type);\n   sibling_attribute ();\n@@ -3865,9 +3865,9 @@ output_inlined_union_type_die (arg)\n \n static void\n output_enumeration_type_die (arg)\n-     register void *arg;\n+     void *arg;\n {\n-  register tree type = arg;\n+  tree type = arg;\n \n   ASM_OUTPUT_DWARF_TAG (asm_out_file, TAG_enumeration_type);\n   sibling_attribute ();\n@@ -3901,9 +3901,9 @@ output_enumeration_type_die (arg)\n \n static void\n output_formal_parameter_die (arg)\n-     register void *arg;\n+     void *arg;\n {\n-  register tree node = arg;\n+  tree node = arg;\n \n   ASM_OUTPUT_DWARF_TAG (asm_out_file, TAG_formal_parameter);\n   sibling_attribute ();\n@@ -3943,10 +3943,10 @@ output_formal_parameter_die (arg)\n \n static void\n output_global_subroutine_die (arg)\n-     register void *arg;\n+     void *arg;\n {\n-  register tree decl = arg;\n-  register tree origin = decl_ultimate_origin (decl);\n+  tree decl = arg;\n+  tree origin = decl_ultimate_origin (decl);\n \n   ASM_OUTPUT_DWARF_TAG (asm_out_file, TAG_global_subroutine);\n   sibling_attribute ();\n@@ -3955,7 +3955,7 @@ output_global_subroutine_die (arg)\n     abstract_origin_attribute (origin);\n   else\n     {\n-      register tree type = TREE_TYPE (decl);\n+      tree type = TREE_TYPE (decl);\n \n       name_and_src_coords_attributes (decl);\n       inline_attribute (decl);\n@@ -3992,10 +3992,10 @@ output_global_subroutine_die (arg)\n \n static void\n output_global_variable_die (arg)\n-     register void *arg;\n+     void *arg;\n {\n-  register tree decl = arg;\n-  register tree origin = decl_ultimate_origin (decl);\n+  tree decl = arg;\n+  tree origin = decl_ultimate_origin (decl);\n \n   ASM_OUTPUT_DWARF_TAG (asm_out_file, TAG_global_variable);\n   sibling_attribute ();\n@@ -4020,10 +4020,10 @@ output_global_variable_die (arg)\n \n static void\n output_label_die (arg)\n-     register void *arg;\n+     void *arg;\n {\n-  register tree decl = arg;\n-  register tree origin = decl_ultimate_origin (decl);\n+  tree decl = arg;\n+  tree origin = decl_ultimate_origin (decl);\n \n   ASM_OUTPUT_DWARF_TAG (asm_out_file, TAG_label);\n   sibling_attribute ();\n@@ -4035,7 +4035,7 @@ output_label_die (arg)\n     equate_decl_number_to_die_number (decl);\n   else\n     {\n-      register rtx insn = DECL_RTL (decl);\n+      rtx insn = DECL_RTL (decl);\n \n       /* Deleted labels are programmer specified labels which have been\n \t eliminated because of various optimisations.  We still emit them\n@@ -4063,9 +4063,9 @@ output_label_die (arg)\n \n static void\n output_lexical_block_die (arg)\n-     register void *arg;\n+     void *arg;\n {\n-  register tree stmt = arg;\n+  tree stmt = arg;\n \n   ASM_OUTPUT_DWARF_TAG (asm_out_file, TAG_lexical_block);\n   sibling_attribute ();\n@@ -4084,9 +4084,9 @@ output_lexical_block_die (arg)\n \n static void\n output_inlined_subroutine_die (arg)\n-     register void *arg;\n+     void *arg;\n {\n-  register tree stmt = arg;\n+  tree stmt = arg;\n \n   ASM_OUTPUT_DWARF_TAG (asm_out_file, TAG_inlined_subroutine);\n   sibling_attribute ();\n@@ -4109,10 +4109,10 @@ output_inlined_subroutine_die (arg)\n \n static void\n output_local_variable_die (arg)\n-     register void *arg;\n+     void *arg;\n {\n-  register tree decl = arg;\n-  register tree origin = decl_ultimate_origin (decl);\n+  tree decl = arg;\n+  tree origin = decl_ultimate_origin (decl);\n \n   ASM_OUTPUT_DWARF_TAG (asm_out_file, TAG_local_variable);\n   sibling_attribute ();\n@@ -4133,9 +4133,9 @@ output_local_variable_die (arg)\n \n static void\n output_member_die (arg)\n-     register void *arg;\n+     void *arg;\n {\n-  register tree decl = arg;\n+  tree decl = arg;\n \n   ASM_OUTPUT_DWARF_TAG (asm_out_file, TAG_member);\n   sibling_attribute ();\n@@ -4162,9 +4162,9 @@ output_member_die (arg)\n \n static void\n output_pointer_type_die (arg)\n-     register void *arg;\n+     void *arg;\n {\n-  register tree type = arg;\n+  tree type = arg;\n \n   ASM_OUTPUT_DWARF_TAG (asm_out_file, TAG_pointer_type);\n   sibling_attribute ();\n@@ -4175,9 +4175,9 @@ output_pointer_type_die (arg)\n \n static void\n output_reference_type_die (arg)\n-     register void *arg;\n+     void *arg;\n {\n-  register tree type = arg;\n+  tree type = arg;\n \n   ASM_OUTPUT_DWARF_TAG (asm_out_file, TAG_reference_type);\n   sibling_attribute ();\n@@ -4189,9 +4189,9 @@ output_reference_type_die (arg)\n \n static void\n output_ptr_to_mbr_type_die (arg)\n-     register void *arg;\n+     void *arg;\n {\n-  register tree type = arg;\n+  tree type = arg;\n \n   ASM_OUTPUT_DWARF_TAG (asm_out_file, TAG_ptr_to_member_type);\n   sibling_attribute ();\n@@ -4203,9 +4203,9 @@ output_ptr_to_mbr_type_die (arg)\n \n static void\n output_compile_unit_die (arg)\n-     register void *arg;\n+     void *arg;\n {\n-  register const char *main_input_filename = arg;\n+  const char *main_input_filename = arg;\n \n   ASM_OUTPUT_DWARF_TAG (asm_out_file, TAG_compile_unit);\n   sibling_attribute ();\n@@ -4256,9 +4256,9 @@ output_compile_unit_die (arg)\n \n static void\n output_string_type_die (arg)\n-     register void *arg;\n+     void *arg;\n {\n-  register tree type = arg;\n+  tree type = arg;\n \n   ASM_OUTPUT_DWARF_TAG (asm_out_file, TAG_string_type);\n   sibling_attribute ();\n@@ -4270,9 +4270,9 @@ output_string_type_die (arg)\n \n static void\n output_inheritance_die (arg)\n-     register void *arg;\n+     void *arg;\n {\n-  register tree binfo = arg;\n+  tree binfo = arg;\n \n   ASM_OUTPUT_DWARF_TAG (asm_out_file, TAG_inheritance);\n   sibling_attribute ();\n@@ -4297,9 +4297,9 @@ output_inheritance_die (arg)\n \n static void\n output_structure_type_die (arg)\n-     register void *arg;\n+     void *arg;\n {\n-  register tree type = arg;\n+  tree type = arg;\n \n   ASM_OUTPUT_DWARF_TAG (asm_out_file, TAG_structure_type);\n   sibling_attribute ();\n@@ -4325,10 +4325,10 @@ output_structure_type_die (arg)\n \n static void\n output_local_subroutine_die (arg)\n-     register void *arg;\n+     void *arg;\n {\n-  register tree decl = arg;\n-  register tree origin = decl_ultimate_origin (decl);\n+  tree decl = arg;\n+  tree origin = decl_ultimate_origin (decl);\n \n   ASM_OUTPUT_DWARF_TAG (asm_out_file, TAG_subroutine);\n   sibling_attribute ();\n@@ -4337,7 +4337,7 @@ output_local_subroutine_die (arg)\n     abstract_origin_attribute (origin);\n   else\n     {\n-      register tree type = TREE_TYPE (decl);\n+      tree type = TREE_TYPE (decl);\n \n       name_and_src_coords_attributes (decl);\n       inline_attribute (decl);\n@@ -4372,10 +4372,10 @@ output_local_subroutine_die (arg)\n \n static void\n output_subroutine_type_die (arg)\n-     register void *arg;\n+     void *arg;\n {\n-  register tree type = arg;\n-  register tree return_type = TREE_TYPE (type);\n+  tree type = arg;\n+  tree return_type = TREE_TYPE (type);\n \n   ASM_OUTPUT_DWARF_TAG (asm_out_file, TAG_subroutine_type);\n   sibling_attribute ();\n@@ -4388,10 +4388,10 @@ output_subroutine_type_die (arg)\n \n static void\n output_typedef_die (arg)\n-     register void *arg;\n+     void *arg;\n {\n-  register tree decl = arg;\n-  register tree origin = decl_ultimate_origin (decl);\n+  tree decl = arg;\n+  tree origin = decl_ultimate_origin (decl);\n \n   ASM_OUTPUT_DWARF_TAG (asm_out_file, TAG_typedef);\n   sibling_attribute ();\n@@ -4410,9 +4410,9 @@ output_typedef_die (arg)\n \n static void\n output_union_type_die (arg)\n-     register void *arg;\n+     void *arg;\n {\n-  register tree type = arg;\n+  tree type = arg;\n \n   ASM_OUTPUT_DWARF_TAG (asm_out_file, TAG_union_type);\n   sibling_attribute ();\n@@ -4438,9 +4438,9 @@ output_union_type_die (arg)\n \n static void\n output_unspecified_parameters_die (arg)\n-     register void *arg;\n+     void *arg;\n {\n-  register tree decl_or_type = arg;\n+  tree decl_or_type = arg;\n \n   ASM_OUTPUT_DWARF_TAG (asm_out_file, TAG_unspecified_parameters);\n   sibling_attribute ();\n@@ -4464,7 +4464,7 @@ output_unspecified_parameters_die (arg)\n \n static void\n output_padded_null_die (arg)\n-     register void *arg ATTRIBUTE_UNUSED;\n+     void *arg ATTRIBUTE_UNUSED;\n {\n   ASM_OUTPUT_ALIGN (asm_out_file, 2);\t/* 2**2 == 4 */\n }\n@@ -4479,8 +4479,8 @@ output_padded_null_die (arg)\n \n static void\n output_die (die_specific_output_function, param)\n-     register void (*die_specific_output_function) PARAMS ((void *));\n-     register void *param;\n+     void (*die_specific_output_function) PARAMS ((void *));\n+     void *param;\n {\n   char begin_label[MAX_ARTIFICIAL_LABEL_BYTES];\n   char end_label[MAX_ARTIFICIAL_LABEL_BYTES];\n@@ -4543,11 +4543,11 @@ end_sibling_chain ()\n \n static void\n output_formal_types (function_or_method_type)\n-     register tree function_or_method_type;\n+     tree function_or_method_type;\n {\n-  register tree link;\n-  register tree formal_type = NULL;\n-  register tree first_parm_type = TYPE_ARG_TYPES (function_or_method_type);\n+  tree link;\n+  tree formal_type = NULL;\n+  tree first_parm_type = TYPE_ARG_TYPES (function_or_method_type);\n \n   /* Set TREE_ASM_WRITTEN while processing the parameters, lest we\n      get bogus recursion when outputting tagged types local to a\n@@ -4608,7 +4608,7 @@ output_formal_types (function_or_method_type)\n \n static void\n pend_type (type)\n-     register tree type;\n+     tree type;\n {\n   if (pending_types == pending_types_allocated)\n     {\n@@ -4664,8 +4664,8 @@ pend_type (type)\n \n static inline int\n type_ok_for_scope (type, scope)\n-    register tree type;\n-    register tree scope;\n+    tree type;\n+    tree scope;\n {\n   /* Tagged types (i.e. struct, union, and enum types) must always be\n      output only in the scopes where they actually belong (or else the\n@@ -4701,18 +4701,18 @@ type_ok_for_scope (type, scope)\n \n static void\n output_pending_types_for_scope (containing_scope)\n-     register tree containing_scope;\n+     tree containing_scope;\n {\n-  register unsigned i;\n+  unsigned i;\n \n   for (i = 0; i < pending_types; )\n     {\n-      register tree type = pending_types_list[i];\n+      tree type = pending_types_list[i];\n \n       if (type_ok_for_scope (type, containing_scope))\n \t{\n-\t  register tree *mover;\n-\t  register tree *limit;\n+\t  tree *mover;\n+\t  tree *limit;\n \n \t  pending_types--;\n \t  limit = &pending_types_list[pending_types];\n@@ -4758,7 +4758,7 @@ add_incomplete_type (type)\n static void\n retry_incomplete_types ()\n {\n-  register tree type;\n+  tree type;\n \n   finalizing = 1;\n   while (incomplete_types)\n@@ -4771,8 +4771,8 @@ retry_incomplete_types ()\n \n static void\n output_type (type, containing_scope)\n-     register tree type;\n-     register tree containing_scope;\n+     tree type;\n+     tree containing_scope;\n {\n   if (type == 0 || type == error_mark_node)\n     return;\n@@ -4787,7 +4787,7 @@ output_type (type, containing_scope)\n     {\n       if (finalizing && AGGREGATE_TYPE_P (type))\n \t{\n-\t  register tree member;\n+\t  tree member;\n \n \t  /* Some of our nested types might not have been defined when we\n \t     were written out before; force them out now.  */\n@@ -4885,7 +4885,7 @@ output_type (type, containing_scope)\n \t  }\n \telse\n \t  {\n-\t    register tree element_type;\n+\t    tree element_type;\n \n \t    element_type = TREE_TYPE (type);\n \t    while (TREE_CODE (element_type) == ARRAY_TYPE)\n@@ -5006,7 +5006,7 @@ output_type (type, containing_scope)\n \t    ++in_class;\n \n \t    {\n-\t      register tree normal_member;\n+\t      tree normal_member;\n \n \t      /* Now output info about the data members and type members.  */\n \n@@ -5017,7 +5017,7 @@ output_type (type, containing_scope)\n \t    }\n \n \t    {\n-\t      register tree func_member;\n+\t      tree func_member;\n \n \t      /* Now output info about the function members (if any).  */\n \n@@ -5066,7 +5066,7 @@ output_type (type, containing_scope)\n \n static void\n output_tagged_type_instantiation (type)\n-     register tree type;\n+     tree type;\n {\n   if (type == 0 || type == error_mark_node)\n     return;\n@@ -5110,12 +5110,12 @@ output_tagged_type_instantiation (type)\n \n static void\n output_block (stmt, depth)\n-    register tree stmt;\n+    tree stmt;\n     int depth;\n {\n-  register int must_output_die = 0;\n-  register tree origin;\n-  register enum tree_code origin_code;\n+  int must_output_die = 0;\n+  tree origin;\n+  enum tree_code origin_code;\n \n   /* Ignore blocks never really used to make RTL.  */\n \n@@ -5161,7 +5161,7 @@ output_block (stmt, depth)\n \t    must_output_die = (BLOCK_VARS (stmt) != NULL);\n \t  else\n \t    {\n-\t      register tree decl;\n+\t      tree decl;\n \n \t      /* We are in terse mode, so only local (nested) function\n \t         definitions count as \"significant\" local declarations.  */\n@@ -5204,7 +5204,7 @@ output_block (stmt, depth)\n \n static void\n output_decls_for_scope (stmt, depth)\n-     register tree stmt;\n+     tree stmt;\n      int depth;\n {\n   /* Ignore blocks never really used to make RTL.  */\n@@ -5217,7 +5217,7 @@ output_decls_for_scope (stmt, depth)\n      but not within any nested sub-blocks.  */\n \n   {\n-    register tree decl;\n+    tree decl;\n \n     for (decl = BLOCK_VARS (stmt); decl; decl = TREE_CHAIN (decl))\n       output_decl (decl, stmt);\n@@ -5229,7 +5229,7 @@ output_decls_for_scope (stmt, depth)\n      therein) of this block.\t */\n \n   {\n-    register tree subblocks;\n+    tree subblocks;\n \n     for (subblocks = BLOCK_SUBBLOCKS (stmt);\n          subblocks;\n@@ -5242,7 +5242,7 @@ output_decls_for_scope (stmt, depth)\n \n static inline int\n is_redundant_typedef (decl)\n-     register tree decl;\n+     tree decl;\n {\n   if (TYPE_DECL_IS_STUB (decl))\n     return 1;\n@@ -5260,8 +5260,8 @@ is_redundant_typedef (decl)\n \n static void\n output_decl (decl, containing_scope)\n-     register tree decl;\n-     register tree containing_scope;\n+     tree decl;\n+     tree containing_scope;\n {\n   /* Make a note of the decl node we are going to be working on.  We may\n      need to give the user the source coordinates of where it appeared in\n@@ -5368,8 +5368,8 @@ output_decl (decl, containing_scope)\n \t{\n \t  /* Generate DIEs to represent all known formal parameters */\n \n-\t  register tree arg_decls = DECL_ARGUMENTS (decl);\n-\t  register tree parm;\n+\t  tree arg_decls = DECL_ARGUMENTS (decl);\n+\t  tree parm;\n \n \t  /* WARNING!  Kludge zone ahead!  Here we have a special\n \t     hack for svr4 SDB compatibility.  Instead of passing the\n@@ -5437,7 +5437,7 @@ output_decl (decl, containing_scope)\n \t  */\n \n \t  {\n-\t    register tree fn_arg_types = TYPE_ARG_TYPES (TREE_TYPE (decl));\n+\t    tree fn_arg_types = TYPE_ARG_TYPES (TREE_TYPE (decl));\n \n \t    if (fn_arg_types)\n \t      {\n@@ -5457,7 +5457,7 @@ output_decl (decl, containing_scope)\n \t     function (if it has one - it may be just a declaration).  */\n \n \t  {\n-\t    register tree outer_scope = DECL_INITIAL (decl);\n+\t    tree outer_scope = DECL_INITIAL (decl);\n \n \t    if (outer_scope && TREE_CODE (outer_scope) != ERROR_MARK)\n \t      {\n@@ -5584,7 +5584,7 @@ output_decl (decl, containing_scope)\n \t function.  */\n \n       {\n-        register void (*func) PARAMS ((void *));\n+        void (*func) PARAMS ((void *));\n \tregister tree origin = decl_ultimate_origin (decl);\n \n \tif (origin != NULL && TREE_CODE (origin) == PARM_DECL)\n@@ -5685,8 +5685,8 @@ dwarfout_deferred_inline_function (decl)\n \n static void\n dwarfout_file_scope_decl (decl, set_finalizing)\n-     register tree decl;\n-     register int set_finalizing;\n+     tree decl;\n+     int set_finalizing;\n {\n   if (TREE_CODE (decl) == ERROR_MARK)\n     return;\n@@ -5978,11 +5978,11 @@ dwarfout_end_epilogue ()\n \n static void\n shuffle_filename_entry (new_zeroth)\n-     register filename_entry *new_zeroth;\n+     filename_entry *new_zeroth;\n {\n   filename_entry temp_entry;\n-  register filename_entry *limit_p;\n-  register filename_entry *move_p;\n+  filename_entry *limit_p;\n+  filename_entry *move_p;\n \n   if (new_zeroth == &filename_table[0])\n     return;\n@@ -6053,8 +6053,8 @@ static unsigned\n lookup_filename (file_name)\n      const char *file_name;\n {\n-  register filename_entry *search_p;\n-  register filename_entry *limit_p = &filename_table[ft_entries];\n+  filename_entry *search_p;\n+  filename_entry *limit_p = &filename_table[ft_entries];\n \n   for (search_p = filename_table; search_p < limit_p; search_p++)\n     if (!strcmp (file_name, search_p->name))\n@@ -6129,7 +6129,7 @@ dwarfout_source_line (line, filename)\n       char label[MAX_ARTIFICIAL_LABEL_BYTES];\n       static unsigned last_line_entry_num = 0;\n       static unsigned prev_file_entry_num = (unsigned) -1;\n-      register unsigned this_file_entry_num;\n+      unsigned this_file_entry_num;\n \n       function_section (current_function_decl);\n       sprintf (label, LINE_CODE_LABEL_FMT, ++last_line_entry_num);\n@@ -6152,7 +6152,7 @@ dwarfout_source_line (line, filename)\n         }\n \n       {\n-        register const char *tail = strrchr (filename, '/');\n+        const char *tail = strrchr (filename, '/');\n \n         if (tail != NULL)\n           filename = tail;\n@@ -6175,8 +6175,8 @@ dwarfout_source_line (line, filename)\n \n static void\n generate_macinfo_entry (type_and_offset, string)\n-     register const char *type_and_offset;\n-     register const char *string;\n+     const char *type_and_offset;\n+     const char *string;\n {\n   if (! use_gnu_debug_info_extensions)\n     return;\n@@ -6192,7 +6192,7 @@ generate_macinfo_entry (type_and_offset, string)\n static void\n dwarfout_start_source_file_check (line, filename)\n      unsigned int line;\n-     register const char *filename;\n+     const char *filename;\n {\n   if (debug_info_level == DINFO_LEVEL_VERBOSE)\n     dwarfout_start_source_file (line, filename);\n@@ -6201,7 +6201,7 @@ dwarfout_start_source_file_check (line, filename)\n static void\n dwarfout_start_source_file (line, filename)\n      unsigned int line ATTRIBUTE_UNUSED;\n-     register const char *filename;\n+     const char *filename;\n {\n   char label[MAX_ARTIFICIAL_LABEL_BYTES];\n   char type_and_offset[MAX_ARTIFICIAL_LABEL_BYTES*3];\n@@ -6218,15 +6218,15 @@ dwarfout_start_source_file (line, filename)\n /* Wrapper for toplev.c callback to check debug info level.  */\n static void\n dwarfout_end_source_file_check (lineno)\n-     register unsigned lineno;\n+     unsigned lineno;\n {\n   if (debug_info_level == DINFO_LEVEL_VERBOSE)\n     dwarfout_end_source_file (lineno);\n }\n \n static void\n dwarfout_end_source_file (lineno)\n-     register unsigned lineno;\n+     unsigned lineno;\n {\n   char type_and_offset[MAX_ARTIFICIAL_LABEL_BYTES*2];\n \n@@ -6242,8 +6242,8 @@ dwarfout_end_source_file (lineno)\n \n static void\n dwarfout_define (lineno, buffer)\n-     register unsigned lineno;\n-     register const char *buffer;\n+     unsigned lineno;\n+     const char *buffer;\n {\n   static int initialized = 0;\n   char type_and_offset[MAX_ARTIFICIAL_LABEL_BYTES*2];\n@@ -6265,8 +6265,8 @@ dwarfout_define (lineno, buffer)\n \n static void\n dwarfout_undef (lineno, buffer)\n-     register unsigned lineno;\n-     register const char *buffer;\n+     unsigned lineno;\n+     const char *buffer;\n {\n   char type_and_offset[MAX_ARTIFICIAL_LABEL_BYTES*2];\n \n@@ -6279,7 +6279,7 @@ dwarfout_undef (lineno, buffer)\n \n static void\n dwarfout_init (main_input_filename)\n-     register const char *main_input_filename;\n+     const char *main_input_filename;\n {\n   /* Remember the name of the primary input file.  */\n \n@@ -6372,8 +6372,8 @@ dwarfout_init (main_input_filename)\n \t  ASM_OUTPUT_PUSH_SECTION (asm_out_file, DEBUG_SFNAMES_SECTION);\n \t  ASM_OUTPUT_LABEL (asm_out_file, SFNAMES_BEGIN_LABEL);\n \t  {\n-\t    register const char *pwd = getpwd ();\n-\t    register char *dirname;\n+\t    const char *pwd = getpwd ();\n+\t    char *dirname;\n \n \t    if (!pwd)\n \t      fatal_io_error (\"can't get current directory\");\n@@ -6468,7 +6468,7 @@ dwarfout_init (main_input_filename)\n \n static void\n dwarfout_finish (main_input_filename)\n-     register const char *main_input_filename ATTRIBUTE_UNUSED;\n+     const char *main_input_filename ATTRIBUTE_UNUSED;\n {\n   char label[MAX_ARTIFICIAL_LABEL_BYTES];\n "}, {"sha": "eaaf20cbe122eb6145bca22f84cf4f092884ffbb", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 65, "deletions": 65, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=b36948478c22c58018d0a888ee8ca393dea60dc9", "patch": "@@ -487,9 +487,9 @@ gen_lowpart_SUBREG (mode, reg)\n rtx\n gen_rtx VPARAMS ((enum rtx_code code, enum machine_mode mode, ...))\n {\n-  register int i;\t\t/* Array indices...\t\t\t*/\n-  register const char *fmt;\t/* Current rtx's format...\t\t*/\n-  register rtx rt_val;\t\t/* RTX to return to caller...\t\t*/\n+  int i;\t\t/* Array indices...\t\t\t*/\n+  const char *fmt;\t/* Current rtx's format...\t\t*/\n+  rtx rt_val;\t\t/* RTX to return to caller...\t\t*/\n \n   VA_OPEN (p, mode);\n   VA_FIXEDARG (p, enum rtx_code, code);\n@@ -606,8 +606,8 @@ gen_rtvec_v (n, argp)\n      int n;\n      rtx *argp;\n {\n-  register int i;\n-  register rtvec rt_val;\n+  int i;\n+  rtvec rt_val;\n \n   if (n == 0)\n     return NULL_RTVEC;\t\t/* Don't allocate an empty rtvec...\t*/\n@@ -628,7 +628,7 @@ gen_reg_rtx (mode)\n      enum machine_mode mode;\n {\n   struct function *f = cfun;\n-  register rtx val;\n+  rtx val;\n \n   /* Don't let anything called after initial flow analysis create new\n      registers.  */\n@@ -749,7 +749,7 @@ get_first_label_num ()\n    register.  */\n int\n subreg_hard_regno (x, check_mode)\n-     register rtx x;\n+     rtx x;\n      int check_mode;\n {\n   enum machine_mode mode = GET_MODE (x);\n@@ -791,7 +791,7 @@ subreg_hard_regno (x, check_mode)\n rtx\n gen_lowpart_common (mode, x)\n      enum machine_mode mode;\n-     register rtx x;\n+     rtx x;\n {\n   int msize = GET_MODE_SIZE (mode);\n   int xsize = GET_MODE_SIZE (GET_MODE (x));\n@@ -1075,7 +1075,7 @@ gen_lowpart_common (mode, x)\n rtx\n gen_realpart (mode, x)\n      enum machine_mode mode;\n-     register rtx x;\n+     rtx x;\n {\n   if (WORDS_BIG_ENDIAN\n       && GET_MODE_BITSIZE (mode) < BITS_PER_WORD\n@@ -1095,7 +1095,7 @@ gen_realpart (mode, x)\n rtx\n gen_imagpart (mode, x)\n      enum machine_mode mode;\n-     register rtx x;\n+     rtx x;\n {\n   if (WORDS_BIG_ENDIAN)\n     return gen_lowpart (mode, x);\n@@ -1135,7 +1135,7 @@ subreg_realpart_p (x)\n rtx\n gen_lowpart (mode, x)\n      enum machine_mode mode;\n-     register rtx x;\n+     rtx x;\n {\n   rtx result = gen_lowpart_common (mode, x);\n \n@@ -1152,7 +1152,7 @@ gen_lowpart (mode, x)\n   else if (GET_CODE (x) == MEM)\n     {\n       /* The only additional case we can do is MEM.  */\n-      register int offset = 0;\n+      int offset = 0;\n       if (WORDS_BIG_ENDIAN)\n \toffset = (MAX (GET_MODE_SIZE (GET_MODE (x)), UNITS_PER_WORD)\n \t\t  - MAX (GET_MODE_SIZE (mode), UNITS_PER_WORD));\n@@ -1177,7 +1177,7 @@ gen_lowpart (mode, x)\n rtx\n gen_highpart (mode, x)\n      enum machine_mode mode;\n-     register rtx x;\n+     rtx x;\n {\n   unsigned int msize = GET_MODE_SIZE (mode);\n   rtx result;\n@@ -1855,7 +1855,7 @@ replace_equiv_address_nv (memref, addr)\n rtx\n gen_label_rtx ()\n {\n-  register rtx label;\n+  rtx label;\n \n   label = gen_rtx_CODE_LABEL (VOIDmode, 0, NULL_RTX,\n \t\t\t      NULL_RTX, label_num++, NULL, NULL);\n@@ -2055,10 +2055,10 @@ rtx\n copy_rtx_if_shared (orig)\n      rtx orig;\n {\n-  register rtx x = orig;\n-  register int i;\n-  register enum rtx_code code;\n-  register const char *format_ptr;\n+  rtx x = orig;\n+  int i;\n+  enum rtx_code code;\n+  const char *format_ptr;\n   int copied = 0;\n \n   if (x == 0)\n@@ -2122,7 +2122,7 @@ copy_rtx_if_shared (orig)\n \n   if (x->used)\n     {\n-      register rtx copy;\n+      rtx copy;\n \n       copy = rtx_alloc (code);\n       memcpy (copy, x,\n@@ -2151,7 +2151,7 @@ copy_rtx_if_shared (orig)\n \tcase 'E':\n \t  if (XVEC (x, i) != NULL)\n \t    {\n-\t      register int j;\n+\t      int j;\n \t      int len = XVECLEN (x, i);\n \n \t      if (copied && len > 0)\n@@ -2172,9 +2172,9 @@ void\n reset_used_flags (x)\n      rtx x;\n {\n-  register int i, j;\n-  register enum rtx_code code;\n-  register const char *format_ptr;\n+  int i, j;\n+  enum rtx_code code;\n+  const char *format_ptr;\n \n   if (x == 0)\n     return;\n@@ -2604,9 +2604,9 @@ static void\n mark_label_nuses(x)\n     rtx x;\n {\n-  register enum rtx_code code;\n-  register int i, j;\n-  register const char *fmt;\n+  enum rtx_code code;\n+  int i, j;\n+  const char *fmt;\n \n   code = GET_CODE (x);\n   if (code == LABEL_REF)\n@@ -2810,7 +2810,7 @@ rtx\n make_insn_raw (pattern)\n      rtx pattern;\n {\n-  register rtx insn;\n+  rtx insn;\n \n   insn = rtx_alloc (INSN);\n \n@@ -2841,7 +2841,7 @@ static rtx\n make_jump_insn_raw (pattern)\n      rtx pattern;\n {\n-  register rtx insn;\n+  rtx insn;\n \n   insn = rtx_alloc (JUMP_INSN);\n   INSN_UID (insn) = cur_insn_uid++;\n@@ -2861,7 +2861,7 @@ static rtx\n make_call_insn_raw (pattern)\n      rtx pattern;\n {\n-  register rtx insn;\n+  rtx insn;\n \n   insn = rtx_alloc (CALL_INSN);\n   INSN_UID (insn) = cur_insn_uid++;\n@@ -2880,7 +2880,7 @@ make_call_insn_raw (pattern)\n \n void\n add_insn (insn)\n-     register rtx insn;\n+     rtx insn;\n {\n   PREV_INSN (insn) = last_insn;\n   NEXT_INSN (insn) = 0;\n@@ -3341,13 +3341,13 @@ remove_unnecessary_notes ()\n \n rtx\n emit_insn_before (pattern, before)\n-     register rtx pattern, before;\n+     rtx pattern, before;\n {\n-  register rtx insn = before;\n+  rtx insn = before;\n \n   if (GET_CODE (pattern) == SEQUENCE)\n     {\n-      register int i;\n+      int i;\n \n       for (i = 0; i < XVECLEN (pattern, 0); i++)\n \t{\n@@ -3369,9 +3369,9 @@ emit_insn_before (pattern, before)\n \n rtx\n emit_jump_insn_before (pattern, before)\n-     register rtx pattern, before;\n+     rtx pattern, before;\n {\n-  register rtx insn;\n+  rtx insn;\n \n   if (GET_CODE (pattern) == SEQUENCE)\n     insn = emit_insn_before (pattern, before);\n@@ -3389,9 +3389,9 @@ emit_jump_insn_before (pattern, before)\n \n rtx\n emit_call_insn_before (pattern, before)\n-     register rtx pattern, before;\n+     rtx pattern, before;\n {\n-  register rtx insn;\n+  rtx insn;\n \n   if (GET_CODE (pattern) == SEQUENCE)\n     insn = emit_insn_before (pattern, before);\n@@ -3410,9 +3410,9 @@ emit_call_insn_before (pattern, before)\n \n rtx\n emit_barrier_before (before)\n-     register rtx before;\n+     rtx before;\n {\n-  register rtx insn = rtx_alloc (BARRIER);\n+  rtx insn = rtx_alloc (BARRIER);\n \n   INSN_UID (insn) = cur_insn_uid++;\n \n@@ -3444,7 +3444,7 @@ emit_note_before (subtype, before)\n      int subtype;\n      rtx before;\n {\n-  register rtx note = rtx_alloc (NOTE);\n+  rtx note = rtx_alloc (NOTE);\n   INSN_UID (note) = cur_insn_uid++;\n   NOTE_SOURCE_FILE (note) = 0;\n   NOTE_LINE_NUMBER (note) = subtype;\n@@ -3458,13 +3458,13 @@ emit_note_before (subtype, before)\n \n rtx\n emit_insn_after (pattern, after)\n-     register rtx pattern, after;\n+     rtx pattern, after;\n {\n-  register rtx insn = after;\n+  rtx insn = after;\n \n   if (GET_CODE (pattern) == SEQUENCE)\n     {\n-      register int i;\n+      int i;\n \n       for (i = 0; i < XVECLEN (pattern, 0); i++)\n \t{\n@@ -3509,9 +3509,9 @@ emit_insn_after_with_line_notes (pattern, after, from)\n \n rtx\n emit_jump_insn_after (pattern, after)\n-     register rtx pattern, after;\n+     rtx pattern, after;\n {\n-  register rtx insn;\n+  rtx insn;\n \n   if (GET_CODE (pattern) == SEQUENCE)\n     insn = emit_insn_after (pattern, after);\n@@ -3529,9 +3529,9 @@ emit_jump_insn_after (pattern, after)\n \n rtx\n emit_barrier_after (after)\n-     register rtx after;\n+     rtx after;\n {\n-  register rtx insn = rtx_alloc (BARRIER);\n+  rtx insn = rtx_alloc (BARRIER);\n \n   INSN_UID (insn) = cur_insn_uid++;\n \n@@ -3564,7 +3564,7 @@ emit_note_after (subtype, after)\n      int subtype;\n      rtx after;\n {\n-  register rtx note = rtx_alloc (NOTE);\n+  rtx note = rtx_alloc (NOTE);\n   INSN_UID (note) = cur_insn_uid++;\n   NOTE_SOURCE_FILE (note) = 0;\n   NOTE_LINE_NUMBER (note) = subtype;\n@@ -3580,7 +3580,7 @@ emit_line_note_after (file, line, after)\n      int line;\n      rtx after;\n {\n-  register rtx note;\n+  rtx note;\n \n   if (no_line_numbers && line > 0)\n     {\n@@ -3611,7 +3611,7 @@ emit_insn (pattern)\n \n   if (GET_CODE (pattern) == SEQUENCE)\n     {\n-      register int i;\n+      int i;\n \n       for (i = 0; i < XVECLEN (pattern, 0); i++)\n \t{\n@@ -3674,11 +3674,11 @@ emit_insns_before (insn, before)\n \n rtx\n emit_insns_after (first, after)\n-     register rtx first;\n-     register rtx after;\n+     rtx first;\n+     rtx after;\n {\n-  register rtx last;\n-  register rtx after_after;\n+  rtx last;\n+  rtx after_after;\n   basic_block bb;\n \n   if (!after)\n@@ -3725,7 +3725,7 @@ emit_jump_insn (pattern)\n     return emit_insn (pattern);\n   else\n     {\n-      register rtx insn = make_jump_insn_raw (pattern);\n+      rtx insn = make_jump_insn_raw (pattern);\n       add_insn (insn);\n       return insn;\n     }\n@@ -3742,7 +3742,7 @@ emit_call_insn (pattern)\n     return emit_insn (pattern);\n   else\n     {\n-      register rtx insn = make_call_insn_raw (pattern);\n+      rtx insn = make_call_insn_raw (pattern);\n       add_insn (insn);\n       PUT_CODE (insn, CALL_INSN);\n       return insn;\n@@ -3772,7 +3772,7 @@ emit_label (label)\n rtx\n emit_barrier ()\n {\n-  register rtx barrier = rtx_alloc (BARRIER);\n+  rtx barrier = rtx_alloc (BARRIER);\n   INSN_UID (barrier) = cur_insn_uid++;\n   add_insn (barrier);\n   return barrier;\n@@ -3808,7 +3808,7 @@ emit_note (file, line)\n      const char *file;\n      int line;\n {\n-  register rtx note;\n+  rtx note;\n \n   if (line > 0)\n     {\n@@ -3895,7 +3895,7 @@ classify_insn (x)\n     }\n   if (GET_CODE (x) == PARALLEL)\n     {\n-      register int j;\n+      int j;\n       for (j = XVECLEN (x, 0) - 1; j >= 0; j--)\n \tif (GET_CODE (XVECEXP (x, 0, j)) == CALL)\n \t  return CALL_INSN;\n@@ -3924,7 +3924,7 @@ emit (x)\n     return emit_insn (x);\n   else if (code == JUMP_INSN)\n     {\n-      register rtx insn = emit_jump_insn (x);\n+      rtx insn = emit_jump_insn (x);\n       if (any_uncondjump_p (insn) || GET_CODE (x) == RETURN)\n \treturn emit_barrier ();\n       return insn;\n@@ -4181,12 +4181,12 @@ static rtvec copy_asm_constraints_vector;\n \n rtx\n copy_insn_1 (orig)\n-     register rtx orig;\n+     rtx orig;\n {\n-  register rtx copy;\n-  register int i, j;\n-  register RTX_CODE code;\n-  register const char *format_ptr;\n+  rtx copy;\n+  int i, j;\n+  RTX_CODE code;\n+  const char *format_ptr;\n \n   code = GET_CODE (orig);\n "}, {"sha": "533fe57deeb6916a57c2db654befcbf3da333a9a", "filename": "gcc/explow.c", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=b36948478c22c58018d0a888ee8ca393dea60dc9", "patch": "@@ -71,13 +71,13 @@ trunc_int_for_mode (c, mode)\n \n rtx\n plus_constant_wide (x, c)\n-     register rtx x;\n-     register HOST_WIDE_INT c;\n+     rtx x;\n+     HOST_WIDE_INT c;\n {\n-  register RTX_CODE code;\n+  RTX_CODE code;\n   rtx y;\n-  register enum machine_mode mode;\n-  register rtx tem;\n+  enum machine_mode mode;\n+  rtx tem;\n   int all_constant = 0;\n \n   if (c == 0)\n@@ -202,7 +202,7 @@ eliminate_constant_term (x, constptr)\n      rtx x;\n      rtx *constptr;\n {\n-  register rtx x0, x1;\n+  rtx x0, x1;\n   rtx tem;\n \n   if (GET_CODE (x) != PLUS)\n@@ -318,7 +318,7 @@ expr_size (exp)\n \n static rtx\n break_out_memory_refs (x)\n-     register rtx x;\n+     rtx x;\n {\n   if (GET_CODE (x) == MEM\n       || (CONSTANT_P (x) && CONSTANT_ADDRESS_P (x)\n@@ -327,8 +327,8 @@ break_out_memory_refs (x)\n   else if (GET_CODE (x) == PLUS || GET_CODE (x) == MINUS\n \t   || GET_CODE (x) == MULT)\n     {\n-      register rtx op0 = break_out_memory_refs (XEXP (x, 0));\n-      register rtx op1 = break_out_memory_refs (XEXP (x, 1));\n+      rtx op0 = break_out_memory_refs (XEXP (x, 0));\n+      rtx op1 = break_out_memory_refs (XEXP (x, 1));\n \n       if (op0 != XEXP (x, 0) || op1 != XEXP (x, 1))\n \tx = gen_rtx_fmt_ee (GET_CODE (x), Pmode, op0, op1);\n@@ -433,7 +433,7 @@ convert_memory_address (to_mode, x)\n \n rtx\n copy_all_regs (x)\n-     register rtx x;\n+     rtx x;\n {\n   if (GET_CODE (x) == REG)\n     {\n@@ -449,8 +449,8 @@ copy_all_regs (x)\n   else if (GET_CODE (x) == PLUS || GET_CODE (x) == MINUS\n \t   || GET_CODE (x) == MULT)\n     {\n-      register rtx op0 = copy_all_regs (XEXP (x, 0));\n-      register rtx op1 = copy_all_regs (XEXP (x, 1));\n+      rtx op0 = copy_all_regs (XEXP (x, 0));\n+      rtx op1 = copy_all_regs (XEXP (x, 1));\n       if (op0 != XEXP (x, 0) || op1 != XEXP (x, 1))\n \tx = gen_rtx_fmt_ee (GET_CODE (x), Pmode, op0, op1);\n     }\n@@ -464,9 +464,9 @@ copy_all_regs (x)\n rtx\n memory_address (mode, x)\n      enum machine_mode mode;\n-     register rtx x;\n+     rtx x;\n {\n-  register rtx oldx = x;\n+  rtx oldx = x;\n \n   if (GET_CODE (x) == ADDRESSOF)\n     return x;\n@@ -667,7 +667,7 @@ rtx\n copy_to_reg (x)\n      rtx x;\n {\n-  register rtx temp = gen_reg_rtx (GET_MODE (x));\n+  rtx temp = gen_reg_rtx (GET_MODE (x));\n  \n   /* If not an operand, must be an address with PLUS and MULT so\n      do the computation.  */ \n@@ -698,7 +698,7 @@ copy_to_mode_reg (mode, x)\n      enum machine_mode mode;\n      rtx x;\n {\n-  register rtx temp = gen_reg_rtx (mode);\n+  rtx temp = gen_reg_rtx (mode);\n   \n   /* If not an operand, must be an address with PLUS and MULT so\n      do the computation.  */ \n@@ -725,7 +725,7 @@ force_reg (mode, x)\n      enum machine_mode mode;\n      rtx x;\n {\n-  register rtx temp, insn, set;\n+  rtx temp, insn, set;\n \n   if (GET_CODE (x) == REG)\n     return x;\n@@ -761,7 +761,7 @@ rtx\n force_not_mem (x)\n      rtx x;\n {\n-  register rtx temp;\n+  rtx temp;\n \n   if (GET_CODE (x) != MEM || GET_MODE (x) == BLKmode)\n     return x;\n@@ -780,7 +780,7 @@ copy_to_suggested_reg (x, target, mode)\n      rtx x, target;\n      enum machine_mode mode;\n {\n-  register rtx temp;\n+  rtx temp;\n \n   if (target && GET_CODE (target) == REG)\n     temp = target;"}, {"sha": "b08a8c60c4620e5d821bcbbf61f4607a134ee830", "filename": "gcc/expmed.c", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=b36948478c22c58018d0a888ee8ca393dea60dc9", "patch": "@@ -302,7 +302,7 @@ store_bit_field (str_rtx, bitsize, bitnum, fieldmode, value, align, total_size)\n     = (GET_CODE (str_rtx) == MEM) ? BITS_PER_UNIT : BITS_PER_WORD;\n   unsigned HOST_WIDE_INT offset = bitnum / unit;\n   unsigned HOST_WIDE_INT bitpos = bitnum % unit;\n-  register rtx op0 = str_rtx;\n+  rtx op0 = str_rtx;\n \n   enum machine_mode op_mode = mode_for_extraction (EP_insv, 3);\n \n@@ -693,12 +693,12 @@ store_bit_field (str_rtx, bitsize, bitnum, fieldmode, value, align, total_size)\n \n static void\n store_fixed_bit_field (op0, offset, bitsize, bitpos, value, struct_align)\n-     register rtx op0;\n+     rtx op0;\n      unsigned HOST_WIDE_INT offset, bitsize, bitpos;\n-     register rtx value;\n+     rtx value;\n      unsigned int struct_align;\n {\n-  register enum machine_mode mode;\n+  enum machine_mode mode;\n   unsigned int total_bits = BITS_PER_WORD;\n   rtx subtarget, temp;\n   int all_zero = 0;\n@@ -794,7 +794,7 @@ store_fixed_bit_field (op0, offset, bitsize, bitpos, value, struct_align)\n \n   if (GET_CODE (value) == CONST_INT)\n     {\n-      register HOST_WIDE_INT v = INTVAL (value);\n+      HOST_WIDE_INT v = INTVAL (value);\n \n       if (bitsize < HOST_BITS_PER_WIDE_INT)\n \tv &= ((HOST_WIDE_INT) 1 << bitsize) - 1;\n@@ -1033,7 +1033,7 @@ extract_bit_field (str_rtx, bitsize, bitnum, unsignedp,\n     = (GET_CODE (str_rtx) == MEM) ? BITS_PER_UNIT : BITS_PER_WORD;\n   unsigned HOST_WIDE_INT offset = bitnum / unit;\n   unsigned HOST_WIDE_INT bitpos = bitnum % unit;\n-  register rtx op0 = str_rtx;\n+  rtx op0 = str_rtx;\n   rtx spec_target = target;\n   rtx spec_target_subreg = 0;\n   enum machine_mode int_mode;\n@@ -1577,7 +1577,7 @@ static rtx\n extract_fixed_bit_field (tmode, op0, offset, bitsize, bitpos,\n \t\t\t target, unsignedp, align)\n      enum machine_mode tmode;\n-     register rtx op0, target;\n+     rtx op0, target;\n      unsigned HOST_WIDE_INT offset, bitsize, bitpos;\n      int unsignedp;\n      unsigned int align;\n@@ -1931,15 +1931,15 @@ expand_dec (target, dec)\n rtx\n expand_shift (code, mode, shifted, amount, target, unsignedp)\n      enum tree_code code;\n-     register enum machine_mode mode;\n+     enum machine_mode mode;\n      rtx shifted;\n      tree amount;\n-     register rtx target;\n+     rtx target;\n      int unsignedp;\n {\n-  register rtx op1, temp = 0;\n-  register int left = (code == LSHIFT_EXPR || code == LROTATE_EXPR);\n-  register int rotate = (code == LROTATE_EXPR || code == RROTATE_EXPR);\n+  rtx op1, temp = 0;\n+  int left = (code == LSHIFT_EXPR || code == LROTATE_EXPR);\n+  int rotate = (code == LROTATE_EXPR || code == RROTATE_EXPR);\n   int try;\n \n   /* Previously detected shift-counts computed by NEGATE_EXPR\n@@ -2371,7 +2371,7 @@ synth_mult (alg_out, t, cost_limit)\n rtx\n expand_mult (mode, op0, op1, target, unsignedp)\n      enum machine_mode mode;\n-     register rtx op0, op1, target;\n+     rtx op0, op1, target;\n      int unsignedp;\n {\n   rtx const_op1 = op1;\n@@ -2757,7 +2757,7 @@ invert_mod2n (x, n)\n rtx\n expand_mult_highpart_adjust (mode, adj_operand, op0, op1, target, unsignedp)\n      enum machine_mode mode;\n-     register rtx adj_operand, op0, op1, target;\n+     rtx adj_operand, op0, op1, target;\n      int unsignedp;\n {\n   rtx tem;\n@@ -2794,7 +2794,7 @@ expand_mult_highpart_adjust (mode, adj_operand, op0, op1, target, unsignedp)\n rtx\n expand_mult_highpart (mode, op0, cnst1, target, unsignedp, max_cost)\n      enum machine_mode mode;\n-     register rtx op0, target;\n+     rtx op0, target;\n      unsigned HOST_WIDE_INT cnst1;\n      int unsignedp;\n      int max_cost;\n@@ -2976,11 +2976,11 @@ expand_divmod (rem_flag, code, mode, op0, op1, target, unsignedp)\n      int rem_flag;\n      enum tree_code code;\n      enum machine_mode mode;\n-     register rtx op0, op1, target;\n+     rtx op0, op1, target;\n      int unsignedp;\n {\n   enum machine_mode compute_mode;\n-  register rtx tquotient;\n+  rtx tquotient;\n   rtx quotient = 0, remainder = 0;\n   rtx last;\n   int size;"}, {"sha": "9457e8fd7bea2fc11a999dd3ee19e8f84ea1cdc5", "filename": "gcc/expr.c", "status": "modified", "additions": 44, "deletions": 44, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=b36948478c22c58018d0a888ee8ca393dea60dc9", "patch": "@@ -365,10 +365,10 @@ enqueue_insn (var, body)\n \n rtx\n protect_from_queue (x, modify)\n-     register rtx x;\n+     rtx x;\n      int modify;\n {\n-  register RTX_CODE code = GET_CODE (x);\n+  RTX_CODE code = GET_CODE (x);\n \n #if 0  /* A QUEUED can hang around after the queue is forced out.  */\n   /* Shortcut for most common case.  */\n@@ -453,7 +453,7 @@ int\n queued_subexp_p (x)\n      rtx x;\n {\n-  register enum rtx_code code = GET_CODE (x);\n+  enum rtx_code code = GET_CODE (x);\n   switch (code)\n     {\n     case QUEUED:\n@@ -475,7 +475,7 @@ queued_subexp_p (x)\n void\n emit_queue ()\n {\n-  register rtx p;\n+  rtx p;\n   while ((p = pending_chain))\n     {\n       rtx body = QUEUED_BODY (p);\n@@ -498,7 +498,7 @@ emit_queue ()\n \n void\n convert_move (to, from, unsignedp)\n-     register rtx to, from;\n+     rtx to, from;\n      int unsignedp;\n {\n   enum machine_mode to_mode = GET_MODE (to);\n@@ -1294,7 +1294,7 @@ convert_modes (mode, oldmode, x, unsignedp)\n      rtx x;\n      int unsignedp;\n {\n-  register rtx temp;\n+  rtx temp;\n \n   /* If FROM is a SUBREG that indicates that we have already done at least\n      the required extension, strip it.  */\n@@ -3082,7 +3082,7 @@ push_block (size, extra, below)\n      rtx size;\n      int extra, below;\n {\n-  register rtx temp;\n+  rtx temp;\n \n   size = convert_modes (Pmode, ptr_mode, size, 1);\n   if (CONSTANT_P (size))\n@@ -3132,7 +3132,7 @@ static rtx\n get_push_address (size)\n      int size;\n {\n-  register rtx temp;\n+  rtx temp;\n \n   if (STACK_PUSH_CODE == POST_DEC)\n     temp = gen_rtx_PLUS (Pmode, stack_pointer_rtx, GEN_INT (size));\n@@ -3237,7 +3237,7 @@ void\n emit_push_insn (x, mode, type, size, align, partial, reg, extra,\n \t\targs_addr, args_so_far, reg_parm_stack_space,\n                 alignment_pad)\n-     register rtx x;\n+     rtx x;\n      enum machine_mode mode;\n      tree type;\n      rtx size;\n@@ -3275,7 +3275,7 @@ emit_push_insn (x, mode, type, size, align, partial, reg, extra,\n     {\n       /* Copy a block into the stack, entirely or partially.  */\n \n-      register rtx temp;\n+      rtx temp;\n       int used = partial * UNITS_PER_WORD;\n       int offset = used % (PARM_BOUNDARY / BITS_PER_UNIT);\n       int skip;\n@@ -3683,7 +3683,7 @@ expand_assignment (to, from, want_value, suggest_reg)\n      int want_value;\n      int suggest_reg ATTRIBUTE_UNUSED;\n {\n-  register rtx to_rtx = 0;\n+  rtx to_rtx = 0;\n   rtx result;\n \n   /* Don't crash if the lhs of the assignment was erroneous.  */\n@@ -4023,11 +4023,11 @@ expand_assignment (to, from, want_value, suggest_reg)\n \n rtx\n store_expr (exp, target, want_value)\n-     register tree exp;\n-     register rtx target;\n+     tree exp;\n+     rtx target;\n      int want_value;\n {\n-  register rtx temp;\n+  rtx temp;\n   int dont_return_target = 0;\n   int dont_store_target = 0;\n \n@@ -4542,7 +4542,7 @@ store_constructor (exp, target, align, cleared, size)\n   if (TREE_CODE (type) == RECORD_TYPE || TREE_CODE (type) == UNION_TYPE\n       || TREE_CODE (type) == QUAL_UNION_TYPE)\n     {\n-      register tree elt;\n+      tree elt;\n \n       /* Inform later passes that the whole union value is dead.  */\n       if ((TREE_CODE (type) == UNION_TYPE\n@@ -4595,11 +4595,11 @@ store_constructor (exp, target, align, cleared, size)\n \n       for (elt = CONSTRUCTOR_ELTS (exp); elt; elt = TREE_CHAIN (elt))\n \t{\n-\t  register tree field = TREE_PURPOSE (elt);\n+\t  tree field = TREE_PURPOSE (elt);\n #ifdef WORD_REGISTER_OPERATIONS\n \t  tree value = TREE_VALUE (elt);\n #endif\n-\t  register enum machine_mode mode;\n+\t  enum machine_mode mode;\n \t  HOST_WIDE_INT bitsize;\n \t  HOST_WIDE_INT bitpos = 0;\n \t  int unsignedp;\n@@ -4709,8 +4709,8 @@ store_constructor (exp, target, align, cleared, size)\n     }\n   else if (TREE_CODE (type) == ARRAY_TYPE)\n     {\n-      register tree elt;\n-      register int i;\n+      tree elt;\n+      int i;\n       int need_to_clear;\n       tree domain = TYPE_DOMAIN (type);\n       tree elttype = TREE_TYPE (type);\n@@ -4795,7 +4795,7 @@ store_constructor (exp, target, align, cleared, size)\n \t   elt;\n \t   elt = TREE_CHAIN (elt), i++)\n \t{\n-\t  register enum machine_mode mode;\n+\t  enum machine_mode mode;\n \t  HOST_WIDE_INT bitsize;\n \t  HOST_WIDE_INT bitpos;\n \t  int unsignedp;\n@@ -5582,13 +5582,13 @@ rtx\n force_operand (value, target)\n      rtx value, target;\n {\n-  register optab binoptab = 0;\n+  optab binoptab = 0;\n   /* Use a temporary to force order of execution of calls to\n      `force_operand'.  */\n   rtx tmp;\n-  register rtx op2;\n+  rtx op2;\n   /* Use subtarget as the target for operand 0 of a binary operation.  */\n-  register rtx subtarget = get_subtarget (target);\n+  rtx subtarget = get_subtarget (target);\n \n   /* Check for a PIC address load.  */\n   if (flag_pic\n@@ -6059,16 +6059,16 @@ find_placeholder (exp, plist)\n \n rtx\n expand_expr (exp, target, tmode, modifier)\n-     register tree exp;\n+     tree exp;\n      rtx target;\n      enum machine_mode tmode;\n      enum expand_modifier modifier;\n {\n-  register rtx op0, op1, temp;\n+  rtx op0, op1, temp;\n   tree type = TREE_TYPE (exp);\n   int unsignedp = TREE_UNSIGNED (type);\n-  register enum machine_mode mode;\n-  register enum tree_code code = TREE_CODE (exp);\n+  enum machine_mode mode;\n+  enum tree_code code = TREE_CODE (exp);\n   optab this_optab;\n   rtx subtarget, original_target;\n   int ignore;\n@@ -7658,7 +7658,7 @@ expand_expr (exp, target, tmode, modifier)\n \t check the second operand.  */\n       if (TREE_CODE (TREE_OPERAND (exp, 0)) == INTEGER_CST)\n \t{\n-\t  register tree t1 = TREE_OPERAND (exp, 0);\n+\t  tree t1 = TREE_OPERAND (exp, 0);\n \t  TREE_OPERAND (exp, 0) = TREE_OPERAND (exp, 1);\n \t  TREE_OPERAND (exp, 1) = t1;\n \t}\n@@ -8811,12 +8811,12 @@ expand_expr (exp, target, tmode, modifier)\n \n static rtx\n expand_expr_unaligned (exp, palign)\n-     register tree exp;\n+     tree exp;\n      unsigned int *palign;\n {\n-  register rtx op0;\n+  rtx op0;\n   tree type = TREE_TYPE (exp);\n-  register enum machine_mode mode = TYPE_MODE (type);\n+  enum machine_mode mode = TYPE_MODE (type);\n \n   /* Default the alignment we return to that of the type.  */\n   *palign = TYPE_ALIGN (type);\n@@ -9163,12 +9163,12 @@ string_constant (arg, ptr_offset)\n \n static rtx\n expand_increment (exp, post, ignore)\n-     register tree exp;\n+     tree exp;\n      int post, ignore;\n {\n-  register rtx op0, op1;\n-  register rtx temp, value;\n-  register tree incremented = TREE_OPERAND (exp, 0);\n+  rtx op0, op1;\n+  rtx temp, value;\n+  tree incremented = TREE_OPERAND (exp, 0);\n   optab this_optab = add_optab;\n   int icode;\n   enum machine_mode mode = TYPE_MODE (TREE_TYPE (exp));\n@@ -9448,7 +9448,7 @@ do_jump (exp, if_false_label, if_true_label)\n      tree exp;\n      rtx if_false_label, if_true_label;\n {\n-  register enum tree_code code = TREE_CODE (exp);\n+  enum tree_code code = TREE_CODE (exp);\n   /* Some cases need to create a label to jump to\n      in order to properly fall through.\n      These cases set DROP_THROUGH_LABEL nonzero.  */\n@@ -9634,7 +9634,7 @@ do_jump (exp, if_false_label, if_true_label)\n \n       else\n \t{\n-\t  register rtx label1 = gen_label_rtx ();\n+\t  rtx label1 = gen_label_rtx ();\n \t  drop_through_label = gen_label_rtx ();\n \n \t  do_jump (TREE_OPERAND (exp, 0), label1, NULL_RTX);\n@@ -10095,7 +10095,7 @@ do_jump_by_parts_equality_rtx (op0, if_false_label, if_true_label)\n \n rtx\n compare_from_rtx (op0, op1, code, unsignedp, mode, size, align)\n-     register rtx op0, op1;\n+     rtx op0, op1;\n      enum rtx_code code;\n      int unsignedp;\n      enum machine_mode mode;\n@@ -10166,7 +10166,7 @@ compare_from_rtx (op0, op1, code, unsignedp, mode, size, align)\n void\n do_compare_rtx_and_jump (op0, op1, code, unsignedp, mode, size, align,\n \t\t\t if_false_label, if_true_label)\n-     register rtx op0, op1;\n+     rtx op0, op1;\n      enum rtx_code code;\n      int unsignedp;\n      enum machine_mode mode;\n@@ -10271,14 +10271,14 @@ do_compare_rtx_and_jump (op0, op1, code, unsignedp, mode, size, align,\n static void\n do_compare_and_jump (exp, signed_code, unsigned_code, if_false_label,\n \t\t     if_true_label)\n-     register tree exp;\n+     tree exp;\n      enum rtx_code signed_code, unsigned_code;\n      rtx if_false_label, if_true_label;\n {\n   unsigned int align0, align1;\n-  register rtx op0, op1;\n-  register tree type;\n-  register enum machine_mode mode;\n+  rtx op0, op1;\n+  tree type;\n+  enum machine_mode mode;\n   int unsignedp;\n   enum rtx_code code;\n \n@@ -10754,7 +10754,7 @@ do_tablejump (index, mode, range, table_label, default_label)\n      rtx index, range, table_label, default_label;\n      enum machine_mode mode;\n {\n-  register rtx temp, vector;\n+  rtx temp, vector;\n \n   /* Do an unsigned comparison (in the proper mode) between the index\n      expression and the value which represents the length of the range."}, {"sha": "28f756d14758029a7fc9420a8b1ce0279afed82e", "filename": "gcc/final.c", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=b36948478c22c58018d0a888ee8ca393dea60dc9", "patch": "@@ -1948,7 +1948,7 @@ final (first, file, optimize, prescan)\n      int optimize;\n      int prescan;\n {\n-  register rtx insn;\n+  rtx insn;\n   int max_line = 0;\n   int max_uid = 0;\n \n@@ -2205,7 +2205,7 @@ final_scan_insn (insn, file, optimize, prescan, nopeepholes)\n \n \t  /* This note is a line-number.  */\n \t  {\n-\t    register rtx note;\n+\t    rtx note;\n \t    int note_after = 0;\n \n \t    /* If there is anything real after this note, output it.\n@@ -2372,7 +2372,7 @@ final_scan_insn (insn, file, optimize, prescan, nopeepholes)\n \n     default:\n       {\n-\tregister rtx body = PATTERN (insn);\n+\trtx body = PATTERN (insn);\n \tint insn_code_number;\n \tconst char *template;\n #ifdef HAVE_cc0\n@@ -2406,7 +2406,7 @@ final_scan_insn (insn, file, optimize, prescan, nopeepholes)\n \tif (GET_CODE (body) == ADDR_VEC || GET_CODE (body) == ADDR_DIFF_VEC)\n \t  {\n #if !(defined(ASM_OUTPUT_ADDR_VEC) || defined(ASM_OUTPUT_ADDR_DIFF_VEC))\n-\t    register int vlen, idx;\n+\t    int vlen, idx;\n #endif\n \n \t    if (prescan > 0)\n@@ -2541,7 +2541,7 @@ final_scan_insn (insn, file, optimize, prescan, nopeepholes)\n \tif (GET_CODE (body) == SEQUENCE)\n \t  {\n \t    /* A delayed-branch sequence */\n-\t    register int i;\n+\t    int i;\n \t    rtx next;\n \n \t    if (prescan > 0)\n@@ -2705,7 +2705,7 @@ final_scan_insn (insn, file, optimize, prescan, nopeepholes)\n \t       It may also return 1 meaning condition now always true\n \t       or -1 meaning condition now always false\n \t       or 2 meaning condition nontrivial but altered.  */\n-\t    register int result = alter_cond (XEXP (SET_SRC (body), 0));\n+\t    int result = alter_cond (XEXP (SET_SRC (body), 0));\n \t    /* If condition now has fixed value, replace the IF_THEN_ELSE\n \t       with its then-operand or its else-operand.  */\n \t    if (result == 1)\n@@ -2766,7 +2766,7 @@ final_scan_insn (insn, file, optimize, prescan, nopeepholes)\n \t      case EQ:\n \t      case NE:\n \t\t{\n-\t\t  register int result;\n+\t\t  int result;\n \t\t  if (XEXP (cond_rtx, 0) != cc0_rtx)\n \t\t    break;\n \t\t  result = alter_cond (cond_rtx);\n@@ -2966,7 +2966,7 @@ static void\n notice_source_line (insn)\n      rtx insn;\n {\n-  register const char *filename = NOTE_SOURCE_FILE (insn);\n+  const char *filename = NOTE_SOURCE_FILE (insn);\n \n   /* Remember filename for basic block profiling.\n      Filenames are allocated on the permanent obstack\n@@ -3017,9 +3017,9 @@ cleanup_subreg_operands (insn)\n \n rtx\n alter_subreg (x)\n-     register rtx x;\n+     rtx x;\n {\n-  register rtx y = SUBREG_REG (x);\n+  rtx y = SUBREG_REG (x);\n \n   if (GET_CODE (y) == SUBREG)\n     y = alter_subreg (y);\n@@ -3097,7 +3097,7 @@ walk_alter_subreg (x)\n \n static int\n alter_cond (cond)\n-     register rtx cond;\n+     rtx cond;\n {\n   int value = 0;\n \n@@ -3286,7 +3286,7 @@ output_asm_name ()\n \t alternative used.  */\n       if (debug_insn)\n \t{\n-\t  register int num = INSN_CODE (debug_insn);\n+\t  int num = INSN_CODE (debug_insn);\n \t  fprintf (asm_out_file, \"\\t%s %d\\t%s\",\n \t\t   ASM_COMMENT_START, INSN_UID (debug_insn),\n \t\t   insn_data[num].name);\n@@ -3308,8 +3308,8 @@ output_asm_insn (template, operands)\n      const char *template;\n      rtx *operands;\n {\n-  register const char *p;\n-  register int c;\n+  const char *p;\n+  int c;\n \n   /* An insn may return a null string template\n      in a case where no assembler code is needed.  */\n@@ -3342,7 +3342,7 @@ output_asm_insn (template, operands)\n #ifdef ASSEMBLER_DIALECT\n       case '{':\n \t{\n-\t  register int i;\n+\t  int i;\n \n \t  /* If we want the first dialect, do nothing.  Otherwise, skip\n \t     DIALECT_NUMBER of strings ending with '|'.  */\n@@ -4096,10 +4096,10 @@ leaf_renumber_regs (first)\n \n void\n leaf_renumber_regs_insn (in_rtx)\n-     register rtx in_rtx;\n+     rtx in_rtx;\n {\n-  register int i, j;\n-  register const char *format_ptr;\n+  int i, j;\n+  const char *format_ptr;\n \n   if (in_rtx == 0)\n     return;"}, {"sha": "b197371c22a206faf338f5dff6e8301515896721", "filename": "gcc/fix-header.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Ffix-header.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Ffix-header.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffix-header.c?ref=b36948478c22c58018d0a888ee8ca393dea60dc9", "patch": "@@ -617,7 +617,7 @@ read_scan_file (in_fname, argc, argv)\n   cpp_options *options;\n   struct fn_decl *fn;\n   int i;\n-  register struct symbol_list *cur_symbols;\n+  struct symbol_list *cur_symbols;\n \n   obstack_init (&scan_file_obstack); \n \n@@ -730,7 +730,7 @@ write_rbrac ()\n {\n   struct fn_decl *fn;\n   const char *cptr;\n-  register struct symbol_list *cur_symbols;\n+  struct symbol_list *cur_symbols;\n \n   if (required_unseen_count)\n     {\n@@ -929,7 +929,7 @@ inf_read_upto (str, delim)\n \n static int\n inf_scan_ident (s, c)\n-     register sstring *s;\n+     sstring *s;\n      int c;\n {\n   s->ptr = s->base;\n@@ -1074,11 +1074,11 @@ main (argc, argv)\n   int endif_line;\n   long to_read;\n   long int inf_size;\n-  register struct symbol_list *cur_symbols;\n+  struct symbol_list *cur_symbols;\n \n   if (argv[0] && argv[0][0])\n     {\n-      register char *p;\n+      char *p;\n \n       progname = 0;\n       for (p = argv[0]; *p; p++)"}, {"sha": "929aef7353c1eb2bf5c76a76b1ab3d95c083b401", "filename": "gcc/floatlib.c", "status": "modified", "additions": 50, "deletions": 50, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Ffloatlib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Ffloatlib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffloatlib.c?ref=b36948478c22c58018d0a888ee8ca393dea60dc9", "patch": "@@ -100,9 +100,9 @@ union float_long\n float\n __addsf3 (float a1, float a2)\n {\n-  register long mant1, mant2;\n-  register union float_long fl1, fl2;\n-  register int exp1, exp2;\n+  long mant1, mant2;\n+  union float_long fl1, fl2;\n+  int exp1, exp2;\n   int sign = 0;\n \n   fl1.f = a1;\n@@ -196,7 +196,7 @@ __addsf3 (float a1, float a2)\n float\n __subsf3 (float a1, float a2)\n {\n-  register union float_long fl1, fl2;\n+  union float_long fl1, fl2;\n \n   fl1.f = a1;\n   fl2.f = a2;\n@@ -216,7 +216,7 @@ __subsf3 (float a1, float a2)\n long\n __cmpsf2 (float a1, float a2)\n {\n-  register union float_long fl1, fl2;\n+  union float_long fl1, fl2;\n \n   fl1.f = a1;\n   fl2.f = a2;\n@@ -237,9 +237,9 @@ __cmpsf2 (float a1, float a2)\n float\n __mulsf3 (float a1, float a2)\n {\n-  register union float_long fl1, fl2;\n-  register unsigned long result;\n-  register int exp;\n+  union float_long fl1, fl2;\n+  unsigned long result;\n+  int exp;\n   int sign;\n \n   fl1.f = a1;\n@@ -294,10 +294,10 @@ __mulsf3 (float a1, float a2)\n float\n __divsf3 (float a1, float a2)\n {\n-  register union float_long fl1, fl2;\n-  register int result;\n-  register int mask;\n-  register int exp, sign;\n+  union float_long fl1, fl2;\n+  int result;\n+  int mask;\n+  int exp, sign;\n \n   fl1.f = a1;\n   fl2.f = a2;\n@@ -358,9 +358,9 @@ __divsf3 (float a1, float a2)\n \n /* convert int to double */\n double\n-__floatsidf (register long a1)\n+__floatsidf (long a1)\n {\n-  register int sign = 0, exp = 31 + EXCESSD;\n+  int sign = 0, exp = 31 + EXCESSD;\n   union double_long dl;\n \n   if (!a1)\n@@ -397,9 +397,9 @@ __floatsidf (register long a1)\n }\n \n double\n-__floatdidf (register long long a1)\n+__floatdidf (long long a1)\n {\n-    register int exp = 63 + EXCESSD;\n+    int exp = 63 + EXCESSD;\n     union double_long dl;\n \n     dl.l.upper = dl.l.lower = 0;\n@@ -428,13 +428,13 @@ __floatdidf (register long long a1)\n }\n \n float\n-__floatsisf (register long a1)\n+__floatsisf (long a1)\n {\n     (float)__floatsidf(a1);\n }\n \n float\n-__floatdisf (register long long a1)\n+__floatdisf (long long a1)\n {\n     (float)__floatdidf(a1);\n }\n@@ -443,7 +443,7 @@ __floatdisf (register long long a1)\n float\n __negsf2 (float a1)\n {\n-  register union float_long fl1;\n+  union float_long fl1;\n \n   fl1.f = a1;\n   if (!fl1.l)\n@@ -457,7 +457,7 @@ __negsf2 (float a1)\n double\n __negdf2 (double a1)\n {\n-  register union double_long dl1;\n+  union double_long dl1;\n \n   dl1.d = a1;\n \n@@ -472,9 +472,9 @@ __negdf2 (double a1)\n double\n __extendsfdf2 (float a1)\n {\n-  register union float_long fl1;\n-  register union double_long dl;\n-  register int exp;\n+  union float_long fl1;\n+  union double_long dl;\n+  int exp;\n \n   fl1.f = a1;\n \n@@ -497,10 +497,10 @@ __extendsfdf2 (float a1)\n float\n __truncdfsf2 (double a1)\n {\n-  register int exp;\n-  register long mant;\n-  register union float_long fl;\n-  register union double_long dl1;\n+  int exp;\n+  long mant;\n+  union float_long fl;\n+  union double_long dl1;\n \n   dl1.d = a1;\n \n@@ -534,7 +534,7 @@ __truncdfsf2 (double a1)\n long\n __cmpdf2 (double a1, double a2)\n {\n-  register union double_long dl1, dl2;\n+  union double_long dl1, dl2;\n \n   dl1.d = a1;\n   dl2.d = a2;\n@@ -559,9 +559,9 @@ __cmpdf2 (double a1, double a2)\n long\n __fixdfsi (double a1)\n {\n-  register union double_long dl1;\n-  register int exp;\n-  register long l;\n+  union double_long dl1;\n+  int exp;\n+  long l;\n \n   dl1.d = a1;\n \n@@ -587,9 +587,9 @@ __fixdfsi (double a1)\n long long\n __fixdfdi (double a1)\n {\n-    register union double_long dl1;\n-    register int exp;\n-    register long long l;\n+    union double_long dl1;\n+    int exp;\n+    long long l;\n \n     dl1.d = a1;\n \n@@ -619,9 +619,9 @@ __fixdfdi (double a1)\n unsigned long\n __fixunsdfsi (double a1)\n {\n-  register union double_long dl1;\n-  register int exp;\n-  register unsigned long l;\n+  union double_long dl1;\n+  int exp;\n+  unsigned long l;\n \n   dl1.d = a1;\n \n@@ -647,9 +647,9 @@ __fixunsdfsi (double a1)\n unsigned long long\n __fixunsdfdi (double a1)\n {\n-    register union double_long dl1;\n-    register int exp;\n-    register unsigned long long l;\n+    union double_long dl1;\n+    int exp;\n+    unsigned long long l;\n \n     dl1.d = a1;\n \n@@ -676,9 +676,9 @@ __fixunsdfdi (double a1)\n double\n __adddf3 (double a1, double a2)\n {\n-    register long long mant1, mant2;\n-    register union double_long fl1, fl2;\n-    register int exp1, exp2;\n+    long long mant1, mant2;\n+    union double_long fl1, fl2;\n+    int exp1, exp2;\n     int sign = 0;\n \n     fl1.d = a1;\n@@ -765,7 +765,7 @@ __adddf3 (double a1, double a2)\n double\n __subdf3 (double a1, double a2)\n {\n-    register union double_long fl1, fl2;\n+    union double_long fl1, fl2;\n \n     fl1.d = a1;\n     fl2.d = a2;\n@@ -784,9 +784,9 @@ __subdf3 (double a1, double a2)\n double\n __muldf3 (double a1, double a2)\n {\n-    register union double_long fl1, fl2;\n-    register unsigned long long result;\n-    register int exp;\n+    union double_long fl1, fl2;\n+    unsigned long long result;\n+    int exp;\n     int sign;\n \n     fl1.d = a1;\n@@ -838,9 +838,9 @@ __muldf3 (double a1, double a2)\n double\n __divdf3 (double a1, double a2)\n {\n-    register union double_long fl1, fl2;\n-    register long long mask,result;\n-    register int exp, sign;\n+    union double_long fl1, fl2;\n+    long long mask,result;\n+    int exp, sign;\n \n     fl1.d = a1;\n     fl2.d = a2;"}, {"sha": "f0dd62e31498d1736fe01ebcad28b9af8b8433f8", "filename": "gcc/flow.c", "status": "modified", "additions": 25, "deletions": 24, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=b36948478c22c58018d0a888ee8ca393dea60dc9", "patch": "@@ -416,7 +416,7 @@ life_analysis (f, file, flags)\n      int flags;\n {\n #ifdef ELIMINABLE_REGS\n-  register int i;\n+  int i;\n   static const struct {const int from, to; } eliminables[] = ELIMINABLE_REGS;\n #endif\n \n@@ -1273,7 +1273,7 @@ calculate_global_regs_live (blocks_in, blocks_out, flags)\n void\n allocate_bb_life_data ()\n {\n-  register int i;\n+  int i;\n \n   for (i = 0; i < n_basic_blocks; i++)\n     {\n@@ -1452,7 +1452,7 @@ propagate_one_insn (pbi, insn)\n      a following memory address.  */\n #ifdef AUTO_INC_DEC\n   {\n-    register rtx x = single_set (insn);\n+    rtx x = single_set (insn);\n \n     /* Does this instruction increment or decrement a register?  */\n     if ((flags & PROP_AUTOINC)\n@@ -1510,7 +1510,7 @@ propagate_one_insn (pbi, insn)\n \n       if (GET_CODE (insn) == CALL_INSN)\n \t{\n-\t  register int i;\n+\t  int i;\n \t  rtx note, cond;\n \n \t  cond = NULL_RTX;\n@@ -1560,7 +1560,7 @@ propagate_one_insn (pbi, insn)\n \n       if (! insn_is_dead && GET_CODE (insn) == CALL_INSN)\n \t{\n-\t  register int i;\n+\t  int i;\n \t  rtx note, cond;\n \n \t  cond = NULL_RTX;\n@@ -1815,7 +1815,7 @@ propagate_block (bb, live, local_set, cond_local_set, flags)\n \n   if (flags & PROP_REG_INFO)\n     {\n-      register int i;\n+      int i;\n \n       /* Process the regs live at the end of the block.\n \t Mark them as not local to any one basic block.  */\n@@ -2062,13 +2062,13 @@ libcall_dead_p (pbi, note, insn)\n \n   if (x)\n     {\n-      register rtx r = SET_SRC (x);\n+      rtx r = SET_SRC (x);\n \n       if (GET_CODE (r) == REG)\n \t{\n \t  rtx call = XEXP (note, 0);\n \t  rtx call_pat;\n-\t  register int i;\n+\t  int i;\n \n \t  /* Find the call insn.  */\n \t  while (call != insn && GET_CODE (call) != CALL_INSN)\n@@ -2271,7 +2271,8 @@ mark_set_regs (pbi, x, insn)\n \n     case PARALLEL:\n       {\n-\tregister int i;\n+\tint i;\n+\n \tfor (i = XVECLEN (x, 0) - 1; i >= 0; i--)\n \t  {\n \t    rtx sub = XVECEXP (x, 0, i);\n@@ -2486,8 +2487,8 @@ mark_set_1 (pbi, code, reg, cond, insn, flags)\n       if (flags & (PROP_LOG_LINKS | PROP_REG_INFO\n \t\t   | PROP_DEATH_NOTES | PROP_AUTOINC))\n \t{\n-\t  register rtx y;\n-\t  register int blocknum = pbi->bb->index;\n+\t  rtx y;\n+\t  int blocknum = pbi->bb->index;\n \n \t  y = NULL_RTX;\n \t  if (flags & (PROP_LOG_LINKS | PROP_AUTOINC))\n@@ -3331,7 +3332,7 @@ mark_used_reg (pbi, reg, cond, insn)\n \t{\n \t  /* Keep track of which basic block each reg appears in.  */\n \n-\t  register int blocknum = pbi->bb->index;\n+\t  int blocknum = pbi->bb->index;\n \t  if (REG_BASIC_BLOCK (regno_first) == REG_BLOCK_UNKNOWN)\n \t    REG_BASIC_BLOCK (regno_first) = blocknum;\n \t  else if (REG_BASIC_BLOCK (regno_first) != blocknum)\n@@ -3463,8 +3464,8 @@ mark_used_regs (pbi, x, cond, insn)\n      struct propagate_block_info *pbi;\n      rtx x, cond, insn;\n {\n-  register RTX_CODE code;\n-  register int regno;\n+  RTX_CODE code;\n+  int regno;\n   int flags = pbi->flags;\n \n  retry:\n@@ -3565,7 +3566,7 @@ mark_used_regs (pbi, x, cond, insn)\n \n     case SET:\n       {\n-\tregister rtx testreg = SET_DEST (x);\n+\trtx testreg = SET_DEST (x);\n \tint mark_dest = 0;\n \n \t/* If storing into MEM, don't show it as being used.  But do\n@@ -3704,8 +3705,8 @@ mark_used_regs (pbi, x, cond, insn)\n   /* Recursively scan the operands of this expression.  */\n \n   {\n-    register const char * const fmt = GET_RTX_FORMAT (code);\n-    register int i;\n+    const char * const fmt = GET_RTX_FORMAT (code);\n+    int i;\n \n     for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n       {\n@@ -3721,7 +3722,7 @@ mark_used_regs (pbi, x, cond, insn)\n \t  }\n \telse if (fmt[i] == 'E')\n \t  {\n-\t    register int j;\n+\t    int j;\n \t    for (j = 0; j < XVECLEN (x, i); j++)\n \t      mark_used_regs (pbi, XVECEXP (x, i, j), cond, insn);\n \t  }\n@@ -3784,7 +3785,7 @@ try_pre_increment (insn, reg, amount)\n      rtx insn, reg;\n      HOST_WIDE_INT amount;\n {\n-  register rtx use;\n+  rtx use;\n \n   /* Nonzero if we can try to make a pre-increment or pre-decrement.\n      For example, addl $4,r1; movl (r1),... can become movl +(r1),...  */\n@@ -3861,15 +3862,15 @@ try_pre_increment (insn, reg, amount)\n \n rtx\n find_use_as_address (x, reg, plusconst)\n-     register rtx x;\n+     rtx x;\n      rtx reg;\n      HOST_WIDE_INT plusconst;\n {\n   enum rtx_code code = GET_CODE (x);\n   const char * const fmt = GET_RTX_FORMAT (code);\n-  register int i;\n-  register rtx value = 0;\n-  register rtx tem;\n+  int i;\n+  rtx value = 0;\n+  rtx tem;\n \n   if (code == MEM && XEXP (x, 0) == reg && plusconst == 0)\n     return x;\n@@ -3903,7 +3904,7 @@ find_use_as_address (x, reg, plusconst)\n \t}\n       else if (fmt[i] == 'E')\n \t{\n-\t  register int j;\n+\t  int j;\n \t  for (j = XVECLEN (x, i) - 1; j >= 0; j--)\n \t    {\n \t      tem = find_use_as_address (XVECEXP (x, i, j), reg, plusconst);"}, {"sha": "e25b67fc76d72a9730a6865972e99aaaaa5ca3ce", "filename": "gcc/fold-const.c", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=b36948478c22c58018d0a888ee8ca393dea60dc9", "patch": "@@ -324,8 +324,8 @@ mul_double (l1, h1, l2, h2, lv, hv)\n   HOST_WIDE_INT arg1[4];\n   HOST_WIDE_INT arg2[4];\n   HOST_WIDE_INT prod[4 * 2];\n-  register unsigned HOST_WIDE_INT carry;\n-  register int i, j, k;\n+  unsigned HOST_WIDE_INT carry;\n+  int i, j, k;\n   unsigned HOST_WIDE_INT toplow, neglow;\n   HOST_WIDE_INT tophigh, neghigh;\n \n@@ -537,7 +537,7 @@ div_and_round_double (code, uns,\n   int quo_neg = 0;\n   HOST_WIDE_INT num[4 + 1];\t/* extra element for scaling.  */\n   HOST_WIDE_INT den[4], quo[4];\n-  register int i, j;\n+  int i, j;\n   unsigned HOST_WIDE_INT work;\n   unsigned HOST_WIDE_INT carry = 0;\n   unsigned HOST_WIDE_INT lnum = lnum_orig;\n@@ -1486,7 +1486,7 @@ associate_trees (t1, t2, code, type)\n static tree\n int_const_binop (code, arg1, arg2, notrunc)\n      enum tree_code code;\n-     register tree arg1, arg2;\n+     tree arg1, arg2;\n      int notrunc;\n {\n   unsigned HOST_WIDE_INT int1l, int2l;\n@@ -1495,7 +1495,7 @@ int_const_binop (code, arg1, arg2, notrunc)\n   HOST_WIDE_INT hi;\n   unsigned HOST_WIDE_INT garbagel;\n   HOST_WIDE_INT garbageh;\n-  register tree t;\n+  tree t;\n   tree type = TREE_TYPE (arg1);\n   int uns = TREE_UNSIGNED (type);\n   int is_sizetype\n@@ -1744,7 +1744,7 @@ const_binop_1 (data)\n static tree\n const_binop (code, arg1, arg2, notrunc)\n      enum tree_code code;\n-     register tree arg1, arg2;\n+     tree arg1, arg2;\n      int notrunc;\n {\n   STRIP_NOPS (arg1);\n@@ -1800,12 +1800,12 @@ const_binop (code, arg1, arg2, notrunc)\n #endif /* not REAL_IS_NOT_DOUBLE, or REAL_ARITHMETIC */\n   if (TREE_CODE (arg1) == COMPLEX_CST)\n     {\n-      register tree type = TREE_TYPE (arg1);\n-      register tree r1 = TREE_REALPART (arg1);\n-      register tree i1 = TREE_IMAGPART (arg1);\n-      register tree r2 = TREE_REALPART (arg2);\n-      register tree i2 = TREE_IMAGPART (arg2);\n-      register tree t;\n+      tree type = TREE_TYPE (arg1);\n+      tree r1 = TREE_REALPART (arg1);\n+      tree i1 = TREE_IMAGPART (arg1);\n+      tree r2 = TREE_REALPART (arg2);\n+      tree i2 = TREE_IMAGPART (arg2);\n+      tree t;\n \n       switch (code)\n \t{\n@@ -1839,7 +1839,7 @@ const_binop (code, arg1, arg2, notrunc)\n \n \tcase RDIV_EXPR:\n \t  {\n-\t    register tree magsquared\n+\t    tree magsquared\n \t      = const_binop (PLUS_EXPR,\n \t\t\t     const_binop (MULT_EXPR, r2, r2, notrunc),\n \t\t\t     const_binop (MULT_EXPR, i2, i2, notrunc),\n@@ -2069,10 +2069,10 @@ fold_convert_1 (data)\n \n static tree\n fold_convert (t, arg1)\n-     register tree t;\n-     register tree arg1;\n+     tree t;\n+     tree arg1;\n {\n-  register tree type = TREE_TYPE (t);\n+  tree type = TREE_TYPE (t);\n   int overflow = 0;\n \n   if (POINTER_TYPE_P (type) || INTEGRAL_TYPE_P (type))\n@@ -4913,13 +4913,13 @@ tree\n fold (expr)\n      tree expr;\n {\n-  register tree t = expr;\n+  tree t = expr;\n   tree t1 = NULL_TREE;\n   tree tem;\n   tree type = TREE_TYPE (expr);\n-  register tree arg0 = NULL_TREE, arg1 = NULL_TREE;\n-  register enum tree_code code = TREE_CODE (t);\n-  register int kind = TREE_CODE_CLASS (code);\n+  tree arg0 = NULL_TREE, arg1 = NULL_TREE;\n+  enum tree_code code = TREE_CODE (t);\n+  int kind = TREE_CODE_CLASS (code);\n   int invert;\n   /* WINS will be nonzero when the switch is done\n      if all operands are constant.  */\n@@ -4966,8 +4966,8 @@ fold (expr)\n     }\n   else if (IS_EXPR_CODE_CLASS (kind) || kind == 'r')\n     {\n-      register int len = first_rtl_op (code);\n-      register int i;\n+      int len = first_rtl_op (code);\n+      int i;\n       for (i = 0; i < len; i++)\n \t{\n \t  tree op = TREE_OPERAND (t, i);\n@@ -5544,7 +5544,7 @@ fold (expr)\n       /* (A << B) + (A >> (Z - B)) if A is unsigned and Z is the size of A\n \t is a rotate of A by B bits.  */\n       {\n-\tregister enum tree_code code0, code1;\n+\tenum tree_code code0, code1;\n \tcode0 = TREE_CODE (arg0);\n \tcode1 = TREE_CODE (arg1);\n \tif (((code0 == RSHIFT_EXPR && code1 == LSHIFT_EXPR)\n@@ -5553,8 +5553,8 @@ fold (expr)\n \t\t\t        TREE_OPERAND (arg1, 0), 0)\n \t    && TREE_UNSIGNED (TREE_TYPE (TREE_OPERAND (arg0, 0))))\n \t  {\n-\t    register tree tree01, tree11;\n-\t    register enum tree_code code01, code11;\n+\t    tree tree01, tree11;\n+\t    enum tree_code code01, code11;\n \n \t    tree01 = TREE_OPERAND (arg0, 1);\n \t    tree11 = TREE_OPERAND (arg1, 1);"}, {"sha": "19b9f5057984006ed9248f878494b3e05c441053", "filename": "gcc/function.c", "status": "modified", "additions": 36, "deletions": 36, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=b36948478c22c58018d0a888ee8ca393dea60dc9", "patch": "@@ -523,7 +523,7 @@ assign_stack_local_1 (mode, size, align, function)\n      int align;\n      struct function *function;\n {\n-  register rtx x, addr;\n+  rtx x, addr;\n   int bigend_correction = 0;\n   int alignment;\n \n@@ -1303,7 +1303,7 @@ void\n put_var_into_stack (decl)\n      tree decl;\n {\n-  register rtx reg;\n+  rtx reg;\n   enum machine_mode promoted_mode, decl_mode;\n   struct function *function = 0;\n   tree context;\n@@ -1879,17 +1879,17 @@ fixup_var_refs_insn (insn, var, promoted_mode, unsignedp, toplevel)\n \n static void\n fixup_var_refs_1 (var, promoted_mode, loc, insn, replacements)\n-     register rtx var;\n+     rtx var;\n      enum machine_mode promoted_mode;\n-     register rtx *loc;\n+     rtx *loc;\n      rtx insn;\n      struct fixup_replacement **replacements;\n {\n-  register int i;\n-  register rtx x = *loc;\n+  int i;\n+  rtx x = *loc;\n   RTX_CODE code = GET_CODE (x);\n-  register const char *fmt;\n-  register rtx tem, tem1;\n+  const char *fmt;\n+  rtx tem, tem1;\n   struct fixup_replacement *replacement;\n \n   switch (code)\n@@ -2458,7 +2458,7 @@ fixup_var_refs_1 (var, promoted_mode, loc, insn, replacements)\n \tfixup_var_refs_1 (var, promoted_mode, &XEXP (x, i), insn, replacements);\n       else if (fmt[i] == 'E')\n \t{\n-\t  register int j;\n+\t  int j;\n \t  for (j = 0; j < XVECLEN (x, i); j++)\n \t    fixup_var_refs_1 (var, promoted_mode, &XVECEXP (x, i, j),\n \t\t\t      insn, replacements);\n@@ -2512,13 +2512,13 @@ fixup_memory_subreg (x, insn, uncritical)\n \n static rtx\n walk_fixup_memory_subreg (x, insn, uncritical)\n-     register rtx x;\n+     rtx x;\n      rtx insn;\n      int uncritical;\n {\n-  register enum rtx_code code;\n-  register const char *fmt;\n-  register int i;\n+  enum rtx_code code;\n+  const char *fmt;\n+  int i;\n \n   if (x == 0)\n     return 0;\n@@ -2537,7 +2537,7 @@ walk_fixup_memory_subreg (x, insn, uncritical)\n \tXEXP (x, i) = walk_fixup_memory_subreg (XEXP (x, i), insn, uncritical);\n       else if (fmt[i] == 'E')\n \t{\n-\t  register int j;\n+\t  int j;\n \t  for (j = 0; j < XVECLEN (x, i); j++)\n \t    XVECEXP (x, i, j)\n \t      = walk_fixup_memory_subreg (XVECEXP (x, i, j), insn, uncritical);\n@@ -2557,13 +2557,13 @@ fixup_stack_1 (x, insn)\n      rtx x;\n      rtx insn;\n {\n-  register int i;\n-  register RTX_CODE code = GET_CODE (x);\n-  register const char *fmt;\n+  int i;\n+  RTX_CODE code = GET_CODE (x);\n+  const char *fmt;\n \n   if (code == MEM)\n     {\n-      register rtx ad = XEXP (x, 0);\n+      rtx ad = XEXP (x, 0);\n       /* If we have address of a stack slot but it's not valid\n \t (displacement is too large), compute the sum in a register.  */\n       if (GET_CODE (ad) == PLUS\n@@ -2600,7 +2600,7 @@ fixup_stack_1 (x, insn)\n \tXEXP (x, i) = fixup_stack_1 (XEXP (x, i), insn);\n       else if (fmt[i] == 'E')\n \t{\n-\t  register int j;\n+\t  int j;\n \t  for (j = 0; j < XVECLEN (x, i); j++)\n \t    XVECEXP (x, i, j) = fixup_stack_1 (XVECEXP (x, i, j), insn);\n \t}\n@@ -2625,7 +2625,7 @@ optimize_bit_field (body, insn, equiv_mem)\n      rtx insn;\n      rtx *equiv_mem;\n {\n-  register rtx bitfield;\n+  rtx bitfield;\n   int destflag;\n   rtx seq = 0;\n   enum machine_mode mode;\n@@ -2645,7 +2645,7 @@ optimize_bit_field (body, insn, equiv_mem)\n \t  != BLKmode)\n       && INTVAL (XEXP (bitfield, 2)) % INTVAL (XEXP (bitfield, 1)) == 0)\n     {\n-      register rtx memref = 0;\n+      rtx memref = 0;\n \n       /* Now check that the containing word is memory, not a register,\n \t and that it is safe to change the machine mode.  */\n@@ -4150,8 +4150,8 @@ get_first_nonparm_insn ()\n rtx\n get_first_block_beg ()\n {\n-  register rtx searcher;\n-  register rtx insn = get_first_nonparm_insn ();\n+  rtx searcher;\n+  rtx insn = get_first_nonparm_insn ();\n \n   for (searcher = insn; searcher; searcher = NEXT_INSN (searcher))\n     if (GET_CODE (searcher) == NOTE\n@@ -4211,9 +4211,9 @@ void\n assign_parms (fndecl)\n      tree fndecl;\n {\n-  register tree parm;\n-  register rtx entry_parm = 0;\n-  register rtx stack_parm = 0;\n+  tree parm;\n+  rtx entry_parm = 0;\n+  rtx stack_parm = 0;\n   CUMULATIVE_ARGS args_so_far;\n   enum machine_mode promoted_mode, passed_mode;\n   enum machine_mode nominal_mode, promoted_nominal_mode;\n@@ -4660,7 +4660,7 @@ assign_parms (fndecl)\n \t  /* Store the parm in a pseudoregister during the function, but we\n \t     may need to do it in a wider mode.  */\n \n-\t  register rtx parmreg;\n+\t  rtx parmreg;\n \t  unsigned int regno, regnoi = 0, regnor = 0;\n \n \t  unsignedp = TREE_UNSIGNED (TREE_TYPE (parm));\n@@ -5354,7 +5354,7 @@ void\n uninitialized_vars_warning (block)\n      tree block;\n {\n-  register tree decl, sub;\n+  tree decl, sub;\n   for (decl = BLOCK_VARS (block); decl; decl = TREE_CHAIN (decl))\n     {\n       if (warn_uninitialized\n@@ -5395,7 +5395,7 @@ uninitialized_vars_warning (block)\n void\n setjmp_args_warning ()\n {\n-  register tree decl;\n+  tree decl;\n   for (decl = DECL_ARGUMENTS (current_function_decl);\n        decl; decl = TREE_CHAIN (decl))\n     if (DECL_RTL (decl) != 0\n@@ -5412,7 +5412,7 @@ void\n setjmp_protect (block)\n      tree block;\n {\n-  register tree decl, sub;\n+  tree decl, sub;\n   for (decl = BLOCK_VARS (block); decl; decl = TREE_CHAIN (decl))\n     if ((TREE_CODE (decl) == VAR_DECL\n \t || TREE_CODE (decl) == PARM_DECL)\n@@ -5444,7 +5444,7 @@ setjmp_protect (block)\n void\n setjmp_protect_args ()\n {\n-  register tree decl;\n+  tree decl;\n   for (decl = DECL_ARGUMENTS (current_function_decl);\n        decl; decl = TREE_CHAIN (decl))\n     if ((TREE_CODE (decl) == VAR_DECL\n@@ -5969,7 +5969,7 @@ static tree\n blocks_nreverse (t)\n      tree t;\n {\n-  register tree prev = 0, decl, next;\n+  tree prev = 0, decl, next;\n   for (decl = t; decl; decl = next)\n     {\n       next = BLOCK_CHAIN (decl);\n@@ -6403,7 +6403,7 @@ expand_function_start (subr, parms_have_cleanups)\n   if (aggregate_value_p (DECL_RESULT (subr)))\n     {\n       /* Returning something that won't go in a register.  */\n-      register rtx value_address = 0;\n+      rtx value_address = 0;\n \n #ifdef PCC_STATIC_STRUCT_RETURN\n       if (current_function_returns_pcc_struct)\n@@ -7046,7 +7046,7 @@ contains (insn, vec)\n      rtx insn;\n      varray_type vec;\n {\n-  register int i, j;\n+  int i, j;\n \n   if (GET_CODE (insn) == INSN\n       && GET_CODE (PATTERN (insn)) == SEQUENCE)\n@@ -7487,7 +7487,7 @@ reposition_prologue_and_epilogue_notes (f)\n \n   if ((len = VARRAY_SIZE (prologue)) > 0)\n     {\n-      register rtx insn, note = 0;\n+      rtx insn, note = 0;\n \n       /* Scan from the beginning until we reach the last prologue insn.\n \t We apparently can't depend on basic_block_{head,end} after\n@@ -7530,7 +7530,7 @@ reposition_prologue_and_epilogue_notes (f)\n \n   if ((len = VARRAY_SIZE (epilogue)) > 0)\n     {\n-      register rtx insn, note = 0;\n+      rtx insn, note = 0;\n \n       /* Scan from the end until we reach the first epilogue insn.\n \t We apparently can't depend on basic_block_{head,end} after"}, {"sha": "f49804019ea4e24d8abc8594d3c5a4c92aaec890", "filename": "gcc/gcc.c", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Fgcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Fgcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc.c?ref=b36948478c22c58018d0a888ee8ca393dea60dc9", "patch": "@@ -1737,7 +1737,7 @@ read_specs (filename, main_p)\n      int main_p;\n {\n   char *buffer;\n-  register char *p;\n+  char *p;\n \n   buffer = load_specs (filename);\n \n@@ -2003,11 +2003,11 @@ record_temp_file (filename, always_delete, fail_delete)\n      int always_delete;\n      int fail_delete;\n {\n-  register char *const name = xstrdup (filename);\n+  char *const name = xstrdup (filename);\n \n   if (always_delete)\n     {\n-      register struct temp_file *temp;\n+      struct temp_file *temp;\n       for (temp = always_delete_queue; temp; temp = temp->next)\n \tif (! strcmp (name, temp->name))\n \t  goto already1;\n@@ -2022,7 +2022,7 @@ record_temp_file (filename, always_delete, fail_delete)\n \n   if (fail_delete)\n     {\n-      register struct temp_file *temp;\n+      struct temp_file *temp;\n       for (temp = failure_delete_queue; temp; temp = temp->next)\n \tif (! strcmp (name, temp->name))\n \t  goto already2;\n@@ -2064,7 +2064,7 @@ delete_if_ordinary (name)\n static void\n delete_temp_files ()\n {\n-  register struct temp_file *temp;\n+  struct temp_file *temp;\n \n   for (temp = always_delete_queue; temp; temp = temp->next)\n     delete_if_ordinary (temp->name);\n@@ -2076,7 +2076,7 @@ delete_temp_files ()\n static void\n delete_failure_queue ()\n {\n-  register struct temp_file *temp;\n+  struct temp_file *temp;\n \n   for (temp = failure_delete_queue; temp; temp = temp->next)\n     delete_if_ordinary (temp->name);\n@@ -3065,7 +3065,7 @@ process_command (argc, argv)\n      int argc;\n      const char *const *argv;\n {\n-  register int i;\n+  int i;\n   const char *temp;\n   char *temp1;\n   const char *spec_lang = 0;\n@@ -3413,8 +3413,8 @@ process_command (argc, argv)\n \treport_times = 1;\n       else if (argv[i][0] == '-' && argv[i][1] != 0)\n \t{\n-\t  register const char *p = &argv[i][1];\n-\t  register int c = *p;\n+\t  const char *p = &argv[i][1];\n+\t  int c = *p;\n \n \t  switch (c)\n \t    {\n@@ -4060,8 +4060,8 @@ do_spec_1 (spec, inswitch, soft_matched_part)\n      int inswitch;\n      const char *soft_matched_part;\n {\n-  register const char *p = spec;\n-  register int c;\n+  const char *p = spec;\n+  int c;\n   int i;\n   const char *string;\n   int value;\n@@ -5004,7 +5004,7 @@ do_spec_1 (spec, inswitch, soft_matched_part)\n \n static const char *\n handle_braces (p)\n-     register const char *p;\n+     const char *p;\n {\n   const char *filter, *body = NULL, *endbody = NULL;\n   int pipe_p = 0;\n@@ -5076,8 +5076,8 @@ handle_braces (p)\n     {\n       if (*p != '}' && *p != '&')\n \t{\n-\t  register int count = 1;\n-\t  register const char *q = p;\n+\t  int count = 1;\n+\t  const char *q = p;\n \n \t  while (*q++ != ':')\n \t    continue;\n@@ -5115,7 +5115,7 @@ handle_braces (p)\n   else if (p[-1] == '*' && (p[0] == '}' || p[0] == '&'))\n     {\n       /* Substitute all matching switches as separate args.  */\n-      register int i;\n+      int i;\n \n       for (i = 0; i < n_switches; i++)\n \tif (!strncmp (switches[i].part1, filter, p - 1 - filter)\n@@ -5133,7 +5133,7 @@ handle_braces (p)\n   else\n     {\n       /* Test for presence of the specified switch.  */\n-      register int i;\n+      int i;\n       int present = 0;\n \n       /* If name specified ends in *, as in {x*:...},\n@@ -5487,7 +5487,7 @@ static void\n set_input (filename)\n      const char *filename;\n {\n-  register const char *p;\n+  const char *p;\n \n   input_filename = filename;\n   input_filename_length = strlen (input_filename);\n@@ -6138,7 +6138,7 @@ save_string (s, len)\n      const char *s;\n      int len;\n {\n-  register char *result = xmalloc (len + 1);\n+  char *result = xmalloc (len + 1);\n \n   memcpy (result, s, len);\n   result[len] = 0;\n@@ -6232,8 +6232,8 @@ static void\n validate_all_switches ()\n {\n   struct compiler *comp;\n-  register const char *p;\n-  register char c;\n+  const char *p;\n+  char c;\n   struct spec_list *spec;\n \n   for (comp = compilers; comp->spec; comp++)\n@@ -6269,9 +6269,9 @@ static void\n validate_switches (start)\n      const char *start;\n {\n-  register const char *p = start;\n+  const char *p = start;\n   const char *filter;\n-  register int i;\n+  int i;\n   int suffix;\n \n   if (*p == '|')"}, {"sha": "0119f6742435b94baa7b38cdc747608644b16910", "filename": "gcc/gcse.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=b36948478c22c58018d0a888ee8ca393dea60dc9", "patch": "@@ -1798,9 +1798,9 @@ static int\n expr_equiv_p (x, y)\n      rtx x, y;\n {\n-  register int i, j;\n-  register enum rtx_code code;\n-  register const char *fmt;\n+  int i, j;\n+  enum rtx_code code;\n+  const char *fmt;\n \n   if (x == y)\n     return 1;"}, {"sha": "8e535b5eb5cd1b5887b2646fc34976b57b7785ac", "filename": "gcc/gen-protos.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Fgen-protos.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Fgen-protos.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgen-protos.c?ref=b36948478c22c58018d0a888ee8ca393dea60dc9", "patch": "@@ -69,7 +69,7 @@ parse_fn_proto (start, end, fn)\n      char *start, *end;\n      struct fn_decl *fn;\n {\n-  register char *ptr;\n+  char *ptr;\n   int param_nesting = 1;\n   char *param_start, *param_end, *decl_start, *name_start, *name_end;\n "}, {"sha": "060f24a03276e97c85a71d8590e68de08dc35477", "filename": "gcc/genattrtab.c", "status": "modified", "additions": 36, "deletions": 36, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Fgenattrtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Fgenattrtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenattrtab.c?ref=b36948478c22c58018d0a888ee8ca393dea60dc9", "patch": "@@ -503,7 +503,7 @@ attr_hash_add_rtx (hashcode, rtl)\n      int hashcode;\n      rtx rtl;\n {\n-  register struct attr_hash *h;\n+  struct attr_hash *h;\n \n   h = (struct attr_hash *) obstack_alloc (hash_obstack,\n \t\t\t\t\t  sizeof (struct attr_hash));\n@@ -520,7 +520,7 @@ attr_hash_add_string (hashcode, str)\n      int hashcode;\n      char *str;\n {\n-  register struct attr_hash *h;\n+  struct attr_hash *h;\n \n   h = (struct attr_hash *) obstack_alloc (hash_obstack,\n \t\t\t\t\t  sizeof (struct attr_hash));\n@@ -547,11 +547,11 @@ attr_rtx VPARAMS ((enum rtx_code code, ...))\n   enum rtx_code code;\n #endif\n   va_list p;\n-  register int i;\t\t/* Array indices...\t\t\t*/\n-  register const char *fmt;\t/* Current rtx's format...\t\t*/\n-  register rtx rt_val = NULL_RTX;/* RTX to return to caller...\t\t*/\n+  int i;\t\t/* Array indices...\t\t\t*/\n+  const char *fmt;\t/* Current rtx's format...\t\t*/\n+  rtx rt_val = NULL_RTX;/* RTX to return to caller...\t\t*/\n   int hashcode;\n-  register struct attr_hash *h;\n+  struct attr_hash *h;\n   struct obstack *old_obstack = rtl_obstack;\n \n   VA_START (p, code);\n@@ -743,7 +743,7 @@ attr_rtx VPARAMS ((enum rtx_code code, ...))\n    rtx attr_printf (len, format, [arg1, ..., argn])  */\n \n static char *\n-attr_printf VPARAMS ((register unsigned int len, const char *fmt, ...))\n+attr_printf VPARAMS ((unsigned int len, const char *fmt, ...))\n {\n   char str[256];\n \n@@ -783,10 +783,10 @@ attr_string (str, len)\n      const char *str;\n      int len;\n {\n-  register struct attr_hash *h;\n+  struct attr_hash *h;\n   int hashcode;\n   int i;\n-  register char *new_str;\n+  char *new_str;\n \n   /* Compute the hash code.  */\n   hashcode = (len + 1) * 613 + (unsigned) str[0];\n@@ -828,12 +828,12 @@ attr_equal_p (x, y)\n \n static rtx\n attr_copy_rtx (orig)\n-     register rtx orig;\n+     rtx orig;\n {\n-  register rtx copy;\n-  register int i, j;\n-  register RTX_CODE code;\n-  register const char *format_ptr;\n+  rtx copy;\n+  int i, j;\n+  RTX_CODE code;\n+  const char *format_ptr;\n \n   /* No need to copy a permanent object.  */\n   if (RTX_INTEGRATED_P (orig))\n@@ -2260,10 +2260,10 @@ static rtx\n encode_units_mask (x)\n      rtx x;\n {\n-  register int i;\n-  register int j;\n-  register enum rtx_code code;\n-  register const char *fmt;\n+  int i;\n+  int j;\n+  enum rtx_code code;\n+  const char *fmt;\n \n   code = GET_CODE (x);\n \n@@ -4024,7 +4024,7 @@ static rtx\n simplify_with_current_value_aux (exp)\n      rtx exp;\n {\n-  register int i;\n+  int i;\n   rtx cond;\n \n   switch (GET_CODE (exp))\n@@ -4103,10 +4103,10 @@ static void\n clear_struct_flag (x)\n      rtx x;\n {\n-  register int i;\n-  register int j;\n-  register enum rtx_code code;\n-  register const char *fmt;\n+  int i;\n+  int j;\n+  enum rtx_code code;\n+  const char *fmt;\n \n   MEM_IN_STRUCT_P (x) = 0;\n   if (RTX_UNCHANGING_P (x))\n@@ -4161,10 +4161,10 @@ count_sub_rtxs (x, max)\n      rtx x;\n      int max;\n {\n-  register int i;\n-  register int j;\n-  register enum rtx_code code;\n-  register const char *fmt;\n+  int i;\n+  int j;\n+  enum rtx_code code;\n+  const char *fmt;\n   int total = 0;\n \n   code = GET_CODE (x);\n@@ -4907,8 +4907,8 @@ static void\n walk_attr_value (exp)\n      rtx exp;\n {\n-  register int i, j;\n-  register const char *fmt;\n+  int i, j;\n+  const char *fmt;\n   RTX_CODE code;\n \n   if (exp == NULL)\n@@ -5276,11 +5276,11 @@ write_expr_attr_cache (p, attr)\n \treturn 0;\n \n       if (!attr->is_numeric)\n-\tprintf (\"  register enum attr_%s \", attr->name);\n+\tprintf (\"  enum attr_%s \", attr->name);\n       else if (attr->unsigned_p)\n-\tprintf (\"  register unsigned int \");\n+\tprintf (\"  unsigned int \");\n       else\n-\tprintf (\"  register int \");\n+\tprintf (\"  int \");\n \n       printf (\"attr_%s = get_attr_%s (insn);\\n\", attr->name, attr->name);\n       return 1;\n@@ -5325,7 +5325,7 @@ write_toplevel_expr (p)\n       if (!attr->is_const)\n \twrite_expr_attr_cache (p, attr);\n \n-  printf (\"  register unsigned long accum = 0;\\n\\n\");\n+  printf (\"  unsigned long accum = 0;\\n\\n\");\n \n   while (GET_CODE (p) == IOR)\n     {\n@@ -5983,11 +5983,11 @@ extend_range (range, min, max)\n \n static rtx\n copy_rtx_unchanging (orig)\n-     register rtx orig;\n+     rtx orig;\n {\n #if 0\n-  register rtx copy;\n-  register RTX_CODE code;\n+  rtx copy;\n+  RTX_CODE code;\n #endif\n \n   if (RTX_UNCHANGING_P (orig) || MEM_IN_STRUCT_P (orig))"}, {"sha": "87364505d8f4cf7f1eb93d5c0a21e36da6a8707c", "filename": "gcc/gencheck.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Fgencheck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Fgencheck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgencheck.c?ref=b36948478c22c58018d0a888ee8ca393dea60dc9", "patch": "@@ -77,9 +77,9 @@ main (argc, argv)\n    we link against libiberty.a. (ghazi@caip.rutgers.edu 6/3/98) */\n PTR\n xmalloc (nbytes)\n-  size_t nbytes;\n+     size_t nbytes;\n {\n-  register PTR tmp = (PTR) really_call_malloc (nbytes);\n+  PTR tmp = (PTR) really_call_malloc (nbytes);\n \n   if (!tmp)\n     {"}, {"sha": "f9ae6d5e3cec7f3f1d594178f6d5efee9a65a4c2", "filename": "gcc/genconfig.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Fgenconfig.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Fgenconfig.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenconfig.c?ref=b36948478c22c58018d0a888ee8ca393dea60dc9", "patch": "@@ -67,9 +67,9 @@ walk_insn_part (part, recog_p, non_pc_set_src)\n      int recog_p;\n      int non_pc_set_src;\n {\n-  register int i, j;\n-  register RTX_CODE code;\n-  register const char *format_ptr;\n+  int i, j;\n+  RTX_CODE code;\n+  const char *format_ptr;\n \n   if (part == 0)\n     return;"}, {"sha": "24d41874c51ef6d55417d7da1d315b72d305846e", "filename": "gcc/genemit.c", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Fgenemit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Fgenemit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenemit.c?ref=b36948478c22c58018d0a888ee8ca393dea60dc9", "patch": "@@ -72,10 +72,10 @@ static void\n max_operand_1 (x)\n      rtx x;\n {\n-  register RTX_CODE code;\n-  register int i;\n-  register int len;\n-  register const char *fmt;\n+  RTX_CODE code;\n+  int i;\n+  int len;\n+  const char *fmt;\n \n   if (x == 0)\n     return;\n@@ -114,8 +114,8 @@ max_operand_vec (insn, arg)\n      rtx insn;\n      int arg;\n {\n-  register int len = XVECLEN (insn, arg);\n-  register int i;\n+  int len = XVECLEN (insn, arg);\n+  int i;\n \n   max_opno = -1;\n   max_dup_opno = -1;\n@@ -131,7 +131,7 @@ static void\n print_code (code)\n      RTX_CODE code;\n {\n-  register const char *p1;\n+  const char *p1;\n   for (p1 = GET_RTX_NAME (code); *p1; p1++)\n     putchar (TOUPPER(*p1));\n }\n@@ -159,10 +159,10 @@ gen_exp (x, subroutine_type)\n      rtx x;\n      enum rtx_code subroutine_type;\n {\n-  register RTX_CODE code;\n-  register int i;\n-  register int len;\n-  register const char *fmt;\n+  RTX_CODE code;\n+  int i;\n+  int len;\n+  const char *fmt;\n \n   if (x == 0)\n     {\n@@ -291,7 +291,7 @@ gen_insn (insn)\n      rtx insn;\n {\n   int operands;\n-  register int i;\n+  int i;\n \n   /* See if the pattern for this insn ends with a group of CLOBBERs of (hard)\n      registers or MATCH_SCRATCHes.  If so, store away the information for\n@@ -314,10 +314,10 @@ gen_insn (insn)\n \n       if (i != XVECLEN (insn, 1) - 1)\n \t{\n-\t  register struct clobber_pat *p;\n-\t  register struct clobber_ent *link\n+\t  struct clobber_pat *p;\n+\t  struct clobber_ent *link\n \t    = (struct clobber_ent *) xmalloc (sizeof (struct clobber_ent));\n-\t  register int j;\n+\t  int j;\n \n \t  link->code_number = insn_code_number;\n \n@@ -421,7 +421,7 @@ gen_expand (expand)\n      rtx expand;\n {\n   int operands;\n-  register int i;\n+  int i;\n \n   if (strlen (XSTR (expand, 0)) == 0)\n     fatal (\"define_expand lacks a name\");\n@@ -556,7 +556,7 @@ static void\n gen_split (split)\n      rtx split;\n {\n-  register int i;\n+  int i;\n   int operands;\n   const char *const name =\n     ((GET_CODE (split) == DEFINE_PEEPHOLE2) ? \"peephole2\" : \"split\");"}, {"sha": "80602d701c10b853e9f958e024a0fcc6e798997e", "filename": "gcc/genextract.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Fgenextract.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Fgenextract.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenextract.c?ref=b36948478c22c58018d0a888ee8ca393dea60dc9", "patch": "@@ -102,9 +102,9 @@ static void\n gen_insn (insn)\n      rtx insn;\n {\n-  register int i;\n-  register struct extraction *p;\n-  register struct code_ptr *link;\n+  int i;\n+  struct extraction *p;\n+  struct code_ptr *link;\n \n   op_count = 0;\n   dup_count = 0;\n@@ -183,10 +183,10 @@ walk_rtx (x, path)\n      rtx x;\n      const char *path;\n {\n-  register RTX_CODE code;\n-  register int i;\n-  register int len;\n-  register const char *fmt;\n+  RTX_CODE code;\n+  int i;\n+  int len;\n+  const char *fmt;\n   int depth = strlen (path);\n   char *newpath;\n \n@@ -307,8 +307,8 @@ static void\n print_path (path)\n      const char *path;\n {\n-  register int len = strlen (path);\n-  register int i;\n+  int len = strlen (path);\n+  int i;\n \n   if (len == 0)\n     {\n@@ -387,8 +387,8 @@ from the machine description file `md'.  */\\n\\n\");\n   printf (\"void\\ninsn_extract (insn)\\n\");\n   printf (\"     rtx insn;\\n\");\n   printf (\"{\\n\");\n-  printf (\"  register rtx *ro = recog_data.operand;\\n\");\n-  printf (\"  register rtx **ro_loc = recog_data.operand_loc;\\n\");\n+  printf (\"  rtx *ro = recog_data.operand;\\n\");\n+  printf (\"  rtx **ro_loc = recog_data.operand_loc;\\n\");\n   printf (\"  rtx pat = PATTERN (insn);\\n\");\n   printf (\"  int i ATTRIBUTE_UNUSED;\\n\\n\");\n   printf (\"  memset (ro, 0, sizeof (*ro) * MAX_RECOG_OPERANDS);\\n\");"}, {"sha": "cd30af1f6f5f769018995693c865921ca80df46f", "filename": "gcc/genflags.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Fgenflags.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Fgenflags.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenflags.c?ref=b36948478c22c58018d0a888ee8ca393dea60dc9", "patch": "@@ -54,10 +54,10 @@ static void\n max_operand_1 (x)\n      rtx x;\n {\n-  register RTX_CODE code;\n-  register int i;\n-  register int len;\n-  register const char *fmt;\n+  RTX_CODE code;\n+  int i;\n+  int len;\n+  const char *fmt;\n \n   if (x == 0)\n     return;\n@@ -87,8 +87,8 @@ static int\n num_operands (insn)\n      rtx insn;\n {\n-  register int len = XVECLEN (insn, 1);\n-  register int i;\n+  int len = XVECLEN (insn, 1);\n+  int i;\n \n   max_opno = -1;\n "}, {"sha": "711cede5297a6c20d517ae76b1bc7fbcaccabe20", "filename": "gcc/gengenrtl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Fgengenrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Fgengenrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengenrtl.c?ref=b36948478c22c58018d0a888ee8ca393dea60dc9", "patch": "@@ -395,7 +395,7 @@ PTR\n xmalloc (nbytes)\n   size_t nbytes;\n {\n-  register PTR tmp = (PTR) really_call_malloc (nbytes);\n+  PTR tmp = (PTR) really_call_malloc (nbytes);\n \n   if (!tmp)\n     {"}, {"sha": "00b2903d949fcf78638bc97fbc96c4f19cf441d5", "filename": "gcc/genoutput.c", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Fgenoutput.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Fgenoutput.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenoutput.c?ref=b36948478c22c58018d0a888ee8ca393dea60dc9", "patch": "@@ -247,7 +247,7 @@ static void\n output_predicate_decls ()\n {\n   struct predicate *predicates = 0;\n-  register struct operand_data *d;\n+  struct operand_data *d;\n   struct predicate *p, *next;\n \n   for (d = odata; d; d = d->next)\n@@ -279,7 +279,7 @@ output_predicate_decls ()\n static void\n output_operand_data ()\n {\n-  register struct operand_data *d;\n+  struct operand_data *d;\n \n   printf (\"\\nstatic const struct insn_operand_data operand_data[] = \\n{\\n\");\n \n@@ -306,12 +306,12 @@ output_operand_data ()\n static void\n output_insn_data ()\n {\n-  register struct data *d;\n+  struct data *d;\n   int name_offset = 0;\n   int next_name_offset;\n   const char * last_name = 0;\n   const char * next_name = 0;\n-  register struct data *n;\n+  struct data *n;\n \n   for (n = idata, next_name_offset = 1; n; n = n->next, next_name_offset++)\n     if (n->name)\n@@ -429,8 +429,8 @@ scan_operands (d, part, this_address_p, this_strict_low)\n      int this_address_p;\n      int this_strict_low;\n {\n-  register int i, j;\n-  register const char *format_ptr;\n+  int i, j;\n+  const char *format_ptr;\n   int opno;\n \n   if (part == 0)\n@@ -662,8 +662,8 @@ process_template (d, template)\n     struct data *d;\n     const char *template;\n {\n-  register const char *cp;\n-  register int i;\n+  const char *cp;\n+  int i;\n \n   /* Templates starting with * contain straight code to be run.  */\n   if (template[0] == '*')\n@@ -732,7 +732,7 @@ static void\n validate_insn_alternatives (d)\n      struct data *d;\n {\n-  register int n = 0, start;\n+  int n = 0, start;\n \n   /* Make sure all the operands have the same number of alternatives\n      in their constraints.  Let N be that number.  */\n@@ -779,8 +779,8 @@ gen_insn (insn, lineno)\n      rtx insn;\n      int lineno;\n {\n-  register struct data *d = (struct data *) xmalloc (sizeof (struct data));\n-  register int i;\n+  struct data *d = (struct data *) xmalloc (sizeof (struct data));\n+  int i;\n \n   d->code_number = next_code_number;\n   d->index_number = next_index_number;\n@@ -821,8 +821,8 @@ gen_peephole (peep, lineno)\n      rtx peep;\n      int lineno;\n {\n-  register struct data *d = (struct data *) xmalloc (sizeof (struct data));\n-  register int i;\n+  struct data *d = (struct data *) xmalloc (sizeof (struct data));\n+  int i;\n \n   d->code_number = next_code_number;\n   d->index_number = next_index_number;\n@@ -861,8 +861,8 @@ gen_expand (insn, lineno)\n      rtx insn;\n      int lineno;\n {\n-  register struct data *d = (struct data *) xmalloc (sizeof (struct data));\n-  register int i;\n+  struct data *d = (struct data *) xmalloc (sizeof (struct data));\n+  int i;\n \n   d->code_number = next_code_number;\n   d->index_number = next_index_number;\n@@ -906,8 +906,8 @@ gen_split (split, lineno)\n      rtx split;\n      int lineno;\n {\n-  register struct data *d = (struct data *) xmalloc (sizeof (struct data));\n-  register int i;\n+  struct data *d = (struct data *) xmalloc (sizeof (struct data));\n+  int i;\n \n   d->code_number = next_code_number;\n   d->index_number = next_index_number;"}, {"sha": "4f0861f4471b239160fc53991bbfaf59ef01430e", "filename": "gcc/genpeep.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Fgenpeep.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Fgenpeep.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenpeep.c?ref=b36948478c22c58018d0a888ee8ca393dea60dc9", "patch": "@@ -146,10 +146,10 @@ match_rtx (x, path, fail_label)\n      struct link *path;\n      int fail_label;\n {\n-  register RTX_CODE code;\n-  register int i;\n-  register int len;\n-  register const char *fmt;\n+  RTX_CODE code;\n+  int i;\n+  int len;\n+  const char *fmt;\n   struct link link;\n \n   if (x == 0)\n@@ -364,7 +364,7 @@ static void\n print_code (code)\n      RTX_CODE code;\n {\n-  register const char *p1;\n+  const char *p1;\n   for (p1 = GET_RTX_NAME (code); *p1; p1++)\n     putchar (TOUPPER(*p1));\n }"}, {"sha": "7e1d849c70b8aec4e433e93f70554c4101ec5061", "filename": "gcc/genrecog.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Fgenrecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Fgenrecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenrecog.c?ref=b36948478c22c58018d0a888ee8ca393dea60dc9", "patch": "@@ -319,7 +319,7 @@ new_decision (position, last)\n      const char *position;\n      struct decision_head *last;\n {\n-  register struct decision *new\n+  struct decision *new\n     = (struct decision *) xmalloc (sizeof (struct decision));\n \n   memset (new, 0, sizeof (*new));\n@@ -777,8 +777,8 @@ add_to_sequence (pattern, last, position, insn_type, top)\n   struct decision_test *test;\n   struct decision_test **place;\n   char *subpos;\n-  register size_t i;\n-  register const char *fmt;\n+  size_t i;\n+  const char *fmt;\n   int depth = strlen (position);\n   int len;\n   enum machine_mode mode;\n@@ -1009,7 +1009,7 @@ add_to_sequence (pattern, last, position, insn_type, top)\n \n \tcase 'E':\n \t  {\n-\t    register int j;\n+\t    int j;\n \t    for (j = 0; j < XVECLEN (pattern, i); j++)\n \t      {\n \t\tsubpos[depth] = 'a' + j;\n@@ -1772,7 +1772,7 @@ static void\n print_code (code)\n      enum rtx_code code;\n {\n-  register const char *p;\n+  const char *p;\n   for (p = GET_RTX_NAME (code); *p; p++)\n     putchar (TOUPPER (*p));\n }\n@@ -2271,7 +2271,7 @@ write_tree (head, prevpos, type, initial)\n      enum routine_type type;\n      int initial;\n {\n-  register struct decision *p = head->first;\n+  struct decision *p = head->first;\n \n   putchar ('\\n');\n   if (p->need_label)\n@@ -2349,31 +2349,31 @@ write_subroutine (head, type)\n       printf (\"%sint recog%s PARAMS ((rtx, rtx, int *));\\n\", s_or_e, extension);\n       printf (\"%sint\\n\\\n recog%s (x0, insn, pnum_clobbers)\\n\\\n-     register rtx x0;\\n\\\n+     rtx x0;\\n\\\n      rtx insn ATTRIBUTE_UNUSED;\\n\\\n      int *pnum_clobbers ATTRIBUTE_UNUSED;\\n\", s_or_e, extension);\n       break;\n     case SPLIT:\n       printf (\"%srtx split%s PARAMS ((rtx, rtx));\\n\", s_or_e, extension);\n       printf (\"%srtx\\n\\\n split%s (x0, insn)\\n\\\n-     register rtx x0;\\n\\\n+     rtx x0;\\n\\\n      rtx insn ATTRIBUTE_UNUSED;\\n\", s_or_e, extension);\n       break;\n     case PEEPHOLE2:\n       printf (\"%srtx peephole2%s PARAMS ((rtx, rtx, int *));\\n\",\n \t      s_or_e, extension);\n       printf (\"%srtx\\n\\\n peephole2%s (x0, insn, _pmatch_len)\\n\\\n-     register rtx x0;\\n\\\n+     rtx x0;\\n\\\n      rtx insn ATTRIBUTE_UNUSED;\\n\\\n      int *_pmatch_len ATTRIBUTE_UNUSED;\\n\", s_or_e, extension);\n       break;\n     }\n \n-  printf (\"{\\n  register rtx * const operands ATTRIBUTE_UNUSED = &recog_data.operand[0];\\n\");\n+  printf (\"{\\n  rtx * const operands ATTRIBUTE_UNUSED = &recog_data.operand[0];\\n\");\n   for (i = 1; i <= max_depth; i++)\n-    printf (\"  register rtx x%d ATTRIBUTE_UNUSED;\\n\", i);\n+    printf (\"  rtx x%d ATTRIBUTE_UNUSED;\\n\", i);\n \n   printf (\"  %s tem ATTRIBUTE_UNUSED;\\n\", IS_SPLIT (type) ? \"rtx\" : \"int\");\n "}, {"sha": "e5ce347168e7751d642dddad7f22adf12681d2cd", "filename": "gcc/gensupport.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Fgensupport.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Fgensupport.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgensupport.c?ref=b36948478c22c58018d0a888ee8ca393dea60dc9", "patch": "@@ -112,8 +112,8 @@ static void\n remove_constraints (part)\n      rtx part;\n {\n-  register int i, j;\n-  register const char *format_ptr;\n+  int i, j;\n+  const char *format_ptr;\n \n   if (part == 0)\n     return;\n@@ -847,8 +847,8 @@ char *\n xstrdup (input)\n   const char *input;\n {\n-  register size_t len = strlen (input) + 1;\n-  register char *output = xmalloc (len);\n+  size_t len = strlen (input) + 1;\n+  char *output = xmalloc (len);\n   memcpy (output, input, len);\n   return output;\n }\n@@ -873,7 +873,7 @@ xrealloc (old, size)\n   PTR old;\n   size_t size;\n {\n-  register PTR ptr;\n+  PTR ptr;\n   if (old)\n     ptr = (PTR) really_call_realloc (old, size);\n   else\n@@ -887,7 +887,7 @@ PTR\n xmalloc (size)\n   size_t size;\n {\n-  register PTR val = (PTR) really_call_malloc (size);\n+  PTR val = (PTR) really_call_malloc (size);\n \n   if (val == 0)\n     fatal (\"virtual memory exhausted\");"}, {"sha": "a460755c29f8a0a6fe098aed24a7893b6b157997", "filename": "gcc/global.c", "status": "modified", "additions": 40, "deletions": 39, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Fglobal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Fglobal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fglobal.c?ref=b36948478c22c58018d0a888ee8ca393dea60dc9", "patch": "@@ -335,7 +335,7 @@ global_alloc (file)\n #endif\n        || FRAME_POINTER_REQUIRED);\n \n-  register size_t i;\n+  size_t i;\n   rtx x;\n \n   max_allocno = 0;\n@@ -614,11 +614,11 @@ allocno_compare (v1p, v2p)\n      times a register can occur in one insn (surely less than 100)\n      weighted by the frequency (maximally REG_FREQ_MAX).\n      Multiplying this by 10000/REG_FREQ_MAX can't overflow.  */\n-  register int pri1\n+  int pri1\n     = (((double) (floor_log2 (allocno[v1].n_refs) * allocno[v1].freq)\n \t/ allocno[v1].live_length)\n        * (10000 / REG_FREQ_MAX) * allocno[v1].size);\n-  register int pri2\n+  int pri2\n     = (((double) (floor_log2 (allocno[v2].n_refs) * allocno[v2].freq)\n \t/ allocno[v2].live_length)\n        * (10000 / REG_FREQ_MAX) * allocno[v2].size);\n@@ -636,8 +636,8 @@ allocno_compare (v1p, v2p)\n static void\n global_conflicts ()\n {\n-  register int b, i;\n-  register rtx insn;\n+  int b, i;\n+  rtx insn;\n   int *block_start_allocnos;\n \n   /* Make a vector that mark_reg_{store,clobber} will store in.  */\n@@ -664,13 +664,13 @@ global_conflicts ()\n \t are explicitly marked in basic_block_live_at_start.  */\n \n       {\n-\tregister regset old = BASIC_BLOCK (b)->global_live_at_start;\n+\tregset old = BASIC_BLOCK (b)->global_live_at_start;\n \tint ax = 0;\n \n \tREG_SET_TO_HARD_REG_SET (hard_regs_live, old);\n \tEXECUTE_IF_SET_IN_REG_SET (old, FIRST_PSEUDO_REGISTER, i,\n \t\t\t\t   {\n-\t\t\t\t     register int a = reg_allocno[i];\n+\t\t\t\t     int a = reg_allocno[i];\n \t\t\t\t     if (a >= 0)\n \t\t\t\t       {\n \t\t\t\t\t SET_ALLOCNO_LIVE (a);\n@@ -731,8 +731,8 @@ global_conflicts ()\n \n       while (1)\n \t{\n-\t  register RTX_CODE code = GET_CODE (insn);\n-\t  register rtx link;\n+\t  RTX_CODE code = GET_CODE (insn);\n+\t  rtx link;\n \n \t  /* Make regs_set an empty set.  */\n \n@@ -984,7 +984,7 @@ find_reg (num, losers, alt_regs_p, accept_call_clobbered, retrying)\n      int accept_call_clobbered;\n      int retrying;\n {\n-  register int i, best_reg, pass;\n+  int i, best_reg, pass;\n #ifdef HARD_REG_SET\n   register\t\t/* Declare it register if it's a scalar.  */\n #endif\n@@ -1048,8 +1048,8 @@ find_reg (num, losers, alt_regs_p, accept_call_clobbered, retrying)\n \t\t  || accept_call_clobbered\n \t\t  || ! HARD_REGNO_CALL_PART_CLOBBERED (regno, mode)))\n \t    {\n-\t      register int j;\n-\t      register int lim = regno + HARD_REGNO_NREGS (regno, mode);\n+\t      int j;\n+\t      int lim = regno + HARD_REGNO_NREGS (regno, mode);\n \t      for (j = regno + 1;\n \t\t   (j < lim\n \t\t    && ! TEST_HARD_REG_BIT (used, j));\n@@ -1092,8 +1092,8 @@ find_reg (num, losers, alt_regs_p, accept_call_clobbered, retrying)\n \t\t|| reg_class_subset_p (REGNO_REG_CLASS (best_reg),\n \t\t\t\t       REGNO_REG_CLASS (i))))\n \t    {\n-\t      register int j;\n-\t      register int lim = i + HARD_REGNO_NREGS (i, mode);\n+\t      int j;\n+\t      int lim = i + HARD_REGNO_NREGS (i, mode);\n \t      for (j = i + 1;\n \t\t   (j < lim\n \t\t    && ! TEST_HARD_REG_BIT (used, j)\n@@ -1128,8 +1128,8 @@ find_reg (num, losers, alt_regs_p, accept_call_clobbered, retrying)\n \t\t|| reg_class_subset_p (REGNO_REG_CLASS (best_reg),\n \t\t\t\t       REGNO_REG_CLASS (i))))\n \t    {\n-\t      register int j;\n-\t      register int lim = i + HARD_REGNO_NREGS (i, mode);\n+\t      int j;\n+\t      int lim = i + HARD_REGNO_NREGS (i, mode);\n \t      for (j = i + 1;\n \t\t   (j < lim\n \t\t    && ! TEST_HARD_REG_BIT (used, j)\n@@ -1246,7 +1246,7 @@ find_reg (num, losers, alt_regs_p, accept_call_clobbered, retrying)\n \n   if (best_reg >= 0)\n     {\n-      register int lim, j;\n+      int lim, j;\n       HARD_REG_SET this_reg;\n \n       /* Yes.  Record it as the hard register of this pseudo-reg.  */\n@@ -1322,7 +1322,7 @@ static void\n record_one_conflict (regno)\n      int regno;\n {\n-  register int j;\n+  int j;\n \n   if (regno < FIRST_PSEUDO_REGISTER)\n     /* When a hard register becomes live,\n@@ -1336,8 +1336,9 @@ record_one_conflict (regno)\n        record conflicts first with hard regs,\n        then with other pseudo regs.  */\n     {\n-      register int ialloc = reg_allocno[regno];\n-      register int ialloc_prod = ialloc * allocno_row_words;\n+      int ialloc = reg_allocno[regno];\n+      int ialloc_prod = ialloc * allocno_row_words;\n+\n       IOR_HARD_REG_SET (allocno[ialloc].hard_reg_conflicts, hard_regs_live);\n       for (j = allocno_row_words - 1; j >= 0; j--)\n \t{\n@@ -1363,11 +1364,11 @@ record_one_conflict (regno)\n \n static void\n record_conflicts (allocno_vec, len)\n-     register int *allocno_vec;\n-     register int len;\n+     int *allocno_vec;\n+     int len;\n {\n-  register int num;\n-  register int ialloc_prod;\n+  int num;\n+  int ialloc_prod;\n \n   while (--len >= 0)\n     {\n@@ -1381,7 +1382,7 @@ record_conflicts (allocno_vec, len)\n static void\n mirror_conflicts ()\n {\n-  register int i, j;\n+  int i, j;\n   int rw = allocno_row_words;\n   int rwb = rw * INT_BITS;\n   INT_TYPE *p = conflicts;\n@@ -1431,7 +1432,7 @@ mark_reg_store (reg, setter, data)\n      rtx reg, setter;\n      void *data ATTRIBUTE_UNUSED;\n {\n-  register int regno;\n+  int regno;\n \n   if (GET_CODE (reg) == SUBREG)\n     reg = SUBREG_REG (reg);\n@@ -1463,7 +1464,7 @@ mark_reg_store (reg, setter, data)\n   /* Handle hardware regs (and pseudos allocated to hard regs).  */\n   if (regno < FIRST_PSEUDO_REGISTER && ! fixed_regs[regno])\n     {\n-      register int last = regno + HARD_REGNO_NREGS (regno, GET_MODE (reg));\n+      int last = regno + HARD_REGNO_NREGS (regno, GET_MODE (reg));\n       while (regno < last)\n \t{\n \t  record_one_conflict (regno);\n@@ -1491,7 +1492,7 @@ static void\n mark_reg_conflicts (reg)\n      rtx reg;\n {\n-  register int regno;\n+  int regno;\n \n   if (GET_CODE (reg) == SUBREG)\n     reg = SUBREG_REG (reg);\n@@ -1515,7 +1516,7 @@ mark_reg_conflicts (reg)\n   /* Handle hardware regs (and pseudos allocated to hard regs).  */\n   if (regno < FIRST_PSEUDO_REGISTER && ! fixed_regs[regno])\n     {\n-      register int last = regno + HARD_REGNO_NREGS (regno, GET_MODE (reg));\n+      int last = regno + HARD_REGNO_NREGS (regno, GET_MODE (reg));\n       while (regno < last)\n \t{\n \t  record_one_conflict (regno);\n@@ -1531,7 +1532,7 @@ static void\n mark_reg_death (reg)\n      rtx reg;\n {\n-  register int regno = REGNO (reg);\n+  int regno = REGNO (reg);\n \n   /* Either this is one of the max_allocno pseudo regs not allocated,\n      or it is a hardware reg.  First handle the pseudo-regs.  */\n@@ -1550,7 +1551,7 @@ mark_reg_death (reg)\n     {\n       /* Pseudo regs already assigned hardware regs are treated\n \t almost the same as explicit hardware regs.  */\n-      register int last = regno + HARD_REGNO_NREGS (regno, GET_MODE (reg));\n+      int last = regno + HARD_REGNO_NREGS (regno, GET_MODE (reg));\n       while (regno < last)\n \t{\n \t  CLEAR_HARD_REG_BIT (hard_regs_live, regno);\n@@ -1566,10 +1567,10 @@ mark_reg_death (reg)\n \n static void\n mark_reg_live_nc (regno, mode)\n-     register int regno;\n+     int regno;\n      enum machine_mode mode;\n {\n-  register int last = regno + HARD_REGNO_NREGS (regno, mode);\n+  int last = regno + HARD_REGNO_NREGS (regno, mode);\n   while (regno < last)\n     {\n       SET_HARD_REG_BIT (hard_regs_live, regno);\n@@ -1702,7 +1703,7 @@ mark_elimination (from, to)\n \n   for (i = 0; i < n_basic_blocks; i++)\n     {\n-      register regset r = BASIC_BLOCK (i)->global_live_at_start; \n+      regset r = BASIC_BLOCK (i)->global_live_at_start; \n       if (REGNO_REG_SET_P (r, from))\n \t{\n \t  CLEAR_REGNO_REG_SET (r, from);\n@@ -1888,9 +1889,9 @@ static void\n dump_conflicts (file)\n      FILE *file;\n {\n-  register int i;\n-  register int has_preferences;\n-  register int nregs;\n+  int i;\n+  int has_preferences;\n+  int nregs;\n   nregs = 0;\n   for (i = 0; i < max_allocno; i++)\n     {\n@@ -1916,7 +1917,7 @@ dump_conflicts (file)\n \n   for (i = 0; i < max_allocno; i++)\n     {\n-      register int j;\n+      int j;\n       fprintf (file, \";; %d conflicts:\", allocno[i].reg);\n       for (j = 0; j < max_allocno; j++)\n \tif (CONFLICTP (j, i))\n@@ -1946,7 +1947,7 @@ void\n dump_global_regs (file)\n      FILE *file;\n {\n-  register int i, j;\n+  int i, j;\n   \n   fprintf (file, \";; Register dispositions:\\n\");\n   for (i = FIRST_PSEUDO_REGISTER, j = 0; i < max_regno; i++)"}, {"sha": "aa4fd166ea1aac5424206d783e5b4daa7556e201", "filename": "gcc/gmon.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Fgmon.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Fgmon.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgmon.c?ref=b36948478c22c58018d0a888ee8ca393dea60dc9", "patch": "@@ -74,7 +74,7 @@ monstartup(lowpc, highpc)\n {\n     int\t\t\tmonsize;\n     char\t\t*buffer;\n-    register int\to;\n+    int\t\t\to;\n \n \t/*\n \t *\tround lowpc and highpc to multiples of the density we're using"}, {"sha": "87230479bb4e839ed4c82fbb83695d226b50bfad", "filename": "gcc/graph.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Fgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Fgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraph.c?ref=b36948478c22c58018d0a888ee8ca393dea60dc9", "patch": "@@ -236,7 +236,7 @@ print_rtl_graph_with_bb (base, suffix, rtx_first)\n      const char *suffix;\n      rtx rtx_first;\n {\n-  register rtx tmp_rtx;\n+  rtx tmp_rtx;\n   size_t namelen = strlen (base);\n   size_t suffixlen = strlen (suffix);\n   size_t extlen = strlen (graph_ext[graph_dump_format]) + 1;"}, {"sha": "90c75460609a5a413643dd6d731a7cf42a9ed372", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=b36948478c22c58018d0a888ee8ca393dea60dc9", "patch": "@@ -360,7 +360,7 @@ HAIFA_INLINE int\n insn_unit (insn)\n      rtx insn;\n {\n-  register int unit = INSN_UNIT (insn);\n+  int unit = INSN_UNIT (insn);\n \n   if (unit == 0)\n     {\n@@ -646,7 +646,7 @@ HAIFA_INLINE int\n insn_cost (insn, link, used)\n      rtx insn, link, used;\n {\n-  register int cost = INSN_COST (insn);\n+  int cost = INSN_COST (insn);\n \n   if (cost == 0)\n     {\n@@ -1462,7 +1462,7 @@ queue_to_ready (ready)\n      of the pending insns at that point to the ready list.  */\n   if (ready->n_ready == 0)\n     {\n-      register int stalls;\n+      int stalls;\n \n       for (stalls = 1; stalls < INSN_QUEUE_SIZE; stalls++)\n \t{"}, {"sha": "a4ac4d02634f2641eedcee44f737e8c775b9ec0b", "filename": "gcc/hard-reg-set.h", "status": "modified", "additions": 56, "deletions": 56, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Fhard-reg-set.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Fhard-reg-set.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhard-reg-set.h?ref=b36948478c22c58018d0a888ee8ca393dea60dc9", "patch": "@@ -127,116 +127,116 @@ typedef HARD_REG_ELT_TYPE HARD_REG_SET[HARD_REG_SET_LONGS];\n \n #if FIRST_PSEUDO_REGISTER <= 2*HOST_BITS_PER_WIDE_INT\n #define CLEAR_HARD_REG_SET(TO)  \\\n-do { register HARD_REG_ELT_TYPE *scan_tp_ = (TO);\t\t\\\n+do { HARD_REG_ELT_TYPE *scan_tp_ = (TO);\t\t\t\\\n      scan_tp_[0] = 0;\t\t\t\t\t\t\\\n      scan_tp_[1] = 0; } while (0)\n \n #define SET_HARD_REG_SET(TO)  \\\n-do { register HARD_REG_ELT_TYPE *scan_tp_ = (TO);\t\t\\\n+do { HARD_REG_ELT_TYPE *scan_tp_ = (TO);\t\t\t\\\n      scan_tp_[0] = -1;\t\t\t\t\t\t\\\n      scan_tp_[1] = -1; } while (0)\n \n #define COPY_HARD_REG_SET(TO, FROM)  \\\n-do { register HARD_REG_ELT_TYPE *scan_tp_ = (TO), *scan_fp_ = (FROM);\t\\\n+do { HARD_REG_ELT_TYPE *scan_tp_ = (TO), *scan_fp_ = (FROM);\t\\\n      scan_tp_[0] = scan_fp_[0];\t\t\t\t\t\\\n      scan_tp_[1] = scan_fp_[1]; } while (0)\n \n #define COMPL_HARD_REG_SET(TO, FROM)  \\\n-do { register HARD_REG_ELT_TYPE *scan_tp_ = (TO), *scan_fp_ = (FROM); \\\n+do { HARD_REG_ELT_TYPE *scan_tp_ = (TO), *scan_fp_ = (FROM); \t\\\n      scan_tp_[0] = ~ scan_fp_[0];\t\t\t\t\\\n      scan_tp_[1] = ~ scan_fp_[1]; } while (0)\n \n #define AND_HARD_REG_SET(TO, FROM)  \\\n-do { register HARD_REG_ELT_TYPE *scan_tp_ = (TO), *scan_fp_ = (FROM); \\\n-     scan_tp_[0] &= scan_fp_[0];\t\t\t\t\t\\\n+do { HARD_REG_ELT_TYPE *scan_tp_ = (TO), *scan_fp_ = (FROM); \t\\\n+     scan_tp_[0] &= scan_fp_[0];\t\t\t\t\\\n      scan_tp_[1] &= scan_fp_[1]; } while (0)\n \n #define AND_COMPL_HARD_REG_SET(TO, FROM)  \\\n-do { register HARD_REG_ELT_TYPE *scan_tp_ = (TO), *scan_fp_ = (FROM); \\\n+do { HARD_REG_ELT_TYPE *scan_tp_ = (TO), *scan_fp_ = (FROM); \t\\\n      scan_tp_[0] &= ~ scan_fp_[0];\t\t\t\t\\\n      scan_tp_[1] &= ~ scan_fp_[1]; } while (0)\n \n #define IOR_HARD_REG_SET(TO, FROM)  \\\n-do { register HARD_REG_ELT_TYPE *scan_tp_ = (TO), *scan_fp_ = (FROM); \\\n+do { HARD_REG_ELT_TYPE *scan_tp_ = (TO), *scan_fp_ = (FROM); \t\\\n      scan_tp_[0] |= scan_fp_[0];\t\t\t\t\\\n      scan_tp_[1] |= scan_fp_[1]; } while (0)\n \n #define IOR_COMPL_HARD_REG_SET(TO, FROM)  \\\n-do { register HARD_REG_ELT_TYPE *scan_tp_ = (TO), *scan_fp_ = (FROM); \\\n+do { HARD_REG_ELT_TYPE *scan_tp_ = (TO), *scan_fp_ = (FROM); \t\\\n      scan_tp_[0] |= ~ scan_fp_[0];\t\t\t\t\\\n      scan_tp_[1] |= ~ scan_fp_[1]; } while (0)\n \n #define GO_IF_HARD_REG_SUBSET(X,Y,TO)  \\\n-do { register HARD_REG_ELT_TYPE *scan_xp_ = (X), *scan_yp_ = (Y); \\\n+do { HARD_REG_ELT_TYPE *scan_xp_ = (X), *scan_yp_ = (Y); \t\\\n      if ((0 == (scan_xp_[0] & ~ scan_yp_[0]))\t\t\t\\\n \t && (0 == (scan_xp_[1] & ~ scan_yp_[1])))\t\t\\\n \tgoto TO; } while (0)\n \n #define GO_IF_HARD_REG_EQUAL(X,Y,TO)  \\\n-do { register HARD_REG_ELT_TYPE *scan_xp_ = (X), *scan_yp_ = (Y); \\\n+do { HARD_REG_ELT_TYPE *scan_xp_ = (X), *scan_yp_ = (Y); \t\\\n      if ((scan_xp_[0] == scan_yp_[0])\t\t\t\t\\\n \t && (scan_xp_[1] == scan_yp_[1]))\t\t\t\\\n \tgoto TO; } while (0)\n \n #else\n #if FIRST_PSEUDO_REGISTER <= 3*HOST_BITS_PER_WIDE_INT\n #define CLEAR_HARD_REG_SET(TO)  \\\n-do { register HARD_REG_ELT_TYPE *scan_tp_ = (TO);\t\t\\\n+do { HARD_REG_ELT_TYPE *scan_tp_ = (TO);\t\t\t\\\n      scan_tp_[0] = 0;\t\t\t\t\t\t\\\n      scan_tp_[1] = 0;\t\t\t\t\t\t\\\n      scan_tp_[2] = 0; } while (0)\n \n #define SET_HARD_REG_SET(TO)  \\\n-do { register HARD_REG_ELT_TYPE *scan_tp_ = (TO);\t\t\\\n+do { HARD_REG_ELT_TYPE *scan_tp_ = (TO);\t\t\t\\\n      scan_tp_[0] = -1;\t\t\t\t\t\t\\\n      scan_tp_[1] = -1;\t\t\t\t\t\t\\\n      scan_tp_[2] = -1; } while (0)\n \n #define COPY_HARD_REG_SET(TO, FROM)  \\\n-do { register HARD_REG_ELT_TYPE *scan_tp_ = (TO), *scan_fp_ = (FROM);\t\\\n+do { HARD_REG_ELT_TYPE *scan_tp_ = (TO), *scan_fp_ = (FROM);\t\\\n      scan_tp_[0] = scan_fp_[0];\t\t\t\t\t\\\n      scan_tp_[1] = scan_fp_[1];\t\t\t\t\t\\\n      scan_tp_[2] = scan_fp_[2]; } while (0)\n \n #define COMPL_HARD_REG_SET(TO, FROM)  \\\n-do { register HARD_REG_ELT_TYPE *scan_tp_ = (TO), *scan_fp_ = (FROM); \\\n+do { HARD_REG_ELT_TYPE *scan_tp_ = (TO), *scan_fp_ = (FROM); \t\\\n      scan_tp_[0] = ~ scan_fp_[0];\t\t\t\t\\\n      scan_tp_[1] = ~ scan_fp_[1];\t\t\t\t\\\n      scan_tp_[2] = ~ scan_fp_[2]; } while (0)\n \n #define AND_HARD_REG_SET(TO, FROM)  \\\n-do { register HARD_REG_ELT_TYPE *scan_tp_ = (TO), *scan_fp_ = (FROM); \\\n-     scan_tp_[0] &= scan_fp_[0];\t\t\t\t\t\\\n-     scan_tp_[1] &= scan_fp_[1];\t\t\t\t\t\\\n+do { HARD_REG_ELT_TYPE *scan_tp_ = (TO), *scan_fp_ = (FROM); \t\\\n+     scan_tp_[0] &= scan_fp_[0];\t\t\t\t\\\n+     scan_tp_[1] &= scan_fp_[1];\t\t\t\t\\\n      scan_tp_[2] &= scan_fp_[2]; } while (0)\n \n #define AND_COMPL_HARD_REG_SET(TO, FROM)  \\\n-do { register HARD_REG_ELT_TYPE *scan_tp_ = (TO), *scan_fp_ = (FROM); \\\n+do { HARD_REG_ELT_TYPE *scan_tp_ = (TO), *scan_fp_ = (FROM); \t\\\n      scan_tp_[0] &= ~ scan_fp_[0];\t\t\t\t\\\n      scan_tp_[1] &= ~ scan_fp_[1];\t\t\t\t\\\n      scan_tp_[2] &= ~ scan_fp_[2]; } while (0)\n \n #define IOR_HARD_REG_SET(TO, FROM)  \\\n-do { register HARD_REG_ELT_TYPE *scan_tp_ = (TO), *scan_fp_ = (FROM); \\\n+do { HARD_REG_ELT_TYPE *scan_tp_ = (TO), *scan_fp_ = (FROM); \t\\\n      scan_tp_[0] |= scan_fp_[0];\t\t\t\t\\\n      scan_tp_[1] |= scan_fp_[1];\t\t\t\t\\\n      scan_tp_[2] |= scan_fp_[2]; } while (0)\n \n #define IOR_COMPL_HARD_REG_SET(TO, FROM)  \\\n-do { register HARD_REG_ELT_TYPE *scan_tp_ = (TO), *scan_fp_ = (FROM); \\\n+do { HARD_REG_ELT_TYPE *scan_tp_ = (TO), *scan_fp_ = (FROM); \t\\\n      scan_tp_[0] |= ~ scan_fp_[0];\t\t\t\t\\\n      scan_tp_[1] |= ~ scan_fp_[1];\t\t\t\t\\\n      scan_tp_[2] |= ~ scan_fp_[2]; } while (0)\n \n #define GO_IF_HARD_REG_SUBSET(X,Y,TO)  \\\n-do { register HARD_REG_ELT_TYPE *scan_xp_ = (X), *scan_yp_ = (Y); \\\n+do { HARD_REG_ELT_TYPE *scan_xp_ = (X), *scan_yp_ = (Y); \t\\\n      if ((0 == (scan_xp_[0] & ~ scan_yp_[0]))\t\t\t\\\n \t && (0 == (scan_xp_[1] & ~ scan_yp_[1]))\t\t\\\n \t && (0 == (scan_xp_[2] & ~ scan_yp_[2])))\t\t\\\n \tgoto TO; } while (0)\n \n #define GO_IF_HARD_REG_EQUAL(X,Y,TO)  \\\n-do { register HARD_REG_ELT_TYPE *scan_xp_ = (X), *scan_yp_ = (Y); \\\n+do { HARD_REG_ELT_TYPE *scan_xp_ = (X), *scan_yp_ = (Y); \t\\\n      if ((scan_xp_[0] == scan_yp_[0])\t\t\t\t\\\n \t && (scan_xp_[1] == scan_yp_[1])\t\t\t\\\n \t && (scan_xp_[2] == scan_yp_[2]))\t\t\t\\\n@@ -245,71 +245,71 @@ do { register HARD_REG_ELT_TYPE *scan_xp_ = (X), *scan_yp_ = (Y); \\\n #else\n #if FIRST_PSEUDO_REGISTER <= 4*HOST_BITS_PER_WIDE_INT\n #define CLEAR_HARD_REG_SET(TO)  \\\n-do { register HARD_REG_ELT_TYPE *scan_tp_ = (TO);\t\t\\\n+do { HARD_REG_ELT_TYPE *scan_tp_ = (TO);\t\t\t\\\n      scan_tp_[0] = 0;\t\t\t\t\t\t\\\n      scan_tp_[1] = 0;\t\t\t\t\t\t\\\n      scan_tp_[2] = 0;\t\t\t\t\t\t\\\n      scan_tp_[3] = 0; } while (0)\n \n #define SET_HARD_REG_SET(TO)  \\\n-do { register HARD_REG_ELT_TYPE *scan_tp_ = (TO);\t\t\\\n+do { HARD_REG_ELT_TYPE *scan_tp_ = (TO);\t\t\t\\\n      scan_tp_[0] = -1;\t\t\t\t\t\t\\\n      scan_tp_[1] = -1;\t\t\t\t\t\t\\\n      scan_tp_[2] = -1;\t\t\t\t\t\t\\\n      scan_tp_[3] = -1; } while (0)\n \n #define COPY_HARD_REG_SET(TO, FROM)  \\\n-do { register HARD_REG_ELT_TYPE *scan_tp_ = (TO), *scan_fp_ = (FROM);\t\\\n+do { HARD_REG_ELT_TYPE *scan_tp_ = (TO), *scan_fp_ = (FROM);\t\\\n      scan_tp_[0] = scan_fp_[0];\t\t\t\t\t\\\n      scan_tp_[1] = scan_fp_[1];\t\t\t\t\t\\\n      scan_tp_[2] = scan_fp_[2];\t\t\t\t\t\\\n      scan_tp_[3] = scan_fp_[3]; } while (0)\n \n #define COMPL_HARD_REG_SET(TO, FROM)  \\\n-do { register HARD_REG_ELT_TYPE *scan_tp_ = (TO), *scan_fp_ = (FROM); \\\n+do { HARD_REG_ELT_TYPE *scan_tp_ = (TO), *scan_fp_ = (FROM); \t\\\n      scan_tp_[0] = ~ scan_fp_[0];\t\t\t\t\\\n      scan_tp_[1] = ~ scan_fp_[1];\t\t\t\t\\\n      scan_tp_[2] = ~ scan_fp_[2];\t\t\t\t\\\n      scan_tp_[3] = ~ scan_fp_[3]; } while (0)\n \n #define AND_HARD_REG_SET(TO, FROM)  \\\n-do { register HARD_REG_ELT_TYPE *scan_tp_ = (TO), *scan_fp_ = (FROM); \\\n-     scan_tp_[0] &= scan_fp_[0];\t\t\t\t\t\\\n-     scan_tp_[1] &= scan_fp_[1];\t\t\t\t\t\\\n-     scan_tp_[2] &= scan_fp_[2];\t\t\t\t\t\\\n+do { HARD_REG_ELT_TYPE *scan_tp_ = (TO), *scan_fp_ = (FROM); \t\\\n+     scan_tp_[0] &= scan_fp_[0];\t\t\t\t\\\n+     scan_tp_[1] &= scan_fp_[1];\t\t\t\t\\\n+     scan_tp_[2] &= scan_fp_[2];\t\t\t\t\\\n      scan_tp_[3] &= scan_fp_[3]; } while (0)\n \n #define AND_COMPL_HARD_REG_SET(TO, FROM)  \\\n-do { register HARD_REG_ELT_TYPE *scan_tp_ = (TO), *scan_fp_ = (FROM); \\\n+do { HARD_REG_ELT_TYPE *scan_tp_ = (TO), *scan_fp_ = (FROM); \t\\\n      scan_tp_[0] &= ~ scan_fp_[0];\t\t\t\t\\\n      scan_tp_[1] &= ~ scan_fp_[1];\t\t\t\t\\\n      scan_tp_[2] &= ~ scan_fp_[2];\t\t\t\t\\\n      scan_tp_[3] &= ~ scan_fp_[3]; } while (0)\n \n #define IOR_HARD_REG_SET(TO, FROM)  \\\n-do { register HARD_REG_ELT_TYPE *scan_tp_ = (TO), *scan_fp_ = (FROM); \\\n+do { HARD_REG_ELT_TYPE *scan_tp_ = (TO), *scan_fp_ = (FROM); \t\\\n      scan_tp_[0] |= scan_fp_[0];\t\t\t\t\\\n      scan_tp_[1] |= scan_fp_[1];\t\t\t\t\\\n      scan_tp_[2] |= scan_fp_[2];\t\t\t\t\\\n      scan_tp_[3] |= scan_fp_[3]; } while (0)\n \n #define IOR_COMPL_HARD_REG_SET(TO, FROM)  \\\n-do { register HARD_REG_ELT_TYPE *scan_tp_ = (TO), *scan_fp_ = (FROM); \\\n+do { HARD_REG_ELT_TYPE *scan_tp_ = (TO), *scan_fp_ = (FROM); \t\\\n      scan_tp_[0] |= ~ scan_fp_[0];\t\t\t\t\\\n      scan_tp_[1] |= ~ scan_fp_[1];\t\t\t\t\\\n      scan_tp_[2] |= ~ scan_fp_[2];\t\t\t\t\\\n      scan_tp_[3] |= ~ scan_fp_[3]; } while (0)\n \n #define GO_IF_HARD_REG_SUBSET(X,Y,TO)  \\\n-do { register HARD_REG_ELT_TYPE *scan_xp_ = (X), *scan_yp_ = (Y); \\\n+do { HARD_REG_ELT_TYPE *scan_xp_ = (X), *scan_yp_ = (Y); \t\\\n      if ((0 == (scan_xp_[0] & ~ scan_yp_[0]))\t\t\t\\\n \t && (0 == (scan_xp_[1] & ~ scan_yp_[1]))\t\t\\\n \t && (0 == (scan_xp_[2] & ~ scan_yp_[2]))\t\t\\\n \t && (0 == (scan_xp_[3] & ~ scan_yp_[3])))\t\t\\\n \tgoto TO; } while (0)\n \n #define GO_IF_HARD_REG_EQUAL(X,Y,TO)  \\\n-do { register HARD_REG_ELT_TYPE *scan_xp_ = (X), *scan_yp_ = (Y); \\\n+do { HARD_REG_ELT_TYPE *scan_xp_ = (X), *scan_yp_ = (Y); \t\\\n      if ((scan_xp_[0] == scan_yp_[0])\t\t\t\t\\\n \t && (scan_xp_[1] == scan_yp_[1])\t\t\t\\\n \t && (scan_xp_[2] == scan_yp_[2])\t\t\t\\\n@@ -319,63 +319,63 @@ do { register HARD_REG_ELT_TYPE *scan_xp_ = (X), *scan_yp_ = (Y); \\\n #else /* FIRST_PSEUDO_REGISTER > 3*HOST_BITS_PER_WIDE_INT */\n \n #define CLEAR_HARD_REG_SET(TO)  \\\n-do { register HARD_REG_ELT_TYPE *scan_tp_ = (TO);\t\t\\\n-     register int i;\t\t\t\t\t\t\\\n+do { HARD_REG_ELT_TYPE *scan_tp_ = (TO);\t\t\t\\\n+     int i;\t\t\t\t\t\t\t\\\n      for (i = 0; i < HARD_REG_SET_LONGS; i++)\t\t\t\\\n        *scan_tp_++ = 0; } while (0)\n \n #define SET_HARD_REG_SET(TO)  \\\n-do { register HARD_REG_ELT_TYPE *scan_tp_ = (TO);\t\t\\\n-     register int i;\t\t\t\t\t\t\\\n+do { HARD_REG_ELT_TYPE *scan_tp_ = (TO);\t\t\t\\\n+     int i;\t\t\t\t\t\t\t\\\n      for (i = 0; i < HARD_REG_SET_LONGS; i++)\t\t\t\\\n        *scan_tp_++ = -1; } while (0)\n \n #define COPY_HARD_REG_SET(TO, FROM)  \\\n-do { register HARD_REG_ELT_TYPE *scan_tp_ = (TO), *scan_fp_ = (FROM); \\\n-     register int i;\t\t\t\t\t\t\\\n+do { HARD_REG_ELT_TYPE *scan_tp_ = (TO), *scan_fp_ = (FROM); \t\\\n+     int i;\t\t\t\t\t\t\t\\\n      for (i = 0; i < HARD_REG_SET_LONGS; i++)\t\t\t\\\n        *scan_tp_++ = *scan_fp_++; } while (0)\n \n #define COMPL_HARD_REG_SET(TO, FROM)  \\\n-do { register HARD_REG_ELT_TYPE *scan_tp_ = (TO), *scan_fp_ = (FROM); \\\n-     register int i;\t\t\t\t\t\t\\\n+do { HARD_REG_ELT_TYPE *scan_tp_ = (TO), *scan_fp_ = (FROM); \t\\\n+     int i;\t\t\t\t\t\t\t\\\n      for (i = 0; i < HARD_REG_SET_LONGS; i++)\t\t\t\\\n        *scan_tp_++ = ~ *scan_fp_++; } while (0)\n \n #define AND_HARD_REG_SET(TO, FROM)  \\\n-do { register HARD_REG_ELT_TYPE *scan_tp_ = (TO), *scan_fp_ = (FROM); \\\n-     register int i;\t\t\t\t\t\t\\\n+do { HARD_REG_ELT_TYPE *scan_tp_ = (TO), *scan_fp_ = (FROM); \t\\\n+     int i;\t\t\t\t\t\t\t\\\n      for (i = 0; i < HARD_REG_SET_LONGS; i++)\t\t\t\\\n        *scan_tp_++ &= *scan_fp_++; } while (0)\n \n #define AND_COMPL_HARD_REG_SET(TO, FROM)  \\\n-do { register HARD_REG_ELT_TYPE *scan_tp_ = (TO), *scan_fp_ = (FROM); \\\n-     register int i;\t\t\t\t\t\t\\\n+do { HARD_REG_ELT_TYPE *scan_tp_ = (TO), *scan_fp_ = (FROM); \t\\\n+     int i;\t\t\t\t\t\t\t\\\n      for (i = 0; i < HARD_REG_SET_LONGS; i++)\t\t\t\\\n        *scan_tp_++ &= ~ *scan_fp_++; } while (0)\n \n #define IOR_HARD_REG_SET(TO, FROM)  \\\n-do { register HARD_REG_ELT_TYPE *scan_tp_ = (TO), *scan_fp_ = (FROM); \\\n-     register int i;\t\t\t\t\t\t\\\n+do { HARD_REG_ELT_TYPE *scan_tp_ = (TO), *scan_fp_ = (FROM); \t\\\n+     int i;\t\t\t\t\t\t\t\\\n      for (i = 0; i < HARD_REG_SET_LONGS; i++)\t\t\t\\\n        *scan_tp_++ |= *scan_fp_++; } while (0)\n \n #define IOR_COMPL_HARD_REG_SET(TO, FROM)  \\\n-do { register HARD_REG_ELT_TYPE *scan_tp_ = (TO), *scan_fp_ = (FROM); \\\n-     register int i;\t\t\t\t\t\t\\\n+do { HARD_REG_ELT_TYPE *scan_tp_ = (TO), *scan_fp_ = (FROM); \t\\\n+     int i;\t\t\t\t\t\t\t\\\n      for (i = 0; i < HARD_REG_SET_LONGS; i++)\t\t\t\\\n        *scan_tp_++ |= ~ *scan_fp_++; } while (0)\n \n #define GO_IF_HARD_REG_SUBSET(X,Y,TO)  \\\n-do { register HARD_REG_ELT_TYPE *scan_xp_ = (X), *scan_yp_ = (Y); \\\n-     register int i;\t\t\t\t\t\t\\\n+do { HARD_REG_ELT_TYPE *scan_xp_ = (X), *scan_yp_ = (Y); \t\\\n+     int i;\t\t\t\t\t\t\t\\\n      for (i = 0; i < HARD_REG_SET_LONGS; i++)\t\t\t\\\n        if (0 != (*scan_xp_++ & ~ *scan_yp_++)) break;\t\t\\\n      if (i == HARD_REG_SET_LONGS) goto TO; } while (0)\n \n #define GO_IF_HARD_REG_EQUAL(X,Y,TO)  \\\n-do { register HARD_REG_ELT_TYPE *scan_xp_ = (X), *scan_yp_ = (Y); \\\n-     register int i;\t\t\t\t\t\t\\\n+do { HARD_REG_ELT_TYPE *scan_xp_ = (X), *scan_yp_ = (Y); \t\\\n+     int i;\t\t\t\t\t\t\t\\\n      for (i = 0; i < HARD_REG_SET_LONGS; i++)\t\t\t\\\n        if (*scan_xp_++ != *scan_yp_++) break;\t\t\t\\\n      if (i == HARD_REG_SET_LONGS) goto TO; } while (0)"}, {"sha": "5cf8397692d63e08954b6a3553a7c3eb935ec52d", "filename": "gcc/hash.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Fhash.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Fhash.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhash.c?ref=b36948478c22c58018d0a888ee8ca393dea60dc9", "patch": "@@ -91,7 +91,7 @@ hash_lookup (table, key, create, copy)\n      hash_table_key (*copy) PARAMS ((struct obstack* memory, \n \t\t\t\t     hash_table_key key));\n {\n-  register unsigned long hash;\n+  unsigned long hash;\n   struct hash_entry *hashp;\n   unsigned int index;\n   "}, {"sha": "1cbeca0608173f901503f1b4519d1c5912bae7c9", "filename": "gcc/integrate.c", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=b36948478c22c58018d0a888ee8ca393dea60dc9", "patch": "@@ -164,9 +164,9 @@ function_attribute_inlinable_p (fndecl)\n \n const char *\n function_cannot_inline_p (fndecl)\n-     register tree fndecl;\n+     tree fndecl;\n {\n-  register rtx insn;\n+  rtx insn;\n   tree last = tree_last (TYPE_ARG_TYPES (TREE_TYPE (fndecl)));\n \n   /* For functions marked as inline increase the maximum size to\n@@ -178,8 +178,8 @@ function_cannot_inline_p (fndecl)\n \t\t      + 8 * list_length (DECL_ARGUMENTS (fndecl)))\n \t\t   : INTEGRATE_THRESHOLD (fndecl);\n \n-  register int ninsns = 0;\n-  register tree parms;\n+  int ninsns = 0;\n+  tree parms;\n \n   if (DECL_UNINLINABLE (fndecl))\n     return N_(\"function cannot be inline\");\n@@ -655,7 +655,7 @@ expand_inline_function (fndecl, parms, target, ignore, type,\n   tree *arg_trees;\n   rtx *arg_vals;\n   int max_regno;\n-  register int i;\n+  int i;\n   int min_labelno = inl_f->emit->x_first_label_num;\n   int max_labelno = inl_f->inl_max_label_num;\n   int nargs;\n@@ -1315,7 +1315,7 @@ copy_insn_list (insns, map, static_chain_value)\n      struct inline_remap *map;\n      rtx static_chain_value;\n {\n-  register int i;\n+  int i;\n   rtx insn;\n   rtx temp;\n #ifdef HAVE_cc0\n@@ -1717,8 +1717,8 @@ integrate_parm_decls (args, map, arg_vector)\n      struct inline_remap *map;\n      rtvec arg_vector;\n {\n-  register tree tail;\n-  register int i;\n+  tree tail;\n+  int i;\n \n   for (tail = args, i = 0; tail; tail = TREE_CHAIN (tail), i++)\n     {\n@@ -1819,15 +1819,15 @@ integrate_decl_tree (let, map)\n \n rtx\n copy_rtx_and_substitute (orig, map, for_lhs)\n-     register rtx orig;\n+     rtx orig;\n      struct inline_remap *map;\n      int for_lhs;\n {\n-  register rtx copy, temp;\n-  register int i, j;\n-  register RTX_CODE code;\n-  register enum machine_mode mode;\n-  register const char *format_ptr;\n+  rtx copy, temp;\n+  int i, j;\n+  RTX_CODE code;\n+  enum machine_mode mode;\n+  const char *format_ptr;\n   int regno;\n \n   if (orig == 0)\n@@ -2409,9 +2409,9 @@ subst_constants (loc, insn, map, memonly)\n      int memonly;\n {\n   rtx x = *loc;\n-  register int i, j;\n-  register enum rtx_code code;\n-  register const char *format_ptr;\n+  int i, j;\n+  enum rtx_code code;\n+  const char *format_ptr;\n   int num_changes = num_validated_changes ();\n   rtx new = 0;\n   enum machine_mode op0_mode = MAX_MACHINE_MODE;\n@@ -2793,14 +2793,14 @@ mark_stores (dest, x, data)\n \n static void\n set_block_origin_self (stmt)\n-     register tree stmt;\n+     tree stmt;\n {\n   if (BLOCK_ABSTRACT_ORIGIN (stmt) == NULL_TREE)\n     {\n       BLOCK_ABSTRACT_ORIGIN (stmt) = stmt;\n \n       {\n-\tregister tree local_decl;\n+\ttree local_decl;\n \n \tfor (local_decl = BLOCK_VARS (stmt);\n \t     local_decl != NULL_TREE;\n@@ -2809,7 +2809,7 @@ set_block_origin_self (stmt)\n       }\n \n       {\n-\tregister tree subblock;\n+\ttree subblock;\n \n \tfor (subblock = BLOCK_SUBBLOCKS (stmt);\n \t     subblock != NULL_TREE;\n@@ -2832,14 +2832,14 @@ set_block_origin_self (stmt)\n \n void\n set_decl_origin_self (decl)\n-     register tree decl;\n+     tree decl;\n {\n   if (DECL_ABSTRACT_ORIGIN (decl) == NULL_TREE)\n     {\n       DECL_ABSTRACT_ORIGIN (decl) = decl;\n       if (TREE_CODE (decl) == FUNCTION_DECL)\n \t{\n-\t  register tree arg;\n+\t  tree arg;\n \n \t  for (arg = DECL_ARGUMENTS (decl); arg; arg = TREE_CHAIN (arg))\n \t    DECL_ABSTRACT_ORIGIN (arg) = arg;\n@@ -2857,11 +2857,11 @@ set_decl_origin_self (decl)\n \n static void\n set_block_abstract_flags (stmt, setting)\n-     register tree stmt;\n-     register int setting;\n+     tree stmt;\n+     int setting;\n {\n-  register tree local_decl;\n-  register tree subblock;\n+  tree local_decl;\n+  tree subblock;\n \n   BLOCK_ABSTRACT (stmt) = setting;\n \n@@ -2884,13 +2884,13 @@ set_block_abstract_flags (stmt, setting)\n \n void\n set_decl_abstract_flags (decl, setting)\n-     register tree decl;\n-     register int setting;\n+     tree decl;\n+     int setting;\n {\n   DECL_ABSTRACT (decl) = setting;\n   if (TREE_CODE (decl) == FUNCTION_DECL)\n     {\n-      register tree arg;\n+      tree arg;\n \n       for (arg = DECL_ARGUMENTS (decl); arg; arg = TREE_CHAIN (arg))\n \tDECL_ABSTRACT (arg) = setting;"}, {"sha": "c5a10b0a9be801bbe54d4f66d1325cdd5930a4a9", "filename": "gcc/jump.c", "status": "modified", "additions": 38, "deletions": 38, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=b36948478c22c58018d0a888ee8ca393dea60dc9", "patch": "@@ -78,7 +78,7 @@ void\n rebuild_jump_labels (f)\n      rtx f;\n {\n-  register rtx insn;\n+  rtx insn;\n   int max_uid = 0;\n \n   max_uid = init_label_info (f) + 1;\n@@ -131,7 +131,7 @@ void\n copy_loop_headers (f)\n      rtx f;\n {\n-  register rtx insn, next;\n+  rtx insn, next;\n   /* Now iterate optimizing jumps until nothing changes over one pass.  */\n   for (insn = f; insn; insn = next)\n     {\n@@ -1094,7 +1094,7 @@ int\n condjump_p (insn)\n      rtx insn;\n {\n-  register rtx x = PATTERN (insn);\n+  rtx x = PATTERN (insn);\n \n   if (GET_CODE (x) != SET\n       || GET_CODE (SET_DEST (x)) != PC)\n@@ -1125,7 +1125,7 @@ int\n condjump_in_parallel_p (insn)\n      rtx insn;\n {\n-  register rtx x = PATTERN (insn);\n+  rtx x = PATTERN (insn);\n \n   if (GET_CODE (x) != PARALLEL)\n     return 0;\n@@ -1347,10 +1347,10 @@ rtx\n follow_jumps (label)\n      rtx label;\n {\n-  register rtx insn;\n-  register rtx next;\n-  register rtx value = label;\n-  register int depth;\n+  rtx insn;\n+  rtx next;\n+  rtx value = label;\n+  int depth;\n \n   for (depth = 0;\n        (depth < 10\n@@ -1409,13 +1409,13 @@ follow_jumps (label)\n \n void\n mark_jump_label (x, insn, in_mem)\n-     register rtx x;\n+     rtx x;\n      rtx insn;\n      int in_mem;\n {\n-  register RTX_CODE code = GET_CODE (x);\n-  register int i;\n-  register const char *fmt;\n+  RTX_CODE code = GET_CODE (x);\n+  int i;\n+  const char *fmt;\n \n   switch (code)\n     {\n@@ -1505,7 +1505,7 @@ mark_jump_label (x, insn, in_mem)\n \tmark_jump_label (XEXP (x, i), insn, in_mem);\n       else if (fmt[i] == 'E')\n \t{\n-\t  register int j;\n+\t  int j;\n \t  for (j = 0; j < XVECLEN (x, i); j++)\n \t    mark_jump_label (XVECEXP (x, i, j), insn, in_mem);\n \t}\n@@ -1520,7 +1520,7 @@ void\n delete_jump (insn)\n      rtx insn;\n {\n-  register rtx set = single_set (insn);\n+  rtx set = single_set (insn);\n \n   if (set && GET_CODE (SET_DEST (set)) == PC)\n     delete_computation (insn);\n@@ -1723,9 +1723,9 @@ delete_computation (insn)\n \n rtx\n delete_related_insns (insn)\n-     register rtx insn;\n+     rtx insn;\n {\n-  register int was_code_label = (GET_CODE (insn) == CODE_LABEL);\n+  int was_code_label = (GET_CODE (insn) == CODE_LABEL);\n   rtx note;\n   rtx next = NEXT_INSN (insn), prev = PREV_INSN (insn);\n \n@@ -1824,7 +1824,7 @@ delete_related_insns (insn)\n \n   if (was_code_label && prev && GET_CODE (prev) == BARRIER)\n     {\n-      register RTX_CODE code;\n+      RTX_CODE code;\n       while (next != 0\n \t     && (GET_RTX_CLASS (code = GET_CODE (next)) == 'i'\n \t\t || code == NOTE || code == BARRIER\n@@ -1867,14 +1867,14 @@ next_nondeleted_insn (insn)\n \n void\n delete_for_peephole (from, to)\n-     register rtx from, to;\n+     rtx from, to;\n {\n-  register rtx insn = from;\n+  rtx insn = from;\n \n   while (1)\n     {\n-      register rtx next = NEXT_INSN (insn);\n-      register rtx prev = PREV_INSN (insn);\n+      rtx next = NEXT_INSN (insn);\n+      rtx prev = PREV_INSN (insn);\n \n       if (GET_CODE (insn) != NOTE)\n \t{\n@@ -1956,10 +1956,10 @@ redirect_exp_1 (loc, olabel, nlabel, insn)\n      rtx olabel, nlabel;\n      rtx insn;\n {\n-  register rtx x = *loc;\n-  register RTX_CODE code = GET_CODE (x);\n-  register int i;\n-  register const char *fmt;\n+  rtx x = *loc;\n+  RTX_CODE code = GET_CODE (x);\n+  int i;\n+  const char *fmt;\n \n   if (code == LABEL_REF)\n     {\n@@ -1999,7 +1999,7 @@ redirect_exp_1 (loc, olabel, nlabel, insn)\n \tredirect_exp_1 (&XEXP (x, i), olabel, nlabel, insn);\n       else if (fmt[i] == 'E')\n \t{\n-\t  register int j;\n+\t  int j;\n \t  for (j = 0; j < XVECLEN (x, i); j++)\n \t    redirect_exp_1 (&XVECEXP (x, i, j), olabel, nlabel, insn);\n \t}\n@@ -2062,7 +2062,7 @@ redirect_jump (jump, nlabel, delete_unused)\n      rtx jump, nlabel;\n      int delete_unused;\n {\n-  register rtx olabel = JUMP_LABEL (jump);\n+  rtx olabel = JUMP_LABEL (jump);\n \n   if (nlabel == olabel)\n     return 1;\n@@ -2095,7 +2095,7 @@ static void\n invert_exp_1 (insn)\n      rtx insn;\n {\n-  register RTX_CODE code;\n+  RTX_CODE code;\n   rtx x = pc_set (insn);\n \n   if (!x)\n@@ -2106,8 +2106,8 @@ invert_exp_1 (insn)\n \n   if (code == IF_THEN_ELSE)\n     {\n-      register rtx comp = XEXP (x, 0);\n-      register rtx tem;\n+      rtx comp = XEXP (x, 0);\n+      rtx tem;\n       enum rtx_code reversed_code;\n \n       /* We can do this in two ways:  The preferable way, which can only\n@@ -2218,9 +2218,9 @@ int\n rtx_renumbered_equal_p (x, y)\n      rtx x, y;\n {\n-  register int i;\n-  register RTX_CODE code = GET_CODE (x);\n-  register const char *fmt;\n+  int i;\n+  RTX_CODE code = GET_CODE (x);\n+  const char *fmt;\n \n   if (x == y)\n     return 1;\n@@ -2349,7 +2349,7 @@ rtx_renumbered_equal_p (x, y)\n   fmt = GET_RTX_FORMAT (code);\n   for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n     {\n-      register int j;\n+      int j;\n       switch (fmt[i])\n \t{\n \tcase 'w':\n@@ -2716,10 +2716,10 @@ rtx_equal_for_thread_p (x, y, yinsn)\n      rtx x, y;\n      rtx yinsn;\n {\n-  register int i;\n-  register int j;\n-  register enum rtx_code code;\n-  register const char *fmt;\n+  int i;\n+  int j;\n+  enum rtx_code code;\n+  const char *fmt;\n \n   code = GET_CODE (x);\n   /* Rtx's of different codes cannot be equal.  */"}, {"sha": "0adacfb5162f7232687bc57019a1f419f33976c1", "filename": "gcc/lists.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Flists.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Flists.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flists.c?ref=b36948478c22c58018d0a888ee8ca393dea60dc9", "patch": "@@ -45,7 +45,7 @@ static void\n free_list (listp, unused_listp)\n      rtx *listp, *unused_listp;\n {\n-  register rtx link, prev_link;\n+  rtx link, prev_link;\n \n   prev_link = *listp;\n   link = XEXP (prev_link, 1);"}, {"sha": "2637b7e78a13e32fde1b79d80d5a0e7bdbebf323", "filename": "gcc/local-alloc.c", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Flocal-alloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Flocal-alloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flocal-alloc.c?ref=b36948478c22c58018d0a888ee8ca393dea60dc9", "patch": "@@ -312,7 +312,7 @@ alloc_qty (regno, mode, size, birth)\n      enum machine_mode mode;\n      int size, birth;\n {\n-  register int qtyno = next_qty++;\n+  int qtyno = next_qty++;\n \n   reg_qty[regno] = qtyno;\n   reg_offset[regno] = 0;\n@@ -335,7 +335,7 @@ alloc_qty (regno, mode, size, birth)\n int\n local_alloc ()\n {\n-  register int b, i;\n+  int b, i;\n   int max_qty;\n \n   /* We need to keep track of whether or not we recorded a LABEL_REF so\n@@ -523,9 +523,9 @@ static int\n equiv_init_varies_p (x)\n      rtx x;\n {\n-  register RTX_CODE code = GET_CODE (x);\n-  register int i;\n-  register const char *fmt;\n+  RTX_CODE code = GET_CODE (x);\n+  int i;\n+  const char *fmt;\n \n   switch (code)\n     {\n@@ -1215,8 +1215,8 @@ static void\n block_alloc (b)\n      int b;\n {\n-  register int i, q;\n-  register rtx insn;\n+  int i, q;\n+  rtx insn;\n   rtx note;\n   int insn_number = 0;\n   int insn_count = 0;\n@@ -1258,9 +1258,9 @@ block_alloc (b)\n \n       if (INSN_P (insn))\n \t{\n-\t  register rtx link, set;\n-\t  register int win = 0;\n-\t  register rtx r0, r1 = NULL_RTX;\n+\t  rtx link, set;\n+\t  int win = 0;\n+\t  rtx r0, r1 = NULL_RTX;\n \t  int combined_regno = -1;\n \t  int i;\n \n@@ -1690,8 +1690,8 @@ qty_compare_1 (q1p, q2p)\n      const PTR q1p;\n      const PTR q2p;\n {\n-  register int q1 = *(const int *) q1p, q2 = *(const int *) q2p;\n-  register int tem = QTY_CMP_PRI (q2) - QTY_CMP_PRI (q1);\n+  int q1 = *(const int *) q1p, q2 = *(const int *) q2p;\n+  int tem = QTY_CMP_PRI (q2) - QTY_CMP_PRI (q1);\n \n   if (tem != 0)\n     return tem;\n@@ -1717,7 +1717,7 @@ static int\n qty_sugg_compare (q1, q2)\n      int q1, q2;\n {\n-  register int tem = QTY_CMP_SUGG (q1) - QTY_CMP_SUGG (q2);\n+  int tem = QTY_CMP_SUGG (q1) - QTY_CMP_SUGG (q2);\n \n   if (tem != 0)\n     return tem;\n@@ -1730,8 +1730,8 @@ qty_sugg_compare_1 (q1p, q2p)\n      const PTR q1p;\n      const PTR q2p;\n {\n-  register int q1 = *(const int *) q1p, q2 = *(const int *) q2p;\n-  register int tem = QTY_CMP_SUGG (q1) - QTY_CMP_SUGG (q2);\n+  int q1 = *(const int *) q1p, q2 = *(const int *) q2p;\n+  int tem = QTY_CMP_SUGG (q1) - QTY_CMP_SUGG (q2);\n \n   if (tem != 0)\n     return tem;\n@@ -1778,10 +1778,10 @@ combine_regs (usedreg, setreg, may_save_copy, insn_number, insn, already_dead)\n      rtx insn;\n      int already_dead;\n {\n-  register int ureg, sreg;\n-  register int offset = 0;\n+  int ureg, sreg;\n+  int offset = 0;\n   int usize, ssize;\n-  register int sqty;\n+  int sqty;\n \n   /* Determine the numbers and sizes of registers being used.  If a subreg\n      is present that does not change the entire register, don't consider\n@@ -1947,7 +1947,7 @@ combine_regs (usedreg, setreg, may_save_copy, insn_number, insn, already_dead)\n       qty[sqty].freq += REG_FREQ (sreg);\n       if (usize < ssize)\n \t{\n-\t  register int i;\n+\t  int i;\n \n \t  for (i = qty[sqty].first_reg; i >= 0; i = reg_next_in_qty[i])\n \t    reg_offset[i] -= offset;\n@@ -1971,7 +1971,7 @@ reg_meets_class_p (reg, class)\n      int reg;\n      enum reg_class class;\n {\n-  register enum reg_class rclass = reg_preferred_class (reg);\n+  enum reg_class rclass = reg_preferred_class (reg);\n   return (reg_class_subset_p (rclass, class)\n \t  || reg_class_subset_p (class, rclass));\n }\n@@ -2032,7 +2032,7 @@ reg_is_born (reg, birth)\n      rtx reg;\n      int birth;\n {\n-  register int regno;\n+  int regno;\n \n   if (GET_CODE (reg) == SUBREG)\n     {\n@@ -2070,10 +2070,10 @@ reg_is_born (reg, birth)\n \n static void\n wipe_dead_reg (reg, output_p)\n-     register rtx reg;\n+     rtx reg;\n      int output_p;\n {\n-  register int regno = REGNO (reg);\n+  int regno = REGNO (reg);\n \n   /* If this insn has multiple results,\n      and the dead reg is used in one of the results,\n@@ -2145,7 +2145,7 @@ find_free_reg (class, mode, qtyno, accept_call_clobbered, just_try_suggested,\n      int just_try_suggested;\n      int born_index, dead_index;\n {\n-  register int i, ins;\n+  int i, ins;\n #ifdef HARD_REG_SET\n   /* Declare it register if it's a scalar.  */\n   register\n@@ -2238,8 +2238,8 @@ find_free_reg (class, mode, qtyno, accept_call_clobbered, just_try_suggested,\n \t      || accept_call_clobbered\n \t      || ! HARD_REGNO_CALL_PART_CLOBBERED (regno, mode)))\n \t{\n-\t  register int j;\n-\t  register int size1 = HARD_REGNO_NREGS (regno, mode);\n+\t  int j;\n+\t  int size1 = HARD_REGNO_NREGS (regno, mode);\n \t  for (j = 1; j < size1 && ! TEST_HARD_REG_BIT (used, regno + j); j++);\n \t  if (j == size1)\n \t    {\n@@ -2296,11 +2296,11 @@ find_free_reg (class, mode, qtyno, accept_call_clobbered, just_try_suggested,\n \n static void\n mark_life (regno, mode, life)\n-     register int regno;\n+     int regno;\n      enum machine_mode mode;\n      int life;\n {\n-  register int j = HARD_REGNO_NREGS (regno, mode);\n+  int j = HARD_REGNO_NREGS (regno, mode);\n   if (life)\n     while (--j >= 0)\n       SET_HARD_REG_BIT (regs_live, regno + j);\n@@ -2319,7 +2319,7 @@ post_mark_life (regno, mode, life, birth, death)\n      enum machine_mode mode;\n      int life, birth, death;\n {\n-  register int j = HARD_REGNO_NREGS (regno, mode);\n+  int j = HARD_REGNO_NREGS (regno, mode);\n #ifdef HARD_REG_SET\n   /* Declare it register if it's a scalar.  */\n   register\n@@ -2451,7 +2451,7 @@ void\n dump_local_alloc (file)\n      FILE *file;\n {\n-  register int i;\n+  int i;\n   for (i = FIRST_PSEUDO_REGISTER; i < max_regno; i++)\n     if (reg_renumber[i] != -1)\n       fprintf (file, \";; Register %d in %d.\\n\", i, reg_renumber[i]);"}, {"sha": "c81a2c645a292032a02a6e7fe67ec2f0323b73ce", "filename": "gcc/loop.c", "status": "modified", "additions": 52, "deletions": 50, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=b36948478c22c58018d0a888ee8ca393dea60dc9", "patch": "@@ -356,8 +356,8 @@ loop_optimize (f, dumpfile, flags)\n      FILE *dumpfile;\n      int flags;\n {\n-  register rtx insn;\n-  register int i;\n+  rtx insn;\n+  int i;\n   struct loops loops_data;\n   struct loops *loops = &loops_data;\n   struct loop_info *loops_info;\n@@ -522,7 +522,7 @@ scan_loop (loop, flags)\n {\n   struct loop_info *loop_info = LOOP_INFO (loop);\n   struct loop_regs *regs = LOOP_REGS (loop);\n-  register int i;\n+  int i;\n   rtx loop_start = loop->start;\n   rtx loop_end = loop->end;\n   rtx p;\n@@ -761,8 +761,8 @@ scan_loop (loop, flags)\n \t\t   && ! ((maybe_never || call_passed)\n \t\t\t && may_trap_p (src)))\n \t    {\n-\t      register struct movable *m;\n-\t      register int regno = REGNO (SET_DEST (set));\n+\t      struct movable *m;\n+\t      int regno = REGNO (SET_DEST (set));\n \n \t      /* A potential lossage is where we have a case where two insns\n \t\t can be combined as long as they are both in the loop, but\n@@ -892,10 +892,10 @@ scan_loop (loop, flags)\n \t\t       == SET_DEST (set))\n \t\t   && !reg_mentioned_p (SET_DEST (set), SET_SRC (set1)))\n \t    {\n-\t      register int regno = REGNO (SET_DEST (set));\n+\t      int regno = REGNO (SET_DEST (set));\n \t      if (regs->array[regno].set_in_loop == 2)\n \t\t{\n-\t\t  register struct movable *m;\n+\t\t  struct movable *m;\n \t\t  m = (struct movable *) xmalloc (sizeof (struct movable));\n \t\t  m->next = 0;\n \t\t  m->insn = p;\n@@ -1252,7 +1252,7 @@ static void\n ignore_some_movables (movables)\n      struct loop_movables *movables;\n {\n-  register struct movable *m, *m1;\n+  struct movable *m, *m1;\n \n   for (m = movables->head; m; m = m->next)\n     {\n@@ -1284,7 +1284,8 @@ static void\n force_movables (movables)\n      struct loop_movables *movables;\n {\n-  register struct movable *m, *m1;\n+  struct movable *m, *m1;\n+\n   for (m1 = movables->head; m1; m1 = m1->next)\n     /* Omit this if moving just the (SET (REG) 0) of a zero-extend.  */\n     if (!m1->partial && !m1->done)\n@@ -1324,7 +1325,7 @@ combine_movables (movables, regs)\n      struct loop_movables *movables;\n      struct loop_regs *regs;\n {\n-  register struct movable *m;\n+  struct movable *m;\n   char *matched_regs = (char *) xmalloc (regs->num);\n   enum machine_mode mode;\n \n@@ -1336,7 +1337,7 @@ combine_movables (movables, regs)\n     if (m->match == 0 && regs->array[m->regno].n_times_set == 1\n \t&& !m->partial)\n       {\n-\tregister struct movable *m1;\n+\tstruct movable *m1;\n \tint regno = m->regno;\n \n \tmemset (matched_regs, 0, regs->num);\n@@ -1389,15 +1390,16 @@ combine_movables (movables, regs)\n   for (mode = GET_CLASS_NARROWEST_MODE (MODE_INT); mode != VOIDmode;\n        mode = GET_MODE_WIDER_MODE (mode))\n     {\n-      register struct movable *m0 = 0;\n+      struct movable *m0 = 0;\n \n       /* Combine all the registers for extension from mode MODE.\n \t Don't combine any that are used outside this loop.  */\n       for (m = movables->head; m; m = m->next)\n \tif (m->partial && ! m->global\n \t    && mode == GET_MODE (SET_SRC (PATTERN (NEXT_INSN (m->insn)))))\n \t  {\n-\t    register struct movable *m1;\n+\t    struct movable *m1;\n+\n \t    int first = REGNO_FIRST_LUID (m->regno);\n \t    int last = REGNO_LAST_LUID (m->regno);\n \n@@ -1491,11 +1493,11 @@ rtx_equal_for_loop_p (x, y, movables, regs)\n      struct loop_movables *movables;\n      struct loop_regs *regs;\n {\n-  register int i;\n-  register int j;\n-  register struct movable *m;\n-  register enum rtx_code code;\n-  register const char *fmt;\n+  int i;\n+  int j;\n+  struct movable *m;\n+  enum rtx_code code;\n+  const char *fmt;\n \n   if (x == y)\n     return 1;\n@@ -1656,8 +1658,8 @@ move_movables (loop, movables, threshold, insn_count)\n   struct loop_regs *regs = LOOP_REGS (loop);\n   int nregs = regs->num;\n   rtx new_start = 0;\n-  register struct movable *m;\n-  register rtx p;\n+  struct movable *m;\n+  rtx p;\n   rtx loop_start = loop->start;\n   rtx loop_end = loop->end;\n   /* Map of pseudo-register replacements to handle combining\n@@ -1708,8 +1710,8 @@ move_movables (loop, movables, threshold, insn_count)\n \t\t\t\t\t\t       m->insn))))\n \t  && (! m->forces || m->forces->done))\n \t{\n-\t  register int regno;\n-\t  register rtx p;\n+\t  int regno;\n+\t  rtx p;\n \t  int savings = m->savings;\n \n \t  /* We have an insn that is safe to move.\n@@ -1745,7 +1747,7 @@ move_movables (loop, movables, threshold, insn_count)\n \t\t  && regs->array[m->forces->regno].n_times_set == 1))\n \t    {\n \t      int count;\n-\t      register struct movable *m1;\n+\t      struct movable *m1;\n \t      rtx first = NULL_RTX;\n \n \t      /* Now move the insns that set the reg.  */\n@@ -2185,9 +2187,9 @@ static void\n replace_call_address (x, reg, addr)\n      rtx x, reg, addr;\n {\n-  register enum rtx_code code;\n-  register int i;\n-  register const char *fmt;\n+  enum rtx_code code;\n+  int i;\n+  const char *fmt;\n \n   if (x == 0)\n     return;\n@@ -2233,7 +2235,7 @@ replace_call_address (x, reg, addr)\n \treplace_call_address (XEXP (x, i), reg, addr);\n       else if (fmt[i] == 'E')\n \t{\n-\t  register int j;\n+\t  int j;\n \t  for (j = 0; j < XVECLEN (x, i); j++)\n \t    replace_call_address (XVECEXP (x, i, j), reg, addr);\n \t}\n@@ -2249,9 +2251,9 @@ count_nonfixed_reads (loop, x)\n      const struct loop *loop;\n      rtx x;\n {\n-  register enum rtx_code code;\n-  register int i;\n-  register const char *fmt;\n+  enum rtx_code code;\n+  int i;\n+  const char *fmt;\n   int value;\n \n   if (x == 0)\n@@ -2286,7 +2288,7 @@ count_nonfixed_reads (loop, x)\n \tvalue += count_nonfixed_reads (loop, XEXP (x, i));\n       if (fmt[i] == 'E')\n \t{\n-\t  register int j;\n+\t  int j;\n \t  for (j = 0; j < XVECLEN (x, i); j++)\n \t    value += count_nonfixed_reads (loop, XVECEXP (x, i, j));\n \t}\n@@ -2304,7 +2306,7 @@ static void\n prescan_loop (loop)\n      struct loop *loop;\n {\n-  register int level = 1;\n+  int level = 1;\n   rtx insn;\n   struct loop_info *loop_info = LOOP_INFO (loop);\n   rtx start = loop->start;\n@@ -3058,13 +3060,13 @@ note_set_pseudo_multiple_uses (x, y, data)\n int\n loop_invariant_p (loop, x)\n      const struct loop *loop;\n-     register rtx x;\n+     rtx x;\n {\n   struct loop_info *loop_info = LOOP_INFO (loop);\n   struct loop_regs *regs = LOOP_REGS (loop);\n-  register int i;\n-  register enum rtx_code code;\n-  register const char *fmt;\n+  int i;\n+  enum rtx_code code;\n+  const char *fmt;\n   int conditional = 0;\n   rtx mem_list_entry;\n \n@@ -3162,7 +3164,7 @@ loop_invariant_p (loop, x)\n \t}\n       else if (fmt[i] == 'E')\n \t{\n-\t  register int j;\n+\t  int j;\n \t  for (j = 0; j < XVECLEN (x, i); j++)\n \t    {\n \t      int tem = loop_invariant_p (loop, XVECEXP (x, i, j));\n@@ -3212,7 +3214,7 @@ consec_sets_invariant_p (loop, reg, n_sets, insn)\n \n   while (count > 0)\n     {\n-      register enum rtx_code code;\n+      enum rtx_code code;\n       rtx set;\n \n       p = NEXT_INSN (p);\n@@ -3269,12 +3271,12 @@ all_sets_invariant_p (reg, insn, table)\n      rtx reg, insn;\n      short *table;\n {\n-  register rtx p = insn;\n-  register int regno = REGNO (reg);\n+  rtx p = insn;\n+  int regno = REGNO (reg);\n \n   while (1)\n     {\n-      register enum rtx_code code;\n+      enum rtx_code code;\n       p = NEXT_INSN (p);\n       code = GET_CODE (p);\n       if (code == CODE_LABEL || code == JUMP_INSN)\n@@ -3356,7 +3358,7 @@ count_one_set (regs, insn, x, last_set)\n \tdest = XEXP (dest, 0);\n       if (GET_CODE (dest) == REG)\n \t{\n-\t  register int regno = REGNO (dest);\n+\t  int regno = REGNO (dest);\n \t  /* If this is the first setting of this reg\n \t     in current basic block, and it was set before,\n \t     it must be set in two basic blocks, so it cannot\n@@ -4722,9 +4724,9 @@ find_mem_givs (loop, x, insn, not_every_iteration, maybe_multiple)\n      rtx insn;\n      int not_every_iteration, maybe_multiple;\n {\n-  register int i, j;\n-  register enum rtx_code code;\n-  register const char *fmt;\n+  int i, j;\n+  enum rtx_code code;\n+  const char *fmt;\n \n   if (x == 0)\n     return;\n@@ -5396,15 +5398,15 @@ update_giv_derive (loop, p)\n static int\n basic_induction_var (loop, x, mode, dest_reg, p, inc_val, mult_val, location)\n      const struct loop *loop;\n-     register rtx x;\n+     rtx x;\n      enum machine_mode mode;\n      rtx dest_reg;\n      rtx p;\n      rtx *inc_val;\n      rtx *mult_val;\n      rtx **location;\n {\n-  register enum rtx_code code;\n+  enum rtx_code code;\n   rtx *argp, arg;\n   rtx insn, set = 0;\n \n@@ -8311,8 +8313,8 @@ update_reg_last_use (x, insn)\n     }\n   else\n     {\n-      register int i, j;\n-      register const char *fmt = GET_RTX_FORMAT (GET_CODE (x));\n+      int i, j;\n+      const char *fmt = GET_RTX_FORMAT (GET_CODE (x));\n       for (i = GET_RTX_LENGTH (GET_CODE (x)) - 1; i >= 0; i--)\n \t{\n \t  if (fmt[i] == 'e')\n@@ -8808,7 +8810,7 @@ loop_regs_scan (loop, extra_size)\n \t    count_one_set (regs, insn, PATTERN (insn), last_set);\n \t  else if (GET_CODE (PATTERN (insn)) == PARALLEL)\n \t    {\n-\t      register int i;\n+\t      int i;\n \t      for (i = XVECLEN (PATTERN (insn), 0) - 1; i >= 0; i--)\n \t\tcount_one_set (regs, insn, XVECEXP (PATTERN (insn), 0, i),\n \t\t\t       last_set);"}, {"sha": "32f2bc2331030fe493b1ce2284b0227cb3c3bfe0", "filename": "gcc/mips-tdump.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Fmips-tdump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Fmips-tdump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmips-tdump.c?ref=b36948478c22c58018d0a888ee8ca393dea60dc9", "patch": "@@ -1011,9 +1011,10 @@ print_symbol (sym_ptr, number, strbase, aux_base, ifd, fdp)\n \n   if (MIPS_IS_STAB(sym_ptr))\n     {\n-      register int i = ARRAY_SIZE (stab_names);\n+      int i = ARRAY_SIZE (stab_names);\n       const char *stab_name = \"stab\";\n       short code = MIPS_UNMARK_STAB(sym_ptr->index);\n+\n       while (--i >= 0)\n \tif (stab_names[i].code == code)\n \t  {"}, {"sha": "ca03f263729612e54ac538189c6541dd528bbab4", "filename": "gcc/mips-tfile.c", "status": "modified", "additions": 136, "deletions": 136, "changes": 272, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Fmips-tfile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Fmips-tfile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmips-tfile.c?ref=b36948478c22c58018d0a888ee8ca393dea60dc9", "patch": "@@ -1778,10 +1778,10 @@ hash_string (text, hash_len, hash_tbl, ret_hash_index)\n      shash_t **hash_tbl;\t\t/* hash table */\n      symint_t *ret_hash_index;\t\t/* ptr to store hash index */\n {\n-  register unsigned long hi;\n-  register Ptrdiff_t i;\n-  register shash_t *ptr;\n-  register int first_ch = *text;\n+  unsigned long hi;\n+  Ptrdiff_t i;\n+  shash_t *ptr;\n+  int first_ch = *text;\n \n   hi = hash_len;\n   for (i = 0; i < hash_len; i++)\n@@ -1815,8 +1815,8 @@ add_string (vp, hash_tbl, start, end_p1, ret_hash)\n      const char *end_p1;\t\t/* 1st byte after string */\n      shash_t **ret_hash;\t\t/* return hash pointer */\n {\n-  register Ptrdiff_t len = end_p1 - start;\n-  register shash_t *hash_ptr;\n+  Ptrdiff_t len = end_p1 - start;\n+  shash_t *hash_ptr;\n   symint_t hi;\n \n   if (len >= (Ptrdiff_t) PAGE_USIZE)\n@@ -1825,7 +1825,7 @@ add_string (vp, hash_tbl, start, end_p1, ret_hash)\n   hash_ptr = hash_string (start, len, hash_tbl, &hi);\n   if (hash_ptr == (shash_t *) 0)\n     {\n-      register char *p;\n+      char *p;\n \n       if (vp->objects_last_page + len >= (long) PAGE_USIZE)\n \t{\n@@ -1869,14 +1869,14 @@ add_local_symbol (str_start, str_end_p1, type, storage, value, indx)\n      symint_t value;\t\t\t/* value of symbol */\n      symint_t indx;\t\t\t/* index to local/aux. syms */\n {\n-  register symint_t ret;\n-  register SYMR *psym;\n-  register scope_t *pscope;\n-  register thead_t *ptag_head;\n-  register tag_t *ptag;\n-  register tag_t *ptag_next;\n-  register varray_t *vp = &cur_file_ptr->symbols;\n-  register int scope_delta = 0;\n+  symint_t ret;\n+  SYMR *psym;\n+  scope_t *pscope;\n+  thead_t *ptag_head;\n+  tag_t *ptag;\n+  tag_t *ptag_next;\n+  varray_t *vp = &cur_file_ptr->symbols;\n+  int scope_delta = 0;\n   shash_t *hash_ptr = (shash_t *) 0;\n \n   if (vp->objects_last_page == vp->objects_per_page)\n@@ -2045,8 +2045,8 @@ add_ext_symbol (esym, ifd)\n {\n   const char *str_start;\t\t/* first byte in string */\n   const char *str_end_p1;\t\t/* first byte after string */\n-  register EXTR *psym;\n-  register varray_t *vp = &ext_symbols;\n+  EXTR *psym;\n+  varray_t *vp = &ext_symbols;\n   shash_t *hash_ptr = (shash_t *) 0;\n \n   str_start = ORIG_ESTRS (esym->asym.iss);\n@@ -2096,9 +2096,9 @@ STATIC symint_t\n add_aux_sym_symint (aux_word)\n      symint_t aux_word;\t\t/* auxiliary information word */\n {\n-  register AUXU *aux_ptr;\n-  register efdr_t *file_ptr = cur_file_ptr;\n-  register varray_t *vp = &file_ptr->aux_syms;\n+  AUXU *aux_ptr;\n+  efdr_t *file_ptr = cur_file_ptr;\n+  varray_t *vp = &file_ptr->aux_syms;\n \n   if (vp->objects_last_page == vp->objects_per_page)\n     add_varray_page (vp);\n@@ -2117,9 +2117,9 @@ add_aux_sym_rndx (file_index, sym_index)\n      int file_index;\n      symint_t sym_index;\n {\n-  register AUXU *aux_ptr;\n-  register efdr_t *file_ptr = cur_file_ptr;\n-  register varray_t *vp = &file_ptr->aux_syms;\n+  AUXU *aux_ptr;\n+  efdr_t *file_ptr = cur_file_ptr;\n+  varray_t *vp = &file_ptr->aux_syms;\n \n   if (vp->objects_last_page == vp->objects_per_page)\n     add_varray_page (vp);\n@@ -2141,9 +2141,9 @@ add_aux_sym_tir (t, state, hash_tbl)\n      hash_state_t state;\t/* whether to hash type or not */\n      thash_t **hash_tbl;\t/* pointer to hash table to use */\n {\n-  register AUXU *aux_ptr;\n-  register efdr_t *file_ptr = cur_file_ptr;\n-  register varray_t *vp = &file_ptr->aux_syms;\n+  AUXU *aux_ptr;\n+  efdr_t *file_ptr = cur_file_ptr;\n+  varray_t *vp = &file_ptr->aux_syms;\n   static AUXU init_aux;\n   symint_t ret;\n   int i;\n@@ -2186,8 +2186,8 @@ add_aux_sym_tir (t, state, hash_tbl)\n \n   if (state != hash_no)\n     {\n-      register thash_t *hash_ptr;\n-      register symint_t hi;\n+      thash_t *hash_ptr;\n+      symint_t hi;\n \n       hi = aux.isym & ((1 << HASHBITS) - 1);\n       hi %= THASH_SIZE;\n@@ -2243,8 +2243,8 @@ add_aux_sym_tir (t, state, hash_tbl)\n       || t->basic_type == bt_Union\n       || t->basic_type == bt_Enum)\n     {\n-      register symint_t file_index = t->tag_ptr->ifd;\n-      register symint_t sym_index  = t->tag_ptr->indx;\n+      symint_t file_index = t->tag_ptr->ifd;\n+      symint_t sym_index  = t->tag_ptr->indx;\n \n       if (t->unknown_tag)\n \t{\n@@ -2258,7 +2258,7 @@ add_aux_sym_tir (t, state, hash_tbl)\n \t}\n       else\n \t{\n-\t  register forward_t *forward_ref = allocate_forward ();\n+\t  forward_t *forward_ref = allocate_forward ();\n \n \t  forward_ref->type_ptr = aux_ptr;\n \t  forward_ref->next = t->tag_ptr->forward_ref;\n@@ -2414,15 +2414,15 @@ add_procedure (func_start, func_end_p1)\n      const char *func_start;\t\t/* 1st byte of func name */\n      const char *func_end_p1;\t\t/* 1st byte after func name */\n {\n-  register PDR *new_proc_ptr;\n-  register efdr_t *file_ptr = cur_file_ptr;\n-  register varray_t *vp = &file_ptr->procs;\n-  register symint_t value = 0;\n-  register st_t proc_type = st_Proc;\n-  register shash_t *shash_ptr = hash_string (func_start,\n-\t\t\t\t\t    func_end_p1 - func_start,\n-\t\t\t\t\t    &orig_str_hash[0],\n-\t\t\t\t\t    (symint_t *) 0);\n+  PDR *new_proc_ptr;\n+  efdr_t *file_ptr = cur_file_ptr;\n+  varray_t *vp = &file_ptr->procs;\n+  symint_t value = 0;\n+  st_t proc_type = st_Proc;\n+  shash_t *shash_ptr = hash_string (func_start,\n+\t\t\t\t    func_end_p1 - func_start,\n+\t\t\t\t    &orig_str_hash[0],\n+\t\t\t\t    (symint_t *) 0);\n \n   if (debug)\n     fputc ('\\n', stderr);\n@@ -2439,8 +2439,8 @@ add_procedure (func_start, func_end_p1)\n   cur_oproc_ptr = (PDR *) 0;\n   if (shash_ptr != (shash_t *) 0)\n     {\n-      register PDR *old_proc_ptr = shash_ptr->proc_ptr;\n-      register SYMR *sym_ptr = shash_ptr->sym_ptr;\n+      PDR *old_proc_ptr = shash_ptr->proc_ptr;\n+      SYMR *sym_ptr = shash_ptr->sym_ptr;\n \n       if (old_proc_ptr != (PDR *) 0\n \t  && sym_ptr != (SYMR *) 0\n@@ -2482,9 +2482,9 @@ add_file (file_start, file_end_p1)\n {\n   static char zero_bytes[2] = { '\\0', '\\0' };\n \n-  register Ptrdiff_t len = file_end_p1 - file_start;\n-  register int first_ch = *file_start;\n-  register efdr_t *file_ptr;\n+  Ptrdiff_t len = file_end_p1 - file_start;\n+  int first_ch = *file_start;\n+  efdr_t *file_ptr;\n \n   if (debug)\n     fprintf (stderr, \"\\tfile\\t%.*s\\n\", (int) len, file_start);\n@@ -2561,9 +2561,9 @@ add_bytes (vp, input_ptr, nitems)\n      char *input_ptr;\t\t\t/* start of the bytes */\n      Size_t nitems;\t\t\t/* # items to move */\n {\n-  register Size_t move_items;\n-  register Size_t move_bytes;\n-  register char *ptr;\n+  Size_t move_items;\n+  Size_t move_bytes;\n+  char *ptr;\n \n   while (nitems > 0)\n     {\n@@ -2673,10 +2673,10 @@ STATIC char *\n read_line ()\n {\n   static   int line_split_p\t= 0;\n-  register int string_p\t\t= 0;\n-  register int comment_p\t= 0;\n-  register int ch;\n-  register char *ptr;\n+  int string_p\t\t= 0;\n+  int comment_p\t= 0;\n+  int ch;\n+  char *ptr;\n \n   if (cur_line_start == (char *) 0)\n     {\t\t\t\t/* allocate initial page */\n@@ -2694,8 +2694,8 @@ read_line ()\n     {\n       if (++cur_line_nbytes >= cur_line_alloc-1)\n \t{\n-\t  register int num_pages = cur_line_alloc / PAGE_SIZE;\n-\t  register char *old_buffer = cur_line_start;\n+\t  int num_pages = cur_line_alloc / PAGE_SIZE;\n+\t  char *old_buffer = cur_line_start;\n \n \t  cur_line_alloc += PAGE_SIZE;\n \t  cur_line_start = (char *) allocate_multiple_pages (num_pages+1);\n@@ -3435,10 +3435,10 @@ STATIC void\n parse_end (start)\n      const char *start;\t\t\t/* start of directive */\n {\n-  register const char *start_func, *end_func_p1;\n-  register int ch;\n-  register symint_t value;\n-  register FDR *orig_fdr;\n+  const char *start_func, *end_func_p1;\n+  int ch;\n+  symint_t value;\n+  FDR *orig_fdr;\n \n   if (cur_file_ptr == (efdr_t *) 0)\n     {\n@@ -3498,8 +3498,8 @@ STATIC void\n parse_ent (start)\n      const char *start;\t\t\t/* start of directive */\n {\n-  register const char *start_func, *end_func_p1;\n-  register int ch;\n+  const char *start_func, *end_func_p1;\n+  int ch;\n \n   if (cur_file_ptr == (efdr_t *) 0)\n     {\n@@ -3537,7 +3537,7 @@ parse_file (start)\n      const char *start;\t\t\t/* start of directive */\n {\n   char *p;\n-  register char *start_name, *end_name_p1;\n+  char *start_name, *end_name_p1;\n \n   (void) strtol (start, &p, 0);\n   if (start == p\n@@ -3834,11 +3834,11 @@ parse_stabn (start)\n STATIC void\n parse_input ()\n {\n-  register char *p;\n-  register Size_t i;\n-  register thead_t *ptag_head;\n-  register tag_t *ptag;\n-  register tag_t *ptag_next;\n+  char *p;\n+  Size_t i;\n+  thead_t *ptag_head;\n+  tag_t *ptag;\n+  tag_t *ptag_next;\n \n   if (debug)\n     fprintf (stderr, \"\\tinput\\n\");\n@@ -3897,8 +3897,8 @@ parse_input ()\n STATIC void\n update_headers ()\n {\n-  register symint_t i;\n-  register efdr_t *file_ptr;\n+  symint_t i;\n+  efdr_t *file_ptr;\n \n   /* Set up the symbolic header.  */\n   file_offset = sizeof (symbolic_header) + orig_file_header.f_symptr;\n@@ -3924,10 +3924,10 @@ update_headers ()\n        file_ptr != (efdr_t *) 0;\n        file_ptr = file_ptr->next_file)\n     {\n-      register SYMR *sym_start;\n-      register SYMR *sym;\n-      register SYMR *sym_end_p1;\n-      register FDR *fd_ptr = file_ptr->orig_fdr;\n+      SYMR *sym_start;\n+      SYMR *sym;\n+      SYMR *sym_end_p1;\n+      FDR *fd_ptr = file_ptr->orig_fdr;\n \n       cur_file_ptr = file_ptr;\n \n@@ -3941,9 +3941,9 @@ update_headers ()\n \t{\n \t  if ((st_t)sym->st == st_Static)\n \t    {\n-\t      register char *str = ORIG_LSTRS (fd_ptr->issBase + sym->iss);\n-\t      register Size_t len = strlen (str);\n-\t      register shash_t *hash_ptr;\n+\t      char *str = ORIG_LSTRS (fd_ptr->issBase + sym->iss);\n+\t      Size_t len = strlen (str);\n+\t      shash_t *hash_ptr;\n \n \t      /* Ignore internal labels.  */\n \t      if (str[0] == '$' && str[1] == 'L')\n@@ -4440,13 +4440,13 @@ STATIC void\n copy_object ()\n {\n   char buffer[ PAGE_SIZE ];\n-  register int sys_read;\n-  register int remaining;\n-  register int num_write;\n-  register int sys_write;\n-  register int fd, es;\n-  register int delete_ifd = 0;\n-  register int *remap_file_number;\n+  int sys_read;\n+  int remaining;\n+  int num_write;\n+  int sys_write;\n+  int fd, es;\n+  int delete_ifd = 0;\n+  int *remap_file_number;\n   struct stat stat_buf;\n \n   if (debug)\n@@ -4597,8 +4597,8 @@ copy_object ()\n \n   for (fd = delete_ifd; fd < orig_sym_hdr.ifdMax; fd++)\n     {\n-      register FDR *fd_ptr = ORIG_FILES (fd);\n-      register char *filename = ORIG_LSTRS (fd_ptr->issBase + fd_ptr->rss);\n+      FDR *fd_ptr = ORIG_FILES (fd);\n+      char *filename = ORIG_LSTRS (fd_ptr->issBase + fd_ptr->rss);\n \n       /* file support itself.  */\n       add_file (filename, filename + strlen (filename));\n@@ -4622,8 +4622,8 @@ copy_object ()\n \n   for (es = 0; es < orig_sym_hdr.iextMax; es++)\n     {\n-      register EXTR *eptr = orig_ext_syms + es;\n-      register unsigned ifd = eptr->ifd;\n+      EXTR *eptr = orig_ext_syms + es;\n+      unsigned ifd = eptr->ifd;\n \n       (void) add_ext_symbol (eptr, ((long) ifd < orig_sym_hdr.ifdMax)\n \t\t\t     ? remap_file_number[ ifd ] : ifd );\n@@ -4635,14 +4635,14 @@ copy_object ()\n \n   for (fd = delete_ifd; fd < orig_sym_hdr.ifdMax; fd++)\n     {\n-      register FDR *fd_ptr = ORIG_FILES (fd);\n-      register char *filename = ORIG_LSTRS (fd_ptr->issBase + fd_ptr->rss);\n-      register SYMR *sym_start;\n-      register SYMR *sym;\n-      register SYMR *sym_end_p1;\n-      register PDR *proc_start;\n-      register PDR *proc;\n-      register PDR *proc_end_p1;\n+      FDR *fd_ptr = ORIG_FILES (fd);\n+      char *filename = ORIG_LSTRS (fd_ptr->issBase + fd_ptr->rss);\n+      SYMR *sym_start;\n+      SYMR *sym;\n+      SYMR *sym_end_p1;\n+      PDR *proc_start;\n+      PDR *proc;\n+      PDR *proc_end_p1;\n \n       /* file support itself.  */\n       add_file (filename, filename + strlen (filename));\n@@ -4683,12 +4683,12 @@ copy_object ()\n \t    case st_StaticProc:\n \t      {\n \t\tauto symint_t hash_index;\n-\t\tregister char *str = ORIG_LSTRS (fd_ptr->issBase + sym->iss);\n-\t\tregister Size_t len = strlen (str);\n-\t\tregister shash_t *shash_ptr = hash_string (str,\n-\t\t\t\t\t\t\t   (Ptrdiff_t)len,\n-\t\t\t\t\t\t\t   &orig_str_hash[0],\n-\t\t\t\t\t\t\t   &hash_index);\n+\t\tchar *str = ORIG_LSTRS (fd_ptr->issBase + sym->iss);\n+\t\tSize_t len = strlen (str);\n+\t\tshash_t *shash_ptr = hash_string (str,\n+\t\t\t\t\t\t  (Ptrdiff_t)len,\n+\t\t\t\t\t\t  &orig_str_hash[0],\n+\t\t\t\t\t\t  &hash_index);\n \n \t\tif (shash_ptr != (shash_t *) 0)\n \t\t  error (\"internal error, %s is already in original symbol table\", str);\n@@ -4710,15 +4710,15 @@ copy_object ()\n \t    case st_End:\n \t      if ((sc_t) sym->sc == sc_Text)\n \t\t{\n-\t\t  register char *str = ORIG_LSTRS (fd_ptr->issBase + sym->iss);\n+\t\t  char *str = ORIG_LSTRS (fd_ptr->issBase + sym->iss);\n \n \t\t  if (*str != '\\0')\n \t\t    {\n-\t\t      register Size_t len = strlen (str);\n-\t\t      register shash_t *shash_ptr = hash_string (str,\n-\t\t\t\t\t\t\t\t (Ptrdiff_t)len,\n-\t\t\t\t\t\t\t\t &orig_str_hash[0],\n-\t\t\t\t\t\t\t\t (symint_t *) 0);\n+\t\t      Size_t len = strlen (str);\n+\t\t      shash_t *shash_ptr = hash_string (str,\n+\t\t\t\t\t\t\t(Ptrdiff_t)len,\n+\t\t\t\t\t\t\t&orig_str_hash[0],\n+\t\t\t\t\t\t\t(symint_t *) 0);\n \n \t\t      if (shash_ptr != (shash_t *) 0)\n \t\t\tshash_ptr->end_ptr = sym;\n@@ -4742,13 +4742,13 @@ copy_object ()\n       proc_end_p1 = proc_start + fd_ptr->cpd;\n       for (proc = proc_start; proc < proc_end_p1; proc++)\n \t{\n-\t  register SYMR *proc_sym = ORIG_LSYMS (fd_ptr->isymBase + proc->isym);\n-\t  register char *str = ORIG_LSTRS (fd_ptr->issBase + proc_sym->iss);\n-\t  register Size_t len = strlen (str);\n-\t  register shash_t *shash_ptr = hash_string (str,\n-\t\t\t\t\t\t     (Ptrdiff_t)len,\n-\t\t\t\t\t\t     &orig_str_hash[0],\n-\t\t\t\t\t\t     (symint_t *) 0);\n+\t  SYMR *proc_sym = ORIG_LSYMS (fd_ptr->isymBase + proc->isym);\n+\t  char *str = ORIG_LSTRS (fd_ptr->issBase + proc_sym->iss);\n+\t  Size_t len = strlen (str);\n+\t  shash_t *shash_ptr = hash_string (str,\n+\t\t\t\t\t    (Ptrdiff_t)len,\n+\t\t\t\t\t    &orig_str_hash[0],\n+\t\t\t\t\t    (symint_t *) 0);\n \n \t  if (shash_ptr == (shash_t *) 0)\n \t    error (\"internal error, function %s is not in original symbol table\", str);\n@@ -5091,7 +5091,7 @@ STATIC page_t *\n allocate_cluster (npages)\n      Size_t npages;\n {\n-  register page_t *value = (page_t *) xcalloc (npages, PAGE_USIZE);\n+  page_t *value = (page_t *) xcalloc (npages, PAGE_USIZE);\n \n   if (debug > 3)\n     fprintf (stderr, \"\\talloc\\tnpages = %d, value = 0x%.8x\\n\", npages, value);\n@@ -5105,7 +5105,7 @@ STATIC page_t *\n allocate_cluster (npages)\n      Size_t npages;\n {\n-  register page_t *ptr = (page_t *) sbrk (0);\t/* current sbreak */\n+  page_t *ptr = (page_t *) sbrk (0);\t/* current sbreak */\n   unsigned long offset = ((unsigned long) ptr) & (PAGE_SIZE - 1);\n \n   if (offset != 0)\t\t\t/* align to a page boundary */\n@@ -5227,7 +5227,7 @@ allocate_page ()\n STATIC scope_t *\n allocate_scope ()\n {\n-  register scope_t *ptr;\n+  scope_t *ptr;\n   static scope_t initial_scope;\n \n #ifndef MALLOC_CHECK\n@@ -5237,8 +5237,8 @@ allocate_scope ()\n \n   else\n     {\n-      register int unallocated\t= alloc_counts[ (int)alloc_type_scope ].unallocated;\n-      register page_t *cur_page\t= alloc_counts[ (int)alloc_type_scope ].cur_page;\n+      int unallocated\t= alloc_counts[ (int)alloc_type_scope ].unallocated;\n+      page_t *cur_page\t= alloc_counts[ (int)alloc_type_scope ].cur_page;\n \n       if (unallocated == 0)\n \t{\n@@ -5285,12 +5285,12 @@ free_scope (ptr)\n STATIC vlinks_t *\n allocate_vlinks ()\n {\n-  register vlinks_t *ptr;\n+  vlinks_t *ptr;\n   static vlinks_t initial_vlinks;\n \n #ifndef MALLOC_CHECK\n-  register int unallocated\t= alloc_counts[ (int)alloc_type_vlinks ].unallocated;\n-  register page_t *cur_page\t= alloc_counts[ (int)alloc_type_vlinks ].cur_page;\n+  int unallocated\t= alloc_counts[ (int)alloc_type_vlinks ].unallocated;\n+  page_t *cur_page\t= alloc_counts[ (int)alloc_type_vlinks ].cur_page;\n \n   if (unallocated == 0)\n     {\n@@ -5318,12 +5318,12 @@ allocate_vlinks ()\n STATIC shash_t *\n allocate_shash ()\n {\n-  register shash_t *ptr;\n+  shash_t *ptr;\n   static shash_t initial_shash;\n \n #ifndef MALLOC_CHECK\n-  register int unallocated\t= alloc_counts[ (int)alloc_type_shash ].unallocated;\n-  register page_t *cur_page\t= alloc_counts[ (int)alloc_type_shash ].cur_page;\n+  int unallocated\t= alloc_counts[ (int)alloc_type_shash ].unallocated;\n+  page_t *cur_page\t= alloc_counts[ (int)alloc_type_shash ].cur_page;\n \n   if (unallocated == 0)\n     {\n@@ -5351,12 +5351,12 @@ allocate_shash ()\n STATIC thash_t *\n allocate_thash ()\n {\n-  register thash_t *ptr;\n+  thash_t *ptr;\n   static thash_t initial_thash;\n \n #ifndef MALLOC_CHECK\n-  register int unallocated\t= alloc_counts[ (int)alloc_type_thash ].unallocated;\n-  register page_t *cur_page\t= alloc_counts[ (int)alloc_type_thash ].cur_page;\n+  int unallocated\t= alloc_counts[ (int)alloc_type_thash ].unallocated;\n+  page_t *cur_page\t= alloc_counts[ (int)alloc_type_thash ].cur_page;\n \n   if (unallocated == 0)\n     {\n@@ -5384,7 +5384,7 @@ allocate_thash ()\n STATIC tag_t *\n allocate_tag ()\n {\n-  register tag_t *ptr;\n+  tag_t *ptr;\n   static tag_t initial_tag;\n \n #ifndef MALLOC_CHECK\n@@ -5394,8 +5394,8 @@ allocate_tag ()\n \n   else\n     {\n-      register int unallocated\t= alloc_counts[ (int)alloc_type_tag ].unallocated;\n-      register page_t *cur_page\t= alloc_counts[ (int)alloc_type_tag ].cur_page;\n+      int unallocated\t= alloc_counts[ (int)alloc_type_tag ].unallocated;\n+      page_t *cur_page\t= alloc_counts[ (int)alloc_type_tag ].cur_page;\n \n       if (unallocated == 0)\n \t{\n@@ -5442,7 +5442,7 @@ free_tag (ptr)\n STATIC forward_t *\n allocate_forward ()\n {\n-  register forward_t *ptr;\n+  forward_t *ptr;\n   static forward_t initial_forward;\n \n #ifndef MALLOC_CHECK\n@@ -5452,8 +5452,8 @@ allocate_forward ()\n \n   else\n     {\n-      register int unallocated\t= alloc_counts[ (int)alloc_type_forward ].unallocated;\n-      register page_t *cur_page\t= alloc_counts[ (int)alloc_type_forward ].cur_page;\n+      int unallocated\t= alloc_counts[ (int)alloc_type_forward ].unallocated;\n+      page_t *cur_page\t= alloc_counts[ (int)alloc_type_forward ].cur_page;\n \n       if (unallocated == 0)\n \t{\n@@ -5500,7 +5500,7 @@ free_forward (ptr)\n STATIC thead_t *\n allocate_thead ()\n {\n-  register thead_t *ptr;\n+  thead_t *ptr;\n   static thead_t initial_thead;\n \n #ifndef MALLOC_CHECK\n@@ -5510,8 +5510,8 @@ allocate_thead ()\n \n   else\n     {\n-      register int unallocated\t= alloc_counts[ (int)alloc_type_thead ].unallocated;\n-      register page_t *cur_page\t= alloc_counts[ (int)alloc_type_thead ].cur_page;\n+      int unallocated\t= alloc_counts[ (int)alloc_type_thead ].unallocated;\n+      page_t *cur_page\t= alloc_counts[ (int)alloc_type_thead ].cur_page;\n \n       if (unallocated == 0)\n \t{"}, {"sha": "28e227b60f9bbf3cea73071e4f908a330502e5c7", "filename": "gcc/optabs.c", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=b36948478c22c58018d0a888ee8ca393dea60dc9", "patch": "@@ -645,7 +645,7 @@ expand_binop (mode, binoptab, op0, op1, target, unsignedp, methods)\n        ? OPTAB_WIDEN : methods);\n   enum mode_class class;\n   enum machine_mode wider_mode;\n-  register rtx temp;\n+  rtx temp;\n   int commutative_op = 0;\n   int shift_op = (binoptab->code ==  ASHIFT\n \t\t  || binoptab->code == ASHIFTRT\n@@ -738,7 +738,7 @@ expand_binop (mode, binoptab, op0, op1, target, unsignedp, methods)\n \t  if (GET_MODE (op0) != mode0 && GET_MODE (op1) != mode1\n \t      && GET_MODE (op0) == mode1 && GET_MODE (op1) == mode0)\n \t    {\n-\t      register rtx tmp;\n+\t      rtx tmp;\n \n \t      tmp = op0; op0 = op1; op1 = tmp;\n \t      tmp = xop0; xop0 = xop1; xop1 = tmp;\n@@ -1862,7 +1862,7 @@ sign_expand_binop (mode, uoptab, soptab, op0, op1, target, unsignedp, methods)\n     int unsignedp;\n     enum optab_methods methods;\n {\n-  register rtx temp;\n+  rtx temp;\n   optab direct_optab = unsignedp ? uoptab : soptab;\n   struct optab wide_soptab;\n \n@@ -2011,8 +2011,8 @@ expand_twoval_binop (binoptab, op0, op1, targ0, targ1, unsignedp)\n \t  if (binoptab->handlers[(int) wider_mode].insn_code\n \t      != CODE_FOR_nothing)\n \t    {\n-\t      register rtx t0 = gen_reg_rtx (wider_mode);\n-\t      register rtx t1 = gen_reg_rtx (wider_mode);\n+\t      rtx t0 = gen_reg_rtx (wider_mode);\n+\t      rtx t1 = gen_reg_rtx (wider_mode);\n \t      rtx cop0 = convert_modes (wider_mode, mode, op0, unsignedp);\n \t      rtx cop1 = convert_modes (wider_mode, mode, op1, unsignedp);\n \n@@ -2072,7 +2072,7 @@ expand_unop (mode, unoptab, op0, target, unsignedp)\n {\n   enum mode_class class;\n   enum machine_mode wider_mode;\n-  register rtx temp;\n+  rtx temp;\n   rtx last = get_last_insn ();\n   rtx pat;\n \n@@ -2448,7 +2448,7 @@ expand_complex_abs (mode, op0, target, unsignedp)\n {\n   enum mode_class class = GET_MODE_CLASS (mode);\n   enum machine_mode wider_mode;\n-  register rtx temp;\n+  rtx temp;\n   rtx entry_last = get_last_insn ();\n   rtx last;\n   rtx pat;\n@@ -2649,7 +2649,7 @@ emit_unop_insn (icode, target, op0, code)\n      rtx op0;\n      enum rtx_code code;\n {\n-  register rtx temp;\n+  rtx temp;\n   enum machine_mode mode0 = insn_data[icode].operand[1].mode;\n   rtx pat;\n \n@@ -3923,7 +3923,7 @@ rtx\n gen_move_insn (x, y)\n      rtx x, y;\n {\n-  register enum machine_mode mode = GET_MODE (x);\n+  enum machine_mode mode = GET_MODE (x);\n   enum insn_code insn_code;\n   rtx seq;\n \n@@ -4070,7 +4070,7 @@ expand_float (to, from, unsignedp)\n      int unsignedp;\n {\n   enum insn_code icode;\n-  register rtx target = to;\n+  rtx target = to;\n   enum machine_mode fmode, imode;\n \n   /* Crash now, because we won't be able to decide which mode to use.  */\n@@ -4337,11 +4337,11 @@ ftruncify (x)\n \n void\n expand_fix (to, from, unsignedp)\n-     register rtx to, from;\n+     rtx to, from;\n      int unsignedp;\n {\n   enum insn_code icode;\n-  register rtx target = to;\n+  rtx target = to;\n   enum machine_mode fmode, imode;\n   int must_trunc = 0;\n   rtx libfcn = 0;\n@@ -4625,23 +4625,23 @@ init_optabv (code)\n \n static void\n init_libfuncs (optable, first_mode, last_mode, opname, suffix)\n-    register optab optable;\n-    register int first_mode;\n-    register int last_mode;\n-    register const char *opname;\n-    register int suffix;\n+    optab optable;\n+    int first_mode;\n+    int last_mode;\n+    const char *opname;\n+    int suffix;\n {\n-  register int mode;\n-  register unsigned opname_len = strlen (opname);\n+  int mode;\n+  unsigned opname_len = strlen (opname);\n \n   for (mode = first_mode; (int) mode <= (int) last_mode;\n        mode = (enum machine_mode) ((int) mode + 1))\n     {\n-      register const char *mname = GET_MODE_NAME(mode);\n-      register unsigned mname_len = strlen (mname);\n-      register char *libfunc_name = alloca (2 + opname_len + mname_len + 1 + 1);\n-      register char *p;\n-      register const char *q;\n+      const char *mname = GET_MODE_NAME(mode);\n+      unsigned mname_len = strlen (mname);\n+      char *libfunc_name = alloca (2 + opname_len + mname_len + 1 + 1);\n+      char *p;\n+      const char *q;\n \n       p = libfunc_name;\n       *p++ = '_';\n@@ -4666,9 +4666,9 @@ init_libfuncs (optable, first_mode, last_mode, opname, suffix)\n \n static void\n init_integral_libfuncs (optable, opname, suffix)\n-    register optab optable;\n-    register const char *opname;\n-    register int suffix;\n+    optab optable;\n+    const char *opname;\n+    int suffix;\n {\n   init_libfuncs (optable, SImode, TImode, opname, suffix);\n }\n@@ -4680,16 +4680,16 @@ init_integral_libfuncs (optable, opname, suffix)\n \n static void\n init_floating_libfuncs (optable, opname, suffix)\n-    register optab optable;\n-    register const char *opname;\n-    register int suffix;\n+    optab optable;\n+    const char *opname;\n+    int suffix;\n {\n   init_libfuncs (optable, SFmode, TFmode, opname, suffix);\n }\n \n rtx\n init_one_libfunc (name)\n-     register const char *name;\n+     const char *name;\n {\n   /* Create a FUNCTION_DECL that can be passed to ENCODE_SECTION_INFO.  */\n   /* ??? We don't have any type information except for this is"}, {"sha": "88906731bfd55f94a19c8550dd3e1a2cdc6730d8", "filename": "gcc/prefix.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Fprefix.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Fprefix.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprefix.c?ref=b36948478c22c58018d0a888ee8ca393dea60dc9", "patch": "@@ -115,7 +115,7 @@ save_string (s, len)\n   const char *s;\n   int len;\n {\n-  register char *result = xmalloc (len + 1);\n+  char *result = xmalloc (len + 1);\n \n   memcpy (result, s, len);\n   result[len] = 0;"}, {"sha": "f2025b500ba0eef29d49f153d4702275aea5cd57", "filename": "gcc/print-rtl.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Fprint-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Fprint-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-rtl.c?ref=b36948478c22c58018d0a888ee8ca393dea60dc9", "patch": "@@ -76,12 +76,12 @@ static int debug_call_placeholder_verbose;\n \n static void\n print_rtx (in_rtx)\n-     register rtx in_rtx;\n+     rtx in_rtx;\n {\n-  register int i = 0;\n-  register int j;\n-  register const char *format_ptr;\n-  register int is_insn;\n+  int i = 0;\n+  int j;\n+  const char *format_ptr;\n+  int is_insn;\n   rtx tem;\n \n   if (sawclose)\n@@ -335,7 +335,7 @@ print_rtx (in_rtx)\n \t  }\n \telse\n \t  {\n-\t    register int value = XINT (in_rtx, i);\n+\t    int value = XINT (in_rtx, i);\n \t    const char *name;\n \n \t    if (GET_CODE (in_rtx) == REG && value < FIRST_PSEUDO_REGISTER)\n@@ -639,7 +639,7 @@ print_rtl (outf, rtx_first)\n      FILE *outf;\n      rtx rtx_first;\n {\n-  register rtx tmp_rtx;\n+  rtx tmp_rtx;\n \n   outfile = outf;\n   sawclose = 0;"}, {"sha": "a366dc8c6c25234dd011b507529e5c2d2d900865", "filename": "gcc/read-rtl.c", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Fread-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Fread-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fread-rtl.c?ref=b36948478c22c58018d0a888ee8ca393dea60dc9", "patch": "@@ -105,7 +105,8 @@ int\n read_skip_spaces (infile)\n      FILE *infile;\n {\n-  register int c;\n+  int c;\n+\n   while (1)\n     {\n       c = getc (infile);\n@@ -127,7 +128,7 @@ read_skip_spaces (infile)\n \n \tcase '/':\n \t  {\n-\t    register int prevc;\n+\t    int prevc;\n \t    c = getc (infile);\n \t    if (c != '*')\n \t      fatal_expected_char (infile, '*', c);\n@@ -158,10 +159,10 @@ read_name (str, infile)\n      char *str;\n      FILE *infile;\n {\n-  register char *p;\n-  register int c;\n+  char *p;\n+  int c;\n \n-  c = read_skip_spaces(infile);\n+  c = read_skip_spaces (infile);\n \n   p = str;\n   while (1)\n@@ -212,6 +213,7 @@ read_escape (ob, infile)\n      FILE *infile;\n {\n   int c = getc (infile);\n+\n   switch (c)\n     {\n       /* Backslash-newline is replaced by nothing, as in C.  */\n@@ -266,6 +268,7 @@ read_quoted_string (ob, infile)\n      FILE *infile;\n {\n   int c;\n+\n   while (1)\n     {\n       c = getc (infile); /* Read the string  */\n@@ -500,15 +503,15 @@ rtx\n read_rtx (infile)\n      FILE *infile;\n {\n-  register int i, j;\n+  int i, j;\n   RTX_CODE tmp_code;\n-  register const char *format_ptr;\n+  const char *format_ptr;\n   /* tmp_char is a buffer used for reading decimal integers\n      and names of rtx types and machine modes.\n      Therefore, 256 must be enough.  */\n   char tmp_char[256];\n   rtx return_rtx;\n-  register int c;\n+  int c;\n   int tmp_int;\n   HOST_WIDE_INT tmp_wide;\n "}, {"sha": "0cb2cdb41347dc6826773db9c794747dbf085852", "filename": "gcc/real.c", "status": "modified", "additions": 47, "deletions": 47, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Freal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Freal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freal.c?ref=b36948478c22c58018d0a888ee8ca393dea60dc9", "patch": "@@ -1606,9 +1606,9 @@ extern int rndprc;\n \n static void\n eclear (x)\n-     register UEMUSHORT *x;\n+     UEMUSHORT *x;\n {\n-  register int i;\n+  int i;\n \n   for (i = 0; i < NE; i++)\n     *x++ = 0;\n@@ -1618,9 +1618,9 @@ eclear (x)\n \n static void\n emov (a, b)\n-     register UEMUSHORT *a, *b;\n+     UEMUSHORT *a, *b;\n {\n-  register int i;\n+  int i;\n \n   for (i = 0; i < NE; i++)\n     *b++ = *a++;\n@@ -1708,9 +1708,9 @@ eisnan (x)\n \n static void\n einfin (x)\n-     register UEMUSHORT *x;\n+     UEMUSHORT *x;\n {\n-  register int i;\n+  int i;\n \n #ifdef INFINITY\n   for (i = 0; i < NE - 1; i++)\n@@ -1752,10 +1752,10 @@ einfin (x)\n #ifdef NANS\n static void\n enan (x, sign)\n-     register UEMUSHORT *x;\n+     UEMUSHORT *x;\n      int sign;\n {\n-  register int i;\n+  int i;\n \n   for (i = 0; i < NE - 2; i++)\n     *x++ = 0;\n@@ -1770,7 +1770,7 @@ static void\n emovi (a, b)\n      UEMUSHORT *a, *b;\n {\n-  register UEMUSHORT *p, *q;\n+  UEMUSHORT *p, *q;\n   int i;\n \n   q = b;\n@@ -1817,7 +1817,7 @@ static void\n emovo (a, b)\n      UEMUSHORT *a, *b;\n {\n-  register UEMUSHORT *p, *q;\n+  UEMUSHORT *p, *q;\n   UEMUSHORT i;\n   int j;\n \n@@ -1854,9 +1854,9 @@ emovo (a, b)\n \n static void\n ecleaz (xi)\n-     register UEMUSHORT *xi;\n+     UEMUSHORT *xi;\n {\n-  register int i;\n+  int i;\n \n   for (i = 0; i < NI; i++)\n     *xi++ = 0;\n@@ -1866,9 +1866,9 @@ ecleaz (xi)\n \n static void\n ecleazs (xi)\n-     register UEMUSHORT *xi;\n+     UEMUSHORT *xi;\n {\n-  register int i;\n+  int i;\n \n   ++xi;\n   for (i = 0; i < NI - 1; i++)\n@@ -1879,9 +1879,9 @@ ecleazs (xi)\n \n static void\n emovz (a, b)\n-     register UEMUSHORT *a, *b;\n+     UEMUSHORT *a, *b;\n {\n-  register int i;\n+  int i;\n \n   for (i = 0; i < NI - 1; i++)\n     *b++ = *a++;\n@@ -1979,7 +1979,7 @@ eiisinf (x)\n \n static int\n ecmpm (a, b)\n-     register UEMUSHORT *a, *b;\n+     UEMUSHORT *a, *b;\n {\n   int i;\n \n@@ -2003,9 +2003,9 @@ ecmpm (a, b)\n \n static void\n eshdn1 (x)\n-     register UEMUSHORT *x;\n+     UEMUSHORT *x;\n {\n-  register UEMUSHORT bits;\n+  UEMUSHORT bits;\n   int i;\n \n   x += M;\t\t\t/* point to significand area */\n@@ -2027,9 +2027,9 @@ eshdn1 (x)\n \n static void\n eshup1 (x)\n-     register UEMUSHORT *x;\n+     UEMUSHORT *x;\n {\n-  register UEMUSHORT bits;\n+  UEMUSHORT bits;\n   int i;\n \n   x += NI - 1;\n@@ -2052,9 +2052,9 @@ eshup1 (x)\n \n static void\n eshdn8 (x)\n-     register UEMUSHORT *x;\n+     UEMUSHORT *x;\n {\n-  register UEMUSHORT newbyt, oldbyt;\n+  UEMUSHORT newbyt, oldbyt;\n   int i;\n \n   x += M;\n@@ -2073,10 +2073,10 @@ eshdn8 (x)\n \n static void\n eshup8 (x)\n-     register UEMUSHORT *x;\n+     UEMUSHORT *x;\n {\n   int i;\n-  register UEMUSHORT newbyt, oldbyt;\n+  UEMUSHORT newbyt, oldbyt;\n \n   x += NI - 1;\n   oldbyt = 0;\n@@ -2095,10 +2095,10 @@ eshup8 (x)\n \n static void\n eshup6 (x)\n-     register UEMUSHORT *x;\n+     UEMUSHORT *x;\n {\n   int i;\n-  register UEMUSHORT *p;\n+  UEMUSHORT *p;\n \n   p = x + M;\n   x += M + 1;\n@@ -2113,10 +2113,10 @@ eshup6 (x)\n \n static void\n eshdn6 (x)\n-     register UEMUSHORT *x;\n+     UEMUSHORT *x;\n {\n   int i;\n-  register UEMUSHORT *p;\n+  UEMUSHORT *p;\n \n   x += NI - 1;\n   p = x + 1;\n@@ -2133,7 +2133,7 @@ static void\n eaddm (x, y)\n      UEMUSHORT *x, *y;\n {\n-  register unsigned EMULONG a;\n+  unsigned EMULONG a;\n   int i;\n   unsigned int carry;\n \n@@ -2194,7 +2194,7 @@ edivm (den, num)\n      UEMUSHORT den[], num[];\n {\n   int i;\n-  register UEMUSHORT *p, *q;\n+  UEMUSHORT *p, *q;\n   UEMUSHORT j;\n \n   p = &equot[0];\n@@ -2344,8 +2344,8 @@ m16m (a, b, c)\n      unsigned int a;\n      UEMUSHORT b[], c[];\n {\n-  register UEMUSHORT *pp;\n-  register unsigned EMULONG carry;\n+  UEMUSHORT *pp;\n+  unsigned EMULONG carry;\n   UEMUSHORT *ps;\n   UEMUSHORT p[NI];\n   unsigned EMULONG aa, m;\n@@ -2388,7 +2388,7 @@ edivm (den, num)\n      UEMUSHORT den[], num[];\n {\n   int i;\n-  register UEMUSHORT *p;\n+  UEMUSHORT *p;\n   unsigned EMULONG tnum;\n   UEMUSHORT j, tdenm, tquot;\n   UEMUSHORT tprod[NI+1];\n@@ -3135,8 +3135,8 @@ e53toe (pe, y)\n   c4xtoe (pe, y, HFmode);\n \n #else\n-  register UEMUSHORT r;\n-  register UEMUSHORT *e, *p;\n+  UEMUSHORT r;\n+  UEMUSHORT *e, *p;\n   UEMUSHORT yy[NI];\n   int denorm, k;\n \n@@ -3352,7 +3352,7 @@ static void\n e113toe (pe, y)\n      UEMUSHORT *pe, *y;\n {\n-  register UEMUSHORT r;\n+  UEMUSHORT r;\n   UEMUSHORT *e, *p;\n   UEMUSHORT yy[NI];\n   int denorm, i;\n@@ -3450,8 +3450,8 @@ e24toe (pe, y)\n \n #else\n \n-  register UEMUSHORT r;\n-  register UEMUSHORT *e, *p;\n+  UEMUSHORT r;\n+  UEMUSHORT *e, *p;\n   UEMUSHORT yy[NI];\n   int denorm, k;\n \n@@ -3576,7 +3576,7 @@ static void\n toe113 (a, b)\n      UEMUSHORT *a, *b;\n {\n-  register UEMUSHORT *p, *q;\n+  UEMUSHORT *p, *q;\n   UEMUSHORT i;\n \n #ifdef NANS\n@@ -3670,7 +3670,7 @@ static void\n toe64 (a, b)\n      UEMUSHORT *a, *b;\n {\n-  register UEMUSHORT *p, *q;\n+  UEMUSHORT *p, *q;\n   UEMUSHORT i;\n \n #ifdef NANS\n@@ -4161,8 +4161,8 @@ ecmp (a, b)\n      UEMUSHORT *a, *b;\n {\n   UEMUSHORT ai[NI], bi[NI];\n-  register UEMUSHORT *p, *q;\n-  register int i;\n+  UEMUSHORT *p, *q;\n+  int i;\n   int msign;\n \n #ifdef NANS\n@@ -4534,7 +4534,7 @@ static int\n enormlz (x)\n      UEMUSHORT x[];\n {\n-  register UEMUSHORT *p;\n+  UEMUSHORT *p;\n   int sc;\n \n   sc = 0;\n@@ -5561,7 +5561,7 @@ static void\n efloor (x, y)\n      UEMUSHORT x[], y[];\n {\n-  register UEMUSHORT *p;\n+  UEMUSHORT *p;\n   int e, expon, i;\n   UEMUSHORT f[NE];\n \n@@ -5795,7 +5795,7 @@ dectoe (d, e)\n      UEMUSHORT *e;\n {\n   UEMUSHORT y[NI];\n-  register UEMUSHORT r, *p;\n+  UEMUSHORT r, *p;\n \n   ecleaz (y);\t\t\t/* start with a zero */\n   p = y;\t\t\t/* point to our number */\n@@ -5904,7 +5904,7 @@ ibmtoe (d, e, mode)\n      enum machine_mode mode;\n {\n   UEMUSHORT y[NI];\n-  register UEMUSHORT r, *p;\n+  UEMUSHORT r, *p;\n \n   ecleaz (y);\t\t\t/* start with a zero */\n   p = y;\t\t\t/* point to our number */"}, {"sha": "e240ebbe2cc7788bef973cd822a4baa7dfec7df9", "filename": "gcc/recog.c", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=b36948478c22c58018d0a888ee8ca393dea60dc9", "patch": "@@ -437,9 +437,9 @@ validate_replace_rtx_1 (loc, from, to, object)\n      rtx *loc;\n      rtx from, to, object;\n {\n-  register int i, j;\n-  register const char *fmt;\n-  register rtx x = *loc;\n+  int i, j;\n+  const char *fmt;\n+  rtx x = *loc;\n   enum rtx_code code;\n   enum machine_mode op0_mode = VOIDmode;\n   int prev_changes = num_changes;\n@@ -687,7 +687,7 @@ int\n next_insn_tests_no_inequality (insn)\n      rtx insn;\n {\n-  register rtx next = next_cc0_user (insn);\n+  rtx next = next_cc0_user (insn);\n \n   /* If there is no next insn, we have to take the conservative choice.  */\n   if (next == 0)\n@@ -707,7 +707,7 @@ int\n next_insns_test_no_inequality (insn)\n      rtx insn;\n {\n-  register rtx next = NEXT_INSN (insn);\n+  rtx next = NEXT_INSN (insn);\n \n   for (; next != 0; next = NEXT_INSN (next))\n     {\n@@ -913,10 +913,10 @@ find_single_use (dest, insn, ploc)\n \n int\n general_operand (op, mode)\n-     register rtx op;\n+     rtx op;\n      enum machine_mode mode;\n {\n-  register enum rtx_code code = GET_CODE (op);\n+  enum rtx_code code = GET_CODE (op);\n \n   if (mode == VOIDmode)\n     mode = GET_MODE (op);\n@@ -976,7 +976,7 @@ general_operand (op, mode)\n \n   if (code == MEM)\n     {\n-      register rtx y = XEXP (op, 0);\n+      rtx y = XEXP (op, 0);\n \n       if (! volatile_ok && MEM_VOLATILE_P (op))\n \treturn 0;\n@@ -1008,7 +1008,7 @@ general_operand (op, mode)\n \n int\n address_operand (op, mode)\n-     register rtx op;\n+     rtx op;\n      enum machine_mode mode;\n {\n   return memory_address_p (mode, op);\n@@ -1030,7 +1030,7 @@ address_operand (op, mode)\n \n int\n register_operand (op, mode)\n-     register rtx op;\n+     rtx op;\n      enum machine_mode mode;\n {\n   if (GET_MODE (op) != mode && mode != VOIDmode)\n@@ -1089,7 +1089,7 @@ pmode_register_operand (op, mode)\n \n int\n scratch_operand (op, mode)\n-     register rtx op;\n+     rtx op;\n      enum machine_mode mode;\n {\n   if (GET_MODE (op) != mode && mode != VOIDmode)\n@@ -1107,7 +1107,7 @@ scratch_operand (op, mode)\n \n int\n immediate_operand (op, mode)\n-     register rtx op;\n+     rtx op;\n      enum machine_mode mode;\n {\n   /* Don't accept CONST_INT or anything similar\n@@ -1140,7 +1140,7 @@ immediate_operand (op, mode)\n \n int\n const_int_operand (op, mode)\n-     register rtx op;\n+     rtx op;\n      enum machine_mode mode;\n {\n   if (GET_CODE (op) != CONST_INT)\n@@ -1158,7 +1158,7 @@ const_int_operand (op, mode)\n \n int\n const_double_operand (op, mode)\n-     register rtx op;\n+     rtx op;\n      enum machine_mode mode;\n {\n   /* Don't accept CONST_INT or anything similar\n@@ -1177,7 +1177,7 @@ const_double_operand (op, mode)\n \n int\n nonimmediate_operand (op, mode)\n-     register rtx op;\n+     rtx op;\n      enum machine_mode mode;\n {\n   return (general_operand (op, mode) && ! CONSTANT_P (op));\n@@ -1187,7 +1187,7 @@ nonimmediate_operand (op, mode)\n \n int\n nonmemory_operand (op, mode)\n-     register rtx op;\n+     rtx op;\n      enum machine_mode mode;\n {\n   if (CONSTANT_P (op))\n@@ -1312,7 +1312,7 @@ pop_operand (op, mode)\n int\n memory_address_p (mode, addr)\n      enum machine_mode mode ATTRIBUTE_UNUSED;\n-     register rtx addr;\n+     rtx addr;\n {\n   if (GET_CODE (addr) == ADDRESSOF)\n     return 1;\n@@ -1332,7 +1332,7 @@ memory_address_p (mode, addr)\n \n int\n memory_operand (op, mode)\n-     register rtx op;\n+     rtx op;\n      enum machine_mode mode;\n {\n   rtx inner;\n@@ -1357,14 +1357,14 @@ memory_operand (op, mode)\n \n int\n indirect_operand (op, mode)\n-     register rtx op;\n+     rtx op;\n      enum machine_mode mode;\n {\n   /* Before reload, a SUBREG isn't in memory (see memory_operand, above).  */\n   if (! reload_completed\n       && GET_CODE (op) == SUBREG && GET_CODE (SUBREG_REG (op)) == MEM)\n     {\n-      register int offset = SUBREG_BYTE (op);\n+      int offset = SUBREG_BYTE (op);\n       rtx inner = SUBREG_REG (op);\n \n       if (mode != VOIDmode && GET_MODE (op) != mode)\n@@ -1392,7 +1392,7 @@ indirect_operand (op, mode)\n \n int\n comparison_operator (op, mode)\n-    register rtx op;\n+    rtx op;\n     enum machine_mode mode;\n {\n   return ((mode == VOIDmode || GET_MODE (op) == mode)\n@@ -1496,7 +1496,7 @@ decode_asm_operands (body, operands, operand_locs, constraints, modes)\n      const char **constraints;\n      enum machine_mode *modes;\n {\n-  register int i;\n+  int i;\n   int noperands;\n   const char *template = 0;\n \n@@ -1828,8 +1828,8 @@ rtx *\n find_constant_term_loc (p)\n      rtx *p;\n {\n-  register rtx *tem;\n-  register enum rtx_code code = GET_CODE (*p);\n+  rtx *tem;\n+  enum rtx_code code = GET_CODE (*p);\n \n   /* If *P IS such a constant term, P is its location.  */\n \n@@ -1911,10 +1911,10 @@ int\n offsettable_address_p (strictp, mode, y)\n      int strictp;\n      enum machine_mode mode;\n-     register rtx y;\n+     rtx y;\n {\n-  register enum rtx_code ycode = GET_CODE (y);\n-  register rtx z;\n+  enum rtx_code ycode = GET_CODE (y);\n+  rtx z;\n   rtx y1 = y;\n   rtx *y2;\n   int (*addressp) PARAMS ((enum machine_mode, rtx)) =\n@@ -2291,7 +2291,7 @@ constrain_operands (strict)\n   const char *constraints[MAX_RECOG_OPERANDS];\n   int matching_operands[MAX_RECOG_OPERANDS];\n   int earlyclobber[MAX_RECOG_OPERANDS];\n-  register int c;\n+  int c;\n \n   struct funny_match funny_match[MAX_RECOG_OPERANDS];\n   int funny_match_index;\n@@ -2308,15 +2308,15 @@ constrain_operands (strict)\n \n   do\n     {\n-      register int opno;\n+      int opno;\n       int lose = 0;\n       funny_match_index = 0;\n \n       for (opno = 0; opno < recog_data.n_operands; opno++)\n \t{\n-\t  register rtx op = recog_data.operand[opno];\n+\t  rtx op = recog_data.operand[opno];\n \t  enum machine_mode mode = GET_MODE (op);\n-\t  register const char *p = constraints[opno];\n+\t  const char *p = constraints[opno];\n \t  int offset = 0;\n \t  int win = 0;\n \t  int val;\n@@ -2631,16 +2631,16 @@ constrain_operands (strict)\n int\n reg_fits_class_p (operand, class, offset, mode)\n      rtx operand;\n-     register enum reg_class class;\n+     enum reg_class class;\n      int offset;\n      enum machine_mode mode;\n {\n-  register int regno = REGNO (operand);\n+  int regno = REGNO (operand);\n   if (regno < FIRST_PSEUDO_REGISTER\n       && TEST_HARD_REG_BIT (reg_class_contents[(int) class],\n \t\t\t    regno + offset))\n     {\n-      register int sr;\n+      int sr;\n       regno += offset;\n       for (sr = HARD_REGNO_NREGS (regno, mode) - 1;\n \t   sr > 0; sr--)"}, {"sha": "b79c8741f005e59abd14d65a9e55221e1b6784e0", "filename": "gcc/reg-stack.c", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Freg-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Freg-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.c?ref=b36948478c22c58018d0a888ee8ca393dea60dc9", "patch": "@@ -273,8 +273,8 @@ static int\n stack_regs_mentioned_p (pat)\n      rtx pat;\n {\n-  register const char *fmt;\n-  register int i;\n+  const char *fmt;\n+  int i;\n \n   if (STACK_REG_P (pat))\n     return 1;\n@@ -284,7 +284,7 @@ stack_regs_mentioned_p (pat)\n     {\n       if (fmt[i] == 'E')\n \t{\n-\t  register int j;\n+\t  int j;\n \n \t  for (j = XVECLEN (pat, i) - 1; j >= 0; j--)\n \t    if (stack_regs_mentioned_p (XVECEXP (pat, i, j)))\n@@ -508,14 +508,14 @@ static void\n record_label_references (insn, pat)\n      rtx insn, pat;\n {\n-  register enum rtx_code code = GET_CODE (pat);\n-  register int i;\n-  register const char *fmt;\n+  enum rtx_code code = GET_CODE (pat);\n+  int i;\n+  const char *fmt;\n \n   if (code == LABEL_REF)\n     {\n-      register rtx label = XEXP (pat, 0);\n-      register rtx ref;\n+      rtx label = XEXP (pat, 0);\n+      rtx ref;\n \n       if (GET_CODE (label) != CODE_LABEL)\n \tabort ();\n@@ -547,7 +547,7 @@ record_label_references (insn, pat)\n \trecord_label_references (insn, XEXP (pat, i));\n       if (fmt[i] == 'E')\n \t{\n-\t  register int j;\n+\t  int j;\n \t  for (j = 0; j < XVECLEN (pat, i); j++)\n \t    record_label_references (insn, XVECEXP (pat, i, j));\n \t}\n@@ -867,7 +867,7 @@ remove_regno_note (insn, note, regno)\n      enum reg_note note;\n      unsigned int regno;\n {\n-  register rtx *note_link, this;\n+  rtx *note_link, this;\n \n   note_link = &REG_NOTES(insn);\n   for (this = *note_link; this; this = XEXP (this, 1))\n@@ -1206,8 +1206,8 @@ static int\n swap_rtx_condition_1 (pat)\n      rtx pat;\n {\n-  register const char *fmt;\n-  register int i, r = 0;\n+  const char *fmt;\n+  int i, r = 0;\n \n   if (GET_RTX_CLASS (GET_CODE (pat)) == '<')\n     {\n@@ -1221,7 +1221,7 @@ swap_rtx_condition_1 (pat)\n \t{\n \t  if (fmt[i] == 'E')\n \t    {\n-\t      register int j;\n+\t      int j;\n \n \t      for (j = XVECLEN (pat, i) - 1; j >= 0; j--)\n \t\tr |= swap_rtx_condition_1 (XVECEXP (pat, i, j));\n@@ -2155,8 +2155,8 @@ subst_stack_regs (insn, regstack)\n      rtx insn;\n      stack regstack;\n {\n-  register rtx *note_link, note;\n-  register int i;\n+  rtx *note_link, note;\n+  int i;\n \n   if (GET_CODE (insn) == CALL_INSN)\n     {"}, {"sha": "a514bd5a4a6b2c14391f1c366a6042d8b9cc65c1", "filename": "gcc/regclass.c", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Fregclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Fregclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregclass.c?ref=b36948478c22c58018d0a888ee8ca393dea60dc9", "patch": "@@ -276,7 +276,7 @@ static int no_global_reg_vars = 0;\n void\n init_reg_sets ()\n {\n-  register int i, j;\n+  int i, j;\n \n   /* First copy the register information from the initial int form into\n      the regsets.  */\n@@ -311,8 +311,8 @@ init_reg_sets ()\n static void\n init_reg_sets_1 ()\n {\n-  register unsigned int i, j;\n-  register unsigned int /* enum machine_mode */ m;\n+  unsigned int i, j;\n+  unsigned int /* enum machine_mode */ m;\n   char allocatable_regs_of_mode [MAX_MACHINE_MODE];\n \n   /* This macro allows the fixed or call-used registers\n@@ -342,7 +342,7 @@ init_reg_sets_1 ()\n \t  register\t\t/* Declare it register if it's a scalar.  */\n #endif\n \t    HARD_REG_SET c;\n-\t  register int k;\n+\t  int k;\n \n \t  COPY_HARD_REG_SET (c, reg_class_contents[i]);\n \t  IOR_HARD_REG_SET (c, reg_class_contents[j]);\n@@ -376,7 +376,7 @@ init_reg_sets_1 ()\n \t  register\t\t/* Declare it register if it's a scalar.  */\n #endif\n \t    HARD_REG_SET c;\n-\t  register int k;\n+\t  int k;\n \n \t  COPY_HARD_REG_SET (c, reg_class_contents[i]);\n \t  IOR_HARD_REG_SET (c, reg_class_contents[j]);\n@@ -578,7 +578,7 @@ init_reg_sets_1 ()\n static void\n init_reg_modes ()\n {\n-  register int i;\n+  int i;\n \n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n     {\n@@ -1163,8 +1163,8 @@ regclass (f, nregs, dump)\n      int nregs;\n      FILE *dump;\n {\n-  register rtx insn;\n-  register int i;\n+  rtx insn;\n+  int i;\n   int pass;\n \n   init_recog ();\n@@ -1188,7 +1188,7 @@ regclass (f, nregs, dump)\n     {\n       rtx r = gen_rtx_REG (VOIDmode, 0);\n       enum machine_mode m;\n-      register int j;\n+      int j;\n \n       for (j = 0; j < FIRST_PSEUDO_REGISTER; j++)\n \tif (TEST_HARD_REG_BIT (reg_class_contents[i], j))\n@@ -1289,12 +1289,12 @@ regclass (f, nregs, dump)\n \t}\n       for (i = FIRST_PSEUDO_REGISTER; i < nregs; i++)\n \t{\n-\t  register int best_cost = (1 << (HOST_BITS_PER_INT - 2)) - 1;\n+\t  int best_cost = (1 << (HOST_BITS_PER_INT - 2)) - 1;\n \t  enum reg_class best = ALL_REGS, alt = NO_REGS;\n \t  /* This is an enum reg_class, but we call it an int\n \t     to save lots of casts.  */\n-\t  register int class;\n-\t  register struct costs *p = &costs[i];\n+\t  int class;\n+\t  struct costs *p = &costs[i];\n \n \t  /* In non-optimizing compilation REG_N_REFS is not initialized\n \t     yet.  */\n@@ -1948,7 +1948,7 @@ record_address_regs (x, class, scale)\n      enum reg_class class;\n      int scale;\n {\n-  register enum rtx_code code = GET_CODE (x);\n+  enum rtx_code code = GET_CODE (x);\n \n   switch (code)\n     {\n@@ -1976,8 +1976,8 @@ record_address_regs (x, class, scale)\n       {\n \trtx arg0 = XEXP (x, 0);\n \trtx arg1 = XEXP (x, 1);\n-\tregister enum rtx_code code0 = GET_CODE (arg0);\n-\tregister enum rtx_code code1 = GET_CODE (arg1);\n+\tenum rtx_code code0 = GET_CODE (arg0);\n+\tenum rtx_code code1 = GET_CODE (arg1);\n \n \t/* Look inside subregs.  */\n \tif (code0 == SUBREG)\n@@ -2097,8 +2097,8 @@ record_address_regs (x, class, scale)\n \n     case REG:\n       {\n-\tregister struct costs *pp = &costs[REGNO (x)];\n-\tregister int i;\n+\tstruct costs *pp = &costs[REGNO (x)];\n+\tint i;\n \n \tpp->mem_cost += (MEMORY_MOVE_COST (Pmode, class, 1) * scale) / 2;\n \n@@ -2109,8 +2109,8 @@ record_address_regs (x, class, scale)\n \n     default:\n       {\n-\tregister const char *fmt = GET_RTX_FORMAT (code);\n-\tregister int i;\n+\tconst char *fmt = GET_RTX_FORMAT (code);\n+\tint i;\n \tfor (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n \t  if (fmt[i] == 'e')\n \t    record_address_regs (XEXP (x, i), class, scale);\n@@ -2318,7 +2318,7 @@ reg_scan (f, nregs, repeat)\n      unsigned int nregs;\n      int repeat ATTRIBUTE_UNUSED;\n {\n-  register rtx insn;\n+  rtx insn;\n \n   allocate_reg_info (nregs, TRUE, FALSE);\n   max_parallel = 3;\n@@ -2352,7 +2352,7 @@ reg_scan_update (first, last, old_max_regno)\n      rtx last;\n      unsigned int old_max_regno;\n {\n-  register rtx insn;\n+  rtx insn;\n \n   allocate_reg_info (max_reg_num (), FALSE, FALSE);\n \n@@ -2383,9 +2383,9 @@ reg_scan_mark_refs (x, insn, note_flag, min_regno)\n      int note_flag;\n      unsigned int min_regno;\n {\n-  register enum rtx_code code;\n-  register rtx dest;\n-  register rtx note;\n+  enum rtx_code code;\n+  rtx dest;\n+  rtx note;\n \n   code = GET_CODE (x);\n   switch (code)\n@@ -2500,15 +2500,15 @@ reg_scan_mark_refs (x, insn, note_flag, min_regno)\n \n     default:\n       {\n-\tregister const char *fmt = GET_RTX_FORMAT (code);\n-\tregister int i;\n+\tconst char *fmt = GET_RTX_FORMAT (code);\n+\tint i;\n \tfor (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n \t  {\n \t    if (fmt[i] == 'e')\n \t      reg_scan_mark_refs (XEXP (x, i), insn, note_flag, min_regno);\n \t    else if (fmt[i] == 'E' && XVEC (x, i) != 0)\n \t      {\n-\t\tregister int j;\n+\t\tint j;\n \t\tfor (j = XVECLEN (x, i) - 1; j >= 0; j--)\n \t\t  reg_scan_mark_refs (XVECEXP (x, i, j), insn, note_flag, min_regno);\n \t      }\n@@ -2522,8 +2522,8 @@ reg_scan_mark_refs (x, insn, note_flag, min_regno)\n \n int\n reg_class_subset_p (c1, c2)\n-     register enum reg_class c1;\n-     register enum reg_class c2;\n+     enum reg_class c1;\n+     enum reg_class c2;\n {\n   if (c1 == c2) return 1;\n \n@@ -2540,8 +2540,8 @@ reg_class_subset_p (c1, c2)\n \n int\n reg_classes_intersect_p (c1, c2)\n-     register enum reg_class c1;\n-     register enum reg_class c2;\n+     enum reg_class c1;\n+     enum reg_class c2;\n {\n #ifdef HARD_REG_SET\n   register"}, {"sha": "ce62cce72a5f001e01fcacf7a9ab041be0029196", "filename": "gcc/regmove.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Fregmove.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Fregmove.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregmove.c?ref=b36948478c22c58018d0a888ee8ca393dea60dc9", "patch": "@@ -863,7 +863,7 @@ reg_is_remote_constant_p (reg, insn, first)\n      rtx insn;\n      rtx first;\n {\n-  register rtx p;\n+  rtx p;\n \n   if (REG_N_SETS (REGNO (reg)) != 1)\n     return 0;"}, {"sha": "613d6c7e2c7a8f921e175a7d32c6ec5e8518fa25", "filename": "gcc/reload.c", "status": "modified", "additions": 75, "deletions": 75, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=b36948478c22c58018d0a888ee8ca393dea60dc9", "patch": "@@ -857,7 +857,7 @@ push_reload (in, out, inloc, outloc, class,\n      int opnum;\n      enum reload_type type;\n {\n-  register int i;\n+  int i;\n   int dont_share = 0;\n   int dont_remove_subreg = 0;\n   rtx *in_subreg_loc = 0, *out_subreg_loc = 0;\n@@ -879,7 +879,7 @@ push_reload (in, out, inloc, outloc, class,\n      Often this is done earlier, but not always in find_reloads_address.  */\n   if (in != 0 && GET_CODE (in) == REG)\n     {\n-      register int regno = REGNO (in);\n+      int regno = REGNO (in);\n \n       if (regno >= FIRST_PSEUDO_REGISTER && reg_renumber[regno] < 0\n \t  && reg_equiv_constant[regno] != 0)\n@@ -891,7 +891,7 @@ push_reload (in, out, inloc, outloc, class,\n      (in the case of a parameter).  */\n   if (out != 0 && GET_CODE (out) == REG)\n     {\n-      register int regno = REGNO (out);\n+      int regno = REGNO (out);\n \n       if (regno >= FIRST_PSEUDO_REGISTER && reg_renumber[regno] < 0\n \t  && reg_equiv_constant[regno] != 0)\n@@ -1402,15 +1402,15 @@ push_reload (in, out, inloc, outloc, class,\n     {\n       if (inloc != 0)\n \t{\n-\t  register struct replacement *r = &replacements[n_replacements++];\n+\t  struct replacement *r = &replacements[n_replacements++];\n \t  r->what = i;\n \t  r->subreg_loc = in_subreg_loc;\n \t  r->where = inloc;\n \t  r->mode = inmode;\n \t}\n       if (outloc != 0 && outloc != inloc)\n \t{\n-\t  register struct replacement *r = &replacements[n_replacements++];\n+\t  struct replacement *r = &replacements[n_replacements++];\n \t  r->what = i;\n \t  r->where = outloc;\n \t  r->subreg_loc = out_subreg_loc;\n@@ -1537,7 +1537,7 @@ push_replacement (loc, reloadnum, mode)\n {\n   if (replace_reloads)\n     {\n-      register struct replacement *r = &replacements[n_replacements++];\n+      struct replacement *r = &replacements[n_replacements++];\n       r->what = reloadnum;\n       r->where = loc;\n       r->subreg_loc = 0;\n@@ -1978,7 +1978,7 @@ hard_reg_set_here_p (beg_regno, end_regno, x)\n {\n   if (GET_CODE (x) == SET || GET_CODE (x) == CLOBBER)\n     {\n-      register rtx op0 = SET_DEST (x);\n+      rtx op0 = SET_DEST (x);\n \n       while (GET_CODE (op0) == SUBREG)\n \top0 = SUBREG_REG (op0);\n@@ -1994,7 +1994,7 @@ hard_reg_set_here_p (beg_regno, end_regno, x)\n     }\n   else if (GET_CODE (x) == PARALLEL)\n     {\n-      register int i = XVECLEN (x, 0) - 1;\n+      int i = XVECLEN (x, 0) - 1;\n \n       for (; i >= 0; i--)\n \tif (hard_reg_set_here_p (beg_regno, end_regno, XVECEXP (x, 0, i)))\n@@ -2011,7 +2011,7 @@ hard_reg_set_here_p (beg_regno, end_regno, x)\n int\n strict_memory_address_p (mode, addr)\n      enum machine_mode mode ATTRIBUTE_UNUSED;\n-     register rtx addr;\n+     rtx addr;\n {\n   GO_IF_LEGITIMATE_ADDRESS (mode, addr, win);\n   return 0;\n@@ -2037,11 +2037,11 @@ strict_memory_address_p (mode, addr)\n \n int\n operands_match_p (x, y)\n-     register rtx x, y;\n+     rtx x, y;\n {\n-  register int i;\n-  register RTX_CODE code = GET_CODE (x);\n-  register const char *fmt;\n+  int i;\n+  RTX_CODE code = GET_CODE (x);\n+  const char *fmt;\n   int success_2;\n \n   if (x == y)\n@@ -2050,7 +2050,7 @@ operands_match_p (x, y)\n       && (GET_CODE (y) == REG || (GET_CODE (y) == SUBREG\n \t\t\t\t  && GET_CODE (SUBREG_REG (y)) == REG)))\n     {\n-      register int j;\n+      int j;\n \n       if (code == SUBREG)\n \t{\n@@ -2410,8 +2410,8 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n      int live_known;\n      short *reload_reg_p;\n {\n-  register int insn_code_number;\n-  register int i, j;\n+  int insn_code_number;\n+  int i, j;\n   int noperands;\n   /* These start out as the constraints for the insn\n      and they are chewed up as we consider alternatives.  */\n@@ -2524,8 +2524,8 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \n   for (i = 0; i < noperands; i++)\n     {\n-      register char *p;\n-      register int c;\n+      char *p;\n+      int c;\n \n       substed_operand[i] = recog_data.operand[i];\n       p = constraints[i];\n@@ -2596,7 +2596,7 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \n   for (i = 0; i < noperands; i++)\n     {\n-      register RTX_CODE code = GET_CODE (recog_data.operand[i]);\n+      RTX_CODE code = GET_CODE (recog_data.operand[i]);\n \n       address_reloaded[i] = 0;\n       operand_type[i] = (modified[i] == RELOAD_READ ? RELOAD_FOR_INPUT\n@@ -2687,7 +2687,7 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t     we replace it by the constant.  We must be sure, however,\n \t     that we don't try to replace it in the insn in which it\n \t     is being set.  */\n-\t  register int regno = REGNO (recog_data.operand[i]);\n+\t  int regno = REGNO (recog_data.operand[i]);\n \t  if (reg_equiv_constant[regno] != 0\n \t      && (set == 0 || &SET_DEST (set) != recog_data.operand_loc[i]))\n \t    {\n@@ -2774,15 +2774,15 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \n       for (i = 0; i < noperands; i++)\n \t{\n-\t  register char *p = constraints[i];\n-\t  register int win = 0;\n+\t  char *p = constraints[i];\n+\t  int win = 0;\n \t  int did_match = 0;\n \t  /* 0 => this operand can be reloaded somehow for this alternative.  */\n \t  int badop = 1;\n \t  /* 0 => this operand can be reloaded if the alternative allows regs.  */\n \t  int winreg = 0;\n \t  int c;\n-\t  register rtx operand = recog_data.operand[i];\n+\t  rtx operand = recog_data.operand[i];\n \t  int offset = 0;\n \t  /* Nonzero means this is a MEM that must be reloaded into a reg\n \t     regardless of what the constraint says.  */\n@@ -3494,8 +3494,8 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n       swapped = !swapped;\n       if (swapped)\n \t{\n-\t  register enum reg_class tclass;\n-\t  register int t;\n+\t  enum reg_class tclass;\n+\t  int t;\n \n \t  recog_data.operand[commutative] = substed_operand[commutative + 1];\n \t  recog_data.operand[commutative + 1] = substed_operand[commutative];\n@@ -3564,7 +3564,7 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \n   if (goal_alternative_swapped)\n     {\n-      register rtx tem;\n+      rtx tem;\n \n       tem = substed_operand[commutative];\n       substed_operand[commutative] = substed_operand[commutative + 1];\n@@ -4229,7 +4229,7 @@ alternative_allows_memconst (constraint, altnum)\n      const char *constraint;\n      int altnum;\n {\n-  register int c;\n+  int c;\n   /* Skip alternatives before the one requested.  */\n   while (altnum > 0)\n     {\n@@ -4277,16 +4277,16 @@ find_reloads_toplev (x, opnum, type, ind_levels, is_set_dest, insn,\n      rtx insn;\n      int *address_reloaded;\n {\n-  register RTX_CODE code = GET_CODE (x);\n+  RTX_CODE code = GET_CODE (x);\n \n-  register const char *fmt = GET_RTX_FORMAT (code);\n-  register int i;\n+  const char *fmt = GET_RTX_FORMAT (code);\n+  int i;\n   int copied;\n \n   if (code == REG)\n     {\n       /* This code is duplicated for speed in find_reloads.  */\n-      register int regno = REGNO (x);\n+      int regno = REGNO (x);\n       if (reg_equiv_constant[regno] != 0 && !is_set_dest)\n \tx = reg_equiv_constant[regno];\n #if 0\n@@ -4343,7 +4343,7 @@ find_reloads_toplev (x, opnum, type, ind_levels, is_set_dest, insn,\n \t the register (this should never happen because one of the cases\n \t above should handle it).  */\n \n-      register int regno = REGNO (SUBREG_REG (x));\n+      int regno = REGNO (SUBREG_REG (x));\n       rtx tem;\n \n       if (subreg_lowpart_p (x)\n@@ -4514,7 +4514,7 @@ find_reloads_address (mode, memrefloc, ad, loc, opnum, type, ind_levels, insn)\n      int ind_levels;\n      rtx insn;\n {\n-  register int regno;\n+  int regno;\n   int removed_and = 0;\n   rtx tem;\n \n@@ -4874,9 +4874,9 @@ subst_reg_equivs (ad, insn)\n      rtx ad;\n      rtx insn;\n {\n-  register RTX_CODE code = GET_CODE (ad);\n-  register int i;\n-  register const char *fmt;\n+  RTX_CODE code = GET_CODE (ad);\n+  int i;\n+  const char *fmt;\n \n   switch (code)\n     {\n@@ -4892,7 +4892,7 @@ subst_reg_equivs (ad, insn)\n \n     case REG:\n       {\n-\tregister int regno = REGNO (ad);\n+\tint regno = REGNO (ad);\n \n \tif (reg_equiv_constant[regno] != 0)\n \t  {\n@@ -5105,18 +5105,18 @@ find_reloads_address_1 (mode, x, context, loc, opnum, type, ind_levels, insn)\n      int ind_levels;\n      rtx insn;\n {\n-  register RTX_CODE code = GET_CODE (x);\n+  RTX_CODE code = GET_CODE (x);\n \n   switch (code)\n     {\n     case PLUS:\n       {\n-\tregister rtx orig_op0 = XEXP (x, 0);\n-\tregister rtx orig_op1 = XEXP (x, 1);\n-\tregister RTX_CODE code0 = GET_CODE (orig_op0);\n-\tregister RTX_CODE code1 = GET_CODE (orig_op1);\n-\tregister rtx op0 = orig_op0;\n-\tregister rtx op1 = orig_op1;\n+\trtx orig_op0 = XEXP (x, 0);\n+\trtx orig_op1 = XEXP (x, 1);\n+\tRTX_CODE code0 = GET_CODE (orig_op0);\n+\tRTX_CODE code1 = GET_CODE (orig_op1);\n+\trtx op0 = orig_op0;\n+\trtx op1 = orig_op1;\n \n \tif (GET_CODE (op0) == SUBREG)\n \t  {\n@@ -5316,7 +5316,7 @@ find_reloads_address_1 (mode, x, context, loc, opnum, type, ind_levels, insn)\n     case PRE_DEC:\n       if (GET_CODE (XEXP (x, 0)) == REG)\n \t{\n-\t  register int regno = REGNO (XEXP (x, 0));\n+\t  int regno = REGNO (XEXP (x, 0));\n \t  int value = 0;\n \t  rtx x_orig = x;\n \n@@ -5429,7 +5429,7 @@ find_reloads_address_1 (mode, x, context, loc, opnum, type, ind_levels, insn)\n \t     reload it into a register.  */\n \t  /* Variable `tem' might or might not be used in FIND_REG_INC_NOTE.  */\n \t  rtx tem ATTRIBUTE_UNUSED = XEXP (x, 0);\n-\t  register rtx link;\n+\t  rtx link;\n \t  int reloadnum;\n \n \t  /* Since we know we are going to reload this item, don't decrement\n@@ -5481,7 +5481,7 @@ find_reloads_address_1 (mode, x, context, loc, opnum, type, ind_levels, insn)\n \n     case REG:\n       {\n-\tregister int regno = REGNO (x);\n+\tint regno = REGNO (x);\n \n \tif (reg_equiv_constant[regno] != 0)\n \t  {\n@@ -5586,8 +5586,8 @@ find_reloads_address_1 (mode, x, context, loc, opnum, type, ind_levels, insn)\n     }\n \n   {\n-    register const char *fmt = GET_RTX_FORMAT (code);\n-    register int i;\n+    const char *fmt = GET_RTX_FORMAT (code);\n+    int i;\n \n     for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n       {\n@@ -5765,12 +5765,12 @@ void\n subst_reloads (insn)\n      rtx insn;\n {\n-  register int i;\n+  int i;\n \n   for (i = 0; i < n_replacements; i++)\n     {\n-      register struct replacement *r = &replacements[i];\n-      register rtx reloadreg = rld[r->what].reg_rtx;\n+      struct replacement *r = &replacements[i];\n+      rtx reloadreg = rld[r->what].reg_rtx;\n       if (reloadreg)\n \t{\n #ifdef ENABLE_CHECKING\n@@ -6090,7 +6090,7 @@ refers_to_regno_for_reload_p (regno, endregno, x, loc)\n \t}\n       else if (fmt[i] == 'E')\n \t{\n-\t  register int j;\n+\t  int j;\n \t  for (j = XVECLEN (x, i) - 1; j >= 0; j--)\n \t    if (loc != &XVECEXP (x, i, j)\n \t\t&& refers_to_regno_for_reload_p (regno, endregno,\n@@ -6218,18 +6218,18 @@ refers_to_mem_for_reload_p (x)\n \n rtx\n find_equiv_reg (goal, insn, class, other, reload_reg_p, goalreg, mode)\n-     register rtx goal;\n+     rtx goal;\n      rtx insn;\n      enum reg_class class;\n-     register int other;\n+     int other;\n      short *reload_reg_p;\n      int goalreg;\n      enum machine_mode mode;\n {\n-  register rtx p = insn;\n+  rtx p = insn;\n   rtx goaltry, valtry, value, where;\n-  register rtx pat;\n-  register int regno = -1;\n+  rtx pat;\n+  int regno = -1;\n   int valueno;\n   int goal_mem = 0;\n   int goal_const = 0;\n@@ -6515,15 +6515,15 @@ find_equiv_reg (goal, insn, class, other, reload_reg_p, goalreg, mode)\n \t    pat = COND_EXEC_CODE (pat);\n \t  if (GET_CODE (pat) == SET || GET_CODE (pat) == CLOBBER)\n \t    {\n-\t      register rtx dest = SET_DEST (pat);\n+\t      rtx dest = SET_DEST (pat);\n \t      while (GET_CODE (dest) == SUBREG\n \t\t     || GET_CODE (dest) == ZERO_EXTRACT\n \t\t     || GET_CODE (dest) == SIGN_EXTRACT\n \t\t     || GET_CODE (dest) == STRICT_LOW_PART)\n \t\tdest = XEXP (dest, 0);\n \t      if (GET_CODE (dest) == REG)\n \t\t{\n-\t\t  register int xregno = REGNO (dest);\n+\t\t  int xregno = REGNO (dest);\n \t\t  int xnregs;\n \t\t  if (REGNO (dest) < FIRST_PSEUDO_REGISTER)\n \t\t    xnregs = HARD_REGNO_NREGS (xregno, GET_MODE (dest));\n@@ -6551,23 +6551,23 @@ find_equiv_reg (goal, insn, class, other, reload_reg_p, goalreg, mode)\n \t    }\n \t  else if (GET_CODE (pat) == PARALLEL)\n \t    {\n-\t      register int i;\n+\t      int i;\n \t      for (i = XVECLEN (pat, 0) - 1; i >= 0; i--)\n \t\t{\n-\t\t  register rtx v1 = XVECEXP (pat, 0, i);\n+\t\t  rtx v1 = XVECEXP (pat, 0, i);\n \t\t  if (GET_CODE (v1) == COND_EXEC)\n \t\t    v1 = COND_EXEC_CODE (v1);\n \t\t  if (GET_CODE (v1) == SET || GET_CODE (v1) == CLOBBER)\n \t\t    {\n-\t\t      register rtx dest = SET_DEST (v1);\n+\t\t      rtx dest = SET_DEST (v1);\n \t\t      while (GET_CODE (dest) == SUBREG\n \t\t\t     || GET_CODE (dest) == ZERO_EXTRACT\n \t\t\t     || GET_CODE (dest) == SIGN_EXTRACT\n \t\t\t     || GET_CODE (dest) == STRICT_LOW_PART)\n \t\t\tdest = XEXP (dest, 0);\n \t\t      if (GET_CODE (dest) == REG)\n \t\t\t{\n-\t\t\t  register int xregno = REGNO (dest);\n+\t\t\t  int xregno = REGNO (dest);\n \t\t\t  int xnregs;\n \t\t\t  if (REGNO (dest) < FIRST_PSEUDO_REGISTER)\n \t\t\t    xnregs = HARD_REGNO_NREGS (xregno, GET_MODE (dest));\n@@ -6609,11 +6609,11 @@ find_equiv_reg (goal, insn, class, other, reload_reg_p, goalreg, mode)\n \t\t  pat = XEXP (link, 0);\n \t\t  if (GET_CODE (pat) == CLOBBER)\n \t\t    {\n-\t\t      register rtx dest = SET_DEST (pat);\n+\t\t      rtx dest = SET_DEST (pat);\n \n \t\t      if (GET_CODE (dest) == REG)\n \t\t\t{\n-\t\t\t  register int xregno = REGNO (dest);\n+\t\t\t  int xregno = REGNO (dest);\n \t\t\t  int xnregs\n \t\t\t    = HARD_REGNO_NREGS (xregno, GET_MODE (dest));\n \n@@ -6645,13 +6645,13 @@ find_equiv_reg (goal, insn, class, other, reload_reg_p, goalreg, mode)\n \t     If GOAL is a memory ref and its address is not constant,\n \t     and this insn P increments a register used in GOAL, return 0.  */\n \t  {\n-\t    register rtx link;\n+\t    rtx link;\n \n \t    for (link = REG_NOTES (p); link; link = XEXP (link, 1))\n \t      if (REG_NOTE_KIND (link) == REG_INC\n \t\t  && GET_CODE (XEXP (link, 0)) == REG)\n \t\t{\n-\t\t  register int incno = REGNO (XEXP (link, 0));\n+\t\t  int incno = REGNO (XEXP (link, 0));\n \t\t  if (incno < regno + nregs && incno >= regno)\n \t\t    return 0;\n \t\t  if (incno < valueno + valuenregs && incno >= valueno)\n@@ -6675,13 +6675,13 @@ static int\n find_inc_amount (x, inced)\n      rtx x, inced;\n {\n-  register enum rtx_code code = GET_CODE (x);\n-  register const char *fmt;\n-  register int i;\n+  enum rtx_code code = GET_CODE (x);\n+  const char *fmt;\n+  int i;\n \n   if (code == MEM)\n     {\n-      register rtx addr = XEXP (x, 0);\n+      rtx addr = XEXP (x, 0);\n       if ((GET_CODE (addr) == PRE_DEC\n \t   || GET_CODE (addr) == POST_DEC\n \t   || GET_CODE (addr) == PRE_INC\n@@ -6705,16 +6705,16 @@ find_inc_amount (x, inced)\n     {\n       if (fmt[i] == 'e')\n \t{\n-\t  register int tem = find_inc_amount (XEXP (x, i), inced);\n+\t  int tem = find_inc_amount (XEXP (x, i), inced);\n \t  if (tem != 0)\n \t    return tem;\n \t}\n       if (fmt[i] == 'E')\n \t{\n-\t  register int j;\n+\t  int j;\n \t  for (j = XVECLEN (x, i) - 1; j >= 0; j--)\n \t    {\n-\t      register int tem = find_inc_amount (XVECEXP (x, i, j), inced);\n+\t      int tem = find_inc_amount (XVECEXP (x, i, j), inced);\n \t      if (tem != 0)\n \t\treturn tem;\n \t    }"}, {"sha": "2be0983a2acc676403ccf0ee0153b333f1b9a08d", "filename": "gcc/reload1.c", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=b36948478c22c58018d0a888ee8ca393dea60dc9", "patch": "@@ -467,13 +467,13 @@ extern void dump_needs\t\t\tPARAMS ((struct insn_chain *));\n void\n init_reload ()\n {\n-  register int i;\n+  int i;\n \n   /* Often (MEM (REG n)) is still valid even if (REG n) is put on the stack.\n      Set spill_indirect_levels to the number of levels such addressing is\n      permitted, zero if it is not permitted at all.  */\n \n-  register rtx tem\n+  rtx tem\n     = gen_rtx_MEM (Pmode,\n \t\t   gen_rtx_PLUS (Pmode,\n \t\t\t\t gen_rtx_REG (Pmode,\n@@ -672,9 +672,9 @@ reload (first, global)\n      rtx first;\n      int global;\n {\n-  register int i;\n-  register rtx insn;\n-  register struct elim_table *ep;\n+  int i;\n+  rtx insn;\n+  struct elim_table *ep;\n \n   /* The two pointers used to track the true location of the memory used\n      for label offsets.  */\n@@ -1519,8 +1519,8 @@ reload_reg_class_lower (r1p, r2p)\n      const PTR r1p;\n      const PTR r2p;\n {\n-  register int r1 = *(const short *) r1p, r2 = *(const short *) r2p;\n-  register int t;\n+  int r1 = *(const short *) r1p, r2 = *(const short *) r2p;\n+  int t;\n \n   /* Consider required reloads before optional ones.  */\n   t = rld[r1].optional - rld[r2].optional;\n@@ -1921,7 +1921,7 @@ delete_dead_insn (insn)\n \n static void\n alter_reg (i, from_reg)\n-     register int i;\n+     int i;\n      int from_reg;\n {\n   /* When outputting an inline function, this can happen\n@@ -1947,7 +1947,7 @@ alter_reg (i, from_reg)\n       && reg_equiv_constant[i] == 0\n       && reg_equiv_memory_loc[i] == 0)\n     {\n-      register rtx x;\n+      rtx x;\n       unsigned int inherent_size = PSEUDO_REGNO_BYTES (i);\n       unsigned int total_size = MAX (inherent_size, reg_max_ref_width[i]);\n       int adjust = 0;\n@@ -2053,7 +2053,7 @@ void\n mark_home_live (regno)\n      int regno;\n {\n-  register int i, lim;\n+  int i, lim;\n \n   i = reg_renumber[regno];\n   if (i < 0)\n@@ -3262,7 +3262,7 @@ mark_not_eliminable (dest, x, data)\n      rtx x;\n      void *data ATTRIBUTE_UNUSED;\n {\n-  register unsigned int i;\n+  unsigned int i;\n \n   /* A SUBREG of a hard register here is just changing its mode.  We should\n      not see a SUBREG of an eliminable hard register, but check just in\n@@ -3404,7 +3404,7 @@ update_eliminables (pset)\n   for (ep = reg_eliminate; ep < &reg_eliminate[NUM_ELIMINABLE_REGS]; ep++)\n     {\n       struct elim_table *op;\n-      register int new_to = -1;\n+      int new_to = -1;\n \n       if (! ep->can_eliminate && ep->can_eliminate_previous)\n \t{\n@@ -3530,7 +3530,7 @@ spill_hard_reg (regno, cant_eliminate)\n      unsigned int regno;\n      int cant_eliminate;\n {\n-  register int i;\n+  int i;\n \n   if (cant_eliminate)\n     {\n@@ -3718,11 +3718,11 @@ finish_spills (global)\n \n static void\n scan_paradoxical_subregs (x)\n-     register rtx x;\n+     rtx x;\n {\n-  register int i;\n-  register const char *fmt;\n-  register enum rtx_code code = GET_CODE (x);\n+  int i;\n+  const char *fmt;\n+  enum rtx_code code = GET_CODE (x);\n \n   switch (code)\n     {\n@@ -3763,7 +3763,7 @@ scan_paradoxical_subregs (x)\n \tscan_paradoxical_subregs (XEXP (x, i));\n       else if (fmt[i] == 'E')\n \t{\n-\t  register int j;\n+\t  int j;\n \t  for (j = XVECLEN (x, i) - 1; j >= 0; j--)\n \t    scan_paradoxical_subregs (XVECEXP (x, i, j));\n \t}\n@@ -3785,7 +3785,7 @@ reload_as_needed (live_known)\n {\n   struct insn_chain *chain;\n #if defined (AUTO_INC_DEC)\n-  register int i;\n+  int i;\n #endif\n   rtx x;\n \n@@ -5276,7 +5276,7 @@ choose_reload_regs (chain)\n      struct insn_chain *chain;\n {\n   rtx insn = chain->insn;\n-  register int i, j;\n+  int i, j;\n   unsigned int max_group_size = 1;\n   enum reg_class group_class = NO_REGS;\n   int pass, win, inheritance;\n@@ -5340,7 +5340,7 @@ choose_reload_regs (chain)\n \n       for (j = 0; j < n_reloads; j++)\n \t{\n-\t  register int r = reload_order[j];\n+\t  int r = reload_order[j];\n \t  rtx search_equiv = NULL_RTX;\n \n \t  /* Ignore reloads that got marked inoperative.  */\n@@ -5393,7 +5393,7 @@ choose_reload_regs (chain)\n \t  if (inheritance)\n \t    {\n \t      int byte = 0;\n-\t      register int regno = -1;\n+\t      int regno = -1;\n \t      enum machine_mode mode = VOIDmode;\n \n \t      if (rld[r].in == 0)\n@@ -5612,7 +5612,7 @@ choose_reload_regs (chain)\n \n \t  if (search_equiv)\n \t    {\n-\t      register rtx equiv\n+\t      rtx equiv\n \t\t= find_equiv_reg (search_equiv, insn, rld[r].class,\n \t\t\t\t  -1, NULL, 0, rld[r].mode);\n \t      int regno = 0;\n@@ -5787,7 +5787,7 @@ choose_reload_regs (chain)\n \t didn't get one yet.  */\n       for (j = 0; j < n_reloads; j++)\n \t{\n-\t  register int r = reload_order[j];\n+\t  int r = reload_order[j];\n \n \t  /* Ignore reloads that got marked inoperative.  */\n \t  if (rld[r].out == 0 && rld[r].in == 0 && ! rld[r].secondary_p)\n@@ -5848,7 +5848,7 @@ choose_reload_regs (chain)\n     {\n       for (j = 0; j < n_reloads; j++)\n \t{\n-\t  register int r = reload_order[j];\n+\t  int r = reload_order[j];\n \t  rtx check_reg;\n \t  if (reload_inherited[r] && rld[r].reg_rtx)\n \t    check_reg = rld[r].reg_rtx;\n@@ -5915,7 +5915,7 @@ choose_reload_regs (chain)\n   /* Record which pseudos and which spill regs have output reloads.  */\n   for (j = 0; j < n_reloads; j++)\n     {\n-      register int r = reload_order[j];\n+      int r = reload_order[j];\n \n       i = reload_spill_index[r];\n \n@@ -5925,7 +5925,7 @@ choose_reload_regs (chain)\n       if (rld[r].out_reg != 0 && GET_CODE (rld[r].out_reg) == REG\n \t  && rld[r].reg_rtx != 0)\n \t{\n-\t  register int nregno = REGNO (rld[r].out_reg);\n+\t  int nregno = REGNO (rld[r].out_reg);\n \t  int nr = 1;\n \n \t  if (nregno < FIRST_PSEUDO_REGISTER)\n@@ -6106,7 +6106,7 @@ emit_input_reload_insns (chain, rl, old, j)\n      int j;\n {\n   rtx insn = chain->insn;\n-  register rtx reloadreg = rl->reg_rtx;\n+  rtx reloadreg = rl->reg_rtx;\n   rtx oldequiv_reg = 0;\n   rtx oldequiv = 0;\n   int special = 0;\n@@ -6937,7 +6937,7 @@ emit_reload_insns (chain)\n {\n   rtx insn = chain->insn;\n \n-  register int j;\n+  int j;\n \n   CLEAR_HARD_REG_SET (reg_reloaded_died);\n \n@@ -7028,8 +7028,8 @@ emit_reload_insns (chain)\n \n   for (j = 0; j < n_reloads; j++)\n     {\n-      register int r = reload_order[j];\n-      register int i = reload_spill_index[r];\n+      int r = reload_order[j];\n+      int i = reload_spill_index[r];\n \n       /* If this is a non-inherited input reload from a pseudo, we must\n \t clear any memory of a previous store to the same pseudo.  Only do\n@@ -7104,7 +7104,7 @@ emit_reload_insns (chain)\n \t\t\t     : rld[r].out_reg\n \t\t\t     ? rld[r].out_reg\n /* AUTO_INC */\t\t     : XEXP (rld[r].in_reg, 0));\n-\t\t  register int nregno = REGNO (out);\n+\t\t  int nregno = REGNO (out);\n \t\t  int nnr = (nregno >= FIRST_PSEUDO_REGISTER ? 1\n \t\t\t     : HARD_REGNO_NREGS (nregno,\n \t\t\t\t\t\t GET_MODE (rld[r].reg_rtx)));\n@@ -7152,7 +7152,7 @@ emit_reload_insns (chain)\n \t\t\t       && ! reg_has_output_reload[REGNO (rld[r].in_reg)]))\n \t\t       && ! reg_set_p (rld[r].reg_rtx, PATTERN (insn)))\n \t\t{\n-\t\t  register int nregno;\n+\t\t  int nregno;\n \t\t  int nnr;\n \n \t\t  if (GET_CODE (rld[r].in) == REG\n@@ -7225,7 +7225,7 @@ emit_reload_insns (chain)\n \t{\n \t  rtx out = (GET_CODE (rld[r].out) == REG\n \t\t     ? rld[r].out : rld[r].out_reg);\n-\t  register int nregno = REGNO (out);\n+\t  int nregno = REGNO (out);\n \t  if (nregno >= FIRST_PSEUDO_REGISTER)\n \t    {\n \t      rtx src_reg, store_insn = NULL_RTX;\n@@ -7541,7 +7541,7 @@ delete_output_reload (insn, j, last_reload_reg)\n   int k;\n   int n_occurrences;\n   int n_inherited = 0;\n-  register rtx i1;\n+  rtx i1;\n   rtx substed;\n \n   /* Get the raw pseudo-register referred to.  */"}, {"sha": "5132aef73c7fb632b7656a1e1b2ab7db36e25811", "filename": "gcc/reorg.c", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Freorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Freorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freorg.c?ref=b36948478c22c58018d0a888ee8ca393dea60dc9", "patch": "@@ -301,8 +301,8 @@ resource_conflicts_p (res1, res2)\n \n static int\n insn_references_resource_p (insn, res, include_delayed_effects)\n-     register rtx insn;\n-     register struct resources *res;\n+     rtx insn;\n+     struct resources *res;\n      int include_delayed_effects;\n {\n   struct resources insn_res;\n@@ -319,8 +319,8 @@ insn_references_resource_p (insn, res, include_delayed_effects)\n \n static int\n insn_sets_resource_p (insn, res, include_delayed_effects)\n-     register rtx insn;\n-     register struct resources *res;\n+     rtx insn;\n+     struct resources *res;\n      int include_delayed_effects;\n {\n   struct resources insn_sets;\n@@ -436,8 +436,8 @@ emit_delay_sequence (insn, list, length)\n      rtx list;\n      int length;\n {\n-  register int i = 1;\n-  register rtx li;\n+  int i = 1;\n+  rtx li;\n   int had_barrier = 0;\n \n   /* Allocate the rtvec to hold the insns and the SEQUENCE.  */\n@@ -719,9 +719,9 @@ note_delay_statistics (slots_filled, index)\n \n static rtx\n optimize_skip (insn)\n-     register rtx insn;\n+     rtx insn;\n {\n-  register rtx trial = next_nonnote_insn (insn);\n+  rtx trial = next_nonnote_insn (insn);\n   rtx next_trial = next_active_insn (trial);\n   rtx delay_list = 0;\n   rtx target_label;\n@@ -2034,8 +2034,8 @@ static void\n fill_simple_delay_slots (non_jumps_p)\n      int non_jumps_p;\n {\n-  register rtx insn, pat, trial, next_trial;\n-  register int i;\n+  rtx insn, pat, trial, next_trial;\n+  int i;\n   int num_unfilled_slots = unfilled_slots_next - unfilled_slots_base;\n   struct resources needed, set;\n   int slots_to_fill, slots_filled;\n@@ -2943,8 +2943,8 @@ fill_slots_from_thread (insn, condition, thread, opposite_thread, likely,\n static void\n fill_eager_delay_slots ()\n {\n-  register rtx insn;\n-  register int i;\n+  rtx insn;\n+  int i;\n   int num_unfilled_slots = unfilled_slots_next - unfilled_slots_base;\n \n   for (i = 0; i < num_unfilled_slots; i++)\n@@ -3072,8 +3072,8 @@ static void\n relax_delay_slots (first)\n      rtx first;\n {\n-  register rtx insn, next, pat;\n-  register rtx trial, delay_insn, target_label;\n+  rtx insn, next, pat;\n+  rtx trial, delay_insn, target_label;\n \n   /* Look at every JUMP_INSN and see if we can improve it.  */\n   for (insn = first; insn; insn = next)\n@@ -3662,7 +3662,7 @@ dbr_schedule (first, file)\n \n   if (file)\n     {\n-      register int i, j, need_comma;\n+      int i, j, need_comma;\n       int total_delay_slots[MAX_DELAY_HISTOGRAM + 1];\n       int total_annul_slots[MAX_DELAY_HISTOGRAM + 1];\n "}, {"sha": "ebff8c61887486d9021035752543c4aec8f17a9a", "filename": "gcc/resource.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Fresource.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Fresource.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fresource.c?ref=b36948478c22c58018d0a888ee8ca393dea60dc9", "patch": "@@ -196,14 +196,14 @@ next_insn_no_annul (insn)\n \n void\n mark_referenced_resources (x, res, include_delayed_effects)\n-     register rtx x;\n-     register struct resources *res;\n-     register int include_delayed_effects;\n+     rtx x;\n+     struct resources *res;\n+     int include_delayed_effects;\n {\n   enum rtx_code code = GET_CODE (x);\n   int i, j;\n   unsigned int r;\n-  register const char *format_ptr;\n+  const char *format_ptr;\n \n   /* Handle leaf items for which we set resource flags.  Also, special-case\n      CALL, SET and CLOBBER operators.  */\n@@ -623,8 +623,8 @@ find_dead_or_set_registers (target, res, jump_target, jump_count, set, needed)\n \n void\n mark_set_resources (x, res, in_dest, mark_type)\n-     register rtx x;\n-     register struct resources *res;\n+     rtx x;\n+     struct resources *res;\n      int in_dest;\n      enum mark_resource_type mark_type;\n {"}, {"sha": "bcf300522f4db7df6f2ca95be648c15720045a0c", "filename": "gcc/rtl.c", "status": "modified", "additions": 23, "deletions": 22, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Frtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Frtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.c?ref=b36948478c22c58018d0a888ee8ca393dea60dc9", "patch": "@@ -330,12 +330,12 @@ rtx_alloc (code)\n \n rtx\n copy_rtx (orig)\n-     register rtx orig;\n+     rtx orig;\n {\n-  register rtx copy;\n-  register int i, j;\n-  register RTX_CODE code;\n-  register const char *format_ptr;\n+  rtx copy;\n+  int i, j;\n+  RTX_CODE code;\n+  const char *format_ptr;\n \n   code = GET_CODE (orig);\n \n@@ -435,13 +435,13 @@ copy_rtx (orig)\n \n rtx\n copy_most_rtx (orig, may_share)\n-     register rtx orig;\n-     register rtx may_share;\n+     rtx orig;\n+     rtx may_share;\n {\n-  register rtx copy;\n-  register int i, j;\n-  register RTX_CODE code;\n-  register const char *format_ptr;\n+  rtx copy;\n+  int i, j;\n+  RTX_CODE code;\n+  const char *format_ptr;\n \n   if (orig == may_share)\n     return orig;\n@@ -534,9 +534,9 @@ rtx\n shallow_copy_rtx (orig)\n      rtx orig;\n {\n-  register int i;\n-  register RTX_CODE code = GET_CODE (orig);\n-  register rtx copy = rtx_alloc (code);\n+  int i;\n+  RTX_CODE code = GET_CODE (orig);\n+  rtx copy = rtx_alloc (code);\n \n   PUT_MODE (copy, GET_MODE (orig));\n   copy->in_struct = orig->in_struct;\n@@ -564,10 +564,10 @@ int\n rtx_equal_p (x, y)\n      rtx x, y;\n {\n-  register int i;\n-  register int j;\n-  register enum rtx_code code;\n-  register const char *fmt;\n+  int i;\n+  int j;\n+  enum rtx_code code;\n+  const char *fmt;\n \n   if (x == y)\n     return 1;\n@@ -589,10 +589,11 @@ rtx_equal_p (x, y)\n   switch (code)\n     {\n     case REG:\n-      /* Until rtl generation is complete, don't consider a reference to the\n-\t return register of the current function the same as the return from a\n-\t called function.  This eases the job of function integration.  Once the\n-\t distinction is no longer needed, they can be considered equivalent.  */\n+      /* Until rtl generation is complete, don't consider a reference\n+\t to the return register of the current function the same as\n+\t the return from a called function.  This eases the job of\n+\t function integration.  Once the distinction is no longer\n+\t needed, they can be considered equivalent.  */\n       return (REGNO (x) == REGNO (y)\n \t      && (! rtx_equal_function_value_matters\n \t\t  || REG_FUNCTION_VALUE_P (x) == REG_FUNCTION_VALUE_P (y)));"}, {"sha": "ee40d6c790835e392a544e9d5b1d2d7e8e5bb735", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 56, "deletions": 56, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=b36948478c22c58018d0a888ee8ca393dea60dc9", "patch": "@@ -47,9 +47,9 @@ int\n rtx_unstable_p (x)\n      rtx x;\n {\n-  register RTX_CODE code = GET_CODE (x);\n-  register int i;\n-  register const char *fmt;\n+  RTX_CODE code = GET_CODE (x);\n+  int i;\n+  const char *fmt;\n \n   switch (code)\n     {\n@@ -123,9 +123,9 @@ rtx_varies_p (x, for_alias)\n      rtx x;\n      int for_alias;\n {\n-  register RTX_CODE code = GET_CODE (x);\n-  register int i;\n-  register const char *fmt;\n+  RTX_CODE code = GET_CODE (x);\n+  int i;\n+  const char *fmt;\n \n   switch (code)\n     {\n@@ -202,9 +202,9 @@ rtx_varies_p (x, for_alias)\n \n int\n rtx_addr_can_trap_p (x)\n-     register rtx x;\n+     rtx x;\n {\n-  register enum rtx_code code = GET_CODE (x);\n+  enum rtx_code code = GET_CODE (x);\n \n   switch (code)\n     {\n@@ -269,9 +269,9 @@ rtx_addr_varies_p (x, for_alias)\n      rtx x;\n      int for_alias;\n {\n-  register enum rtx_code code;\n-  register int i;\n-  register const char *fmt;\n+  enum rtx_code code;\n+  int i;\n+  const char *fmt;\n \n   if (x == 0)\n     return 0;\n@@ -407,11 +407,11 @@ count_occurrences (x, find, count_dest)\n \n int\n reg_mentioned_p (reg, in)\n-     register rtx reg, in;\n+     rtx reg, in;\n {\n-  register const char *fmt;\n-  register int i;\n-  register enum rtx_code code;\n+  const char *fmt;\n+  int i;\n+  enum rtx_code code;\n \n   if (in == 0)\n     return 0;\n@@ -457,7 +457,7 @@ reg_mentioned_p (reg, in)\n     {\n       if (fmt[i] == 'E')\n \t{\n-\t  register int j;\n+\t  int j;\n \t  for (j = XVECLEN (in, i) - 1; j >= 0; j--)\n \t    if (reg_mentioned_p (reg, XVECEXP (in, i, j)))\n \t      return 1;\n@@ -476,7 +476,7 @@ int\n no_labels_between_p (beg, end)\n      rtx beg, end;\n {\n-  register rtx p;\n+  rtx p;\n   if (beg == end)\n     return 0;\n   for (p = NEXT_INSN (beg); p != end; p = NEXT_INSN (p))\n@@ -492,7 +492,7 @@ int\n no_jumps_between_p (beg, end)\n      rtx beg, end;\n {\n-  register rtx p;\n+  rtx p;\n   for (p = NEXT_INSN (beg); p != end; p = NEXT_INSN (p))\n     if (GET_CODE (p) == JUMP_INSN)\n       return 0;\n@@ -506,7 +506,7 @@ int\n reg_used_between_p (reg, from_insn, to_insn)\n      rtx reg, from_insn, to_insn;\n {\n-  register rtx insn;\n+  rtx insn;\n \n   if (from_insn == to_insn)\n     return 0;\n@@ -605,7 +605,7 @@ int\n reg_referenced_between_p (reg, from_insn, to_insn)\n      rtx reg, from_insn, to_insn;\n {\n-  register rtx insn;\n+  rtx insn;\n \n   if (from_insn == to_insn)\n     return 0;\n@@ -626,7 +626,7 @@ int\n reg_set_between_p (reg, from_insn, to_insn)\n      rtx reg, from_insn, to_insn;\n {\n-  register rtx insn;\n+  rtx insn;\n \n   if (from_insn == to_insn)\n     return 0;\n@@ -1218,7 +1218,7 @@ refers_to_regno_p (regno, endregno, x, loc)\n \t}\n       else if (fmt[i] == 'E')\n \t{\n-\t  register int j;\n+\t  int j;\n \t  for (j = XVECLEN (x, i) - 1; j >=0; j--)\n \t    if (loc != &XVECEXP (x, i, j)\n \t\t&& refers_to_regno_p (regno, endregno, XVECEXP (x, i, j), loc))\n@@ -1364,7 +1364,7 @@ reg_set_last (x, insn)\n      \n void\n note_stores (x, fun, data)\n-     register rtx x;\n+     rtx x;\n      void (*fun) PARAMS ((rtx, rtx, void *));\n      void *data;\n {\n@@ -1375,7 +1375,7 @@ note_stores (x, fun, data)\n \n   if (GET_CODE (x) == SET || GET_CODE (x) == CLOBBER)\n     {\n-      register rtx dest = SET_DEST (x);\n+      rtx dest = SET_DEST (x);\n \n       while ((GET_CODE (dest) == SUBREG\n \t      && (GET_CODE (SUBREG_REG (dest)) != REG\n@@ -1582,7 +1582,7 @@ dead_or_set_regno_p (insn, test_regno)\n     }\n   else if (GET_CODE (pattern) == PARALLEL)\n     {\n-      register int i;\n+      int i;\n \n       for (i = XVECLEN (pattern, 0) - 1; i >= 0; i--)\n \t{\n@@ -1627,7 +1627,7 @@ find_reg_note (insn, kind, datum)\n      enum reg_note kind;\n      rtx datum;\n {\n-  register rtx link;\n+  rtx link;\n \n   /* Ignore anything that is not an INSN, JUMP_INSN or CALL_INSN.  */\n   if (! INSN_P (insn))\n@@ -1651,7 +1651,7 @@ find_regno_note (insn, kind, regno)\n      enum reg_note kind;\n      unsigned int regno;\n {\n-  register rtx link;\n+  rtx link;\n \n   /* Ignore anything that is not an INSN, JUMP_INSN or CALL_INSN.  */\n   if (! INSN_P (insn))\n@@ -1708,7 +1708,7 @@ find_reg_fusage (insn, code, datum)\n \n   if (GET_CODE (datum) != REG)\n     {\n-      register rtx link;\n+      rtx link;\n \n       for (link = CALL_INSN_FUNCTION_USAGE (insn);\n            link;\n@@ -1748,7 +1748,7 @@ find_regno_fusage (insn, code, regno)\n      enum rtx_code code;\n      unsigned int regno;\n {\n-  register rtx link;\n+  rtx link;\n \n   /* CALL_INSN_FUNCTION_USAGE information cannot contain references\n      to pseudo registers, so don't bother checking.  */\n@@ -1776,10 +1776,10 @@ find_regno_fusage (insn, code, regno)\n \n void\n remove_note (insn, note)\n-     register rtx insn;\n-     register rtx note;\n+     rtx insn;\n+     rtx note;\n {\n-  register rtx link;\n+  rtx link;\n \n   if (note == NULL_RTX)\n     return;\n@@ -1840,7 +1840,7 @@ int\n volatile_insn_p (x)\n      rtx x;\n {\n-  register RTX_CODE code;\n+  RTX_CODE code;\n \n   code = GET_CODE (x);\n   switch (code)\n@@ -1877,8 +1877,8 @@ volatile_insn_p (x)\n   /* Recursively scan the operands of this expression.  */\n \n   {\n-    register const char *fmt = GET_RTX_FORMAT (code);\n-    register int i;\n+    const char *fmt = GET_RTX_FORMAT (code);\n+    int i;\n     \n     for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n       {\n@@ -1889,7 +1889,7 @@ volatile_insn_p (x)\n \t  }\n \telse if (fmt[i] == 'E')\n \t  {\n-\t    register int j;\n+\t    int j;\n \t    for (j = 0; j < XVECLEN (x, i); j++)\n \t      if (volatile_insn_p (XVECEXP (x, i, j)))\n \t\treturn 1;\n@@ -1906,7 +1906,7 @@ int\n volatile_refs_p (x)\n      rtx x;\n {\n-  register RTX_CODE code;\n+  RTX_CODE code;\n \n   code = GET_CODE (x);\n   switch (code)\n@@ -1943,8 +1943,8 @@ volatile_refs_p (x)\n   /* Recursively scan the operands of this expression.  */\n \n   {\n-    register const char *fmt = GET_RTX_FORMAT (code);\n-    register int i;\n+    const char *fmt = GET_RTX_FORMAT (code);\n+    int i;\n     \n     for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n       {\n@@ -1955,7 +1955,7 @@ volatile_refs_p (x)\n \t  }\n \telse if (fmt[i] == 'E')\n \t  {\n-\t    register int j;\n+\t    int j;\n \t    for (j = 0; j < XVECLEN (x, i); j++)\n \t      if (volatile_refs_p (XVECEXP (x, i, j)))\n \t\treturn 1;\n@@ -1972,7 +1972,7 @@ int\n side_effects_p (x)\n      rtx x;\n {\n-  register RTX_CODE code;\n+  RTX_CODE code;\n \n   code = GET_CODE (x);\n   switch (code)\n@@ -2020,8 +2020,8 @@ side_effects_p (x)\n   /* Recursively scan the operands of this expression.  */\n \n   {\n-    register const char *fmt = GET_RTX_FORMAT (code);\n-    register int i;\n+    const char *fmt = GET_RTX_FORMAT (code);\n+    int i;\n     \n     for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n       {\n@@ -2032,7 +2032,7 @@ side_effects_p (x)\n \t  }\n \telse if (fmt[i] == 'E')\n \t  {\n-\t    register int j;\n+\t    int j;\n \t    for (j = 0; j < XVECLEN (x, i); j++)\n \t      if (side_effects_p (XVECEXP (x, i, j)))\n \t\treturn 1;\n@@ -2140,7 +2140,7 @@ may_trap_p (x)\n \t}\n       else if (fmt[i] == 'E')\n \t{\n-\t  register int j;\n+\t  int j;\n \t  for (j = 0; j < XVECLEN (x, i); j++)\n \t    if (may_trap_p (XVECEXP (x, i, j)))\n \t      return 1;\n@@ -2156,9 +2156,9 @@ int\n inequality_comparisons_p (x)\n      rtx x;\n {\n-  register const char *fmt;\n-  register int len, i;\n-  register enum rtx_code code = GET_CODE (x);\n+  const char *fmt;\n+  int len, i;\n+  enum rtx_code code = GET_CODE (x);\n \n   switch (code)\n     {\n@@ -2199,7 +2199,7 @@ inequality_comparisons_p (x)\n \t}\n       else if (fmt[i] == 'E')\n \t{\n-\t  register int j;\n+\t  int j;\n \t  for (j = XVECLEN (x, i) - 1; j >= 0; j--)\n \t    if (inequality_comparisons_p (XVECEXP (x, i, j)))\n \t      return 1;\n@@ -2219,8 +2219,8 @@ rtx\n replace_rtx (x, from, to)\n      rtx x, from, to;\n {\n-  register int i, j;\n-  register const char *fmt;\n+  int i, j;\n+  const char *fmt;\n \n   /* The following prevents loops occurrence when we change MEM in\n      CONST_DOUBLE onto the same CONST_DOUBLE.  */\n@@ -2266,9 +2266,9 @@ replace_regs (x, reg_map, nregs, replace_dest)\n      unsigned int nregs;\n      int replace_dest;\n {\n-  register enum rtx_code code;\n-  register int i;\n-  register const char *fmt;\n+  enum rtx_code code;\n+  int i;\n+  const char *fmt;\n \n   if (x == 0)\n     return x;\n@@ -2341,7 +2341,7 @@ replace_regs (x, reg_map, nregs, replace_dest)\n \tXEXP (x, i) = replace_regs (XEXP (x, i), reg_map, nregs, replace_dest);\n       else if (fmt[i] == 'E')\n \t{\n-\t  register int j;\n+\t  int j;\n \t  for (j = 0; j < XVECLEN (x, i); j++)\n \t    XVECEXP (x, i, j) = replace_regs (XVECEXP (x, i, j), reg_map,\n \t\t\t\t\t      nregs, replace_dest);\n@@ -2527,7 +2527,7 @@ regno_use_in (regno, x)\n      unsigned int regno;\n      rtx x;\n {\n-  register const char *fmt;\n+  const char *fmt;\n   int i, j;\n   rtx tem;\n "}, {"sha": "e9a9a4b5d253d80eff91d80facbfd1a464dd38af", "filename": "gcc/scan.c", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Fscan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Fscan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fscan.c?ref=b36948478c22c58018d0a888ee8ca393dea60dc9", "patch": "@@ -45,8 +45,9 @@ sstring_append (dst, src)\n      sstring *dst;\n      sstring *src;\n {\n-  register char *d, *s;\n-  register int count = SSTRING_LENGTH(src);\n+  char *d, *s;\n+  int count = SSTRING_LENGTH(src);\n+\n   MAKE_SSTRING_SPACE(dst, count + 1);\n   d = dst->ptr;\n   s = src->base;\n@@ -57,8 +58,8 @@ sstring_append (dst, src)\n \n int\n scan_ident (fp, s, c)\n-     register FILE *fp;\n-     register sstring *s;\n+     FILE *fp;\n+     sstring *s;\n      int c;\n {\n   s->ptr = s->base;\n@@ -79,11 +80,12 @@ scan_ident (fp, s, c)\n \n int\n scan_string (fp, s, init)\n-     register FILE *fp;\n-     register sstring *s;\n+     FILE *fp;\n+     sstring *s;\n      int init;\n {\n   int c;\n+\n   for (;;)\n     {\n       c = getc (fp);\n@@ -113,7 +115,7 @@ scan_string (fp, s, init)\n \n int\n skip_spaces (fp, c)\n-     register FILE *fp;\n+     FILE *fp;\n      int c;\n {\n   for (;;)\n@@ -156,6 +158,7 @@ read_upto (fp, str, delim)\n      int delim;\n {\n   int ch;\n+\n   for (;;)\n     {\n       ch = getc (fp);\n@@ -170,10 +173,11 @@ read_upto (fp, str, delim)\n \n int\n get_token (fp, s)\n-     register FILE *fp;\n-     register sstring *s;\n+     FILE *fp;\n+     sstring *s;\n {\n   int c;\n+\n   s->ptr = s->base;\n  retry:\n   c = ' ';"}, {"sha": "9d53200d75a854927e7f7f42930ed56f60df85a4", "filename": "gcc/sched-deps.c", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Fsched-deps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Fsched-deps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-deps.c?ref=b36948478c22c58018d0a888ee8ca393dea60dc9", "patch": "@@ -488,7 +488,7 @@ add_insn_mem_dependence (deps, insn_list, mem_list, insn, mem)\n      struct deps *deps;\n      rtx *insn_list, *mem_list, insn, mem;\n {\n-  register rtx link;\n+  rtx link;\n \n   link = alloc_INSN_LIST (insn, *insn_list);\n   *insn_list = link;\n@@ -564,16 +564,16 @@ sched_analyze_1 (deps, x, insn)\n      rtx x;\n      rtx insn;\n {\n-  register int regno;\n-  register rtx dest = XEXP (x, 0);\n+  int regno;\n+  rtx dest = XEXP (x, 0);\n   enum rtx_code code = GET_CODE (x);\n \n   if (dest == 0)\n     return;\n \n   if (GET_CODE (dest) == PARALLEL)\n     {\n-      register int i;\n+      int i;\n \n       for (i = XVECLEN (dest, 0) - 1; i >= 0; i--)\n \tif (XEXP (XVECEXP (dest, 0, i), 0) != 0)\n@@ -601,7 +601,7 @@ sched_analyze_1 (deps, x, insn)\n \n   if (GET_CODE (dest) == REG)\n     {\n-      register int i;\n+      int i;\n \n       regno = REGNO (dest);\n \n@@ -759,10 +759,10 @@ sched_analyze_2 (deps, x, insn)\n      rtx x;\n      rtx insn;\n {\n-  register int i;\n-  register int j;\n-  register enum rtx_code code;\n-  register const char *fmt;\n+  int i;\n+  int j;\n+  enum rtx_code code;\n+  const char *fmt;\n \n   if (x == 0)\n     return;\n@@ -1007,7 +1007,7 @@ sched_analyze_insn (deps, x, insn, loop_notes)\n      rtx x, insn;\n      rtx loop_notes;\n {\n-  register RTX_CODE code = GET_CODE (x);\n+  RTX_CODE code = GET_CODE (x);\n   int schedule_barrier_found = 0;\n   rtx link;\n   int i;\n@@ -1025,7 +1025,7 @@ sched_analyze_insn (deps, x, insn, loop_notes)\n     sched_analyze_1 (deps, x, insn);\n   else if (code == PARALLEL)\n     {\n-      register int i;\n+      int i;\n       for (i = XVECLEN (x, 0) - 1; i >= 0; i--)\n \t{\n \t  rtx sub = XVECEXP (x, 0, i);\n@@ -1264,8 +1264,8 @@ sched_analyze (deps, head, tail)\n      struct deps *deps;\n      rtx head, tail;\n {\n-  register rtx insn;\n-  register rtx u;\n+  rtx insn;\n+  rtx u;\n   rtx loop_notes = 0;\n \n   if (current_sched_info->use_cselib)\n@@ -1298,7 +1298,7 @@ sched_analyze (deps, head, tail)\n       else if (GET_CODE (insn) == CALL_INSN)\n \t{\n \t  rtx x;\n-\t  register int i;\n+\t  int i;\n \n \t  /* Clear out stale SCHED_GROUP_P.  */\n \t  SCHED_GROUP_P (insn) = 0;"}, {"sha": "168ce8de3fd77d82cbc4b54d6c4f7b45fed3a100", "filename": "gcc/sched-rgn.c", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Fsched-rgn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Fsched-rgn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-rgn.c?ref=b36948478c22c58018d0a888ee8ca393dea60dc9", "patch": "@@ -486,29 +486,29 @@ new_edge (source, target)\n \n /* Compute bitwise union of two bitsets.  */\n #define BITSET_UNION(set1, set2, len)                                \\\n-do { register bitset tp = set1, sp = set2;                           \\\n-     register int i;                                                 \\\n+do { bitset tp = set1, sp = set2;                                    \\\n+     int i;                                                          \\\n      for (i = 0; i < len; i++)                                       \\\n        *(tp++) |= *(sp++); } while (0)\n \n /* Compute bitwise intersection of two bitsets.  */\n #define BITSET_INTER(set1, set2, len)                                \\\n-do { register bitset tp = set1, sp = set2;                           \\\n-     register int i;                                                 \\\n+do { bitset tp = set1, sp = set2;                                    \\\n+     int i;                                                          \\\n      for (i = 0; i < len; i++)                                       \\\n        *(tp++) &= *(sp++); } while (0)\n \n /* Compute bitwise difference of two bitsets.  */\n #define BITSET_DIFFER(set1, set2, len)                               \\\n-do { register bitset tp = set1, sp = set2;                           \\\n-     register int i;                                                 \\\n+do { bitset tp = set1, sp = set2;                                    \\\n+     int i;                                                          \\\n      for (i = 0; i < len; i++)                                       \\\n        *(tp++) &= ~*(sp++); } while (0)\n \n /* Inverts every bit of bitset 'set'.  */\n #define BITSET_INVERT(set, len)                                      \\\n-do { register bitset tmpset = set;                                   \\\n-     register int i;                                                 \\\n+do { bitset tmpset = set;                                            \\\n+     int i;                                                          \\\n      for (i = 0; i < len; i++, tmpset++)                             \\\n        *tmpset = ~*tmpset; } while (0)\n \n@@ -1229,7 +1229,7 @@ static void\n compute_trg_info (trg)\n      int trg;\n {\n-  register candidate *sp;\n+  candidate *sp;\n   edgelst el;\n   int check_block, update_idx;\n   int i, j, k, fst_edge, nxt_edge;\n@@ -1384,9 +1384,9 @@ check_live_1 (src, x)\n      int src;\n      rtx x;\n {\n-  register int i;\n-  register int regno;\n-  register rtx reg = SET_DEST (x);\n+  int i;\n+  int regno;\n+  rtx reg = SET_DEST (x);\n \n   if (reg == 0)\n     return 1;\n@@ -1398,7 +1398,7 @@ check_live_1 (src, x)\n \n   if (GET_CODE (reg) == PARALLEL)\n     {\n-      register int i;\n+      int i;\n \n       for (i = XVECLEN (reg, 0) - 1; i >= 0; i--)\n \tif (XEXP (XVECEXP (reg, 0, i), 0) != 0)\n@@ -1464,9 +1464,9 @@ update_live_1 (src, x)\n      int src;\n      rtx x;\n {\n-  register int i;\n-  register int regno;\n-  register rtx reg = SET_DEST (x);\n+  int i;\n+  int regno;\n+  rtx reg = SET_DEST (x);\n \n   if (reg == 0)\n     return;\n@@ -1478,7 +1478,7 @@ update_live_1 (src, x)\n \n   if (GET_CODE (reg) == PARALLEL)\n     {\n-      register int i;\n+      int i;\n \n       for (i = XVECLEN (reg, 0) - 1; i >= 0; i--)\n \tif (XEXP (XVECEXP (reg, 0, i), 0) != 0)\n@@ -1770,7 +1770,7 @@ is_pfree (load_insn, bb_src, bb_trg)\n      int bb_src, bb_trg;\n {\n   rtx back_link;\n-  register candidate *candp = candidate_table + bb_src;\n+  candidate *candp = candidate_table + bb_src;\n \n   if (candp->split_bbs.nr_members != 1)\n     /* Must have exactly one escape block.  */"}, {"sha": "a1180e2ec2490043a3f02003f7cad293759aed7f", "filename": "gcc/sdbout.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Fsdbout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Fsdbout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsdbout.c?ref=b36948478c22c58018d0a888ee8ca393dea60dc9", "patch": "@@ -429,7 +429,7 @@ static int\n template_name_p (name)\n      tree name;\n {\n-  register const char *ptr = IDENTIFIER_POINTER (name);\n+  const char *ptr = IDENTIFIER_POINTER (name);\n   while (*ptr && *ptr != '<')\n     ptr++;\n \n@@ -661,7 +661,7 @@ static int do_block = 0;\n \n static void\n sdbout_block (block)\n-     register tree block;\n+     tree block;\n {\n   while (block)\n     {\n@@ -999,7 +999,7 @@ sdbout_queue_anonymous_type (type)\n static void\n sdbout_dequeue_anonymous_types ()\n {\n-  register tree types, link;\n+  tree types, link;\n \n   while (anonymous_types)\n     {\n@@ -1008,7 +1008,7 @@ sdbout_dequeue_anonymous_types ()\n \n       for (link = types; link; link = TREE_CHAIN (link))\n \t{\n-\t  register tree type = TREE_VALUE (link);\n+\t  tree type = TREE_VALUE (link);\n \n \t  if (type && ! TREE_ASM_WRITTEN (type))\n \t    sdbout_one_type (type);\n@@ -1023,9 +1023,9 @@ sdbout_dequeue_anonymous_types ()\n \n void\n sdbout_types (types)\n-     register tree types;\n+     tree types;\n {\n-  register tree link;\n+  tree link;\n \n   for (link = types; link; link = TREE_CHAIN (link))\n     sdbout_one_type (link);\n@@ -1697,7 +1697,7 @@ sdbout_end_epilogue ()\n \n static void\n sdbout_label (insn)\n-     register rtx insn;\n+     rtx insn;\n {\n   PUT_SDB_DEF (LABEL_NAME (insn));\n   PUT_SDB_VAL (insn);"}, {"sha": "2b7e3a2ac7a5f2c8554be76cb12049a2ae5dd506", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=b36948478c22c58018d0a888ee8ca393dea60dc9", "patch": "@@ -488,8 +488,8 @@ simplify_unary_operation (code, mode, op, op_mode)\n   if (GET_CODE (trueop) == CONST_INT\n       && width <= HOST_BITS_PER_WIDE_INT && width > 0)\n     {\n-      register HOST_WIDE_INT arg0 = INTVAL (trueop);\n-      register HOST_WIDE_INT val;\n+      HOST_WIDE_INT arg0 = INTVAL (trueop);\n+      HOST_WIDE_INT val;\n \n       switch (code)\n \t{\n@@ -859,7 +859,7 @@ simplify_binary_operation (code, mode, op0, op1)\n      enum machine_mode mode;\n      rtx op0, op1;\n {\n-  register HOST_WIDE_INT arg0, arg1, arg0s, arg1s;\n+  HOST_WIDE_INT arg0, arg1, arg0s, arg1s;\n   HOST_WIDE_INT val;\n   unsigned int width = GET_MODE_BITSIZE (mode);\n   rtx tem;"}, {"sha": "b7ced6a8eca0c0098f0eefb6334510a51482eace", "filename": "gcc/stmt.c", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=b36948478c22c58018d0a888ee8ca393dea60dc9", "patch": "@@ -1040,7 +1040,7 @@ expand_fixup (tree_label, rtl_label, last_insn)\n \t as a placeholder.  */\n \n       {\n-        register rtx original_before_jump\n+        rtx original_before_jump\n           = last_insn ? last_insn : get_last_insn ();\n \trtx start;\n \trtx end;\n@@ -1118,7 +1118,7 @@ fixup_gotos (thisblock, stack_level, cleanup_list, first_insn, dont_jump_in)\n      rtx first_insn;\n      int dont_jump_in;\n {\n-  register struct goto_fixup *f, *prev;\n+  struct goto_fixup *f, *prev;\n \n   /* F is the fixup we are considering; PREV is the previous one.  */\n   /* We run this loop in two passes so that cleanups of exited blocks\n@@ -1138,7 +1138,7 @@ fixup_gotos (thisblock, stack_level, cleanup_list, first_insn, dont_jump_in)\n \t If so, we can finalize it.  */\n       else if (PREV_INSN (f->target_rtl) != 0)\n \t{\n-\t  register rtx cleanup_insns;\n+\t  rtx cleanup_insns;\n \n \t  /* If this fixup jumped into this contour from before the beginning\n \t     of this contour, report an error.   This code used to use\n@@ -1485,7 +1485,7 @@ expand_asm_operands (string, outputs, inputs, clobbers, vol, filename, line)\n   int ninout = 0;\n   int nclobbers;\n   tree tail;\n-  register int i;\n+  int i;\n   /* Vector of RTX's of evaluated output operands.  */\n   rtx *output_rtx = (rtx *) alloca (noutputs * sizeof (rtx));\n   int *inout_opnum = (int *) alloca (noutputs * sizeof (int));\n@@ -2333,7 +2333,7 @@ struct nesting *\n expand_start_loop (exit_flag)\n      int exit_flag;\n {\n-  register struct nesting *thisloop = ALLOC_NESTING ();\n+  struct nesting *thisloop = ALLOC_NESTING ();\n \n   /* Make an entry on loop_stack for the loop we are entering.  */\n \n@@ -2374,7 +2374,7 @@ expand_start_loop_continue_elsewhere (exit_flag)\n struct nesting *\n expand_start_null_loop ()\n {\n-  register struct nesting *thisloop = ALLOC_NESTING ();\n+  struct nesting *thisloop = ALLOC_NESTING ();\n \n   /* Make an entry on loop_stack for the loop we are entering.  */\n \n@@ -2655,8 +2655,8 @@ expand_end_loop ()\n \t  /* We found one.  Move everything from there up\n \t     to the end of the loop, and add a jump into the loop\n \t     to jump to there.  */\n-\t  register rtx newstart_label = gen_label_rtx ();\n-\t  register rtx start_move = start_label;\n+\t  rtx newstart_label = gen_label_rtx ();\n+\t  rtx start_move = start_label;\n \t  rtx next_insn;\n \n \t  /* If the start label is preceded by a NOTE_INSN_LOOP_CONT note,\n@@ -2945,7 +2945,7 @@ expand_return (retval)\n      computation of the return value.  */\n   rtx last_insn = 0;\n   rtx result_rtl;\n-  register rtx val = 0;\n+  rtx val = 0;\n   tree retval_rhs;\n \n   /* If function wants no value, give it none.  */\n@@ -3197,9 +3197,9 @@ static int\n tail_recursion_args (actuals, formals)\n      tree actuals, formals;\n {\n-  register tree a = actuals, f = formals;\n-  register int i;\n-  register rtx *argvec;\n+  tree a = actuals, f = formals;\n+  int i;\n+  rtx *argvec;\n \n   /* Check that number and types of actuals are compatible\n      with the formals.  This is not always true in valid C code.\n@@ -3232,7 +3232,7 @@ tail_recursion_args (actuals, formals)\n   for (a = actuals, i = 0; a; a = TREE_CHAIN (a), i++)\n     {\n       int copy = 0;\n-      register int j;\n+      int j;\n       for (f = formals, j = 0; j < i; f = TREE_CHAIN (f), j++)\n \tif (reg_mentioned_p (DECL_RTL (f), argvec[i]))\n \t  {\n@@ -3387,7 +3387,7 @@ expand_end_target_temps ()\n \n int\n is_body_block (stmt)\n-     register tree stmt;\n+     tree stmt;\n {\n   if (TREE_CODE (stmt) == BLOCK)\n     {\n@@ -3619,7 +3619,7 @@ expand_end_bindings (vars, mark_ends, dont_jump_in)\n      int mark_ends;\n      int dont_jump_in;\n {\n-  register struct nesting *thisblock = block_stack;\n+  struct nesting *thisblock = block_stack;\n \n   /* If any of the variables in this scope were not used, warn the\n      user.  */\n@@ -3764,7 +3764,7 @@ save_stack_pointer ()\n \n void\n expand_decl (decl)\n-     register tree decl;\n+     tree decl;\n {\n   struct nesting *thisblock;\n   tree type;\n@@ -4311,7 +4311,7 @@ expand_start_case (exit_flag, expr, type, printname)\n      tree type;\n      const char *printname;\n {\n-  register struct nesting *thiscase = ALLOC_NESTING ();\n+  struct nesting *thiscase = ALLOC_NESTING ();\n \n   /* Make an entry on case_stack for the case we are entering.  */\n \n@@ -4348,7 +4348,7 @@ expand_start_case (exit_flag, expr, type, printname)\n void\n expand_start_case_dummy ()\n {\n-  register struct nesting *thiscase = ALLOC_NESTING ();\n+  struct nesting *thiscase = ALLOC_NESTING ();\n \n   /* Make an entry on case_stack for the dummy.  */\n \n@@ -4439,9 +4439,9 @@ check_seenlabel ()\n \n int\n pushcase (value, converter, label, duplicate)\n-     register tree value;\n+     tree value;\n      tree (*converter) PARAMS ((tree, tree));\n-     register tree label;\n+     tree label;\n      tree *duplicate;\n {\n   tree index_type;\n@@ -4489,9 +4489,9 @@ pushcase (value, converter, label, duplicate)\n \n int\n pushcase_range (value1, value2, converter, label, duplicate)\n-     register tree value1, value2;\n+     tree value1, value2;\n      tree (*converter) PARAMS ((tree, tree));\n-     register tree label;\n+     tree label;\n      tree *duplicate;\n {\n   tree index_type;\n@@ -4882,7 +4882,7 @@ mark_seen_cases (type, cases_seen, count, sparseness)\n   tree next_node_to_try = NULL_TREE;\n   HOST_WIDE_INT next_node_offset = 0;\n \n-  register struct case_node *n, *root = case_stack->data.case_stmt.case_list;\n+  struct case_node *n, *root = case_stack->data.case_stmt.case_list;\n   tree val = make_node (INTEGER_CST);\n \n   TREE_TYPE (val) = type;\n@@ -5011,8 +5011,8 @@ void\n check_for_full_enumeration_handling (type)\n      tree type;\n {\n-  register struct case_node *n;\n-  register tree chain;\n+  struct case_node *n;\n+  tree chain;\n \n   /* True iff the selector type is a numbered set mode.  */\n   int sparseness = 0;\n@@ -5138,15 +5138,15 @@ expand_end_case (orig_index)\n {\n   tree minval = NULL_TREE, maxval = NULL_TREE, range = NULL_TREE, orig_minval;\n   rtx default_label = 0;\n-  register struct case_node *n;\n+  struct case_node *n;\n   unsigned int count;\n   rtx index;\n   rtx table_label;\n   int ncases;\n   rtx *labelvec;\n-  register int i;\n+  int i;\n   rtx before_case, end;\n-  register struct nesting *thiscase = case_stack;\n+  struct nesting *thiscase = case_stack;\n   tree index_expr, index_type;\n   int unsignedp;\n \n@@ -5366,7 +5366,7 @@ expand_end_case (orig_index)\n \n \t  for (n = thiscase->data.case_stmt.case_list; n; n = n->right)\n \t    {\n-\t      register HOST_WIDE_INT i\n+\t      HOST_WIDE_INT i\n \t\t= TREE_INT_CST_LOW (n->low) - TREE_INT_CST_LOW (orig_minval);\n \n \t      while (1)\n@@ -5614,15 +5614,15 @@ balance_case_nodes (head, parent)\n      case_node_ptr *head;\n      case_node_ptr parent;\n {\n-  register case_node_ptr np;\n+  case_node_ptr np;\n \n   np = *head;\n   if (np)\n     {\n       int cost = 0;\n       int i = 0;\n       int ranges = 0;\n-      register case_node_ptr *npp;\n+      case_node_ptr *npp;\n       case_node_ptr left;\n \n       /* Count the number of entries on branch.  Also count the ranges.  */"}, {"sha": "9de3233821af1abf41af30afd94cec0540ecdb1f", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=b36948478c22c58018d0a888ee8ca393dea60dc9", "patch": "@@ -198,7 +198,7 @@ mode_for_size (size, class, limit)\n      enum mode_class class;\n      int limit;\n {\n-  register enum machine_mode mode;\n+  enum machine_mode mode;\n \n   if (limit && size > MAX_FIXED_MODE_SIZE)\n     return BLKmode;\n@@ -238,7 +238,7 @@ smallest_mode_for_size (size, class)\n      unsigned int size;\n      enum mode_class class;\n {\n-  register enum machine_mode mode;\n+  enum machine_mode mode;\n \n   /* Get the first mode which has at least this size, in the\n      specified class.  */\n@@ -327,8 +327,8 @@ layout_decl (decl, known_align)\n      tree decl;\n      unsigned int known_align;\n {\n-  register tree type = TREE_TYPE (decl);\n-  register enum tree_code code = TREE_CODE (decl);\n+  tree type = TREE_TYPE (decl);\n+  enum tree_code code = TREE_CODE (decl);\n \n   if (code == CONST_DECL)\n     return;\n@@ -396,7 +396,7 @@ layout_decl (decl, known_align)\n       && TREE_CODE (TYPE_SIZE (type)) == INTEGER_CST\n       && GET_MODE_CLASS (TYPE_MODE (type)) == MODE_INT)\n     {\n-      register enum machine_mode xmode\n+      enum machine_mode xmode\n \t= mode_for_size_tree (DECL_SIZE (decl), MODE_INT, 1);\n \n       if (xmode != BLKmode && known_align >= GET_MODE_ALIGNMENT (xmode))\n@@ -1390,8 +1390,8 @@ layout_type (type)\n \n     case ARRAY_TYPE:\n       {\n-\tregister tree index = TYPE_DOMAIN (type);\n-\tregister tree element = TREE_TYPE (type);\n+\ttree index = TYPE_DOMAIN (type);\n+\ttree element = TREE_TYPE (type);\n \n \tbuild_pointer_type (element);\n \n@@ -1596,7 +1596,7 @@ tree\n make_signed_type (precision)\n      int precision;\n {\n-  register tree type = make_node (INTEGER_TYPE);\n+  tree type = make_node (INTEGER_TYPE);\n \n   TYPE_PRECISION (type) = precision;\n \n@@ -1610,7 +1610,7 @@ tree\n make_unsigned_type (precision)\n      int precision;\n {\n-  register tree type = make_node (INTEGER_TYPE);\n+  tree type = make_node (INTEGER_TYPE);\n \n   TYPE_PRECISION (type) = precision;\n \n@@ -1741,7 +1741,7 @@ void\n fixup_signed_type (type)\n      tree type;\n {\n-  register int precision = TYPE_PRECISION (type);\n+  int precision = TYPE_PRECISION (type);\n \n   TYPE_MIN_VALUE (type)\n     = build_int_2 ((precision - HOST_BITS_PER_WIDE_INT > 0\n@@ -1773,7 +1773,7 @@ void\n fixup_unsigned_type (type)\n      tree type;\n {\n-  register int precision = TYPE_PRECISION (type);\n+  int precision = TYPE_PRECISION (type);\n \n   TYPE_MIN_VALUE (type) = build_int_2 (0, 0);\n   TYPE_MAX_VALUE (type)"}, {"sha": "e940aa6a7acd9ca63d647d3d384e63cde61cde66", "filename": "gcc/toplev.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=b36948478c22c58018d0a888ee8ca393dea60dc9", "patch": "@@ -1638,9 +1638,9 @@ botch (s)\n \n int\n exact_log2_wide (x)\n-     register unsigned HOST_WIDE_INT x;\n+     unsigned HOST_WIDE_INT x;\n {\n-  register int log = 0;\n+  int log = 0;\n   /* Test for 0 or a power of 2.  */\n   if (x == 0 || x != (x & -x))\n     return -1;\n@@ -1656,9 +1656,9 @@ exact_log2_wide (x)\n \n int\n floor_log2_wide (x)\n-     register unsigned HOST_WIDE_INT x;\n+     unsigned HOST_WIDE_INT x;\n {\n-  register int log = -1;\n+  int log = -1;\n   while (x != 0)\n     log++,\n     x >>= 1;\n@@ -2613,7 +2613,7 @@ void\n rest_of_compilation (decl)\n      tree decl;\n {\n-  register rtx insns;\n+  rtx insns;\n   int tem;\n   int failure = 0;\n   int rebuild_label_notes_after_reload;\n@@ -4612,7 +4612,7 @@ toplev_main (argc, argv)\n      int argc;\n      char **argv;\n {\n-  register int i;\n+  int i;\n   char *p;\n \n   /* save in case md file wants to emit args as a comment.  */\n@@ -4986,7 +4986,7 @@ static void\n set_target_switch (name)\n      const char *name;\n {\n-  register size_t j;\n+  size_t j;\n   int valid_target_option = 0;\n \n   for (j = 0; j < ARRAY_SIZE (target_switches); j++)"}, {"sha": "1f8eb2858fcec903641caaf5e7dcaeff0e249213", "filename": "gcc/tradcif.y", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Ftradcif.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Ftradcif.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftradcif.y?ref=b36948478c22c58018d0a888ee8ca393dea60dc9", "patch": "@@ -218,11 +218,11 @@ static int\n parse_number (olen)\n      int olen;\n {\n-  register const char *p = lexptr;\n-  register long n = 0;\n-  register int c;\n-  register int base = 10;\n-  register int len = olen;\n+  const char *p = lexptr;\n+  long n = 0;\n+  int c;\n+  int base = 10;\n+  int len = olen;\n \n   for (c = 0; c < len; c++)\n     if (p[c] == '.') {\n@@ -310,10 +310,10 @@ static const struct token tokentab2[] = {\n static int\n yylex ()\n {\n-  register int c;\n-  register int namelen;\n-  register const char *tokstart;\n-  register const struct token *toktab;\n+  int c;\n+  int namelen;\n+  const char *tokstart;\n+  const struct token *toktab;\n \n  retry:\n \n@@ -440,7 +440,7 @@ static int\n parse_escape (string_ptr)\n      const char **string_ptr;\n {\n-  register int c = *(*string_ptr)++;\n+  int c = *(*string_ptr)++;\n   switch (c)\n     {\n     case 'a':\n@@ -481,8 +481,8 @@ parse_escape (string_ptr)\n     case '6':\n     case '7':\n       {\n-\tregister int i = c - '0';\n-\tregister int count = 0;\n+\tint i = c - '0';\n+\tint count = 0;\n \twhile (++count < 3)\n \t  {\n \t    c = *(*string_ptr)++;\n@@ -503,7 +503,7 @@ parse_escape (string_ptr)\n       }\n     case 'x':\n       {\n-\tregister int i = 0;\n+\tint i = 0;\n \tfor (;;)\n \t  {\n \t    c = *(*string_ptr)++;"}, {"sha": "2c47a697b105c1aa36503ada66bfbcdbef592aa6", "filename": "gcc/tradcpp.c", "status": "modified", "additions": 79, "deletions": 79, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Ftradcpp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Ftradcpp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftradcpp.c?ref=b36948478c22c58018d0a888ee8ca393dea60dc9", "patch": "@@ -1075,8 +1075,8 @@ static void\n newline_fix (bp)\n      U_CHAR *bp;\n {\n-  register U_CHAR *p = bp;\n-  register int count = 0;\n+  U_CHAR *p = bp;\n+  int count = 0;\n \n   /* First count the backslash-newline pairs here.  */\n \n@@ -1110,8 +1110,8 @@ static void\n name_newline_fix (bp)\n      U_CHAR *bp;\n {\n-  register U_CHAR *p = bp;\n-  register int count = 0;\n+  U_CHAR *p = bp;\n+  int count = 0;\n \n   /* First count the backslash-newline pairs here.  */\n \n@@ -1181,25 +1181,25 @@ rescan (op, output_marks)\n      int output_marks;\n {\n   /* Character being scanned in main loop.  */\n-  register U_CHAR c;\n+  U_CHAR c;\n \n   /* Length of pending accumulated identifier.  */\n-  register int ident_length = 0;\n+  int ident_length = 0;\n \n   /* Hash code of pending accumulated identifier.  */\n-  register int hash = 0;\n+  int hash = 0;\n \n   /* Current input level (&instack[indepth]).  */\n   FILE_BUF *ip;\n \n   /* Pointer for scanning input.  */\n-  register U_CHAR *ibp;\n+  U_CHAR *ibp;\n \n   /* Pointer to end of input.  End of scan is controlled by LIMIT.  */\n-  register U_CHAR *limit;\n+  U_CHAR *limit;\n \n   /* Pointer for storing output.  */\n-  register U_CHAR *obp;\n+  U_CHAR *obp;\n \n   /* REDO_CHAR is nonzero if we are processing an identifier\n      after backing up over the terminating character.\n@@ -1629,7 +1629,7 @@ do { ip = &instack[indepth];\t\t\\\n randomchar:\n \n       if (ident_length > 0) {\n-\tregister HASHNODE *hp;\n+\tHASHNODE *hp;\n \n \t/* We have just seen an identifier end.  If it's a macro, expand it.\n \n@@ -1654,9 +1654,9 @@ do { ip = &instack[indepth];\t\t\\\n \t    /* obufp_before_macroname is used only in this block,\n                but it has to be global because of RECACHE.  */\n \t    int op_lineno_before_macroname;\n-\t    register int i = ident_length;\n-\t    register U_CHAR *p = hp->name;\n-\t    register U_CHAR *q = obp - i;\n+\t    int i = ident_length;\n+\t    U_CHAR *p = hp->name;\n+\t    U_CHAR *q = obp - i;\n \n \t    if (! redo_char)\n \t      q--;\n@@ -1821,7 +1821,7 @@ expand_to_temp_buffer (buf, limit, output_marks)\n      const U_CHAR *buf, *limit;\n      int output_marks;\n {\n-  register FILE_BUF *ip;\n+  FILE_BUF *ip;\n   FILE_BUF obuf;\n   int length = limit - buf;\n   U_CHAR *buf1;\n@@ -1834,8 +1834,8 @@ expand_to_temp_buffer (buf, limit, output_marks)\n \n   buf1 = (U_CHAR *) alloca (length + 1);\n   {\n-    register const U_CHAR *p1 = buf;\n-    register U_CHAR *p2 = buf1;\n+    const U_CHAR *p1 = buf;\n+    U_CHAR *p2 = buf1;\n \n     while (p1 != limit)\n       *p2++ = *p1++;\n@@ -1898,9 +1898,9 @@ static int\n handle_directive (ip, op)\n      FILE_BUF *ip, *op;\n {\n-  register U_CHAR *bp, *cp;\n-  register struct directive *kt;\n-  register int ident_length;\n+  U_CHAR *bp, *cp;\n+  struct directive *kt;\n+  int ident_length;\n   U_CHAR *resume_p;\n \n   /* Nonzero means we must copy the entire command\n@@ -1957,8 +1957,8 @@ handle_directive (ip, op)\n   for (kt = directive_table; kt->length > 0; kt++) {\n     if (kt->length == ident_length\n \t&& !strncmp (kt->name, (const char *)ident, ident_length)) {\n-      register U_CHAR *buf;\n-      register U_CHAR *limit = ip->buf + ip->length;\n+      U_CHAR *buf;\n+      U_CHAR *limit = ip->buf + ip->length;\n       int unterminated = 0;\n \n       /* Nonzero means do not delete comments within the directive.\n@@ -1972,7 +1972,7 @@ handle_directive (ip, op)\n \n       buf = bp = after_ident;\n       while (bp < limit) {\n-\tregister U_CHAR c = *bp++;\n+\tU_CHAR c = *bp++;\n \tswitch (c) {\n \tcase '\\\\':\n \t  if (bp < limit) {\n@@ -2036,7 +2036,7 @@ handle_directive (ip, op)\n \t A comment may come between.  */\n \n       if (copy_command) {\n-\tregister U_CHAR *xp = buf;\n+\tU_CHAR *xp = buf;\n \t/* Need to copy entire command into temp buffer before dispatching */\n \n \tcp = (U_CHAR *) alloca (bp - buf + 5); /* room for cmd plus\n@@ -2047,7 +2047,7 @@ handle_directive (ip, op)\n \t   and backslash-newlines (and whitespace surrounding the latter).  */\n \n \twhile (xp < bp) {\n-\t  register U_CHAR c = *xp++;\n+\t  U_CHAR c = *xp++;\n \t  *cp++ = c;\n \n \t  switch (c) {\n@@ -2087,7 +2087,7 @@ handle_directive (ip, op)\n \t  case '\\'':\n \t  case '\\\"':\n \t    {\n-\t      register const U_CHAR *bp1\n+\t      const U_CHAR *bp1\n \t\t= skip_quoted_string (xp - 1, limit, ip->lineno, 0, 0, 0);\n \t      while (xp != bp1)\n \t\t*cp++ = *xp++;\n@@ -2825,9 +2825,9 @@ static int\n compare_defs (d1, d2)\n      DEFINITION *d1, *d2;\n {\n-  register struct reflist *a1, *a2;\n-  register U_CHAR *p1 = d1->expansion;\n-  register U_CHAR *p2 = d2->expansion;\n+  struct reflist *a1, *a2;\n+  U_CHAR *p1 = d1->expansion;\n+  U_CHAR *p2 = d2->expansion;\n   int first = 1;\n \n   if (d1->nargs != d2->nargs)\n@@ -2871,8 +2871,8 @@ comp_def_part (first, beg1, len1, beg2, len2, last)\n      int len1, len2;\n      int last;\n {\n-  register const U_CHAR *end1 = beg1 + len1;\n-  register const U_CHAR *end2 = beg2 + len2;\n+  const U_CHAR *end1 = beg1 + len1;\n+  const U_CHAR *end2 = beg2 + len2;\n   if (first) {\n     while (beg1 != end1 && is_space (*beg1)) beg1++;\n     while (beg2 != end2 && is_space (*beg2)) beg2++;\n@@ -2920,7 +2920,7 @@ collect_expansion (buf, end, nargs, arglist)\n      struct arglist *arglist;\n {\n   DEFINITION *defn;\n-  register U_CHAR *p, *limit, *lastp, *exp_p;\n+  U_CHAR *p, *limit, *lastp, *exp_p;\n   struct reflist *endpat = NULL;\n   /* Pointer to first nonspace after last ## seen.  */\n   U_CHAR *concat = 0;\n@@ -2969,7 +2969,7 @@ collect_expansion (buf, end, nargs, arglist)\n   /* Process the main body of the definition.  */\n   while (p < limit) {\n     int skipped_arg = 0;\n-    register U_CHAR c = *p++;\n+    U_CHAR c = *p++;\n \n     *exp_p++ = c;\n \n@@ -3020,7 +3020,7 @@ collect_expansion (buf, end, nargs, arglist)\n       id_len = p - id_beg;\n \n       if (is_idstart (c)) {\n-\tregister struct arglist *arg;\n+\tstruct arglist *arg;\n \n \tfor (arg = arglist; arg != NULL; arg = arg->next) {\n \t  struct reflist *tpat;\n@@ -3046,7 +3046,7 @@ collect_expansion (buf, end, nargs, arglist)\n \t    tpat->argno = arg->argno;\n \t    tpat->nchars = exp_p - lastp;\n \t    {\n-\t      register U_CHAR *p1 = p;\n+\t      U_CHAR *p1 = p;\n \t      SKIP_WHITE_SPACE (p1);\n \t      if (p1 + 2 <= limit && p1[0] == '#' && p1[1] == '#')\n \t\ttpat->raw_after = 1;\n@@ -3060,7 +3060,7 @@ collect_expansion (buf, end, nargs, arglist)\n \n       /* If this was not a macro arg, copy it into the expansion.  */\n       if (! skipped_arg) {\n-\tregister U_CHAR *lim1 = p;\n+\tU_CHAR *lim1 = p;\n \tp = id_beg;\n \twhile (p != lim1)\n \t  *exp_p++ = *p++;\n@@ -3098,7 +3098,7 @@ do_line (buf, limit, op)\n      U_CHAR *buf, *limit;\n      FILE_BUF *op;\n {\n-  register U_CHAR *bp;\n+  U_CHAR *bp;\n   FILE_BUF *ip = &instack[indepth];\n   FILE_BUF tem;\n   int new_lineno;\n@@ -3677,8 +3677,8 @@ skip_if_group (ip, any)\n      FILE_BUF *ip;\n      int any;\n {\n-  register U_CHAR *bp = ip->bufp, *cp;\n-  register U_CHAR *endb = ip->buf + ip->length;\n+  U_CHAR *bp = ip->bufp, *cp;\n+  U_CHAR *endb = ip->buf + ip->length;\n   struct directive *kt;\n   IF_STACK_FRAME *save_if_stack = if_stack; /* don't pop past here */\n   U_CHAR *beg_of_line = bp;\n@@ -3897,11 +3897,11 @@ do_endif (buf, limit, op)\n  */\n static U_CHAR *\n skip_to_end_of_comment (ip, line_counter)\n-     register FILE_BUF *ip;\n+     FILE_BUF *ip;\n      int *line_counter;\t\t/* place to remember newlines, or NULL */\n {\n-  register U_CHAR *limit = ip->buf + ip->length;\n-  register U_CHAR *bp = ip->bufp;\n+  U_CHAR *limit = ip->buf + ip->length;\n+  U_CHAR *bp = ip->bufp;\n   FILE_BUF *op = &outbuf;\t/* JF */\n   int output = put_out_comments && !line_counter;\n \n@@ -3960,14 +3960,14 @@ skip_to_end_of_comment (ip, line_counter)\n  */\n static U_CHAR *\n skip_quoted_string (bp, limit, start_line, count_newlines, backslash_newlines_p, eofp)\n-     register const U_CHAR *bp;\n-     register const U_CHAR *limit;\n+     const U_CHAR *bp;\n+     const U_CHAR *limit;\n      int start_line;\n      int *count_newlines;\n      int *backslash_newlines_p;\n      int *eofp;\n {\n-  register U_CHAR c, match;\n+  U_CHAR c, match;\n \n   match = *bp++;\n   while (1) {\n@@ -4076,7 +4076,7 @@ macroexpand (hp, op)\n {\n   int nargs;\n   DEFINITION *defn = hp->value.defn;\n-  register U_CHAR *xbuf;\n+  U_CHAR *xbuf;\n   int xbuf_len;\n   int start_line = instack[indepth].lineno;\n \n@@ -4091,7 +4091,7 @@ macroexpand (hp, op)\n   nargs = defn->nargs;\n \n   if (nargs >= 0) {\n-    register int i;\n+    int i;\n     struct argdata *args;\n     const char *parse_error = 0;\n \n@@ -4123,8 +4123,8 @@ macroexpand (hp, op)\n \n     /* If we got one arg but it was just whitespace, call that 0 args.  */\n     if (i == 1) {\n-      register const U_CHAR *bp = args[0].raw;\n-      register const U_CHAR *lim = bp + args[0].raw_length;\n+      const U_CHAR *bp = args[0].raw;\n+      const U_CHAR *lim = bp + args[0].raw_length;\n       while (bp != lim && is_space (*bp)) bp++;\n       if (bp == lim)\n \ti = 0;\n@@ -4154,12 +4154,12 @@ macroexpand (hp, op)\n       xbuf = defn->expansion;\n       xbuf_len = defn->length;\n     } else {\n-      register U_CHAR *exp = defn->expansion;\n-      register int offset;\t/* offset in expansion,\n+      U_CHAR *exp = defn->expansion;\n+      int offset;\t/* offset in expansion,\n \t\t\t\t   copied a piece at a time */\n-      register int totlen;\t/* total amount of exp buffer filled so far */\n+      int totlen;\t/* total amount of exp buffer filled so far */\n \n-      register struct reflist *ap;\n+      struct reflist *ap;\n \n       /* Macro really takes args.  Compute the expansion of this call.  */\n \n@@ -4181,7 +4181,7 @@ macroexpand (hp, op)\n \t of where we are copying from.  */\n       offset = totlen = 0;\n       for (ap = defn->pattern; ap != NULL; ap = ap->next) {\n-\tregister struct argdata *arg = &args[ap->argno];\n+\tstruct argdata *arg = &args[ap->argno];\n \n \tfor (i = 0; i < ap->nchars; i++)\n \t  xbuf[totlen++] = exp[offset++];\n@@ -4312,7 +4312,7 @@ macroexpand (hp, op)\n   /* Now put the expansion on the input stack\n      so our caller will commence reading from it.  */\n   {\n-    register FILE_BUF *ip2;\n+    FILE_BUF *ip2;\n \n     ip2 = &instack[++indepth];\n \n@@ -4334,7 +4334,7 @@ macroexpand (hp, op)\n \n static const char *\n macarg (argptr)\n-     register struct argdata *argptr;\n+     struct argdata *argptr;\n {\n   FILE_BUF *ip = &instack[indepth];\n   int paren = 0;\n@@ -4420,8 +4420,8 @@ macarg (argptr)\n \n   if (argptr != 0) {\n     FILE_BUF obuf;\n-    register const U_CHAR *buf, *lim;\n-    register int totlen;\n+    const U_CHAR *buf, *lim;\n+    int totlen;\n \n     obuf = expand_to_temp_buffer (argptr->raw,\n \t\t\t\t  argptr->raw + argptr->raw_length,\n@@ -4436,7 +4436,7 @@ macarg (argptr)\n \n     totlen = 0;\n     while (buf != lim) {\n-      register U_CHAR c = *buf++;\n+      U_CHAR c = *buf++;\n       totlen++;\n       /* Internal sequences of whitespace are replaced by one space\n \t in most cases, but not always.  So count all the whitespace\n@@ -4466,10 +4466,10 @@ macarg (argptr)\n static U_CHAR *\n macarg1 (start, limit, depthptr, newlines, comments)\n      U_CHAR *start;\n-     register const U_CHAR *limit;\n+     const U_CHAR *limit;\n      int *depthptr, *newlines, *comments;\n {\n-  register U_CHAR *bp = start;\n+  U_CHAR *bp = start;\n \n   while (bp < limit) {\n     switch (*bp) {\n@@ -4557,10 +4557,10 @@ discard_comments (start, length, newlines)\n      int length;\n      int newlines;\n {\n-  register U_CHAR *ibp;\n-  register U_CHAR *obp;\n-  register const U_CHAR *limit;\n-  register int c;\n+  U_CHAR *ibp;\n+  U_CHAR *obp;\n+  const U_CHAR *limit;\n+  int c;\n \n   /* If we have newlines to duplicate, copy everything\n      that many characters up.  Then, in the second part,\n@@ -4797,10 +4797,10 @@ line_for_error (line)\n \n static void\n grow_outbuf (obuf, needed)\n-     register FILE_BUF *obuf;\n-     register int needed;\n+     FILE_BUF *obuf;\n+     int needed;\n {\n-  register U_CHAR *p;\n+  U_CHAR *p;\n   int minsize;\n \n   if (obuf->length - (obuf->bufp - obuf->buf) > needed)\n@@ -4844,9 +4844,9 @@ install (name, len, type, hash)\n      int hash;\n         /* watch out here if sizeof (U_CHAR *) != sizeof (int) */\n {\n-  register HASHNODE *hp;\n-  register int bucket;\n-  register const U_CHAR *p;\n+  HASHNODE *hp;\n+  int bucket;\n+  const U_CHAR *p;\n   U_CHAR *q;\n \n   if (len < 0) {\n@@ -4891,8 +4891,8 @@ lookup (name, len, hash)\n      int len;\n      int hash;\n {\n-  register const U_CHAR *bp;\n-  register HASHNODE *bucket;\n+  const U_CHAR *bp;\n+  HASHNODE *bucket;\n \n   if (len < 0) {\n     for (bp = name; is_idchar (*bp); bp++) ;\n@@ -4949,11 +4949,11 @@ delete_macro (hp)\n  */\n static int\n hashf (name, len, hashsize)\n-     register const U_CHAR *name;\n-     register int len;\n+     const U_CHAR *name;\n+     int len;\n      int hashsize;\n {\n-  register int r = 0;\n+  int r = 0;\n \n   while (len--)\n     r = HASHSTEP (r, *name++);\n@@ -4969,11 +4969,11 @@ dump_all_macros ()\n   int bucket;\n \n   for (bucket = 0; bucket < HASHSIZE; bucket++) {\n-    register HASHNODE *hp;\n+    HASHNODE *hp;\n \n     for (hp = hashtab[bucket]; hp; hp= hp->next) {\n       if (hp->type == T_MACRO) {\n-\tregister DEFINITION *defn = hp->value.defn;\n+\tDEFINITION *defn = hp->value.defn;\n \tstruct reflist *ap;\n \tint offset;\n \tint concat;\n@@ -5055,7 +5055,7 @@ dump_arg_n (defn, argnum)\n      DEFINITION *defn;\n      int argnum;\n {\n-  register const U_CHAR *p = defn->argnames;\n+  const U_CHAR *p = defn->argnames;\n   while (argnum + 1 < defn->nargs) {\n     p = (const U_CHAR *) strchr ((const char *)p, ' ') + 1;\n     argnum++;"}, {"sha": "a65bfb5e0b6012129fff36807c43f1f31bd8dd9e", "filename": "gcc/tree.c", "status": "modified", "additions": 73, "deletions": 73, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=b36948478c22c58018d0a888ee8ca393dea60dc9", "patch": "@@ -326,11 +326,11 @@ tree\n make_node (code)\n      enum tree_code code;\n {\n-  register tree t;\n-  register int type = TREE_CODE_CLASS (code);\n-  register size_t length;\n+  tree t;\n+  int type = TREE_CODE_CLASS (code);\n+  size_t length;\n #ifdef GATHER_STATISTICS\n-  register tree_node_kind kind;\n+  tree_node_kind kind;\n #endif\n   struct tree_common ttmp;\n   \n@@ -485,9 +485,9 @@ tree\n copy_node (node)\n      tree node;\n {\n-  register tree t;\n-  register enum tree_code code = TREE_CODE (node);\n-  register size_t length;\n+  tree t;\n+  enum tree_code code = TREE_CODE (node);\n+  size_t length;\n \n   length = tree_size (node);\n   t = ggc_alloc_tree (length);\n@@ -521,7 +521,7 @@ copy_list (list)\n      tree list;\n {\n   tree head;\n-  register tree prev, next;\n+  tree prev, next;\n \n   if (list == 0)\n     return 0;\n@@ -549,7 +549,7 @@ build_int_2_wide (low, hi)\n      unsigned HOST_WIDE_INT low;\n      HOST_WIDE_INT hi;\n {\n-  register tree t = make_node (INTEGER_CST);\n+  tree t = make_node (INTEGER_CST);\n \n   TREE_INT_CST_LOW (t) = low;\n   TREE_INT_CST_HIGH (t) = hi;\n@@ -713,7 +713,7 @@ build_string (len, str)\n      int len;\n      const char *str;\n {\n-  register tree s = make_node (STRING_CST);\n+  tree s = make_node (STRING_CST);\n \n   TREE_STRING_LENGTH (s) = len;\n   TREE_STRING_POINTER (s) = ggc_alloc_string (str, len);\n@@ -731,7 +731,7 @@ build_complex (type, real, imag)\n      tree type;\n      tree real, imag;\n {\n-  register tree t = make_node (COMPLEX_CST);\n+  tree t = make_node (COMPLEX_CST);\n \n   TREE_REALPART (t) = real;\n   TREE_IMAGPART (t) = imag;\n@@ -748,8 +748,8 @@ tree\n make_tree_vec (len)\n      int len;\n {\n-  register tree t;\n-  register int length = (len-1) * sizeof (tree) + sizeof (struct tree_vec);\n+  tree t;\n+  int length = (len-1) * sizeof (tree) + sizeof (struct tree_vec);\n \n #ifdef GATHER_STATISTICS\n   tree_node_counts[(int)vec_kind]++;\n@@ -808,8 +808,8 @@ int\n integer_all_onesp (expr)\n      tree expr;\n {\n-  register int prec;\n-  register int uns;\n+  int prec;\n+  int uns;\n \n   STRIP_NOPS (expr);\n \n@@ -1148,8 +1148,8 @@ int\n list_length (t)\n      tree t;\n {\n-  register tree tail;\n-  register int len = 0;\n+  tree tail;\n+  int len = 0;\n \n   for (tail = t; tail; tail = TREE_CHAIN (tail))\n     len++;\n@@ -1184,9 +1184,9 @@ chainon (op1, op2)\n \n   if (op1)\n     {\n-      register tree t1;\n+      tree t1;\n #ifdef ENABLE_TREE_CHECKING\n-      register tree t2;\n+      tree t2;\n #endif\n \n       for (t1 = op1; TREE_CHAIN (t1); t1 = TREE_CHAIN (t1))\n@@ -1207,9 +1207,9 @@ chainon (op1, op2)\n \n tree\n tree_last (chain)\n-     register tree chain;\n+     tree chain;\n {\n-  register tree next;\n+  tree next;\n   if (chain)\n     while ((next = TREE_CHAIN (chain)))\n       chain = next;\n@@ -1223,7 +1223,7 @@ tree\n nreverse (t)\n      tree t;\n {\n-  register tree prev = 0, decl, next;\n+  tree prev = 0, decl, next;\n   for (decl = t; decl; decl = next)\n     {\n       next = TREE_CHAIN (decl);\n@@ -1265,7 +1265,7 @@ tree\n build_tree_list (parm, value)\n      tree parm, value;\n {\n-  register tree t = make_node (TREE_LIST);\n+  tree t = make_node (TREE_LIST);\n   TREE_PURPOSE (t) = parm;\n   TREE_VALUE (t) = value;\n   return t;\n@@ -1279,7 +1279,7 @@ tree\n tree_cons (purpose, value, chain)\n      tree purpose, value, chain;\n {\n-  register tree node;\n+  tree node;\n \n   node = ggc_alloc_tree (sizeof (struct tree_list));\n \n@@ -1548,7 +1548,7 @@ tree\n save_expr (expr)\n      tree expr;\n {\n-  register tree t = fold (expr);\n+  tree t = fold (expr);\n \n   /* We don't care about whether this can be used as an lvalue in this\n      context.  */\n@@ -1833,7 +1833,7 @@ int\n contains_placeholder_p (exp)\n      tree exp;\n {\n-  register enum tree_code code;\n+  enum tree_code code;\n   int result;\n \n   if (!exp)\n@@ -2158,8 +2158,8 @@ tree\n stabilize_reference (ref)\n      tree ref;\n {\n-  register tree result;\n-  register enum tree_code code = TREE_CODE (ref);\n+  tree result;\n+  enum tree_code code = TREE_CODE (ref);\n \n   switch (code)\n     {\n@@ -2256,8 +2256,8 @@ tree\n stabilize_reference_1 (e)\n      tree e;\n {\n-  register tree result;\n-  register enum tree_code code = TREE_CODE (e);\n+  tree result;\n+  enum tree_code code = TREE_CODE (e);\n \n   /* We cannot ignore const expressions because it might be a reference\n      to a const array but whose index contains side-effects.  But we can\n@@ -2331,9 +2331,9 @@ stabilize_reference_1 (e)\n tree\n build VPARAMS ((enum tree_code code, tree tt, ...))\n {\n-  register tree t;\n-  register int length;\n-  register int i;\n+  tree t;\n+  int length;\n+  int i;\n   int fro;\n   int constant;\n \n@@ -2361,8 +2361,8 @@ build VPARAMS ((enum tree_code code, tree tt, ...))\n   if (length == 2)\n     {\n       /* This is equivalent to the loop below, but faster.  */\n-      register tree arg0 = va_arg (p, tree);\n-      register tree arg1 = va_arg (p, tree);\n+      tree arg0 = va_arg (p, tree);\n+      tree arg1 = va_arg (p, tree);\n \n       TREE_OPERAND (t, 0) = arg0;\n       TREE_OPERAND (t, 1) = arg1;\n@@ -2389,7 +2389,7 @@ build VPARAMS ((enum tree_code code, tree tt, ...))\n     }\n   else if (length == 1)\n     {\n-      register tree arg0 = va_arg (p, tree);\n+      tree arg0 = va_arg (p, tree);\n \n       /* The only one-operand cases we handle here are those with side-effects.\n \t Others are handled with build1.  So don't bother checked if the\n@@ -2404,7 +2404,7 @@ build VPARAMS ((enum tree_code code, tree tt, ...))\n     {\n       for (i = 0; i < length; i++)\n \t{\n-\t  register tree operand = va_arg (p, tree);\n+\t  tree operand = va_arg (p, tree);\n \n \t  TREE_OPERAND (t, i) = operand;\n \t  if (operand && fro > i)\n@@ -2432,11 +2432,11 @@ build1 (code, type, node)\n      tree type;\n      tree node;\n {\n-  register int length;\n+  int length;\n #ifdef GATHER_STATISTICS\n-  register tree_node_kind kind;\n+  tree_node_kind kind;\n #endif\n-  register tree t;\n+  tree t;\n \n #ifdef GATHER_STATISTICS\n   if (TREE_CODE_CLASS (code) == 'r')\n@@ -2507,9 +2507,9 @@ build1 (code, type, node)\n tree\n build_nt VPARAMS ((enum tree_code code, ...))\n {\n-  register tree t;\n-  register int length;\n-  register int i;\n+  tree t;\n+  int length;\n+  int i;\n \n   VA_OPEN (p, code);\n   VA_FIXEDARG (p, enum tree_code, code);\n@@ -2535,7 +2535,7 @@ build_decl (code, name, type)\n      enum tree_code code;\n      tree name, type;\n {\n-  register tree t;\n+  tree t;\n \n   t = make_node (code);\n \n@@ -2563,7 +2563,7 @@ tree\n build_block (vars, tags, subblocks, supercontext, chain)\n      tree vars, tags ATTRIBUTE_UNUSED, subblocks, supercontext, chain;\n {\n-  register tree block = make_node (BLOCK);\n+  tree block = make_node (BLOCK);\n \n   BLOCK_VARS (block) = vars;\n   BLOCK_SUBBLOCKS (block) = subblocks;\n@@ -2585,7 +2585,7 @@ build_expr_wfl (node, file, line, col)\n {\n   static const char *last_file = 0;\n   static tree last_filenode = NULL_TREE;\n-  register tree wfl = make_node (EXPR_WITH_FILE_LOCATION);\n+  tree wfl = make_node (EXPR_WITH_FILE_LOCATION);\n \n   EXPR_WFL_NODE (wfl) = node;\n   EXPR_WFL_SET_LINECOL (wfl, line, col);\n@@ -2790,7 +2790,7 @@ lookup_attribute (attr_name, list)\n \n tree\n merge_attributes (a1, a2)\n-     register tree a1, a2;\n+     tree a1, a2;\n {\n   tree attributes;\n \n@@ -2979,7 +2979,7 @@ tree\n build_type_copy (type)\n      tree type;\n {\n-  register tree t, m = TYPE_MAIN_VARIANT (type);\n+  tree t, m = TYPE_MAIN_VARIANT (type);\n \n   t = copy_node (type);\n \n@@ -3005,7 +3005,7 @@ type_hash_list (list)\n      tree list;\n {\n   unsigned int hashcode;\n-  register tree tail;\n+  tree tail;\n \n   for (hashcode = 0, tail = list; tail; tail = TREE_CHAIN (tail))\n     hashcode += TYPE_HASH (TREE_VALUE (tail));\n@@ -3207,7 +3207,7 @@ attribute_hash_list (list)\n      tree list;\n {\n   unsigned int hashcode;\n-  register tree tail;\n+  tree tail;\n \n   for (hashcode = 0, tail = list; tail; tail = TREE_CHAIN (tail))\n     /* ??? Do we want to add in TREE_VALUE too? */\n@@ -3238,7 +3238,7 @@ int\n attribute_list_contained (l1, l2)\n      tree l1, l2;\n {\n-  register tree t1, t2;\n+  tree t1, t2;\n \n   /* First check the obvious, maybe the lists are identical.  */\n   if (l1 == l2)\n@@ -3286,7 +3286,7 @@ int\n type_list_equal (l1, l2)\n      tree l1, l2;\n {\n-  register tree t1, t2;\n+  tree t1, t2;\n \n   for (t1 = l1, t2 = l2; t1 && t2; t1 = TREE_CHAIN (t1), t2 = TREE_CHAIN (t2))\n     if (TREE_VALUE (t1) != TREE_VALUE (t2)\n@@ -3413,7 +3413,7 @@ int\n tree_int_cst_msb (t)\n      tree t;\n {\n-  register int prec;\n+  int prec;\n   HOST_WIDE_INT h;\n   unsigned HOST_WIDE_INT l;\n \n@@ -3472,7 +3472,7 @@ int\n simple_cst_equal (t1, t2)\n      tree t1, t2;\n {\n-  register enum tree_code code1, code2;\n+  enum tree_code code1, code2;\n   int cmp;\n   int i;\n \n@@ -3635,7 +3635,7 @@ tree\n build_pointer_type (to_type)\n      tree to_type;\n {\n-  register tree t = TYPE_POINTER_TO (to_type);\n+  tree t = TYPE_POINTER_TO (to_type);\n \n   /* First, if we already have a type for pointers to TO_TYPE, use it.  */\n \n@@ -3664,7 +3664,7 @@ tree\n build_reference_type (to_type)\n      tree to_type;\n {\n-  register tree t = TYPE_REFERENCE_TO (to_type);\n+  tree t = TYPE_REFERENCE_TO (to_type);\n \n   /* First, if we already have a type for pointers to TO_TYPE, use it.  */\n \n@@ -3717,7 +3717,7 @@ tree\n build_index_type (maxval)\n      tree maxval;\n {\n-  register tree itype = make_node (INTEGER_TYPE);\n+  tree itype = make_node (INTEGER_TYPE);\n \n   TREE_TYPE (itype) = sizetype;\n   TYPE_PRECISION (itype) = TYPE_PRECISION (sizetype);\n@@ -3744,7 +3744,7 @@ tree\n build_range_type (type, lowval, highval)\n      tree type, lowval, highval;\n {\n-  register tree itype = make_node (INTEGER_TYPE);\n+  tree itype = make_node (INTEGER_TYPE);\n \n   TREE_TYPE (itype) = type;\n   if (type == NULL_TREE)\n@@ -3816,7 +3816,7 @@ tree\n build_array_type (elt_type, index_type)\n      tree elt_type, index_type;\n {\n-  register tree t;\n+  tree t;\n   unsigned int hashcode;\n \n   if (TREE_CODE (elt_type) == FUNCTION_TYPE)\n@@ -3873,7 +3873,7 @@ tree\n build_function_type (value_type, arg_types)\n      tree value_type, arg_types;\n {\n-  register tree t;\n+  tree t;\n   unsigned int hashcode;\n \n   if (TREE_CODE (value_type) == FUNCTION_TYPE)\n@@ -3905,7 +3905,7 @@ tree\n build_method_type (basetype, type)\n      tree basetype, type;\n {\n-  register tree t;\n+  tree t;\n   unsigned int hashcode;\n \n   /* Make a node of the sort we want.  */\n@@ -3942,7 +3942,7 @@ tree\n build_offset_type (basetype, type)\n      tree basetype, type;\n {\n-  register tree t;\n+  tree t;\n   unsigned int hashcode;\n \n   /* Make a node of the sort we want.  */\n@@ -3967,7 +3967,7 @@ tree\n build_complex_type (component_type)\n      tree component_type;\n {\n-  register tree t;\n+  tree t;\n   unsigned int hashcode;\n \n   /* Make a node of the sort we want.  */\n@@ -4045,22 +4045,22 @@ build_complex_type (component_type)\n \n tree\n get_unwidened (op, for_type)\n-     register tree op;\n+     tree op;\n      tree for_type;\n {\n   /* Set UNS initially if converting OP to FOR_TYPE is a zero-extension.  */\n-  register tree type = TREE_TYPE (op);\n-  register unsigned final_prec\n+  tree type = TREE_TYPE (op);\n+  unsigned final_prec\n     = TYPE_PRECISION (for_type != 0 ? for_type : type);\n-  register int uns\n+  int uns\n     = (for_type != 0 && for_type != type\n        && final_prec > TYPE_PRECISION (type)\n        && TREE_UNSIGNED (type));\n-  register tree win = op;\n+  tree win = op;\n \n   while (TREE_CODE (op) == NOP_EXPR)\n     {\n-      register int bitschange\n+      int bitschange\n \t= TYPE_PRECISION (TREE_TYPE (op))\n \t  - TYPE_PRECISION (TREE_TYPE (TREE_OPERAND (op, 0)));\n \n@@ -4138,16 +4138,16 @@ get_unwidened (op, for_type)\n \n tree\n get_narrower (op, unsignedp_ptr)\n-     register tree op;\n+     tree op;\n      int *unsignedp_ptr;\n {\n-  register int uns = 0;\n+  int uns = 0;\n   int first = 1;\n-  register tree win = op;\n+  tree win = op;\n \n   while (TREE_CODE (op) == NOP_EXPR)\n     {\n-      register int bitschange\n+      int bitschange\n \t= (TYPE_PRECISION (TREE_TYPE (op))\n \t   - TYPE_PRECISION (TREE_TYPE (TREE_OPERAND (op, 0))));\n "}, {"sha": "efb9de1db540d6400ac0cd2ce30ff808aa3278cf", "filename": "gcc/unroll.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Funroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Funroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funroll.c?ref=b36948478c22c58018d0a888ee8ca393dea60dc9", "patch": "@@ -898,7 +898,7 @@ unroll_loop (loop, insn_count, strength_reduce_p)\n \t\t\t       &initial_value, &final_value, &increment,\n \t\t\t       &mode))\n \t{\n-\t  register rtx diff;\n+\t  rtx diff;\n \t  rtx *labels;\n \t  int abs_inc, neg_inc;\n \n@@ -4043,9 +4043,9 @@ remap_split_bivs (loop, x)\n      rtx x;\n {\n   struct loop_ivs *ivs = LOOP_IVS (loop);\n-  register enum rtx_code code;\n-  register int i;\n-  register const char *fmt;\n+  enum rtx_code code;\n+  int i;\n+  const char *fmt;\n \n   if (x == 0)\n     return x;\n@@ -4084,7 +4084,7 @@ remap_split_bivs (loop, x)\n \tXEXP (x, i) = remap_split_bivs (loop, XEXP (x, i));\n       else if (fmt[i] == 'E')\n \t{\n-\t  register int j;\n+\t  int j;\n \t  for (j = 0; j < XVECLEN (x, i); j++)\n \t    XVECEXP (x, i, j) = remap_split_bivs (loop, XVECEXP (x, i, j));\n \t}"}, {"sha": "312387530bd73fc50eeb3cbeaf078a826840362b", "filename": "gcc/varasm.c", "status": "modified", "additions": 38, "deletions": 38, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=b36948478c22c58018d0a888ee8ca393dea60dc9", "patch": "@@ -1477,7 +1477,7 @@ assemble_variable (decl, top_level, at_end, dont_output_data)\n      int at_end ATTRIBUTE_UNUSED;\n      int dont_output_data;\n {\n-  register const char *name;\n+  const char *name;\n   unsigned int align;\n   int reloc = 0;\n   rtx decl_rtl;\n@@ -2170,7 +2170,7 @@ immed_double_const (i0, i1, mode)\n      HOST_WIDE_INT i0, i1;\n      enum machine_mode mode;\n {\n-  register rtx r;\n+  rtx r;\n \n   if (GET_MODE_CLASS (mode) == MODE_INT\n       || GET_MODE_CLASS (mode) == MODE_PARTIAL_INT)\n@@ -2262,7 +2262,7 @@ immed_real_const_1 (d, mode)\n      enum machine_mode mode;\n {\n   union real_extract u;\n-  register rtx r;\n+  rtx r;\n \n   /* Get the desired `double' value as a sequence of ints\n      since that is how they are stored in a CONST_DOUBLE.  */\n@@ -2343,7 +2343,7 @@ immed_real_const (exp)\n void\n clear_const_double_mem ()\n {\n-  register rtx r, next;\n+  rtx r, next;\n   enum machine_mode mode;\n   int i;\n \n@@ -2381,9 +2381,9 @@ decode_addr_const (exp, value)\n      tree exp;\n      struct addr_const *value;\n {\n-  register tree target = TREE_OPERAND (exp, 0);\n-  register int offset = 0;\n-  register rtx x;\n+  tree target = TREE_OPERAND (exp, 0);\n+  int offset = 0;\n+  rtx x;\n \n   while (1)\n     {\n@@ -2564,9 +2564,9 @@ static int\n const_hash (exp)\n      tree exp;\n {\n-  register const char *p;\n-  register int len, hi, i;\n-  register enum tree_code code = TREE_CODE (exp);\n+  const char *p;\n+  int len, hi, i;\n+  enum tree_code code = TREE_CODE (exp);\n \n   /* Either set P and LEN to the address and len of something to hash and\n      exit the switch or return a value.  */\n@@ -2605,7 +2605,7 @@ const_hash (exp)\n \t}\n       else\n \t{\n-\t  register tree link;\n+\t  tree link;\n \n \t  /* For record type, include the type in the hashing.\n \t     We do not do so for array types\n@@ -2702,9 +2702,9 @@ compare_constant_1 (exp, p)\n      tree exp;\n      const unsigned char *p;\n {\n-  register const unsigned char *strp;\n-  register int len;\n-  register enum tree_code code = TREE_CODE (exp);\n+  const unsigned char *strp;\n+  int len;\n+  enum tree_code code = TREE_CODE (exp);\n \n   if (code != (enum tree_code) *p++)\n     return 0;\n@@ -2771,7 +2771,7 @@ compare_constant_1 (exp, p)\n \t}\n       else\n \t{\n-\t  register tree link;\n+\t  tree link;\n \t  int length = list_length (CONSTRUCTOR_ELTS (exp));\n \t  tree type;\n \t  enum machine_mode mode = TYPE_MODE (TREE_TYPE (exp));\n@@ -2957,9 +2957,9 @@ static void\n record_constant_1 (exp)\n      tree exp;\n {\n-  register const unsigned char *strp;\n-  register int len;\n-  register enum tree_code code = TREE_CODE (exp);\n+  const unsigned char *strp;\n+  int len;\n+  enum tree_code code = TREE_CODE (exp);\n \n   obstack_1grow (&permanent_obstack, (unsigned int) code);\n \n@@ -3006,7 +3006,7 @@ record_constant_1 (exp)\n \t}\n       else\n \t{\n-\t  register tree link;\n+\t  tree link;\n \t  int length = list_length (CONSTRUCTOR_ELTS (exp));\n \t  enum machine_mode mode = TYPE_MODE (TREE_TYPE (exp));\n \t  tree type;\n@@ -3276,8 +3276,8 @@ output_constant_def (exp, defer)\n      tree exp;\n      int defer;\n {\n-  register int hash;\n-  register struct constant_descriptor *desc;\n+  int hash;\n+  struct constant_descriptor *desc;\n   struct deferred_string **defstr;\n   char label[256];\n   int reloc;\n@@ -3705,8 +3705,8 @@ const_hash_rtx (mode, x)\n      enum machine_mode mode;\n      rtx x;\n {\n-  register int hi;\n-  register size_t i;\n+  int hi;\n+  size_t i;\n \n   struct rtx_const value;\n   decode_rtx_const (mode, x, &value);\n@@ -3730,9 +3730,9 @@ compare_constant_rtx (mode, x, desc)\n      rtx x;\n      struct constant_descriptor *desc;\n {\n-  register int *p = (int *) desc->u.contents;\n-  register int *strp;\n-  register int len;\n+  int *p = (int *) desc->u.contents;\n+  int *strp;\n+  int len;\n   struct rtx_const value;\n \n   decode_rtx_const (mode, x, &value);\n@@ -3773,8 +3773,8 @@ force_const_mem (mode, x)\n      enum machine_mode mode;\n      rtx x;\n {\n-  register int hash;\n-  register struct constant_descriptor *desc;\n+  int hash;\n+  struct constant_descriptor *desc;\n   char label[256];\n   const char *found = 0;\n   rtx def;\n@@ -3807,7 +3807,7 @@ force_const_mem (mode, x)\n \n   if (found == 0)\n     {\n-      register struct pool_constant *pool;\n+      struct pool_constant *pool;\n       int align;\n \n       /* No constant equal to X is known to have been output.\n@@ -4081,7 +4081,7 @@ output_constant_pool (fnname, fndecl)\n static void\n mark_constant_pool ()\n {\n-  register rtx insn;\n+  rtx insn;\n   struct pool_constant *pool;\n \n   if (first_pool == 0 && htab_elements (const_str_htab) == 0)\n@@ -4110,8 +4110,8 @@ static void\n mark_constants (x)\n      rtx x;\n {\n-  register int i;\n-  register const char *format_ptr;\n+  int i;\n+  const char *format_ptr;\n \n   if (x == 0)\n     return;\n@@ -4148,7 +4148,7 @@ mark_constants (x)\n \tcase 'E':\n \t  if (XVEC (x, i) != 0)\n \t    {\n-\t      register int j;\n+\t      int j;\n \n \t      for (j = 0; j < XVECLEN (x, i); j++)\n \t\tmark_constants (XVECEXP (x, i, j));\n@@ -4238,7 +4238,7 @@ output_addressed_constants (exp)\n     {\n     case ADDR_EXPR:\n       {\n-\tregister tree constant = TREE_OPERAND (exp, 0);\n+\ttree constant = TREE_OPERAND (exp, 0);\n \n \twhile (TREE_CODE (constant) == COMPONENT_REF)\n \t  {\n@@ -4268,7 +4268,7 @@ output_addressed_constants (exp)\n \n     case CONSTRUCTOR:\n       {\n-\tregister tree link;\n+\ttree link;\n \tfor (link = CONSTRUCTOR_ELTS (exp); link; link = TREE_CHAIN (link))\n \t  if (TREE_VALUE (link) != 0)\n \t    reloc |= output_addressed_constants (TREE_VALUE (link));\n@@ -4476,7 +4476,7 @@ output_constant (exp, size, align)\n      int size;\n      unsigned int align;\n {\n-  register enum tree_code code = TREE_CODE (TREE_TYPE (exp));\n+  enum tree_code code = TREE_CODE (TREE_TYPE (exp));\n \n   /* Some front-ends use constants other than the standard\n      language-indepdent varieties, but which may still be output\n@@ -4672,14 +4672,14 @@ output_constructor (exp, size, align)\n      unsigned int align;\n {\n   tree type = TREE_TYPE (exp);\n-  register tree link, field = 0;\n+  tree link, field = 0;\n   tree min_index = 0;\n   /* Number of bytes output or skipped so far.\n      In other words, current position within the constructor.  */\n   HOST_WIDE_INT total_bytes = 0;\n   /* Non-zero means BYTE contains part of a byte, to be output.  */\n   int byte_buffer_in_use = 0;\n-  register int byte = 0;\n+  int byte = 0;\n \n   if (HOST_BITS_PER_WIDE_INT < BITS_PER_UNIT)\n     abort ();"}, {"sha": "36a1e726559071f0da821c1767e0559e25625be3", "filename": "gcc/xcoffout.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Fxcoffout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b36948478c22c58018d0a888ee8ca393dea60dc9/gcc%2Fxcoffout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fxcoffout.c?ref=b36948478c22c58018d0a888ee8ca393dea60dc9", "patch": "@@ -328,7 +328,7 @@ static int do_block = 0;\n \n static void\n xcoffout_block (block, depth, args)\n-     register tree block;\n+     tree block;\n      int depth;\n      tree args;\n {"}]}