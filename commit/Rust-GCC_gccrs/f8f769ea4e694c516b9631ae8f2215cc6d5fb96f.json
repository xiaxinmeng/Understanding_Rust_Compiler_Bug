{"sha": "f8f769ea4e694c516b9631ae8f2215cc6d5fb96f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjhmNzY5ZWE0ZTY5NGM1MTZiOTYzMWFlOGYyMjE1Y2M2ZDVmYjk2Zg==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@wolery.cumb.org", "date": "2000-05-28T05:56:38Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2000-05-28T05:56:38Z"}, "message": "cppfiles.c: Read files in, using mmap if possible, then prescan them separately.\n\n\t* cppfiles.c: Read files in, using mmap if possible, then\n\tprescan them separately.\n\t(read_file, read_with_read): New functions.\n\t* cpplex.c: Don't define UCHAR_MAX.\n\t(_cpp_read_and_prescan): Rename to _cpp_prescan.  Don't read\n\tthe file here.\n\n\t* cppinit.c (handle_option): Automatically define __cplusplus,\n\t__OBJC__, __ASEEMBLER__, _LANGUAGE_FORTRAN here when we see\n\tthe respective -lang switch.\n\n\t* cpphash.h (enum node_type, struct hashnode, _cpp_lookup\n\tprototype): Move to...\n\t* cpplib.h: ... here.  Rename struct hashnode to struct\n\tcpp_hashnode and give it a typedef.  Rename _cpp_lookup to\n\tcpp_lookup.  Add 'fe_value' slot, a union tree_node *.\n\nFrom-SVN: r34228", "tree": {"sha": "2f5db92bd0f352a3b3a9f86ac6b719d86650e290", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2f5db92bd0f352a3b3a9f86ac6b719d86650e290"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f8f769ea4e694c516b9631ae8f2215cc6d5fb96f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8f769ea4e694c516b9631ae8f2215cc6d5fb96f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f8f769ea4e694c516b9631ae8f2215cc6d5fb96f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8f769ea4e694c516b9631ae8f2215cc6d5fb96f/comments", "author": null, "committer": null, "parents": [{"sha": "e79f71f73dd44748c28d7f94b29d293722345e26", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e79f71f73dd44748c28d7f94b29d293722345e26", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e79f71f73dd44748c28d7f94b29d293722345e26"}], "stats": {"total": 691, "additions": 372, "deletions": 319}, "files": [{"sha": "7fce1fd1028b6ef8ee7e8808e45bc11643da7af4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8f769ea4e694c516b9631ae8f2215cc6d5fb96f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8f769ea4e694c516b9631ae8f2215cc6d5fb96f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f8f769ea4e694c516b9631ae8f2215cc6d5fb96f", "patch": "@@ -1,3 +1,22 @@\n+2000-05-27  Zack Weinberg  <zack@wolery.cumb.org>\n+\n+\t* cppfiles.c: Read files in, using mmap if possible, then\n+\tprescan them separately.\n+\t(read_file, read_with_read): New functions.\n+\t* cpplex.c: Don't define UCHAR_MAX.\n+\t(_cpp_read_and_prescan): Rename to _cpp_prescan.  Don't read\n+\tthe file here.\n+\n+\t* cppinit.c (handle_option): Automatically define __cplusplus,\n+\t__OBJC__, __ASEEMBLER__, _LANGUAGE_FORTRAN here when we see\n+\tthe respective -lang switch.\n+\n+\t* cpphash.h (enum node_type, struct hashnode, _cpp_lookup\n+\tprototype): Move to...\n+\t* cpplib.h: ... here.  Rename struct hashnode to struct\n+\tcpp_hashnode and give it a typedef.  Rename _cpp_lookup to\n+\tcpp_lookup.  Add 'fe_value' slot, a union tree_node *.\n+\n 2000-05-27  Geoffrey Keating  <geoffk@cygnus.com>\n \n \t* config/rs6000/rs6000.md (movsi): Constify 'name'."}, {"sha": "b50acd8bb3cdc49d187f3581a1c43ae2477cd868", "filename": "gcc/cppexp.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8f769ea4e694c516b9631ae8f2215cc6d5fb96f/gcc%2Fcppexp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8f769ea4e694c516b9631ae8f2215cc6d5fb96f/gcc%2Fcppexp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppexp.c?ref=f8f769ea4e694c516b9631ae8f2215cc6d5fb96f", "patch": "@@ -394,7 +394,7 @@ parse_assertion (pfile)\n      cpp_reader *pfile;\n {\n   struct operation op;\n-  HASHNODE *hp;\n+  cpp_hashnode *hp;\n   struct predicate *pred;\n   cpp_toklist query;\n   enum cpp_ttype type;\n@@ -414,7 +414,7 @@ parse_assertion (pfile)\n \n   tok = pfile->token_buffer + old_written;\n   len = CPP_WRITTEN (pfile) - old_written;\n-  hp = _cpp_lookup (pfile, tok, len);\n+  hp = cpp_lookup (pfile, tok, len);\n \n   /* Look ahead for an open paren.  */\n   _cpp_skip_hspace (pfile);"}, {"sha": "295590203963237a65857239adcd000f91d338a8", "filename": "gcc/cppfiles.c", "status": "modified", "additions": 113, "deletions": 27, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8f769ea4e694c516b9631ae8f2215cc6d5fb96f/gcc%2Fcppfiles.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8f769ea4e694c516b9631ae8f2215cc6d5fb96f/gcc%2Fcppfiles.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppfiles.c?ref=f8f769ea4e694c516b9631ae8f2215cc6d5fb96f", "patch": "@@ -28,6 +28,17 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n #include \"intl.h\"\n #include \"mkdeps.h\"\n \n+#ifdef HAVE_MMAP_FILE\n+# include <sys/mman.h>\n+# ifndef MMAP_THRESHOLD\n+#  define MMAP_THRESHOLD 3 /* Minimum page count to mmap the file.  */\n+# endif\n+\n+#else  /* No MMAP_FILE */\n+#  undef MMAP_THRESHOLD\n+#  define MMAP_THRESHOLD 0\n+#endif\n+\n static IHASH *redundant_include_p PARAMS ((cpp_reader *, IHASH *,\n \t\t\t\t\t   struct file_name_list *));\n static IHASH *make_IHASH\tPARAMS ((const char *, const char *,\n@@ -45,8 +56,10 @@ static int eq_IHASH\t\tPARAMS ((const void *, const void *));\n static int find_include_file\tPARAMS ((cpp_reader *, const char *,\n \t\t\t\t\tstruct file_name_list *,\n \t\t\t\t\tIHASH **, int *));\n-static int read_include_file\tPARAMS ((cpp_reader *, int, IHASH *));\n static inline int open_include_file PARAMS ((cpp_reader *, const char *));\n+static int read_include_file\tPARAMS ((cpp_reader *, int, IHASH *));\n+static ssize_t read_with_read\tPARAMS ((cpp_buffer *, int, ssize_t));\n+static ssize_t read_file\tPARAMS ((cpp_buffer *, int, ssize_t));\n \n #if 0\n static void hack_vms_include_specification PARAMS ((char *));\n@@ -678,8 +691,7 @@ read_include_file (pfile, fd, ihash)\n      IHASH *ihash;\n {\n   struct stat st;\n-  size_t st_size;\n-  long length;\n+  ssize_t length;\n   cpp_buffer *fp;\n \n   fp = cpp_push_buffer (pfile, NULL, 0);\n@@ -690,35 +702,37 @@ read_include_file (pfile, fd, ihash)\n   if (fstat (fd, &st) < 0)\n     goto perror_fail;\n \n-  /* If fd points to a plain file, we know how big it is, so we can\n-     allocate the buffer all at once.  If fd is a pipe or terminal, we\n-     can't.  Most C source files are 4k or less, so we guess that.  If\n-     fd is something weird, like a directory, we don't want to read it\n-     at all.\n+  /* If fd points to a plain file, we might be able to mmap it; we can\n+     definitely allocate the buffer all at once.  If fd is a pipe or\n+     terminal, we can't do either.  If fd is something weird, like a\n+     block device or a directory, we don't want to read it at all.\n \n      Unfortunately, different systems use different st.st_mode values\n      for pipes: some have S_ISFIFO, some S_ISSOCK, some are buggy and\n      zero the entire struct stat except a couple fields.  Hence we don't\n      even try to figure out what something is, except for plain files,\n-     directories, and block devices.\n-\n-     In all cases, read_and_prescan will resize the buffer if it\n-     turns out there's more data than we thought.  */\n+     directories, and block devices.  */\n \n   if (S_ISREG (st.st_mode))\n     {\n-      /* off_t might have a wider range than size_t - in other words,\n+      ssize_t st_size;\n+\n+      /* off_t might have a wider range than ssize_t - in other words,\n \t the max size of a file might be bigger than the address\n \t space.  We can't handle a file that large.  (Anyone with\n-         a single source file bigger than 4GB needs to rethink\n+\t a single source file bigger than 2GB needs to rethink\n \t their coding style.)  */\n-      st_size = (size_t) st.st_size;\n-      if ((unsigned HOST_WIDEST_INT) st_size\n-\t  != (unsigned HOST_WIDEST_INT) st.st_size)\n+      if (st.st_size > SSIZE_MAX)\n \t{\n-\t  cpp_error (pfile, \"file `%s' is too large\", ihash->name);\n+\t  cpp_error (pfile, \"%s is too large\", ihash->name);\n \t  goto fail;\n \t}\n+      st_size = st.st_size;\n+      length = read_file (fp, fd, st_size);\n+      if (length == -1)\n+\tgoto perror_fail;\n+      if (length < st_size)\n+\tcpp_warning (pfile, \"%s is shorter than expected\\n\", ihash->name);\n     }\n   else if (S_ISBLK (st.st_mode))\n     {\n@@ -732,25 +746,28 @@ read_include_file (pfile, fd, ihash)\n     }\n   else\n     {\n-      /* We don't know how big this is.  4k is a decent first guess.  */\n-      st_size = 4096;\n+      /* 8 kilobytes is a sensible starting size.  It ought to be\n+\t bigger than the kernel pipe buffer, and it's definitely\n+\t bigger than the majority of C source files.  */\n+      length = read_with_read (fp, fd, 8 * 1024);\n+      if (length == -1)\n+\tgoto perror_fail;\n     }\n \n-  /* Read the file, converting end-of-line characters and trigraphs\n-     (if enabled). */\n+  /* These must be set before prescan.  */\n   fp->ihash = ihash;\n   fp->nominal_fname = ihash->name;\n-  length = _cpp_read_and_prescan (pfile, fp, fd, st_size);\n-  if (length < 0)\n-    goto fail;\n+  \n   if (length == 0)\n     ihash->control_macro = U\"\";  /* never re-include */\n+  else\n+    /* Temporary - I hope.  */\n+    length = _cpp_prescan (pfile, fp, length);\n \n-  close (fd);\n   fp->rlimit = fp->buf + length;\n   fp->cur = fp->buf;\n   if (ihash->foundhere != ABSOLUTE_PATH)\n-      fp->system_header_p = ihash->foundhere->sysp;\n+    fp->system_header_p = ihash->foundhere->sysp;\n   fp->lineno = 1;\n   fp->line_base = fp->buf;\n \n@@ -761,6 +778,7 @@ read_include_file (pfile, fd, ihash)\n \n   pfile->input_stack_listing_current = 0;\n   pfile->only_seen_white = 2;\n+  close (fd);\n   return 1;\n \n  perror_fail:\n@@ -772,6 +790,74 @@ read_include_file (pfile, fd, ihash)\n   return 0;\n }\n \n+static ssize_t\n+read_file (fp, fd, size)\n+     cpp_buffer *fp;\n+     int fd;\n+     ssize_t size;\n+{\n+  static int pagesize = -1;\n+\n+  if (size == 0)\n+    return 0;\n+\n+  if (pagesize == -1)\n+    pagesize = getpagesize ();\n+\n+#if MMAP_THRESHOLD\n+  if (size / pagesize >= MMAP_THRESHOLD)\n+    {\n+      const U_CHAR *result\n+\t= (const U_CHAR *) mmap (0, size, PROT_READ, MAP_PRIVATE, fd, 0);\n+      if (result != (const U_CHAR *)-1)\n+\t{\n+\t  fp->buf = result;\n+\t  fp->mapped = 1;\n+\t  return size;\n+\t}\n+    }\n+  /* If mmap fails, try read.  If there's really a problem, read will\n+     fail too.  */\n+#endif\n+\n+  return read_with_read (fp, fd, size);\n+}\n+\n+static ssize_t\n+read_with_read (fp, fd, size)\n+     cpp_buffer *fp;\n+     int fd;\n+     ssize_t size;\n+{\n+  ssize_t offset, count;\n+  U_CHAR *buf;\n+\n+  buf = (U_CHAR *) xmalloc (size);\n+  offset = 0;\n+  while ((count = read (fd, buf + offset, size - offset)) > 0)\n+    {\n+      offset += count;\n+      if (offset == size)\n+\tbuf = xrealloc (buf, (size *= 2));\n+    }\n+  if (count < 0)\n+    {\n+      free (buf);\n+      return -1;\n+    }\n+  if (offset == 0)\n+    {\n+      free (buf);\n+      return 0;\n+    }\n+\n+  if (offset < size)\n+    buf = xrealloc (buf, offset);\n+  fp->buf = buf;\n+  fp->mapped = 0;\n+  return offset;\n+}\n+\n /* Given a path FNAME, extract the directory component and place it\n    onto the actual_dirs list.  Return a pointer to the allocated\n    file_name_list structure.  These structures are used to implement"}, {"sha": "76f52ccef2f883fb209dafed74afd8a6f5234f98", "filename": "gcc/cpphash.c", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8f769ea4e694c516b9631ae8f2215cc6d5fb96f/gcc%2Fcpphash.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8f769ea4e694c516b9631ae8f2215cc6d5fb96f/gcc%2Fcpphash.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.c?ref=f8f769ea4e694c516b9631ae8f2215cc6d5fb96f", "patch": "@@ -110,18 +110,18 @@ struct hashdummy\n static unsigned int hash_HASHNODE PARAMS ((const void *));\n static int eq_HASHNODE\t\t  PARAMS ((const void *, const void *));\n static void del_HASHNODE\t  PARAMS ((void *));\n-static HASHNODE *make_HASHNODE\t  PARAMS ((const U_CHAR *, size_t,\n+static cpp_hashnode *make_HASHNODE\t  PARAMS ((const U_CHAR *, size_t,\n \t\t\t\t\t   enum node_type, unsigned int));\n \n static void dump_funlike_macro\t  PARAMS ((cpp_reader *,\n \t\t\t\t\t   const struct funct_defn *));\n static int dump_hash_helper\t  PARAMS ((void **, void *));\n \n static void push_macro_expansion PARAMS ((cpp_reader *, const U_CHAR *,\n-\t\t\t\t\t  int, HASHNODE *));\n+\t\t\t\t\t  int, cpp_hashnode *));\n static int unsafe_chars\t\t PARAMS ((cpp_reader *, int, int));\n static enum cpp_ttype macarg\t PARAMS ((cpp_reader *, int));\n-static void special_symbol\t PARAMS ((cpp_reader *, HASHNODE *));\n+static void special_symbol\t PARAMS ((cpp_reader *, cpp_hashnode *));\n static int compare_defs\t\t PARAMS ((cpp_reader *,\n \t\t\t\t\t  const struct funct_defn *,\n \t\t\t\t\t  const struct funct_defn *));\n@@ -195,7 +195,7 @@ static void scan_arguments\tPARAMS ((cpp_reader *,\n \t\t\t\t\t const struct funct_defn *,\n \t\t\t\t\t struct argdata *, const U_CHAR *));\n static void stringify\t\tPARAMS ((cpp_reader *, struct argdata *));\n-static void funlike_macroexpand\tPARAMS ((cpp_reader *, HASHNODE *,\n+static void funlike_macroexpand\tPARAMS ((cpp_reader *, cpp_hashnode *,\n \t\t\t\t\t struct argdata *));\n \n /* Calculate hash of a string of length LEN.  */\n@@ -213,16 +213,16 @@ _cpp_calc_hash (str, len)\n   return r + len;\n }\n \n-/* Calculate hash of a HASHNODE structure.  */\n+/* Calculate hash of a cpp_hashnode structure.  */\n static unsigned int\n hash_HASHNODE (x)\n      const void *x;\n {\n-  const HASHNODE *h = (const HASHNODE *)x;\n+  const cpp_hashnode *h = (const cpp_hashnode *)x;\n   return h->hash;\n }\n \n-/* Compare a HASHNODE structure (already in the table) with a\n+/* Compare a cpp_hashnode structure (already in the table) with a\n    hashdummy structure (not yet in the table).  This relies on the\n    rule that the existing entry is the first argument, the potential\n    entry the second.  It also relies on the comparison function never\n@@ -233,36 +233,36 @@ eq_HASHNODE (x, y)\n      const void *x;\n      const void *y;\n {\n-  const HASHNODE *a = (const HASHNODE *)x;\n+  const cpp_hashnode *a = (const cpp_hashnode *)x;\n   const struct hashdummy *b = (const struct hashdummy *)y;\n \n   return (a->length == b->length\n \t  && !ustrncmp (a->name, b->name, a->length));\n }\n \n-/* Destroy a HASHNODE.  */\n+/* Destroy a cpp_hashnode.  */\n static void\n del_HASHNODE (x)\n      void *x;\n {\n-  HASHNODE *h = (HASHNODE *)x;\n+  cpp_hashnode *h = (cpp_hashnode *)x;\n \n   _cpp_free_definition (h);\n   free (h);\n }\n \n-/* Allocate and initialize a HASHNODE structure.\n+/* Allocate and initialize a cpp_hashnode structure.\n    Caller must fill in the value field.  */\n \n-static HASHNODE *\n+static cpp_hashnode *\n make_HASHNODE (name, len, type, hash)\n      const U_CHAR *name;\n      size_t len;\n      enum node_type type;\n      unsigned int hash;\n {\n-  HASHNODE *hp = (HASHNODE *) xmalloc (sizeof (HASHNODE) + len);\n-  U_CHAR *p = (U_CHAR *)hp + offsetof (HASHNODE, name);\n+  cpp_hashnode *hp = (cpp_hashnode *) xmalloc (sizeof (cpp_hashnode) + len);\n+  U_CHAR *p = (U_CHAR *)hp + offsetof (cpp_hashnode, name);\n \n   hp->type = type;\n   hp->length = len;\n@@ -277,21 +277,21 @@ make_HASHNODE (name, len, type, hash)\n \n /* Find the hash node for name \"name\", of length LEN.  */\n \n-HASHNODE *\n-_cpp_lookup (pfile, name, len)\n+cpp_hashnode *\n+cpp_lookup (pfile, name, len)\n      cpp_reader *pfile;\n      const U_CHAR *name;\n      int len;\n {\n   struct hashdummy dummy;\n-  HASHNODE *new, **slot;\n+  cpp_hashnode *new, **slot;\n   unsigned int hash;\n \n   dummy.name = name;\n   dummy.length = len;\n   hash = _cpp_calc_hash (name, len);\n \n-  slot = (HASHNODE **)\n+  slot = (cpp_hashnode **)\n     htab_find_slot_with_hash (pfile->hashtab, (void *)&dummy, hash, INSERT);\n   if (*slot)\n     return *slot;\n@@ -315,7 +315,7 @@ _cpp_init_macro_hash (pfile)\n \n void\n _cpp_free_definition (h)\n-     HASHNODE *h;\n+     cpp_hashnode *h;\n {\n   if (h->type == T_XCONST)\n     free ((PTR) h->value.cpval);\n@@ -860,7 +860,7 @@ int\n _cpp_create_definition (pfile, list, hp)\n      cpp_reader *pfile;\n      cpp_toklist *list;\n-     HASHNODE *hp;\n+     cpp_hashnode *hp;\n {\n   struct funct_defn *fdefn = 0;\n   struct object_defn *odefn = 0;\n@@ -1102,7 +1102,7 @@ _cpp_quote_string (pfile, src)\n static void\n special_symbol (pfile, hp)\n      cpp_reader *pfile;\n-     HASHNODE *hp;\n+     cpp_hashnode *hp;\n {\n   const U_CHAR *buf;\n   cpp_buffer *ip;\n@@ -1187,12 +1187,12 @@ special_symbol (pfile, hp)\n       {\n \ttime_t tt = time (NULL);\n \tstruct tm *tb = localtime (&tt);\n-\tHASHNODE *d, *t;\n+\tcpp_hashnode *d, *t;\n \n \tif (hp->type == T_DATE)\n-\t  d = hp, t = _cpp_lookup (pfile, DSC(\"__TIME__\"));\n+\t  d = hp, t = cpp_lookup (pfile, DSC(\"__TIME__\"));\n \telse\n-\t  t = hp, d = _cpp_lookup (pfile, DSC(\"__DATE__\"));\n+\t  t = hp, d = cpp_lookup (pfile, DSC(\"__DATE__\"));\n \n \td->value.cpval = xmalloc (sizeof \"'Oct 11 1347'\");\n \tsprintf ((char *)d->value.cpval, \"\\\"%s %2d %4d\\\"\",\n@@ -1229,7 +1229,7 @@ special_symbol (pfile, hp)\n void\n _cpp_macroexpand (pfile, hp)\n      cpp_reader *pfile;\n-     HASHNODE *hp;\n+     cpp_hashnode *hp;\n {\n   const struct funct_defn *defn;\n   struct argdata *args;\n@@ -1481,7 +1481,7 @@ stringify (pfile, arg)\n static void\n funlike_macroexpand (pfile, hp, args)\n      cpp_reader *pfile;\n-     HASHNODE *hp;\n+     cpp_hashnode *hp;\n      struct argdata *args;\n {\n   const struct funct_defn *defn = hp->value.fdefn;\n@@ -1731,7 +1731,7 @@ push_macro_expansion (pfile, xbuf, len, hp)\n      cpp_reader *pfile;\n      const U_CHAR *xbuf;\n      int len;\n-     HASHNODE *hp;\n+     cpp_hashnode *hp;\n {\n   cpp_buffer *mbuf;\n   int advance_cur = 0;\n@@ -1840,7 +1840,7 @@ compare_defs (pfile, d1, d2)\n void\n _cpp_dump_definition (pfile, hp)\n      cpp_reader *pfile;\n-     HASHNODE *hp;\n+     cpp_hashnode *hp;\n {\n   CPP_RESERVE (pfile, hp->length + sizeof \"#define \");\n   CPP_PUTS_Q (pfile, \"#define \", sizeof \"#define \" - 1);\n@@ -1945,7 +1945,7 @@ dump_hash_helper (h, p)\n      void **h;\n      void *p;\n {\n-  HASHNODE *hp = (HASHNODE *)*h;\n+  cpp_hashnode *hp = (cpp_hashnode *)*h;\n   cpp_reader *pfile = (cpp_reader *)p;\n \n   if (hp->type == T_MACRO || hp->type == T_FMACRO"}, {"sha": "c590de68636ec453a17435765cc132703d76e791", "filename": "gcc/cpphash.h", "status": "modified", "additions": 9, "deletions": 58, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8f769ea4e694c516b9631ae8f2215cc6d5fb96f/gcc%2Fcpphash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8f769ea4e694c516b9631ae8f2215cc6d5fb96f/gcc%2Fcpphash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.h?ref=f8f769ea4e694c516b9631ae8f2215cc6d5fb96f", "patch": "@@ -25,52 +25,6 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n typedef unsigned char U_CHAR;\n #define U (const U_CHAR *)  /* Intended use: U\"string\" */\n \n-/* The structure of a node in the hash table.  The hash table\n-   has entries for all tokens defined by #define commands (type T_MACRO),\n-   plus some special tokens like __LINE__ (these each have their own\n-   type, and the appropriate code is run when that type of node is seen.\n-   It does not contain control words like \"#define\", which are recognized\n-   by a separate piece of code. */\n-\n-/* different flavors of hash nodes */\n-enum node_type\n-{\n-  T_VOID = 0,\t   /* no definition yet */\n-  T_SPECLINE,\t   /* `__LINE__' */\n-  T_DATE,\t   /* `__DATE__' */\n-  T_FILE,\t   /* `__FILE__' */\n-  T_BASE_FILE,\t   /* `__BASE_FILE__' */\n-  T_INCLUDE_LEVEL, /* `__INCLUDE_LEVEL__' */\n-  T_TIME,\t   /* `__TIME__' */\n-  T_STDC,\t   /* `__STDC__' */\n-  T_CONST,\t   /* Constant string, used by `__SIZE_TYPE__' etc */\n-  T_XCONST,\t   /* Ditto, but the string is malloced memory */\n-  T_POISON,\t   /* poisoned identifier */\n-  T_MACRO,\t   /* object-like macro */\n-  T_FMACRO,\t   /* function-like macro */\n-  T_IDENTITY,\t   /* macro defined to itself */\n-  T_EMPTY,\t   /* macro defined to nothing */\n-  T_ASSERTION\t   /* predicate for #assert */\n-};\n-\n-typedef struct hashnode HASHNODE;\n-struct hashnode\n-{\n-  unsigned int hash;\t\t\t/* cached hash value */\n-  unsigned short length;\t\t/* length of name */\n-  ENUM_BITFIELD(node_type) type : 8;\t/* node type */\n-  char disabled;\t\t\t/* macro turned off for rescan? */\n-\n-  union {\n-    const U_CHAR *cpval;\t\t/* some predefined macros */\n-    const struct object_defn *odefn;\t/* #define foo bar */\n-    const struct funct_defn *fdefn;\t/* #define foo(x) bar(x) */\n-    struct predicate *pred;\t\t/* #assert */\n-  } value;\n-\n-  const U_CHAR name[1];\t\t\t/* name[length] */\n-};\n-\n /* Structure used for assertion predicates.  */\n struct predicate\n {\n@@ -109,14 +63,13 @@ struct ihash\n   struct ihash *next_this_file;\n \n   /* Location of the file in the include search path.\n-     Used for include_next */\n+     Used for include_next and to detect redundant includes. */\n   struct file_name_list *foundhere;\n \n   unsigned int hash;\t\t/* save hash value for future reference */\n   const char *nshort;\t\t/* name of file as referenced in #include;\n \t\t\t\t   points into name[]  */\n-  const U_CHAR *control_macro;\t/* macro, if any, preventing reinclusion -\n-\t\t\t\t   see redundant_include_p */\n+  const U_CHAR *control_macro;\t/* macro, if any, preventing reinclusion.  */\n   const char name[1];\t\t/* (partial) pathname of file */\n };\n typedef struct ihash IHASH;\n@@ -224,14 +177,12 @@ extern unsigned char _cpp_IStable[256];\n \n /* In cpphash.c */\n extern unsigned int _cpp_calc_hash\tPARAMS ((const U_CHAR *, size_t));\n-extern HASHNODE *_cpp_lookup\t\tPARAMS ((cpp_reader *,\n-\t\t\t\t\t\t const U_CHAR *, int));\n-extern void _cpp_free_definition\tPARAMS ((HASHNODE *));\n-extern int _cpp_create_definition\tPARAMS ((cpp_reader *,\n-\t\t\t\t\t\t cpp_toklist *, HASHNODE *));\n-extern void _cpp_dump_definition\tPARAMS ((cpp_reader *, HASHNODE *));\n+extern void _cpp_free_definition\tPARAMS ((cpp_hashnode *));\n+extern int _cpp_create_definition\tPARAMS ((cpp_reader *, cpp_toklist *,\n+\t\t\t\t\t\t cpp_hashnode *));\n+extern void _cpp_dump_definition\tPARAMS ((cpp_reader *, cpp_hashnode *));\n extern void _cpp_quote_string\t\tPARAMS ((cpp_reader *, const U_CHAR *));\n-extern void _cpp_macroexpand\t\tPARAMS ((cpp_reader *, HASHNODE *));\n+extern void _cpp_macroexpand\t\tPARAMS ((cpp_reader *, cpp_hashnode *));\n extern void _cpp_init_macro_hash\tPARAMS ((cpp_reader *));\n extern void _cpp_dump_macro_hash\tPARAMS ((cpp_reader *));\n \n@@ -254,8 +205,8 @@ extern void _cpp_expand_to_buffer\tPARAMS ((cpp_reader *,\n \t\t\t\t\t\t const unsigned char *, int));\n extern int _cpp_parse_assertion\t\tPARAMS ((cpp_reader *));\n extern enum cpp_ttype _cpp_lex_token\tPARAMS ((cpp_reader *));\n-extern long _cpp_read_and_prescan\tPARAMS ((cpp_reader *, cpp_buffer *,\n-\t\t\t\t\t\t int, size_t));\n+extern ssize_t _cpp_prescan\t\tPARAMS ((cpp_reader *, cpp_buffer *,\n+\t\t\t\t\t\t ssize_t));\n extern void _cpp_init_input_buffer\tPARAMS ((cpp_reader *));\n extern void _cpp_grow_token_buffer\tPARAMS ((cpp_reader *, long));\n extern enum cpp_ttype _cpp_get_directive_token"}, {"sha": "86f85d6c3405a9297b55f9d31a1d213e8f04e70a", "filename": "gcc/cppinit.c", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8f769ea4e694c516b9631ae8f2215cc6d5fb96f/gcc%2Fcppinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8f769ea4e694c516b9631ae8f2215cc6d5fb96f/gcc%2Fcppinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppinit.c?ref=f8f769ea4e694c516b9631ae8f2215cc6d5fb96f", "patch": "@@ -670,7 +670,7 @@ initialize_builtins (pfile)\n {\n   const struct builtin *b;\n   const U_CHAR *val;\n-  HASHNODE *hp;\n+  cpp_hashnode *hp;\n   for(b = builtin_array; b < builtin_array_end; b++)\n     {\n       if (b->type == T_STDC && CPP_TRADITIONAL (pfile))\n@@ -686,7 +686,7 @@ initialize_builtins (pfile)\n       else\n \tval = b->value;\n \n-      hp = _cpp_lookup (pfile, b->name, b->len);\n+      hp = cpp_lookup (pfile, b->name, b->len);\n       hp->value.cpval = val;\n       hp->type = b->type;\n \n@@ -1252,6 +1252,7 @@ handle_option (pfile, argc, argv)\n      char **argv;\n {\n   int i = 0;\n+  struct cpp_pending *pend = CPP_OPTION (pfile, pending);\n \n   if (argv[i][0] != '-')\n     {\n@@ -1354,7 +1355,7 @@ handle_option (pfile, argc, argv)\n \t  CPP_OPTION (pfile, print_include_names) = 1;\n \t  break;\n \tcase OPT_D:\n-\t  new_pending_directive (CPP_OPTION (pfile, pending), arg, cpp_define);\n+\t  new_pending_directive (pend, arg, cpp_define);\n \t  break;\n \tcase OPT_pedantic_errors:\n \t  CPP_OPTION (pfile, pedantic_errors) = 1;\n@@ -1396,30 +1397,37 @@ handle_option (pfile, argc, argv)\n \t  CPP_OPTION (pfile, c99) = 0;\n \t  CPP_OPTION (pfile, objc) = 0;\n \t  CPP_OPTION (pfile, trigraphs) = 1;\n-\t  new_pending_directive (CPP_OPTION (pfile, pending),\n-\t\t\t\t \"__STRICT_ANSI__\", cpp_define);\n+\t  new_pending_directive (pend, \"__STRICT_ANSI__\", cpp_define);\n \t  break;\n \tcase OPT_lang_cplusplus:\n \t  CPP_OPTION (pfile, cplusplus) = 1;\n \t  CPP_OPTION (pfile, cplusplus_comments) = 1;\n \t  CPP_OPTION (pfile, c89) = 0;\n \t  CPP_OPTION (pfile, c99) = 0;\n \t  CPP_OPTION (pfile, objc) = 0;\n+\t  new_pending_directive (pend, \"__cplusplus\", cpp_define);\n \t  break;\n-\tcase OPT_lang_objc:\n \tcase OPT_lang_objcplusplus:\n-\t  CPP_OPTION (pfile, cplusplus) = opt_code == OPT_lang_objcplusplus;\n+\t  CPP_OPTION (pfile, cplusplus) = 1;\n+\t  new_pending_directive (pend, \"__cplusplus\", cpp_define);\n+\t  /* fall through */\n+\tcase OPT_lang_objc:\n \t  CPP_OPTION (pfile, cplusplus_comments) = 1;\n \t  CPP_OPTION (pfile, c89) = 0;\n \t  CPP_OPTION (pfile, c99) = 0;\n \t  CPP_OPTION (pfile, objc) = 1;\n+\t  new_pending_directive (pend, \"__OBJC__\", cpp_define);\n \t  break;\n \tcase OPT_lang_asm:\n  \t  CPP_OPTION (pfile, lang_asm) = 1;\n+\t  CPP_OPTION (pfile, dollars_in_ident) = 0;\n+\t  new_pending_directive (pend, \"__ASSEMBLER__\", cpp_define);\n \t  break;\n \tcase OPT_lang_fortran:\n  \t  CPP_OPTION (pfile, lang_fortran) = 1;\n+\t  CPP_OPTION (pfile, traditional) = 1;\n \t  CPP_OPTION (pfile, cplusplus_comments) = 0;\n+\t  new_pending_directive (pend, \"_LANGUAGE_FORTRAN\", cpp_define);\n \t  break;\n \tcase OPT_lang_chill:\n \t  CPP_OPTION (pfile, objc) = 0;"}, {"sha": "4708382d15825d4ab46847f116debe22869bb22a", "filename": "gcc/cpplex.c", "status": "modified", "additions": 115, "deletions": 184, "changes": 299, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8f769ea4e694c516b9631ae8f2215cc6d5fb96f/gcc%2Fcpplex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8f769ea4e694c516b9631ae8f2215cc6d5fb96f/gcc%2Fcpplex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplex.c?ref=f8f769ea4e694c516b9631ae8f2215cc6d5fb96f", "patch": "@@ -26,6 +26,10 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n #include \"cpplib.h\"\n #include \"cpphash.h\"\n \n+#ifdef HAVE_MMAP_FILE\n+# include <sys/mman.h>\n+#endif\n+\n #define PEEKBUF(BUFFER, N) \\\n   ((BUFFER)->rlimit - (BUFFER)->cur > (N) ? (BUFFER)->cur[N] : EOF)\n #define GETBUF(BUFFER) \\\n@@ -224,7 +228,7 @@ cpp_pop_buffer (pfile)\n     }\n   else if (buf->macro)\n     {\n-      HASHNODE *m = buf->macro;\n+      cpp_hashnode *m = buf->macro;\n   \n       m->disabled = 0;\n       if ((m->type == T_FMACRO && buf->mapped)\n@@ -1622,9 +1626,9 @@ maybe_macroexpand (pfile, written)\n {\n   U_CHAR *macro = pfile->token_buffer + written;\n   size_t len = CPP_WRITTEN (pfile) - written;\n-  HASHNODE *hp = _cpp_lookup (pfile, macro, len);\n+  cpp_hashnode *hp = cpp_lookup (pfile, macro, len);\n \n-  /* _cpp_lookup never returns null.  */\n+  /* cpp_lookup never returns null.  */\n   if (hp->type == T_VOID)\n     return 0;\n   if (hp->disabled || hp->type == T_IDENTITY)\n@@ -1892,14 +1896,10 @@ find_position (start, limit, linep)\n   return lbase;\n }\n \n-/* The following table is used by _cpp_read_and_prescan.  If we have\n+/* The following table is used by _cpp_prescan.  If we have\n    designated initializers, it can be constant data; otherwise, it is\n    set up at runtime by _cpp_init_input_buffer.  */\n \n-#ifndef UCHAR_MAX\n-#define UCHAR_MAX 255\t/* assume 8-bit bytes */\n-#endif\n-\n #if (GCC_VERSION >= 2007)\n #define init_chartab()  /* nothing */\n #define CHARTAB __extension__ static const U_CHAR chartab[UCHAR_MAX + 1] = {\n@@ -1937,9 +1937,10 @@ END\n #define NORMAL(c) ((chartab[c]) == 0 || (chartab[c]) > SPECCASE_QUESTION)\n #define NONTRI(c) ((c) <= SPECCASE_QUESTION)\n \n-/* Read the entire contents of file DESC into buffer BUF.  LEN is how\n-   much memory to allocate initially; more will be allocated if\n-   necessary.  Convert end-of-line markers (\\n, \\r, \\r\\n, \\n\\r) to\n+/* Prescan pass over a file already loaded into BUF.  This is\n+   translation phases 1 and 2 (C99 5.1.1.2).\n+\n+   Convert end-of-line markers (\\n, \\r, \\r\\n, \\n\\r) to\n    canonical form (\\n).  If enabled, convert and/or warn about\n    trigraphs.  Convert backslash-newline to a one-character escape\n    (\\r) and remove it from \"embarrassing\" places (i.e. the middle of a\n@@ -1960,235 +1961,165 @@ END\n    at the end of reload1.c is about 60%.  (reload1.c is 329k.)\n \n    If your file has more than one kind of end-of-line marker, you\n-   will get messed-up line numbering.\n-   \n-   So that the cases of the switch statement do not have to concern\n-   themselves with the complications of reading beyond the end of the\n-   buffer, the buffer is guaranteed to have at least 3 characters in\n-   it (or however many are left in the file, if less) on entry to the\n-   switch.  This is enough to handle trigraphs and the \"\\\\\\n\\r\" and\n-   \"\\\\\\r\\n\" cases.\n-   \n-   The end of the buffer is marked by a '\\\\', which, being a special\n-   character, guarantees we will exit the fast-scan loops and perform\n-   a refill. */\n- \n-long\n-_cpp_read_and_prescan (pfile, fp, desc, len)\n+   will get messed-up line numbering.  */\n+\n+ssize_t\n+_cpp_prescan (pfile, fp, len)\n      cpp_reader *pfile;\n      cpp_buffer *fp;\n-     int desc;\n-     size_t len;\n+     ssize_t len;\n {\n-  U_CHAR *buf = (U_CHAR *) xmalloc (len);\n-  U_CHAR *ip, *op, *line_base;\n-  U_CHAR *ibase;\n+  U_CHAR *buf, *op;\n+  const U_CHAR *ibase, *ip, *ilimit;\n+  U_CHAR *line_base;\n   unsigned long line;\n   unsigned int deferred_newlines;\n-  size_t offset;\n-  int count = 0;\n \n-  offset = 0;\n-  deferred_newlines = 0;\n-  op = buf;\n-  line_base = buf;\n+  /* Allocate an extra byte in case we must add a trailing \\n.  */\n+  buf = (U_CHAR *) xmalloc (len + 1);\n+  line_base = op = buf;\n+  ip = ibase = fp->buf;\n+  ilimit = ibase + len;\n   line = 1;\n-  ibase = pfile->input_buffer + 3;\n-  ip = ibase;\n-  ip[-1] = '\\0';  /* Guarantee no match with \\n for SPECCASE_CR */\n+  deferred_newlines = 0;\n \n   for (;;)\n     {\n-      U_CHAR *near_buff_end;\n+      const U_CHAR *iq;\n \n-      count = read (desc, ibase, pfile->input_buffer_len);\n-      if (count < 0)\n-\tgoto error;\n-      \n-      ibase[count] = '\\\\';  /* Marks end of buffer */\n-      if (count)\n+      /* Deal with \\-newline, potentially in the middle of a token. */\n+      if (deferred_newlines)\n \t{\n-\t  near_buff_end = pfile->input_buffer + count;\n-\t  offset += count;\n-\t  if (offset > len)\n+\t  if (op != buf && ! is_space (op[-1]) && op[-1] != '\\r')\n \t    {\n-\t      size_t delta_op;\n-\t      size_t delta_line_base;\n-\t      len = offset * 2;\n-\t      if (offset > len)\n-\t\t/* len overflowed.\n-\t\t   This could happen if the file is larger than half the\n-\t\t   maximum address space of the machine. */\n-\t\tgoto too_big;\n-\n-\t      delta_op = op - buf;\n-\t      delta_line_base = line_base - buf;\n-\t      buf = (U_CHAR *) xrealloc (buf, len);\n-\t      op = buf + delta_op;\n-\t      line_base = buf + delta_line_base;\n+\t      /* Previous was not white space.  Skip to white\n+\t\t space, if we can, before outputting the \\r's */\n+\t      iq = ip;\n+\t      while (iq < ilimit\n+\t\t     && *iq != ' '\n+\t\t     && *iq != '\\t'\n+\t\t     && *iq != '\\n'\n+\t\t     && NORMAL(*iq))\n+\t\tiq++;\n+\t      memcpy (op, ip, iq - ip);\n+\t      op += iq - ip;\n+\t      ip += iq - ip;\n+\t      if (! NORMAL(*ip))\n+\t\tgoto do_speccase;\n \t    }\n-\t}\n-      else\n-\t{\n-\t  if (ip == ibase)\n-\t    break;\n-\t  /* Allow normal processing of the (at most 2) remaining\n-\t     characters.  The end-of-buffer marker is still present\n-\t     and prevents false matches within the switch. */\n-\t  near_buff_end = ibase - 1;\n+\t  while (deferred_newlines)\n+\t    deferred_newlines--, *op++ = '\\r';\n \t}\n \n-      for (;;)\n-\t{\n-\t  unsigned int span;\n+      /* Copy as much as we can without special treatment. */\n+      iq = ip;\n+      while (iq < ilimit && NORMAL (*iq)) iq++;\n+      memcpy (op, ip, iq - ip);\n+      op += iq - ip;\n+      ip += iq - ip;\n \n-\t  /* Deal with \\-newline, potentially in the middle of a token. */\n-\t  if (deferred_newlines)\n+    do_speccase:\n+      if (ip >= ilimit)\n+\tbreak;\n+\n+      switch (chartab[*ip++])\n+\t{\n+\tcase SPECCASE_CR:  /* \\r */\n+\t  if (ip[-2] != '\\n')\n \t    {\n-\t      if (op != buf && ! is_space (op[-1]) && op[-1] != '\\r')\n-\t\t{\n-\t\t  /* Previous was not white space.  Skip to white\n-\t\t     space, if we can, before outputting the \\r's */\n-\t\t  span = 0;\n-\t\t  while (ip[span] != ' '\n-\t\t\t && ip[span] != '\\t'\n-\t\t\t && ip[span] != '\\n'\n-\t\t\t && NORMAL(ip[span]))\n-\t\t    span++;\n-\t\t  memcpy (op, ip, span);\n-\t\t  op += span;\n-\t\t  ip += span;\n-\t\t  if (! NORMAL(ip[0]))\n-\t\t    goto do_speccase;\n-\t\t}\n-\t      while (deferred_newlines)\n-\t\tdeferred_newlines--, *op++ = '\\r';\n+\t      if (ip < ilimit && *ip == '\\n')\n+\t\tip++;\n+\t      *op++ = '\\n';\n \t    }\n+\t  break;\n \n-\t  /* Copy as much as we can without special treatment. */\n-\t  span = 0;\n-\t  while (NORMAL (ip[span])) span++;\n-\t  memcpy (op, ip, span);\n-\t  op += span;\n-\t  ip += span;\n-\n-\tdo_speccase:\n-\t  if (ip > near_buff_end) /* Do we have enough chars? */\n-\t    break;\n-\t  switch (chartab[*ip++])\n+\tcase SPECCASE_BACKSLASH:  /* \\ */\n+\tbackslash:\n+\t  if (ip < ilimit)\n \t    {\n-\t    case SPECCASE_CR:  /* \\r */\n-\t      if (ip[-2] != '\\n')\n-\t\t{\n-\t\t  if (*ip == '\\n')\n-\t\t    ip++;\n-\t\t  *op++ = '\\n';\n-\t\t}\n-\t      break;\n-\n-\t    case SPECCASE_BACKSLASH:  /* \\ */\n \t      if (*ip == '\\n')\n \t\t{\n \t\t  deferred_newlines++;\n \t\t  ip++;\n \t\t  if (*ip == '\\r') ip++;\n+\t\t  break;\n \t\t}\n \t      else if (*ip == '\\r')\n \t\t{\n \t\t  deferred_newlines++;\n \t\t  ip++;\n \t\t  if (*ip == '\\n') ip++;\n+\t\t  break;\n \t\t}\n-\t      else\n-\t\t*op++ = '\\\\';\n-\t      break;\n+\t    }\n \n-\t    case SPECCASE_QUESTION: /* ? */\n-\t      {\n-\t\tunsigned int d, t;\n+\t  *op++ = '\\\\';\n+\t  break;\n \n-\t\t*op++ = '?'; /* Normal non-trigraph case */\n-\t\tif (ip[0] != '?')\n-\t\t  break;\n-\t\t    \n-\t\td = ip[1];\n-\t\tt = chartab[d];\n-\t\tif (NONTRI (t))\n-\t\t  break;\n+\tcase SPECCASE_QUESTION: /* ? */\n+\t  {\n+\t    unsigned int d, t;\n \n-\t\tif (CPP_OPTION (pfile, warn_trigraphs))\n-\t\t  {\n-\t\t    unsigned long col;\n-\t\t    line_base = find_position (line_base, op, &line);\n-\t\t    col = op - line_base + 1;\n-\t\t    if (CPP_OPTION (pfile, trigraphs))\n-\t\t      cpp_warning_with_line (pfile, line, col,\n-\t\t\t\t\t     \"trigraph ??%c converted to %c\", d, t);\n-\t\t    else\n-\t\t      cpp_warning_with_line (pfile, line, col,\n-\t\t\t\t\t     \"trigraph ??%c ignored\", d);\n-\t\t  }\n+\t    *op++ = '?'; /* Normal non-trigraph case */\n+\t    if (ip > ilimit - 2 || ip[0] != '?')\n+\t      break;\n+\t\t    \n+\t    d = ip[1];\n+\t    t = chartab[d];\n+\t    if (NONTRI (t))\n+\t      break;\n \n-\t\tip += 2;\n+\t    if (CPP_OPTION (pfile, warn_trigraphs))\n+\t      {\n+\t\tunsigned long col;\n+\t\tline_base = find_position (line_base, op, &line);\n+\t\tcol = op - line_base + 1;\n \t\tif (CPP_OPTION (pfile, trigraphs))\n-\t\t  {\n-\t\t    op[-1] = t;\t    /* Overwrite '?' */\n-\t\t    if (t == '\\\\')\n-\t\t      {\n-\t\t\top--;\n-\t\t\t*--ip = '\\\\';\n-\t\t\tgoto do_speccase; /* May need buffer refill */\n-\t\t      }\n-\t\t  }\n+\t\t  cpp_warning_with_line (pfile, line, col,\n+\t\t\t\t\t \"trigraph ??%c converted to %c\", d, t);\n \t\telse\n+\t\t  cpp_warning_with_line (pfile, line, col,\n+\t\t\t\t\t \"trigraph ??%c ignored\", d);\n+\t      }\n+\n+\t    ip += 2;\n+\t    if (CPP_OPTION (pfile, trigraphs))\n+\t      {\n+\t\top[-1] = t;\t    /* Overwrite '?' */\n+\t\tif (t == '\\\\')\n \t\t  {\n-\t\t    *op++ = '?';\n-\t\t    *op++ = d;\n+\t\t    op--;\n+\t\t    goto backslash;\n \t\t  }\n \t      }\n-\t      break;\n-\t    }\n+\t    else\n+\t      {\n+\t\t*op++ = '?';\n+\t\t*op++ = d;\n+\t      }\n+\t  }\n+\t  break;\n \t}\n-      /* Copy previous char plus unprocessed (at most 2) chars\n-\t to beginning of buffer, refill it with another\n-\t read(), and continue processing */\n-      memmove (ip - count - 1, ip - 1, 4 - (ip - near_buff_end));\n-      ip -= count;\n     }\n \n-  if (offset == 0)\n-    return 0;\n+#ifdef HAVE_MMAP_FILE\n+  if (fp->mapped)\n+    munmap ((caddr_t) fp->buf, len);\n+  else\n+#endif\n+    free ((PTR) fp->buf);\n \n   if (op[-1] != '\\n')\n     {\n       unsigned long col;\n       line_base = find_position (line_base, op, &line);\n       col = op - line_base + 1;\n       cpp_warning_with_line (pfile, line, col, \"no newline at end of file\");\n-      if (offset + 1 > len)\n-\t{\n-\t  len += 1;\n-\t  if (offset + 1 > len)\n-\t    goto too_big;\n-\t  buf = (U_CHAR *) xrealloc (buf, len);\n-\t  op = buf + offset;\n-\t}\n       *op++ = '\\n';\n     }\n \n-  fp->buf = ((len - offset < 20) ? buf : (U_CHAR *)xrealloc (buf, op - buf));\n+  fp->buf = buf;\n   return op - buf;\n-\n- too_big:\n-  cpp_notice (pfile, \"%s is too large (>%lu bytes)\", fp->ihash->name,\n-\t      (unsigned long)offset);\n-  free (buf);\n-  return -1;\n-\n- error:\n-  cpp_error_from_errno (pfile, fp->ihash->name);\n-  free (buf);\n-  return -1;\n }\n \n /* Allocate pfile->input_buffer, and initialize chartab[]"}, {"sha": "6cc99ec7eaacfb3af81812e7dcec1fa68d2bce71", "filename": "gcc/cpplib.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8f769ea4e694c516b9631ae8f2215cc6d5fb96f/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8f769ea4e694c516b9631ae8f2215cc6d5fb96f/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=f8f769ea4e694c516b9631ae8f2215cc6d5fb96f", "patch": "@@ -339,7 +339,7 @@ static int\n do_define (pfile)\n      cpp_reader *pfile;\n {\n-  HASHNODE *node;\n+  cpp_hashnode *node;\n   int len;\n   const U_CHAR *sym;\n   cpp_toklist *list = &pfile->directbuf;\n@@ -371,7 +371,7 @@ do_define (pfile)\n       goto out;\n     }\n \n-  node = _cpp_lookup (pfile, sym, len);\n+  node = cpp_lookup (pfile, sym, len);\n   /* Check for poisoned identifiers now.  All other checks\n      are done in cpphash.c.  */\n   if (node->type == T_POISON)\n@@ -681,7 +681,7 @@ do_undef (pfile)\n      cpp_reader *pfile;\n {\n   int len;\n-  HASHNODE *hp;\n+  cpp_hashnode *hp;\n   U_CHAR *name;\n   long here = CPP_WRITTEN (pfile);\n   enum cpp_ttype token;\n@@ -708,7 +708,7 @@ do_undef (pfile)\n   name = pfile->token_buffer + here;\n   CPP_SET_WRITTEN (pfile, here);\n \n-  hp = _cpp_lookup (pfile, name, len);\n+  hp = cpp_lookup (pfile, name, len);\n   if (hp->type == T_VOID)\n     ; /* Not defined in the first place - do nothing.  */\n   else if (hp->type == T_POISON)\n@@ -941,7 +941,7 @@ do_pragma_poison (pfile)\n   /* Poison these symbols so that all subsequent usage produces an\n      error message.  */\n   U_CHAR *p;\n-  HASHNODE *hp;\n+  cpp_hashnode *hp;\n   long written;\n   size_t len;\n   enum cpp_ttype token;\n@@ -968,7 +968,7 @@ do_pragma_poison (pfile)\n \n       p = pfile->token_buffer + written;\n       len = CPP_PWRITTEN (pfile) - p;\n-      hp = _cpp_lookup (pfile, p, len);\n+      hp = cpp_lookup (pfile, p, len);\n       if (hp->type == T_POISON)\n \t;  /* It is allowed to poison the same identifier twice.  */\n       else\n@@ -1528,7 +1528,7 @@ do_assert (pfile)\n   long old_written;\n   U_CHAR *sym;\n   size_t len;\n-  HASHNODE *hp;\n+  cpp_hashnode *hp;\n   struct predicate *pred = 0;\n   enum cpp_ttype type;\n \n@@ -1544,7 +1544,7 @@ do_assert (pfile)\n \n   sym = pfile->token_buffer + old_written;\n   len = CPP_WRITTEN (pfile) - old_written;\n-  hp = _cpp_lookup (pfile, sym, len);\n+  hp = cpp_lookup (pfile, sym, len);\n \n   if (_cpp_get_directive_token (pfile) != CPP_OPEN_PAREN)\n     ERROR (\"missing token-sequence in #assert\");\n@@ -1606,7 +1606,7 @@ do_unassert (pfile)\n   long old_written;\n   U_CHAR *sym;\n   size_t len;\n-  HASHNODE *hp;\n+  cpp_hashnode *hp;\n   cpp_toklist ans;\n   enum cpp_ttype type;\n   int specific = 0;\n@@ -1620,7 +1620,7 @@ do_unassert (pfile)\n \n   sym = pfile->token_buffer + old_written;\n   len = CPP_WRITTEN (pfile) - old_written;\n-  hp = _cpp_lookup (pfile, sym, len);\n+  hp = cpp_lookup (pfile, sym, len);\n \n   type = _cpp_get_directive_token (pfile);\n   if (type == CPP_OPEN_PAREN)\n@@ -1784,7 +1784,7 @@ cpp_defined (pfile, id, len)\n      const U_CHAR *id;\n      int len;\n {\n-  HASHNODE *hp = _cpp_lookup (pfile, id, len);\n+  cpp_hashnode *hp = cpp_lookup (pfile, id, len);\n   if (hp->type == T_POISON)\n     {\n       cpp_error (pfile, \"attempt to use poisoned `%s'\", hp->name);"}, {"sha": "0ac5c271ea6a948df1c567d47f47fd834c59f840", "filename": "gcc/cpplib.h", "status": "modified", "additions": 59, "deletions": 1, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8f769ea4e694c516b9631ae8f2215cc6d5fb96f/gcc%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8f769ea4e694c516b9631ae8f2215cc6d5fb96f/gcc%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.h?ref=f8f769ea4e694c516b9631ae8f2215cc6d5fb96f", "patch": "@@ -35,6 +35,7 @@ typedef struct cpp_printer cpp_printer;\n typedef struct cpp_token cpp_token;\n typedef struct cpp_toklist cpp_toklist;\n typedef struct cpp_name cpp_name;\n+typedef struct cpp_hashnode cpp_hashnode;\n \n /* The first two groups, apart from '=', can appear in preprocessor\n    expressions.  This allows a lookup table to be implemented in\n@@ -238,7 +239,7 @@ struct cpp_buffer\n \n   /* If the buffer is the expansion of a macro, this points to the\n      macro's hash table entry.  */\n-  struct hashnode *macro;\n+  struct cpp_hashnode *macro;\n \n   /* Value of if_stack at start of this file.\n      Used to prohibit unmatched #endif (etc) in an include file.  */\n@@ -590,6 +591,61 @@ struct cpp_printer\n /* Name under which this program was invoked.  */\n extern const char *progname;\n \n+/* The structure of a node in the hash table.  The hash table\n+   has entries for all tokens defined by #define commands (type T_MACRO),\n+   plus some special tokens like __LINE__ (these each have their own\n+   type, and the appropriate code is run when that type of node is seen.\n+   It does not contain control words like \"#define\", which are recognized\n+   by a separate piece of code. */\n+\n+/* different flavors of hash nodes */\n+enum node_type\n+{\n+  T_VOID = 0,\t   /* no definition yet */\n+  T_SPECLINE,\t   /* `__LINE__' */\n+  T_DATE,\t   /* `__DATE__' */\n+  T_FILE,\t   /* `__FILE__' */\n+  T_BASE_FILE,\t   /* `__BASE_FILE__' */\n+  T_INCLUDE_LEVEL, /* `__INCLUDE_LEVEL__' */\n+  T_TIME,\t   /* `__TIME__' */\n+  T_STDC,\t   /* `__STDC__' */\n+  T_CONST,\t   /* Constant string, used by `__SIZE_TYPE__' etc */\n+  T_XCONST,\t   /* Ditto, but the string is malloced memory */\n+  T_POISON,\t   /* poisoned identifier */\n+  T_MACRO,\t   /* object-like macro */\n+  T_FMACRO,\t   /* function-like macro */\n+  T_IDENTITY,\t   /* macro defined to itself */\n+  T_EMPTY,\t   /* macro defined to nothing */\n+  T_ASSERTION\t   /* predicate for #assert */\n+};\n+\n+/* There is a slot in the hashnode for use by front ends when integrated\n+   with cpplib.  It holds a tree (see tree.h) but we mustn't drag that\n+   header into every user of cpplib.h.  cpplib does not do anything with\n+   this slot except clear it when a new node is created.  */\n+union tree_node;\n+\n+struct cpp_hashnode\n+{\n+  unsigned int hash;\t\t\t/* cached hash value */\n+  unsigned short length;\t\t/* length of name */\n+  ENUM_BITFIELD(node_type) type : 8;\t/* node type */\n+  char disabled;\t\t\t/* macro turned off for rescan? */\n+\n+  union {\n+    const unsigned char *cpval;\t\t/* some predefined macros */\n+    const struct object_defn *odefn;\t/* #define foo bar */\n+    const struct funct_defn *fdefn;\t/* #define foo(x) bar(x) */\n+    struct predicate *pred;\t\t/* #assert */\n+  } value;\n+\n+  union tree_node *fe_value;\t\t/* front end value */\n+\n+  const unsigned char name[1];\t\t/* name[length] */\n+};\n+\n+\n+\n extern void _cpp_lex_file PARAMS((cpp_reader *));\n extern int cpp_handle_options PARAMS ((cpp_reader *, int, char **));\n extern enum cpp_ttype cpp_get_token PARAMS ((cpp_reader *));\n@@ -653,6 +709,8 @@ extern int cpp_idcmp\t\t\tPARAMS ((const unsigned char *,\n /* In cpphash.c */\n extern int cpp_defined\t\t\tPARAMS ((cpp_reader *,\n \t\t\t\t\t\t const unsigned char *, int));\n+extern cpp_hashnode *cpp_lookup\t\tPARAMS ((cpp_reader *,\n+\t\t\t\t\t\t const unsigned char *, int));\n \n /* In cppfiles.c */\n extern int cpp_included\t\t\tPARAMS ((cpp_reader *, const char *));"}]}