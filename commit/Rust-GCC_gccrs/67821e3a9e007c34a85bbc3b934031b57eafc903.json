{"sha": "67821e3a9e007c34a85bbc3b934031b57eafc903", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Njc4MjFlM2E5ZTAwN2MzNGE4NWJiYzNiOTM0MDMxYjU3ZWFmYzkwMw==", "commit": {"author": {"name": "Neil Booth", "email": "neil@daikokuya.demon.co.uk", "date": "2001-08-05T17:31:25Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2001-08-05T17:31:25Z"}, "message": "re PR preprocessor/3081 (Preprocessor merges 2 first lines when -imacros is being used)\n\n\tPR preprocessor/3081\n\t* c-lex.c (map): New.\n\t(cb_file_change): Update map and use it.\n\t(cb_def_pragma, cb_define, cb_undef): Use map and line.\n\t(c_lex): Update to use map.\n\t* cpperror.c (print_location): Move to using logical line numbers.\n\t* cppfiles.c (stack_include_file): Update for new _cpp_do_file_change.\n\t(cpp_make_system_header): Similarly.\n\t(_cpp_execute_include): Stop line numbering hacks.  Store the\n\tline we will return to.\n\t* cpphash.h (CPP_BUF_LINE): Remove.\n\t(struct cpp_buffer): Remove lineno and pseudo_newlines.\n\tAdd map and return_to_line.\n\t(_cpp_do_file_change): Update.\n\t* cppinit.c (cpp_start_read): Update line kludge.\n\t* cpplex.c (handle_newline): Don't update lineno and pseudo_newlines.\n\t(trigraph_ok): Use logical line numbers for diagnostics.\n\t(skip_block_comment): Likewise.\n\t(skip_whitespace): Likewise.\n\t(skip_line_comment): Use pfile->line instead.\n\t(_cpp_lex_token): Update to use logical line numbering exclusively.\n\tHandle BOL locally.  Accept new lines in directives, but keep\n\tpfile->line decremented.  Diagnostics use logical lines.  Update\n\tdirective handling.\n\t* cpplib.c (SEEN_EOL): New.\n\t(skip_rest_of_line, check_eol): Use it.\n\t(end_directive): Increase line number when accepting the newline\n\tat the end of a directive.\n\t(run_directive): Simplify.\n\t(do_line): Bad LC_LEAVEs become LC_RENAMEs.  Update.\n\t(_cpp_do_file_change): Update to take buffer line number as an\n\targument, and store the current map in the cpp_reader.  Remove\n\tline number kludges.\n\t(_cpp_do__Pragma): Restore output position after a _Pragma.\n\t(cpp_push_buffer): Don't set output line or lineno.\n\t(_cpp_pop_buffer): Transfer more info from a faked buffer.\n\tRemove line kludge.  Set output_line.\n\t* cppmacro.c (builtin_macro): Update handling of __LINE__.\n\t(parse_arg): Use logical lines.\n\t(save_lookahead_token): Save EOFs too now.\n\t* cppmain.c (struct printer): Fix comments.\n\t(printer_init): Simplify, let caller do errors.\n\t(scan_translation_unit, check_multiline_token, dump_macro): Update.\n\t(maybe_print_line): Simplify.\n\t(print_line): Don't print a linemarker if -P.\n\t(cb_define, cb_undef, cb_def_pragma, cb_ident, cb_include): Update.\n\t(cb_file_change): Simplify.\n\t* line-map.h (LAST_SOURCE_LINE): Fix.\n\t(CURRENT_LINE_MAP): New.\n\n\t* gcc.dg/cpp/19951025-1.c: Revert.\n\t* gcc.dg/cpp/directiv.c: We no longer process directives that\n\tinterrupt macro arguments.\n\nFrom-SVN: r44650", "tree": {"sha": "37a35ef3c394621edd2c84f886dcc1310e94c38d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/37a35ef3c394621edd2c84f886dcc1310e94c38d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/67821e3a9e007c34a85bbc3b934031b57eafc903", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/67821e3a9e007c34a85bbc3b934031b57eafc903", "html_url": "https://github.com/Rust-GCC/gccrs/commit/67821e3a9e007c34a85bbc3b934031b57eafc903", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/67821e3a9e007c34a85bbc3b934031b57eafc903/comments", "author": null, "committer": null, "parents": [{"sha": "8125d7e9ad4f1525e0e703f7610fd47cc628f047", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8125d7e9ad4f1525e0e703f7610fd47cc628f047", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8125d7e9ad4f1525e0e703f7610fd47cc628f047"}], "stats": {"total": 548, "additions": 296, "deletions": 252}, "files": [{"sha": "70f07e38545819c9ff8d834d85dbb5d453f3110b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67821e3a9e007c34a85bbc3b934031b57eafc903/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67821e3a9e007c34a85bbc3b934031b57eafc903/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=67821e3a9e007c34a85bbc3b934031b57eafc903", "patch": "@@ -1,3 +1,55 @@\n+2001-08-05  Neil Booth  <neil@daikokuya.demon.co.uk>\n+\n+\tPR preprocessor/3081\n+\t* c-lex.c (map): New.\n+\t(cb_file_change): Update map and use it.\n+\t(cb_def_pragma, cb_define, cb_undef): Use map and line.\n+\t(c_lex): Update to use map.\n+\t* cpperror.c (print_location): Move to using logical line numbers.\n+\t* cppfiles.c (stack_include_file): Update for new _cpp_do_file_change.\n+\t(cpp_make_system_header): Similarly.\n+\t(_cpp_execute_include): Stop line numbering hacks.  Store the\n+\tline we will return to.\n+\t* cpphash.h (CPP_BUF_LINE): Remove.\n+\t(struct cpp_buffer): Remove lineno and pseudo_newlines.\n+\tAdd map and return_to_line.\n+\t(_cpp_do_file_change): Update.\n+\t* cppinit.c (cpp_start_read): Update line kludge.\n+\t* cpplex.c (handle_newline): Don't update lineno and pseudo_newlines.\n+\t(trigraph_ok): Use logical line numbers for diagnostics.\n+\t(skip_block_comment): Likewise.\n+\t(skip_whitespace): Likewise.\n+\t(skip_line_comment): Use pfile->line instead.\n+\t(_cpp_lex_token): Update to use logical line numbering exclusively.\n+\tHandle BOL locally.  Accept new lines in directives, but keep\n+\tpfile->line decremented.  Diagnostics use logical lines.  Update\n+\tdirective handling.\n+\t* cpplib.c (SEEN_EOL): New.\n+\t(skip_rest_of_line, check_eol): Use it.\n+\t(end_directive): Increase line number when accepting the newline\n+\tat the end of a directive.\n+\t(run_directive): Simplify.\n+\t(do_line): Bad LC_LEAVEs become LC_RENAMEs.  Update.\n+\t(_cpp_do_file_change): Update to take buffer line number as an\n+\targument, and store the current map in the cpp_reader.  Remove\n+\tline number kludges.\n+\t(_cpp_do__Pragma): Restore output position after a _Pragma.\n+\t(cpp_push_buffer): Don't set output line or lineno.\n+\t(_cpp_pop_buffer): Transfer more info from a faked buffer.\n+\tRemove line kludge.  Set output_line.\n+\t* cppmacro.c (builtin_macro): Update handling of __LINE__.\n+\t(parse_arg): Use logical lines.\n+\t(save_lookahead_token): Save EOFs too now.\n+\t* cppmain.c (struct printer): Fix comments.\n+\t(printer_init): Simplify, let caller do errors.\n+\t(scan_translation_unit, check_multiline_token, dump_macro): Update.\n+\t(maybe_print_line): Simplify.\n+\t(print_line): Don't print a linemarker if -P.\n+\t(cb_define, cb_undef, cb_def_pragma, cb_ident, cb_include): Update.\n+\t(cb_file_change): Simplify.\n+\t* line-map.h (LAST_SOURCE_LINE): Fix.\n+\t(CURRENT_LINE_MAP): New.\n+\n 2001-08-05  Bernd Schmidt  <bernds@redhat.com>\n \n \t* doloop.c (doloop_modify_runtime): Properly compute number of"}, {"sha": "971d9cd14a7e997cbbe5d0b7a93302af290ec517", "filename": "gcc/c-lex.c", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67821e3a9e007c34a85bbc3b934031b57eafc903/gcc%2Fc-lex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67821e3a9e007c34a85bbc3b934031b57eafc903/gcc%2Fc-lex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-lex.c?ref=67821e3a9e007c34a85bbc3b934031b57eafc903", "patch": "@@ -57,6 +57,9 @@ Boston, MA 02111-1307, USA.  */\n /* The input filename as understood by CPP, where \"\" represents stdin.  */\n static const char *cpp_filename;\n \n+/* The current line map.  */\n+static struct line_map *map;\n+\n /* We may keep statistics about how long which files took to compile.  */\n static int header_time, body_time;\n static splay_tree file_info_tree;\n@@ -301,9 +304,10 @@ cb_file_change (pfile, fc)\n     }\n \n   update_header_times (fc->map->to_file);\n+  map = fc->map;\n   in_system_header = fc->sysp != 0;\n-  input_filename = fc->map->to_file;\n-  lineno = SOURCE_LINE (fc->map, fc->line); /* Do we need this?  */\n+  input_filename = map->to_file;\n+  lineno = SOURCE_LINE (map, fc->line);\n \n   /* Hook for C++.  */\n   extract_interface_info ();\n@@ -312,7 +316,7 @@ cb_file_change (pfile, fc)\n static void\n cb_def_pragma (pfile, line)\n      cpp_reader *pfile;\n-     unsigned int line ATTRIBUTE_UNUSED;\n+     unsigned int line;\n {\n   /* Issue a warning message if we have been asked to do so.  Ignore\n      unknown pragmas in system headers unless an explicit\n@@ -328,7 +332,7 @@ cb_def_pragma (pfile, line)\n       if (s.type == CPP_NAME)\n \tname = cpp_token_as_text (pfile, &s);\n \n-      lineno = cpp_get_line (parse_in)->line;\n+      lineno = SOURCE_LINE (map, line);\n       if (name)\n \twarning (\"ignoring #pragma %s %s\", space, name);\n       else\n@@ -340,21 +344,21 @@ cb_def_pragma (pfile, line)\n static void\n cb_define (pfile, line, node)\n      cpp_reader *pfile;\n-     unsigned int line ATTRIBUTE_UNUSED;\n+     unsigned int line;\n      cpp_hashnode *node;\n {\n-  (*debug_hooks->define) (cpp_get_line (pfile)->line,\n+  (*debug_hooks->define) (SOURCE_LINE (map, line),\n \t\t\t  (const char *) cpp_macro_definition (pfile, node));\n }\n \n /* #undef callback for DWARF and DWARF2 debug info.  */\n static void\n cb_undef (pfile, line, node)\n-     cpp_reader *pfile;\n-     unsigned int line ATTRIBUTE_UNUSED;\n+     cpp_reader *pfile ATTRIBUTE_UNUSED;\n+     unsigned int line;\n      cpp_hashnode *node;\n {\n-  (*debug_hooks->undef) (cpp_get_line (pfile)->line,\n+  (*debug_hooks->undef) (SOURCE_LINE (map, line),\n \t\t\t (const char *) NODE_NAME (node));\n }\n \n@@ -763,7 +767,7 @@ c_lex (value)\n   /* The C++ front end does horrible things with the current line\n      number.  To ensure an accurate line number, we must reset it\n      every time we return a token.  */\n-  lineno = cpp_get_line (parse_in)->line;\n+  lineno = SOURCE_LINE (map, cpp_get_line (parse_in)->line);\n \n   *value = NULL_TREE;\n   type = tok.type;"}, {"sha": "4ed4de6273ac8fc86adfece01bcc0273593a49bc", "filename": "gcc/cpperror.c", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67821e3a9e007c34a85bbc3b934031b57eafc903/gcc%2Fcpperror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67821e3a9e007c34a85bbc3b934031b57eafc903/gcc%2Fcpperror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpperror.c?ref=67821e3a9e007c34a85bbc3b934031b57eafc903", "patch": "@@ -108,23 +108,17 @@ print_location (pfile, filename, pos)\n \t{\n \t  struct line_map *map;\n \n-\t  line = pfile->line;\n \t  if (type == BUF_PRAGMA)\n-\t    {\n-\t      buffer = buffer->prev;\n-\t      col = CPP_BUF_COL (buffer);\n-\t    }\n+\t    buffer = buffer->prev;\n \n-\t  map = lookup_line (&pfile->line_maps, line);\n \t  if (pos == 0)\n-\t    {\n-\t      pos = cpp_get_line (pfile);\n-\t      line = SOURCE_LINE (map, line);\n-\t    }\n-\t  else\n-\t    line = pos->line;\n-\t  col = pos->col;\n+\t    pos = cpp_get_line (pfile);\n+\t  map = lookup_line (&pfile->line_maps, pos->line);\n+\t  line = SOURCE_LINE (map, pos->line);\n+\t  if (filename == 0)\n+\t    filename = map->to_file;\n \n+\t  col = pos->col;\n \t  if (col == 0)\n \t    col = 1;\n "}, {"sha": "8af65c8925f19619029eccc6bfd5058c7c0ef1e9", "filename": "gcc/cppfiles.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67821e3a9e007c34a85bbc3b934031b57eafc903/gcc%2Fcppfiles.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67821e3a9e007c34a85bbc3b934031b57eafc903/gcc%2Fcppfiles.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppfiles.c?ref=67821e3a9e007c34a85bbc3b934031b57eafc903", "patch": "@@ -337,9 +337,7 @@ stack_include_file (pfile, inc)\n   pfile->include_depth++;\n \n   /* Generate the call back.  */\n-  fp->lineno = 0;\n-  _cpp_do_file_change (pfile, LC_ENTER);\n-  fp->lineno = 1;\n+  _cpp_do_file_change (pfile, LC_ENTER, 1);\n }\n \n /* Read the file referenced by INC into the file cache.\n@@ -579,7 +577,8 @@ cpp_make_system_header (pfile, syshdr, externc)\n   if (syshdr)\n     flags = 1 + (externc != 0);\n   pfile->buffer->sysp = flags;\n-  _cpp_do_file_change (pfile, LC_RENAME);\n+  _cpp_do_file_change (pfile, LC_RENAME,\n+\t\t       SOURCE_LINE (pfile->map, pfile->line));\n }\n \n /* Report on all files that might benefit from a multiple include guard.\n@@ -679,8 +678,8 @@ _cpp_execute_include (pfile, header, type)\n       if (header->type == CPP_HEADER_NAME)\n \tpfile->system_include_depth++;\n \n+      pfile->buffer->return_to_line = SOURCE_LINE (pfile->map, pfile->line);\n       stack_include_file (pfile, inc);\n-      pfile->line++;\t\t/* Fake the '\\n' at the end of #include.  */\n \n       if (type == IT_IMPORT)\n \t_cpp_never_reread (inc);"}, {"sha": "1ba4282561b857aed95211ce270c0aaf142588db", "filename": "gcc/cpphash.h", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67821e3a9e007c34a85bbc3b934031b57eafc903/gcc%2Fcpphash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67821e3a9e007c34a85bbc3b934031b57eafc903/gcc%2Fcpphash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.h?ref=67821e3a9e007c34a85bbc3b934031b57eafc903", "patch": "@@ -35,7 +35,6 @@ struct directive;\t\t/* Deliberately incomplete.  */\n \n #define CPP_OPTION(PFILE, OPTION) ((PFILE)->opts.OPTION)\n #define CPP_BUFFER(PFILE) ((PFILE)->buffer)\n-#define CPP_BUF_LINE(BUF) ((BUF)->lineno)\n #define CPP_BUF_COLUMN(BUF, CUR) ((CUR) - (BUF)->line_base + (BUF)->col_adjust)\n #define CPP_BUF_COL(BUF) CPP_BUF_COLUMN(BUF, (BUF)->cur)\n \n@@ -194,8 +193,10 @@ struct cpp_buffer\n   /* Token column position adjustment owing to tabs in whitespace.  */\n   unsigned int col_adjust;\n \n-  /* Line number at line_base (above). */\n-  unsigned int lineno;\n+  /* The line of the buffer that we return to after a #include.\n+     Strictly this is redundant, since it can be calculated from the\n+     line maps, but it is clearest to save it here.  */\n+  unsigned int return_to_line;\n \n   /* Contains PREV_WHITE and/or AVOID_LPASTE.  */\n   unsigned char saved_flags;\n@@ -251,12 +252,10 @@ struct cpp_reader\n   /* Lexer state.  */\n   struct lexer_state state;\n \n-  /* Source line tracking.  Subtract pseudo_newlines from the actual\n-     line number to get the line number of preprocessed output.  Used\n-     for escaped newlines and macro args that cross multiple lines.  */\n+  /* Source line tracking.  */\n   struct line_maps line_maps;\n+  struct line_map *map;\n   unsigned int line;\n-  unsigned int pseudo_newlines;\n \n   /* The position of the last lexed token and last lexed directive.  */\n   cpp_lexer_pos lexer_pos;\n@@ -446,7 +445,8 @@ extern void _cpp_define_builtin\tPARAMS ((cpp_reader *, const char *));\n extern void _cpp_do__Pragma\tPARAMS ((cpp_reader *));\n extern void _cpp_init_directives PARAMS ((cpp_reader *));\n extern void _cpp_init_internal_pragmas PARAMS ((cpp_reader *));\n-extern void _cpp_do_file_change PARAMS ((cpp_reader *, enum lc_reason));\n+extern void _cpp_do_file_change PARAMS ((cpp_reader *, enum lc_reason,\n+\t\t\t\t\t unsigned int));\n extern void _cpp_pop_buffer PARAMS ((cpp_reader *));\n \n /* Utility routines and macros.  */"}, {"sha": "f1b6b24f0aa9b56751f326a230ac800a9a635eff", "filename": "gcc/cppinit.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67821e3a9e007c34a85bbc3b934031b57eafc903/gcc%2Fcppinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67821e3a9e007c34a85bbc3b934031b57eafc903/gcc%2Fcppinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppinit.c?ref=67821e3a9e007c34a85bbc3b934031b57eafc903", "patch": "@@ -949,10 +949,10 @@ cpp_start_read (pfile, fname)\n       p = q;\n     }\n \n-  /* This was zero when the initial buffer was stacked; so we must\n-     make up for a non-existent new line, as well as the intervening\n-     macro definitions, by setting it to 1.  */\n-  pfile->line = 1;\n+  /* Hopefully a short-term kludge.  We stacked the main file at line\n+     zero.  The intervening macro definitions have messed up line\n+     numbering, so we need to restore it.  */\n+  pfile->lexer_pos.output_line = pfile->line = 0;\n \n   /* The -imacros files can be scanned now, but the -include files\n      have to be pushed onto the buffer stack and processed later,"}, {"sha": "f9c4bb9ab0cb040a3998fb7229a464e59e2abd7a", "filename": "gcc/cpplex.c", "status": "modified", "additions": 65, "deletions": 63, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67821e3a9e007c34a85bbc3b934031b57eafc903/gcc%2Fcpplex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67821e3a9e007c34a85bbc3b934031b57eafc903/gcc%2Fcpplex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplex.c?ref=67821e3a9e007c34a85bbc3b934031b57eafc903", "patch": "@@ -132,11 +132,8 @@ handle_newline (pfile, newline_char)\n   cppchar_t next = EOF;\n \n   pfile->line++;\n-  pfile->pseudo_newlines++;\n-\n   buffer = pfile->buffer;\n   buffer->col_adjust = 0;\n-  buffer->lineno++;\n   buffer->line_base = buffer->cur;\n \n   /* Handle CR-LF and LF-CR combinations, get the next character.  */\n@@ -173,15 +170,16 @@ trigraph_ok (pfile, from_char)\n   if (CPP_OPTION (pfile, warn_trigraphs) && !pfile->state.lexing_comment)\n     {\n       cpp_buffer *buffer = pfile->buffer;\n+\n       if (accept)\n-\tcpp_warning_with_line (pfile, buffer->lineno, CPP_BUF_COL (buffer) - 2,\n+\tcpp_warning_with_line (pfile, pfile->line, CPP_BUF_COL (buffer) - 2,\n \t\t\t       \"trigraph ??%c converted to %c\",\n \t\t\t       (int) from_char,\n \t\t\t       (int) _cpp_trigraph_map[from_char]);\n       else if (buffer->cur != buffer->last_Wtrigraphs)\n \t{\n \t  buffer->last_Wtrigraphs = buffer->cur;\n-\t  cpp_warning_with_line (pfile, buffer->lineno,\n+\t  cpp_warning_with_line (pfile, pfile->line,\n \t\t\t\t CPP_BUF_COL (buffer) - 2,\n \t\t\t\t \"trigraph ??%c ignored\", (int) from_char);\n \t}\n@@ -344,8 +342,8 @@ skip_block_comment (pfile)\n \t\t{\n \t\t  prevc = c, c = *buffer->cur++;\n \t\t  if (c != '/') \n-\t\t    cpp_warning_with_line (pfile, CPP_BUF_LINE (buffer),\n-\t\t\t\t\t   CPP_BUF_COL (buffer),\n+\t\t    cpp_warning_with_line (pfile, pfile->line,\n+\t\t\t\t\t   CPP_BUF_COL (buffer) - 2,\n \t\t\t\t\t   \"\\\"/*\\\" within comment\");\n \t\t}\n \t      goto next_char;\n@@ -373,7 +371,7 @@ skip_line_comment (pfile)\n      cpp_reader *pfile;\n {\n   cpp_buffer *buffer = pfile->buffer;\n-  unsigned int orig_lineno = buffer->lineno;\n+  unsigned int orig_line = pfile->line;\n   cppchar_t c;\n \n   pfile->state.lexing_comment = 1;\n@@ -391,7 +389,7 @@ skip_line_comment (pfile)\n \n   pfile->state.lexing_comment = 0;\n   buffer->read_ahead = c;\t/* Leave any newline for caller.  */\n-  return orig_lineno != buffer->lineno;\n+  return orig_line != pfile->line;\n }\n \n /* pfile->buffer->cur is one beyond the \\t character.  Update\n@@ -437,7 +435,7 @@ skip_whitespace (pfile, c)\n \t    }\n \t}\n       else if (pfile->state.in_directive && CPP_PEDANTIC (pfile))\n-\tcpp_pedwarn_with_line (pfile, CPP_BUF_LINE (buffer),\n+\tcpp_pedwarn_with_line (pfile, pfile->line,\n \t\t\t       CPP_BUF_COL (buffer),\n \t\t\t       \"%s in preprocessing directive\",\n \t\t\t       c == '\\f' ? \"form feed\" : \"vertical tab\");\n@@ -865,17 +863,16 @@ _cpp_lex_token (pfile, result)\n   cppchar_t c;\n   cpp_buffer *buffer;\n   const unsigned char *comment_start;\n-  unsigned char bol;\n+  int bol;\n \n- skip:\n-  bol = pfile->state.next_bol;\n- done_directive:\n+ next_token:\n   buffer = pfile->buffer;\n-  pfile->state.next_bol = 0;\n   result->flags = buffer->saved_flags;\n   buffer->saved_flags = 0;\n+  bol = (buffer->cur <= buffer->line_base + 1\n+\t && pfile->lexer_pos.output_line == pfile->line);\n  next_char:\n-  pfile->lexer_pos.line = buffer->lineno;\n+  pfile->lexer_pos.line = pfile->line;\n   result->line = pfile->line;\n  next_char2:\n   pfile->lexer_pos.col = CPP_BUF_COLUMN (buffer, buffer->cur);\n@@ -893,22 +890,29 @@ _cpp_lex_token (pfile, result)\n   switch (c)\n     {\n     case EOF:\n-      if (!pfile->state.in_directive)\n+      /* To prevent bogus diagnostics, only pop the buffer when\n+\t in-progress directives and arguments have been taken care of.\n+\t Decrement the line to terminate an in-progress directive.  */\n+      if (pfile->state.in_directive)\n+\tpfile->line--;\n+      else if (! pfile->state.parsing_args)\n \t{\n \t  unsigned char ret = pfile->buffer->return_at_eof;\n \n \t  /* Non-empty files should end in a newline.  Don't warn for\n \t     command line and _Pragma buffers.  */\n-\t  if (pfile->lexer_pos.col != 0 && !buffer->from_stage3)\n-\t    cpp_pedwarn (pfile, \"no newline at end of file\");\n-\t  _cpp_pop_buffer (pfile);\n-\t  if (pfile->buffer && !ret)\n+\t  if (pfile->lexer_pos.col != 0)\n \t    {\n-\t      bol = 1;\n-\t      goto done_directive;\n+\t      /* Account for the missing \\n.  */\n+\t      pfile->line++;\n+\t      if (!buffer->from_stage3)\n+\t\tcpp_pedwarn (pfile, \"no newline at end of file\");\n \t    }\n+\n+\t  _cpp_pop_buffer (pfile);\n+\t  if (pfile->buffer && !ret)\n+\t    goto next_token;\n \t}\n-      pfile->state.next_bol = 1;\n       result->type = CPP_EOF;\n       return;\n \n@@ -918,36 +922,41 @@ _cpp_lex_token (pfile, result)\n       goto next_char2;\n \n     case '\\n': case '\\r':\n-      if (!pfile->state.in_directive)\n+      if (pfile->state.in_directive)\n \t{\n-\t  handle_newline (pfile, c);\n-\t  if (!pfile->state.parsing_args)\n-\t    pfile->pseudo_newlines = 0;\n-\t  bol = 1;\n-\t  pfile->lexer_pos.output_line = buffer->lineno;\n-\t  /* This is a new line, so clear any white space flag.\n-\t          Newlines in arguments are white space (6.10.3.10);\n-\t\t  parse_arg takes care of that.  */\n-\t  result->flags &= ~(PREV_WHITE | AVOID_LPASTE);\n-\t  goto next_char;\n+\t  result->type = CPP_EOF;\n+\t  if (pfile->state.parsing_args)\n+\t    buffer->read_ahead = c;\n+\t  else\n+\t    {\n+\t      handle_newline (pfile, c);\n+\t      /* Decrementing pfile->line allows directives to\n+\t\t recognise that the newline has been seen, and also\n+\t\t means that diagnostics don't point to the next line.  */\n+\t      pfile->lexer_pos.output_line = pfile->line--;\n+\t    }\n+\t  return;\n \t}\n \n-      /* Don't let directives spill over to the next line.  */\n-      buffer->read_ahead = c;\n-      pfile->state.next_bol = 1;\n-      result->type = CPP_EOF;\n-      /* Don't break; pfile->state.skipping might be true.  */\n-      return;\n+      handle_newline (pfile, c);\n+      /* This is a new line, so clear any white space flag.  Newlines\n+\t in arguments are white space (6.10.3.10); parse_arg takes\n+\t care of that.  */\n+      result->flags &= ~(PREV_WHITE | AVOID_LPASTE);\n+      bol = 1;\n+      if (pfile->state.parsing_args != 2)\n+\tpfile->lexer_pos.output_line = pfile->line;\n+      goto next_char;\n \n     case '?':\n     case '\\\\':\n       /* These could start an escaped newline, or '?' a trigraph.  Let\n \t skip_escaped_newlines do all the work.  */\n       {\n-\tunsigned int lineno = buffer->lineno;\n+\tunsigned int line = pfile->line;\n \n \tc = skip_escaped_newlines (buffer, c);\n-\tif (lineno != buffer->lineno)\n+\tif (line != pfile->line)\n \t  /* We had at least one escaped newline of some sort, and the\n \t     next character is in buffer->read_ahead.  Update the\n \t     token's line and column.  */\n@@ -1026,9 +1035,7 @@ _cpp_lex_token (pfile, result)\n       if (c == '*')\n \t{\n \t  if (skip_block_comment (pfile))\n-\t    cpp_error_with_line (pfile, pfile->lexer_pos.line,\n-\t\t\t\t pfile->lexer_pos.col,\n-\t\t\t\t \"unterminated comment\");\n+\t    cpp_error (pfile, \"unterminated comment\");\n \t}\n       else\n \t{\n@@ -1212,26 +1219,21 @@ _cpp_lex_token (pfile, result)\n \t macro invocation, and proceed to process the directive.  */\n       if (pfile->state.parsing_args)\n \t{\n+\t  pfile->lexer_pos.output_line = pfile->line;\n \t  if (pfile->state.parsing_args == 2)\n-\t    cpp_error (pfile,\n-\t\t       \"directives may not be used inside a macro argument\");\n-\n-\t  /* Put a '#' in lookahead, return CPP_EOF for parse_arg.  */\n-\t  buffer->extra_char = buffer->read_ahead;\n-\t  buffer->read_ahead = '#';\n-\t  pfile->state.next_bol = 1;\n-\t  result->type = CPP_EOF;\n-\n-\t  /* Get whitespace right - newline_in_args sets it.  */\n-\t  if (pfile->lexer_pos.col == 1)\n-\t    result->flags &= ~(PREV_WHITE | AVOID_LPASTE);\n+\t    {\n+\t      cpp_error (pfile,\n+\t\t\t \"directives may not be used inside a macro argument\");\n+\t      result->type = CPP_EOF;\n+\t    }\n \t}\n-      else\n+      /* in_directive can be true inside a _Pragma.  */\n+      else if (!pfile->state.in_directive)\n \t{\n-\t  /* This is the hash introducing a directive.  */\n+\t  /* This is the hash introducing a directive.  If the return\n+\t     value is false, it is an assembler #.  */\n \t  if (_cpp_handle_directive (pfile, result->flags & PREV_WHITE))\n-\t    goto done_directive; /* bol still 1.  */\n-\t  /* This is in fact an assembler #.  */\n+\t    goto next_token;\n \t}\n       break;\n \n@@ -1283,7 +1285,7 @@ _cpp_lex_token (pfile, result)\n     }\n \n   if (!pfile->state.in_directive && pfile->state.skipping)\n-    goto skip;\n+    goto next_char;\n \n   /* If not in a directive, this token invalidates controlling macros.  */\n   if (!pfile->state.in_directive)"}, {"sha": "5932a44d1d5bc2e6a87138f37f12cf2af1151378", "filename": "gcc/cpplib.c", "status": "modified", "additions": 44, "deletions": 41, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67821e3a9e007c34a85bbc3b934031b57eafc903/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67821e3a9e007c34a85bbc3b934031b57eafc903/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=67821e3a9e007c34a85bbc3b934031b57eafc903", "patch": "@@ -178,6 +178,8 @@ DIRECTIVE_TABLE\n #undef D\n #undef DIRECTIVE_TABLE\n \n+#define SEEN_EOL() (pfile->lexer_pos.output_line > pfile->line)\n+\n /* Skip any remaining tokens in a directive.  */\n static void\n skip_rest_of_line (pfile)\n@@ -194,7 +196,7 @@ skip_rest_of_line (pfile)\n     _cpp_pop_context (pfile);\n \n   /* Sweep up all tokens remaining on the line.  */\n-  while (!pfile->state.next_bol)\n+  while (! SEEN_EOL ())\n     _cpp_lex_token (pfile, &token);\n }\n \n@@ -203,7 +205,7 @@ static void\n check_eol (pfile)\n      cpp_reader *pfile;\n {\n-  if (!pfile->state.next_bol)\n+  if (! SEEN_EOL ())\n     {\n       cpp_token token;\n \n@@ -240,7 +242,11 @@ end_directive (pfile, skip_line)\n {\n   /* We don't skip for an assembler #.  */\n   if (skip_line)\n-    skip_rest_of_line (pfile);\n+    {\n+      skip_rest_of_line (pfile);\n+      /*  \"Accept\" the newline now.  */\n+      pfile->line++;\n+    }\n \n   /* Restore state.  */\n   pfile->la_write = pfile->la_saved;\n@@ -395,19 +401,9 @@ run_directive (pfile, dir_no, type, buf, count)\n      const char *buf;\n      size_t count;\n {\n-  unsigned int output_line = pfile->lexer_pos.output_line;\n   cpp_buffer *buffer;\n \n   buffer = cpp_push_buffer (pfile, (const U_CHAR *) buf, count, type, 0, 1);\n-\n-  if (dir_no == T_PRAGMA)\n-    {\n-      /* A kludge to avoid line markers for _Pragma.  */\n-      pfile->lexer_pos.output_line = output_line;\n-      /* Avoid interpretation of directives in a _Pragma string.  */\n-      pfile->state.next_bol = 0;\n-    }\n-\n   start_directive (pfile);\n   pfile->state.prevent_expansion++;\n   pfile->directive = &dtable[dir_no];\n@@ -779,8 +775,11 @@ do_line (pfile)\n \t  else if (reason == LC_LEAVE)\n \t    {\n \t      if (buffer->type != BUF_FAKE)\n-\t\tcpp_warning (pfile, \"file \\\"%s\\\" left but not entered\",\n-\t\t\t     buffer->nominal_fname);\n+\t\t{\n+\t\t  cpp_warning (pfile, \"file \\\"%s\\\" left but not entered\",\n+\t\t\t       buffer->nominal_fname);\n+\t\t  reason = LC_RENAME;\n+\t\t}\n \t      else\n \t\t{\n \t\t  _cpp_pop_buffer (pfile);\n@@ -789,9 +788,6 @@ do_line (pfile)\n \t\t  if (strcmp (buffer->nominal_fname, fname))\n \t\t    cpp_warning (pfile, \"expected to return to file \\\"%s\\\"\",\n \t\t\t\t buffer->nominal_fname);\n-\t\t  if (buffer->lineno + 1 != new_lineno)\n-\t\t    cpp_warning (pfile, \"expected to return to line number %u\",\n-\t\t\t\t buffer->lineno + 1);\n \t\t  if (buffer->sysp != sysp)\n \t\t    cpp_warning (pfile, \"header flags for \\\"%s\\\" have changed\",\n \t\t\t\t buffer->nominal_fname);\n@@ -810,30 +806,29 @@ do_line (pfile)\n     }\n \n   end_directive (pfile, 1);\n-  buffer->lineno = new_lineno - 1;\n-  _cpp_do_file_change (pfile, reason);\n+  _cpp_do_file_change (pfile, reason, new_lineno);\n }\n \n-/* Arrange the file_change callback.  It is assumed that the next line\n-   is given by incrementing buffer->lineno and pfile->line.  */\n+/* Arrange the file_change callback.  pfile->line has changed to\n+   FILE_LINE of the current buffer, for reason REASON.  */\n void\n-_cpp_do_file_change (pfile, reason)\n+_cpp_do_file_change (pfile, reason, file_line)\n      cpp_reader *pfile;\n      enum lc_reason reason;\n+     unsigned int file_line;\n {\n   cpp_buffer *buffer;\n-  struct line_map *map;\n \n   buffer = pfile->buffer;\n-  map = add_line_map (&pfile->line_maps, reason,\n-\t\t      pfile->line + 1, buffer->nominal_fname, buffer->lineno + 1);\n+  pfile->map = add_line_map (&pfile->line_maps, reason,\n+\t\t\t     pfile->line, buffer->nominal_fname, file_line);\n \n   if (pfile->cb.file_change)\n     {\n       cpp_file_change fc;\n       \n-      fc.map = map;\n-      fc.line = pfile->line + 1;\n+      fc.map = pfile->map;\n+      fc.line = pfile->line;\n       fc.reason = reason;\n       fc.sysp = buffer->sysp;\n       fc.externc = CPP_OPTION (pfile, cplusplus) && buffer->sysp == 2;\n@@ -1195,16 +1190,19 @@ _cpp_do__Pragma (pfile)\n   cpp_token string;\n   unsigned char *buffer;\n   unsigned int len;\n+  cpp_lexer_pos orig_pos;\n \n+  orig_pos = pfile->lexer_pos;\n   if (get__Pragma_string (pfile, &string))\n+    cpp_error (pfile, \"_Pragma takes a parenthesized string literal\");\n+  else\n     {\n-      cpp_error (pfile, \"_Pragma takes a parenthesized string literal\");\n-      return;\n+      buffer = destringize (&string.val.str, &len);\n+      run_directive (pfile, T_PRAGMA, BUF_PRAGMA, (char *) buffer, len);\n+      free ((PTR) buffer);\n+      pfile->lexer_pos = orig_pos;\n+      pfile->line = pfile->lexer_pos.line;\n     }\n-\n-  buffer = destringize (&string.val.str, &len);\n-  run_directive (pfile, T_PRAGMA, BUF_PRAGMA, (char *) buffer, len);\n-  free ((PTR) buffer);\n }\n \n /* Just ignore #sccs, on systems where we define it at all.  */\n@@ -1815,8 +1813,6 @@ cpp_push_buffer (pfile, buffer, len, type, filename, return_at_eof)\n       /* Preprocessed files, builtins, _Pragma and command line\n \t options don't do trigraph and escaped newline processing.  */\n       new->from_stage3 = type != BUF_FILE || CPP_OPTION (pfile, preprocessed);\n-\n-      pfile->lexer_pos.output_line = 1;\n     }\n \n   if (*filename == '\\0')\n@@ -1827,7 +1823,6 @@ cpp_push_buffer (pfile, buffer, len, type, filename, return_at_eof)\n   new->prev = pfile->buffer;\n   new->pfile = pfile;\n   new->include_stack_listed = 0;\n-  new->lineno = 1;\n   new->return_at_eof = return_at_eof;\n \n   pfile->state.next_bol = 1;\n@@ -1857,7 +1852,11 @@ _cpp_pop_buffer (pfile)\n \t\t\t     \"unterminated #%s\", dtable[ifs->type].name);\n \n       if (buffer->type == BUF_FAKE)\n-\tbuffer->prev->cur = buffer->cur;\n+\t{\n+\t  buffer->prev->cur = buffer->cur;\n+\t  buffer->prev->line_base = buffer->line_base;\n+\t  buffer->prev->read_ahead = buffer->read_ahead;\n+\t}\n       else if (buffer->type == BUF_FILE)\n \t_cpp_pop_file_buffer (pfile, buffer);\n \n@@ -1877,8 +1876,7 @@ _cpp_pop_buffer (pfile)\n       if (pfile->directive == &dtable[T_LINE])\n \tbreak;\n \n-      pfile->line--;\t\t/* We have a '\\n' at the end of #include.  */\n-      _cpp_do_file_change (pfile, LC_LEAVE);\n+      _cpp_do_file_change (pfile, LC_LEAVE, pfile->buffer->return_to_line);\n       if (pfile->buffer->type == BUF_FILE)\n \tbreak;\n \n@@ -1888,7 +1886,12 @@ _cpp_pop_buffer (pfile)\n \n   obstack_free (&pfile->buffer_ob, buffer);\n \n-  pfile->state.skipping = 0;\t/* In case missing #endif.  */\n+  /* The output line can fall out of sync if we missed the final\n+     newline from the previous buffer, for example because of an\n+     unterminated comment.  Similarly, skipping needs to be cleared in\n+     case of a missing #endif.  */\n+  pfile->lexer_pos.output_line = pfile->line;\n+  pfile->state.skipping = 0;\n }\n \n void"}, {"sha": "1618e7e102fb2821869d5bd2a1f7166973bee04c", "filename": "gcc/cppmacro.c", "status": "modified", "additions": 15, "deletions": 17, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67821e3a9e007c34a85bbc3b934031b57eafc903/gcc%2Fcppmacro.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67821e3a9e007c34a85bbc3b934031b57eafc903/gcc%2Fcppmacro.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppmacro.c?ref=67821e3a9e007c34a85bbc3b934031b57eafc903", "patch": "@@ -175,7 +175,8 @@ builtin_macro (pfile, token)\n       /* If __LINE__ is embedded in a macro, it must expand to the\n \t line of the macro's invocation, not its definition.\n \t Otherwise things like assert() will not work properly.  */\n-      make_number_token (pfile, token, cpp_get_line (pfile)->line);\n+      make_number_token (pfile, token,\n+\t\t\t SOURCE_LINE (pfile->map, cpp_get_line (pfile)->line));\n       break;\n \n     case BT_STDC:\n@@ -484,9 +485,9 @@ parse_arg (pfile, arg, variadic)\n \t}\n \n       /* Newlines in arguments are white space (6.10.3.10).  */\n-      line = pfile->lexer_pos.output_line;\n+      line = pfile->line;\n       cpp_get_token (pfile, token);\n-      if (line != pfile->lexer_pos.output_line)\n+      if (line != pfile->line)\n \ttoken->flags |= PREV_WHITE;\n \n       result = token->type;\n@@ -1027,22 +1028,19 @@ save_lookahead_token (pfile, token)\n      cpp_reader *pfile;\n      const cpp_token *token;\n {\n-  if (token->type != CPP_EOF)\n-    {\n-      cpp_lookahead *la = pfile->la_write;\n-      cpp_token_with_pos *twp;\n-\n-      if (la->count == la->cap)\n-\t{\n-\t  la->cap += la->cap + 8;\n-\t  la->tokens = (cpp_token_with_pos *)\n-\t    xrealloc (la->tokens, la->cap * sizeof (cpp_token_with_pos));\n-\t}\n+  cpp_lookahead *la = pfile->la_write;\n+  cpp_token_with_pos *twp;\n \n-      twp = &la->tokens[la->count++];\n-      twp->token = *token;\n-      twp->pos = *cpp_get_line (pfile);\n+  if (la->count == la->cap)\n+    {\n+      la->cap += la->cap + 8;\n+      la->tokens = (cpp_token_with_pos *)\n+\txrealloc (la->tokens, la->cap * sizeof (cpp_token_with_pos));\n     }\n+\n+  twp = &la->tokens[la->count++];\n+  twp->token = *token;\n+  twp->pos = *cpp_get_line (pfile);\n }\n \n static void"}, {"sha": "86d245ab9f110a1296ac33e75e5511c376a5f9b3", "filename": "gcc/cppmain.c", "status": "modified", "additions": 71, "deletions": 81, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67821e3a9e007c34a85bbc3b934031b57eafc903/gcc%2Fcppmain.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67821e3a9e007c34a85bbc3b934031b57eafc903/gcc%2Fcppmain.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppmain.c?ref=67821e3a9e007c34a85bbc3b934031b57eafc903", "patch": "@@ -30,12 +30,12 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n    cpp_get_token back into a text file.  */\n struct printer\n {\n-  FILE *outf;\t\t\t/* stream to write to.  */\n-  const char *last_fname;\t/* previous file name.  */\n-  const char *syshdr_flags;\t/* system header flags, if any.  */\n-  unsigned int lineno;\t\t/* line currently being written.  */\n-  unsigned char printed;\t/* nonzero if something output at lineno.  */\n-  struct line_map *map;\t\t/* logical to physical line mappings.  */\n+  FILE *outf;\t\t\t/* Stream to write to.  */\n+  const char *filename;\t\t/* Name of current file.  */\n+  const char *syshdr_flags;\t/* System header flags, if any.  */\n+  unsigned int line;\t\t/* Line currently being written.  */\n+  unsigned char printed;\t/* Nonzero if something output at line.  */\n+  struct line_map *map;\t\t/* Logical to physical line mappings.  */\n };\n \n int main\t\tPARAMS ((int, char **));\n@@ -46,10 +46,10 @@ static void setup_callbacks PARAMS ((void));\n /* General output routines.  */\n static void scan_translation_unit PARAMS ((cpp_reader *));\n static void check_multiline_token PARAMS ((cpp_string *));\n-static int printer_init PARAMS ((cpp_reader *));\n+static void printer_init PARAMS ((void));\n static int dump_macro PARAMS ((cpp_reader *, cpp_hashnode *, void *));\n \n-static void print_line PARAMS ((const char *));\n+static void print_line PARAMS ((unsigned int, const char *));\n static void maybe_print_line PARAMS ((unsigned int));\n \n /* Callback routines for the parser.   Most of these are active only\n@@ -144,8 +144,12 @@ do_preprocessing (argc, argv)\n   /* Open the output now.  We must do so even if no_output is on,\n      because there may be other output than from the actual\n      preprocessing (e.g. from -dM).  */\n-  if (printer_init (pfile))\n-    return;\n+  printer_init ();\n+  if (print.outf == NULL)\n+    {\n+      cpp_notice_from_errno (pfile, options->out_fname);\n+      return;\n+    }\n \n   setup_callbacks ();\n \n@@ -216,7 +220,7 @@ scan_translation_unit (pfile)\n \tbreak;\n \n       line = cpp_get_line (pfile)->output_line;\n-      if (print.lineno != line)\n+      if (print.line != line)\n \t{\n \t  unsigned int col = cpp_get_line (pfile)->col;\n \n@@ -253,7 +257,7 @@ scan_translation_unit (pfile)\n     }\n }\n \n-/* Adjust print.lineno for newlines embedded in tokens.  */\n+/* Adjust print.line for newlines embedded in tokens.  */\n static void\n check_multiline_token (str)\n      cpp_string *str;\n@@ -262,107 +266,91 @@ check_multiline_token (str)\n \n   for (i = 0; i < str->len; i++)\n     if (str->text[i] == '\\n')\n-      print.lineno++;\n+      print.line++;\n }\n \n /* Initialize a cpp_printer structure.  As a side effect, open the\n-   output file.  */\n-static int\n-printer_init (pfile)\n-     cpp_reader *pfile;\n+   output file.  If print.outf is NULL an error occurred.  */\n+static void\n+printer_init ()\n {\n-  print.last_fname = 0;\n-  print.lineno = 0;\n+  /* Setting print.line to -1 here guarantees that the first token of\n+     the file will cause a linemarker to be output by maybe_print_line.  */\n+  print.line = (unsigned int) -1;\n   print.printed = 0;\n+  print.map = 0;\n \n   if (options->out_fname[0] == '\\0')\n     print.outf = stdout;\n   else\n-    {\n-      print.outf = fopen (options->out_fname, \"w\");\n-      if (! print.outf)\n-\t{\n-\t  cpp_notice_from_errno (pfile, options->out_fname);\n-\t  return 1;\n-\t}\n-    }\n-\n-  return 0;\n+    print.outf = fopen (options->out_fname, \"w\");\n }\n \n-/* Newline-terminate any output line currently in progress.  If\n-   appropriate, write the current line number to the output, or pad\n-   with newlines so the output line matches the current line.  */\n+/* If the token read on logical line LINE needs to be output on a\n+   different line to the current one, output the required newlines or\n+   a line marker, and return 1.  Otherwise return 0.  */\n+\n static void\n maybe_print_line (line)\n      unsigned int line;\n {\n-  /* End the previous line of text (probably only needed until we get\n-     multi-line tokens fixed).  */\n+  /* End the previous line of text.  */\n   if (print.printed)\n     {\n       putc ('\\n', print.outf);\n-      print.lineno++;\n+      print.line++;\n       print.printed = 0;\n     }\n \n-  if (options->no_line_commands)\n+  if (line >= print.line && line < print.line + 8)\n     {\n-      print.lineno = line;\n-      return;\n-    }\n-\n-  /* print.lineno is zero if this is the first token of the file.  We\n-     handle this specially, so that a first line of \"# 1 \"foo.c\" in\n-     file foo.i outputs just the foo.c line, and not a foo.i line.  */\n-  if (line >= print.lineno && line < print.lineno + 8 && print.lineno)\n-    {\n-      while (line > print.lineno)\n+      while (line > print.line)\n \t{\n \t  putc ('\\n', print.outf);\n-\t  print.lineno++;\n+\t  print.line++;\n \t}\n     }\n   else\n-    {\n-      print.lineno = line;\n-      print_line (\"\");\n-    }\n+    print_line (line, \"\");\n }\n \n static void\n-print_line (special_flags)\n-  const char *special_flags;\n+print_line (line, special_flags)\n+     unsigned int line;\n+     const char *special_flags;\n {\n   /* End any previous line of text.  */\n   if (print.printed)\n     putc ('\\n', print.outf);\n   print.printed = 0;\n \n-  fprintf (print.outf, \"# %u \\\"%s\\\"%s%s\\n\",\n-\t   print.lineno, print.last_fname, special_flags, print.syshdr_flags);\n+  print.line = line;\n+  if (! options->no_line_commands)\n+    fprintf (print.outf, \"# %u \\\"%s\\\"%s%s\\n\",\n+\t     SOURCE_LINE (print.map, print.line),\n+\t     print.filename, special_flags, print.syshdr_flags);\n }\n \n /* Callbacks.  */\n \n static void\n cb_ident (pfile, line, str)\n      cpp_reader *pfile ATTRIBUTE_UNUSED;\n-     unsigned int line ATTRIBUTE_UNUSED;\n+     unsigned int line;\n      const cpp_string * str;\n {\n-  maybe_print_line (cpp_get_line (pfile)->output_line);\n+  maybe_print_line (line);\n   fprintf (print.outf, \"#ident \\\"%s\\\"\\n\", str->text);\n-  print.lineno++;\n+  print.line++;\n }\n \n static void\n cb_define (pfile, line, node)\n      cpp_reader *pfile;\n-     unsigned int line ATTRIBUTE_UNUSED;\n+     unsigned int line;\n      cpp_hashnode *node;\n {\n-  maybe_print_line (cpp_get_line (pfile)->output_line);\n+  maybe_print_line (line);\n   fputs (\"#define \", print.outf);\n \n   /* -dD command line option.  */\n@@ -372,62 +360,64 @@ cb_define (pfile, line, node)\n     fputs ((const char *) NODE_NAME (node), print.outf);\n \n   putc ('\\n', print.outf);\n-  print.lineno++;\n+  print.line++;\n }\n \n static void\n cb_undef (pfile, line, node)\n-     cpp_reader *pfile;\n-     unsigned int line ATTRIBUTE_UNUSED;\n+     cpp_reader *pfile ATTRIBUTE_UNUSED;\n+     unsigned int line;\n      cpp_hashnode *node;\n {\n-  maybe_print_line (cpp_get_line (pfile)->output_line);\n+  maybe_print_line (line);\n   fprintf (print.outf, \"#undef %s\\n\", NODE_NAME (node));\n-  print.lineno++;\n+  print.line++;\n }\n \n static void\n cb_include (pfile, line, dir, header)\n-     cpp_reader *pfile ATTRIBUTE_UNUSED;\n-     unsigned int line ATTRIBUTE_UNUSED;\n+     cpp_reader *pfile;\n+     unsigned int line;\n      const unsigned char *dir;\n      const cpp_token *header;\n {\n-  maybe_print_line (cpp_get_line (pfile)->output_line);\n+  maybe_print_line (line);\n   fprintf (print.outf, \"#%s %s\\n\", dir, cpp_token_as_text (pfile, header));\n-  print.lineno++;\n+  print.line++;\n }\n \n static void\n cb_file_change (pfile, fc)\n      cpp_reader *pfile ATTRIBUTE_UNUSED;\n      const cpp_file_change *fc;\n {\n-  /* Bring current file to correct line (except first file).  */\n-  if (fc->reason == LC_ENTER && !MAIN_FILE_P (fc->map))\n-    maybe_print_line (SOURCE_LINE (fc->map - 1, fc->line - 1));\n+  bool first_time = print.map == NULL;\n+\n+  /* Bring current file to correct line.  We handle the first file\n+     change callback specially, so that a first line of \"# 1 \"foo.c\"\n+     in file foo.i outputs just the foo.c line, and not a foo.i line.  */\n+  if (fc->reason == LC_ENTER && !first_time)\n+    maybe_print_line (fc->line - 1);\n \n   print.map = fc->map;\n-  print.last_fname = fc->map->to_file;\n+  print.filename = fc->map->to_file;\n   if (fc->externc)\n     print.syshdr_flags = \" 3 4\";\n   else if (fc->sysp)\n     print.syshdr_flags = \" 3\";\n   else\n     print.syshdr_flags = \"\";\n \n-  if (print.lineno)\n+  if (!first_time)\n     {\n       const char *flags = \"\";\n \n-      print.lineno = SOURCE_LINE (fc->map, fc->line);\n       if (fc->reason == LC_ENTER)\n \tflags = \" 1\";\n       else if (fc->reason == LC_LEAVE)\n \tflags = \" 2\";\n \n-      if (! options->no_line_commands)\n-\tprint_line (flags);\n+      print_line (fc->line, flags);\n     }\n }\n \n@@ -436,12 +426,12 @@ cb_file_change (pfile, fc)\n static void\n cb_def_pragma (pfile, line)\n      cpp_reader *pfile;\n-     unsigned int line ATTRIBUTE_UNUSED;\n+     unsigned int line;\n {\n-  maybe_print_line (cpp_get_line (pfile)->output_line);\n+  maybe_print_line (line);\n   fputs (\"#pragma \", print.outf);\n   cpp_output_line (pfile, print.outf);\n-  print.lineno++;\n+  print.line++;\n }\n \n /* Dump out the hash table.  */\n@@ -456,7 +446,7 @@ dump_macro (pfile, node, v)\n       fputs (\"#define \", print.outf);\n       fputs ((const char *) cpp_macro_definition (pfile, node), print.outf);\n       putc ('\\n', print.outf);\n-      print.lineno++;\n+      print.line++;\n     }\n \n   return 1;"}, {"sha": "b6c934435d3912a6d649db5d08c9e452d55fe96b", "filename": "gcc/line-map.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67821e3a9e007c34a85bbc3b934031b57eafc903/gcc%2Fline-map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67821e3a9e007c34a85bbc3b934031b57eafc903/gcc%2Fline-map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fline-map.h?ref=67821e3a9e007c34a85bbc3b934031b57eafc903", "patch": "@@ -75,9 +75,12 @@ extern struct line_map *lookup_line\n \n /* Returns the last source line within a map.  This is the (last) line\n    of the #include, or other directive, that caused a map change.  */\n-#define LAST_SOURCE_LINE(MAP) SOURCE_LINE (MAP, (MAP)[1].from_line - 1)\n+#define LAST_SOURCE_LINE(MAP) SOURCE_LINE ((MAP), (MAP)[1].from_line - 1)\n \n /* Non-zero if the map is at the bottom of the include stack.  */\n #define MAIN_FILE_P(MAP) ((MAP)->included_from < 0)\n \n+/* The current line map.  */\n+#define CURRENT_LINE_MAP(MAPS) ((MAPS)->maps + (MAPS)->used - 1)\n+\n #endif /* !GCC_LINE_MAP_H  */"}, {"sha": "512f539381384a644a515ccf4b65fc0bcad02b18", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67821e3a9e007c34a85bbc3b934031b57eafc903/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67821e3a9e007c34a85bbc3b934031b57eafc903/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=67821e3a9e007c34a85bbc3b934031b57eafc903", "patch": "@@ -1,3 +1,9 @@\n+2001-08-05  Neil Booth  <neil@daikokuya.demon.co.uk>\n+\n+\t* gcc.dg/cpp/19951025-1.c: Revert.\n+\t* gcc.dg/cpp/directiv.c: We no longer process directives that\n+\tinterrupt macro arguments.\n+\n 2001-08-03  Zack Weinberg  <zackw@stanford.edu>\n \n \t* gcc.dg/bconstp-1.c: New test."}, {"sha": "283b5f53f1abaaee40c164ebcdc31aee6f6ecf9b", "filename": "gcc/testsuite/gcc.dg/cpp/19951025-1.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67821e3a9e007c34a85bbc3b934031b57eafc903/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2F19951025-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67821e3a9e007c34a85bbc3b934031b57eafc903/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2F19951025-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2F19951025-1.c?ref=67821e3a9e007c34a85bbc3b934031b57eafc903", "patch": "@@ -1,4 +1,4 @@\n /* { dg-do preprocess } */\n-/* { dg-error \"include expects\" \"\" { target *-*-* } 5 } */\n-/* { dg-error \"newline at end\" \"\" { target *-*-* } 5 } */\n+/* { dg-error \"include expects\" \"\" { target *-*-* } 4 } */\n+/* { dg-error \"newline at end\" \"\" { target *-*-* } 4 } */\n #include /\\"}, {"sha": "622f7a3471a370950b2fb91a1130c55a3c816863", "filename": "gcc/testsuite/gcc.dg/cpp/directiv.c", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67821e3a9e007c34a85bbc3b934031b57eafc903/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fdirectiv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67821e3a9e007c34a85bbc3b934031b57eafc903/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fdirectiv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fdirectiv.c?ref=67821e3a9e007c34a85bbc3b934031b57eafc903", "patch": "@@ -31,13 +31,6 @@ EMPTY #define bar\n func (2\t\t/* { dg-error \"unterminated\" \"\" { target *-*-* } 32 } */\n #define foobar\t/* { dg-error \"directives may not\" } */\n \n-/* For tidiness, I think the directive should still be processed\n-   above.  Certainly, continuing to try to find the closing ')' can\n-   lead to some really confusing error messages.  Hence this test.  */\n-#ifndef foobar\n-#error It is nice if the directive is processed!\n-#endif\n-\n /* Check newlines end directives, even in function-like macro\n    invocations.  6.10 paragraph 1.\n "}]}