{"sha": "f38cd3bdb4cd429a5f7082ea91793a59b37d47b9", "node_id": "C_kwDOANBUbNoAKGYzOGNkM2JkYjRjZDQyOWE1ZjcwODJlYTkxNzkzYTU5YjM3ZDQ3Yjk", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2021-09-29T12:48:19Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2021-09-29T12:48:19Z"}, "message": "libstdc++: Implement std::regex_constants::multiline (LWG 2503)\n\nThis implements LWG 2503, which allows ^ and $ to match line terminator\ncharacters, rather than only matching the beginning and end of the\nentire input. The multiline option is only valid for ECMAScript, but\nfor other grammars we ignore it rather than throwing an exception.\n\nThis is related to PR libstdc++/102480, which incorrectly said that\nECMAscript should match the beginning of a line when match_prev_avail\nis used. I think that's only supposed to happen when multiline is used.\n\nThe new regex_constants::multiline and basic_regex::multiline constants\nare not defined for strict -std=c++11 and -std=c++14 modes, but\nregex_constants::__multiline is always defined, so that the\nimplementation can use it internally.\n\nSigned-off-by: Jonathan Wakely <jwakely@redhat.com>\n\nlibstdc++-v3/ChangeLog:\n\n\t* include/bits/regex.h (basic_regex::multiline): Define constant\n\tfor C++17.\n\t* include/bits/regex_constants.h (regex_constants::multiline):\n\tDefine constant for C++17.\n\t(regex_constants::__multiline): Define duplicate constant for\n\tinternal use in C++11 and C++14.\n\t* include/bits/regex_executor.h (_Executor::_M_match_multiline()):\n\tNew member function.\n\t(_Executor::_M_is_line_terminator(_CharT)): New member function.\n\t(_Executor::_M_at_begin(), _Executor::_M_at_end()): Use new\n\tmember functions to support multiline matches.\n\t* testsuite/28_regex/algorithms/regex_match/multiline.cc: New test.", "tree": {"sha": "be23a5f66d83fea6c12a180553055b8ca2217526", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/be23a5f66d83fea6c12a180553055b8ca2217526"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f38cd3bdb4cd429a5f7082ea91793a59b37d47b9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f38cd3bdb4cd429a5f7082ea91793a59b37d47b9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f38cd3bdb4cd429a5f7082ea91793a59b37d47b9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f38cd3bdb4cd429a5f7082ea91793a59b37d47b9/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9ca4c42a3b756e54a92ff8e1ac6c396b680b7839", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ca4c42a3b756e54a92ff8e1ac6c396b680b7839", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9ca4c42a3b756e54a92ff8e1ac6c396b680b7839"}], "stats": {"total": 172, "additions": 157, "deletions": 15}, "files": [{"sha": "ad33ecaa14b70e6eca6acd259770d504e27cc5d7", "filename": "libstdc++-v3/include/bits/regex.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f38cd3bdb4cd429a5f7082ea91793a59b37d47b9/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f38cd3bdb4cd429a5f7082ea91793a59b37d47b9/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex.h?ref=f38cd3bdb4cd429a5f7082ea91793a59b37d47b9", "patch": "@@ -424,6 +424,9 @@ _GLIBCXX_BEGIN_NAMESPACE_CXX11\n       static constexpr flag_type awk = regex_constants::awk;\n       static constexpr flag_type grep = regex_constants::grep;\n       static constexpr flag_type egrep = regex_constants::egrep;\n+#if __cplusplus >= 2017\n+      static constexpr flag_type multiline = regex_constants::multiline;\n+#endif\n       ///@}\n \n       // [7.8.2] construct/copy/destroy"}, {"sha": "af689ff93af1bcb6fbe36d3e88ccccf539fbed5b", "filename": "libstdc++-v3/include/bits/regex_constants.h", "status": "modified", "additions": 21, "deletions": 4, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f38cd3bdb4cd429a5f7082ea91793a59b37d47b9/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_constants.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f38cd3bdb4cd429a5f7082ea91793a59b37d47b9/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_constants.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_constants.h?ref=f38cd3bdb4cd429a5f7082ea91793a59b37d47b9", "patch": "@@ -64,7 +64,7 @@ namespace regex_constants\n     _S_grep,\n     _S_egrep,\n     _S_polynomial,\n-    _S_syntax_last\n+    _S_multiline\n   };\n \n   /**\n@@ -170,6 +170,22 @@ namespace regex_constants\n   _GLIBCXX17_INLINE constexpr syntax_option_type egrep =\n     static_cast<syntax_option_type>(1 << _S_egrep);\n \n+#if __cplusplus >= 201703L || !defined __STRICT_ANSI__\n+  /**\n+   * Specifies that the `^` anchor matches at the beginning of a line,\n+   * and the `$` anchor matches at the end of a line, not only at the\n+   * beginning/end of the input.\n+   * Valid for the ECMAScript syntax, ignored otherwise.\n+   * @since C++17\n+   */\n+  _GLIBCXX17_INLINE constexpr syntax_option_type multiline =\n+    static_cast<syntax_option_type>(1 << _S_multiline);\n+#endif\n+\n+  /// Extension: Equivalent to regex_constants::multiline for C++11 and C++14.\n+  _GLIBCXX17_INLINE constexpr syntax_option_type __multiline =\n+    static_cast<syntax_option_type>(1 << _S_multiline);\n+\n   /**\n    * Extension: Ensure both space complexity of compiled regex and\n    * time complexity execution are not exponential.\n@@ -310,9 +326,10 @@ namespace regex_constants\n     static_cast<match_flag_type>(1 << _S_continuous);\n \n   /**\n-   * --first is a valid iterator position.  When this flag is set then the\n-   * flags match_not_bol and match_not_bow are ignored by the regular\n-   * expression algorithms 28.11 and iterators 28.12.\n+   * `--first` is a valid iterator position.  When this flag is set then the\n+   * flags `match_not_bol` and `match_not_bow` are ignored by the algorithms\n+   * `regex_match`, `regex_search`, and `regex_replace`, and by the iterators\n+   * `regex_iterator` and `regex_token_iterator`.\n    */\n   _GLIBCXX17_INLINE constexpr match_flag_type match_prev_avail =\n     static_cast<match_flag_type>(1 << _S_prev_avail);"}, {"sha": "167d40624d9cdc9088544bbfd63f2f46a8c243cd", "filename": "libstdc++-v3/include/bits/regex_executor.h", "status": "modified", "additions": 59, "deletions": 11, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f38cd3bdb4cd429a5f7082ea91793a59b37d47b9/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_executor.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f38cd3bdb4cd429a5f7082ea91793a59b37d47b9/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_executor.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fregex_executor.h?ref=f38cd3bdb4cd429a5f7082ea91793a59b37d47b9", "patch": "@@ -78,12 +78,12 @@ namespace __detail\n       _M_results(__results),\n       _M_rep_count(_M_nfa.size()),\n       _M_states(_M_nfa._M_start(), _M_nfa.size()),\n-      _M_flags((__flags & regex_constants::match_prev_avail)\n-\t       ? (__flags\n-\t\t  & ~regex_constants::match_not_bol\n-\t\t  & ~regex_constants::match_not_bow)\n-\t       : __flags)\n-      { }\n+      _M_flags(__flags)\n+      {\n+\tusing namespace regex_constants;\n+\tif (__flags & match_prev_avail) // ignore not_bol and not_bow\n+\t  _M_flags &= ~(match_not_bol | match_not_bow);\n+      }\n \n       // Set matched when string exactly matches the pattern.\n       bool\n@@ -165,16 +165,39 @@ namespace __detail\n       bool\n       _M_at_begin() const\n       {\n-\treturn _M_current == _M_begin\n-\t  && !(_M_flags & (regex_constants::match_not_bol\n-\t\t\t   | regex_constants::match_prev_avail));\n+\tif (_M_current == _M_begin)\n+\t  {\n+\t    // match_not_bol means ^ does not match [_M_begin,_M_begin)\n+\t    if (_M_flags & regex_constants::match_not_bol)\n+\t      return false;\n+\t    // match_prev_avail means _M_begin is not the start of the input.\n+\t    if (_M_flags & regex_constants::match_prev_avail)\n+\t      {\n+\t\t// For ECMAScript multiline matches, check if the previous\n+\t\t// character is a line terminator.\n+\t\tif (_M_match_multiline())\n+\t\t  return _M_is_line_terminator(*std::prev(_M_current));\n+\t\telse\n+\t\t  return false;\n+\t      }\n+\t    else // ^ matches at _M_begin\n+\t      return true;\n+\t  }\n+\telse if (_M_match_multiline())\n+\t  return _M_is_line_terminator(*std::prev(_M_current));\n+\telse\n+\t  return false;\n       }\n \n       bool\n       _M_at_end() const\n       {\n-\treturn _M_current == _M_end\n-\t  && !(_M_flags & regex_constants::match_not_eol);\n+\tif (_M_current == _M_end)\n+\t  return !(_M_flags & regex_constants::match_not_eol);\n+\telse if (_M_match_multiline())\n+\t  return _M_is_line_terminator(*_M_current);\n+\telse\n+\t  return false;\n       }\n \n       bool\n@@ -183,6 +206,31 @@ namespace __detail\n       bool\n       _M_lookahead(_StateIdT __next);\n \n+      bool\n+      _M_is_line_terminator(_CharT __c) const\n+      {\n+\tconst auto& __traits = _M_re._M_automaton->_M_traits;\n+\tconst auto& __ct = use_facet<ctype<_CharT>>(__traits.getloc());\n+\tconst char __n{ __ct.narrow(__c, ' ') };\n+\tif (__n == '\\n')\n+\t  return true;\n+\tif (_M_re._M_automaton->_M_options() & regex_constants::ECMAScript)\n+\t  {\n+\t    if (__n == '\\r')\n+\t      return true;\n+\t    // FIXME: U+2028 (line separator) and U+2029 (paragraph separator)\n+\t  }\n+\treturn false;\n+      }\n+\n+      bool\n+      _M_match_multiline() const noexcept\n+      {\n+\tconstexpr auto __m\n+\t  = regex_constants::ECMAScript | regex_constants::__multiline;\n+\treturn (_M_re._M_automaton->_M_options() & __m) == __m;\n+      }\n+\n        // Holds additional information used in BFS-mode.\n       template<typename _SearchMode, typename _ResultsVec>\n \tstruct _State_info;"}, {"sha": "a1982fc8f786de6806ee9d6fe033c1fbd1ad2a6d", "filename": "libstdc++-v3/testsuite/28_regex/algorithms/regex_match/multiline.cc", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f38cd3bdb4cd429a5f7082ea91793a59b37d47b9/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Falgorithms%2Fregex_match%2Fmultiline.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f38cd3bdb4cd429a5f7082ea91793a59b37d47b9/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Falgorithms%2Fregex_match%2Fmultiline.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F28_regex%2Falgorithms%2Fregex_match%2Fmultiline.cc?ref=f38cd3bdb4cd429a5f7082ea91793a59b37d47b9", "patch": "@@ -0,0 +1,74 @@\n+// { dg-do run { target c++11 } }\n+#include <regex>\n+#include <testsuite_hooks.h>\n+\n+#if __cplusplus >= 201703L || !defined __STRICT_ANSI__\n+static_assert( std::regex_constants::multiline == std::regex::multiline );\n+static_assert( std::regex_constants::__multiline == std::regex::multiline );\n+#else\n+namespace test { constexpr int multiline = 0; }\n+namespace check {\n+  using namespace test;\n+  using namespace std::regex_constants;\n+  int ml = multiline;\n+}\n+#endif\n+\n+void\n+test01()\n+{\n+  using namespace std::regex_constants;\n+\n+  std::regex ml{\"^a.$\", __multiline};\n+  VERIFY( ml.flags() == __multiline );\n+  VERIFY(!std::regex_search(\"abx\\nxab\", ml));\n+  VERIFY(std::regex_search(\"x\\nab\", ml));\n+  VERIFY(std::regex_search(\"ab\\n\", ml));\n+  VERIFY(std::regex_search(\"x\\nab\\nx\", ml));\n+\n+  ml.assign(\"a$\\n^b$\\n^c\", ECMAScript|__multiline);\n+  VERIFY( ml.flags() == ECMAScript|__multiline );\n+  VERIFY( regex_search(\"a\\nb\\nc\", ml) );\n+\n+  ml.assign(\"a$\\n^b$\\n^c\", ECMAScript|__multiline|icase);\n+  VERIFY( ml.flags() == ECMAScript|__multiline|icase );\n+  VERIFY( regex_search(\"A\\nB\\nC\", ml) );\n+}\n+\n+void\n+test_pr102480()\n+{\n+  using namespace std::regex_constants;\n+\n+  std::regex re(\"^a\");\n+  std::regex reml(\"^a\", __multiline);\n+  VERIFY( std::regex_match(\"\\na\" + 1, re));\n+  VERIFY( std::regex_match(\"\\na\" + 1, reml));\n+  // PR libstdc++/102480\n+  VERIFY(!std::regex_match(\"\\na\" + 1, re, match_prev_avail));\n+  VERIFY( std::regex_match(\"\\na\" + 1, reml, match_prev_avail));\n+  VERIFY(!std::regex_match(\"\\na\" + 1, re, match_not_bol));\n+  VERIFY(!std::regex_match(\"\\na\" + 1, re, match_prev_avail|match_not_bol));\n+  VERIFY( std::regex_match(\"\\na\" + 1, reml, match_prev_avail|match_not_bol));\n+  VERIFY(!std::regex_match(\"\\ra\" + 1, re, match_prev_avail));\n+  VERIFY( std::regex_match(\"\\ra\" + 1, reml, match_prev_avail));\n+  VERIFY(!std::regex_match(\"xa\" + 1, re, match_prev_avail));\n+  VERIFY(!std::regex_match(\"xa\" + 1, reml, match_prev_avail));\n+\n+  std::regex bre(\"^a\", basic|__multiline);\n+  VERIFY(std::regex_match(\"\\na\" + 1, bre));\n+  VERIFY(!std::regex_match(\"\\na\" + 1, bre, match_not_bol));\n+  // multiline is ignored for any grammar except ECMAScript,\n+  // so none of the following should match even though\n+  // match_prev_avail is set and *--first == '\\n'.\n+  VERIFY(!std::regex_match(\"\\na\" + 1, bre, match_prev_avail));\n+  VERIFY(!std::regex_match(\"\\na\" + 1, bre, match_prev_avail|match_not_bol));\n+  VERIFY(!std::regex_match(\"\\ra\" + 1, bre, match_prev_avail));\n+  VERIFY(!std::regex_match(\"xa\" + 1, bre, match_prev_avail));\n+}\n+\n+int main()\n+{\n+  test01();\n+  test_pr102480();\n+}"}]}