{"sha": "29e11dabe9ef0d906d57eadb0a0bea96f250cd67", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjllMTFkYWJlOWVmMGQ5MDZkNTdlYWRiMGEwYmVhOTZmMjUwY2Q2Nw==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-02-09T01:17:59Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-02-09T01:17:59Z"}, "message": "(earith, ereal_negate, eneg, eisneg, enan, emovo, esub, eadd, ediv):\n\nPropagate the sign of NaNs, so that e.g. -(NaN) evaluates to -NaN.\n(emul, eremain, e53toe, e64toe, e113toe, e24toe, esqrt): Likewise.\n(make_nan): New arg specifies sign of NaN.  All callers changed.\n(eiisneg): New function.\n(esqrt): Compute sqrt(-0.0) to be -0.0, not 0.0.\n\nFrom-SVN: r6511", "tree": {"sha": "1fc43aff4c403c85bbcefb8bac7eb422b1a6488d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1fc43aff4c403c85bbcefb8bac7eb422b1a6488d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/29e11dabe9ef0d906d57eadb0a0bea96f250cd67", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29e11dabe9ef0d906d57eadb0a0bea96f250cd67", "html_url": "https://github.com/Rust-GCC/gccrs/commit/29e11dabe9ef0d906d57eadb0a0bea96f250cd67", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29e11dabe9ef0d906d57eadb0a0bea96f250cd67/comments", "author": null, "committer": null, "parents": [{"sha": "b9b63425c6db79f9e93990d8b17d22d40bbcd018", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9b63425c6db79f9e93990d8b17d22d40bbcd018", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b9b63425c6db79f9e93990d8b17d22d40bbcd018"}], "stats": {"total": 113, "additions": 58, "deletions": 55}, "files": [{"sha": "db36bfe8a6ee1333041364613638d78802c28fb6", "filename": "gcc/real.c", "status": "modified", "additions": 58, "deletions": 55, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29e11dabe9ef0d906d57eadb0a0bea96f250cd67/gcc%2Freal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29e11dabe9ef0d906d57eadb0a0bea96f250cd67/gcc%2Freal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freal.c?ref=29e11dabe9ef0d906d57eadb0a0bea96f250cd67", "patch": "@@ -1,8 +1,8 @@\n /* real.c - implementation of REAL_ARITHMETIC, REAL_VALUE_ATOF,\n-and support for XFmode IEEE extended real floating point arithmetic.\n-Contributed by Stephen L. Moshier (moshier@world.std.com).\n+   and support for XFmode IEEE extended real floating point arithmetic.\n+   Contributed by Stephen L. Moshier (moshier@world.std.com).\n \n-   Copyright (C) 1993 Free Software Foundation, Inc.\n+   Copyright (C) 1993, 1994 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -322,7 +322,7 @@ do { EMUSHORT w[4];\t\t\\\n void warning ();\n extern int extra_warnings;\n int ecmp (), enormlz (), eshift ();\n-int eisneg (), eisinf (), eisnan (), eiisinf (), eiisnan ();\n+int eisneg (), eisinf (), eisnan (), eiisinf (), eiisnan (), eiisneg ();\n void eadd (), esub (), emul (), ediv ();\n void eshup1 (), eshup8 (), eshup6 (), eshdn1 (), eshdn8 (), eshdn6 ();\n void eabs (), eneg (), emov (), eclear (), einfin (), efloor ();\n@@ -490,7 +490,7 @@ earith (value, icode, r1, r2)\n       if (ecmp (d2, ezero) == 0)\n \t{\n #ifdef NANS\n-\tenan (v);\n+\tenan (v, eisneg (d1) ^ eisneg (d2));\n \tbreak;\n #else\n \tabort ();\n@@ -616,10 +616,6 @@ ereal_negate (x)\n   REAL_VALUE_TYPE r;\n \n   GET_REAL (&x, e);\n-#ifdef NANS\n-  if (eisnan (e))\n-    return (x);\n-#endif\n   eneg (e);\n   PUT_REAL (e, &r);\n   return (r);\n@@ -1096,6 +1092,7 @@ ereal_isneg (x)\n  *\tesubm (ai, bi)\t\tsubtract significands, bi = bi - ai\n  *      eiisinf (ai)            1 if infinite\n  *      eiisnan (ai)            1 if a NaN\n+ *\teiisneg (ai)\t\t1 if sign bit of ai != 0, else 0\n  *      einan (ai)              set ai = NaN\n  *      eiinfin (ai)            set ai = infinity\n  *\n@@ -1349,27 +1346,19 @@ eneg (x)\n      unsigned EMUSHORT x[];\n {\n \n-#ifdef NANS\n-  if (eisnan (x))\n-    return;\n-#endif\n   x[NE - 1] ^= 0x8000;\t\t/* Toggle the sign bit */\n }\n \n \n \n-/* Return 1 if external format number is negative,\n- * else return zero, including when it is a NaN.\n+/* Return 1 if sign bit of external format number is nonzero,\n+ * else return zero.\n  */\n int \n eisneg (x)\n      unsigned EMUSHORT x[];\n {\n \n-#ifdef NANS\n-  if (eisnan (x))\n-    return (0);\n-#endif\n   if (x[NE - 1] & 0x8000)\n     return (1);\n   else\n@@ -1468,15 +1457,16 @@ einfin (x)\n    The exponent is 7fff, the leading mantissa word is c000.  */\n \n void \n-enan (x)\n+enan (x, sign)\n      register unsigned EMUSHORT *x;\n+     int sign;\n {\n   register int i;\n \n   for (i = 0; i < NE - 2; i++)\n     *x++ = 0;\n   *x++ = 0xc000;\n-  *x = 0x7fff;\n+  *x = (sign << 15) | 0x7fff;\n }\n \n \n@@ -1552,7 +1542,7 @@ emovo (a, b)\n #ifdef NANS\n       if (eiisnan (a))\n \t{\n-\t  enan (b);\n+\t  enan (b, eiisneg (a));\n \t  return;\n \t}\n #endif\n@@ -1646,6 +1636,16 @@ eiisnan (x)\n   return (0);\n }\n \n+/* Return nonzero if sign of internal format number is nonzero.  */\n+\n+int \n+eiisneg (x)\n+     unsigned EMUSHORT x[];\n+{\n+\n+  return x[0] != 0;\n+}\n+\n /* Fill internal format number with infinity pattern.\n    This has maximum exponent and significand all zeros.  */\n \n@@ -2484,7 +2484,7 @@ esub (a, b, c)\n       && ((eisneg (a) ^ eisneg (b)) == 0))\n     {\n       mtherr (\"esub\", INVALID);\n-      enan (c);\n+      enan (c, 0);\n       return;\n     }\n #endif\n@@ -2522,7 +2522,7 @@ eadd (a, b, c)\n       && ((eisneg (a) ^ eisneg (b)) != 0))\n     {\n       mtherr (\"esub\", INVALID);\n-      enan (c);\n+      enan (c, 0);\n       return;\n     }\n #endif\n@@ -2665,7 +2665,7 @@ ediv (a, b, c)\n       || (eisinf (a) && eisinf (b)))\n     {\n     mtherr (\"ediv\", INVALID);\n-    enan (c);\n+    enan (c, eisneg (a) ^ eisneg (b));\n     return;\n     }\n #endif\n@@ -2773,7 +2773,7 @@ emul (a, b, c)\n       || (eisinf (b) && (ecmp (a, ezero) == 0)))\n     {\n     mtherr (\"emul\", INVALID);\n-    enan (c);\n+    enan (c, eisneg (a) ^ eisneg (b));\n     return;\n     }\n #endif\n@@ -2884,14 +2884,14 @@ e53toe (pe, y)\n       if (((pe[3] & 0xf) != 0) || (pe[2] != 0)\n \t  || (pe[1] != 0) || (pe[0] != 0))\n \t{\n-\t  enan (y);\n+\t  enan (y, yy[0] != 0);\n \t  return;\n \t}\n #else\n       if (((pe[0] & 0xf) != 0) || (pe[1] != 0)\n \t  || (pe[2] != 0) || (pe[3] != 0))\n \t{\n-\t  enan (y);\n+\t  enan (y, yy[0] != 0);\n \t  return;\n \t}\n #endif\n@@ -2984,7 +2984,7 @@ e64toe (pe, y)\n \t{\n \t  if (pe[i] != 0)\n \t    {\n-\t      enan (y);\n+\t      enan (y, (*p & 0x8000) != 0);\n \t      return;\n \t    }\n \t}\n@@ -2993,7 +2993,7 @@ e64toe (pe, y)\n \t{\n \t  if (pe[i] != 0)\n \t    {\n-\t      enan (y);\n+\t      enan (y, (*p & 0x8000) != 0);\n \t      return;\n \t    }\n \t}\n@@ -3040,7 +3040,7 @@ e113toe (pe, y)\n \t{\n \t  if (pe[i] != 0)\n \t    {\n-\t      enan (y);\n+\t      enan (y, yy[0] != 0);\n \t      return;\n \t    }\n \t}\n@@ -3049,7 +3049,7 @@ e113toe (pe, y)\n \t{\n \t  if (pe[i] != 0)\n \t    {\n-\t      enan (y);\n+\t      enan (y, yy[0] != 0);\n \t      return;\n \t    }\n \t}\n@@ -3129,13 +3129,13 @@ e24toe (pe, y)\n #ifdef MIEEE\n       if (((pe[0] & 0x7f) != 0) || (pe[1] != 0))\n \t{\n-\t  enan (y);\n+\t  enan (y, yy[0] != 0);\n \t  return;\n \t}\n #else\n       if (((pe[1] & 0x7f) != 0) || (pe[0] != 0))\n \t{\n-\t  enan (y);\n+\t  enan (y, yy[0] != 0);\n \t  return;\n \t}\n #endif\n@@ -3192,7 +3192,7 @@ etoe113 (x, e)\n #ifdef NANS\n   if (eisnan (x))\n     {\n-      make_nan (e, TFmode);\n+      make_nan (e, eisneg (x), TFmode);\n       return;\n     }\n #endif\n@@ -3222,7 +3222,7 @@ toe113 (a, b)\n #ifdef NANS\n   if (eiisnan (a))\n     {\n-      make_nan (b, TFmode);\n+      make_nan (b, eiisneg (a), TFmode);\n       return;\n     }\n #endif\n@@ -3274,7 +3274,7 @@ etoe64 (x, e)\n #ifdef NANS\n   if (eisnan (x))\n     {\n-      make_nan (e, XFmode);\n+      make_nan (e, eisneg (x), XFmode);\n       return;\n     }\n #endif\n@@ -3305,7 +3305,7 @@ toe64 (a, b)\n #ifdef NANS\n   if (eiisnan (a))\n     {\n-      make_nan (b, XFmode);\n+      make_nan (b, eiisneg (a), XFmode);\n       return;\n     }\n #endif\n@@ -3400,7 +3400,7 @@ etoe53 (x, e)\n #ifdef NANS\n   if (eisnan (x))\n     {\n-      make_nan (e, DFmode);\n+      make_nan (e, eisneg (x), DFmode);\n       return;\n     }\n #endif\n@@ -3431,7 +3431,7 @@ toe53 (x, y)\n #ifdef NANS\n   if (eiisnan (x))\n     {\n-      make_nan (y, DFmode);\n+      make_nan (y, eiisneg (x), DFmode);\n       return;\n     }\n #endif\n@@ -3539,7 +3539,7 @@ etoe24 (x, e)\n #ifdef NANS\n   if (eisnan (x))\n     {\n-      make_nan (e, SFmode);\n+      make_nan (e, eisneg (x), SFmode);\n       return;\n     }\n #endif\n@@ -3569,7 +3569,7 @@ toe24 (x, y)\n #ifdef NANS\n   if (eiisnan (x))\n     {\n-      make_nan (y, SFmode);\n+      make_nan (y, eiisneg (x), SFmode);\n       return;\n     }\n #endif\n@@ -5117,7 +5117,7 @@ eremain (a, b, c)\n       || eisnan (a)\n       || eisnan (b))\n     {\n-      enan (c);\n+      enan (c, 0);\n       return;\n     }\n #endif\n@@ -5582,14 +5582,14 @@ unsigned EMUSHORT SFnan[2] = {0, 0xffc0};\n \n \n void\n-make_nan (nan, mode)\n+make_nan (nan, sign, mode)\n unsigned EMUSHORT *nan;\n+int sign;\n enum machine_mode mode;\n {\n-  int i, n;\n+  int n;\n   unsigned EMUSHORT *p;\n \n-  n = 0;\n   switch (mode)\n     {\n /* Possibly the `reserved operand' patterns on a VAX can be\n@@ -5615,8 +5615,14 @@ enum machine_mode mode;\n     default:\n       abort ();\n     }\n-  for (i=0; i < n; i++)\n+#ifdef MIEEE\n+  *nan++ = (sign << 15) | *p++;\n+#endif\n+  while (--n != 0)\n     *nan++ = *p++;\n+#ifndef MIEEE\n+  *nan = (sign << 15) | *p;\n+#endif\n }\n \n /* Convert an SFmode target `float' value to a REAL_VALUE_TYPE.\n@@ -5961,16 +5967,13 @@ esqrt (x, y)\n   i = ecmp (x, ezero);\n   if (i <= 0)\n     {\n-#ifdef NANS\n-      if (i == -2)\n+      if (i == -1)\n \t{\n-\t  enan (y);\n-\t  return;\n+\t  mtherr (\"esqrt\", DOMAIN);\n+\t  eclear (y);\n \t}\n-#endif\n-      eclear (y);\n-      if (i < 0)\n-\tmtherr (\"esqrt\", DOMAIN);\n+      else\n+\temov (x, y);\n       return;\n     }\n "}]}