{"sha": "6d3d91336c1a1e9b7e6d742a967a13ac799437b0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmQzZDkxMzM2YzFhMWU5YjdlNmQ3NDJhOTY3YTEzYWM3OTk0MzdiMA==", "commit": {"author": {"name": "Nick Clifton", "email": "nickc@redhat.com", "date": "2000-12-08T19:25:33Z"}, "committer": {"name": "Nick Clifton", "email": "nickc@gcc.gnu.org", "date": "2000-12-08T19:25:33Z"}, "message": "Add support for interrupt function attribute\n\nFrom-SVN: r38134", "tree": {"sha": "c11994311174f3c3145a04a55414654bfaf86159", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c11994311174f3c3145a04a55414654bfaf86159"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6d3d91336c1a1e9b7e6d742a967a13ac799437b0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d3d91336c1a1e9b7e6d742a967a13ac799437b0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6d3d91336c1a1e9b7e6d742a967a13ac799437b0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d3d91336c1a1e9b7e6d742a967a13ac799437b0/comments", "author": {"login": "nickclifton", "id": 31441682, "node_id": "MDQ6VXNlcjMxNDQxNjgy", "avatar_url": "https://avatars.githubusercontent.com/u/31441682?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nickclifton", "html_url": "https://github.com/nickclifton", "followers_url": "https://api.github.com/users/nickclifton/followers", "following_url": "https://api.github.com/users/nickclifton/following{/other_user}", "gists_url": "https://api.github.com/users/nickclifton/gists{/gist_id}", "starred_url": "https://api.github.com/users/nickclifton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nickclifton/subscriptions", "organizations_url": "https://api.github.com/users/nickclifton/orgs", "repos_url": "https://api.github.com/users/nickclifton/repos", "events_url": "https://api.github.com/users/nickclifton/events{/privacy}", "received_events_url": "https://api.github.com/users/nickclifton/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2bff3fd5272ea60a55570812b780ddef91bc45d0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2bff3fd5272ea60a55570812b780ddef91bc45d0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2bff3fd5272ea60a55570812b780ddef91bc45d0"}], "stats": {"total": 1182, "additions": 735, "deletions": 447}, "files": [{"sha": "7539396c332be975e3fdf6da010947518946a047", "filename": "gcc/ChangeLog", "status": "modified", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d3d91336c1a1e9b7e6d742a967a13ac799437b0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d3d91336c1a1e9b7e6d742a967a13ac799437b0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6d3d91336c1a1e9b7e6d742a967a13ac799437b0", "patch": "@@ -1,3 +1,58 @@\n+2000-12-08  Nick Clifton  <nickc@redhat.com>\n+\n+\t* extend.texi: Document ARM \"interrupt\" function attribute.\n+\tMention that the ARM also support the \"naked\" function\n+\tattribute.\n+\n+\t* config/arm/arm-protos.h (arm_current_func_type): Add\n+\tprototype.\n+\n+\t* config/arm/arm.h (EXCEPTION_LR_REGNUM): Define.\n+\t(struct machine_function): Add 'func_type' field.\n+\tDefine bit values for 'func_type' field.\n+\t(ARM_FUNC_TYPE): New macro.\n+\t(IS_INTERRUPT): New macro.\n+\t(IS_VOLATILE): New macro.\n+\t(IS_NAKED): New macro.\n+\t(IS_NESTED): New macro.\n+\t(ARM_INITIAL_ELIMINATION_OFFSET): Use IS_VOLATILE.\n+\n+\t* config/arm/arm.c (isr_attribute_args): New Structure.  A\n+\tlist of \"interrupt\" function attribute modifiers.\n+\t(arm_isr_value): New Function: Returns the type of the current\n+\tinterrupt function.\n+\t(arm_compute_func_type): New Function: Computes the type of\n+\tthe current function.\n+\t(arm_current_func_type): New Function: Returns the type of the\n+\tcurrent function.\n+\t(use_return_insn): Use arm_current_func_type.\n+\t(arm_valid_type_attribute_p): Accept \"interrupt\" function\n+\tattribute.\n+\t(arm_comp_type_attributes): Check \"interrupt\" attributes.\n+\t(arm_valid_machine_decl): Accept \"interrupt\" function\n+\tattribute.\n+\t(arm_function_ok_for_sibcall): Do not allow interrupt\n+\tfunctions to use sibcalls.\n+\t(arm_naked_function_p): Delete.\n+\t(print_multi_reg): Remove redundant parameter 'hat'.\n+\t(arm_compute_save_reg_mask): New Function: Compute a bit mask\n+\tof registers saved during the current function's prologue.\n+\t(output_arm_return_instruction): Use arm_current_func_type.\n+\tGenerate return instruction when LR is not poppsed off the\n+\tstack.\n+\t(arm_volatile_func): Delete.\n+\t(output_arm_prologue): Use arm_current_func_type and\n+\tarm_compute_save_reg_mask.\n+\tNote presernce of interrupt functions.\n+\t(arm_output_epilogue): Use arm_current_func_type and\n+\tarm_compute_save_reg_mask.\n+\t(arm_expand_prologue): Use arm_current_func_type and\n+\tarm_compute_save_reg_mask.\n+\t(arm_init_machine_status): Initialise func_type field, if\n+\tnecessary.\n+\t(thumb_expand_prologue): Use arm_current_func_type.\n+\t(output_thumb_prologue): Use arm_current_func_type.\n+\n 2000-12-08  Brad Lucier <lucier@math.purdue.edu>\n \n         * tradcpp.c (do_include): Make pointer differences 64-bit clean."}, {"sha": "ac3713adda063a9668943be3904ac76598373470", "filename": "gcc/config/arm/arm-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d3d91336c1a1e9b7e6d742a967a13ac799437b0/gcc%2Fconfig%2Farm%2Farm-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d3d91336c1a1e9b7e6d742a967a13ac799437b0/gcc%2Fconfig%2Farm%2Farm-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-protos.h?ref=6d3d91336c1a1e9b7e6d742a967a13ac799437b0", "patch": "@@ -34,6 +34,7 @@ extern void   arm_expand_prologue\tPARAMS ((void));\n /* Used in arm.md, but defined in output.c.  */\n extern void   assemble_align\t\tPARAMS ((int)); \n extern const char * arm_strip_name_encoding\tPARAMS ((const char *));\n+extern unsigned long arm_current_func_type\tPARAMS ((void));\n \n #ifdef TREE_CODE\n extern int    arm_return_in_memory\tPARAMS ((tree));"}, {"sha": "b0021328a720ac100e6a32ee537f12a23dfcdf97", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 607, "deletions": 424, "changes": 1031, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d3d91336c1a1e9b7e6d742a967a13ac799437b0/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d3d91336c1a1e9b7e6d742a967a13ac799437b0/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=6d3d91336c1a1e9b7e6d742a967a13ac799437b0", "patch": "@@ -55,32 +55,32 @@ typedef struct minipool_fixup   Mfix;\n #define Hint     HOST_WIDE_INT\n #define Mmode    enum machine_mode\n #define Ulong    unsigned long\n+#define Ccstar   const char *\n \n /* Forward function declarations.  */\n static void      arm_add_gc_roots \t\tPARAMS ((void));\n static int       arm_gen_constant\t\tPARAMS ((enum rtx_code, Mmode, Hint, rtx, rtx, int, int));\n-static int       arm_naked_function_p\t\tPARAMS ((tree));\n static Ulong     bit_count \t\t\tPARAMS ((signed int));\n static int       const_ok_for_op \t\tPARAMS ((Hint, enum rtx_code));\n static int       eliminate_lr2ip\t\tPARAMS ((rtx *));\n static rtx\t emit_multi_reg_push\t\tPARAMS ((int));\n static rtx\t emit_sfm\t\t\tPARAMS ((int, int));\n-static const char * fp_const_from_val\t\tPARAMS ((REAL_VALUE_TYPE *));\n+static Ccstar    fp_const_from_val\t\tPARAMS ((REAL_VALUE_TYPE *));\n static arm_cc    get_arm_condition_code\t\tPARAMS ((rtx));\n static void      init_fpa_table\t\t\tPARAMS ((void));\n static Hint      int_log2\t\t\tPARAMS ((Hint));\n static rtx       is_jump_table \t\t\tPARAMS ((rtx));\n-static const char * output_multi_immediate\tPARAMS ((rtx *, const char *, const char *, int, Hint));\n-static void      print_multi_reg\t\tPARAMS ((FILE *, const char *, int, int, int));\n+static Ccstar    output_multi_immediate\t\tPARAMS ((rtx *, Ccstar, Ccstar, int, Hint));\n+static void      print_multi_reg\t\tPARAMS ((FILE *, Ccstar, int, int));\n static Mmode     select_dominance_cc_mode\tPARAMS ((rtx, rtx, Hint));\n-static const char * shift_op\t\t\tPARAMS ((rtx, Hint *));\n+static Ccstar    shift_op\t\t\tPARAMS ((rtx, Hint *));\n static void      arm_init_machine_status\tPARAMS ((struct function *));\n static void      arm_mark_machine_status        PARAMS ((struct function *));\n static int       number_of_first_bit_set        PARAMS ((int));\n static void      replace_symbols_in_block       PARAMS ((tree, rtx, rtx));\n static void      thumb_exit                     PARAMS ((FILE *, int, rtx));\n static void      thumb_pushpop                  PARAMS ((FILE *, int, int));\n-static const char * thumb_condition_code        PARAMS ((rtx, int));\n+static Ccstar    thumb_condition_code           PARAMS ((rtx, int));\n static rtx\t is_jump_table\t\t        PARAMS ((rtx));\n static Hint\t get_jump_table_size\t        PARAMS ((rtx));\n static Mnode *   move_minipool_fix_forward_ref  PARAMS ((Mnode *, Mnode *, Hint));\n@@ -96,10 +96,14 @@ static void\t push_minipool_barrier\t        PARAMS ((rtx, Hint));\n static void\t push_minipool_fix\t\tPARAMS ((rtx, Hint, rtx *, Mmode, rtx));\n static void\t note_invalid_constants\t        PARAMS ((rtx, Hint));\n static int       current_file_function_operand\tPARAMS ((rtx));\n+static Ulong     arm_compute_save_reg_mask\tPARAMS ((void));\n+static Ulong     arm_isr_value \t\t\tPARAMS ((tree));\n+static Ulong     arm_compute_func_type\t\tPARAMS ((void));\n \f\n #undef Hint\n #undef Mmode\n #undef Ulong\n+#undef Ccstar\n \n /* Obstack for minipool constant handling.  */\n static struct obstack minipool_obstack;\n@@ -683,26 +687,150 @@ arm_add_gc_roots ()\n {\n   ggc_add_rtx_root (&arm_compare_op0, 1);\n   ggc_add_rtx_root (&arm_compare_op1, 1);\n-  ggc_add_rtx_root (&arm_target_insn, 1); /* Not sure this is really a root */\n+  ggc_add_rtx_root (&arm_target_insn, 1); /* Not sure this is really a root.  */\n \n   gcc_obstack_init(&minipool_obstack);\n   minipool_startobj = (char *) obstack_alloc (&minipool_obstack, 0);\n }\n \f\n+/* A table of known ARM exception types.\n+   For use with the interrupt function attribute.  */\n+\n+typedef struct\n+{\n+  const char * \targ;\n+  unsigned long\treturn_value;\n+}\n+isr_attribute_arg;\n+\n+static isr_attribute_arg isr_attribute_args [] =\n+{\n+  { \"IRQ\",   ARM_FT_ISR },\n+  { \"irq\",   ARM_FT_ISR },\n+  { \"FIQ\",   ARM_FT_FIQ },\n+  { \"fiq\",   ARM_FT_FIQ },\n+  { \"ABORT\", ARM_FT_ISR },\n+  { \"abort\", ARM_FT_ISR },\n+  { \"ABORT\", ARM_FT_ISR },\n+  { \"abort\", ARM_FT_ISR },\n+  { \"UNDEF\", ARM_FT_EXCEPTION },\n+  { \"undef\", ARM_FT_EXCEPTION },\n+  { \"SWI\",   ARM_FT_EXCEPTION },\n+  { \"swi\",   ARM_FT_EXCEPTION },\n+  { NULL,    ARM_FT_NORMAL }\n+};\n+\n+/* Returns the (interrupt) function type of the current\n+   function, or ARM_FT_UNKNOWN if the type cannot be determined.  */\n+\n+static unsigned long\n+arm_isr_value (argument)\n+     tree argument;\n+{\n+  isr_attribute_arg * ptr;\n+  const char *        arg;\n+\n+  /* No argument - default to IRQ.  */\n+  if (argument == NULL_TREE)\n+    return ARM_FT_ISR;\n+\n+  /* Get the value of the argument.  */\n+  if (TREE_VALUE (argument) == NULL_TREE\n+      || TREE_CODE (TREE_VALUE (argument)) != STRING_CST)\n+    return ARM_FT_UNKNOWN;\n+\n+  arg = TREE_STRING_POINTER (TREE_VALUE (argument));\n+\n+  /* Check it against the list of known arguments.  */\n+  for (ptr = isr_attribute_args; ptr->arg != NULL; ptr ++)\n+    if (strcmp (arg, ptr->arg) == 0)\n+\treturn ptr->return_value;\n+\n+  /* An unrecognised interrupt type.  */\n+  return ARM_FT_UNKNOWN;\n+}\n+\n+/* Computes the type of the current function.  */\n+\n+static unsigned long\n+arm_compute_func_type ()\n+{\n+  unsigned long type = ARM_FT_UNKNOWN;\n+  tree a;\n+  tree attr;\n+  \n+  if (TREE_CODE (current_function_decl) != FUNCTION_DECL)\n+    abort ();\n+\n+  /* Decide if the current function is volatile.  Such functions\n+     never return, and many memory cycles can be saved by not storing\n+     register values that will never be needed again.  This optimization\n+     was added to speed up context switching in a kernel application.  */\n+  if (optimize > 0\n+      && current_function_nothrow\n+      && TREE_THIS_VOLATILE (current_function_decl))\n+    type |= ARM_FT_VOLATILE;\n+  \n+  if (current_function_needs_context)\n+    type |= ARM_FT_NESTED;\n+\n+  attr = DECL_MACHINE_ATTRIBUTES (current_function_decl);\n+  \n+  a = lookup_attribute (\"naked\", attr);\n+  if (a != NULL_TREE)\n+    type |= ARM_FT_NAKED;\n+\n+  if (cfun->machine->eh_epilogue_sp_ofs != NULL_RTX)\n+    type |= ARM_FT_EXCEPTION_HANDLER;\n+  else\n+    {\n+      a = lookup_attribute (\"isr\", attr);\n+      if (a == NULL_TREE)\n+\ta = lookup_attribute (\"interrupt\", attr);\n+      \n+      if (a == NULL_TREE)\n+\ttype |= TARGET_INTERWORK ? ARM_FT_INTERWORKED : ARM_FT_NORMAL;\n+      else\n+\ttype |= arm_isr_value (TREE_VALUE (a));\n+    }\n+  \n+  return type;\n+}\n+\n+/* Returns the type of the current function.  */\n+\n+unsigned long\n+arm_current_func_type ()\n+{\n+  if (ARM_FUNC_TYPE (cfun->machine->func_type) == ARM_FT_UNKNOWN)\n+    cfun->machine->func_type = arm_compute_func_type ();\n+\n+  return cfun->machine->func_type;\n+}\n+\f\n /* Return 1 if it is possible to return using a single instruction.  */\n+\n int\n use_return_insn (iscond)\n      int iscond;\n {\n   int regno;\n+  unsigned int func_type = arm_current_func_type ();\n \n   /* Never use a return instruction before reload has run.  */\n-  if (!reload_completed\n-      /* Or if the function is variadic.  */\n-      || current_function_pretend_args_size\n+  if (!reload_completed)\n+    return 0;\n+      \n+  /* Naked functions, volatile functiond and interrupt\n+     functions all need special consideration.  */\n+  if (func_type & (ARM_FT_INTERRUPT | ARM_FT_VOLATILE | ARM_FT_NAKED))\n+    return 0;\n+  \n+  /* As do variadic functions.  */\n+  if (current_function_pretend_args_size\n       || current_function_anonymous_args\n       /* Of if the function calls __builtin_eh_return () */\n-      || cfun->machine->eh_epilogue_sp_ofs != NULL\n+      || ARM_FUNC_TYPE (func_type) == ARM_FT_EXCEPTION_HANDLER\n       /* Or if there is no frame pointer and there is a stack adjustment.  */\n       || ((get_frame_size () + current_function_outgoing_args_size != 0)\n \t  && !frame_pointer_needed))\n@@ -725,17 +853,13 @@ use_return_insn (iscond)\n \treturn 0;\n     }\n       \n-  /* Can't be done if any of the FPU regs are pushed, since this also\n-     requires an insn.  */\n+  /* Can't be done if any of the FPU regs are pushed,\n+     since this also requires an insn.  */\n   if (TARGET_HARD_FLOAT)\n     for (regno = FIRST_ARM_FP_REGNUM; regno <= LAST_ARM_FP_REGNUM; regno++)\n       if (regs_ever_live[regno] && !call_used_regs[regno])\n \treturn 0;\n \n-  /* If a function is naked, don't use the \"return\" insn.  */\n-  if (arm_naked_function_p (current_function_decl))\n-    return 0;\n-\n   return 1;\n }\n \n@@ -1685,6 +1809,11 @@ arm_valid_type_attribute_p (type, attributes, identifier, args)\n   if (is_attribute_p (\"short_call\", identifier))\n     return (args == NULL_TREE);\n   \n+  /* Interrupt Service Routines have special prologue and epilogue requirements.  */ \n+  if (is_attribute_p (\"isr\", identifier)\n+      || is_attribute_p (\"interrupt\", identifier))\n+    return arm_isr_value (args);\n+\n   return 0;\n }\n \n@@ -1720,6 +1849,16 @@ arm_comp_type_attributes (type1, type2)\n \treturn 0;\n     }\n   \n+  /* Check for mismatched ISR attribute.  */\n+  l1 = lookup_attribute (\"isr\", TYPE_ATTRIBUTES (type1)) != NULL;\n+  if (! l1)\n+    l1 = lookup_attribute (\"interrupt\", TYPE_ATTRIBUTES (type1)) != NULL;\n+  l2 = lookup_attribute (\"isr\", TYPE_ATTRIBUTES (type2)) != NULL;\n+  if (! l2)\n+    l1 = lookup_attribute (\"interrupt\", TYPE_ATTRIBUTES (type2)) != NULL;\n+  if (l1 != l2)\n+    return 0;\n+\n   return 1;\n }\n \n@@ -1745,7 +1884,7 @@ arm_encode_call_attribute (decl, flag)\n   newstr[0] = flag;\n   strcpy (newstr + 1, str);\n \n-  newstr = ggc_alloc_string (newstr, len + 1);\n+  newstr = (char *) ggc_alloc_string (newstr, len + 1);\n   XSTR (XEXP (DECL_RTL (decl), 0), 0) = newstr;\n }\n \n@@ -1882,6 +2021,10 @@ arm_function_ok_for_sibcall (decl)\n   if (TARGET_INTERWORK && TREE_PUBLIC (decl) && !TREE_ASM_WRITTEN (decl))\n     return 0;\n \n+  /* Never tailcall from an ISR routine - it needs a special exit sequence.  */\n+  if (IS_INTERRUPT (arm_current_func_type ()))\n+    return 0;\n+\n   /* Everything else is ok.  */\n   return 1;\n }\n@@ -3862,6 +4005,9 @@ multi_register_push (op, mode)\n      don't output any prologue or epilogue code, the user is assumed\n      to do the right thing.\n    \n+   isr or interrupt:\n+     Interrupt Service Routine.\n+\n    interfacearm:\n      Always assume that this function will be entered in ARM mode,\n      not Thumb mode, and that the caller wishes to be returned to in\n@@ -3872,6 +4018,12 @@ arm_valid_machine_decl_attribute (decl, attr, args)\n      tree attr;\n      tree args;\n {\n+  /* The interrupt attribute can take args, so check for it before\n+     rejecting other attributes on the grounds that they did have args.  */\n+  if (is_attribute_p (\"isr\", attr)\n+      || is_attribute_p (\"interrupt\", attr))\n+    return TREE_CODE (decl) == FUNCTION_DECL;\n+\n   if (args != NULL_TREE)\n     return 0;\n \n@@ -3885,20 +4037,6 @@ arm_valid_machine_decl_attribute (decl, attr, args)\n   \n   return 0;\n }\n-\n-/* Return non-zero if FUNC is a naked function.  */\n-static int\n-arm_naked_function_p (func)\n-     tree func;\n-{\n-  tree a;\n-\n-  if (TREE_CODE (func) != FUNCTION_DECL)\n-    abort ();\n-  \n-  a = lookup_attribute (\"naked\", DECL_MACHINE_ATTRIBUTES (func));\n-  return a != NULL_TREE;\n-}\n \f\n /* Routines for use in generating RTL.  */\n rtx\n@@ -5895,16 +6033,15 @@ fp_const_from_val (r)\n \n /* Output the operands of a LDM/STM instruction to STREAM.\n    MASK is the ARM register set mask of which only bits 0-15 are important.\n-   INSTR is the possibly suffixed base register.  HAT unequals zero if a hat\n-   must follow the register list.  */\n+   REG is the base register, either the frame pointer or the stack pointer,\n+   INSTR is the possibly suffixed load or store instruction.  */\n \n static void\n-print_multi_reg (stream, instr, reg, mask, hat)\n+print_multi_reg (stream, instr, reg, mask)\n      FILE * stream;\n      const char * instr;\n      int reg;\n      int mask;\n-     int hat;\n {\n   int i;\n   int not_first = FALSE;\n@@ -5923,7 +6060,7 @@ print_multi_reg (stream, instr, reg, mask, hat)\n \tnot_first = TRUE;\n       }\n \n-  fprintf (stream, \"}%s\\n\", hat ? \"^\" : \"\");\n+  fprintf (stream, \"}%s\\n\", TARGET_APCS_32 ? \"\" : \"^\");\n }\n \n /* Output a 'call' insn.  */\n@@ -6694,24 +6831,105 @@ output_ascii_pseudo_op (stream, p, len)\n   fputs (\"\\\"\\n\", stream);\n }\n \f\n+/* Compute a bit mask of which registers need to be\n+   saved on the stack for the current function.  */\n+\n+static unsigned long\n+arm_compute_save_reg_mask ()\n+{\n+  unsigned int save_reg_mask = 0;\n+  unsigned int reg;\n+  unsigned long func_type = arm_current_func_type ();\n+\n+  if (IS_NAKED (func_type))\n+    /* This should never really happen.  */\n+    return 0;\n+\n+  /* If we are creating a stack frame, then we must save the frame pointer,\n+     IP (which will hold the old stack pointer), LR and the PC.  */\n+  if (frame_pointer_needed)\n+    save_reg_mask |=\n+      (1 << ARM_HARD_FRAME_POINTER_REGNUM)\n+      | (1 << IP_REGNUM)\n+      | (1 << LR_REGNUM)\n+      | (1 << PC_REGNUM);\n+\n+  /* Volatile functions do not return, so there\n+     is no need to save any other registers.  */\n+  if (IS_VOLATILE (func_type))\n+    return save_reg_mask;\n+\n+  if (ARM_FUNC_TYPE (func_type) == ARM_FT_ISR)\n+    {\n+      /* FIQ handlers have registers r8 - r12 banked, so\n+\t we only need to check r0 - r7, they must save them.  */\n+      for (reg = 0; reg < 8; reg++)\n+\tif (regs_ever_live[reg])\n+\t  save_reg_mask |= (1 << reg);\n+    }\n+  else\n+    {\n+      /* In the normal case we only need to save those registers\n+\t which are call saved and which are used by this function.  */\n+      for (reg = 0; reg <= 10; reg++)\n+\tif (regs_ever_live[reg] && ! call_used_regs [reg])\n+\t  save_reg_mask |= (1 << reg);\n+\n+      /* Handle the frame pointer as a special case.  */\n+      if (! TARGET_APCS_FRAME\n+\t  && ! frame_pointer_needed\n+\t  && regs_ever_live[HARD_FRAME_POINTER_REGNUM]\n+\t  && ! call_used_regs[HARD_FRAME_POINTER_REGNUM])\n+\tsave_reg_mask |= 1 << HARD_FRAME_POINTER_REGNUM;\n+\n+      /* If we aren't loading the PIC register,\n+\t don't stack it even though it may be live.  */\n+      if (flag_pic\n+\t  && ! TARGET_SINGLE_PIC_BASE \n+\t  && regs_ever_live[PIC_OFFSET_TABLE_REGNUM])\n+\tsave_reg_mask |= 1 << PIC_OFFSET_TABLE_REGNUM;\n+    }\n+\n+  /* Decide if we need to save the link register.\n+     Interrupt routines have their own banked link register,\n+     so they never need to save it.\n+     Otheriwse if we do not use the link register we do not need to save\n+     it.  If we are pushing other registers onto the stack however, we\n+     can save an instruction in the epilogue by pushing the link register\n+     now and then popping it back into the PC.  This incurs extra memory\n+     accesses though, so we only do it when optimising for size, and only\n+     if we know that we will not need a fancy return sequence.  */\n+  if (! IS_INTERRUPT (func_type)\n+      && (regs_ever_live [LR_REGNUM]\n+\t  || (save_reg_mask\n+\t      && optimize_size\n+\t      && ARM_FUNC_TYPE (func_type) == ARM_FT_NORMAL)))\n+    save_reg_mask |= 1 << LR_REGNUM;\n+\n+  return save_reg_mask;\n+}\n+\n+/* Generate a function exit sequence.  If REALLY_RETURN is true, then do\n+   everything bar the final return instruction.  */\n \n const char *\n output_return_instruction (operand, really_return, reverse)\n      rtx operand;\n      int really_return;\n      int reverse;\n {\n+  char conditional[10];\n   char instr[100];\n-  int reg, live_regs = 0;\n-  int volatile_func = arm_volatile_func ();\n+  int reg;\n+  unsigned long live_regs_mask;\n+  unsigned long func_type;\n+  \n+  func_type = arm_current_func_type ();\n \n-  /* If a function is naked, don't use the \"return\" insn.  */\n-  if (arm_naked_function_p (current_function_decl))\n+  if (IS_NAKED (func_type))\n     return \"\";\n-  \n-  return_used_this_function = 1;\n-  \n-  if (TARGET_ABORT_NORETURN && volatile_func)\n+\n+  if (IS_VOLATILE (func_type) && TARGET_ABORT_NORETURN)\n     {\n       /* If this function was declared non-returning, and we have found a tail \n \t call, then we have to trust that the called function won't return.  */\n@@ -6729,137 +6947,163 @@ output_return_instruction (operand, really_return, reverse)\n       \n       return \"\";\n     }\n-      \n+\n   if (current_function_calls_alloca && !really_return)\n     abort ();\n-  \n-  for (reg = 0; reg <= 10; reg++)\n-    if (regs_ever_live[reg] && !call_used_regs[reg])\n-      live_regs++;\n \n-  if (!TARGET_APCS_FRAME\n-      && !frame_pointer_needed\n-      && regs_ever_live[HARD_FRAME_POINTER_REGNUM]\n-      && !call_used_regs[HARD_FRAME_POINTER_REGNUM])\n-    live_regs++;\n+  /* Construct the conditional part of the instruction(s) to be emitted.  */\n+  sprintf (conditional, \"%%?%%%c0\", reverse ? 'D' : 'd');\n \n-  if (flag_pic && !TARGET_SINGLE_PIC_BASE\n-      && regs_ever_live[PIC_OFFSET_TABLE_REGNUM])\n-    live_regs++;\n-\n-  if (live_regs || regs_ever_live[LR_REGNUM])\n-    live_regs++;\n+  return_used_this_function = 1;\n \n-  if (frame_pointer_needed)\n-    live_regs += 4;\n+  live_regs_mask = arm_compute_save_reg_mask ();\n \n   /* On some ARM architectures it is faster to use LDR rather than LDM to\n-     load a single register.  On other architectures, the cost is the same.  */\n-  if (live_regs == 1\n-      && regs_ever_live[LR_REGNUM]\n-      && !really_return)\n-    output_asm_insn (reverse ? \"ldr%?%D0\\t%|lr, [%|sp], #4\" \n-\t\t     : \"ldr%?%d0\\t%|lr, [%|sp], #4\", &operand);\n-  else if (live_regs == 1\n-\t   && regs_ever_live[LR_REGNUM]\n-\t   && TARGET_APCS_32)\n-    output_asm_insn (reverse ? \"ldr%?%D0\\t%|pc, [%|sp], #4\"\n-\t\t     : \"ldr%?%d0\\t%|pc, [%|sp], #4\", &operand);\n-  else if (live_regs)\n-    {\n-      if (!regs_ever_live[LR_REGNUM])\n-        live_regs++;\n+     load a single register.  On other architectures, the cost is the same.\n+     In 26 bit mode we have to use LDM in order to be able to restore the CPSR.  */\n+  if ((live_regs_mask  == (1 << LR_REGNUM))\n+      && (! really_return || TARGET_APCS_32))\n+    {\n+      if (! really_return)\n+\tsprintf (instr, \"ldr%s\\t%%|lr, [%%|sp], #4\", conditional);\n+      else\n+\tsprintf (instr, \"ldr%s\\t%%|pc, [%%|sp], #4\", conditional);\n+    }\n+  else if (live_regs_mask)\n+    {\n+      if ((live_regs_mask & (1 << IP_REGNUM)) == (1 << IP_REGNUM))\n+\t/* There are two possible reasons for the IP register being saved.\n+\t   Either a stack frame was created, in which case IP contains the\n+\t   old stack pointer, or an ISR routine corrupted it.  If this in an\n+\t   ISR routine then just restore IP, otherwise restore IP into SP.  */\n+\tif (! IS_INTERRUPT (func_type))\n+\t  {\n+\t    live_regs_mask &= ~ (1 << IP_REGNUM);\n+\t    live_regs_mask |=   (1 << SP_REGNUM);\n+\t  }\n \n+      /* Generate the load multiple instruction to restore the registers.  */\n       if (frame_pointer_needed)\n-        strcpy (instr,\n-\t\treverse ? \"ldm%?%D0ea\\t%|fp, {\" : \"ldm%?%d0ea\\t%|fp, {\");\n+\tsprintf (instr, \"ldm%sea\\t%%|fp, {\", conditional);\n       else\n-        strcpy (instr, \n-\t\treverse ? \"ldm%?%D0fd\\t%|sp!, {\" : \"ldm%?%d0fd\\t%|sp!, {\");\n+\tsprintf (instr, \"ldm%sfd\\t%%|sp!, {\", conditional);\n \n-      for (reg = 0; reg <= 10; reg++)\n-        if (regs_ever_live[reg]\n-\t    && (!call_used_regs[reg]\n-\t\t|| (flag_pic && !TARGET_SINGLE_PIC_BASE\n-\t\t    && reg == PIC_OFFSET_TABLE_REGNUM)))\n-          {\n+      for (reg = 0; reg <= SP_REGNUM; reg++)\n+\tif (live_regs_mask & (1 << reg))\n+\t  {\n \t    strcat (instr, \"%|\");\n-            strcat (instr, reg_names[reg]);\n-\t    if (--live_regs)\n-              strcat (instr, \", \");\n-          }\n+\t    strcat (instr, reg_names[reg]);\n+\t    strcat (instr, \", \");\n+\t  }\n \n-      if (frame_pointer_needed)\n-        {\n-\t  strcat (instr, \"%|\");\n-          strcat (instr, reg_names[11]);\n-          strcat (instr, \", \");\n-\t  strcat (instr, \"%|\");\n-          strcat (instr, reg_names[13]);\n-          strcat (instr, \", \");\n-\t  strcat (instr, \"%|\");\n-\t  strcat (instr, TARGET_INTERWORK || (!really_return)\n-\t\t  ? reg_names[LR_REGNUM] : reg_names[PC_REGNUM] );\n-        }\n+      if ((live_regs_mask & (1 << LR_REGNUM)) == 0)\n+\t{\n+\t  /* If we are not restoring the LR register then we will\n+\t     have added one too many commas to the list above.\n+\t     Replace it with a closing brace.  */\n+\t  instr [strlen (instr) - 2] =  '}';\n+\t}\n       else\n \t{\n-\t  if (!TARGET_APCS_FRAME\n-\t      && regs_ever_live[HARD_FRAME_POINTER_REGNUM]\n-\t      && !call_used_regs[HARD_FRAME_POINTER_REGNUM])\n-\t    {\n-\t      strcat (instr, \"%|\");\n-\t      strcat (instr, reg_names[HARD_FRAME_POINTER_REGNUM]);\n-\t      strcat (instr, \", \");\n-\t    }\n-\t  \n \t  strcat (instr, \"%|\");\n-\t  \n-\t  if (TARGET_INTERWORK && really_return)\n-\t    strcat (instr, reg_names[IP_REGNUM]);\n+\n+\t  /* At this point there should only be one or two registers left in\n+\t     live_regs_mask: always LR, and possibly PC if we created a stack\n+\t     frame.  LR contains the return address.  If we do not have any\n+\t     special requirements for function exit (eg interworking, or ISR)\n+\t     then we can load this value directly into the PC and save an\n+\t     instruction.  */\n+\t  if (! TARGET_INTERWORK\n+\t      && ! IS_INTERRUPT (func_type)\n+\t      && really_return)\n+\t    strcat (instr, reg_names [PC_REGNUM]);\n \t  else\n-\t    strcat (instr, really_return ? reg_names[PC_REGNUM] : reg_names[LR_REGNUM]);\n+\t    strcat (instr, reg_names [LR_REGNUM]);\n+\n+\t  strcat (instr, (TARGET_APCS_32 || !really_return) ? \"}\" : \"}^\");\n \t}\n-      \n-      strcat (instr, (TARGET_APCS_32 || !really_return) ? \"}\" : \"}^\");\n-      output_asm_insn (instr, &operand);\n \n-      if (TARGET_INTERWORK && really_return)\n+      if (really_return)\n \t{\n-\t  strcpy (instr, \"bx%?\");\n-\t  strcat (instr, reverse ? \"%D0\" : \"%d0\");\n-\t  strcat (instr, \"\\t%|\");\n-\t  strcat (instr, frame_pointer_needed ? \"lr\" : \"ip\");\n+\t  /* See if we need to generate an extra instruction to\n+\t     perform the actual function return.  */\n+\t  switch ((int) ARM_FUNC_TYPE (func_type))\n+\t    {\n+\t    case ARM_FT_ISR:\n+\t    case ARM_FT_FIQ:\n+\t      output_asm_insn (instr, & operand);\n+\n+\t      strcpy (instr, \"sub\");\n+\t      strcat (instr, conditional);\n+\t      strcat (instr, \"s\\t%|pc, %|lr, #4\");\n+\t      break;\n+\n+\t    case ARM_FT_EXCEPTION:\n+\t      output_asm_insn (instr, & operand);\n+\n+\t      strcpy (instr, \"mov\");\n+\t      strcat (instr, conditional);\n+\t      strcat (instr, \"s\\t%|pc, %|lr\");\n+\t      break;\n+\n+\t    case ARM_FT_INTERWORKED:\n+\t      output_asm_insn (instr, & operand);\n+\n+\t      strcpy (instr, \"bx\");\n+\t      strcat (instr, conditional);\n+\t      strcat (instr, \"\\t%|lr\");\n+\t      break;\n \n-\t  output_asm_insn (instr, &operand);\n+\t    default:\n+\t      /* The return has already been handled\n+\t\t by loading the LR into the PC.  */\n+\t      if ((live_regs_mask & (1 << LR_REGNUM)) == 0)\n+\t\t{\n+\t\t  output_asm_insn (instr, & operand);\n+\n+\t\t  strcpy (instr, \"mov\");\n+\t\t  strcat (instr, conditional);\n+\t\t  if (! TARGET_APCS_32)\n+\t\t    strcat (instr, \"s\");\n+\t\t  strcat (instr, \"\\t%|pc, %|lr\");\n+\t\t}\n+\t      break;\n+\t    }\n \t}\n     }\n   else if (really_return)\n     {\n-      if (TARGET_INTERWORK)\n-\tsprintf (instr, \"bx%%?%%%s0\\t%%|lr\", reverse ? \"D\" : \"d\");\n-      else\n-\tsprintf (instr, \"mov%%?%%%s0%s\\t%%|pc, %%|lr\",\n-\t\t reverse ? \"D\" : \"d\", TARGET_APCS_32 ? \"\" : \"s\");\n-      \n-      output_asm_insn (instr, &operand);\n+      switch ((int) ARM_FUNC_TYPE (func_type))\n+\t{\n+\tcase ARM_FT_ISR:\n+\tcase ARM_FT_FIQ:\n+\t  sprintf (instr, \"sub%ss\\t%%|pc, %%|lr, #4\", conditional);\n+\t  break;\n+\n+\tcase ARM_FT_INTERWORKED:\n+\t  sprintf (instr, \"bx%s\\t%%|lr\", conditional);\n+\t  break;\n+\n+\tcase ARM_FT_EXCEPTION:\n+\t  sprintf (instr, \"mov%ss\\t%%|pc, %%|lr\", conditional);\n+\t  break;\n+\n+\tdefault:\n+\t  sprintf (instr, \"mov%s%s\\t%%|pc, %%|lr\",\n+\t\t   conditional, TARGET_APCS_32 ? \"\" : \"s\");\n+\t  break;\n+\t}\n     }\n+  else\n+    /* Nothing to load off the stack, and\n+       no return instruction to generate.  */\n+    return \"\";\n \n+  output_asm_insn (instr, & operand);\n+      \n   return \"\";\n }\n \n-/* Return nonzero if optimizing and the current function is volatile.\n-   Such functions never return, and many memory cycles can be saved\n-   by not storing register values that will never be needed again.\n-   This optimization was added to speed up context switching in a\n-   kernel application.  */\n-int\n-arm_volatile_func ()\n-{\n-  return (optimize > 0\n-\t  && current_function_nothrow\n-\t  && TREE_THIS_VOLATILE (current_function_decl));\n-}\n-\n /* Write the function name into the code section, directly preceding\n    the function prologue.\n \n@@ -6905,151 +7149,119 @@ arm_poke_function_name (stream, name)\n   ASM_OUTPUT_INT (stream, x);\n }\n \n-/* The amount of stack adjustment that happens here, in output_return and in\n-   output_epilogue must be exactly the same as was calculated during reload,\n-   or things will point to the wrong place.  The only time we can safely\n-   ignore this constraint is when a function has no arguments on the stack,\n-   no stack frame requirement and no live registers execpt for `lr'.  If we\n-   can guarantee that by making all function calls into tail calls and that\n-   lr is not clobbered in any other way, then there is no need to push lr\n-   onto the stack.  */\n+/* Place some comments into the assembler stream\n+   describing the current function.  */\n+\n void\n output_arm_prologue (f, frame_size)\n      FILE * f;\n      int frame_size;\n {\n-  int reg, live_regs_mask = 0;\n-  int volatile_func = arm_volatile_func ();\n-\n-  /* Nonzero if we must stuff some register arguments onto the stack as if\n-     they were passed there.  */\n-  int store_arg_regs = 0;\n-\n+  unsigned long func_type;\n+  \n+  /* Sanity check.  */\n   if (arm_ccfsm_state || arm_target_insn)\n-    abort ();\t\t\t\t\t/* Sanity check.  */\n-\n-  if (arm_naked_function_p (current_function_decl))\n-    return;\n+    abort ();\n \n-  return_used_this_function = 0;\n+  func_type = arm_current_func_type ();\n+  \n+  switch ((int) ARM_FUNC_TYPE (func_type))\n+    {\n+    default:\n+    case ARM_FT_NORMAL:\n+      break;\n+    case ARM_FT_INTERWORKED:\n+      asm_fprintf (f, \"\\t%@ Function supports interworking.\\n\");\n+      break;\n+    case ARM_FT_EXCEPTION_HANDLER:\n+      asm_fprintf (f, \"\\t%@ C++ Exception Handler.\\n\");\n+      break;\n+    case ARM_FT_ISR:\n+      asm_fprintf (f, \"\\t%@ Interrupt Service Routine.\\n\");\n+      break;\n+    case ARM_FT_FIQ:\n+      asm_fprintf (f, \"\\t%@ Fast Interrupt Service Routine.\\n\");\n+      break;\n+    case ARM_FT_EXCEPTION:\n+      asm_fprintf (f, \"\\t%@ ARM Exception Handler.\\n\");\n+      break;\n+    }\n   \n+  if (IS_NAKED (func_type))\n+    asm_fprintf (f, \"\\t%@ Naked Function: prologue and epilogue provided by programmer.\\n\");\n+\n+  if (IS_VOLATILE (func_type))\n+    asm_fprintf (f, \"\\t%@ Volatile: function does not return.\\n\");\n+\n+  if (IS_NESTED (func_type))\n+    asm_fprintf (f, \"\\t%@ Nested: function declared inside another function.\\n\");\n+    \n   asm_fprintf (f, \"\\t%@ args = %d, pretend = %d, frame = %d\\n\",\n \t       current_function_args_size,\n \t       current_function_pretend_args_size, frame_size);\n+\n   asm_fprintf (f, \"\\t%@ frame_needed = %d, current_function_anonymous_args = %d\\n\",\n \t       frame_pointer_needed,\n \t       current_function_anonymous_args);\n \n-  if (volatile_func)\n-    asm_fprintf (f, \"\\t%@ Volatile function.\\n\");\n-\n-  if (current_function_needs_context)\n-    asm_fprintf (f, \"\\t%@ Nested function.\\n\");\n-\n-  if (current_function_anonymous_args && current_function_pretend_args_size)\n-    store_arg_regs = 1;\n-\n-  for (reg = 0; reg <= 10; reg++)\n-    if (regs_ever_live[reg] && !call_used_regs[reg])\n-      live_regs_mask |= (1 << reg);\n-\n-  if (!TARGET_APCS_FRAME\n-      && !frame_pointer_needed\n-      && regs_ever_live[HARD_FRAME_POINTER_REGNUM]\n-      && !call_used_regs[HARD_FRAME_POINTER_REGNUM])\n-    live_regs_mask |= (1 << HARD_FRAME_POINTER_REGNUM);\n-\n-  if (flag_pic && !TARGET_SINGLE_PIC_BASE\n-      && regs_ever_live[PIC_OFFSET_TABLE_REGNUM])\n-    live_regs_mask |= (1 << PIC_OFFSET_TABLE_REGNUM);\n-\n-  if (frame_pointer_needed)\n-    live_regs_mask |= 0xD800;\n-  else if (regs_ever_live[LR_REGNUM])\n-    {\n-      live_regs_mask |= 1 << LR_REGNUM;\n-    }\n-\n-  if (live_regs_mask)\n-    /* If a di mode load/store multiple is used, and the base register\n-       is r3, then r4 can become an ever live register without lr\n-       doing so,  in this case we need to push lr as well, or we\n-       will fail to get a proper return.  */\n-    live_regs_mask |= 1 << LR_REGNUM;\n-\n #ifdef AOF_ASSEMBLER\n   if (flag_pic)\n     asm_fprintf (f, \"\\tmov\\t%r, %r\\n\", IP_REGNUM, PIC_OFFSET_TABLE_REGNUM);\n #endif\n+\n+  return_used_this_function = 0;  \n }\n \n const char *\n arm_output_epilogue (really_return)\n      int really_return;\n {\n   int reg;\n-  int live_regs_mask = 0;\n+  unsigned long live_regs_mask;\n+  unsigned long func_type;\n   /* If we need this, then it will always be at least this much.  */\n   int floats_offset = 12;\n   rtx operands[3];\n   int frame_size = get_frame_size ();\n-  rtx eh_ofs = cfun->machine->eh_epilogue_sp_ofs;\n   FILE * f = asm_out_file;\n-  int volatile_func = arm_volatile_func ();\n-  int return_regnum;\n+  rtx eh_ofs = cfun->machine->eh_epilogue_sp_ofs;\n \n+  /* If we have already generated the return instruction\n+     then it is futile to generate anything else.  */\n   if (use_return_insn (FALSE) && return_used_this_function)\n     return \"\";\n \n-  /* Naked functions don't have epilogues.  */\n-  if (arm_naked_function_p (current_function_decl))\n-    return \"\";\n-\n-  /* If we are throwing an exception, the address we want to jump to is in\n-     R1; otherwise, it's in LR.  */\n-  return_regnum = eh_ofs ? 2 : LR_REGNUM;\n+  func_type = arm_current_func_type ();\n \n-  /* If we are throwing an exception, then we really must be doing a return,\n-     so we can't tail-call.  */\n-  if (eh_ofs && !really_return)\n-    abort();\n+  if (IS_NAKED (func_type))\n+    /* Naked functions don't have epilogues.  */\n+    return \"\";\n \n-  /* A volatile function should never return.  Call abort.  */\n-  if (TARGET_ABORT_NORETURN && volatile_func)\n+  if (IS_VOLATILE (func_type) && TARGET_ABORT_NORETURN)\n     {\n       rtx op;\n+\t  \n+      /* A volatile function should never return.  Call abort.  */\n       op = gen_rtx_SYMBOL_REF (Pmode, NEED_PLT_RELOC ? \"abort(PLT)\" : \"abort\");\n       assemble_external_libcall (op);\n       output_asm_insn (\"bl\\t%a0\", &op);\n+      \n       return \"\";\n     }\n \n-  for (reg = 0; reg <= 10; reg++)\n-    if (regs_ever_live[reg] && !call_used_regs[reg])\n-      {\n-        live_regs_mask |= (1 << reg);\n-\tfloats_offset += 4;\n-      }\n-\n-  /* Handle the frame pointer as a special case.  */\n-  if (!TARGET_APCS_FRAME\n-      && !frame_pointer_needed\n-      && regs_ever_live[HARD_FRAME_POINTER_REGNUM]\n-      && !call_used_regs[HARD_FRAME_POINTER_REGNUM])\n-    {\n-      live_regs_mask |= (1 << HARD_FRAME_POINTER_REGNUM);\n-      floats_offset += 4;\n-    }\n-\n-  /* If we aren't loading the PIC register, don't stack it even though it may\n-     be live.  */\n-  if (flag_pic && !TARGET_SINGLE_PIC_BASE \n-      && regs_ever_live[PIC_OFFSET_TABLE_REGNUM])\n-    {\n-      live_regs_mask |= (1 << PIC_OFFSET_TABLE_REGNUM);\n+  if (ARM_FUNC_TYPE (func_type) == ARM_FT_EXCEPTION_HANDLER\n+      && ! really_return)\n+    /* If we are throwing an exception, then we really must\n+       be doing a return,  so we can't tail-call.  */\n+    abort ();\n+  \n+  live_regs_mask = arm_compute_save_reg_mask ();\n+  \n+  /* Compute how far away the floats will be.  */\n+  for (reg = 0; reg <= LAST_ARM_REGNUM; reg ++)\n+    if (live_regs_mask & (1 << reg))\n       floats_offset += 4;\n-    }\n-\n+  \n   if (frame_pointer_needed)\n     {\n       if (arm_fpu_arch == FP_SOFT2)\n@@ -7096,37 +7308,28 @@ arm_output_epilogue (really_return)\n \t\t\t reg + 1, start_reg - reg,\n \t\t\t FP_REGNUM, floats_offset);\n \t}\n-      \n-      if (TARGET_INTERWORK)\n-\t{\n-\t  live_regs_mask |= 0x6800;\n-\t  print_multi_reg (f, \"ldmea\\t%r\", FP_REGNUM, live_regs_mask, FALSE);\n-\t  if (eh_ofs)\n-\t    asm_fprintf (f, \"\\tadd\\t%r, %r, %r\\n\", SP_REGNUM, SP_REGNUM,\n-\t\t\t REGNO (eh_ofs));\n-\t  if (really_return)\n-\t    asm_fprintf (f, \"\\tbx\\t%r\\n\", return_regnum);\n-\t}\n-      else if (eh_ofs || !really_return)\n-\t{\n-\t  live_regs_mask |= 0x6800;\n-\t  print_multi_reg (f, \"ldmea\\t%r\", FP_REGNUM, live_regs_mask, FALSE);\n-\t  if (eh_ofs)\n-\t    {\n-\t      asm_fprintf (f, \"\\tadd\\t%r, %r, %r\\n\", SP_REGNUM, SP_REGNUM,\n-\t\t\t   REGNO (eh_ofs));\n-\t      /* Even in 26-bit mode we do a mov (rather than a movs)\n-\t\t because we don't have the PSR bits set in the\n-\t\t address.  */\n-\t      asm_fprintf (f, \"\\tmov\\t%r, %r\\n\", PC_REGNUM, return_regnum);\n-\t    }\n-\t}\n+\n+      /* live_regs_mask should contain the IP, which at the time of stack\n+\t frame generation actually contains the old stack pointer.  So a\n+\t quick way to unwind the stack is just pop the IP register directly\n+\t into the stack pointer.  */\n+      if ((live_regs_mask & (1 << IP_REGNUM)) == 0)\n+\tabort ();\n+      live_regs_mask &= ~ (1 << IP_REGNUM);\n+      live_regs_mask |=   (1 << SP_REGNUM);\n+\n+      /* There are two registers left in live_regs_mask - LR and PC.  We\n+\t only need to restore the LR register (the return address), but to\n+\t save time we can load it directly into the PC, unless we need a\n+\t special function exit sequence, or we are not really returning.  */\n+      if (really_return && ARM_FUNC_TYPE (func_type) == ARM_FT_NORMAL)\n+\t/* Delete the LR from the register mask, so that the LR on\n+\t   the stack is loaded into the PC in the register mask.  */\n+\tlive_regs_mask &= ~ (1 << LR_REGNUM);\n       else\n-\t{\n-\t  live_regs_mask |= 0xA800;\n-\t  print_multi_reg (f, \"ldmea\\t%r\", FP_REGNUM, live_regs_mask,\n-\t\t\t   TARGET_APCS_32 ? FALSE : TRUE);\n-\t}\n+\tlive_regs_mask &= ~ (1 << PC_REGNUM);\n+      \n+      print_multi_reg (f, \"ldmea\\t%r\", FP_REGNUM, live_regs_mask);\n     }\n   else\n     {\n@@ -7178,102 +7381,86 @@ arm_output_epilogue (really_return)\n \t\t\t start_reg, reg - start_reg, SP_REGNUM);\n \t}\n \n-      if (current_function_pretend_args_size == 0 && regs_ever_live[LR_REGNUM])\n+      /* If we can, restore the LR into the PC.  */\n+      if (ARM_FUNC_TYPE (func_type) == ARM_FT_NORMAL\n+\t  && really_return\n+\t  && current_function_pretend_args_size == 0\n+\t  && regs_ever_live [LR_REGNUM])\n \t{\n-\t  if (TARGET_INTERWORK)\n-\t    {\n-\t      live_regs_mask |= 1 << LR_REGNUM;\n-\n-\t      /* Handle LR on its own.  */\n-\t      if (live_regs_mask == (1 << LR_REGNUM))\n-\t\t{\n-\t\t  if (eh_ofs)\n-\t\t    asm_fprintf (f, \"\\tadd\\t%r, %r, #4\\n\", SP_REGNUM,\n-\t\t\t\t SP_REGNUM);\n-\t\t  else\n-\t\t    asm_fprintf (f, \"\\tldr\\t%r, [%r], #4\\n\", LR_REGNUM,\n-\t\t\t\t SP_REGNUM);\n-\t\t}\n-\t      else if (live_regs_mask != 0)\n-\t\tprint_multi_reg (f, \"ldmfd\\t%r!\", SP_REGNUM, live_regs_mask,\n-\t\t\t\t FALSE);\n-\n-\t      if (eh_ofs)\n-\t\tasm_fprintf (f, \"\\tadd\\t%r, %r, %r\\n\", SP_REGNUM, SP_REGNUM,\n-\t\t\t     REGNO (eh_ofs));\n+\t  live_regs_mask &= ~ (1 << LR_REGNUM);\n+\t  live_regs_mask |=   (1 << PC_REGNUM);\n+\t}\n \n-\t      if (really_return)\n-\t\tasm_fprintf (f, \"\\tbx\\t%r\\n\", return_regnum);\n-\t    }\n-\t  else if (eh_ofs)\n-\t    {\n-\t      if (live_regs_mask == 0)\n-\t\tasm_fprintf (f, \"\\tadd\\t%r, %r, #4\\n\", SP_REGNUM, SP_REGNUM);\n-\t      else\n-\t\tprint_multi_reg (f, \"\\tldmfd\\t%r!\", SP_REGNUM,\n-\t\t\t\t live_regs_mask | (1 << LR_REGNUM), FALSE);\n-\t\t\n-\t      asm_fprintf (f, \"\\tadd\\t%r, %r, %r\\n\", SP_REGNUM, SP_REGNUM,\n-\t\t\t   REGNO (eh_ofs));\n-\t      /* Jump to the target; even in 26-bit mode.  */\n-\t      asm_fprintf (f, \"\\tmov\\t%r, %r\\n\", PC_REGNUM, return_regnum);\n-\t    }\n-\t  else if (TARGET_APCS_32 && live_regs_mask == 0 && !really_return)\n-\t    asm_fprintf (f, \"\\tldr\\t%r, [%r], #4\\n\", LR_REGNUM, SP_REGNUM);\n-\t  else if (TARGET_APCS_32 && live_regs_mask == 0 && really_return)\n-\t    asm_fprintf (f, \"\\tldr\\t%r, [%r], #4\\n\", PC_REGNUM, SP_REGNUM);\n-\t  else if (!really_return)\n-\t    print_multi_reg (f, \"ldmfd\\t%r!\", SP_REGNUM,\n-\t\t\t     live_regs_mask | (1 << LR_REGNUM), FALSE);\n+      /* Load the registers off the stack.  If we only have one register\n+\t to load use the LDR instruction - it is faster.  */\n+      if (live_regs_mask == (1 << LR_REGNUM))\n+\t{\n+\t  /* The excpetion handler ignores the LR, so we do\n+\t     not really need to load it off the stack.  */\n+\t  if (eh_ofs)\n+\t    asm_fprintf (f, \"\\tadd\\t%r, %r, #4\\n\", SP_REGNUM, SP_REGNUM);\n \t  else\n-\t    print_multi_reg (f, \"ldmfd\\t%r!\", SP_REGNUM,\n-\t\t\t     live_regs_mask | (1 << PC_REGNUM),\n-\t\t\t     TARGET_APCS_32 ? FALSE : TRUE);\n+\t    asm_fprintf (f, \"\\tldr\\t%r, [%r], #4\\n\", LR_REGNUM, SP_REGNUM);\n \t}\n-      else\n+      else if (live_regs_mask)\n+\tprint_multi_reg (f, \"ldmfd\\t%r!\", SP_REGNUM, live_regs_mask);\n+\n+      if (current_function_pretend_args_size)\n \t{\n-\t  if (live_regs_mask || regs_ever_live[LR_REGNUM])\n-\t    {\n-\t      /* Restore the integer regs, and the return address into lr.  */\n-\t      live_regs_mask |= 1 << LR_REGNUM;\n+\t  /* Unwind the pre-pushed regs.  */\n+\t  operands[0] = operands[1] = stack_pointer_rtx;\n+\t  operands[2] = GEN_INT (current_function_pretend_args_size);\n+\t  output_add_immediate (operands);\n+\t}\n+    }\n \n-\t      if (live_regs_mask == (1 << LR_REGNUM))\n-\t\t{\n-\t\t  if (eh_ofs)\n-\t\t    asm_fprintf (f, \"\\tadd\\t%r, %r, #4\\n\", SP_REGNUM,\n-\t\t\t\t SP_REGNUM);\n-\t\t  else\n-\t\t    asm_fprintf (f, \"\\tldr\\t%r, [%r], #4\\n\", LR_REGNUM,\n-\t\t\t\t SP_REGNUM);\n-\t\t}\n-\t      else if (live_regs_mask != 0)\n-\t\tprint_multi_reg (f, \"ldmfd\\t%r!\", SP_REGNUM, live_regs_mask,\n-\t\t\t\t FALSE);\n-\t    }\n+  if (ARM_FUNC_TYPE (func_type) == ARM_FT_EXCEPTION_HANDLER)\n+    /* Adjust the stack to remove the exception handler stuff.  */\n+    asm_fprintf (f, \"\\tadd\\t%r, %r, %r\\n\", SP_REGNUM, SP_REGNUM,\n+\t\t REGNO (eh_ofs));\n \n-\t  if (current_function_pretend_args_size)\n-\t    {\n-\t      /* Unwind the pre-pushed regs.  */\n-\t      operands[0] = operands[1] = stack_pointer_rtx;\n-\t      operands[2] = GEN_INT (current_function_pretend_args_size);\n-\t      output_add_immediate (operands);\n-\t    }\n+  if (! really_return)\n+    return \"\";\n \n-\t  if (eh_ofs)\n-\t    asm_fprintf (f, \"\\tadd\\t%r, %r, %r\\n\", SP_REGNUM, SP_REGNUM,\n-\t\t\t REGNO (eh_ofs));\n+  /* Generate the return instruction.  */\n+  switch ((int) ARM_FUNC_TYPE (func_type))\n+    {\n+    case ARM_FT_EXCEPTION_HANDLER:\n+      /* Even in 26-bit mode we do a mov (rather than a movs)\n+\t because we don't have the PSR bits set in the address.  */\n+      asm_fprintf (f, \"\\tmov\\t%r, %r\\n\", PC_REGNUM, EXCEPTION_LR_REGNUM);\n+      break;\n \n-\t  if (really_return)\n-\t    {\n-\t      /* And finally, go home.  */\n-\t      if (TARGET_INTERWORK)\n-\t\tasm_fprintf (f, \"\\tbx\\t%r\\n\", return_regnum);\n-\t      else if (TARGET_APCS_32 || eh_ofs)\n-\t\tasm_fprintf (f, \"\\tmov\\t%r, %r\\n\", PC_REGNUM, return_regnum);\n-\t      else\n-\t\tasm_fprintf (f, \"\\tmovs\\t%r, %r\\n\", PC_REGNUM, return_regnum);\n-\t    }\n-\t}\n+    case ARM_FT_ISR:\n+    case ARM_FT_FIQ:\n+      asm_fprintf (f, \"\\tsubs\\t%r, %r, #4\\n\", PC_REGNUM, LR_REGNUM);\n+      break;\n+\n+    case ARM_FT_EXCEPTION:\n+      asm_fprintf (f, \"\\tmovs\\t%r, %r\\n\", PC_REGNUM, LR_REGNUM);\n+      break;\n+\n+    case ARM_FT_INTERWORKED:\n+      asm_fprintf (f, \"\\tbx\\t%r\\n\", LR_REGNUM);\n+      break;\n+\n+    default:\n+      if (frame_pointer_needed)\n+\t/* If we used the frame pointer then the return adddress\n+\t   will have been loaded off the stack directly into the\n+\t   PC, so there is no need to issue a MOV instruction\n+\t   here.  */\n+\t;\n+      else if (current_function_pretend_args_size == 0\n+\t       && regs_ever_live [LR_REGNUM])\n+\t/* Similarly we may have been able to load LR into the PC\n+\t   even if we did not create a stack frame.  */\n+\t;\n+      else if (TARGET_APCS_32)\n+\tasm_fprintf (f, \"\\tmov\\t%r, %r\\n\", PC_REGNUM, LR_REGNUM);\n+      else\n+\tasm_fprintf (f, \"\\tmovs\\t%r, %r\\n\", PC_REGNUM, LR_REGNUM);\n+      break;\n     }\n \n   return \"\";\n@@ -7308,6 +7495,7 @@ output_func_epilogue (frame_size)\n    Unfortunately, since this insn does not reflect very well the actual\n    semantics of the operation, we need to annotate the insn for the benefit\n    of DWARF2 frame unwind information.  */\n+\n static rtx\n emit_multi_reg_push (mask)\n      int mask;\n@@ -7476,79 +7664,66 @@ emit_sfm (base_reg, count)\n   return par;\n }\n \n+/* Generate the prologue instructions for entry into an ARM function.  */\n+\n void\n arm_expand_prologue ()\n {\n   int reg;\n-  rtx amount = GEN_INT (-(get_frame_size ()\n-\t\t\t  + current_function_outgoing_args_size));\n-  int live_regs_mask = 0;\n-  int store_arg_regs = 0;\n-  /* If this function doesn't return, then there is no need to push\n-     the call-saved regs.  */\n-  int volatile_func = arm_volatile_func ();\n+  rtx amount;\n   rtx insn;\n   rtx ip_rtx;\n+  unsigned long live_regs_mask;\n+  unsigned long func_type;\n   int fp_offset = 0;\n-\n+  \n+  func_type = arm_current_func_type ();\n \n   /* Naked functions don't have prologues.  */\n-  if (arm_naked_function_p (current_function_decl))\n+  if (IS_NAKED (func_type))\n     return;\n \n-  if (current_function_anonymous_args && current_function_pretend_args_size)\n-    store_arg_regs = 1;\n-\n-  if (!volatile_func)\n-    {\n-      for (reg = 0; reg <= 10; reg++)\n-\tif (regs_ever_live[reg] && !call_used_regs[reg])\n-\t  live_regs_mask |= 1 << reg;\n-\n-      if (!TARGET_APCS_FRAME\n-\t  && !frame_pointer_needed\n-\t  && regs_ever_live[HARD_FRAME_POINTER_REGNUM]\n-\t  && !call_used_regs[HARD_FRAME_POINTER_REGNUM])\n-\tlive_regs_mask |= 1 << HARD_FRAME_POINTER_REGNUM;\n-      \n-      if (flag_pic && regs_ever_live[PIC_OFFSET_TABLE_REGNUM])\n-\tlive_regs_mask |= 1 << PIC_OFFSET_TABLE_REGNUM;\n-\n-      if (regs_ever_live[LR_REGNUM])\n-\tlive_regs_mask |= 1 << LR_REGNUM;\n-    }\n+  /* Compute which register we will have to save onto the stack.  */\n+  live_regs_mask = arm_compute_save_reg_mask ();\n \n   ip_rtx = gen_rtx_REG (SImode, IP_REGNUM);\n   \n   if (frame_pointer_needed)\n     {\n-      if (current_function_needs_context)\n+      if (IS_NESTED (func_type))\n \t{\n \t  /* The Static chain register is the same as the IP register\n \t     used as a scratch register during stack frame creation.\n \t     To get around this need to find somewhere to store IP\n \t     whilst the frame is being created.  We try the following\n \t     places in order:\n \t     \n-\t       1. An unused argument register.\n+\t       1. The last argument register.\n \t       2. A slot on the stack above the frame.  (This only\n \t          works if the function is not a varargs function).\n \t\t  \n-\t     If neither of these places is available, we abort (for now).  */\n+\t     If neither of these places is available, we abort (for now).\n+\n+\t     Note - setting RTX_FRAME_RELATED_P on these insns breaks\n+\t     the dwarf2 parsing code in various bits of gcc.  This ought\n+\t     to be fixed sometime, but until then the flag is suppressed.\n+\t     [Use gcc/testsuite/gcc.c-torture/execute/921215-1.c with\n+\t     \"-O3 -g\" to test this].  */\n+\t  \n \t  if (regs_ever_live[3] == 0)\n \t    {\n \t      insn = gen_rtx_REG (SImode, 3);\n \t      insn = gen_rtx_SET (SImode, insn, ip_rtx);\n-\t      insn = emit_insn (insn);\n-\t      RTX_FRAME_RELATED_P (insn) = 1;\t  \n+\t      insn = emit_insn (insn);\t      \n+\t      /* RTX_FRAME_RELATED_P (insn) = 1; */\n \t    }\n \t  else if (current_function_pretend_args_size == 0)\n \t    {\n \t      insn = gen_rtx_PRE_DEC (SImode, stack_pointer_rtx);\n \t      insn = gen_rtx_MEM (SImode, insn);\n \t      insn = gen_rtx_SET (VOIDmode, insn, ip_rtx);\n \t      insn = emit_insn (insn);\n-\t      RTX_FRAME_RELATED_P (insn) = 1;\n+\t      /* RTX_FRAME_RELATED_P (insn) = 1; */\n \t      fp_offset = 4;\n \t    }\n \t  else\n@@ -7560,8 +7735,6 @@ arm_expand_prologue ()\n \t    error (\"Unable to find a temporary location for static chanin register\");\n \t}\n \n-      live_regs_mask |= 0xD800;\n-\n       if (fp_offset)\n \t{\n \t  insn = gen_rtx_PLUS (SImode, stack_pointer_rtx, GEN_INT (fp_offset));\n@@ -7570,13 +7743,14 @@ arm_expand_prologue ()\n       else\n \tinsn = gen_movsi (ip_rtx, stack_pointer_rtx);\n       \n-      insn = emit_insn (insn);\n       RTX_FRAME_RELATED_P (insn) = 1;\n+      insn = emit_insn (insn);\n     }\n \n   if (current_function_pretend_args_size)\n     {\n-      if (store_arg_regs)\n+      /* Push the argument registers, or reserve space for them.  */\n+      if (current_function_anonymous_args)\n \tinsn = emit_multi_reg_push\n \t  ((0xf0 >> (current_function_pretend_args_size / 4)) & 0xf);\n       else\n@@ -7588,17 +7762,13 @@ arm_expand_prologue ()\n \n   if (live_regs_mask)\n     {\n-      /* If we have to push any regs, then we must push lr as well, or\n-\t we won't get a proper return.  */\n-      live_regs_mask |= 1 << LR_REGNUM;\n       insn = emit_multi_reg_push (live_regs_mask);\n       RTX_FRAME_RELATED_P (insn) = 1;\n     }\n-      \n-  /* For now the integer regs are still pushed in output_arm_epilogue ().  */\n \n-  if (!volatile_func)\n+  if (! IS_VOLATILE (func_type))\n     {\n+      /* Save any floating point call-saved registers used by this function.  */\n       if (arm_fpu_arch == FP_SOFT2)\n \t{\n \t  for (reg = LAST_ARM_FP_REGNUM; reg >= FIRST_ARM_FP_REGNUM; reg --)\n@@ -7647,31 +7817,35 @@ arm_expand_prologue ()\n \n   if (frame_pointer_needed)\n     {\n+      /* Create the new frame pointer.  */\n       insn = GEN_INT (-(4 + current_function_pretend_args_size + fp_offset));\n       insn = emit_insn (gen_addsi3 (hard_frame_pointer_rtx, ip_rtx, insn));\n       RTX_FRAME_RELATED_P (insn) = 1;\n       \n-      if (current_function_needs_context)\n+      if (IS_NESTED (func_type))\n \t{\n \t  /* Recover the static chain register.  */\n \t  if (regs_ever_live [3] == 0)\n \t    {\n \t      insn = gen_rtx_REG (SImode, 3);\n \t      insn = gen_rtx_SET (SImode, ip_rtx, insn);\n \t      insn = emit_insn (insn);\n-\t      RTX_FRAME_RELATED_P (insn) = 1;\t  \n+\t      /* RTX_FRAME_RELATED_P (insn) = 1; */\n \t    }\n \t  else /* if (current_function_pretend_args_size == 0) */\n \t    {\n \t      insn = gen_rtx_PLUS (SImode, hard_frame_pointer_rtx, GEN_INT (4));\n \t      insn = gen_rtx_MEM (SImode, insn);\n \t      insn = gen_rtx_SET (SImode, ip_rtx, insn);\n \t      insn = emit_insn (insn);\n-\t      RTX_FRAME_RELATED_P (insn) = 1;\t  \n+\t      /* RTX_FRAME_RELATED_P (insn) = 1; */\n \t    }\n \t}\n     }\n \n+  amount = GEN_INT (-(get_frame_size ()\n+\t\t      + current_function_outgoing_args_size));\n+\n   if (amount != const0_rtx)\n     {\n       insn = emit_insn (gen_addsi3 (stack_pointer_rtx, stack_pointer_rtx,\n@@ -7687,7 +7861,7 @@ arm_expand_prologue ()\n \t\t\t\t       gen_rtvec (2, stack_pointer_rtx,\n \t\t\t\t\t\t  hard_frame_pointer_rtx), 4);\n \n-\t  emit_insn (gen_rtx_CLOBBER (VOIDmode,\n+\t  insn = emit_insn (gen_rtx_CLOBBER (VOIDmode,\n \t\t\t\t      gen_rtx_MEM (BLKmode, unspec)));\n \t}\n     }\n@@ -9310,7 +9484,7 @@ static void\n arm_mark_machine_status (p)\n      struct function * p;\n {\n-  struct machine_function *machine = p->machine;\n+  machine_function *machine = p->machine;\n \n   ggc_mark_rtx (machine->ra_rtx);\n   ggc_mark_rtx (machine->eh_epilogue_sp_ofs);\n@@ -9321,7 +9495,11 @@ arm_init_machine_status (p)\n      struct function * p;\n {\n   p->machine =\n-    (struct machine_function *) xcalloc (1, sizeof (struct machine_function));\n+    (machine_function *) xcalloc (1, sizeof (machine_function));\n+\n+#if ARM_FT_UNKNOWWN != 0  \n+  ((machine_function *) p->machine)->func_type = ARM_FT_UNKNOWN;\n+#endif\n }\n \n /* Return an RTX indicating where the return address to the\n@@ -9379,11 +9557,20 @@ thumb_expand_prologue ()\n {\n   HOST_WIDE_INT amount = (get_frame_size ()\n \t\t\t  + current_function_outgoing_args_size);\n+  unsigned long func_type;\n+\n+  func_type = arm_current_func_type ();\n   \n   /* Naked functions don't have prologues.  */\n-  if (arm_naked_function_p (current_function_decl))\n+  if (IS_NAKED (func_type))\n     return;\n \n+  if (IS_INTERRUPT (func_type))\n+    {\n+      error (\"Interrupt Service Routines cannot be coded in Thumb mode.\");\n+      return;\n+    }\n+\n   if (frame_pointer_needed)\n     emit_insn (gen_movsi (hard_frame_pointer_rtx, stack_pointer_rtx));\n \n@@ -9465,9 +9652,9 @@ thumb_expand_epilogue ()\n {\n   HOST_WIDE_INT amount = (get_frame_size ()\n \t\t\t  + current_function_outgoing_args_size);\n-\n-  /* Naked functions don't have epilogues.  */\n-  if (arm_naked_function_p (current_function_decl))\n+  \n+  /* Naked functions don't have prologues.  */\n+  if (IS_NAKED (arm_current_func_type ()))\n     return;\n \n   if (frame_pointer_needed)\n@@ -9503,10 +9690,9 @@ output_thumb_prologue (f)\n {\n   int live_regs_mask = 0;\n   int high_regs_pushed = 0;\n-  int store_arg_regs = 0;\n   int regno;\n \n-  if (arm_naked_function_p (current_function_decl))\n+  if (IS_NAKED (arm_current_func_type ()))\n     return;\n \n   if (is_called_in_ARM_mode (current_function_decl))\n@@ -9544,12 +9730,9 @@ output_thumb_prologue (f)\n       asm_fprintf (f, \"%s%U%s:\\n\", STUB_NAME, name);\n     }\n     \n-  if (current_function_anonymous_args && current_function_pretend_args_size)\n-    store_arg_regs = 1;\n-\n   if (current_function_pretend_args_size)\n     {\n-      if (store_arg_regs)\n+      if (current_function_anonymous_args)\n \t{\n \t  int num_pushes;\n \t  "}, {"sha": "40287c8d99ecc0753975a58674156a6cb0c887ce", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 47, "deletions": 6, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d3d91336c1a1e9b7e6d742a967a13ac799437b0/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d3d91336c1a1e9b7e6d742a967a13ac799437b0/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=6d3d91336c1a1e9b7e6d742a967a13ac799437b0", "patch": "@@ -903,7 +903,10 @@ extern const char * structure_size_string;\n #define LAST_ARG_REGNUM \tARG_REGISTER (NUM_ARG_REGS)\n \n /* The number of the last \"lo\" register (thumb).  */\n-#define LAST_LO_REGNUM  \t 7\n+#define LAST_LO_REGNUM  \t7\n+\n+/* The register that holds the return address in exception handlers.  */\n+#define EXCEPTION_LR_REGNUM\t2\n \n /* The native (Norcroft) Pascal compiler for the ARM passes the static chain\n    as an invisible last argument (possible since varargs don't exist in\n@@ -1394,9 +1397,44 @@ enum reg_class\n #define CALL_LONG\t\t0x00000001\t/* Always call indirect.  */\n #define CALL_SHORT\t\t0x00000002\t/* Never call indirect.  */\n \n-/* A C structure for machine-specific, per-function data.  This is added\n-   to the cfun structure.  */\n-struct machine_function\n+/* These bits describe the different types of function supported\n+   by the ARM backend.  They are exclusive.  ie a function cannot be both a\n+   normal function and an interworked function, for example.  Knowing the\n+   type of a function is important for determining its prologue and\n+   epilogue sequences.\n+   Note value 7 is currently unassigned.  Also note that the interrupt\n+   function types all have bit 2 set, so that they can be tested for easily.\n+   Note that 0 is deliberately chosen for ARM_FT_UNKNOWN so that when the\n+   machine_function structure is initialised (to zero) func_type will\n+   default to unknown.  This will force the first use of arm_current_func_type\n+   to call arm_compute_func_type.  */\n+#define ARM_FT_UNKNOWN\t\t 0 /* Type has not yet been determined.  */\n+#define ARM_FT_NORMAL\t\t 1 /* Your normal, straightforward function.  */\n+#define ARM_FT_INTERWORKED\t 2 /* A function that supports interworking.  */\n+#define ARM_FT_EXCEPTION_HANDLER 3 /* A C++ exception handler.  */\n+#define ARM_FT_ISR\t\t 4 /* An interrupt service routine.  */\n+#define ARM_FT_FIQ\t\t 5 /* A fast interrupt service routine.  */\n+#define ARM_FT_EXCEPTION\t 6 /* An ARM exception handler (subcase of ISR).  */\n+\n+#define ARM_FT_TYPE_MASK\t((1 << 3) - 1)\n+\n+/* In addition functions can have several type modifiers,\n+   outlined by these bit masks:  */\n+#define ARM_FT_INTERRUPT\t(1 << 2) /* Note overlap with FT_ISR and above.  */\n+#define ARM_FT_NAKED\t\t(1 << 3) /* No prologue or epilogue.  */\n+#define ARM_FT_VOLATILE\t\t(1 << 4) /* Does not return.  */\n+#define ARM_FT_NESTED\t\t(1 << 5) /* Embedded inside another func. */\n+\n+/* Some macros to test these flags.  */\n+#define ARM_FUNC_TYPE(t)\t(t & ARM_FT_TYPE_MASK)\n+#define IS_INTERRUPT(t)\t\t(t & ARM_FT_INTERRUPT)\n+#define IS_VOLATILE(t)     \t(t & ARM_FT_VOLATILE)\n+#define IS_NAKED(t)        \t(t & ARM_FT_NAKED)\n+#define IS_NESTED(t)       \t(t & ARM_FT_NESTED)\n+\n+/* A C structure for machine-specific, per-function data.\n+   This is added to the cfun structure.  */\n+typedef struct machine_function\n {\n   /* Records __builtin_return address.  */\n   struct rtx_def *ra_rtx;\n@@ -1406,7 +1444,10 @@ struct machine_function\n   int far_jump_used;\n   /* Records if ARG_POINTER was ever live.  */\n   int arg_pointer_live;\n-};\n+  /* Records the type of the current function.  */\n+  unsigned long func_type;\n+}\n+machine_function;\n \n /* A C type for declaring a variable that is used as the first argument of\n    `FUNCTION_ARG' and other related values.  For some target machines, the\n@@ -1615,7 +1656,7 @@ typedef struct\n    other its replacement, at the start of a routine.  */\n #define ARM_INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET)\t\t\\\n {\t\t\t\t\t\t\t\t\t\\\n-  int volatile_func = arm_volatile_func ();\t\t\t\t\\\n+  int volatile_func = IS_VOLATILE (arm_current_func_type ());\t\t\\\n   if ((FROM) == ARG_POINTER_REGNUM && (TO) == HARD_FRAME_POINTER_REGNUM)\\\n     {\t\t\t\t\t\t\t\t\t\\\n       if (! current_function_needs_context || ! frame_pointer_needed)\t\\"}, {"sha": "9950ddea2922d999b120640dcd1eac937703366d", "filename": "gcc/extend.texi", "status": "modified", "additions": 25, "deletions": 17, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d3d91336c1a1e9b7e6d742a967a13ac799437b0/gcc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d3d91336c1a1e9b7e6d742a967a13ac799437b0/gcc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fextend.texi?ref=6d3d91336c1a1e9b7e6d742a967a13ac799437b0", "patch": "@@ -1760,6 +1760,27 @@ function is an interrupt handler.  The compiler will generate function\n entry and exit sequences suitable for use in an interrupt handler when this\n attribute is present.\n \n+@item interrupt\n+@cindex interrupt handler functions\n+Use this option on the ARM, AVR and M32R/D ports to indicate that the\n+specified function is an interrupt handler.  The compiler will generate\n+function entry and exit sequences suitable for use in an interrupt\n+handler when this attribute is present.\n+\n+Note, interrupt handlers for ther H8/300 and H8/300H processors can be\n+specified via the @code{interrupt_handler} attribute.\n+\n+Note, on the AVR interrupts will be enabled inside the function.\n+\n+Note, for the ARM you can specify the kind of interrupt to be handled by\n+adding an optional parameter to the interrupt attribute like this:\n+\n+@smallexample\n+void f () __attribute__ ((interrupt (\"IRQ\")));\n+@end smallexample\n+\n+Permissable values for this parameter are: IRQ, FIQ, SWI, ABORT and UNDEF.\n+\n @item eightbit_data\n @cindex eight bit data on the H8/300 and H8/300H\n Use this option on the H8/300 and H8/300H to indicate that the specified\n@@ -1779,19 +1800,6 @@ The compiler will generate more efficient code for loads and stores\n on data in the tiny data section.  Note the tiny data area is limited to\n slightly under 32kbytes of data.\n \n-@item interrupt\n-@cindex interrupt handlers on the M32R/D\n-Use this option on the M32R/D to indicate that the specified\n-function is an interrupt handler.  The compiler will generate function\n-entry and exit sequences suitable for use in an interrupt handler when this\n-attribute is present.\n-\n-Interrupt handler functions on the AVR processors\n-Use this option on the AVR to indicate that the specified\n-function is an interrupt handler.  The compiler will generate function\n-entry and exit sequences suitable for use in an interrupt handler when this\n-attribute is present. Interrupts will be enabled inside function.\n-\n @item signal\n @cindex signal handler functions on the AVR processors\n Use this option on the AVR to indicate that the specified\n@@ -1800,10 +1808,10 @@ entry and exit sequences suitable for use in an signal handler when this\n attribute is present. Interrupts will be disabled inside function.\n \n @item naked\n-@cindex function without a prologue/epilogue code on the AVR processors\n-Use this option on the AVR to indicate that the specified\n-function don't have a prologue/epilogue.  The compiler don't generate\n-function entry and exit sequences.\n+@cindex function without a prologue/epilogue code\n+Use this option on the ARM or AVR ports to indicate that the specified\n+function do not need prologue/epilogue sequences generated by the\n+compiler.  It is up to the programmer to provide these sequences.\n \n @item model (@var{model-name})\n @cindex function addressability on the M32R/D"}]}