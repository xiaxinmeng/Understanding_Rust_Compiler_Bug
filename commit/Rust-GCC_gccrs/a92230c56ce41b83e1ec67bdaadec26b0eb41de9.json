{"sha": "a92230c56ce41b83e1ec67bdaadec26b0eb41de9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTkyMjMwYzU2Y2U0MWI4M2UxZWM2N2JkYWFkZWMyNmIwZWI0MWRlOQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-10-17T08:42:41Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-10-17T08:42:41Z"}, "message": "[multiple changes]\n\n2014-10-17  Robert Dewar  <dewar@adacore.com>\n\n\t* sem_util.adb: Minor reformatting.\n\n2014-10-17  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch12.adb (Build_Function_Wrapper): Build wrappers for\n\tactuals that are defaulted subprograms of the formal subprogram\n\tdeclaration.\n\n2014-10-17  Robert Dewar  <dewar@adacore.com>\n\n\t* exp_ch4.adb (Expand_N_Op_Eq): Make sure we deal with the\n\timplementation base type.\n\t* sinfo.ads: Add a note for N_Op_Eq and N_Op_Ne that record\n\toperands are always expanded out into component comparisons.\n\n2014-10-17  Robert Dewar  <dewar@adacore.com>\n\n\t* s-vallli.adb: Minor comment correction.\n\t* s-valuti.ads: Minor comment reformatting.\n\n2014-10-17  Robert Dewar  <dewar@adacore.com>\n\n\t* gnat_rm.texi: Document System.Atomic_Counters.\n\t* impunit.adb: Add System.Atomic_Counters (s-atocou.ads) to the\n\tlist of user- accessible units added as children of System.\n\t* s-atocou.ads: Update comment.\n\n2014-10-17  Arnaud Charlet  <charlet@adacore.com>\n\n\t* s-expmod.ads: Add comments.\n\nFrom-SVN: r216371", "tree": {"sha": "7635a8604e038a607885229eb96aee7a0317ba4e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7635a8604e038a607885229eb96aee7a0317ba4e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a92230c56ce41b83e1ec67bdaadec26b0eb41de9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a92230c56ce41b83e1ec67bdaadec26b0eb41de9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a92230c56ce41b83e1ec67bdaadec26b0eb41de9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a92230c56ce41b83e1ec67bdaadec26b0eb41de9/comments", "author": null, "committer": null, "parents": [{"sha": "38d0d6c854d9fc64b2c52a73af8db8af247eb0b7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38d0d6c854d9fc64b2c52a73af8db8af247eb0b7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/38d0d6c854d9fc64b2c52a73af8db8af247eb0b7"}], "stats": {"total": 319, "additions": 196, "deletions": 123}, "files": [{"sha": "b40757165eed7f823f1aebff6254f9a5224aeb36", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a92230c56ce41b83e1ec67bdaadec26b0eb41de9/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a92230c56ce41b83e1ec67bdaadec26b0eb41de9/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=a92230c56ce41b83e1ec67bdaadec26b0eb41de9", "patch": "@@ -1,3 +1,36 @@\n+2014-10-17  Robert Dewar  <dewar@adacore.com>\n+\n+\t* sem_util.adb: Minor reformatting.\n+\n+2014-10-17  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch12.adb (Build_Function_Wrapper): Build wrappers for\n+\tactuals that are defaulted subprograms of the formal subprogram\n+\tdeclaration.\n+\n+2014-10-17  Robert Dewar  <dewar@adacore.com>\n+\n+\t* exp_ch4.adb (Expand_N_Op_Eq): Make sure we deal with the\n+\timplementation base type.\n+\t* sinfo.ads: Add a note for N_Op_Eq and N_Op_Ne that record\n+\toperands are always expanded out into component comparisons.\n+\n+2014-10-17  Robert Dewar  <dewar@adacore.com>\n+\n+\t* s-vallli.adb: Minor comment correction.\n+\t* s-valuti.ads: Minor comment reformatting.\n+\n+2014-10-17  Robert Dewar  <dewar@adacore.com>\n+\n+\t* gnat_rm.texi: Document System.Atomic_Counters.\n+\t* impunit.adb: Add System.Atomic_Counters (s-atocou.ads) to the\n+\tlist of user- accessible units added as children of System.\n+\t* s-atocou.ads: Update comment.\n+\n+2014-10-17  Arnaud Charlet  <charlet@adacore.com>\n+\n+\t* s-expmod.ads: Add comments.\n+\n 2014-10-17  Hristian Kirtchev  <kirtchev@adacore.com>\n \n \t* sem_ch3.adb (Build_Derived_Record_Type): Remove the propagation"}, {"sha": "5fdba539c28d3df7e37fab83d0b1430b1e599555", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a92230c56ce41b83e1ec67bdaadec26b0eb41de9/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a92230c56ce41b83e1ec67bdaadec26b0eb41de9/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=a92230c56ce41b83e1ec67bdaadec26b0eb41de9", "patch": "@@ -7152,7 +7152,10 @@ package body Exp_Ch4 is\n          return;\n       end if;\n \n-      Typl := Base_Type (Typl);\n+      --  Now get the implementation base type (note that plain Base_Type here\n+      --  might lead us back to the private type, which is not what we want!)\n+\n+      Typl := Implementation_Base_Type (Typl);\n \n       --  Equality between variant records results in a call to a routine\n       --  that has conditional tests of the discriminant value(s), and hence"}, {"sha": "4258722a9393cb6eab4df8237c7f3b9289ef7d61", "filename": "gcc/ada/gnat_rm.texi", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a92230c56ce41b83e1ec67bdaadec26b0eb41de9/gcc%2Fada%2Fgnat_rm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a92230c56ce41b83e1ec67bdaadec26b0eb41de9/gcc%2Fada%2Fgnat_rm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_rm.texi?ref=a92230c56ce41b83e1ec67bdaadec26b0eb41de9", "patch": "@@ -661,6 +661,7 @@ The GNAT Library\n * Interfaces.VxWorks.IO (i-vxwoio.ads)::\n * System.Address_Image (s-addima.ads)::\n * System.Assertions (s-assert.ads)::\n+* System.Atomic_Counters (s-atocou.ads)::\n * System.Memory (s-memory.ads)::\n * System.Multiprocessors (s-multip.ads)::\n * System.Multiprocessors.Dispatching_Domains (s-mudido.ads)::\n@@ -19074,6 +19075,7 @@ of GNAT, and will generate a warning message.\n * Interfaces.VxWorks.IO (i-vxwoio.ads)::\n * System.Address_Image (s-addima.ads)::\n * System.Assertions (s-assert.ads)::\n+* System.Atomic_Counters (s-atocou.ads)::\n * System.Memory (s-memory.ads)::\n * System.Multiprocessors (s-multip.ads)::\n * System.Multiprocessors.Dispatching_Domains (s-mudido.ads)::\n@@ -20585,6 +20587,18 @@ This package provides the declaration of the exception raised\n by an run-time assertion failure, as well as the routine that\n is used internally to raise this assertion.\n \n+@node System.Atomic_Counters (s-atocou.ads)\n+@section @code{System.Atomic_Counters} (@file{s-atocou.ads})\n+@cindex @code{System.Atomic_Counters} (@file{s-atocou.ads})\n+\n+@noindent\n+This package provides the declaration of an atomic counter type,\n+together with efficient routines (using hardware\n+synchronization primitives) for incrementing, decrementing,\n+and testing of these counters. This package is implemented\n+on most targets, including all Alpha, ia64, PowerPC, SPARC V9,\n+x86, and x86_64 platforms.\n+\n @node System.Memory (s-memory.ads)\n @section @code{System.Memory} (@file{s-memory.ads})\n @cindex @code{System.Memory} (@file{s-memory.ads})"}, {"sha": "49baf1651c2bab85cff8c5e5c3ea476a82663393", "filename": "gcc/ada/impunit.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a92230c56ce41b83e1ec67bdaadec26b0eb41de9/gcc%2Fada%2Fimpunit.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a92230c56ce41b83e1ec67bdaadec26b0eb41de9/gcc%2Fada%2Fimpunit.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fimpunit.adb?ref=a92230c56ce41b83e1ec67bdaadec26b0eb41de9", "patch": "@@ -367,6 +367,7 @@ package body Impunit is\n    --------------------------------------\n \n     (\"s-addima\", F),  -- System.Address_Image\n+    (\"s-atocou\", F),  -- System.Atomic_Counters\n     (\"s-assert\", F),  -- System.Assertions\n     (\"s-diflio\", F),  -- System.Dim.Float_IO\n     (\"s-diinio\", F),  -- System.Dim.Integer_IO"}, {"sha": "a2e6d897efb469a722b65c8137c18de42798004d", "filename": "gcc/ada/s-atocou.ads", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a92230c56ce41b83e1ec67bdaadec26b0eb41de9/gcc%2Fada%2Fs-atocou.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a92230c56ce41b83e1ec67bdaadec26b0eb41de9/gcc%2Fada%2Fs-atocou.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-atocou.ads?ref=a92230c56ce41b83e1ec67bdaadec26b0eb41de9", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2011-2013, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2011-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -37,8 +37,6 @@\n --    - all x86 platforms\n --    - all x86_64 platforms\n \n---  Why isn't this package available to application programs???\n-\n package System.Atomic_Counters is\n \n    pragma Preelaborate;\n@@ -59,20 +57,19 @@ package System.Atomic_Counters is\n \n    function Decrement (Item : in out Atomic_Counter) return Boolean;\n    pragma Inline_Always (Decrement);\n-   --  Decrements value of atomic counter, returns True when value reach zero.\n+   --  Decrements value of atomic counter, returns True when value reach zero\n \n    function Is_One (Item : Atomic_Counter) return Boolean;\n    pragma Inline_Always (Is_One);\n-   --  Returns True when value of the atomic counter is one.\n+   --  Returns True when value of the atomic counter is one\n \n    procedure Initialize (Item : out Atomic_Counter);\n    pragma Inline_Always (Initialize);\n    --  Initialize counter by setting its value to one. This subprogram is\n-   --  intended to be used in special cases when counter object can't be\n+   --  intended to be used in special cases when the counter object cannot be\n    --  initialized in standard way.\n \n private\n-\n    type Unsigned_32 is mod 2 ** 32;\n \n    type Atomic_Counter is limited record"}, {"sha": "c90691523b0eb5a68b69a9f51cc74258129b789c", "filename": "gcc/ada/s-expmod.ads", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a92230c56ce41b83e1ec67bdaadec26b0eb41de9/gcc%2Fada%2Fs-expmod.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a92230c56ce41b83e1ec67bdaadec26b0eb41de9/gcc%2Fada%2Fs-expmod.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-expmod.ads?ref=a92230c56ce41b83e1ec67bdaadec26b0eb41de9", "patch": "@@ -32,15 +32,25 @@\n --  This function performs exponentiation of a modular type with non-binary\n --  modulus values. Arithmetic is done in Long_Long_Unsigned, with explicit\n --  accounting for the modulus value which is passed as the second argument.\n+--  Note that 1 is a binary modulus (2**0), so the compiler should not (and\n+--  will not) call this function with Modulus equal to 1).\n \n with System.Unsigned_Types;\n \n package System.Exp_Mod is\n    pragma Pure;\n+   use type System.Unsigned_Types.Unsigned;\n+\n+   subtype Power_Of_2 is System.Unsigned_Types.Unsigned with\n+     Dynamic_Predicate =>\n+        Power_Of_2 /= 0 and then (Power_Of_2 and (Power_Of_2 - 1)) = 0;\n \n    function Exp_Modular\n      (Left    : System.Unsigned_Types.Unsigned;\n       Modulus : System.Unsigned_Types.Unsigned;\n-      Right   : Natural) return System.Unsigned_Types.Unsigned;\n+      Right   : Natural) return System.Unsigned_Types.Unsigned\n+   with\n+       Pre  => Modulus /= 0 and then Modulus not in Power_Of_2,\n+       Post => Exp_Modular'Result = Left ** Right mod Modulus;\n \n end System.Exp_Mod;"}, {"sha": "203e475b3cff5b71d889bf67db477fce1b74a344", "filename": "gcc/ada/s-vallli.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a92230c56ce41b83e1ec67bdaadec26b0eb41de9/gcc%2Fada%2Fs-vallli.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a92230c56ce41b83e1ec67bdaadec26b0eb41de9/gcc%2Fada%2Fs-vallli.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-vallli.adb?ref=a92230c56ce41b83e1ec67bdaadec26b0eb41de9", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2012, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -51,7 +51,7 @@ package body System.Val_LLI is\n       --  Set to True if minus sign is present, otherwise to False\n \n       Start : Positive;\n-      --  Saves location of first non-blank (not used in this case)\n+      --  Saves location of first non-blank\n \n    begin\n       Scan_Sign (Str, Ptr, Max, Minus, Start);"}, {"sha": "e69af0f089f8190453810a3624c92af187d559bb", "filename": "gcc/ada/s-valuti.ads", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a92230c56ce41b83e1ec67bdaadec26b0eb41de9/gcc%2Fada%2Fs-valuti.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a92230c56ce41b83e1ec67bdaadec26b0eb41de9/gcc%2Fada%2Fs-valuti.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-valuti.ads?ref=a92230c56ce41b83e1ec67bdaadec26b0eb41de9", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2012, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -43,9 +43,9 @@ package System.Val_Util is\n       F, L : out Integer);\n    --  This procedure scans the string S setting F to be the index of the first\n    --  non-blank character of S and L to be the index of the last non-blank\n-   --  character of S. Any lower case characters present in S will be folded\n-   --  to their upper case equivalent except for character literals. If S\n-   --  consists of entirely blanks then Constraint_Error is raised.\n+   --  character of S. Any lower case characters present in S will be folded to\n+   --  their upper case equivalent except for character literals. If S consists\n+   --  of entirely blanks then Constraint_Error is raised.\n    --\n    --  Note: if S is the null string, F is set to S'First, L to S'Last\n \n@@ -60,25 +60,25 @@ package System.Val_Util is\n    --  last character in the string). Scan_Sign first scans out any initial\n    --  blanks, raising Constraint_Error if the field is all blank. It then\n    --  checks for and skips an initial plus or minus, requiring a non-blank\n-   --  character to follow (Constraint_Error is raised if plus or minus\n-   --  appears at the end of the string or with a following blank). Minus is\n-   --  set True if a minus sign was skipped, and False otherwise. On exit\n-   --  Ptr.all points to the character after the sign, or to the first\n-   --  non-blank character if no sign is present. Start is set to the point\n-   --  to the first non-blank character (sign or digit after it).\n+   --  character to follow (Constraint_Error is raised if plus or minus appears\n+   --  at the end of the string or with a following blank). Minus is set True\n+   --  if a minus sign was skipped, and False otherwise. On exit Ptr.all points\n+   --  to the character after the sign, or to the first non-blank character\n+   --  if no sign is present. Start is set to the point to the first non-blank\n+   --  character (sign or digit after it).\n    --\n    --  Note: if Str is null, i.e. if Max is less than Ptr, then this is a\n    --  special case of an all-blank string, and Ptr is unchanged, and hence\n-   --  is greater than Max as required in this case. Constraint_Error is\n-   --  also raised in this case.\n+   --  is greater than Max as required in this case. Constraint_Error is also\n+   --  raised in this case.\n \n    procedure Scan_Plus_Sign\n      (Str   : String;\n       Ptr   : not null access Integer;\n       Max   : Integer;\n       Start : out Positive);\n-   --  Same as Scan_Sign, but allows only plus, not minus.\n-   --  This is used for modular types.\n+   --  Same as Scan_Sign, but allows only plus, not minus. This is used for\n+   --  modular types.\n \n    function Scan_Exponent\n      (Str  : String;"}, {"sha": "277b7eff469426388cb35acf7408f48055daf9ab", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 26, "deletions": 12, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a92230c56ce41b83e1ec67bdaadec26b0eb41de9/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a92230c56ce41b83e1ec67bdaadec26b0eb41de9/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=a92230c56ce41b83e1ec67bdaadec26b0eb41de9", "patch": "@@ -1056,7 +1056,12 @@ package body Sem_Ch12 is\n          Actuals := New_List;\n          Profile := New_List;\n \n-         F := First_Formal (Entity (Actual));\n+         if Present (Actual) then\n+            F := First_Formal (Entity (Actual));\n+         else\n+            F := First_Formal (Formal);\n+         end if;\n+\n          N_Parms := 0;\n          while Present (F) loop\n \n@@ -1066,16 +1071,26 @@ package body Sem_Ch12 is\n             New_F := Make_Temporary\n                        (Loc, Character'Val (Character'Pos ('A') + N_Parms));\n \n-            --  If a formal has a class-wide type, rewrite as the corresponding\n-            --  attribute, because the class-wide type is not retrievable by\n-            --  visbility.\n+            if No (Actual) then\n+\n+               --  If formal has a class-wide type rewrite as the corresponding\n+               --  attribute, because the class-wide type is not retrievable by\n+               --  visbility.\n+\n+               if Is_Class_Wide_Type (Etype (F)) then\n+                  Parm_Type :=\n+                    Make_Attribute_Reference (Loc,\n+                      Attribute_Name => Name_Class,\n+                      Prefix         =>\n+                        Make_Identifier (Loc, Chars (Etype (Etype (F)))));\n+\n+               else\n+                  Parm_Type :=\n+                    Make_Identifier (Loc, Chars (Etype (Etype (F))));\n+               end if;\n+\n+            --  If actual is present, use the type of its own formal\n \n-            if Is_Class_Wide_Type (Etype (F)) then\n-               Parm_Type :=\n-                 Make_Attribute_Reference (Loc,\n-                   Attribute_Name => Name_Class,\n-                   Prefix         =>\n-                     Make_Identifier (Loc, Chars (Etype (Etype (F)))));\n             else\n                Parm_Type := New_Occurrence_Of (Etype (F), Loc);\n             end if;\n@@ -1766,8 +1781,7 @@ package body Sem_Ch12 is\n \n                   else\n                      if GNATprove_Mode\n-                       and then\n-                         Present\n+                        and then Present\n                            (Containing_Package_With_Ext_Axioms\n                               (Defining_Entity (Analyzed_Formal)))\n                        and then Ekind (Defining_Entity (Analyzed_Formal)) ="}, {"sha": "1eac0b2ffd011f48931394f3b1b09ba268b44201", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 82, "deletions": 86, "changes": 168, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a92230c56ce41b83e1ec67bdaadec26b0eb41de9/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a92230c56ce41b83e1ec67bdaadec26b0eb41de9/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=a92230c56ce41b83e1ec67bdaadec26b0eb41de9", "patch": "@@ -371,8 +371,7 @@ package body Sem_Util is\n             raise Program_Error;\n          end if;\n \n-      --  Contract items related to subprogram bodies. The applicable pragmas\n-      --  are:\n+      --  Contract items related to subprogram bodies. Applicable pragmas are:\n       --    Refined_Depends\n       --    Refined_Global\n       --    Refined_Post\n@@ -392,7 +391,7 @@ package body Sem_Util is\n             raise Program_Error;\n          end if;\n \n-      --  Contract items related to variables. The applicable pragmas are:\n+      --  Contract items related to variables. Applicable pragmas are:\n       --    Async_Readers\n       --    Async_Writers\n       --    Effective_Reads\n@@ -801,9 +800,7 @@ package body Sem_Util is\n             return;\n          end if;\n \n-         if Is_Generic_Formal (Typ)\n-           and then Is_Discrete_Type (Typ)\n-         then\n+         if Is_Generic_Formal (Typ) and then Is_Discrete_Type (Typ) then\n             Set_No_Predicate_On_Actual (Typ);\n          end if;\n \n@@ -1442,8 +1439,7 @@ package body Sem_Util is\n       pragma Assert (Has_Default_Init_Cond (Typ));\n       pragma Assert (Present (Prag));\n \n-      --  Nothing to do if the default initial condition procedure was already\n-      --  built.\n+      --  Nothing to do if default initial condition procedure already built\n \n       if Present (Default_Init_Cond_Procedure (Typ)) then\n          return;\n@@ -1909,7 +1905,7 @@ package body Sem_Util is\n                   return False;\n                else\n                   return\n-                    Cannot_Raise_Constraint_Error (Left_Opnd (Expr))\n+                    Cannot_Raise_Constraint_Error (Left_Opnd  (Expr))\n                       and then\n                     Cannot_Raise_Constraint_Error (Right_Opnd (Expr));\n                end if;\n@@ -1938,7 +1934,7 @@ package body Sem_Util is\n                   return False;\n                else\n                   return\n-                    Cannot_Raise_Constraint_Error (Left_Opnd (Expr))\n+                    Cannot_Raise_Constraint_Error (Left_Opnd  (Expr))\n                       and then\n                     Cannot_Raise_Constraint_Error (Right_Opnd (Expr));\n                end if;\n@@ -1992,6 +1988,7 @@ package body Sem_Util is\n            and then Ekind (Non_Limited_View (T)) /= E_Incomplete_Type\n          then\n             --  The non-limited view is fully declared\n+\n             null;\n \n          else\n@@ -2429,7 +2426,7 @@ package body Sem_Util is\n                            elsif Nkind_In (Choice, N_Range,\n                                                    N_Subtype_Indication)\n                              or else (Is_Entity_Name (Choice)\n-                                        and then Is_Type (Entity (Choice)))\n+                                       and then Is_Type (Entity (Choice)))\n                            then\n                               declare\n                                  L, H : Node_Id;\n@@ -3049,7 +3046,8 @@ package body Sem_Util is\n            Comes_From_Source (N)\n              and then Is_Entity_Name (N)\n              and then (Entity (N) = Standard_True\n-                        or else Entity (N) = Standard_False);\n+                         or else\n+                       Entity (N) = Standard_False);\n       end Is_Trivial_Boolean;\n \n       -------------------------\n@@ -4747,7 +4745,8 @@ package body Sem_Util is\n             --  attempt to detect partial overlap of slices.\n \n             return Denotes_Same_Object (Lo1, Lo2)\n-              and then Denotes_Same_Object (Hi1, Hi2);\n+                     and then\n+                   Denotes_Same_Object (Hi1, Hi2);\n          end;\n \n       --  In the recursion, literals appear as indexes\n@@ -4788,7 +4787,7 @@ package body Sem_Util is\n             Nkind_In (A2, N_Selected_Component, N_Indexed_Component, N_Slice)\n       then\n          declare\n-            Root1, Root2 : Node_Id;\n+            Root1, Root2   : Node_Id;\n             Depth1, Depth2 : Int := 0;\n \n          begin\n@@ -4807,8 +4806,8 @@ package body Sem_Util is\n \n             Root2 := Prefix (A2);\n             while not Is_Entity_Name (Root2) loop\n-               if not Nkind_In\n-                 (Root2, N_Selected_Component, N_Indexed_Component)\n+               if not Nkind_In (Root2, N_Selected_Component,\n+                                       N_Indexed_Component)\n                then\n                   return False;\n                else\n@@ -4826,15 +4825,15 @@ package body Sem_Util is\n \n             elsif Depth1 > Depth2 then\n                Root1 := Prefix (A1);\n-               for I in 1 .. Depth1 - Depth2 - 1 loop\n+               for J in 1 .. Depth1 - Depth2 - 1 loop\n                   Root1 := Prefix (Root1);\n                end loop;\n \n                return Denotes_Same_Object (Root1, A2);\n \n             else\n                Root2 := Prefix (A2);\n-               for I in 1 .. Depth2 - Depth1 - 1 loop\n+               for J in 1 .. Depth2 - Depth1 - 1 loop\n                   Root2 := Prefix (Root2);\n                end loop;\n \n@@ -4897,7 +4896,6 @@ package body Sem_Util is\n       begin\n          if Nkind (N) = N_Defining_Program_Unit_Name then\n             return Name (N);\n-\n          else\n             return Prefix (N);\n          end if;\n@@ -4911,7 +4909,6 @@ package body Sem_Util is\n       begin\n          if Nkind (N) = N_Defining_Program_Unit_Name then\n             return Defining_Identifier (N);\n-\n          else\n             return Selector_Name (N);\n          end if;\n@@ -6552,9 +6549,8 @@ package body Sem_Util is\n          if In_Spec_Expression then\n             return Typ;\n \n-         elsif Is_Private_Type (Typ)\n-           and then not Has_Discriminants (Typ)\n-         then\n+         elsif Is_Private_Type (Typ) and then not Has_Discriminants (Typ) then\n+\n             --  If the type has no discriminants, there is no subtype to\n             --  build, even if the underlying type is discriminated.\n \n@@ -6793,7 +6789,6 @@ package body Sem_Util is\n       --  For all other cases, we have a complete table of literals, and\n       --  we simply iterate through the chain of literal until the one\n       --  with the desired position value is found.\n-      --\n \n       else\n          if Is_Private_Type (Btyp) and then Present (Full_View (Btyp)) then\n@@ -7579,7 +7574,7 @@ package body Sem_Util is\n \n          elsif Default /= Unknown\n            and then (Has_Size_Clause      (Etype (Expr))\n-                      or else\n+                       or else\n                      Has_Alignment_Clause (Etype (Expr)))\n          then\n             Set_Result (Unknown);\n@@ -7881,13 +7876,13 @@ package body Sem_Util is\n          --  property is enabled when the flag evaluates to True or the flag is\n          --  missing altogether.\n \n-         elsif Property = Name_Async_Readers and then Is_Enabled (AR) then\n+         elsif Property = Name_Async_Readers    and then Is_Enabled (AR) then\n             return True;\n \n-         elsif Property = Name_Async_Writers and then Is_Enabled (AW) then\n+         elsif Property = Name_Async_Writers    and then Is_Enabled (AW) then\n             return True;\n \n-         elsif Property = Name_Effective_Reads and then Is_Enabled (ER) then\n+         elsif Property = Name_Effective_Reads  and then Is_Enabled (ER) then\n             return True;\n \n          elsif Property = Name_Effective_Writes and then Is_Enabled (EW) then\n@@ -8027,7 +8022,7 @@ package body Sem_Util is\n \n       elsif Nkind (N) in N_Binary_Op or else Nkind (N) in N_Short_Circuit then\n          return Has_No_Obvious_Side_Effects (Left_Opnd  (N))\n-                  and then\n+                   and then\n                 Has_No_Obvious_Side_Effects (Right_Opnd (N));\n \n       elsif Nkind (N) = N_Expression_With_Actions\n@@ -8247,10 +8242,8 @@ package body Sem_Util is\n             elsif Is_Entity_Name (N)\n               and then\n                 (Ekind (Entity (N)) = E_Discriminant\n-                  or else\n-                    ((Ekind (Entity (N)) = E_Constant\n-                       or else Ekind (Entity (N)) = E_In_Parameter)\n-                     and then Present (Discriminal_Link (Entity (N)))))\n+                  or else (Ekind_In (Entity (N), E_Constant, E_In_Parameter)\n+                            and then Present (Discriminal_Link (Entity (N)))))\n             then\n                return True;\n \n@@ -8260,9 +8253,7 @@ package body Sem_Util is\n             --  For aggregates we have to check that each of the associations\n             --  is preelaborable.\n \n-            elsif Nkind (N) = N_Aggregate\n-              or else Nkind (N) = N_Extension_Aggregate\n-            then\n+            elsif Nkind_In (N, N_Aggregate, N_Extension_Aggregate) then\n                Is_Array_Aggr := Is_Array_Type (Etype (N));\n \n                if Is_Array_Aggr then\n@@ -8564,7 +8555,8 @@ package body Sem_Util is\n             if No (UT) then\n                if No (Full_View (Btype)) then\n                   return not Is_Generic_Type (Btype)\n-                    and then not Is_Generic_Type (Root_Type (Btype));\n+                            and then\n+                         not Is_Generic_Type (Root_Type (Btype));\n                else\n                   return not Is_Generic_Type (Root_Type (Full_View (Btype)));\n                end if;\n@@ -8749,9 +8741,7 @@ package body Sem_Util is\n       Comp : Entity_Id;\n \n    begin\n-      if Is_Private_Type (Typ)\n-        and then Present (Underlying_Type (Typ))\n-      then\n+      if Is_Private_Type (Typ) and then Present (Underlying_Type (Typ)) then\n          return Has_Tagged_Component (Underlying_Type (Typ));\n \n       elsif Is_Array_Type (Typ) then\n@@ -8926,9 +8916,7 @@ package body Sem_Util is\n    begin\n       S := Current_Scope;\n       while Present (S) and then S /= Standard_Standard loop\n-         if (Ekind (S) = E_Function\n-              or else Ekind (S) = E_Package\n-              or else Ekind (S) = E_Procedure)\n+         if Ekind_In (S, E_Function, E_Package, E_Procedure)\n            and then Is_Generic_Instance (S)\n          then\n             --  A child instance is always compiled in the context of a parent\n@@ -9479,8 +9467,8 @@ package body Sem_Util is\n                            and then Is_Aliased_View (Renamed_Object (E)))))\n \n            or else ((Is_Formal (E)\n-                      or else Ekind (E) = E_Generic_In_Out_Parameter\n-                      or else Ekind (E) = E_Generic_In_Parameter)\n+                      or else Ekind_In (E, E_Generic_In_Out_Parameter,\n+                                           E_Generic_In_Parameter))\n                     and then Is_Tagged_Type (Etype (E)))\n \n            or else (Is_Concurrent_Type (E) and then In_Open_Scopes (E))\n@@ -9842,9 +9830,9 @@ package body Sem_Util is\n    begin\n       return Is_Interface (T)\n         and then\n-            (Is_Protected_Interface (T)\n-               or else Is_Synchronized_Interface (T)\n-               or else Is_Task_Interface (T));\n+          (Is_Protected_Interface (T)\n+            or else Is_Synchronized_Interface (T)\n+            or else Is_Task_Interface (T));\n    end Is_Concurrent_Interface;\n \n    ---------------------------\n@@ -10282,9 +10270,9 @@ package body Sem_Util is\n             if not Is_Constrained (Prefix_Type)\n               and then (not Is_Indefinite_Subtype (Prefix_Type)\n                          or else\n-                          (Is_Generic_Type (Prefix_Type)\n-                            and then Ekind (Current_Scope) = E_Generic_Package\n-                            and then In_Package_Body (Current_Scope)))\n+                           (Is_Generic_Type (Prefix_Type)\n+                             and then Ekind (Current_Scope) = E_Generic_Package\n+                             and then In_Package_Body (Current_Scope)))\n \n               and then (Is_Declared_Within_Variant (Comp)\n                          or else Has_Discriminant_Dependent_Constraint (Comp))\n@@ -10518,11 +10506,17 @@ package body Sem_Util is\n \n    function Is_Fully_Initialized_Type (Typ : Entity_Id) return Boolean is\n    begin\n-      --  In Ada2012, a scalar type with an aspect Default_Value\n-      --  is fully initialized.\n+      --  Scalar types\n \n       if Is_Scalar_Type (Typ) then\n-         return Ada_Version >= Ada_2012 and then Has_Default_Aspect (Typ);\n+\n+         --  A scalar type with an aspect Default_Value is fully initialized\n+\n+         --  Note: Iniitalize/Normalize_Scalars also ensure full initialization\n+         --  of a scalar type, but we don't take that into account here, since\n+         --  we don't want these to affect warnings.\n+\n+         return Has_Default_Aspect (Typ);\n \n       elsif Is_Access_Type (Typ) then\n          return True;\n@@ -11786,7 +11780,10 @@ package body Sem_Util is\n             Comp_Assn := First (Component_Associations (Orig_N));\n             while Present (Comp_Assn) loop\n                Expr := Expression (Comp_Assn);\n-               if Present (Expr)  --  needed for box association\n+\n+               --  Note: test for Present here needed for box assocation\n+\n+               if Present (Expr)\n                  and then not Is_SPARK_05_Initialization_Expr (Expr)\n                then\n                   Is_Ok := False;\n@@ -11890,7 +11887,8 @@ package body Sem_Util is\n \n       return (Is_Tagged_Type (E)\n                 and then (Kind = E_Task_Type\n-                           or else Kind = E_Protected_Type))\n+                            or else\n+                          Kind = E_Protected_Type))\n             or else\n              (Is_Interface (E)\n                 and then Is_Synchronized_Interface (E))\n@@ -12215,13 +12213,13 @@ package body Sem_Util is\n             K : constant Entity_Kind := Ekind (E);\n \n          begin\n-            return     (K = E_Variable\n-                         and then Nkind (Parent (E)) /= N_Exception_Handler)\n-              or else  (K = E_Component\n-                         and then not In_Protected_Function (E))\n-              or else  K = E_Out_Parameter\n-              or else  K = E_In_Out_Parameter\n-              or else  K = E_Generic_In_Out_Parameter\n+            return    (K = E_Variable\n+                        and then Nkind (Parent (E)) /= N_Exception_Handler)\n+              or else (K = E_Component\n+                        and then not In_Protected_Function (E))\n+              or else K = E_Out_Parameter\n+              or else K = E_In_Out_Parameter\n+              or else K = E_Generic_In_Out_Parameter\n \n               --  Current instance of type. If this is a protected type, check\n               --  we are not within the body of one of its protected functions.\n@@ -12270,10 +12268,10 @@ package body Sem_Util is\n                return Is_Variable (Expression (Orig_Node))\n                  and then\n                    (not Comes_From_Source (Orig_Node)\n-                      or else\n-                        (Is_Tagged_Type (Etype (Subtype_Mark (Orig_Node)))\n-                          and then\n-                         Is_Tagged_Type (Etype (Expression (Orig_Node)))));\n+                     or else\n+                       (Is_Tagged_Type (Etype (Subtype_Mark (Orig_Node)))\n+                         and then\n+                        Is_Tagged_Type (Etype (Expression (Orig_Node)))));\n \n             --  GNAT allows an unchecked type conversion as a variable. This\n             --  only affects the generation of internal expanded code, since\n@@ -13103,9 +13101,9 @@ package body Sem_Util is\n       end if;\n    end New_Copy_List_Tree;\n \n-   -------------------\n-   -- New_Copy_Tree --\n-   -------------------\n+   --------------------------------------------------\n+   -- New_Copy_Tree Auxiliary Data and Subprograms --\n+   --------------------------------------------------\n \n    use Atree.Unchecked_Access;\n    use Atree_Private_Part;\n@@ -13168,7 +13166,9 @@ package body Sem_Util is\n      Hash       => New_Copy_Hash,\n      Equal      => Types.\"=\");\n \n-   --  Start of processing for New_Copy_Tree function\n+   -------------------\n+   -- New_Copy_Tree --\n+   -------------------\n \n    function New_Copy_Tree\n      (Source    : Node_Id;\n@@ -14321,9 +14321,9 @@ package body Sem_Util is\n                      then\n                         if No (Actuals)\n                           and then\n-                           Nkind_In (Parent (N), N_Procedure_Call_Statement,\n-                                                 N_Function_Call,\n-                                                 N_Parameter_Association)\n+                            Nkind_In (Parent (N), N_Procedure_Call_Statement,\n+                                                  N_Function_Call,\n+                                                  N_Parameter_Association)\n                           and then Ekind (S) /= E_Function\n                         then\n                            Set_Etype (N, Etype (S));\n@@ -14332,8 +14332,8 @@ package body Sem_Util is\n                            Error_Msg_Name_1 := Chars (S);\n                            Error_Msg_Sloc := Sloc (S);\n                            Error_Msg_NE\n-                             (\"missing argument for parameter & \" &\n-                                \"in call to % declared #\", N, Formal);\n+                             (\"missing argument for parameter & \"\n+                              & \"in call to % declared #\", N, Formal);\n                         end if;\n \n                      elsif Is_Overloadable (S) then\n@@ -14345,8 +14345,8 @@ package body Sem_Util is\n                         Error_Msg_Sloc := Sloc (Parent (S));\n \n                         Error_Msg_NE\n-                          (\"missing argument for parameter & \" &\n-                             \"in call to % (inherited) #\", N, Formal);\n+                          (\"missing argument for parameter & \"\n+                           & \"in call to % (inherited) #\", N, Formal);\n \n                      else\n                         Error_Msg_NE\n@@ -14504,8 +14504,7 @@ package body Sem_Util is\n                   --  sure this is a modification.\n \n                   if Has_Pragma_Unmodified (Ent) and then Sure then\n-                     Error_Msg_NE\n-                       (\"??pragma Unmodified given for &!\", N, Ent);\n+                     Error_Msg_NE (\"??pragma Unmodified given for &!\", N, Ent);\n                   end if;\n \n                   Set_Never_Set_In_Source (Ent, False);\n@@ -15049,7 +15048,7 @@ package body Sem_Util is\n       --  would cause infinite recursion.\n \n       elsif Ekind (Subp) = E_Function\n-        and then (Is_Predicate_Function (Subp)\n+        and then (Is_Predicate_Function   (Subp)\n                     or else\n                   Is_Predicate_Function_M (Subp))\n       then\n@@ -15780,11 +15779,7 @@ package body Sem_Util is\n \n       if (Ekind (Ent) = E_Variable and then No (Renamed_Object (Ent)))\n             or else\n-          Ekind (Ent) = E_Constant\n-            or else\n-          Ekind (Ent) = E_Out_Parameter\n-            or else\n-          Ekind (Ent) = E_In_Out_Parameter\n+          Ekind_In (Ent, E_Constant, E_Out_Parameter, E_In_Out_Parameter)\n       then\n          null;\n \n@@ -17789,6 +17784,7 @@ package body Sem_Util is\n                Op : constant Node_Id := Right_Opnd (Parent (Expr));\n                L  : constant Node_Id := Left_Opnd (Op);\n                R  : constant Node_Id := Right_Opnd (Op);\n+\n             begin\n                --  The case for the message is when the left operand of the\n                --  comparison is the same modular type, or when it is an"}, {"sha": "bfa33e0b9e46a63917fe862da98f1c7f2519143d", "filename": "gcc/ada/sinfo.ads", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a92230c56ce41b83e1ec67bdaadec26b0eb41de9/gcc%2Fada%2Fsinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a92230c56ce41b83e1ec67bdaadec26b0eb41de9/gcc%2Fada%2Fsinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.ads?ref=a92230c56ce41b83e1ec67bdaadec26b0eb41de9", "patch": "@@ -4246,6 +4246,11 @@ package Sinfo is\n       --  point operands if the Treat_Fixed_As_Integer flag is set and will\n       --  thus treat these nodes in identical manner, ignoring small values.\n \n+      --  Note on equality/inequality tests for records. In the expanded tree,\n+      --  record comparisons are always expanded to be a series of component\n+      --  comparisons, so the back end will never see an equality or inequality\n+      --  operation with operands of a record type.\n+\n       --  Note on overflow handling: When the overflow checking mode is set to\n       --  MINIMIZED or ELIMINATED, nodes for signed arithmetic operations may\n       --  be modified to use a larger type for the operands and result. In"}]}