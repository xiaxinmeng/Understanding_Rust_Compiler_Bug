{"sha": "d32db3a763249a8b94c2e2e285fc6f400eadea4e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDMyZGIzYTc2MzI0OWE4Yjk0YzJlMmUyODVmYzZmNDAwZWFkZWE0ZQ==", "commit": {"author": {"name": "Gary Dismukes", "email": "dismukes@adacore.com", "date": "2021-03-05T07:20:09Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2021-06-17T14:32:16Z"}, "message": "[Ada] Implementation of Inox feature of fixed lower bounds on array types/subtypes\n\ngcc/ada/\n\n\t* checks.adb (Discrete_Range_Cond): For an index subtype that\n\thas a fixed lower bound, require that the range's lower bound\n\tmatch that of the subtype.\n\t(Selected_Range_Checks): Warn about the case where a static\n\tlower bound does not equal an index subtype's fixed lower bound.\n\t* einfo.ads (Is_Fixed_Lower_Bound_Array_Subtype,\n\tIs_Fixed_Lower_Bound_Index_Subtype): Document new entity flag.\n\t* exp_ch4.adb (Expand_N_Type_Conversion): If the operand is of\n\tan unconstrained array subtype with fixed lower bound, then\n\tExpand_Sliding_Conversion is applied to the operand.\n\t* exp_ch6.adb (Expand_Simple_Function_Return): If the result\n\tsubtype is an unconstrained array subtype with fixed lower\n\tbound, then Expand_Sliding_Conversion is applied to the return\n\tobject.\n\t* exp_util.ads (Expand_Sliding_Conversion): New procedure for\n\tapplying a sliding subtype conversion to an array object of a\n\tfixed-lower-bound subtype when needed.\n\t* exp_util.adb: Add with_clause for Freeze.\n\t(Expand_Sliding_Conversion): New procedure for applying a\n\tsliding subtype conversion to an array object of a\n\tfixed-lower-bound subtype when needed.  It traverses the indexes\n\tof the unconstrained array type/subtype to create a target\n\tconstrained subtype and rewrites the array object to be a\n\tconversion to that subtype, when there's at least one index\n\twhose lower bound does not statically match the fixed-lower\n\tbound of the target subtype.\n\t* gen_il-fields.ads (type Opt_Field_Enum): Add literals\n\tIs_Fixed_Lower_Bound_Array_Subtype and\n\tIs_Fixed_Lower_Bound_Index_Subtype for new flags on type\n\tentities.\n\t* gen_il-gen-gen_entities.adb: Add calls to\n\tCreate_Semantic_Field for the new fixed-lower-bound flags on\n\ttype entities.\n\t* par-ch3.adb (P_Array_Type_Definition): Add handling for\n\tparsing of fixed-lower-bound index ranges in unconstrained array\n\ttypes. Report an error if such an index is encountered and GNAT\n\tlanguage extensions are not enabled.\n\t(P_Index_Subtype_Def_With_Fixed_Lower_Bound): Support procedure\n\tfor parsing unconstrained index ranges.\n\t(P_Index_Or_Discriminant_Constraint): Add handling for parsing\n\tof index constraints that specify ranges with fixed lower\n\tbounds. Report an error if such an index is encountered and GNAT\n\tlanguage extensions are not enabled.\n\t* sem_ch3.adb (Analyze_Object_Declaration): If the object's\n\tnominal subtype is an array subtype with fixed lower bound, then\n\tExpand_Sliding_Conversion is applied to the object.\n\t(Array_Type_Declaration): Mark the array type and the subtypes\n\tof any indexes that specify a fixed lower bound as being\n\tfixed-lower-bound subtypes, and set the High_bound of the range\n\tof such an index to the upper bound of the named subtype.\n\t(Constrain_Array): For an array subtype with one or more index\n\tranges specifying a fixed lower bound, set Is_Constrained to\n\tFalse and set the array subtype's\n\tIs_Fixed_Lower_Bound_Array_Subtype flag to True.\n\t(Constrain_Index): Mark the subtypes of an index that specifies\n\ta fixed lower bound as being a fixed-lower-bound index subtype,\n\tand set the High_bound of the range of such an index to the\n\tupper bound of the base type of the array type's corresponding\n\tindex.\n\t* sem_res.adb (Resolve_Actuals): If a formal is of an\n\tunconstrained array subtype with fixed lower bound, then\n\tExpand_Sliding_Conversion is applied to the actual.\n\t* sem_util.adb (Build_Actual_Subtype): If the actual subtype\n\tcorresponds to an unconstrained array subtype having any indexes\n\twith fixed lower bounds, then set the lower bounds of any such\n\tindexes of the actual subtype to the appropriate fixed lower\n\tbound of the formal subtype (rather than taking it from the\n\tformal itself).\n\t* sprint.adb (Sprint_Node_Actual, case N_Range): If a range's\n\tEtype has a fixed lower bound, then print \"<>\" rather than the\n\tHigh_Bound of the range.", "tree": {"sha": "834f149ad26966000533a1dcefd502b5c07fa11e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/834f149ad26966000533a1dcefd502b5c07fa11e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d32db3a763249a8b94c2e2e285fc6f400eadea4e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d32db3a763249a8b94c2e2e285fc6f400eadea4e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d32db3a763249a8b94c2e2e285fc6f400eadea4e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d32db3a763249a8b94c2e2e285fc6f400eadea4e/comments", "author": {"login": "dismukes", "id": 50880541, "node_id": "MDQ6VXNlcjUwODgwNTQx", "avatar_url": "https://avatars.githubusercontent.com/u/50880541?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dismukes", "html_url": "https://github.com/dismukes", "followers_url": "https://api.github.com/users/dismukes/followers", "following_url": "https://api.github.com/users/dismukes/following{/other_user}", "gists_url": "https://api.github.com/users/dismukes/gists{/gist_id}", "starred_url": "https://api.github.com/users/dismukes/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dismukes/subscriptions", "organizations_url": "https://api.github.com/users/dismukes/orgs", "repos_url": "https://api.github.com/users/dismukes/repos", "events_url": "https://api.github.com/users/dismukes/events{/privacy}", "received_events_url": "https://api.github.com/users/dismukes/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4892e31daceb8ab230768a15eb0a01b814e8bbfd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4892e31daceb8ab230768a15eb0a01b814e8bbfd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4892e31daceb8ab230768a15eb0a01b814e8bbfd"}], "stats": {"total": 612, "additions": 587, "deletions": 25}, "files": [{"sha": "8c4667cb43132050a492d4bb1522c8a78ac153cf", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 45, "deletions": 10, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d32db3a763249a8b94c2e2e285fc6f400eadea4e/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d32db3a763249a8b94c2e2e285fc6f400eadea4e/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=d32db3a763249a8b94c2e2e285fc6f400eadea4e", "patch": "@@ -10506,16 +10506,36 @@ package body Checks is\n             LB := New_Occurrence_Of (Discriminal (Entity (LB)), Loc);\n          end if;\n \n-         Left_Opnd :=\n-           Make_Op_Lt (Loc,\n-             Left_Opnd  =>\n-               Convert_To\n-                 (Base_Type (Typ), Duplicate_Subexpr_No_Checks (LB)),\n+         --  If the index type has a fixed lower bound, then we require an\n+         --  exact match of the range's lower bound against that fixed lower\n+         --  bound.\n \n-             Right_Opnd =>\n-               Convert_To\n-                 (Base_Type (Typ),\n-                  Get_E_First_Or_Last (Loc, Typ, 0, Name_First)));\n+         if Is_Fixed_Lower_Bound_Index_Subtype (Typ) then\n+            Left_Opnd :=\n+              Make_Op_Ne (Loc,\n+                Left_Opnd  =>\n+                  Convert_To\n+                    (Base_Type (Typ), Duplicate_Subexpr_No_Checks (LB)),\n+\n+                Right_Opnd =>\n+                  Convert_To\n+                    (Base_Type (Typ),\n+                     Get_E_First_Or_Last (Loc, Typ, 0, Name_First)));\n+\n+         --  Otherwise we do the expected less-than comparison\n+\n+         else\n+            Left_Opnd :=\n+              Make_Op_Lt (Loc,\n+                Left_Opnd  =>\n+                  Convert_To\n+                    (Base_Type (Typ), Duplicate_Subexpr_No_Checks (LB)),\n+\n+                Right_Opnd =>\n+                  Convert_To\n+                    (Base_Type (Typ),\n+                     Get_E_First_Or_Last (Loc, Typ, 0, Name_First)));\n+         end if;\n \n          if Nkind (HB) = N_Identifier\n            and then Ekind (Entity (HB)) = E_Discriminant\n@@ -10821,6 +10841,22 @@ package body Checks is\n                   end if;\n                end if;\n \n+               --  Flag the case of a fixed-lower-bound index where the static\n+               --  bounds are not equal.\n+\n+               if not Check_Added\n+                 and then Is_Fixed_Lower_Bound_Index_Subtype (T_Typ)\n+                 and then Expr_Value (LB) /= Expr_Value (T_LB)\n+               then\n+                  Add_Check\n+                    (Compile_Time_Constraint_Error\n+                       ((if Present (Warn_Node)\n+                        then Warn_Node else Low_Bound (Expr)),\n+                        \"static value does not equal lower bound of}??\",\n+                        T_Typ));\n+                  Check_Added := True;\n+               end if;\n+\n                if Known_HB then\n                   if Known_T_HB then\n                      Out_Of_Range_H := T_HB < HB;\n@@ -10972,7 +11008,6 @@ package body Checks is\n \n       if Is_Array_Type (T_Typ) and then Is_Array_Type (S_Typ) then\n          if Is_Constrained (T_Typ) then\n-\n             Expr_Actual := Get_Referenced_Object (Expr);\n             Exptyp      := Get_Actual_Subtype (Expr_Actual);\n "}, {"sha": "55cf83d847eaca913bc36dfc25e807d061e250b3", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d32db3a763249a8b94c2e2e285fc6f400eadea4e/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d32db3a763249a8b94c2e2e285fc6f400eadea4e/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=d32db3a763249a8b94c2e2e285fc6f400eadea4e", "patch": "@@ -2589,6 +2589,16 @@ package Einfo is\n --       an anonymous base type (e.g. for integer type declarations or\n --       constrained array declarations).\n \n+--    Is_Fixed_Lower_Bound_Array_Subtype\n+--       Defined in type entities. True for unconstrained array types and\n+--       subtypes where at least one index has a range specified with a fixed\n+--       lower bound (range syntax is \"<expression> .. <>\").\n+\n+--    Is_Fixed_Lower_Bound_Index_Subtype\n+--       Defined in type entities. True for an index of an unconstrained array\n+--       type or subtype whose range is specified with a fixed lower bound\n+--       (range syntax is \"<expression> .. <>\").\n+\n --    Is_Fixed_Point_Type (synthesized)\n --       Applies to all entities, true for decimal and ordinary fixed\n --       point types and subtypes."}, {"sha": "1d04a0613ca18e8dca800cef0cbdf1b0da73a583", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d32db3a763249a8b94c2e2e285fc6f400eadea4e/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d32db3a763249a8b94c2e2e285fc6f400eadea4e/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=d32db3a763249a8b94c2e2e285fc6f400eadea4e", "patch": "@@ -12585,6 +12585,13 @@ package body Exp_Ch4 is\n          if Is_Constrained (Target_Type) then\n             Apply_Length_Check (Operand, Target_Type);\n          else\n+            --  If the object has an unconstrained array subtype with fixed\n+            --  lower bound, then sliding to that bound may be needed.\n+\n+            if Is_Fixed_Lower_Bound_Array_Subtype (Target_Type) then\n+               Expand_Sliding_Conversion (Operand, Target_Type);\n+            end if;\n+\n             Apply_Range_Check (Operand, Target_Type);\n          end if;\n "}, {"sha": "6314b0ae7a94515a29c4ab9d343b884e36f9051f", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d32db3a763249a8b94c2e2e285fc6f400eadea4e/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d32db3a763249a8b94c2e2e285fc6f400eadea4e/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=d32db3a763249a8b94c2e2e285fc6f400eadea4e", "patch": "@@ -7534,6 +7534,13 @@ package body Exp_Ch6 is\n              Suppress  => All_Checks);\n       end if;\n \n+      --  If the result is of an unconstrained array subtype with fixed lower\n+      --  bound, then sliding to that bound may be needed.\n+\n+      if Is_Fixed_Lower_Bound_Array_Subtype (R_Type) then\n+         Expand_Sliding_Conversion (Exp, R_Type);\n+      end if;\n+\n       --  If we are returning a nonscalar object that is possibly unaligned,\n       --  then copy the value into a temporary first. This copy may need to\n       --  expand to a loop of component operations."}, {"sha": "19b8c656e2cb2ead57c08c467b7250ab4c1ca2c4", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 181, "deletions": 0, "changes": 181, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d32db3a763249a8b94c2e2e285fc6f400eadea4e/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d32db3a763249a8b94c2e2e285fc6f400eadea4e/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=d32db3a763249a8b94c2e2e285fc6f400eadea4e", "patch": "@@ -37,6 +37,7 @@ with Exp_Aggr;       use Exp_Aggr;\n with Exp_Ch6;        use Exp_Ch6;\n with Exp_Ch7;        use Exp_Ch7;\n with Exp_Ch11;       use Exp_Ch11;\n+with Freeze;         use Freeze;\n with Ghost;          use Ghost;\n with Inline;         use Inline;\n with Itypes;         use Itypes;\n@@ -5315,6 +5316,186 @@ package body Exp_Util is\n       end if;\n    end Evolve_Or_Else;\n \n+   -------------------------------\n+   -- Expand_Sliding_Conversion --\n+   -------------------------------\n+\n+   procedure Expand_Sliding_Conversion (N : Node_Id; Arr_Typ : Entity_Id) is\n+\n+      pragma Assert (Is_Array_Type (Arr_Typ)\n+                      and then not Is_Constrained (Arr_Typ));\n+\n+      Constraints : List_Id;\n+      Index       : Node_Id := First_Index (Arr_Typ);\n+      Loc         : constant Source_Ptr := Sloc (N);\n+      Subt_Decl   : Node_Id;\n+      Subt        : Entity_Id;\n+      Subt_Low    : Node_Id;\n+      Subt_High   : Node_Id;\n+\n+      Act_Subt    : Entity_Id;\n+      Act_Index   : Node_Id;\n+      Act_Low     : Node_Id;\n+      Act_High    : Node_Id;\n+      Adjust_Incr : Node_Id;\n+      Dimension   : Int := 0;\n+      All_FLBs_Match : Boolean := True;\n+\n+   begin\n+      if Is_Fixed_Lower_Bound_Array_Subtype (Arr_Typ) then\n+         Constraints := New_List;\n+\n+         Act_Subt  := Get_Actual_Subtype (N);\n+         Act_Index := First_Index (Act_Subt);\n+\n+         --  Loop over the indexes of the fixed-lower-bound array type or\n+         --  subtype to build up an index constraint for constructing the\n+         --  subtype that will be the target of a conversion of the array\n+         --  object that may need a sliding conversion.\n+\n+         while Present (Index) loop\n+            pragma Assert (Present (Act_Index));\n+\n+            Dimension := Dimension + 1;\n+\n+            Get_Index_Bounds (Act_Index, Act_Low, Act_High);\n+\n+            --  If Index defines a normal unconstrained range (range <>),\n+            --  then we will simply use the bounds of the actual subtype's\n+            --  corresponding index range.\n+\n+            if not Is_Fixed_Lower_Bound_Index_Subtype (Etype (Index)) then\n+               Subt_Low  := Act_Low;\n+               Subt_High := Act_High;\n+\n+            --  Otherwise, a range will be created with a low bound given by\n+            --  the fixed lower bound of the array subtype's index, and with\n+            --  high bound given by (Actual'Length + fixed lower bound - 1).\n+\n+            else\n+               if Nkind (Index) = N_Subtype_Indication then\n+                  Subt_Low :=\n+                    New_Copy_Tree\n+                      (Low_Bound (Range_Expression (Constraint (Index))));\n+               else\n+                  pragma Assert (Nkind (Index) = N_Range);\n+\n+                  Subt_Low := New_Copy_Tree (Low_Bound (Index));\n+               end if;\n+\n+               --  If either we have a nonstatic lower bound, or the target and\n+               --  source subtypes are statically known to have unequal lower\n+               --  bounds, then we will need to make a subtype conversion to\n+               --  slide the bounds. However, if all of the indexes' lower\n+               --  bounds are static and known to be equal (the common case),\n+               --  then no conversion will be needed, and we'll end up not\n+               --  creating the subtype or the conversion (though we still\n+               --  build up the index constraint, which will simply be unused).\n+\n+               if not (Compile_Time_Known_Value (Subt_Low)\n+                        and then Compile_Time_Known_Value (Act_Low))\n+                 or else Expr_Value (Subt_Low) /= Expr_Value (Act_Low)\n+               then\n+                  All_FLBs_Match := False;\n+               end if;\n+\n+               --  Apply 'Pos to lower bound, which may be of an enumeration\n+               --  type, before subtracting.\n+\n+               Adjust_Incr :=\n+                 Make_Op_Subtract (Loc,\n+                   Make_Attribute_Reference (Loc,\n+                      Prefix         =>\n+                        New_Occurrence_Of (Etype (Act_Index), Loc),\n+                      Attribute_Name =>\n+                        Name_Pos,\n+                      Expressions    =>\n+                        New_List (New_Copy_Tree (Subt_Low))),\n+                   Make_Integer_Literal (Loc, 1));\n+\n+               --  Apply 'Val to the result of adding the increment to the\n+               --  length, to handle indexes of enumeration types.\n+\n+               Subt_High :=\n+                 Make_Attribute_Reference (Loc,\n+                   Prefix         =>\n+                     New_Occurrence_Of (Etype (Act_Index), Loc),\n+                   Attribute_Name =>\n+                     Name_Val,\n+                   Expressions    =>\n+                     New_List (Make_Op_Add (Loc,\n+                                 Make_Attribute_Reference (Loc,\n+                                   Prefix         =>\n+                                     New_Occurrence_Of (Act_Subt, Loc),\n+                                   Attribute_Name =>\n+                                     Name_Length,\n+                                   Expressions    =>\n+                                     New_List\n+                                       (Make_Integer_Literal\n+                                          (Loc, Dimension))),\n+                                 Adjust_Incr)));\n+            end if;\n+\n+            Append (Make_Range (Loc, Subt_Low, Subt_High), Constraints);\n+\n+            Next (Index);\n+            Next (Act_Index);\n+         end loop;\n+\n+         --  If for each index with a fixed lower bound (FLB), the lower bound\n+         --  of the corresponding index of the actual subtype is statically\n+         --  known be equal to the FLB, then a sliding conversion isn't needed\n+         --  at all, so just return without building a subtype or conversion.\n+\n+         if All_FLBs_Match then\n+            return;\n+         end if;\n+\n+         --  A sliding conversion is needed, so create the target subtype using\n+         --  the index constraint created above, and rewrite the expression\n+         --  as a conversion to that subtype.\n+\n+         Subt := Make_Temporary (Loc, 'S', Related_Node => N);\n+         Set_Is_Internal (Subt);\n+\n+         Subt_Decl :=\n+           Make_Subtype_Declaration (Loc,\n+             Defining_Identifier => Subt,\n+             Subtype_Indication  =>\n+               Make_Subtype_Indication (Loc,\n+                 Subtype_Mark =>\n+                   New_Occurrence_Of (Arr_Typ,  Loc),\n+                 Constraint   =>\n+                   Make_Index_Or_Discriminant_Constraint (Loc,\n+                     Constraints => Constraints)));\n+\n+         Mark_Rewrite_Insertion (Subt_Decl);\n+\n+         --  The actual subtype is an Itype, so we analyze the declaration,\n+         --  but do not attach it to the tree.\n+\n+         Set_Parent (Subt_Decl, N);\n+         Set_Is_Itype (Subt);\n+         Analyze (Subt_Decl, Suppress => All_Checks);\n+         Set_Associated_Node_For_Itype (Subt, N);\n+         Set_Has_Delayed_Freeze (Subt, False);\n+\n+         --  We need to freeze the actual subtype immediately.  This is needed\n+         --  because otherwise this Itype will not get frozen at all, and it is\n+         --  always safe to freeze on creation because any associated types\n+         --  must be frozen at this point.\n+\n+         Freeze_Itype (Subt, N);\n+\n+         Rewrite (N,\n+                  Make_Type_Conversion (Loc,\n+                    Subtype_Mark =>\n+                      New_Occurrence_Of (Subt, Loc),\n+                    Expression   => Relocate_Node (N)));\n+         Analyze (N);\n+      end if;\n+   end Expand_Sliding_Conversion;\n+\n    -----------------------------------------\n    -- Expand_Static_Predicates_In_Choices --\n    -----------------------------------------"}, {"sha": "2b3147d89d3ffda3e84211fddc031068be14b28b", "filename": "gcc/ada/exp_util.ads", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d32db3a763249a8b94c2e2e285fc6f400eadea4e/gcc%2Fada%2Fexp_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d32db3a763249a8b94c2e2e285fc6f400eadea4e/gcc%2Fada%2Fexp_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.ads?ref=d32db3a763249a8b94c2e2e285fc6f400eadea4e", "patch": "@@ -560,6 +560,12 @@ package Exp_Util is\n    --  indicating that no checks were required). The Sloc field of the\n    --  constructed N_Or_Else node is copied from Cond1.\n \n+   procedure Expand_Sliding_Conversion (N : Node_Id; Arr_Typ : Entity_Id);\n+   --  When sliding is needed for an array object N in the context of an\n+   --  unconstrained array type Arr_Typ with fixed lower bound (FLB), create\n+   --  a subtype with appropriate index constraint (FLB .. N'Length + FLB - 1)\n+   --  and apply a conversion from N to that subtype.\n+\n    procedure Expand_Static_Predicates_In_Choices (N : Node_Id);\n    --  N is either a case alternative or a variant. The Discrete_Choices field\n    --  of N points to a list of choices. If any of these choices is the name"}, {"sha": "4aac802819a00897f455f1e04f6a251d98828cbc", "filename": "gcc/ada/gen_il-fields.ads", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d32db3a763249a8b94c2e2e285fc6f400eadea4e/gcc%2Fada%2Fgen_il-fields.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d32db3a763249a8b94c2e2e285fc6f400eadea4e/gcc%2Fada%2Fgen_il-fields.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgen_il-fields.ads?ref=d32db3a763249a8b94c2e2e285fc6f400eadea4e", "patch": "@@ -705,6 +705,8 @@ package Gen_IL.Fields is\n       Is_Exported,\n       Is_Finalized_Transient,\n       Is_First_Subtype,\n+      Is_Fixed_Lower_Bound_Array_Subtype,\n+      Is_Fixed_Lower_Bound_Index_Subtype,\n       Is_Formal_Subprogram,\n       Is_Frozen,\n       Is_Generic_Actual_Subprogram,"}, {"sha": "afd3ec47696f09b1bcf7b182b24a9ed56aa33338", "filename": "gcc/ada/gen_il-gen-gen_entities.adb", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d32db3a763249a8b94c2e2e285fc6f400eadea4e/gcc%2Fada%2Fgen_il-gen-gen_entities.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d32db3a763249a8b94c2e2e285fc6f400eadea4e/gcc%2Fada%2Fgen_il-gen-gen_entities.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgen_il-gen-gen_entities.adb?ref=d32db3a763249a8b94c2e2e285fc6f400eadea4e", "patch": "@@ -532,6 +532,8 @@ begin -- Gen_IL.Gen.Gen_Entities\n         Sm (Is_Abstract_Type, Flag),\n         Sm (Is_Actual_Subtype, Flag),\n         Sm (Is_Asynchronous, Flag),\n+        Sm (Is_Fixed_Lower_Bound_Array_Subtype, Flag),\n+        Sm (Is_Fixed_Lower_Bound_Index_Subtype, Flag),\n         Sm (Is_Generic_Actual_Type, Flag),\n         Sm (Is_Non_Static_Subtype, Flag),\n         Sm (Is_Private_Composite, Flag),"}, {"sha": "52e52dcac8e1970b623020210ffdade383edc3d4", "filename": "gcc/ada/par-ch3.adb", "status": "modified", "additions": 202, "deletions": 5, "changes": 207, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d32db3a763249a8b94c2e2e285fc6f400eadea4e/gcc%2Fada%2Fpar-ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d32db3a763249a8b94c2e2e285fc6f400eadea4e/gcc%2Fada%2Fpar-ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch3.adb?ref=d32db3a763249a8b94c2e2e285fc6f400eadea4e", "patch": "@@ -2693,6 +2693,73 @@ package body Ch3 is\n       Scan_State       : Saved_Scan_State;\n       Aliased_Present  : Boolean := False;\n \n+      procedure P_Index_Subtype_Def_With_Fixed_Lower_Bound\n+        (Subtype_Mark : Node_Id);\n+      --  Parse an unconstrained index range with a fixed lower bound:\n+      --    subtype_mark range <expression> .. <>\n+      --  This procedure creates a subtype_indication node for the index.\n+\n+      --------------------------------------------\n+      --  P_Index_Range_With_Fixed_Lower_Bound  --\n+      --------------------------------------------\n+\n+      procedure P_Index_Subtype_Def_With_Fixed_Lower_Bound\n+        (Subtype_Mark : Node_Id)\n+      is\n+         Low_Expr_Node  : constant Node_Id := P_Expression;\n+         High_Expr_Node : Node_Id;\n+         Indic_Node     : Node_Id;\n+         Constr_Node    : Node_Id;\n+         Range_Node     : Node_Id;\n+\n+      begin\n+         T_Dot_Dot;  -- Error if no ..\n+\n+         --  A box is required at this point, and we'll set the upper bound to\n+         --  the same expression as the lower bound (see further below), to\n+         --  avoid problems with trying to analyze an Empty node. Analysis can\n+         --  still tell that this is a fixed-lower-bound range because the\n+         --  index is represented by a subtype_indication in an unconstrained\n+         --  array type definition.\n+\n+         if Token = Tok_Box then\n+            Scan;\n+            High_Expr_Node := Low_Expr_Node;\n+\n+         --  Error if no <> was found, and try to parse an expression since\n+         --  it's likely one was given in place of the <>.\n+\n+         else\n+            Error_Msg_AP -- CODEFIX\n+              (\"missing \"\"'<'>\"\"\");\n+\n+            High_Expr_Node := P_Expression;\n+         end if;\n+\n+         Constr_Node := New_Node (N_Range_Constraint, Token_Ptr);\n+         Range_Node  := New_Node (N_Range, Token_Ptr);\n+         Set_Range_Expression (Constr_Node, Range_Node);\n+\n+         Check_Simple_Expression (Low_Expr_Node);\n+\n+         Set_Low_Bound (Range_Node, Low_Expr_Node);\n+         Set_High_Bound (Range_Node, High_Expr_Node);\n+\n+         Indic_Node :=\n+           New_Node (N_Subtype_Indication, Sloc (Subtype_Mark));\n+         Set_Subtype_Mark (Indic_Node, Check_Subtype_Mark (Subtype_Mark));\n+         Set_Constraint (Indic_Node, Constr_Node);\n+\n+         Append (Indic_Node, Subs_List);\n+      end P_Index_Subtype_Def_With_Fixed_Lower_Bound;\n+\n+      --  Local variables\n+\n+      Is_Constrained_Array_Def : Boolean := True;\n+      Subtype_Mark_Node        : Node_Id;\n+\n+   --  Start of processing for P_Array_Type_Definition\n+\n    begin\n       Array_Loc := Token_Ptr;\n       Scan; -- past ARRAY\n@@ -2724,17 +2791,125 @@ package body Ch3 is\n          Def_Node := New_Node (N_Unconstrained_Array_Definition, Array_Loc);\n          Restore_Scan_State (Scan_State); -- to first subtype mark\n \n+         Is_Constrained_Array_Def := False;\n+\n+         --  Now parse a sequence of indexes where each is either of form:\n+         --    <subtype_mark> range <>\n+         --  or\n+         --    <subtype_mark> range <expr> .. <>\n+         --\n+         --  The latter syntax indicates an index with a fixed lower bound,\n+         --  and only applies when extensions are enabled (-gnatX).\n+\n          loop\n-            Append (P_Subtype_Mark_Resync, Subs_List);\n+            Subtype_Mark_Node := P_Subtype_Mark_Resync;\n+\n             T_Range;\n-            T_Box;\n+\n+            --  Normal \"subtype_mark range <>\" form, so simply append\n+            --  the subtype reference.\n+\n+            if Token = Tok_Box then\n+               Append (Subtype_Mark_Node, Subs_List);\n+               Scan;\n+\n+            --  Fixed-lower-bound form (\"subtype_mark range <expr> .. <>\")\n+\n+            else\n+               P_Index_Subtype_Def_With_Fixed_Lower_Bound (Subtype_Mark_Node);\n+\n+               if not Extensions_Allowed then\n+                  Error_Msg_N\n+                    (\"fixed-lower-bound array is an extension feature; \"\n+                       & \"use -gnatX\",\n+                     Token_Node);\n+               end if;\n+            end if;\n+\n             exit when Token = Tok_Right_Paren or else Token = Tok_Of;\n             T_Comma;\n          end loop;\n \n          Set_Subtype_Marks (Def_Node, Subs_List);\n \n-      else\n+      --  If we don't have \"range <>\", then \"range\" will be followed by an\n+      --  expression, for either a normal range or a fixed-lower-bound range\n+      --  (\"<exp> .. <>\"), and we have to know which, in order to determine\n+      --  whether to parse the indexes for an unconstrained or constrained\n+      --  array definition. So we look ahead to see if \"<>\" follows the \"..\".\n+      --  If not, then this must be a discrete_subtype_indication for a\n+      --  constrained_array_definition, which will be processed further below.\n+\n+      elsif Prev_Token = Tok_Range\n+        and then Token /= Tok_Right_Paren and then Token /= Tok_Comma\n+      then\n+         --  If we have an expression followed by \"..\", then scan farther\n+         --  and check for \"<>\" to see if we have a fixed-lower-bound range.\n+\n+         if P_Expression_Or_Range_Attribute /= Error\n+           and then Expr_Form /= EF_Range_Attr\n+           and then Token = Tok_Dot_Dot\n+         then\n+            Scan;\n+\n+            --  If there's a \"<>\", then we know we have a fixed-lower-bound\n+            --  index, so we can proceed with parsing an unconstrained array\n+            --  definition.\n+\n+            if Token = Tok_Box then\n+               Is_Constrained_Array_Def := False;\n+\n+               Def_Node :=\n+                 New_Node (N_Unconstrained_Array_Definition, Array_Loc);\n+\n+               Restore_Scan_State (Scan_State); -- to first subtype mark\n+\n+               --  Now parse a sequence of indexes where each is either of\n+               --  form:\n+               --     <subtype_mark> range <>\n+               --  or\n+               --     <subtype_mark> range <expr> .. <>\n+               --\n+               --  The latter indicates an index with a fixed lower bound,\n+               --  and only applies when extensions are enabled (-gnatX).\n+\n+               loop\n+                  Subtype_Mark_Node := P_Subtype_Mark_Resync;\n+\n+                  T_Range;\n+\n+                  --  Normal \"subtype_mark range <>\" form, so simply append\n+                  --  the subtype reference.\n+\n+                  if Token = Tok_Box then\n+                     Append (Subtype_Mark_Node, Subs_List);\n+                     Scan;\n+\n+                  --  This must be an index of form:\n+                  --    <subtype_mark> range <expr> .. <>\"\n+\n+                  else\n+                     P_Index_Subtype_Def_With_Fixed_Lower_Bound\n+                       (Subtype_Mark_Node);\n+\n+                     if not Extensions_Allowed then\n+                        Error_Msg_N\n+                          (\"fixed-lower-bound array is an extension feature; \"\n+                             & \"use -gnatX\",\n+                           Token_Node);\n+                     end if;\n+                  end if;\n+\n+                  exit when Token = Tok_Right_Paren or else Token = Tok_Of;\n+                  T_Comma;\n+               end loop;\n+\n+               Set_Subtype_Marks (Def_Node, Subs_List);\n+            end if;\n+         end if;\n+      end if;\n+\n+      if Is_Constrained_Array_Def then\n          Def_Node := New_Node (N_Constrained_Array_Definition, Array_Loc);\n          Restore_Scan_State (Scan_State); -- to first discrete range\n \n@@ -3217,8 +3392,30 @@ package body Ch3 is\n             Constr_Node := New_Node (N_Range, Token_Ptr);\n             Set_Low_Bound (Constr_Node, Expr_Node);\n             Scan; -- past ..\n-            Expr_Node := P_Expression;\n-            Check_Simple_Expression (Expr_Node);\n+\n+            --  If the upper bound is given by \"<>\", this is an index for\n+            --  a fixed-lower-bound subtype, so set the expression to Empty\n+            --  for now (it will be set to the ranges maximum upper bound\n+            --  later during analysis), and scan to the next token.\n+\n+            if Token = Tok_Box then\n+               if not Extensions_Allowed then\n+                  Error_Msg_N\n+                    (\"fixed-lower-bound array is an extension feature; \"\n+                       & \"use -gnatX\",\n+                     Expr_Node);\n+               end if;\n+\n+               Expr_Node := Empty;\n+               Scan;\n+\n+            --  Otherwise parse the range's upper bound expression\n+\n+            else\n+               Expr_Node := P_Expression;\n+               Check_Simple_Expression (Expr_Node);\n+            end if;\n+\n             Set_High_Bound (Constr_Node, Expr_Node);\n             Append (Constr_Node, Constr_List);\n             goto Loop_Continue;"}, {"sha": "6720d41c2211e935a79fffbbb419892dcb1b45e4", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 88, "deletions": 2, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d32db3a763249a8b94c2e2e285fc6f400eadea4e/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d32db3a763249a8b94c2e2e285fc6f400eadea4e/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=d32db3a763249a8b94c2e2e285fc6f400eadea4e", "patch": "@@ -4620,6 +4620,13 @@ package body Sem_Ch3 is\n                   Related_Id := Empty;\n                end if;\n \n+               --  If the object has an unconstrained array subtype with fixed\n+               --  lower bound, then sliding to that bound may be needed.\n+\n+               if Is_Fixed_Lower_Bound_Array_Subtype (T) then\n+                  Expand_Sliding_Conversion (E, T);\n+               end if;\n+\n                Expand_Subtype_From_Expr\n                  (N             => N,\n                   Unc_Type      => T,\n@@ -6024,6 +6031,7 @@ package body Sem_Ch3 is\n       Nb_Index      : Pos;\n       Priv          : Entity_Id;\n       Related_Id    : Entity_Id;\n+      Has_FLB_Index : Boolean := False;\n \n    begin\n       if Nkind (Def) = N_Constrained_Array_Definition then\n@@ -6113,6 +6121,39 @@ package body Sem_Ch3 is\n \n          Make_Index (Index, P, Related_Id, Nb_Index);\n \n+         --  In the case where we have an unconstrained array with an index\n+         --  given by a subtype_indication, this is necessarily a \"fixed lower\n+         --  bound\" index. We change the upper bound of that index to the upper\n+         --  bound of the index's subtype (denoted by the subtype_mark), since\n+         --  that upper bound was originally set by the parser to be the same\n+         --  as the lower bound. In truth, that upper bound corresponds to\n+         --  a box (\"<>\"), and could be set to Empty, but it's convenient to\n+         --  set it to the upper bound to avoid needing to add special tests\n+         --  in various places for an Empty upper bound, and in any case that\n+         --  accurately characterizes the index's range of values.\n+\n+         if Nkind (Def) = N_Unconstrained_Array_Definition\n+           and then Nkind (Index) = N_Subtype_Indication\n+         then\n+            declare\n+               Index_Subtype_High_Bound : constant Entity_Id :=\n+                 Type_High_Bound (Entity (Subtype_Mark (Index)));\n+            begin\n+               Set_High_Bound (Range_Expression (Constraint (Index)),\n+                               Index_Subtype_High_Bound);\n+\n+               --  Record that the array type has one or more indexes with\n+               --  a fixed lower bound.\n+\n+               Has_FLB_Index := True;\n+\n+               --  Mark the index as belonging to an array type with a fixed\n+               --  lower bound.\n+\n+               Set_Is_Fixed_Lower_Bound_Index_Subtype (Etype (Index));\n+            end;\n+         end if;\n+\n          --  Check error of subtype with predicate for index type\n \n          Bad_Predicated_Subtype_Use\n@@ -6241,6 +6282,8 @@ package body Sem_Ch3 is\n          Set_Scope                    (T, Current_Scope);\n          Set_Component_Size           (T, Uint_0);\n          Set_Is_Constrained           (T, False);\n+         Set_Is_Fixed_Lower_Bound_Array_Subtype\n+                                      (T, Has_FLB_Index);\n          Set_First_Index              (T, First (Subtype_Marks (Def)));\n          Set_Has_Delayed_Freeze       (T, True);\n          Propagate_Concurrent_Flags   (T, Element_Type);\n@@ -13270,6 +13313,7 @@ package body Sem_Ch3 is\n       Index                 : Node_Id;\n       S, T                  : Entity_Id;\n       Constraint_OK         : Boolean := True;\n+      Is_FLB_Array_Subtype  : Boolean := False;\n \n    begin\n       T := Entity (Subtype_Mark (SI));\n@@ -13313,6 +13357,16 @@ package body Sem_Ch3 is\n \n             for J in 1 .. Number_Of_Constraints loop\n                Constrain_Index (Index, S, Related_Nod, Related_Id, Suffix, J);\n+\n+               --  If the subtype of the index has been set to indicate that\n+               --  it has a fixed lower bound, then record that the subtype's\n+               --  entity will need to be marked as being a fixed-lower-bound\n+               --  array subtype.\n+\n+               if Is_Fixed_Lower_Bound_Index_Subtype (Etype (S)) then\n+                  Is_FLB_Array_Subtype := True;\n+               end if;\n+\n                Next (Index);\n                Next (S);\n             end loop;\n@@ -13339,7 +13393,9 @@ package body Sem_Ch3 is\n          Set_First_Index (Def_Id, First_Index (T));\n       end if;\n \n-      Set_Is_Constrained     (Def_Id, True);\n+      Set_Is_Constrained     (Def_Id, not Is_FLB_Array_Subtype);\n+      Set_Is_Fixed_Lower_Bound_Array_Subtype\n+                             (Def_Id, Is_FLB_Array_Subtype);\n       Set_Is_Aliased         (Def_Id, Is_Aliased (T));\n       Set_Is_Independent     (Def_Id, Is_Independent (T));\n       Set_Depends_On_Private (Def_Id, Has_Private_Component (Def_Id));\n@@ -14201,6 +14257,7 @@ package body Sem_Ch3 is\n       Def_Id : Entity_Id;\n       R      : Node_Id := Empty;\n       T      : constant Entity_Id := Etype (Index);\n+      Is_FLB_Index : Boolean := False;\n \n    begin\n       Def_Id :=\n@@ -14214,6 +14271,20 @@ package body Sem_Ch3 is\n       then\n          --  A Range attribute will be transformed into N_Range by Resolve\n \n+         --  If a range has an Empty upper bound, then remember that for later\n+         --  setting of the index subtype's Is_Fixed_Lower_Bound_Index_Subtype\n+         --  flag, and also set the upper bound of the range to the index\n+         --  subtype's upper bound rather than leaving it Empty. In truth,\n+         --  that upper bound corresponds to a box (\"<>\"), but it's convenient\n+         --  to set it to the upper bound to avoid needing to add special tests\n+         --  in various places for an Empty upper bound, and in any case it\n+         --  accurately characterizes the index's range of values.\n+\n+         if Nkind (S) = N_Range and then not Present (High_Bound (S)) then\n+            Is_FLB_Index := True;\n+            Set_High_Bound (S, Type_High_Bound (T));\n+         end if;\n+\n          R := S;\n \n          Process_Range_Expr_In_Decl (R, T);\n@@ -14314,7 +14385,22 @@ package body Sem_Ch3 is\n       Set_RM_Size        (Def_Id, RM_Size        (T));\n       Set_First_Rep_Item (Def_Id, First_Rep_Item (T));\n \n-      Set_Scalar_Range   (Def_Id, R);\n+      --  If this is a range for a fixed-lower-bound subtype, then set the\n+      --  index itype's lower bound to the FLB and the index type's upper bound\n+      --  to the high bound of the index base type's high bound, mark the itype\n+      --  as an FLB index subtype, and set the range's Etype to the itype.\n+\n+      if Nkind (S) = N_Range and then Is_FLB_Index then\n+         Set_Scalar_Range\n+           (Def_Id,\n+            Make_Range (Sloc (S),\n+              Low_Bound  => Low_Bound (S),\n+              High_Bound => Type_High_Bound (Base_Type (T))));\n+         Set_Is_Fixed_Lower_Bound_Index_Subtype (Def_Id);\n+\n+      else\n+         Set_Scalar_Range (Def_Id, R);\n+      end if;\n \n       Set_Etype (S, Def_Id);\n       Set_Discrete_RM_Size (Def_Id);"}, {"sha": "720f170ff734b0865a743f08aa47a659cb4aa4b8", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d32db3a763249a8b94c2e2e285fc6f400eadea4e/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d32db3a763249a8b94c2e2e285fc6f400eadea4e/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=d32db3a763249a8b94c2e2e285fc6f400eadea4e", "patch": "@@ -4773,6 +4773,13 @@ package body Sem_Res is\n                --  Expand_Actuals routine in Exp_Ch6.\n             end if;\n \n+            --  If the formal is of an unconstrained array subtype with fixed\n+            --  lower bound, then sliding to that bound may be needed.\n+\n+            if Is_Fixed_Lower_Bound_Array_Subtype (F_Typ) then\n+               Expand_Sliding_Conversion (A, F_Typ);\n+            end if;\n+\n             --  An actual associated with an access parameter is implicitly\n             --  converted to the anonymous access type of the formal and must\n             --  satisfy the legality checks for access conversions."}, {"sha": "d0e3b1a47c3e62aa1e1b24de94a8cce26fd7272a", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 23, "deletions": 7, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d32db3a763249a8b94c2e2e285fc6f400eadea4e/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d32db3a763249a8b94c2e2e285fc6f400eadea4e/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=d32db3a763249a8b94c2e2e285fc6f400eadea4e", "patch": "@@ -1683,6 +1683,7 @@ package body Sem_Util is\n       Subt        : Entity_Id;\n       Disc_Type   : Entity_Id;\n       Obj         : Node_Id;\n+      Index       : Node_Id;\n \n    begin\n       Loc := Sloc (N);\n@@ -1713,20 +1714,33 @@ package body Sem_Util is\n \n       if Is_Array_Type (T) then\n          Constraints := New_List;\n+         Index := First_Index (T);\n+\n          for J in 1 .. Number_Dimensions (T) loop\n \n             --  Build an array subtype declaration with the nominal subtype and\n             --  the bounds of the actual. Add the declaration in front of the\n             --  local declarations for the subprogram, for analysis before any\n             --  reference to the formal in the body.\n \n-            Lo :=\n-              Make_Attribute_Reference (Loc,\n-                Prefix         =>\n-                  Duplicate_Subexpr_No_Checks (Obj, Name_Req => True),\n-                Attribute_Name => Name_First,\n-                Expressions    => New_List (\n-                  Make_Integer_Literal (Loc, J)));\n+            --  If this is for an index with a fixed lower bound, then use\n+            --  the fixed lower bound as the lower bound of the actual\n+            --  subtype's corresponding index.\n+\n+            if not Is_Constrained (T)\n+              and then Is_Fixed_Lower_Bound_Index_Subtype (Etype (Index))\n+            then\n+               Lo := New_Copy_Tree (Type_Low_Bound (Etype (Index)));\n+\n+            else\n+               Lo :=\n+                 Make_Attribute_Reference (Loc,\n+                   Prefix         =>\n+                     Duplicate_Subexpr_No_Checks (Obj, Name_Req => True),\n+                   Attribute_Name => Name_First,\n+                   Expressions    => New_List (\n+                     Make_Integer_Literal (Loc, J)));\n+            end if;\n \n             Hi :=\n               Make_Attribute_Reference (Loc,\n@@ -1737,6 +1751,8 @@ package body Sem_Util is\n                   Make_Integer_Literal (Loc, J)));\n \n             Append (Make_Range (Loc, Lo, Hi), Constraints);\n+\n+            Next_Index (Index);\n          end loop;\n \n       --  If the type has unknown discriminants there is no constrained"}, {"sha": "5f2d027dfaf9752acc0c54dc3321b48b9b2a2cf4", "filename": "gcc/ada/sprint.adb", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d32db3a763249a8b94c2e2e285fc6f400eadea4e/gcc%2Fada%2Fsprint.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d32db3a763249a8b94c2e2e285fc6f400eadea4e/gcc%2Fada%2Fsprint.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsprint.adb?ref=d32db3a763249a8b94c2e2e285fc6f400eadea4e", "patch": "@@ -3072,7 +3072,13 @@ package body Sprint is\n          when N_Range =>\n             Sprint_Node (Low_Bound (Node));\n             Write_Str_Sloc (\" .. \");\n-            Sprint_Node (High_Bound (Node));\n+            if Present (Etype (Node))\n+              and then Is_Fixed_Lower_Bound_Index_Subtype (Etype (Node))\n+            then\n+               Write_Str (\"<>\");\n+            else\n+               Sprint_Node (High_Bound (Node));\n+            end if;\n             Update_Itype (Node);\n \n          when N_Range_Constraint =>"}]}