{"sha": "36d3fb4cfe1c79915ed747b54f6a1aa2a471a833", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzZkM2ZiNGNmZTFjNzk5MTVlZDc0N2I1NGY2YTFhYTJhNDcxYTgzMw==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2007-03-15T06:44:25Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2007-03-15T06:44:25Z"}, "message": "[multiple changes]\n\n2007-03-15  Tobias Burnus  <burnus@gcc.gnu.org>\n\t    Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/30922\n\t* decl.c (gfc_match_import): If the parent of the current name-\n\tspace is null, try looking for an imported symbol in the parent\n\tof the proc_name interface.\n\t* resolve.c (resolve_fl_variable): Do not check for blocking of\n\thost association by a same symbol, if the symbol is in an\n\tinterface body.\n\n2007-03-15  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/30879\n\t* decl.c (match_data_constant): Before going on to try to match\n\ta name, try to match a structure component.\n\n\n\tPR fortran/30870\n\t* resolve.c (resolve_actual_arglist): Do not reject a generic\n\tactual argument if it has a same name specific interface.\n\n\tPR fortran/31163\n\t* trans-array.c (parse_interface): Do not nullify allocatable\n\tcomponents if the symbol has the saved attribute.\n\n\n2007-03-15  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/30922\n\t* gfortran.dg/import5.f90.f90: New test.\n\n\n\tPR fortran/30879\n\t* gfortran.dg/data_components_1.f90: New test.\n\n\n\tPR fortran/30870\n\t* gfortran.dg/generic_13.f90: New test.\n\n\tPR fortran/31163\n\t* gfortran.dg/alloc_comp_basics_5.f90: New test.\n\nFrom-SVN: r122944", "tree": {"sha": "5cb4c73baa1e5f429a60e96974501d4c438fcd54", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5cb4c73baa1e5f429a60e96974501d4c438fcd54"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/36d3fb4cfe1c79915ed747b54f6a1aa2a471a833", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/36d3fb4cfe1c79915ed747b54f6a1aa2a471a833", "html_url": "https://github.com/Rust-GCC/gccrs/commit/36d3fb4cfe1c79915ed747b54f6a1aa2a471a833", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/36d3fb4cfe1c79915ed747b54f6a1aa2a471a833/comments", "author": null, "committer": null, "parents": [{"sha": "23dd73839f0024c837c3304f46c2b90c4645e9a2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/23dd73839f0024c837c3304f46c2b90c4645e9a2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/23dd73839f0024c837c3304f46c2b90c4645e9a2"}], "stats": {"total": 255, "additions": 246, "deletions": 9}, "files": [{"sha": "449f9b89d04643cd992a1ae34833f29e9122de04", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36d3fb4cfe1c79915ed747b54f6a1aa2a471a833/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36d3fb4cfe1c79915ed747b54f6a1aa2a471a833/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=36d3fb4cfe1c79915ed747b54f6a1aa2a471a833", "patch": "@@ -1,3 +1,29 @@\n+2007-03-15  Tobias Burnus  <burnus@gcc.gnu.org>\n+\t    Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/30922\n+\t* decl.c (gfc_match_import): If the parent of the current name-\n+\tspace is null, try looking for an imported symbol in the parent\n+\tof the proc_name interface.\n+\t* resolve.c (resolve_fl_variable): Do not check for blocking of\n+\thost association by a same symbol, if the symbol is in an\n+\tinterface body.\n+\n+2007-03-15  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/30879\n+\t* decl.c (match_data_constant): Before going on to try to match\n+\ta name, try to match a structure component.\n+\n+\n+\tPR fortran/30870\n+\t* resolve.c (resolve_actual_arglist): Do not reject a generic\n+\tactual argument if it has a same name specific interface.\n+\n+\tPR fortran/31163\n+\t* trans-array.c (parse_interface): Do not nullify allocatable\n+\tcomponents if the symbol has the saved attribute.\n+\n 2007-03-14  Francois-Xavier Coudert  <coudert@clipper.ens.fr>\n \n \t* trans-array.c (gfc_trans_auto_array_allocation): Replace"}, {"sha": "09ded01d27c3808ffc072fd5bf3fcb4dfdb23367", "filename": "gcc/fortran/decl.c", "status": "modified", "additions": 29, "deletions": 1, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36d3fb4cfe1c79915ed747b54f6a1aa2a471a833/gcc%2Ffortran%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36d3fb4cfe1c79915ed747b54f6a1aa2a471a833/gcc%2Ffortran%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdecl.c?ref=36d3fb4cfe1c79915ed747b54f6a1aa2a471a833", "patch": "@@ -301,6 +301,7 @@ match_data_constant (gfc_expr **result)\n   gfc_symbol *sym;\n   gfc_expr *expr;\n   match m;\n+  locus old_loc;\n \n   m = gfc_match_literal_constant (&expr, 1);\n   if (m == MATCH_YES)\n@@ -316,6 +317,23 @@ match_data_constant (gfc_expr **result)\n   if (m != MATCH_NO)\n     return m;\n \n+  old_loc = gfc_current_locus;\n+\n+  /* Should this be a structure component, try to match it\n+     before matching a name.  */\n+  m = gfc_match_rvalue (result);\n+  if (m == MATCH_ERROR)\n+    return m;\n+\n+  if (m == MATCH_YES && (*result)->expr_type == EXPR_STRUCTURE)\n+    {\n+      if (gfc_simplify_expr (*result, 0) == FAILURE)\n+\tm = MATCH_ERROR;\n+      return m;\n+    }\n+\n+  gfc_current_locus = old_loc;\n+\n   m = gfc_match_name (name);\n   if (m != MATCH_YES)\n     return m;\n@@ -2041,7 +2059,17 @@ gfc_match_import (void)\n       switch (m)\n \t{\n \tcase MATCH_YES:\n-\t  if (gfc_find_symbol (name, gfc_current_ns->parent, 1, &sym))\n+\t  if (gfc_current_ns->parent !=  NULL\n+\t\t  && gfc_find_symbol (name, gfc_current_ns->parent,\n+\t\t\t\t      1, &sym))\n+\t    {\n+\t       gfc_error (\"Type name '%s' at %C is ambiguous\", name);\n+\t       return MATCH_ERROR;\n+\t    }\n+\t  else if (gfc_current_ns->proc_name->ns->parent !=  NULL\n+\t\t  && gfc_find_symbol (name,\n+\t\t\tgfc_current_ns->proc_name->ns->parent,\n+\t\t\t1, &sym))\n \t    {\n \t       gfc_error (\"Type name '%s' at %C is ambiguous\", name);\n \t       return MATCH_ERROR;"}, {"sha": "db55c0c5cc2affc13cac8c1de35025a45862f6f3", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 18, "deletions": 4, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36d3fb4cfe1c79915ed747b54f6a1aa2a471a833/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36d3fb4cfe1c79915ed747b54f6a1aa2a471a833/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=36d3fb4cfe1c79915ed747b54f6a1aa2a471a833", "patch": "@@ -922,11 +922,24 @@ resolve_actual_arglist (gfc_actual_arglist *arg, procedure_type ptype)\n \t\t\t &e->where);\n \t    }\n \n+\t  /* Check if a generic interface has a specific procedure\n+\t    with the same name before emitting an error.  */\n \t  if (sym->attr.generic)\n \t    {\n-\t      gfc_error (\"GENERIC non-INTRINSIC procedure '%s' is not \"\n-\t\t\t \"allowed as an actual argument at %L\", sym->name,\n-\t\t\t &e->where);\n+\t      gfc_interface *p;\n+\t      for (p = sym->generic; p; p = p->next)\n+\t\tif (strcmp (sym->name, p->sym->name) == 0)\n+\t\t  {\n+\t\t    e->symtree = gfc_find_symtree\n+\t\t\t\t\t   (p->sym->ns->sym_root, sym->name);\n+\t\t    sym = p->sym;\n+\t\t    break;\n+\t\t  }\n+\n+\t      if (p == NULL || e->symtree == NULL)\n+\t\tgfc_error (\"GENERIC non-INTRINSIC procedure '%s' is not \"\n+\t\t\t\t\"allowed as an actual argument at %L\", sym->name,\n+\t\t\t\t&e->where);\n \t    }\n \n \t  /* If the symbol is the function that names the current (or\n@@ -5663,7 +5676,8 @@ resolve_fl_variable (gfc_symbol *sym, int mp_flag)\n   /* Check to see if a derived type is blocked from being host associated\n      by the presence of another class I symbol in the same namespace.\n      14.6.1.3 of the standard and the discussion on comp.lang.fortran.  */\n-  if (sym->ts.type == BT_DERIVED && sym->ns != sym->ts.derived->ns)\n+  if (sym->ts.type == BT_DERIVED && sym->ns != sym->ts.derived->ns\n+\t&& sym->ns->proc_name->attr.if_source != IFSRC_IFBODY)\n     {\n       gfc_symbol *s;\n       gfc_find_symbol (sym->ts.derived->name, sym->ns, 0, &s);"}, {"sha": "00e54c830ce48e91bf0ae4c497e1bc0f7abbeed2", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36d3fb4cfe1c79915ed747b54f6a1aa2a471a833/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36d3fb4cfe1c79915ed747b54f6a1aa2a471a833/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=36d3fb4cfe1c79915ed747b54f6a1aa2a471a833", "patch": "@@ -5216,9 +5216,12 @@ gfc_trans_deferred_array (gfc_symbol * sym, tree body)\n     \n   if (sym_has_alloc_comp && !(sym->attr.pointer || sym->attr.allocatable))\n     {\n-      rank = sym->as ? sym->as->rank : 0;\n-      tmp = gfc_nullify_alloc_comp (sym->ts.derived, descriptor, rank);\n-      gfc_add_expr_to_block (&fnblock, tmp);\n+      if (!sym->attr.save)\n+\t{\n+\t  rank = sym->as ? sym->as->rank : 0;\n+\t  tmp = gfc_nullify_alloc_comp (sym->ts.derived, descriptor, rank);\n+\t  gfc_add_expr_to_block (&fnblock, tmp);\n+\t}\n     }\n   else if (!GFC_DESCRIPTOR_TYPE_P (type))\n     {\n@@ -5239,7 +5242,7 @@ gfc_trans_deferred_array (gfc_symbol * sym, tree body)\n   /* Allocatable arrays need to be freed when they go out of scope.\n      The allocatable components of pointers must not be touched.  */\n   if (sym_has_alloc_comp && !(sym->attr.function || sym->attr.result)\n-      && !sym->attr.pointer)\n+      && !sym->attr.pointer && !sym->attr.save)\n     {\n       int rank;\n       rank = sym->as ? sym->as->rank : 0;"}, {"sha": "291295c34e4f7d650281e9958aaa9f763994d320", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36d3fb4cfe1c79915ed747b54f6a1aa2a471a833/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36d3fb4cfe1c79915ed747b54f6a1aa2a471a833/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=36d3fb4cfe1c79915ed747b54f6a1aa2a471a833", "patch": "@@ -1,3 +1,19 @@\n+2007-03-15  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/30922\n+\t* gfortran.dg/import5.f90.f90: New test.\n+\n+\n+\tPR fortran/30879\n+\t* gfortran.dg/data_components_1.f90: New test.\n+\n+\n+\tPR fortran/30870\n+\t* gfortran.dg/generic_13.f90: New test.\n+\n+\tPR fortran/31163\n+\t* gfortran.dg/alloc_comp_basics_5.f90: New test.\n+\n 2007-03-14  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n \n \tPR libgfortran/31051"}, {"sha": "99cd9e08ce342bd5539fe04ab57e5b5351648d9f", "filename": "gcc/testsuite/gfortran.dg/alloc_comp_basics_5.f90", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36d3fb4cfe1c79915ed747b54f6a1aa2a471a833/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_basics_5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36d3fb4cfe1c79915ed747b54f6a1aa2a471a833/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_basics_5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Falloc_comp_basics_5.f90?ref=36d3fb4cfe1c79915ed747b54f6a1aa2a471a833", "patch": "@@ -0,0 +1,47 @@\n+! { dg-do run }\n+! This checks the correct functioning of derived types with the SAVE\n+! attribute and allocatable components - PR31163\n+!\n+! Contributed by Salvatore Filippone  <salvatore.filippone@uniroma2.it>\n+!\n+Module bar_mod\n+\n+  type foo_type\n+     integer, allocatable :: mv(:)\n+  end type foo_type\n+\n+\n+contains\n+\n+\n+  subroutine bar_foo_ab(info)\n+\n+    integer, intent(out)               :: info\n+    Type(foo_type), save :: f_a\n+    \n+    if (allocated(f_a%mv)) then \n+      info = size(f_a%mv)\n+    else\n+      allocate(f_a%mv(10),stat=info)\n+      if (info /= 0) then \n+        info = -1 \n+      endif\n+    end if\n+  end subroutine bar_foo_ab\n+\n+\n+end module bar_mod\n+\n+program tsave\n+  use bar_mod\n+\n+  integer :: info\n+  \n+  call bar_foo_ab(info) \n+  if (info .ne. 0) call abort ()\n+  call bar_foo_ab(info) \n+  if (info .ne. 10) call abort ()\n+  \n+end program tsave\n+\n+! { dg-final { cleanup-modules \"bar_mod\" } }"}, {"sha": "2ce677e9f026e4fd40054ef8b125076d1491796f", "filename": "gcc/testsuite/gfortran.dg/data_components_1.f90", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36d3fb4cfe1c79915ed747b54f6a1aa2a471a833/gcc%2Ftestsuite%2Fgfortran.dg%2Fdata_components_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36d3fb4cfe1c79915ed747b54f6a1aa2a471a833/gcc%2Ftestsuite%2Fgfortran.dg%2Fdata_components_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdata_components_1.f90?ref=36d3fb4cfe1c79915ed747b54f6a1aa2a471a833", "patch": "@@ -0,0 +1,23 @@\n+! { dg-do compile }\n+! Check the fix for PR30879, in which the structure\n+! components in the DATA values would cause a syntax\n+! error.\n+!\n+! Contributed by Joost VandeVondele <jv244@cam.ac.uk>\n+!\n+  TYPE T1\n+   INTEGER :: I\n+  END TYPE T1\n+\n+  TYPE(T1), PARAMETER :: D1=T1(2)\n+  TYPE(T1) :: D2(2)\n+\n+  INTEGER :: a(2)\n+\n+  DATA (a(i),i=1,D1%I) /D1%I*D1%I/\n+\n+  DATA (D2(i),i=1,D1%I) /D1%I*T1(4)/\n+\n+  print *, a\n+  print *, D2\n+  END"}, {"sha": "56613451115f6cc99cabf5cf54219389c8403c06", "filename": "gcc/testsuite/gfortran.dg/generic_13.f90", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36d3fb4cfe1c79915ed747b54f6a1aa2a471a833/gcc%2Ftestsuite%2Fgfortran.dg%2Fgeneric_13.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36d3fb4cfe1c79915ed747b54f6a1aa2a471a833/gcc%2Ftestsuite%2Fgfortran.dg%2Fgeneric_13.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgeneric_13.f90?ref=36d3fb4cfe1c79915ed747b54f6a1aa2a471a833", "patch": "@@ -0,0 +1,36 @@\n+! { dg-do compile }\n+! tests the patch for PR30870, in which the generic XX was rejected\n+! because the specific with the same name was not looked for.\n+!\n+! Contributed by Joost VandeVondele <jv244@cam.ac.uk>\n+!\n+MODULE TEST\n+ INTERFACE xx\n+   MODULE PROCEDURE xx\n+ END INTERFACE\n+ public :: xx\n+CONTAINS\n+ SUBROUTINE xx(i)\n+  INTEGER :: I\n+  I=7\n+ END SUBROUTINE\n+END\n+MODULE TOO\n+CONTAINS\n+ SUBROUTINE SUB(xx,I)\n+  INTERFACE\n+    SUBROUTINE XX(I)\n+        INTEGER :: I\n+    END SUBROUTINE\n+  END INTERFACE\n+  CALL XX(I)\n+ END SUBROUTINE\n+END MODULE TOO\n+PROGRAM TT\n+ USE TEST\n+ USE TOO\n+ INTEGER :: I\n+ CALL SUB(xx,I)\n+ IF (I.NE.7) CALL ABORT()\n+END PROGRAM\n+! { dg-final { cleanup-modules \"test too\" } }"}, {"sha": "0106c4ec121442e4c5992ff24a4c3111c3128a19", "filename": "gcc/testsuite/gfortran.dg/import5.f90", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/36d3fb4cfe1c79915ed747b54f6a1aa2a471a833/gcc%2Ftestsuite%2Fgfortran.dg%2Fimport5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/36d3fb4cfe1c79915ed747b54f6a1aa2a471a833/gcc%2Ftestsuite%2Fgfortran.dg%2Fimport5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fimport5.f90?ref=36d3fb4cfe1c79915ed747b54f6a1aa2a471a833", "patch": "@@ -0,0 +1,44 @@\n+! { dg-do compile }\n+! Test for import in interfaces PR fortran/30922\n+!\n+! Contributed by Tobias Burnus <burnus@gcc.gnu.org>\n+!\n+module test_import\n+  implicit none\n+\n+  type :: my_type\n+     integer :: data\n+  end type my_type\n+  integer, parameter :: n = 20\n+\n+  interface\n+     integer function func1(param)\n+       import\n+       type(my_type) :: param(n)\n+     end function func1\n+\n+     integer function func2(param)\n+       import :: my_type\n+       type(my_type), value :: param\n+     end function func2\n+  end interface\n+\n+contains\n+\n+  subroutine sub1 ()\n+\n+    interface\n+      integer function func3(param)\n+        import\n+        type(my_type), dimension (n) :: param\n+      end function func3\n+\n+      integer function func4(param)\n+        import :: my_type, n\n+        type(my_type), dimension (n) :: param\n+      end function func4\n+    end interface\n+\n+  end subroutine sub1\n+end module test_import\n+! { dg-final { cleanup-modules \"test_import\" } }"}]}