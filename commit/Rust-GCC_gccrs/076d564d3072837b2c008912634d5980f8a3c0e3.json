{"sha": "076d564d3072837b2c008912634d5980f8a3c0e3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDc2ZDU2NGQzMDcyODM3YjJjMDA4OTEyNjM0ZDU5ODBmOGEzYzBlMw==", "commit": {"author": {"name": "Aditya Kumar", "email": "aditya.k7@samsung.com", "date": "2015-10-05T16:02:59Z"}, "committer": {"name": "Sebastian Pop", "email": "spop@gcc.gnu.org", "date": "2015-10-05T16:02:59Z"}, "message": "move scop detection related stuff to graphite-scop-detection.c\n\nCo-Authored-By: Sebastian Pop <s.pop@samsung.com>\n\nFrom-SVN: r228492", "tree": {"sha": "d7dc845a0cadde6d90436cf8a9cfb60ad862ecd2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d7dc845a0cadde6d90436cf8a9cfb60ad862ecd2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/076d564d3072837b2c008912634d5980f8a3c0e3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/076d564d3072837b2c008912634d5980f8a3c0e3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/076d564d3072837b2c008912634d5980f8a3c0e3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/076d564d3072837b2c008912634d5980f8a3c0e3/comments", "author": null, "committer": {"login": "sebpop", "id": 568397, "node_id": "MDQ6VXNlcjU2ODM5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/568397?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sebpop", "html_url": "https://github.com/sebpop", "followers_url": "https://api.github.com/users/sebpop/followers", "following_url": "https://api.github.com/users/sebpop/following{/other_user}", "gists_url": "https://api.github.com/users/sebpop/gists{/gist_id}", "starred_url": "https://api.github.com/users/sebpop/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sebpop/subscriptions", "organizations_url": "https://api.github.com/users/sebpop/orgs", "repos_url": "https://api.github.com/users/sebpop/repos", "events_url": "https://api.github.com/users/sebpop/events{/privacy}", "received_events_url": "https://api.github.com/users/sebpop/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c8710b5ce0876b154477b3d80ba415f857661f76", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c8710b5ce0876b154477b3d80ba415f857661f76", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c8710b5ce0876b154477b3d80ba415f857661f76"}], "stats": {"total": 2129, "additions": 1226, "deletions": 903}, "files": [{"sha": "6b71dc7780e99642b9101801d40f94ecce9b2216", "filename": "gcc/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/076d564d3072837b2c008912634d5980f8a3c0e3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/076d564d3072837b2c008912634d5980f8a3c0e3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=076d564d3072837b2c008912634d5980f8a3c0e3", "patch": "@@ -1,3 +1,34 @@\n+2015-10-05  Aditya Kumar  <aditya.k7@samsung.com>\n+\t    Sebastian Pop  <s.pop@samsung.com>\n+\n+\t* graphite-scop-detection.c: Include domwalk.h and tree-cfg.h.\n+\t(trivially_empty_bb_p): Move...\n+\t(same_close_phi_node): Move...\n+\t(new_gimple_poly_bb): Move...\n+\t(compare_bb_depths): Move...\n+\t(graphite_sort_dominated_info): Move...\n+\t(remove_duplicate_close_phi): Move...\n+\t(make_close_phi_nodes_unique): Move...\n+\t(canonicalize_loop_closed_ssa): Move...\n+\t(canonicalize_loop_closed_ssa_form): Move...\n+\t(loop_ivs_can_be_represented): Move...\n+\t(single_pred_cond_non_loop_exit): Move...\n+\t(graphite_can_represent_init): Move...\n+\t(graphite_can_represent_scev): Move...\n+\t(stmt_has_simple_data_refs_p): Move...\n+\t(stmt_has_side_effects):  Move...\n+\t(graphite_can_represent_stmt): Move...\n+\t(scop_detection): ... here.\n+\t(sese_dom_walker): ... and here.\n+\t(build_scops): Call all moved functions.\n+\t* graphite-sese-to-poly.c (try_generate_gimple_bb): Move...\n+\t(all_non_dominated_preds_marked_p): Move...\n+\t(build_scop_bbs_1): Move...\n+\t(build_scop_bbs): Move...\n+\t(set_scop_parameter_dim): Move...\n+\t(nb_pbbs_in_loops): Move...\n+\t(build_poly_scop): Do not call all the moved functions.\n+\n 2015-10-05  Martin Jambor  <mjambor@suse.cz>\n \t    Jan Hubicka  <hubicka@ucw.cz>\n "}, {"sha": "03fd023a56d91ae4512a0612748e075cb01fbac9", "filename": "gcc/graphite-scop-detection.c", "status": "modified", "additions": 1178, "deletions": 736, "changes": 1914, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/076d564d3072837b2c008912634d5980f8a3c0e3/gcc%2Fgraphite-scop-detection.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/076d564d3072837b2c008912634d5980f8a3c0e3/gcc%2Fgraphite-scop-detection.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-scop-detection.c?ref=076d564d3072837b2c008912634d5980f8a3c0e3", "patch": "@@ -34,12 +34,14 @@ along with GCC; see the file COPYING3.  If not see\n #include \"coretypes.h\"\n #include \"backend.h\"\n #include \"cfghooks.h\"\n+#include \"domwalk.h\"\n #include \"params.h\"\n #include \"tree.h\"\n #include \"gimple.h\"\n #include \"ssa.h\"\n #include \"fold-const.h\"\n #include \"gimple-iterator.h\"\n+#include \"tree-cfg.h\"\n #include \"tree-ssa-loop-manip.h\"\n #include \"tree-ssa-loop-niter.h\"\n #include \"tree-ssa-loop.h\"\n@@ -58,23 +60,14 @@ along with GCC; see the file COPYING3.  If not see\n    TODO: Make all this as a constant_edge.  */\n struct sese_l\n {\n-  sese_l (edge e, edge x)\n-  : entry (e), exit (x)\n-  { }\n+  sese_l (edge e, edge x) : entry (e), exit (x) {}\n \n   /* This is to push objects of sese_l in a vec.  */\n-  sese_l (int i)\n-  : entry (NULL), exit (NULL)\n-  {\n-    gcc_assert (i == 0);\n-  }\n+  sese_l (int i) : entry (NULL), exit (NULL) { gcc_assert (i == 0); }\n \n-  operator bool () const\n-  {\n-    return entry && exit;\n-  }\n+  operator bool () const { return entry && exit; }\n \n-  const sese_l&\n+  const sese_l &\n   operator= (const sese_l &s)\n   {\n     entry = s.entry;\n@@ -86,70 +79,967 @@ struct sese_l\n   edge exit;\n };\n \n-/* APIs for getting entry/exit of an sese.  */\n-static basic_block\n-get_entry_bb (edge e)\n-{\n-  return e->dest;\n-}\n+/* APIs for getting entry/exit of an sese.  */\n+static basic_block\n+get_entry_bb (edge e)\n+{\n+  return e->dest;\n+}\n+\n+static basic_block\n+get_exit_bb (edge e)\n+{\n+  return e->src;\n+}\n+\n+class debug_printer\n+{\n+private:\n+  FILE *dump_file;\n+\n+public:\n+  void\n+  set_dump_file (FILE *f)\n+  {\n+    gcc_assert (f);\n+    dump_file = f;\n+  }\n+\n+  friend debug_printer &\n+  operator<< (debug_printer &output, int i)\n+  {\n+    fprintf (output.dump_file, \"%d\", i);\n+    return output;\n+  }\n+  friend debug_printer &\n+  operator<< (debug_printer &output, const char *s)\n+  {\n+    fprintf (output.dump_file, \"%s\", s);\n+    return output;\n+  }\n+} dp;\n+\n+#define DEBUG_PRINT(args) do \\\n+    {\t\t\t\t\t\t\t\t\\\n+      if (dump_file && (dump_flags & TDF_DETAILS)) { args; }\t\\\n+    } while (0);\n+\n+\n+/* Return true if BB is empty, contains only DEBUG_INSNs.  */\n+\n+static bool\n+trivially_empty_bb_p (basic_block bb)\n+{\n+  gimple_stmt_iterator gsi;\n+\n+  for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+    if (gimple_code (gsi_stmt (gsi)) != GIMPLE_DEBUG)\n+      return false;\n+\n+  return true;\n+}\n+\n+/* Returns true when P1 and P2 are close phis with the same\n+   argument.  */\n+\n+static inline bool\n+same_close_phi_node (gphi *p1, gphi *p2)\n+{\n+  return operand_equal_p (gimple_phi_arg_def (p1, 0),\n+\t\t\t  gimple_phi_arg_def (p2, 0), 0);\n+}\n+\n+/* Store the GRAPHITE representation of BB.  */\n+\n+static gimple_poly_bb_p\n+new_gimple_poly_bb (basic_block bb, vec<data_reference_p> drs)\n+{\n+  gimple_poly_bb_p gbb;\n+\n+  gbb = XNEW (struct gimple_poly_bb);\n+  bb->aux = gbb;\n+  GBB_BB (gbb) = bb;\n+  GBB_DATA_REFS (gbb) = drs;\n+  GBB_CONDITIONS (gbb).create (0);\n+  GBB_CONDITION_CASES (gbb).create (0);\n+\n+  return gbb;\n+}\n+\n+/* Compare the depth of two basic_block's P1 and P2.  */\n+\n+static int\n+compare_bb_depths (const void *p1, const void *p2)\n+{\n+  const_basic_block const bb1 = *(const_basic_block const *)p1;\n+  const_basic_block const bb2 = *(const_basic_block const *)p2;\n+  int d1 = loop_depth (bb1->loop_father);\n+  int d2 = loop_depth (bb2->loop_father);\n+\n+  if (d1 < d2)\n+    return 1;\n+\n+  if (d1 > d2)\n+    return -1;\n+\n+  return 0;\n+}\n+\n+/* Sort the basic blocks from DOM such that the first are the ones at\n+   a deepest loop level.  */\n+\n+static void\n+graphite_sort_dominated_info (vec<basic_block> dom)\n+{\n+  dom.qsort (compare_bb_depths);\n+}\n+\n+static void make_close_phi_nodes_unique (basic_block bb);\n+\n+/* Remove the close phi node at GSI and replace its rhs with the rhs\n+   of PHI.  */\n+\n+static void\n+remove_duplicate_close_phi (gphi *phi, gphi_iterator *gsi)\n+{\n+  gimple *use_stmt;\n+  use_operand_p use_p;\n+  imm_use_iterator imm_iter;\n+  tree res = gimple_phi_result (phi);\n+  tree def = gimple_phi_result (gsi->phi ());\n+\n+  gcc_assert (same_close_phi_node (phi, gsi->phi ()));\n+\n+  FOR_EACH_IMM_USE_STMT (use_stmt, imm_iter, def)\n+    {\n+      FOR_EACH_IMM_USE_ON_STMT (use_p, imm_iter)\n+\tSET_USE (use_p, res);\n+\n+      update_stmt (use_stmt);\n+\n+      /* It is possible that we just created a duplicate close-phi\n+\t for an already-processed containing loop.  Check for this\n+\t case and clean it up.  */\n+      if (gimple_code (use_stmt) == GIMPLE_PHI\n+\t  && gimple_phi_num_args (use_stmt) == 1)\n+\tmake_close_phi_nodes_unique (gimple_bb (use_stmt));\n+    }\n+\n+  remove_phi_node (gsi, true);\n+}\n+\n+/* Removes all the close phi duplicates from BB.  */\n+\n+static void\n+make_close_phi_nodes_unique (basic_block bb)\n+{\n+  gphi_iterator psi;\n+\n+  for (psi = gsi_start_phis (bb); !gsi_end_p (psi); gsi_next (&psi))\n+    {\n+      gphi_iterator gsi = psi;\n+      gphi *phi = psi.phi ();\n+\n+      /* At this point, PHI should be a close phi in normal form.  */\n+      gcc_assert (gimple_phi_num_args (phi) == 1);\n+\n+      /* Iterate over the next phis and remove duplicates.  */\n+      gsi_next (&gsi);\n+      while (!gsi_end_p (gsi))\n+\tif (same_close_phi_node (phi, gsi.phi ()))\n+\t  remove_duplicate_close_phi (phi, &gsi);\n+\telse\n+\t  gsi_next (&gsi);\n+    }\n+}\n+\n+/* Transforms LOOP to the canonical loop closed SSA form.  */\n+\n+static void\n+canonicalize_loop_closed_ssa (loop_p loop)\n+{\n+  edge e = single_exit (loop);\n+  basic_block bb;\n+\n+  if (!e || e->flags & EDGE_ABNORMAL)\n+    return;\n+\n+  bb = e->dest;\n+\n+  if (single_pred_p (bb))\n+    {\n+      e = split_block_after_labels (bb);\n+      DEBUG_PRINT (dp << \"\\nSplitting bb_\" << bb->index);\n+      make_close_phi_nodes_unique (e->src);\n+    }\n+  else\n+    {\n+      gphi_iterator psi;\n+      basic_block close = split_edge (e);\n+\n+      e = single_succ_edge (close);\n+      DEBUG_PRINT (dp << \"\\nSplitting edge (\" << e->src->index << \",\"\n+\t\t      << e->dest->index << \")\\n\");\n+\n+      for (psi = gsi_start_phis (bb); !gsi_end_p (psi); gsi_next (&psi))\n+\t{\n+\t  gphi *phi = psi.phi ();\n+\t  unsigned i;\n+\n+\t  for (i = 0; i < gimple_phi_num_args (phi); i++)\n+\t    if (gimple_phi_arg_edge (phi, i) == e)\n+\t      {\n+\t\ttree res, arg = gimple_phi_arg_def (phi, i);\n+\t\tuse_operand_p use_p;\n+\t\tgphi *close_phi;\n+\n+\t\tif (TREE_CODE (arg) != SSA_NAME)\n+\t\t  continue;\n+\n+\t\tclose_phi = create_phi_node (NULL_TREE, close);\n+\t\tres = create_new_def_for (arg, close_phi,\n+\t\t\t\t\t  gimple_phi_result_ptr (close_phi));\n+\t\tadd_phi_arg (close_phi, arg,\n+\t\t\t     gimple_phi_arg_edge (close_phi, 0),\n+\t\t\t     UNKNOWN_LOCATION);\n+\t\tuse_p = gimple_phi_arg_imm_use_ptr (phi, i);\n+\t\treplace_exp (use_p, res);\n+\t\tupdate_stmt (phi);\n+\t      }\n+\t}\n+\n+      make_close_phi_nodes_unique (close);\n+    }\n+\n+  /* The code above does not properly handle changes in the post dominance\n+     information (yet).  */\n+  recompute_all_dominators ();\n+}\n+\n+/* Converts the current loop closed SSA form to a canonical form\n+   expected by the Graphite code generation.\n+\n+   The loop closed SSA form has the following invariant: a variable\n+   defined in a loop that is used outside the loop appears only in the\n+   phi nodes in the destination of the loop exit.  These phi nodes are\n+   called close phi nodes.\n+\n+   The canonical loop closed SSA form contains the extra invariants:\n+\n+   - when the loop contains only one exit, the close phi nodes contain\n+   only one argument.  That implies that the basic block that contains\n+   the close phi nodes has only one predecessor, that is a basic block\n+   in the loop.\n+\n+   - the basic block containing the close phi nodes does not contain\n+   other statements.\n+\n+   - there exist only one phi node per definition in the loop.\n+*/\n+\n+static void\n+canonicalize_loop_closed_ssa_form (void)\n+{\n+  loop_p loop;\n+\n+#ifdef ENABLE_CHECKING\n+  verify_loop_closed_ssa (true);\n+#endif\n+\n+  FOR_EACH_LOOP (loop, 0)\n+    canonicalize_loop_closed_ssa (loop);\n+\n+  rewrite_into_loop_closed_ssa (NULL, TODO_update_ssa);\n+  update_ssa (TODO_update_ssa);\n+\n+#ifdef ENABLE_CHECKING\n+  verify_loop_closed_ssa (true);\n+#endif\n+}\n+\n+/* Can all ivs be represented by a signed integer?\n+   As ISL might generate negative values in its expressions, signed loop ivs\n+   are required in the backend.  */\n+\n+static bool\n+loop_ivs_can_be_represented (loop_p loop)\n+{\n+  unsigned type_long_long = TYPE_PRECISION (long_long_integer_type_node);\n+  for (gphi_iterator psi = gsi_start_phis (loop->header); !gsi_end_p (psi);\n+       gsi_next (&psi))\n+    {\n+      gphi *phi = psi.phi ();\n+      tree res = PHI_RESULT (phi);\n+      tree type = TREE_TYPE (res);\n+\n+      if (TYPE_UNSIGNED (type) && TYPE_PRECISION (type) >= type_long_long)\n+\treturn false;\n+    }\n+\n+  return true;\n+}\n+\n+/* Returns a COND_EXPR statement when BB has a single predecessor, the\n+   edge between BB and its predecessor is not a loop exit edge, and\n+   the last statement of the single predecessor is a COND_EXPR.  */\n+\n+static gcond *\n+single_pred_cond_non_loop_exit (basic_block bb)\n+{\n+  if (single_pred_p (bb))\n+    {\n+      edge e = single_pred_edge (bb);\n+      basic_block pred = e->src;\n+      gimple *stmt;\n+\n+      if (loop_depth (pred->loop_father) > loop_depth (bb->loop_father))\n+\treturn NULL;\n+\n+      stmt = last_stmt (pred);\n+\n+      if (stmt && gimple_code (stmt) == GIMPLE_COND)\n+\treturn as_a<gcond *> (stmt);\n+    }\n+\n+  return NULL;\n+}\n+\n+namespace\n+{\n+\n+/* Build the maximal scop containing LOOPs and add it to SCOPS.  */\n+\n+class scop_detection\n+{\n+public:\n+  scop_detection () : scops (vNULL) {}\n+\n+  /* A marker for invalid sese_l.  */\n+  static sese_l invalid_sese;\n+\n+  /* Return the SCOPS in this SCOP_DETECTION.  */\n+\n+  vec<sese_l>\n+  get_scops ()\n+  {\n+    return scops;\n+  }\n+\n+  /* Return an sese_l around the LOOP.  */\n+\n+  sese_l get_sese (loop_p loop);\n+\n+  /* Return the closest dominator with a single entry edge.  In case of a\n+     back-loop the back-edge is not counted.  */\n+\n+  static edge get_nearest_dom_with_single_entry (basic_block dom);\n+\n+  /* Return the closest post-dominator with a single exit edge.  In case of a\n+     back-loop the back-edge is not counted.  */\n+\n+  static edge get_nearest_pdom_with_single_exit (basic_block dom);\n+\n+  /* Print S to FILE.  */\n+\n+  static void print_sese (FILE *file, sese_l s);\n+\n+  /* Merge scops at same loop depth and returns the new sese.\n+     Returns a new SESE when merge was successful, INVALID_SESE otherwise.  */\n+\n+  sese_l merge_sese (sese_l first, sese_l second) const;\n+\n+  /* Build scop outer->inner if possible.  */\n+\n+  sese_l build_scop_depth (sese_l s, loop_p loop);\n+\n+  /* If loop and loop->next are valid scops, try to merge them.  */\n+\n+  sese_l build_scop_breadth (sese_l s1, loop_p loop);\n+\n+  /* Return true when LOOP is a valid scop, that is a Static Control Part, a\n+     region of code that can be represented in the polyhedral model.  SCOP\n+     defines the region we analyse.  */\n+\n+  bool loop_is_valid_scop (loop_p loop, sese_l scop) const;\n+\n+  /* Return true when BEGIN is the preheader edge of a loop with a single exit\n+     END.  */\n+\n+  static bool region_has_one_loop (sese_l s);\n+\n+  /* Add to SCOPS a scop starting at SCOP_BEGIN and ending at SCOP_END.  */\n+\n+  void add_scop (sese_l s);\n+\n+  /* Returns true if S1 subsumes/surrounds S2.  */\n+  static bool subsumes (sese_l s1, sese_l s2);\n+\n+  /* Remove a SCoP which is subsumed by S1.  */\n+  void remove_subscops (sese_l s1);\n+\n+  /* Returns true if S1 intersects with S2.  Since we already know that S1 does\n+     not subsume S2 or vice-versa, we only check for entry bbs.  */\n+\n+  static bool intersects (sese_l s1, sese_l s2);\n+\n+  /* Remove one of the scops when it intersects with any other.  */\n+\n+  void remove_intersecting_scops (sese_l s1);\n+\n+  /* Return true when the body of LOOP has statements that can be represented\n+     as a valid scop.  */\n+\n+  bool loop_body_is_valid_scop (loop_p loop, sese_l scop) const;\n+\n+  /* Return true when BB contains a harmful operation for a scop: that\n+     can be a function call with side effects, the induction variables\n+     are not linear with respect to SCOP, etc.  The current open\n+     scop should end before this statement.  */\n+\n+  bool harmful_stmt_in_bb (sese_l scop, basic_block bb) const;\n+\n+  /* Return true when a statement in SCOP cannot be represented by Graphite.\n+     The assumptions are that L1 dominates L2, and SCOP->entry dominates L1.\n+     Limit the number of bbs between adjacent loops to\n+     PARAM_SCOP_MAX_NUM_BBS_BETWEEN_LOOPS.  */\n+\n+  bool harmful_stmt_in_region (sese_l scop) const;\n+\n+  /* Return true only when STMT is simple enough for being handled by Graphite.\n+     This depends on SCOP, as the parameters are initialized relatively to\n+     this basic block, the linear functions are initialized based on the\n+     outermost loop containing STMT inside the SCOP.  BB is the place where we\n+     try to evaluate the STMT.  */\n+\n+  bool stmt_simple_for_scop_p (sese_l scop, gimple *stmt,\n+\t\t\t       basic_block bb) const;\n+\n+  /* Something like \"n * m\" is not allowed.  */\n+\n+  static bool graphite_can_represent_init (tree e);\n+\n+  /* Return true when SCEV can be represented in the polyhedral model.\n+\n+     An expression can be represented, if it can be expressed as an\n+     affine expression.  For loops (i, j) and parameters (m, n) all\n+     affine expressions are of the form:\n+\n+     x1 * i + x2 * j + x3 * m + x4 * n + x5 * 1 where x1..x5 element of Z\n+\n+     1 i + 20 j + (-2) m + 25\n+\n+     Something like \"i * n\" or \"n * m\" is not allowed.  */\n+\n+  static bool graphite_can_represent_scev (tree scev);\n+\n+  /* Return true when EXPR can be represented in the polyhedral model.\n+\n+     This means an expression can be represented, if it is linear with respect\n+     to the loops and the strides are non parametric.  LOOP is the place where\n+     the expr will be evaluated.  SCOP defines the region we analyse.  */\n+\n+  static bool graphite_can_represent_expr (sese_l scop, loop_p loop,\n+\t\t\t\t\t   tree expr);\n+\n+  /* Return true if the data references of STMT can be represented by Graphite.\n+     We try to analyze the data references in a loop contained in the SCOP.  */\n+\n+  static bool stmt_has_simple_data_refs_p (sese_l scop, gimple *stmt);\n+\n+  /* Remove the close phi node at GSI and replace its rhs with the rhs\n+     of PHI.  */\n+\n+  static void remove_duplicate_close_phi (gphi *phi, gphi_iterator *gsi);\n+\n+  /* Returns true when Graphite can represent LOOP in SCOP.\n+     FIXME: For the moment, graphite cannot be used on loops that iterate using\n+     induction variables that wrap.  */\n+\n+  static bool can_represent_loop_1 (loop_p loop, sese_l scop);\n+\n+  /* Return true when all the loops within LOOP can be represented by\n+     Graphite.  */\n+\n+  static bool can_represent_loop (loop_p loop, sese_l scop);\n+\n+  /* Generates a polyhedral black box only if the bb contains interesting\n+     information.  */\n+\n+  static gimple_poly_bb_p try_generate_gimple_bb (scop_p scop, basic_block bb);\n+\n+  /* Returns true if all predecessors of BB, that are not dominated by BB, are\n+     marked in MAP.  The predecessors dominated by BB are loop latches and will\n+     be handled after BB.  */\n+\n+  static bool all_non_dominated_preds_marked_p (basic_block bb, sbitmap map);\n+\n+  /* Recursive helper function for build_scops_bbs.  */\n+\n+  static void build_scop_bbs_1 (scop_p scop, sbitmap visited, basic_block bb);\n+\n+  /* Gather the basic blocks belonging to the SCOP.  */\n+\n+  static void build_scop_bbs (scop_p scop);\n+\n+  /* Returns the number of pbbs that are in loops contained in SCOP.  */\n+\n+  static int nb_pbbs_in_loops (scop_p scop);\n+\n+  static bool graphite_can_represent_stmt (sese_l, gimple *, basic_block);\n+\n+private:\n+  vec<sese_l> scops;\n+};\n+\n+sese_l scop_detection::invalid_sese (0);\n+\n+/* Return an sese_l around the LOOP.  */\n+\n+sese_l\n+scop_detection::get_sese (loop_p loop)\n+{\n+  if (!loop)\n+    return invalid_sese;\n+\n+  if (!loops_state_satisfies_p (LOOPS_HAVE_PREHEADERS))\n+    return invalid_sese;\n+  edge scop_end = single_exit (loop);\n+  if (!scop_end)\n+    return invalid_sese;\n+  edge scop_begin = loop_preheader_edge (loop);\n+  sese_l s (scop_begin, scop_end);\n+  return s;\n+}\n+\n+/* Return the closest dominator with a single entry edge.  */\n+\n+edge\n+scop_detection::get_nearest_dom_with_single_entry (basic_block dom)\n+{\n+  if (!dom->preds)\n+    return NULL;\n+  /* If e1->src dominates e2->src then e1->src will also dominate dom.  */\n+  if (dom->preds->length () == 2)\n+    {\n+      edge e1 = (*dom->preds)[0];\n+      edge e2 = (*dom->preds)[1];\n+      if (dominated_by_p (CDI_DOMINATORS, e2->src, e1->src))\n+\treturn e1;\n+      if (dominated_by_p (CDI_DOMINATORS, e1->src, e2->src))\n+\treturn e2;\n+    }\n+\n+  while (dom->preds->length () != 1)\n+    {\n+      if (dom->preds->length () < 1)\n+\treturn NULL;\n+      dom = get_immediate_dominator (CDI_DOMINATORS, dom);\n+      if (!dom->preds)\n+\treturn NULL;\n+    }\n+  return (*dom->preds)[0];\n+}\n+\n+/* Return the closest post-dominator with a single exit edge.  In case of a\n+   back-loop the back-edge is not counted.  */\n+\n+edge\n+scop_detection::get_nearest_pdom_with_single_exit (basic_block dom)\n+{\n+  if (!dom->succs)\n+    return NULL;\n+  if (dom->succs->length () == 2)\n+    {\n+      edge e1 = (*dom->succs)[0];\n+      edge e2 = (*dom->succs)[1];\n+      if (dominated_by_p (CDI_POST_DOMINATORS, e2->dest, e1->dest))\n+\treturn e1;\n+      if (dominated_by_p (CDI_POST_DOMINATORS, e1->dest, e2->dest))\n+\treturn e2;\n+    }\n+\n+  while (dom->succs->length () != 1)\n+    {\n+      if (dom->succs->length () < 1)\n+\treturn NULL;\n+      dom = get_immediate_dominator (CDI_POST_DOMINATORS, dom);\n+      if (!dom->succs)\n+\treturn NULL;\n+    }\n+  return (*dom->succs)[0];\n+}\n+\n+/* Print S to FILE.  */\n+\n+void\n+scop_detection::print_sese (FILE *file, sese_l s)\n+{\n+  fprintf (file, \"(entry_edge (bb_%d, bb_%d), exit_edge (bb_%d, bb_%d))\\n\",\n+           s.entry->src->index, s.entry->dest->index,\n+           s.exit->src->index, s.exit->dest->index);\n+}\n+\n+/* Merge scops at same loop depth and returns the new sese.\n+   Returns a new SESE when merge was successful, INVALID_SESE otherwise.  */\n+\n+sese_l\n+scop_detection::merge_sese (sese_l first, sese_l second) const\n+{\n+  /* In the trivial case first/second may be NULL.  */\n+  if (!first)\n+    return second;\n+  if (!second)\n+    return first;\n+\n+  DEBUG_PRINT (dp << \"[try-merging-sese] s1: \"; print_sese (dump_file, first);\n+\t       dp << \"[try-merging-sese] s2: \";\n+\t       print_sese (dump_file, second));\n+\n+  /* Assumption: Both the sese's should be at the same loop depth or one scop\n+     should subsume the other like in case of nested loops.  */\n+\n+  /* Find the common dominators for entry,\n+     and common post-dominators for the exit.  */\n+  basic_block dom = nearest_common_dominator (CDI_DOMINATORS,\n+\t\t\t\t\t      get_entry_bb (first.entry),\n+\t\t\t\t\t      get_entry_bb (second.entry));\n+\n+  edge entry = get_nearest_dom_with_single_entry (dom);\n+  if (!entry)\n+    return invalid_sese;\n+\n+  basic_block pdom = nearest_common_dominator (CDI_POST_DOMINATORS,\n+\t\t\t\t\t       get_exit_bb (first.exit),\n+\t\t\t\t\t       get_exit_bb (second.exit));\n+  pdom = nearest_common_dominator (CDI_POST_DOMINATORS, dom, pdom);\n+\n+  edge exit = get_nearest_pdom_with_single_exit (pdom);\n+  if (!exit)\n+    return invalid_sese;\n+\n+  sese_l combined (entry, exit);\n+\n+  /* FIXME: We could iterate to find the dom which dominates pdom, and pdom\n+     which post-dominates dom, until it stabilizes.  Also, ENTRY->SRC and\n+     EXIT->DEST should be in the same loop nest.  */\n+  if (!dominated_by_p (CDI_DOMINATORS, pdom, dom)\n+      || loop_depth (entry->src->loop_father)\n+         != loop_depth (exit->dest->loop_father))\n+    return invalid_sese;\n+\n+  /* For now we just want to bail out when exit does not post-dominate entry.\n+     TODO: We might just add a basic_block at the exit to make exit\n+     post-dominate entry (the entire region).  */\n+  if (!dominated_by_p (CDI_POST_DOMINATORS, get_entry_bb (entry),\n+\t\t       get_exit_bb (exit))\n+      || !dominated_by_p (CDI_DOMINATORS, get_exit_bb (exit),\n+\t\t\t  get_entry_bb (entry)))\n+    {\n+      DEBUG_PRINT (dp << \"[scop-detection-fail] cannot merge seses.\\n\");\n+      return invalid_sese;\n+    }\n+\n+  /* FIXME: We should remove this piece of code once\n+     canonicalize_loop_closed_ssa has been removed, because that function\n+     adds a BB with single exit.  */\n+  if (!trivially_empty_bb_p (get_exit_bb (combined.exit)))\n+    {\n+      /* Find the first empty succ (with single exit) of combined.exit.  */\n+      basic_block imm_succ = combined.exit->dest;\n+      if (single_succ_p (imm_succ) && trivially_empty_bb_p (imm_succ))\n+\tcombined.exit = single_succ_edge (imm_succ);\n+      else\n+\t{\n+\t  DEBUG_PRINT (dp << \"\\n[scop-detection-fail] Discarding SCoP because \"\n+\t\t\t  << \"no single exit (empty succ) for sese exit\";\n+\t\t       print_sese (dump_file, combined));\n+\t  return invalid_sese;\n+\t}\n+    }\n+\n+  /* Analyze all the BBs in new sese.  */\n+  if (harmful_stmt_in_region (combined))\n+    return invalid_sese;\n+\n+  DEBUG_PRINT (dp << \"[merged-sese] s1: \"; print_sese (dump_file, combined));\n+\n+  return combined;\n+}\n+\n+/* Build scop outer->inner if possible.  */\n+\n+sese_l\n+scop_detection::build_scop_depth (sese_l s, loop_p loop)\n+{\n+  if (!loop)\n+    return s;\n+\n+  DEBUG_PRINT (dp << \"\\n[Depth loop_\" << loop->num << \"]\");\n+  s = build_scop_depth (s, loop->inner);\n+\n+  sese_l s2 = merge_sese (s, get_sese (loop));\n+  if (!s2)\n+    {\n+      /* s might be a valid scop, so return it and start analyzing from the\n+\t adjacent loop.  */\n+      build_scop_depth (invalid_sese, loop->next);\n+      return s;\n+    }\n+\n+  if (!loop_is_valid_scop (loop, s2))\n+    return build_scop_depth (invalid_sese, loop->next);\n+\n+  return build_scop_breadth (s2, loop);\n+}\n+\n+/* If loop and loop->next are valid scops, try to merge them.  */\n+\n+sese_l\n+scop_detection::build_scop_breadth (sese_l s1, loop_p loop)\n+{\n+  if (!loop)\n+    return s1;\n+  DEBUG_PRINT (dp << \"\\n[Breadth loop_\" << loop->num << \"]\");\n+  gcc_assert (s1);\n+\n+  loop_p l = loop;\n+  sese_l s2 = build_scop_depth (invalid_sese, l->next);\n+  if (!s2)\n+    {\n+      if (s1)\n+\tadd_scop (s1);\n+      return s1;\n+    }\n+\n+  sese_l combined = merge_sese (s1, s2);\n+\n+  if (combined)\n+    s1 = combined;\n+  else\n+    add_scop (s2);\n+\n+  if (s1)\n+    add_scop (s1);\n+  return s1;\n+}\n+\n+/* Returns true when Graphite can represent LOOP in SCOP.\n+   FIXME: For the moment, graphite cannot be used on loops that iterate using\n+   induction variables that wrap.  */\n+\n+bool\n+scop_detection::can_represent_loop_1 (loop_p loop, sese_l scop)\n+{\n+  tree niter;\n+  struct tree_niter_desc niter_desc;\n+\n+  return single_exit (loop)\n+    && number_of_iterations_exit (loop, single_exit (loop), &niter_desc, false)\n+    && niter_desc.control.no_overflow\n+    && (niter = number_of_latch_executions (loop))\n+    && !chrec_contains_undetermined (niter)\n+    && graphite_can_represent_expr (scop, loop, niter);\n+}\n+\n+/* Return true when all the loops within LOOP can be represented by\n+   Graphite.  */\n+\n+bool\n+scop_detection::can_represent_loop (loop_p loop, sese_l scop)\n+{\n+  if (!can_represent_loop_1 (loop, scop))\n+    return false;\n+  if (loop->inner && !can_represent_loop (loop->inner, scop))\n+    return false;\n+  if (loop->next && !can_represent_loop (loop->next, scop))\n+    return false;\n+\n+  return true;\n+}\n+\n+/* Return true when LOOP is a valid scop, that is a Static Control Part, a\n+   region of code that can be represented in the polyhedral model.  SCOP\n+   defines the region we analyse.  */\n+\n+bool\n+scop_detection::loop_is_valid_scop (loop_p loop, sese_l scop) const\n+{\n+  if (!scop)\n+    return false;\n+\n+  if (!can_represent_loop (loop, scop))\n+    {\n+      DEBUG_PRINT (dp << \"[scop-detection-fail] cannot represent loop_\"\n+\t\t      << loop->num << \"\\n\");\n+      return false;\n+    }\n+\n+  if (loop_body_is_valid_scop (loop, scop))\n+    {\n+      DEBUG_PRINT (dp << \"[valid-scop] loop_\" << loop->num\n+\t\t      << \"is a valid scop.\\n\");\n+      return true;\n+    }\n+  return false;\n+}\n+\n+/* Return true when BEGIN is the preheader edge of a loop with a single exit\n+   END.  */\n+\n+bool\n+scop_detection::region_has_one_loop (sese_l s)\n+{\n+  edge begin = s.entry;\n+  edge end = s.exit;\n+  /* Check for a single perfectly nested loop.  */\n+  if (begin->dest->loop_father->inner)\n+    return false;\n+\n+  /* Otherwise, check whether we have adjacent loops.  */\n+  return begin->dest->loop_father == end->src->loop_father;\n+}\n+\n+/* Add to SCOPS a scop starting at SCOP_BEGIN and ending at SCOP_END.  */\n+\n+void\n+scop_detection::add_scop (sese_l s)\n+{\n+  gcc_assert (s);\n+\n+  /* Do not add scops with only one loop.  */\n+  if (region_has_one_loop (s))\n+    {\n+      DEBUG_PRINT (dp << \"\\n[scop-detection-fail] Discarding one loop SCoP\";\n+\t\t   print_sese (dump_file, s));\n+      return;\n+    }\n+\n+  if (get_exit_bb (s.exit) == EXIT_BLOCK_PTR_FOR_FN (cfun))\n+    {\n+      DEBUG_PRINT (dp << \"\\n[scop-detection-fail] \"\n+\t\t      << \"Discarding SCoP exiting to return\";\n+\t\t   print_sese (dump_file, s));\n+      return;\n+    }\n+\n+  /* Remove all the scops which are subsumed by s.  */\n+  remove_subscops (s);\n+\n+  /* Replace this with split-intersecting scops.  */\n+  remove_intersecting_scops (s);\n \n-static basic_block\n-get_exit_bb (edge e)\n-{\n-  return e->src;\n+  scops.safe_push (s);\n+  DEBUG_PRINT (dp << \"\\nAdding SCoP \"; print_sese (dump_file, s));\n }\n \n-class debug_printer\n+/* Return true when a statement in SCOP cannot be represented by Graphite.\n+   The assumptions are that L1 dominates L2, and SCOP->entry dominates L1.\n+   Limit the number of bbs between adjacent loops to\n+   PARAM_SCOP_MAX_NUM_BBS_BETWEEN_LOOPS.  */\n+\n+bool\n+scop_detection::harmful_stmt_in_region (sese_l scop) const\n {\n-private:\n-  FILE *dump_file;\n-public:\n-  void set_dump_file (FILE *f)\n-  {\n-    gcc_assert (f);\n-    dump_file = f;\n-  }\n+  basic_block exit_bb = get_exit_bb (scop.exit);\n+  basic_block entry_bb = get_entry_bb (scop.entry);\n \n-  friend debug_printer &operator<<(debug_printer &output, int i)\n-  {\n-    fprintf (output.dump_file, \"%d\", i);\n-    return output;\n-  }\n-  friend debug_printer &operator<<(debug_printer &output, const char *s)\n-  {\n-    fprintf (output.dump_file, \"%s\", s);\n-    return output;\n-  }\n-} dp;\n+  DEBUG_PRINT (dp << \"\\n[checking-harmful-bbs] \";\n+\t       print_sese (dump_file, scop));\n+  gcc_assert (dominated_by_p (CDI_DOMINATORS, exit_bb, entry_bb));\n \n-#define DEBUG_PRINT(args) do \\\n-    {\t\t\t\t\t\t\t\t\\\n-      if (dump_file && (dump_flags & TDF_DETAILS)) { args; }\t\\\n-    } while (0);\n+  int depth = bb_dom_dfs_in (CDI_DOMINATORS, exit_bb)\n+    - bb_dom_dfs_in (CDI_DOMINATORS, entry_bb);\n \n+  gcc_assert (depth > 0);\n \n-/* Return true if BB is empty, contains only DEBUG_INSNs.  */\n+  vec<basic_block> dom\n+      = get_dominated_to_depth (CDI_DOMINATORS, entry_bb, depth);\n+  int i;\n+  basic_block bb;\n+  FOR_EACH_VEC_ELT (dom, i, bb)\n+    {\n+      DEBUG_PRINT (dp << \"\\nVisiting bb_\" << bb->index);\n \n-static bool\n-trivially_empty_bb_p (basic_block bb)\n+      /* We don't want to analyze any bb outside sese.  */\n+      if (!dominated_by_p (CDI_POST_DOMINATORS, bb, exit_bb))\n+\tcontinue;\n+\n+      if (harmful_stmt_in_bb (scop, bb))\n+\treturn true;\n+    }\n+\n+    return false;\n+}\n+\n+/* Returns true if S1 subsumes/surrounds S2.  */\n+bool\n+scop_detection::subsumes (sese_l s1, sese_l s2)\n {\n-  gimple_stmt_iterator gsi;\n+  if (dominated_by_p (CDI_DOMINATORS, get_entry_bb (s2.entry),\n+\t\t      get_entry_bb (s1.entry))\n+      && dominated_by_p (CDI_POST_DOMINATORS, get_entry_bb (s2.exit),\n+\t\t\t get_entry_bb (s1.exit)))\n+    return true;\n+  return false;\n+}\n \n-  for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n-    if (gimple_code (gsi_stmt (gsi)) != GIMPLE_DEBUG)\n-      return false;\n+/* Remove a SCoP which is subsumed by S1.  */\n+void\n+scop_detection::remove_subscops (sese_l s1)\n+{\n+  int j;\n+  sese_l s2 (0);\n+  FOR_EACH_VEC_ELT_REVERSE (scops, j, s2)\n+    {\n+      if (subsumes (s1, s2))\n+\t{\n+\t  DEBUG_PRINT (dp << \"\\nRemoving sub-SCoP\";\n+\t\t       print_sese (dump_file, s2));\n+\t  scops.unordered_remove (j);\n+\t}\n+    }\n+}\n \n-  return true;\n+/* Returns true if S1 intersects with S2.  Since we already know that S1 does\n+   not subsume S2 or vice-versa, we only check for entry bbs.  */\n+\n+bool\n+scop_detection::intersects (sese_l s1, sese_l s2)\n+{\n+  if (dominated_by_p (CDI_DOMINATORS, get_entry_bb (s2.entry),\n+\t\t      get_entry_bb (s1.entry))\n+      && !dominated_by_p (CDI_DOMINATORS, get_entry_bb (s2.entry),\n+\t\t\t  get_exit_bb (s1.exit)))\n+    return true;\n+  if ((s1.exit == s2.entry) || (s2.exit == s1.entry))\n+    return true;\n+\n+  return false;\n }\n \n+/* Remove one of the scops when it intersects with any other.  */\n \n-/* Forward declarations.  */\n-static void make_close_phi_nodes_unique (basic_block);\n+void\n+scop_detection::remove_intersecting_scops (sese_l s1)\n+{\n+  int j;\n+  sese_l s2 (0);\n+  FOR_EACH_VEC_ELT_REVERSE (scops, j, s2)\n+    {\n+      if (intersects (s1, s2))\n+\t{\n+\t  DEBUG_PRINT (dp << \"\\nRemoving intersecting SCoP\";\n+\t\t       print_sese (dump_file, s2); dp << \"Intersects with:\";\n+\t\t       print_sese (dump_file, s1));\n+\t  scops.unordered_remove (j);\n+\t}\n+    }\n+}\n \n /* Something like \"n * m\" is not allowed.  */\n \n-static bool\n-graphite_can_represent_init (tree e)\n+bool\n+scop_detection::graphite_can_represent_init (tree e)\n {\n   switch (TREE_CODE (e))\n     {\n@@ -177,8 +1067,8 @@ graphite_can_represent_init (tree e)\n     case NON_LVALUE_EXPR:\n       return graphite_can_represent_init (TREE_OPERAND (e, 0));\n \n-   default:\n-     break;\n+    default:\n+      break;\n     }\n \n   return true;\n@@ -196,8 +1086,8 @@ graphite_can_represent_init (tree e)\n \n    Something like \"i * n\" or \"n * m\" is not allowed.  */\n \n-static bool\n-graphite_can_represent_scev (tree scev)\n+bool\n+scop_detection::graphite_can_represent_scev (tree scev)\n {\n   if (chrec_contains_undetermined (scev))\n     return false;\n@@ -248,22 +1138,21 @@ graphite_can_represent_scev (tree scev)\n     }\n \n   /* Only affine functions can be represented.  */\n-  if (tree_contains_chrecs (scev, NULL)\n-      || !scev_is_linear_expression (scev))\n+  if (tree_contains_chrecs (scev, NULL) || !scev_is_linear_expression (scev))\n     return false;\n \n   return true;\n }\n \n-\n /* Return true when EXPR can be represented in the polyhedral model.\n \n    This means an expression can be represented, if it is linear with respect to\n    the loops and the strides are non parametric.  LOOP is the place where the\n    expr will be evaluated.  SCOP defines the region we analyse.  */\n \n-static bool\n-graphite_can_represent_expr (sese_l scop, loop_p loop, tree expr)\n+bool\n+scop_detection::graphite_can_represent_expr (sese_l scop, loop_p loop,\n+\t\t\t\t\t     tree expr)\n {\n   sese region = new_sese (scop.entry, scop.exit);\n   tree scev = scalar_evolution_in_region (region, loop, expr);\n@@ -274,8 +1163,8 @@ graphite_can_represent_expr (sese_l scop, loop_p loop, tree expr)\n /* Return true if the data references of STMT can be represented by Graphite.\n    We try to analyze the data references in a loop contained in the SCOP.  */\n \n-static bool\n-stmt_has_simple_data_refs_p (sese_l scop, gimple *stmt)\n+bool\n+scop_detection::stmt_has_simple_data_refs_p (sese_l scop, gimple *stmt)\n {\n   sese region = new_sese (scop.entry, scop.exit);\n   loop_p nest = outermost_loop_in_sese (region, gimple_bb (stmt));\n@@ -301,8 +1190,7 @@ stmt_has_simple_data_refs_p (sese_l scop, gimple *stmt)\n       for (int i = nb_subscripts - 1; i >= 0; i--)\n \t{\n \t  if (!graphite_can_represent_scev (DR_ACCESS_FN (dr, i))\n-\t      || (TREE_CODE (ref) != ARRAY_REF\n-\t\t  && TREE_CODE (ref) != MEM_REF\n+\t      || (TREE_CODE (ref) != ARRAY_REF && TREE_CODE (ref) != MEM_REF\n \t\t  && TREE_CODE (ref) != COMPONENT_REF))\n \t    {\n \t      free_data_refs (drs);\n@@ -313,8 +1201,8 @@ stmt_has_simple_data_refs_p (sese_l scop, gimple *stmt)\n \t}\n     }\n \n-  free_data_refs (drs);\n-  return true;\n+    free_data_refs (drs);\n+    return true;\n }\n \n /* GIMPLE_ASM and GIMPLE_CALL may embed arbitrary side effects.\n@@ -331,7 +1219,7 @@ stmt_has_side_effects (gimple *stmt)\n     {\n       DEBUG_PRINT (dp << \"[scop-detection-fail] \"\n \t\t      << \"Statement has side-effects:\\n\";\n-\tprint_gimple_stmt (dump_file, stmt, 0, TDF_VOPS|TDF_MEMSYMS));\n+\tprint_gimple_stmt (dump_file, stmt, 0, TDF_VOPS | TDF_MEMSYMS));\n       return true;\n     }\n   return false;\n@@ -340,8 +1228,9 @@ stmt_has_side_effects (gimple *stmt)\n /* Returns true if STMT can be represented in polyhedral model. LABEL,\n    simple COND stmts, pure calls, and assignments can be repesented.  */\n \n-static bool\n-graphite_can_represent_stmt (sese_l scop, gimple *stmt, basic_block bb)\n+bool\n+scop_detection::graphite_can_represent_stmt (sese_l scop, gimple *stmt,\n+\t\t\t\t\t     basic_block bb)\n {\n   loop_p loop = bb->loop_father;\n   switch (gimple_code (stmt))\n@@ -364,7 +1253,8 @@ graphite_can_represent_stmt (sese_l scop, gimple *stmt, basic_block bb)\n \t  {\n \t    DEBUG_PRINT (dp << \"[scop-detection-fail] \"\n \t\t\t    << \"Graphite cannot handle cond stmt:\\n\";\n-\t      print_gimple_stmt (dump_file, stmt, 0, TDF_VOPS|TDF_MEMSYMS));\n+\t\t\t print_gimple_stmt (dump_file, stmt, 0,\n+\t\t\t\t\t    TDF_VOPS | TDF_MEMSYMS));\n \t    return false;\n \t  }\n \n@@ -375,9 +1265,10 @@ graphite_can_represent_stmt (sese_l scop, gimple *stmt, basic_block bb)\n \t\t/* We can only constrain on integer type.  */\n \t\t|| (TREE_CODE (TREE_TYPE (op)) != INTEGER_TYPE))\n \t      {\n-\t\tDEBUG_PRINT (dp <<  \"[scop-detection-fail] \"\n-\t\t\t        << \"Graphite cannot represent stmt:\\n\";\n-\t\t  print_gimple_stmt (dump_file, stmt, 0, TDF_VOPS|TDF_MEMSYMS));\n+\t\tDEBUG_PRINT (dp << \"[scop-detection-fail] \"\n+\t\t\t\t<< \"Graphite cannot represent stmt:\\n\";\n+\t\t\t     print_gimple_stmt (dump_file, stmt, 0,\n+\t\t\t\t\t\tTDF_VOPS | TDF_MEMSYMS));\n \t\treturn false;\n \t      }\n \t  }\n@@ -391,9 +1282,10 @@ graphite_can_represent_stmt (sese_l scop, gimple *stmt, basic_block bb)\n \n     default:\n       /* These nodes cut a new scope.  */\n-      DEBUG_PRINT (dp << \"[scop-detection-fail] \"\n-\t\t      << \"Gimple stmt not handled in Graphite:\\n\";\n-\tprint_gimple_stmt (dump_file, stmt, 0, TDF_VOPS|TDF_MEMSYMS));\n+      DEBUG_PRINT (\n+\t  dp << \"[scop-detection-fail] \"\n+\t     << \"Gimple stmt not handled in Graphite:\\n\";\n+\t  print_gimple_stmt (dump_file, stmt, 0, TDF_VOPS | TDF_MEMSYMS));\n       return false;\n     }\n }\n@@ -404,8 +1296,9 @@ graphite_can_represent_stmt (sese_l scop, gimple *stmt, basic_block bb)\n    loop containing STMT inside the SCOP.  BB is the place where we try to\n    evaluate the STMT.  */\n \n-static bool\n-stmt_simple_for_scop_p (sese_l scop, gimple *stmt, basic_block bb)\n+bool\n+scop_detection::stmt_simple_for_scop_p (sese_l scop, gimple *stmt,\n+\t\t\t\t\tbasic_block bb) const\n {\n   gcc_assert (scop);\n \n@@ -431,188 +1324,16 @@ stmt_simple_for_scop_p (sese_l scop, gimple *stmt, basic_block bb)\n    are not linear with respect to SCOP, etc.  The current open\n    scop should end before this statement.  */\n \n-static bool\n-harmful_stmt_in_bb (sese_l scop, basic_block bb)\n+bool\n+scop_detection::harmful_stmt_in_bb (sese_l scop, basic_block bb) const\n {\n   gimple_stmt_iterator gsi;\n \n-  for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n-    if (!stmt_simple_for_scop_p (scop, gsi_stmt (gsi), bb))\n-      return true;\n-\n-  return false;\n-}\n-\n-/* Returns true when P1 and P2 are close phis with the same\n-   argument.  */\n-\n-static inline bool\n-same_close_phi_node (gphi *p1, gphi *p2)\n-{\n-  return operand_equal_p (gimple_phi_arg_def (p1, 0),\n-\t\t\t  gimple_phi_arg_def (p2, 0), 0);\n-}\n-\n-/* Remove the close phi node at GSI and replace its rhs with the rhs\n-   of PHI.  */\n-\n-static void\n-remove_duplicate_close_phi (gphi *phi, gphi_iterator *gsi)\n-{\n-  gimple *use_stmt;\n-  use_operand_p use_p;\n-  imm_use_iterator imm_iter;\n-  tree res = gimple_phi_result (phi);\n-  tree def = gimple_phi_result (gsi->phi ());\n-\n-  gcc_assert (same_close_phi_node (phi, gsi->phi ()));\n-\n-  FOR_EACH_IMM_USE_STMT (use_stmt, imm_iter, def)\n-    {\n-      FOR_EACH_IMM_USE_ON_STMT (use_p, imm_iter)\n-\tSET_USE (use_p, res);\n-\n-      update_stmt (use_stmt);\n-      \n-      /* It is possible that we just created a duplicate close-phi\n-\t for an already-processed containing loop.  Check for this\n-\t case and clean it up.  */\n-      if (gimple_code (use_stmt) == GIMPLE_PHI\n-\t  && gimple_phi_num_args (use_stmt) == 1)\n-\tmake_close_phi_nodes_unique (gimple_bb (use_stmt));\n-    }\n-\n-  remove_phi_node (gsi, true);\n-}\n-\n-/* Removes all the close phi duplicates from BB.  */\n-\n-static void\n-make_close_phi_nodes_unique (basic_block bb)\n-{\n-  gphi_iterator psi;\n-\n-  for (psi = gsi_start_phis (bb); !gsi_end_p (psi); gsi_next (&psi))\n-    {\n-      gphi_iterator gsi = psi;\n-      gphi *phi = psi.phi ();\n-\n-      /* At this point, PHI should be a close phi in normal form.  */\n-      gcc_assert (gimple_phi_num_args (phi) == 1);\n-\n-      /* Iterate over the next phis and remove duplicates.  */\n-      gsi_next (&gsi);\n-      while (!gsi_end_p (gsi))\n-\tif (same_close_phi_node (phi, gsi.phi ()))\n-\t  remove_duplicate_close_phi (phi, &gsi);\n-\telse\n-\t  gsi_next (&gsi);\n-    }\n-}\n-\n-/* Transforms LOOP to the canonical loop closed SSA form.  */\n-\n-static void\n-canonicalize_loop_closed_ssa (loop_p loop)\n-{\n-  edge e = single_exit (loop);\n-  basic_block bb;\n-\n-  if (!e || e->flags & EDGE_ABNORMAL)\n-    return;\n-\n-  bb = e->dest;\n-\n-  if (single_pred_p (bb))\n-    {\n-      e = split_block_after_labels (bb);\n-      DEBUG_PRINT (dp << \"\\nSplitting bb_\" << bb->index);\n-      make_close_phi_nodes_unique (e->src);\n-    }\n-  else\n-    {\n-      gphi_iterator psi;\n-      basic_block close = split_edge (e);\n-\n-      e = single_succ_edge (close);\n-      DEBUG_PRINT (dp << \"\\nSplitting edge (\"\n-\t\t      << e->src->index << \",\" << e->dest->index\n-\t\t      << \")\\n\");\n-\n-      for (psi = gsi_start_phis (bb); !gsi_end_p (psi); gsi_next (&psi))\n-\t{\n-\t  gphi *phi = psi.phi ();\n-\t  unsigned i;\n-\n-\t  for (i = 0; i < gimple_phi_num_args (phi); i++)\n-\t    if (gimple_phi_arg_edge (phi, i) == e)\n-\t      {\n-\t\ttree res, arg = gimple_phi_arg_def (phi, i);\n-\t\tuse_operand_p use_p;\n-\t\tgphi *close_phi;\n-\n-\t\tif (TREE_CODE (arg) != SSA_NAME)\n-\t\t  continue;\n-\n-\t\tclose_phi = create_phi_node (NULL_TREE, close);\n-\t\tres = create_new_def_for (arg, close_phi,\n-\t\t\t\t\t  gimple_phi_result_ptr (close_phi));\n-\t\tadd_phi_arg (close_phi, arg,\n-\t\t\t     gimple_phi_arg_edge (close_phi, 0),\n-\t\t\t     UNKNOWN_LOCATION);\n-\t\tuse_p = gimple_phi_arg_imm_use_ptr (phi, i);\n-\t\treplace_exp (use_p, res);\n-\t\tupdate_stmt (phi);\n-\t      }\n-\t}\n-\n-      make_close_phi_nodes_unique (close);\n-    }\n-\n-  /* The code above does not properly handle changes in the post dominance\n-     information (yet).  */\n-  recompute_all_dominators ();\n-}\n-\n-/* Converts the current loop closed SSA form to a canonical form\n-   expected by the Graphite code generation.\n-\n-   The loop closed SSA form has the following invariant: a variable\n-   defined in a loop that is used outside the loop appears only in the\n-   phi nodes in the destination of the loop exit.  These phi nodes are\n-   called close phi nodes.\n-\n-   The canonical loop closed SSA form contains the extra invariants:\n-\n-   - when the loop contains only one exit, the close phi nodes contain\n-   only one argument.  That implies that the basic block that contains\n-   the close phi nodes has only one predecessor, that is a basic block\n-   in the loop.\n-\n-   - the basic block containing the close phi nodes does not contain\n-   other statements.\n-\n-   - there exist only one phi node per definition in the loop.\n-*/\n-\n-static void\n-canonicalize_loop_closed_ssa_form (void)\n-{\n-  loop_p loop;\n-\n-#ifdef ENABLE_CHECKING\n-  verify_loop_closed_ssa (true);\n-#endif\n-\n-  FOR_EACH_LOOP (loop, 0)\n-    canonicalize_loop_closed_ssa (loop);\n-\n-  rewrite_into_loop_closed_ssa (NULL, TODO_update_ssa);\n-  update_ssa (TODO_update_ssa);\n+  for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+    if (!stmt_simple_for_scop_p (scop, gsi_stmt (gsi), bb))\n+      return true;\n \n-#ifdef ENABLE_CHECKING\n-  verify_loop_closed_ssa (true);\n-#endif\n+  return false;\n }\n \n /* Pretty print to FILE all the SCoPs in DOT format and mark them with\n@@ -632,7 +1353,7 @@ dot_all_scops_1 (FILE *file, vec<scop_p> scops)\n   edge e;\n   edge_iterator ei;\n   scop_p scop;\n-  const char* color;\n+  const char *color;\n   int i;\n \n   /* Disable debugging while printing graph.  */\n@@ -646,18 +1367,17 @@ dot_all_scops_1 (FILE *file, vec<scop_p> scops)\n       int part_of_scop = false;\n \n       /* Use HTML for every bb label.  So we are able to print bbs\n-         which are part of two different SCoPs, with two different\n-         background colors.  */\n+\t which are part of two different SCoPs, with two different\n+\t background colors.  */\n       fprintf (file, \"%d [label=<\\n  <TABLE BORDER=\\\"0\\\" CELLBORDER=\\\"1\\\" \",\n-                     bb->index);\n+\t       bb->index);\n       fprintf (file, \"CELLSPACING=\\\"0\\\">\\n\");\n \n       /* Select color for SCoP.  */\n       FOR_EACH_VEC_ELT (scops, i, scop)\n \t{\n \t  sese region = SCOP_REGION (scop);\n-\t  if (bb_in_sese_p (bb, region)\n-\t      || (SESE_EXIT_BB (region) == bb)\n+\t  if (bb_in_sese_p (bb, region) || (SESE_EXIT_BB (region) == bb)\n \t      || (SESE_ENTRY_BB (region) == bb))\n \t    {\n \t      switch (i % 17)\n@@ -717,13 +1437,13 @@ dot_all_scops_1 (FILE *file, vec<scop_p> scops)\n \t\t  color = \"#999999\";\n \t\t}\n \n-\t      fprintf (file, \"    <TR><TD WIDTH=\\\"50\\\" BGCOLOR=\\\"%s\\\">\", color);\n+\t      fprintf (file, \"    <TR><TD WIDTH=\\\"50\\\" BGCOLOR=\\\"%s\\\">\",\n+\t\t       color);\n \n \t      if (!bb_in_sese_p (bb, region))\n \t\tfprintf (file, \" (\");\n \n-\t      if (bb == SESE_ENTRY_BB (region)\n-\t\t  && bb == SESE_EXIT_BB (region))\n+\t      if (bb == SESE_ENTRY_BB (region) && bb == SESE_EXIT_BB (region))\n \t\tfprintf (file, \" %d*# \", bb->index);\n \t      else if (bb == SESE_ENTRY_BB (region))\n \t\tfprintf (file, \" %d* \", bb->index);\n@@ -734,28 +1454,28 @@ dot_all_scops_1 (FILE *file, vec<scop_p> scops)\n \n \t      fprintf (file, \"{lp_%d}\", bb->loop_father->num);\n \n-\t      if (!bb_in_sese_p (bb,region))\n+\t      if (!bb_in_sese_p (bb, region))\n \t\tfprintf (file, \")\");\n \n \t      fprintf (file, \"</TD></TR>\\n\");\n-\t      part_of_scop  = true;\n+\t      part_of_scop = true;\n \t    }\n \t}\n \n-      if (!part_of_scop)\n-\t{\n-\t  fprintf (file, \"    <TR><TD WIDTH=\\\"50\\\" BGCOLOR=\\\"#ffffff\\\">\");\n-\t  fprintf (file, \" %d {lp_%d} </TD></TR>\\n\",\n-\t\t   bb->index, bb->loop_father->num);\n-\t}\n-      fprintf (file, \"  </TABLE>>, shape=box, style=\\\"setlinewidth(0)\\\"]\\n\");\n+\tif (!part_of_scop)\n+\t  {\n+\t    fprintf (file, \"    <TR><TD WIDTH=\\\"50\\\" BGCOLOR=\\\"#ffffff\\\">\");\n+\t    fprintf (file, \" %d {lp_%d} </TD></TR>\\n\", bb->index,\n+\t\t     bb->loop_father->num);\n+\t  }\n+\tfprintf (file, \"  </TABLE>>, shape=box, style=\\\"setlinewidth(0)\\\"]\\n\");\n     }\n \n-  FOR_ALL_BB_FN (bb, cfun)\n-    {\n-      FOR_EACH_EDGE (e, ei, bb->succs)\n-\t      fprintf (file, \"%d -> %d;\\n\", bb->index, e->dest->index);\n-    }\n+    FOR_ALL_BB_FN (bb, cfun)\n+      {\n+\tFOR_EACH_EDGE (e, ei, bb->succs)\n+\t  fprintf (file, \"%d -> %d;\\n\", bb->index, e->dest->index);\n+      }\n \n   fputs (\"}\\n\\n\", file);\n \n@@ -811,44 +1531,23 @@ dot_scop (scop_p scop)\n #endif\n }\n \n-/* Can all ivs be represented by a signed integer?\n-   As ISL might generate negative values in its expressions, signed loop ivs\n-   are required in the backend.  */\n-\n-static bool\n-loop_ivs_can_be_represented (loop_p loop)\n-{\n-  for (gphi_iterator psi = gsi_start_phis (loop->header);\n-       !gsi_end_p (psi); gsi_next (&psi))\n-    {\n-      gphi *phi = psi.phi ();\n-      tree res = PHI_RESULT (phi);\n-      tree type = TREE_TYPE (res);\n-\n-      if (TYPE_UNSIGNED (type)\n-\t  && TYPE_PRECISION (type) >= TYPE_PRECISION (long_long_integer_type_node))\n-        return false;\n-    }\n-  return true;\n-}\n-\n /* Return true when the body of LOOP has statements that can be represented as a\n    valid scop.  */\n \n-static bool\n-loop_body_is_valid_scop (loop_p loop, sese_l scop)\n+bool\n+scop_detection::loop_body_is_valid_scop (loop_p loop, sese_l scop) const\n {\n   if (!loop_ivs_can_be_represented (loop))\n     {\n-      DEBUG_PRINT (dp << \"[scop-detection-fail] loop_\"\n-\t\t      << loop->num << \"IV cannot be represented.\\n\");\n+      DEBUG_PRINT (dp << \"[scop-detection-fail] loop_\" << loop->num\n+\t\t      << \"IV cannot be represented.\\n\");\n       return false;\n     }\n \n   if (!loop_nest_has_data_refs (loop))\n     {\n-      DEBUG_PRINT (dp << \"[scop-detection-fail] loop_\"\n-\t\t      << loop->num << \"does not have any data reference.\\n\");\n+      DEBUG_PRINT (dp << \"[scop-detection-fail] loop_\" << loop->num\n+\t\t      << \"does not have any data reference.\\n\");\n       return false;\n     }\n \n@@ -876,467 +1575,189 @@ loop_body_is_valid_scop (loop_p loop, sese_l scop)\n   return true;\n }\n \n-/* Build the maximal scop containing LOOP(s) and add it to SCOPS.  */\n+/* Generates a polyhedral black box only if the bb contains interesting\n+   information.  */\n \n-class scop_builder\n+gimple_poly_bb_p\n+scop_detection::try_generate_gimple_bb (scop_p scop, basic_block bb)\n {\n- public:\n-  scop_builder ()\n-    : scops (vNULL)\n-  { }\n-\n-  static sese_l invalid_sese;\n-\n-  vec<sese_l>\n-    get_scops ()\n-  {\n-    return scops;\n-  }\n-\n-  sese_l\n-    get_sese (loop_p loop)\n-  {\n-    if (!loop)\n-      return invalid_sese;\n-\n-    if (!loops_state_satisfies_p (LOOPS_HAVE_PREHEADERS))\n-      return invalid_sese;\n-    edge scop_end = single_exit (loop);\n-    if (!scop_end)\n-      return invalid_sese;\n-    edge scop_begin = loop_preheader_edge (loop);\n-    sese_l s (scop_begin, scop_end);\n-    return s;\n-  }\n-\n-  static edge\n-    get_nearest_dom_with_single_entry (basic_block dom)\n-  {\n-    if (!dom->preds)\n-      return NULL;\n-    /* If e1->src dominates e2->src then e1->src will also dominate dom.  */\n-    if (dom->preds->length () == 2)\n-      {\n-\tedge e1 = (*dom->preds)[0];\n-\tedge e2 = (*dom->preds)[1];\n-\tif (dominated_by_p (CDI_DOMINATORS, e2->src, e1->src))\n-\t  return e1;\n-\tif (dominated_by_p (CDI_DOMINATORS, e1->src, e2->src))\n-\t  return e2;\n-      }\n-\n-    while (dom->preds->length () != 1)\n-      {\n-\tif (dom->preds->length () < 1)\n-\t  return NULL;\n-\tdom = get_immediate_dominator (CDI_DOMINATORS, dom);\n-\tif (!dom->preds)\n-\t  return NULL;\n-      }\n-    return (*dom->preds)[0];\n-  }\n+  vec<data_reference_p> drs;\n+  drs.create (5);\n+  sese region = SCOP_REGION (scop);\n+  loop_p nest = outermost_loop_in_sese (region, bb);\n \n-  static edge\n-    get_nearest_pdom_with_single_exit (basic_block dom)\n-  {\n-    if (!dom->succs)\n-      return NULL;\n-    if (dom->succs->length () == 2)\n-      {\n-\tedge e1 = (*dom->succs)[0];\n-\tedge e2 = (*dom->succs)[1];\n-\tif (dominated_by_p (CDI_POST_DOMINATORS, e2->dest, e1->dest))\n-\t  return e1;\n-\tif (dominated_by_p (CDI_POST_DOMINATORS, e1->dest, e2->dest))\n-\t  return e2;\n-      }\n+  loop_p loop = bb->loop_father;\n+  if (!loop_in_sese_p (loop, region))\n+    loop = nest;\n \n-    while (dom->succs->length () != 1)\n-      {\n-\tif (dom->succs->length () < 1)\n-\t  return NULL;\n-\tdom = get_immediate_dominator (CDI_POST_DOMINATORS, dom);\n-\tif (!dom->succs)\n-\t  return NULL;\n-      }\n-    return (*dom->succs)[0];\n-  }\n+  gimple_stmt_iterator gsi;\n+  for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+    {\n+      gimple *stmt = gsi_stmt (gsi);\n+      if (is_gimple_debug (stmt))\n+\tcontinue;\n \n-  /* Print S to FILE.  */\n+      graphite_find_data_references_in_stmt (nest, loop, stmt, &drs);\n+    }\n \n-  static void\n-    print_sese (FILE *file, sese_l s)\n-  {\n-    fprintf (file, \"(entry_edge (bb_%d, bb_%d), exit_edge (bb_%d, bb_%d))\\n\",\n-\t     s.entry->src->index, s.entry->dest->index,\n-\t     s.exit->src->index, s.exit->dest->index);\n-  }\n+  return new_gimple_poly_bb (bb, drs);\n+}\n \n-  /* Merge scops at same loop depth and returns the new sese.\n-     Returns a new SESE when merge was successful, INVALID_SESE otherwise.  */\n+/* Returns true if all predecessors of BB, that are not dominated by BB, are\n+   marked in MAP.  The predecessors dominated by BB are loop latches and will\n+   be handled after BB.  */\n \n-  static sese_l\n-    merge_sese (sese_l first, sese_l second)\n-  {\n-    /* In the trivial case first/second may be NULL.  */\n-    if (!first)\n-      return second;\n-    if (!second)\n-      return first;\n+bool\n+scop_detection::all_non_dominated_preds_marked_p (basic_block bb, sbitmap map)\n+{\n+  edge e;\n+  edge_iterator ei;\n \n-    DEBUG_PRINT (dp << \"[try-merging-sese] s1: \";\n-\t\t print_sese (dump_file, first);\n-\t\t dp << \"[try-merging-sese] s2: \";\n-\t\t print_sese (dump_file, second));\n+  FOR_EACH_EDGE (e, ei, bb->preds)\n+    if (!bitmap_bit_p (map, e->src->index)\n+\t&& !dominated_by_p (CDI_DOMINATORS, e->src, bb))\n+      return false;\n \n-    /* Assumption: Both the sese's should be at the same loop depth or one scop\n-       should subsume the other like in case of nested loops.  */\n+  return true;\n+}\n \n-    /* Find the common dominators for entry,\n-       and common post-dominators for the exit.  */\n-    basic_block dom = nearest_common_dominator (CDI_DOMINATORS,\n-\t\t\t\t\t\tget_entry_bb (first.entry),\n-\t\t\t\t\t\tget_entry_bb (second.entry));\n+/* Recursive helper function for build_scops_bbs.  */\n \n+void\n+scop_detection::build_scop_bbs_1 (scop_p scop, sbitmap visited, basic_block bb)\n+{\n+  sese region = SCOP_REGION (scop);\n+  vec<basic_block> dom;\n+  poly_bb_p pbb;\n \n-    edge entry = get_nearest_dom_with_single_entry (dom);\n-    if (!entry)\n-      return invalid_sese;\n+  if (bitmap_bit_p (visited, bb->index) || !bb_in_sese_p (bb, region))\n+    return;\n \n-    basic_block pdom = nearest_common_dominator (CDI_POST_DOMINATORS,\n-\t\t\t\t\t\t get_exit_bb (first.exit),\n-\t\t\t\t\t\t get_exit_bb (second.exit));\n-    pdom = nearest_common_dominator (CDI_POST_DOMINATORS, dom, pdom);\n+  pbb = new_poly_bb (scop, try_generate_gimple_bb (scop, bb));\n+  SCOP_BBS (scop).safe_push (pbb);\n+  bitmap_set_bit (visited, bb->index);\n \n-    edge exit = get_nearest_pdom_with_single_exit (pdom);\n-    if (!exit)\n-      return invalid_sese;\n+  dom = get_dominated_by (CDI_DOMINATORS, bb);\n \n-    sese_l combined (entry, exit);\n+  if (!dom.exists ())\n+    return;\n \n-    /* FIXME: We could iterate to find the dom which dominates pdom, and pdom\n-       which post-dominates dom, until it stabilizes.  Also, ENTRY->SRC and\n-       EXIT->DEST should be in the same loop nest.  */\n-    if (!dominated_by_p (CDI_DOMINATORS, pdom, dom)\n-\t|| loop_depth (entry->src->loop_father)\n-\t   != loop_depth (exit->dest->loop_father))\n-      return invalid_sese;\n+  graphite_sort_dominated_info (dom);\n \n-    /* For now we just want to bail out when exit does not post-dominate entry.\n-       TODO: We might just add a basic_block at the exit to make exit\n-       post-dominate entry (the entire region).  */\n-    if (!dominated_by_p (CDI_POST_DOMINATORS, get_entry_bb (entry),\n-                         get_exit_bb (exit))\n-\t|| !dominated_by_p (CDI_DOMINATORS, get_exit_bb (exit),\n-\t\t\t    get_entry_bb (entry)))\n-      {\n-\tDEBUG_PRINT (dp <<  \"[scop-detection-fail] cannot merge seses.\\n\");\n-\treturn invalid_sese;\n-      }\n+  while (!dom.is_empty ())\n+    {\n+      int i;\n+      basic_block dom_bb;\n \n-    /* FIXME: We should remove this piece of code once\n-       canonicalize_loop_closed_ssa has been removed, because that function\n-       adds a BB with single exit.  */\n-    if (!trivially_empty_bb_p (get_exit_bb (combined.exit)))\n-      {\n-\t/* Find the first empty succ (with single exit) of combined.exit.  */\n-\tbasic_block imm_succ = combined.exit->dest;\n-\tif (single_succ_p (imm_succ) && trivially_empty_bb_p (imm_succ))\n-\t  combined.exit = single_succ_edge (imm_succ);\n-\telse\n+      FOR_EACH_VEC_ELT (dom, i, dom_bb)\n+\tif (all_non_dominated_preds_marked_p (dom_bb, visited))\n \t  {\n-\t    DEBUG_PRINT (dp << \"\\n[scop-detection-fail] Discarding SCoP because \"\n-\t\t\t    << \"no single exit (empty succ) for sese exit\";\n-\t\t\t print_sese (dump_file, combined));\n-\t    return invalid_sese;\n+\t    build_scop_bbs_1 (scop, visited, dom_bb);\n+\t    dom.unordered_remove (i);\n+\t    break;\n \t  }\n-      }\n-\n-    /* Analyze all the BBs in new sese.  */\n-    if (harmful_stmt_in_region (combined))\n-      return invalid_sese;\n-\n-    DEBUG_PRINT (dp <<  \"[merged-sese] s1: \";\n-\t\t print_sese (dump_file, combined));\n-\n-    return combined;\n-  }\n-\n-  /* Build scop outer->inner if possible.  */\n-  sese_l\n-    build_scop_depth (sese_l s, loop_p loop)\n-  {\n-    if (!loop)\n-      return s;\n-\n-    DEBUG_PRINT (dp << \"\\n[Depth loop_\" << loop->num << \"]\");\n-    s = build_scop_depth (s, loop->inner);\n-\n-    sese_l s2 = merge_sese (s, get_sese (loop));\n-    if (!s2)\n-      {\n-\t/* s might be a valid scop, so return it and start analyzing from the\n-\t   adjacent loop.  */\n-\tbuild_scop_depth (invalid_sese, loop->next);\n-\treturn s;\n-      }\n-\n-    if (!loop_is_valid_scop (loop, s2))\n-      return build_scop_depth (invalid_sese, loop->next);\n-\n-    return build_scop_breadth (s2, loop);\n-  }\n-\n-  /* If loop and loop->next are valid scops, try to merge them.  */\n-\n-  sese_l\n-    build_scop_breadth (sese_l s1, loop_p loop)\n-  {\n-    if (!loop)\n-      return s1;\n-    DEBUG_PRINT (dp << \"\\n[Breadth loop_\" << loop->num << \"]\");\n-    gcc_assert (s1);\n-\n-    loop_p l = loop;\n-    sese_l s2 = build_scop_depth (invalid_sese, l->next);\n-    if (!s2)\n-      {\n-\tif (s1)\n-\t  add_scop (s1);\n-\treturn s1;\n-      }\n-\n-    sese_l combined = merge_sese (s1, s2);\n-\n-    if (combined)\n-      s1 = combined;\n-    else\n-      add_scop (s2);\n-\n-    if (s1)\n-      add_scop (s1);\n-    return s1;\n-  }\n-\n-  /* Returns true when Graphite can represent LOOP in SCOP.\n-     FIXME: For the moment, graphite cannot be used on loops that iterate using\n-     induction variables that wrap.  */\n-  static bool\n-    can_represent_loop_1 (loop_p loop, sese_l scop)\n-  {\n-    tree niter;\n-    struct tree_niter_desc niter_desc;\n-\n-    return single_exit (loop)\n-      && number_of_iterations_exit (loop, single_exit (loop), &niter_desc, false)\n-      && niter_desc.control.no_overflow\n-      && (niter = number_of_latch_executions (loop))\n-      && !chrec_contains_undetermined (niter)\n-      && graphite_can_represent_expr (scop, loop, niter);\n-  }\n-\n-  /* Return true when all the loops within LOOP can be represented by\n-     Graphite.  */\n-\n-  static bool\n-    can_represent_loop (loop_p loop, sese_l scop)\n-  {\n-    if (!can_represent_loop_1 (loop, scop))\n-      return false;\n-    if (loop->inner && !can_represent_loop (loop->inner, scop))\n-      return false;\n-    if (loop->next && !can_represent_loop (loop->next, scop))\n-      return false;\n-\n-    return true;\n-  }\n-\n-  /* Return true when LOOP is a valid scop, that is a Static Control Part, a\n-     region of code that can be represented in the polyhedral model.  SCOP\n-     defines the region we analyse.  */\n-\n-  static bool\n-    loop_is_valid_scop (loop_p loop, sese_l scop)\n-  {\n-    if (!scop)\n-      return false;\n-\n-    if (!can_represent_loop (loop, scop))\n-      {\n-\tDEBUG_PRINT (dp << \"[scop-detection-fail] cannot represent loop_\"\n-\t\t        << loop->num << \"\\n\");\n-\treturn false;\n-      }\n-\n-    if (loop_body_is_valid_scop (loop, scop))\n-      {\n-\tDEBUG_PRINT (dp << \"[valid-scop] loop_\"\n-\t\t        << loop->num << \"is a valid scop.\\n\");\n-\treturn true;\n-      }\n-    return false;\n-  }\n-\n-  /* Return true when BEGIN is the preheader edge of a loop with a single exit\n-     END.  */\n-\n-  static bool\n-    region_has_one_loop (sese_l s)\n-  {\n-    edge begin = s.entry;\n-    edge end = s.exit;\n-    /* Check for a single perfectly nested loop.  */\n-    if (begin->dest->loop_father->inner)\n-      return false;\n-\n-    /* Otherwise, check whether we have adjacent loops.  */\n-    return begin->dest->loop_father == end->src->loop_father;\n-  }\n-\n-  /* Add to SCOPS a scop starting at SCOP_BEGIN and ending at SCOP_END.  */\n-\n-  void\n-    add_scop (sese_l s)\n-  {\n-    gcc_assert (s);\n+    }\n \n-    /* Do not add scops with only one loop.  */\n-    if (region_has_one_loop (s))\n-      {\n-\tDEBUG_PRINT (dp << \"\\n[scop-detection-fail] Discarding one loop SCoP\";\n-\t\t     print_sese (dump_file, s));\n-\treturn;\n-      }\n+  dom.release ();\n+}\n \n-    if (get_exit_bb (s.exit) == EXIT_BLOCK_PTR_FOR_FN (cfun))\n-      {\n-\tDEBUG_PRINT (dp << \"\\n[scop-detection-fail] \"\n-\t\t        << \"Discarding SCoP exiting to return\";\n-\t\t     print_sese (dump_file, s));\n-\treturn;\n-      }\n+/* Gather the basic blocks belonging to the SCOP.  */\n \n-    /* Remove all the scops which are subsumed by s.  */\n-    remove_subscops (s);\n+void\n+scop_detection::build_scop_bbs (scop_p scop)\n+{\n+  sbitmap visited = sbitmap_alloc (last_basic_block_for_fn (cfun));\n+  sese region = SCOP_REGION (scop);\n \n-    /* Replace this with split-intersecting scops.  */\n-    remove_intersecting_scops (s);\n+  bitmap_clear (visited);\n+  build_scop_bbs_1 (scop, visited, SESE_ENTRY_BB (region));\n+  sbitmap_free (visited);\n+}\n \n-    scops.safe_push (s);\n-    DEBUG_PRINT (dp << \"\\nAdding SCoP \"; print_sese (dump_file, s));\n-  }\n+/* Returns the number of pbbs that are in loops contained in SCOP.  */\n \n-  /* Return true when a statement in SCOP cannot be represented by Graphite.\n-     The assumptions are that L1 dominates L2, and SCOP->entry dominates L1.\n-     Limit the number of bbs between adjacent loops to\n-     PARAM_SCOP_MAX_NUM_BBS_BETWEEN_LOOPS.  */\n+int\n+scop_detection::nb_pbbs_in_loops (scop_p scop)\n+{\n+  int i;\n+  poly_bb_p pbb;\n+  int res = 0;\n \n-  static bool\n-    harmful_stmt_in_region (sese_l scop)\n-  {\n-    basic_block exit_bb = get_exit_bb (scop.exit);\n-    basic_block entry_bb = get_entry_bb (scop.entry);\n+  FOR_EACH_VEC_ELT (SCOP_BBS (scop), i, pbb)\n+    if (loop_in_sese_p (gbb_loop (PBB_BLACK_BOX (pbb)), SCOP_REGION (scop)))\n+      res++;\n \n-    DEBUG_PRINT (dp << \"\\n[checking-harmful-bbs] \";\n-\t\t print_sese (dump_file, scop));\n-    gcc_assert (dominated_by_p (CDI_DOMINATORS, exit_bb, entry_bb));\n+  return res;\n+}\n \n-    int depth = bb_dom_dfs_in (CDI_DOMINATORS, exit_bb)\n-      - bb_dom_dfs_in (CDI_DOMINATORS, entry_bb);\n+class sese_dom_walker : public dom_walker\n+{\n+public:\n+  sese_dom_walker (cdi_direction, sese);\n \n-    gcc_assert (depth >0);\n+  virtual void before_dom_children (basic_block);\n+  virtual void after_dom_children (basic_block);\n \n-    vec<basic_block> dom = get_dominated_to_depth (CDI_DOMINATORS,\n-\t\t\t\t\t\t   entry_bb, depth);\n-    int i;\n-    basic_block bb;\n-    FOR_EACH_VEC_ELT (dom, i, bb)\n-      {\n-\tDEBUG_PRINT (dp << \"\\nVisiting bb_\" << bb->index);\n+private:\n+  auto_vec<gimple *, 3> m_conditions, m_cases;\n+  sese m_region;\n+};\n+}\n+sese_dom_walker::sese_dom_walker (cdi_direction direction, sese region)\n+  : dom_walker (direction), m_region (region)\n+{\n+}\n \n-\t/* We don't want to analyze any bb outside sese.  */\n-\tif (!dominated_by_p (CDI_POST_DOMINATORS, bb, exit_bb))\n-\t  continue;\n+/* Call-back for dom_walk executed before visiting the dominated\n+   blocks.  */\n \n-\tif (harmful_stmt_in_bb (scop, bb))\n-\t  return true;\n-      }\n+void\n+sese_dom_walker::before_dom_children (basic_block bb)\n+{\n+  gimple_poly_bb_p gbb;\n+  gcond *stmt;\n \n-    return false;\n-  }\n+  if (!bb_in_sese_p (bb, m_region))\n+    return;\n \n-  /* Returns true if S1 subsumes/surrounds S2.  */\n-  static bool\n-    subsumes (sese_l s1, sese_l s2)\n-  {\n-    if (dominated_by_p (CDI_DOMINATORS, get_entry_bb (s2.entry),\n-\t\t\tget_entry_bb (s1.entry))\n-\t&& dominated_by_p (CDI_POST_DOMINATORS, get_entry_bb (s2.exit),\n-\t\t\t   get_entry_bb (s1.exit)))\n-      return true;\n-    return false;\n-  }\n+  stmt = single_pred_cond_non_loop_exit (bb);\n \n-  /* Remove a SCoP which is subsumed by S1.  */\n-  void\n-    remove_subscops (sese_l s1)\n-  {\n-    int j;\n-    sese_l s2 (0);\n-    FOR_EACH_VEC_ELT_REVERSE (scops, j, s2)\n-      {\n-\tif (subsumes (s1, s2))\n-\t  {\n-\t    DEBUG_PRINT (dp << \"\\nRemoving sub-SCoP\";\n-\t\t print_sese (dump_file, s2));\n-\t    scops.unordered_remove (j);\n-\t  }\n-      }\n-  }\n+  if (stmt)\n+    {\n+      edge e = single_pred_edge (bb);\n \n-  /* Returns true if S1 intersects with S2.  Since we already know that S1 does\n-     not subsume S2 or vice-versa, we only check for entry bbs.  */\n+      m_conditions.safe_push (stmt);\n \n-  static bool\n-    intersects (sese_l s1, sese_l s2)\n-  {\n-    if (dominated_by_p (CDI_DOMINATORS, get_entry_bb (s2.entry),\n-\t\t\tget_entry_bb (s1.entry))\n-\t&& !dominated_by_p (CDI_DOMINATORS, get_entry_bb (s2.entry),\n-\t\t\t    get_exit_bb (s1.exit)))\n-      return true;\n-    if ((s1.exit == s2.entry)\n-\t|| (s2.exit == s1.entry))\n-      return true;\n+      if (e->flags & EDGE_TRUE_VALUE)\n+\tm_cases.safe_push (stmt);\n+      else\n+\tm_cases.safe_push (NULL);\n+    }\n \n-    return false;\n-  }\n+  gbb = gbb_from_bb (bb);\n \n-  /* Remove one of the scops when it intersects with any other.  */\n+  if (gbb)\n+    {\n+      GBB_CONDITIONS (gbb) = m_conditions.copy ();\n+      GBB_CONDITION_CASES (gbb) = m_cases.copy ();\n+    }\n+}\n \n-  void\n-    remove_intersecting_scops (sese_l s1)\n-  {\n-    int j;\n-    sese_l s2 (0);\n-    FOR_EACH_VEC_ELT_REVERSE (scops, j, s2)\n-      {\n-\tif (intersects (s1, s2))\n-\t  {\n-\t    DEBUG_PRINT (dp << \"\\nRemoving intersecting SCoP\";\n-\t\tprint_sese (dump_file, s2);\n-\t\tdp << \"Intersects with:\";\n-\t\tprint_sese (dump_file, s1));\n-\t    scops.unordered_remove (j);\n-\t  }\n-      }\n-  }\n+/* Call-back for dom_walk executed after visiting the dominated\n+   blocks.  */\n \n- private:\n-  vec<sese_l> scops;\n-};\n+void\n+sese_dom_walker::after_dom_children (basic_block bb)\n+{\n+  if (!bb_in_sese_p (bb, m_region))\n+    return;\n \n-sese_l scop_builder::invalid_sese (0);\n+  if (single_pred_cond_non_loop_exit (bb))\n+    {\n+      m_conditions.pop ();\n+      m_cases.pop ();\n+    }\n+}\n \n /* Find Static Control Parts (SCoP) in the current function and pushes\n    them to SCOPS.  */\n@@ -1349,20 +1770,41 @@ build_scops (vec<scop_p> *scops)\n \n   canonicalize_loop_closed_ssa_form ();\n \n-  scop_builder sb;\n-  sb.build_scop_depth (scop_builder::invalid_sese, current_loops->tree_root);\n+  scop_detection sb;\n+  sb.build_scop_depth (scop_detection::invalid_sese, current_loops->tree_root);\n \n   /* Now create scops from the lightweight SESEs.  */\n   vec<sese_l> scops_l = sb.get_scops ();\n   int i;\n   sese_l s (0);\n   FOR_EACH_VEC_ELT (scops_l, i, s)\n+    {\n+      sese sese_reg = new_sese (s.entry, s.exit);\n+      scop_p scop = new_scop (sese_reg);\n+\n+      /* Do not optimize a scop containing only PBBs that do not belong\n+\t to any loops.  */\n+      if (sb.nb_pbbs_in_loops (scop) == 0)\n+\t{\n+\t  free_sese (sese_reg);\n+\t  free_scop (scop);\n+\t  continue;\n+\t}\n+\n+      scops->safe_push (scop);\n+    }\n+\n+  scop_p scop;\n+  FOR_EACH_VEC_ELT (*scops, i, scop)\n   {\n-    sese sese_reg = new_sese (s.entry, s.exit);\n-    scops->safe_push (new_scop (sese_reg));\n+    sb.build_scop_bbs (scop);\n+    sese region = SCOP_REGION (scop);\n+    build_sese_loop_nests (region);\n+    /* Record all conditions in REGION.  */\n+    sese_dom_walker (CDI_DOMINATORS, region).walk (cfun->cfg->x_entry_block_ptr);\n   }\n \n   DEBUG_PRINT (dp << \"number of SCoPs: \" << (scops ? scops->length () : 0););\n }\n \n-#endif  /* HAVE_isl */\n+#endif /* HAVE_isl */"}, {"sha": "0674689936e5edc8f65e42ec60302ef07fccd84b", "filename": "gcc/graphite-sese-to-poly.c", "status": "modified", "additions": 17, "deletions": 167, "changes": 184, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/076d564d3072837b2c008912634d5980f8a3c0e3/gcc%2Fgraphite-sese-to-poly.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/076d564d3072837b2c008912634d5980f8a3c0e3/gcc%2Fgraphite-sese-to-poly.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-sese-to-poly.c?ref=076d564d3072837b2c008912634d5980f8a3c0e3", "patch": "@@ -274,134 +274,6 @@ free_scops (vec<scop_p> scops)\n   scops.release ();\n }\n \n-/* Generates a polyhedral black box only if the bb contains interesting\n-   information.  */\n-\n-static gimple_poly_bb_p\n-try_generate_gimple_bb (scop_p scop, basic_block bb)\n-{\n-  vec<data_reference_p> drs;\n-  drs.create (5);\n-  sese region = SCOP_REGION (scop);\n-\n-  loop_p nest = outermost_loop_in_sese (region, bb);\n-  loop_p loop = bb->loop_father;\n-  if (!loop_in_sese_p (loop, region))\n-    loop = nest;\n-\n-  gimple_stmt_iterator gsi;\n-  for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n-    {\n-      gimple *stmt = gsi_stmt (gsi);\n-      if (is_gimple_debug (stmt))\n-\tcontinue;\n-\n-      graphite_find_data_references_in_stmt (nest, loop, stmt, &drs);\n-    }\n-\n-  return new_gimple_poly_bb (bb, drs);\n-}\n-\n-/* Returns true if all predecessors of BB, that are not dominated by BB, are\n-   marked in MAP.  The predecessors dominated by BB are loop latches and will\n-   be handled after BB.  */\n-\n-static bool\n-all_non_dominated_preds_marked_p (basic_block bb, sbitmap map)\n-{\n-  edge e;\n-  edge_iterator ei;\n-\n-  FOR_EACH_EDGE (e, ei, bb->preds)\n-    if (!bitmap_bit_p (map, e->src->index)\n-\t&& !dominated_by_p (CDI_DOMINATORS, e->src, bb))\n-\treturn false;\n-\n-  return true;\n-}\n-\n-/* Compare the depth of two basic_block's P1 and P2.  */\n-\n-static int\n-compare_bb_depths (const void *p1, const void *p2)\n-{\n-  const_basic_block const bb1 = *(const_basic_block const*)p1;\n-  const_basic_block const bb2 = *(const_basic_block const*)p2;\n-  int d1 = loop_depth (bb1->loop_father);\n-  int d2 = loop_depth (bb2->loop_father);\n-\n-  if (d1 < d2)\n-    return 1;\n-\n-  if (d1 > d2)\n-    return -1;\n-\n-  return 0;\n-}\n-\n-/* Sort the basic blocks from DOM such that the first are the ones at\n-   a deepest loop level.  */\n-\n-static void\n-graphite_sort_dominated_info (vec<basic_block> dom)\n-{\n-  dom.qsort (compare_bb_depths);\n-}\n-\n-/* Recursive helper function for build_scops_bbs.  */\n-\n-static void\n-build_scop_bbs_1 (scop_p scop, sbitmap visited, basic_block bb)\n-{\n-  sese region = SCOP_REGION (scop);\n-  vec<basic_block> dom;\n-  poly_bb_p pbb;\n-\n-  if (bitmap_bit_p (visited, bb->index)\n-      || !bb_in_sese_p (bb, region))\n-    return;\n-\n-  pbb = new_poly_bb (scop, try_generate_gimple_bb (scop, bb));\n-  SCOP_BBS (scop).safe_push (pbb);\n-  bitmap_set_bit (visited, bb->index);\n-\n-  dom = get_dominated_by (CDI_DOMINATORS, bb);\n-\n-  if (!dom.exists ())\n-    return;\n-\n-  graphite_sort_dominated_info (dom);\n-\n-  while (!dom.is_empty ())\n-    {\n-      int i;\n-      basic_block dom_bb;\n-\n-      FOR_EACH_VEC_ELT (dom, i, dom_bb)\n-\tif (all_non_dominated_preds_marked_p (dom_bb, visited))\n-\t  {\n-\t    build_scop_bbs_1 (scop, visited, dom_bb);\n-\t    dom.unordered_remove (i);\n-\t    break;\n-\t  }\n-    }\n-\n-  dom.release ();\n-}\n-\n-/* Gather the basic blocks belonging to the SCOP.  */\n-\n-static void\n-build_scop_bbs (scop_p scop)\n-{\n-  sbitmap visited = sbitmap_alloc (last_basic_block_for_fn (cfun));\n-  sese region = SCOP_REGION (scop);\n-\n-  bitmap_clear (visited);\n-  build_scop_bbs_1 (scop, visited, SESE_ENTRY_BB (region));\n-  sbitmap_free (visited);\n-}\n-\n /* Return an ISL identifier for the polyhedral basic block PBB.  */\n \n static isl_id *\n@@ -931,17 +803,24 @@ find_scop_parameters (scop_p scop)\n   nbp = sese_nb_params (region);\n   scop_set_nb_params (scop, nbp);\n   SESE_ADD_PARAMS (region) = false;\n+}\n \n-  {\n-    tree e;\n-    isl_space *space = isl_space_set_alloc (scop->ctx, nbp, 0);\n+/* Assign dimension for each parameter in SCOP.  */\n \n-    FOR_EACH_VEC_ELT (SESE_PARAMS (region), i, e)\n-      space = isl_space_set_dim_id (space, isl_dim_param, i,\n-\t\t\t\t    isl_id_for_ssa_name (scop, e));\n+static void\n+set_scop_parameter_dim (scop_p scop)\n+{\n+  sese region = SCOP_REGION (scop);\n+  unsigned nbp = sese_nb_params (region);\n+  isl_space *space = isl_space_set_alloc (scop->ctx, nbp, 0);\n \n-    scop->context = isl_set_universe (space);\n-  }\n+  unsigned i;\n+  tree e;\n+  FOR_EACH_VEC_ELT (SESE_PARAMS (region), i, e)\n+    space = isl_space_set_dim_id (space, isl_dim_param, i,\n+                                  isl_id_for_ssa_name (scop, e));\n+\n+  scop->context = isl_set_universe (space);\n }\n \n /* Builds the constraint polyhedra for LOOP in SCOP.  OUTER_PH gives\n@@ -2454,46 +2333,17 @@ rewrite_cross_bb_scalar_deps_out_of_ssa (scop_p scop)\n     }\n }\n \n-/* Returns the number of pbbs that are in loops contained in SCOP.  */\n-\n-static int\n-nb_pbbs_in_loops (scop_p scop)\n-{\n-  int i;\n-  poly_bb_p pbb;\n-  int res = 0;\n-\n-  FOR_EACH_VEC_ELT (SCOP_BBS (scop), i, pbb)\n-    if (loop_in_sese_p (gbb_loop (PBB_BLACK_BOX (pbb)), SCOP_REGION (scop)))\n-      res++;\n-\n-  return res;\n-}\n-\n /* Builds the polyhedral representation for a SESE region.  */\n \n void\n build_poly_scop (scop_p scop)\n {\n-  sese region = SCOP_REGION (scop);\n-  graphite_dim_t max_dim;\n-\n-  build_scop_bbs (scop);\n-\n-  /* Do not optimize a scop containing only PBBs that do not belong\n-     to any loops.  */\n-  if (nb_pbbs_in_loops (scop) == 0)\n-    return;\n-\n-  build_sese_loop_nests (region);\n-  /* Record all conditions in REGION.  */\n-  sese_dom_walker (CDI_DOMINATORS, region).walk (cfun->cfg->x_entry_block_ptr);\n   find_scop_parameters (scop);\n \n-  max_dim = PARAM_VALUE (PARAM_GRAPHITE_MAX_NB_SCOP_PARAMS);\n+  graphite_dim_t max_dim = PARAM_VALUE (PARAM_GRAPHITE_MAX_NB_SCOP_PARAMS);\n   if (scop_nb_params (scop) > max_dim)\n     return;\n-\n+  set_scop_parameter_dim (scop);\n   build_scop_iteration_domain (scop);\n   build_scop_context (scop);\n   add_conditions_to_constraints (scop);"}]}