{"sha": "3521ba8b2e5c974c021853b2b829313029b4eda8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzUyMWJhOGIyZTVjOTc0YzAyMTg1M2IyYjgyOTMxMzAyOWI0ZWRhOA==", "commit": {"author": {"name": "Alan Modra", "email": "amodra@gcc.gnu.org", "date": "2013-11-17T14:35:08Z"}, "committer": {"name": "Alan Modra", "email": "amodra@gcc.gnu.org", "date": "2013-11-17T14:35:08Z"}, "message": "PowerPC64 ELFv2 support\n\nPowerPC64 ELFv2 support\n\t* src/powerpc/ffitarget.h: Import from upstream.\n\t* src/powerpc/ffi.c: Likewise.\n\t* src/powerpc/linux64.S: Likewise.\n\t* src/powerpc/linux64_closure.S: Likewise.\n\t* doc/libffi.texi: Likewise.\n\t* testsuite/libffi.call/cls_double_va.c: Likewise.\n\t* testsuite/libffi.call/cls_longdouble_va.c: Likewise.\n\nFrom-SVN: r204917", "tree": {"sha": "dd3c7417bef8e7912052a55fffdfbd91018418c1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dd3c7417bef8e7912052a55fffdfbd91018418c1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3521ba8b2e5c974c021853b2b829313029b4eda8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3521ba8b2e5c974c021853b2b829313029b4eda8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3521ba8b2e5c974c021853b2b829313029b4eda8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3521ba8b2e5c974c021853b2b829313029b4eda8/comments", "author": null, "committer": null, "parents": [{"sha": "abe6cd5d35c0ec893ffff056f46f3729a3c8bf52", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/abe6cd5d35c0ec893ffff056f46f3729a3c8bf52", "html_url": "https://github.com/Rust-GCC/gccrs/commit/abe6cd5d35c0ec893ffff056f46f3729a3c8bf52"}], "stats": {"total": 1210, "additions": 860, "deletions": 350}, "files": [{"sha": "ce3a6c5797ed823c09d36fdff87ec6ede701dae8", "filename": "libffi/ChangeLog", "status": "modified", "additions": 109, "deletions": 99, "changes": 208, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3521ba8b2e5c974c021853b2b829313029b4eda8/libffi%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3521ba8b2e5c974c021853b2b829313029b4eda8/libffi%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2FChangeLog?ref=3521ba8b2e5c974c021853b2b829313029b4eda8", "patch": "@@ -1,3 +1,13 @@\n+2013-11-18  Alan Modra  <amodra@gmail.com>\n+\n+\t* src/powerpc/ffitarget.h: Import from upstream.\n+\t* src/powerpc/ffi.c: Likewise.\n+\t* src/powerpc/linux64.S: Likewise.\n+\t* src/powerpc/linux64_closure.S: Likewise.\n+\t* doc/libffi.texi: Likewise.\n+\t* testsuite/libffi.call/cls_double_va.c: Likewise.\n+\t* testsuite/libffi.call/cls_longdouble_va.c: Likewise.\n+\n 2013-09-20  Alan Modra  <amodra@gmail.com>\n \n \t* configure: Regenerate.\n@@ -88,41 +98,41 @@\n 2012-10-30  James Greenhalgh  <james.greenhalgh at arm.com>\n             Marcus Shawcroft  <marcus.shawcroft at arm.com>\n \n-        * README: Add details of aarch64 port.\n-        * src/aarch64/ffi.c: New.\n-        * src/aarch64/ffitarget.h: Likewise.\n-        * src/aarch64/sysv.S: Likewise.\n+\t* README: Add details of aarch64 port.\n+\t* src/aarch64/ffi.c: New.\n+\t* src/aarch64/ffitarget.h: Likewise.\n+\t* src/aarch64/sysv.S: Likewise.\n \t* Makefile.am: Support aarch64.\n \t* configure.ac: Support aarch64.\n \t* Makefile.in, configure: Rebuilt.\n \n 2012-10-30  James Greenhalgh  <james.greenhalgh at arm.com>\n             Marcus Shawcroft  <marcus.shawcroft at arm.com>\n \n-        * testsuite/lib/libffi.exp: Add support for aarch64.\n-        * testsuite/libffi.call/cls_struct_va1.c: New.\n-        * testsuite/libffi.call/cls_uchar_va.c: Likewise.\n-        * testsuite/libffi.call/cls_uint_va.c: Likewise.\n-        * testsuite/libffi.call/cls_ulong_va.c: Likewise.\n-        * testsuite/libffi.call/cls_ushort_va.c: Likewise.\n-        * testsuite/libffi.call/nested_struct11.c: Likewise.\n-        * testsuite/libffi.call/uninitialized.c: Likewise.\n-        * testsuite/libffi.call/va_1.c: Likewise.\n-        * testsuite/libffi.call/va_struct1.c: Likewise.\n-        * testsuite/libffi.call/va_struct2.c: Likewise.\n-        * testsuite/libffi.call/va_struct3.c: Likewise.\n+\t* testsuite/lib/libffi.exp: Add support for aarch64.\n+\t* testsuite/libffi.call/cls_struct_va1.c: New.\n+\t* testsuite/libffi.call/cls_uchar_va.c: Likewise.\n+\t* testsuite/libffi.call/cls_uint_va.c: Likewise.\n+\t* testsuite/libffi.call/cls_ulong_va.c: Likewise.\n+\t* testsuite/libffi.call/cls_ushort_va.c: Likewise.\n+\t* testsuite/libffi.call/nested_struct11.c: Likewise.\n+\t* testsuite/libffi.call/uninitialized.c: Likewise.\n+\t* testsuite/libffi.call/va_1.c: Likewise.\n+\t* testsuite/libffi.call/va_struct1.c: Likewise.\n+\t* testsuite/libffi.call/va_struct2.c: Likewise.\n+\t* testsuite/libffi.call/va_struct3.c: Likewise.\n \n 2012-10-12  Walter Lee  <walt@tilera.com>\n \n-        * Makefile.am: Add TILE-Gx/TILEPro support.\n-        * configure.ac: Likewise.\n-        * Makefile.in: Regenerate.\n-        * configure: Likewise.\n-        * src/prep_cif.c (ffi_prep_cif_core): Handle TILE-Gx/TILEPro.\n-        * src/tile: New directory.\n-        * src/tile/ffi.c: New file.\n-        * src/tile/ffitarget.h: Ditto.\n-        * src/tile/tile.S: Ditto.\n+\t* Makefile.am: Add TILE-Gx/TILEPro support.\n+\t* configure.ac: Likewise.\n+\t* Makefile.in: Regenerate.\n+\t* configure: Likewise.\n+\t* src/prep_cif.c (ffi_prep_cif_core): Handle TILE-Gx/TILEPro.\n+\t* src/tile: New directory.\n+\t* src/tile/ffi.c: New file.\n+\t* src/tile/ffitarget.h: Ditto.\n+\t* src/tile/tile.S: Ditto.\n \n 2012-10-12  Matthias Klose  <doko@ubuntu.com>\n \n@@ -623,7 +633,7 @@\n \n 2011-07-11  Andrew Haley  <aph@redhat.com>\n \n-        * src/arm/ffi.c (FFI_INIT_TRAMPOLINE): Clear icache.\n+\t* src/arm/ffi.c (FFI_INIT_TRAMPOLINE): Clear icache.\n \n 2011-06-29  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n \n@@ -923,10 +933,10 @@\n \n 2010-08-05  Dan Witte  <dwitte@mozilla.com>\n \n-        * Makefile.am: Pass FFI_DEBUG define to msvcc.sh for linking to the\n-        debug CRT when --enable-debug is given.\n-        * configure.ac: Define it.\n-        * msvcc.sh: Translate -g and -DFFI_DEBUG appropriately.\n+\t* Makefile.am: Pass FFI_DEBUG define to msvcc.sh for linking to the\n+\tdebug CRT when --enable-debug is given.\n+\t* configure.ac: Define it.\n+\t* msvcc.sh: Translate -g and -DFFI_DEBUG appropriately.\n \n 2010-08-04  Dan Witte  <dwitte@mozilla.com>\n \n@@ -944,7 +954,7 @@\n \n \t* src/*/ffitarget.h: Make FFI_LAST_ABI one past the last valid ABI.\n \t* src/prep_cif.c: Fix ABI assertion.\n-        * src/cris/ffi.c: Ditto.\n+\t* src/cris/ffi.c: Ditto.\n \n 2010-07-10  Evan Phoenix  <evan@fallingsnow.net>\n \n@@ -1546,74 +1556,74 @@\n \ttestsuite/libffi.call/cls_2byte.c,\n \ttestsuite/libffi.call/cls_3_1byte.c,\n \ttestsuite/libffi.call/cls_3byte1.c,\n- \ttestsuite/libffi.call/cls_3byte2.c,\n- \ttestsuite/libffi.call/cls_4_1byte.c,\n- \ttestsuite/libffi.call/cls_4byte.c,\n- \ttestsuite/libffi.call/cls_5_1_byte.c,\n- \ttestsuite/libffi.call/cls_5byte.c,\n- \ttestsuite/libffi.call/cls_64byte.c,\n- \ttestsuite/libffi.call/cls_6_1_byte.c,\n- \ttestsuite/libffi.call/cls_6byte.c,\n- \ttestsuite/libffi.call/cls_7_1_byte.c,\n- \ttestsuite/libffi.call/cls_7byte.c,\n- \ttestsuite/libffi.call/cls_8byte.c,\n- \ttestsuite/libffi.call/cls_9byte1.c,\n- \ttestsuite/libffi.call/cls_9byte2.c,\n- \ttestsuite/libffi.call/cls_align_double.c,\n- \ttestsuite/libffi.call/cls_align_float.c,\n- \ttestsuite/libffi.call/cls_align_longdouble.c,\n- \ttestsuite/libffi.call/cls_align_longdouble_split.c,\n- \ttestsuite/libffi.call/cls_align_longdouble_split2.c,\n- \ttestsuite/libffi.call/cls_align_pointer.c,\n- \ttestsuite/libffi.call/cls_align_sint16.c,\n- \ttestsuite/libffi.call/cls_align_sint32.c,\n- \ttestsuite/libffi.call/cls_align_sint64.c,\n- \ttestsuite/libffi.call/cls_align_uint16.c,\n- \ttestsuite/libffi.call/cls_align_uint32.c,\n- \ttestsuite/libffi.call/cls_align_uint64.c,\n- \ttestsuite/libffi.call/cls_dbls_struct.c,\n- \ttestsuite/libffi.call/cls_double.c,\n- \ttestsuite/libffi.call/cls_double_va.c,\n- \ttestsuite/libffi.call/cls_float.c,\n- \ttestsuite/libffi.call/cls_longdouble.c,\n- \ttestsuite/libffi.call/cls_longdouble_va.c,\n- \ttestsuite/libffi.call/cls_multi_schar.c,\n- \ttestsuite/libffi.call/cls_multi_sshort.c,\n- \ttestsuite/libffi.call/cls_multi_sshortchar.c,\n- \ttestsuite/libffi.call/cls_multi_uchar.c,\n- \ttestsuite/libffi.call/cls_multi_ushort.c,\n- \ttestsuite/libffi.call/cls_multi_ushortchar.c,\n- \ttestsuite/libffi.call/cls_pointer.c,\n- \ttestsuite/libffi.call/cls_pointer_stack.c,\n- \ttestsuite/libffi.call/cls_schar.c,\n- \ttestsuite/libffi.call/cls_sint.c,\n- \ttestsuite/libffi.call/cls_sshort.c,\n- \ttestsuite/libffi.call/cls_uchar.c,\n- \ttestsuite/libffi.call/cls_uint.c,\n- \ttestsuite/libffi.call/cls_ulonglong.c,\n- \ttestsuite/libffi.call/cls_ushort.c,\n- \ttestsuite/libffi.call/err_bad_abi.c,\n- \ttestsuite/libffi.call/err_bad_typedef.c,\n- \ttestsuite/libffi.call/float2.c,\n- \ttestsuite/libffi.call/huge_struct.c,\n- \ttestsuite/libffi.call/nested_struct.c,\n- \ttestsuite/libffi.call/nested_struct1.c,\n- \ttestsuite/libffi.call/nested_struct10.c,\n- \ttestsuite/libffi.call/nested_struct2.c,\n- \ttestsuite/libffi.call/nested_struct3.c,\n- \ttestsuite/libffi.call/nested_struct4.c,\n- \ttestsuite/libffi.call/nested_struct5.c,\n- \ttestsuite/libffi.call/nested_struct6.c,\n- \ttestsuite/libffi.call/nested_struct7.c,\n- \ttestsuite/libffi.call/nested_struct8.c,\n- \ttestsuite/libffi.call/nested_struct9.c,\n- \ttestsuite/libffi.call/problem1.c,\n- \ttestsuite/libffi.call/return_ldl.c,\n- \ttestsuite/libffi.call/return_ll1.c,\n- \ttestsuite/libffi.call/stret_large.c,\n- \ttestsuite/libffi.call/stret_large2.c,\n- \ttestsuite/libffi.call/stret_medium.c,\n- \ttestsuite/libffi.call/stret_medium2.c,\n+\ttestsuite/libffi.call/cls_3byte2.c,\n+\ttestsuite/libffi.call/cls_4_1byte.c,\n+\ttestsuite/libffi.call/cls_4byte.c,\n+\ttestsuite/libffi.call/cls_5_1_byte.c,\n+\ttestsuite/libffi.call/cls_5byte.c,\n+\ttestsuite/libffi.call/cls_64byte.c,\n+\ttestsuite/libffi.call/cls_6_1_byte.c,\n+\ttestsuite/libffi.call/cls_6byte.c,\n+\ttestsuite/libffi.call/cls_7_1_byte.c,\n+\ttestsuite/libffi.call/cls_7byte.c,\n+\ttestsuite/libffi.call/cls_8byte.c,\n+\ttestsuite/libffi.call/cls_9byte1.c,\n+\ttestsuite/libffi.call/cls_9byte2.c,\n+\ttestsuite/libffi.call/cls_align_double.c,\n+\ttestsuite/libffi.call/cls_align_float.c,\n+\ttestsuite/libffi.call/cls_align_longdouble.c,\n+\ttestsuite/libffi.call/cls_align_longdouble_split.c,\n+\ttestsuite/libffi.call/cls_align_longdouble_split2.c,\n+\ttestsuite/libffi.call/cls_align_pointer.c,\n+\ttestsuite/libffi.call/cls_align_sint16.c,\n+\ttestsuite/libffi.call/cls_align_sint32.c,\n+\ttestsuite/libffi.call/cls_align_sint64.c,\n+\ttestsuite/libffi.call/cls_align_uint16.c,\n+\ttestsuite/libffi.call/cls_align_uint32.c,\n+\ttestsuite/libffi.call/cls_align_uint64.c,\n+\ttestsuite/libffi.call/cls_dbls_struct.c,\n+\ttestsuite/libffi.call/cls_double.c,\n+\ttestsuite/libffi.call/cls_double_va.c,\n+\ttestsuite/libffi.call/cls_float.c,\n+\ttestsuite/libffi.call/cls_longdouble.c,\n+\ttestsuite/libffi.call/cls_longdouble_va.c,\n+\ttestsuite/libffi.call/cls_multi_schar.c,\n+\ttestsuite/libffi.call/cls_multi_sshort.c,\n+\ttestsuite/libffi.call/cls_multi_sshortchar.c,\n+\ttestsuite/libffi.call/cls_multi_uchar.c,\n+\ttestsuite/libffi.call/cls_multi_ushort.c,\n+\ttestsuite/libffi.call/cls_multi_ushortchar.c,\n+\ttestsuite/libffi.call/cls_pointer.c,\n+\ttestsuite/libffi.call/cls_pointer_stack.c,\n+\ttestsuite/libffi.call/cls_schar.c,\n+\ttestsuite/libffi.call/cls_sint.c,\n+\ttestsuite/libffi.call/cls_sshort.c,\n+\ttestsuite/libffi.call/cls_uchar.c,\n+\ttestsuite/libffi.call/cls_uint.c,\n+\ttestsuite/libffi.call/cls_ulonglong.c,\n+\ttestsuite/libffi.call/cls_ushort.c,\n+\ttestsuite/libffi.call/err_bad_abi.c,\n+\ttestsuite/libffi.call/err_bad_typedef.c,\n+\ttestsuite/libffi.call/float2.c,\n+\ttestsuite/libffi.call/huge_struct.c,\n+\ttestsuite/libffi.call/nested_struct.c,\n+\ttestsuite/libffi.call/nested_struct1.c,\n+\ttestsuite/libffi.call/nested_struct10.c,\n+\ttestsuite/libffi.call/nested_struct2.c,\n+\ttestsuite/libffi.call/nested_struct3.c,\n+\ttestsuite/libffi.call/nested_struct4.c,\n+\ttestsuite/libffi.call/nested_struct5.c,\n+\ttestsuite/libffi.call/nested_struct6.c,\n+\ttestsuite/libffi.call/nested_struct7.c,\n+\ttestsuite/libffi.call/nested_struct8.c,\n+\ttestsuite/libffi.call/nested_struct9.c,\n+\ttestsuite/libffi.call/problem1.c,\n+\ttestsuite/libffi.call/return_ldl.c,\n+\ttestsuite/libffi.call/return_ll1.c,\n+\ttestsuite/libffi.call/stret_large.c,\n+\ttestsuite/libffi.call/stret_large2.c,\n+\ttestsuite/libffi.call/stret_medium.c,\n+\ttestsuite/libffi.call/stret_medium2.c,\n \ttestsuite/libffi.special/unwindtest.cc: use ffi_closure_alloc instead\n \tof checking for MMAP.  Use intptr_t instead of long casts.\n "}, {"sha": "57dae0b84cd8df758795200d73f6f3c37b2606c4", "filename": "libffi/doc/libffi.texi", "status": "modified", "additions": 17, "deletions": 14, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3521ba8b2e5c974c021853b2b829313029b4eda8/libffi%2Fdoc%2Flibffi.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3521ba8b2e5c974c021853b2b829313029b4eda8/libffi%2Fdoc%2Flibffi.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fdoc%2Flibffi.texi?ref=3521ba8b2e5c974c021853b2b829313029b4eda8", "patch": "@@ -184,11 +184,11 @@ This calls the function @var{fn} according to the description given in\n \n @var{rvalue} is a pointer to a chunk of memory that will hold the\n result of the function call.  This must be large enough to hold the\n-result and must be suitably aligned; it is the caller's responsibility\n+result, no smaller than the system register size (generally 32 or 64\n+bits), and must be suitably aligned; it is the caller's responsibility\n to ensure this.  If @var{cif} declares that the function returns\n @code{void} (using @code{ffi_type_void}), then @var{rvalue} is\n-ignored.  If @var{rvalue} is @samp{NULL}, then the return value is\n-discarded.\n+ignored.\n \n @var{avalues} is a vector of @code{void *} pointers that point to the\n memory locations holding the argument values for a call.  If @var{cif}\n@@ -214,15 +214,15 @@ int main()\n   ffi_type *args[1];\n   void *values[1];\n   char *s;\n-  int rc;\n+  ffi_arg rc;\n   \n   /* Initialize the argument info vectors */    \n   args[0] = &ffi_type_pointer;\n   values[0] = &s;\n   \n   /* Initialize the cif */\n   if (ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1, \n-\t\t       &ffi_type_uint, args) == FFI_OK)\n+\t\t       &ffi_type_sint, args) == FFI_OK)\n     @{\n       s = \"Hello World!\";\n       ffi_call(&cif, puts, &rc, values);\n@@ -360,7 +360,7 @@ You must first describe the structure to @samp{libffi} by creating a\n new @code{ffi_type} object for it.\n \n @tindex ffi_type\n-@deftp ffi_type\n+@deftp {Data type} ffi_type\n The @code{ffi_type} has the following members:\n @table @code\n @item size_t size\n@@ -414,6 +414,7 @@ Here is the corresponding code to describe this struct to\n       int i;\n \n       tm_type.size = tm_type.alignment = 0;\n+      tm_type.type = FFI_TYPE_STRUCT;\n       tm_type.elements = &tm_type_elements;\n     \n       for (i = 0; i < 9; i++)\n@@ -540,21 +541,23 @@ A trivial example that creates a new @code{puts} by binding\n #include <ffi.h>\n \n /* Acts like puts with the file given at time of enclosure. */\n-void puts_binding(ffi_cif *cif, unsigned int *ret, void* args[], \n-                  FILE *stream)\n+void puts_binding(ffi_cif *cif, void *ret, void* args[],\n+                  void *stream)\n @{\n-  *ret = fputs(*(char **)args[0], stream);\n+  *(ffi_arg *)ret = fputs(*(char **)args[0], (FILE *)stream);\n @}\n \n+typedef int (*puts_t)(char *);\n+\n int main()\n @{\n   ffi_cif cif;\n   ffi_type *args[1];\n   ffi_closure *closure;\n \n-  int (*bound_puts)(char *);\n+  void *bound_puts;\n   int rc;\n-  \n+\n   /* Allocate closure and bound_puts */\n   closure = ffi_closure_alloc(sizeof(ffi_closure), &bound_puts);\n \n@@ -565,13 +568,13 @@ int main()\n \n       /* Initialize the cif */\n       if (ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1,\n-                       &ffi_type_uint, args) == FFI_OK)\n+                       &ffi_type_sint, args) == FFI_OK)\n         @{\n           /* Initialize the closure, setting stream to stdout */\n-          if (ffi_prep_closure_loc(closure, &cif, puts_binding, \n+          if (ffi_prep_closure_loc(closure, &cif, puts_binding,\n                                    stdout, bound_puts) == FFI_OK)\n             @{\n-              rc = bound_puts(\"Hello World!\");\n+              rc = ((puts_t)bound_puts)(\"Hello World!\");\n               /* rc now holds the result of the call to fputs */\n             @}\n         @}"}, {"sha": "feb21447b64f5492caef02374ab0da6037e66622", "filename": "libffi/src/powerpc/ffi.c", "status": "modified", "additions": 416, "deletions": 92, "changes": 508, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3521ba8b2e5c974c021853b2b829313029b4eda8/libffi%2Fsrc%2Fpowerpc%2Fffi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3521ba8b2e5c974c021853b2b829313029b4eda8/libffi%2Fsrc%2Fpowerpc%2Fffi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fpowerpc%2Fffi.c?ref=3521ba8b2e5c974c021853b2b829313029b4eda8", "patch": "@@ -49,6 +49,7 @@ enum {\n   FLAG_RETURNS_128BITS  = 1 << (31-27), /* cr6  */\n \n   FLAG_ARG_NEEDS_COPY   = 1 << (31- 7),\n+  FLAG_ARG_NEEDS_PSAVE  = FLAG_ARG_NEEDS_COPY, /* Used by ELFv2 */\n #ifndef __NO_FPRS__\n   FLAG_FP_ARGUMENTS     = 1 << (31- 6), /* cr1.eq; specified by ABI */\n #endif\n@@ -369,7 +370,13 @@ ffi_prep_args_SYSV (extended_cif *ecif, unsigned *const stack)\n   /* Check that we didn't overrun the stack...  */\n   FFI_ASSERT (copy_space.c >= next_arg.c);\n   FFI_ASSERT (gpr_base.u <= stacktop.u - ASM_NEEDS_REGISTERS);\n+  /* The assert below is testing that the number of integer arguments agrees\n+     with the number found in ffi_prep_cif_machdep().  However, intarg_count\n+     is incremented whenever we place an FP arg on the stack, so account for\n+     that before our assert test.  */\n #ifndef __NO_FPRS__\n+  if (fparg_count > NUM_FPR_ARG_REGISTERS)\n+    intarg_count -= fparg_count - NUM_FPR_ARG_REGISTERS;\n   FFI_ASSERT (fpr_base.u\n \t      <= stacktop.u - ASM_NEEDS_REGISTERS - NUM_GPR_ARG_REGISTERS);\n #endif\n@@ -383,6 +390,45 @@ enum {\n };\n enum { ASM_NEEDS_REGISTERS64 = 4 };\n \n+#if _CALL_ELF == 2\n+static unsigned int\n+discover_homogeneous_aggregate (const ffi_type *t, unsigned int *elnum)\n+{\n+  switch (t->type)\n+    {\n+    case FFI_TYPE_FLOAT:\n+    case FFI_TYPE_DOUBLE:\n+      *elnum = 1;\n+      return (int) t->type;\n+\n+    case FFI_TYPE_STRUCT:;\n+      {\n+\tunsigned int base_elt = 0, total_elnum = 0;\n+\tffi_type **el = t->elements;\n+\twhile (*el)\n+\t  {\n+\t    unsigned int el_elt, el_elnum = 0;\n+\t    el_elt = discover_homogeneous_aggregate (*el, &el_elnum);\n+\t    if (el_elt == 0\n+\t\t|| (base_elt && base_elt != el_elt))\n+\t      return 0;\n+\t    base_elt = el_elt;\n+\t    total_elnum += el_elnum;\n+\t    if (total_elnum > 8)\n+\t      return 0;\n+\t    el++;\n+\t  }\n+\t*elnum = total_elnum;\n+\treturn base_elt;\n+      }\n+\n+    default:\n+      return 0;\n+    }\n+}\n+#endif\n+\n+\n /* ffi_prep_args64 is called by the assembly routine once stack space\n    has been allocated for the function's arguments.\n \n@@ -428,6 +474,7 @@ ffi_prep_args64 (extended_cif *ecif, unsigned long *const stack)\n     unsigned long *ul;\n     float *f;\n     double *d;\n+    size_t p;\n   } valp;\n \n   /* 'stacktop' points at the previous backchain pointer.  */\n@@ -443,9 +490,9 @@ ffi_prep_args64 (extended_cif *ecif, unsigned long *const stack)\n   /* 'fpr_base' points at the space for fpr3, and grows upwards as\n      we use FPR registers.  */\n   valp fpr_base;\n-  int fparg_count;\n+  unsigned int fparg_count;\n \n-  int i, words;\n+  unsigned int i, words, nargs, nfixedargs;\n   ffi_type **ptr;\n   double double_tmp;\n   union {\n@@ -462,11 +509,18 @@ ffi_prep_args64 (extended_cif *ecif, unsigned long *const stack)\n     double **d;\n   } p_argv;\n   unsigned long gprvalue;\n+#ifdef __STRUCT_PARM_ALIGN__\n+  unsigned long align;\n+#endif\n \n   stacktop.c = (char *) stack + bytes;\n   gpr_base.ul = stacktop.ul - ASM_NEEDS_REGISTERS64 - NUM_GPR_ARG_REGISTERS64;\n   gpr_end.ul = gpr_base.ul + NUM_GPR_ARG_REGISTERS64;\n+#if _CALL_ELF == 2\n+  rest.ul = stack + 4 + NUM_GPR_ARG_REGISTERS64;\n+#else\n   rest.ul = stack + 6 + NUM_GPR_ARG_REGISTERS64;\n+#endif\n   fpr_base.d = gpr_base.d - NUM_FPR_ARG_REGISTERS64;\n   fparg_count = 0;\n   next_arg.ul = gpr_base.ul;\n@@ -482,78 +536,144 @@ ffi_prep_args64 (extended_cif *ecif, unsigned long *const stack)\n \n   /* Now for the arguments.  */\n   p_argv.v = ecif->avalue;\n-  for (ptr = ecif->cif->arg_types, i = ecif->cif->nargs;\n-       i > 0;\n-       i--, ptr++, p_argv.v++)\n+  nargs = ecif->cif->nargs;\n+  nfixedargs = ecif->cif->nfixedargs;\n+  for (ptr = ecif->cif->arg_types, i = 0;\n+       i < nargs;\n+       i++, ptr++, p_argv.v++)\n     {\n+      unsigned int elt, elnum;\n+\n       switch ((*ptr)->type)\n \t{\n \tcase FFI_TYPE_FLOAT:\n \t  double_tmp = **p_argv.f;\n-\t  *next_arg.f = (float) double_tmp;\n+\t  if (fparg_count < NUM_FPR_ARG_REGISTERS64 && i < nfixedargs)\n+\t    *fpr_base.d++ = double_tmp;\n+\t  else\n+\t    *next_arg.f = (float) double_tmp;\n \t  if (++next_arg.ul == gpr_end.ul)\n \t    next_arg.ul = rest.ul;\n-\t  if (fparg_count < NUM_FPR_ARG_REGISTERS64)\n-\t    *fpr_base.d++ = double_tmp;\n \t  fparg_count++;\n \t  FFI_ASSERT (flags & FLAG_FP_ARGUMENTS);\n \t  break;\n \n \tcase FFI_TYPE_DOUBLE:\n \t  double_tmp = **p_argv.d;\n-\t  *next_arg.d = double_tmp;\n+\t  if (fparg_count < NUM_FPR_ARG_REGISTERS64 && i < nfixedargs)\n+\t    *fpr_base.d++ = double_tmp;\n+\t  else\n+\t    *next_arg.d = double_tmp;\n \t  if (++next_arg.ul == gpr_end.ul)\n \t    next_arg.ul = rest.ul;\n-\t  if (fparg_count < NUM_FPR_ARG_REGISTERS64)\n-\t    *fpr_base.d++ = double_tmp;\n \t  fparg_count++;\n \t  FFI_ASSERT (flags & FLAG_FP_ARGUMENTS);\n \t  break;\n \n #if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n \tcase FFI_TYPE_LONGDOUBLE:\n \t  double_tmp = (*p_argv.d)[0];\n-\t  *next_arg.d = double_tmp;\n+\t  if (fparg_count < NUM_FPR_ARG_REGISTERS64 && i < nfixedargs)\n+\t    *fpr_base.d++ = double_tmp;\n+\t  else\n+\t    *next_arg.d = double_tmp;\n \t  if (++next_arg.ul == gpr_end.ul)\n \t    next_arg.ul = rest.ul;\n-\t  if (fparg_count < NUM_FPR_ARG_REGISTERS64)\n-\t    *fpr_base.d++ = double_tmp;\n \t  fparg_count++;\n \t  double_tmp = (*p_argv.d)[1];\n-\t  *next_arg.d = double_tmp;\n+\t  if (fparg_count < NUM_FPR_ARG_REGISTERS64 && i < nfixedargs)\n+\t    *fpr_base.d++ = double_tmp;\n+\t  else\n+\t    *next_arg.d = double_tmp;\n \t  if (++next_arg.ul == gpr_end.ul)\n \t    next_arg.ul = rest.ul;\n-\t  if (fparg_count < NUM_FPR_ARG_REGISTERS64)\n-\t    *fpr_base.d++ = double_tmp;\n \t  fparg_count++;\n \t  FFI_ASSERT (__LDBL_MANT_DIG__ == 106);\n \t  FFI_ASSERT (flags & FLAG_FP_ARGUMENTS);\n \t  break;\n #endif\n \n \tcase FFI_TYPE_STRUCT:\n-\t  words = ((*ptr)->size + 7) / 8;\n-\t  if (next_arg.ul >= gpr_base.ul && next_arg.ul + words > gpr_end.ul)\n+#ifdef __STRUCT_PARM_ALIGN__\n+\t  align = (*ptr)->alignment;\n+\t  if (align > __STRUCT_PARM_ALIGN__)\n+\t    align = __STRUCT_PARM_ALIGN__;\n+\t  if (align > 1)\n+\t    next_arg.p = ALIGN (next_arg.p, align);\n+#endif\n+\t  elt = 0;\n+#if _CALL_ELF == 2\n+\t  elt = discover_homogeneous_aggregate (*ptr, &elnum);\n+#endif\n+\t  if (elt)\n \t    {\n-\t      size_t first = gpr_end.c - next_arg.c;\n-\t      memcpy (next_arg.c, *p_argv.c, first);\n-\t      memcpy (rest.c, *p_argv.c + first, (*ptr)->size - first);\n-\t      next_arg.c = rest.c + words * 8 - first;\n+\t      union {\n+\t\tvoid *v;\n+\t\tfloat *f;\n+\t\tdouble *d;\n+\t      } arg;\n+\n+\t      arg.v = *p_argv.v;\n+\t      if (elt == FFI_TYPE_FLOAT)\n+\t\t{\n+\t\t  do\n+\t\t    {\n+\t\t      double_tmp = *arg.f++;\n+\t\t      if (fparg_count < NUM_FPR_ARG_REGISTERS64\n+\t\t\t  && i < nfixedargs)\n+\t\t\t*fpr_base.d++ = double_tmp;\n+\t\t      else\n+\t\t\t*next_arg.f = (float) double_tmp;\n+\t\t      if (++next_arg.f == gpr_end.f)\n+\t\t\tnext_arg.f = rest.f;\n+\t\t      fparg_count++;\n+\t\t    }\n+\t\t  while (--elnum != 0);\n+\t\t  if ((next_arg.p & 3) != 0)\n+\t\t    {\n+\t\t      if (++next_arg.f == gpr_end.f)\n+\t\t\tnext_arg.f = rest.f;\n+\t\t    }\n+\t\t}\n+\t      else\n+\t\tdo\n+\t\t  {\n+\t\t    double_tmp = *arg.d++;\n+\t\t    if (fparg_count < NUM_FPR_ARG_REGISTERS64 && i < nfixedargs)\n+\t\t      *fpr_base.d++ = double_tmp;\n+\t\t    else\n+\t\t      *next_arg.d = double_tmp;\n+\t\t    if (++next_arg.d == gpr_end.d)\n+\t\t      next_arg.d = rest.d;\n+\t\t    fparg_count++;\n+\t\t  }\n+\t\twhile (--elnum != 0);\n \t    }\n \t  else\n \t    {\n-\t      char *where = next_arg.c;\n+\t      words = ((*ptr)->size + 7) / 8;\n+\t      if (next_arg.ul >= gpr_base.ul && next_arg.ul + words > gpr_end.ul)\n+\t\t{\n+\t\t  size_t first = gpr_end.c - next_arg.c;\n+\t\t  memcpy (next_arg.c, *p_argv.c, first);\n+\t\t  memcpy (rest.c, *p_argv.c + first, (*ptr)->size - first);\n+\t\t  next_arg.c = rest.c + words * 8 - first;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  char *where = next_arg.c;\n \n #ifndef __LITTLE_ENDIAN__\n-\t      /* Structures with size less than eight bytes are passed\n-\t\t left-padded.  */\n-\t      if ((*ptr)->size < 8)\n-\t\twhere += 8 - (*ptr)->size;\n+\t\t  /* Structures with size less than eight bytes are passed\n+\t\t     left-padded.  */\n+\t\t  if ((*ptr)->size < 8)\n+\t\t    where += 8 - (*ptr)->size;\n #endif\n-\t      memcpy (where, *p_argv.c, (*ptr)->size);\n-\t      next_arg.ul += words;\n-\t      if (next_arg.ul == gpr_end.ul)\n-\t\tnext_arg.ul = rest.ul;\n+\t\t  memcpy (where, *p_argv.c, (*ptr)->size);\n+\t\t  next_arg.ul += words;\n+\t\t  if (next_arg.ul == gpr_end.ul)\n+\t\t    next_arg.ul = rest.ul;\n+\t\t}\n \t    }\n \t  break;\n \n@@ -597,24 +717,22 @@ ffi_prep_args64 (extended_cif *ecif, unsigned long *const stack)\n \n \n /* Perform machine dependent cif processing */\n-ffi_status\n-ffi_prep_cif_machdep (ffi_cif *cif)\n+static ffi_status\n+ffi_prep_cif_machdep_core (ffi_cif *cif)\n {\n   /* All this is for the SYSV and LINUX64 ABI.  */\n-  int i;\n   ffi_type **ptr;\n   unsigned bytes;\n-  int fparg_count = 0, intarg_count = 0;\n-  unsigned flags = 0;\n+  unsigned i, fparg_count = 0, intarg_count = 0;\n+  unsigned flags = cif->flags;\n   unsigned struct_copy_size = 0;\n   unsigned type = cif->rtype->type;\n   unsigned size = cif->rtype->size;\n \n+  /* The machine-independent calculation of cif->bytes doesn't work\n+     for us.  Redo the calculation.  */\n   if (cif->abi != FFI_LINUX64)\n     {\n-      /* All the machine-independent calculation of cif->bytes will be wrong.\n-\t Redo the calculation for SYSV.  */\n-\n       /* Space for the frame pointer, callee's LR, and the asm's temp regs.  */\n       bytes = (2 + ASM_NEEDS_REGISTERS) * sizeof (int);\n \n@@ -624,13 +742,20 @@ ffi_prep_cif_machdep (ffi_cif *cif)\n   else\n     {\n       /* 64-bit ABI.  */\n+#if _CALL_ELF == 2\n+      /* Space for backchain, CR, LR, TOC and the asm's temp regs.  */\n+      bytes = (4 + ASM_NEEDS_REGISTERS64) * sizeof (long);\n \n+      /* Space for the general registers.  */\n+      bytes += NUM_GPR_ARG_REGISTERS64 * sizeof (long);\n+#else\n       /* Space for backchain, CR, LR, cc/ld doubleword, TOC and the asm's temp\n \t regs.  */\n       bytes = (6 + ASM_NEEDS_REGISTERS64) * sizeof (long);\n \n       /* Space for the mandatory parm save area and general registers.  */\n       bytes += 2 * NUM_GPR_ARG_REGISTERS64 * sizeof (long);\n+#endif\n     }\n \n   /* Return value handling.  The rules for SYSV are as follows:\n@@ -650,19 +775,23 @@ ffi_prep_cif_machdep (ffi_cif *cif)\n      - soft-float float/doubles are treated as UINT32/UINT64 respectivley.\n      - soft-float long doubles are returned in gpr3-gpr6.  */\n   /* First translate for softfloat/nonlinux */\n-  if (cif->abi == FFI_LINUX_SOFT_FLOAT) {\n-\tif (type == FFI_TYPE_FLOAT)\n-\t\ttype = FFI_TYPE_UINT32;\n-\tif (type == FFI_TYPE_DOUBLE)\n-\t\ttype = FFI_TYPE_UINT64;\n-\tif (type == FFI_TYPE_LONGDOUBLE)\n-\t\ttype = FFI_TYPE_UINT128;\n-  } else if (cif->abi != FFI_LINUX && cif->abi != FFI_LINUX64) {\n+  if (cif->abi == FFI_LINUX_SOFT_FLOAT)\n+    {\n+      if (type == FFI_TYPE_FLOAT)\n+\ttype = FFI_TYPE_UINT32;\n+      if (type == FFI_TYPE_DOUBLE)\n+\ttype = FFI_TYPE_UINT64;\n+      if (type == FFI_TYPE_LONGDOUBLE)\n+\ttype = FFI_TYPE_UINT128;\n+    }\n+  else if (cif->abi != FFI_LINUX\n+\t   && cif->abi != FFI_LINUX64)\n+    {\n #if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n-\tif (type == FFI_TYPE_LONGDOUBLE)\n-\t\ttype = FFI_TYPE_STRUCT;\n+      if (type == FFI_TYPE_LONGDOUBLE)\n+\ttype = FFI_TYPE_STRUCT;\n #endif\n-  }\n+    }\n \n   switch (type)\n     {\n@@ -691,7 +820,7 @@ ffi_prep_cif_machdep (ffi_cif *cif)\n     case FFI_TYPE_STRUCT:\n       /*\n        * The final SYSV ABI says that structures smaller or equal 8 bytes\n-       * are returned in r3/r4. The FFI_GCC_SYSV ABI instead returns them\n+       * are returned in r3/r4.  The FFI_GCC_SYSV ABI instead returns them\n        * in memory.\n        *\n        * NOTE: The assembly code can safely assume that it just needs to\n@@ -700,7 +829,29 @@ ffi_prep_cif_machdep (ffi_cif *cif)\n        *       set.\n        */\n       if (cif->abi == FFI_SYSV && size <= 8)\n-\tflags |= FLAG_RETURNS_SMST;\n+\t{\n+\t  flags |= FLAG_RETURNS_SMST;\n+\t  break;\n+\t}\n+#if _CALL_ELF == 2\n+      if (cif->abi == FFI_LINUX64)\n+\t{\n+\t  unsigned int elt, elnum;\n+\t  elt = discover_homogeneous_aggregate (cif->rtype, &elnum);\n+\t  if (elt)\n+\t    {\n+\t      if (elt == FFI_TYPE_DOUBLE)\n+\t\tflags |= FLAG_RETURNS_64BITS;\n+\t      flags |= FLAG_RETURNS_FP | FLAG_RETURNS_SMST;\n+\t      break;\n+\t    }\n+\t  if (size <= 16)\n+\t    {\n+\t      flags |= FLAG_RETURNS_SMST;\n+\t      break;\n+\t    }\n+\t}\n+#endif\n       intarg_count++;\n       flags |= FLAG_RETVAL_REFERENCE;\n       /* Fall through.  */\n@@ -816,27 +967,54 @@ ffi_prep_cif_machdep (ffi_cif *cif)\n   else\n     for (ptr = cif->arg_types, i = cif->nargs; i > 0; i--, ptr++)\n       {\n+\tunsigned int elt, elnum;\n+#ifdef __STRUCT_PARM_ALIGN__\n+\tunsigned int align;\n+#endif\n+\n \tswitch ((*ptr)->type)\n \t  {\n #if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n \t  case FFI_TYPE_LONGDOUBLE:\n-\t    if (cif->abi == FFI_LINUX_SOFT_FLOAT)\n-\t      intarg_count += 4;\n-\t    else\n-\t      {\n-\t\tfparg_count += 2;\n-\t\tintarg_count += 2;\n-\t      }\n+\t    fparg_count += 2;\n+\t    intarg_count += 2;\n+\t    if (fparg_count > NUM_FPR_ARG_REGISTERS)\n+\t      flags |= FLAG_ARG_NEEDS_PSAVE;\n \t    break;\n #endif\n \t  case FFI_TYPE_FLOAT:\n \t  case FFI_TYPE_DOUBLE:\n \t    fparg_count++;\n \t    intarg_count++;\n+\t    if (fparg_count > NUM_FPR_ARG_REGISTERS)\n+\t      flags |= FLAG_ARG_NEEDS_PSAVE;\n \t    break;\n \n \t  case FFI_TYPE_STRUCT:\n+#ifdef __STRUCT_PARM_ALIGN__\n+\t    align = (*ptr)->alignment;\n+\t    if (align > __STRUCT_PARM_ALIGN__)\n+\t      align = __STRUCT_PARM_ALIGN__;\n+\t    align = align / 8;\n+\t    if (align > 1)\n+\t      intarg_count = ALIGN (intarg_count, align);\n+#endif\n \t    intarg_count += ((*ptr)->size + 7) / 8;\n+\t    elt = 0;\n+#if _CALL_ELF == 2\n+\t    elt = discover_homogeneous_aggregate (*ptr, &elnum);\n+#endif\n+\t    if (elt)\n+\t      {\n+\t\tfparg_count += elnum;\n+\t\tif (fparg_count > NUM_FPR_ARG_REGISTERS)\n+\t\t  flags |= FLAG_ARG_NEEDS_PSAVE;\n+\t      }\n+\t    else\n+\t      {\n+\t\tif (intarg_count > NUM_GPR_ARG_REGISTERS)\n+\t\t  flags |= FLAG_ARG_NEEDS_PSAVE;\n+\t      }\n \t    break;\n \n \t  case FFI_TYPE_POINTER:\n@@ -852,9 +1030,11 @@ ffi_prep_cif_machdep (ffi_cif *cif)\n \t    /* Everything else is passed as a 8-byte word in a GPR, either\n \t       the object itself or a pointer to it.  */\n \t    intarg_count++;\n+\t    if (intarg_count > NUM_GPR_ARG_REGISTERS)\n+\t      flags |= FLAG_ARG_NEEDS_PSAVE;\n \t    break;\n \t  default:\n-\t\tFFI_ASSERT (0);\n+\t    FFI_ASSERT (0);\n \t  }\n       }\n \n@@ -892,8 +1072,13 @@ ffi_prep_cif_machdep (ffi_cif *cif)\n #endif\n \n       /* Stack space.  */\n+#if _CALL_ELF == 2\n+      if ((flags & FLAG_ARG_NEEDS_PSAVE) != 0)\n+\tbytes += intarg_count * sizeof (long);\n+#else\n       if (intarg_count > NUM_GPR_ARG_REGISTERS64)\n \tbytes += (intarg_count - NUM_GPR_ARG_REGISTERS64) * sizeof (long);\n+#endif\n     }\n \n   /* The stack space allocated needs to be a multiple of 16 bytes.  */\n@@ -908,6 +1093,26 @@ ffi_prep_cif_machdep (ffi_cif *cif)\n   return FFI_OK;\n }\n \n+ffi_status\n+ffi_prep_cif_machdep (ffi_cif *cif)\n+{\n+  cif->nfixedargs = cif->nargs;\n+  return ffi_prep_cif_machdep_core (cif);\n+}\n+\n+ffi_status\n+ffi_prep_cif_machdep_var (ffi_cif *cif,\n+\t\t\t  unsigned int nfixedargs,\n+\t\t\t  unsigned int ntotalargs MAYBE_UNUSED)\n+{\n+  cif->nfixedargs = nfixedargs;\n+#if _CALL_ELF == 2\n+  if (cif->abi == FFI_LINUX64)\n+    cif->flags |= FLAG_ARG_NEEDS_PSAVE;\n+#endif\n+  return ffi_prep_cif_machdep_core (cif);\n+}\n+\n extern void ffi_call_SYSV(extended_cif *, unsigned, unsigned, unsigned *,\n \t\t\t  void (*fn)(void));\n extern void FFI_HIDDEN ffi_call_LINUX64(extended_cif *, unsigned long,\n@@ -919,30 +1124,28 @@ ffi_call(ffi_cif *cif, void (*fn)(void), void *rvalue, void **avalue)\n {\n   /*\n    * The final SYSV ABI says that structures smaller or equal 8 bytes\n-   * are returned in r3/r4. The FFI_GCC_SYSV ABI instead returns them\n+   * are returned in r3/r4.  The FFI_GCC_SYSV ABI instead returns them\n    * in memory.\n    *\n-   * Just to keep things simple for the assembly code, we will always\n-   * bounce-buffer struct return values less than or equal to 8 bytes.\n-   * This allows the ASM to handle SYSV small structures by directly\n-   * writing r3 and r4 to memory without worrying about struct size.\n+   * We bounce-buffer SYSV small struct return values so that sysv.S\n+   * can write r3 and r4 to memory without worrying about struct size.\n+   *\n+   * For ELFv2 ABI, use a bounce buffer for homogeneous structs too,\n+   * for similar reasons.\n    */\n-  unsigned int smst_buffer[2];\n+  unsigned long smst_buffer[8];\n   extended_cif ecif;\n-  unsigned int rsize = 0;\n \n   ecif.cif = cif;\n   ecif.avalue = avalue;\n \n-  /* Ensure that we have a valid struct return value */\n   ecif.rvalue = rvalue;\n-  if (cif->rtype->type == FFI_TYPE_STRUCT) {\n-    rsize = cif->rtype->size;\n-    if (rsize <= 8)\n-      ecif.rvalue = smst_buffer;\n-    else if (!rvalue)\n-      ecif.rvalue = alloca(rsize);\n-  }\n+  if ((cif->flags & FLAG_RETURNS_SMST) != 0)\n+    ecif.rvalue = smst_buffer;\n+  /* Ensure that we have a valid struct return value.\n+     FIXME: Isn't this just papering over a user problem?  */\n+  else if (!rvalue && cif->rtype->type == FFI_TYPE_STRUCT)\n+    ecif.rvalue = alloca (cif->rtype->size);\n \n   switch (cif->abi)\n     {\n@@ -967,11 +1170,26 @@ ffi_call(ffi_cif *cif, void (*fn)(void), void *rvalue, void **avalue)\n \n   /* Check for a bounce-buffered return value */\n   if (rvalue && ecif.rvalue == smst_buffer)\n-    memcpy(rvalue, smst_buffer, rsize);\n+    {\n+      unsigned int rsize = cif->rtype->size;\n+#ifndef __LITTLE_ENDIAN__\n+      /* The SYSV ABI returns a structure of up to 4 bytes in size\n+\t left-padded in r3.  */\n+      if (cif->abi == FFI_SYSV && rsize <= 4)\n+\tmemcpy (rvalue, (char *) smst_buffer + 4 - rsize, rsize);\n+      /* The SYSV ABI returns a structure of up to 8 bytes in size\n+\t left-padded in r3/r4, and the ELFv2 ABI similarly returns a\n+\t structure of up to 8 bytes in size left-padded in r3.  */\n+      else if (rsize <= 8)\n+\tmemcpy (rvalue, (char *) smst_buffer + 8 - rsize, rsize);\n+      else\n+#endif\n+\tmemcpy (rvalue, smst_buffer, rsize);\n+    }\n }\n \n \n-#ifndef POWERPC64\n+#if !defined POWERPC64 || _CALL_ELF == 2\n #define MIN_CACHE_LINE_SIZE 8\n \n static void\n@@ -995,13 +1213,30 @@ ffi_prep_closure_loc (ffi_closure *closure,\n \t\t      void *codeloc)\n {\n #ifdef POWERPC64\n+# if _CALL_ELF == 2\n+  unsigned int *tramp = (unsigned int *) &closure->tramp[0];\n+\n+  if (cif->abi != FFI_LINUX64)\n+    return FFI_BAD_ABI;\n+\n+  tramp[0] = 0xe96c0018;\t/* 0:\tld\t11,2f-0b(12)\t*/\n+  tramp[1] = 0xe98c0010;\t/*\tld\t12,1f-0b(12)\t*/\n+  tramp[2] = 0x7d8903a6;\t/*\tmtctr\t12\t\t*/\n+  tramp[3] = 0x4e800420;\t/*\tbctr\t\t\t*/\n+\t\t\t\t/* 1:\t.quad\tfunction_addr\t*/\n+\t\t\t\t/* 2:\t.quad\tcontext\t\t*/\n+  *(void **) &tramp[4] = (void *) ffi_closure_LINUX64;\n+  *(void **) &tramp[6] = codeloc;\n+  flush_icache ((char *)tramp, (char *)codeloc, FFI_TRAMPOLINE_SIZE);\n+# else\n   void **tramp = (void **) &closure->tramp[0];\n \n   if (cif->abi != FFI_LINUX64)\n     return FFI_BAD_ABI;\n   /* Copy function address and TOC from ffi_closure_LINUX64.  */\n   memcpy (tramp, (char *) ffi_closure_LINUX64, 16);\n   tramp[2] = codeloc;\n+# endif\n #else\n   unsigned int *tramp;\n \n@@ -1226,6 +1461,7 @@ ffi_closure_helper_SYSV (ffi_closure *closure, void *rvalue,\n \t    }\n \t  break;\n #endif\n+\n \tcase FFI_TYPE_SINT16:\n \tcase FFI_TYPE_UINT16:\n #ifndef __LITTLE_ENDIAN__\n@@ -1243,6 +1479,7 @@ ffi_closure_helper_SYSV (ffi_closure *closure, void *rvalue,\n \t    }\n \t  break;\n #endif\n+\n \tcase FFI_TYPE_SINT32:\n \tcase FFI_TYPE_UINT32:\n \tcase FFI_TYPE_POINTER:\n@@ -1346,28 +1583,35 @@ ffi_closure_helper_LINUX64 (ffi_closure *closure, void *rvalue,\n \n   void **avalue;\n   ffi_type **arg_types;\n-  long i, avn;\n+  unsigned long i, avn, nfixedargs;\n   ffi_cif *cif;\n   ffi_dblfl *end_pfr = pfr + NUM_FPR_ARG_REGISTERS64;\n+#ifdef __STRUCT_PARM_ALIGN__\n+  unsigned long align;\n+#endif\n \n   cif = closure->cif;\n   avalue = alloca (cif->nargs * sizeof (void *));\n \n-  /* Copy the caller's structure return value address so that the closure\n-     returns the data directly to the caller.  */\n-  if (cif->rtype->type == FFI_TYPE_STRUCT)\n+  /* Copy the caller's structure return value address so that the\n+     closure returns the data directly to the caller.  */\n+  if (cif->rtype->type == FFI_TYPE_STRUCT\n+      && (cif->flags & FLAG_RETURNS_SMST) == 0)\n     {\n       rvalue = (void *) *pst;\n       pst++;\n     }\n \n   i = 0;\n   avn = cif->nargs;\n+  nfixedargs = cif->nfixedargs;\n   arg_types = cif->arg_types;\n \n   /* Grab the addresses of the arguments from the stack frame.  */\n   while (i < avn)\n     {\n+      unsigned int elt, elnum;\n+\n       switch (arg_types[i]->type)\n \t{\n \tcase FFI_TYPE_SINT8:\n@@ -1377,20 +1621,23 @@ ffi_closure_helper_LINUX64 (ffi_closure *closure, void *rvalue,\n \t  pst++;\n \t  break;\n #endif\n+\n \tcase FFI_TYPE_SINT16:\n \tcase FFI_TYPE_UINT16:\n #ifndef __LITTLE_ENDIAN__\n \t  avalue[i] = (char *) pst + 6;\n \t  pst++;\n \t  break;\n #endif\n+\n \tcase FFI_TYPE_SINT32:\n \tcase FFI_TYPE_UINT32:\n #ifndef __LITTLE_ENDIAN__\n \t  avalue[i] = (char *) pst + 4;\n \t  pst++;\n \t  break;\n #endif\n+\n \tcase FFI_TYPE_SINT64:\n \tcase FFI_TYPE_UINT64:\n \tcase FFI_TYPE_POINTER:\n@@ -1399,14 +1646,82 @@ ffi_closure_helper_LINUX64 (ffi_closure *closure, void *rvalue,\n \t  break;\n \n \tcase FFI_TYPE_STRUCT:\n-#ifndef __LITTLE_ENDIAN__\n-\t  /* Structures with size less than eight bytes are passed\n-\t     left-padded.  */\n-\t  if (arg_types[i]->size < 8)\n-\t    avalue[i] = (char *) pst + 8 - arg_types[i]->size;\n+#ifdef __STRUCT_PARM_ALIGN__\n+\t  align = arg_types[i]->alignment;\n+\t  if (align > __STRUCT_PARM_ALIGN__)\n+\t    align = __STRUCT_PARM_ALIGN__;\n+\t  if (align > 1)\n+\t    pst = (unsigned long *) ALIGN ((size_t) pst, align);\n+#endif\n+\t  elt = 0;\n+#if _CALL_ELF == 2\n+\t  elt = discover_homogeneous_aggregate (arg_types[i], &elnum);\n+#endif\n+\t  if (elt)\n+\t    {\n+\t      union {\n+\t\tvoid *v;\n+\t\tunsigned long *ul;\n+\t\tfloat *f;\n+\t\tdouble *d;\n+\t\tsize_t p;\n+\t      } to, from;\n+\n+\t      /* Repackage the aggregate from its parts.  The\n+\t\t aggregate size is not greater than the space taken by\n+\t\t the registers so store back to the register/parameter\n+\t\t save arrays.  */\n+\t      if (pfr + elnum <= end_pfr)\n+\t\tto.v = pfr;\n+\t      else\n+\t\tto.v = pst;\n+\n+\t      avalue[i] = to.v;\n+\t      from.ul = pst;\n+\t      if (elt == FFI_TYPE_FLOAT)\n+\t\t{\n+\t\t  do\n+\t\t    {\n+\t\t      if (pfr < end_pfr && i < nfixedargs)\n+\t\t\t{\n+\t\t\t  *to.f = (float) pfr->d;\n+\t\t\t  pfr++;\n+\t\t\t}\n+\t\t      else\n+\t\t\t*to.f = *from.f;\n+\t\t      to.f++;\n+\t\t      from.f++;\n+\t\t    }\n+\t\t  while (--elnum != 0);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  do\n+\t\t    {\n+\t\t      if (pfr < end_pfr && i < nfixedargs)\n+\t\t\t{\n+\t\t\t  *to.d = pfr->d;\n+\t\t\t  pfr++;\n+\t\t\t}\n+\t\t      else\n+\t\t\t*to.d = *from.d;\n+\t\t      to.d++;\n+\t\t      from.d++;\n+\t\t    }\n+\t\t  while (--elnum != 0);\n+\t\t}\n+\t    }\n \t  else\n+\t    {\n+#ifndef __LITTLE_ENDIAN__\n+\t      /* Structures with size less than eight bytes are passed\n+\t\t left-padded.  */\n+\t      if (arg_types[i]->size < 8)\n+\t\tavalue[i] = (char *) pst + 8 - arg_types[i]->size;\n+\t      else\n #endif\n-\t    avalue[i] = pst;\n+\t\tavalue[i] = pst;\n+\t    }\n \t  pst += (arg_types[i]->size + 7) / 8;\n \t  break;\n \n@@ -1418,7 +1733,7 @@ ffi_closure_helper_LINUX64 (ffi_closure *closure, void *rvalue,\n \n \t  /* there are 13 64bit floating point registers */\n \n-\t  if (pfr < end_pfr)\n+\t  if (pfr < end_pfr && i < nfixedargs)\n \t    {\n \t      double temp = pfr->d;\n \t      pfr->f = (float) temp;\n@@ -1434,7 +1749,7 @@ ffi_closure_helper_LINUX64 (ffi_closure *closure, void *rvalue,\n \t  /* On the outgoing stack all values are aligned to 8 */\n \t  /* there are 13 64bit floating point registers */\n \n-\t  if (pfr < end_pfr)\n+\t  if (pfr < end_pfr && i < nfixedargs)\n \t    {\n \t      avalue[i] = pfr;\n \t      pfr++;\n@@ -1446,14 +1761,14 @@ ffi_closure_helper_LINUX64 (ffi_closure *closure, void *rvalue,\n \n #if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE\n \tcase FFI_TYPE_LONGDOUBLE:\n-\t  if (pfr + 1 < end_pfr)\n+\t  if (pfr + 1 < end_pfr && i + 1 < nfixedargs)\n \t    {\n \t      avalue[i] = pfr;\n \t      pfr += 2;\n \t    }\n \t  else\n \t    {\n-\t      if (pfr < end_pfr)\n+\t      if (pfr < end_pfr && i < nfixedargs)\n \t\t{\n \t\t  /* Passed partly in f13 and partly on the stack.\n \t\t     Move it all to the stack.  */\n@@ -1477,5 +1792,14 @@ ffi_closure_helper_LINUX64 (ffi_closure *closure, void *rvalue,\n   (closure->fun) (cif, rvalue, avalue, closure->user_data);\n \n   /* Tell ffi_closure_LINUX64 how to perform return type promotions.  */\n+  if ((cif->flags & FLAG_RETURNS_SMST) != 0)\n+    {\n+      if ((cif->flags & FLAG_RETURNS_FP) == 0)\n+\treturn FFI_V2_TYPE_SMALL_STRUCT + cif->rtype->size - 1;\n+      else if ((cif->flags & FLAG_RETURNS_64BITS) != 0)\n+\treturn FFI_V2_TYPE_DOUBLE_HOMOG;\n+      else\n+\treturn FFI_V2_TYPE_FLOAT_HOMOG;\n+    }\n   return cif->rtype->type;\n }"}, {"sha": "2be728e18f493226dcd1011e48ba54684b711f8a", "filename": "libffi/src/powerpc/ffitarget.h", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3521ba8b2e5c974c021853b2b829313029b4eda8/libffi%2Fsrc%2Fpowerpc%2Fffitarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3521ba8b2e5c974c021853b2b829313029b4eda8/libffi%2Fsrc%2Fpowerpc%2Fffitarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fpowerpc%2Fffitarget.h?ref=3521ba8b2e5c974c021853b2b829313029b4eda8", "patch": "@@ -106,6 +106,10 @@ typedef enum ffi_abi {\n \n #define FFI_CLOSURES 1\n #define FFI_NATIVE_RAW_API 0\n+#if defined (POWERPC) || defined (POWERPC_FREEBSD)\n+# define FFI_TARGET_SPECIFIC_VARIADIC 1\n+# define FFI_EXTRA_CIF_FIELDS unsigned nfixedargs\n+#endif\n \n /* For additional types like the below, take care about the order in\n    ppc_closures.S. They must follow after the FFI_TYPE_LAST.  */\n@@ -118,14 +122,23 @@ typedef enum ffi_abi {\n    defined in ffi.c, to determine the exact return type and its size.  */\n #define FFI_SYSV_TYPE_SMALL_STRUCT (FFI_TYPE_LAST + 2)\n \n-#if defined(POWERPC64) || defined(POWERPC_AIX)\n+/* Used by ELFv2 for homogenous structure returns.  */\n+#define FFI_V2_TYPE_FLOAT_HOMOG\t\t(FFI_TYPE_LAST + 1)\n+#define FFI_V2_TYPE_DOUBLE_HOMOG\t(FFI_TYPE_LAST + 2)\n+#define FFI_V2_TYPE_SMALL_STRUCT\t(FFI_TYPE_LAST + 3)\n+\n+#if _CALL_ELF == 2\n+# define FFI_TRAMPOLINE_SIZE 32\n+#else\n+# if defined(POWERPC64) || defined(POWERPC_AIX)\n #  if defined(POWERPC_DARWIN64)\n #    define FFI_TRAMPOLINE_SIZE 48\n #  else\n #    define FFI_TRAMPOLINE_SIZE 24\n #  endif\n-#else /* POWERPC || POWERPC_AIX */\n+# else /* POWERPC || POWERPC_AIX */\n #  define FFI_TRAMPOLINE_SIZE 40\n+# endif\n #endif\n \n #ifndef LIBFFI_ASM"}, {"sha": "85b8aaafd82ef8672f7b83949f273dd4dc40fe6f", "filename": "libffi/src/powerpc/linux64.S", "status": "modified", "additions": 73, "deletions": 17, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3521ba8b2e5c974c021853b2b829313029b4eda8/libffi%2Fsrc%2Fpowerpc%2Flinux64.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3521ba8b2e5c974c021853b2b829313029b4eda8/libffi%2Fsrc%2Fpowerpc%2Flinux64.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fpowerpc%2Flinux64.S?ref=3521ba8b2e5c974c021853b2b829313029b4eda8", "patch": "@@ -32,23 +32,31 @@\n #ifdef __powerpc64__\n \t.hidden\tffi_call_LINUX64\n \t.globl\tffi_call_LINUX64\n+# if _CALL_ELF == 2\n+\t.text\n+ffi_call_LINUX64:\n+\taddis\t%r2, %r12, .TOC.-ffi_call_LINUX64@ha\n+\taddi\t%r2, %r2, .TOC.-ffi_call_LINUX64@l\n+\t.localentry ffi_call_LINUX64, . - ffi_call_LINUX64\n+# else\n \t.section\t\".opd\",\"aw\"\n \t.align\t3\n ffi_call_LINUX64:\n-#ifdef _CALL_LINUX\n+#  ifdef _CALL_LINUX\n \t.quad\t.L.ffi_call_LINUX64,.TOC.@tocbase,0\n \t.type\tffi_call_LINUX64,@function\n \t.text\n .L.ffi_call_LINUX64:\n-#else\n+#  else\n \t.hidden\t.ffi_call_LINUX64\n \t.globl\t.ffi_call_LINUX64\n \t.quad\t.ffi_call_LINUX64,.TOC.@tocbase,0\n \t.size\tffi_call_LINUX64,24\n \t.type\t.ffi_call_LINUX64,@function\n \t.text\n .ffi_call_LINUX64:\n-#endif\n+#  endif\n+# endif\n .LFB1:\n \tmflr\t%r0\n \tstd\t%r28, -32(%r1)\n@@ -63,26 +71,35 @@ ffi_call_LINUX64:\n \tmr\t%r31, %r5\t/* flags, */\n \tmr\t%r30, %r6\t/* rvalue, */\n \tmr\t%r29, %r7\t/* function address.  */\n+/* Save toc pointer, not for the ffi_prep_args64 call, but for the later\n+   bctrl function call.  */\n+# if _CALL_ELF == 2\n+\tstd\t%r2, 24(%r1)\n+# else\n \tstd\t%r2, 40(%r1)\n+# endif\n \n \t/* Call ffi_prep_args64.  */\n \tmr\t%r4, %r1\n-#ifdef _CALL_LINUX\n+# if defined _CALL_LINUX || _CALL_ELF == 2\n \tbl\tffi_prep_args64\n-#else\n+# else\n \tbl\t.ffi_prep_args64\n-#endif\n+# endif\n \n-\tld\t%r0, 0(%r29)\n+# if _CALL_ELF == 2\n+\tmr\t%r12, %r29\n+# else\n+\tld\t%r12, 0(%r29)\n \tld\t%r2, 8(%r29)\n \tld\t%r11, 16(%r29)\n-\n+# endif\n \t/* Now do the call.  */\n \t/* Set up cr1 with bits 4-7 of the flags.  */\n \tmtcrf\t0x40, %r31\n \n \t/* Get the address to call into CTR.  */\n-\tmtctr\t%r0\n+\tmtctr\t%r12\n \t/* Load all those argument registers.  */\n \tld\t%r3, -32-(8*8)(%r28)\n \tld\t%r4, -32-(7*8)(%r28)\n@@ -117,20 +134,25 @@ ffi_call_LINUX64:\n \n \t/* This must follow the call immediately, the unwinder\n \t   uses this to find out if r2 has been saved or not.  */\n+# if _CALL_ELF == 2\n+\tld\t%r2, 24(%r1)\n+# else\n \tld\t%r2, 40(%r1)\n+# endif\n \n \t/* Now, deal with the return value.  */\n \tmtcrf\t0x01, %r31\n-\tbt-\t30, .Ldone_return_value\n-\tbt-\t29, .Lfp_return_value\n+\tbt\t31, .Lstruct_return_value\n+\tbt\t30, .Ldone_return_value\n+\tbt\t29, .Lfp_return_value\n \tstd\t%r3, 0(%r30)\n \t/* Fall through...  */\n \n .Ldone_return_value:\n \t/* Restore the registers we used and return.  */\n \tmr\t%r1, %r28\n \tld\t%r0, 16(%r28)\n-\tld\t%r28, -32(%r1)\n+\tld\t%r28, -32(%r28)\n \tmtlr\t%r0\n \tld\t%r29, -24(%r1)\n \tld\t%r30, -16(%r1)\n@@ -147,14 +169,48 @@ ffi_call_LINUX64:\n .Lfloat_return_value:\n \tstfs\t%f1, 0(%r30)\n \tb\t.Ldone_return_value\n+\n+.Lstruct_return_value:\n+\tbf\t29, .Lsmall_struct\n+\tbf\t28, .Lfloat_homog_return_value\n+\tstfd\t%f1, 0(%r30)\n+\tstfd\t%f2, 8(%r30)\n+\tstfd\t%f3, 16(%r30)\n+\tstfd\t%f4, 24(%r30)\n+\tstfd\t%f5, 32(%r30)\n+\tstfd\t%f6, 40(%r30)\n+\tstfd\t%f7, 48(%r30)\n+\tstfd\t%f8, 56(%r30)\n+\tb\t.Ldone_return_value\n+\n+.Lfloat_homog_return_value:\n+\tstfs\t%f1, 0(%r30)\n+\tstfs\t%f2, 4(%r30)\n+\tstfs\t%f3, 8(%r30)\n+\tstfs\t%f4, 12(%r30)\n+\tstfs\t%f5, 16(%r30)\n+\tstfs\t%f6, 20(%r30)\n+\tstfs\t%f7, 24(%r30)\n+\tstfs\t%f8, 28(%r30)\n+\tb\t.Ldone_return_value\n+\n+.Lsmall_struct:\n+\tstd\t%r3, 0(%r30)\n+\tstd\t%r4, 8(%r30)\n+\tb\t.Ldone_return_value\n+\n .LFE1:\n \t.long\t0\n \t.byte\t0,12,0,1,128,4,0,0\n-#ifdef _CALL_LINUX\n+# if _CALL_ELF == 2\n+\t.size\tffi_call_LINUX64,.-ffi_call_LINUX64\n+# else\n+#  ifdef _CALL_LINUX\n \t.size\tffi_call_LINUX64,.-.L.ffi_call_LINUX64\n-#else\n+#  else\n \t.size\t.ffi_call_LINUX64,.-.ffi_call_LINUX64\n-#endif\n+#  endif\n+# endif\n \n \t.section\t.eh_frame,EH_FRAME_FLAGS,@progbits\n .Lframe1:\n@@ -197,8 +253,8 @@ ffi_call_LINUX64:\n \t.uleb128 0x4\n \t.align 3\n .LEFDE1:\n-#endif\n \n-#if defined __ELF__ && defined __linux__\n+# if (defined __ELF__ && defined __linux__) || _CALL_ELF == 2\n \t.section\t.note.GNU-stack,\"\",@progbits\n+# endif\n #endif"}, {"sha": "9b6b5f3d79ed1b2f3c8eae64c49654ff85b9a992", "filename": "libffi/src/powerpc/linux64_closure.S", "status": "modified", "additions": 214, "deletions": 105, "changes": 319, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3521ba8b2e5c974c021853b2b829313029b4eda8/libffi%2Fsrc%2Fpowerpc%2Flinux64_closure.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3521ba8b2e5c974c021853b2b829313029b4eda8/libffi%2Fsrc%2Fpowerpc%2Flinux64_closure.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fpowerpc%2Flinux64_closure.S?ref=3521ba8b2e5c974c021853b2b829313029b4eda8", "patch": "@@ -33,77 +33,126 @@\n #ifdef __powerpc64__\n \tFFI_HIDDEN (ffi_closure_LINUX64)\n \t.globl  ffi_closure_LINUX64\n+# if _CALL_ELF == 2\n+\t.text\n+ffi_closure_LINUX64:\n+\taddis\t%r2, %r12, .TOC.-ffi_closure_LINUX64@ha\n+\taddi\t%r2, %r2, .TOC.-ffi_closure_LINUX64@l\n+\t.localentry ffi_closure_LINUX64, . - ffi_closure_LINUX64\n+# else\n \t.section        \".opd\",\"aw\"\n \t.align  3\n ffi_closure_LINUX64:\n-#ifdef _CALL_LINUX\n+#  ifdef _CALL_LINUX\n \t.quad   .L.ffi_closure_LINUX64,.TOC.@tocbase,0\n \t.type   ffi_closure_LINUX64,@function\n \t.text\n .L.ffi_closure_LINUX64:\n-#else\n+#  else\n \tFFI_HIDDEN (.ffi_closure_LINUX64)\n \t.globl  .ffi_closure_LINUX64\n \t.quad   .ffi_closure_LINUX64,.TOC.@tocbase,0\n \t.size   ffi_closure_LINUX64,24\n \t.type   .ffi_closure_LINUX64,@function\n \t.text\n .ffi_closure_LINUX64:\n-#endif\n+#  endif\n+# endif\n+\n+# if _CALL_ELF == 2\n+#  32 byte special reg save area + 64 byte parm save area and retval\n+#  + 13*8 fpr save area + round to 16\n+#  define STACKFRAME 208\n+#  define PARMSAVE 32\n+#  No parameter save area is needed for the call to ffi_closure_helper_LINUX64,\n+#  so return value can start there.\n+#  define RETVAL PARMSAVE\n+# else\n+#  48 bytes special reg save area + 64 bytes parm save area\n+#  + 16 bytes retval area + 13*8 bytes fpr save area + round to 16\n+#  define STACKFRAME 240\n+#  define PARMSAVE 48\n+#  define RETVAL PARMSAVE+64\n+# endif\n+\n .LFB1:\n-\t# save general regs into parm save area\n-\tstd\t%r3, 48(%r1)\n-\tstd\t%r4, 56(%r1)\n-\tstd\t%r5, 64(%r1)\n-\tstd\t%r6, 72(%r1)\n+# if _CALL_ELF == 2\n+\tld\t%r12, FFI_TRAMPOLINE_SIZE(%r11)\t\t# closure->cif\n \tmflr\t%r0\n+\tlwz\t%r12, 28(%r12)\t\t\t\t# cif->flags\n+\tmtcrf\t0x40, %r12\n+\taddi\t%r12, %r1, PARMSAVE\n+\tbt\t7, .Lparmsave\n+\t# Our caller has not allocated a parameter save area.\n+\t# We need to allocate one here and use it to pass gprs to\n+\t# ffi_closure_helper_LINUX64.  The return value area will do.\n+\taddi\t%r12, %r1, -STACKFRAME+RETVAL\n+.Lparmsave:\n+\tstd\t%r0, 16(%r1)\n+\t# Save general regs into parm save area\n+\tstd\t%r3, 0(%r12)\n+\tstd\t%r4, 8(%r12)\n+\tstd\t%r5, 16(%r12)\n+\tstd\t%r6, 24(%r12)\n+\tstd\t%r7, 32(%r12)\n+\tstd\t%r8, 40(%r12)\n+\tstd\t%r9, 48(%r12)\n+\tstd\t%r10, 56(%r12)\n+\n+\t# load up the pointer to the parm save area\n+\tmr\t%r5, %r12\n+# else\n+\tmflr\t%r0\n+\t# Save general regs into parm save area\n+\t# This is the parameter save area set up by our caller.\n+\tstd\t%r3, PARMSAVE+0(%r1)\n+\tstd\t%r4, PARMSAVE+8(%r1)\n+\tstd\t%r5, PARMSAVE+16(%r1)\n+\tstd\t%r6, PARMSAVE+24(%r1)\n+\tstd\t%r7, PARMSAVE+32(%r1)\n+\tstd\t%r8, PARMSAVE+40(%r1)\n+\tstd\t%r9, PARMSAVE+48(%r1)\n+\tstd\t%r10, PARMSAVE+56(%r1)\n \n-\tstd\t%r7, 80(%r1)\n-\tstd\t%r8, 88(%r1)\n-\tstd\t%r9, 96(%r1)\n-\tstd\t%r10, 104(%r1)\n \tstd\t%r0, 16(%r1)\n \n-\t# mandatory 48 bytes special reg save area + 64 bytes parm save area\n-\t# + 16 bytes retval area + 13*8 bytes fpr save area + round to 16\n-\tstdu\t%r1, -240(%r1)\n-.LCFI0:\n+\t# load up the pointer to the parm save area\n+\taddi\t%r5, %r1, PARMSAVE\n+# endif\n \n \t# next save fpr 1 to fpr 13\n-\tstfd  %f1, 128+(0*8)(%r1)\n-\tstfd  %f2, 128+(1*8)(%r1)\n-\tstfd  %f3, 128+(2*8)(%r1)\n-\tstfd  %f4, 128+(3*8)(%r1)\n-\tstfd  %f5, 128+(4*8)(%r1)\n-\tstfd  %f6, 128+(5*8)(%r1)\n-\tstfd  %f7, 128+(6*8)(%r1)\n-\tstfd  %f8, 128+(7*8)(%r1)\n-\tstfd  %f9, 128+(8*8)(%r1)\n-\tstfd  %f10, 128+(9*8)(%r1)\n-\tstfd  %f11, 128+(10*8)(%r1)\n-\tstfd  %f12, 128+(11*8)(%r1)\n-\tstfd  %f13, 128+(12*8)(%r1)\n+\tstfd\t%f1, -104+(0*8)(%r1)\n+\tstfd\t%f2, -104+(1*8)(%r1)\n+\tstfd\t%f3, -104+(2*8)(%r1)\n+\tstfd\t%f4, -104+(3*8)(%r1)\n+\tstfd\t%f5, -104+(4*8)(%r1)\n+\tstfd\t%f6, -104+(5*8)(%r1)\n+\tstfd\t%f7, -104+(6*8)(%r1)\n+\tstfd\t%f8, -104+(7*8)(%r1)\n+\tstfd\t%f9, -104+(8*8)(%r1)\n+\tstfd\t%f10, -104+(9*8)(%r1)\n+\tstfd\t%f11, -104+(10*8)(%r1)\n+\tstfd\t%f12, -104+(11*8)(%r1)\n+\tstfd\t%f13, -104+(12*8)(%r1)\n \n-\t# set up registers for the routine that actually does the work\n-\t# get the context pointer from the trampoline\n-\tmr %r3, %r11\n+\t# load up the pointer to the saved fpr registers */\n+\taddi\t%r6, %r1, -104\n \n-\t# now load up the pointer to the result storage\n-\taddi %r4, %r1, 112\n+\t# load up the pointer to the result storage\n+\taddi\t%r4, %r1, -STACKFRAME+RETVAL\n \n-\t# now load up the pointer to the parameter save area\n-\t# in the previous frame\n-\taddi %r5, %r1, 240 + 48\n+\tstdu\t%r1, -STACKFRAME(%r1)\n+.LCFI0:\n \n-\t# now load up the pointer to the saved fpr registers */\n-\taddi %r6, %r1, 128\n+\t# get the context pointer from the trampoline\n+\tmr\t%r3, %r11\n \n \t# make the call\n-#ifdef _CALL_LINUX\n+# if defined _CALL_LINUX || _CALL_ELF == 2\n \tbl ffi_closure_helper_LINUX64\n-#else\n+# else\n \tbl .ffi_closure_helper_LINUX64\n-#endif\n+# endif\n .Lret:\n \n \t# now r3 contains the return type\n@@ -112,10 +161,12 @@ ffi_closure_LINUX64:\n \n \t# look up the proper starting point in table\n \t# by using return type as offset\n+\tld %r0, STACKFRAME+16(%r1)\n+\tcmpldi %r3, FFI_V2_TYPE_SMALL_STRUCT\n+\tbge .Lsmall\n \tmflr %r4\t\t# move address of .Lret to r4\n \tsldi %r3, %r3, 4\t# now multiply return type by 16\n \taddi %r4, %r4, .Lret_type0 - .Lret\n-\tld %r0, 240+16(%r1)\n \tadd %r3, %r3, %r4\t# add contents of table to table address\n \tmtctr %r3\n \tbctr\t\t\t# jump to it\n@@ -128,117 +179,175 @@ ffi_closure_LINUX64:\n .Lret_type0:\n # case FFI_TYPE_VOID\n \tmtlr %r0\n-\taddi %r1, %r1, 240\n+\taddi %r1, %r1, STACKFRAME\n \tblr\n \tnop\n # case FFI_TYPE_INT\n-#ifdef __LITTLE_ENDIAN__\n-\tlwa %r3, 112+0(%r1)\n-#else\n-\tlwa %r3, 112+4(%r1)\n-#endif\n+# ifdef __LITTLE_ENDIAN__\n+\tlwa %r3, RETVAL+0(%r1)\n+# else\n+\tlwa %r3, RETVAL+4(%r1)\n+# endif\n \tmtlr %r0\n-\taddi %r1, %r1, 240\n+\taddi %r1, %r1, STACKFRAME\n \tblr\n # case FFI_TYPE_FLOAT\n-\tlfs %f1, 112+0(%r1)\n+\tlfs %f1, RETVAL+0(%r1)\n \tmtlr %r0\n-\taddi %r1, %r1, 240\n+\taddi %r1, %r1, STACKFRAME\n \tblr\n # case FFI_TYPE_DOUBLE\n-\tlfd %f1, 112+0(%r1)\n+\tlfd %f1, RETVAL+0(%r1)\n \tmtlr %r0\n-\taddi %r1, %r1, 240\n+\taddi %r1, %r1, STACKFRAME\n \tblr\n # case FFI_TYPE_LONGDOUBLE\n-\tlfd %f1, 112+0(%r1)\n+\tlfd %f1, RETVAL+0(%r1)\n \tmtlr %r0\n-\tlfd %f2, 112+8(%r1)\n+\tlfd %f2, RETVAL+8(%r1)\n \tb .Lfinish\n # case FFI_TYPE_UINT8\n-#ifdef __LITTLE_ENDIAN__\n-\tlbz %r3, 112+0(%r1)\n-#else\n-\tlbz %r3, 112+7(%r1)\n-#endif\n+# ifdef __LITTLE_ENDIAN__\n+\tlbz %r3, RETVAL+0(%r1)\n+# else\n+\tlbz %r3, RETVAL+7(%r1)\n+# endif\n \tmtlr %r0\n-\taddi %r1, %r1, 240\n+\taddi %r1, %r1, STACKFRAME\n \tblr\n # case FFI_TYPE_SINT8\n-#ifdef __LITTLE_ENDIAN__\n-\tlbz %r3, 112+0(%r1)\n-#else\n-\tlbz %r3, 112+7(%r1)\n-#endif\n+# ifdef __LITTLE_ENDIAN__\n+\tlbz %r3, RETVAL+0(%r1)\n+# else\n+\tlbz %r3, RETVAL+7(%r1)\n+# endif\n \textsb %r3,%r3\n \tmtlr %r0\n \tb .Lfinish\n # case FFI_TYPE_UINT16\n-#ifdef __LITTLE_ENDIAN__\n-\tlhz %r3, 112+0(%r1)\n-#else\n-\tlhz %r3, 112+6(%r1)\n-#endif\n+# ifdef __LITTLE_ENDIAN__\n+\tlhz %r3, RETVAL+0(%r1)\n+# else\n+\tlhz %r3, RETVAL+6(%r1)\n+# endif\n \tmtlr %r0\n .Lfinish:\n-\taddi %r1, %r1, 240\n+\taddi %r1, %r1, STACKFRAME\n \tblr\n # case FFI_TYPE_SINT16\n-#ifdef __LITTLE_ENDIAN__\n-\tlha %r3, 112+0(%r1)\n-#else\n-\tlha %r3, 112+6(%r1)\n-#endif\n+# ifdef __LITTLE_ENDIAN__\n+\tlha %r3, RETVAL+0(%r1)\n+# else\n+\tlha %r3, RETVAL+6(%r1)\n+# endif\n \tmtlr %r0\n-\taddi %r1, %r1, 240\n+\taddi %r1, %r1, STACKFRAME\n \tblr\n # case FFI_TYPE_UINT32\n-#ifdef __LITTLE_ENDIAN__\n-\tlwz %r3, 112+0(%r1)\n-#else\n-\tlwz %r3, 112+4(%r1)\n-#endif\n+# ifdef __LITTLE_ENDIAN__\n+\tlwz %r3, RETVAL+0(%r1)\n+# else\n+\tlwz %r3, RETVAL+4(%r1)\n+# endif\n \tmtlr %r0\n-\taddi %r1, %r1, 240\n+\taddi %r1, %r1, STACKFRAME\n \tblr\n # case FFI_TYPE_SINT32\n-#ifdef __LITTLE_ENDIAN__\n-\tlwa %r3, 112+0(%r1)\n-#else\n-\tlwa %r3, 112+4(%r1)\n-#endif\n+# ifdef __LITTLE_ENDIAN__\n+\tlwa %r3, RETVAL+0(%r1)\n+# else\n+\tlwa %r3, RETVAL+4(%r1)\n+# endif\n \tmtlr %r0\n-\taddi %r1, %r1, 240\n+\taddi %r1, %r1, STACKFRAME\n \tblr\n # case FFI_TYPE_UINT64\n-\tld %r3, 112+0(%r1)\n+\tld %r3, RETVAL+0(%r1)\n \tmtlr %r0\n-\taddi %r1, %r1, 240\n+\taddi %r1, %r1, STACKFRAME\n \tblr\n # case FFI_TYPE_SINT64\n-\tld %r3, 112+0(%r1)\n+\tld %r3, RETVAL+0(%r1)\n \tmtlr %r0\n-\taddi %r1, %r1, 240\n+\taddi %r1, %r1, STACKFRAME\n \tblr\n # case FFI_TYPE_STRUCT\n \tmtlr %r0\n-\taddi %r1, %r1, 240\n+\taddi %r1, %r1, STACKFRAME\n \tblr\n \tnop\n # case FFI_TYPE_POINTER\n-\tld %r3, 112+0(%r1)\n+\tld %r3, RETVAL+0(%r1)\n+\tmtlr %r0\n+\taddi %r1, %r1, STACKFRAME\n+\tblr\n+# case FFI_V2_TYPE_FLOAT_HOMOG\n+\tlfs %f1, RETVAL+0(%r1)\n+\tlfs %f2, RETVAL+4(%r1)\n+\tlfs %f3, RETVAL+8(%r1)\n+\tb .Lmorefloat\n+# case FFI_V2_TYPE_DOUBLE_HOMOG\n+\tlfd %f1, RETVAL+0(%r1)\n+\tlfd %f2, RETVAL+8(%r1)\n+\tlfd %f3, RETVAL+16(%r1)\n+\tlfd %f4, RETVAL+24(%r1)\n+\tmtlr %r0\n+\tlfd %f5, RETVAL+32(%r1)\n+\tlfd %f6, RETVAL+40(%r1)\n+\tlfd %f7, RETVAL+48(%r1)\n+\tlfd %f8, RETVAL+56(%r1)\n+\taddi %r1, %r1, STACKFRAME\n+\tblr\n+.Lmorefloat:\n+\tlfs %f4, RETVAL+12(%r1)\n+\tmtlr %r0\n+\tlfs %f5, RETVAL+16(%r1)\n+\tlfs %f6, RETVAL+20(%r1)\n+\tlfs %f7, RETVAL+24(%r1)\n+\tlfs %f8, RETVAL+28(%r1)\n+\taddi %r1, %r1, STACKFRAME\n+\tblr\n+.Lsmall:\n+# ifdef __LITTLE_ENDIAN__\n+\tld %r3,RETVAL+0(%r1)\n+\tmtlr %r0\n+\tld %r4,RETVAL+8(%r1)\n+\taddi %r1, %r1, STACKFRAME\n+\tblr\n+# else\n+\t# A struct smaller than a dword is returned in the low bits of r3\n+\t# ie. right justified.  Larger structs are passed left justified\n+\t# in r3 and r4.  The return value area on the stack will have\n+\t# the structs as they are usually stored in memory.\n+\tcmpldi %r3, FFI_V2_TYPE_SMALL_STRUCT + 7 # size 8 bytes?\n+\tneg %r5, %r3\n+\tld %r3,RETVAL+0(%r1)\n+\tblt .Lsmalldown\n+\tmtlr %r0\n+\tld %r4,RETVAL+8(%r1)\n+\taddi %r1, %r1, STACKFRAME\n+\tblr\n+.Lsmalldown:\n+\taddi %r5, %r5, FFI_V2_TYPE_SMALL_STRUCT + 7\n \tmtlr %r0\n-\taddi %r1, %r1, 240\n+\tsldi %r5, %r5, 3\n+\taddi %r1, %r1, STACKFRAME\n+\tsrd %r3, %r3, %r5\n \tblr\n-# esac\n+# endif\n+\n .LFE1:\n \t.long\t0\n \t.byte\t0,12,0,1,128,0,0,0\n-#ifdef _CALL_LINUX\n+# if _CALL_ELF == 2\n+\t.size\tffi_closure_LINUX64,.-ffi_closure_LINUX64\n+# else\n+#  ifdef _CALL_LINUX\n \t.size\tffi_closure_LINUX64,.-.L.ffi_closure_LINUX64\n-#else\n+#  else\n \t.size\t.ffi_closure_LINUX64,.-.ffi_closure_LINUX64\n-#endif\n+#  endif\n+# endif\n \n \t.section\t.eh_frame,EH_FRAME_FLAGS,@progbits\n .Lframe1:\n@@ -267,14 +376,14 @@ ffi_closure_LINUX64:\n \t.byte\t0x2\t # DW_CFA_advance_loc1\n \t.byte\t.LCFI0-.LFB1\n \t.byte\t0xe\t # DW_CFA_def_cfa_offset\n-\t.uleb128 240\n+\t.uleb128 STACKFRAME\n \t.byte\t0x11\t # DW_CFA_offset_extended_sf\n \t.uleb128 0x41\n \t.sleb128 -2\n \t.align 3\n .LEFDE1:\n-#endif\n \n-#if defined __ELF__ && defined __linux__\n+# if defined __ELF__ && defined __linux__\n \t.section\t.note.GNU-stack,\"\",@progbits\n+# endif\n #endif"}, {"sha": "e077f92b8638398efdf87211f0ef5af26c8978cc", "filename": "libffi/testsuite/libffi.call/cls_double_va.c", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3521ba8b2e5c974c021853b2b829313029b4eda8/libffi%2Ftestsuite%2Flibffi.call%2Fcls_double_va.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3521ba8b2e5c974c021853b2b829313029b4eda8/libffi%2Ftestsuite%2Flibffi.call%2Fcls_double_va.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_double_va.c?ref=3521ba8b2e5c974c021853b2b829313029b4eda8", "patch": "@@ -38,26 +38,24 @@ int main (void)\n \n \t/* This printf call is variadic */\n \tCHECK(ffi_prep_cif_var(&cif, FFI_DEFAULT_ABI, 1, 2, &ffi_type_sint,\n-\t\targ_types) == FFI_OK);\n+\t\t\t       arg_types) == FFI_OK);\n \n \targs[0] = &format;\n \targs[1] = &doubleArg;\n \targs[2] = NULL;\n \n \tffi_call(&cif, FFI_FN(printf), &res, args);\n-\t// { dg-output \"7.0\" }\n+\t/* { dg-output \"7.0\" } */\n \tprintf(\"res: %d\\n\", (int) res);\n-\t// { dg-output \"\\nres: 4\" }\n+\t/* { dg-output \"\\nres: 4\" } */\n \n-\t/* The call to cls_double_va_fn is static, so have to use a normal prep_cif */\n-\tCHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 2, &ffi_type_sint, arg_types) == FFI_OK);\n+\tCHECK(ffi_prep_closure_loc(pcl, &cif, cls_double_va_fn, NULL,\n+\t\t\t\t   code) == FFI_OK);\n \n-\tCHECK(ffi_prep_closure_loc(pcl, &cif, cls_double_va_fn, NULL, code) == FFI_OK);\n-\n-\tres\t= ((int(*)(char*, double))(code))(format, doubleArg);\n-\t// { dg-output \"\\n7.0\" }\n+\tres = ((int(*)(char*, ...))(code))(format, doubleArg);\n+\t/* { dg-output \"\\n7.0\" } */\n \tprintf(\"res: %d\\n\", (int) res);\n-\t// { dg-output \"\\nres: 4\" }\n+\t/* { dg-output \"\\nres: 4\" } */\n \n \texit(0);\n }"}, {"sha": "39b438b289a85e4c8b24cde34c29ef42b895e5dd", "filename": "libffi/testsuite/libffi.call/cls_longdouble_va.c", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3521ba8b2e5c974c021853b2b829313029b4eda8/libffi%2Ftestsuite%2Flibffi.call%2Fcls_longdouble_va.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3521ba8b2e5c974c021853b2b829313029b4eda8/libffi%2Ftestsuite%2Flibffi.call%2Fcls_longdouble_va.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_longdouble_va.c?ref=3521ba8b2e5c974c021853b2b829313029b4eda8", "patch": "@@ -38,27 +38,24 @@ int main (void)\n \n \t/* This printf call is variadic */\n \tCHECK(ffi_prep_cif_var(&cif, FFI_DEFAULT_ABI, 1, 2, &ffi_type_sint,\n-\t\targ_types) == FFI_OK);\n+\t\t\t       arg_types) == FFI_OK);\n \n \targs[0] = &format;\n \targs[1] = &ldArg;\n \targs[2] = NULL;\n \n \tffi_call(&cif, FFI_FN(printf), &res, args);\n-\t// { dg-output \"7.0\" }\n+\t/* { dg-output \"7.0\" } */\n \tprintf(\"res: %d\\n\", (int) res);\n-\t// { dg-output \"\\nres: 4\" }\n+\t/* { dg-output \"\\nres: 4\" } */\n \n-\t/* The call to cls_longdouble_va_fn is static, so have to use a normal prep_cif */\n-\tCHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 2, &ffi_type_sint,\n-\t\targ_types) == FFI_OK);\n+\tCHECK(ffi_prep_closure_loc(pcl, &cif, cls_longdouble_va_fn, NULL,\n+\t\t\t\t   code) == FFI_OK);\n \n-\tCHECK(ffi_prep_closure_loc(pcl, &cif, cls_longdouble_va_fn, NULL, code) == FFI_OK);\n-\n-\tres\t= ((int(*)(char*, long double))(code))(format, ldArg);\n-\t// { dg-output \"\\n7.0\" }\n+\tres = ((int(*)(char*, ...))(code))(format, ldArg);\n+\t/* { dg-output \"\\n7.0\" } */\n \tprintf(\"res: %d\\n\", (int) res);\n-\t// { dg-output \"\\nres: 4\" }\n+\t/* { dg-output \"\\nres: 4\" } */\n \n \texit(0);\n }"}]}