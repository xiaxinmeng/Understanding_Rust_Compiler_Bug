{"sha": "225a658415367be2700835fec916c091cd6a6945", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjI1YTY1ODQxNTM2N2JlMjcwMDgzNWZlYzkxNmMwOTFjZDZhNjk0NQ==", "commit": {"author": {"name": "Gabriel Dos Reis", "email": "gdr@cs.tamu.edu", "date": "2010-10-27T20:11:29Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2010-10-27T20:11:29Z"}, "message": "method.c (synthesized_method_walk): Track constexprness too.\n\n\t* method.c (synthesized_method_walk): Track constexprness too.\n\t(process_subob_fn, walk_field_subobs): Likewise.\n\t(implicitly_declare_fn): Set DECL_DECLARED_CONSTEXPR_P.\n\t(defaulted_late_check): Handle DECL_DECLARED_CONSTEXPR_P.\n\t* class.c (add_implicitly_declared_members): Handle\n\tconstexpr default ctor.\n\nCo-Authored-By: Jason Merrill <jason@redhat.com>\n\nFrom-SVN: r166014", "tree": {"sha": "cfac62de4f33a49459c45849153f2c9b3bc6419c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cfac62de4f33a49459c45849153f2c9b3bc6419c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/225a658415367be2700835fec916c091cd6a6945", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/225a658415367be2700835fec916c091cd6a6945", "html_url": "https://github.com/Rust-GCC/gccrs/commit/225a658415367be2700835fec916c091cd6a6945", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/225a658415367be2700835fec916c091cd6a6945/comments", "author": null, "committer": null, "parents": [{"sha": "91ea6df357db9c986090683aa22cfa1ea2547213", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91ea6df357db9c986090683aa22cfa1ea2547213", "html_url": "https://github.com/Rust-GCC/gccrs/commit/91ea6df357db9c986090683aa22cfa1ea2547213"}], "stats": {"total": 158, "additions": 114, "deletions": 44}, "files": [{"sha": "8402c72023612fb92c941822905df1886ab1abe2", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/225a658415367be2700835fec916c091cd6a6945/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/225a658415367be2700835fec916c091cd6a6945/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=225a658415367be2700835fec916c091cd6a6945", "patch": "@@ -1,6 +1,13 @@\n 2010-10-27  Gabriel Dos Reis  <gdr@cse.tamu.edu>\n \t    Jason Merrill  <jason@redhat.com>\n \n+\t* method.c (synthesized_method_walk): Track constexprness too.\n+\t(process_subob_fn, walk_field_subobs): Likewise.\n+\t(implicitly_declare_fn): Set DECL_DECLARED_CONSTEXPR_P.\n+\t(defaulted_late_check): Handle DECL_DECLARED_CONSTEXPR_P.\n+\t* class.c (add_implicitly_declared_members): Handle\n+\tconstexpr default ctor.\n+\n \t* parser.c (cp_parser_ctor_initializer_opt_and_function_body):\n \tMake sure a constexpr ctor has an empty body.\n \t* class.c (type_has_constexpr_default_constructor): New."}, {"sha": "a31aad3aba794c3a696e9dd19680ad0aba000049", "filename": "gcc/cp/class.c", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/225a658415367be2700835fec916c091cd6a6945/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/225a658415367be2700835fec916c091cd6a6945/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=225a658415367be2700835fec916c091cd6a6945", "patch": "@@ -2672,7 +2672,20 @@ add_implicitly_declared_members (tree t,\n   if (! TYPE_HAS_USER_CONSTRUCTOR (t))\n     {\n       TYPE_HAS_DEFAULT_CONSTRUCTOR (t) = 1;\n-      CLASSTYPE_LAZY_DEFAULT_CTOR (t) = 1;\n+      if (TYPE_HAS_TRIVIAL_DFLT (t))\n+\t{\n+\t  /* A trivial default constructor is constexpr\n+\t     if there is nothing to initialize.  */\n+\t  if (cxx_dialect >= cxx0x && is_really_empty_class (t))\n+\t    TYPE_HAS_CONSTEXPR_CTOR (t) = 1;\n+\t  CLASSTYPE_LAZY_DEFAULT_CTOR (t) = 1;\n+\t}\n+      else if (cxx_dialect >= cxx0x)\n+\t/* We need to go ahead and declare this to set\n+\t   TYPE_HAS_CONSTEXPR_CTOR.  */\n+\tlazily_declare_fn (sfk_constructor, t);\n+      else\n+\tCLASSTYPE_LAZY_DEFAULT_CTOR (t) = 1;\n     }\n \n   /* [class.ctor]"}, {"sha": "6687c75f2a338f18eff414de3f525651c5eef5b0", "filename": "gcc/cp/method.c", "status": "modified", "additions": 90, "deletions": 43, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/225a658415367be2700835fec916c091cd6a6945/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/225a658415367be2700835fec916c091cd6a6945/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=225a658415367be2700835fec916c091cd6a6945", "patch": "@@ -903,7 +903,8 @@ get_copy_assign (tree type)\n \n static void\n process_subob_fn (tree fn, bool move_p, tree *spec_p, bool *trivial_p,\n-\t\t  bool *deleted_p, const char *msg, tree arg)\n+\t\t  bool *deleted_p, bool *constexpr_p,\n+\t\t  const char *msg, tree arg)\n {\n   if (!fn || fn == error_mark_node)\n     goto bad;\n@@ -935,6 +936,9 @@ process_subob_fn (tree fn, bool move_p, tree *spec_p, bool *trivial_p,\n       goto bad;\n     }\n \n+  if (constexpr_p && !DECL_DECLARED_CONSTEXPR_P (fn))\n+    *constexpr_p = false;\n+\n   return;\n \n  bad:\n@@ -949,7 +953,7 @@ static void\n walk_field_subobs (tree fields, tree fnname, special_function_kind sfk,\n \t\t   int quals, bool copy_arg_p, bool move_p,\n \t\t   bool assign_p, tree *spec_p, bool *trivial_p,\n-\t\t   bool *deleted_p, const char *msg,\n+\t\t   bool *deleted_p, bool *constexpr_p, const char *msg,\n \t\t   int flags, tsubst_flags_t complain)\n {\n   tree field;\n@@ -1005,6 +1009,13 @@ walk_field_subobs (tree fields, tree fnname, special_function_kind sfk,\n \n \t  if (bad && deleted_p)\n \t    *deleted_p = true;\n+\n+\t  /* For an implicitly-defined default constructor to be constexpr,\n+\t     every member must have a user-provided default constructor.  */\n+\t  /* FIXME will need adjustment for non-static data member\n+\t     initializers.  */\n+\t  if (constexpr_p && !CLASS_TYPE_P (mem_type))\n+\t    *constexpr_p = false;\n \t}\n \n       if (!CLASS_TYPE_P (mem_type))\n@@ -1014,7 +1025,7 @@ walk_field_subobs (tree fields, tree fnname, special_function_kind sfk,\n \t{\n \t  walk_field_subobs (TYPE_FIELDS (mem_type), fnname, sfk, quals,\n \t\t\t     copy_arg_p, move_p, assign_p, spec_p, trivial_p,\n-\t\t\t     deleted_p, msg, flags, complain);\n+\t\t\t     deleted_p, constexpr_p, msg, flags, complain);\n \t  continue;\n \t}\n \n@@ -1031,7 +1042,7 @@ walk_field_subobs (tree fields, tree fnname, special_function_kind sfk,\n       rval = locate_fn_flags (mem_type, fnname, argtype, flags, complain);\n \n       process_subob_fn (rval, move_p, spec_p, trivial_p, deleted_p,\n-\t\t\tmsg, field);\n+\t\t\tconstexpr_p, msg, field);\n     }\n }\n \n@@ -1044,7 +1055,7 @@ walk_field_subobs (tree fields, tree fnname, special_function_kind sfk,\n static void\n synthesized_method_walk (tree ctype, special_function_kind sfk, bool const_p,\n \t\t\t tree *spec_p, bool *trivial_p, bool *deleted_p,\n-\t\t\t bool diag)\n+\t\t\t bool *constexpr_p, bool diag)\n {\n   tree binfo, base_binfo, scope, fnname, rval, argtype;\n   bool move_p, copy_arg_p, assign_p, expected_trivial, check_vdtor;\n@@ -1078,6 +1089,41 @@ synthesized_method_walk (tree ctype, special_function_kind sfk, bool const_p,\n       *deleted_p = false;\n     }\n \n+  ctor_p = false;\n+  assign_p = false;\n+  check_vdtor = false;\n+  switch (sfk)\n+    {\n+    case sfk_move_assignment:\n+    case sfk_copy_assignment:\n+      assign_p = true;\n+      fnname = ansi_assopname (NOP_EXPR);\n+      break;\n+\n+    case sfk_destructor:\n+      check_vdtor = true;\n+      /* The synthesized method will call base dtors, but check complete\n+\t here to avoid having to deal with VTT.  */\n+      fnname = complete_dtor_identifier;\n+      break;\n+\n+    case sfk_constructor:\n+    case sfk_move_constructor:\n+    case sfk_copy_constructor:\n+      ctor_p = true;\n+      fnname = complete_ctor_identifier;\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  /* If that user-written default constructor would satisfy the\n+     requirements of a constexpr constructor (7.1.5), the\n+     implicitly-defined default constructor is constexpr.  */\n+  if (constexpr_p)\n+    *constexpr_p = ctor_p;\n+\n   move_p = false;\n   switch (sfk)\n     {\n@@ -1114,35 +1160,6 @@ synthesized_method_walk (tree ctype, special_function_kind sfk, bool const_p,\n     return;\n #endif\n \n-  ctor_p = false;\n-  assign_p = false;\n-  check_vdtor = false;\n-  switch (sfk)\n-    {\n-    case sfk_move_assignment:\n-    case sfk_copy_assignment:\n-      assign_p = true;\n-      fnname = ansi_assopname (NOP_EXPR);\n-      break;\n-\n-    case sfk_destructor:\n-      check_vdtor = true;\n-      /* The synthesized method will call base dtors, but check complete\n-\t here to avoid having to deal with VTT.  */\n-      fnname = complete_dtor_identifier;\n-      break;\n-\n-    case sfk_constructor:\n-    case sfk_move_constructor:\n-    case sfk_copy_constructor:\n-      ctor_p = true;\n-      fnname = complete_ctor_identifier;\n-      break;\n-\n-    default:\n-      gcc_unreachable ();\n-    }\n-\n   ++cp_unevaluated_operand;\n   ++c_inhibit_evaluation_warnings;\n \n@@ -1183,15 +1200,16 @@ synthesized_method_walk (tree ctype, special_function_kind sfk, bool const_p,\n       rval = locate_fn_flags (base_binfo, fnname, argtype, flags, complain);\n \n       process_subob_fn (rval, move_p, spec_p, trivial_p, deleted_p,\n-\t\t\tmsg, basetype);\n+\t\t\tconstexpr_p, msg, basetype);\n       if (ctor_p && TYPE_HAS_NONTRIVIAL_DESTRUCTOR (basetype))\n \t{\n \t  /* In a constructor we also need to check the subobject\n \t     destructors for cleanup of partially constructed objects.  */\n \t  rval = locate_fn_flags (base_binfo, complete_dtor_identifier,\n \t\t\t\t  NULL_TREE, flags, complain);\n \t  process_subob_fn (rval, false, &cleanup_spec, &cleanup_trivial,\n-\t\t\t    &cleanup_deleted, NULL, basetype);\n+\t\t\t    &cleanup_deleted, NULL, NULL,\n+\t\t\t    basetype);\n \t}\n \n       if (check_vdtor && type_has_virtual_destructor (basetype))\n@@ -1221,6 +1239,8 @@ synthesized_method_walk (tree ctype, special_function_kind sfk, bool const_p,\n       if (diag)\n \tmsg = (\"virtual base %qT does not have a move constructor \"\n \t       \"or trivial copy constructor\");\n+      if (vbases && constexpr_p)\n+\t*constexpr_p = false;\n       FOR_EACH_VEC_ELT (tree, vbases, i, base_binfo)\n \t{\n \t  tree basetype = BINFO_TYPE (base_binfo);\n@@ -1229,13 +1249,14 @@ synthesized_method_walk (tree ctype, special_function_kind sfk, bool const_p,\n \t  rval = locate_fn_flags (base_binfo, fnname, argtype, flags, complain);\n \n \t  process_subob_fn (rval, move_p, spec_p, trivial_p, deleted_p,\n-\t\t\t    msg, basetype);\n+\t\t\t    constexpr_p, msg, basetype);\n \t  if (ctor_p && TYPE_HAS_NONTRIVIAL_DESTRUCTOR (basetype))\n \t    {\n \t      rval = locate_fn_flags (base_binfo, complete_dtor_identifier,\n \t\t\t\t      NULL_TREE, flags, complain);\n \t      process_subob_fn (rval, false, &cleanup_spec, &cleanup_trivial,\n-\t\t\t\t&cleanup_deleted, NULL, basetype);\n+\t\t\t\t&cleanup_deleted, NULL, NULL,\n+\t\t\t\tbasetype);\n \t    }\n \t}\n     }\n@@ -1249,12 +1270,13 @@ synthesized_method_walk (tree ctype, special_function_kind sfk, bool const_p,\n \t   \"constructor or trivial copy constructor\");\n   walk_field_subobs (TYPE_FIELDS (ctype), fnname, sfk, quals,\n \t\t     copy_arg_p, move_p, assign_p, spec_p, trivial_p,\n-\t\t     deleted_p, msg, flags, complain);\n+\t\t     deleted_p, constexpr_p, msg, flags, complain);\n   if (ctor_p)\n     walk_field_subobs (TYPE_FIELDS (ctype), complete_dtor_identifier,\n \t\t       sfk_destructor, TYPE_UNQUALIFIED, false,\n \t\t       false, false, &cleanup_spec, &cleanup_trivial,\n-\t\t       &cleanup_deleted, NULL, flags, complain);\n+\t\t       &cleanup_deleted, NULL,\n+\t\t       NULL, flags, complain);\n \n   pop_scope (scope);\n \n@@ -1333,7 +1355,7 @@ maybe_explain_implicit_delete (tree decl)\n \t\t \"definition would be ill-formed:\", decl);\n \t  pop_scope (scope);\n \t  synthesized_method_walk (ctype, sfk, const_p,\n-\t\t\t\t   NULL, NULL, NULL, true);\n+\t\t\t\t   NULL, NULL, NULL, NULL, true);\n \t}\n \n       input_location = loc;\n@@ -1362,6 +1384,7 @@ implicitly_declare_fn (special_function_kind kind, tree type, bool const_p)\n   HOST_WIDE_INT saved_processing_template_decl;\n   bool deleted_p;\n   bool trivial_p;\n+  bool constexpr_p;\n \n   /* Because we create declarations for implicitly declared functions\n      lazily, we may be creating the declaration for a member of TYPE\n@@ -1431,7 +1454,15 @@ implicitly_declare_fn (special_function_kind kind, tree type, bool const_p)\n     }\n \n   synthesized_method_walk (type, kind, const_p, &raises, &trivial_p,\n-\t\t\t   &deleted_p, false);\n+\t\t\t   &deleted_p, &constexpr_p, false);\n+  /* Don't bother marking a deleted constructor as constexpr.  */\n+  if (deleted_p)\n+    constexpr_p = false;\n+  /* A trivial copy/move constructor is also a constexpr constructor.  */\n+  else if (trivial_p && cxx_dialect >= cxx0x\n+\t   && (kind == sfk_copy_constructor\n+\t       || kind == sfk_move_constructor))\n+    gcc_assert (constexpr_p);\n \n   if (!trivial_p && type_has_trivial_fn (type, kind))\n     type_set_nontrivial_flag (type, kind);\n@@ -1481,7 +1512,10 @@ implicitly_declare_fn (special_function_kind kind, tree type, bool const_p)\n   DECL_ARTIFICIAL (fn) = 1;\n   DECL_DEFAULTED_FN (fn) = 1;\n   if (cxx_dialect >= cxx0x)\n-    DECL_DELETED_FN (fn) = deleted_p;\n+    {\n+      DECL_DELETED_FN (fn) = deleted_p;\n+      DECL_DECLARED_CONSTEXPR_P (fn) = constexpr_p;\n+    }\n   DECL_NOT_REALLY_EXTERN (fn) = 1;\n   DECL_DECLARED_INLINE_P (fn) = 1;\n   gcc_assert (!TREE_USED (fn));\n@@ -1521,6 +1555,19 @@ defaulted_late_check (tree fn)\n     {\n       tree eh_spec = TYPE_RAISES_EXCEPTIONS (TREE_TYPE (implicit_fn));\n       TREE_TYPE (fn) = build_exception_variant (TREE_TYPE (fn), eh_spec);\n+      if (DECL_DECLARED_CONSTEXPR_P (implicit_fn))\n+\t/* Hmm...should we do this for out-of-class too? Should it be OK to\n+\t   add constexpr later like inline, rather than requiring\n+\t   declarations to match?  */\n+\tDECL_DECLARED_CONSTEXPR_P (fn) = true;\n+    }\n+\n+  if (!DECL_DECLARED_CONSTEXPR_P (implicit_fn)\n+      && DECL_DECLARED_CONSTEXPR_P (fn))\n+    {\n+      if (!CLASSTYPE_TEMPLATE_INSTANTIATION (ctx))\n+\terror (\"%qD cannot be declared as constexpr\", fn);\n+      DECL_DECLARED_CONSTEXPR_P (fn) = false;\n     }\n \n   if (DECL_DELETED_FN (implicit_fn))"}, {"sha": "67c9503025b5177af101a9602c64e06b555ff64a", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-delete.C", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/225a658415367be2700835fec916c091cd6a6945/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-delete.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/225a658415367be2700835fec916c091cd6a6945/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-delete.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-delete.C?ref=225a658415367be2700835fec916c091cd6a6945", "patch": "@@ -0,0 +1,3 @@\n+// { dg-options -std=c++0x }\n+\n+constexpr bool never() = delete; // useless, but OK"}]}