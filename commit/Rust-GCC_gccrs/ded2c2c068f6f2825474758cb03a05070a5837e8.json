{"sha": "ded2c2c068f6f2825474758cb03a05070a5837e8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGVkMmMyYzA2OGY2ZjI4MjU0NzQ3NThjYjAzYTA1MDcwYTU4MzdlOA==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2021-08-04T22:21:21Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2021-08-04T22:21:25Z"}, "message": "analyzer: initial implementation of asm support [PR101570]\n\ngcc/ChangeLog:\n\tPR analyzer/101570\n\t* Makefile.in (ANALYZER_OBJS): Add analyzer/region-model-asm.o.\n\ngcc/analyzer/ChangeLog:\n\tPR analyzer/101570\n\t* analyzer.cc (maybe_reconstruct_from_def_stmt): Add GIMPLE_ASM\n\tcase.\n\t* analyzer.h (class asm_output_svalue): New forward decl.\n\t(class reachable_regions): New forward decl.\n\t* complexity.cc (complexity::from_vec_svalue): New.\n\t* complexity.h (complexity::from_vec_svalue): New decl.\n\t* engine.cc (feasibility_state::maybe_update_for_edge): Handle\n\tasm stmts by calling on_asm_stmt.\n\t* region-model-asm.cc: New file.\n\t* region-model-manager.cc\n\t(region_model_manager::maybe_fold_asm_output_svalue): New.\n\t(region_model_manager::get_or_create_asm_output_svalue): New.\n\t(region_model_manager::log_stats): Log m_asm_output_values_map.\n\t* region-model.cc (region_model::on_stmt_pre): Handle GIMPLE_ASM.\n\t* region-model.h (visitor::visit_asm_output_svalue): New.\n\t(region_model_manager::get_or_create_asm_output_svalue): New decl.\n\t(region_model_manager::maybe_fold_asm_output_svalue): New decl.\n\t(region_model_manager::asm_output_values_map_t): New typedef.\n\t(region_model_manager::m_asm_output_values_map): New field.\n\t(region_model::on_asm_stmt): New.\n\t* store.cc (binding_cluster::on_asm): New.\n\t* store.h (binding_cluster::on_asm): New decl.\n\t* svalue.cc (svalue::cmp_ptr): Handle SK_ASM_OUTPUT.\n\t(asm_output_svalue::dump_to_pp): New.\n\t(asm_output_svalue::dump_input): New.\n\t(asm_output_svalue::input_idx_to_asm_idx): New.\n\t(asm_output_svalue::accept): New.\n\t* svalue.h (enum svalue_kind): Add SK_ASM_OUTPUT.\n\t(svalue::dyn_cast_asm_output_svalue): New.\n\t(class asm_output_svalue): New.\n\t(is_a_helper <const asm_output_svalue *>::test): New.\n\t(struct default_hash_traits<asm_output_svalue::key_t>): New.\n\ngcc/testsuite/ChangeLog:\n\tPR analyzer/101570\n\t* gcc.dg/analyzer/asm-x86-1.c: New test.\n\t* gcc.dg/analyzer/asm-x86-lp64-1.c: New test.\n\t* gcc.dg/analyzer/asm-x86-lp64-2.c: New test.\n\t* gcc.dg/analyzer/pr101570.c: New test.\n\t* gcc.dg/analyzer/torture/asm-x86-linux-array_index_mask_nospec.c:\n\tNew test.\n\t* gcc.dg/analyzer/torture/asm-x86-linux-cpuid-paravirt-1.c: New\n\ttest.\n\t* gcc.dg/analyzer/torture/asm-x86-linux-cpuid-paravirt-2.c: New\n\ttest.\n\t* gcc.dg/analyzer/torture/asm-x86-linux-cpuid.c: New test.\n\t* gcc.dg/analyzer/torture/asm-x86-linux-rdmsr-paravirt.c: New\n\ttest.\n\t* gcc.dg/analyzer/torture/asm-x86-linux-rdmsr.c: New test.\n\t* gcc.dg/analyzer/torture/asm-x86-linux-wfx_get_ps_timeout-full.c:\n\tNew test.\n\t* gcc.dg/analyzer/torture/asm-x86-linux-wfx_get_ps_timeout-reduced.c:\n\tNew test.\n\nSigned-off-by: David Malcolm <dmalcolm@redhat.com>", "tree": {"sha": "5d806e4f9435ad7d88d4ba77f0104357ba0da6ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5d806e4f9435ad7d88d4ba77f0104357ba0da6ab"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ded2c2c068f6f2825474758cb03a05070a5837e8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ded2c2c068f6f2825474758cb03a05070a5837e8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ded2c2c068f6f2825474758cb03a05070a5837e8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ded2c2c068f6f2825474758cb03a05070a5837e8/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5738a64f8b3cf132b88b39af84b9f5f5a9a1554c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5738a64f8b3cf132b88b39af84b9f5f5a9a1554c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5738a64f8b3cf132b88b39af84b9f5f5a9a1554c"}], "stats": {"total": 1858, "additions": 1855, "deletions": 3}, "files": [{"sha": "c0f6e0a2e39a3c31657121a697faae2fc6b1cf62", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ded2c2c068f6f2825474758cb03a05070a5837e8/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ded2c2c068f6f2825474758cb03a05070a5837e8/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=ded2c2c068f6f2825474758cb03a05070a5837e8", "patch": "@@ -1262,6 +1262,7 @@ ANALYZER_OBJS = \\\n \tanalyzer/program-state.o \\\n \tanalyzer/region.o \\\n \tanalyzer/region-model.o \\\n+\tanalyzer/region-model-asm.o \\\n \tanalyzer/region-model-impl-calls.o \\\n \tanalyzer/region-model-manager.o \\\n \tanalyzer/region-model-reachability.o \\"}, {"sha": "557887724e8eb98c25e10b18b7b8495656f6dc42", "filename": "gcc/analyzer/analyzer.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ded2c2c068f6f2825474758cb03a05070a5837e8/gcc%2Fanalyzer%2Fanalyzer.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ded2c2c068f6f2825474758cb03a05070a5837e8/gcc%2Fanalyzer%2Fanalyzer.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fanalyzer.cc?ref=ded2c2c068f6f2825474758cb03a05070a5837e8", "patch": "@@ -131,6 +131,7 @@ maybe_reconstruct_from_def_stmt (tree ssa_name,\n     {\n     default:\n       gcc_unreachable ();\n+    case GIMPLE_ASM:\n     case GIMPLE_NOP:\n     case GIMPLE_PHI:\n       /* Can't handle these.  */"}, {"sha": "896b35075ccdd69af7729b407df39b8441b51868", "filename": "gcc/analyzer/analyzer.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ded2c2c068f6f2825474758cb03a05070a5837e8/gcc%2Fanalyzer%2Fanalyzer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ded2c2c068f6f2825474758cb03a05070a5837e8/gcc%2Fanalyzer%2Fanalyzer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fanalyzer.h?ref=ded2c2c068f6f2825474758cb03a05070a5837e8", "patch": "@@ -53,6 +53,7 @@ class svalue;\n   class widening_svalue;\n   class compound_svalue;\n   class conjured_svalue;\n+  class asm_output_svalue;\n typedef hash_set<const svalue *> svalue_set;\n class region;\n   class frame_region;\n@@ -77,6 +78,7 @@ class call_details;\n struct rejected_constraint;\n class constraint_manager;\n class equiv_class;\n+class reachable_regions;\n \n class pending_diagnostic;\n class state_change_event;"}, {"sha": "ae9f9820c6d32d84766d06e4f3fb12d9487d9d10", "filename": "gcc/analyzer/complexity.cc", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ded2c2c068f6f2825474758cb03a05070a5837e8/gcc%2Fanalyzer%2Fcomplexity.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ded2c2c068f6f2825474758cb03a05070a5837e8/gcc%2Fanalyzer%2Fcomplexity.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fcomplexity.cc?ref=ded2c2c068f6f2825474758cb03a05070a5837e8", "patch": "@@ -90,6 +90,22 @@ complexity::from_pair (const complexity &c1, const complexity &c2)\n \t\t     MAX (c1.m_max_depth, c2.m_max_depth) + 1);\n }\n \n+/* Get complexity for a new node that references the svalues in VEC.  */\n+\n+complexity\n+complexity::from_vec_svalue (const vec<const svalue *> &vec)\n+{\n+  unsigned num_nodes = 0;\n+  unsigned max_depth = 0;\n+  for (auto iter_sval : vec)\n+    {\n+      const complexity &iter_c = iter_sval->get_complexity ();\n+      num_nodes += iter_c.m_num_nodes;\n+      max_depth = MAX (max_depth, iter_c.m_max_depth);\n+    }\n+  return complexity (num_nodes + 1, max_depth + 1);\n+}\n+\n } // namespace ana\n \n #endif /* #if ENABLE_ANALYZER */"}, {"sha": "85c03721e3a6acbda6ab853dead9baeeff495a5e", "filename": "gcc/analyzer/complexity.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ded2c2c068f6f2825474758cb03a05070a5837e8/gcc%2Fanalyzer%2Fcomplexity.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ded2c2c068f6f2825474758cb03a05070a5837e8/gcc%2Fanalyzer%2Fcomplexity.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fcomplexity.h?ref=ded2c2c068f6f2825474758cb03a05070a5837e8", "patch": "@@ -36,6 +36,7 @@ struct complexity\n   complexity (const region *reg);\n   complexity (const svalue *sval);\n   static complexity from_pair (const complexity &c1, const complexity &c);\n+  static complexity from_vec_svalue (const vec<const svalue *> &vec);\n \n   /* The total number of svalues and regions in the tree of this\n      entity, including the entity itself.  */"}, {"sha": "ecd4265733ba96f83749ae840b037bf918511c6d", "filename": "gcc/analyzer/engine.cc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ded2c2c068f6f2825474758cb03a05070a5837e8/gcc%2Fanalyzer%2Fengine.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ded2c2c068f6f2825474758cb03a05070a5837e8/gcc%2Fanalyzer%2Fengine.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fengine.cc?ref=ded2c2c068f6f2825474758cb03a05070a5837e8", "patch": "@@ -3718,6 +3718,8 @@ feasibility_state::maybe_update_for_edge (logger *logger,\n \n       if (const gassign *assign = dyn_cast <const gassign *> (stmt))\n \tm_model.on_assignment (assign, NULL);\n+      else if (const gasm *asm_stmt = dyn_cast <const gasm *> (stmt))\n+\tm_model.on_asm_stmt (asm_stmt, NULL);\n       else if (const gcall *call = dyn_cast <const gcall *> (stmt))\n \t{\n \t  bool terminate_path;"}, {"sha": "3efc3fd426a26d1d5db4e4036a2e8fe2e486714a", "filename": "gcc/analyzer/region-model-asm.cc", "status": "added", "additions": 303, "deletions": 0, "changes": 303, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ded2c2c068f6f2825474758cb03a05070a5837e8/gcc%2Fanalyzer%2Fregion-model-asm.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ded2c2c068f6f2825474758cb03a05070a5837e8/gcc%2Fanalyzer%2Fregion-model-asm.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model-asm.cc?ref=ded2c2c068f6f2825474758cb03a05070a5837e8", "patch": "@@ -0,0 +1,303 @@\n+/* Handling inline asm in the analyzer.\n+   Copyright (C) 2021 Free Software Foundation, Inc.\n+   Contributed by David Malcolm <dmalcolm@redhat.com>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tree.h\"\n+#include \"function.h\"\n+#include \"basic-block.h\"\n+#include \"gimple.h\"\n+#include \"gimple-iterator.h\"\n+#include \"diagnostic-core.h\"\n+#include \"pretty-print.h\"\n+#include \"tristate.h\"\n+#include \"selftest.h\"\n+#include \"json.h\"\n+#include \"analyzer/analyzer.h\"\n+#include \"analyzer/analyzer-logging.h\"\n+#include \"options.h\"\n+#include \"analyzer/call-string.h\"\n+#include \"analyzer/program-point.h\"\n+#include \"analyzer/store.h\"\n+#include \"analyzer/region-model.h\"\n+#include \"analyzer/region-model-reachability.h\"\n+#include \"stmt.h\"\n+\n+#if ENABLE_ANALYZER\n+\n+namespace ana {\n+\n+/* Minimal asm support for the analyzer.\n+\n+   The objective of this code is to:\n+   - minimize false positives from the analyzer on the Linux kernel\n+   (which makes heavy use of inline asm), whilst\n+   - avoiding having to \"teach\" the compiler anything about specific strings\n+   in asm statements.\n+\n+   Specifically, we want to:\n+\n+   (a) mark asm outputs and certain other regions as having been written to,\n+       to avoid false postives from -Wanalyzer-use-of-uninitialized-value.\n+\n+   (b) identify some of these stmts as \"deterministic\" so that we can\n+       write consistent outputs given consistent inputs, so that we can\n+       avoid false positives for paths in which an asm is invoked twice\n+       with the same inputs and is expected to emit the same output.\n+\n+   This file implements heuristics for achieving the above.  */\n+\n+/* Determine if ASM_STMT is deterministic, in the sense of (b) above.\n+\n+   Consider this x86 function taken from the Linux kernel\n+   (arch/x86/include/asm/barrier.h):\n+\n+     static inline unsigned long array_index_mask_nospec(unsigned long index,\n+\t\t\t\t\t\t\t unsigned long size)\n+     {\n+       unsigned long mask;\n+\n+       asm volatile (\"cmp %1,%2; sbb %0,%0;\"\n+\t\t     :\"=r\" (mask)\n+\t\t     :\"g\"(size),\"r\" (index)\n+\t\t     :\"cc\");\n+       return mask;\n+     }\n+\n+   The above is a mitigation for Spectre-variant-1 attacks, for clamping\n+   an array access to within the range of [0, size] if the CPU speculates\n+   past the array bounds.\n+\n+   However, it is ultimately used to implement wdev_to_wvif:\n+\n+     static inline struct wfx_vif *\n+     wdev_to_wvif(struct wfx_dev *wdev, int vif_id)\n+     {\n+       vif_id = array_index_nospec(vif_id, ARRAY_SIZE(wdev->vif));\n+       if (!wdev->vif[vif_id]) {\n+\t return NULL;\n+       }\n+       return (struct wfx_vif *)wdev->vif[vif_id]->drv_priv;\n+     }\n+\n+   which is used by:\n+\n+     if (wdev_to_wvif(wvif->wdev, 1))\n+       return wdev_to_wvif(wvif->wdev, 1)->vif;\n+\n+   The code has been written to assume that wdev_to_wvif is deterministic,\n+   and won't change from returning non-NULL at the \"if\" clause to\n+   returning NULL at the \"->vif\" dereference.\n+\n+   By treating the above specific \"asm volatile\" as deterministic we avoid\n+   a false positive from -Wanalyzer-null-dereference.  */\n+\n+static bool\n+deterministic_p (const gasm *asm_stmt)\n+{\n+  /* Assume something volatile with no inputs is querying\n+     changeable state e.g. rdtsc.  */\n+  if (gimple_asm_ninputs (asm_stmt) == 0\n+      && gimple_asm_volatile_p (asm_stmt))\n+    return false;\n+\n+  /* Otherwise assume it's purely a function of its inputs.  */\n+  return true;\n+}\n+\n+/* Update this model for the asm STMT, using CTXT to report any\n+   diagnostics.\n+\n+   Compare with cfgexpand.c: expand_asm_stmt.  */\n+\n+void\n+region_model::on_asm_stmt (const gasm *stmt, region_model_context *ctxt)\n+{\n+  logger *logger = ctxt ? ctxt->get_logger () : NULL;\n+  LOG_SCOPE (logger);\n+\n+  const unsigned noutputs = gimple_asm_noutputs (stmt);\n+  const unsigned ninputs = gimple_asm_ninputs (stmt);\n+\n+  auto_vec<tree> output_tvec;\n+  auto_vec<tree> input_tvec;\n+  auto_vec<const char *> constraints;\n+\n+  /* Copy the gimple vectors into new vectors that we can manipulate.  */\n+  output_tvec.safe_grow (noutputs, true);\n+  input_tvec.safe_grow (ninputs, true);\n+  constraints.safe_grow (noutputs + ninputs, true);\n+\n+  for (unsigned i = 0; i < noutputs; ++i)\n+    {\n+      tree t = gimple_asm_output_op (stmt, i);\n+      output_tvec[i] = TREE_VALUE (t);\n+      constraints[i] = TREE_STRING_POINTER (TREE_VALUE (TREE_PURPOSE (t)));\n+    }\n+  for (unsigned i = 0; i < ninputs; i++)\n+    {\n+      tree t = gimple_asm_input_op (stmt, i);\n+      input_tvec[i] = TREE_VALUE (t);\n+      constraints[i + noutputs]\n+\t= TREE_STRING_POINTER (TREE_VALUE (TREE_PURPOSE (t)));\n+    }\n+\n+  /* Determine which regions are reachable from the inputs\n+     to this stmt.  */\n+  reachable_regions reachable_regs (this);\n+\n+  int num_errors = 0;\n+\n+  auto_vec<const region *> output_regions (noutputs);\n+  for (unsigned i = 0; i < noutputs; ++i)\n+    {\n+      tree val = output_tvec[i];\n+      const char *constraint;\n+      bool is_inout;\n+      bool allows_reg;\n+      bool allows_mem;\n+\n+      const region *dst_reg = get_lvalue (val, ctxt);\n+      output_regions.quick_push (dst_reg);\n+      reachable_regs.add (dst_reg, true);\n+\n+      /* Try to parse the output constraint.  If that fails, there's\n+\t no point in going further.  */\n+      constraint = constraints[i];\n+      if (!parse_output_constraint (&constraint, i, ninputs, noutputs,\n+\t\t\t\t    &allows_mem, &allows_reg, &is_inout))\n+\t{\n+\t  if (logger)\n+\t    logger->log (\"error parsing constraint for output %i: %qs\",\n+\t\t\t i, constraint);\n+\t  num_errors++;\n+\t  continue;\n+\t}\n+\n+      if (logger)\n+\t{\n+\t  logger->log (\"output %i: %qs %qE\"\n+\t\t       \" is_inout: %i allows_reg: %i allows_mem: %i\",\n+\t\t       i, constraint, val,\n+\t\t       (int)is_inout, (int)allows_reg, (int)allows_mem);\n+\t  logger->start_log_line ();\n+\t  logger->log_partial (\"  region: \");\n+\t  dst_reg->dump_to_pp (logger->get_printer (), true);\n+\t  logger->end_log_line ();\n+\t}\n+\n+    }\n+\n+  /* Ideally should combine with inout_svals to determine the\n+     \"effective inputs\" and use this for the asm_output_svalue.  */\n+\n+  auto_vec<const svalue *> input_svals (ninputs);\n+  for (unsigned i = 0; i < ninputs; i++)\n+    {\n+      tree val = input_tvec[i];\n+      const char *constraint = constraints[i + noutputs];\n+      bool allows_reg, allows_mem;\n+      if (! parse_input_constraint (&constraint, i, ninputs, noutputs, 0,\n+\t\t\t\t    constraints.address (),\n+\t\t\t\t    &allows_mem, &allows_reg))\n+\t{\n+\t  if (logger)\n+\t    logger->log (\"error parsing constraint for input %i: %qs\",\n+\t\t\t i, constraint);\n+\t  num_errors++;\n+\t  continue;\n+\t}\n+\n+      tree src_expr = input_tvec[i];\n+      const svalue *src_sval = get_rvalue (src_expr, ctxt);\n+      check_for_poison (src_sval, src_expr, ctxt);\n+      input_svals.quick_push (src_sval);\n+      reachable_regs.handle_sval (src_sval);\n+\n+      if (logger)\n+\t{\n+\t  logger->log (\"input %i: %qs %qE\"\n+\t\t       \" allows_reg: %i allows_mem: %i\",\n+\t\t       i, constraint, val,\n+\t\t       (int)allows_reg, (int)allows_mem);\n+\t  logger->start_log_line ();\n+\t  logger->log_partial (\"  sval: \");\n+\t  src_sval->dump_to_pp (logger->get_printer (), true);\n+\t  logger->end_log_line ();\n+\t}\n+    }\n+\n+  if (num_errors > 0)\n+    gcc_unreachable ();\n+\n+  if (logger)\n+    {\n+      logger->log (\"reachability: \");\n+      reachable_regs.dump_to_pp (logger->get_printer ());\n+      logger->end_log_line ();\n+    }\n+\n+  /* Given the regions that were reachable from the inputs we\n+     want to clobber them.\n+     This is similar to region_model::handle_unrecognized_call,\n+     but the unknown call policies seems too aggressive (e.g. purging state\n+     from anything that's ever escaped).  Instead, clobber any clusters\n+     that were reachable in *this* asm stmt, rather than those that\n+     escaped, and we don't treat the values as having escaped.\n+     We also assume that asm stmts don't affect sm-state.  */\n+  for (auto iter = reachable_regs.begin_mutable_base_regs ();\n+       iter != reachable_regs.end_mutable_base_regs (); ++iter)\n+    {\n+      const region *base_reg = *iter;\n+      if (base_reg->symbolic_for_unknown_ptr_p ())\n+\tcontinue;\n+\n+      binding_cluster *cluster = m_store.get_or_create_cluster (base_reg);\n+      cluster->on_asm (stmt, m_mgr->get_store_manager ());\n+    }\n+\n+  /* Update the outputs.  */\n+  for (unsigned output_idx = 0; output_idx < noutputs; output_idx++)\n+    {\n+      tree dst_expr = output_tvec[output_idx];\n+      const region *dst_reg = output_regions[output_idx];\n+\n+      const svalue *sval;\n+      if (deterministic_p (stmt)\n+\t  && input_svals.length () <= asm_output_svalue::MAX_INPUTS)\n+\tsval = m_mgr->get_or_create_asm_output_svalue (TREE_TYPE (dst_expr),\n+\t\t\t\t\t\t       stmt,\n+\t\t\t\t\t\t       output_idx,\n+\t\t\t\t\t\t       input_svals);\n+      else\n+\t{\n+\t  sval = m_mgr->get_or_create_conjured_svalue (TREE_TYPE (dst_expr),\n+\t\t\t\t\t\t       stmt,\n+\t\t\t\t\t\t       dst_reg);\n+\t  purge_state_involving (sval, ctxt);\n+\t}\n+      set_value (dst_reg, sval, ctxt);\n+    }\n+}\n+\n+} // namespace ana\n+\n+#endif /* #if ENABLE_ANALYZER */"}, {"sha": "9e4644f2e54e99d3f9db2d6d277ff68a13c04fea", "filename": "gcc/analyzer/region-model-manager.cc", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ded2c2c068f6f2825474758cb03a05070a5837e8/gcc%2Fanalyzer%2Fregion-model-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ded2c2c068f6f2825474758cb03a05070a5837e8/gcc%2Fanalyzer%2Fregion-model-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model-manager.cc?ref=ded2c2c068f6f2825474758cb03a05070a5837e8", "patch": "@@ -1087,6 +1087,51 @@ region_model_manager::get_or_create_conjured_svalue (tree type,\n   return conjured_sval;\n }\n \n+/* Subroutine of region_model_manager::get_or_create_asm_output_svalue.\n+   Return a folded svalue, or NULL.  */\n+\n+const svalue *\n+region_model_manager::\n+maybe_fold_asm_output_svalue (tree type,\n+\t\t\t      const vec<const svalue *> &inputs)\n+{\n+  /* Unknown inputs should lead to unknown results.  */\n+  for (const auto &iter : inputs)\n+    if (iter->get_kind () == SK_UNKNOWN)\n+      return get_or_create_unknown_svalue (type);\n+\n+  return NULL;\n+}\n+\n+/* Return the svalue * of type TYPE for OUTPUT_IDX of the deterministic\n+   asm stmt ASM_STMT, given INPUTS as inputs.  */\n+\n+const svalue *\n+region_model_manager::\n+get_or_create_asm_output_svalue (tree type,\n+\t\t\t\t const gasm *asm_stmt,\n+\t\t\t\t unsigned output_idx,\n+\t\t\t\t const vec<const svalue *> &inputs)\n+{\n+  gcc_assert (inputs.length () <= asm_output_svalue::MAX_INPUTS);\n+\n+  if (const svalue *folded\n+\t= maybe_fold_asm_output_svalue (type, inputs))\n+    return folded;\n+\n+  const char *asm_string = gimple_asm_string (asm_stmt);\n+  const unsigned noutputs = gimple_asm_noutputs (asm_stmt);\n+\n+  asm_output_svalue::key_t key (type, asm_string, output_idx, inputs);\n+  if (asm_output_svalue **slot = m_asm_output_values_map.get (key))\n+    return *slot;\n+  asm_output_svalue *asm_output_sval\n+    = new asm_output_svalue (type, asm_string, output_idx, noutputs, inputs);\n+  RETURN_UNKNOWN_IF_TOO_COMPLEX (asm_output_sval);\n+  m_asm_output_values_map.put (key, asm_output_sval);\n+  return asm_output_sval;\n+}\n+\n /* Given STRING_CST, a STRING_CST and BYTE_OFFSET_CST a constant,\n    attempt to get the character at that offset, returning either\n    the svalue for the character constant, or NULL if unsuccessful.  */\n@@ -1505,6 +1550,9 @@ region_model_manager::log_stats (logger *logger, bool show_objs) const\n   log_uniq_map (logger, show_objs, \"widening_svalue\", m_widening_values_map);\n   log_uniq_map (logger, show_objs, \"compound_svalue\", m_compound_values_map);\n   log_uniq_map (logger, show_objs, \"conjured_svalue\", m_conjured_values_map);\n+  log_uniq_map (logger, show_objs, \"asm_output_svalue\",\n+\t\tm_asm_output_values_map);\n+\n   logger->log (\"max accepted svalue num_nodes: %i\",\n \t       m_max_complexity.m_num_nodes);\n   logger->log (\"max accepted svalue max_depth: %i\","}, {"sha": "58da7e3c0e49ef92280bc4d319b54e25d401a400", "filename": "gcc/analyzer/region-model.cc", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ded2c2c068f6f2825474758cb03a05070a5837e8/gcc%2Fanalyzer%2Fregion-model.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ded2c2c068f6f2825474758cb03a05070a5837e8/gcc%2Fanalyzer%2Fregion-model.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model.cc?ref=ded2c2c068f6f2825474758cb03a05070a5837e8", "patch": "@@ -980,7 +980,10 @@ region_model::on_stmt_pre (const gimple *stmt,\n       break;\n \n     case GIMPLE_ASM:\n-      /* No-op for now.  */\n+      {\n+\tconst gasm *asm_stmt = as_a <const gasm *> (stmt);\n+\ton_asm_stmt (asm_stmt, ctxt);\n+      }\n       break;\n \n     case GIMPLE_CALL:"}, {"sha": "30f02a06b62705f0ac733b6ee0d1c76f4404576c", "filename": "gcc/analyzer/region-model.h", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ded2c2c068f6f2825474758cb03a05070a5837e8/gcc%2Fanalyzer%2Fregion-model.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ded2c2c068f6f2825474758cb03a05070a5837e8/gcc%2Fanalyzer%2Fregion-model.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model.h?ref=ded2c2c068f6f2825474758cb03a05070a5837e8", "patch": "@@ -221,6 +221,7 @@ class visitor\n   virtual void visit_widening_svalue (const widening_svalue *) {}\n   virtual void visit_compound_svalue (const compound_svalue *) {}\n   virtual void visit_conjured_svalue (const conjured_svalue *) {}\n+  virtual void visit_asm_output_svalue (const asm_output_svalue *) {}\n \n   virtual void visit_region (const region *) {}\n };\n@@ -274,6 +275,11 @@ class region_model_manager\n \t\t\t\t\t       const binding_map &map);\n   const svalue *get_or_create_conjured_svalue (tree type, const gimple *stmt,\n \t\t\t\t\t       const region *id_reg);\n+  const svalue *\n+  get_or_create_asm_output_svalue (tree type,\n+\t\t\t\t   const gasm *asm_stmt,\n+\t\t\t\t   unsigned output_idx,\n+\t\t\t\t   const vec<const svalue *> &inputs);\n \n   const svalue *maybe_get_char_from_string_cst (tree string_cst,\n \t\t\t\t\t\ttree byte_offset_cst);\n@@ -346,6 +352,8 @@ class region_model_manager\n   const svalue *maybe_undo_optimize_bit_field_compare (tree type,\n \t\t\t\t\t\t       const compound_svalue *compound_sval,\n \t\t\t\t\t\t       tree cst, const svalue *arg1);\n+  const svalue *maybe_fold_asm_output_svalue (tree type,\n+\t\t\t\t\t      const vec<const svalue *> &inputs);\n \n   unsigned m_next_region_id;\n   root_region m_root_region;\n@@ -410,6 +418,10 @@ class region_model_manager\n \t\t   conjured_svalue *> conjured_values_map_t;\n   conjured_values_map_t m_conjured_values_map;\n \n+  typedef hash_map<asm_output_svalue::key_t,\n+\t\t   asm_output_svalue *> asm_output_values_map_t;\n+  asm_output_values_map_t m_asm_output_values_map;\n+\n   bool m_check_complexity;\n \n   /* Maximum complexity of svalues that weren't rejected.  */\n@@ -537,6 +549,7 @@ class region_model\n   void on_assignment (const gassign *stmt, region_model_context *ctxt);\n   const svalue *get_gassign_result (const gassign *assign,\n \t\t\t\t    region_model_context *ctxt);\n+  void on_asm_stmt (const gasm *asm_stmt, region_model_context *ctxt);\n   bool on_call_pre (const gcall *stmt, region_model_context *ctxt,\n \t\t    bool *out_terminate_path);\n   void on_call_post (const gcall *stmt,"}, {"sha": "eac1295c5de8d2e402185b8e4eda03ff863e7b3d", "filename": "gcc/analyzer/store.cc", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ded2c2c068f6f2825474758cb03a05070a5837e8/gcc%2Fanalyzer%2Fstore.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ded2c2c068f6f2825474758cb03a05070a5837e8/gcc%2Fanalyzer%2Fstore.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fstore.cc?ref=ded2c2c068f6f2825474758cb03a05070a5837e8", "patch": "@@ -1796,6 +1796,23 @@ binding_cluster::on_unknown_fncall (const gcall *call,\n     }\n }\n \n+/* Mark this cluster as having been clobbered by STMT.  */\n+\n+void\n+binding_cluster::on_asm (const gasm *stmt,\n+\t\t\t store_manager *mgr)\n+{\n+  m_map.empty ();\n+\n+  /* Bind it to a new \"conjured\" value using CALL.  */\n+  const svalue *sval\n+    = mgr->get_svalue_manager ()->get_or_create_conjured_svalue\n+    (m_base_region->get_type (), stmt, m_base_region);\n+  bind (mgr, m_base_region, sval);\n+\n+  m_touched = true;\n+}\n+\n /* Return true if this binding_cluster has no information\n    i.e. if there are no bindings, and it hasn't been marked as having\n    escaped, or touched symbolically.  */"}, {"sha": "b75691e4a168b022c893731eedd768039c56ebb7", "filename": "gcc/analyzer/store.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ded2c2c068f6f2825474758cb03a05070a5837e8/gcc%2Fanalyzer%2Fstore.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ded2c2c068f6f2825474758cb03a05070a5837e8/gcc%2Fanalyzer%2Fstore.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fstore.h?ref=ded2c2c068f6f2825474758cb03a05070a5837e8", "patch": "@@ -603,6 +603,7 @@ class binding_cluster\n \n   void mark_as_escaped ();\n   void on_unknown_fncall (const gcall *call, store_manager *mgr);\n+  void on_asm (const gasm *stmt, store_manager *mgr);\n \n   bool escaped_p () const { return m_escaped; }\n   bool touched_p () const { return m_touched; }"}, {"sha": "691316179f07350f30b635ab59cad974e01cc4de", "filename": "gcc/analyzer/svalue.cc", "status": "modified", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ded2c2c068f6f2825474758cb03a05070a5837e8/gcc%2Fanalyzer%2Fsvalue.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ded2c2c068f6f2825474758cb03a05070a5837e8/gcc%2Fanalyzer%2Fsvalue.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsvalue.cc?ref=ded2c2c068f6f2825474758cb03a05070a5837e8", "patch": "@@ -508,6 +508,29 @@ svalue::cmp_ptr (const svalue *sval1, const svalue *sval2)\n \t\t\t\tconjured_sval2->get_id_region ());\n       }\n       break;\n+    case SK_ASM_OUTPUT:\n+      {\n+\tconst asm_output_svalue *asm_output_sval1\n+\t  = (const asm_output_svalue *)sval1;\n+\tconst asm_output_svalue *asm_output_sval2\n+\t  = (const asm_output_svalue *)sval2;\n+\tif (int asm_string_cmp = strcmp (asm_output_sval1->get_asm_string (),\n+\t\t\t\t\t asm_output_sval2->get_asm_string ()))\n+\t  return asm_string_cmp;\n+\tif (int output_idx_cmp = ((int)asm_output_sval1->get_output_idx ()\n+\t\t\t\t  - (int)asm_output_sval2->get_output_idx ()))\n+\t  return output_idx_cmp;\n+\tif (int cmp = ((int)asm_output_sval1->get_num_inputs ()\n+\t\t       - (int)asm_output_sval2->get_num_inputs ()))\n+\t  return cmp;\n+\tfor (unsigned i = 0; i < asm_output_sval1->get_num_inputs (); i++)\n+\t  if (int input_cmp\n+\t      = svalue::cmp_ptr (asm_output_sval1->get_input (i),\n+\t\t\t\t asm_output_sval2->get_input (i)))\n+\t    return input_cmp;\n+\treturn 0;\n+      }\n+      break;\n     }\n }\n \n@@ -1794,6 +1817,72 @@ conjured_svalue::accept (visitor *v) const\n   m_id_reg->accept (v);\n }\n \n+/* class asm_output_svalue : public svalue.  */\n+\n+/* Implementation of svalue::dump_to_pp vfunc for asm_output_svalue.  */\n+\n+void\n+asm_output_svalue::dump_to_pp (pretty_printer *pp, bool simple) const\n+{\n+  if (simple)\n+    {\n+      pp_printf (pp, \"ASM_OUTPUT(%qs, %%%i, {\",\n+\t\t get_asm_string (),\n+\t\t get_output_idx ());\n+      for (unsigned i = 0; i < m_num_inputs; i++)\n+\t{\n+\t  if (i > 0)\n+\t    pp_string (pp, \", \");\n+\t  dump_input (pp, 0, m_input_arr[i], simple);\n+\t}\n+      pp_string (pp, \"})\");\n+    }\n+  else\n+    {\n+      pp_printf (pp, \"asm_output_svalue (%qs, %%%i, {\",\n+\t\t get_asm_string (),\n+\t\t get_output_idx ());\n+      for (unsigned i = 0; i < m_num_inputs; i++)\n+\t{\n+\t  if (i > 0)\n+\t    pp_string (pp, \", \");\n+\t  dump_input (pp, 0, m_input_arr[i], simple);\n+\t}\n+      pp_string (pp, \"})\");\n+    }\n+}\n+\n+/* Subroutine of asm_output_svalue::dump_to_pp.  */\n+\n+void\n+asm_output_svalue::dump_input (pretty_printer *pp,\n+\t\t\t       unsigned input_idx,\n+\t\t\t       const svalue *sval,\n+\t\t\t       bool simple) const\n+{\n+  pp_printf (pp, \"%%%i: \", input_idx_to_asm_idx (input_idx));\n+  sval->dump_to_pp (pp, simple);\n+}\n+\n+/* Convert INPUT_IDX from an index into the array of inputs\n+   into the index of all operands for the asm stmt.  */\n+\n+unsigned\n+asm_output_svalue::input_idx_to_asm_idx (unsigned input_idx) const\n+{\n+  return input_idx + m_num_outputs;\n+}\n+\n+/* Implementation of svalue::accept vfunc for asm_output_svalue.  */\n+\n+void\n+asm_output_svalue::accept (visitor *v) const\n+{\n+  v->visit_asm_output_svalue (this);\n+  for (unsigned i = 0; i < m_num_inputs; i++)\n+    m_input_arr[i]->accept (v);\n+}\n+\n } // namespace ana\n \n #endif /* #if ENABLE_ANALYZER */"}, {"sha": "63f7d1539a7d81e6cedc4f54061cf68b09b4292e", "filename": "gcc/analyzer/svalue.h", "status": "modified", "additions": 143, "deletions": 2, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ded2c2c068f6f2825474758cb03a05070a5837e8/gcc%2Fanalyzer%2Fsvalue.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ded2c2c068f6f2825474758cb03a05070a5837e8/gcc%2Fanalyzer%2Fsvalue.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsvalue.h?ref=ded2c2c068f6f2825474758cb03a05070a5837e8", "patch": "@@ -47,7 +47,8 @@ enum svalue_kind\n   SK_PLACEHOLDER,\n   SK_WIDENING,\n   SK_COMPOUND,\n-  SK_CONJURED\n+  SK_CONJURED,\n+  SK_ASM_OUTPUT\n };\n \n /* svalue and its subclasses.\n@@ -74,7 +75,9 @@ enum svalue_kind\n      widening_svalue (SK_WIDENING): a merger of two svalues (possibly\n        in an iteration).\n      compound_svalue (SK_COMPOUND): a mapping of bit-ranges to svalues\n-     conjured_svalue (SK_CONJURED): a value arising from a stmt.  */\n+     conjured_svalue (SK_CONJURED): a value arising from a stmt\n+     asm_output_svalue (SK_ASM_OUTPUT): an output from a deterministic\n+       asm stmt.  */\n \n /* An abstract base class representing a value held by a region of memory.  */\n \n@@ -124,6 +127,8 @@ class svalue\n   dyn_cast_compound_svalue () const { return NULL; }\n   virtual const conjured_svalue *\n   dyn_cast_conjured_svalue () const { return NULL; }\n+  virtual const asm_output_svalue *\n+  dyn_cast_asm_output_svalue () const { return NULL; }\n \n   tree maybe_get_constant () const;\n   const region *maybe_get_region () const;\n@@ -1394,4 +1399,140 @@ template <> struct default_hash_traits<conjured_svalue::key_t>\n   static const bool empty_zero_p = true;\n };\n \n+namespace ana {\n+\n+/* An output from a deterministic asm stmt, where we want to identify a\n+   particular unknown value, rather than resorting to the unknown_value\n+   singleton.\n+\n+   Comparisons of variables that share the same asm_output_svalue are known\n+   to be equal, even if we don't know what the value is.  */\n+\n+class asm_output_svalue : public svalue\n+{\n+public:\n+  /* Imposing an upper limit and using a (small) array allows key_t\n+     to avoid memory management.  */\n+  static const unsigned MAX_INPUTS = 2;\n+\n+  /* A support class for uniquifying instances of asm_output_svalue.  */\n+  struct key_t\n+  {\n+    key_t (tree type,\n+\t   const char *asm_string,\n+\t   unsigned output_idx,\n+\t   const vec<const svalue *> &inputs)\n+    : m_type (type), m_asm_string (asm_string), m_output_idx (output_idx),\n+      m_num_inputs (inputs.length ())\n+    {\n+      gcc_assert (inputs.length () <= MAX_INPUTS);\n+      for (unsigned i = 0; i < m_num_inputs; i++)\n+\tm_input_arr[i] = inputs[i];\n+    }\n+\n+    hashval_t hash () const\n+    {\n+      inchash::hash hstate;\n+      hstate.add_ptr (m_type);\n+      /* We don't bother hashing m_asm_str.  */\n+      hstate.add_int (m_output_idx);\n+      for (unsigned i = 0; i < m_num_inputs; i++)\n+\thstate.add_ptr (m_input_arr[i]);\n+      return hstate.end ();\n+    }\n+\n+    bool operator== (const key_t &other) const\n+    {\n+      if (!(m_type == other.m_type\n+\t    && 0 == (strcmp (m_asm_string, other.m_asm_string))\n+\t    && m_output_idx == other.m_output_idx\n+\t    && m_num_inputs == other.m_num_inputs))\n+\treturn false;\n+      for (unsigned i = 0; i < m_num_inputs; i++)\n+\tif (m_input_arr[i] != other.m_input_arr[i])\n+\t  return false;\n+      return true;\n+    }\n+\n+    /* Use m_asm_string to mark empty/deleted, as m_type can be NULL for\n+       legitimate instances.  */\n+    void mark_deleted () { m_asm_string = reinterpret_cast<const char *> (1); }\n+    void mark_empty () { m_asm_string = NULL; }\n+    bool is_deleted () const\n+    {\n+      return m_asm_string == reinterpret_cast<const char *> (1);\n+    }\n+    bool is_empty () const { return m_asm_string == NULL; }\n+\n+    tree m_type;\n+    const char *m_asm_string;\n+    unsigned m_output_idx;\n+    unsigned m_num_inputs;\n+    const svalue *m_input_arr[MAX_INPUTS];\n+  };\n+\n+  asm_output_svalue (tree type,\n+\t\t     const char *asm_string,\n+\t\t     unsigned output_idx,\n+\t\t     unsigned num_outputs,\n+\t\t     const vec<const svalue *> &inputs)\n+  : svalue (complexity::from_vec_svalue (inputs), type),\n+    m_asm_string (asm_string),\n+    m_output_idx (output_idx),\n+    m_num_outputs (num_outputs),\n+    m_num_inputs (inputs.length ())\n+  {\n+    gcc_assert (inputs.length () <= MAX_INPUTS);\n+    for (unsigned i = 0; i < m_num_inputs; i++)\n+      m_input_arr[i] = inputs[i];\n+  }\n+\n+  enum svalue_kind get_kind () const FINAL OVERRIDE { return SK_ASM_OUTPUT; }\n+  const asm_output_svalue *\n+  dyn_cast_asm_output_svalue () const FINAL OVERRIDE\n+  {\n+    return this;\n+  }\n+\n+  void dump_to_pp (pretty_printer *pp, bool simple) const FINAL OVERRIDE;\n+  void accept (visitor *v) const FINAL OVERRIDE;\n+\n+  const char *get_asm_string () const { return m_asm_string; }\n+  unsigned get_output_idx () const { return m_output_idx; }\n+  unsigned get_num_inputs () const { return m_num_inputs; }\n+  const svalue *get_input (unsigned idx) const { return m_input_arr[idx]; }\n+\n+ private:\n+  void dump_input (pretty_printer *pp,\n+\t\t   unsigned input_idx,\n+\t\t   const svalue *sval,\n+\t\t   bool simple) const;\n+  unsigned input_idx_to_asm_idx (unsigned input_idx) const;\n+\n+  const char *m_asm_string;\n+  unsigned m_output_idx;\n+\n+  /* We capture this so that we can offset the input indices\n+     to match the %0, %1, %2 in the asm_string when dumping.  */\n+  unsigned m_num_outputs;\n+\n+  unsigned m_num_inputs;\n+  const svalue *m_input_arr[MAX_INPUTS];\n+};\n+\n+} // namespace ana\n+\n+template <>\n+template <>\n+inline bool\n+is_a_helper <const asm_output_svalue *>::test (const svalue *sval)\n+{\n+  return sval->get_kind () == SK_ASM_OUTPUT;\n+}\n+\n+template <> struct default_hash_traits<asm_output_svalue::key_t>\n+: public member_function_hash_traits<asm_output_svalue::key_t>\n+{\n+  static const bool empty_zero_p = true;\n+};\n #endif /* GCC_ANALYZER_SVALUE_H */"}, {"sha": "f6026b7e28889f8cdefb0299d2650dbdac8b4d7e", "filename": "gcc/testsuite/gcc.dg/analyzer/asm-x86-1.c", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ded2c2c068f6f2825474758cb03a05070a5837e8/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fasm-x86-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ded2c2c068f6f2825474758cb03a05070a5837e8/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fasm-x86-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fasm-x86-1.c?ref=ded2c2c068f6f2825474758cb03a05070a5837e8", "patch": "@@ -0,0 +1,69 @@\n+/* { dg-do assemble { target x86_64-*-* } } */\n+\n+#include \"analyzer-decls.h\"\n+\n+int test_out (void)\n+{\n+  int dst_a, dst_b;\n+  asm (\"mov 42, %0\"\n+       : \"=r\" (dst_a));\n+  asm (\"mov 42, %0\"\n+       : \"=r\" (dst_b));\n+  __analyzer_eval (dst_a == dst_b); /* { dg-warning \"TRUE\" } */\n+  return dst_a;\n+}\n+\n+int test_out_in (int src_a)\n+{\n+  int dst_a, dst_b;\n+  asm (\"mov %1, %0\"\n+       : \"=r\" (dst_a)\n+       : \"r\" (src_a));\n+  asm (\"mov %1, %0\"\n+       : \"=r\" (dst_b)\n+       : \"r\" (src_a));\n+  __analyzer_eval (dst_a == dst_b); /* { dg-warning \"TRUE\" } */\n+  return dst_a;\n+}\n+\n+int test_out_in_in (int src_a, int src_b)\n+{\n+  int dst_a, dst_b;\n+  asm (\"mov %1, %0;\\n\"\n+       \"add %2, %0\"\n+       : \"=r\" (dst_a)\n+       : \"r\" (src_a),\n+\t \"r\" (src_b));\n+  asm (\"mov %1, %0;\\n\"\n+       \"add %2, %0\"\n+       : \"=r\" (dst_b)\n+       : \"r\" (src_a),\n+\t \"r\" (src_b));\n+  __analyzer_eval (dst_a == dst_b); /* { dg-warning \"TRUE\" } */\n+  return dst_a;\n+}\n+\n+void test_inout_1 (int v)\n+{\n+  int saved = v;\n+  int result_a, result_b;\n+  asm (\"dec %0\"\n+       : \"+r\" (v));\n+  result_a = v;\n+\n+  asm (\"dec %0\"\n+       : \"+r\" (v));\n+  result_b = v;\n+\n+  __analyzer_eval (v == saved); /* { dg-warning \"UNKNOWN\" } */\n+  __analyzer_eval (v == result_a); /* { dg-warning \"UNKNOWN\" } */\n+  __analyzer_eval (v == result_b); /* { dg-warning \"TRUE\" } */\n+}\n+\n+void test_inout_2 (void)\n+{\n+  int v;\n+  int result_a, result_b;\n+  asm (\"dec %0\" /* { dg-warning \"use of uninitialized value 'v'\" } */\n+       : \"+r\" (v));\n+}"}, {"sha": "c235e22fd01c7f9f6a972bc79151c72d747b790e", "filename": "gcc/testsuite/gcc.dg/analyzer/asm-x86-lp64-1.c", "status": "added", "additions": 131, "deletions": 0, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ded2c2c068f6f2825474758cb03a05070a5837e8/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fasm-x86-lp64-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ded2c2c068f6f2825474758cb03a05070a5837e8/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fasm-x86-lp64-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fasm-x86-lp64-1.c?ref=ded2c2c068f6f2825474758cb03a05070a5837e8", "patch": "@@ -0,0 +1,131 @@\n+/* { dg-do assemble { target x86_64-*-* } } */\n+/* { dg-require-effective-target lp64 } */\n+\n+#include \"analyzer-decls.h\"\n+\n+#include <stdint.h>\n+\n+int test_1 (int src)\n+{\n+  int dst;\n+  asm (\"mov %1, %0\\n\\t\"\n+       \"add $1, %0\"\n+       : \"=r\" (dst)\n+       : \"r\" (src));\n+  return dst;\n+}\n+\n+uint32_t test_2 (uint32_t Mask)\n+{\n+  uint32_t Index;\n+  asm (\"bsfl %[aMask], %[aIndex]\"\n+       : [aIndex] \"=r\" (Index)\n+       : [aMask] \"r\" (Mask)\n+       : \"cc\");\n+  return Index;\n+}\n+\n+int test_3a (int p1, int p2)\n+{\n+  asm goto (\"btl %1, %0\\n\\t\"\n+\t    \"jc %l2\"\n+\t    : // No outputs\n+\t    : \"r\" (p1), \"r\" (p2)\n+\t    : \"cc\"\n+\t    : carry);\n+\n+  return 0;\n+\n+ carry:\n+  return 1;\n+}\n+\n+int test_3b (int p1, int p2)\n+{\n+  asm goto (\"btl %1, %0\\n\\t\"\n+\t    \"jc %l[carry]\"\n+\t    : // No outputs\n+\t    : \"r\" (p1), \"r\" (p2)\n+\t    : \"cc\"\n+\t    : carry);\n+\n+  return 0;\n+\n+ carry:\n+  return 1;\n+}\n+\n+uint64_t test_4 (void)\n+{\n+  uint64_t start_time, end_time;\n+\n+  // Get start time\n+  asm volatile (\"rdtsc\\n\\t\"    // Returns the time in EDX:EAX.\n+\t\t\"shl $32, %%rdx\\n\\t\"  // Shift the upper bits left.\n+\t\t\"or %%rdx, %0\"        // 'Or' in the lower bits.\n+\t\t: \"=a\" (start_time)\n+\t\t:\n+\t\t: \"rdx\");\n+\n+  // could do other work here\n+\n+  // Get end time\n+  asm volatile (\"rdtsc\\n\\t\"    // Returns the time in EDX:EAX.\n+\t\t\"shl $32, %%rdx\\n\\t\"  // Shift the upper bits left.\n+\t\t\"or %%rdx, %0\"        // 'Or' in the lower bits.\n+\t\t: \"=a\" (end_time)\n+\t\t:\n+\t\t: \"rdx\");\n+\n+  __analyzer_eval (start_time == end_time); /* { dg-warning \"UNKNOWN\" } */\n+\n+  // Get elapsed time\n+  return end_time - start_time;\n+}\n+\n+static uint64_t get_time (void)\n+{\n+  uint64_t result;\n+  asm volatile (\"rdtsc\\n\\t\"    // Returns the time in EDX:EAX.\n+\t\t\"shl $32, %%rdx\\n\\t\"  // Shift the upper bits left.\n+\t\t\"or %%rdx, %0\"        // 'Or' in the lower bits.\n+\t\t: \"=a\" (result)\n+\t\t:\n+\t\t: \"rdx\");\n+  return result;\n+}\n+\n+uint64_t test_4a (void)\n+{\n+  uint64_t start_time, end_time;\n+\n+  start_time = get_time ();\n+  // could do other work here\n+  end_time = get_time ();\n+\n+  __analyzer_eval (start_time == end_time); /* { dg-warning \"UNKNOWN\" } */\n+\n+  // Get elapsed time\n+  return end_time - start_time;\n+}\n+\n+asm (\"\\t.pushsection .text\\n\"\n+     \"\\t.globl add_asm\\n\"\n+     \"\\t.type add_asm, @function\\n\"\n+     \"add_asm:\\n\"\n+     \"\\tmovq %rdi, %rax\\n\"\n+     \"\\tadd %rsi, %rax\\n\"\n+     \"\\tret\\n\"\n+     \"\\t.popsection\\n\");\n+\n+int test_5 (int count)\n+{\n+  asm goto (\"dec %0; jb %l[stop]\"\n+\t    : \"+r\" (count)\n+\t    :\n+\t    :\n+\t    : stop);\n+  return count;\n+stop:\n+  return 0;\n+}"}, {"sha": "fa507395ec7a9b9d8e93689271a5f13b536e15b0", "filename": "gcc/testsuite/gcc.dg/analyzer/asm-x86-lp64-2.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ded2c2c068f6f2825474758cb03a05070a5837e8/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fasm-x86-lp64-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ded2c2c068f6f2825474758cb03a05070a5837e8/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fasm-x86-lp64-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fasm-x86-lp64-2.c?ref=ded2c2c068f6f2825474758cb03a05070a5837e8", "patch": "@@ -0,0 +1,34 @@\n+/* { dg-do assemble { target x86_64-*-* } } */\n+/* { dg-require-effective-target lp64 } */\n+\n+/* Adapted from Linux x86: page_ref_dec_and_test.c (GPL-2.0).  */\n+\n+typedef _Bool bool;\n+\n+typedef struct {\n+  int counter;\n+} atomic_t;\n+\n+bool\n+arch_atomic_dec_and_test(atomic_t *v) {\n+  return ({\n+    bool c;\n+    asm volatile(\".pushsection .smp_locks,\\\"a\\\"\\n\"\n+                 \".balign 4\\n\"\n+                 \".long 671f - .\\n\"\n+                 \".popsection\\n\"\n+                 \"671:\"\n+                 \"\\n\\tlock; \"\n+                 \"decl\"\n+                 \" \"\n+                 \"%[var]\"\n+                 \"\\n\\t/* output condition code \"\n+                 \"e\"\n+                 \"*/\\n\"\n+                 : [ var ] \"+m\"(v->counter), \"=@cc\"\n+                                             \"e\"(c)\n+                 :\n+                 : \"memory\");\n+    c;\n+  });\n+}"}, {"sha": "809bad683f9af799e95ee4c3eae4fd26f964d5cc", "filename": "gcc/testsuite/gcc.dg/analyzer/pr101570.c", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ded2c2c068f6f2825474758cb03a05070a5837e8/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr101570.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ded2c2c068f6f2825474758cb03a05070a5837e8/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr101570.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr101570.c?ref=ded2c2c068f6f2825474758cb03a05070a5837e8", "patch": "@@ -0,0 +1,5 @@\n+void\n+test2 (_Complex double f)\n+{\n+  __asm__ (\"\" : \"=r\" (__real f));\n+}"}, {"sha": "6201fdb498f64f076c7fd81850dba74c6d55c385", "filename": "gcc/testsuite/gcc.dg/analyzer/torture/asm-x86-linux-array_index_mask_nospec.c", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ded2c2c068f6f2825474758cb03a05070a5837e8/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftorture%2Fasm-x86-linux-array_index_mask_nospec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ded2c2c068f6f2825474758cb03a05070a5837e8/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftorture%2Fasm-x86-linux-array_index_mask_nospec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftorture%2Fasm-x86-linux-array_index_mask_nospec.c?ref=ded2c2c068f6f2825474758cb03a05070a5837e8", "patch": "@@ -0,0 +1,74 @@\n+/* { dg-do assemble { target x86_64-*-* } } */\n+/* { dg-require-effective-target lp64 } */\n+/* { dg-skip-if \"\" { *-*-* } { \"-fno-fat-lto-objects\" } { \"\" } } */\n+\n+#include \"../analyzer-decls.h\"\n+\n+/* Copied from linux: arch/x86/include/asm/barrier.h (GPL-2.0) */\n+\n+static inline unsigned long array_index_mask_nospec(unsigned long index,\n+\t\t\t\t\t\t    unsigned long size)\n+{\n+\tunsigned long mask;\n+\n+\tasm volatile (\"cmp %1,%2; sbb %0,%0;\"\n+\t\t\t:\"=r\" (mask)\n+\t\t\t:\"g\"(size),\"r\" (index)\n+\t\t\t:\"cc\");\n+\treturn mask;\n+}\n+\n+/* The analyzer ought to treat array_index_mask_nospec as being\n+   effectively pure.  */\n+\n+void test_1 (unsigned long index, unsigned long size)\n+{\n+  unsigned long a = array_index_mask_nospec (index, size);\n+  unsigned long b = array_index_mask_nospec (index, size);\n+  __analyzer_eval (a == b); /* { dg-warning \"TRUE\" } */\n+}\n+\n+void test_2 (unsigned long index_a, unsigned long size_a,\n+\t     unsigned long index_b, unsigned long size_b)\n+{\n+  unsigned long aa_1 = array_index_mask_nospec (index_a, size_a);\n+  unsigned long ab_1 = array_index_mask_nospec (index_a, size_b);\n+  unsigned long ba_1 = array_index_mask_nospec (index_b, size_a);\n+  unsigned long bb_1 = array_index_mask_nospec (index_b, size_b);\n+\n+  unsigned long aa_2 = array_index_mask_nospec (index_a, size_a);\n+  unsigned long ab_2 = array_index_mask_nospec (index_a, size_b);\n+  unsigned long ba_2 = array_index_mask_nospec (index_b, size_a);\n+  unsigned long bb_2 = array_index_mask_nospec (index_b, size_b);\n+\n+  __analyzer_eval (aa_1 == aa_2); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (ab_1 == ab_2); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (ba_1 == ba_2); /* { dg-warning \"TRUE\" } */\n+  __analyzer_eval (bb_1 == bb_2); /* { dg-warning \"TRUE\" } */\n+\n+  __analyzer_eval (aa_1 == ab_1); /* { dg-warning \"UNKNOWN\" } */\n+  __analyzer_eval (aa_1 == ba_1); /* { dg-warning \"UNKNOWN\" } */\n+  __analyzer_eval (aa_1 == bb_1); /* { dg-warning \"UNKNOWN\" } */\n+\n+  __analyzer_eval (ab_1 == ba_1); /* { dg-warning \"UNKNOWN\" } */\n+  __analyzer_eval (ab_1 == bb_1); /* { dg-warning \"UNKNOWN\" } */\n+\n+  __analyzer_eval (ba_1 == bb_1); /* { dg-warning \"UNKNOWN\" } */\n+}\n+\n+/* Equivalent asm strings should be treated the same, rather\n+   than requiring the results to come from the same stmt.  */\n+\n+void test_3 (unsigned long index, unsigned long size)\n+{\n+  unsigned long a = array_index_mask_nospec (index, size);\n+  unsigned long b;\n+\n+  /* Copy of the asm from array_index_mask_nospec.  */\n+  asm volatile (\"cmp %1,%2; sbb %0,%0;\"\n+\t\t:\"=r\" (b)\n+\t\t:\"g\"(size),\"r\" (index)\n+\t\t:\"cc\");\n+\n+  __analyzer_eval (a == b); /* { dg-warning \"TRUE\" } */\n+}"}, {"sha": "cf5cf97367d1315f91b538cf27736fdab0203aee", "filename": "gcc/testsuite/gcc.dg/analyzer/torture/asm-x86-linux-cpuid-paravirt-1.c", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ded2c2c068f6f2825474758cb03a05070a5837e8/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftorture%2Fasm-x86-linux-cpuid-paravirt-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ded2c2c068f6f2825474758cb03a05070a5837e8/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftorture%2Fasm-x86-linux-cpuid-paravirt-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftorture%2Fasm-x86-linux-cpuid-paravirt-1.c?ref=ded2c2c068f6f2825474758cb03a05070a5837e8", "patch": "@@ -0,0 +1,81 @@\n+/* { dg-do assemble { target x86_64-*-* } } */\n+/* { dg-require-effective-target lp64 } */\n+/* { dg-skip-if \"\" { *-*-* } { \"-O0\" } { \"\" } } */\n+/* { dg-skip-if \"\" { *-*-* } { \"-fno-fat-lto-objects\" } { \"\" } } */\n+\n+/* Adapted/reduced from linux kernel (GPL-2.0).  */\n+\n+register unsigned long current_stack_pointer asm(\"rsp\");\n+\n+struct pv_cpu_ops {\n+  /* snip */\n+  void (*cpuid)(unsigned int *eax, unsigned int *ebx, unsigned int *ecx,\n+                unsigned int *edx);\n+  /* snip */\n+};\n+struct paravirt_patch_template {\n+  struct pv_cpu_ops cpu;\n+  /* snip */\n+};\n+extern struct paravirt_patch_template pv_ops;\n+\n+/* snip */\n+static void cpuid(unsigned int *eax, unsigned int *ebx, unsigned int *ecx,\n+\t\t  unsigned int *edx) {\n+  unsigned long __edi = __edi, __esi = __esi, __edx = __edx, __ecx = __ecx,\n+                __eax = __eax;\n+  asm volatile(\n+      \"771:\\n\\t\"\n+      \"999:\\n\\t\"\n+      \".pushsection .discard.retpoline_safe\\n\\t\"\n+      \" \"\n+      \".quad\"\n+      \" \"\n+      \" 999b\\n\\t\"\n+      \".popsection\\n\\t\"\n+      \"call *%c[paravirt_opptr];\"\n+      \"\\n\"\n+      \"772:\\n\"\n+      \".pushsection .parainstructions,\\\"a\\\"\\n\"\n+      \" \"\n+      \".balign 8\"\n+      \" \"\n+      \"\\n\"\n+      \" \"\n+      \".quad\"\n+      \" \"\n+      \" 771b\\n\"\n+      \"  .byte \"\n+      \"%c[paravirt_typenum]\"\n+      \"\\n\"\n+      \"  .byte 772b-771b\\n\"\n+      \"  .short \"\n+      \"%c[paravirt_clobber]\"\n+      \"\\n\"\n+      \".popsection\\n\"\n+      : \"=D\"(__edi), \"=S\"(__esi), \"=d\"(__edx), \"=c\"(__ecx),\n+        \"+r\"(current_stack_pointer)\n+      : [ paravirt_typenum ] \"i\"(\n+            (__builtin_offsetof(struct paravirt_patch_template, cpu.cpuid) /\n+             sizeof(void *))),\n+        [ paravirt_opptr ] \"i\"(&(pv_ops.cpu.cpuid)),\n+        [ paravirt_clobber ] \"i\"(((1 << 9) - 1)), \"D\"((unsigned long)(eax)),\n+        \"S\"((unsigned long)(ebx)), \"d\"((unsigned long)(ecx)),\n+        \"c\"((unsigned long)(edx))\n+      : \"memory\", \"cc\", \"rax\", \"r8\", \"r9\", \"r10\", \"r11\");\n+}\n+\n+extern void check_init_int(int v);\n+\n+void test(unsigned int op) {\n+  unsigned int eax, ebx, ecx, edx;\n+\n+  eax = op;\n+  ecx = 0;\n+  cpuid(&eax, &ebx, &ecx, &edx);\n+\n+  check_init_int(eax);\n+  check_init_int(ebx); /* { dg-bogus \"use of uninitialized value 'ebx'\" } */\n+  check_init_int(ecx);\n+  check_init_int(edx); /* { dg-bogus \"use of uninitialized value 'edx'\" } */\n+}"}, {"sha": "c4b365f1e6e279129ab3b2585a8faf051bcb1eb8", "filename": "gcc/testsuite/gcc.dg/analyzer/torture/asm-x86-linux-cpuid-paravirt-2.c", "status": "added", "additions": 135, "deletions": 0, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ded2c2c068f6f2825474758cb03a05070a5837e8/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftorture%2Fasm-x86-linux-cpuid-paravirt-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ded2c2c068f6f2825474758cb03a05070a5837e8/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftorture%2Fasm-x86-linux-cpuid-paravirt-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftorture%2Fasm-x86-linux-cpuid-paravirt-2.c?ref=ded2c2c068f6f2825474758cb03a05070a5837e8", "patch": "@@ -0,0 +1,135 @@\n+/* { dg-do assemble { target x86_64-*-* } } */\n+/* { dg-require-effective-target lp64 } */\n+/* { dg-skip-if \"\" { *-*-* } { \"-O0\" } { \"\" } } */\n+/* { dg-skip-if \"\" { *-*-* } { \"-fno-fat-lto-objects\" } { \"\" } } */\n+\n+/* Adapted/reduced from linux kernel (GPL-2.0).  */\n+\n+typedef __SIZE_TYPE__ size_t;\n+\n+#define offsetof(TYPE, MEMBER)\t((size_t)&((TYPE *)0)->MEMBER)\n+\n+#define __stringify_1(x...)\t#x\n+#define __stringify(x...)\t__stringify_1(x)\n+#define __ASM_FORM(x, ...)\t\t\" \" __stringify(x,##__VA_ARGS__) \" \"\n+#define __ASM_FORM_RAW(x, ...)\t\t    __stringify(x,##__VA_ARGS__)\n+#define __ASM_SEL(a,b)\t\t__ASM_FORM(b)\n+#define __ASM_SEL_RAW(a,b)\t__ASM_FORM_RAW(b)\n+#define __ASM_REG(reg)         __ASM_SEL_RAW(e##reg, r##reg)\n+#define _ASM_PTR\t__ASM_SEL(.long, .quad)\n+#define _ASM_ALIGN   __ASM_SEL(.balign 4, .balign 8)\n+#define _ASM_SP\t\t__ASM_REG(sp)\n+\n+\n+register unsigned long current_stack_pointer asm(_ASM_SP);\n+#define ASM_CALL_CONSTRAINT \"+r\" (current_stack_pointer)\n+\n+#define ANNOTATE_RETPOLINE_SAFE\t\t\t\t\t\\\n+\t\"999:\\n\\t\"\t\t\t\t\t\t\\\n+\t\".pushsection .discard.retpoline_safe\\n\\t\"\t\t\\\n+\t_ASM_PTR \" 999b\\n\\t\"\t\t\t\t\t\\\n+\t\".popsection\\n\\t\"\n+\n+/* Adapted from Linux arch/x86/include/asm/paravirt.h  */\n+\n+struct pv_cpu_ops {\n+  /* snip */\n+  void (*cpuid)(unsigned int *eax, unsigned int *ebx, unsigned int *ecx,\n+\t\tunsigned int *edx);\n+  /* snip */\n+};\n+\n+struct paravirt_patch_template {\n+  struct pv_cpu_ops cpu;\n+  /* snip */\n+};\n+extern struct paravirt_patch_template pv_ops;\n+\n+#define PARAVIRT_PATCH(x)\t\t\t\t\t\\\n+\t(offsetof(struct paravirt_patch_template, x) / sizeof(void *))\n+\n+#define paravirt_type(op)\t\t\t\t\\\n+\t[paravirt_typenum] \"i\" (PARAVIRT_PATCH(op)),\t\\\n+\t[paravirt_opptr] \"i\" (&(pv_ops.op))\n+#define paravirt_clobber(clobber)\t\t\\\n+\t[paravirt_clobber] \"i\" (clobber)\n+\n+#define CLBR_ANY  ((1 << 9) - 1)\n+\n+#define _paravirt_alt(insn_string, type, clobber)\t\\\n+\t\"771:\\n\\t\" insn_string \"\\n\" \"772:\\n\"\t\t\\\n+\t\".pushsection .parainstructions,\\\"a\\\"\\n\"\t\\\n+\t_ASM_ALIGN \"\\n\"\t\t\t\t\t\\\n+\t_ASM_PTR \" 771b\\n\"\t\t\t\t\\\n+\t\"  .byte \" type \"\\n\"\t\t\t\t\\\n+\t\"  .byte 772b-771b\\n\"\t\t\t\t\\\n+\t\"  .short \" clobber \"\\n\"\t\t\t\\\n+\t\".popsection\\n\"\n+\n+#define paravirt_alt(insn_string)\t\t\t\t\t\\\n+\t_paravirt_alt(insn_string, \"%c[paravirt_typenum]\", \"%c[paravirt_clobber]\")\n+\n+#define PARAVIRT_CALL\t\t\t\t\t\\\n+\tANNOTATE_RETPOLINE_SAFE\t\t\t\t\\\n+\t\"call *%c[paravirt_opptr];\"\n+\n+#define PVOP_CALL_ARGS\t\t\t\t\t\t\\\n+\tunsigned long __edi = __edi, __esi = __esi,\t\t\\\n+\t\t__edx = __edx, __ecx = __ecx, __eax = __eax;\n+\n+#define PVOP_CALL_ARG1(x)\t\t\"D\" ((unsigned long)(x))\n+#define PVOP_CALL_ARG2(x)\t\t\"S\" ((unsigned long)(x))\n+#define PVOP_CALL_ARG3(x)\t\t\"d\" ((unsigned long)(x))\n+#define PVOP_CALL_ARG4(x)\t\t\"c\" ((unsigned long)(x))\n+\n+#define PVOP_VCALL_CLOBBERS\t\"=D\" (__edi),\t\t\t\t\\\n+\t\t\t\t\"=S\" (__esi), \"=d\" (__edx),\t\t\\\n+\t\t\t\t\"=c\" (__ecx)\n+/* void functions are still allowed [re]ax for scratch */\n+#define PVOP_VCALLEE_CLOBBERS\t\"=a\" (__eax)\n+\n+#define VEXTRA_CLOBBERS\t , \"rax\", \"r8\", \"r9\", \"r10\", \"r11\"\n+\n+#define PVOP_TEST_NULL(op)\t((void)pv_ops.op)\n+\n+#define ____PVOP_CALL(ret, op, clbr, call_clbr, extra_clbr, ...)\t\\\n+\t({\t\t\t\t\t\t\t\t\\\n+\t\tPVOP_CALL_ARGS;\t\t\t\t\t\t\\\n+\t\tPVOP_TEST_NULL(op);\t\t\t\t\t\\\n+\t\tasm volatile(paravirt_alt(PARAVIRT_CALL)\t\t\\\n+\t\t\t     : call_clbr, ASM_CALL_CONSTRAINT\t\t\\\n+\t\t\t     : paravirt_type(op),\t\t\t\\\n+\t\t\t       paravirt_clobber(clbr),\t\t\t\\\n+\t\t\t       ##__VA_ARGS__\t\t\t\t\\\n+\t\t\t     : \"memory\", \"cc\" extra_clbr);\t\t\\\n+\t\tret;\t\t\t\t\t\t\t\\\n+\t})\n+\n+#define __PVOP_VCALL(op, ...)\t\t\t\t\t\t\\\n+\t(void)____PVOP_CALL(, op, CLBR_ANY, PVOP_VCALL_CLOBBERS,\t\\\n+\t\t       VEXTRA_CLOBBERS, ##__VA_ARGS__)\n+\n+#define PVOP_VCALL4(op, arg1, arg2, arg3, arg4)\t\t\t\t\\\n+\t__PVOP_VCALL(op, PVOP_CALL_ARG1(arg1), PVOP_CALL_ARG2(arg2),\t\\\n+\t\t     PVOP_CALL_ARG3(arg3), PVOP_CALL_ARG4(arg4))\n+\n+static void cpuid(unsigned int *eax, unsigned int *ebx, unsigned int *ecx,\n+\t\t  unsigned int *edx)\n+{\n+  PVOP_VCALL4(cpu.cpuid, eax, ebx, ecx, edx);\n+}\n+\n+extern void check_init_int(int v);\n+\n+void test(unsigned int op) {\n+  unsigned int eax, ebx, ecx, edx;\n+\n+  eax = op;\n+  ecx = 0;\n+  cpuid(&eax, &ebx, &ecx, &edx);\n+\n+  check_init_int(eax);\n+  check_init_int(ebx); /* { dg-bogus \"use of uninitialized value 'ebx'\" } */\n+  check_init_int(ecx);\n+  check_init_int(edx); /* { dg-bogus \"use of uninitialized value 'edx'\" } */\n+}"}, {"sha": "243931aebc850961dd49d022395d7ff11730b428", "filename": "gcc/testsuite/gcc.dg/analyzer/torture/asm-x86-linux-cpuid.c", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ded2c2c068f6f2825474758cb03a05070a5837e8/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftorture%2Fasm-x86-linux-cpuid.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ded2c2c068f6f2825474758cb03a05070a5837e8/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftorture%2Fasm-x86-linux-cpuid.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftorture%2Fasm-x86-linux-cpuid.c?ref=ded2c2c068f6f2825474758cb03a05070a5837e8", "patch": "@@ -0,0 +1,46 @@\n+/* { dg-do assemble { target x86_64-*-* } } */\n+/* { dg-require-effective-target lp64 } */\n+\n+#include \"../analyzer-decls.h\"\n+\n+typedef unsigned __INT32_TYPE__ u32;\n+typedef unsigned __INT64_TYPE__ u64;\n+\n+extern void check_init_u32 (u32 v);\n+extern void check_init_u64 (u32 v);\n+\n+/* Adapted from linux kernel: arch/x86/include/asm/processor.h (GPL-2.0).  */\n+\n+static inline void native_cpuid(unsigned int *eax, unsigned int *ebx,\n+\t\t\t\tunsigned int *ecx, unsigned int *edx)\n+{\n+\t/* ecx is often an input as well as an output. */\n+\tasm volatile(\"cpuid\"\n+\t    : \"=a\" (*eax),\n+\t      \"=b\" (*ebx),\n+\t      \"=c\" (*ecx),\n+\t      \"=d\" (*edx)\n+\t    : \"0\" (*eax), \"2\" (*ecx)\n+\t    : \"memory\");\n+}\n+\n+static inline void cpuid(unsigned int op,\n+\t\t\t unsigned int *eax, unsigned int *ebx,\n+\t\t\t unsigned int *ecx, unsigned int *edx)\n+{\n+\t*eax = op;\n+\t*ecx = 0;\n+\tnative_cpuid(eax, ebx, ecx, edx);\n+}\n+\n+void test_1 (void)\n+{\n+  u32 eax, ebx, ecx, edx;\n+  cpuid(0x8000001e, &eax, &ebx, &ecx, &edx); /* from \"amd_get_topology\".  */\n+\n+  /* Verify that they are now initialized.  */\n+  check_init_u32 (eax);\n+  check_init_u32 (ebx);\n+  check_init_u32 (ecx);\n+  check_init_u32 (edx);\n+}"}, {"sha": "d9947871235930990a6b1bd850148c8c3282cfaf", "filename": "gcc/testsuite/gcc.dg/analyzer/torture/asm-x86-linux-rdmsr-paravirt.c", "status": "added", "additions": 210, "deletions": 0, "changes": 210, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ded2c2c068f6f2825474758cb03a05070a5837e8/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftorture%2Fasm-x86-linux-rdmsr-paravirt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ded2c2c068f6f2825474758cb03a05070a5837e8/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftorture%2Fasm-x86-linux-rdmsr-paravirt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftorture%2Fasm-x86-linux-rdmsr-paravirt.c?ref=ded2c2c068f6f2825474758cb03a05070a5837e8", "patch": "@@ -0,0 +1,210 @@\n+/* Adapted from Linux: arch/x86/include/asm/paravirt.h */\n+\n+/* { dg-do assemble { target x86_64-*-* } } */\n+/* { dg-skip-if \"\" { *-*-* } { \"-fno-fat-lto-objects\" } { \"\" } } */\n+/* { dg-skip-if \"\" { *-*-* } { \"-O0\" } { \"\" } } */\n+\n+/* Adapted/reduced from linux kernel (GPL-2.0).  */\n+\n+#include \"../analyzer-decls.h\"\n+\n+typedef unsigned char u8;\n+typedef unsigned __INT32_TYPE__ u32;\n+typedef unsigned __INT64_TYPE__ u64;\n+typedef __SIZE_TYPE__ size_t;\n+\n+#define offsetof(TYPE, MEMBER)\t((size_t)&((TYPE *)0)->MEMBER)\n+\n+#define __stringify_1(x...)\t#x\n+#define __stringify(x...)\t__stringify_1(x)\n+\n+# define __ASM_FORM(x, ...)\t\t\" \" __stringify(x,##__VA_ARGS__) \" \"\n+# define __ASM_FORM_RAW(x, ...)\t\t    __stringify(x,##__VA_ARGS__)\n+\n+#ifndef __x86_64__\n+/* 32 bit */\n+# define __ASM_SEL(a,b)\t\t__ASM_FORM(a)\n+# define __ASM_SEL_RAW(a,b)\t__ASM_FORM_RAW(a)\n+#else\n+/* 64 bit */\n+# define __ASM_SEL(a,b)\t\t__ASM_FORM(b)\n+# define __ASM_SEL_RAW(a,b)\t__ASM_FORM_RAW(b)\n+#endif\n+\n+#define __ASM_REG(reg)         __ASM_SEL_RAW(e##reg, r##reg)\n+\n+#define _ASM_PTR\t__ASM_SEL(.long, .quad)\n+#define _ASM_ALIGN   __ASM_SEL(.balign 4, .balign 8)\n+\n+#define _ASM_SP\t\t__ASM_REG(sp)\n+\n+\n+register unsigned long current_stack_pointer asm(_ASM_SP);\n+#define ASM_CALL_CONSTRAINT \"+r\" (current_stack_pointer)\n+\n+#define ANNOTATE_RETPOLINE_SAFE\t\t\t\t\t\\\n+\t\"999:\\n\\t\"\t\t\t\t\t\t\\\n+\t\".pushsection .discard.retpoline_safe\\n\\t\"\t\t\\\n+\t_ASM_PTR \" 999b\\n\\t\"\t\t\t\t\t\\\n+\t\".popsection\\n\\t\"\n+\n+/* Adapted from Linux arch/x86/include/asm/paravirt.h  */\n+\n+\n+/* snip */\n+\n+/* ./arch/x86/include/asm/paravirt.h I think; was:\n+   PVOP_VCALL4(cpu.cpuid, eax, ebx, ecx, edx);\n+\n+*/\n+\n+#ifndef __x86_64__\n+#define CLBR_ANY  ((1 << 4) - 1)\n+#else\n+#define CLBR_ANY  ((1 << 9) - 1)\n+#endif /* X86_64 */\n+\n+struct pv_cpu_ops {\n+  /* snip */\n+  u64 (*read_msr_safe)(unsigned int msr, int *err);\n+  /* snip */\n+};\n+\n+struct paravirt_patch_template {\n+  struct pv_cpu_ops cpu;\n+  /* snip */\n+};\n+extern struct paravirt_patch_template pv_ops;\n+\n+#define PARAVIRT_PATCH(x)\t\t\t\t\t\\\n+\t(offsetof(struct paravirt_patch_template, x) / sizeof(void *))\n+\n+#define paravirt_type(op)\t\t\t\t\\\n+\t[paravirt_typenum] \"i\" (PARAVIRT_PATCH(op)),\t\\\n+\t[paravirt_opptr] \"i\" (&(pv_ops.op))\n+#define paravirt_clobber(clobber)\t\t\\\n+\t[paravirt_clobber] \"i\" (clobber)\n+\n+/*\n+ * Generate some code, and mark it as patchable by the\n+ * apply_paravirt() alternate instruction patcher.\n+ */\n+#define _paravirt_alt(insn_string, type, clobber)\t\\\n+\t\"771:\\n\\t\" insn_string \"\\n\" \"772:\\n\"\t\t\\\n+\t\".pushsection .parainstructions,\\\"a\\\"\\n\"\t\\\n+\t_ASM_ALIGN \"\\n\"\t\t\t\t\t\\\n+\t_ASM_PTR \" 771b\\n\"\t\t\t\t\\\n+\t\"  .byte \" type \"\\n\"\t\t\t\t\\\n+\t\"  .byte 772b-771b\\n\"\t\t\t\t\\\n+\t\"  .short \" clobber \"\\n\"\t\t\t\\\n+\t\".popsection\\n\"\n+\n+/* Generate patchable code, with the default asm parameters. */\n+#define paravirt_alt(insn_string)\t\t\t\t\t\\\n+\t_paravirt_alt(insn_string, \"%c[paravirt_typenum]\", \"%c[paravirt_clobber]\")\n+\n+#define PARAVIRT_CALL\t\t\t\t\t\\\n+\tANNOTATE_RETPOLINE_SAFE\t\t\t\t\\\n+\t\"call *%c[paravirt_opptr];\"\n+\n+#ifndef __x86_64__\n+\n+/* 32-bit.  */\n+\n+#define PVOP_CALL_ARGS\t\t\t\t\t\t\t\\\n+\tunsigned long __eax = __eax, __edx = __edx, __ecx = __ecx;\n+\n+#define PVOP_CALL_ARG1(x)\t\t\"a\" ((unsigned long)(x))\n+#define PVOP_CALL_ARG2(x)\t\t\"d\" ((unsigned long)(x))\n+\n+#define PVOP_VCALL_CLOBBERS\t\t\"=a\" (__eax), \"=d\" (__edx),\t\\\n+\t\t\t\t\t\"=c\" (__ecx)\n+#define PVOP_CALL_CLOBBERS\t\tPVOP_VCALL_CLOBBERS\n+\n+#define PVOP_VCALLEE_CLOBBERS\t\t\"=a\" (__eax), \"=d\" (__edx)\n+#define PVOP_CALLEE_CLOBBERS\t\tPVOP_VCALLEE_CLOBBERS\n+\n+#define EXTRA_CLOBBERS\n+\n+#else\n+\n+/* 64-bit.  */\n+\n+/* [re]ax isn't an arg, but the return val */\n+#define PVOP_CALL_ARGS\t\t\t\t\t\t\\\n+\tunsigned long __edi = __edi, __esi = __esi,\t\t\\\n+\t\t__edx = __edx, __ecx = __ecx, __eax = __eax;\n+\n+#define PVOP_CALL_ARG1(x)\t\t\"D\" ((unsigned long)(x))\n+#define PVOP_CALL_ARG2(x)\t\t\"S\" ((unsigned long)(x))\n+\n+#define PVOP_VCALL_CLOBBERS\t\"=D\" (__edi),\t\t\t\t\\\n+\t\t\t\t\"=S\" (__esi), \"=d\" (__edx),\t\t\\\n+\t\t\t\t\"=c\" (__ecx)\n+#define PVOP_CALL_CLOBBERS\tPVOP_VCALL_CLOBBERS, \"=a\" (__eax)\n+#define PVOP_VCALLEE_CLOBBERS\t\"=a\" (__eax)\n+#define PVOP_CALLEE_CLOBBERS\tPVOP_VCALLEE_CLOBBERS\n+\n+#define EXTRA_CLOBBERS\t , \"r8\", \"r9\", \"r10\", \"r11\"\n+#endif\t/* CONFIG_X86_32 */\n+\n+#define PVOP_TEST_NULL(op)\t((void)pv_ops.op)\n+\n+#define PVOP_RETVAL(rettype)\t\t\t\t\t\t\\\n+\t({\tunsigned long __mask = ~0UL;\t\t\t\t\\\n+\t\tswitch (sizeof(rettype)) {\t\t\t\t\\\n+\t\tcase 1: __mask =       0xffUL; break;\t\t\t\\\n+\t\tcase 2: __mask =     0xffffUL; break;\t\t\t\\\n+\t\tcase 4: __mask = 0xffffffffUL; break;\t\t\t\\\n+\t\tdefault: break;\t\t\t\t\t\t\\\n+\t\t}\t\t\t\t\t\t\t\\\n+\t\t__mask & __eax;\t\t\t\t\t\t\\\n+\t})\n+\n+#define ____PVOP_CALL(ret, op, clbr, call_clbr, extra_clbr, ...)\t\\\n+\t({\t\t\t\t\t\t\t\t\\\n+\t\tPVOP_CALL_ARGS;\t\t\t\t\t\t\\\n+\t\tPVOP_TEST_NULL(op);\t\t\t\t\t\\\n+\t\tasm volatile(paravirt_alt(PARAVIRT_CALL)\t\t\\\n+\t\t\t     : call_clbr, ASM_CALL_CONSTRAINT\t\t\\\n+\t\t\t     : paravirt_type(op),\t\t\t\\\n+\t\t\t       paravirt_clobber(clbr),\t\t\t\\\n+\t\t\t       ##__VA_ARGS__\t\t\t\t\\\n+\t\t\t     : \"memory\", \"cc\" extra_clbr);\t\t\\\n+\t\tret;\t\t\t\t\t\t\t\\\n+\t})\n+\n+#define __PVOP_CALL(rettype, op, ...)\t\t\t\t\t\\\n+\t____PVOP_CALL(PVOP_RETVAL(rettype), op, CLBR_ANY,\t\t\\\n+\t\t      PVOP_CALL_CLOBBERS, EXTRA_CLOBBERS, ##__VA_ARGS__)\n+\n+#define PVOP_CALL2(rettype, op, arg1, arg2)\t\t\t\t\\\n+\t__PVOP_CALL(rettype, op, PVOP_CALL_ARG1(arg1), PVOP_CALL_ARG2(arg2))\n+\n+static inline u64 paravirt_read_msr_safe(unsigned msr, int *err)\n+{\n+\treturn PVOP_CALL2(u64, cpu.read_msr_safe, msr, err);\n+}\n+\n+#define rdmsr_safe(msr, a, b)\t\t\t\t\\\n+({\t\t\t\t\t\t\t\\\n+\tint _err;\t\t\t\t\t\\\n+\tu64 _l = paravirt_read_msr_safe(msr, &_err);\t\\\n+\t(*a) = (u32)_l;\t\t\t\t\t\\\n+\t(*b) = _l >> 32;\t\t\t\t\\\n+\t_err;\t\t\t\t\t\t\\\n+})\n+\n+\n+void check_init_int(int);\n+void check_init_u32(u32);\n+\n+void test(void)\n+{\n+  int err;\n+  u32 eax, edx;\n+  err = rdmsr_safe(0, &eax, &edx);\n+  check_init_int(err);\n+  check_init_u32(eax);\n+  check_init_u32(edx);\n+}"}, {"sha": "0a1c48f580053ef0a5402265ba9655a4f7add15b", "filename": "gcc/testsuite/gcc.dg/analyzer/torture/asm-x86-linux-rdmsr.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ded2c2c068f6f2825474758cb03a05070a5837e8/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftorture%2Fasm-x86-linux-rdmsr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ded2c2c068f6f2825474758cb03a05070a5837e8/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftorture%2Fasm-x86-linux-rdmsr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftorture%2Fasm-x86-linux-rdmsr.c?ref=ded2c2c068f6f2825474758cb03a05070a5837e8", "patch": "@@ -0,0 +1,33 @@\n+/* { dg-do assemble { target x86_64-*-* } } */\n+/* { dg-skip-if \"\" { *-*-* } { \"-fno-fat-lto-objects\" } { \"\" } } */\n+\n+#include \"../analyzer-decls.h\"\n+\n+/* Adapted from Linux: arch/x86/include/asm/msr.h (GPL-2.0)  */\n+\n+#ifdef __x86_64__\n+#define DECLARE_ARGS(val, low, high)\tunsigned long low, high\n+#define EAX_EDX_VAL(val, low, high)\t((low) | (high) << 32)\n+#define EAX_EDX_RET(val, low, high)\t\"=a\" (low), \"=d\" (high)\n+#else\n+#define DECLARE_ARGS(val, low, high)\tunsigned long long val\n+#define EAX_EDX_VAL(val, low, high)\t(val)\n+#define EAX_EDX_RET(val, low, high)\t\"=A\" (val)\n+#endif\n+\n+static unsigned long long __rdmsr(unsigned int msr)\n+{\n+\tDECLARE_ARGS(val, low, high);\n+\n+\tasm volatile(\"1: rdmsr\\n\"\n+\t\t     \"2:\\n\"\n+\t\t     : EAX_EDX_RET(val, low, high) : \"c\" (msr));\n+\n+\treturn EAX_EDX_VAL(val, low, high);\n+}\n+\n+void test (void)\n+{\n+  __analyzer_eval (__rdmsr (0)); /* { dg-warning \"UNKNOWN\" } */\n+  __analyzer_eval (__rdmsr (1)); /* { dg-warning \"UNKNOWN\" } */\n+}"}, {"sha": "e90dccf58dd20feddb3a0f8ecef3367664a20e8c", "filename": "gcc/testsuite/gcc.dg/analyzer/torture/asm-x86-linux-wfx_get_ps_timeout-full.c", "status": "added", "additions": 319, "deletions": 0, "changes": 319, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ded2c2c068f6f2825474758cb03a05070a5837e8/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftorture%2Fasm-x86-linux-wfx_get_ps_timeout-full.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ded2c2c068f6f2825474758cb03a05070a5837e8/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftorture%2Fasm-x86-linux-wfx_get_ps_timeout-full.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftorture%2Fasm-x86-linux-wfx_get_ps_timeout-full.c?ref=ded2c2c068f6f2825474758cb03a05070a5837e8", "patch": "@@ -0,0 +1,319 @@\n+/* { dg-do assemble { target x86_64-*-* } } */\n+/* { dg-require-effective-target lp64 } */\n+/* { dg-additional-options \"-fsanitize=bounds -fno-analyzer-call-summaries\" } */\n+/* { dg-skip-if \"\" { *-*-* } { \"-O0\" } { \"\" } } */\n+\n+/* Reduced from linux kernel: drivers/staging/wfx/sta.c (GPL-2.0)\n+   on x86_64 with \"allyesconfig\"\n+\n+   This test is deliberately not fully reduced, as an integration test\n+   that the analyzer doesn't emit bogus \"dereference of NULL\" warnings\n+   on the repeated wdev_to_wvif calls.  */\n+\n+#define NULL ((void *)0)\n+\n+/* Types.  */\n+\n+typedef unsigned char __u8;\n+typedef unsigned short __u16;\n+__extension__ typedef unsigned long long __u64;\n+\n+typedef __u8 u8;\n+typedef __u16 u16;\n+typedef __u64 u64;\n+\n+enum { false = 0, true = 1 };\n+typedef _Bool bool;\n+\n+struct device;\n+\n+typedef struct {\n+  int counter;\n+} atomic_t;\n+\n+struct static_key {\n+  atomic_t enabled;\n+  union {\n+    unsigned long type;\n+    struct jump_entry *entries;\n+    struct static_key_mod *next;\n+  };\n+};\n+\n+struct static_key_true {\n+  struct static_key key;\n+};\n+\n+struct static_key_false {\n+  struct static_key key;\n+};\n+\n+struct _ddebug {\n+  const char *modname;\n+  const char *function;\n+  const char *filename;\n+  const char *format;\n+  unsigned int lineno : 18;\n+  unsigned int flags : 8;\n+\n+  union {\n+    struct static_key_true dd_key_true;\n+    struct static_key_false dd_key_false;\n+  } key;\n+\n+} __attribute__((aligned(8)));\n+\n+enum nl80211_iftype {\n+  /* [...snip...] */\n+  NL80211_IFTYPE_AP,\n+  /* [...snip...] */\n+  NUM_NL80211_IFTYPES,\n+  NL80211_IFTYPE_MAX = NUM_NL80211_IFTYPES - 1\n+};\n+\n+struct ieee80211_channel {\n+  /* [...snip...] */\n+  u16 hw_value;\n+  /* [...snip...] */\n+};\n+\n+struct cfg80211_chan_def {\n+  struct ieee80211_channel *chan;\n+  /* [...snip...] */\n+};\n+\n+struct ieee80211_bss_conf {\n+  /* [...snip...] */\n+  bool assoc, ibss_joined;\n+  /* [...snip...] */\n+  struct cfg80211_chan_def chandef;\n+  /* [...snip...] */\n+  bool ps;\n+  /* [...snip...] */\n+};\n+\n+struct ieee80211_conf {\n+  /* [...snip...] */\n+  int power_level, dynamic_ps_timeout;\n+  /* [...snip...] */\n+};\n+\n+struct ieee80211_vif {\n+  enum nl80211_iftype type;\n+  struct ieee80211_bss_conf bss_conf;\n+  /* [...snip...] */\n+  u8 drv_priv[] __attribute__((__aligned__(sizeof(void *))));\n+};\n+\n+struct ieee80211_hw {\n+  struct ieee80211_conf conf;\n+  /* [...snip...] */\n+};\n+\n+struct wfx_dev {\n+  /* [...snip...] */\n+  struct device *dev;\n+  struct ieee80211_hw *hw;\n+  struct ieee80211_vif *vif[2];\n+  /* [...snip...] */\n+  int force_ps_timeout;\n+};\n+\n+struct wfx_vif {\n+  struct wfx_dev *wdev;\n+  struct ieee80211_vif *vif;\n+  /* [...snip...] */\n+};\n+\n+/* Function decls.  */\n+\n+extern __attribute__((__format__(printf, 1, 2))) void\n+__warn_printk(const char *fmt, ...);\n+\n+extern bool ____wrong_branch_error(void);\n+\n+extern __attribute__((__format__(printf, 3, 4))) void\n+__dynamic_dev_dbg(struct _ddebug *descriptor, const struct device *dev,\n+                  const char *fmt, ...);\n+\n+bool wfx_api_older_than(struct wfx_dev *wdev, int major, int minor);\n+\n+/* Function defns.  */\n+\n+static inline unsigned long array_index_mask_nospec(unsigned long index,\n+                                                    unsigned long size) {\n+  unsigned long mask;\n+\n+  asm volatile(\"cmp %1,%2; sbb %0,%0;\"\n+               : \"=r\"(mask)\n+               : \"g\"(size), \"r\"(index)\n+               : \"cc\");\n+  return mask;\n+}\n+\n+static inline __attribute__((__always_inline__)) bool\n+arch_static_branch(struct static_key *key, bool branch) {\n+  asm goto(\"1:\"\n+           \"jmp %l[l_yes] # objtool NOPs this \\n\\t\"\n+           \".pushsection __jump_table,  \\\"aw\\\" \\n\\t\"\n+           \" \"\n+           \".balign 8\"\n+           \" \"\n+           \"\\n\\t\"\n+           \".long 1b - . \\n\\t\"\n+           \".long %l[l_yes] - . \\n\\t\"\n+           \" \"\n+           \".quad\"\n+           \" \"\n+           \"%c0 + %c1 - .\\n\\t\"\n+           \".popsection \\n\\t\"\n+           :\n+           : \"i\"(key), \"i\"(2 | branch)\n+           :\n+           : l_yes);\n+  asm(\"\");\n+\n+  return false;\n+l_yes:\n+  return true;\n+}\n+\n+static inline __attribute__((__always_inline__)) bool\n+arch_static_branch_jump(struct static_key *const key, const bool branch) {\n+  asm goto(\"1:\"\n+           \"jmp %l[l_yes]\\n\\t\"\n+           \".pushsection __jump_table,  \\\"aw\\\" \\n\\t\"\n+           \" \"\n+           \".balign 8\"\n+           \" \"\n+           \"\\n\\t\"\n+           \".long 1b - . \\n\\t\"\n+           \".long %l[l_yes] - . \\n\\t\"\n+           \" \"\n+           \".quad\"\n+           \" \"\n+           \"%c0 + %c1 - .\\n\\t\"\n+           \".popsection \\n\\t\"\n+           :\n+           : \"i\"(key), \"i\"(branch)\n+           :\n+           : l_yes);\n+  asm(\"\");\n+\n+  return false;\n+l_yes:\n+  return true;\n+}\n+\n+static inline struct wfx_vif *wdev_to_wvif(struct wfx_dev *wdev, int vif_id) {\n+  if (vif_id >=\n+      (sizeof(wdev->vif) / sizeof((wdev->vif)[0]) + ((int)(sizeof(struct {\n+         int : (-!!(__builtin_types_compatible_p(typeof((wdev->vif)),\n+                                                 typeof(&(wdev->vif)[0]))));\n+       }))))) {\n+    static struct _ddebug __attribute__((__aligned__(8)))\n+    __attribute__((__section__(\"__dyndbg\"))) __UNIQUE_ID_ddebug1678 = {\n+        .modname = \"wfx\",\n+        .function = __func__,\n+        .filename = \"drivers/staging/wfx/wfx.h\",\n+        .format = (\"requesting non-existent vif: %d\\n\"),\n+        .lineno = 97,\n+        .flags = 0,\n+        .key.dd_key_false = ((struct static_key_false){\n+            .key = {.enabled = {0}, {.entries = (void *)0UL}},\n+        })};\n+    if (({\n+          bool branch;\n+          if (__builtin_types_compatible_p(\n+                  typeof(*&__UNIQUE_ID_ddebug1678.key.dd_key_false),\n+                  struct static_key_true))\n+            branch = arch_static_branch_jump(\n+                &(&__UNIQUE_ID_ddebug1678.key.dd_key_false)->key, false);\n+          else if (__builtin_types_compatible_p(\n+                       typeof(*&__UNIQUE_ID_ddebug1678.key.dd_key_false),\n+                       struct static_key_false))\n+            branch = arch_static_branch(\n+                &(&__UNIQUE_ID_ddebug1678.key.dd_key_false)->key, false);\n+          else\n+            branch = ____wrong_branch_error();\n+          __builtin_expect(!!(branch), 0);\n+        }))\n+      __dynamic_dev_dbg(&__UNIQUE_ID_ddebug1678, wdev->dev,\n+                        \"requesting non-existent vif: %d\\n\", vif_id);\n+    return NULL;\n+  }\n+  typeof(vif_id) _i = (vif_id);\n+  typeof((sizeof(wdev->vif) / sizeof((wdev->vif)[0]) + ((int)(sizeof(struct {\n+            int : (-!!(__builtin_types_compatible_p(typeof((wdev->vif)),\n+                                                    typeof(&(wdev->vif)[0]))));\n+          }))))) _s =\n+      ((sizeof(wdev->vif) / sizeof((wdev->vif)[0]) + ((int)(sizeof(struct {\n+          int : (-!!(__builtin_types_compatible_p(typeof((wdev->vif)),\n+                                                  typeof(&(wdev->vif)[0]))));\n+        })))));\n+  unsigned long _mask = array_index_mask_nospec(_i, _s);\n+  vif_id = (typeof(_i))(_i & _mask);\n+  if (!wdev->vif[vif_id]) {\n+    static struct _ddebug __attribute__((__aligned__(8)))\n+    __attribute__((__section__(\"__dyndbg\"))) __UNIQUE_ID_ddebug1681 = {\n+        .modname = \"wfx\",\n+        .function = __func__,\n+        .filename = \"drivers/staging/wfx/wfx.h\",\n+        .format = (\"requesting non-allocated vif: %d\\n\"),\n+        .lineno = 102,\n+        .flags = 0,\n+        .key.dd_key_false = ((struct static_key_false){\n+            .key = {.enabled = {0}, {.entries = (void *)0UL}},\n+        })};\n+    if (({\n+          bool branch;\n+          if (__builtin_types_compatible_p(\n+                  typeof(*&__UNIQUE_ID_ddebug1681.key.dd_key_false),\n+                  struct static_key_true))\n+            branch = arch_static_branch_jump(\n+                &(&__UNIQUE_ID_ddebug1681.key.dd_key_false)->key, false);\n+          else if (__builtin_types_compatible_p(\n+                       typeof(*&__UNIQUE_ID_ddebug1681.key.dd_key_false),\n+                       struct static_key_false))\n+            branch = arch_static_branch(\n+                &(&__UNIQUE_ID_ddebug1681.key.dd_key_false)->key, false);\n+          else\n+            branch = ____wrong_branch_error();\n+          __builtin_expect(!!(branch), 0);\n+        }))\n+      __dynamic_dev_dbg(&__UNIQUE_ID_ddebug1681, wdev->dev,\n+                        \"requesting non-allocated vif: %d\\n\", vif_id);\n+    return NULL;\n+  }\n+  return (struct wfx_vif *)wdev->vif[vif_id]->drv_priv;\n+}\n+\n+int wfx_get_ps_timeout(struct wfx_vif *wvif, bool *enable_ps) {\n+  struct ieee80211_channel *chan0 = NULL, *chan1 = NULL;\n+  struct ieee80211_conf *conf = &wvif->wdev->hw->conf;\n+\n+  if (wdev_to_wvif(wvif->wdev, 0))\n+    chan0 = wdev_to_wvif(wvif->wdev, 0)->vif->bss_conf.chandef.chan; /* { dg-bogus \"dereference of NULL\" } */\n+  if (wdev_to_wvif(wvif->wdev, 1))\n+    chan1 = wdev_to_wvif(wvif->wdev, 1)->vif->bss_conf.chandef.chan; /* { dg-bogus \"dereference of NULL\" } */\n+  if (chan0 && chan1 && chan0->hw_value != chan1->hw_value &&\n+      wvif->vif->type != NL80211_IFTYPE_AP) {\n+\n+    if (enable_ps)\n+      *enable_ps = true;\n+    if (wvif->wdev->force_ps_timeout > -1)\n+      return wvif->wdev->force_ps_timeout;\n+    else if (wfx_api_older_than(wvif->wdev, 3, 2))\n+      return 0;\n+    else\n+      return 30;\n+  }\n+  if (enable_ps)\n+    *enable_ps = wvif->vif->bss_conf.ps;\n+  if (wvif->wdev->force_ps_timeout > -1)\n+    return wvif->wdev->force_ps_timeout;\n+  else if (wvif->vif->bss_conf.assoc && wvif->vif->bss_conf.ps)\n+    return conf->dynamic_ps_timeout;\n+  else\n+    return -1;\n+}"}, {"sha": "a18c58c5e610a532156103f42c96ee7ff392f58e", "filename": "gcc/testsuite/gcc.dg/analyzer/torture/asm-x86-linux-wfx_get_ps_timeout-reduced.c", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ded2c2c068f6f2825474758cb03a05070a5837e8/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftorture%2Fasm-x86-linux-wfx_get_ps_timeout-reduced.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ded2c2c068f6f2825474758cb03a05070a5837e8/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftorture%2Fasm-x86-linux-wfx_get_ps_timeout-reduced.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Ftorture%2Fasm-x86-linux-wfx_get_ps_timeout-reduced.c?ref=ded2c2c068f6f2825474758cb03a05070a5837e8", "patch": "@@ -0,0 +1,77 @@\n+/* { dg-do assemble { target x86_64-*-* } } */\n+/* { dg-require-effective-target lp64 } */\n+\n+/* Reproducer for false positive from -Wanalyzer-null-dereference seen\n+   in Linux kernel (drivers/staging/wfx/sta.c; GPL-2.0) due to\n+   the analyzer not grokking that array_index_mask_nospec is\n+   effectively pure, and thus not realizing that array_index_no_spec\n+   is also pure, leading to wdev_to_wvif not being treated as pure,\n+   and thus able to return non-NULL and then NULL.  */\n+\n+typedef unsigned char u8;\n+#define NULL ((void *)0)\n+\n+/* Types.  */\n+\n+struct ieee80211_vif {\n+  int placeholder;\n+  /* snip */\n+  u8 drv_priv[];\n+};\n+\n+struct wfx_dev {\n+  /* snip */\n+  struct ieee80211_vif *vif[2];\n+  /* snip */\n+};\n+\n+struct wfx_vif {\n+  struct wfx_dev *wdev;\n+  struct ieee80211_vif *vif;\n+  /* snip */\n+};\n+\n+/* Copied from arch/x86/include/asm/barrier.h */\n+\n+static inline unsigned long array_index_mask_nospec(unsigned long index,\n+\t\tunsigned long size)\n+{\n+\tunsigned long mask;\n+\n+\tasm volatile (\"cmp %1,%2; sbb %0,%0;\"\n+\t\t\t:\"=r\" (mask)\n+\t\t\t:\"g\"(size),\"r\" (index)\n+\t\t\t:\"cc\");\n+\treturn mask;\n+}\n+\n+/* Simplified from include/linux/kernel.h */\n+#define ARRAY_SIZE(arr) (sizeof(arr) / sizeof((arr)[0]))\n+\n+/* Simplified from include/linux/nospec.h */\n+\n+#define array_index_nospec(index, size)\t\t\t\t\t\\\n+({\t\t\t\t\t\t\t\t\t\\\n+\ttypeof(index) _i = (index);\t\t\t\t\t\\\n+\ttypeof(size) _s = (size);\t\t\t\t\t\\\n+\tunsigned long _mask = array_index_mask_nospec(_i, _s);\t\t\\\n+\t/* snip */\t\t\t\t\t\t\t\\\n+\t(typeof(_i)) (_i & _mask);\t\t\t\t\t\\\n+})\n+\n+/* Simplified from drivers/staging/wfx/wfx.h */\n+\n+static inline struct wfx_vif *wdev_to_wvif(struct wfx_dev *wdev, int vif_id) {\n+  vif_id = array_index_nospec(vif_id, ARRAY_SIZE(wdev->vif));\n+  if (!wdev->vif[vif_id]) {\n+    return NULL;\n+  }\n+  return (struct wfx_vif *)wdev->vif[vif_id]->drv_priv;\n+}\n+\n+struct ieee80211_vif *test (struct wfx_vif *wvif) {\n+  if (wdev_to_wvif(wvif->wdev, 1))\n+    return wdev_to_wvif(wvif->wdev, 1)->vif; /* { dg-bogus \"dereference of NULL\" } */\n+  else\n+    return NULL;\n+}"}]}