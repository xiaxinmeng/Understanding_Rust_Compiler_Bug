{"sha": "c152593057a3315c3e11343efb2717d5fa8b5df0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzE1MjU5MzA1N2EzMzE1YzNlMTEzNDNlZmIyNzE3ZDVmYThiNWRmMA==", "commit": {"author": {"name": "Tobias Burnus", "email": "burnus@net-b.de", "date": "2018-10-16T18:37:08Z"}, "committer": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2018-10-16T18:37:08Z"}, "message": "Fix bounds with ALLOCATE with source-expr\n\n        PR fortran/67125\n        * trans-array.c (gfc_array_init_size, gfc_array_allocate):\n        Rename argument e3_is_array_constr to e3_has_nodescriptor\n        and update comments.\n        * trans-stmt.c (gfc_trans_allocate): Also fix lower bound\n        to 1 for nonalloc/nonpointer func results/vars besides\n        array constructors.\n\n        PR fortran/67125\n        * gfortran.dg/allocate_with_source_26.f90: New.\n\nFrom-SVN: r265212", "tree": {"sha": "494f41ed69baffeea88852147f7a3958480cd6ee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/494f41ed69baffeea88852147f7a3958480cd6ee"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c152593057a3315c3e11343efb2717d5fa8b5df0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c152593057a3315c3e11343efb2717d5fa8b5df0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c152593057a3315c3e11343efb2717d5fa8b5df0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c152593057a3315c3e11343efb2717d5fa8b5df0/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "91ab2a1d6e137c2eaa6f8f5966b611bca700ef96", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91ab2a1d6e137c2eaa6f8f5966b611bca700ef96", "html_url": "https://github.com/Rust-GCC/gccrs/commit/91ab2a1d6e137c2eaa6f8f5966b611bca700ef96"}], "stats": {"total": 115, "additions": 101, "deletions": 14}, "files": [{"sha": "1d9d65ccd685f6f2f3d3f74cdf8fca3b2cc34029", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c152593057a3315c3e11343efb2717d5fa8b5df0/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c152593057a3315c3e11343efb2717d5fa8b5df0/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=c152593057a3315c3e11343efb2717d5fa8b5df0", "patch": "@@ -1,3 +1,13 @@\n+2018-10-16  Tobias Burnus  <burnus@net-b.de>\n+\n+\tPR fortran/67125\n+\t* trans-array.c (gfc_array_init_size, gfc_array_allocate):\n+\tRename argument e3_is_array_constr to e3_has_nodescriptor\n+\tand update comments.\n+\t* trans-stmt.c (gfc_trans_allocate): Also fix lower bound\n+\tto 1 for nonalloc/nonpointer func results/vars besides\n+\tarray constructors.\n+\n 2018-10-16  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/87556"}, {"sha": "ea4cf8cd1b8acd57ed250b1672658cab471d4abb", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c152593057a3315c3e11343efb2717d5fa8b5df0/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c152593057a3315c3e11343efb2717d5fa8b5df0/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=c152593057a3315c3e11343efb2717d5fa8b5df0", "patch": "@@ -5333,7 +5333,7 @@ gfc_array_init_size (tree descriptor, int rank, int corank, tree * poffset,\n \t\t     gfc_expr ** lower, gfc_expr ** upper, stmtblock_t * pblock,\n \t\t     stmtblock_t * descriptor_block, tree * overflow,\n \t\t     tree expr3_elem_size, tree *nelems, gfc_expr *expr3,\n-\t\t     tree expr3_desc, bool e3_is_array_constr, gfc_expr *expr)\n+\t\t     tree expr3_desc, bool e3_has_nodescriptor, gfc_expr *expr)\n {\n   tree type;\n   tree tmp;\n@@ -5412,10 +5412,11 @@ gfc_array_init_size (tree descriptor, int rank, int corank, tree * poffset,\n       gfc_init_se (&se, NULL);\n       if (expr3_desc != NULL_TREE)\n \t{\n-\t  if (e3_is_array_constr)\n-\t    /* The lbound of a constant array [] starts at zero, but when\n-\t       allocating it, the standard expects the array to start at\n-\t       one.  */\n+\t  if (e3_has_nodescriptor)\n+\t    /* The lbound of nondescriptor arrays like array constructors,\n+\t       nonallocatable/nonpointer function results/variables,\n+\t       start at zero, but when allocating it, the standard expects\n+\t       the array to start at one.  */\n \t    se.expr = gfc_index_one_node;\n \t  else\n \t    se.expr = gfc_conv_descriptor_lbound_get (expr3_desc,\n@@ -5451,12 +5452,13 @@ gfc_array_init_size (tree descriptor, int rank, int corank, tree * poffset,\n       gfc_init_se (&se, NULL);\n       if (expr3_desc != NULL_TREE)\n \t{\n-\t  if (e3_is_array_constr)\n+\t  if (e3_has_nodescriptor)\n \t    {\n-\t      /* The lbound of a constant array [] starts at zero, but when\n-\t       allocating it, the standard expects the array to start at\n-\t       one.  Therefore fix the upper bound to be\n-\t       (desc.ubound - desc.lbound)+ 1.  */\n+\t      /* The lbound of nondescriptor arrays like array constructors,\n+\t\t nonallocatable/nonpointer function results/variables,\n+\t\t start at zero, but when allocating it, the standard expects\n+\t\t the array to start at one.  Therefore fix the upper bound to be\n+\t\t (desc.ubound - desc.lbound) + 1.  */\n \t      tmp = fold_build2_loc (input_location, MINUS_EXPR,\n \t\t\t\t     gfc_array_index_type,\n \t\t\t\t     gfc_conv_descriptor_ubound_get (\n@@ -5684,7 +5686,7 @@ bool\n gfc_array_allocate (gfc_se * se, gfc_expr * expr, tree status, tree errmsg,\n \t\t    tree errlen, tree label_finish, tree expr3_elem_size,\n \t\t    tree *nelems, gfc_expr *expr3, tree e3_arr_desc,\n-\t\t    bool e3_is_array_constr)\n+\t\t    bool e3_has_nodescriptor)\n {\n   tree tmp;\n   tree pointer;\n@@ -5813,7 +5815,7 @@ gfc_array_allocate (gfc_se * se, gfc_expr * expr, tree status, tree errmsg,\n \t\t\t      &offset, lower, upper,\n \t\t\t      &se->pre, &set_descriptor_block, &overflow,\n \t\t\t      expr3_elem_size, nelems, expr3, e3_arr_desc,\n-\t\t\t      e3_is_array_constr, expr);\n+\t\t\t      e3_has_nodescriptor, expr);\n \n   if (dimension)\n     {"}, {"sha": "c778df06329b3ee42aa892d3cbdfcbe9768dde3a", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c152593057a3315c3e11343efb2717d5fa8b5df0/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c152593057a3315c3e11343efb2717d5fa8b5df0/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=c152593057a3315c3e11343efb2717d5fa8b5df0", "patch": "@@ -5801,6 +5801,7 @@ gfc_trans_allocate (gfc_code * code)\n   tree nelems;\n   bool upoly_expr, tmp_expr3_len_flag = false, al_len_needs_set, is_coarray;\n   bool needs_caf_sync, caf_refs_comp;\n+  bool e3_has_nodescriptor = false;\n   gfc_symtree *newsym = NULL;\n   symbol_attribute caf_attr;\n   gfc_actual_arglist *param_list;\n@@ -6236,6 +6237,17 @@ gfc_trans_allocate (gfc_code * code)\n \t}\n       else\n \te3rhs = gfc_copy_expr (code->expr3);\n+\n+      // We need to propagate the bounds of the expr3 for source=/mold=;\n+      // however, for nondescriptor arrays, we use internally a lower bound\n+      // of zero instead of one, which needs to be corrected for the allocate obj\n+      if (e3_is == E3_DESC)\n+\t{\n+\t  symbol_attribute attr = gfc_expr_attr (code->expr3);\n+\t  if (code->expr3->expr_type == EXPR_ARRAY ||\n+\t      (!attr.allocatable && !attr.pointer))\n+\t    e3_has_nodescriptor = true;\n+\t}\n     }\n \n   /* Loop over all objects to allocate.  */\n@@ -6319,12 +6331,12 @@ gfc_trans_allocate (gfc_code * code)\n \t}\n       else\n \ttmp = expr3_esize;\n+\n       if (!gfc_array_allocate (&se, expr, stat, errmsg, errlen,\n \t\t\t       label_finish, tmp, &nelems,\n \t\t\t       e3rhs ? e3rhs : code->expr3,\n \t\t\t       e3_is == E3_DESC ? expr3 : NULL_TREE,\n-\t\t\t       code->expr3 != NULL && e3_is == E3_DESC\n-\t\t\t       && code->expr3->expr_type == EXPR_ARRAY))\n+\t\t\t       e3_has_nodescriptor))\n \t{\n \t  /* A scalar or derived type.  First compute the size to\n \t     allocate."}, {"sha": "59bada061f446fd1fa513e556d0649c1068371fb", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c152593057a3315c3e11343efb2717d5fa8b5df0/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c152593057a3315c3e11343efb2717d5fa8b5df0/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c152593057a3315c3e11343efb2717d5fa8b5df0", "patch": "@@ -1,3 +1,8 @@\n+2018-10-16  Tobias Burnus  <burnus@net-b.de>\n+\n+\tPR fortran/67125\n+\t* gfortran.dg/allocate_with_source_26.f90: New.\n+\n 2018-10-15  David Malcolm  <dmalcolm@redhat.com>\n \n \t* gcc.dg/missing-header-fixit-3.c: Update expected indentation"}, {"sha": "38127c06bc0723c66629dac07e3466c7f85852d8", "filename": "gcc/testsuite/gfortran.dg/allocate_with_source_26.f90", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c152593057a3315c3e11343efb2717d5fa8b5df0/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocate_with_source_26.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c152593057a3315c3e11343efb2717d5fa8b5df0/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocate_with_source_26.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocate_with_source_26.f90?ref=c152593057a3315c3e11343efb2717d5fa8b5df0", "patch": "@@ -0,0 +1,58 @@\n+! { dg-do run }\n+!\n+! Ensure that the lower bound starts with the correct\n+! value\n+!\n+! PR fortran/87580\n+! PR fortran/67125\n+!\n+! Contributed by Antony Lewis and mrestelli\n+!\n+program p\n+ implicit none\n+ integer, allocatable :: a(:), b(:), c(:), d(:), e(:)\n+ integer :: vec(6)\n+\n+ vec = [1,2,3,4,5,6]\n+\n+ allocate(a, source=f(3))\n+ allocate(b, source=g(3))\n+ allocate(c, source=h(3))\n+ allocate(d, source=[1,2,3,4,5])\n+ allocate(e, source=vec)\n+\n+ !write(*,*) lbound(a,1), ubound(a,1) ! prints 1 3\n+ !write(*,*) lbound(b,1), ubound(b,1) ! prints 1 3\n+ !write(*,*) lbound(c,1), ubound(c,1) ! prints 3 5\n+ !write(*,*) lbound(d,1), ubound(d,1) ! prints 1 5\n+ !write(*,*) lbound(e,1), ubound(e,1) ! prints 1 6\n+\n+ if (lbound(a,1) /= 1 .or. ubound(a,1) /= 3 &\n+     .or. lbound(b,1) /= 1 .or. ubound(b,1) /= 3 &\n+     .or. lbound(c,1) /= 3 .or. ubound(c,1) /= 5 &\n+     .or. lbound(d,1) /= 1 .or. ubound(d,1) /= 5 &\n+     .or. lbound(e,1) /= 1 .or. ubound(e,1) /= 6) then\n+   call abort()\n+ endif\n+   \n+contains\n+\n+ pure function f(i)\n+  integer, intent(in) :: i\n+  integer :: f(i)\n+   f = 2*i\n+ end function f\n+\n+ pure function g(i) result(r)\n+  integer, value, intent(in) :: i\n+  integer, allocatable :: r(:)\n+  r = [1,2,3]\n+ end function g\n+\n+ pure function h(i) result(r)\n+  integer, value, intent(in) :: i\n+  integer, allocatable :: r(:)\n+  allocate(r(3:5))\n+  r = [1,2,3]\n+ end function h\n+end program p"}]}