{"sha": "be6c485b24f2b47ac85380dd2bea025d353f1f91", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmU2YzQ4NWIyNGYyYjQ3YWM4NTM4MGRkMmJlYTAyNWQzNTNmMWY5MQ==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2021-01-07T02:44:07Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2021-01-07T02:44:07Z"}, "message": "analyzer: fix false leak reports when merging states [PR97074]\n\ngcc/analyzer/ChangeLog:\n\tPR analyzer/97074\n\t* store.cc (binding_cluster::can_merge_p): Add \"out_store\" param\n\tand pass to calls to binding_cluster::make_unknown_relative_to.\n\t(binding_cluster::make_unknown_relative_to): Add \"out_store\"\n\tparam.  Use it to mark base regions that are pointed to by\n\tpointers that become unknown as having escaped.\n\t(store::can_merge_p): Pass out_store to\n\tbinding_cluster::can_merge_p.\n\t* store.h (binding_cluster::can_merge_p): Add \"out_store\" param.\n\t(binding_cluster::make_unknown_relative_to): Likewise.\n\t* svalue.cc (region_svalue::implicitly_live_p): New vfunc.\n\t* svalue.h (region_svalue::implicitly_live_p): New vfunc decl.\n\ngcc/testsuite/ChangeLog:\n\tPR analyzer/97074\n\t* gcc.dg/analyzer/pr97074.c: New test.", "tree": {"sha": "2283d0408d31fa4edf81fb319fb88275dfb938f4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2283d0408d31fa4edf81fb319fb88275dfb938f4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/be6c485b24f2b47ac85380dd2bea025d353f1f91", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be6c485b24f2b47ac85380dd2bea025d353f1f91", "html_url": "https://github.com/Rust-GCC/gccrs/commit/be6c485b24f2b47ac85380dd2bea025d353f1f91", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be6c485b24f2b47ac85380dd2bea025d353f1f91/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cffe6dd2ce358c2cb550c9fb3c57cec65eee1c93", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cffe6dd2ce358c2cb550c9fb3c57cec65eee1c93", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cffe6dd2ce358c2cb550c9fb3c57cec65eee1c93"}], "stats": {"total": 75, "additions": 72, "deletions": 3}, "files": [{"sha": "23118d05685637b82cded4a1877664bfd8a650f3", "filename": "gcc/analyzer/store.cc", "status": "modified", "additions": 20, "deletions": 3, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be6c485b24f2b47ac85380dd2bea025d353f1f91/gcc%2Fanalyzer%2Fstore.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be6c485b24f2b47ac85380dd2bea025d353f1f91/gcc%2Fanalyzer%2Fstore.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fstore.cc?ref=be6c485b24f2b47ac85380dd2bea025d353f1f91", "patch": "@@ -1177,6 +1177,7 @@ bool\n binding_cluster::can_merge_p (const binding_cluster *cluster_a,\n \t\t\t      const binding_cluster *cluster_b,\n \t\t\t      binding_cluster *out_cluster,\n+\t\t\t      store *out_store,\n \t\t\t      store_manager *mgr,\n \t\t\t      model_merger *merger)\n {\n@@ -1197,14 +1198,14 @@ binding_cluster::can_merge_p (const binding_cluster *cluster_a,\n     {\n       gcc_assert (cluster_b != NULL);\n       gcc_assert (cluster_b->m_base_region == out_cluster->m_base_region);\n-      out_cluster->make_unknown_relative_to (cluster_b, mgr);\n+      out_cluster->make_unknown_relative_to (cluster_b, out_store, mgr);\n       return true;\n     }\n   if (cluster_b == NULL)\n     {\n       gcc_assert (cluster_a != NULL);\n       gcc_assert (cluster_a->m_base_region == out_cluster->m_base_region);\n-      out_cluster->make_unknown_relative_to (cluster_a, mgr);\n+      out_cluster->make_unknown_relative_to (cluster_a, out_store, mgr);\n       return true;\n     }\n \n@@ -1298,6 +1299,7 @@ binding_cluster::can_merge_p (const binding_cluster *cluster_a,\n \n void\n binding_cluster::make_unknown_relative_to (const binding_cluster *other,\n+\t\t\t\t\t   store *out_store,\n \t\t\t\t\t   store_manager *mgr)\n {\n   for (map_t::iterator iter = other->m_map.begin ();\n@@ -1309,6 +1311,21 @@ binding_cluster::make_unknown_relative_to (const binding_cluster *other,\n \t= mgr->get_svalue_manager ()->get_or_create_unknown_svalue\n \t  (iter_sval->get_type ());\n       m_map.put (iter_key, unknown_sval);\n+\n+      /* For any pointers in OTHER, the merger means that the\n+\t concrete pointer becomes an unknown value, which could\n+\t show up as a false report of a leak when considering what\n+\t pointers are live before vs after.\n+\t Avoid this by marking the base regions they point to as having\n+\t escaped.  */\n+      if (const region_svalue *region_sval\n+\t  = iter_sval->dyn_cast_region_svalue ())\n+\t{\n+\t  const region *base_reg\n+\t    = region_sval->get_pointee ()->get_base_region ();\n+\t  binding_cluster *c = out_store->get_or_create_cluster (base_reg);\n+\t  c->mark_as_escaped ();\n+\t}\n     }\n }\n \n@@ -2092,7 +2109,7 @@ store::can_merge_p (const store *store_a, const store *store_b,\n       binding_cluster *out_cluster\n \t= out_store->get_or_create_cluster (base_reg);\n       if (!binding_cluster::can_merge_p (cluster_a, cluster_b,\n-\t\t\t\t\t out_cluster, mgr, merger))\n+\t\t\t\t\t out_cluster, out_store, mgr, merger))\n \treturn false;\n     }\n   return true;"}, {"sha": "366439ce2dd1618ead2ed4cf627b12c5dbc8c4cd", "filename": "gcc/analyzer/store.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be6c485b24f2b47ac85380dd2bea025d353f1f91/gcc%2Fanalyzer%2Fstore.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be6c485b24f2b47ac85380dd2bea025d353f1f91/gcc%2Fanalyzer%2Fstore.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fstore.h?ref=be6c485b24f2b47ac85380dd2bea025d353f1f91", "patch": "@@ -434,9 +434,11 @@ class binding_cluster\n   static bool can_merge_p (const binding_cluster *cluster_a,\n \t\t\t   const binding_cluster *cluster_b,\n \t\t\t   binding_cluster *out_cluster,\n+\t\t\t   store *out_store,\n \t\t\t   store_manager *mgr,\n \t\t\t   model_merger *merger);\n   void make_unknown_relative_to (const binding_cluster *other_cluster,\n+\t\t\t\t store *out_store,\n \t\t\t\t store_manager *mgr);\n \n   void mark_as_escaped ();"}, {"sha": "5bbd05e832725cabcb1e22ab5fe2abb66f727e6d", "filename": "gcc/analyzer/svalue.cc", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be6c485b24f2b47ac85380dd2bea025d353f1f91/gcc%2Fanalyzer%2Fsvalue.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be6c485b24f2b47ac85380dd2bea025d353f1f91/gcc%2Fanalyzer%2Fsvalue.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsvalue.cc?ref=be6c485b24f2b47ac85380dd2bea025d353f1f91", "patch": "@@ -509,6 +509,22 @@ region_svalue::accept (visitor *v) const\n   m_reg->accept (v);\n }\n \n+/* Implementation of svalue::implicitly_live_p vfunc for region_svalue.  */\n+\n+bool\n+region_svalue::implicitly_live_p (const svalue_set &,\n+\t\t\t\t  const region_model *model) const\n+{\n+  /* Pointers into clusters that have escaped should be treated as live.  */\n+  const region *base_reg = get_pointee ()->get_base_region ();\n+  const store *store = model->get_store ();\n+  if (const binding_cluster *c = store->get_cluster (base_reg))\n+    if (c->escaped_p ())\n+\treturn true;\n+\n+  return false;\n+}\n+\n /* Evaluate the condition LHS OP RHS.\n    Subroutine of region_model::eval_condition for when we have a pair of\n    pointers.  */"}, {"sha": "0703cac8bb33b90af4d784a8a5fa4a19e5544521", "filename": "gcc/analyzer/svalue.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be6c485b24f2b47ac85380dd2bea025d353f1f91/gcc%2Fanalyzer%2Fsvalue.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be6c485b24f2b47ac85380dd2bea025d353f1f91/gcc%2Fanalyzer%2Fsvalue.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsvalue.h?ref=be6c485b24f2b47ac85380dd2bea025d353f1f91", "patch": "@@ -194,6 +194,8 @@ class region_svalue : public svalue\n \n   void dump_to_pp (pretty_printer *pp, bool simple) const FINAL OVERRIDE;\n   void accept (visitor *v) const FINAL OVERRIDE;\n+  bool implicitly_live_p (const svalue_set &,\n+\t\t\t  const region_model *) const FINAL OVERRIDE;\n \n   const region * get_pointee () const { return m_reg; }\n "}, {"sha": "ccb3b61bd415b2836e7d5b359add8349bf3ab70c", "filename": "gcc/testsuite/gcc.dg/analyzer/pr97074.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be6c485b24f2b47ac85380dd2bea025d353f1f91/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr97074.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be6c485b24f2b47ac85380dd2bea025d353f1f91/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr97074.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr97074.c?ref=be6c485b24f2b47ac85380dd2bea025d353f1f91", "patch": "@@ -0,0 +1,32 @@\n+#include \"analyzer-decls.h\"\n+#define NULL ((void *)0)\n+\n+void *x, *y;\n+\n+void test_1 (int flag)\n+{\n+  void *p = __builtin_malloc (1024);\n+  if (flag)\n+    x = p;\n+  else\n+    y = p;\n+} /* { dg-bogus \"leak\" } */\n+\n+struct s2\n+{\n+  void *f1;\n+  void *f2;\n+};\n+\n+struct s2 test_2 (int flag)\n+{\n+  struct s2 r;\n+  r.f1 = NULL;\n+  r.f2 = NULL;\n+  void *p = __builtin_malloc (1024);\n+  if (flag)\n+    r.f1 = p;\n+  else\n+    r.f2 = p;\n+  return r;\n+}"}]}