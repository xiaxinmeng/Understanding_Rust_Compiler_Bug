{"sha": "84538074d9b5ae903c2d3561653b071995bdc934", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODQ1MzgwNzRkOWI1YWU5MDNjMmQzNTYxNjUzYjA3MTk5NWJkYzkzNA==", "commit": {"author": {"name": "Jerome Lambourg", "email": "lambourg@adacore.com", "date": "2016-04-18T09:24:08Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2016-04-18T09:24:08Z"}, "message": "sigtramp-vxworks-target.inc: sigtramp-vxworks: force the stack alignment for x86_64.\n\n2016-04-18  Jerome Lambourg  <lambourg@adacore.com>\n\n\t* sigtramp-vxworks-target.inc: sigtramp-vxworks: force the stack\n\talignment for x86_64.\n\t* init.c: Better fix for guard page reset on x86_64-vx7.\n\tDo not try to retrieve the page that actually raised\n\tthe signal as the probing mechanism used on x86_64 do not allow\n\tsuch retrieval. We thus just test if the guard page is active,\n\tand re-activate it if not.\n\nFrom-SVN: r235102", "tree": {"sha": "bc015aa7a5ff8ea2b213941770336c5c8f466f0b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bc015aa7a5ff8ea2b213941770336c5c8f466f0b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/84538074d9b5ae903c2d3561653b071995bdc934", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84538074d9b5ae903c2d3561653b071995bdc934", "html_url": "https://github.com/Rust-GCC/gccrs/commit/84538074d9b5ae903c2d3561653b071995bdc934", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/84538074d9b5ae903c2d3561653b071995bdc934/comments", "author": {"login": "lambourg", "id": 480233, "node_id": "MDQ6VXNlcjQ4MDIzMw==", "avatar_url": "https://avatars.githubusercontent.com/u/480233?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lambourg", "html_url": "https://github.com/lambourg", "followers_url": "https://api.github.com/users/lambourg/followers", "following_url": "https://api.github.com/users/lambourg/following{/other_user}", "gists_url": "https://api.github.com/users/lambourg/gists{/gist_id}", "starred_url": "https://api.github.com/users/lambourg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lambourg/subscriptions", "organizations_url": "https://api.github.com/users/lambourg/orgs", "repos_url": "https://api.github.com/users/lambourg/repos", "events_url": "https://api.github.com/users/lambourg/events{/privacy}", "received_events_url": "https://api.github.com/users/lambourg/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "230ad3691829ee68b2e25ac1347dbe88240d7598", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/230ad3691829ee68b2e25ac1347dbe88240d7598", "html_url": "https://github.com/Rust-GCC/gccrs/commit/230ad3691829ee68b2e25ac1347dbe88240d7598"}], "stats": {"total": 83, "additions": 40, "deletions": 43}, "files": [{"sha": "9df5e2b8289c8aaf4adc55c1542981f07e16d164", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84538074d9b5ae903c2d3561653b071995bdc934/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84538074d9b5ae903c2d3561653b071995bdc934/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=84538074d9b5ae903c2d3561653b071995bdc934", "patch": "@@ -1,3 +1,13 @@\n+2016-04-18  Jerome Lambourg  <lambourg@adacore.com>\n+\n+\t* sigtramp-vxworks-target.inc: sigtramp-vxworks: force the stack\n+\talignment for x86_64.\n+\t* init.c: Better fix for guard page reset on x86_64-vx7.\n+\tDo not try to retrieve the page that actually raised\n+\tthe signal as the probing mechanism used on x86_64 do not allow\n+\tsuch retrieval. We thus just test if the guard page is active,\n+\tand re-activate it if not.\n+\n 2016-04-18  Arnaud Charlet  <charlet@adacore.com>\n \n \t* a-sytaco.adb (Suspension_Object): Aspect Default_Initial_Condition"}, {"sha": "ae9b58e0fb80288abb978556751e0de40a365553", "filename": "gcc/ada/init.c", "status": "modified", "additions": 20, "deletions": 35, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84538074d9b5ae903c2d3561653b071995bdc934/gcc%2Fada%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84538074d9b5ae903c2d3561653b071995bdc934/gcc%2Fada%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Finit.c?ref=84538074d9b5ae903c2d3561653b071995bdc934", "patch": "@@ -1759,7 +1759,7 @@ getpid (void)\n    This function returns TRUE in case the guard page was hit by the\n    signal. */\n static int\n-__gnat_reset_guard_page (int sig, void *sc)\n+__gnat_reset_guard_page (int sig)\n {\n   /* On ARM VxWorks 6.x and x86_64 VxWorks 7, the guard page is left un-armed\n      by the kernel after being violated, so subsequent violations aren't\n@@ -1776,42 +1776,24 @@ __gnat_reset_guard_page (int sig, void *sc)\n \n   TASK_ID tid           = taskIdSelf ();\n   WIND_TCB *pTcb        = taskTcb (tid);\n-  REG_SET *pregs        = ((struct sigcontext *) sc)->sc_pregs;\n   VIRT_ADDR guardPage   = (VIRT_ADDR) pTcb->pStackEnd - INT_OVERFLOW_SIZE;\n   UINT stateMask        = VM_STATE_MASK_VALID;\n-  UINT state            = VM_STATE_VALID_NOT;\n-  size_t probe_distance = 0;\n-  VIRT_ADDR sigPage;\n+  UINT guardState       = VM_STATE_VALID_NOT;\n \n-#if defined (ARMEL)\n-  /* violating address in rip: r12 */\n-  sigPage    = pregs->r[12] & ~(INT_OVERFLOW_SIZE - 1);\n-#elif defined (__x86_64__)\n-  /* violating address in rsp. */\n-  probe_distance = 16 * 1024; /* in gcc/config/i386/vxworks7.h */\n-  sigPage    = pregs->rsp & ~(INT_OVERFLOW_SIZE - 1);\n-  stateMask |= MMU_ATTR_SPL_MSK;\n-  state     |= MMU_ATTR_NO_BLOCK;\n-#else\n-#error \"Not Implemented for this CPU\"\n+#if (_WRS_VXWORKS_MAJOR >= 7)\n+  stateMask  |= MMU_ATTR_SPL_MSK;\n+  guardState |= MMU_ATTR_NO_BLOCK;\n #endif\n \n-  if (guardPage == (sigPage - probe_distance))\n+  UINT nState;\n+  vmStateGet (NULL, guardPage, &nState);\n+  if ((nState & VM_STATE_MASK_VALID) != VM_STATE_VALID_NOT)\n     {\n-      UINT nState;\n-      vmStateGet (NULL, guardPage, &nState);\n-      if ((nState & VM_STATE_MASK_VALID) != VM_STATE_VALID_NOT) {\n-        /* If the guard page has a valid state, we need to reset to\n-           invalid state here */\n-        vmStateSet (NULL, guardPage, INT_OVERFLOW_SIZE, stateMask, state);\n-      }\n-\n+      /* If the guard page has a valid state, we need to reset to\n+         invalid state here */\n+      vmStateSet (NULL, guardPage, INT_OVERFLOW_SIZE, stateMask, guardState);\n       return TRUE;\n     }\n-  else\n-    {\n-      return FALSE;\n-    }\n #endif /* VXWORKS_FORCE_GUARD_PAGE */\n   return FALSE;\n }\n@@ -1919,7 +1901,7 @@ __gnat_map_signal (int sig, siginfo_t *si ATTRIBUTE_UNUSED, void *sc)\n       msg = \"unhandled signal\";\n     }\n \n-  if (__gnat_reset_guard_page (sig, sc))\n+  if (__gnat_reset_guard_page (sig))\n     {\n       /* Set the exception message: we know for sure that we have a\n          stack overflow here */\n@@ -1997,14 +1979,17 @@ __gnat_error_handler (int sig, siginfo_t *si, void *sc)\n      when they contain SPE instructions, we need to set it back before doing\n      anything else.\n      This mechanism is only need in kernel mode. */\n-#if !(defined (__RTP__) || defined (CERT)) && ((CPU == PPCE500V2) || (CPU == PPC85XX))\n+#if !(defined (__RTP__) || defined (VTHREADS)) && ((CPU == PPCE500V2) || (CPU == PPC85XX))\n   register unsigned msr;\n   /* Read the MSR value */\n   asm volatile (\"mfmsr %0\" : \"=r\" (msr));\n-  /* Force the SPE bit */\n-  msr |= 0x02000000;\n-  /* Store to MSR */\n-  asm volatile (\"mtmsr %0\" : : \"r\" (msr));\n+  /* Force the SPE bit if not set.  */\n+  if ((msr & 0x02000000) == 0)\n+    {\n+      msr |= 0x02000000;\n+      /* Store to MSR */\n+      asm volatile (\"mtmsr %0\" : : \"r\" (msr));\n+    }\n #endif\n \n   /* VxWorks will always mask out the signal during the signal handler and"}, {"sha": "722dd31c7b5535e01374a8342e7d34455e1a10e8", "filename": "gcc/ada/sigtramp-vxworks-target.inc", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/84538074d9b5ae903c2d3561653b071995bdc934/gcc%2Fada%2Fsigtramp-vxworks-target.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/84538074d9b5ae903c2d3561653b071995bdc934/gcc%2Fada%2Fsigtramp-vxworks-target.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsigtramp-vxworks-target.inc?ref=84538074d9b5ae903c2d3561653b071995bdc934", "patch": "@@ -159,7 +159,7 @@\n #define REGNO_R13 13\n #define REGNO_R14 14\n #define REGNO_R15 15\n-#define REGNO_SET_PC 16 /* aka %rip */\n+#define REGNO_RPC 16 /* aka %rip */\n #define REGNO_EFLAGS 49\n #define REGNO_FS 54\n \n@@ -401,8 +401,6 @@ TCR(\"ret\")\n \n #define COMMON_CFI(REG) \\\n   \".cfi_offset \" S(REGNO_##REG) \",\" S(REG_##REG)\n-#define PC_CFI(REG) \\\n-  \".cfi_offset \" S(REGNO_##REG) \",\" S(REG_##REG)\n \n #define CFI_COMMON_REGS \\\n CR(\"# CFI for common registers\\n\") \\\n@@ -422,10 +420,8 @@ TCR(COMMON_CFI(RBX)) \\\n TCR(COMMON_CFI(RDX)) \\\n TCR(COMMON_CFI(RCX)) \\\n TCR(COMMON_CFI(RAX)) \\\n-TCR(COMMON_CFI(EFLAGS)) \\\n-TCR(COMMON_CFI(SET_PC)) \\\n-TCR(COMMON_CFI(FS)) \\\n-TCR(\".cfi_return_column \" S(REGNO_SET_PC))\n+TCR(COMMON_CFI(RPC)) \\\n+TCR(\".cfi_return_column \" S(REGNO_RPC))\n \n /* Trampoline body block\n    ---------------------  */\n@@ -451,10 +447,17 @@ Not_implemented;\n /* Symbol definition block\n    -----------------------  */\n \n+#ifdef __x86_64__\n+#define FUNC_ALIGN TCR(\".p2align 4,,15\")\n+#else\n+#define FUNC_ALIGN\n+#endif\n+\n #define SIGTRAMP_START(SYM) \\\n CR(\"# \" S(SYM) \" cfi trampoline\") \\\n TCR(\".type \" S(SYM) \", \"FUNCTION) \\\n CR(\"\") \\\n+FUNC_ALIGN \\\n CR(S(SYM) \":\") \\\n TCR(\".cfi_startproc\") \\\n TCR(\".cfi_signal_frame\")\n@@ -474,4 +477,3 @@ TCR(\".size \" S(SYM) \", .-\" S(SYM))\n \n asm (\".text\\n\"\n      TCR(\".align 2\"));\n-"}]}