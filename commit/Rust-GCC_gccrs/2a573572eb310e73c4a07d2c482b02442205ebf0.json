{"sha": "2a573572eb310e73c4a07d2c482b02442205ebf0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmE1NzM1NzJlYjMxMGU3M2M0YTA3ZDJjNDgyYjAyNDQyMjA1ZWJmMA==", "commit": {"author": {"name": "Mikael Morin", "email": "mikael@gcc.gnu.org", "date": "2012-08-14T16:28:29Z"}, "committer": {"name": "Mikael Morin", "email": "mikael@gcc.gnu.org", "date": "2012-08-14T16:28:29Z"}, "message": "gfortran.h (gfc_get_proc_ptr_comp): New prototype.\n\nfortran/\n\t* gfortran.h (gfc_get_proc_ptr_comp): New prototype.\n\t(gfc_is_proc_ptr_comp): Update prototype.\n\t* expr.c (gfc_get_proc_ptr_comp): New function based on the old\n\tgfc_is_proc_ptr_comp.\n\t(gfc_is_proc_ptr_comp): Call gfc_get_proc_ptr_comp.\n\t(gfc_specification_expr, gfc_check_pointer_assign): Use\n\tgfc_get_proc_ptr_comp.\n\t* trans-array.c (gfc_walk_function_expr): Likewise.\n\t* resolve.c (resolve_structure_cons, update_ppc_arglist,\n\tresolve_ppc_call, resolve_expr_ppc): Likewise.\n\t(resolve_function): Update call to gfc_is_proc_ptr_comp.\n\t* dump-parse-tree.c (show_expr): Likewise.\n\t* interface.c (compare_actual_formal): Likewise.\n\t* match.c (gfc_match_pointer_assignment): Likewise.\n\t* primary.c (gfc_match_varspec): Likewise.\n\t* trans-io.c (gfc_trans_transfer): Likewise.\n\t* trans-expr.c (gfc_conv_variable, conv_function_val,\n\tconv_isocbinding_procedure, gfc_conv_procedure_call,\n\tgfc_trans_pointer_assignment): Likewise.\n\t(gfc_conv_procedure_call, gfc_trans_array_func_assign):\n\tUse gfc_get_proc_ptr_comp.\n\nFrom-SVN: r190391", "tree": {"sha": "9a18e0b10e011cc6fa3f311bee0aebc8ee677295", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9a18e0b10e011cc6fa3f311bee0aebc8ee677295"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2a573572eb310e73c4a07d2c482b02442205ebf0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a573572eb310e73c4a07d2c482b02442205ebf0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2a573572eb310e73c4a07d2c482b02442205ebf0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a573572eb310e73c4a07d2c482b02442205ebf0/comments", "author": null, "committer": null, "parents": [{"sha": "cc360b36dfccb7179f0ff2d01bfeb5161237aaae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc360b36dfccb7179f0ff2d01bfeb5161237aaae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cc360b36dfccb7179f0ff2d01bfeb5161237aaae"}], "stats": {"total": 129, "additions": 80, "deletions": 49}, "files": [{"sha": "6309b5a25f36b19bc2d31702b5aa51ff066bde82", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a573572eb310e73c4a07d2c482b02442205ebf0/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a573572eb310e73c4a07d2c482b02442205ebf0/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=2a573572eb310e73c4a07d2c482b02442205ebf0", "patch": "@@ -1,3 +1,27 @@\n+2012-08-14  Mikael Morin  <mikael@gcc.gnu.org>\n+\n+\t* gfortran.h (gfc_get_proc_ptr_comp): New prototype.\n+\t(gfc_is_proc_ptr_comp): Update prototype.\n+\t* expr.c (gfc_get_proc_ptr_comp): New function based on the old\n+\tgfc_is_proc_ptr_comp.\n+\t(gfc_is_proc_ptr_comp): Call gfc_get_proc_ptr_comp.\n+\t(gfc_specification_expr, gfc_check_pointer_assign): Use\n+\tgfc_get_proc_ptr_comp.\n+\t* trans-array.c (gfc_walk_function_expr): Likewise.\n+\t* resolve.c (resolve_structure_cons, update_ppc_arglist,\n+\tresolve_ppc_call, resolve_expr_ppc): Likewise.\n+\t(resolve_function): Update call to gfc_is_proc_ptr_comp.\n+\t* dump-parse-tree.c (show_expr): Likewise.\n+\t* interface.c (compare_actual_formal): Likewise.\n+\t* match.c (gfc_match_pointer_assignment): Likewise.\n+\t* primary.c (gfc_match_varspec): Likewise.\n+\t* trans-io.c (gfc_trans_transfer): Likewise.\n+\t* trans-expr.c (gfc_conv_variable, conv_function_val,\n+\tconv_isocbinding_procedure, gfc_conv_procedure_call,\n+\tgfc_trans_pointer_assignment): Likewise.\n+\t(gfc_conv_procedure_call, gfc_trans_array_func_assign):\n+\tUse gfc_get_proc_ptr_comp.\n+\n 2012-08-14  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/40881"}, {"sha": "cb8fab4fe354a7c5d1c5bbc6bc0fa9a4dee43744", "filename": "gcc/fortran/dump-parse-tree.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a573572eb310e73c4a07d2c482b02442205ebf0/gcc%2Ffortran%2Fdump-parse-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a573572eb310e73c4a07d2c482b02442205ebf0/gcc%2Ffortran%2Fdump-parse-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdump-parse-tree.c?ref=2a573572eb310e73c4a07d2c482b02442205ebf0", "patch": "@@ -569,7 +569,7 @@ show_expr (gfc_expr *p)\n       if (p->value.function.name == NULL)\n \t{\n \t  fprintf (dumpfile, \"%s\", p->symtree->n.sym->name);\n-\t  if (gfc_is_proc_ptr_comp (p, NULL))\n+\t  if (gfc_is_proc_ptr_comp (p))\n \t    show_ref (p->ref);\n \t  fputc ('[', dumpfile);\n \t  show_actual_arglist (p->value.function.actual);\n@@ -578,7 +578,7 @@ show_expr (gfc_expr *p)\n       else\n \t{\n \t  fprintf (dumpfile, \"%s\", p->value.function.name);\n-\t  if (gfc_is_proc_ptr_comp (p, NULL))\n+\t  if (gfc_is_proc_ptr_comp (p))\n \t    show_ref (p->ref);\n \t  fputc ('[', dumpfile);\n \t  fputc ('[', dumpfile);"}, {"sha": "7d745285c010dfcdf737a0ae28cb46c89816ec78", "filename": "gcc/fortran/expr.c", "status": "modified", "additions": 27, "deletions": 21, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a573572eb310e73c4a07d2c482b02442205ebf0/gcc%2Ffortran%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a573572eb310e73c4a07d2c482b02442205ebf0/gcc%2Ffortran%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fexpr.c?ref=2a573572eb310e73c4a07d2c482b02442205ebf0", "patch": "@@ -2962,12 +2962,12 @@ gfc_specification_expr (gfc_expr *e)\n       return FAILURE;\n     }\n \n+  comp = gfc_get_proc_ptr_comp (e);\n   if (e->expr_type == EXPR_FUNCTION\n-\t  && !e->value.function.isym\n-\t  && !e->value.function.esym\n-\t  && !gfc_pure (e->symtree->n.sym)\n-\t  && (!gfc_is_proc_ptr_comp (e, &comp)\n-\t      || !comp->attr.pure))\n+      && !e->value.function.isym\n+      && !e->value.function.esym\n+      && !gfc_pure (e->symtree->n.sym)\n+      && (!comp || !comp->attr.pure))\n     {\n       gfc_error (\"Function '%s' at %L must be PURE\",\n \t\t e->symtree->n.sym->name, &e->where);\n@@ -3495,12 +3495,14 @@ gfc_check_pointer_assign (gfc_expr *lvalue, gfc_expr *rvalue)\n \t    }\n \t}\n \n-      if (gfc_is_proc_ptr_comp (lvalue, &comp))\n+      comp = gfc_get_proc_ptr_comp (lvalue);\n+      if (comp)\n \ts1 = comp->ts.interface;\n       else\n \ts1 = lvalue->symtree->n.sym;\n \n-      if (gfc_is_proc_ptr_comp (rvalue, &comp))\n+      comp = gfc_get_proc_ptr_comp (rvalue);\n+      if (comp)\n \t{\n \t  s2 = comp->ts.interface;\n \t  name = comp->name;\n@@ -4075,31 +4077,35 @@ gfc_expr_set_symbols_referenced (gfc_expr *expr)\n }\n \n \n-/* Determine if an expression is a procedure pointer component. If yes, the\n-   argument 'comp' will point to the component (provided that 'comp' was\n-   provided).  */\n+/* Determine if an expression is a procedure pointer component and return\n+   the component in that case.  Otherwise return NULL.  */\n \n-bool\n-gfc_is_proc_ptr_comp (gfc_expr *expr, gfc_component **comp)\n+gfc_component *\n+gfc_get_proc_ptr_comp (gfc_expr *expr)\n {\n   gfc_ref *ref;\n-  bool ppc = false;\n \n   if (!expr || !expr->ref)\n-    return false;\n+    return NULL;\n \n   ref = expr->ref;\n   while (ref->next)\n     ref = ref->next;\n \n-  if (ref->type == REF_COMPONENT)\n-    {\n-      ppc = ref->u.c.component->attr.proc_pointer;\n-      if (ppc && comp)\n-\t*comp = ref->u.c.component;\n-    }\n+  if (ref->type == REF_COMPONENT\n+      && ref->u.c.component->attr.proc_pointer)\n+    return ref->u.c.component;\n+\n+  return NULL;\n+}\n+\n \n-  return ppc;\n+/* Determine if an expression is a procedure pointer component.  */\n+\n+bool\n+gfc_is_proc_ptr_comp (gfc_expr *expr)\n+{\n+  return (gfc_get_proc_ptr_comp (expr) != NULL);\n }\n \n "}, {"sha": "7c4c0a42bf0822b374d0c6b86ece216ceea14830", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a573572eb310e73c4a07d2c482b02442205ebf0/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a573572eb310e73c4a07d2c482b02442205ebf0/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=2a573572eb310e73c4a07d2c482b02442205ebf0", "patch": "@@ -2766,7 +2766,8 @@ gfc_try gfc_expr_check_typed (gfc_expr*, gfc_namespace*, bool);\n void gfc_expr_replace_symbols (gfc_expr *, gfc_symbol *);\n void gfc_expr_replace_comp (gfc_expr *, gfc_component *);\n \n-bool gfc_is_proc_ptr_comp (gfc_expr *, gfc_component **);\n+gfc_component * gfc_get_proc_ptr_comp (gfc_expr *);\n+bool gfc_is_proc_ptr_comp (gfc_expr *);\n \n bool gfc_ref_this_image (gfc_ref *ref);\n bool gfc_is_coindexed (gfc_expr *);"}, {"sha": "482c294ecbacf15cbd80f2ad0cd56294a8ea2cb6", "filename": "gcc/fortran/interface.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a573572eb310e73c4a07d2c482b02442205ebf0/gcc%2Ffortran%2Finterface.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a573572eb310e73c4a07d2c482b02442205ebf0/gcc%2Ffortran%2Finterface.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Finterface.c?ref=2a573572eb310e73c4a07d2c482b02442205ebf0", "patch": "@@ -2558,7 +2558,7 @@ compare_actual_formal (gfc_actual_arglist **ap, gfc_formal_arglist *formal,\n \t\t&& a->expr->symtree->n.sym->attr.proc_pointer)\n \t       || (a->expr->expr_type == EXPR_FUNCTION\n \t\t   && a->expr->symtree->n.sym->result->attr.proc_pointer)\n-\t       || gfc_is_proc_ptr_comp (a->expr, NULL)))\n+\t       || gfc_is_proc_ptr_comp (a->expr)))\n \t{\n \t  if (where)\n \t    gfc_error (\"Expected a procedure pointer for argument '%s' at %L\",\n@@ -2568,7 +2568,7 @@ compare_actual_formal (gfc_actual_arglist **ap, gfc_formal_arglist *formal,\n \n       /* Satisfy 12.4.1.2 by ensuring that a procedure actual argument is\n \t provided for a procedure formal argument.  */\n-      if (a->expr->ts.type != BT_PROCEDURE && !gfc_is_proc_ptr_comp (a->expr, NULL)\n+      if (a->expr->ts.type != BT_PROCEDURE && !gfc_is_proc_ptr_comp (a->expr)\n \t  && a->expr->expr_type == EXPR_VARIABLE\n \t  && f->sym->attr.flavor == FL_PROCEDURE)\n \t{"}, {"sha": "0b1cf5a3dbb73c391ea56f78f0b34a02cafdd8d5", "filename": "gcc/fortran/match.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a573572eb310e73c4a07d2c482b02442205ebf0/gcc%2Ffortran%2Fmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a573572eb310e73c4a07d2c482b02442205ebf0/gcc%2Ffortran%2Fmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.c?ref=2a573572eb310e73c4a07d2c482b02442205ebf0", "patch": "@@ -1344,7 +1344,7 @@ gfc_match_pointer_assignment (void)\n     }\n \n   if (lvalue->symtree->n.sym->attr.proc_pointer\n-      || gfc_is_proc_ptr_comp (lvalue, NULL))\n+      || gfc_is_proc_ptr_comp (lvalue))\n     gfc_matching_procptr_assignment = 1;\n   else\n     gfc_matching_ptr_assignment = 1;"}, {"sha": "cadc20c27b76eda3ba7a81035c2f86aa3e36010b", "filename": "gcc/fortran/primary.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a573572eb310e73c4a07d2c482b02442205ebf0/gcc%2Ffortran%2Fprimary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a573572eb310e73c4a07d2c482b02442205ebf0/gcc%2Ffortran%2Fprimary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fprimary.c?ref=2a573572eb310e73c4a07d2c482b02442205ebf0", "patch": "@@ -1862,7 +1862,7 @@ gfc_match_varspec (gfc_expr *primary, int equiv_flag, bool sub_flag,\n   if ((equiv_flag && gfc_peek_ascii_char () == '(')\n       || gfc_peek_ascii_char () == '[' || sym->attr.codimension\n       || (sym->attr.dimension && sym->ts.type != BT_CLASS\n-\t  && !sym->attr.proc_pointer && !gfc_is_proc_ptr_comp (primary, NULL)\n+\t  && !sym->attr.proc_pointer && !gfc_is_proc_ptr_comp (primary)\n \t  && !(gfc_matching_procptr_assignment\n \t       && sym->attr.flavor == FL_PROCEDURE))\n       || (sym->ts.type == BT_CLASS && sym->attr.class_ok"}, {"sha": "c706b8956d7724e16576c8496e2b246eeb91497d", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a573572eb310e73c4a07d2c482b02442205ebf0/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a573572eb310e73c4a07d2c482b02442205ebf0/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=2a573572eb310e73c4a07d2c482b02442205ebf0", "patch": "@@ -1195,7 +1195,8 @@ resolve_structure_cons (gfc_expr *expr, int init)\n \t  const char *name;\n \t  char err[200];\n \n-\t  if (gfc_is_proc_ptr_comp (cons->expr, &c2))\n+\t  c2 = gfc_get_proc_ptr_comp (cons->expr);\n+\t  if (c2)\n \t    {\n \t      s2 = c2->ts.interface;\n \t      name = c2->name;\n@@ -3093,9 +3094,9 @@ resolve_function (gfc_expr *expr)\n     sym = expr->symtree->n.sym;\n \n   /* If this is a procedure pointer component, it has already been resolved.  */\n-  if (gfc_is_proc_ptr_comp (expr, NULL))\n+  if (gfc_is_proc_ptr_comp (expr))\n     return SUCCESS;\n-  \n+\n   if (sym && sym->attr.intrinsic\n       && gfc_resolve_intrinsic (sym, &expr->where) == FAILURE)\n     return FAILURE;\n@@ -5740,7 +5741,8 @@ update_ppc_arglist (gfc_expr* e)\n   gfc_component *ppc;\n   gfc_typebound_proc* tb;\n \n-  if (!gfc_is_proc_ptr_comp (e, &ppc))\n+  ppc = gfc_get_proc_ptr_comp (e);\n+  if (!ppc)\n     return FAILURE;\n \n   tb = ppc->tb;\n@@ -6363,10 +6365,9 @@ static gfc_try\n resolve_ppc_call (gfc_code* c)\n {\n   gfc_component *comp;\n-  bool b;\n \n-  b = gfc_is_proc_ptr_comp (c->expr1, &comp);\n-  gcc_assert (b);\n+  comp = gfc_get_proc_ptr_comp (c->expr1);\n+  gcc_assert (comp != NULL);\n \n   c->resolved_sym = c->expr1->symtree->n.sym;\n   c->expr1->expr_type = EXPR_VARIABLE;\n@@ -6398,10 +6399,9 @@ static gfc_try\n resolve_expr_ppc (gfc_expr* e)\n {\n   gfc_component *comp;\n-  bool b;\n \n-  b = gfc_is_proc_ptr_comp (e, &comp);\n-  gcc_assert (b);\n+  comp = gfc_get_proc_ptr_comp (e);\n+  gcc_assert (comp != NULL);\n \n   /* Convert to EXPR_FUNCTION.  */\n   e->expr_type = EXPR_FUNCTION;"}, {"sha": "8c254dda6b08a08a3a2f36f2d45613f4bee68b46", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a573572eb310e73c4a07d2c482b02442205ebf0/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a573572eb310e73c4a07d2c482b02442205ebf0/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=2a573572eb310e73c4a07d2c482b02442205ebf0", "patch": "@@ -8666,7 +8666,7 @@ gfc_walk_function_expr (gfc_ss * ss, gfc_expr * expr)\n     sym = expr->symtree->n.sym;\n \n   /* A function that returns arrays.  */\n-  gfc_is_proc_ptr_comp (expr, &comp);\n+  comp = gfc_get_proc_ptr_comp (expr);\n   if ((!comp && gfc_return_by_reference (sym) && sym->result->attr.dimension)\n       || (comp && comp->attr.dimension))\n     return gfc_get_array_ss (ss, expr, expr->rank, GFC_SS_FUNCTION);"}, {"sha": "12a75d0d156a47f5eb66c940919d4625fbe8d3a8", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a573572eb310e73c4a07d2c482b02442205ebf0/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a573572eb310e73c4a07d2c482b02442205ebf0/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=2a573572eb310e73c4a07d2c482b02442205ebf0", "patch": "@@ -1512,9 +1512,9 @@ gfc_conv_variable (gfc_se * se, gfc_expr * expr)\n      separately.  */\n   if (se->want_pointer)\n     {\n-      if (expr->ts.type == BT_CHARACTER && !gfc_is_proc_ptr_comp (expr, NULL))\n+      if (expr->ts.type == BT_CHARACTER && !gfc_is_proc_ptr_comp (expr))\n \tgfc_conv_string_parameter (se);\n-      else \n+      else\n \tse->expr = gfc_build_addr_expr (NULL_TREE, se->expr);\n     }\n }\n@@ -2438,7 +2438,7 @@ conv_function_val (gfc_se * se, gfc_symbol * sym, gfc_expr * expr)\n {\n   tree tmp;\n \n-  if (gfc_is_proc_ptr_comp (expr, NULL))\n+  if (gfc_is_proc_ptr_comp (expr))\n     tmp = get_proc_ptr_comp (expr);\n   else if (sym->attr.dummy)\n     {\n@@ -3447,7 +3447,7 @@ conv_isocbinding_procedure (gfc_se * se, gfc_symbol * sym,\n       if (arg->next->expr->rank == 0)\n \t{\n \t  if (sym->intmod_sym_id == ISOCBINDING_F_POINTER\n-\t      || gfc_is_proc_ptr_comp (arg->next->expr, NULL))\n+\t      || gfc_is_proc_ptr_comp (arg->next->expr))\n \t    fptrse.want_pointer = 1;\n \n \t  gfc_conv_expr (&fptrse, arg->next->expr);\n@@ -3649,7 +3649,7 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n       && conv_isocbinding_procedure (se, sym, args))\n     return 0;\n \n-  gfc_is_proc_ptr_comp (expr, &comp);\n+  comp = gfc_get_proc_ptr_comp (expr);\n \n   if (se->ss != NULL)\n     {\n@@ -3958,7 +3958,7 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t\t\t\t   && e->symtree->n.sym->attr.dummy))\n \t\t\t  || (fsym->attr.proc_pointer\n \t\t\t      && e->expr_type == EXPR_VARIABLE\n-\t\t\t      && gfc_is_proc_ptr_comp (e, NULL))\n+\t\t\t      && gfc_is_proc_ptr_comp (e))\n \t\t\t  || (fsym->attr.allocatable\n \t\t\t      && fsym->attr.flavor != FL_PROCEDURE)))\n \t\t    {\n@@ -6007,7 +6007,7 @@ gfc_trans_pointer_assignment (gfc_expr * expr1, gfc_expr * expr2)\n       if (expr1->ts.type == BT_CHARACTER && expr2->expr_type != EXPR_NULL\n \t  && !expr1->ts.deferred\n \t  && !expr1->symtree->n.sym->attr.proc_pointer\n-\t  && !gfc_is_proc_ptr_comp (expr1, NULL))\n+\t  && !gfc_is_proc_ptr_comp (expr1))\n \t{\n \t  gcc_assert (expr2->ts.type == BT_CHARACTER);\n \t  gcc_assert (lse.string_length && rse.string_length);\n@@ -6700,9 +6700,9 @@ gfc_trans_arrayfunc_assign (gfc_expr * expr1, gfc_expr * expr2)\n \n   /* The frontend doesn't seem to bother filling in expr->symtree for intrinsic\n      functions.  */\n+  comp = gfc_get_proc_ptr_comp (expr2);\n   gcc_assert (expr2->value.function.isym\n-\t      || (gfc_is_proc_ptr_comp (expr2, &comp)\n-\t\t  && comp && comp->attr.dimension)\n+\t      || (comp && comp->attr.dimension)\n \t      || (!comp && gfc_return_by_reference (expr2->value.function.esym)\n \t\t  && expr2->value.function.esym->result->attr.dimension));\n "}, {"sha": "9d7d5b6cb724aa20055aafe00b111e6ae99cd0fd", "filename": "gcc/fortran/trans-io.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a573572eb310e73c4a07d2c482b02442205ebf0/gcc%2Ffortran%2Ftrans-io.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a573572eb310e73c4a07d2c482b02442205ebf0/gcc%2Ffortran%2Ftrans-io.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-io.c?ref=2a573572eb310e73c4a07d2c482b02442205ebf0", "patch": "@@ -2252,7 +2252,7 @@ gfc_trans_transfer (gfc_code * code)\n       /* Transfer an array. If it is an array of an intrinsic\n \t type, pass the descriptor to the library.  Otherwise\n \t scalarize the transfer.  */\n-      if (expr->ref && !gfc_is_proc_ptr_comp (expr, NULL))\n+      if (expr->ref && !gfc_is_proc_ptr_comp (expr))\n \t{\n \t  for (ref = expr->ref; ref && ref->type != REF_ARRAY;\n \t\t ref = ref->next);"}]}