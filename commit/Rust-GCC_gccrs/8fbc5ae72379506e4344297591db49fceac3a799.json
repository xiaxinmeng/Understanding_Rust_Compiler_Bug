{"sha": "8fbc5ae72379506e4344297591db49fceac3a799", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGZiYzVhZTcyMzc5NTA2ZTQzNDQyOTc1OTFkYjQ5ZmNlYWMzYTc5OQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2003-01-16T20:30:50Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2003-01-16T20:30:50Z"}, "message": "cp-tree.h (lang_type_class): Remove is_partial_instantiation.\n\n\t* cp-tree.h (lang_type_class): Remove is_partial_instantiation.\n\t(PARTIAL_INSTANTIATION_P): Remove.\n\t(IMPLICIT_TYPENAME_P): Likewise.\n\t(IMPLICIT_TYPENAME_TYPE_DECL_P): Likewise.\n\t(build_typename_type): Remove declaration.\n\t(parmlist_is_exprlist): Likewise.\n\t* decl.c (build_typename_type): Make it static, remove third\n\tparameter.\n\t(push_class_binding): Don't do implicit typename stuff.\n\t(make_typename_type): Likewise.\n\t(lookup_name_real): Likewise.\n\t(grokdeclarator): Don't try to convert declarations into\n\tinitializations.  Don't do implicit typename stuff.\n\t(parmlist_is_exprlist): Remove.\n\t(xref_basetypes): Simplify.\n\t* decl2.c (grokfield): Don't try to convert declarations into\n\tinitializations.\n\t(build_anon_union_vars): Do this while processing templates, too.\n\t(finish_anon_union): Likewise.\n\t* error.c (dump_type): Remove implicit typename handling.\n\t* parser.c (cp_parser_diagnose_invalid_type_name): New method.\n\t(cp_parser_primary_expression): Correct handling of names not\n\tfound by unqualified name lookup in templates.\n\t(cp_parser_nested_name_specifier_opt): Avoid checking dependency\n\tof types when possible.\n\t(cp_parser_simple_declaration): Complain intelligently about some\n\tinvalid declarations.\n\t(cp_parser_member_declaration): Likewise.\n\t(cp_parser_constructor_declarator_p): Don't check when we're in a\n\tfunction scope.\n\t* pt.c (instantiate_class_template): Remove\n\tPARTIAL_INSTANTIATION_P gunk.\n\t* search.c (lookup_field_r): Don't build implicit typenames.\n\t(marked_pushdecls_p): Don't enter dependent base types.\n\t(unmarked_pushdecls_p): Likewise.\n\t* semantics.c (begin_class_definition): Remove implicit typename\n\tstuff.\n\n\t* config/locale/gnu/messages_members.h: Use this-> to refer to\n\tunqualified members of base clasess.\n\t* config/locale/ieee_1003.1-2001/codecvt_specializations.h: Likewise.\n\t* include/bits/codecvt.h: Likewise.\n\t* include/bits/deque.tcc: Likewise.\n\t* include/bits/fstream.tcc: Likewise.\n\t* include/bits/istream.tcc: Likewise.\n\t* include/bits/list.tcc: Likewise.\n\t* include/bits/locale_facets.h: Likewise.\n\t* include/bits/ostream.tcc: Likewise.\n\t* include/bits/sstream.tcc: Likewise.\n\t* include/bits/stl_bvector.h: Likewise.\n\t* include/bits/stl_deque.h: Likewise.\n\t* include/bits/stl_list.h: Likewise.\n\t* include/bits/stl_tree.h: Likewise.\n\t* include/bits/stl_vector.h: Likewise.\n\t* include/bits/vector.tcc: Likewise.\n\t* include/ext/ropeimpl.h: Likewise.\n\t* include/ext/stdio_filebuf.h: Likewise.\n\t* include/ext/stl_rope.h: Likewise.\n\t* include/std/std_fstream.h: Likewise.\n\t* include/std/std_sstream.h: Likewise.\n\nCo-Authored-By: Jeffrey Oldham <oldham@codesourcery.com>\n\nFrom-SVN: r61403", "tree": {"sha": "a9333721985e67177f1e06a4c7ccc9166503d5bd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a9333721985e67177f1e06a4c7ccc9166503d5bd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8fbc5ae72379506e4344297591db49fceac3a799", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8fbc5ae72379506e4344297591db49fceac3a799", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8fbc5ae72379506e4344297591db49fceac3a799", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8fbc5ae72379506e4344297591db49fceac3a799/comments", "author": null, "committer": null, "parents": [{"sha": "07488f322a10f0f8cc56385e3ab01b4c6b1f5a41", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07488f322a10f0f8cc56385e3ab01b4c6b1f5a41", "html_url": "https://github.com/Rust-GCC/gccrs/commit/07488f322a10f0f8cc56385e3ab01b4c6b1f5a41"}], "stats": {"total": 2371, "additions": 1211, "deletions": 1160}, "files": [{"sha": "aea2a4c372d783e07daa0ba6ad1c647c0b1d3165", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fbc5ae72379506e4344297591db49fceac3a799/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fbc5ae72379506e4344297591db49fceac3a799/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=8fbc5ae72379506e4344297591db49fceac3a799", "patch": "@@ -1,3 +1,43 @@\n+2003-01-16  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* cp-tree.h (lang_type_class): Remove is_partial_instantiation.\n+\t(PARTIAL_INSTANTIATION_P): Remove.\n+\t(IMPLICIT_TYPENAME_P): Likewise.\n+\t(IMPLICIT_TYPENAME_TYPE_DECL_P): Likewise.\n+\t(build_typename_type): Remove declaration.\n+\t(parmlist_is_exprlist): Likewise.\n+\t* decl.c (build_typename_type): Make it static, remove third\n+\tparameter.\n+\t(push_class_binding): Don't do implicit typename stuff.\n+\t(make_typename_type): Likewise.\n+\t(lookup_name_real): Likewise.\n+\t(grokdeclarator): Don't try to convert declarations into\n+\tinitializations.  Don't do implicit typename stuff.\n+\t(parmlist_is_exprlist): Remove.\n+\t(xref_basetypes): Simplify.\n+\t* decl2.c (grokfield): Don't try to convert declarations into\n+\tinitializations.\n+\t(build_anon_union_vars): Do this while processing templates, too.\n+\t(finish_anon_union): Likewise.\n+\t* error.c (dump_type): Remove implicit typename handling.\n+\t* parser.c (cp_parser_diagnose_invalid_type_name): New method.\n+\t(cp_parser_primary_expression): Correct handling of names not\n+\tfound by unqualified name lookup in templates.\n+\t(cp_parser_nested_name_specifier_opt): Avoid checking dependency\n+\tof types when possible.\n+\t(cp_parser_simple_declaration): Complain intelligently about some\n+\tinvalid declarations.\n+\t(cp_parser_member_declaration): Likewise.\n+\t(cp_parser_constructor_declarator_p): Don't check when we're in a\n+\tfunction scope.\n+\t* pt.c (instantiate_class_template): Remove\n+\tPARTIAL_INSTANTIATION_P gunk.\n+\t* search.c (lookup_field_r): Don't build implicit typenames.\n+\t(marked_pushdecls_p): Don't enter dependent base types.\n+\t(unmarked_pushdecls_p): Likewise.\n+\t* semantics.c (begin_class_definition): Remove implicit typename\n+\tstuff.\n+\n 2003-01-16  Nathan Sidwell  <nathan@codesourcery.com>\n \n \tPR c++/9212"}, {"sha": "90c2e598f8ac520749b0fc509cffaa286500b5a9", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 3, "deletions": 23, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fbc5ae72379506e4344297591db49fceac3a799/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fbc5ae72379506e4344297591db49fceac3a799/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=8fbc5ae72379506e4344297591db49fceac3a799", "patch": "@@ -1133,6 +1133,7 @@ struct lang_type_class GTY(())\n   unsigned has_arrow_overloaded : 1;\n   unsigned interface_only : 1;\n   unsigned interface_unknown : 1;\n+  unsigned contains_empty_class_p : 1;\n \n   unsigned marks: 6;\n   unsigned vec_new_uses_cookie : 1;\n@@ -1152,13 +1153,11 @@ struct lang_type_class GTY(())\n   unsigned has_complex_assign_ref : 1;\n   unsigned has_abstract_assign_ref : 1;\n   unsigned non_aggregate : 1;\n-  unsigned is_partial_instantiation : 1;\n   unsigned java_interface : 1;\n-\n   unsigned anon_aggr : 1;\n+\n   unsigned non_zero_init : 1;\n   unsigned empty_p : 1;\n-  unsigned contains_empty_class_p : 1;\n \n   /* When adding a flag here, consider whether or not it ought to\n      apply to a template instance if it applies to the template.  If\n@@ -1167,7 +1166,7 @@ struct lang_type_class GTY(())\n   /* There are some bits left to fill out a 32-bit word.  Keep track\n      of this by updating the size of this bitfield whenever you add or\n      remove a flag.  */\n-  unsigned dummy : 5;\n+  unsigned dummy : 6;\n \n   tree primary_base;\n   tree vfields;\n@@ -2412,17 +2411,6 @@ struct lang_decl GTY(())\n    TEMPLATE_ID_EXPR if we had something like `typename X::Y<T>'.  */\n #define TYPENAME_TYPE_FULLNAME(NODE) (TYPE_FIELDS (NODE))\n \n-/* Nonzero if NODE is an implicit typename.  */\n-#define IMPLICIT_TYPENAME_P(NODE) \\\n-  (TREE_CODE (NODE) == TYPENAME_TYPE && TREE_TYPE (NODE))\n-\n-/* Nonzero if NODE is a TYPE_DECL that should not be visible because\n-   it is from a dependent base class.  */\n-#define IMPLICIT_TYPENAME_TYPE_DECL_P(NODE)\t\\\n-  (TREE_CODE (NODE) == TYPE_DECL\t\t\\\n-   && DECL_ARTIFICIAL (NODE)\t\t\t\\\n-   && IMPLICIT_TYPENAME_P (TREE_TYPE (NODE)))\n-\n /* Nonzero in INTEGER_CST means that this int is negative by dint of\n    using a twos-complement negated operand.  */\n #define TREE_NEGATED_INT(NODE) TREE_LANG_FLAG_0 (INTEGER_CST_CHECK (NODE))\n@@ -2908,12 +2896,6 @@ struct lang_decl GTY(())\n #define DECL_FRIEND_PSEUDO_TEMPLATE_INSTANTIATION(DECL) \\\n   (DECL_TEMPLATE_INFO (DECL) && !DECL_USE_TEMPLATE (DECL))\n \n-/* Nonzero if TYPE is a partial instantiation of a template class,\n-   i.e., an instantiation whose instantiation arguments involve\n-   template types.  */\n-#define PARTIAL_INSTANTIATION_P(TYPE) \\\n-  (LANG_TYPE_CLASS_CHECK (TYPE)->is_partial_instantiation)\n-\n /* Nonzero iff we are currently processing a declaration for an\n    entity with its own template parameter list, and which is not a\n    full specialization.  */\n@@ -3765,7 +3747,6 @@ extern tree binding_for_name                    (tree, tree);\n extern tree namespace_binding                   (tree, tree);\n extern void set_namespace_binding               (tree, tree, tree);\n extern tree lookup_namespace_name\t\t(tree, tree);\n-extern tree build_typename_type                 (tree, tree, tree, tree);\n extern tree make_typename_type\t\t\t(tree, tree, tsubst_flags_t);\n extern tree make_unbound_class_template\t\t(tree, tree, tsubst_flags_t);\n extern tree lookup_name_nonclass\t\t(tree);\n@@ -3800,7 +3781,6 @@ extern int complete_array_type\t\t\t(tree, tree, int);\n extern tree build_ptrmemfunc_type\t\t(tree);\n extern tree build_ptrmem_type                   (tree, tree);\n /* the grokdeclarator prototype is in decl.h */\n-extern int parmlist_is_exprlist\t\t\t(tree);\n extern int copy_fn_p\t\t\t\t(tree);\n extern tree get_scope_of_declarator             (tree);\n extern void grok_special_member_properties\t(tree);"}, {"sha": "4f3d9ed0c18f980acf51f583a153246866485e8f", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 95, "deletions": 212, "changes": 307, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fbc5ae72379506e4344297591db49fceac3a799/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fbc5ae72379506e4344297591db49fceac3a799/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=8fbc5ae72379506e4344297591db49fceac3a799", "patch": "@@ -147,6 +147,7 @@ static void initialize_local_var (tree, tree);\n static void expand_static_init (tree, tree);\n static tree next_initializable_field (tree);\n static tree reshape_init (tree, tree *);\n+static tree build_typename_type (tree, tree, tree);\n \n #if defined (DEBUG_BINDING_LEVELS)\n static void indent (void);\n@@ -1093,27 +1094,18 @@ push_class_binding (tree id, tree decl)\n   binding = IDENTIFIER_BINDING (id);\n   if (BINDING_VALUE (binding) == decl && TREE_CODE (decl) != TREE_LIST)\n     {\n-      /* Any implicit typename must be from a base-class.  The\n-\t context for an implicit typename declaration is always\n-\t the derived class in which the lookup was done, so the checks\n-\t based on the context of DECL below will not trigger.  */\n-      if (IMPLICIT_TYPENAME_TYPE_DECL_P (decl))\n-\tINHERITED_VALUE_BINDING_P (binding) = 1;\n+      if (TREE_CODE (decl) == OVERLOAD)\n+\tcontext = CP_DECL_CONTEXT (OVL_CURRENT (decl));\n       else\n \t{\n-\t  if (TREE_CODE (decl) == OVERLOAD)\n-\t    context = CP_DECL_CONTEXT (OVL_CURRENT (decl));\n-\t  else\n-\t    {\n-\t      my_friendly_assert (DECL_P (decl), 0);\n-\t      context = context_for_name_lookup (decl);\n-\t    }\n-\n-\t  if (is_properly_derived_from (current_class_type, context))\n-\t    INHERITED_VALUE_BINDING_P (binding) = 1;\n-\t  else\n-\t    INHERITED_VALUE_BINDING_P (binding) = 0;\n+\t  my_friendly_assert (DECL_P (decl), 0);\n+\t  context = context_for_name_lookup (decl);\n \t}\n+\n+      if (is_properly_derived_from (current_class_type, context))\n+\tINHERITED_VALUE_BINDING_P (binding) = 1;\n+      else\n+\tINHERITED_VALUE_BINDING_P (binding) = 0;\n     }\n   else if (BINDING_VALUE (binding) == decl)\n     /* We only encounter a TREE_LIST when push_class_decls detects an\n@@ -5437,7 +5429,7 @@ typename_compare (const void * k1, const void * k2)\n static GTY ((param_is (union tree_node))) htab_t typename_htab;\n \n tree\n-build_typename_type (tree context, tree name, tree fullname, tree base_type)\n+build_typename_type (tree context, tree name, tree fullname)\n {\n   tree t;\n   tree d;\n@@ -5453,7 +5445,6 @@ build_typename_type (tree context, tree name, tree fullname, tree base_type)\n   t = make_aggr_type (TYPENAME_TYPE);\n   TYPE_CONTEXT (t) = FROB_CONTEXT (context);\n   TYPENAME_TYPE_FULLNAME (t) = fullname;\n-  TREE_TYPE (t) = base_type;\n \n   /* Build the corresponding TYPE_DECL.  */\n   d = build_decl (TYPE_DECL, name, t);\n@@ -5586,16 +5577,6 @@ make_typename_type (tree context, tree name, tsubst_flags_t complain)\n \n \t      if (DECL_ARTIFICIAL (t) || !(complain & tf_keep_type_decl))\n \t\tt = TREE_TYPE (t);\n-\t      if (IMPLICIT_TYPENAME_P (t))\n-\t\t{\n-\t\t  /* Lookup found an implicit typename that we had\n-\t\t     injected into the current scope. Doing things\n-\t\t     properly would have located the exact same type,\n-\t\t     so there is no error here.  We must remove the\n-\t\t     implicitness so that we do not warn about it.  */\n-\t\t  t = copy_node (t);\n-\t\t  TREE_TYPE (t) = NULL_TREE;\n-\t\t}\n \t      \n \t      return t;\n \t    }\n@@ -5611,7 +5592,7 @@ make_typename_type (tree context, tree name, tsubst_flags_t complain)\n       return error_mark_node;\n     }\n \n-  return build_typename_type (context, name, fullname,  NULL_TREE);\n+  return build_typename_type (context, name, fullname);\n }\n \n /* Resolve `CONTEXT::template NAME'.  Returns an appropriate type,\n@@ -5935,7 +5916,6 @@ lookup_name_real (tree name,\n {\n   tree t;\n   tree val = NULL_TREE;\n-  int val_is_implicit_typename = 0;\n \n   /* Conversion operators are handled specially because ordinary\n      unqualified name lookup will not find template conversion\n@@ -5990,29 +5970,19 @@ lookup_name_real (tree name,\n       else\n \tbinding = NULL_TREE;\n \n-      if (binding\n-\t  && (!val || !IMPLICIT_TYPENAME_TYPE_DECL_P (binding)))\n+      if (binding)\n \t{\n-\t  if (val_is_implicit_typename)\n-\t    warn_about_implicit_typename_lookup (val, binding);\n \t  val = binding;\n-\t  val_is_implicit_typename\n-\t    = IMPLICIT_TYPENAME_TYPE_DECL_P (val);\n-\t  if (!val_is_implicit_typename)\n-\t    break;\n+\t  break;\n \t}\n     }\n \n   /* Now lookup in namespace scopes.  */\n-  if (!val || val_is_implicit_typename)\n+  if (!val)\n     {\n       t = unqualified_namespace_lookup (name, flags, 0);\n       if (t)\n-\t{\n-\t  if (val_is_implicit_typename)\n-\t    warn_about_implicit_typename_lookup (val, t);\n-\t  val = t;\n-\t}\n+\tval = t;\n     }\n \n   if (val)\n@@ -9723,9 +9693,6 @@ grokdeclarator (tree declarator,\n   /* See the code below that used this.  */\n   tree decl_attr = NULL_TREE;\n #endif\n-  /* Set this to error_mark_node for FIELD_DECLs we could not handle properly.\n-     All FIELD_DECLs we build here have `init' put into their DECL_INITIAL.  */\n-  tree init = NULL_TREE;\n \n   /* Keep track of what sort of function is being processed\n      so that we can warn about default return values, or explicit\n@@ -9825,46 +9792,6 @@ grokdeclarator (tree declarator,\n \t    break;\n \n \t  case CALL_EXPR:\n-\t    if (parmlist_is_exprlist (CALL_DECLARATOR_PARMS (decl)))\n-\t      {\n-\t\t/* This is actually a variable declaration using\n-\t\t   constructor syntax.  We need to call start_decl and\n-\t\t   cp_finish_decl so we can get the variable\n-\t\t   initialized...  */\n-\n-\t\ttree attributes;\n-\n-\t\tif (decl_context != NORMAL)\n-\t\t  {\n-\t\t    error (\"variable declaration is not allowed here\");\n-\t\t    return error_mark_node;\n-\t\t  }\n-\n-\t\t*next = TREE_OPERAND (decl, 0);\n-\t\tinit = CALL_DECLARATOR_PARMS (decl);\n-\n-\t\tif (attrlist)\n-\t\t  {\n-\t\t    attributes = *attrlist;\n-\t\t  }\n-\t\telse\n-\t\t  {\n-\t\t    attributes = NULL_TREE;\n-\t\t  }\n-\n-\t\tdecl = start_decl (declarator, declspecs, 1,\n-\t\t\t\t   attributes, NULL_TREE);\n-\t\tif (decl)\n-\t\t  {\n-\t\t    /* Look for __unused__ attribute */\n-\t\t    if (TREE_USED (TREE_TYPE (decl)))\n-\t\t      TREE_USED (decl) = 1;\n-\t\t    finish_decl (decl, init, NULL_TREE);\n-\t\t  }\n-\t\telse\n-\t\t  error (\"invalid declarator\");\n-\t\treturn NULL_TREE;\n-\t      }\n \t    innermost_code = TREE_CODE (decl);\n \t    if (decl_context == FIELD && ctype == NULL_TREE)\n \t      ctype = current_class_type;\n@@ -10294,21 +10221,6 @@ grokdeclarator (tree declarator,\n       type = integer_type_node;\n     }\n   \n-  if (type && IMPLICIT_TYPENAME_P (type))\n-    {\n-      /* The implicit typename extension is deprecated and will be\n-\t removed.  Warn about its use now.  */\n-      warning (\"`%T' is implicitly a typename\", type);\n-      cp_deprecated (\"implicit typename\");\n-\n-      /* Now remove its implicitness, so that we don't warn again.\n-         For instance this might be a typedef, and we do not want to\n-         warn on uses of the typedef itself.  Simply clearing the\n-         TREE_TYPE is insufficient.  */\n-      type = copy_node (type);\n-      TREE_TYPE (type) = NULL_TREE;\n-    }\n-\n   ctype = NULL_TREE;\n \n   /* Now process the modifiers that were specified\n@@ -11903,32 +11815,6 @@ grokdeclarator (tree declarator,\n   }\n }\n \f\n-/* Tell if a parmlist/exprlist looks like an exprlist or a parmlist.\n-   An empty exprlist is a parmlist.  An exprlist which\n-   contains only identifiers at the global level\n-   is a parmlist.  Otherwise, it is an exprlist.  */\n-\n-int\n-parmlist_is_exprlist (tree exprs)\n-{\n-  if (exprs == NULL_TREE || TREE_PARMLIST (exprs))\n-    return 0;\n-\n-  if (toplevel_bindings_p ())\n-    {\n-      /* At the global level, if these are all identifiers,\n-\t then it is a parmlist.  */\n-      while (exprs)\n-\t{\n-\t  if (TREE_CODE (TREE_VALUE (exprs)) != IDENTIFIER_NODE)\n-\t    return 1;\n-\t  exprs = TREE_CHAIN (exprs);\n-\t}\n-      return 0;\n-    }\n-  return 1;\n-}\n-\n /* Subroutine of start_function.  Ensure that each of the parameter\n    types (as listed in PARMS) is complete, as is required for a\n    function definition.  */\n@@ -12963,9 +12849,9 @@ xref_basetypes (tree ref, tree binfo)\n   /* In the declaration `A : X, Y, ... Z' we mark all the types\n      (A, X, Y, ..., Z) so we can check for duplicates.  */\n   tree binfos;\n-  tree base;\n+  tree *basep;\n \n-  int i, len;\n+  int i;\n   enum tag_types tag_code;\n \n   if (TREE_CODE (ref) == UNION_TYPE)\n@@ -12976,17 +12862,25 @@ xref_basetypes (tree ref, tree binfo)\n \n   tag_code = (CLASSTYPE_DECLARED_CLASS (ref) ? class_type : record_type);\n \n-  len = list_length (binfo);\n-\n   /* First, make sure that any templates in base-classes are\n      instantiated.  This ensures that if we call ourselves recursively\n      we do not get confused about which classes are marked and which\n      are not.  */\n-  for (base = binfo; base; base = TREE_CHAIN (base))\n-    complete_type (TREE_VALUE (base));\n+  basep = &binfo; \n+  while (*basep) \n+    {\n+      tree basetype = TREE_VALUE (*basep);\n+      if (!(processing_template_decl && uses_template_parms (basetype))\n+\t  && !complete_type_or_else (basetype, NULL))\n+\t/* An incomplete type.  Remove it form the list.  */\n+\t*basep = TREE_CHAIN (*basep);\n+      else\n+\tbasep = &TREE_CHAIN (*basep);\n+    }\n \n   SET_CLASSTYPE_MARKED (ref);\n-  BINFO_BASETYPES (TYPE_BINFO (ref)) = binfos = make_tree_vec (len);\n+  BINFO_BASETYPES (TYPE_BINFO (ref)) = binfos \n+    = make_tree_vec (list_length (binfo));\n \n   for (i = 0; binfo; binfo = TREE_CHAIN (binfo))\n     {\n@@ -13021,85 +12915,74 @@ xref_basetypes (tree ref, tree binfo)\n \t  continue;\n \t}\n \n-      /* This code replaces similar code in layout_basetypes.\n-         We put the complete_type first for implicit `typename'.  */\n-      if (!COMPLETE_TYPE_P (basetype)\n-\t  && ! (current_template_parms && uses_template_parms (basetype)))\n+      if (CLASSTYPE_MARKED (basetype))\n \t{\n-\t  error (\"base class `%T' has incomplete type\", basetype);\n+\t  if (basetype == ref)\n+\t    error (\"recursive type `%T' undefined\", basetype);\n+\t  else\n+\t    error (\"duplicate base type `%T' invalid\", basetype);\n \t  continue;\n \t}\n-      else\n-\t{\n-\t  if (CLASSTYPE_MARKED (basetype))\n-\t    {\n-\t      if (basetype == ref)\n-\t\terror (\"recursive type `%T' undefined\", basetype);\n-\t      else\n-\t\terror (\"duplicate base type `%T' invalid\", basetype);\n-\t      continue;\n-\t    }\n-\n-\t  if (TYPE_FOR_JAVA (basetype)\n-\t      && (current_lang_depth () == 0))\n-\t    TYPE_FOR_JAVA (ref) = 1;\n-\n-\t  /* Note that the BINFO records which describe individual\n-\t     inheritances are *not* shared in the lattice!  They\n-\t     cannot be shared because a given baseclass may be\n-\t     inherited with different `accessibility' by different\n-\t     derived classes.  (Each BINFO record describing an\n-\t     individual inheritance contains flags which say what\n-\t     the `accessibility' of that particular inheritance is.)  */\n-\n-\t  base_binfo\n-\t    = make_binfo (size_zero_node, basetype,\n-\t\t\t  CLASS_TYPE_P (basetype)\n-\t\t\t  ? TYPE_BINFO_VTABLE (basetype) : NULL_TREE,\n-\t\t\t  CLASS_TYPE_P (basetype)\n-\t\t\t  ? TYPE_BINFO_VIRTUALS (basetype) : NULL_TREE);\n-\n-\t  TREE_VEC_ELT (binfos, i) = base_binfo;\n-\t  TREE_VIA_PUBLIC (base_binfo) = via_public;\n-\t  TREE_VIA_PROTECTED (base_binfo) = via_protected;\n-\t  TREE_VIA_VIRTUAL (base_binfo) = via_virtual;\n-\t  BINFO_INHERITANCE_CHAIN (base_binfo) = TYPE_BINFO (ref);\n-\n-\t  /* We need to unshare the binfos now so that lookups during class\n-\t     definition work.  */\n-\t  unshare_base_binfos (base_binfo);\n-\n-\t  SET_CLASSTYPE_MARKED (basetype);\n-\n-\t  /* We are free to modify these bits because they are meaningless\n-\t     at top level, and BASETYPE is a top-level type.  */\n-\t  if (via_virtual || TYPE_USES_VIRTUAL_BASECLASSES (basetype))\n-\t    {\n-\t      TYPE_USES_VIRTUAL_BASECLASSES (ref) = 1;\n-\t      /* Converting to a virtual base class requires looking\n-\t\t up the offset of the virtual base.  */\n-\t      TYPE_BASE_CONVS_MAY_REQUIRE_CODE_P (ref) = 1;\n-\t    }\n \n-\t  if (CLASS_TYPE_P (basetype))\n-\t    {\n-\t      TYPE_HAS_NEW_OPERATOR (ref)\n-\t\t|= TYPE_HAS_NEW_OPERATOR (basetype);\n-\t      TYPE_HAS_ARRAY_NEW_OPERATOR (ref)\n-\t\t|= TYPE_HAS_ARRAY_NEW_OPERATOR (basetype);\n-\t      TYPE_GETS_DELETE (ref) |= TYPE_GETS_DELETE (basetype);\n-\t      /* If the base-class uses multiple inheritance, so do we.  */\n-\t      TYPE_USES_MULTIPLE_INHERITANCE (ref)\n-\t\t|= TYPE_USES_MULTIPLE_INHERITANCE (basetype);\n-\t      /* Likewise, if converting to a base of the base may require\n-\t\t code, then we may need to generate code to convert to a\n-\t\t base as well.  */\n-\t      TYPE_BASE_CONVS_MAY_REQUIRE_CODE_P (ref)\n-\t\t|= TYPE_BASE_CONVS_MAY_REQUIRE_CODE_P (basetype);\n-\t    }\n-\n-\t  i += 1;\n-\t}\n+      if (TYPE_FOR_JAVA (basetype)\n+\t  && (current_lang_depth () == 0))\n+\tTYPE_FOR_JAVA (ref) = 1;\n+\n+      /* Note that the BINFO records which describe individual\n+\t inheritances are *not* shared in the lattice!  They\n+\t cannot be shared because a given baseclass may be\n+\t inherited with different `accessibility' by different\n+\t derived classes.  (Each BINFO record describing an\n+\t individual inheritance contains flags which say what\n+\t the `accessibility' of that particular inheritance is.)  */\n+\n+      base_binfo\n+\t= make_binfo (size_zero_node, basetype,\n+\t\t      CLASS_TYPE_P (basetype)\n+\t\t      ? TYPE_BINFO_VTABLE (basetype) : NULL_TREE,\n+\t\t      CLASS_TYPE_P (basetype)\n+\t\t      ? TYPE_BINFO_VIRTUALS (basetype) : NULL_TREE);\n+\n+      TREE_VEC_ELT (binfos, i) = base_binfo;\n+      TREE_VIA_PUBLIC (base_binfo) = via_public;\n+      TREE_VIA_PROTECTED (base_binfo) = via_protected;\n+      TREE_VIA_VIRTUAL (base_binfo) = via_virtual;\n+      BINFO_INHERITANCE_CHAIN (base_binfo) = TYPE_BINFO (ref);\n+\n+      /* We need to unshare the binfos now so that lookups during class\n+\t definition work.  */\n+      unshare_base_binfos (base_binfo);\n+\n+      SET_CLASSTYPE_MARKED (basetype);\n+\n+      /* We are free to modify these bits because they are meaningless\n+\t at top level, and BASETYPE is a top-level type.  */\n+      if (via_virtual || TYPE_USES_VIRTUAL_BASECLASSES (basetype))\n+\t{\n+\t  TYPE_USES_VIRTUAL_BASECLASSES (ref) = 1;\n+\t  /* Converting to a virtual base class requires looking\n+\t     up the offset of the virtual base.  */\n+\t  TYPE_BASE_CONVS_MAY_REQUIRE_CODE_P (ref) = 1;\n+\t}\n+\n+      if (CLASS_TYPE_P (basetype))\n+\t{\n+\t  TYPE_HAS_NEW_OPERATOR (ref)\n+\t    |= TYPE_HAS_NEW_OPERATOR (basetype);\n+\t  TYPE_HAS_ARRAY_NEW_OPERATOR (ref)\n+\t    |= TYPE_HAS_ARRAY_NEW_OPERATOR (basetype);\n+\t  TYPE_GETS_DELETE (ref) |= TYPE_GETS_DELETE (basetype);\n+\t  /* If the base-class uses multiple inheritance, so do we.  */\n+\t  TYPE_USES_MULTIPLE_INHERITANCE (ref)\n+\t    |= TYPE_USES_MULTIPLE_INHERITANCE (basetype);\n+\t  /* Likewise, if converting to a base of the base may require\n+\t     code, then we may need to generate code to convert to a\n+\t     base as well.  */\n+\t  TYPE_BASE_CONVS_MAY_REQUIRE_CODE_P (ref)\n+\t    |= TYPE_BASE_CONVS_MAY_REQUIRE_CODE_P (basetype);\n+\t}\n+\n+      i += 1;\n     }\n   if (i)\n     TREE_VEC_LENGTH (binfos) = i;"}, {"sha": "4401dccb20f927a8701b5d43f32229eafa031358", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 12, "deletions": 39, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fbc5ae72379506e4344297591db49fceac3a799/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fbc5ae72379506e4344297591db49fceac3a799/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=8fbc5ae72379506e4344297591db49fceac3a799", "patch": "@@ -846,35 +846,6 @@ grokfield (tree declarator, tree declspecs, tree init, tree asmspec_tree,\n   const char *asmspec = 0;\n   int flags = LOOKUP_ONLYCONVERTING;\n \n-  /* Convert () initializers to = initializers.  */\n-  if (init == NULL_TREE && declarator != NULL_TREE\n-      && TREE_CODE (declarator) == CALL_EXPR\n-      && TREE_OPERAND (declarator, 0)\n-      && (TREE_CODE (TREE_OPERAND (declarator, 0)) == IDENTIFIER_NODE\n-\t  || TREE_CODE (TREE_OPERAND (declarator, 0)) == SCOPE_REF)\n-      && parmlist_is_exprlist (CALL_DECLARATOR_PARMS (declarator)))\n-    {\n-      /* It's invalid to try to initialize a data member using a\n-\t functional notation, e.g.:\n-\t \n-            struct S {\n-\t      static int i (3);\n-\t    };\n-\t    \n-\t Explain that to the user.  */\n-      static int explained;\n-\n-      error (\"invalid data member initialization\");\n-      if (!explained)\n-\t{\n-\t  error (\"(use `=' to initialize static data members)\");\n-\t  explained = 1;\n-\t}\n-\n-      declarator = TREE_OPERAND (declarator, 0);\n-      flags = 0;\n-    }\n-\n   if (declspecs == NULL_TREE\n       && TREE_CODE (declarator) == SCOPE_REF\n       && TREE_CODE (TREE_OPERAND (declarator, 1)) == IDENTIFIER_NODE)\n@@ -1280,8 +1251,11 @@ build_anon_union_vars (tree object)\n       else if (TREE_PROTECTED (field))\n \tcp_pedwarn_at (\"protected member `%#D' in anonymous union\", field);\n \n-      ref = build_class_member_access_expr (object, field, NULL_TREE,\n-\t\t\t\t\t    false);\n+      if (processing_template_decl)\n+\tref = build_min_nt (COMPONENT_REF, object, DECL_NAME (field));\n+      else\n+\tref = build_class_member_access_expr (object, field, NULL_TREE,\n+\t\t\t\t\t      false);\n \n       if (DECL_NAME (field))\n \t{\n@@ -1327,16 +1301,15 @@ finish_anon_union (tree anon_union_decl)\n       return;\n     }\n \n-  if (!processing_template_decl)\n+  main_decl = build_anon_union_vars (anon_union_decl);\n+  if (main_decl == NULL_TREE)\n     {\n-      main_decl = build_anon_union_vars (anon_union_decl);\n-\n-      if (main_decl == NULL_TREE)\n-\t{\n-\t  warning (\"anonymous union with no members\");\n-\t  return;\n-\t}\n+      warning (\"anonymous union with no members\");\n+      return;\n+    }\n \n+  if (!processing_template_decl)\n+    {\n       /* Use main_decl to set the mangled name.  */\n       DECL_NAME (anon_union_decl) = DECL_NAME (main_decl);\n       mangle_decl (anon_union_decl);"}, {"sha": "d9bc5528ab817b7ae9f7c6b0d8a65a5b5fa80d63", "filename": "gcc/cp/error.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fbc5ae72379506e4344297591db49fceac3a799/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fbc5ae72379506e4344297591db49fceac3a799/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=8fbc5ae72379506e4344297591db49fceac3a799", "patch": "@@ -454,8 +454,7 @@ dump_type (t, flags)\n       break;\n     }\n     case TYPENAME_TYPE:\n-      if (!IMPLICIT_TYPENAME_P (t))\n-        output_add_string (scratch_buffer, \"typename \");\n+      output_add_string (scratch_buffer, \"typename \");\n       dump_typename (t, flags);\n       break;\n "}, {"sha": "75d7a6456de5040a969f9c3f812fc46adb2cde0a", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 119, "deletions": 7, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fbc5ae72379506e4344297591db49fceac3a799/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fbc5ae72379506e4344297591db49fceac3a799/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=8fbc5ae72379506e4344297591db49fceac3a799", "patch": "@@ -1758,6 +1758,8 @@ static bool cp_parser_simulate_error\n   PARAMS ((cp_parser *));\n static void cp_parser_check_type_definition\n   PARAMS ((cp_parser *));\n+static bool cp_parser_diagnose_invalid_type_name\n+  (cp_parser *);\n static bool cp_parser_skip_to_closing_parenthesis\n   PARAMS ((cp_parser *));\n static bool cp_parser_skip_to_closing_parenthesis_or_comma\n@@ -2201,6 +2203,83 @@ cp_parser_check_type_definition (parser)\n     error (\"%s\", parser->type_definition_forbidden_message);\n }\n \n+/* Check for a common situation where a type-name should be present,\n+   but is not, and issue a sensible error message.  Returns true if an\n+   invalid type-name was detected.  */\n+\n+static bool\n+cp_parser_diagnose_invalid_type_name (cp_parser *parser)\n+{\n+  /* If the next two tokens are both identifiers, the code is\n+     erroneous. The usual cause of this situation is code like:\n+\n+       T t;\n+\n+     where \"T\" should name a type -- but does not.  */\n+  if (cp_lexer_next_token_is (parser->lexer, CPP_NAME)\n+      && cp_lexer_peek_nth_token (parser->lexer, 2)->type == CPP_NAME)\n+    {\n+      tree name;\n+\n+      /* If parsing tenatively, we should commit; we really are\n+\t looking at a declaration.  */\n+      /* Consume the first identifier.  */\n+      name = cp_lexer_consume_token (parser->lexer)->value;\n+      /* Issue an error message.  */\n+      error (\"`%s' does not name a type\", IDENTIFIER_POINTER (name));\n+      /* If we're in a template class, it's possible that the user was\n+\t referring to a type from a base class.  For example:\n+\n+\t   template <typename T> struct A { typedef T X; };\n+\t   template <typename T> struct B : public A<T> { X x; };\n+\n+\t The user should have said \"typename A<T>::X\".  */\n+      if (processing_template_decl && current_class_type)\n+\t{\n+\t  tree b;\n+\n+\t  for (b = TREE_CHAIN (TYPE_BINFO (current_class_type));\n+\t       b;\n+\t       b = TREE_CHAIN (b))\n+\t    {\n+\t      tree base_type = BINFO_TYPE (b);\n+\t      if (CLASS_TYPE_P (base_type) \n+\t\t  && cp_parser_dependent_type_p (base_type))\n+\t\t{\n+\t\t  tree field;\n+\t\t  /* Go from a particular instantiation of the\n+\t\t     template (which will have an empty TYPE_FIELDs),\n+\t\t     to the main version.  */\n+\t\t  if (CLASSTYPE_USE_TEMPLATE (base_type))\n+\t\t    base_type = (TREE_TYPE\n+\t\t\t\t (DECL_TEMPLATE_RESULT \n+\t\t\t\t  (DECL_PRIMARY_TEMPLATE\n+\t\t\t\t   (CLASSTYPE_TI_TEMPLATE (base_type)))));\n+\t\t  for (field = TYPE_FIELDS (base_type);\n+\t\t       field;\n+\t\t       field = TREE_CHAIN (field))\n+\t\t    if (TREE_CODE (field) == TYPE_DECL\n+\t\t\t&& DECL_NAME (field) == name)\n+\t\t      {\n+\t\t\terror (\"(perhaps `typename %T::%s' was intended)\",\n+\t\t\t       BINFO_TYPE (b), IDENTIFIER_POINTER (name));\n+\t\t\tbreak;\n+\t\t      }\n+\t\t  if (field)\n+\t\t    break;\n+\t\t}\n+\t    }\n+\t}\n+      /* Skip to the end of the declaration; there's no point in\n+\t trying to process it.  */\n+      cp_parser_skip_to_end_of_statement (parser);\n+      \n+      return true;\n+    }\n+\n+  return false;\n+}\n+\n /* Consume tokens up to, and including, the next non-nested closing `)'. \n    Returns TRUE iff we found a closing `)'.  */\n \n@@ -2744,15 +2823,21 @@ cp_parser_primary_expression (cp_parser *parser,\n \t\t  }\n \t      }\n \n-\t    /* If unqualified name lookup fails while processing a\n-\t       template, that just means that we need to do name\n-\t       lookup again when the template is instantiated.  */\n \t    if (!parser->scope \n \t\t&& decl == error_mark_node\n \t\t&& processing_template_decl)\n \t      {\n+\t\t/* Unqualified name lookup failed while processing a\n+\t\t   template.  */\n \t\t*idk = CP_PARSER_ID_KIND_UNQUALIFIED;\n-\t\treturn build_min_nt (LOOKUP_EXPR, id_expression);\n+\t\t/* If the next token is a parenthesis, assume that\n+\t\t   Koenig lookup will succeed when instantiating the\n+\t\t   template.  */\n+\t\tif (cp_lexer_next_token_is (parser->lexer, CPP_OPEN_PAREN))\n+\t\t  return build_min_nt (LOOKUP_EXPR, id_expression);\n+\t\t/* If we're not doing Koenig lookup, issue an error.  */\n+\t\terror (\"`%D' has not been declared\", id_expression);\n+\t\treturn error_mark_node;\n \t      }\n \t    else if (decl == error_mark_node\n \t\t     && !processing_template_decl)\n@@ -3521,7 +3606,12 @@ cp_parser_nested_name_specifier_opt (cp_parser *parser,\n \t\t       : new_scope);\n       /* If it is a class scope, try to complete it; we are about to\n \t be looking up names inside the class.  */\n-      if (TYPE_P (parser->scope))\n+      if (TYPE_P (parser->scope)\n+\t  /* Since checking types for dependency can be expensive,\n+\t     avoid doing it if the type is already complete.  */\n+\t  && !COMPLETE_TYPE_P (parser->scope)\n+\t  /* Do not try to complete dependent types.  */\n+\t  && !cp_parser_dependent_type_p (parser->scope))\n \tcomplete_type (parser->scope);\n     }\n \n@@ -6656,6 +6746,21 @@ cp_parser_simple_declaration (parser, function_definition_allowed_p)\n   /* We no longer need to defer access checks.  */\n   stop_deferring_access_checks ();\n \n+  /* If the next two tokens are both identifiers, the code is\n+     erroneous. The usual cause of this situation is code like:\n+\n+       T t;\n+\n+     where \"T\" should name a type -- but does not.  */\n+  if (cp_parser_diagnose_invalid_type_name (parser))\n+    {\n+      /* If parsing tenatively, we should commit; we really are\n+\t looking at a declaration.  */\n+      cp_parser_commit_to_tentative_parse (parser);\n+      /* Give up.  */\n+      return;\n+    }\n+\n   /* Keep going until we hit the `;' at the end of the simple\n      declaration.  */\n   saw_declarator = false;\n@@ -12061,6 +12166,9 @@ cp_parser_member_declaration (parser)\n \t\t\t\t    CP_PARSER_FLAGS_OPTIONAL,\n \t\t\t\t    &prefix_attributes,\n \t\t\t\t    &declares_class_or_enum);\n+  /* Check for an invalid type-name.  */\n+  if (cp_parser_diagnose_invalid_type_name (parser))\n+    return;\n   /* If there is no declarator, then the decl-specifier-seq should\n      specify a type.  */\n   if (cp_lexer_next_token_is (parser->lexer, CPP_SEMICOLON))\n@@ -13818,7 +13926,11 @@ cp_parser_constructor_declarator_p (cp_parser *parser, bool friend_p)\n   cp_token *next_token;\n \n   /* The common case is that this is not a constructor declarator, so\n-     try to avoid doing lots of work if at all possible.  */\n+     try to avoid doing lots of work if at all possible.  It's not\n+     valid declare a constructor at function scope.  */\n+  if (at_function_scope_p ())\n+    return false;\n+  /* And only certain tokens can begin a constructor declarator.  */\n   next_token = cp_lexer_peek_token (parser->lexer);\n   if (next_token->type != CPP_NAME\n       && next_token->type != CPP_SCOPE\n@@ -13853,7 +13965,7 @@ cp_parser_constructor_declarator_p (cp_parser *parser, bool friend_p)\n     {\n       /* If we have:\n \n-\t   template <typename T> struct S { S(); }\n+\t   template <typename T> struct S { S(); };\n \t   template <typename T> S<T>::S ();\n \n \t we must recognize that the nested `S' names a class."}, {"sha": "91cf89cb5f6c956b0e19a835bb9a7db17fdb4f13", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 12, "deletions": 69, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fbc5ae72379506e4344297591db49fceac3a799/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fbc5ae72379506e4344297591db49fceac3a799/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=8fbc5ae72379506e4344297591db49fceac3a799", "patch": "@@ -5152,63 +5152,26 @@ instantiate_class_template (type)\n   /* Figure out which arguments are being used to do the\n      instantiation.  */\n   args = CLASSTYPE_TI_ARGS (type);\n-  PARTIAL_INSTANTIATION_P (type) = uses_template_parms (args);\n-\n-  if (pedantic && PARTIAL_INSTANTIATION_P (type))\n-    /* If this is a partial instantiation, then we can't instantiate\n-       the type; there's no telling whether or not one of the\n-       template parameters might eventually be instantiated to some\n-       value that results in a specialization being used.  For\n-       example, consider:\n-\n-         template <class T>\n-         struct S {};\n-\n-         template <class U> \n-         void f(S<U>);\n-\t     \n-         template <> \n-         struct S<int> {};\n-\n-       Now, the `S<U>' in `f<int>' is the specialization, not an\n-       instantiation of the original template.  */\n-    return type;\n \n   /* Determine what specialization of the original template to\n      instantiate.  */\n-  if (PARTIAL_INSTANTIATION_P (type))\n-    /* There's no telling which specialization is appropriate at this\n-       point.  Since all peeking at the innards of this partial\n-       instantiation are extensions (like the \"implicit typename\"\n-       extension, which allows users to omit the keyword `typename' on\n-       names that are declared as types in template base classes), we\n-       are free to do what we please.\n-\n-       Trying to figure out which partial instantiation to use can\n-       cause a crash.  (Some of the template arguments don't even have\n-       types.)  So, we just use the most general version.  */\n-    t = NULL_TREE;\n-  else\n+  t = most_specialized_class (template, args);\n+  if (t == error_mark_node)\n     {\n-      t = most_specialized_class (template, args);\n-\n-      if (t == error_mark_node)\n+      const char *str = \"candidates are:\";\n+      error (\"ambiguous class template instantiation for `%#T'\", type);\n+      for (t = DECL_TEMPLATE_SPECIALIZATIONS (template); t; \n+\t   t = TREE_CHAIN (t))\n \t{\n-\t  const char *str = \"candidates are:\";\n-\t  error (\"ambiguous class template instantiation for `%#T'\", type);\n-\t  for (t = DECL_TEMPLATE_SPECIALIZATIONS (template); t; \n-\t       t = TREE_CHAIN (t))\n+\t  if (get_class_bindings (TREE_VALUE (t), TREE_PURPOSE (t),\n+\t\t\t\t  args))\n \t    {\n-\t      if (get_class_bindings (TREE_VALUE (t), TREE_PURPOSE (t),\n-\t\t\t\t      args))\n-\t\t{\n-\t\t  cp_error_at (\"%s %+#T\", str, TREE_TYPE (t));\n-\t\t  str = \"               \";\n-\t\t}\n+\t      cp_error_at (\"%s %+#T\", str, TREE_TYPE (t));\n+\t      str = \"               \";\n \t    }\n-\t  TYPE_BEING_DEFINED (type) = 1;\n-\t  return error_mark_node;\n \t}\n+      TYPE_BEING_DEFINED (type) = 1;\n+      return error_mark_node;\n     }\n \n   if (t)\n@@ -5221,26 +5184,6 @@ instantiate_class_template (type)\n   if (!COMPLETE_TYPE_P (pattern))\n     return type;\n \n-  /* If this is a partial instantiation, don't tsubst anything.  We will\n-     only use this type for implicit typename, so the actual contents don't\n-     matter.  All that matters is whether a particular name is a type.  */\n-  if (PARTIAL_INSTANTIATION_P (type))\n-    {\n-      /* The fields set here must be kept in sync with those cleared\n-\t in begin_class_definition.  */\n-      TYPE_BINFO_BASETYPES (type) = TYPE_BINFO_BASETYPES (pattern);\n-      TYPE_FIELDS (type) = TYPE_FIELDS (pattern);\n-      TYPE_METHODS (type) = TYPE_METHODS (pattern);\n-      CLASSTYPE_DECL_LIST (type) = CLASSTYPE_DECL_LIST (pattern);\n-      CLASSTYPE_TAGS (type) = CLASSTYPE_TAGS (pattern);\n-      CLASSTYPE_VBASECLASSES (type) = CLASSTYPE_VBASECLASSES (pattern);\n-      \n-      /* Pretend that the type is complete, so that we will look\n-\t inside it during name lookup and such.  */\n-      TYPE_SIZE (type) = bitsize_zero_node;\n-      return type;\n-    }\n-\n   /* If we've recursively instantiated too many templates, stop.  */\n   if (! push_tinst_level (type))\n     return type;"}, {"sha": "29ee667d1fbdcd89cec04f184b91a5b859d6be68", "filename": "gcc/cp/search.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fbc5ae72379506e4344297591db49fceac3a799/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fbc5ae72379506e4344297591db49fceac3a799/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=8fbc5ae72379506e4344297591db49fceac3a799", "patch": "@@ -1350,7 +1350,7 @@ lookup_field_r (binfo, data)\n     }\n   else\n     {\n-      if (from_dep_base_p && TREE_CODE (nval) != TYPE_DECL\n+      if (from_dep_base_p && TREE_CODE (nval) == TYPE_DECL\n \t  /* We need to return a member template class so we can\n \t     define partial specializations.  Is there a better\n \t     way?  */\n@@ -1500,9 +1500,7 @@ lookup_member (xbasetype, name, protect, want_type)\n   /* If the thing we found was found via the implicit typename\n      extension, build the typename type.  */\n   if (rval && lfi.from_dep_base_p && !DECL_CLASS_TEMPLATE_P (rval))\n-    rval = TYPE_STUB_DECL (build_typename_type (BINFO_TYPE (basetype_path),\n-\t\t\t\t\t\tname, name,\n-\t\t\t\t\t\tTREE_TYPE (rval)));\n+    abort ();\n \n   if (rval && is_overloaded_fn (rval)) \n     rval = build_baselink (rval_binfo, basetype_path, rval,\n@@ -2187,6 +2185,7 @@ marked_pushdecls_p (binfo, data)\n      void *data ATTRIBUTE_UNUSED;\n {\n   return (CLASS_TYPE_P (BINFO_TYPE (binfo))\n+\t  && !dependent_base_p (binfo)\n \t  && BINFO_PUSHDECLS_MARKED (binfo)) ? binfo : NULL_TREE; \n }\n \n@@ -2196,6 +2195,7 @@ unmarked_pushdecls_p (binfo, data)\n      void *data ATTRIBUTE_UNUSED;\n { \n   return (CLASS_TYPE_P (BINFO_TYPE (binfo))\n+\t  && !dependent_base_p (binfo)\n \t  && !BINFO_PUSHDECLS_MARKED (binfo)) ? binfo : NULL_TREE;\n }\n "}, {"sha": "adba8a5172a96f648d43e5ddfcf84615ee284d01", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 1, "deletions": 53, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fbc5ae72379506e4344297591db49fceac3a799/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fbc5ae72379506e4344297591db49fceac3a799/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=8fbc5ae72379506e4344297591db49fceac3a799", "patch": "@@ -1797,11 +1797,6 @@ begin_class_definition (t)\n       error (\"definition of `%#T' inside template parameter list\", t);\n       return error_mark_node;\n     }\n-\n-  /* In a definition of a member class template, we will get here with\n-     an implicit typename.  */\n-  if (IMPLICIT_TYPENAME_P (t))\n-    t = TREE_TYPE (t);\n   /* A non-implicit typename comes from code like:\n \n        template <typename T> struct A {\n@@ -1820,56 +1815,9 @@ begin_class_definition (t)\n       pushtag (make_anon_name (), t, 0);\n     }\n \n-  /* If we generated a partial instantiation of this type, but now\n-     we're seeing a real definition, we're actually looking at a\n-     partial specialization.  Consider:\n-\n-       template <class T, class U>\n-       struct Y {};\n-\n-       template <class T>\n-       struct X {};\n-\n-       template <class T, class U>\n-       void f()\n-       {\n-\t typename X<Y<T, U> >::A a;\n-       }\n-\n-       template <class T, class U>\n-       struct X<Y<T, U> >\n-       {\n-       };\n-\n-     We have to undo the effects of the previous partial\n-     instantiation.  */\n-  if (PARTIAL_INSTANTIATION_P (t))\n-    {\n-      if (!pedantic) \n-\t{\n-\t  /* Unfortunately, when we're not in pedantic mode, we\n-\t     attempt to actually fill in some of the fields of the\n-\t     partial instantiation, in order to support the implicit\n-\t     typename extension.  Clear those fields now, in\n-\t     preparation for the definition here.  The fields cleared\n-\t     here must match those set in instantiate_class_template.\n-\t     Look for a comment mentioning begin_class_definition\n-\t     there.  */\n-\t  TYPE_BINFO_BASETYPES (t) = NULL_TREE;\n-\t  TYPE_FIELDS (t) = NULL_TREE;\n-\t  TYPE_METHODS (t) = NULL_TREE;\n-\t  CLASSTYPE_DECL_LIST (t) = NULL_TREE;\n-\t  CLASSTYPE_TAGS (t) = NULL_TREE;\n-\t  CLASSTYPE_VBASECLASSES (t) = NULL_TREE;\n-\t  TYPE_SIZE (t) = NULL_TREE;\n-\t}\n-\n-      /* This isn't a partial instantiation any more.  */\n-      PARTIAL_INSTANTIATION_P (t) = 0;\n-    }\n   /* If this type was already complete, and we see another definition,\n      that's an error.  */\n-  else if (COMPLETE_TYPE_P (t))\n+  if (COMPLETE_TYPE_P (t))\n     duplicate_tag_error (t);\n \n   /* Update the location of the decl.  */"}, {"sha": "55e4028613fdceb910e57348b53a267acd21b942", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fbc5ae72379506e4344297591db49fceac3a799/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fbc5ae72379506e4344297591db49fceac3a799/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8fbc5ae72379506e4344297591db49fceac3a799", "patch": "@@ -1,3 +1,33 @@\n+2003-01-16  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* gcc/testsuite/g++.dg/ext/typename1.C: Add typename keyword.\n+\t* gcc/testsuite/g++.dg/template/crash1.C: Update error messages.\n+\t* gcc/testsuite/g++.dg/template/crash2.C: Remove error message.\n+\t* gcc/testsuite/g++.dg/parse/typename2.C: New test.\n+\t* gcc/testsuite/g++.dg/template/typename2.C: Change implicit\n+\ttypename warning into error.\n+\t* gcc/testsuite/g++.old-deja/g++.benjamin/tem03.C: Issue more\n+\terror messages.\n+\t* gcc/testsuite/g++.old-deja/g++.benjamin/tem04.C: Fix typos.\n+\t* gcc/testsuite/g++.old-deja/g++.brendan/crash56.C: Add this->.\n+\t* gcc/testsuite/g++.old-deja/g++.law/visibility13.C: Remove error\n+\tmessages.\n+\t* gcc/testsuite/g++.old-deja/g++.ns/template17.C: Reorder code to\n+\tmake declaration visible in template.\n+\t* gcc/testsuite/g++.old-deja/g++.pt/crash3.C: Fix typos.\n+\t* gcc/testsuite/g++.old-deja/g++.pt/crash36.C: Issue more error\n+\tmessages.\n+\t* gcc/testsuite/g++.old-deja/g++.pt/crash5.C: Improve error\n+\tmessage.\n+\t* gcc/testsuite/g++.old-deja/g++.pt/crash67.C: Remove warning.\n+\t* gcc/testsuite/g++.old-deja/g++.pt/inherit1.C: Add this->.\n+\t* gcc/testsuite/g++.old-deja/g++.pt/niklas01a.C: Add error message.\n+\t* gcc/testsuite/g++.old-deja/g++.pt/typename16.C: Replace implicit\n+\ttypename warning with error message.\n+\t* gcc/testsuite/g++.old-deja/g++.pt/typename19.C: Remove warning.\n+\t* gcc/testsuite/g++.old-deja/g++.robertl/eb112.C: Fix typo.\n+\t* gcc/testsuite/g++.old-deja/g++.robertl/eb24.C: Use this->.\n+\t\n 2003-01-16  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* g++.dg/parse/ambig2.C: New test."}, {"sha": "cb9f4a7fc6c5b20b6b4470a0a83fc2ebe4924c2b", "filename": "gcc/testsuite/g++.dg/ext/typename1.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fbc5ae72379506e4344297591db49fceac3a799/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Ftypename1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fbc5ae72379506e4344297591db49fceac3a799/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Ftypename1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Ftypename1.C?ref=8fbc5ae72379506e4344297591db49fceac3a799", "patch": "@@ -3,5 +3,5 @@\n \n template <class T> struct A { typedef int X; };\n template <class T> struct B { typedef A<T> Y; void f (typename Y::X); };\n-template <class T, class T1, class T2, class T3> struct C : public B<T> { void g (typename Y::X); };\n+template <class T, class T1, class T2, class T3> struct C : public B<T> { void g (typename B<T>::Y::X); };\n template class B<int>;"}, {"sha": "8878497ad2f16a4982e6e58180c68b268cf76660", "filename": "gcc/testsuite/g++.dg/parse/typename2.C", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fbc5ae72379506e4344297591db49fceac3a799/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ftypename2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fbc5ae72379506e4344297591db49fceac3a799/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ftypename2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ftypename2.C?ref=8fbc5ae72379506e4344297591db49fceac3a799", "patch": "@@ -0,0 +1,17 @@\n+template<class T, class U>\n+struct UnaryReturn {\n+        typedef T Type_t;\n+};\n+\n+struct foo\n+{\n+        template <class T>\n+        typename UnaryReturn<T, int>::Type_t\n+        bar();\n+};\n+\n+template<class T>\n+struct UnaryReturn<T, int> {\n+        typedef bool Type_t;\n+};\n+"}, {"sha": "16d584e0fbb650ca72bfd501b3a10f532416969c", "filename": "gcc/testsuite/g++.dg/template/crash1.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fbc5ae72379506e4344297591db49fceac3a799/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fcrash1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fbc5ae72379506e4344297591db49fceac3a799/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fcrash1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fcrash1.C?ref=8fbc5ae72379506e4344297591db49fceac3a799", "patch": "@@ -1,6 +1,6 @@\n // { dg-do compile }\n \n-// Copyright (C) 2001, 2002 Free Software Foundation, Inc.\n+// Copyright (C) 2001, 2002, 2003 Free Software Foundation, Inc.\n // Contributed by Nathan Sidwell 29 Dec 2001 <nathan@codesourcery.com>\n \n // PR 5125. ICE\n@@ -12,6 +12,6 @@ class S\n };\n \n template <class I>\n-void S::Foo(int (*f)(TYPO&o) ) // { dg-error \"Foo\" }\n+void S::Foo(int (*f)(TYPO&o) ) // { dg-error \"Foo|f|TYPO|o\" }\n { // { dg-error \"expected `;'\" }\n }"}, {"sha": "a02787a46fa0b8db20a7187677bb27b2c0fbf263", "filename": "gcc/testsuite/g++.dg/template/crash2.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fbc5ae72379506e4344297591db49fceac3a799/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fcrash2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fbc5ae72379506e4344297591db49fceac3a799/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fcrash2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fcrash2.C?ref=8fbc5ae72379506e4344297591db49fceac3a799", "patch": "@@ -17,7 +17,7 @@ enum E { max = 5 };\n  \n struct B\n {\n-  A<E> a; // { dg-error \"\" }\n+  A<E> a;\n };\n  \n }"}, {"sha": "644c62a7f4ce07431705b1537edb931fbe423e64", "filename": "gcc/testsuite/g++.dg/template/typename2.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fbc5ae72379506e4344297591db49fceac3a799/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ftypename2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fbc5ae72379506e4344297591db49fceac3a799/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ftypename2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ftypename2.C?ref=8fbc5ae72379506e4344297591db49fceac3a799", "patch": "@@ -1,7 +1,7 @@\n // { dg-do compile }\n // { dg-options \"\" }\n \n-// Copyright (C) 2001 Free Software Foundation, Inc.\n+// Copyright (C) 2001, 2003 Free Software Foundation, Inc.\n // Contributed by Nathan Sidwell 21 Mar 2002 <nathan@codesourcery.com>\n \n // PR 5507. Overzealous implicit typename warning\n@@ -21,5 +21,5 @@ class ctype : public __ctype_abstract_base<_CharT>\n template<typename _CharT>\n class ctype2 : public __ctype_abstract_base<_CharT>\n {\n-  typedef mask mask; // { dg-warning \"(implicitly a typename)|(implicit typename)\" \"\" }\n+  typedef mask mask; // { dg-error \"\" }\n };"}, {"sha": "80490e92551ec4617df6bd3564e4a90423ef9e53", "filename": "gcc/testsuite/g++.old-deja/g++.benjamin/tem03.C", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fbc5ae72379506e4344297591db49fceac3a799/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.benjamin%2Ftem03.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fbc5ae72379506e4344297591db49fceac3a799/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.benjamin%2Ftem03.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.benjamin%2Ftem03.C?ref=8fbc5ae72379506e4344297591db49fceac3a799", "patch": "@@ -127,7 +127,7 @@ public:\n   friend bool foo(T161 u)\n     {\n       Xseven<T161, 5, int> obj; // ERROR - .*\n-      return (obj.inst == u.inst);\n+      return (obj.inst == u.inst); // ERROR - .*\n     }\n \n };\n@@ -192,10 +192,10 @@ template <long l>// ERROR - .*\n struct Xthirteen {\n   template <long l> long comp_ge(long test) {// ERROR - .\n     long local_value;\n-    if (local_value > value) \n+    if (local_value > value) // ERROR - .*\n       return local_value;\n     else\n-      return value;\n+      return value; // ERROR - .*\n   }\n };\n "}, {"sha": "3c01be739bc259a67cdd02d0dde34eaf48f560f6", "filename": "gcc/testsuite/g++.old-deja/g++.benjamin/tem04.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fbc5ae72379506e4344297591db49fceac3a799/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.benjamin%2Ftem04.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fbc5ae72379506e4344297591db49fceac3a799/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.benjamin%2Ftem04.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.benjamin%2Ftem04.C?ref=8fbc5ae72379506e4344297591db49fceac3a799", "patch": "@@ -115,7 +115,7 @@ protected:\n template <class T17, int i> struct Xtwenty {\n   void f(){\n     T17 my_type; //ok\n-    for (int j = 0; j < 5; ++l)\n+    for (int j = 0; j < 5; ++j)\n       {\n \tT17 my_type; //ok\n \t++my_type;"}, {"sha": "0523f1fe31bed5aee8e1fde58dcaf5dfb4bb28c7", "filename": "gcc/testsuite/g++.old-deja/g++.benjamin/tem05.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fbc5ae72379506e4344297591db49fceac3a799/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.benjamin%2Ftem05.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fbc5ae72379506e4344297591db49fceac3a799/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.benjamin%2Ftem05.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.benjamin%2Ftem05.C?ref=8fbc5ae72379506e4344297591db49fceac3a799", "patch": "@@ -51,7 +51,7 @@ unsigned short X_one<T>::ret_id() {\n \n export template <class T2> // WARNING - \n bool compare_ge(T2 test) {\n-  if (test > type)\n+  if (test > type) // ERROR - .*\n     return true;\n   return false;\n }"}, {"sha": "78c291bf4c5d1ce85090663d151e073220ef4c5d", "filename": "gcc/testsuite/g++.old-deja/g++.brendan/crash56.C", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fbc5ae72379506e4344297591db49fceac3a799/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.brendan%2Fcrash56.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fbc5ae72379506e4344297591db49fceac3a799/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.brendan%2Fcrash56.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.brendan%2Fcrash56.C?ref=8fbc5ae72379506e4344297591db49fceac3a799", "patch": "@@ -273,10 +273,10 @@ template<class T>\n void\n SetLD<T>::remove(const T& item)\n {\n-    typename ListD<T>::Action a = NORMAL;\n+    typename ListD<T>::Action a = this->NORMAL;\n     Vix x;\n-    for (first(x); 0 != x && REMOVE_CURRENT != a; next(x, a))\n-\ta = operator()(x) == item ? REMOVE_CURRENT: NORMAL;// ERROR - .*\n+    for (first(x); 0 != x && this->REMOVE_CURRENT != a; next(x, a))\n+\ta = operator()(x) == item ? this->REMOVE_CURRENT: this->NORMAL; // ERROR - .*\n }\n template<class T>\n bool"}, {"sha": "2a74151242395d7ba27826d580c4a919917491b0", "filename": "gcc/testsuite/g++.old-deja/g++.law/visibility13.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fbc5ae72379506e4344297591db49fceac3a799/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.law%2Fvisibility13.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fbc5ae72379506e4344297591db49fceac3a799/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.law%2Fvisibility13.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.law%2Fvisibility13.C?ref=8fbc5ae72379506e4344297591db49fceac3a799", "patch": "@@ -25,8 +25,8 @@ public:\n     virtual Type& operator[](int ix) { return ia[ix]; }\n private:\n     void init(const Type*, int);\n-    int size; // ERROR - private\n-    int *ia; // ERROR - private\n+    int size;\n+    int *ia;\n };\n \n template <class Type>"}, {"sha": "a441ebe5b2a2523544a4357c633e974b5d929466", "filename": "gcc/testsuite/g++.old-deja/g++.ns/template17.C", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fbc5ae72379506e4344297591db49fceac3a799/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.ns%2Ftemplate17.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fbc5ae72379506e4344297591db49fceac3a799/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.ns%2Ftemplate17.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.ns%2Ftemplate17.C?ref=8fbc5ae72379506e4344297591db49fceac3a799", "patch": "@@ -1,6 +1,6 @@\n // Build don't link:\n // \n-// Copyright (C) 2001 Free Software Foundation, Inc.\n+// Copyright (C) 2001, 2003 Free Software Foundation, Inc.\n // Contributed by Nathan Sidwell 29 Apr 2001 <nathan@codesourcery.com>\n \n // Bug 2258. We failed to implement using directives inside template\n@@ -16,6 +16,11 @@ namespace whatever\n \n template <typename T> void fn (T, T (*)(T));\n \n+namespace whatever\n+{\n+  template <typename T> T end3 (T);\n+}\n+\n template <class T> void mycout(const T& data)\n {\n   using namespace thing;\n@@ -25,11 +30,6 @@ template <class T> void mycout(const T& data)\n   fn (data, end3);\n }\n \n-namespace whatever\n-{\n-  template <typename T> T end3 (T);\n-}\n-\n int main()\n {\n   double data = 5.0;"}, {"sha": "a6133e17344babb41241a336b3448c9caf6130dc", "filename": "gcc/testsuite/g++.old-deja/g++.pt/crash3.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fbc5ae72379506e4344297591db49fceac3a799/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fcrash3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fbc5ae72379506e4344297591db49fceac3a799/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fcrash3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fcrash3.C?ref=8fbc5ae72379506e4344297591db49fceac3a799", "patch": "@@ -5,12 +5,12 @@ class CVector {\n public:\n     CVector<int> f() const\n     {\n-       CVector<int> v(n);\n+       CVector<int> v();\n        return v;\n     }\n     CVector<long> g() const\n     {\n-       CVector<long> v(n);\n+       CVector<long> v();\n        return v;\n     }\n };"}, {"sha": "938591fd13e5e59eec36437cb1b649d73b685944", "filename": "gcc/testsuite/g++.old-deja/g++.pt/crash36.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fbc5ae72379506e4344297591db49fceac3a799/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fcrash36.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fbc5ae72379506e4344297591db49fceac3a799/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fcrash36.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fcrash36.C?ref=8fbc5ae72379506e4344297591db49fceac3a799", "patch": "@@ -29,7 +29,7 @@ struct list {\n   \n   reverse_iterator<list_iterator<T> > rbegin()\n     { return reverse_iterator<list_iterator<T> > // ERROR - no type|instantiated here\n-\t(list_iterator<T>(Head->next())); }\n+\t(list_iterator<T>(Head->next())); } // ERROR - not declared\n };\n \n template class list<int>;"}, {"sha": "c36f5d786c34a1b3aca411751941b62bb2403a93", "filename": "gcc/testsuite/g++.old-deja/g++.pt/crash5.C", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fbc5ae72379506e4344297591db49fceac3a799/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fcrash5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fbc5ae72379506e4344297591db49fceac3a799/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fcrash5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fcrash5.C?ref=8fbc5ae72379506e4344297591db49fceac3a799", "patch": "@@ -1,12 +1,12 @@\n // Build don't link:\n \n template <class T, int i>\n-struct K {  // ERROR - forward declaration\n+struct K {\n \tvoid f();\n };\n \n template <class T>\n void\n-K<T, i>::f()\n-{ // ERROR - template parameters\n+K<T, i>::f() // ERROR - i has not been declared\n+{ \n }"}, {"sha": "646763a4be75b900bea2a6c23d03e5f0efa6153d", "filename": "gcc/testsuite/g++.old-deja/g++.pt/crash67.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fbc5ae72379506e4344297591db49fceac3a799/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fcrash67.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fbc5ae72379506e4344297591db49fceac3a799/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fcrash67.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fcrash67.C?ref=8fbc5ae72379506e4344297591db49fceac3a799", "patch": "@@ -1,7 +1,7 @@\n // Build don't link:\n // Special g++ Options: \n // \n-// Copyright (C) 2001 Free Software Foundation, Inc.\n+// Copyright (C) 2001, 2003 Free Software Foundation, Inc.\n // Contributed by Nathan Sidwell 6 May 2001 <nathan@codesourcery.com>\n \n // Bug 2526. We ICE'd after diagnosing dependent name confusion in\n@@ -16,5 +16,5 @@ struct B\n template<typename T>\n struct D : B<T>\n {\n-  friend class Mother; // WARNING - defines namespace class\n+  friend class Mother;\n };"}, {"sha": "3fb5656543532acfd9cf94ac9641490b32650afc", "filename": "gcc/testsuite/g++.old-deja/g++.pt/inherit1.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fbc5ae72379506e4344297591db49fceac3a799/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Finherit1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fbc5ae72379506e4344297591db49fceac3a799/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Finherit1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Finherit1.C?ref=8fbc5ae72379506e4344297591db49fceac3a799", "patch": "@@ -14,7 +14,7 @@ template <int dim>\n class FinalClass :  public Derived<dim> {\n public:\n   FinalClass () {\n-    if (&local1 != &local2)\n+    if (&this->local1 != &this->local2)\n       i = 0;\n   }\n };"}, {"sha": "131964b43757178cce7368ab9a30a7cabda779b3", "filename": "gcc/testsuite/g++.old-deja/g++.pt/niklas01a.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fbc5ae72379506e4344297591db49fceac3a799/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fniklas01a.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fbc5ae72379506e4344297591db49fceac3a799/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fniklas01a.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fniklas01a.C?ref=8fbc5ae72379506e4344297591db49fceac3a799", "patch": "@@ -1,6 +1,6 @@\n // Build don't link: \n \n-struct A {\n+struct A { // ERROR - forward declaration\n   friend struct B : A {\t\t// ERROR - \n     int x;\n   };"}, {"sha": "f40a6a2822931467e132eeb78db75afdc4e2a5b9", "filename": "gcc/testsuite/g++.old-deja/g++.pt/typename16.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fbc5ae72379506e4344297591db49fceac3a799/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ftypename16.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fbc5ae72379506e4344297591db49fceac3a799/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ftypename16.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ftypename16.C?ref=8fbc5ae72379506e4344297591db49fceac3a799", "patch": "@@ -11,7 +11,7 @@ struct D1 : public B {\n \n template <class T>\n struct D2 : public D1<T> {\n-  I i;  // WARNING - implicit typename\n+  I i;  // ERROR - not a type\n };\n \n template <>\n@@ -27,5 +27,5 @@ void f(double) {}\n int main()\n {\n   D2<int> d2i;\n-  f(d2i.i);\n+  f(d2i.i); // ERROR - no member i\n }"}, {"sha": "332f294d7cf362ec4564247bb8dd8aba10f0473e", "filename": "gcc/testsuite/g++.old-deja/g++.pt/typename19.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fbc5ae72379506e4344297591db49fceac3a799/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ftypename19.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fbc5ae72379506e4344297591db49fceac3a799/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ftypename19.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ftypename19.C?ref=8fbc5ae72379506e4344297591db49fceac3a799", "patch": "@@ -12,7 +12,7 @@ struct S {\n \n   template <class U>\n   struct I : public O<U> {\n-    static X x; // WARNING - lookup finds S<T>::X\n+    static X x;\n   };\n };\n "}, {"sha": "c0231b7095564d8f1f68c358dfad5a1f84ac4c60", "filename": "gcc/testsuite/g++.old-deja/g++.robertl/eb112.C", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fbc5ae72379506e4344297591db49fceac3a799/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.robertl%2Feb112.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fbc5ae72379506e4344297591db49fceac3a799/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.robertl%2Feb112.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.robertl%2Feb112.C?ref=8fbc5ae72379506e4344297591db49fceac3a799", "patch": "@@ -4,8 +4,7 @@ setback(MEMBER *bp, MEMBER STRUCT::*offset)\n {\n         // The implementation of this function may be platform dependend\n         if(!bp) return 0; // NULL pointers remain NULL\n-        union { int i; MEMBER STRUCT::*of; } u; // Switch types. Casting won't\n-+work.\n+        union { int i; MEMBER STRUCT::*of; } u; // Switch types. Casting won't work.\n         u.of = offset;\n         return (STRUCT *) ((int) bp - u.i);\n }"}, {"sha": "528af4c4dee9d4502e2d0d4cd9337889b7c17060", "filename": "gcc/testsuite/g++.old-deja/g++.robertl/eb24.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fbc5ae72379506e4344297591db49fceac3a799/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.robertl%2Feb24.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fbc5ae72379506e4344297591db49fceac3a799/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.robertl%2Feb24.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.robertl%2Feb24.C?ref=8fbc5ae72379506e4344297591db49fceac3a799", "patch": "@@ -19,5 +19,5 @@ class Y : public X<T>\n \n     using X<T>::x;\n \n-    void        f () { std::cout << x << std::endl; }\n+    void        f () { std::cout << this->x << std::endl; }\n };"}, {"sha": "901776ef8341fb2bf4db1cbf17db2bce87695d02", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fbc5ae72379506e4344297591db49fceac3a799/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fbc5ae72379506e4344297591db49fceac3a799/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=8fbc5ae72379506e4344297591db49fceac3a799", "patch": "@@ -1,3 +1,29 @@\n+2003-01-16  Mark Mitchell  <mark@codesourcery.com>\n+\t    Jeffrey Oldham <oldham@codesourcery.com>\n+\t\n+\t* config/locale/gnu/messages_members.h: Use this-> to refer to\n+\tunqualified members of base clasess.\n+\t* config/locale/ieee_1003.1-2001/codecvt_specializations.h: Likewise.\n+\t* include/bits/codecvt.h: Likewise.\n+\t* include/bits/deque.tcc: Likewise.\n+\t* include/bits/fstream.tcc: Likewise.\n+\t* include/bits/istream.tcc: Likewise.\n+\t* include/bits/list.tcc: Likewise.\n+\t* include/bits/locale_facets.h: Likewise.\n+\t* include/bits/ostream.tcc: Likewise.\n+\t* include/bits/sstream.tcc: Likewise.\n+\t* include/bits/stl_bvector.h: Likewise.\n+\t* include/bits/stl_deque.h: Likewise.\n+\t* include/bits/stl_list.h: Likewise.\n+\t* include/bits/stl_tree.h: Likewise.\n+\t* include/bits/stl_vector.h: Likewise.\n+\t* include/bits/vector.tcc: Likewise.\n+\t* include/ext/ropeimpl.h: Likewise.\n+\t* include/ext/stdio_filebuf.h: Likewise.\n+\t* include/ext/stl_rope.h: Likewise.\n+\t* include/std/std_fstream.h: Likewise.\n+\t* include/std/std_sstream.h: Likewise.\n+\t\n 2003-01-15  Phil Edwards  <pme@gcc.gnu.org>\n \n \t* include/bits/basic_string.tcc (_S_string_copy): Unused, remove."}, {"sha": "8cab730acfab589e83c9d1125c9380abe3064ab9", "filename": "libstdc++-v3/config/locale/gnu/messages_members.h", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fbc5ae72379506e4344297591db49fceac3a799/libstdc%2B%2B-v3%2Fconfig%2Flocale%2Fgnu%2Fmessages_members.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fbc5ae72379506e4344297591db49fceac3a799/libstdc%2B%2B-v3%2Fconfig%2Flocale%2Fgnu%2Fmessages_members.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Flocale%2Fgnu%2Fmessages_members.h?ref=8fbc5ae72379506e4344297591db49fceac3a799", "patch": "@@ -99,11 +99,11 @@\n      : messages<_CharT>(__refs) \n      { \n #if !(__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ > 2))\n-       if (_S_c_name != _M_name_messages)\n-\t delete [] _M_name_messages;\n-       _M_name_messages = new char[strlen(__s) + 1];\n-       strcpy(_M_name_messages, __s);\n+       if (this->_S_c_name != this->_M_name_messages)\n+\t delete [] this->_M_name_messages;\n+       this->_M_name_messages = new char[strlen(__s) + 1];\n+       strcpy(this->_M_name_messages, __s);\n #endif\n-       _S_destroy_c_locale(_M_c_locale_messages);\n-       _S_create_c_locale(_M_c_locale_messages, __s); \n+       _S_destroy_c_locale(this->_M_c_locale_messages);\n+       _S_create_c_locale(this->_M_c_locale_messages, __s); \n      }"}, {"sha": "1921905dfe5aaefd8ba9f97857b596682212c203", "filename": "libstdc++-v3/config/locale/ieee_1003.1-2001/codecvt_specializations.h", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fbc5ae72379506e4344297591db49fceac3a799/libstdc%2B%2B-v3%2Fconfig%2Flocale%2Fieee_1003.1-2001%2Fcodecvt_specializations.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fbc5ae72379506e4344297591db49fceac3a799/libstdc%2B%2B-v3%2Fconfig%2Flocale%2Fieee_1003.1-2001%2Fcodecvt_specializations.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Flocale%2Fieee_1003.1-2001%2Fcodecvt_specializations.h?ref=8fbc5ae72379506e4344297591db49fceac3a799", "patch": "@@ -1,6 +1,6 @@\n // Locale support (codecvt) -*- C++ -*-\n \n-// Copyright (C) 2000, 2001, 2002 Free Software Foundation, Inc.\n+// Copyright (C) 2000, 2001, 2002, 2003 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -260,7 +260,7 @@\n \t   extern_type* __to, extern_type* __to_end,\n \t   extern_type*& __to_next) const\n     {\n-      result __ret = error;\n+      result __ret = codecvt_base::error;\n       if (__state._M_good())\n \t{\n \t  typedef state_type::__desc_type\t__desc_type;\n@@ -304,18 +304,18 @@\n \t    {\n \t      __from_next = reinterpret_cast<const intern_type*>(__cfrom);\n \t      __to_next = reinterpret_cast<extern_type*>(__cto);\n-\t      __ret = ok;\n+\t      __ret = codecvt_base::ok;\n \t    }\n \t  else \n \t    {\n \t      if (__fbytes < __fmultiple * (__from_end - __from))\n \t\t{\n \t\t  __from_next = reinterpret_cast<const intern_type*>(__cfrom);\n \t\t  __to_next = reinterpret_cast<extern_type*>(__cto);\n-\t\t  __ret = partial;\n+\t\t  __ret = codecvt_base::partial;\n \t\t}\n \t      else\n-\t\t__ret = error;\n+\t\t__ret = codecvt_base::error;\n \t    }\n \t}\n       return __ret; \n@@ -327,7 +327,7 @@\n     do_unshift(state_type& __state, extern_type* __to, \n \t       extern_type* __to_end, extern_type*& __to_next) const\n     {\n-      result __ret = error;\n+      result __ret = codecvt_base::error;\n       if (__state._M_good())\n \t{\n \t  typedef state_type::__desc_type\t__desc_type;\n@@ -345,14 +345,14 @@\n \t    {\n \t      __to_next = reinterpret_cast<extern_type*>(__cto);\n \t      if (__tlen == __tmultiple * (__to_end - __to))\n-\t\t__ret = noconv;\n+\t\t__ret = codecvt_base::noconv;\n \t      else if (__tlen == 0)\n-\t\t__ret = ok;\n+\t\t__ret = codecvt_base::ok;\n \t      else\n-\t\t__ret = partial;\n+\t\t__ret = codecvt_base::partial;\n \t    }\n \t  else \n-\t    __ret = error;\n+\t    __ret = codecvt_base::error;\n \t}\n       return __ret; \n     }\n@@ -365,7 +365,7 @@\n \t  intern_type* __to, intern_type* __to_end, \n \t  intern_type*& __to_next) const\n     { \n-      result __ret = error;\n+      result __ret = codecvt_base::error;\n       if (__state._M_good())\n \t{\n \t  typedef state_type::__desc_type\t__desc_type;\n@@ -410,18 +410,18 @@\n \t    {\n \t      __from_next = reinterpret_cast<const extern_type*>(__cfrom);\n \t      __to_next = reinterpret_cast<intern_type*>(__cto);\n-\t      __ret = ok;\n+\t      __ret = codecvt_base::ok;\n \t    }\n \t  else \n \t    {\n \t      if (__flen < static_cast<size_t>(__from_end - __from))\n \t\t{\n \t\t  __from_next = reinterpret_cast<const extern_type*>(__cfrom);\n \t\t  __to_next = reinterpret_cast<intern_type*>(__cto);\n-\t\t  __ret = partial;\n+\t\t  __ret = codecvt_base::partial;\n \t\t}\n \t      else\n-\t\t__ret = error;\n+\t\t__ret = codecvt_base::error;\n \t    }\n \t}\n       return __ret; "}, {"sha": "c88c29d2cd0064ed1a50dbfb9908163103b9b9f4", "filename": "libstdc++-v3/include/bits/codecvt.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fbc5ae72379506e4344297591db49fceac3a799/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fcodecvt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fbc5ae72379506e4344297591db49fceac3a799/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fcodecvt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fcodecvt.h?ref=8fbc5ae72379506e4344297591db49fceac3a799", "patch": "@@ -1,6 +1,6 @@\n // Locale support (codecvt) -*- C++ -*-\n \n-// Copyright (C) 2000, 2001, 2002 Free Software Foundation, Inc.\n+// Copyright (C) 2000, 2001, 2002, 2003 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -341,9 +341,9 @@\n       codecvt_byname(const char* __s, size_t __refs = 0) \n       : codecvt<_InternT, _ExternT, _StateT>(__refs)\n       { \n-\tif (_M_c_locale_codecvt != _S_c_locale)\n-\t  _S_destroy_c_locale(_M_c_locale_codecvt);\n-\t_S_create_c_locale(_M_c_locale_codecvt, __s); \n+\tif (this->_M_c_locale_codecvt != this->_S_c_locale)\n+\t  _S_destroy_c_locale(this->_M_c_locale_codecvt);\n+\t_S_create_c_locale(this->_M_c_locale_codecvt, __s); \n       }\n \n     protected:"}, {"sha": "d4143f4f15520a2d6a798ed277a7d590c9156f23", "filename": "libstdc++-v3/include/bits/deque.tcc", "status": "modified", "additions": 154, "deletions": 135, "changes": 289, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fbc5ae72379506e4344297591db49fceac3a799/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fdeque.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fbc5ae72379506e4344297591db49fceac3a799/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fdeque.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fdeque.tcc?ref=8fbc5ae72379506e4344297591db49fceac3a799", "patch": "@@ -1,6 +1,6 @@\n // Deque implementation (out of line) -*- C++ -*-\n \n-// Copyright (C) 2001, 2002 Free Software Foundation, Inc.\n+// Copyright (C) 2001, 2002, 2003 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -72,12 +72,12 @@ namespace std\n       if (&__x != this)\n       {\n         if (__len >= __x.size())\n-          erase(copy(__x.begin(), __x.end(), _M_start), _M_finish);\n+          erase(copy(__x.begin(), __x.end(), this->_M_start), this->_M_finish);\n         else\n         {\n           const_iterator __mid = __x.begin() + difference_type(__len);\n-          copy(__x.begin(), __mid, _M_start);\n-          insert(_M_finish, __mid, __x.end());\n+          copy(__x.begin(), __mid, this->_M_start);\n+          insert(this->_M_finish, __mid, __x.end());\n         }\n       }\n       return *this;\n@@ -88,15 +88,15 @@ namespace std\n     deque<_Tp,_Alloc>::\n     insert(iterator position, const value_type& __x)\n     {\n-      if (position._M_cur == _M_start._M_cur)\n+      if (position._M_cur == this->_M_start._M_cur)\n       {\n         push_front(__x);\n-        return _M_start;\n+        return this->_M_start;\n       }\n-      else if (position._M_cur == _M_finish._M_cur)\n+      else if (position._M_cur == this->_M_finish._M_cur)\n       {\n         push_back(__x);\n-        iterator __tmp = _M_finish;\n+        iterator __tmp = this->_M_finish;\n         --__tmp;\n         return __tmp;\n       }\n@@ -111,51 +111,52 @@ namespace std\n     {\n       iterator __next = __position;\n       ++__next;\n-      size_type __index = __position - _M_start;\n+      size_type __index = __position - this->_M_start;\n       if (__index < (size() >> 1))\n       {\n-        copy_backward(_M_start, __position, __next);\n+        copy_backward(this->_M_start, __position, __next);\n         pop_front();\n       }\n       else\n       {\n-        copy(__next, _M_finish, __position);\n+        copy(__next, this->_M_finish, __position);\n         pop_back();\n       }\n-      return _M_start + __index;\n+      return this->_M_start + __index;\n     }\n   \n   template <typename _Tp, typename _Alloc>\n     typename deque<_Tp,_Alloc>::iterator \n     deque<_Tp,_Alloc>::\n     erase(iterator __first, iterator __last)\n     {\n-      if (__first == _M_start && __last == _M_finish)\n+      if (__first == this->_M_start && __last == this->_M_finish)\n       {\n         clear();\n-        return _M_finish;\n+        return this->_M_finish;\n       }\n       else\n       {\n         difference_type __n = __last - __first;\n-        difference_type __elems_before = __first - _M_start;\n+        difference_type __elems_before = __first - this->_M_start;\n         if (static_cast<size_type>(__elems_before) < (size() - __n) / 2)\n         {\n-          copy_backward(_M_start, __first, __last);\n-          iterator __new_start = _M_start + __n;\n-          _Destroy(_M_start, __new_start);\n-          _M_destroy_nodes(_M_start._M_node, __new_start._M_node);\n-          _M_start = __new_start;\n+          copy_backward(this->_M_start, __first, __last);\n+          iterator __new_start = this->_M_start + __n;\n+          _Destroy(this->_M_start, __new_start);\n+          _M_destroy_nodes(this->_M_start._M_node, __new_start._M_node);\n+          this->_M_start = __new_start;\n         }\n         else\n         {\n-          copy(__last, _M_finish, __first);\n-          iterator __new_finish = _M_finish - __n;\n-          _Destroy(__new_finish, _M_finish);\n-          _M_destroy_nodes(__new_finish._M_node + 1, _M_finish._M_node + 1);\n-          _M_finish = __new_finish;\n+          copy(__last, this->_M_finish, __first);\n+          iterator __new_finish = this->_M_finish - __n;\n+          _Destroy(__new_finish, this->_M_finish);\n+          _M_destroy_nodes(__new_finish._M_node + 1,\n+\t\t\t   this->_M_finish._M_node + 1);\n+          this->_M_finish = __new_finish;\n         }\n-        return _M_start + __elems_before;\n+        return this->_M_start + __elems_before;\n       }\n     }\n     \n@@ -164,24 +165,24 @@ namespace std\n     deque<_Tp,_Alloc>::\n     clear()\n     {\n-      for (_Map_pointer __node = _M_start._M_node + 1;\n-           __node < _M_finish._M_node;\n+      for (_Map_pointer __node = this->_M_start._M_node + 1;\n+           __node < this->_M_finish._M_node;\n            ++__node)\n       {\n         _Destroy(*__node, *__node + _S_buffer_size());\n         _M_deallocate_node(*__node);\n       }\n     \n-      if (_M_start._M_node != _M_finish._M_node)\n+      if (this->_M_start._M_node != this->_M_finish._M_node)\n       {\n-        _Destroy(_M_start._M_cur, _M_start._M_last);\n-        _Destroy(_M_finish._M_first, _M_finish._M_cur);\n-        _M_deallocate_node(_M_finish._M_first);\n+        _Destroy(this->_M_start._M_cur, this->_M_start._M_last);\n+        _Destroy(this->_M_finish._M_first, this->_M_finish._M_cur);\n+        _M_deallocate_node(this->_M_finish._M_first);\n       }\n       else\n-        _Destroy(_M_start._M_cur, _M_finish._M_cur);\n+        _Destroy(this->_M_start._M_cur, this->_M_finish._M_cur);\n     \n-      _M_finish = _M_start;\n+      this->_M_finish = this->_M_start;\n     }\n     \n   template <typename _Tp, class _Alloc>\n@@ -204,31 +205,32 @@ namespace std\n     deque<_Tp,_Alloc>::\n     _M_fill_insert(iterator __pos, size_type __n, const value_type& __x)\n     {\n-      if (__pos._M_cur == _M_start._M_cur)\n+      if (__pos._M_cur == this->_M_start._M_cur)\n       {\n         iterator __new_start = _M_reserve_elements_at_front(__n);\n         try\n           {\n-            uninitialized_fill(__new_start, _M_start, __x);\n-            _M_start = __new_start;\n+            uninitialized_fill(__new_start, this->_M_start, __x);\n+            this->_M_start = __new_start;\n           }\n         catch(...)\n           {\n-            _M_destroy_nodes(__new_start._M_node, _M_start._M_node);\n+            _M_destroy_nodes(__new_start._M_node, this->_M_start._M_node);\n             __throw_exception_again;\n           }\n       }\n-      else if (__pos._M_cur == _M_finish._M_cur)\n+      else if (__pos._M_cur == this->_M_finish._M_cur)\n       {\n         iterator __new_finish = _M_reserve_elements_at_back(__n);\n         try\n           {\n-            uninitialized_fill(_M_finish, __new_finish, __x);\n-            _M_finish = __new_finish;\n+            uninitialized_fill(this->_M_finish, __new_finish, __x);\n+            this->_M_finish = __new_finish;\n           }\n         catch(...)\n           {\n-            _M_destroy_nodes(_M_finish._M_node + 1, __new_finish._M_node + 1);    \n+            _M_destroy_nodes(this->_M_finish._M_node + 1,\n+\t\t\t     __new_finish._M_node + 1);    \n             __throw_exception_again;\n           }\n       }\n@@ -244,13 +246,17 @@ namespace std\n       _Map_pointer __cur;\n       try\n         {\n-          for (__cur = _M_start._M_node; __cur < _M_finish._M_node; ++__cur)\n+          for (__cur = this->_M_start._M_node;\n+\t       __cur < this->_M_finish._M_node;\n+\t       ++__cur)\n             uninitialized_fill(*__cur, *__cur + _S_buffer_size(), __value);\n-          uninitialized_fill(_M_finish._M_first, _M_finish._M_cur, __value);\n+          uninitialized_fill(this->_M_finish._M_first,\n+\t\t\t     this->_M_finish._M_cur,\n+\t\t\t     __value);\n         }\n       catch(...)\n         {\n-          _Destroy(_M_start, iterator(*__cur, __cur));\n+          _Destroy(this->_M_start, iterator(*__cur, __cur));\n           __throw_exception_again;\n         }\n     }\n@@ -288,20 +294,20 @@ namespace std\n         _Map_pointer __cur_node;\n         try\n           {\n-            for (__cur_node = _M_start._M_node; \n-                 __cur_node < _M_finish._M_node; \n+            for (__cur_node = this->_M_start._M_node; \n+                 __cur_node < this->_M_finish._M_node; \n                  ++__cur_node)\n             {\n               _ForwardIterator __mid = __first;\n               advance(__mid, _S_buffer_size());\n               uninitialized_copy(__first, __mid, *__cur_node);\n               __first = __mid;\n             }\n-            uninitialized_copy(__first, __last, _M_finish._M_first);\n+            uninitialized_copy(__first, __last, this->_M_finish._M_first);\n           }\n         catch(...)\n           {\n-            _Destroy(_M_start, iterator(*__cur_node, __cur_node));\n+            _Destroy(this->_M_start, iterator(*__cur_node, __cur_node));\n             __throw_exception_again;\n           }\n       }\n@@ -314,16 +320,16 @@ namespace std\n     {\n       value_type __t_copy = __t;\n       _M_reserve_map_at_back();\n-      *(_M_finish._M_node + 1) = _M_allocate_node();\n+      *(this->_M_finish._M_node + 1) = _M_allocate_node();\n       try\n         {\n-          _Construct(_M_finish._M_cur, __t_copy);\n-          _M_finish._M_set_node(_M_finish._M_node + 1);\n-          _M_finish._M_cur = _M_finish._M_first;\n+          _Construct(this->_M_finish._M_cur, __t_copy);\n+          this->_M_finish._M_set_node(this->_M_finish._M_node + 1);\n+          this->_M_finish._M_cur = this->_M_finish._M_first;\n         }\n       catch(...)\n         {\n-          _M_deallocate_node(*(_M_finish._M_node + 1));\n+          _M_deallocate_node(*(this->_M_finish._M_node + 1));\n           __throw_exception_again;\n         }\n     }\n@@ -336,17 +342,17 @@ namespace std\n     {\n       value_type __t_copy = __t;\n       _M_reserve_map_at_front();\n-      *(_M_start._M_node - 1) = _M_allocate_node();\n+      *(this->_M_start._M_node - 1) = _M_allocate_node();\n       try\n         {\n-          _M_start._M_set_node(_M_start._M_node - 1);\n-          _M_start._M_cur = _M_start._M_last - 1;\n-          _Construct(_M_start._M_cur, __t_copy);\n+          this->_M_start._M_set_node(this->_M_start._M_node - 1);\n+          this->_M_start._M_cur = this->_M_start._M_last - 1;\n+          _Construct(this->_M_start._M_cur, __t_copy);\n         }\n       catch(...)\n         {\n-          ++_M_start;\n-          _M_deallocate_node(*(_M_start._M_node - 1));\n+          ++this->_M_start;\n+          _M_deallocate_node(*(this->_M_start._M_node - 1));\n           __throw_exception_again;\n         }\n     } \n@@ -356,10 +362,10 @@ namespace std\n     void deque<_Tp,_Alloc>::\n     _M_pop_back_aux()\n     {\n-      _M_deallocate_node(_M_finish._M_first);\n-      _M_finish._M_set_node(_M_finish._M_node - 1);\n-      _M_finish._M_cur = _M_finish._M_last - 1;\n-      _Destroy(_M_finish._M_cur);\n+      _M_deallocate_node(this->_M_finish._M_first);\n+      this->_M_finish._M_set_node(this->_M_finish._M_node - 1);\n+      this->_M_finish._M_cur = this->_M_finish._M_last - 1;\n+      _Destroy(this->_M_finish._M_cur);\n     }\n     \n   // Called only if _M_start._M_cur == _M_start._M_last - 1.  Note that \n@@ -370,10 +376,10 @@ namespace std\n     void deque<_Tp,_Alloc>::\n     _M_pop_front_aux()\n     {\n-      _Destroy(_M_start._M_cur);\n-      _M_deallocate_node(_M_start._M_first);\n-      _M_start._M_set_node(_M_start._M_node + 1);\n-      _M_start._M_cur = _M_start._M_first;\n+      _Destroy(this->_M_start._M_cur);\n+      _M_deallocate_node(this->_M_start._M_first);\n+      this->_M_start._M_set_node(this->_M_start._M_node + 1);\n+      this->_M_start._M_cur = this->_M_start._M_first;\n     }      \n     \n   template <typename _Tp, typename _Alloc>\n@@ -396,31 +402,32 @@ namespace std\n                           forward_iterator_tag)\n       {\n         size_type __n = std::distance(__first, __last);\n-        if (__pos._M_cur == _M_start._M_cur)\n+        if (__pos._M_cur == this->_M_start._M_cur)\n         {\n           iterator __new_start = _M_reserve_elements_at_front(__n);\n           try\n             {\n               uninitialized_copy(__first, __last, __new_start);\n-              _M_start = __new_start;\n+              this->_M_start = __new_start;\n             }\n           catch(...)\n             {\n-              _M_destroy_nodes(__new_start._M_node, _M_start._M_node);\n+              _M_destroy_nodes(__new_start._M_node, this->_M_start._M_node);\n               __throw_exception_again;\n             }\n         }\n-        else if (__pos._M_cur == _M_finish._M_cur)\n+        else if (__pos._M_cur == this->_M_finish._M_cur)\n         {\n           iterator __new_finish = _M_reserve_elements_at_back(__n);\n           try\n             {\n-              uninitialized_copy(__first, __last, _M_finish);\n-              _M_finish = __new_finish;\n+              uninitialized_copy(__first, __last, this->_M_finish);\n+              this->_M_finish = __new_finish;\n             }\n           catch(...)\n             {\n-              _M_destroy_nodes(_M_finish._M_node + 1, __new_finish._M_node + 1);\n+              _M_destroy_nodes(this->_M_finish._M_node + 1,\n+\t\t\t       __new_finish._M_node + 1);\n               __throw_exception_again;\n             }\n         }\n@@ -433,28 +440,28 @@ namespace std\n     deque<_Tp,_Alloc>::\n     _M_insert_aux(iterator __pos, const value_type& __x)\n     {\n-      difference_type __index = __pos - _M_start;\n+      difference_type __index = __pos - this->_M_start;\n       value_type __x_copy = __x; // XXX copy\n       if (static_cast<size_type>(__index) < size() / 2)\n       {\n         push_front(front());\n-        iterator __front1 = _M_start;\n+        iterator __front1 = this->_M_start;\n         ++__front1;\n         iterator __front2 = __front1;\n         ++__front2;\n-        __pos = _M_start + __index;\n+        __pos = this->_M_start + __index;\n         iterator __pos1 = __pos;\n         ++__pos1;\n         copy(__front2, __pos1, __front1);\n       }\n       else\n       {\n         push_back(back());\n-        iterator __back1 = _M_finish;\n+        iterator __back1 = this->_M_finish;\n         --__back1;\n         iterator __back2 = __back1;\n         --__back2;\n-        __pos = _M_start + __index;\n+        __pos = this->_M_start + __index;\n         copy_backward(__pos, __back2, __back1);\n       }\n       *__pos = __x_copy;\n@@ -466,66 +473,68 @@ namespace std\n     deque<_Tp,_Alloc>::\n     _M_insert_aux(iterator __pos, size_type __n, const value_type& __x)\n     {\n-      const difference_type __elems_before = __pos - _M_start;\n+      const difference_type __elems_before = __pos - this->_M_start;\n       size_type __length = this->size();\n       value_type __x_copy = __x;\n       if (__elems_before < difference_type(__length / 2))\n       {\n         iterator __new_start = _M_reserve_elements_at_front(__n);\n-        iterator __old_start = _M_start;\n-        __pos = _M_start + __elems_before;\n+        iterator __old_start = this->_M_start;\n+        __pos = this->_M_start + __elems_before;\n         try\n           {\n             if (__elems_before >= difference_type(__n))\n             {\n-              iterator __start_n = _M_start + difference_type(__n);\n-              uninitialized_copy(_M_start, __start_n, __new_start);\n-              _M_start = __new_start;\n+              iterator __start_n = this->_M_start + difference_type(__n);\n+              uninitialized_copy(this->_M_start, __start_n, __new_start);\n+              this->_M_start = __new_start;\n               copy(__start_n, __pos, __old_start);\n               fill(__pos - difference_type(__n), __pos, __x_copy);\n             }\n             else\n             {\n-              __uninitialized_copy_fill(_M_start, __pos, __new_start, \n-                                        _M_start, __x_copy);\n-              _M_start = __new_start;\n+              __uninitialized_copy_fill(this->_M_start, __pos, __new_start, \n+                                        this->_M_start, __x_copy);\n+              this->_M_start = __new_start;\n               fill(__old_start, __pos, __x_copy);\n             }\n           }\n         catch(...)\n           { \n-            _M_destroy_nodes(__new_start._M_node, _M_start._M_node);\n+            _M_destroy_nodes(__new_start._M_node, this->_M_start._M_node);\n             __throw_exception_again;\n           }\n       }\n       else\n       {\n         iterator __new_finish = _M_reserve_elements_at_back(__n);\n-        iterator __old_finish = _M_finish;\n+        iterator __old_finish = this->_M_finish;\n         const difference_type __elems_after = \n           difference_type(__length) - __elems_before;\n-        __pos = _M_finish - __elems_after;\n+        __pos = this->_M_finish - __elems_after;\n         try\n           {\n             if (__elems_after > difference_type(__n))\n             {\n-              iterator __finish_n = _M_finish - difference_type(__n);\n-              uninitialized_copy(__finish_n, _M_finish, _M_finish);\n-              _M_finish = __new_finish;\n+              iterator __finish_n = this->_M_finish - difference_type(__n);\n+              uninitialized_copy(__finish_n, this->_M_finish, this->_M_finish);\n+              this->_M_finish = __new_finish;\n               copy_backward(__pos, __finish_n, __old_finish);\n               fill(__pos, __pos + difference_type(__n), __x_copy);\n             }\n             else\n             {\n-              __uninitialized_fill_copy(_M_finish, __pos + difference_type(__n),\n-                                        __x_copy, __pos, _M_finish);\n-              _M_finish = __new_finish;\n+              __uninitialized_fill_copy(this->_M_finish,\n+\t\t\t\t\t__pos + difference_type(__n),\n+                                        __x_copy, __pos, this->_M_finish);\n+              this->_M_finish = __new_finish;\n               fill(__pos, __old_finish, __x_copy);\n             }\n           }\n         catch(...)\n           { \n-            _M_destroy_nodes(_M_finish._M_node + 1, __new_finish._M_node + 1);\n+            _M_destroy_nodes(this->_M_finish._M_node + 1,\n+\t\t\t     __new_finish._M_node + 1);\n             __throw_exception_again;\n           }\n       }\n@@ -539,53 +548,55 @@ namespace std\n                     _ForwardIterator __first, _ForwardIterator __last,\n                     size_type __n)\n       {\n-        const difference_type __elemsbefore = __pos - _M_start;\n+        const difference_type __elemsbefore = __pos - this->_M_start;\n         size_type __length = size();\n         if (static_cast<size_type>(__elemsbefore) < __length / 2)\n         {\n           iterator __new_start = _M_reserve_elements_at_front(__n);\n-          iterator __old_start = _M_start;\n-          __pos = _M_start + __elemsbefore;\n+          iterator __old_start = this->_M_start;\n+          __pos = this->_M_start + __elemsbefore;\n           try\n             {\n               if (__elemsbefore >= difference_type(__n))\n               {\n-                iterator __start_n = _M_start + difference_type(__n); \n-                uninitialized_copy(_M_start, __start_n, __new_start);\n-                _M_start = __new_start;\n+                iterator __start_n = this->_M_start + difference_type(__n); \n+                uninitialized_copy(this->_M_start, __start_n, __new_start);\n+                this->_M_start = __new_start;\n                 copy(__start_n, __pos, __old_start);\n                 copy(__first, __last, __pos - difference_type(__n));\n               }\n               else\n               {\n                 _ForwardIterator __mid = __first;\n                 advance(__mid, difference_type(__n) - __elemsbefore);\n-                __uninitialized_copy_copy(_M_start, __pos, __first, __mid,\n-                                          __new_start);\n-                _M_start = __new_start;\n+                __uninitialized_copy_copy(this->_M_start, __pos,\n+\t\t\t\t\t  __first, __mid, __new_start);\n+                this->_M_start = __new_start;\n                 copy(__mid, __last, __old_start);\n               }\n             }\n           catch(...)\n             {\n-              _M_destroy_nodes(__new_start._M_node, _M_start._M_node);\n+              _M_destroy_nodes(__new_start._M_node, this->_M_start._M_node);\n               __throw_exception_again;\n             }\n         }\n         else\n         {\n           iterator __new_finish = _M_reserve_elements_at_back(__n);\n-          iterator __old_finish = _M_finish;\n+          iterator __old_finish = this->_M_finish;\n           const difference_type __elemsafter = \n             difference_type(__length) - __elemsbefore;\n-          __pos = _M_finish - __elemsafter;\n+          __pos = this->_M_finish - __elemsafter;\n           try\n             {\n               if (__elemsafter > difference_type(__n))\n               {\n-                iterator __finish_n = _M_finish - difference_type(__n);\n-                uninitialized_copy(__finish_n, _M_finish, _M_finish);\n-                _M_finish = __new_finish;\n+                iterator __finish_n = this->_M_finish - difference_type(__n);\n+                uninitialized_copy(__finish_n,\n+\t\t\t\t   this->_M_finish,\n+\t\t\t\t   this->_M_finish);\n+                this->_M_finish = __new_finish;\n                 copy_backward(__pos, __finish_n, __old_finish);\n                 copy(__first, __last, __pos);\n               }\n@@ -594,14 +605,15 @@ namespace std\n                 _ForwardIterator __mid = __first;\n                 advance(__mid, __elemsafter);\n                 __uninitialized_copy_copy(__mid, __last, __pos,\n-                                          _M_finish, _M_finish);\n-                _M_finish = __new_finish;\n+                                          this->_M_finish, this->_M_finish);\n+                this->_M_finish = __new_finish;\n                 copy(__first, __mid, __pos);\n               }\n             }\n           catch(...)\n             {\n-              _M_destroy_nodes(_M_finish._M_node + 1, __new_finish._M_node + 1);\n+              _M_destroy_nodes(this->_M_finish._M_node + 1,\n+\t\t\t       __new_finish._M_node + 1);\n               __throw_exception_again;\n             }\n         }\n@@ -619,12 +631,12 @@ namespace std\n       try\n         {\n           for (__i = 1; __i <= __new_nodes; ++__i)\n-            *(_M_start._M_node - __i) = _M_allocate_node();\n+            *(this->_M_start._M_node - __i) = _M_allocate_node();\n         }\n       catch(...)\n         {\n           for (size_type __j = 1; __j < __i; ++__j)\n-            _M_deallocate_node(*(_M_start._M_node - __j));      \n+            _M_deallocate_node(*(this->_M_start._M_node - __j));      \n           __throw_exception_again;\n         }\n     }\n@@ -641,12 +653,12 @@ namespace std\n       try\n         {\n           for (__i = 1; __i <= __new_nodes; ++__i)\n-            *(_M_finish._M_node + __i) = _M_allocate_node();\n+            *(this->_M_finish._M_node + __i) = _M_allocate_node();\n         }\n       catch(...)\n         {\n           for (size_type __j = 1; __j < __i; ++__j)\n-            _M_deallocate_node(*(_M_finish._M_node + __j));      \n+            _M_deallocate_node(*(this->_M_finish._M_node + __j));      \n           __throw_exception_again;\n         }\n     }\n@@ -656,37 +668,44 @@ namespace std\n     deque<_Tp,_Alloc>::\n     _M_reallocate_map(size_type __nodes_to_add, bool __add_at_front)\n     {\n-      size_type __old_num_nodes = _M_finish._M_node - _M_start._M_node + 1;\n+      size_type __old_num_nodes\n+\t= this->_M_finish._M_node - this->_M_start._M_node + 1;\n       size_type __new_num_nodes = __old_num_nodes + __nodes_to_add;\n     \n       _Map_pointer __new_nstart;\n-      if (_M_map_size > 2 * __new_num_nodes)\n+      if (this->_M_map_size > 2 * __new_num_nodes)\n       {\n-        __new_nstart = _M_map + (_M_map_size - __new_num_nodes) / 2 \n-                         + (__add_at_front ? __nodes_to_add : 0);\n-        if (__new_nstart < _M_start._M_node)\n-          copy(_M_start._M_node, _M_finish._M_node + 1, __new_nstart);\n+        __new_nstart\n+\t  = this->_M_map + (this->_M_map_size - __new_num_nodes) / 2 \n+\t  + (__add_at_front ? __nodes_to_add : 0);\n+        if (__new_nstart < this->_M_start._M_node)\n+          copy(this->_M_start._M_node,\n+\t       this->_M_finish._M_node + 1,\n+\t       __new_nstart);\n         else\n-          copy_backward(_M_start._M_node, _M_finish._M_node + 1, \n+          copy_backward(this->_M_start._M_node,\n+\t\t\tthis->_M_finish._M_node + 1, \n                         __new_nstart + __old_num_nodes);\n       }\n       else\n       {\n         size_type __new_map_size = \n-          _M_map_size + std::max(_M_map_size, __nodes_to_add) + 2;\n+          this->_M_map_size + std::max(this->_M_map_size, __nodes_to_add) + 2;\n     \n         _Map_pointer __new_map = _M_allocate_map(__new_map_size);\n         __new_nstart = __new_map + (__new_map_size - __new_num_nodes) / 2\n                              + (__add_at_front ? __nodes_to_add : 0);\n-        copy(_M_start._M_node, _M_finish._M_node + 1, __new_nstart);\n-        _M_deallocate_map(_M_map, _M_map_size);\n+        copy(this->_M_start._M_node,\n+\t     this->_M_finish._M_node + 1,\n+\t     __new_nstart);\n+        _M_deallocate_map(this->_M_map, this->_M_map_size);\n     \n-        _M_map = __new_map;\n-        _M_map_size = __new_map_size;\n+        this->_M_map = __new_map;\n+        this->_M_map_size = __new_map_size;\n       }\n     \n-      _M_start._M_set_node(__new_nstart);\n-      _M_finish._M_set_node(__new_nstart + __old_num_nodes - 1);\n+      this->_M_start._M_set_node(__new_nstart);\n+      this->_M_finish._M_set_node(__new_nstart + __old_num_nodes - 1);\n     }\n } // namespace std \n   "}, {"sha": "1865a92f2f4f18217954ddde956362a11752beb4", "filename": "libstdc++-v3/include/bits/fstream.tcc", "status": "modified", "additions": 52, "deletions": 46, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fbc5ae72379506e4344297591db49fceac3a799/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ffstream.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fbc5ae72379506e4344297591db49fceac3a799/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ffstream.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ffstream.tcc?ref=8fbc5ae72379506e4344297591db49fceac3a799", "patch": "@@ -1,6 +1,6 @@\n // File based streams -*- C++ -*-\n \n-// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002\n+// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003\n // Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n@@ -44,12 +44,12 @@ namespace std\n     basic_filebuf<_CharT, _Traits>::\n     _M_allocate_internal_buffer()\n     {\n-      if (!_M_buf && _M_buf_size_opt)\n+      if (!this->_M_buf && this->_M_buf_size_opt)\n \t{\n-\t  _M_buf_size = _M_buf_size_opt;\n+\t  this->_M_buf_size = this->_M_buf_size_opt;\n \n \t  // Allocate internal buffer.\n-\t  _M_buf = new char_type[_M_buf_size]; \n+\t  this->_M_buf = new char_type[this->_M_buf_size]; \n \t  _M_buf_allocated = true;\n \t}\n     }\n@@ -62,8 +62,8 @@ namespace std\n     {\n       if (_M_buf_allocated)\n \t{\n-\t  delete [] _M_buf;\n-\t  _M_buf = NULL;\n+\t  delete [] this->_M_buf;\n+\t  this->_M_buf = NULL;\n \t  _M_buf_allocated = false;\n \t  this->setg(NULL, NULL, NULL);\n \t  this->setp(NULL, NULL);\n@@ -75,7 +75,7 @@ namespace std\n     basic_filebuf() : __streambuf_type(), _M_file(&_M_lock), \n     _M_state_cur(__state_type()), _M_state_beg(__state_type()), \n     _M_buf_allocated(false), _M_last_overflowed(false)\n-    { _M_buf_unified = true; }\n+    { this->_M_buf_unified = true; }\n \n   template<typename _CharT, typename _Traits>\n     typename basic_filebuf<_CharT, _Traits>::__filebuf_type* \n@@ -89,7 +89,7 @@ namespace std\n \t  if (this->is_open())\n \t    {\n \t      _M_allocate_internal_buffer();\n-\t      _M_mode = __mode;\n+\t      this->_M_mode = __mode;\n \n \t      // Setup initial position of buffer.\n \t      _M_set_indeterminate();\n@@ -120,13 +120,14 @@ namespace std\n       if (this->is_open())\n \t{\n \t  const int_type __eof = traits_type::eof();\n-\t  bool __testput = _M_out_cur && _M_out_beg < _M_out_end;\n+\t  bool __testput = this->_M_out_cur\n+\t    && this->_M_out_beg < this->_M_out_end;\n \t  if (__testput \n \t      && traits_type::eq_int_type(_M_really_overflow(__eof), __eof))\n \t    return __ret;\n \n \t  // NB: Do this here so that re-opened filebufs will be cool...\n-\t  _M_mode = ios_base::openmode(0);\n+\t  this->_M_mode = ios_base::openmode(0);\n \t  _M_destroy_internal_buffer();\n \t  _M_pback_destroy();\n \t  \n@@ -153,10 +154,10 @@ namespace std\n     showmanyc()\n     {\n       streamsize __ret = -1;\n-      bool __testin = _M_mode & ios_base::in;\n+      bool __testin = this->_M_mode & ios_base::in;\n \n       if (__testin && this->is_open())\n-\t__ret = _M_in_end - _M_in_cur;\n+\t__ret = this->_M_in_end - this->_M_in_cur;\n       _M_last_overflowed = false;\t\n       return __ret;\n     }\n@@ -167,42 +168,42 @@ namespace std\n     pbackfail(int_type __i)\n     {\n       int_type __ret = traits_type::eof();\n-      bool __testin = _M_mode & ios_base::in;\n+      bool __testin = this->_M_mode & ios_base::in;\n \n       if (__testin)\n \t{\n-\t  bool __testpb = _M_in_beg < _M_in_cur;\n+\t  bool __testpb = this->_M_in_beg < this->_M_in_cur;\n \t  char_type __c = traits_type::to_char_type(__i);\n \t  bool __testeof = traits_type::eq_int_type(__i, __ret);\n \n \t  if (__testpb)\n \t    {\n-\t      bool __testout = _M_mode & ios_base::out;\n+\t      bool __testout = this->_M_mode & ios_base::out;\n \t      bool __testeq = traits_type::eq(__c, this->gptr()[-1]);\n \n \t      // Try to put back __c into input sequence in one of three ways.\n \t      // Order these tests done in is unspecified by the standard.\n \t      if (!__testeof && __testeq)\n \t\t{\n-\t\t  --_M_in_cur;\n+\t\t  --this->_M_in_cur;\n \t\t  if (__testout)\n-\t\t    --_M_out_cur;\n+\t\t    --this->_M_out_cur;\n \t\t  __ret = __i;\n \t\t}\n \t      else if (__testeof)\n \t\t{\n-\t\t  --_M_in_cur;\n+\t\t  --this->_M_in_cur;\n \t\t  if (__testout)\n-\t\t    --_M_out_cur;\n+\t\t    --this->_M_out_cur;\n \t\t  __ret = traits_type::not_eof(__i);\n \t\t}\n \t      else if (!__testeof)\n \t\t{\n-\t\t  --_M_in_cur;\n+\t\t  --this->_M_in_cur;\n \t\t  if (__testout)\n-\t\t    --_M_out_cur;\n+\t\t    --this->_M_out_cur;\n \t\t  _M_pback_create();\n-\t\t  *_M_in_cur = __c; \n+\t\t  *this->_M_in_cur = __c; \n \t\t  __ret = __i;\n \t\t}\n \t    }\n@@ -214,10 +215,10 @@ namespace std\n \t      this->underflow();\n  \t      if (!__testeof)\n  \t\t{\n-\t\t  if (!traits_type::eq(__c, *_M_in_cur))\n+\t\t  if (!traits_type::eq(__c, *this->_M_in_cur))\n \t\t    {\n \t\t      _M_pback_create();\n-\t\t      *_M_in_cur = __c;\n+\t\t      *this->_M_in_cur = __c;\n \t\t    }\n  \t\t  __ret = __i;\n  \t\t}\n@@ -235,14 +236,15 @@ namespace std\n     overflow(int_type __c)\n     {\n       int_type __ret = traits_type::eof();\n-      bool __testput = _M_out_cur && _M_out_cur < _M_buf + _M_buf_size;\n-      bool __testout = _M_mode & ios_base::out;\n+      bool __testput = this->_M_out_cur\n+\t&& this->_M_out_cur < this->_M_buf + this->_M_buf_size;\n+      bool __testout = this->_M_mode & ios_base::out;\n       \n       if (__testout)\n \t{\n \t  if (__testput)\n \t    {\n-\t      *_M_out_cur = traits_type::to_char_type(__c);\n+\t      *this->_M_out_cur = traits_type::to_char_type(__c);\n \t      _M_out_cur_move(1);\n \t      __ret = traits_type::not_eof(__c);\n \t    }\n@@ -297,7 +299,7 @@ namespace std\n \t  if (__r == codecvt_base::partial)\n \t    {\n \t      const char_type* __iresume = __iend;\n-\t      streamsize __rlen = _M_out_end - __iend;\n+\t      streamsize __rlen = this->_M_out_end - __iend;\n \t      __r = __cvt.out(_M_state_cur, __iresume, __iresume + __rlen, \n \t\t\t      __iend, __buf, __buf + __blen, __bend);\n \t      if (__r != codecvt_base::error)\n@@ -319,8 +321,8 @@ namespace std\n     _M_really_overflow(int_type __c)\n     {\n       int_type __ret = traits_type::eof();\n-      bool __testput = _M_out_cur && _M_out_beg < _M_out_end;\n-      bool __testunbuffered = _M_file.is_open() && !_M_buf_size_opt;\n+      bool __testput = this->_M_out_cur && this->_M_out_beg < this->_M_out_end;\n+      bool __testunbuffered = _M_file.is_open() && !this->_M_buf_size_opt;\n \n       if (__testput || __testunbuffered)\n \t{\n@@ -331,16 +333,17 @@ namespace std\n \t  // Need to restore current position. The position of the external\n \t  // byte sequence (_M_file) corresponds to _M_filepos, and we need\n \t  // to move it to _M_out_beg for the write.\n-\t  if (_M_filepos && _M_filepos != _M_out_beg)\n+\t  if (_M_filepos && _M_filepos != this->_M_out_beg)\n \t    {\n-\t      off_type __off = _M_out_beg - _M_filepos;\n+\t      off_type __off = this->_M_out_beg - _M_filepos;\n \t      _M_file.seekoff(__off, ios_base::cur);\n \t    }\n \n \t  // Convert internal buffer to external representation, output.\n \t  // NB: In the unbuffered case, no internal buffer exists. \n \t  if (!__testunbuffered)\n-\t    _M_convert_to_external(_M_out_beg,  _M_out_end - _M_out_beg, \n+\t    _M_convert_to_external(this->_M_out_beg,\n+\t\t\t\t   this->_M_out_end - this->_M_out_beg, \n \t\t\t\t   __elen, __plen);\n \n \t  // Convert pending sequence to external representation, output.\n@@ -373,7 +376,7 @@ namespace std\n     setbuf(char_type* __s, streamsize __n)\n     {\n       if (!this->is_open() && __s == 0 && __n == 0)\n-\t_M_buf_size_opt = 0;\n+\tthis->_M_buf_size_opt = 0;\n       else if (__s && __n)\n \t{\n \t  // This is implementation-defined behavior, and assumes\n@@ -384,8 +387,8 @@ namespace std\n \t  _M_destroy_internal_buffer();\n \t  \n \t  // Step 2: Use the external array.\n-\t  _M_buf = __s;\n-\t  _M_buf_size_opt = _M_buf_size = __n;\n+\t  this->_M_buf = __s;\n+\t  this->_M_buf_size_opt = this->_M_buf_size = __n;\n \t  _M_set_indeterminate();\n \t}\n       _M_last_overflowed = false;\t\n@@ -398,11 +401,11 @@ namespace std\n     seekoff(off_type __off, ios_base::seekdir __way, ios_base::openmode __mode)\n     {\n       pos_type __ret =  pos_type(off_type(-1)); \n-      bool __testin = (ios_base::in & _M_mode & __mode) != 0;\n-      bool __testout = (ios_base::out & _M_mode & __mode) != 0;\n+      bool __testin = (ios_base::in & this->_M_mode & __mode) != 0;\n+      bool __testout = (ios_base::out & this->_M_mode & __mode) != 0;\n \n       // Should probably do has_facet checks here.\n-      int __width = use_facet<__codecvt_type>(_M_buf_locale).encoding();\n+      int __width = use_facet<__codecvt_type>(this->_M_buf_locale).encoding();\n       if (__width < 0)\n \t__width = 0;\n       bool __testfail = __off != 0 && __width <= 0;\n@@ -416,8 +419,10 @@ namespace std\n \t    { \n \t      off_type __computed_off = __width * __off;\n \t      \n-\t      bool __testget = _M_in_cur && _M_in_beg < _M_in_end;\n-\t      bool __testput = _M_out_cur && _M_out_beg < _M_out_end;\n+\t      bool __testget = this->_M_in_cur\n+\t\t&& this->_M_in_beg < this->_M_in_end;\n+\t      bool __testput = this->_M_out_cur\n+\t\t&& this->_M_out_beg < this->_M_out_end;\n \t      // Sync the internal and external streams.\n \t      // out\n \t      if (__testput || _M_last_overflowed)\n@@ -429,7 +434,7 @@ namespace std\n \t\t}\n \t      //in\n \t      else if (__testget && __way == ios_base::cur)\n-\t\t__computed_off += _M_in_cur - _M_filepos;\n+\t\t__computed_off += this->_M_in_cur - _M_filepos;\n \t  \n \t      __ret = _M_file.seekoff(__computed_off, __way, __mode);\n \t      _M_set_indeterminate();\n@@ -439,7 +444,8 @@ namespace std\n \t  else\n \t    {\n \t      __ret = _M_file.seekoff(__off, ios_base::cur, __mode);\n-\t      __ret += std::max(_M_out_cur, _M_in_cur) - _M_filepos;\n+\t      __ret +=\n+\t\tstd::max(this->_M_out_cur, this->_M_in_cur) - _M_filepos;\n \t    }\n \t}\n       _M_last_overflowed = false;\t\n@@ -470,10 +476,10 @@ namespace std\n     {\n       bool __testbeg = gptr() == eback() && pptr() == pbase();\n \n-      if (__testbeg && _M_buf_locale != __loc)\n+      if (__testbeg && this->_M_buf_locale != __loc)\n \t{\n-\t  _M_buf_locale = __loc;\n-\t  _M_buf_locale_init = true;\n+\t  this->_M_buf_locale = __loc;\n+\t  this->_M_buf_locale_init = true;\n \t}\n \n       // NB this may require the reconversion of previously"}, {"sha": "ea8573665efc72151dc0bd554c70939b33819517", "filename": "libstdc++-v3/include/bits/istream.tcc", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fbc5ae72379506e4344297591db49fceac3a799/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fistream.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fbc5ae72379506e4344297591db49fceac3a799/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fistream.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fistream.tcc?ref=8fbc5ae72379506e4344297591db49fceac3a799", "patch": "@@ -114,8 +114,8 @@ namespace std\n \t  try \n \t    {\n \t      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);\n-\t      if (_M_check_facet(_M_fnumget))\n-\t\t_M_fnumget->get(*this, 0, *this, __err, __n);\n+\t      if (_M_check_facet(this->_M_fnumget))\n+\t\tthis->_M_fnumget->get(*this, 0, *this, __err, __n);\n \t      this->setstate(__err);\n \t    }\n \t  catch(exception& __fail)\n@@ -142,8 +142,8 @@ namespace std\n \t    {\n \t      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);\n \t      long __l;\n-\t      if (_M_check_facet(_M_fnumget))\n-\t\t_M_fnumget->get(*this, 0, *this, __err, __l);\n+\t      if (_M_check_facet(this->_M_fnumget))\n+\t\tthis->_M_fnumget->get(*this, 0, *this, __err, __l);\n #ifdef _GLIBCPP_RESOLVE_LIB_DEFECTS\n \t      // 118. basic_istream uses nonexistent num_get member functions.\n \t      if (!(__err & ios_base::failbit)\n@@ -178,8 +178,8 @@ namespace std\n \t  try \n \t    {\n \t      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);\n-\t      if (_M_check_facet(_M_fnumget))\n-\t\t_M_fnumget->get(*this, 0, *this, __err, __n);\n+\t      if (_M_check_facet(this->_M_fnumget))\n+\t\tthis->_M_fnumget->get(*this, 0, *this, __err, __n);\n \t      this->setstate(__err);\n \t    }\n \t  catch(exception& __fail)\n@@ -206,8 +206,8 @@ namespace std\n \t    {\n \t      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);\n \t      long __l;\n-\t      if (_M_check_facet(_M_fnumget))\n-\t\t_M_fnumget->get(*this, 0, *this, __err, __l);\n+\t      if (_M_check_facet(this->_M_fnumget))\n+\t\tthis->_M_fnumget->get(*this, 0, *this, __err, __l);\n #ifdef _GLIBCPP_RESOLVE_LIB_DEFECTS\n \t      // 118. basic_istream uses nonexistent num_get member functions.\n \t      if (!(__err & ios_base::failbit)\n@@ -242,8 +242,8 @@ namespace std\n \t  try \n \t    {\n \t      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);\n-\t      if (_M_check_facet(_M_fnumget))\n-\t\t_M_fnumget->get(*this, 0, *this, __err, __n);\n+\t      if (_M_check_facet(this->_M_fnumget))\n+\t\tthis->_M_fnumget->get(*this, 0, *this, __err, __n);\n \t      this->setstate(__err);\n \t    }\n \t  catch(exception& __fail)\n@@ -269,8 +269,8 @@ namespace std\n \t  try \n \t    {\n \t      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);\n-\t      if (_M_check_facet(_M_fnumget))\n-\t\t_M_fnumget->get(*this, 0, *this, __err, __n);\n+\t      if (_M_check_facet(this->_M_fnumget))\n+\t\tthis->_M_fnumget->get(*this, 0, *this, __err, __n);\n \t      this->setstate(__err);\n \t    }\n \t  catch(exception& __fail)\n@@ -296,8 +296,8 @@ namespace std\n \t  try \n \t    {\n \t      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);\n-\t      if (_M_check_facet(_M_fnumget))\n-\t\t_M_fnumget->get(*this, 0, *this, __err, __n);\n+\t      if (_M_check_facet(this->_M_fnumget))\n+\t\tthis->_M_fnumget->get(*this, 0, *this, __err, __n);\n \t      this->setstate(__err);\n \t    }\n \t  catch(exception& __fail)\n@@ -324,8 +324,8 @@ namespace std\n \t  try \n \t    {\n \t      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);\n-\t      if (_M_check_facet(_M_fnumget))\n-\t\t_M_fnumget->get(*this, 0, *this, __err, __n);\n+\t      if (_M_check_facet(this->_M_fnumget))\n+\t\tthis->_M_fnumget->get(*this, 0, *this, __err, __n);\n \t      this->setstate(__err);\n \t    }\n \t  catch(exception& __fail)\n@@ -351,8 +351,8 @@ namespace std\n \t  try \n \t    {\n \t      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);\n-\t      if (_M_check_facet(_M_fnumget))\n-\t\t_M_fnumget->get(*this, 0, *this, __err, __n);\n+\t      if (_M_check_facet(this->_M_fnumget))\n+\t\tthis->_M_fnumget->get(*this, 0, *this, __err, __n);\n \t      this->setstate(__err);\n \t    }\n \t  catch(exception& __fail)\n@@ -379,8 +379,8 @@ namespace std\n \t  try \n \t    {\n \t      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);\n-\t      if (_M_check_facet(_M_fnumget))\n-\t\t_M_fnumget->get(*this, 0, *this, __err, __n);\n+\t      if (_M_check_facet(this->_M_fnumget))\n+\t\tthis->_M_fnumget->get(*this, 0, *this, __err, __n);\n \t      this->setstate(__err);\n \t    }\n \t  catch(exception& __fail)\n@@ -406,8 +406,8 @@ namespace std\n \t  try \n \t    {\n \t      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);\n-\t      if (_M_check_facet(_M_fnumget))\n-\t\t_M_fnumget->get(*this, 0, *this, __err, __n);\n+\t      if (_M_check_facet(this->_M_fnumget))\n+\t\tthis->_M_fnumget->get(*this, 0, *this, __err, __n);\n \t      this->setstate(__err);\n \t    }\n \t  catch(exception& __fail)\n@@ -433,8 +433,8 @@ namespace std\n \t  try \n \t    {\n \t      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);\n-\t      if (_M_check_facet(_M_fnumget))\n-\t\t_M_fnumget->get(*this, 0, *this, __err, __n);\n+\t      if (_M_check_facet(this->_M_fnumget))\n+\t\tthis->_M_fnumget->get(*this, 0, *this, __err, __n);\n \t      this->setstate(__err);\n \t    }\n \t  catch(exception& __fail)\n@@ -460,8 +460,8 @@ namespace std\n \t  try \n \t    {\n \t      ios_base::iostate __err = ios_base::iostate(ios_base::goodbit);\n-\t      if (_M_check_facet(_M_fnumget))\n-\t\t_M_fnumget->get(*this, 0, *this, __err, __n);\n+\t      if (_M_check_facet(this->_M_fnumget))\n+\t\tthis->_M_fnumget->get(*this, 0, *this, __err, __n);\n \t      this->setstate(__err);\n \t    }\n \t  catch(exception& __fail)"}, {"sha": "e4d47a2bb3792873f25b7f04357ac5301a8c9bd3", "filename": "libstdc++-v3/include/bits/list.tcc", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fbc5ae72379506e4344297591db49fceac3a799/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flist.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fbc5ae72379506e4344297591db49fceac3a799/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flist.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flist.tcc?ref=8fbc5ae72379506e4344297591db49fceac3a799", "patch": "@@ -1,6 +1,6 @@\n // List implementation (out of line) -*- C++ -*-\n \n-// Copyright (C) 2001, 2002 Free Software Foundation, Inc.\n+// Copyright (C) 2001, 2002, 2003 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -69,16 +69,16 @@ namespace std\n     __clear()\n     {\n       typedef _List_node<_Tp>  _Node;\n-      _Node* __cur = static_cast<_Node*>(_M_node->_M_next);\n-      while (__cur != _M_node)\n+      _Node* __cur = static_cast<_Node*>(this->_M_node->_M_next);\n+      while (__cur != this->_M_node)\n       {\n         _Node* __tmp = __cur;\n         __cur = static_cast<_Node*>(__cur->_M_next);\n         _Destroy(&__tmp->_M_data);\n         _M_put_node(__tmp);\n       }\n-      _M_node->_M_next = _M_node;\n-      _M_node->_M_prev = _M_node;\n+      this->_M_node->_M_next = this->_M_node;\n+      this->_M_node->_M_prev = this->_M_node;\n     }\n   \n   template<typename _Tp, typename _Alloc>\n@@ -250,7 +250,8 @@ namespace std\n     sort()\n     {\n       // Do nothing if the list has length 0 or 1.\n-      if (_M_node->_M_next != _M_node && _M_node->_M_next->_M_next != _M_node)\n+      if (this->_M_node->_M_next != this->_M_node \n+\t  && this->_M_node->_M_next->_M_next != this->_M_node)\n       {\n         list __carry;\n         list __counter[64];\n@@ -340,7 +341,8 @@ namespace std\n     sort(_StrictWeakOrdering __comp)\n     {\n       // Do nothing if the list has length 0 or 1.\n-      if (_M_node->_M_next != _M_node && _M_node->_M_next->_M_next != _M_node)\n+      if (this->_M_node->_M_next != this->_M_node && \n+\t  this->_M_node->_M_next->_M_next != this->_M_node)\n       {\n         list __carry;\n         list __counter[64];"}, {"sha": "809155fe116791cbdf578b9a48f77ba1b96c123e", "filename": "libstdc++-v3/include/bits/locale_facets.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fbc5ae72379506e4344297591db49fceac3a799/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fbc5ae72379506e4344297591db49fceac3a799/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.h?ref=8fbc5ae72379506e4344297591db49fceac3a799", "patch": "@@ -921,8 +921,8 @@ namespace std\n       collate_byname(const char* __s, size_t __refs = 0)\n       : collate<_CharT>(__refs) \n       { \n-\t_S_destroy_c_locale(_M_c_locale_collate);\n-\t_S_create_c_locale(_M_c_locale_collate, __s); \n+\t_S_destroy_c_locale(this->_M_c_locale_collate);\n+\t_S_create_c_locale(this->_M_c_locale_collate, __s); \n       }\n \n     protected:"}, {"sha": "30b16ca8dfdeb797098c08303e19948f25b4a03b", "filename": "libstdc++-v3/include/bits/ostream.tcc", "status": "modified", "additions": 28, "deletions": 18, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fbc5ae72379506e4344297591db49fceac3a799/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fostream.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fbc5ae72379506e4344297591db49fceac3a799/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fostream.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fostream.tcc?ref=8fbc5ae72379506e4344297591db49fceac3a799", "patch": "@@ -149,8 +149,9 @@ namespace std\n \t{\n \t  try \n \t    {\n-\t      if (_M_check_facet(_M_fnumput))\n-\t\tif (_M_fnumput->put(*this, *this, this->fill(), __n).failed())\n+\t      if (_M_check_facet(this->_M_fnumput))\n+\t\tif (this->_M_fnumput->put(*this, *this, \n+\t\t\t\t\t  this->fill(), __n).failed())\n \t\t  this->setstate(ios_base::badbit);\n \t    }\n \t  catch(exception& __fail)\n@@ -176,16 +177,18 @@ namespace std\n \t    {\n \t      char_type __c = this->fill();\n \t      ios_base::fmtflags __fmt = this->flags() & ios_base::basefield;\n-\t      if (_M_check_facet(_M_fnumput))\n+\t      if (_M_check_facet(this->_M_fnumput))\n \t\t{\n \t\t  bool __b = false;\n \t\t  if ((__fmt & ios_base::oct) || (__fmt & ios_base::hex))\n \t\t    {\n \t\t      unsigned long __l = static_cast<unsigned long>(__n);\n-\t\t      __b = _M_fnumput->put(*this, *this, __c, __l).failed();\n+\t\t      __b = this->_M_fnumput->put(*this, *this, \n+\t\t\t\t\t\t  __c, __l).failed();\n \t\t    }\n \t\t  else\n-\t\t    __b = _M_fnumput->put(*this, *this, __c, __n).failed();\n+\t\t    __b = this->_M_fnumput->put(*this, *this,\n+\t\t\t\t\t\t__c, __n).failed();\n \t\t  if (__b)  \n \t\t    this->setstate(ios_base::badbit);\n \t\t}\n@@ -211,8 +214,9 @@ namespace std\n \t{\n \t  try \n \t    {\n-\t      if (_M_check_facet(_M_fnumput))\n-\t\tif (_M_fnumput->put(*this, *this, this->fill(), __n).failed())\n+\t      if (_M_check_facet(this->_M_fnumput))\n+\t\tif (this->_M_fnumput->put(*this, *this, \n+\t\t\t\t\t  this->fill(), __n).failed())\n \t\t  this->setstate(ios_base::badbit);\n \t    }\n \t  catch(exception& __fail)\n@@ -239,17 +243,19 @@ namespace std\n \t    {\n \t      char_type __c = this->fill();\n \t      ios_base::fmtflags __fmt = this->flags() & ios_base::basefield;\n-\t      if (_M_check_facet(_M_fnumput))\n+\t      if (_M_check_facet(this->_M_fnumput))\n \t\t{\n \t\t  bool __b = false;\n \t\t  if ((__fmt & ios_base::oct) || (__fmt & ios_base::hex))\n \t\t    {\n \t\t      unsigned long long __l;\n \t\t      __l = static_cast<unsigned long long>(__n);\n-\t\t      __b = _M_fnumput->put(*this, *this, __c, __l).failed();\n+\t\t      __b = this->_M_fnumput->put(*this, *this,\n+\t\t\t\t\t\t  __c, __l).failed();\n \t\t    }\n \t\t  else\n-\t\t    __b = _M_fnumput->put(*this, *this, __c, __n).failed();\n+\t\t    __b = this->_M_fnumput->put(*this, *this,\n+\t\t\t\t\t\t__c, __n).failed();\n \t\t  if (__b)  \n \t\t    this->setstate(ios_base::badbit);\n \t\t}\n@@ -275,8 +281,9 @@ namespace std\n \t{\n \t  try \n \t    {\n-\t      if (_M_check_facet(_M_fnumput))\n-\t\tif (_M_fnumput->put(*this, *this, this->fill(), __n).failed())\n+\t      if (_M_check_facet(this->_M_fnumput))\n+\t\tif (this->_M_fnumput->put(*this, *this, \n+\t\t\t\t\t  this->fill(), __n).failed())\n \t\t  this->setstate(ios_base::badbit);\n \t    }\n \t  catch(exception& __fail)\n@@ -301,8 +308,9 @@ namespace std\n \t{\n \t  try \n \t    {\n-\t      if (_M_check_facet(_M_fnumput))\n-\t\tif (_M_fnumput->put(*this, *this, this->fill(), __n).failed())\n+\t      if (_M_check_facet(this->_M_fnumput))\n+\t\tif (this->_M_fnumput->put(*this, *this, \n+\t\t\t\t\t  this->fill(), __n).failed())\n \t\t  this->setstate(ios_base::badbit);\n \t    }\n \t  catch(exception& __fail)\n@@ -326,8 +334,9 @@ namespace std\n \t{\n \t  try \n \t    {\n-\t      if (_M_check_facet(_M_fnumput))\n-\t\tif (_M_fnumput->put(*this, *this, this->fill(), __n).failed())\n+\t      if (_M_check_facet(this->_M_fnumput))\n+\t\tif (this->_M_fnumput->put(*this, *this, \n+\t\t\t\t\t  this->fill(), __n).failed())\n \t\t  this->setstate(ios_base::badbit);\n \t    }\n \t  catch(exception& __fail)\n@@ -351,8 +360,9 @@ namespace std\n \t{\n \t  try \n \t    {\n-\t      if (_M_check_facet(_M_fnumput))\n-\t\tif (_M_fnumput->put(*this, *this, this->fill(), __n).failed())\n+\t      if (_M_check_facet(this->_M_fnumput))\n+\t\tif (this->_M_fnumput->put(*this, *this, \n+\t\t\t\t\t  this->fill(), __n).failed())\n \t\t  this->setstate(ios_base::badbit);\n \t    }\n \t  catch(exception& __fail)"}, {"sha": "32014bc396e696252da78af5ea66b1ab72cecd99", "filename": "libstdc++-v3/include/bits/sstream.tcc", "status": "modified", "additions": 25, "deletions": 24, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fbc5ae72379506e4344297591db49fceac3a799/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fsstream.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fbc5ae72379506e4344297591db49fceac3a799/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fsstream.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fsstream.tcc?ref=8fbc5ae72379506e4344297591db49fceac3a799", "patch": "@@ -48,7 +48,7 @@ namespace std\n     {\n       int_type __ret = traits_type::eof();\n       bool __testeof = traits_type::eq_int_type(__c, traits_type::eof());\n-      bool __testpos = _M_in_cur && _M_in_beg < _M_in_cur; \n+      bool __testpos = this->_M_in_cur && this->_M_in_beg < this->_M_in_cur; \n       \n       // Try to put back __c into input sequence in one of three ways.\n       // Order these tests done in is unspecified by the standard.\n@@ -57,18 +57,18 @@ namespace std\n \t  if (traits_type::eq(traits_type::to_char_type(__c), this->gptr()[-1])\n \t      && !__testeof)\n \t    {\n-\t      --_M_in_cur;\n+\t      --this->_M_in_cur;\n \t      __ret = __c;\n \t    }\n \t  else if (!__testeof)\n \t    {\n-\t      --_M_in_cur;\n-\t      *_M_in_cur = traits_type::to_char_type(__c);\n+\t      --this->_M_in_cur;\n+\t      *this->_M_in_cur = traits_type::to_char_type(__c);\n \t      __ret = __c;\n \t    }\n \t  else if (__testeof)\n \t    {\n-\t      --_M_in_cur;\n+\t      --this->_M_in_cur;\n \t      __ret = traits_type::not_eof(__c);\n \t    }\n \t}\n@@ -82,16 +82,17 @@ namespace std\n     {\n       int_type __ret = traits_type::eof();\n       bool __testeof = traits_type::eq_int_type(__c, __ret);\n-      bool __testwrite = _M_out_cur < _M_buf + _M_buf_size;\n-      bool __testout = _M_mode & ios_base::out;\n+      bool __testwrite = this->_M_out_cur < this->_M_buf + this->_M_buf_size;\n+      bool __testout = this->_M_mode & ios_base::out;\n \n       // Try to append __c into output sequence in one of two ways.\n       // Order these tests done in is unspecified by the standard.\n       if (__testout)\n \t{\n \t  if (!__testeof)\n \t    {\n-\t      __size_type __len = std::max(_M_buf_size, _M_buf_size_opt);\n+\t      __size_type __len = std::max(this->_M_buf_size, \n+\t\t\t\t\t   this->_M_buf_size_opt);\n \t      __len *= 2;\n \n \t      if (__testwrite)\n@@ -101,10 +102,10 @@ namespace std\n \t\t  // Force-allocate, re-sync.\n \t\t  _M_string = this->str();\n \t\t  _M_string.reserve(__len);\n-\t\t  _M_buf_size = __len;\n-\t\t  _M_really_sync(_M_in_cur - _M_in_beg, \n-\t\t\t\t _M_out_cur - _M_out_beg);\n-\t\t  *_M_out_cur = traits_type::to_char_type(__c);\n+\t\t  this->_M_buf_size = __len;\n+\t\t  _M_really_sync(this->_M_in_cur - this->_M_in_beg, \n+\t\t\t\t this->_M_out_cur - this->_M_out_beg);\n+\t\t  *this->_M_out_cur = traits_type::to_char_type(__c);\n \t\t  _M_out_cur_move(1);\n \t\t  __ret = __c;\n \t\t}\n@@ -121,15 +122,15 @@ namespace std\n     seekoff(off_type __off, ios_base::seekdir __way, ios_base::openmode __mode)\n     {\n       pos_type __ret =  pos_type(off_type(-1)); \n-      bool __testin = (ios_base::in & _M_mode & __mode) != 0;\n-      bool __testout = (ios_base::out & _M_mode & __mode) != 0;\n+      bool __testin = (ios_base::in & this->_M_mode & __mode) != 0;\n+      bool __testout = (ios_base::out & this->_M_mode & __mode) != 0;\n       bool __testboth = __testin && __testout && __way != ios_base::cur;\n       __testin &= !(__mode & ios_base::out);\n       __testout &= !(__mode & ios_base::in);\n \n-      if (_M_buf_size && (__testin || __testout || __testboth))\n+      if (this->_M_buf_size && (__testin || __testout || __testboth))\n \t{\n-\t  char_type* __beg = _M_buf;\n+\t  char_type* __beg = this->_M_buf;\n \t  char_type* __curi = NULL;\n \t  char_type* __curo = NULL;\n \t  char_type* __endi = NULL;\n@@ -162,13 +163,13 @@ namespace std\n \t  if ((__testin || __testboth)\n \t      && __newoffi + __off >= 0 && __endi - __beg >= __newoffi + __off)\n \t    {\n-\t      _M_in_cur = __beg + __newoffi + __off;\n+\t      this->_M_in_cur = __beg + __newoffi + __off;\n \t      __ret = pos_type(__newoffi);\n \t    }\n \t  if ((__testout || __testboth)\n \t      && __newoffo + __off >= 0 && __endo - __beg >= __newoffo + __off)\n \t    {\n-\t      _M_out_cur_move(__newoffo + __off - (_M_out_cur - __beg));\n+\t      _M_out_cur_move(__newoffo + __off - (this->_M_out_cur - __beg));\n \t      __ret = pos_type(__newoffo);\n \t    }\n \t}\n@@ -182,13 +183,13 @@ namespace std\n     {\n       pos_type __ret =  pos_type(off_type(-1)); \n       \n-      if (_M_buf_size)\n+      if (this->_M_buf_size)\n \t{\n \t  off_type __pos = __sp; // Use streamoff operator to do conversion.\n \t  char_type* __beg = NULL;\n \t  char_type* __end = NULL;\n-\t  bool __testin = (ios_base::in & _M_mode & __mode) != 0;\n-\t  bool __testout = (ios_base::out & _M_mode & __mode) != 0;\n+\t  bool __testin = (ios_base::in & this->_M_mode & __mode) != 0;\n+\t  bool __testout = (ios_base::out & this->_M_mode & __mode) != 0;\n \t  bool __testboth = __testin && __testout;\n \t  __testin &= !(__mode & ios_base::out);\n \t  __testout &= !(__mode & ios_base::in);\n@@ -206,16 +207,16 @@ namespace std\n \t  if (__testout || __testboth)\n \t    {\n \t      __beg = this->pbase();\n-\t      __end = _M_buf + _M_buf_size;\n+\t      __end = this->_M_buf + this->_M_buf_size;\n \t      if (0 <= __pos && __pos <= __end - __beg)\n \t\t__testposo = true;\n \t    }\n \t  if (__testposi || __testposo)\n \t    {\n \t      if (__testposi)\n-\t\t_M_in_cur = _M_in_beg + __pos;\n+\t\tthis->_M_in_cur = this->_M_in_beg + __pos;\n \t      if (__testposo)\n-\t\t_M_out_cur_move((__pos) - (_M_out_cur - __beg));\n+\t\t_M_out_cur_move((__pos) - (this->_M_out_cur - __beg));\n \t      __ret = pos_type(off_type(__pos));\n \t    }\n \t}"}, {"sha": "d334a729d23b9d5b1d6e113b86c10eb3a7c4da9d", "filename": "libstdc++-v3/include/bits/stl_bvector.h", "status": "modified", "additions": 56, "deletions": 50, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fbc5ae72379506e4344297591db49fceac3a799/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_bvector.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fbc5ae72379506e4344297591db49fceac3a799/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_bvector.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_bvector.h?ref=8fbc5ae72379506e4344297591db49fceac3a799", "patch": "@@ -1,6 +1,6 @@\n // bit_vector and vector<bool> specialization -*- C++ -*-\n \n-// Copyright (C) 2001, 2002 Free Software Foundation, Inc.\n+// Copyright (C) 2001, 2002, 2003 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -374,35 +374,35 @@ template <typename _Alloc>\n   protected:\n     void _M_initialize(size_type __n) {\n       _Bit_type * __q = _M_bit_alloc(__n);\n-      _M_end_of_storage = __q + (__n + _M_word_bit - 1)/_M_word_bit;\n-      _M_start = iterator(__q, 0);\n-      _M_finish = _M_start + difference_type(__n);\n+      this->_M_end_of_storage = __q + (__n + _M_word_bit - 1)/_M_word_bit;\n+      this->_M_start = iterator(__q, 0);\n+      this->_M_finish = this->_M_start + difference_type(__n);\n     }\n     void _M_insert_aux(iterator __position, bool __x) {\n-      if (_M_finish._M_p != _M_end_of_storage) {\n-        copy_backward(__position, _M_finish, _M_finish + 1);\n+      if (this->_M_finish._M_p != this->_M_end_of_storage) {\n+        copy_backward(__position, this->_M_finish, this->_M_finish + 1);\n         *__position = __x;\n-        ++_M_finish;\n+        ++this->_M_finish;\n       }\n       else {\n         size_type __len = size() \n \t                  ? 2 * size() : static_cast<size_type>(_M_word_bit);\n         _Bit_type * __q = _M_bit_alloc(__len);\n         iterator __i = copy(begin(), __position, iterator(__q, 0));\n         *__i++ = __x;\n-        _M_finish = copy(__position, end(), __i);\n+        this->_M_finish = copy(__position, end(), __i);\n         _M_deallocate();\n-        _M_end_of_storage = __q + (__len + _M_word_bit - 1)/_M_word_bit;\n-        _M_start = iterator(__q, 0);\n+        this->_M_end_of_storage = __q + (__len + _M_word_bit - 1)/_M_word_bit;\n+        this->_M_start = iterator(__q, 0);\n       }\n     }\n   \n     template <class _InputIterator>\n     void _M_initialize_range(_InputIterator __first, _InputIterator __last,\n                              input_iterator_tag) {\n-      _M_start = iterator();\n-      _M_finish = iterator();\n-      _M_end_of_storage = 0;\n+      this->_M_start = iterator();\n+      this->_M_finish = iterator();\n+      this->_M_end_of_storage = 0;\n       for ( ; __first != __last; ++__first) \n         push_back(*__first);\n     }\n@@ -412,7 +412,7 @@ template <typename _Alloc>\n                              forward_iterator_tag) {\n       size_type __n = std::distance(__first, __last);\n       _M_initialize(__n);\n-      copy(__first, __last, _M_start);\n+      copy(__first, __last, this->_M_start);\n     }\n   \n     template <class _InputIterator>\n@@ -432,28 +432,30 @@ template <typename _Alloc>\n       if (__first != __last) {\n         size_type __n = std::distance(__first, __last);\n         if (capacity() - size() >= __n) {\n-          copy_backward(__position, end(), _M_finish + difference_type(__n));\n+          copy_backward(__position, end(),\n+\t\t\tthis->_M_finish + difference_type(__n));\n           copy(__first, __last, __position);\n-          _M_finish += difference_type(__n);\n+          this->_M_finish += difference_type(__n);\n         }\n         else {\n           size_type __len = size() + std::max(size(), __n);\n           _Bit_type * __q = _M_bit_alloc(__len);\n           iterator __i = copy(begin(), __position, iterator(__q, 0));\n           __i = copy(__first, __last, __i);\n-          _M_finish = copy(__position, end(), __i);\n+          this->_M_finish = copy(__position, end(), __i);\n           _M_deallocate();\n-          _M_end_of_storage = __q + (__len + _M_word_bit - 1)/_M_word_bit;\n-          _M_start = iterator(__q, 0);\n+          this->_M_end_of_storage\n+\t    = __q + (__len + _M_word_bit - 1)/_M_word_bit;\n+          this->_M_start = iterator(__q, 0);\n         }\n       }\n     }      \n   \n   public:\n-    iterator begin() { return _M_start; }\n-    const_iterator begin() const { return _M_start; }\n-    iterator end() { return _M_finish; }\n-    const_iterator end() const { return _M_finish; }\n+    iterator begin() { return this->_M_start; }\n+    const_iterator begin() const { return this->_M_start; }\n+    iterator end() { return this->_M_finish; }\n+    const_iterator end() const { return this->_M_finish; }\n   \n     reverse_iterator rbegin() { return reverse_iterator(end()); }\n     const_reverse_iterator rbegin() const { \n@@ -467,7 +469,7 @@ template <typename _Alloc>\n     size_type size() const { return size_type(end() - begin()); }\n     size_type max_size() const { return size_type(-1); }\n     size_type capacity() const {\n-      return size_type(const_iterator(_M_end_of_storage, 0) - begin());\n+      return size_type(const_iterator(this->_M_end_of_storage, 0) - begin());\n     }\n     bool empty() const { return begin() == end(); }\n   \n@@ -494,27 +496,27 @@ template <typename _Alloc>\n       : _Bvector_base<_Alloc>(__a)\n     {\n       _M_initialize(__n);\n-      fill(_M_start._M_p, _M_end_of_storage, __value ? ~0 : 0);\n+      fill(this->_M_start._M_p, this->_M_end_of_storage, __value ? ~0 : 0);\n     }\n   \n     explicit vector(size_type __n)\n       : _Bvector_base<_Alloc>(allocator_type())\n     {\n       _M_initialize(__n);\n-      fill(_M_start._M_p, _M_end_of_storage, 0);\n+      fill(this->_M_start._M_p, this->_M_end_of_storage, 0);\n     }\n   \n     vector(const vector& __x) : _Bvector_base<_Alloc>(__x.get_allocator()) {\n       _M_initialize(__x.size());\n-      copy(__x.begin(), __x.end(), _M_start);\n+      copy(__x.begin(), __x.end(), this->_M_start);\n     }\n   \n     // Check whether it's an integral type.  If so, it's not an iterator.\n   \n     template <class _Integer>\n     void _M_initialize_dispatch(_Integer __n, _Integer __x, __true_type) {\n       _M_initialize(__n);\n-      fill(_M_start._M_p, _M_end_of_storage, __x ? ~0 : 0);\n+      fill(this->_M_start._M_p, this->_M_end_of_storage, __x ? ~0 : 0);\n     }\n   \n     template <class _InputIterator>\n@@ -541,7 +543,7 @@ template <typename _Alloc>\n         _M_initialize(__x.size());\n       }\n       copy(__x.begin(), __x.end(), begin());\n-      _M_finish = begin() + difference_type(__x.size());\n+      this->_M_finish = begin() + difference_type(__x.size());\n       return *this;\n     }\n   \n@@ -552,12 +554,12 @@ template <typename _Alloc>\n   \n     void _M_fill_assign(size_t __n, bool __x) {\n       if (__n > size()) {\n-        fill(_M_start._M_p, _M_end_of_storage, __x ? ~0 : 0);\n+        fill(this->_M_start._M_p, this->_M_end_of_storage, __x ? ~0 : 0);\n         insert(end(), __n - size(), __x);\n       }\n       else {\n         erase(begin() + __n, end());\n-        fill(_M_start._M_p, _M_end_of_storage, __x ? ~0 : 0);\n+        fill(this->_M_start._M_p, this->_M_end_of_storage, __x ? ~0 : 0);\n       }\n     }\n   \n@@ -608,10 +610,10 @@ template <typename _Alloc>\n \t__throw_length_error(\"vector::reserve\");\n       if (this->capacity() < __n) {\n         _Bit_type * __q = _M_bit_alloc(__n);\n-        _M_finish = copy(begin(), end(), iterator(__q, 0));\n+        this->_M_finish = copy(begin(), end(), iterator(__q, 0));\n         _M_deallocate();\n-        _M_start = iterator(__q, 0);\n-        _M_end_of_storage = __q + (__n + _M_word_bit - 1)/_M_word_bit;\n+        this->_M_start = iterator(__q, 0);\n+        this->_M_end_of_storage = __q + (__n + _M_word_bit - 1)/_M_word_bit;\n       }\n     }\n   \n@@ -620,15 +622,15 @@ template <typename _Alloc>\n     reference back() { return *(end() - 1); }\n     const_reference back() const { return *(end() - 1); }\n     void push_back(bool __x) {\n-      if (_M_finish._M_p != _M_end_of_storage)\n-        *_M_finish++ = __x;\n+      if (this->_M_finish._M_p != this->_M_end_of_storage)\n+        *this->_M_finish++ = __x;\n       else\n         _M_insert_aux(end(), __x);\n     }\n     void swap(vector<bool, _Alloc>& __x) {\n-      std::swap(_M_start, __x._M_start);\n-      std::swap(_M_finish, __x._M_finish);\n-      std::swap(_M_end_of_storage, __x._M_end_of_storage);\n+      std::swap(this->_M_start, __x._M_start);\n+      std::swap(this->_M_finish, __x._M_finish);\n+      std::swap(this->_M_end_of_storage, __x._M_end_of_storage);\n     }\n \n     // [23.2.5]/1, third-to-last entry in synopsis listing\n@@ -640,8 +642,9 @@ template <typename _Alloc>\n \n     iterator insert(iterator __position, bool __x = bool()) {\n       difference_type __n = __position - begin();\n-      if (_M_finish._M_p != _M_end_of_storage && __position == end())\n-        *_M_finish++ = __x;\n+      if (this->_M_finish._M_p != this->_M_end_of_storage\n+\t  && __position == end())\n+        *this->_M_finish++ = __x;\n       else\n         _M_insert_aux(__position, __x);\n       return begin() + __n;\n@@ -672,35 +675,36 @@ template <typename _Alloc>\n     void _M_fill_insert(iterator __position, size_type __n, bool __x) {\n       if (__n == 0) return;\n       if (capacity() - size() >= __n) {\n-        copy_backward(__position, end(), _M_finish + difference_type(__n));\n+        copy_backward(__position, end(),\n+\t\t      this->_M_finish + difference_type(__n));\n         fill(__position, __position + difference_type(__n), __x);\n-        _M_finish += difference_type(__n);\n+        this->_M_finish += difference_type(__n);\n       }\n       else {\n         size_type __len = size() + std::max(size(), __n);\n         _Bit_type * __q = _M_bit_alloc(__len);\n         iterator __i = copy(begin(), __position, iterator(__q, 0));\n         fill_n(__i, __n, __x);\n-        _M_finish = copy(__position, end(), __i + difference_type(__n));\n+        this->_M_finish = copy(__position, end(), __i + difference_type(__n));\n         _M_deallocate();\n-        _M_end_of_storage = __q + (__len + _M_word_bit - 1)/_M_word_bit;\n-        _M_start = iterator(__q, 0);\n+        this->_M_end_of_storage = __q + (__len + _M_word_bit - 1)/_M_word_bit;\n+        this->_M_start = iterator(__q, 0);\n       }\n     }\n   \n     void insert(iterator __position, size_type __n, bool __x) {\n       _M_fill_insert(__position, __n, __x);\n     }\n   \n-    void pop_back() { --_M_finish; }\n+    void pop_back() { --this->_M_finish; }\n     iterator erase(iterator __position) {\n       if (__position + 1 != end())\n         copy(__position + 1, end(), __position);\n-        --_M_finish;\n+        --this->_M_finish;\n       return __position;\n     }\n     iterator erase(iterator __first, iterator __last) {\n-      _M_finish = copy(__last, end(), __first);\n+      this->_M_finish = copy(__last, end(), __first);\n       return __first;\n     }\n     void resize(size_type __new_size, bool __x = bool()) {\n@@ -710,7 +714,9 @@ template <typename _Alloc>\n         insert(end(), __new_size - size(), __x);\n     }\n     void flip() {\n-      for (_Bit_type * __p = _M_start._M_p; __p != _M_end_of_storage; ++__p)\n+      for (_Bit_type * __p = this->_M_start._M_p;\n+\t   __p != this->_M_end_of_storage;\n+\t   ++__p)\n         *__p = ~*__p;\n     }\n   "}, {"sha": "916a1dc812e932b3770172c5d699a691cf46ed02", "filename": "libstdc++-v3/include/bits/stl_deque.h", "status": "modified", "additions": 56, "deletions": 51, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fbc5ae72379506e4344297591db49fceac3a799/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_deque.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fbc5ae72379506e4344297591db49fceac3a799/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_deque.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_deque.h?ref=8fbc5ae72379506e4344297591db49fceac3a799", "patch": "@@ -1,6 +1,6 @@\n // Deque implementation -*- C++ -*-\n \n-// Copyright (C) 2001, 2002 Free Software Foundation, Inc.\n+// Copyright (C) 2001, 2002, 2003 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -473,10 +473,10 @@ namespace std\n   template <typename _Tp, typename _Alloc>\n   _Deque_base<_Tp,_Alloc>::~_Deque_base()\n   {\n-    if (_M_map)\n+    if (this->_M_map)\n     {\n       _M_destroy_nodes(_M_start._M_node, _M_finish._M_node + 1);\n-      _M_deallocate_map(_M_map, _M_map_size);\n+      _M_deallocate_map(this->_M_map, this->_M_map_size);\n     }\n   }\n   \n@@ -497,23 +497,24 @@ namespace std\n     size_t __num_nodes = \n       __num_elements / __deque_buf_size(sizeof(_Tp)) + 1;\n   \n-    _M_map_size = std::max((size_t) _S_initial_map_size, __num_nodes + 2);\n-    _M_map = _M_allocate_map(_M_map_size);\n+    this->_M_map_size\n+      = std::max((size_t) _S_initial_map_size, __num_nodes + 2);\n+    this->_M_map = _M_allocate_map(this->_M_map_size);\n   \n     // For \"small\" maps (needing less than _M_map_size nodes), allocation\n     // starts in the middle elements and grows outwards.  So nstart may be the\n     // beginning of _M_map, but for small maps it may be as far in as _M_map+3.\n   \n-    _Tp** __nstart = _M_map + (_M_map_size - __num_nodes) / 2;\n+    _Tp** __nstart = this->_M_map + (this->_M_map_size - __num_nodes) / 2;\n     _Tp** __nfinish = __nstart + __num_nodes;\n       \n     try \n       { _M_create_nodes(__nstart, __nfinish); }\n     catch(...)\n       {\n-        _M_deallocate_map(_M_map, _M_map_size);\n-        _M_map = 0;\n-        _M_map_size = 0;\n+        _M_deallocate_map(this->_M_map, this->_M_map_size);\n+        this->_M_map = 0;\n+        this->_M_map_size = 0;\n         __throw_exception_again;\n       }\n     \n@@ -722,7 +723,7 @@ namespace std\n     */\n     deque(const deque& __x)\n       : _Base(__x.get_allocator(), __x.size()) \n-      { uninitialized_copy(__x.begin(), __x.end(), _M_start); }\n+      { uninitialized_copy(__x.begin(), __x.end(), this->_M_start); }\n   \n     /**\n      *  @brief  Builds a %deque from a range.\n@@ -752,7 +753,7 @@ namespace std\n      *  themselves are pointers, the pointed-to memory is not touched in any\n      *  way.  Managing the pointer is the user's responsibilty.\n     */\n-    ~deque() { _Destroy(_M_start, _M_finish); }\n+    ~deque() { _Destroy(this->_M_start, this->_M_finish); }\n   \n     /**\n      *  @brief  %Deque assignment operator.\n@@ -807,63 +808,63 @@ namespace std\n      *  %deque.  Iteration is done in ordinary element order.\n     */\n     iterator\n-    begin() { return _M_start; }\n+    begin() { return this->_M_start; }\n   \n     /**\n      *  Returns a read-only (constant) iterator that points to the first element\n      *  in the %deque.  Iteration is done in ordinary element order.\n     */\n     const_iterator\n-    begin() const { return _M_start; }\n+    begin() const { return this->_M_start; }\n   \n     /**\n      *  Returns a read/write iterator that points one past the last element in\n      *  the %deque.  Iteration is done in ordinary element order.\n     */\n     iterator\n-    end() { return _M_finish; }\n+    end() { return this->_M_finish; }\n   \n     /**\n      *  Returns a read-only (constant) iterator that points one past the last\n      *  element in the %deque.  Iteration is done in ordinary element order.\n     */\n     const_iterator\n-    end() const { return _M_finish; }\n+    end() const { return this->_M_finish; }\n   \n     /**\n      *  Returns a read/write reverse iterator that points to the last element in\n      *  the %deque.  Iteration is done in reverse element order.\n     */\n     reverse_iterator\n-    rbegin() { return reverse_iterator(_M_finish); }\n+    rbegin() { return reverse_iterator(this->_M_finish); }\n   \n     /**\n      *  Returns a read-only (constant) reverse iterator that points to the last\n      *  element in the %deque.  Iteration is done in reverse element order.\n     */\n     const_reverse_iterator\n-    rbegin() const { return const_reverse_iterator(_M_finish); }\n+    rbegin() const { return const_reverse_iterator(this->_M_finish); }\n   \n     /**\n      *  Returns a read/write reverse iterator that points to one before the\n      *  first element in the %deque.  Iteration is done in reverse element\n      *  order.\n     */\n     reverse_iterator\n-    rend() { return reverse_iterator(_M_start); }\n+    rend() { return reverse_iterator(this->_M_start); }\n   \n     /**\n      *  Returns a read-only (constant) reverse iterator that points to one\n      *  before the first element in the %deque.  Iteration is done in reverse\n      *  element order.\n     */\n     const_reverse_iterator\n-    rend() const { return const_reverse_iterator(_M_start); }\n+    rend() const { return const_reverse_iterator(this->_M_start); }\n   \n     // [23.2.1.2] capacity\n     /**  Returns the number of elements in the %deque.  */\n     size_type\n-    size() const { return _M_finish - _M_start; }\n+    size() const { return this->_M_finish - this->_M_start; }\n   \n     /**  Returns the size() of the largest possible %deque.  */\n     size_type\n@@ -884,9 +885,9 @@ namespace std\n     {\n       const size_type __len = size();\n       if (__new_size < __len) \n-        erase(_M_start + __new_size, _M_finish);\n+        erase(this->_M_start + __new_size, this->_M_finish);\n       else\n-        insert(_M_finish, __new_size - __len, __x);\n+        insert(this->_M_finish, __new_size - __len, __x);\n     }\n   \n     /**\n@@ -904,7 +905,7 @@ namespace std\n     /**\n      *  Returns true if the %deque is empty.  (Thus begin() would equal end().)\n     */\n-    bool empty() const { return _M_finish == _M_start; }\n+    bool empty() const { return this->_M_finish == this->_M_start; }\n   \n     // element access\n     /**\n@@ -917,7 +918,7 @@ namespace std\n      *  lookups are not defined. (For checked lookups see at().)\n     */\n     reference\n-    operator[](size_type __n) { return _M_start[difference_type(__n)]; }\n+    operator[](size_type __n) { return this->_M_start[difference_type(__n)]; }\n   \n     /**\n      *  @brief  Subscript access to the data contained in the %deque.\n@@ -929,7 +930,9 @@ namespace std\n      *  lookups are not defined. (For checked lookups see at().)\n     */\n     const_reference\n-    operator[](size_type __n) const { return _M_start[difference_type(__n)]; }\n+    operator[](size_type __n) const {\n+      return this->_M_start[difference_type(__n)];\n+    }\n   \n   protected:\n     /// @if maint Safety check used only from at().  @endif\n@@ -972,14 +975,14 @@ namespace std\n      *  %deque.\n     */\n     reference\n-    front() { return *_M_start; }\n+    front() { return *this->_M_start; }\n   \n     /**\n      *  Returns a read-only (constant) reference to the data at the first\n      *  element of the %deque.\n     */\n     const_reference\n-    front() const { return *_M_start; }\n+    front() const { return *this->_M_start; }\n   \n     /**\n      *  Returns a read/write reference to the data at the last element of the\n@@ -988,7 +991,7 @@ namespace std\n     reference\n     back()\n     {\n-      iterator __tmp = _M_finish;\n+      iterator __tmp = this->_M_finish;\n       --__tmp;\n       return *__tmp;\n     }\n@@ -1000,7 +1003,7 @@ namespace std\n     const_reference\n     back() const\n     {\n-      const_iterator __tmp = _M_finish;\n+      const_iterator __tmp = this->_M_finish;\n       --__tmp;\n       return *__tmp;\n     }\n@@ -1017,9 +1020,9 @@ namespace std\n     void\n     push_front(const value_type& __x) \n     {\n-      if (_M_start._M_cur != _M_start._M_first) {\n-        _Construct(_M_start._M_cur - 1, __x);\n-        --_M_start._M_cur;\n+      if (this->_M_start._M_cur != this->_M_start._M_first) {\n+        _Construct(this->_M_start._M_cur - 1, __x);\n+        --this->_M_start._M_cur;\n       }\n       else\n         _M_push_front_aux(__x);\n@@ -1036,9 +1039,9 @@ namespace std\n     void\n     push_back(const value_type& __x)\n     {\n-      if (_M_finish._M_cur != _M_finish._M_last - 1) {\n-        _Construct(_M_finish._M_cur, __x);\n-        ++_M_finish._M_cur;\n+      if (this->_M_finish._M_cur != this->_M_finish._M_last - 1) {\n+        _Construct(this->_M_finish._M_cur, __x);\n+        ++this->_M_finish._M_cur;\n       }\n       else\n         _M_push_back_aux(__x);\n@@ -1055,9 +1058,9 @@ namespace std\n     void\n     pop_front()\n     {\n-      if (_M_start._M_cur != _M_start._M_last - 1) {\n-        _Destroy(_M_start._M_cur);\n-        ++_M_start._M_cur;\n+      if (this->_M_start._M_cur != this->_M_start._M_last - 1) {\n+        _Destroy(this->_M_start._M_cur);\n+        ++this->_M_start._M_cur;\n       }\n       else \n         _M_pop_front_aux();\n@@ -1074,9 +1077,9 @@ namespace std\n     void\n     pop_back()\n     {\n-      if (_M_finish._M_cur != _M_finish._M_first) {\n-        --_M_finish._M_cur;\n-        _Destroy(_M_finish._M_cur);\n+      if (this->_M_finish._M_cur != this->_M_finish._M_first) {\n+        --this->_M_finish._M_cur;\n+        _Destroy(this->_M_finish._M_cur);\n       }\n       else\n         _M_pop_back_aux();\n@@ -1173,10 +1176,10 @@ namespace std\n     void\n     swap(deque& __x)\n     {\n-      std::swap(_M_start, __x._M_start);\n-      std::swap(_M_finish, __x._M_finish);\n-      std::swap(_M_map, __x._M_map);\n-      std::swap(_M_map_size, __x._M_map_size);\n+      std::swap(this->_M_start, __x._M_start);\n+      std::swap(this->_M_finish, __x._M_finish);\n+      std::swap(this->_M_map, __x._M_map);\n+      std::swap(this->_M_map_size, __x._M_map_size);\n     }\n   \n     /**\n@@ -1396,19 +1399,20 @@ namespace std\n     iterator\n     _M_reserve_elements_at_front(size_type __n)\n     {\n-      size_type __vacancies = _M_start._M_cur - _M_start._M_first;\n+      size_type __vacancies = this->_M_start._M_cur - this->_M_start._M_first;\n       if (__n > __vacancies) \n         _M_new_elements_at_front(__n - __vacancies);\n-      return _M_start - difference_type(__n);\n+      return this->_M_start - difference_type(__n);\n     }\n   \n     iterator\n     _M_reserve_elements_at_back(size_type __n)\n     {\n-      size_type __vacancies = (_M_finish._M_last - _M_finish._M_cur) - 1;\n+      size_type __vacancies\n+\t= (this->_M_finish._M_last - this->_M_finish._M_cur) - 1;\n       if (__n > __vacancies)\n         _M_new_elements_at_back(__n - __vacancies);\n-      return _M_finish + difference_type(__n);\n+      return this->_M_finish + difference_type(__n);\n     }\n   \n     void\n@@ -1432,14 +1436,15 @@ namespace std\n     void\n     _M_reserve_map_at_back (size_type __nodes_to_add = 1)\n     {\n-      if (__nodes_to_add + 1 > _M_map_size - (_M_finish._M_node - _M_map))\n+      if (__nodes_to_add + 1 \n+\t  > this->_M_map_size - (this->_M_finish._M_node - this->_M_map))\n         _M_reallocate_map(__nodes_to_add, false);\n     }\n   \n     void\n     _M_reserve_map_at_front (size_type __nodes_to_add = 1)\n     {\n-      if (__nodes_to_add > size_type(_M_start._M_node - _M_map))\n+      if (__nodes_to_add > size_type(this->_M_start._M_node - this->_M_map))\n         _M_reallocate_map(__nodes_to_add, true);\n     }\n   "}, {"sha": "b8a59e106c72230eeba393fcd1c0e17118cedff1", "filename": "libstdc++-v3/include/bits/stl_list.h", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fbc5ae72379506e4344297591db49fceac3a799/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_list.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fbc5ae72379506e4344297591db49fceac3a799/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_list.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_list.h?ref=8fbc5ae72379506e4344297591db49fceac3a799", "patch": "@@ -1,6 +1,6 @@\n // List implementation -*- C++ -*-\n \n-// Copyright (C) 2001, 2002 Free Software Foundation, Inc.\n+// Copyright (C) 2001, 2002, 2003 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -301,16 +301,16 @@ namespace std\n     _List_base(const allocator_type& __a)\n     : _Base(__a)\n     {\n-      _M_node = _M_get_node();\n-      _M_node->_M_next = _M_node;\n-      _M_node->_M_prev = _M_node;\n+      this->_M_node = _M_get_node();\n+      this->_M_node->_M_next = this->_M_node;\n+      this->_M_node->_M_prev = this->_M_node;\n     }\n   \n     // This is what actually destroys the list.\n     ~_List_base()\n     {\n       __clear();\n-      _M_put_node(_M_node);\n+      _M_put_node(this->_M_node);\n     }\n   \n     void\n@@ -566,28 +566,28 @@ namespace std\n      *  %list.  Iteration is done in ordinary element order.\n     */\n     iterator\n-    begin() { return static_cast<_Node*>(_M_node->_M_next); }\n+    begin() { return static_cast<_Node*>(this->_M_node->_M_next); }\n   \n     /**\n      *  Returns a read-only (constant) iterator that points to the first element\n      *  in the %list.  Iteration is done in ordinary element order.\n     */\n     const_iterator\n-    begin() const { return static_cast<_Node*>(_M_node->_M_next); }\n+    begin() const { return static_cast<_Node*>(this->_M_node->_M_next); }\n   \n     /**\n      *  Returns a read/write iterator that points one past the last element in\n      *  the %list.  Iteration is done in ordinary element order.\n     */\n     iterator\n-    end() { return _M_node; }\n+    end() { return this->_M_node; }\n   \n     /**\n      *  Returns a read-only (constant) iterator that points one past the last\n      *  element in the %list.  Iteration is done in ordinary element order.\n     */\n     const_iterator\n-    end() const { return _M_node; }\n+    end() const { return this->_M_node; }\n   \n     /**\n      *  Returns a read/write reverse iterator that points to the last element in\n@@ -625,7 +625,7 @@ namespace std\n      *  Returns true if the %list is empty.  (Thus begin() would equal end().)\n     */\n     bool\n-    empty() const { return _M_node->_M_next == _M_node; }\n+    empty() const { return this->_M_node->_M_next == this->_M_node; }\n   \n     /**  Returns the number of elements in the %list.  */\n     size_type\n@@ -853,7 +853,7 @@ namespace std\n      *  std::swap(l1,l2) will feed to this function.\n     */\n     void\n-    swap(list& __x) { std::swap(_M_node, __x._M_node); }\n+    swap(list& __x) { std::swap(this->_M_node, __x._M_node); }\n   \n     /**\n      *  Erases all the elements.  Note that this function only erases the"}, {"sha": "b6050375647c46def5cbd798345e79817d7a723c", "filename": "libstdc++-v3/include/bits/stl_tree.h", "status": "modified", "additions": 45, "deletions": 38, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fbc5ae72379506e4344297591db49fceac3a799/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fbc5ae72379506e4344297591db49fceac3a799/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tree.h?ref=8fbc5ae72379506e4344297591db49fceac3a799", "patch": "@@ -1,6 +1,6 @@\n // RB tree implementation -*- C++ -*-\n \n-// Copyright (C) 2001, 2002 Free Software Foundation, Inc.\n+// Copyright (C) 2001, 2002, 2003 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -576,8 +576,8 @@ namespace std\n       typedef typename _Base::allocator_type allocator_type;\n \n       _Rb_tree_base(const allocator_type& __a) \n-      : _Base(__a) { _M_header = _M_get_node(); }\n-      ~_Rb_tree_base() { _M_put_node(_M_header); }\n+      : _Base(__a) { this->_M_header = _M_get_node(); }\n+      ~_Rb_tree_base() { _M_put_node(this->_M_header); }\n     };\n \n \n@@ -645,13 +645,13 @@ namespace std\n       _Compare _M_key_compare;\n \n       _Link_type& \n-      _M_root() const { return (_Link_type&) _M_header->_M_parent; }\n+      _M_root() const { return (_Link_type&) this->_M_header->_M_parent; }\n \n       _Link_type& \n-      _M_leftmost() const { return (_Link_type&) _M_header->_M_left; }\n+      _M_leftmost() const { return (_Link_type&) this->_M_header->_M_left; }\n \n       _Link_type& \n-      _M_rightmost() const { return (_Link_type&) _M_header->_M_right; }\n+      _M_rightmost() const { return (_Link_type&) this->_M_header->_M_right; }\n \n       static _Link_type& \n       _S_left(_Link_type __x) { return (_Link_type&)(__x->_M_left); }\n@@ -737,8 +737,8 @@ namespace std\n \t  _M_empty_initialize();\n \telse \n \t  {\n-\t    _S_color(_M_header) = _M_red;\n-\t    _M_root() = _M_copy(__x._M_root(), _M_header);\n+\t    _S_color(this->_M_header) = _M_red;\n+\t    _M_root() = _M_copy(__x._M_root(), this->_M_header);\n \t    _M_leftmost() = _S_minimum(_M_root());\n \t    _M_rightmost() = _S_maximum(_M_root());\n \t  }\n@@ -753,11 +753,11 @@ namespace std\n     private:\n       void _M_empty_initialize() \n       {\n-\t_S_color(_M_header) = _M_red; // used to distinguish header from \n+\t_S_color(this->_M_header) = _M_red; // used to distinguish header from \n \t// __root, in iterator.operator++\n \t_M_root() = 0;\n-\t_M_leftmost() = _M_header;\n-\t_M_rightmost() = _M_header;\n+\t_M_leftmost() = this->_M_header;\n+\t_M_rightmost() = this->_M_header;\n       }\n \n     public:    \n@@ -772,10 +772,10 @@ namespace std\n       begin() const { return _M_leftmost(); }\n \n       iterator \n-      end() { return _M_header; }\n+      end() { return this->_M_header; }\n \n       const_iterator \n-      end() const { return _M_header; }\n+      end() const { return this->_M_header; }\n \n       reverse_iterator \n       rbegin() { return reverse_iterator(end()); }\n@@ -801,7 +801,7 @@ namespace std\n       void \n       swap(_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& __t) \n       {\n-\tstd::swap(_M_header, __t._M_header);\n+\tstd::swap(this->_M_header, __t._M_header);\n \tstd::swap(_M_node_count, __t._M_node_count);\n \tstd::swap(_M_key_compare, __t._M_key_compare);\n       }\n@@ -845,9 +845,9 @@ namespace std\n \tif (_M_node_count != 0) \n \t  {\n \t    _M_erase(_M_root());\n-\t    _M_leftmost() = _M_header;\n+\t    _M_leftmost() = this->_M_header;\n \t    _M_root() = 0;\n-\t    _M_rightmost() = _M_header;\n+\t    _M_rightmost() = this->_M_header;\n \t    _M_node_count = 0;\n \t  }\n       }      \n@@ -955,12 +955,12 @@ namespace std\n \t  if (__x._M_root() == 0) \n \t    {\n \t      _M_root() = 0;\n-\t      _M_leftmost() = _M_header;\n-\t      _M_rightmost() = _M_header;\n+\t      _M_leftmost() = this->_M_header;\n+\t      _M_rightmost() = this->_M_header;\n \t    }\n \t  else \n \t    {\n-\t      _M_root() = _M_copy(__x._M_root(), _M_header);\n+\t      _M_root() = _M_copy(__x._M_root(), this->_M_header);\n \t      _M_leftmost() = _S_minimum(_M_root());\n \t      _M_rightmost() = _S_maximum(_M_root());\n \t      _M_node_count = __x._M_node_count;\n@@ -979,13 +979,13 @@ namespace std\n       _Link_type __y = (_Link_type) __y_;\n       _Link_type __z;\n       \n-      if (__y == _M_header || __x != 0 || \n+      if (__y == this->_M_header || __x != 0 || \n \t  _M_key_compare(_KeyOfValue()(__v), _S_key(__y))) \n \t{\n \t  __z = _M_create_node(__v);\n \t  _S_left(__y) = __z;               // also makes _M_leftmost() = __z \n \t  //    when __y == _M_header\n-\t  if (__y == _M_header) \n+\t  if (__y == this->_M_header) \n \t    {\n \t      _M_root() = __z;\n \t      _M_rightmost() = __z;\n@@ -1004,7 +1004,7 @@ namespace std\n       _S_parent(__z) = __y;\n       _S_left(__z) = 0;\n       _S_right(__z) = 0;\n-      _Rb_tree_rebalance(__z, _M_header->_M_parent);\n+      _Rb_tree_rebalance(__z, this->_M_header->_M_parent);\n       ++_M_node_count;\n       return iterator(__z);\n     }\n@@ -1015,7 +1015,7 @@ namespace std\n     _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::\n     insert_equal(const _Val& __v)\n     {\n-      _Link_type __y = _M_header;\n+      _Link_type __y = this->_M_header;\n       _Link_type __x = _M_root();\n       while (__x != 0) \n \t{\n@@ -1033,7 +1033,7 @@ namespace std\n     _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::\n     insert_unique(const _Val& __v)\n     {\n-      _Link_type __y = _M_header;\n+      _Link_type __y = this->_M_header;\n       _Link_type __x = _M_root();\n       bool __comp = true;\n       while (__x != 0) \n@@ -1060,7 +1060,7 @@ namespace std\n     _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n     insert_unique(iterator __position, const _Val& __v)\n     {\n-      if (__position._M_node == _M_header->_M_left) \n+      if (__position._M_node == this->_M_header->_M_left) \n \t{ \n \t  // begin()\n \t  if (size() > 0 && \n@@ -1070,7 +1070,7 @@ namespace std\n \t  else\n \t    return insert_unique(__v).first;\n \t} \n-      else if (__position._M_node == _M_header) \n+      else if (__position._M_node == this->_M_header) \n \t{ \n \t  // end()\n \t  if (_M_key_compare(_S_key(_M_rightmost()), _KeyOfValue()(__v)))\n@@ -1102,7 +1102,7 @@ namespace std\n     _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::\n     insert_equal(iterator __position, const _Val& __v)\n     {\n-      if (__position._M_node == _M_header->_M_left) \n+      if (__position._M_node == this->_M_header->_M_left) \n \t{ \n \t  // begin()\n \t  if (size() > 0 && \n@@ -1112,7 +1112,7 @@ namespace std\n \t  else\n \t    return insert_equal(__v);\n \t} \n-      else if (__position._M_node == _M_header) \n+      else if (__position._M_node == this->_M_header) \n \t{\n \t  // end()\n \t  if (!_M_key_compare(_KeyOfValue()(__v), _S_key(_M_rightmost())))\n@@ -1168,9 +1168,9 @@ namespace std\n     {\n       _Link_type __y = \n \t(_Link_type) _Rb_tree_rebalance_for_erase(__position._M_node,\n-\t\t\t\t\t\t  _M_header->_M_parent,\n-\t\t\t\t\t\t  _M_header->_M_left,\n-\t\t\t\t\t\t  _M_header->_M_right);\n+\t\t\t\t\t\t  this->_M_header->_M_parent,\n+\t\t\t\t\t\t  this->_M_header->_M_left,\n+\t\t\t\t\t\t  this->_M_header->_M_right);\n       destroy_node(__y);\n       --_M_node_count;\n     }\n@@ -1264,7 +1264,8 @@ namespace std\n     typename _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator \n     _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::find(const _Key& __k)\n     {\n-      _Link_type __y = _M_header;  // Last node which is not less than __k. \n+      _Link_type __y\n+\t= this->_M_header;  // Last node which is not less than __k. \n       _Link_type __x = _M_root();  // Current node. \n       \n       while (__x != 0) \n@@ -1284,7 +1285,8 @@ namespace std\n     _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::\n     find(const _Key& __k) const\n     {\n-      _Link_type __y = _M_header; // Last node which is not less than __k. \n+      _Link_type __y\n+\t= this->_M_header; // Last node which is not less than __k. \n       _Link_type __x = _M_root(); // Current node. \n  \n      while (__x != 0) \n@@ -1316,7 +1318,8 @@ namespace std\n     _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::\n     lower_bound(const _Key& __k)\n     {\n-      _Link_type __y = _M_header; /* Last node which is not less than __k. */\n+      _Link_type __y\n+\t= this->_M_header; /* Last node which is not less than __k. */\n       _Link_type __x = _M_root(); /* Current node. */\n       \n       while (__x != 0) \n@@ -1334,7 +1337,8 @@ namespace std\n     _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::\n     lower_bound(const _Key& __k) const\n     {\n-      _Link_type __y = _M_header; /* Last node which is not less than __k. */\n+      _Link_type __y\n+\t= this->_M_header; /* Last node which is not less than __k. */\n       _Link_type __x = _M_root(); /* Current node. */\n       \n       while (__x != 0) \n@@ -1352,7 +1356,8 @@ namespace std\n     _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::\n     upper_bound(const _Key& __k)\n     {\n-      _Link_type __y = _M_header; /* Last node which is greater than __k. */\n+      _Link_type __y\n+\t= this->_M_header; /* Last node which is greater than __k. */\n       _Link_type __x = _M_root(); /* Current node. */\n       \n       while (__x != 0) \n@@ -1370,7 +1375,8 @@ namespace std\n     _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::\n     upper_bound(const _Key& __k) const\n     {\n-      _Link_type __y = _M_header; /* Last node which is greater than __k. */\n+      _Link_type __y\n+\t= this->_M_header; /* Last node which is greater than __k. */\n       _Link_type __x = _M_root(); /* Current node. */\n       \n       while (__x != 0) \n@@ -1428,7 +1434,8 @@ namespace std\n     {\n     if (_M_node_count == 0 || begin() == end())\n       return _M_node_count == 0 && begin() == end() &&\n-\t_M_header->_M_left == _M_header && _M_header->_M_right == _M_header;\n+\tthis->_M_header->_M_left == this->_M_header\n+\t&& this->_M_header->_M_right == this->_M_header;\n   \n     int __len = __black_count(_M_leftmost(), _M_root());\n     for (const_iterator __it = begin(); __it != end(); ++__it) "}, {"sha": "f0da72adcb928d619831f66740c42965f9687202", "filename": "libstdc++-v3/include/bits/stl_vector.h", "status": "modified", "additions": 33, "deletions": 28, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fbc5ae72379506e4344297591db49fceac3a799/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_vector.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fbc5ae72379506e4344297591db49fceac3a799/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_vector.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_vector.h?ref=8fbc5ae72379506e4344297591db49fceac3a799", "patch": "@@ -1,6 +1,6 @@\n // Vector implementation -*- C++ -*-\n \n-// Copyright (C) 2001, 2002 Free Software Foundation, Inc.\n+// Copyright (C) 2001, 2002, 2003 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -153,13 +153,14 @@ namespace std\n       _Vector_base(size_t __n, const allocator_type& __a)\n       : _Base(__a)\n       {\n-\t_M_start = _M_allocate(__n);\n-\t_M_finish = _M_start;\n-\t_M_end_of_storage = _M_start + __n;\n+\tthis->_M_start = _M_allocate(__n);\n+\tthis->_M_finish = this->_M_start;\n+\tthis->_M_end_of_storage = this->_M_start + __n;\n       }\n       \n       ~_Vector_base() \n-      { _M_deallocate(_M_start, _M_end_of_storage - _M_start); }\n+      { _M_deallocate(this->_M_start,\n+\t\t      this->_M_end_of_storage - this->_M_start); }\n     };\n   \n   \n@@ -238,7 +239,7 @@ namespace std\n       vector(size_type __n, const value_type& __value,\n \t     const allocator_type& __a = allocator_type())\n       : _Base(__n, __a)\n-      { _M_finish = uninitialized_fill_n(_M_start, __n, __value); }\n+      { this->_M_finish = uninitialized_fill_n(this->_M_start, __n, __value); }\n   \n       /**\n        *  @brief  Create a %vector with default elements.\n@@ -250,7 +251,8 @@ namespace std\n       explicit\n       vector(size_type __n)\n       : _Base(__n, allocator_type())\n-      { _M_finish = uninitialized_fill_n(_M_start, __n, value_type()); }\n+      { this->_M_finish = uninitialized_fill_n(this->_M_start,\n+\t\t\t\t\t       __n, value_type()); }\n       \n       /**\n        *  @brief  %Vector copy constructor.\n@@ -263,7 +265,9 @@ namespace std\n        */\n       vector(const vector& __x)\n       : _Base(__x.size(), __x.get_allocator())\n-      { _M_finish = uninitialized_copy(__x.begin(), __x.end(), _M_start); }\n+      { this->_M_finish = uninitialized_copy(__x.begin(), __x.end(),\n+\t\t\t\t\t     this->_M_start);\n+      }\n   \n       /**\n        *  @brief  Builds a %vector from a range.\n@@ -294,7 +298,7 @@ namespace std\n        *  themselves are pointers, the pointed-to memory is not touched in any\n        *  way.  Managing the pointer is the user's responsibilty.\n        */\n-      ~vector() { _Destroy(_M_start, _M_finish); }\n+      ~vector() { _Destroy(this->_M_start, this->_M_finish); }\n   \n       /**\n        *  @brief  %Vector assignment operator.\n@@ -352,30 +356,30 @@ namespace std\n        *  %vector.  Iteration is done in ordinary element order.\n        */\n       iterator\n-      begin() { return iterator (_M_start); }\n+      begin() { return iterator (this->_M_start); }\n       \n       /**\n        *  Returns a read-only (constant) iterator that points to the\n        *  first element in the %vector.  Iteration is done in ordinary\n        *  element order.\n        */\n       const_iterator\n-      begin() const { return const_iterator (_M_start); }\n+      begin() const { return const_iterator (this->_M_start); }\n       \n       /**\n        *  Returns a read/write iterator that points one past the last\n        *  element in the %vector.  Iteration is done in ordinary\n        *  element order.\n        */\n       iterator\n-      end() { return iterator (_M_finish); }\n+      end() { return iterator (this->_M_finish); }\n       \n       /**\n        *  Returns a read-only (constant) iterator that points one past the last\n        *  element in the %vector.  Iteration is done in ordinary element order.\n        */\n       const_iterator\n-      end() const { return const_iterator (_M_finish); }\n+      end() const { return const_iterator (this->_M_finish); }\n       \n       /**\n        *  Returns a read/write reverse iterator that points to the\n@@ -457,7 +461,7 @@ namespace std\n        */\n       size_type\n       capacity() const\n-      { return size_type(const_iterator(_M_end_of_storage) - begin()); }\n+      { return size_type(const_iterator(this->_M_end_of_storage) - begin()); }\n       \n       /**\n        *  Returns true if the %vector is empty.  (Thus begin() would\n@@ -594,10 +598,10 @@ namespace std\n       void\n       push_back(const value_type& __x)\n       {\n-\tif (_M_finish != _M_end_of_storage)\n+\tif (this->_M_finish != this->_M_end_of_storage)\n \t  {\n-\t    _Construct(_M_finish, __x);\n-\t    ++_M_finish;\n+\t    _Construct(this->_M_finish, __x);\n+\t    ++this->_M_finish;\n \t  }\n \telse\n \t  _M_insert_aux(end(), __x);\n@@ -614,8 +618,8 @@ namespace std\n       void\n       pop_back()\n       {\n-\t--_M_finish;\n-\t_Destroy(_M_finish);\n+\t--this->_M_finish;\n+\t_Destroy(this->_M_finish);\n       }\n       \n       /**\n@@ -723,9 +727,9 @@ namespace std\n       void\n       swap(vector& __x)\n       {\n-\tstd::swap(_M_start, __x._M_start);\n-\tstd::swap(_M_finish, __x._M_finish);\n-\tstd::swap(_M_end_of_storage, __x._M_end_of_storage);\n+\tstd::swap(this->_M_start, __x._M_start);\n+\tstd::swap(this->_M_finish, __x._M_finish);\n+\tstd::swap(this->_M_end_of_storage, __x._M_end_of_storage);\n       }\n       \n       /**\n@@ -770,9 +774,9 @@ namespace std\n         void\n         _M_initialize_dispatch(_Integer __n, _Integer __value, __true_type)\n         {\n-\t  _M_start = _M_allocate(__n);\n-\t  _M_end_of_storage = _M_start + __n;\n-\t  _M_finish = uninitialized_fill_n(_M_start, __n, __value);\n+\t  this->_M_start = _M_allocate(__n);\n+\t  this->_M_end_of_storage = this->_M_start + __n;\n+\t  this->_M_finish = uninitialized_fill_n(this->_M_start, __n, __value);\n \t}\n       \n       // Called by the range constructor to implement [23.1.1]/9\n@@ -803,9 +807,10 @@ namespace std\n \t\t\t    _ForwardIterator __last, forward_iterator_tag)\n         {\n \t  size_type __n = std::distance(__first, __last);\n-\t  _M_start = _M_allocate(__n);\n-\t  _M_end_of_storage = _M_start + __n;\n-\t  _M_finish = uninitialized_copy(__first, __last, _M_start);\n+\t  this->_M_start = _M_allocate(__n);\n+\t  this->_M_end_of_storage = this->_M_start + __n;\n+\t  this->_M_finish = uninitialized_copy(__first, __last,\n+\t\t\t\t\t       this->_M_start);\n \t}\n       \n       "}, {"sha": "0b6724c91471d4299fb0687376b6549ceb58ebb3", "filename": "libstdc++-v3/include/bits/vector.tcc", "status": "modified", "additions": 87, "deletions": 67, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fbc5ae72379506e4344297591db49fceac3a799/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fvector.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fbc5ae72379506e4344297591db49fceac3a799/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fvector.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fvector.tcc?ref=8fbc5ae72379506e4344297591db49fceac3a799", "patch": "@@ -1,6 +1,6 @@\n // Vector implementation (out of line) -*- C++ -*-\n \n-// Copyright (C) 2001, 2002 Free Software Foundation, Inc.\n+// Copyright (C) 2001, 2002, 2003 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -73,12 +73,15 @@ namespace std\n       if (this->capacity() < __n)\n \t{\n \t  const size_type __old_size = size();\n-\t  pointer __tmp = _M_allocate_and_copy(__n, _M_start, _M_finish);\n-\t  _Destroy(_M_start, _M_finish);\n-\t  _M_deallocate(_M_start, _M_end_of_storage - _M_start);\n-\t  _M_start = __tmp;\n-\t  _M_finish = __tmp + __old_size;\n-\t  _M_end_of_storage = _M_start + __n;\n+\t  pointer __tmp = _M_allocate_and_copy(__n,\n+\t\t\t\t\t       this->_M_start,\n+\t\t\t\t\t       this->_M_finish);\n+\t  _Destroy(this->_M_start, this->_M_finish);\n+\t  _M_deallocate(this->_M_start,\n+\t\t\tthis->_M_end_of_storage - this->_M_start);\n+\t  this->_M_start = __tmp;\n+\t  this->_M_finish = __tmp + __old_size;\n+\t  this->_M_end_of_storage = this->_M_start + __n;\n \t}\n     }\n   \n@@ -88,10 +91,10 @@ namespace std\n     insert(iterator __position, const value_type& __x)\n     {\n       size_type __n = __position - begin();\n-      if (_M_finish != _M_end_of_storage && __position == end())\n+      if (this->_M_finish != this->_M_end_of_storage && __position == end())\n       {\n-        _Construct(_M_finish, __x);\n-        ++_M_finish;\n+        _Construct(this->_M_finish, __x);\n+        ++this->_M_finish;\n       }\n       else\n         _M_insert_aux(__position, __x);\n@@ -105,8 +108,8 @@ namespace std\n     {\n       if (__position + 1 != end())\n         copy(__position + 1, end(), __position);\n-      --_M_finish;\n-      _Destroy(_M_finish);\n+      --this->_M_finish;\n+      _Destroy(this->_M_finish);\n       return __position;\n     }\n   \n@@ -117,7 +120,7 @@ namespace std\n     {\n       iterator __i(copy(__last, end(), __first));\n       _Destroy(__i, end());\n-      _M_finish = _M_finish - (__last - __first);\n+      this->_M_finish = this->_M_finish - (__last - __first);\n       return __first;\n     }\n   \n@@ -132,10 +135,11 @@ namespace std\n         if (__xlen > capacity())\n         {\n           pointer __tmp = _M_allocate_and_copy(__xlen, __x.begin(), __x.end());\n-          _Destroy(_M_start, _M_finish);\n-          _M_deallocate(_M_start, _M_end_of_storage - _M_start);\n-          _M_start = __tmp;\n-          _M_end_of_storage = _M_start + __xlen;\n+          _Destroy(this->_M_start, this->_M_finish);\n+          _M_deallocate(this->_M_start,\n+\t\t\tthis->_M_end_of_storage - this->_M_start);\n+          this->_M_start = __tmp;\n+          this->_M_end_of_storage = this->_M_start + __xlen;\n         }\n         else if (size() >= __xlen)\n         {\n@@ -144,10 +148,10 @@ namespace std\n         }\n         else\n         {\n-          copy(__x.begin(), __x.begin() + size(), _M_start);\n-          uninitialized_copy(__x.begin() + size(), __x.end(), _M_finish);\n+          copy(__x.begin(), __x.begin() + size(), this->_M_start);\n+          uninitialized_copy(__x.begin() + size(), __x.end(), this->_M_finish);\n         }\n-        _M_finish = _M_start + __xlen;\n+        this->_M_finish = this->_M_start + __xlen;\n       }\n       return *this;\n     }\n@@ -165,7 +169,8 @@ namespace std\n       else if (__n > size())\n       {\n         fill(begin(), end(), __val);\n-        _M_finish = uninitialized_fill_n(_M_finish, __n - size(), __val);\n+        this->_M_finish\n+\t  = uninitialized_fill_n(this->_M_finish, __n - size(), __val);\n       }\n       else\n         erase(fill_n(begin(), __n, __val), end());\n@@ -196,23 +201,24 @@ namespace std\n       if (__len > capacity())\n       {\n         pointer __tmp(_M_allocate_and_copy(__len, __first, __last));\n-        _Destroy(_M_start, _M_finish);\n-        _M_deallocate(_M_start, _M_end_of_storage - _M_start);\n-        _M_start = __tmp;\n-        _M_end_of_storage = _M_finish = _M_start + __len;\n+        _Destroy(this->_M_start, this->_M_finish);\n+        _M_deallocate(this->_M_start,\n+\t\t      this->_M_end_of_storage - this->_M_start);\n+        this->_M_start = __tmp;\n+        this->_M_end_of_storage = this->_M_finish = this->_M_start + __len;\n       }\n       else if (size() >= __len)\n       {\n-        iterator __new_finish(copy(__first, __last, _M_start));\n+        iterator __new_finish(copy(__first, __last, this->_M_start));\n         _Destroy(__new_finish, end());\n-        _M_finish = __new_finish.base();\n+        this->_M_finish = __new_finish.base();\n       }\n       else\n       {\n         _ForwardIter __mid = __first;\n         advance(__mid, size());\n-        copy(__first, __mid, _M_start);\n-        _M_finish = uninitialized_copy(__mid, __last, _M_finish);\n+        copy(__first, __mid, this->_M_start);\n+        this->_M_finish = uninitialized_copy(__mid, __last, this->_M_finish);\n       }\n     }\n   \n@@ -221,12 +227,14 @@ namespace std\n     vector<_Tp,_Alloc>::\n     _M_insert_aux(iterator __position, const _Tp& __x)\n     {\n-      if (_M_finish != _M_end_of_storage)\n+      if (this->_M_finish != this->_M_end_of_storage)\n       {\n-        _Construct(_M_finish, *(_M_finish - 1));\n-        ++_M_finish;\n+        _Construct(this->_M_finish, *(this->_M_finish - 1));\n+        ++this->_M_finish;\n         _Tp __x_copy = __x;\n-        copy_backward(__position, iterator(_M_finish-2), iterator(_M_finish-1));\n+        copy_backward(__position,\n+\t\t      iterator(this->_M_finish-2),\n+\t\t      iterator(this->_M_finish-1));\n         *__position = __x_copy;\n       }\n       else\n@@ -237,11 +245,13 @@ namespace std\n         iterator __new_finish(__new_start);\n         try\n           {\n-            __new_finish = uninitialized_copy(iterator(_M_start), __position,\n+            __new_finish = uninitialized_copy(iterator(this->_M_start),\n+\t\t\t\t\t      __position,\n                                               __new_start);\n             _Construct(__new_finish.base(), __x);\n             ++__new_finish;\n-            __new_finish = uninitialized_copy(__position, iterator(_M_finish),\n+            __new_finish = uninitialized_copy(__position,\n+\t\t\t\t\t      iterator(this->_M_finish),\n                                               __new_finish);\n           }\n         catch(...)\n@@ -251,10 +261,11 @@ namespace std\n             __throw_exception_again;\n           }\n         _Destroy(begin(), end());\n-        _M_deallocate(_M_start, _M_end_of_storage - _M_start);\n-        _M_start = __new_start.base();\n-        _M_finish = __new_finish.base();\n-        _M_end_of_storage = __new_start.base() + __len;\n+        _M_deallocate(this->_M_start,\n+\t\t      this->_M_end_of_storage - this->_M_start);\n+        this->_M_start = __new_start.base();\n+        this->_M_finish = __new_finish.base();\n+        this->_M_end_of_storage = __new_start.base() + __len;\n       }\n     }\n   \n@@ -309,24 +320,28 @@ namespace std\n     {\n       if (__n != 0)\n       {\n-        if (size_type(_M_end_of_storage - _M_finish) >= __n) \n+        if (size_type(this->_M_end_of_storage - this->_M_finish) >= __n) \n \t  {\n            value_type __x_copy = __x;\n \t   const size_type __elems_after = end() - __position;\n-\t   iterator __old_finish(_M_finish);\n+\t   iterator __old_finish(this->_M_finish);\n \t   if (__elems_after > __n)\n \t     {\n-\t       uninitialized_copy(_M_finish - __n, _M_finish, _M_finish);\n-\t       _M_finish += __n;\n+\t       uninitialized_copy(this->_M_finish - __n,\n+\t\t\t\t  this->_M_finish,\n+\t\t\t\t  this->_M_finish);\n+\t       this->_M_finish += __n;\n \t       copy_backward(__position, __old_finish - __n, __old_finish);\n \t       fill(__position, __position + __n, __x_copy);\n \t     }\n \t   else\n \t     {\n-\t       uninitialized_fill_n(_M_finish, __n - __elems_after, __x_copy);\n-\t       _M_finish += __n - __elems_after;\n-\t       uninitialized_copy(__position, __old_finish, _M_finish);\n-\t       _M_finish += __elems_after;\n+\t       uninitialized_fill_n(this->_M_finish,\n+\t\t\t\t    __n - __elems_after,\n+\t\t\t\t    __x_copy);\n+\t       this->_M_finish += __n - __elems_after;\n+\t       uninitialized_copy(__position, __old_finish, this->_M_finish);\n+\t       this->_M_finish += __elems_after;\n \t       fill(__position, __old_finish, __x_copy);\n \t     }\n \t  }\n@@ -350,11 +365,12 @@ namespace std\n \t\t_M_deallocate(__new_start.base(),__len);\n \t\t__throw_exception_again;\n \t      }\n-\t    _Destroy(_M_start, _M_finish);\n-\t    _M_deallocate(_M_start, _M_end_of_storage - _M_start);\n-\t    _M_start = __new_start.base();\n-\t    _M_finish = __new_finish.base();\n-\t    _M_end_of_storage = __new_start.base() + __len;\n+\t    _Destroy(this->_M_start, this->_M_finish);\n+\t    _M_deallocate(this->_M_start,\n+\t\t\t  this->_M_end_of_storage - this->_M_start);\n+\t    this->_M_start = __new_start.base();\n+\t    this->_M_finish = __new_finish.base();\n+\t    this->_M_end_of_storage = __new_start.base() + __len;\n \t  }\n       }\n     }\n@@ -382,25 +398,27 @@ namespace std\n       if (__first != __last)\n       {\n         size_type __n = std::distance(__first, __last);\n-        if (size_type(_M_end_of_storage - _M_finish) >= __n)\n+        if (size_type(this->_M_end_of_storage - this->_M_finish) >= __n)\n         {\n           const size_type __elems_after = end() - __position;\n-          iterator __old_finish(_M_finish);\n+          iterator __old_finish(this->_M_finish);\n           if (__elems_after > __n)\n           {\n-            uninitialized_copy(_M_finish - __n, _M_finish, _M_finish);\n-            _M_finish += __n;\n+            uninitialized_copy(this->_M_finish - __n,\n+\t\t\t       this->_M_finish,\n+\t\t\t       this->_M_finish);\n+            this->_M_finish += __n;\n             copy_backward(__position, __old_finish - __n, __old_finish);\n             copy(__first, __last, __position);\n           }\n           else\n           {\n             _ForwardIterator __mid = __first;\n             advance(__mid, __elems_after);\n-            uninitialized_copy(__mid, __last, _M_finish);\n-            _M_finish += __n - __elems_after;\n-            uninitialized_copy(__position, __old_finish, _M_finish);\n-            _M_finish += __elems_after;\n+            uninitialized_copy(__mid, __last, this->_M_finish);\n+            this->_M_finish += __n - __elems_after;\n+            uninitialized_copy(__position, __old_finish, this->_M_finish);\n+            this->_M_finish += __elems_after;\n             copy(__first, __mid, __position);\n           }\n         }\n@@ -412,10 +430,11 @@ namespace std\n           iterator __new_finish(__new_start);\n           try\n             {\n-              __new_finish = uninitialized_copy(iterator(_M_start),\n+              __new_finish = uninitialized_copy(iterator(this->_M_start),\n                                                 __position, __new_start);\n               __new_finish = uninitialized_copy(__first, __last, __new_finish);\n-              __new_finish = uninitialized_copy(__position, iterator(_M_finish),\n+              __new_finish = uninitialized_copy(__position,\n+\t\t\t\t\t\titerator(this->_M_finish),\n                                                 __new_finish);\n             }\n           catch(...)\n@@ -424,11 +443,12 @@ namespace std\n               _M_deallocate(__new_start.base(), __len);\n               __throw_exception_again;\n             }\n-          _Destroy(_M_start, _M_finish);\n-          _M_deallocate(_M_start, _M_end_of_storage - _M_start);\n-          _M_start = __new_start.base();\n-          _M_finish = __new_finish.base();\n-          _M_end_of_storage = __new_start.base() + __len;\n+          _Destroy(this->_M_start, this->_M_finish);\n+          _M_deallocate(this->_M_start,\n+\t\t\tthis->_M_end_of_storage - this->_M_start);\n+          this->_M_start = __new_start.base();\n+          this->_M_finish = __new_finish.base();\n+          this->_M_end_of_storage = __new_start.base() + __len;\n         }\n       }\n     }"}, {"sha": "91bd5e0fc9e1fcb298f4724ea4b2677de0216cc9", "filename": "libstdc++-v3/include/ext/ropeimpl.h", "status": "modified", "additions": 23, "deletions": 21, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fbc5ae72379506e4344297591db49fceac3a799/libstdc%2B%2B-v3%2Finclude%2Fext%2Fropeimpl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fbc5ae72379506e4344297591db49fceac3a799/libstdc%2B%2B-v3%2Finclude%2Fext%2Fropeimpl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fropeimpl.h?ref=8fbc5ae72379506e4344297591db49fceac3a799", "patch": "@@ -1,6 +1,6 @@\n // SGI's rope class implementation -*- C++ -*-\n \n-// Copyright (C) 2001, 2002 Free Software Foundation, Inc.\n+// Copyright (C) 2001, 2002, 2003 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -278,12 +278,12 @@ void _Rope_iterator_base<_CharT,_Alloc>::_M_decr(size_t __n) {\n \n template <class _CharT, class _Alloc>\n void _Rope_iterator<_CharT,_Alloc>::_M_check() {\n-    if (_M_root_rope->_M_tree_ptr != _M_root) {\n+    if (_M_root_rope->_M_tree_ptr != this->_M_root) {\n         // _Rope was modified.  Get things fixed up.\n-        _RopeRep::_S_unref(_M_root);\n-        _M_root = _M_root_rope->_M_tree_ptr;\n-        _RopeRep::_S_ref(_M_root);\n-        _M_buf_ptr = 0;\n+        _RopeRep::_S_unref(this->_M_root);\n+        this->_M_root = _M_root_rope->_M_tree_ptr;\n+        _RopeRep::_S_ref(this->_M_root);\n+        this->_M_buf_ptr = 0;\n     }\n }\n \n@@ -300,7 +300,7 @@ inline _Rope_iterator<_CharT,_Alloc>::_Rope_iterator(\n : _Rope_iterator_base<_CharT,_Alloc>(__r._M_tree_ptr, __pos), \n   _M_root_rope(&__r)\n {\n-    _RopeRep::_S_ref(_M_root);\n+    _RopeRep::_S_ref(this->_M_root);\n }\n \n template <class _CharT, class _Alloc>\n@@ -321,7 +321,7 @@ inline void _Rope_RopeRep<_CharT,_Alloc>::_M_free_c_string()\n {\n     _CharT* __cstr = _M_c_string;\n     if (0 != __cstr) {\n-\tsize_t __size = _M_size + 1;\n+\tsize_t __size = this->_M_size + 1;\n \t_Destroy(__cstr, __cstr + __size);\n \t_Data_deallocate(__cstr, __size);\n     }\n@@ -960,7 +960,7 @@ size_t\n rope<_CharT,_Alloc>::find(_CharT __pattern, size_t __start) const\n {\n     _Rope_find_char_char_consumer<_CharT> __c(__pattern);\n-    _S_apply_to_pieces(__c, _M_tree_ptr, __start, size());\n+    _S_apply_to_pieces(__c, this->_M_tree_ptr, __start, size());\n     size_type __result_pos = __start + __c._M_count;\n #   ifndef __STL_OLD_ROPE_SEMANTICS\n \tif (__result_pos == size()) __result_pos = npos;\n@@ -1436,31 +1436,32 @@ rope<_CharT, _Alloc>::rope(size_t __n, _CharT __c,\n     } else {\n \t__result = __remainder_rope;\n     }\n-    _M_tree_ptr = __result._M_tree_ptr;\n-    _M_tree_ptr->_M_ref_nonnil();\n+    this->_M_tree_ptr = __result._M_tree_ptr;\n+    this->_M_tree_ptr->_M_ref_nonnil();\n }\n \n template<class _CharT, class _Alloc>\n   _CharT rope<_CharT,_Alloc>::_S_empty_c_str[1];\n \n template<class _CharT, class _Alloc>\n const _CharT* rope<_CharT,_Alloc>::c_str() const {\n-    if (0 == _M_tree_ptr) {\n+    if (0 == this->_M_tree_ptr) {\n         _S_empty_c_str[0] = _S_eos((_CharT*)0);  // Possibly redundant,\n \t\t\t\t\t     // but probably fast.\n         return _S_empty_c_str;\n     }\n-    __GC_CONST _CharT* __old_c_string = _M_tree_ptr->_M_c_string;\n+    __GC_CONST _CharT* __old_c_string = this->_M_tree_ptr->_M_c_string;\n     if (0 != __old_c_string) return(__old_c_string);\n     size_t __s = size();\n     _CharT* __result = _Data_allocate(__s + 1);\n-    _S_flatten(_M_tree_ptr, __result);\n+    _S_flatten(this->_M_tree_ptr, __result);\n     __result[__s] = _S_eos((_CharT*)0);\n #   ifdef __GC\n \t_M_tree_ptr->_M_c_string = __result;\n #   else\n       if ((__old_c_string = (__GC_CONST _CharT*)\n-             std::_Atomic_swap((unsigned long *)(&(_M_tree_ptr->_M_c_string)),\n+             std::_Atomic_swap((unsigned long *)\n+\t\t\t       (&(this->_M_tree_ptr->_M_c_string)),\n \t\t\t  (unsigned long)__result)) != 0) {\n \t// It must have been added in the interim.  Hence it had to have been\n \t// separately allocated.  Deallocate the old copy, since we just\n@@ -1474,20 +1475,21 @@ const _CharT* rope<_CharT,_Alloc>::c_str() const {\n \n template<class _CharT, class _Alloc>\n const _CharT* rope<_CharT,_Alloc>::replace_with_c_str() {\n-    if (0 == _M_tree_ptr) {\n+    if (0 == this->_M_tree_ptr) {\n         _S_empty_c_str[0] = _S_eos((_CharT*)0);\n         return _S_empty_c_str;\n     }\n-    __GC_CONST _CharT* __old_c_string = _M_tree_ptr->_M_c_string;\n-    if (_RopeRep::_S_leaf == _M_tree_ptr->_M_tag && 0 != __old_c_string) {\n+    __GC_CONST _CharT* __old_c_string = this->_M_tree_ptr->_M_c_string;\n+    if (_RopeRep::_S_leaf == this->_M_tree_ptr->_M_tag\n+\t&& 0 != __old_c_string) {\n \treturn(__old_c_string);\n     }\n     size_t __s = size();\n     _CharT* __result = _Data_allocate(_S_rounded_up_size(__s));\n-    _S_flatten(_M_tree_ptr, __result);\n+    _S_flatten(this->_M_tree_ptr, __result);\n     __result[__s] = _S_eos((_CharT*)0);\n-    _M_tree_ptr->_M_unref_nonnil();\n-    _M_tree_ptr = _S_new_RopeLeaf(__result, __s, get_allocator());\n+    this->_M_tree_ptr->_M_unref_nonnil();\n+    this->_M_tree_ptr = _S_new_RopeLeaf(__result, __s, get_allocator());\n     return(__result);\n }\n "}, {"sha": "1fb40be2b493d60416aa137a043d843033af2f88", "filename": "libstdc++-v3/include/ext/stdio_filebuf.h", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fbc5ae72379506e4344297591db49fceac3a799/libstdc%2B%2B-v3%2Finclude%2Fext%2Fstdio_filebuf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fbc5ae72379506e4344297591db49fceac3a799/libstdc%2B%2B-v3%2Finclude%2Fext%2Fstdio_filebuf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fstdio_filebuf.h?ref=8fbc5ae72379506e4344297591db49fceac3a799", "patch": "@@ -1,6 +1,6 @@\n // File descriptor layer for filebuf -*- C++ -*-\n \n-// Copyright (C) 2002 Free Software Foundation, Inc.\n+// Copyright (C) 2002, 2003 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -107,7 +107,7 @@ namespace __gnu_cxx\n       */\n       int\n       fd()\n-      { return _M_file.fd(); }\n+      { return this->_M_file.fd(); }\n     };\n \n   template<typename _CharT, typename _Traits>\n@@ -119,20 +119,20 @@ namespace __gnu_cxx\n     stdio_filebuf(int __fd, std::ios_base::openmode __mode, bool __del, \n \t\t  int_type __size)\n     {\n-      _M_file.sys_open(__fd, __mode, __del);\n+      this->_M_file.sys_open(__fd, __mode, __del);\n       if (this->is_open())\n \t{\n-\t  _M_mode = __mode;\n+\t  this->_M_mode = __mode;\n \t  if (__size > 0 && __size < 4)\n \t    {\n \t      // Specify unbuffered.\n-\t      _M_buf = _M_unbuf;\n-\t      _M_buf_size = __size;\n-\t      _M_buf_size_opt = 0;\n+\t      this->_M_buf = _M_unbuf;\n+\t      this->_M_buf_size = __size;\n+\t      this->_M_buf_size_opt = 0;\n \t    }\n \t  else\n \t    {\n-\t      _M_buf_size_opt = __size;\n+\t      this->_M_buf_size_opt = __size;\n \t      _M_allocate_internal_buffer();\n \t    }\n \t  _M_set_indeterminate();\n@@ -144,20 +144,20 @@ namespace __gnu_cxx\n     stdio_filebuf(std::__c_file* __f, std::ios_base::openmode __mode, \n \t\t  int_type __size)\n     {\n-      _M_file.sys_open(__f, __mode);\n+      this->_M_file.sys_open(__f, __mode);\n       if (this->is_open())\n \t{\n-\t  _M_mode = __mode;\n+\t  this->_M_mode = __mode;\n \t  if (__size > 0 && __size < 4)\n \t    {\n \t      // Specify unbuffered.\n-\t      _M_buf = _M_unbuf;\n-\t      _M_buf_size = __size;\n-\t      _M_buf_size_opt = 0;\n+\t      this->_M_buf = _M_unbuf;\n+\t      this->_M_buf_size = __size;\n+\t      this->_M_buf_size_opt = 0;\n \t    }\n \t  else\n \t    {\n-\t      _M_buf_size_opt = __size;\n+\t      this->_M_buf_size_opt = __size;\n \t      _M_allocate_internal_buffer();\n \t    }\n \t  _M_set_indeterminate();"}, {"sha": "95c3c0c80fc8898b0e945635375a7acdee9120a7", "filename": "libstdc++-v3/include/ext/stl_rope.h", "status": "modified", "additions": 127, "deletions": 113, "changes": 240, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fbc5ae72379506e4344297591db49fceac3a799/libstdc%2B%2B-v3%2Finclude%2Fext%2Fstl_rope.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fbc5ae72379506e4344297591db49fceac3a799/libstdc%2B%2B-v3%2Finclude%2Fext%2Fstl_rope.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fstl_rope.h?ref=8fbc5ae72379506e4344297591db49fceac3a799", "patch": "@@ -1,6 +1,6 @@\n // SGI's rope implementation -*- C++ -*-\n \n-// Copyright (C) 2001, 2002 Free Software Foundation, Inc.\n+// Copyright (C) 2001, 2002, 2003 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -579,23 +579,24 @@ struct _Rope_RopeLeaf : public _Rope_RopeRep<_CharT,_Alloc> {\n     typedef typename _Rope_rep_base<_CharT,_Alloc>::allocator_type\n                         allocator_type;\n     _Rope_RopeLeaf(__GC_CONST _CharT* __d, size_t __size, allocator_type __a)\n-        : _Rope_RopeRep<_CharT,_Alloc>(_S_leaf, 0, true, __size, __a),\n+        : _Rope_RopeRep<_CharT,_Alloc>(_Rope_RopeRep<_CharT,_Alloc>::_S_leaf,\n+\t\t\t\t       0, true, __size, __a),\n           _M_data(__d)\n         {\n         if (_S_is_basic_char_type((_CharT *)0)) {\n             // already eos terminated.\n-            _M_c_string = __d;\n+            this->_M_c_string = __d;\n         }\n     }\n         // The constructor assumes that d has been allocated with\n         // the proper allocator and the properly padded size.\n         // In contrast, the destructor deallocates the data:\n # ifndef __GC\n     ~_Rope_RopeLeaf() {\n-        if (_M_data != _M_c_string) {\n+        if (_M_data != this->_M_c_string) {\n             _M_free_c_string();\n         }\n-        __STL_FREE_STRING(_M_data, _M_size, get_allocator());\n+        __STL_FREE_STRING(_M_data, this->_M_size, get_allocator());\n     }\n # endif\n };\n@@ -611,7 +612,7 @@ struct _Rope_RopeConcatenation : public _Rope_RopeRep<_CharT,_Alloc> {\n                              _Rope_RopeRep<_CharT,_Alloc>* __r,\n                              allocator_type __a)\n \n-      : _Rope_RopeRep<_CharT,_Alloc>(_S_concat,\n+      : _Rope_RopeRep<_CharT,_Alloc>(_Rope_RopeRep<_CharT,_Alloc>::_S_concat,\n                                      std::max(__l->_M_depth, __r->_M_depth) + 1,\n                                      false,\n                                      __l->_M_size + __r->_M_size, __a),\n@@ -649,7 +650,8 @@ struct _Rope_RopeFunction : public _Rope_RopeRep<_CharT,_Alloc> {\n                                         allocator_type;\n     _Rope_RopeFunction(char_producer<_CharT>* __f, size_t __size,\n                         bool __d, allocator_type __a)\n-      : _Rope_RopeRep<_CharT,_Alloc>(_S_function, 0, true, __size, __a)\n+      : _Rope_RopeRep<_CharT,_Alloc>(_Rope_RopeRep<_CharT,_Alloc>::_S_function,\n+\t\t\t\t     0, true, __size, __a)\n       , _M_fn(__f)\n #       ifndef __GC\n       , _M_delete_when_done(__d)\n@@ -688,15 +690,15 @@ struct _Rope_RopeSubstring : public _Rope_RopeFunction<_CharT,_Alloc>,\n     virtual void operator()(size_t __start_pos, size_t __req_len,\n                             _CharT* __buffer) {\n         switch(_M_base->_M_tag) {\n-            case _S_function:\n-            case _S_substringfn:\n+            case _Rope_RopeFunction<_CharT,_Alloc>::_S_function:\n+            case _Rope_RopeFunction<_CharT,_Alloc>::_S_substringfn:\n               {\n                 char_producer<_CharT>* __fn =\n                         ((_Rope_RopeFunction<_CharT,_Alloc>*)_M_base)->_M_fn;\n                 (*__fn)(__start_pos + _M_start, __req_len, __buffer);\n               }\n               break;\n-            case _S_leaf:\n+            case _Rope_RopeFunction<_CharT,_Alloc>::_S_leaf:\n               {\n                 __GC_CONST _CharT* __s =\n                         ((_Rope_RopeLeaf<_CharT,_Alloc>*)_M_base)->_M_data;\n@@ -720,7 +722,7 @@ struct _Rope_RopeSubstring : public _Rope_RopeFunction<_CharT,_Alloc>,\n #       ifndef __GC\n             _M_base->_M_ref_nonnil();\n #       endif\n-        _M_tag = _S_substringfn;\n+        this->_M_tag = _Rope_RopeFunction<_CharT,_Alloc>::_S_substringfn;\n     }\n     virtual ~_Rope_RopeSubstring()\n       { \n@@ -948,21 +950,22 @@ class _Rope_const_iterator : public _Rope_iterator_base<_CharT,_Alloc> {\n         if (0 != __x._M_buf_ptr) {\n             *(static_cast<_Rope_iterator_base<_CharT,_Alloc>*>(this)) = __x;\n         } else {\n-            _M_current_pos = __x._M_current_pos;\n-            _M_root = __x._M_root;\n-            _M_buf_ptr = 0;\n+            this->_M_current_pos = __x._M_current_pos;\n+            this->_M_root = __x._M_root;\n+            this->_M_buf_ptr = 0;\n         }\n         return(*this);\n     }\n     reference operator*() {\n-        if (0 == _M_buf_ptr) _S_setcache(*this);\n-        return *_M_buf_ptr;\n+        if (0 == this->_M_buf_ptr) _S_setcache(*this);\n+        return *this->_M_buf_ptr;\n     }\n     _Rope_const_iterator& operator++() {\n         __GC_CONST _CharT* __next;\n-        if (0 != _M_buf_ptr && (__next = _M_buf_ptr + 1) < _M_buf_end) {\n-            _M_buf_ptr = __next;\n-            ++_M_current_pos;\n+        if (0 != this->_M_buf_ptr\n+\t    && (__next = this->_M_buf_ptr + 1) < this->_M_buf_end) {\n+            this->_M_buf_ptr = __next;\n+            ++this->_M_current_pos;\n         } else {\n             _M_incr(1);\n         }\n@@ -989,17 +992,17 @@ class _Rope_const_iterator : public _Rope_iterator_base<_CharT,_Alloc> {\n         return *this;\n     }\n     _Rope_const_iterator operator++(int) {\n-        size_t __old_pos = _M_current_pos;\n+        size_t __old_pos = this->_M_current_pos;\n         _M_incr(1);\n-        return _Rope_const_iterator<_CharT,_Alloc>(_M_root, __old_pos);\n+        return _Rope_const_iterator<_CharT,_Alloc>(this->_M_root, __old_pos);\n         // This makes a subsequent dereference expensive.\n         // Perhaps we should instead copy the iterator\n         // if it has a valid cache?\n     }\n     _Rope_const_iterator operator--(int) {\n-        size_t __old_pos = _M_current_pos;\n+        size_t __old_pos = this->_M_current_pos;\n         _M_decr(1);\n-        return _Rope_const_iterator<_CharT,_Alloc>(_M_root, __old_pos);\n+        return _Rope_const_iterator<_CharT,_Alloc>(this->_M_root, __old_pos);\n     }\n     template<class _CharT2, class _Alloc2>\n     friend _Rope_const_iterator<_CharT2,_Alloc2> operator-\n@@ -1014,7 +1017,8 @@ class _Rope_const_iterator : public _Rope_iterator_base<_CharT,_Alloc> {\n         (ptrdiff_t __n,\n          const _Rope_const_iterator<_CharT2,_Alloc2>& __x);\n     reference operator[](size_t __n) {\n-        return rope<_CharT,_Alloc>::_S_fetch(_M_root, _M_current_pos + __n);\n+        return rope<_CharT,_Alloc>::_S_fetch(this->_M_root,\n+\t\t\t\t\t     this->_M_current_pos + __n);\n     }\n \n     template<class _CharT2, class _Alloc2>\n@@ -1047,7 +1051,8 @@ class _Rope_iterator : public _Rope_iterator_base<_CharT,_Alloc> {\n     _Rope_iterator(rope<_CharT,_Alloc>* __r, size_t __pos)\n       : _Rope_iterator_base<_CharT,_Alloc>(__r->_M_tree_ptr, __pos),\n         _M_root_rope(__r) \n-       { _RopeRep::_S_ref(_M_root); if (!(__r -> empty()))_S_setcache(*this); }\n+      { _RopeRep::_S_ref(this->_M_root);\n+        if (!(__r -> empty()))_S_setcache(*this); }\n \n     void _M_check();\n   public:\n@@ -1057,41 +1062,41 @@ class _Rope_iterator : public _Rope_iterator_base<_CharT,_Alloc> {\n   public:\n     rope<_CharT,_Alloc>& container() { return *_M_root_rope; }\n     _Rope_iterator() {\n-        _M_root = 0;  // Needed for reference counting.\n+        this->_M_root = 0;  // Needed for reference counting.\n     };\n     _Rope_iterator(const _Rope_iterator& __x) :\n         _Rope_iterator_base<_CharT,_Alloc>(__x) {\n         _M_root_rope = __x._M_root_rope;\n-        _RopeRep::_S_ref(_M_root);\n+        _RopeRep::_S_ref(this->_M_root);\n     }\n     _Rope_iterator(rope<_CharT,_Alloc>& __r, size_t __pos);\n     ~_Rope_iterator() {\n-        _RopeRep::_S_unref(_M_root);\n+        _RopeRep::_S_unref(this->_M_root);\n     }\n     _Rope_iterator& operator= (const _Rope_iterator& __x) {\n-        _RopeRep* __old = _M_root;\n+        _RopeRep* __old = this->_M_root;\n \n         _RopeRep::_S_ref(__x._M_root);\n         if (0 != __x._M_buf_ptr) {\n             _M_root_rope = __x._M_root_rope;\n             *(static_cast<_Rope_iterator_base<_CharT,_Alloc>*>(this)) = __x;\n         } else {\n-            _M_current_pos = __x._M_current_pos;\n-            _M_root = __x._M_root;\n+\t    this->_M_current_pos = __x._M_current_pos;\n+            this->_M_root = __x._M_root;\n             _M_root_rope = __x._M_root_rope;\n-            _M_buf_ptr = 0;\n+            this->_M_buf_ptr = 0;\n         }\n         _RopeRep::_S_unref(__old);\n         return(*this);\n     }\n     reference operator*() {\n         _M_check();\n-        if (0 == _M_buf_ptr) {\n+        if (0 == this->_M_buf_ptr) {\n             return _Rope_char_ref_proxy<_CharT,_Alloc>(\n-               _M_root_rope, _M_current_pos);\n+               _M_root_rope, this->_M_current_pos);\n         } else {\n             return _Rope_char_ref_proxy<_CharT,_Alloc>(\n-               _M_root_rope, _M_current_pos, *_M_buf_ptr);\n+               _M_root_rope, this->_M_current_pos, *this->_M_buf_ptr);\n         }\n     }\n     _Rope_iterator& operator++() {\n@@ -1119,18 +1124,18 @@ class _Rope_iterator : public _Rope_iterator_base<_CharT,_Alloc> {\n         return *this;\n     }\n     _Rope_iterator operator++(int) {\n-        size_t __old_pos = _M_current_pos;\n+        size_t __old_pos = this->_M_current_pos;\n         _M_incr(1);\n         return _Rope_iterator<_CharT,_Alloc>(_M_root_rope, __old_pos);\n     }\n     _Rope_iterator operator--(int) {\n-        size_t __old_pos = _M_current_pos;\n+        size_t __old_pos = this->_M_current_pos;\n         _M_decr(1);\n         return _Rope_iterator<_CharT,_Alloc>(_M_root_rope, __old_pos);\n     }\n     reference operator[](ptrdiff_t __n) {\n         return _Rope_char_ref_proxy<_CharT,_Alloc>(\n-          _M_root_rope, _M_current_pos + __n);\n+          _M_root_rope, this->_M_current_pos + __n);\n     }\n \n     template<class _CharT2, class _Alloc2>\n@@ -1352,7 +1357,7 @@ class rope : public _Rope_base<_CharT,_Alloc> {\n    public:\n         void apply_to_pieces( size_t __begin, size_t __end,\n                               _Rope_char_consumer<_CharT>& __c) const {\n-            _S_apply_to_pieces(__c, _M_tree_ptr, __begin, __end);\n+            _S_apply_to_pieces(__c, this->_M_tree_ptr, __begin, __end);\n         }\n \n \n@@ -1510,13 +1515,13 @@ class rope : public _Rope_base<_CharT,_Alloc> {\n         static int _S_compare(const _RopeRep* __x, const _RopeRep* __y);\n \n    public:\n-        bool empty() const { return 0 == _M_tree_ptr; }\n+        bool empty() const { return 0 == this->_M_tree_ptr; }\n \n         // Comparison member function.  This is public only for those\n         // clients that need a ternary comparison.  Others\n         // should use the comparison operators below.\n         int compare(const rope& __y) const {\n-            return _S_compare(_M_tree_ptr, __y._M_tree_ptr);\n+            return _S_compare(this->_M_tree_ptr, __y._M_tree_ptr);\n         }\n \n         rope(const _CharT* __s, const allocator_type& __a = allocator_type())\n@@ -1556,7 +1561,7 @@ class rope : public _Rope_base<_CharT,_Alloc> {\n \n             std::_Construct(__buf, __c);\n             try {\n-                _M_tree_ptr = _S_new_RopeLeaf(__buf, 1, __a);\n+                this->_M_tree_ptr = _S_new_RopeLeaf(__buf, 1, __a);\n             }\n             catch(...)\n \t      {\n@@ -1576,63 +1581,66 @@ class rope : public _Rope_base<_CharT,_Alloc> {\n              const allocator_type& __a = allocator_type())\n             : _Base(__a)\n         {\n-            _M_tree_ptr = (0 == __len) ?\n+            this->_M_tree_ptr = (0 == __len) ?\n                0 : _S_new_RopeFunction(__fn, __len, __delete_fn, __a);\n         }\n \n         rope(const rope& __x, const allocator_type& __a = allocator_type())\n         : _Base(__x._M_tree_ptr, __a)\n         {\n-            _S_ref(_M_tree_ptr);\n+            _S_ref(this->_M_tree_ptr);\n         }\n \n         ~rope()\n         {\n-            _S_unref(_M_tree_ptr);\n+            _S_unref(this->_M_tree_ptr);\n         }\n \n         rope& operator=(const rope& __x)\n         {\n-            _RopeRep* __old = _M_tree_ptr;\n-            _M_tree_ptr = __x._M_tree_ptr;\n-            _S_ref(_M_tree_ptr);\n+            _RopeRep* __old = this->_M_tree_ptr;\n+            this->_M_tree_ptr = __x._M_tree_ptr;\n+            _S_ref(this->_M_tree_ptr);\n             _S_unref(__old);\n             return(*this);\n         }\n \n         void clear()\n         {\n-            _S_unref(_M_tree_ptr);\n-            _M_tree_ptr = 0;\n+            _S_unref(this->_M_tree_ptr);\n+            this->_M_tree_ptr = 0;\n         }\n \n         void push_back(_CharT __x)\n         {\n-            _RopeRep* __old = _M_tree_ptr;\n-            _M_tree_ptr = _S_destr_concat_char_iter(_M_tree_ptr, &__x, 1);\n+            _RopeRep* __old = this->_M_tree_ptr;\n+            this->_M_tree_ptr\n+\t      = _S_destr_concat_char_iter(this->_M_tree_ptr, &__x, 1);\n             _S_unref(__old);\n         }\n \n         void pop_back()\n         {\n-            _RopeRep* __old = _M_tree_ptr;\n-            _M_tree_ptr = \n-              _S_substring(_M_tree_ptr, 0, _M_tree_ptr->_M_size - 1);\n+            _RopeRep* __old = this->_M_tree_ptr;\n+            this->_M_tree_ptr = \n+              _S_substring(this->_M_tree_ptr,\n+\t\t\t   0,\n+\t\t\t   this->_M_tree_ptr->_M_size - 1);\n             _S_unref(__old);\n         }\n \n         _CharT back() const\n         {\n-            return _S_fetch(_M_tree_ptr, _M_tree_ptr->_M_size - 1);\n+            return _S_fetch(this->_M_tree_ptr, this->_M_tree_ptr->_M_size - 1);\n         }\n \n         void push_front(_CharT __x)\n         {\n-            _RopeRep* __old = _M_tree_ptr;\n+            _RopeRep* __old = this->_M_tree_ptr;\n             _RopeRep* __left =\n               __STL_ROPE_FROM_UNOWNED_CHAR_PTR(&__x, 1, get_allocator());\n             try {\n-              _M_tree_ptr = _S_concat(__left, _M_tree_ptr);\n+              this->_M_tree_ptr = _S_concat(__left, this->_M_tree_ptr);\n               _S_unref(__old);\n               _S_unref(__left);\n             }\n@@ -1645,26 +1653,27 @@ class rope : public _Rope_base<_CharT,_Alloc> {\n \n         void pop_front()\n         {\n-            _RopeRep* __old = _M_tree_ptr;\n-            _M_tree_ptr = _S_substring(_M_tree_ptr, 1, _M_tree_ptr->_M_size);\n+            _RopeRep* __old = this->_M_tree_ptr;\n+            this->_M_tree_ptr\n+\t      = _S_substring(this->_M_tree_ptr, 1, this->_M_tree_ptr->_M_size);\n             _S_unref(__old);\n         }\n \n         _CharT front() const\n         {\n-            return _S_fetch(_M_tree_ptr, 0);\n+            return _S_fetch(this->_M_tree_ptr, 0);\n         }\n \n         void balance()\n         {\n-            _RopeRep* __old = _M_tree_ptr;\n-            _M_tree_ptr = _S_balance(_M_tree_ptr);\n+            _RopeRep* __old = this->_M_tree_ptr;\n+            this->_M_tree_ptr = _S_balance(this->_M_tree_ptr);\n             _S_unref(__old);\n         }\n \n         void copy(_CharT* __buffer) const {\n             _Destroy(__buffer, __buffer + size());\n-            _S_flatten(_M_tree_ptr, __buffer);\n+            _S_flatten(this->_M_tree_ptr, __buffer);\n         }\n \n         // This is the copy function from the standard, but\n@@ -1678,14 +1687,14 @@ class rope : public _Rope_base<_CharT,_Alloc> {\n             size_t __len = (__pos + __n > __size? __size - __pos : __n);\n \n             _Destroy(__buffer, __buffer + __len);\n-            _S_flatten(_M_tree_ptr, __pos, __len, __buffer);\n+            _S_flatten(this->_M_tree_ptr, __pos, __len, __buffer);\n             return __len;\n         }\n \n         // Print to stdout, exposing structure.  May be useful for\n         // performance debugging.\n         void dump() {\n-            _S_dump(_M_tree_ptr);\n+            _S_dump(this->_M_tree_ptr);\n         }\n \n         // Convert to 0 terminated string in new allocated memory.\n@@ -1700,21 +1709,21 @@ class rope : public _Rope_base<_CharT,_Alloc> {\n         // Intentionally undocumented, since it's hard to say when this\n         // is safe for multiple threads.\n         void delete_c_str () {\n-            if (0 == _M_tree_ptr) return;\n-            if (_RopeRep::_S_leaf == _M_tree_ptr->_M_tag && \n-                ((_RopeLeaf*)_M_tree_ptr)->_M_data == \n-                      _M_tree_ptr->_M_c_string) {\n+            if (0 == this->_M_tree_ptr) return;\n+            if (_RopeRep::_S_leaf == this->_M_tree_ptr->_M_tag && \n+                ((_RopeLeaf*)this->_M_tree_ptr)->_M_data == \n+                      this->_M_tree_ptr->_M_c_string) {\n                 // Representation shared\n                 return;\n             }\n #           ifndef __GC\n-              _M_tree_ptr->_M_free_c_string();\n+              this->_M_tree_ptr->_M_free_c_string();\n #           endif\n-            _M_tree_ptr->_M_c_string = 0;\n+            this->_M_tree_ptr->_M_c_string = 0;\n         }\n \n         _CharT operator[] (size_type __pos) const {\n-            return _S_fetch(_M_tree_ptr, __pos);\n+            return _S_fetch(this->_M_tree_ptr, __pos);\n         }\n \n         _CharT at(size_type __pos) const {\n@@ -1723,24 +1732,24 @@ class rope : public _Rope_base<_CharT,_Alloc> {\n         }\n \n         const_iterator begin() const {\n-            return(const_iterator(_M_tree_ptr, 0));\n+            return(const_iterator(this->_M_tree_ptr, 0));\n         }\n \n         // An easy way to get a const iterator from a non-const container.\n         const_iterator const_begin() const {\n-            return(const_iterator(_M_tree_ptr, 0));\n+            return(const_iterator(this->_M_tree_ptr, 0));\n         }\n \n         const_iterator end() const {\n-            return(const_iterator(_M_tree_ptr, size()));\n+            return(const_iterator(this->_M_tree_ptr, size()));\n         }\n \n         const_iterator const_end() const {\n-            return(const_iterator(_M_tree_ptr, size()));\n+            return(const_iterator(this->_M_tree_ptr, size()));\n         }\n \n         size_type size() const { \n-            return(0 == _M_tree_ptr? 0 : _M_tree_ptr->_M_size);\n+            return(0 == this->_M_tree_ptr? 0 : this->_M_tree_ptr->_M_size);\n         }\n \n         size_type length() const {\n@@ -1793,9 +1802,9 @@ class rope : public _Rope_base<_CharT,_Alloc> {\n         // forward iterator with value_type _CharT.\n         rope& append(const _CharT* __iter, size_t __n) {\n             _RopeRep* __result = \n-              _S_destr_concat_char_iter(_M_tree_ptr, __iter, __n);\n-            _S_unref(_M_tree_ptr);\n-            _M_tree_ptr = __result;\n+              _S_destr_concat_char_iter(this->_M_tree_ptr, __iter, __n);\n+            _S_unref(this->_M_tree_ptr);\n+            this->_M_tree_ptr = __result;\n             return *this;\n         }\n \n@@ -1807,36 +1816,36 @@ class rope : public _Rope_base<_CharT,_Alloc> {\n \n         rope& append(const _CharT* __s, const _CharT* __e) {\n             _RopeRep* __result =\n-                _S_destr_concat_char_iter(_M_tree_ptr, __s, __e - __s);\n-            _S_unref(_M_tree_ptr);\n-            _M_tree_ptr = __result;\n+                _S_destr_concat_char_iter(this->_M_tree_ptr, __s, __e - __s);\n+            _S_unref(this->_M_tree_ptr);\n+            this->_M_tree_ptr = __result;\n             return *this;\n         }\n \n         rope& append(const_iterator __s, const_iterator __e) {\n             _Self_destruct_ptr __appendee(_S_substring(\n               __s._M_root, __s._M_current_pos, __e._M_current_pos));\n             _RopeRep* __result = \n-              _S_concat(_M_tree_ptr, (_RopeRep*)__appendee);\n-            _S_unref(_M_tree_ptr);\n-            _M_tree_ptr = __result;\n+              _S_concat(this->_M_tree_ptr, (_RopeRep*)__appendee);\n+            _S_unref(this->_M_tree_ptr);\n+            this->_M_tree_ptr = __result;\n             return *this;\n         }\n \n         rope& append(_CharT __c) {\n             _RopeRep* __result = \n-              _S_destr_concat_char_iter(_M_tree_ptr, &__c, 1);\n-            _S_unref(_M_tree_ptr);\n-            _M_tree_ptr = __result;\n+              _S_destr_concat_char_iter(this->_M_tree_ptr, &__c, 1);\n+            _S_unref(this->_M_tree_ptr);\n+            this->_M_tree_ptr = __result;\n             return *this;\n         }\n \n         rope& append() { return append(_CharT()); }  // XXX why?\n \n         rope& append(const rope& __y) {\n-            _RopeRep* __result = _S_concat(_M_tree_ptr, __y._M_tree_ptr);\n-            _S_unref(_M_tree_ptr);\n-            _M_tree_ptr = __result;\n+            _RopeRep* __result = _S_concat(this->_M_tree_ptr, __y._M_tree_ptr);\n+            _S_unref(this->_M_tree_ptr);\n+            this->_M_tree_ptr = __result;\n             return *this;\n         }\n \n@@ -1846,8 +1855,8 @@ class rope : public _Rope_base<_CharT,_Alloc> {\n         }\n \n         void swap(rope& __b) {\n-            _RopeRep* __tmp = _M_tree_ptr;\n-            _M_tree_ptr = __b._M_tree_ptr;\n+            _RopeRep* __tmp = this->_M_tree_ptr;\n+            this->_M_tree_ptr = __b._M_tree_ptr;\n             __b._M_tree_ptr = __tmp;\n         }\n \n@@ -1875,9 +1884,9 @@ class rope : public _Rope_base<_CharT,_Alloc> {\n     public:\n         void insert(size_t __p, const rope& __r) {\n             _RopeRep* __result = \n-              replace(_M_tree_ptr, __p, __p, __r._M_tree_ptr);\n-            _S_unref(_M_tree_ptr);\n-            _M_tree_ptr = __result;\n+              replace(this->_M_tree_ptr, __p, __p, __r._M_tree_ptr);\n+            _S_unref(this->_M_tree_ptr);\n+            this->_M_tree_ptr = __result;\n         }\n \n         void insert(size_t __p, size_t __n, _CharT __c) {\n@@ -1886,16 +1895,17 @@ class rope : public _Rope_base<_CharT,_Alloc> {\n         }\n \n         void insert(size_t __p, const _CharT* __i, size_t __n) {\n-            _Self_destruct_ptr __left(_S_substring(_M_tree_ptr, 0, __p));\n-            _Self_destruct_ptr __right(_S_substring(_M_tree_ptr, __p, size()));\n+            _Self_destruct_ptr __left(_S_substring(this->_M_tree_ptr, 0, __p));\n+            _Self_destruct_ptr __right(_S_substring(this->_M_tree_ptr,\n+\t\t\t\t\t\t    __p, size()));\n             _Self_destruct_ptr __left_result(\n               _S_concat_char_iter(__left, __i, __n));\n                 // _S_ destr_concat_char_iter should be safe here.\n                 // But as it stands it's probably not a win, since __left\n                 // is likely to have additional references.\n             _RopeRep* __result = _S_concat(__left_result, __right);\n-            _S_unref(_M_tree_ptr);\n-            _M_tree_ptr = __result;\n+            _S_unref(this->_M_tree_ptr);\n+            this->_M_tree_ptr = __result;\n         }\n \n         void insert(size_t __p, const _CharT* __c_string) {\n@@ -1932,9 +1942,9 @@ class rope : public _Rope_base<_CharT,_Alloc> {\n \n         void replace(size_t __p, size_t __n, const rope& __r) {\n             _RopeRep* __result = \n-              replace(_M_tree_ptr, __p, __p + __n, __r._M_tree_ptr);\n-            _S_unref(_M_tree_ptr);\n-            _M_tree_ptr = __result;\n+              replace(this->_M_tree_ptr, __p, __p + __n, __r._M_tree_ptr);\n+            _S_unref(this->_M_tree_ptr);\n+            this->_M_tree_ptr = __result;\n         }\n \n         void replace(size_t __p, size_t __n, \n@@ -2005,9 +2015,9 @@ class rope : public _Rope_base<_CharT,_Alloc> {\n \n         // Erase, (position, size) variant.\n         void erase(size_t __p, size_t __n) {\n-            _RopeRep* __result = replace(_M_tree_ptr, __p, __p + __n, 0);\n-            _S_unref(_M_tree_ptr);\n-            _M_tree_ptr = __result;\n+            _RopeRep* __result = replace(this->_M_tree_ptr, __p, __p + __n, 0);\n+            _S_unref(this->_M_tree_ptr);\n+            this->_M_tree_ptr = __result;\n         }\n \n         // Erase, single character\n@@ -2091,31 +2101,35 @@ class rope : public _Rope_base<_CharT,_Alloc> {\n \n         rope substr(size_t __start, size_t __len = 1) const {\n             return rope<_CharT,_Alloc>(\n-                        _S_substring(_M_tree_ptr, __start, __start + __len));\n+                        _S_substring(this->_M_tree_ptr,\n+\t\t\t\t     __start,\n+\t\t\t\t     __start + __len));\n         }\n \n         rope substr(iterator __start, iterator __end) const {\n             return rope<_CharT,_Alloc>(\n-                _S_substring(_M_tree_ptr, __start.index(), __end.index()));\n+                _S_substring(this->_M_tree_ptr,\n+\t\t\t     __start.index(),\n+\t\t\t     __end.index()));\n         }\n         \n         rope substr(iterator __start) const {\n             size_t __pos = __start.index();\n             return rope<_CharT,_Alloc>(\n-                        _S_substring(_M_tree_ptr, __pos, __pos + 1));\n+                        _S_substring(this->_M_tree_ptr, __pos, __pos + 1));\n         }\n         \n         rope substr(const_iterator __start, const_iterator __end) const {\n             // This might eventually take advantage of the cache in the\n             // iterator.\n             return rope<_CharT,_Alloc>(\n-              _S_substring(_M_tree_ptr, __start.index(), __end.index()));\n+              _S_substring(this->_M_tree_ptr, __start.index(), __end.index()));\n         }\n \n         rope<_CharT,_Alloc> substr(const_iterator __start) {\n             size_t __pos = __start.index();\n             return rope<_CharT,_Alloc>(\n-              _S_substring(_M_tree_ptr, __pos, __pos + 1));\n+              _S_substring(this->_M_tree_ptr, __pos, __pos + 1));\n         }\n \n         static const size_type npos;"}, {"sha": "0c7bf180550766e6f1b9cbf5c013d47d71e7053c", "filename": "libstdc++-v3/include/std/std_fstream.h", "status": "modified", "additions": 25, "deletions": 22, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fbc5ae72379506e4344297591db49fceac3a799/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_fstream.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fbc5ae72379506e4344297591db49fceac3a799/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_fstream.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_fstream.h?ref=8fbc5ae72379506e4344297591db49fceac3a799", "patch": "@@ -1,6 +1,6 @@\n // File based streams -*- C++ -*-\n \n-// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002\n+// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003\n // Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n@@ -311,14 +311,15 @@ namespace std\n       virtual int\n       sync()\n       {\n-\tbool __testput = _M_out_cur && _M_out_beg < _M_out_end;\n+\tbool __testput = this->_M_out_cur\n+\t  && this->_M_out_beg < this->_M_out_end;\n \n \t// Make sure that the internal buffer resyncs its idea of\n \t// the file position with the external file.\n \tif (__testput)\n \t  {\n \t    // Need to restore current position after the write.\n-\t    off_type __off = _M_out_cur - _M_out_end;\n+\t    off_type __off = this->_M_out_cur - this->_M_out_end;\n \t    _M_really_overflow(); // _M_file.sync() will be called within\n \t    if (__off)\n \t      _M_file.seekoff(__off, ios_base::cur);\n@@ -339,14 +340,14 @@ namespace std\n       {\n \tstreamsize __ret = 0;\n \t// Clear out pback buffer before going on to the real deal...\n-\tif (_M_pback_init)\n+\tif (this->_M_pback_init)\n \t  {\n-\t    while (__ret < __n && _M_in_cur < _M_in_end)\n+\t    while (__ret < __n && this->_M_in_cur < this->_M_in_end)\n \t      {\n-\t\t*__s = *_M_in_cur;\n+\t\t*__s = *this->_M_in_cur;\n \t\t++__ret;\n \t\t++__s;\n-\t\t++_M_in_cur;\n+\t\t++this->_M_in_cur;\n \t      }\n \t    _M_pback_destroy();\n \t  }\n@@ -386,11 +387,11 @@ namespace std\n       void\n       _M_set_indeterminate(void)\n       {\n-\tif (_M_mode & ios_base::in)\n-\t  this->setg(_M_buf, _M_buf, _M_buf);\n-\tif (_M_mode & ios_base::out)\n-\t  this->setp(_M_buf, _M_buf);\n-\t_M_filepos = _M_buf;\n+\tif (this->_M_mode & ios_base::in)\n+\t  this->setg(this->_M_buf, this->_M_buf, this->_M_buf);\n+\tif (this->_M_mode & ios_base::out)\n+\t  this->setp(this->_M_buf, this->_M_buf);\n+\t_M_filepos = this->_M_buf;\n       }\n \n       /**\n@@ -401,13 +402,13 @@ namespace std\n       void\n       _M_set_determinate(off_type __off)\n       {\n-\tbool __testin = _M_mode & ios_base::in;\n-\tbool __testout = _M_mode & ios_base::out;\n+\tbool __testin = this->_M_mode & ios_base::in;\n+\tbool __testout = this->_M_mode & ios_base::out;\n \tif (__testin)\n-\t  this->setg(_M_buf, _M_buf, _M_buf + __off);\n+\t  this->setg(this->_M_buf, this->_M_buf, this->_M_buf + __off);\n \tif (__testout)\n-\t  this->setp(_M_buf, _M_buf + __off);\n-\t_M_filepos = _M_buf + __off;\n+\t  this->setp(this->_M_buf, this->_M_buf + __off);\n+\t_M_filepos = this->_M_buf + __off;\n       }\n \n       /**\n@@ -420,12 +421,14 @@ namespace std\n       { \n \tbool __ret = false;\n \t// Don't return true if unbuffered.\n-\tif (_M_buf)\n+\tif (this->_M_buf)\n \t  {\n-\t    if (_M_mode & ios_base::in)\n-\t      __ret = _M_in_beg == _M_in_cur && _M_in_cur == _M_in_end;\n-\t    if (_M_mode & ios_base::out)\n-\t      __ret = _M_out_beg == _M_out_cur && _M_out_cur == _M_out_end;\n+\t    if (this->_M_mode & ios_base::in)\n+\t      __ret = this->_M_in_beg == this->_M_in_cur\n+\t\t&& this->_M_in_cur == this->_M_in_end;\n+\t    if (this->_M_mode & ios_base::out)\n+\t      __ret = this->_M_out_beg == this->_M_out_cur\n+\t\t&& this->_M_out_cur == this->_M_out_end;\n \t  }\n \treturn __ret;\n       }"}, {"sha": "0ad52d023c8cbab1bddb149e2e4db7f476fd78f8", "filename": "libstdc++-v3/include/std/std_sstream.h", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fbc5ae72379506e4344297591db49fceac3a799/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_sstream.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fbc5ae72379506e4344297591db49fceac3a799/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_sstream.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_sstream.h?ref=8fbc5ae72379506e4344297591db49fceac3a799", "patch": "@@ -1,6 +1,6 @@\n // String based streams -*- C++ -*-\n \n-// Copyright (C) 1997, 1998, 1999, 2002 Free Software Foundation, Inc.\n+// Copyright (C) 1997, 1998, 1999, 2002, 2003 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -133,16 +133,17 @@ namespace std\n       __string_type\n       str() const\n       {\n-\tif (_M_mode & ios_base::out)\n+\tif (this->_M_mode & ios_base::out)\n \t  {\n \t    // This is the deal: _M_string.size() is a value that\n \t    // represents the size of the initial string that makes\n \t    // _M_string, and may not be the correct size of the\n \t    // current stringbuf internal buffer.\n \t    __size_type __len = _M_string.size();\n-\t    if (_M_out_cur > _M_out_beg)\n-\t      __len = std::max(__size_type(_M_out_end - _M_out_beg), __len);\n-\t    return __string_type(_M_out_beg, _M_out_beg + __len);\n+\t    if (this->_M_out_cur > this->_M_out_beg)\n+\t      __len = std::max(__size_type(this->_M_out_end \n+\t\t\t\t\t   - this->_M_out_beg), __len);\n+\t    return __string_type(this->_M_out_beg, this->_M_out_beg + __len);\n \t  }\n \telse\n \t  return _M_string;\n@@ -160,7 +161,7 @@ namespace std\n       {\n \t// Cannot use _M_string = __s, since v3 strings are COW.\n \t_M_string.assign(__s.data(), __s.size());\n-\t_M_stringbuf_init(_M_mode);\n+\t_M_stringbuf_init(this->_M_mode);\n       }\n \n     protected:\n@@ -178,16 +179,16 @@ namespace std\n \t// necessary as ostringstreams are implemented with the\n \t// streambufs having control of the allocation and\n \t// re-allocation of the internal string object, _M_string.\n-\t_M_buf_size = _M_string.size();\n+\tthis->_M_buf_size = _M_string.size();\n \n \t// NB: Start ostringstream buffers at 512 bytes. This is an\n \t// experimental value (pronounced \"arbitrary\" in some of the\n \t// hipper english-speaking countries), and can be changed to\n \t// suit particular needs.\n-\t_M_buf_size_opt = 512;\n-\t_M_mode = __mode;\n-\tif (_M_mode & (ios_base::ate | ios_base::app))\n-\t  _M_really_sync(0, _M_buf_size);\n+\tthis->_M_buf_size_opt = 512;\n+\tthis->_M_mode = __mode;\n+\tif (this->_M_mode & (ios_base::ate | ios_base::app))\n+\t  _M_really_sync(0, this->_M_buf_size);\n \telse\n \t  _M_really_sync(0, 0);\n       }\n@@ -197,7 +198,7 @@ namespace std\n       virtual int_type\n       underflow()\n       {\n-\tif (_M_in_cur && _M_in_cur < _M_in_end)\n+\tif (this->_M_in_cur && this->_M_in_cur < this->_M_in_end)\n \t  return traits_type::to_int_type(*gptr());\n \telse\n \t  return traits_type::eof();\n@@ -258,17 +259,17 @@ namespace std\n       _M_really_sync(__size_type __i, __size_type __o)\n       {\n \tchar_type* __base = const_cast<char_type*>(_M_string.data());\n-\tbool __testin = _M_mode & ios_base::in;\n-\tbool __testout = _M_mode & ios_base::out;\n+\tbool __testin = this->_M_mode & ios_base::in;\n+\tbool __testout = this->_M_mode & ios_base::out;\n \t__size_type __len = _M_string.size();\n \n-\t_M_buf = __base;\n+\tthis->_M_buf = __base;\n \tif (__testin)\n \t    this->setg(__base, __base + __i, __base + __len);\n \tif (__testout)\n \t  {\n \t    this->setp(__base, __base + __len);\n-\t    _M_out_cur += __o;\n+\t    this->_M_out_cur += __o;\n \t  }\n \treturn 0;\n       }"}]}